{
  "module_name": "efi-stub-helper.c",
  "hash_id": "b8b4f6e8bd834146dbc2f0558cee20175b211019d40870c3a0552a8ff3be0302",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/libstub/efi-stub-helper.c",
  "human_readable_source": "\n \n\n#include <linux/stdarg.h>\n\n#include <linux/efi.h>\n#include <linux/kernel.h>\n#include <asm/efi.h>\n#include <asm/setup.h>\n\n#include \"efistub.h\"\n\nbool efi_nochunk;\nbool efi_nokaslr = !IS_ENABLED(CONFIG_RANDOMIZE_BASE);\nbool efi_novamap;\n\nstatic bool efi_noinitrd;\nstatic bool efi_nosoftreserve;\nstatic bool efi_disable_pci_dma = IS_ENABLED(CONFIG_EFI_DISABLE_PCI_DMA);\n\nbool __pure __efi_soft_reserve_enabled(void)\n{\n\treturn !efi_nosoftreserve;\n}\n\n \nefi_status_t efi_parse_options(char const *cmdline)\n{\n\tsize_t len;\n\tefi_status_t status;\n\tchar *str, *buf;\n\n\tif (!cmdline)\n\t\treturn EFI_SUCCESS;\n\n\tlen = strnlen(cmdline, COMMAND_LINE_SIZE - 1) + 1;\n\tstatus = efi_bs_call(allocate_pool, EFI_LOADER_DATA, len, (void **)&buf);\n\tif (status != EFI_SUCCESS)\n\t\treturn status;\n\n\tmemcpy(buf, cmdline, len - 1);\n\tbuf[len - 1] = '\\0';\n\tstr = skip_spaces(buf);\n\n\twhile (*str) {\n\t\tchar *param, *val;\n\n\t\tstr = next_arg(str, &param, &val);\n\t\tif (!val && !strcmp(param, \"--\"))\n\t\t\tbreak;\n\n\t\tif (!strcmp(param, \"nokaslr\")) {\n\t\t\tefi_nokaslr = true;\n\t\t} else if (!strcmp(param, \"quiet\")) {\n\t\t\tefi_loglevel = CONSOLE_LOGLEVEL_QUIET;\n\t\t} else if (!strcmp(param, \"noinitrd\")) {\n\t\t\tefi_noinitrd = true;\n\t\t} else if (IS_ENABLED(CONFIG_X86_64) && !strcmp(param, \"no5lvl\")) {\n\t\t\tefi_no5lvl = true;\n\t\t} else if (!strcmp(param, \"efi\") && val) {\n\t\t\tefi_nochunk = parse_option_str(val, \"nochunk\");\n\t\t\tefi_novamap |= parse_option_str(val, \"novamap\");\n\n\t\t\tefi_nosoftreserve = IS_ENABLED(CONFIG_EFI_SOFT_RESERVE) &&\n\t\t\t\t\t    parse_option_str(val, \"nosoftreserve\");\n\n\t\t\tif (parse_option_str(val, \"disable_early_pci_dma\"))\n\t\t\t\tefi_disable_pci_dma = true;\n\t\t\tif (parse_option_str(val, \"no_disable_early_pci_dma\"))\n\t\t\t\tefi_disable_pci_dma = false;\n\t\t\tif (parse_option_str(val, \"debug\"))\n\t\t\t\tefi_loglevel = CONSOLE_LOGLEVEL_DEBUG;\n\t\t} else if (!strcmp(param, \"video\") &&\n\t\t\t   val && strstarts(val, \"efifb:\")) {\n\t\t\tefi_parse_option_graphics(val + strlen(\"efifb:\"));\n\t\t}\n\t}\n\tefi_bs_call(free_pool, buf);\n\treturn EFI_SUCCESS;\n}\n\n \nstatic\nbool efi_load_option_unpack(efi_load_option_unpacked_t *dest,\n\t\t\t    const efi_load_option_t *src, size_t size)\n{\n\tconst void *pos;\n\tu16 c;\n\tefi_device_path_protocol_t header;\n\tconst efi_char16_t *description;\n\tconst efi_device_path_protocol_t *file_path_list;\n\n\tif (size < offsetof(efi_load_option_t, variable_data))\n\t\treturn false;\n\tpos = src->variable_data;\n\tsize -= offsetof(efi_load_option_t, variable_data);\n\n\tif ((src->attributes & ~EFI_LOAD_OPTION_MASK) != 0)\n\t\treturn false;\n\n\t \n\tdescription = pos;\n\tdo {\n\t\tif (size < sizeof(c))\n\t\t\treturn false;\n\t\tc = *(const u16 *)pos;\n\t\tpos += sizeof(c);\n\t\tsize -= sizeof(c);\n\t} while (c != L'\\0');\n\n\t \n\tfile_path_list = pos;\n\tdo {\n\t\tif (size < sizeof(header))\n\t\t\treturn false;\n\t\theader = *(const efi_device_path_protocol_t *)pos;\n\t\tif (header.length < sizeof(header))\n\t\t\treturn false;\n\t\tif (size < header.length)\n\t\t\treturn false;\n\t\tpos += header.length;\n\t\tsize -= header.length;\n\t} while ((header.type != EFI_DEV_END_PATH && header.type != EFI_DEV_END_PATH2) ||\n\t\t (header.sub_type != EFI_DEV_END_ENTIRE));\n\tif (pos != (const void *)file_path_list + src->file_path_list_length)\n\t\treturn false;\n\n\tdest->attributes = src->attributes;\n\tdest->file_path_list_length = src->file_path_list_length;\n\tdest->description = description;\n\tdest->file_path_list = file_path_list;\n\tdest->optional_data_size = size;\n\tdest->optional_data = size ? pos : NULL;\n\n\treturn true;\n}\n\n \nvoid efi_apply_loadoptions_quirk(const void **load_options, u32 *load_options_size)\n{\n\tconst efi_load_option_t *load_option = *load_options;\n\tefi_load_option_unpacked_t load_option_unpacked;\n\n\tif (!IS_ENABLED(CONFIG_X86))\n\t\treturn;\n\tif (!load_option)\n\t\treturn;\n\tif (*load_options_size < sizeof(*load_option))\n\t\treturn;\n\tif ((load_option->attributes & ~EFI_LOAD_OPTION_BOOT_MASK) != 0)\n\t\treturn;\n\n\tif (!efi_load_option_unpack(&load_option_unpacked, load_option, *load_options_size))\n\t\treturn;\n\n\tefi_warn_once(FW_BUG \"LoadOptions is an EFI_LOAD_OPTION descriptor\\n\");\n\tefi_warn_once(FW_BUG \"Using OptionalData as a workaround\\n\");\n\n\t*load_options = load_option_unpacked.optional_data;\n\t*load_options_size = load_option_unpacked.optional_data_size;\n}\n\nenum efistub_event {\n\tEFISTUB_EVT_INITRD,\n\tEFISTUB_EVT_LOAD_OPTIONS,\n\tEFISTUB_EVT_COUNT,\n};\n\n#define STR_WITH_SIZE(s)\tsizeof(s), s\n\nstatic const struct {\n\tu32\t\tpcr_index;\n\tu32\t\tevent_id;\n\tu32\t\tevent_data_len;\n\tu8\t\tevent_data[52];\n} events[] = {\n\t[EFISTUB_EVT_INITRD] = {\n\t\t9,\n\t\tINITRD_EVENT_TAG_ID,\n\t\tSTR_WITH_SIZE(\"Linux initrd\")\n\t},\n\t[EFISTUB_EVT_LOAD_OPTIONS] = {\n\t\t9,\n\t\tLOAD_OPTIONS_EVENT_TAG_ID,\n\t\tSTR_WITH_SIZE(\"LOADED_IMAGE::LoadOptions\")\n\t},\n};\n\nstatic efi_status_t efi_measure_tagged_event(unsigned long load_addr,\n\t\t\t\t\t     unsigned long load_size,\n\t\t\t\t\t     enum efistub_event event)\n{\n\tefi_guid_t tcg2_guid = EFI_TCG2_PROTOCOL_GUID;\n\tefi_tcg2_protocol_t *tcg2 = NULL;\n\tefi_status_t status;\n\n\tefi_bs_call(locate_protocol, &tcg2_guid, NULL, (void **)&tcg2);\n\tif (tcg2) {\n\t\tstruct efi_measured_event {\n\t\t\tefi_tcg2_event_t\tevent_data;\n\t\t\tefi_tcg2_tagged_event_t tagged_event;\n\t\t\tu8\t\t\ttagged_event_data[];\n\t\t} *evt;\n\t\tint size = sizeof(*evt) + events[event].event_data_len;\n\n\t\tstatus = efi_bs_call(allocate_pool, EFI_LOADER_DATA, size,\n\t\t\t\t     (void **)&evt);\n\t\tif (status != EFI_SUCCESS)\n\t\t\tgoto fail;\n\n\t\tevt->event_data = (struct efi_tcg2_event){\n\t\t\t.event_size\t\t\t= size,\n\t\t\t.event_header.header_size\t= sizeof(evt->event_data.event_header),\n\t\t\t.event_header.header_version\t= EFI_TCG2_EVENT_HEADER_VERSION,\n\t\t\t.event_header.pcr_index\t\t= events[event].pcr_index,\n\t\t\t.event_header.event_type\t= EV_EVENT_TAG,\n\t\t};\n\n\t\tevt->tagged_event = (struct efi_tcg2_tagged_event){\n\t\t\t.tagged_event_id\t\t= events[event].event_id,\n\t\t\t.tagged_event_data_size\t\t= events[event].event_data_len,\n\t\t};\n\n\t\tmemcpy(evt->tagged_event_data, events[event].event_data,\n\t\t       events[event].event_data_len);\n\n\t\tstatus = efi_call_proto(tcg2, hash_log_extend_event, 0,\n\t\t\t\t\tload_addr, load_size, &evt->event_data);\n\t\tefi_bs_call(free_pool, evt);\n\n\t\tif (status != EFI_SUCCESS)\n\t\t\tgoto fail;\n\t\treturn EFI_SUCCESS;\n\t}\n\n\treturn EFI_UNSUPPORTED;\nfail:\n\tefi_warn(\"Failed to measure data for event %d: 0x%lx\\n\", event, status);\n\treturn status;\n}\n\n \nchar *efi_convert_cmdline(efi_loaded_image_t *image, int *cmd_line_len)\n{\n\tconst efi_char16_t *options = efi_table_attr(image, load_options);\n\tu32 options_size = efi_table_attr(image, load_options_size);\n\tint options_bytes = 0, safe_options_bytes = 0;   \n\tunsigned long cmdline_addr = 0;\n\tconst efi_char16_t *s2;\n\tbool in_quote = false;\n\tefi_status_t status;\n\tu32 options_chars;\n\n\tif (options_size > 0)\n\t\tefi_measure_tagged_event((unsigned long)options, options_size,\n\t\t\t\t\t EFISTUB_EVT_LOAD_OPTIONS);\n\n\tefi_apply_loadoptions_quirk((const void **)&options, &options_size);\n\toptions_chars = options_size / sizeof(efi_char16_t);\n\n\tif (options) {\n\t\ts2 = options;\n\t\twhile (options_bytes < COMMAND_LINE_SIZE && options_chars--) {\n\t\t\tefi_char16_t c = *s2++;\n\n\t\t\tif (c < 0x80) {\n\t\t\t\tif (c == L'\\0' || c == L'\\n')\n\t\t\t\t\tbreak;\n\t\t\t\tif (c == L'\"')\n\t\t\t\t\tin_quote = !in_quote;\n\t\t\t\telse if (!in_quote && isspace((char)c))\n\t\t\t\t\tsafe_options_bytes = options_bytes;\n\n\t\t\t\toptions_bytes++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\toptions_bytes += 2 + (c >= 0x800);\n\t\t\t \n\t\t\tif ((c & 0xfc00) == 0xd800) {\n\t\t\t\t \n\t\t\t\tif (!options_chars) {\n\t\t\t\t\toptions_bytes -= 3;\n\t\t\t\t} else if ((*s2 & 0xfc00) == 0xdc00) {\n\t\t\t\t\toptions_bytes++;\n\t\t\t\t\toptions_chars--;\n\t\t\t\t\ts2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (options_bytes >= COMMAND_LINE_SIZE) {\n\t\t\toptions_bytes = safe_options_bytes;\n\t\t\tefi_err(\"Command line is too long: truncated to %d bytes\\n\",\n\t\t\t\toptions_bytes);\n\t\t}\n\t}\n\n\toptions_bytes++;\t \n\n\tstatus = efi_bs_call(allocate_pool, EFI_LOADER_DATA, options_bytes,\n\t\t\t     (void **)&cmdline_addr);\n\tif (status != EFI_SUCCESS)\n\t\treturn NULL;\n\n\tsnprintf((char *)cmdline_addr, options_bytes, \"%.*ls\",\n\t\t options_bytes - 1, options);\n\n\t*cmd_line_len = options_bytes;\n\treturn (char *)cmdline_addr;\n}\n\n \nefi_status_t efi_exit_boot_services(void *handle, void *priv,\n\t\t\t\t    efi_exit_boot_map_processing priv_func)\n{\n\tstruct efi_boot_memmap *map;\n\tefi_status_t status;\n\n\tif (efi_disable_pci_dma)\n\t\tefi_pci_disable_bridge_busmaster();\n\n\tstatus = efi_get_memory_map(&map, true);\n\tif (status != EFI_SUCCESS)\n\t\treturn status;\n\n\tstatus = priv_func(map, priv);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_bs_call(free_pool, map);\n\t\treturn status;\n\t}\n\n\tstatus = efi_bs_call(exit_boot_services, handle, map->map_key);\n\n\tif (status == EFI_INVALID_PARAMETER) {\n\t\t \n\t\tmap->map_size = map->buff_size;\n\t\tstatus = efi_bs_call(get_memory_map,\n\t\t\t\t     &map->map_size,\n\t\t\t\t     &map->map,\n\t\t\t\t     &map->map_key,\n\t\t\t\t     &map->desc_size,\n\t\t\t\t     &map->desc_ver);\n\n\t\t \n\t\tif (status != EFI_SUCCESS)\n\t\t\treturn status;\n\n\t\tstatus = priv_func(map, priv);\n\t\t \n\t\tif (status != EFI_SUCCESS)\n\t\t\treturn status;\n\n\t\tstatus = efi_bs_call(exit_boot_services, handle, map->map_key);\n\t}\n\n\treturn status;\n}\n\n \nvoid *get_efi_config_table(efi_guid_t guid)\n{\n\tunsigned long tables = efi_table_attr(efi_system_table, tables);\n\tint nr_tables = efi_table_attr(efi_system_table, nr_tables);\n\tint i;\n\n\tfor (i = 0; i < nr_tables; i++) {\n\t\tefi_config_table_t *t = (void *)tables;\n\n\t\tif (efi_guidcmp(t->guid, guid) == 0)\n\t\t\treturn efi_table_attr(t, table);\n\n\t\ttables += efi_is_native() ? sizeof(efi_config_table_t)\n\t\t\t\t\t  : sizeof(efi_config_table_32_t);\n\t}\n\treturn NULL;\n}\n\n \nstatic const struct {\n\tstruct efi_vendor_dev_path\tvendor;\n\tstruct efi_generic_dev_path\tend;\n} __packed initrd_dev_path = {\n\t{\n\t\t{\n\t\t\tEFI_DEV_MEDIA,\n\t\t\tEFI_DEV_MEDIA_VENDOR,\n\t\t\tsizeof(struct efi_vendor_dev_path),\n\t\t},\n\t\tLINUX_EFI_INITRD_MEDIA_GUID\n\t}, {\n\t\tEFI_DEV_END_PATH,\n\t\tEFI_DEV_END_ENTIRE,\n\t\tsizeof(struct efi_generic_dev_path)\n\t}\n};\n\n \nstatic\nefi_status_t efi_load_initrd_dev_path(struct linux_efi_initrd *initrd,\n\t\t\t\t      unsigned long max)\n{\n\tefi_guid_t lf2_proto_guid = EFI_LOAD_FILE2_PROTOCOL_GUID;\n\tefi_device_path_protocol_t *dp;\n\tefi_load_file2_protocol_t *lf2;\n\tefi_handle_t handle;\n\tefi_status_t status;\n\n\tdp = (efi_device_path_protocol_t *)&initrd_dev_path;\n\tstatus = efi_bs_call(locate_device_path, &lf2_proto_guid, &dp, &handle);\n\tif (status != EFI_SUCCESS)\n\t\treturn status;\n\n\tstatus = efi_bs_call(handle_protocol, handle, &lf2_proto_guid,\n\t\t\t     (void **)&lf2);\n\tif (status != EFI_SUCCESS)\n\t\treturn status;\n\n\tinitrd->size = 0;\n\tstatus = efi_call_proto(lf2, load_file, dp, false, &initrd->size, NULL);\n\tif (status != EFI_BUFFER_TOO_SMALL)\n\t\treturn EFI_LOAD_ERROR;\n\n\tstatus = efi_allocate_pages(initrd->size, &initrd->base, max);\n\tif (status != EFI_SUCCESS)\n\t\treturn status;\n\n\tstatus = efi_call_proto(lf2, load_file, dp, false, &initrd->size,\n\t\t\t\t(void *)initrd->base);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_free(initrd->size, initrd->base);\n\t\treturn EFI_LOAD_ERROR;\n\t}\n\treturn EFI_SUCCESS;\n}\n\nstatic\nefi_status_t efi_load_initrd_cmdline(efi_loaded_image_t *image,\n\t\t\t\t     struct linux_efi_initrd *initrd,\n\t\t\t\t     unsigned long soft_limit,\n\t\t\t\t     unsigned long hard_limit)\n{\n\tif (image == NULL)\n\t\treturn EFI_UNSUPPORTED;\n\n\treturn handle_cmdline_files(image, L\"initrd=\", sizeof(L\"initrd=\") - 2,\n\t\t\t\t    soft_limit, hard_limit,\n\t\t\t\t    &initrd->base, &initrd->size);\n}\n\n \nefi_status_t efi_load_initrd(efi_loaded_image_t *image,\n\t\t\t     unsigned long soft_limit,\n\t\t\t     unsigned long hard_limit,\n\t\t\t     const struct linux_efi_initrd **out)\n{\n\tefi_guid_t tbl_guid = LINUX_EFI_INITRD_MEDIA_GUID;\n\tefi_status_t status = EFI_SUCCESS;\n\tstruct linux_efi_initrd initrd, *tbl;\n\n\tif (!IS_ENABLED(CONFIG_BLK_DEV_INITRD) || efi_noinitrd)\n\t\treturn EFI_SUCCESS;\n\n\tstatus = efi_load_initrd_dev_path(&initrd, hard_limit);\n\tif (status == EFI_SUCCESS) {\n\t\tefi_info(\"Loaded initrd from LINUX_EFI_INITRD_MEDIA_GUID device path\\n\");\n\t\tif (initrd.size > 0 &&\n\t\t    efi_measure_tagged_event(initrd.base, initrd.size,\n\t\t\t\t\t     EFISTUB_EVT_INITRD) == EFI_SUCCESS)\n\t\t\tefi_info(\"Measured initrd data into PCR 9\\n\");\n\t} else if (status == EFI_NOT_FOUND) {\n\t\tstatus = efi_load_initrd_cmdline(image, &initrd, soft_limit,\n\t\t\t\t\t\t hard_limit);\n\t\t \n\t\tif (status == EFI_UNSUPPORTED || status == EFI_NOT_READY)\n\t\t\treturn EFI_SUCCESS;\n\t\tif (status == EFI_SUCCESS)\n\t\t\tefi_info(\"Loaded initrd from command line option\\n\");\n\t}\n\tif (status != EFI_SUCCESS)\n\t\tgoto failed;\n\n\tstatus = efi_bs_call(allocate_pool, EFI_LOADER_DATA, sizeof(initrd),\n\t\t\t     (void **)&tbl);\n\tif (status != EFI_SUCCESS)\n\t\tgoto free_initrd;\n\n\t*tbl = initrd;\n\tstatus = efi_bs_call(install_configuration_table, &tbl_guid, tbl);\n\tif (status != EFI_SUCCESS)\n\t\tgoto free_tbl;\n\n\tif (out)\n\t\t*out = tbl;\n\treturn EFI_SUCCESS;\n\nfree_tbl:\n\tefi_bs_call(free_pool, tbl);\nfree_initrd:\n\tefi_free(initrd.size, initrd.base);\nfailed:\n\tefi_err(\"Failed to load initrd: 0x%lx\\n\", status);\n\treturn status;\n}\n\n \nefi_status_t efi_wait_for_key(unsigned long usec, efi_input_key_t *key)\n{\n\tefi_event_t events[2], timer;\n\tunsigned long index;\n\tefi_simple_text_input_protocol_t *con_in;\n\tefi_status_t status;\n\n\tcon_in = efi_table_attr(efi_system_table, con_in);\n\tif (!con_in)\n\t\treturn EFI_UNSUPPORTED;\n\tefi_set_event_at(events, 0, efi_table_attr(con_in, wait_for_key));\n\n\tstatus = efi_bs_call(create_event, EFI_EVT_TIMER, 0, NULL, NULL, &timer);\n\tif (status != EFI_SUCCESS)\n\t\treturn status;\n\n\tstatus = efi_bs_call(set_timer, timer, EfiTimerRelative,\n\t\t\t     EFI_100NSEC_PER_USEC * usec);\n\tif (status != EFI_SUCCESS)\n\t\treturn status;\n\tefi_set_event_at(events, 1, timer);\n\n\tstatus = efi_bs_call(wait_for_event, 2, events, &index);\n\tif (status == EFI_SUCCESS) {\n\t\tif (index == 0)\n\t\t\tstatus = efi_call_proto(con_in, read_keystroke, key);\n\t\telse\n\t\t\tstatus = EFI_TIMEOUT;\n\t}\n\n\tefi_bs_call(close_event, timer);\n\n\treturn status;\n}\n\n \nvoid efi_remap_image(unsigned long image_base, unsigned alloc_size,\n\t\t     unsigned long code_size)\n{\n\tefi_guid_t guid = EFI_MEMORY_ATTRIBUTE_PROTOCOL_GUID;\n\tefi_memory_attribute_protocol_t *memattr;\n\tefi_status_t status;\n\tu64 attr;\n\n\t \n\tstatus = efi_bs_call(locate_protocol, &guid, NULL, (void **)&memattr);\n\tif (status != EFI_SUCCESS)\n\t\treturn;\n\n\t\n\tstatus = memattr->get_memory_attributes(memattr, image_base,\n\t\t\t\t\t\talloc_size, &attr);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_warn(\"Failed to retrieve memory attributes for image region: 0x%lx\\n\",\n\t\t\t status);\n\t\treturn;\n\t}\n\n\t\n\tstatus = memattr->set_memory_attributes(memattr, image_base, code_size,\n\t\t\t\t\t\tEFI_MEMORY_RO);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_warn(\"Failed to remap code region read-only\\n\");\n\t\treturn;\n\t}\n\n\t\n\t\n\t\n\tif (attr & EFI_MEMORY_XP) {\n\t\tstatus = memattr->clear_memory_attributes(memattr, image_base,\n\t\t\t\t\t\t\t  code_size,\n\t\t\t\t\t\t\t  EFI_MEMORY_XP);\n\t\tif (status != EFI_SUCCESS)\n\t\t\tefi_warn(\"Failed to remap code region executable\\n\");\n\t} else {\n\t\tstatus = memattr->set_memory_attributes(memattr,\n\t\t\t\t\t\t\timage_base + code_size,\n\t\t\t\t\t\t\talloc_size - code_size,\n\t\t\t\t\t\t\tEFI_MEMORY_XP);\n\t\tif (status != EFI_SUCCESS)\n\t\t\tefi_warn(\"Failed to remap data region non-executable\\n\");\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}