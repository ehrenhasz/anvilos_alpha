{
  "module_name": "string.c",
  "hash_id": "1fcc038dc61f0478a9fd03c17f7844a4fe7b55c3fded7d097a51ab55f98a8762",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/libstub/string.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/string.h>\n\n#ifndef EFI_HAVE_STRLEN\n \nsize_t strlen(const char *s)\n{\n\tconst char *sc;\n\n\tfor (sc = s; *sc != '\\0'; ++sc)\n\t\t ;\n\treturn sc - s;\n}\n#endif\n\n#ifndef EFI_HAVE_STRNLEN\n \nsize_t strnlen(const char *s, size_t count)\n{\n\tconst char *sc;\n\n\tfor (sc = s; count-- && *sc != '\\0'; ++sc)\n\t\t ;\n\treturn sc - s;\n}\n#endif\n\n \nchar *strstr(const char *s1, const char *s2)\n{\n\tsize_t l1, l2;\n\n\tl2 = strlen(s2);\n\tif (!l2)\n\t\treturn (char *)s1;\n\tl1 = strlen(s1);\n\twhile (l1 >= l2) {\n\t\tl1--;\n\t\tif (!memcmp(s1, s2, l2))\n\t\t\treturn (char *)s1;\n\t\ts1++;\n\t}\n\treturn NULL;\n}\n\n#ifndef EFI_HAVE_STRCMP\n \nint strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n#endif\n\n \nint strncmp(const char *cs, const char *ct, size_t count)\n{\n\tunsigned char c1, c2;\n\n\twhile (count) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t\tcount--;\n\t}\n\treturn 0;\n}\n\n \n#define TOLOWER(x) ((x) | 0x20)\n\nstatic unsigned int simple_guess_base(const char *cp)\n{\n\tif (cp[0] == '0') {\n\t\tif (TOLOWER(cp[1]) == 'x' && isxdigit(cp[2]))\n\t\t\treturn 16;\n\t\telse\n\t\t\treturn 8;\n\t} else {\n\t\treturn 10;\n\t}\n}\n\n \n\nunsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base)\n{\n\tunsigned long long result = 0;\n\n\tif (!base)\n\t\tbase = simple_guess_base(cp);\n\n\tif (base == 16 && cp[0] == '0' && TOLOWER(cp[1]) == 'x')\n\t\tcp += 2;\n\n\twhile (isxdigit(*cp)) {\n\t\tunsigned int value;\n\n\t\tvalue = isdigit(*cp) ? *cp - '0' : TOLOWER(*cp) - 'a' + 10;\n\t\tif (value >= base)\n\t\t\tbreak;\n\t\tresult = result * base + value;\n\t\tcp++;\n\t}\n\tif (endp)\n\t\t*endp = (char *)cp;\n\n\treturn result;\n}\n\nlong simple_strtol(const char *cp, char **endp, unsigned int base)\n{\n\tif (*cp == '-')\n\t\treturn -simple_strtoull(cp + 1, endp, base);\n\n\treturn simple_strtoull(cp, endp, base);\n}\n\n#ifdef CONFIG_EFI_PARAMS_FROM_FDT\n#ifndef EFI_HAVE_STRRCHR\n \nchar *strrchr(const char *s, int c)\n{\n\tconst char *last = NULL;\n\tdo {\n\t\tif (*s == (char)c)\n\t\t\tlast = s;\n\t} while (*s++);\n\treturn (char *)last;\n}\n#endif\n#ifndef EFI_HAVE_MEMCHR\n \nvoid *memchr(const void *s, int c, size_t n)\n{\n\tconst unsigned char *p = s;\n\twhile (n-- != 0) {\n\t\tif ((unsigned char)c == *p++) {\n\t\t\treturn (void *)(p - 1);\n\t\t}\n\t}\n\treturn NULL;\n}\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}