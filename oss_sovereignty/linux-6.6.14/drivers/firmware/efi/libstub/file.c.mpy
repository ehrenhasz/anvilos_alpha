{
  "module_name": "file.c",
  "hash_id": "e6553f8c6c23acbc126e084c9b625f9c8f0e029cf7cebd751b18ed46182beca5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/libstub/file.c",
  "human_readable_source": "\n \n\n#include <linux/efi.h>\n#include <asm/efi.h>\n\n#include \"efistub.h\"\n\n#define MAX_FILENAME_SIZE\t256\n\n \n#define EFI_READ_CHUNK_SIZE\tSZ_1M\n\nstruct finfo {\n\tefi_file_info_t info;\n\tefi_char16_t\tfilename[MAX_FILENAME_SIZE];\n};\n\nstatic efi_status_t efi_open_file(efi_file_protocol_t *volume,\n\t\t\t\t  struct finfo *fi,\n\t\t\t\t  efi_file_protocol_t **handle,\n\t\t\t\t  unsigned long *file_size)\n{\n\tefi_guid_t info_guid = EFI_FILE_INFO_ID;\n\tefi_file_protocol_t *fh;\n\tunsigned long info_sz;\n\tefi_status_t status;\n\tefi_char16_t *c;\n\n\t \n\tfor (c = fi->filename; *c != L'\\0'; c++) {\n\t\tif (*c == L'/')\n\t\t\t*c = L'\\\\';\n\t}\n\n\tstatus = efi_call_proto(volume, open, &fh, fi->filename,\n\t\t\t\tEFI_FILE_MODE_READ, 0);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"Failed to open file: %ls\\n\", fi->filename);\n\t\treturn status;\n\t}\n\n\tinfo_sz = sizeof(struct finfo);\n\tstatus = efi_call_proto(fh, get_info, &info_guid, &info_sz, fi);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"Failed to get file info\\n\");\n\t\tefi_call_proto(fh, close);\n\t\treturn status;\n\t}\n\n\t*handle = fh;\n\t*file_size = fi->info.file_size;\n\treturn EFI_SUCCESS;\n}\n\nstatic efi_status_t efi_open_volume(efi_loaded_image_t *image,\n\t\t\t\t    efi_file_protocol_t **fh)\n{\n\tefi_guid_t fs_proto = EFI_FILE_SYSTEM_GUID;\n\tefi_simple_file_system_protocol_t *io;\n\tefi_status_t status;\n\n\tstatus = efi_bs_call(handle_protocol, efi_table_attr(image, device_handle),\n\t\t\t     &fs_proto, (void **)&io);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"Failed to handle fs_proto\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = efi_call_proto(io, open_volume, fh);\n\tif (status != EFI_SUCCESS)\n\t\tefi_err(\"Failed to open volume\\n\");\n\n\treturn status;\n}\n\nstatic int find_file_option(const efi_char16_t *cmdline, int cmdline_len,\n\t\t\t    const efi_char16_t *prefix, int prefix_size,\n\t\t\t    efi_char16_t *result, int result_len)\n{\n\tint prefix_len = prefix_size / 2;\n\tbool found = false;\n\tint i;\n\n\tfor (i = prefix_len; i < cmdline_len; i++) {\n\t\tif (!memcmp(&cmdline[i - prefix_len], prefix, prefix_size)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn 0;\n\n\t \n\twhile (i < cmdline_len && (cmdline[i] == L'/' || cmdline[i] == L'\\\\'))\n\t\ti++;\n\n\twhile (--result_len > 0 && i < cmdline_len) {\n\t\tefi_char16_t c = cmdline[i++];\n\n\t\tif (c == L'\\0' || c == L'\\n' || c == L' ')\n\t\t\tbreak;\n\t\t*result++ = c;\n\t}\n\t*result = L'\\0';\n\treturn i;\n}\n\nstatic efi_status_t efi_open_device_path(efi_file_protocol_t **volume,\n\t\t\t\t\t struct finfo *fi)\n{\n\tefi_guid_t text_to_dp_guid = EFI_DEVICE_PATH_FROM_TEXT_PROTOCOL_GUID;\n\tstatic efi_device_path_from_text_protocol_t *text_to_dp = NULL;\n\tefi_guid_t fs_proto = EFI_FILE_SYSTEM_GUID;\n\tefi_device_path_protocol_t *initrd_dp;\n\tefi_simple_file_system_protocol_t *io;\n\tstruct efi_file_path_dev_path *fpath;\n\tefi_handle_t handle;\n\tefi_status_t status;\n\n\t \n\tif (!text_to_dp &&\n\t    efi_bs_call(locate_protocol, &text_to_dp_guid, NULL,\n\t\t\t(void **)&text_to_dp) != EFI_SUCCESS)\n\t\treturn EFI_UNSUPPORTED;\n\n\n\t \n\tinitrd_dp = efi_fn_call(text_to_dp, convert_text_to_device_path,\n\t\t\t\tfi->filename);\n\n\t \n\tif ((efi_bs_call(locate_device_path, &fs_proto, &initrd_dp, &handle) ?:\n\t     efi_bs_call(handle_protocol, handle, &fs_proto, (void **)&io))\n\t    != EFI_SUCCESS)\n\t\treturn EFI_NOT_FOUND;\n\n\t \n\tif (initrd_dp->type != EFI_DEV_MEDIA ||\n\t    initrd_dp->sub_type != EFI_DEV_MEDIA_FILE) {\n\t\tefi_warn(\"Unexpected device path node type: (%x, %x)\\n\",\n\t\t\t initrd_dp->type, initrd_dp->sub_type);\n\t\treturn EFI_LOAD_ERROR;\n\t}\n\n\t \n\tfpath = (struct efi_file_path_dev_path *)initrd_dp;\n\tmemcpy(fi->filename, fpath->filename,\n\t       min(sizeof(fi->filename),\n\t\t   fpath->header.length - sizeof(fpath->header)));\n\n\tstatus = efi_call_proto(io, open_volume, volume);\n\tif (status != EFI_SUCCESS)\n\t\tefi_err(\"Failed to open volume\\n\");\n\n\treturn status;\n}\n\n \nefi_status_t handle_cmdline_files(efi_loaded_image_t *image,\n\t\t\t\t  const efi_char16_t *optstr,\n\t\t\t\t  int optstr_size,\n\t\t\t\t  unsigned long soft_limit,\n\t\t\t\t  unsigned long hard_limit,\n\t\t\t\t  unsigned long *load_addr,\n\t\t\t\t  unsigned long *load_size)\n{\n\tconst efi_char16_t *cmdline = efi_table_attr(image, load_options);\n\tu32 cmdline_len = efi_table_attr(image, load_options_size);\n\tunsigned long efi_chunk_size = ULONG_MAX;\n\tefi_file_protocol_t *volume = NULL;\n\tefi_file_protocol_t *file;\n\tunsigned long alloc_addr;\n\tunsigned long alloc_size;\n\tefi_status_t status;\n\tint offset;\n\n\tif (!load_addr || !load_size)\n\t\treturn EFI_INVALID_PARAMETER;\n\n\tefi_apply_loadoptions_quirk((const void **)&cmdline, &cmdline_len);\n\tcmdline_len /= sizeof(*cmdline);\n\n\tif (IS_ENABLED(CONFIG_X86) && !efi_nochunk)\n\t\tefi_chunk_size = EFI_READ_CHUNK_SIZE;\n\n\talloc_addr = alloc_size = 0;\n\tdo {\n\t\tstruct finfo fi;\n\t\tunsigned long size;\n\t\tvoid *addr;\n\n\t\toffset = find_file_option(cmdline, cmdline_len,\n\t\t\t\t\t  optstr, optstr_size,\n\t\t\t\t\t  fi.filename, ARRAY_SIZE(fi.filename));\n\n\t\tif (!offset)\n\t\t\tbreak;\n\n\t\tcmdline += offset;\n\t\tcmdline_len -= offset;\n\n\t\tstatus = efi_open_device_path(&volume, &fi);\n\t\tif (status == EFI_UNSUPPORTED || status == EFI_NOT_FOUND)\n\t\t\t \n\t\t\tstatus = efi_open_volume(image, &volume);\n\n\t\tif (status != EFI_SUCCESS)\n\t\t\tgoto err_free_alloc;\n\n\t\tstatus = efi_open_file(volume, &fi, &file, &size);\n\t\tif (status != EFI_SUCCESS)\n\t\t\tgoto err_close_volume;\n\n\t\t \n\t\tif (round_up(alloc_size + size, EFI_ALLOC_ALIGN) >\n\t\t    round_up(alloc_size, EFI_ALLOC_ALIGN)) {\n\t\t\tunsigned long old_addr = alloc_addr;\n\n\t\t\tstatus = EFI_OUT_OF_RESOURCES;\n\t\t\tif (soft_limit < hard_limit)\n\t\t\t\tstatus = efi_allocate_pages(alloc_size + size,\n\t\t\t\t\t\t\t    &alloc_addr,\n\t\t\t\t\t\t\t    soft_limit);\n\t\t\tif (status == EFI_OUT_OF_RESOURCES)\n\t\t\t\tstatus = efi_allocate_pages(alloc_size + size,\n\t\t\t\t\t\t\t    &alloc_addr,\n\t\t\t\t\t\t\t    hard_limit);\n\t\t\tif (status != EFI_SUCCESS) {\n\t\t\t\tefi_err(\"Failed to allocate memory for files\\n\");\n\t\t\t\tgoto err_close_file;\n\t\t\t}\n\n\t\t\tif (old_addr != 0) {\n\t\t\t\t \n\t\t\t\tmemcpy((void *)alloc_addr, (void *)old_addr, alloc_size);\n\t\t\t\tefi_free(alloc_size, old_addr);\n\t\t\t}\n\t\t}\n\n\t\taddr = (void *)alloc_addr + alloc_size;\n\t\talloc_size += size;\n\n\t\twhile (size) {\n\t\t\tunsigned long chunksize = min(size, efi_chunk_size);\n\n\t\t\tstatus = efi_call_proto(file, read, &chunksize, addr);\n\t\t\tif (status != EFI_SUCCESS) {\n\t\t\t\tefi_err(\"Failed to read file\\n\");\n\t\t\t\tgoto err_close_file;\n\t\t\t}\n\t\t\taddr += chunksize;\n\t\t\tsize -= chunksize;\n\t\t}\n\t\tefi_call_proto(file, close);\n\t\tefi_call_proto(volume, close);\n\t} while (offset > 0);\n\n\t*load_addr = alloc_addr;\n\t*load_size = alloc_size;\n\n\tif (*load_size == 0)\n\t\treturn EFI_NOT_READY;\n\treturn EFI_SUCCESS;\n\nerr_close_file:\n\tefi_call_proto(file, close);\n\nerr_close_volume:\n\tefi_call_proto(volume, close);\n\nerr_free_alloc:\n\tefi_free(alloc_size, alloc_addr);\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}