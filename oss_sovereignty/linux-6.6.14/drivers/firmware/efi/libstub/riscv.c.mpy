{
  "module_name": "riscv.c",
  "hash_id": "e7590fa7622e7d151661ac9a26c22da539d8c106ace2a197d5f3dd66feb84c52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/libstub/riscv.c",
  "human_readable_source": "\n \n\n#include <linux/efi.h>\n#include <linux/libfdt.h>\n\n#include <asm/efi.h>\n#include <asm/unaligned.h>\n\n#include \"efistub.h\"\n\ntypedef void __noreturn (*jump_kernel_func)(unsigned long, unsigned long);\n\nstatic unsigned long hartid;\n\nstatic int get_boot_hartid_from_fdt(void)\n{\n\tconst void *fdt;\n\tint chosen_node, len;\n\tconst void *prop;\n\n\tfdt = get_efi_config_table(DEVICE_TREE_GUID);\n\tif (!fdt)\n\t\treturn -EINVAL;\n\n\tchosen_node = fdt_path_offset(fdt, \"/chosen\");\n\tif (chosen_node < 0)\n\t\treturn -EINVAL;\n\n\tprop = fdt_getprop((void *)fdt, chosen_node, \"boot-hartid\", &len);\n\tif (!prop)\n\t\treturn -EINVAL;\n\n\tif (len == sizeof(u32))\n\t\thartid = (unsigned long) fdt32_to_cpu(*(fdt32_t *)prop);\n\telse if (len == sizeof(u64))\n\t\thartid = (unsigned long) fdt64_to_cpu(__get_unaligned_t(fdt64_t, prop));\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic efi_status_t get_boot_hartid_from_efi(void)\n{\n\tefi_guid_t boot_protocol_guid = RISCV_EFI_BOOT_PROTOCOL_GUID;\n\tstruct riscv_efi_boot_protocol *boot_protocol;\n\tefi_status_t status;\n\n\tstatus = efi_bs_call(locate_protocol, &boot_protocol_guid, NULL,\n\t\t\t     (void **)&boot_protocol);\n\tif (status != EFI_SUCCESS)\n\t\treturn status;\n\treturn efi_call_proto(boot_protocol, get_boot_hartid, &hartid);\n}\n\nefi_status_t check_platform_features(void)\n{\n\tefi_status_t status;\n\tint ret;\n\n\tstatus = get_boot_hartid_from_efi();\n\tif (status != EFI_SUCCESS) {\n\t\tret = get_boot_hartid_from_fdt();\n\t\tif (ret) {\n\t\t\tefi_err(\"Failed to get boot hartid!\\n\");\n\t\t\treturn EFI_UNSUPPORTED;\n\t\t}\n\t}\n\treturn EFI_SUCCESS;\n}\n\nunsigned long __weak stext_offset(void)\n{\n\t \n\treturn 0;\n}\n\nvoid __noreturn efi_enter_kernel(unsigned long entrypoint, unsigned long fdt,\n\t\t\t\t unsigned long fdt_size)\n{\n\tunsigned long kernel_entry = entrypoint + stext_offset();\n\tjump_kernel_func jump_kernel = (jump_kernel_func)kernel_entry;\n\n\t \n\tcsr_write(CSR_SATP, 0);\n\tjump_kernel(hartid, fdt);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}