{
  "module_name": "arm64.c",
  "hash_id": "8021a59a339b68c4691ff642c98e888e4aa65d77ff150e1fd830fd32a48052b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/libstub/arm64.c",
  "human_readable_source": "\n \n\n\n#include <linux/efi.h>\n#include <asm/efi.h>\n#include <asm/image.h>\n#include <asm/memory.h>\n#include <asm/sysreg.h>\n\n#include \"efistub.h\"\n\nstatic bool system_needs_vamap(void)\n{\n\tconst struct efi_smbios_type4_record *record;\n\tconst u32 __aligned(1) *socid;\n\tconst u8 *version;\n\n\t \n\trecord = (struct efi_smbios_type4_record *)efi_get_smbios_record(4);\n\tif (!record)\n\t\treturn false;\n\n\tsocid = (u32 *)record->processor_id;\n\tswitch (*socid & 0xffff000f) {\n\t\tstatic char const altra[] = \"Ampere(TM) Altra(TM) Processor\";\n\t\tstatic char const emag[] = \"eMAG\";\n\n\tdefault:\n\t\tversion = efi_get_smbios_string(&record->header, 4,\n\t\t\t\t\t\tprocessor_version);\n\t\tif (!version || (strncmp(version, altra, sizeof(altra) - 1) &&\n\t\t\t\t strncmp(version, emag, sizeof(emag) - 1)))\n\t\t\tbreak;\n\n\t\tfallthrough;\n\n\tcase 0x0a160001:\t\n\tcase 0x0a160002:\t\n\t\tefi_warn(\"Working around broken SetVirtualAddressMap()\\n\");\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nefi_status_t check_platform_features(void)\n{\n\tu64 tg;\n\n\t \n\tif (VA_BITS_MIN >= 48 && !system_needs_vamap())\n\t\tefi_novamap = true;\n\n\t \n\tif (IS_ENABLED(CONFIG_ARM64_4K_PAGES))\n\t\treturn EFI_SUCCESS;\n\n\ttg = (read_cpuid(ID_AA64MMFR0_EL1) >> ID_AA64MMFR0_EL1_TGRAN_SHIFT) & 0xf;\n\tif (tg < ID_AA64MMFR0_EL1_TGRAN_SUPPORTED_MIN || tg > ID_AA64MMFR0_EL1_TGRAN_SUPPORTED_MAX) {\n\t\tif (IS_ENABLED(CONFIG_ARM64_64K_PAGES))\n\t\t\tefi_err(\"This 64 KB granular kernel is not supported by your CPU\\n\");\n\t\telse\n\t\t\tefi_err(\"This 16 KB granular kernel is not supported by your CPU\\n\");\n\t\treturn EFI_UNSUPPORTED;\n\t}\n\treturn EFI_SUCCESS;\n}\n\n#ifdef CONFIG_ARM64_WORKAROUND_CLEAN_CACHE\n#define DCTYPE\t\"civac\"\n#else\n#define DCTYPE\t\"cvau\"\n#endif\n\nu32 __weak code_size;\n\nvoid efi_cache_sync_image(unsigned long image_base,\n\t\t\t  unsigned long alloc_size)\n{\n\tu32 ctr = read_cpuid_effective_cachetype();\n\tu64 lsize = 4 << cpuid_feature_extract_unsigned_field(ctr,\n\t\t\t\t\t\tCTR_EL0_DminLine_SHIFT);\n\n\t \n\tif (!(ctr & BIT(CTR_EL0_IDC_SHIFT))) {\n\t\tunsigned long base = image_base;\n\t\tunsigned long size = code_size;\n\n\t\tdo {\n\t\t\tasm(\"dc \" DCTYPE \", %0\" :: \"r\"(base));\n\t\t\tbase += lsize;\n\t\t\tsize -= lsize;\n\t\t} while (size >= lsize);\n\t}\n\n\tasm(\"ic ialluis\");\n\tdsb(ish);\n\tisb();\n\n\tefi_remap_image(image_base, alloc_size, code_size);\n}\n\nunsigned long __weak primary_entry_offset(void)\n{\n\t \n       return 0;\n}\n\nvoid __noreturn efi_enter_kernel(unsigned long entrypoint,\n\t\t\t\t unsigned long fdt_addr,\n\t\t\t\t unsigned long fdt_size)\n{\n\tvoid (* __noreturn enter_kernel)(u64, u64, u64, u64);\n\n\tenter_kernel = (void *)entrypoint + primary_entry_offset();\n\tenter_kernel(fdt_addr, 0, 0, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}