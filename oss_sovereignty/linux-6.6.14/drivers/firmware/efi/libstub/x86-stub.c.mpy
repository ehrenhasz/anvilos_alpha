{
  "module_name": "x86-stub.c",
  "hash_id": "c6a91c58104fab5d4357d7eb468e56c22d64143f77f15b73ba6ae432e2cc49d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/libstub/x86-stub.c",
  "human_readable_source": "\n\n \n\n#include <linux/efi.h>\n#include <linux/pci.h>\n#include <linux/stddef.h>\n\n#include <asm/efi.h>\n#include <asm/e820/types.h>\n#include <asm/setup.h>\n#include <asm/desc.h>\n#include <asm/boot.h>\n#include <asm/kaslr.h>\n#include <asm/sev.h>\n\n#include \"efistub.h\"\n#include \"x86-stub.h\"\n\nconst efi_system_table_t *efi_system_table;\nconst efi_dxe_services_table_t *efi_dxe_table;\nstatic efi_loaded_image_t *image = NULL;\nstatic efi_memory_attribute_protocol_t *memattr;\n\ntypedef union sev_memory_acceptance_protocol sev_memory_acceptance_protocol_t;\nunion sev_memory_acceptance_protocol {\n\tstruct {\n\t\tefi_status_t (__efiapi * allow_unaccepted_memory)(\n\t\t\tsev_memory_acceptance_protocol_t *);\n\t};\n\tstruct {\n\t\tu32 allow_unaccepted_memory;\n\t} mixed_mode;\n};\n\nstatic efi_status_t\npreserve_pci_rom_image(efi_pci_io_protocol_t *pci, struct pci_setup_rom **__rom)\n{\n\tstruct pci_setup_rom *rom = NULL;\n\tefi_status_t status;\n\tunsigned long size;\n\tuint64_t romsize;\n\tvoid *romimage;\n\n\t \n\tromimage = efi_table_attr(pci, romimage);\n\tromsize = efi_table_attr(pci, romsize);\n\tif (!romimage || !romsize || romsize > SZ_16M)\n\t\treturn EFI_INVALID_PARAMETER;\n\n\tsize = romsize + sizeof(*rom);\n\n\tstatus = efi_bs_call(allocate_pool, EFI_LOADER_DATA, size,\n\t\t\t     (void **)&rom);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"Failed to allocate memory for 'rom'\\n\");\n\t\treturn status;\n\t}\n\n\tmemset(rom, 0, sizeof(*rom));\n\n\trom->data.type\t= SETUP_PCI;\n\trom->data.len\t= size - sizeof(struct setup_data);\n\trom->data.next\t= 0;\n\trom->pcilen\t= romsize;\n\t*__rom = rom;\n\n\tstatus = efi_call_proto(pci, pci.read, EfiPciIoWidthUint16,\n\t\t\t\tPCI_VENDOR_ID, 1, &rom->vendor);\n\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"Failed to read rom->vendor\\n\");\n\t\tgoto free_struct;\n\t}\n\n\tstatus = efi_call_proto(pci, pci.read, EfiPciIoWidthUint16,\n\t\t\t\tPCI_DEVICE_ID, 1, &rom->devid);\n\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"Failed to read rom->devid\\n\");\n\t\tgoto free_struct;\n\t}\n\n\tstatus = efi_call_proto(pci, get_location, &rom->segment, &rom->bus,\n\t\t\t\t&rom->device, &rom->function);\n\n\tif (status != EFI_SUCCESS)\n\t\tgoto free_struct;\n\n\tmemcpy(rom->romdata, romimage, romsize);\n\treturn status;\n\nfree_struct:\n\tefi_bs_call(free_pool, rom);\n\treturn status;\n}\n\n \nstatic void setup_efi_pci(struct boot_params *params)\n{\n\tefi_status_t status;\n\tvoid **pci_handle = NULL;\n\tefi_guid_t pci_proto = EFI_PCI_IO_PROTOCOL_GUID;\n\tunsigned long size = 0;\n\tstruct setup_data *data;\n\tefi_handle_t h;\n\tint i;\n\n\tstatus = efi_bs_call(locate_handle, EFI_LOCATE_BY_PROTOCOL,\n\t\t\t     &pci_proto, NULL, &size, pci_handle);\n\n\tif (status == EFI_BUFFER_TOO_SMALL) {\n\t\tstatus = efi_bs_call(allocate_pool, EFI_LOADER_DATA, size,\n\t\t\t\t     (void **)&pci_handle);\n\n\t\tif (status != EFI_SUCCESS) {\n\t\t\tefi_err(\"Failed to allocate memory for 'pci_handle'\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tstatus = efi_bs_call(locate_handle, EFI_LOCATE_BY_PROTOCOL,\n\t\t\t\t     &pci_proto, NULL, &size, pci_handle);\n\t}\n\n\tif (status != EFI_SUCCESS)\n\t\tgoto free_handle;\n\n\tdata = (struct setup_data *)(unsigned long)params->hdr.setup_data;\n\n\twhile (data && data->next)\n\t\tdata = (struct setup_data *)(unsigned long)data->next;\n\n\tfor_each_efi_handle(h, pci_handle, size, i) {\n\t\tefi_pci_io_protocol_t *pci = NULL;\n\t\tstruct pci_setup_rom *rom;\n\n\t\tstatus = efi_bs_call(handle_protocol, h, &pci_proto,\n\t\t\t\t     (void **)&pci);\n\t\tif (status != EFI_SUCCESS || !pci)\n\t\t\tcontinue;\n\n\t\tstatus = preserve_pci_rom_image(pci, &rom);\n\t\tif (status != EFI_SUCCESS)\n\t\t\tcontinue;\n\n\t\tif (data)\n\t\t\tdata->next = (unsigned long)rom;\n\t\telse\n\t\t\tparams->hdr.setup_data = (unsigned long)rom;\n\n\t\tdata = (struct setup_data *)rom;\n\t}\n\nfree_handle:\n\tefi_bs_call(free_pool, pci_handle);\n}\n\nstatic void retrieve_apple_device_properties(struct boot_params *boot_params)\n{\n\tefi_guid_t guid = APPLE_PROPERTIES_PROTOCOL_GUID;\n\tstruct setup_data *data, *new;\n\tefi_status_t status;\n\tu32 size = 0;\n\tapple_properties_protocol_t *p;\n\n\tstatus = efi_bs_call(locate_protocol, &guid, NULL, (void **)&p);\n\tif (status != EFI_SUCCESS)\n\t\treturn;\n\n\tif (efi_table_attr(p, version) != 0x10000) {\n\t\tefi_err(\"Unsupported properties proto version\\n\");\n\t\treturn;\n\t}\n\n\tefi_call_proto(p, get_all, NULL, &size);\n\tif (!size)\n\t\treturn;\n\n\tdo {\n\t\tstatus = efi_bs_call(allocate_pool, EFI_LOADER_DATA,\n\t\t\t\t     size + sizeof(struct setup_data),\n\t\t\t\t     (void **)&new);\n\t\tif (status != EFI_SUCCESS) {\n\t\t\tefi_err(\"Failed to allocate memory for 'properties'\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tstatus = efi_call_proto(p, get_all, new->data, &size);\n\n\t\tif (status == EFI_BUFFER_TOO_SMALL)\n\t\t\tefi_bs_call(free_pool, new);\n\t} while (status == EFI_BUFFER_TOO_SMALL);\n\n\tnew->type = SETUP_APPLE_PROPERTIES;\n\tnew->len  = size;\n\tnew->next = 0;\n\n\tdata = (struct setup_data *)(unsigned long)boot_params->hdr.setup_data;\n\tif (!data) {\n\t\tboot_params->hdr.setup_data = (unsigned long)new;\n\t} else {\n\t\twhile (data->next)\n\t\t\tdata = (struct setup_data *)(unsigned long)data->next;\n\t\tdata->next = (unsigned long)new;\n\t}\n}\n\nvoid efi_adjust_memory_range_protection(unsigned long start,\n\t\t\t\t\tunsigned long size)\n{\n\tefi_status_t status;\n\tefi_gcd_memory_space_desc_t desc;\n\tunsigned long end, next;\n\tunsigned long rounded_start, rounded_end;\n\tunsigned long unprotect_start, unprotect_size;\n\n\trounded_start = rounddown(start, EFI_PAGE_SIZE);\n\trounded_end = roundup(start + size, EFI_PAGE_SIZE);\n\n\tif (memattr != NULL) {\n\t\tefi_call_proto(memattr, clear_memory_attributes, rounded_start,\n\t\t\t       rounded_end - rounded_start, EFI_MEMORY_XP);\n\t\treturn;\n\t}\n\n\tif (efi_dxe_table == NULL)\n\t\treturn;\n\n\t \n\n\tfor (end = start + size; start < end; start = next) {\n\n\t\tstatus = efi_dxe_call(get_memory_space_descriptor, start, &desc);\n\n\t\tif (status != EFI_SUCCESS)\n\t\t\treturn;\n\n\t\tnext = desc.base_address + desc.length;\n\n\t\t \n\n\t\tif (desc.gcd_memory_type != EfiGcdMemoryTypeSystemMemory ||\n\t\t    (desc.attributes & (EFI_MEMORY_RO | EFI_MEMORY_XP)) == 0)\n\t\t\tcontinue;\n\n\t\tunprotect_start = max(rounded_start, (unsigned long)desc.base_address);\n\t\tunprotect_size = min(rounded_end, next) - unprotect_start;\n\n\t\tstatus = efi_dxe_call(set_memory_space_attributes,\n\t\t\t\t      unprotect_start, unprotect_size,\n\t\t\t\t      EFI_MEMORY_WB);\n\n\t\tif (status != EFI_SUCCESS) {\n\t\t\tefi_warn(\"Unable to unprotect memory range [%08lx,%08lx]: %lx\\n\",\n\t\t\t\t unprotect_start,\n\t\t\t\t unprotect_start + unprotect_size,\n\t\t\t\t status);\n\t\t}\n\t}\n}\n\nstatic void setup_unaccepted_memory(void)\n{\n\tefi_guid_t mem_acceptance_proto = OVMF_SEV_MEMORY_ACCEPTANCE_PROTOCOL_GUID;\n\tsev_memory_acceptance_protocol_t *proto;\n\tefi_status_t status;\n\n\tif (!IS_ENABLED(CONFIG_UNACCEPTED_MEMORY))\n\t\treturn;\n\n\t \n\tstatus = efi_bs_call(locate_protocol, &mem_acceptance_proto, NULL,\n\t\t\t     (void **)&proto);\n\tif (status != EFI_SUCCESS)\n\t\treturn;\n\n\tstatus = efi_call_proto(proto, allow_unaccepted_memory);\n\tif (status != EFI_SUCCESS)\n\t\tefi_err(\"Memory acceptance protocol failed\\n\");\n}\n\nstatic efi_char16_t *efistub_fw_vendor(void)\n{\n\tunsigned long vendor = efi_table_attr(efi_system_table, fw_vendor);\n\n\treturn (efi_char16_t *)vendor;\n}\n\nstatic const efi_char16_t apple[] = L\"Apple\";\n\nstatic void setup_quirks(struct boot_params *boot_params)\n{\n\tif (IS_ENABLED(CONFIG_APPLE_PROPERTIES) &&\n\t    !memcmp(efistub_fw_vendor(), apple, sizeof(apple)))\n\t\tretrieve_apple_device_properties(boot_params);\n}\n\n \nstatic efi_status_t\nsetup_uga(struct screen_info *si, efi_guid_t *uga_proto, unsigned long size)\n{\n\tefi_status_t status;\n\tu32 width, height;\n\tvoid **uga_handle = NULL;\n\tefi_uga_draw_protocol_t *uga = NULL, *first_uga;\n\tefi_handle_t handle;\n\tint i;\n\n\tstatus = efi_bs_call(allocate_pool, EFI_LOADER_DATA, size,\n\t\t\t     (void **)&uga_handle);\n\tif (status != EFI_SUCCESS)\n\t\treturn status;\n\n\tstatus = efi_bs_call(locate_handle, EFI_LOCATE_BY_PROTOCOL,\n\t\t\t     uga_proto, NULL, &size, uga_handle);\n\tif (status != EFI_SUCCESS)\n\t\tgoto free_handle;\n\n\theight = 0;\n\twidth = 0;\n\n\tfirst_uga = NULL;\n\tfor_each_efi_handle(handle, uga_handle, size, i) {\n\t\tefi_guid_t pciio_proto = EFI_PCI_IO_PROTOCOL_GUID;\n\t\tu32 w, h, depth, refresh;\n\t\tvoid *pciio;\n\n\t\tstatus = efi_bs_call(handle_protocol, handle, uga_proto,\n\t\t\t\t     (void **)&uga);\n\t\tif (status != EFI_SUCCESS)\n\t\t\tcontinue;\n\n\t\tpciio = NULL;\n\t\tefi_bs_call(handle_protocol, handle, &pciio_proto, &pciio);\n\n\t\tstatus = efi_call_proto(uga, get_mode, &w, &h, &depth, &refresh);\n\t\tif (status == EFI_SUCCESS && (!first_uga || pciio)) {\n\t\t\twidth = w;\n\t\t\theight = h;\n\n\t\t\t \n\t\t\tif (pciio)\n\t\t\t\tbreak;\n\n\t\t\tfirst_uga = uga;\n\t\t}\n\t}\n\n\tif (!width && !height)\n\t\tgoto free_handle;\n\n\t \n\tsi->orig_video_isVGA\t= VIDEO_TYPE_EFI;\n\n\tsi->lfb_depth\t\t= 32;\n\tsi->lfb_width\t\t= width;\n\tsi->lfb_height\t\t= height;\n\n\tsi->red_size\t\t= 8;\n\tsi->red_pos\t\t= 16;\n\tsi->green_size\t\t= 8;\n\tsi->green_pos\t\t= 8;\n\tsi->blue_size\t\t= 8;\n\tsi->blue_pos\t\t= 0;\n\tsi->rsvd_size\t\t= 8;\n\tsi->rsvd_pos\t\t= 24;\n\nfree_handle:\n\tefi_bs_call(free_pool, uga_handle);\n\n\treturn status;\n}\n\nstatic void setup_graphics(struct boot_params *boot_params)\n{\n\tefi_guid_t graphics_proto = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;\n\tstruct screen_info *si;\n\tefi_guid_t uga_proto = EFI_UGA_PROTOCOL_GUID;\n\tefi_status_t status;\n\tunsigned long size;\n\tvoid **gop_handle = NULL;\n\tvoid **uga_handle = NULL;\n\n\tsi = &boot_params->screen_info;\n\tmemset(si, 0, sizeof(*si));\n\n\tsize = 0;\n\tstatus = efi_bs_call(locate_handle, EFI_LOCATE_BY_PROTOCOL,\n\t\t\t     &graphics_proto, NULL, &size, gop_handle);\n\tif (status == EFI_BUFFER_TOO_SMALL)\n\t\tstatus = efi_setup_gop(si, &graphics_proto, size);\n\n\tif (status != EFI_SUCCESS) {\n\t\tsize = 0;\n\t\tstatus = efi_bs_call(locate_handle, EFI_LOCATE_BY_PROTOCOL,\n\t\t\t\t     &uga_proto, NULL, &size, uga_handle);\n\t\tif (status == EFI_BUFFER_TOO_SMALL)\n\t\t\tsetup_uga(si, &uga_proto, size);\n\t}\n}\n\n\nstatic void __noreturn efi_exit(efi_handle_t handle, efi_status_t status)\n{\n\tefi_bs_call(exit, handle, status, 0, NULL);\n\tfor(;;)\n\t\tasm(\"hlt\");\n}\n\nvoid __noreturn efi_stub_entry(efi_handle_t handle,\n\t\t\t       efi_system_table_t *sys_table_arg,\n\t\t\t       struct boot_params *boot_params);\n\n \nefi_status_t __efiapi efi_pe_entry(efi_handle_t handle,\n\t\t\t\t   efi_system_table_t *sys_table_arg)\n{\n\tstruct boot_params *boot_params;\n\tstruct setup_header *hdr;\n\tvoid *image_base;\n\tefi_guid_t proto = LOADED_IMAGE_PROTOCOL_GUID;\n\tint options_size = 0;\n\tefi_status_t status;\n\tchar *cmdline_ptr;\n\n\tefi_system_table = sys_table_arg;\n\n\t \n\tif (efi_system_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)\n\t\tefi_exit(handle, EFI_INVALID_PARAMETER);\n\n\tstatus = efi_bs_call(handle_protocol, handle, &proto, (void **)&image);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"Failed to get handle for LOADED_IMAGE_PROTOCOL\\n\");\n\t\tefi_exit(handle, status);\n\t}\n\n\timage_base = efi_table_attr(image, image_base);\n\n\tstatus = efi_allocate_pages(sizeof(struct boot_params),\n\t\t\t\t    (unsigned long *)&boot_params, ULONG_MAX);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"Failed to allocate lowmem for boot params\\n\");\n\t\tefi_exit(handle, status);\n\t}\n\n\tmemset(boot_params, 0x0, sizeof(struct boot_params));\n\n\thdr = &boot_params->hdr;\n\n\t \n\tmemcpy(&hdr->jump, image_base + 512,\n\t       sizeof(struct setup_header) - offsetof(struct setup_header, jump));\n\n\t \n\thdr->root_flags\t= 1;\n\thdr->vid_mode\t= 0xffff;\n\thdr->boot_flag\t= 0xAA55;\n\n\thdr->type_of_loader = 0x21;\n\n\t \n\tcmdline_ptr = efi_convert_cmdline(image, &options_size);\n\tif (!cmdline_ptr)\n\t\tgoto fail;\n\n\tefi_set_u64_split((unsigned long)cmdline_ptr,\n\t\t\t  &hdr->cmd_line_ptr, &boot_params->ext_cmd_line_ptr);\n\n\thdr->ramdisk_image = 0;\n\thdr->ramdisk_size = 0;\n\n\t \n\thdr->setup_data = 0;\n\n\tefi_stub_entry(handle, sys_table_arg, boot_params);\n\t \n\nfail:\n\tefi_free(sizeof(struct boot_params), (unsigned long)boot_params);\n\n\tefi_exit(handle, status);\n}\n\nstatic void add_e820ext(struct boot_params *params,\n\t\t\tstruct setup_data *e820ext, u32 nr_entries)\n{\n\tstruct setup_data *data;\n\n\te820ext->type = SETUP_E820_EXT;\n\te820ext->len  = nr_entries * sizeof(struct boot_e820_entry);\n\te820ext->next = 0;\n\n\tdata = (struct setup_data *)(unsigned long)params->hdr.setup_data;\n\n\twhile (data && data->next)\n\t\tdata = (struct setup_data *)(unsigned long)data->next;\n\n\tif (data)\n\t\tdata->next = (unsigned long)e820ext;\n\telse\n\t\tparams->hdr.setup_data = (unsigned long)e820ext;\n}\n\nstatic efi_status_t\nsetup_e820(struct boot_params *params, struct setup_data *e820ext, u32 e820ext_size)\n{\n\tstruct boot_e820_entry *entry = params->e820_table;\n\tstruct efi_info *efi = &params->efi_info;\n\tstruct boot_e820_entry *prev = NULL;\n\tu32 nr_entries;\n\tu32 nr_desc;\n\tint i;\n\n\tnr_entries = 0;\n\tnr_desc = efi->efi_memmap_size / efi->efi_memdesc_size;\n\n\tfor (i = 0; i < nr_desc; i++) {\n\t\tefi_memory_desc_t *d;\n\t\tunsigned int e820_type = 0;\n\t\tunsigned long m = efi->efi_memmap;\n\n#ifdef CONFIG_X86_64\n\t\tm |= (u64)efi->efi_memmap_hi << 32;\n#endif\n\n\t\td = efi_early_memdesc_ptr(m, efi->efi_memdesc_size, i);\n\t\tswitch (d->type) {\n\t\tcase EFI_RESERVED_TYPE:\n\t\tcase EFI_RUNTIME_SERVICES_CODE:\n\t\tcase EFI_RUNTIME_SERVICES_DATA:\n\t\tcase EFI_MEMORY_MAPPED_IO:\n\t\tcase EFI_MEMORY_MAPPED_IO_PORT_SPACE:\n\t\tcase EFI_PAL_CODE:\n\t\t\te820_type = E820_TYPE_RESERVED;\n\t\t\tbreak;\n\n\t\tcase EFI_UNUSABLE_MEMORY:\n\t\t\te820_type = E820_TYPE_UNUSABLE;\n\t\t\tbreak;\n\n\t\tcase EFI_ACPI_RECLAIM_MEMORY:\n\t\t\te820_type = E820_TYPE_ACPI;\n\t\t\tbreak;\n\n\t\tcase EFI_LOADER_CODE:\n\t\tcase EFI_LOADER_DATA:\n\t\tcase EFI_BOOT_SERVICES_CODE:\n\t\tcase EFI_BOOT_SERVICES_DATA:\n\t\tcase EFI_CONVENTIONAL_MEMORY:\n\t\t\tif (efi_soft_reserve_enabled() &&\n\t\t\t    (d->attribute & EFI_MEMORY_SP))\n\t\t\t\te820_type = E820_TYPE_SOFT_RESERVED;\n\t\t\telse\n\t\t\t\te820_type = E820_TYPE_RAM;\n\t\t\tbreak;\n\n\t\tcase EFI_ACPI_MEMORY_NVS:\n\t\t\te820_type = E820_TYPE_NVS;\n\t\t\tbreak;\n\n\t\tcase EFI_PERSISTENT_MEMORY:\n\t\t\te820_type = E820_TYPE_PMEM;\n\t\t\tbreak;\n\n\t\tcase EFI_UNACCEPTED_MEMORY:\n\t\t\tif (!IS_ENABLED(CONFIG_UNACCEPTED_MEMORY))\n\t\t\t\tcontinue;\n\t\t\te820_type = E820_TYPE_RAM;\n\t\t\tprocess_unaccepted_memory(d->phys_addr,\n\t\t\t\t\t\t  d->phys_addr + PAGE_SIZE * d->num_pages);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (prev && prev->type == e820_type &&\n\t\t    (prev->addr + prev->size) == d->phys_addr) {\n\t\t\tprev->size += d->num_pages << 12;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nr_entries == ARRAY_SIZE(params->e820_table)) {\n\t\t\tu32 need = (nr_desc - i) * sizeof(struct e820_entry) +\n\t\t\t\t   sizeof(struct setup_data);\n\n\t\t\tif (!e820ext || e820ext_size < need)\n\t\t\t\treturn EFI_BUFFER_TOO_SMALL;\n\n\t\t\t \n\t\t\tentry = (struct boot_e820_entry *)e820ext->data;\n\t\t}\n\n\t\tentry->addr = d->phys_addr;\n\t\tentry->size = d->num_pages << PAGE_SHIFT;\n\t\tentry->type = e820_type;\n\t\tprev = entry++;\n\t\tnr_entries++;\n\t}\n\n\tif (nr_entries > ARRAY_SIZE(params->e820_table)) {\n\t\tu32 nr_e820ext = nr_entries - ARRAY_SIZE(params->e820_table);\n\n\t\tadd_e820ext(params, e820ext, nr_e820ext);\n\t\tnr_entries -= nr_e820ext;\n\t}\n\n\tparams->e820_entries = (u8)nr_entries;\n\n\treturn EFI_SUCCESS;\n}\n\nstatic efi_status_t alloc_e820ext(u32 nr_desc, struct setup_data **e820ext,\n\t\t\t\t  u32 *e820ext_size)\n{\n\tefi_status_t status;\n\tunsigned long size;\n\n\tsize = sizeof(struct setup_data) +\n\t\tsizeof(struct e820_entry) * nr_desc;\n\n\tif (*e820ext) {\n\t\tefi_bs_call(free_pool, *e820ext);\n\t\t*e820ext = NULL;\n\t\t*e820ext_size = 0;\n\t}\n\n\tstatus = efi_bs_call(allocate_pool, EFI_LOADER_DATA, size,\n\t\t\t     (void **)e820ext);\n\tif (status == EFI_SUCCESS)\n\t\t*e820ext_size = size;\n\n\treturn status;\n}\n\nstatic efi_status_t allocate_e820(struct boot_params *params,\n\t\t\t\t  struct setup_data **e820ext,\n\t\t\t\t  u32 *e820ext_size)\n{\n\tstruct efi_boot_memmap *map;\n\tefi_status_t status;\n\t__u32 nr_desc;\n\n\tstatus = efi_get_memory_map(&map, false);\n\tif (status != EFI_SUCCESS)\n\t\treturn status;\n\n\tnr_desc = map->map_size / map->desc_size;\n\tif (nr_desc > ARRAY_SIZE(params->e820_table) - EFI_MMAP_NR_SLACK_SLOTS) {\n\t\tu32 nr_e820ext = nr_desc - ARRAY_SIZE(params->e820_table) +\n\t\t\t\t EFI_MMAP_NR_SLACK_SLOTS;\n\n\t\tstatus = alloc_e820ext(nr_e820ext, e820ext, e820ext_size);\n\t}\n\n\tif (IS_ENABLED(CONFIG_UNACCEPTED_MEMORY) && status == EFI_SUCCESS)\n\t\tstatus = allocate_unaccepted_bitmap(nr_desc, map);\n\n\tefi_bs_call(free_pool, map);\n\treturn status;\n}\n\nstruct exit_boot_struct {\n\tstruct boot_params\t*boot_params;\n\tstruct efi_info\t\t*efi;\n};\n\nstatic efi_status_t exit_boot_func(struct efi_boot_memmap *map,\n\t\t\t\t   void *priv)\n{\n\tconst char *signature;\n\tstruct exit_boot_struct *p = priv;\n\n\tsignature = efi_is_64bit() ? EFI64_LOADER_SIGNATURE\n\t\t\t\t   : EFI32_LOADER_SIGNATURE;\n\tmemcpy(&p->efi->efi_loader_signature, signature, sizeof(__u32));\n\n\tefi_set_u64_split((unsigned long)efi_system_table,\n\t\t\t  &p->efi->efi_systab, &p->efi->efi_systab_hi);\n\tp->efi->efi_memdesc_size\t= map->desc_size;\n\tp->efi->efi_memdesc_version\t= map->desc_ver;\n\tefi_set_u64_split((unsigned long)map->map,\n\t\t\t  &p->efi->efi_memmap, &p->efi->efi_memmap_hi);\n\tp->efi->efi_memmap_size\t\t= map->map_size;\n\n\treturn EFI_SUCCESS;\n}\n\nstatic efi_status_t exit_boot(struct boot_params *boot_params, void *handle)\n{\n\tstruct setup_data *e820ext = NULL;\n\t__u32 e820ext_size = 0;\n\tefi_status_t status;\n\tstruct exit_boot_struct priv;\n\n\tpriv.boot_params\t= boot_params;\n\tpriv.efi\t\t= &boot_params->efi_info;\n\n\tstatus = allocate_e820(boot_params, &e820ext, &e820ext_size);\n\tif (status != EFI_SUCCESS)\n\t\treturn status;\n\n\t \n\tstatus = efi_exit_boot_services(handle, &priv, exit_boot_func);\n\tif (status != EFI_SUCCESS)\n\t\treturn status;\n\n\t \n\tboot_params->alt_mem_k\t= 32 * 1024;\n\n\tstatus = setup_e820(boot_params, e820ext, e820ext_size);\n\tif (status != EFI_SUCCESS)\n\t\treturn status;\n\n\treturn EFI_SUCCESS;\n}\n\nstatic bool have_unsupported_snp_features(void)\n{\n\tu64 unsupported;\n\n\tunsupported = snp_get_unsupported_features(sev_get_status());\n\tif (unsupported) {\n\t\tefi_err(\"Unsupported SEV-SNP features detected: 0x%llx\\n\",\n\t\t\tunsupported);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void efi_get_seed(void *seed, int size)\n{\n\tefi_get_random_bytes(size, seed);\n\n\t \n\t*(unsigned long *)seed ^= kaslr_get_random_long(\"EFI\");\n}\n\nstatic void error(char *str)\n{\n\tefi_warn(\"Decompression failed: %s\\n\", str);\n}\n\nstatic efi_status_t efi_decompress_kernel(unsigned long *kernel_entry)\n{\n\tunsigned long virt_addr = LOAD_PHYSICAL_ADDR;\n\tunsigned long addr, alloc_size, entry;\n\tefi_status_t status;\n\tu32 seed[2] = {};\n\n\t \n\talloc_size = ALIGN(max_t(unsigned long, output_len, kernel_total_size),\n\t\t\t   MIN_KERNEL_ALIGN);\n\n\tif (IS_ENABLED(CONFIG_RANDOMIZE_BASE) && !efi_nokaslr) {\n\t\tu64 range = KERNEL_IMAGE_SIZE - LOAD_PHYSICAL_ADDR - kernel_total_size;\n\t\tstatic const efi_char16_t ami[] = L\"American Megatrends\";\n\n\t\tefi_get_seed(seed, sizeof(seed));\n\n\t\tvirt_addr += (range * seed[1]) >> 32;\n\t\tvirt_addr &= ~(CONFIG_PHYSICAL_ALIGN - 1);\n\n\t\t \n\t\tif (efi_system_table->hdr.revision <= EFI_2_00_SYSTEM_TABLE_REVISION &&\n\t\t    !memcmp(efistub_fw_vendor(), ami, sizeof(ami))) {\n\t\t\tefi_debug(\"AMI firmware v2.0 or older detected - disabling physical KASLR\\n\");\n\t\t\tseed[0] = 0;\n\t\t}\n\t}\n\n\tstatus = efi_random_alloc(alloc_size, CONFIG_PHYSICAL_ALIGN, &addr,\n\t\t\t\t  seed[0], EFI_LOADER_CODE,\n\t\t\t\t  EFI_X86_KERNEL_ALLOC_LIMIT);\n\tif (status != EFI_SUCCESS)\n\t\treturn status;\n\n\tentry = decompress_kernel((void *)addr, virt_addr, error);\n\tif (entry == ULONG_MAX) {\n\t\tefi_free(alloc_size, addr);\n\t\treturn EFI_LOAD_ERROR;\n\t}\n\n\t*kernel_entry = addr + entry;\n\n\tefi_adjust_memory_range_protection(addr, kernel_total_size);\n\n\treturn EFI_SUCCESS;\n}\n\nstatic void __noreturn enter_kernel(unsigned long kernel_addr,\n\t\t\t\t    struct boot_params *boot_params)\n{\n\t \n\tasm(\"jmp *%0\"::\"r\"(kernel_addr), \"S\"(boot_params));\n\n\tunreachable();\n}\n\n \nvoid __noreturn efi_stub_entry(efi_handle_t handle,\n\t\t\t       efi_system_table_t *sys_table_arg,\n\t\t\t       struct boot_params *boot_params)\n{\n\tefi_guid_t guid = EFI_MEMORY_ATTRIBUTE_PROTOCOL_GUID;\n\tstruct setup_header *hdr = &boot_params->hdr;\n\tconst struct linux_efi_initrd *initrd = NULL;\n\tunsigned long kernel_entry;\n\tefi_status_t status;\n\n\tboot_params_pointer = boot_params;\n\n\tefi_system_table = sys_table_arg;\n\t \n\tif (efi_system_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)\n\t\tefi_exit(handle, EFI_INVALID_PARAMETER);\n\n\tif (have_unsupported_snp_features())\n\t\tefi_exit(handle, EFI_UNSUPPORTED);\n\n\tif (IS_ENABLED(CONFIG_EFI_DXE_MEM_ATTRIBUTES)) {\n\t\tefi_dxe_table = get_efi_config_table(EFI_DXE_SERVICES_TABLE_GUID);\n\t\tif (efi_dxe_table &&\n\t\t    efi_dxe_table->hdr.signature != EFI_DXE_SERVICES_TABLE_SIGNATURE) {\n\t\t\tefi_warn(\"Ignoring DXE services table: invalid signature\\n\");\n\t\t\tefi_dxe_table = NULL;\n\t\t}\n\t}\n\n\t \n\tefi_bs_call(locate_protocol, &guid, NULL, (void **)&memattr);\n\n\tstatus = efi_setup_5level_paging();\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"efi_setup_5level_paging() failed!\\n\");\n\t\tgoto fail;\n\t}\n\n#ifdef CONFIG_CMDLINE_BOOL\n\tstatus = efi_parse_options(CONFIG_CMDLINE);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"Failed to parse options\\n\");\n\t\tgoto fail;\n\t}\n#endif\n\tif (!IS_ENABLED(CONFIG_CMDLINE_OVERRIDE)) {\n\t\tunsigned long cmdline_paddr = ((u64)hdr->cmd_line_ptr |\n\t\t\t\t\t       ((u64)boot_params->ext_cmd_line_ptr << 32));\n\t\tstatus = efi_parse_options((char *)cmdline_paddr);\n\t\tif (status != EFI_SUCCESS) {\n\t\t\tefi_err(\"Failed to parse options\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tstatus = efi_decompress_kernel(&kernel_entry);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"Failed to decompress kernel\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\tstatus = efi_load_initrd(image, hdr->initrd_addr_max, ULONG_MAX,\n\t\t\t\t &initrd);\n\tif (status != EFI_SUCCESS)\n\t\tgoto fail;\n\tif (initrd && initrd->size > 0) {\n\t\tefi_set_u64_split(initrd->base, &hdr->ramdisk_image,\n\t\t\t\t  &boot_params->ext_ramdisk_image);\n\t\tefi_set_u64_split(initrd->size, &hdr->ramdisk_size,\n\t\t\t\t  &boot_params->ext_ramdisk_size);\n\t}\n\n\n\t \n\tif (boot_params->secure_boot == efi_secureboot_mode_unset)\n\t\tboot_params->secure_boot = efi_get_secureboot();\n\n\t \n\tefi_enable_reset_attack_mitigation();\n\n\tefi_random_get_seed();\n\n\tefi_retrieve_tpm2_eventlog();\n\n\tsetup_graphics(boot_params);\n\n\tsetup_efi_pci(boot_params);\n\n\tsetup_quirks(boot_params);\n\n\tsetup_unaccepted_memory();\n\n\tstatus = exit_boot(boot_params, handle);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"exit_boot() failed!\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\tsev_enable(boot_params);\n\n\tefi_5level_switch();\n\n\tenter_kernel(kernel_entry, boot_params);\nfail:\n\tefi_err(\"efi_stub_entry() failed!\\n\");\n\n\tefi_exit(handle, status);\n}\n\n#ifdef CONFIG_EFI_HANDOVER_PROTOCOL\nvoid efi_handover_entry(efi_handle_t handle, efi_system_table_t *sys_table_arg,\n\t\t\tstruct boot_params *boot_params)\n{\n\textern char _bss[], _ebss[];\n\n\tmemset(_bss, 0, _ebss - _bss);\n\tefi_stub_entry(handle, sys_table_arg, boot_params);\n}\n\n#ifndef CONFIG_EFI_MIXED\nextern __alias(efi_handover_entry)\nvoid efi32_stub_entry(efi_handle_t handle, efi_system_table_t *sys_table_arg,\n\t\t      struct boot_params *boot_params);\n\nextern __alias(efi_handover_entry)\nvoid efi64_stub_entry(efi_handle_t handle, efi_system_table_t *sys_table_arg,\n\t\t      struct boot_params *boot_params);\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}