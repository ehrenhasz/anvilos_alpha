{
  "module_name": "unaccepted_memory.c",
  "hash_id": "e68773d4114614e9dd247c87b87f474e874a14899fa70a8a7f982b342811771c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/libstub/unaccepted_memory.c",
  "human_readable_source": "\n\n#include <linux/efi.h>\n#include <asm/efi.h>\n#include \"efistub.h\"\n\nstruct efi_unaccepted_memory *unaccepted_table;\n\nefi_status_t allocate_unaccepted_bitmap(__u32 nr_desc,\n\t\t\t\t\tstruct efi_boot_memmap *map)\n{\n\tefi_guid_t unaccepted_table_guid = LINUX_EFI_UNACCEPTED_MEM_TABLE_GUID;\n\tu64 unaccepted_start = ULLONG_MAX, unaccepted_end = 0, bitmap_size;\n\tefi_status_t status;\n\tint i;\n\n\t \n\tunaccepted_table = get_efi_config_table(unaccepted_table_guid);\n\tif (unaccepted_table) {\n\t\tif (unaccepted_table->version != 1) {\n\t\t\tefi_err(\"Unknown version of unaccepted memory table\\n\");\n\t\t\treturn EFI_UNSUPPORTED;\n\t\t}\n\t\treturn EFI_SUCCESS;\n\t}\n\n\t \n\tfor (i = 0; i < nr_desc; i++) {\n\t\tefi_memory_desc_t *d;\n\t\tunsigned long m = (unsigned long)map->map;\n\n\t\td = efi_early_memdesc_ptr(m, map->desc_size, i);\n\t\tif (d->type != EFI_UNACCEPTED_MEMORY)\n\t\t\tcontinue;\n\n\t\tunaccepted_start = min(unaccepted_start, d->phys_addr);\n\t\tunaccepted_end = max(unaccepted_end,\n\t\t\t\t     d->phys_addr + d->num_pages * PAGE_SIZE);\n\t}\n\n\tif (unaccepted_start == ULLONG_MAX)\n\t\treturn EFI_SUCCESS;\n\n\tunaccepted_start = round_down(unaccepted_start,\n\t\t\t\t      EFI_UNACCEPTED_UNIT_SIZE);\n\tunaccepted_end = round_up(unaccepted_end, EFI_UNACCEPTED_UNIT_SIZE);\n\n\t \n\tbitmap_size = DIV_ROUND_UP(unaccepted_end - unaccepted_start,\n\t\t\t\t   EFI_UNACCEPTED_UNIT_SIZE * BITS_PER_BYTE);\n\n\tstatus = efi_bs_call(allocate_pool, EFI_ACPI_RECLAIM_MEMORY,\n\t\t\t     sizeof(*unaccepted_table) + bitmap_size,\n\t\t\t     (void **)&unaccepted_table);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"Failed to allocate unaccepted memory config table\\n\");\n\t\treturn status;\n\t}\n\n\tunaccepted_table->version = 1;\n\tunaccepted_table->unit_size = EFI_UNACCEPTED_UNIT_SIZE;\n\tunaccepted_table->phys_base = unaccepted_start;\n\tunaccepted_table->size = bitmap_size;\n\tmemset(unaccepted_table->bitmap, 0, bitmap_size);\n\n\tstatus = efi_bs_call(install_configuration_table,\n\t\t\t     &unaccepted_table_guid, unaccepted_table);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_bs_call(free_pool, unaccepted_table);\n\t\tefi_err(\"Failed to install unaccepted memory config table!\\n\");\n\t}\n\n\treturn status;\n}\n\n \nvoid process_unaccepted_memory(u64 start, u64 end)\n{\n\tu64 unit_size = unaccepted_table->unit_size;\n\tu64 unit_mask = unaccepted_table->unit_size - 1;\n\tu64 bitmap_size = unaccepted_table->size;\n\n\t \n\tif (end - start < 2 * unit_size) {\n\t\tarch_accept_memory(start, end);\n\t\treturn;\n\t}\n\n\t \n\n\t \n\tif (start & unit_mask) {\n\t\tarch_accept_memory(start, round_up(start, unit_size));\n\t\tstart = round_up(start, unit_size);\n\t}\n\n\t \n\tif (end & unit_mask) {\n\t\tarch_accept_memory(round_down(end, unit_size), end);\n\t\tend = round_down(end, unit_size);\n\t}\n\n\t \n\tif (start < unaccepted_table->phys_base) {\n\t\tarch_accept_memory(start,\n\t\t\t\t   min(unaccepted_table->phys_base, end));\n\t\tstart = unaccepted_table->phys_base;\n\t}\n\n\t \n\tif (end < unaccepted_table->phys_base)\n\t\treturn;\n\n\t \n\tstart -= unaccepted_table->phys_base;\n\tend -= unaccepted_table->phys_base;\n\n\t \n\tif (end > bitmap_size * unit_size * BITS_PER_BYTE) {\n\t\tunsigned long phys_start, phys_end;\n\n\t\tphys_start = bitmap_size * unit_size * BITS_PER_BYTE +\n\t\t\t     unaccepted_table->phys_base;\n\t\tphys_end = end + unaccepted_table->phys_base;\n\n\t\tarch_accept_memory(phys_start, phys_end);\n\t\tend = bitmap_size * unit_size * BITS_PER_BYTE;\n\t}\n\n\t \n\tbitmap_set(unaccepted_table->bitmap,\n\t\t   start / unit_size, (end - start) / unit_size);\n}\n\nvoid accept_memory(phys_addr_t start, phys_addr_t end)\n{\n\tunsigned long range_start, range_end;\n\tunsigned long bitmap_size;\n\tu64 unit_size;\n\n\tif (!unaccepted_table)\n\t\treturn;\n\n\tunit_size = unaccepted_table->unit_size;\n\n\t \n\tif (start < unaccepted_table->phys_base)\n\t\tstart = unaccepted_table->phys_base;\n\tif (end < unaccepted_table->phys_base)\n\t\treturn;\n\n\t \n\tstart -= unaccepted_table->phys_base;\n\tend -= unaccepted_table->phys_base;\n\n\t \n\tif (end > unaccepted_table->size * unit_size * BITS_PER_BYTE)\n\t\tend = unaccepted_table->size * unit_size * BITS_PER_BYTE;\n\n\trange_start = start / unit_size;\n\tbitmap_size = DIV_ROUND_UP(end, unit_size);\n\n\tfor_each_set_bitrange_from(range_start, range_end,\n\t\t\t\t   unaccepted_table->bitmap, bitmap_size) {\n\t\tunsigned long phys_start, phys_end;\n\n\t\tphys_start = range_start * unit_size + unaccepted_table->phys_base;\n\t\tphys_end = range_end * unit_size + unaccepted_table->phys_base;\n\n\t\tarch_accept_memory(phys_start, phys_end);\n\t\tbitmap_clear(unaccepted_table->bitmap,\n\t\t\t     range_start, range_end - range_start);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}