{
  "module_name": "vsprintf.c",
  "hash_id": "a98dc2132df16085cb6ade88b08bbe7847471e55fca056df04d3270e6fab9ce1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/libstub/vsprintf.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/stdarg.h>\n\n#include <linux/compiler.h>\n#include <linux/ctype.h>\n#include <linux/kernel.h>\n#include <linux/limits.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstatic\nint skip_atoi(const char **s)\n{\n\tint i = 0;\n\n\twhile (isdigit(**s))\n\t\ti = i * 10 + *((*s)++) - '0';\n\treturn i;\n}\n\n \nstatic\nvoid put_dec_full4(char *end, unsigned int r)\n{\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tunsigned int q = (r * 0xccd) >> 15;\n\t\t*--end = '0' + (r - q * 10);\n\t\tr = q;\n\t}\n\t*--end = '0' + r;\n}\n\n \n\n \nstatic\nunsigned int put_dec_helper4(char *end, unsigned int x)\n{\n\tunsigned int q = (x * 0x346DC5D7ULL) >> 43;\n\n\tput_dec_full4(end, x - q * 10000);\n\treturn q;\n}\n\n \nstatic\nchar *put_dec(char *end, unsigned long long n)\n{\n\tunsigned int d3, d2, d1, q, h;\n\tchar *p = end;\n\n\td1  = ((unsigned int)n >> 16);  \n\th   = (n >> 32);\n\td2  = (h      ) & 0xffff;\n\td3  = (h >> 16);  \n\n\t \n\tq = 656 * d3 + 7296 * d2 + 5536 * d1 + ((unsigned int)n & 0xffff);\n\tq = put_dec_helper4(p, q);\n\tp -= 4;\n\n\tq += 7671 * d3 + 9496 * d2 + 6 * d1;\n\tq = put_dec_helper4(p, q);\n\tp -= 4;\n\n\tq += 4749 * d3 + 42 * d2;\n\tq = put_dec_helper4(p, q);\n\tp -= 4;\n\n\tq += 281 * d3;\n\tq = put_dec_helper4(p, q);\n\tp -= 4;\n\n\tput_dec_full4(p, q);\n\tp -= 4;\n\n\t \n\twhile (p < end && *p == '0')\n\t\t++p;\n\n\treturn p;\n}\n\nstatic\nchar *number(char *end, unsigned long long num, int base, char locase)\n{\n\t \n\n\t \n\tstatic const char digits[16] = \"0123456789ABCDEF\";  \n\n\tswitch (base) {\n\tcase 10:\n\t\tif (num != 0)\n\t\t\tend = put_dec(end, num);\n\t\tbreak;\n\tcase 8:\n\t\tfor (; num != 0; num >>= 3)\n\t\t\t*--end = '0' + (num & 07);\n\t\tbreak;\n\tcase 16:\n\t\tfor (; num != 0; num >>= 4)\n\t\t\t*--end = digits[num & 0xf] | locase;\n\t\tbreak;\n\tdefault:\n\t\tunreachable();\n\t}\n\n\treturn end;\n}\n\n#define ZEROPAD\t1\t\t \n#define SIGN\t2\t\t \n#define PLUS\t4\t\t \n#define SPACE\t8\t\t \n#define LEFT\t16\t\t \n#define SMALL\t32\t\t \n#define SPECIAL\t64\t\t \n#define WIDE\t128\t\t \n\nstatic\nint get_flags(const char **fmt)\n{\n\tint flags = 0;\n\n\tdo {\n\t\tswitch (**fmt) {\n\t\tcase '-':\n\t\t\tflags |= LEFT;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\tflags |= PLUS;\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\tflags |= SPACE;\n\t\t\tbreak;\n\t\tcase '#':\n\t\t\tflags |= SPECIAL;\n\t\t\tbreak;\n\t\tcase '0':\n\t\t\tflags |= ZEROPAD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn flags;\n\t\t}\n\t\t++(*fmt);\n\t} while (1);\n}\n\nstatic\nint get_int(const char **fmt, va_list *ap)\n{\n\tif (isdigit(**fmt))\n\t\treturn skip_atoi(fmt);\n\tif (**fmt == '*') {\n\t\t++(*fmt);\n\t\t \n\t\treturn va_arg(*ap, int);\n\t}\n\treturn 0;\n}\n\nstatic\nunsigned long long get_number(int sign, int qualifier, va_list *ap)\n{\n\tif (sign) {\n\t\tswitch (qualifier) {\n\t\tcase 'L':\n\t\t\treturn va_arg(*ap, long long);\n\t\tcase 'l':\n\t\t\treturn va_arg(*ap, long);\n\t\tcase 'h':\n\t\t\treturn (short)va_arg(*ap, int);\n\t\tcase 'H':\n\t\t\treturn (signed char)va_arg(*ap, int);\n\t\tdefault:\n\t\t\treturn va_arg(*ap, int);\n\t\t};\n\t} else {\n\t\tswitch (qualifier) {\n\t\tcase 'L':\n\t\t\treturn va_arg(*ap, unsigned long long);\n\t\tcase 'l':\n\t\t\treturn va_arg(*ap, unsigned long);\n\t\tcase 'h':\n\t\t\treturn (unsigned short)va_arg(*ap, int);\n\t\tcase 'H':\n\t\t\treturn (unsigned char)va_arg(*ap, int);\n\t\tdefault:\n\t\t\treturn va_arg(*ap, unsigned int);\n\t\t}\n\t}\n}\n\nstatic\nchar get_sign(long long *num, int flags)\n{\n\tif (!(flags & SIGN))\n\t\treturn 0;\n\tif (*num < 0) {\n\t\t*num = -(*num);\n\t\treturn '-';\n\t}\n\tif (flags & PLUS)\n\t\treturn '+';\n\tif (flags & SPACE)\n\t\treturn ' ';\n\treturn 0;\n}\n\nstatic\nsize_t utf16s_utf8nlen(const u16 *s16, size_t maxlen)\n{\n\tsize_t len, clen;\n\n\tfor (len = 0; len < maxlen && *s16; len += clen) {\n\t\tu16 c0 = *s16++;\n\n\t\t \n\t\tclen = 1 + (c0 >= 0x80) + (c0 >= 0x800);\n\t\tif (len + clen > maxlen)\n\t\t\tbreak;\n\t\t \n\t\tif ((c0 & 0xfc00) == 0xd800) {\n\t\t\tif (len + clen == maxlen)\n\t\t\t\tbreak;\n\t\t\tif ((*s16 & 0xfc00) == 0xdc00) {\n\t\t\t\t++s16;\n\t\t\t\t++clen;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn len;\n}\n\nstatic\nu32 utf16_to_utf32(const u16 **s16)\n{\n\tu16 c0, c1;\n\n\tc0 = *(*s16)++;\n\t \n\tif ((c0 & 0xf800) != 0xd800)\n\t\treturn c0;\n\t \n\tif (c0 & 0x0400)\n\t\treturn 0xfffd;\n\tc1 = **s16;\n\t \n\tif ((c1 & 0xfc00) != 0xdc00)\n\t\treturn 0xfffd;\n\t \n\t++(*s16);\n\treturn (0x10000 - (0xd800 << 10) - 0xdc00) + (c0 << 10) + c1;\n}\n\n#define PUTC(c) \\\ndo {\t\t\t\t\\\n\tif (pos < size)\t\t\\\n\t\tbuf[pos] = (c);\t\\\n\t++pos;\t\t\t\\\n} while (0);\n\nint vsnprintf(char *buf, size_t size, const char *fmt, va_list ap)\n{\n\t \n\tchar tmp[(sizeof(unsigned long long) * 8 + 2) / 3];\n\tchar *tmp_end = &tmp[ARRAY_SIZE(tmp)];\n\tlong long num;\n\tint base;\n\tconst char *s;\n\tsize_t len, pos;\n\tchar sign;\n\n\tint flags;\t\t \n\n\tint field_width;\t \n\tint precision;\t\t \n\tint qualifier;\t\t \n\n\tva_list args;\n\n\t \n\tva_copy(args, ap);\n\n\tfor (pos = 0; *fmt; ++fmt) {\n\t\tif (*fmt != '%' || *++fmt == '%') {\n\t\t\tPUTC(*fmt);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tflags = get_flags(&fmt);\n\n\t\t \n\t\tfield_width = get_int(&fmt, &args);\n\t\tif (field_width < 0) {\n\t\t\tfield_width = -field_width;\n\t\t\tflags |= LEFT;\n\t\t}\n\n\t\tif (flags & LEFT)\n\t\t\tflags &= ~ZEROPAD;\n\n\t\t \n\t\tprecision = -1;\n\t\tif (*fmt == '.') {\n\t\t\t++fmt;\n\t\t\tprecision = get_int(&fmt, &args);\n\t\t\tif (precision >= 0)\n\t\t\t\tflags &= ~ZEROPAD;\n\t\t}\n\n\t\t \n\t\tqualifier = -1;\n\t\tif (*fmt == 'h' || *fmt == 'l') {\n\t\t\tqualifier = *fmt;\n\t\t\t++fmt;\n\t\t\tif (qualifier == *fmt) {\n\t\t\t\tqualifier -= 'a'-'A';\n\t\t\t\t++fmt;\n\t\t\t}\n\t\t}\n\n\t\tsign = 0;\n\n\t\tswitch (*fmt) {\n\t\tcase 'c':\n\t\t\tflags &= LEFT;\n\t\t\ts = tmp;\n\t\t\tif (qualifier == 'l') {\n\t\t\t\t((u16 *)tmp)[0] = (u16)va_arg(args, unsigned int);\n\t\t\t\t((u16 *)tmp)[1] = L'\\0';\n\t\t\t\tprecision = INT_MAX;\n\t\t\t\tgoto wstring;\n\t\t\t} else {\n\t\t\t\ttmp[0] = (unsigned char)va_arg(args, int);\n\t\t\t\tprecision = len = 1;\n\t\t\t}\n\t\t\tgoto output;\n\n\t\tcase 's':\n\t\t\tflags &= LEFT;\n\t\t\tif (precision < 0)\n\t\t\t\tprecision = INT_MAX;\n\t\t\ts = va_arg(args, void *);\n\t\t\tif (!s)\n\t\t\t\ts = precision < 6 ? \"\" : \"(null)\";\n\t\t\telse if (qualifier == 'l') {\n\t\twstring:\n\t\t\t\tflags |= WIDE;\n\t\t\t\tprecision = len = utf16s_utf8nlen((const u16 *)s, precision);\n\t\t\t\tgoto output;\n\t\t\t}\n\t\t\tprecision = len = strnlen(s, precision);\n\t\t\tgoto output;\n\n\t\t\t \n\t\tcase 'o':\n\t\t\tbase = 8;\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tif (precision < 0)\n\t\t\t\tprecision = 2 * sizeof(void *);\n\t\t\tfallthrough;\n\t\tcase 'x':\n\t\t\tflags |= SMALL;\n\t\t\tfallthrough;\n\t\tcase 'X':\n\t\t\tbase = 16;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\tcase 'i':\n\t\t\tflags |= SIGN;\n\t\t\tfallthrough;\n\t\tcase 'u':\n\t\t\tflags &= ~SPECIAL;\n\t\t\tbase = 10;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tgoto fail;\n\t\t}\n\t\tif (*fmt == 'p') {\n\t\t\tnum = (unsigned long)va_arg(args, void *);\n\t\t} else {\n\t\t\tnum = get_number(flags & SIGN, qualifier, &args);\n\t\t}\n\n\t\tsign = get_sign(&num, flags);\n\t\tif (sign)\n\t\t\t--field_width;\n\n\t\ts = number(tmp_end, num, base, flags & SMALL);\n\t\tlen = tmp_end - s;\n\t\t \n\t\tif (precision < 0)\n\t\t\tprecision = 1;\n\t\t \n\t\tif (precision < len)\n\t\t\tprecision = len;\n\t\tif (flags & SPECIAL) {\n\t\t\t \n\t\t\tif (base == 8 && precision == len)\n\t\t\t\t++precision;\n\t\t\t \n\t\t\tif (base == 16 && precision > 0)\n\t\t\t\tfield_width -= 2;\n\t\t\telse\n\t\t\t\tflags &= ~SPECIAL;\n\t\t}\n\t\t \n\t\tif ((flags & ZEROPAD) && field_width > precision)\n\t\t\tprecision = field_width;\n\noutput:\n\t\t \n\t\tfield_width -= precision;\n\t\t \n\t\tif (!(flags & LEFT))\n\t\t\twhile (field_width-- > 0)\n\t\t\t\tPUTC(' ');\n\t\t \n\t\tif (sign)\n\t\t\tPUTC(sign);\n\t\t \n\t\tif (flags & SPECIAL) {\n\t\t\tPUTC('0');\n\t\t\tPUTC( 'X' | (flags & SMALL));\n\t\t}\n\t\t \n\t\twhile (precision-- > len)\n\t\t\tPUTC('0');\n\t\t \n\t\tif (flags & WIDE) {\n\t\t\tconst u16 *ws = (const u16 *)s;\n\n\t\t\twhile (len-- > 0) {\n\t\t\t\tu32 c32 = utf16_to_utf32(&ws);\n\t\t\t\tu8 *s8;\n\t\t\t\tsize_t clen;\n\n\t\t\t\tif (c32 < 0x80) {\n\t\t\t\t\tPUTC(c32);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tclen = 1 + (c32 >= 0x800) + (c32 >= 0x10000);\n\n\t\t\t\tlen -= clen;\n\t\t\t\ts8 = (u8 *)&buf[pos];\n\n\t\t\t\t \n\t\t\t\tPUTC('\\0');\n\t\t\t\tpos += clen;\n\t\t\t\tif (pos >= size)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\t*s8 = (0xf00 >> 1) >> clen;\n\t\t\t\t \n\t\t\t\tfor (s8 += clen; clen; --clen, c32 >>= 6)\n\t\t\t\t\t*s8-- = 0x80 | (c32 & 0x3f);\n\t\t\t\t \n\t\t\t\t*s8 |= c32;\n\t\t\t}\n\t\t} else {\n\t\t\twhile (len-- > 0)\n\t\t\t\tPUTC(*s++);\n\t\t}\n\t\t \n\t\twhile (field_width-- > 0)\n\t\t\tPUTC(' ');\n\t}\nfail:\n\tva_end(args);\n\n\tif (size)\n\t\tbuf[min(pos, size-1)] = '\\0';\n\n\treturn pos;\n}\n\nint snprintf(char *buf, size_t size, const char *fmt, ...)\n{\n\tva_list args;\n\tint i;\n\n\tva_start(args, fmt);\n\ti = vsnprintf(buf, size, fmt, args);\n\tva_end(args);\n\treturn i;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}