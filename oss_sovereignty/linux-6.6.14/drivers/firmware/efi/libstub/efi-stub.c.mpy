{
  "module_name": "efi-stub.c",
  "hash_id": "8f8f7decefce38a71c9a459cf75cdc57b3537b0ac4366e02685fc68f97119dba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/libstub/efi-stub.c",
  "human_readable_source": "\n \n\n#include <linux/efi.h>\n#include <asm/efi.h>\n\n#include \"efistub.h\"\n\n \n#define EFI_RT_VIRTUAL_BASE\tSZ_512M\n\n \n#ifndef EFI_RT_VIRTUAL_OFFSET\n#define EFI_RT_VIRTUAL_OFFSET\t0\n#endif\n\nstatic u64 virtmap_base = EFI_RT_VIRTUAL_BASE;\nstatic bool flat_va_mapping = (EFI_RT_VIRTUAL_OFFSET != 0);\n\nvoid __weak free_screen_info(struct screen_info *si)\n{\n}\n\nstatic struct screen_info *setup_graphics(void)\n{\n\tefi_guid_t gop_proto = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;\n\tefi_status_t status;\n\tunsigned long size;\n\tvoid **gop_handle = NULL;\n\tstruct screen_info *si = NULL;\n\n\tsize = 0;\n\tstatus = efi_bs_call(locate_handle, EFI_LOCATE_BY_PROTOCOL,\n\t\t\t     &gop_proto, NULL, &size, gop_handle);\n\tif (status == EFI_BUFFER_TOO_SMALL) {\n\t\tsi = alloc_screen_info();\n\t\tif (!si)\n\t\t\treturn NULL;\n\t\tstatus = efi_setup_gop(si, &gop_proto, size);\n\t\tif (status != EFI_SUCCESS) {\n\t\t\tfree_screen_info(si);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn si;\n}\n\nstatic void install_memreserve_table(void)\n{\n\tstruct linux_efi_memreserve *rsv;\n\tefi_guid_t memreserve_table_guid = LINUX_EFI_MEMRESERVE_TABLE_GUID;\n\tefi_status_t status;\n\n\tstatus = efi_bs_call(allocate_pool, EFI_LOADER_DATA, sizeof(*rsv),\n\t\t\t     (void **)&rsv);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"Failed to allocate memreserve entry!\\n\");\n\t\treturn;\n\t}\n\n\trsv->next = 0;\n\trsv->size = 0;\n\tatomic_set(&rsv->count, 0);\n\n\tstatus = efi_bs_call(install_configuration_table,\n\t\t\t     &memreserve_table_guid, rsv);\n\tif (status != EFI_SUCCESS)\n\t\tefi_err(\"Failed to install memreserve config table!\\n\");\n}\n\nstatic u32 get_supported_rt_services(void)\n{\n\tconst efi_rt_properties_table_t *rt_prop_table;\n\tu32 supported = EFI_RT_SUPPORTED_ALL;\n\n\trt_prop_table = get_efi_config_table(EFI_RT_PROPERTIES_TABLE_GUID);\n\tif (rt_prop_table)\n\t\tsupported &= rt_prop_table->runtime_services_supported;\n\n\treturn supported;\n}\n\nefi_status_t efi_handle_cmdline(efi_loaded_image_t *image, char **cmdline_ptr)\n{\n\tint cmdline_size = 0;\n\tefi_status_t status;\n\tchar *cmdline;\n\n\t \n\tcmdline = efi_convert_cmdline(image, &cmdline_size);\n\tif (!cmdline) {\n\t\tefi_err(\"getting command line via LOADED_IMAGE_PROTOCOL\\n\");\n\t\treturn EFI_OUT_OF_RESOURCES;\n\t}\n\n\tif (IS_ENABLED(CONFIG_CMDLINE_EXTEND) ||\n\t    IS_ENABLED(CONFIG_CMDLINE_FORCE) ||\n\t    cmdline_size == 0) {\n\t\tstatus = efi_parse_options(CONFIG_CMDLINE);\n\t\tif (status != EFI_SUCCESS) {\n\t\t\tefi_err(\"Failed to parse options\\n\");\n\t\t\tgoto fail_free_cmdline;\n\t\t}\n\t}\n\n\tif (!IS_ENABLED(CONFIG_CMDLINE_FORCE) && cmdline_size > 0) {\n\t\tstatus = efi_parse_options(cmdline);\n\t\tif (status != EFI_SUCCESS) {\n\t\t\tefi_err(\"Failed to parse options\\n\");\n\t\t\tgoto fail_free_cmdline;\n\t\t}\n\t}\n\n\t*cmdline_ptr = cmdline;\n\treturn EFI_SUCCESS;\n\nfail_free_cmdline:\n\tefi_bs_call(free_pool, cmdline_ptr);\n\treturn status;\n}\n\nefi_status_t efi_stub_common(efi_handle_t handle,\n\t\t\t     efi_loaded_image_t *image,\n\t\t\t     unsigned long image_addr,\n\t\t\t     char *cmdline_ptr)\n{\n\tstruct screen_info *si;\n\tefi_status_t status;\n\n\tstatus = check_platform_features();\n\tif (status != EFI_SUCCESS)\n\t\treturn status;\n\n\tsi = setup_graphics();\n\n\tefi_retrieve_tpm2_eventlog();\n\n\t \n\tefi_enable_reset_attack_mitigation();\n\n\tefi_load_initrd(image, ULONG_MAX, efi_get_max_initrd_addr(image_addr),\n\t\t\tNULL);\n\n\tefi_random_get_seed();\n\n\t \n\tefi_novamap |= !(get_supported_rt_services() &\n\t\t\t EFI_RT_SUPPORTED_SET_VIRTUAL_ADDRESS_MAP);\n\n\tinstall_memreserve_table();\n\n\tstatus = efi_boot_kernel(handle, image, image_addr, cmdline_ptr);\n\n\tfree_screen_info(si);\n\treturn status;\n}\n\n \nefi_status_t efi_alloc_virtmap(efi_memory_desc_t **virtmap,\n\t\t\t       unsigned long *desc_size, u32 *desc_ver)\n{\n\tunsigned long size, mmap_key;\n\tefi_status_t status;\n\n\t \n\tsize = 0;\n\tstatus = efi_bs_call(get_memory_map, &size, NULL, &mmap_key, desc_size,\n\t\t\t     desc_ver);\n\tif (status != EFI_BUFFER_TOO_SMALL)\n\t\treturn EFI_LOAD_ERROR;\n\n\treturn efi_bs_call(allocate_pool, EFI_LOADER_DATA, size,\n\t\t\t   (void **)virtmap);\n}\n\n \nvoid efi_get_virtmap(efi_memory_desc_t *memory_map, unsigned long map_size,\n\t\t     unsigned long desc_size, efi_memory_desc_t *runtime_map,\n\t\t     int *count)\n{\n\tu64 efi_virt_base = virtmap_base;\n\tefi_memory_desc_t *in, *out = runtime_map;\n\tint l;\n\n\t*count = 0;\n\n\tfor (l = 0; l < map_size; l += desc_size) {\n\t\tu64 paddr, size;\n\n\t\tin = (void *)memory_map + l;\n\t\tif (!(in->attribute & EFI_MEMORY_RUNTIME))\n\t\t\tcontinue;\n\n\t\tpaddr = in->phys_addr;\n\t\tsize = in->num_pages * EFI_PAGE_SIZE;\n\n\t\tin->virt_addr = in->phys_addr + EFI_RT_VIRTUAL_OFFSET;\n\t\tif (efi_novamap) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!flat_va_mapping) {\n\n\t\t\tpaddr = round_down(in->phys_addr, SZ_64K);\n\t\t\tsize += in->phys_addr - paddr;\n\n\t\t\t \n\t\t\tif (IS_ALIGNED(in->phys_addr, SZ_2M) && size >= SZ_2M)\n\t\t\t\tefi_virt_base = round_up(efi_virt_base, SZ_2M);\n\t\t\telse\n\t\t\t\tefi_virt_base = round_up(efi_virt_base, SZ_64K);\n\n\t\t\tin->virt_addr += efi_virt_base - paddr;\n\t\t\tefi_virt_base += size;\n\t\t}\n\n\t\tmemcpy(out, in, desc_size);\n\t\tout = (void *)out + desc_size;\n\t\t++*count;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}