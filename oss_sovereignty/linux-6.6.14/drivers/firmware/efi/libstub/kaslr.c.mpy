{
  "module_name": "kaslr.c",
  "hash_id": "0f16a62f939a39af6be97baa846a46da71639e59cf0123b54127f2a64ec0e32c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/libstub/kaslr.c",
  "human_readable_source": "\n \n#include <linux/efi.h>\n\n#include \"efistub.h\"\n\n \nu32 efi_kaslr_get_phys_seed(efi_handle_t image_handle)\n{\n\tefi_status_t status;\n\tu32 phys_seed;\n\tefi_guid_t li_fixed_proto = LINUX_EFI_LOADED_IMAGE_FIXED_GUID;\n\tvoid *p;\n\n\tif (!IS_ENABLED(CONFIG_RANDOMIZE_BASE))\n\t\treturn 0;\n\n\tif (efi_nokaslr) {\n\t\tefi_info(\"KASLR disabled on kernel command line\\n\");\n\t} else if (efi_bs_call(handle_protocol, image_handle,\n\t\t\t       &li_fixed_proto, &p) == EFI_SUCCESS) {\n\t\tefi_info(\"Image placement fixed by loader\\n\");\n\t} else {\n\t\tstatus = efi_get_random_bytes(sizeof(phys_seed),\n\t\t\t\t\t      (u8 *)&phys_seed);\n\t\tif (status == EFI_SUCCESS) {\n\t\t\treturn phys_seed;\n\t\t} else if (status == EFI_NOT_FOUND) {\n\t\t\tefi_info(\"EFI_RNG_PROTOCOL unavailable\\n\");\n\t\t\tefi_nokaslr = true;\n\t\t} else if (status != EFI_SUCCESS) {\n\t\t\tefi_err(\"efi_get_random_bytes() failed (0x%lx)\\n\",\n\t\t\t\tstatus);\n\t\t\tefi_nokaslr = true;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool check_image_region(u64 base, u64 size)\n{\n\tstruct efi_boot_memmap *map;\n\tefi_status_t status;\n\tbool ret = false;\n\tint map_offset;\n\n\tstatus = efi_get_memory_map(&map, false);\n\tif (status != EFI_SUCCESS)\n\t\treturn false;\n\n\tfor (map_offset = 0; map_offset < map->map_size; map_offset += map->desc_size) {\n\t\tefi_memory_desc_t *md = (void *)map->map + map_offset;\n\t\tu64 end = md->phys_addr + md->num_pages * EFI_PAGE_SIZE;\n\n\t\t \n\t\tif (base >= md->phys_addr && base < end) {\n\t\t\tret = (base + size) <= end;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tefi_bs_call(free_pool, map);\n\n\treturn ret;\n}\n\n \nefi_status_t efi_kaslr_relocate_kernel(unsigned long *image_addr,\n\t\t\t\t       unsigned long *reserve_addr,\n\t\t\t\t       unsigned long *reserve_size,\n\t\t\t\t       unsigned long kernel_size,\n\t\t\t\t       unsigned long kernel_codesize,\n\t\t\t\t       unsigned long kernel_memsize,\n\t\t\t\t       u32 phys_seed)\n{\n\tefi_status_t status;\n\tu64 min_kimg_align = efi_get_kimg_min_align();\n\n\tif (IS_ENABLED(CONFIG_RANDOMIZE_BASE) && phys_seed != 0) {\n\t\t \n\t\tstatus = efi_random_alloc(*reserve_size, min_kimg_align,\n\t\t\t\t\t  reserve_addr, phys_seed,\n\t\t\t\t\t  EFI_LOADER_CODE, EFI_ALLOC_LIMIT);\n\t\tif (status != EFI_SUCCESS)\n\t\t\tefi_warn(\"efi_random_alloc() failed: 0x%lx\\n\", status);\n\t} else {\n\t\tstatus = EFI_OUT_OF_RESOURCES;\n\t}\n\n\tif (status != EFI_SUCCESS) {\n\t\tif (!check_image_region(*image_addr, kernel_memsize)) {\n\t\t\tefi_err(\"FIRMWARE BUG: Image BSS overlaps adjacent EFI memory region\\n\");\n\t\t} else if (IS_ALIGNED(*image_addr, min_kimg_align) &&\n\t\t\t   (unsigned long)_end < EFI_ALLOC_LIMIT) {\n\t\t\t \n\t\t\t*reserve_size = 0;\n\t\t\treturn EFI_SUCCESS;\n\t\t}\n\n\t\tstatus = efi_allocate_pages_aligned(*reserve_size, reserve_addr,\n\t\t\t\t\t\t    ULONG_MAX, min_kimg_align,\n\t\t\t\t\t\t    EFI_LOADER_CODE);\n\n\t\tif (status != EFI_SUCCESS) {\n\t\t\tefi_err(\"Failed to relocate kernel\\n\");\n\t\t\t*reserve_size = 0;\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tmemcpy((void *)*reserve_addr, (void *)*image_addr, kernel_size);\n\t*image_addr = *reserve_addr;\n\tefi_icache_sync(*image_addr, *image_addr + kernel_codesize);\n\tefi_remap_image(*image_addr, *reserve_size, kernel_codesize);\n\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}