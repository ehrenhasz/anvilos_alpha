{
  "module_name": "tpm.c",
  "hash_id": "092de632b8555346476474539913d95813be0d5cde7c62baf5c644caa5fe6ec7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/libstub/tpm.c",
  "human_readable_source": "\n \n#include <linux/efi.h>\n#include <linux/tpm_eventlog.h>\n#include <asm/efi.h>\n\n#include \"efistub.h\"\n\n#ifdef CONFIG_RESET_ATTACK_MITIGATION\nstatic const efi_char16_t efi_MemoryOverWriteRequest_name[] =\n\tL\"MemoryOverwriteRequestControl\";\n\n#define MEMORY_ONLY_RESET_CONTROL_GUID \\\n\tEFI_GUID(0xe20939be, 0x32d4, 0x41be, 0xa1, 0x50, 0x89, 0x7f, 0x85, 0xd4, 0x98, 0x29)\n\n \nvoid efi_enable_reset_attack_mitigation(void)\n{\n\tu8 val = 1;\n\tefi_guid_t var_guid = MEMORY_ONLY_RESET_CONTROL_GUID;\n\tefi_status_t status;\n\tunsigned long datasize = 0;\n\n\tstatus = get_efi_var(efi_MemoryOverWriteRequest_name, &var_guid,\n\t\t\t     NULL, &datasize, NULL);\n\n\tif (status == EFI_NOT_FOUND)\n\t\treturn;\n\n\tset_efi_var(efi_MemoryOverWriteRequest_name, &var_guid,\n\t\t    EFI_VARIABLE_NON_VOLATILE |\n\t\t    EFI_VARIABLE_BOOTSERVICE_ACCESS |\n\t\t    EFI_VARIABLE_RUNTIME_ACCESS, sizeof(val), &val);\n}\n\n#endif\n\nvoid efi_retrieve_tpm2_eventlog(void)\n{\n\tefi_guid_t tcg2_guid = EFI_TCG2_PROTOCOL_GUID;\n\tefi_guid_t linux_eventlog_guid = LINUX_EFI_TPM_EVENT_LOG_GUID;\n\tefi_status_t status;\n\tefi_physical_addr_t log_location = 0, log_last_entry = 0;\n\tstruct linux_efi_tpm_eventlog *log_tbl = NULL;\n\tstruct efi_tcg2_final_events_table *final_events_table = NULL;\n\tunsigned long first_entry_addr, last_entry_addr;\n\tsize_t log_size, last_entry_size;\n\tefi_bool_t truncated;\n\tint version = EFI_TCG2_EVENT_LOG_FORMAT_TCG_2;\n\tefi_tcg2_protocol_t *tcg2_protocol = NULL;\n\tint final_events_size = 0;\n\n\tstatus = efi_bs_call(locate_protocol, &tcg2_guid, NULL,\n\t\t\t     (void **)&tcg2_protocol);\n\tif (status != EFI_SUCCESS)\n\t\treturn;\n\n\tstatus = efi_call_proto(tcg2_protocol, get_event_log, version,\n\t\t\t\t&log_location, &log_last_entry, &truncated);\n\n\tif (status != EFI_SUCCESS || !log_location) {\n\t\tversion = EFI_TCG2_EVENT_LOG_FORMAT_TCG_1_2;\n\t\tstatus = efi_call_proto(tcg2_protocol, get_event_log, version,\n\t\t\t\t\t&log_location, &log_last_entry,\n\t\t\t\t\t&truncated);\n\t\tif (status != EFI_SUCCESS || !log_location)\n\t\t\treturn;\n\n\t}\n\n\tfirst_entry_addr = (unsigned long) log_location;\n\n\t \n\tif (!log_last_entry) {\n\t\tlog_size = 0;\n\t} else {\n\t\tlast_entry_addr = (unsigned long) log_last_entry;\n\t\t \n\t\tif (version == EFI_TCG2_EVENT_LOG_FORMAT_TCG_2) {\n\t\t\t \n\t\t\tlast_entry_size =\n\t\t\t\t__calc_tpm2_event_size((void *)last_entry_addr,\n\t\t\t\t\t\t    (void *)(long)log_location,\n\t\t\t\t\t\t    false);\n\t\t} else {\n\t\t\tlast_entry_size = sizeof(struct tcpa_event) +\n\t\t\t   ((struct tcpa_event *) last_entry_addr)->event_size;\n\t\t}\n\t\tlog_size = log_last_entry - log_location + last_entry_size;\n\t}\n\n\t \n\tstatus = efi_bs_call(allocate_pool, EFI_LOADER_DATA,\n\t\t\t     sizeof(*log_tbl) + log_size, (void **)&log_tbl);\n\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"Unable to allocate memory for event log\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (version == EFI_TCG2_EVENT_LOG_FORMAT_TCG_2)\n\t\tfinal_events_table = get_efi_config_table(LINUX_EFI_TPM_FINAL_LOG_GUID);\n\tif (final_events_table && final_events_table->nr_events) {\n\t\tstruct tcg_pcr_event2_head *header;\n\t\tint offset;\n\t\tvoid *data;\n\t\tint event_size;\n\t\tint i = final_events_table->nr_events;\n\n\t\tdata = (void *)final_events_table;\n\t\toffset = sizeof(final_events_table->version) +\n\t\t\tsizeof(final_events_table->nr_events);\n\n\t\twhile (i > 0) {\n\t\t\theader = data + offset + final_events_size;\n\t\t\tevent_size = __calc_tpm2_event_size(header,\n\t\t\t\t\t\t   (void *)(long)log_location,\n\t\t\t\t\t\t   false);\n\t\t\tfinal_events_size += event_size;\n\t\t\ti--;\n\t\t}\n\t}\n\n\tmemset(log_tbl, 0, sizeof(*log_tbl) + log_size);\n\tlog_tbl->size = log_size;\n\tlog_tbl->final_events_preboot_size = final_events_size;\n\tlog_tbl->version = version;\n\tmemcpy(log_tbl->log, (void *) first_entry_addr, log_size);\n\n\tstatus = efi_bs_call(install_configuration_table,\n\t\t\t     &linux_eventlog_guid, log_tbl);\n\tif (status != EFI_SUCCESS)\n\t\tgoto err_free;\n\treturn;\n\nerr_free:\n\tefi_bs_call(free_pool, log_tbl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}