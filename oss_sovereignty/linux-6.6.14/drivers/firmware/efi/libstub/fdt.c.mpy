{
  "module_name": "fdt.c",
  "hash_id": "2dc8c02f1839dfb6fad80c625d27c4b39b37aa404732bdc0de6053f8d47d13d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/libstub/fdt.c",
  "human_readable_source": "\n \n\n#include <linux/efi.h>\n#include <linux/libfdt.h>\n#include <asm/efi.h>\n\n#include \"efistub.h\"\n\n#define EFI_DT_ADDR_CELLS_DEFAULT 2\n#define EFI_DT_SIZE_CELLS_DEFAULT 2\n\nstatic void fdt_update_cell_size(void *fdt)\n{\n\tint offset;\n\n\toffset = fdt_path_offset(fdt, \"/\");\n\t \n\n\tfdt_setprop_u32(fdt, offset, \"#address-cells\", EFI_DT_ADDR_CELLS_DEFAULT);\n\tfdt_setprop_u32(fdt, offset, \"#size-cells\",    EFI_DT_SIZE_CELLS_DEFAULT);\n}\n\nstatic efi_status_t update_fdt(void *orig_fdt, unsigned long orig_fdt_size,\n\t\t\t       void *fdt, int new_fdt_size, char *cmdline_ptr)\n{\n\tint node, num_rsv;\n\tint status;\n\tu32 fdt_val32;\n\tu64 fdt_val64;\n\n\t \n\tif (orig_fdt) {\n\t\tif (fdt_check_header(orig_fdt)) {\n\t\t\tefi_err(\"Device Tree header not valid!\\n\");\n\t\t\treturn EFI_LOAD_ERROR;\n\t\t}\n\t\t \n\t\tif (orig_fdt_size && fdt_totalsize(orig_fdt) > orig_fdt_size) {\n\t\t\tefi_err(\"Truncated device tree! foo!\\n\");\n\t\t\treturn EFI_LOAD_ERROR;\n\t\t}\n\t}\n\n\tif (orig_fdt) {\n\t\tstatus = fdt_open_into(orig_fdt, fdt, new_fdt_size);\n\t} else {\n\t\tstatus = fdt_create_empty_tree(fdt, new_fdt_size);\n\t\tif (status == 0) {\n\t\t\t \n\t\t\tfdt_update_cell_size(fdt);\n\t\t}\n\t}\n\n\tif (status != 0)\n\t\tgoto fdt_set_fail;\n\n\t \n\tnum_rsv = fdt_num_mem_rsv(fdt);\n\twhile (num_rsv-- > 0)\n\t\tfdt_del_mem_rsv(fdt, num_rsv);\n\n\tnode = fdt_subnode_offset(fdt, 0, \"chosen\");\n\tif (node < 0) {\n\t\tnode = fdt_add_subnode(fdt, 0, \"chosen\");\n\t\tif (node < 0) {\n\t\t\t \n\t\t\tstatus = node;\n\t\t\tgoto fdt_set_fail;\n\t\t}\n\t}\n\n\tif (cmdline_ptr != NULL && strlen(cmdline_ptr) > 0) {\n\t\tstatus = fdt_setprop(fdt, node, \"bootargs\", cmdline_ptr,\n\t\t\t\t     strlen(cmdline_ptr) + 1);\n\t\tif (status)\n\t\t\tgoto fdt_set_fail;\n\t}\n\n\t \n\tnode = fdt_subnode_offset(fdt, 0, \"chosen\");\n\tfdt_val64 = cpu_to_fdt64((u64)(unsigned long)efi_system_table);\n\n\tstatus = fdt_setprop_var(fdt, node, \"linux,uefi-system-table\", fdt_val64);\n\tif (status)\n\t\tgoto fdt_set_fail;\n\n\tfdt_val64 = U64_MAX;  \n\n\tstatus = fdt_setprop_var(fdt, node, \"linux,uefi-mmap-start\", fdt_val64);\n\tif (status)\n\t\tgoto fdt_set_fail;\n\n\tfdt_val32 = U32_MAX;  \n\n\tstatus = fdt_setprop_var(fdt, node, \"linux,uefi-mmap-size\", fdt_val32);\n\tif (status)\n\t\tgoto fdt_set_fail;\n\n\tstatus = fdt_setprop_var(fdt, node, \"linux,uefi-mmap-desc-size\", fdt_val32);\n\tif (status)\n\t\tgoto fdt_set_fail;\n\n\tstatus = fdt_setprop_var(fdt, node, \"linux,uefi-mmap-desc-ver\", fdt_val32);\n\tif (status)\n\t\tgoto fdt_set_fail;\n\n\tif (IS_ENABLED(CONFIG_RANDOMIZE_BASE) && !efi_nokaslr) {\n\t\tefi_status_t efi_status;\n\n\t\tefi_status = efi_get_random_bytes(sizeof(fdt_val64),\n\t\t\t\t\t\t  (u8 *)&fdt_val64);\n\t\tif (efi_status == EFI_SUCCESS) {\n\t\t\tstatus = fdt_setprop_var(fdt, node, \"kaslr-seed\", fdt_val64);\n\t\t\tif (status)\n\t\t\t\tgoto fdt_set_fail;\n\t\t}\n\t}\n\n\t \n\tfdt_pack(fdt);\n\n\treturn EFI_SUCCESS;\n\nfdt_set_fail:\n\tif (status == -FDT_ERR_NOSPACE)\n\t\treturn EFI_BUFFER_TOO_SMALL;\n\n\treturn EFI_LOAD_ERROR;\n}\n\nstatic efi_status_t update_fdt_memmap(void *fdt, struct efi_boot_memmap *map)\n{\n\tint node = fdt_path_offset(fdt, \"/chosen\");\n\tu64 fdt_val64;\n\tu32 fdt_val32;\n\tint err;\n\n\tif (node < 0)\n\t\treturn EFI_LOAD_ERROR;\n\n\tfdt_val64 = cpu_to_fdt64((unsigned long)map->map);\n\n\terr = fdt_setprop_inplace_var(fdt, node, \"linux,uefi-mmap-start\", fdt_val64);\n\tif (err)\n\t\treturn EFI_LOAD_ERROR;\n\n\tfdt_val32 = cpu_to_fdt32(map->map_size);\n\n\terr = fdt_setprop_inplace_var(fdt, node, \"linux,uefi-mmap-size\", fdt_val32);\n\tif (err)\n\t\treturn EFI_LOAD_ERROR;\n\n\tfdt_val32 = cpu_to_fdt32(map->desc_size);\n\n\terr = fdt_setprop_inplace_var(fdt, node, \"linux,uefi-mmap-desc-size\", fdt_val32);\n\tif (err)\n\t\treturn EFI_LOAD_ERROR;\n\n\tfdt_val32 = cpu_to_fdt32(map->desc_ver);\n\n\terr = fdt_setprop_inplace_var(fdt, node, \"linux,uefi-mmap-desc-ver\", fdt_val32);\n\tif (err)\n\t\treturn EFI_LOAD_ERROR;\n\n\treturn EFI_SUCCESS;\n}\n\nstruct exit_boot_struct {\n\tstruct efi_boot_memmap\t*boot_memmap;\n\tefi_memory_desc_t\t*runtime_map;\n\tint\t\t\truntime_entry_count;\n\tvoid\t\t\t*new_fdt_addr;\n};\n\nstatic efi_status_t exit_boot_func(struct efi_boot_memmap *map, void *priv)\n{\n\tstruct exit_boot_struct *p = priv;\n\n\tp->boot_memmap = map;\n\n\t \n\tefi_get_virtmap(map->map, map->map_size, map->desc_size,\n\t\t\tp->runtime_map, &p->runtime_entry_count);\n\n\treturn update_fdt_memmap(p->new_fdt_addr, map);\n}\n\n#ifndef MAX_FDT_SIZE\n# define MAX_FDT_SIZE SZ_2M\n#endif\n\n \nstatic\nefi_status_t allocate_new_fdt_and_exit_boot(void *handle,\n\t\t\t\t\t    efi_loaded_image_t *image,\n\t\t\t\t\t    unsigned long *new_fdt_addr,\n\t\t\t\t\t    char *cmdline_ptr)\n{\n\tunsigned long desc_size;\n\tu32 desc_ver;\n\tefi_status_t status;\n\tstruct exit_boot_struct priv;\n\tunsigned long fdt_addr = 0;\n\tunsigned long fdt_size = 0;\n\n\tif (!efi_novamap) {\n\t\tstatus = efi_alloc_virtmap(&priv.runtime_map, &desc_size,\n\t\t\t\t\t   &desc_ver);\n\t\tif (status != EFI_SUCCESS) {\n\t\t\tefi_err(\"Unable to retrieve UEFI memory map.\\n\");\n\t\t\treturn status;\n\t\t}\n\t}\n\n\t \n\tif (!IS_ENABLED(CONFIG_EFI_ARMSTUB_DTB_LOADER) ||\n\t    efi_get_secureboot() != efi_secureboot_mode_disabled) {\n\t\tif (strstr(cmdline_ptr, \"dtb=\"))\n\t\t\tefi_err(\"Ignoring DTB from command line.\\n\");\n\t} else {\n\t\tstatus = efi_load_dtb(image, &fdt_addr, &fdt_size);\n\n\t\tif (status != EFI_SUCCESS && status != EFI_NOT_READY) {\n\t\t\tefi_err(\"Failed to load device tree!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (fdt_addr) {\n\t\tefi_info(\"Using DTB from command line\\n\");\n\t} else {\n\t\t \n\t\tfdt_addr = (uintptr_t)get_fdt(&fdt_size);\n\t\tif (fdt_addr)\n\t\t\tefi_info(\"Using DTB from configuration table\\n\");\n\t}\n\n\tif (!fdt_addr)\n\t\tefi_info(\"Generating empty DTB\\n\");\n\n\tefi_info(\"Exiting boot services...\\n\");\n\n\tstatus = efi_allocate_pages(MAX_FDT_SIZE, new_fdt_addr, ULONG_MAX);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"Unable to allocate memory for new device tree.\\n\");\n\t\tgoto fail;\n\t}\n\n\tstatus = update_fdt((void *)fdt_addr, fdt_size,\n\t\t\t    (void *)*new_fdt_addr, MAX_FDT_SIZE, cmdline_ptr);\n\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"Unable to construct new device tree.\\n\");\n\t\tgoto fail_free_new_fdt;\n\t}\n\n\tpriv.new_fdt_addr = (void *)*new_fdt_addr;\n\n\tstatus = efi_exit_boot_services(handle, &priv, exit_boot_func);\n\n\tif (status == EFI_SUCCESS) {\n\t\tefi_set_virtual_address_map_t *svam;\n\n\t\tif (efi_novamap)\n\t\t\treturn EFI_SUCCESS;\n\n\t\t \n\t\tsvam = efi_system_table->runtime->set_virtual_address_map;\n\t\tstatus = svam(priv.runtime_entry_count * desc_size, desc_size,\n\t\t\t      desc_ver, priv.runtime_map);\n\n\t\t \n\t\tif (status != EFI_SUCCESS) {\n\t\t\tefi_memory_desc_t *p;\n\t\t\tint l;\n\n\t\t\t \n\t\t\tfor (l = 0; l < priv.boot_memmap->map_size;\n\t\t\t     l += priv.boot_memmap->desc_size) {\n\t\t\t\tp = (void *)priv.boot_memmap->map + l;\n\n\t\t\t\tif (p->attribute & EFI_MEMORY_RUNTIME)\n\t\t\t\t\tp->virt_addr = U64_MAX;\n\t\t\t}\n\t\t}\n\t\treturn EFI_SUCCESS;\n\t}\n\n\tefi_err(\"Exit boot services failed.\\n\");\n\nfail_free_new_fdt:\n\tefi_free(MAX_FDT_SIZE, *new_fdt_addr);\n\nfail:\n\tefi_free(fdt_size, fdt_addr);\n\n\tefi_bs_call(free_pool, priv.runtime_map);\n\n\treturn EFI_LOAD_ERROR;\n}\n\nefi_status_t efi_boot_kernel(void *handle, efi_loaded_image_t *image,\n\t\t\t     unsigned long kernel_addr, char *cmdline_ptr)\n{\n\tunsigned long fdt_addr;\n\tefi_status_t status;\n\n\tstatus = allocate_new_fdt_and_exit_boot(handle, image, &fdt_addr,\n\t\t\t\t\t\tcmdline_ptr);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"Failed to update FDT and exit boot services\\n\");\n\t\treturn status;\n\t}\n\n\tif (IS_ENABLED(CONFIG_ARM))\n\t\tefi_handle_post_ebs_state();\n\n\tefi_enter_kernel(kernel_addr, fdt_addr, fdt_totalsize((void *)fdt_addr));\n\t \n}\n\nvoid *get_fdt(unsigned long *fdt_size)\n{\n\tvoid *fdt;\n\n\tfdt = get_efi_config_table(DEVICE_TREE_GUID);\n\n\tif (!fdt)\n\t\treturn NULL;\n\n\tif (fdt_check_header(fdt) != 0) {\n\t\tefi_err(\"Invalid header detected on UEFI supplied FDT, ignoring ...\\n\");\n\t\treturn NULL;\n\t}\n\t*fdt_size = fdt_totalsize(fdt);\n\treturn fdt;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}