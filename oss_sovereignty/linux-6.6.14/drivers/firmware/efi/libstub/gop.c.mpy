{
  "module_name": "gop.c",
  "hash_id": "e436f00533791458d32034bc639075ea384d062fede0da42c50880202db824d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/libstub/gop.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/ctype.h>\n#include <linux/efi.h>\n#include <linux/screen_info.h>\n#include <linux/string.h>\n#include <asm/efi.h>\n#include <asm/setup.h>\n\n#include \"efistub.h\"\n\nenum efi_cmdline_option {\n\tEFI_CMDLINE_NONE,\n\tEFI_CMDLINE_MODE_NUM,\n\tEFI_CMDLINE_RES,\n\tEFI_CMDLINE_AUTO,\n\tEFI_CMDLINE_LIST\n};\n\nstatic struct {\n\tenum efi_cmdline_option option;\n\tunion {\n\t\tu32 mode;\n\t\tstruct {\n\t\t\tu32 width, height;\n\t\t\tint format;\n\t\t\tu8 depth;\n\t\t} res;\n\t};\n} cmdline = { .option = EFI_CMDLINE_NONE };\n\nstatic bool parse_modenum(char *option, char **next)\n{\n\tu32 m;\n\n\tif (!strstarts(option, \"mode=\"))\n\t\treturn false;\n\toption += strlen(\"mode=\");\n\tm = simple_strtoull(option, &option, 0);\n\tif (*option && *option++ != ',')\n\t\treturn false;\n\tcmdline.option = EFI_CMDLINE_MODE_NUM;\n\tcmdline.mode   = m;\n\n\t*next = option;\n\treturn true;\n}\n\nstatic bool parse_res(char *option, char **next)\n{\n\tu32 w, h, d = 0;\n\tint pf = -1;\n\n\tif (!isdigit(*option))\n\t\treturn false;\n\tw = simple_strtoull(option, &option, 10);\n\tif (*option++ != 'x' || !isdigit(*option))\n\t\treturn false;\n\th = simple_strtoull(option, &option, 10);\n\tif (*option == '-') {\n\t\toption++;\n\t\tif (strstarts(option, \"rgb\")) {\n\t\t\toption += strlen(\"rgb\");\n\t\t\tpf = PIXEL_RGB_RESERVED_8BIT_PER_COLOR;\n\t\t} else if (strstarts(option, \"bgr\")) {\n\t\t\toption += strlen(\"bgr\");\n\t\t\tpf = PIXEL_BGR_RESERVED_8BIT_PER_COLOR;\n\t\t} else if (isdigit(*option))\n\t\t\td = simple_strtoull(option, &option, 10);\n\t\telse\n\t\t\treturn false;\n\t}\n\tif (*option && *option++ != ',')\n\t\treturn false;\n\tcmdline.option     = EFI_CMDLINE_RES;\n\tcmdline.res.width  = w;\n\tcmdline.res.height = h;\n\tcmdline.res.format = pf;\n\tcmdline.res.depth  = d;\n\n\t*next = option;\n\treturn true;\n}\n\nstatic bool parse_auto(char *option, char **next)\n{\n\tif (!strstarts(option, \"auto\"))\n\t\treturn false;\n\toption += strlen(\"auto\");\n\tif (*option && *option++ != ',')\n\t\treturn false;\n\tcmdline.option = EFI_CMDLINE_AUTO;\n\n\t*next = option;\n\treturn true;\n}\n\nstatic bool parse_list(char *option, char **next)\n{\n\tif (!strstarts(option, \"list\"))\n\t\treturn false;\n\toption += strlen(\"list\");\n\tif (*option && *option++ != ',')\n\t\treturn false;\n\tcmdline.option = EFI_CMDLINE_LIST;\n\n\t*next = option;\n\treturn true;\n}\n\nvoid efi_parse_option_graphics(char *option)\n{\n\twhile (*option) {\n\t\tif (parse_modenum(option, &option))\n\t\t\tcontinue;\n\t\tif (parse_res(option, &option))\n\t\t\tcontinue;\n\t\tif (parse_auto(option, &option))\n\t\t\tcontinue;\n\t\tif (parse_list(option, &option))\n\t\t\tcontinue;\n\n\t\twhile (*option && *option++ != ',')\n\t\t\t;\n\t}\n}\n\nstatic u32 choose_mode_modenum(efi_graphics_output_protocol_t *gop)\n{\n\tefi_status_t status;\n\n\tefi_graphics_output_protocol_mode_t *mode;\n\tefi_graphics_output_mode_info_t *info;\n\tunsigned long info_size;\n\n\tu32 max_mode, cur_mode;\n\tint pf;\n\n\tmode = efi_table_attr(gop, mode);\n\n\tcur_mode = efi_table_attr(mode, mode);\n\tif (cmdline.mode == cur_mode)\n\t\treturn cur_mode;\n\n\tmax_mode = efi_table_attr(mode, max_mode);\n\tif (cmdline.mode >= max_mode) {\n\t\tefi_err(\"Requested mode is invalid\\n\");\n\t\treturn cur_mode;\n\t}\n\n\tstatus = efi_call_proto(gop, query_mode, cmdline.mode,\n\t\t\t\t&info_size, &info);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"Couldn't get mode information\\n\");\n\t\treturn cur_mode;\n\t}\n\n\tpf = info->pixel_format;\n\n\tefi_bs_call(free_pool, info);\n\n\tif (pf == PIXEL_BLT_ONLY || pf >= PIXEL_FORMAT_MAX) {\n\t\tefi_err(\"Invalid PixelFormat\\n\");\n\t\treturn cur_mode;\n\t}\n\n\treturn cmdline.mode;\n}\n\nstatic u8 pixel_bpp(int pixel_format, efi_pixel_bitmask_t pixel_info)\n{\n\tif (pixel_format == PIXEL_BIT_MASK) {\n\t\tu32 mask = pixel_info.red_mask | pixel_info.green_mask |\n\t\t\t   pixel_info.blue_mask | pixel_info.reserved_mask;\n\t\tif (!mask)\n\t\t\treturn 0;\n\t\treturn __fls(mask) - __ffs(mask) + 1;\n\t} else\n\t\treturn 32;\n}\n\nstatic u32 choose_mode_res(efi_graphics_output_protocol_t *gop)\n{\n\tefi_status_t status;\n\n\tefi_graphics_output_protocol_mode_t *mode;\n\tefi_graphics_output_mode_info_t *info;\n\tunsigned long info_size;\n\n\tu32 max_mode, cur_mode;\n\tint pf;\n\tefi_pixel_bitmask_t pi;\n\tu32 m, w, h;\n\n\tmode = efi_table_attr(gop, mode);\n\n\tcur_mode = efi_table_attr(mode, mode);\n\tinfo = efi_table_attr(mode, info);\n\tpf = info->pixel_format;\n\tpi = info->pixel_information;\n\tw  = info->horizontal_resolution;\n\th  = info->vertical_resolution;\n\n\tif (w == cmdline.res.width && h == cmdline.res.height &&\n\t    (cmdline.res.format < 0 || cmdline.res.format == pf) &&\n\t    (!cmdline.res.depth || cmdline.res.depth == pixel_bpp(pf, pi)))\n\t\treturn cur_mode;\n\n\tmax_mode = efi_table_attr(mode, max_mode);\n\n\tfor (m = 0; m < max_mode; m++) {\n\t\tif (m == cur_mode)\n\t\t\tcontinue;\n\n\t\tstatus = efi_call_proto(gop, query_mode, m,\n\t\t\t\t\t&info_size, &info);\n\t\tif (status != EFI_SUCCESS)\n\t\t\tcontinue;\n\n\t\tpf = info->pixel_format;\n\t\tpi = info->pixel_information;\n\t\tw  = info->horizontal_resolution;\n\t\th  = info->vertical_resolution;\n\n\t\tefi_bs_call(free_pool, info);\n\n\t\tif (pf == PIXEL_BLT_ONLY || pf >= PIXEL_FORMAT_MAX)\n\t\t\tcontinue;\n\t\tif (w == cmdline.res.width && h == cmdline.res.height &&\n\t\t    (cmdline.res.format < 0 || cmdline.res.format == pf) &&\n\t\t    (!cmdline.res.depth || cmdline.res.depth == pixel_bpp(pf, pi)))\n\t\t\treturn m;\n\t}\n\n\tefi_err(\"Couldn't find requested mode\\n\");\n\n\treturn cur_mode;\n}\n\nstatic u32 choose_mode_auto(efi_graphics_output_protocol_t *gop)\n{\n\tefi_status_t status;\n\n\tefi_graphics_output_protocol_mode_t *mode;\n\tefi_graphics_output_mode_info_t *info;\n\tunsigned long info_size;\n\n\tu32 max_mode, cur_mode, best_mode, area;\n\tu8 depth;\n\tint pf;\n\tefi_pixel_bitmask_t pi;\n\tu32 m, w, h, a;\n\tu8 d;\n\n\tmode = efi_table_attr(gop, mode);\n\n\tcur_mode = efi_table_attr(mode, mode);\n\tmax_mode = efi_table_attr(mode, max_mode);\n\n\tinfo = efi_table_attr(mode, info);\n\n\tpf = info->pixel_format;\n\tpi = info->pixel_information;\n\tw  = info->horizontal_resolution;\n\th  = info->vertical_resolution;\n\n\tbest_mode = cur_mode;\n\tarea = w * h;\n\tdepth = pixel_bpp(pf, pi);\n\n\tfor (m = 0; m < max_mode; m++) {\n\t\tif (m == cur_mode)\n\t\t\tcontinue;\n\n\t\tstatus = efi_call_proto(gop, query_mode, m,\n\t\t\t\t\t&info_size, &info);\n\t\tif (status != EFI_SUCCESS)\n\t\t\tcontinue;\n\n\t\tpf = info->pixel_format;\n\t\tpi = info->pixel_information;\n\t\tw  = info->horizontal_resolution;\n\t\th  = info->vertical_resolution;\n\n\t\tefi_bs_call(free_pool, info);\n\n\t\tif (pf == PIXEL_BLT_ONLY || pf >= PIXEL_FORMAT_MAX)\n\t\t\tcontinue;\n\t\ta = w * h;\n\t\tif (a < area)\n\t\t\tcontinue;\n\t\td = pixel_bpp(pf, pi);\n\t\tif (a > area || d > depth) {\n\t\t\tbest_mode = m;\n\t\t\tarea = a;\n\t\t\tdepth = d;\n\t\t}\n\t}\n\n\treturn best_mode;\n}\n\nstatic u32 choose_mode_list(efi_graphics_output_protocol_t *gop)\n{\n\tefi_status_t status;\n\n\tefi_graphics_output_protocol_mode_t *mode;\n\tefi_graphics_output_mode_info_t *info;\n\tunsigned long info_size;\n\n\tu32 max_mode, cur_mode;\n\tint pf;\n\tefi_pixel_bitmask_t pi;\n\tu32 m, w, h;\n\tu8 d;\n\tconst char *dstr;\n\tbool valid;\n\tefi_input_key_t key;\n\n\tmode = efi_table_attr(gop, mode);\n\n\tcur_mode = efi_table_attr(mode, mode);\n\tmax_mode = efi_table_attr(mode, max_mode);\n\n\tefi_printk(\"Available graphics modes are 0-%u\\n\", max_mode-1);\n\tefi_puts(\"  * = current mode\\n\"\n\t\t \"  - = unusable mode\\n\");\n\tfor (m = 0; m < max_mode; m++) {\n\t\tstatus = efi_call_proto(gop, query_mode, m,\n\t\t\t\t\t&info_size, &info);\n\t\tif (status != EFI_SUCCESS)\n\t\t\tcontinue;\n\n\t\tpf = info->pixel_format;\n\t\tpi = info->pixel_information;\n\t\tw  = info->horizontal_resolution;\n\t\th  = info->vertical_resolution;\n\n\t\tefi_bs_call(free_pool, info);\n\n\t\tvalid = !(pf == PIXEL_BLT_ONLY || pf >= PIXEL_FORMAT_MAX);\n\t\td = 0;\n\t\tswitch (pf) {\n\t\tcase PIXEL_RGB_RESERVED_8BIT_PER_COLOR:\n\t\t\tdstr = \"rgb\";\n\t\t\tbreak;\n\t\tcase PIXEL_BGR_RESERVED_8BIT_PER_COLOR:\n\t\t\tdstr = \"bgr\";\n\t\t\tbreak;\n\t\tcase PIXEL_BIT_MASK:\n\t\t\tdstr = \"\";\n\t\t\td = pixel_bpp(pf, pi);\n\t\t\tbreak;\n\t\tcase PIXEL_BLT_ONLY:\n\t\t\tdstr = \"blt\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdstr = \"xxx\";\n\t\t\tbreak;\n\t\t}\n\n\t\tefi_printk(\"Mode %3u %c%c: Resolution %ux%u-%s%.0hhu\\n\",\n\t\t\t   m,\n\t\t\t   m == cur_mode ? '*' : ' ',\n\t\t\t   !valid ? '-' : ' ',\n\t\t\t   w, h, dstr, d);\n\t}\n\n\tefi_puts(\"\\nPress any key to continue (or wait 10 seconds)\\n\");\n\tstatus = efi_wait_for_key(10 * EFI_USEC_PER_SEC, &key);\n\tif (status != EFI_SUCCESS && status != EFI_TIMEOUT) {\n\t\tefi_err(\"Unable to read key, continuing in 10 seconds\\n\");\n\t\tefi_bs_call(stall, 10 * EFI_USEC_PER_SEC);\n\t}\n\n\treturn cur_mode;\n}\n\nstatic void set_mode(efi_graphics_output_protocol_t *gop)\n{\n\tefi_graphics_output_protocol_mode_t *mode;\n\tu32 cur_mode, new_mode;\n\n\tswitch (cmdline.option) {\n\tcase EFI_CMDLINE_MODE_NUM:\n\t\tnew_mode = choose_mode_modenum(gop);\n\t\tbreak;\n\tcase EFI_CMDLINE_RES:\n\t\tnew_mode = choose_mode_res(gop);\n\t\tbreak;\n\tcase EFI_CMDLINE_AUTO:\n\t\tnew_mode = choose_mode_auto(gop);\n\t\tbreak;\n\tcase EFI_CMDLINE_LIST:\n\t\tnew_mode = choose_mode_list(gop);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tmode = efi_table_attr(gop, mode);\n\tcur_mode = efi_table_attr(mode, mode);\n\n\tif (new_mode == cur_mode)\n\t\treturn;\n\n\tif (efi_call_proto(gop, set_mode, new_mode) != EFI_SUCCESS)\n\t\tefi_err(\"Failed to set requested mode\\n\");\n}\n\nstatic void find_bits(u32 mask, u8 *pos, u8 *size)\n{\n\tif (!mask) {\n\t\t*pos = *size = 0;\n\t\treturn;\n\t}\n\n\t \n\t*pos  = __ffs(mask);\n\t*size = __fls(mask) - *pos + 1;\n}\n\nstatic void\nsetup_pixel_info(struct screen_info *si, u32 pixels_per_scan_line,\n\t\t efi_pixel_bitmask_t pixel_info, int pixel_format)\n{\n\tif (pixel_format == PIXEL_BIT_MASK) {\n\t\tfind_bits(pixel_info.red_mask,\n\t\t\t  &si->red_pos, &si->red_size);\n\t\tfind_bits(pixel_info.green_mask,\n\t\t\t  &si->green_pos, &si->green_size);\n\t\tfind_bits(pixel_info.blue_mask,\n\t\t\t  &si->blue_pos, &si->blue_size);\n\t\tfind_bits(pixel_info.reserved_mask,\n\t\t\t  &si->rsvd_pos, &si->rsvd_size);\n\t\tsi->lfb_depth = si->red_size + si->green_size +\n\t\t\tsi->blue_size + si->rsvd_size;\n\t\tsi->lfb_linelength = (pixels_per_scan_line * si->lfb_depth) / 8;\n\t} else {\n\t\tif (pixel_format == PIXEL_RGB_RESERVED_8BIT_PER_COLOR) {\n\t\t\tsi->red_pos   = 0;\n\t\t\tsi->blue_pos  = 16;\n\t\t} else   {\n\t\t\tsi->blue_pos  = 0;\n\t\t\tsi->red_pos   = 16;\n\t\t}\n\n\t\tsi->green_pos = 8;\n\t\tsi->rsvd_pos  = 24;\n\t\tsi->red_size = si->green_size =\n\t\t\tsi->blue_size = si->rsvd_size = 8;\n\n\t\tsi->lfb_depth = 32;\n\t\tsi->lfb_linelength = pixels_per_scan_line * 4;\n\t}\n}\n\nstatic efi_graphics_output_protocol_t *\nfind_gop(efi_guid_t *proto, unsigned long size, void **handles)\n{\n\tefi_graphics_output_protocol_t *first_gop;\n\tefi_handle_t h;\n\tint i;\n\n\tfirst_gop = NULL;\n\n\tfor_each_efi_handle(h, handles, size, i) {\n\t\tefi_status_t status;\n\n\t\tefi_graphics_output_protocol_t *gop;\n\t\tefi_graphics_output_protocol_mode_t *mode;\n\t\tefi_graphics_output_mode_info_t *info;\n\n\t\tefi_guid_t conout_proto = EFI_CONSOLE_OUT_DEVICE_GUID;\n\t\tvoid *dummy = NULL;\n\n\t\tstatus = efi_bs_call(handle_protocol, h, proto, (void **)&gop);\n\t\tif (status != EFI_SUCCESS)\n\t\t\tcontinue;\n\n\t\tmode = efi_table_attr(gop, mode);\n\t\tinfo = efi_table_attr(mode, info);\n\t\tif (info->pixel_format == PIXEL_BLT_ONLY ||\n\t\t    info->pixel_format >= PIXEL_FORMAT_MAX)\n\t\t\tcontinue;\n\n\t\t \n\t\tstatus = efi_bs_call(handle_protocol, h, &conout_proto, &dummy);\n\t\tif (status == EFI_SUCCESS)\n\t\t\treturn gop;\n\n\t\tif (!first_gop)\n\t\t\tfirst_gop = gop;\n\t}\n\n\treturn first_gop;\n}\n\nstatic efi_status_t setup_gop(struct screen_info *si, efi_guid_t *proto,\n\t\t\t      unsigned long size, void **handles)\n{\n\tefi_graphics_output_protocol_t *gop;\n\tefi_graphics_output_protocol_mode_t *mode;\n\tefi_graphics_output_mode_info_t *info;\n\n\tgop = find_gop(proto, size, handles);\n\n\t \n\tif (!gop)\n\t\treturn EFI_NOT_FOUND;\n\n\t \n\tset_mode(gop);\n\n\t \n\tmode = efi_table_attr(gop, mode);\n\tinfo = efi_table_attr(mode, info);\n\n\tsi->orig_video_isVGA = VIDEO_TYPE_EFI;\n\n\tsi->lfb_width  = info->horizontal_resolution;\n\tsi->lfb_height = info->vertical_resolution;\n\n\tefi_set_u64_split(efi_table_attr(mode, frame_buffer_base),\n\t\t\t  &si->lfb_base, &si->ext_lfb_base);\n\tif (si->ext_lfb_base)\n\t\tsi->capabilities |= VIDEO_CAPABILITY_64BIT_BASE;\n\n\tsi->pages = 1;\n\n\tsetup_pixel_info(si, info->pixels_per_scan_line,\n\t\t\t     info->pixel_information, info->pixel_format);\n\n\tsi->lfb_size = si->lfb_linelength * si->lfb_height;\n\n\tsi->capabilities |= VIDEO_CAPABILITY_SKIP_QUIRKS;\n\n\treturn EFI_SUCCESS;\n}\n\n \nefi_status_t efi_setup_gop(struct screen_info *si, efi_guid_t *proto,\n\t\t\t   unsigned long size)\n{\n\tefi_status_t status;\n\tvoid **gop_handle = NULL;\n\n\tstatus = efi_bs_call(allocate_pool, EFI_LOADER_DATA, size,\n\t\t\t     (void **)&gop_handle);\n\tif (status != EFI_SUCCESS)\n\t\treturn status;\n\n\tstatus = efi_bs_call(locate_handle, EFI_LOCATE_BY_PROTOCOL, proto, NULL,\n\t\t\t     &size, gop_handle);\n\tif (status != EFI_SUCCESS)\n\t\tgoto free_handle;\n\n\tstatus = setup_gop(si, proto, size, gop_handle);\n\nfree_handle:\n\tefi_bs_call(free_pool, gop_handle);\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}