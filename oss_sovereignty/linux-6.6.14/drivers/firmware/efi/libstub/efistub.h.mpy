{
  "module_name": "efistub.h",
  "hash_id": "0d45c2cdbcb995c85290830172c0b689d2a27c24d9ebb6abf9575fa1f2e5c884",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/libstub/efistub.h",
  "human_readable_source": " \n\n#ifndef _DRIVERS_FIRMWARE_EFI_EFISTUB_H\n#define _DRIVERS_FIRMWARE_EFI_EFISTUB_H\n\n#include <linux/compiler.h>\n#include <linux/efi.h>\n#include <linux/kernel.h>\n#include <linux/kern_levels.h>\n#include <linux/types.h>\n#include <asm/efi.h>\n\n \n#undef __init\n\n \n#ifndef EFI_ALLOC_ALIGN\n#define EFI_ALLOC_ALIGN\t\tEFI_PAGE_SIZE\n#endif\n\n#ifndef EFI_ALLOC_LIMIT\n#define EFI_ALLOC_LIMIT\t\tULONG_MAX\n#endif\n\nextern bool efi_no5lvl;\nextern bool efi_nochunk;\nextern bool efi_nokaslr;\nextern int efi_loglevel;\nextern bool efi_novamap;\n\nextern const efi_system_table_t *efi_system_table;\n\ntypedef union efi_dxe_services_table efi_dxe_services_table_t;\nextern const efi_dxe_services_table_t *efi_dxe_table;\n\nefi_status_t __efiapi efi_pe_entry(efi_handle_t handle,\n\t\t\t\t   efi_system_table_t *sys_table_arg);\n\n#ifndef ARCH_HAS_EFISTUB_WRAPPERS\n\n#define efi_is_native()\t\t\t(true)\n#define efi_table_attr(inst, attr)\t(inst)->attr\n#define efi_fn_call(inst, func, ...)\t(inst)->func(__VA_ARGS__)\n\n#endif\n\n#define efi_call_proto(inst, func, ...) ({\t\t\t\\\n\t__typeof__(inst) __inst = (inst);\t\t\t\\\n\tefi_fn_call(__inst, func, __inst, ##__VA_ARGS__);\t\\\n})\n#define efi_bs_call(func, ...) \\\n\tefi_fn_call(efi_table_attr(efi_system_table, boottime), func, ##__VA_ARGS__)\n#define efi_rt_call(func, ...) \\\n\tefi_fn_call(efi_table_attr(efi_system_table, runtime), func, ##__VA_ARGS__)\n#define efi_dxe_call(func, ...) \\\n\tefi_fn_call(efi_dxe_table, func, ##__VA_ARGS__)\n\n#define efi_info(fmt, ...) \\\n\tefi_printk(KERN_INFO fmt, ##__VA_ARGS__)\n#define efi_warn(fmt, ...) \\\n\tefi_printk(KERN_WARNING \"WARNING: \" fmt, ##__VA_ARGS__)\n#define efi_err(fmt, ...) \\\n\tefi_printk(KERN_ERR \"ERROR: \" fmt, ##__VA_ARGS__)\n#define efi_debug(fmt, ...) \\\n\tefi_printk(KERN_DEBUG \"DEBUG: \" fmt, ##__VA_ARGS__)\n\n#define efi_printk_once(fmt, ...) \t\t\\\n({\t\t\t\t\t\t\\\n\tstatic bool __print_once;\t\t\\\n\tbool __ret_print_once = !__print_once;\t\\\n\t\t\t\t\t\t\\\n\tif (!__print_once) {\t\t\t\\\n\t\t__print_once = true;\t\t\\\n\t\tefi_printk(fmt, ##__VA_ARGS__);\t\\\n\t}\t\t\t\t\t\\\n\t__ret_print_once;\t\t\t\\\n})\n\n#define efi_info_once(fmt, ...) \\\n\tefi_printk_once(KERN_INFO fmt, ##__VA_ARGS__)\n#define efi_warn_once(fmt, ...) \\\n\tefi_printk_once(KERN_WARNING \"WARNING: \" fmt, ##__VA_ARGS__)\n#define efi_err_once(fmt, ...) \\\n\tefi_printk_once(KERN_ERR \"ERROR: \" fmt, ##__VA_ARGS__)\n#define efi_debug_once(fmt, ...) \\\n\tefi_printk_once(KERN_DEBUG \"DEBUG: \" fmt, ##__VA_ARGS__)\n\n \n#ifndef fdt_setprop_inplace_var\n#define fdt_setprop_inplace_var(fdt, node_offset, name, var) \\\n\tfdt_setprop_inplace((fdt), (node_offset), (name), &(var), sizeof(var))\n#endif\n\n#ifndef fdt_setprop_var\n#define fdt_setprop_var(fdt, node_offset, name, var) \\\n\tfdt_setprop((fdt), (node_offset), (name), &(var), sizeof(var))\n#endif\n\n#define get_efi_var(name, vendor, ...)\t\t\t\t\\\n\tefi_rt_call(get_variable, (efi_char16_t *)(name),\t\\\n\t\t    (efi_guid_t *)(vendor), __VA_ARGS__)\n\n#define set_efi_var(name, vendor, ...)\t\t\t\t\\\n\tefi_rt_call(set_variable, (efi_char16_t *)(name),\t\\\n\t\t    (efi_guid_t *)(vendor), __VA_ARGS__)\n\n#define efi_get_handle_at(array, idx)\t\t\t\t\t\\\n\t(efi_is_native() ? (array)[idx] \t\t\t\t\\\n\t\t: (efi_handle_t)(unsigned long)((u32 *)(array))[idx])\n\n#define efi_get_handle_num(size)\t\t\t\t\t\\\n\t((size) / (efi_is_native() ? sizeof(efi_handle_t) : sizeof(u32)))\n\n#define for_each_efi_handle(handle, array, size, i)\t\t\t\\\n\tfor (i = 0;\t\t\t\t\t\t\t\\\n\t     i < efi_get_handle_num(size) &&\t\t\t\t\\\n\t\t((handle = efi_get_handle_at((array), i)) || true);\t\\\n\t     i++)\n\nstatic inline\nvoid efi_set_u64_split(u64 data, u32 *lo, u32 *hi)\n{\n\t*lo = lower_32_bits(data);\n\t*hi = upper_32_bits(data);\n}\n\n \n#define EFI_ALLOCATE_ANY_PAGES\t\t0\n#define EFI_ALLOCATE_MAX_ADDRESS\t1\n#define EFI_ALLOCATE_ADDRESS\t\t2\n#define EFI_MAX_ALLOCATE_TYPE\t\t3\n\n \n#define EFI_LOCATE_ALL_HANDLES\t\t\t0\n#define EFI_LOCATE_BY_REGISTER_NOTIFY\t\t1\n#define EFI_LOCATE_BY_PROTOCOL\t\t\t2\n\n \n#define EFI_USEC_PER_SEC\t\t1000000\n\n \n#define EFI_100NSEC_PER_USEC\t((u64)10)\n\n \n#define EFI_MMAP_NR_SLACK_SLOTS\t8\n\ntypedef struct efi_generic_dev_path efi_device_path_protocol_t;\n\nunion efi_device_path_to_text_protocol {\n\tstruct {\n\t\tefi_char16_t *(__efiapi *convert_device_node_to_text)(\n\t\t\t\t\tconst efi_device_path_protocol_t *,\n\t\t\t\t\tbool, bool);\n\t\tefi_char16_t *(__efiapi *convert_device_path_to_text)(\n\t\t\t\t\tconst efi_device_path_protocol_t *,\n\t\t\t\t\tbool, bool);\n\t};\n\tstruct {\n\t\tu32 convert_device_node_to_text;\n\t\tu32 convert_device_path_to_text;\n\t} mixed_mode;\n};\n\ntypedef union efi_device_path_to_text_protocol efi_device_path_to_text_protocol_t;\n\nunion efi_device_path_from_text_protocol {\n\tstruct {\n\t\tefi_device_path_protocol_t *\n\t\t\t(__efiapi *convert_text_to_device_node)(const efi_char16_t *);\n\t\tefi_device_path_protocol_t *\n\t\t\t(__efiapi *convert_text_to_device_path)(const efi_char16_t *);\n\t};\n\tstruct {\n\t\tu32 convert_text_to_device_node;\n\t\tu32 convert_text_to_device_path;\n\t} mixed_mode;\n};\n\ntypedef union efi_device_path_from_text_protocol efi_device_path_from_text_protocol_t;\n\ntypedef void *efi_event_t;\n \ntypedef void (__efiapi *efi_event_notify_t)(efi_event_t, void *);\n\n#define EFI_EVT_TIMER\t\t0x80000000U\n#define EFI_EVT_RUNTIME\t\t0x40000000U\n#define EFI_EVT_NOTIFY_WAIT\t0x00000100U\n#define EFI_EVT_NOTIFY_SIGNAL\t0x00000200U\n\n \nstatic inline\nvoid efi_set_event_at(efi_event_t *events, size_t idx, efi_event_t event)\n{\n\tif (efi_is_native())\n\t\tevents[idx] = event;\n\telse\n\t\t((u32 *)events)[idx] = (u32)(unsigned long)event;\n}\n\n#define EFI_TPL_APPLICATION\t4\n#define EFI_TPL_CALLBACK\t8\n#define EFI_TPL_NOTIFY\t\t16\n#define EFI_TPL_HIGH_LEVEL\t31\n\ntypedef enum {\n\tEfiTimerCancel,\n\tEfiTimerPeriodic,\n\tEfiTimerRelative\n} EFI_TIMER_DELAY;\n\n \nunion efi_boot_services {\n\tstruct {\n\t\tefi_table_hdr_t hdr;\n\t\tvoid *raise_tpl;\n\t\tvoid *restore_tpl;\n\t\tefi_status_t (__efiapi *allocate_pages)(int, int, unsigned long,\n\t\t\t\t\t\t\tefi_physical_addr_t *);\n\t\tefi_status_t (__efiapi *free_pages)(efi_physical_addr_t,\n\t\t\t\t\t\t    unsigned long);\n\t\tefi_status_t (__efiapi *get_memory_map)(unsigned long *, void *,\n\t\t\t\t\t\t\tunsigned long *,\n\t\t\t\t\t\t\tunsigned long *, u32 *);\n\t\tefi_status_t (__efiapi *allocate_pool)(int, unsigned long,\n\t\t\t\t\t\t       void **);\n\t\tefi_status_t (__efiapi *free_pool)(void *);\n\t\tefi_status_t (__efiapi *create_event)(u32, unsigned long,\n\t\t\t\t\t\t      efi_event_notify_t, void *,\n\t\t\t\t\t\t      efi_event_t *);\n\t\tefi_status_t (__efiapi *set_timer)(efi_event_t,\n\t\t\t\t\t\t  EFI_TIMER_DELAY, u64);\n\t\tefi_status_t (__efiapi *wait_for_event)(unsigned long,\n\t\t\t\t\t\t\tefi_event_t *,\n\t\t\t\t\t\t\tunsigned long *);\n\t\tvoid *signal_event;\n\t\tefi_status_t (__efiapi *close_event)(efi_event_t);\n\t\tvoid *check_event;\n\t\tvoid *install_protocol_interface;\n\t\tvoid *reinstall_protocol_interface;\n\t\tvoid *uninstall_protocol_interface;\n\t\tefi_status_t (__efiapi *handle_protocol)(efi_handle_t,\n\t\t\t\t\t\t\t efi_guid_t *, void **);\n\t\tvoid *__reserved;\n\t\tvoid *register_protocol_notify;\n\t\tefi_status_t (__efiapi *locate_handle)(int, efi_guid_t *,\n\t\t\t\t\t\t       void *, unsigned long *,\n\t\t\t\t\t\t       efi_handle_t *);\n\t\tefi_status_t (__efiapi *locate_device_path)(efi_guid_t *,\n\t\t\t\t\t\t\t    efi_device_path_protocol_t **,\n\t\t\t\t\t\t\t    efi_handle_t *);\n\t\tefi_status_t (__efiapi *install_configuration_table)(efi_guid_t *,\n\t\t\t\t\t\t\t\t     void *);\n\t\tefi_status_t (__efiapi *load_image)(bool, efi_handle_t,\n\t\t\t\t\t\t    efi_device_path_protocol_t *,\n\t\t\t\t\t\t    void *, unsigned long,\n\t\t\t\t\t\t    efi_handle_t *);\n\t\tefi_status_t (__efiapi *start_image)(efi_handle_t, unsigned long *,\n\t\t\t\t\t\t     efi_char16_t **);\n\t\tefi_status_t __noreturn (__efiapi *exit)(efi_handle_t,\n\t\t\t\t\t\t\t efi_status_t,\n\t\t\t\t\t\t\t unsigned long,\n\t\t\t\t\t\t\t efi_char16_t *);\n\t\tefi_status_t (__efiapi *unload_image)(efi_handle_t);\n\t\tefi_status_t (__efiapi *exit_boot_services)(efi_handle_t,\n\t\t\t\t\t\t\t    unsigned long);\n\t\tvoid *get_next_monotonic_count;\n\t\tefi_status_t (__efiapi *stall)(unsigned long);\n\t\tvoid *set_watchdog_timer;\n\t\tvoid *connect_controller;\n\t\tefi_status_t (__efiapi *disconnect_controller)(efi_handle_t,\n\t\t\t\t\t\t\t       efi_handle_t,\n\t\t\t\t\t\t\t       efi_handle_t);\n\t\tvoid *open_protocol;\n\t\tvoid *close_protocol;\n\t\tvoid *open_protocol_information;\n\t\tvoid *protocols_per_handle;\n\t\tvoid *locate_handle_buffer;\n\t\tefi_status_t (__efiapi *locate_protocol)(efi_guid_t *, void *,\n\t\t\t\t\t\t\t void **);\n\t\tefi_status_t (__efiapi *install_multiple_protocol_interfaces)(efi_handle_t *, ...);\n\t\tefi_status_t (__efiapi *uninstall_multiple_protocol_interfaces)(efi_handle_t, ...);\n\t\tvoid *calculate_crc32;\n\t\tvoid (__efiapi *copy_mem)(void *, const void *, unsigned long);\n\t\tvoid (__efiapi *set_mem)(void *, unsigned long, unsigned char);\n\t\tvoid *create_event_ex;\n\t};\n\tstruct {\n\t\tefi_table_hdr_t hdr;\n\t\tu32 raise_tpl;\n\t\tu32 restore_tpl;\n\t\tu32 allocate_pages;\n\t\tu32 free_pages;\n\t\tu32 get_memory_map;\n\t\tu32 allocate_pool;\n\t\tu32 free_pool;\n\t\tu32 create_event;\n\t\tu32 set_timer;\n\t\tu32 wait_for_event;\n\t\tu32 signal_event;\n\t\tu32 close_event;\n\t\tu32 check_event;\n\t\tu32 install_protocol_interface;\n\t\tu32 reinstall_protocol_interface;\n\t\tu32 uninstall_protocol_interface;\n\t\tu32 handle_protocol;\n\t\tu32 __reserved;\n\t\tu32 register_protocol_notify;\n\t\tu32 locate_handle;\n\t\tu32 locate_device_path;\n\t\tu32 install_configuration_table;\n\t\tu32 load_image;\n\t\tu32 start_image;\n\t\tu32 exit;\n\t\tu32 unload_image;\n\t\tu32 exit_boot_services;\n\t\tu32 get_next_monotonic_count;\n\t\tu32 stall;\n\t\tu32 set_watchdog_timer;\n\t\tu32 connect_controller;\n\t\tu32 disconnect_controller;\n\t\tu32 open_protocol;\n\t\tu32 close_protocol;\n\t\tu32 open_protocol_information;\n\t\tu32 protocols_per_handle;\n\t\tu32 locate_handle_buffer;\n\t\tu32 locate_protocol;\n\t\tu32 install_multiple_protocol_interfaces;\n\t\tu32 uninstall_multiple_protocol_interfaces;\n\t\tu32 calculate_crc32;\n\t\tu32 copy_mem;\n\t\tu32 set_mem;\n\t\tu32 create_event_ex;\n\t} mixed_mode;\n};\n\ntypedef enum {\n\tEfiGcdMemoryTypeNonExistent,\n\tEfiGcdMemoryTypeReserved,\n\tEfiGcdMemoryTypeSystemMemory,\n\tEfiGcdMemoryTypeMemoryMappedIo,\n\tEfiGcdMemoryTypePersistent,\n\tEfiGcdMemoryTypeMoreReliable,\n\tEfiGcdMemoryTypeMaximum\n} efi_gcd_memory_type_t;\n\ntypedef struct {\n\tefi_physical_addr_t base_address;\n\tu64 length;\n\tu64 capabilities;\n\tu64 attributes;\n\tefi_gcd_memory_type_t gcd_memory_type;\n\tvoid *image_handle;\n\tvoid *device_handle;\n} efi_gcd_memory_space_desc_t;\n\n \nunion efi_dxe_services_table {\n\tstruct {\n\t\tefi_table_hdr_t hdr;\n\t\tvoid *add_memory_space;\n\t\tvoid *allocate_memory_space;\n\t\tvoid *free_memory_space;\n\t\tvoid *remove_memory_space;\n\t\tefi_status_t (__efiapi *get_memory_space_descriptor)(efi_physical_addr_t,\n\t\t\t\t\t\t\t\t     efi_gcd_memory_space_desc_t *);\n\t\tefi_status_t (__efiapi *set_memory_space_attributes)(efi_physical_addr_t,\n\t\t\t\t\t\t\t\t     u64, u64);\n\t\tvoid *get_memory_space_map;\n\t\tvoid *add_io_space;\n\t\tvoid *allocate_io_space;\n\t\tvoid *free_io_space;\n\t\tvoid *remove_io_space;\n\t\tvoid *get_io_space_descriptor;\n\t\tvoid *get_io_space_map;\n\t\tvoid *dispatch;\n\t\tvoid *schedule;\n\t\tvoid *trust;\n\t\tvoid *process_firmware_volume;\n\t\tvoid *set_memory_space_capabilities;\n\t};\n\tstruct {\n\t\tefi_table_hdr_t hdr;\n\t\tu32 add_memory_space;\n\t\tu32 allocate_memory_space;\n\t\tu32 free_memory_space;\n\t\tu32 remove_memory_space;\n\t\tu32 get_memory_space_descriptor;\n\t\tu32 set_memory_space_attributes;\n\t\tu32 get_memory_space_map;\n\t\tu32 add_io_space;\n\t\tu32 allocate_io_space;\n\t\tu32 free_io_space;\n\t\tu32 remove_io_space;\n\t\tu32 get_io_space_descriptor;\n\t\tu32 get_io_space_map;\n\t\tu32 dispatch;\n\t\tu32 schedule;\n\t\tu32 trust;\n\t\tu32 process_firmware_volume;\n\t\tu32 set_memory_space_capabilities;\n\t} mixed_mode;\n};\n\ntypedef union efi_memory_attribute_protocol efi_memory_attribute_protocol_t;\n\nunion efi_memory_attribute_protocol {\n\tstruct {\n\t\tefi_status_t (__efiapi *get_memory_attributes)(\n\t\t\tefi_memory_attribute_protocol_t *, efi_physical_addr_t, u64, u64 *);\n\n\t\tefi_status_t (__efiapi *set_memory_attributes)(\n\t\t\tefi_memory_attribute_protocol_t *, efi_physical_addr_t, u64, u64);\n\n\t\tefi_status_t (__efiapi *clear_memory_attributes)(\n\t\t\tefi_memory_attribute_protocol_t *, efi_physical_addr_t, u64, u64);\n\t};\n\tstruct {\n\t\tu32 get_memory_attributes;\n\t\tu32 set_memory_attributes;\n\t\tu32 clear_memory_attributes;\n\t} mixed_mode;\n};\n\ntypedef union efi_uga_draw_protocol efi_uga_draw_protocol_t;\n\nunion efi_uga_draw_protocol {\n\tstruct {\n\t\tefi_status_t (__efiapi *get_mode)(efi_uga_draw_protocol_t *,\n\t\t\t\t\t\t  u32*, u32*, u32*, u32*);\n\t\tvoid *set_mode;\n\t\tvoid *blt;\n\t};\n\tstruct {\n\t\tu32 get_mode;\n\t\tu32 set_mode;\n\t\tu32 blt;\n\t} mixed_mode;\n};\n\ntypedef struct {\n\tu16 scan_code;\n\tefi_char16_t unicode_char;\n} efi_input_key_t;\n\nunion efi_simple_text_input_protocol {\n\tstruct {\n\t\tvoid *reset;\n\t\tefi_status_t (__efiapi *read_keystroke)(efi_simple_text_input_protocol_t *,\n\t\t\t\t\t\t\tefi_input_key_t *);\n\t\tefi_event_t wait_for_key;\n\t};\n\tstruct {\n\t\tu32 reset;\n\t\tu32 read_keystroke;\n\t\tu32 wait_for_key;\n\t} mixed_mode;\n};\n\nefi_status_t efi_wait_for_key(unsigned long usec, efi_input_key_t *key);\n\nunion efi_simple_text_output_protocol {\n\tstruct {\n\t\tvoid *reset;\n\t\tefi_status_t (__efiapi *output_string)(efi_simple_text_output_protocol_t *,\n\t\t\t\t\t\t       efi_char16_t *);\n\t\tvoid *test_string;\n\t};\n\tstruct {\n\t\tu32 reset;\n\t\tu32 output_string;\n\t\tu32 test_string;\n\t} mixed_mode;\n};\n\n#define PIXEL_RGB_RESERVED_8BIT_PER_COLOR\t\t0\n#define PIXEL_BGR_RESERVED_8BIT_PER_COLOR\t\t1\n#define PIXEL_BIT_MASK\t\t\t\t\t2\n#define PIXEL_BLT_ONLY\t\t\t\t\t3\n#define PIXEL_FORMAT_MAX\t\t\t\t4\n\ntypedef struct {\n\tu32 red_mask;\n\tu32 green_mask;\n\tu32 blue_mask;\n\tu32 reserved_mask;\n} efi_pixel_bitmask_t;\n\ntypedef struct {\n\tu32 version;\n\tu32 horizontal_resolution;\n\tu32 vertical_resolution;\n\tint pixel_format;\n\tefi_pixel_bitmask_t pixel_information;\n\tu32 pixels_per_scan_line;\n} efi_graphics_output_mode_info_t;\n\ntypedef union efi_graphics_output_protocol_mode efi_graphics_output_protocol_mode_t;\n\nunion efi_graphics_output_protocol_mode {\n\tstruct {\n\t\tu32 max_mode;\n\t\tu32 mode;\n\t\tefi_graphics_output_mode_info_t *info;\n\t\tunsigned long size_of_info;\n\t\tefi_physical_addr_t frame_buffer_base;\n\t\tunsigned long frame_buffer_size;\n\t};\n\tstruct {\n\t\tu32 max_mode;\n\t\tu32 mode;\n\t\tu32 info;\n\t\tu32 size_of_info;\n\t\tu64 frame_buffer_base;\n\t\tu32 frame_buffer_size;\n\t} mixed_mode;\n};\n\ntypedef union efi_graphics_output_protocol efi_graphics_output_protocol_t;\n\nunion efi_graphics_output_protocol {\n\tstruct {\n\t\tefi_status_t (__efiapi *query_mode)(efi_graphics_output_protocol_t *,\n\t\t\t\t\t\t    u32, unsigned long *,\n\t\t\t\t\t\t    efi_graphics_output_mode_info_t **);\n\t\tefi_status_t (__efiapi *set_mode)  (efi_graphics_output_protocol_t *, u32);\n\t\tvoid *blt;\n\t\tefi_graphics_output_protocol_mode_t *mode;\n\t};\n\tstruct {\n\t\tu32 query_mode;\n\t\tu32 set_mode;\n\t\tu32 blt;\n\t\tu32 mode;\n\t} mixed_mode;\n};\n\ntypedef union {\n\tstruct {\n\t\tu32\t\t\trevision;\n\t\tefi_handle_t\t\tparent_handle;\n\t\tefi_system_table_t\t*system_table;\n\t\tefi_handle_t\t\tdevice_handle;\n\t\tvoid\t\t\t*file_path;\n\t\tvoid\t\t\t*reserved;\n\t\tu32\t\t\tload_options_size;\n\t\tvoid\t\t\t*load_options;\n\t\tvoid\t\t\t*image_base;\n\t\t__aligned_u64\t\timage_size;\n\t\tunsigned int\t\timage_code_type;\n\t\tunsigned int\t\timage_data_type;\n\t\tefi_status_t\t\t(__efiapi *unload)(efi_handle_t image_handle);\n\t};\n\tstruct {\n\t\tu32\t\trevision;\n\t\tu32\t\tparent_handle;\n\t\tu32\t\tsystem_table;\n\t\tu32\t\tdevice_handle;\n\t\tu32\t\tfile_path;\n\t\tu32\t\treserved;\n\t\tu32\t\tload_options_size;\n\t\tu32\t\tload_options;\n\t\tu32\t\timage_base;\n\t\t__aligned_u64\timage_size;\n\t\tu32\t\timage_code_type;\n\t\tu32\t\timage_data_type;\n\t\tu32\t\tunload;\n\t} mixed_mode;\n} efi_loaded_image_t;\n\ntypedef struct {\n\tu64\t\t\tsize;\n\tu64\t\t\tfile_size;\n\tu64\t\t\tphys_size;\n\tefi_time_t\t\tcreate_time;\n\tefi_time_t\t\tlast_access_time;\n\tefi_time_t\t\tmodification_time;\n\t__aligned_u64\t\tattribute;\n\tefi_char16_t\t\tfilename[];\n} efi_file_info_t;\n\ntypedef union efi_file_protocol efi_file_protocol_t;\n\nunion efi_file_protocol {\n\tstruct {\n\t\tu64\t\trevision;\n\t\tefi_status_t\t(__efiapi *open)\t(efi_file_protocol_t *,\n\t\t\t\t\t\t\t efi_file_protocol_t **,\n\t\t\t\t\t\t\t efi_char16_t *, u64,\n\t\t\t\t\t\t\t u64);\n\t\tefi_status_t\t(__efiapi *close)\t(efi_file_protocol_t *);\n\t\tefi_status_t\t(__efiapi *delete)\t(efi_file_protocol_t *);\n\t\tefi_status_t\t(__efiapi *read)\t(efi_file_protocol_t *,\n\t\t\t\t\t\t\t unsigned long *,\n\t\t\t\t\t\t\t void *);\n\t\tefi_status_t\t(__efiapi *write)\t(efi_file_protocol_t *,\n\t\t\t\t\t\t\t unsigned long, void *);\n\t\tefi_status_t\t(__efiapi *get_position)(efi_file_protocol_t *,\n\t\t\t\t\t\t\t u64 *);\n\t\tefi_status_t\t(__efiapi *set_position)(efi_file_protocol_t *,\n\t\t\t\t\t\t\t u64);\n\t\tefi_status_t\t(__efiapi *get_info)\t(efi_file_protocol_t *,\n\t\t\t\t\t\t\t efi_guid_t *,\n\t\t\t\t\t\t\t unsigned long *,\n\t\t\t\t\t\t\t void *);\n\t\tefi_status_t\t(__efiapi *set_info)\t(efi_file_protocol_t *,\n\t\t\t\t\t\t\t efi_guid_t *,\n\t\t\t\t\t\t\t unsigned long,\n\t\t\t\t\t\t\t void *);\n\t\tefi_status_t\t(__efiapi *flush)\t(efi_file_protocol_t *);\n\t};\n\tstruct {\n\t\tu64 revision;\n\t\tu32 open;\n\t\tu32 close;\n\t\tu32 delete;\n\t\tu32 read;\n\t\tu32 write;\n\t\tu32 get_position;\n\t\tu32 set_position;\n\t\tu32 get_info;\n\t\tu32 set_info;\n\t\tu32 flush;\n\t} mixed_mode;\n};\n\ntypedef union efi_simple_file_system_protocol efi_simple_file_system_protocol_t;\n\nunion efi_simple_file_system_protocol {\n\tstruct {\n\t\tu64\t\trevision;\n\t\tefi_status_t\t(__efiapi *open_volume)(efi_simple_file_system_protocol_t *,\n\t\t\t\t\t\t\tefi_file_protocol_t **);\n\t};\n\tstruct {\n\t\tu64 revision;\n\t\tu32 open_volume;\n\t} mixed_mode;\n};\n\n#define EFI_FILE_MODE_READ\t0x0000000000000001\n#define EFI_FILE_MODE_WRITE\t0x0000000000000002\n#define EFI_FILE_MODE_CREATE\t0x8000000000000000\n\ntypedef enum {\n\tEfiPciIoWidthUint8,\n\tEfiPciIoWidthUint16,\n\tEfiPciIoWidthUint32,\n\tEfiPciIoWidthUint64,\n\tEfiPciIoWidthFifoUint8,\n\tEfiPciIoWidthFifoUint16,\n\tEfiPciIoWidthFifoUint32,\n\tEfiPciIoWidthFifoUint64,\n\tEfiPciIoWidthFillUint8,\n\tEfiPciIoWidthFillUint16,\n\tEfiPciIoWidthFillUint32,\n\tEfiPciIoWidthFillUint64,\n\tEfiPciIoWidthMaximum\n} EFI_PCI_IO_PROTOCOL_WIDTH;\n\ntypedef enum {\n\tEfiPciIoAttributeOperationGet,\n\tEfiPciIoAttributeOperationSet,\n\tEfiPciIoAttributeOperationEnable,\n\tEfiPciIoAttributeOperationDisable,\n\tEfiPciIoAttributeOperationSupported,\n    EfiPciIoAttributeOperationMaximum\n} EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION;\n\ntypedef struct {\n\tu32 read;\n\tu32 write;\n} efi_pci_io_protocol_access_32_t;\n\ntypedef union efi_pci_io_protocol efi_pci_io_protocol_t;\n\ntypedef\nefi_status_t (__efiapi *efi_pci_io_protocol_cfg_t)(efi_pci_io_protocol_t *,\n\t\t\t\t\t\t   EFI_PCI_IO_PROTOCOL_WIDTH,\n\t\t\t\t\t\t   u32 offset,\n\t\t\t\t\t\t   unsigned long count,\n\t\t\t\t\t\t   void *buffer);\n\ntypedef struct {\n\tvoid *read;\n\tvoid *write;\n} efi_pci_io_protocol_access_t;\n\ntypedef struct {\n\tefi_pci_io_protocol_cfg_t read;\n\tefi_pci_io_protocol_cfg_t write;\n} efi_pci_io_protocol_config_access_t;\n\nunion efi_pci_io_protocol {\n\tstruct {\n\t\tvoid *poll_mem;\n\t\tvoid *poll_io;\n\t\tefi_pci_io_protocol_access_t mem;\n\t\tefi_pci_io_protocol_access_t io;\n\t\tefi_pci_io_protocol_config_access_t pci;\n\t\tvoid *copy_mem;\n\t\tvoid *map;\n\t\tvoid *unmap;\n\t\tvoid *allocate_buffer;\n\t\tvoid *free_buffer;\n\t\tvoid *flush;\n\t\tefi_status_t (__efiapi *get_location)(efi_pci_io_protocol_t *,\n\t\t\t\t\t\t      unsigned long *segment_nr,\n\t\t\t\t\t\t      unsigned long *bus_nr,\n\t\t\t\t\t\t      unsigned long *device_nr,\n\t\t\t\t\t\t      unsigned long *func_nr);\n\t\tvoid *attributes;\n\t\tvoid *get_bar_attributes;\n\t\tvoid *set_bar_attributes;\n\t\tuint64_t romsize;\n\t\tvoid *romimage;\n\t};\n\tstruct {\n\t\tu32 poll_mem;\n\t\tu32 poll_io;\n\t\tefi_pci_io_protocol_access_32_t mem;\n\t\tefi_pci_io_protocol_access_32_t io;\n\t\tefi_pci_io_protocol_access_32_t pci;\n\t\tu32 copy_mem;\n\t\tu32 map;\n\t\tu32 unmap;\n\t\tu32 allocate_buffer;\n\t\tu32 free_buffer;\n\t\tu32 flush;\n\t\tu32 get_location;\n\t\tu32 attributes;\n\t\tu32 get_bar_attributes;\n\t\tu32 set_bar_attributes;\n\t\tu64 romsize;\n\t\tu32 romimage;\n\t} mixed_mode;\n};\n\n#define EFI_PCI_IO_ATTRIBUTE_ISA_MOTHERBOARD_IO 0x0001\n#define EFI_PCI_IO_ATTRIBUTE_ISA_IO 0x0002\n#define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO 0x0004\n#define EFI_PCI_IO_ATTRIBUTE_VGA_MEMORY 0x0008\n#define EFI_PCI_IO_ATTRIBUTE_VGA_IO 0x0010\n#define EFI_PCI_IO_ATTRIBUTE_IDE_PRIMARY_IO 0x0020\n#define EFI_PCI_IO_ATTRIBUTE_IDE_SECONDARY_IO 0x0040\n#define EFI_PCI_IO_ATTRIBUTE_MEMORY_WRITE_COMBINE 0x0080\n#define EFI_PCI_IO_ATTRIBUTE_IO 0x0100\n#define EFI_PCI_IO_ATTRIBUTE_MEMORY 0x0200\n#define EFI_PCI_IO_ATTRIBUTE_BUS_MASTER 0x0400\n#define EFI_PCI_IO_ATTRIBUTE_MEMORY_CACHED 0x0800\n#define EFI_PCI_IO_ATTRIBUTE_MEMORY_DISABLE 0x1000\n#define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_DEVICE 0x2000\n#define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_ROM 0x4000\n#define EFI_PCI_IO_ATTRIBUTE_DUAL_ADDRESS_CYCLE 0x8000\n#define EFI_PCI_IO_ATTRIBUTE_ISA_IO_16 0x10000\n#define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO_16 0x20000\n#define EFI_PCI_IO_ATTRIBUTE_VGA_IO_16 0x40000\n\nstruct efi_dev_path;\n\ntypedef union apple_properties_protocol apple_properties_protocol_t;\n\nunion apple_properties_protocol {\n\tstruct {\n\t\tunsigned long version;\n\t\tefi_status_t (__efiapi *get)(apple_properties_protocol_t *,\n\t\t\t\t\t     struct efi_dev_path *,\n\t\t\t\t\t     efi_char16_t *, void *, u32 *);\n\t\tefi_status_t (__efiapi *set)(apple_properties_protocol_t *,\n\t\t\t\t\t     struct efi_dev_path *,\n\t\t\t\t\t     efi_char16_t *, void *, u32);\n\t\tefi_status_t (__efiapi *del)(apple_properties_protocol_t *,\n\t\t\t\t\t     struct efi_dev_path *,\n\t\t\t\t\t     efi_char16_t *);\n\t\tefi_status_t (__efiapi *get_all)(apple_properties_protocol_t *,\n\t\t\t\t\t\t void *buffer, u32 *);\n\t};\n\tstruct {\n\t\tu32 version;\n\t\tu32 get;\n\t\tu32 set;\n\t\tu32 del;\n\t\tu32 get_all;\n\t} mixed_mode;\n};\n\ntypedef u32 efi_tcg2_event_log_format;\n\n#define INITRD_EVENT_TAG_ID 0x8F3B22ECU\n#define LOAD_OPTIONS_EVENT_TAG_ID 0x8F3B22EDU\n#define EV_EVENT_TAG 0x00000006U\n#define EFI_TCG2_EVENT_HEADER_VERSION\t0x1\n\nstruct efi_tcg2_event {\n\tu32\t\tevent_size;\n\tstruct {\n\t\tu32\theader_size;\n\t\tu16\theader_version;\n\t\tu32\tpcr_index;\n\t\tu32\tevent_type;\n\t} __packed event_header;\n\t \n} __packed;\n\nstruct efi_tcg2_tagged_event {\n\tu32 tagged_event_id;\n\tu32 tagged_event_data_size;\n\t \n} __packed;\n\ntypedef struct efi_tcg2_event efi_tcg2_event_t;\ntypedef struct efi_tcg2_tagged_event efi_tcg2_tagged_event_t;\ntypedef union efi_tcg2_protocol efi_tcg2_protocol_t;\n\nunion efi_tcg2_protocol {\n\tstruct {\n\t\tvoid *get_capability;\n\t\tefi_status_t (__efiapi *get_event_log)(efi_tcg2_protocol_t *,\n\t\t\t\t\t\t       efi_tcg2_event_log_format,\n\t\t\t\t\t\t       efi_physical_addr_t *,\n\t\t\t\t\t\t       efi_physical_addr_t *,\n\t\t\t\t\t\t       efi_bool_t *);\n\t\tefi_status_t (__efiapi *hash_log_extend_event)(efi_tcg2_protocol_t *,\n\t\t\t\t\t\t\t       u64,\n\t\t\t\t\t\t\t       efi_physical_addr_t,\n\t\t\t\t\t\t\t       u64,\n\t\t\t\t\t\t\t       const efi_tcg2_event_t *);\n\t\tvoid *submit_command;\n\t\tvoid *get_active_pcr_banks;\n\t\tvoid *set_active_pcr_banks;\n\t\tvoid *get_result_of_set_active_pcr_banks;\n\t};\n\tstruct {\n\t\tu32 get_capability;\n\t\tu32 get_event_log;\n\t\tu32 hash_log_extend_event;\n\t\tu32 submit_command;\n\t\tu32 get_active_pcr_banks;\n\t\tu32 set_active_pcr_banks;\n\t\tu32 get_result_of_set_active_pcr_banks;\n\t} mixed_mode;\n};\n\nstruct riscv_efi_boot_protocol {\n\tu64 revision;\n\n\tefi_status_t (__efiapi *get_boot_hartid)(struct riscv_efi_boot_protocol *,\n\t\t\t\t\t\t unsigned long *boot_hartid);\n};\n\ntypedef union efi_load_file_protocol efi_load_file_protocol_t;\ntypedef union efi_load_file_protocol efi_load_file2_protocol_t;\n\nunion efi_load_file_protocol {\n\tstruct {\n\t\tefi_status_t (__efiapi *load_file)(efi_load_file_protocol_t *,\n\t\t\t\t\t\t   efi_device_path_protocol_t *,\n\t\t\t\t\t\t   bool, unsigned long *, void *);\n\t};\n\tstruct {\n\t\tu32 load_file;\n\t} mixed_mode;\n};\n\ntypedef struct {\n\tu32 attributes;\n\tu16 file_path_list_length;\n\tu8 variable_data[];\n\t\n\t\n\t\n} __packed efi_load_option_t;\n\n#define EFI_LOAD_OPTION_ACTIVE\t\t0x0001U\n#define EFI_LOAD_OPTION_FORCE_RECONNECT\t0x0002U\n#define EFI_LOAD_OPTION_HIDDEN\t\t0x0008U\n#define EFI_LOAD_OPTION_CATEGORY\t0x1f00U\n#define   EFI_LOAD_OPTION_CATEGORY_BOOT\t0x0000U\n#define   EFI_LOAD_OPTION_CATEGORY_APP\t0x0100U\n\n#define EFI_LOAD_OPTION_BOOT_MASK \\\n\t(EFI_LOAD_OPTION_ACTIVE|EFI_LOAD_OPTION_HIDDEN|EFI_LOAD_OPTION_CATEGORY)\n#define EFI_LOAD_OPTION_MASK (EFI_LOAD_OPTION_FORCE_RECONNECT|EFI_LOAD_OPTION_BOOT_MASK)\n\ntypedef struct {\n\tu32 attributes;\n\tu16 file_path_list_length;\n\tconst efi_char16_t *description;\n\tconst efi_device_path_protocol_t *file_path_list;\n\tu32 optional_data_size;\n\tconst void *optional_data;\n} efi_load_option_unpacked_t;\n\nvoid efi_pci_disable_bridge_busmaster(void);\n\ntypedef efi_status_t (*efi_exit_boot_map_processing)(\n\tstruct efi_boot_memmap *map,\n\tvoid *priv);\n\nefi_status_t efi_exit_boot_services(void *handle, void *priv,\n\t\t\t\t    efi_exit_boot_map_processing priv_func);\n\nefi_status_t efi_boot_kernel(void *handle, efi_loaded_image_t *image,\n\t\t\t     unsigned long kernel_addr, char *cmdline_ptr);\n\nvoid *get_fdt(unsigned long *fdt_size);\n\nefi_status_t efi_alloc_virtmap(efi_memory_desc_t **virtmap,\n\t\t\t       unsigned long *desc_size, u32 *desc_ver);\nvoid efi_get_virtmap(efi_memory_desc_t *memory_map, unsigned long map_size,\n\t\t     unsigned long desc_size, efi_memory_desc_t *runtime_map,\n\t\t     int *count);\n\nefi_status_t efi_get_random_bytes(unsigned long size, u8 *out);\n\nefi_status_t efi_random_alloc(unsigned long size, unsigned long align,\n\t\t\t      unsigned long *addr, unsigned long random_seed,\n\t\t\t      int memory_type, unsigned long alloc_limit);\n\nefi_status_t efi_random_get_seed(void);\n\nefi_status_t check_platform_features(void);\n\nvoid *get_efi_config_table(efi_guid_t guid);\n\n \nvoid efi_char16_puts(efi_char16_t *);\nvoid efi_puts(const char *str);\n\n__printf(1, 2) int efi_printk(char const *fmt, ...);\n\nvoid efi_free(unsigned long size, unsigned long addr);\n\nvoid efi_apply_loadoptions_quirk(const void **load_options, u32 *load_options_size);\n\nchar *efi_convert_cmdline(efi_loaded_image_t *image, int *cmd_line_len);\n\nefi_status_t efi_get_memory_map(struct efi_boot_memmap **map,\n\t\t\t\tbool install_cfg_tbl);\n\nefi_status_t efi_allocate_pages(unsigned long size, unsigned long *addr,\n\t\t\t\tunsigned long max);\n\nefi_status_t efi_allocate_pages_aligned(unsigned long size, unsigned long *addr,\n\t\t\t\t\tunsigned long max, unsigned long align,\n\t\t\t\t\tint memory_type);\n\nefi_status_t efi_low_alloc_above(unsigned long size, unsigned long align,\n\t\t\t\t unsigned long *addr, unsigned long min);\n\nefi_status_t efi_relocate_kernel(unsigned long *image_addr,\n\t\t\t\t unsigned long image_size,\n\t\t\t\t unsigned long alloc_size,\n\t\t\t\t unsigned long preferred_addr,\n\t\t\t\t unsigned long alignment,\n\t\t\t\t unsigned long min_addr);\n\nefi_status_t efi_parse_options(char const *cmdline);\n\nvoid efi_parse_option_graphics(char *option);\n\nefi_status_t efi_setup_gop(struct screen_info *si, efi_guid_t *proto,\n\t\t\t   unsigned long size);\n\nefi_status_t handle_cmdline_files(efi_loaded_image_t *image,\n\t\t\t\t  const efi_char16_t *optstr,\n\t\t\t\t  int optstr_size,\n\t\t\t\t  unsigned long soft_limit,\n\t\t\t\t  unsigned long hard_limit,\n\t\t\t\t  unsigned long *load_addr,\n\t\t\t\t  unsigned long *load_size);\n\n\nstatic inline efi_status_t efi_load_dtb(efi_loaded_image_t *image,\n\t\t\t\t\tunsigned long *load_addr,\n\t\t\t\t\tunsigned long *load_size)\n{\n\treturn handle_cmdline_files(image, L\"dtb=\", sizeof(L\"dtb=\") - 2,\n\t\t\t\t    ULONG_MAX, ULONG_MAX, load_addr, load_size);\n}\n\nefi_status_t efi_load_initrd(efi_loaded_image_t *image,\n\t\t\t     unsigned long soft_limit,\n\t\t\t     unsigned long hard_limit,\n\t\t\t     const struct linux_efi_initrd **out);\n \nefi_status_t handle_kernel_image(unsigned long *image_addr,\n\t\t\t\t unsigned long *image_size,\n\t\t\t\t unsigned long *reserve_addr,\n\t\t\t\t unsigned long *reserve_size,\n\t\t\t\t efi_loaded_image_t *image,\n\t\t\t\t efi_handle_t image_handle);\n\n \nefi_status_t efi_stub_common(efi_handle_t handle,\n\t\t\t     efi_loaded_image_t *image,\n\t\t\t     unsigned long image_addr,\n\t\t\t     char *cmdline_ptr);\n\nefi_status_t efi_handle_cmdline(efi_loaded_image_t *image, char **cmdline_ptr);\n\nasmlinkage void __noreturn efi_enter_kernel(unsigned long entrypoint,\n\t\t\t\t\t    unsigned long fdt_addr,\n\t\t\t\t\t    unsigned long fdt_size);\n\nvoid efi_handle_post_ebs_state(void);\n\nenum efi_secureboot_mode efi_get_secureboot(void);\n\n#ifdef CONFIG_RESET_ATTACK_MITIGATION\nvoid efi_enable_reset_attack_mitigation(void);\n#else\nstatic inline void\nefi_enable_reset_attack_mitigation(void) { }\n#endif\n\nvoid efi_retrieve_tpm2_eventlog(void);\n\nstruct screen_info *alloc_screen_info(void);\nstruct screen_info *__alloc_screen_info(void);\nvoid free_screen_info(struct screen_info *si);\n\nvoid efi_cache_sync_image(unsigned long image_base,\n\t\t\t  unsigned long alloc_size);\n\nstruct efi_smbios_record {\n\tu8\ttype;\n\tu8\tlength;\n\tu16\thandle;\n};\n\nconst struct efi_smbios_record *efi_get_smbios_record(u8 type);\n\nstruct efi_smbios_type1_record {\n\tstruct efi_smbios_record\theader;\n\n\tu8\t\t\t\tmanufacturer;\n\tu8\t\t\t\tproduct_name;\n\tu8\t\t\t\tversion;\n\tu8\t\t\t\tserial_number;\n\tefi_guid_t\t\t\tuuid;\n\tu8\t\t\t\twakeup_type;\n\tu8\t\t\t\tsku_number;\n\tu8\t\t\t\tfamily;\n};\n\nstruct efi_smbios_type4_record {\n\tstruct efi_smbios_record\theader;\n\n\tu8\t\t\t\tsocket;\n\tu8\t\t\t\tprocessor_type;\n\tu8\t\t\t\tprocessor_family;\n\tu8\t\t\t\tprocessor_manufacturer;\n\tu8\t\t\t\tprocessor_id[8];\n\tu8\t\t\t\tprocessor_version;\n\tu8\t\t\t\tvoltage;\n\tu16\t\t\t\texternal_clock;\n\tu16\t\t\t\tmax_speed;\n\tu16\t\t\t\tcurrent_speed;\n\tu8\t\t\t\tstatus;\n\tu8\t\t\t\tprocessor_upgrade;\n\tu16\t\t\t\tl1_cache_handle;\n\tu16\t\t\t\tl2_cache_handle;\n\tu16\t\t\t\tl3_cache_handle;\n\tu8\t\t\t\tserial_number;\n\tu8\t\t\t\tasset_tag;\n\tu8\t\t\t\tpart_number;\n\tu8\t\t\t\tcore_count;\n\tu8\t\t\t\tenabled_core_count;\n\tu8\t\t\t\tthread_count;\n\tu16\t\t\t\tprocessor_characteristics;\n\tu16\t\t\t\tprocessor_family2;\n\tu16\t\t\t\tcore_count2;\n\tu16\t\t\t\tenabled_core_count2;\n\tu16\t\t\t\tthread_count2;\n\tu16\t\t\t\tthread_enabled;\n};\n\n#define efi_get_smbios_string(__record, __type, __name) ({\t\t\\\n\tint off = offsetof(struct efi_smbios_type ## __type ## _record,\t\\\n\t\t\t   __name);\t\t\t\t\t\\\n\t__efi_get_smbios_string((__record), __type, off);\t\t\\\n})\n\nconst u8 *__efi_get_smbios_string(const struct efi_smbios_record *record,\n\t\t\t\t  u8 type, int offset);\n\nvoid efi_remap_image(unsigned long image_base, unsigned alloc_size,\n\t\t     unsigned long code_size);\nefi_status_t efi_kaslr_relocate_kernel(unsigned long *image_addr,\n\t\t\t\t       unsigned long *reserve_addr,\n\t\t\t\t       unsigned long *reserve_size,\n\t\t\t\t       unsigned long kernel_size,\n\t\t\t\t       unsigned long kernel_codesize,\n\t\t\t\t       unsigned long kernel_memsize,\n\t\t\t\t       u32 phys_seed);\nu32 efi_kaslr_get_phys_seed(efi_handle_t image_handle);\n\nasmlinkage efi_status_t __efiapi\nefi_zboot_entry(efi_handle_t handle, efi_system_table_t *systab);\n\nefi_status_t allocate_unaccepted_bitmap(__u32 nr_desc,\n\t\t\t\t\tstruct efi_boot_memmap *map);\nvoid process_unaccepted_memory(u64 start, u64 end);\nvoid accept_memory(phys_addr_t start, phys_addr_t end);\nvoid arch_accept_memory(phys_addr_t start, phys_addr_t end);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}