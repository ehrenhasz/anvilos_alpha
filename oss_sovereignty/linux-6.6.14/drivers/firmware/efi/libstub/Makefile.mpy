{
  "module_name": "Makefile",
  "hash_id": "528670a632e3de2358ce08c531785460b5926df3148b410fc7cff5c28fe88d9f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/libstub/Makefile",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n#\n# The stub may be linked into the kernel proper or into a separate boot binary,\n# but in either case, it executes before the kernel does (with MMU disabled) so\n# things like ftrace and stack-protector are likely to cause trouble if left\n# enabled, even if doing so doesn't break the build.\n#\n\n# non-x86 reuses KBUILD_CFLAGS, x86 does not\ncflags-y\t\t\t:= $(KBUILD_CFLAGS)\n\ncflags-$(CONFIG_X86_32)\t\t:= -march=i386\ncflags-$(CONFIG_X86_64)\t\t:= -mcmodel=small\ncflags-$(CONFIG_X86)\t\t+= -m$(BITS) -D__KERNEL__ \\\n\t\t\t\t   -fPIC -fno-strict-aliasing -mno-red-zone \\\n\t\t\t\t   -mno-mmx -mno-sse -fshort-wchar \\\n\t\t\t\t   -Wno-pointer-sign \\\n\t\t\t\t   $(call cc-disable-warning, address-of-packed-member) \\\n\t\t\t\t   $(call cc-disable-warning, gnu) \\\n\t\t\t\t   -fno-asynchronous-unwind-tables \\\n\t\t\t\t   $(CLANG_FLAGS)\n\n# arm64 uses the full KBUILD_CFLAGS so it's necessary to explicitly\n# disable the stackleak plugin\ncflags-$(CONFIG_ARM64)\t\t+= -fpie $(DISABLE_STACKLEAK_PLUGIN) \\\n\t\t\t\t   -fno-unwind-tables -fno-asynchronous-unwind-tables\ncflags-$(CONFIG_ARM)\t\t+= -DEFI_HAVE_STRLEN -DEFI_HAVE_STRNLEN \\\n\t\t\t\t   -DEFI_HAVE_MEMCHR -DEFI_HAVE_STRRCHR \\\n\t\t\t\t   -DEFI_HAVE_STRCMP -fno-builtin -fpic \\\n\t\t\t\t   $(call cc-option,-mno-single-pic-base)\ncflags-$(CONFIG_RISCV)\t\t+= -fpic\ncflags-$(CONFIG_LOONGARCH)\t+= -fpie\n\ncflags-$(CONFIG_EFI_PARAMS_FROM_FDT)\t+= -I$(srctree)/scripts/dtc/libfdt\n\nKBUILD_CFLAGS\t\t\t:= $(subst $(CC_FLAGS_FTRACE),,$(cflags-y)) \\\n\t\t\t\t   -Os -DDISABLE_BRANCH_PROFILING \\\n\t\t\t\t   -include $(srctree)/include/linux/hidden.h \\\n\t\t\t\t   -D__NO_FORTIFY \\\n\t\t\t\t   -ffreestanding \\\n\t\t\t\t   -fno-stack-protector \\\n\t\t\t\t   $(call cc-option,-fno-addrsig) \\\n\t\t\t\t   -D__DISABLE_EXPORTS\n\n#\n# struct randomization only makes sense for Linux internal types, which the EFI\n# stub code never touches, so let's turn off struct randomization for the stub\n# altogether\n#\nKBUILD_CFLAGS := $(filter-out $(RANDSTRUCT_CFLAGS), $(KBUILD_CFLAGS))\n\n# remove SCS flags from all objects in this directory\nKBUILD_CFLAGS := $(filter-out $(CC_FLAGS_SCS), $(KBUILD_CFLAGS))\n# disable CFI\nKBUILD_CFLAGS := $(filter-out $(CC_FLAGS_CFI), $(KBUILD_CFLAGS))\n# disable LTO\nKBUILD_CFLAGS := $(filter-out $(CC_FLAGS_LTO), $(KBUILD_CFLAGS))\n\nGCOV_PROFILE\t\t\t:= n\n# Sanitizer runtimes are unavailable and cannot be linked here.\nKASAN_SANITIZE\t\t\t:= n\nKCSAN_SANITIZE\t\t\t:= n\nKMSAN_SANITIZE\t\t\t:= n\nUBSAN_SANITIZE\t\t\t:= n\nOBJECT_FILES_NON_STANDARD\t:= y\n\n# Prevents link failures: __sanitizer_cov_trace_pc() is not linked in.\nKCOV_INSTRUMENT\t\t\t:= n\n\nlib-y\t\t\t\t:= efi-stub-helper.o gop.o secureboot.o tpm.o \\\n\t\t\t\t   file.o mem.o random.o randomalloc.o pci.o \\\n\t\t\t\t   skip_spaces.o lib-cmdline.o lib-ctype.o \\\n\t\t\t\t   alignedmem.o relocate.o printk.o vsprintf.o\n\n# include the stub's libfdt dependencies from lib/ when needed\nlibfdt-deps\t\t\t:= fdt_rw.c fdt_ro.c fdt_wip.c fdt.c \\\n\t\t\t\t   fdt_empty_tree.c fdt_sw.c\n\nlib-$(CONFIG_EFI_PARAMS_FROM_FDT) += fdt.o \\\n\t\t\t\t     $(patsubst %.c,lib-%.o,$(libfdt-deps))\n\n$(obj)/lib-%.o: $(srctree)/lib/%.c FORCE\n\t$(call if_changed_rule,cc_o_c)\n\nlib-$(CONFIG_EFI_GENERIC_STUB)\t+= efi-stub.o string.o intrinsics.o systable.o \\\n\t\t\t\t   screen_info.o efi-stub-entry.o\n\nlib-$(CONFIG_ARM)\t\t+= arm32-stub.o\nlib-$(CONFIG_ARM64)\t\t+= kaslr.o arm64.o arm64-stub.o smbios.o\nlib-$(CONFIG_X86)\t\t+= x86-stub.o\nlib-$(CONFIG_X86_64)\t\t+= x86-5lvl.o\nlib-$(CONFIG_RISCV)\t\t+= kaslr.o riscv.o riscv-stub.o\nlib-$(CONFIG_LOONGARCH)\t\t+= loongarch.o loongarch-stub.o\n\nCFLAGS_arm32-stub.o\t\t:= -DTEXT_OFFSET=$(TEXT_OFFSET)\n\nzboot-obj-$(CONFIG_RISCV)\t:= lib-clz_ctz.o lib-ashldi3.o\nlib-$(CONFIG_EFI_ZBOOT)\t\t+= zboot.o $(zboot-obj-y)\n\nlib-$(CONFIG_UNACCEPTED_MEMORY) += unaccepted_memory.o bitmap.o find.o\n\nextra-y\t\t\t\t:= $(lib-y)\nlib-y\t\t\t\t:= $(patsubst %.o,%.stub.o,$(lib-y))\n\n# Even when -mbranch-protection=none is set, Clang will generate a\n# .note.gnu.property for code-less object files (like lib/ctype.c),\n# so work around this by explicitly removing the unwanted section.\n# https://bugs.llvm.org/show_bug.cgi?id=46480\nSTUBCOPY_FLAGS-y\t\t+= --remove-section=.note.gnu.property\n\n#\n# For x86, bootloaders like systemd-boot or grub-efi do not zero-initialize the\n# .bss section, so the .bss section of the EFI stub needs to be included in the\n# .data section of the compressed kernel to ensure initialization. Rename the\n# .bss section here so it's easy to pick out in the linker script.\n#\nSTUBCOPY_FLAGS-$(CONFIG_X86)\t+= --rename-section .bss=.bss.efistub,load,alloc\nSTUBCOPY_RELOC-$(CONFIG_X86_32)\t:= R_386_32\nSTUBCOPY_RELOC-$(CONFIG_X86_64)\t:= R_X86_64_64\n\n#\n# ARM discards the .data section because it disallows r/w data in the\n# decompressor. So move our .data to .data.efistub and .bss to .bss.efistub,\n# which are preserved explicitly by the decompressor linker script.\n#\nSTUBCOPY_FLAGS-$(CONFIG_ARM)\t+= --rename-section .data=.data.efistub\t\\\n\t\t\t\t   --rename-section .bss=.bss.efistub,load,alloc\nSTUBCOPY_RELOC-$(CONFIG_ARM)\t:= R_ARM_ABS\n\n#\n# arm64 puts the stub in the kernel proper, which will unnecessarily retain all\n# code indefinitely unless it is annotated as __init/__initdata/__initconst etc.\n# So let's apply the __init annotations at the section level, by prefixing\n# the section names directly. This will ensure that even all the inline string\n# literals are covered.\n# The fact that the stub and the kernel proper are essentially the same binary\n# also means that we need to be extra careful to make sure that the stub does\n# not rely on any absolute symbol references, considering that the virtual\n# kernel mapping that the linker uses is not active yet when the stub is\n# executing. So build all C dependencies of the EFI stub into libstub, and do\n# a verification pass to see if any absolute relocations exist in any of the\n# object files.\n#\nSTUBCOPY_FLAGS-$(CONFIG_ARM64)\t+= --prefix-alloc-sections=.init \\\n\t\t\t\t   --prefix-symbols=__efistub_\nSTUBCOPY_RELOC-$(CONFIG_ARM64)\t:= R_AARCH64_ABS\n\n# For RISC-V, we don't need anything special other than arm64. Keep all the\n# symbols in .init section and make sure that no absolute symbols references\n# exist.\nSTUBCOPY_FLAGS-$(CONFIG_RISCV)\t+= --prefix-alloc-sections=.init \\\n\t\t\t\t   --prefix-symbols=__efistub_\nSTUBCOPY_RELOC-$(CONFIG_RISCV)\t:= R_RISCV_HI20\n\n# For LoongArch, keep all the symbols in .init section and make sure that no\n# absolute symbols references exist.\nSTUBCOPY_FLAGS-$(CONFIG_LOONGARCH)\t+= --prefix-alloc-sections=.init \\\n\t\t\t\t\t   --prefix-symbols=__efistub_\nSTUBCOPY_RELOC-$(CONFIG_LOONGARCH)\t:= R_LARCH_MARK_LA\n\n$(obj)/%.stub.o: $(obj)/%.o FORCE\n\t$(call if_changed,stubcopy)\n\n#\n# Strip debug sections and some other sections that may legally contain\n# absolute relocations, so that we can inspect the remaining sections for\n# such relocations. If none are found, regenerate the output object, but\n# this time, use objcopy and leave all sections in place.\n#\nquiet_cmd_stubcopy = STUBCPY $@\n      cmd_stubcopy =\t\t\t\t\t\t\t\\\n\t$(STRIP) --strip-debug -o $@ $<;\t\t\t\t\\\n\tif $(OBJDUMP) -r $@ | grep $(STUBCOPY_RELOC-y); then\t\t\\\n\t\techo \"$@: absolute symbol references not allowed in the EFI stub\" >&2; \\\n\t\t/bin/false;\t\t\t\t\t\t\\\n\tfi;\t\t\t\t\t\t\t\t\\\n\t$(OBJCOPY) $(STUBCOPY_FLAGS-y) $< $@\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}