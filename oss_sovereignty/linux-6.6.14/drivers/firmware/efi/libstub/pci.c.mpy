{
  "module_name": "pci.c",
  "hash_id": "8e628dd63ea421f7c7f063cd2ea1d50dd8cc11867249a11d47090955ed4ac7ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/libstub/pci.c",
  "human_readable_source": "\n \n\n#include <linux/efi.h>\n#include <linux/pci.h>\n\n#include <asm/efi.h>\n\n#include \"efistub.h\"\n\nvoid efi_pci_disable_bridge_busmaster(void)\n{\n\tefi_guid_t pci_proto = EFI_PCI_IO_PROTOCOL_GUID;\n\tunsigned long pci_handle_size = 0;\n\tefi_handle_t *pci_handle = NULL;\n\tefi_handle_t handle;\n\tefi_status_t status;\n\tu16 class, command;\n\tint i;\n\n\tstatus = efi_bs_call(locate_handle, EFI_LOCATE_BY_PROTOCOL, &pci_proto,\n\t\t\t     NULL, &pci_handle_size, NULL);\n\n\tif (status != EFI_BUFFER_TOO_SMALL) {\n\t\tif (status != EFI_SUCCESS && status != EFI_NOT_FOUND)\n\t\t\tefi_err(\"Failed to locate PCI I/O handles'\\n\");\n\t\treturn;\n\t}\n\n\tstatus = efi_bs_call(allocate_pool, EFI_LOADER_DATA, pci_handle_size,\n\t\t\t     (void **)&pci_handle);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"Failed to allocate memory for 'pci_handle'\\n\");\n\t\treturn;\n\t}\n\n\tstatus = efi_bs_call(locate_handle, EFI_LOCATE_BY_PROTOCOL, &pci_proto,\n\t\t\t     NULL, &pci_handle_size, pci_handle);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_err(\"Failed to locate PCI I/O handles'\\n\");\n\t\tgoto free_handle;\n\t}\n\n\tfor_each_efi_handle(handle, pci_handle, pci_handle_size, i) {\n\t\tefi_pci_io_protocol_t *pci;\n\t\tunsigned long segment_nr, bus_nr, device_nr, func_nr;\n\n\t\tstatus = efi_bs_call(handle_protocol, handle, &pci_proto,\n\t\t\t\t     (void **)&pci);\n\t\tif (status != EFI_SUCCESS)\n\t\t\tcontinue;\n\n\t\t \n\t\tstatus = efi_call_proto(pci, get_location, &segment_nr, &bus_nr,\n\t\t\t\t\t&device_nr, &func_nr);\n\t\tif (status != EFI_SUCCESS || bus_nr == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tstatus = efi_call_proto(pci, pci.read, EfiPciIoWidthUint16,\n\t\t\t\t\tPCI_CLASS_DEVICE, 1, &class);\n\t\tif (status != EFI_SUCCESS || class == PCI_CLASS_DISPLAY_VGA)\n\t\t\tcontinue;\n\n\t\t \n\t\tefi_bs_call(disconnect_controller, handle, NULL, NULL);\n\t}\n\n\tfor_each_efi_handle(handle, pci_handle, pci_handle_size, i) {\n\t\tefi_pci_io_protocol_t *pci;\n\n\t\tstatus = efi_bs_call(handle_protocol, handle, &pci_proto,\n\t\t\t\t     (void **)&pci);\n\t\tif (status != EFI_SUCCESS || !pci)\n\t\t\tcontinue;\n\n\t\tstatus = efi_call_proto(pci, pci.read, EfiPciIoWidthUint16,\n\t\t\t\t\tPCI_CLASS_DEVICE, 1, &class);\n\n\t\tif (status != EFI_SUCCESS || class != PCI_CLASS_BRIDGE_PCI)\n\t\t\tcontinue;\n\n\t\t \n\t\tstatus = efi_call_proto(pci, pci.read, EfiPciIoWidthUint16,\n\t\t\t\t\tPCI_COMMAND, 1, &command);\n\t\tif (status != EFI_SUCCESS || !(command & PCI_COMMAND_MASTER))\n\t\t\tcontinue;\n\n\t\tcommand &= ~PCI_COMMAND_MASTER;\n\t\tstatus = efi_call_proto(pci, pci.write, EfiPciIoWidthUint16,\n\t\t\t\t\tPCI_COMMAND, 1, &command);\n\t\tif (status != EFI_SUCCESS)\n\t\t\tefi_err(\"Failed to disable PCI busmastering\\n\");\n\t}\n\nfree_handle:\n\tefi_bs_call(free_pool, pci_handle);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}