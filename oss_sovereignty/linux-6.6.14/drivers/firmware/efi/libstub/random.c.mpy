{
  "module_name": "random.c",
  "hash_id": "5ce4b47e7578faf5bc2927cb09a7cb39eae40d9e7ed73ffb12c0e1cc6b5102c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/libstub/random.c",
  "human_readable_source": "\n \n\n#include <linux/efi.h>\n#include <asm/efi.h>\n\n#include \"efistub.h\"\n\ntypedef union efi_rng_protocol efi_rng_protocol_t;\n\nunion efi_rng_protocol {\n\tstruct {\n\t\tefi_status_t (__efiapi *get_info)(efi_rng_protocol_t *,\n\t\t\t\t\t\t  unsigned long *,\n\t\t\t\t\t\t  efi_guid_t *);\n\t\tefi_status_t (__efiapi *get_rng)(efi_rng_protocol_t *,\n\t\t\t\t\t\t efi_guid_t *, unsigned long,\n\t\t\t\t\t\t u8 *out);\n\t};\n\tstruct {\n\t\tu32 get_info;\n\t\tu32 get_rng;\n\t} mixed_mode;\n};\n\n \nefi_status_t efi_get_random_bytes(unsigned long size, u8 *out)\n{\n\tefi_guid_t rng_proto = EFI_RNG_PROTOCOL_GUID;\n\tefi_status_t status;\n\tefi_rng_protocol_t *rng = NULL;\n\n\tstatus = efi_bs_call(locate_protocol, &rng_proto, NULL, (void **)&rng);\n\tif (status != EFI_SUCCESS)\n\t\treturn status;\n\n\treturn efi_call_proto(rng, get_rng, NULL, size, out);\n}\n\n \nefi_status_t efi_random_get_seed(void)\n{\n\tefi_guid_t rng_proto = EFI_RNG_PROTOCOL_GUID;\n\tefi_guid_t rng_algo_raw = EFI_RNG_ALGORITHM_RAW;\n\tefi_guid_t rng_table_guid = LINUX_EFI_RANDOM_SEED_TABLE_GUID;\n\tstruct linux_efi_random_seed *prev_seed, *seed = NULL;\n\tint prev_seed_size = 0, seed_size = EFI_RANDOM_SEED_SIZE;\n\tunsigned long nv_seed_size = 0, offset = 0;\n\tefi_rng_protocol_t *rng = NULL;\n\tefi_status_t status;\n\n\tstatus = efi_bs_call(locate_protocol, &rng_proto, NULL, (void **)&rng);\n\tif (status != EFI_SUCCESS)\n\t\tseed_size = 0;\n\n\t\n\tget_efi_var(L\"RandomSeed\", &rng_table_guid, NULL, &nv_seed_size, NULL);\n\tif (!seed_size && !nv_seed_size)\n\t\treturn status;\n\n\tseed_size += nv_seed_size;\n\n\t \n\tprev_seed = get_efi_config_table(rng_table_guid);\n\tif (prev_seed && prev_seed->size <= 512U) {\n\t\tprev_seed_size = prev_seed->size;\n\t\tseed_size += prev_seed_size;\n\t}\n\n\t \n\tstatus = efi_bs_call(allocate_pool, EFI_ACPI_RECLAIM_MEMORY,\n\t\t\t     struct_size(seed, bits, seed_size),\n\t\t\t     (void **)&seed);\n\tif (status != EFI_SUCCESS) {\n\t\tefi_warn(\"Failed to allocate memory for RNG seed.\\n\");\n\t\tgoto err_warn;\n\t}\n\n\tif (rng) {\n\t\tstatus = efi_call_proto(rng, get_rng, &rng_algo_raw,\n\t\t\t\t\tEFI_RANDOM_SEED_SIZE, seed->bits);\n\n\t\tif (status == EFI_UNSUPPORTED)\n\t\t\t \n\t\t\tstatus = efi_call_proto(rng, get_rng, NULL,\n\t\t\t\t\t\tEFI_RANDOM_SEED_SIZE, seed->bits);\n\n\t\tif (status == EFI_SUCCESS)\n\t\t\toffset = EFI_RANDOM_SEED_SIZE;\n\t}\n\n\tif (nv_seed_size) {\n\t\tstatus = get_efi_var(L\"RandomSeed\", &rng_table_guid, NULL,\n\t\t\t\t     &nv_seed_size, seed->bits + offset);\n\n\t\tif (status == EFI_SUCCESS)\n\t\t\t \n\t\t\tstatus = set_efi_var(L\"RandomSeed\", &rng_table_guid, 0,\n\t\t\t\t\t     0, NULL);\n\n\t\tif (status == EFI_SUCCESS)\n\t\t\toffset += nv_seed_size;\n\t\telse\n\t\t\tmemzero_explicit(seed->bits + offset, nv_seed_size);\n\t}\n\n\tif (!offset)\n\t\tgoto err_freepool;\n\n\tif (prev_seed_size) {\n\t\tmemcpy(seed->bits + offset, prev_seed->bits, prev_seed_size);\n\t\toffset += prev_seed_size;\n\t}\n\n\tseed->size = offset;\n\tstatus = efi_bs_call(install_configuration_table, &rng_table_guid, seed);\n\tif (status != EFI_SUCCESS)\n\t\tgoto err_freepool;\n\n\tif (prev_seed_size) {\n\t\t \n\t\tmemzero_explicit(prev_seed->bits, prev_seed_size);\n\t\tefi_bs_call(free_pool, prev_seed);\n\t}\n\treturn EFI_SUCCESS;\n\nerr_freepool:\n\tmemzero_explicit(seed, struct_size(seed, bits, seed_size));\n\tefi_bs_call(free_pool, seed);\n\tefi_warn(\"Failed to obtain seed from EFI_RNG_PROTOCOL or EFI variable\\n\");\nerr_warn:\n\tif (prev_seed)\n\t\tefi_warn(\"Retaining bootloader-supplied seed only\");\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}