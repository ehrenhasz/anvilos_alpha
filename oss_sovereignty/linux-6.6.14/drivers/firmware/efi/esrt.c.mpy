{
  "module_name": "esrt.c",
  "hash_id": "36241dff9a83f193a1f8d979c9aa23a1d4aa4c65106448b74ce38c163c901262",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/esrt.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"esrt: \" fmt\n\n#include <linux/capability.h>\n#include <linux/device.h>\n#include <linux/efi.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/kobject.h>\n#include <linux/list.h>\n#include <linux/memblock.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include <asm/io.h>\n#include <asm/early_ioremap.h>\n\nstruct efi_system_resource_entry_v1 {\n\tefi_guid_t\tfw_class;\n\tu32\t\tfw_type;\n\tu32\t\tfw_version;\n\tu32\t\tlowest_supported_fw_version;\n\tu32\t\tcapsule_flags;\n\tu32\t\tlast_attempt_version;\n\tu32\t\tlast_attempt_status;\n};\n\n \nstruct efi_system_resource_table {\n\tu32\tfw_resource_count;\n\tu32\tfw_resource_count_max;\n\tu64\tfw_resource_version;\n\tu8\tentries[];\n};\n\nstatic phys_addr_t esrt_data;\nstatic size_t esrt_data_size;\n\nstatic struct efi_system_resource_table *esrt;\n\nstruct esre_entry {\n\tunion {\n\t\tstruct efi_system_resource_entry_v1 *esre1;\n\t} esre;\n\n\tstruct kobject kobj;\n\tstruct list_head list;\n};\n\n \nstatic LIST_HEAD(entry_list);\n\n \nstruct esre_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct esre_entry *entry, char *buf);\n\tssize_t (*store)(struct esre_entry *entry,\n\t\t\t const char *buf, size_t count);\n};\n\nstatic struct esre_entry *to_entry(struct kobject *kobj)\n{\n\treturn container_of(kobj, struct esre_entry, kobj);\n}\n\nstatic struct esre_attribute *to_attr(struct attribute *attr)\n{\n\treturn container_of(attr, struct esre_attribute, attr);\n}\n\nstatic ssize_t esre_attr_show(struct kobject *kobj,\n\t\t\t      struct attribute *_attr, char *buf)\n{\n\tstruct esre_entry *entry = to_entry(kobj);\n\tstruct esre_attribute *attr = to_attr(_attr);\n\n\treturn attr->show(entry, buf);\n}\n\nstatic const struct sysfs_ops esre_attr_ops = {\n\t.show = esre_attr_show,\n};\n\n \nstatic ssize_t fw_class_show(struct esre_entry *entry, char *buf)\n{\n\tchar *str = buf;\n\n\tefi_guid_to_str(&entry->esre.esre1->fw_class, str);\n\tstr += strlen(str);\n\tstr += sprintf(str, \"\\n\");\n\n\treturn str - buf;\n}\n\nstatic struct esre_attribute esre_fw_class = __ATTR_RO_MODE(fw_class, 0400);\n\n#define esre_attr_decl(name, size, fmt) \\\nstatic ssize_t name##_show(struct esre_entry *entry, char *buf) \\\n{ \\\n\treturn sprintf(buf, fmt \"\\n\", \\\n\t\t       le##size##_to_cpu(entry->esre.esre1->name)); \\\n} \\\n\\\nstatic struct esre_attribute esre_##name = __ATTR_RO_MODE(name, 0400)\n\nesre_attr_decl(fw_type, 32, \"%u\");\nesre_attr_decl(fw_version, 32, \"%u\");\nesre_attr_decl(lowest_supported_fw_version, 32, \"%u\");\nesre_attr_decl(capsule_flags, 32, \"0x%x\");\nesre_attr_decl(last_attempt_version, 32, \"%u\");\nesre_attr_decl(last_attempt_status, 32, \"%u\");\n\nstatic struct attribute *esre1_attrs[] = {\n\t&esre_fw_class.attr,\n\t&esre_fw_type.attr,\n\t&esre_fw_version.attr,\n\t&esre_lowest_supported_fw_version.attr,\n\t&esre_capsule_flags.attr,\n\t&esre_last_attempt_version.attr,\n\t&esre_last_attempt_status.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(esre1);\n\nstatic void esre_release(struct kobject *kobj)\n{\n\tstruct esre_entry *entry = to_entry(kobj);\n\n\tlist_del(&entry->list);\n\tkfree(entry);\n}\n\nstatic const struct kobj_type esre1_ktype = {\n\t.release = esre_release,\n\t.sysfs_ops = &esre_attr_ops,\n\t.default_groups = esre1_groups,\n};\n\n\nstatic struct kobject *esrt_kobj;\nstatic struct kset *esrt_kset;\n\nstatic int esre_create_sysfs_entry(void *esre, int entry_num)\n{\n\tstruct esre_entry *entry;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->kobj.kset = esrt_kset;\n\n\tif (esrt->fw_resource_version == 1) {\n\t\tint rc = 0;\n\n\t\tentry->esre.esre1 = esre;\n\t\trc = kobject_init_and_add(&entry->kobj, &esre1_ktype, NULL,\n\t\t\t\t\t  \"entry%d\", entry_num);\n\t\tif (rc) {\n\t\t\tkobject_put(&entry->kobj);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tlist_add_tail(&entry->list, &entry_list);\n\treturn 0;\n}\n\n \n#define esrt_attr_decl(name, size, fmt) \\\nstatic ssize_t name##_show(struct kobject *kobj, \\\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\\\n{ \\\n\treturn sprintf(buf, fmt \"\\n\", le##size##_to_cpu(esrt->name)); \\\n} \\\n\\\nstatic struct kobj_attribute esrt_##name = __ATTR_RO_MODE(name, 0400)\n\nesrt_attr_decl(fw_resource_count, 32, \"%u\");\nesrt_attr_decl(fw_resource_count_max, 32, \"%u\");\nesrt_attr_decl(fw_resource_version, 64, \"%llu\");\n\nstatic struct attribute *esrt_attrs[] = {\n\t&esrt_fw_resource_count.attr,\n\t&esrt_fw_resource_count_max.attr,\n\t&esrt_fw_resource_version.attr,\n\tNULL,\n};\n\nstatic inline int esrt_table_exists(void)\n{\n\tif (!efi_enabled(EFI_CONFIG_TABLES))\n\t\treturn 0;\n\tif (efi.esrt == EFI_INVALID_TABLE_ADDR)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic umode_t esrt_attr_is_visible(struct kobject *kobj,\n\t\t\t\t    struct attribute *attr, int n)\n{\n\tif (!esrt_table_exists())\n\t\treturn 0;\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group esrt_attr_group = {\n\t.attrs = esrt_attrs,\n\t.is_visible = esrt_attr_is_visible,\n};\n\n \nvoid __init efi_esrt_init(void)\n{\n\tvoid *va;\n\tstruct efi_system_resource_table tmpesrt;\n\tsize_t size, max, entry_size, entries_size;\n\tefi_memory_desc_t md;\n\tint rc;\n\tphys_addr_t end;\n\n\tif (!efi_enabled(EFI_MEMMAP) && !efi_enabled(EFI_PARAVIRT))\n\t\treturn;\n\n\tpr_debug(\"esrt-init: loading.\\n\");\n\tif (!esrt_table_exists())\n\t\treturn;\n\n\trc = efi_mem_desc_lookup(efi.esrt, &md);\n\tif (rc < 0 ||\n\t    (!(md.attribute & EFI_MEMORY_RUNTIME) &&\n\t     md.type != EFI_BOOT_SERVICES_DATA &&\n\t     md.type != EFI_RUNTIME_SERVICES_DATA &&\n\t     md.type != EFI_ACPI_RECLAIM_MEMORY &&\n\t     md.type != EFI_ACPI_MEMORY_NVS)) {\n\t\tpr_warn(\"ESRT header is not in the memory map.\\n\");\n\t\treturn;\n\t}\n\n\tmax = efi_mem_desc_end(&md) - efi.esrt;\n\tsize = sizeof(*esrt);\n\n\tif (max < size) {\n\t\tpr_err(\"ESRT header doesn't fit on single memory map entry. (size: %zu max: %zu)\\n\",\n\t\t       size, max);\n\t\treturn;\n\t}\n\n\tva = early_memremap(efi.esrt, size);\n\tif (!va) {\n\t\tpr_err(\"early_memremap(%p, %zu) failed.\\n\", (void *)efi.esrt,\n\t\t       size);\n\t\treturn;\n\t}\n\n\tmemcpy(&tmpesrt, va, sizeof(tmpesrt));\n\tearly_memunmap(va, size);\n\n\tif (tmpesrt.fw_resource_version != 1) {\n\t\tpr_err(\"Unsupported ESRT version %lld.\\n\",\n\t\t       tmpesrt.fw_resource_version);\n\t\treturn;\n\t}\n\n\tentry_size = sizeof(struct efi_system_resource_entry_v1);\n\tif (tmpesrt.fw_resource_count > 0 && max - size < entry_size) {\n\t\tpr_err(\"ESRT memory map entry can only hold the header. (max: %zu size: %zu)\\n\",\n\t\t       max - size, entry_size);\n\t\treturn;\n\t}\n\n\t \n\tif (tmpesrt.fw_resource_count > 128) {\n\t\tpr_err(\"ESRT says fw_resource_count has very large value %d.\\n\",\n\t\t       tmpesrt.fw_resource_count);\n\t\treturn;\n\t}\n\n\t \n\tentries_size = tmpesrt.fw_resource_count * entry_size;\n\tif (max < size + entries_size) {\n\t\tpr_err(\"ESRT does not fit on single memory map entry (size: %zu max: %zu)\\n\",\n\t\t       size, max);\n\t\treturn;\n\t}\n\n\tsize += entries_size;\n\n\tesrt_data = (phys_addr_t)efi.esrt;\n\tesrt_data_size = size;\n\n\tend = esrt_data + size;\n\tpr_info(\"Reserving ESRT space from %pa to %pa.\\n\", &esrt_data, &end);\n\tif (md.type == EFI_BOOT_SERVICES_DATA)\n\t\tefi_mem_reserve(esrt_data, esrt_data_size);\n\n\tpr_debug(\"esrt-init: loaded.\\n\");\n}\n\nstatic int __init register_entries(void)\n{\n\tstruct efi_system_resource_entry_v1 *v1_entries = (void *)esrt->entries;\n\tint i, rc;\n\n\tif (!esrt_table_exists())\n\t\treturn 0;\n\n\tfor (i = 0; i < le32_to_cpu(esrt->fw_resource_count); i++) {\n\t\tvoid *esre = NULL;\n\t\tif (esrt->fw_resource_version == 1) {\n\t\t\tesre = &v1_entries[i];\n\t\t} else {\n\t\t\tpr_err(\"Unsupported ESRT version %lld.\\n\",\n\t\t\t       esrt->fw_resource_version);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trc = esre_create_sysfs_entry(esre, i);\n\t\tif (rc < 0) {\n\t\t\tpr_err(\"ESRT entry creation failed with error %d.\\n\",\n\t\t\t       rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void cleanup_entry_list(void)\n{\n\tstruct esre_entry *entry, *next;\n\n\tlist_for_each_entry_safe(entry, next, &entry_list, list) {\n\t\tkobject_put(&entry->kobj);\n\t}\n}\n\nstatic int __init esrt_sysfs_init(void)\n{\n\tint error;\n\n\tpr_debug(\"esrt-sysfs: loading.\\n\");\n\tif (!esrt_data || !esrt_data_size)\n\t\treturn -ENOSYS;\n\n\tesrt = memremap(esrt_data, esrt_data_size, MEMREMAP_WB);\n\tif (!esrt) {\n\t\tpr_err(\"memremap(%pa, %zu) failed.\\n\", &esrt_data,\n\t\t       esrt_data_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tesrt_kobj = kobject_create_and_add(\"esrt\", efi_kobj);\n\tif (!esrt_kobj) {\n\t\tpr_err(\"Firmware table registration failed.\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\terror = sysfs_create_group(esrt_kobj, &esrt_attr_group);\n\tif (error) {\n\t\tpr_err(\"Sysfs attribute export failed with error %d.\\n\",\n\t\t       error);\n\t\tgoto err_remove_esrt;\n\t}\n\n\tesrt_kset = kset_create_and_add(\"entries\", NULL, esrt_kobj);\n\tif (!esrt_kset) {\n\t\tpr_err(\"kset creation failed.\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_remove_group;\n\t}\n\n\terror = register_entries();\n\tif (error)\n\t\tgoto err_cleanup_list;\n\n\tpr_debug(\"esrt-sysfs: loaded.\\n\");\n\n\treturn 0;\nerr_cleanup_list:\n\tcleanup_entry_list();\n\tkset_unregister(esrt_kset);\nerr_remove_group:\n\tsysfs_remove_group(esrt_kobj, &esrt_attr_group);\nerr_remove_esrt:\n\tkobject_put(esrt_kobj);\nerr:\n\tmemunmap(esrt);\n\tesrt = NULL;\n\treturn error;\n}\ndevice_initcall(esrt_sysfs_init);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}