{
  "module_name": "cper.c",
  "hash_id": "3f384d344aa4b34a11236d6df83ce490b7f0d5f59e0f6305eabd4a39a80dabd7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/cper.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/time.h>\n#include <linux/cper.h>\n#include <linux/dmi.h>\n#include <linux/acpi.h>\n#include <linux/pci.h>\n#include <linux/aer.h>\n#include <linux/printk.h>\n#include <linux/bcd.h>\n#include <acpi/ghes.h>\n#include <ras/ras_event.h>\n#include \"cper_cxl.h\"\n\n \nu64 cper_next_record_id(void)\n{\n\tstatic atomic64_t seq;\n\n\tif (!atomic64_read(&seq)) {\n\t\ttime64_t time = ktime_get_real_seconds();\n\n\t\t \n\t\tif (time < 0x80000000)\n\t\t\tatomic64_set(&seq, (ktime_get_real_seconds()) << 32);\n\t\telse\n\t\t\tatomic64_set(&seq, 0x8000000000000000ull |\n\t\t\t\t\t   ktime_get_real_seconds() << 24);\n\t}\n\n\treturn atomic64_inc_return(&seq);\n}\nEXPORT_SYMBOL_GPL(cper_next_record_id);\n\nstatic const char * const severity_strs[] = {\n\t\"recoverable\",\n\t\"fatal\",\n\t\"corrected\",\n\t\"info\",\n};\n\nconst char *cper_severity_str(unsigned int severity)\n{\n\treturn severity < ARRAY_SIZE(severity_strs) ?\n\t\tseverity_strs[severity] : \"unknown\";\n}\nEXPORT_SYMBOL_GPL(cper_severity_str);\n\n \nvoid cper_print_bits(const char *pfx, unsigned int bits,\n\t\t     const char * const strs[], unsigned int strs_size)\n{\n\tint i, len = 0;\n\tconst char *str;\n\tchar buf[84];\n\n\tfor (i = 0; i < strs_size; i++) {\n\t\tif (!(bits & (1U << i)))\n\t\t\tcontinue;\n\t\tstr = strs[i];\n\t\tif (!str)\n\t\t\tcontinue;\n\t\tif (len && len + strlen(str) + 2 > 80) {\n\t\t\tprintk(\"%s\\n\", buf);\n\t\t\tlen = 0;\n\t\t}\n\t\tif (!len)\n\t\t\tlen = snprintf(buf, sizeof(buf), \"%s%s\", pfx, str);\n\t\telse\n\t\t\tlen += scnprintf(buf+len, sizeof(buf)-len, \", %s\", str);\n\t}\n\tif (len)\n\t\tprintk(\"%s\\n\", buf);\n}\n\nstatic const char * const proc_type_strs[] = {\n\t\"IA32/X64\",\n\t\"IA64\",\n\t\"ARM\",\n};\n\nstatic const char * const proc_isa_strs[] = {\n\t\"IA32\",\n\t\"IA64\",\n\t\"X64\",\n\t\"ARM A32/T32\",\n\t\"ARM A64\",\n};\n\nconst char * const cper_proc_error_type_strs[] = {\n\t\"cache error\",\n\t\"TLB error\",\n\t\"bus error\",\n\t\"micro-architectural error\",\n};\n\nstatic const char * const proc_op_strs[] = {\n\t\"unknown or generic\",\n\t\"data read\",\n\t\"data write\",\n\t\"instruction execution\",\n};\n\nstatic const char * const proc_flag_strs[] = {\n\t\"restartable\",\n\t\"precise IP\",\n\t\"overflow\",\n\t\"corrected\",\n};\n\nstatic void cper_print_proc_generic(const char *pfx,\n\t\t\t\t    const struct cper_sec_proc_generic *proc)\n{\n\tif (proc->validation_bits & CPER_PROC_VALID_TYPE)\n\t\tprintk(\"%s\"\"processor_type: %d, %s\\n\", pfx, proc->proc_type,\n\t\t       proc->proc_type < ARRAY_SIZE(proc_type_strs) ?\n\t\t       proc_type_strs[proc->proc_type] : \"unknown\");\n\tif (proc->validation_bits & CPER_PROC_VALID_ISA)\n\t\tprintk(\"%s\"\"processor_isa: %d, %s\\n\", pfx, proc->proc_isa,\n\t\t       proc->proc_isa < ARRAY_SIZE(proc_isa_strs) ?\n\t\t       proc_isa_strs[proc->proc_isa] : \"unknown\");\n\tif (proc->validation_bits & CPER_PROC_VALID_ERROR_TYPE) {\n\t\tprintk(\"%s\"\"error_type: 0x%02x\\n\", pfx, proc->proc_error_type);\n\t\tcper_print_bits(pfx, proc->proc_error_type,\n\t\t\t\tcper_proc_error_type_strs,\n\t\t\t\tARRAY_SIZE(cper_proc_error_type_strs));\n\t}\n\tif (proc->validation_bits & CPER_PROC_VALID_OPERATION)\n\t\tprintk(\"%s\"\"operation: %d, %s\\n\", pfx, proc->operation,\n\t\t       proc->operation < ARRAY_SIZE(proc_op_strs) ?\n\t\t       proc_op_strs[proc->operation] : \"unknown\");\n\tif (proc->validation_bits & CPER_PROC_VALID_FLAGS) {\n\t\tprintk(\"%s\"\"flags: 0x%02x\\n\", pfx, proc->flags);\n\t\tcper_print_bits(pfx, proc->flags, proc_flag_strs,\n\t\t\t\tARRAY_SIZE(proc_flag_strs));\n\t}\n\tif (proc->validation_bits & CPER_PROC_VALID_LEVEL)\n\t\tprintk(\"%s\"\"level: %d\\n\", pfx, proc->level);\n\tif (proc->validation_bits & CPER_PROC_VALID_VERSION)\n\t\tprintk(\"%s\"\"version_info: 0x%016llx\\n\", pfx, proc->cpu_version);\n\tif (proc->validation_bits & CPER_PROC_VALID_ID)\n\t\tprintk(\"%s\"\"processor_id: 0x%016llx\\n\", pfx, proc->proc_id);\n\tif (proc->validation_bits & CPER_PROC_VALID_TARGET_ADDRESS)\n\t\tprintk(\"%s\"\"target_address: 0x%016llx\\n\",\n\t\t       pfx, proc->target_addr);\n\tif (proc->validation_bits & CPER_PROC_VALID_REQUESTOR_ID)\n\t\tprintk(\"%s\"\"requestor_id: 0x%016llx\\n\",\n\t\t       pfx, proc->requestor_id);\n\tif (proc->validation_bits & CPER_PROC_VALID_RESPONDER_ID)\n\t\tprintk(\"%s\"\"responder_id: 0x%016llx\\n\",\n\t\t       pfx, proc->responder_id);\n\tif (proc->validation_bits & CPER_PROC_VALID_IP)\n\t\tprintk(\"%s\"\"IP: 0x%016llx\\n\", pfx, proc->ip);\n}\n\nstatic const char * const mem_err_type_strs[] = {\n\t\"unknown\",\n\t\"no error\",\n\t\"single-bit ECC\",\n\t\"multi-bit ECC\",\n\t\"single-symbol chipkill ECC\",\n\t\"multi-symbol chipkill ECC\",\n\t\"master abort\",\n\t\"target abort\",\n\t\"parity error\",\n\t\"watchdog timeout\",\n\t\"invalid address\",\n\t\"mirror Broken\",\n\t\"memory sparing\",\n\t\"scrub corrected error\",\n\t\"scrub uncorrected error\",\n\t\"physical memory map-out event\",\n};\n\nconst char *cper_mem_err_type_str(unsigned int etype)\n{\n\treturn etype < ARRAY_SIZE(mem_err_type_strs) ?\n\t\tmem_err_type_strs[etype] : \"unknown\";\n}\nEXPORT_SYMBOL_GPL(cper_mem_err_type_str);\n\nconst char *cper_mem_err_status_str(u64 status)\n{\n\tswitch ((status >> 8) & 0xff) {\n\tcase  1:\treturn \"Error detected internal to the component\";\n\tcase  4:\treturn \"Storage error in DRAM memory\";\n\tcase  5:\treturn \"Storage error in TLB\";\n\tcase  6:\treturn \"Storage error in cache\";\n\tcase  7:\treturn \"Error in one or more functional units\";\n\tcase  8:\treturn \"Component failed self test\";\n\tcase  9:\treturn \"Overflow or undervalue of internal queue\";\n\tcase 16:\treturn \"Error detected in the bus\";\n\tcase 17:\treturn \"Virtual address not found on IO-TLB or IO-PDIR\";\n\tcase 18:\treturn \"Improper access error\";\n\tcase 19:\treturn \"Access to a memory address which is not mapped to any component\";\n\tcase 20:\treturn \"Loss of Lockstep\";\n\tcase 21:\treturn \"Response not associated with a request\";\n\tcase 22:\treturn \"Bus parity error - must also set the A, C, or D Bits\";\n\tcase 23:\treturn \"Detection of a protocol error\";\n\tcase 24:\treturn \"Detection of a PATH_ERROR\";\n\tcase 25:\treturn \"Bus operation timeout\";\n\tcase 26:\treturn \"A read was issued to data that has been poisoned\";\n\tdefault:\treturn \"Reserved\";\n\t}\n}\nEXPORT_SYMBOL_GPL(cper_mem_err_status_str);\n\nint cper_mem_err_location(struct cper_mem_err_compact *mem, char *msg)\n{\n\tu32 len, n;\n\n\tif (!msg)\n\t\treturn 0;\n\n\tn = 0;\n\tlen = CPER_REC_LEN;\n\tif (mem->validation_bits & CPER_MEM_VALID_NODE)\n\t\tn += scnprintf(msg + n, len - n, \"node:%d \", mem->node);\n\tif (mem->validation_bits & CPER_MEM_VALID_CARD)\n\t\tn += scnprintf(msg + n, len - n, \"card:%d \", mem->card);\n\tif (mem->validation_bits & CPER_MEM_VALID_MODULE)\n\t\tn += scnprintf(msg + n, len - n, \"module:%d \", mem->module);\n\tif (mem->validation_bits & CPER_MEM_VALID_RANK_NUMBER)\n\t\tn += scnprintf(msg + n, len - n, \"rank:%d \", mem->rank);\n\tif (mem->validation_bits & CPER_MEM_VALID_BANK)\n\t\tn += scnprintf(msg + n, len - n, \"bank:%d \", mem->bank);\n\tif (mem->validation_bits & CPER_MEM_VALID_BANK_GROUP)\n\t\tn += scnprintf(msg + n, len - n, \"bank_group:%d \",\n\t\t\t       mem->bank >> CPER_MEM_BANK_GROUP_SHIFT);\n\tif (mem->validation_bits & CPER_MEM_VALID_BANK_ADDRESS)\n\t\tn += scnprintf(msg + n, len - n, \"bank_address:%d \",\n\t\t\t       mem->bank & CPER_MEM_BANK_ADDRESS_MASK);\n\tif (mem->validation_bits & CPER_MEM_VALID_DEVICE)\n\t\tn += scnprintf(msg + n, len - n, \"device:%d \", mem->device);\n\tif (mem->validation_bits & (CPER_MEM_VALID_ROW | CPER_MEM_VALID_ROW_EXT)) {\n\t\tu32 row = mem->row;\n\n\t\trow |= cper_get_mem_extension(mem->validation_bits, mem->extended);\n\t\tn += scnprintf(msg + n, len - n, \"row:%d \", row);\n\t}\n\tif (mem->validation_bits & CPER_MEM_VALID_COLUMN)\n\t\tn += scnprintf(msg + n, len - n, \"column:%d \", mem->column);\n\tif (mem->validation_bits & CPER_MEM_VALID_BIT_POSITION)\n\t\tn += scnprintf(msg + n, len - n, \"bit_position:%d \",\n\t\t\t       mem->bit_pos);\n\tif (mem->validation_bits & CPER_MEM_VALID_REQUESTOR_ID)\n\t\tn += scnprintf(msg + n, len - n, \"requestor_id:0x%016llx \",\n\t\t\t       mem->requestor_id);\n\tif (mem->validation_bits & CPER_MEM_VALID_RESPONDER_ID)\n\t\tn += scnprintf(msg + n, len - n, \"responder_id:0x%016llx \",\n\t\t\t       mem->responder_id);\n\tif (mem->validation_bits & CPER_MEM_VALID_TARGET_ID)\n\t\tn += scnprintf(msg + n, len - n, \"target_id:0x%016llx \",\n\t\t\t       mem->target_id);\n\tif (mem->validation_bits & CPER_MEM_VALID_CHIP_ID)\n\t\tn += scnprintf(msg + n, len - n, \"chip_id:%d \",\n\t\t\t       mem->extended >> CPER_MEM_CHIP_ID_SHIFT);\n\n\treturn n;\n}\nEXPORT_SYMBOL_GPL(cper_mem_err_location);\n\nint cper_dimm_err_location(struct cper_mem_err_compact *mem, char *msg)\n{\n\tu32 len, n;\n\tconst char *bank = NULL, *device = NULL;\n\n\tif (!msg || !(mem->validation_bits & CPER_MEM_VALID_MODULE_HANDLE))\n\t\treturn 0;\n\n\tlen = CPER_REC_LEN;\n\tdmi_memdev_name(mem->mem_dev_handle, &bank, &device);\n\tif (bank && device)\n\t\tn = snprintf(msg, len, \"DIMM location: %s %s \", bank, device);\n\telse\n\t\tn = snprintf(msg, len,\n\t\t\t     \"DIMM location: not present. DMI handle: 0x%.4x \",\n\t\t\t     mem->mem_dev_handle);\n\n\treturn n;\n}\nEXPORT_SYMBOL_GPL(cper_dimm_err_location);\n\nvoid cper_mem_err_pack(const struct cper_sec_mem_err *mem,\n\t\t       struct cper_mem_err_compact *cmem)\n{\n\tcmem->validation_bits = mem->validation_bits;\n\tcmem->node = mem->node;\n\tcmem->card = mem->card;\n\tcmem->module = mem->module;\n\tcmem->bank = mem->bank;\n\tcmem->device = mem->device;\n\tcmem->row = mem->row;\n\tcmem->column = mem->column;\n\tcmem->bit_pos = mem->bit_pos;\n\tcmem->requestor_id = mem->requestor_id;\n\tcmem->responder_id = mem->responder_id;\n\tcmem->target_id = mem->target_id;\n\tcmem->extended = mem->extended;\n\tcmem->rank = mem->rank;\n\tcmem->mem_array_handle = mem->mem_array_handle;\n\tcmem->mem_dev_handle = mem->mem_dev_handle;\n}\nEXPORT_SYMBOL_GPL(cper_mem_err_pack);\n\nconst char *cper_mem_err_unpack(struct trace_seq *p,\n\t\t\t\tstruct cper_mem_err_compact *cmem)\n{\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\tchar rcd_decode_str[CPER_REC_LEN];\n\n\tif (cper_mem_err_location(cmem, rcd_decode_str))\n\t\ttrace_seq_printf(p, \"%s\", rcd_decode_str);\n\tif (cper_dimm_err_location(cmem, rcd_decode_str))\n\t\ttrace_seq_printf(p, \"%s\", rcd_decode_str);\n\ttrace_seq_putc(p, '\\0');\n\n\treturn ret;\n}\n\nstatic void cper_print_mem(const char *pfx, const struct cper_sec_mem_err *mem,\n\tint len)\n{\n\tstruct cper_mem_err_compact cmem;\n\tchar rcd_decode_str[CPER_REC_LEN];\n\n\t \n\tif (len == sizeof(struct cper_sec_mem_err_old) &&\n\t    (mem->validation_bits & ~(CPER_MEM_VALID_RANK_NUMBER - 1))) {\n\t\tpr_err(FW_WARN \"valid bits set for fields beyond structure\\n\");\n\t\treturn;\n\t}\n\tif (mem->validation_bits & CPER_MEM_VALID_ERROR_STATUS)\n\t\tprintk(\"%s error_status: %s (0x%016llx)\\n\",\n\t\t       pfx, cper_mem_err_status_str(mem->error_status),\n\t\t       mem->error_status);\n\tif (mem->validation_bits & CPER_MEM_VALID_PA)\n\t\tprintk(\"%s\"\"physical_address: 0x%016llx\\n\",\n\t\t       pfx, mem->physical_addr);\n\tif (mem->validation_bits & CPER_MEM_VALID_PA_MASK)\n\t\tprintk(\"%s\"\"physical_address_mask: 0x%016llx\\n\",\n\t\t       pfx, mem->physical_addr_mask);\n\tcper_mem_err_pack(mem, &cmem);\n\tif (cper_mem_err_location(&cmem, rcd_decode_str))\n\t\tprintk(\"%s%s\\n\", pfx, rcd_decode_str);\n\tif (mem->validation_bits & CPER_MEM_VALID_ERROR_TYPE) {\n\t\tu8 etype = mem->error_type;\n\t\tprintk(\"%s\"\"error_type: %d, %s\\n\", pfx, etype,\n\t\t       cper_mem_err_type_str(etype));\n\t}\n\tif (cper_dimm_err_location(&cmem, rcd_decode_str))\n\t\tprintk(\"%s%s\\n\", pfx, rcd_decode_str);\n}\n\nstatic const char * const pcie_port_type_strs[] = {\n\t\"PCIe end point\",\n\t\"legacy PCI end point\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"root port\",\n\t\"upstream switch port\",\n\t\"downstream switch port\",\n\t\"PCIe to PCI/PCI-X bridge\",\n\t\"PCI/PCI-X to PCIe bridge\",\n\t\"root complex integrated endpoint device\",\n\t\"root complex event collector\",\n};\n\nstatic void cper_print_pcie(const char *pfx, const struct cper_sec_pcie *pcie,\n\t\t\t    const struct acpi_hest_generic_data *gdata)\n{\n\tif (pcie->validation_bits & CPER_PCIE_VALID_PORT_TYPE)\n\t\tprintk(\"%s\"\"port_type: %d, %s\\n\", pfx, pcie->port_type,\n\t\t       pcie->port_type < ARRAY_SIZE(pcie_port_type_strs) ?\n\t\t       pcie_port_type_strs[pcie->port_type] : \"unknown\");\n\tif (pcie->validation_bits & CPER_PCIE_VALID_VERSION)\n\t\tprintk(\"%s\"\"version: %d.%d\\n\", pfx,\n\t\t       pcie->version.major, pcie->version.minor);\n\tif (pcie->validation_bits & CPER_PCIE_VALID_COMMAND_STATUS)\n\t\tprintk(\"%s\"\"command: 0x%04x, status: 0x%04x\\n\", pfx,\n\t\t       pcie->command, pcie->status);\n\tif (pcie->validation_bits & CPER_PCIE_VALID_DEVICE_ID) {\n\t\tconst __u8 *p;\n\t\tprintk(\"%s\"\"device_id: %04x:%02x:%02x.%x\\n\", pfx,\n\t\t       pcie->device_id.segment, pcie->device_id.bus,\n\t\t       pcie->device_id.device, pcie->device_id.function);\n\t\tprintk(\"%s\"\"slot: %d\\n\", pfx,\n\t\t       pcie->device_id.slot >> CPER_PCIE_SLOT_SHIFT);\n\t\tprintk(\"%s\"\"secondary_bus: 0x%02x\\n\", pfx,\n\t\t       pcie->device_id.secondary_bus);\n\t\tprintk(\"%s\"\"vendor_id: 0x%04x, device_id: 0x%04x\\n\", pfx,\n\t\t       pcie->device_id.vendor_id, pcie->device_id.device_id);\n\t\tp = pcie->device_id.class_code;\n\t\tprintk(\"%s\"\"class_code: %02x%02x%02x\\n\", pfx, p[2], p[1], p[0]);\n\t}\n\tif (pcie->validation_bits & CPER_PCIE_VALID_SERIAL_NUMBER)\n\t\tprintk(\"%s\"\"serial number: 0x%04x, 0x%04x\\n\", pfx,\n\t\t       pcie->serial_number.lower, pcie->serial_number.upper);\n\tif (pcie->validation_bits & CPER_PCIE_VALID_BRIDGE_CONTROL_STATUS)\n\t\tprintk(\n\t\"%s\"\"bridge: secondary_status: 0x%04x, control: 0x%04x\\n\",\n\tpfx, pcie->bridge.secondary_status, pcie->bridge.control);\n\n\t \n\tif ((pcie->validation_bits & CPER_PCIE_VALID_AER_INFO) &&\n\t    (gdata->error_severity & CPER_SEV_FATAL)) {\n\t\tstruct aer_capability_regs *aer;\n\n\t\taer = (struct aer_capability_regs *)pcie->aer_info;\n\t\tprintk(\"%saer_uncor_status: 0x%08x, aer_uncor_mask: 0x%08x\\n\",\n\t\t       pfx, aer->uncor_status, aer->uncor_mask);\n\t\tprintk(\"%saer_uncor_severity: 0x%08x\\n\",\n\t\t       pfx, aer->uncor_severity);\n\t\tprintk(\"%sTLP Header: %08x %08x %08x %08x\\n\", pfx,\n\t\t       aer->header_log.dw0, aer->header_log.dw1,\n\t\t       aer->header_log.dw2, aer->header_log.dw3);\n\t}\n}\n\nstatic const char * const fw_err_rec_type_strs[] = {\n\t\"IPF SAL Error Record\",\n\t\"SOC Firmware Error Record Type1 (Legacy CrashLog Support)\",\n\t\"SOC Firmware Error Record Type2\",\n};\n\nstatic void cper_print_fw_err(const char *pfx,\n\t\t\t      struct acpi_hest_generic_data *gdata,\n\t\t\t      const struct cper_sec_fw_err_rec_ref *fw_err)\n{\n\tvoid *buf = acpi_hest_get_payload(gdata);\n\tu32 offset, length = gdata->error_data_length;\n\n\tprintk(\"%s\"\"Firmware Error Record Type: %s\\n\", pfx,\n\t       fw_err->record_type < ARRAY_SIZE(fw_err_rec_type_strs) ?\n\t       fw_err_rec_type_strs[fw_err->record_type] : \"unknown\");\n\tprintk(\"%s\"\"Revision: %d\\n\", pfx, fw_err->revision);\n\n\t \n\tif (fw_err->revision == 0) {\n\t\tprintk(\"%s\"\"Record Identifier: %08llx\\n\", pfx,\n\t\t       fw_err->record_identifier);\n\t} else if (fw_err->revision == 2) {\n\t\tprintk(\"%s\"\"Record Identifier: %pUl\\n\", pfx,\n\t\t       &fw_err->record_identifier_guid);\n\t}\n\n\t \n\tif (fw_err->revision == 0) {\n\t\t \n\t\toffset = offsetof(struct cper_sec_fw_err_rec_ref,\n\t\t\t\t  record_identifier_guid);\n\t} else if (fw_err->revision == 1) {\n\t\t \n\t\toffset = offsetof(struct cper_sec_fw_err_rec_ref,\n\t\t\t\t  record_identifier);\n\t} else {\n\t\toffset = sizeof(*fw_err);\n\t}\n\n\tbuf += offset;\n\tlength -= offset;\n\n\tprint_hex_dump(pfx, \"\", DUMP_PREFIX_OFFSET, 16, 4, buf, length, true);\n}\n\nstatic void cper_print_tstamp(const char *pfx,\n\t\t\t\t   struct acpi_hest_generic_data_v300 *gdata)\n{\n\t__u8 hour, min, sec, day, mon, year, century, *timestamp;\n\n\tif (gdata->validation_bits & ACPI_HEST_GEN_VALID_TIMESTAMP) {\n\t\ttimestamp = (__u8 *)&(gdata->time_stamp);\n\t\tsec       = bcd2bin(timestamp[0]);\n\t\tmin       = bcd2bin(timestamp[1]);\n\t\thour      = bcd2bin(timestamp[2]);\n\t\tday       = bcd2bin(timestamp[4]);\n\t\tmon       = bcd2bin(timestamp[5]);\n\t\tyear      = bcd2bin(timestamp[6]);\n\t\tcentury   = bcd2bin(timestamp[7]);\n\n\t\tprintk(\"%s%ststamp: %02d%02d-%02d-%02d %02d:%02d:%02d\\n\", pfx,\n\t\t       (timestamp[3] & 0x1 ? \"precise \" : \"imprecise \"),\n\t\t       century, year, mon, day, hour, min, sec);\n\t}\n}\n\nstatic void\ncper_estatus_print_section(const char *pfx, struct acpi_hest_generic_data *gdata,\n\t\t\t   int sec_no)\n{\n\tguid_t *sec_type = (guid_t *)gdata->section_type;\n\t__u16 severity;\n\tchar newpfx[64];\n\n\tif (acpi_hest_get_version(gdata) >= 3)\n\t\tcper_print_tstamp(pfx, (struct acpi_hest_generic_data_v300 *)gdata);\n\n\tseverity = gdata->error_severity;\n\tprintk(\"%s\"\"Error %d, type: %s\\n\", pfx, sec_no,\n\t       cper_severity_str(severity));\n\tif (gdata->validation_bits & CPER_SEC_VALID_FRU_ID)\n\t\tprintk(\"%s\"\"fru_id: %pUl\\n\", pfx, gdata->fru_id);\n\tif (gdata->validation_bits & CPER_SEC_VALID_FRU_TEXT)\n\t\tprintk(\"%s\"\"fru_text: %.20s\\n\", pfx, gdata->fru_text);\n\n\tsnprintf(newpfx, sizeof(newpfx), \"%s \", pfx);\n\tif (guid_equal(sec_type, &CPER_SEC_PROC_GENERIC)) {\n\t\tstruct cper_sec_proc_generic *proc_err = acpi_hest_get_payload(gdata);\n\n\t\tprintk(\"%s\"\"section_type: general processor error\\n\", newpfx);\n\t\tif (gdata->error_data_length >= sizeof(*proc_err))\n\t\t\tcper_print_proc_generic(newpfx, proc_err);\n\t\telse\n\t\t\tgoto err_section_too_small;\n\t} else if (guid_equal(sec_type, &CPER_SEC_PLATFORM_MEM)) {\n\t\tstruct cper_sec_mem_err *mem_err = acpi_hest_get_payload(gdata);\n\n\t\tprintk(\"%s\"\"section_type: memory error\\n\", newpfx);\n\t\tif (gdata->error_data_length >=\n\t\t    sizeof(struct cper_sec_mem_err_old))\n\t\t\tcper_print_mem(newpfx, mem_err,\n\t\t\t\t       gdata->error_data_length);\n\t\telse\n\t\t\tgoto err_section_too_small;\n\t} else if (guid_equal(sec_type, &CPER_SEC_PCIE)) {\n\t\tstruct cper_sec_pcie *pcie = acpi_hest_get_payload(gdata);\n\n\t\tprintk(\"%s\"\"section_type: PCIe error\\n\", newpfx);\n\t\tif (gdata->error_data_length >= sizeof(*pcie))\n\t\t\tcper_print_pcie(newpfx, pcie, gdata);\n\t\telse\n\t\t\tgoto err_section_too_small;\n#if defined(CONFIG_ARM64) || defined(CONFIG_ARM)\n\t} else if (guid_equal(sec_type, &CPER_SEC_PROC_ARM)) {\n\t\tstruct cper_sec_proc_arm *arm_err = acpi_hest_get_payload(gdata);\n\n\t\tprintk(\"%ssection_type: ARM processor error\\n\", newpfx);\n\t\tif (gdata->error_data_length >= sizeof(*arm_err))\n\t\t\tcper_print_proc_arm(newpfx, arm_err);\n\t\telse\n\t\t\tgoto err_section_too_small;\n#endif\n#if defined(CONFIG_UEFI_CPER_X86)\n\t} else if (guid_equal(sec_type, &CPER_SEC_PROC_IA)) {\n\t\tstruct cper_sec_proc_ia *ia_err = acpi_hest_get_payload(gdata);\n\n\t\tprintk(\"%ssection_type: IA32/X64 processor error\\n\", newpfx);\n\t\tif (gdata->error_data_length >= sizeof(*ia_err))\n\t\t\tcper_print_proc_ia(newpfx, ia_err);\n\t\telse\n\t\t\tgoto err_section_too_small;\n#endif\n\t} else if (guid_equal(sec_type, &CPER_SEC_FW_ERR_REC_REF)) {\n\t\tstruct cper_sec_fw_err_rec_ref *fw_err = acpi_hest_get_payload(gdata);\n\n\t\tprintk(\"%ssection_type: Firmware Error Record Reference\\n\",\n\t\t       newpfx);\n\t\t \n\t\tif (gdata->error_data_length >= SZ_16)\n\t\t\tcper_print_fw_err(newpfx, gdata, fw_err);\n\t\telse\n\t\t\tgoto err_section_too_small;\n\t} else if (guid_equal(sec_type, &CPER_SEC_CXL_PROT_ERR)) {\n\t\tstruct cper_sec_prot_err *prot_err = acpi_hest_get_payload(gdata);\n\n\t\tprintk(\"%ssection_type: CXL Protocol Error\\n\", newpfx);\n\t\tif (gdata->error_data_length >= sizeof(*prot_err))\n\t\t\tcper_print_prot_err(newpfx, prot_err);\n\t\telse\n\t\t\tgoto err_section_too_small;\n\t} else {\n\t\tconst void *err = acpi_hest_get_payload(gdata);\n\n\t\tprintk(\"%ssection type: unknown, %pUl\\n\", newpfx, sec_type);\n\t\tprintk(\"%ssection length: %#x\\n\", newpfx,\n\t\t       gdata->error_data_length);\n\t\tprint_hex_dump(newpfx, \"\", DUMP_PREFIX_OFFSET, 16, 4, err,\n\t\t\t       gdata->error_data_length, true);\n\t}\n\n\treturn;\n\nerr_section_too_small:\n\tpr_err(FW_WARN \"error section length is too small\\n\");\n}\n\nvoid cper_estatus_print(const char *pfx,\n\t\t\tconst struct acpi_hest_generic_status *estatus)\n{\n\tstruct acpi_hest_generic_data *gdata;\n\tint sec_no = 0;\n\tchar newpfx[64];\n\t__u16 severity;\n\n\tseverity = estatus->error_severity;\n\tif (severity == CPER_SEV_CORRECTED)\n\t\tprintk(\"%s%s\\n\", pfx,\n\t\t       \"It has been corrected by h/w \"\n\t\t       \"and requires no further action\");\n\tprintk(\"%s\"\"event severity: %s\\n\", pfx, cper_severity_str(severity));\n\tsnprintf(newpfx, sizeof(newpfx), \"%s \", pfx);\n\n\tapei_estatus_for_each_section(estatus, gdata) {\n\t\tcper_estatus_print_section(newpfx, gdata, sec_no);\n\t\tsec_no++;\n\t}\n}\nEXPORT_SYMBOL_GPL(cper_estatus_print);\n\nint cper_estatus_check_header(const struct acpi_hest_generic_status *estatus)\n{\n\tif (estatus->data_length &&\n\t    estatus->data_length < sizeof(struct acpi_hest_generic_data))\n\t\treturn -EINVAL;\n\tif (estatus->raw_data_length &&\n\t    estatus->raw_data_offset < sizeof(*estatus) + estatus->data_length)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cper_estatus_check_header);\n\nint cper_estatus_check(const struct acpi_hest_generic_status *estatus)\n{\n\tstruct acpi_hest_generic_data *gdata;\n\tunsigned int data_len, record_size;\n\tint rc;\n\n\trc = cper_estatus_check_header(estatus);\n\tif (rc)\n\t\treturn rc;\n\n\tdata_len = estatus->data_length;\n\n\tapei_estatus_for_each_section(estatus, gdata) {\n\t\tif (acpi_hest_get_size(gdata) > data_len)\n\t\t\treturn -EINVAL;\n\n\t\trecord_size = acpi_hest_get_record_size(gdata);\n\t\tif (record_size > data_len)\n\t\t\treturn -EINVAL;\n\n\t\tdata_len -= record_size;\n\t}\n\tif (data_len)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cper_estatus_check);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}