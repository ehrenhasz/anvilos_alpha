{
  "module_name": "capsule-loader.c",
  "hash_id": "58b29734168c2b5996627abd9aeffad00bb096958b1a6d87b74825a0be190778",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/capsule-loader.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"efi: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/miscdevice.h>\n#include <linux/highmem.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/efi.h>\n#include <linux/vmalloc.h>\n\n#define NO_FURTHER_WRITE_ACTION -1\n\n \nstatic void efi_free_all_buff_pages(struct capsule_info *cap_info)\n{\n\twhile (cap_info->index > 0)\n\t\t__free_page(cap_info->pages[--cap_info->index]);\n\n\tcap_info->index = NO_FURTHER_WRITE_ACTION;\n}\n\nint __efi_capsule_setup_info(struct capsule_info *cap_info)\n{\n\tsize_t pages_needed;\n\tint ret;\n\tvoid *temp_page;\n\n\tpages_needed = ALIGN(cap_info->total_size, PAGE_SIZE) / PAGE_SIZE;\n\n\tif (pages_needed == 0) {\n\t\tpr_err(\"invalid capsule size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = efi_capsule_supported(cap_info->header.guid,\n\t\t\t\t    cap_info->header.flags,\n\t\t\t\t    cap_info->header.imagesize,\n\t\t\t\t    &cap_info->reset_type);\n\tif (ret) {\n\t\tpr_err(\"capsule not supported\\n\");\n\t\treturn ret;\n\t}\n\n\ttemp_page = krealloc(cap_info->pages,\n\t\t\t     pages_needed * sizeof(void *),\n\t\t\t     GFP_KERNEL | __GFP_ZERO);\n\tif (!temp_page)\n\t\treturn -ENOMEM;\n\n\tcap_info->pages = temp_page;\n\n\ttemp_page = krealloc(cap_info->phys,\n\t\t\t     pages_needed * sizeof(phys_addr_t *),\n\t\t\t     GFP_KERNEL | __GFP_ZERO);\n\tif (!temp_page)\n\t\treturn -ENOMEM;\n\n\tcap_info->phys = temp_page;\n\n\treturn 0;\n}\n\n \nint __weak efi_capsule_setup_info(struct capsule_info *cap_info, void *kbuff,\n\t\t\t\t  size_t hdr_bytes)\n{\n\t \n\tif (hdr_bytes < sizeof(efi_capsule_header_t))\n\t\treturn 0;\n\n\tmemcpy(&cap_info->header, kbuff, sizeof(cap_info->header));\n\tcap_info->total_size = cap_info->header.imagesize;\n\n\treturn __efi_capsule_setup_info(cap_info);\n}\n\n \nstatic ssize_t efi_capsule_submit_update(struct capsule_info *cap_info)\n{\n\tbool do_vunmap = false;\n\tint ret;\n\n\t \n\tif (!cap_info->capsule) {\n\t\tcap_info->capsule = vmap(cap_info->pages, cap_info->index,\n\t\t\t\t\t VM_MAP, PAGE_KERNEL);\n\t\tif (!cap_info->capsule)\n\t\t\treturn -ENOMEM;\n\t\tdo_vunmap = true;\n\t}\n\n\tret = efi_capsule_update(cap_info->capsule, cap_info->phys);\n\tif (do_vunmap)\n\t\tvunmap(cap_info->capsule);\n\tif (ret) {\n\t\tpr_err(\"capsule update failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tcap_info->index = NO_FURTHER_WRITE_ACTION;\n\n\tif (cap_info->header.flags & EFI_CAPSULE_PERSIST_ACROSS_RESET) {\n\t\tpr_info(\"Successfully uploaded capsule file with reboot type '%s'\\n\",\n\t\t\t!cap_info->reset_type ? \"RESET_COLD\" :\n\t\t\tcap_info->reset_type == 1 ? \"RESET_WARM\" :\n\t\t\t\"RESET_SHUTDOWN\");\n\t} else {\n\t\tpr_info(\"Successfully processed capsule file\\n\");\n\t}\n\n\treturn 0;\n}\n\n \nstatic ssize_t efi_capsule_write(struct file *file, const char __user *buff,\n\t\t\t\t size_t count, loff_t *offp)\n{\n\tint ret;\n\tstruct capsule_info *cap_info = file->private_data;\n\tstruct page *page;\n\tvoid *kbuff = NULL;\n\tsize_t write_byte;\n\n\tif (count == 0)\n\t\treturn 0;\n\n\t \n\tif (cap_info->index < 0)\n\t\treturn -EIO;\n\n\t \n\tif (!cap_info->page_bytes_remain) {\n\t\tpage = alloc_page(GFP_KERNEL);\n\t\tif (!page) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tcap_info->pages[cap_info->index] = page;\n\t\tcap_info->phys[cap_info->index] = page_to_phys(page);\n\t\tcap_info->page_bytes_remain = PAGE_SIZE;\n\t\tcap_info->index++;\n\t} else {\n\t\tpage = cap_info->pages[cap_info->index - 1];\n\t}\n\n\tkbuff = kmap(page);\n\tkbuff += PAGE_SIZE - cap_info->page_bytes_remain;\n\n\t \n\twrite_byte = min_t(size_t, count, cap_info->page_bytes_remain);\n\tif (copy_from_user(kbuff, buff, write_byte)) {\n\t\tret = -EFAULT;\n\t\tgoto fail_unmap;\n\t}\n\tcap_info->page_bytes_remain -= write_byte;\n\n\t \n\tif (cap_info->header.headersize == 0) {\n\t\tret = efi_capsule_setup_info(cap_info, kbuff - cap_info->count,\n\t\t\t\t\t     cap_info->count + write_byte);\n\t\tif (ret)\n\t\t\tgoto fail_unmap;\n\t}\n\n\tcap_info->count += write_byte;\n\tkunmap(page);\n\n\t \n\tif (cap_info->header.headersize > 0 &&\n\t    cap_info->count >= cap_info->total_size) {\n\t\tif (cap_info->count > cap_info->total_size) {\n\t\t\tpr_err(\"capsule upload size exceeded header defined size\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tret = efi_capsule_submit_update(cap_info);\n\t\tif (ret)\n\t\t\tgoto failed;\n\t}\n\n\treturn write_byte;\n\nfail_unmap:\n\tkunmap(page);\nfailed:\n\tefi_free_all_buff_pages(cap_info);\n\treturn ret;\n}\n\n \nstatic int efi_capsule_release(struct inode *inode, struct file *file)\n{\n\tstruct capsule_info *cap_info = file->private_data;\n\n\tif (cap_info->index > 0 &&\n\t    (cap_info->header.headersize == 0 ||\n\t     cap_info->count < cap_info->total_size)) {\n\t\tpr_err(\"capsule upload not complete\\n\");\n\t\tefi_free_all_buff_pages(cap_info);\n\t}\n\n\tkfree(cap_info->pages);\n\tkfree(cap_info->phys);\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\treturn 0;\n}\n\n \nstatic int efi_capsule_open(struct inode *inode, struct file *file)\n{\n\tstruct capsule_info *cap_info;\n\n\tcap_info = kzalloc(sizeof(*cap_info), GFP_KERNEL);\n\tif (!cap_info)\n\t\treturn -ENOMEM;\n\n\tcap_info->pages = kzalloc(sizeof(void *), GFP_KERNEL);\n\tif (!cap_info->pages) {\n\t\tkfree(cap_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tcap_info->phys = kzalloc(sizeof(void *), GFP_KERNEL);\n\tif (!cap_info->phys) {\n\t\tkfree(cap_info->pages);\n\t\tkfree(cap_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tfile->private_data = cap_info;\n\n\treturn 0;\n}\n\nstatic const struct file_operations efi_capsule_fops = {\n\t.owner = THIS_MODULE,\n\t.open = efi_capsule_open,\n\t.write = efi_capsule_write,\n\t.release = efi_capsule_release,\n\t.llseek = no_llseek,\n};\n\nstatic struct miscdevice efi_capsule_misc = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"efi_capsule_loader\",\n\t.fops = &efi_capsule_fops,\n};\n\nstatic int __init efi_capsule_loader_init(void)\n{\n\tint ret;\n\n\tif (!efi_enabled(EFI_RUNTIME_SERVICES))\n\t\treturn -ENODEV;\n\n\tret = misc_register(&efi_capsule_misc);\n\tif (ret)\n\t\tpr_err(\"Unable to register capsule loader device\\n\");\n\n\treturn ret;\n}\nmodule_init(efi_capsule_loader_init);\n\nstatic void __exit efi_capsule_loader_exit(void)\n{\n\tmisc_deregister(&efi_capsule_misc);\n}\nmodule_exit(efi_capsule_loader_exit);\n\nMODULE_DESCRIPTION(\"EFI capsule firmware binary loader\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}