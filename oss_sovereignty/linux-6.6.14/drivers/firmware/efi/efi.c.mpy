{
  "module_name": "efi.c",
  "hash_id": "1c2330f51ffd6dc8db233296403fe2c6321e6e298589c4c9c4f51761ecef2c1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/efi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/efi.h>\n#include <linux/of.h>\n#include <linux/initrd.h>\n#include <linux/io.h>\n#include <linux/kexec.h>\n#include <linux/platform_device.h>\n#include <linux/random.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <linux/ucs2_string.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n\n#include <asm/early_ioremap.h>\n\nstruct efi __read_mostly efi = {\n\t.runtime_supported_mask = EFI_RT_SUPPORTED_ALL,\n\t.acpi\t\t\t= EFI_INVALID_TABLE_ADDR,\n\t.acpi20\t\t\t= EFI_INVALID_TABLE_ADDR,\n\t.smbios\t\t\t= EFI_INVALID_TABLE_ADDR,\n\t.smbios3\t\t= EFI_INVALID_TABLE_ADDR,\n\t.esrt\t\t\t= EFI_INVALID_TABLE_ADDR,\n\t.tpm_log\t\t= EFI_INVALID_TABLE_ADDR,\n\t.tpm_final_log\t\t= EFI_INVALID_TABLE_ADDR,\n#ifdef CONFIG_LOAD_UEFI_KEYS\n\t.mokvar_table\t\t= EFI_INVALID_TABLE_ADDR,\n#endif\n#ifdef CONFIG_EFI_COCO_SECRET\n\t.coco_secret\t\t= EFI_INVALID_TABLE_ADDR,\n#endif\n#ifdef CONFIG_UNACCEPTED_MEMORY\n\t.unaccepted\t\t= EFI_INVALID_TABLE_ADDR,\n#endif\n};\nEXPORT_SYMBOL(efi);\n\nunsigned long __ro_after_init efi_rng_seed = EFI_INVALID_TABLE_ADDR;\nstatic unsigned long __initdata mem_reserve = EFI_INVALID_TABLE_ADDR;\nstatic unsigned long __initdata rt_prop = EFI_INVALID_TABLE_ADDR;\nstatic unsigned long __initdata initrd = EFI_INVALID_TABLE_ADDR;\n\nextern unsigned long screen_info_table;\n\nstruct mm_struct efi_mm = {\n\t.mm_mt\t\t\t= MTREE_INIT_EXT(mm_mt, MM_MT_FLAGS, efi_mm.mmap_lock),\n\t.mm_users\t\t= ATOMIC_INIT(2),\n\t.mm_count\t\t= ATOMIC_INIT(1),\n\t.write_protect_seq      = SEQCNT_ZERO(efi_mm.write_protect_seq),\n\tMMAP_LOCK_INITIALIZER(efi_mm)\n\t.page_table_lock\t= __SPIN_LOCK_UNLOCKED(efi_mm.page_table_lock),\n\t.mmlist\t\t\t= LIST_HEAD_INIT(efi_mm.mmlist),\n\t.cpu_bitmap\t\t= { [BITS_TO_LONGS(NR_CPUS)] = 0},\n};\n\nstruct workqueue_struct *efi_rts_wq;\n\nstatic bool disable_runtime = IS_ENABLED(CONFIG_EFI_DISABLE_RUNTIME);\nstatic int __init setup_noefi(char *arg)\n{\n\tdisable_runtime = true;\n\treturn 0;\n}\nearly_param(\"noefi\", setup_noefi);\n\nbool efi_runtime_disabled(void)\n{\n\treturn disable_runtime;\n}\n\nbool __pure __efi_soft_reserve_enabled(void)\n{\n\treturn !efi_enabled(EFI_MEM_NO_SOFT_RESERVE);\n}\n\nstatic int __init parse_efi_cmdline(char *str)\n{\n\tif (!str) {\n\t\tpr_warn(\"need at least one option\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (parse_option_str(str, \"debug\"))\n\t\tset_bit(EFI_DBG, &efi.flags);\n\n\tif (parse_option_str(str, \"noruntime\"))\n\t\tdisable_runtime = true;\n\n\tif (parse_option_str(str, \"runtime\"))\n\t\tdisable_runtime = false;\n\n\tif (parse_option_str(str, \"nosoftreserve\"))\n\t\tset_bit(EFI_MEM_NO_SOFT_RESERVE, &efi.flags);\n\n\treturn 0;\n}\nearly_param(\"efi\", parse_efi_cmdline);\n\nstruct kobject *efi_kobj;\n\n \nstatic ssize_t systab_show(struct kobject *kobj,\n\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\tchar *str = buf;\n\n\tif (!kobj || !buf)\n\t\treturn -EINVAL;\n\n\tif (efi.acpi20 != EFI_INVALID_TABLE_ADDR)\n\t\tstr += sprintf(str, \"ACPI20=0x%lx\\n\", efi.acpi20);\n\tif (efi.acpi != EFI_INVALID_TABLE_ADDR)\n\t\tstr += sprintf(str, \"ACPI=0x%lx\\n\", efi.acpi);\n\t \n\tif (efi.smbios3 != EFI_INVALID_TABLE_ADDR)\n\t\tstr += sprintf(str, \"SMBIOS3=0x%lx\\n\", efi.smbios3);\n\tif (efi.smbios != EFI_INVALID_TABLE_ADDR)\n\t\tstr += sprintf(str, \"SMBIOS=0x%lx\\n\", efi.smbios);\n\n\tif (IS_ENABLED(CONFIG_IA64) || IS_ENABLED(CONFIG_X86))\n\t\tstr = efi_systab_show_arch(str);\n\n\treturn str - buf;\n}\n\nstatic struct kobj_attribute efi_attr_systab = __ATTR_RO_MODE(systab, 0400);\n\nstatic ssize_t fw_platform_size_show(struct kobject *kobj,\n\t\t\t\t     struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", efi_enabled(EFI_64BIT) ? 64 : 32);\n}\n\nextern __weak struct kobj_attribute efi_attr_fw_vendor;\nextern __weak struct kobj_attribute efi_attr_runtime;\nextern __weak struct kobj_attribute efi_attr_config_table;\nstatic struct kobj_attribute efi_attr_fw_platform_size =\n\t__ATTR_RO(fw_platform_size);\n\nstatic struct attribute *efi_subsys_attrs[] = {\n\t&efi_attr_systab.attr,\n\t&efi_attr_fw_platform_size.attr,\n\t&efi_attr_fw_vendor.attr,\n\t&efi_attr_runtime.attr,\n\t&efi_attr_config_table.attr,\n\tNULL,\n};\n\numode_t __weak efi_attr_is_visible(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t   int n)\n{\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group efi_subsys_attr_group = {\n\t.attrs = efi_subsys_attrs,\n\t.is_visible = efi_attr_is_visible,\n};\n\nstatic struct efivars generic_efivars;\nstatic struct efivar_operations generic_ops;\n\nstatic bool generic_ops_supported(void)\n{\n\tunsigned long name_size;\n\tefi_status_t status;\n\tefi_char16_t name;\n\tefi_guid_t guid;\n\n\tname_size = sizeof(name);\n\n\tstatus = efi.get_next_variable(&name_size, &name, &guid);\n\tif (status == EFI_UNSUPPORTED)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int generic_ops_register(void)\n{\n\tif (!generic_ops_supported())\n\t\treturn 0;\n\n\tgeneric_ops.get_variable = efi.get_variable;\n\tgeneric_ops.get_next_variable = efi.get_next_variable;\n\tgeneric_ops.query_variable_store = efi_query_variable_store;\n\tgeneric_ops.query_variable_info = efi.query_variable_info;\n\n\tif (efi_rt_services_supported(EFI_RT_SUPPORTED_SET_VARIABLE)) {\n\t\tgeneric_ops.set_variable = efi.set_variable;\n\t\tgeneric_ops.set_variable_nonblocking = efi.set_variable_nonblocking;\n\t}\n\treturn efivars_register(&generic_efivars, &generic_ops);\n}\n\nstatic void generic_ops_unregister(void)\n{\n\tif (!generic_ops.get_variable)\n\t\treturn;\n\n\tefivars_unregister(&generic_efivars);\n}\n\n#ifdef CONFIG_EFI_CUSTOM_SSDT_OVERLAYS\n#define EFIVAR_SSDT_NAME_MAX\t16UL\nstatic char efivar_ssdt[EFIVAR_SSDT_NAME_MAX] __initdata;\nstatic int __init efivar_ssdt_setup(char *str)\n{\n\tint ret = security_locked_down(LOCKDOWN_ACPI_TABLES);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (strlen(str) < sizeof(efivar_ssdt))\n\t\tmemcpy(efivar_ssdt, str, strlen(str));\n\telse\n\t\tpr_warn(\"efivar_ssdt: name too long: %s\\n\", str);\n\treturn 1;\n}\n__setup(\"efivar_ssdt=\", efivar_ssdt_setup);\n\nstatic __init int efivar_ssdt_load(void)\n{\n\tunsigned long name_size = 256;\n\tefi_char16_t *name = NULL;\n\tefi_status_t status;\n\tefi_guid_t guid;\n\n\tif (!efivar_ssdt[0])\n\t\treturn 0;\n\n\tname = kzalloc(name_size, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tfor (;;) {\n\t\tchar utf8_name[EFIVAR_SSDT_NAME_MAX];\n\t\tunsigned long data_size = 0;\n\t\tvoid *data;\n\t\tint limit;\n\n\t\tstatus = efi.get_next_variable(&name_size, name, &guid);\n\t\tif (status == EFI_NOT_FOUND) {\n\t\t\tbreak;\n\t\t} else if (status == EFI_BUFFER_TOO_SMALL) {\n\t\t\tefi_char16_t *name_tmp =\n\t\t\t\tkrealloc(name, name_size, GFP_KERNEL);\n\t\t\tif (!name_tmp) {\n\t\t\t\tkfree(name);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tname = name_tmp;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlimit = min(EFIVAR_SSDT_NAME_MAX, name_size);\n\t\tucs2_as_utf8(utf8_name, name, limit - 1);\n\t\tif (strncmp(utf8_name, efivar_ssdt, limit) != 0)\n\t\t\tcontinue;\n\n\t\tpr_info(\"loading SSDT from variable %s-%pUl\\n\", efivar_ssdt, &guid);\n\n\t\tstatus = efi.get_variable(name, &guid, NULL, &data_size, NULL);\n\t\tif (status != EFI_BUFFER_TOO_SMALL || !data_size)\n\t\t\treturn -EIO;\n\n\t\tdata = kmalloc(data_size, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tstatus = efi.get_variable(name, &guid, NULL, &data_size, data);\n\t\tif (status == EFI_SUCCESS) {\n\t\t\tacpi_status ret = acpi_load_table(data, NULL);\n\t\t\tif (ret)\n\t\t\t\tpr_err(\"failed to load table: %u\\n\", ret);\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tpr_err(\"failed to get var data: 0x%lx\\n\", status);\n\t\t}\n\t\tkfree(data);\n\t}\n\treturn 0;\n}\n#else\nstatic inline int efivar_ssdt_load(void) { return 0; }\n#endif\n\n#ifdef CONFIG_DEBUG_FS\n\n#define EFI_DEBUGFS_MAX_BLOBS 32\n\nstatic struct debugfs_blob_wrapper debugfs_blob[EFI_DEBUGFS_MAX_BLOBS];\n\nstatic void __init efi_debugfs_init(void)\n{\n\tstruct dentry *efi_debugfs;\n\tefi_memory_desc_t *md;\n\tchar name[32];\n\tint type_count[EFI_BOOT_SERVICES_DATA + 1] = {};\n\tint i = 0;\n\n\tefi_debugfs = debugfs_create_dir(\"efi\", NULL);\n\tif (IS_ERR_OR_NULL(efi_debugfs))\n\t\treturn;\n\n\tfor_each_efi_memory_desc(md) {\n\t\tswitch (md->type) {\n\t\tcase EFI_BOOT_SERVICES_CODE:\n\t\t\tsnprintf(name, sizeof(name), \"boot_services_code%d\",\n\t\t\t\t type_count[md->type]++);\n\t\t\tbreak;\n\t\tcase EFI_BOOT_SERVICES_DATA:\n\t\t\tsnprintf(name, sizeof(name), \"boot_services_data%d\",\n\t\t\t\t type_count[md->type]++);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (i >= EFI_DEBUGFS_MAX_BLOBS) {\n\t\t\tpr_warn(\"More then %d EFI boot service segments, only showing first %d in debugfs\\n\",\n\t\t\t\tEFI_DEBUGFS_MAX_BLOBS, EFI_DEBUGFS_MAX_BLOBS);\n\t\t\tbreak;\n\t\t}\n\n\t\tdebugfs_blob[i].size = md->num_pages << EFI_PAGE_SHIFT;\n\t\tdebugfs_blob[i].data = memremap(md->phys_addr,\n\t\t\t\t\t\tdebugfs_blob[i].size,\n\t\t\t\t\t\tMEMREMAP_WB);\n\t\tif (!debugfs_blob[i].data)\n\t\t\tcontinue;\n\n\t\tdebugfs_create_blob(name, 0400, efi_debugfs, &debugfs_blob[i]);\n\t\ti++;\n\t}\n}\n#else\nstatic inline void efi_debugfs_init(void) {}\n#endif\n\n \nstatic int __init efisubsys_init(void)\n{\n\tint error;\n\n\tif (!efi_enabled(EFI_RUNTIME_SERVICES))\n\t\tefi.runtime_supported_mask = 0;\n\n\tif (!efi_enabled(EFI_BOOT))\n\t\treturn 0;\n\n\tif (efi.runtime_supported_mask) {\n\t\t \n\t\tefi_rts_wq = alloc_ordered_workqueue(\"efi_rts_wq\", 0);\n\t\tif (!efi_rts_wq) {\n\t\t\tpr_err(\"Creating efi_rts_wq failed, EFI runtime services disabled.\\n\");\n\t\t\tclear_bit(EFI_RUNTIME_SERVICES, &efi.flags);\n\t\t\tefi.runtime_supported_mask = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (efi_rt_services_supported(EFI_RT_SUPPORTED_TIME_SERVICES))\n\t\tplatform_device_register_simple(\"rtc-efi\", 0, NULL, 0);\n\n\t \n\tefi_kobj = kobject_create_and_add(\"efi\", firmware_kobj);\n\tif (!efi_kobj) {\n\t\tpr_err(\"efi: Firmware registration failed.\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_destroy_wq;\n\t}\n\n\tif (efi_rt_services_supported(EFI_RT_SUPPORTED_GET_VARIABLE |\n\t\t\t\t      EFI_RT_SUPPORTED_GET_NEXT_VARIABLE_NAME)) {\n\t\terror = generic_ops_register();\n\t\tif (error)\n\t\t\tgoto err_put;\n\t\tefivar_ssdt_load();\n\t\tplatform_device_register_simple(\"efivars\", 0, NULL, 0);\n\t}\n\n\terror = sysfs_create_group(efi_kobj, &efi_subsys_attr_group);\n\tif (error) {\n\t\tpr_err(\"efi: Sysfs attribute export failed with error %d.\\n\",\n\t\t       error);\n\t\tgoto err_unregister;\n\t}\n\n\t \n\terror = sysfs_create_mount_point(efi_kobj, \"efivars\");\n\tif (error) {\n\t\tpr_err(\"efivars: Subsystem registration failed.\\n\");\n\t\tgoto err_remove_group;\n\t}\n\n\tif (efi_enabled(EFI_DBG) && efi_enabled(EFI_PRESERVE_BS_REGIONS))\n\t\tefi_debugfs_init();\n\n#ifdef CONFIG_EFI_COCO_SECRET\n\tif (efi.coco_secret != EFI_INVALID_TABLE_ADDR)\n\t\tplatform_device_register_simple(\"efi_secret\", 0, NULL, 0);\n#endif\n\n\treturn 0;\n\nerr_remove_group:\n\tsysfs_remove_group(efi_kobj, &efi_subsys_attr_group);\nerr_unregister:\n\tif (efi_rt_services_supported(EFI_RT_SUPPORTED_GET_VARIABLE |\n\t\t\t\t      EFI_RT_SUPPORTED_GET_NEXT_VARIABLE_NAME))\n\t\tgeneric_ops_unregister();\nerr_put:\n\tkobject_put(efi_kobj);\n\tefi_kobj = NULL;\nerr_destroy_wq:\n\tif (efi_rts_wq)\n\t\tdestroy_workqueue(efi_rts_wq);\n\n\treturn error;\n}\n\nsubsys_initcall(efisubsys_init);\n\nvoid __init efi_find_mirror(void)\n{\n\tefi_memory_desc_t *md;\n\tu64 mirror_size = 0, total_size = 0;\n\n\tif (!efi_enabled(EFI_MEMMAP))\n\t\treturn;\n\n\tfor_each_efi_memory_desc(md) {\n\t\tunsigned long long start = md->phys_addr;\n\t\tunsigned long long size = md->num_pages << EFI_PAGE_SHIFT;\n\n\t\ttotal_size += size;\n\t\tif (md->attribute & EFI_MEMORY_MORE_RELIABLE) {\n\t\t\tmemblock_mark_mirror(start, size);\n\t\t\tmirror_size += size;\n\t\t}\n\t}\n\tif (mirror_size)\n\t\tpr_info(\"Memory: %lldM/%lldM mirrored memory\\n\",\n\t\t\tmirror_size>>20, total_size>>20);\n}\n\n \nint __efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md)\n{\n\tefi_memory_desc_t *md;\n\n\tif (!efi_enabled(EFI_MEMMAP)) {\n\t\tpr_err_once(\"EFI_MEMMAP is not enabled.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!out_md) {\n\t\tpr_err_once(\"out_md is null.\\n\");\n\t\treturn -EINVAL;\n        }\n\n\tfor_each_efi_memory_desc(md) {\n\t\tu64 size;\n\t\tu64 end;\n\n\t\t \n\t\tif ((md->phys_addr & (EFI_PAGE_SIZE - 1)) ||\n\t\t    (md->num_pages <= 0) ||\n\t\t    (md->num_pages > (U64_MAX - md->phys_addr) >> EFI_PAGE_SHIFT))\n\t\t\tcontinue;\n\n\t\tsize = md->num_pages << EFI_PAGE_SHIFT;\n\t\tend = md->phys_addr + size;\n\t\tif (phys_addr >= md->phys_addr && phys_addr < end) {\n\t\t\tmemcpy(out_md, md, sizeof(*out_md));\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n\nextern int efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md)\n\t__weak __alias(__efi_mem_desc_lookup);\n\n \nu64 __init efi_mem_desc_end(efi_memory_desc_t *md)\n{\n\tu64 size = md->num_pages << EFI_PAGE_SHIFT;\n\tu64 end = md->phys_addr + size;\n\treturn end;\n}\n\nvoid __init __weak efi_arch_mem_reserve(phys_addr_t addr, u64 size) {}\n\n \nvoid __init efi_mem_reserve(phys_addr_t addr, u64 size)\n{\n\t \n\tif (WARN_ON_ONCE(efi_enabled(EFI_PARAVIRT)))\n\t\treturn;\n\n\tif (!memblock_is_region_reserved(addr, size))\n\t\tmemblock_reserve(addr, size);\n\n\t \n\tefi_arch_mem_reserve(addr, size);\n}\n\nstatic const efi_config_table_type_t common_tables[] __initconst = {\n\t{ACPI_20_TABLE_GUID,\t\t\t&efi.acpi20,\t\t\"ACPI 2.0\"\t},\n\t{ACPI_TABLE_GUID,\t\t\t&efi.acpi,\t\t\"ACPI\"\t\t},\n\t{SMBIOS_TABLE_GUID,\t\t\t&efi.smbios,\t\t\"SMBIOS\"\t},\n\t{SMBIOS3_TABLE_GUID,\t\t\t&efi.smbios3,\t\t\"SMBIOS 3.0\"\t},\n\t{EFI_SYSTEM_RESOURCE_TABLE_GUID,\t&efi.esrt,\t\t\"ESRT\"\t\t},\n\t{EFI_MEMORY_ATTRIBUTES_TABLE_GUID,\t&efi_mem_attr_table,\t\"MEMATTR\"\t},\n\t{LINUX_EFI_RANDOM_SEED_TABLE_GUID,\t&efi_rng_seed,\t\t\"RNG\"\t\t},\n\t{LINUX_EFI_TPM_EVENT_LOG_GUID,\t\t&efi.tpm_log,\t\t\"TPMEventLog\"\t},\n\t{LINUX_EFI_TPM_FINAL_LOG_GUID,\t\t&efi.tpm_final_log,\t\"TPMFinalLog\"\t},\n\t{LINUX_EFI_MEMRESERVE_TABLE_GUID,\t&mem_reserve,\t\t\"MEMRESERVE\"\t},\n\t{LINUX_EFI_INITRD_MEDIA_GUID,\t\t&initrd,\t\t\"INITRD\"\t},\n\t{EFI_RT_PROPERTIES_TABLE_GUID,\t\t&rt_prop,\t\t\"RTPROP\"\t},\n#ifdef CONFIG_EFI_RCI2_TABLE\n\t{DELLEMC_EFI_RCI2_TABLE_GUID,\t\t&rci2_table_phys\t\t\t},\n#endif\n#ifdef CONFIG_LOAD_UEFI_KEYS\n\t{LINUX_EFI_MOK_VARIABLE_TABLE_GUID,\t&efi.mokvar_table,\t\"MOKvar\"\t},\n#endif\n#ifdef CONFIG_EFI_COCO_SECRET\n\t{LINUX_EFI_COCO_SECRET_AREA_GUID,\t&efi.coco_secret,\t\"CocoSecret\"\t},\n#endif\n#ifdef CONFIG_UNACCEPTED_MEMORY\n\t{LINUX_EFI_UNACCEPTED_MEM_TABLE_GUID,\t&efi.unaccepted,\t\"Unaccepted\"\t},\n#endif\n#ifdef CONFIG_EFI_GENERIC_STUB\n\t{LINUX_EFI_SCREEN_INFO_TABLE_GUID,\t&screen_info_table\t\t\t},\n#endif\n\t{},\n};\n\nstatic __init int match_config_table(const efi_guid_t *guid,\n\t\t\t\t     unsigned long table,\n\t\t\t\t     const efi_config_table_type_t *table_types)\n{\n\tint i;\n\n\tfor (i = 0; efi_guidcmp(table_types[i].guid, NULL_GUID); i++) {\n\t\tif (efi_guidcmp(*guid, table_types[i].guid))\n\t\t\tcontinue;\n\n\t\tif (!efi_config_table_is_usable(guid, table)) {\n\t\t\tif (table_types[i].name[0])\n\t\t\t\tpr_cont(\"(%s=0x%lx unusable) \",\n\t\t\t\t\ttable_types[i].name, table);\n\t\t\treturn 1;\n\t\t}\n\n\t\t*(table_types[i].ptr) = table;\n\t\tif (table_types[i].name[0])\n\t\t\tpr_cont(\"%s=0x%lx \", table_types[i].name, table);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic __init void reserve_unaccepted(struct efi_unaccepted_memory *unaccepted)\n{\n\tphys_addr_t start, size;\n\n\tstart = PAGE_ALIGN_DOWN(efi.unaccepted);\n\tsize = PAGE_ALIGN(sizeof(*unaccepted) + unaccepted->size);\n\n\tmemblock_add(start, size);\n\tmemblock_reserve(start, size);\n}\n\nint __init efi_config_parse_tables(const efi_config_table_t *config_tables,\n\t\t\t\t   int count,\n\t\t\t\t   const efi_config_table_type_t *arch_tables)\n{\n\tconst efi_config_table_64_t *tbl64 = (void *)config_tables;\n\tconst efi_config_table_32_t *tbl32 = (void *)config_tables;\n\tconst efi_guid_t *guid;\n\tunsigned long table;\n\tint i;\n\n\tpr_info(\"\");\n\tfor (i = 0; i < count; i++) {\n\t\tif (!IS_ENABLED(CONFIG_X86)) {\n\t\t\tguid = &config_tables[i].guid;\n\t\t\ttable = (unsigned long)config_tables[i].table;\n\t\t} else if (efi_enabled(EFI_64BIT)) {\n\t\t\tguid = &tbl64[i].guid;\n\t\t\ttable = tbl64[i].table;\n\n\t\t\tif (IS_ENABLED(CONFIG_X86_32) &&\n\t\t\t    tbl64[i].table > U32_MAX) {\n\t\t\t\tpr_cont(\"\\n\");\n\t\t\t\tpr_err(\"Table located above 4GB, disabling EFI.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tguid = &tbl32[i].guid;\n\t\t\ttable = tbl32[i].table;\n\t\t}\n\n\t\tif (!match_config_table(guid, table, common_tables) && arch_tables)\n\t\t\tmatch_config_table(guid, table, arch_tables);\n\t}\n\tpr_cont(\"\\n\");\n\tset_bit(EFI_CONFIG_TABLES, &efi.flags);\n\n\tif (efi_rng_seed != EFI_INVALID_TABLE_ADDR) {\n\t\tstruct linux_efi_random_seed *seed;\n\t\tu32 size = 0;\n\n\t\tseed = early_memremap(efi_rng_seed, sizeof(*seed));\n\t\tif (seed != NULL) {\n\t\t\tsize = min_t(u32, seed->size, SZ_1K); \n\t\t\tearly_memunmap(seed, sizeof(*seed));\n\t\t} else {\n\t\t\tpr_err(\"Could not map UEFI random seed!\\n\");\n\t\t}\n\t\tif (size > 0) {\n\t\t\tseed = early_memremap(efi_rng_seed,\n\t\t\t\t\t      sizeof(*seed) + size);\n\t\t\tif (seed != NULL) {\n\t\t\t\tadd_bootloader_randomness(seed->bits, size);\n\t\t\t\tmemzero_explicit(seed->bits, size);\n\t\t\t\tearly_memunmap(seed, sizeof(*seed) + size);\n\t\t\t} else {\n\t\t\t\tpr_err(\"Could not map UEFI random seed!\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!IS_ENABLED(CONFIG_X86_32) && efi_enabled(EFI_MEMMAP))\n\t\tefi_memattr_init();\n\n\tefi_tpm_eventlog_init();\n\n\tif (mem_reserve != EFI_INVALID_TABLE_ADDR) {\n\t\tunsigned long prsv = mem_reserve;\n\n\t\twhile (prsv) {\n\t\t\tstruct linux_efi_memreserve *rsv;\n\t\t\tu8 *p;\n\n\t\t\t \n\t\t\tp = early_memremap(ALIGN_DOWN(prsv, PAGE_SIZE),\n\t\t\t\t\t   PAGE_SIZE);\n\t\t\tif (p == NULL) {\n\t\t\t\tpr_err(\"Could not map UEFI memreserve entry!\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\trsv = (void *)(p + prsv % PAGE_SIZE);\n\n\t\t\t \n\t\t\tmemblock_reserve(prsv,\n\t\t\t\t\t struct_size(rsv, entry, rsv->size));\n\n\t\t\tfor (i = 0; i < atomic_read(&rsv->count); i++) {\n\t\t\t\tmemblock_reserve(rsv->entry[i].base,\n\t\t\t\t\t\t rsv->entry[i].size);\n\t\t\t}\n\n\t\t\tprsv = rsv->next;\n\t\t\tearly_memunmap(p, PAGE_SIZE);\n\t\t}\n\t}\n\n\tif (rt_prop != EFI_INVALID_TABLE_ADDR) {\n\t\tefi_rt_properties_table_t *tbl;\n\n\t\ttbl = early_memremap(rt_prop, sizeof(*tbl));\n\t\tif (tbl) {\n\t\t\tefi.runtime_supported_mask &= tbl->runtime_services_supported;\n\t\t\tearly_memunmap(tbl, sizeof(*tbl));\n\t\t}\n\t}\n\n\tif (IS_ENABLED(CONFIG_BLK_DEV_INITRD) &&\n\t    initrd != EFI_INVALID_TABLE_ADDR && phys_initrd_size == 0) {\n\t\tstruct linux_efi_initrd *tbl;\n\n\t\ttbl = early_memremap(initrd, sizeof(*tbl));\n\t\tif (tbl) {\n\t\t\tphys_initrd_start = tbl->base;\n\t\t\tphys_initrd_size = tbl->size;\n\t\t\tearly_memunmap(tbl, sizeof(*tbl));\n\t\t}\n\t}\n\n\tif (IS_ENABLED(CONFIG_UNACCEPTED_MEMORY) &&\n\t    efi.unaccepted != EFI_INVALID_TABLE_ADDR) {\n\t\tstruct efi_unaccepted_memory *unaccepted;\n\n\t\tunaccepted = early_memremap(efi.unaccepted, sizeof(*unaccepted));\n\t\tif (unaccepted) {\n\n\t\t\tif (unaccepted->version == 1) {\n\t\t\t\treserve_unaccepted(unaccepted);\n\t\t\t} else {\n\t\t\t\tefi.unaccepted = EFI_INVALID_TABLE_ADDR;\n\t\t\t}\n\n\t\t\tearly_memunmap(unaccepted, sizeof(*unaccepted));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint __init efi_systab_check_header(const efi_table_hdr_t *systab_hdr)\n{\n\tif (systab_hdr->signature != EFI_SYSTEM_TABLE_SIGNATURE) {\n\t\tpr_err(\"System table signature incorrect!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n#ifndef CONFIG_IA64\nstatic const efi_char16_t *__init map_fw_vendor(unsigned long fw_vendor,\n\t\t\t\t\t\tsize_t size)\n{\n\tconst efi_char16_t *ret;\n\n\tret = early_memremap_ro(fw_vendor, size);\n\tif (!ret)\n\t\tpr_err(\"Could not map the firmware vendor!\\n\");\n\treturn ret;\n}\n\nstatic void __init unmap_fw_vendor(const void *fw_vendor, size_t size)\n{\n\tearly_memunmap((void *)fw_vendor, size);\n}\n#else\n#define map_fw_vendor(p, s)\t__va(p)\n#define unmap_fw_vendor(v, s)\n#endif\n\nvoid __init efi_systab_report_header(const efi_table_hdr_t *systab_hdr,\n\t\t\t\t     unsigned long fw_vendor)\n{\n\tchar vendor[100] = \"unknown\";\n\tconst efi_char16_t *c16;\n\tsize_t i;\n\tu16 rev;\n\n\tc16 = map_fw_vendor(fw_vendor, sizeof(vendor) * sizeof(efi_char16_t));\n\tif (c16) {\n\t\tfor (i = 0; i < sizeof(vendor) - 1 && c16[i]; ++i)\n\t\t\tvendor[i] = c16[i];\n\t\tvendor[i] = '\\0';\n\n\t\tunmap_fw_vendor(c16, sizeof(vendor) * sizeof(efi_char16_t));\n\t}\n\n\trev = (u16)systab_hdr->revision;\n\tpr_info(\"EFI v%u.%u\", systab_hdr->revision >> 16, rev / 10);\n\n\trev %= 10;\n\tif (rev)\n\t\tpr_cont(\".%u\", rev);\n\n\tpr_cont(\" by %s\\n\", vendor);\n\n\tif (IS_ENABLED(CONFIG_X86_64) &&\n\t    systab_hdr->revision > EFI_1_10_SYSTEM_TABLE_REVISION &&\n\t    !strcmp(vendor, \"Apple\")) {\n\t\tpr_info(\"Apple Mac detected, using EFI v1.10 runtime services only\\n\");\n\t\tefi.runtime_version = EFI_1_10_SYSTEM_TABLE_REVISION;\n\t}\n}\n\nstatic __initdata char memory_type_name[][13] = {\n\t\"Reserved\",\n\t\"Loader Code\",\n\t\"Loader Data\",\n\t\"Boot Code\",\n\t\"Boot Data\",\n\t\"Runtime Code\",\n\t\"Runtime Data\",\n\t\"Conventional\",\n\t\"Unusable\",\n\t\"ACPI Reclaim\",\n\t\"ACPI Mem NVS\",\n\t\"MMIO\",\n\t\"MMIO Port\",\n\t\"PAL Code\",\n\t\"Persistent\",\n\t\"Unaccepted\",\n};\n\nchar * __init efi_md_typeattr_format(char *buf, size_t size,\n\t\t\t\t     const efi_memory_desc_t *md)\n{\n\tchar *pos;\n\tint type_len;\n\tu64 attr;\n\n\tpos = buf;\n\tif (md->type >= ARRAY_SIZE(memory_type_name))\n\t\ttype_len = snprintf(pos, size, \"[type=%u\", md->type);\n\telse\n\t\ttype_len = snprintf(pos, size, \"[%-*s\",\n\t\t\t\t    (int)(sizeof(memory_type_name[0]) - 1),\n\t\t\t\t    memory_type_name[md->type]);\n\tif (type_len >= size)\n\t\treturn buf;\n\n\tpos += type_len;\n\tsize -= type_len;\n\n\tattr = md->attribute;\n\tif (attr & ~(EFI_MEMORY_UC | EFI_MEMORY_WC | EFI_MEMORY_WT |\n\t\t     EFI_MEMORY_WB | EFI_MEMORY_UCE | EFI_MEMORY_RO |\n\t\t     EFI_MEMORY_WP | EFI_MEMORY_RP | EFI_MEMORY_XP |\n\t\t     EFI_MEMORY_NV | EFI_MEMORY_SP | EFI_MEMORY_CPU_CRYPTO |\n\t\t     EFI_MEMORY_RUNTIME | EFI_MEMORY_MORE_RELIABLE))\n\t\tsnprintf(pos, size, \"|attr=0x%016llx]\",\n\t\t\t (unsigned long long)attr);\n\telse\n\t\tsnprintf(pos, size,\n\t\t\t \"|%3s|%2s|%2s|%2s|%2s|%2s|%2s|%2s|%2s|%3s|%2s|%2s|%2s|%2s]\",\n\t\t\t attr & EFI_MEMORY_RUNTIME\t\t? \"RUN\" : \"\",\n\t\t\t attr & EFI_MEMORY_MORE_RELIABLE\t? \"MR\"  : \"\",\n\t\t\t attr & EFI_MEMORY_CPU_CRYPTO   \t? \"CC\"  : \"\",\n\t\t\t attr & EFI_MEMORY_SP\t\t\t? \"SP\"  : \"\",\n\t\t\t attr & EFI_MEMORY_NV\t\t\t? \"NV\"  : \"\",\n\t\t\t attr & EFI_MEMORY_XP\t\t\t? \"XP\"  : \"\",\n\t\t\t attr & EFI_MEMORY_RP\t\t\t? \"RP\"  : \"\",\n\t\t\t attr & EFI_MEMORY_WP\t\t\t? \"WP\"  : \"\",\n\t\t\t attr & EFI_MEMORY_RO\t\t\t? \"RO\"  : \"\",\n\t\t\t attr & EFI_MEMORY_UCE\t\t\t? \"UCE\" : \"\",\n\t\t\t attr & EFI_MEMORY_WB\t\t\t? \"WB\"  : \"\",\n\t\t\t attr & EFI_MEMORY_WT\t\t\t? \"WT\"  : \"\",\n\t\t\t attr & EFI_MEMORY_WC\t\t\t? \"WC\"  : \"\",\n\t\t\t attr & EFI_MEMORY_UC\t\t\t? \"UC\"  : \"\");\n\treturn buf;\n}\n\n \n#ifndef CONFIG_IA64\n \nu64 efi_mem_attributes(unsigned long phys_addr)\n{\n\tefi_memory_desc_t *md;\n\n\tif (!efi_enabled(EFI_MEMMAP))\n\t\treturn 0;\n\n\tfor_each_efi_memory_desc(md) {\n\t\tif ((md->phys_addr <= phys_addr) &&\n\t\t    (phys_addr < (md->phys_addr +\n\t\t    (md->num_pages << EFI_PAGE_SHIFT))))\n\t\t\treturn md->attribute;\n\t}\n\treturn 0;\n}\n\n \nint efi_mem_type(unsigned long phys_addr)\n{\n\tconst efi_memory_desc_t *md;\n\n\tif (!efi_enabled(EFI_MEMMAP))\n\t\treturn -ENOTSUPP;\n\n\tfor_each_efi_memory_desc(md) {\n\t\tif ((md->phys_addr <= phys_addr) &&\n\t\t    (phys_addr < (md->phys_addr +\n\t\t\t\t  (md->num_pages << EFI_PAGE_SHIFT))))\n\t\t\treturn md->type;\n\t}\n\treturn -EINVAL;\n}\n#endif\n\nint efi_status_to_err(efi_status_t status)\n{\n\tint err;\n\n\tswitch (status) {\n\tcase EFI_SUCCESS:\n\t\terr = 0;\n\t\tbreak;\n\tcase EFI_INVALID_PARAMETER:\n\t\terr = -EINVAL;\n\t\tbreak;\n\tcase EFI_OUT_OF_RESOURCES:\n\t\terr = -ENOSPC;\n\t\tbreak;\n\tcase EFI_DEVICE_ERROR:\n\t\terr = -EIO;\n\t\tbreak;\n\tcase EFI_WRITE_PROTECTED:\n\t\terr = -EROFS;\n\t\tbreak;\n\tcase EFI_SECURITY_VIOLATION:\n\t\terr = -EACCES;\n\t\tbreak;\n\tcase EFI_NOT_FOUND:\n\t\terr = -ENOENT;\n\t\tbreak;\n\tcase EFI_ABORTED:\n\t\terr = -EINTR;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(efi_status_to_err);\n\nstatic DEFINE_SPINLOCK(efi_mem_reserve_persistent_lock);\nstatic struct linux_efi_memreserve *efi_memreserve_root __ro_after_init;\n\nstatic int __init efi_memreserve_map_root(void)\n{\n\tif (mem_reserve == EFI_INVALID_TABLE_ADDR)\n\t\treturn -ENODEV;\n\n\tefi_memreserve_root = memremap(mem_reserve,\n\t\t\t\t       sizeof(*efi_memreserve_root),\n\t\t\t\t       MEMREMAP_WB);\n\tif (WARN_ON_ONCE(!efi_memreserve_root))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int efi_mem_reserve_iomem(phys_addr_t addr, u64 size)\n{\n\tstruct resource *res, *parent;\n\tint ret;\n\n\tres = kzalloc(sizeof(struct resource), GFP_ATOMIC);\n\tif (!res)\n\t\treturn -ENOMEM;\n\n\tres->name\t= \"reserved\";\n\tres->flags\t= IORESOURCE_MEM;\n\tres->start\t= addr;\n\tres->end\t= addr + size - 1;\n\n\t \n\tparent = request_resource_conflict(&iomem_resource, res);\n\tret = parent ? request_resource(parent, res) : 0;\n\n\t \n\tif (IS_ENABLED(CONFIG_ARCH_KEEP_MEMBLOCK) && !ret)\n\t\tmemblock_reserve(addr, size);\n\n\treturn ret;\n}\n\nint __ref efi_mem_reserve_persistent(phys_addr_t addr, u64 size)\n{\n\tstruct linux_efi_memreserve *rsv;\n\tunsigned long prsv;\n\tint rc, index;\n\n\tif (efi_memreserve_root == (void *)ULONG_MAX)\n\t\treturn -ENODEV;\n\n\tif (!efi_memreserve_root) {\n\t\trc = efi_memreserve_map_root();\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t \n\tfor (prsv = efi_memreserve_root->next; prsv; ) {\n\t\trsv = memremap(prsv, sizeof(*rsv), MEMREMAP_WB);\n\t\tif (!rsv)\n\t\t\treturn -ENOMEM;\n\t\tindex = atomic_fetch_add_unless(&rsv->count, 1, rsv->size);\n\t\tif (index < rsv->size) {\n\t\t\trsv->entry[index].base = addr;\n\t\t\trsv->entry[index].size = size;\n\n\t\t\tmemunmap(rsv);\n\t\t\treturn efi_mem_reserve_iomem(addr, size);\n\t\t}\n\t\tprsv = rsv->next;\n\t\tmemunmap(rsv);\n\t}\n\n\t \n\trsv = (struct linux_efi_memreserve *)__get_free_page(GFP_ATOMIC);\n\tif (!rsv)\n\t\treturn -ENOMEM;\n\n\trc = efi_mem_reserve_iomem(__pa(rsv), SZ_4K);\n\tif (rc) {\n\t\tfree_page((unsigned long)rsv);\n\t\treturn rc;\n\t}\n\n\t \n\trsv->size = EFI_MEMRESERVE_COUNT(SZ_4K);\n\tatomic_set(&rsv->count, 1);\n\trsv->entry[0].base = addr;\n\trsv->entry[0].size = size;\n\n\tspin_lock(&efi_mem_reserve_persistent_lock);\n\trsv->next = efi_memreserve_root->next;\n\tefi_memreserve_root->next = __pa(rsv);\n\tspin_unlock(&efi_mem_reserve_persistent_lock);\n\n\treturn efi_mem_reserve_iomem(addr, size);\n}\n\nstatic int __init efi_memreserve_root_init(void)\n{\n\tif (efi_memreserve_root)\n\t\treturn 0;\n\tif (efi_memreserve_map_root())\n\t\tefi_memreserve_root = (void *)ULONG_MAX;\n\treturn 0;\n}\nearly_initcall(efi_memreserve_root_init);\n\n#ifdef CONFIG_KEXEC\nstatic int update_efi_random_seed(struct notifier_block *nb,\n\t\t\t\t  unsigned long code, void *unused)\n{\n\tstruct linux_efi_random_seed *seed;\n\tu32 size = 0;\n\n\tif (!kexec_in_progress)\n\t\treturn NOTIFY_DONE;\n\n\tseed = memremap(efi_rng_seed, sizeof(*seed), MEMREMAP_WB);\n\tif (seed != NULL) {\n\t\tsize = min(seed->size, EFI_RANDOM_SEED_SIZE);\n\t\tmemunmap(seed);\n\t} else {\n\t\tpr_err(\"Could not map UEFI random seed!\\n\");\n\t}\n\tif (size > 0) {\n\t\tseed = memremap(efi_rng_seed, sizeof(*seed) + size,\n\t\t\t\tMEMREMAP_WB);\n\t\tif (seed != NULL) {\n\t\t\tseed->size = size;\n\t\t\tget_random_bytes(seed->bits, seed->size);\n\t\t\tmemunmap(seed);\n\t\t} else {\n\t\t\tpr_err(\"Could not map UEFI random seed!\\n\");\n\t\t}\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block efi_random_seed_nb = {\n\t.notifier_call = update_efi_random_seed,\n};\n\nstatic int __init register_update_efi_random_seed(void)\n{\n\tif (efi_rng_seed == EFI_INVALID_TABLE_ADDR)\n\t\treturn 0;\n\treturn register_reboot_notifier(&efi_random_seed_nb);\n}\nlate_initcall(register_update_efi_random_seed);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}