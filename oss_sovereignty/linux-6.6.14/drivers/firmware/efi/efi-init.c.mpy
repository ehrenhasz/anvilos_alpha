{
  "module_name": "efi-init.c",
  "hash_id": "472b82d3cc278d635d4700b7e5f13c96b81d97ee53e8082cb52c38fa19004592",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/efi/efi-init.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"efi: \" fmt\n\n#include <linux/efi.h>\n#include <linux/fwnode.h>\n#include <linux/init.h>\n#include <linux/memblock.h>\n#include <linux/mm_types.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_fdt.h>\n#include <linux/platform_device.h>\n#include <linux/screen_info.h>\n\n#include <asm/efi.h>\n\nunsigned long __initdata screen_info_table = EFI_INVALID_TABLE_ADDR;\n\nstatic int __init is_memory(efi_memory_desc_t *md)\n{\n\tif (md->attribute & (EFI_MEMORY_WB|EFI_MEMORY_WT|EFI_MEMORY_WC))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic phys_addr_t __init efi_to_phys(unsigned long addr)\n{\n\tefi_memory_desc_t *md;\n\n\tfor_each_efi_memory_desc(md) {\n\t\tif (!(md->attribute & EFI_MEMORY_RUNTIME))\n\t\t\tcontinue;\n\t\tif (md->virt_addr == 0)\n\t\t\t \n\t\t\tbreak;\n\t\tif (md->virt_addr <= addr &&\n\t\t    (addr - md->virt_addr) < (md->num_pages << EFI_PAGE_SHIFT))\n\t\t\treturn md->phys_addr + addr - md->virt_addr;\n\t}\n\treturn addr;\n}\n\nextern __weak const efi_config_table_type_t efi_arch_tables[];\n\nstatic void __init init_screen_info(void)\n{\n\tstruct screen_info *si;\n\n\tif (screen_info_table != EFI_INVALID_TABLE_ADDR) {\n\t\tsi = early_memremap(screen_info_table, sizeof(*si));\n\t\tif (!si) {\n\t\t\tpr_err(\"Could not map screen_info config table\\n\");\n\t\t\treturn;\n\t\t}\n\t\tscreen_info = *si;\n\t\tmemset(si, 0, sizeof(*si));\n\t\tearly_memunmap(si, sizeof(*si));\n\n\t\tif (memblock_is_map_memory(screen_info.lfb_base))\n\t\t\tmemblock_mark_nomap(screen_info.lfb_base,\n\t\t\t\t\t    screen_info.lfb_size);\n\n\t\tif (IS_ENABLED(CONFIG_EFI_EARLYCON))\n\t\t\tefi_earlycon_reprobe();\n\t}\n}\n\nstatic int __init uefi_init(u64 efi_system_table)\n{\n\tefi_config_table_t *config_tables;\n\tefi_system_table_t *systab;\n\tsize_t table_size;\n\tint retval;\n\n\tsystab = early_memremap_ro(efi_system_table, sizeof(efi_system_table_t));\n\tif (systab == NULL) {\n\t\tpr_warn(\"Unable to map EFI system table.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tset_bit(EFI_BOOT, &efi.flags);\n\tif (IS_ENABLED(CONFIG_64BIT))\n\t\tset_bit(EFI_64BIT, &efi.flags);\n\n\tretval = efi_systab_check_header(&systab->hdr);\n\tif (retval)\n\t\tgoto out;\n\n\tefi.runtime = systab->runtime;\n\tefi.runtime_version = systab->hdr.revision;\n\n\tefi_systab_report_header(&systab->hdr, efi_to_phys(systab->fw_vendor));\n\n\ttable_size = sizeof(efi_config_table_t) * systab->nr_tables;\n\tconfig_tables = early_memremap_ro(efi_to_phys(systab->tables),\n\t\t\t\t\t  table_size);\n\tif (config_tables == NULL) {\n\t\tpr_warn(\"Unable to map EFI config table array.\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto out;\n\t}\n\tretval = efi_config_parse_tables(config_tables, systab->nr_tables,\n\t\t\t\t\t efi_arch_tables);\n\n\tearly_memunmap(config_tables, table_size);\nout:\n\tearly_memunmap(systab, sizeof(efi_system_table_t));\n\treturn retval;\n}\n\n \nstatic __init int is_usable_memory(efi_memory_desc_t *md)\n{\n\tswitch (md->type) {\n\tcase EFI_LOADER_CODE:\n\tcase EFI_LOADER_DATA:\n\tcase EFI_ACPI_RECLAIM_MEMORY:\n\tcase EFI_BOOT_SERVICES_CODE:\n\tcase EFI_BOOT_SERVICES_DATA:\n\tcase EFI_CONVENTIONAL_MEMORY:\n\tcase EFI_PERSISTENT_MEMORY:\n\t\t \n\t\tif (efi_soft_reserve_enabled() &&\n\t\t    (md->attribute & EFI_MEMORY_SP))\n\t\t\treturn false;\n\n\t\t \n\t\treturn (md->attribute & EFI_MEMORY_WB);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nstatic __init void reserve_regions(void)\n{\n\tefi_memory_desc_t *md;\n\tu64 paddr, npages, size;\n\n\tif (efi_enabled(EFI_DBG))\n\t\tpr_info(\"Processing EFI memory map:\\n\");\n\n\t \n\tmemblock_dump_all();\n\tmemblock_remove(0, PHYS_ADDR_MAX);\n\n\tfor_each_efi_memory_desc(md) {\n\t\tpaddr = md->phys_addr;\n\t\tnpages = md->num_pages;\n\n\t\tif (efi_enabled(EFI_DBG)) {\n\t\t\tchar buf[64];\n\n\t\t\tpr_info(\"  0x%012llx-0x%012llx %s\\n\",\n\t\t\t\tpaddr, paddr + (npages << EFI_PAGE_SHIFT) - 1,\n\t\t\t\tefi_md_typeattr_format(buf, sizeof(buf), md));\n\t\t}\n\n\t\tmemrange_efi_to_native(&paddr, &npages);\n\t\tsize = npages << PAGE_SHIFT;\n\n\t\tif (is_memory(md)) {\n\t\t\tearly_init_dt_add_memory_arch(paddr, size);\n\n\t\t\tif (!is_usable_memory(md))\n\t\t\t\tmemblock_mark_nomap(paddr, size);\n\n\t\t\t \n\t\t\tif (md->type == EFI_ACPI_RECLAIM_MEMORY)\n\t\t\t\tmemblock_reserve(paddr, size);\n\t\t}\n\t}\n}\n\nvoid __init efi_init(void)\n{\n\tstruct efi_memory_map_data data;\n\tu64 efi_system_table;\n\n\t \n\tefi_system_table = efi_get_fdt_params(&data);\n\tif (!efi_system_table)\n\t\treturn;\n\n\tif (efi_memmap_init_early(&data) < 0) {\n\t\t \n\t\tpanic(\"Unable to map EFI memory map.\\n\");\n\t}\n\n\tWARN(efi.memmap.desc_version != 1,\n\t     \"Unexpected EFI_MEMORY_DESCRIPTOR version %ld\",\n\t      efi.memmap.desc_version);\n\n\tif (uefi_init(efi_system_table) < 0) {\n\t\tefi_memmap_unmap();\n\t\treturn;\n\t}\n\n\treserve_regions();\n\t \n\tearly_init_dt_check_for_usable_mem_range();\n\tefi_find_mirror();\n\tefi_esrt_init();\n\tefi_mokvar_table_init();\n\n\tmemblock_reserve(data.phys_map & PAGE_MASK,\n\t\t\t PAGE_ALIGN(data.size + (data.phys_map & ~PAGE_MASK)));\n\n\tinit_screen_info();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}