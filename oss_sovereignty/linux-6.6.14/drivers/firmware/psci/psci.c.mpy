{
  "module_name": "psci.c",
  "hash_id": "dd51e12d46429aa45750d2a36867f86e88a1ee9510e01dd713a2f3a593808620",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/psci/psci.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"psci: \" fmt\n\n#include <linux/acpi.h>\n#include <linux/arm-smccc.h>\n#include <linux/cpuidle.h>\n#include <linux/debugfs.h>\n#include <linux/errno.h>\n#include <linux/linkage.h>\n#include <linux/of.h>\n#include <linux/pm.h>\n#include <linux/printk.h>\n#include <linux/psci.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n\n#include <uapi/linux/psci.h>\n\n#include <asm/cpuidle.h>\n#include <asm/cputype.h>\n#include <asm/hypervisor.h>\n#include <asm/system_misc.h>\n#include <asm/smp_plat.h>\n#include <asm/suspend.h>\n\n \n#ifdef CONFIG_64BIT\n#define PSCI_FN_NATIVE(version, name)\tPSCI_##version##_FN64_##name\n#else\n#define PSCI_FN_NATIVE(version, name)\tPSCI_##version##_FN_##name\n#endif\n\n \nstatic int resident_cpu = -1;\nstruct psci_operations psci_ops;\nstatic enum arm_smccc_conduit psci_conduit = SMCCC_CONDUIT_NONE;\n\nbool psci_tos_resident_on(int cpu)\n{\n\treturn cpu == resident_cpu;\n}\n\ntypedef unsigned long (psci_fn)(unsigned long, unsigned long,\n\t\t\t\tunsigned long, unsigned long);\nstatic psci_fn *invoke_psci_fn;\n\nstatic struct psci_0_1_function_ids psci_0_1_function_ids;\n\nstruct psci_0_1_function_ids get_psci_0_1_function_ids(void)\n{\n\treturn psci_0_1_function_ids;\n}\n\n#define PSCI_0_2_POWER_STATE_MASK\t\t\\\n\t\t\t\t(PSCI_0_2_POWER_STATE_ID_MASK | \\\n\t\t\t\tPSCI_0_2_POWER_STATE_TYPE_MASK | \\\n\t\t\t\tPSCI_0_2_POWER_STATE_AFFL_MASK)\n\n#define PSCI_1_0_EXT_POWER_STATE_MASK\t\t\\\n\t\t\t\t(PSCI_1_0_EXT_POWER_STATE_ID_MASK | \\\n\t\t\t\tPSCI_1_0_EXT_POWER_STATE_TYPE_MASK)\n\nstatic u32 psci_cpu_suspend_feature;\nstatic bool psci_system_reset2_supported;\n\nstatic inline bool psci_has_ext_power_state(void)\n{\n\treturn psci_cpu_suspend_feature &\n\t\t\t\tPSCI_1_0_FEATURES_CPU_SUSPEND_PF_MASK;\n}\n\nbool psci_has_osi_support(void)\n{\n\treturn psci_cpu_suspend_feature & PSCI_1_0_OS_INITIATED;\n}\n\nstatic inline bool psci_power_state_loses_context(u32 state)\n{\n\tconst u32 mask = psci_has_ext_power_state() ?\n\t\t\t\t\tPSCI_1_0_EXT_POWER_STATE_TYPE_MASK :\n\t\t\t\t\tPSCI_0_2_POWER_STATE_TYPE_MASK;\n\n\treturn state & mask;\n}\n\nbool psci_power_state_is_valid(u32 state)\n{\n\tconst u32 valid_mask = psci_has_ext_power_state() ?\n\t\t\t       PSCI_1_0_EXT_POWER_STATE_MASK :\n\t\t\t       PSCI_0_2_POWER_STATE_MASK;\n\n\treturn !(state & ~valid_mask);\n}\n\nstatic __always_inline unsigned long\n__invoke_psci_fn_hvc(unsigned long function_id,\n\t\t     unsigned long arg0, unsigned long arg1,\n\t\t     unsigned long arg2)\n{\n\tstruct arm_smccc_res res;\n\n\tarm_smccc_hvc(function_id, arg0, arg1, arg2, 0, 0, 0, 0, &res);\n\treturn res.a0;\n}\n\nstatic __always_inline unsigned long\n__invoke_psci_fn_smc(unsigned long function_id,\n\t\t     unsigned long arg0, unsigned long arg1,\n\t\t     unsigned long arg2)\n{\n\tstruct arm_smccc_res res;\n\n\tarm_smccc_smc(function_id, arg0, arg1, arg2, 0, 0, 0, 0, &res);\n\treturn res.a0;\n}\n\nstatic __always_inline int psci_to_linux_errno(int errno)\n{\n\tswitch (errno) {\n\tcase PSCI_RET_SUCCESS:\n\t\treturn 0;\n\tcase PSCI_RET_NOT_SUPPORTED:\n\t\treturn -EOPNOTSUPP;\n\tcase PSCI_RET_INVALID_PARAMS:\n\tcase PSCI_RET_INVALID_ADDRESS:\n\t\treturn -EINVAL;\n\tcase PSCI_RET_DENIED:\n\t\treturn -EPERM;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic u32 psci_0_1_get_version(void)\n{\n\treturn PSCI_VERSION(0, 1);\n}\n\nstatic u32 psci_0_2_get_version(void)\n{\n\treturn invoke_psci_fn(PSCI_0_2_FN_PSCI_VERSION, 0, 0, 0);\n}\n\nint psci_set_osi_mode(bool enable)\n{\n\tunsigned long suspend_mode;\n\tint err;\n\n\tsuspend_mode = enable ? PSCI_1_0_SUSPEND_MODE_OSI :\n\t\t\tPSCI_1_0_SUSPEND_MODE_PC;\n\n\terr = invoke_psci_fn(PSCI_1_0_FN_SET_SUSPEND_MODE, suspend_mode, 0, 0);\n\tif (err < 0)\n\t\tpr_info(FW_BUG \"failed to set %s mode: %d\\n\",\n\t\t\t\tenable ? \"OSI\" : \"PC\", err);\n\treturn psci_to_linux_errno(err);\n}\n\nstatic __always_inline int\n__psci_cpu_suspend(u32 fn, u32 state, unsigned long entry_point)\n{\n\tint err;\n\n\terr = invoke_psci_fn(fn, state, entry_point, 0);\n\treturn psci_to_linux_errno(err);\n}\n\nstatic __always_inline int\npsci_0_1_cpu_suspend(u32 state, unsigned long entry_point)\n{\n\treturn __psci_cpu_suspend(psci_0_1_function_ids.cpu_suspend,\n\t\t\t\t  state, entry_point);\n}\n\nstatic __always_inline int\npsci_0_2_cpu_suspend(u32 state, unsigned long entry_point)\n{\n\treturn __psci_cpu_suspend(PSCI_FN_NATIVE(0_2, CPU_SUSPEND),\n\t\t\t\t  state, entry_point);\n}\n\nstatic int __psci_cpu_off(u32 fn, u32 state)\n{\n\tint err;\n\n\terr = invoke_psci_fn(fn, state, 0, 0);\n\treturn psci_to_linux_errno(err);\n}\n\nstatic int psci_0_1_cpu_off(u32 state)\n{\n\treturn __psci_cpu_off(psci_0_1_function_ids.cpu_off, state);\n}\n\nstatic int psci_0_2_cpu_off(u32 state)\n{\n\treturn __psci_cpu_off(PSCI_0_2_FN_CPU_OFF, state);\n}\n\nstatic int __psci_cpu_on(u32 fn, unsigned long cpuid, unsigned long entry_point)\n{\n\tint err;\n\n\terr = invoke_psci_fn(fn, cpuid, entry_point, 0);\n\treturn psci_to_linux_errno(err);\n}\n\nstatic int psci_0_1_cpu_on(unsigned long cpuid, unsigned long entry_point)\n{\n\treturn __psci_cpu_on(psci_0_1_function_ids.cpu_on, cpuid, entry_point);\n}\n\nstatic int psci_0_2_cpu_on(unsigned long cpuid, unsigned long entry_point)\n{\n\treturn __psci_cpu_on(PSCI_FN_NATIVE(0_2, CPU_ON), cpuid, entry_point);\n}\n\nstatic int __psci_migrate(u32 fn, unsigned long cpuid)\n{\n\tint err;\n\n\terr = invoke_psci_fn(fn, cpuid, 0, 0);\n\treturn psci_to_linux_errno(err);\n}\n\nstatic int psci_0_1_migrate(unsigned long cpuid)\n{\n\treturn __psci_migrate(psci_0_1_function_ids.migrate, cpuid);\n}\n\nstatic int psci_0_2_migrate(unsigned long cpuid)\n{\n\treturn __psci_migrate(PSCI_FN_NATIVE(0_2, MIGRATE), cpuid);\n}\n\nstatic int psci_affinity_info(unsigned long target_affinity,\n\t\tunsigned long lowest_affinity_level)\n{\n\treturn invoke_psci_fn(PSCI_FN_NATIVE(0_2, AFFINITY_INFO),\n\t\t\t      target_affinity, lowest_affinity_level, 0);\n}\n\nstatic int psci_migrate_info_type(void)\n{\n\treturn invoke_psci_fn(PSCI_0_2_FN_MIGRATE_INFO_TYPE, 0, 0, 0);\n}\n\nstatic unsigned long psci_migrate_info_up_cpu(void)\n{\n\treturn invoke_psci_fn(PSCI_FN_NATIVE(0_2, MIGRATE_INFO_UP_CPU),\n\t\t\t      0, 0, 0);\n}\n\nstatic void set_conduit(enum arm_smccc_conduit conduit)\n{\n\tswitch (conduit) {\n\tcase SMCCC_CONDUIT_HVC:\n\t\tinvoke_psci_fn = __invoke_psci_fn_hvc;\n\t\tbreak;\n\tcase SMCCC_CONDUIT_SMC:\n\t\tinvoke_psci_fn = __invoke_psci_fn_smc;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Unexpected PSCI conduit %d\\n\", conduit);\n\t}\n\n\tpsci_conduit = conduit;\n}\n\nstatic int get_set_conduit_method(const struct device_node *np)\n{\n\tconst char *method;\n\n\tpr_info(\"probing for conduit method from DT.\\n\");\n\n\tif (of_property_read_string(np, \"method\", &method)) {\n\t\tpr_warn(\"missing \\\"method\\\" property\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (!strcmp(\"hvc\", method)) {\n\t\tset_conduit(SMCCC_CONDUIT_HVC);\n\t} else if (!strcmp(\"smc\", method)) {\n\t\tset_conduit(SMCCC_CONDUIT_SMC);\n\t} else {\n\t\tpr_warn(\"invalid \\\"method\\\" property: %s\\n\", method);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int psci_sys_reset(struct notifier_block *nb, unsigned long action,\n\t\t\t  void *data)\n{\n\tif ((reboot_mode == REBOOT_WARM || reboot_mode == REBOOT_SOFT) &&\n\t    psci_system_reset2_supported) {\n\t\t \n\t\tinvoke_psci_fn(PSCI_FN_NATIVE(1_1, SYSTEM_RESET2), 0, 0, 0);\n\t} else {\n\t\tinvoke_psci_fn(PSCI_0_2_FN_SYSTEM_RESET, 0, 0, 0);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block psci_sys_reset_nb = {\n\t.notifier_call = psci_sys_reset,\n\t.priority = 129,\n};\n\nstatic void psci_sys_poweroff(void)\n{\n\tinvoke_psci_fn(PSCI_0_2_FN_SYSTEM_OFF, 0, 0, 0);\n}\n\nstatic int psci_features(u32 psci_func_id)\n{\n\treturn invoke_psci_fn(PSCI_1_0_FN_PSCI_FEATURES,\n\t\t\t      psci_func_id, 0, 0);\n}\n\n#ifdef CONFIG_DEBUG_FS\n\n#define PSCI_ID(ver, _name) \\\n\t{ .fn = PSCI_##ver##_FN_##_name, .name = #_name, }\n#define PSCI_ID_NATIVE(ver, _name) \\\n\t{ .fn = PSCI_FN_NATIVE(ver, _name), .name = #_name, }\n\n \nstatic const struct {\n\tu32 fn;\n\tconst char *name;\n} psci_fn_ids[] = {\n\tPSCI_ID_NATIVE(0_2, MIGRATE),\n\tPSCI_ID(0_2, MIGRATE_INFO_TYPE),\n\tPSCI_ID_NATIVE(0_2, MIGRATE_INFO_UP_CPU),\n\tPSCI_ID(1_0, CPU_FREEZE),\n\tPSCI_ID_NATIVE(1_0, CPU_DEFAULT_SUSPEND),\n\tPSCI_ID_NATIVE(1_0, NODE_HW_STATE),\n\tPSCI_ID_NATIVE(1_0, SYSTEM_SUSPEND),\n\tPSCI_ID(1_0, SET_SUSPEND_MODE),\n\tPSCI_ID_NATIVE(1_0, STAT_RESIDENCY),\n\tPSCI_ID_NATIVE(1_0, STAT_COUNT),\n\tPSCI_ID_NATIVE(1_1, SYSTEM_RESET2),\n\tPSCI_ID(1_1, MEM_PROTECT),\n\tPSCI_ID_NATIVE(1_1, MEM_PROTECT_CHECK_RANGE),\n};\n\nstatic int psci_debugfs_read(struct seq_file *s, void *data)\n{\n\tint feature, type, i;\n\tu32 ver;\n\n\tver = psci_ops.get_version();\n\tseq_printf(s, \"PSCIv%d.%d\\n\",\n\t\t   PSCI_VERSION_MAJOR(ver),\n\t\t   PSCI_VERSION_MINOR(ver));\n\n\t \n\tif (PSCI_VERSION_MAJOR(ver) < 1)\n\t\treturn 0;\n\n\tfeature = psci_features(ARM_SMCCC_VERSION_FUNC_ID);\n\tif (feature != PSCI_RET_NOT_SUPPORTED) {\n\t\tver = invoke_psci_fn(ARM_SMCCC_VERSION_FUNC_ID, 0, 0, 0);\n\t\tseq_printf(s, \"SMC Calling Convention v%d.%d\\n\",\n\t\t\t   PSCI_VERSION_MAJOR(ver),\n\t\t\t   PSCI_VERSION_MINOR(ver));\n\t} else {\n\t\tseq_puts(s, \"SMC Calling Convention v1.0 is assumed\\n\");\n\t}\n\n\tfeature = psci_features(PSCI_FN_NATIVE(0_2, CPU_SUSPEND));\n\tif (feature < 0) {\n\t\tseq_printf(s, \"PSCI_FEATURES(CPU_SUSPEND) error (%d)\\n\", feature);\n\t} else {\n\t\tseq_printf(s, \"OSI is %ssupported\\n\",\n\t\t\t   (feature & BIT(0)) ? \"\" : \"not \");\n\t\tseq_printf(s, \"%s StateID format is used\\n\",\n\t\t\t   (feature & BIT(1)) ? \"Extended\" : \"Original\");\n\t}\n\n\ttype = psci_ops.migrate_info_type();\n\tif (type == PSCI_0_2_TOS_UP_MIGRATE ||\n\t    type == PSCI_0_2_TOS_UP_NO_MIGRATE) {\n\t\tunsigned long cpuid;\n\n\t\tseq_printf(s, \"Trusted OS %smigrate capable\\n\",\n\t\t\t   type == PSCI_0_2_TOS_UP_NO_MIGRATE ? \"not \" : \"\");\n\t\tcpuid = psci_migrate_info_up_cpu();\n\t\tseq_printf(s, \"Trusted OS resident on physical CPU 0x%lx (#%d)\\n\",\n\t\t\t   cpuid, resident_cpu);\n\t} else if (type == PSCI_0_2_TOS_MP) {\n\t\tseq_puts(s, \"Trusted OS migration not required\\n\");\n\t} else {\n\t\tif (type != PSCI_RET_NOT_SUPPORTED)\n\t\t\tseq_printf(s, \"MIGRATE_INFO_TYPE returned unknown type (%d)\\n\", type);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(psci_fn_ids); i++) {\n\t\tfeature = psci_features(psci_fn_ids[i].fn);\n\t\tif (feature == PSCI_RET_NOT_SUPPORTED)\n\t\t\tcontinue;\n\t\tif (feature < 0)\n\t\t\tseq_printf(s, \"PSCI_FEATURES(%s) error (%d)\\n\",\n\t\t\t\t   psci_fn_ids[i].name, feature);\n\t\telse\n\t\t\tseq_printf(s, \"%s is supported\\n\", psci_fn_ids[i].name);\n\t}\n\n\treturn 0;\n}\n\nstatic int psci_debugfs_open(struct inode *inode, struct file *f)\n{\n\treturn single_open(f, psci_debugfs_read, NULL);\n}\n\nstatic const struct file_operations psci_debugfs_ops = {\n\t.owner = THIS_MODULE,\n\t.open = psci_debugfs_open,\n\t.release = single_release,\n\t.read = seq_read,\n\t.llseek = seq_lseek\n};\n\nstatic int __init psci_debugfs_init(void)\n{\n\tif (!invoke_psci_fn || !psci_ops.get_version)\n\t\treturn 0;\n\n\treturn PTR_ERR_OR_ZERO(debugfs_create_file(\"psci\", 0444, NULL, NULL,\n\t\t\t\t\t\t   &psci_debugfs_ops));\n}\nlate_initcall(psci_debugfs_init)\n#endif\n\n#ifdef CONFIG_CPU_IDLE\nstatic noinstr int psci_suspend_finisher(unsigned long state)\n{\n\tu32 power_state = state;\n\tphys_addr_t pa_cpu_resume;\n\n\tpa_cpu_resume = __pa_symbol_nodebug((unsigned long)cpu_resume);\n\n\treturn psci_ops.cpu_suspend(power_state, pa_cpu_resume);\n}\n\nint psci_cpu_suspend_enter(u32 state)\n{\n\tint ret;\n\n\tif (!psci_power_state_loses_context(state)) {\n\t\tstruct arm_cpuidle_irq_context context;\n\n\t\tct_cpuidle_enter();\n\t\tarm_cpuidle_save_irq_context(&context);\n\t\tret = psci_ops.cpu_suspend(state, 0);\n\t\tarm_cpuidle_restore_irq_context(&context);\n\t\tct_cpuidle_exit();\n\t} else {\n\t\t \n\t\tif (!IS_ENABLED(CONFIG_ARM64))\n\t\t\tct_cpuidle_enter();\n\n\t\tret = cpu_suspend(state, psci_suspend_finisher);\n\n\t\tif (!IS_ENABLED(CONFIG_ARM64))\n\t\t\tct_cpuidle_exit();\n\t}\n\n\treturn ret;\n}\n#endif\n\nstatic int psci_system_suspend(unsigned long unused)\n{\n\tphys_addr_t pa_cpu_resume = __pa_symbol(cpu_resume);\n\n\treturn invoke_psci_fn(PSCI_FN_NATIVE(1_0, SYSTEM_SUSPEND),\n\t\t\t      pa_cpu_resume, 0, 0);\n}\n\nstatic int psci_system_suspend_enter(suspend_state_t state)\n{\n\treturn cpu_suspend(0, psci_system_suspend);\n}\n\nstatic const struct platform_suspend_ops psci_suspend_ops = {\n\t.valid          = suspend_valid_only_mem,\n\t.enter          = psci_system_suspend_enter,\n};\n\nstatic void __init psci_init_system_reset2(void)\n{\n\tint ret;\n\n\tret = psci_features(PSCI_FN_NATIVE(1_1, SYSTEM_RESET2));\n\n\tif (ret != PSCI_RET_NOT_SUPPORTED)\n\t\tpsci_system_reset2_supported = true;\n}\n\nstatic void __init psci_init_system_suspend(void)\n{\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_SUSPEND))\n\t\treturn;\n\n\tret = psci_features(PSCI_FN_NATIVE(1_0, SYSTEM_SUSPEND));\n\n\tif (ret != PSCI_RET_NOT_SUPPORTED)\n\t\tsuspend_set_ops(&psci_suspend_ops);\n}\n\nstatic void __init psci_init_cpu_suspend(void)\n{\n\tint feature = psci_features(PSCI_FN_NATIVE(0_2, CPU_SUSPEND));\n\n\tif (feature != PSCI_RET_NOT_SUPPORTED)\n\t\tpsci_cpu_suspend_feature = feature;\n}\n\n \nstatic void __init psci_init_migrate(void)\n{\n\tunsigned long cpuid;\n\tint type, cpu = -1;\n\n\ttype = psci_ops.migrate_info_type();\n\n\tif (type == PSCI_0_2_TOS_MP) {\n\t\tpr_info(\"Trusted OS migration not required\\n\");\n\t\treturn;\n\t}\n\n\tif (type == PSCI_RET_NOT_SUPPORTED) {\n\t\tpr_info(\"MIGRATE_INFO_TYPE not supported.\\n\");\n\t\treturn;\n\t}\n\n\tif (type != PSCI_0_2_TOS_UP_MIGRATE &&\n\t    type != PSCI_0_2_TOS_UP_NO_MIGRATE) {\n\t\tpr_err(\"MIGRATE_INFO_TYPE returned unknown type (%d)\\n\", type);\n\t\treturn;\n\t}\n\n\tcpuid = psci_migrate_info_up_cpu();\n\tif (cpuid & ~MPIDR_HWID_BITMASK) {\n\t\tpr_warn(\"MIGRATE_INFO_UP_CPU reported invalid physical ID (0x%lx)\\n\",\n\t\t\tcpuid);\n\t\treturn;\n\t}\n\n\tcpu = get_logical_index(cpuid);\n\tresident_cpu = cpu >= 0 ? cpu : -1;\n\n\tpr_info(\"Trusted OS resident on physical CPU 0x%lx\\n\", cpuid);\n}\n\nstatic void __init psci_init_smccc(void)\n{\n\tu32 ver = ARM_SMCCC_VERSION_1_0;\n\tint feature;\n\n\tfeature = psci_features(ARM_SMCCC_VERSION_FUNC_ID);\n\n\tif (feature != PSCI_RET_NOT_SUPPORTED) {\n\t\tu32 ret;\n\t\tret = invoke_psci_fn(ARM_SMCCC_VERSION_FUNC_ID, 0, 0, 0);\n\t\tif (ret >= ARM_SMCCC_VERSION_1_1) {\n\t\t\tarm_smccc_version_init(ret, psci_conduit);\n\t\t\tver = ret;\n\t\t}\n\t}\n\n\t \n\tpr_info(\"SMC Calling Convention v%d.%d\\n\",\n\t\tPSCI_VERSION_MAJOR(ver), PSCI_VERSION_MINOR(ver));\n\n}\n\nstatic void __init psci_0_2_set_functions(void)\n{\n\tpr_info(\"Using standard PSCI v0.2 function IDs\\n\");\n\n\tpsci_ops = (struct psci_operations){\n\t\t.get_version = psci_0_2_get_version,\n\t\t.cpu_suspend = psci_0_2_cpu_suspend,\n\t\t.cpu_off = psci_0_2_cpu_off,\n\t\t.cpu_on = psci_0_2_cpu_on,\n\t\t.migrate = psci_0_2_migrate,\n\t\t.affinity_info = psci_affinity_info,\n\t\t.migrate_info_type = psci_migrate_info_type,\n\t};\n\n\tregister_restart_handler(&psci_sys_reset_nb);\n\n\tpm_power_off = psci_sys_poweroff;\n}\n\n \nstatic int __init psci_probe(void)\n{\n\tu32 ver = psci_0_2_get_version();\n\n\tpr_info(\"PSCIv%d.%d detected in firmware.\\n\",\n\t\t\tPSCI_VERSION_MAJOR(ver),\n\t\t\tPSCI_VERSION_MINOR(ver));\n\n\tif (PSCI_VERSION_MAJOR(ver) == 0 && PSCI_VERSION_MINOR(ver) < 2) {\n\t\tpr_err(\"Conflicting PSCI version detected.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpsci_0_2_set_functions();\n\n\tpsci_init_migrate();\n\n\tif (PSCI_VERSION_MAJOR(ver) >= 1) {\n\t\tpsci_init_smccc();\n\t\tpsci_init_cpu_suspend();\n\t\tpsci_init_system_suspend();\n\t\tpsci_init_system_reset2();\n\t\tkvm_init_hyp_services();\n\t}\n\n\treturn 0;\n}\n\ntypedef int (*psci_initcall_t)(const struct device_node *);\n\n \nstatic int __init psci_0_2_init(const struct device_node *np)\n{\n\tint err;\n\n\terr = get_set_conduit_method(np);\n\tif (err)\n\t\treturn err;\n\n\t \n\treturn psci_probe();\n}\n\n \nstatic int __init psci_0_1_init(const struct device_node *np)\n{\n\tu32 id;\n\tint err;\n\n\terr = get_set_conduit_method(np);\n\tif (err)\n\t\treturn err;\n\n\tpr_info(\"Using PSCI v0.1 Function IDs from DT\\n\");\n\n\tpsci_ops.get_version = psci_0_1_get_version;\n\n\tif (!of_property_read_u32(np, \"cpu_suspend\", &id)) {\n\t\tpsci_0_1_function_ids.cpu_suspend = id;\n\t\tpsci_ops.cpu_suspend = psci_0_1_cpu_suspend;\n\t}\n\n\tif (!of_property_read_u32(np, \"cpu_off\", &id)) {\n\t\tpsci_0_1_function_ids.cpu_off = id;\n\t\tpsci_ops.cpu_off = psci_0_1_cpu_off;\n\t}\n\n\tif (!of_property_read_u32(np, \"cpu_on\", &id)) {\n\t\tpsci_0_1_function_ids.cpu_on = id;\n\t\tpsci_ops.cpu_on = psci_0_1_cpu_on;\n\t}\n\n\tif (!of_property_read_u32(np, \"migrate\", &id)) {\n\t\tpsci_0_1_function_ids.migrate = id;\n\t\tpsci_ops.migrate = psci_0_1_migrate;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init psci_1_0_init(const struct device_node *np)\n{\n\tint err;\n\n\terr = psci_0_2_init(np);\n\tif (err)\n\t\treturn err;\n\n\tif (psci_has_osi_support()) {\n\t\tpr_info(\"OSI mode supported.\\n\");\n\n\t\t \n\t\tpsci_set_osi_mode(false);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id psci_of_match[] __initconst = {\n\t{ .compatible = \"arm,psci\",\t.data = psci_0_1_init},\n\t{ .compatible = \"arm,psci-0.2\",\t.data = psci_0_2_init},\n\t{ .compatible = \"arm,psci-1.0\",\t.data = psci_1_0_init},\n\t{},\n};\n\nint __init psci_dt_init(void)\n{\n\tstruct device_node *np;\n\tconst struct of_device_id *matched_np;\n\tpsci_initcall_t init_fn;\n\tint ret;\n\n\tnp = of_find_matching_node_and_match(NULL, psci_of_match, &matched_np);\n\n\tif (!np || !of_device_is_available(np))\n\t\treturn -ENODEV;\n\n\tinit_fn = (psci_initcall_t)matched_np->data;\n\tret = init_fn(np);\n\n\tof_node_put(np);\n\treturn ret;\n}\n\n#ifdef CONFIG_ACPI\n \nint __init psci_acpi_init(void)\n{\n\tif (!acpi_psci_present()) {\n\t\tpr_info(\"is not implemented in ACPI.\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpr_info(\"probing for conduit method from ACPI.\\n\");\n\n\tif (acpi_psci_use_hvc())\n\t\tset_conduit(SMCCC_CONDUIT_HVC);\n\telse\n\t\tset_conduit(SMCCC_CONDUIT_SMC);\n\n\treturn psci_probe();\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}