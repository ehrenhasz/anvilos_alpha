{
  "module_name": "psci_checker.c",
  "hash_id": "d07f98baf97212af4d8791e7d247e45adec326b0b159937583385c46cc1f180d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/psci/psci_checker.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/atomic.h>\n#include <linux/completion.h>\n#include <linux/cpu.h>\n#include <linux/cpuidle.h>\n#include <linux/cpu_pm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/psci.h>\n#include <linux/slab.h>\n#include <linux/tick.h>\n#include <linux/topology.h>\n\n#include <asm/cpuidle.h>\n\n#include <uapi/linux/psci.h>\n\n#define NUM_SUSPEND_CYCLE (10)\n\nstatic unsigned int nb_available_cpus;\nstatic int tos_resident_cpu = -1;\n\nstatic atomic_t nb_active_threads;\nstatic struct completion suspend_threads_started =\n\tCOMPLETION_INITIALIZER(suspend_threads_started);\nstatic struct completion suspend_threads_done =\n\tCOMPLETION_INITIALIZER(suspend_threads_done);\n\n \nstatic int psci_ops_check(void)\n{\n\tint migrate_type = -1;\n\tint cpu;\n\n\tif (!(psci_ops.cpu_off && psci_ops.cpu_on && psci_ops.cpu_suspend)) {\n\t\tpr_warn(\"Missing PSCI operations, aborting tests\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (psci_ops.migrate_info_type)\n\t\tmigrate_type = psci_ops.migrate_info_type();\n\n\tif (migrate_type == PSCI_0_2_TOS_UP_MIGRATE ||\n\t    migrate_type == PSCI_0_2_TOS_UP_NO_MIGRATE) {\n\t\t \n\t\tfor_each_online_cpu(cpu)\n\t\t\tif (psci_tos_resident_on(cpu)) {\n\t\t\t\ttos_resident_cpu = cpu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (tos_resident_cpu == -1)\n\t\t\tpr_warn(\"UP Trusted OS resides on no online CPU\\n\");\n\t}\n\n\treturn 0;\n}\n\n \nstatic unsigned int down_and_up_cpus(const struct cpumask *cpus,\n\t\t\t\t     struct cpumask *offlined_cpus)\n{\n\tint cpu;\n\tint err = 0;\n\n\tcpumask_clear(offlined_cpus);\n\n\t \n\tfor_each_cpu(cpu, cpus) {\n\t\tint ret = remove_cpu(cpu);\n\n\t\t \n\t\tif (cpumask_weight(offlined_cpus) + 1 == nb_available_cpus) {\n\t\t\tif (ret != -EBUSY) {\n\t\t\t\tpr_err(\"Unexpected return code %d while trying \"\n\t\t\t\t       \"to power down last online CPU %d\\n\",\n\t\t\t\t       ret, cpu);\n\t\t\t\t++err;\n\t\t\t}\n\t\t} else if (cpu == tos_resident_cpu) {\n\t\t\tif (ret != -EPERM) {\n\t\t\t\tpr_err(\"Unexpected return code %d while trying \"\n\t\t\t\t       \"to power down TOS resident CPU %d\\n\",\n\t\t\t\t       ret, cpu);\n\t\t\t\t++err;\n\t\t\t}\n\t\t} else if (ret != 0) {\n\t\t\tpr_err(\"Error occurred (%d) while trying \"\n\t\t\t       \"to power down CPU %d\\n\", ret, cpu);\n\t\t\t++err;\n\t\t}\n\n\t\tif (ret == 0)\n\t\t\tcpumask_set_cpu(cpu, offlined_cpus);\n\t}\n\n\t \n\tfor_each_cpu(cpu, offlined_cpus) {\n\t\tint ret = add_cpu(cpu);\n\n\t\tif (ret != 0) {\n\t\t\tpr_err(\"Error occurred (%d) while trying \"\n\t\t\t       \"to power up CPU %d\\n\", ret, cpu);\n\t\t\t++err;\n\t\t} else {\n\t\t\tcpumask_clear_cpu(cpu, offlined_cpus);\n\t\t}\n\t}\n\n\t \n\tWARN_ON(!cpumask_empty(offlined_cpus) ||\n\t\tnum_online_cpus() != nb_available_cpus);\n\n\treturn err;\n}\n\nstatic void free_cpu_groups(int num, cpumask_var_t **pcpu_groups)\n{\n\tint i;\n\tcpumask_var_t *cpu_groups = *pcpu_groups;\n\n\tfor (i = 0; i < num; ++i)\n\t\tfree_cpumask_var(cpu_groups[i]);\n\tkfree(cpu_groups);\n}\n\nstatic int alloc_init_cpu_groups(cpumask_var_t **pcpu_groups)\n{\n\tint num_groups = 0;\n\tcpumask_var_t tmp, *cpu_groups;\n\n\tif (!alloc_cpumask_var(&tmp, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tcpu_groups = kcalloc(nb_available_cpus, sizeof(*cpu_groups),\n\t\t\t     GFP_KERNEL);\n\tif (!cpu_groups) {\n\t\tfree_cpumask_var(tmp);\n\t\treturn -ENOMEM;\n\t}\n\n\tcpumask_copy(tmp, cpu_online_mask);\n\n\twhile (!cpumask_empty(tmp)) {\n\t\tconst struct cpumask *cpu_group =\n\t\t\ttopology_core_cpumask(cpumask_any(tmp));\n\n\t\tif (!alloc_cpumask_var(&cpu_groups[num_groups], GFP_KERNEL)) {\n\t\t\tfree_cpumask_var(tmp);\n\t\t\tfree_cpu_groups(num_groups, &cpu_groups);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tcpumask_copy(cpu_groups[num_groups++], cpu_group);\n\t\tcpumask_andnot(tmp, tmp, cpu_group);\n\t}\n\n\tfree_cpumask_var(tmp);\n\t*pcpu_groups = cpu_groups;\n\n\treturn num_groups;\n}\n\nstatic int hotplug_tests(void)\n{\n\tint i, nb_cpu_group, err = -ENOMEM;\n\tcpumask_var_t offlined_cpus, *cpu_groups;\n\tchar *page_buf;\n\n\tif (!alloc_cpumask_var(&offlined_cpus, GFP_KERNEL))\n\t\treturn err;\n\n\tnb_cpu_group = alloc_init_cpu_groups(&cpu_groups);\n\tif (nb_cpu_group < 0)\n\t\tgoto out_free_cpus;\n\tpage_buf = (char *)__get_free_page(GFP_KERNEL);\n\tif (!page_buf)\n\t\tgoto out_free_cpu_groups;\n\n\t \n\tpr_info(\"Trying to turn off and on again all CPUs\\n\");\n\terr = down_and_up_cpus(cpu_online_mask, offlined_cpus);\n\n\t \n\tfor (i = 0; i < nb_cpu_group; ++i) {\n\t\tssize_t len = cpumap_print_to_pagebuf(true, page_buf,\n\t\t\t\t\t\t      cpu_groups[i]);\n\t\t \n\t\tpage_buf[len - 1] = '\\0';\n\t\tpr_info(\"Trying to turn off and on again group %d (CPUs %s)\\n\",\n\t\t\ti, page_buf);\n\t\terr += down_and_up_cpus(cpu_groups[i], offlined_cpus);\n\t}\n\n\tfree_page((unsigned long)page_buf);\nout_free_cpu_groups:\n\tfree_cpu_groups(nb_cpu_group, &cpu_groups);\nout_free_cpus:\n\tfree_cpumask_var(offlined_cpus);\n\treturn err;\n}\n\nstatic void dummy_callback(struct timer_list *unused) {}\n\nstatic int suspend_cpu(struct cpuidle_device *dev,\n\t\t       struct cpuidle_driver *drv, int index)\n{\n\tstruct cpuidle_state *state = &drv->states[index];\n\tbool broadcast = state->flags & CPUIDLE_FLAG_TIMER_STOP;\n\tint ret;\n\n\tarch_cpu_idle_enter();\n\n\tif (broadcast) {\n\t\t \n\t\tret = tick_broadcast_enter();\n\t\tif (ret) {\n\t\t\t \n\t\t\tcpu_do_idle();\n\t\t\tret = 0;\n\t\t\tgoto out_arch_exit;\n\t\t}\n\t}\n\n\tret = state->enter(dev, drv, index);\n\n\tif (broadcast)\n\t\ttick_broadcast_exit();\n\nout_arch_exit:\n\tarch_cpu_idle_exit();\n\n\treturn ret;\n}\n\nstatic int suspend_test_thread(void *arg)\n{\n\tint cpu = (long)arg;\n\tint i, nb_suspend = 0, nb_shallow_sleep = 0, nb_err = 0;\n\tstruct cpuidle_device *dev;\n\tstruct cpuidle_driver *drv;\n\t \n\tstruct timer_list wakeup_timer;\n\n\t \n\twait_for_completion(&suspend_threads_started);\n\n\t \n\tsched_set_fifo(current);\n\n\tdev = this_cpu_read(cpuidle_devices);\n\tdrv = cpuidle_get_cpu_driver(dev);\n\n\tpr_info(\"CPU %d entering suspend cycles, states 1 through %d\\n\",\n\t\tcpu, drv->state_count - 1);\n\n\ttimer_setup_on_stack(&wakeup_timer, dummy_callback, 0);\n\tfor (i = 0; i < NUM_SUSPEND_CYCLE; ++i) {\n\t\tint index;\n\t\t \n\t\tfor (index = 1; index < drv->state_count; ++index) {\n\t\t\tint ret;\n\t\t\tstruct cpuidle_state *state = &drv->states[index];\n\n\t\t\t \n\t\t\tmod_timer(&wakeup_timer, jiffies +\n\t\t\t\t  usecs_to_jiffies(state->target_residency));\n\n\t\t\t \n\t\t\tlocal_irq_disable();\n\n\t\t\tret = suspend_cpu(dev, drv, index);\n\n\t\t\t \n\t\t\tlocal_irq_enable();\n\n\t\t\tif (ret == index) {\n\t\t\t\t++nb_suspend;\n\t\t\t} else if (ret >= 0) {\n\t\t\t\t \n\t\t\t\t++nb_shallow_sleep;\n\t\t\t} else {\n\t\t\t\tpr_err(\"Failed to suspend CPU %d: error %d \"\n\t\t\t\t       \"(requested state %d, cycle %d)\\n\",\n\t\t\t\t       cpu, ret, index, i);\n\t\t\t\t++nb_err;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tdel_timer(&wakeup_timer);\n\tdestroy_timer_on_stack(&wakeup_timer);\n\n\tif (atomic_dec_return_relaxed(&nb_active_threads) == 0)\n\t\tcomplete(&suspend_threads_done);\n\n\tfor (;;) {\n\t\t \n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (kthread_should_park())\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\n\tpr_info(\"CPU %d suspend test results: success %d, shallow states %d, errors %d\\n\",\n\t\tcpu, nb_suspend, nb_shallow_sleep, nb_err);\n\n\tkthread_parkme();\n\n\treturn nb_err;\n}\n\nstatic int suspend_tests(void)\n{\n\tint i, cpu, err = 0;\n\tstruct task_struct **threads;\n\tint nb_threads = 0;\n\n\tthreads = kmalloc_array(nb_available_cpus, sizeof(*threads),\n\t\t\t\tGFP_KERNEL);\n\tif (!threads)\n\t\treturn -ENOMEM;\n\n\t \n\tcpuidle_pause_and_lock();\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct task_struct *thread;\n\t\t \n\t\tstruct cpuidle_device *dev = per_cpu(cpuidle_devices, cpu);\n\t\tstruct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev);\n\n\t\tif (!dev || !drv) {\n\t\t\tpr_warn(\"cpuidle not available on CPU %d, ignoring\\n\",\n\t\t\t\tcpu);\n\t\t\tcontinue;\n\t\t}\n\n\t\tthread = kthread_create_on_cpu(suspend_test_thread,\n\t\t\t\t\t       (void *)(long)cpu, cpu,\n\t\t\t\t\t       \"psci_suspend_test\");\n\t\tif (IS_ERR(thread))\n\t\t\tpr_err(\"Failed to create kthread on CPU %d\\n\", cpu);\n\t\telse\n\t\t\tthreads[nb_threads++] = thread;\n\t}\n\n\tif (nb_threads < 1) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tatomic_set(&nb_active_threads, nb_threads);\n\n\t \n\tfor (i = 0; i < nb_threads; ++i)\n\t\twake_up_process(threads[i]);\n\tcomplete_all(&suspend_threads_started);\n\n\twait_for_completion(&suspend_threads_done);\n\n\n\t \n\tfor (i = 0; i < nb_threads; ++i) {\n\t\terr += kthread_park(threads[i]);\n\t\terr += kthread_stop(threads[i]);\n\t}\n out:\n\tcpuidle_resume_and_unlock();\n\tkfree(threads);\n\treturn err;\n}\n\nstatic int __init psci_checker(void)\n{\n\tint ret;\n\n\t \n\tnb_available_cpus = num_online_cpus();\n\n\t \n\tret = psci_ops_check();\n\tif (ret)\n\t\treturn ret;\n\n\tpr_info(\"PSCI checker started using %u CPUs\\n\", nb_available_cpus);\n\n\tpr_info(\"Starting hotplug tests\\n\");\n\tret = hotplug_tests();\n\tif (ret == 0)\n\t\tpr_info(\"Hotplug tests passed OK\\n\");\n\telse if (ret > 0)\n\t\tpr_err(\"%d error(s) encountered in hotplug tests\\n\", ret);\n\telse {\n\t\tpr_err(\"Out of memory\\n\");\n\t\treturn ret;\n\t}\n\n\tpr_info(\"Starting suspend tests (%d cycles per state)\\n\",\n\t\tNUM_SUSPEND_CYCLE);\n\tret = suspend_tests();\n\tif (ret == 0)\n\t\tpr_info(\"Suspend tests passed OK\\n\");\n\telse if (ret > 0)\n\t\tpr_err(\"%d error(s) encountered in suspend tests\\n\", ret);\n\telse {\n\t\tswitch (ret) {\n\t\tcase -ENOMEM:\n\t\t\tpr_err(\"Out of memory\\n\");\n\t\t\tbreak;\n\t\tcase -ENODEV:\n\t\t\tpr_warn(\"Could not start suspend tests on any CPU\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpr_info(\"PSCI checker completed\\n\");\n\treturn ret < 0 ? ret : 0;\n}\nlate_initcall(psci_checker);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}