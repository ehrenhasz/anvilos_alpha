{
  "module_name": "qcom_scm-smc.c",
  "hash_id": "06f069ed1bb1541b4da918f2faa25717637917d211761c48b22abd5d8e28c211",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/qcom_scm-smc.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/firmware/qcom/qcom_scm.h>\n#include <linux/arm-smccc.h>\n#include <linux/dma-mapping.h>\n\n#include \"qcom_scm.h\"\n\n \nstruct arm_smccc_args {\n\tunsigned long args[8];\n};\n\nstatic DEFINE_MUTEX(qcom_scm_lock);\n\n#define QCOM_SCM_EBUSY_WAIT_MS 30\n#define QCOM_SCM_EBUSY_MAX_RETRY 20\n\n#define SCM_SMC_N_REG_ARGS\t4\n#define SCM_SMC_FIRST_EXT_IDX\t(SCM_SMC_N_REG_ARGS - 1)\n#define SCM_SMC_N_EXT_ARGS\t(MAX_QCOM_SCM_ARGS - SCM_SMC_N_REG_ARGS + 1)\n#define SCM_SMC_FIRST_REG_IDX\t2\n#define SCM_SMC_LAST_REG_IDX\t(SCM_SMC_FIRST_REG_IDX + SCM_SMC_N_REG_ARGS - 1)\n\nstatic void __scm_smc_do_quirk(const struct arm_smccc_args *smc,\n\t\t\t       struct arm_smccc_res *res)\n{\n\tunsigned long a0 = smc->args[0];\n\tstruct arm_smccc_quirk quirk = { .id = ARM_SMCCC_QUIRK_QCOM_A6 };\n\n\tquirk.state.a6 = 0;\n\n\tdo {\n\t\tarm_smccc_smc_quirk(a0, smc->args[1], smc->args[2],\n\t\t\t\t    smc->args[3], smc->args[4], smc->args[5],\n\t\t\t\t    quirk.state.a6, smc->args[7], res, &quirk);\n\n\t\tif (res->a0 == QCOM_SCM_INTERRUPTED)\n\t\t\ta0 = res->a0;\n\n\t} while (res->a0 == QCOM_SCM_INTERRUPTED);\n}\n\nstatic void fill_wq_resume_args(struct arm_smccc_args *resume, u32 smc_call_ctx)\n{\n\tmemset(resume->args, 0, sizeof(resume->args[0]) * ARRAY_SIZE(resume->args));\n\n\tresume->args[0] = ARM_SMCCC_CALL_VAL(ARM_SMCCC_STD_CALL,\n\t\t\t\t\tARM_SMCCC_SMC_64, ARM_SMCCC_OWNER_SIP,\n\t\t\t\t\tSCM_SMC_FNID(QCOM_SCM_SVC_WAITQ, QCOM_SCM_WAITQ_RESUME));\n\n\tresume->args[1] = QCOM_SCM_ARGS(1);\n\n\tresume->args[2] = smc_call_ctx;\n}\n\nint scm_get_wq_ctx(u32 *wq_ctx, u32 *flags, u32 *more_pending)\n{\n\tint ret;\n\tstruct arm_smccc_res get_wq_res;\n\tstruct arm_smccc_args get_wq_ctx = {0};\n\n\tget_wq_ctx.args[0] = ARM_SMCCC_CALL_VAL(ARM_SMCCC_STD_CALL,\n\t\t\t\tARM_SMCCC_SMC_64, ARM_SMCCC_OWNER_SIP,\n\t\t\t\tSCM_SMC_FNID(QCOM_SCM_SVC_WAITQ, QCOM_SCM_WAITQ_GET_WQ_CTX));\n\n\t \n\t__scm_smc_do_quirk(&get_wq_ctx, &get_wq_res);\n\tret = get_wq_res.a0;\n\tif (ret)\n\t\treturn ret;\n\n\t*wq_ctx = get_wq_res.a1;\n\t*flags  = get_wq_res.a2;\n\t*more_pending = get_wq_res.a3;\n\n\treturn 0;\n}\n\nstatic int __scm_smc_do_quirk_handle_waitq(struct device *dev, struct arm_smccc_args *waitq,\n\t\t\t\t\t   struct arm_smccc_res *res)\n{\n\tint ret;\n\tu32 wq_ctx, smc_call_ctx;\n\tstruct arm_smccc_args resume;\n\tstruct arm_smccc_args *smc = waitq;\n\n\tdo {\n\t\t__scm_smc_do_quirk(smc, res);\n\n\t\tif (res->a0 == QCOM_SCM_WAITQ_SLEEP) {\n\t\t\twq_ctx = res->a1;\n\t\t\tsmc_call_ctx = res->a2;\n\n\t\t\tret = qcom_scm_wait_for_wq_completion(wq_ctx);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tfill_wq_resume_args(&resume, smc_call_ctx);\n\t\t\tsmc = &resume;\n\t\t}\n\t} while (res->a0 == QCOM_SCM_WAITQ_SLEEP);\n\n\treturn 0;\n}\n\nstatic int __scm_smc_do(struct device *dev, struct arm_smccc_args *smc,\n\t\t\tstruct arm_smccc_res *res, bool atomic)\n{\n\tint ret, retry_count = 0;\n\n\tif (atomic) {\n\t\t__scm_smc_do_quirk(smc, res);\n\t\treturn 0;\n\t}\n\n\tdo {\n\t\tmutex_lock(&qcom_scm_lock);\n\n\t\tret = __scm_smc_do_quirk_handle_waitq(dev, smc, res);\n\n\t\tmutex_unlock(&qcom_scm_lock);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (res->a0 == QCOM_SCM_V2_EBUSY) {\n\t\t\tif (retry_count++ > QCOM_SCM_EBUSY_MAX_RETRY)\n\t\t\t\tbreak;\n\t\t\tmsleep(QCOM_SCM_EBUSY_WAIT_MS);\n\t\t}\n\t}  while (res->a0 == QCOM_SCM_V2_EBUSY);\n\n\treturn 0;\n}\n\n\nint __scm_smc_call(struct device *dev, const struct qcom_scm_desc *desc,\n\t\t   enum qcom_scm_convention qcom_convention,\n\t\t   struct qcom_scm_res *res, bool atomic)\n{\n\tint arglen = desc->arginfo & 0xf;\n\tint i, ret;\n\tdma_addr_t args_phys = 0;\n\tvoid *args_virt = NULL;\n\tsize_t alloc_len;\n\tgfp_t flag = atomic ? GFP_ATOMIC : GFP_KERNEL;\n\tu32 smccc_call_type = atomic ? ARM_SMCCC_FAST_CALL : ARM_SMCCC_STD_CALL;\n\tu32 qcom_smccc_convention = (qcom_convention == SMC_CONVENTION_ARM_32) ?\n\t\t\t\t    ARM_SMCCC_SMC_32 : ARM_SMCCC_SMC_64;\n\tstruct arm_smccc_res smc_res;\n\tstruct arm_smccc_args smc = {0};\n\n\tsmc.args[0] = ARM_SMCCC_CALL_VAL(\n\t\tsmccc_call_type,\n\t\tqcom_smccc_convention,\n\t\tdesc->owner,\n\t\tSCM_SMC_FNID(desc->svc, desc->cmd));\n\tsmc.args[1] = desc->arginfo;\n\tfor (i = 0; i < SCM_SMC_N_REG_ARGS; i++)\n\t\tsmc.args[i + SCM_SMC_FIRST_REG_IDX] = desc->args[i];\n\n\tif (unlikely(arglen > SCM_SMC_N_REG_ARGS)) {\n\t\talloc_len = SCM_SMC_N_EXT_ARGS * sizeof(u64);\n\t\targs_virt = kzalloc(PAGE_ALIGN(alloc_len), flag);\n\n\t\tif (!args_virt)\n\t\t\treturn -ENOMEM;\n\n\t\tif (qcom_smccc_convention == ARM_SMCCC_SMC_32) {\n\t\t\t__le32 *args = args_virt;\n\n\t\t\tfor (i = 0; i < SCM_SMC_N_EXT_ARGS; i++)\n\t\t\t\targs[i] = cpu_to_le32(desc->args[i +\n\t\t\t\t\t\t      SCM_SMC_FIRST_EXT_IDX]);\n\t\t} else {\n\t\t\t__le64 *args = args_virt;\n\n\t\t\tfor (i = 0; i < SCM_SMC_N_EXT_ARGS; i++)\n\t\t\t\targs[i] = cpu_to_le64(desc->args[i +\n\t\t\t\t\t\t      SCM_SMC_FIRST_EXT_IDX]);\n\t\t}\n\n\t\targs_phys = dma_map_single(dev, args_virt, alloc_len,\n\t\t\t\t\t   DMA_TO_DEVICE);\n\n\t\tif (dma_mapping_error(dev, args_phys)) {\n\t\t\tkfree(args_virt);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tsmc.args[SCM_SMC_LAST_REG_IDX] = args_phys;\n\t}\n\n\t \n\tret = __scm_smc_do(dev, &smc, &smc_res, atomic);\n\n\tif (args_virt) {\n\t\tdma_unmap_single(dev, args_phys, alloc_len, DMA_TO_DEVICE);\n\t\tkfree(args_virt);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (res) {\n\t\tres->result[0] = smc_res.a1;\n\t\tres->result[1] = smc_res.a2;\n\t\tres->result[2] = smc_res.a3;\n\t}\n\n\treturn (long)smc_res.a0 ? qcom_scm_remap_error(smc_res.a0) : 0;\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}