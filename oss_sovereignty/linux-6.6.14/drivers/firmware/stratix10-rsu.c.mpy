{
  "module_name": "stratix10-rsu.c",
  "hash_id": "53231a5810a51ac73cd6335e9147782a548b91f444d4218f64bf578e57e5f820",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/stratix10-rsu.c",
  "human_readable_source": "\n \n\n#include <linux/arm-smccc.h>\n#include <linux/bitfield.h>\n#include <linux/completion.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/firmware/intel/stratix10-svc-client.h>\n#include <linux/string.h>\n#include <linux/sysfs.h>\n\n#define RSU_STATE_MASK\t\t\tGENMASK_ULL(31, 0)\n#define RSU_VERSION_MASK\t\tGENMASK_ULL(63, 32)\n#define RSU_ERROR_LOCATION_MASK\t\tGENMASK_ULL(31, 0)\n#define RSU_ERROR_DETAIL_MASK\t\tGENMASK_ULL(63, 32)\n#define RSU_DCMF0_MASK\t\t\tGENMASK_ULL(31, 0)\n#define RSU_DCMF1_MASK\t\t\tGENMASK_ULL(63, 32)\n#define RSU_DCMF2_MASK\t\t\tGENMASK_ULL(31, 0)\n#define RSU_DCMF3_MASK\t\t\tGENMASK_ULL(63, 32)\n#define RSU_DCMF0_STATUS_MASK\t\tGENMASK_ULL(15, 0)\n#define RSU_DCMF1_STATUS_MASK\t\tGENMASK_ULL(31, 16)\n#define RSU_DCMF2_STATUS_MASK\t\tGENMASK_ULL(47, 32)\n#define RSU_DCMF3_STATUS_MASK\t\tGENMASK_ULL(63, 48)\n\n#define RSU_TIMEOUT\t(msecs_to_jiffies(SVC_RSU_REQUEST_TIMEOUT_MS))\n\n#define INVALID_RETRY_COUNTER\t\t0xFF\n#define INVALID_DCMF_VERSION\t\t0xFF\n#define INVALID_DCMF_STATUS\t\t0xFFFFFFFF\n#define INVALID_SPT_ADDRESS\t\t0x0\n\n#define RSU_GET_SPT_CMD\t\t\t0x5A\n#define RSU_GET_SPT_RESP_LEN\t\t(4 * sizeof(unsigned int))\n\ntypedef void (*rsu_callback)(struct stratix10_svc_client *client,\n\t\t\t     struct stratix10_svc_cb_data *data);\n \nstruct stratix10_rsu_priv {\n\tstruct stratix10_svc_chan *chan;\n\tstruct stratix10_svc_client client;\n\tstruct completion completion;\n\tstruct mutex lock;\n\tstruct {\n\t\tunsigned long current_image;\n\t\tunsigned long fail_image;\n\t\tunsigned int version;\n\t\tunsigned int state;\n\t\tunsigned int error_details;\n\t\tunsigned int error_location;\n\t} status;\n\n\tstruct {\n\t\tunsigned int dcmf0;\n\t\tunsigned int dcmf1;\n\t\tunsigned int dcmf2;\n\t\tunsigned int dcmf3;\n\t} dcmf_version;\n\n\tstruct {\n\t\tunsigned int dcmf0;\n\t\tunsigned int dcmf1;\n\t\tunsigned int dcmf2;\n\t\tunsigned int dcmf3;\n\t} dcmf_status;\n\n\tunsigned int retry_counter;\n\tunsigned int max_retry;\n\n\tunsigned long spt0_address;\n\tunsigned long spt1_address;\n\n\tunsigned int *get_spt_response_buf;\n};\n\n \nstatic void rsu_status_callback(struct stratix10_svc_client *client,\n\t\t\t\tstruct stratix10_svc_cb_data *data)\n{\n\tstruct stratix10_rsu_priv *priv = client->priv;\n\tstruct arm_smccc_res *res = (struct arm_smccc_res *)data->kaddr1;\n\n\tif (data->status == BIT(SVC_STATUS_OK)) {\n\t\tpriv->status.version = FIELD_GET(RSU_VERSION_MASK,\n\t\t\t\t\t\t res->a2);\n\t\tpriv->status.state = FIELD_GET(RSU_STATE_MASK, res->a2);\n\t\tpriv->status.fail_image = res->a1;\n\t\tpriv->status.current_image = res->a0;\n\t\tpriv->status.error_location =\n\t\t\tFIELD_GET(RSU_ERROR_LOCATION_MASK, res->a3);\n\t\tpriv->status.error_details =\n\t\t\tFIELD_GET(RSU_ERROR_DETAIL_MASK, res->a3);\n\t} else {\n\t\tdev_err(client->dev, \"COMMAND_RSU_STATUS returned 0x%lX\\n\",\n\t\t\tres->a0);\n\t\tpriv->status.version = 0;\n\t\tpriv->status.state = 0;\n\t\tpriv->status.fail_image = 0;\n\t\tpriv->status.current_image = 0;\n\t\tpriv->status.error_location = 0;\n\t\tpriv->status.error_details = 0;\n\t}\n\n\tcomplete(&priv->completion);\n}\n\n \nstatic void rsu_command_callback(struct stratix10_svc_client *client,\n\t\t\t\t struct stratix10_svc_cb_data *data)\n{\n\tstruct stratix10_rsu_priv *priv = client->priv;\n\n\tif (data->status == BIT(SVC_STATUS_NO_SUPPORT))\n\t\tdev_warn(client->dev, \"Secure FW doesn't support notify\\n\");\n\telse if (data->status == BIT(SVC_STATUS_ERROR))\n\t\tdev_err(client->dev, \"Failure, returned status is %lu\\n\",\n\t\t\tBIT(data->status));\n\n\tcomplete(&priv->completion);\n}\n\n \nstatic void rsu_retry_callback(struct stratix10_svc_client *client,\n\t\t\t       struct stratix10_svc_cb_data *data)\n{\n\tstruct stratix10_rsu_priv *priv = client->priv;\n\tunsigned int *counter = (unsigned int *)data->kaddr1;\n\n\tif (data->status == BIT(SVC_STATUS_OK))\n\t\tpriv->retry_counter = *counter;\n\telse if (data->status == BIT(SVC_STATUS_NO_SUPPORT))\n\t\tdev_warn(client->dev, \"Secure FW doesn't support retry\\n\");\n\telse\n\t\tdev_err(client->dev, \"Failed to get retry counter %lu\\n\",\n\t\t\tBIT(data->status));\n\n\tcomplete(&priv->completion);\n}\n\n \nstatic void rsu_max_retry_callback(struct stratix10_svc_client *client,\n\t\t\t\t   struct stratix10_svc_cb_data *data)\n{\n\tstruct stratix10_rsu_priv *priv = client->priv;\n\tunsigned int *max_retry = (unsigned int *)data->kaddr1;\n\n\tif (data->status == BIT(SVC_STATUS_OK))\n\t\tpriv->max_retry = *max_retry;\n\telse if (data->status == BIT(SVC_STATUS_NO_SUPPORT))\n\t\tdev_warn(client->dev, \"Secure FW doesn't support max retry\\n\");\n\telse\n\t\tdev_err(client->dev, \"Failed to get max retry %lu\\n\",\n\t\t\tBIT(data->status));\n\n\tcomplete(&priv->completion);\n}\n\n \nstatic void rsu_dcmf_version_callback(struct stratix10_svc_client *client,\n\t\t\t\t      struct stratix10_svc_cb_data *data)\n{\n\tstruct stratix10_rsu_priv *priv = client->priv;\n\tunsigned long long *value1 = (unsigned long long *)data->kaddr1;\n\tunsigned long long *value2 = (unsigned long long *)data->kaddr2;\n\n\tif (data->status == BIT(SVC_STATUS_OK)) {\n\t\tpriv->dcmf_version.dcmf0 = FIELD_GET(RSU_DCMF0_MASK, *value1);\n\t\tpriv->dcmf_version.dcmf1 = FIELD_GET(RSU_DCMF1_MASK, *value1);\n\t\tpriv->dcmf_version.dcmf2 = FIELD_GET(RSU_DCMF2_MASK, *value2);\n\t\tpriv->dcmf_version.dcmf3 = FIELD_GET(RSU_DCMF3_MASK, *value2);\n\t} else\n\t\tdev_err(client->dev, \"failed to get DCMF version\\n\");\n\n\tcomplete(&priv->completion);\n}\n\n \nstatic void rsu_dcmf_status_callback(struct stratix10_svc_client *client,\n\t\t\t\t     struct stratix10_svc_cb_data *data)\n{\n\tstruct stratix10_rsu_priv *priv = client->priv;\n\tunsigned long long *value = (unsigned long long *)data->kaddr1;\n\n\tif (data->status == BIT(SVC_STATUS_OK)) {\n\t\tpriv->dcmf_status.dcmf0 = FIELD_GET(RSU_DCMF0_STATUS_MASK,\n\t\t\t\t\t\t    *value);\n\t\tpriv->dcmf_status.dcmf1 = FIELD_GET(RSU_DCMF1_STATUS_MASK,\n\t\t\t\t\t\t    *value);\n\t\tpriv->dcmf_status.dcmf2 = FIELD_GET(RSU_DCMF2_STATUS_MASK,\n\t\t\t\t\t\t    *value);\n\t\tpriv->dcmf_status.dcmf3 = FIELD_GET(RSU_DCMF3_STATUS_MASK,\n\t\t\t\t\t\t    *value);\n\t} else\n\t\tdev_err(client->dev, \"failed to get DCMF status\\n\");\n\n\tcomplete(&priv->completion);\n}\n\nstatic void rsu_get_spt_callback(struct stratix10_svc_client *client,\n\t\t\t\t struct stratix10_svc_cb_data *data)\n{\n\tstruct stratix10_rsu_priv *priv = client->priv;\n\tunsigned long *mbox_err = (unsigned long *)data->kaddr1;\n\tunsigned long *resp_len = (unsigned long *)data->kaddr2;\n\n\tif (data->status != BIT(SVC_STATUS_OK) || (*mbox_err) ||\n\t    (*resp_len != RSU_GET_SPT_RESP_LEN))\n\t\tgoto error;\n\n\tpriv->spt0_address = priv->get_spt_response_buf[0];\n\tpriv->spt0_address <<= 32;\n\tpriv->spt0_address |= priv->get_spt_response_buf[1];\n\n\tpriv->spt1_address = priv->get_spt_response_buf[2];\n\tpriv->spt1_address <<= 32;\n\tpriv->spt1_address |= priv->get_spt_response_buf[3];\n\n\tgoto complete;\n\nerror:\n\tdev_err(client->dev, \"failed to get SPTs\\n\");\n\ncomplete:\n\tstratix10_svc_free_memory(priv->chan, priv->get_spt_response_buf);\n\tpriv->get_spt_response_buf = NULL;\n\tcomplete(&priv->completion);\n}\n\n \nstatic int rsu_send_msg(struct stratix10_rsu_priv *priv,\n\t\t\tenum stratix10_svc_command_code command,\n\t\t\tunsigned long arg,\n\t\t\trsu_callback callback)\n{\n\tstruct stratix10_svc_client_msg msg;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\treinit_completion(&priv->completion);\n\tpriv->client.receive_cb = callback;\n\n\tmsg.command = command;\n\tif (arg)\n\t\tmsg.arg[0] = arg;\n\n\tif (command == COMMAND_MBOX_SEND_CMD) {\n\t\tmsg.arg[1] = 0;\n\t\tmsg.payload = NULL;\n\t\tmsg.payload_length = 0;\n\t\tmsg.payload_output = priv->get_spt_response_buf;\n\t\tmsg.payload_length_output = RSU_GET_SPT_RESP_LEN;\n\t}\n\n\tret = stratix10_svc_send(priv->chan, &msg);\n\tif (ret < 0)\n\t\tgoto status_done;\n\n\tret = wait_for_completion_interruptible_timeout(&priv->completion,\n\t\t\t\t\t\t\tRSU_TIMEOUT);\n\tif (!ret) {\n\t\tdev_err(priv->client.dev,\n\t\t\t\"timeout waiting for SMC call\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto status_done;\n\t} else if (ret < 0) {\n\t\tdev_err(priv->client.dev,\n\t\t\t\"error %d waiting for SMC call\\n\", ret);\n\t\tgoto status_done;\n\t} else {\n\t\tret = 0;\n\t}\n\nstatus_done:\n\tstratix10_svc_done(priv->chan);\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\n \n\nstatic ssize_t current_image_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct stratix10_rsu_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"0x%08lx\\n\", priv->status.current_image);\n}\n\nstatic ssize_t fail_image_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct stratix10_rsu_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"0x%08lx\\n\", priv->status.fail_image);\n}\n\nstatic ssize_t version_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct stratix10_rsu_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"0x%08x\\n\", priv->status.version);\n}\n\nstatic ssize_t state_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct stratix10_rsu_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"0x%08x\\n\", priv->status.state);\n}\n\nstatic ssize_t error_location_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct stratix10_rsu_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"0x%08x\\n\", priv->status.error_location);\n}\n\nstatic ssize_t error_details_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct stratix10_rsu_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"0x%08x\\n\", priv->status.error_details);\n}\n\nstatic ssize_t retry_counter_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct stratix10_rsu_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"0x%08x\\n\", priv->retry_counter);\n}\n\nstatic ssize_t max_retry_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct stratix10_rsu_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\treturn scnprintf(buf, sizeof(priv->max_retry),\n\t\t\t \"0x%08x\\n\", priv->max_retry);\n}\n\nstatic ssize_t dcmf0_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct stratix10_rsu_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"0x%08x\\n\", priv->dcmf_version.dcmf0);\n}\n\nstatic ssize_t dcmf1_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct stratix10_rsu_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"0x%08x\\n\", priv->dcmf_version.dcmf1);\n}\n\nstatic ssize_t dcmf2_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct stratix10_rsu_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"0x%08x\\n\", priv->dcmf_version.dcmf2);\n}\n\nstatic ssize_t dcmf3_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct stratix10_rsu_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"0x%08x\\n\", priv->dcmf_version.dcmf3);\n}\n\nstatic ssize_t dcmf0_status_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct stratix10_rsu_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\tif (priv->dcmf_status.dcmf0 == INVALID_DCMF_STATUS)\n\t\treturn -EIO;\n\n\treturn sprintf(buf, \"0x%08x\\n\", priv->dcmf_status.dcmf0);\n}\n\nstatic ssize_t dcmf1_status_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct stratix10_rsu_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\tif (priv->dcmf_status.dcmf1 == INVALID_DCMF_STATUS)\n\t\treturn -EIO;\n\n\treturn sprintf(buf, \"0x%08x\\n\", priv->dcmf_status.dcmf1);\n}\n\nstatic ssize_t dcmf2_status_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct stratix10_rsu_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\tif (priv->dcmf_status.dcmf2 == INVALID_DCMF_STATUS)\n\t\treturn -EIO;\n\n\treturn sprintf(buf, \"0x%08x\\n\", priv->dcmf_status.dcmf2);\n}\n\nstatic ssize_t dcmf3_status_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct stratix10_rsu_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\tif (priv->dcmf_status.dcmf3 == INVALID_DCMF_STATUS)\n\t\treturn -EIO;\n\n\treturn sprintf(buf, \"0x%08x\\n\", priv->dcmf_status.dcmf3);\n}\nstatic ssize_t reboot_image_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct stratix10_rsu_priv *priv = dev_get_drvdata(dev);\n\tunsigned long address;\n\tint ret;\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\tret = kstrtoul(buf, 0, &address);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rsu_send_msg(priv, COMMAND_RSU_UPDATE,\n\t\t\t   address, rsu_command_callback);\n\tif (ret) {\n\t\tdev_err(dev, \"Error, RSU update returned %i\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t notify_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct stratix10_rsu_priv *priv = dev_get_drvdata(dev);\n\tunsigned long status;\n\tint ret;\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\tret = kstrtoul(buf, 0, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rsu_send_msg(priv, COMMAND_RSU_NOTIFY,\n\t\t\t   status, rsu_command_callback);\n\tif (ret) {\n\t\tdev_err(dev, \"Error, RSU notify returned %i\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = rsu_send_msg(priv, COMMAND_RSU_STATUS,\n\t\t\t   0, rsu_status_callback);\n\tif (ret) {\n\t\tdev_err(dev, \"Error, getting RSU status %i\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = rsu_send_msg(priv, COMMAND_RSU_RETRY, 0, rsu_retry_callback);\n\tif (ret) {\n\t\tdev_err(dev, \"Error, getting RSU retry %i\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t spt0_address_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct stratix10_rsu_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\tif (priv->spt0_address == INVALID_SPT_ADDRESS)\n\t\treturn -EIO;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"0x%08lx\\n\", priv->spt0_address);\n}\n\nstatic ssize_t spt1_address_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct stratix10_rsu_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\tif (priv->spt1_address == INVALID_SPT_ADDRESS)\n\t\treturn -EIO;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"0x%08lx\\n\", priv->spt1_address);\n}\n\nstatic DEVICE_ATTR_RO(current_image);\nstatic DEVICE_ATTR_RO(fail_image);\nstatic DEVICE_ATTR_RO(state);\nstatic DEVICE_ATTR_RO(version);\nstatic DEVICE_ATTR_RO(error_location);\nstatic DEVICE_ATTR_RO(error_details);\nstatic DEVICE_ATTR_RO(retry_counter);\nstatic DEVICE_ATTR_RO(max_retry);\nstatic DEVICE_ATTR_RO(dcmf0);\nstatic DEVICE_ATTR_RO(dcmf1);\nstatic DEVICE_ATTR_RO(dcmf2);\nstatic DEVICE_ATTR_RO(dcmf3);\nstatic DEVICE_ATTR_RO(dcmf0_status);\nstatic DEVICE_ATTR_RO(dcmf1_status);\nstatic DEVICE_ATTR_RO(dcmf2_status);\nstatic DEVICE_ATTR_RO(dcmf3_status);\nstatic DEVICE_ATTR_WO(reboot_image);\nstatic DEVICE_ATTR_WO(notify);\nstatic DEVICE_ATTR_RO(spt0_address);\nstatic DEVICE_ATTR_RO(spt1_address);\n\nstatic struct attribute *rsu_attrs[] = {\n\t&dev_attr_current_image.attr,\n\t&dev_attr_fail_image.attr,\n\t&dev_attr_state.attr,\n\t&dev_attr_version.attr,\n\t&dev_attr_error_location.attr,\n\t&dev_attr_error_details.attr,\n\t&dev_attr_retry_counter.attr,\n\t&dev_attr_max_retry.attr,\n\t&dev_attr_dcmf0.attr,\n\t&dev_attr_dcmf1.attr,\n\t&dev_attr_dcmf2.attr,\n\t&dev_attr_dcmf3.attr,\n\t&dev_attr_dcmf0_status.attr,\n\t&dev_attr_dcmf1_status.attr,\n\t&dev_attr_dcmf2_status.attr,\n\t&dev_attr_dcmf3_status.attr,\n\t&dev_attr_reboot_image.attr,\n\t&dev_attr_notify.attr,\n\t&dev_attr_spt0_address.attr,\n\t&dev_attr_spt1_address.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(rsu);\n\nstatic int stratix10_rsu_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct stratix10_rsu_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->client.dev = dev;\n\tpriv->client.receive_cb = NULL;\n\tpriv->client.priv = priv;\n\tpriv->status.current_image = 0;\n\tpriv->status.fail_image = 0;\n\tpriv->status.error_location = 0;\n\tpriv->status.error_details = 0;\n\tpriv->status.version = 0;\n\tpriv->status.state = 0;\n\tpriv->retry_counter = INVALID_RETRY_COUNTER;\n\tpriv->dcmf_version.dcmf0 = INVALID_DCMF_VERSION;\n\tpriv->dcmf_version.dcmf1 = INVALID_DCMF_VERSION;\n\tpriv->dcmf_version.dcmf2 = INVALID_DCMF_VERSION;\n\tpriv->dcmf_version.dcmf3 = INVALID_DCMF_VERSION;\n\tpriv->dcmf_status.dcmf0 = INVALID_DCMF_STATUS;\n\tpriv->dcmf_status.dcmf1 = INVALID_DCMF_STATUS;\n\tpriv->dcmf_status.dcmf2 = INVALID_DCMF_STATUS;\n\tpriv->dcmf_status.dcmf3 = INVALID_DCMF_STATUS;\n\tpriv->max_retry = INVALID_RETRY_COUNTER;\n\tpriv->spt0_address = INVALID_SPT_ADDRESS;\n\tpriv->spt1_address = INVALID_SPT_ADDRESS;\n\n\tmutex_init(&priv->lock);\n\tpriv->chan = stratix10_svc_request_channel_byname(&priv->client,\n\t\t\t\t\t\t\t  SVC_CLIENT_RSU);\n\tif (IS_ERR(priv->chan)) {\n\t\tdev_err(dev, \"couldn't get service channel %s\\n\",\n\t\t\tSVC_CLIENT_RSU);\n\t\treturn PTR_ERR(priv->chan);\n\t}\n\n\tinit_completion(&priv->completion);\n\tplatform_set_drvdata(pdev, priv);\n\n\t \n\tret = rsu_send_msg(priv, COMMAND_RSU_STATUS,\n\t\t\t   0, rsu_status_callback);\n\tif (ret) {\n\t\tdev_err(dev, \"Error, getting RSU status %i\\n\", ret);\n\t\tstratix10_svc_free_channel(priv->chan);\n\t}\n\n\t \n\tret = rsu_send_msg(priv, COMMAND_RSU_DCMF_VERSION,\n\t\t\t   0, rsu_dcmf_version_callback);\n\tif (ret) {\n\t\tdev_err(dev, \"Error, getting DCMF version %i\\n\", ret);\n\t\tstratix10_svc_free_channel(priv->chan);\n\t}\n\n\tret = rsu_send_msg(priv, COMMAND_RSU_DCMF_STATUS,\n\t\t\t   0, rsu_dcmf_status_callback);\n\tif (ret) {\n\t\tdev_err(dev, \"Error, getting DCMF status %i\\n\", ret);\n\t\tstratix10_svc_free_channel(priv->chan);\n\t}\n\n\tret = rsu_send_msg(priv, COMMAND_RSU_RETRY, 0, rsu_retry_callback);\n\tif (ret) {\n\t\tdev_err(dev, \"Error, getting RSU retry %i\\n\", ret);\n\t\tstratix10_svc_free_channel(priv->chan);\n\t}\n\n\tret = rsu_send_msg(priv, COMMAND_RSU_MAX_RETRY, 0,\n\t\t\t   rsu_max_retry_callback);\n\tif (ret) {\n\t\tdev_err(dev, \"Error, getting RSU max retry %i\\n\", ret);\n\t\tstratix10_svc_free_channel(priv->chan);\n\t}\n\n\tpriv->get_spt_response_buf =\n\t\tstratix10_svc_allocate_memory(priv->chan, RSU_GET_SPT_RESP_LEN);\n\n\tif (IS_ERR(priv->get_spt_response_buf)) {\n\t\tdev_err(dev, \"failed to allocate get spt buffer\\n\");\n\t} else {\n\t\tret = rsu_send_msg(priv, COMMAND_MBOX_SEND_CMD,\n\t\t\t\t   RSU_GET_SPT_CMD, rsu_get_spt_callback);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Error, getting SPT table %i\\n\", ret);\n\t\t\tstratix10_svc_free_channel(priv->chan);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int stratix10_rsu_remove(struct platform_device *pdev)\n{\n\tstruct stratix10_rsu_priv *priv = platform_get_drvdata(pdev);\n\n\tstratix10_svc_free_channel(priv->chan);\n\treturn 0;\n}\n\nstatic struct platform_driver stratix10_rsu_driver = {\n\t.probe = stratix10_rsu_probe,\n\t.remove = stratix10_rsu_remove,\n\t.driver = {\n\t\t.name = \"stratix10-rsu\",\n\t\t.dev_groups = rsu_groups,\n\t},\n};\n\nmodule_platform_driver(stratix10_rsu_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel Remote System Update Driver\");\nMODULE_AUTHOR(\"Richard Gong <richard.gong@intel.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}