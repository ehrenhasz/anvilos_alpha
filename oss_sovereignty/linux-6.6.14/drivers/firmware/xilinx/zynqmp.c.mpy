{
  "module_name": "zynqmp.c",
  "hash_id": "b58805286e22a87fd9352cfdd9b8eb721b27e6a305a7df044ccd1fae8a4d4c0f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/xilinx/zynqmp.c",
  "human_readable_source": "\n \n\n#include <linux/arm-smccc.h>\n#include <linux/compiler.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/mfd/core.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/hashtable.h>\n\n#include <linux/firmware/xlnx-zynqmp.h>\n#include <linux/firmware/xlnx-event-manager.h>\n#include \"zynqmp-debug.h\"\n\n \n#define PM_API_FEATURE_CHECK_MAX_ORDER  7\n\n \n#define CRL_APB_BASE\t\t\t0xFF5E0000U\n \n#define CRL_APB_BOOT_PIN_CTRL\t\t(CRL_APB_BASE + (0x250U))\n \n#define CRL_APB_BOOTPIN_CTRL_MASK\t0xF0FU\n\n \n#define FEATURE_PAYLOAD_SIZE\t\t2\n\n \n#define FIRMWARE_VERSION_MASK\t\tGENMASK(15, 0)\n\nstatic bool feature_check_enabled;\nstatic DEFINE_HASHTABLE(pm_api_features_map, PM_API_FEATURE_CHECK_MAX_ORDER);\nstatic u32 ioctl_features[FEATURE_PAYLOAD_SIZE];\nstatic u32 query_features[FEATURE_PAYLOAD_SIZE];\n\nstatic struct platform_device *em_dev;\n\n \nstruct zynqmp_devinfo {\n\tstruct device *dev;\n\tu32 feature_conf_id;\n};\n\n \nstruct pm_api_feature_data {\n\tu32 pm_api_id;\n\tint feature_status;\n\tstruct hlist_node hentry;\n};\n\nstatic const struct mfd_cell firmware_devs[] = {\n\t{\n\t\t.name = \"zynqmp_power_controller\",\n\t},\n};\n\n \nstatic int zynqmp_pm_ret_code(u32 ret_status)\n{\n\tswitch (ret_status) {\n\tcase XST_PM_SUCCESS:\n\tcase XST_PM_DOUBLE_REQ:\n\t\treturn 0;\n\tcase XST_PM_NO_FEATURE:\n\t\treturn -ENOTSUPP;\n\tcase XST_PM_NO_ACCESS:\n\t\treturn -EACCES;\n\tcase XST_PM_ABORT_SUSPEND:\n\t\treturn -ECANCELED;\n\tcase XST_PM_MULT_USER:\n\t\treturn -EUSERS;\n\tcase XST_PM_INTERNAL:\n\tcase XST_PM_CONFLICT:\n\tcase XST_PM_INVALID_NODE:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic noinline int do_fw_call_fail(u64 arg0, u64 arg1, u64 arg2,\n\t\t\t\t    u32 *ret_payload)\n{\n\treturn -ENODEV;\n}\n\n \nstatic int (*do_fw_call)(u64, u64, u64, u32 *ret_payload) = do_fw_call_fail;\n\n \nstatic noinline int do_fw_call_smc(u64 arg0, u64 arg1, u64 arg2,\n\t\t\t\t   u32 *ret_payload)\n{\n\tstruct arm_smccc_res res;\n\n\tarm_smccc_smc(arg0, arg1, arg2, 0, 0, 0, 0, 0, &res);\n\n\tif (ret_payload) {\n\t\tret_payload[0] = lower_32_bits(res.a0);\n\t\tret_payload[1] = upper_32_bits(res.a0);\n\t\tret_payload[2] = lower_32_bits(res.a1);\n\t\tret_payload[3] = upper_32_bits(res.a1);\n\t}\n\n\treturn zynqmp_pm_ret_code((enum pm_ret_status)res.a0);\n}\n\n \nstatic noinline int do_fw_call_hvc(u64 arg0, u64 arg1, u64 arg2,\n\t\t\t\t   u32 *ret_payload)\n{\n\tstruct arm_smccc_res res;\n\n\tarm_smccc_hvc(arg0, arg1, arg2, 0, 0, 0, 0, 0, &res);\n\n\tif (ret_payload) {\n\t\tret_payload[0] = lower_32_bits(res.a0);\n\t\tret_payload[1] = upper_32_bits(res.a0);\n\t\tret_payload[2] = lower_32_bits(res.a1);\n\t\tret_payload[3] = upper_32_bits(res.a1);\n\t}\n\n\treturn zynqmp_pm_ret_code((enum pm_ret_status)res.a0);\n}\n\nstatic int __do_feature_check_call(const u32 api_id, u32 *ret_payload)\n{\n\tint ret;\n\tu64 smc_arg[2];\n\n\tsmc_arg[0] = PM_SIP_SVC | PM_FEATURE_CHECK;\n\tsmc_arg[1] = api_id;\n\n\tret = do_fw_call(smc_arg[0], smc_arg[1], 0, ret_payload);\n\tif (ret)\n\t\tret = -EOPNOTSUPP;\n\telse\n\t\tret = ret_payload[1];\n\n\treturn ret;\n}\n\nstatic int do_feature_check_call(const u32 api_id)\n{\n\tint ret;\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tstruct pm_api_feature_data *feature_data;\n\n\t \n\thash_for_each_possible(pm_api_features_map, feature_data, hentry,\n\t\t\t       api_id) {\n\t\tif (feature_data->pm_api_id == api_id)\n\t\t\treturn feature_data->feature_status;\n\t}\n\n\t \n\tfeature_data = kmalloc(sizeof(*feature_data), GFP_ATOMIC);\n\tif (!feature_data)\n\t\treturn -ENOMEM;\n\n\tfeature_data->pm_api_id = api_id;\n\tret = __do_feature_check_call(api_id, ret_payload);\n\n\tfeature_data->feature_status = ret;\n\thash_add(pm_api_features_map, &feature_data->hentry, api_id);\n\n\tif (api_id == PM_IOCTL)\n\t\t \n\t\tmemcpy(ioctl_features, &ret_payload[2], FEATURE_PAYLOAD_SIZE * 4);\n\telse if (api_id == PM_QUERY_DATA)\n\t\t \n\t\tmemcpy(query_features, &ret_payload[2], FEATURE_PAYLOAD_SIZE * 4);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_feature);\n\n \nint zynqmp_pm_feature(const u32 api_id)\n{\n\tint ret;\n\n\tif (!feature_check_enabled)\n\t\treturn 0;\n\n\tret = do_feature_check_call(api_id);\n\n\treturn ret;\n}\n\n \nint zynqmp_pm_is_function_supported(const u32 api_id, const u32 id)\n{\n\tint ret;\n\tu32 *bit_mask;\n\n\t \n\tif (id >= 64 || (api_id != PM_IOCTL && api_id != PM_QUERY_DATA))\n\t\treturn -EINVAL;\n\n\t \n\tret = do_feature_check_call(PM_FEATURE_CHECK);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif ((ret & FIRMWARE_VERSION_MASK) == PM_API_VERSION_2) {\n\t\t \n\t\tret = do_feature_check_call(api_id);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbit_mask = (api_id == PM_IOCTL) ? ioctl_features : query_features;\n\n\t\tif ((bit_mask[(id / 32)] & BIT((id % 32))) == 0U)\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\treturn -ENODATA;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_is_function_supported);\n\n \nint zynqmp_pm_invoke_fn(u32 pm_api_id, u32 arg0, u32 arg1,\n\t\t\tu32 arg2, u32 arg3, u32 *ret_payload)\n{\n\t \n\tu64 smc_arg[4];\n\tint ret;\n\n\t \n\tret = zynqmp_pm_feature(pm_api_id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsmc_arg[0] = PM_SIP_SVC | pm_api_id;\n\tsmc_arg[1] = ((u64)arg1 << 32) | arg0;\n\tsmc_arg[2] = ((u64)arg3 << 32) | arg2;\n\n\treturn do_fw_call(smc_arg[0], smc_arg[1], smc_arg[2], ret_payload);\n}\n\nstatic u32 pm_api_version;\nstatic u32 pm_tz_version;\nstatic u32 pm_family_code;\nstatic u32 pm_sub_family_code;\n\nint zynqmp_pm_register_sgi(u32 sgi_num, u32 reset)\n{\n\tint ret;\n\n\tret = zynqmp_pm_invoke_fn(TF_A_PM_REGISTER_SGI, sgi_num, reset, 0, 0,\n\t\t\t\t  NULL);\n\tif (!ret)\n\t\treturn ret;\n\n\t \n\treturn zynqmp_pm_invoke_fn(PM_IOCTL, 0, IOCTL_REGISTER_SGI, sgi_num,\n\t\t\t\t   reset, NULL);\n}\n\n \nint zynqmp_pm_get_api_version(u32 *version)\n{\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tif (!version)\n\t\treturn -EINVAL;\n\n\t \n\tif (pm_api_version > 0) {\n\t\t*version = pm_api_version;\n\t\treturn 0;\n\t}\n\tret = zynqmp_pm_invoke_fn(PM_GET_API_VERSION, 0, 0, 0, 0, ret_payload);\n\t*version = ret_payload[1];\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_get_api_version);\n\n \nint zynqmp_pm_get_chipid(u32 *idcode, u32 *version)\n{\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tif (!idcode || !version)\n\t\treturn -EINVAL;\n\n\tret = zynqmp_pm_invoke_fn(PM_GET_CHIPID, 0, 0, 0, 0, ret_payload);\n\t*idcode = ret_payload[1];\n\t*version = ret_payload[2];\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_get_chipid);\n\n \nstatic int zynqmp_pm_get_family_info(u32 *family, u32 *subfamily)\n{\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tu32 idcode;\n\tint ret;\n\n\t \n\tif (pm_family_code && pm_sub_family_code) {\n\t\t*family = pm_family_code;\n\t\t*subfamily = pm_sub_family_code;\n\t\treturn 0;\n\t}\n\n\tret = zynqmp_pm_invoke_fn(PM_GET_CHIPID, 0, 0, 0, 0, ret_payload);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tidcode = ret_payload[1];\n\tpm_family_code = FIELD_GET(FAMILY_CODE_MASK, idcode);\n\tpm_sub_family_code = FIELD_GET(SUB_FAMILY_CODE_MASK, idcode);\n\t*family = pm_family_code;\n\t*subfamily = pm_sub_family_code;\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_pm_get_trustzone_version(u32 *version)\n{\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tif (!version)\n\t\treturn -EINVAL;\n\n\t \n\tif (pm_tz_version > 0) {\n\t\t*version = pm_tz_version;\n\t\treturn 0;\n\t}\n\tret = zynqmp_pm_invoke_fn(PM_GET_TRUSTZONE_VERSION, 0, 0,\n\t\t\t\t  0, 0, ret_payload);\n\t*version = ret_payload[1];\n\n\treturn ret;\n}\n\n \nstatic int get_set_conduit_method(struct device_node *np)\n{\n\tconst char *method;\n\n\tif (of_property_read_string(np, \"method\", &method)) {\n\t\tpr_warn(\"%s missing \\\"method\\\" property\\n\", __func__);\n\t\treturn -ENXIO;\n\t}\n\n\tif (!strcmp(\"hvc\", method)) {\n\t\tdo_fw_call = do_fw_call_hvc;\n\t} else if (!strcmp(\"smc\", method)) {\n\t\tdo_fw_call = do_fw_call_smc;\n\t} else {\n\t\tpr_warn(\"%s Invalid \\\"method\\\" property: %s\\n\",\n\t\t\t__func__, method);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint zynqmp_pm_query_data(struct zynqmp_pm_query_data qdata, u32 *out)\n{\n\tint ret;\n\n\tret = zynqmp_pm_invoke_fn(PM_QUERY_DATA, qdata.qid, qdata.arg1,\n\t\t\t\t  qdata.arg2, qdata.arg3, out);\n\n\t \n\treturn qdata.qid == PM_QID_CLOCK_GET_NAME ? 0 : ret;\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_query_data);\n\n \nint zynqmp_pm_clock_enable(u32 clock_id)\n{\n\treturn zynqmp_pm_invoke_fn(PM_CLOCK_ENABLE, clock_id, 0, 0, 0, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_clock_enable);\n\n \nint zynqmp_pm_clock_disable(u32 clock_id)\n{\n\treturn zynqmp_pm_invoke_fn(PM_CLOCK_DISABLE, clock_id, 0, 0, 0, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_clock_disable);\n\n \nint zynqmp_pm_clock_getstate(u32 clock_id, u32 *state)\n{\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tret = zynqmp_pm_invoke_fn(PM_CLOCK_GETSTATE, clock_id, 0,\n\t\t\t\t  0, 0, ret_payload);\n\t*state = ret_payload[1];\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_clock_getstate);\n\n \nint zynqmp_pm_clock_setdivider(u32 clock_id, u32 divider)\n{\n\treturn zynqmp_pm_invoke_fn(PM_CLOCK_SETDIVIDER, clock_id, divider,\n\t\t\t\t   0, 0, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_clock_setdivider);\n\n \nint zynqmp_pm_clock_getdivider(u32 clock_id, u32 *divider)\n{\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tret = zynqmp_pm_invoke_fn(PM_CLOCK_GETDIVIDER, clock_id, 0,\n\t\t\t\t  0, 0, ret_payload);\n\t*divider = ret_payload[1];\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_clock_getdivider);\n\n \nint zynqmp_pm_clock_setrate(u32 clock_id, u64 rate)\n{\n\treturn zynqmp_pm_invoke_fn(PM_CLOCK_SETRATE, clock_id,\n\t\t\t\t   lower_32_bits(rate),\n\t\t\t\t   upper_32_bits(rate),\n\t\t\t\t   0, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_clock_setrate);\n\n \nint zynqmp_pm_clock_getrate(u32 clock_id, u64 *rate)\n{\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tret = zynqmp_pm_invoke_fn(PM_CLOCK_GETRATE, clock_id, 0,\n\t\t\t\t  0, 0, ret_payload);\n\t*rate = ((u64)ret_payload[2] << 32) | ret_payload[1];\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_clock_getrate);\n\n \nint zynqmp_pm_clock_setparent(u32 clock_id, u32 parent_id)\n{\n\treturn zynqmp_pm_invoke_fn(PM_CLOCK_SETPARENT, clock_id,\n\t\t\t\t   parent_id, 0, 0, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_clock_setparent);\n\n \nint zynqmp_pm_clock_getparent(u32 clock_id, u32 *parent_id)\n{\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tret = zynqmp_pm_invoke_fn(PM_CLOCK_GETPARENT, clock_id, 0,\n\t\t\t\t  0, 0, ret_payload);\n\t*parent_id = ret_payload[1];\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_clock_getparent);\n\n \nint zynqmp_pm_set_pll_frac_mode(u32 clk_id, u32 mode)\n{\n\treturn zynqmp_pm_invoke_fn(PM_IOCTL, 0, IOCTL_SET_PLL_FRAC_MODE,\n\t\t\t\t   clk_id, mode, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_set_pll_frac_mode);\n\n \nint zynqmp_pm_get_pll_frac_mode(u32 clk_id, u32 *mode)\n{\n\treturn zynqmp_pm_invoke_fn(PM_IOCTL, 0, IOCTL_GET_PLL_FRAC_MODE,\n\t\t\t\t   clk_id, 0, mode);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_get_pll_frac_mode);\n\n \nint zynqmp_pm_set_pll_frac_data(u32 clk_id, u32 data)\n{\n\treturn zynqmp_pm_invoke_fn(PM_IOCTL, 0, IOCTL_SET_PLL_FRAC_DATA,\n\t\t\t\t   clk_id, data, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_set_pll_frac_data);\n\n \nint zynqmp_pm_get_pll_frac_data(u32 clk_id, u32 *data)\n{\n\treturn zynqmp_pm_invoke_fn(PM_IOCTL, 0, IOCTL_GET_PLL_FRAC_DATA,\n\t\t\t\t   clk_id, 0, data);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_get_pll_frac_data);\n\n \nint zynqmp_pm_set_sd_tapdelay(u32 node_id, u32 type, u32 value)\n{\n\tu32 reg = (type == PM_TAPDELAY_INPUT) ? SD_ITAPDLY : SD_OTAPDLYSEL;\n\tu32 mask = (node_id == NODE_SD_0) ? GENMASK(15, 0) : GENMASK(31, 16);\n\n\tif (value) {\n\t\treturn zynqmp_pm_invoke_fn(PM_IOCTL, node_id,\n\t\t\t\t\t   IOCTL_SET_SD_TAPDELAY,\n\t\t\t\t\t   type, value, NULL);\n\t}\n\n\t \n\treturn zynqmp_pm_invoke_fn(PM_MMIO_WRITE, reg, mask, 0, 0, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_set_sd_tapdelay);\n\n \nint zynqmp_pm_sd_dll_reset(u32 node_id, u32 type)\n{\n\treturn zynqmp_pm_invoke_fn(PM_IOCTL, node_id, IOCTL_SD_DLL_RESET,\n\t\t\t\t   type, 0, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_sd_dll_reset);\n\n \nint zynqmp_pm_ospi_mux_select(u32 dev_id, u32 select)\n{\n\treturn zynqmp_pm_invoke_fn(PM_IOCTL, dev_id, IOCTL_OSPI_MUX_SELECT,\n\t\t\t\t   select, 0, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_ospi_mux_select);\n\n \nint zynqmp_pm_write_ggs(u32 index, u32 value)\n{\n\treturn zynqmp_pm_invoke_fn(PM_IOCTL, 0, IOCTL_WRITE_GGS,\n\t\t\t\t   index, value, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_write_ggs);\n\n \nint zynqmp_pm_read_ggs(u32 index, u32 *value)\n{\n\treturn zynqmp_pm_invoke_fn(PM_IOCTL, 0, IOCTL_READ_GGS,\n\t\t\t\t   index, 0, value);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_read_ggs);\n\n \nint zynqmp_pm_write_pggs(u32 index, u32 value)\n{\n\treturn zynqmp_pm_invoke_fn(PM_IOCTL, 0, IOCTL_WRITE_PGGS, index, value,\n\t\t\t\t   NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_write_pggs);\n\n \nint zynqmp_pm_read_pggs(u32 index, u32 *value)\n{\n\treturn zynqmp_pm_invoke_fn(PM_IOCTL, 0, IOCTL_READ_PGGS, index, 0,\n\t\t\t\t   value);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_read_pggs);\n\nint zynqmp_pm_set_tapdelay_bypass(u32 index, u32 value)\n{\n\treturn zynqmp_pm_invoke_fn(PM_IOCTL, 0, IOCTL_SET_TAPDELAY_BYPASS,\n\t\t\t\t   index, value, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_set_tapdelay_bypass);\n\n \nint zynqmp_pm_set_boot_health_status(u32 value)\n{\n\treturn zynqmp_pm_invoke_fn(PM_IOCTL, 0, IOCTL_SET_BOOT_HEALTH_STATUS,\n\t\t\t\t   value, 0, NULL);\n}\n\n \nint zynqmp_pm_reset_assert(const enum zynqmp_pm_reset reset,\n\t\t\t   const enum zynqmp_pm_reset_action assert_flag)\n{\n\treturn zynqmp_pm_invoke_fn(PM_RESET_ASSERT, reset, assert_flag,\n\t\t\t\t   0, 0, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_reset_assert);\n\n \nint zynqmp_pm_reset_get_status(const enum zynqmp_pm_reset reset, u32 *status)\n{\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tif (!status)\n\t\treturn -EINVAL;\n\n\tret = zynqmp_pm_invoke_fn(PM_RESET_GET_STATUS, reset, 0,\n\t\t\t\t  0, 0, ret_payload);\n\t*status = ret_payload[1];\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_reset_get_status);\n\n \nint zynqmp_pm_fpga_load(const u64 address, const u32 size, const u32 flags)\n{\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tret = zynqmp_pm_invoke_fn(PM_FPGA_LOAD, lower_32_bits(address),\n\t\t\t\t  upper_32_bits(address), size, flags,\n\t\t\t\t  ret_payload);\n\tif (ret_payload[0])\n\t\treturn -ret_payload[0];\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_fpga_load);\n\n \nint zynqmp_pm_fpga_get_status(u32 *value)\n{\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tif (!value)\n\t\treturn -EINVAL;\n\n\tret = zynqmp_pm_invoke_fn(PM_FPGA_GET_STATUS, 0, 0, 0, 0, ret_payload);\n\t*value = ret_payload[1];\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_fpga_get_status);\n\n \nint zynqmp_pm_fpga_get_config_status(u32 *value)\n{\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tu32 buf, lower_addr, upper_addr;\n\tint ret;\n\n\tif (!value)\n\t\treturn -EINVAL;\n\n\tlower_addr = lower_32_bits((u64)&buf);\n\tupper_addr = upper_32_bits((u64)&buf);\n\n\tret = zynqmp_pm_invoke_fn(PM_FPGA_READ,\n\t\t\t\t  XILINX_ZYNQMP_PM_FPGA_CONFIG_STAT_OFFSET,\n\t\t\t\t  lower_addr, upper_addr,\n\t\t\t\t  XILINX_ZYNQMP_PM_FPGA_READ_CONFIG_REG,\n\t\t\t\t  ret_payload);\n\n\t*value = ret_payload[1];\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_fpga_get_config_status);\n\n \nint zynqmp_pm_pinctrl_request(const u32 pin)\n{\n\treturn zynqmp_pm_invoke_fn(PM_PINCTRL_REQUEST, pin, 0, 0, 0, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_pinctrl_request);\n\n \nint zynqmp_pm_pinctrl_release(const u32 pin)\n{\n\treturn zynqmp_pm_invoke_fn(PM_PINCTRL_RELEASE, pin, 0, 0, 0, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_pinctrl_release);\n\n \nint zynqmp_pm_pinctrl_get_function(const u32 pin, u32 *id)\n{\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tif (!id)\n\t\treturn -EINVAL;\n\n\tret = zynqmp_pm_invoke_fn(PM_PINCTRL_GET_FUNCTION, pin, 0,\n\t\t\t\t  0, 0, ret_payload);\n\t*id = ret_payload[1];\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_pinctrl_get_function);\n\n \nint zynqmp_pm_pinctrl_set_function(const u32 pin, const u32 id)\n{\n\treturn zynqmp_pm_invoke_fn(PM_PINCTRL_SET_FUNCTION, pin, id,\n\t\t\t\t   0, 0, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_pinctrl_set_function);\n\n \nint zynqmp_pm_pinctrl_get_config(const u32 pin, const u32 param,\n\t\t\t\t u32 *value)\n{\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tif (!value)\n\t\treturn -EINVAL;\n\n\tret = zynqmp_pm_invoke_fn(PM_PINCTRL_CONFIG_PARAM_GET, pin, param,\n\t\t\t\t  0, 0, ret_payload);\n\t*value = ret_payload[1];\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_pinctrl_get_config);\n\n \nint zynqmp_pm_pinctrl_set_config(const u32 pin, const u32 param,\n\t\t\t\t u32 value)\n{\n\tint ret;\n\n\tif (pm_family_code == ZYNQMP_FAMILY_CODE &&\n\t    param == PM_PINCTRL_CONFIG_TRI_STATE) {\n\t\tret = zynqmp_pm_feature(PM_PINCTRL_CONFIG_PARAM_SET);\n\t\tif (ret < PM_PINCTRL_PARAM_SET_VERSION)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn zynqmp_pm_invoke_fn(PM_PINCTRL_CONFIG_PARAM_SET, pin,\n\t\t\t\t   param, value, 0, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_pinctrl_set_config);\n\n \nunsigned int zynqmp_pm_bootmode_read(u32 *ps_mode)\n{\n\tunsigned int ret;\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\n\tret = zynqmp_pm_invoke_fn(PM_MMIO_READ, CRL_APB_BOOT_PIN_CTRL, 0,\n\t\t\t\t  0, 0, ret_payload);\n\n\t*ps_mode = ret_payload[1];\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_bootmode_read);\n\n \nint zynqmp_pm_bootmode_write(u32 ps_mode)\n{\n\treturn zynqmp_pm_invoke_fn(PM_MMIO_WRITE, CRL_APB_BOOT_PIN_CTRL,\n\t\t\t\t   CRL_APB_BOOTPIN_CTRL_MASK, ps_mode, 0, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_bootmode_write);\n\n \nint zynqmp_pm_init_finalize(void)\n{\n\treturn zynqmp_pm_invoke_fn(PM_PM_INIT_FINALIZE, 0, 0, 0, 0, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_init_finalize);\n\n \nint zynqmp_pm_set_suspend_mode(u32 mode)\n{\n\treturn zynqmp_pm_invoke_fn(PM_SET_SUSPEND_MODE, mode, 0, 0, 0, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_set_suspend_mode);\n\n \nint zynqmp_pm_request_node(const u32 node, const u32 capabilities,\n\t\t\t   const u32 qos, const enum zynqmp_pm_request_ack ack)\n{\n\treturn zynqmp_pm_invoke_fn(PM_REQUEST_NODE, node, capabilities,\n\t\t\t\t   qos, ack, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_request_node);\n\n \nint zynqmp_pm_release_node(const u32 node)\n{\n\treturn zynqmp_pm_invoke_fn(PM_RELEASE_NODE, node, 0, 0, 0, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_release_node);\n\n \nint zynqmp_pm_get_rpu_mode(u32 node_id, enum rpu_oper_mode *rpu_mode)\n{\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tret = zynqmp_pm_invoke_fn(PM_IOCTL, node_id,\n\t\t\t\t  IOCTL_GET_RPU_OPER_MODE, 0, 0, ret_payload);\n\n\t \n\tif (ret == XST_PM_SUCCESS)\n\t\t*rpu_mode = ret_payload[0];\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_get_rpu_mode);\n\n \nint zynqmp_pm_set_rpu_mode(u32 node_id, enum rpu_oper_mode rpu_mode)\n{\n\treturn zynqmp_pm_invoke_fn(PM_IOCTL, node_id,\n\t\t\t\t   IOCTL_SET_RPU_OPER_MODE, (u32)rpu_mode,\n\t\t\t\t   0, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_set_rpu_mode);\n\n \nint zynqmp_pm_set_tcm_config(u32 node_id, enum rpu_tcm_comb tcm_mode)\n{\n\treturn zynqmp_pm_invoke_fn(PM_IOCTL, node_id,\n\t\t\t\t   IOCTL_TCM_COMB_CONFIG, (u32)tcm_mode, 0,\n\t\t\t\t   NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_set_tcm_config);\n\n \nint zynqmp_pm_force_pwrdwn(const u32 node,\n\t\t\t   const enum zynqmp_pm_request_ack ack)\n{\n\treturn zynqmp_pm_invoke_fn(PM_FORCE_POWERDOWN, node, ack, 0, 0, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_force_pwrdwn);\n\n \nint zynqmp_pm_request_wake(const u32 node,\n\t\t\t   const bool set_addr,\n\t\t\t   const u64 address,\n\t\t\t   const enum zynqmp_pm_request_ack ack)\n{\n\t \n\treturn zynqmp_pm_invoke_fn(PM_REQUEST_WAKEUP, node, address | set_addr,\n\t\t\t\t   address >> 32, ack, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_request_wake);\n\n \nint zynqmp_pm_set_requirement(const u32 node, const u32 capabilities,\n\t\t\t      const u32 qos,\n\t\t\t      const enum zynqmp_pm_request_ack ack)\n{\n\treturn zynqmp_pm_invoke_fn(PM_SET_REQUIREMENT, node, capabilities,\n\t\t\t\t   qos, ack, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_set_requirement);\n\n \nint zynqmp_pm_load_pdi(const u32 src, const u64 address)\n{\n\treturn zynqmp_pm_invoke_fn(PM_LOAD_PDI, src,\n\t\t\t\t   lower_32_bits(address),\n\t\t\t\t   upper_32_bits(address), 0, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_load_pdi);\n\n \nint zynqmp_pm_aes_engine(const u64 address, u32 *out)\n{\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tif (!out)\n\t\treturn -EINVAL;\n\n\tret = zynqmp_pm_invoke_fn(PM_SECURE_AES, upper_32_bits(address),\n\t\t\t\t  lower_32_bits(address),\n\t\t\t\t  0, 0, ret_payload);\n\t*out = ret_payload[1];\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_aes_engine);\n\n \nint zynqmp_pm_sha_hash(const u64 address, const u32 size, const u32 flags)\n{\n\tu32 lower_addr = lower_32_bits(address);\n\tu32 upper_addr = upper_32_bits(address);\n\n\treturn zynqmp_pm_invoke_fn(PM_SECURE_SHA, upper_addr, lower_addr,\n\t\t\t\t   size, flags, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_sha_hash);\n\n \n\nint zynqmp_pm_register_notifier(const u32 node, const u32 event,\n\t\t\t\tconst u32 wake, const u32 enable)\n{\n\treturn zynqmp_pm_invoke_fn(PM_REGISTER_NOTIFIER, node, event,\n\t\t\t\t   wake, enable, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_register_notifier);\n\n \nint zynqmp_pm_system_shutdown(const u32 type, const u32 subtype)\n{\n\treturn zynqmp_pm_invoke_fn(PM_SYSTEM_SHUTDOWN, type, subtype,\n\t\t\t\t   0, 0, NULL);\n}\n\n \nint zynqmp_pm_set_feature_config(enum pm_feature_config_id id, u32 value)\n{\n\treturn zynqmp_pm_invoke_fn(PM_IOCTL, 0, IOCTL_SET_FEATURE_CONFIG,\n\t\t\t\t   id, value, NULL);\n}\n\n \nint zynqmp_pm_get_feature_config(enum pm_feature_config_id id,\n\t\t\t\t u32 *payload)\n{\n\treturn zynqmp_pm_invoke_fn(PM_IOCTL, 0, IOCTL_GET_FEATURE_CONFIG,\n\t\t\t\t   id, 0, payload);\n}\n\n \nint zynqmp_pm_set_sd_config(u32 node, enum pm_sd_config_type config, u32 value)\n{\n\treturn zynqmp_pm_invoke_fn(PM_IOCTL, node, IOCTL_SET_SD_CONFIG,\n\t\t\t\t   config, value, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_set_sd_config);\n\n \nint zynqmp_pm_set_gem_config(u32 node, enum pm_gem_config_type config,\n\t\t\t     u32 value)\n{\n\treturn zynqmp_pm_invoke_fn(PM_IOCTL, node, IOCTL_SET_GEM_CONFIG,\n\t\t\t\t   config, value, NULL);\n}\nEXPORT_SYMBOL_GPL(zynqmp_pm_set_gem_config);\n\n \nstruct zynqmp_pm_shutdown_scope {\n\tconst enum zynqmp_pm_shutdown_subtype subtype;\n\tconst char *name;\n};\n\nstatic struct zynqmp_pm_shutdown_scope shutdown_scopes[] = {\n\t[ZYNQMP_PM_SHUTDOWN_SUBTYPE_SUBSYSTEM] = {\n\t\t.subtype = ZYNQMP_PM_SHUTDOWN_SUBTYPE_SUBSYSTEM,\n\t\t.name = \"subsystem\",\n\t},\n\t[ZYNQMP_PM_SHUTDOWN_SUBTYPE_PS_ONLY] = {\n\t\t.subtype = ZYNQMP_PM_SHUTDOWN_SUBTYPE_PS_ONLY,\n\t\t.name = \"ps_only\",\n\t},\n\t[ZYNQMP_PM_SHUTDOWN_SUBTYPE_SYSTEM] = {\n\t\t.subtype = ZYNQMP_PM_SHUTDOWN_SUBTYPE_SYSTEM,\n\t\t.name = \"system\",\n\t},\n};\n\nstatic struct zynqmp_pm_shutdown_scope *selected_scope =\n\t\t&shutdown_scopes[ZYNQMP_PM_SHUTDOWN_SUBTYPE_SYSTEM];\n\n \nstatic struct zynqmp_pm_shutdown_scope*\n\t\tzynqmp_pm_is_shutdown_scope_valid(const char *scope_string)\n{\n\tint count;\n\n\tfor (count = 0; count < ARRAY_SIZE(shutdown_scopes); count++)\n\t\tif (sysfs_streq(scope_string, shutdown_scopes[count].name))\n\t\t\treturn &shutdown_scopes[count];\n\n\treturn NULL;\n}\n\nstatic ssize_t shutdown_scope_show(struct device *device,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(shutdown_scopes); i++) {\n\t\tif (&shutdown_scopes[i] == selected_scope) {\n\t\t\tstrcat(buf, \"[\");\n\t\t\tstrcat(buf, shutdown_scopes[i].name);\n\t\t\tstrcat(buf, \"]\");\n\t\t} else {\n\t\t\tstrcat(buf, shutdown_scopes[i].name);\n\t\t}\n\t\tstrcat(buf, \" \");\n\t}\n\tstrcat(buf, \"\\n\");\n\n\treturn strlen(buf);\n}\n\nstatic ssize_t shutdown_scope_store(struct device *device,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tint ret;\n\tstruct zynqmp_pm_shutdown_scope *scope;\n\n\tscope = zynqmp_pm_is_shutdown_scope_valid(buf);\n\tif (!scope)\n\t\treturn -EINVAL;\n\n\tret = zynqmp_pm_system_shutdown(ZYNQMP_PM_SHUTDOWN_TYPE_SETSCOPE_ONLY,\n\t\t\t\t\tscope->subtype);\n\tif (ret) {\n\t\tpr_err(\"unable to set shutdown scope %s\\n\", buf);\n\t\treturn ret;\n\t}\n\n\tselected_scope = scope;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(shutdown_scope);\n\nstatic ssize_t health_status_store(struct device *device,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tint ret;\n\tunsigned int value;\n\n\tret = kstrtouint(buf, 10, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tret = zynqmp_pm_set_boot_health_status(value);\n\tif (ret) {\n\t\tdev_err(device, \"unable to set healthy bit value to %u\\n\",\n\t\t\tvalue);\n\t\treturn ret;\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_WO(health_status);\n\nstatic ssize_t ggs_show(struct device *device,\n\t\t\tstruct device_attribute *attr,\n\t\t\tchar *buf,\n\t\t\tu32 reg)\n{\n\tint ret;\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\n\tret = zynqmp_pm_read_ggs(reg, ret_payload);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"0x%x\\n\", ret_payload[1]);\n}\n\nstatic ssize_t ggs_store(struct device *device,\n\t\t\t struct device_attribute *attr,\n\t\t\t const char *buf, size_t count,\n\t\t\t u32 reg)\n{\n\tlong value;\n\tint ret;\n\n\tif (reg >= GSS_NUM_REGS)\n\t\treturn -EINVAL;\n\n\tret = kstrtol(buf, 16, &value);\n\tif (ret) {\n\t\tcount = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tret = zynqmp_pm_write_ggs(reg, value);\n\tif (ret)\n\t\tcount = -EFAULT;\nerr:\n\treturn count;\n}\n\n \n#define GGS0_SHOW(N)\t\t\t\t\t\t\\\n\tssize_t ggs##N##_show(struct device *device,\t\t\\\n\t\t\t      struct device_attribute *attr,\t\\\n\t\t\t      char *buf)\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\treturn ggs_show(device, attr, buf, N);\t\t\\\n\t}\n\nstatic GGS0_SHOW(0);\nstatic GGS0_SHOW(1);\nstatic GGS0_SHOW(2);\nstatic GGS0_SHOW(3);\n\n \n#define GGS0_STORE(N)\t\t\t\t\t\t\\\n\tssize_t ggs##N##_store(struct device *device,\t\t\\\n\t\t\t       struct device_attribute *attr,\t\\\n\t\t\t       const char *buf,\t\t\t\\\n\t\t\t       size_t count)\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\treturn ggs_store(device, attr, buf, count, N);\t\\\n\t}\n\nstatic GGS0_STORE(0);\nstatic GGS0_STORE(1);\nstatic GGS0_STORE(2);\nstatic GGS0_STORE(3);\n\nstatic ssize_t pggs_show(struct device *device,\n\t\t\t struct device_attribute *attr,\n\t\t\t char *buf,\n\t\t\t u32 reg)\n{\n\tint ret;\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\n\tret = zynqmp_pm_read_pggs(reg, ret_payload);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"0x%x\\n\", ret_payload[1]);\n}\n\nstatic ssize_t pggs_store(struct device *device,\n\t\t\t  struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count,\n\t\t\t  u32 reg)\n{\n\tlong value;\n\tint ret;\n\n\tif (reg >= GSS_NUM_REGS)\n\t\treturn -EINVAL;\n\n\tret = kstrtol(buf, 16, &value);\n\tif (ret) {\n\t\tcount = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tret = zynqmp_pm_write_pggs(reg, value);\n\tif (ret)\n\t\tcount = -EFAULT;\n\nerr:\n\treturn count;\n}\n\n#define PGGS0_SHOW(N)\t\t\t\t\t\t\\\n\tssize_t pggs##N##_show(struct device *device,\t\t\\\n\t\t\t       struct device_attribute *attr,\t\\\n\t\t\t       char *buf)\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\treturn pggs_show(device, attr, buf, N);\t\t\\\n\t}\n\n#define PGGS0_STORE(N)\t\t\t\t\t\t\\\n\tssize_t pggs##N##_store(struct device *device,\t\t\\\n\t\t\t\tstruct device_attribute *attr,\t\\\n\t\t\t\tconst char *buf,\t\t\\\n\t\t\t\tsize_t count)\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\treturn pggs_store(device, attr, buf, count, N);\t\\\n\t}\n\n \nstatic PGGS0_SHOW(0);\nstatic PGGS0_SHOW(1);\nstatic PGGS0_SHOW(2);\nstatic PGGS0_SHOW(3);\n\n \nstatic PGGS0_STORE(0);\nstatic PGGS0_STORE(1);\nstatic PGGS0_STORE(2);\nstatic PGGS0_STORE(3);\n\n \nstatic DEVICE_ATTR_RW(ggs0);\nstatic DEVICE_ATTR_RW(ggs1);\nstatic DEVICE_ATTR_RW(ggs2);\nstatic DEVICE_ATTR_RW(ggs3);\n\n \nstatic DEVICE_ATTR_RW(pggs0);\nstatic DEVICE_ATTR_RW(pggs1);\nstatic DEVICE_ATTR_RW(pggs2);\nstatic DEVICE_ATTR_RW(pggs3);\n\nstatic ssize_t feature_config_id_show(struct device *device,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct zynqmp_devinfo *devinfo = dev_get_drvdata(device);\n\n\treturn sysfs_emit(buf, \"%d\\n\", devinfo->feature_conf_id);\n}\n\nstatic ssize_t feature_config_id_store(struct device *device,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tu32 config_id;\n\tint ret;\n\tstruct zynqmp_devinfo *devinfo = dev_get_drvdata(device);\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tret = kstrtou32(buf, 10, &config_id);\n\tif (ret)\n\t\treturn ret;\n\n\tdevinfo->feature_conf_id = config_id;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(feature_config_id);\n\nstatic ssize_t feature_config_value_show(struct device *device,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tint ret;\n\tu32 ret_payload[PAYLOAD_ARG_CNT];\n\tstruct zynqmp_devinfo *devinfo = dev_get_drvdata(device);\n\n\tret = zynqmp_pm_get_feature_config(devinfo->feature_conf_id,\n\t\t\t\t\t   ret_payload);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", ret_payload[1]);\n}\n\nstatic ssize_t feature_config_value_store(struct device *device,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tu32 value;\n\tint ret;\n\tstruct zynqmp_devinfo *devinfo = dev_get_drvdata(device);\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tret = kstrtou32(buf, 10, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tret = zynqmp_pm_set_feature_config(devinfo->feature_conf_id,\n\t\t\t\t\t   value);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(feature_config_value);\n\nstatic struct attribute *zynqmp_firmware_attrs[] = {\n\t&dev_attr_ggs0.attr,\n\t&dev_attr_ggs1.attr,\n\t&dev_attr_ggs2.attr,\n\t&dev_attr_ggs3.attr,\n\t&dev_attr_pggs0.attr,\n\t&dev_attr_pggs1.attr,\n\t&dev_attr_pggs2.attr,\n\t&dev_attr_pggs3.attr,\n\t&dev_attr_shutdown_scope.attr,\n\t&dev_attr_health_status.attr,\n\t&dev_attr_feature_config_id.attr,\n\t&dev_attr_feature_config_value.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(zynqmp_firmware);\n\nstatic int zynqmp_firmware_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np;\n\tstruct zynqmp_devinfo *devinfo;\n\tint ret;\n\n\tret = get_set_conduit_method(dev->of_node);\n\tif (ret)\n\t\treturn ret;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"xlnx,zynqmp\");\n\tif (!np) {\n\t\tnp = of_find_compatible_node(NULL, NULL, \"xlnx,versal\");\n\t\tif (!np)\n\t\t\treturn 0;\n\n\t\tfeature_check_enabled = true;\n\t}\n\n\tif (!feature_check_enabled) {\n\t\tret = do_feature_check_call(PM_FEATURE_CHECK);\n\t\tif (ret >= 0)\n\t\t\tfeature_check_enabled = true;\n\t}\n\n\tof_node_put(np);\n\n\tdevinfo = devm_kzalloc(dev, sizeof(*devinfo), GFP_KERNEL);\n\tif (!devinfo)\n\t\treturn -ENOMEM;\n\n\tdevinfo->dev = dev;\n\n\tplatform_set_drvdata(pdev, devinfo);\n\n\t \n\tret = zynqmp_pm_get_api_version(&pm_api_version);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pm_api_version < ZYNQMP_PM_VERSION) {\n\t\tpanic(\"%s Platform Management API version error. Expected: v%d.%d - Found: v%d.%d\\n\",\n\t\t      __func__,\n\t\t      ZYNQMP_PM_VERSION_MAJOR, ZYNQMP_PM_VERSION_MINOR,\n\t\t      pm_api_version >> 16, pm_api_version & 0xFFFF);\n\t}\n\n\tpr_info(\"%s Platform Management API v%d.%d\\n\", __func__,\n\t\tpm_api_version >> 16, pm_api_version & 0xFFFF);\n\n\t \n\tret = zynqmp_pm_get_family_info(&pm_family_code, &pm_sub_family_code);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = zynqmp_pm_get_trustzone_version(&pm_tz_version);\n\tif (ret)\n\t\tpanic(\"Legacy trustzone found without version support\\n\");\n\n\tif (pm_tz_version < ZYNQMP_TZ_VERSION)\n\t\tpanic(\"%s Trustzone version error. Expected: v%d.%d - Found: v%d.%d\\n\",\n\t\t      __func__,\n\t\t      ZYNQMP_TZ_VERSION_MAJOR, ZYNQMP_TZ_VERSION_MINOR,\n\t\t      pm_tz_version >> 16, pm_tz_version & 0xFFFF);\n\n\tpr_info(\"%s Trustzone version v%d.%d\\n\", __func__,\n\t\tpm_tz_version >> 16, pm_tz_version & 0xFFFF);\n\n\tret = mfd_add_devices(&pdev->dev, PLATFORM_DEVID_NONE, firmware_devs,\n\t\t\t      ARRAY_SIZE(firmware_devs), NULL, 0, NULL);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add MFD devices %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tzynqmp_pm_api_debugfs_init();\n\n\tnp = of_find_compatible_node(NULL, NULL, \"xlnx,versal\");\n\tif (np) {\n\t\tem_dev = platform_device_register_data(&pdev->dev, \"xlnx_event_manager\",\n\t\t\t\t\t\t       -1, NULL, 0);\n\t\tif (IS_ERR(em_dev))\n\t\t\tdev_err_probe(&pdev->dev, PTR_ERR(em_dev), \"EM register fail with error\\n\");\n\t}\n\tof_node_put(np);\n\n\treturn of_platform_populate(dev->of_node, NULL, NULL, dev);\n}\n\nstatic int zynqmp_firmware_remove(struct platform_device *pdev)\n{\n\tstruct pm_api_feature_data *feature_data;\n\tstruct hlist_node *tmp;\n\tint i;\n\n\tmfd_remove_devices(&pdev->dev);\n\tzynqmp_pm_api_debugfs_exit();\n\n\thash_for_each_safe(pm_api_features_map, i, tmp, feature_data, hentry) {\n\t\thash_del(&feature_data->hentry);\n\t\tkfree(feature_data);\n\t}\n\n\tplatform_device_unregister(em_dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id zynqmp_firmware_of_match[] = {\n\t{.compatible = \"xlnx,zynqmp-firmware\"},\n\t{.compatible = \"xlnx,versal-firmware\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, zynqmp_firmware_of_match);\n\nstatic struct platform_driver zynqmp_firmware_driver = {\n\t.driver = {\n\t\t.name = \"zynqmp_firmware\",\n\t\t.of_match_table = zynqmp_firmware_of_match,\n\t\t.dev_groups = zynqmp_firmware_groups,\n\t},\n\t.probe = zynqmp_firmware_probe,\n\t.remove = zynqmp_firmware_remove,\n};\nmodule_platform_driver(zynqmp_firmware_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}