{
  "module_name": "memmap.c",
  "hash_id": "93277b12d574ccb4f0f4f5f41a256557fb26c32dea3d94224bac84f4a71165c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/memmap.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/firmware-map.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/memblock.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\n \n\n \nstruct firmware_map_entry {\n\t \n\tu64\t\t\tstart;\t \n\tu64\t\t\tend;\t \n\tconst char\t\t*type;\t \n\tstruct list_head\tlist;\t \n\tstruct kobject\t\tkobj;    \n};\n\n \nstatic ssize_t memmap_attr_show(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr, char *buf);\nstatic ssize_t start_show(struct firmware_map_entry *entry, char *buf);\nstatic ssize_t end_show(struct firmware_map_entry *entry, char *buf);\nstatic ssize_t type_show(struct firmware_map_entry *entry, char *buf);\n\nstatic struct firmware_map_entry * __meminit\nfirmware_map_find_entry(u64 start, u64 end, const char *type);\n\n \n\nstruct memmap_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct firmware_map_entry *entry, char *buf);\n};\n\nstatic struct memmap_attribute memmap_start_attr = __ATTR_RO(start);\nstatic struct memmap_attribute memmap_end_attr   = __ATTR_RO(end);\nstatic struct memmap_attribute memmap_type_attr  = __ATTR_RO(type);\n\n \nstatic struct attribute *def_attrs[] = {\n\t&memmap_start_attr.attr,\n\t&memmap_end_attr.attr,\n\t&memmap_type_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(def);\n\nstatic const struct sysfs_ops memmap_attr_ops = {\n\t.show = memmap_attr_show,\n};\n\n \nstatic LIST_HEAD(map_entries);\nstatic DEFINE_SPINLOCK(map_entries_lock);\n\n \nstatic LIST_HEAD(map_entries_bootmem);\nstatic DEFINE_SPINLOCK(map_entries_bootmem_lock);\n\n\nstatic inline struct firmware_map_entry *\nto_memmap_entry(struct kobject *kobj)\n{\n\treturn container_of(kobj, struct firmware_map_entry, kobj);\n}\n\nstatic void __meminit release_firmware_map_entry(struct kobject *kobj)\n{\n\tstruct firmware_map_entry *entry = to_memmap_entry(kobj);\n\n\tif (PageReserved(virt_to_page(entry))) {\n\t\t \n\t\tspin_lock(&map_entries_bootmem_lock);\n\t\tlist_add(&entry->list, &map_entries_bootmem);\n\t\tspin_unlock(&map_entries_bootmem_lock);\n\n\t\treturn;\n\t}\n\n\tkfree(entry);\n}\n\nstatic struct kobj_type __refdata memmap_ktype = {\n\t.release\t= release_firmware_map_entry,\n\t.sysfs_ops\t= &memmap_attr_ops,\n\t.default_groups\t= def_groups,\n};\n\n \n\n \nstatic int firmware_map_add_entry(u64 start, u64 end,\n\t\t\t\t  const char *type,\n\t\t\t\t  struct firmware_map_entry *entry)\n{\n\tBUG_ON(start > end);\n\n\tentry->start = start;\n\tentry->end = end - 1;\n\tentry->type = type;\n\tINIT_LIST_HEAD(&entry->list);\n\tkobject_init(&entry->kobj, &memmap_ktype);\n\n\tspin_lock(&map_entries_lock);\n\tlist_add_tail(&entry->list, &map_entries);\n\tspin_unlock(&map_entries_lock);\n\n\treturn 0;\n}\n\n \nstatic inline void firmware_map_remove_entry(struct firmware_map_entry *entry)\n{\n\tlist_del(&entry->list);\n}\n\n \nstatic int add_sysfs_fw_map_entry(struct firmware_map_entry *entry)\n{\n\tstatic int map_entries_nr;\n\tstatic struct kset *mmap_kset;\n\n\tif (entry->kobj.state_in_sysfs)\n\t\treturn -EEXIST;\n\n\tif (!mmap_kset) {\n\t\tmmap_kset = kset_create_and_add(\"memmap\", NULL, firmware_kobj);\n\t\tif (!mmap_kset)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tentry->kobj.kset = mmap_kset;\n\tif (kobject_add(&entry->kobj, NULL, \"%d\", map_entries_nr++))\n\t\tkobject_put(&entry->kobj);\n\n\treturn 0;\n}\n\n \nstatic inline void remove_sysfs_fw_map_entry(struct firmware_map_entry *entry)\n{\n\tkobject_put(&entry->kobj);\n}\n\n \nstatic struct firmware_map_entry * __meminit\nfirmware_map_find_entry_in_list(u64 start, u64 end, const char *type,\n\t\t\t\tstruct list_head *list)\n{\n\tstruct firmware_map_entry *entry;\n\n\tlist_for_each_entry(entry, list, list)\n\t\tif ((entry->start == start) && (entry->end == end) &&\n\t\t    (!strcmp(entry->type, type))) {\n\t\t\treturn entry;\n\t\t}\n\n\treturn NULL;\n}\n\n \nstatic struct firmware_map_entry * __meminit\nfirmware_map_find_entry(u64 start, u64 end, const char *type)\n{\n\treturn firmware_map_find_entry_in_list(start, end, type, &map_entries);\n}\n\n \nstatic struct firmware_map_entry * __meminit\nfirmware_map_find_entry_bootmem(u64 start, u64 end, const char *type)\n{\n\treturn firmware_map_find_entry_in_list(start, end, type,\n\t\t\t\t\t       &map_entries_bootmem);\n}\n\n \nint __meminit firmware_map_add_hotplug(u64 start, u64 end, const char *type)\n{\n\tstruct firmware_map_entry *entry;\n\n\tentry = firmware_map_find_entry(start, end - 1, type);\n\tif (entry)\n\t\treturn 0;\n\n\tentry = firmware_map_find_entry_bootmem(start, end - 1, type);\n\tif (!entry) {\n\t\tentry = kzalloc(sizeof(struct firmware_map_entry), GFP_ATOMIC);\n\t\tif (!entry)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\t \n\t\tspin_lock(&map_entries_bootmem_lock);\n\t\tlist_del(&entry->list);\n\t\tspin_unlock(&map_entries_bootmem_lock);\n\n\t\tmemset(entry, 0, sizeof(*entry));\n\t}\n\n\tfirmware_map_add_entry(start, end, type, entry);\n\t \n\tadd_sysfs_fw_map_entry(entry);\n\n\treturn 0;\n}\n\n \nint __init firmware_map_add_early(u64 start, u64 end, const char *type)\n{\n\tstruct firmware_map_entry *entry;\n\n\tentry = memblock_alloc(sizeof(struct firmware_map_entry),\n\t\t\t       SMP_CACHE_BYTES);\n\tif (WARN_ON(!entry))\n\t\treturn -ENOMEM;\n\n\treturn firmware_map_add_entry(start, end, type, entry);\n}\n\n \nint __meminit firmware_map_remove(u64 start, u64 end, const char *type)\n{\n\tstruct firmware_map_entry *entry;\n\n\tspin_lock(&map_entries_lock);\n\tentry = firmware_map_find_entry(start, end - 1, type);\n\tif (!entry) {\n\t\tspin_unlock(&map_entries_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tfirmware_map_remove_entry(entry);\n\tspin_unlock(&map_entries_lock);\n\n\t \n\tremove_sysfs_fw_map_entry(entry);\n\n\treturn 0;\n}\n\n \n\nstatic ssize_t start_show(struct firmware_map_entry *entry, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"0x%llx\\n\",\n\t\t(unsigned long long)entry->start);\n}\n\nstatic ssize_t end_show(struct firmware_map_entry *entry, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"0x%llx\\n\",\n\t\t(unsigned long long)entry->end);\n}\n\nstatic ssize_t type_show(struct firmware_map_entry *entry, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", entry->type);\n}\n\nstatic inline struct memmap_attribute *to_memmap_attr(struct attribute *attr)\n{\n\treturn container_of(attr, struct memmap_attribute, attr);\n}\n\nstatic ssize_t memmap_attr_show(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr, char *buf)\n{\n\tstruct firmware_map_entry *entry = to_memmap_entry(kobj);\n\tstruct memmap_attribute *memmap_attr = to_memmap_attr(attr);\n\n\treturn memmap_attr->show(entry, buf);\n}\n\n \nstatic int __init firmware_memmap_init(void)\n{\n\tstruct firmware_map_entry *entry;\n\n\tlist_for_each_entry(entry, &map_entries, list)\n\t\tadd_sysfs_fw_map_entry(entry);\n\n\treturn 0;\n}\nlate_initcall(firmware_memmap_init);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}