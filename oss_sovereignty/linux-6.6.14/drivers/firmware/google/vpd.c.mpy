{
  "module_name": "vpd.c",
  "hash_id": "39207ce9cd62aa3d931de746cacc5e5032bed4ba6aff1afab0cbfef19f18c948",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/google/vpd.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/kobject.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n\n#include \"coreboot_table.h\"\n#include \"vpd_decode.h\"\n\n#define CB_TAG_VPD      0x2c\n#define VPD_CBMEM_MAGIC 0x43524f53\n\nstatic struct kobject *vpd_kobj;\n\nstruct vpd_cbmem {\n\tu32 magic;\n\tu32 version;\n\tu32 ro_size;\n\tu32 rw_size;\n\tu8  blob[];\n};\n\nstruct vpd_section {\n\tbool enabled;\n\tconst char *name;\n\tchar *raw_name;                 \n\tstruct kobject *kobj;           \n\tchar *baseaddr;\n\tstruct bin_attribute bin_attr;  \n\tstruct list_head attribs;       \n};\n\nstruct vpd_attrib_info {\n\tchar *key;\n\tconst char *value;\n\tstruct bin_attribute bin_attr;\n\tstruct list_head list;\n};\n\nstatic struct vpd_section ro_vpd;\nstatic struct vpd_section rw_vpd;\n\nstatic ssize_t vpd_attrib_read(struct file *filp, struct kobject *kobp,\n\t\t\t       struct bin_attribute *bin_attr, char *buf,\n\t\t\t       loff_t pos, size_t count)\n{\n\tstruct vpd_attrib_info *info = bin_attr->private;\n\n\treturn memory_read_from_buffer(buf, count, &pos, info->value,\n\t\t\t\t       info->bin_attr.size);\n}\n\n \nstatic int vpd_section_check_key_name(const u8 *key, s32 key_len)\n{\n\tint c;\n\n\twhile (key_len-- > 0) {\n\t\tc = *key++;\n\n\t\tif (!isalnum(c) && c != '_')\n\t\t\treturn VPD_FAIL;\n\t}\n\n\treturn VPD_OK;\n}\n\nstatic int vpd_section_attrib_add(const u8 *key, u32 key_len,\n\t\t\t\t  const u8 *value, u32 value_len,\n\t\t\t\t  void *arg)\n{\n\tint ret;\n\tstruct vpd_section *sec = arg;\n\tstruct vpd_attrib_info *info;\n\n\t \n\tif (vpd_section_check_key_name(key, key_len) != VPD_OK)\n\t\treturn VPD_OK;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->key = kstrndup(key, key_len, GFP_KERNEL);\n\tif (!info->key) {\n\t\tret = -ENOMEM;\n\t\tgoto free_info;\n\t}\n\n\tsysfs_bin_attr_init(&info->bin_attr);\n\tinfo->bin_attr.attr.name = info->key;\n\tinfo->bin_attr.attr.mode = 0444;\n\tinfo->bin_attr.size = value_len;\n\tinfo->bin_attr.read = vpd_attrib_read;\n\tinfo->bin_attr.private = info;\n\n\tinfo->value = value;\n\n\tINIT_LIST_HEAD(&info->list);\n\n\tret = sysfs_create_bin_file(sec->kobj, &info->bin_attr);\n\tif (ret)\n\t\tgoto free_info_key;\n\n\tlist_add_tail(&info->list, &sec->attribs);\n\treturn 0;\n\nfree_info_key:\n\tkfree(info->key);\nfree_info:\n\tkfree(info);\n\n\treturn ret;\n}\n\nstatic void vpd_section_attrib_destroy(struct vpd_section *sec)\n{\n\tstruct vpd_attrib_info *info;\n\tstruct vpd_attrib_info *temp;\n\n\tlist_for_each_entry_safe(info, temp, &sec->attribs, list) {\n\t\tsysfs_remove_bin_file(sec->kobj, &info->bin_attr);\n\t\tkfree(info->key);\n\t\tkfree(info);\n\t}\n}\n\nstatic ssize_t vpd_section_read(struct file *filp, struct kobject *kobp,\n\t\t\t\tstruct bin_attribute *bin_attr, char *buf,\n\t\t\t\tloff_t pos, size_t count)\n{\n\tstruct vpd_section *sec = bin_attr->private;\n\n\treturn memory_read_from_buffer(buf, count, &pos, sec->baseaddr,\n\t\t\t\t       sec->bin_attr.size);\n}\n\nstatic int vpd_section_create_attribs(struct vpd_section *sec)\n{\n\ts32 consumed;\n\tint ret;\n\n\tconsumed = 0;\n\tdo {\n\t\tret = vpd_decode_string(sec->bin_attr.size, sec->baseaddr,\n\t\t\t\t\t&consumed, vpd_section_attrib_add, sec);\n\t} while (ret == VPD_OK);\n\n\treturn 0;\n}\n\nstatic int vpd_section_init(const char *name, struct vpd_section *sec,\n\t\t\t    phys_addr_t physaddr, size_t size)\n{\n\tint err;\n\n\tsec->baseaddr = memremap(physaddr, size, MEMREMAP_WB);\n\tif (!sec->baseaddr)\n\t\treturn -ENOMEM;\n\n\tsec->name = name;\n\n\t \n\tsec->raw_name = kasprintf(GFP_KERNEL, \"%s_raw\", name);\n\tif (!sec->raw_name) {\n\t\terr = -ENOMEM;\n\t\tgoto err_memunmap;\n\t}\n\n\tsysfs_bin_attr_init(&sec->bin_attr);\n\tsec->bin_attr.attr.name = sec->raw_name;\n\tsec->bin_attr.attr.mode = 0444;\n\tsec->bin_attr.size = size;\n\tsec->bin_attr.read = vpd_section_read;\n\tsec->bin_attr.private = sec;\n\n\terr = sysfs_create_bin_file(vpd_kobj, &sec->bin_attr);\n\tif (err)\n\t\tgoto err_free_raw_name;\n\n\tsec->kobj = kobject_create_and_add(name, vpd_kobj);\n\tif (!sec->kobj) {\n\t\terr = -EINVAL;\n\t\tgoto err_sysfs_remove;\n\t}\n\n\tINIT_LIST_HEAD(&sec->attribs);\n\tvpd_section_create_attribs(sec);\n\n\tsec->enabled = true;\n\n\treturn 0;\n\nerr_sysfs_remove:\n\tsysfs_remove_bin_file(vpd_kobj, &sec->bin_attr);\nerr_free_raw_name:\n\tkfree(sec->raw_name);\nerr_memunmap:\n\tmemunmap(sec->baseaddr);\n\treturn err;\n}\n\nstatic int vpd_section_destroy(struct vpd_section *sec)\n{\n\tif (sec->enabled) {\n\t\tvpd_section_attrib_destroy(sec);\n\t\tkobject_put(sec->kobj);\n\t\tsysfs_remove_bin_file(vpd_kobj, &sec->bin_attr);\n\t\tkfree(sec->raw_name);\n\t\tmemunmap(sec->baseaddr);\n\t\tsec->enabled = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int vpd_sections_init(phys_addr_t physaddr)\n{\n\tstruct vpd_cbmem *temp;\n\tstruct vpd_cbmem header;\n\tint ret = 0;\n\n\ttemp = memremap(physaddr, sizeof(struct vpd_cbmem), MEMREMAP_WB);\n\tif (!temp)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&header, temp, sizeof(struct vpd_cbmem));\n\tmemunmap(temp);\n\n\tif (header.magic != VPD_CBMEM_MAGIC)\n\t\treturn -ENODEV;\n\n\tif (header.ro_size) {\n\t\tret = vpd_section_init(\"ro\", &ro_vpd,\n\t\t\t\t       physaddr + sizeof(struct vpd_cbmem),\n\t\t\t\t       header.ro_size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (header.rw_size) {\n\t\tret = vpd_section_init(\"rw\", &rw_vpd,\n\t\t\t\t       physaddr + sizeof(struct vpd_cbmem) +\n\t\t\t\t       header.ro_size, header.rw_size);\n\t\tif (ret) {\n\t\t\tvpd_section_destroy(&ro_vpd);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int vpd_probe(struct coreboot_device *dev)\n{\n\tint ret;\n\n\tvpd_kobj = kobject_create_and_add(\"vpd\", firmware_kobj);\n\tif (!vpd_kobj)\n\t\treturn -ENOMEM;\n\n\tret = vpd_sections_init(dev->cbmem_ref.cbmem_addr);\n\tif (ret) {\n\t\tkobject_put(vpd_kobj);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void vpd_remove(struct coreboot_device *dev)\n{\n\tvpd_section_destroy(&ro_vpd);\n\tvpd_section_destroy(&rw_vpd);\n\n\tkobject_put(vpd_kobj);\n}\n\nstatic struct coreboot_driver vpd_driver = {\n\t.probe = vpd_probe,\n\t.remove = vpd_remove,\n\t.drv = {\n\t\t.name = \"vpd\",\n\t},\n\t.tag = CB_TAG_VPD,\n};\nmodule_coreboot_driver(vpd_driver);\n\nMODULE_AUTHOR(\"Google, Inc.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}