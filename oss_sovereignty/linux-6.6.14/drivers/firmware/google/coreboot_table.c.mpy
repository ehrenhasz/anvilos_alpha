{
  "module_name": "coreboot_table.c",
  "hash_id": "63078af1da6ba6e600e5a8832e3c2df477fff402282f33fca156b855e02d0988",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/google/coreboot_table.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"coreboot_table.h\"\n\n#define CB_DEV(d) container_of(d, struct coreboot_device, dev)\n#define CB_DRV(d) container_of(d, struct coreboot_driver, drv)\n\nstatic int coreboot_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct coreboot_device *device = CB_DEV(dev);\n\tstruct coreboot_driver *driver = CB_DRV(drv);\n\n\treturn device->entry.tag == driver->tag;\n}\n\nstatic int coreboot_bus_probe(struct device *dev)\n{\n\tint ret = -ENODEV;\n\tstruct coreboot_device *device = CB_DEV(dev);\n\tstruct coreboot_driver *driver = CB_DRV(dev->driver);\n\n\tif (driver->probe)\n\t\tret = driver->probe(device);\n\n\treturn ret;\n}\n\nstatic void coreboot_bus_remove(struct device *dev)\n{\n\tstruct coreboot_device *device = CB_DEV(dev);\n\tstruct coreboot_driver *driver = CB_DRV(dev->driver);\n\n\tif (driver->remove)\n\t\tdriver->remove(device);\n}\n\nstatic struct bus_type coreboot_bus_type = {\n\t.name\t\t= \"coreboot\",\n\t.match\t\t= coreboot_bus_match,\n\t.probe\t\t= coreboot_bus_probe,\n\t.remove\t\t= coreboot_bus_remove,\n};\n\nstatic void coreboot_device_release(struct device *dev)\n{\n\tstruct coreboot_device *device = CB_DEV(dev);\n\n\tkfree(device);\n}\n\nint coreboot_driver_register(struct coreboot_driver *driver)\n{\n\tdriver->drv.bus = &coreboot_bus_type;\n\n\treturn driver_register(&driver->drv);\n}\nEXPORT_SYMBOL(coreboot_driver_register);\n\nvoid coreboot_driver_unregister(struct coreboot_driver *driver)\n{\n\tdriver_unregister(&driver->drv);\n}\nEXPORT_SYMBOL(coreboot_driver_unregister);\n\nstatic int coreboot_table_populate(struct device *dev, void *ptr)\n{\n\tint i, ret;\n\tvoid *ptr_entry;\n\tstruct coreboot_device *device;\n\tstruct coreboot_table_entry *entry;\n\tstruct coreboot_table_header *header = ptr;\n\n\tptr_entry = ptr + header->header_bytes;\n\tfor (i = 0; i < header->table_entries; i++) {\n\t\tentry = ptr_entry;\n\n\t\tif (entry->size < sizeof(*entry)) {\n\t\t\tdev_warn(dev, \"coreboot table entry too small!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdevice = kzalloc(sizeof(device->dev) + entry->size, GFP_KERNEL);\n\t\tif (!device)\n\t\t\treturn -ENOMEM;\n\n\t\tdevice->dev.parent = dev;\n\t\tdevice->dev.bus = &coreboot_bus_type;\n\t\tdevice->dev.release = coreboot_device_release;\n\t\tmemcpy(device->raw, ptr_entry, entry->size);\n\n\t\tswitch (device->entry.tag) {\n\t\tcase LB_TAG_CBMEM_ENTRY:\n\t\t\tdev_set_name(&device->dev, \"cbmem-%08x\",\n\t\t\t\t     device->cbmem_entry.id);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_set_name(&device->dev, \"coreboot%d\", i);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = device_register(&device->dev);\n\t\tif (ret) {\n\t\t\tput_device(&device->dev);\n\t\t\treturn ret;\n\t\t}\n\n\t\tptr_entry += entry->size;\n\t}\n\n\treturn 0;\n}\n\nstatic int coreboot_table_probe(struct platform_device *pdev)\n{\n\tresource_size_t len;\n\tstruct coreboot_table_header *header;\n\tstruct resource *res;\n\tstruct device *dev = &pdev->dev;\n\tvoid *ptr;\n\tint ret;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tlen = resource_size(res);\n\tif (!res->start || !len)\n\t\treturn -EINVAL;\n\n\t \n\theader = memremap(res->start, sizeof(*header), MEMREMAP_WB);\n\tif (!header)\n\t\treturn -ENOMEM;\n\n\tlen = header->header_bytes + header->table_bytes;\n\tret = strncmp(header->signature, \"LBIO\", sizeof(header->signature));\n\tmemunmap(header);\n\tif (ret) {\n\t\tdev_warn(dev, \"coreboot table missing or corrupt!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tptr = memremap(res->start, len, MEMREMAP_WB);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tret = coreboot_table_populate(dev, ptr);\n\n\tmemunmap(ptr);\n\n\treturn ret;\n}\n\nstatic int __cb_dev_unregister(struct device *dev, void *dummy)\n{\n\tdevice_unregister(dev);\n\treturn 0;\n}\n\nstatic int coreboot_table_remove(struct platform_device *pdev)\n{\n\tbus_for_each_dev(&coreboot_bus_type, NULL, NULL, __cb_dev_unregister);\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id cros_coreboot_acpi_match[] = {\n\t{ \"GOOGCB00\", 0 },\n\t{ \"BOOT0000\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, cros_coreboot_acpi_match);\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id coreboot_of_match[] = {\n\t{ .compatible = \"coreboot\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, coreboot_of_match);\n#endif\n\nstatic struct platform_driver coreboot_table_driver = {\n\t.probe = coreboot_table_probe,\n\t.remove = coreboot_table_remove,\n\t.driver = {\n\t\t.name = \"coreboot_table\",\n\t\t.acpi_match_table = ACPI_PTR(cros_coreboot_acpi_match),\n\t\t.of_match_table = of_match_ptr(coreboot_of_match),\n\t},\n};\n\nstatic int __init coreboot_table_driver_init(void)\n{\n\tint ret;\n\n\tret = bus_register(&coreboot_bus_type);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&coreboot_table_driver);\n\tif (ret) {\n\t\tbus_unregister(&coreboot_bus_type);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit coreboot_table_driver_exit(void)\n{\n\tplatform_driver_unregister(&coreboot_table_driver);\n\tbus_unregister(&coreboot_bus_type);\n}\n\nmodule_init(coreboot_table_driver_init);\nmodule_exit(coreboot_table_driver_exit);\n\nMODULE_AUTHOR(\"Google, Inc.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}