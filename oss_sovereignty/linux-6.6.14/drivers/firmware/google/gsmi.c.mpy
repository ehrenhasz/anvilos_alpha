{
  "module_name": "gsmi.c",
  "hash_id": "53643df47368ffeb565c2ee324acbd985a8f6850b4776430b74df11cc2d1e316",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/google/gsmi.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/dma-mapping.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/panic_notifier.h>\n#include <linux/ioctl.h>\n#include <linux/acpi.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/dmi.h>\n#include <linux/kdebug.h>\n#include <linux/reboot.h>\n#include <linux/efi.h>\n#include <linux/module.h>\n#include <linux/ucs2_string.h>\n#include <linux/suspend.h>\n\n#define GSMI_SHUTDOWN_CLEAN\t0\t \n \n#define GSMI_SHUTDOWN_NMIWDT\t1\t \n#define GSMI_SHUTDOWN_PANIC\t2\t \n#define GSMI_SHUTDOWN_OOPS\t3\t \n#define GSMI_SHUTDOWN_DIE\t4\t \n#define GSMI_SHUTDOWN_MCE\t5\t \n#define GSMI_SHUTDOWN_SOFTWDT\t6\t \n#define GSMI_SHUTDOWN_MBE\t7\t \n#define GSMI_SHUTDOWN_TRIPLE\t8\t \n\n#define DRIVER_VERSION\t\t\"1.0\"\n#define GSMI_GUID_SIZE\t\t16\n#define GSMI_BUF_SIZE\t\t1024\n#define GSMI_BUF_ALIGN\t\tsizeof(u64)\n#define GSMI_CALLBACK\t\t0xef\n\n \n#define GSMI_SUCCESS\t\t0x00\n#define GSMI_UNSUPPORTED2\t0x03\n#define GSMI_LOG_FULL\t\t0x0b\n#define GSMI_VAR_NOT_FOUND\t0x0e\n#define GSMI_HANDSHAKE_SPIN\t0x7d\n#define GSMI_HANDSHAKE_CF\t0x7e\n#define GSMI_HANDSHAKE_NONE\t0x7f\n#define GSMI_INVALID_PARAMETER\t0x82\n#define GSMI_UNSUPPORTED\t0x83\n#define GSMI_BUFFER_TOO_SMALL\t0x85\n#define GSMI_NOT_READY\t\t0x86\n#define GSMI_DEVICE_ERROR\t0x87\n#define GSMI_NOT_FOUND\t\t0x8e\n\n#define QUIRKY_BOARD_HASH 0x78a30a50\n\n \n#define GSMI_CMD_GET_NVRAM_VAR\t\t0x01\n#define GSMI_CMD_GET_NEXT_VAR\t\t0x02\n#define GSMI_CMD_SET_NVRAM_VAR\t\t0x03\n#define GSMI_CMD_SET_EVENT_LOG\t\t0x08\n#define GSMI_CMD_CLEAR_EVENT_LOG\t0x09\n#define GSMI_CMD_LOG_S0IX_SUSPEND\t0x0a\n#define GSMI_CMD_LOG_S0IX_RESUME\t0x0b\n#define GSMI_CMD_CLEAR_CONFIG\t\t0x20\n#define GSMI_CMD_HANDSHAKE_TYPE\t\t0xC1\n#define GSMI_CMD_RESERVED\t\t0xff\n\n \n#define GSMI_LOG_ENTRY_TYPE_KERNEL     0xDEAD\n\n \nstruct gsmi_buf {\n\tu8 *start;\t\t\t \n\tsize_t length;\t\t\t \n\tu32 address;\t\t\t \n};\n\nstatic struct gsmi_device {\n\tstruct platform_device *pdev;\t \n\tstruct gsmi_buf *name_buf;\t \n\tstruct gsmi_buf *data_buf;\t \n\tstruct gsmi_buf *param_buf;\t \n\tspinlock_t lock;\t\t \n\tu16 smi_cmd;\t\t\t \n\tint handshake_type;\t\t \n\tstruct kmem_cache *mem_pool;\t \n} gsmi_dev;\n\n \nstruct gsmi_nvram_var_param {\n\tefi_guid_t\tguid;\n\tu32\t\tname_ptr;\n\tu32\t\tattributes;\n\tu32\t\tdata_len;\n\tu32\t\tdata_ptr;\n} __packed;\n\nstruct gsmi_get_next_var_param {\n\tu8\tguid[GSMI_GUID_SIZE];\n\tu32\tname_ptr;\n\tu32\tname_len;\n} __packed;\n\nstruct gsmi_set_eventlog_param {\n\tu32\tdata_ptr;\n\tu32\tdata_len;\n\tu32\ttype;\n} __packed;\n\n \nstruct gsmi_log_entry_type_1 {\n\tu16\ttype;\n\tu32\tinstance;\n} __packed;\n\n \n#define GSMI_DEFAULT_SPINCOUNT\t0x10000\nstatic unsigned int spincount = GSMI_DEFAULT_SPINCOUNT;\nmodule_param(spincount, uint, 0600);\nMODULE_PARM_DESC(spincount,\n\t\"The number of loop iterations to use when using the spin handshake.\");\n\n \nstatic bool s0ix_logging_enable = true;\nmodule_param(s0ix_logging_enable, bool, 0600);\n\nstatic struct gsmi_buf *gsmi_buf_alloc(void)\n{\n\tstruct gsmi_buf *smibuf;\n\n\tsmibuf = kzalloc(sizeof(*smibuf), GFP_KERNEL);\n\tif (!smibuf) {\n\t\tprintk(KERN_ERR \"gsmi: out of memory\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tsmibuf->start = kmem_cache_alloc(gsmi_dev.mem_pool, GFP_KERNEL);\n\tif (!smibuf->start) {\n\t\tprintk(KERN_ERR \"gsmi: failed to allocate name buffer\\n\");\n\t\tkfree(smibuf);\n\t\treturn NULL;\n\t}\n\n\t \n\tsmibuf->length = GSMI_BUF_SIZE;\n\tsmibuf->address = (u32)virt_to_phys(smibuf->start);\n\n\treturn smibuf;\n}\n\nstatic void gsmi_buf_free(struct gsmi_buf *smibuf)\n{\n\tif (smibuf) {\n\t\tif (smibuf->start)\n\t\t\tkmem_cache_free(gsmi_dev.mem_pool, smibuf->start);\n\t\tkfree(smibuf);\n\t}\n}\n\n \nstatic int gsmi_exec(u8 func, u8 sub)\n{\n\tu16 cmd = (sub << 8) | func;\n\tu16 result = 0;\n\tint rc = 0;\n\n\t \n\tif (gsmi_dev.handshake_type == GSMI_HANDSHAKE_CF) {\n\t\t \n\t\tasm volatile (\n\t\t\t\"stc\\n\"\n\t\t\t\"outb %%al, %%dx\\n\"\n\t\t\"1:      jc 1b\\n\"\n\t\t\t: \"=a\" (result)\n\t\t\t: \"0\" (cmd),\n\t\t\t  \"d\" (gsmi_dev.smi_cmd),\n\t\t\t  \"b\" (gsmi_dev.param_buf->address)\n\t\t\t: \"memory\", \"cc\"\n\t\t);\n\t} else if (gsmi_dev.handshake_type == GSMI_HANDSHAKE_SPIN) {\n\t\t \n\t\tasm volatile (\n\t\t\t\"outb %%al, %%dx\\n\"\n\t\t\"1:      loop 1b\\n\"\n\t\t\t: \"=a\" (result)\n\t\t\t: \"0\" (cmd),\n\t\t\t  \"d\" (gsmi_dev.smi_cmd),\n\t\t\t  \"b\" (gsmi_dev.param_buf->address),\n\t\t\t  \"c\" (spincount)\n\t\t\t: \"memory\", \"cc\"\n\t\t);\n\t} else {\n\t\t \n\t\tasm volatile (\n\t\t\t\"outb %%al, %%dx\\n\\t\"\n\t\t\t: \"=a\" (result)\n\t\t\t: \"0\" (cmd),\n\t\t\t  \"d\" (gsmi_dev.smi_cmd),\n\t\t\t  \"b\" (gsmi_dev.param_buf->address)\n\t\t\t: \"memory\", \"cc\"\n\t\t);\n\t}\n\n\t \n\tswitch (result) {\n\tcase GSMI_SUCCESS:\n\t\tbreak;\n\tcase GSMI_VAR_NOT_FOUND:\n\t\t \n\t\trc = 1;\n\t\tbreak;\n\tcase GSMI_INVALID_PARAMETER:\n\t\tprintk(KERN_ERR \"gsmi: exec 0x%04x: Invalid parameter\\n\", cmd);\n\t\trc = -EINVAL;\n\t\tbreak;\n\tcase GSMI_BUFFER_TOO_SMALL:\n\t\tprintk(KERN_ERR \"gsmi: exec 0x%04x: Buffer too small\\n\", cmd);\n\t\trc = -ENOMEM;\n\t\tbreak;\n\tcase GSMI_UNSUPPORTED:\n\tcase GSMI_UNSUPPORTED2:\n\t\tif (sub != GSMI_CMD_HANDSHAKE_TYPE)\n\t\t\tprintk(KERN_ERR \"gsmi: exec 0x%04x: Not supported\\n\",\n\t\t\t       cmd);\n\t\trc = -ENOSYS;\n\t\tbreak;\n\tcase GSMI_NOT_READY:\n\t\tprintk(KERN_ERR \"gsmi: exec 0x%04x: Not ready\\n\", cmd);\n\t\trc = -EBUSY;\n\t\tbreak;\n\tcase GSMI_DEVICE_ERROR:\n\t\tprintk(KERN_ERR \"gsmi: exec 0x%04x: Device error\\n\", cmd);\n\t\trc = -EFAULT;\n\t\tbreak;\n\tcase GSMI_NOT_FOUND:\n\t\tprintk(KERN_ERR \"gsmi: exec 0x%04x: Data not found\\n\", cmd);\n\t\trc = -ENOENT;\n\t\tbreak;\n\tcase GSMI_LOG_FULL:\n\t\tprintk(KERN_ERR \"gsmi: exec 0x%04x: Log full\\n\", cmd);\n\t\trc = -ENOSPC;\n\t\tbreak;\n\tcase GSMI_HANDSHAKE_CF:\n\tcase GSMI_HANDSHAKE_SPIN:\n\tcase GSMI_HANDSHAKE_NONE:\n\t\trc = result;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"gsmi: exec 0x%04x: Unknown error 0x%04x\\n\",\n\t\t       cmd, result);\n\t\trc = -ENXIO;\n\t}\n\n\treturn rc;\n}\n\n#ifdef CONFIG_EFI\n\nstatic struct efivars efivars;\n\nstatic efi_status_t gsmi_get_variable(efi_char16_t *name,\n\t\t\t\t      efi_guid_t *vendor, u32 *attr,\n\t\t\t\t      unsigned long *data_size,\n\t\t\t\t      void *data)\n{\n\tstruct gsmi_nvram_var_param param = {\n\t\t.name_ptr = gsmi_dev.name_buf->address,\n\t\t.data_ptr = gsmi_dev.data_buf->address,\n\t\t.data_len = (u32)*data_size,\n\t};\n\tefi_status_t ret = EFI_SUCCESS;\n\tunsigned long flags;\n\tsize_t name_len = ucs2_strnlen(name, GSMI_BUF_SIZE / 2);\n\tint rc;\n\n\tif (name_len >= GSMI_BUF_SIZE / 2)\n\t\treturn EFI_BAD_BUFFER_SIZE;\n\n\tspin_lock_irqsave(&gsmi_dev.lock, flags);\n\n\t \n\tmemcpy(&param.guid, vendor, sizeof(param.guid));\n\n\t \n\tmemset(gsmi_dev.name_buf->start, 0, gsmi_dev.name_buf->length);\n\tmemcpy(gsmi_dev.name_buf->start, name, name_len * 2);\n\n\t \n\tmemset(gsmi_dev.data_buf->start, 0, gsmi_dev.data_buf->length);\n\n\t \n\tmemset(gsmi_dev.param_buf->start, 0, gsmi_dev.param_buf->length);\n\tmemcpy(gsmi_dev.param_buf->start, &param, sizeof(param));\n\n\trc = gsmi_exec(GSMI_CALLBACK, GSMI_CMD_GET_NVRAM_VAR);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"gsmi: Get Variable failed\\n\");\n\t\tret = EFI_LOAD_ERROR;\n\t} else if (rc == 1) {\n\t\t \n\t\tret = EFI_NOT_FOUND;\n\t} else {\n\t\t \n\t\tmemcpy(&param, gsmi_dev.param_buf->start, sizeof(param));\n\n\t\t \n\t\t*data_size = min_t(unsigned long, *data_size,\n\t\t\t\t\t\tgsmi_dev.data_buf->length);\n\t\t*data_size = min_t(unsigned long, *data_size, param.data_len);\n\n\t\t \n\t\tmemcpy(data, gsmi_dev.data_buf->start, *data_size);\n\n\t\t \n\t\tif (attr)\n\t\t\t*attr = EFI_VARIABLE_NON_VOLATILE |\n\t\t\t\tEFI_VARIABLE_BOOTSERVICE_ACCESS |\n\t\t\t\tEFI_VARIABLE_RUNTIME_ACCESS;\n\t}\n\n\tspin_unlock_irqrestore(&gsmi_dev.lock, flags);\n\n\treturn ret;\n}\n\nstatic efi_status_t gsmi_get_next_variable(unsigned long *name_size,\n\t\t\t\t\t   efi_char16_t *name,\n\t\t\t\t\t   efi_guid_t *vendor)\n{\n\tstruct gsmi_get_next_var_param param = {\n\t\t.name_ptr = gsmi_dev.name_buf->address,\n\t\t.name_len = gsmi_dev.name_buf->length,\n\t};\n\tefi_status_t ret = EFI_SUCCESS;\n\tint rc;\n\tunsigned long flags;\n\n\t \n\tif (*name_size != GSMI_BUF_SIZE)\n\t\treturn EFI_BAD_BUFFER_SIZE;\n\n\t \n\tif (ucs2_strnlen(name, GSMI_BUF_SIZE / 2) == GSMI_BUF_SIZE / 2)\n\t\treturn EFI_INVALID_PARAMETER;\n\n\tspin_lock_irqsave(&gsmi_dev.lock, flags);\n\n\t \n\tmemcpy(&param.guid, vendor, sizeof(param.guid));\n\n\t \n\tmemcpy(gsmi_dev.name_buf->start, name, *name_size);\n\n\t \n\tmemset(gsmi_dev.param_buf->start, 0, gsmi_dev.param_buf->length);\n\tmemcpy(gsmi_dev.param_buf->start, &param, sizeof(param));\n\n\trc = gsmi_exec(GSMI_CALLBACK, GSMI_CMD_GET_NEXT_VAR);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"gsmi: Get Next Variable Name failed\\n\");\n\t\tret = EFI_LOAD_ERROR;\n\t} else if (rc == 1) {\n\t\t \n\t\tret = EFI_NOT_FOUND;\n\t} else {\n\t\t \n\t\tmemcpy(&param, gsmi_dev.param_buf->start, sizeof(param));\n\n\t\t \n\t\tmemcpy(name, gsmi_dev.name_buf->start, GSMI_BUF_SIZE);\n\t\t*name_size = ucs2_strnlen(name, GSMI_BUF_SIZE / 2) * 2;\n\n\t\t \n\t\tmemcpy(vendor, &param.guid, sizeof(param.guid));\n\t\tret = EFI_SUCCESS;\n\t}\n\n\tspin_unlock_irqrestore(&gsmi_dev.lock, flags);\n\n\treturn ret;\n}\n\nstatic efi_status_t gsmi_set_variable(efi_char16_t *name,\n\t\t\t\t      efi_guid_t *vendor,\n\t\t\t\t      u32 attr,\n\t\t\t\t      unsigned long data_size,\n\t\t\t\t      void *data)\n{\n\tstruct gsmi_nvram_var_param param = {\n\t\t.name_ptr = gsmi_dev.name_buf->address,\n\t\t.data_ptr = gsmi_dev.data_buf->address,\n\t\t.data_len = (u32)data_size,\n\t\t.attributes = EFI_VARIABLE_NON_VOLATILE |\n\t\t\t      EFI_VARIABLE_BOOTSERVICE_ACCESS |\n\t\t\t      EFI_VARIABLE_RUNTIME_ACCESS,\n\t};\n\tsize_t name_len = ucs2_strnlen(name, GSMI_BUF_SIZE / 2);\n\tefi_status_t ret = EFI_SUCCESS;\n\tint rc;\n\tunsigned long flags;\n\n\tif (name_len >= GSMI_BUF_SIZE / 2)\n\t\treturn EFI_BAD_BUFFER_SIZE;\n\n\tspin_lock_irqsave(&gsmi_dev.lock, flags);\n\n\t \n\tmemcpy(&param.guid, vendor, sizeof(param.guid));\n\n\t \n\tmemset(gsmi_dev.name_buf->start, 0, gsmi_dev.name_buf->length);\n\tmemcpy(gsmi_dev.name_buf->start, name, name_len * 2);\n\n\t \n\tmemset(gsmi_dev.data_buf->start, 0, gsmi_dev.data_buf->length);\n\tmemcpy(gsmi_dev.data_buf->start, data, data_size);\n\n\t \n\tmemset(gsmi_dev.param_buf->start, 0, gsmi_dev.param_buf->length);\n\tmemcpy(gsmi_dev.param_buf->start, &param, sizeof(param));\n\n\trc = gsmi_exec(GSMI_CALLBACK, GSMI_CMD_SET_NVRAM_VAR);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"gsmi: Set Variable failed\\n\");\n\t\tret = EFI_INVALID_PARAMETER;\n\t}\n\n\tspin_unlock_irqrestore(&gsmi_dev.lock, flags);\n\n\treturn ret;\n}\n\nstatic const struct efivar_operations efivar_ops = {\n\t.get_variable = gsmi_get_variable,\n\t.set_variable = gsmi_set_variable,\n\t.get_next_variable = gsmi_get_next_variable,\n};\n\n#endif  \n\nstatic ssize_t eventlog_write(struct file *filp, struct kobject *kobj,\n\t\t\t       struct bin_attribute *bin_attr,\n\t\t\t       char *buf, loff_t pos, size_t count)\n{\n\tstruct gsmi_set_eventlog_param param = {\n\t\t.data_ptr = gsmi_dev.data_buf->address,\n\t};\n\tint rc = 0;\n\tunsigned long flags;\n\n\t \n\tif (count < sizeof(u32))\n\t\treturn -EINVAL;\n\tparam.type = *(u32 *)buf;\n\tbuf += sizeof(u32);\n\n\t \n\tif ((count - sizeof(u32)) > gsmi_dev.data_buf->length)\n\t\treturn -EINVAL;\n\tparam.data_len = count - sizeof(u32);\n\n\tspin_lock_irqsave(&gsmi_dev.lock, flags);\n\n\t \n\tmemset(gsmi_dev.data_buf->start, 0, gsmi_dev.data_buf->length);\n\tmemcpy(gsmi_dev.data_buf->start, buf, param.data_len);\n\n\t \n\tmemset(gsmi_dev.param_buf->start, 0, gsmi_dev.param_buf->length);\n\tmemcpy(gsmi_dev.param_buf->start, &param, sizeof(param));\n\n\trc = gsmi_exec(GSMI_CALLBACK, GSMI_CMD_SET_EVENT_LOG);\n\tif (rc < 0)\n\t\tprintk(KERN_ERR \"gsmi: Set Event Log failed\\n\");\n\n\tspin_unlock_irqrestore(&gsmi_dev.lock, flags);\n\n\treturn (rc == 0) ? count : rc;\n\n}\n\nstatic struct bin_attribute eventlog_bin_attr = {\n\t.attr = {.name = \"append_to_eventlog\", .mode = 0200},\n\t.write = eventlog_write,\n};\n\nstatic ssize_t gsmi_clear_eventlog_store(struct kobject *kobj,\n\t\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tint rc;\n\tunsigned long flags;\n\tunsigned long val;\n\tstruct {\n\t\tu32 percentage;\n\t\tu32 data_type;\n\t} param;\n\n\trc = kstrtoul(buf, 0, &val);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (val > 100)\n\t\treturn -EINVAL;\n\n\t \n\tparam.percentage = val;\n\tparam.data_type = 0;\n\n\tspin_lock_irqsave(&gsmi_dev.lock, flags);\n\n\t \n\tmemset(gsmi_dev.param_buf->start, 0, gsmi_dev.param_buf->length);\n\tmemcpy(gsmi_dev.param_buf->start, &param, sizeof(param));\n\n\trc = gsmi_exec(GSMI_CALLBACK, GSMI_CMD_CLEAR_EVENT_LOG);\n\n\tspin_unlock_irqrestore(&gsmi_dev.lock, flags);\n\n\tif (rc)\n\t\treturn rc;\n\treturn count;\n}\n\nstatic struct kobj_attribute gsmi_clear_eventlog_attr = {\n\t.attr = {.name = \"clear_eventlog\", .mode = 0200},\n\t.store = gsmi_clear_eventlog_store,\n};\n\nstatic ssize_t gsmi_clear_config_store(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tint rc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gsmi_dev.lock, flags);\n\n\t \n\tmemset(gsmi_dev.param_buf->start, 0, gsmi_dev.param_buf->length);\n\n\trc = gsmi_exec(GSMI_CALLBACK, GSMI_CMD_CLEAR_CONFIG);\n\n\tspin_unlock_irqrestore(&gsmi_dev.lock, flags);\n\n\tif (rc)\n\t\treturn rc;\n\treturn count;\n}\n\nstatic struct kobj_attribute gsmi_clear_config_attr = {\n\t.attr = {.name = \"clear_config\", .mode = 0200},\n\t.store = gsmi_clear_config_store,\n};\n\nstatic const struct attribute *gsmi_attrs[] = {\n\t&gsmi_clear_config_attr.attr,\n\t&gsmi_clear_eventlog_attr.attr,\n\tNULL,\n};\n\nstatic int gsmi_shutdown_reason(int reason)\n{\n\tstruct gsmi_log_entry_type_1 entry = {\n\t\t.type     = GSMI_LOG_ENTRY_TYPE_KERNEL,\n\t\t.instance = reason,\n\t};\n\tstruct gsmi_set_eventlog_param param = {\n\t\t.data_len = sizeof(entry),\n\t\t.type     = 1,\n\t};\n\tstatic int saved_reason;\n\tint rc = 0;\n\tunsigned long flags;\n\n\t \n\tif (saved_reason & (1 << reason))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&gsmi_dev.lock, flags);\n\n\tsaved_reason |= (1 << reason);\n\n\t \n\tmemset(gsmi_dev.data_buf->start, 0, gsmi_dev.data_buf->length);\n\tmemcpy(gsmi_dev.data_buf->start, &entry, sizeof(entry));\n\n\t \n\tparam.data_ptr = gsmi_dev.data_buf->address;\n\tmemset(gsmi_dev.param_buf->start, 0, gsmi_dev.param_buf->length);\n\tmemcpy(gsmi_dev.param_buf->start, &param, sizeof(param));\n\n\trc = gsmi_exec(GSMI_CALLBACK, GSMI_CMD_SET_EVENT_LOG);\n\n\tspin_unlock_irqrestore(&gsmi_dev.lock, flags);\n\n\tif (rc < 0)\n\t\tprintk(KERN_ERR \"gsmi: Log Shutdown Reason failed\\n\");\n\telse\n\t\tprintk(KERN_EMERG \"gsmi: Log Shutdown Reason 0x%02x\\n\",\n\t\t       reason);\n\n\treturn rc;\n}\n\nstatic int gsmi_reboot_callback(struct notifier_block *nb,\n\t\t\t\tunsigned long reason, void *arg)\n{\n\tgsmi_shutdown_reason(GSMI_SHUTDOWN_CLEAN);\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block gsmi_reboot_notifier = {\n\t.notifier_call = gsmi_reboot_callback\n};\n\nstatic int gsmi_die_callback(struct notifier_block *nb,\n\t\t\t     unsigned long reason, void *arg)\n{\n\tif (reason == DIE_OOPS)\n\t\tgsmi_shutdown_reason(GSMI_SHUTDOWN_OOPS);\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block gsmi_die_notifier = {\n\t.notifier_call = gsmi_die_callback\n};\n\nstatic int gsmi_panic_callback(struct notifier_block *nb,\n\t\t\t       unsigned long reason, void *arg)\n{\n\n\t \n\tif (spin_is_locked(&gsmi_dev.lock))\n\t\treturn NOTIFY_DONE;\n\n\tgsmi_shutdown_reason(GSMI_SHUTDOWN_PANIC);\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block gsmi_panic_notifier = {\n\t.notifier_call = gsmi_panic_callback,\n};\n\n \nstatic u64 __init local_hash_64(u64 val, unsigned bits)\n{\n\tu64 hash = val;\n\n\t \n\tu64 n = hash;\n\tn <<= 18;\n\thash -= n;\n\tn <<= 33;\n\thash -= n;\n\tn <<= 3;\n\thash += n;\n\tn <<= 3;\n\thash -= n;\n\tn <<= 4;\n\thash += n;\n\tn <<= 2;\n\thash += n;\n\n\t \n\treturn hash >> (64 - bits);\n}\n\nstatic u32 __init hash_oem_table_id(char s[8])\n{\n\tu64 input;\n\tmemcpy(&input, s, 8);\n\treturn local_hash_64(input, 32);\n}\n\nstatic const struct dmi_system_id gsmi_dmi_table[] __initconst = {\n\t{\n\t\t.ident = \"Google Board\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Google, Inc.\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Coreboot Firmware\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BIOS_VENDOR, \"coreboot\"),\n\t\t},\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(dmi, gsmi_dmi_table);\n\nstatic __init int gsmi_system_valid(void)\n{\n\tu32 hash;\n\tu16 cmd, result;\n\n\tif (!dmi_check_system(gsmi_dmi_table))\n\t\treturn -ENODEV;\n\n\t \n\tif (!strncmp(acpi_gbl_FADT.header.oem_table_id, \"FACP\", 4)) {\n\t\tprintk(KERN_INFO \"gsmi: Board is too old\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\thash = hash_oem_table_id(acpi_gbl_FADT.header.oem_table_id);\n\tif (hash == QUIRKY_BOARD_HASH) {\n\t\tconst char *bios_ver = dmi_get_system_info(DMI_BIOS_VERSION);\n\t\tif (strncmp(bios_ver, \"1.0\", 3) == 0) {\n\t\t\tpr_info(\"gsmi: disabled on this board's BIOS %s\\n\",\n\t\t\t\tbios_ver);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\tif (acpi_gbl_FADT.smi_command == 0) {\n\t\tpr_info(\"gsmi: missing smi_command\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tcmd = GSMI_CALLBACK | GSMI_CMD_RESERVED << 8;\n\tasm volatile (\n\t\t\"outb %%al, %%dx\\n\\t\"\n\t\t: \"=a\" (result)\n\t\t: \"0\" (cmd),\n\t\t  \"d\" (acpi_gbl_FADT.smi_command)\n\t\t: \"memory\", \"cc\"\n\t\t);\n\tif (cmd == result) {\n\t\tpr_info(\"gsmi: no gsmi handler in firmware\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic struct kobject *gsmi_kobj;\n\nstatic const struct platform_device_info gsmi_dev_info = {\n\t.name\t\t= \"gsmi\",\n\t.id\t\t= -1,\n\t \n\t.dma_mask\t= DMA_BIT_MASK(32),\n};\n\n#ifdef CONFIG_PM\nstatic void gsmi_log_s0ix_info(u8 cmd)\n{\n\tunsigned long flags;\n\n\t \n\tif (!s0ix_logging_enable)\n\t\treturn;\n\n\tspin_lock_irqsave(&gsmi_dev.lock, flags);\n\n\tmemset(gsmi_dev.param_buf->start, 0, gsmi_dev.param_buf->length);\n\n\tgsmi_exec(GSMI_CALLBACK, cmd);\n\n\tspin_unlock_irqrestore(&gsmi_dev.lock, flags);\n}\n\nstatic int gsmi_log_s0ix_suspend(struct device *dev)\n{\n\t \n\tif (!pm_suspend_via_firmware())\n\t\tgsmi_log_s0ix_info(GSMI_CMD_LOG_S0IX_SUSPEND);\n\n\t \n\treturn 0;\n}\n\nstatic int gsmi_log_s0ix_resume(struct device *dev)\n{\n\t \n\tif (!pm_resume_via_firmware())\n\t\tgsmi_log_s0ix_info(GSMI_CMD_LOG_S0IX_RESUME);\n\n\t \n\treturn 0;\n}\n\nstatic const struct dev_pm_ops gsmi_pm_ops = {\n\t.suspend_noirq = gsmi_log_s0ix_suspend,\n\t.resume_noirq = gsmi_log_s0ix_resume,\n};\n\nstatic int gsmi_platform_driver_probe(struct platform_device *dev)\n{\n\treturn 0;\n}\n\nstatic struct platform_driver gsmi_driver_info = {\n\t.driver = {\n\t\t.name = \"gsmi\",\n\t\t.pm = &gsmi_pm_ops,\n\t},\n\t.probe = gsmi_platform_driver_probe,\n};\n#endif\n\nstatic __init int gsmi_init(void)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tret = gsmi_system_valid();\n\tif (ret)\n\t\treturn ret;\n\n\tgsmi_dev.smi_cmd = acpi_gbl_FADT.smi_command;\n\n#ifdef CONFIG_PM\n\tret = platform_driver_register(&gsmi_driver_info);\n\tif (unlikely(ret)) {\n\t\tprintk(KERN_ERR \"gsmi: unable to register platform driver\\n\");\n\t\treturn ret;\n\t}\n#endif\n\n\t \n\tgsmi_dev.pdev = platform_device_register_full(&gsmi_dev_info);\n\tif (IS_ERR(gsmi_dev.pdev)) {\n\t\tprintk(KERN_ERR \"gsmi: unable to register platform device\\n\");\n\t\treturn PTR_ERR(gsmi_dev.pdev);\n\t}\n\n\t \n\tspin_lock_init(&gsmi_dev.lock);\n\n\tret = -ENOMEM;\n\n\t \n\tgsmi_dev.mem_pool = kmem_cache_create(\"gsmi\", GSMI_BUF_SIZE,\n\t\t\t\t\t      GSMI_BUF_ALIGN,\n\t\t\t\t\t      SLAB_CACHE_DMA32, NULL);\n\tif (!gsmi_dev.mem_pool)\n\t\tgoto out_err;\n\n\t \n\tgsmi_dev.name_buf = gsmi_buf_alloc();\n\tif (!gsmi_dev.name_buf) {\n\t\tprintk(KERN_ERR \"gsmi: failed to allocate name buffer\\n\");\n\t\tgoto out_err;\n\t}\n\n\tgsmi_dev.data_buf = gsmi_buf_alloc();\n\tif (!gsmi_dev.data_buf) {\n\t\tprintk(KERN_ERR \"gsmi: failed to allocate data buffer\\n\");\n\t\tgoto out_err;\n\t}\n\n\tgsmi_dev.param_buf = gsmi_buf_alloc();\n\tif (!gsmi_dev.param_buf) {\n\t\tprintk(KERN_ERR \"gsmi: failed to allocate param buffer\\n\");\n\t\tgoto out_err;\n\t}\n\n\t \n\tspin_lock_irqsave(&gsmi_dev.lock, flags);\n\tgsmi_dev.handshake_type = GSMI_HANDSHAKE_SPIN;\n\tgsmi_dev.handshake_type =\n\t    gsmi_exec(GSMI_CALLBACK, GSMI_CMD_HANDSHAKE_TYPE);\n\tif (gsmi_dev.handshake_type == -ENOSYS)\n\t\tgsmi_dev.handshake_type = GSMI_HANDSHAKE_NONE;\n\tspin_unlock_irqrestore(&gsmi_dev.lock, flags);\n\n\t \n\tif (gsmi_dev.handshake_type == -ENXIO) {\n\t\tprintk(KERN_INFO \"gsmi version \" DRIVER_VERSION\n\t\t       \" failed to load\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_err;\n\t}\n\n\t \n\tret = -ENOMEM;\n\tgsmi_kobj = kobject_create_and_add(\"gsmi\", firmware_kobj);\n\tif (!gsmi_kobj) {\n\t\tprintk(KERN_INFO \"gsmi: Failed to create firmware kobj\\n\");\n\t\tgoto out_err;\n\t}\n\n\t \n\tret = sysfs_create_bin_file(gsmi_kobj, &eventlog_bin_attr);\n\tif (ret) {\n\t\tprintk(KERN_INFO \"gsmi: Failed to setup eventlog\");\n\t\tgoto out_err;\n\t}\n\n\t \n\tret = sysfs_create_files(gsmi_kobj, gsmi_attrs);\n\tif (ret) {\n\t\tprintk(KERN_INFO \"gsmi: Failed to add attrs\");\n\t\tgoto out_remove_bin_file;\n\t}\n\n#ifdef CONFIG_EFI\n\tret = efivars_register(&efivars, &efivar_ops);\n\tif (ret) {\n\t\tprintk(KERN_INFO \"gsmi: Failed to register efivars\\n\");\n\t\tsysfs_remove_files(gsmi_kobj, gsmi_attrs);\n\t\tgoto out_remove_bin_file;\n\t}\n#endif\n\n\tregister_reboot_notifier(&gsmi_reboot_notifier);\n\tregister_die_notifier(&gsmi_die_notifier);\n\tatomic_notifier_chain_register(&panic_notifier_list,\n\t\t\t\t       &gsmi_panic_notifier);\n\n\tprintk(KERN_INFO \"gsmi version \" DRIVER_VERSION \" loaded\\n\");\n\n\treturn 0;\n\nout_remove_bin_file:\n\tsysfs_remove_bin_file(gsmi_kobj, &eventlog_bin_attr);\nout_err:\n\tkobject_put(gsmi_kobj);\n\tgsmi_buf_free(gsmi_dev.param_buf);\n\tgsmi_buf_free(gsmi_dev.data_buf);\n\tgsmi_buf_free(gsmi_dev.name_buf);\n\tkmem_cache_destroy(gsmi_dev.mem_pool);\n\tplatform_device_unregister(gsmi_dev.pdev);\n\tpr_info(\"gsmi: failed to load: %d\\n\", ret);\n#ifdef CONFIG_PM\n\tplatform_driver_unregister(&gsmi_driver_info);\n#endif\n\treturn ret;\n}\n\nstatic void __exit gsmi_exit(void)\n{\n\tunregister_reboot_notifier(&gsmi_reboot_notifier);\n\tunregister_die_notifier(&gsmi_die_notifier);\n\tatomic_notifier_chain_unregister(&panic_notifier_list,\n\t\t\t\t\t &gsmi_panic_notifier);\n#ifdef CONFIG_EFI\n\tefivars_unregister(&efivars);\n#endif\n\n\tsysfs_remove_files(gsmi_kobj, gsmi_attrs);\n\tsysfs_remove_bin_file(gsmi_kobj, &eventlog_bin_attr);\n\tkobject_put(gsmi_kobj);\n\tgsmi_buf_free(gsmi_dev.param_buf);\n\tgsmi_buf_free(gsmi_dev.data_buf);\n\tgsmi_buf_free(gsmi_dev.name_buf);\n\tkmem_cache_destroy(gsmi_dev.mem_pool);\n\tplatform_device_unregister(gsmi_dev.pdev);\n#ifdef CONFIG_PM\n\tplatform_driver_unregister(&gsmi_driver_info);\n#endif\n}\n\nmodule_init(gsmi_init);\nmodule_exit(gsmi_exit);\n\nMODULE_AUTHOR(\"Google, Inc.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}