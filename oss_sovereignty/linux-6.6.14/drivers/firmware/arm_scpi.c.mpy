{
  "module_name": "arm_scpi.c",
  "hash_id": "8c9c3c5974348aa9bbf46e32ff75e7cf6cd43e65eb55cffedfcc67b35b58df69",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/arm_scpi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bitmap.h>\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/printk.h>\n#include <linux/pm_opp.h>\n#include <linux/scpi_protocol.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/spinlock.h>\n\n#define CMD_ID_MASK\t\tGENMASK(6, 0)\n#define CMD_TOKEN_ID_MASK\tGENMASK(15, 8)\n#define CMD_DATA_SIZE_MASK\tGENMASK(24, 16)\n#define CMD_LEGACY_DATA_SIZE_MASK\tGENMASK(28, 20)\n#define PACK_SCPI_CMD(cmd_id, tx_sz)\t\t\\\n\t(FIELD_PREP(CMD_ID_MASK, cmd_id) |\t\\\n\tFIELD_PREP(CMD_DATA_SIZE_MASK, tx_sz))\n#define PACK_LEGACY_SCPI_CMD(cmd_id, tx_sz)\t\\\n\t(FIELD_PREP(CMD_ID_MASK, cmd_id) |\t\\\n\tFIELD_PREP(CMD_LEGACY_DATA_SIZE_MASK, tx_sz))\n\n#define CMD_SIZE(cmd)\tFIELD_GET(CMD_DATA_SIZE_MASK, cmd)\n#define CMD_UNIQ_MASK\t(CMD_TOKEN_ID_MASK | CMD_ID_MASK)\n#define CMD_XTRACT_UNIQ(cmd)\t((cmd) & CMD_UNIQ_MASK)\n\n#define SCPI_SLOT\t\t0\n\n#define MAX_DVFS_DOMAINS\t8\n#define MAX_DVFS_OPPS\t\t16\n\n#define PROTO_REV_MAJOR_MASK\tGENMASK(31, 16)\n#define PROTO_REV_MINOR_MASK\tGENMASK(15, 0)\n\n#define FW_REV_MAJOR_MASK\tGENMASK(31, 24)\n#define FW_REV_MINOR_MASK\tGENMASK(23, 16)\n#define FW_REV_PATCH_MASK\tGENMASK(15, 0)\n\n#define MAX_RX_TIMEOUT\t\t(msecs_to_jiffies(30))\n\nenum scpi_error_codes {\n\tSCPI_SUCCESS = 0,  \n\tSCPI_ERR_PARAM = 1,  \n\tSCPI_ERR_ALIGN = 2,  \n\tSCPI_ERR_SIZE = 3,  \n\tSCPI_ERR_HANDLER = 4,  \n\tSCPI_ERR_ACCESS = 5,  \n\tSCPI_ERR_RANGE = 6,  \n\tSCPI_ERR_TIMEOUT = 7,  \n\tSCPI_ERR_NOMEM = 8,  \n\tSCPI_ERR_PWRSTATE = 9,  \n\tSCPI_ERR_SUPPORT = 10,  \n\tSCPI_ERR_DEVICE = 11,  \n\tSCPI_ERR_BUSY = 12,  \n\tSCPI_ERR_MAX\n};\n\n \nenum scpi_std_cmd {\n\tSCPI_CMD_INVALID\t\t= 0x00,\n\tSCPI_CMD_SCPI_READY\t\t= 0x01,\n\tSCPI_CMD_SCPI_CAPABILITIES\t= 0x02,\n\tSCPI_CMD_SET_CSS_PWR_STATE\t= 0x03,\n\tSCPI_CMD_GET_CSS_PWR_STATE\t= 0x04,\n\tSCPI_CMD_SET_SYS_PWR_STATE\t= 0x05,\n\tSCPI_CMD_SET_CPU_TIMER\t\t= 0x06,\n\tSCPI_CMD_CANCEL_CPU_TIMER\t= 0x07,\n\tSCPI_CMD_DVFS_CAPABILITIES\t= 0x08,\n\tSCPI_CMD_GET_DVFS_INFO\t\t= 0x09,\n\tSCPI_CMD_SET_DVFS\t\t= 0x0a,\n\tSCPI_CMD_GET_DVFS\t\t= 0x0b,\n\tSCPI_CMD_GET_DVFS_STAT\t\t= 0x0c,\n\tSCPI_CMD_CLOCK_CAPABILITIES\t= 0x0d,\n\tSCPI_CMD_GET_CLOCK_INFO\t\t= 0x0e,\n\tSCPI_CMD_SET_CLOCK_VALUE\t= 0x0f,\n\tSCPI_CMD_GET_CLOCK_VALUE\t= 0x10,\n\tSCPI_CMD_PSU_CAPABILITIES\t= 0x11,\n\tSCPI_CMD_GET_PSU_INFO\t\t= 0x12,\n\tSCPI_CMD_SET_PSU\t\t= 0x13,\n\tSCPI_CMD_GET_PSU\t\t= 0x14,\n\tSCPI_CMD_SENSOR_CAPABILITIES\t= 0x15,\n\tSCPI_CMD_SENSOR_INFO\t\t= 0x16,\n\tSCPI_CMD_SENSOR_VALUE\t\t= 0x17,\n\tSCPI_CMD_SENSOR_CFG_PERIODIC\t= 0x18,\n\tSCPI_CMD_SENSOR_CFG_BOUNDS\t= 0x19,\n\tSCPI_CMD_SENSOR_ASYNC_VALUE\t= 0x1a,\n\tSCPI_CMD_SET_DEVICE_PWR_STATE\t= 0x1b,\n\tSCPI_CMD_GET_DEVICE_PWR_STATE\t= 0x1c,\n\tSCPI_CMD_COUNT\n};\n\n \nenum legacy_scpi_std_cmd {\n\tLEGACY_SCPI_CMD_INVALID\t\t\t= 0x00,\n\tLEGACY_SCPI_CMD_SCPI_READY\t\t= 0x01,\n\tLEGACY_SCPI_CMD_SCPI_CAPABILITIES\t= 0x02,\n\tLEGACY_SCPI_CMD_EVENT\t\t\t= 0x03,\n\tLEGACY_SCPI_CMD_SET_CSS_PWR_STATE\t= 0x04,\n\tLEGACY_SCPI_CMD_GET_CSS_PWR_STATE\t= 0x05,\n\tLEGACY_SCPI_CMD_CFG_PWR_STATE_STAT\t= 0x06,\n\tLEGACY_SCPI_CMD_GET_PWR_STATE_STAT\t= 0x07,\n\tLEGACY_SCPI_CMD_SYS_PWR_STATE\t\t= 0x08,\n\tLEGACY_SCPI_CMD_L2_READY\t\t= 0x09,\n\tLEGACY_SCPI_CMD_SET_AP_TIMER\t\t= 0x0a,\n\tLEGACY_SCPI_CMD_CANCEL_AP_TIME\t\t= 0x0b,\n\tLEGACY_SCPI_CMD_DVFS_CAPABILITIES\t= 0x0c,\n\tLEGACY_SCPI_CMD_GET_DVFS_INFO\t\t= 0x0d,\n\tLEGACY_SCPI_CMD_SET_DVFS\t\t= 0x0e,\n\tLEGACY_SCPI_CMD_GET_DVFS\t\t= 0x0f,\n\tLEGACY_SCPI_CMD_GET_DVFS_STAT\t\t= 0x10,\n\tLEGACY_SCPI_CMD_SET_RTC\t\t\t= 0x11,\n\tLEGACY_SCPI_CMD_GET_RTC\t\t\t= 0x12,\n\tLEGACY_SCPI_CMD_CLOCK_CAPABILITIES\t= 0x13,\n\tLEGACY_SCPI_CMD_SET_CLOCK_INDEX\t\t= 0x14,\n\tLEGACY_SCPI_CMD_SET_CLOCK_VALUE\t\t= 0x15,\n\tLEGACY_SCPI_CMD_GET_CLOCK_VALUE\t\t= 0x16,\n\tLEGACY_SCPI_CMD_PSU_CAPABILITIES\t= 0x17,\n\tLEGACY_SCPI_CMD_SET_PSU\t\t\t= 0x18,\n\tLEGACY_SCPI_CMD_GET_PSU\t\t\t= 0x19,\n\tLEGACY_SCPI_CMD_SENSOR_CAPABILITIES\t= 0x1a,\n\tLEGACY_SCPI_CMD_SENSOR_INFO\t\t= 0x1b,\n\tLEGACY_SCPI_CMD_SENSOR_VALUE\t\t= 0x1c,\n\tLEGACY_SCPI_CMD_SENSOR_CFG_PERIODIC\t= 0x1d,\n\tLEGACY_SCPI_CMD_SENSOR_CFG_BOUNDS\t= 0x1e,\n\tLEGACY_SCPI_CMD_SENSOR_ASYNC_VALUE\t= 0x1f,\n\tLEGACY_SCPI_CMD_COUNT\n};\n\n \nstatic int legacy_hpriority_cmds[] = {\n\tLEGACY_SCPI_CMD_GET_CSS_PWR_STATE,\n\tLEGACY_SCPI_CMD_CFG_PWR_STATE_STAT,\n\tLEGACY_SCPI_CMD_GET_PWR_STATE_STAT,\n\tLEGACY_SCPI_CMD_SET_DVFS,\n\tLEGACY_SCPI_CMD_GET_DVFS,\n\tLEGACY_SCPI_CMD_SET_RTC,\n\tLEGACY_SCPI_CMD_GET_RTC,\n\tLEGACY_SCPI_CMD_SET_CLOCK_INDEX,\n\tLEGACY_SCPI_CMD_SET_CLOCK_VALUE,\n\tLEGACY_SCPI_CMD_GET_CLOCK_VALUE,\n\tLEGACY_SCPI_CMD_SET_PSU,\n\tLEGACY_SCPI_CMD_GET_PSU,\n\tLEGACY_SCPI_CMD_SENSOR_CFG_PERIODIC,\n\tLEGACY_SCPI_CMD_SENSOR_CFG_BOUNDS,\n};\n\n \nenum scpi_drv_cmds {\n\tCMD_SCPI_CAPABILITIES = 0,\n\tCMD_GET_CLOCK_INFO,\n\tCMD_GET_CLOCK_VALUE,\n\tCMD_SET_CLOCK_VALUE,\n\tCMD_GET_DVFS,\n\tCMD_SET_DVFS,\n\tCMD_GET_DVFS_INFO,\n\tCMD_SENSOR_CAPABILITIES,\n\tCMD_SENSOR_INFO,\n\tCMD_SENSOR_VALUE,\n\tCMD_SET_DEVICE_PWR_STATE,\n\tCMD_GET_DEVICE_PWR_STATE,\n\tCMD_MAX_COUNT,\n};\n\nstatic int scpi_std_commands[CMD_MAX_COUNT] = {\n\tSCPI_CMD_SCPI_CAPABILITIES,\n\tSCPI_CMD_GET_CLOCK_INFO,\n\tSCPI_CMD_GET_CLOCK_VALUE,\n\tSCPI_CMD_SET_CLOCK_VALUE,\n\tSCPI_CMD_GET_DVFS,\n\tSCPI_CMD_SET_DVFS,\n\tSCPI_CMD_GET_DVFS_INFO,\n\tSCPI_CMD_SENSOR_CAPABILITIES,\n\tSCPI_CMD_SENSOR_INFO,\n\tSCPI_CMD_SENSOR_VALUE,\n\tSCPI_CMD_SET_DEVICE_PWR_STATE,\n\tSCPI_CMD_GET_DEVICE_PWR_STATE,\n};\n\nstatic int scpi_legacy_commands[CMD_MAX_COUNT] = {\n\tLEGACY_SCPI_CMD_SCPI_CAPABILITIES,\n\t-1,  \n\tLEGACY_SCPI_CMD_GET_CLOCK_VALUE,\n\tLEGACY_SCPI_CMD_SET_CLOCK_VALUE,\n\tLEGACY_SCPI_CMD_GET_DVFS,\n\tLEGACY_SCPI_CMD_SET_DVFS,\n\tLEGACY_SCPI_CMD_GET_DVFS_INFO,\n\tLEGACY_SCPI_CMD_SENSOR_CAPABILITIES,\n\tLEGACY_SCPI_CMD_SENSOR_INFO,\n\tLEGACY_SCPI_CMD_SENSOR_VALUE,\n\t-1,  \n\t-1,  \n};\n\nstruct scpi_xfer {\n\tu32 slot;  \n\tu32 cmd;\n\tu32 status;\n\tconst void *tx_buf;\n\tvoid *rx_buf;\n\tunsigned int tx_len;\n\tunsigned int rx_len;\n\tstruct list_head node;\n\tstruct completion done;\n};\n\nstruct scpi_chan {\n\tstruct mbox_client cl;\n\tstruct mbox_chan *chan;\n\tvoid __iomem *tx_payload;\n\tvoid __iomem *rx_payload;\n\tstruct list_head rx_pending;\n\tstruct list_head xfers_list;\n\tstruct scpi_xfer *xfers;\n\tspinlock_t rx_lock;  \n\tstruct mutex xfers_lock;\n\tu8 token;\n};\n\nstruct scpi_drvinfo {\n\tu32 protocol_version;\n\tu32 firmware_version;\n\tbool is_legacy;\n\tint num_chans;\n\tint *commands;\n\tDECLARE_BITMAP(cmd_priority, LEGACY_SCPI_CMD_COUNT);\n\tatomic_t next_chan;\n\tstruct scpi_ops *scpi_ops;\n\tstruct scpi_chan *channels;\n\tstruct scpi_dvfs_info *dvfs[MAX_DVFS_DOMAINS];\n};\n\n \nstruct scpi_shared_mem {\n\t__le32 command;\n\t__le32 status;\n\tu8 payload[];\n} __packed;\n\nstruct legacy_scpi_shared_mem {\n\t__le32 status;\n\tu8 payload[];\n} __packed;\n\nstruct scp_capabilities {\n\t__le32 protocol_version;\n\t__le32 event_version;\n\t__le32 platform_version;\n\t__le32 commands[4];\n} __packed;\n\nstruct clk_get_info {\n\t__le16 id;\n\t__le16 flags;\n\t__le32 min_rate;\n\t__le32 max_rate;\n\tu8 name[20];\n} __packed;\n\nstruct clk_set_value {\n\t__le16 id;\n\t__le16 reserved;\n\t__le32 rate;\n} __packed;\n\nstruct legacy_clk_set_value {\n\t__le32 rate;\n\t__le16 id;\n\t__le16 reserved;\n} __packed;\n\nstruct dvfs_info {\n\tu8 domain;\n\tu8 opp_count;\n\t__le16 latency;\n\tstruct {\n\t\t__le32 freq;\n\t\t__le32 m_volt;\n\t} opps[MAX_DVFS_OPPS];\n} __packed;\n\nstruct dvfs_set {\n\tu8 domain;\n\tu8 index;\n} __packed;\n\nstruct _scpi_sensor_info {\n\t__le16 sensor_id;\n\tu8 class;\n\tu8 trigger_type;\n\tchar name[20];\n};\n\nstruct dev_pstate_set {\n\t__le16 dev_id;\n\tu8 pstate;\n} __packed;\n\nstatic struct scpi_drvinfo *scpi_info;\n\nstatic int scpi_linux_errmap[SCPI_ERR_MAX] = {\n\t \n\t0,  \n\t-EINVAL,  \n\t-ENOEXEC,  \n\t-EMSGSIZE,  \n\t-EINVAL,  \n\t-EACCES,  \n\t-ERANGE,  \n\t-ETIMEDOUT,  \n\t-ENOMEM,  \n\t-EINVAL,  \n\t-EOPNOTSUPP,  \n\t-EIO,  \n\t-EBUSY,  \n};\n\nstatic inline int scpi_to_linux_errno(int errno)\n{\n\tif (errno >= SCPI_SUCCESS && errno < SCPI_ERR_MAX)\n\t\treturn scpi_linux_errmap[errno];\n\treturn -EIO;\n}\n\nstatic void scpi_process_cmd(struct scpi_chan *ch, u32 cmd)\n{\n\tunsigned long flags;\n\tstruct scpi_xfer *t, *match = NULL;\n\n\tspin_lock_irqsave(&ch->rx_lock, flags);\n\tif (list_empty(&ch->rx_pending)) {\n\t\tspin_unlock_irqrestore(&ch->rx_lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tif (scpi_info->is_legacy) {\n\t\tmatch = list_first_entry(&ch->rx_pending, struct scpi_xfer,\n\t\t\t\t\t node);\n\t\tlist_del(&match->node);\n\t} else {\n\t\tlist_for_each_entry(t, &ch->rx_pending, node)\n\t\t\tif (CMD_XTRACT_UNIQ(t->cmd) == CMD_XTRACT_UNIQ(cmd)) {\n\t\t\t\tlist_del(&t->node);\n\t\t\t\tmatch = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\t \n\tif (match && !completion_done(&match->done)) {\n\t\tunsigned int len;\n\n\t\tif (scpi_info->is_legacy) {\n\t\t\tstruct legacy_scpi_shared_mem __iomem *mem =\n\t\t\t\t\t\t\tch->rx_payload;\n\n\t\t\t \n\t\t\tlen = match->rx_len;\n\n\t\t\tmatch->status = ioread32(&mem->status);\n\t\t\tmemcpy_fromio(match->rx_buf, mem->payload, len);\n\t\t} else {\n\t\t\tstruct scpi_shared_mem __iomem *mem = ch->rx_payload;\n\n\t\t\tlen = min_t(unsigned int, match->rx_len, CMD_SIZE(cmd));\n\n\t\t\tmatch->status = ioread32(&mem->status);\n\t\t\tmemcpy_fromio(match->rx_buf, mem->payload, len);\n\t\t}\n\n\t\tif (match->rx_len > len)\n\t\t\tmemset(match->rx_buf + len, 0, match->rx_len - len);\n\t\tcomplete(&match->done);\n\t}\n\tspin_unlock_irqrestore(&ch->rx_lock, flags);\n}\n\nstatic void scpi_handle_remote_msg(struct mbox_client *c, void *msg)\n{\n\tstruct scpi_chan *ch = container_of(c, struct scpi_chan, cl);\n\tstruct scpi_shared_mem __iomem *mem = ch->rx_payload;\n\tu32 cmd = 0;\n\n\tif (!scpi_info->is_legacy)\n\t\tcmd = ioread32(&mem->command);\n\n\tscpi_process_cmd(ch, cmd);\n}\n\nstatic void scpi_tx_prepare(struct mbox_client *c, void *msg)\n{\n\tunsigned long flags;\n\tstruct scpi_xfer *t = msg;\n\tstruct scpi_chan *ch = container_of(c, struct scpi_chan, cl);\n\tstruct scpi_shared_mem __iomem *mem = ch->tx_payload;\n\n\tif (t->tx_buf) {\n\t\tif (scpi_info->is_legacy)\n\t\t\tmemcpy_toio(ch->tx_payload, t->tx_buf, t->tx_len);\n\t\telse\n\t\t\tmemcpy_toio(mem->payload, t->tx_buf, t->tx_len);\n\t}\n\n\tif (t->rx_buf) {\n\t\tif (!(++ch->token))\n\t\t\t++ch->token;\n\t\tt->cmd |= FIELD_PREP(CMD_TOKEN_ID_MASK, ch->token);\n\t\tspin_lock_irqsave(&ch->rx_lock, flags);\n\t\tlist_add_tail(&t->node, &ch->rx_pending);\n\t\tspin_unlock_irqrestore(&ch->rx_lock, flags);\n\t}\n\n\tif (!scpi_info->is_legacy)\n\t\tiowrite32(t->cmd, &mem->command);\n}\n\nstatic struct scpi_xfer *get_scpi_xfer(struct scpi_chan *ch)\n{\n\tstruct scpi_xfer *t;\n\n\tmutex_lock(&ch->xfers_lock);\n\tif (list_empty(&ch->xfers_list)) {\n\t\tmutex_unlock(&ch->xfers_lock);\n\t\treturn NULL;\n\t}\n\tt = list_first_entry(&ch->xfers_list, struct scpi_xfer, node);\n\tlist_del(&t->node);\n\tmutex_unlock(&ch->xfers_lock);\n\treturn t;\n}\n\nstatic void put_scpi_xfer(struct scpi_xfer *t, struct scpi_chan *ch)\n{\n\tmutex_lock(&ch->xfers_lock);\n\tlist_add_tail(&t->node, &ch->xfers_list);\n\tmutex_unlock(&ch->xfers_lock);\n}\n\nstatic int scpi_send_message(u8 idx, void *tx_buf, unsigned int tx_len,\n\t\t\t     void *rx_buf, unsigned int rx_len)\n{\n\tint ret;\n\tu8 chan;\n\tu8 cmd;\n\tstruct scpi_xfer *msg;\n\tstruct scpi_chan *scpi_chan;\n\n\tif (scpi_info->commands[idx] < 0)\n\t\treturn -EOPNOTSUPP;\n\n\tcmd = scpi_info->commands[idx];\n\n\tif (scpi_info->is_legacy)\n\t\tchan = test_bit(cmd, scpi_info->cmd_priority) ? 1 : 0;\n\telse\n\t\tchan = atomic_inc_return(&scpi_info->next_chan) %\n\t\t\tscpi_info->num_chans;\n\tscpi_chan = scpi_info->channels + chan;\n\n\tmsg = get_scpi_xfer(scpi_chan);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (scpi_info->is_legacy) {\n\t\tmsg->cmd = PACK_LEGACY_SCPI_CMD(cmd, tx_len);\n\t\tmsg->slot = msg->cmd;\n\t} else {\n\t\tmsg->slot = BIT(SCPI_SLOT);\n\t\tmsg->cmd = PACK_SCPI_CMD(cmd, tx_len);\n\t}\n\tmsg->tx_buf = tx_buf;\n\tmsg->tx_len = tx_len;\n\tmsg->rx_buf = rx_buf;\n\tmsg->rx_len = rx_len;\n\treinit_completion(&msg->done);\n\n\tret = mbox_send_message(scpi_chan->chan, msg);\n\tif (ret < 0 || !rx_buf)\n\t\tgoto out;\n\n\tif (!wait_for_completion_timeout(&msg->done, MAX_RX_TIMEOUT))\n\t\tret = -ETIMEDOUT;\n\telse\n\t\t \n\t\tret = msg->status;\nout:\n\tif (ret < 0 && rx_buf)  \n\t\tscpi_process_cmd(scpi_chan, msg->cmd);\n\n\tput_scpi_xfer(msg, scpi_chan);\n\t \n\treturn ret > 0 ? scpi_to_linux_errno(ret) : ret;\n}\n\nstatic u32 scpi_get_version(void)\n{\n\treturn scpi_info->protocol_version;\n}\n\nstatic int\nscpi_clk_get_range(u16 clk_id, unsigned long *min, unsigned long *max)\n{\n\tint ret;\n\tstruct clk_get_info clk;\n\t__le16 le_clk_id = cpu_to_le16(clk_id);\n\n\tret = scpi_send_message(CMD_GET_CLOCK_INFO, &le_clk_id,\n\t\t\t\tsizeof(le_clk_id), &clk, sizeof(clk));\n\tif (!ret) {\n\t\t*min = le32_to_cpu(clk.min_rate);\n\t\t*max = le32_to_cpu(clk.max_rate);\n\t}\n\treturn ret;\n}\n\nstatic unsigned long scpi_clk_get_val(u16 clk_id)\n{\n\tint ret;\n\t__le32 rate;\n\t__le16 le_clk_id = cpu_to_le16(clk_id);\n\n\tret = scpi_send_message(CMD_GET_CLOCK_VALUE, &le_clk_id,\n\t\t\t\tsizeof(le_clk_id), &rate, sizeof(rate));\n\tif (ret)\n\t\treturn 0;\n\n\treturn le32_to_cpu(rate);\n}\n\nstatic int scpi_clk_set_val(u16 clk_id, unsigned long rate)\n{\n\tint stat;\n\tstruct clk_set_value clk = {\n\t\t.id = cpu_to_le16(clk_id),\n\t\t.rate = cpu_to_le32(rate)\n\t};\n\n\treturn scpi_send_message(CMD_SET_CLOCK_VALUE, &clk, sizeof(clk),\n\t\t\t\t &stat, sizeof(stat));\n}\n\nstatic int legacy_scpi_clk_set_val(u16 clk_id, unsigned long rate)\n{\n\tint stat;\n\tstruct legacy_clk_set_value clk = {\n\t\t.id = cpu_to_le16(clk_id),\n\t\t.rate = cpu_to_le32(rate)\n\t};\n\n\treturn scpi_send_message(CMD_SET_CLOCK_VALUE, &clk, sizeof(clk),\n\t\t\t\t &stat, sizeof(stat));\n}\n\nstatic int scpi_dvfs_get_idx(u8 domain)\n{\n\tint ret;\n\tu8 dvfs_idx;\n\n\tret = scpi_send_message(CMD_GET_DVFS, &domain, sizeof(domain),\n\t\t\t\t&dvfs_idx, sizeof(dvfs_idx));\n\n\treturn ret ? ret : dvfs_idx;\n}\n\nstatic int scpi_dvfs_set_idx(u8 domain, u8 index)\n{\n\tint stat;\n\tstruct dvfs_set dvfs = {domain, index};\n\n\treturn scpi_send_message(CMD_SET_DVFS, &dvfs, sizeof(dvfs),\n\t\t\t\t &stat, sizeof(stat));\n}\n\nstatic int opp_cmp_func(const void *opp1, const void *opp2)\n{\n\tconst struct scpi_opp *t1 = opp1, *t2 = opp2;\n\n\treturn t1->freq - t2->freq;\n}\n\nstatic struct scpi_dvfs_info *scpi_dvfs_get_info(u8 domain)\n{\n\tstruct scpi_dvfs_info *info;\n\tstruct scpi_opp *opp;\n\tstruct dvfs_info buf;\n\tint ret, i;\n\n\tif (domain >= MAX_DVFS_DOMAINS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (scpi_info->dvfs[domain])\t \n\t\treturn scpi_info->dvfs[domain];\n\n\tret = scpi_send_message(CMD_GET_DVFS_INFO, &domain, sizeof(domain),\n\t\t\t\t&buf, sizeof(buf));\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo->count = buf.opp_count;\n\tinfo->latency = le16_to_cpu(buf.latency) * 1000;  \n\n\tinfo->opps = kcalloc(info->count, sizeof(*opp), GFP_KERNEL);\n\tif (!info->opps) {\n\t\tkfree(info);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfor (i = 0, opp = info->opps; i < info->count; i++, opp++) {\n\t\topp->freq = le32_to_cpu(buf.opps[i].freq);\n\t\topp->m_volt = le32_to_cpu(buf.opps[i].m_volt);\n\t}\n\n\tsort(info->opps, info->count, sizeof(*opp), opp_cmp_func, NULL);\n\n\tscpi_info->dvfs[domain] = info;\n\treturn info;\n}\n\nstatic int scpi_dev_domain_id(struct device *dev)\n{\n\tstruct of_phandle_args clkspec;\n\n\tif (of_parse_phandle_with_args(dev->of_node, \"clocks\", \"#clock-cells\",\n\t\t\t\t       0, &clkspec))\n\t\treturn -EINVAL;\n\n\treturn clkspec.args[0];\n}\n\nstatic struct scpi_dvfs_info *scpi_dvfs_info(struct device *dev)\n{\n\tint domain = scpi_dev_domain_id(dev);\n\n\tif (domain < 0)\n\t\treturn ERR_PTR(domain);\n\n\treturn scpi_dvfs_get_info(domain);\n}\n\nstatic int scpi_dvfs_get_transition_latency(struct device *dev)\n{\n\tstruct scpi_dvfs_info *info = scpi_dvfs_info(dev);\n\n\tif (IS_ERR(info))\n\t\treturn PTR_ERR(info);\n\n\treturn info->latency;\n}\n\nstatic int scpi_dvfs_add_opps_to_device(struct device *dev)\n{\n\tint idx, ret;\n\tstruct scpi_opp *opp;\n\tstruct scpi_dvfs_info *info = scpi_dvfs_info(dev);\n\n\tif (IS_ERR(info))\n\t\treturn PTR_ERR(info);\n\n\tif (!info->opps)\n\t\treturn -EIO;\n\n\tfor (opp = info->opps, idx = 0; idx < info->count; idx++, opp++) {\n\t\tret = dev_pm_opp_add(dev, opp->freq, opp->m_volt * 1000);\n\t\tif (ret) {\n\t\t\tdev_warn(dev, \"failed to add opp %uHz %umV\\n\",\n\t\t\t\t opp->freq, opp->m_volt);\n\t\t\twhile (idx-- > 0)\n\t\t\t\tdev_pm_opp_remove(dev, (--opp)->freq);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int scpi_sensor_get_capability(u16 *sensors)\n{\n\t__le16 cap;\n\tint ret;\n\n\tret = scpi_send_message(CMD_SENSOR_CAPABILITIES, NULL, 0, &cap,\n\t\t\t\tsizeof(cap));\n\tif (!ret)\n\t\t*sensors = le16_to_cpu(cap);\n\n\treturn ret;\n}\n\nstatic int scpi_sensor_get_info(u16 sensor_id, struct scpi_sensor_info *info)\n{\n\t__le16 id = cpu_to_le16(sensor_id);\n\tstruct _scpi_sensor_info _info;\n\tint ret;\n\n\tret = scpi_send_message(CMD_SENSOR_INFO, &id, sizeof(id),\n\t\t\t\t&_info, sizeof(_info));\n\tif (!ret) {\n\t\tmemcpy(info, &_info, sizeof(*info));\n\t\tinfo->sensor_id = le16_to_cpu(_info.sensor_id);\n\t}\n\n\treturn ret;\n}\n\nstatic int scpi_sensor_get_value(u16 sensor, u64 *val)\n{\n\t__le16 id = cpu_to_le16(sensor);\n\t__le64 value;\n\tint ret;\n\n\tret = scpi_send_message(CMD_SENSOR_VALUE, &id, sizeof(id),\n\t\t\t\t&value, sizeof(value));\n\tif (ret)\n\t\treturn ret;\n\n\tif (scpi_info->is_legacy)\n\t\t \n\t\t*val = le32_to_cpup((__le32 *)&value);\n\telse\n\t\t*val = le64_to_cpu(value);\n\n\treturn 0;\n}\n\nstatic int scpi_device_get_power_state(u16 dev_id)\n{\n\tint ret;\n\tu8 pstate;\n\t__le16 id = cpu_to_le16(dev_id);\n\n\tret = scpi_send_message(CMD_GET_DEVICE_PWR_STATE, &id,\n\t\t\t\tsizeof(id), &pstate, sizeof(pstate));\n\treturn ret ? ret : pstate;\n}\n\nstatic int scpi_device_set_power_state(u16 dev_id, u8 pstate)\n{\n\tint stat;\n\tstruct dev_pstate_set dev_set = {\n\t\t.dev_id = cpu_to_le16(dev_id),\n\t\t.pstate = pstate,\n\t};\n\n\treturn scpi_send_message(CMD_SET_DEVICE_PWR_STATE, &dev_set,\n\t\t\t\t sizeof(dev_set), &stat, sizeof(stat));\n}\n\nstatic struct scpi_ops scpi_ops = {\n\t.get_version = scpi_get_version,\n\t.clk_get_range = scpi_clk_get_range,\n\t.clk_get_val = scpi_clk_get_val,\n\t.clk_set_val = scpi_clk_set_val,\n\t.dvfs_get_idx = scpi_dvfs_get_idx,\n\t.dvfs_set_idx = scpi_dvfs_set_idx,\n\t.dvfs_get_info = scpi_dvfs_get_info,\n\t.device_domain_id = scpi_dev_domain_id,\n\t.get_transition_latency = scpi_dvfs_get_transition_latency,\n\t.add_opps_to_device = scpi_dvfs_add_opps_to_device,\n\t.sensor_get_capability = scpi_sensor_get_capability,\n\t.sensor_get_info = scpi_sensor_get_info,\n\t.sensor_get_value = scpi_sensor_get_value,\n\t.device_get_power_state = scpi_device_get_power_state,\n\t.device_set_power_state = scpi_device_set_power_state,\n};\n\nstruct scpi_ops *get_scpi_ops(void)\n{\n\treturn scpi_info ? scpi_info->scpi_ops : NULL;\n}\nEXPORT_SYMBOL_GPL(get_scpi_ops);\n\nstatic int scpi_init_versions(struct scpi_drvinfo *info)\n{\n\tint ret;\n\tstruct scp_capabilities caps;\n\n\tret = scpi_send_message(CMD_SCPI_CAPABILITIES, NULL, 0,\n\t\t\t\t&caps, sizeof(caps));\n\tif (!ret) {\n\t\tinfo->protocol_version = le32_to_cpu(caps.protocol_version);\n\t\tinfo->firmware_version = le32_to_cpu(caps.platform_version);\n\t}\n\t \n\tif (info->is_legacy && ret == -EOPNOTSUPP)\n\t\treturn 0;\n\n\treturn ret;\n}\n\nstatic ssize_t protocol_version_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct scpi_drvinfo *scpi_info = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%lu.%lu\\n\",\n\t\tFIELD_GET(PROTO_REV_MAJOR_MASK, scpi_info->protocol_version),\n\t\tFIELD_GET(PROTO_REV_MINOR_MASK, scpi_info->protocol_version));\n}\nstatic DEVICE_ATTR_RO(protocol_version);\n\nstatic ssize_t firmware_version_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct scpi_drvinfo *scpi_info = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%lu.%lu.%lu\\n\",\n\t\tFIELD_GET(FW_REV_MAJOR_MASK, scpi_info->firmware_version),\n\t\tFIELD_GET(FW_REV_MINOR_MASK, scpi_info->firmware_version),\n\t\tFIELD_GET(FW_REV_PATCH_MASK, scpi_info->firmware_version));\n}\nstatic DEVICE_ATTR_RO(firmware_version);\n\nstatic struct attribute *versions_attrs[] = {\n\t&dev_attr_firmware_version.attr,\n\t&dev_attr_protocol_version.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(versions);\n\nstatic void scpi_free_channels(void *data)\n{\n\tstruct scpi_drvinfo *info = data;\n\tint i;\n\n\tfor (i = 0; i < info->num_chans; i++)\n\t\tmbox_free_channel(info->channels[i].chan);\n}\n\nstatic int scpi_remove(struct platform_device *pdev)\n{\n\tint i;\n\tstruct scpi_drvinfo *info = platform_get_drvdata(pdev);\n\n\tscpi_info = NULL;  \n\n\tfor (i = 0; i < MAX_DVFS_DOMAINS && info->dvfs[i]; i++) {\n\t\tkfree(info->dvfs[i]->opps);\n\t\tkfree(info->dvfs[i]);\n\t}\n\n\treturn 0;\n}\n\n#define MAX_SCPI_XFERS\t\t10\nstatic int scpi_alloc_xfer_list(struct device *dev, struct scpi_chan *ch)\n{\n\tint i;\n\tstruct scpi_xfer *xfers;\n\n\txfers = devm_kcalloc(dev, MAX_SCPI_XFERS, sizeof(*xfers), GFP_KERNEL);\n\tif (!xfers)\n\t\treturn -ENOMEM;\n\n\tch->xfers = xfers;\n\tfor (i = 0; i < MAX_SCPI_XFERS; i++, xfers++) {\n\t\tinit_completion(&xfers->done);\n\t\tlist_add_tail(&xfers->node, &ch->xfers_list);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id legacy_scpi_of_match[] = {\n\t{.compatible = \"arm,scpi-pre-1.0\"},\n\t{},\n};\n\nstatic const struct of_device_id shmem_of_match[] __maybe_unused = {\n\t{ .compatible = \"amlogic,meson-gxbb-scp-shmem\", },\n\t{ .compatible = \"amlogic,meson-axg-scp-shmem\", },\n\t{ .compatible = \"arm,juno-scp-shmem\", },\n\t{ .compatible = \"arm,scp-shmem\", },\n\t{ }\n};\n\nstatic int scpi_probe(struct platform_device *pdev)\n{\n\tint count, idx, ret;\n\tstruct resource res;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct scpi_drvinfo *scpi_drvinfo;\n\n\tscpi_drvinfo = devm_kzalloc(dev, sizeof(*scpi_drvinfo), GFP_KERNEL);\n\tif (!scpi_drvinfo)\n\t\treturn -ENOMEM;\n\n\tif (of_match_device(legacy_scpi_of_match, &pdev->dev))\n\t\tscpi_drvinfo->is_legacy = true;\n\n\tcount = of_count_phandle_with_args(np, \"mboxes\", \"#mbox-cells\");\n\tif (count < 0) {\n\t\tdev_err(dev, \"no mboxes property in '%pOF'\\n\", np);\n\t\treturn -ENODEV;\n\t}\n\n\tscpi_drvinfo->channels =\n\t\tdevm_kcalloc(dev, count, sizeof(struct scpi_chan), GFP_KERNEL);\n\tif (!scpi_drvinfo->channels)\n\t\treturn -ENOMEM;\n\n\tret = devm_add_action(dev, scpi_free_channels, scpi_drvinfo);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (; scpi_drvinfo->num_chans < count; scpi_drvinfo->num_chans++) {\n\t\tresource_size_t size;\n\t\tint idx = scpi_drvinfo->num_chans;\n\t\tstruct scpi_chan *pchan = scpi_drvinfo->channels + idx;\n\t\tstruct mbox_client *cl = &pchan->cl;\n\t\tstruct device_node *shmem = of_parse_phandle(np, \"shmem\", idx);\n\n\t\tif (!of_match_node(shmem_of_match, shmem))\n\t\t\treturn -ENXIO;\n\n\t\tret = of_address_to_resource(shmem, 0, &res);\n\t\tof_node_put(shmem);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to get SCPI payload mem resource\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tsize = resource_size(&res);\n\t\tpchan->rx_payload = devm_ioremap(dev, res.start, size);\n\t\tif (!pchan->rx_payload) {\n\t\t\tdev_err(dev, \"failed to ioremap SCPI payload\\n\");\n\t\t\treturn -EADDRNOTAVAIL;\n\t\t}\n\t\tpchan->tx_payload = pchan->rx_payload + (size >> 1);\n\n\t\tcl->dev = dev;\n\t\tcl->rx_callback = scpi_handle_remote_msg;\n\t\tcl->tx_prepare = scpi_tx_prepare;\n\t\tcl->tx_block = true;\n\t\tcl->tx_tout = 20;\n\t\tcl->knows_txdone = false;  \n\n\t\tINIT_LIST_HEAD(&pchan->rx_pending);\n\t\tINIT_LIST_HEAD(&pchan->xfers_list);\n\t\tspin_lock_init(&pchan->rx_lock);\n\t\tmutex_init(&pchan->xfers_lock);\n\n\t\tret = scpi_alloc_xfer_list(dev, pchan);\n\t\tif (!ret) {\n\t\t\tpchan->chan = mbox_request_channel(cl, idx);\n\t\t\tif (!IS_ERR(pchan->chan))\n\t\t\t\tcontinue;\n\t\t\tret = PTR_ERR(pchan->chan);\n\t\t\tif (ret != -EPROBE_DEFER)\n\t\t\t\tdev_err(dev, \"failed to get channel%d err %d\\n\",\n\t\t\t\t\tidx, ret);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tscpi_drvinfo->commands = scpi_std_commands;\n\n\tplatform_set_drvdata(pdev, scpi_drvinfo);\n\n\tif (scpi_drvinfo->is_legacy) {\n\t\t \n\t\tscpi_ops.clk_set_val = legacy_scpi_clk_set_val;\n\t\tscpi_drvinfo->commands = scpi_legacy_commands;\n\n\t\t \n\t\tfor (idx = 0; idx < ARRAY_SIZE(legacy_hpriority_cmds); idx++)\n\t\t\tset_bit(legacy_hpriority_cmds[idx],\n\t\t\t\tscpi_drvinfo->cmd_priority);\n\t}\n\n\tscpi_info = scpi_drvinfo;\n\n\tret = scpi_init_versions(scpi_drvinfo);\n\tif (ret) {\n\t\tdev_err(dev, \"incorrect or no SCP firmware found\\n\");\n\t\tscpi_info = NULL;\n\t\treturn ret;\n\t}\n\n\tif (scpi_drvinfo->is_legacy && !scpi_drvinfo->protocol_version &&\n\t    !scpi_drvinfo->firmware_version)\n\t\tdev_info(dev, \"SCP Protocol legacy pre-1.0 firmware\\n\");\n\telse\n\t\tdev_info(dev, \"SCP Protocol %lu.%lu Firmware %lu.%lu.%lu version\\n\",\n\t\t\t FIELD_GET(PROTO_REV_MAJOR_MASK,\n\t\t\t\t   scpi_drvinfo->protocol_version),\n\t\t\t FIELD_GET(PROTO_REV_MINOR_MASK,\n\t\t\t\t   scpi_drvinfo->protocol_version),\n\t\t\t FIELD_GET(FW_REV_MAJOR_MASK,\n\t\t\t\t   scpi_drvinfo->firmware_version),\n\t\t\t FIELD_GET(FW_REV_MINOR_MASK,\n\t\t\t\t   scpi_drvinfo->firmware_version),\n\t\t\t FIELD_GET(FW_REV_PATCH_MASK,\n\t\t\t\t   scpi_drvinfo->firmware_version));\n\n\tscpi_drvinfo->scpi_ops = &scpi_ops;\n\n\tret = devm_of_platform_populate(dev);\n\tif (ret)\n\t\tscpi_info = NULL;\n\n\treturn ret;\n}\n\nstatic const struct of_device_id scpi_of_match[] = {\n\t{.compatible = \"arm,scpi\"},\n\t{.compatible = \"arm,scpi-pre-1.0\"},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, scpi_of_match);\n\nstatic struct platform_driver scpi_driver = {\n\t.driver = {\n\t\t.name = \"scpi_protocol\",\n\t\t.of_match_table = scpi_of_match,\n\t\t.dev_groups = versions_groups,\n\t},\n\t.probe = scpi_probe,\n\t.remove = scpi_remove,\n};\nmodule_platform_driver(scpi_driver);\n\nMODULE_AUTHOR(\"Sudeep Holla <sudeep.holla@arm.com>\");\nMODULE_DESCRIPTION(\"ARM SCPI mailbox protocol driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}