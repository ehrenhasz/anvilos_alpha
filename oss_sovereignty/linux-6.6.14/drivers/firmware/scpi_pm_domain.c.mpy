{
  "module_name": "scpi_pm_domain.c",
  "hash_id": "b2b1403bf9a8198985d3ea03b59dd1d9be24f192b3d0d7af1a60e141ea140f84",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/scpi_pm_domain.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/scpi_protocol.h>\n\nstruct scpi_pm_domain {\n\tstruct generic_pm_domain genpd;\n\tstruct scpi_ops *ops;\n\tu32 domain;\n};\n\n \nenum scpi_power_domain_state {\n\tSCPI_PD_STATE_ON = 0,\n\tSCPI_PD_STATE_OFF = 3,\n};\n\n#define to_scpi_pd(gpd) container_of(gpd, struct scpi_pm_domain, genpd)\n\nstatic int scpi_pd_power(struct scpi_pm_domain *pd, bool power_on)\n{\n\tint ret;\n\tenum scpi_power_domain_state state;\n\n\tif (power_on)\n\t\tstate = SCPI_PD_STATE_ON;\n\telse\n\t\tstate = SCPI_PD_STATE_OFF;\n\n\tret = pd->ops->device_set_power_state(pd->domain, state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !(state == pd->ops->device_get_power_state(pd->domain));\n}\n\nstatic int scpi_pd_power_on(struct generic_pm_domain *domain)\n{\n\tstruct scpi_pm_domain *pd = to_scpi_pd(domain);\n\n\treturn scpi_pd_power(pd, true);\n}\n\nstatic int scpi_pd_power_off(struct generic_pm_domain *domain)\n{\n\tstruct scpi_pm_domain *pd = to_scpi_pd(domain);\n\n\treturn scpi_pd_power(pd, false);\n}\n\nstatic int scpi_pm_domain_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct scpi_pm_domain *scpi_pd;\n\tstruct genpd_onecell_data *scpi_pd_data;\n\tstruct generic_pm_domain **domains;\n\tstruct scpi_ops *scpi_ops;\n\tint ret, num_domains, i;\n\n\tscpi_ops = get_scpi_ops();\n\tif (!scpi_ops)\n\t\treturn -EPROBE_DEFER;\n\n\tif (!np) {\n\t\tdev_err(dev, \"device tree node not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!scpi_ops->device_set_power_state ||\n\t    !scpi_ops->device_get_power_state) {\n\t\tdev_err(dev, \"power domains not supported in the firmware\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = of_property_read_u32(np, \"num-domains\", &num_domains);\n\tif (ret) {\n\t\tdev_err(dev, \"number of domains not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tscpi_pd = devm_kcalloc(dev, num_domains, sizeof(*scpi_pd), GFP_KERNEL);\n\tif (!scpi_pd)\n\t\treturn -ENOMEM;\n\n\tscpi_pd_data = devm_kzalloc(dev, sizeof(*scpi_pd_data), GFP_KERNEL);\n\tif (!scpi_pd_data)\n\t\treturn -ENOMEM;\n\n\tdomains = devm_kcalloc(dev, num_domains, sizeof(*domains), GFP_KERNEL);\n\tif (!domains)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_domains; i++, scpi_pd++) {\n\t\tdomains[i] = &scpi_pd->genpd;\n\n\t\tscpi_pd->domain = i;\n\t\tscpi_pd->ops = scpi_ops;\n\t\tscpi_pd->genpd.name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t     \"%pOFn.%d\", np, i);\n\t\tif (!scpi_pd->genpd.name) {\n\t\t\tdev_err(dev, \"Failed to allocate genpd name:%pOFn.%d\\n\",\n\t\t\t\tnp, i);\n\t\t\tcontinue;\n\t\t}\n\t\tscpi_pd->genpd.power_off = scpi_pd_power_off;\n\t\tscpi_pd->genpd.power_on = scpi_pd_power_on;\n\n\t\t \n\t\tpm_genpd_init(&scpi_pd->genpd, NULL, true);\n\t}\n\n\tscpi_pd_data->domains = domains;\n\tscpi_pd_data->num_domains = num_domains;\n\n\tof_genpd_add_provider_onecell(np, scpi_pd_data);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id scpi_power_domain_ids[] = {\n\t{ .compatible = \"arm,scpi-power-domains\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, scpi_power_domain_ids);\n\nstatic struct platform_driver scpi_power_domain_driver = {\n\t.driver\t= {\n\t\t.name = \"scpi_power_domain\",\n\t\t.of_match_table = scpi_power_domain_ids,\n\t},\n\t.probe = scpi_pm_domain_probe,\n};\nmodule_platform_driver(scpi_power_domain_driver);\n\nMODULE_AUTHOR(\"Sudeep Holla <sudeep.holla@arm.com>\");\nMODULE_DESCRIPTION(\"ARM SCPI power domain driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}