{
  "module_name": "raspberrypi.c",
  "hash_id": "fa1561afa1511a300960678f6438835af85edf43c7951aef51606525b39dd232",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/raspberrypi.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/kref.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <soc/bcm2835/raspberrypi-firmware.h>\n\n#define MBOX_MSG(chan, data28)\t\t(((data28) & ~0xf) | ((chan) & 0xf))\n#define MBOX_CHAN(msg)\t\t\t((msg) & 0xf)\n#define MBOX_DATA28(msg)\t\t((msg) & ~0xf)\n#define MBOX_CHAN_PROPERTY\t\t8\n\nstatic struct platform_device *rpi_hwmon;\nstatic struct platform_device *rpi_clk;\n\nstruct rpi_firmware {\n\tstruct mbox_client cl;\n\tstruct mbox_chan *chan;  \n\tstruct completion c;\n\tu32 enabled;\n\n\tstruct kref consumers;\n};\n\nstatic DEFINE_MUTEX(transaction_lock);\n\nstatic void response_callback(struct mbox_client *cl, void *msg)\n{\n\tstruct rpi_firmware *fw = container_of(cl, struct rpi_firmware, cl);\n\tcomplete(&fw->c);\n}\n\n \nstatic int\nrpi_firmware_transaction(struct rpi_firmware *fw, u32 chan, u32 data)\n{\n\tu32 message = MBOX_MSG(chan, data);\n\tint ret;\n\n\tWARN_ON(data & 0xf);\n\n\tmutex_lock(&transaction_lock);\n\treinit_completion(&fw->c);\n\tret = mbox_send_message(fw->chan, &message);\n\tif (ret >= 0) {\n\t\tif (wait_for_completion_timeout(&fw->c, HZ)) {\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tWARN_ONCE(1, \"Firmware transaction timeout\");\n\t\t}\n\t} else {\n\t\tdev_err(fw->cl.dev, \"mbox_send_message returned %d\\n\", ret);\n\t}\n\tmutex_unlock(&transaction_lock);\n\n\treturn ret;\n}\n\n \nint rpi_firmware_property_list(struct rpi_firmware *fw,\n\t\t\t       void *data, size_t tag_size)\n{\n\tsize_t size = tag_size + 12;\n\tu32 *buf;\n\tdma_addr_t bus_addr;\n\tint ret;\n\n\t \n\tif (size & 3)\n\t\treturn -EINVAL;\n\n\tbuf = dma_alloc_coherent(fw->cl.dev, PAGE_ALIGN(size), &bus_addr,\n\t\t\t\t GFP_ATOMIC);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tWARN_ON(size >= 1024 * 1024);\n\n\tbuf[0] = size;\n\tbuf[1] = RPI_FIRMWARE_STATUS_REQUEST;\n\tmemcpy(&buf[2], data, tag_size);\n\tbuf[size / 4 - 1] = RPI_FIRMWARE_PROPERTY_END;\n\twmb();\n\n\tret = rpi_firmware_transaction(fw, MBOX_CHAN_PROPERTY, bus_addr);\n\n\trmb();\n\tmemcpy(data, &buf[2], tag_size);\n\tif (ret == 0 && buf[1] != RPI_FIRMWARE_STATUS_SUCCESS) {\n\t\t \n\t\tdev_err(fw->cl.dev, \"Request 0x%08x returned status 0x%08x\\n\",\n\t\t\tbuf[2], buf[1]);\n\t\tret = -EINVAL;\n\t}\n\n\tdma_free_coherent(fw->cl.dev, PAGE_ALIGN(size), buf, bus_addr);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(rpi_firmware_property_list);\n\n \nint rpi_firmware_property(struct rpi_firmware *fw,\n\t\t\t  u32 tag, void *tag_data, size_t buf_size)\n{\n\tstruct rpi_firmware_property_tag_header *header;\n\tint ret;\n\n\t \n\tvoid *data = kmalloc(sizeof(*header) + buf_size, GFP_KERNEL);\n\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\theader = data;\n\theader->tag = tag;\n\theader->buf_size = buf_size;\n\theader->req_resp_size = 0;\n\tmemcpy(data + sizeof(*header), tag_data, buf_size);\n\n\tret = rpi_firmware_property_list(fw, data, buf_size + sizeof(*header));\n\n\tmemcpy(tag_data, data + sizeof(*header), buf_size);\n\n\tkfree(data);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(rpi_firmware_property);\n\nstatic void\nrpi_firmware_print_firmware_revision(struct rpi_firmware *fw)\n{\n\ttime64_t date_and_time;\n\tu32 packet;\n\tint ret = rpi_firmware_property(fw,\n\t\t\t\t\tRPI_FIRMWARE_GET_FIRMWARE_REVISION,\n\t\t\t\t\t&packet, sizeof(packet));\n\n\tif (ret)\n\t\treturn;\n\n\t \n\tdate_and_time = packet;\n\tdev_info(fw->cl.dev, \"Attached to firmware from %ptT\\n\", &date_and_time);\n}\n\nstatic void\nrpi_register_hwmon_driver(struct device *dev, struct rpi_firmware *fw)\n{\n\tu32 packet;\n\tint ret = rpi_firmware_property(fw, RPI_FIRMWARE_GET_THROTTLED,\n\t\t\t\t\t&packet, sizeof(packet));\n\n\tif (ret)\n\t\treturn;\n\n\trpi_hwmon = platform_device_register_data(dev, \"raspberrypi-hwmon\",\n\t\t\t\t\t\t  -1, NULL, 0);\n}\n\nstatic void rpi_register_clk_driver(struct device *dev)\n{\n\tstruct device_node *firmware;\n\n\t \n\tfirmware = of_get_compatible_child(dev->of_node,\n\t\t\t\t\t   \"raspberrypi,firmware-clocks\");\n\tif (firmware) {\n\t\tof_node_put(firmware);\n\t\treturn;\n\t}\n\n\trpi_clk = platform_device_register_data(dev, \"raspberrypi-clk\",\n\t\t\t\t\t\t-1, NULL, 0);\n}\n\nunsigned int rpi_firmware_clk_get_max_rate(struct rpi_firmware *fw, unsigned int id)\n{\n\tstruct rpi_firmware_clk_rate_request msg =\n\t\tRPI_FIRMWARE_CLK_RATE_REQUEST(id);\n\tint ret;\n\n\tret = rpi_firmware_property(fw, RPI_FIRMWARE_GET_MAX_CLOCK_RATE,\n\t\t\t\t    &msg, sizeof(msg));\n\tif (ret)\n\t\t \n\t\t return UINT_MAX;\n\n\treturn le32_to_cpu(msg.rate);\n}\nEXPORT_SYMBOL_GPL(rpi_firmware_clk_get_max_rate);\n\nstatic void rpi_firmware_delete(struct kref *kref)\n{\n\tstruct rpi_firmware *fw = container_of(kref, struct rpi_firmware,\n\t\t\t\t\t       consumers);\n\n\tmbox_free_channel(fw->chan);\n\tkfree(fw);\n}\n\nvoid rpi_firmware_put(struct rpi_firmware *fw)\n{\n\tkref_put(&fw->consumers, rpi_firmware_delete);\n}\nEXPORT_SYMBOL_GPL(rpi_firmware_put);\n\nstatic void devm_rpi_firmware_put(void *data)\n{\n\tstruct rpi_firmware *fw = data;\n\n\trpi_firmware_put(fw);\n}\n\nstatic int rpi_firmware_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rpi_firmware *fw;\n\n\t \n\tfw = kzalloc(sizeof(*fw), GFP_KERNEL);\n\tif (!fw)\n\t\treturn -ENOMEM;\n\n\tfw->cl.dev = dev;\n\tfw->cl.rx_callback = response_callback;\n\tfw->cl.tx_block = true;\n\n\tfw->chan = mbox_request_channel(&fw->cl, 0);\n\tif (IS_ERR(fw->chan)) {\n\t\tint ret = PTR_ERR(fw->chan);\n\t\tkfree(fw);\n\t\treturn dev_err_probe(dev, ret, \"Failed to get mbox channel\\n\");\n\t}\n\n\tinit_completion(&fw->c);\n\tkref_init(&fw->consumers);\n\n\tplatform_set_drvdata(pdev, fw);\n\n\trpi_firmware_print_firmware_revision(fw);\n\trpi_register_hwmon_driver(dev, fw);\n\trpi_register_clk_driver(dev);\n\n\treturn 0;\n}\n\nstatic void rpi_firmware_shutdown(struct platform_device *pdev)\n{\n\tstruct rpi_firmware *fw = platform_get_drvdata(pdev);\n\n\tif (!fw)\n\t\treturn;\n\n\trpi_firmware_property(fw, RPI_FIRMWARE_NOTIFY_REBOOT, NULL, 0);\n}\n\nstatic int rpi_firmware_remove(struct platform_device *pdev)\n{\n\tstruct rpi_firmware *fw = platform_get_drvdata(pdev);\n\n\tplatform_device_unregister(rpi_hwmon);\n\trpi_hwmon = NULL;\n\tplatform_device_unregister(rpi_clk);\n\trpi_clk = NULL;\n\n\trpi_firmware_put(fw);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rpi_firmware_of_match[] = {\n\t{ .compatible = \"raspberrypi,bcm2835-firmware\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rpi_firmware_of_match);\n\nstruct device_node *rpi_firmware_find_node(void)\n{\n\treturn of_find_matching_node(NULL, rpi_firmware_of_match);\n}\nEXPORT_SYMBOL_GPL(rpi_firmware_find_node);\n\n \nstruct rpi_firmware *rpi_firmware_get(struct device_node *firmware_node)\n{\n\tstruct platform_device *pdev = of_find_device_by_node(firmware_node);\n\tstruct rpi_firmware *fw;\n\n\tif (!pdev)\n\t\treturn NULL;\n\n\tfw = platform_get_drvdata(pdev);\n\tif (!fw)\n\t\tgoto err_put_device;\n\n\tif (!kref_get_unless_zero(&fw->consumers))\n\t\tgoto err_put_device;\n\n\tput_device(&pdev->dev);\n\n\treturn fw;\n\nerr_put_device:\n\tput_device(&pdev->dev);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(rpi_firmware_get);\n\n \nstruct rpi_firmware *devm_rpi_firmware_get(struct device *dev,\n\t\t\t\t\t   struct device_node *firmware_node)\n{\n\tstruct rpi_firmware *fw;\n\n\tfw = rpi_firmware_get(firmware_node);\n\tif (!fw)\n\t\treturn NULL;\n\n\tif (devm_add_action_or_reset(dev, devm_rpi_firmware_put, fw))\n\t\treturn NULL;\n\n\treturn fw;\n}\nEXPORT_SYMBOL_GPL(devm_rpi_firmware_get);\n\nstatic struct platform_driver rpi_firmware_driver = {\n\t.driver = {\n\t\t.name = \"raspberrypi-firmware\",\n\t\t.of_match_table = rpi_firmware_of_match,\n\t},\n\t.probe\t\t= rpi_firmware_probe,\n\t.shutdown\t= rpi_firmware_shutdown,\n\t.remove\t\t= rpi_firmware_remove,\n};\nmodule_platform_driver(rpi_firmware_driver);\n\nMODULE_AUTHOR(\"Eric Anholt <eric@anholt.net>\");\nMODULE_DESCRIPTION(\"Raspberry Pi firmware driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}