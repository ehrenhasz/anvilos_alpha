{
  "module_name": "turris-mox-rwtm.c",
  "hash_id": "f18bbee9478e5a44b1f8ab43c60a783c0882211a64ffd38556e9faa7166d0373",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/turris-mox-rwtm.c",
  "human_readable_source": "\n \n\n#include <linux/armada-37xx-rwtm-mailbox.h>\n#include <linux/completion.h>\n#include <linux/debugfs.h>\n#include <linux/dma-mapping.h>\n#include <linux/hw_random.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define DRIVER_NAME\t\t\"turris-mox-rwtm\"\n\n \n\n#define MBOX_STS_SUCCESS\t(0 << 30)\n#define MBOX_STS_FAIL\t\t(1 << 30)\n#define MBOX_STS_BADCMD\t\t(2 << 30)\n#define MBOX_STS_ERROR(s)\t((s) & (3 << 30))\n#define MBOX_STS_VALUE(s)\t(((s) >> 10) & 0xfffff)\n#define MBOX_STS_CMD(s)\t\t((s) & 0x3ff)\n\nenum mbox_cmd {\n\tMBOX_CMD_GET_RANDOM\t= 1,\n\tMBOX_CMD_BOARD_INFO\t= 2,\n\tMBOX_CMD_ECDSA_PUB_KEY\t= 3,\n\tMBOX_CMD_HASH\t\t= 4,\n\tMBOX_CMD_SIGN\t\t= 5,\n\tMBOX_CMD_VERIFY\t\t= 6,\n\n\tMBOX_CMD_OTP_READ\t= 7,\n\tMBOX_CMD_OTP_WRITE\t= 8,\n};\n\nstruct mox_kobject;\n\nstruct mox_rwtm {\n\tstruct device *dev;\n\tstruct mbox_client mbox_client;\n\tstruct mbox_chan *mbox;\n\tstruct mox_kobject *kobj;\n\tstruct hwrng hwrng;\n\n\tstruct armada_37xx_rwtm_rx_msg reply;\n\n\tvoid *buf;\n\tdma_addr_t buf_phys;\n\n\tstruct mutex busy;\n\tstruct completion cmd_done;\n\n\t \n\tint has_board_info;\n\tu64 serial_number;\n\tint board_version, ram_size;\n\tu8 mac_address1[6], mac_address2[6];\n\n\t \n\tint has_pubkey;\n\tu8 pubkey[135];\n\n#ifdef CONFIG_DEBUG_FS\n\t \n\tstruct dentry *debugfs_root;\n\tu32 last_sig[34];\n\tint last_sig_done;\n#endif\n};\n\nstruct mox_kobject {\n\tstruct kobject kobj;\n\tstruct mox_rwtm *rwtm;\n};\n\nstatic inline struct kobject *rwtm_to_kobj(struct mox_rwtm *rwtm)\n{\n\treturn &rwtm->kobj->kobj;\n}\n\nstatic inline struct mox_rwtm *to_rwtm(struct kobject *kobj)\n{\n\treturn container_of(kobj, struct mox_kobject, kobj)->rwtm;\n}\n\nstatic void mox_kobj_release(struct kobject *kobj)\n{\n\tkfree(to_rwtm(kobj)->kobj);\n}\n\nstatic const struct kobj_type mox_kobj_ktype = {\n\t.release\t= mox_kobj_release,\n\t.sysfs_ops\t= &kobj_sysfs_ops,\n};\n\nstatic int mox_kobj_create(struct mox_rwtm *rwtm)\n{\n\trwtm->kobj = kzalloc(sizeof(*rwtm->kobj), GFP_KERNEL);\n\tif (!rwtm->kobj)\n\t\treturn -ENOMEM;\n\n\tkobject_init(rwtm_to_kobj(rwtm), &mox_kobj_ktype);\n\tif (kobject_add(rwtm_to_kobj(rwtm), firmware_kobj, \"turris-mox-rwtm\")) {\n\t\tkobject_put(rwtm_to_kobj(rwtm));\n\t\treturn -ENXIO;\n\t}\n\n\trwtm->kobj->rwtm = rwtm;\n\n\treturn 0;\n}\n\n#define MOX_ATTR_RO(name, format, cat)\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\\\nname##_show(struct kobject *kobj, struct kobj_attribute *a,\t\\\n\t    char *buf)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct mox_rwtm *rwtm = to_rwtm(kobj);\t\\\n\tif (!rwtm->has_##cat)\t\t\t\t\t\\\n\t\treturn -ENODATA;\t\t\t\t\\\n\treturn sprintf(buf, format, rwtm->name);\t\t\\\n}\t\t\t\t\t\t\t\t\\\nstatic struct kobj_attribute mox_attr_##name = __ATTR_RO(name)\n\nMOX_ATTR_RO(serial_number, \"%016llX\\n\", board_info);\nMOX_ATTR_RO(board_version, \"%i\\n\", board_info);\nMOX_ATTR_RO(ram_size, \"%i\\n\", board_info);\nMOX_ATTR_RO(mac_address1, \"%pM\\n\", board_info);\nMOX_ATTR_RO(mac_address2, \"%pM\\n\", board_info);\nMOX_ATTR_RO(pubkey, \"%s\\n\", pubkey);\n\nstatic int mox_get_status(enum mbox_cmd cmd, u32 retval)\n{\n\tif (MBOX_STS_CMD(retval) != cmd)\n\t\treturn -EIO;\n\telse if (MBOX_STS_ERROR(retval) == MBOX_STS_FAIL)\n\t\treturn -(int)MBOX_STS_VALUE(retval);\n\telse if (MBOX_STS_ERROR(retval) == MBOX_STS_BADCMD)\n\t\treturn -ENOSYS;\n\telse if (MBOX_STS_ERROR(retval) != MBOX_STS_SUCCESS)\n\t\treturn -EIO;\n\telse\n\t\treturn MBOX_STS_VALUE(retval);\n}\n\nstatic const struct attribute *mox_rwtm_attrs[] = {\n\t&mox_attr_serial_number.attr,\n\t&mox_attr_board_version.attr,\n\t&mox_attr_ram_size.attr,\n\t&mox_attr_mac_address1.attr,\n\t&mox_attr_mac_address2.attr,\n\t&mox_attr_pubkey.attr,\n\tNULL\n};\n\nstatic void mox_rwtm_rx_callback(struct mbox_client *cl, void *data)\n{\n\tstruct mox_rwtm *rwtm = dev_get_drvdata(cl->dev);\n\tstruct armada_37xx_rwtm_rx_msg *msg = data;\n\n\trwtm->reply = *msg;\n\tcomplete(&rwtm->cmd_done);\n}\n\nstatic void reply_to_mac_addr(u8 *mac, u32 t1, u32 t2)\n{\n\tmac[0] = t1 >> 8;\n\tmac[1] = t1;\n\tmac[2] = t2 >> 24;\n\tmac[3] = t2 >> 16;\n\tmac[4] = t2 >> 8;\n\tmac[5] = t2;\n}\n\nstatic int mox_get_board_info(struct mox_rwtm *rwtm)\n{\n\tstruct armada_37xx_rwtm_tx_msg msg;\n\tstruct armada_37xx_rwtm_rx_msg *reply = &rwtm->reply;\n\tint ret;\n\n\tmsg.command = MBOX_CMD_BOARD_INFO;\n\tret = mbox_send_message(rwtm->mbox, &msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wait_for_completion_timeout(&rwtm->cmd_done, HZ / 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mox_get_status(MBOX_CMD_BOARD_INFO, reply->retval);\n\tif (ret == -ENODATA) {\n\t\tdev_warn(rwtm->dev,\n\t\t\t \"Board does not have manufacturing information burned!\\n\");\n\t} else if (ret == -ENOSYS) {\n\t\tdev_notice(rwtm->dev,\n\t\t\t   \"Firmware does not support the BOARD_INFO command\\n\");\n\t} else if (ret < 0) {\n\t\treturn ret;\n\t} else {\n\t\trwtm->serial_number = reply->status[1];\n\t\trwtm->serial_number <<= 32;\n\t\trwtm->serial_number |= reply->status[0];\n\t\trwtm->board_version = reply->status[2];\n\t\trwtm->ram_size = reply->status[3];\n\t\treply_to_mac_addr(rwtm->mac_address1, reply->status[4],\n\t\t\t\t  reply->status[5]);\n\t\treply_to_mac_addr(rwtm->mac_address2, reply->status[6],\n\t\t\t\t  reply->status[7]);\n\t\trwtm->has_board_info = 1;\n\n\t\tpr_info(\"Turris Mox serial number %016llX\\n\",\n\t\t\trwtm->serial_number);\n\t\tpr_info(\"           board version %i\\n\", rwtm->board_version);\n\t\tpr_info(\"           burned RAM size %i MiB\\n\", rwtm->ram_size);\n\t}\n\n\tmsg.command = MBOX_CMD_ECDSA_PUB_KEY;\n\tret = mbox_send_message(rwtm->mbox, &msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wait_for_completion_timeout(&rwtm->cmd_done, HZ / 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mox_get_status(MBOX_CMD_ECDSA_PUB_KEY, reply->retval);\n\tif (ret == -ENODATA) {\n\t\tdev_warn(rwtm->dev, \"Board has no public key burned!\\n\");\n\t} else if (ret == -ENOSYS) {\n\t\tdev_notice(rwtm->dev,\n\t\t\t   \"Firmware does not support the ECDSA_PUB_KEY command\\n\");\n\t} else if (ret < 0) {\n\t\treturn ret;\n\t} else {\n\t\tu32 *s = reply->status;\n\n\t\trwtm->has_pubkey = 1;\n\t\tsprintf(rwtm->pubkey,\n\t\t\t\"%06x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x\",\n\t\t\tret, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],\n\t\t\ts[8], s[9], s[10], s[11], s[12], s[13], s[14], s[15]);\n\t}\n\n\treturn 0;\n}\n\nstatic int check_get_random_support(struct mox_rwtm *rwtm)\n{\n\tstruct armada_37xx_rwtm_tx_msg msg;\n\tint ret;\n\n\tmsg.command = MBOX_CMD_GET_RANDOM;\n\tmsg.args[0] = 1;\n\tmsg.args[1] = rwtm->buf_phys;\n\tmsg.args[2] = 4;\n\n\tret = mbox_send_message(rwtm->mbox, &msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wait_for_completion_timeout(&rwtm->cmd_done, HZ / 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn mox_get_status(MBOX_CMD_GET_RANDOM, rwtm->reply.retval);\n}\n\nstatic int mox_hwrng_read(struct hwrng *rng, void *data, size_t max, bool wait)\n{\n\tstruct mox_rwtm *rwtm = (struct mox_rwtm *) rng->priv;\n\tstruct armada_37xx_rwtm_tx_msg msg;\n\tint ret;\n\n\tif (max > 4096)\n\t\tmax = 4096;\n\n\tmsg.command = MBOX_CMD_GET_RANDOM;\n\tmsg.args[0] = 1;\n\tmsg.args[1] = rwtm->buf_phys;\n\tmsg.args[2] = (max + 3) & ~3;\n\n\tif (!wait) {\n\t\tif (!mutex_trylock(&rwtm->busy))\n\t\t\treturn -EBUSY;\n\t} else {\n\t\tmutex_lock(&rwtm->busy);\n\t}\n\n\tret = mbox_send_message(rwtm->mbox, &msg);\n\tif (ret < 0)\n\t\tgoto unlock_mutex;\n\n\tret = wait_for_completion_interruptible(&rwtm->cmd_done);\n\tif (ret < 0)\n\t\tgoto unlock_mutex;\n\n\tret = mox_get_status(MBOX_CMD_GET_RANDOM, rwtm->reply.retval);\n\tif (ret < 0)\n\t\tgoto unlock_mutex;\n\n\tmemcpy(data, rwtm->buf, max);\n\tret = max;\n\nunlock_mutex:\n\tmutex_unlock(&rwtm->busy);\n\treturn ret;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic int rwtm_debug_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = inode->i_private;\n\n\treturn nonseekable_open(inode, file);\n}\n\nstatic ssize_t do_sign_read(struct file *file, char __user *buf, size_t len,\n\t\t\t    loff_t *ppos)\n{\n\tstruct mox_rwtm *rwtm = file->private_data;\n\tssize_t ret;\n\n\t \n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tif (len < 136)\n\t\treturn -EINVAL;\n\n\tif (!rwtm->last_sig_done)\n\t\treturn -ENODATA;\n\n\t \n\tret = simple_read_from_buffer(buf, len, ppos, rwtm->last_sig, 136);\n\trwtm->last_sig_done = 0;\n\n\treturn ret;\n}\n\nstatic ssize_t do_sign_write(struct file *file, const char __user *buf,\n\t\t\t     size_t len, loff_t *ppos)\n{\n\tstruct mox_rwtm *rwtm = file->private_data;\n\tstruct armada_37xx_rwtm_rx_msg *reply = &rwtm->reply;\n\tstruct armada_37xx_rwtm_tx_msg msg;\n\tloff_t dummy = 0;\n\tssize_t ret;\n\n\t \n\tif (len != 64)\n\t\treturn -EINVAL;\n\n\t \n\tif (rwtm->last_sig_done)\n\t\treturn -EBUSY;\n\n\tif (!mutex_trylock(&rwtm->busy))\n\t\treturn -EBUSY;\n\n\t \n\tmemset(rwtm->buf, 0, 4);\n\tret = simple_write_to_buffer(rwtm->buf + 4, 64, &dummy, buf, len);\n\tif (ret < 0)\n\t\tgoto unlock_mutex;\n\tbe32_to_cpu_array(rwtm->buf, rwtm->buf, 17);\n\n\tmsg.command = MBOX_CMD_SIGN;\n\tmsg.args[0] = 1;\n\tmsg.args[1] = rwtm->buf_phys;\n\tmsg.args[2] = rwtm->buf_phys + 68;\n\tmsg.args[3] = rwtm->buf_phys + 2 * 68;\n\tret = mbox_send_message(rwtm->mbox, &msg);\n\tif (ret < 0)\n\t\tgoto unlock_mutex;\n\n\tret = wait_for_completion_interruptible(&rwtm->cmd_done);\n\tif (ret < 0)\n\t\tgoto unlock_mutex;\n\n\tret = MBOX_STS_VALUE(reply->retval);\n\tif (MBOX_STS_ERROR(reply->retval) != MBOX_STS_SUCCESS)\n\t\tgoto unlock_mutex;\n\n\t \n\tmemcpy(rwtm->last_sig, rwtm->buf + 68, 136);\n\tcpu_to_be32_array(rwtm->last_sig, rwtm->last_sig, 34);\n\trwtm->last_sig_done = 1;\n\n\tmutex_unlock(&rwtm->busy);\n\treturn len;\nunlock_mutex:\n\tmutex_unlock(&rwtm->busy);\n\treturn ret;\n}\n\nstatic const struct file_operations do_sign_fops = {\n\t.owner\t= THIS_MODULE,\n\t.open\t= rwtm_debug_open,\n\t.read\t= do_sign_read,\n\t.write\t= do_sign_write,\n\t.llseek\t= no_llseek,\n};\n\nstatic int rwtm_register_debugfs(struct mox_rwtm *rwtm)\n{\n\tstruct dentry *root, *entry;\n\n\troot = debugfs_create_dir(\"turris-mox-rwtm\", NULL);\n\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\tentry = debugfs_create_file_unsafe(\"do_sign\", 0600, root, rwtm,\n\t\t\t\t\t   &do_sign_fops);\n\tif (IS_ERR(entry))\n\t\tgoto err_remove;\n\n\trwtm->debugfs_root = root;\n\n\treturn 0;\nerr_remove:\n\tdebugfs_remove_recursive(root);\n\treturn PTR_ERR(entry);\n}\n\nstatic void rwtm_unregister_debugfs(struct mox_rwtm *rwtm)\n{\n\tdebugfs_remove_recursive(rwtm->debugfs_root);\n}\n#else\nstatic inline int rwtm_register_debugfs(struct mox_rwtm *rwtm)\n{\n\treturn 0;\n}\n\nstatic inline void rwtm_unregister_debugfs(struct mox_rwtm *rwtm)\n{\n}\n#endif\n\nstatic int turris_mox_rwtm_probe(struct platform_device *pdev)\n{\n\tstruct mox_rwtm *rwtm;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\trwtm = devm_kzalloc(dev, sizeof(*rwtm), GFP_KERNEL);\n\tif (!rwtm)\n\t\treturn -ENOMEM;\n\n\trwtm->dev = dev;\n\trwtm->buf = dmam_alloc_coherent(dev, PAGE_SIZE, &rwtm->buf_phys,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!rwtm->buf)\n\t\treturn -ENOMEM;\n\n\tret = mox_kobj_create(rwtm);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Cannot create turris-mox-rwtm kobject!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = sysfs_create_files(rwtm_to_kobj(rwtm), mox_rwtm_attrs);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Cannot create sysfs files!\\n\");\n\t\tgoto put_kobj;\n\t}\n\n\tplatform_set_drvdata(pdev, rwtm);\n\n\tmutex_init(&rwtm->busy);\n\n\trwtm->mbox_client.dev = dev;\n\trwtm->mbox_client.rx_callback = mox_rwtm_rx_callback;\n\n\trwtm->mbox = mbox_request_channel(&rwtm->mbox_client, 0);\n\tif (IS_ERR(rwtm->mbox)) {\n\t\tret = PTR_ERR(rwtm->mbox);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Cannot request mailbox channel: %i\\n\",\n\t\t\t\tret);\n\t\tgoto remove_files;\n\t}\n\n\tinit_completion(&rwtm->cmd_done);\n\n\tret = mox_get_board_info(rwtm);\n\tif (ret < 0)\n\t\tdev_warn(dev, \"Cannot read board information: %i\\n\", ret);\n\n\tret = check_get_random_support(rwtm);\n\tif (ret < 0) {\n\t\tdev_notice(dev,\n\t\t\t   \"Firmware does not support the GET_RANDOM command\\n\");\n\t\tgoto free_channel;\n\t}\n\n\trwtm->hwrng.name = DRIVER_NAME \"_hwrng\";\n\trwtm->hwrng.read = mox_hwrng_read;\n\trwtm->hwrng.priv = (unsigned long) rwtm;\n\n\tret = devm_hwrng_register(dev, &rwtm->hwrng);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Cannot register HWRNG: %i\\n\", ret);\n\t\tgoto free_channel;\n\t}\n\n\tret = rwtm_register_debugfs(rwtm);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed creating debugfs entries: %i\\n\", ret);\n\t\tgoto free_channel;\n\t}\n\n\tdev_info(dev, \"HWRNG successfully registered\\n\");\n\n\treturn 0;\n\nfree_channel:\n\tmbox_free_channel(rwtm->mbox);\nremove_files:\n\tsysfs_remove_files(rwtm_to_kobj(rwtm), mox_rwtm_attrs);\nput_kobj:\n\tkobject_put(rwtm_to_kobj(rwtm));\n\treturn ret;\n}\n\nstatic int turris_mox_rwtm_remove(struct platform_device *pdev)\n{\n\tstruct mox_rwtm *rwtm = platform_get_drvdata(pdev);\n\n\trwtm_unregister_debugfs(rwtm);\n\tsysfs_remove_files(rwtm_to_kobj(rwtm), mox_rwtm_attrs);\n\tkobject_put(rwtm_to_kobj(rwtm));\n\tmbox_free_channel(rwtm->mbox);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id turris_mox_rwtm_match[] = {\n\t{ .compatible = \"cznic,turris-mox-rwtm\", },\n\t{ .compatible = \"marvell,armada-3700-rwtm-firmware\", },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, turris_mox_rwtm_match);\n\nstatic struct platform_driver turris_mox_rwtm_driver = {\n\t.probe\t= turris_mox_rwtm_probe,\n\t.remove\t= turris_mox_rwtm_remove,\n\t.driver\t= {\n\t\t.name\t\t= DRIVER_NAME,\n\t\t.of_match_table\t= turris_mox_rwtm_match,\n\t},\n};\nmodule_platform_driver(turris_mox_rwtm_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Turris Mox rWTM firmware driver\");\nMODULE_AUTHOR(\"Marek Behun <kabel@kernel.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}