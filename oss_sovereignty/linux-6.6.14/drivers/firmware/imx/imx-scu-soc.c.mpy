{
  "module_name": "imx-scu-soc.c",
  "hash_id": "1b5300c0a701e8df27d52d2d66ec2f8fd633fffe72583597938d7bcf81e87499",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/imx/imx-scu-soc.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/firmware/imx/rsrc.h>\n#include <linux/firmware/imx/sci.h>\n#include <linux/slab.h>\n#include <linux/sys_soc.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n\nstatic struct imx_sc_ipc *imx_sc_soc_ipc_handle;\n\nstruct imx_sc_msg_misc_get_soc_id {\n\tstruct imx_sc_rpc_msg hdr;\n\tunion {\n\t\tstruct {\n\t\t\tu32 control;\n\t\t\tu16 resource;\n\t\t} __packed req;\n\t\tstruct {\n\t\t\tu32 id;\n\t\t} resp;\n\t} data;\n} __packed __aligned(4);\n\nstruct imx_sc_msg_misc_get_soc_uid {\n\tstruct imx_sc_rpc_msg hdr;\n\tu32 uid_low;\n\tu32 uid_high;\n} __packed;\n\nstatic int imx_scu_soc_uid(u64 *soc_uid)\n{\n\tstruct imx_sc_msg_misc_get_soc_uid msg;\n\tstruct imx_sc_rpc_msg *hdr = &msg.hdr;\n\tint ret;\n\n\thdr->ver = IMX_SC_RPC_VERSION;\n\thdr->svc = IMX_SC_RPC_SVC_MISC;\n\thdr->func = IMX_SC_MISC_FUNC_UNIQUE_ID;\n\thdr->size = 1;\n\n\tret = imx_scu_call_rpc(imx_sc_soc_ipc_handle, &msg, true);\n\tif (ret) {\n\t\tpr_err(\"%s: get soc uid failed, ret %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\t*soc_uid = msg.uid_high;\n\t*soc_uid <<= 32;\n\t*soc_uid |= msg.uid_low;\n\n\treturn 0;\n}\n\nstatic int imx_scu_soc_id(void)\n{\n\tstruct imx_sc_msg_misc_get_soc_id msg;\n\tstruct imx_sc_rpc_msg *hdr = &msg.hdr;\n\tint ret;\n\n\thdr->ver = IMX_SC_RPC_VERSION;\n\thdr->svc = IMX_SC_RPC_SVC_MISC;\n\thdr->func = IMX_SC_MISC_FUNC_GET_CONTROL;\n\thdr->size = 3;\n\n\tmsg.data.req.control = IMX_SC_C_ID;\n\tmsg.data.req.resource = IMX_SC_R_SYSTEM;\n\n\tret = imx_scu_call_rpc(imx_sc_soc_ipc_handle, &msg, true);\n\tif (ret) {\n\t\tpr_err(\"%s: get soc info failed, ret %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn msg.data.resp.id;\n}\n\nstatic const char *imx_scu_soc_name(u32 id)\n{\n\tswitch (id) {\n\tcase 0x1:\n\t\treturn \"i.MX8QM\";\n\tcase 0x2:\n\t\treturn \"i.MX8QXP\";\n\tcase 0xe:\n\t\treturn \"i.MX8DXL\";\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn \"NULL\";\n}\n\nint imx_scu_soc_init(struct device *dev)\n{\n\tstruct soc_device_attribute *soc_dev_attr;\n\tstruct soc_device *soc_dev;\n\tint id, ret;\n\tu64 uid = 0;\n\tu32 val;\n\n\tret = imx_scu_get_handle(&imx_sc_soc_ipc_handle);\n\tif (ret)\n\t\treturn ret;\n\n\tsoc_dev_attr = devm_kzalloc(dev, sizeof(*soc_dev_attr),\n\t\t\t\t    GFP_KERNEL);\n\tif (!soc_dev_attr)\n\t\treturn -ENOMEM;\n\n\tsoc_dev_attr->family = \"Freescale i.MX\";\n\n\tret = of_property_read_string(of_root,\n\t\t\t\t      \"model\",\n\t\t\t\t      &soc_dev_attr->machine);\n\tif (ret)\n\t\treturn ret;\n\n\tid = imx_scu_soc_id();\n\tif (id < 0)\n\t\treturn -EINVAL;\n\n\tret = imx_scu_soc_uid(&uid);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\t \n\tval = id & 0x1f;\n\tsoc_dev_attr->soc_id = imx_scu_soc_name(val);\n\n\t \n\tval = (id >> 5) & 0xf;\n\tval = (((val >> 2) + 1) << 4) | (val & 0x3);\n\tsoc_dev_attr->revision = devm_kasprintf(dev, GFP_KERNEL, \"%d.%d\",\n\t\t\t\t\t\t(val >> 4) & 0xf, val & 0xf);\n\tif (!soc_dev_attr->revision)\n\t\treturn -ENOMEM;\n\n\tsoc_dev_attr->serial_number = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t     \"%016llX\", uid);\n\tif (!soc_dev_attr->serial_number)\n\t\treturn -ENOMEM;\n\n\tsoc_dev = soc_device_register(soc_dev_attr);\n\tif (IS_ERR(soc_dev))\n\t\treturn PTR_ERR(soc_dev);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}