{
  "module_name": "imx-scu-irq.c",
  "hash_id": "4288930ba65e6edfbb97f955b78795ad2edf155469cec0adb9ed376f81abaae6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/imx/imx-scu-irq.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/firmware/imx/rsrc.h>\n#include <linux/firmware/imx/ipc.h>\n#include <linux/firmware/imx/sci.h>\n#include <linux/kobject.h>\n#include <linux/mailbox_client.h>\n#include <linux/of.h>\n#include <linux/suspend.h>\n#include <linux/sysfs.h>\n\n#define IMX_SC_IRQ_FUNC_ENABLE\t1\n#define IMX_SC_IRQ_FUNC_STATUS\t2\n#define IMX_SC_IRQ_NUM_GROUP\t9\n\nstatic u32 mu_resource_id;\n\nstruct imx_sc_msg_irq_get_status {\n\tstruct imx_sc_rpc_msg hdr;\n\tunion {\n\t\tstruct {\n\t\t\tu16 resource;\n\t\t\tu8 group;\n\t\t\tu8 reserved;\n\t\t} __packed req;\n\t\tstruct {\n\t\t\tu32 status;\n\t\t} resp;\n\t} data;\n};\n\nstruct imx_sc_msg_irq_enable {\n\tstruct imx_sc_rpc_msg hdr;\n\tu32 mask;\n\tu16 resource;\n\tu8 group;\n\tu8 enable;\n} __packed;\n\nstruct scu_wakeup {\n\tu32 mask;\n\tu32 wakeup_src;\n\tbool valid;\n};\n\n \nstatic struct kobject *wakeup_obj;\nstatic ssize_t wakeup_source_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf);\nstatic struct kobj_attribute wakeup_source_attr =\n\t\t__ATTR(wakeup_src, 0660, wakeup_source_show, NULL);\n\nstatic struct scu_wakeup scu_irq_wakeup[IMX_SC_IRQ_NUM_GROUP];\n\nstatic struct imx_sc_ipc *imx_sc_irq_ipc_handle;\nstatic struct work_struct imx_sc_irq_work;\nstatic BLOCKING_NOTIFIER_HEAD(imx_scu_irq_notifier_chain);\n\nint imx_scu_irq_register_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(\n\t\t&imx_scu_irq_notifier_chain, nb);\n}\nEXPORT_SYMBOL(imx_scu_irq_register_notifier);\n\nint imx_scu_irq_unregister_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(\n\t\t&imx_scu_irq_notifier_chain, nb);\n}\nEXPORT_SYMBOL(imx_scu_irq_unregister_notifier);\n\nstatic int imx_scu_irq_notifier_call_chain(unsigned long status, u8 *group)\n{\n\treturn blocking_notifier_call_chain(&imx_scu_irq_notifier_chain,\n\t\tstatus, (void *)group);\n}\n\nstatic void imx_scu_irq_work_handler(struct work_struct *work)\n{\n\tu32 irq_status;\n\tint ret;\n\tu8 i;\n\n\tfor (i = 0; i < IMX_SC_IRQ_NUM_GROUP; i++) {\n\t\tif (scu_irq_wakeup[i].mask) {\n\t\t\tscu_irq_wakeup[i].valid = false;\n\t\t\tscu_irq_wakeup[i].wakeup_src = 0;\n\t\t}\n\n\t\tret = imx_scu_irq_get_status(i, &irq_status);\n\t\tif (ret) {\n\t\t\tpr_err(\"get irq group %d status failed, ret %d\\n\",\n\t\t\t       i, ret);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!irq_status)\n\t\t\tcontinue;\n\t\tif (scu_irq_wakeup[i].mask & irq_status) {\n\t\t\tscu_irq_wakeup[i].valid = true;\n\t\t\tscu_irq_wakeup[i].wakeup_src = irq_status & scu_irq_wakeup[i].mask;\n\t\t} else {\n\t\t\tscu_irq_wakeup[i].wakeup_src = irq_status;\n\t\t}\n\n\t\tpm_system_wakeup();\n\t\timx_scu_irq_notifier_call_chain(irq_status, &i);\n\t}\n}\n\nint imx_scu_irq_get_status(u8 group, u32 *irq_status)\n{\n\tstruct imx_sc_msg_irq_get_status msg;\n\tstruct imx_sc_rpc_msg *hdr = &msg.hdr;\n\tint ret;\n\n\thdr->ver = IMX_SC_RPC_VERSION;\n\thdr->svc = IMX_SC_RPC_SVC_IRQ;\n\thdr->func = IMX_SC_IRQ_FUNC_STATUS;\n\thdr->size = 2;\n\n\tmsg.data.req.resource = mu_resource_id;\n\tmsg.data.req.group = group;\n\n\tret = imx_scu_call_rpc(imx_sc_irq_ipc_handle, &msg, true);\n\tif (ret)\n\t\treturn ret;\n\n\tif (irq_status)\n\t\t*irq_status = msg.data.resp.status;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(imx_scu_irq_get_status);\n\nint imx_scu_irq_group_enable(u8 group, u32 mask, u8 enable)\n{\n\tstruct imx_sc_msg_irq_enable msg;\n\tstruct imx_sc_rpc_msg *hdr = &msg.hdr;\n\tint ret;\n\n\tif (!imx_sc_irq_ipc_handle)\n\t\treturn -EPROBE_DEFER;\n\n\thdr->ver = IMX_SC_RPC_VERSION;\n\thdr->svc = IMX_SC_RPC_SVC_IRQ;\n\thdr->func = IMX_SC_IRQ_FUNC_ENABLE;\n\thdr->size = 3;\n\n\tmsg.resource = mu_resource_id;\n\tmsg.group = group;\n\tmsg.mask = mask;\n\tmsg.enable = enable;\n\n\tret = imx_scu_call_rpc(imx_sc_irq_ipc_handle, &msg, true);\n\tif (ret)\n\t\tpr_err(\"enable irq failed, group %d, mask %d, ret %d\\n\",\n\t\t\tgroup, mask, ret);\n\n\tif (enable)\n\t\tscu_irq_wakeup[group].mask |= mask;\n\telse\n\t\tscu_irq_wakeup[group].mask &= ~mask;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(imx_scu_irq_group_enable);\n\nstatic void imx_scu_irq_callback(struct mbox_client *c, void *msg)\n{\n\tschedule_work(&imx_sc_irq_work);\n}\n\nstatic ssize_t wakeup_source_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tint i;\n\n\tfor (i = 0; i < IMX_SC_IRQ_NUM_GROUP; i++) {\n\t\tif (!scu_irq_wakeup[i].wakeup_src)\n\t\t\tcontinue;\n\n\t\tif (scu_irq_wakeup[i].valid)\n\t\t\tsprintf(buf, \"Wakeup source group = %d, irq = 0x%x\\n\",\n\t\t\t\ti, scu_irq_wakeup[i].wakeup_src);\n\t\telse\n\t\t\tsprintf(buf, \"Spurious SCU wakeup, group = %d, irq = 0x%x\\n\",\n\t\t\t\ti, scu_irq_wakeup[i].wakeup_src);\n\t}\n\n\treturn strlen(buf);\n}\n\nint imx_scu_enable_general_irq_channel(struct device *dev)\n{\n\tstruct of_phandle_args spec;\n\tstruct mbox_client *cl;\n\tstruct mbox_chan *ch;\n\tint ret = 0, i = 0;\n\n\tret = imx_scu_get_handle(&imx_sc_irq_ipc_handle);\n\tif (ret)\n\t\treturn ret;\n\n\tcl = devm_kzalloc(dev, sizeof(*cl), GFP_KERNEL);\n\tif (!cl)\n\t\treturn -ENOMEM;\n\n\tcl->dev = dev;\n\tcl->rx_callback = imx_scu_irq_callback;\n\n\t \n\tch = mbox_request_channel_byname(cl, \"gip3\");\n\tif (IS_ERR(ch)) {\n\t\tret = PTR_ERR(ch);\n\t\tdev_err(dev, \"failed to request mbox chan gip3, ret %d\\n\", ret);\n\t\tdevm_kfree(dev, cl);\n\t\treturn ret;\n\t}\n\n\tINIT_WORK(&imx_sc_irq_work, imx_scu_irq_work_handler);\n\n\tif (!of_parse_phandle_with_args(dev->of_node, \"mboxes\",\n\t\t\t\t       \"#mbox-cells\", 0, &spec))\n\t\ti = of_alias_get_id(spec.np, \"mu\");\n\n\t \n\tif (i < 0)\n\t\ti = 1;\n\n\tmu_resource_id = IMX_SC_R_MU_0A + i;\n\n\t \n\twakeup_obj = kobject_create_and_add(\"scu_wakeup_source\", firmware_kobj);\n\tif (!wakeup_obj) {\n\t\tret = -ENOMEM;\n\t\tgoto free_ch;\n\t}\n\n\tret = sysfs_create_file(wakeup_obj, &wakeup_source_attr.attr);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot create wakeup source src file......\\n\");\n\t\tkobject_put(wakeup_obj);\n\t\tgoto free_ch;\n\t}\n\n\treturn 0;\n\nfree_ch:\n\tmbox_free_channel(ch);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(imx_scu_enable_general_irq_channel);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}