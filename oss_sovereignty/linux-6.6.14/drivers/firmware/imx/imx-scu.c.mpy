{
  "module_name": "imx-scu.c",
  "hash_id": "b8a0a52f3f1e275e400edeb16d74d7a84be13e209ae54601f1534594fe8ec616",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/imx/imx-scu.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/firmware/imx/ipc.h>\n#include <linux/firmware/imx/sci.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n#define SCU_MU_CHAN_NUM\t\t8\n#define MAX_RX_TIMEOUT\t\t(msecs_to_jiffies(3000))\n\nstruct imx_sc_chan {\n\tstruct imx_sc_ipc *sc_ipc;\n\n\tstruct mbox_client cl;\n\tstruct mbox_chan *ch;\n\tint idx;\n\tstruct completion tx_done;\n};\n\nstruct imx_sc_ipc {\n\t \n\tstruct imx_sc_chan chans[SCU_MU_CHAN_NUM];\n\tstruct device *dev;\n\tstruct mutex lock;\n\tstruct completion done;\n\tbool fast_ipc;\n\n\t \n\tu32 *msg;\n\tu8 rx_size;\n\tu8 count;\n};\n\n \nenum imx_sc_error_codes {\n\tIMX_SC_ERR_NONE = 0,\t \n\tIMX_SC_ERR_VERSION = 1,\t \n\tIMX_SC_ERR_CONFIG = 2,\t \n\tIMX_SC_ERR_PARM = 3,\t \n\tIMX_SC_ERR_NOACCESS = 4,\t \n\tIMX_SC_ERR_LOCKED = 5,\t \n\tIMX_SC_ERR_UNAVAILABLE = 6,\t \n\tIMX_SC_ERR_NOTFOUND = 7,\t \n\tIMX_SC_ERR_NOPOWER = 8,\t \n\tIMX_SC_ERR_IPC = 9,\t\t \n\tIMX_SC_ERR_BUSY = 10,\t \n\tIMX_SC_ERR_FAIL = 11,\t \n\tIMX_SC_ERR_LAST\n};\n\nstatic int imx_sc_linux_errmap[IMX_SC_ERR_LAST] = {\n\t0,\t  \n\t-EINVAL,  \n\t-EINVAL,  \n\t-EINVAL,  \n\t-EACCES,  \n\t-EACCES,  \n\t-ERANGE,  \n\t-EEXIST,  \n\t-EPERM,\t  \n\t-EPIPE,\t  \n\t-EBUSY,\t  \n\t-EIO,\t  \n};\n\nstatic struct imx_sc_ipc *imx_sc_ipc_handle;\n\nstatic inline int imx_sc_to_linux_errno(int errno)\n{\n\tif (errno >= IMX_SC_ERR_NONE && errno < IMX_SC_ERR_LAST)\n\t\treturn imx_sc_linux_errmap[errno];\n\treturn -EIO;\n}\n\n \nint imx_scu_get_handle(struct imx_sc_ipc **ipc)\n{\n\tif (!imx_sc_ipc_handle)\n\t\treturn -EPROBE_DEFER;\n\n\t*ipc = imx_sc_ipc_handle;\n\treturn 0;\n}\nEXPORT_SYMBOL(imx_scu_get_handle);\n\n \nstatic void imx_scu_tx_done(struct mbox_client *cl, void *mssg, int r)\n{\n\tstruct imx_sc_chan *sc_chan = container_of(cl, struct imx_sc_chan, cl);\n\n\tcomplete(&sc_chan->tx_done);\n}\n\nstatic void imx_scu_rx_callback(struct mbox_client *c, void *msg)\n{\n\tstruct imx_sc_chan *sc_chan = container_of(c, struct imx_sc_chan, cl);\n\tstruct imx_sc_ipc *sc_ipc = sc_chan->sc_ipc;\n\tstruct imx_sc_rpc_msg *hdr;\n\tu32 *data = msg;\n\tint i;\n\n\tif (!sc_ipc->msg) {\n\t\tdev_warn(sc_ipc->dev, \"unexpected rx idx %d 0x%08x, ignore!\\n\",\n\t\t\t\tsc_chan->idx, *data);\n\t\treturn;\n\t}\n\n\tif (sc_ipc->fast_ipc) {\n\t\thdr = msg;\n\t\tsc_ipc->rx_size = hdr->size;\n\t\tsc_ipc->msg[0] = *data++;\n\n\t\tfor (i = 1; i < sc_ipc->rx_size; i++)\n\t\t\tsc_ipc->msg[i] = *data++;\n\n\t\tcomplete(&sc_ipc->done);\n\n\t\treturn;\n\t}\n\n\tif (sc_chan->idx == 0) {\n\t\thdr = msg;\n\t\tsc_ipc->rx_size = hdr->size;\n\t\tdev_dbg(sc_ipc->dev, \"msg rx size %u\\n\", sc_ipc->rx_size);\n\t\tif (sc_ipc->rx_size > 4)\n\t\t\tdev_warn(sc_ipc->dev, \"RPC does not support receiving over 4 words: %u\\n\",\n\t\t\t\t sc_ipc->rx_size);\n\t}\n\n\tsc_ipc->msg[sc_chan->idx] = *data;\n\tsc_ipc->count++;\n\n\tdev_dbg(sc_ipc->dev, \"mu %u msg %u 0x%x\\n\", sc_chan->idx,\n\t\tsc_ipc->count, *data);\n\n\tif ((sc_ipc->rx_size != 0) && (sc_ipc->count == sc_ipc->rx_size))\n\t\tcomplete(&sc_ipc->done);\n}\n\nstatic int imx_scu_ipc_write(struct imx_sc_ipc *sc_ipc, void *msg)\n{\n\tstruct imx_sc_rpc_msg hdr = *(struct imx_sc_rpc_msg *)msg;\n\tstruct imx_sc_chan *sc_chan;\n\tu32 *data = msg;\n\tint ret;\n\tint size;\n\tint i;\n\n\t \n\tif (hdr.size > IMX_SC_RPC_MAX_MSG)\n\t\treturn -EINVAL;\n\n\tdev_dbg(sc_ipc->dev, \"RPC SVC %u FUNC %u SIZE %u\\n\", hdr.svc,\n\t\thdr.func, hdr.size);\n\n\tsize = sc_ipc->fast_ipc ? 1 : hdr.size;\n\tfor (i = 0; i < size; i++) {\n\t\tsc_chan = &sc_ipc->chans[i % 4];\n\n\t\t \n\t\tif (!sc_ipc->fast_ipc) {\n\t\t\twait_for_completion(&sc_chan->tx_done);\n\t\t\treinit_completion(&sc_chan->tx_done);\n\t\t}\n\n\t\tret = mbox_send_message(sc_chan->ch, &data[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nint imx_scu_call_rpc(struct imx_sc_ipc *sc_ipc, void *msg, bool have_resp)\n{\n\tuint8_t saved_svc, saved_func;\n\tstruct imx_sc_rpc_msg *hdr;\n\tint ret;\n\n\tif (WARN_ON(!sc_ipc || !msg))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sc_ipc->lock);\n\treinit_completion(&sc_ipc->done);\n\n\tif (have_resp) {\n\t\tsc_ipc->msg = msg;\n\t\tsaved_svc = ((struct imx_sc_rpc_msg *)msg)->svc;\n\t\tsaved_func = ((struct imx_sc_rpc_msg *)msg)->func;\n\t}\n\tsc_ipc->count = 0;\n\tret = imx_scu_ipc_write(sc_ipc, msg);\n\tif (ret < 0) {\n\t\tdev_err(sc_ipc->dev, \"RPC send msg failed: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tif (have_resp) {\n\t\tif (!wait_for_completion_timeout(&sc_ipc->done,\n\t\t\t\t\t\t MAX_RX_TIMEOUT)) {\n\t\t\tdev_err(sc_ipc->dev, \"RPC send msg timeout\\n\");\n\t\t\tmutex_unlock(&sc_ipc->lock);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\t \n\t\thdr = msg;\n\t\tret = hdr->func;\n\t\t \n\t\tif ((saved_svc == IMX_SC_RPC_SVC_MISC) &&\n\t\t\t(saved_func == IMX_SC_MISC_FUNC_UNIQUE_ID ||\n\t\t\t saved_func == IMX_SC_MISC_FUNC_GET_BUTTON_STATUS))\n\t\t\tret = 0;\n\t}\n\nout:\n\tsc_ipc->msg = NULL;\n\tmutex_unlock(&sc_ipc->lock);\n\n\tdev_dbg(sc_ipc->dev, \"RPC SVC done\\n\");\n\n\treturn imx_sc_to_linux_errno(ret);\n}\nEXPORT_SYMBOL(imx_scu_call_rpc);\n\nstatic int imx_scu_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct imx_sc_ipc *sc_ipc;\n\tstruct imx_sc_chan *sc_chan;\n\tstruct mbox_client *cl;\n\tchar *chan_name;\n\tstruct of_phandle_args args;\n\tint num_channel;\n\tint ret;\n\tint i;\n\n\tsc_ipc = devm_kzalloc(dev, sizeof(*sc_ipc), GFP_KERNEL);\n\tif (!sc_ipc)\n\t\treturn -ENOMEM;\n\n\tret = of_parse_phandle_with_args(pdev->dev.of_node, \"mboxes\",\n\t\t\t\t\t \"#mbox-cells\", 0, &args);\n\tif (ret)\n\t\treturn ret;\n\n\tsc_ipc->fast_ipc = of_device_is_compatible(args.np, \"fsl,imx8-mu-scu\");\n\n\tnum_channel = sc_ipc->fast_ipc ? 2 : SCU_MU_CHAN_NUM;\n\tfor (i = 0; i < num_channel; i++) {\n\t\tif (i < num_channel / 2)\n\t\t\tchan_name = kasprintf(GFP_KERNEL, \"tx%d\", i);\n\t\telse\n\t\t\tchan_name = kasprintf(GFP_KERNEL, \"rx%d\",\n\t\t\t\t\t      i - num_channel / 2);\n\n\t\tif (!chan_name)\n\t\t\treturn -ENOMEM;\n\n\t\tsc_chan = &sc_ipc->chans[i];\n\t\tcl = &sc_chan->cl;\n\t\tcl->dev = dev;\n\t\tcl->tx_block = false;\n\t\tcl->knows_txdone = true;\n\t\tcl->rx_callback = imx_scu_rx_callback;\n\n\t\tif (!sc_ipc->fast_ipc) {\n\t\t\t \n\t\t\tcl->tx_done = imx_scu_tx_done;\n\t\t\tinit_completion(&sc_chan->tx_done);\n\t\t\tcomplete(&sc_chan->tx_done);\n\t\t}\n\n\t\tsc_chan->sc_ipc = sc_ipc;\n\t\tsc_chan->idx = i % (num_channel / 2);\n\t\tsc_chan->ch = mbox_request_channel_byname(cl, chan_name);\n\t\tif (IS_ERR(sc_chan->ch)) {\n\t\t\tret = PTR_ERR(sc_chan->ch);\n\t\t\tdev_err_probe(dev, ret, \"Failed to request mbox chan %s\\n\",\n\t\t\t\t      chan_name);\n\t\t\tkfree(chan_name);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdev_dbg(dev, \"request mbox chan %s\\n\", chan_name);\n\t\t \n\t\tkfree(chan_name);\n\t}\n\n\tsc_ipc->dev = dev;\n\tmutex_init(&sc_ipc->lock);\n\tinit_completion(&sc_ipc->done);\n\n\timx_sc_ipc_handle = sc_ipc;\n\n\tret = imx_scu_soc_init(dev);\n\tif (ret)\n\t\tdev_warn(dev, \"failed to initialize SoC info: %d\\n\", ret);\n\n\tret = imx_scu_enable_general_irq_channel(dev);\n\tif (ret)\n\t\tdev_warn(dev,\n\t\t\t\"failed to enable general irq channel: %d\\n\", ret);\n\n\tdev_info(dev, \"NXP i.MX SCU Initialized\\n\");\n\n\treturn devm_of_platform_populate(dev);\n}\n\nstatic const struct of_device_id imx_scu_match[] = {\n\t{ .compatible = \"fsl,imx-scu\", },\n\t{   }\n};\n\nstatic struct platform_driver imx_scu_driver = {\n\t.driver = {\n\t\t.name = \"imx-scu\",\n\t\t.of_match_table = imx_scu_match,\n\t},\n\t.probe = imx_scu_probe,\n};\n\nstatic int __init imx_scu_driver_init(void)\n{\n\treturn platform_driver_register(&imx_scu_driver);\n}\nsubsys_initcall_sync(imx_scu_driver_init);\n\nMODULE_AUTHOR(\"Dong Aisheng <aisheng.dong@nxp.com>\");\nMODULE_DESCRIPTION(\"IMX SCU firmware protocol driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}