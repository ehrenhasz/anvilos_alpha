{
  "module_name": "Kconfig",
  "hash_id": "e6e9a96ad02d0668b57c772a6a318a5888eeb8c3837d847ee63cf844b0c0a2b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# For a description of the syntax of this configuration file,\n# see Documentation/kbuild/kconfig-language.rst.\n#\n\nmenu \"Firmware Drivers\"\n\nsource \"drivers/firmware/arm_scmi/Kconfig\"\n\nconfig ARM_SCPI_PROTOCOL\n\ttristate \"ARM System Control and Power Interface (SCPI) Message Protocol\"\n\tdepends on ARM || ARM64 || COMPILE_TEST\n\tdepends on MAILBOX\n\thelp\n\t  System Control and Power Interface (SCPI) Message Protocol is\n\t  defined for the purpose of communication between the Application\n\t  Cores(AP) and the System Control Processor(SCP). The MHU peripheral\n\t  provides a mechanism for inter-processor communication between SCP\n\t  and AP.\n\n\t  SCP controls most of the power management on the Application\n\t  Processors. It offers control and management of: the core/cluster\n\t  power states, various power domain DVFS including the core/cluster,\n\t  certain system clocks configuration, thermal sensors and many\n\t  others.\n\n\t  This protocol library provides interface for all the client drivers\n\t  making use of the features offered by the SCP.\n\nconfig ARM_SCPI_POWER_DOMAIN\n\ttristate \"SCPI power domain driver\"\n\tdepends on ARM_SCPI_PROTOCOL || (COMPILE_TEST && OF)\n\tdefault y\n\tselect PM_GENERIC_DOMAINS if PM\n\thelp\n\t  This enables support for the SCPI power domains which can be\n\t  enabled or disabled via the SCP firmware\n\nconfig ARM_SDE_INTERFACE\n\tbool \"ARM Software Delegated Exception Interface (SDEI)\"\n\tdepends on ARM64\n\tdepends on ACPI_APEI_GHES\n\thelp\n\t  The Software Delegated Exception Interface (SDEI) is an ARM\n\t  standard for registering callbacks from the platform firmware\n\t  into the OS. This is typically used to implement RAS notifications.\n\nconfig EDD\n\ttristate \"BIOS Enhanced Disk Drive calls determine boot disk\"\n\tdepends on X86\n\thelp\n\t  Say Y or M here if you want to enable BIOS Enhanced Disk Drive\n\t  Services real mode BIOS calls to determine which disk\n\t  BIOS tries boot from.  This information is then exported via sysfs.\n\n\t  This option is experimental and is known to fail to boot on some\n          obscure configurations. Most disk controller BIOS vendors do\n          not yet implement this feature.\n\nconfig EDD_OFF\n\tbool \"Sets default behavior for EDD detection to off\"\n\tdepends on EDD\n\tdefault n\n\thelp\n\t  Say Y if you want EDD disabled by default, even though it is compiled into the\n\t  kernel. Say N if you want EDD enabled by default. EDD can be dynamically set\n\t  using the kernel parameter 'edd={on|skipmbr|off}'.\n\nconfig FIRMWARE_MEMMAP\n    bool \"Add firmware-provided memory map to sysfs\" if EXPERT\n    default X86\n    help\n      Add the firmware-provided (unmodified) memory map to /sys/firmware/memmap.\n      That memory map is used for example by kexec to set up parameter area\n      for the next kernel, but can also be used for debugging purposes.\n\n      See also Documentation/ABI/testing/sysfs-firmware-memmap.\n\nconfig EFI_PCDP\n\tbool \"Console device selection via EFI PCDP or HCDP table\"\n\tdepends on ACPI && EFI && IA64\n\tdefault y if IA64\n\thelp\n\t  If your firmware supplies the PCDP table, and you want to\n\t  automatically use the primary console device it describes\n\t  as the Linux console, say Y here.\n\n\t  If your firmware supplies the HCDP table, and you want to\n\t  use the first serial port it describes as the Linux console,\n\t  say Y here.  If your EFI ConOut path contains only a UART\n\t  device, it will become the console automatically.  Otherwise,\n\t  you must specify the \"console=hcdp\" kernel boot argument.\n\n\t  Neither the PCDP nor the HCDP affects naming of serial devices,\n\t  so a serial console may be /dev/ttyS0, /dev/ttyS1, etc, depending\n\t  on how the driver discovers devices.\n\n\t  You must also enable the appropriate drivers (serial, VGA, etc.)\n\n\t  See DIG64_HCDPv20_042804.pdf available from\n\t  <http://www.dig64.org/specifications/> \n\nconfig DMIID\n    bool \"Export DMI identification via sysfs to userspace\"\n    depends on DMI\n    default y\n\thelp\n\t  Say Y here if you want to query SMBIOS/DMI system identification\n\t  information from userspace through /sys/class/dmi/id/ or if you want\n\t  DMI-based module auto-loading.\n\nconfig DMI_SYSFS\n\ttristate \"DMI table support in sysfs\"\n\tdepends on SYSFS && DMI\n\tdefault n\n\thelp\n\t  Say Y or M here to enable the exporting of the raw DMI table\n\t  data via sysfs.  This is useful for consuming the data without\n\t  requiring any access to /dev/mem at all.  Tables are found\n\t  under /sys/firmware/dmi when this option is enabled and\n\t  loaded.\n\nconfig DMI_SCAN_MACHINE_NON_EFI_FALLBACK\n\tbool\n\nconfig ISCSI_IBFT_FIND\n\tbool \"iSCSI Boot Firmware Table Attributes\"\n\tdepends on X86 && ISCSI_IBFT\n\tdefault n\n\thelp\n\t  This option enables the kernel to find the region of memory\n\t  in which the ISCSI Boot Firmware Table (iBFT) resides. This\n\t  is necessary for iSCSI Boot Firmware Table Attributes module to work\n\t  properly.\n\nconfig ISCSI_IBFT\n\ttristate \"iSCSI Boot Firmware Table Attributes module\"\n\tselect ISCSI_BOOT_SYSFS\n\tselect ISCSI_IBFT_FIND if X86\n\tdepends on ACPI && SCSI && SCSI_LOWLEVEL\n\tdefault\tn\n\thelp\n\t  This option enables support for detection and exposing of iSCSI\n\t  Boot Firmware Table (iBFT) via sysfs to userspace. If you wish to\n\t  detect iSCSI boot parameters dynamically during system boot, say Y.\n\t  Otherwise, say N.\n\nconfig RASPBERRYPI_FIRMWARE\n\ttristate \"Raspberry Pi Firmware Driver\"\n\tdepends on BCM2835_MBOX\n\thelp\n\t  This option enables support for communicating with the firmware on the\n\t  Raspberry Pi.\n\nconfig FW_CFG_SYSFS\n\ttristate \"QEMU fw_cfg device support in sysfs\"\n\tdepends on SYSFS && (ARM || ARM64 || PARISC || PPC_PMAC || SPARC || X86)\n\tdepends on HAS_IOPORT_MAP\n\tdefault n\n\thelp\n\t  Say Y or M here to enable the exporting of the QEMU firmware\n\t  configuration (fw_cfg) file entries via sysfs. Entries are\n\t  found under /sys/firmware/fw_cfg when this option is enabled\n\t  and loaded.\n\nconfig FW_CFG_SYSFS_CMDLINE\n\tbool \"QEMU fw_cfg device parameter parsing\"\n\tdepends on FW_CFG_SYSFS\n\thelp\n\t  Allow the qemu_fw_cfg device to be initialized via the kernel\n\t  command line or using a module parameter.\n\t  WARNING: Using incorrect parameters (base address in particular)\n\t  may crash your system.\n\nconfig INTEL_STRATIX10_SERVICE\n\ttristate \"Intel Stratix10 Service Layer\"\n\tdepends on ARCH_INTEL_SOCFPGA && ARM64 && HAVE_ARM_SMCCC\n\tdefault n\n\thelp\n\t  Intel Stratix10 service layer runs at privileged exception level,\n\t  interfaces with the service providers (FPGA manager is one of them)\n\t  and manages secure monitor call to communicate with secure monitor\n\t  software at secure monitor exception level.\n\n\t  Say Y here if you want Stratix10 service layer support.\n\nconfig INTEL_STRATIX10_RSU\n\ttristate \"Intel Stratix10 Remote System Update\"\n\tdepends on INTEL_STRATIX10_SERVICE\n\thelp\n\t  The Intel Remote System Update (RSU) driver exposes interfaces\n\t  access through the Intel Service Layer to user space via sysfs\n\t  device attribute nodes. The RSU interfaces report/control some of\n\t  the optional RSU features of the Stratix 10 SoC FPGA.\n\n\t  The RSU provides a way for customers to update the boot\n\t  configuration of a Stratix 10 SoC device with significantly reduced\n\t  risk of corrupting the bitstream storage and bricking the system.\n\n\t  Enable RSU support if you are using an Intel SoC FPGA with the RSU\n\t  feature enabled and you want Linux user space control.\n\n\t  Say Y here if you want Intel RSU support.\n\nconfig MTK_ADSP_IPC\n\ttristate \"MTK ADSP IPC Protocol driver\"\n\tdepends on MTK_ADSP_MBOX\n\thelp\n\t  Say yes here to add support for the MediaTek ADSP IPC\n\t  between host AP (Linux) and the firmware running on ADSP.\n\t  ADSP exists on some mtk processors.\n\t  Client might use shared memory to exchange information with ADSP.\n\nconfig QCOM_SCM\n\ttristate\n\nconfig QCOM_SCM_DOWNLOAD_MODE_DEFAULT\n\tbool \"Qualcomm download mode enabled by default\"\n\tdepends on QCOM_SCM\n\thelp\n\t  A device with \"download mode\" enabled will upon an unexpected\n\t  warm-restart enter a special debug mode that allows the user to\n\t  \"download\" memory content over USB for offline postmortem analysis.\n\t  The feature can be enabled/disabled on the kernel command line.\n\n\t  Say Y here to enable \"download mode\" by default.\n\nconfig SYSFB\n\tbool\n\tselect BOOT_VESA_SUPPORT\n\nconfig SYSFB_SIMPLEFB\n\tbool \"Mark VGA/VBE/EFI FB as generic system framebuffer\"\n\tdepends on X86 || EFI\n\tselect SYSFB\n\thelp\n\t  Firmwares often provide initial graphics framebuffers so the BIOS,\n\t  bootloader or kernel can show basic video-output during boot for\n\t  user-guidance and debugging. Historically, x86 used the VESA BIOS\n\t  Extensions and EFI-framebuffers for this, which are mostly limited\n\t  to x86 BIOS or EFI systems.\n\t  This option, if enabled, marks VGA/VBE/EFI framebuffers as generic\n\t  framebuffers so the new generic system-framebuffer drivers can be\n\t  used instead. If the framebuffer is not compatible with the generic\n\t  modes, it is advertised as fallback platform framebuffer so legacy\n\t  drivers like efifb, vesafb and uvesafb can pick it up.\n\t  If this option is not selected, all system framebuffers are always\n\t  marked as fallback platform framebuffers as usual.\n\n\t  Note: Legacy fbdev drivers, including vesafb, efifb, uvesafb, will\n\t  not be able to pick up generic system framebuffers if this option\n\t  is selected. You are highly encouraged to enable simplefb as\n\t  replacement if you select this option. simplefb can correctly deal\n\t  with generic system framebuffers. But you should still keep vesafb\n\t  and others enabled as fallback if a system framebuffer is\n\t  incompatible with simplefb.\n\n\t  If unsure, say Y.\n\nconfig TI_SCI_PROTOCOL\n\ttristate \"TI System Control Interface (TISCI) Message Protocol\"\n\tdepends on TI_MESSAGE_MANAGER\n\thelp\n\t  TI System Control Interface (TISCI) Message Protocol is used to manage\n\t  compute systems such as ARM, DSP etc with the system controller in\n\t  complex System on Chip(SoC) such as those found on certain keystone\n\t  generation SoC from TI.\n\n\t  System controller provides various facilities including power\n\t  management function support.\n\n\t  This protocol library is used by client drivers to use the features\n\t  provided by the system controller.\n\nconfig TRUSTED_FOUNDATIONS\n\tbool \"Trusted Foundations secure monitor support\"\n\tdepends on ARM && CPU_V7\n\thelp\n\t  Some devices (including most early Tegra-based consumer devices on\n\t  the market) are booted with the Trusted Foundations secure monitor\n\t  active, requiring some core operations to be performed by the secure\n\t  monitor instead of the kernel.\n\n\t  This option allows the kernel to invoke the secure monitor whenever\n\t  required on devices using Trusted Foundations. See the functions and\n\t  comments in linux/firmware/trusted_foundations.h or the device tree\n\t  bindings for \"tlm,trusted-foundations\" for details on how to use it.\n\n\t  Choose N if you don't know what this is about.\n\nconfig TURRIS_MOX_RWTM\n\ttristate \"Turris Mox rWTM secure firmware driver\"\n\tdepends on ARCH_MVEBU || COMPILE_TEST\n\tdepends on HAS_DMA && OF\n\tdepends on MAILBOX\n\tselect HW_RANDOM\n\tselect ARMADA_37XX_RWTM_MBOX\n\thelp\n\t  This driver communicates with the firmware on the Cortex-M3 secure\n\t  processor of the Turris Mox router. Enable if you are building for\n\t  Turris Mox, and you will be able to read the device serial number and\n\t  other manufacturing data and also utilize the Entropy Bit Generator\n\t  for hardware random number generation.\n\nsource \"drivers/firmware/arm_ffa/Kconfig\"\nsource \"drivers/firmware/broadcom/Kconfig\"\nsource \"drivers/firmware/cirrus/Kconfig\"\nsource \"drivers/firmware/google/Kconfig\"\nsource \"drivers/firmware/efi/Kconfig\"\nsource \"drivers/firmware/imx/Kconfig\"\nsource \"drivers/firmware/meson/Kconfig\"\nsource \"drivers/firmware/psci/Kconfig\"\nsource \"drivers/firmware/smccc/Kconfig\"\nsource \"drivers/firmware/tegra/Kconfig\"\nsource \"drivers/firmware/xilinx/Kconfig\"\n\nendmenu\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}