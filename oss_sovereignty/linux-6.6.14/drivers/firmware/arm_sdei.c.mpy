{
  "module_name": "arm_sdei.c",
  "hash_id": "92479832d563e6685c5dd4f955e23957a73f46cd52c7dc9c37dbbcdddc1f4f0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/arm_sdei.c",
  "human_readable_source": "\n\n#define pr_fmt(fmt) \"sdei: \" fmt\n\n#include <acpi/ghes.h>\n#include <linux/acpi.h>\n#include <linux/arm_sdei.h>\n#include <linux/arm-smccc.h>\n#include <linux/atomic.h>\n#include <linux/bitops.h>\n#include <linux/compiler.h>\n#include <linux/cpuhotplug.h>\n#include <linux/cpu.h>\n#include <linux/cpu_pm.h>\n#include <linux/errno.h>\n#include <linux/hardirq.h>\n#include <linux/kernel.h>\n#include <linux/kprobes.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/notifier.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/percpu.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/ptrace.h>\n#include <linux/preempt.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n\n \nstatic asmlinkage void (*sdei_firmware_call)(unsigned long function_id,\n\t\t      unsigned long arg0, unsigned long arg1,\n\t\t      unsigned long arg2, unsigned long arg3,\n\t\t      unsigned long arg4, struct arm_smccc_res *res);\n\n \nstatic unsigned long sdei_entry_point;\n\nstatic int sdei_hp_state;\n\nstruct sdei_event {\n\t \n\tstruct list_head\tlist;\n\tbool\t\t\treregister;\n\tbool\t\t\treenable;\n\n\tu32\t\t\tevent_num;\n\tu8\t\t\ttype;\n\tu8\t\t\tpriority;\n\n\t \n\tunion {\n\t\t \n\t\tstruct sdei_registered_event *registered;\n\n\t\t \n\t\tstruct sdei_registered_event __percpu *private_registered;\n\t};\n};\n\n \nstatic DEFINE_MUTEX(sdei_events_lock);\n\n \nstatic DEFINE_SPINLOCK(sdei_list_lock);\nstatic LIST_HEAD(sdei_list);\n\n \nstruct sdei_crosscall_args {\n\tstruct sdei_event *event;\n\tatomic_t errors;\n\tint first_error;\n};\n\n#define CROSSCALL_INIT(arg, event)\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\targ.event = event;\t\t\\\n\t\targ.first_error = 0;\t\t\\\n\t\tatomic_set(&arg.errors, 0);\t\\\n\t} while (0)\n\nstatic inline int sdei_do_local_call(smp_call_func_t fn,\n\t\t\t\t     struct sdei_event *event)\n{\n\tstruct sdei_crosscall_args arg;\n\n\tCROSSCALL_INIT(arg, event);\n\tfn(&arg);\n\n\treturn arg.first_error;\n}\n\nstatic inline int sdei_do_cross_call(smp_call_func_t fn,\n\t\t\t\t     struct sdei_event *event)\n{\n\tstruct sdei_crosscall_args arg;\n\n\tCROSSCALL_INIT(arg, event);\n\ton_each_cpu(fn, &arg, true);\n\n\treturn arg.first_error;\n}\n\nstatic inline void\nsdei_cross_call_return(struct sdei_crosscall_args *arg, int err)\n{\n\tif (err && (atomic_inc_return(&arg->errors) == 1))\n\t\targ->first_error = err;\n}\n\nstatic int sdei_to_linux_errno(unsigned long sdei_err)\n{\n\tswitch (sdei_err) {\n\tcase SDEI_NOT_SUPPORTED:\n\t\treturn -EOPNOTSUPP;\n\tcase SDEI_INVALID_PARAMETERS:\n\t\treturn -EINVAL;\n\tcase SDEI_DENIED:\n\t\treturn -EPERM;\n\tcase SDEI_PENDING:\n\t\treturn -EINPROGRESS;\n\tcase SDEI_OUT_OF_RESOURCE:\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int invoke_sdei_fn(unsigned long function_id, unsigned long arg0,\n\t\t\t  unsigned long arg1, unsigned long arg2,\n\t\t\t  unsigned long arg3, unsigned long arg4,\n\t\t\t  u64 *result)\n{\n\tint err;\n\tstruct arm_smccc_res res;\n\n\tif (sdei_firmware_call) {\n\t\tsdei_firmware_call(function_id, arg0, arg1, arg2, arg3, arg4,\n\t\t\t\t   &res);\n\t\terr = sdei_to_linux_errno(res.a0);\n\t} else {\n\t\t \n\t\terr = -EIO;\n\t\tres.a0 = SDEI_NOT_SUPPORTED;\n\t}\n\n\tif (result)\n\t\t*result = res.a0;\n\n\treturn err;\n}\nNOKPROBE_SYMBOL(invoke_sdei_fn);\n\nstatic struct sdei_event *sdei_event_find(u32 event_num)\n{\n\tstruct sdei_event *e, *found = NULL;\n\n\tlockdep_assert_held(&sdei_events_lock);\n\n\tspin_lock(&sdei_list_lock);\n\tlist_for_each_entry(e, &sdei_list, list) {\n\t\tif (e->event_num == event_num) {\n\t\t\tfound = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&sdei_list_lock);\n\n\treturn found;\n}\n\nint sdei_api_event_context(u32 query, u64 *result)\n{\n\treturn invoke_sdei_fn(SDEI_1_0_FN_SDEI_EVENT_CONTEXT, query, 0, 0, 0, 0,\n\t\t\t      result);\n}\nNOKPROBE_SYMBOL(sdei_api_event_context);\n\nstatic int sdei_api_event_get_info(u32 event, u32 info, u64 *result)\n{\n\treturn invoke_sdei_fn(SDEI_1_0_FN_SDEI_EVENT_GET_INFO, event, info, 0,\n\t\t\t      0, 0, result);\n}\n\nstatic struct sdei_event *sdei_event_create(u32 event_num,\n\t\t\t\t\t    sdei_event_callback *cb,\n\t\t\t\t\t    void *cb_arg)\n{\n\tint err;\n\tu64 result;\n\tstruct sdei_event *event;\n\tstruct sdei_registered_event *reg;\n\n\tlockdep_assert_held(&sdei_events_lock);\n\n\tevent = kzalloc(sizeof(*event), GFP_KERNEL);\n\tif (!event) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tINIT_LIST_HEAD(&event->list);\n\tevent->event_num = event_num;\n\n\terr = sdei_api_event_get_info(event_num, SDEI_EVENT_INFO_EV_PRIORITY,\n\t\t\t\t      &result);\n\tif (err)\n\t\tgoto fail;\n\tevent->priority = result;\n\n\terr = sdei_api_event_get_info(event_num, SDEI_EVENT_INFO_EV_TYPE,\n\t\t\t\t      &result);\n\tif (err)\n\t\tgoto fail;\n\tevent->type = result;\n\n\tif (event->type == SDEI_EVENT_TYPE_SHARED) {\n\t\treg = kzalloc(sizeof(*reg), GFP_KERNEL);\n\t\tif (!reg) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\treg->event_num = event->event_num;\n\t\treg->priority = event->priority;\n\n\t\treg->callback = cb;\n\t\treg->callback_arg = cb_arg;\n\t\tevent->registered = reg;\n\t} else {\n\t\tint cpu;\n\t\tstruct sdei_registered_event __percpu *regs;\n\n\t\tregs = alloc_percpu(struct sdei_registered_event);\n\t\tif (!regs) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\treg = per_cpu_ptr(regs, cpu);\n\n\t\t\treg->event_num = event->event_num;\n\t\t\treg->priority = event->priority;\n\t\t\treg->callback = cb;\n\t\t\treg->callback_arg = cb_arg;\n\t\t}\n\n\t\tevent->private_registered = regs;\n\t}\n\n\tspin_lock(&sdei_list_lock);\n\tlist_add(&event->list, &sdei_list);\n\tspin_unlock(&sdei_list_lock);\n\n\treturn event;\n\nfail:\n\tkfree(event);\n\treturn ERR_PTR(err);\n}\n\nstatic void sdei_event_destroy_llocked(struct sdei_event *event)\n{\n\tlockdep_assert_held(&sdei_events_lock);\n\tlockdep_assert_held(&sdei_list_lock);\n\n\tlist_del(&event->list);\n\n\tif (event->type == SDEI_EVENT_TYPE_SHARED)\n\t\tkfree(event->registered);\n\telse\n\t\tfree_percpu(event->private_registered);\n\n\tkfree(event);\n}\n\nstatic void sdei_event_destroy(struct sdei_event *event)\n{\n\tspin_lock(&sdei_list_lock);\n\tsdei_event_destroy_llocked(event);\n\tspin_unlock(&sdei_list_lock);\n}\n\nstatic int sdei_api_get_version(u64 *version)\n{\n\treturn invoke_sdei_fn(SDEI_1_0_FN_SDEI_VERSION, 0, 0, 0, 0, 0, version);\n}\n\nint sdei_mask_local_cpu(void)\n{\n\tint err;\n\n\terr = invoke_sdei_fn(SDEI_1_0_FN_SDEI_PE_MASK, 0, 0, 0, 0, 0, NULL);\n\tif (err && err != -EIO) {\n\t\tpr_warn_once(\"failed to mask CPU[%u]: %d\\n\",\n\t\t\t      smp_processor_id(), err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void _ipi_mask_cpu(void *ignored)\n{\n\tWARN_ON_ONCE(preemptible());\n\tsdei_mask_local_cpu();\n}\n\nint sdei_unmask_local_cpu(void)\n{\n\tint err;\n\n\terr = invoke_sdei_fn(SDEI_1_0_FN_SDEI_PE_UNMASK, 0, 0, 0, 0, 0, NULL);\n\tif (err && err != -EIO) {\n\t\tpr_warn_once(\"failed to unmask CPU[%u]: %d\\n\",\n\t\t\t     smp_processor_id(), err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void _ipi_unmask_cpu(void *ignored)\n{\n\tWARN_ON_ONCE(preemptible());\n\tsdei_unmask_local_cpu();\n}\n\nstatic void _ipi_private_reset(void *ignored)\n{\n\tint err;\n\n\tWARN_ON_ONCE(preemptible());\n\n\terr = invoke_sdei_fn(SDEI_1_0_FN_SDEI_PRIVATE_RESET, 0, 0, 0, 0, 0,\n\t\t\t     NULL);\n\tif (err && err != -EIO)\n\t\tpr_warn_once(\"failed to reset CPU[%u]: %d\\n\",\n\t\t\t     smp_processor_id(), err);\n}\n\nstatic int sdei_api_shared_reset(void)\n{\n\treturn invoke_sdei_fn(SDEI_1_0_FN_SDEI_SHARED_RESET, 0, 0, 0, 0, 0,\n\t\t\t      NULL);\n}\n\nstatic void sdei_mark_interface_broken(void)\n{\n\tpr_err(\"disabling SDEI firmware interface\\n\");\n\ton_each_cpu(&_ipi_mask_cpu, NULL, true);\n\tsdei_firmware_call = NULL;\n}\n\nstatic int sdei_platform_reset(void)\n{\n\tint err;\n\n\ton_each_cpu(&_ipi_private_reset, NULL, true);\n\terr = sdei_api_shared_reset();\n\tif (err) {\n\t\tpr_err(\"Failed to reset platform: %d\\n\", err);\n\t\tsdei_mark_interface_broken();\n\t}\n\n\treturn err;\n}\n\nstatic int sdei_api_event_enable(u32 event_num)\n{\n\treturn invoke_sdei_fn(SDEI_1_0_FN_SDEI_EVENT_ENABLE, event_num, 0, 0, 0,\n\t\t\t      0, NULL);\n}\n\n \nstatic void _local_event_enable(void *data)\n{\n\tint err;\n\tstruct sdei_crosscall_args *arg = data;\n\n\terr = sdei_api_event_enable(arg->event->event_num);\n\n\tsdei_cross_call_return(arg, err);\n}\n\nint sdei_event_enable(u32 event_num)\n{\n\tint err = -EINVAL;\n\tstruct sdei_event *event;\n\n\tmutex_lock(&sdei_events_lock);\n\tevent = sdei_event_find(event_num);\n\tif (!event) {\n\t\tmutex_unlock(&sdei_events_lock);\n\t\treturn -ENOENT;\n\t}\n\n\n\tcpus_read_lock();\n\tif (event->type == SDEI_EVENT_TYPE_SHARED)\n\t\terr = sdei_api_event_enable(event->event_num);\n\telse\n\t\terr = sdei_do_cross_call(_local_event_enable, event);\n\n\tif (!err) {\n\t\tspin_lock(&sdei_list_lock);\n\t\tevent->reenable = true;\n\t\tspin_unlock(&sdei_list_lock);\n\t}\n\tcpus_read_unlock();\n\tmutex_unlock(&sdei_events_lock);\n\n\treturn err;\n}\n\nstatic int sdei_api_event_disable(u32 event_num)\n{\n\treturn invoke_sdei_fn(SDEI_1_0_FN_SDEI_EVENT_DISABLE, event_num, 0, 0,\n\t\t\t      0, 0, NULL);\n}\n\nstatic void _ipi_event_disable(void *data)\n{\n\tint err;\n\tstruct sdei_crosscall_args *arg = data;\n\n\terr = sdei_api_event_disable(arg->event->event_num);\n\n\tsdei_cross_call_return(arg, err);\n}\n\nint sdei_event_disable(u32 event_num)\n{\n\tint err = -EINVAL;\n\tstruct sdei_event *event;\n\n\tmutex_lock(&sdei_events_lock);\n\tevent = sdei_event_find(event_num);\n\tif (!event) {\n\t\tmutex_unlock(&sdei_events_lock);\n\t\treturn -ENOENT;\n\t}\n\n\tspin_lock(&sdei_list_lock);\n\tevent->reenable = false;\n\tspin_unlock(&sdei_list_lock);\n\n\tif (event->type == SDEI_EVENT_TYPE_SHARED)\n\t\terr = sdei_api_event_disable(event->event_num);\n\telse\n\t\terr = sdei_do_cross_call(_ipi_event_disable, event);\n\tmutex_unlock(&sdei_events_lock);\n\n\treturn err;\n}\n\nstatic int sdei_api_event_unregister(u32 event_num)\n{\n\treturn invoke_sdei_fn(SDEI_1_0_FN_SDEI_EVENT_UNREGISTER, event_num, 0,\n\t\t\t      0, 0, 0, NULL);\n}\n\n \nstatic void _local_event_unregister(void *data)\n{\n\tint err;\n\tstruct sdei_crosscall_args *arg = data;\n\n\terr = sdei_api_event_unregister(arg->event->event_num);\n\n\tsdei_cross_call_return(arg, err);\n}\n\nint sdei_event_unregister(u32 event_num)\n{\n\tint err;\n\tstruct sdei_event *event;\n\n\tWARN_ON(in_nmi());\n\n\tmutex_lock(&sdei_events_lock);\n\tevent = sdei_event_find(event_num);\n\tif (!event) {\n\t\tpr_warn(\"Event %u not registered\\n\", event_num);\n\t\terr = -ENOENT;\n\t\tgoto unlock;\n\t}\n\n\tspin_lock(&sdei_list_lock);\n\tevent->reregister = false;\n\tevent->reenable = false;\n\tspin_unlock(&sdei_list_lock);\n\n\tif (event->type == SDEI_EVENT_TYPE_SHARED)\n\t\terr = sdei_api_event_unregister(event->event_num);\n\telse\n\t\terr = sdei_do_cross_call(_local_event_unregister, event);\n\n\tif (err)\n\t\tgoto unlock;\n\n\tsdei_event_destroy(event);\nunlock:\n\tmutex_unlock(&sdei_events_lock);\n\n\treturn err;\n}\n\n \nstatic int sdei_unregister_shared(void)\n{\n\tint err = 0;\n\tstruct sdei_event *event;\n\n\tmutex_lock(&sdei_events_lock);\n\tspin_lock(&sdei_list_lock);\n\tlist_for_each_entry(event, &sdei_list, list) {\n\t\tif (event->type != SDEI_EVENT_TYPE_SHARED)\n\t\t\tcontinue;\n\n\t\terr = sdei_api_event_unregister(event->event_num);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&sdei_list_lock);\n\tmutex_unlock(&sdei_events_lock);\n\n\treturn err;\n}\n\nstatic int sdei_api_event_register(u32 event_num, unsigned long entry_point,\n\t\t\t\t   void *arg, u64 flags, u64 affinity)\n{\n\treturn invoke_sdei_fn(SDEI_1_0_FN_SDEI_EVENT_REGISTER, event_num,\n\t\t\t      (unsigned long)entry_point, (unsigned long)arg,\n\t\t\t      flags, affinity, NULL);\n}\n\n \nstatic void _local_event_register(void *data)\n{\n\tint err;\n\tstruct sdei_registered_event *reg;\n\tstruct sdei_crosscall_args *arg = data;\n\n\treg = per_cpu_ptr(arg->event->private_registered, smp_processor_id());\n\terr = sdei_api_event_register(arg->event->event_num, sdei_entry_point,\n\t\t\t\t      reg, 0, 0);\n\n\tsdei_cross_call_return(arg, err);\n}\n\nint sdei_event_register(u32 event_num, sdei_event_callback *cb, void *arg)\n{\n\tint err;\n\tstruct sdei_event *event;\n\n\tWARN_ON(in_nmi());\n\n\tmutex_lock(&sdei_events_lock);\n\tif (sdei_event_find(event_num)) {\n\t\tpr_warn(\"Event %u already registered\\n\", event_num);\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tevent = sdei_event_create(event_num, cb, arg);\n\tif (IS_ERR(event)) {\n\t\terr = PTR_ERR(event);\n\t\tpr_warn(\"Failed to create event %u: %d\\n\", event_num, err);\n\t\tgoto unlock;\n\t}\n\n\tcpus_read_lock();\n\tif (event->type == SDEI_EVENT_TYPE_SHARED) {\n\t\terr = sdei_api_event_register(event->event_num,\n\t\t\t\t\t      sdei_entry_point,\n\t\t\t\t\t      event->registered,\n\t\t\t\t\t      SDEI_EVENT_REGISTER_RM_ANY, 0);\n\t} else {\n\t\terr = sdei_do_cross_call(_local_event_register, event);\n\t\tif (err)\n\t\t\tsdei_do_cross_call(_local_event_unregister, event);\n\t}\n\n\tif (err) {\n\t\tsdei_event_destroy(event);\n\t\tpr_warn(\"Failed to register event %u: %d\\n\", event_num, err);\n\t\tgoto cpu_unlock;\n\t}\n\n\tspin_lock(&sdei_list_lock);\n\tevent->reregister = true;\n\tspin_unlock(&sdei_list_lock);\ncpu_unlock:\n\tcpus_read_unlock();\nunlock:\n\tmutex_unlock(&sdei_events_lock);\n\treturn err;\n}\n\nstatic int sdei_reregister_shared(void)\n{\n\tint err = 0;\n\tstruct sdei_event *event;\n\n\tmutex_lock(&sdei_events_lock);\n\tspin_lock(&sdei_list_lock);\n\tlist_for_each_entry(event, &sdei_list, list) {\n\t\tif (event->type != SDEI_EVENT_TYPE_SHARED)\n\t\t\tcontinue;\n\n\t\tif (event->reregister) {\n\t\t\terr = sdei_api_event_register(event->event_num,\n\t\t\t\t\tsdei_entry_point, event->registered,\n\t\t\t\t\tSDEI_EVENT_REGISTER_RM_ANY, 0);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"Failed to re-register event %u\\n\",\n\t\t\t\t       event->event_num);\n\t\t\t\tsdei_event_destroy_llocked(event);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (event->reenable) {\n\t\t\terr = sdei_api_event_enable(event->event_num);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"Failed to re-enable event %u\\n\",\n\t\t\t\t       event->event_num);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&sdei_list_lock);\n\tmutex_unlock(&sdei_events_lock);\n\n\treturn err;\n}\n\nstatic int sdei_cpuhp_down(unsigned int cpu)\n{\n\tstruct sdei_event *event;\n\tint err;\n\n\t \n\tspin_lock(&sdei_list_lock);\n\tlist_for_each_entry(event, &sdei_list, list) {\n\t\tif (event->type == SDEI_EVENT_TYPE_SHARED)\n\t\t\tcontinue;\n\n\t\terr = sdei_do_local_call(_local_event_unregister, event);\n\t\tif (err) {\n\t\t\tpr_err(\"Failed to unregister event %u: %d\\n\",\n\t\t\t       event->event_num, err);\n\t\t}\n\t}\n\tspin_unlock(&sdei_list_lock);\n\n\treturn sdei_mask_local_cpu();\n}\n\nstatic int sdei_cpuhp_up(unsigned int cpu)\n{\n\tstruct sdei_event *event;\n\tint err;\n\n\t \n\tspin_lock(&sdei_list_lock);\n\tlist_for_each_entry(event, &sdei_list, list) {\n\t\tif (event->type == SDEI_EVENT_TYPE_SHARED)\n\t\t\tcontinue;\n\n\t\tif (event->reregister) {\n\t\t\terr = sdei_do_local_call(_local_event_register, event);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"Failed to re-register event %u: %d\\n\",\n\t\t\t\t       event->event_num, err);\n\t\t\t}\n\t\t}\n\n\t\tif (event->reenable) {\n\t\t\terr = sdei_do_local_call(_local_event_enable, event);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"Failed to re-enable event %u: %d\\n\",\n\t\t\t\t       event->event_num, err);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&sdei_list_lock);\n\n\treturn sdei_unmask_local_cpu();\n}\n\n \nstatic int sdei_pm_notifier(struct notifier_block *nb, unsigned long action,\n\t\t\t    void *data)\n{\n\tint rv;\n\n\tWARN_ON_ONCE(preemptible());\n\n\tswitch (action) {\n\tcase CPU_PM_ENTER:\n\t\trv = sdei_mask_local_cpu();\n\t\tbreak;\n\tcase CPU_PM_EXIT:\n\tcase CPU_PM_ENTER_FAILED:\n\t\trv = sdei_unmask_local_cpu();\n\t\tbreak;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tif (rv)\n\t\treturn notifier_from_errno(rv);\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block sdei_pm_nb = {\n\t.notifier_call = sdei_pm_notifier,\n};\n\nstatic int sdei_device_suspend(struct device *dev)\n{\n\ton_each_cpu(_ipi_mask_cpu, NULL, true);\n\n\treturn 0;\n}\n\nstatic int sdei_device_resume(struct device *dev)\n{\n\ton_each_cpu(_ipi_unmask_cpu, NULL, true);\n\n\treturn 0;\n}\n\n \nstatic int sdei_device_freeze(struct device *dev)\n{\n\tint err;\n\n\t \n\tcpuhp_remove_state(sdei_entry_point);\n\n\terr = sdei_unregister_shared();\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int sdei_device_thaw(struct device *dev)\n{\n\tint err;\n\n\t \n\terr = sdei_reregister_shared();\n\tif (err) {\n\t\tpr_warn(\"Failed to re-register shared events...\\n\");\n\t\tsdei_mark_interface_broken();\n\t\treturn err;\n\t}\n\n\terr = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"SDEI\",\n\t\t\t\t&sdei_cpuhp_up, &sdei_cpuhp_down);\n\tif (err < 0) {\n\t\tpr_warn(\"Failed to re-register CPU hotplug notifier...\\n\");\n\t\treturn err;\n\t}\n\n\tsdei_hp_state = err;\n\treturn 0;\n}\n\nstatic int sdei_device_restore(struct device *dev)\n{\n\tint err;\n\n\terr = sdei_platform_reset();\n\tif (err)\n\t\treturn err;\n\n\treturn sdei_device_thaw(dev);\n}\n\nstatic const struct dev_pm_ops sdei_pm_ops = {\n\t.suspend = sdei_device_suspend,\n\t.resume = sdei_device_resume,\n\t.freeze = sdei_device_freeze,\n\t.thaw = sdei_device_thaw,\n\t.restore = sdei_device_restore,\n};\n\n \nstatic int sdei_reboot_notifier(struct notifier_block *nb, unsigned long action,\n\t\t\t\tvoid *data)\n{\n\t \n\tcpuhp_remove_state(sdei_hp_state);\n\n\tsdei_platform_reset();\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block sdei_reboot_nb = {\n\t.notifier_call = sdei_reboot_notifier,\n};\n\nstatic void sdei_smccc_smc(unsigned long function_id,\n\t\t\t   unsigned long arg0, unsigned long arg1,\n\t\t\t   unsigned long arg2, unsigned long arg3,\n\t\t\t   unsigned long arg4, struct arm_smccc_res *res)\n{\n\tarm_smccc_smc(function_id, arg0, arg1, arg2, arg3, arg4, 0, 0, res);\n}\nNOKPROBE_SYMBOL(sdei_smccc_smc);\n\nstatic void sdei_smccc_hvc(unsigned long function_id,\n\t\t\t   unsigned long arg0, unsigned long arg1,\n\t\t\t   unsigned long arg2, unsigned long arg3,\n\t\t\t   unsigned long arg4, struct arm_smccc_res *res)\n{\n\tarm_smccc_hvc(function_id, arg0, arg1, arg2, arg3, arg4, 0, 0, res);\n}\nNOKPROBE_SYMBOL(sdei_smccc_hvc);\n\nint sdei_register_ghes(struct ghes *ghes, sdei_event_callback *normal_cb,\n\t\t       sdei_event_callback *critical_cb)\n{\n\tint err;\n\tu64 result;\n\tu32 event_num;\n\tsdei_event_callback *cb;\n\n\tif (!IS_ENABLED(CONFIG_ACPI_APEI_GHES))\n\t\treturn -EOPNOTSUPP;\n\n\tevent_num = ghes->generic->notify.vector;\n\tif (event_num == 0) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\terr = sdei_api_event_get_info(event_num, SDEI_EVENT_INFO_EV_PRIORITY,\n\t\t\t\t      &result);\n\tif (err)\n\t\treturn err;\n\n\tif (result == SDEI_EVENT_PRIORITY_CRITICAL)\n\t\tcb = critical_cb;\n\telse\n\t\tcb = normal_cb;\n\n\terr = sdei_event_register(event_num, cb, ghes);\n\tif (!err)\n\t\terr = sdei_event_enable(event_num);\n\n\treturn err;\n}\n\nint sdei_unregister_ghes(struct ghes *ghes)\n{\n\tint i;\n\tint err;\n\tu32 event_num = ghes->generic->notify.vector;\n\n\tmight_sleep();\n\n\tif (!IS_ENABLED(CONFIG_ACPI_APEI_GHES))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\terr = sdei_event_disable(event_num);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < 3; i++) {\n\t\terr = sdei_event_unregister(event_num);\n\t\tif (err != -EINPROGRESS)\n\t\t\tbreak;\n\n\t\tschedule();\n\t}\n\n\treturn err;\n}\n\nstatic int sdei_get_conduit(struct platform_device *pdev)\n{\n\tconst char *method;\n\tstruct device_node *np = pdev->dev.of_node;\n\n\tsdei_firmware_call = NULL;\n\tif (np) {\n\t\tif (of_property_read_string(np, \"method\", &method)) {\n\t\t\tpr_warn(\"missing \\\"method\\\" property\\n\");\n\t\t\treturn SMCCC_CONDUIT_NONE;\n\t\t}\n\n\t\tif (!strcmp(\"hvc\", method)) {\n\t\t\tsdei_firmware_call = &sdei_smccc_hvc;\n\t\t\treturn SMCCC_CONDUIT_HVC;\n\t\t} else if (!strcmp(\"smc\", method)) {\n\t\t\tsdei_firmware_call = &sdei_smccc_smc;\n\t\t\treturn SMCCC_CONDUIT_SMC;\n\t\t}\n\n\t\tpr_warn(\"invalid \\\"method\\\" property: %s\\n\", method);\n\t} else if (!acpi_disabled) {\n\t\tif (acpi_psci_use_hvc()) {\n\t\t\tsdei_firmware_call = &sdei_smccc_hvc;\n\t\t\treturn SMCCC_CONDUIT_HVC;\n\t\t} else {\n\t\t\tsdei_firmware_call = &sdei_smccc_smc;\n\t\t\treturn SMCCC_CONDUIT_SMC;\n\t\t}\n\t}\n\n\treturn SMCCC_CONDUIT_NONE;\n}\n\nstatic int sdei_probe(struct platform_device *pdev)\n{\n\tint err;\n\tu64 ver = 0;\n\tint conduit;\n\n\tconduit = sdei_get_conduit(pdev);\n\tif (!sdei_firmware_call)\n\t\treturn 0;\n\n\terr = sdei_api_get_version(&ver);\n\tif (err) {\n\t\tpr_err(\"Failed to get SDEI version: %d\\n\", err);\n\t\tsdei_mark_interface_broken();\n\t\treturn err;\n\t}\n\n\tpr_info(\"SDEIv%d.%d (0x%x) detected in firmware.\\n\",\n\t\t(int)SDEI_VERSION_MAJOR(ver), (int)SDEI_VERSION_MINOR(ver),\n\t\t(int)SDEI_VERSION_VENDOR(ver));\n\n\tif (SDEI_VERSION_MAJOR(ver) != 1) {\n\t\tpr_warn(\"Conflicting SDEI version detected.\\n\");\n\t\tsdei_mark_interface_broken();\n\t\treturn -EINVAL;\n\t}\n\n\terr = sdei_platform_reset();\n\tif (err)\n\t\treturn err;\n\n\tsdei_entry_point = sdei_arch_get_entry_point(conduit);\n\tif (!sdei_entry_point) {\n\t\t \n\t\tsdei_mark_interface_broken();\n\t\treturn 0;\n\t}\n\n\terr = cpu_pm_register_notifier(&sdei_pm_nb);\n\tif (err) {\n\t\tpr_warn(\"Failed to register CPU PM notifier...\\n\");\n\t\tgoto error;\n\t}\n\n\terr = register_reboot_notifier(&sdei_reboot_nb);\n\tif (err) {\n\t\tpr_warn(\"Failed to register reboot notifier...\\n\");\n\t\tgoto remove_cpupm;\n\t}\n\n\terr = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"SDEI\",\n\t\t\t\t&sdei_cpuhp_up, &sdei_cpuhp_down);\n\tif (err < 0) {\n\t\tpr_warn(\"Failed to register CPU hotplug notifier...\\n\");\n\t\tgoto remove_reboot;\n\t}\n\n\tsdei_hp_state = err;\n\n\treturn 0;\n\nremove_reboot:\n\tunregister_reboot_notifier(&sdei_reboot_nb);\n\nremove_cpupm:\n\tcpu_pm_unregister_notifier(&sdei_pm_nb);\n\nerror:\n\tsdei_mark_interface_broken();\n\treturn err;\n}\n\nstatic const struct of_device_id sdei_of_match[] = {\n\t{ .compatible = \"arm,sdei-1.0\" },\n\t{}\n};\n\nstatic struct platform_driver sdei_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t\t= \"sdei\",\n\t\t.pm\t\t\t= &sdei_pm_ops,\n\t\t.of_match_table\t\t= sdei_of_match,\n\t},\n\t.probe\t\t= sdei_probe,\n};\n\nstatic bool __init sdei_present_acpi(void)\n{\n\tacpi_status status;\n\tstruct acpi_table_header *sdei_table_header;\n\n\tif (acpi_disabled)\n\t\treturn false;\n\n\tstatus = acpi_get_table(ACPI_SIG_SDEI, 0, &sdei_table_header);\n\tif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\n\t\tconst char *msg = acpi_format_exception(status);\n\n\t\tpr_info(\"Failed to get ACPI:SDEI table, %s\\n\", msg);\n\t}\n\tif (ACPI_FAILURE(status))\n\t\treturn false;\n\n\tacpi_put_table(sdei_table_header);\n\n\treturn true;\n}\n\nvoid __init sdei_init(void)\n{\n\tstruct platform_device *pdev;\n\tint ret;\n\n\tret = platform_driver_register(&sdei_driver);\n\tif (ret || !sdei_present_acpi())\n\t\treturn;\n\n\tpdev = platform_device_register_simple(sdei_driver.driver.name,\n\t\t\t\t\t       0, NULL, 0);\n\tif (IS_ERR(pdev)) {\n\t\tret = PTR_ERR(pdev);\n\t\tplatform_driver_unregister(&sdei_driver);\n\t\tpr_info(\"Failed to register ACPI:SDEI platform device %d\\n\",\n\t\t\tret);\n\t}\n}\n\nint sdei_event_handler(struct pt_regs *regs,\n\t\t       struct sdei_registered_event *arg)\n{\n\tint err;\n\tu32 event_num = arg->event_num;\n\n\terr = arg->callback(event_num, regs, arg->callback_arg);\n\tif (err)\n\t\tpr_err_ratelimited(\"event %u on CPU %u failed with error: %d\\n\",\n\t\t\t\t   event_num, smp_processor_id(), err);\n\n\treturn err;\n}\nNOKPROBE_SYMBOL(sdei_event_handler);\n\nvoid sdei_handler_abort(void)\n{\n\t \n\tif (__this_cpu_read(sdei_active_critical_event)) {\n\t        pr_warn(\"still in SDEI critical event context, attempting to finish handler.\\n\");\n\t        __sdei_handler_abort();\n\t        __this_cpu_write(sdei_active_critical_event, NULL);\n\t}\n\tif (__this_cpu_read(sdei_active_normal_event)) {\n\t        pr_warn(\"still in SDEI normal event context, attempting to finish handler.\\n\");\n\t        __sdei_handler_abort();\n\t        __this_cpu_write(sdei_active_normal_event, NULL);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}