{
  "module_name": "edd.c",
  "hash_id": "a06030a3a013d15904189b453cd452b5c0b25ee5ee3a287eb8506986325ca3c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/edd.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/stat.h>\n#include <linux/err.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/limits.h>\n#include <linux/device.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/edd.h>\n\n#define EDD_VERSION \"0.16\"\n#define EDD_DATE    \"2004-Jun-25\"\n\nMODULE_AUTHOR(\"Matt Domsch <Matt_Domsch@Dell.com>\");\nMODULE_DESCRIPTION(\"sysfs interface to BIOS EDD information\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(EDD_VERSION);\n\n#define left (PAGE_SIZE - (p - buf) - 1)\n\nstruct edd_device {\n\tunsigned int index;\n\tunsigned int mbr_signature;\n\tstruct edd_info *info;\n\tstruct kobject kobj;\n};\n\nstruct edd_attribute {\n\tstruct attribute attr;\n\tssize_t(*show) (struct edd_device * edev, char *buf);\n\tint (*test) (struct edd_device * edev);\n};\n\n \nstatic int edd_dev_is_type(struct edd_device *edev, const char *type);\nstatic struct pci_dev *edd_get_pci_dev(struct edd_device *edev);\n\nstatic struct edd_device *edd_devices[EDD_MBR_SIG_MAX];\n\n#define EDD_DEVICE_ATTR(_name,_mode,_show,_test) \\\nstruct edd_attribute edd_attr_##_name = { \t\\\n\t.attr = {.name = __stringify(_name), .mode = _mode },\t\\\n\t.show\t= _show,\t\t\t\t\\\n\t.test\t= _test,\t\t\t\t\\\n};\n\nstatic int\nedd_has_mbr_signature(struct edd_device *edev)\n{\n\treturn edev->index < min_t(unsigned char, edd.mbr_signature_nr, EDD_MBR_SIG_MAX);\n}\n\nstatic int\nedd_has_edd_info(struct edd_device *edev)\n{\n\treturn edev->index < min_t(unsigned char, edd.edd_info_nr, EDDMAXNR);\n}\n\nstatic inline struct edd_info *\nedd_dev_get_info(struct edd_device *edev)\n{\n\treturn edev->info;\n}\n\nstatic inline void\nedd_dev_set_info(struct edd_device *edev, int i)\n{\n\tedev->index = i;\n\tif (edd_has_mbr_signature(edev))\n\t\tedev->mbr_signature = edd.mbr_signature[i];\n\tif (edd_has_edd_info(edev))\n\t\tedev->info = &edd.edd_info[i];\n}\n\n#define to_edd_attr(_attr) container_of(_attr,struct edd_attribute,attr)\n#define to_edd_device(obj) container_of(obj,struct edd_device,kobj)\n\nstatic ssize_t\nedd_attr_show(struct kobject * kobj, struct attribute *attr, char *buf)\n{\n\tstruct edd_device *dev = to_edd_device(kobj);\n\tstruct edd_attribute *edd_attr = to_edd_attr(attr);\n\tssize_t ret = -EIO;\n\n\tif (edd_attr->show)\n\t\tret = edd_attr->show(dev, buf);\n\treturn ret;\n}\n\nstatic const struct sysfs_ops edd_attr_ops = {\n\t.show = edd_attr_show,\n};\n\nstatic ssize_t\nedd_show_host_bus(struct edd_device *edev, char *buf)\n{\n\tstruct edd_info *info;\n\tchar *p = buf;\n\tint i;\n\n\tif (!edev)\n\t\treturn -EINVAL;\n\tinfo = edd_dev_get_info(edev);\n\tif (!info || !buf)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (isprint(info->params.host_bus_type[i])) {\n\t\t\tp += scnprintf(p, left, \"%c\", info->params.host_bus_type[i]);\n\t\t} else {\n\t\t\tp += scnprintf(p, left, \" \");\n\t\t}\n\t}\n\n\tif (!strncmp(info->params.host_bus_type, \"ISA\", 3)) {\n\t\tp += scnprintf(p, left, \"\\tbase_address: %x\\n\",\n\t\t\t     info->params.interface_path.isa.base_address);\n\t} else if (!strncmp(info->params.host_bus_type, \"PCIX\", 4) ||\n\t\t   !strncmp(info->params.host_bus_type, \"PCI\", 3) ||\n\t\t   !strncmp(info->params.host_bus_type, \"XPRS\", 4)) {\n\t\tp += scnprintf(p, left,\n\t\t\t     \"\\t%02x:%02x.%d  channel: %u\\n\",\n\t\t\t     info->params.interface_path.pci.bus,\n\t\t\t     info->params.interface_path.pci.slot,\n\t\t\t     info->params.interface_path.pci.function,\n\t\t\t     info->params.interface_path.pci.channel);\n\t} else if (!strncmp(info->params.host_bus_type, \"IBND\", 4) ||\n\t\t   !strncmp(info->params.host_bus_type, \"HTPT\", 4)) {\n\t\tp += scnprintf(p, left,\n\t\t\t     \"\\tTBD: %llx\\n\",\n\t\t\t     info->params.interface_path.ibnd.reserved);\n\n\t} else {\n\t\tp += scnprintf(p, left, \"\\tunknown: %llx\\n\",\n\t\t\t     info->params.interface_path.unknown.reserved);\n\t}\n\treturn (p - buf);\n}\n\nstatic ssize_t\nedd_show_interface(struct edd_device *edev, char *buf)\n{\n\tstruct edd_info *info;\n\tchar *p = buf;\n\tint i;\n\n\tif (!edev)\n\t\treturn -EINVAL;\n\tinfo = edd_dev_get_info(edev);\n\tif (!info || !buf)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (isprint(info->params.interface_type[i])) {\n\t\t\tp += scnprintf(p, left, \"%c\", info->params.interface_type[i]);\n\t\t} else {\n\t\t\tp += scnprintf(p, left, \" \");\n\t\t}\n\t}\n\tif (!strncmp(info->params.interface_type, \"ATAPI\", 5)) {\n\t\tp += scnprintf(p, left, \"\\tdevice: %u  lun: %u\\n\",\n\t\t\t     info->params.device_path.atapi.device,\n\t\t\t     info->params.device_path.atapi.lun);\n\t} else if (!strncmp(info->params.interface_type, \"ATA\", 3)) {\n\t\tp += scnprintf(p, left, \"\\tdevice: %u\\n\",\n\t\t\t     info->params.device_path.ata.device);\n\t} else if (!strncmp(info->params.interface_type, \"SCSI\", 4)) {\n\t\tp += scnprintf(p, left, \"\\tid: %u  lun: %llu\\n\",\n\t\t\t     info->params.device_path.scsi.id,\n\t\t\t     info->params.device_path.scsi.lun);\n\t} else if (!strncmp(info->params.interface_type, \"USB\", 3)) {\n\t\tp += scnprintf(p, left, \"\\tserial_number: %llx\\n\",\n\t\t\t     info->params.device_path.usb.serial_number);\n\t} else if (!strncmp(info->params.interface_type, \"1394\", 4)) {\n\t\tp += scnprintf(p, left, \"\\teui: %llx\\n\",\n\t\t\t     info->params.device_path.i1394.eui);\n\t} else if (!strncmp(info->params.interface_type, \"FIBRE\", 5)) {\n\t\tp += scnprintf(p, left, \"\\twwid: %llx lun: %llx\\n\",\n\t\t\t     info->params.device_path.fibre.wwid,\n\t\t\t     info->params.device_path.fibre.lun);\n\t} else if (!strncmp(info->params.interface_type, \"I2O\", 3)) {\n\t\tp += scnprintf(p, left, \"\\tidentity_tag: %llx\\n\",\n\t\t\t     info->params.device_path.i2o.identity_tag);\n\t} else if (!strncmp(info->params.interface_type, \"RAID\", 4)) {\n\t\tp += scnprintf(p, left, \"\\tidentity_tag: %x\\n\",\n\t\t\t     info->params.device_path.raid.array_number);\n\t} else if (!strncmp(info->params.interface_type, \"SATA\", 4)) {\n\t\tp += scnprintf(p, left, \"\\tdevice: %u\\n\",\n\t\t\t     info->params.device_path.sata.device);\n\t} else {\n\t\tp += scnprintf(p, left, \"\\tunknown: %llx %llx\\n\",\n\t\t\t     info->params.device_path.unknown.reserved1,\n\t\t\t     info->params.device_path.unknown.reserved2);\n\t}\n\n\treturn (p - buf);\n}\n\n \nstatic ssize_t\nedd_show_raw_data(struct edd_device *edev, char *buf)\n{\n\tstruct edd_info *info;\n\tssize_t len = sizeof (info->params);\n\tif (!edev)\n\t\treturn -EINVAL;\n\tinfo = edd_dev_get_info(edev);\n\tif (!info || !buf)\n\t\treturn -EINVAL;\n\n\tif (!(info->params.key == 0xBEDD || info->params.key == 0xDDBE))\n\t\tlen = info->params.length;\n\n\t \n\tif (len > (sizeof(info->params)))\n\t\tlen = sizeof(info->params);\n\n\tmemcpy(buf, &info->params, len);\n\treturn len;\n}\n\nstatic ssize_t\nedd_show_version(struct edd_device *edev, char *buf)\n{\n\tstruct edd_info *info;\n\tchar *p = buf;\n\tif (!edev)\n\t\treturn -EINVAL;\n\tinfo = edd_dev_get_info(edev);\n\tif (!info || !buf)\n\t\treturn -EINVAL;\n\n\tp += scnprintf(p, left, \"0x%02x\\n\", info->version);\n\treturn (p - buf);\n}\n\nstatic ssize_t\nedd_show_mbr_signature(struct edd_device *edev, char *buf)\n{\n\tchar *p = buf;\n\tp += scnprintf(p, left, \"0x%08x\\n\", edev->mbr_signature);\n\treturn (p - buf);\n}\n\nstatic ssize_t\nedd_show_extensions(struct edd_device *edev, char *buf)\n{\n\tstruct edd_info *info;\n\tchar *p = buf;\n\tif (!edev)\n\t\treturn -EINVAL;\n\tinfo = edd_dev_get_info(edev);\n\tif (!info || !buf)\n\t\treturn -EINVAL;\n\n\tif (info->interface_support & EDD_EXT_FIXED_DISK_ACCESS) {\n\t\tp += scnprintf(p, left, \"Fixed disk access\\n\");\n\t}\n\tif (info->interface_support & EDD_EXT_DEVICE_LOCKING_AND_EJECTING) {\n\t\tp += scnprintf(p, left, \"Device locking and ejecting\\n\");\n\t}\n\tif (info->interface_support & EDD_EXT_ENHANCED_DISK_DRIVE_SUPPORT) {\n\t\tp += scnprintf(p, left, \"Enhanced Disk Drive support\\n\");\n\t}\n\tif (info->interface_support & EDD_EXT_64BIT_EXTENSIONS) {\n\t\tp += scnprintf(p, left, \"64-bit extensions\\n\");\n\t}\n\treturn (p - buf);\n}\n\nstatic ssize_t\nedd_show_info_flags(struct edd_device *edev, char *buf)\n{\n\tstruct edd_info *info;\n\tchar *p = buf;\n\tif (!edev)\n\t\treturn -EINVAL;\n\tinfo = edd_dev_get_info(edev);\n\tif (!info || !buf)\n\t\treturn -EINVAL;\n\n\tif (info->params.info_flags & EDD_INFO_DMA_BOUNDARY_ERROR_TRANSPARENT)\n\t\tp += scnprintf(p, left, \"DMA boundary error transparent\\n\");\n\tif (info->params.info_flags & EDD_INFO_GEOMETRY_VALID)\n\t\tp += scnprintf(p, left, \"geometry valid\\n\");\n\tif (info->params.info_flags & EDD_INFO_REMOVABLE)\n\t\tp += scnprintf(p, left, \"removable\\n\");\n\tif (info->params.info_flags & EDD_INFO_WRITE_VERIFY)\n\t\tp += scnprintf(p, left, \"write verify\\n\");\n\tif (info->params.info_flags & EDD_INFO_MEDIA_CHANGE_NOTIFICATION)\n\t\tp += scnprintf(p, left, \"media change notification\\n\");\n\tif (info->params.info_flags & EDD_INFO_LOCKABLE)\n\t\tp += scnprintf(p, left, \"lockable\\n\");\n\tif (info->params.info_flags & EDD_INFO_NO_MEDIA_PRESENT)\n\t\tp += scnprintf(p, left, \"no media present\\n\");\n\tif (info->params.info_flags & EDD_INFO_USE_INT13_FN50)\n\t\tp += scnprintf(p, left, \"use int13 fn50\\n\");\n\treturn (p - buf);\n}\n\nstatic ssize_t\nedd_show_legacy_max_cylinder(struct edd_device *edev, char *buf)\n{\n\tstruct edd_info *info;\n\tchar *p = buf;\n\tif (!edev)\n\t\treturn -EINVAL;\n\tinfo = edd_dev_get_info(edev);\n\tif (!info || !buf)\n\t\treturn -EINVAL;\n\n\tp += scnprintf(p, left, \"%u\\n\", info->legacy_max_cylinder);\n\treturn (p - buf);\n}\n\nstatic ssize_t\nedd_show_legacy_max_head(struct edd_device *edev, char *buf)\n{\n\tstruct edd_info *info;\n\tchar *p = buf;\n\tif (!edev)\n\t\treturn -EINVAL;\n\tinfo = edd_dev_get_info(edev);\n\tif (!info || !buf)\n\t\treturn -EINVAL;\n\n\tp += scnprintf(p, left, \"%u\\n\", info->legacy_max_head);\n\treturn (p - buf);\n}\n\nstatic ssize_t\nedd_show_legacy_sectors_per_track(struct edd_device *edev, char *buf)\n{\n\tstruct edd_info *info;\n\tchar *p = buf;\n\tif (!edev)\n\t\treturn -EINVAL;\n\tinfo = edd_dev_get_info(edev);\n\tif (!info || !buf)\n\t\treturn -EINVAL;\n\n\tp += scnprintf(p, left, \"%u\\n\", info->legacy_sectors_per_track);\n\treturn (p - buf);\n}\n\nstatic ssize_t\nedd_show_default_cylinders(struct edd_device *edev, char *buf)\n{\n\tstruct edd_info *info;\n\tchar *p = buf;\n\tif (!edev)\n\t\treturn -EINVAL;\n\tinfo = edd_dev_get_info(edev);\n\tif (!info || !buf)\n\t\treturn -EINVAL;\n\n\tp += scnprintf(p, left, \"%u\\n\", info->params.num_default_cylinders);\n\treturn (p - buf);\n}\n\nstatic ssize_t\nedd_show_default_heads(struct edd_device *edev, char *buf)\n{\n\tstruct edd_info *info;\n\tchar *p = buf;\n\tif (!edev)\n\t\treturn -EINVAL;\n\tinfo = edd_dev_get_info(edev);\n\tif (!info || !buf)\n\t\treturn -EINVAL;\n\n\tp += scnprintf(p, left, \"%u\\n\", info->params.num_default_heads);\n\treturn (p - buf);\n}\n\nstatic ssize_t\nedd_show_default_sectors_per_track(struct edd_device *edev, char *buf)\n{\n\tstruct edd_info *info;\n\tchar *p = buf;\n\tif (!edev)\n\t\treturn -EINVAL;\n\tinfo = edd_dev_get_info(edev);\n\tif (!info || !buf)\n\t\treturn -EINVAL;\n\n\tp += scnprintf(p, left, \"%u\\n\", info->params.sectors_per_track);\n\treturn (p - buf);\n}\n\nstatic ssize_t\nedd_show_sectors(struct edd_device *edev, char *buf)\n{\n\tstruct edd_info *info;\n\tchar *p = buf;\n\tif (!edev)\n\t\treturn -EINVAL;\n\tinfo = edd_dev_get_info(edev);\n\tif (!info || !buf)\n\t\treturn -EINVAL;\n\n\tp += scnprintf(p, left, \"%llu\\n\", info->params.number_of_sectors);\n\treturn (p - buf);\n}\n\n\n \n\nstatic int\nedd_has_legacy_max_cylinder(struct edd_device *edev)\n{\n\tstruct edd_info *info;\n\tif (!edev)\n\t\treturn 0;\n\tinfo = edd_dev_get_info(edev);\n\tif (!info)\n\t\treturn 0;\n\treturn info->legacy_max_cylinder > 0;\n}\n\nstatic int\nedd_has_legacy_max_head(struct edd_device *edev)\n{\n\tstruct edd_info *info;\n\tif (!edev)\n\t\treturn 0;\n\tinfo = edd_dev_get_info(edev);\n\tif (!info)\n\t\treturn 0;\n\treturn info->legacy_max_head > 0;\n}\n\nstatic int\nedd_has_legacy_sectors_per_track(struct edd_device *edev)\n{\n\tstruct edd_info *info;\n\tif (!edev)\n\t\treturn 0;\n\tinfo = edd_dev_get_info(edev);\n\tif (!info)\n\t\treturn 0;\n\treturn info->legacy_sectors_per_track > 0;\n}\n\nstatic int\nedd_has_default_cylinders(struct edd_device *edev)\n{\n\tstruct edd_info *info;\n\tif (!edev)\n\t\treturn 0;\n\tinfo = edd_dev_get_info(edev);\n\tif (!info)\n\t\treturn 0;\n\treturn info->params.num_default_cylinders > 0;\n}\n\nstatic int\nedd_has_default_heads(struct edd_device *edev)\n{\n\tstruct edd_info *info;\n\tif (!edev)\n\t\treturn 0;\n\tinfo = edd_dev_get_info(edev);\n\tif (!info)\n\t\treturn 0;\n\treturn info->params.num_default_heads > 0;\n}\n\nstatic int\nedd_has_default_sectors_per_track(struct edd_device *edev)\n{\n\tstruct edd_info *info;\n\tif (!edev)\n\t\treturn 0;\n\tinfo = edd_dev_get_info(edev);\n\tif (!info)\n\t\treturn 0;\n\treturn info->params.sectors_per_track > 0;\n}\n\nstatic int\nedd_has_edd30(struct edd_device *edev)\n{\n\tstruct edd_info *info;\n\tint i;\n\tu8 csum = 0;\n\n\tif (!edev)\n\t\treturn 0;\n\tinfo = edd_dev_get_info(edev);\n\tif (!info)\n\t\treturn 0;\n\n\tif (!(info->params.key == 0xBEDD || info->params.key == 0xDDBE)) {\n\t\treturn 0;\n\t}\n\n\n\t \n\tif (info->params.device_path_info_length != 44)\n\t\treturn 0;\n\n\tfor (i = 30; i < info->params.device_path_info_length + 30; i++)\n\t\tcsum += *(((u8 *)&info->params) + i);\n\n\tif (csum)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n\nstatic EDD_DEVICE_ATTR(raw_data, 0444, edd_show_raw_data, edd_has_edd_info);\nstatic EDD_DEVICE_ATTR(version, 0444, edd_show_version, edd_has_edd_info);\nstatic EDD_DEVICE_ATTR(extensions, 0444, edd_show_extensions, edd_has_edd_info);\nstatic EDD_DEVICE_ATTR(info_flags, 0444, edd_show_info_flags, edd_has_edd_info);\nstatic EDD_DEVICE_ATTR(sectors, 0444, edd_show_sectors, edd_has_edd_info);\nstatic EDD_DEVICE_ATTR(legacy_max_cylinder, 0444,\n                       edd_show_legacy_max_cylinder,\n\t\t       edd_has_legacy_max_cylinder);\nstatic EDD_DEVICE_ATTR(legacy_max_head, 0444, edd_show_legacy_max_head,\n\t\t       edd_has_legacy_max_head);\nstatic EDD_DEVICE_ATTR(legacy_sectors_per_track, 0444,\n                       edd_show_legacy_sectors_per_track,\n\t\t       edd_has_legacy_sectors_per_track);\nstatic EDD_DEVICE_ATTR(default_cylinders, 0444, edd_show_default_cylinders,\n\t\t       edd_has_default_cylinders);\nstatic EDD_DEVICE_ATTR(default_heads, 0444, edd_show_default_heads,\n\t\t       edd_has_default_heads);\nstatic EDD_DEVICE_ATTR(default_sectors_per_track, 0444,\n\t\t       edd_show_default_sectors_per_track,\n\t\t       edd_has_default_sectors_per_track);\nstatic EDD_DEVICE_ATTR(interface, 0444, edd_show_interface, edd_has_edd30);\nstatic EDD_DEVICE_ATTR(host_bus, 0444, edd_show_host_bus, edd_has_edd30);\nstatic EDD_DEVICE_ATTR(mbr_signature, 0444, edd_show_mbr_signature, edd_has_mbr_signature);\n\n \nstatic struct edd_attribute * edd_attrs[] = {\n\t&edd_attr_raw_data,\n\t&edd_attr_version,\n\t&edd_attr_extensions,\n\t&edd_attr_info_flags,\n\t&edd_attr_sectors,\n\t&edd_attr_legacy_max_cylinder,\n\t&edd_attr_legacy_max_head,\n\t&edd_attr_legacy_sectors_per_track,\n\t&edd_attr_default_cylinders,\n\t&edd_attr_default_heads,\n\t&edd_attr_default_sectors_per_track,\n\t&edd_attr_interface,\n\t&edd_attr_host_bus,\n\t&edd_attr_mbr_signature,\n\tNULL,\n};\n\n \n\nstatic void edd_release(struct kobject * kobj)\n{\n\tstruct edd_device * dev = to_edd_device(kobj);\n\tkfree(dev);\n}\n\nstatic const struct kobj_type edd_ktype = {\n\t.release\t= edd_release,\n\t.sysfs_ops\t= &edd_attr_ops,\n};\n\nstatic struct kset *edd_kset;\n\n\n \nstatic int\nedd_dev_is_type(struct edd_device *edev, const char *type)\n{\n\tstruct edd_info *info;\n\tif (!edev)\n\t\treturn 0;\n\tinfo = edd_dev_get_info(edev);\n\n\tif (type && info) {\n\t\tif (!strncmp(info->params.host_bus_type, type, strlen(type)) ||\n\t\t    !strncmp(info->params.interface_type, type, strlen(type)))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic struct pci_dev *\nedd_get_pci_dev(struct edd_device *edev)\n{\n\tstruct edd_info *info = edd_dev_get_info(edev);\n\n\tif (edd_dev_is_type(edev, \"PCI\") || edd_dev_is_type(edev, \"XPRS\")) {\n\t\treturn pci_get_domain_bus_and_slot(0,\n\t\t\t\tinfo->params.interface_path.pci.bus,\n\t\t\t\tPCI_DEVFN(info->params.interface_path.pci.slot,\n\t\t\t\tinfo->params.interface_path.pci.function));\n\t}\n\treturn NULL;\n}\n\nstatic int\nedd_create_symlink_to_pcidev(struct edd_device *edev)\n{\n\n\tstruct pci_dev *pci_dev = edd_get_pci_dev(edev);\n\tint ret;\n\tif (!pci_dev)\n\t\treturn 1;\n\tret = sysfs_create_link(&edev->kobj,&pci_dev->dev.kobj,\"pci_dev\");\n\tpci_dev_put(pci_dev);\n\treturn ret;\n}\n\nstatic inline void\nedd_device_unregister(struct edd_device *edev)\n{\n\tkobject_put(&edev->kobj);\n}\n\nstatic void edd_populate_dir(struct edd_device * edev)\n{\n\tstruct edd_attribute * attr;\n\tint error = 0;\n\tint i;\n\n\tfor (i = 0; (attr = edd_attrs[i]) && !error; i++) {\n\t\tif (!attr->test || attr->test(edev))\n\t\t\terror = sysfs_create_file(&edev->kobj,&attr->attr);\n\t}\n\n\tif (!error) {\n\t\tedd_create_symlink_to_pcidev(edev);\n\t}\n}\n\nstatic int\nedd_device_register(struct edd_device *edev, int i)\n{\n\tint error;\n\n\tif (!edev)\n\t\treturn 1;\n\tedd_dev_set_info(edev, i);\n\tedev->kobj.kset = edd_kset;\n\terror = kobject_init_and_add(&edev->kobj, &edd_ktype, NULL,\n\t\t\t\t     \"int13_dev%02x\", 0x80 + i);\n\tif (!error) {\n\t\tedd_populate_dir(edev);\n\t\tkobject_uevent(&edev->kobj, KOBJ_ADD);\n\t}\n\treturn error;\n}\n\nstatic inline int edd_num_devices(void)\n{\n\treturn max_t(unsigned char,\n\t\t     min_t(unsigned char, EDD_MBR_SIG_MAX, edd.mbr_signature_nr),\n\t\t     min_t(unsigned char, EDDMAXNR, edd.edd_info_nr));\n}\n\n \nstatic int __init\nedd_init(void)\n{\n\tint i;\n\tint rc=0;\n\tstruct edd_device *edev;\n\n\tif (!edd_num_devices())\n\t\treturn -ENODEV;\n\n\tprintk(KERN_INFO \"BIOS EDD facility v%s %s, %d devices found\\n\",\n\t       EDD_VERSION, EDD_DATE, edd_num_devices());\n\n\tedd_kset = kset_create_and_add(\"edd\", NULL, firmware_kobj);\n\tif (!edd_kset)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < edd_num_devices(); i++) {\n\t\tedev = kzalloc(sizeof (*edev), GFP_KERNEL);\n\t\tif (!edev) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = edd_device_register(edev, i);\n\t\tif (rc) {\n\t\t\tkfree(edev);\n\t\t\tgoto out;\n\t\t}\n\t\tedd_devices[i] = edev;\n\t}\n\n\treturn 0;\n\nout:\n\twhile (--i >= 0)\n\t\tedd_device_unregister(edd_devices[i]);\n\tkset_unregister(edd_kset);\n\treturn rc;\n}\n\nstatic void __exit\nedd_exit(void)\n{\n\tint i;\n\tstruct edd_device *edev;\n\n\tfor (i = 0; i < edd_num_devices(); i++) {\n\t\tif ((edev = edd_devices[i]))\n\t\t\tedd_device_unregister(edev);\n\t}\n\tkset_unregister(edd_kset);\n}\n\nlate_initcall(edd_init);\nmodule_exit(edd_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}