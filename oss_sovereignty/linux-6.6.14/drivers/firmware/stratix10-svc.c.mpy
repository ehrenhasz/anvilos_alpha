{
  "module_name": "stratix10-svc.c",
  "hash_id": "725f059a4909f58052fce96846dc4675e26d06f35ff2eb36b03e2c3a321ab2d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/stratix10-svc.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/genalloc.h>\n#include <linux/io.h>\n#include <linux/kfifo.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/firmware/intel/stratix10-smc.h>\n#include <linux/firmware/intel/stratix10-svc-client.h>\n#include <linux/types.h>\n\n \n#define SVC_NUM_DATA_IN_FIFO\t\t\t32\n#define SVC_NUM_CHANNEL\t\t\t\t3\n#define FPGA_CONFIG_DATA_CLAIM_TIMEOUT_MS\t200\n#define FPGA_CONFIG_STATUS_TIMEOUT_SEC\t\t30\n#define BYTE_TO_WORD_SIZE              4\n\n \n#define STRATIX10_RSU\t\t\t\t\"stratix10-rsu\"\n#define INTEL_FCS\t\t\t\t\"intel-fcs\"\n\ntypedef void (svc_invoke_fn)(unsigned long, unsigned long, unsigned long,\n\t\t\t     unsigned long, unsigned long, unsigned long,\n\t\t\t     unsigned long, unsigned long,\n\t\t\t     struct arm_smccc_res *);\nstruct stratix10_svc_chan;\n\n \nstruct stratix10_svc {\n\tstruct platform_device *stratix10_svc_rsu;\n\tstruct platform_device *intel_svc_fcs;\n};\n\n \nstruct stratix10_svc_sh_memory {\n\tstruct completion sync_complete;\n\tunsigned long addr;\n\tunsigned long size;\n\tsvc_invoke_fn *invoke_fn;\n};\n\n \nstruct stratix10_svc_data_mem {\n\tvoid *vaddr;\n\tphys_addr_t paddr;\n\tsize_t size;\n\tstruct list_head node;\n};\n\n \nstruct stratix10_svc_data {\n\tstruct stratix10_svc_chan *chan;\n\tphys_addr_t paddr;\n\tsize_t size;\n\tphys_addr_t paddr_output;\n\tsize_t size_output;\n\tu32 command;\n\tu32 flag;\n\tu64 arg[3];\n};\n\n \nstruct stratix10_svc_controller {\n\tstruct device *dev;\n\tstruct stratix10_svc_chan *chans;\n\tint num_chans;\n\tint num_active_client;\n\tstruct list_head node;\n\tstruct gen_pool *genpool;\n\tstruct task_struct *task;\n\tstruct kfifo svc_fifo;\n\tstruct completion complete_status;\n\tspinlock_t svc_fifo_lock;\n\tsvc_invoke_fn *invoke_fn;\n};\n\n \nstruct stratix10_svc_chan {\n\tstruct stratix10_svc_controller *ctrl;\n\tstruct stratix10_svc_client *scl;\n\tchar *name;\n\tspinlock_t lock;\n};\n\nstatic LIST_HEAD(svc_ctrl);\nstatic LIST_HEAD(svc_data_mem);\n\n \nstatic void *svc_pa_to_va(unsigned long addr)\n{\n\tstruct stratix10_svc_data_mem *pmem;\n\n\tpr_debug(\"claim back P-addr=0x%016x\\n\", (unsigned int)addr);\n\tlist_for_each_entry(pmem, &svc_data_mem, node)\n\t\tif (pmem->paddr == addr)\n\t\t\treturn pmem->vaddr;\n\n\t \n\treturn NULL;\n}\n\n \nstatic void svc_thread_cmd_data_claim(struct stratix10_svc_controller *ctrl,\n\t\t\t\t      struct stratix10_svc_data *p_data,\n\t\t\t\t      struct stratix10_svc_cb_data *cb_data)\n{\n\tstruct arm_smccc_res res;\n\tunsigned long timeout;\n\n\treinit_completion(&ctrl->complete_status);\n\ttimeout = msecs_to_jiffies(FPGA_CONFIG_DATA_CLAIM_TIMEOUT_MS);\n\n\tpr_debug(\"%s: claim back the submitted buffer\\n\", __func__);\n\tdo {\n\t\tctrl->invoke_fn(INTEL_SIP_SMC_FPGA_CONFIG_COMPLETED_WRITE,\n\t\t\t\t0, 0, 0, 0, 0, 0, 0, &res);\n\n\t\tif (res.a0 == INTEL_SIP_SMC_STATUS_OK) {\n\t\t\tif (!res.a1) {\n\t\t\t\tcomplete(&ctrl->complete_status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_data->status = BIT(SVC_STATUS_BUFFER_DONE);\n\t\t\tcb_data->kaddr1 = svc_pa_to_va(res.a1);\n\t\t\tcb_data->kaddr2 = (res.a2) ?\n\t\t\t\t\t  svc_pa_to_va(res.a2) : NULL;\n\t\t\tcb_data->kaddr3 = (res.a3) ?\n\t\t\t\t\t  svc_pa_to_va(res.a3) : NULL;\n\t\t\tp_data->chan->scl->receive_cb(p_data->chan->scl,\n\t\t\t\t\t\t      cb_data);\n\t\t} else {\n\t\t\tpr_debug(\"%s: secure world busy, polling again\\n\",\n\t\t\t\t __func__);\n\t\t}\n\t} while (res.a0 == INTEL_SIP_SMC_STATUS_OK ||\n\t\t res.a0 == INTEL_SIP_SMC_STATUS_BUSY ||\n\t\t wait_for_completion_timeout(&ctrl->complete_status, timeout));\n}\n\n \nstatic void svc_thread_cmd_config_status(struct stratix10_svc_controller *ctrl,\n\t\t\t\t\t struct stratix10_svc_data *p_data,\n\t\t\t\t\t struct stratix10_svc_cb_data *cb_data)\n{\n\tstruct arm_smccc_res res;\n\tint count_in_sec;\n\tunsigned long a0, a1, a2;\n\n\tcb_data->kaddr1 = NULL;\n\tcb_data->kaddr2 = NULL;\n\tcb_data->kaddr3 = NULL;\n\tcb_data->status = BIT(SVC_STATUS_ERROR);\n\n\tpr_debug(\"%s: polling config status\\n\", __func__);\n\n\ta0 = INTEL_SIP_SMC_FPGA_CONFIG_ISDONE;\n\ta1 = (unsigned long)p_data->paddr;\n\ta2 = (unsigned long)p_data->size;\n\n\tif (p_data->command == COMMAND_POLL_SERVICE_STATUS)\n\t\ta0 = INTEL_SIP_SMC_SERVICE_COMPLETED;\n\n\tcount_in_sec = FPGA_CONFIG_STATUS_TIMEOUT_SEC;\n\twhile (count_in_sec) {\n\t\tctrl->invoke_fn(a0, a1, a2, 0, 0, 0, 0, 0, &res);\n\t\tif ((res.a0 == INTEL_SIP_SMC_STATUS_OK) ||\n\t\t    (res.a0 == INTEL_SIP_SMC_STATUS_ERROR) ||\n\t\t    (res.a0 == INTEL_SIP_SMC_STATUS_REJECTED))\n\t\t\tbreak;\n\n\t\t \n\t\tmsleep(1000);\n\t\tcount_in_sec--;\n\t}\n\n\tif (!count_in_sec) {\n\t\tpr_err(\"%s: poll status timeout\\n\", __func__);\n\t\tcb_data->status = BIT(SVC_STATUS_BUSY);\n\t} else if (res.a0 == INTEL_SIP_SMC_STATUS_OK) {\n\t\tcb_data->status = BIT(SVC_STATUS_COMPLETED);\n\t\tcb_data->kaddr2 = (res.a2) ?\n\t\t\t\t  svc_pa_to_va(res.a2) : NULL;\n\t\tcb_data->kaddr3 = (res.a3) ? &res.a3 : NULL;\n\t} else {\n\t\tpr_err(\"%s: poll status error\\n\", __func__);\n\t\tcb_data->kaddr1 = &res.a1;\n\t\tcb_data->kaddr2 = (res.a2) ?\n\t\t\t\t  svc_pa_to_va(res.a2) : NULL;\n\t\tcb_data->kaddr3 = (res.a3) ? &res.a3 : NULL;\n\t\tcb_data->status = BIT(SVC_STATUS_ERROR);\n\t}\n\n\tp_data->chan->scl->receive_cb(p_data->chan->scl, cb_data);\n}\n\n \nstatic void svc_thread_recv_status_ok(struct stratix10_svc_data *p_data,\n\t\t\t\t      struct stratix10_svc_cb_data *cb_data,\n\t\t\t\t      struct arm_smccc_res res)\n{\n\tcb_data->kaddr1 = NULL;\n\tcb_data->kaddr2 = NULL;\n\tcb_data->kaddr3 = NULL;\n\n\tswitch (p_data->command) {\n\tcase COMMAND_RECONFIG:\n\tcase COMMAND_RSU_UPDATE:\n\tcase COMMAND_RSU_NOTIFY:\n\tcase COMMAND_FCS_REQUEST_SERVICE:\n\tcase COMMAND_FCS_SEND_CERTIFICATE:\n\tcase COMMAND_FCS_DATA_ENCRYPTION:\n\tcase COMMAND_FCS_DATA_DECRYPTION:\n\t\tcb_data->status = BIT(SVC_STATUS_OK);\n\t\tbreak;\n\tcase COMMAND_RECONFIG_DATA_SUBMIT:\n\t\tcb_data->status = BIT(SVC_STATUS_BUFFER_SUBMITTED);\n\t\tbreak;\n\tcase COMMAND_RECONFIG_STATUS:\n\t\tcb_data->status = BIT(SVC_STATUS_COMPLETED);\n\t\tbreak;\n\tcase COMMAND_RSU_RETRY:\n\tcase COMMAND_RSU_MAX_RETRY:\n\tcase COMMAND_RSU_DCMF_STATUS:\n\tcase COMMAND_FIRMWARE_VERSION:\n\t\tcb_data->status = BIT(SVC_STATUS_OK);\n\t\tcb_data->kaddr1 = &res.a1;\n\t\tbreak;\n\tcase COMMAND_SMC_SVC_VERSION:\n\t\tcb_data->status = BIT(SVC_STATUS_OK);\n\t\tcb_data->kaddr1 = &res.a1;\n\t\tcb_data->kaddr2 = &res.a2;\n\t\tbreak;\n\tcase COMMAND_RSU_DCMF_VERSION:\n\t\tcb_data->status = BIT(SVC_STATUS_OK);\n\t\tcb_data->kaddr1 = &res.a1;\n\t\tcb_data->kaddr2 = &res.a2;\n\t\tbreak;\n\tcase COMMAND_FCS_RANDOM_NUMBER_GEN:\n\tcase COMMAND_FCS_GET_PROVISION_DATA:\n\tcase COMMAND_POLL_SERVICE_STATUS:\n\t\tcb_data->status = BIT(SVC_STATUS_OK);\n\t\tcb_data->kaddr1 = &res.a1;\n\t\tcb_data->kaddr2 = svc_pa_to_va(res.a2);\n\t\tcb_data->kaddr3 = &res.a3;\n\t\tbreak;\n\tcase COMMAND_MBOX_SEND_CMD:\n\t\tcb_data->status = BIT(SVC_STATUS_OK);\n\t\tcb_data->kaddr1 = &res.a1;\n\t\t \n\t\tres.a2 = res.a2 * BYTE_TO_WORD_SIZE;\n\t\tcb_data->kaddr2 = &res.a2;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"it shouldn't happen\\n\");\n\t\tbreak;\n\t}\n\n\tpr_debug(\"%s: call receive_cb\\n\", __func__);\n\tp_data->chan->scl->receive_cb(p_data->chan->scl, cb_data);\n}\n\n \nstatic int svc_normal_to_secure_thread(void *data)\n{\n\tstruct stratix10_svc_controller\n\t\t\t*ctrl = (struct stratix10_svc_controller *)data;\n\tstruct stratix10_svc_data *pdata;\n\tstruct stratix10_svc_cb_data *cbdata;\n\tstruct arm_smccc_res res;\n\tunsigned long a0, a1, a2, a3, a4, a5, a6, a7;\n\tint ret_fifo = 0;\n\n\tpdata =  kmalloc(sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tcbdata = kmalloc(sizeof(*cbdata), GFP_KERNEL);\n\tif (!cbdata) {\n\t\tkfree(pdata);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\ta0 = INTEL_SIP_SMC_FPGA_CONFIG_LOOPBACK;\n\ta1 = 0;\n\ta2 = 0;\n\ta3 = 0;\n\ta4 = 0;\n\ta5 = 0;\n\ta6 = 0;\n\ta7 = 0;\n\n\tpr_debug(\"smc_hvc_shm_thread is running\\n\");\n\n\twhile (!kthread_should_stop()) {\n\t\tret_fifo = kfifo_out_spinlocked(&ctrl->svc_fifo,\n\t\t\t\t\t\tpdata, sizeof(*pdata),\n\t\t\t\t\t\t&ctrl->svc_fifo_lock);\n\n\t\tif (!ret_fifo)\n\t\t\tcontinue;\n\n\t\tpr_debug(\"get from FIFO pa=0x%016x, command=%u, size=%u\\n\",\n\t\t\t (unsigned int)pdata->paddr, pdata->command,\n\t\t\t (unsigned int)pdata->size);\n\n\t\tswitch (pdata->command) {\n\t\tcase COMMAND_RECONFIG_DATA_CLAIM:\n\t\t\tsvc_thread_cmd_data_claim(ctrl, pdata, cbdata);\n\t\t\tcontinue;\n\t\tcase COMMAND_RECONFIG:\n\t\t\ta0 = INTEL_SIP_SMC_FPGA_CONFIG_START;\n\t\t\tpr_debug(\"conf_type=%u\\n\", (unsigned int)pdata->flag);\n\t\t\ta1 = pdata->flag;\n\t\t\ta2 = 0;\n\t\t\tbreak;\n\t\tcase COMMAND_RECONFIG_DATA_SUBMIT:\n\t\t\ta0 = INTEL_SIP_SMC_FPGA_CONFIG_WRITE;\n\t\t\ta1 = (unsigned long)pdata->paddr;\n\t\t\ta2 = (unsigned long)pdata->size;\n\t\t\tbreak;\n\t\tcase COMMAND_RECONFIG_STATUS:\n\t\t\ta0 = INTEL_SIP_SMC_FPGA_CONFIG_ISDONE;\n\t\t\ta1 = 0;\n\t\t\ta2 = 0;\n\t\t\tbreak;\n\t\tcase COMMAND_RSU_STATUS:\n\t\t\ta0 = INTEL_SIP_SMC_RSU_STATUS;\n\t\t\ta1 = 0;\n\t\t\ta2 = 0;\n\t\t\tbreak;\n\t\tcase COMMAND_RSU_UPDATE:\n\t\t\ta0 = INTEL_SIP_SMC_RSU_UPDATE;\n\t\t\ta1 = pdata->arg[0];\n\t\t\ta2 = 0;\n\t\t\tbreak;\n\t\tcase COMMAND_RSU_NOTIFY:\n\t\t\ta0 = INTEL_SIP_SMC_RSU_NOTIFY;\n\t\t\ta1 = pdata->arg[0];\n\t\t\ta2 = 0;\n\t\t\tbreak;\n\t\tcase COMMAND_RSU_RETRY:\n\t\t\ta0 = INTEL_SIP_SMC_RSU_RETRY_COUNTER;\n\t\t\ta1 = 0;\n\t\t\ta2 = 0;\n\t\t\tbreak;\n\t\tcase COMMAND_RSU_MAX_RETRY:\n\t\t\ta0 = INTEL_SIP_SMC_RSU_MAX_RETRY;\n\t\t\ta1 = 0;\n\t\t\ta2 = 0;\n\t\t\tbreak;\n\t\tcase COMMAND_RSU_DCMF_VERSION:\n\t\t\ta0 = INTEL_SIP_SMC_RSU_DCMF_VERSION;\n\t\t\ta1 = 0;\n\t\t\ta2 = 0;\n\t\t\tbreak;\n\t\tcase COMMAND_FIRMWARE_VERSION:\n\t\t\ta0 = INTEL_SIP_SMC_FIRMWARE_VERSION;\n\t\t\ta1 = 0;\n\t\t\ta2 = 0;\n\t\t\tbreak;\n\n\t\t \n\t\tcase COMMAND_FCS_DATA_ENCRYPTION:\n\t\t\ta0 = INTEL_SIP_SMC_FCS_CRYPTION;\n\t\t\ta1 = 1;\n\t\t\ta2 = (unsigned long)pdata->paddr;\n\t\t\ta3 = (unsigned long)pdata->size;\n\t\t\ta4 = (unsigned long)pdata->paddr_output;\n\t\t\ta5 = (unsigned long)pdata->size_output;\n\t\t\tbreak;\n\t\tcase COMMAND_FCS_DATA_DECRYPTION:\n\t\t\ta0 = INTEL_SIP_SMC_FCS_CRYPTION;\n\t\t\ta1 = 0;\n\t\t\ta2 = (unsigned long)pdata->paddr;\n\t\t\ta3 = (unsigned long)pdata->size;\n\t\t\ta4 = (unsigned long)pdata->paddr_output;\n\t\t\ta5 = (unsigned long)pdata->size_output;\n\t\t\tbreak;\n\t\tcase COMMAND_FCS_RANDOM_NUMBER_GEN:\n\t\t\ta0 = INTEL_SIP_SMC_FCS_RANDOM_NUMBER;\n\t\t\ta1 = (unsigned long)pdata->paddr;\n\t\t\ta2 = 0;\n\t\t\tbreak;\n\t\tcase COMMAND_FCS_REQUEST_SERVICE:\n\t\t\ta0 = INTEL_SIP_SMC_FCS_SERVICE_REQUEST;\n\t\t\ta1 = (unsigned long)pdata->paddr;\n\t\t\ta2 = (unsigned long)pdata->size;\n\t\t\tbreak;\n\t\tcase COMMAND_FCS_SEND_CERTIFICATE:\n\t\t\ta0 = INTEL_SIP_SMC_FCS_SEND_CERTIFICATE;\n\t\t\ta1 = (unsigned long)pdata->paddr;\n\t\t\ta2 = (unsigned long)pdata->size;\n\t\t\tbreak;\n\t\tcase COMMAND_FCS_GET_PROVISION_DATA:\n\t\t\ta0 = INTEL_SIP_SMC_FCS_GET_PROVISION_DATA;\n\t\t\ta1 = (unsigned long)pdata->paddr;\n\t\t\ta2 = 0;\n\t\t\tbreak;\n\n\t\t \n\t\tcase COMMAND_POLL_SERVICE_STATUS:\n\t\t\ta0 = INTEL_SIP_SMC_SERVICE_COMPLETED;\n\t\t\ta1 = (unsigned long)pdata->paddr;\n\t\t\ta2 = (unsigned long)pdata->size;\n\t\t\tbreak;\n\t\tcase COMMAND_RSU_DCMF_STATUS:\n\t\t\ta0 = INTEL_SIP_SMC_RSU_DCMF_STATUS;\n\t\t\ta1 = 0;\n\t\t\ta2 = 0;\n\t\t\tbreak;\n\t\tcase COMMAND_SMC_SVC_VERSION:\n\t\t\ta0 = INTEL_SIP_SMC_SVC_VERSION;\n\t\t\ta1 = 0;\n\t\t\ta2 = 0;\n\t\t\tbreak;\n\t\tcase COMMAND_MBOX_SEND_CMD:\n\t\t\ta0 = INTEL_SIP_SMC_MBOX_SEND_CMD;\n\t\t\ta1 = pdata->arg[0];\n\t\t\ta2 = (unsigned long)pdata->paddr;\n\t\t\ta3 = (unsigned long)pdata->size / BYTE_TO_WORD_SIZE;\n\t\t\ta4 = pdata->arg[1];\n\t\t\ta5 = (unsigned long)pdata->paddr_output;\n\t\t\ta6 = (unsigned long)pdata->size_output / BYTE_TO_WORD_SIZE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"it shouldn't happen\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tpr_debug(\"%s: before SMC call -- a0=0x%016x a1=0x%016x\",\n\t\t\t __func__,\n\t\t\t (unsigned int)a0,\n\t\t\t (unsigned int)a1);\n\t\tpr_debug(\" a2=0x%016x\\n\", (unsigned int)a2);\n\t\tpr_debug(\" a3=0x%016x\\n\", (unsigned int)a3);\n\t\tpr_debug(\" a4=0x%016x\\n\", (unsigned int)a4);\n\t\tpr_debug(\" a5=0x%016x\\n\", (unsigned int)a5);\n\t\tctrl->invoke_fn(a0, a1, a2, a3, a4, a5, a6, a7, &res);\n\n\t\tpr_debug(\"%s: after SMC call -- res.a0=0x%016x\",\n\t\t\t __func__, (unsigned int)res.a0);\n\t\tpr_debug(\" res.a1=0x%016x, res.a2=0x%016x\",\n\t\t\t (unsigned int)res.a1, (unsigned int)res.a2);\n\t\tpr_debug(\" res.a3=0x%016x\\n\", (unsigned int)res.a3);\n\n\t\tif (pdata->command == COMMAND_RSU_STATUS) {\n\t\t\tif (res.a0 == INTEL_SIP_SMC_RSU_ERROR)\n\t\t\t\tcbdata->status = BIT(SVC_STATUS_ERROR);\n\t\t\telse\n\t\t\t\tcbdata->status = BIT(SVC_STATUS_OK);\n\n\t\t\tcbdata->kaddr1 = &res;\n\t\t\tcbdata->kaddr2 = NULL;\n\t\t\tcbdata->kaddr3 = NULL;\n\t\t\tpdata->chan->scl->receive_cb(pdata->chan->scl, cbdata);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (res.a0) {\n\t\tcase INTEL_SIP_SMC_STATUS_OK:\n\t\t\tsvc_thread_recv_status_ok(pdata, cbdata, res);\n\t\t\tbreak;\n\t\tcase INTEL_SIP_SMC_STATUS_BUSY:\n\t\t\tswitch (pdata->command) {\n\t\t\tcase COMMAND_RECONFIG_DATA_SUBMIT:\n\t\t\t\tsvc_thread_cmd_data_claim(ctrl,\n\t\t\t\t\t\t\t  pdata, cbdata);\n\t\t\t\tbreak;\n\t\t\tcase COMMAND_RECONFIG_STATUS:\n\t\t\tcase COMMAND_POLL_SERVICE_STATUS:\n\t\t\t\tsvc_thread_cmd_config_status(ctrl,\n\t\t\t\t\t\t\t     pdata, cbdata);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"it shouldn't happen\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase INTEL_SIP_SMC_STATUS_REJECTED:\n\t\t\tpr_debug(\"%s: STATUS_REJECTED\\n\", __func__);\n\t\t\t \n\t\t\tswitch (pdata->command) {\n\t\t\tcase COMMAND_FCS_REQUEST_SERVICE:\n\t\t\tcase COMMAND_FCS_SEND_CERTIFICATE:\n\t\t\tcase COMMAND_FCS_GET_PROVISION_DATA:\n\t\t\tcase COMMAND_FCS_DATA_ENCRYPTION:\n\t\t\tcase COMMAND_FCS_DATA_DECRYPTION:\n\t\t\tcase COMMAND_FCS_RANDOM_NUMBER_GEN:\n\t\t\tcase COMMAND_MBOX_SEND_CMD:\n\t\t\t\tcbdata->status = BIT(SVC_STATUS_INVALID_PARAM);\n\t\t\t\tcbdata->kaddr1 = NULL;\n\t\t\t\tcbdata->kaddr2 = NULL;\n\t\t\t\tcbdata->kaddr3 = NULL;\n\t\t\t\tpdata->chan->scl->receive_cb(pdata->chan->scl,\n\t\t\t\t\t\t\t     cbdata);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase INTEL_SIP_SMC_STATUS_ERROR:\n\t\tcase INTEL_SIP_SMC_RSU_ERROR:\n\t\t\tpr_err(\"%s: STATUS_ERROR\\n\", __func__);\n\t\t\tcbdata->status = BIT(SVC_STATUS_ERROR);\n\t\t\tcbdata->kaddr1 = &res.a1;\n\t\t\tcbdata->kaddr2 = (res.a2) ?\n\t\t\t\tsvc_pa_to_va(res.a2) : NULL;\n\t\t\tcbdata->kaddr3 = (res.a3) ? &res.a3 : NULL;\n\t\t\tpdata->chan->scl->receive_cb(pdata->chan->scl, cbdata);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Secure firmware doesn't support...\\n\");\n\n\t\t\t \n\t\t\tif ((pdata->command != COMMAND_RSU_UPDATE) &&\n\t\t\t\t(pdata->command != COMMAND_RSU_STATUS)) {\n\t\t\t\tcbdata->status =\n\t\t\t\t\tBIT(SVC_STATUS_NO_SUPPORT);\n\t\t\t\tcbdata->kaddr1 = NULL;\n\t\t\t\tcbdata->kaddr2 = NULL;\n\t\t\t\tcbdata->kaddr3 = NULL;\n\t\t\t\tpdata->chan->scl->receive_cb(\n\t\t\t\t\tpdata->chan->scl, cbdata);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t}\n\t}\n\n\tkfree(cbdata);\n\tkfree(pdata);\n\n\treturn 0;\n}\n\n \nstatic int svc_normal_to_secure_shm_thread(void *data)\n{\n\tstruct stratix10_svc_sh_memory\n\t\t\t*sh_mem = (struct stratix10_svc_sh_memory *)data;\n\tstruct arm_smccc_res res;\n\n\t \n\tsh_mem->invoke_fn(INTEL_SIP_SMC_FPGA_CONFIG_GET_MEM,\n\t\t\t  0, 0, 0, 0, 0, 0, 0, &res);\n\tif (res.a0 == INTEL_SIP_SMC_STATUS_OK) {\n\t\tsh_mem->addr = res.a1;\n\t\tsh_mem->size = res.a2;\n\t} else {\n\t\tpr_err(\"%s: after SMC call -- res.a0=0x%016x\",  __func__,\n\t\t       (unsigned int)res.a0);\n\t\tsh_mem->addr = 0;\n\t\tsh_mem->size = 0;\n\t}\n\n\tcomplete(&sh_mem->sync_complete);\n\treturn 0;\n}\n\n \nstatic int svc_get_sh_memory(struct platform_device *pdev,\n\t\t\t\t    struct stratix10_svc_sh_memory *sh_memory)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct task_struct *sh_memory_task;\n\tunsigned int cpu = 0;\n\n\tinit_completion(&sh_memory->sync_complete);\n\n\t \n\tsh_memory_task = kthread_create_on_node(svc_normal_to_secure_shm_thread,\n\t\t\t\t\t       (void *)sh_memory,\n\t\t\t\t\t\tcpu_to_node(cpu),\n\t\t\t\t\t\t\"svc_smc_hvc_shm_thread\");\n\tif (IS_ERR(sh_memory_task)) {\n\t\tdev_err(dev, \"fail to create stratix10_svc_smc_shm_thread\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twake_up_process(sh_memory_task);\n\n\tif (!wait_for_completion_timeout(&sh_memory->sync_complete, 10 * HZ)) {\n\t\tdev_err(dev,\n\t\t\t\"timeout to get sh-memory paras from secure world\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (!sh_memory->addr || !sh_memory->size) {\n\t\tdev_err(dev,\n\t\t\t\"failed to get shared memory info from secure world\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdev_dbg(dev, \"SM software provides paddr: 0x%016x, size: 0x%08x\\n\",\n\t\t(unsigned int)sh_memory->addr,\n\t\t(unsigned int)sh_memory->size);\n\n\treturn 0;\n}\n\n \nstatic struct gen_pool *\nsvc_create_memory_pool(struct platform_device *pdev,\n\t\t       struct stratix10_svc_sh_memory *sh_memory)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct gen_pool *genpool;\n\tunsigned long vaddr;\n\tphys_addr_t paddr;\n\tsize_t size;\n\tphys_addr_t begin;\n\tphys_addr_t end;\n\tvoid *va;\n\tsize_t page_mask = PAGE_SIZE - 1;\n\tint min_alloc_order = 3;\n\tint ret;\n\n\tbegin = roundup(sh_memory->addr, PAGE_SIZE);\n\tend = rounddown(sh_memory->addr + sh_memory->size, PAGE_SIZE);\n\tpaddr = begin;\n\tsize = end - begin;\n\tva = devm_memremap(dev, paddr, size, MEMREMAP_WC);\n\tif (IS_ERR(va)) {\n\t\tdev_err(dev, \"fail to remap shared memory\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tvaddr = (unsigned long)va;\n\tdev_dbg(dev,\n\t\t\"reserved memory vaddr: %p, paddr: 0x%16x size: 0x%8x\\n\",\n\t\tva, (unsigned int)paddr, (unsigned int)size);\n\tif ((vaddr & page_mask) || (paddr & page_mask) ||\n\t    (size & page_mask)) {\n\t\tdev_err(dev, \"page is not aligned\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tgenpool = gen_pool_create(min_alloc_order, -1);\n\tif (!genpool) {\n\t\tdev_err(dev, \"fail to create genpool\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tgen_pool_set_algo(genpool, gen_pool_best_fit, NULL);\n\tret = gen_pool_add_virt(genpool, vaddr, paddr, size, -1);\n\tif (ret) {\n\t\tdev_err(dev, \"fail to add memory chunk to the pool\\n\");\n\t\tgen_pool_destroy(genpool);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn genpool;\n}\n\n \nstatic void svc_smccc_smc(unsigned long a0, unsigned long a1,\n\t\t\t  unsigned long a2, unsigned long a3,\n\t\t\t  unsigned long a4, unsigned long a5,\n\t\t\t  unsigned long a6, unsigned long a7,\n\t\t\t  struct arm_smccc_res *res)\n{\n\tarm_smccc_smc(a0, a1, a2, a3, a4, a5, a6, a7, res);\n}\n\n \nstatic void svc_smccc_hvc(unsigned long a0, unsigned long a1,\n\t\t\t  unsigned long a2, unsigned long a3,\n\t\t\t  unsigned long a4, unsigned long a5,\n\t\t\t  unsigned long a6, unsigned long a7,\n\t\t\t  struct arm_smccc_res *res)\n{\n\tarm_smccc_hvc(a0, a1, a2, a3, a4, a5, a6, a7, res);\n}\n\n \nstatic svc_invoke_fn *get_invoke_func(struct device *dev)\n{\n\tconst char *method;\n\n\tif (of_property_read_string(dev->of_node, \"method\", &method)) {\n\t\tdev_warn(dev, \"missing \\\"method\\\" property\\n\");\n\t\treturn ERR_PTR(-ENXIO);\n\t}\n\n\tif (!strcmp(method, \"smc\"))\n\t\treturn svc_smccc_smc;\n\tif (!strcmp(method, \"hvc\"))\n\t\treturn svc_smccc_hvc;\n\n\tdev_warn(dev, \"invalid \\\"method\\\" property: %s\\n\", method);\n\n\treturn ERR_PTR(-EINVAL);\n}\n\n \nstruct stratix10_svc_chan *stratix10_svc_request_channel_byname(\n\tstruct stratix10_svc_client *client, const char *name)\n{\n\tstruct device *dev = client->dev;\n\tstruct stratix10_svc_controller *controller;\n\tstruct stratix10_svc_chan *chan = NULL;\n\tunsigned long flag;\n\tint i;\n\n\t \n\tif (list_empty(&svc_ctrl))\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\tcontroller = list_first_entry(&svc_ctrl,\n\t\t\t\t      struct stratix10_svc_controller, node);\n\tfor (i = 0; i < SVC_NUM_CHANNEL; i++) {\n\t\tif (!strcmp(controller->chans[i].name, name)) {\n\t\t\tchan = &controller->chans[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (i == SVC_NUM_CHANNEL) {\n\t\tdev_err(dev, \"%s: channel not allocated\\n\", __func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (chan->scl || !try_module_get(controller->dev->driver->owner)) {\n\t\tdev_dbg(dev, \"%s: svc not free\\n\", __func__);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tspin_lock_irqsave(&chan->lock, flag);\n\tchan->scl = client;\n\tchan->ctrl->num_active_client++;\n\tspin_unlock_irqrestore(&chan->lock, flag);\n\n\treturn chan;\n}\nEXPORT_SYMBOL_GPL(stratix10_svc_request_channel_byname);\n\n \nvoid stratix10_svc_free_channel(struct stratix10_svc_chan *chan)\n{\n\tunsigned long flag;\n\n\tspin_lock_irqsave(&chan->lock, flag);\n\tchan->scl = NULL;\n\tchan->ctrl->num_active_client--;\n\tmodule_put(chan->ctrl->dev->driver->owner);\n\tspin_unlock_irqrestore(&chan->lock, flag);\n}\nEXPORT_SYMBOL_GPL(stratix10_svc_free_channel);\n\n \nint stratix10_svc_send(struct stratix10_svc_chan *chan, void *msg)\n{\n\tstruct stratix10_svc_client_msg\n\t\t*p_msg = (struct stratix10_svc_client_msg *)msg;\n\tstruct stratix10_svc_data_mem *p_mem;\n\tstruct stratix10_svc_data *p_data;\n\tint ret = 0;\n\tunsigned int cpu = 0;\n\n\tp_data = kzalloc(sizeof(*p_data), GFP_KERNEL);\n\tif (!p_data)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!chan->ctrl->task) {\n\t\tchan->ctrl->task =\n\t\t\tkthread_create_on_node(svc_normal_to_secure_thread,\n\t\t\t\t\t      (void *)chan->ctrl,\n\t\t\t\t\t      cpu_to_node(cpu),\n\t\t\t\t\t      \"svc_smc_hvc_thread\");\n\t\t\tif (IS_ERR(chan->ctrl->task)) {\n\t\t\t\tdev_err(chan->ctrl->dev,\n\t\t\t\t\t\"failed to create svc_smc_hvc_thread\\n\");\n\t\t\t\tkfree(p_data);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\tkthread_bind(chan->ctrl->task, cpu);\n\t\twake_up_process(chan->ctrl->task);\n\t}\n\n\tpr_debug(\"%s: sent P-va=%p, P-com=%x, P-size=%u\\n\", __func__,\n\t\t p_msg->payload, p_msg->command,\n\t\t (unsigned int)p_msg->payload_length);\n\n\tif (list_empty(&svc_data_mem)) {\n\t\tif (p_msg->command == COMMAND_RECONFIG) {\n\t\t\tstruct stratix10_svc_command_config_type *ct =\n\t\t\t\t(struct stratix10_svc_command_config_type *)\n\t\t\t\tp_msg->payload;\n\t\t\tp_data->flag = ct->flags;\n\t\t}\n\t} else {\n\t\tlist_for_each_entry(p_mem, &svc_data_mem, node)\n\t\t\tif (p_mem->vaddr == p_msg->payload) {\n\t\t\t\tp_data->paddr = p_mem->paddr;\n\t\t\t\tp_data->size = p_msg->payload_length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (p_msg->payload_output) {\n\t\t\tlist_for_each_entry(p_mem, &svc_data_mem, node)\n\t\t\t\tif (p_mem->vaddr == p_msg->payload_output) {\n\t\t\t\t\tp_data->paddr_output =\n\t\t\t\t\t\tp_mem->paddr;\n\t\t\t\t\tp_data->size_output =\n\t\t\t\t\t\tp_msg->payload_length_output;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n\n\tp_data->command = p_msg->command;\n\tp_data->arg[0] = p_msg->arg[0];\n\tp_data->arg[1] = p_msg->arg[1];\n\tp_data->arg[2] = p_msg->arg[2];\n\tp_data->size = p_msg->payload_length;\n\tp_data->chan = chan;\n\tpr_debug(\"%s: put to FIFO pa=0x%016x, cmd=%x, size=%u\\n\", __func__,\n\t       (unsigned int)p_data->paddr, p_data->command,\n\t       (unsigned int)p_data->size);\n\tret = kfifo_in_spinlocked(&chan->ctrl->svc_fifo, p_data,\n\t\t\t\t  sizeof(*p_data),\n\t\t\t\t  &chan->ctrl->svc_fifo_lock);\n\n\tkfree(p_data);\n\n\tif (!ret)\n\t\treturn -ENOBUFS;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(stratix10_svc_send);\n\n \nvoid stratix10_svc_done(struct stratix10_svc_chan *chan)\n{\n\t \n\tif (chan->ctrl->task && chan->ctrl->num_active_client <= 1) {\n\t\tpr_debug(\"svc_smc_hvc_shm_thread is stopped\\n\");\n\t\tkthread_stop(chan->ctrl->task);\n\t\tchan->ctrl->task = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(stratix10_svc_done);\n\n \nvoid *stratix10_svc_allocate_memory(struct stratix10_svc_chan *chan,\n\t\t\t\t    size_t size)\n{\n\tstruct stratix10_svc_data_mem *pmem;\n\tunsigned long va;\n\tphys_addr_t pa;\n\tstruct gen_pool *genpool = chan->ctrl->genpool;\n\tsize_t s = roundup(size, 1 << genpool->min_alloc_order);\n\n\tpmem = devm_kzalloc(chan->ctrl->dev, sizeof(*pmem), GFP_KERNEL);\n\tif (!pmem)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tva = gen_pool_alloc(genpool, s);\n\tif (!va)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemset((void *)va, 0, s);\n\tpa = gen_pool_virt_to_phys(genpool, va);\n\n\tpmem->vaddr = (void *)va;\n\tpmem->paddr = pa;\n\tpmem->size = s;\n\tlist_add_tail(&pmem->node, &svc_data_mem);\n\tpr_debug(\"%s: va=%p, pa=0x%016x\\n\", __func__,\n\t\t pmem->vaddr, (unsigned int)pmem->paddr);\n\n\treturn (void *)va;\n}\nEXPORT_SYMBOL_GPL(stratix10_svc_allocate_memory);\n\n \nvoid stratix10_svc_free_memory(struct stratix10_svc_chan *chan, void *kaddr)\n{\n\tstruct stratix10_svc_data_mem *pmem;\n\n\tlist_for_each_entry(pmem, &svc_data_mem, node)\n\t\tif (pmem->vaddr == kaddr) {\n\t\t\tgen_pool_free(chan->ctrl->genpool,\n\t\t\t\t       (unsigned long)kaddr, pmem->size);\n\t\t\tpmem->vaddr = NULL;\n\t\t\tlist_del(&pmem->node);\n\t\t\treturn;\n\t\t}\n\n\tlist_del(&svc_data_mem);\n}\nEXPORT_SYMBOL_GPL(stratix10_svc_free_memory);\n\nstatic const struct of_device_id stratix10_svc_drv_match[] = {\n\t{.compatible = \"intel,stratix10-svc\"},\n\t{.compatible = \"intel,agilex-svc\"},\n\t{},\n};\n\nstatic int stratix10_svc_drv_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct stratix10_svc_controller *controller;\n\tstruct stratix10_svc_chan *chans;\n\tstruct gen_pool *genpool;\n\tstruct stratix10_svc_sh_memory *sh_memory;\n\tstruct stratix10_svc *svc;\n\n\tsvc_invoke_fn *invoke_fn;\n\tsize_t fifo_size;\n\tint ret;\n\n\t \n\tinvoke_fn = get_invoke_func(dev);\n\tif (IS_ERR(invoke_fn))\n\t\treturn -EINVAL;\n\n\tsh_memory = devm_kzalloc(dev, sizeof(*sh_memory), GFP_KERNEL);\n\tif (!sh_memory)\n\t\treturn -ENOMEM;\n\n\tsh_memory->invoke_fn = invoke_fn;\n\tret = svc_get_sh_memory(pdev, sh_memory);\n\tif (ret)\n\t\treturn ret;\n\n\tgenpool = svc_create_memory_pool(pdev, sh_memory);\n\tif (IS_ERR(genpool))\n\t\treturn PTR_ERR(genpool);\n\n\t \n\tcontroller = devm_kzalloc(dev, sizeof(*controller), GFP_KERNEL);\n\tif (!controller) {\n\t\tret = -ENOMEM;\n\t\tgoto err_destroy_pool;\n\t}\n\n\tchans = devm_kmalloc_array(dev, SVC_NUM_CHANNEL,\n\t\t\t\t   sizeof(*chans), GFP_KERNEL | __GFP_ZERO);\n\tif (!chans) {\n\t\tret = -ENOMEM;\n\t\tgoto err_destroy_pool;\n\t}\n\n\tcontroller->dev = dev;\n\tcontroller->num_chans = SVC_NUM_CHANNEL;\n\tcontroller->num_active_client = 0;\n\tcontroller->chans = chans;\n\tcontroller->genpool = genpool;\n\tcontroller->task = NULL;\n\tcontroller->invoke_fn = invoke_fn;\n\tinit_completion(&controller->complete_status);\n\n\tfifo_size = sizeof(struct stratix10_svc_data) * SVC_NUM_DATA_IN_FIFO;\n\tret = kfifo_alloc(&controller->svc_fifo, fifo_size, GFP_KERNEL);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to allocate FIFO\\n\");\n\t\tgoto err_destroy_pool;\n\t}\n\tspin_lock_init(&controller->svc_fifo_lock);\n\n\tchans[0].scl = NULL;\n\tchans[0].ctrl = controller;\n\tchans[0].name = SVC_CLIENT_FPGA;\n\tspin_lock_init(&chans[0].lock);\n\n\tchans[1].scl = NULL;\n\tchans[1].ctrl = controller;\n\tchans[1].name = SVC_CLIENT_RSU;\n\tspin_lock_init(&chans[1].lock);\n\n\tchans[2].scl = NULL;\n\tchans[2].ctrl = controller;\n\tchans[2].name = SVC_CLIENT_FCS;\n\tspin_lock_init(&chans[2].lock);\n\n\tlist_add_tail(&controller->node, &svc_ctrl);\n\tplatform_set_drvdata(pdev, controller);\n\n\t \n\tsvc = devm_kzalloc(dev, sizeof(*svc), GFP_KERNEL);\n\tif (!svc) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_kfifo;\n\t}\n\n\tsvc->stratix10_svc_rsu = platform_device_alloc(STRATIX10_RSU, 0);\n\tif (!svc->stratix10_svc_rsu) {\n\t\tdev_err(dev, \"failed to allocate %s device\\n\", STRATIX10_RSU);\n\t\tret = -ENOMEM;\n\t\tgoto err_free_kfifo;\n\t}\n\n\tret = platform_device_add(svc->stratix10_svc_rsu);\n\tif (ret) {\n\t\tplatform_device_put(svc->stratix10_svc_rsu);\n\t\tgoto err_free_kfifo;\n\t}\n\n\tsvc->intel_svc_fcs = platform_device_alloc(INTEL_FCS, 1);\n\tif (!svc->intel_svc_fcs) {\n\t\tdev_err(dev, \"failed to allocate %s device\\n\", INTEL_FCS);\n\t\tret = -ENOMEM;\n\t\tgoto err_unregister_dev;\n\t}\n\n\tret = platform_device_add(svc->intel_svc_fcs);\n\tif (ret) {\n\t\tplatform_device_put(svc->intel_svc_fcs);\n\t\tgoto err_unregister_dev;\n\t}\n\n\tdev_set_drvdata(dev, svc);\n\n\tpr_info(\"Intel Service Layer Driver Initialized\\n\");\n\n\treturn 0;\n\nerr_unregister_dev:\n\tplatform_device_unregister(svc->stratix10_svc_rsu);\nerr_free_kfifo:\n\tkfifo_free(&controller->svc_fifo);\nerr_destroy_pool:\n\tgen_pool_destroy(genpool);\n\treturn ret;\n}\n\nstatic int stratix10_svc_drv_remove(struct platform_device *pdev)\n{\n\tstruct stratix10_svc *svc = dev_get_drvdata(&pdev->dev);\n\tstruct stratix10_svc_controller *ctrl = platform_get_drvdata(pdev);\n\n\tplatform_device_unregister(svc->intel_svc_fcs);\n\tplatform_device_unregister(svc->stratix10_svc_rsu);\n\n\tkfifo_free(&ctrl->svc_fifo);\n\tif (ctrl->task) {\n\t\tkthread_stop(ctrl->task);\n\t\tctrl->task = NULL;\n\t}\n\tif (ctrl->genpool)\n\t\tgen_pool_destroy(ctrl->genpool);\n\tlist_del(&ctrl->node);\n\n\treturn 0;\n}\n\nstatic struct platform_driver stratix10_svc_driver = {\n\t.probe = stratix10_svc_drv_probe,\n\t.remove = stratix10_svc_drv_remove,\n\t.driver = {\n\t\t.name = \"stratix10-svc\",\n\t\t.of_match_table = stratix10_svc_drv_match,\n\t},\n};\n\nstatic int __init stratix10_svc_init(void)\n{\n\tstruct device_node *fw_np;\n\tstruct device_node *np;\n\tint ret;\n\n\tfw_np = of_find_node_by_name(NULL, \"firmware\");\n\tif (!fw_np)\n\t\treturn -ENODEV;\n\n\tnp = of_find_matching_node(fw_np, stratix10_svc_drv_match);\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tof_node_put(np);\n\tret = of_platform_populate(fw_np, stratix10_svc_drv_match, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn platform_driver_register(&stratix10_svc_driver);\n}\n\nstatic void __exit stratix10_svc_exit(void)\n{\n\treturn platform_driver_unregister(&stratix10_svc_driver);\n}\n\nsubsys_initcall(stratix10_svc_init);\nmodule_exit(stratix10_svc_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel Stratix10 Service Layer Driver\");\nMODULE_AUTHOR(\"Richard Gong <richard.gong@intel.com>\");\nMODULE_ALIAS(\"platform:stratix10-svc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}