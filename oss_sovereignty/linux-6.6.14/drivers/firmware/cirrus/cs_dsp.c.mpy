{
  "module_name": "cs_dsp.c",
  "hash_id": "8905dc4593b7f461f417d00a6efa1ee4942e49201a29da4c19c39d0c1adacffa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/cirrus/cs_dsp.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\n#include <linux/firmware/cirrus/cs_dsp.h>\n#include <linux/firmware/cirrus/wmfw.h>\n\n#define cs_dsp_err(_dsp, fmt, ...) \\\n\tdev_err(_dsp->dev, \"%s: \" fmt, _dsp->name, ##__VA_ARGS__)\n#define cs_dsp_warn(_dsp, fmt, ...) \\\n\tdev_warn(_dsp->dev, \"%s: \" fmt, _dsp->name, ##__VA_ARGS__)\n#define cs_dsp_info(_dsp, fmt, ...) \\\n\tdev_info(_dsp->dev, \"%s: \" fmt, _dsp->name, ##__VA_ARGS__)\n#define cs_dsp_dbg(_dsp, fmt, ...) \\\n\tdev_dbg(_dsp->dev, \"%s: \" fmt, _dsp->name, ##__VA_ARGS__)\n\n#define ADSP1_CONTROL_1                   0x00\n#define ADSP1_CONTROL_2                   0x02\n#define ADSP1_CONTROL_3                   0x03\n#define ADSP1_CONTROL_4                   0x04\n#define ADSP1_CONTROL_5                   0x06\n#define ADSP1_CONTROL_6                   0x07\n#define ADSP1_CONTROL_7                   0x08\n#define ADSP1_CONTROL_8                   0x09\n#define ADSP1_CONTROL_9                   0x0A\n#define ADSP1_CONTROL_10                  0x0B\n#define ADSP1_CONTROL_11                  0x0C\n#define ADSP1_CONTROL_12                  0x0D\n#define ADSP1_CONTROL_13                  0x0F\n#define ADSP1_CONTROL_14                  0x10\n#define ADSP1_CONTROL_15                  0x11\n#define ADSP1_CONTROL_16                  0x12\n#define ADSP1_CONTROL_17                  0x13\n#define ADSP1_CONTROL_18                  0x14\n#define ADSP1_CONTROL_19                  0x16\n#define ADSP1_CONTROL_20                  0x17\n#define ADSP1_CONTROL_21                  0x18\n#define ADSP1_CONTROL_22                  0x1A\n#define ADSP1_CONTROL_23                  0x1B\n#define ADSP1_CONTROL_24                  0x1C\n#define ADSP1_CONTROL_25                  0x1E\n#define ADSP1_CONTROL_26                  0x20\n#define ADSP1_CONTROL_27                  0x21\n#define ADSP1_CONTROL_28                  0x22\n#define ADSP1_CONTROL_29                  0x23\n#define ADSP1_CONTROL_30                  0x24\n#define ADSP1_CONTROL_31                  0x26\n\n \n#define ADSP1_WDMA_BUFFER_LENGTH_MASK     0x00FF   \n#define ADSP1_WDMA_BUFFER_LENGTH_SHIFT         0   \n#define ADSP1_WDMA_BUFFER_LENGTH_WIDTH         8   \n\n \n#define ADSP1_DBG_CLK_ENA                 0x0008   \n#define ADSP1_DBG_CLK_ENA_MASK            0x0008   \n#define ADSP1_DBG_CLK_ENA_SHIFT                3   \n#define ADSP1_DBG_CLK_ENA_WIDTH                1   \n#define ADSP1_SYS_ENA                     0x0004   \n#define ADSP1_SYS_ENA_MASK                0x0004   \n#define ADSP1_SYS_ENA_SHIFT                    2   \n#define ADSP1_SYS_ENA_WIDTH                    1   \n#define ADSP1_CORE_ENA                    0x0002   \n#define ADSP1_CORE_ENA_MASK               0x0002   \n#define ADSP1_CORE_ENA_SHIFT                   1   \n#define ADSP1_CORE_ENA_WIDTH                   1   \n#define ADSP1_START                       0x0001   \n#define ADSP1_START_MASK                  0x0001   \n#define ADSP1_START_SHIFT                      0   \n#define ADSP1_START_WIDTH                      1   \n\n \n#define ADSP1_CLK_SEL_MASK                0x0007   \n#define ADSP1_CLK_SEL_SHIFT                    0   \n#define ADSP1_CLK_SEL_WIDTH                    3   \n\n#define ADSP2_CONTROL                     0x0\n#define ADSP2_CLOCKING                    0x1\n#define ADSP2V2_CLOCKING                  0x2\n#define ADSP2_STATUS1                     0x4\n#define ADSP2_WDMA_CONFIG_1               0x30\n#define ADSP2_WDMA_CONFIG_2               0x31\n#define ADSP2V2_WDMA_CONFIG_2             0x32\n#define ADSP2_RDMA_CONFIG_1               0x34\n\n#define ADSP2_SCRATCH0                    0x40\n#define ADSP2_SCRATCH1                    0x41\n#define ADSP2_SCRATCH2                    0x42\n#define ADSP2_SCRATCH3                    0x43\n\n#define ADSP2V2_SCRATCH0_1                0x40\n#define ADSP2V2_SCRATCH2_3                0x42\n\n \n#define ADSP2_MEM_ENA                     0x0010   \n#define ADSP2_MEM_ENA_MASK                0x0010   \n#define ADSP2_MEM_ENA_SHIFT                    4   \n#define ADSP2_MEM_ENA_WIDTH                    1   \n#define ADSP2_SYS_ENA                     0x0004   \n#define ADSP2_SYS_ENA_MASK                0x0004   \n#define ADSP2_SYS_ENA_SHIFT                    2   \n#define ADSP2_SYS_ENA_WIDTH                    1   \n#define ADSP2_CORE_ENA                    0x0002   \n#define ADSP2_CORE_ENA_MASK               0x0002   \n#define ADSP2_CORE_ENA_SHIFT                   1   \n#define ADSP2_CORE_ENA_WIDTH                   1   \n#define ADSP2_START                       0x0001   \n#define ADSP2_START_MASK                  0x0001   \n#define ADSP2_START_SHIFT                      0   \n#define ADSP2_START_WIDTH                      1   \n\n \n#define ADSP2_CLK_SEL_MASK                0x0007   \n#define ADSP2_CLK_SEL_SHIFT                    0   \n#define ADSP2_CLK_SEL_WIDTH                    3   \n\n \n#define ADSP2V2_CLK_SEL_MASK             0x70000   \n#define ADSP2V2_CLK_SEL_SHIFT                 16   \n#define ADSP2V2_CLK_SEL_WIDTH                  3   \n\n#define ADSP2V2_RATE_MASK                 0x7800   \n#define ADSP2V2_RATE_SHIFT                    11   \n#define ADSP2V2_RATE_WIDTH                     4   \n\n \n#define ADSP2_RAM_RDY                     0x0001\n#define ADSP2_RAM_RDY_MASK                0x0001\n#define ADSP2_RAM_RDY_SHIFT                    0\n#define ADSP2_RAM_RDY_WIDTH                    1\n\n \n#define ADSP2_LOCK_CODE_0                    0x5555\n#define ADSP2_LOCK_CODE_1                    0xAAAA\n\n#define ADSP2_WATCHDOG                       0x0A\n#define ADSP2_BUS_ERR_ADDR                   0x52\n#define ADSP2_REGION_LOCK_STATUS             0x64\n#define ADSP2_LOCK_REGION_1_LOCK_REGION_0    0x66\n#define ADSP2_LOCK_REGION_3_LOCK_REGION_2    0x68\n#define ADSP2_LOCK_REGION_5_LOCK_REGION_4    0x6A\n#define ADSP2_LOCK_REGION_7_LOCK_REGION_6    0x6C\n#define ADSP2_LOCK_REGION_9_LOCK_REGION_8    0x6E\n#define ADSP2_LOCK_REGION_CTRL               0x7A\n#define ADSP2_PMEM_ERR_ADDR_XMEM_ERR_ADDR    0x7C\n\n#define ADSP2_REGION_LOCK_ERR_MASK           0x8000\n#define ADSP2_ADDR_ERR_MASK                  0x4000\n#define ADSP2_WDT_TIMEOUT_STS_MASK           0x2000\n#define ADSP2_CTRL_ERR_PAUSE_ENA             0x0002\n#define ADSP2_CTRL_ERR_EINT                  0x0001\n\n#define ADSP2_BUS_ERR_ADDR_MASK              0x00FFFFFF\n#define ADSP2_XMEM_ERR_ADDR_MASK             0x0000FFFF\n#define ADSP2_PMEM_ERR_ADDR_MASK             0x7FFF0000\n#define ADSP2_PMEM_ERR_ADDR_SHIFT            16\n#define ADSP2_WDT_ENA_MASK                   0xFFFFFFFD\n\n#define ADSP2_LOCK_REGION_SHIFT              16\n\n \n#define CS_DSP_FW_EVENT_SHUTDOWN             0x000001\n\n \n#define HALO_AHBM_WINDOW_DEBUG_0             0x02040\n#define HALO_AHBM_WINDOW_DEBUG_1             0x02044\n\n \n#define HALO_SCRATCH1                        0x005c0\n#define HALO_SCRATCH2                        0x005c8\n#define HALO_SCRATCH3                        0x005d0\n#define HALO_SCRATCH4                        0x005d8\n#define HALO_CCM_CORE_CONTROL                0x41000\n#define HALO_CORE_SOFT_RESET                 0x00010\n#define HALO_WDT_CONTROL                     0x47000\n\n \n#define HALO_MPU_XMEM_ACCESS_0               0x43000\n#define HALO_MPU_YMEM_ACCESS_0               0x43004\n#define HALO_MPU_WINDOW_ACCESS_0             0x43008\n#define HALO_MPU_XREG_ACCESS_0               0x4300C\n#define HALO_MPU_YREG_ACCESS_0               0x43014\n#define HALO_MPU_XMEM_ACCESS_1               0x43018\n#define HALO_MPU_YMEM_ACCESS_1               0x4301C\n#define HALO_MPU_WINDOW_ACCESS_1             0x43020\n#define HALO_MPU_XREG_ACCESS_1               0x43024\n#define HALO_MPU_YREG_ACCESS_1               0x4302C\n#define HALO_MPU_XMEM_ACCESS_2               0x43030\n#define HALO_MPU_YMEM_ACCESS_2               0x43034\n#define HALO_MPU_WINDOW_ACCESS_2             0x43038\n#define HALO_MPU_XREG_ACCESS_2               0x4303C\n#define HALO_MPU_YREG_ACCESS_2               0x43044\n#define HALO_MPU_XMEM_ACCESS_3               0x43048\n#define HALO_MPU_YMEM_ACCESS_3               0x4304C\n#define HALO_MPU_WINDOW_ACCESS_3             0x43050\n#define HALO_MPU_XREG_ACCESS_3               0x43054\n#define HALO_MPU_YREG_ACCESS_3               0x4305C\n#define HALO_MPU_XM_VIO_ADDR                 0x43100\n#define HALO_MPU_XM_VIO_STATUS               0x43104\n#define HALO_MPU_YM_VIO_ADDR                 0x43108\n#define HALO_MPU_YM_VIO_STATUS               0x4310C\n#define HALO_MPU_PM_VIO_ADDR                 0x43110\n#define HALO_MPU_PM_VIO_STATUS               0x43114\n#define HALO_MPU_LOCK_CONFIG                 0x43140\n\n \n#define HALO_AHBM_CORE_ERR_ADDR_MASK         0x0fffff00\n#define HALO_AHBM_CORE_ERR_ADDR_SHIFT                 8\n#define HALO_AHBM_FLAGS_ERR_MASK             0x000000ff\n\n \n#define HALO_CORE_RESET                     0x00000200\n#define HALO_CORE_EN                        0x00000001\n\n \n#define HALO_CORE_SOFT_RESET_MASK           0x00000001\n\n \n#define HALO_WDT_EN_MASK                    0x00000001\n\n \n#define HALO_MPU_VIO_STS_MASK               0x007e0000\n#define HALO_MPU_VIO_STS_SHIFT                      17\n#define HALO_MPU_VIO_ERR_WR_MASK            0x00008000\n#define HALO_MPU_VIO_ERR_SRC_MASK           0x00007fff\n#define HALO_MPU_VIO_ERR_SRC_SHIFT                   0\n\nstruct cs_dsp_ops {\n\tbool (*validate_version)(struct cs_dsp *dsp, unsigned int version);\n\tunsigned int (*parse_sizes)(struct cs_dsp *dsp,\n\t\t\t\t    const char * const file,\n\t\t\t\t    unsigned int pos,\n\t\t\t\t    const struct firmware *firmware);\n\tint (*setup_algs)(struct cs_dsp *dsp);\n\tunsigned int (*region_to_reg)(struct cs_dsp_region const *mem,\n\t\t\t\t      unsigned int offset);\n\n\tvoid (*show_fw_status)(struct cs_dsp *dsp);\n\tvoid (*stop_watchdog)(struct cs_dsp *dsp);\n\n\tint (*enable_memory)(struct cs_dsp *dsp);\n\tvoid (*disable_memory)(struct cs_dsp *dsp);\n\tint (*lock_memory)(struct cs_dsp *dsp, unsigned int lock_regions);\n\n\tint (*enable_core)(struct cs_dsp *dsp);\n\tvoid (*disable_core)(struct cs_dsp *dsp);\n\n\tint (*start_core)(struct cs_dsp *dsp);\n\tvoid (*stop_core)(struct cs_dsp *dsp);\n};\n\nstatic const struct cs_dsp_ops cs_dsp_adsp1_ops;\nstatic const struct cs_dsp_ops cs_dsp_adsp2_ops[];\nstatic const struct cs_dsp_ops cs_dsp_halo_ops;\nstatic const struct cs_dsp_ops cs_dsp_halo_ao_ops;\n\nstruct cs_dsp_buf {\n\tstruct list_head list;\n\tvoid *buf;\n};\n\nstatic struct cs_dsp_buf *cs_dsp_buf_alloc(const void *src, size_t len,\n\t\t\t\t\t   struct list_head *list)\n{\n\tstruct cs_dsp_buf *buf = kzalloc(sizeof(*buf), GFP_KERNEL);\n\n\tif (buf == NULL)\n\t\treturn NULL;\n\n\tbuf->buf = vmalloc(len);\n\tif (!buf->buf) {\n\t\tkfree(buf);\n\t\treturn NULL;\n\t}\n\tmemcpy(buf->buf, src, len);\n\n\tif (list)\n\t\tlist_add_tail(&buf->list, list);\n\n\treturn buf;\n}\n\nstatic void cs_dsp_buf_free(struct list_head *list)\n{\n\twhile (!list_empty(list)) {\n\t\tstruct cs_dsp_buf *buf = list_first_entry(list,\n\t\t\t\t\t\t\t  struct cs_dsp_buf,\n\t\t\t\t\t\t\t  list);\n\t\tlist_del(&buf->list);\n\t\tvfree(buf->buf);\n\t\tkfree(buf);\n\t}\n}\n\n \nconst char *cs_dsp_mem_region_name(unsigned int type)\n{\n\tswitch (type) {\n\tcase WMFW_ADSP1_PM:\n\t\treturn \"PM\";\n\tcase WMFW_HALO_PM_PACKED:\n\t\treturn \"PM_PACKED\";\n\tcase WMFW_ADSP1_DM:\n\t\treturn \"DM\";\n\tcase WMFW_ADSP2_XM:\n\t\treturn \"XM\";\n\tcase WMFW_HALO_XM_PACKED:\n\t\treturn \"XM_PACKED\";\n\tcase WMFW_ADSP2_YM:\n\t\treturn \"YM\";\n\tcase WMFW_HALO_YM_PACKED:\n\t\treturn \"YM_PACKED\";\n\tcase WMFW_ADSP1_ZM:\n\t\treturn \"ZM\";\n\tdefault:\n\t\treturn NULL;\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_mem_region_name, FW_CS_DSP);\n\n#ifdef CONFIG_DEBUG_FS\nstatic void cs_dsp_debugfs_save_wmfwname(struct cs_dsp *dsp, const char *s)\n{\n\tchar *tmp = kasprintf(GFP_KERNEL, \"%s\\n\", s);\n\n\tkfree(dsp->wmfw_file_name);\n\tdsp->wmfw_file_name = tmp;\n}\n\nstatic void cs_dsp_debugfs_save_binname(struct cs_dsp *dsp, const char *s)\n{\n\tchar *tmp = kasprintf(GFP_KERNEL, \"%s\\n\", s);\n\n\tkfree(dsp->bin_file_name);\n\tdsp->bin_file_name = tmp;\n}\n\nstatic void cs_dsp_debugfs_clear(struct cs_dsp *dsp)\n{\n\tkfree(dsp->wmfw_file_name);\n\tkfree(dsp->bin_file_name);\n\tdsp->wmfw_file_name = NULL;\n\tdsp->bin_file_name = NULL;\n}\n\nstatic ssize_t cs_dsp_debugfs_wmfw_read(struct file *file,\n\t\t\t\t\tchar __user *user_buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct cs_dsp *dsp = file->private_data;\n\tssize_t ret;\n\n\tmutex_lock(&dsp->pwr_lock);\n\n\tif (!dsp->wmfw_file_name || !dsp->booted)\n\t\tret = 0;\n\telse\n\t\tret = simple_read_from_buffer(user_buf, count, ppos,\n\t\t\t\t\t      dsp->wmfw_file_name,\n\t\t\t\t\t      strlen(dsp->wmfw_file_name));\n\n\tmutex_unlock(&dsp->pwr_lock);\n\treturn ret;\n}\n\nstatic ssize_t cs_dsp_debugfs_bin_read(struct file *file,\n\t\t\t\t       char __user *user_buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct cs_dsp *dsp = file->private_data;\n\tssize_t ret;\n\n\tmutex_lock(&dsp->pwr_lock);\n\n\tif (!dsp->bin_file_name || !dsp->booted)\n\t\tret = 0;\n\telse\n\t\tret = simple_read_from_buffer(user_buf, count, ppos,\n\t\t\t\t\t      dsp->bin_file_name,\n\t\t\t\t\t      strlen(dsp->bin_file_name));\n\n\tmutex_unlock(&dsp->pwr_lock);\n\treturn ret;\n}\n\nstatic const struct {\n\tconst char *name;\n\tconst struct file_operations fops;\n} cs_dsp_debugfs_fops[] = {\n\t{\n\t\t.name = \"wmfw_file_name\",\n\t\t.fops = {\n\t\t\t.open = simple_open,\n\t\t\t.read = cs_dsp_debugfs_wmfw_read,\n\t\t},\n\t},\n\t{\n\t\t.name = \"bin_file_name\",\n\t\t.fops = {\n\t\t\t.open = simple_open,\n\t\t\t.read = cs_dsp_debugfs_bin_read,\n\t\t},\n\t},\n};\n\nstatic int cs_dsp_coeff_base_reg(struct cs_dsp_coeff_ctl *ctl, unsigned int *reg,\n\t\t\t\t unsigned int off);\n\nstatic int cs_dsp_debugfs_read_controls_show(struct seq_file *s, void *ignored)\n{\n\tstruct cs_dsp *dsp = s->private;\n\tstruct cs_dsp_coeff_ctl *ctl;\n\tunsigned int reg;\n\n\tlist_for_each_entry(ctl, &dsp->ctl_list, list) {\n\t\tcs_dsp_coeff_base_reg(ctl, &reg, 0);\n\t\tseq_printf(s, \"%22.*s: %#8zx %s:%08x %#8x %s %#8x %#4x %c%c%c%c %s %s\\n\",\n\t\t\t   ctl->subname_len, ctl->subname, ctl->len,\n\t\t\t   cs_dsp_mem_region_name(ctl->alg_region.type),\n\t\t\t   ctl->offset, reg, ctl->fw_name, ctl->alg_region.alg, ctl->type,\n\t\t\t   ctl->flags & WMFW_CTL_FLAG_VOLATILE ? 'V' : '-',\n\t\t\t   ctl->flags & WMFW_CTL_FLAG_SYS ? 'S' : '-',\n\t\t\t   ctl->flags & WMFW_CTL_FLAG_READABLE ? 'R' : '-',\n\t\t\t   ctl->flags & WMFW_CTL_FLAG_WRITEABLE ? 'W' : '-',\n\t\t\t   ctl->enabled ? \"enabled\" : \"disabled\",\n\t\t\t   ctl->set ? \"dirty\" : \"clean\");\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(cs_dsp_debugfs_read_controls);\n\n \nvoid cs_dsp_init_debugfs(struct cs_dsp *dsp, struct dentry *debugfs_root)\n{\n\tstruct dentry *root = NULL;\n\tint i;\n\n\troot = debugfs_create_dir(dsp->name, debugfs_root);\n\n\tdebugfs_create_bool(\"booted\", 0444, root, &dsp->booted);\n\tdebugfs_create_bool(\"running\", 0444, root, &dsp->running);\n\tdebugfs_create_x32(\"fw_id\", 0444, root, &dsp->fw_id);\n\tdebugfs_create_x32(\"fw_version\", 0444, root, &dsp->fw_id_version);\n\n\tfor (i = 0; i < ARRAY_SIZE(cs_dsp_debugfs_fops); ++i)\n\t\tdebugfs_create_file(cs_dsp_debugfs_fops[i].name, 0444, root,\n\t\t\t\t    dsp, &cs_dsp_debugfs_fops[i].fops);\n\n\tdebugfs_create_file(\"controls\", 0444, root, dsp,\n\t\t\t    &cs_dsp_debugfs_read_controls_fops);\n\n\tdsp->debugfs_root = root;\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_init_debugfs, FW_CS_DSP);\n\n \nvoid cs_dsp_cleanup_debugfs(struct cs_dsp *dsp)\n{\n\tcs_dsp_debugfs_clear(dsp);\n\tdebugfs_remove_recursive(dsp->debugfs_root);\n\tdsp->debugfs_root = NULL;\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_cleanup_debugfs, FW_CS_DSP);\n#else\nvoid cs_dsp_init_debugfs(struct cs_dsp *dsp, struct dentry *debugfs_root)\n{\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_init_debugfs, FW_CS_DSP);\n\nvoid cs_dsp_cleanup_debugfs(struct cs_dsp *dsp)\n{\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_cleanup_debugfs, FW_CS_DSP);\n\nstatic inline void cs_dsp_debugfs_save_wmfwname(struct cs_dsp *dsp,\n\t\t\t\t\t\tconst char *s)\n{\n}\n\nstatic inline void cs_dsp_debugfs_save_binname(struct cs_dsp *dsp,\n\t\t\t\t\t       const char *s)\n{\n}\n\nstatic inline void cs_dsp_debugfs_clear(struct cs_dsp *dsp)\n{\n}\n#endif\n\nstatic const struct cs_dsp_region *cs_dsp_find_region(struct cs_dsp *dsp,\n\t\t\t\t\t\t      int type)\n{\n\tint i;\n\n\tfor (i = 0; i < dsp->num_mems; i++)\n\t\tif (dsp->mem[i].type == type)\n\t\t\treturn &dsp->mem[i];\n\n\treturn NULL;\n}\n\nstatic unsigned int cs_dsp_region_to_reg(struct cs_dsp_region const *mem,\n\t\t\t\t\t unsigned int offset)\n{\n\tswitch (mem->type) {\n\tcase WMFW_ADSP1_PM:\n\t\treturn mem->base + (offset * 3);\n\tcase WMFW_ADSP1_DM:\n\tcase WMFW_ADSP2_XM:\n\tcase WMFW_ADSP2_YM:\n\tcase WMFW_ADSP1_ZM:\n\t\treturn mem->base + (offset * 2);\n\tdefault:\n\t\tWARN(1, \"Unknown memory region type\");\n\t\treturn offset;\n\t}\n}\n\nstatic unsigned int cs_dsp_halo_region_to_reg(struct cs_dsp_region const *mem,\n\t\t\t\t\t      unsigned int offset)\n{\n\tswitch (mem->type) {\n\tcase WMFW_ADSP2_XM:\n\tcase WMFW_ADSP2_YM:\n\t\treturn mem->base + (offset * 4);\n\tcase WMFW_HALO_XM_PACKED:\n\tcase WMFW_HALO_YM_PACKED:\n\t\treturn (mem->base + (offset * 3)) & ~0x3;\n\tcase WMFW_HALO_PM_PACKED:\n\t\treturn mem->base + (offset * 5);\n\tdefault:\n\t\tWARN(1, \"Unknown memory region type\");\n\t\treturn offset;\n\t}\n}\n\nstatic void cs_dsp_read_fw_status(struct cs_dsp *dsp,\n\t\t\t\t  int noffs, unsigned int *offs)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < noffs; ++i) {\n\t\tret = regmap_read(dsp->regmap, dsp->base + offs[i], &offs[i]);\n\t\tif (ret) {\n\t\t\tcs_dsp_err(dsp, \"Failed to read SCRATCH%u: %d\\n\", i, ret);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void cs_dsp_adsp2_show_fw_status(struct cs_dsp *dsp)\n{\n\tunsigned int offs[] = {\n\t\tADSP2_SCRATCH0, ADSP2_SCRATCH1, ADSP2_SCRATCH2, ADSP2_SCRATCH3,\n\t};\n\n\tcs_dsp_read_fw_status(dsp, ARRAY_SIZE(offs), offs);\n\n\tcs_dsp_dbg(dsp, \"FW SCRATCH 0:0x%x 1:0x%x 2:0x%x 3:0x%x\\n\",\n\t\t   offs[0], offs[1], offs[2], offs[3]);\n}\n\nstatic void cs_dsp_adsp2v2_show_fw_status(struct cs_dsp *dsp)\n{\n\tunsigned int offs[] = { ADSP2V2_SCRATCH0_1, ADSP2V2_SCRATCH2_3 };\n\n\tcs_dsp_read_fw_status(dsp, ARRAY_SIZE(offs), offs);\n\n\tcs_dsp_dbg(dsp, \"FW SCRATCH 0:0x%x 1:0x%x 2:0x%x 3:0x%x\\n\",\n\t\t   offs[0] & 0xFFFF, offs[0] >> 16,\n\t\t   offs[1] & 0xFFFF, offs[1] >> 16);\n}\n\nstatic void cs_dsp_halo_show_fw_status(struct cs_dsp *dsp)\n{\n\tunsigned int offs[] = {\n\t\tHALO_SCRATCH1, HALO_SCRATCH2, HALO_SCRATCH3, HALO_SCRATCH4,\n\t};\n\n\tcs_dsp_read_fw_status(dsp, ARRAY_SIZE(offs), offs);\n\n\tcs_dsp_dbg(dsp, \"FW SCRATCH 0:0x%x 1:0x%x 2:0x%x 3:0x%x\\n\",\n\t\t   offs[0], offs[1], offs[2], offs[3]);\n}\n\nstatic int cs_dsp_coeff_base_reg(struct cs_dsp_coeff_ctl *ctl, unsigned int *reg,\n\t\t\t\t unsigned int off)\n{\n\tconst struct cs_dsp_alg_region *alg_region = &ctl->alg_region;\n\tstruct cs_dsp *dsp = ctl->dsp;\n\tconst struct cs_dsp_region *mem;\n\n\tmem = cs_dsp_find_region(dsp, alg_region->type);\n\tif (!mem) {\n\t\tcs_dsp_err(dsp, \"No base for region %x\\n\",\n\t\t\t   alg_region->type);\n\t\treturn -EINVAL;\n\t}\n\n\t*reg = dsp->ops->region_to_reg(mem, ctl->alg_region.base + ctl->offset + off);\n\n\treturn 0;\n}\n\n \nint cs_dsp_coeff_write_acked_control(struct cs_dsp_coeff_ctl *ctl, unsigned int event_id)\n{\n\tstruct cs_dsp *dsp = ctl->dsp;\n\t__be32 val = cpu_to_be32(event_id);\n\tunsigned int reg;\n\tint i, ret;\n\n\tlockdep_assert_held(&dsp->pwr_lock);\n\n\tif (!dsp->running)\n\t\treturn -EPERM;\n\n\tret = cs_dsp_coeff_base_reg(ctl, &reg, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tcs_dsp_dbg(dsp, \"Sending 0x%x to acked control alg 0x%x %s:0x%x\\n\",\n\t\t   event_id, ctl->alg_region.alg,\n\t\t   cs_dsp_mem_region_name(ctl->alg_region.type), ctl->offset);\n\n\tret = regmap_raw_write(dsp->regmap, reg, &val, sizeof(val));\n\tif (ret) {\n\t\tcs_dsp_err(dsp, \"Failed to write %x: %d\\n\", reg, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < CS_DSP_ACKED_CTL_TIMEOUT_MS;) {\n\t\tswitch (i) {\n\t\tcase 0 ... CS_DSP_ACKED_CTL_N_QUICKPOLLS - 1:\n\t\t\tusleep_range(1000, 2000);\n\t\t\ti++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusleep_range(10000, 20000);\n\t\t\ti += 10;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = regmap_raw_read(dsp->regmap, reg, &val, sizeof(val));\n\t\tif (ret) {\n\t\t\tcs_dsp_err(dsp, \"Failed to read %x: %d\\n\", reg, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (val == 0) {\n\t\t\tcs_dsp_dbg(dsp, \"Acked control ACKED at poll %u\\n\", i);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcs_dsp_warn(dsp, \"Acked control @0x%x alg:0x%x %s:0x%x timed out\\n\",\n\t\t    reg, ctl->alg_region.alg,\n\t\t    cs_dsp_mem_region_name(ctl->alg_region.type),\n\t\t    ctl->offset);\n\n\treturn -ETIMEDOUT;\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_coeff_write_acked_control, FW_CS_DSP);\n\nstatic int cs_dsp_coeff_write_ctrl_raw(struct cs_dsp_coeff_ctl *ctl,\n\t\t\t\t       unsigned int off, const void *buf, size_t len)\n{\n\tstruct cs_dsp *dsp = ctl->dsp;\n\tvoid *scratch;\n\tint ret;\n\tunsigned int reg;\n\n\tret = cs_dsp_coeff_base_reg(ctl, &reg, off);\n\tif (ret)\n\t\treturn ret;\n\n\tscratch = kmemdup(buf, len, GFP_KERNEL | GFP_DMA);\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\tret = regmap_raw_write(dsp->regmap, reg, scratch,\n\t\t\t       len);\n\tif (ret) {\n\t\tcs_dsp_err(dsp, \"Failed to write %zu bytes to %x: %d\\n\",\n\t\t\t   len, reg, ret);\n\t\tkfree(scratch);\n\t\treturn ret;\n\t}\n\tcs_dsp_dbg(dsp, \"Wrote %zu bytes to %x\\n\", len, reg);\n\n\tkfree(scratch);\n\n\treturn 0;\n}\n\n \nint cs_dsp_coeff_write_ctrl(struct cs_dsp_coeff_ctl *ctl,\n\t\t\t    unsigned int off, const void *buf, size_t len)\n{\n\tint ret = 0;\n\n\tif (!ctl)\n\t\treturn -ENOENT;\n\n\tlockdep_assert_held(&ctl->dsp->pwr_lock);\n\n\tif (len + off * sizeof(u32) > ctl->len)\n\t\treturn -EINVAL;\n\n\tif (ctl->flags & WMFW_CTL_FLAG_VOLATILE) {\n\t\tret = -EPERM;\n\t} else if (buf != ctl->cache) {\n\t\tif (memcmp(ctl->cache + off * sizeof(u32), buf, len))\n\t\t\tmemcpy(ctl->cache + off * sizeof(u32), buf, len);\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tctl->set = 1;\n\tif (ctl->enabled && ctl->dsp->running)\n\t\tret = cs_dsp_coeff_write_ctrl_raw(ctl, off, buf, len);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 1;\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_coeff_write_ctrl, FW_CS_DSP);\n\nstatic int cs_dsp_coeff_read_ctrl_raw(struct cs_dsp_coeff_ctl *ctl,\n\t\t\t\t      unsigned int off, void *buf, size_t len)\n{\n\tstruct cs_dsp *dsp = ctl->dsp;\n\tvoid *scratch;\n\tint ret;\n\tunsigned int reg;\n\n\tret = cs_dsp_coeff_base_reg(ctl, &reg, off);\n\tif (ret)\n\t\treturn ret;\n\n\tscratch = kmalloc(len, GFP_KERNEL | GFP_DMA);\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\tret = regmap_raw_read(dsp->regmap, reg, scratch, len);\n\tif (ret) {\n\t\tcs_dsp_err(dsp, \"Failed to read %zu bytes from %x: %d\\n\",\n\t\t\t   len, reg, ret);\n\t\tkfree(scratch);\n\t\treturn ret;\n\t}\n\tcs_dsp_dbg(dsp, \"Read %zu bytes from %x\\n\", len, reg);\n\n\tmemcpy(buf, scratch, len);\n\tkfree(scratch);\n\n\treturn 0;\n}\n\n \nint cs_dsp_coeff_read_ctrl(struct cs_dsp_coeff_ctl *ctl,\n\t\t\t   unsigned int off, void *buf, size_t len)\n{\n\tint ret = 0;\n\n\tif (!ctl)\n\t\treturn -ENOENT;\n\n\tlockdep_assert_held(&ctl->dsp->pwr_lock);\n\n\tif (len + off * sizeof(u32) > ctl->len)\n\t\treturn -EINVAL;\n\n\tif (ctl->flags & WMFW_CTL_FLAG_VOLATILE) {\n\t\tif (ctl->enabled && ctl->dsp->running)\n\t\t\treturn cs_dsp_coeff_read_ctrl_raw(ctl, off, buf, len);\n\t\telse\n\t\t\treturn -EPERM;\n\t} else {\n\t\tif (!ctl->flags && ctl->enabled && ctl->dsp->running)\n\t\t\tret = cs_dsp_coeff_read_ctrl_raw(ctl, 0, ctl->cache, ctl->len);\n\n\t\tif (buf != ctl->cache)\n\t\t\tmemcpy(buf, ctl->cache + off * sizeof(u32), len);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_coeff_read_ctrl, FW_CS_DSP);\n\nstatic int cs_dsp_coeff_init_control_caches(struct cs_dsp *dsp)\n{\n\tstruct cs_dsp_coeff_ctl *ctl;\n\tint ret;\n\n\tlist_for_each_entry(ctl, &dsp->ctl_list, list) {\n\t\tif (!ctl->enabled || ctl->set)\n\t\t\tcontinue;\n\t\tif (ctl->flags & WMFW_CTL_FLAG_VOLATILE)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!ctl->flags || (ctl->flags & WMFW_CTL_FLAG_READABLE)) {\n\t\t\tret = cs_dsp_coeff_read_ctrl_raw(ctl, 0, ctl->cache, ctl->len);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cs_dsp_coeff_sync_controls(struct cs_dsp *dsp)\n{\n\tstruct cs_dsp_coeff_ctl *ctl;\n\tint ret;\n\n\tlist_for_each_entry(ctl, &dsp->ctl_list, list) {\n\t\tif (!ctl->enabled)\n\t\t\tcontinue;\n\t\tif (ctl->set && !(ctl->flags & WMFW_CTL_FLAG_VOLATILE)) {\n\t\t\tret = cs_dsp_coeff_write_ctrl_raw(ctl, 0, ctl->cache,\n\t\t\t\t\t\t\t  ctl->len);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void cs_dsp_signal_event_controls(struct cs_dsp *dsp,\n\t\t\t\t\t unsigned int event)\n{\n\tstruct cs_dsp_coeff_ctl *ctl;\n\tint ret;\n\n\tlist_for_each_entry(ctl, &dsp->ctl_list, list) {\n\t\tif (ctl->type != WMFW_CTL_TYPE_HOSTEVENT)\n\t\t\tcontinue;\n\n\t\tif (!ctl->enabled)\n\t\t\tcontinue;\n\n\t\tret = cs_dsp_coeff_write_acked_control(ctl, event);\n\t\tif (ret)\n\t\t\tcs_dsp_warn(dsp,\n\t\t\t\t    \"Failed to send 0x%x event to alg 0x%x (%d)\\n\",\n\t\t\t\t    event, ctl->alg_region.alg, ret);\n\t}\n}\n\nstatic void cs_dsp_free_ctl_blk(struct cs_dsp_coeff_ctl *ctl)\n{\n\tkfree(ctl->cache);\n\tkfree(ctl->subname);\n\tkfree(ctl);\n}\n\nstatic int cs_dsp_create_control(struct cs_dsp *dsp,\n\t\t\t\t const struct cs_dsp_alg_region *alg_region,\n\t\t\t\t unsigned int offset, unsigned int len,\n\t\t\t\t const char *subname, unsigned int subname_len,\n\t\t\t\t unsigned int flags, unsigned int type)\n{\n\tstruct cs_dsp_coeff_ctl *ctl;\n\tint ret;\n\n\tlist_for_each_entry(ctl, &dsp->ctl_list, list) {\n\t\tif (ctl->fw_name == dsp->fw_name &&\n\t\t    ctl->alg_region.alg == alg_region->alg &&\n\t\t    ctl->alg_region.type == alg_region->type) {\n\t\t\tif ((!subname && !ctl->subname) ||\n\t\t\t    (subname && (ctl->subname_len == subname_len) &&\n\t\t\t     !strncmp(ctl->subname, subname, ctl->subname_len))) {\n\t\t\t\tif (!ctl->enabled)\n\t\t\t\t\tctl->enabled = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tctl = kzalloc(sizeof(*ctl), GFP_KERNEL);\n\tif (!ctl)\n\t\treturn -ENOMEM;\n\n\tctl->fw_name = dsp->fw_name;\n\tctl->alg_region = *alg_region;\n\tif (subname && dsp->fw_ver >= 2) {\n\t\tctl->subname_len = subname_len;\n\t\tctl->subname = kasprintf(GFP_KERNEL, \"%.*s\", subname_len, subname);\n\t\tif (!ctl->subname) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_ctl;\n\t\t}\n\t}\n\tctl->enabled = 1;\n\tctl->set = 0;\n\tctl->dsp = dsp;\n\n\tctl->flags = flags;\n\tctl->type = type;\n\tctl->offset = offset;\n\tctl->len = len;\n\tctl->cache = kzalloc(ctl->len, GFP_KERNEL);\n\tif (!ctl->cache) {\n\t\tret = -ENOMEM;\n\t\tgoto err_ctl_subname;\n\t}\n\n\tlist_add(&ctl->list, &dsp->ctl_list);\n\n\tif (dsp->client_ops->control_add) {\n\t\tret = dsp->client_ops->control_add(ctl);\n\t\tif (ret)\n\t\t\tgoto err_list_del;\n\t}\n\n\treturn 0;\n\nerr_list_del:\n\tlist_del(&ctl->list);\n\tkfree(ctl->cache);\nerr_ctl_subname:\n\tkfree(ctl->subname);\nerr_ctl:\n\tkfree(ctl);\n\n\treturn ret;\n}\n\nstruct cs_dsp_coeff_parsed_alg {\n\tint id;\n\tconst u8 *name;\n\tint name_len;\n\tint ncoeff;\n};\n\nstruct cs_dsp_coeff_parsed_coeff {\n\tint offset;\n\tint mem_type;\n\tconst u8 *name;\n\tint name_len;\n\tunsigned int ctl_type;\n\tint flags;\n\tint len;\n};\n\nstatic int cs_dsp_coeff_parse_string(int bytes, const u8 **pos, const u8 **str)\n{\n\tint length;\n\n\tswitch (bytes) {\n\tcase 1:\n\t\tlength = **pos;\n\t\tbreak;\n\tcase 2:\n\t\tlength = le16_to_cpu(*((__le16 *)*pos));\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (str)\n\t\t*str = *pos + bytes;\n\n\t*pos += ((length + bytes) + 3) & ~0x03;\n\n\treturn length;\n}\n\nstatic int cs_dsp_coeff_parse_int(int bytes, const u8 **pos)\n{\n\tint val = 0;\n\n\tswitch (bytes) {\n\tcase 2:\n\t\tval = le16_to_cpu(*((__le16 *)*pos));\n\t\tbreak;\n\tcase 4:\n\t\tval = le32_to_cpu(*((__le32 *)*pos));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t*pos += bytes;\n\n\treturn val;\n}\n\nstatic inline void cs_dsp_coeff_parse_alg(struct cs_dsp *dsp, const u8 **data,\n\t\t\t\t\t  struct cs_dsp_coeff_parsed_alg *blk)\n{\n\tconst struct wmfw_adsp_alg_data *raw;\n\n\tswitch (dsp->fw_ver) {\n\tcase 0:\n\tcase 1:\n\t\traw = (const struct wmfw_adsp_alg_data *)*data;\n\t\t*data = raw->data;\n\n\t\tblk->id = le32_to_cpu(raw->id);\n\t\tblk->name = raw->name;\n\t\tblk->name_len = strlen(raw->name);\n\t\tblk->ncoeff = le32_to_cpu(raw->ncoeff);\n\t\tbreak;\n\tdefault:\n\t\tblk->id = cs_dsp_coeff_parse_int(sizeof(raw->id), data);\n\t\tblk->name_len = cs_dsp_coeff_parse_string(sizeof(u8), data,\n\t\t\t\t\t\t\t  &blk->name);\n\t\tcs_dsp_coeff_parse_string(sizeof(u16), data, NULL);\n\t\tblk->ncoeff = cs_dsp_coeff_parse_int(sizeof(raw->ncoeff), data);\n\t\tbreak;\n\t}\n\n\tcs_dsp_dbg(dsp, \"Algorithm ID: %#x\\n\", blk->id);\n\tcs_dsp_dbg(dsp, \"Algorithm name: %.*s\\n\", blk->name_len, blk->name);\n\tcs_dsp_dbg(dsp, \"# of coefficient descriptors: %#x\\n\", blk->ncoeff);\n}\n\nstatic inline void cs_dsp_coeff_parse_coeff(struct cs_dsp *dsp, const u8 **data,\n\t\t\t\t\t    struct cs_dsp_coeff_parsed_coeff *blk)\n{\n\tconst struct wmfw_adsp_coeff_data *raw;\n\tconst u8 *tmp;\n\tint length;\n\n\tswitch (dsp->fw_ver) {\n\tcase 0:\n\tcase 1:\n\t\traw = (const struct wmfw_adsp_coeff_data *)*data;\n\t\t*data = *data + sizeof(raw->hdr) + le32_to_cpu(raw->hdr.size);\n\n\t\tblk->offset = le16_to_cpu(raw->hdr.offset);\n\t\tblk->mem_type = le16_to_cpu(raw->hdr.type);\n\t\tblk->name = raw->name;\n\t\tblk->name_len = strlen(raw->name);\n\t\tblk->ctl_type = le16_to_cpu(raw->ctl_type);\n\t\tblk->flags = le16_to_cpu(raw->flags);\n\t\tblk->len = le32_to_cpu(raw->len);\n\t\tbreak;\n\tdefault:\n\t\ttmp = *data;\n\t\tblk->offset = cs_dsp_coeff_parse_int(sizeof(raw->hdr.offset), &tmp);\n\t\tblk->mem_type = cs_dsp_coeff_parse_int(sizeof(raw->hdr.type), &tmp);\n\t\tlength = cs_dsp_coeff_parse_int(sizeof(raw->hdr.size), &tmp);\n\t\tblk->name_len = cs_dsp_coeff_parse_string(sizeof(u8), &tmp,\n\t\t\t\t\t\t\t  &blk->name);\n\t\tcs_dsp_coeff_parse_string(sizeof(u8), &tmp, NULL);\n\t\tcs_dsp_coeff_parse_string(sizeof(u16), &tmp, NULL);\n\t\tblk->ctl_type = cs_dsp_coeff_parse_int(sizeof(raw->ctl_type), &tmp);\n\t\tblk->flags = cs_dsp_coeff_parse_int(sizeof(raw->flags), &tmp);\n\t\tblk->len = cs_dsp_coeff_parse_int(sizeof(raw->len), &tmp);\n\n\t\t*data = *data + sizeof(raw->hdr) + length;\n\t\tbreak;\n\t}\n\n\tcs_dsp_dbg(dsp, \"\\tCoefficient type: %#x\\n\", blk->mem_type);\n\tcs_dsp_dbg(dsp, \"\\tCoefficient offset: %#x\\n\", blk->offset);\n\tcs_dsp_dbg(dsp, \"\\tCoefficient name: %.*s\\n\", blk->name_len, blk->name);\n\tcs_dsp_dbg(dsp, \"\\tCoefficient flags: %#x\\n\", blk->flags);\n\tcs_dsp_dbg(dsp, \"\\tALSA control type: %#x\\n\", blk->ctl_type);\n\tcs_dsp_dbg(dsp, \"\\tALSA control len: %#x\\n\", blk->len);\n}\n\nstatic int cs_dsp_check_coeff_flags(struct cs_dsp *dsp,\n\t\t\t\t    const struct cs_dsp_coeff_parsed_coeff *coeff_blk,\n\t\t\t\t    unsigned int f_required,\n\t\t\t\t    unsigned int f_illegal)\n{\n\tif ((coeff_blk->flags & f_illegal) ||\n\t    ((coeff_blk->flags & f_required) != f_required)) {\n\t\tcs_dsp_err(dsp, \"Illegal flags 0x%x for control type 0x%x\\n\",\n\t\t\t   coeff_blk->flags, coeff_blk->ctl_type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs_dsp_parse_coeff(struct cs_dsp *dsp,\n\t\t\t      const struct wmfw_region *region)\n{\n\tstruct cs_dsp_alg_region alg_region = {};\n\tstruct cs_dsp_coeff_parsed_alg alg_blk;\n\tstruct cs_dsp_coeff_parsed_coeff coeff_blk;\n\tconst u8 *data = region->data;\n\tint i, ret;\n\n\tcs_dsp_coeff_parse_alg(dsp, &data, &alg_blk);\n\tfor (i = 0; i < alg_blk.ncoeff; i++) {\n\t\tcs_dsp_coeff_parse_coeff(dsp, &data, &coeff_blk);\n\n\t\tswitch (coeff_blk.ctl_type) {\n\t\tcase WMFW_CTL_TYPE_BYTES:\n\t\t\tbreak;\n\t\tcase WMFW_CTL_TYPE_ACKED:\n\t\t\tif (coeff_blk.flags & WMFW_CTL_FLAG_SYS)\n\t\t\t\tcontinue;\t \n\n\t\t\tret = cs_dsp_check_coeff_flags(dsp, &coeff_blk,\n\t\t\t\t\t\t       WMFW_CTL_FLAG_VOLATILE |\n\t\t\t\t\t\t       WMFW_CTL_FLAG_WRITEABLE |\n\t\t\t\t\t\t       WMFW_CTL_FLAG_READABLE,\n\t\t\t\t\t\t       0);\n\t\t\tif (ret)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase WMFW_CTL_TYPE_HOSTEVENT:\n\t\tcase WMFW_CTL_TYPE_FWEVENT:\n\t\t\tret = cs_dsp_check_coeff_flags(dsp, &coeff_blk,\n\t\t\t\t\t\t       WMFW_CTL_FLAG_SYS |\n\t\t\t\t\t\t       WMFW_CTL_FLAG_VOLATILE |\n\t\t\t\t\t\t       WMFW_CTL_FLAG_WRITEABLE |\n\t\t\t\t\t\t       WMFW_CTL_FLAG_READABLE,\n\t\t\t\t\t\t       0);\n\t\t\tif (ret)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase WMFW_CTL_TYPE_HOST_BUFFER:\n\t\t\tret = cs_dsp_check_coeff_flags(dsp, &coeff_blk,\n\t\t\t\t\t\t       WMFW_CTL_FLAG_SYS |\n\t\t\t\t\t\t       WMFW_CTL_FLAG_VOLATILE |\n\t\t\t\t\t\t       WMFW_CTL_FLAG_READABLE,\n\t\t\t\t\t\t       0);\n\t\t\tif (ret)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcs_dsp_err(dsp, \"Unknown control type: %d\\n\",\n\t\t\t\t   coeff_blk.ctl_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\talg_region.type = coeff_blk.mem_type;\n\t\talg_region.alg = alg_blk.id;\n\n\t\tret = cs_dsp_create_control(dsp, &alg_region,\n\t\t\t\t\t    coeff_blk.offset,\n\t\t\t\t\t    coeff_blk.len,\n\t\t\t\t\t    coeff_blk.name,\n\t\t\t\t\t    coeff_blk.name_len,\n\t\t\t\t\t    coeff_blk.flags,\n\t\t\t\t\t    coeff_blk.ctl_type);\n\t\tif (ret < 0)\n\t\t\tcs_dsp_err(dsp, \"Failed to create control: %.*s, %d\\n\",\n\t\t\t\t   coeff_blk.name_len, coeff_blk.name, ret);\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int cs_dsp_adsp1_parse_sizes(struct cs_dsp *dsp,\n\t\t\t\t\t     const char * const file,\n\t\t\t\t\t     unsigned int pos,\n\t\t\t\t\t     const struct firmware *firmware)\n{\n\tconst struct wmfw_adsp1_sizes *adsp1_sizes;\n\n\tadsp1_sizes = (void *)&firmware->data[pos];\n\n\tcs_dsp_dbg(dsp, \"%s: %d DM, %d PM, %d ZM\\n\", file,\n\t\t   le32_to_cpu(adsp1_sizes->dm), le32_to_cpu(adsp1_sizes->pm),\n\t\t   le32_to_cpu(adsp1_sizes->zm));\n\n\treturn pos + sizeof(*adsp1_sizes);\n}\n\nstatic unsigned int cs_dsp_adsp2_parse_sizes(struct cs_dsp *dsp,\n\t\t\t\t\t     const char * const file,\n\t\t\t\t\t     unsigned int pos,\n\t\t\t\t\t     const struct firmware *firmware)\n{\n\tconst struct wmfw_adsp2_sizes *adsp2_sizes;\n\n\tadsp2_sizes = (void *)&firmware->data[pos];\n\n\tcs_dsp_dbg(dsp, \"%s: %d XM, %d YM %d PM, %d ZM\\n\", file,\n\t\t   le32_to_cpu(adsp2_sizes->xm), le32_to_cpu(adsp2_sizes->ym),\n\t\t   le32_to_cpu(adsp2_sizes->pm), le32_to_cpu(adsp2_sizes->zm));\n\n\treturn pos + sizeof(*adsp2_sizes);\n}\n\nstatic bool cs_dsp_validate_version(struct cs_dsp *dsp, unsigned int version)\n{\n\tswitch (version) {\n\tcase 0:\n\t\tcs_dsp_warn(dsp, \"Deprecated file format %d\\n\", version);\n\t\treturn true;\n\tcase 1:\n\tcase 2:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs_dsp_halo_validate_version(struct cs_dsp *dsp, unsigned int version)\n{\n\tswitch (version) {\n\tcase 3:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int cs_dsp_load(struct cs_dsp *dsp, const struct firmware *firmware,\n\t\t       const char *file)\n{\n\tLIST_HEAD(buf_list);\n\tstruct regmap *regmap = dsp->regmap;\n\tunsigned int pos = 0;\n\tconst struct wmfw_header *header;\n\tconst struct wmfw_adsp1_sizes *adsp1_sizes;\n\tconst struct wmfw_footer *footer;\n\tconst struct wmfw_region *region;\n\tconst struct cs_dsp_region *mem;\n\tconst char *region_name;\n\tchar *text = NULL;\n\tstruct cs_dsp_buf *buf;\n\tunsigned int reg;\n\tint regions = 0;\n\tint ret, offset, type;\n\n\tif (!firmware)\n\t\treturn 0;\n\n\tret = -EINVAL;\n\n\tpos = sizeof(*header) + sizeof(*adsp1_sizes) + sizeof(*footer);\n\tif (pos >= firmware->size) {\n\t\tcs_dsp_err(dsp, \"%s: file too short, %zu bytes\\n\",\n\t\t\t   file, firmware->size);\n\t\tgoto out_fw;\n\t}\n\n\theader = (void *)&firmware->data[0];\n\n\tif (memcmp(&header->magic[0], \"WMFW\", 4) != 0) {\n\t\tcs_dsp_err(dsp, \"%s: invalid magic\\n\", file);\n\t\tgoto out_fw;\n\t}\n\n\tif (!dsp->ops->validate_version(dsp, header->ver)) {\n\t\tcs_dsp_err(dsp, \"%s: unknown file format %d\\n\",\n\t\t\t   file, header->ver);\n\t\tgoto out_fw;\n\t}\n\n\tcs_dsp_info(dsp, \"Firmware version: %d\\n\", header->ver);\n\tdsp->fw_ver = header->ver;\n\n\tif (header->core != dsp->type) {\n\t\tcs_dsp_err(dsp, \"%s: invalid core %d != %d\\n\",\n\t\t\t   file, header->core, dsp->type);\n\t\tgoto out_fw;\n\t}\n\n\tpos = sizeof(*header);\n\tpos = dsp->ops->parse_sizes(dsp, file, pos, firmware);\n\n\tfooter = (void *)&firmware->data[pos];\n\tpos += sizeof(*footer);\n\n\tif (le32_to_cpu(header->len) != pos) {\n\t\tcs_dsp_err(dsp, \"%s: unexpected header length %d\\n\",\n\t\t\t   file, le32_to_cpu(header->len));\n\t\tgoto out_fw;\n\t}\n\n\tcs_dsp_dbg(dsp, \"%s: timestamp %llu\\n\", file,\n\t\t   le64_to_cpu(footer->timestamp));\n\n\twhile (pos < firmware->size &&\n\t       sizeof(*region) < firmware->size - pos) {\n\t\tregion = (void *)&(firmware->data[pos]);\n\t\tregion_name = \"Unknown\";\n\t\treg = 0;\n\t\ttext = NULL;\n\t\toffset = le32_to_cpu(region->offset) & 0xffffff;\n\t\ttype = be32_to_cpu(region->type) & 0xff;\n\n\t\tswitch (type) {\n\t\tcase WMFW_NAME_TEXT:\n\t\t\tregion_name = \"Firmware name\";\n\t\t\ttext = kzalloc(le32_to_cpu(region->len) + 1,\n\t\t\t\t       GFP_KERNEL);\n\t\t\tbreak;\n\t\tcase WMFW_ALGORITHM_DATA:\n\t\t\tregion_name = \"Algorithm\";\n\t\t\tret = cs_dsp_parse_coeff(dsp, region);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out_fw;\n\t\t\tbreak;\n\t\tcase WMFW_INFO_TEXT:\n\t\t\tregion_name = \"Information\";\n\t\t\ttext = kzalloc(le32_to_cpu(region->len) + 1,\n\t\t\t\t       GFP_KERNEL);\n\t\t\tbreak;\n\t\tcase WMFW_ABSOLUTE:\n\t\t\tregion_name = \"Absolute\";\n\t\t\treg = offset;\n\t\t\tbreak;\n\t\tcase WMFW_ADSP1_PM:\n\t\tcase WMFW_ADSP1_DM:\n\t\tcase WMFW_ADSP2_XM:\n\t\tcase WMFW_ADSP2_YM:\n\t\tcase WMFW_ADSP1_ZM:\n\t\tcase WMFW_HALO_PM_PACKED:\n\t\tcase WMFW_HALO_XM_PACKED:\n\t\tcase WMFW_HALO_YM_PACKED:\n\t\t\tmem = cs_dsp_find_region(dsp, type);\n\t\t\tif (!mem) {\n\t\t\t\tcs_dsp_err(dsp, \"No region of type: %x\\n\", type);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_fw;\n\t\t\t}\n\n\t\t\tregion_name = cs_dsp_mem_region_name(type);\n\t\t\treg = dsp->ops->region_to_reg(mem, offset);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcs_dsp_warn(dsp,\n\t\t\t\t    \"%s.%d: Unknown region type %x at %d(%x)\\n\",\n\t\t\t\t    file, regions, type, pos, pos);\n\t\t\tbreak;\n\t\t}\n\n\t\tcs_dsp_dbg(dsp, \"%s.%d: %d bytes at %d in %s\\n\", file,\n\t\t\t   regions, le32_to_cpu(region->len), offset,\n\t\t\t   region_name);\n\n\t\tif (le32_to_cpu(region->len) >\n\t\t    firmware->size - pos - sizeof(*region)) {\n\t\t\tcs_dsp_err(dsp,\n\t\t\t\t   \"%s.%d: %s region len %d bytes exceeds file length %zu\\n\",\n\t\t\t\t   file, regions, region_name,\n\t\t\t\t   le32_to_cpu(region->len), firmware->size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_fw;\n\t\t}\n\n\t\tif (text) {\n\t\t\tmemcpy(text, region->data, le32_to_cpu(region->len));\n\t\t\tcs_dsp_info(dsp, \"%s: %s\\n\", file, text);\n\t\t\tkfree(text);\n\t\t\ttext = NULL;\n\t\t}\n\n\t\tif (reg) {\n\t\t\tbuf = cs_dsp_buf_alloc(region->data,\n\t\t\t\t\t       le32_to_cpu(region->len),\n\t\t\t\t\t       &buf_list);\n\t\t\tif (!buf) {\n\t\t\t\tcs_dsp_err(dsp, \"Out of memory\\n\");\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_fw;\n\t\t\t}\n\n\t\t\tret = regmap_raw_write_async(regmap, reg, buf->buf,\n\t\t\t\t\t\t     le32_to_cpu(region->len));\n\t\t\tif (ret != 0) {\n\t\t\t\tcs_dsp_err(dsp,\n\t\t\t\t\t   \"%s.%d: Failed to write %d bytes at %d in %s: %d\\n\",\n\t\t\t\t\t   file, regions,\n\t\t\t\t\t   le32_to_cpu(region->len), offset,\n\t\t\t\t\t   region_name, ret);\n\t\t\t\tgoto out_fw;\n\t\t\t}\n\t\t}\n\n\t\tpos += le32_to_cpu(region->len) + sizeof(*region);\n\t\tregions++;\n\t}\n\n\tret = regmap_async_complete(regmap);\n\tif (ret != 0) {\n\t\tcs_dsp_err(dsp, \"Failed to complete async write: %d\\n\", ret);\n\t\tgoto out_fw;\n\t}\n\n\tif (pos > firmware->size)\n\t\tcs_dsp_warn(dsp, \"%s.%d: %zu bytes at end of file\\n\",\n\t\t\t    file, regions, pos - firmware->size);\n\n\tcs_dsp_debugfs_save_wmfwname(dsp, file);\n\nout_fw:\n\tregmap_async_complete(regmap);\n\tcs_dsp_buf_free(&buf_list);\n\tkfree(text);\n\n\treturn ret;\n}\n\n \nstruct cs_dsp_coeff_ctl *cs_dsp_get_ctl(struct cs_dsp *dsp, const char *name, int type,\n\t\t\t\t\tunsigned int alg)\n{\n\tstruct cs_dsp_coeff_ctl *pos, *rslt = NULL;\n\n\tlockdep_assert_held(&dsp->pwr_lock);\n\n\tlist_for_each_entry(pos, &dsp->ctl_list, list) {\n\t\tif (!pos->subname)\n\t\t\tcontinue;\n\t\tif (strncmp(pos->subname, name, pos->subname_len) == 0 &&\n\t\t    pos->fw_name == dsp->fw_name &&\n\t\t    pos->alg_region.alg == alg &&\n\t\t    pos->alg_region.type == type) {\n\t\t\trslt = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rslt;\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_get_ctl, FW_CS_DSP);\n\nstatic void cs_dsp_ctl_fixup_base(struct cs_dsp *dsp,\n\t\t\t\t  const struct cs_dsp_alg_region *alg_region)\n{\n\tstruct cs_dsp_coeff_ctl *ctl;\n\n\tlist_for_each_entry(ctl, &dsp->ctl_list, list) {\n\t\tif (ctl->fw_name == dsp->fw_name &&\n\t\t    alg_region->alg == ctl->alg_region.alg &&\n\t\t    alg_region->type == ctl->alg_region.type) {\n\t\t\tctl->alg_region.base = alg_region->base;\n\t\t}\n\t}\n}\n\nstatic void *cs_dsp_read_algs(struct cs_dsp *dsp, size_t n_algs,\n\t\t\t      const struct cs_dsp_region *mem,\n\t\t\t      unsigned int pos, unsigned int len)\n{\n\tvoid *alg;\n\tunsigned int reg;\n\tint ret;\n\t__be32 val;\n\n\tif (n_algs == 0) {\n\t\tcs_dsp_err(dsp, \"No algorithms\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (n_algs > 1024) {\n\t\tcs_dsp_err(dsp, \"Algorithm count %zx excessive\\n\", n_algs);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\treg = dsp->ops->region_to_reg(mem, pos + len);\n\n\tret = regmap_raw_read(dsp->regmap, reg, &val, sizeof(val));\n\tif (ret != 0) {\n\t\tcs_dsp_err(dsp, \"Failed to read algorithm list end: %d\\n\",\n\t\t\t   ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (be32_to_cpu(val) != 0xbedead)\n\t\tcs_dsp_warn(dsp, \"Algorithm list end %x 0x%x != 0xbedead\\n\",\n\t\t\t    reg, be32_to_cpu(val));\n\n\t \n\tlen *= sizeof(u32);\n\n\talg = kzalloc(len, GFP_KERNEL | GFP_DMA);\n\tif (!alg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treg = dsp->ops->region_to_reg(mem, pos);\n\n\tret = regmap_raw_read(dsp->regmap, reg, alg, len);\n\tif (ret != 0) {\n\t\tcs_dsp_err(dsp, \"Failed to read algorithm list: %d\\n\", ret);\n\t\tkfree(alg);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn alg;\n}\n\n \nstruct cs_dsp_alg_region *cs_dsp_find_alg_region(struct cs_dsp *dsp,\n\t\t\t\t\t\t int type, unsigned int id)\n{\n\tstruct cs_dsp_alg_region *alg_region;\n\n\tlockdep_assert_held(&dsp->pwr_lock);\n\n\tlist_for_each_entry(alg_region, &dsp->alg_regions, list) {\n\t\tif (id == alg_region->alg && type == alg_region->type)\n\t\t\treturn alg_region;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_find_alg_region, FW_CS_DSP);\n\nstatic struct cs_dsp_alg_region *cs_dsp_create_region(struct cs_dsp *dsp,\n\t\t\t\t\t\t      int type, __be32 id,\n\t\t\t\t\t\t      __be32 ver, __be32 base)\n{\n\tstruct cs_dsp_alg_region *alg_region;\n\n\talg_region = kzalloc(sizeof(*alg_region), GFP_KERNEL);\n\tif (!alg_region)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\talg_region->type = type;\n\talg_region->alg = be32_to_cpu(id);\n\talg_region->ver = be32_to_cpu(ver);\n\talg_region->base = be32_to_cpu(base);\n\n\tlist_add_tail(&alg_region->list, &dsp->alg_regions);\n\n\tif (dsp->fw_ver > 0)\n\t\tcs_dsp_ctl_fixup_base(dsp, alg_region);\n\n\treturn alg_region;\n}\n\nstatic void cs_dsp_free_alg_regions(struct cs_dsp *dsp)\n{\n\tstruct cs_dsp_alg_region *alg_region;\n\n\twhile (!list_empty(&dsp->alg_regions)) {\n\t\talg_region = list_first_entry(&dsp->alg_regions,\n\t\t\t\t\t      struct cs_dsp_alg_region,\n\t\t\t\t\t      list);\n\t\tlist_del(&alg_region->list);\n\t\tkfree(alg_region);\n\t}\n}\n\nstatic void cs_dsp_parse_wmfw_id_header(struct cs_dsp *dsp,\n\t\t\t\t\tstruct wmfw_id_hdr *fw, int nalgs)\n{\n\tdsp->fw_id = be32_to_cpu(fw->id);\n\tdsp->fw_id_version = be32_to_cpu(fw->ver);\n\n\tcs_dsp_info(dsp, \"Firmware: %x v%d.%d.%d, %d algorithms\\n\",\n\t\t    dsp->fw_id, (dsp->fw_id_version & 0xff0000) >> 16,\n\t\t    (dsp->fw_id_version & 0xff00) >> 8, dsp->fw_id_version & 0xff,\n\t\t    nalgs);\n}\n\nstatic void cs_dsp_parse_wmfw_v3_id_header(struct cs_dsp *dsp,\n\t\t\t\t\t   struct wmfw_v3_id_hdr *fw, int nalgs)\n{\n\tdsp->fw_id = be32_to_cpu(fw->id);\n\tdsp->fw_id_version = be32_to_cpu(fw->ver);\n\tdsp->fw_vendor_id = be32_to_cpu(fw->vendor_id);\n\n\tcs_dsp_info(dsp, \"Firmware: %x vendor: 0x%x v%d.%d.%d, %d algorithms\\n\",\n\t\t    dsp->fw_id, dsp->fw_vendor_id,\n\t\t    (dsp->fw_id_version & 0xff0000) >> 16,\n\t\t    (dsp->fw_id_version & 0xff00) >> 8, dsp->fw_id_version & 0xff,\n\t\t    nalgs);\n}\n\nstatic int cs_dsp_create_regions(struct cs_dsp *dsp, __be32 id, __be32 ver,\n\t\t\t\t int nregions, const int *type, __be32 *base)\n{\n\tstruct cs_dsp_alg_region *alg_region;\n\tint i;\n\n\tfor (i = 0; i < nregions; i++) {\n\t\talg_region = cs_dsp_create_region(dsp, type[i], id, ver, base[i]);\n\t\tif (IS_ERR(alg_region))\n\t\t\treturn PTR_ERR(alg_region);\n\t}\n\n\treturn 0;\n}\n\nstatic int cs_dsp_adsp1_setup_algs(struct cs_dsp *dsp)\n{\n\tstruct wmfw_adsp1_id_hdr adsp1_id;\n\tstruct wmfw_adsp1_alg_hdr *adsp1_alg;\n\tstruct cs_dsp_alg_region *alg_region;\n\tconst struct cs_dsp_region *mem;\n\tunsigned int pos, len;\n\tsize_t n_algs;\n\tint i, ret;\n\n\tmem = cs_dsp_find_region(dsp, WMFW_ADSP1_DM);\n\tif (WARN_ON(!mem))\n\t\treturn -EINVAL;\n\n\tret = regmap_raw_read(dsp->regmap, mem->base, &adsp1_id,\n\t\t\t      sizeof(adsp1_id));\n\tif (ret != 0) {\n\t\tcs_dsp_err(dsp, \"Failed to read algorithm info: %d\\n\",\n\t\t\t   ret);\n\t\treturn ret;\n\t}\n\n\tn_algs = be32_to_cpu(adsp1_id.n_algs);\n\n\tcs_dsp_parse_wmfw_id_header(dsp, &adsp1_id.fw, n_algs);\n\n\talg_region = cs_dsp_create_region(dsp, WMFW_ADSP1_ZM,\n\t\t\t\t\t  adsp1_id.fw.id, adsp1_id.fw.ver,\n\t\t\t\t\t  adsp1_id.zm);\n\tif (IS_ERR(alg_region))\n\t\treturn PTR_ERR(alg_region);\n\n\talg_region = cs_dsp_create_region(dsp, WMFW_ADSP1_DM,\n\t\t\t\t\t  adsp1_id.fw.id, adsp1_id.fw.ver,\n\t\t\t\t\t  adsp1_id.dm);\n\tif (IS_ERR(alg_region))\n\t\treturn PTR_ERR(alg_region);\n\n\t \n\tpos = sizeof(adsp1_id) / sizeof(u32);\n\tlen = (sizeof(*adsp1_alg) * n_algs) / sizeof(u32);\n\n\tadsp1_alg = cs_dsp_read_algs(dsp, n_algs, mem, pos, len);\n\tif (IS_ERR(adsp1_alg))\n\t\treturn PTR_ERR(adsp1_alg);\n\n\tfor (i = 0; i < n_algs; i++) {\n\t\tcs_dsp_info(dsp, \"%d: ID %x v%d.%d.%d DM@%x ZM@%x\\n\",\n\t\t\t    i, be32_to_cpu(adsp1_alg[i].alg.id),\n\t\t\t    (be32_to_cpu(adsp1_alg[i].alg.ver) & 0xff0000) >> 16,\n\t\t\t    (be32_to_cpu(adsp1_alg[i].alg.ver) & 0xff00) >> 8,\n\t\t\t    be32_to_cpu(adsp1_alg[i].alg.ver) & 0xff,\n\t\t\t    be32_to_cpu(adsp1_alg[i].dm),\n\t\t\t    be32_to_cpu(adsp1_alg[i].zm));\n\n\t\talg_region = cs_dsp_create_region(dsp, WMFW_ADSP1_DM,\n\t\t\t\t\t\t  adsp1_alg[i].alg.id,\n\t\t\t\t\t\t  adsp1_alg[i].alg.ver,\n\t\t\t\t\t\t  adsp1_alg[i].dm);\n\t\tif (IS_ERR(alg_region)) {\n\t\t\tret = PTR_ERR(alg_region);\n\t\t\tgoto out;\n\t\t}\n\t\tif (dsp->fw_ver == 0) {\n\t\t\tif (i + 1 < n_algs) {\n\t\t\t\tlen = be32_to_cpu(adsp1_alg[i + 1].dm);\n\t\t\t\tlen -= be32_to_cpu(adsp1_alg[i].dm);\n\t\t\t\tlen *= 4;\n\t\t\t\tcs_dsp_create_control(dsp, alg_region, 0,\n\t\t\t\t\t\t      len, NULL, 0, 0,\n\t\t\t\t\t\t      WMFW_CTL_TYPE_BYTES);\n\t\t\t} else {\n\t\t\t\tcs_dsp_warn(dsp, \"Missing length info for region DM with ID %x\\n\",\n\t\t\t\t\t    be32_to_cpu(adsp1_alg[i].alg.id));\n\t\t\t}\n\t\t}\n\n\t\talg_region = cs_dsp_create_region(dsp, WMFW_ADSP1_ZM,\n\t\t\t\t\t\t  adsp1_alg[i].alg.id,\n\t\t\t\t\t\t  adsp1_alg[i].alg.ver,\n\t\t\t\t\t\t  adsp1_alg[i].zm);\n\t\tif (IS_ERR(alg_region)) {\n\t\t\tret = PTR_ERR(alg_region);\n\t\t\tgoto out;\n\t\t}\n\t\tif (dsp->fw_ver == 0) {\n\t\t\tif (i + 1 < n_algs) {\n\t\t\t\tlen = be32_to_cpu(adsp1_alg[i + 1].zm);\n\t\t\t\tlen -= be32_to_cpu(adsp1_alg[i].zm);\n\t\t\t\tlen *= 4;\n\t\t\t\tcs_dsp_create_control(dsp, alg_region, 0,\n\t\t\t\t\t\t      len, NULL, 0, 0,\n\t\t\t\t\t\t      WMFW_CTL_TYPE_BYTES);\n\t\t\t} else {\n\t\t\t\tcs_dsp_warn(dsp, \"Missing length info for region ZM with ID %x\\n\",\n\t\t\t\t\t    be32_to_cpu(adsp1_alg[i].alg.id));\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tkfree(adsp1_alg);\n\treturn ret;\n}\n\nstatic int cs_dsp_adsp2_setup_algs(struct cs_dsp *dsp)\n{\n\tstruct wmfw_adsp2_id_hdr adsp2_id;\n\tstruct wmfw_adsp2_alg_hdr *adsp2_alg;\n\tstruct cs_dsp_alg_region *alg_region;\n\tconst struct cs_dsp_region *mem;\n\tunsigned int pos, len;\n\tsize_t n_algs;\n\tint i, ret;\n\n\tmem = cs_dsp_find_region(dsp, WMFW_ADSP2_XM);\n\tif (WARN_ON(!mem))\n\t\treturn -EINVAL;\n\n\tret = regmap_raw_read(dsp->regmap, mem->base, &adsp2_id,\n\t\t\t      sizeof(adsp2_id));\n\tif (ret != 0) {\n\t\tcs_dsp_err(dsp, \"Failed to read algorithm info: %d\\n\",\n\t\t\t   ret);\n\t\treturn ret;\n\t}\n\n\tn_algs = be32_to_cpu(adsp2_id.n_algs);\n\n\tcs_dsp_parse_wmfw_id_header(dsp, &adsp2_id.fw, n_algs);\n\n\talg_region = cs_dsp_create_region(dsp, WMFW_ADSP2_XM,\n\t\t\t\t\t  adsp2_id.fw.id, adsp2_id.fw.ver,\n\t\t\t\t\t  adsp2_id.xm);\n\tif (IS_ERR(alg_region))\n\t\treturn PTR_ERR(alg_region);\n\n\talg_region = cs_dsp_create_region(dsp, WMFW_ADSP2_YM,\n\t\t\t\t\t  adsp2_id.fw.id, adsp2_id.fw.ver,\n\t\t\t\t\t  adsp2_id.ym);\n\tif (IS_ERR(alg_region))\n\t\treturn PTR_ERR(alg_region);\n\n\talg_region = cs_dsp_create_region(dsp, WMFW_ADSP2_ZM,\n\t\t\t\t\t  adsp2_id.fw.id, adsp2_id.fw.ver,\n\t\t\t\t\t  adsp2_id.zm);\n\tif (IS_ERR(alg_region))\n\t\treturn PTR_ERR(alg_region);\n\n\t \n\tpos = sizeof(adsp2_id) / sizeof(u32);\n\tlen = (sizeof(*adsp2_alg) * n_algs) / sizeof(u32);\n\n\tadsp2_alg = cs_dsp_read_algs(dsp, n_algs, mem, pos, len);\n\tif (IS_ERR(adsp2_alg))\n\t\treturn PTR_ERR(adsp2_alg);\n\n\tfor (i = 0; i < n_algs; i++) {\n\t\tcs_dsp_dbg(dsp,\n\t\t\t   \"%d: ID %x v%d.%d.%d XM@%x YM@%x ZM@%x\\n\",\n\t\t\t   i, be32_to_cpu(adsp2_alg[i].alg.id),\n\t\t\t   (be32_to_cpu(adsp2_alg[i].alg.ver) & 0xff0000) >> 16,\n\t\t\t   (be32_to_cpu(adsp2_alg[i].alg.ver) & 0xff00) >> 8,\n\t\t\t   be32_to_cpu(adsp2_alg[i].alg.ver) & 0xff,\n\t\t\t   be32_to_cpu(adsp2_alg[i].xm),\n\t\t\t   be32_to_cpu(adsp2_alg[i].ym),\n\t\t\t   be32_to_cpu(adsp2_alg[i].zm));\n\n\t\talg_region = cs_dsp_create_region(dsp, WMFW_ADSP2_XM,\n\t\t\t\t\t\t  adsp2_alg[i].alg.id,\n\t\t\t\t\t\t  adsp2_alg[i].alg.ver,\n\t\t\t\t\t\t  adsp2_alg[i].xm);\n\t\tif (IS_ERR(alg_region)) {\n\t\t\tret = PTR_ERR(alg_region);\n\t\t\tgoto out;\n\t\t}\n\t\tif (dsp->fw_ver == 0) {\n\t\t\tif (i + 1 < n_algs) {\n\t\t\t\tlen = be32_to_cpu(adsp2_alg[i + 1].xm);\n\t\t\t\tlen -= be32_to_cpu(adsp2_alg[i].xm);\n\t\t\t\tlen *= 4;\n\t\t\t\tcs_dsp_create_control(dsp, alg_region, 0,\n\t\t\t\t\t\t      len, NULL, 0, 0,\n\t\t\t\t\t\t      WMFW_CTL_TYPE_BYTES);\n\t\t\t} else {\n\t\t\t\tcs_dsp_warn(dsp, \"Missing length info for region XM with ID %x\\n\",\n\t\t\t\t\t    be32_to_cpu(adsp2_alg[i].alg.id));\n\t\t\t}\n\t\t}\n\n\t\talg_region = cs_dsp_create_region(dsp, WMFW_ADSP2_YM,\n\t\t\t\t\t\t  adsp2_alg[i].alg.id,\n\t\t\t\t\t\t  adsp2_alg[i].alg.ver,\n\t\t\t\t\t\t  adsp2_alg[i].ym);\n\t\tif (IS_ERR(alg_region)) {\n\t\t\tret = PTR_ERR(alg_region);\n\t\t\tgoto out;\n\t\t}\n\t\tif (dsp->fw_ver == 0) {\n\t\t\tif (i + 1 < n_algs) {\n\t\t\t\tlen = be32_to_cpu(adsp2_alg[i + 1].ym);\n\t\t\t\tlen -= be32_to_cpu(adsp2_alg[i].ym);\n\t\t\t\tlen *= 4;\n\t\t\t\tcs_dsp_create_control(dsp, alg_region, 0,\n\t\t\t\t\t\t      len, NULL, 0, 0,\n\t\t\t\t\t\t      WMFW_CTL_TYPE_BYTES);\n\t\t\t} else {\n\t\t\t\tcs_dsp_warn(dsp, \"Missing length info for region YM with ID %x\\n\",\n\t\t\t\t\t    be32_to_cpu(adsp2_alg[i].alg.id));\n\t\t\t}\n\t\t}\n\n\t\talg_region = cs_dsp_create_region(dsp, WMFW_ADSP2_ZM,\n\t\t\t\t\t\t  adsp2_alg[i].alg.id,\n\t\t\t\t\t\t  adsp2_alg[i].alg.ver,\n\t\t\t\t\t\t  adsp2_alg[i].zm);\n\t\tif (IS_ERR(alg_region)) {\n\t\t\tret = PTR_ERR(alg_region);\n\t\t\tgoto out;\n\t\t}\n\t\tif (dsp->fw_ver == 0) {\n\t\t\tif (i + 1 < n_algs) {\n\t\t\t\tlen = be32_to_cpu(adsp2_alg[i + 1].zm);\n\t\t\t\tlen -= be32_to_cpu(adsp2_alg[i].zm);\n\t\t\t\tlen *= 4;\n\t\t\t\tcs_dsp_create_control(dsp, alg_region, 0,\n\t\t\t\t\t\t      len, NULL, 0, 0,\n\t\t\t\t\t\t      WMFW_CTL_TYPE_BYTES);\n\t\t\t} else {\n\t\t\t\tcs_dsp_warn(dsp, \"Missing length info for region ZM with ID %x\\n\",\n\t\t\t\t\t    be32_to_cpu(adsp2_alg[i].alg.id));\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tkfree(adsp2_alg);\n\treturn ret;\n}\n\nstatic int cs_dsp_halo_create_regions(struct cs_dsp *dsp, __be32 id, __be32 ver,\n\t\t\t\t      __be32 xm_base, __be32 ym_base)\n{\n\tstatic const int types[] = {\n\t\tWMFW_ADSP2_XM, WMFW_HALO_XM_PACKED,\n\t\tWMFW_ADSP2_YM, WMFW_HALO_YM_PACKED\n\t};\n\t__be32 bases[] = { xm_base, xm_base, ym_base, ym_base };\n\n\treturn cs_dsp_create_regions(dsp, id, ver, ARRAY_SIZE(types), types, bases);\n}\n\nstatic int cs_dsp_halo_setup_algs(struct cs_dsp *dsp)\n{\n\tstruct wmfw_halo_id_hdr halo_id;\n\tstruct wmfw_halo_alg_hdr *halo_alg;\n\tconst struct cs_dsp_region *mem;\n\tunsigned int pos, len;\n\tsize_t n_algs;\n\tint i, ret;\n\n\tmem = cs_dsp_find_region(dsp, WMFW_ADSP2_XM);\n\tif (WARN_ON(!mem))\n\t\treturn -EINVAL;\n\n\tret = regmap_raw_read(dsp->regmap, mem->base, &halo_id,\n\t\t\t      sizeof(halo_id));\n\tif (ret != 0) {\n\t\tcs_dsp_err(dsp, \"Failed to read algorithm info: %d\\n\",\n\t\t\t   ret);\n\t\treturn ret;\n\t}\n\n\tn_algs = be32_to_cpu(halo_id.n_algs);\n\n\tcs_dsp_parse_wmfw_v3_id_header(dsp, &halo_id.fw, n_algs);\n\n\tret = cs_dsp_halo_create_regions(dsp, halo_id.fw.id, halo_id.fw.ver,\n\t\t\t\t\t halo_id.xm_base, halo_id.ym_base);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpos = sizeof(halo_id) / sizeof(u32);\n\tlen = (sizeof(*halo_alg) * n_algs) / sizeof(u32);\n\n\thalo_alg = cs_dsp_read_algs(dsp, n_algs, mem, pos, len);\n\tif (IS_ERR(halo_alg))\n\t\treturn PTR_ERR(halo_alg);\n\n\tfor (i = 0; i < n_algs; i++) {\n\t\tcs_dsp_dbg(dsp,\n\t\t\t   \"%d: ID %x v%d.%d.%d XM@%x YM@%x\\n\",\n\t\t\t   i, be32_to_cpu(halo_alg[i].alg.id),\n\t\t\t   (be32_to_cpu(halo_alg[i].alg.ver) & 0xff0000) >> 16,\n\t\t\t   (be32_to_cpu(halo_alg[i].alg.ver) & 0xff00) >> 8,\n\t\t\t   be32_to_cpu(halo_alg[i].alg.ver) & 0xff,\n\t\t\t   be32_to_cpu(halo_alg[i].xm_base),\n\t\t\t   be32_to_cpu(halo_alg[i].ym_base));\n\n\t\tret = cs_dsp_halo_create_regions(dsp, halo_alg[i].alg.id,\n\t\t\t\t\t\t halo_alg[i].alg.ver,\n\t\t\t\t\t\t halo_alg[i].xm_base,\n\t\t\t\t\t\t halo_alg[i].ym_base);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\tkfree(halo_alg);\n\treturn ret;\n}\n\nstatic int cs_dsp_load_coeff(struct cs_dsp *dsp, const struct firmware *firmware,\n\t\t\t     const char *file)\n{\n\tLIST_HEAD(buf_list);\n\tstruct regmap *regmap = dsp->regmap;\n\tstruct wmfw_coeff_hdr *hdr;\n\tstruct wmfw_coeff_item *blk;\n\tconst struct cs_dsp_region *mem;\n\tstruct cs_dsp_alg_region *alg_region;\n\tconst char *region_name;\n\tint ret, pos, blocks, type, offset, reg, version;\n\tchar *text = NULL;\n\tstruct cs_dsp_buf *buf;\n\n\tif (!firmware)\n\t\treturn 0;\n\n\tret = -EINVAL;\n\n\tif (sizeof(*hdr) >= firmware->size) {\n\t\tcs_dsp_err(dsp, \"%s: coefficient file too short, %zu bytes\\n\",\n\t\t\t   file, firmware->size);\n\t\tgoto out_fw;\n\t}\n\n\thdr = (void *)&firmware->data[0];\n\tif (memcmp(hdr->magic, \"WMDR\", 4) != 0) {\n\t\tcs_dsp_err(dsp, \"%s: invalid coefficient magic\\n\", file);\n\t\tgoto out_fw;\n\t}\n\n\tswitch (be32_to_cpu(hdr->rev) & 0xff) {\n\tcase 1:\n\tcase 2:\n\t\tbreak;\n\tdefault:\n\t\tcs_dsp_err(dsp, \"%s: Unsupported coefficient file format %d\\n\",\n\t\t\t   file, be32_to_cpu(hdr->rev) & 0xff);\n\t\tret = -EINVAL;\n\t\tgoto out_fw;\n\t}\n\n\tcs_dsp_info(dsp, \"%s: v%d.%d.%d\\n\", file,\n\t\t    (le32_to_cpu(hdr->ver) >> 16) & 0xff,\n\t\t    (le32_to_cpu(hdr->ver) >>  8) & 0xff,\n\t\t    le32_to_cpu(hdr->ver) & 0xff);\n\n\tpos = le32_to_cpu(hdr->len);\n\n\tblocks = 0;\n\twhile (pos < firmware->size &&\n\t       sizeof(*blk) < firmware->size - pos) {\n\t\tblk = (void *)(&firmware->data[pos]);\n\n\t\ttype = le16_to_cpu(blk->type);\n\t\toffset = le16_to_cpu(blk->offset);\n\t\tversion = le32_to_cpu(blk->ver) >> 8;\n\n\t\tcs_dsp_dbg(dsp, \"%s.%d: %x v%d.%d.%d\\n\",\n\t\t\t   file, blocks, le32_to_cpu(blk->id),\n\t\t\t   (le32_to_cpu(blk->ver) >> 16) & 0xff,\n\t\t\t   (le32_to_cpu(blk->ver) >>  8) & 0xff,\n\t\t\t   le32_to_cpu(blk->ver) & 0xff);\n\t\tcs_dsp_dbg(dsp, \"%s.%d: %d bytes at 0x%x in %x\\n\",\n\t\t\t   file, blocks, le32_to_cpu(blk->len), offset, type);\n\n\t\treg = 0;\n\t\tregion_name = \"Unknown\";\n\t\tswitch (type) {\n\t\tcase (WMFW_NAME_TEXT << 8):\n\t\t\ttext = kzalloc(le32_to_cpu(blk->len) + 1, GFP_KERNEL);\n\t\t\tbreak;\n\t\tcase (WMFW_INFO_TEXT << 8):\n\t\tcase (WMFW_METADATA << 8):\n\t\t\tbreak;\n\t\tcase (WMFW_ABSOLUTE << 8):\n\t\t\t \n\t\t\tif (le32_to_cpu(blk->id) == dsp->fw_id &&\n\t\t\t    offset == 0) {\n\t\t\t\tregion_name = \"global coefficients\";\n\t\t\t\tmem = cs_dsp_find_region(dsp, type);\n\t\t\t\tif (!mem) {\n\t\t\t\t\tcs_dsp_err(dsp, \"No ZM\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treg = dsp->ops->region_to_reg(mem, 0);\n\n\t\t\t} else {\n\t\t\t\tregion_name = \"register\";\n\t\t\t\treg = offset;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase WMFW_ADSP1_DM:\n\t\tcase WMFW_ADSP1_ZM:\n\t\tcase WMFW_ADSP2_XM:\n\t\tcase WMFW_ADSP2_YM:\n\t\tcase WMFW_HALO_XM_PACKED:\n\t\tcase WMFW_HALO_YM_PACKED:\n\t\tcase WMFW_HALO_PM_PACKED:\n\t\t\tcs_dsp_dbg(dsp, \"%s.%d: %d bytes in %x for %x\\n\",\n\t\t\t\t   file, blocks, le32_to_cpu(blk->len),\n\t\t\t\t   type, le32_to_cpu(blk->id));\n\n\t\t\tregion_name = cs_dsp_mem_region_name(type);\n\t\t\tmem = cs_dsp_find_region(dsp, type);\n\t\t\tif (!mem) {\n\t\t\t\tcs_dsp_err(dsp, \"No base for region %x\\n\", type);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\talg_region = cs_dsp_find_alg_region(dsp, type,\n\t\t\t\t\t\t\t    le32_to_cpu(blk->id));\n\t\t\tif (alg_region) {\n\t\t\t\tif (version != alg_region->ver)\n\t\t\t\t\tcs_dsp_warn(dsp,\n\t\t\t\t\t\t    \"Algorithm coefficient version %d.%d.%d but expected %d.%d.%d\\n\",\n\t\t\t\t\t\t   (version >> 16) & 0xFF,\n\t\t\t\t\t\t   (version >> 8) & 0xFF,\n\t\t\t\t\t\t   version & 0xFF,\n\t\t\t\t\t\t   (alg_region->ver >> 16) & 0xFF,\n\t\t\t\t\t\t   (alg_region->ver >> 8) & 0xFF,\n\t\t\t\t\t\t   alg_region->ver & 0xFF);\n\n\t\t\t\treg = alg_region->base;\n\t\t\t\treg = dsp->ops->region_to_reg(mem, reg);\n\t\t\t\treg += offset;\n\t\t\t} else {\n\t\t\t\tcs_dsp_err(dsp, \"No %s for algorithm %x\\n\",\n\t\t\t\t\t   region_name, le32_to_cpu(blk->id));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcs_dsp_err(dsp, \"%s.%d: Unknown region type %x at %d\\n\",\n\t\t\t\t   file, blocks, type, pos);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (text) {\n\t\t\tmemcpy(text, blk->data, le32_to_cpu(blk->len));\n\t\t\tcs_dsp_info(dsp, \"%s: %s\\n\", dsp->fw_name, text);\n\t\t\tkfree(text);\n\t\t\ttext = NULL;\n\t\t}\n\n\t\tif (reg) {\n\t\t\tif (le32_to_cpu(blk->len) >\n\t\t\t    firmware->size - pos - sizeof(*blk)) {\n\t\t\t\tcs_dsp_err(dsp,\n\t\t\t\t\t   \"%s.%d: %s region len %d bytes exceeds file length %zu\\n\",\n\t\t\t\t\t   file, blocks, region_name,\n\t\t\t\t\t   le32_to_cpu(blk->len),\n\t\t\t\t\t   firmware->size);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_fw;\n\t\t\t}\n\n\t\t\tbuf = cs_dsp_buf_alloc(blk->data,\n\t\t\t\t\t       le32_to_cpu(blk->len),\n\t\t\t\t\t       &buf_list);\n\t\t\tif (!buf) {\n\t\t\t\tcs_dsp_err(dsp, \"Out of memory\\n\");\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_fw;\n\t\t\t}\n\n\t\t\tcs_dsp_dbg(dsp, \"%s.%d: Writing %d bytes at %x\\n\",\n\t\t\t\t   file, blocks, le32_to_cpu(blk->len),\n\t\t\t\t   reg);\n\t\t\tret = regmap_raw_write_async(regmap, reg, buf->buf,\n\t\t\t\t\t\t     le32_to_cpu(blk->len));\n\t\t\tif (ret != 0) {\n\t\t\t\tcs_dsp_err(dsp,\n\t\t\t\t\t   \"%s.%d: Failed to write to %x in %s: %d\\n\",\n\t\t\t\t\t   file, blocks, reg, region_name, ret);\n\t\t\t}\n\t\t}\n\n\t\tpos += (le32_to_cpu(blk->len) + sizeof(*blk) + 3) & ~0x03;\n\t\tblocks++;\n\t}\n\n\tret = regmap_async_complete(regmap);\n\tif (ret != 0)\n\t\tcs_dsp_err(dsp, \"Failed to complete async write: %d\\n\", ret);\n\n\tif (pos > firmware->size)\n\t\tcs_dsp_warn(dsp, \"%s.%d: %zu bytes at end of file\\n\",\n\t\t\t    file, blocks, pos - firmware->size);\n\n\tcs_dsp_debugfs_save_binname(dsp, file);\n\nout_fw:\n\tregmap_async_complete(regmap);\n\tcs_dsp_buf_free(&buf_list);\n\tkfree(text);\n\treturn ret;\n}\n\nstatic int cs_dsp_create_name(struct cs_dsp *dsp)\n{\n\tif (!dsp->name) {\n\t\tdsp->name = devm_kasprintf(dsp->dev, GFP_KERNEL, \"DSP%d\",\n\t\t\t\t\t   dsp->num);\n\t\tif (!dsp->name)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs_dsp_common_init(struct cs_dsp *dsp)\n{\n\tint ret;\n\n\tret = cs_dsp_create_name(dsp);\n\tif (ret)\n\t\treturn ret;\n\n\tINIT_LIST_HEAD(&dsp->alg_regions);\n\tINIT_LIST_HEAD(&dsp->ctl_list);\n\n\tmutex_init(&dsp->pwr_lock);\n\n\treturn 0;\n}\n\n \nint cs_dsp_adsp1_init(struct cs_dsp *dsp)\n{\n\tdsp->ops = &cs_dsp_adsp1_ops;\n\n\treturn cs_dsp_common_init(dsp);\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_adsp1_init, FW_CS_DSP);\n\n \nint cs_dsp_adsp1_power_up(struct cs_dsp *dsp,\n\t\t\t  const struct firmware *wmfw_firmware, char *wmfw_filename,\n\t\t\t  const struct firmware *coeff_firmware, char *coeff_filename,\n\t\t\t  const char *fw_name)\n{\n\tunsigned int val;\n\tint ret;\n\n\tmutex_lock(&dsp->pwr_lock);\n\n\tdsp->fw_name = fw_name;\n\n\tregmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,\n\t\t\t   ADSP1_SYS_ENA, ADSP1_SYS_ENA);\n\n\t \n\tif (dsp->sysclk_reg) {\n\t\tret = regmap_read(dsp->regmap, dsp->sysclk_reg, &val);\n\t\tif (ret != 0) {\n\t\t\tcs_dsp_err(dsp, \"Failed to read SYSCLK state: %d\\n\", ret);\n\t\t\tgoto err_mutex;\n\t\t}\n\n\t\tval = (val & dsp->sysclk_mask) >> dsp->sysclk_shift;\n\n\t\tret = regmap_update_bits(dsp->regmap,\n\t\t\t\t\t dsp->base + ADSP1_CONTROL_31,\n\t\t\t\t\t ADSP1_CLK_SEL_MASK, val);\n\t\tif (ret != 0) {\n\t\t\tcs_dsp_err(dsp, \"Failed to set clock rate: %d\\n\", ret);\n\t\t\tgoto err_mutex;\n\t\t}\n\t}\n\n\tret = cs_dsp_load(dsp, wmfw_firmware, wmfw_filename);\n\tif (ret != 0)\n\t\tgoto err_ena;\n\n\tret = cs_dsp_adsp1_setup_algs(dsp);\n\tif (ret != 0)\n\t\tgoto err_ena;\n\n\tret = cs_dsp_load_coeff(dsp, coeff_firmware, coeff_filename);\n\tif (ret != 0)\n\t\tgoto err_ena;\n\n\t \n\tret = cs_dsp_coeff_init_control_caches(dsp);\n\tif (ret != 0)\n\t\tgoto err_ena;\n\n\t \n\tret = cs_dsp_coeff_sync_controls(dsp);\n\tif (ret != 0)\n\t\tgoto err_ena;\n\n\tdsp->booted = true;\n\n\t \n\tregmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,\n\t\t\t   ADSP1_CORE_ENA | ADSP1_START,\n\t\t\t   ADSP1_CORE_ENA | ADSP1_START);\n\n\tdsp->running = true;\n\n\tmutex_unlock(&dsp->pwr_lock);\n\n\treturn 0;\n\nerr_ena:\n\tregmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,\n\t\t\t   ADSP1_SYS_ENA, 0);\nerr_mutex:\n\tmutex_unlock(&dsp->pwr_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_adsp1_power_up, FW_CS_DSP);\n\n \nvoid cs_dsp_adsp1_power_down(struct cs_dsp *dsp)\n{\n\tstruct cs_dsp_coeff_ctl *ctl;\n\n\tmutex_lock(&dsp->pwr_lock);\n\n\tdsp->running = false;\n\tdsp->booted = false;\n\n\t \n\tregmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,\n\t\t\t   ADSP1_CORE_ENA | ADSP1_START, 0);\n\n\tregmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_19,\n\t\t\t   ADSP1_WDMA_BUFFER_LENGTH_MASK, 0);\n\n\tregmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,\n\t\t\t   ADSP1_SYS_ENA, 0);\n\n\tlist_for_each_entry(ctl, &dsp->ctl_list, list)\n\t\tctl->enabled = 0;\n\n\tcs_dsp_free_alg_regions(dsp);\n\n\tmutex_unlock(&dsp->pwr_lock);\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_adsp1_power_down, FW_CS_DSP);\n\nstatic int cs_dsp_adsp2v2_enable_core(struct cs_dsp *dsp)\n{\n\tunsigned int val;\n\tint ret, count;\n\n\t \n\tfor (count = 0; count < 10; ++count) {\n\t\tret = regmap_read(dsp->regmap, dsp->base + ADSP2_STATUS1, &val);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\tif (val & ADSP2_RAM_RDY)\n\t\t\tbreak;\n\n\t\tusleep_range(250, 500);\n\t}\n\n\tif (!(val & ADSP2_RAM_RDY)) {\n\t\tcs_dsp_err(dsp, \"Failed to start DSP RAM\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tcs_dsp_dbg(dsp, \"RAM ready after %d polls\\n\", count);\n\n\treturn 0;\n}\n\nstatic int cs_dsp_adsp2_enable_core(struct cs_dsp *dsp)\n{\n\tint ret;\n\n\tret = regmap_update_bits_async(dsp->regmap, dsp->base + ADSP2_CONTROL,\n\t\t\t\t       ADSP2_SYS_ENA, ADSP2_SYS_ENA);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn cs_dsp_adsp2v2_enable_core(dsp);\n}\n\nstatic int cs_dsp_adsp2_lock(struct cs_dsp *dsp, unsigned int lock_regions)\n{\n\tstruct regmap *regmap = dsp->regmap;\n\tunsigned int code0, code1, lock_reg;\n\n\tif (!(lock_regions & CS_ADSP2_REGION_ALL))\n\t\treturn 0;\n\n\tlock_regions &= CS_ADSP2_REGION_ALL;\n\tlock_reg = dsp->base + ADSP2_LOCK_REGION_1_LOCK_REGION_0;\n\n\twhile (lock_regions) {\n\t\tcode0 = code1 = 0;\n\t\tif (lock_regions & BIT(0)) {\n\t\t\tcode0 = ADSP2_LOCK_CODE_0;\n\t\t\tcode1 = ADSP2_LOCK_CODE_1;\n\t\t}\n\t\tif (lock_regions & BIT(1)) {\n\t\t\tcode0 |= ADSP2_LOCK_CODE_0 << ADSP2_LOCK_REGION_SHIFT;\n\t\t\tcode1 |= ADSP2_LOCK_CODE_1 << ADSP2_LOCK_REGION_SHIFT;\n\t\t}\n\t\tregmap_write(regmap, lock_reg, code0);\n\t\tregmap_write(regmap, lock_reg, code1);\n\t\tlock_regions >>= 2;\n\t\tlock_reg += 2;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs_dsp_adsp2_enable_memory(struct cs_dsp *dsp)\n{\n\treturn regmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,\n\t\t\t\t  ADSP2_MEM_ENA, ADSP2_MEM_ENA);\n}\n\nstatic void cs_dsp_adsp2_disable_memory(struct cs_dsp *dsp)\n{\n\tregmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,\n\t\t\t   ADSP2_MEM_ENA, 0);\n}\n\nstatic void cs_dsp_adsp2_disable_core(struct cs_dsp *dsp)\n{\n\tregmap_write(dsp->regmap, dsp->base + ADSP2_RDMA_CONFIG_1, 0);\n\tregmap_write(dsp->regmap, dsp->base + ADSP2_WDMA_CONFIG_1, 0);\n\tregmap_write(dsp->regmap, dsp->base + ADSP2_WDMA_CONFIG_2, 0);\n\n\tregmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,\n\t\t\t   ADSP2_SYS_ENA, 0);\n}\n\nstatic void cs_dsp_adsp2v2_disable_core(struct cs_dsp *dsp)\n{\n\tregmap_write(dsp->regmap, dsp->base + ADSP2_RDMA_CONFIG_1, 0);\n\tregmap_write(dsp->regmap, dsp->base + ADSP2_WDMA_CONFIG_1, 0);\n\tregmap_write(dsp->regmap, dsp->base + ADSP2V2_WDMA_CONFIG_2, 0);\n}\n\nstatic int cs_dsp_halo_configure_mpu(struct cs_dsp *dsp, unsigned int lock_regions)\n{\n\tstruct reg_sequence config[] = {\n\t\t{ dsp->base + HALO_MPU_LOCK_CONFIG,     0x5555 },\n\t\t{ dsp->base + HALO_MPU_LOCK_CONFIG,     0xAAAA },\n\t\t{ dsp->base + HALO_MPU_XMEM_ACCESS_0,   0xFFFFFFFF },\n\t\t{ dsp->base + HALO_MPU_YMEM_ACCESS_0,   0xFFFFFFFF },\n\t\t{ dsp->base + HALO_MPU_WINDOW_ACCESS_0, lock_regions },\n\t\t{ dsp->base + HALO_MPU_XREG_ACCESS_0,   lock_regions },\n\t\t{ dsp->base + HALO_MPU_YREG_ACCESS_0,   lock_regions },\n\t\t{ dsp->base + HALO_MPU_XMEM_ACCESS_1,   0xFFFFFFFF },\n\t\t{ dsp->base + HALO_MPU_YMEM_ACCESS_1,   0xFFFFFFFF },\n\t\t{ dsp->base + HALO_MPU_WINDOW_ACCESS_1, lock_regions },\n\t\t{ dsp->base + HALO_MPU_XREG_ACCESS_1,   lock_regions },\n\t\t{ dsp->base + HALO_MPU_YREG_ACCESS_1,   lock_regions },\n\t\t{ dsp->base + HALO_MPU_XMEM_ACCESS_2,   0xFFFFFFFF },\n\t\t{ dsp->base + HALO_MPU_YMEM_ACCESS_2,   0xFFFFFFFF },\n\t\t{ dsp->base + HALO_MPU_WINDOW_ACCESS_2, lock_regions },\n\t\t{ dsp->base + HALO_MPU_XREG_ACCESS_2,   lock_regions },\n\t\t{ dsp->base + HALO_MPU_YREG_ACCESS_2,   lock_regions },\n\t\t{ dsp->base + HALO_MPU_XMEM_ACCESS_3,   0xFFFFFFFF },\n\t\t{ dsp->base + HALO_MPU_YMEM_ACCESS_3,   0xFFFFFFFF },\n\t\t{ dsp->base + HALO_MPU_WINDOW_ACCESS_3, lock_regions },\n\t\t{ dsp->base + HALO_MPU_XREG_ACCESS_3,   lock_regions },\n\t\t{ dsp->base + HALO_MPU_YREG_ACCESS_3,   lock_regions },\n\t\t{ dsp->base + HALO_MPU_LOCK_CONFIG,     0 },\n\t};\n\n\treturn regmap_multi_reg_write(dsp->regmap, config, ARRAY_SIZE(config));\n}\n\n \nint cs_dsp_set_dspclk(struct cs_dsp *dsp, unsigned int freq)\n{\n\tint ret;\n\n\tret = regmap_update_bits(dsp->regmap, dsp->base + ADSP2_CLOCKING,\n\t\t\t\t ADSP2_CLK_SEL_MASK,\n\t\t\t\t freq << ADSP2_CLK_SEL_SHIFT);\n\tif (ret)\n\t\tcs_dsp_err(dsp, \"Failed to set clock rate: %d\\n\", ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_set_dspclk, FW_CS_DSP);\n\nstatic void cs_dsp_stop_watchdog(struct cs_dsp *dsp)\n{\n\tregmap_update_bits(dsp->regmap, dsp->base + ADSP2_WATCHDOG,\n\t\t\t   ADSP2_WDT_ENA_MASK, 0);\n}\n\nstatic void cs_dsp_halo_stop_watchdog(struct cs_dsp *dsp)\n{\n\tregmap_update_bits(dsp->regmap, dsp->base + HALO_WDT_CONTROL,\n\t\t\t   HALO_WDT_EN_MASK, 0);\n}\n\n \nint cs_dsp_power_up(struct cs_dsp *dsp,\n\t\t    const struct firmware *wmfw_firmware, char *wmfw_filename,\n\t\t    const struct firmware *coeff_firmware, char *coeff_filename,\n\t\t    const char *fw_name)\n{\n\tint ret;\n\n\tmutex_lock(&dsp->pwr_lock);\n\n\tdsp->fw_name = fw_name;\n\n\tif (dsp->ops->enable_memory) {\n\t\tret = dsp->ops->enable_memory(dsp);\n\t\tif (ret != 0)\n\t\t\tgoto err_mutex;\n\t}\n\n\tif (dsp->ops->enable_core) {\n\t\tret = dsp->ops->enable_core(dsp);\n\t\tif (ret != 0)\n\t\t\tgoto err_mem;\n\t}\n\n\tret = cs_dsp_load(dsp, wmfw_firmware, wmfw_filename);\n\tif (ret != 0)\n\t\tgoto err_ena;\n\n\tret = dsp->ops->setup_algs(dsp);\n\tif (ret != 0)\n\t\tgoto err_ena;\n\n\tret = cs_dsp_load_coeff(dsp, coeff_firmware, coeff_filename);\n\tif (ret != 0)\n\t\tgoto err_ena;\n\n\t \n\tret = cs_dsp_coeff_init_control_caches(dsp);\n\tif (ret != 0)\n\t\tgoto err_ena;\n\n\tif (dsp->ops->disable_core)\n\t\tdsp->ops->disable_core(dsp);\n\n\tdsp->booted = true;\n\n\tmutex_unlock(&dsp->pwr_lock);\n\n\treturn 0;\nerr_ena:\n\tif (dsp->ops->disable_core)\n\t\tdsp->ops->disable_core(dsp);\nerr_mem:\n\tif (dsp->ops->disable_memory)\n\t\tdsp->ops->disable_memory(dsp);\nerr_mutex:\n\tmutex_unlock(&dsp->pwr_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_power_up, FW_CS_DSP);\n\n \nvoid cs_dsp_power_down(struct cs_dsp *dsp)\n{\n\tstruct cs_dsp_coeff_ctl *ctl;\n\n\tmutex_lock(&dsp->pwr_lock);\n\n\tcs_dsp_debugfs_clear(dsp);\n\n\tdsp->fw_id = 0;\n\tdsp->fw_id_version = 0;\n\n\tdsp->booted = false;\n\n\tif (dsp->ops->disable_memory)\n\t\tdsp->ops->disable_memory(dsp);\n\n\tlist_for_each_entry(ctl, &dsp->ctl_list, list)\n\t\tctl->enabled = 0;\n\n\tcs_dsp_free_alg_regions(dsp);\n\n\tmutex_unlock(&dsp->pwr_lock);\n\n\tcs_dsp_dbg(dsp, \"Shutdown complete\\n\");\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_power_down, FW_CS_DSP);\n\nstatic int cs_dsp_adsp2_start_core(struct cs_dsp *dsp)\n{\n\treturn regmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,\n\t\t\t\t  ADSP2_CORE_ENA | ADSP2_START,\n\t\t\t\t  ADSP2_CORE_ENA | ADSP2_START);\n}\n\nstatic void cs_dsp_adsp2_stop_core(struct cs_dsp *dsp)\n{\n\tregmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,\n\t\t\t   ADSP2_CORE_ENA | ADSP2_START, 0);\n}\n\n \nint cs_dsp_run(struct cs_dsp *dsp)\n{\n\tint ret;\n\n\tmutex_lock(&dsp->pwr_lock);\n\n\tif (!dsp->booted) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tif (dsp->ops->enable_core) {\n\t\tret = dsp->ops->enable_core(dsp);\n\t\tif (ret != 0)\n\t\t\tgoto err;\n\t}\n\n\tif (dsp->client_ops->pre_run) {\n\t\tret = dsp->client_ops->pre_run(dsp);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tret = cs_dsp_coeff_sync_controls(dsp);\n\tif (ret != 0)\n\t\tgoto err;\n\n\tif (dsp->ops->lock_memory) {\n\t\tret = dsp->ops->lock_memory(dsp, dsp->lock_regions);\n\t\tif (ret != 0) {\n\t\t\tcs_dsp_err(dsp, \"Error configuring MPU: %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (dsp->ops->start_core) {\n\t\tret = dsp->ops->start_core(dsp);\n\t\tif (ret != 0)\n\t\t\tgoto err;\n\t}\n\n\tdsp->running = true;\n\n\tif (dsp->client_ops->post_run) {\n\t\tret = dsp->client_ops->post_run(dsp);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tmutex_unlock(&dsp->pwr_lock);\n\n\treturn 0;\n\nerr:\n\tif (dsp->ops->stop_core)\n\t\tdsp->ops->stop_core(dsp);\n\tif (dsp->ops->disable_core)\n\t\tdsp->ops->disable_core(dsp);\n\tmutex_unlock(&dsp->pwr_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_run, FW_CS_DSP);\n\n \nvoid cs_dsp_stop(struct cs_dsp *dsp)\n{\n\t \n\tcs_dsp_signal_event_controls(dsp, CS_DSP_FW_EVENT_SHUTDOWN);\n\n\tif (dsp->ops->stop_watchdog)\n\t\tdsp->ops->stop_watchdog(dsp);\n\n\t \n\tif (dsp->ops->show_fw_status)\n\t\tdsp->ops->show_fw_status(dsp);\n\n\tmutex_lock(&dsp->pwr_lock);\n\n\tif (dsp->client_ops->pre_stop)\n\t\tdsp->client_ops->pre_stop(dsp);\n\n\tdsp->running = false;\n\n\tif (dsp->ops->stop_core)\n\t\tdsp->ops->stop_core(dsp);\n\tif (dsp->ops->disable_core)\n\t\tdsp->ops->disable_core(dsp);\n\n\tif (dsp->client_ops->post_stop)\n\t\tdsp->client_ops->post_stop(dsp);\n\n\tmutex_unlock(&dsp->pwr_lock);\n\n\tcs_dsp_dbg(dsp, \"Execution stopped\\n\");\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_stop, FW_CS_DSP);\n\nstatic int cs_dsp_halo_start_core(struct cs_dsp *dsp)\n{\n\tint ret;\n\n\tret = regmap_update_bits(dsp->regmap, dsp->base + HALO_CCM_CORE_CONTROL,\n\t\t\t\t HALO_CORE_RESET | HALO_CORE_EN,\n\t\t\t\t HALO_CORE_RESET | HALO_CORE_EN);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(dsp->regmap, dsp->base + HALO_CCM_CORE_CONTROL,\n\t\t\t\t  HALO_CORE_RESET, 0);\n}\n\nstatic void cs_dsp_halo_stop_core(struct cs_dsp *dsp)\n{\n\tregmap_update_bits(dsp->regmap, dsp->base + HALO_CCM_CORE_CONTROL,\n\t\t\t   HALO_CORE_EN, 0);\n\n\t \n\tregmap_update_bits(dsp->regmap, dsp->base + HALO_CORE_SOFT_RESET,\n\t\t\t   HALO_CORE_SOFT_RESET_MASK, 1);\n}\n\n \nint cs_dsp_adsp2_init(struct cs_dsp *dsp)\n{\n\tint ret;\n\n\tswitch (dsp->rev) {\n\tcase 0:\n\t\t \n\t\tret = regmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,\n\t\t\t\t\t ADSP2_MEM_ENA, 0);\n\t\tif (ret) {\n\t\t\tcs_dsp_err(dsp,\n\t\t\t\t   \"Failed to clear memory retention: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdsp->ops = &cs_dsp_adsp2_ops[0];\n\t\tbreak;\n\tcase 1:\n\t\tdsp->ops = &cs_dsp_adsp2_ops[1];\n\t\tbreak;\n\tdefault:\n\t\tdsp->ops = &cs_dsp_adsp2_ops[2];\n\t\tbreak;\n\t}\n\n\treturn cs_dsp_common_init(dsp);\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_adsp2_init, FW_CS_DSP);\n\n \nint cs_dsp_halo_init(struct cs_dsp *dsp)\n{\n\tif (dsp->no_core_startstop)\n\t\tdsp->ops = &cs_dsp_halo_ao_ops;\n\telse\n\t\tdsp->ops = &cs_dsp_halo_ops;\n\n\treturn cs_dsp_common_init(dsp);\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_halo_init, FW_CS_DSP);\n\n \nvoid cs_dsp_remove(struct cs_dsp *dsp)\n{\n\tstruct cs_dsp_coeff_ctl *ctl;\n\n\twhile (!list_empty(&dsp->ctl_list)) {\n\t\tctl = list_first_entry(&dsp->ctl_list, struct cs_dsp_coeff_ctl, list);\n\n\t\tif (dsp->client_ops->control_remove)\n\t\t\tdsp->client_ops->control_remove(ctl);\n\n\t\tlist_del(&ctl->list);\n\t\tcs_dsp_free_ctl_blk(ctl);\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_remove, FW_CS_DSP);\n\n \nint cs_dsp_read_raw_data_block(struct cs_dsp *dsp, int mem_type, unsigned int mem_addr,\n\t\t\t       unsigned int num_words, __be32 *data)\n{\n\tstruct cs_dsp_region const *mem = cs_dsp_find_region(dsp, mem_type);\n\tunsigned int reg;\n\tint ret;\n\n\tlockdep_assert_held(&dsp->pwr_lock);\n\n\tif (!mem)\n\t\treturn -EINVAL;\n\n\treg = dsp->ops->region_to_reg(mem, mem_addr);\n\n\tret = regmap_raw_read(dsp->regmap, reg, data,\n\t\t\t      sizeof(*data) * num_words);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_read_raw_data_block, FW_CS_DSP);\n\n \nint cs_dsp_read_data_word(struct cs_dsp *dsp, int mem_type, unsigned int mem_addr, u32 *data)\n{\n\t__be32 raw;\n\tint ret;\n\n\tret = cs_dsp_read_raw_data_block(dsp, mem_type, mem_addr, 1, &raw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*data = be32_to_cpu(raw) & 0x00ffffffu;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_read_data_word, FW_CS_DSP);\n\n \nint cs_dsp_write_data_word(struct cs_dsp *dsp, int mem_type, unsigned int mem_addr, u32 data)\n{\n\tstruct cs_dsp_region const *mem = cs_dsp_find_region(dsp, mem_type);\n\t__be32 val = cpu_to_be32(data & 0x00ffffffu);\n\tunsigned int reg;\n\n\tlockdep_assert_held(&dsp->pwr_lock);\n\n\tif (!mem)\n\t\treturn -EINVAL;\n\n\treg = dsp->ops->region_to_reg(mem, mem_addr);\n\n\treturn regmap_raw_write(dsp->regmap, reg, &val, sizeof(val));\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_write_data_word, FW_CS_DSP);\n\n \nvoid cs_dsp_remove_padding(u32 *buf, int nwords)\n{\n\tconst __be32 *pack_in = (__be32 *)buf;\n\tu8 *pack_out = (u8 *)buf;\n\tint i;\n\n\tfor (i = 0; i < nwords; i++) {\n\t\tu32 word = be32_to_cpu(*pack_in++);\n\t\t*pack_out++ = (u8)word;\n\t\t*pack_out++ = (u8)(word >> 8);\n\t\t*pack_out++ = (u8)(word >> 16);\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_remove_padding, FW_CS_DSP);\n\n \nvoid cs_dsp_adsp2_bus_error(struct cs_dsp *dsp)\n{\n\tunsigned int val;\n\tstruct regmap *regmap = dsp->regmap;\n\tint ret = 0;\n\n\tmutex_lock(&dsp->pwr_lock);\n\n\tret = regmap_read(regmap, dsp->base + ADSP2_LOCK_REGION_CTRL, &val);\n\tif (ret) {\n\t\tcs_dsp_err(dsp,\n\t\t\t   \"Failed to read Region Lock Ctrl register: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tif (val & ADSP2_WDT_TIMEOUT_STS_MASK) {\n\t\tcs_dsp_err(dsp, \"watchdog timeout error\\n\");\n\t\tdsp->ops->stop_watchdog(dsp);\n\t\tif (dsp->client_ops->watchdog_expired)\n\t\t\tdsp->client_ops->watchdog_expired(dsp);\n\t}\n\n\tif (val & (ADSP2_ADDR_ERR_MASK | ADSP2_REGION_LOCK_ERR_MASK)) {\n\t\tif (val & ADSP2_ADDR_ERR_MASK)\n\t\t\tcs_dsp_err(dsp, \"bus error: address error\\n\");\n\t\telse\n\t\t\tcs_dsp_err(dsp, \"bus error: region lock error\\n\");\n\n\t\tret = regmap_read(regmap, dsp->base + ADSP2_BUS_ERR_ADDR, &val);\n\t\tif (ret) {\n\t\t\tcs_dsp_err(dsp,\n\t\t\t\t   \"Failed to read Bus Err Addr register: %d\\n\",\n\t\t\t\t   ret);\n\t\t\tgoto error;\n\t\t}\n\n\t\tcs_dsp_err(dsp, \"bus error address = 0x%x\\n\",\n\t\t\t   val & ADSP2_BUS_ERR_ADDR_MASK);\n\n\t\tret = regmap_read(regmap,\n\t\t\t\t  dsp->base + ADSP2_PMEM_ERR_ADDR_XMEM_ERR_ADDR,\n\t\t\t\t  &val);\n\t\tif (ret) {\n\t\t\tcs_dsp_err(dsp,\n\t\t\t\t   \"Failed to read Pmem Xmem Err Addr register: %d\\n\",\n\t\t\t\t   ret);\n\t\t\tgoto error;\n\t\t}\n\n\t\tcs_dsp_err(dsp, \"xmem error address = 0x%x\\n\",\n\t\t\t   val & ADSP2_XMEM_ERR_ADDR_MASK);\n\t\tcs_dsp_err(dsp, \"pmem error address = 0x%x\\n\",\n\t\t\t   (val & ADSP2_PMEM_ERR_ADDR_MASK) >>\n\t\t\t   ADSP2_PMEM_ERR_ADDR_SHIFT);\n\t}\n\n\tregmap_update_bits(regmap, dsp->base + ADSP2_LOCK_REGION_CTRL,\n\t\t\t   ADSP2_CTRL_ERR_EINT, ADSP2_CTRL_ERR_EINT);\n\nerror:\n\tmutex_unlock(&dsp->pwr_lock);\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_adsp2_bus_error, FW_CS_DSP);\n\n \nvoid cs_dsp_halo_bus_error(struct cs_dsp *dsp)\n{\n\tstruct regmap *regmap = dsp->regmap;\n\tunsigned int fault[6];\n\tstruct reg_sequence clear[] = {\n\t\t{ dsp->base + HALO_MPU_XM_VIO_STATUS,     0x0 },\n\t\t{ dsp->base + HALO_MPU_YM_VIO_STATUS,     0x0 },\n\t\t{ dsp->base + HALO_MPU_PM_VIO_STATUS,     0x0 },\n\t};\n\tint ret;\n\n\tmutex_lock(&dsp->pwr_lock);\n\n\tret = regmap_read(regmap, dsp->base_sysinfo + HALO_AHBM_WINDOW_DEBUG_1,\n\t\t\t  fault);\n\tif (ret) {\n\t\tcs_dsp_warn(dsp, \"Failed to read AHB DEBUG_1: %d\\n\", ret);\n\t\tgoto exit_unlock;\n\t}\n\n\tcs_dsp_warn(dsp, \"AHB: STATUS: 0x%x ADDR: 0x%x\\n\",\n\t\t    *fault & HALO_AHBM_FLAGS_ERR_MASK,\n\t\t    (*fault & HALO_AHBM_CORE_ERR_ADDR_MASK) >>\n\t\t    HALO_AHBM_CORE_ERR_ADDR_SHIFT);\n\n\tret = regmap_read(regmap, dsp->base_sysinfo + HALO_AHBM_WINDOW_DEBUG_0,\n\t\t\t  fault);\n\tif (ret) {\n\t\tcs_dsp_warn(dsp, \"Failed to read AHB DEBUG_0: %d\\n\", ret);\n\t\tgoto exit_unlock;\n\t}\n\n\tcs_dsp_warn(dsp, \"AHB: SYS_ADDR: 0x%x\\n\", *fault);\n\n\tret = regmap_bulk_read(regmap, dsp->base + HALO_MPU_XM_VIO_ADDR,\n\t\t\t       fault, ARRAY_SIZE(fault));\n\tif (ret) {\n\t\tcs_dsp_warn(dsp, \"Failed to read MPU fault info: %d\\n\", ret);\n\t\tgoto exit_unlock;\n\t}\n\n\tcs_dsp_warn(dsp, \"XM: STATUS:0x%x ADDR:0x%x\\n\", fault[1], fault[0]);\n\tcs_dsp_warn(dsp, \"YM: STATUS:0x%x ADDR:0x%x\\n\", fault[3], fault[2]);\n\tcs_dsp_warn(dsp, \"PM: STATUS:0x%x ADDR:0x%x\\n\", fault[5], fault[4]);\n\n\tret = regmap_multi_reg_write(dsp->regmap, clear, ARRAY_SIZE(clear));\n\tif (ret)\n\t\tcs_dsp_warn(dsp, \"Failed to clear MPU status: %d\\n\", ret);\n\nexit_unlock:\n\tmutex_unlock(&dsp->pwr_lock);\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_halo_bus_error, FW_CS_DSP);\n\n \nvoid cs_dsp_halo_wdt_expire(struct cs_dsp *dsp)\n{\n\tmutex_lock(&dsp->pwr_lock);\n\n\tcs_dsp_warn(dsp, \"WDT Expiry Fault\\n\");\n\n\tdsp->ops->stop_watchdog(dsp);\n\tif (dsp->client_ops->watchdog_expired)\n\t\tdsp->client_ops->watchdog_expired(dsp);\n\n\tmutex_unlock(&dsp->pwr_lock);\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_halo_wdt_expire, FW_CS_DSP);\n\nstatic const struct cs_dsp_ops cs_dsp_adsp1_ops = {\n\t.validate_version = cs_dsp_validate_version,\n\t.parse_sizes = cs_dsp_adsp1_parse_sizes,\n\t.region_to_reg = cs_dsp_region_to_reg,\n};\n\nstatic const struct cs_dsp_ops cs_dsp_adsp2_ops[] = {\n\t{\n\t\t.parse_sizes = cs_dsp_adsp2_parse_sizes,\n\t\t.validate_version = cs_dsp_validate_version,\n\t\t.setup_algs = cs_dsp_adsp2_setup_algs,\n\t\t.region_to_reg = cs_dsp_region_to_reg,\n\n\t\t.show_fw_status = cs_dsp_adsp2_show_fw_status,\n\n\t\t.enable_memory = cs_dsp_adsp2_enable_memory,\n\t\t.disable_memory = cs_dsp_adsp2_disable_memory,\n\n\t\t.enable_core = cs_dsp_adsp2_enable_core,\n\t\t.disable_core = cs_dsp_adsp2_disable_core,\n\n\t\t.start_core = cs_dsp_adsp2_start_core,\n\t\t.stop_core = cs_dsp_adsp2_stop_core,\n\n\t},\n\t{\n\t\t.parse_sizes = cs_dsp_adsp2_parse_sizes,\n\t\t.validate_version = cs_dsp_validate_version,\n\t\t.setup_algs = cs_dsp_adsp2_setup_algs,\n\t\t.region_to_reg = cs_dsp_region_to_reg,\n\n\t\t.show_fw_status = cs_dsp_adsp2v2_show_fw_status,\n\n\t\t.enable_memory = cs_dsp_adsp2_enable_memory,\n\t\t.disable_memory = cs_dsp_adsp2_disable_memory,\n\t\t.lock_memory = cs_dsp_adsp2_lock,\n\n\t\t.enable_core = cs_dsp_adsp2v2_enable_core,\n\t\t.disable_core = cs_dsp_adsp2v2_disable_core,\n\n\t\t.start_core = cs_dsp_adsp2_start_core,\n\t\t.stop_core = cs_dsp_adsp2_stop_core,\n\t},\n\t{\n\t\t.parse_sizes = cs_dsp_adsp2_parse_sizes,\n\t\t.validate_version = cs_dsp_validate_version,\n\t\t.setup_algs = cs_dsp_adsp2_setup_algs,\n\t\t.region_to_reg = cs_dsp_region_to_reg,\n\n\t\t.show_fw_status = cs_dsp_adsp2v2_show_fw_status,\n\t\t.stop_watchdog = cs_dsp_stop_watchdog,\n\n\t\t.enable_memory = cs_dsp_adsp2_enable_memory,\n\t\t.disable_memory = cs_dsp_adsp2_disable_memory,\n\t\t.lock_memory = cs_dsp_adsp2_lock,\n\n\t\t.enable_core = cs_dsp_adsp2v2_enable_core,\n\t\t.disable_core = cs_dsp_adsp2v2_disable_core,\n\n\t\t.start_core = cs_dsp_adsp2_start_core,\n\t\t.stop_core = cs_dsp_adsp2_stop_core,\n\t},\n};\n\nstatic const struct cs_dsp_ops cs_dsp_halo_ops = {\n\t.parse_sizes = cs_dsp_adsp2_parse_sizes,\n\t.validate_version = cs_dsp_halo_validate_version,\n\t.setup_algs = cs_dsp_halo_setup_algs,\n\t.region_to_reg = cs_dsp_halo_region_to_reg,\n\n\t.show_fw_status = cs_dsp_halo_show_fw_status,\n\t.stop_watchdog = cs_dsp_halo_stop_watchdog,\n\n\t.lock_memory = cs_dsp_halo_configure_mpu,\n\n\t.start_core = cs_dsp_halo_start_core,\n\t.stop_core = cs_dsp_halo_stop_core,\n};\n\nstatic const struct cs_dsp_ops cs_dsp_halo_ao_ops = {\n\t.parse_sizes = cs_dsp_adsp2_parse_sizes,\n\t.validate_version = cs_dsp_halo_validate_version,\n\t.setup_algs = cs_dsp_halo_setup_algs,\n\t.region_to_reg = cs_dsp_halo_region_to_reg,\n\t.show_fw_status = cs_dsp_halo_show_fw_status,\n};\n\n \nint cs_dsp_chunk_write(struct cs_dsp_chunk *ch, int nbits, u32 val)\n{\n\tint nwrite, i;\n\n\tnwrite = min(CS_DSP_DATA_WORD_BITS - ch->cachebits, nbits);\n\n\tch->cache <<= nwrite;\n\tch->cache |= val >> (nbits - nwrite);\n\tch->cachebits += nwrite;\n\tnbits -= nwrite;\n\n\tif (ch->cachebits == CS_DSP_DATA_WORD_BITS) {\n\t\tif (cs_dsp_chunk_end(ch))\n\t\t\treturn -ENOSPC;\n\n\t\tch->cache &= 0xFFFFFF;\n\t\tfor (i = 0; i < sizeof(ch->cache); i++, ch->cache <<= BITS_PER_BYTE)\n\t\t\t*ch->data++ = (ch->cache & 0xFF000000) >> CS_DSP_DATA_WORD_BITS;\n\n\t\tch->bytes += sizeof(ch->cache);\n\t\tch->cachebits = 0;\n\t}\n\n\tif (nbits)\n\t\treturn cs_dsp_chunk_write(ch, nbits, val);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_chunk_write, FW_CS_DSP);\n\n \nint cs_dsp_chunk_flush(struct cs_dsp_chunk *ch)\n{\n\tif (!ch->cachebits)\n\t\treturn 0;\n\n\treturn cs_dsp_chunk_write(ch, CS_DSP_DATA_WORD_BITS - ch->cachebits, 0);\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_chunk_flush, FW_CS_DSP);\n\n \nint cs_dsp_chunk_read(struct cs_dsp_chunk *ch, int nbits)\n{\n\tint nread, i;\n\tu32 result;\n\n\tif (!ch->cachebits) {\n\t\tif (cs_dsp_chunk_end(ch))\n\t\t\treturn -ENOSPC;\n\n\t\tch->cache = 0;\n\t\tch->cachebits = CS_DSP_DATA_WORD_BITS;\n\n\t\tfor (i = 0; i < sizeof(ch->cache); i++, ch->cache <<= BITS_PER_BYTE)\n\t\t\tch->cache |= *ch->data++;\n\n\t\tch->bytes += sizeof(ch->cache);\n\t}\n\n\tnread = min(ch->cachebits, nbits);\n\tnbits -= nread;\n\n\tresult = ch->cache >> ((sizeof(ch->cache) * BITS_PER_BYTE) - nread);\n\tch->cache <<= nread;\n\tch->cachebits -= nread;\n\n\tif (nbits)\n\t\tresult = (result << nbits) | cs_dsp_chunk_read(ch, nbits);\n\n\treturn result;\n}\nEXPORT_SYMBOL_NS_GPL(cs_dsp_chunk_read, FW_CS_DSP);\n\nMODULE_DESCRIPTION(\"Cirrus Logic DSP Support\");\nMODULE_AUTHOR(\"Simon Trimmer <simont@opensource.cirrus.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}