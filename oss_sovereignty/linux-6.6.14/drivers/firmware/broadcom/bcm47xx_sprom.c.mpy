{
  "module_name": "bcm47xx_sprom.c",
  "hash_id": "d2d95945e38861027c2d7213f45dde0ff7f5bcd642924bff969ab5afafb50f1b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/broadcom/bcm47xx_sprom.c",
  "human_readable_source": " \n\n#include <linux/bcm47xx_nvram.h>\n#include <linux/bcm47xx_sprom.h>\n#include <linux/bcma/bcma.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n#include <linux/ssb/ssb.h>\n\nstatic void create_key(const char *prefix, const char *postfix,\n\t\t       const char *name, char *buf, int len)\n{\n\tif (prefix && postfix)\n\t\tsnprintf(buf, len, \"%s%s%s\", prefix, name, postfix);\n\telse if (prefix)\n\t\tsnprintf(buf, len, \"%s%s\", prefix, name);\n\telse if (postfix)\n\t\tsnprintf(buf, len, \"%s%s\", name, postfix);\n\telse\n\t\tsnprintf(buf, len, \"%s\", name);\n}\n\nstatic int get_nvram_var(const char *prefix, const char *postfix,\n\t\t\t const char *name, char *buf, int len, bool fallback)\n{\n\tchar key[40];\n\tint err;\n\n\tcreate_key(prefix, postfix, name, key, sizeof(key));\n\n\terr = bcm47xx_nvram_getenv(key, buf, len);\n\tif (fallback && err == -ENOENT && prefix) {\n\t\tcreate_key(NULL, postfix, name, key, sizeof(key));\n\t\terr = bcm47xx_nvram_getenv(key, buf, len);\n\t}\n\treturn err;\n}\n\n#define NVRAM_READ_VAL(type)\t\t\t\t\t\t\\\nstatic void nvram_read_ ## type(const char *prefix,\t\t\t\\\n\t\t\t\tconst char *postfix, const char *name,\t\\\n\t\t\t\ttype *val, type allset, bool fallback)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tchar buf[100];\t\t\t\t\t\t\t\\\n\tint err;\t\t\t\t\t\t\t\\\n\ttype var;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\terr = get_nvram_var(prefix, postfix, name, buf, sizeof(buf),\t\\\n\t\t\t    fallback);\t\t\t\t\t\\\n\tif (err < 0)\t\t\t\t\t\t\t\\\n\t\treturn;\t\t\t\t\t\t\t\\\n\terr = kstrto ## type(strim(buf), 0, &var);\t\t\t\\\n\tif (err) {\t\t\t\t\t\t\t\\\n\t\tpr_warn(\"can not parse nvram name %s%s%s with value %s got %i\\n\",\t\\\n\t\t\tprefix, name, postfix, buf, err);\t\t\\\n\t\treturn;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tif (allset && var == allset)\t\t\t\t\t\\\n\t\treturn;\t\t\t\t\t\t\t\\\n\t*val = var;\t\t\t\t\t\t\t\\\n}\n\nNVRAM_READ_VAL(u8)\nNVRAM_READ_VAL(s8)\nNVRAM_READ_VAL(u16)\nNVRAM_READ_VAL(u32)\n\n#undef NVRAM_READ_VAL\n\nstatic void nvram_read_u32_2(const char *prefix, const char *name,\n\t\t\t     u16 *val_lo, u16 *val_hi, bool fallback)\n{\n\tchar buf[100];\n\tint err;\n\tu32 val;\n\n\terr = get_nvram_var(prefix, NULL, name, buf, sizeof(buf), fallback);\n\tif (err < 0)\n\t\treturn;\n\terr = kstrtou32(strim(buf), 0, &val);\n\tif (err) {\n\t\tpr_warn(\"can not parse nvram name %s%s with value %s got %i\\n\",\n\t\t\tprefix, name, buf, err);\n\t\treturn;\n\t}\n\t*val_lo = (val & 0x0000FFFFU);\n\t*val_hi = (val & 0xFFFF0000U) >> 16;\n}\n\nstatic void nvram_read_leddc(const char *prefix, const char *name,\n\t\t\t     u8 *leddc_on_time, u8 *leddc_off_time,\n\t\t\t     bool fallback)\n{\n\tchar buf[100];\n\tint err;\n\tu32 val;\n\n\terr = get_nvram_var(prefix, NULL, name, buf, sizeof(buf), fallback);\n\tif (err < 0)\n\t\treturn;\n\terr = kstrtou32(strim(buf), 0, &val);\n\tif (err) {\n\t\tpr_warn(\"can not parse nvram name %s%s with value %s got %i\\n\",\n\t\t\tprefix, name, buf, err);\n\t\treturn;\n\t}\n\n\tif (val == 0xffff || val == 0xffffffff)\n\t\treturn;\n\n\t*leddc_on_time = val & 0xff;\n\t*leddc_off_time = (val >> 16) & 0xff;\n}\n\nstatic void nvram_read_macaddr(const char *prefix, const char *name,\n\t\t\t       u8 val[6], bool fallback)\n{\n\tchar buf[100];\n\tint err;\n\n\terr = get_nvram_var(prefix, NULL, name, buf, sizeof(buf), fallback);\n\tif (err < 0)\n\t\treturn;\n\n\tstrreplace(buf, '-', ':');\n\tif (!mac_pton(buf, val))\n\t\tpr_warn(\"Can not parse mac address: %s\\n\", buf);\n}\n\nstatic void nvram_read_alpha2(const char *prefix, const char *name,\n\t\t\t     char val[2], bool fallback)\n{\n\tchar buf[10];\n\tint err;\n\n\terr = get_nvram_var(prefix, NULL, name, buf, sizeof(buf), fallback);\n\tif (err < 0)\n\t\treturn;\n\tif (buf[0] == '0')\n\t\treturn;\n\tif (strlen(buf) > 2) {\n\t\tpr_warn(\"alpha2 is too long %s\\n\", buf);\n\t\treturn;\n\t}\n\tmemcpy(val, buf, 2);\n}\n\n \n#define ENTRY(_revmask, _type, _prefix, _name, _val, _allset, _fallback) \\\n\tif (_revmask & BIT(sprom->revision)) \\\n\t\tnvram_read_ ## _type(_prefix, NULL, _name, &sprom->_val, \\\n\t\t\t\t     _allset, _fallback)\n \nstatic void bcm47xx_sprom_fill_auto(struct ssb_sprom *sprom,\n\t\t\t\t    const char *prefix, bool fallback)\n{\n\tconst char *pre = prefix;\n\tbool fb = fallback;\n\n\t \n\tENTRY(0xfffffffe, u16, pre, \"devid\", dev_id, 0, fallback);\n\n\tENTRY(0xfffffffe, u16, pre, \"boardrev\", board_rev, 0, true);\n\tENTRY(0xfffffffe, u32, pre, \"boardflags\", boardflags, 0, fb);\n\tENTRY(0xfffffff0, u32, pre, \"boardflags2\", boardflags2, 0, fb);\n\tENTRY(0xfffff800, u32, pre, \"boardflags3\", boardflags3, 0, fb);\n\tENTRY(0x00000002, u16, pre, \"boardflags\", boardflags_lo, 0, fb);\n\tENTRY(0xfffffffc, u16, pre, \"boardtype\", board_type, 0, true);\n\tENTRY(0xfffffffe, u16, pre, \"boardnum\", board_num, 0, fb);\n\tENTRY(0x00000002, u8, pre, \"cc\", country_code, 0, fb);\n\tENTRY(0xfffffff8, u8, pre, \"regrev\", regrev, 0, fb);\n\n\tENTRY(0xfffffffe, u8, pre, \"ledbh0\", gpio0, 0xff, fb);\n\tENTRY(0xfffffffe, u8, pre, \"ledbh1\", gpio1, 0xff, fb);\n\tENTRY(0xfffffffe, u8, pre, \"ledbh2\", gpio2, 0xff, fb);\n\tENTRY(0xfffffffe, u8, pre, \"ledbh3\", gpio3, 0xff, fb);\n\n\tENTRY(0x0000070e, u16, pre, \"pa0b0\", pa0b0, 0, fb);\n\tENTRY(0x0000070e, u16, pre, \"pa0b1\", pa0b1, 0, fb);\n\tENTRY(0x0000070e, u16, pre, \"pa0b2\", pa0b2, 0, fb);\n\tENTRY(0x0000070e, u8, pre, \"pa0itssit\", itssi_bg, 0, fb);\n\tENTRY(0x0000070e, u8, pre, \"pa0maxpwr\", maxpwr_bg, 0, fb);\n\n\tENTRY(0x0000070c, u8, pre, \"opo\", opo, 0, fb);\n\tENTRY(0xfffffffe, u8, pre, \"aa2g\", ant_available_bg, 0, fb);\n\tENTRY(0xfffffffe, u8, pre, \"aa5g\", ant_available_a, 0, fb);\n\tENTRY(0x000007fe, s8, pre, \"ag0\", antenna_gain.a0, 0, fb);\n\tENTRY(0x000007fe, s8, pre, \"ag1\", antenna_gain.a1, 0, fb);\n\tENTRY(0x000007f0, s8, pre, \"ag2\", antenna_gain.a2, 0, fb);\n\tENTRY(0x000007f0, s8, pre, \"ag3\", antenna_gain.a3, 0, fb);\n\n\tENTRY(0x0000070e, u16, pre, \"pa1b0\", pa1b0, 0, fb);\n\tENTRY(0x0000070e, u16, pre, \"pa1b1\", pa1b1, 0, fb);\n\tENTRY(0x0000070e, u16, pre, \"pa1b2\", pa1b2, 0, fb);\n\tENTRY(0x0000070c, u16, pre, \"pa1lob0\", pa1lob0, 0, fb);\n\tENTRY(0x0000070c, u16, pre, \"pa1lob1\", pa1lob1, 0, fb);\n\tENTRY(0x0000070c, u16, pre, \"pa1lob2\", pa1lob2, 0, fb);\n\tENTRY(0x0000070c, u16, pre, \"pa1hib0\", pa1hib0, 0, fb);\n\tENTRY(0x0000070c, u16, pre, \"pa1hib1\", pa1hib1, 0, fb);\n\tENTRY(0x0000070c, u16, pre, \"pa1hib2\", pa1hib2, 0, fb);\n\tENTRY(0x0000070e, u8, pre, \"pa1itssit\", itssi_a, 0, fb);\n\tENTRY(0x0000070e, u8, pre, \"pa1maxpwr\", maxpwr_a, 0, fb);\n\tENTRY(0x0000070c, u8, pre, \"pa1lomaxpwr\", maxpwr_al, 0, fb);\n\tENTRY(0x0000070c, u8, pre, \"pa1himaxpwr\", maxpwr_ah, 0, fb);\n\n\tENTRY(0x00000708, u8, pre, \"bxa2g\", bxa2g, 0, fb);\n\tENTRY(0x00000708, u8, pre, \"rssisav2g\", rssisav2g, 0, fb);\n\tENTRY(0x00000708, u8, pre, \"rssismc2g\", rssismc2g, 0, fb);\n\tENTRY(0x00000708, u8, pre, \"rssismf2g\", rssismf2g, 0, fb);\n\tENTRY(0x00000708, u8, pre, \"bxa5g\", bxa5g, 0, fb);\n\tENTRY(0x00000708, u8, pre, \"rssisav5g\", rssisav5g, 0, fb);\n\tENTRY(0x00000708, u8, pre, \"rssismc5g\", rssismc5g, 0, fb);\n\tENTRY(0x00000708, u8, pre, \"rssismf5g\", rssismf5g, 0, fb);\n\tENTRY(0x00000708, u8, pre, \"tri2g\", tri2g, 0, fb);\n\tENTRY(0x00000708, u8, pre, \"tri5g\", tri5g, 0, fb);\n\tENTRY(0x00000708, u8, pre, \"tri5gl\", tri5gl, 0, fb);\n\tENTRY(0x00000708, u8, pre, \"tri5gh\", tri5gh, 0, fb);\n\tENTRY(0x00000708, s8, pre, \"rxpo2g\", rxpo2g, 0, fb);\n\tENTRY(0x00000708, s8, pre, \"rxpo5g\", rxpo5g, 0, fb);\n\tENTRY(0xfffffff0, u8, pre, \"txchain\", txchain, 0xf, fb);\n\tENTRY(0xfffffff0, u8, pre, \"rxchain\", rxchain, 0xf, fb);\n\tENTRY(0xfffffff0, u8, pre, \"antswitch\", antswitch, 0xff, fb);\n\tENTRY(0x00000700, u8, pre, \"tssipos2g\", fem.ghz2.tssipos, 0, fb);\n\tENTRY(0x00000700, u8, pre, \"extpagain2g\", fem.ghz2.extpa_gain, 0, fb);\n\tENTRY(0x00000700, u8, pre, \"pdetrange2g\", fem.ghz2.pdet_range, 0, fb);\n\tENTRY(0x00000700, u8, pre, \"triso2g\", fem.ghz2.tr_iso, 0, fb);\n\tENTRY(0x00000700, u8, pre, \"antswctl2g\", fem.ghz2.antswlut, 0, fb);\n\tENTRY(0x00000700, u8, pre, \"tssipos5g\", fem.ghz5.tssipos, 0, fb);\n\tENTRY(0x00000700, u8, pre, \"extpagain5g\", fem.ghz5.extpa_gain, 0, fb);\n\tENTRY(0x00000700, u8, pre, \"pdetrange5g\", fem.ghz5.pdet_range, 0, fb);\n\tENTRY(0x00000700, u8, pre, \"triso5g\", fem.ghz5.tr_iso, 0, fb);\n\tENTRY(0x00000700, u8, pre, \"antswctl5g\", fem.ghz5.antswlut, 0, fb);\n\tENTRY(0x000000f0, u8, pre, \"txpid2ga0\", txpid2g[0], 0, fb);\n\tENTRY(0x000000f0, u8, pre, \"txpid2ga1\", txpid2g[1], 0, fb);\n\tENTRY(0x000000f0, u8, pre, \"txpid2ga2\", txpid2g[2], 0, fb);\n\tENTRY(0x000000f0, u8, pre, \"txpid2ga3\", txpid2g[3], 0, fb);\n\tENTRY(0x000000f0, u8, pre, \"txpid5ga0\", txpid5g[0], 0, fb);\n\tENTRY(0x000000f0, u8, pre, \"txpid5ga1\", txpid5g[1], 0, fb);\n\tENTRY(0x000000f0, u8, pre, \"txpid5ga2\", txpid5g[2], 0, fb);\n\tENTRY(0x000000f0, u8, pre, \"txpid5ga3\", txpid5g[3], 0, fb);\n\tENTRY(0x000000f0, u8, pre, \"txpid5gla0\", txpid5gl[0], 0, fb);\n\tENTRY(0x000000f0, u8, pre, \"txpid5gla1\", txpid5gl[1], 0, fb);\n\tENTRY(0x000000f0, u8, pre, \"txpid5gla2\", txpid5gl[2], 0, fb);\n\tENTRY(0x000000f0, u8, pre, \"txpid5gla3\", txpid5gl[3], 0, fb);\n\tENTRY(0x000000f0, u8, pre, \"txpid5gha0\", txpid5gh[0], 0, fb);\n\tENTRY(0x000000f0, u8, pre, \"txpid5gha1\", txpid5gh[1], 0, fb);\n\tENTRY(0x000000f0, u8, pre, \"txpid5gha2\", txpid5gh[2], 0, fb);\n\tENTRY(0x000000f0, u8, pre, \"txpid5gha3\", txpid5gh[3], 0, fb);\n\n\tENTRY(0xffffff00, u8, pre, \"tempthresh\", tempthresh, 0, fb);\n\tENTRY(0xffffff00, u8, pre, \"tempoffset\", tempoffset, 0, fb);\n\tENTRY(0xffffff00, u16, pre, \"rawtempsense\", rawtempsense, 0, fb);\n\tENTRY(0xffffff00, u8, pre, \"measpower\", measpower, 0, fb);\n\tENTRY(0xffffff00, u8, pre, \"tempsense_slope\", tempsense_slope, 0, fb);\n\tENTRY(0xffffff00, u8, pre, \"tempcorrx\", tempcorrx, 0, fb);\n\tENTRY(0xffffff00, u8, pre, \"tempsense_option\", tempsense_option, 0, fb);\n\tENTRY(0x00000700, u8, pre, \"freqoffset_corr\", freqoffset_corr, 0, fb);\n\tENTRY(0x00000700, u8, pre, \"iqcal_swp_dis\", iqcal_swp_dis, 0, fb);\n\tENTRY(0x00000700, u8, pre, \"hw_iqcal_en\", hw_iqcal_en, 0, fb);\n\tENTRY(0x00000700, u8, pre, \"elna2g\", elna2g, 0, fb);\n\tENTRY(0x00000700, u8, pre, \"elna5g\", elna5g, 0, fb);\n\tENTRY(0xffffff00, u8, pre, \"phycal_tempdelta\", phycal_tempdelta, 0, fb);\n\tENTRY(0xffffff00, u8, pre, \"temps_period\", temps_period, 0, fb);\n\tENTRY(0xffffff00, u8, pre, \"temps_hysteresis\", temps_hysteresis, 0, fb);\n\tENTRY(0xffffff00, u8, pre, \"measpower1\", measpower1, 0, fb);\n\tENTRY(0xffffff00, u8, pre, \"measpower2\", measpower2, 0, fb);\n\n\tENTRY(0x000001f0, u16, pre, \"cck2gpo\", cck2gpo, 0, fb);\n\tENTRY(0x000001f0, u32, pre, \"ofdm2gpo\", ofdm2gpo, 0, fb);\n\tENTRY(0x000001f0, u32, pre, \"ofdm5gpo\", ofdm5gpo, 0, fb);\n\tENTRY(0x000001f0, u32, pre, \"ofdm5glpo\", ofdm5glpo, 0, fb);\n\tENTRY(0x000001f0, u32, pre, \"ofdm5ghpo\", ofdm5ghpo, 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs2gpo0\", mcs2gpo[0], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs2gpo1\", mcs2gpo[1], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs2gpo2\", mcs2gpo[2], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs2gpo3\", mcs2gpo[3], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs2gpo4\", mcs2gpo[4], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs2gpo5\", mcs2gpo[5], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs2gpo6\", mcs2gpo[6], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs2gpo7\", mcs2gpo[7], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5gpo0\", mcs5gpo[0], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5gpo1\", mcs5gpo[1], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5gpo2\", mcs5gpo[2], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5gpo3\", mcs5gpo[3], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5gpo4\", mcs5gpo[4], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5gpo5\", mcs5gpo[5], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5gpo6\", mcs5gpo[6], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5gpo7\", mcs5gpo[7], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5glpo0\", mcs5glpo[0], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5glpo1\", mcs5glpo[1], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5glpo2\", mcs5glpo[2], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5glpo3\", mcs5glpo[3], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5glpo4\", mcs5glpo[4], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5glpo5\", mcs5glpo[5], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5glpo6\", mcs5glpo[6], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5glpo7\", mcs5glpo[7], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5ghpo0\", mcs5ghpo[0], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5ghpo1\", mcs5ghpo[1], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5ghpo2\", mcs5ghpo[2], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5ghpo3\", mcs5ghpo[3], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5ghpo4\", mcs5ghpo[4], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5ghpo5\", mcs5ghpo[5], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5ghpo6\", mcs5ghpo[6], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"mcs5ghpo7\", mcs5ghpo[7], 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"cddpo\", cddpo, 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"stbcpo\", stbcpo, 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"bw40po\", bw40po, 0, fb);\n\tENTRY(0x000001f0, u16, pre, \"bwduppo\", bwduppo, 0, fb);\n\n\tENTRY(0xfffffe00, u16, pre, \"cckbw202gpo\", cckbw202gpo, 0, fb);\n\tENTRY(0xfffffe00, u16, pre, \"cckbw20ul2gpo\", cckbw20ul2gpo, 0, fb);\n\tENTRY(0x00000600, u32, pre, \"legofdmbw202gpo\", legofdmbw202gpo, 0, fb);\n\tENTRY(0x00000600, u32, pre, \"legofdmbw20ul2gpo\", legofdmbw20ul2gpo, 0, fb);\n\tENTRY(0x00000600, u32, pre, \"legofdmbw205glpo\", legofdmbw205glpo, 0, fb);\n\tENTRY(0x00000600, u32, pre, \"legofdmbw20ul5glpo\", legofdmbw20ul5glpo, 0, fb);\n\tENTRY(0x00000600, u32, pre, \"legofdmbw205gmpo\", legofdmbw205gmpo, 0, fb);\n\tENTRY(0x00000600, u32, pre, \"legofdmbw20ul5gmpo\", legofdmbw20ul5gmpo, 0, fb);\n\tENTRY(0x00000600, u32, pre, \"legofdmbw205ghpo\", legofdmbw205ghpo, 0, fb);\n\tENTRY(0x00000600, u32, pre, \"legofdmbw20ul5ghpo\", legofdmbw20ul5ghpo, 0, fb);\n\tENTRY(0xfffffe00, u32, pre, \"mcsbw202gpo\", mcsbw202gpo, 0, fb);\n\tENTRY(0x00000600, u32, pre, \"mcsbw20ul2gpo\", mcsbw20ul2gpo, 0, fb);\n\tENTRY(0xfffffe00, u32, pre, \"mcsbw402gpo\", mcsbw402gpo, 0, fb);\n\tENTRY(0xfffffe00, u32, pre, \"mcsbw205glpo\", mcsbw205glpo, 0, fb);\n\tENTRY(0x00000600, u32, pre, \"mcsbw20ul5glpo\", mcsbw20ul5glpo, 0, fb);\n\tENTRY(0xfffffe00, u32, pre, \"mcsbw405glpo\", mcsbw405glpo, 0, fb);\n\tENTRY(0xfffffe00, u32, pre, \"mcsbw205gmpo\", mcsbw205gmpo, 0, fb);\n\tENTRY(0x00000600, u32, pre, \"mcsbw20ul5gmpo\", mcsbw20ul5gmpo, 0, fb);\n\tENTRY(0xfffffe00, u32, pre, \"mcsbw405gmpo\", mcsbw405gmpo, 0, fb);\n\tENTRY(0xfffffe00, u32, pre, \"mcsbw205ghpo\", mcsbw205ghpo, 0, fb);\n\tENTRY(0x00000600, u32, pre, \"mcsbw20ul5ghpo\", mcsbw20ul5ghpo, 0, fb);\n\tENTRY(0xfffffe00, u32, pre, \"mcsbw405ghpo\", mcsbw405ghpo, 0, fb);\n\tENTRY(0x00000600, u16, pre, \"mcs32po\", mcs32po, 0, fb);\n\tENTRY(0x00000600, u16, pre, \"legofdm40duppo\", legofdm40duppo, 0, fb);\n\tENTRY(0x00000700, u8, pre, \"pcieingress_war\", pcieingress_war, 0, fb);\n\n\t \n\tENTRY(0x00000700, u8, pre, \"rxgainerr2ga0\", rxgainerr2ga[0], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"rxgainerr2ga1\", rxgainerr2ga[1], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"rxgainerr2ga2\", rxgainerr2ga[2], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"rxgainerr5gla0\", rxgainerr5gla[0], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"rxgainerr5gla1\", rxgainerr5gla[1], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"rxgainerr5gla2\", rxgainerr5gla[2], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"rxgainerr5gma0\", rxgainerr5gma[0], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"rxgainerr5gma1\", rxgainerr5gma[1], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"rxgainerr5gma2\", rxgainerr5gma[2], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"rxgainerr5gha0\", rxgainerr5gha[0], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"rxgainerr5gha1\", rxgainerr5gha[1], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"rxgainerr5gha2\", rxgainerr5gha[2], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"rxgainerr5gua0\", rxgainerr5gua[0], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"rxgainerr5gua1\", rxgainerr5gua[1], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"rxgainerr5gua2\", rxgainerr5gua[2], 0, fb);\n\n\tENTRY(0xfffffe00, u8, pre, \"sar2g\", sar2g, 0, fb);\n\tENTRY(0xfffffe00, u8, pre, \"sar5g\", sar5g, 0, fb);\n\n\t \n\tENTRY(0x00000700, u8, pre, \"noiselvl2ga0\", noiselvl2ga[0], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"noiselvl2ga1\", noiselvl2ga[1], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"noiselvl2ga2\", noiselvl2ga[2], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"noiselvl5gla0\", noiselvl5gla[0], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"noiselvl5gla1\", noiselvl5gla[1], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"noiselvl5gla2\", noiselvl5gla[2], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"noiselvl5gma0\", noiselvl5gma[0], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"noiselvl5gma1\", noiselvl5gma[1], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"noiselvl5gma2\", noiselvl5gma[2], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"noiselvl5gha0\", noiselvl5gha[0], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"noiselvl5gha1\", noiselvl5gha[1], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"noiselvl5gha2\", noiselvl5gha[2], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"noiselvl5gua0\", noiselvl5gua[0], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"noiselvl5gua1\", noiselvl5gua[1], 0, fb);\n\tENTRY(0x00000700, u8, pre, \"noiselvl5gua2\", noiselvl5gua[2], 0, fb);\n}\n#undef ENTRY  \n\nstatic void bcm47xx_fill_sprom_path_r4589(struct ssb_sprom *sprom,\n\t\t\t\t\t  const char *prefix, bool fallback)\n{\n\tchar postfix[2];\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sprom->core_pwr_info); i++) {\n\t\tstruct ssb_sprom_core_pwr_info *pwr_info;\n\n\t\tpwr_info = &sprom->core_pwr_info[i];\n\n\t\tsnprintf(postfix, sizeof(postfix), \"%i\", i);\n\t\tnvram_read_u8(prefix, postfix, \"maxp2ga\",\n\t\t\t      &pwr_info->maxpwr_2g, 0, fallback);\n\t\tnvram_read_u8(prefix, postfix, \"itt2ga\",\n\t\t\t      &pwr_info->itssi_2g, 0, fallback);\n\t\tnvram_read_u8(prefix, postfix, \"itt5ga\",\n\t\t\t      &pwr_info->itssi_5g, 0, fallback);\n\t\tnvram_read_u16(prefix, postfix, \"pa2gw0a\",\n\t\t\t       &pwr_info->pa_2g[0], 0, fallback);\n\t\tnvram_read_u16(prefix, postfix, \"pa2gw1a\",\n\t\t\t       &pwr_info->pa_2g[1], 0, fallback);\n\t\tnvram_read_u16(prefix, postfix, \"pa2gw2a\",\n\t\t\t       &pwr_info->pa_2g[2], 0, fallback);\n\t\tnvram_read_u8(prefix, postfix, \"maxp5ga\",\n\t\t\t      &pwr_info->maxpwr_5g, 0, fallback);\n\t\tnvram_read_u8(prefix, postfix, \"maxp5gha\",\n\t\t\t      &pwr_info->maxpwr_5gh, 0, fallback);\n\t\tnvram_read_u8(prefix, postfix, \"maxp5gla\",\n\t\t\t      &pwr_info->maxpwr_5gl, 0, fallback);\n\t\tnvram_read_u16(prefix, postfix, \"pa5gw0a\",\n\t\t\t       &pwr_info->pa_5g[0], 0, fallback);\n\t\tnvram_read_u16(prefix, postfix, \"pa5gw1a\",\n\t\t\t       &pwr_info->pa_5g[1], 0, fallback);\n\t\tnvram_read_u16(prefix, postfix, \"pa5gw2a\",\n\t\t\t       &pwr_info->pa_5g[2], 0, fallback);\n\t\tnvram_read_u16(prefix, postfix, \"pa5glw0a\",\n\t\t\t       &pwr_info->pa_5gl[0], 0, fallback);\n\t\tnvram_read_u16(prefix, postfix, \"pa5glw1a\",\n\t\t\t       &pwr_info->pa_5gl[1], 0, fallback);\n\t\tnvram_read_u16(prefix, postfix, \"pa5glw2a\",\n\t\t\t       &pwr_info->pa_5gl[2], 0, fallback);\n\t\tnvram_read_u16(prefix, postfix, \"pa5ghw0a\",\n\t\t\t       &pwr_info->pa_5gh[0], 0, fallback);\n\t\tnvram_read_u16(prefix, postfix, \"pa5ghw1a\",\n\t\t\t       &pwr_info->pa_5gh[1], 0, fallback);\n\t\tnvram_read_u16(prefix, postfix, \"pa5ghw2a\",\n\t\t\t       &pwr_info->pa_5gh[2], 0, fallback);\n\t}\n}\n\nstatic void bcm47xx_fill_sprom_path_r45(struct ssb_sprom *sprom,\n\t\t\t\t\tconst char *prefix, bool fallback)\n{\n\tchar postfix[2];\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sprom->core_pwr_info); i++) {\n\t\tstruct ssb_sprom_core_pwr_info *pwr_info;\n\n\t\tpwr_info = &sprom->core_pwr_info[i];\n\n\t\tsnprintf(postfix, sizeof(postfix), \"%i\", i);\n\t\tnvram_read_u16(prefix, postfix, \"pa2gw3a\",\n\t\t\t       &pwr_info->pa_2g[3], 0, fallback);\n\t\tnvram_read_u16(prefix, postfix, \"pa5gw3a\",\n\t\t\t       &pwr_info->pa_5g[3], 0, fallback);\n\t\tnvram_read_u16(prefix, postfix, \"pa5glw3a\",\n\t\t\t       &pwr_info->pa_5gl[3], 0, fallback);\n\t\tnvram_read_u16(prefix, postfix, \"pa5ghw3a\",\n\t\t\t       &pwr_info->pa_5gh[3], 0, fallback);\n\t}\n}\n\nstatic bool bcm47xx_is_valid_mac(u8 *mac)\n{\n\treturn mac && !(mac[0] == 0x00 && mac[1] == 0x90 && mac[2] == 0x4c);\n}\n\nstatic int bcm47xx_increase_mac_addr(u8 *mac, u8 num)\n{\n\tu8 *oui = mac + ETH_ALEN/2 - 1;\n\tu8 *p = mac + ETH_ALEN - 1;\n\n\tdo {\n\t\t(*p) += num;\n\t\tif (*p > num)\n\t\t\tbreak;\n\t\tp--;\n\t\tnum = 1;\n\t} while (p != oui);\n\n\tif (p == oui) {\n\t\tpr_err(\"unable to fetch mac address\\n\");\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}\n\nstatic int mac_addr_used = 2;\n\nstatic void bcm47xx_fill_sprom_ethernet(struct ssb_sprom *sprom,\n\t\t\t\t\tconst char *prefix, bool fallback)\n{\n\tbool fb = fallback;\n\n\tnvram_read_macaddr(prefix, \"et0macaddr\", sprom->et0mac, fallback);\n\tnvram_read_u8(prefix, NULL, \"et0mdcport\", &sprom->et0mdcport, 0,\n\t\t      fallback);\n\tnvram_read_u8(prefix, NULL, \"et0phyaddr\", &sprom->et0phyaddr, 0,\n\t\t      fallback);\n\n\tnvram_read_macaddr(prefix, \"et1macaddr\", sprom->et1mac, fallback);\n\tnvram_read_u8(prefix, NULL, \"et1mdcport\", &sprom->et1mdcport, 0,\n\t\t      fallback);\n\tnvram_read_u8(prefix, NULL, \"et1phyaddr\", &sprom->et1phyaddr, 0,\n\t\t      fallback);\n\n\tnvram_read_macaddr(prefix, \"et2macaddr\", sprom->et2mac, fb);\n\tnvram_read_u8(prefix, NULL, \"et2mdcport\", &sprom->et2mdcport, 0, fb);\n\tnvram_read_u8(prefix, NULL, \"et2phyaddr\", &sprom->et2phyaddr, 0, fb);\n\n\tnvram_read_macaddr(prefix, \"macaddr\", sprom->il0mac, fallback);\n\tnvram_read_macaddr(prefix, \"il0macaddr\", sprom->il0mac, fallback);\n\n\t \n\tif (!bcm47xx_is_valid_mac(sprom->il0mac)) {\n\t\tu8 mac[6];\n\n\t\tnvram_read_macaddr(NULL, \"et0macaddr\", mac, false);\n\t\tif (bcm47xx_is_valid_mac(mac)) {\n\t\t\tint err = bcm47xx_increase_mac_addr(mac, mac_addr_used);\n\n\t\t\tif (!err) {\n\t\t\t\tether_addr_copy(sprom->il0mac, mac);\n\t\t\t\tmac_addr_used++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void bcm47xx_fill_board_data(struct ssb_sprom *sprom, const char *prefix,\n\t\t\t\t    bool fallback)\n{\n\tnvram_read_u32_2(prefix, \"boardflags\", &sprom->boardflags_lo,\n\t\t\t &sprom->boardflags_hi, fallback);\n\tnvram_read_u32_2(prefix, \"boardflags2\", &sprom->boardflags2_lo,\n\t\t\t &sprom->boardflags2_hi, fallback);\n}\n\nvoid bcm47xx_fill_sprom(struct ssb_sprom *sprom, const char *prefix,\n\t\t\tbool fallback)\n{\n\tbcm47xx_fill_sprom_ethernet(sprom, prefix, fallback);\n\tbcm47xx_fill_board_data(sprom, prefix, fallback);\n\n\tnvram_read_u8(prefix, NULL, \"sromrev\", &sprom->revision, 0, fallback);\n\n\t \n\tnvram_read_alpha2(prefix, \"ccode\", sprom->alpha2, fallback);\n\tif (sprom->revision >= 3)\n\t\tnvram_read_leddc(prefix, \"leddc\", &sprom->leddc_on_time,\n\t\t\t\t &sprom->leddc_off_time, fallback);\n\n\tswitch (sprom->revision) {\n\tcase 4:\n\tcase 5:\n\t\tbcm47xx_fill_sprom_path_r4589(sprom, prefix, fallback);\n\t\tbcm47xx_fill_sprom_path_r45(sprom, prefix, fallback);\n\t\tbreak;\n\tcase 8:\n\tcase 9:\n\t\tbcm47xx_fill_sprom_path_r4589(sprom, prefix, fallback);\n\t\tbreak;\n\t}\n\n\tbcm47xx_sprom_fill_auto(sprom, prefix, fallback);\n}\n\n#if IS_BUILTIN(CONFIG_SSB) && IS_ENABLED(CONFIG_SSB_SPROM)\nstatic int bcm47xx_get_sprom_ssb(struct ssb_bus *bus, struct ssb_sprom *out)\n{\n\tchar prefix[10];\n\n\tswitch (bus->bustype) {\n\tcase SSB_BUSTYPE_SSB:\n\t\tbcm47xx_fill_sprom(out, NULL, false);\n\t\treturn 0;\n\tcase SSB_BUSTYPE_PCI:\n\t\tmemset(out, 0, sizeof(struct ssb_sprom));\n\t\tsnprintf(prefix, sizeof(prefix), \"pci/%u/%u/\",\n\t\t\t bus->host_pci->bus->number + 1,\n\t\t\t PCI_SLOT(bus->host_pci->devfn));\n\t\tbcm47xx_fill_sprom(out, prefix, false);\n\t\treturn 0;\n\tdefault:\n\t\tpr_warn(\"Unable to fill SPROM for given bustype.\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n#endif\n\n#if IS_BUILTIN(CONFIG_BCMA)\n \nstatic void bcm47xx_sprom_apply_prefix_alias(char *prefix, size_t prefix_size)\n{\n\tsize_t prefix_len = strlen(prefix);\n\tsize_t short_len = prefix_len - 1;\n\tchar nvram_var[10];\n\tchar buf[20];\n\tint i;\n\n\t \n\tif (prefix_len <= 0 || prefix[prefix_len - 1] != '/')\n\t\treturn;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (snprintf(nvram_var, sizeof(nvram_var), \"devpath%d\", i) <= 0)\n\t\t\tcontinue;\n\t\tif (bcm47xx_nvram_getenv(nvram_var, buf, sizeof(buf)) < 0)\n\t\t\tcontinue;\n\t\tif (!strcmp(buf, prefix) ||\n\t\t    (short_len && strlen(buf) == short_len && !strncmp(buf, prefix, short_len))) {\n\t\t\tsnprintf(prefix, prefix_size, \"%d:\", i);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int bcm47xx_get_sprom_bcma(struct bcma_bus *bus, struct ssb_sprom *out)\n{\n\tstruct bcma_boardinfo *binfo = &bus->boardinfo;\n\tstruct bcma_device *core;\n\tchar buf[10];\n\tchar *prefix;\n\tbool fallback = false;\n\n\tswitch (bus->hosttype) {\n\tcase BCMA_HOSTTYPE_PCI:\n\t\tmemset(out, 0, sizeof(struct ssb_sprom));\n\t\t \n\t\tif (IS_ENABLED(CONFIG_BCM47XX))\n\t\t\tsnprintf(buf, sizeof(buf), \"pci/%u/%u/\",\n\t\t\t\t bus->host_pci->bus->number + 1,\n\t\t\t\t PCI_SLOT(bus->host_pci->devfn));\n\t\telse\n\t\t\tsnprintf(buf, sizeof(buf), \"pci/%u/%u/\",\n\t\t\t\t pci_domain_nr(bus->host_pci->bus) + 1,\n\t\t\t\t bus->host_pci->bus->number);\n\t\tbcm47xx_sprom_apply_prefix_alias(buf, sizeof(buf));\n\t\tprefix = buf;\n\t\tbreak;\n\tcase BCMA_HOSTTYPE_SOC:\n\t\tmemset(out, 0, sizeof(struct ssb_sprom));\n\t\tcore = bcma_find_core(bus, BCMA_CORE_80211);\n\t\tif (core) {\n\t\t\tsnprintf(buf, sizeof(buf), \"sb/%u/\",\n\t\t\t\t core->core_index);\n\t\t\tprefix = buf;\n\t\t\tfallback = true;\n\t\t} else {\n\t\t\tprefix = NULL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"Unable to fill SPROM for given bustype.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnvram_read_u16(prefix, NULL, \"boardvendor\", &binfo->vendor, 0, true);\n\tif (!binfo->vendor)\n\t\tbinfo->vendor = SSB_BOARDVENDOR_BCM;\n\tnvram_read_u16(prefix, NULL, \"boardtype\", &binfo->type, 0, true);\n\n\tbcm47xx_fill_sprom(out, prefix, fallback);\n\n\treturn 0;\n}\n#endif\n\nstatic unsigned int bcm47xx_sprom_registered;\n\n \nint bcm47xx_sprom_register_fallbacks(void)\n{\n\tif (bcm47xx_sprom_registered)\n\t\treturn 0;\n\n#if IS_BUILTIN(CONFIG_SSB) && IS_ENABLED(CONFIG_SSB_SPROM)\n\tif (ssb_arch_register_fallback_sprom(&bcm47xx_get_sprom_ssb))\n\t\tpr_warn(\"Failed to register ssb SPROM handler\\n\");\n#endif\n\n#if IS_BUILTIN(CONFIG_BCMA)\n\tif (bcma_arch_register_fallback_sprom(&bcm47xx_get_sprom_bcma))\n\t\tpr_warn(\"Failed to register bcma SPROM handler\\n\");\n#endif\n\n\tbcm47xx_sprom_registered = 1;\n\n\treturn 0;\n}\n\nfs_initcall(bcm47xx_sprom_register_fallbacks);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}