{
  "module_name": "bcm47xx_nvram.c",
  "hash_id": "e48df5a50b548186f780b8b34ddcf7feb989d2791133bdc252a9a88665e079c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/broadcom/bcm47xx_nvram.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/mtd/mtd.h>\n#include <linux/bcm47xx_nvram.h>\n\n#define NVRAM_MAGIC\t\t\t0x48534C46\t \n#define NVRAM_SPACE\t\t\t0x10000\n#define NVRAM_MAX_GPIO_ENTRIES\t\t32\n#define NVRAM_MAX_GPIO_VALUE_LEN\t30\n\n#define FLASH_MIN\t\t0x00020000\t \n\nstruct nvram_header {\n\tu32 magic;\n\tu32 len;\n\tu32 crc_ver_init;\t \n\tu32 config_refresh;\t \n\tu32 config_ncdl;\t \n};\n\nstatic char nvram_buf[NVRAM_SPACE];\nstatic size_t nvram_len;\nstatic const u32 nvram_sizes[] = {0x6000, 0x8000, 0xF000, 0x10000};\n\n \nstatic bool bcm47xx_nvram_is_valid(void __iomem *nvram)\n{\n\treturn ((struct nvram_header *)nvram)->magic == NVRAM_MAGIC;\n}\n\n \nstatic void bcm47xx_nvram_copy(void __iomem *nvram_start, size_t res_size)\n{\n\tstruct nvram_header __iomem *header = nvram_start;\n\tsize_t copy_size;\n\n\tcopy_size = header->len;\n\tif (copy_size > res_size) {\n\t\tpr_err(\"The nvram size according to the header seems to be bigger than the partition on flash\\n\");\n\t\tcopy_size = res_size;\n\t}\n\tif (copy_size >= NVRAM_SPACE) {\n\t\tpr_err(\"nvram on flash (%zu bytes) is bigger than the reserved space in memory, will just copy the first %i bytes\\n\",\n\t\t       copy_size, NVRAM_SPACE - 1);\n\t\tcopy_size = NVRAM_SPACE - 1;\n\t}\n\n\t__ioread32_copy(nvram_buf, nvram_start, DIV_ROUND_UP(copy_size, 4));\n\tnvram_buf[NVRAM_SPACE - 1] = '\\0';\n\tnvram_len = copy_size;\n}\n\n \nstatic int bcm47xx_nvram_find_and_copy(void __iomem *flash_start, size_t res_size)\n{\n\tsize_t flash_size;\n\tsize_t offset;\n\tint i;\n\n\tif (nvram_len) {\n\t\tpr_warn(\"nvram already initialized\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\t \n\n\t \n\tfor (flash_size = FLASH_MIN; flash_size <= res_size; flash_size <<= 1) {\n\t\tfor (i = 0; i < ARRAY_SIZE(nvram_sizes); i++) {\n\t\t\toffset = flash_size - nvram_sizes[i];\n\t\t\tif (bcm47xx_nvram_is_valid(flash_start + offset))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\n\t \n\n\toffset = 4096;\n\tif (bcm47xx_nvram_is_valid(flash_start + offset))\n\t\tgoto found;\n\n\toffset = 1024;\n\tif (bcm47xx_nvram_is_valid(flash_start + offset))\n\t\tgoto found;\n\n\tpr_err(\"no nvram found\\n\");\n\treturn -ENXIO;\n\nfound:\n\tbcm47xx_nvram_copy(flash_start + offset, res_size - offset);\n\n\treturn 0;\n}\n\nint bcm47xx_nvram_init_from_iomem(void __iomem *nvram_start, size_t res_size)\n{\n\tif (nvram_len) {\n\t\tpr_warn(\"nvram already initialized\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\tif (!bcm47xx_nvram_is_valid(nvram_start)) {\n\t\tpr_err(\"No valid NVRAM found\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tbcm47xx_nvram_copy(nvram_start, res_size);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(bcm47xx_nvram_init_from_iomem);\n\n \nint bcm47xx_nvram_init_from_mem(u32 base, u32 lim)\n{\n\tvoid __iomem *iobase;\n\tint err;\n\n\tiobase = ioremap(base, lim);\n\tif (!iobase)\n\t\treturn -ENOMEM;\n\n\terr = bcm47xx_nvram_find_and_copy(iobase, lim);\n\n\tiounmap(iobase);\n\n\treturn err;\n}\n\nstatic int nvram_init(void)\n{\n#ifdef CONFIG_MTD\n\tstruct mtd_info *mtd;\n\tstruct nvram_header header;\n\tsize_t bytes_read;\n\tint err;\n\n\tmtd = get_mtd_device_nm(\"nvram\");\n\tif (IS_ERR(mtd))\n\t\treturn -ENODEV;\n\n\terr = mtd_read(mtd, 0, sizeof(header), &bytes_read, (uint8_t *)&header);\n\tif (!err && header.magic == NVRAM_MAGIC &&\n\t    header.len > sizeof(header)) {\n\t\tnvram_len = header.len;\n\t\tif (nvram_len >= NVRAM_SPACE) {\n\t\t\tpr_err(\"nvram on flash (%zu bytes) is bigger than the reserved space in memory, will just copy the first %i bytes\\n\",\n\t\t\t\tnvram_len, NVRAM_SPACE);\n\t\t\tnvram_len = NVRAM_SPACE - 1;\n\t\t}\n\n\t\terr = mtd_read(mtd, 0, nvram_len, &nvram_len,\n\t\t\t       (u8 *)nvram_buf);\n\t\treturn err;\n\t}\n#endif\n\n\treturn -ENXIO;\n}\n\nint bcm47xx_nvram_getenv(const char *name, char *val, size_t val_len)\n{\n\tchar *var, *value, *end, *eq;\n\tint err;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tif (!nvram_len) {\n\t\terr = nvram_init();\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tvar = &nvram_buf[sizeof(struct nvram_header)];\n\tend = nvram_buf + sizeof(nvram_buf);\n\twhile (var < end && *var) {\n\t\teq = strchr(var, '=');\n\t\tif (!eq)\n\t\t\tbreak;\n\t\tvalue = eq + 1;\n\t\tif (eq - var == strlen(name) &&\n\t\t    strncmp(var, name, eq - var) == 0)\n\t\t\treturn snprintf(val, val_len, \"%s\", value);\n\t\tvar = value + strlen(value) + 1;\n\t}\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL(bcm47xx_nvram_getenv);\n\nint bcm47xx_nvram_gpio_pin(const char *name)\n{\n\tint i, err;\n\tchar nvram_var[] = \"gpioXX\";\n\tchar buf[NVRAM_MAX_GPIO_VALUE_LEN];\n\n\t \n\tfor (i = 0; i < NVRAM_MAX_GPIO_ENTRIES; i++) {\n\t\terr = snprintf(nvram_var, sizeof(nvram_var), \"gpio%i\", i);\n\t\tif (err <= 0)\n\t\t\tcontinue;\n\t\terr = bcm47xx_nvram_getenv(nvram_var, buf, sizeof(buf));\n\t\tif (err <= 0)\n\t\t\tcontinue;\n\t\tif (!strcmp(name, buf))\n\t\t\treturn i;\n\t}\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL(bcm47xx_nvram_gpio_pin);\n\nchar *bcm47xx_nvram_get_contents(size_t *nvram_size)\n{\n\tint err;\n\tchar *nvram;\n\n\tif (!nvram_len) {\n\t\terr = nvram_init();\n\t\tif (err)\n\t\t\treturn NULL;\n\t}\n\n\t*nvram_size = nvram_len - sizeof(struct nvram_header);\n\tnvram = vmalloc(*nvram_size);\n\tif (!nvram)\n\t\treturn NULL;\n\tmemcpy(nvram, &nvram_buf[sizeof(struct nvram_header)], *nvram_size);\n\n\treturn nvram;\n}\nEXPORT_SYMBOL(bcm47xx_nvram_get_contents);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}