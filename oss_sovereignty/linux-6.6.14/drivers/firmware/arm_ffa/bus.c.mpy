{
  "module_name": "bus.c",
  "hash_id": "3734c29442349424b8185e2cf0124bf884b9aa53c82d5c104db576aa4edfc123",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/arm_ffa/bus.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/arm_ffa.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include \"common.h\"\n\nstatic DEFINE_IDA(ffa_bus_id);\n\nstatic int ffa_device_match(struct device *dev, struct device_driver *drv)\n{\n\tconst struct ffa_device_id *id_table;\n\tstruct ffa_device *ffa_dev;\n\n\tid_table = to_ffa_driver(drv)->id_table;\n\tffa_dev = to_ffa_dev(dev);\n\n\twhile (!uuid_is_null(&id_table->uuid)) {\n\t\t \n\t\tif (uuid_is_null(&ffa_dev->uuid))\n\t\t\tffa_device_match_uuid(ffa_dev, &id_table->uuid);\n\n\t\tif (uuid_equal(&ffa_dev->uuid, &id_table->uuid))\n\t\t\treturn 1;\n\t\tid_table++;\n\t}\n\n\treturn 0;\n}\n\nstatic int ffa_device_probe(struct device *dev)\n{\n\tstruct ffa_driver *ffa_drv = to_ffa_driver(dev->driver);\n\tstruct ffa_device *ffa_dev = to_ffa_dev(dev);\n\n\treturn ffa_drv->probe(ffa_dev);\n}\n\nstatic void ffa_device_remove(struct device *dev)\n{\n\tstruct ffa_driver *ffa_drv = to_ffa_driver(dev->driver);\n\n\tif (ffa_drv->remove)\n\t\tffa_drv->remove(to_ffa_dev(dev));\n}\n\nstatic int ffa_device_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct ffa_device *ffa_dev = to_ffa_dev(dev);\n\n\treturn add_uevent_var(env, \"MODALIAS=arm_ffa:%04x:%pUb\",\n\t\t\t      ffa_dev->vm_id, &ffa_dev->uuid);\n}\n\nstatic ssize_t partition_id_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct ffa_device *ffa_dev = to_ffa_dev(dev);\n\n\treturn sprintf(buf, \"0x%04x\\n\", ffa_dev->vm_id);\n}\nstatic DEVICE_ATTR_RO(partition_id);\n\nstatic ssize_t uuid_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct ffa_device *ffa_dev = to_ffa_dev(dev);\n\n\treturn sprintf(buf, \"%pUb\\n\", &ffa_dev->uuid);\n}\nstatic DEVICE_ATTR_RO(uuid);\n\nstatic struct attribute *ffa_device_attributes_attrs[] = {\n\t&dev_attr_partition_id.attr,\n\t&dev_attr_uuid.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(ffa_device_attributes);\n\nstruct bus_type ffa_bus_type = {\n\t.name\t\t= \"arm_ffa\",\n\t.match\t\t= ffa_device_match,\n\t.probe\t\t= ffa_device_probe,\n\t.remove\t\t= ffa_device_remove,\n\t.uevent\t\t= ffa_device_uevent,\n\t.dev_groups\t= ffa_device_attributes_groups,\n};\nEXPORT_SYMBOL_GPL(ffa_bus_type);\n\nint ffa_driver_register(struct ffa_driver *driver, struct module *owner,\n\t\t\tconst char *mod_name)\n{\n\tint ret;\n\n\tif (!driver->probe)\n\t\treturn -EINVAL;\n\n\tdriver->driver.bus = &ffa_bus_type;\n\tdriver->driver.name = driver->name;\n\tdriver->driver.owner = owner;\n\tdriver->driver.mod_name = mod_name;\n\n\tret = driver_register(&driver->driver);\n\tif (!ret)\n\t\tpr_debug(\"registered new ffa driver %s\\n\", driver->name);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ffa_driver_register);\n\nvoid ffa_driver_unregister(struct ffa_driver *driver)\n{\n\tdriver_unregister(&driver->driver);\n}\nEXPORT_SYMBOL_GPL(ffa_driver_unregister);\n\nstatic void ffa_release_device(struct device *dev)\n{\n\tstruct ffa_device *ffa_dev = to_ffa_dev(dev);\n\n\tida_free(&ffa_bus_id, ffa_dev->id);\n\tkfree(ffa_dev);\n}\n\nstatic int __ffa_devices_unregister(struct device *dev, void *data)\n{\n\tdevice_unregister(dev);\n\n\treturn 0;\n}\n\nstatic void ffa_devices_unregister(void)\n{\n\tbus_for_each_dev(&ffa_bus_type, NULL, NULL,\n\t\t\t __ffa_devices_unregister);\n}\n\nbool ffa_device_is_valid(struct ffa_device *ffa_dev)\n{\n\tbool valid = false;\n\tstruct device *dev = NULL;\n\tstruct ffa_device *tmp_dev;\n\n\tdo {\n\t\tdev = bus_find_next_device(&ffa_bus_type, dev);\n\t\ttmp_dev = to_ffa_dev(dev);\n\t\tif (tmp_dev == ffa_dev) {\n\t\t\tvalid = true;\n\t\t\tbreak;\n\t\t}\n\t\tput_device(dev);\n\t} while (dev);\n\n\tput_device(dev);\n\n\treturn valid;\n}\n\nstruct ffa_device *ffa_device_register(const uuid_t *uuid, int vm_id,\n\t\t\t\t       const struct ffa_ops *ops)\n{\n\tint id, ret;\n\tstruct device *dev;\n\tstruct ffa_device *ffa_dev;\n\n\tid = ida_alloc_min(&ffa_bus_id, 1, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn NULL;\n\n\tffa_dev = kzalloc(sizeof(*ffa_dev), GFP_KERNEL);\n\tif (!ffa_dev) {\n\t\tida_free(&ffa_bus_id, id);\n\t\treturn NULL;\n\t}\n\n\tdev = &ffa_dev->dev;\n\tdev->bus = &ffa_bus_type;\n\tdev->release = ffa_release_device;\n\tdev_set_name(&ffa_dev->dev, \"arm-ffa-%d\", id);\n\n\tffa_dev->id = id;\n\tffa_dev->vm_id = vm_id;\n\tffa_dev->ops = ops;\n\tuuid_copy(&ffa_dev->uuid, uuid);\n\n\tret = device_register(&ffa_dev->dev);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to register device %s err=%d\\n\",\n\t\t\tdev_name(dev), ret);\n\t\tput_device(dev);\n\t\treturn NULL;\n\t}\n\n\treturn ffa_dev;\n}\nEXPORT_SYMBOL_GPL(ffa_device_register);\n\nvoid ffa_device_unregister(struct ffa_device *ffa_dev)\n{\n\tif (!ffa_dev)\n\t\treturn;\n\n\tdevice_unregister(&ffa_dev->dev);\n}\nEXPORT_SYMBOL_GPL(ffa_device_unregister);\n\nint arm_ffa_bus_init(void)\n{\n\treturn bus_register(&ffa_bus_type);\n}\n\nvoid arm_ffa_bus_exit(void)\n{\n\tffa_devices_unregister();\n\tbus_unregister(&ffa_bus_type);\n\tida_destroy(&ffa_bus_id);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}