{
  "module_name": "meson_sm.c",
  "hash_id": "71d88fe015b9f73f4edf8f3966543775c3d2c5791493965933de4afd7bcbdbfb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/meson/meson_sm.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"meson-sm: \" fmt\n\n#include <linux/arm-smccc.h>\n#include <linux/bug.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/printk.h>\n#include <linux/types.h>\n#include <linux/sizes.h>\n #include <linux/slab.h>\n\n#include <linux/firmware/meson/meson_sm.h>\n\nstruct meson_sm_cmd {\n\tunsigned int index;\n\tu32 smc_id;\n};\n#define CMD(d, s) { .index = (d), .smc_id = (s), }\n\nstruct meson_sm_chip {\n\tunsigned int shmem_size;\n\tu32 cmd_shmem_in_base;\n\tu32 cmd_shmem_out_base;\n\tstruct meson_sm_cmd cmd[];\n};\n\nstatic const struct meson_sm_chip gxbb_chip = {\n\t.shmem_size\t\t= SZ_4K,\n\t.cmd_shmem_in_base\t= 0x82000020,\n\t.cmd_shmem_out_base\t= 0x82000021,\n\t.cmd = {\n\t\tCMD(SM_EFUSE_READ,\t0x82000030),\n\t\tCMD(SM_EFUSE_WRITE,\t0x82000031),\n\t\tCMD(SM_EFUSE_USER_MAX,\t0x82000033),\n\t\tCMD(SM_GET_CHIP_ID,\t0x82000044),\n\t\tCMD(SM_A1_PWRC_SET,\t0x82000093),\n\t\tCMD(SM_A1_PWRC_GET,\t0x82000095),\n\t\t{   },\n\t},\n};\n\nstruct meson_sm_firmware {\n\tconst struct meson_sm_chip *chip;\n\tvoid __iomem *sm_shmem_in_base;\n\tvoid __iomem *sm_shmem_out_base;\n};\n\nstatic u32 meson_sm_get_cmd(const struct meson_sm_chip *chip,\n\t\t\t    unsigned int cmd_index)\n{\n\tconst struct meson_sm_cmd *cmd = chip->cmd;\n\n\twhile (cmd->smc_id && cmd->index != cmd_index)\n\t\tcmd++;\n\n\treturn cmd->smc_id;\n}\n\nstatic u32 __meson_sm_call(u32 cmd, u32 arg0, u32 arg1, u32 arg2,\n\t\t\t   u32 arg3, u32 arg4)\n{\n\tstruct arm_smccc_res res;\n\n\tarm_smccc_smc(cmd, arg0, arg1, arg2, arg3, arg4, 0, 0, &res);\n\treturn res.a0;\n}\n\nstatic void __iomem *meson_sm_map_shmem(u32 cmd_shmem, unsigned int size)\n{\n\tu32 sm_phy_base;\n\n\tsm_phy_base = __meson_sm_call(cmd_shmem, 0, 0, 0, 0, 0);\n\tif (!sm_phy_base)\n\t\treturn NULL;\n\n\treturn ioremap_cache(sm_phy_base, size);\n}\n\n \nint meson_sm_call(struct meson_sm_firmware *fw, unsigned int cmd_index,\n\t\t  u32 *ret, u32 arg0, u32 arg1, u32 arg2, u32 arg3, u32 arg4)\n{\n\tu32 cmd, lret;\n\n\tif (!fw->chip)\n\t\treturn -ENOENT;\n\n\tcmd = meson_sm_get_cmd(fw->chip, cmd_index);\n\tif (!cmd)\n\t\treturn -EINVAL;\n\n\tlret = __meson_sm_call(cmd, arg0, arg1, arg2, arg3, arg4);\n\n\tif (ret)\n\t\t*ret = lret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(meson_sm_call);\n\n \nint meson_sm_call_read(struct meson_sm_firmware *fw, void *buffer,\n\t\t       unsigned int bsize, unsigned int cmd_index, u32 arg0,\n\t\t       u32 arg1, u32 arg2, u32 arg3, u32 arg4)\n{\n\tu32 size;\n\tint ret;\n\n\tif (!fw->chip)\n\t\treturn -ENOENT;\n\n\tif (!fw->chip->cmd_shmem_out_base)\n\t\treturn -EINVAL;\n\n\tif (bsize > fw->chip->shmem_size)\n\t\treturn -EINVAL;\n\n\tif (meson_sm_call(fw, cmd_index, &size, arg0, arg1, arg2, arg3, arg4) < 0)\n\t\treturn -EINVAL;\n\n\tif (size > bsize)\n\t\treturn -EINVAL;\n\n\tret = size;\n\n\tif (!size)\n\t\tsize = bsize;\n\n\tif (buffer)\n\t\tmemcpy(buffer, fw->sm_shmem_out_base, size);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(meson_sm_call_read);\n\n \nint meson_sm_call_write(struct meson_sm_firmware *fw, void *buffer,\n\t\t\tunsigned int size, unsigned int cmd_index, u32 arg0,\n\t\t\tu32 arg1, u32 arg2, u32 arg3, u32 arg4)\n{\n\tu32 written;\n\n\tif (!fw->chip)\n\t\treturn -ENOENT;\n\n\tif (size > fw->chip->shmem_size)\n\t\treturn -EINVAL;\n\n\tif (!fw->chip->cmd_shmem_in_base)\n\t\treturn -EINVAL;\n\n\tmemcpy(fw->sm_shmem_in_base, buffer, size);\n\n\tif (meson_sm_call(fw, cmd_index, &written, arg0, arg1, arg2, arg3, arg4) < 0)\n\t\treturn -EINVAL;\n\n\tif (!written)\n\t\treturn -EINVAL;\n\n\treturn written;\n}\nEXPORT_SYMBOL(meson_sm_call_write);\n\n \nstruct meson_sm_firmware *meson_sm_get(struct device_node *sm_node)\n{\n\tstruct platform_device *pdev = of_find_device_by_node(sm_node);\n\n\tif (!pdev)\n\t\treturn NULL;\n\n\treturn platform_get_drvdata(pdev);\n}\nEXPORT_SYMBOL_GPL(meson_sm_get);\n\n#define SM_CHIP_ID_LENGTH\t119\n#define SM_CHIP_ID_OFFSET\t4\n#define SM_CHIP_ID_SIZE\t\t12\n\nstatic ssize_t serial_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct meson_sm_firmware *fw;\n\tuint8_t *id_buf;\n\tint ret;\n\n\tfw = platform_get_drvdata(pdev);\n\n\tid_buf = kmalloc(SM_CHIP_ID_LENGTH, GFP_KERNEL);\n\tif (!id_buf)\n\t\treturn -ENOMEM;\n\n\tret = meson_sm_call_read(fw, id_buf, SM_CHIP_ID_LENGTH, SM_GET_CHIP_ID,\n\t\t\t\t 0, 0, 0, 0, 0);\n\tif (ret < 0) {\n\t\tkfree(id_buf);\n\t\treturn ret;\n\t}\n\n\tret = sprintf(buf, \"%12phN\\n\", &id_buf[SM_CHIP_ID_OFFSET]);\n\n\tkfree(id_buf);\n\n\treturn ret;\n}\n\nstatic DEVICE_ATTR_RO(serial);\n\nstatic struct attribute *meson_sm_sysfs_attributes[] = {\n\t&dev_attr_serial.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group meson_sm_sysfs_attr_group = {\n\t.attrs = meson_sm_sysfs_attributes,\n};\n\nstatic const struct of_device_id meson_sm_ids[] = {\n\t{ .compatible = \"amlogic,meson-gxbb-sm\", .data = &gxbb_chip },\n\t{   },\n};\n\nstatic int __init meson_sm_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct meson_sm_chip *chip;\n\tstruct meson_sm_firmware *fw;\n\n\tfw = devm_kzalloc(dev, sizeof(*fw), GFP_KERNEL);\n\tif (!fw)\n\t\treturn -ENOMEM;\n\n\tchip = of_match_device(meson_sm_ids, dev)->data;\n\tif (!chip)\n\t\treturn -EINVAL;\n\n\tif (chip->cmd_shmem_in_base) {\n\t\tfw->sm_shmem_in_base = meson_sm_map_shmem(chip->cmd_shmem_in_base,\n\t\t\t\t\t\t\t  chip->shmem_size);\n\t\tif (WARN_ON(!fw->sm_shmem_in_base))\n\t\t\tgoto out;\n\t}\n\n\tif (chip->cmd_shmem_out_base) {\n\t\tfw->sm_shmem_out_base = meson_sm_map_shmem(chip->cmd_shmem_out_base,\n\t\t\t\t\t\t\t   chip->shmem_size);\n\t\tif (WARN_ON(!fw->sm_shmem_out_base))\n\t\t\tgoto out_in_base;\n\t}\n\n\tfw->chip = chip;\n\n\tplatform_set_drvdata(pdev, fw);\n\n\tif (devm_of_platform_populate(dev))\n\t\tgoto out_in_base;\n\n\tif (sysfs_create_group(&pdev->dev.kobj, &meson_sm_sysfs_attr_group))\n\t\tgoto out_in_base;\n\n\tpr_info(\"secure-monitor enabled\\n\");\n\n\treturn 0;\n\nout_in_base:\n\tiounmap(fw->sm_shmem_in_base);\nout:\n\treturn -EINVAL;\n}\n\nstatic struct platform_driver meson_sm_driver = {\n\t.driver = {\n\t\t.name = \"meson-sm\",\n\t\t.of_match_table = of_match_ptr(meson_sm_ids),\n\t},\n};\nmodule_platform_driver_probe(meson_sm_driver, meson_sm_probe);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}