{
  "module_name": "trusted_foundations.c",
  "hash_id": "392f74ccb9617e6f7bab5bbe694cb2dbfa29d01b6659c3463f661e0fa908c3e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/trusted_foundations.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/of.h>\n\n#include <linux/firmware/trusted_foundations.h>\n\n#include <asm/firmware.h>\n#include <asm/hardware/cache-l2x0.h>\n#include <asm/outercache.h>\n\n#define TF_CACHE_MAINT\t\t0xfffff100\n\n#define TF_CACHE_ENABLE\t\t1\n#define TF_CACHE_DISABLE\t2\n#define TF_CACHE_REENABLE\t4\n\n#define TF_SET_CPU_BOOT_ADDR_SMC 0xfffff200\n\n#define TF_CPU_PM\t\t0xfffffffc\n#define TF_CPU_PM_S3\t\t0xffffffe3\n#define TF_CPU_PM_S2\t\t0xffffffe6\n#define TF_CPU_PM_S2_NO_MC_CLK\t0xffffffe5\n#define TF_CPU_PM_S1\t\t0xffffffe4\n#define TF_CPU_PM_S1_NOFLUSH_L2\t0xffffffe7\n\nstatic unsigned long tf_idle_mode = TF_PM_MODE_NONE;\nstatic unsigned long cpu_boot_addr;\n\nstatic void tf_generic_smc(u32 type, u32 arg1, u32 arg2)\n{\n\tregister u32 r0 asm(\"r0\") = type;\n\tregister u32 r1 asm(\"r1\") = arg1;\n\tregister u32 r2 asm(\"r2\") = arg2;\n\n\tasm volatile(\n\t\t\".arch_extension\tsec\\n\\t\"\n\t\t\"stmfd\tsp!, {r4 - r11}\\n\\t\"\n\t\t__asmeq(\"%0\", \"r0\")\n\t\t__asmeq(\"%1\", \"r1\")\n\t\t__asmeq(\"%2\", \"r2\")\n\t\t\"mov\tr3, #0\\n\\t\"\n\t\t\"mov\tr4, #0\\n\\t\"\n\t\t\"smc\t#0\\n\\t\"\n\t\t\"ldmfd\tsp!, {r4 - r11}\\n\\t\"\n\t\t:\n\t\t: \"r\" (r0), \"r\" (r1), \"r\" (r2)\n\t\t: \"memory\", \"r3\", \"r12\", \"lr\");\n}\n\nstatic int tf_set_cpu_boot_addr(int cpu, unsigned long boot_addr)\n{\n\tcpu_boot_addr = boot_addr;\n\ttf_generic_smc(TF_SET_CPU_BOOT_ADDR_SMC, cpu_boot_addr, 0);\n\n\treturn 0;\n}\n\nstatic int tf_prepare_idle(unsigned long mode)\n{\n\tswitch (mode) {\n\tcase TF_PM_MODE_LP0:\n\t\ttf_generic_smc(TF_CPU_PM, TF_CPU_PM_S3, cpu_boot_addr);\n\t\tbreak;\n\n\tcase TF_PM_MODE_LP1:\n\t\ttf_generic_smc(TF_CPU_PM, TF_CPU_PM_S2, cpu_boot_addr);\n\t\tbreak;\n\n\tcase TF_PM_MODE_LP1_NO_MC_CLK:\n\t\ttf_generic_smc(TF_CPU_PM, TF_CPU_PM_S2_NO_MC_CLK,\n\t\t\t       cpu_boot_addr);\n\t\tbreak;\n\n\tcase TF_PM_MODE_LP2:\n\t\ttf_generic_smc(TF_CPU_PM, TF_CPU_PM_S1, cpu_boot_addr);\n\t\tbreak;\n\n\tcase TF_PM_MODE_LP2_NOFLUSH_L2:\n\t\ttf_generic_smc(TF_CPU_PM, TF_CPU_PM_S1_NOFLUSH_L2,\n\t\t\t       cpu_boot_addr);\n\t\tbreak;\n\n\tcase TF_PM_MODE_NONE:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttf_idle_mode = mode;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_CACHE_L2X0\nstatic void tf_cache_write_sec(unsigned long val, unsigned int reg)\n{\n\tu32 enable_op, l2x0_way_mask = 0xff;\n\n\tswitch (reg) {\n\tcase L2X0_CTRL:\n\t\tif (l2x0_saved_regs.aux_ctrl & L310_AUX_CTRL_ASSOCIATIVITY_16)\n\t\t\tl2x0_way_mask = 0xffff;\n\n\t\tswitch (tf_idle_mode) {\n\t\tcase TF_PM_MODE_LP2:\n\t\t\tenable_op = TF_CACHE_REENABLE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tenable_op = TF_CACHE_ENABLE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val == L2X0_CTRL_EN)\n\t\t\ttf_generic_smc(TF_CACHE_MAINT, enable_op,\n\t\t\t\t       l2x0_saved_regs.aux_ctrl);\n\t\telse\n\t\t\ttf_generic_smc(TF_CACHE_MAINT, TF_CACHE_DISABLE,\n\t\t\t\t       l2x0_way_mask);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int tf_init_cache(void)\n{\n\touter_cache.write_sec = tf_cache_write_sec;\n\n\treturn 0;\n}\n#endif  \n\nstatic const struct firmware_ops trusted_foundations_ops = {\n\t.set_cpu_boot_addr = tf_set_cpu_boot_addr,\n\t.prepare_idle = tf_prepare_idle,\n#ifdef CONFIG_CACHE_L2X0\n\t.l2x0_init = tf_init_cache,\n#endif\n};\n\nvoid register_trusted_foundations(struct trusted_foundations_platform_data *pd)\n{\n\t \n\tregister_firmware_ops(&trusted_foundations_ops);\n}\n\nvoid of_register_trusted_foundations(void)\n{\n\tstruct device_node *node;\n\tstruct trusted_foundations_platform_data pdata;\n\tint err;\n\n\tnode = of_find_compatible_node(NULL, NULL, \"tlm,trusted-foundations\");\n\tif (!node)\n\t\treturn;\n\n\terr = of_property_read_u32(node, \"tlm,version-major\",\n\t\t\t\t   &pdata.version_major);\n\tif (err != 0)\n\t\tpanic(\"Trusted Foundation: missing version-major property\\n\");\n\terr = of_property_read_u32(node, \"tlm,version-minor\",\n\t\t\t\t   &pdata.version_minor);\n\tif (err != 0)\n\t\tpanic(\"Trusted Foundation: missing version-minor property\\n\");\n\tregister_trusted_foundations(&pdata);\n}\n\nbool trusted_foundations_registered(void)\n{\n\treturn firmware_ops == &trusted_foundations_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}