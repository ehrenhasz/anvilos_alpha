{
  "module_name": "dmi-sysfs.c",
  "hash_id": "dfe3fd818088578fe8e4796f12a9b426c52a07ad8779c79974181913397197a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firmware/dmi-sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kobject.h>\n#include <linux/dmi.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <asm/dmi.h>\n\n#define MAX_ENTRY_TYPE 255  \n\nstruct dmi_sysfs_entry {\n\tstruct dmi_header dh;\n\tstruct kobject kobj;\n\tint instance;\n\tint position;\n\tstruct list_head list;\n\tstruct kobject *child;\n};\n\n \nstatic LIST_HEAD(entry_list);\nstatic DEFINE_SPINLOCK(entry_list_lock);\n\n \nstruct dmi_sysfs_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct dmi_sysfs_entry *entry, char *buf);\n};\n\n#define DMI_SYSFS_ATTR(_entry, _name) \\\nstruct dmi_sysfs_attribute dmi_sysfs_attr_##_entry##_##_name = { \\\n\t.attr = {.name = __stringify(_name), .mode = 0400}, \\\n\t.show = dmi_sysfs_##_entry##_##_name, \\\n}\n\n \nstruct dmi_sysfs_mapped_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct dmi_sysfs_entry *entry,\n\t\t\tconst struct dmi_header *dh,\n\t\t\tchar *buf);\n};\n\n#define DMI_SYSFS_MAPPED_ATTR(_entry, _name) \\\nstruct dmi_sysfs_mapped_attribute dmi_sysfs_attr_##_entry##_##_name = { \\\n\t.attr = {.name = __stringify(_name), .mode = 0400}, \\\n\t.show = dmi_sysfs_##_entry##_##_name, \\\n}\n\n \nstatic void dmi_entry_free(struct kobject *kobj)\n{\n\tkfree(kobj);\n}\n\nstatic struct dmi_sysfs_entry *to_entry(struct kobject *kobj)\n{\n\treturn container_of(kobj, struct dmi_sysfs_entry, kobj);\n}\n\nstatic struct dmi_sysfs_attribute *to_attr(struct attribute *attr)\n{\n\treturn container_of(attr, struct dmi_sysfs_attribute, attr);\n}\n\nstatic ssize_t dmi_sysfs_attr_show(struct kobject *kobj,\n\t\t\t\t   struct attribute *_attr, char *buf)\n{\n\tstruct dmi_sysfs_entry *entry = to_entry(kobj);\n\tstruct dmi_sysfs_attribute *attr = to_attr(_attr);\n\n\t \n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\treturn attr->show(entry, buf);\n}\n\nstatic const struct sysfs_ops dmi_sysfs_attr_ops = {\n\t.show = dmi_sysfs_attr_show,\n};\n\ntypedef ssize_t (*dmi_callback)(struct dmi_sysfs_entry *,\n\t\t\t\tconst struct dmi_header *dh, void *);\n\nstruct find_dmi_data {\n\tstruct dmi_sysfs_entry\t*entry;\n\tdmi_callback\t\tcallback;\n\tvoid\t\t\t*private;\n\tint\t\t\tinstance_countdown;\n\tssize_t\t\t\tret;\n};\n\nstatic void find_dmi_entry_helper(const struct dmi_header *dh,\n\t\t\t\t  void *_data)\n{\n\tstruct find_dmi_data *data = _data;\n\tstruct dmi_sysfs_entry *entry = data->entry;\n\n\t \n\tif (dh->type != entry->dh.type)\n\t\treturn;\n\n\tif (data->instance_countdown != 0) {\n\t\t \n\t\tdata->instance_countdown--;\n\t\treturn;\n\t}\n\n\t \n\tdata->instance_countdown--;\n\n\t \n\tdata->ret = data->callback(entry, dh, data->private);\n}\n\n \nstruct dmi_read_state {\n\tchar *buf;\n\tloff_t pos;\n\tsize_t count;\n};\n\nstatic ssize_t find_dmi_entry(struct dmi_sysfs_entry *entry,\n\t\t\t      dmi_callback callback, void *private)\n{\n\tstruct find_dmi_data data = {\n\t\t.entry = entry,\n\t\t.callback = callback,\n\t\t.private = private,\n\t\t.instance_countdown = entry->instance,\n\t\t.ret = -EIO,   \n\t};\n\tint ret;\n\n\tret = dmi_walk(find_dmi_entry_helper, &data);\n\t \n\tif (ret)\n\t\treturn -EINVAL;\n\treturn data.ret;\n}\n\n \nstatic size_t dmi_entry_length(const struct dmi_header *dh)\n{\n\tconst char *p = (const char *)dh;\n\n\tp += dh->length;\n\n\twhile (p[0] || p[1])\n\t\tp++;\n\n\treturn 2 + p - (const char *)dh;\n}\n\n \nstruct dmi_entry_attr_show_data {\n\tstruct attribute *attr;\n\tchar *buf;\n};\n\nstatic ssize_t dmi_entry_attr_show_helper(struct dmi_sysfs_entry *entry,\n\t\t\t\t\t  const struct dmi_header *dh,\n\t\t\t\t\t  void *_data)\n{\n\tstruct dmi_entry_attr_show_data *data = _data;\n\tstruct dmi_sysfs_mapped_attribute *attr;\n\n\tattr = container_of(data->attr,\n\t\t\t    struct dmi_sysfs_mapped_attribute, attr);\n\treturn attr->show(entry, dh, data->buf);\n}\n\nstatic ssize_t dmi_entry_attr_show(struct kobject *kobj,\n\t\t\t\t   struct attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct dmi_entry_attr_show_data data = {\n\t\t.attr = attr,\n\t\t.buf  = buf,\n\t};\n\t \n\treturn find_dmi_entry(to_entry(kobj->parent),\n\t\t\t      dmi_entry_attr_show_helper, &data);\n}\n\nstatic const struct sysfs_ops dmi_sysfs_specialize_attr_ops = {\n\t.show = dmi_entry_attr_show,\n};\n\n \n\n \n\n#define DMI_SEL_ACCESS_METHOD_IO8\t0x00\n#define DMI_SEL_ACCESS_METHOD_IO2x8\t0x01\n#define DMI_SEL_ACCESS_METHOD_IO16\t0x02\n#define DMI_SEL_ACCESS_METHOD_PHYS32\t0x03\n#define DMI_SEL_ACCESS_METHOD_GPNV\t0x04\n\nstruct dmi_system_event_log {\n\tstruct dmi_header header;\n\tu16\tarea_length;\n\tu16\theader_start_offset;\n\tu16\tdata_start_offset;\n\tu8\taccess_method;\n\tu8\tstatus;\n\tu32\tchange_token;\n\tunion {\n\t\tstruct {\n\t\t\tu16 index_addr;\n\t\t\tu16 data_addr;\n\t\t} io;\n\t\tu32\tphys_addr32;\n\t\tu16\tgpnv_handle;\n\t\tu32\taccess_method_address;\n\t};\n\tu8\theader_format;\n\tu8\ttype_descriptors_supported_count;\n\tu8\tper_log_type_descriptor_length;\n\tu8\tsupported_log_type_descriptos[];\n} __packed;\n\n#define DMI_SYSFS_SEL_FIELD(_field) \\\nstatic ssize_t dmi_sysfs_sel_##_field(struct dmi_sysfs_entry *entry, \\\n\t\t\t\t      const struct dmi_header *dh, \\\n\t\t\t\t      char *buf) \\\n{ \\\n\tstruct dmi_system_event_log sel; \\\n\tif (sizeof(sel) > dmi_entry_length(dh)) \\\n\t\treturn -EIO; \\\n\tmemcpy(&sel, dh, sizeof(sel)); \\\n\treturn sprintf(buf, \"%u\\n\", sel._field); \\\n} \\\nstatic DMI_SYSFS_MAPPED_ATTR(sel, _field)\n\nDMI_SYSFS_SEL_FIELD(area_length);\nDMI_SYSFS_SEL_FIELD(header_start_offset);\nDMI_SYSFS_SEL_FIELD(data_start_offset);\nDMI_SYSFS_SEL_FIELD(access_method);\nDMI_SYSFS_SEL_FIELD(status);\nDMI_SYSFS_SEL_FIELD(change_token);\nDMI_SYSFS_SEL_FIELD(access_method_address);\nDMI_SYSFS_SEL_FIELD(header_format);\nDMI_SYSFS_SEL_FIELD(type_descriptors_supported_count);\nDMI_SYSFS_SEL_FIELD(per_log_type_descriptor_length);\n\nstatic struct attribute *dmi_sysfs_sel_attrs[] = {\n\t&dmi_sysfs_attr_sel_area_length.attr,\n\t&dmi_sysfs_attr_sel_header_start_offset.attr,\n\t&dmi_sysfs_attr_sel_data_start_offset.attr,\n\t&dmi_sysfs_attr_sel_access_method.attr,\n\t&dmi_sysfs_attr_sel_status.attr,\n\t&dmi_sysfs_attr_sel_change_token.attr,\n\t&dmi_sysfs_attr_sel_access_method_address.attr,\n\t&dmi_sysfs_attr_sel_header_format.attr,\n\t&dmi_sysfs_attr_sel_type_descriptors_supported_count.attr,\n\t&dmi_sysfs_attr_sel_per_log_type_descriptor_length.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(dmi_sysfs_sel);\n\nstatic const struct kobj_type dmi_system_event_log_ktype = {\n\t.release = dmi_entry_free,\n\t.sysfs_ops = &dmi_sysfs_specialize_attr_ops,\n\t.default_groups = dmi_sysfs_sel_groups,\n};\n\n#ifdef CONFIG_HAS_IOPORT\ntypedef u8 (*sel_io_reader)(const struct dmi_system_event_log *sel,\n\t\t\t    loff_t offset);\n\nstatic DEFINE_MUTEX(io_port_lock);\n\nstatic u8 read_sel_8bit_indexed_io(const struct dmi_system_event_log *sel,\n\t\t\t\t   loff_t offset)\n{\n\tu8 ret;\n\n\tmutex_lock(&io_port_lock);\n\toutb((u8)offset, sel->io.index_addr);\n\tret = inb(sel->io.data_addr);\n\tmutex_unlock(&io_port_lock);\n\treturn ret;\n}\n\nstatic u8 read_sel_2x8bit_indexed_io(const struct dmi_system_event_log *sel,\n\t\t\t\t     loff_t offset)\n{\n\tu8 ret;\n\n\tmutex_lock(&io_port_lock);\n\toutb((u8)offset, sel->io.index_addr);\n\toutb((u8)(offset >> 8), sel->io.index_addr + 1);\n\tret = inb(sel->io.data_addr);\n\tmutex_unlock(&io_port_lock);\n\treturn ret;\n}\n\nstatic u8 read_sel_16bit_indexed_io(const struct dmi_system_event_log *sel,\n\t\t\t\t    loff_t offset)\n{\n\tu8 ret;\n\n\tmutex_lock(&io_port_lock);\n\toutw((u16)offset, sel->io.index_addr);\n\tret = inb(sel->io.data_addr);\n\tmutex_unlock(&io_port_lock);\n\treturn ret;\n}\n\nstatic sel_io_reader sel_io_readers[] = {\n\t[DMI_SEL_ACCESS_METHOD_IO8]\t= read_sel_8bit_indexed_io,\n\t[DMI_SEL_ACCESS_METHOD_IO2x8]\t= read_sel_2x8bit_indexed_io,\n\t[DMI_SEL_ACCESS_METHOD_IO16]\t= read_sel_16bit_indexed_io,\n};\n\nstatic ssize_t dmi_sel_raw_read_io(struct dmi_sysfs_entry *entry,\n\t\t\t\t   const struct dmi_system_event_log *sel,\n\t\t\t\t   char *buf, loff_t pos, size_t count)\n{\n\tssize_t wrote = 0;\n\n\tsel_io_reader io_reader = sel_io_readers[sel->access_method];\n\n\twhile (count && pos < sel->area_length) {\n\t\tcount--;\n\t\t*(buf++) = io_reader(sel, pos++);\n\t\twrote++;\n\t}\n\n\treturn wrote;\n}\n#endif\n\nstatic ssize_t dmi_sel_raw_read_phys32(struct dmi_sysfs_entry *entry,\n\t\t\t\t       const struct dmi_system_event_log *sel,\n\t\t\t\t       char *buf, loff_t pos, size_t count)\n{\n\tu8 __iomem *mapped;\n\tssize_t wrote = 0;\n\n\tmapped = dmi_remap(sel->access_method_address, sel->area_length);\n\tif (!mapped)\n\t\treturn -EIO;\n\n\twhile (count && pos < sel->area_length) {\n\t\tcount--;\n\t\t*(buf++) = readb(mapped + pos++);\n\t\twrote++;\n\t}\n\n\tdmi_unmap(mapped);\n\treturn wrote;\n}\n\nstatic ssize_t dmi_sel_raw_read_helper(struct dmi_sysfs_entry *entry,\n\t\t\t\t       const struct dmi_header *dh,\n\t\t\t\t       void *_state)\n{\n\tstruct dmi_read_state *state = _state;\n\tstruct dmi_system_event_log sel;\n\n\tif (sizeof(sel) > dmi_entry_length(dh))\n\t\treturn -EIO;\n\n\tmemcpy(&sel, dh, sizeof(sel));\n\n\tswitch (sel.access_method) {\n#ifdef CONFIG_HAS_IOPORT\n\tcase DMI_SEL_ACCESS_METHOD_IO8:\n\tcase DMI_SEL_ACCESS_METHOD_IO2x8:\n\tcase DMI_SEL_ACCESS_METHOD_IO16:\n\t\treturn dmi_sel_raw_read_io(entry, &sel, state->buf,\n\t\t\t\t\t   state->pos, state->count);\n#endif\n\tcase DMI_SEL_ACCESS_METHOD_PHYS32:\n\t\treturn dmi_sel_raw_read_phys32(entry, &sel, state->buf,\n\t\t\t\t\t       state->pos, state->count);\n\tcase DMI_SEL_ACCESS_METHOD_GPNV:\n\t\tpr_info_ratelimited(\"dmi-sysfs: GPNV support missing.\\n\");\n\t\treturn -EIO;\n\tdefault:\n\t\tpr_info_ratelimited(\"dmi-sysfs: Unknown access method %02x\\n\",\n\t\t\tsel.access_method);\n\t\treturn -EIO;\n\t}\n}\n\nstatic ssize_t dmi_sel_raw_read(struct file *filp, struct kobject *kobj,\n\t\t\t\tstruct bin_attribute *bin_attr,\n\t\t\t\tchar *buf, loff_t pos, size_t count)\n{\n\tstruct dmi_sysfs_entry *entry = to_entry(kobj->parent);\n\tstruct dmi_read_state state = {\n\t\t.buf = buf,\n\t\t.pos = pos,\n\t\t.count = count,\n\t};\n\n\treturn find_dmi_entry(entry, dmi_sel_raw_read_helper, &state);\n}\n\nstatic struct bin_attribute dmi_sel_raw_attr = {\n\t.attr = {.name = \"raw_event_log\", .mode = 0400},\n\t.read = dmi_sel_raw_read,\n};\n\nstatic int dmi_system_event_log(struct dmi_sysfs_entry *entry)\n{\n\tint ret;\n\n\tentry->child = kzalloc(sizeof(*entry->child), GFP_KERNEL);\n\tif (!entry->child)\n\t\treturn -ENOMEM;\n\tret = kobject_init_and_add(entry->child,\n\t\t\t\t   &dmi_system_event_log_ktype,\n\t\t\t\t   &entry->kobj,\n\t\t\t\t   \"system_event_log\");\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = sysfs_create_bin_file(entry->child, &dmi_sel_raw_attr);\n\tif (ret)\n\t\tgoto out_del;\n\n\treturn 0;\n\nout_del:\n\tkobject_del(entry->child);\nout_free:\n\tkfree(entry->child);\n\treturn ret;\n}\n\n \n\nstatic ssize_t dmi_sysfs_entry_length(struct dmi_sysfs_entry *entry, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", entry->dh.length);\n}\n\nstatic ssize_t dmi_sysfs_entry_handle(struct dmi_sysfs_entry *entry, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", entry->dh.handle);\n}\n\nstatic ssize_t dmi_sysfs_entry_type(struct dmi_sysfs_entry *entry, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", entry->dh.type);\n}\n\nstatic ssize_t dmi_sysfs_entry_instance(struct dmi_sysfs_entry *entry,\n\t\t\t\t\tchar *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", entry->instance);\n}\n\nstatic ssize_t dmi_sysfs_entry_position(struct dmi_sysfs_entry *entry,\n\t\t\t\t\tchar *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", entry->position);\n}\n\nstatic DMI_SYSFS_ATTR(entry, length);\nstatic DMI_SYSFS_ATTR(entry, handle);\nstatic DMI_SYSFS_ATTR(entry, type);\nstatic DMI_SYSFS_ATTR(entry, instance);\nstatic DMI_SYSFS_ATTR(entry, position);\n\nstatic struct attribute *dmi_sysfs_entry_attrs[] = {\n\t&dmi_sysfs_attr_entry_length.attr,\n\t&dmi_sysfs_attr_entry_handle.attr,\n\t&dmi_sysfs_attr_entry_type.attr,\n\t&dmi_sysfs_attr_entry_instance.attr,\n\t&dmi_sysfs_attr_entry_position.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(dmi_sysfs_entry);\n\nstatic ssize_t dmi_entry_raw_read_helper(struct dmi_sysfs_entry *entry,\n\t\t\t\t\t const struct dmi_header *dh,\n\t\t\t\t\t void *_state)\n{\n\tstruct dmi_read_state *state = _state;\n\tsize_t entry_length;\n\n\tentry_length = dmi_entry_length(dh);\n\n\treturn memory_read_from_buffer(state->buf, state->count,\n\t\t\t\t       &state->pos, dh, entry_length);\n}\n\nstatic ssize_t dmi_entry_raw_read(struct file *filp,\n\t\t\t\t  struct kobject *kobj,\n\t\t\t\t  struct bin_attribute *bin_attr,\n\t\t\t\t  char *buf, loff_t pos, size_t count)\n{\n\tstruct dmi_sysfs_entry *entry = to_entry(kobj);\n\tstruct dmi_read_state state = {\n\t\t.buf = buf,\n\t\t.pos = pos,\n\t\t.count = count,\n\t};\n\n\treturn find_dmi_entry(entry, dmi_entry_raw_read_helper, &state);\n}\n\nstatic const struct bin_attribute dmi_entry_raw_attr = {\n\t.attr = {.name = \"raw\", .mode = 0400},\n\t.read = dmi_entry_raw_read,\n};\n\nstatic void dmi_sysfs_entry_release(struct kobject *kobj)\n{\n\tstruct dmi_sysfs_entry *entry = to_entry(kobj);\n\n\tspin_lock(&entry_list_lock);\n\tlist_del(&entry->list);\n\tspin_unlock(&entry_list_lock);\n\tkfree(entry);\n}\n\nstatic const struct kobj_type dmi_sysfs_entry_ktype = {\n\t.release = dmi_sysfs_entry_release,\n\t.sysfs_ops = &dmi_sysfs_attr_ops,\n\t.default_groups = dmi_sysfs_entry_groups,\n};\n\nstatic struct kset *dmi_kset;\n\n \nstatic int __initdata instance_counts[MAX_ENTRY_TYPE + 1];\n\n \nstatic int __initdata position_count;\n\nstatic void __init dmi_sysfs_register_handle(const struct dmi_header *dh,\n\t\t\t\t\t     void *_ret)\n{\n\tstruct dmi_sysfs_entry *entry;\n\tint *ret = _ret;\n\n\t \n\tif (*ret)\n\t\treturn;\n\n\t \n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\t*ret = -ENOMEM;\n\t\treturn;\n\t}\n\n\t \n\tmemcpy(&entry->dh, dh, sizeof(*dh));\n\tentry->instance = instance_counts[dh->type]++;\n\tentry->position = position_count++;\n\n\tentry->kobj.kset = dmi_kset;\n\t*ret = kobject_init_and_add(&entry->kobj, &dmi_sysfs_entry_ktype, NULL,\n\t\t\t\t    \"%d-%d\", dh->type, entry->instance);\n\n\t \n\tspin_lock(&entry_list_lock);\n\tlist_add_tail(&entry->list, &entry_list);\n\tspin_unlock(&entry_list_lock);\n\n\tif (*ret) {\n\t\tkobject_put(&entry->kobj);\n\t\treturn;\n\t}\n\n\t \n\tswitch (dh->type) {\n\tcase DMI_ENTRY_SYSTEM_EVENT_LOG:\n\t\t*ret = dmi_system_event_log(entry);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\tif (*ret)\n\t\tgoto out_err;\n\n\t \n\t*ret = sysfs_create_bin_file(&entry->kobj, &dmi_entry_raw_attr);\n\tif (*ret)\n\t\tgoto out_err;\n\n\treturn;\nout_err:\n\tkobject_put(entry->child);\n\tkobject_put(&entry->kobj);\n\treturn;\n}\n\nstatic void cleanup_entry_list(void)\n{\n\tstruct dmi_sysfs_entry *entry, *next;\n\n\t \n\tlist_for_each_entry_safe(entry, next, &entry_list, list) {\n\t\tkobject_put(entry->child);\n\t\tkobject_put(&entry->kobj);\n\t}\n}\n\nstatic int __init dmi_sysfs_init(void)\n{\n\tint error;\n\tint val;\n\n\tif (!dmi_kobj) {\n\t\tpr_debug(\"dmi-sysfs: dmi entry is absent.\\n\");\n\t\terror = -ENODATA;\n\t\tgoto err;\n\t}\n\n\tdmi_kset = kset_create_and_add(\"entries\", NULL, dmi_kobj);\n\tif (!dmi_kset) {\n\t\terror = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tval = 0;\n\terror = dmi_walk(dmi_sysfs_register_handle, &val);\n\tif (error)\n\t\tgoto err;\n\tif (val) {\n\t\terror = val;\n\t\tgoto err;\n\t}\n\n\tpr_debug(\"dmi-sysfs: loaded.\\n\");\n\n\treturn 0;\nerr:\n\tcleanup_entry_list();\n\tkset_unregister(dmi_kset);\n\treturn error;\n}\n\n \nstatic void __exit dmi_sysfs_exit(void)\n{\n\tpr_debug(\"dmi-sysfs: unloading.\\n\");\n\tcleanup_entry_list();\n\tkset_unregister(dmi_kset);\n}\n\nmodule_init(dmi_sysfs_init);\nmodule_exit(dmi_sysfs_exit);\n\nMODULE_AUTHOR(\"Mike Waychison <mikew@google.com>\");\nMODULE_DESCRIPTION(\"DMI sysfs support\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}