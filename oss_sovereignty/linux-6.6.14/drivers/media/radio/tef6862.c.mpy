{
  "module_name": "tef6862.c",
  "hash_id": "1f8025b0b9ce6c5c0b27b97e9cf5569b6b05df6b17bde719d633238ba4d1dce2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/tef6862.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-device.h>\n\n#define DRIVER_NAME \"tef6862\"\n\n#define FREQ_MUL 16000\n\n#define TEF6862_LO_FREQ (875U * FREQ_MUL / 10)\n#define TEF6862_HI_FREQ (108U * FREQ_MUL)\n\n \n#define WM_SUB_BANDWIDTH\t0x0\n#define WM_SUB_PLLM\t\t0x1\n#define WM_SUB_PLLL\t\t0x2\n#define WM_SUB_DAA\t\t0x3\n#define WM_SUB_AGC\t\t0x4\n#define WM_SUB_BAND\t\t0x5\n#define WM_SUB_CONTROL\t\t0x6\n#define WM_SUB_LEVEL\t\t0x7\n#define WM_SUB_IFCF\t\t0x8\n#define WM_SUB_IFCAP\t\t0x9\n#define WM_SUB_ACD\t\t0xA\n#define WM_SUB_TEST\t\t0xF\n\n \n#define MSA_MODE_BUFFER\t\t0x0\n#define MSA_MODE_PRESET\t\t0x1\n#define MSA_MODE_SEARCH\t\t0x2\n#define MSA_MODE_AF_UPDATE\t0x3\n#define MSA_MODE_JUMP\t\t0x4\n#define MSA_MODE_CHECK\t\t0x5\n#define MSA_MODE_LOAD\t\t0x6\n#define MSA_MODE_END\t\t0x7\n#define MSA_MODE_SHIFT\t\t5\n\nstruct tef6862_state {\n\tstruct v4l2_subdev sd;\n\tunsigned long freq;\n};\n\nstatic inline struct tef6862_state *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct tef6862_state, sd);\n}\n\nstatic u16 tef6862_sigstr(struct i2c_client *client)\n{\n\tu8 buf[4];\n\tint err = i2c_master_recv(client, buf, sizeof(buf));\n\tif (err == sizeof(buf))\n\t\treturn buf[3] << 8;\n\treturn 0;\n}\n\nstatic int tef6862_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *v)\n{\n\tif (v->index > 0)\n\t\treturn -EINVAL;\n\n\t \n\tstrscpy(v->name, \"FM\", sizeof(v->name));\n\tv->type = V4L2_TUNER_RADIO;\n\tv->rangelow = TEF6862_LO_FREQ;\n\tv->rangehigh = TEF6862_HI_FREQ;\n\tv->rxsubchans = V4L2_TUNER_SUB_MONO;\n\tv->capability = V4L2_TUNER_CAP_LOW;\n\tv->audmode = V4L2_TUNER_MODE_STEREO;\n\tv->signal = tef6862_sigstr(v4l2_get_subdevdata(sd));\n\n\treturn 0;\n}\n\nstatic int tef6862_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *v)\n{\n\treturn v->index ? -EINVAL : 0;\n}\n\nstatic int tef6862_s_frequency(struct v4l2_subdev *sd, const struct v4l2_frequency *f)\n{\n\tstruct tef6862_state *state = to_state(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tunsigned freq = f->frequency;\n\tu16 pll;\n\tu8 i2cmsg[3];\n\tint err;\n\n\tif (f->tuner != 0)\n\t\treturn -EINVAL;\n\n\tfreq = clamp(freq, TEF6862_LO_FREQ, TEF6862_HI_FREQ);\n\tpll = 1964 + ((freq - TEF6862_LO_FREQ) * 20) / FREQ_MUL;\n\ti2cmsg[0] = (MSA_MODE_PRESET << MSA_MODE_SHIFT) | WM_SUB_PLLM;\n\ti2cmsg[1] = (pll >> 8) & 0xff;\n\ti2cmsg[2] = pll & 0xff;\n\n\terr = i2c_master_send(client, i2cmsg, sizeof(i2cmsg));\n\tif (err != sizeof(i2cmsg))\n\t\treturn err < 0 ? err : -EIO;\n\n\tstate->freq = freq;\n\treturn 0;\n}\n\nstatic int tef6862_g_frequency(struct v4l2_subdev *sd, struct v4l2_frequency *f)\n{\n\tstruct tef6862_state *state = to_state(sd);\n\n\tif (f->tuner != 0)\n\t\treturn -EINVAL;\n\tf->type = V4L2_TUNER_RADIO;\n\tf->frequency = state->freq;\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_tuner_ops tef6862_tuner_ops = {\n\t.g_tuner = tef6862_g_tuner,\n\t.s_tuner = tef6862_s_tuner,\n\t.s_frequency = tef6862_s_frequency,\n\t.g_frequency = tef6862_g_frequency,\n};\n\nstatic const struct v4l2_subdev_ops tef6862_ops = {\n\t.tuner = &tef6862_tuner_ops,\n};\n\n \n\nstatic int tef6862_probe(struct i2c_client *client)\n{\n\tstruct tef6862_state *state;\n\tstruct v4l2_subdev *sd;\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tv4l_info(client, \"chip found @ 0x%02x (%s)\\n\",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tstate = kzalloc(sizeof(struct tef6862_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\tstate->freq = TEF6862_LO_FREQ;\n\n\tsd = &state->sd;\n\tv4l2_i2c_subdev_init(sd, client, &tef6862_ops);\n\n\treturn 0;\n}\n\nstatic void tef6862_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\n\tv4l2_device_unregister_subdev(sd);\n\tkfree(to_state(sd));\n}\n\nstatic const struct i2c_device_id tef6862_id[] = {\n\t{DRIVER_NAME, 0},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(i2c, tef6862_id);\n\nstatic struct i2c_driver tef6862_driver = {\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t},\n\t.probe\t\t= tef6862_probe,\n\t.remove\t\t= tef6862_remove,\n\t.id_table\t= tef6862_id,\n};\n\nmodule_i2c_driver(tef6862_driver);\n\nMODULE_DESCRIPTION(\"TEF6862 Car Radio Enhanced Selectivity Tuner\");\nMODULE_AUTHOR(\"Mocean Laboratories\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}