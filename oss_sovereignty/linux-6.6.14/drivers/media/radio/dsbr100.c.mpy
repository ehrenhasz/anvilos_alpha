{
  "module_name": "dsbr100.c",
  "hash_id": "aa17a61026118206fbc433f6da395236e37dfc932d3737e341f4e43eae18c6cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/dsbr100.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/videodev2.h>\n#include <linux/usb.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n\n \nMODULE_AUTHOR(\"Markus Demleitner <msdemlei@tucana.harvard.edu>\");\nMODULE_DESCRIPTION(\"D-Link DSB-R100 USB FM radio driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"1.1.0\");\n\n#define DSB100_VENDOR 0x04b4\n#define DSB100_PRODUCT 0x1002\n\n \n#define DSB100_TUNE 1\n#define DSB100_ONOFF 2\n\n#define TB_LEN 16\n\n \n#define FREQ_MIN  87.5\n#define FREQ_MAX 108.0\n#define FREQ_MUL 16000\n\n#define v4l2_dev_to_radio(d) container_of(d, struct dsbr100_device, v4l2_dev)\n\nstatic int radio_nr = -1;\nmodule_param(radio_nr, int, 0);\n\n \nstruct dsbr100_device {\n\tstruct usb_device *usbdev;\n\tstruct video_device videodev;\n\tstruct v4l2_device v4l2_dev;\n\tstruct v4l2_ctrl_handler hdl;\n\n\tu8 *transfer_buffer;\n\tstruct mutex v4l2_lock;\n\tint curfreq;\n\tbool stereo;\n\tbool muted;\n};\n\n \n\n \nstatic int dsbr100_setfreq(struct dsbr100_device *radio, unsigned freq)\n{\n\tunsigned f = (freq / 16 * 80) / 1000 + 856;\n\tint retval = 0;\n\n\tif (!radio->muted) {\n\t\tretval = usb_control_msg(radio->usbdev,\n\t\t\t\tusb_rcvctrlpipe(radio->usbdev, 0),\n\t\t\t\tDSB100_TUNE,\n\t\t\t\tUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\n\t\t\t\t(f >> 8) & 0x00ff, f & 0xff,\n\t\t\t\tradio->transfer_buffer, 8, 300);\n\t\tif (retval >= 0)\n\t\t\tmdelay(1);\n\t}\n\n\tif (retval >= 0) {\n\t\tradio->curfreq = freq;\n\t\treturn 0;\n\t}\n\tdev_err(&radio->usbdev->dev,\n\t\t\"%s - usb_control_msg returned %i, request %i\\n\",\n\t\t\t__func__, retval, DSB100_TUNE);\n\treturn retval;\n}\n\n \nstatic int dsbr100_start(struct dsbr100_device *radio)\n{\n\tint retval = usb_control_msg(radio->usbdev,\n\t\tusb_rcvctrlpipe(radio->usbdev, 0),\n\t\tDSB100_ONOFF,\n\t\tUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\n\t\t0x01, 0x00, radio->transfer_buffer, 8, 300);\n\n\tif (retval >= 0)\n\t\treturn dsbr100_setfreq(radio, radio->curfreq);\n\tdev_err(&radio->usbdev->dev,\n\t\t\"%s - usb_control_msg returned %i, request %i\\n\",\n\t\t\t__func__, retval, DSB100_ONOFF);\n\treturn retval;\n\n}\n\n \nstatic int dsbr100_stop(struct dsbr100_device *radio)\n{\n\tint retval = usb_control_msg(radio->usbdev,\n\t\tusb_rcvctrlpipe(radio->usbdev, 0),\n\t\tDSB100_ONOFF,\n\t\tUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\n\t\t0x00, 0x00, radio->transfer_buffer, 8, 300);\n\n\tif (retval >= 0)\n\t\treturn 0;\n\tdev_err(&radio->usbdev->dev,\n\t\t\"%s - usb_control_msg returned %i, request %i\\n\",\n\t\t\t__func__, retval, DSB100_ONOFF);\n\treturn retval;\n\n}\n\n \nstatic void dsbr100_getstat(struct dsbr100_device *radio)\n{\n\tint retval = usb_control_msg(radio->usbdev,\n\t\tusb_rcvctrlpipe(radio->usbdev, 0),\n\t\tUSB_REQ_GET_STATUS,\n\t\tUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\n\t\t0x00, 0x24, radio->transfer_buffer, 8, 300);\n\n\tif (retval < 0) {\n\t\tradio->stereo = false;\n\t\tdev_err(&radio->usbdev->dev,\n\t\t\t\"%s - usb_control_msg returned %i, request %i\\n\",\n\t\t\t\t__func__, retval, USB_REQ_GET_STATUS);\n\t} else {\n\t\tradio->stereo = !(radio->transfer_buffer[0] & 0x01);\n\t}\n}\n\nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_capability *v)\n{\n\tstruct dsbr100_device *radio = video_drvdata(file);\n\n\tstrscpy(v->driver, \"dsbr100\", sizeof(v->driver));\n\tstrscpy(v->card, \"D-Link R-100 USB FM Radio\", sizeof(v->card));\n\tusb_make_path(radio->usbdev, v->bus_info, sizeof(v->bus_info));\n\treturn 0;\n}\n\nstatic int vidioc_g_tuner(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_tuner *v)\n{\n\tstruct dsbr100_device *radio = video_drvdata(file);\n\n\tif (v->index > 0)\n\t\treturn -EINVAL;\n\n\tdsbr100_getstat(radio);\n\tstrscpy(v->name, \"FM\", sizeof(v->name));\n\tv->type = V4L2_TUNER_RADIO;\n\tv->rangelow = FREQ_MIN * FREQ_MUL;\n\tv->rangehigh = FREQ_MAX * FREQ_MUL;\n\tv->rxsubchans = radio->stereo ? V4L2_TUNER_SUB_STEREO :\n\t\tV4L2_TUNER_SUB_MONO;\n\tv->capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO;\n\tv->audmode = V4L2_TUNER_MODE_STEREO;\n\tv->signal = radio->stereo ? 0xffff : 0;      \n\treturn 0;\n}\n\nstatic int vidioc_s_tuner(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_tuner *v)\n{\n\treturn v->index ? -EINVAL : 0;\n}\n\nstatic int vidioc_s_frequency(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_frequency *f)\n{\n\tstruct dsbr100_device *radio = video_drvdata(file);\n\n\tif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\n\t\treturn -EINVAL;\n\n\treturn dsbr100_setfreq(radio, clamp_t(unsigned, f->frequency,\n\t\t\tFREQ_MIN * FREQ_MUL, FREQ_MAX * FREQ_MUL));\n}\n\nstatic int vidioc_g_frequency(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_frequency *f)\n{\n\tstruct dsbr100_device *radio = video_drvdata(file);\n\n\tif (f->tuner)\n\t\treturn -EINVAL;\n\tf->type = V4L2_TUNER_RADIO;\n\tf->frequency = radio->curfreq;\n\treturn 0;\n}\n\nstatic int usb_dsbr100_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct dsbr100_device *radio =\n\t\tcontainer_of(ctrl->handler, struct dsbr100_device, hdl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\tradio->muted = ctrl->val;\n\t\treturn radio->muted ? dsbr100_stop(radio) : dsbr100_start(radio);\n\t}\n\treturn -EINVAL;\n}\n\n\n \n\n \nstatic void usb_dsbr100_disconnect(struct usb_interface *intf)\n{\n\tstruct dsbr100_device *radio = usb_get_intfdata(intf);\n\n\tmutex_lock(&radio->v4l2_lock);\n\t \n\tusb_control_msg(radio->usbdev,\n\t\tusb_rcvctrlpipe(radio->usbdev, 0),\n\t\tDSB100_ONOFF,\n\t\tUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\n\t\t0x00, 0x00, radio->transfer_buffer, 8, 300);\n\tusb_set_intfdata(intf, NULL);\n\tvideo_unregister_device(&radio->videodev);\n\tv4l2_device_disconnect(&radio->v4l2_dev);\n\tmutex_unlock(&radio->v4l2_lock);\n\tv4l2_device_put(&radio->v4l2_dev);\n}\n\n\n \nstatic int usb_dsbr100_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct dsbr100_device *radio = usb_get_intfdata(intf);\n\n\tmutex_lock(&radio->v4l2_lock);\n\tif (!radio->muted && dsbr100_stop(radio) < 0)\n\t\tdev_warn(&intf->dev, \"dsbr100_stop failed\\n\");\n\tmutex_unlock(&radio->v4l2_lock);\n\n\tdev_info(&intf->dev, \"going into suspend..\\n\");\n\treturn 0;\n}\n\n \nstatic int usb_dsbr100_resume(struct usb_interface *intf)\n{\n\tstruct dsbr100_device *radio = usb_get_intfdata(intf);\n\n\tmutex_lock(&radio->v4l2_lock);\n\tif (!radio->muted && dsbr100_start(radio) < 0)\n\t\tdev_warn(&intf->dev, \"dsbr100_start failed\\n\");\n\tmutex_unlock(&radio->v4l2_lock);\n\n\tdev_info(&intf->dev, \"coming out of suspend..\\n\");\n\treturn 0;\n}\n\n \nstatic void usb_dsbr100_release(struct v4l2_device *v4l2_dev)\n{\n\tstruct dsbr100_device *radio = v4l2_dev_to_radio(v4l2_dev);\n\n\tv4l2_ctrl_handler_free(&radio->hdl);\n\tv4l2_device_unregister(&radio->v4l2_dev);\n\tkfree(radio->transfer_buffer);\n\tkfree(radio);\n}\n\nstatic const struct v4l2_ctrl_ops usb_dsbr100_ctrl_ops = {\n\t.s_ctrl = usb_dsbr100_s_ctrl,\n};\n\n \nstatic const struct v4l2_file_operations usb_dsbr100_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.open           = v4l2_fh_open,\n\t.release        = v4l2_fh_release,\n\t.poll\t\t= v4l2_ctrl_poll,\n};\n\nstatic const struct v4l2_ioctl_ops usb_dsbr100_ioctl_ops = {\n\t.vidioc_querycap    = vidioc_querycap,\n\t.vidioc_g_tuner     = vidioc_g_tuner,\n\t.vidioc_s_tuner     = vidioc_s_tuner,\n\t.vidioc_g_frequency = vidioc_g_frequency,\n\t.vidioc_s_frequency = vidioc_s_frequency,\n\t.vidioc_log_status  = v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\n \nstatic int usb_dsbr100_probe(struct usb_interface *intf,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct dsbr100_device *radio;\n\tstruct v4l2_device *v4l2_dev;\n\tint retval;\n\n\tradio = kzalloc(sizeof(struct dsbr100_device), GFP_KERNEL);\n\n\tif (!radio)\n\t\treturn -ENOMEM;\n\n\tradio->transfer_buffer = kmalloc(TB_LEN, GFP_KERNEL);\n\n\tif (!(radio->transfer_buffer)) {\n\t\tkfree(radio);\n\t\treturn -ENOMEM;\n\t}\n\n\tv4l2_dev = &radio->v4l2_dev;\n\tv4l2_dev->release = usb_dsbr100_release;\n\n\tretval = v4l2_device_register(&intf->dev, v4l2_dev);\n\tif (retval < 0) {\n\t\tv4l2_err(v4l2_dev, \"couldn't register v4l2_device\\n\");\n\t\tgoto err_reg_dev;\n\t}\n\n\tv4l2_ctrl_handler_init(&radio->hdl, 1);\n\tv4l2_ctrl_new_std(&radio->hdl, &usb_dsbr100_ctrl_ops,\n\t\t\t  V4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\n\tif (radio->hdl.error) {\n\t\tretval = radio->hdl.error;\n\t\tv4l2_err(v4l2_dev, \"couldn't register control\\n\");\n\t\tgoto err_reg_ctrl;\n\t}\n\tmutex_init(&radio->v4l2_lock);\n\tstrscpy(radio->videodev.name, v4l2_dev->name,\n\t\tsizeof(radio->videodev.name));\n\tradio->videodev.v4l2_dev = v4l2_dev;\n\tradio->videodev.fops = &usb_dsbr100_fops;\n\tradio->videodev.ioctl_ops = &usb_dsbr100_ioctl_ops;\n\tradio->videodev.release = video_device_release_empty;\n\tradio->videodev.lock = &radio->v4l2_lock;\n\tradio->videodev.ctrl_handler = &radio->hdl;\n\tradio->videodev.device_caps = V4L2_CAP_RADIO | V4L2_CAP_TUNER;\n\n\tradio->usbdev = interface_to_usbdev(intf);\n\tradio->curfreq = FREQ_MIN * FREQ_MUL;\n\tradio->muted = true;\n\n\tvideo_set_drvdata(&radio->videodev, radio);\n\tusb_set_intfdata(intf, radio);\n\n\tretval = video_register_device(&radio->videodev, VFL_TYPE_RADIO, radio_nr);\n\tif (retval == 0)\n\t\treturn 0;\n\tv4l2_err(v4l2_dev, \"couldn't register video device\\n\");\n\nerr_reg_ctrl:\n\tv4l2_ctrl_handler_free(&radio->hdl);\n\tv4l2_device_unregister(v4l2_dev);\nerr_reg_dev:\n\tkfree(radio->transfer_buffer);\n\tkfree(radio);\n\treturn retval;\n}\n\nstatic const struct usb_device_id usb_dsbr100_device_table[] = {\n\t{ USB_DEVICE(DSB100_VENDOR, DSB100_PRODUCT) },\n\t{ }\t\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, usb_dsbr100_device_table);\n\n \nstatic struct usb_driver usb_dsbr100_driver = {\n\t.name\t\t\t= \"dsbr100\",\n\t.probe\t\t\t= usb_dsbr100_probe,\n\t.disconnect\t\t= usb_dsbr100_disconnect,\n\t.id_table\t\t= usb_dsbr100_device_table,\n\t.suspend\t\t= usb_dsbr100_suspend,\n\t.resume\t\t\t= usb_dsbr100_resume,\n\t.reset_resume\t\t= usb_dsbr100_resume,\n};\n\nmodule_usb_driver(usb_dsbr100_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}