{
  "module_name": "saa7706h.c",
  "hash_id": "363411df95d1839974a7b68648612fb52a6ea5464570b7ef2f5f13b9ecb7d819",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/saa7706h.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n\n#define DRIVER_NAME \"saa7706h\"\n\n \n\n#define SAA7706H_REG_CTRL\t\t0x0fff\n#define SAA7706H_CTRL_BYP_PLL\t\t0x0001\n#define SAA7706H_CTRL_PLL_DIV_MASK\t0x003e\n#define SAA7706H_CTRL_PLL3_62975MHZ\t0x003e\n#define SAA7706H_CTRL_DSP_TURBO\t\t0x0040\n#define SAA7706H_CTRL_PC_RESET_DSP1\t0x0080\n#define SAA7706H_CTRL_PC_RESET_DSP2\t0x0100\n#define SAA7706H_CTRL_DSP1_ROM_EN_MASK\t0x0600\n#define SAA7706H_CTRL_DSP1_FUNC_PROM\t0x0000\n#define SAA7706H_CTRL_DSP2_ROM_EN_MASK\t0x1800\n#define SAA7706H_CTRL_DSP2_FUNC_PROM\t0x0000\n#define SAA7706H_CTRL_DIG_SIL_INTERPOL\t0x8000\n\n#define SAA7706H_REG_EVALUATION\t\t\t0x1ff0\n#define SAA7706H_EVAL_DISABLE_CHARGE_PUMP\t0x000001\n#define SAA7706H_EVAL_DCS_CLOCK\t\t\t0x000002\n#define SAA7706H_EVAL_GNDRC1_ENABLE\t\t0x000004\n#define SAA7706H_EVAL_GNDRC2_ENABLE\t\t0x000008\n\n#define SAA7706H_REG_CL_GEN1\t\t\t0x1ff3\n#define SAA7706H_CL_GEN1_MIN_LOOPGAIN_MASK\t0x00000f\n#define SAA7706H_CL_GEN1_LOOPGAIN_MASK\t\t0x0000f0\n#define SAA7706H_CL_GEN1_COARSE_RATION\t\t0xffff00\n\n#define SAA7706H_REG_CL_GEN2\t\t\t0x1ff4\n#define SAA7706H_CL_GEN2_WSEDGE_FALLING\t\t0x000001\n#define SAA7706H_CL_GEN2_STOP_VCO\t\t0x000002\n#define SAA7706H_CL_GEN2_FRERUN\t\t\t0x000004\n#define SAA7706H_CL_GEN2_ADAPTIVE\t\t0x000008\n#define SAA7706H_CL_GEN2_FINE_RATIO_MASK\t0x0ffff0\n\n#define SAA7706H_REG_CL_GEN4\t\t0x1ff6\n#define SAA7706H_CL_GEN4_BYPASS_PLL1\t0x001000\n#define SAA7706H_CL_GEN4_PLL1_DIV_MASK\t0x03e000\n#define SAA7706H_CL_GEN4_DSP1_TURBO\t0x040000\n\n#define SAA7706H_REG_SEL\t0x1ff7\n#define SAA7706H_SEL_DSP2_SRCA_MASK\t0x000007\n#define SAA7706H_SEL_DSP2_FMTA_MASK\t0x000031\n#define SAA7706H_SEL_DSP2_SRCB_MASK\t0x0001c0\n#define SAA7706H_SEL_DSP2_FMTB_MASK\t0x000e00\n#define SAA7706H_SEL_DSP1_SRC_MASK\t0x003000\n#define SAA7706H_SEL_DSP1_FMT_MASK\t0x01c003\n#define SAA7706H_SEL_SPDIF2\t\t0x020000\n#define SAA7706H_SEL_HOST_IO_FMT_MASK\t0x1c0000\n#define SAA7706H_SEL_EN_HOST_IO\t\t0x200000\n\n#define SAA7706H_REG_IAC\t\t0x1ff8\n#define SAA7706H_REG_CLK_SET\t\t0x1ff9\n#define SAA7706H_REG_CLK_COEFF\t\t0x1ffa\n#define SAA7706H_REG_INPUT_SENS\t\t0x1ffb\n#define SAA7706H_INPUT_SENS_RDS_VOL_MASK\t0x0003f\n#define SAA7706H_INPUT_SENS_FM_VOL_MASK\t\t0x00fc0\n#define SAA7706H_INPUT_SENS_FM_MPX\t\t0x01000\n#define SAA7706H_INPUT_SENS_OFF_FILTER_A_EN\t0x02000\n#define SAA7706H_INPUT_SENS_OFF_FILTER_B_EN\t0x04000\n#define SAA7706H_REG_PHONE_NAV_AUDIO\t0x1ffc\n#define SAA7706H_REG_IO_CONF_DSP2\t0x1ffd\n#define SAA7706H_REG_STATUS_DSP2\t0x1ffe\n#define SAA7706H_REG_PC_DSP2\t\t0x1fff\n\n#define SAA7706H_DSP1_MOD0\t0x0800\n#define SAA7706H_DSP1_ROM_VER\t0x097f\n#define SAA7706H_DSP2_MPTR0\t0x1000\n\n#define SAA7706H_DSP1_MODPNTR\t0x0000\n\n#define SAA7706H_DSP2_XMEM_CONTLLCW\t0x113e\n#define SAA7706H_DSP2_XMEM_BUSAMP\t0x114a\n#define SAA7706H_DSP2_XMEM_FDACPNTR\t0x11f9\n#define SAA7706H_DSP2_XMEM_IIS1PNTR\t0x11fb\n\n#define SAA7706H_DSP2_YMEM_PVGA\t\t0x212a\n#define SAA7706H_DSP2_YMEM_PVAT1\t0x212b\n#define SAA7706H_DSP2_YMEM_PVAT\t\t0x212c\n#define SAA7706H_DSP2_YMEM_ROM_VER\t0x21ff\n\n#define SUPPORTED_DSP1_ROM_VER\t\t0x667\n\nstruct saa7706h_state {\n\tstruct v4l2_subdev sd;\n\tstruct v4l2_ctrl_handler hdl;\n\tunsigned muted;\n};\n\nstatic inline struct saa7706h_state *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct saa7706h_state, sd);\n}\n\nstatic int saa7706h_i2c_send(struct i2c_client *client, const u8 *data, int len)\n{\n\tint err = i2c_master_send(client, data, len);\n\tif (err == len)\n\t\treturn 0;\n\treturn err > 0 ? -EIO : err;\n}\n\nstatic int saa7706h_i2c_transfer(struct i2c_client *client,\n\tstruct i2c_msg *msgs, int num)\n{\n\tint err = i2c_transfer(client->adapter, msgs, num);\n\tif (err == num)\n\t\treturn 0;\n\treturn err > 0 ? -EIO : err;\n}\n\nstatic int saa7706h_set_reg24(struct v4l2_subdev *sd, u16 reg, u32 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tu8 buf[5];\n\tint pos = 0;\n\n\tbuf[pos++] = reg >> 8;\n\tbuf[pos++] = reg;\n\tbuf[pos++] = val >> 16;\n\tbuf[pos++] = val >> 8;\n\tbuf[pos++] = val;\n\n\treturn saa7706h_i2c_send(client, buf, pos);\n}\n\nstatic int saa7706h_set_reg24_err(struct v4l2_subdev *sd, u16 reg, u32 val,\n\tint *err)\n{\n\treturn *err ? *err : saa7706h_set_reg24(sd, reg, val);\n}\n\nstatic int saa7706h_set_reg16(struct v4l2_subdev *sd, u16 reg, u16 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tu8 buf[4];\n\tint pos = 0;\n\n\tbuf[pos++] = reg >> 8;\n\tbuf[pos++] = reg;\n\tbuf[pos++] = val >> 8;\n\tbuf[pos++] = val;\n\n\treturn saa7706h_i2c_send(client, buf, pos);\n}\n\nstatic int saa7706h_set_reg16_err(struct v4l2_subdev *sd, u16 reg, u16 val,\n\tint *err)\n{\n\treturn *err ? *err : saa7706h_set_reg16(sd, reg, val);\n}\n\nstatic int saa7706h_get_reg16(struct v4l2_subdev *sd, u16 reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tu8 buf[2];\n\tint err;\n\tu8 regaddr[] = {reg >> 8, reg};\n\tstruct i2c_msg msg[] = {\n\t\t\t\t\t{\n\t\t\t\t\t\t.addr = client->addr,\n\t\t\t\t\t\t.len = sizeof(regaddr),\n\t\t\t\t\t\t.buf = regaddr\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t.addr = client->addr,\n\t\t\t\t\t\t.flags = I2C_M_RD,\n\t\t\t\t\t\t.len = sizeof(buf),\n\t\t\t\t\t\t.buf = buf\n\t\t\t\t\t}\n\t\t\t\t};\n\n\terr = saa7706h_i2c_transfer(client, msg, ARRAY_SIZE(msg));\n\tif (err)\n\t\treturn err;\n\n\treturn buf[0] << 8 | buf[1];\n}\n\nstatic int saa7706h_unmute(struct v4l2_subdev *sd)\n{\n\tstruct saa7706h_state *state = to_state(sd);\n\tint err = 0;\n\n\terr = saa7706h_set_reg16_err(sd, SAA7706H_REG_CTRL,\n\t\tSAA7706H_CTRL_PLL3_62975MHZ | SAA7706H_CTRL_PC_RESET_DSP1 |\n\t\tSAA7706H_CTRL_PC_RESET_DSP2, &err);\n\n\t \n\tmsleep(1);\n\n\terr = saa7706h_set_reg16_err(sd, SAA7706H_REG_CTRL,\n\t\tSAA7706H_CTRL_PLL3_62975MHZ, &err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_REG_EVALUATION, 0, &err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_REG_CL_GEN1, 0x040022, &err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_REG_CL_GEN2,\n\t\tSAA7706H_CL_GEN2_WSEDGE_FALLING, &err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_REG_CL_GEN4, 0x024080, &err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_REG_SEL, 0x200080, &err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_REG_IAC, 0xf4caed, &err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_REG_CLK_SET, 0x124334, &err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_REG_CLK_COEFF, 0x004a1a,\n\t\t&err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_REG_INPUT_SENS, 0x0071c7,\n\t\t&err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_REG_PHONE_NAV_AUDIO,\n\t\t0x0e22ff, &err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_REG_IO_CONF_DSP2, 0x001ff8,\n\t\t&err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_REG_STATUS_DSP2, 0x080003,\n\t\t&err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_REG_PC_DSP2, 0x000004, &err);\n\n\terr = saa7706h_set_reg16_err(sd, SAA7706H_DSP1_MOD0, 0x0c6c, &err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_DSP2_MPTR0, 0x000b4b, &err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_DSP1_MODPNTR, 0x000600, &err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_DSP1_MODPNTR, 0x0000c0, &err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_DSP2_XMEM_CONTLLCW, 0x000819,\n\t\t&err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_DSP2_XMEM_CONTLLCW, 0x00085a,\n\t\t&err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_DSP2_XMEM_BUSAMP, 0x7fffff,\n\t\t&err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_DSP2_XMEM_FDACPNTR, 0x2000cb,\n\t\t&err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_DSP2_XMEM_IIS1PNTR, 0x2000cb,\n\t\t&err);\n\n\terr = saa7706h_set_reg16_err(sd, SAA7706H_DSP2_YMEM_PVGA, 0x0f80, &err);\n\n\terr = saa7706h_set_reg16_err(sd, SAA7706H_DSP2_YMEM_PVAT1, 0x0800,\n\t\t&err);\n\n\terr = saa7706h_set_reg16_err(sd, SAA7706H_DSP2_YMEM_PVAT, 0x0800, &err);\n\n\terr = saa7706h_set_reg24_err(sd, SAA7706H_DSP2_XMEM_CONTLLCW, 0x000905,\n\t\t&err);\n\tif (!err)\n\t\tstate->muted = 0;\n\treturn err;\n}\n\nstatic int saa7706h_mute(struct v4l2_subdev *sd)\n{\n\tstruct saa7706h_state *state = to_state(sd);\n\tint err;\n\n\terr = saa7706h_set_reg16(sd, SAA7706H_REG_CTRL,\n\t\tSAA7706H_CTRL_PLL3_62975MHZ | SAA7706H_CTRL_PC_RESET_DSP1 |\n\t\tSAA7706H_CTRL_PC_RESET_DSP2);\n\tif (!err)\n\t\tstate->muted = 1;\n\treturn err;\n}\n\nstatic int saa7706h_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct saa7706h_state *state =\n\t\tcontainer_of(ctrl->handler, struct saa7706h_state, hdl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\tif (ctrl->val)\n\t\t\treturn saa7706h_mute(&state->sd);\n\t\treturn saa7706h_unmute(&state->sd);\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct v4l2_ctrl_ops saa7706h_ctrl_ops = {\n\t.s_ctrl = saa7706h_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_ops empty_ops = {};\n\n \n\nstatic int saa7706h_probe(struct i2c_client *client)\n{\n\tstruct saa7706h_state *state;\n\tstruct v4l2_subdev *sd;\n\tint err;\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tv4l_info(client, \"chip found @ 0x%02x (%s)\\n\",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tstate = kzalloc(sizeof(struct saa7706h_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\tsd = &state->sd;\n\tv4l2_i2c_subdev_init(sd, client, &empty_ops);\n\n\tv4l2_ctrl_handler_init(&state->hdl, 4);\n\tv4l2_ctrl_new_std(&state->hdl, &saa7706h_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\n\tsd->ctrl_handler = &state->hdl;\n\terr = state->hdl.error;\n\tif (err)\n\t\tgoto err;\n\n\t \n\terr = saa7706h_get_reg16(sd, SAA7706H_DSP1_ROM_VER);\n\tif (err < 0)\n\t\tgoto err;\n\tif (err != SUPPORTED_DSP1_ROM_VER)\n\t\tv4l2_warn(sd, \"Unknown DSP1 ROM code version: 0x%x\\n\", err);\n\tstate->muted = 1;\n\n\t \n\terr = saa7706h_mute(sd);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tv4l2_device_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(&state->hdl);\n\tkfree(to_state(sd));\n\n\tprintk(KERN_ERR DRIVER_NAME \": Failed to probe: %d\\n\", err);\n\n\treturn err;\n}\n\nstatic void saa7706h_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct saa7706h_state *state = to_state(sd);\n\n\tsaa7706h_mute(sd);\n\tv4l2_device_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(&state->hdl);\n\tkfree(to_state(sd));\n}\n\nstatic const struct i2c_device_id saa7706h_id[] = {\n\t{DRIVER_NAME, 0},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(i2c, saa7706h_id);\n\nstatic struct i2c_driver saa7706h_driver = {\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t},\n\t.probe\t\t= saa7706h_probe,\n\t.remove\t\t= saa7706h_remove,\n\t.id_table\t= saa7706h_id,\n};\n\nmodule_i2c_driver(saa7706h_driver);\n\nMODULE_DESCRIPTION(\"SAA7706H Car Radio DSP driver\");\nMODULE_AUTHOR(\"Mocean Laboratories\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}