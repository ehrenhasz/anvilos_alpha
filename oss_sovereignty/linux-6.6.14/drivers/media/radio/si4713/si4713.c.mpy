{
  "module_name": "si4713.c",
  "hash_id": "69d18ea86fc2998eba6a91d29e875af05e686b993dcd05cad2cb6959cdcf59a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/si4713/si4713.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-common.h>\n\n#include \"si4713.h\"\n\n \nstatic int debug;\nmodule_param(debug, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"Debug level (0 - 2)\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Eduardo Valentin <eduardo.valentin@nokia.com>\");\nMODULE_DESCRIPTION(\"I2C driver for Si4713 FM Radio Transmitter\");\nMODULE_VERSION(\"0.0.1\");\n\n#define DEFAULT_RDS_PI\t\t\t0x00\n#define DEFAULT_RDS_PTY\t\t\t0x00\n#define DEFAULT_RDS_DEVIATION\t\t0x00C8\n#define DEFAULT_RDS_PS_REPEAT_COUNT\t0x0003\n#define DEFAULT_LIMITER_RTIME\t\t0x1392\n#define DEFAULT_LIMITER_DEV\t\t0x102CA\n#define DEFAULT_PILOT_FREQUENCY\t\t0x4A38\n#define DEFAULT_PILOT_DEVIATION\t\t0x1A5E\n#define DEFAULT_ACOMP_ATIME\t\t0x0000\n#define DEFAULT_ACOMP_RTIME\t\t0xF4240L\n#define DEFAULT_ACOMP_GAIN\t\t0x0F\n#define DEFAULT_ACOMP_THRESHOLD\t\t(-0x28)\n#define DEFAULT_MUTE\t\t\t0x01\n#define DEFAULT_POWER_LEVEL\t\t88\n#define DEFAULT_FREQUENCY\t\t8800\n#define DEFAULT_PREEMPHASIS\t\tFMPE_EU\n#define DEFAULT_TUNE_RNL\t\t0xFF\n\n#define to_si4713_device(sd)\tcontainer_of(sd, struct si4713_device, sd)\n\n \n#define FREQDEV_UNIT\t100000\n#define FREQV4L2_MULTI\t625\n#define si4713_to_v4l2(f)\t((f * FREQDEV_UNIT) / FREQV4L2_MULTI)\n#define v4l2_to_si4713(f)\t((f * FREQV4L2_MULTI) / FREQDEV_UNIT)\n#define FREQ_RANGE_LOW\t\t\t7600\n#define FREQ_RANGE_HIGH\t\t\t10800\n\n#define MAX_ARGS 7\n\n#define RDS_BLOCK\t\t\t8\n#define RDS_BLOCK_CLEAR\t\t\t0x03\n#define RDS_BLOCK_LOAD\t\t\t0x04\n#define RDS_RADIOTEXT_2A\t\t0x20\n#define RDS_RADIOTEXT_BLK_SIZE\t\t4\n#define RDS_RADIOTEXT_INDEX_MAX\t\t0x0F\n#define RDS_CARRIAGE_RETURN\t\t0x0D\n\n#define rds_ps_nblocks(len)\t((len / RDS_BLOCK) + (len % RDS_BLOCK ? 1 : 0))\n\n#define get_status_bit(p, b, m)\t(((p) & (m)) >> (b))\n#define set_bits(p, v, b, m)\t(((p) & ~(m)) | ((v) << (b)))\n\n#define ATTACK_TIME_UNIT\t500\n\n#define POWER_OFF\t\t\t0x00\n#define POWER_ON\t\t\t0x01\n\n#define msb(x)                  ((u8)((u16) x >> 8))\n#define lsb(x)                  ((u8)((u16) x &  0x00FF))\n#define compose_u16(msb, lsb)\t(((u16)msb << 8) | lsb)\n#define check_command_failed(status)\t(!(status & SI4713_CTS) || \\\n\t\t\t\t\t(status & SI4713_ERR))\n \n#define set_mute(p)\t(((p) & 1) | (((p) & 1) << 1))\n\n#ifdef DEBUG\n#define DBG_BUFFER(device, message, buffer, size)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tint i;\t\t\t\t\t\t\t\\\n\t\tchar str[(size)*5];\t\t\t\t\t\\\n\t\tfor (i = 0; i < size; i++)\t\t\t\t\\\n\t\t\tsprintf(str + i * 5, \" 0x%02x\", buffer[i]);\t\\\n\t\tv4l2_dbg(2, debug, device, \"%s:%s\\n\", message, str);\t\\\n\t}\n#else\n#define DBG_BUFFER(device, message, buffer, size)\n#endif\n\n \nstatic long limiter_times[] = {\n\t2000,\t250,\n\t1000,\t500,\n\t510,\t1000,\n\t255,\t2000,\n\t170,\t3000,\n\t127,\t4020,\n\t102,\t5010,\n\t85,\t6020,\n\t73,\t7010,\n\t64,\t7990,\n\t57,\t8970,\n\t51,\t10030,\n\t25,\t20470,\n\t17,\t30110,\n\t13,\t39380,\n\t10,\t51190,\n\t8,\t63690,\n\t7,\t73140,\n\t6,\t85330,\n\t5,\t102390,\n};\n\n \nstatic unsigned long acomp_rtimes[] = {\n\t0,\t100000,\n\t1,\t200000,\n\t2,\t350000,\n\t3,\t525000,\n\t4,\t1000000,\n};\n\n \nstatic unsigned long preemphasis_values[] = {\n\tFMPE_DISABLED,\tV4L2_PREEMPHASIS_DISABLED,\n\tFMPE_EU,\tV4L2_PREEMPHASIS_50_uS,\n\tFMPE_USA,\tV4L2_PREEMPHASIS_75_uS,\n};\n\nstatic int usecs_to_dev(unsigned long usecs, unsigned long const array[],\n\t\t\tint size)\n{\n\tint i;\n\tint rval = -EINVAL;\n\n\tfor (i = 0; i < size / 2; i++)\n\t\tif (array[(i * 2) + 1] >= usecs) {\n\t\t\trval = array[i * 2];\n\t\t\tbreak;\n\t\t}\n\n\treturn rval;\n}\n\n \nstatic irqreturn_t si4713_handler(int irq, void *dev)\n{\n\tstruct si4713_device *sdev = dev;\n\n\tv4l2_dbg(2, debug, &sdev->sd,\n\t\t\t\"%s: sending signal to completion work.\\n\", __func__);\n\tcomplete(&sdev->work);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int si4713_send_command(struct si4713_device *sdev, const u8 command,\n\t\t\t\tconst u8 args[], const int argn,\n\t\t\t\tu8 response[], const int respn, const int usecs)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sdev->sd);\n\tunsigned long until_jiffies;\n\tu8 data1[MAX_ARGS + 1];\n\tint err;\n\n\tif (!client->adapter)\n\t\treturn -ENODEV;\n\n\t \n\tdata1[0] = command;\n\tmemcpy(data1 + 1, args, argn);\n\tDBG_BUFFER(&sdev->sd, \"Parameters\", data1, argn + 1);\n\n\terr = i2c_master_send(client, data1, argn + 1);\n\tif (err != argn + 1) {\n\t\tv4l2_err(&sdev->sd, \"Error while sending command 0x%02x\\n\",\n\t\t\tcommand);\n\t\treturn err < 0 ? err : -EIO;\n\t}\n\n\tuntil_jiffies = jiffies + usecs_to_jiffies(usecs) + 1;\n\n\t \n\tif (client->irq) {\n\t\tif (!wait_for_completion_timeout(&sdev->work,\n\t\t\t\tusecs_to_jiffies(usecs) + 1))\n\t\t\tv4l2_warn(&sdev->sd,\n\t\t\t\t\"(%s) Device took too much time to answer.\\n\",\n\t\t\t\t__func__);\n\t}\n\n\tdo {\n\t\terr = i2c_master_recv(client, response, respn);\n\t\tif (err != respn) {\n\t\t\tv4l2_err(&sdev->sd,\n\t\t\t\t\"Error %d while reading response for command 0x%02x\\n\",\n\t\t\t\terr, command);\n\t\t\treturn err < 0 ? err : -EIO;\n\t\t}\n\n\t\tDBG_BUFFER(&sdev->sd, \"Response\", response, respn);\n\t\tif (!check_command_failed(response[0]))\n\t\t\treturn 0;\n\n\t\tif (client->irq)\n\t\t\treturn -EBUSY;\n\t\tif (usecs <= 1000)\n\t\t\tusleep_range(usecs, 1000);\n\t\telse\n\t\t\tusleep_range(1000, 2000);\n\t} while (time_is_after_jiffies(until_jiffies));\n\n\treturn -EBUSY;\n}\n\n \nstatic int si4713_read_property(struct si4713_device *sdev, u16 prop, u32 *pv)\n{\n\tint err;\n\tu8 val[SI4713_GET_PROP_NRESP];\n\t \n\tconst u8 args[SI4713_GET_PROP_NARGS] = {\n\t\t0x00,\n\t\tmsb(prop),\n\t\tlsb(prop),\n\t};\n\n\terr = si4713_send_command(sdev, SI4713_CMD_GET_PROPERTY,\n\t\t\t\t  args, ARRAY_SIZE(args), val,\n\t\t\t\t  ARRAY_SIZE(val), DEFAULT_TIMEOUT);\n\n\tif (err < 0)\n\t\treturn err;\n\n\t*pv = compose_u16(val[2], val[3]);\n\n\tv4l2_dbg(1, debug, &sdev->sd,\n\t\t\t\"%s: property=0x%02x value=0x%02x status=0x%02x\\n\",\n\t\t\t__func__, prop, *pv, val[0]);\n\n\treturn err;\n}\n\n \nstatic int si4713_write_property(struct si4713_device *sdev, u16 prop, u16 val)\n{\n\tint rval;\n\tu8 resp[SI4713_SET_PROP_NRESP];\n\t \n\tconst u8 args[SI4713_SET_PROP_NARGS] = {\n\t\t0x00,\n\t\tmsb(prop),\n\t\tlsb(prop),\n\t\tmsb(val),\n\t\tlsb(val),\n\t};\n\n\trval = si4713_send_command(sdev, SI4713_CMD_SET_PROPERTY,\n\t\t\t\t\targs, ARRAY_SIZE(args),\n\t\t\t\t\tresp, ARRAY_SIZE(resp),\n\t\t\t\t\tDEFAULT_TIMEOUT);\n\n\tif (rval < 0)\n\t\treturn rval;\n\n\tv4l2_dbg(1, debug, &sdev->sd,\n\t\t\t\"%s: property=0x%02x value=0x%02x status=0x%02x\\n\",\n\t\t\t__func__, prop, val, resp[0]);\n\n\t \n\tmsleep(TIMEOUT_SET_PROPERTY);\n\n\treturn rval;\n}\n\n \nstatic int si4713_powerup(struct si4713_device *sdev)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sdev->sd);\n\tint err;\n\tu8 resp[SI4713_PWUP_NRESP];\n\t \n\tu8 args[SI4713_PWUP_NARGS] = {\n\t\tSI4713_PWUP_GPO2OEN | SI4713_PWUP_FUNC_TX,\n\t\tSI4713_PWUP_OPMOD_ANALOG,\n\t};\n\n\tif (sdev->power_state)\n\t\treturn 0;\n\n\tif (sdev->vdd) {\n\t\terr = regulator_enable(sdev->vdd);\n\t\tif (err) {\n\t\t\tv4l2_err(&sdev->sd, \"Failed to enable vdd: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (sdev->vio) {\n\t\terr = regulator_enable(sdev->vio);\n\t\tif (err) {\n\t\t\tv4l2_err(&sdev->sd, \"Failed to enable vio: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (sdev->gpio_reset) {\n\t\tudelay(50);\n\t\tgpiod_set_value(sdev->gpio_reset, 1);\n\t}\n\n\tif (client->irq)\n\t\targs[0] |= SI4713_PWUP_CTSIEN;\n\n\terr = si4713_send_command(sdev, SI4713_CMD_POWER_UP,\n\t\t\t\t\targs, ARRAY_SIZE(args),\n\t\t\t\t\tresp, ARRAY_SIZE(resp),\n\t\t\t\t\tTIMEOUT_POWER_UP);\n\n\tif (!err) {\n\t\tv4l2_dbg(1, debug, &sdev->sd, \"Powerup response: 0x%02x\\n\",\n\t\t\t\tresp[0]);\n\t\tv4l2_dbg(1, debug, &sdev->sd, \"Device in power up mode\\n\");\n\t\tsdev->power_state = POWER_ON;\n\n\t\tif (client->irq)\n\t\t\terr = si4713_write_property(sdev, SI4713_GPO_IEN,\n\t\t\t\t\t\tSI4713_STC_INT | SI4713_CTS);\n\t\treturn err;\n\t}\n\tgpiod_set_value(sdev->gpio_reset, 0);\n\n\n\tif (sdev->vdd) {\n\t\terr = regulator_disable(sdev->vdd);\n\t\tif (err)\n\t\t\tv4l2_err(&sdev->sd, \"Failed to disable vdd: %d\\n\", err);\n\t}\n\n\tif (sdev->vio) {\n\t\terr = regulator_disable(sdev->vio);\n\t\tif (err)\n\t\t\tv4l2_err(&sdev->sd, \"Failed to disable vio: %d\\n\", err);\n\t}\n\n\treturn err;\n}\n\n \nstatic int si4713_powerdown(struct si4713_device *sdev)\n{\n\tint err;\n\tu8 resp[SI4713_PWDN_NRESP];\n\n\tif (!sdev->power_state)\n\t\treturn 0;\n\n\terr = si4713_send_command(sdev, SI4713_CMD_POWER_DOWN,\n\t\t\t\t\tNULL, 0,\n\t\t\t\t\tresp, ARRAY_SIZE(resp),\n\t\t\t\t\tDEFAULT_TIMEOUT);\n\n\tif (!err) {\n\t\tv4l2_dbg(1, debug, &sdev->sd, \"Power down response: 0x%02x\\n\",\n\t\t\t\tresp[0]);\n\t\tv4l2_dbg(1, debug, &sdev->sd, \"Device in reset mode\\n\");\n\t\tif (sdev->gpio_reset)\n\t\t\tgpiod_set_value(sdev->gpio_reset, 0);\n\n\t\tif (sdev->vdd) {\n\t\t\terr = regulator_disable(sdev->vdd);\n\t\t\tif (err) {\n\t\t\t\tv4l2_err(&sdev->sd,\n\t\t\t\t\t\"Failed to disable vdd: %d\\n\", err);\n\t\t\t}\n\t\t}\n\n\t\tif (sdev->vio) {\n\t\t\terr = regulator_disable(sdev->vio);\n\t\t\tif (err) {\n\t\t\t\tv4l2_err(&sdev->sd,\n\t\t\t\t\t\"Failed to disable vio: %d\\n\", err);\n\t\t\t}\n\t\t}\n\t\tsdev->power_state = POWER_OFF;\n\t}\n\n\treturn err;\n}\n\n \nstatic int si4713_checkrev(struct si4713_device *sdev)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sdev->sd);\n\tint rval;\n\tu8 resp[SI4713_GETREV_NRESP];\n\n\trval = si4713_send_command(sdev, SI4713_CMD_GET_REV,\n\t\t\t\t\tNULL, 0,\n\t\t\t\t\tresp, ARRAY_SIZE(resp),\n\t\t\t\t\tDEFAULT_TIMEOUT);\n\n\tif (rval < 0)\n\t\treturn rval;\n\n\tif (resp[1] == SI4713_PRODUCT_NUMBER) {\n\t\tv4l2_info(&sdev->sd, \"chip found @ 0x%02x (%s)\\n\",\n\t\t\t\tclient->addr << 1, client->adapter->name);\n\t} else {\n\t\tv4l2_err(&sdev->sd, \"Invalid product number 0x%X\\n\", resp[1]);\n\t\trval = -EINVAL;\n\t}\n\treturn rval;\n}\n\n \nstatic int si4713_wait_stc(struct si4713_device *sdev, const int usecs)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sdev->sd);\n\tu8 resp[SI4713_GET_STATUS_NRESP];\n\tunsigned long start_jiffies = jiffies;\n\tint err;\n\n\tif (client->irq &&\n\t    !wait_for_completion_timeout(&sdev->work, usecs_to_jiffies(usecs) + 1))\n\t\tv4l2_warn(&sdev->sd,\n\t\t\t\"(%s) Device took too much time to answer.\\n\", __func__);\n\n\tfor (;;) {\n\t\t \n\t\terr = si4713_send_command(sdev, SI4713_CMD_GET_INT_STATUS,\n\t\t\t\tNULL, 0,\n\t\t\t\tresp, ARRAY_SIZE(resp),\n\t\t\t\tDEFAULT_TIMEOUT);\n\t\t \n\t\tif (err >= 0) {\n\t\t\tv4l2_dbg(1, debug, &sdev->sd,\n\t\t\t\t\"%s: status bits: 0x%02x\\n\", __func__, resp[0]);\n\n\t\t\tif (resp[0] & SI4713_STC_INT)\n\t\t\t\treturn 0;\n\t\t}\n\t\tif (jiffies_to_usecs(jiffies - start_jiffies) > usecs)\n\t\t\treturn err < 0 ? err : -EIO;\n\t\t \n\t\tusleep_range(3000, 4000);\n\t}\n}\n\n \nstatic int si4713_tx_tune_freq(struct si4713_device *sdev, u16 frequency)\n{\n\tint err;\n\tu8 val[SI4713_TXFREQ_NRESP];\n\t \n\tconst u8 args[SI4713_TXFREQ_NARGS] = {\n\t\t0x00,\n\t\tmsb(frequency),\n\t\tlsb(frequency),\n\t};\n\n\terr = si4713_send_command(sdev, SI4713_CMD_TX_TUNE_FREQ,\n\t\t\t\t  args, ARRAY_SIZE(args), val,\n\t\t\t\t  ARRAY_SIZE(val), DEFAULT_TIMEOUT);\n\n\tif (err < 0)\n\t\treturn err;\n\n\tv4l2_dbg(1, debug, &sdev->sd,\n\t\t\t\"%s: frequency=0x%02x status=0x%02x\\n\", __func__,\n\t\t\tfrequency, val[0]);\n\n\terr = si4713_wait_stc(sdev, TIMEOUT_TX_TUNE);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn compose_u16(args[1], args[2]);\n}\n\n \nstatic int si4713_tx_tune_power(struct si4713_device *sdev, u8 power,\n\t\t\t\tu8 antcap)\n{\n\tint err;\n\tu8 val[SI4713_TXPWR_NRESP];\n\t \n\tu8 args[SI4713_TXPWR_NARGS] = {\n\t\t0x00,\n\t\t0x00,\n\t\tpower,\n\t\tantcap,\n\t};\n\n\t \n\tif (power > 0 && power < SI4713_MIN_POWER)\n\t\targs[2] = power = SI4713_MIN_POWER;\n\n\terr = si4713_send_command(sdev, SI4713_CMD_TX_TUNE_POWER,\n\t\t\t\t  args, ARRAY_SIZE(args), val,\n\t\t\t\t  ARRAY_SIZE(val), DEFAULT_TIMEOUT);\n\n\tif (err < 0)\n\t\treturn err;\n\n\tv4l2_dbg(1, debug, &sdev->sd,\n\t\t\t\"%s: power=0x%02x antcap=0x%02x status=0x%02x\\n\",\n\t\t\t__func__, power, antcap, val[0]);\n\n\treturn si4713_wait_stc(sdev, TIMEOUT_TX_TUNE_POWER);\n}\n\n \nstatic int si4713_tx_tune_measure(struct si4713_device *sdev, u16 frequency,\n\t\t\t\t\tu8 antcap)\n{\n\tint err;\n\tu8 val[SI4713_TXMEA_NRESP];\n\t \n\tconst u8 args[SI4713_TXMEA_NARGS] = {\n\t\t0x00,\n\t\tmsb(frequency),\n\t\tlsb(frequency),\n\t\tantcap,\n\t};\n\n\tsdev->tune_rnl = DEFAULT_TUNE_RNL;\n\n\tif (antcap > SI4713_MAX_ANTCAP)\n\t\treturn -EDOM;\n\n\terr = si4713_send_command(sdev, SI4713_CMD_TX_TUNE_MEASURE,\n\t\t\t\t  args, ARRAY_SIZE(args), val,\n\t\t\t\t  ARRAY_SIZE(val), DEFAULT_TIMEOUT);\n\n\tif (err < 0)\n\t\treturn err;\n\n\tv4l2_dbg(1, debug, &sdev->sd,\n\t\t\t\"%s: frequency=0x%02x antcap=0x%02x status=0x%02x\\n\",\n\t\t\t__func__, frequency, antcap, val[0]);\n\n\treturn si4713_wait_stc(sdev, TIMEOUT_TX_TUNE);\n}\n\n \nstatic int si4713_tx_tune_status(struct si4713_device *sdev, u8 intack,\n\t\t\t\t\tu16 *frequency,\tu8 *power,\n\t\t\t\t\tu8 *antcap, u8 *noise)\n{\n\tint err;\n\tu8 val[SI4713_TXSTATUS_NRESP];\n\t \n\tconst u8 args[SI4713_TXSTATUS_NARGS] = {\n\t\tintack & SI4713_INTACK_MASK,\n\t};\n\n\terr = si4713_send_command(sdev, SI4713_CMD_TX_TUNE_STATUS,\n\t\t\t\t  args, ARRAY_SIZE(args), val,\n\t\t\t\t  ARRAY_SIZE(val), DEFAULT_TIMEOUT);\n\n\tif (!err) {\n\t\tv4l2_dbg(1, debug, &sdev->sd,\n\t\t\t\"%s: status=0x%02x\\n\", __func__, val[0]);\n\t\t*frequency = compose_u16(val[2], val[3]);\n\t\tsdev->frequency = *frequency;\n\t\t*power = val[5];\n\t\t*antcap = val[6];\n\t\t*noise = val[7];\n\t\tv4l2_dbg(1, debug, &sdev->sd,\n\t\t\t \"%s: response: %d x 10 kHz (power %d, antcap %d, rnl %d)\\n\",\n\t\t\t __func__, *frequency, *power, *antcap, *noise);\n\t}\n\n\treturn err;\n}\n\n \nstatic int si4713_tx_rds_buff(struct si4713_device *sdev, u8 mode, u16 rdsb,\n\t\t\t\tu16 rdsc, u16 rdsd, s8 *cbleft)\n{\n\tint err;\n\tu8 val[SI4713_RDSBUFF_NRESP];\n\n\tconst u8 args[SI4713_RDSBUFF_NARGS] = {\n\t\tmode & SI4713_RDSBUFF_MODE_MASK,\n\t\tmsb(rdsb),\n\t\tlsb(rdsb),\n\t\tmsb(rdsc),\n\t\tlsb(rdsc),\n\t\tmsb(rdsd),\n\t\tlsb(rdsd),\n\t};\n\n\terr = si4713_send_command(sdev, SI4713_CMD_TX_RDS_BUFF,\n\t\t\t\t  args, ARRAY_SIZE(args), val,\n\t\t\t\t  ARRAY_SIZE(val), DEFAULT_TIMEOUT);\n\n\tif (!err) {\n\t\tv4l2_dbg(1, debug, &sdev->sd,\n\t\t\t\"%s: status=0x%02x\\n\", __func__, val[0]);\n\t\t*cbleft = (s8)val[2] - val[3];\n\t\tv4l2_dbg(1, debug, &sdev->sd,\n\t\t\t \"%s: response: interrupts 0x%02x cb avail: %d cb used %d fifo avail %d fifo used %d\\n\",\n\t\t\t __func__, val[1], val[2], val[3], val[4], val[5]);\n\t}\n\n\treturn err;\n}\n\n \nstatic int si4713_tx_rds_ps(struct si4713_device *sdev, u8 psid,\n\t\t\t\tunsigned char *pschar)\n{\n\tint err;\n\tu8 val[SI4713_RDSPS_NRESP];\n\n\tconst u8 args[SI4713_RDSPS_NARGS] = {\n\t\tpsid & SI4713_RDSPS_PSID_MASK,\n\t\tpschar[0],\n\t\tpschar[1],\n\t\tpschar[2],\n\t\tpschar[3],\n\t};\n\n\terr = si4713_send_command(sdev, SI4713_CMD_TX_RDS_PS,\n\t\t\t\t  args, ARRAY_SIZE(args), val,\n\t\t\t\t  ARRAY_SIZE(val), DEFAULT_TIMEOUT);\n\n\tif (err < 0)\n\t\treturn err;\n\n\tv4l2_dbg(1, debug, &sdev->sd, \"%s: status=0x%02x\\n\", __func__, val[0]);\n\n\treturn err;\n}\n\nstatic int si4713_set_power_state(struct si4713_device *sdev, u8 value)\n{\n\tif (value)\n\t\treturn si4713_powerup(sdev);\n\treturn si4713_powerdown(sdev);\n}\n\nstatic int si4713_set_mute(struct si4713_device *sdev, u16 mute)\n{\n\tint rval = 0;\n\n\tmute = set_mute(mute);\n\n\tif (sdev->power_state)\n\t\trval = si4713_write_property(sdev,\n\t\t\t\tSI4713_TX_LINE_INPUT_MUTE, mute);\n\n\treturn rval;\n}\n\nstatic int si4713_set_rds_ps_name(struct si4713_device *sdev, char *ps_name)\n{\n\tint rval = 0, i;\n\tu8 len = 0;\n\n\t \n\tif (!strlen(ps_name))\n\t\tmemset(ps_name, 0, MAX_RDS_PS_NAME + 1);\n\n\tif (sdev->power_state) {\n\t\t \n\t\tfor (i = 0; i < MAX_RDS_PS_NAME; i += (RDS_BLOCK / 2)) {\n\t\t\trval = si4713_tx_rds_ps(sdev, (i / (RDS_BLOCK / 2)),\n\t\t\t\t\t\tps_name + i);\n\t\t\tif (rval < 0)\n\t\t\t\treturn rval;\n\t\t}\n\n\t\t \n\t\tif (strlen(ps_name))\n\t\t\tlen = strlen(ps_name) - 1;\n\t\telse\n\t\t\tlen = 1;\n\n\t\trval = si4713_write_property(sdev,\n\t\t\t\tSI4713_TX_RDS_PS_MESSAGE_COUNT,\n\t\t\t\trds_ps_nblocks(len));\n\t\tif (rval < 0)\n\t\t\treturn rval;\n\n\t\trval = si4713_write_property(sdev,\n\t\t\t\tSI4713_TX_RDS_PS_REPEAT_COUNT,\n\t\t\t\tDEFAULT_RDS_PS_REPEAT_COUNT * 2);\n\t\tif (rval < 0)\n\t\t\treturn rval;\n\t}\n\n\treturn rval;\n}\n\nstatic int si4713_set_rds_radio_text(struct si4713_device *sdev, const char *rt)\n{\n\tstatic const char cr[RDS_RADIOTEXT_BLK_SIZE] = { RDS_CARRIAGE_RETURN, 0 };\n\tint rval = 0, i;\n\tu16 t_index = 0;\n\tu8 b_index = 0, cr_inserted = 0;\n\ts8 left;\n\n\tif (!sdev->power_state)\n\t\treturn rval;\n\n\trval = si4713_tx_rds_buff(sdev, RDS_BLOCK_CLEAR, 0, 0, 0, &left);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tif (!strlen(rt))\n\t\treturn rval;\n\n\tdo {\n\t\t \n\t\tif (t_index < (RDS_RADIOTEXT_INDEX_MAX * RDS_RADIOTEXT_BLK_SIZE)) {\n\t\t\tfor (i = 0; i < RDS_RADIOTEXT_BLK_SIZE; i++) {\n\t\t\t\tif (!rt[t_index + i] ||\n\t\t\t\t    rt[t_index + i] == RDS_CARRIAGE_RETURN) {\n\t\t\t\t\trt = cr;\n\t\t\t\t\tcr_inserted = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trval = si4713_tx_rds_buff(sdev, RDS_BLOCK_LOAD,\n\t\t\t\tcompose_u16(RDS_RADIOTEXT_2A, b_index++),\n\t\t\t\tcompose_u16(rt[t_index], rt[t_index + 1]),\n\t\t\t\tcompose_u16(rt[t_index + 2], rt[t_index + 3]),\n\t\t\t\t&left);\n\t\tif (rval < 0)\n\t\t\treturn rval;\n\n\t\tt_index += RDS_RADIOTEXT_BLK_SIZE;\n\n\t\tif (cr_inserted)\n\t\t\tbreak;\n\t} while (left > 0);\n\n\treturn rval;\n}\n\n \nstatic int si4713_update_tune_status(struct si4713_device *sdev)\n{\n\tint rval;\n\tu16 f = 0;\n\tu8 p = 0, a = 0, n = 0;\n\n\trval = si4713_tx_tune_status(sdev, 0x00, &f, &p, &a, &n);\n\n\tif (rval < 0)\n\t\tgoto exit;\n\n \n\tsdev->tune_rnl = n;\n\nexit:\n\treturn rval;\n}\n\nstatic int si4713_choose_econtrol_action(struct si4713_device *sdev, u32 id,\n\t\ts32 *bit, s32 *mask, u16 *property, int *mul,\n\t\tunsigned long **table, int *size)\n{\n\ts32 rval = 0;\n\n\tswitch (id) {\n\t \n\tcase V4L2_CID_RDS_TX_PI:\n\t\t*property = SI4713_TX_RDS_PI;\n\t\t*mul = 1;\n\t\tbreak;\n\tcase V4L2_CID_AUDIO_COMPRESSION_THRESHOLD:\n\t\t*property = SI4713_TX_ACOMP_THRESHOLD;\n\t\t*mul = 1;\n\t\tbreak;\n\tcase V4L2_CID_AUDIO_COMPRESSION_GAIN:\n\t\t*property = SI4713_TX_ACOMP_GAIN;\n\t\t*mul = 1;\n\t\tbreak;\n\tcase V4L2_CID_PILOT_TONE_FREQUENCY:\n\t\t*property = SI4713_TX_PILOT_FREQUENCY;\n\t\t*mul = 1;\n\t\tbreak;\n\tcase V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME:\n\t\t*property = SI4713_TX_ACOMP_ATTACK_TIME;\n\t\t*mul = ATTACK_TIME_UNIT;\n\t\tbreak;\n\tcase V4L2_CID_PILOT_TONE_DEVIATION:\n\t\t*property = SI4713_TX_PILOT_DEVIATION;\n\t\t*mul = 10;\n\t\tbreak;\n\tcase V4L2_CID_AUDIO_LIMITER_DEVIATION:\n\t\t*property = SI4713_TX_AUDIO_DEVIATION;\n\t\t*mul = 10;\n\t\tbreak;\n\tcase V4L2_CID_RDS_TX_DEVIATION:\n\t\t*property = SI4713_TX_RDS_DEVIATION;\n\t\t*mul = 1;\n\t\tbreak;\n\n\tcase V4L2_CID_RDS_TX_PTY:\n\t\t*property = SI4713_TX_RDS_PS_MISC;\n\t\t*bit = 5;\n\t\t*mask = 0x1F << 5;\n\t\tbreak;\n\tcase V4L2_CID_RDS_TX_DYNAMIC_PTY:\n\t\t*property = SI4713_TX_RDS_PS_MISC;\n\t\t*bit = 15;\n\t\t*mask = 1 << 15;\n\t\tbreak;\n\tcase V4L2_CID_RDS_TX_COMPRESSED:\n\t\t*property = SI4713_TX_RDS_PS_MISC;\n\t\t*bit = 14;\n\t\t*mask = 1 << 14;\n\t\tbreak;\n\tcase V4L2_CID_RDS_TX_ARTIFICIAL_HEAD:\n\t\t*property = SI4713_TX_RDS_PS_MISC;\n\t\t*bit = 13;\n\t\t*mask = 1 << 13;\n\t\tbreak;\n\tcase V4L2_CID_RDS_TX_MONO_STEREO:\n\t\t*property = SI4713_TX_RDS_PS_MISC;\n\t\t*bit = 12;\n\t\t*mask = 1 << 12;\n\t\tbreak;\n\tcase V4L2_CID_RDS_TX_TRAFFIC_PROGRAM:\n\t\t*property = SI4713_TX_RDS_PS_MISC;\n\t\t*bit = 10;\n\t\t*mask = 1 << 10;\n\t\tbreak;\n\tcase V4L2_CID_RDS_TX_TRAFFIC_ANNOUNCEMENT:\n\t\t*property = SI4713_TX_RDS_PS_MISC;\n\t\t*bit = 4;\n\t\t*mask = 1 << 4;\n\t\tbreak;\n\tcase V4L2_CID_RDS_TX_MUSIC_SPEECH:\n\t\t*property = SI4713_TX_RDS_PS_MISC;\n\t\t*bit = 3;\n\t\t*mask = 1 << 3;\n\t\tbreak;\n\tcase V4L2_CID_AUDIO_LIMITER_ENABLED:\n\t\t*property = SI4713_TX_ACOMP_ENABLE;\n\t\t*bit = 1;\n\t\t*mask = 1 << 1;\n\t\tbreak;\n\tcase V4L2_CID_AUDIO_COMPRESSION_ENABLED:\n\t\t*property = SI4713_TX_ACOMP_ENABLE;\n\t\t*bit = 0;\n\t\t*mask = 1 << 0;\n\t\tbreak;\n\tcase V4L2_CID_PILOT_TONE_ENABLED:\n\t\t*property = SI4713_TX_COMPONENT_ENABLE;\n\t\t*bit = 0;\n\t\t*mask = 1 << 0;\n\t\tbreak;\n\n\tcase V4L2_CID_AUDIO_LIMITER_RELEASE_TIME:\n\t\t*property = SI4713_TX_LIMITER_RELEASE_TIME;\n\t\t*table = limiter_times;\n\t\t*size = ARRAY_SIZE(limiter_times);\n\t\tbreak;\n\tcase V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME:\n\t\t*property = SI4713_TX_ACOMP_RELEASE_TIME;\n\t\t*table = acomp_rtimes;\n\t\t*size = ARRAY_SIZE(acomp_rtimes);\n\t\tbreak;\n\tcase V4L2_CID_TUNE_PREEMPHASIS:\n\t\t*property = SI4713_TX_PREEMPHASIS;\n\t\t*table = preemphasis_values;\n\t\t*size = ARRAY_SIZE(preemphasis_values);\n\t\tbreak;\n\n\tdefault:\n\t\trval = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn rval;\n}\n\nstatic int si4713_s_frequency(struct v4l2_subdev *sd, const struct v4l2_frequency *f);\nstatic int si4713_s_modulator(struct v4l2_subdev *sd, const struct v4l2_modulator *);\n \nstatic int si4713_setup(struct si4713_device *sdev)\n{\n\tstruct v4l2_frequency f;\n\tstruct v4l2_modulator vm;\n\tint rval;\n\n\t \n\tf.tuner = 0;\n\tf.frequency = sdev->frequency ? sdev->frequency : DEFAULT_FREQUENCY;\n\tf.frequency = si4713_to_v4l2(f.frequency);\n\trval = si4713_s_frequency(&sdev->sd, &f);\n\n\tvm.index = 0;\n\tif (sdev->stereo)\n\t\tvm.txsubchans = V4L2_TUNER_SUB_STEREO;\n\telse\n\t\tvm.txsubchans = V4L2_TUNER_SUB_MONO;\n\tif (sdev->rds_enabled)\n\t\tvm.txsubchans |= V4L2_TUNER_SUB_RDS;\n\tsi4713_s_modulator(&sdev->sd, &vm);\n\n\treturn rval;\n}\n\n \nstatic int si4713_initialize(struct si4713_device *sdev)\n{\n\tint rval;\n\n\trval = si4713_set_power_state(sdev, POWER_ON);\n\tif (rval < 0)\n\t\treturn rval;\n\n\trval = si4713_checkrev(sdev);\n\tif (rval < 0)\n\t\treturn rval;\n\n\trval = si4713_set_power_state(sdev, POWER_OFF);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tsdev->frequency = DEFAULT_FREQUENCY;\n\tsdev->stereo = 1;\n\tsdev->tune_rnl = DEFAULT_TUNE_RNL;\n\treturn 0;\n}\n\n \nstatic int si4713_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct si4713_device *sdev =\n\t\tcontainer_of(ctrl->handler, struct si4713_device, ctrl_handler);\n\tu32 val = 0;\n\ts32 bit = 0, mask = 0;\n\tu16 property = 0;\n\tint mul = 0;\n\tunsigned long *table = NULL;\n\tint size = 0;\n\tbool force = false;\n\tint c;\n\tint ret = 0;\n\n\tif (ctrl->id != V4L2_CID_AUDIO_MUTE)\n\t\treturn -EINVAL;\n\tif (ctrl->is_new) {\n\t\tif (ctrl->val) {\n\t\t\tret = si4713_set_mute(sdev, ctrl->val);\n\t\t\tif (!ret)\n\t\t\t\tret = si4713_set_power_state(sdev, POWER_DOWN);\n\t\t\treturn ret;\n\t\t}\n\t\tret = si4713_set_power_state(sdev, POWER_UP);\n\t\tif (!ret)\n\t\t\tret = si4713_set_mute(sdev, ctrl->val);\n\t\tif (!ret)\n\t\t\tret = si4713_setup(sdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tforce = true;\n\t}\n\n\tif (!sdev->power_state)\n\t\treturn 0;\n\n\tfor (c = 1; !ret && c < ctrl->ncontrols; c++) {\n\t\tctrl = ctrl->cluster[c];\n\n\t\tif (!force && !ctrl->is_new)\n\t\t\tcontinue;\n\n\t\tswitch (ctrl->id) {\n\t\tcase V4L2_CID_RDS_TX_PS_NAME:\n\t\t\tret = si4713_set_rds_ps_name(sdev, ctrl->p_new.p_char);\n\t\t\tbreak;\n\n\t\tcase V4L2_CID_RDS_TX_RADIO_TEXT:\n\t\t\tret = si4713_set_rds_radio_text(sdev, ctrl->p_new.p_char);\n\t\t\tbreak;\n\n\t\tcase V4L2_CID_TUNE_ANTENNA_CAPACITOR:\n\t\t\t \n\t\t\tif (force)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase V4L2_CID_TUNE_POWER_LEVEL:\n\t\t\tret = si4713_tx_tune_power(sdev,\n\t\t\t\tsdev->tune_pwr_level->val, sdev->tune_ant_cap->val);\n\t\t\tif (!ret) {\n\t\t\t\t \n\t\t\t\tsdev->tune_ant_cap->is_new = false;\n\t\t\t\tsdev->tune_pwr_level->is_new = false;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase V4L2_CID_RDS_TX_ALT_FREQS_ENABLE:\n\t\tcase V4L2_CID_RDS_TX_ALT_FREQS:\n\t\t\tif (sdev->rds_alt_freqs_enable->val) {\n\t\t\t\tval = sdev->rds_alt_freqs->p_new.p_u32[0];\n\t\t\t\tval = val / 100 - 876 + 0xe101;\n\t\t\t} else {\n\t\t\t\tval = 0xe0e0;\n\t\t\t}\n\t\t\tret = si4713_write_property(sdev, SI4713_TX_RDS_PS_AF, val);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret = si4713_choose_econtrol_action(sdev, ctrl->id, &bit,\n\t\t\t\t\t&mask, &property, &mul, &table, &size);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tval = ctrl->val;\n\t\t\tif (mul) {\n\t\t\t\tval = val / mul;\n\t\t\t} else if (table) {\n\t\t\t\tret = usecs_to_dev(val, table, size);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tval = ret;\n\t\t\t\tret = 0;\n\t\t\t}\n\n\t\t\tif (mask) {\n\t\t\t\tret = si4713_read_property(sdev, property, &val);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tval = set_bits(val, ctrl->val, bit, mask);\n\t\t\t}\n\n\t\t\tret = si4713_write_property(sdev, property, val);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tif (mask)\n\t\t\t\tval = ctrl->val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic long si4713_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\n{\n\tstruct si4713_device *sdev = to_si4713_device(sd);\n\tstruct si4713_rnl *rnl = arg;\n\tu16 frequency;\n\tint rval = 0;\n\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase SI4713_IOC_MEASURE_RNL:\n\t\tfrequency = v4l2_to_si4713(rnl->frequency);\n\n\t\tif (sdev->power_state) {\n\t\t\t \n\t\t\trval = si4713_tx_tune_measure(sdev, frequency, 0);\n\t\t\tif (rval < 0)\n\t\t\t\treturn rval;\n\t\t\t \n\t\t\trval = si4713_update_tune_status(sdev);\n\t\t\tif (rval < 0)\n\t\t\t\treturn rval;\n\t\t}\n\t\trnl->rnl = sdev->tune_rnl;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\trval = -ENOIOCTLCMD;\n\t}\n\n\treturn rval;\n}\n\n \nstatic int si4713_g_modulator(struct v4l2_subdev *sd, struct v4l2_modulator *vm)\n{\n\tstruct si4713_device *sdev = to_si4713_device(sd);\n\tint rval = 0;\n\n\tif (!sdev)\n\t\treturn -ENODEV;\n\n\tif (vm->index > 0)\n\t\treturn -EINVAL;\n\n\tstrscpy(vm->name, \"FM Modulator\", sizeof(vm->name));\n\tvm->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_LOW |\n\t\tV4L2_TUNER_CAP_RDS | V4L2_TUNER_CAP_RDS_CONTROLS;\n\n\t \n\tvm->rangelow = si4713_to_v4l2(FREQ_RANGE_LOW);\n\tvm->rangehigh = si4713_to_v4l2(FREQ_RANGE_HIGH);\n\n\tif (sdev->power_state) {\n\t\tu32 comp_en = 0;\n\n\t\trval = si4713_read_property(sdev, SI4713_TX_COMPONENT_ENABLE,\n\t\t\t\t\t\t&comp_en);\n\t\tif (rval < 0)\n\t\t\treturn rval;\n\n\t\tsdev->stereo = get_status_bit(comp_en, 1, 1 << 1);\n\t}\n\n\t \n\tif (sdev->stereo)\n\t\tvm->txsubchans = V4L2_TUNER_SUB_STEREO;\n\telse\n\t\tvm->txsubchans = V4L2_TUNER_SUB_MONO;\n\n\t \n\tif (sdev->rds_enabled)\n\t\tvm->txsubchans |= V4L2_TUNER_SUB_RDS;\n\telse\n\t\tvm->txsubchans &= ~V4L2_TUNER_SUB_RDS;\n\n\treturn rval;\n}\n\n \nstatic int si4713_s_modulator(struct v4l2_subdev *sd, const struct v4l2_modulator *vm)\n{\n\tstruct si4713_device *sdev = to_si4713_device(sd);\n\tint rval = 0;\n\tu16 stereo, rds;\n\tu32 p;\n\n\tif (!sdev)\n\t\treturn -ENODEV;\n\n\tif (vm->index > 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (vm->txsubchans & V4L2_TUNER_SUB_STEREO)\n\t\tstereo = 1;\n\telse if (vm->txsubchans & V4L2_TUNER_SUB_MONO)\n\t\tstereo = 0;\n\telse\n\t\treturn -EINVAL;\n\n\trds = !!(vm->txsubchans & V4L2_TUNER_SUB_RDS);\n\n\tif (sdev->power_state) {\n\t\trval = si4713_read_property(sdev,\n\t\t\t\t\t\tSI4713_TX_COMPONENT_ENABLE, &p);\n\t\tif (rval < 0)\n\t\t\treturn rval;\n\n\t\tp = set_bits(p, stereo, 1, 1 << 1);\n\t\tp = set_bits(p, rds, 2, 1 << 2);\n\n\t\trval = si4713_write_property(sdev,\n\t\t\t\t\t\tSI4713_TX_COMPONENT_ENABLE, p);\n\t\tif (rval < 0)\n\t\t\treturn rval;\n\t}\n\n\tsdev->stereo = stereo;\n\tsdev->rds_enabled = rds;\n\n\treturn rval;\n}\n\n \nstatic int si4713_g_frequency(struct v4l2_subdev *sd, struct v4l2_frequency *f)\n{\n\tstruct si4713_device *sdev = to_si4713_device(sd);\n\tint rval = 0;\n\n\tif (f->tuner)\n\t\treturn -EINVAL;\n\n\tif (sdev->power_state) {\n\t\tu16 freq;\n\t\tu8 p, a, n;\n\n\t\trval = si4713_tx_tune_status(sdev, 0x00, &freq, &p, &a, &n);\n\t\tif (rval < 0)\n\t\t\treturn rval;\n\n\t\tsdev->frequency = freq;\n\t}\n\n\tf->frequency = si4713_to_v4l2(sdev->frequency);\n\n\treturn rval;\n}\n\n \nstatic int si4713_s_frequency(struct v4l2_subdev *sd, const struct v4l2_frequency *f)\n{\n\tstruct si4713_device *sdev = to_si4713_device(sd);\n\tint rval = 0;\n\tu16 frequency = v4l2_to_si4713(f->frequency);\n\n\tif (f->tuner)\n\t\treturn -EINVAL;\n\n\t \n\tfrequency = clamp_t(u16, frequency, FREQ_RANGE_LOW, FREQ_RANGE_HIGH);\n\n\tif (sdev->power_state) {\n\t\trval = si4713_tx_tune_freq(sdev, frequency);\n\t\tif (rval < 0)\n\t\t\treturn rval;\n\t\tfrequency = rval;\n\t\trval = 0;\n\t}\n\tsdev->frequency = frequency;\n\n\treturn rval;\n}\n\nstatic const struct v4l2_ctrl_ops si4713_ctrl_ops = {\n\t.s_ctrl = si4713_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops si4713_subdev_core_ops = {\n\t.ioctl\t\t= si4713_ioctl,\n};\n\nstatic const struct v4l2_subdev_tuner_ops si4713_subdev_tuner_ops = {\n\t.g_frequency\t= si4713_g_frequency,\n\t.s_frequency\t= si4713_s_frequency,\n\t.g_modulator\t= si4713_g_modulator,\n\t.s_modulator\t= si4713_s_modulator,\n};\n\nstatic const struct v4l2_subdev_ops si4713_subdev_ops = {\n\t.core\t\t= &si4713_subdev_core_ops,\n\t.tuner\t\t= &si4713_subdev_tuner_ops,\n};\n\nstatic const struct v4l2_ctrl_config si4713_alt_freqs_ctrl = {\n\t.id = V4L2_CID_RDS_TX_ALT_FREQS,\n\t.type = V4L2_CTRL_TYPE_U32,\n\t.min = 87600,\n\t.max = 107900,\n\t.step = 100,\n\t.def = 87600,\n\t.dims = { 1 },\n\t.elem_size = sizeof(u32),\n};\n\n \n \nstatic int si4713_probe(struct i2c_client *client)\n{\n\tstruct si4713_device *sdev;\n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct si4713_platform_data *pdata = client->dev.platform_data;\n\tstruct device_node *np = client->dev.of_node;\n\tstruct radio_si4713_platform_data si4713_pdev_pdata;\n\tstruct platform_device *si4713_pdev;\n\tint rval;\n\n\tsdev = devm_kzalloc(&client->dev, sizeof(*sdev), GFP_KERNEL);\n\tif (!sdev) {\n\t\tdev_err(&client->dev, \"Failed to alloc video device.\\n\");\n\t\trval = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tsdev->gpio_reset = devm_gpiod_get_optional(&client->dev, \"reset\",\n\t\t\t\t\t\t   GPIOD_OUT_LOW);\n\tif (IS_ERR(sdev->gpio_reset)) {\n\t\trval = PTR_ERR(sdev->gpio_reset);\n\t\tdev_err(&client->dev, \"Failed to request gpio: %d\\n\", rval);\n\t\tgoto exit;\n\t}\n\n\tsdev->vdd = devm_regulator_get_optional(&client->dev, \"vdd\");\n\tif (IS_ERR(sdev->vdd)) {\n\t\trval = PTR_ERR(sdev->vdd);\n\t\tif (rval == -EPROBE_DEFER)\n\t\t\tgoto exit;\n\n\t\tdev_dbg(&client->dev, \"no vdd regulator found: %d\\n\", rval);\n\t\tsdev->vdd = NULL;\n\t}\n\n\tsdev->vio = devm_regulator_get_optional(&client->dev, \"vio\");\n\tif (IS_ERR(sdev->vio)) {\n\t\trval = PTR_ERR(sdev->vio);\n\t\tif (rval == -EPROBE_DEFER)\n\t\t\tgoto exit;\n\n\t\tdev_dbg(&client->dev, \"no vio regulator found: %d\\n\", rval);\n\t\tsdev->vio = NULL;\n\t}\n\n\tv4l2_i2c_subdev_init(&sdev->sd, client, &si4713_subdev_ops);\n\n\tinit_completion(&sdev->work);\n\n\thdl = &sdev->ctrl_handler;\n\tv4l2_ctrl_handler_init(hdl, 20);\n\tsdev->mute = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_MUTE, 0, 1, 1, DEFAULT_MUTE);\n\n\tsdev->rds_pi = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_PI, 0, 0xffff, 1, DEFAULT_RDS_PI);\n\tsdev->rds_pty = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_PTY, 0, 31, 1, DEFAULT_RDS_PTY);\n\tsdev->rds_compressed = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_COMPRESSED, 0, 1, 1, 0);\n\tsdev->rds_art_head = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_ARTIFICIAL_HEAD, 0, 1, 1, 0);\n\tsdev->rds_stereo = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_MONO_STEREO, 0, 1, 1, 1);\n\tsdev->rds_tp = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_TRAFFIC_PROGRAM, 0, 1, 1, 0);\n\tsdev->rds_ta = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_TRAFFIC_ANNOUNCEMENT, 0, 1, 1, 0);\n\tsdev->rds_ms = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_MUSIC_SPEECH, 0, 1, 1, 1);\n\tsdev->rds_dyn_pty = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_DYNAMIC_PTY, 0, 1, 1, 0);\n\tsdev->rds_alt_freqs_enable = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_ALT_FREQS_ENABLE, 0, 1, 1, 0);\n\tsdev->rds_alt_freqs = v4l2_ctrl_new_custom(hdl, &si4713_alt_freqs_ctrl, NULL);\n\tsdev->rds_deviation = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_DEVIATION, 0, MAX_RDS_DEVIATION,\n\t\t\t10, DEFAULT_RDS_DEVIATION);\n\t \n\tsdev->rds_ps_name = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_PS_NAME, 0, MAX_RDS_PS_NAME, 8, 0);\n\t \n\tsdev->rds_radio_text = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_RDS_TX_RADIO_TEXT, 0, MAX_RDS_RADIO_TEXT, 32, 0);\n\n\tsdev->limiter_enabled = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_LIMITER_ENABLED, 0, 1, 1, 1);\n\tsdev->limiter_release_time = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_LIMITER_RELEASE_TIME, 250,\n\t\t\tMAX_LIMITER_RELEASE_TIME, 10, DEFAULT_LIMITER_RTIME);\n\tsdev->limiter_deviation = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_LIMITER_DEVIATION, 0,\n\t\t\tMAX_LIMITER_DEVIATION, 10, DEFAULT_LIMITER_DEV);\n\n\tsdev->compression_enabled = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_COMPRESSION_ENABLED, 0, 1, 1, 1);\n\tsdev->compression_gain = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_COMPRESSION_GAIN, 0, MAX_ACOMP_GAIN, 1,\n\t\t\tDEFAULT_ACOMP_GAIN);\n\tsdev->compression_threshold = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_COMPRESSION_THRESHOLD,\n\t\t\tMIN_ACOMP_THRESHOLD, MAX_ACOMP_THRESHOLD, 1,\n\t\t\tDEFAULT_ACOMP_THRESHOLD);\n\tsdev->compression_attack_time = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME, 0,\n\t\t\tMAX_ACOMP_ATTACK_TIME, 500, DEFAULT_ACOMP_ATIME);\n\tsdev->compression_release_time = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME, 100000,\n\t\t\tMAX_ACOMP_RELEASE_TIME, 100000, DEFAULT_ACOMP_RTIME);\n\n\tsdev->pilot_tone_enabled = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_PILOT_TONE_ENABLED, 0, 1, 1, 1);\n\tsdev->pilot_tone_deviation = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_PILOT_TONE_DEVIATION, 0, MAX_PILOT_DEVIATION,\n\t\t\t10, DEFAULT_PILOT_DEVIATION);\n\tsdev->pilot_tone_freq = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_PILOT_TONE_FREQUENCY, 0, MAX_PILOT_FREQUENCY,\n\t\t\t1, DEFAULT_PILOT_FREQUENCY);\n\n\tsdev->tune_preemphasis = v4l2_ctrl_new_std_menu(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_TUNE_PREEMPHASIS,\n\t\t\tV4L2_PREEMPHASIS_75_uS, 0, V4L2_PREEMPHASIS_50_uS);\n\tsdev->tune_pwr_level = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_TUNE_POWER_LEVEL, 0, SI4713_MAX_POWER,\n\t\t\t1, DEFAULT_POWER_LEVEL);\n\tsdev->tune_ant_cap = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\n\t\t\tV4L2_CID_TUNE_ANTENNA_CAPACITOR, 0, SI4713_MAX_ANTCAP,\n\t\t\t1, 0);\n\n\tif (hdl->error) {\n\t\trval = hdl->error;\n\t\tgoto free_ctrls;\n\t}\n\tv4l2_ctrl_cluster(29, &sdev->mute);\n\tsdev->sd.ctrl_handler = hdl;\n\n\tif (client->irq) {\n\t\trval = devm_request_irq(&client->dev, client->irq,\n\t\t\tsi4713_handler, IRQF_TRIGGER_FALLING,\n\t\t\tclient->name, sdev);\n\t\tif (rval < 0) {\n\t\t\tv4l2_err(&sdev->sd, \"Could not request IRQ\\n\");\n\t\t\tgoto free_ctrls;\n\t\t}\n\t\tv4l2_dbg(1, debug, &sdev->sd, \"IRQ requested.\\n\");\n\t} else {\n\t\tv4l2_warn(&sdev->sd, \"IRQ not configured. Using timeouts.\\n\");\n\t}\n\n\trval = si4713_initialize(sdev);\n\tif (rval < 0) {\n\t\tv4l2_err(&sdev->sd, \"Failed to probe device information.\\n\");\n\t\tgoto free_ctrls;\n\t}\n\n\tif (!np && (!pdata || !pdata->is_platform_device))\n\t\treturn 0;\n\n\tsi4713_pdev = platform_device_alloc(\"radio-si4713\", -1);\n\tif (!si4713_pdev) {\n\t\trval = -ENOMEM;\n\t\tgoto put_main_pdev;\n\t}\n\n\tsi4713_pdev_pdata.subdev = client;\n\trval = platform_device_add_data(si4713_pdev, &si4713_pdev_pdata,\n\t\t\t\t\tsizeof(si4713_pdev_pdata));\n\tif (rval)\n\t\tgoto put_main_pdev;\n\n\trval = platform_device_add(si4713_pdev);\n\tif (rval)\n\t\tgoto put_main_pdev;\n\n\tsdev->pd = si4713_pdev;\n\n\treturn 0;\n\nput_main_pdev:\n\tplatform_device_put(si4713_pdev);\n\tv4l2_device_unregister_subdev(&sdev->sd);\nfree_ctrls:\n\tv4l2_ctrl_handler_free(hdl);\nexit:\n\treturn rval;\n}\n\n \nstatic void si4713_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct si4713_device *sdev = to_si4713_device(sd);\n\n\tplatform_device_unregister(sdev->pd);\n\n\tif (sdev->power_state)\n\t\tsi4713_set_power_state(sdev, POWER_DOWN);\n\n\tv4l2_device_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(sd->ctrl_handler);\n}\n\n \nstatic const struct i2c_device_id si4713_id[] = {\n\t{ \"si4713\" , 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, si4713_id);\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id si4713_of_match[] = {\n\t{ .compatible = \"silabs,si4713\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, si4713_of_match);\n#endif\n\nstatic struct i2c_driver si4713_i2c_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"si4713\",\n\t\t.of_match_table = of_match_ptr(si4713_of_match),\n\t},\n\t.probe\t\t= si4713_probe,\n\t.remove         = si4713_remove,\n\t.id_table       = si4713_id,\n};\n\nmodule_i2c_driver(si4713_i2c_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}