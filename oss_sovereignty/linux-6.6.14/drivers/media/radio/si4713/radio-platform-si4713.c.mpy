{
  "module_name": "radio-platform-si4713.c",
  "hash_id": "caf2637fe3f765c4140e703c0e1ac53072f35ca5a6955a79ac3401e76193f0cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/si4713/radio-platform-si4713.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/i2c.h>\n#include <linux/videodev2.h>\n#include <linux/slab.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include \"si4713.h\"\n\n \nstatic int radio_nr = -1;\t \nmodule_param(radio_nr, int, 0);\nMODULE_PARM_DESC(radio_nr,\n\t\t \"Minor number for radio device (-1 ==> auto assign)\");\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Eduardo Valentin <eduardo.valentin@nokia.com>\");\nMODULE_DESCRIPTION(\"Platform driver for Si4713 FM Radio Transmitter\");\nMODULE_VERSION(\"0.0.1\");\nMODULE_ALIAS(\"platform:radio-si4713\");\n\n \nstruct radio_si4713_device {\n\tstruct v4l2_device\t\tv4l2_dev;\n\tstruct video_device\t\tradio_dev;\n\tstruct mutex lock;\n};\n\n \nstatic const struct v4l2_file_operations radio_si4713_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open = v4l2_fh_open,\n\t.release = v4l2_fh_release,\n\t.poll = v4l2_ctrl_poll,\n\t \n\t.unlocked_ioctl\t= video_ioctl2,\n};\n\n \n\n \nstatic int radio_si4713_querycap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_capability *capability)\n{\n\tstrscpy(capability->driver, \"radio-si4713\", sizeof(capability->driver));\n\tstrscpy(capability->card, \"Silicon Labs Si4713 Modulator\",\n\t\tsizeof(capability->card));\n\tstrscpy(capability->bus_info, \"platform:radio-si4713\",\n\t\tsizeof(capability->bus_info));\n\treturn 0;\n}\n\n \nstatic inline struct v4l2_device *get_v4l2_dev(struct file *file)\n{\n\treturn &((struct radio_si4713_device *)video_drvdata(file))->v4l2_dev;\n}\n\nstatic int radio_si4713_g_modulator(struct file *file, void *p,\n\t\t\t\t    struct v4l2_modulator *vm)\n{\n\treturn v4l2_device_call_until_err(get_v4l2_dev(file), 0, tuner,\n\t\t\t\t\t  g_modulator, vm);\n}\n\nstatic int radio_si4713_s_modulator(struct file *file, void *p,\n\t\t\t\t    const struct v4l2_modulator *vm)\n{\n\treturn v4l2_device_call_until_err(get_v4l2_dev(file), 0, tuner,\n\t\t\t\t\t  s_modulator, vm);\n}\n\nstatic int radio_si4713_g_frequency(struct file *file, void *p,\n\t\t\t\t    struct v4l2_frequency *vf)\n{\n\treturn v4l2_device_call_until_err(get_v4l2_dev(file), 0, tuner,\n\t\t\t\t\t  g_frequency, vf);\n}\n\nstatic int radio_si4713_s_frequency(struct file *file, void *p,\n\t\t\t\t    const struct v4l2_frequency *vf)\n{\n\treturn v4l2_device_call_until_err(get_v4l2_dev(file), 0, tuner,\n\t\t\t\t\t  s_frequency, vf);\n}\n\nstatic long radio_si4713_default(struct file *file, void *p,\n\t\t\t\t bool valid_prio, unsigned int cmd, void *arg)\n{\n\treturn v4l2_device_call_until_err(get_v4l2_dev(file), 0, core,\n\t\t\t\t\t  ioctl, cmd, arg);\n}\n\nstatic const struct v4l2_ioctl_ops radio_si4713_ioctl_ops = {\n\t.vidioc_querycap\t= radio_si4713_querycap,\n\t.vidioc_g_modulator\t= radio_si4713_g_modulator,\n\t.vidioc_s_modulator\t= radio_si4713_s_modulator,\n\t.vidioc_g_frequency\t= radio_si4713_g_frequency,\n\t.vidioc_s_frequency\t= radio_si4713_s_frequency,\n\t.vidioc_log_status      = v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\t.vidioc_default\t\t= radio_si4713_default,\n};\n\n \nstatic const struct video_device radio_si4713_vdev_template = {\n\t.fops\t\t\t= &radio_si4713_fops,\n\t.name\t\t\t= \"radio-si4713\",\n\t.release\t\t= video_device_release_empty,\n\t.ioctl_ops\t\t= &radio_si4713_ioctl_ops,\n\t.vfl_dir\t\t= VFL_DIR_TX,\n};\n\n \n \nstatic int radio_si4713_pdriver_probe(struct platform_device *pdev)\n{\n\tstruct radio_si4713_platform_data *pdata = pdev->dev.platform_data;\n\tstruct radio_si4713_device *rsdev;\n\tstruct v4l2_subdev *sd;\n\tint rval = 0;\n\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"Cannot proceed without platform data.\\n\");\n\t\trval = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\trsdev = devm_kzalloc(&pdev->dev, sizeof(*rsdev), GFP_KERNEL);\n\tif (!rsdev) {\n\t\tdev_err(&pdev->dev, \"Failed to alloc video device.\\n\");\n\t\trval = -ENOMEM;\n\t\tgoto exit;\n\t}\n\tmutex_init(&rsdev->lock);\n\n\trval = v4l2_device_register(&pdev->dev, &rsdev->v4l2_dev);\n\tif (rval) {\n\t\tdev_err(&pdev->dev, \"Failed to register v4l2 device.\\n\");\n\t\tgoto exit;\n\t}\n\n\tsd = i2c_get_clientdata(pdata->subdev);\n\trval = v4l2_device_register_subdev(&rsdev->v4l2_dev, sd);\n\tif (rval) {\n\t\tdev_err(&pdev->dev, \"Cannot get v4l2 subdevice\\n\");\n\t\tgoto unregister_v4l2_dev;\n\t}\n\n\trsdev->radio_dev = radio_si4713_vdev_template;\n\trsdev->radio_dev.v4l2_dev = &rsdev->v4l2_dev;\n\trsdev->radio_dev.ctrl_handler = sd->ctrl_handler;\n\t \n\trsdev->radio_dev.lock = &rsdev->lock;\n\trsdev->radio_dev.device_caps = V4L2_CAP_MODULATOR | V4L2_CAP_RDS_OUTPUT;\n\tvideo_set_drvdata(&rsdev->radio_dev, rsdev);\n\tif (video_register_device(&rsdev->radio_dev, VFL_TYPE_RADIO, radio_nr)) {\n\t\tdev_err(&pdev->dev, \"Could not register video device.\\n\");\n\t\trval = -EIO;\n\t\tgoto unregister_v4l2_dev;\n\t}\n\tdev_info(&pdev->dev, \"New device successfully probed\\n\");\n\n\tgoto exit;\n\nunregister_v4l2_dev:\n\tv4l2_device_unregister(&rsdev->v4l2_dev);\nexit:\n\treturn rval;\n}\n\n \nstatic void radio_si4713_pdriver_remove(struct platform_device *pdev)\n{\n\tstruct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);\n\tstruct radio_si4713_device *rsdev;\n\n\trsdev = container_of(v4l2_dev, struct radio_si4713_device, v4l2_dev);\n\tvideo_unregister_device(&rsdev->radio_dev);\n\tv4l2_device_unregister(&rsdev->v4l2_dev);\n}\n\nstatic struct platform_driver radio_si4713_pdriver = {\n\t.driver\t\t= {\n\t\t.name\t= \"radio-si4713\",\n\t},\n\t.probe\t\t= radio_si4713_pdriver_probe,\n\t.remove_new     = radio_si4713_pdriver_remove,\n};\n\nmodule_platform_driver(radio_si4713_pdriver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}