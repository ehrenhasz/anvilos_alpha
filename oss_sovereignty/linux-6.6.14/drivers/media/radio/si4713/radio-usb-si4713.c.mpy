{
  "module_name": "radio-usb-si4713.c",
  "hash_id": "aa3a9a517019280fb096101f51292f4707e5e9ad1addf6f98eba5933664b7952",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/si4713/radio-usb-si4713.c",
  "human_readable_source": "\n \n\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/mutex.h>\n#include <linux/i2c.h>\n \n#include <linux/videodev2.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include <linux/platform_data/media/si4713.h>\n\n#include \"si4713.h\"\n\n \nMODULE_AUTHOR(\"Dinesh Ram <dinesh.ram@cern.ch>\");\nMODULE_DESCRIPTION(\"Si4713 FM Transmitter USB driver\");\nMODULE_LICENSE(\"GPL v2\");\n\n \n#define USB_SI4713_VENDOR\t\t0x10c4\n#define USB_SI4713_PRODUCT\t\t0x8244\n\n#define BUFFER_LENGTH\t\t\t64\n#define USB_TIMEOUT\t\t\t1000\n#define USB_RESP_TIMEOUT\t\t50000\n\n \nstatic const struct usb_device_id usb_si4713_usb_device_table[] = {\n\t{USB_DEVICE_AND_INTERFACE_INFO(USB_SI4713_VENDOR, USB_SI4713_PRODUCT,\n\t\t\t\t\t\t\tUSB_CLASS_HID, 0, 0) },\n\t{ }\t\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, usb_si4713_usb_device_table);\n\nstruct si4713_usb_device {\n\tstruct usb_device\t*usbdev;\n\tstruct usb_interface\t*intf;\n\tstruct video_device\tvdev;\n\tstruct v4l2_device\tv4l2_dev;\n\tstruct v4l2_subdev\t*v4l2_subdev;\n\tstruct mutex\t\tlock;\n\tstruct i2c_adapter\ti2c_adapter;\n\n\tu8\t\t\t*buffer;\n};\n\nstatic inline struct si4713_usb_device *to_si4713_dev(struct v4l2_device *v4l2_dev)\n{\n\treturn container_of(v4l2_dev, struct si4713_usb_device, v4l2_dev);\n}\n\nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_capability *v)\n{\n\tstruct si4713_usb_device *radio = video_drvdata(file);\n\n\tstrscpy(v->driver, \"radio-usb-si4713\", sizeof(v->driver));\n\tstrscpy(v->card, \"Si4713 FM Transmitter\", sizeof(v->card));\n\tusb_make_path(radio->usbdev, v->bus_info, sizeof(v->bus_info));\n\treturn 0;\n}\n\nstatic int vidioc_g_modulator(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_modulator *vm)\n{\n\tstruct si4713_usb_device *radio = video_drvdata(file);\n\n\treturn v4l2_subdev_call(radio->v4l2_subdev, tuner, g_modulator, vm);\n}\n\nstatic int vidioc_s_modulator(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_modulator *vm)\n{\n\tstruct si4713_usb_device *radio = video_drvdata(file);\n\n\treturn v4l2_subdev_call(radio->v4l2_subdev, tuner, s_modulator, vm);\n}\n\nstatic int vidioc_s_frequency(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_frequency *vf)\n{\n\tstruct si4713_usb_device *radio = video_drvdata(file);\n\n\treturn v4l2_subdev_call(radio->v4l2_subdev, tuner, s_frequency, vf);\n}\n\nstatic int vidioc_g_frequency(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_frequency *vf)\n{\n\tstruct si4713_usb_device *radio = video_drvdata(file);\n\n\treturn v4l2_subdev_call(radio->v4l2_subdev, tuner, g_frequency, vf);\n}\n\nstatic const struct v4l2_ioctl_ops usb_si4713_ioctl_ops = {\n\t.vidioc_querycap\t  = vidioc_querycap,\n\t.vidioc_g_modulator\t  = vidioc_g_modulator,\n\t.vidioc_s_modulator\t  = vidioc_s_modulator,\n\t.vidioc_g_frequency\t  = vidioc_g_frequency,\n\t.vidioc_s_frequency\t  = vidioc_s_frequency,\n\t.vidioc_log_status\t  = v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event   = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\n \nstatic const struct v4l2_file_operations usb_si4713_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open           = v4l2_fh_open,\n\t.release        = v4l2_fh_release,\n\t.poll           = v4l2_ctrl_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n};\n\nstatic void usb_si4713_video_device_release(struct v4l2_device *v4l2_dev)\n{\n\tstruct si4713_usb_device *radio = to_si4713_dev(v4l2_dev);\n\tstruct i2c_adapter *adapter = &radio->i2c_adapter;\n\n\ti2c_del_adapter(adapter);\n\tv4l2_device_unregister(&radio->v4l2_dev);\n\tkfree(radio->buffer);\n\tkfree(radio);\n}\n\n \nstatic int si4713_send_startup_command(struct si4713_usb_device *radio)\n{\n\tunsigned long until_jiffies = jiffies + usecs_to_jiffies(USB_RESP_TIMEOUT) + 1;\n\tu8 *buffer = radio->buffer;\n\tint retval;\n\n\t \n\tretval = usb_control_msg(radio->usbdev, usb_sndctrlpipe(radio->usbdev, 0),\n\t\t\t\t\t0x09, 0x21, 0x033f, 0, radio->buffer,\n\t\t\t\t\tBUFFER_LENGTH, USB_TIMEOUT);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tfor (;;) {\n\t\t \n\t\tretval = usb_control_msg(radio->usbdev, usb_rcvctrlpipe(radio->usbdev, 0),\n\t\t\t\t0x01, 0xa1, 0x033f, 0, radio->buffer,\n\t\t\t\tBUFFER_LENGTH, USB_TIMEOUT);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (!radio->buffer[1]) {\n\t\t\t \n\t\t\tswitch (buffer[1]) {\n\t\t\tcase 0x32:\n\t\t\t\tif (radio->buffer[2] == 0)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\tcase 0x14:\n\t\t\tcase 0x12:\n\t\t\t\tif (radio->buffer[2] & SI4713_CTS)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\tcase 0x06:\n\t\t\t\tif ((radio->buffer[2] & SI4713_CTS) && radio->buffer[9] == 0x08)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif (time_is_before_jiffies(until_jiffies))\n\t\t\treturn -EIO;\n\t\tmsleep(3);\n\t}\n\n\treturn retval;\n}\n\nstruct si4713_start_seq_table {\n\tint len;\n\tu8 payload[8];\n};\n\n \nstatic const struct si4713_start_seq_table start_seq[] = {\n\n\t{ 1, { 0x03 } },\n\t{ 2, { 0x32, 0x7f } },\n\t{ 6, { 0x06, 0x03, 0x03, 0x08, 0x01, 0x0f } },\n\t{ 2, { 0x14, 0x02 } },\n\t{ 2, { 0x09, 0x90 } },\n\t{ 3, { 0x08, 0x90, 0xfa } },\n\t{ 2, { 0x36, 0x01 } },\n\t{ 2, { 0x05, 0x03 } },\n\t{ 7, { 0x06, 0x00, 0x06, 0x0e, 0x01, 0x0f, 0x05 } },\n\t{ 1, { 0x12 } },\n\t \n\t{ 1, { 0x03 } },\n\t{ 1, { 0x01 } },\n\t{ 2, { 0x09, 0x90 } },\n\t{ 3, { 0x08, 0x90, 0xfa } },\n\t{ 1, { 0x34 } },\n\t{ 2, { 0x35, 0x01 } },\n\t{ 2, { 0x36, 0x01 } },\n\t{ 2, { 0x30, 0x09 } },\n\t{ 4, { 0x30, 0x06, 0x00, 0xe2 } },\n\t{ 3, { 0x31, 0x01, 0x30 } },\n\t{ 3, { 0x31, 0x04, 0x09 } },\n\t{ 2, { 0x05, 0x02 } },\n\t{ 6, { 0x06, 0x03, 0x03, 0x08, 0x01, 0x0f } },\n};\n\nstatic int si4713_start_seq(struct si4713_usb_device *radio)\n{\n\tint retval = 0;\n\tint i;\n\n\tradio->buffer[0] = 0x3f;\n\n\tfor (i = 0; i < ARRAY_SIZE(start_seq); i++) {\n\t\tint len = start_seq[i].len;\n\t\tconst u8 *payload = start_seq[i].payload;\n\n\t\tmemcpy(radio->buffer + 1, payload, len);\n\t\tmemset(radio->buffer + len + 1, 0, BUFFER_LENGTH - 1 - len);\n\t\tretval = si4713_send_startup_command(radio);\n\t}\n\n\treturn retval;\n}\n\nstatic struct i2c_board_info si4713_board_info = {\n\tI2C_BOARD_INFO(\"si4713\", SI4713_I2C_ADDR_BUSEN_HIGH),\n};\n\nstruct si4713_command_table {\n\tint command_id;\n\tu8 payload[8];\n};\n\n \nstatic struct si4713_command_table command_table[] = {\n\n\t{ SI4713_CMD_POWER_UP,\t\t{ 0x00, SI4713_PWUP_NARGS + 1, SI4713_PWUP_NRESP} },\n\t{ SI4713_CMD_GET_REV,\t\t{ 0x03, 0x01, SI4713_GETREV_NRESP } },\n\t{ SI4713_CMD_POWER_DOWN,\t{ 0x00, 0x01, SI4713_PWDN_NRESP} },\n\t{ SI4713_CMD_SET_PROPERTY,\t{ 0x00, SI4713_SET_PROP_NARGS + 1, SI4713_SET_PROP_NRESP } },\n\t{ SI4713_CMD_GET_PROPERTY,\t{ 0x00, SI4713_GET_PROP_NARGS + 1, SI4713_GET_PROP_NRESP } },\n\t{ SI4713_CMD_TX_TUNE_FREQ,\t{ 0x03, SI4713_TXFREQ_NARGS + 1, SI4713_TXFREQ_NRESP } },\n\t{ SI4713_CMD_TX_TUNE_POWER,\t{ 0x03, SI4713_TXPWR_NARGS + 1, SI4713_TXPWR_NRESP } },\n\t{ SI4713_CMD_TX_TUNE_MEASURE,\t{ 0x03, SI4713_TXMEA_NARGS + 1, SI4713_TXMEA_NRESP } },\n\t{ SI4713_CMD_TX_TUNE_STATUS,\t{ 0x00, SI4713_TXSTATUS_NARGS + 1, SI4713_TXSTATUS_NRESP } },\n\t{ SI4713_CMD_TX_ASQ_STATUS,\t{ 0x03, SI4713_ASQSTATUS_NARGS + 1, SI4713_ASQSTATUS_NRESP } },\n\t{ SI4713_CMD_GET_INT_STATUS,\t{ 0x03, 0x01, SI4713_GET_STATUS_NRESP } },\n\t{ SI4713_CMD_TX_RDS_BUFF,\t{ 0x03, SI4713_RDSBUFF_NARGS + 1, SI4713_RDSBUFF_NRESP } },\n\t{ SI4713_CMD_TX_RDS_PS,\t\t{ 0x00, SI4713_RDSPS_NARGS + 1, SI4713_RDSPS_NRESP } },\n};\n\nstatic int send_command(struct si4713_usb_device *radio, u8 *payload, char *data, int len)\n{\n\tint retval;\n\n\tradio->buffer[0] = 0x3f;\n\tradio->buffer[1] = 0x06;\n\n\tmemcpy(radio->buffer + 2, payload, 3);\n\tmemcpy(radio->buffer + 5, data, len);\n\tmemset(radio->buffer + 5 + len, 0, BUFFER_LENGTH - 5 - len);\n\n\t \n\tretval = usb_control_msg(radio->usbdev, usb_sndctrlpipe(radio->usbdev, 0),\n\t\t\t\t\t0x09, 0x21, 0x033f, 0, radio->buffer,\n\t\t\t\t\tBUFFER_LENGTH, USB_TIMEOUT);\n\n\treturn retval < 0 ? retval : 0;\n}\n\nstatic int si4713_i2c_read(struct si4713_usb_device *radio, char *data, int len)\n{\n\tunsigned long until_jiffies = jiffies + usecs_to_jiffies(USB_RESP_TIMEOUT) + 1;\n\tint retval;\n\n\t \n\tfor (;;) {\n\t\tretval = usb_control_msg(radio->usbdev,\n\t\t\t\t\tusb_rcvctrlpipe(radio->usbdev, 0),\n\t\t\t\t\t0x01, 0xa1, 0x033f, 0, radio->buffer,\n\t\t\t\t\tBUFFER_LENGTH, USB_TIMEOUT);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\t \n\t\tif (radio->buffer[1] == 0 && (radio->buffer[2] & SI4713_CTS)) {\n\t\t\tmemcpy(data, radio->buffer + 2, len);\n\t\t\treturn 0;\n\t\t}\n\t\tif (time_is_before_jiffies(until_jiffies)) {\n\t\t\t \n\t\t\tdata[0] = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tmsleep(3);\n\t}\n}\n\nstatic int si4713_i2c_write(struct si4713_usb_device *radio, char *data, int len)\n{\n\tint retval = -EINVAL;\n\tint i;\n\n\tif (len > BUFFER_LENGTH - 5)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(command_table); i++) {\n\t\tif (data[0] == command_table[i].command_id)\n\t\t\tretval = send_command(radio, command_table[i].payload,\n\t\t\t\t\t\tdata, len);\n\t}\n\n\treturn retval < 0 ? retval : 0;\n}\n\nstatic int si4713_transfer(struct i2c_adapter *i2c_adapter,\n\t\t\t\tstruct i2c_msg *msgs, int num)\n{\n\tstruct si4713_usb_device *radio = i2c_get_adapdata(i2c_adapter);\n\tint retval = -EINVAL;\n\tint i;\n\n\tfor (i = 0; i < num; i++) {\n\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\tretval = si4713_i2c_read(radio, msgs[i].buf, msgs[i].len);\n\t\telse\n\t\t\tretval = si4713_i2c_write(radio, msgs[i].buf, msgs[i].len);\n\t\tif (retval)\n\t\t\tbreak;\n\t}\n\n\treturn retval ? retval : num;\n}\n\nstatic u32 si4713_functionality(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm si4713_algo = {\n\t.master_xfer   = si4713_transfer,\n\t.functionality = si4713_functionality,\n};\n\n \nstatic const struct i2c_adapter si4713_i2c_adapter_template = {\n\t.name   = \"si4713-i2c\",\n\t.owner  = THIS_MODULE,\n\t.algo   = &si4713_algo,\n};\n\nstatic int si4713_register_i2c_adapter(struct si4713_usb_device *radio)\n{\n\tradio->i2c_adapter = si4713_i2c_adapter_template;\n\t \n\tradio->i2c_adapter.dev.parent = &radio->usbdev->dev;\n\ti2c_set_adapdata(&radio->i2c_adapter, radio);\n\n\treturn i2c_add_adapter(&radio->i2c_adapter);\n}\n\n \nstatic int usb_si4713_probe(struct usb_interface *intf,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct si4713_usb_device *radio;\n\tstruct i2c_adapter *adapter;\n\tstruct v4l2_subdev *sd;\n\tint retval;\n\n\tdev_info(&intf->dev, \"Si4713 development board discovered: (%04X:%04X)\\n\",\n\t\t\tid->idVendor, id->idProduct);\n\n\t \n\tradio = kzalloc(sizeof(struct si4713_usb_device), GFP_KERNEL);\n\tif (radio)\n\t\tradio->buffer = kmalloc(BUFFER_LENGTH, GFP_KERNEL);\n\n\tif (!radio || !radio->buffer) {\n\t\tdev_err(&intf->dev, \"kmalloc for si4713_usb_device failed\\n\");\n\t\tkfree(radio);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&radio->lock);\n\n\tradio->usbdev = interface_to_usbdev(intf);\n\tradio->intf = intf;\n\tusb_set_intfdata(intf, &radio->v4l2_dev);\n\n\tretval = si4713_start_seq(radio);\n\tif (retval < 0)\n\t\tgoto err_v4l2;\n\n\tretval = v4l2_device_register(&intf->dev, &radio->v4l2_dev);\n\tif (retval < 0) {\n\t\tdev_err(&intf->dev, \"couldn't register v4l2_device\\n\");\n\t\tgoto err_v4l2;\n\t}\n\n\tretval = si4713_register_i2c_adapter(radio);\n\tif (retval < 0) {\n\t\tdev_err(&intf->dev, \"could not register i2c device\\n\");\n\t\tgoto err_i2cdev;\n\t}\n\n\tadapter = &radio->i2c_adapter;\n\tsd = v4l2_i2c_new_subdev_board(&radio->v4l2_dev, adapter,\n\t\t\t\t\t  &si4713_board_info, NULL);\n\tradio->v4l2_subdev = sd;\n\tif (!sd) {\n\t\tdev_err(&intf->dev, \"cannot get v4l2 subdevice\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto del_adapter;\n\t}\n\n\tradio->vdev.ctrl_handler = sd->ctrl_handler;\n\tradio->v4l2_dev.release = usb_si4713_video_device_release;\n\tstrscpy(radio->vdev.name, radio->v4l2_dev.name,\n\t\tsizeof(radio->vdev.name));\n\tradio->vdev.v4l2_dev = &radio->v4l2_dev;\n\tradio->vdev.fops = &usb_si4713_fops;\n\tradio->vdev.ioctl_ops = &usb_si4713_ioctl_ops;\n\tradio->vdev.lock = &radio->lock;\n\tradio->vdev.release = video_device_release_empty;\n\tradio->vdev.vfl_dir = VFL_DIR_TX;\n\tradio->vdev.device_caps = V4L2_CAP_MODULATOR | V4L2_CAP_RDS_OUTPUT;\n\n\tvideo_set_drvdata(&radio->vdev, radio);\n\n\tretval = video_register_device(&radio->vdev, VFL_TYPE_RADIO, -1);\n\tif (retval < 0) {\n\t\tdev_err(&intf->dev, \"could not register video device\\n\");\n\t\tgoto del_adapter;\n\t}\n\n\tdev_info(&intf->dev, \"V4L2 device registered as %s\\n\",\n\t\t\tvideo_device_node_name(&radio->vdev));\n\n\treturn 0;\n\ndel_adapter:\n\ti2c_del_adapter(adapter);\nerr_i2cdev:\n\tv4l2_device_unregister(&radio->v4l2_dev);\nerr_v4l2:\n\tkfree(radio->buffer);\n\tkfree(radio);\n\treturn retval;\n}\n\nstatic void usb_si4713_disconnect(struct usb_interface *intf)\n{\n\tstruct si4713_usb_device *radio = to_si4713_dev(usb_get_intfdata(intf));\n\n\tdev_info(&intf->dev, \"Si4713 development board now disconnected\\n\");\n\n\tmutex_lock(&radio->lock);\n\tusb_set_intfdata(intf, NULL);\n\tvideo_unregister_device(&radio->vdev);\n\tv4l2_device_disconnect(&radio->v4l2_dev);\n\tmutex_unlock(&radio->lock);\n\tv4l2_device_put(&radio->v4l2_dev);\n}\n\n \nstatic struct usb_driver usb_si4713_driver = {\n\t.name\t\t\t= \"radio-usb-si4713\",\n\t.probe\t\t\t= usb_si4713_probe,\n\t.disconnect\t\t= usb_si4713_disconnect,\n\t.id_table\t\t= usb_si4713_usb_device_table,\n};\n\nmodule_usb_driver(usb_si4713_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}