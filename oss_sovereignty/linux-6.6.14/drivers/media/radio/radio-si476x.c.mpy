{
  "module_name": "radio-si476x.c",
  "hash_id": "5dda9a6d3de057033a9ea3cfcede353cda1f9311261a20372251fb3c7ec6a964",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/radio-si476x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/videodev2.h>\n#include <linux/mutex.h>\n#include <linux/debugfs.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-device.h>\n\n#include <media/drv-intf/si476x.h>\n#include <linux/mfd/si476x-core.h>\n\n#define FM_FREQ_RANGE_LOW   64000000\n#define FM_FREQ_RANGE_HIGH 108000000\n\n#define AM_FREQ_RANGE_LOW    520000\n#define AM_FREQ_RANGE_HIGH 30000000\n\n#define PWRLINEFLTR (1 << 8)\n\n#define FREQ_MUL (10000000 / 625)\n\n#define SI476X_PHDIV_STATUS_LINK_LOCKED(status) (0x80 & (status))\n\n#define DRIVER_NAME \"si476x-radio\"\n#define DRIVER_CARD \"SI476x AM/FM Receiver\"\n\nenum si476x_freq_bands {\n\tSI476X_BAND_FM,\n\tSI476X_BAND_AM,\n};\n\nstatic const struct v4l2_frequency_band si476x_bands[] = {\n\t[SI476X_BAND_FM] = {\n\t\t.type\t\t= V4L2_TUNER_RADIO,\n\t\t.index\t\t= SI476X_BAND_FM,\n\t\t.capability\t= V4L2_TUNER_CAP_LOW\n\t\t| V4L2_TUNER_CAP_STEREO\n\t\t| V4L2_TUNER_CAP_RDS\n\t\t| V4L2_TUNER_CAP_RDS_BLOCK_IO\n\t\t| V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow\t=  64 * FREQ_MUL,\n\t\t.rangehigh\t= 108 * FREQ_MUL,\n\t\t.modulation\t= V4L2_BAND_MODULATION_FM,\n\t},\n\t[SI476X_BAND_AM] = {\n\t\t.type\t\t= V4L2_TUNER_RADIO,\n\t\t.index\t\t= SI476X_BAND_AM,\n\t\t.capability\t= V4L2_TUNER_CAP_LOW\n\t\t| V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow\t= 0.52 * FREQ_MUL,\n\t\t.rangehigh\t= 30 * FREQ_MUL,\n\t\t.modulation\t= V4L2_BAND_MODULATION_AM,\n\t},\n};\n\nstatic inline bool si476x_radio_freq_is_inside_of_the_band(u32 freq, int band)\n{\n\treturn freq >= si476x_bands[band].rangelow &&\n\t\tfreq <= si476x_bands[band].rangehigh;\n}\n\nstatic inline bool si476x_radio_range_is_inside_of_the_band(u32 low, u32 high,\n\t\t\t\t\t\t\t    int band)\n{\n\treturn low  >= si476x_bands[band].rangelow &&\n\t\thigh <= si476x_bands[band].rangehigh;\n}\n\nstatic int si476x_radio_s_ctrl(struct v4l2_ctrl *ctrl);\nstatic int si476x_radio_g_volatile_ctrl(struct v4l2_ctrl *ctrl);\n\nenum phase_diversity_modes_idx {\n\tSI476X_IDX_PHDIV_DISABLED,\n\tSI476X_IDX_PHDIV_PRIMARY_COMBINING,\n\tSI476X_IDX_PHDIV_PRIMARY_ANTENNA,\n\tSI476X_IDX_PHDIV_SECONDARY_ANTENNA,\n\tSI476X_IDX_PHDIV_SECONDARY_COMBINING,\n};\n\nstatic const char * const phase_diversity_modes[] = {\n\t[SI476X_IDX_PHDIV_DISABLED]\t\t= \"Disabled\",\n\t[SI476X_IDX_PHDIV_PRIMARY_COMBINING]\t= \"Primary with Secondary\",\n\t[SI476X_IDX_PHDIV_PRIMARY_ANTENNA]\t= \"Primary Antenna\",\n\t[SI476X_IDX_PHDIV_SECONDARY_ANTENNA]\t= \"Secondary Antenna\",\n\t[SI476X_IDX_PHDIV_SECONDARY_COMBINING]\t= \"Secondary with Primary\",\n};\n\nstatic inline enum phase_diversity_modes_idx\nsi476x_phase_diversity_mode_to_idx(enum si476x_phase_diversity_mode mode)\n{\n\tswitch (mode) {\n\tdefault:\n\t\tfallthrough;\n\tcase SI476X_PHDIV_DISABLED:\n\t\treturn SI476X_IDX_PHDIV_DISABLED;\n\tcase SI476X_PHDIV_PRIMARY_COMBINING:\n\t\treturn SI476X_IDX_PHDIV_PRIMARY_COMBINING;\n\tcase SI476X_PHDIV_PRIMARY_ANTENNA:\n\t\treturn SI476X_IDX_PHDIV_PRIMARY_ANTENNA;\n\tcase SI476X_PHDIV_SECONDARY_ANTENNA:\n\t\treturn SI476X_IDX_PHDIV_SECONDARY_ANTENNA;\n\tcase SI476X_PHDIV_SECONDARY_COMBINING:\n\t\treturn SI476X_IDX_PHDIV_SECONDARY_COMBINING;\n\t}\n}\n\nstatic inline enum si476x_phase_diversity_mode\nsi476x_phase_diversity_idx_to_mode(enum phase_diversity_modes_idx idx)\n{\n\tstatic const int idx_to_value[] = {\n\t\t[SI476X_IDX_PHDIV_DISABLED]\t\t= SI476X_PHDIV_DISABLED,\n\t\t[SI476X_IDX_PHDIV_PRIMARY_COMBINING]\t= SI476X_PHDIV_PRIMARY_COMBINING,\n\t\t[SI476X_IDX_PHDIV_PRIMARY_ANTENNA]\t= SI476X_PHDIV_PRIMARY_ANTENNA,\n\t\t[SI476X_IDX_PHDIV_SECONDARY_ANTENNA]\t= SI476X_PHDIV_SECONDARY_ANTENNA,\n\t\t[SI476X_IDX_PHDIV_SECONDARY_COMBINING]\t= SI476X_PHDIV_SECONDARY_COMBINING,\n\t};\n\n\treturn idx_to_value[idx];\n}\n\nstatic const struct v4l2_ctrl_ops si476x_ctrl_ops = {\n\t.g_volatile_ctrl\t= si476x_radio_g_volatile_ctrl,\n\t.s_ctrl\t\t\t= si476x_radio_s_ctrl,\n};\n\n\nenum si476x_ctrl_idx {\n\tSI476X_IDX_RSSI_THRESHOLD,\n\tSI476X_IDX_SNR_THRESHOLD,\n\tSI476X_IDX_MAX_TUNE_ERROR,\n\tSI476X_IDX_HARMONICS_COUNT,\n\tSI476X_IDX_DIVERSITY_MODE,\n\tSI476X_IDX_INTERCHIP_LINK,\n};\nstatic struct v4l2_ctrl_config si476x_ctrls[] = {\n\n\t \n\t[SI476X_IDX_RSSI_THRESHOLD] = {\n\t\t.ops\t= &si476x_ctrl_ops,\n\t\t.id\t= V4L2_CID_SI476X_RSSI_THRESHOLD,\n\t\t.name\t= \"Valid RSSI Threshold\",\n\t\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.min\t= -128,\n\t\t.max\t= 127,\n\t\t.step\t= 1,\n\t},\n\t[SI476X_IDX_SNR_THRESHOLD] = {\n\t\t.ops\t= &si476x_ctrl_ops,\n\t\t.id\t= V4L2_CID_SI476X_SNR_THRESHOLD,\n\t\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.name\t= \"Valid SNR Threshold\",\n\t\t.min\t= -128,\n\t\t.max\t= 127,\n\t\t.step\t= 1,\n\t},\n\t[SI476X_IDX_MAX_TUNE_ERROR] = {\n\t\t.ops\t= &si476x_ctrl_ops,\n\t\t.id\t= V4L2_CID_SI476X_MAX_TUNE_ERROR,\n\t\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.name\t= \"Max Tune Errors\",\n\t\t.min\t= 0,\n\t\t.max\t= 126 * 2,\n\t\t.step\t= 2,\n\t},\n\n\t \n\t[SI476X_IDX_HARMONICS_COUNT] = {\n\t\t.ops\t= &si476x_ctrl_ops,\n\t\t.id\t= V4L2_CID_SI476X_HARMONICS_COUNT,\n\t\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\n\t\t.name\t= \"Count of Harmonics to Reject\",\n\t\t.min\t= 0,\n\t\t.max\t= 20,\n\t\t.step\t= 1,\n\t},\n\n\t \n\t[SI476X_IDX_DIVERSITY_MODE] = {\n\t\t.ops\t= &si476x_ctrl_ops,\n\t\t.id\t= V4L2_CID_SI476X_DIVERSITY_MODE,\n\t\t.type\t= V4L2_CTRL_TYPE_MENU,\n\t\t.name\t= \"Phase Diversity Mode\",\n\t\t.qmenu\t= phase_diversity_modes,\n\t\t.min\t= 0,\n\t\t.max\t= ARRAY_SIZE(phase_diversity_modes) - 1,\n\t},\n\n\t \n\t[SI476X_IDX_INTERCHIP_LINK] = {\n\t\t.ops\t= &si476x_ctrl_ops,\n\t\t.id\t= V4L2_CID_SI476X_INTERCHIP_LINK,\n\t\t.type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.flags  = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_VOLATILE,\n\t\t.name\t= \"Inter-Chip Link\",\n\t\t.min\t= 0,\n\t\t.max\t= 1,\n\t\t.step\t= 1,\n\t},\n};\n\nstruct si476x_radio;\n\n \nstruct si476x_radio_ops {\n\tint (*tune_freq)(struct si476x_core *, struct si476x_tune_freq_args *);\n\tint (*seek_start)(struct si476x_core *, bool, bool);\n\tint (*rsq_status)(struct si476x_core *, struct si476x_rsq_status_args *,\n\t\t\t  struct si476x_rsq_status_report *);\n\tint (*rds_blckcnt)(struct si476x_core *, bool,\n\t\t\t   struct si476x_rds_blockcount_report *);\n\n\tint (*phase_diversity)(struct si476x_core *,\n\t\t\t       enum si476x_phase_diversity_mode);\n\tint (*phase_div_status)(struct si476x_core *);\n\tint (*acf_status)(struct si476x_core *,\n\t\t\t  struct si476x_acf_status_report *);\n\tint (*agc_status)(struct si476x_core *,\n\t\t\t  struct si476x_agc_status_report *);\n};\n\n \nstruct si476x_radio {\n\tstruct v4l2_device v4l2dev;\n\tstruct video_device videodev;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\n\tstruct si476x_core  *core;\n\t \n\tconst struct si476x_radio_ops *ops;\n\n\tstruct dentry\t*debugfs;\n\tu32 audmode;\n};\n\nstatic inline struct si476x_radio *\nv4l2_ctrl_handler_to_radio(struct v4l2_ctrl_handler *d)\n{\n\treturn container_of(d, struct si476x_radio, ctrl_handler);\n}\n\n \nstatic int si476x_radio_querycap(struct file *file, void *priv,\n\t\t\t\t struct v4l2_capability *capability)\n{\n\tstruct si476x_radio *radio = video_drvdata(file);\n\n\tstrscpy(capability->driver, radio->v4l2dev.name,\n\t\tsizeof(capability->driver));\n\tstrscpy(capability->card,   DRIVER_CARD, sizeof(capability->card));\n\tsnprintf(capability->bus_info, sizeof(capability->bus_info),\n\t\t \"platform:%s\", radio->v4l2dev.name);\n\treturn 0;\n}\n\nstatic int si476x_radio_enum_freq_bands(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_frequency_band *band)\n{\n\tint err;\n\tstruct si476x_radio *radio = video_drvdata(file);\n\n\tif (band->tuner != 0)\n\t\treturn -EINVAL;\n\n\tswitch (radio->core->chip_id) {\n\t\t \n\tcase SI476X_CHIP_SI4761:\n\tcase SI476X_CHIP_SI4764:\n\t\tif (band->index < ARRAY_SIZE(si476x_bands)) {\n\t\t\t*band = si476x_bands[band->index];\n\t\t\terr = 0;\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tbreak;\n\t\t \n\tcase SI476X_CHIP_SI4768:\n\t\tif (band->index == SI476X_BAND_FM) {\n\t\t\t*band = si476x_bands[band->index];\n\t\t\terr = 0;\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic int si476x_radio_g_tuner(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_tuner *tuner)\n{\n\tint err;\n\tstruct si476x_rsq_status_report report;\n\tstruct si476x_radio *radio = video_drvdata(file);\n\n\tstruct si476x_rsq_status_args args = {\n\t\t.primary\t= false,\n\t\t.rsqack\t\t= false,\n\t\t.attune\t\t= false,\n\t\t.cancel\t\t= false,\n\t\t.stcack\t\t= false,\n\t};\n\n\tif (tuner->index != 0)\n\t\treturn -EINVAL;\n\n\ttuner->type       = V4L2_TUNER_RADIO;\n\ttuner->capability = V4L2_TUNER_CAP_LOW  \n\t\t| V4L2_TUNER_CAP_STEREO\n\t\t| V4L2_TUNER_CAP_HWSEEK_BOUNDED\n\t\t| V4L2_TUNER_CAP_HWSEEK_WRAP\n\t\t| V4L2_TUNER_CAP_HWSEEK_PROG_LIM;\n\n\tsi476x_core_lock(radio->core);\n\n\tif (si476x_core_is_a_secondary_tuner(radio->core)) {\n\t\tstrscpy(tuner->name, \"FM (secondary)\", sizeof(tuner->name));\n\t\ttuner->rxsubchans = 0;\n\t\ttuner->rangelow = si476x_bands[SI476X_BAND_FM].rangelow;\n\t} else if (si476x_core_has_am(radio->core)) {\n\t\tif (si476x_core_is_a_primary_tuner(radio->core))\n\t\t\tstrscpy(tuner->name, \"AM/FM (primary)\",\n\t\t\t\tsizeof(tuner->name));\n\t\telse\n\t\t\tstrscpy(tuner->name, \"AM/FM\", sizeof(tuner->name));\n\n\t\ttuner->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO\n\t\t\t| V4L2_TUNER_SUB_RDS;\n\t\ttuner->capability |= V4L2_TUNER_CAP_RDS\n\t\t\t| V4L2_TUNER_CAP_RDS_BLOCK_IO\n\t\t\t| V4L2_TUNER_CAP_FREQ_BANDS;\n\n\t\ttuner->rangelow = si476x_bands[SI476X_BAND_AM].rangelow;\n\t} else {\n\t\tstrscpy(tuner->name, \"FM\", sizeof(tuner->name));\n\t\ttuner->rxsubchans = V4L2_TUNER_SUB_RDS;\n\t\ttuner->capability |= V4L2_TUNER_CAP_RDS\n\t\t\t| V4L2_TUNER_CAP_RDS_BLOCK_IO\n\t\t\t| V4L2_TUNER_CAP_FREQ_BANDS;\n\t\ttuner->rangelow = si476x_bands[SI476X_BAND_FM].rangelow;\n\t}\n\n\ttuner->audmode = radio->audmode;\n\n\ttuner->afc = 1;\n\ttuner->rangehigh = si476x_bands[SI476X_BAND_FM].rangehigh;\n\n\terr = radio->ops->rsq_status(radio->core,\n\t\t\t\t     &args, &report);\n\tif (err < 0) {\n\t\ttuner->signal = 0;\n\t} else {\n\t\t \n\t\ttuner->signal = (report.rssi + 128) * 257;\n\t}\n\tsi476x_core_unlock(radio->core);\n\n\treturn err;\n}\n\nstatic int si476x_radio_s_tuner(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_tuner *tuner)\n{\n\tstruct si476x_radio *radio = video_drvdata(file);\n\n\tif (tuner->index != 0)\n\t\treturn -EINVAL;\n\n\tif (tuner->audmode == V4L2_TUNER_MODE_MONO ||\n\t    tuner->audmode == V4L2_TUNER_MODE_STEREO)\n\t\tradio->audmode = tuner->audmode;\n\telse\n\t\tradio->audmode = V4L2_TUNER_MODE_STEREO;\n\n\treturn 0;\n}\n\nstatic int si476x_radio_init_vtable(struct si476x_radio *radio,\n\t\t\t\t    enum si476x_func func)\n{\n\tstatic const struct si476x_radio_ops fm_ops = {\n\t\t.tune_freq\t\t= si476x_core_cmd_fm_tune_freq,\n\t\t.seek_start\t\t= si476x_core_cmd_fm_seek_start,\n\t\t.rsq_status\t\t= si476x_core_cmd_fm_rsq_status,\n\t\t.rds_blckcnt\t\t= si476x_core_cmd_fm_rds_blockcount,\n\t\t.phase_diversity\t= si476x_core_cmd_fm_phase_diversity,\n\t\t.phase_div_status\t= si476x_core_cmd_fm_phase_div_status,\n\t\t.acf_status\t\t= si476x_core_cmd_fm_acf_status,\n\t\t.agc_status\t\t= si476x_core_cmd_agc_status,\n\t};\n\n\tstatic const struct si476x_radio_ops am_ops = {\n\t\t.tune_freq\t\t= si476x_core_cmd_am_tune_freq,\n\t\t.seek_start\t\t= si476x_core_cmd_am_seek_start,\n\t\t.rsq_status\t\t= si476x_core_cmd_am_rsq_status,\n\t\t.rds_blckcnt\t\t= NULL,\n\t\t.phase_diversity\t= NULL,\n\t\t.phase_div_status\t= NULL,\n\t\t.acf_status\t\t= si476x_core_cmd_am_acf_status,\n\t\t.agc_status\t\t= NULL,\n\t};\n\n\tswitch (func) {\n\tcase SI476X_FUNC_FM_RECEIVER:\n\t\tradio->ops = &fm_ops;\n\t\treturn 0;\n\n\tcase SI476X_FUNC_AM_RECEIVER:\n\t\tradio->ops = &am_ops;\n\t\treturn 0;\n\tdefault:\n\t\tWARN(1, \"Unexpected tuner function value\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int si476x_radio_pretune(struct si476x_radio *radio,\n\t\t\t\tenum si476x_func func)\n{\n\tint retval;\n\n\tstruct si476x_tune_freq_args args = {\n\t\t.zifsr\t\t= false,\n\t\t.hd\t\t= false,\n\t\t.injside\t= SI476X_INJSIDE_AUTO,\n\t\t.tunemode\t= SI476X_TM_VALIDATED_NORMAL_TUNE,\n\t\t.smoothmetrics\t= SI476X_SM_INITIALIZE_AUDIO,\n\t\t.antcap\t\t= 0,\n\t};\n\n\tswitch (func) {\n\tcase SI476X_FUNC_FM_RECEIVER:\n\t\targs.freq = v4l2_to_si476x(radio->core,\n\t\t\t\t\t   92 * FREQ_MUL);\n\t\tretval = radio->ops->tune_freq(radio->core, &args);\n\t\tbreak;\n\tcase SI476X_FUNC_AM_RECEIVER:\n\t\targs.freq = v4l2_to_si476x(radio->core,\n\t\t\t\t\t   0.6 * FREQ_MUL);\n\t\tretval = radio->ops->tune_freq(radio->core, &args);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Unexpected tuner function value\\n\");\n\t\tretval = -EINVAL;\n\t}\n\n\treturn retval;\n}\nstatic int si476x_radio_do_post_powerup_init(struct si476x_radio *radio,\n\t\t\t\t\t     enum si476x_func func)\n{\n\tint err;\n\n\t \n\terr = regcache_sync_region(radio->core->regmap,\n\t\t\t\t   SI476X_PROP_DIGITAL_IO_INPUT_SAMPLE_RATE,\n\t\t\t\t   SI476X_PROP_DIGITAL_IO_OUTPUT_FORMAT);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = regcache_sync_region(radio->core->regmap,\n\t\t\t\t   SI476X_PROP_AUDIO_DEEMPHASIS,\n\t\t\t\t   SI476X_PROP_AUDIO_PWR_LINE_FILTER);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = regcache_sync_region(radio->core->regmap,\n\t\t\t\t   SI476X_PROP_INT_CTL_ENABLE,\n\t\t\t\t   SI476X_PROP_INT_CTL_ENABLE);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = regcache_sync_region(radio->core->regmap,\n\t\t\t\t   SI476X_PROP_VALID_MAX_TUNE_ERROR,\n\t\t\t\t   SI476X_PROP_VALID_MAX_TUNE_ERROR);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = regcache_sync_region(radio->core->regmap,\n\t\t\t\t   SI476X_PROP_VALID_SNR_THRESHOLD,\n\t\t\t\t   SI476X_PROP_VALID_RSSI_THRESHOLD);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (func == SI476X_FUNC_FM_RECEIVER) {\n\t\tif (si476x_core_has_diversity(radio->core)) {\n\t\t\terr = si476x_core_cmd_fm_phase_diversity(radio->core,\n\t\t\t\t\t\t\t\t radio->core->diversity_mode);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\terr = regcache_sync_region(radio->core->regmap,\n\t\t\t\t\t   SI476X_PROP_FM_RDS_INTERRUPT_SOURCE,\n\t\t\t\t\t   SI476X_PROP_FM_RDS_CONFIG);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn si476x_radio_init_vtable(radio, func);\n\n}\n\nstatic int si476x_radio_change_func(struct si476x_radio *radio,\n\t\t\t\t    enum si476x_func func)\n{\n\tint err;\n\tbool soft;\n\t \n\tif (func == radio->core->power_up_parameters.func)\n\t\treturn 0;\n\n\tsoft = true;\n\terr = si476x_core_stop(radio->core, soft);\n\tif (err < 0) {\n\t\t \n\t\tsoft = false;\n\t\terr = si476x_core_stop(radio->core, soft);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\t \n\tradio->core->power_up_parameters.func = func;\n\n\terr = si476x_core_start(radio->core, soft);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (func != SI476X_FUNC_FM_RECEIVER &&\n\t    func != SI476X_FUNC_AM_RECEIVER)\n\t\treturn err;\n\n\treturn si476x_radio_do_post_powerup_init(radio, func);\n}\n\nstatic int si476x_radio_g_frequency(struct file *file, void *priv,\n\t\t\t      struct v4l2_frequency *f)\n{\n\tint err;\n\tstruct si476x_radio *radio = video_drvdata(file);\n\n\tif (f->tuner != 0 ||\n\t    f->type  != V4L2_TUNER_RADIO)\n\t\treturn -EINVAL;\n\n\tsi476x_core_lock(radio->core);\n\n\tif (radio->ops->rsq_status) {\n\t\tstruct si476x_rsq_status_report report;\n\t\tstruct si476x_rsq_status_args   args = {\n\t\t\t.primary\t= false,\n\t\t\t.rsqack\t\t= false,\n\t\t\t.attune\t\t= true,\n\t\t\t.cancel\t\t= false,\n\t\t\t.stcack\t\t= false,\n\t\t};\n\n\t\terr = radio->ops->rsq_status(radio->core, &args, &report);\n\t\tif (!err)\n\t\t\tf->frequency = si476x_to_v4l2(radio->core,\n\t\t\t\t\t\t      report.readfreq);\n\t} else {\n\t\terr = -EINVAL;\n\t}\n\n\tsi476x_core_unlock(radio->core);\n\n\treturn err;\n}\n\nstatic int si476x_radio_s_frequency(struct file *file, void *priv,\n\t\t\t\t    const struct v4l2_frequency *f)\n{\n\tint err;\n\tu32 freq = f->frequency;\n\tstruct si476x_tune_freq_args args;\n\tstruct si476x_radio *radio = video_drvdata(file);\n\n\tconst u32 midrange = (si476x_bands[SI476X_BAND_AM].rangehigh +\n\t\t\t      si476x_bands[SI476X_BAND_FM].rangelow) / 2;\n\tconst int band = (freq > midrange) ?\n\t\tSI476X_BAND_FM : SI476X_BAND_AM;\n\tconst enum si476x_func func = (band == SI476X_BAND_AM) ?\n\t\tSI476X_FUNC_AM_RECEIVER : SI476X_FUNC_FM_RECEIVER;\n\n\tif (f->tuner != 0 ||\n\t    f->type  != V4L2_TUNER_RADIO)\n\t\treturn -EINVAL;\n\n\tsi476x_core_lock(radio->core);\n\n\tfreq = clamp(freq,\n\t\t     si476x_bands[band].rangelow,\n\t\t     si476x_bands[band].rangehigh);\n\n\tif (si476x_radio_freq_is_inside_of_the_band(freq,\n\t\t\t\t\t\t    SI476X_BAND_AM) &&\n\t    (!si476x_core_has_am(radio->core) ||\n\t     si476x_core_is_a_secondary_tuner(radio->core))) {\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\terr = si476x_radio_change_func(radio, func);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\targs.zifsr\t\t= false;\n\targs.hd\t\t\t= false;\n\targs.injside\t\t= SI476X_INJSIDE_AUTO;\n\targs.freq\t\t= v4l2_to_si476x(radio->core, freq);\n\targs.tunemode\t\t= SI476X_TM_VALIDATED_NORMAL_TUNE;\n\targs.smoothmetrics\t= SI476X_SM_INITIALIZE_AUDIO;\n\targs.antcap\t\t= 0;\n\n\terr = radio->ops->tune_freq(radio->core, &args);\n\nunlock:\n\tsi476x_core_unlock(radio->core);\n\treturn err;\n}\n\nstatic int si476x_radio_s_hw_freq_seek(struct file *file, void *priv,\n\t\t\t\t       const struct v4l2_hw_freq_seek *seek)\n{\n\tint err;\n\tenum si476x_func func;\n\tu32 rangelow = seek->rangelow, rangehigh = seek->rangehigh;\n\tstruct si476x_radio *radio = video_drvdata(file);\n\n\tif (file->f_flags & O_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tif (seek->tuner != 0 ||\n\t    seek->type  != V4L2_TUNER_RADIO)\n\t\treturn -EINVAL;\n\n\tsi476x_core_lock(radio->core);\n\n\tif (!rangelow) {\n\t\terr = regmap_read(radio->core->regmap,\n\t\t\t\t  SI476X_PROP_SEEK_BAND_BOTTOM,\n\t\t\t\t  &rangelow);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\trangelow = si476x_to_v4l2(radio->core, rangelow);\n\t}\n\tif (!rangehigh) {\n\t\terr = regmap_read(radio->core->regmap,\n\t\t\t\t  SI476X_PROP_SEEK_BAND_TOP,\n\t\t\t\t  &rangehigh);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\trangehigh = si476x_to_v4l2(radio->core, rangehigh);\n\t}\n\n\tif (rangelow > rangehigh) {\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (si476x_radio_range_is_inside_of_the_band(rangelow, rangehigh,\n\t\t\t\t\t\t     SI476X_BAND_FM)) {\n\t\tfunc = SI476X_FUNC_FM_RECEIVER;\n\n\t} else if (si476x_core_has_am(radio->core) &&\n\t\t   si476x_radio_range_is_inside_of_the_band(rangelow, rangehigh,\n\t\t\t\t\t\t\t    SI476X_BAND_AM)) {\n\t\tfunc = SI476X_FUNC_AM_RECEIVER;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\terr = si476x_radio_change_func(radio, func);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tif (seek->rangehigh) {\n\t\terr = regmap_write(radio->core->regmap,\n\t\t\t\t   SI476X_PROP_SEEK_BAND_TOP,\n\t\t\t\t   v4l2_to_si476x(radio->core,\n\t\t\t\t\t\t  seek->rangehigh));\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\tif (seek->rangelow) {\n\t\terr = regmap_write(radio->core->regmap,\n\t\t\t\t   SI476X_PROP_SEEK_BAND_BOTTOM,\n\t\t\t\t   v4l2_to_si476x(radio->core,\n\t\t\t\t\t\t  seek->rangelow));\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\tif (seek->spacing) {\n\t\terr = regmap_write(radio->core->regmap,\n\t\t\t\t     SI476X_PROP_SEEK_FREQUENCY_SPACING,\n\t\t\t\t     v4l2_to_si476x(radio->core,\n\t\t\t\t\t\t    seek->spacing));\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\terr = radio->ops->seek_start(radio->core,\n\t\t\t\t     seek->seek_upward,\n\t\t\t\t     seek->wrap_around);\nunlock:\n\tsi476x_core_unlock(radio->core);\n\n\n\n\treturn err;\n}\n\nstatic int si476x_radio_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tint retval;\n\tstruct si476x_radio *radio = v4l2_ctrl_handler_to_radio(ctrl->handler);\n\n\tsi476x_core_lock(radio->core);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_SI476X_INTERCHIP_LINK:\n\t\tif (si476x_core_has_diversity(radio->core)) {\n\t\t\tif (radio->ops->phase_diversity) {\n\t\t\t\tretval = radio->ops->phase_div_status(radio->core);\n\t\t\t\tif (retval < 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tctrl->val = !!SI476X_PHDIV_STATUS_LINK_LOCKED(retval);\n\t\t\t\tretval = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tretval = -ENOTTY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tretval = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tretval = -EINVAL;\n\t\tbreak;\n\t}\n\tsi476x_core_unlock(radio->core);\n\treturn retval;\n\n}\n\nstatic int si476x_radio_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tint retval;\n\tenum si476x_phase_diversity_mode mode;\n\tstruct si476x_radio *radio = v4l2_ctrl_handler_to_radio(ctrl->handler);\n\n\tsi476x_core_lock(radio->core);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_SI476X_HARMONICS_COUNT:\n\t\tretval = regmap_update_bits(radio->core->regmap,\n\t\t\t\t\t    SI476X_PROP_AUDIO_PWR_LINE_FILTER,\n\t\t\t\t\t    SI476X_PROP_PWR_HARMONICS_MASK,\n\t\t\t\t\t    ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_POWER_LINE_FREQUENCY:\n\t\tswitch (ctrl->val) {\n\t\tcase V4L2_CID_POWER_LINE_FREQUENCY_DISABLED:\n\t\t\tretval = regmap_update_bits(radio->core->regmap,\n\t\t\t\t\t\t    SI476X_PROP_AUDIO_PWR_LINE_FILTER,\n\t\t\t\t\t\t    SI476X_PROP_PWR_ENABLE_MASK,\n\t\t\t\t\t\t    0);\n\t\t\tbreak;\n\t\tcase V4L2_CID_POWER_LINE_FREQUENCY_50HZ:\n\t\t\tretval = regmap_update_bits(radio->core->regmap,\n\t\t\t\t\t\t    SI476X_PROP_AUDIO_PWR_LINE_FILTER,\n\t\t\t\t\t\t    SI476X_PROP_PWR_GRID_MASK,\n\t\t\t\t\t\t    SI476X_PROP_PWR_GRID_50HZ);\n\t\t\tbreak;\n\t\tcase V4L2_CID_POWER_LINE_FREQUENCY_60HZ:\n\t\t\tretval = regmap_update_bits(radio->core->regmap,\n\t\t\t\t\t\t    SI476X_PROP_AUDIO_PWR_LINE_FILTER,\n\t\t\t\t\t\t    SI476X_PROP_PWR_GRID_MASK,\n\t\t\t\t\t\t    SI476X_PROP_PWR_GRID_60HZ);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tretval = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_SI476X_RSSI_THRESHOLD:\n\t\tretval = regmap_write(radio->core->regmap,\n\t\t\t\t      SI476X_PROP_VALID_RSSI_THRESHOLD,\n\t\t\t\t      ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SI476X_SNR_THRESHOLD:\n\t\tretval = regmap_write(radio->core->regmap,\n\t\t\t\t      SI476X_PROP_VALID_SNR_THRESHOLD,\n\t\t\t\t      ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SI476X_MAX_TUNE_ERROR:\n\t\tretval = regmap_write(radio->core->regmap,\n\t\t\t\t      SI476X_PROP_VALID_MAX_TUNE_ERROR,\n\t\t\t\t      ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_RDS_RECEPTION:\n\t\t \n\t\tif (si476x_core_is_in_am_receiver_mode(radio->core))\n\t\t\tregcache_cache_only(radio->core->regmap, true);\n\n\t\tif (ctrl->val) {\n\t\t\tretval = regmap_write(radio->core->regmap,\n\t\t\t\t\t      SI476X_PROP_FM_RDS_INTERRUPT_FIFO_COUNT,\n\t\t\t\t\t      radio->core->rds_fifo_depth);\n\t\t\tif (retval < 0)\n\t\t\t\tbreak;\n\n\t\t\tif (radio->core->client->irq) {\n\t\t\t\tretval = regmap_write(radio->core->regmap,\n\t\t\t\t\t\t      SI476X_PROP_FM_RDS_INTERRUPT_SOURCE,\n\t\t\t\t\t\t      SI476X_RDSRECV);\n\t\t\t\tif (retval < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tretval = si476x_core_cmd_fm_rds_status(radio->core,\n\t\t\t\t\t\t\t       false,\n\t\t\t\t\t\t\t       true,\n\t\t\t\t\t\t\t       true,\n\t\t\t\t\t\t\t       NULL);\n\t\t\tif (retval < 0)\n\t\t\t\tbreak;\n\n\t\t\tretval = regmap_update_bits(radio->core->regmap,\n\t\t\t\t\t\t    SI476X_PROP_FM_RDS_CONFIG,\n\t\t\t\t\t\t    SI476X_PROP_RDSEN_MASK,\n\t\t\t\t\t\t    SI476X_PROP_RDSEN);\n\t\t} else {\n\t\t\tretval = regmap_update_bits(radio->core->regmap,\n\t\t\t\t\t\t    SI476X_PROP_FM_RDS_CONFIG,\n\t\t\t\t\t\t    SI476X_PROP_RDSEN_MASK,\n\t\t\t\t\t\t    !SI476X_PROP_RDSEN);\n\t\t}\n\n\t\tif (si476x_core_is_in_am_receiver_mode(radio->core))\n\t\t\tregcache_cache_only(radio->core->regmap, false);\n\t\tbreak;\n\tcase V4L2_CID_TUNE_DEEMPHASIS:\n\t\tretval = regmap_write(radio->core->regmap,\n\t\t\t\t      SI476X_PROP_AUDIO_DEEMPHASIS,\n\t\t\t\t      ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_SI476X_DIVERSITY_MODE:\n\t\tmode = si476x_phase_diversity_idx_to_mode(ctrl->val);\n\n\t\tif (mode == radio->core->diversity_mode) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (si476x_core_is_in_am_receiver_mode(radio->core)) {\n\t\t\t \n\t\t\tradio->core->diversity_mode = mode;\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tretval = radio->ops->phase_diversity(radio->core, mode);\n\t\t\tif (!retval)\n\t\t\t\tradio->core->diversity_mode = mode;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tretval = -EINVAL;\n\t\tbreak;\n\t}\n\n\tsi476x_core_unlock(radio->core);\n\n\treturn retval;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int si476x_radio_g_register(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_dbg_register *reg)\n{\n\tint err;\n\tunsigned int value;\n\tstruct si476x_radio *radio = video_drvdata(file);\n\n\tsi476x_core_lock(radio->core);\n\treg->size = 2;\n\terr = regmap_read(radio->core->regmap,\n\t\t\t  (unsigned int)reg->reg, &value);\n\treg->val = value;\n\tsi476x_core_unlock(radio->core);\n\n\treturn err;\n}\nstatic int si476x_radio_s_register(struct file *file, void *fh,\n\t\t\t\t   const struct v4l2_dbg_register *reg)\n{\n\n\tint err;\n\tstruct si476x_radio *radio = video_drvdata(file);\n\n\tsi476x_core_lock(radio->core);\n\terr = regmap_write(radio->core->regmap,\n\t\t\t   (unsigned int)reg->reg,\n\t\t\t   (unsigned int)reg->val);\n\tsi476x_core_unlock(radio->core);\n\n\treturn err;\n}\n#endif\n\nstatic int si476x_radio_fops_open(struct file *file)\n{\n\tstruct si476x_radio *radio = video_drvdata(file);\n\tint err;\n\n\terr = v4l2_fh_open(file);\n\tif (err)\n\t\treturn err;\n\n\tif (v4l2_fh_is_singular_file(file)) {\n\t\tsi476x_core_lock(radio->core);\n\t\terr = si476x_core_set_power_state(radio->core,\n\t\t\t\t\t\t  SI476X_POWER_UP_FULL);\n\t\tif (err < 0)\n\t\t\tgoto done;\n\n\t\terr = si476x_radio_do_post_powerup_init(radio,\n\t\t\t\t\t\t\tradio->core->power_up_parameters.func);\n\t\tif (err < 0)\n\t\t\tgoto power_down;\n\n\t\terr = si476x_radio_pretune(radio,\n\t\t\t\t\t   radio->core->power_up_parameters.func);\n\t\tif (err < 0)\n\t\t\tgoto power_down;\n\n\t\tsi476x_core_unlock(radio->core);\n\t\t \n\t\tv4l2_ctrl_handler_setup(&radio->ctrl_handler);\n\t}\n\n\treturn err;\n\npower_down:\n\tsi476x_core_set_power_state(radio->core,\n\t\t\t\t    SI476X_POWER_DOWN);\ndone:\n\tsi476x_core_unlock(radio->core);\n\tv4l2_fh_release(file);\n\n\treturn err;\n}\n\nstatic int si476x_radio_fops_release(struct file *file)\n{\n\tstruct si476x_radio *radio = video_drvdata(file);\n\n\tif (v4l2_fh_is_singular_file(file) &&\n\t    atomic_read(&radio->core->is_alive))\n\t\tsi476x_core_set_power_state(radio->core,\n\t\t\t\t\t    SI476X_POWER_DOWN);\n\n\treturn v4l2_fh_release(file);\n}\n\nstatic ssize_t si476x_radio_fops_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tssize_t      rval;\n\tsize_t       fifo_len;\n\tunsigned int copied;\n\n\tstruct si476x_radio *radio = video_drvdata(file);\n\n\t \n\tif (kfifo_is_empty(&radio->core->rds_fifo)) {\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EWOULDBLOCK;\n\n\t\trval = wait_event_interruptible(radio->core->rds_read_queue,\n\t\t\t\t\t\t(!kfifo_is_empty(&radio->core->rds_fifo) ||\n\t\t\t\t\t\t !atomic_read(&radio->core->is_alive)));\n\t\tif (rval < 0)\n\t\t\treturn -EINTR;\n\n\t\tif (!atomic_read(&radio->core->is_alive))\n\t\t\treturn -ENODEV;\n\t}\n\n\tfifo_len = kfifo_len(&radio->core->rds_fifo);\n\n\tif (kfifo_to_user(&radio->core->rds_fifo, buf,\n\t\t\t  min(fifo_len, count),\n\t\t\t  &copied) != 0) {\n\t\tdev_warn(&radio->videodev.dev,\n\t\t\t \"Error during FIFO to userspace copy\\n\");\n\t\trval = -EIO;\n\t} else {\n\t\trval = (ssize_t)copied;\n\t}\n\n\treturn rval;\n}\n\nstatic __poll_t si476x_radio_fops_poll(struct file *file,\n\t\t\t\tstruct poll_table_struct *pts)\n{\n\tstruct si476x_radio *radio = video_drvdata(file);\n\t__poll_t req_events = poll_requested_events(pts);\n\t__poll_t err = v4l2_ctrl_poll(file, pts);\n\n\tif (req_events & (EPOLLIN | EPOLLRDNORM)) {\n\t\tif (atomic_read(&radio->core->is_alive))\n\t\t\tpoll_wait(file, &radio->core->rds_read_queue, pts);\n\n\t\tif (!atomic_read(&radio->core->is_alive))\n\t\t\terr = EPOLLHUP;\n\n\t\tif (!kfifo_is_empty(&radio->core->rds_fifo))\n\t\t\terr = EPOLLIN | EPOLLRDNORM;\n\t}\n\n\treturn err;\n}\n\nstatic const struct v4l2_file_operations si476x_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.read\t\t\t= si476x_radio_fops_read,\n\t.poll\t\t\t= si476x_radio_fops_poll,\n\t.unlocked_ioctl\t\t= video_ioctl2,\n\t.open\t\t\t= si476x_radio_fops_open,\n\t.release\t\t= si476x_radio_fops_release,\n};\n\n\nstatic const struct v4l2_ioctl_ops si4761_ioctl_ops = {\n\t.vidioc_querycap\t\t= si476x_radio_querycap,\n\t.vidioc_g_tuner\t\t\t= si476x_radio_g_tuner,\n\t.vidioc_s_tuner\t\t\t= si476x_radio_s_tuner,\n\n\t.vidioc_g_frequency\t\t= si476x_radio_g_frequency,\n\t.vidioc_s_frequency\t\t= si476x_radio_s_frequency,\n\t.vidioc_s_hw_freq_seek\t\t= si476x_radio_s_hw_freq_seek,\n\t.vidioc_enum_freq_bands\t\t= si476x_radio_enum_freq_bands,\n\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_register\t\t= si476x_radio_g_register,\n\t.vidioc_s_register\t\t= si476x_radio_s_register,\n#endif\n};\n\n\nstatic const struct video_device si476x_viddev_template = {\n\t.fops\t\t\t= &si476x_fops,\n\t.name\t\t\t= DRIVER_NAME,\n\t.release\t\t= video_device_release_empty,\n};\n\n\n\nstatic ssize_t si476x_radio_read_acf_blob(struct file *file,\n\t\t\t\t\t  char __user *user_buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tint err;\n\tstruct si476x_radio *radio = file->private_data;\n\tstruct si476x_acf_status_report report;\n\n\tsi476x_core_lock(radio->core);\n\tif (radio->ops->acf_status)\n\t\terr = radio->ops->acf_status(radio->core, &report);\n\telse\n\t\terr = -ENOENT;\n\tsi476x_core_unlock(radio->core);\n\n\tif (err < 0)\n\t\treturn err;\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, &report,\n\t\t\t\t       sizeof(report));\n}\n\nstatic const struct file_operations radio_acf_fops = {\n\t.open\t= simple_open,\n\t.llseek = default_llseek,\n\t.read\t= si476x_radio_read_acf_blob,\n};\n\nstatic ssize_t si476x_radio_read_rds_blckcnt_blob(struct file *file,\n\t\t\t\t\t\t  char __user *user_buf,\n\t\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tint err;\n\tstruct si476x_radio *radio = file->private_data;\n\tstruct si476x_rds_blockcount_report report;\n\n\tsi476x_core_lock(radio->core);\n\tif (radio->ops->rds_blckcnt)\n\t\terr = radio->ops->rds_blckcnt(radio->core, true,\n\t\t\t\t\t       &report);\n\telse\n\t\terr = -ENOENT;\n\tsi476x_core_unlock(radio->core);\n\n\tif (err < 0)\n\t\treturn err;\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, &report,\n\t\t\t\t       sizeof(report));\n}\n\nstatic const struct file_operations radio_rds_blckcnt_fops = {\n\t.open\t= simple_open,\n\t.llseek = default_llseek,\n\t.read\t= si476x_radio_read_rds_blckcnt_blob,\n};\n\nstatic ssize_t si476x_radio_read_agc_blob(struct file *file,\n\t\t\t\t\t  char __user *user_buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tint err;\n\tstruct si476x_radio *radio = file->private_data;\n\tstruct si476x_agc_status_report report;\n\n\tsi476x_core_lock(radio->core);\n\tif (radio->ops->rds_blckcnt)\n\t\terr = radio->ops->agc_status(radio->core, &report);\n\telse\n\t\terr = -ENOENT;\n\tsi476x_core_unlock(radio->core);\n\n\tif (err < 0)\n\t\treturn err;\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, &report,\n\t\t\t\t       sizeof(report));\n}\n\nstatic const struct file_operations radio_agc_fops = {\n\t.open\t= simple_open,\n\t.llseek = default_llseek,\n\t.read\t= si476x_radio_read_agc_blob,\n};\n\nstatic ssize_t si476x_radio_read_rsq_blob(struct file *file,\n\t\t\t\t\t  char __user *user_buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tint err;\n\tstruct si476x_radio *radio = file->private_data;\n\tstruct si476x_rsq_status_report report;\n\tstruct si476x_rsq_status_args args = {\n\t\t.primary\t= false,\n\t\t.rsqack\t\t= false,\n\t\t.attune\t\t= false,\n\t\t.cancel\t\t= false,\n\t\t.stcack\t\t= false,\n\t};\n\n\tsi476x_core_lock(radio->core);\n\tif (radio->ops->rds_blckcnt)\n\t\terr = radio->ops->rsq_status(radio->core, &args, &report);\n\telse\n\t\terr = -ENOENT;\n\tsi476x_core_unlock(radio->core);\n\n\tif (err < 0)\n\t\treturn err;\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, &report,\n\t\t\t\t       sizeof(report));\n}\n\nstatic const struct file_operations radio_rsq_fops = {\n\t.open\t= simple_open,\n\t.llseek = default_llseek,\n\t.read\t= si476x_radio_read_rsq_blob,\n};\n\nstatic ssize_t si476x_radio_read_rsq_primary_blob(struct file *file,\n\t\t\t\t\t\t  char __user *user_buf,\n\t\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tint err;\n\tstruct si476x_radio *radio = file->private_data;\n\tstruct si476x_rsq_status_report report;\n\tstruct si476x_rsq_status_args args = {\n\t\t.primary\t= true,\n\t\t.rsqack\t\t= false,\n\t\t.attune\t\t= false,\n\t\t.cancel\t\t= false,\n\t\t.stcack\t\t= false,\n\t};\n\n\tsi476x_core_lock(radio->core);\n\tif (radio->ops->rds_blckcnt)\n\t\terr = radio->ops->rsq_status(radio->core, &args, &report);\n\telse\n\t\terr = -ENOENT;\n\tsi476x_core_unlock(radio->core);\n\n\tif (err < 0)\n\t\treturn err;\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, &report,\n\t\t\t\t       sizeof(report));\n}\n\nstatic const struct file_operations radio_rsq_primary_fops = {\n\t.open\t= simple_open,\n\t.llseek = default_llseek,\n\t.read\t= si476x_radio_read_rsq_primary_blob,\n};\n\n\nstatic void si476x_radio_init_debugfs(struct si476x_radio *radio)\n{\n\tradio->debugfs = debugfs_create_dir(dev_name(radio->v4l2dev.dev), NULL);\n\n\tdebugfs_create_file(\"acf\", S_IRUGO, radio->debugfs, radio,\n\t\t\t    &radio_acf_fops);\n\n\tdebugfs_create_file(\"rds_blckcnt\", S_IRUGO, radio->debugfs, radio,\n\t\t\t    &radio_rds_blckcnt_fops);\n\n\tdebugfs_create_file(\"agc\", S_IRUGO, radio->debugfs, radio,\n\t\t\t    &radio_agc_fops);\n\n\tdebugfs_create_file(\"rsq\", S_IRUGO, radio->debugfs, radio,\n\t\t\t    &radio_rsq_fops);\n\n\tdebugfs_create_file(\"rsq_primary\", S_IRUGO, radio->debugfs, radio,\n\t\t\t    &radio_rsq_primary_fops);\n}\n\n\nstatic int si476x_radio_add_new_custom(struct si476x_radio *radio,\n\t\t\t\t       enum si476x_ctrl_idx idx)\n{\n\tint rval;\n\tstruct v4l2_ctrl *ctrl;\n\n\tctrl = v4l2_ctrl_new_custom(&radio->ctrl_handler,\n\t\t\t\t    &si476x_ctrls[idx],\n\t\t\t\t    NULL);\n\trval = radio->ctrl_handler.error;\n\tif (ctrl == NULL && rval)\n\t\tdev_err(radio->v4l2dev.dev,\n\t\t\t\"Could not initialize '%s' control %d\\n\",\n\t\t\tsi476x_ctrls[idx].name, rval);\n\n\treturn rval;\n}\n\nstatic int si476x_radio_probe(struct platform_device *pdev)\n{\n\tint rval;\n\tstruct si476x_radio *radio;\n\tstruct v4l2_ctrl *ctrl;\n\n\tstatic atomic_t instance = ATOMIC_INIT(0);\n\n\tradio = devm_kzalloc(&pdev->dev, sizeof(*radio), GFP_KERNEL);\n\tif (!radio)\n\t\treturn -ENOMEM;\n\n\tradio->core = i2c_mfd_cell_to_core(&pdev->dev);\n\n\tv4l2_device_set_name(&radio->v4l2dev, DRIVER_NAME, &instance);\n\n\trval = v4l2_device_register(&pdev->dev, &radio->v4l2dev);\n\tif (rval) {\n\t\tdev_err(&pdev->dev, \"Cannot register v4l2_device.\\n\");\n\t\treturn rval;\n\t}\n\n\tmemcpy(&radio->videodev, &si476x_viddev_template,\n\t       sizeof(struct video_device));\n\n\tradio->videodev.v4l2_dev  = &radio->v4l2dev;\n\tradio->videodev.ioctl_ops = &si4761_ioctl_ops;\n\tradio->videodev.device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO |\n\t\t\t\t      V4L2_CAP_HW_FREQ_SEEK;\n\n\tsi476x_core_lock(radio->core);\n\tif (!si476x_core_is_a_secondary_tuner(radio->core))\n\t\tradio->videodev.device_caps |= V4L2_CAP_RDS_CAPTURE |\n\t\t\t\t\t       V4L2_CAP_READWRITE;\n\tsi476x_core_unlock(radio->core);\n\n\tvideo_set_drvdata(&radio->videodev, radio);\n\tplatform_set_drvdata(pdev, radio);\n\n\n\tradio->v4l2dev.ctrl_handler = &radio->ctrl_handler;\n\tv4l2_ctrl_handler_init(&radio->ctrl_handler,\n\t\t\t       1 + ARRAY_SIZE(si476x_ctrls));\n\n\tif (si476x_core_has_am(radio->core)) {\n\t\tctrl = v4l2_ctrl_new_std_menu(&radio->ctrl_handler,\n\t\t\t\t\t      &si476x_ctrl_ops,\n\t\t\t\t\t      V4L2_CID_POWER_LINE_FREQUENCY,\n\t\t\t\t\t      V4L2_CID_POWER_LINE_FREQUENCY_60HZ,\n\t\t\t\t\t      0, 0);\n\t\trval = radio->ctrl_handler.error;\n\t\tif (ctrl == NULL && rval) {\n\t\t\tdev_err(&pdev->dev, \"Could not initialize V4L2_CID_POWER_LINE_FREQUENCY control %d\\n\",\n\t\t\t\trval);\n\t\t\tgoto exit;\n\t\t}\n\n\t\trval = si476x_radio_add_new_custom(radio,\n\t\t\t\t\t\t   SI476X_IDX_HARMONICS_COUNT);\n\t\tif (rval < 0)\n\t\t\tgoto exit;\n\t}\n\n\trval = si476x_radio_add_new_custom(radio, SI476X_IDX_RSSI_THRESHOLD);\n\tif (rval < 0)\n\t\tgoto exit;\n\n\trval = si476x_radio_add_new_custom(radio, SI476X_IDX_SNR_THRESHOLD);\n\tif (rval < 0)\n\t\tgoto exit;\n\n\trval = si476x_radio_add_new_custom(radio, SI476X_IDX_MAX_TUNE_ERROR);\n\tif (rval < 0)\n\t\tgoto exit;\n\n\tctrl = v4l2_ctrl_new_std_menu(&radio->ctrl_handler,\n\t\t\t\t      &si476x_ctrl_ops,\n\t\t\t\t      V4L2_CID_TUNE_DEEMPHASIS,\n\t\t\t\t      V4L2_DEEMPHASIS_75_uS, 0, 0);\n\trval = radio->ctrl_handler.error;\n\tif (ctrl == NULL && rval) {\n\t\tdev_err(&pdev->dev, \"Could not initialize V4L2_CID_TUNE_DEEMPHASIS control %d\\n\",\n\t\t\trval);\n\t\tgoto exit;\n\t}\n\n\tctrl = v4l2_ctrl_new_std(&radio->ctrl_handler, &si476x_ctrl_ops,\n\t\t\t\t V4L2_CID_RDS_RECEPTION,\n\t\t\t\t 0, 1, 1, 1);\n\trval = radio->ctrl_handler.error;\n\tif (ctrl == NULL && rval) {\n\t\tdev_err(&pdev->dev, \"Could not initialize V4L2_CID_RDS_RECEPTION control %d\\n\",\n\t\t\trval);\n\t\tgoto exit;\n\t}\n\n\tif (si476x_core_has_diversity(radio->core)) {\n\t\tsi476x_ctrls[SI476X_IDX_DIVERSITY_MODE].def =\n\t\t\tsi476x_phase_diversity_mode_to_idx(radio->core->diversity_mode);\n\t\trval = si476x_radio_add_new_custom(radio, SI476X_IDX_DIVERSITY_MODE);\n\t\tif (rval < 0)\n\t\t\tgoto exit;\n\n\t\trval = si476x_radio_add_new_custom(radio, SI476X_IDX_INTERCHIP_LINK);\n\t\tif (rval < 0)\n\t\t\tgoto exit;\n\t}\n\n\t \n\trval = video_register_device(&radio->videodev, VFL_TYPE_RADIO, -1);\n\tif (rval < 0) {\n\t\tdev_err(&pdev->dev, \"Could not register video device\\n\");\n\t\tgoto exit;\n\t}\n\n\tsi476x_radio_init_debugfs(radio);\n\n\treturn 0;\nexit:\n\tv4l2_ctrl_handler_free(radio->videodev.ctrl_handler);\n\treturn rval;\n}\n\nstatic void si476x_radio_remove(struct platform_device *pdev)\n{\n\tstruct si476x_radio *radio = platform_get_drvdata(pdev);\n\n\tv4l2_ctrl_handler_free(radio->videodev.ctrl_handler);\n\tvideo_unregister_device(&radio->videodev);\n\tv4l2_device_unregister(&radio->v4l2dev);\n\tdebugfs_remove_recursive(radio->debugfs);\n}\n\nMODULE_ALIAS(\"platform:si476x-radio\");\n\nstatic struct platform_driver si476x_radio_driver = {\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t},\n\t.probe\t\t= si476x_radio_probe,\n\t.remove_new\t= si476x_radio_remove,\n};\nmodule_platform_driver(si476x_radio_driver);\n\nMODULE_AUTHOR(\"Andrey Smirnov <andrew.smirnov@gmail.com>\");\nMODULE_DESCRIPTION(\"Driver for Si4761/64/68 AM/FM Radio MFD Cell\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}