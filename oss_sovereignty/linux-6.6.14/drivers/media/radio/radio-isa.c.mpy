{
  "module_name": "radio-isa.c",
  "hash_id": "a9e7797e837ec87105b9a2c5cfe640b0bba45d3ebbab9b85f24bcc61651f1119",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/radio-isa.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/videodev2.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n\n#include \"radio-isa.h\"\n\nMODULE_AUTHOR(\"Hans Verkuil\");\nMODULE_DESCRIPTION(\"A framework for ISA radio drivers.\");\nMODULE_LICENSE(\"GPL\");\n\n#define FREQ_LOW  (87U * 16000U)\n#define FREQ_HIGH (108U * 16000U)\n\nstatic int radio_isa_querycap(struct file *file, void  *priv,\n\t\t\t\t\tstruct v4l2_capability *v)\n{\n\tstruct radio_isa_card *isa = video_drvdata(file);\n\n\tstrscpy(v->driver, isa->drv->driver.driver.name, sizeof(v->driver));\n\tstrscpy(v->card, isa->drv->card, sizeof(v->card));\n\tsnprintf(v->bus_info, sizeof(v->bus_info), \"ISA:%s\", isa->v4l2_dev.name);\n\treturn 0;\n}\n\nstatic int radio_isa_g_tuner(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_tuner *v)\n{\n\tstruct radio_isa_card *isa = video_drvdata(file);\n\tconst struct radio_isa_ops *ops = isa->drv->ops;\n\n\tif (v->index > 0)\n\t\treturn -EINVAL;\n\n\tstrscpy(v->name, \"FM\", sizeof(v->name));\n\tv->type = V4L2_TUNER_RADIO;\n\tv->rangelow = FREQ_LOW;\n\tv->rangehigh = FREQ_HIGH;\n\tv->capability = V4L2_TUNER_CAP_LOW;\n\tif (isa->drv->has_stereo)\n\t\tv->capability |= V4L2_TUNER_CAP_STEREO;\n\n\tif (ops->g_rxsubchans)\n\t\tv->rxsubchans = ops->g_rxsubchans(isa);\n\telse\n\t\tv->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;\n\tv->audmode = isa->stereo ? V4L2_TUNER_MODE_STEREO : V4L2_TUNER_MODE_MONO;\n\tif (ops->g_signal)\n\t\tv->signal = ops->g_signal(isa);\n\telse\n\t\tv->signal = (v->rxsubchans & V4L2_TUNER_SUB_STEREO) ?\n\t\t\t\t\t\t\t\t0xffff : 0;\n\treturn 0;\n}\n\nstatic int radio_isa_s_tuner(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_tuner *v)\n{\n\tstruct radio_isa_card *isa = video_drvdata(file);\n\tconst struct radio_isa_ops *ops = isa->drv->ops;\n\n\tif (v->index)\n\t\treturn -EINVAL;\n\tif (ops->s_stereo) {\n\t\tisa->stereo = (v->audmode == V4L2_TUNER_MODE_STEREO);\n\t\treturn ops->s_stereo(isa, isa->stereo);\n\t}\n\treturn 0;\n}\n\nstatic int radio_isa_s_frequency(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_frequency *f)\n{\n\tstruct radio_isa_card *isa = video_drvdata(file);\n\tu32 freq = f->frequency;\n\tint res;\n\n\tif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\n\t\treturn -EINVAL;\n\tfreq = clamp(freq, FREQ_LOW, FREQ_HIGH);\n\tres = isa->drv->ops->s_frequency(isa, freq);\n\tif (res == 0)\n\t\tisa->freq = freq;\n\treturn res;\n}\n\nstatic int radio_isa_g_frequency(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_frequency *f)\n{\n\tstruct radio_isa_card *isa = video_drvdata(file);\n\n\tif (f->tuner != 0)\n\t\treturn -EINVAL;\n\tf->type = V4L2_TUNER_RADIO;\n\tf->frequency = isa->freq;\n\treturn 0;\n}\n\nstatic int radio_isa_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct radio_isa_card *isa =\n\t\tcontainer_of(ctrl->handler, struct radio_isa_card, hdl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\treturn isa->drv->ops->s_mute_volume(isa, ctrl->val,\n\t\t\t\tisa->volume ? isa->volume->val : 0);\n\t}\n\treturn -EINVAL;\n}\n\nstatic int radio_isa_log_status(struct file *file, void *priv)\n{\n\tstruct radio_isa_card *isa = video_drvdata(file);\n\n\tv4l2_info(&isa->v4l2_dev, \"I/O Port = 0x%03x\\n\", isa->io);\n\tv4l2_ctrl_handler_log_status(&isa->hdl, isa->v4l2_dev.name);\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops radio_isa_ctrl_ops = {\n\t.s_ctrl = radio_isa_s_ctrl,\n};\n\nstatic const struct v4l2_file_operations radio_isa_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= v4l2_fh_open,\n\t.release\t= v4l2_fh_release,\n\t.poll\t\t= v4l2_ctrl_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops radio_isa_ioctl_ops = {\n\t.vidioc_querycap    = radio_isa_querycap,\n\t.vidioc_g_tuner     = radio_isa_g_tuner,\n\t.vidioc_s_tuner     = radio_isa_s_tuner,\n\t.vidioc_g_frequency = radio_isa_g_frequency,\n\t.vidioc_s_frequency = radio_isa_s_frequency,\n\t.vidioc_log_status  = radio_isa_log_status,\n\t.vidioc_subscribe_event   = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nint radio_isa_match(struct device *pdev, unsigned int dev)\n{\n\tstruct radio_isa_driver *drv = pdev->platform_data;\n\n\treturn drv->probe || drv->io_params[dev] >= 0;\n}\nEXPORT_SYMBOL_GPL(radio_isa_match);\n\nstatic bool radio_isa_valid_io(const struct radio_isa_driver *drv, int io)\n{\n\tint i;\n\n\tfor (i = 0; i < drv->num_of_io_ports; i++)\n\t\tif (drv->io_ports[i] == io)\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic struct radio_isa_card *radio_isa_alloc(struct radio_isa_driver *drv,\n\t\t\t\tstruct device *pdev)\n{\n\tstruct v4l2_device *v4l2_dev;\n\tstruct radio_isa_card *isa = drv->ops->alloc();\n\tif (!isa)\n\t\treturn NULL;\n\n\tdev_set_drvdata(pdev, isa);\n\tisa->drv = drv;\n\tv4l2_dev = &isa->v4l2_dev;\n\tstrscpy(v4l2_dev->name, dev_name(pdev), sizeof(v4l2_dev->name));\n\n\treturn isa;\n}\n\nstatic int radio_isa_common_probe(struct radio_isa_card *isa,\n\t\t\t\t  struct device *pdev,\n\t\t\t\t  int radio_nr, unsigned region_size)\n{\n\tconst struct radio_isa_driver *drv = isa->drv;\n\tconst struct radio_isa_ops *ops = drv->ops;\n\tstruct v4l2_device *v4l2_dev = &isa->v4l2_dev;\n\tint res;\n\n\tif (!request_region(isa->io, region_size, v4l2_dev->name)) {\n\t\tv4l2_err(v4l2_dev, \"port 0x%x already in use\\n\", isa->io);\n\t\tkfree(isa);\n\t\treturn -EBUSY;\n\t}\n\n\tres = v4l2_device_register(pdev, v4l2_dev);\n\tif (res < 0) {\n\t\tv4l2_err(v4l2_dev, \"Could not register v4l2_device\\n\");\n\t\tgoto err_dev_reg;\n\t}\n\n\tv4l2_ctrl_handler_init(&isa->hdl, 1);\n\tisa->mute = v4l2_ctrl_new_std(&isa->hdl, &radio_isa_ctrl_ops,\n\t\t\t\tV4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\n\tif (drv->max_volume)\n\t\tisa->volume = v4l2_ctrl_new_std(&isa->hdl, &radio_isa_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_VOLUME, 0, drv->max_volume, 1,\n\t\t\tdrv->max_volume);\n\tv4l2_dev->ctrl_handler = &isa->hdl;\n\tif (isa->hdl.error) {\n\t\tres = isa->hdl.error;\n\t\tv4l2_err(v4l2_dev, \"Could not register controls\\n\");\n\t\tgoto err_hdl;\n\t}\n\tif (drv->max_volume)\n\t\tv4l2_ctrl_cluster(2, &isa->mute);\n\tv4l2_dev->ctrl_handler = &isa->hdl;\n\n\tmutex_init(&isa->lock);\n\tisa->vdev.lock = &isa->lock;\n\tstrscpy(isa->vdev.name, v4l2_dev->name, sizeof(isa->vdev.name));\n\tisa->vdev.v4l2_dev = v4l2_dev;\n\tisa->vdev.fops = &radio_isa_fops;\n\tisa->vdev.ioctl_ops = &radio_isa_ioctl_ops;\n\tisa->vdev.release = video_device_release_empty;\n\tisa->vdev.device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;\n\tvideo_set_drvdata(&isa->vdev, isa);\n\tisa->freq = FREQ_LOW;\n\tisa->stereo = drv->has_stereo;\n\n\tif (ops->init)\n\t\tres = ops->init(isa);\n\tif (!res)\n\t\tres = v4l2_ctrl_handler_setup(&isa->hdl);\n\tif (!res)\n\t\tres = ops->s_frequency(isa, isa->freq);\n\tif (!res && ops->s_stereo)\n\t\tres = ops->s_stereo(isa, isa->stereo);\n\tif (res < 0) {\n\t\tv4l2_err(v4l2_dev, \"Could not setup card\\n\");\n\t\tgoto err_hdl;\n\t}\n\tres = video_register_device(&isa->vdev, VFL_TYPE_RADIO, radio_nr);\n\n\tif (res < 0) {\n\t\tv4l2_err(v4l2_dev, \"Could not register device node\\n\");\n\t\tgoto err_hdl;\n\t}\n\n\tv4l2_info(v4l2_dev, \"Initialized radio card %s on port 0x%03x\\n\",\n\t\t\tdrv->card, isa->io);\n\treturn 0;\n\nerr_hdl:\n\tv4l2_ctrl_handler_free(&isa->hdl);\nerr_dev_reg:\n\trelease_region(isa->io, region_size);\n\tkfree(isa);\n\treturn res;\n}\n\nstatic void radio_isa_common_remove(struct radio_isa_card *isa,\n\t\t\t\t    unsigned region_size)\n{\n\tconst struct radio_isa_ops *ops = isa->drv->ops;\n\n\tops->s_mute_volume(isa, true, isa->volume ? isa->volume->cur.val : 0);\n\tvideo_unregister_device(&isa->vdev);\n\tv4l2_ctrl_handler_free(&isa->hdl);\n\tv4l2_device_unregister(&isa->v4l2_dev);\n\trelease_region(isa->io, region_size);\n\tv4l2_info(&isa->v4l2_dev, \"Removed radio card %s\\n\", isa->drv->card);\n\tkfree(isa);\n}\n\nint radio_isa_probe(struct device *pdev, unsigned int dev)\n{\n\tstruct radio_isa_driver *drv = pdev->platform_data;\n\tconst struct radio_isa_ops *ops = drv->ops;\n\tstruct v4l2_device *v4l2_dev;\n\tstruct radio_isa_card *isa;\n\n\tisa = radio_isa_alloc(drv, pdev);\n\tif (!isa)\n\t\treturn -ENOMEM;\n\tisa->io = drv->io_params[dev];\n\tv4l2_dev = &isa->v4l2_dev;\n\n\tif (drv->probe && ops->probe) {\n\t\tint i;\n\n\t\tfor (i = 0; i < drv->num_of_io_ports; ++i) {\n\t\t\tint io = drv->io_ports[i];\n\n\t\t\tif (request_region(io, drv->region_size, v4l2_dev->name)) {\n\t\t\t\tbool found = ops->probe(isa, io);\n\n\t\t\t\trelease_region(io, drv->region_size);\n\t\t\t\tif (found) {\n\t\t\t\t\tisa->io = io;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!radio_isa_valid_io(drv, isa->io)) {\n\t\tint i;\n\n\t\tif (isa->io < 0)\n\t\t\treturn -ENODEV;\n\t\tv4l2_err(v4l2_dev, \"you must set an I/O address with io=0x%03x\",\n\t\t\t\tdrv->io_ports[0]);\n\t\tfor (i = 1; i < drv->num_of_io_ports; i++)\n\t\t\tprintk(KERN_CONT \"/0x%03x\", drv->io_ports[i]);\n\t\tprintk(KERN_CONT \".\\n\");\n\t\tkfree(isa);\n\t\treturn -EINVAL;\n\t}\n\n\treturn radio_isa_common_probe(isa, pdev, drv->radio_nr_params[dev],\n\t\t\t\t\tdrv->region_size);\n}\nEXPORT_SYMBOL_GPL(radio_isa_probe);\n\nvoid radio_isa_remove(struct device *pdev, unsigned int dev)\n{\n\tstruct radio_isa_card *isa = dev_get_drvdata(pdev);\n\n\tradio_isa_common_remove(isa, isa->drv->region_size);\n}\nEXPORT_SYMBOL_GPL(radio_isa_remove);\n\n#ifdef CONFIG_PNP\nint radio_isa_pnp_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)\n{\n\tstruct pnp_driver *pnp_drv = to_pnp_driver(dev->dev.driver);\n\tstruct radio_isa_driver *drv = container_of(pnp_drv,\n\t\t\t\t\tstruct radio_isa_driver, pnp_driver);\n\tstruct radio_isa_card *isa;\n\n\tif (!pnp_port_valid(dev, 0))\n\t\treturn -ENODEV;\n\n\tisa = radio_isa_alloc(drv, &dev->dev);\n\tif (!isa)\n\t\treturn -ENOMEM;\n\n\tisa->io = pnp_port_start(dev, 0);\n\n\treturn radio_isa_common_probe(isa, &dev->dev, drv->radio_nr_params[0],\n\t\t\t\t\tpnp_port_len(dev, 0));\n}\nEXPORT_SYMBOL_GPL(radio_isa_pnp_probe);\n\nvoid radio_isa_pnp_remove(struct pnp_dev *dev)\n{\n\tstruct radio_isa_card *isa = dev_get_drvdata(&dev->dev);\n\n\tradio_isa_common_remove(isa, pnp_port_len(dev, 0));\n}\nEXPORT_SYMBOL_GPL(radio_isa_pnp_remove);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}