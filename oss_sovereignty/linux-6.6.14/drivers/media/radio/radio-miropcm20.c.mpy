{
  "module_name": "radio-miropcm20.c",
  "hash_id": "000aec9435c79b3fc21e24abbcb6471dca44c45058af3c81a2b0d331d4efa599",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/radio-miropcm20.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/videodev2.h>\n#include <linux/kthread.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-event.h>\n#include <sound/aci.h>\n\n#define RDS_DATASHIFT          2    \n#define RDS_DATAMASK        (1 << RDS_DATASHIFT)\n#define RDS_BUSYMASK        0x10    \n#define RDS_CLOCKMASK       0x08    \n#define RDS_DATA(x)         (((x) >> RDS_DATASHIFT) & 1)\n\n#define RDS_STATUS      0x01\n#define RDS_STATIONNAME 0x02\n#define RDS_TEXT        0x03\n#define RDS_ALTFREQ     0x04\n#define RDS_TIMEDATE    0x05\n#define RDS_PI_CODE     0x06\n#define RDS_PTYTATP     0x07\n#define RDS_RESET       0x08\n#define RDS_RXVALUE     0x09\n\nstatic int radio_nr = -1;\nmodule_param(radio_nr, int, 0);\nMODULE_PARM_DESC(radio_nr, \"Set radio device number (/dev/radioX).  Default: -1 (autodetect)\");\n\nstruct pcm20 {\n\tstruct v4l2_device v4l2_dev;\n\tstruct video_device vdev;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tstruct v4l2_ctrl *rds_pty;\n\tstruct v4l2_ctrl *rds_ps_name;\n\tstruct v4l2_ctrl *rds_radio_test;\n\tstruct v4l2_ctrl *rds_ta;\n\tstruct v4l2_ctrl *rds_tp;\n\tstruct v4l2_ctrl *rds_ms;\n\t \n\tstruct task_struct *kthread;\n\tunsigned long freq;\n\tu32 audmode;\n\tstruct snd_miro_aci *aci;\n\tstruct mutex lock;\n};\n\nstatic struct pcm20 pcm20_card = {\n\t.freq = 87 * 16000,\n\t.audmode = V4L2_TUNER_MODE_STEREO,\n};\n\n\nstatic int rds_waitread(struct snd_miro_aci *aci)\n{\n\tu8 byte;\n\tint i = 2000;\n\n\tdo {\n\t\tbyte = inb(aci->aci_port + ACI_REG_RDS);\n\t\ti--;\n\t} while ((byte & RDS_BUSYMASK) && i);\n\n\t \n\tudelay(1);\n\treturn i ? byte : -1;\n}\n\nstatic int rds_rawwrite(struct snd_miro_aci *aci, u8 byte)\n{\n\tif (rds_waitread(aci) >= 0) {\n\t\toutb(byte, aci->aci_port + ACI_REG_RDS);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic int rds_write(struct snd_miro_aci *aci, u8 byte)\n{\n\tu8 sendbuffer[8];\n\tint i;\n\n\tfor (i = 7; i >= 0; i--)\n\t\tsendbuffer[7 - i] = (byte & (1 << i)) ? RDS_DATAMASK : 0;\n\tsendbuffer[0] |= RDS_CLOCKMASK;\n\n\tfor (i = 0; i < 8; i++)\n\t\trds_rawwrite(aci, sendbuffer[i]);\n\treturn 0;\n}\n\nstatic int rds_readcycle_nowait(struct snd_miro_aci *aci)\n{\n\toutb(0, aci->aci_port + ACI_REG_RDS);\n\treturn rds_waitread(aci);\n}\n\nstatic int rds_readcycle(struct snd_miro_aci *aci)\n{\n\tif (rds_rawwrite(aci, 0) < 0)\n\t\treturn -1;\n\treturn rds_waitread(aci);\n}\n\nstatic int rds_ack(struct snd_miro_aci *aci)\n{\n\tint i = rds_readcycle(aci);\n\n\tif (i < 0)\n\t\treturn -1;\n\tif (i & RDS_DATAMASK)\n\t\treturn 0;   \n\treturn 1;   \n}\n\nstatic int rds_cmd(struct snd_miro_aci *aci, u8 cmd, u8 databuffer[], u8 datasize)\n{\n\tint i, j;\n\n\trds_write(aci, cmd);\n\n\t \n\tif (cmd == RDS_RESET)\n\t\treturn 0;\n\tif (rds_ack(aci))\n\t\treturn -EIO;\n\tif (datasize == 0)\n\t\treturn 0;\n\n\t \n\tif (rds_waitread(aci) < 0)\n\t\treturn -1;\n\n\tmemset(databuffer, 0, datasize);\n\n\tfor (i = 0; i < 8 * datasize; i++) {\n\t\tj = rds_readcycle_nowait(aci);\n\t\tif (j < 0)\n\t\t\treturn -EIO;\n\t\tdatabuffer[i / 8] |= RDS_DATA(j) << (7 - (i % 8));\n\t}\n\treturn 0;\n}\n\nstatic int pcm20_setfreq(struct pcm20 *dev, unsigned long freq)\n{\n\tunsigned char freql;\n\tunsigned char freqh;\n\tstruct snd_miro_aci *aci = dev->aci;\n\n\tfreq /= 160;\n\tif (!(aci->aci_version == 0x07 || aci->aci_version >= 0xb0))\n\t\tfreq /= 10;   \n\tfreql = freq & 0xff;\n\tfreqh = freq >> 8;\n\n\trds_cmd(aci, RDS_RESET, NULL, 0);\n\treturn snd_aci_cmd(aci, ACI_WRITE_TUNE, freql, freqh);\n}\n\nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_capability *v)\n{\n\tstruct pcm20 *dev = video_drvdata(file);\n\n\tstrscpy(v->driver, \"Miro PCM20\", sizeof(v->driver));\n\tstrscpy(v->card, \"Miro PCM20\", sizeof(v->card));\n\tsnprintf(v->bus_info, sizeof(v->bus_info), \"ISA:%s\", dev->v4l2_dev.name);\n\treturn 0;\n}\n\nstatic bool sanitize(char *p, int size)\n{\n\tint i;\n\tbool ret = true;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (p[i] < 32) {\n\t\t\tp[i] = ' ';\n\t\t\tret = false;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int vidioc_g_tuner(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_tuner *v)\n{\n\tstruct pcm20 *dev = video_drvdata(file);\n\tint res;\n\tu8 buf;\n\n\tif (v->index)\n\t\treturn -EINVAL;\n\tstrscpy(v->name, \"FM\", sizeof(v->name));\n\tv->type = V4L2_TUNER_RADIO;\n\tv->rangelow = 87*16000;\n\tv->rangehigh = 108*16000;\n\tres = snd_aci_cmd(dev->aci, ACI_READ_TUNERSTATION, -1, -1);\n\tv->signal = (res & 0x80) ? 0 : 0xffff;\n\t \n\tres = snd_aci_cmd(dev->aci, ACI_READ_TUNERSTEREO, -1, -1);\n\tv->rxsubchans = (res & 0x40) ? V4L2_TUNER_SUB_MONO :\n\t\t\t\t\tV4L2_TUNER_SUB_STEREO;\n\tv->capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO |\n\t\t\tV4L2_TUNER_CAP_RDS | V4L2_TUNER_CAP_RDS_CONTROLS;\n\tv->audmode = dev->audmode;\n\tres = rds_cmd(dev->aci, RDS_RXVALUE, &buf, 1);\n\tif (res >= 0 && buf)\n\t\tv->rxsubchans |= V4L2_TUNER_SUB_RDS;\n\treturn 0;\n}\n\nstatic int vidioc_s_tuner(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_tuner *v)\n{\n\tstruct pcm20 *dev = video_drvdata(file);\n\n\tif (v->index)\n\t\treturn -EINVAL;\n\tif (v->audmode > V4L2_TUNER_MODE_STEREO)\n\t\tdev->audmode = V4L2_TUNER_MODE_STEREO;\n\telse\n\t\tdev->audmode = v->audmode;\n\tsnd_aci_cmd(dev->aci, ACI_SET_TUNERMONO,\n\t\t\tdev->audmode == V4L2_TUNER_MODE_MONO, -1);\n\treturn 0;\n}\n\nstatic int vidioc_g_frequency(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_frequency *f)\n{\n\tstruct pcm20 *dev = video_drvdata(file);\n\n\tif (f->tuner != 0)\n\t\treturn -EINVAL;\n\n\tf->type = V4L2_TUNER_RADIO;\n\tf->frequency = dev->freq;\n\treturn 0;\n}\n\n\nstatic int vidioc_s_frequency(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_frequency *f)\n{\n\tstruct pcm20 *dev = video_drvdata(file);\n\n\tif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\n\t\treturn -EINVAL;\n\n\tdev->freq = clamp_t(u32, f->frequency, 87 * 16000U, 108 * 16000U);\n\tpcm20_setfreq(dev, dev->freq);\n\treturn 0;\n}\n\nstatic int pcm20_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct pcm20 *dev = container_of(ctrl->handler, struct pcm20, ctrl_handler);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\tsnd_aci_cmd(dev->aci, ACI_SET_TUNERMUTE, ctrl->val, -1);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int pcm20_thread(void *data)\n{\n\tstruct pcm20 *dev = data;\n\tconst unsigned no_rds_start_counter = 5;\n\tconst unsigned sleep_msecs = 2000;\n\tunsigned no_rds_counter = no_rds_start_counter;\n\n\tfor (;;) {\n\t\tchar text_buffer[66];\n\t\tu8 buf;\n\t\tint res;\n\n\t\tmsleep_interruptible(sleep_msecs);\n\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tres = rds_cmd(dev->aci, RDS_RXVALUE, &buf, 1);\n\t\tif (res)\n\t\t\tcontinue;\n\t\tif (buf == 0) {\n\t\t\tif (no_rds_counter == 0)\n\t\t\t\tcontinue;\n\t\t\tno_rds_counter--;\n\t\t\tif (no_rds_counter)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tv4l2_ctrl_s_ctrl_string(dev->rds_ps_name, \"\");\n\t\t\tv4l2_ctrl_s_ctrl(dev->rds_ms, 1);\n\t\t\tv4l2_ctrl_s_ctrl(dev->rds_ta, 0);\n\t\t\tv4l2_ctrl_s_ctrl(dev->rds_tp, 0);\n\t\t\tv4l2_ctrl_s_ctrl(dev->rds_pty, 0);\n\t\t\tv4l2_ctrl_s_ctrl_string(dev->rds_radio_test, \"\");\n\t\t\tcontinue;\n\t\t}\n\t\tno_rds_counter = no_rds_start_counter;\n\n\t\tres = rds_cmd(dev->aci, RDS_STATUS, &buf, 1);\n\t\tif (res)\n\t\t\tcontinue;\n\t\tif ((buf >> 3) & 1) {\n\t\t\tres = rds_cmd(dev->aci, RDS_STATIONNAME, text_buffer, 8);\n\t\t\ttext_buffer[8] = 0;\n\t\t\tif (!res && sanitize(text_buffer, 8))\n\t\t\t\tv4l2_ctrl_s_ctrl_string(dev->rds_ps_name, text_buffer);\n\t\t}\n\t\tif ((buf >> 6) & 1) {\n\t\t\tu8 pty;\n\n\t\t\tres = rds_cmd(dev->aci, RDS_PTYTATP, &pty, 1);\n\t\t\tif (!res) {\n\t\t\t\tv4l2_ctrl_s_ctrl(dev->rds_ms, !!(pty & 0x01));\n\t\t\t\tv4l2_ctrl_s_ctrl(dev->rds_ta, !!(pty & 0x02));\n\t\t\t\tv4l2_ctrl_s_ctrl(dev->rds_tp, !!(pty & 0x80));\n\t\t\t\tv4l2_ctrl_s_ctrl(dev->rds_pty, (pty >> 2) & 0x1f);\n\t\t\t}\n\t\t}\n\t\tif ((buf >> 4) & 1) {\n\t\t\tres = rds_cmd(dev->aci, RDS_TEXT, text_buffer, 65);\n\t\t\ttext_buffer[65] = 0;\n\t\t\tif (!res && sanitize(text_buffer + 1, 64))\n\t\t\t\tv4l2_ctrl_s_ctrl_string(dev->rds_radio_test, text_buffer + 1);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int pcm20_open(struct file *file)\n{\n\tstruct pcm20 *dev = video_drvdata(file);\n\tint res = v4l2_fh_open(file);\n\n\tif (!res && v4l2_fh_is_singular_file(file) &&\n\t    IS_ERR_OR_NULL(dev->kthread)) {\n\t\tdev->kthread = kthread_run(pcm20_thread, dev, \"%s\",\n\t\t\t\t\t   dev->v4l2_dev.name);\n\t\tif (IS_ERR(dev->kthread)) {\n\t\t\tv4l2_err(&dev->v4l2_dev, \"kernel_thread() failed\\n\");\n\t\t\tv4l2_fh_release(file);\n\t\t\treturn PTR_ERR(dev->kthread);\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic int pcm20_release(struct file *file)\n{\n\tstruct pcm20 *dev = video_drvdata(file);\n\n\tif (v4l2_fh_is_singular_file(file) && !IS_ERR_OR_NULL(dev->kthread)) {\n\t\tkthread_stop(dev->kthread);\n\t\tdev->kthread = NULL;\n\t}\n\treturn v4l2_fh_release(file);\n}\n\nstatic const struct v4l2_file_operations pcm20_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= pcm20_open,\n\t.poll\t\t= v4l2_ctrl_poll,\n\t.release\t= pcm20_release,\n\t.unlocked_ioctl\t= video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops pcm20_ioctl_ops = {\n\t.vidioc_querycap    = vidioc_querycap,\n\t.vidioc_g_tuner     = vidioc_g_tuner,\n\t.vidioc_s_tuner     = vidioc_s_tuner,\n\t.vidioc_g_frequency = vidioc_g_frequency,\n\t.vidioc_s_frequency = vidioc_s_frequency,\n\t.vidioc_log_status  = v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic const struct v4l2_ctrl_ops pcm20_ctrl_ops = {\n\t.s_ctrl = pcm20_s_ctrl,\n};\n\nstatic int __init pcm20_init(void)\n{\n\tstruct pcm20 *dev = &pcm20_card;\n\tstruct v4l2_device *v4l2_dev = &dev->v4l2_dev;\n\tstruct v4l2_ctrl_handler *hdl;\n\tint res;\n\n\tdev->aci = snd_aci_get_aci();\n\tif (dev->aci == NULL) {\n\t\tv4l2_err(v4l2_dev,\n\t\t\t \"you must load the snd-miro driver first!\\n\");\n\t\treturn -ENODEV;\n\t}\n\tstrscpy(v4l2_dev->name, \"radio-miropcm20\", sizeof(v4l2_dev->name));\n\tmutex_init(&dev->lock);\n\n\tres = v4l2_device_register(NULL, v4l2_dev);\n\tif (res < 0) {\n\t\tv4l2_err(v4l2_dev, \"could not register v4l2_device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thdl = &dev->ctrl_handler;\n\tv4l2_ctrl_handler_init(hdl, 7);\n\tv4l2_ctrl_new_std(hdl, &pcm20_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\n\tdev->rds_pty = v4l2_ctrl_new_std(hdl, NULL,\n\t\t\tV4L2_CID_RDS_RX_PTY, 0, 0x1f, 1, 0);\n\tdev->rds_ps_name = v4l2_ctrl_new_std(hdl, NULL,\n\t\t\tV4L2_CID_RDS_RX_PS_NAME, 0, 8, 8, 0);\n\tdev->rds_radio_test = v4l2_ctrl_new_std(hdl, NULL,\n\t\t\tV4L2_CID_RDS_RX_RADIO_TEXT, 0, 64, 64, 0);\n\tdev->rds_ta = v4l2_ctrl_new_std(hdl, NULL,\n\t\t\tV4L2_CID_RDS_RX_TRAFFIC_ANNOUNCEMENT, 0, 1, 1, 0);\n\tdev->rds_tp = v4l2_ctrl_new_std(hdl, NULL,\n\t\t\tV4L2_CID_RDS_RX_TRAFFIC_PROGRAM, 0, 1, 1, 0);\n\tdev->rds_ms = v4l2_ctrl_new_std(hdl, NULL,\n\t\t\tV4L2_CID_RDS_RX_MUSIC_SPEECH, 0, 1, 1, 1);\n\tv4l2_dev->ctrl_handler = hdl;\n\tif (hdl->error) {\n\t\tres = hdl->error;\n\t\tv4l2_err(v4l2_dev, \"Could not register control\\n\");\n\t\tgoto err_hdl;\n\t}\n\tstrscpy(dev->vdev.name, v4l2_dev->name, sizeof(dev->vdev.name));\n\tdev->vdev.v4l2_dev = v4l2_dev;\n\tdev->vdev.fops = &pcm20_fops;\n\tdev->vdev.ioctl_ops = &pcm20_ioctl_ops;\n\tdev->vdev.release = video_device_release_empty;\n\tdev->vdev.lock = &dev->lock;\n\tdev->vdev.device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO |\n\t\t\t\tV4L2_CAP_RDS_CAPTURE;\n\tvideo_set_drvdata(&dev->vdev, dev);\n\tsnd_aci_cmd(dev->aci, ACI_SET_TUNERMONO,\n\t\t\tdev->audmode == V4L2_TUNER_MODE_MONO, -1);\n\tpcm20_setfreq(dev, dev->freq);\n\n\tif (video_register_device(&dev->vdev, VFL_TYPE_RADIO, radio_nr) < 0)\n\t\tgoto err_hdl;\n\n\tv4l2_info(v4l2_dev, \"Mirosound PCM20 Radio tuner\\n\");\n\treturn 0;\nerr_hdl:\n\tv4l2_ctrl_handler_free(hdl);\n\tv4l2_device_unregister(v4l2_dev);\n\treturn -EINVAL;\n}\n\nMODULE_AUTHOR(\"Ruurd Reitsma, Krzysztof Helt\");\nMODULE_DESCRIPTION(\"A driver for the Miro PCM20 radio card.\");\nMODULE_LICENSE(\"GPL\");\n\nstatic void __exit pcm20_cleanup(void)\n{\n\tstruct pcm20 *dev = &pcm20_card;\n\n\tvideo_unregister_device(&dev->vdev);\n\tsnd_aci_cmd(dev->aci, ACI_SET_TUNERMUTE, 1, -1);\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n}\n\nmodule_init(pcm20_init);\nmodule_exit(pcm20_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}