{
  "module_name": "radio-terratec.c",
  "hash_id": "0971f1778fb6c8fa306ec184bb3a08f3bb97cc0fd611528ef637a779997b55d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/radio-terratec.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\t \n#include <linux/init.h>\t\t \n#include <linux/ioport.h>\t \n#include <linux/videodev2.h>\t \n#include <linux/mutex.h>\n#include <linux/io.h>\t\t \n#include <linux/slab.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include \"radio-isa.h\"\n\nMODULE_AUTHOR(\"R. Offermans & others\");\nMODULE_DESCRIPTION(\"A driver for the TerraTec ActiveRadio Standalone radio card.\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.1.99\");\n\n \nstatic int io = 0x590;\nstatic int radio_nr = -1;\n\nmodule_param(radio_nr, int, 0444);\nMODULE_PARM_DESC(radio_nr, \"Radio device number\");\n\n#define WRT_DIS\t\t0x00\n#define CLK_OFF\t\t0x00\n#define IIC_DATA\t0x01\n#define IIC_CLK\t\t0x02\n#define DATA\t\t0x04\n#define CLK_ON\t\t0x08\n#define WRT_EN\t\t0x10\n\nstatic struct radio_isa_card *terratec_alloc(void)\n{\n\treturn kzalloc(sizeof(struct radio_isa_card), GFP_KERNEL);\n}\n\nstatic int terratec_s_mute_volume(struct radio_isa_card *isa, bool mute, int vol)\n{\n\tint i;\n\n\tif (mute)\n\t\tvol = 0;\n\tvol = vol + (vol * 32);  \n\tfor (i = 0; i < 8; i++) {\n\t\tif (vol & (0x80 >> i))\n\t\t\toutb(0x80, isa->io + 1);\n\t\telse\n\t\t\toutb(0x00, isa->io + 1);\n\t}\n\treturn 0;\n}\n\n\n \n \n\nstatic int terratec_s_frequency(struct radio_isa_card *isa, u32 freq)\n{\n\tint i;\n\tint temp;\n\tlong rest;\n\tunsigned char buffer[25];\t\t \n\n\tfreq = freq / 160;\t\t\t \n\tmemset(buffer, 0, sizeof(buffer));\n\n\trest = freq * 10 + 10700;\t \n\t\t\t\t\t \n\ti = 13;\n\ttemp = 102400;\n\twhile (rest != 0) {\n\t\tif (rest % temp  == rest)\n\t\t\tbuffer[i] = 0;\n\t\telse {\n\t\t\tbuffer[i] = 1;\n\t\t\trest = rest - temp;\n\t\t}\n\t\ti--;\n\t\ttemp = temp / 2;\n\t}\n\n\tfor (i = 24; i > -1; i--) {\t \n\t\tif (buffer[i] == 1) {\n\t\t\toutb(WRT_EN | DATA, isa->io);\n\t\t\toutb(WRT_EN | DATA | CLK_ON, isa->io);\n\t\t\toutb(WRT_EN | DATA, isa->io);\n\t\t} else {\n\t\t\toutb(WRT_EN | 0x00, isa->io);\n\t\t\toutb(WRT_EN | 0x00 | CLK_ON, isa->io);\n\t\t}\n\t}\n\toutb(0x00, isa->io);\n\treturn 0;\n}\n\nstatic u32 terratec_g_signal(struct radio_isa_card *isa)\n{\n\t \n\treturn (inb(isa->io) & 2) ? 0 : 0xffff;\n}\n\nstatic const struct radio_isa_ops terratec_ops = {\n\t.alloc = terratec_alloc,\n\t.s_mute_volume = terratec_s_mute_volume,\n\t.s_frequency = terratec_s_frequency,\n\t.g_signal = terratec_g_signal,\n};\n\nstatic const int terratec_ioports[] = { 0x590 };\n\nstatic struct radio_isa_driver terratec_driver = {\n\t.driver = {\n\t\t.match\t\t= radio_isa_match,\n\t\t.probe\t\t= radio_isa_probe,\n\t\t.remove\t\t= radio_isa_remove,\n\t\t.driver\t\t= {\n\t\t\t.name\t= \"radio-terratec\",\n\t\t},\n\t},\n\t.io_params = &io,\n\t.radio_nr_params = &radio_nr,\n\t.io_ports = terratec_ioports,\n\t.num_of_io_ports = ARRAY_SIZE(terratec_ioports),\n\t.region_size = 2,\n\t.card = \"TerraTec ActiveRadio\",\n\t.ops = &terratec_ops,\n\t.has_stereo = true,\n\t.max_volume = 10,\n};\n\nstatic int __init terratec_init(void)\n{\n\treturn isa_register_driver(&terratec_driver.driver, 1);\n}\n\nstatic void __exit terratec_exit(void)\n{\n\tisa_unregister_driver(&terratec_driver.driver);\n}\n\nmodule_init(terratec_init);\nmodule_exit(terratec_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}