{
  "module_name": "radio-keene.c",
  "hash_id": "95640a4cc9123c65d2e2dfd327653a96f0219c7c921634d76635893a708b699c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/radio-keene.c",
  "human_readable_source": "\n \n\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <linux/usb.h>\n#include <linux/mutex.h>\n\n \nMODULE_AUTHOR(\"Hans Verkuil <hverkuil@xs4all.nl>\");\nMODULE_DESCRIPTION(\"Keene FM Transmitter driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define USB_KEENE_VENDOR 0x046d\n#define USB_KEENE_PRODUCT 0x0a0e\n\n \n#define BUFFER_LENGTH 8\n#define USB_TIMEOUT 500\n\n \n#define FREQ_MIN  76U\n#define FREQ_MAX 108U\n#define FREQ_MUL 16000U\n\n \nstatic const struct usb_device_id usb_keene_device_table[] = {\n\t{USB_DEVICE_AND_INTERFACE_INFO(USB_KEENE_VENDOR, USB_KEENE_PRODUCT,\n\t\t\t\t\t\t\tUSB_CLASS_HID, 0, 0) },\n\t{ }\t\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, usb_keene_device_table);\n\nstruct keene_device {\n\tstruct usb_device *usbdev;\n\tstruct usb_interface *intf;\n\tstruct video_device vdev;\n\tstruct v4l2_device v4l2_dev;\n\tstruct v4l2_ctrl_handler hdl;\n\tstruct mutex lock;\n\n\tu8 *buffer;\n\tunsigned curfreq;\n\tu8 tx;\n\tu8 pa;\n\tbool stereo;\n\tbool muted;\n\tbool preemph_75_us;\n};\n\nstatic inline struct keene_device *to_keene_dev(struct v4l2_device *v4l2_dev)\n{\n\treturn container_of(v4l2_dev, struct keene_device, v4l2_dev);\n}\n\n \nstatic int keene_cmd_main(struct keene_device *radio, unsigned freq, bool play)\n{\n\tunsigned short freq_send = freq ? (freq - 76 * 16000) / 800 : 0;\n\tint ret;\n\n\tradio->buffer[0] = 0x00;\n\tradio->buffer[1] = 0x50;\n\tradio->buffer[2] = (freq_send >> 8) & 0xff;\n\tradio->buffer[3] = freq_send & 0xff;\n\tradio->buffer[4] = radio->pa;\n\t \n\tradio->buffer[5] = (radio->muted ? 4 : 8) | (play ? 1 : 2) |\n\t\t\t\t\t\t\t(freq ? 0x10 : 0);\n\tradio->buffer[6] = 0x00;\n\tradio->buffer[7] = 0x00;\n\n\tret = usb_control_msg(radio->usbdev, usb_sndctrlpipe(radio->usbdev, 0),\n\t\t9, 0x21, 0x200, 2, radio->buffer, BUFFER_LENGTH, USB_TIMEOUT);\n\n\tif (ret < 0) {\n\t\tdev_warn(&radio->vdev.dev, \"%s failed (%d)\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\tif (freq)\n\t\tradio->curfreq = freq;\n\treturn 0;\n}\n\n \nstatic int keene_cmd_set(struct keene_device *radio)\n{\n\tint ret;\n\n\tradio->buffer[0] = 0x00;\n\tradio->buffer[1] = 0x51;\n\tradio->buffer[2] = radio->tx;\n\t \n\tradio->buffer[3] = (radio->stereo ? 0 : 1) | (radio->preemph_75_us ? 4 : 0);\n\tradio->buffer[4] = 0x00;\n\tradio->buffer[5] = 0x00;\n\tradio->buffer[6] = 0x00;\n\tradio->buffer[7] = 0x00;\n\n\tret = usb_control_msg(radio->usbdev, usb_sndctrlpipe(radio->usbdev, 0),\n\t\t9, 0x21, 0x200, 2, radio->buffer, BUFFER_LENGTH, USB_TIMEOUT);\n\n\tif (ret < 0) {\n\t\tdev_warn(&radio->vdev.dev, \"%s failed (%d)\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nstatic void usb_keene_disconnect(struct usb_interface *intf)\n{\n\tstruct keene_device *radio = to_keene_dev(usb_get_intfdata(intf));\n\n\tmutex_lock(&radio->lock);\n\tusb_set_intfdata(intf, NULL);\n\tvideo_unregister_device(&radio->vdev);\n\tv4l2_device_disconnect(&radio->v4l2_dev);\n\tmutex_unlock(&radio->lock);\n\tv4l2_device_put(&radio->v4l2_dev);\n}\n\nstatic int usb_keene_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct keene_device *radio = to_keene_dev(usb_get_intfdata(intf));\n\n\treturn keene_cmd_main(radio, 0, false);\n}\n\nstatic int usb_keene_resume(struct usb_interface *intf)\n{\n\tstruct keene_device *radio = to_keene_dev(usb_get_intfdata(intf));\n\n\tmdelay(50);\n\tkeene_cmd_set(radio);\n\tkeene_cmd_main(radio, radio->curfreq, true);\n\treturn 0;\n}\n\nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_capability *v)\n{\n\tstruct keene_device *radio = video_drvdata(file);\n\n\tstrscpy(v->driver, \"radio-keene\", sizeof(v->driver));\n\tstrscpy(v->card, \"Keene FM Transmitter\", sizeof(v->card));\n\tusb_make_path(radio->usbdev, v->bus_info, sizeof(v->bus_info));\n\treturn 0;\n}\n\nstatic int vidioc_g_modulator(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_modulator *v)\n{\n\tstruct keene_device *radio = video_drvdata(file);\n\n\tif (v->index > 0)\n\t\treturn -EINVAL;\n\n\tstrscpy(v->name, \"FM\", sizeof(v->name));\n\tv->rangelow = FREQ_MIN * FREQ_MUL;\n\tv->rangehigh = FREQ_MAX * FREQ_MUL;\n\tv->txsubchans = radio->stereo ? V4L2_TUNER_SUB_STEREO : V4L2_TUNER_SUB_MONO;\n\tv->capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO;\n\treturn 0;\n}\n\nstatic int vidioc_s_modulator(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_modulator *v)\n{\n\tstruct keene_device *radio = video_drvdata(file);\n\n\tif (v->index > 0)\n\t\treturn -EINVAL;\n\n\tradio->stereo = (v->txsubchans == V4L2_TUNER_SUB_STEREO);\n\treturn keene_cmd_set(radio);\n}\n\nstatic int vidioc_s_frequency(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_frequency *f)\n{\n\tstruct keene_device *radio = video_drvdata(file);\n\tunsigned freq = f->frequency;\n\n\tif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\n\t\treturn -EINVAL;\n\tfreq = clamp(freq, FREQ_MIN * FREQ_MUL, FREQ_MAX * FREQ_MUL);\n\treturn keene_cmd_main(radio, freq, true);\n}\n\nstatic int vidioc_g_frequency(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_frequency *f)\n{\n\tstruct keene_device *radio = video_drvdata(file);\n\n\tif (f->tuner != 0)\n\t\treturn -EINVAL;\n\tf->type = V4L2_TUNER_RADIO;\n\tf->frequency = radio->curfreq;\n\treturn 0;\n}\n\nstatic int keene_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstatic const u8 db2tx[] = {\n\t      \n\t\t0x03, 0x13, 0x02, 0x12, 0x22, 0x32,\n\t      \n\t\t0x21, 0x31, 0x20, 0x30, 0x40, 0x50\n\t};\n\tstruct keene_device *radio =\n\t\tcontainer_of(ctrl->handler, struct keene_device, hdl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\tradio->muted = ctrl->val;\n\t\treturn keene_cmd_main(radio, 0, true);\n\n\tcase V4L2_CID_TUNE_POWER_LEVEL:\n\t\t \n\t\tradio->pa = (ctrl->val - 71) * 100 / 62;\n\t\treturn keene_cmd_main(radio, 0, true);\n\n\tcase V4L2_CID_TUNE_PREEMPHASIS:\n\t\tradio->preemph_75_us = ctrl->val == V4L2_PREEMPHASIS_75_uS;\n\t\treturn keene_cmd_set(radio);\n\n\tcase V4L2_CID_AUDIO_COMPRESSION_GAIN:\n\t\tradio->tx = db2tx[(ctrl->val - (s32)ctrl->minimum) / (s32)ctrl->step];\n\t\treturn keene_cmd_set(radio);\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic const struct v4l2_file_operations usb_keene_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open           = v4l2_fh_open,\n\t.release        = v4l2_fh_release,\n\t.poll\t\t= v4l2_ctrl_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n};\n\nstatic const struct v4l2_ctrl_ops keene_ctrl_ops = {\n\t.s_ctrl = keene_s_ctrl,\n};\n\nstatic const struct v4l2_ioctl_ops usb_keene_ioctl_ops = {\n\t.vidioc_querycap    = vidioc_querycap,\n\t.vidioc_g_modulator = vidioc_g_modulator,\n\t.vidioc_s_modulator = vidioc_s_modulator,\n\t.vidioc_g_frequency = vidioc_g_frequency,\n\t.vidioc_s_frequency = vidioc_s_frequency,\n\t.vidioc_log_status = v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic void usb_keene_video_device_release(struct v4l2_device *v4l2_dev)\n{\n\tstruct keene_device *radio = to_keene_dev(v4l2_dev);\n\n\t \n\tv4l2_ctrl_handler_free(&radio->hdl);\n\tkfree(radio->buffer);\n\tkfree(radio);\n}\n\n \nstatic int usb_keene_probe(struct usb_interface *intf,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct keene_device *radio;\n\tstruct v4l2_ctrl_handler *hdl;\n\tint retval = 0;\n\n\t \n\tif (dev->product && strcmp(dev->product, \"B-LINK USB Audio  \"))\n\t\treturn -ENODEV;\n\n\tradio = kzalloc(sizeof(struct keene_device), GFP_KERNEL);\n\tif (radio)\n\t\tradio->buffer = kmalloc(BUFFER_LENGTH, GFP_KERNEL);\n\n\tif (!radio || !radio->buffer) {\n\t\tdev_err(&intf->dev, \"kmalloc for keene_device failed\\n\");\n\t\tkfree(radio);\n\t\tretval = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\thdl = &radio->hdl;\n\tv4l2_ctrl_handler_init(hdl, 4);\n\tv4l2_ctrl_new_std(hdl, &keene_ctrl_ops, V4L2_CID_AUDIO_MUTE,\n\t\t\t0, 1, 1, 0);\n\tv4l2_ctrl_new_std_menu(hdl, &keene_ctrl_ops, V4L2_CID_TUNE_PREEMPHASIS,\n\t\t\tV4L2_PREEMPHASIS_75_uS, 1, V4L2_PREEMPHASIS_50_uS);\n\tv4l2_ctrl_new_std(hdl, &keene_ctrl_ops, V4L2_CID_TUNE_POWER_LEVEL,\n\t\t\t84, 118, 1, 118);\n\tv4l2_ctrl_new_std(hdl, &keene_ctrl_ops, V4L2_CID_AUDIO_COMPRESSION_GAIN,\n\t\t\t-15, 18, 3, 0);\n\tradio->pa = 118;\n\tradio->tx = 0x32;\n\tradio->stereo = true;\n\tif (hdl->error) {\n\t\tretval = hdl->error;\n\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\tgoto err_v4l2;\n\t}\n\tretval = v4l2_device_register(&intf->dev, &radio->v4l2_dev);\n\tif (retval < 0) {\n\t\tdev_err(&intf->dev, \"couldn't register v4l2_device\\n\");\n\t\tgoto err_v4l2;\n\t}\n\n\tmutex_init(&radio->lock);\n\n\tradio->v4l2_dev.ctrl_handler = hdl;\n\tradio->v4l2_dev.release = usb_keene_video_device_release;\n\tstrscpy(radio->vdev.name, radio->v4l2_dev.name,\n\t\tsizeof(radio->vdev.name));\n\tradio->vdev.v4l2_dev = &radio->v4l2_dev;\n\tradio->vdev.fops = &usb_keene_fops;\n\tradio->vdev.ioctl_ops = &usb_keene_ioctl_ops;\n\tradio->vdev.lock = &radio->lock;\n\tradio->vdev.release = video_device_release_empty;\n\tradio->vdev.vfl_dir = VFL_DIR_TX;\n\tradio->vdev.device_caps = V4L2_CAP_RADIO | V4L2_CAP_MODULATOR;\n\n\tradio->usbdev = interface_to_usbdev(intf);\n\tradio->intf = intf;\n\tusb_set_intfdata(intf, &radio->v4l2_dev);\n\n\tvideo_set_drvdata(&radio->vdev, radio);\n\n\t \n\tmsleep(20);\n\tkeene_cmd_main(radio, 95.16 * FREQ_MUL, false);\n\n\tretval = video_register_device(&radio->vdev, VFL_TYPE_RADIO, -1);\n\tif (retval < 0) {\n\t\tdev_err(&intf->dev, \"could not register video device\\n\");\n\t\tgoto err_vdev;\n\t}\n\tv4l2_ctrl_handler_setup(hdl);\n\tdev_info(&intf->dev, \"V4L2 device registered as %s\\n\",\n\t\t\tvideo_device_node_name(&radio->vdev));\n\treturn 0;\n\nerr_vdev:\n\tv4l2_device_unregister(&radio->v4l2_dev);\nerr_v4l2:\n\tkfree(radio->buffer);\n\tkfree(radio);\nerr:\n\treturn retval;\n}\n\n \nstatic struct usb_driver usb_keene_driver = {\n\t.name\t\t\t= \"radio-keene\",\n\t.probe\t\t\t= usb_keene_probe,\n\t.disconnect\t\t= usb_keene_disconnect,\n\t.id_table\t\t= usb_keene_device_table,\n\t.suspend\t\t= usb_keene_suspend,\n\t.resume\t\t\t= usb_keene_resume,\n\t.reset_resume\t\t= usb_keene_resume,\n};\n\nmodule_usb_driver(usb_keene_driver);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}