{
  "module_name": "radio-aimslab.c",
  "hash_id": "61999f728c1285225663e2eb32235ff633264f3adeaefba755614d4c4ed05d1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/radio-aimslab.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\t \n#include <linux/init.h>\t\t \n#include <linux/ioport.h>\t \n#include <linux/delay.h>\t \n#include <linux/videodev2.h>\t \n#include <linux/io.h>\t\t \n#include <linux/slab.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include \"radio-isa.h\"\n#include \"lm7000.h\"\n\nMODULE_AUTHOR(\"M. Kirkwood\");\nMODULE_DESCRIPTION(\"A driver for the RadioTrack/RadioReveal radio card.\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"1.0.0\");\n\n#ifndef CONFIG_RADIO_RTRACK_PORT\n#define CONFIG_RADIO_RTRACK_PORT -1\n#endif\n\n#define RTRACK_MAX 2\n\nstatic int io[RTRACK_MAX] = { [0] = CONFIG_RADIO_RTRACK_PORT,\n\t\t\t      [1 ... (RTRACK_MAX - 1)] = -1 };\nstatic int radio_nr[RTRACK_MAX]\t= { [0 ... (RTRACK_MAX - 1)] = -1 };\n\nmodule_param_array(io, int, NULL, 0444);\nMODULE_PARM_DESC(io, \"I/O addresses of the RadioTrack card (0x20f or 0x30f)\");\nmodule_param_array(radio_nr, int, NULL, 0444);\nMODULE_PARM_DESC(radio_nr, \"Radio device numbers\");\n\nstruct rtrack {\n\tstruct radio_isa_card isa;\n\tint curvol;\n};\n\nstatic struct radio_isa_card *rtrack_alloc(void)\n{\n\tstruct rtrack *rt = kzalloc(sizeof(struct rtrack), GFP_KERNEL);\n\n\tif (rt)\n\t\trt->curvol = 0xff;\n\treturn rt ? &rt->isa : NULL;\n}\n\n#define AIMS_BIT_TUN_CE\t\t(1 << 0)\n#define AIMS_BIT_TUN_CLK\t(1 << 1)\n#define AIMS_BIT_TUN_DATA\t(1 << 2)\n#define AIMS_BIT_VOL_CE\t\t(1 << 3)\n#define AIMS_BIT_TUN_STRQ\t(1 << 4)\n \n#define AIMS_BIT_VOL_UP\t\t(1 << 6)\t \n#define AIMS_BIT_VOL_DN\t\t(1 << 7)\t \n\nstatic void rtrack_set_pins(void *handle, u8 pins)\n{\n\tstruct radio_isa_card *isa = handle;\n\tstruct rtrack *rt = container_of(isa, struct rtrack, isa);\n\tu8 bits = AIMS_BIT_VOL_DN | AIMS_BIT_VOL_UP | AIMS_BIT_TUN_STRQ;\n\n\tif (!v4l2_ctrl_g_ctrl(rt->isa.mute))\n\t\tbits |= AIMS_BIT_VOL_CE;\n\n\tif (pins & LM7000_DATA)\n\t\tbits |= AIMS_BIT_TUN_DATA;\n\tif (pins & LM7000_CLK)\n\t\tbits |= AIMS_BIT_TUN_CLK;\n\tif (pins & LM7000_CE)\n\t\tbits |= AIMS_BIT_TUN_CE;\n\n\toutb_p(bits, rt->isa.io);\n}\n\nstatic int rtrack_s_frequency(struct radio_isa_card *isa, u32 freq)\n{\n\tlm7000_set_freq(freq, isa, rtrack_set_pins);\n\n\treturn 0;\n}\n\nstatic u32 rtrack_g_signal(struct radio_isa_card *isa)\n{\n\t \n\treturn 0xffff * !(inb(isa->io) & 2);\n}\n\nstatic int rtrack_s_mute_volume(struct radio_isa_card *isa, bool mute, int vol)\n{\n\tstruct rtrack *rt = container_of(isa, struct rtrack, isa);\n\tint curvol = rt->curvol;\n\n\tif (mute) {\n\t\toutb(0xd0, isa->io);\t \n\t\treturn 0;\n\t}\n\tif (vol == 0) {\t\t\t \n\t\toutb(0x48, isa->io);\t \n\t\tmsleep(curvol * 3);\t \n\t} else if (curvol < vol) {\n\t\toutb(0x98, isa->io);\t \n\t\tfor (; curvol < vol; curvol++)\n\t\t\tmdelay(3);\n\t} else if (curvol > vol) {\n\t\toutb(0x58, isa->io);\t \n\t\tfor (; curvol > vol; curvol--)\n\t\t\tmdelay(3);\n\t}\n\toutb(0xd8, isa->io);\t\t \n\trt->curvol = vol;\n\treturn 0;\n}\n\n \nstatic int rtrack_initialize(struct radio_isa_card *isa)\n{\n\t \n\toutb(0x90, isa->io);\t \n\tmsleep(3000);\t\t \n\toutb(0xc0, isa->io);\t \n\treturn 0;\n}\n\nstatic const struct radio_isa_ops rtrack_ops = {\n\t.alloc = rtrack_alloc,\n\t.init = rtrack_initialize,\n\t.s_mute_volume = rtrack_s_mute_volume,\n\t.s_frequency = rtrack_s_frequency,\n\t.g_signal = rtrack_g_signal,\n};\n\nstatic const int rtrack_ioports[] = { 0x20f, 0x30f };\n\nstatic struct radio_isa_driver rtrack_driver = {\n\t.driver = {\n\t\t.match\t\t= radio_isa_match,\n\t\t.probe\t\t= radio_isa_probe,\n\t\t.remove\t\t= radio_isa_remove,\n\t\t.driver\t\t= {\n\t\t\t.name\t= \"radio-aimslab\",\n\t\t},\n\t},\n\t.io_params = io,\n\t.radio_nr_params = radio_nr,\n\t.io_ports = rtrack_ioports,\n\t.num_of_io_ports = ARRAY_SIZE(rtrack_ioports),\n\t.region_size = 2,\n\t.card = \"AIMSlab RadioTrack/RadioReveal\",\n\t.ops = &rtrack_ops,\n\t.has_stereo = true,\n\t.max_volume = 0xff,\n};\n\nstatic int __init rtrack_init(void)\n{\n\treturn isa_register_driver(&rtrack_driver.driver, RTRACK_MAX);\n}\n\nstatic void __exit rtrack_exit(void)\n{\n\tisa_unregister_driver(&rtrack_driver.driver);\n}\n\nmodule_init(rtrack_init);\nmodule_exit(rtrack_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}