{
  "module_name": "radio-cadet.c",
  "hash_id": "efd5c8e74d13958533e0bea2033f11da81c5b2179a2762f7f2005aa240bb4c8f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/radio-cadet.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\t \n#include <linux/init.h>\t\t \n#include <linux/ioport.h>\t \n#include <linux/delay.h>\t \n#include <linux/videodev2.h>\t \n#include <linux/param.h>\n#include <linux/pnp.h>\n#include <linux/sched.h>\n#include <linux/io.h>\t\t \n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-event.h>\n\nMODULE_AUTHOR(\"Fred Gleason, Russell Kroll, Quay Lu, Donald Song, Jason Lewis, Scott McGrath, William McGrath\");\nMODULE_DESCRIPTION(\"A driver for the ADS Cadet AM/FM/RDS radio card.\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.3.4\");\n\nstatic int io = -1;\t\t \nstatic int radio_nr = -1;\n\nmodule_param(io, int, 0);\nMODULE_PARM_DESC(io, \"I/O address of Cadet card (0x330,0x332,0x334,0x336,0x338,0x33a,0x33c,0x33e)\");\nmodule_param(radio_nr, int, 0);\n\n#define RDS_BUFFER 256\n#define RDS_RX_FLAG 1\n#define MBS_RX_FLAG 2\n\nstruct cadet {\n\tstruct v4l2_device v4l2_dev;\n\tstruct video_device vdev;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tint io;\n\tbool is_fm_band;\n\tu32 curfreq;\n\tint tunestat;\n\tint sigstrength;\n\twait_queue_head_t read_queue;\n\tstruct timer_list readtimer;\n\tu8 rdsin, rdsout, rdsstat;\n\tunsigned char rdsbuf[RDS_BUFFER];\n\tstruct mutex lock;\n\tint reading;\n};\n\nstatic struct cadet cadet_card;\n\n \nstatic u16 sigtable[2][4] = {\n\t{ 1835, 2621,  4128, 65535 },\n\t{ 2185, 4369, 13107, 65535 },\n};\n\nstatic const struct v4l2_frequency_band bands[] = {\n\t{\n\t\t.index = 0,\n\t\t.type = V4L2_TUNER_RADIO,\n\t\t.capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow = 8320,       \n\t\t.rangehigh = 26400,     \n\t\t.modulation = V4L2_BAND_MODULATION_AM,\n\t}, {\n\t\t.index = 1,\n\t\t.type = V4L2_TUNER_RADIO,\n\t\t.capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_RDS |\n\t\t\tV4L2_TUNER_CAP_RDS_BLOCK_IO | V4L2_TUNER_CAP_LOW |\n\t\t\tV4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow = 1400000,    \n\t\t.rangehigh = 1728000,   \n\t\t.modulation = V4L2_BAND_MODULATION_FM,\n\t},\n};\n\n\nstatic int cadet_getstereo(struct cadet *dev)\n{\n\tint ret = V4L2_TUNER_SUB_MONO;\n\n\tif (!dev->is_fm_band)\t \n\t\treturn V4L2_TUNER_SUB_MONO;\n\n\toutb(7, dev->io);           \n\tif ((inb(dev->io + 1) & 0x40) == 0)\n\t\tret = V4L2_TUNER_SUB_STEREO;\n\treturn ret;\n}\n\nstatic unsigned cadet_gettune(struct cadet *dev)\n{\n\tint curvol, i;\n\tunsigned fifo = 0;\n\n\t \n\n\toutb(7, dev->io);        \n\tcurvol = inb(dev->io + 1);  \n\toutb(0x00, dev->io + 1);   \n\tdev->tunestat = 0xffff;\n\n\t \n\tfor (i = 0; i < 25; i++) {\n\t\tfifo = (fifo << 1) | ((inb(dev->io + 1) >> 7) & 0x01);\n\t\tif (i < 24) {\n\t\t\toutb(0x01, dev->io + 1);\n\t\t\tdev->tunestat &= inb(dev->io + 1);\n\t\t\toutb(0x00, dev->io + 1);\n\t\t}\n\t}\n\n\t \n\toutb(curvol, dev->io + 1);\n\treturn fifo;\n}\n\nstatic unsigned cadet_getfreq(struct cadet *dev)\n{\n\tint i;\n\tunsigned freq = 0, test, fifo = 0;\n\n\t \n\tfifo = cadet_gettune(dev);\n\n\t \n\tif (!dev->is_fm_band)     \n\t\treturn ((fifo & 0x7fff) - 450) * 16;\n\n\ttest = 12500;\n\tfor (i = 0; i < 14; i++) {\n\t\tif ((fifo & 0x01) != 0)\n\t\t\tfreq += test;\n\t\ttest = test << 1;\n\t\tfifo = fifo >> 1;\n\t}\n\tfreq -= 10700000;            \n\tfreq = (freq * 16) / 1000;    \n\treturn freq;\n}\n\nstatic void cadet_settune(struct cadet *dev, unsigned fifo)\n{\n\tint i;\n\tunsigned test;\n\n\toutb(7, dev->io);                 \n\t \n\ttest = 0;\n\ttest = (fifo >> 23) & 0x02;       \n\ttest |= 0x1c;                 \n\toutb(7, dev->io);                 \n\toutb(test, dev->io + 1);            \n\tfor (i = 0; i < 25; i++) {\n\t\ttest |= 0x01;               \n\t\toutb(test, dev->io + 1);\n\t\ttest &= 0xfe;               \n\t\toutb(test, dev->io + 1);\n\t\tfifo = fifo << 1;             \n\t\ttest = 0x1c | ((fifo >> 23) & 0x02);\n\t\toutb(test, dev->io + 1);\n\t}\n}\n\nstatic void cadet_setfreq(struct cadet *dev, unsigned freq)\n{\n\tunsigned fifo;\n\tint i, j, test;\n\tint curvol;\n\n\tfreq = clamp(freq, bands[dev->is_fm_band].rangelow,\n\t\t\t   bands[dev->is_fm_band].rangehigh);\n\tdev->curfreq = freq;\n\t \n\tfifo = 0;\n\tif (dev->is_fm_band) {     \n\t\ttest = 102400;\n\t\tfreq = freq / 16;        \n\t\tfreq += 10700;                \n\t\tfor (i = 0; i < 14; i++) {\n\t\t\tfifo = fifo << 1;\n\t\t\tif (freq >= test) {\n\t\t\t\tfifo |= 0x01;\n\t\t\t\tfreq -= test;\n\t\t\t}\n\t\t\ttest = test >> 1;\n\t\t}\n\t} else {\t \n\t\tfifo = (freq / 16) + 450;\t \n\t\tfifo |= 0x100000;\t\t \n\t}\n\n\t \n\n\toutb(7, dev->io);                 \n\tcurvol = inb(dev->io + 1);\n\n\t \n\tfor (j = 3; j > -1; j--) {\n\t\tcadet_settune(dev, fifo | (j << 16));\n\n\t\toutb(7, dev->io);          \n\t\toutb(curvol, dev->io + 1);\n\n\t\tmsleep(100);\n\n\t\tcadet_gettune(dev);\n\t\tif ((dev->tunestat & 0x40) == 0) {    \n\t\t\tdev->sigstrength = sigtable[dev->is_fm_band][j];\n\t\t\tgoto reset_rds;\n\t\t}\n\t}\n\tdev->sigstrength = 0;\nreset_rds:\n\toutb(3, dev->io);\n\toutb(inb(dev->io + 1) & 0x7f, dev->io + 1);\n}\n\nstatic bool cadet_has_rds_data(struct cadet *dev)\n{\n\tbool result;\n\n\tmutex_lock(&dev->lock);\n\tresult = dev->rdsin != dev->rdsout;\n\tmutex_unlock(&dev->lock);\n\treturn result;\n}\n\n\nstatic void cadet_handler(struct timer_list *t)\n{\n\tstruct cadet *dev = from_timer(dev, t, readtimer);\n\n\t \n\tif (mutex_trylock(&dev->lock)) {\n\t\toutb(0x3, dev->io);        \n\t\tif ((inb(dev->io + 1) & 0x20) != 0)\n\t\t\tpr_err(\"cadet: RDS fifo overflow\\n\");\n\t\toutb(0x80, dev->io);       \n\n\t\twhile ((inb(dev->io) & 0x80) != 0) {\n\t\t\tdev->rdsbuf[dev->rdsin] = inb(dev->io + 1);\n\t\t\tif (dev->rdsin + 1 != dev->rdsout)\n\t\t\t\tdev->rdsin++;\n\t\t}\n\t\tmutex_unlock(&dev->lock);\n\t}\n\n\t \n\tif (cadet_has_rds_data(dev))\n\t\twake_up_interruptible(&dev->read_queue);\n\n\t \n\tdev->readtimer.expires = jiffies + msecs_to_jiffies(50);\n\tadd_timer(&dev->readtimer);\n}\n\nstatic void cadet_start_rds(struct cadet *dev)\n{\n\tdev->rdsstat = 1;\n\toutb(0x80, dev->io);         \n\ttimer_setup(&dev->readtimer, cadet_handler, 0);\n\tdev->readtimer.expires = jiffies + msecs_to_jiffies(50);\n\tadd_timer(&dev->readtimer);\n}\n\nstatic ssize_t cadet_read(struct file *file, char __user *data, size_t count, loff_t *ppos)\n{\n\tstruct cadet *dev = video_drvdata(file);\n\tunsigned char readbuf[RDS_BUFFER];\n\tint i = 0;\n\n\tmutex_lock(&dev->lock);\n\tif (dev->rdsstat == 0)\n\t\tcadet_start_rds(dev);\n\tmutex_unlock(&dev->lock);\n\n\tif (!cadet_has_rds_data(dev) && (file->f_flags & O_NONBLOCK))\n\t\treturn -EWOULDBLOCK;\n\ti = wait_event_interruptible(dev->read_queue, cadet_has_rds_data(dev));\n\tif (i)\n\t\treturn i;\n\n\tmutex_lock(&dev->lock);\n\twhile (i < count && dev->rdsin != dev->rdsout)\n\t\treadbuf[i++] = dev->rdsbuf[dev->rdsout++];\n\tmutex_unlock(&dev->lock);\n\n\tif (i && copy_to_user(data, readbuf, i))\n\t\treturn -EFAULT;\n\treturn i;\n}\n\n\nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_capability *v)\n{\n\tstrscpy(v->driver, \"ADS Cadet\", sizeof(v->driver));\n\tstrscpy(v->card, \"ADS Cadet\", sizeof(v->card));\n\tstrscpy(v->bus_info, \"ISA:radio-cadet\", sizeof(v->bus_info));\n\treturn 0;\n}\n\nstatic int vidioc_g_tuner(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_tuner *v)\n{\n\tstruct cadet *dev = video_drvdata(file);\n\n\tif (v->index)\n\t\treturn -EINVAL;\n\tv->type = V4L2_TUNER_RADIO;\n\tstrscpy(v->name, \"Radio\", sizeof(v->name));\n\tv->capability = bands[0].capability | bands[1].capability;\n\tv->rangelow = bands[0].rangelow;\t    \n\tv->rangehigh = bands[1].rangehigh;     \n\tif (dev->is_fm_band) {\n\t\tv->rxsubchans = cadet_getstereo(dev);\n\t\toutb(3, dev->io);\n\t\toutb(inb(dev->io + 1) & 0x7f, dev->io + 1);\n\t\tmdelay(100);\n\t\toutb(3, dev->io);\n\t\tif (inb(dev->io + 1) & 0x80)\n\t\t\tv->rxsubchans |= V4L2_TUNER_SUB_RDS;\n\t} else {\n\t\tv->rangelow = 8320;       \n\t\tv->rangehigh = 26400;     \n\t\tv->rxsubchans = V4L2_TUNER_SUB_MONO;\n\t}\n\tv->audmode = V4L2_TUNER_MODE_STEREO;\n\tv->signal = dev->sigstrength;  \n\treturn 0;\n}\n\nstatic int vidioc_s_tuner(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_tuner *v)\n{\n\treturn v->index ? -EINVAL : 0;\n}\n\nstatic int vidioc_enum_freq_bands(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_frequency_band *band)\n{\n\tif (band->tuner)\n\t\treturn -EINVAL;\n\tif (band->index >= ARRAY_SIZE(bands))\n\t\treturn -EINVAL;\n\t*band = bands[band->index];\n\treturn 0;\n}\n\nstatic int vidioc_g_frequency(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_frequency *f)\n{\n\tstruct cadet *dev = video_drvdata(file);\n\n\tif (f->tuner)\n\t\treturn -EINVAL;\n\tf->type = V4L2_TUNER_RADIO;\n\tf->frequency = dev->curfreq;\n\treturn 0;\n}\n\n\nstatic int vidioc_s_frequency(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_frequency *f)\n{\n\tstruct cadet *dev = video_drvdata(file);\n\n\tif (f->tuner)\n\t\treturn -EINVAL;\n\tdev->is_fm_band =\n\t\tf->frequency >= (bands[0].rangehigh + bands[1].rangelow) / 2;\n\tcadet_setfreq(dev, f->frequency);\n\treturn 0;\n}\n\nstatic int cadet_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct cadet *dev = container_of(ctrl->handler, struct cadet, ctrl_handler);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\toutb(7, dev->io);                 \n\t\tif (ctrl->val)\n\t\t\toutb(0x00, dev->io + 1);\n\t\telse\n\t\t\toutb(0x20, dev->io + 1);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int cadet_open(struct file *file)\n{\n\tstruct cadet *dev = video_drvdata(file);\n\tint err;\n\n\tmutex_lock(&dev->lock);\n\terr = v4l2_fh_open(file);\n\tif (err)\n\t\tgoto fail;\n\tif (v4l2_fh_is_singular_file(file))\n\t\tinit_waitqueue_head(&dev->read_queue);\nfail:\n\tmutex_unlock(&dev->lock);\n\treturn err;\n}\n\nstatic int cadet_release(struct file *file)\n{\n\tstruct cadet *dev = video_drvdata(file);\n\n\tmutex_lock(&dev->lock);\n\tif (v4l2_fh_is_singular_file(file) && dev->rdsstat) {\n\t\tdel_timer_sync(&dev->readtimer);\n\t\tdev->rdsstat = 0;\n\t}\n\tv4l2_fh_release(file);\n\tmutex_unlock(&dev->lock);\n\treturn 0;\n}\n\nstatic __poll_t cadet_poll(struct file *file, struct poll_table_struct *wait)\n{\n\tstruct cadet *dev = video_drvdata(file);\n\t__poll_t req_events = poll_requested_events(wait);\n\t__poll_t res = v4l2_ctrl_poll(file, wait);\n\n\tpoll_wait(file, &dev->read_queue, wait);\n\tif (dev->rdsstat == 0 && (req_events & (EPOLLIN | EPOLLRDNORM))) {\n\t\tmutex_lock(&dev->lock);\n\t\tif (dev->rdsstat == 0)\n\t\t\tcadet_start_rds(dev);\n\t\tmutex_unlock(&dev->lock);\n\t}\n\tif (cadet_has_rds_data(dev))\n\t\tres |= EPOLLIN | EPOLLRDNORM;\n\treturn res;\n}\n\n\nstatic const struct v4l2_file_operations cadet_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= cadet_open,\n\t.release\t= cadet_release,\n\t.read\t\t= cadet_read,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.poll\t\t= cadet_poll,\n};\n\nstatic const struct v4l2_ioctl_ops cadet_ioctl_ops = {\n\t.vidioc_querycap    = vidioc_querycap,\n\t.vidioc_g_tuner     = vidioc_g_tuner,\n\t.vidioc_s_tuner     = vidioc_s_tuner,\n\t.vidioc_g_frequency = vidioc_g_frequency,\n\t.vidioc_s_frequency = vidioc_s_frequency,\n\t.vidioc_enum_freq_bands = vidioc_enum_freq_bands,\n\t.vidioc_log_status  = v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic const struct v4l2_ctrl_ops cadet_ctrl_ops = {\n\t.s_ctrl = cadet_s_ctrl,\n};\n\n#ifdef CONFIG_PNP\n\nstatic const struct pnp_device_id cadet_pnp_devices[] = {\n\t \n\t{.id = \"MSM0c24\", .driver_data = 0},\n\t{.id = \"\"}\n};\n\nMODULE_DEVICE_TABLE(pnp, cadet_pnp_devices);\n\nstatic int cadet_pnp_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)\n{\n\tif (!dev)\n\t\treturn -ENODEV;\n\t \n\tif (io > 0)\n\t\treturn -EBUSY;\n\n\tif (!pnp_port_valid(dev, 0))\n\t\treturn -ENODEV;\n\n\tio = pnp_port_start(dev, 0);\n\n\tprintk(KERN_INFO \"radio-cadet: PnP reports device at %#x\\n\", io);\n\n\treturn io;\n}\n\nstatic struct pnp_driver cadet_pnp_driver = {\n\t.name\t\t= \"radio-cadet\",\n\t.id_table\t= cadet_pnp_devices,\n\t.probe\t\t= cadet_pnp_probe,\n\t.remove\t\t= NULL,\n};\n\n#else\nstatic struct pnp_driver cadet_pnp_driver;\n#endif\n\nstatic void cadet_probe(struct cadet *dev)\n{\n\tstatic int iovals[8] = { 0x330, 0x332, 0x334, 0x336, 0x338, 0x33a, 0x33c, 0x33e };\n\tint i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tdev->io = iovals[i];\n\t\tif (request_region(dev->io, 2, \"cadet-probe\")) {\n\t\t\tcadet_setfreq(dev, bands[1].rangelow);\n\t\t\tif (cadet_getfreq(dev) == bands[1].rangelow) {\n\t\t\t\trelease_region(dev->io, 2);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trelease_region(dev->io, 2);\n\t\t}\n\t}\n\tdev->io = -1;\n}\n\n \n\nstatic int __init cadet_init(void)\n{\n\tstruct cadet *dev = &cadet_card;\n\tstruct v4l2_device *v4l2_dev = &dev->v4l2_dev;\n\tstruct v4l2_ctrl_handler *hdl;\n\tint res = -ENODEV;\n\n\tstrscpy(v4l2_dev->name, \"cadet\", sizeof(v4l2_dev->name));\n\tmutex_init(&dev->lock);\n\n\t \n\tif (io < 0)\n\t\tpnp_register_driver(&cadet_pnp_driver);\n\tdev->io = io;\n\n\t \n\tif (dev->io < 0)\n\t\tcadet_probe(dev);\n\n\t \n\tif (dev->io < 0) {\n#ifdef MODULE\n\t\tv4l2_err(v4l2_dev, \"you must set an I/O address with io=0x330, 0x332, 0x334,\\n\");\n\t\tv4l2_err(v4l2_dev, \"0x336, 0x338, 0x33a, 0x33c or 0x33e\\n\");\n#endif\n\t\tgoto fail;\n\t}\n\tif (!request_region(dev->io, 2, \"cadet\"))\n\t\tgoto fail;\n\n\tres = v4l2_device_register(NULL, v4l2_dev);\n\tif (res < 0) {\n\t\trelease_region(dev->io, 2);\n\t\tv4l2_err(v4l2_dev, \"could not register v4l2_device\\n\");\n\t\tgoto fail;\n\t}\n\n\thdl = &dev->ctrl_handler;\n\tv4l2_ctrl_handler_init(hdl, 2);\n\tv4l2_ctrl_new_std(hdl, &cadet_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\n\tv4l2_dev->ctrl_handler = hdl;\n\tif (hdl->error) {\n\t\tres = hdl->error;\n\t\tv4l2_err(v4l2_dev, \"Could not register controls\\n\");\n\t\tgoto err_hdl;\n\t}\n\n\tdev->is_fm_band = true;\n\tdev->curfreq = bands[dev->is_fm_band].rangelow;\n\tcadet_setfreq(dev, dev->curfreq);\n\tstrscpy(dev->vdev.name, v4l2_dev->name, sizeof(dev->vdev.name));\n\tdev->vdev.v4l2_dev = v4l2_dev;\n\tdev->vdev.fops = &cadet_fops;\n\tdev->vdev.ioctl_ops = &cadet_ioctl_ops;\n\tdev->vdev.release = video_device_release_empty;\n\tdev->vdev.lock = &dev->lock;\n\tdev->vdev.device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO |\n\t\t\t\tV4L2_CAP_READWRITE | V4L2_CAP_RDS_CAPTURE;\n\tvideo_set_drvdata(&dev->vdev, dev);\n\n\tres = video_register_device(&dev->vdev, VFL_TYPE_RADIO, radio_nr);\n\tif (res < 0)\n\t\tgoto err_hdl;\n\tv4l2_info(v4l2_dev, \"ADS Cadet Radio Card at 0x%x\\n\", dev->io);\n\treturn 0;\nerr_hdl:\n\tv4l2_ctrl_handler_free(hdl);\n\tv4l2_device_unregister(v4l2_dev);\n\trelease_region(dev->io, 2);\nfail:\n\tpnp_unregister_driver(&cadet_pnp_driver);\n\treturn res;\n}\n\nstatic void __exit cadet_exit(void)\n{\n\tstruct cadet *dev = &cadet_card;\n\n\tvideo_unregister_device(&dev->vdev);\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\toutb(7, dev->io);\t \n\toutb(0x00, dev->io + 1);\n\trelease_region(dev->io, 2);\n\tpnp_unregister_driver(&cadet_pnp_driver);\n}\n\nmodule_init(cadet_init);\nmodule_exit(cadet_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}