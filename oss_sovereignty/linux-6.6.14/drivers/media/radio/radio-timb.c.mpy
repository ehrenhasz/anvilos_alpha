{
  "module_name": "radio-timb.c",
  "hash_id": "3068c090bd77119e4611d2e9886963ee066d1e15bdccb81fc0bea171e772cf8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/radio-timb.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/platform_data/media/timb_radio.h>\n\n#define DRIVER_NAME \"timb-radio\"\n\nstruct timbradio {\n\tstruct timb_radio_platform_data\tpdata;\n\tstruct v4l2_subdev\t*sd_tuner;\n\tstruct v4l2_subdev\t*sd_dsp;\n\tstruct video_device\tvideo_dev;\n\tstruct v4l2_device\tv4l2_dev;\n\tstruct mutex\t\tlock;\n};\n\n\nstatic int timbradio_vidioc_querycap(struct file *file, void  *priv,\n\tstruct v4l2_capability *v)\n{\n\tstrscpy(v->driver, DRIVER_NAME, sizeof(v->driver));\n\tstrscpy(v->card, \"Timberdale Radio\", sizeof(v->card));\n\tsnprintf(v->bus_info, sizeof(v->bus_info), \"platform:\"DRIVER_NAME);\n\treturn 0;\n}\n\nstatic int timbradio_vidioc_g_tuner(struct file *file, void *priv,\n\tstruct v4l2_tuner *v)\n{\n\tstruct timbradio *tr = video_drvdata(file);\n\treturn v4l2_subdev_call(tr->sd_tuner, tuner, g_tuner, v);\n}\n\nstatic int timbradio_vidioc_s_tuner(struct file *file, void *priv,\n\tconst struct v4l2_tuner *v)\n{\n\tstruct timbradio *tr = video_drvdata(file);\n\treturn v4l2_subdev_call(tr->sd_tuner, tuner, s_tuner, v);\n}\n\nstatic int timbradio_vidioc_s_frequency(struct file *file, void *priv,\n\tconst struct v4l2_frequency *f)\n{\n\tstruct timbradio *tr = video_drvdata(file);\n\treturn v4l2_subdev_call(tr->sd_tuner, tuner, s_frequency, f);\n}\n\nstatic int timbradio_vidioc_g_frequency(struct file *file, void *priv,\n\tstruct v4l2_frequency *f)\n{\n\tstruct timbradio *tr = video_drvdata(file);\n\treturn v4l2_subdev_call(tr->sd_tuner, tuner, g_frequency, f);\n}\n\nstatic const struct v4l2_ioctl_ops timbradio_ioctl_ops = {\n\t.vidioc_querycap\t= timbradio_vidioc_querycap,\n\t.vidioc_g_tuner\t\t= timbradio_vidioc_g_tuner,\n\t.vidioc_s_tuner\t\t= timbradio_vidioc_s_tuner,\n\t.vidioc_g_frequency\t= timbradio_vidioc_g_frequency,\n\t.vidioc_s_frequency\t= timbradio_vidioc_s_frequency,\n\t.vidioc_log_status      = v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic const struct v4l2_file_operations timbradio_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= v4l2_fh_open,\n\t.release\t= v4l2_fh_release,\n\t.poll\t\t= v4l2_ctrl_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n};\n\nstatic int timbradio_probe(struct platform_device *pdev)\n{\n\tstruct timb_radio_platform_data *pdata = pdev->dev.platform_data;\n\tstruct timbradio *tr;\n\tint err;\n\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"Platform data missing\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\ttr = devm_kzalloc(&pdev->dev, sizeof(*tr), GFP_KERNEL);\n\tif (!tr) {\n\t\terr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\ttr->pdata = *pdata;\n\tmutex_init(&tr->lock);\n\n\tstrscpy(tr->video_dev.name, \"Timberdale Radio\",\n\t\tsizeof(tr->video_dev.name));\n\ttr->video_dev.fops = &timbradio_fops;\n\ttr->video_dev.ioctl_ops = &timbradio_ioctl_ops;\n\ttr->video_dev.release = video_device_release_empty;\n\ttr->video_dev.minor = -1;\n\ttr->video_dev.lock = &tr->lock;\n\ttr->video_dev.device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;\n\n\tstrscpy(tr->v4l2_dev.name, DRIVER_NAME, sizeof(tr->v4l2_dev.name));\n\terr = v4l2_device_register(NULL, &tr->v4l2_dev);\n\tif (err)\n\t\tgoto err;\n\n\ttr->video_dev.v4l2_dev = &tr->v4l2_dev;\n\n\ttr->sd_tuner = v4l2_i2c_new_subdev_board(&tr->v4l2_dev,\n\t\ti2c_get_adapter(pdata->i2c_adapter), pdata->tuner, NULL);\n\ttr->sd_dsp = v4l2_i2c_new_subdev_board(&tr->v4l2_dev,\n\t\ti2c_get_adapter(pdata->i2c_adapter), pdata->dsp, NULL);\n\tif (tr->sd_tuner == NULL || tr->sd_dsp == NULL) {\n\t\terr = -ENODEV;\n\t\tgoto err_video_req;\n\t}\n\n\ttr->v4l2_dev.ctrl_handler = tr->sd_dsp->ctrl_handler;\n\n\terr = video_register_device(&tr->video_dev, VFL_TYPE_RADIO, -1);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Error reg video\\n\");\n\t\tgoto err_video_req;\n\t}\n\n\tvideo_set_drvdata(&tr->video_dev, tr);\n\n\tplatform_set_drvdata(pdev, tr);\n\treturn 0;\n\nerr_video_req:\n\tv4l2_device_unregister(&tr->v4l2_dev);\nerr:\n\tdev_err(&pdev->dev, \"Failed to register: %d\\n\", err);\n\n\treturn err;\n}\n\nstatic void timbradio_remove(struct platform_device *pdev)\n{\n\tstruct timbradio *tr = platform_get_drvdata(pdev);\n\n\tvideo_unregister_device(&tr->video_dev);\n\tv4l2_device_unregister(&tr->v4l2_dev);\n}\n\nstatic struct platform_driver timbradio_platform_driver = {\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t},\n\t.probe\t\t= timbradio_probe,\n\t.remove_new\t= timbradio_remove,\n};\n\nmodule_platform_driver(timbradio_platform_driver);\n\nMODULE_DESCRIPTION(\"Timberdale Radio driver\");\nMODULE_AUTHOR(\"Mocean Laboratories <info@mocean-labs.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(\"0.0.2\");\nMODULE_ALIAS(\"platform:\"DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}