{
  "module_name": "tea575x.c",
  "hash_id": "eb9997b913d78bb7dda34df45feb5f4ba31696201fcc81ede64ae7010836bd94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/tea575x.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <asm/io.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include <media/drv-intf/tea575x.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Routines for control of TEA5757/5759 Philips AM/FM radio tuner chips\");\nMODULE_LICENSE(\"GPL\");\n\n \n\n#define TEA575X_BIT_SEARCH\t(1<<24)\t\t \n#define TEA575X_BIT_UPDOWN\t(1<<23)\t\t \n#define TEA575X_BIT_MONO\t(1<<22)\t\t \n#define TEA575X_BIT_BAND_MASK\t(3<<20)\n#define TEA575X_BIT_BAND_FM\t(0<<20)\n#define TEA575X_BIT_BAND_MW\t(1<<20)\n#define TEA575X_BIT_BAND_LW\t(2<<20)\n#define TEA575X_BIT_BAND_SW\t(3<<20)\n#define TEA575X_BIT_PORT_0\t(1<<19)\t\t \n#define TEA575X_BIT_PORT_1\t(1<<18)\t\t \n#define TEA575X_BIT_SEARCH_MASK\t(3<<16)\t\t \n#define TEA575X_BIT_SEARCH_5_28\t     (0<<16)\t \n#define TEA575X_BIT_SEARCH_10_40     (1<<16)\t \n#define TEA575X_BIT_SEARCH_30_63     (2<<16)\t \n#define TEA575X_BIT_SEARCH_150_1000  (3<<16)\t \n#define TEA575X_BIT_DUMMY\t(1<<15)\t\t \n#define TEA575X_BIT_FREQ_MASK\t0x7fff\n\nenum { BAND_FM, BAND_FM_JAPAN, BAND_AM };\n\nstatic const struct v4l2_frequency_band bands[] = {\n\t{\n\t\t.type = V4L2_TUNER_RADIO,\n\t\t.index = 0,\n\t\t.capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO |\n\t\t\t      V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   =  87500 * 16,\n\t\t.rangehigh  = 108000 * 16,\n\t\t.modulation = V4L2_BAND_MODULATION_FM,\n\t},\n\t{\n\t\t.type = V4L2_TUNER_RADIO,\n\t\t.index = 0,\n\t\t.capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO |\n\t\t\t      V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   = 76000 * 16,\n\t\t.rangehigh  = 91000 * 16,\n\t\t.modulation = V4L2_BAND_MODULATION_FM,\n\t},\n\t{\n\t\t.type = V4L2_TUNER_RADIO,\n\t\t.index = 1,\n\t\t.capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   =  530 * 16,\n\t\t.rangehigh  = 1710 * 16,\n\t\t.modulation = V4L2_BAND_MODULATION_AM,\n\t},\n};\n\n \n\nstatic void snd_tea575x_write(struct snd_tea575x *tea, unsigned int val)\n{\n\tu16 l;\n\tu8 data;\n\n\tif (tea->ops->write_val)\n\t\treturn tea->ops->write_val(tea, val);\n\n\ttea->ops->set_direction(tea, 1);\n\tudelay(16);\n\n\tfor (l = 25; l > 0; l--) {\n\t\tdata = (val >> 24) & TEA575X_DATA;\n\t\tval <<= 1;\t\t\t \n\t\ttea->ops->set_pins(tea, data | TEA575X_WREN);\n\t\tudelay(2);\n\t\ttea->ops->set_pins(tea, data | TEA575X_WREN | TEA575X_CLK);\n\t\tudelay(2);\n\t\ttea->ops->set_pins(tea, data | TEA575X_WREN);\n\t\tudelay(2);\n\t}\n\n\tif (!tea->mute)\n\t\ttea->ops->set_pins(tea, 0);\n}\n\nstatic u32 snd_tea575x_read(struct snd_tea575x *tea)\n{\n\tu16 l, rdata;\n\tu32 data = 0;\n\n\tif (tea->ops->read_val)\n\t\treturn tea->ops->read_val(tea);\n\n\ttea->ops->set_direction(tea, 0);\n\ttea->ops->set_pins(tea, 0);\n\tudelay(16);\n\n\tfor (l = 24; l--;) {\n\t\ttea->ops->set_pins(tea, TEA575X_CLK);\n\t\tudelay(2);\n\t\tif (!l)\n\t\t\ttea->tuned = tea->ops->get_pins(tea) & TEA575X_MOST ? 0 : 1;\n\t\ttea->ops->set_pins(tea, 0);\n\t\tudelay(2);\n\t\tdata <<= 1;\t\t\t \n\t\trdata = tea->ops->get_pins(tea);\n\t\tif (!l)\n\t\t\ttea->stereo = (rdata & TEA575X_MOST) ?  0 : 1;\n\t\tif (rdata & TEA575X_DATA)\n\t\t\tdata++;\n\t\tudelay(2);\n\t}\n\n\tif (tea->mute)\n\t\ttea->ops->set_pins(tea, TEA575X_WREN);\n\n\treturn data;\n}\n\nstatic u32 snd_tea575x_val_to_freq(struct snd_tea575x *tea, u32 val)\n{\n\tu32 freq = val & TEA575X_BIT_FREQ_MASK;\n\n\tif (freq == 0)\n\t\treturn freq;\n\n\tswitch (tea->band) {\n\tcase BAND_FM:\n\t\t \n\t\tfreq *= 125;\n\t\tfreq /= 10;\n\t\t \n\t\tfreq -= TEA575X_FMIF;\n\t\tbreak;\n\tcase BAND_FM_JAPAN:\n\t\t \n\t\tfreq *= 125;\n\t\tfreq /= 10;\n\t\t \n\t\tfreq += TEA575X_FMIF;\n\t\tbreak;\n\tcase BAND_AM:\n\t\t \n\t\tfreq -= TEA575X_AMIF;\n\t\tbreak;\n\t}\n\n\treturn clamp(freq * 16, bands[tea->band].rangelow,\n\t\t\t\tbands[tea->band].rangehigh);  \n}\n\nstatic u32 snd_tea575x_get_freq(struct snd_tea575x *tea)\n{\n\treturn snd_tea575x_val_to_freq(tea, snd_tea575x_read(tea));\n}\n\nvoid snd_tea575x_set_freq(struct snd_tea575x *tea)\n{\n\tu32 freq = tea->freq / 16;\t \n\tu32 band = 0;\n\n\tswitch (tea->band) {\n\tcase BAND_FM:\n\t\tband = TEA575X_BIT_BAND_FM;\n\t\t \n\t\tfreq += TEA575X_FMIF;\n\t\t \n\t\tfreq *= 10;\n\t\tfreq /= 125;\n\t\tbreak;\n\tcase BAND_FM_JAPAN:\n\t\tband = TEA575X_BIT_BAND_FM;\n\t\t \n\t\tfreq -= TEA575X_FMIF;\n\t\t \n\t\tfreq *= 10;\n\t\tfreq /= 125;\n\t\tbreak;\n\tcase BAND_AM:\n\t\tband = TEA575X_BIT_BAND_MW;\n\t\t \n\t\tfreq += TEA575X_AMIF;\n\t\tbreak;\n\t}\n\n\ttea->val &= ~(TEA575X_BIT_FREQ_MASK | TEA575X_BIT_BAND_MASK);\n\ttea->val |= band;\n\ttea->val |= freq & TEA575X_BIT_FREQ_MASK;\n\tsnd_tea575x_write(tea, tea->val);\n\ttea->freq = snd_tea575x_val_to_freq(tea, tea->val);\n}\nEXPORT_SYMBOL(snd_tea575x_set_freq);\n\n \n\nstatic int vidioc_querycap(struct file *file, void  *priv,\n\t\t\t\t\tstruct v4l2_capability *v)\n{\n\tstruct snd_tea575x *tea = video_drvdata(file);\n\n\tstrscpy(v->driver, tea->v4l2_dev->name, sizeof(v->driver));\n\tstrscpy(v->card, tea->card, sizeof(v->card));\n\tstrlcat(v->card, tea->tea5759 ? \" TEA5759\" : \" TEA5757\", sizeof(v->card));\n\tstrscpy(v->bus_info, tea->bus_info, sizeof(v->bus_info));\n\treturn 0;\n}\n\nint snd_tea575x_enum_freq_bands(struct snd_tea575x *tea,\n\t\t\t\t\tstruct v4l2_frequency_band *band)\n{\n\tint index;\n\n\tif (band->tuner != 0)\n\t\treturn -EINVAL;\n\n\tswitch (band->index) {\n\tcase 0:\n\t\tif (tea->tea5759)\n\t\t\tindex = BAND_FM_JAPAN;\n\t\telse\n\t\t\tindex = BAND_FM;\n\t\tbreak;\n\tcase 1:\n\t\tif (tea->has_am) {\n\t\t\tindex = BAND_AM;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*band = bands[index];\n\tif (!tea->cannot_read_data)\n\t\tband->capability |= V4L2_TUNER_CAP_HWSEEK_BOUNDED;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_tea575x_enum_freq_bands);\n\nstatic int vidioc_enum_freq_bands(struct file *file, void *priv,\n\t\t\t\t\t struct v4l2_frequency_band *band)\n{\n\tstruct snd_tea575x *tea = video_drvdata(file);\n\n\treturn snd_tea575x_enum_freq_bands(tea, band);\n}\n\nint snd_tea575x_g_tuner(struct snd_tea575x *tea, struct v4l2_tuner *v)\n{\n\tstruct v4l2_frequency_band band_fm = { 0, };\n\n\tif (v->index > 0)\n\t\treturn -EINVAL;\n\n\tsnd_tea575x_read(tea);\n\tsnd_tea575x_enum_freq_bands(tea, &band_fm);\n\n\tmemset(v, 0, sizeof(*v));\n\tstrscpy(v->name, tea->has_am ? \"FM/AM\" : \"FM\", sizeof(v->name));\n\tv->type = V4L2_TUNER_RADIO;\n\tv->capability = band_fm.capability;\n\tv->rangelow = tea->has_am ? bands[BAND_AM].rangelow : band_fm.rangelow;\n\tv->rangehigh = band_fm.rangehigh;\n\tv->rxsubchans = tea->stereo ? V4L2_TUNER_SUB_STEREO : V4L2_TUNER_SUB_MONO;\n\tv->audmode = (tea->val & TEA575X_BIT_MONO) ?\n\t\tV4L2_TUNER_MODE_MONO : V4L2_TUNER_MODE_STEREO;\n\tv->signal = tea->tuned ? 0xffff : 0;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_tea575x_g_tuner);\n\nstatic int vidioc_g_tuner(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_tuner *v)\n{\n\tstruct snd_tea575x *tea = video_drvdata(file);\n\n\treturn snd_tea575x_g_tuner(tea, v);\n}\n\nstatic int vidioc_s_tuner(struct file *file, void *priv,\n\t\t\t\t\tconst struct v4l2_tuner *v)\n{\n\tstruct snd_tea575x *tea = video_drvdata(file);\n\tu32 orig_val = tea->val;\n\n\tif (v->index)\n\t\treturn -EINVAL;\n\ttea->val &= ~TEA575X_BIT_MONO;\n\tif (v->audmode == V4L2_TUNER_MODE_MONO)\n\t\ttea->val |= TEA575X_BIT_MONO;\n\t \n\tif (tea->band != BAND_AM && tea->val != orig_val)\n\t\tsnd_tea575x_set_freq(tea);\n\n\treturn 0;\n}\n\nstatic int vidioc_g_frequency(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_frequency *f)\n{\n\tstruct snd_tea575x *tea = video_drvdata(file);\n\n\tif (f->tuner != 0)\n\t\treturn -EINVAL;\n\tf->type = V4L2_TUNER_RADIO;\n\tf->frequency = tea->freq;\n\treturn 0;\n}\n\nstatic int vidioc_s_frequency(struct file *file, void *priv,\n\t\t\t\t\tconst struct v4l2_frequency *f)\n{\n\tstruct snd_tea575x *tea = video_drvdata(file);\n\n\tif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\n\t\treturn -EINVAL;\n\n\tif (tea->has_am && f->frequency < (20000 * 16))\n\t\ttea->band = BAND_AM;\n\telse if (tea->tea5759)\n\t\ttea->band = BAND_FM_JAPAN;\n\telse\n\t\ttea->band = BAND_FM;\n\n\ttea->freq = clamp_t(u32, f->frequency, bands[tea->band].rangelow,\n\t\t\t\t\tbands[tea->band].rangehigh);\n\tsnd_tea575x_set_freq(tea);\n\treturn 0;\n}\n\nint snd_tea575x_s_hw_freq_seek(struct file *file, struct snd_tea575x *tea,\n\t\t\t\tconst struct v4l2_hw_freq_seek *a)\n{\n\tunsigned long timeout;\n\tint i, spacing;\n\n\tif (tea->cannot_read_data)\n\t\treturn -ENOTTY;\n\tif (a->tuner || a->wrap_around)\n\t\treturn -EINVAL;\n\n\tif (file->f_flags & O_NONBLOCK)\n\t\treturn -EWOULDBLOCK;\n\n\tif (a->rangelow || a->rangehigh) {\n\t\tfor (i = 0; i < ARRAY_SIZE(bands); i++) {\n\t\t\tif ((i == BAND_FM && tea->tea5759) ||\n\t\t\t    (i == BAND_FM_JAPAN && !tea->tea5759) ||\n\t\t\t    (i == BAND_AM && !tea->has_am))\n\t\t\t\tcontinue;\n\t\t\tif (bands[i].rangelow  == a->rangelow &&\n\t\t\t    bands[i].rangehigh == a->rangehigh)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == ARRAY_SIZE(bands))\n\t\t\treturn -EINVAL;  \n\t\tif (i != tea->band) {\n\t\t\ttea->band = i;\n\t\t\ttea->freq = clamp(tea->freq, bands[i].rangelow,\n\t\t\t\t\t\t     bands[i].rangehigh);\n\t\t\tsnd_tea575x_set_freq(tea);\n\t\t}\n\t}\n\n\tspacing = (tea->band == BAND_AM) ? 5 : 50;  \n\n\t \n\ttea->val &= ~TEA575X_BIT_FREQ_MASK;\n\ttea->val |= TEA575X_BIT_SEARCH;\n\tif (a->seek_upward)\n\t\ttea->val |= TEA575X_BIT_UPDOWN;\n\telse\n\t\ttea->val &= ~TEA575X_BIT_UPDOWN;\n\tsnd_tea575x_write(tea, tea->val);\n\ttimeout = jiffies + msecs_to_jiffies(10000);\n\tfor (;;) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\t\tif (schedule_timeout_interruptible(msecs_to_jiffies(10))) {\n\t\t\t \n\t\t\ttea->val &= ~TEA575X_BIT_SEARCH;\n\t\t\tsnd_tea575x_set_freq(tea);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t\tif (!(snd_tea575x_read(tea) & TEA575X_BIT_SEARCH)) {\n\t\t\tu32 freq;\n\n\t\t\t \n\t\t\tfor (i = 0; i < 100; i++) {\n\t\t\t\tmsleep(10);\n\t\t\t\tfreq = snd_tea575x_get_freq(tea);\n\t\t\t\tif (freq)  \n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (freq == 0)  \n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (abs(tea->freq - freq) < 16 * spacing ||\n\t\t\t\t\t(a->seek_upward && freq < tea->freq) ||\n\t\t\t\t\t(!a->seek_upward && freq > tea->freq)) {\n\t\t\t\tsnd_tea575x_write(tea, tea->val);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttea->freq = freq;\n\t\t\ttea->val &= ~TEA575X_BIT_SEARCH;\n\t\t\treturn 0;\n\t\t}\n\t}\n\ttea->val &= ~TEA575X_BIT_SEARCH;\n\tsnd_tea575x_set_freq(tea);\n\treturn -ENODATA;\n}\nEXPORT_SYMBOL(snd_tea575x_s_hw_freq_seek);\n\nstatic int vidioc_s_hw_freq_seek(struct file *file, void *fh,\n\t\t\t\t\tconst struct v4l2_hw_freq_seek *a)\n{\n\tstruct snd_tea575x *tea = video_drvdata(file);\n\n\treturn snd_tea575x_s_hw_freq_seek(file, tea, a);\n}\n\nstatic int tea575x_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct snd_tea575x *tea = container_of(ctrl->handler, struct snd_tea575x, ctrl_handler);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\ttea->mute = ctrl->val;\n\t\tsnd_tea575x_set_freq(tea);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct v4l2_file_operations tea575x_fops = {\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.open           = v4l2_fh_open,\n\t.release        = v4l2_fh_release,\n\t.poll           = v4l2_ctrl_poll,\n};\n\nstatic const struct v4l2_ioctl_ops tea575x_ioctl_ops = {\n\t.vidioc_querycap    = vidioc_querycap,\n\t.vidioc_g_tuner     = vidioc_g_tuner,\n\t.vidioc_s_tuner     = vidioc_s_tuner,\n\t.vidioc_g_frequency = vidioc_g_frequency,\n\t.vidioc_s_frequency = vidioc_s_frequency,\n\t.vidioc_s_hw_freq_seek = vidioc_s_hw_freq_seek,\n\t.vidioc_enum_freq_bands = vidioc_enum_freq_bands,\n\t.vidioc_log_status  = v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic const struct video_device tea575x_radio = {\n\t.ioctl_ops\t= &tea575x_ioctl_ops,\n\t.release        = video_device_release_empty,\n};\n\nstatic const struct v4l2_ctrl_ops tea575x_ctrl_ops = {\n\t.s_ctrl = tea575x_s_ctrl,\n};\n\n\nint snd_tea575x_hw_init(struct snd_tea575x *tea)\n{\n\ttea->mute = true;\n\n\t \n\tif (!tea->cannot_read_data) {\n\t\tsnd_tea575x_write(tea, 0x55AA);\n\t\tif (snd_tea575x_read(tea) != 0x55AA)\n\t\t\treturn -ENODEV;\n\t}\n\n\ttea->val = TEA575X_BIT_BAND_FM | TEA575X_BIT_SEARCH_5_28;\n\ttea->freq = 90500 * 16;\t\t \n\tsnd_tea575x_set_freq(tea);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_tea575x_hw_init);\n\nint snd_tea575x_init(struct snd_tea575x *tea, struct module *owner)\n{\n\tint retval = snd_tea575x_hw_init(tea);\n\n\tif (retval)\n\t\treturn retval;\n\n\ttea->vd = tea575x_radio;\n\tvideo_set_drvdata(&tea->vd, tea);\n\tmutex_init(&tea->mutex);\n\tstrscpy(tea->vd.name, tea->v4l2_dev->name, sizeof(tea->vd.name));\n\ttea->vd.lock = &tea->mutex;\n\ttea->vd.v4l2_dev = tea->v4l2_dev;\n\ttea->vd.device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;\n\tif (!tea->cannot_read_data)\n\t\ttea->vd.device_caps |= V4L2_CAP_HW_FREQ_SEEK;\n\ttea->fops = tea575x_fops;\n\ttea->fops.owner = owner;\n\ttea->vd.fops = &tea->fops;\n\t \n\tif (tea->cannot_read_data)\n\t\tv4l2_disable_ioctl(&tea->vd, VIDIOC_S_HW_FREQ_SEEK);\n\n\tif (!tea->cannot_mute) {\n\t\ttea->vd.ctrl_handler = &tea->ctrl_handler;\n\t\tv4l2_ctrl_handler_init(&tea->ctrl_handler, 1);\n\t\tv4l2_ctrl_new_std(&tea->ctrl_handler, &tea575x_ctrl_ops,\n\t\t\t\t  V4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\n\t\tretval = tea->ctrl_handler.error;\n\t\tif (retval) {\n\t\t\tv4l2_err(tea->v4l2_dev, \"can't initialize controls\\n\");\n\t\t\tv4l2_ctrl_handler_free(&tea->ctrl_handler);\n\t\t\treturn retval;\n\t\t}\n\n\t\tif (tea->ext_init) {\n\t\t\tretval = tea->ext_init(tea);\n\t\t\tif (retval) {\n\t\t\t\tv4l2_ctrl_handler_free(&tea->ctrl_handler);\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\n\t\tv4l2_ctrl_handler_setup(&tea->ctrl_handler);\n\t}\n\n\tretval = video_register_device(&tea->vd, VFL_TYPE_RADIO, tea->radio_nr);\n\tif (retval) {\n\t\tv4l2_err(tea->v4l2_dev, \"can't register video device!\\n\");\n\t\tv4l2_ctrl_handler_free(tea->vd.ctrl_handler);\n\t\treturn retval;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_tea575x_init);\n\nvoid snd_tea575x_exit(struct snd_tea575x *tea)\n{\n\tvideo_unregister_device(&tea->vd);\n\tv4l2_ctrl_handler_free(tea->vd.ctrl_handler);\n}\nEXPORT_SYMBOL(snd_tea575x_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}