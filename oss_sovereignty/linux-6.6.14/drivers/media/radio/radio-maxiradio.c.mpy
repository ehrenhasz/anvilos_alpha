{
  "module_name": "radio-maxiradio.c",
  "hash_id": "e78187fa614b42e595fc483c57917ddfeac5ed622c911ce594aae1aa455fa9ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/radio-maxiradio.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/videodev2.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <media/drv-intf/tea575x.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n\nMODULE_AUTHOR(\"Dimitromanolakis Apostolos, apdim@grecian.net\");\nMODULE_DESCRIPTION(\"Radio driver for the Guillemot Maxi Radio FM2000.\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"1.0.0\");\n\nstatic int radio_nr = -1;\nmodule_param(radio_nr, int, 0644);\nMODULE_PARM_DESC(radio_nr, \"Radio device number\");\n\n \nstatic const int clk = 1, data = 2, wren = 4, mo_st = 8, power = 16;\n\nstatic atomic_t maxiradio_instance = ATOMIC_INIT(0);\n\n#define PCI_VENDOR_ID_GUILLEMOT 0x5046\n#define PCI_DEVICE_ID_GUILLEMOT_MAXIRADIO 0x1001\n\nstruct maxiradio\n{\n\tstruct snd_tea575x tea;\n\tstruct v4l2_device v4l2_dev;\n\tstruct pci_dev *pdev;\n\n\tu16\tio;\t \n};\n\nstatic inline struct maxiradio *to_maxiradio(struct v4l2_device *v4l2_dev)\n{\n\treturn container_of(v4l2_dev, struct maxiradio, v4l2_dev);\n}\n\nstatic void maxiradio_tea575x_set_pins(struct snd_tea575x *tea, u8 pins)\n{\n\tstruct maxiradio *dev = tea->private_data;\n\tu8 bits = 0;\n\n\tbits |= (pins & TEA575X_DATA) ? data : 0;\n\tbits |= (pins & TEA575X_CLK)  ? clk  : 0;\n\tbits |= (pins & TEA575X_WREN) ? wren : 0;\n\tbits |= power;\n\n\toutb(bits, dev->io);\n}\n\n \nstatic u8 maxiradio_tea575x_get_pins(struct snd_tea575x *tea)\n{\n\tstruct maxiradio *dev = tea->private_data;\n\tu8 bits = inb(dev->io);\n\n\treturn  ((bits & data) ? TEA575X_DATA : 0) |\n\t\t((bits & mo_st) ? TEA575X_MOST : 0);\n}\n\nstatic void maxiradio_tea575x_set_direction(struct snd_tea575x *tea, bool output)\n{\n}\n\nstatic const struct snd_tea575x_ops maxiradio_tea_ops = {\n\t.set_pins = maxiradio_tea575x_set_pins,\n\t.get_pins = maxiradio_tea575x_get_pins,\n\t.set_direction = maxiradio_tea575x_set_direction,\n};\n\nstatic int maxiradio_probe(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *ent)\n{\n\tstruct maxiradio *dev;\n\tstruct v4l2_device *v4l2_dev;\n\tint retval = -ENOMEM;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (dev == NULL) {\n\t\tdev_err(&pdev->dev, \"not enough memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tv4l2_dev = &dev->v4l2_dev;\n\tv4l2_device_set_name(v4l2_dev, \"maxiradio\", &maxiradio_instance);\n\n\tretval = v4l2_device_register(&pdev->dev, v4l2_dev);\n\tif (retval < 0) {\n\t\tv4l2_err(v4l2_dev, \"Could not register v4l2_device\\n\");\n\t\tgoto errfr;\n\t}\n\tdev->tea.private_data = dev;\n\tdev->tea.ops = &maxiradio_tea_ops;\n\t \n\tdev->tea.cannot_read_data = true;\n\tdev->tea.v4l2_dev = v4l2_dev;\n\tdev->tea.radio_nr = radio_nr;\n\tstrscpy(dev->tea.card, \"Maxi Radio FM2000\", sizeof(dev->tea.card));\n\n\tretval = -ENODEV;\n\n\tif (!request_region(pci_resource_start(pdev, 0),\n\t\t\t   pci_resource_len(pdev, 0), v4l2_dev->name)) {\n\t\tdev_err(&pdev->dev, \"can't reserve I/O ports\\n\");\n\t\tgoto err_hdl;\n\t}\n\n\tif (pci_enable_device(pdev))\n\t\tgoto err_out_free_region;\n\n\tdev->io = pci_resource_start(pdev, 0);\n\tif (snd_tea575x_init(&dev->tea, THIS_MODULE)) {\n\t\tprintk(KERN_ERR \"radio-maxiradio: Unable to detect TEA575x tuner\\n\");\n\t\tgoto err_out_free_region;\n\t}\n\treturn 0;\n\nerr_out_free_region:\n\trelease_region(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));\nerr_hdl:\n\tv4l2_device_unregister(v4l2_dev);\nerrfr:\n\tkfree(dev);\n\treturn retval;\n}\n\nstatic void maxiradio_remove(struct pci_dev *pdev)\n{\n\tstruct v4l2_device *v4l2_dev = pci_get_drvdata(pdev);\n\tstruct maxiradio *dev = to_maxiradio(v4l2_dev);\n\n\tsnd_tea575x_exit(&dev->tea);\n\t \n\toutb(0, dev->io);\n\tv4l2_device_unregister(v4l2_dev);\n\trelease_region(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));\n\tkfree(dev);\n}\n\nstatic const struct pci_device_id maxiradio_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_GUILLEMOT, PCI_DEVICE_ID_GUILLEMOT_MAXIRADIO,\n\t\tPCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(pci, maxiradio_pci_tbl);\n\nstatic struct pci_driver maxiradio_driver = {\n\t.name\t\t= \"radio-maxiradio\",\n\t.id_table\t= maxiradio_pci_tbl,\n\t.probe\t\t= maxiradio_probe,\n\t.remove\t\t= maxiradio_remove,\n};\n\nmodule_pci_driver(maxiradio_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}