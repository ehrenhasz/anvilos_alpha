{
  "module_name": "radio-mr800.c",
  "hash_id": "f528a8cf9157f4333639c3ed3b155e4a82968074a70923ae68c206be308499e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/radio-mr800.c",
  "human_readable_source": "\n \n\n \n\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <linux/usb.h>\n#include <linux/mutex.h>\n\n \n#define DRIVER_AUTHOR \"Alexey Klimov <klimov.linux@gmail.com>\"\n#define DRIVER_DESC \"AverMedia MR 800 USB FM radio driver\"\n#define DRIVER_VERSION \"0.1.2\"\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRIVER_VERSION);\n\n#define USB_AMRADIO_VENDOR 0x07ca\n#define USB_AMRADIO_PRODUCT 0xb800\n\n \n#define MR800_DRIVER_NAME \"radio-mr800\"\n#define amradio_dev_warn(dev, fmt, arg...)\t\t\t\t\\\n\t\tdev_warn(dev, MR800_DRIVER_NAME \" - \" fmt, ##arg)\n\n#define amradio_dev_err(dev, fmt, arg...) \\\n\t\tdev_err(dev, MR800_DRIVER_NAME \" - \" fmt, ##arg)\n\n \n#define BUFFER_LENGTH 8\n#define USB_TIMEOUT 500\n\n \n#define FREQ_MIN  87.5\n#define FREQ_MAX 108.0\n#define FREQ_MUL 16000\n\n \n#define AMRADIO_SET_FREQ\t0xa4\n#define AMRADIO_GET_READY_FLAG\t0xa5\n#define AMRADIO_GET_SIGNAL\t0xa7\n#define AMRADIO_GET_FREQ\t0xa8\n#define AMRADIO_SET_SEARCH_UP\t0xa9\n#define AMRADIO_SET_SEARCH_DOWN\t0xaa\n#define AMRADIO_SET_MUTE\t0xab\n#define AMRADIO_SET_RIGHT_MUTE\t0xac\n#define AMRADIO_SET_LEFT_MUTE\t0xad\n#define AMRADIO_SET_MONO\t0xae\n#define AMRADIO_SET_SEARCH_LVL\t0xb0\n#define AMRADIO_STOP_SEARCH\t0xb1\n\n \n#define WANT_STEREO\t\t0x00\n#define WANT_MONO\t\t0x01\n\n \nstatic int radio_nr = -1;\nmodule_param(radio_nr, int, 0);\nMODULE_PARM_DESC(radio_nr, \"Radio Nr\");\n\n \nstruct amradio_device {\n\t \n\tstruct usb_device *usbdev;\n\tstruct usb_interface *intf;\n\tstruct video_device vdev;\n\tstruct v4l2_device v4l2_dev;\n\tstruct v4l2_ctrl_handler hdl;\n\n\tu8 *buffer;\n\tstruct mutex lock;\t \n\tint curfreq;\n\tint stereo;\n\tint muted;\n};\n\nstatic inline struct amradio_device *to_amradio_dev(struct v4l2_device *v4l2_dev)\n{\n\treturn container_of(v4l2_dev, struct amradio_device, v4l2_dev);\n}\n\nstatic int amradio_send_cmd(struct amradio_device *radio, u8 cmd, u8 arg,\n\t\tu8 *extra, u8 extralen, bool reply)\n{\n\tint retval;\n\tint size;\n\n\tradio->buffer[0] = 0x00;\n\tradio->buffer[1] = 0x55;\n\tradio->buffer[2] = 0xaa;\n\tradio->buffer[3] = extralen;\n\tradio->buffer[4] = cmd;\n\tradio->buffer[5] = arg;\n\tradio->buffer[6] = 0x00;\n\tradio->buffer[7] = extra || reply ? 8 : 0;\n\n\tretval = usb_bulk_msg(radio->usbdev, usb_sndintpipe(radio->usbdev, 2),\n\t\tradio->buffer, BUFFER_LENGTH, &size, USB_TIMEOUT);\n\n\tif (retval < 0 || size != BUFFER_LENGTH) {\n\t\tif (video_is_registered(&radio->vdev))\n\t\t\tamradio_dev_warn(&radio->vdev.dev,\n\t\t\t\t\t\"cmd %02x failed\\n\", cmd);\n\t\treturn retval ? retval : -EIO;\n\t}\n\tif (!extra && !reply)\n\t\treturn 0;\n\n\tif (extra) {\n\t\tmemcpy(radio->buffer, extra, extralen);\n\t\tmemset(radio->buffer + extralen, 0, 8 - extralen);\n\t\tretval = usb_bulk_msg(radio->usbdev, usb_sndintpipe(radio->usbdev, 2),\n\t\t\tradio->buffer, BUFFER_LENGTH, &size, USB_TIMEOUT);\n\t} else {\n\t\tmemset(radio->buffer, 0, 8);\n\t\tretval = usb_bulk_msg(radio->usbdev, usb_rcvbulkpipe(radio->usbdev, 0x81),\n\t\t\tradio->buffer, BUFFER_LENGTH, &size, USB_TIMEOUT);\n\t}\n\tif (retval == 0 && size == BUFFER_LENGTH)\n\t\treturn 0;\n\tif (video_is_registered(&radio->vdev) && cmd != AMRADIO_GET_READY_FLAG)\n\t\tamradio_dev_warn(&radio->vdev.dev, \"follow-up to cmd %02x failed\\n\", cmd);\n\treturn retval ? retval : -EIO;\n}\n\n \nstatic int amradio_set_mute(struct amradio_device *radio, bool mute)\n{\n\tint ret = amradio_send_cmd(radio,\n\t\t\tAMRADIO_SET_MUTE, mute, NULL, 0, false);\n\n\tif (!ret)\n\t\tradio->muted = mute;\n\treturn ret;\n}\n\n \nstatic int amradio_set_freq(struct amradio_device *radio, int freq)\n{\n\tunsigned short freq_send;\n\tu8 buf[3];\n\tint retval;\n\n\t \n\tfreq = clamp_t(unsigned, freq, FREQ_MIN * FREQ_MUL, FREQ_MAX * FREQ_MUL);\n\tfreq_send = 0x10 + (freq >> 3) / 25;\n\n\t \n\tbuf[0] = (freq_send >> 8) & 0xff;\n\tbuf[1] = freq_send & 0xff;\n\tbuf[2] = 0x01;\n\n\tretval = amradio_send_cmd(radio, AMRADIO_SET_FREQ, 0, buf, 3, false);\n\tif (retval)\n\t\treturn retval;\n\tradio->curfreq = freq;\n\tmsleep(40);\n\treturn 0;\n}\n\nstatic int amradio_set_stereo(struct amradio_device *radio, bool stereo)\n{\n\tint ret = amradio_send_cmd(radio,\n\t\t\tAMRADIO_SET_MONO, !stereo, NULL, 0, false);\n\n\tif (!ret)\n\t\tradio->stereo = stereo;\n\treturn ret;\n}\n\nstatic int amradio_get_stat(struct amradio_device *radio, bool *is_stereo, u32 *signal)\n{\n\tint ret = amradio_send_cmd(radio,\n\t\t\tAMRADIO_GET_SIGNAL, 0, NULL, 0, true);\n\n\tif (ret)\n\t\treturn ret;\n\t*is_stereo = radio->buffer[2] >> 7;\n\t*signal = (radio->buffer[3] & 0xf0) << 8;\n\treturn 0;\n}\n\n \nstatic void usb_amradio_disconnect(struct usb_interface *intf)\n{\n\tstruct amradio_device *radio = to_amradio_dev(usb_get_intfdata(intf));\n\n\tmutex_lock(&radio->lock);\n\tvideo_unregister_device(&radio->vdev);\n\tamradio_set_mute(radio, true);\n\tusb_set_intfdata(intf, NULL);\n\tv4l2_device_disconnect(&radio->v4l2_dev);\n\tmutex_unlock(&radio->lock);\n\tv4l2_device_put(&radio->v4l2_dev);\n}\n\n \nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_capability *v)\n{\n\tstruct amradio_device *radio = video_drvdata(file);\n\n\tstrscpy(v->driver, \"radio-mr800\", sizeof(v->driver));\n\tstrscpy(v->card, \"AverMedia MR 800 USB FM Radio\", sizeof(v->card));\n\tusb_make_path(radio->usbdev, v->bus_info, sizeof(v->bus_info));\n\treturn 0;\n}\n\n \nstatic int vidioc_g_tuner(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_tuner *v)\n{\n\tstruct amradio_device *radio = video_drvdata(file);\n\tbool is_stereo = false;\n\tint retval;\n\n\tif (v->index > 0)\n\t\treturn -EINVAL;\n\n\tv->signal = 0;\n\tretval = amradio_get_stat(radio, &is_stereo, &v->signal);\n\tif (retval)\n\t\treturn retval;\n\n\tstrscpy(v->name, \"FM\", sizeof(v->name));\n\tv->type = V4L2_TUNER_RADIO;\n\tv->rangelow = FREQ_MIN * FREQ_MUL;\n\tv->rangehigh = FREQ_MAX * FREQ_MUL;\n\tv->capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO |\n\t\tV4L2_TUNER_CAP_HWSEEK_WRAP;\n\tv->rxsubchans = is_stereo ? V4L2_TUNER_SUB_STEREO : V4L2_TUNER_SUB_MONO;\n\tv->audmode = radio->stereo ?\n\t\tV4L2_TUNER_MODE_STEREO : V4L2_TUNER_MODE_MONO;\n\treturn 0;\n}\n\n \nstatic int vidioc_s_tuner(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_tuner *v)\n{\n\tstruct amradio_device *radio = video_drvdata(file);\n\n\tif (v->index > 0)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (v->audmode) {\n\tcase V4L2_TUNER_MODE_MONO:\n\t\treturn amradio_set_stereo(radio, WANT_MONO);\n\tdefault:\n\t\treturn amradio_set_stereo(radio, WANT_STEREO);\n\t}\n}\n\n \nstatic int vidioc_s_frequency(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_frequency *f)\n{\n\tstruct amradio_device *radio = video_drvdata(file);\n\n\tif (f->tuner != 0)\n\t\treturn -EINVAL;\n\treturn amradio_set_freq(radio, f->frequency);\n}\n\n \nstatic int vidioc_g_frequency(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_frequency *f)\n{\n\tstruct amradio_device *radio = video_drvdata(file);\n\n\tif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\n\t\treturn -EINVAL;\n\tf->type = V4L2_TUNER_RADIO;\n\tf->frequency = radio->curfreq;\n\n\treturn 0;\n}\n\nstatic int vidioc_s_hw_freq_seek(struct file *file, void *priv,\n\t\tconst struct v4l2_hw_freq_seek *seek)\n{\n\tstatic u8 buf[8] = {\n\t\t0x3d, 0x32, 0x0f, 0x08, 0x3d, 0x32, 0x0f, 0x08\n\t};\n\tstruct amradio_device *radio = video_drvdata(file);\n\tunsigned long timeout;\n\tint retval;\n\n\tif (seek->tuner != 0 || !seek->wrap_around)\n\t\treturn -EINVAL;\n\n\tif (file->f_flags & O_NONBLOCK)\n\t\treturn -EWOULDBLOCK;\n\n\tretval = amradio_send_cmd(radio,\n\t\t\tAMRADIO_SET_SEARCH_LVL, 0, buf, 8, false);\n\tif (retval)\n\t\treturn retval;\n\tamradio_set_freq(radio, radio->curfreq);\n\tretval = amradio_send_cmd(radio,\n\t\tseek->seek_upward ? AMRADIO_SET_SEARCH_UP : AMRADIO_SET_SEARCH_DOWN,\n\t\t0, NULL, 0, false);\n\tif (retval)\n\t\treturn retval;\n\ttimeout = jiffies + msecs_to_jiffies(30000);\n\tfor (;;) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tretval = -ENODATA;\n\t\t\tbreak;\n\t\t}\n\t\tif (schedule_timeout_interruptible(msecs_to_jiffies(10))) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tretval = amradio_send_cmd(radio, AMRADIO_GET_READY_FLAG,\n\t\t\t\t0, NULL, 0, true);\n\t\tif (retval)\n\t\t\tcontinue;\n\t\tamradio_send_cmd(radio, AMRADIO_GET_FREQ, 0, NULL, 0, true);\n\t\tif (radio->buffer[1] || radio->buffer[2]) {\n\t\t\t \n\t\t\tradio->curfreq = (radio->buffer[1] << 8) | radio->buffer[2];\n\t\t\tradio->curfreq = (radio->curfreq - 0x10) * 200;\n\t\t\tamradio_send_cmd(radio, AMRADIO_STOP_SEARCH,\n\t\t\t\t\t0, NULL, 0, false);\n\t\t\tamradio_set_freq(radio, radio->curfreq);\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tamradio_send_cmd(radio, AMRADIO_STOP_SEARCH, 0, NULL, 0, false);\n\tamradio_set_freq(radio, radio->curfreq);\n\treturn retval;\n}\n\nstatic int usb_amradio_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct amradio_device *radio =\n\t\tcontainer_of(ctrl->handler, struct amradio_device, hdl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\treturn amradio_set_mute(radio, ctrl->val);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int usb_amradio_init(struct amradio_device *radio)\n{\n\tint retval;\n\n\tretval = amradio_set_mute(radio, true);\n\tif (retval)\n\t\tgoto out_err;\n\tretval = amradio_set_stereo(radio, true);\n\tif (retval)\n\t\tgoto out_err;\n\tretval = amradio_set_freq(radio, radio->curfreq);\n\tif (retval)\n\t\tgoto out_err;\n\treturn 0;\n\nout_err:\n\tamradio_dev_err(&radio->vdev.dev, \"initialization failed\\n\");\n\treturn retval;\n}\n\n \nstatic int usb_amradio_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct amradio_device *radio = to_amradio_dev(usb_get_intfdata(intf));\n\n\tmutex_lock(&radio->lock);\n\tif (!radio->muted) {\n\t\tamradio_set_mute(radio, true);\n\t\tradio->muted = false;\n\t}\n\tmutex_unlock(&radio->lock);\n\n\tdev_info(&intf->dev, \"going into suspend..\\n\");\n\treturn 0;\n}\n\n \nstatic int usb_amradio_resume(struct usb_interface *intf)\n{\n\tstruct amradio_device *radio = to_amradio_dev(usb_get_intfdata(intf));\n\n\tmutex_lock(&radio->lock);\n\tamradio_set_stereo(radio, radio->stereo);\n\tamradio_set_freq(radio, radio->curfreq);\n\n\tif (!radio->muted)\n\t\tamradio_set_mute(radio, false);\n\n\tmutex_unlock(&radio->lock);\n\n\tdev_info(&intf->dev, \"coming out of suspend..\\n\");\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops usb_amradio_ctrl_ops = {\n\t.s_ctrl = usb_amradio_s_ctrl,\n};\n\n \nstatic const struct v4l2_file_operations usb_amradio_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= v4l2_fh_open,\n\t.release\t= v4l2_fh_release,\n\t.poll\t\t= v4l2_ctrl_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops usb_amradio_ioctl_ops = {\n\t.vidioc_querycap    = vidioc_querycap,\n\t.vidioc_g_tuner     = vidioc_g_tuner,\n\t.vidioc_s_tuner     = vidioc_s_tuner,\n\t.vidioc_g_frequency = vidioc_g_frequency,\n\t.vidioc_s_frequency = vidioc_s_frequency,\n\t.vidioc_s_hw_freq_seek = vidioc_s_hw_freq_seek,\n\t.vidioc_log_status  = v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic void usb_amradio_release(struct v4l2_device *v4l2_dev)\n{\n\tstruct amradio_device *radio = to_amradio_dev(v4l2_dev);\n\n\t \n\tv4l2_ctrl_handler_free(&radio->hdl);\n\tv4l2_device_unregister(&radio->v4l2_dev);\n\tkfree(radio->buffer);\n\tkfree(radio);\n}\n\n \nstatic int usb_amradio_probe(struct usb_interface *intf,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct amradio_device *radio;\n\tint retval;\n\n\tradio = kzalloc(sizeof(struct amradio_device), GFP_KERNEL);\n\n\tif (!radio) {\n\t\tdev_err(&intf->dev, \"kmalloc for amradio_device failed\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tradio->buffer = kmalloc(BUFFER_LENGTH, GFP_KERNEL);\n\n\tif (!radio->buffer) {\n\t\tdev_err(&intf->dev, \"kmalloc for radio->buffer failed\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto err_nobuf;\n\t}\n\n\tretval = v4l2_device_register(&intf->dev, &radio->v4l2_dev);\n\tif (retval < 0) {\n\t\tdev_err(&intf->dev, \"couldn't register v4l2_device\\n\");\n\t\tgoto err_v4l2;\n\t}\n\n\tv4l2_ctrl_handler_init(&radio->hdl, 1);\n\tv4l2_ctrl_new_std(&radio->hdl, &usb_amradio_ctrl_ops,\n\t\t\t  V4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\n\tif (radio->hdl.error) {\n\t\tretval = radio->hdl.error;\n\t\tdev_err(&intf->dev, \"couldn't register control\\n\");\n\t\tgoto err_ctrl;\n\t}\n\tmutex_init(&radio->lock);\n\n\tradio->v4l2_dev.ctrl_handler = &radio->hdl;\n\tradio->v4l2_dev.release = usb_amradio_release;\n\tstrscpy(radio->vdev.name, radio->v4l2_dev.name,\n\t\tsizeof(radio->vdev.name));\n\tradio->vdev.v4l2_dev = &radio->v4l2_dev;\n\tradio->vdev.fops = &usb_amradio_fops;\n\tradio->vdev.ioctl_ops = &usb_amradio_ioctl_ops;\n\tradio->vdev.release = video_device_release_empty;\n\tradio->vdev.lock = &radio->lock;\n\tradio->vdev.device_caps = V4L2_CAP_RADIO | V4L2_CAP_TUNER |\n\t\t\t\t  V4L2_CAP_HW_FREQ_SEEK;\n\n\tradio->usbdev = interface_to_usbdev(intf);\n\tradio->intf = intf;\n\tusb_set_intfdata(intf, &radio->v4l2_dev);\n\tradio->curfreq = 95.16 * FREQ_MUL;\n\n\tvideo_set_drvdata(&radio->vdev, radio);\n\tretval = usb_amradio_init(radio);\n\tif (retval)\n\t\tgoto err_vdev;\n\n\tretval = video_register_device(&radio->vdev, VFL_TYPE_RADIO,\n\t\t\t\t\tradio_nr);\n\tif (retval < 0) {\n\t\tdev_err(&intf->dev, \"could not register video device\\n\");\n\t\tgoto err_vdev;\n\t}\n\n\treturn 0;\n\nerr_vdev:\n\tv4l2_ctrl_handler_free(&radio->hdl);\nerr_ctrl:\n\tv4l2_device_unregister(&radio->v4l2_dev);\nerr_v4l2:\n\tkfree(radio->buffer);\nerr_nobuf:\n\tkfree(radio);\nerr:\n\treturn retval;\n}\n\n \nstatic const struct usb_device_id usb_amradio_device_table[] = {\n\t{ USB_DEVICE_AND_INTERFACE_INFO(USB_AMRADIO_VENDOR, USB_AMRADIO_PRODUCT,\n\t\t\t\t\t\t\tUSB_CLASS_HID, 0, 0) },\n\t{ }\t\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, usb_amradio_device_table);\n\n \nstatic struct usb_driver usb_amradio_driver = {\n\t.name\t\t\t= MR800_DRIVER_NAME,\n\t.probe\t\t\t= usb_amradio_probe,\n\t.disconnect\t\t= usb_amradio_disconnect,\n\t.suspend\t\t= usb_amradio_suspend,\n\t.resume\t\t\t= usb_amradio_resume,\n\t.reset_resume\t\t= usb_amradio_resume,\n\t.id_table\t\t= usb_amradio_device_table,\n};\n\nmodule_usb_driver(usb_amradio_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}