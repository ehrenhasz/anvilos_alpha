{
  "module_name": "radio-zoltrix.c",
  "hash_id": "b3f1e1bacc20244d1ab803b5ea15e51adf70f6256ce4eb276b6fce2a8fe61a0c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/radio-zoltrix.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\t \n#include <linux/init.h>\t\t \n#include <linux/ioport.h>\t \n#include <linux/delay.h>\t \n#include <linux/videodev2.h>\t \n#include <linux/mutex.h>\n#include <linux/io.h>\t\t \n#include <linux/slab.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include \"radio-isa.h\"\n\nMODULE_AUTHOR(\"C. van Schaik\");\nMODULE_DESCRIPTION(\"A driver for the Zoltrix Radio Plus.\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.1.99\");\n\n#ifndef CONFIG_RADIO_ZOLTRIX_PORT\n#define CONFIG_RADIO_ZOLTRIX_PORT -1\n#endif\n\n#define ZOLTRIX_MAX 2\n\nstatic int io[ZOLTRIX_MAX] = { [0] = CONFIG_RADIO_ZOLTRIX_PORT,\n\t\t\t       [1 ... (ZOLTRIX_MAX - 1)] = -1 };\nstatic int radio_nr[ZOLTRIX_MAX] = { [0 ... (ZOLTRIX_MAX - 1)] = -1 };\n\nmodule_param_array(io, int, NULL, 0444);\nMODULE_PARM_DESC(io, \"I/O addresses of the Zoltrix Radio Plus card (0x20c or 0x30c)\");\nmodule_param_array(radio_nr, int, NULL, 0444);\nMODULE_PARM_DESC(radio_nr, \"Radio device numbers\");\n\nstruct zoltrix {\n\tstruct radio_isa_card isa;\n\tint curvol;\n\tbool muted;\n};\n\nstatic struct radio_isa_card *zoltrix_alloc(void)\n{\n\tstruct zoltrix *zol = kzalloc(sizeof(*zol), GFP_KERNEL);\n\n\treturn zol ? &zol->isa : NULL;\n}\n\nstatic int zoltrix_s_mute_volume(struct radio_isa_card *isa, bool mute, int vol)\n{\n\tstruct zoltrix *zol = container_of(isa, struct zoltrix, isa);\n\n\tzol->curvol = vol;\n\tzol->muted = mute;\n\tif (mute || vol == 0) {\n\t\toutb(0, isa->io);\n\t\toutb(0, isa->io);\n\t\tinb(isa->io + 3);             \n\t\treturn 0;\n\t}\n\n\toutb(vol - 1, isa->io);\n\tmsleep(10);\n\tinb(isa->io + 2);\n\treturn 0;\n}\n\n \nstatic int zoltrix_s_frequency(struct radio_isa_card *isa, u32 freq)\n{\n\tstruct zoltrix *zol = container_of(isa, struct zoltrix, isa);\n\tstruct v4l2_device *v4l2_dev = &isa->v4l2_dev;\n\tunsigned long long bitmask, f, m;\n\tbool stereo = isa->stereo;\n\tint i;\n\n\tif (freq == 0) {\n\t\tv4l2_warn(v4l2_dev, \"cannot set a frequency of 0.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tm = (freq / 160 - 8800) * 2;\n\tf = (unsigned long long)m + 0x4d1c;\n\n\tbitmask = 0xc480402c10080000ull;\n\ti = 45;\n\n\toutb(0, isa->io);\n\toutb(0, isa->io);\n\tinb(isa->io + 3);             \n\n\toutb(0x40, isa->io);\n\toutb(0xc0, isa->io);\n\n\tbitmask = (bitmask ^ ((f & 0xff) << 47) ^ ((f & 0xff00) << 30) ^ (stereo << 31));\n\twhile (i--) {\n\t\tif ((bitmask & 0x8000000000000000ull) != 0) {\n\t\t\toutb(0x80, isa->io);\n\t\t\tudelay(50);\n\t\t\toutb(0x00, isa->io);\n\t\t\tudelay(50);\n\t\t\toutb(0x80, isa->io);\n\t\t\tudelay(50);\n\t\t} else {\n\t\t\toutb(0xc0, isa->io);\n\t\t\tudelay(50);\n\t\t\toutb(0x40, isa->io);\n\t\t\tudelay(50);\n\t\t\toutb(0xc0, isa->io);\n\t\t\tudelay(50);\n\t\t}\n\t\tbitmask *= 2;\n\t}\n\t \n\toutb(0x80, isa->io);\n\toutb(0xc0, isa->io);\n\toutb(0x40, isa->io);\n\tudelay(1000);\n\tinb(isa->io + 2);\n\tudelay(1000);\n\n\treturn zoltrix_s_mute_volume(isa, zol->muted, zol->curvol);\n}\n\n \nstatic u32 zoltrix_g_rxsubchans(struct radio_isa_card *isa)\n{\n\tstruct zoltrix *zol = container_of(isa, struct zoltrix, isa);\n\tint a, b;\n\n\toutb(0x00, isa->io);          \n\toutb(zol->curvol, isa->io);\n\tmsleep(20);\n\n\ta = inb(isa->io);\n\tmsleep(10);\n\tb = inb(isa->io);\n\n\treturn (a == b && a == 0xcf) ?\n\t\tV4L2_TUNER_SUB_STEREO : V4L2_TUNER_SUB_MONO;\n}\n\nstatic u32 zoltrix_g_signal(struct radio_isa_card *isa)\n{\n\tstruct zoltrix *zol = container_of(isa, struct zoltrix, isa);\n\tint a, b;\n\n\toutb(0x00, isa->io);          \n\toutb(zol->curvol, isa->io);\n\tmsleep(20);\n\n\ta = inb(isa->io);\n\tmsleep(10);\n\tb = inb(isa->io);\n\n\tif (a != b)\n\t\treturn 0;\n\n\t \n\treturn (a == 0xcf || a == 0xdf || a == 0xef) ? 0xffff : 0;\n}\n\nstatic int zoltrix_s_stereo(struct radio_isa_card *isa, bool stereo)\n{\n\treturn zoltrix_s_frequency(isa, isa->freq);\n}\n\nstatic const struct radio_isa_ops zoltrix_ops = {\n\t.alloc = zoltrix_alloc,\n\t.s_mute_volume = zoltrix_s_mute_volume,\n\t.s_frequency = zoltrix_s_frequency,\n\t.s_stereo = zoltrix_s_stereo,\n\t.g_rxsubchans = zoltrix_g_rxsubchans,\n\t.g_signal = zoltrix_g_signal,\n};\n\nstatic const int zoltrix_ioports[] = { 0x20c, 0x30c };\n\nstatic struct radio_isa_driver zoltrix_driver = {\n\t.driver = {\n\t\t.match\t\t= radio_isa_match,\n\t\t.probe\t\t= radio_isa_probe,\n\t\t.remove\t\t= radio_isa_remove,\n\t\t.driver\t\t= {\n\t\t\t.name\t= \"radio-zoltrix\",\n\t\t},\n\t},\n\t.io_params = io,\n\t.radio_nr_params = radio_nr,\n\t.io_ports = zoltrix_ioports,\n\t.num_of_io_ports = ARRAY_SIZE(zoltrix_ioports),\n\t.region_size = 2,\n\t.card = \"Zoltrix Radio Plus\",\n\t.ops = &zoltrix_ops,\n\t.has_stereo = true,\n\t.max_volume = 15,\n};\n\nstatic int __init zoltrix_init(void)\n{\n\treturn isa_register_driver(&zoltrix_driver.driver, ZOLTRIX_MAX);\n}\n\nstatic void __exit zoltrix_exit(void)\n{\n\tisa_unregister_driver(&zoltrix_driver.driver);\n}\n\nmodule_init(zoltrix_init);\nmodule_exit(zoltrix_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}