{
  "module_name": "radio-shark2.c",
  "hash_id": "f959466f44d24f71e083f024331a651b67679f4dc99666c9fa7001ef784ec68a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/radio-shark2.c",
  "human_readable_source": " \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/workqueue.h>\n#include <media/v4l2-device.h>\n#include \"radio-tea5777.h\"\n\n#if defined(CONFIG_LEDS_CLASS) || \\\n    (defined(CONFIG_LEDS_CLASS_MODULE) && defined(CONFIG_RADIO_SHARK2_MODULE))\n#define SHARK_USE_LEDS 1\n#endif\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_DESCRIPTION(\"Griffin radioSHARK2, USB radio receiver driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int debug;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"Debug level (0-1)\");\n\n#define SHARK_IN_EP\t\t0x83\n#define SHARK_OUT_EP\t\t0x05\n\n#define TB_LEN 7\n#define DRV_NAME \"radioshark2\"\n\n#define v4l2_dev_to_shark(d) container_of(d, struct shark_device, v4l2_dev)\n\nenum { BLUE_LED, RED_LED, NO_LEDS };\n\nstruct shark_device {\n\tstruct usb_device *usbdev;\n\tstruct v4l2_device v4l2_dev;\n\tstruct radio_tea5777 tea;\n\n#ifdef SHARK_USE_LEDS\n\tstruct work_struct led_work;\n\tstruct led_classdev leds[NO_LEDS];\n\tchar led_names[NO_LEDS][32];\n\tatomic_t brightness[NO_LEDS];\n\tunsigned long brightness_new;\n#endif\n\n\tu8 *transfer_buffer;\n};\n\nstatic atomic_t shark_instance = ATOMIC_INIT(0);\n\nstatic int shark_write_reg(struct radio_tea5777 *tea, u64 reg)\n{\n\tstruct shark_device *shark = tea->private_data;\n\tint i, res, actual_len;\n\n\tmemset(shark->transfer_buffer, 0, TB_LEN);\n\tshark->transfer_buffer[0] = 0x81;  \n\tfor (i = 0; i < 6; i++)\n\t\tshark->transfer_buffer[i + 1] = (reg >> (40 - i * 8)) & 0xff;\n\n\tv4l2_dbg(1, debug, tea->v4l2_dev, \"shark2-write: %*ph\\n\",\n\t\t 7, shark->transfer_buffer);\n\n\tres = usb_interrupt_msg(shark->usbdev,\n\t\t\t\tusb_sndintpipe(shark->usbdev, SHARK_OUT_EP),\n\t\t\t\tshark->transfer_buffer, TB_LEN,\n\t\t\t\t&actual_len, 1000);\n\tif (res < 0) {\n\t\tv4l2_err(tea->v4l2_dev, \"write error: %d\\n\", res);\n\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nstatic int shark_read_reg(struct radio_tea5777 *tea, u32 *reg_ret)\n{\n\tstruct shark_device *shark = tea->private_data;\n\tint i, res, actual_len;\n\tu32 reg = 0;\n\n\tmemset(shark->transfer_buffer, 0, TB_LEN);\n\tshark->transfer_buffer[0] = 0x82;\n\tres = usb_interrupt_msg(shark->usbdev,\n\t\t\t\tusb_sndintpipe(shark->usbdev, SHARK_OUT_EP),\n\t\t\t\tshark->transfer_buffer, TB_LEN,\n\t\t\t\t&actual_len, 1000);\n\tif (res < 0) {\n\t\tv4l2_err(tea->v4l2_dev, \"request-read error: %d\\n\", res);\n\t\treturn res;\n\t}\n\n\tres = usb_interrupt_msg(shark->usbdev,\n\t\t\t\tusb_rcvintpipe(shark->usbdev, SHARK_IN_EP),\n\t\t\t\tshark->transfer_buffer, TB_LEN,\n\t\t\t\t&actual_len, 1000);\n\tif (res < 0) {\n\t\tv4l2_err(tea->v4l2_dev, \"read error: %d\\n\", res);\n\t\treturn res;\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t\treg |= shark->transfer_buffer[i] << (16 - i * 8);\n\n\tv4l2_dbg(1, debug, tea->v4l2_dev, \"shark2-read: %*ph\\n\",\n\t\t 3, shark->transfer_buffer);\n\n\t*reg_ret = reg;\n\treturn 0;\n}\n\nstatic const struct radio_tea5777_ops shark_tea_ops = {\n\t.write_reg = shark_write_reg,\n\t.read_reg  = shark_read_reg,\n};\n\n#ifdef SHARK_USE_LEDS\nstatic void shark_led_work(struct work_struct *work)\n{\n\tstruct shark_device *shark =\n\t\tcontainer_of(work, struct shark_device, led_work);\n\tint i, res, brightness, actual_len;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (!test_and_clear_bit(i, &shark->brightness_new))\n\t\t\tcontinue;\n\n\t\tbrightness = atomic_read(&shark->brightness[i]);\n\t\tmemset(shark->transfer_buffer, 0, TB_LEN);\n\t\tshark->transfer_buffer[0] = 0x83 + i;\n\t\tshark->transfer_buffer[1] = brightness;\n\t\tres = usb_interrupt_msg(shark->usbdev,\n\t\t\t\t\tusb_sndintpipe(shark->usbdev,\n\t\t\t\t\t\t       SHARK_OUT_EP),\n\t\t\t\t\tshark->transfer_buffer, TB_LEN,\n\t\t\t\t\t&actual_len, 1000);\n\t\tif (res < 0)\n\t\t\tv4l2_err(&shark->v4l2_dev, \"set LED %s error: %d\\n\",\n\t\t\t\t shark->led_names[i], res);\n\t}\n}\n\nstatic void shark_led_set_blue(struct led_classdev *led_cdev,\n\t\t\t       enum led_brightness value)\n{\n\tstruct shark_device *shark =\n\t\tcontainer_of(led_cdev, struct shark_device, leds[BLUE_LED]);\n\n\tatomic_set(&shark->brightness[BLUE_LED], value);\n\tset_bit(BLUE_LED, &shark->brightness_new);\n\tschedule_work(&shark->led_work);\n}\n\nstatic void shark_led_set_red(struct led_classdev *led_cdev,\n\t\t\t      enum led_brightness value)\n{\n\tstruct shark_device *shark =\n\t\tcontainer_of(led_cdev, struct shark_device, leds[RED_LED]);\n\n\tatomic_set(&shark->brightness[RED_LED], value);\n\tset_bit(RED_LED, &shark->brightness_new);\n\tschedule_work(&shark->led_work);\n}\n\nstatic const struct led_classdev shark_led_templates[NO_LEDS] = {\n\t[BLUE_LED] = {\n\t\t.name\t\t= \"%s:blue:\",\n\t\t.brightness\t= LED_OFF,\n\t\t.max_brightness = 127,\n\t\t.brightness_set = shark_led_set_blue,\n\t},\n\t[RED_LED] = {\n\t\t.name\t\t= \"%s:red:\",\n\t\t.brightness\t= LED_OFF,\n\t\t.max_brightness = 1,\n\t\t.brightness_set = shark_led_set_red,\n\t},\n};\n\nstatic int shark_register_leds(struct shark_device *shark, struct device *dev)\n{\n\tint i, retval;\n\n\tatomic_set(&shark->brightness[BLUE_LED], 127);\n\tINIT_WORK(&shark->led_work, shark_led_work);\n\tfor (i = 0; i < NO_LEDS; i++) {\n\t\tshark->leds[i] = shark_led_templates[i];\n\t\tsnprintf(shark->led_names[i], sizeof(shark->led_names[0]),\n\t\t\t shark->leds[i].name, shark->v4l2_dev.name);\n\t\tshark->leds[i].name = shark->led_names[i];\n\t\tretval = led_classdev_register(dev, &shark->leds[i]);\n\t\tif (retval) {\n\t\t\tv4l2_err(&shark->v4l2_dev,\n\t\t\t\t \"couldn't register led: %s\\n\",\n\t\t\t\t shark->led_names[i]);\n\t\t\treturn retval;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void shark_unregister_leds(struct shark_device *shark)\n{\n\tint i;\n\n\tfor (i = 0; i < NO_LEDS; i++)\n\t\tled_classdev_unregister(&shark->leds[i]);\n\n\tcancel_work_sync(&shark->led_work);\n}\n\nstatic inline void shark_resume_leds(struct shark_device *shark)\n{\n\tint i;\n\n\tfor (i = 0; i < NO_LEDS; i++)\n\t\tset_bit(i, &shark->brightness_new);\n\n\tschedule_work(&shark->led_work);\n}\n#else\nstatic int shark_register_leds(struct shark_device *shark, struct device *dev)\n{\n\tv4l2_warn(&shark->v4l2_dev,\n\t\t  \"CONFIG_LEDS_CLASS not enabled, LED support disabled\\n\");\n\treturn 0;\n}\nstatic inline void shark_unregister_leds(struct shark_device *shark) { }\nstatic inline void shark_resume_leds(struct shark_device *shark) { }\n#endif\n\nstatic void usb_shark_disconnect(struct usb_interface *intf)\n{\n\tstruct v4l2_device *v4l2_dev = usb_get_intfdata(intf);\n\tstruct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);\n\n\tmutex_lock(&shark->tea.mutex);\n\tv4l2_device_disconnect(&shark->v4l2_dev);\n\tradio_tea5777_exit(&shark->tea);\n\tmutex_unlock(&shark->tea.mutex);\n\n\tshark_unregister_leds(shark);\n\n\tv4l2_device_put(&shark->v4l2_dev);\n}\n\nstatic void usb_shark_release(struct v4l2_device *v4l2_dev)\n{\n\tstruct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);\n\n\tv4l2_device_unregister(&shark->v4l2_dev);\n\tkfree(shark->transfer_buffer);\n\tkfree(shark);\n}\n\nstatic int usb_shark_probe(struct usb_interface *intf,\n\t\t\t   const struct usb_device_id *id)\n{\n\tstruct shark_device *shark;\n\tint retval = -ENOMEM;\n\tstatic const u8 ep_addresses[] = {\n\t\tSHARK_IN_EP | USB_DIR_IN,\n\t\tSHARK_OUT_EP | USB_DIR_OUT,\n\t\t0};\n\n\t \n\tif (!usb_check_int_endpoints(intf, ep_addresses)) {\n\t\tdev_err(&intf->dev, \"Invalid radioSHARK2 device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tshark = kzalloc(sizeof(struct shark_device), GFP_KERNEL);\n\tif (!shark)\n\t\treturn retval;\n\n\tshark->transfer_buffer = kmalloc(TB_LEN, GFP_KERNEL);\n\tif (!shark->transfer_buffer)\n\t\tgoto err_alloc_buffer;\n\n\tv4l2_device_set_name(&shark->v4l2_dev, DRV_NAME, &shark_instance);\n\n\tretval = shark_register_leds(shark, &intf->dev);\n\tif (retval)\n\t\tgoto err_reg_leds;\n\n\tshark->v4l2_dev.release = usb_shark_release;\n\tretval = v4l2_device_register(&intf->dev, &shark->v4l2_dev);\n\tif (retval) {\n\t\tv4l2_err(&shark->v4l2_dev, \"couldn't register v4l2_device\\n\");\n\t\tgoto err_reg_dev;\n\t}\n\n\tshark->usbdev = interface_to_usbdev(intf);\n\tshark->tea.v4l2_dev = &shark->v4l2_dev;\n\tshark->tea.private_data = shark;\n\tshark->tea.ops = &shark_tea_ops;\n\tshark->tea.has_am = true;\n\tshark->tea.write_before_read = true;\n\tstrscpy(shark->tea.card, \"Griffin radioSHARK2\",\n\t\tsizeof(shark->tea.card));\n\tusb_make_path(shark->usbdev, shark->tea.bus_info,\n\t\tsizeof(shark->tea.bus_info));\n\n\tretval = radio_tea5777_init(&shark->tea, THIS_MODULE);\n\tif (retval) {\n\t\tv4l2_err(&shark->v4l2_dev, \"couldn't init tea5777\\n\");\n\t\tgoto err_init_tea;\n\t}\n\n\treturn 0;\n\nerr_init_tea:\n\tv4l2_device_unregister(&shark->v4l2_dev);\nerr_reg_dev:\n\tshark_unregister_leds(shark);\nerr_reg_leds:\n\tkfree(shark->transfer_buffer);\nerr_alloc_buffer:\n\tkfree(shark);\n\n\treturn retval;\n}\n\n#ifdef CONFIG_PM\nstatic int usb_shark_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\treturn 0;\n}\n\nstatic int usb_shark_resume(struct usb_interface *intf)\n{\n\tstruct v4l2_device *v4l2_dev = usb_get_intfdata(intf);\n\tstruct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);\n\tint ret;\n\n\tmutex_lock(&shark->tea.mutex);\n\tret = radio_tea5777_set_freq(&shark->tea);\n\tmutex_unlock(&shark->tea.mutex);\n\n\tshark_resume_leds(shark);\n\n\treturn ret;\n}\n#endif\n\n \nstatic const struct usb_device_id usb_shark_device_table[] = {\n\t{ .match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION |\n\t\t\t USB_DEVICE_ID_MATCH_INT_CLASS,\n\t  .idVendor     = 0x077d,\n\t  .idProduct    = 0x627a,\n\t  .bcdDevice_lo = 0x0010,\n\t  .bcdDevice_hi = 0x0010,\n\t  .bInterfaceClass = 3,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, usb_shark_device_table);\n\nstatic struct usb_driver usb_shark_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.probe\t\t\t= usb_shark_probe,\n\t.disconnect\t\t= usb_shark_disconnect,\n\t.id_table\t\t= usb_shark_device_table,\n#ifdef CONFIG_PM\n\t.suspend\t\t= usb_shark_suspend,\n\t.resume\t\t\t= usb_shark_resume,\n\t.reset_resume\t\t= usb_shark_resume,\n#endif\n};\nmodule_usb_driver(usb_shark_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}