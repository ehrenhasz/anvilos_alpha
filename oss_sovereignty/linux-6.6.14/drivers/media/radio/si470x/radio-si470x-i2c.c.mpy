{
  "module_name": "radio-si470x-i2c.c",
  "hash_id": "3121466783acca000625915c470cef0d82c0f2f251cf46eb5164f782cf304536",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/si470x/radio-si470x-i2c.c",
  "human_readable_source": "\n \n\n\n \n#define DRIVER_AUTHOR \"Joonyoung Shim <jy0922.shim@samsung.com>\";\n#define DRIVER_CARD \"Silicon Labs Si470x FM Radio\"\n#define DRIVER_DESC \"I2C radio driver for Si470x FM Radio Receivers\"\n#define DRIVER_VERSION \"1.0.2\"\n\n \n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n\n#include \"radio-si470x.h\"\n\n\n \nstatic const struct i2c_device_id si470x_i2c_id[] = {\n\t \n\t{ \"si470x\", 0 },\n\t \n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, si470x_i2c_id);\n\n\n \n\n \nstatic int radio_nr = -1;\nmodule_param(radio_nr, int, 0444);\nMODULE_PARM_DESC(radio_nr, \"Radio Nr\");\n\n \nstatic unsigned int rds_buf = 100;\nmodule_param(rds_buf, uint, 0444);\nMODULE_PARM_DESC(rds_buf, \"RDS buffer entries: *100*\");\n\n \nstatic unsigned short max_rds_errors = 1;\n \n \n \n \nmodule_param(max_rds_errors, ushort, 0644);\nMODULE_PARM_DESC(max_rds_errors, \"RDS maximum block errors: *1*\");\n\n\n\n \n\n \n#define WRITE_REG_NUM\t\t8\n#define WRITE_INDEX(i)\t\t(i + 0x02)\n\n \n#define READ_REG_NUM\t\tRADIO_REGISTER_NUM\n#define READ_INDEX(i)\t\t((i + RADIO_REGISTER_NUM - 0x0a) % READ_REG_NUM)\n\n\n\n \n\n \nstatic int si470x_get_register(struct si470x_device *radio, int regnr)\n{\n\t__be16 buf[READ_REG_NUM];\n\tstruct i2c_msg msgs[1] = {\n\t\t{\n\t\t\t.addr = radio->client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = sizeof(u16) * READ_REG_NUM,\n\t\t\t.buf = (void *)buf\n\t\t},\n\t};\n\n\tif (i2c_transfer(radio->client->adapter, msgs, 1) != 1)\n\t\treturn -EIO;\n\n\tradio->registers[regnr] = __be16_to_cpu(buf[READ_INDEX(regnr)]);\n\n\treturn 0;\n}\n\n\n \nstatic int si470x_set_register(struct si470x_device *radio, int regnr)\n{\n\tint i;\n\t__be16 buf[WRITE_REG_NUM];\n\tstruct i2c_msg msgs[1] = {\n\t\t{\n\t\t\t.addr = radio->client->addr,\n\t\t\t.len = sizeof(u16) * WRITE_REG_NUM,\n\t\t\t.buf = (void *)buf\n\t\t},\n\t};\n\n\tfor (i = 0; i < WRITE_REG_NUM; i++)\n\t\tbuf[i] = __cpu_to_be16(radio->registers[WRITE_INDEX(i)]);\n\n\tif (i2c_transfer(radio->client->adapter, msgs, 1) != 1)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n\n\n \n\n \nstatic int si470x_get_all_registers(struct si470x_device *radio)\n{\n\tint i;\n\t__be16 buf[READ_REG_NUM];\n\tstruct i2c_msg msgs[1] = {\n\t\t{\n\t\t\t.addr = radio->client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = sizeof(u16) * READ_REG_NUM,\n\t\t\t.buf = (void *)buf\n\t\t},\n\t};\n\n\tif (i2c_transfer(radio->client->adapter, msgs, 1) != 1)\n\t\treturn -EIO;\n\n\tfor (i = 0; i < READ_REG_NUM; i++)\n\t\tradio->registers[i] = __be16_to_cpu(buf[READ_INDEX(i)]);\n\n\treturn 0;\n}\n\n\n\n \n\n \nstatic int si470x_fops_open(struct file *file)\n{\n\tstruct si470x_device *radio = video_drvdata(file);\n\tint retval = v4l2_fh_open(file);\n\n\tif (retval)\n\t\treturn retval;\n\n\tif (v4l2_fh_is_singular_file(file)) {\n\t\t \n\t\tretval = si470x_start(radio);\n\t\tif (retval < 0)\n\t\t\tgoto done;\n\n\t\t \n\t\tradio->registers[SYSCONFIG1] |= SYSCONFIG1_RDSIEN;\n\t\tradio->registers[SYSCONFIG1] |= SYSCONFIG1_STCIEN;\n\t\tradio->registers[SYSCONFIG1] &= ~SYSCONFIG1_GPIO2;\n\t\tradio->registers[SYSCONFIG1] |= 0x1 << 2;\n\t\tretval = si470x_set_register(radio, SYSCONFIG1);\n\t}\n\ndone:\n\tif (retval)\n\t\tv4l2_fh_release(file);\n\treturn retval;\n}\n\n\n \nstatic int si470x_fops_release(struct file *file)\n{\n\tstruct si470x_device *radio = video_drvdata(file);\n\n\tif (v4l2_fh_is_singular_file(file))\n\t\t \n\t\tsi470x_stop(radio);\n\n\treturn v4l2_fh_release(file);\n}\n\n\n\n \n\n \nstatic int si470x_vidioc_querycap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_capability *capability)\n{\n\tstrscpy(capability->driver, DRIVER_NAME, sizeof(capability->driver));\n\tstrscpy(capability->card, DRIVER_CARD, sizeof(capability->card));\n\treturn 0;\n}\n\n\n\n \n\n \nstatic irqreturn_t si470x_i2c_interrupt(int irq, void *dev_id)\n{\n\tstruct si470x_device *radio = dev_id;\n\tunsigned char regnr;\n\tunsigned char blocknum;\n\tunsigned short bler;  \n\tunsigned short rds;\n\tunsigned char tmpbuf[3];\n\tint retval = 0;\n\n\t \n\tretval = si470x_get_register(radio, STATUSRSSI);\n\tif (retval < 0)\n\t\tgoto end;\n\n\tif (radio->registers[STATUSRSSI] & STATUSRSSI_STC)\n\t\tcomplete(&radio->completion);\n\n\t \n\tif ((radio->registers[SYSCONFIG1] & SYSCONFIG1_RDS) == 0)\n\t\tgoto end;\n\n\t \n\tfor (regnr = 1; regnr < RDS_REGISTER_NUM; regnr++) {\n\t\tretval = si470x_get_register(radio, STATUSRSSI + regnr);\n\t\tif (retval < 0)\n\t\t\tgoto end;\n\t}\n\n\t \n\tif ((radio->registers[STATUSRSSI] & STATUSRSSI_RDSR) == 0)\n\t\t \n\t\tgoto end;\n\n\tfor (blocknum = 0; blocknum < 4; blocknum++) {\n\t\tswitch (blocknum) {\n\t\tdefault:\n\t\t\tbler = (radio->registers[STATUSRSSI] &\n\t\t\t\t\tSTATUSRSSI_BLERA) >> 9;\n\t\t\trds = radio->registers[RDSA];\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbler = (radio->registers[READCHAN] &\n\t\t\t\t\tREADCHAN_BLERB) >> 14;\n\t\t\trds = radio->registers[RDSB];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbler = (radio->registers[READCHAN] &\n\t\t\t\t\tREADCHAN_BLERC) >> 12;\n\t\t\trds = radio->registers[RDSC];\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbler = (radio->registers[READCHAN] &\n\t\t\t\t\tREADCHAN_BLERD) >> 10;\n\t\t\trds = radio->registers[RDSD];\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tput_unaligned_le16(rds, &tmpbuf);\n\t\ttmpbuf[2] = blocknum;\t\t \n\t\ttmpbuf[2] |= blocknum << 3;\t \n\t\tif (bler > max_rds_errors)\n\t\t\ttmpbuf[2] |= 0x80;\t \n\t\telse if (bler > 0)\n\t\t\ttmpbuf[2] |= 0x40;\t \n\n\t\t \n\t\tmemcpy(&radio->buffer[radio->wr_index], &tmpbuf, 3);\n\t\tradio->wr_index += 3;\n\n\t\t \n\t\tif (radio->wr_index >= radio->buf_size)\n\t\t\tradio->wr_index = 0;\n\n\t\t \n\t\tif (radio->wr_index == radio->rd_index) {\n\t\t\t \n\t\t\tradio->rd_index += 3;\n\t\t\tif (radio->rd_index >= radio->buf_size)\n\t\t\t\tradio->rd_index = 0;\n\t\t}\n\t}\n\n\tif (radio->wr_index != radio->rd_index)\n\t\twake_up_interruptible(&radio->read_queue);\n\nend:\n\treturn IRQ_HANDLED;\n}\n\n\n \nstatic int si470x_i2c_probe(struct i2c_client *client)\n{\n\tstruct si470x_device *radio;\n\tint retval = 0;\n\n\t \n\tradio = devm_kzalloc(&client->dev, sizeof(*radio), GFP_KERNEL);\n\tif (!radio) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_initial;\n\t}\n\n\tradio->client = client;\n\tradio->band = 1;  \n\tmutex_init(&radio->lock);\n\tinit_completion(&radio->completion);\n\n\tradio->get_register = si470x_get_register;\n\tradio->set_register = si470x_set_register;\n\tradio->fops_open = si470x_fops_open;\n\tradio->fops_release = si470x_fops_release;\n\tradio->vidioc_querycap = si470x_vidioc_querycap;\n\n\tretval = v4l2_device_register(&client->dev, &radio->v4l2_dev);\n\tif (retval < 0) {\n\t\tdev_err(&client->dev, \"couldn't register v4l2_device\\n\");\n\t\tgoto err_initial;\n\t}\n\n\tv4l2_ctrl_handler_init(&radio->hdl, 2);\n\tv4l2_ctrl_new_std(&radio->hdl, &si470x_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\n\tv4l2_ctrl_new_std(&radio->hdl, &si470x_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_VOLUME, 0, 15, 1, 15);\n\tif (radio->hdl.error) {\n\t\tretval = radio->hdl.error;\n\t\tdev_err(&client->dev, \"couldn't register control\\n\");\n\t\tgoto err_all;\n\t}\n\n\t \n\tradio->videodev = si470x_viddev_template;\n\tradio->videodev.ctrl_handler = &radio->hdl;\n\tradio->videodev.lock = &radio->lock;\n\tradio->videodev.v4l2_dev = &radio->v4l2_dev;\n\tradio->videodev.release = video_device_release_empty;\n\tradio->videodev.device_caps =\n\t\tV4L2_CAP_HW_FREQ_SEEK | V4L2_CAP_READWRITE | V4L2_CAP_TUNER |\n\t\tV4L2_CAP_RADIO | V4L2_CAP_RDS_CAPTURE;\n\tvideo_set_drvdata(&radio->videodev, radio);\n\n\tradio->gpio_reset = devm_gpiod_get_optional(&client->dev, \"reset\",\n\t\t\t\t\t\t    GPIOD_OUT_LOW);\n\tif (IS_ERR(radio->gpio_reset)) {\n\t\tretval = PTR_ERR(radio->gpio_reset);\n\t\tdev_err(&client->dev, \"Failed to request gpio: %d\\n\", retval);\n\t\tgoto err_all;\n\t}\n\n\tif (radio->gpio_reset)\n\t\tgpiod_set_value(radio->gpio_reset, 1);\n\n\t \n\tradio->registers[POWERCFG] = POWERCFG_ENABLE;\n\tif (si470x_set_register(radio, POWERCFG) < 0) {\n\t\tretval = -EIO;\n\t\tgoto err_all;\n\t}\n\tmsleep(110);\n\n\t \n\tif (si470x_get_all_registers(radio) < 0) {\n\t\tretval = -EIO;\n\t\tgoto err_all;\n\t}\n\tdev_info(&client->dev, \"DeviceID=0x%4.4hx ChipID=0x%4.4hx\\n\",\n\t\t\tradio->registers[DEVICEID], radio->registers[SI_CHIPID]);\n\tif ((radio->registers[SI_CHIPID] & SI_CHIPID_FIRMWARE) < RADIO_FW_VERSION) {\n\t\tdev_warn(&client->dev,\n\t\t\t\"This driver is known to work with firmware version %u, but the device has firmware version %u.\\n\"\n\t\t\t\"If you have some trouble using this driver, please report to V4L ML at linux-media@vger.kernel.org\\n\",\n\t\t\tRADIO_FW_VERSION,\n\t\t\tradio->registers[SI_CHIPID] & SI_CHIPID_FIRMWARE);\n\t}\n\n\t \n\tsi470x_set_freq(radio, 87.5 * FREQ_MUL);  \n\n\t \n\tradio->buf_size = rds_buf * 3;\n\tradio->buffer = devm_kmalloc(&client->dev, radio->buf_size, GFP_KERNEL);\n\tif (!radio->buffer) {\n\t\tretval = -EIO;\n\t\tgoto err_all;\n\t}\n\n\t \n\tradio->wr_index = 0;\n\tradio->rd_index = 0;\n\tinit_waitqueue_head(&radio->read_queue);\n\n\tretval = devm_request_threaded_irq(&client->dev, client->irq, NULL,\n\t\t\t\t\t   si470x_i2c_interrupt,\n\t\t\t\t\t   IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\t   DRIVER_NAME, radio);\n\tif (retval) {\n\t\tdev_err(&client->dev, \"Failed to register interrupt\\n\");\n\t\tgoto err_all;\n\t}\n\n\t \n\tretval = video_register_device(&radio->videodev, VFL_TYPE_RADIO,\n\t\t\tradio_nr);\n\tif (retval) {\n\t\tdev_warn(&client->dev, \"Could not register video device\\n\");\n\t\tgoto err_all;\n\t}\n\ti2c_set_clientdata(client, radio);\n\n\treturn 0;\nerr_all:\n\tv4l2_ctrl_handler_free(&radio->hdl);\n\tv4l2_device_unregister(&radio->v4l2_dev);\nerr_initial:\n\treturn retval;\n}\n\n\n \nstatic void si470x_i2c_remove(struct i2c_client *client)\n{\n\tstruct si470x_device *radio = i2c_get_clientdata(client);\n\n\tvideo_unregister_device(&radio->videodev);\n\n\tif (radio->gpio_reset)\n\t\tgpiod_set_value(radio->gpio_reset, 0);\n\n\tv4l2_ctrl_handler_free(&radio->hdl);\n\tv4l2_device_unregister(&radio->v4l2_dev);\n}\n\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int si470x_i2c_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct si470x_device *radio = i2c_get_clientdata(client);\n\n\t \n\tradio->registers[POWERCFG] |= POWERCFG_DISABLE;\n\tif (si470x_set_register(radio, POWERCFG) < 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n\n \nstatic int si470x_i2c_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct si470x_device *radio = i2c_get_clientdata(client);\n\n\t \n\tradio->registers[POWERCFG] |= POWERCFG_ENABLE;\n\tif (si470x_set_register(radio, POWERCFG) < 0)\n\t\treturn -EIO;\n\tmsleep(110);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(si470x_i2c_pm, si470x_i2c_suspend, si470x_i2c_resume);\n#endif\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id si470x_of_match[] = {\n\t{ .compatible = \"silabs,si470x\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, si470x_of_match);\n#endif\n\n \nstatic struct i2c_driver si470x_i2c_driver = {\n\t.driver = {\n\t\t.name\t\t= \"si470x\",\n\t\t.of_match_table = of_match_ptr(si470x_of_match),\n#ifdef CONFIG_PM_SLEEP\n\t\t.pm\t\t= &si470x_i2c_pm,\n#endif\n\t},\n\t.probe\t\t\t= si470x_i2c_probe,\n\t.remove\t\t\t= si470x_i2c_remove,\n\t.id_table\t\t= si470x_i2c_id,\n};\n\nmodule_i2c_driver(si470x_i2c_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_VERSION(DRIVER_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}