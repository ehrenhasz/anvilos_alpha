{
  "module_name": "radio-si470x-usb.c",
  "hash_id": "3aa5e108d4b5524db7c0d5791ddf2b5ba8c48dbe758ecd5b1a8ecd72ac5f4938",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/si470x/radio-si470x-usb.c",
  "human_readable_source": "\n \n\n\n \n\n\n \n#define DRIVER_AUTHOR \"Tobias Lorenz <tobias.lorenz@gmx.net>\"\n#define DRIVER_CARD \"Silicon Labs Si470x FM Radio\"\n#define DRIVER_DESC \"USB radio driver for Si470x FM Radio Receivers\"\n#define DRIVER_VERSION \"1.0.10\"\n\n \n#include <linux/usb.h>\n#include <linux/hid.h>\n#include <linux/slab.h>\n\n#include \"radio-si470x.h\"\n\n\n \nstatic const struct usb_device_id si470x_usb_driver_id_table[] = {\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x10c4, 0x818a, USB_CLASS_HID, 0, 0) },\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x06e1, 0xa155, USB_CLASS_HID, 0, 0) },\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x1b80, 0xd700, USB_CLASS_HID, 0, 0) },\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x10c5, 0x819a, USB_CLASS_HID, 0, 0) },\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x12cf, 0x7111, USB_CLASS_HID, 0, 0) },\n\t \n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, si470x_usb_driver_id_table);\n\n\n\n \n\n \nstatic int radio_nr = -1;\nmodule_param(radio_nr, int, 0444);\nMODULE_PARM_DESC(radio_nr, \"Radio Nr\");\n\n \nstatic unsigned int usb_timeout = 500;\nmodule_param(usb_timeout, uint, 0644);\nMODULE_PARM_DESC(usb_timeout, \"USB timeout (ms): *500*\");\n\n \nstatic unsigned int rds_buf = 100;\nmodule_param(rds_buf, uint, 0444);\nMODULE_PARM_DESC(rds_buf, \"RDS buffer entries: *100*\");\n\n \nstatic unsigned short max_rds_errors = 1;\n \n \n \n \nmodule_param(max_rds_errors, ushort, 0644);\nMODULE_PARM_DESC(max_rds_errors, \"RDS maximum block errors: *1*\");\n\n\n\n \n\n \n \n \n#define REGISTER_REPORT_SIZE\t(RADIO_REGISTER_SIZE + 1)\n#define REGISTER_REPORT(reg)\t((reg) + 1)\n\n \n \n#define ENTIRE_REPORT_SIZE\t(RADIO_REGISTER_NUM * RADIO_REGISTER_SIZE + 1)\n#define ENTIRE_REPORT\t\t17\n\n \n \n#define RDS_REPORT_SIZE\t\t(RDS_REGISTER_NUM * RADIO_REGISTER_SIZE + 1)\n#define RDS_REPORT\t\t18\n\n \n#define LED_REPORT_SIZE\t\t3\n#define LED_REPORT\t\t19\n\n \n#define STREAM_REPORT_SIZE\t3\n#define STREAM_REPORT\t\t19\n\n \n#define SCRATCH_PAGE_SIZE\t63\n#define SCRATCH_REPORT_SIZE\t(SCRATCH_PAGE_SIZE + 1)\n#define SCRATCH_REPORT\t\t20\n\n \n#define WRITE_REPORT_SIZE\t4\n#define WRITE_REPORT\t\t19\n#define FLASH_REPORT_SIZE\t64\n#define FLASH_REPORT\t\t20\n#define CRC_REPORT_SIZE\t\t3\n#define CRC_REPORT\t\t21\n#define RESPONSE_REPORT_SIZE\t2\n#define RESPONSE_REPORT\t\t22\n\n \n \n#define UNUSED_REPORT\t\t23\n\n#define MAX_REPORT_SIZE\t\t64\n\n\n\n \n#define RADIO_HW_VERSION\t\t\t1\n\n\n\n \n#define LED_COMMAND\t\t0x35\n\n#define NO_CHANGE_LED\t\t0x00\n#define ALL_COLOR_LED\t\t0x01\t \n#define BLINK_GREEN_LED\t\t0x02\t \n#define BLINK_RED_LED\t\t0x04\n#define BLINK_ORANGE_LED\t0x10\t \n#define SOLID_GREEN_LED\t\t0x20\t \n#define SOLID_RED_LED\t\t0x40\t \n#define SOLID_ORANGE_LED\t0x80\n\n\n\n \n#define STREAM_COMMAND\t0x36\n#define STREAM_VIDPID\t0x00\n#define STREAM_AUDIO\t0xff\n\n\n\n \n\n \n#define UNIQUE_BL_ID\t\t0x34\n\n \n#define FLASH_DATA_MASK\t\t0x55\n\n \n#define GET_SW_VERSION_COMMAND\t0x00\n#define SET_PAGE_COMMAND\t0x01\n#define ERASE_PAGE_COMMAND\t0x02\n#define WRITE_PAGE_COMMAND\t0x03\n#define CRC_ON_PAGE_COMMAND\t0x04\n#define READ_FLASH_BYTE_COMMAND\t0x05\n#define RESET_DEVICE_COMMAND\t0x06\n#define GET_HW_VERSION_COMMAND\t0x07\n#define BLANK\t\t\t0xff\n\n \n#define COMMAND_OK\t\t0x01\n#define COMMAND_FAILED\t\t0x02\n#define COMMAND_PENDING\t\t0x03\n\n\n\n \n\n \nstatic int si470x_get_report(struct si470x_device *radio, void *buf, int size)\n{\n\tunsigned char *report = buf;\n\tint retval;\n\n\tretval = usb_control_msg(radio->usbdev,\n\t\tusb_rcvctrlpipe(radio->usbdev, 0),\n\t\tHID_REQ_GET_REPORT,\n\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\treport[0], 2,\n\t\tbuf, size, usb_timeout);\n\n\tif (retval < 0)\n\t\tdev_warn(&radio->intf->dev,\n\t\t\t\"si470x_get_report: usb_control_msg returned %d\\n\",\n\t\t\tretval);\n\treturn retval;\n}\n\n\n \nstatic int si470x_set_report(struct si470x_device *radio, void *buf, int size)\n{\n\tunsigned char *report = buf;\n\tint retval;\n\n\tretval = usb_control_msg(radio->usbdev,\n\t\tusb_sndctrlpipe(radio->usbdev, 0),\n\t\tHID_REQ_SET_REPORT,\n\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT,\n\t\treport[0], 2,\n\t\tbuf, size, usb_timeout);\n\n\tif (retval < 0)\n\t\tdev_warn(&radio->intf->dev,\n\t\t\t\"si470x_set_report: usb_control_msg returned %d\\n\",\n\t\t\tretval);\n\treturn retval;\n}\n\n\n \nstatic int si470x_get_register(struct si470x_device *radio, int regnr)\n{\n\tint retval;\n\n\tradio->usb_buf[0] = REGISTER_REPORT(regnr);\n\n\tretval = si470x_get_report(radio, radio->usb_buf, REGISTER_REPORT_SIZE);\n\n\tif (retval >= 0)\n\t\tradio->registers[regnr] = get_unaligned_be16(&radio->usb_buf[1]);\n\n\treturn (retval < 0) ? -EINVAL : 0;\n}\n\n\n \nstatic int si470x_set_register(struct si470x_device *radio, int regnr)\n{\n\tint retval;\n\n\tradio->usb_buf[0] = REGISTER_REPORT(regnr);\n\tput_unaligned_be16(radio->registers[regnr], &radio->usb_buf[1]);\n\n\tretval = si470x_set_report(radio, radio->usb_buf, REGISTER_REPORT_SIZE);\n\n\treturn (retval < 0) ? -EINVAL : 0;\n}\n\n\n\n \n\n \nstatic int si470x_get_all_registers(struct si470x_device *radio)\n{\n\tint retval;\n\tunsigned char regnr;\n\n\tradio->usb_buf[0] = ENTIRE_REPORT;\n\n\tretval = si470x_get_report(radio, radio->usb_buf, ENTIRE_REPORT_SIZE);\n\n\tif (retval >= 0)\n\t\tfor (regnr = 0; regnr < RADIO_REGISTER_NUM; regnr++)\n\t\t\tradio->registers[regnr] = get_unaligned_be16(\n\t\t\t\t&radio->usb_buf[regnr * RADIO_REGISTER_SIZE + 1]);\n\n\treturn (retval < 0) ? -EINVAL : 0;\n}\n\n\n\n \n\n \nstatic int si470x_set_led_state(struct si470x_device *radio,\n\t\tunsigned char led_state)\n{\n\tint retval;\n\n\tradio->usb_buf[0] = LED_REPORT;\n\tradio->usb_buf[1] = LED_COMMAND;\n\tradio->usb_buf[2] = led_state;\n\n\tretval = si470x_set_report(radio, radio->usb_buf, LED_REPORT_SIZE);\n\n\treturn (retval < 0) ? -EINVAL : 0;\n}\n\n\n\n \n\n \nstatic int si470x_get_scratch_page_versions(struct si470x_device *radio)\n{\n\tint retval;\n\n\tradio->usb_buf[0] = SCRATCH_REPORT;\n\n\tretval = si470x_get_report(radio, radio->usb_buf, SCRATCH_REPORT_SIZE);\n\n\tif (retval < 0)\n\t\tdev_warn(&radio->intf->dev, \"si470x_get_scratch: si470x_get_report returned %d\\n\",\n\t\t\t retval);\n\telse {\n\t\tradio->software_version = radio->usb_buf[1];\n\t\tradio->hardware_version = radio->usb_buf[2];\n\t}\n\n\treturn (retval < 0) ? -EINVAL : 0;\n}\n\n\n\n \n\n \nstatic void si470x_int_in_callback(struct urb *urb)\n{\n\tstruct si470x_device *radio = urb->context;\n\tint retval;\n\tunsigned char regnr;\n\tunsigned char blocknum;\n\tunsigned short bler;  \n\tunsigned short rds;\n\tunsigned char tmpbuf[3];\n\n\tif (urb->status) {\n\t\tif (urb->status == -ENOENT ||\n\t\t\t\turb->status == -ECONNRESET ||\n\t\t\t\turb->status == -ESHUTDOWN) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tdev_warn(&radio->intf->dev,\n\t\t\t \"non-zero urb status (%d)\\n\", urb->status);\n\t\t\tgoto resubmit;  \n\t\t}\n\t}\n\n\t \n\tif (urb->actual_length != RDS_REPORT_SIZE)\n\t\tgoto resubmit;\n\n\tradio->registers[STATUSRSSI] =\n\t\tget_unaligned_be16(&radio->int_in_buffer[1]);\n\n\tif (radio->registers[STATUSRSSI] & STATUSRSSI_STC)\n\t\tcomplete(&radio->completion);\n\n\tif ((radio->registers[SYSCONFIG1] & SYSCONFIG1_RDS)) {\n\t\t \n\t\tfor (regnr = 1; regnr < RDS_REGISTER_NUM; regnr++)\n\t\t\tradio->registers[STATUSRSSI + regnr] =\n\t\t\t    get_unaligned_be16(&radio->int_in_buffer[\n\t\t\t\tregnr * RADIO_REGISTER_SIZE + 1]);\n\t\t \n\t\tif ((radio->registers[STATUSRSSI] & STATUSRSSI_RDSR) == 0) {\n\t\t\t \n\t\t\tgoto resubmit;\n\t\t}\n\t\tif ((radio->registers[STATUSRSSI] & STATUSRSSI_RDSS) == 0) {\n\t\t\t \n\t\t\tgoto resubmit;\n\t\t}\n\t\tfor (blocknum = 0; blocknum < 4; blocknum++) {\n\t\t\tswitch (blocknum) {\n\t\t\tdefault:\n\t\t\t\tbler = (radio->registers[STATUSRSSI] &\n\t\t\t\t\t\tSTATUSRSSI_BLERA) >> 9;\n\t\t\t\trds = radio->registers[RDSA];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tbler = (radio->registers[READCHAN] &\n\t\t\t\t\t\tREADCHAN_BLERB) >> 14;\n\t\t\t\trds = radio->registers[RDSB];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbler = (radio->registers[READCHAN] &\n\t\t\t\t\t\tREADCHAN_BLERC) >> 12;\n\t\t\t\trds = radio->registers[RDSC];\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tbler = (radio->registers[READCHAN] &\n\t\t\t\t\t\tREADCHAN_BLERD) >> 10;\n\t\t\t\trds = radio->registers[RDSD];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tput_unaligned_le16(rds, &tmpbuf);\n\t\t\ttmpbuf[2] = blocknum;\t\t \n\t\t\ttmpbuf[2] |= blocknum << 3;\t \n\t\t\tif (bler > max_rds_errors)\n\t\t\t\ttmpbuf[2] |= 0x80;  \n\t\t\telse if (bler > 0)\n\t\t\t\ttmpbuf[2] |= 0x40;  \n\n\t\t\t \n\t\t\tmemcpy(&radio->buffer[radio->wr_index], &tmpbuf, 3);\n\t\t\tradio->wr_index += 3;\n\n\t\t\t \n\t\t\tif (radio->wr_index >= radio->buf_size)\n\t\t\t\tradio->wr_index = 0;\n\n\t\t\t \n\t\t\tif (radio->wr_index == radio->rd_index) {\n\t\t\t\t \n\t\t\t\tradio->rd_index += 3;\n\t\t\t\tif (radio->rd_index >= radio->buf_size)\n\t\t\t\t\tradio->rd_index = 0;\n\t\t\t}\n\t\t}\n\t\tif (radio->wr_index != radio->rd_index)\n\t\t\twake_up_interruptible(&radio->read_queue);\n\t}\n\nresubmit:\n\t \n\tif (radio->int_in_running && radio->usbdev) {\n\t\tretval = usb_submit_urb(radio->int_in_urb, GFP_ATOMIC);\n\t\tif (retval) {\n\t\t\tdev_warn(&radio->intf->dev,\n\t\t\t       \"resubmitting urb failed (%d)\", retval);\n\t\t\tradio->int_in_running = 0;\n\t\t}\n\t}\n\tradio->status_rssi_auto_update = radio->int_in_running;\n}\n\n\nstatic int si470x_fops_open(struct file *file)\n{\n\treturn v4l2_fh_open(file);\n}\n\nstatic int si470x_fops_release(struct file *file)\n{\n\treturn v4l2_fh_release(file);\n}\n\nstatic void si470x_usb_release(struct v4l2_device *v4l2_dev)\n{\n\tstruct si470x_device *radio =\n\t\tcontainer_of(v4l2_dev, struct si470x_device, v4l2_dev);\n\n\tusb_free_urb(radio->int_in_urb);\n\tv4l2_ctrl_handler_free(&radio->hdl);\n\tv4l2_device_unregister(&radio->v4l2_dev);\n\tkfree(radio->int_in_buffer);\n\tkfree(radio->buffer);\n\tkfree(radio->usb_buf);\n\tkfree(radio);\n}\n\n\n \n\n \nstatic int si470x_vidioc_querycap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_capability *capability)\n{\n\tstruct si470x_device *radio = video_drvdata(file);\n\n\tstrscpy(capability->driver, DRIVER_NAME, sizeof(capability->driver));\n\tstrscpy(capability->card, DRIVER_CARD, sizeof(capability->card));\n\tusb_make_path(radio->usbdev, capability->bus_info,\n\t\t\tsizeof(capability->bus_info));\n\treturn 0;\n}\n\n\nstatic int si470x_start_usb(struct si470x_device *radio)\n{\n\tint retval;\n\n\t \n\tusb_fill_int_urb(radio->int_in_urb, radio->usbdev,\n\t\t\tusb_rcvintpipe(radio->usbdev,\n\t\t\t\tradio->int_in_endpoint->bEndpointAddress),\n\t\t\tradio->int_in_buffer,\n\t\t\tle16_to_cpu(radio->int_in_endpoint->wMaxPacketSize),\n\t\t\tsi470x_int_in_callback,\n\t\t\tradio,\n\t\t\tradio->int_in_endpoint->bInterval);\n\n\tradio->int_in_running = 1;\n\tmb();\n\n\tretval = usb_submit_urb(radio->int_in_urb, GFP_KERNEL);\n\tif (retval) {\n\t\tdev_info(&radio->intf->dev,\n\t\t\t\t\"submitting int urb failed (%d)\\n\", retval);\n\t\tradio->int_in_running = 0;\n\t}\n\tradio->status_rssi_auto_update = radio->int_in_running;\n\n\t \n\tretval = si470x_start(radio);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tv4l2_ctrl_handler_setup(&radio->hdl);\n\n\treturn retval;\n}\n\n \n\n \nstatic int si470x_usb_driver_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct si470x_device *radio;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint i, int_end_size, retval;\n\tunsigned char version_warning = 0;\n\n\t \n\tradio = kzalloc(sizeof(struct si470x_device), GFP_KERNEL);\n\tif (!radio) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_initial;\n\t}\n\tradio->usb_buf = kmalloc(MAX_REPORT_SIZE, GFP_KERNEL);\n\tif (radio->usb_buf == NULL) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_radio;\n\t}\n\tradio->usbdev = interface_to_usbdev(intf);\n\tradio->intf = intf;\n\tradio->band = 1;  \n\tmutex_init(&radio->lock);\n\tinit_completion(&radio->completion);\n\n\tradio->get_register = si470x_get_register;\n\tradio->set_register = si470x_set_register;\n\tradio->fops_open = si470x_fops_open;\n\tradio->fops_release = si470x_fops_release;\n\tradio->vidioc_querycap = si470x_vidioc_querycap;\n\n\tiface_desc = intf->cur_altsetting;\n\n\t \n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\t\tif (usb_endpoint_is_int_in(endpoint))\n\t\t\tradio->int_in_endpoint = endpoint;\n\t}\n\tif (!radio->int_in_endpoint) {\n\t\tdev_info(&intf->dev, \"could not find interrupt in endpoint\\n\");\n\t\tretval = -EIO;\n\t\tgoto err_usbbuf;\n\t}\n\n\tint_end_size = le16_to_cpu(radio->int_in_endpoint->wMaxPacketSize);\n\n\tradio->int_in_buffer = kmalloc(int_end_size, GFP_KERNEL);\n\tif (!radio->int_in_buffer) {\n\t\tdev_info(&intf->dev, \"could not allocate int_in_buffer\");\n\t\tretval = -ENOMEM;\n\t\tgoto err_usbbuf;\n\t}\n\n\tradio->int_in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!radio->int_in_urb) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_intbuffer;\n\t}\n\n\tradio->v4l2_dev.release = si470x_usb_release;\n\n\t \n\tif (id->idVendor == 0x10c4 && id->idProduct == 0x818a) {\n\t\tretval = usb_control_msg(radio->usbdev,\n\t\t\t\tusb_rcvctrlpipe(radio->usbdev, 0),\n\t\t\t\tHID_REQ_GET_REPORT,\n\t\t\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t\t\t1, 2,\n\t\t\t\tradio->usb_buf, 3, 500);\n\t\tif (retval != 3 ||\n\t\t    (get_unaligned_be16(&radio->usb_buf[1]) & 0xfff) != 0x0242) {\n\t\t\tdev_info(&intf->dev, \"this is not a si470x device.\\n\");\n\t\t\tretval = -ENODEV;\n\t\t\tgoto err_urb;\n\t\t}\n\t}\n\n\tretval = v4l2_device_register(&intf->dev, &radio->v4l2_dev);\n\tif (retval < 0) {\n\t\tdev_err(&intf->dev, \"couldn't register v4l2_device\\n\");\n\t\tgoto err_urb;\n\t}\n\n\tv4l2_ctrl_handler_init(&radio->hdl, 2);\n\tv4l2_ctrl_new_std(&radio->hdl, &si470x_ctrl_ops,\n\t\t\t  V4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\n\tv4l2_ctrl_new_std(&radio->hdl, &si470x_ctrl_ops,\n\t\t\t  V4L2_CID_AUDIO_VOLUME, 0, 15, 1, 15);\n\tif (radio->hdl.error) {\n\t\tretval = radio->hdl.error;\n\t\tdev_err(&intf->dev, \"couldn't register control\\n\");\n\t\tgoto err_dev;\n\t}\n\tradio->videodev = si470x_viddev_template;\n\tradio->videodev.ctrl_handler = &radio->hdl;\n\tradio->videodev.lock = &radio->lock;\n\tradio->videodev.v4l2_dev = &radio->v4l2_dev;\n\tradio->videodev.release = video_device_release_empty;\n\tradio->videodev.device_caps =\n\t\tV4L2_CAP_HW_FREQ_SEEK | V4L2_CAP_READWRITE | V4L2_CAP_TUNER |\n\t\tV4L2_CAP_RADIO | V4L2_CAP_RDS_CAPTURE;\n\tvideo_set_drvdata(&radio->videodev, radio);\n\n\t \n\tif (si470x_get_all_registers(radio) < 0) {\n\t\tretval = -EIO;\n\t\tgoto err_ctrl;\n\t}\n\tdev_info(&intf->dev, \"DeviceID=0x%4.4hx ChipID=0x%4.4hx\\n\",\n\t\t\tradio->registers[DEVICEID], radio->registers[SI_CHIPID]);\n\tif ((radio->registers[SI_CHIPID] & SI_CHIPID_FIRMWARE) < RADIO_FW_VERSION) {\n\t\tdev_warn(&intf->dev,\n\t\t\t\"This driver is known to work with firmware version %u, but the device has firmware version %u.\\n\",\n\t\t\tRADIO_FW_VERSION,\n\t\t\tradio->registers[SI_CHIPID] & SI_CHIPID_FIRMWARE);\n\t\tversion_warning = 1;\n\t}\n\n\t \n\tif (si470x_get_scratch_page_versions(radio) < 0) {\n\t\tretval = -EIO;\n\t\tgoto err_ctrl;\n\t}\n\tdev_info(&intf->dev, \"software version %d, hardware version %d\\n\",\n\t\t\tradio->software_version, radio->hardware_version);\n\tif (radio->hardware_version < RADIO_HW_VERSION) {\n\t\tdev_warn(&intf->dev,\n\t\t\t\"This driver is known to work with hardware version %u, but the device has hardware version %u.\\n\",\n\t\t\tRADIO_HW_VERSION,\n\t\t\tradio->hardware_version);\n\t\tversion_warning = 1;\n\t}\n\n\t \n\tif (version_warning == 1) {\n\t\tdev_warn(&intf->dev,\n\t\t\t\"If you have some trouble using this driver, please report to V4L ML at linux-media@vger.kernel.org\\n\");\n\t}\n\n\t \n\tsi470x_set_led_state(radio, BLINK_GREEN_LED);\n\n\t \n\tradio->buf_size = rds_buf * 3;\n\tradio->buffer = kmalloc(radio->buf_size, GFP_KERNEL);\n\tif (!radio->buffer) {\n\t\tretval = -EIO;\n\t\tgoto err_ctrl;\n\t}\n\n\t \n\tradio->wr_index = 0;\n\tradio->rd_index = 0;\n\tinit_waitqueue_head(&radio->read_queue);\n\tusb_set_intfdata(intf, radio);\n\n\t \n\tretval = si470x_start_usb(radio);\n\tif (retval < 0 && !radio->int_in_running)\n\t\tgoto err_buf;\n\telse if (retval < 0)\t \n\t\tgoto err_all;\n\n\t \n\tsi470x_set_freq(radio, 87.5 * FREQ_MUL);  \n\n\t \n\tretval = video_register_device(&radio->videodev, VFL_TYPE_RADIO,\n\t\t\tradio_nr);\n\tif (retval) {\n\t\tdev_err(&intf->dev, \"Could not register video device\\n\");\n\t\tgoto err_all;\n\t}\n\n\treturn 0;\nerr_all:\n\tusb_kill_urb(radio->int_in_urb);\nerr_buf:\n\tkfree(radio->buffer);\nerr_ctrl:\n\tv4l2_ctrl_handler_free(&radio->hdl);\nerr_dev:\n\tv4l2_device_unregister(&radio->v4l2_dev);\nerr_urb:\n\tusb_free_urb(radio->int_in_urb);\nerr_intbuffer:\n\tkfree(radio->int_in_buffer);\nerr_usbbuf:\n\tkfree(radio->usb_buf);\nerr_radio:\n\tkfree(radio);\nerr_initial:\n\treturn retval;\n}\n\n\n \nstatic int si470x_usb_driver_suspend(struct usb_interface *intf,\n\t\tpm_message_t message)\n{\n\tstruct si470x_device *radio = usb_get_intfdata(intf);\n\n\tdev_info(&intf->dev, \"suspending now...\\n\");\n\n\t \n\tif (radio->int_in_running) {\n\t\tradio->int_in_running = 0;\n\t\tif (radio->int_in_urb)\n\t\t\tusb_kill_urb(radio->int_in_urb);\n\t}\n\n\t \n\twake_up_interruptible(&radio->read_queue);\n\n\t \n\tsi470x_stop(radio);\n\treturn 0;\n}\n\n\n \nstatic int si470x_usb_driver_resume(struct usb_interface *intf)\n{\n\tstruct si470x_device *radio = usb_get_intfdata(intf);\n\tint ret;\n\n\tdev_info(&intf->dev, \"resuming now...\\n\");\n\n\t \n\tret = si470x_start_usb(radio);\n\tif (ret == 0)\n\t\tv4l2_ctrl_handler_setup(&radio->hdl);\n\n\treturn ret;\n}\n\n\n \nstatic void si470x_usb_driver_disconnect(struct usb_interface *intf)\n{\n\tstruct si470x_device *radio = usb_get_intfdata(intf);\n\n\tmutex_lock(&radio->lock);\n\tv4l2_device_disconnect(&radio->v4l2_dev);\n\tvideo_unregister_device(&radio->videodev);\n\tusb_kill_urb(radio->int_in_urb);\n\tusb_set_intfdata(intf, NULL);\n\tmutex_unlock(&radio->lock);\n\tv4l2_device_put(&radio->v4l2_dev);\n}\n\n\n \nstatic struct usb_driver si470x_usb_driver = {\n\t.name\t\t\t= DRIVER_NAME,\n\t.probe\t\t\t= si470x_usb_driver_probe,\n\t.disconnect\t\t= si470x_usb_driver_disconnect,\n\t.suspend\t\t= si470x_usb_driver_suspend,\n\t.resume\t\t\t= si470x_usb_driver_resume,\n\t.reset_resume\t\t= si470x_usb_driver_resume,\n\t.id_table\t\t= si470x_usb_driver_id_table,\n};\n\nmodule_usb_driver(si470x_usb_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_VERSION(DRIVER_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}