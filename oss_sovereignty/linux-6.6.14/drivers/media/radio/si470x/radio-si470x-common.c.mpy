{
  "module_name": "radio-si470x-common.c",
  "hash_id": "7bead0db2b5db6851a9f7ab005ecc108a98cf57a140288e2791ebc758a6f7c90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/si470x/radio-si470x-common.c",
  "human_readable_source": "\n \n\n\n \n\n\n \n#include \"radio-si470x.h\"\n\n \n\n \n \n \n \nstatic unsigned short space = 2;\nmodule_param(space, ushort, 0444);\nMODULE_PARM_DESC(space, \"Spacing: 0=200kHz 1=100kHz *2=50kHz*\");\n\n \n \n \nstatic unsigned short de = 1;\nmodule_param(de, ushort, 0444);\nMODULE_PARM_DESC(de, \"De-emphasis: 0=75us *1=50us*\");\n\n \nstatic unsigned int tune_timeout = 3000;\nmodule_param(tune_timeout, uint, 0644);\nMODULE_PARM_DESC(tune_timeout, \"Tune timeout: *3000*\");\n\n \nstatic unsigned int seek_timeout = 5000;\nmodule_param(seek_timeout, uint, 0644);\nMODULE_PARM_DESC(seek_timeout, \"Seek timeout: *5000*\");\n\nstatic const struct v4l2_frequency_band bands[] = {\n\t{\n\t\t.type = V4L2_TUNER_RADIO,\n\t\t.index = 0,\n\t\t.capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO |\n\t\t\t    V4L2_TUNER_CAP_RDS | V4L2_TUNER_CAP_RDS_BLOCK_IO |\n\t\t\t    V4L2_TUNER_CAP_FREQ_BANDS |\n\t\t\t    V4L2_TUNER_CAP_HWSEEK_BOUNDED |\n\t\t\t    V4L2_TUNER_CAP_HWSEEK_WRAP,\n\t\t.rangelow   =  87500 * 16,\n\t\t.rangehigh  = 108000 * 16,\n\t\t.modulation = V4L2_BAND_MODULATION_FM,\n\t},\n\t{\n\t\t.type = V4L2_TUNER_RADIO,\n\t\t.index = 1,\n\t\t.capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO |\n\t\t\t    V4L2_TUNER_CAP_RDS | V4L2_TUNER_CAP_RDS_BLOCK_IO |\n\t\t\t    V4L2_TUNER_CAP_FREQ_BANDS |\n\t\t\t    V4L2_TUNER_CAP_HWSEEK_BOUNDED |\n\t\t\t    V4L2_TUNER_CAP_HWSEEK_WRAP,\n\t\t.rangelow   =  76000 * 16,\n\t\t.rangehigh  = 108000 * 16,\n\t\t.modulation = V4L2_BAND_MODULATION_FM,\n\t},\n\t{\n\t\t.type = V4L2_TUNER_RADIO,\n\t\t.index = 2,\n\t\t.capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO |\n\t\t\t    V4L2_TUNER_CAP_RDS | V4L2_TUNER_CAP_RDS_BLOCK_IO |\n\t\t\t    V4L2_TUNER_CAP_FREQ_BANDS |\n\t\t\t    V4L2_TUNER_CAP_HWSEEK_BOUNDED |\n\t\t\t    V4L2_TUNER_CAP_HWSEEK_WRAP,\n\t\t.rangelow   =  76000 * 16,\n\t\t.rangehigh  =  90000 * 16,\n\t\t.modulation = V4L2_BAND_MODULATION_FM,\n\t},\n};\n\n \n\n \nstatic int si470x_set_band(struct si470x_device *radio, int band)\n{\n\tif (radio->band == band)\n\t\treturn 0;\n\n\tradio->band = band;\n\tradio->registers[SYSCONFIG2] &= ~SYSCONFIG2_BAND;\n\tradio->registers[SYSCONFIG2] |= radio->band << 6;\n\treturn radio->set_register(radio, SYSCONFIG2);\n}\n\n \nstatic int si470x_set_chan(struct si470x_device *radio, unsigned short chan)\n{\n\tint retval;\n\tunsigned long time_left;\n\tbool timed_out = false;\n\n\tretval = radio->get_register(radio, POWERCFG);\n\tif (retval)\n\t\treturn retval;\n\n\tif ((radio->registers[POWERCFG] & (POWERCFG_ENABLE|POWERCFG_DMUTE))\n\t\t!= (POWERCFG_ENABLE|POWERCFG_DMUTE)) {\n\t\treturn 0;\n\t}\n\n\t \n\tradio->registers[CHANNEL] &= ~CHANNEL_CHAN;\n\tradio->registers[CHANNEL] |= CHANNEL_TUNE | chan;\n\tretval = radio->set_register(radio, CHANNEL);\n\tif (retval < 0)\n\t\tgoto done;\n\n\t \n\treinit_completion(&radio->completion);\n\ttime_left = wait_for_completion_timeout(&radio->completion,\n\t\t\t\t\t\tmsecs_to_jiffies(tune_timeout));\n\tif (time_left == 0)\n\t\ttimed_out = true;\n\n\tif ((radio->registers[STATUSRSSI] & STATUSRSSI_STC) == 0)\n\t\tdev_warn(&radio->videodev.dev, \"tune does not complete\\n\");\n\tif (timed_out)\n\t\tdev_warn(&radio->videodev.dev,\n\t\t\t\"tune timed out after %u ms\\n\", tune_timeout);\n\n\t \n\tradio->registers[CHANNEL] &= ~CHANNEL_TUNE;\n\tretval = radio->set_register(radio, CHANNEL);\n\ndone:\n\treturn retval;\n}\n\n \nstatic unsigned int si470x_get_step(struct si470x_device *radio)\n{\n\t \n\tswitch ((radio->registers[SYSCONFIG2] & SYSCONFIG2_SPACE) >> 4) {\n\t \n\tcase 0:\n\t\treturn 200 * 16;\n\t \n\tcase 1:\n\t\treturn 100 * 16;\n\t \n\tdefault:\n\t\treturn 50 * 16;\n\t}\n}\n\n\n \nstatic int si470x_get_freq(struct si470x_device *radio, unsigned int *freq)\n{\n\tint chan, retval;\n\n\t \n\tretval = radio->get_register(radio, READCHAN);\n\tchan = radio->registers[READCHAN] & READCHAN_READCHAN;\n\n\t \n\t*freq = chan * si470x_get_step(radio) + bands[radio->band].rangelow;\n\n\treturn retval;\n}\n\n\n \nint si470x_set_freq(struct si470x_device *radio, unsigned int freq)\n{\n\tunsigned short chan;\n\n\tfreq = clamp(freq, bands[radio->band].rangelow,\n\t\t\t   bands[radio->band].rangehigh);\n\t \n\tchan = (freq - bands[radio->band].rangelow) / si470x_get_step(radio);\n\n\treturn si470x_set_chan(radio, chan);\n}\nEXPORT_SYMBOL_GPL(si470x_set_freq);\n\n\n \nstatic int si470x_set_seek(struct si470x_device *radio,\n\t\t\t   const struct v4l2_hw_freq_seek *seek)\n{\n\tint band, retval;\n\tunsigned int freq;\n\tbool timed_out = false;\n\tunsigned long time_left;\n\n\t \n\tif (seek->rangelow || seek->rangehigh) {\n\t\tfor (band = 0; band < ARRAY_SIZE(bands); band++) {\n\t\t\tif (bands[band].rangelow  == seek->rangelow &&\n\t\t\t    bands[band].rangehigh == seek->rangehigh)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (band == ARRAY_SIZE(bands))\n\t\t\treturn -EINVAL;  \n\t} else\n\t\tband = 1;  \n\n\tif (radio->band != band) {\n\t\tretval = si470x_get_freq(radio, &freq);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tretval = si470x_set_band(radio, band);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tretval = si470x_set_freq(radio, freq);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t \n\tradio->registers[POWERCFG] |= POWERCFG_SEEK;\n\tif (seek->wrap_around)\n\t\tradio->registers[POWERCFG] &= ~POWERCFG_SKMODE;\n\telse\n\t\tradio->registers[POWERCFG] |= POWERCFG_SKMODE;\n\tif (seek->seek_upward)\n\t\tradio->registers[POWERCFG] |= POWERCFG_SEEKUP;\n\telse\n\t\tradio->registers[POWERCFG] &= ~POWERCFG_SEEKUP;\n\tretval = radio->set_register(radio, POWERCFG);\n\tif (retval < 0)\n\t\treturn retval;\n\n\t \n\treinit_completion(&radio->completion);\n\ttime_left = wait_for_completion_timeout(&radio->completion,\n\t\t\t\t\t\tmsecs_to_jiffies(seek_timeout));\n\tif (time_left == 0)\n\t\ttimed_out = true;\n\n\tif ((radio->registers[STATUSRSSI] & STATUSRSSI_STC) == 0)\n\t\tdev_warn(&radio->videodev.dev, \"seek does not complete\\n\");\n\tif (radio->registers[STATUSRSSI] & STATUSRSSI_SF)\n\t\tdev_warn(&radio->videodev.dev,\n\t\t\t\"seek failed / band limit reached\\n\");\n\n\t \n\tradio->registers[POWERCFG] &= ~POWERCFG_SEEK;\n\tretval = radio->set_register(radio, POWERCFG);\n\n\t \n\tif (retval == 0 && timed_out)\n\t\treturn -ENODATA;\n\treturn retval;\n}\n\n\n \nint si470x_start(struct si470x_device *radio)\n{\n\tint retval;\n\n\t \n\tradio->registers[POWERCFG] =\n\t\tPOWERCFG_DMUTE | POWERCFG_ENABLE | POWERCFG_RDSM;\n\tretval = radio->set_register(radio, POWERCFG);\n\tif (retval < 0)\n\t\tgoto done;\n\n\t \n\tradio->registers[SYSCONFIG1] |= SYSCONFIG1_RDSIEN | SYSCONFIG1_STCIEN |\n\t\t\t\t\tSYSCONFIG1_RDS;\n\tradio->registers[SYSCONFIG1] &= ~SYSCONFIG1_GPIO2;\n\tradio->registers[SYSCONFIG1] |= SYSCONFIG1_GPIO2_INT;\n\tif (de)\n\t\tradio->registers[SYSCONFIG1] |= SYSCONFIG1_DE;\n\tretval = radio->set_register(radio, SYSCONFIG1);\n\tif (retval < 0)\n\t\tgoto done;\n\n\t \n\tradio->registers[SYSCONFIG2] =\n\t\t(0x1f  << 8) |\t\t\t\t \n\t\t((radio->band << 6) & SYSCONFIG2_BAND) | \n\t\t((space << 4) & SYSCONFIG2_SPACE) |\t \n\t\t15;\t\t\t\t\t \n\tretval = radio->set_register(radio, SYSCONFIG2);\n\tif (retval < 0)\n\t\tgoto done;\n\n\t \n\tretval = si470x_set_chan(radio,\n\t\tradio->registers[CHANNEL] & CHANNEL_CHAN);\n\ndone:\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(si470x_start);\n\n\n \nint si470x_stop(struct si470x_device *radio)\n{\n\tint retval;\n\n\t \n\tradio->registers[SYSCONFIG1] &= ~SYSCONFIG1_RDS;\n\tretval = radio->set_register(radio, SYSCONFIG1);\n\tif (retval < 0)\n\t\tgoto done;\n\n\t \n\tradio->registers[POWERCFG] &= ~POWERCFG_DMUTE;\n\t \n\tradio->registers[POWERCFG] |= POWERCFG_ENABLE |\tPOWERCFG_DISABLE;\n\tretval = radio->set_register(radio, POWERCFG);\n\ndone:\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(si470x_stop);\n\n\n \nstatic int si470x_rds_on(struct si470x_device *radio)\n{\n\tint retval;\n\n\t \n\tradio->registers[SYSCONFIG1] |= SYSCONFIG1_RDS;\n\tretval = radio->set_register(radio, SYSCONFIG1);\n\tif (retval < 0)\n\t\tradio->registers[SYSCONFIG1] &= ~SYSCONFIG1_RDS;\n\n\treturn retval;\n}\n\n\n\n \n\n \nstatic ssize_t si470x_fops_read(struct file *file, char __user *buf,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct si470x_device *radio = video_drvdata(file);\n\tint retval = 0;\n\tunsigned int block_count = 0;\n\n\t \n\tif ((radio->registers[SYSCONFIG1] & SYSCONFIG1_RDS) == 0)\n\t\tsi470x_rds_on(radio);\n\n\t \n\twhile (radio->wr_index == radio->rd_index) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EWOULDBLOCK;\n\t\t\tgoto done;\n\t\t}\n\t\tif (wait_event_interruptible(radio->read_queue,\n\t\t\tradio->wr_index != radio->rd_index) < 0) {\n\t\t\tretval = -EINTR;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tcount /= 3;\n\n\t \n\twhile (block_count < count) {\n\t\tif (radio->rd_index == radio->wr_index)\n\t\t\tbreak;\n\n\t\t \n\t\tif (copy_to_user(buf, &radio->buffer[radio->rd_index], 3))\n\t\t\t \n\t\t\tbreak;\n\n\t\t \n\t\tradio->rd_index += 3;\n\t\tif (radio->rd_index >= radio->buf_size)\n\t\t\tradio->rd_index = 0;\n\n\t\t \n\t\tblock_count++;\n\t\tbuf += 3;\n\t\tretval += 3;\n\t}\n\ndone:\n\treturn retval;\n}\n\n\n \nstatic __poll_t si470x_fops_poll(struct file *file,\n\t\tstruct poll_table_struct *pts)\n{\n\tstruct si470x_device *radio = video_drvdata(file);\n\t__poll_t req_events = poll_requested_events(pts);\n\t__poll_t retval = v4l2_ctrl_poll(file, pts);\n\n\tif (req_events & (EPOLLIN | EPOLLRDNORM)) {\n\t\t \n\t\tif ((radio->registers[SYSCONFIG1] & SYSCONFIG1_RDS) == 0)\n\t\t\tsi470x_rds_on(radio);\n\n\t\tpoll_wait(file, &radio->read_queue, pts);\n\n\t\tif (radio->rd_index != radio->wr_index)\n\t\t\tretval |= EPOLLIN | EPOLLRDNORM;\n\t}\n\n\treturn retval;\n}\n\n\nstatic int si470x_fops_open(struct file *file)\n{\n\tstruct si470x_device *radio = video_drvdata(file);\n\n\treturn radio->fops_open(file);\n}\n\n\n \nstatic int si470x_fops_release(struct file *file)\n{\n\tstruct si470x_device *radio = video_drvdata(file);\n\n\treturn radio->fops_release(file);\n}\n\n\n \nstatic const struct v4l2_file_operations si470x_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.read\t\t\t= si470x_fops_read,\n\t.poll\t\t\t= si470x_fops_poll,\n\t.unlocked_ioctl\t\t= video_ioctl2,\n\t.open\t\t\t= si470x_fops_open,\n\t.release\t\t= si470x_fops_release,\n};\n\n\n\n \n\n\nstatic int si470x_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct si470x_device *radio =\n\t\tcontainer_of(ctrl->handler, struct si470x_device, hdl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_VOLUME:\n\t\tradio->registers[SYSCONFIG2] &= ~SYSCONFIG2_VOLUME;\n\t\tradio->registers[SYSCONFIG2] |= ctrl->val;\n\t\treturn radio->set_register(radio, SYSCONFIG2);\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\tif (ctrl->val)\n\t\t\tradio->registers[POWERCFG] &= ~POWERCFG_DMUTE;\n\t\telse\n\t\t\tradio->registers[POWERCFG] |= POWERCFG_DMUTE;\n\t\treturn radio->set_register(radio, POWERCFG);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n\n \nstatic int si470x_vidioc_g_tuner(struct file *file, void *priv,\n\t\tstruct v4l2_tuner *tuner)\n{\n\tstruct si470x_device *radio = video_drvdata(file);\n\tint retval = 0;\n\n\tif (tuner->index != 0)\n\t\treturn -EINVAL;\n\n\tif (!radio->status_rssi_auto_update) {\n\t\tretval = radio->get_register(radio, STATUSRSSI);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\t \n\tstrscpy(tuner->name, \"FM\", sizeof(tuner->name));\n\ttuner->type = V4L2_TUNER_RADIO;\n\ttuner->capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO |\n\t\t\t    V4L2_TUNER_CAP_RDS | V4L2_TUNER_CAP_RDS_BLOCK_IO |\n\t\t\t    V4L2_TUNER_CAP_HWSEEK_BOUNDED |\n\t\t\t    V4L2_TUNER_CAP_HWSEEK_WRAP;\n\ttuner->rangelow  =  76 * FREQ_MUL;\n\ttuner->rangehigh = 108 * FREQ_MUL;\n\n\t \n\tif ((radio->registers[STATUSRSSI] & STATUSRSSI_ST) == 0)\n\t\ttuner->rxsubchans = V4L2_TUNER_SUB_MONO;\n\telse\n\t\ttuner->rxsubchans = V4L2_TUNER_SUB_STEREO;\n\t \n\ttuner->rxsubchans |= V4L2_TUNER_SUB_RDS;\n\n\t \n\tif ((radio->registers[POWERCFG] & POWERCFG_MONO) == 0)\n\t\ttuner->audmode = V4L2_TUNER_MODE_STEREO;\n\telse\n\t\ttuner->audmode = V4L2_TUNER_MODE_MONO;\n\n\t \n\t \n\ttuner->signal = (radio->registers[STATUSRSSI] & STATUSRSSI_RSSI);\n\t \n\ttuner->signal = (tuner->signal * 873) + (8 * tuner->signal / 10);\n\tif (tuner->signal > 0xffff)\n\t\ttuner->signal = 0xffff;\n\n\t \n\t \n\ttuner->afc = (radio->registers[STATUSRSSI] & STATUSRSSI_AFCRL) ? 1 : 0;\n\n\treturn retval;\n}\n\n\n \nstatic int si470x_vidioc_s_tuner(struct file *file, void *priv,\n\t\tconst struct v4l2_tuner *tuner)\n{\n\tstruct si470x_device *radio = video_drvdata(file);\n\n\tif (tuner->index != 0)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (tuner->audmode) {\n\tcase V4L2_TUNER_MODE_MONO:\n\t\tradio->registers[POWERCFG] |= POWERCFG_MONO;   \n\t\tbreak;\n\tcase V4L2_TUNER_MODE_STEREO:\n\tdefault:\n\t\tradio->registers[POWERCFG] &= ~POWERCFG_MONO;  \n\t\tbreak;\n\t}\n\n\treturn radio->set_register(radio, POWERCFG);\n}\n\n\n \nstatic int si470x_vidioc_g_frequency(struct file *file, void *priv,\n\t\tstruct v4l2_frequency *freq)\n{\n\tstruct si470x_device *radio = video_drvdata(file);\n\n\tif (freq->tuner != 0)\n\t\treturn -EINVAL;\n\n\tfreq->type = V4L2_TUNER_RADIO;\n\treturn si470x_get_freq(radio, &freq->frequency);\n}\n\n\n \nstatic int si470x_vidioc_s_frequency(struct file *file, void *priv,\n\t\tconst struct v4l2_frequency *freq)\n{\n\tstruct si470x_device *radio = video_drvdata(file);\n\tint retval;\n\n\tif (freq->tuner != 0)\n\t\treturn -EINVAL;\n\n\tif (freq->frequency < bands[radio->band].rangelow ||\n\t    freq->frequency > bands[radio->band].rangehigh) {\n\t\t \n\t\tretval = si470x_set_band(radio, 1);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\treturn si470x_set_freq(radio, freq->frequency);\n}\n\n\n \nstatic int si470x_vidioc_s_hw_freq_seek(struct file *file, void *priv,\n\t\tconst struct v4l2_hw_freq_seek *seek)\n{\n\tstruct si470x_device *radio = video_drvdata(file);\n\n\tif (seek->tuner != 0)\n\t\treturn -EINVAL;\n\n\tif (file->f_flags & O_NONBLOCK)\n\t\treturn -EWOULDBLOCK;\n\n\treturn si470x_set_seek(radio, seek);\n}\n\n \nstatic int si470x_vidioc_enum_freq_bands(struct file *file, void *priv,\n\t\t\t\t\t struct v4l2_frequency_band *band)\n{\n\tif (band->tuner != 0)\n\t\treturn -EINVAL;\n\tif (band->index >= ARRAY_SIZE(bands))\n\t\treturn -EINVAL;\n\t*band = bands[band->index];\n\treturn 0;\n}\n\nconst struct v4l2_ctrl_ops si470x_ctrl_ops = {\n\t.s_ctrl = si470x_s_ctrl,\n};\nEXPORT_SYMBOL_GPL(si470x_ctrl_ops);\n\nstatic int si470x_vidioc_querycap(struct file *file, void *priv,\n\t\tstruct v4l2_capability *capability)\n{\n\tstruct si470x_device *radio = video_drvdata(file);\n\n\treturn radio->vidioc_querycap(file, priv, capability);\n};\n\n \nstatic const struct v4l2_ioctl_ops si470x_ioctl_ops = {\n\t.vidioc_querycap\t= si470x_vidioc_querycap,\n\t.vidioc_g_tuner\t\t= si470x_vidioc_g_tuner,\n\t.vidioc_s_tuner\t\t= si470x_vidioc_s_tuner,\n\t.vidioc_g_frequency\t= si470x_vidioc_g_frequency,\n\t.vidioc_s_frequency\t= si470x_vidioc_s_frequency,\n\t.vidioc_s_hw_freq_seek\t= si470x_vidioc_s_hw_freq_seek,\n\t.vidioc_enum_freq_bands = si470x_vidioc_enum_freq_bands,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\n\n \nconst struct video_device si470x_viddev_template = {\n\t.fops\t\t\t= &si470x_fops,\n\t.name\t\t\t= DRIVER_NAME,\n\t.release\t\t= video_device_release_empty,\n\t.ioctl_ops\t\t= &si470x_ioctl_ops,\n};\nEXPORT_SYMBOL_GPL(si470x_viddev_template);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}