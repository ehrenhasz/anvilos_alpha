{
  "module_name": "radio-shark.c",
  "hash_id": "9ede606eb804c5b81e6eccdd7ac54ab03ee647e1bb69af673e58079c1f4ed325",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/radio-shark.c",
  "human_readable_source": " \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/workqueue.h>\n#include <media/v4l2-device.h>\n#include <media/drv-intf/tea575x.h>\n\n#if defined(CONFIG_LEDS_CLASS) || \\\n    (defined(CONFIG_LEDS_CLASS_MODULE) && defined(CONFIG_RADIO_SHARK_MODULE))\n#define SHARK_USE_LEDS 1\n#endif\n\n \nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_DESCRIPTION(\"Griffin radioSHARK, USB radio receiver driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define SHARK_IN_EP\t\t0x83\n#define SHARK_OUT_EP\t\t0x05\n\n#define TEA575X_BIT_MONO\t(1<<22)\t\t \n#define TEA575X_BIT_BAND_MASK\t(3<<20)\n#define TEA575X_BIT_BAND_FM\t(0<<20)\n\n#define TB_LEN 6\n#define DRV_NAME \"radioshark\"\n\n#define v4l2_dev_to_shark(d) container_of(d, struct shark_device, v4l2_dev)\n\n \nenum { BLUE_LED, BLUE_PULSE_LED, RED_LED, NO_LEDS, BLUE_IS_PULSE };\n\nstruct shark_device {\n\tstruct usb_device *usbdev;\n\tstruct v4l2_device v4l2_dev;\n\tstruct snd_tea575x tea;\n\n#ifdef SHARK_USE_LEDS\n\tstruct work_struct led_work;\n\tstruct led_classdev leds[NO_LEDS];\n\tchar led_names[NO_LEDS][32];\n\tatomic_t brightness[NO_LEDS];\n\tunsigned long brightness_new;\n#endif\n\n\tu8 *transfer_buffer;\n\tu32 last_val;\n};\n\nstatic atomic_t shark_instance = ATOMIC_INIT(0);\n\nstatic void shark_write_val(struct snd_tea575x *tea, u32 val)\n{\n\tstruct shark_device *shark = tea->private_data;\n\tint i, res, actual_len;\n\n\t \n\tif (shark->last_val == val)\n\t\treturn;\n\n\tmemset(shark->transfer_buffer, 0, TB_LEN);\n\tshark->transfer_buffer[0] = 0xc0;  \n\tfor (i = 0; i < 4; i++)\n\t\tshark->transfer_buffer[i] |= (val >> (24 - i * 8)) & 0xff;\n\n\tres = usb_interrupt_msg(shark->usbdev,\n\t\t\t\tusb_sndintpipe(shark->usbdev, SHARK_OUT_EP),\n\t\t\t\tshark->transfer_buffer, TB_LEN,\n\t\t\t\t&actual_len, 1000);\n\tif (res >= 0)\n\t\tshark->last_val = val;\n\telse\n\t\tv4l2_err(&shark->v4l2_dev, \"set-freq error: %d\\n\", res);\n}\n\nstatic u32 shark_read_val(struct snd_tea575x *tea)\n{\n\tstruct shark_device *shark = tea->private_data;\n\tint i, res, actual_len;\n\tu32 val = 0;\n\n\tmemset(shark->transfer_buffer, 0, TB_LEN);\n\tshark->transfer_buffer[0] = 0x80;\n\tres = usb_interrupt_msg(shark->usbdev,\n\t\t\t\tusb_sndintpipe(shark->usbdev, SHARK_OUT_EP),\n\t\t\t\tshark->transfer_buffer, TB_LEN,\n\t\t\t\t&actual_len, 1000);\n\tif (res < 0) {\n\t\tv4l2_err(&shark->v4l2_dev, \"request-status error: %d\\n\", res);\n\t\treturn shark->last_val;\n\t}\n\n\tres = usb_interrupt_msg(shark->usbdev,\n\t\t\t\tusb_rcvintpipe(shark->usbdev, SHARK_IN_EP),\n\t\t\t\tshark->transfer_buffer, TB_LEN,\n\t\t\t\t&actual_len, 1000);\n\tif (res < 0) {\n\t\tv4l2_err(&shark->v4l2_dev, \"get-status error: %d\\n\", res);\n\t\treturn shark->last_val;\n\t}\n\n\tfor (i = 0; i < 4; i++)\n\t\tval |= shark->transfer_buffer[i] << (24 - i * 8);\n\n\tshark->last_val = val;\n\n\t \n\tif (((val & TEA575X_BIT_BAND_MASK) == TEA575X_BIT_BAND_FM) &&\n\t    !(val & TEA575X_BIT_MONO))\n\t\tshark->tea.stereo = true;\n\telse\n\t\tshark->tea.stereo = false;\n\n\treturn val;\n}\n\nstatic const struct snd_tea575x_ops shark_tea_ops = {\n\t.write_val = shark_write_val,\n\t.read_val  = shark_read_val,\n};\n\n#ifdef SHARK_USE_LEDS\nstatic void shark_led_work(struct work_struct *work)\n{\n\tstruct shark_device *shark =\n\t\tcontainer_of(work, struct shark_device, led_work);\n\tint i, res, brightness, actual_len;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (!test_and_clear_bit(i, &shark->brightness_new))\n\t\t\tcontinue;\n\n\t\tbrightness = atomic_read(&shark->brightness[i]);\n\t\tmemset(shark->transfer_buffer, 0, TB_LEN);\n\t\tif (i != RED_LED) {\n\t\t\tshark->transfer_buffer[0] = 0xA0 + i;\n\t\t\tshark->transfer_buffer[1] = brightness;\n\t\t} else\n\t\t\tshark->transfer_buffer[0] = brightness ? 0xA9 : 0xA8;\n\t\tres = usb_interrupt_msg(shark->usbdev,\n\t\t\t\t\tusb_sndintpipe(shark->usbdev, 0x05),\n\t\t\t\t\tshark->transfer_buffer, TB_LEN,\n\t\t\t\t\t&actual_len, 1000);\n\t\tif (res < 0)\n\t\t\tv4l2_err(&shark->v4l2_dev, \"set LED %s error: %d\\n\",\n\t\t\t\t shark->led_names[i], res);\n\t}\n}\n\nstatic void shark_led_set_blue(struct led_classdev *led_cdev,\n\t\t\t       enum led_brightness value)\n{\n\tstruct shark_device *shark =\n\t\tcontainer_of(led_cdev, struct shark_device, leds[BLUE_LED]);\n\n\tatomic_set(&shark->brightness[BLUE_LED], value);\n\tset_bit(BLUE_LED, &shark->brightness_new);\n\tclear_bit(BLUE_IS_PULSE, &shark->brightness_new);\n\tschedule_work(&shark->led_work);\n}\n\nstatic void shark_led_set_blue_pulse(struct led_classdev *led_cdev,\n\t\t\t\t     enum led_brightness value)\n{\n\tstruct shark_device *shark = container_of(led_cdev,\n\t\t\t\tstruct shark_device, leds[BLUE_PULSE_LED]);\n\n\tatomic_set(&shark->brightness[BLUE_PULSE_LED], 256 - value);\n\tset_bit(BLUE_PULSE_LED, &shark->brightness_new);\n\tset_bit(BLUE_IS_PULSE, &shark->brightness_new);\n\tschedule_work(&shark->led_work);\n}\n\nstatic void shark_led_set_red(struct led_classdev *led_cdev,\n\t\t\t      enum led_brightness value)\n{\n\tstruct shark_device *shark =\n\t\tcontainer_of(led_cdev, struct shark_device, leds[RED_LED]);\n\n\tatomic_set(&shark->brightness[RED_LED], value);\n\tset_bit(RED_LED, &shark->brightness_new);\n\tschedule_work(&shark->led_work);\n}\n\nstatic const struct led_classdev shark_led_templates[NO_LEDS] = {\n\t[BLUE_LED] = {\n\t\t.name\t\t= \"%s:blue:\",\n\t\t.brightness\t= LED_OFF,\n\t\t.max_brightness = 127,\n\t\t.brightness_set = shark_led_set_blue,\n\t},\n\t[BLUE_PULSE_LED] = {\n\t\t.name\t\t= \"%s:blue-pulse:\",\n\t\t.brightness\t= LED_OFF,\n\t\t.max_brightness = 255,\n\t\t.brightness_set = shark_led_set_blue_pulse,\n\t},\n\t[RED_LED] = {\n\t\t.name\t\t= \"%s:red:\",\n\t\t.brightness\t= LED_OFF,\n\t\t.max_brightness = 1,\n\t\t.brightness_set = shark_led_set_red,\n\t},\n};\n\nstatic int shark_register_leds(struct shark_device *shark, struct device *dev)\n{\n\tint i, retval;\n\n\tatomic_set(&shark->brightness[BLUE_LED], 127);\n\tINIT_WORK(&shark->led_work, shark_led_work);\n\tfor (i = 0; i < NO_LEDS; i++) {\n\t\tshark->leds[i] = shark_led_templates[i];\n\t\tsnprintf(shark->led_names[i], sizeof(shark->led_names[0]),\n\t\t\t shark->leds[i].name, shark->v4l2_dev.name);\n\t\tshark->leds[i].name = shark->led_names[i];\n\t\tretval = led_classdev_register(dev, &shark->leds[i]);\n\t\tif (retval) {\n\t\t\tv4l2_err(&shark->v4l2_dev,\n\t\t\t\t \"couldn't register led: %s\\n\",\n\t\t\t\t shark->led_names[i]);\n\t\t\treturn retval;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void shark_unregister_leds(struct shark_device *shark)\n{\n\tint i;\n\n\tfor (i = 0; i < NO_LEDS; i++)\n\t\tled_classdev_unregister(&shark->leds[i]);\n\n\tcancel_work_sync(&shark->led_work);\n}\n\nstatic inline void shark_resume_leds(struct shark_device *shark)\n{\n\tif (test_bit(BLUE_IS_PULSE, &shark->brightness_new))\n\t\tset_bit(BLUE_PULSE_LED, &shark->brightness_new);\n\telse\n\t\tset_bit(BLUE_LED, &shark->brightness_new);\n\tset_bit(RED_LED, &shark->brightness_new);\n\tschedule_work(&shark->led_work);\n}\n#else\nstatic int shark_register_leds(struct shark_device *shark, struct device *dev)\n{\n\tv4l2_warn(&shark->v4l2_dev,\n\t\t  \"CONFIG_LEDS_CLASS not enabled, LED support disabled\\n\");\n\treturn 0;\n}\nstatic inline void shark_unregister_leds(struct shark_device *shark) { }\nstatic inline void shark_resume_leds(struct shark_device *shark) { }\n#endif\n\nstatic void usb_shark_disconnect(struct usb_interface *intf)\n{\n\tstruct v4l2_device *v4l2_dev = usb_get_intfdata(intf);\n\tstruct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);\n\n\tmutex_lock(&shark->tea.mutex);\n\tv4l2_device_disconnect(&shark->v4l2_dev);\n\tsnd_tea575x_exit(&shark->tea);\n\tmutex_unlock(&shark->tea.mutex);\n\n\tshark_unregister_leds(shark);\n\n\tv4l2_device_put(&shark->v4l2_dev);\n}\n\nstatic void usb_shark_release(struct v4l2_device *v4l2_dev)\n{\n\tstruct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);\n\n\tv4l2_device_unregister(&shark->v4l2_dev);\n\tkfree(shark->transfer_buffer);\n\tkfree(shark);\n}\n\nstatic int usb_shark_probe(struct usb_interface *intf,\n\t\t\t   const struct usb_device_id *id)\n{\n\tstruct shark_device *shark;\n\tint retval = -ENOMEM;\n\tstatic const u8 ep_addresses[] = {\n\t\tSHARK_IN_EP | USB_DIR_IN,\n\t\tSHARK_OUT_EP | USB_DIR_OUT,\n\t\t0};\n\n\t \n\tif (!usb_check_int_endpoints(intf, ep_addresses)) {\n\t\tdev_err(&intf->dev, \"Invalid radioSHARK device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tshark = kzalloc(sizeof(struct shark_device), GFP_KERNEL);\n\tif (!shark)\n\t\treturn retval;\n\n\tshark->transfer_buffer = kmalloc(TB_LEN, GFP_KERNEL);\n\tif (!shark->transfer_buffer)\n\t\tgoto err_alloc_buffer;\n\n\tv4l2_device_set_name(&shark->v4l2_dev, DRV_NAME, &shark_instance);\n\n\tretval = shark_register_leds(shark, &intf->dev);\n\tif (retval)\n\t\tgoto err_reg_leds;\n\n\tshark->v4l2_dev.release = usb_shark_release;\n\tretval = v4l2_device_register(&intf->dev, &shark->v4l2_dev);\n\tif (retval) {\n\t\tv4l2_err(&shark->v4l2_dev, \"couldn't register v4l2_device\\n\");\n\t\tgoto err_reg_dev;\n\t}\n\n\tshark->usbdev = interface_to_usbdev(intf);\n\tshark->tea.v4l2_dev = &shark->v4l2_dev;\n\tshark->tea.private_data = shark;\n\tshark->tea.radio_nr = -1;\n\tshark->tea.ops = &shark_tea_ops;\n\tshark->tea.cannot_mute = true;\n\tshark->tea.has_am = true;\n\tstrscpy(shark->tea.card, \"Griffin radioSHARK\",\n\t\tsizeof(shark->tea.card));\n\tusb_make_path(shark->usbdev, shark->tea.bus_info,\n\t\tsizeof(shark->tea.bus_info));\n\n\tretval = snd_tea575x_init(&shark->tea, THIS_MODULE);\n\tif (retval) {\n\t\tv4l2_err(&shark->v4l2_dev, \"couldn't init tea5757\\n\");\n\t\tgoto err_init_tea;\n\t}\n\n\treturn 0;\n\nerr_init_tea:\n\tv4l2_device_unregister(&shark->v4l2_dev);\nerr_reg_dev:\n\tshark_unregister_leds(shark);\nerr_reg_leds:\n\tkfree(shark->transfer_buffer);\nerr_alloc_buffer:\n\tkfree(shark);\n\n\treturn retval;\n}\n\n#ifdef CONFIG_PM\nstatic int usb_shark_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\treturn 0;\n}\n\nstatic int usb_shark_resume(struct usb_interface *intf)\n{\n\tstruct v4l2_device *v4l2_dev = usb_get_intfdata(intf);\n\tstruct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);\n\n\tmutex_lock(&shark->tea.mutex);\n\tsnd_tea575x_set_freq(&shark->tea);\n\tmutex_unlock(&shark->tea.mutex);\n\n\tshark_resume_leds(shark);\n\n\treturn 0;\n}\n#endif\n\n \nstatic const struct usb_device_id usb_shark_device_table[] = {\n\t{ .match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION |\n\t\t\t USB_DEVICE_ID_MATCH_INT_CLASS,\n\t  .idVendor     = 0x077d,\n\t  .idProduct    = 0x627a,\n\t  .bcdDevice_lo = 0x0001,\n\t  .bcdDevice_hi = 0x0001,\n\t  .bInterfaceClass = 3,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, usb_shark_device_table);\n\nstatic struct usb_driver usb_shark_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.probe\t\t\t= usb_shark_probe,\n\t.disconnect\t\t= usb_shark_disconnect,\n\t.id_table\t\t= usb_shark_device_table,\n#ifdef CONFIG_PM\n\t.suspend\t\t= usb_shark_suspend,\n\t.resume\t\t\t= usb_shark_resume,\n\t.reset_resume\t\t= usb_shark_resume,\n#endif\n};\nmodule_usb_driver(usb_shark_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}