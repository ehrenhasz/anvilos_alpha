{
  "module_name": "radio-rtrack2.c",
  "hash_id": "7ddad1fefc657f1c3942a0c75ad97243c6f1329e48f9214d34c7eeb1c59b93b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/radio-rtrack2.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\t \n#include <linux/init.h>\t\t \n#include <linux/ioport.h>\t \n#include <linux/delay.h>\t \n#include <linux/videodev2.h>\t \n#include <linux/mutex.h>\n#include <linux/io.h>\t\t \n#include <linux/slab.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include \"radio-isa.h\"\n\nMODULE_AUTHOR(\"Ben Pfaff\");\nMODULE_DESCRIPTION(\"A driver for the RadioTrack II radio card.\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.1.99\");\n\n#ifndef CONFIG_RADIO_RTRACK2_PORT\n#define CONFIG_RADIO_RTRACK2_PORT -1\n#endif\n\n#define RTRACK2_MAX 2\n\nstatic int io[RTRACK2_MAX] = { [0] = CONFIG_RADIO_RTRACK2_PORT,\n\t\t\t      [1 ... (RTRACK2_MAX - 1)] = -1 };\nstatic int radio_nr[RTRACK2_MAX] = { [0 ... (RTRACK2_MAX - 1)] = -1 };\n\nmodule_param_array(io, int, NULL, 0444);\nMODULE_PARM_DESC(io, \"I/O addresses of the RadioTrack card (0x20f or 0x30f)\");\nmodule_param_array(radio_nr, int, NULL, 0444);\nMODULE_PARM_DESC(radio_nr, \"Radio device numbers\");\n\nstatic struct radio_isa_card *rtrack2_alloc(void)\n{\n\treturn kzalloc(sizeof(struct radio_isa_card), GFP_KERNEL);\n}\n\nstatic void zero(struct radio_isa_card *isa)\n{\n\toutb_p(1, isa->io);\n\toutb_p(3, isa->io);\n\toutb_p(1, isa->io);\n}\n\nstatic void one(struct radio_isa_card *isa)\n{\n\toutb_p(5, isa->io);\n\toutb_p(7, isa->io);\n\toutb_p(5, isa->io);\n}\n\nstatic int rtrack2_s_frequency(struct radio_isa_card *isa, u32 freq)\n{\n\tint i;\n\n\tfreq = freq / 200 + 856;\n\n\toutb_p(0xc8, isa->io);\n\toutb_p(0xc9, isa->io);\n\toutb_p(0xc9, isa->io);\n\n\tfor (i = 0; i < 10; i++)\n\t\tzero(isa);\n\n\tfor (i = 14; i >= 0; i--)\n\t\tif (freq & (1 << i))\n\t\t\tone(isa);\n\t\telse\n\t\t\tzero(isa);\n\n\toutb_p(0xc8, isa->io);\n\toutb_p(v4l2_ctrl_g_ctrl(isa->mute), isa->io);\n\treturn 0;\n}\n\nstatic u32 rtrack2_g_signal(struct radio_isa_card *isa)\n{\n\t \n\treturn (inb(isa->io) & 2) ? 0 : 0xffff;\n}\n\nstatic int rtrack2_s_mute_volume(struct radio_isa_card *isa, bool mute, int vol)\n{\n\toutb(mute, isa->io);\n\treturn 0;\n}\n\nstatic const struct radio_isa_ops rtrack2_ops = {\n\t.alloc = rtrack2_alloc,\n\t.s_mute_volume = rtrack2_s_mute_volume,\n\t.s_frequency = rtrack2_s_frequency,\n\t.g_signal = rtrack2_g_signal,\n};\n\nstatic const int rtrack2_ioports[] = { 0x20f, 0x30f };\n\nstatic struct radio_isa_driver rtrack2_driver = {\n\t.driver = {\n\t\t.match\t\t= radio_isa_match,\n\t\t.probe\t\t= radio_isa_probe,\n\t\t.remove\t\t= radio_isa_remove,\n\t\t.driver\t\t= {\n\t\t\t.name\t= \"radio-rtrack2\",\n\t\t},\n\t},\n\t.io_params = io,\n\t.radio_nr_params = radio_nr,\n\t.io_ports = rtrack2_ioports,\n\t.num_of_io_ports = ARRAY_SIZE(rtrack2_ioports),\n\t.region_size = 4,\n\t.card = \"AIMSlab RadioTrack II\",\n\t.ops = &rtrack2_ops,\n\t.has_stereo = true,\n};\n\nstatic int __init rtrack2_init(void)\n{\n\treturn isa_register_driver(&rtrack2_driver.driver, RTRACK2_MAX);\n}\n\nstatic void __exit rtrack2_exit(void)\n{\n\tisa_unregister_driver(&rtrack2_driver.driver);\n}\n\nmodule_init(rtrack2_init);\nmodule_exit(rtrack2_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}