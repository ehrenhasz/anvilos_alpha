{
  "module_name": "radio-sf16fmr2.c",
  "hash_id": "040daecf79cf5da8dcfac7899f0956115f78fdfe42922315549c06d57bca95ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/radio-sf16fmr2.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\t \n#include <linux/init.h>\t\t \n#include <linux/slab.h>\n#include <linux/ioport.h>\t \n#include <linux/io.h>\t\t \n#include <linux/isa.h>\n#include <linux/pnp.h>\n#include <media/drv-intf/tea575x.h>\n\nMODULE_AUTHOR(\"Ondrej Zary\");\nMODULE_DESCRIPTION(\"MediaForte SF16-FMR2 and SF16-FMD2 FM radio card driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define FMR2_MAX 2\n\nstatic int radio_nr[FMR2_MAX] = { [0 ... (FMR2_MAX - 1)] = -1 };\nmodule_param_array(radio_nr, int, NULL, 0444);\nMODULE_PARM_DESC(radio_nr, \"Radio device numbers\");\n\nstruct fmr2 {\n\tint io;\n\tstruct v4l2_device v4l2_dev;\n\tstruct snd_tea575x tea;\n\tstruct v4l2_ctrl *volume;\n\tstruct v4l2_ctrl *balance;\n\tbool is_fmd2;\n};\n\nstatic int num_fmr2_cards;\nstatic struct fmr2 *fmr2_cards[FMR2_MAX];\nstatic bool isa_registered;\nstatic bool pnp_registered;\n\n \n#define FMR2_PORT\t0x384\n\n \n#define STR_DATA\t(1 << 0)\n#define STR_CLK\t\t(1 << 1)\n#define STR_WREN\t(1 << 2)\n#define STR_MOST\t(1 << 3)\n \n#define PT_ST\t\t(1 << 4)\n#define PT_CK\t\t(1 << 5)\n#define PT_DATA\t\t(1 << 6)\n \n#define FMR2_HASVOL\t(1 << 7)\n\nstatic void fmr2_tea575x_set_pins(struct snd_tea575x *tea, u8 pins)\n{\n\tstruct fmr2 *fmr2 = tea->private_data;\n\tu8 bits = 0;\n\n\tbits |= (pins & TEA575X_DATA) ? STR_DATA : 0;\n\tbits |= (pins & TEA575X_CLK)  ? STR_CLK  : 0;\n\t \n\tbits |= (pins & TEA575X_WREN) ? 0 : STR_WREN | STR_DATA;\n\n\toutb(bits, fmr2->io);\n}\n\nstatic u8 fmr2_tea575x_get_pins(struct snd_tea575x *tea)\n{\n\tstruct fmr2 *fmr2 = tea->private_data;\n\tu8 bits = inb(fmr2->io);\n\n\treturn  ((bits & STR_DATA) ? TEA575X_DATA : 0) |\n\t\t((bits & STR_MOST) ? TEA575X_MOST : 0);\n}\n\nstatic void fmr2_tea575x_set_direction(struct snd_tea575x *tea, bool output)\n{\n}\n\nstatic const struct snd_tea575x_ops fmr2_tea_ops = {\n\t.set_pins = fmr2_tea575x_set_pins,\n\t.get_pins = fmr2_tea575x_get_pins,\n\t.set_direction = fmr2_tea575x_set_direction,\n};\n\n \n\n \n#define TC9154A_ATT_MAJ_0DB\t(1 << 0)\n#define TC9154A_ATT_MAJ_10DB\t(1 << 1)\n#define TC9154A_ATT_MAJ_20DB\t(1 << 2)\n#define TC9154A_ATT_MAJ_30DB\t(1 << 3)\n#define TC9154A_ATT_MAJ_40DB\t(1 << 4)\n#define TC9154A_ATT_MAJ_50DB\t(1 << 5)\n#define TC9154A_ATT_MAJ_60DB\t(1 << 6)\n\n#define TC9154A_ATT_MIN_0DB\t(1 << 7)\n#define TC9154A_ATT_MIN_2DB\t(1 << 8)\n#define TC9154A_ATT_MIN_4DB\t(1 << 9)\n#define TC9154A_ATT_MIN_6DB\t(1 << 10)\n#define TC9154A_ATT_MIN_8DB\t(1 << 11)\n \n#define TC9154A_CHANNEL_LEFT\t(1 << 13)\n#define TC9154A_CHANNEL_RIGHT\t(1 << 14)\n \n\n#define\tTC9154A_ATT_MAJ(x)\t(1 << x)\n#define TC9154A_ATT_MIN(x)\t(1 << (7 + x))\n\nstatic void tc9154a_set_pins(struct fmr2 *fmr2, u8 pins)\n{\n\tif (!fmr2->tea.mute)\n\t\tpins |= STR_WREN;\n\n\toutb(pins, fmr2->io);\n}\n\nstatic void tc9154a_set_attenuation(struct fmr2 *fmr2, int att, u32 channel)\n{\n\tint i;\n\tu32 reg;\n\tu8 bit;\n\n\treg = TC9154A_ATT_MAJ(att / 10) | TC9154A_ATT_MIN((att % 10) / 2);\n\treg |= channel;\n\t \n\tfor (i = 0; i < 18; i++) {\n\t\tbit = reg & (1 << i) ? PT_DATA : 0;\n\t\ttc9154a_set_pins(fmr2, bit);\n\t\tudelay(5);\n\t\ttc9154a_set_pins(fmr2, bit | PT_CK);\n\t\tudelay(5);\n\t\ttc9154a_set_pins(fmr2, bit);\n\t}\n\n\t \n\tudelay(5);\n\ttc9154a_set_pins(fmr2, PT_ST);\n\tudelay(5);\n\ttc9154a_set_pins(fmr2, 0);\n}\n\nstatic int fmr2_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct snd_tea575x *tea = container_of(ctrl->handler, struct snd_tea575x, ctrl_handler);\n\tstruct fmr2 *fmr2 = tea->private_data;\n\tint volume, balance, left, right;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_VOLUME:\n\t\tvolume = ctrl->val;\n\t\tbalance = fmr2->balance->cur.val;\n\t\tbreak;\n\tcase V4L2_CID_AUDIO_BALANCE:\n\t\tbalance = ctrl->val;\n\t\tvolume = fmr2->volume->cur.val;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tleft = right = volume;\n\tif (balance < 0)\n\t\tright = max(0, right + balance);\n\tif (balance > 0)\n\t\tleft = max(0, left - balance);\n\n\ttc9154a_set_attenuation(fmr2, abs(left - 68), TC9154A_CHANNEL_LEFT);\n\ttc9154a_set_attenuation(fmr2, abs(right - 68), TC9154A_CHANNEL_RIGHT);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops fmr2_ctrl_ops = {\n\t.s_ctrl = fmr2_s_ctrl,\n};\n\nstatic int fmr2_tea_ext_init(struct snd_tea575x *tea)\n{\n\tstruct fmr2 *fmr2 = tea->private_data;\n\n\t \n\tif (!fmr2->is_fmd2 && inb(fmr2->io) & FMR2_HASVOL) {\n\t\tfmr2->volume = v4l2_ctrl_new_std(&tea->ctrl_handler, &fmr2_ctrl_ops, V4L2_CID_AUDIO_VOLUME, 0, 68, 2, 56);\n\t\tfmr2->balance = v4l2_ctrl_new_std(&tea->ctrl_handler, &fmr2_ctrl_ops, V4L2_CID_AUDIO_BALANCE, -68, 68, 2, 0);\n\t\tif (tea->ctrl_handler.error) {\n\t\t\tprintk(KERN_ERR \"radio-sf16fmr2: can't initialize controls\\n\");\n\t\t\treturn tea->ctrl_handler.error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pnp_device_id fmr2_pnp_ids[] = {\n\t{ .id = \"MFRad13\" },  \n\t{ .id = \"\" }\n};\nMODULE_DEVICE_TABLE(pnp, fmr2_pnp_ids);\n\nstatic int fmr2_probe(struct fmr2 *fmr2, struct device *pdev, int io)\n{\n\tint err, i;\n\tchar *card_name = fmr2->is_fmd2 ? \"SF16-FMD2\" : \"SF16-FMR2\";\n\n\t \n\tfor (i = 0; i < num_fmr2_cards; i++)\n\t\tif (io == fmr2_cards[i]->io)\n\t\t\treturn -EBUSY;\n\n\tstrscpy(fmr2->v4l2_dev.name, \"radio-sf16fmr2\",\n\t\tsizeof(fmr2->v4l2_dev.name));\n\tfmr2->io = io;\n\n\tif (!request_region(fmr2->io, 2, fmr2->v4l2_dev.name)) {\n\t\tprintk(KERN_ERR \"radio-sf16fmr2: I/O port 0x%x already in use\\n\", fmr2->io);\n\t\treturn -EBUSY;\n\t}\n\n\tdev_set_drvdata(pdev, fmr2);\n\terr = v4l2_device_register(pdev, &fmr2->v4l2_dev);\n\tif (err < 0) {\n\t\tv4l2_err(&fmr2->v4l2_dev, \"Could not register v4l2_device\\n\");\n\t\trelease_region(fmr2->io, 2);\n\t\treturn err;\n\t}\n\tfmr2->tea.v4l2_dev = &fmr2->v4l2_dev;\n\tfmr2->tea.private_data = fmr2;\n\tfmr2->tea.radio_nr = radio_nr[num_fmr2_cards];\n\tfmr2->tea.ops = &fmr2_tea_ops;\n\tfmr2->tea.ext_init = fmr2_tea_ext_init;\n\tstrscpy(fmr2->tea.card, card_name, sizeof(fmr2->tea.card));\n\tsnprintf(fmr2->tea.bus_info, sizeof(fmr2->tea.bus_info), \"%s:%s\",\n\t\t\tfmr2->is_fmd2 ? \"PnP\" : \"ISA\", dev_name(pdev));\n\n\tif (snd_tea575x_init(&fmr2->tea, THIS_MODULE)) {\n\t\tprintk(KERN_ERR \"radio-sf16fmr2: Unable to detect TEA575x tuner\\n\");\n\t\trelease_region(fmr2->io, 2);\n\t\treturn -ENODEV;\n\t}\n\n\tprintk(KERN_INFO \"radio-sf16fmr2: %s radio card at 0x%x.\\n\",\n\t\t\tcard_name, fmr2->io);\n\treturn 0;\n}\n\nstatic int fmr2_isa_match(struct device *pdev, unsigned int ndev)\n{\n\tstruct fmr2 *fmr2 = kzalloc(sizeof(*fmr2), GFP_KERNEL);\n\tif (!fmr2)\n\t\treturn 0;\n\n\tif (fmr2_probe(fmr2, pdev, FMR2_PORT)) {\n\t\tkfree(fmr2);\n\t\treturn 0;\n\t}\n\tdev_set_drvdata(pdev, fmr2);\n\tfmr2_cards[num_fmr2_cards++] = fmr2;\n\n\treturn 1;\n}\n\nstatic int fmr2_pnp_probe(struct pnp_dev *pdev, const struct pnp_device_id *id)\n{\n\tint ret;\n\tstruct fmr2 *fmr2 = kzalloc(sizeof(*fmr2), GFP_KERNEL);\n\tif (!fmr2)\n\t\treturn -ENOMEM;\n\n\tfmr2->is_fmd2 = true;\n\tret = fmr2_probe(fmr2, &pdev->dev, pnp_port_start(pdev, 0));\n\tif (ret) {\n\t\tkfree(fmr2);\n\t\treturn ret;\n\t}\n\tpnp_set_drvdata(pdev, fmr2);\n\tfmr2_cards[num_fmr2_cards++] = fmr2;\n\n\treturn 0;\n}\n\nstatic void fmr2_remove(struct fmr2 *fmr2)\n{\n\tsnd_tea575x_exit(&fmr2->tea);\n\trelease_region(fmr2->io, 2);\n\tv4l2_device_unregister(&fmr2->v4l2_dev);\n\tkfree(fmr2);\n}\n\nstatic void fmr2_isa_remove(struct device *pdev, unsigned int ndev)\n{\n\tfmr2_remove(dev_get_drvdata(pdev));\n}\n\nstatic void fmr2_pnp_remove(struct pnp_dev *pdev)\n{\n\tfmr2_remove(pnp_get_drvdata(pdev));\n\tpnp_set_drvdata(pdev, NULL);\n}\n\nstatic struct isa_driver fmr2_isa_driver = {\n\t.match\t\t= fmr2_isa_match,\n\t.remove\t\t= fmr2_isa_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"radio-sf16fmr2\",\n\t},\n};\n\nstatic struct pnp_driver fmr2_pnp_driver = {\n\t.name\t\t= \"radio-sf16fmr2\",\n\t.id_table\t= fmr2_pnp_ids,\n\t.probe\t\t= fmr2_pnp_probe,\n\t.remove\t\t= fmr2_pnp_remove,\n};\n\nstatic int __init fmr2_init(void)\n{\n\tint ret;\n\n\tret = pnp_register_driver(&fmr2_pnp_driver);\n\tif (!ret)\n\t\tpnp_registered = true;\n\tret = isa_register_driver(&fmr2_isa_driver, 1);\n\tif (!ret)\n\t\tisa_registered = true;\n\n\treturn (pnp_registered || isa_registered) ? 0 : ret;\n}\n\nstatic void __exit fmr2_exit(void)\n{\n\tif (pnp_registered)\n\t\tpnp_unregister_driver(&fmr2_pnp_driver);\n\tif (isa_registered)\n\t\tisa_unregister_driver(&fmr2_isa_driver);\n}\n\nmodule_init(fmr2_init);\nmodule_exit(fmr2_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}