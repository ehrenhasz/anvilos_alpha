{
  "module_name": "radio-sf16fmi.c",
  "hash_id": "484dc621a42325bbcdf60ac66b230859ca110bd08e439dbdaf62a5192b990a33",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/radio-sf16fmi.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\t \n#include <linux/module.h>\t \n#include <linux/init.h>\t\t \n#include <linux/ioport.h>\t \n#include <linux/delay.h>\t \n#include <linux/isapnp.h>\n#include <linux/mutex.h>\n#include <linux/videodev2.h>\t \n#include <linux/io.h>\t\t \n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include \"lm7000.h\"\n\nMODULE_AUTHOR(\"Petr Vandrovec, vandrove@vc.cvut.cz and M. Kirkwood\");\nMODULE_DESCRIPTION(\"A driver for the SF16-FMI, SF16-FMP and SF16-FMD radio.\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.0.3\");\n\nstatic int io = -1;\nstatic int radio_nr = -1;\n\nmodule_param(io, int, 0);\nMODULE_PARM_DESC(io, \"I/O address of the SF16-FMI/SF16-FMP/SF16-FMD card (0x284 or 0x384)\");\nmodule_param(radio_nr, int, 0);\n\nstruct fmi\n{\n\tstruct v4l2_device v4l2_dev;\n\tstruct v4l2_ctrl_handler hdl;\n\tstruct video_device vdev;\n\tint io;\n\tbool mute;\n\tu32 curfreq;  \n\tstruct mutex lock;\n};\n\nstatic struct fmi fmi_card;\nstatic struct pnp_dev *dev;\nstatic bool pnp_attached;\n\n#define RSF16_MINFREQ (87U * 16000)\n#define RSF16_MAXFREQ (108U * 16000)\n\n#define FMI_BIT_TUN_CE\t\t(1 << 0)\n#define FMI_BIT_TUN_CLK\t\t(1 << 1)\n#define FMI_BIT_TUN_DATA\t(1 << 2)\n#define FMI_BIT_VOL_SW\t\t(1 << 3)\n#define FMI_BIT_TUN_STRQ\t(1 << 4)\n\nstatic void fmi_set_pins(void *handle, u8 pins)\n{\n\tstruct fmi *fmi = handle;\n\tu8 bits = FMI_BIT_TUN_STRQ;\n\n\tif (!fmi->mute)\n\t\tbits |= FMI_BIT_VOL_SW;\n\n\tif (pins & LM7000_DATA)\n\t\tbits |= FMI_BIT_TUN_DATA;\n\tif (pins & LM7000_CLK)\n\t\tbits |= FMI_BIT_TUN_CLK;\n\tif (pins & LM7000_CE)\n\t\tbits |= FMI_BIT_TUN_CE;\n\n\tmutex_lock(&fmi->lock);\n\toutb_p(bits, fmi->io);\n\tmutex_unlock(&fmi->lock);\n}\n\nstatic inline void fmi_mute(struct fmi *fmi)\n{\n\tmutex_lock(&fmi->lock);\n\toutb(0x00, fmi->io);\n\tmutex_unlock(&fmi->lock);\n}\n\nstatic inline void fmi_unmute(struct fmi *fmi)\n{\n\tmutex_lock(&fmi->lock);\n\toutb(0x08, fmi->io);\n\tmutex_unlock(&fmi->lock);\n}\n\nstatic inline int fmi_getsigstr(struct fmi *fmi)\n{\n\tint val;\n\tint res;\n\n\tmutex_lock(&fmi->lock);\n\tval = fmi->mute ? 0x00 : 0x08;\t \n\toutb(val, fmi->io);\n\toutb(val | 0x10, fmi->io);\n\tmsleep(143);\t\t \n\tres = (int)inb(fmi->io + 1);\n\toutb(val, fmi->io);\n\n\tmutex_unlock(&fmi->lock);\n\treturn (res & 2) ? 0 : 0xFFFF;\n}\n\nstatic void fmi_set_freq(struct fmi *fmi)\n{\n\tfmi->curfreq = clamp(fmi->curfreq, RSF16_MINFREQ, RSF16_MAXFREQ);\n\t \n\tlm7000_set_freq((fmi->curfreq / 800) * 800, fmi, fmi_set_pins);\n}\n\nstatic int vidioc_querycap(struct file *file, void  *priv,\n\t\t\t\t\tstruct v4l2_capability *v)\n{\n\tstrscpy(v->driver, \"radio-sf16fmi\", sizeof(v->driver));\n\tstrscpy(v->card, \"SF16-FMI/FMP/FMD radio\", sizeof(v->card));\n\tstrscpy(v->bus_info, \"ISA:radio-sf16fmi\", sizeof(v->bus_info));\n\treturn 0;\n}\n\nstatic int vidioc_g_tuner(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_tuner *v)\n{\n\tstruct fmi *fmi = video_drvdata(file);\n\n\tif (v->index > 0)\n\t\treturn -EINVAL;\n\n\tstrscpy(v->name, \"FM\", sizeof(v->name));\n\tv->type = V4L2_TUNER_RADIO;\n\tv->rangelow = RSF16_MINFREQ;\n\tv->rangehigh = RSF16_MAXFREQ;\n\tv->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;\n\tv->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_LOW;\n\tv->audmode = V4L2_TUNER_MODE_STEREO;\n\tv->signal = fmi_getsigstr(fmi);\n\treturn 0;\n}\n\nstatic int vidioc_s_tuner(struct file *file, void *priv,\n\t\t\t\t\tconst struct v4l2_tuner *v)\n{\n\treturn v->index ? -EINVAL : 0;\n}\n\nstatic int vidioc_s_frequency(struct file *file, void *priv,\n\t\t\t\t\tconst struct v4l2_frequency *f)\n{\n\tstruct fmi *fmi = video_drvdata(file);\n\n\tif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\n\t\treturn -EINVAL;\n\n\tfmi->curfreq = f->frequency;\n\tfmi_set_freq(fmi);\n\n\treturn 0;\n}\n\nstatic int vidioc_g_frequency(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_frequency *f)\n{\n\tstruct fmi *fmi = video_drvdata(file);\n\n\tif (f->tuner != 0)\n\t\treturn -EINVAL;\n\tf->type = V4L2_TUNER_RADIO;\n\tf->frequency = fmi->curfreq;\n\treturn 0;\n}\n\nstatic int fmi_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct fmi *fmi = container_of(ctrl->handler, struct fmi, hdl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\tif (ctrl->val)\n\t\t\tfmi_mute(fmi);\n\t\telse\n\t\t\tfmi_unmute(fmi);\n\t\tfmi->mute = ctrl->val;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct v4l2_ctrl_ops fmi_ctrl_ops = {\n\t.s_ctrl = fmi_s_ctrl,\n};\n\nstatic const struct v4l2_file_operations fmi_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= v4l2_fh_open,\n\t.release\t= v4l2_fh_release,\n\t.poll\t\t= v4l2_ctrl_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops fmi_ioctl_ops = {\n\t.vidioc_querycap    = vidioc_querycap,\n\t.vidioc_g_tuner     = vidioc_g_tuner,\n\t.vidioc_s_tuner     = vidioc_s_tuner,\n\t.vidioc_g_frequency = vidioc_g_frequency,\n\t.vidioc_s_frequency = vidioc_s_frequency,\n\t.vidioc_log_status  = v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\n \nstatic struct isapnp_device_id id_table[] = {\n\t\t \n\t{\tISAPNP_ANY_ID, ISAPNP_ANY_ID,\n\t\tISAPNP_VENDOR('M','F','R'), ISAPNP_FUNCTION(0xad10), 0},\n\t\t \n\t{\tISAPNP_ANY_ID, ISAPNP_ANY_ID,\n\t\tISAPNP_VENDOR('M','F','R'), ISAPNP_FUNCTION(0xad12), 0},\n\t{\tISAPNP_CARD_END, },\n};\n\nMODULE_DEVICE_TABLE(isapnp, id_table);\n\nstatic int __init isapnp_fmi_probe(void)\n{\n\tint i = 0;\n\n\twhile (id_table[i].card_vendor != 0 && dev == NULL) {\n\t\tdev = pnp_find_dev(NULL, id_table[i].vendor,\n\t\t\t\t   id_table[i].function, NULL);\n\t\ti++;\n\t}\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\tif (pnp_device_attach(dev) < 0)\n\t\treturn -EAGAIN;\n\tif (pnp_activate_dev(dev) < 0) {\n\t\tprintk(KERN_ERR \"radio-sf16fmi: PnP configure failed (out of resources?)\\n\");\n\t\tpnp_device_detach(dev);\n\t\treturn -ENOMEM;\n\t}\n\tif (!pnp_port_valid(dev, 0)) {\n\t\tpnp_device_detach(dev);\n\t\treturn -ENODEV;\n\t}\n\n\ti = pnp_port_start(dev, 0);\n\tprintk(KERN_INFO \"radio-sf16fmi: PnP reports card at %#x\\n\", i);\n\n\treturn i;\n}\n\nstatic int __init fmi_init(void)\n{\n\tstruct fmi *fmi = &fmi_card;\n\tstruct v4l2_device *v4l2_dev = &fmi->v4l2_dev;\n\tstruct v4l2_ctrl_handler *hdl = &fmi->hdl;\n\tint res, i;\n\tstatic const int probe_ports[] = { 0, 0x284, 0x384 };\n\n\tif (io < 0) {\n\t\tfor (i = 0; i < ARRAY_SIZE(probe_ports); i++) {\n\t\t\tio = probe_ports[i];\n\t\t\tif (io == 0) {\n\t\t\t\tio = isapnp_fmi_probe();\n\t\t\t\tif (io < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tpnp_attached = true;\n\t\t\t}\n\t\t\tif (!request_region(io, 2, \"radio-sf16fmi\")) {\n\t\t\t\tif (pnp_attached)\n\t\t\t\t\tpnp_device_detach(dev);\n\t\t\t\tio = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pnp_attached ||\n\t\t\t    ((inb(io) & 0xf9) == 0xf9 && (inb(io) & 0x4) == 0))\n\t\t\t\tbreak;\n\t\t\trelease_region(io, 2);\n\t\t\tio = -1;\n\t\t}\n\t} else {\n\t\tif (!request_region(io, 2, \"radio-sf16fmi\")) {\n\t\t\tprintk(KERN_ERR \"radio-sf16fmi: port %#x already in use\\n\", io);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (inb(io) == 0xff) {\n\t\t\tprintk(KERN_ERR \"radio-sf16fmi: card not present at %#x\\n\", io);\n\t\t\trelease_region(io, 2);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tif (io < 0) {\n\t\tprintk(KERN_ERR \"radio-sf16fmi: no cards found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tstrscpy(v4l2_dev->name, \"sf16fmi\", sizeof(v4l2_dev->name));\n\tfmi->io = io;\n\n\tres = v4l2_device_register(NULL, v4l2_dev);\n\tif (res < 0) {\n\t\trelease_region(fmi->io, 2);\n\t\tif (pnp_attached)\n\t\t\tpnp_device_detach(dev);\n\t\tv4l2_err(v4l2_dev, \"Could not register v4l2_device\\n\");\n\t\treturn res;\n\t}\n\n\tv4l2_ctrl_handler_init(hdl, 1);\n\tv4l2_ctrl_new_std(hdl, &fmi_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\n\tv4l2_dev->ctrl_handler = hdl;\n\tif (hdl->error) {\n\t\tres = hdl->error;\n\t\tv4l2_err(v4l2_dev, \"Could not register controls\\n\");\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\tv4l2_device_unregister(v4l2_dev);\n\t\treturn res;\n\t}\n\n\tstrscpy(fmi->vdev.name, v4l2_dev->name, sizeof(fmi->vdev.name));\n\tfmi->vdev.v4l2_dev = v4l2_dev;\n\tfmi->vdev.fops = &fmi_fops;\n\tfmi->vdev.ioctl_ops = &fmi_ioctl_ops;\n\tfmi->vdev.release = video_device_release_empty;\n\tfmi->vdev.device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;\n\tvideo_set_drvdata(&fmi->vdev, fmi);\n\n\tmutex_init(&fmi->lock);\n\n\t \n\tfmi->mute = true;\n\tfmi->curfreq = RSF16_MINFREQ;\n\tfmi_set_freq(fmi);\n\n\tif (video_register_device(&fmi->vdev, VFL_TYPE_RADIO, radio_nr) < 0) {\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\tv4l2_device_unregister(v4l2_dev);\n\t\trelease_region(fmi->io, 2);\n\t\tif (pnp_attached)\n\t\t\tpnp_device_detach(dev);\n\t\treturn -EINVAL;\n\t}\n\n\tv4l2_info(v4l2_dev, \"card driver at 0x%x\\n\", fmi->io);\n\treturn 0;\n}\n\nstatic void __exit fmi_exit(void)\n{\n\tstruct fmi *fmi = &fmi_card;\n\n\tv4l2_ctrl_handler_free(&fmi->hdl);\n\tvideo_unregister_device(&fmi->vdev);\n\tv4l2_device_unregister(&fmi->v4l2_dev);\n\trelease_region(fmi->io, 2);\n\tif (dev && pnp_attached)\n\t\tpnp_device_detach(dev);\n}\n\nmodule_init(fmi_init);\nmodule_exit(fmi_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}