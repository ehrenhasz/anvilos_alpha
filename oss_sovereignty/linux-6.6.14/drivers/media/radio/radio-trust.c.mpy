{
  "module_name": "radio-trust.c",
  "hash_id": "dfbc378a1086186495be4b2ad117c3d0a524e87f1f9ce90e90da0023c0b8dee4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/radio-trust.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/videodev2.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include \"radio-isa.h\"\n\nMODULE_AUTHOR(\"Eric Lammerts, Russell Kroll, Quay Lu, Donald Song, Jason Lewis, Scott McGrath, William McGrath\");\nMODULE_DESCRIPTION(\"A driver for the Trust FM Radio card.\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.1.99\");\n\n \n\n#ifndef CONFIG_RADIO_TRUST_PORT\n#define CONFIG_RADIO_TRUST_PORT -1\n#endif\n\n#define TRUST_MAX 2\n\nstatic int io[TRUST_MAX] = { [0] = CONFIG_RADIO_TRUST_PORT,\n\t\t\t      [1 ... (TRUST_MAX - 1)] = -1 };\nstatic int radio_nr[TRUST_MAX] = { [0 ... (TRUST_MAX - 1)] = -1 };\n\nmodule_param_array(io, int, NULL, 0444);\nMODULE_PARM_DESC(io, \"I/O addresses of the Trust FM Radio card (0x350 or 0x358)\");\nmodule_param_array(radio_nr, int, NULL, 0444);\nMODULE_PARM_DESC(radio_nr, \"Radio device numbers\");\n\nstruct trust {\n\tstruct radio_isa_card isa;\n\tint ioval;\n};\n\nstatic struct radio_isa_card *trust_alloc(void)\n{\n\tstruct trust *tr = kzalloc(sizeof(*tr), GFP_KERNEL);\n\n\treturn tr ? &tr->isa : NULL;\n}\n\n \n#define TDA7318_ADDR 0x88\n#define TSA6060T_ADDR 0xc4\n\n#define TR_DELAY do { inb(tr->isa.io); inb(tr->isa.io); inb(tr->isa.io); } while (0)\n#define TR_SET_SCL outb(tr->ioval |= 2, tr->isa.io)\n#define TR_CLR_SCL outb(tr->ioval &= 0xfd, tr->isa.io)\n#define TR_SET_SDA outb(tr->ioval |= 1, tr->isa.io)\n#define TR_CLR_SDA outb(tr->ioval &= 0xfe, tr->isa.io)\n\nstatic void write_i2c(struct trust *tr, int n, ...)\n{\n\tunsigned char val, mask;\n\tva_list args;\n\n\tva_start(args, n);\n\n\t \n\tTR_SET_SDA;\n\tTR_SET_SCL;\n\tTR_DELAY;\n\tTR_CLR_SDA;\n\tTR_CLR_SCL;\n\tTR_DELAY;\n\n\tfor (; n; n--) {\n\t\tval = va_arg(args, unsigned);\n\t\tfor (mask = 0x80; mask; mask >>= 1) {\n\t\t\tif (val & mask)\n\t\t\t\tTR_SET_SDA;\n\t\t\telse\n\t\t\t\tTR_CLR_SDA;\n\t\t\tTR_SET_SCL;\n\t\t\tTR_DELAY;\n\t\t\tTR_CLR_SCL;\n\t\t\tTR_DELAY;\n\t\t}\n\t\t \n\t\tTR_SET_SDA;\n\t\tTR_SET_SCL;\n\t\tTR_DELAY;\n\t\tTR_CLR_SCL;\n\t\tTR_DELAY;\n\t}\n\n\t \n\tTR_CLR_SDA;\n\tTR_DELAY;\n\tTR_SET_SCL;\n\tTR_DELAY;\n\tTR_SET_SDA;\n\tTR_DELAY;\n\n\tva_end(args);\n}\n\nstatic int trust_s_mute_volume(struct radio_isa_card *isa, bool mute, int vol)\n{\n\tstruct trust *tr = container_of(isa, struct trust, isa);\n\n\ttr->ioval = (tr->ioval & 0xf7) | (mute << 3);\n\toutb(tr->ioval, isa->io);\n\twrite_i2c(tr, 2, TDA7318_ADDR, vol ^ 0x1f);\n\treturn 0;\n}\n\nstatic int trust_s_stereo(struct radio_isa_card *isa, bool stereo)\n{\n\tstruct trust *tr = container_of(isa, struct trust, isa);\n\n\ttr->ioval = (tr->ioval & 0xfb) | (!stereo << 2);\n\toutb(tr->ioval, isa->io);\n\treturn 0;\n}\n\nstatic u32 trust_g_signal(struct radio_isa_card *isa)\n{\n\tint i, v;\n\n\tfor (i = 0, v = 0; i < 100; i++)\n\t\tv |= inb(isa->io);\n\treturn (v & 1) ? 0 : 0xffff;\n}\n\nstatic int trust_s_frequency(struct radio_isa_card *isa, u32 freq)\n{\n\tstruct trust *tr = container_of(isa, struct trust, isa);\n\n\tfreq /= 160;\t \n\tfreq += 1070;\t \n\twrite_i2c(tr, 5, TSA6060T_ADDR, (freq << 1) | 1,\n\t\t\tfreq >> 7, 0x60 | ((freq >> 15) & 1), 0);\n\treturn 0;\n}\n\nstatic int basstreble2chip[15] = {\n\t0, 1, 2, 3, 4, 5, 6, 7, 14, 13, 12, 11, 10, 9, 8\n};\n\nstatic int trust_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct radio_isa_card *isa =\n\t\tcontainer_of(ctrl->handler, struct radio_isa_card, hdl);\n\tstruct trust *tr = container_of(isa, struct trust, isa);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_BASS:\n\t\twrite_i2c(tr, 2, TDA7318_ADDR, 0x60 | basstreble2chip[ctrl->val]);\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_TREBLE:\n\t\twrite_i2c(tr, 2, TDA7318_ADDR, 0x70 | basstreble2chip[ctrl->val]);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct v4l2_ctrl_ops trust_ctrl_ops = {\n\t.s_ctrl = trust_s_ctrl,\n};\n\nstatic int trust_initialize(struct radio_isa_card *isa)\n{\n\tstruct trust *tr = container_of(isa, struct trust, isa);\n\n\ttr->ioval = 0xf;\n\twrite_i2c(tr, 2, TDA7318_ADDR, 0x80);\t \n\twrite_i2c(tr, 2, TDA7318_ADDR, 0xa0);\t \n\twrite_i2c(tr, 2, TDA7318_ADDR, 0xc0);\t \n\twrite_i2c(tr, 2, TDA7318_ADDR, 0xe0);\t \n\twrite_i2c(tr, 2, TDA7318_ADDR, 0x40);\t \n\n\tv4l2_ctrl_new_std(&isa->hdl, &trust_ctrl_ops,\n\t\t\t\tV4L2_CID_AUDIO_BASS, 0, 15, 1, 8);\n\tv4l2_ctrl_new_std(&isa->hdl, &trust_ctrl_ops,\n\t\t\t\tV4L2_CID_AUDIO_TREBLE, 0, 15, 1, 8);\n\treturn isa->hdl.error;\n}\n\nstatic const struct radio_isa_ops trust_ops = {\n\t.init = trust_initialize,\n\t.alloc = trust_alloc,\n\t.s_mute_volume = trust_s_mute_volume,\n\t.s_frequency = trust_s_frequency,\n\t.s_stereo = trust_s_stereo,\n\t.g_signal = trust_g_signal,\n};\n\nstatic const int trust_ioports[] = { 0x350, 0x358 };\n\nstatic struct radio_isa_driver trust_driver = {\n\t.driver = {\n\t\t.match\t\t= radio_isa_match,\n\t\t.probe\t\t= radio_isa_probe,\n\t\t.remove\t\t= radio_isa_remove,\n\t\t.driver\t\t= {\n\t\t\t.name\t= \"radio-trust\",\n\t\t},\n\t},\n\t.io_params = io,\n\t.radio_nr_params = radio_nr,\n\t.io_ports = trust_ioports,\n\t.num_of_io_ports = ARRAY_SIZE(trust_ioports),\n\t.region_size = 2,\n\t.card = \"Trust FM Radio\",\n\t.ops = &trust_ops,\n\t.has_stereo = true,\n\t.max_volume = 31,\n};\n\nstatic int __init trust_init(void)\n{\n\treturn isa_register_driver(&trust_driver.driver, TRUST_MAX);\n}\n\nstatic void __exit trust_exit(void)\n{\n\tisa_unregister_driver(&trust_driver.driver);\n}\n\nmodule_init(trust_init);\nmodule_exit(trust_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}