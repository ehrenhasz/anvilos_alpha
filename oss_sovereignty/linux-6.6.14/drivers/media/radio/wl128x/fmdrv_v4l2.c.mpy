{
  "module_name": "fmdrv_v4l2.c",
  "hash_id": "56d6d81fa8709705d0af80b37b929f212ce50f03a5f85319095ced9538c21dcc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/wl128x/fmdrv_v4l2.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n\n#include \"fmdrv.h\"\n#include \"fmdrv_v4l2.h\"\n#include \"fmdrv_common.h\"\n#include \"fmdrv_rx.h\"\n#include \"fmdrv_tx.h\"\n\nstatic struct video_device gradio_dev;\nstatic u8 radio_disconnected;\n\n \n\n \nstatic ssize_t fm_v4l2_fops_read(struct file *file, char __user * buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tu8 rds_mode;\n\tint ret;\n\tstruct fmdev *fmdev;\n\n\tfmdev = video_drvdata(file);\n\n\tif (!radio_disconnected) {\n\t\tfmerr(\"FM device is already disconnected\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (mutex_lock_interruptible(&fmdev->mutex))\n\t\treturn -ERESTARTSYS;\n\n\t \n\tret = fm_rx_get_rds_mode(fmdev, &rds_mode);\n\tif (ret < 0) {\n\t\tfmerr(\"Unable to read current rds mode\\n\");\n\t\tgoto read_unlock;\n\t}\n\n\tif (rds_mode == FM_RDS_DISABLE) {\n\t\tret = fmc_set_rds_mode(fmdev, FM_RDS_ENABLE);\n\t\tif (ret < 0) {\n\t\t\tfmerr(\"Failed to enable rds mode\\n\");\n\t\t\tgoto read_unlock;\n\t\t}\n\t}\n\n\t \n\tret = fmc_transfer_rds_from_internal_buff(fmdev, file, buf, count);\nread_unlock:\n\tmutex_unlock(&fmdev->mutex);\n\treturn ret;\n}\n\n \nstatic ssize_t fm_v4l2_fops_write(struct file *file, const char __user * buf,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct tx_rds rds;\n\tint ret;\n\tstruct fmdev *fmdev;\n\n\tret = copy_from_user(&rds, buf, sizeof(rds));\n\trds.text[sizeof(rds.text) - 1] = '\\0';\n\tfmdbg(\"(%d)type: %d, text %s, af %d\\n\",\n\t\t   ret, rds.text_type, rds.text, rds.af_freq);\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tfmdev = video_drvdata(file);\n\tif (mutex_lock_interruptible(&fmdev->mutex))\n\t\treturn -ERESTARTSYS;\n\tfm_tx_set_radio_text(fmdev, rds.text, rds.text_type);\n\tfm_tx_set_af(fmdev, rds.af_freq);\n\tmutex_unlock(&fmdev->mutex);\n\n\treturn sizeof(rds);\n}\n\nstatic __poll_t fm_v4l2_fops_poll(struct file *file, struct poll_table_struct *pts)\n{\n\tint ret;\n\tstruct fmdev *fmdev;\n\n\tfmdev = video_drvdata(file);\n\tmutex_lock(&fmdev->mutex);\n\tret = fmc_is_rds_data_available(fmdev, file, pts);\n\tmutex_unlock(&fmdev->mutex);\n\tif (ret < 0)\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\n\treturn 0;\n}\n\n \nstatic int fm_v4l2_fops_open(struct file *file)\n{\n\tint ret;\n\tstruct fmdev *fmdev = NULL;\n\n\t \n\tif (radio_disconnected) {\n\t\tfmerr(\"FM device is already opened\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tfmdev = video_drvdata(file);\n\n\tif (mutex_lock_interruptible(&fmdev->mutex))\n\t\treturn -ERESTARTSYS;\n\tret = fmc_prepare(fmdev);\n\tif (ret < 0) {\n\t\tfmerr(\"Unable to prepare FM CORE\\n\");\n\t\tgoto open_unlock;\n\t}\n\n\tfmdbg(\"Load FM RX firmware..\\n\");\n\n\tret = fmc_set_mode(fmdev, FM_MODE_RX);\n\tif (ret < 0) {\n\t\tfmerr(\"Unable to load FM RX firmware\\n\");\n\t\tgoto open_unlock;\n\t}\n\tradio_disconnected = 1;\n\nopen_unlock:\n\tmutex_unlock(&fmdev->mutex);\n\treturn ret;\n}\n\nstatic int fm_v4l2_fops_release(struct file *file)\n{\n\tint ret;\n\tstruct fmdev *fmdev;\n\n\tfmdev = video_drvdata(file);\n\tif (!radio_disconnected) {\n\t\tfmdbg(\"FM device is already closed\\n\");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&fmdev->mutex);\n\tret = fmc_set_mode(fmdev, FM_MODE_OFF);\n\tif (ret < 0) {\n\t\tfmerr(\"Unable to turn off the chip\\n\");\n\t\tgoto release_unlock;\n\t}\n\n\tret = fmc_release(fmdev);\n\tif (ret < 0) {\n\t\tfmerr(\"FM CORE release failed\\n\");\n\t\tgoto release_unlock;\n\t}\n\tradio_disconnected = 0;\n\nrelease_unlock:\n\tmutex_unlock(&fmdev->mutex);\n\treturn ret;\n}\n\n \nstatic int fm_v4l2_vidioc_querycap(struct file *file, void *priv,\n\t\tstruct v4l2_capability *capability)\n{\n\tstrscpy(capability->driver, FM_DRV_NAME, sizeof(capability->driver));\n\tstrscpy(capability->card, FM_DRV_CARD_SHORT_NAME,\n\t\tsizeof(capability->card));\n\tsprintf(capability->bus_info, \"UART\");\n\treturn 0;\n}\n\nstatic int fm_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct fmdev *fmdev = container_of(ctrl->handler,\n\t\t\tstruct fmdev, ctrl_handler);\n\n\tswitch (ctrl->id) {\n\tcase  V4L2_CID_TUNE_ANTENNA_CAPACITOR:\n\t\tctrl->val = fm_tx_get_tune_cap_val(fmdev);\n\t\tbreak;\n\tdefault:\n\t\tfmwarn(\"%s: Unknown IOCTL: %d\\n\", __func__, ctrl->id);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int fm_v4l2_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct fmdev *fmdev = container_of(ctrl->handler,\n\t\t\tstruct fmdev, ctrl_handler);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_VOLUME:\t \n\t\treturn fm_rx_set_volume(fmdev, (u16)ctrl->val);\n\n\tcase V4L2_CID_AUDIO_MUTE:\t \n\t\treturn fmc_set_mute_mode(fmdev, (u8)ctrl->val);\n\n\tcase V4L2_CID_TUNE_POWER_LEVEL:\n\t\t \n\t\treturn fm_tx_set_pwr_lvl(fmdev, (u8)ctrl->val);\n\n\tcase V4L2_CID_TUNE_PREEMPHASIS:\n\t\treturn fm_tx_set_preemph_filter(fmdev, (u8) ctrl->val);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int fm_v4l2_vidioc_g_audio(struct file *file, void *priv,\n\t\tstruct v4l2_audio *audio)\n{\n\tmemset(audio, 0, sizeof(*audio));\n\tstrscpy(audio->name, \"Radio\", sizeof(audio->name));\n\taudio->capability = V4L2_AUDCAP_STEREO;\n\n\treturn 0;\n}\n\nstatic int fm_v4l2_vidioc_s_audio(struct file *file, void *priv,\n\t\tconst struct v4l2_audio *audio)\n{\n\tif (audio->index != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int fm_v4l2_vidioc_g_tuner(struct file *file, void *priv,\n\t\tstruct v4l2_tuner *tuner)\n{\n\tstruct fmdev *fmdev = video_drvdata(file);\n\tu32 bottom_freq;\n\tu32 top_freq;\n\tu16 stereo_mono_mode;\n\tu16 rssilvl;\n\tint ret;\n\n\tif (tuner->index != 0)\n\t\treturn -EINVAL;\n\n\tif (fmdev->curr_fmmode != FM_MODE_RX)\n\t\treturn -EPERM;\n\n\tret = fm_rx_get_band_freq_range(fmdev, &bottom_freq, &top_freq);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = fm_rx_get_stereo_mono(fmdev, &stereo_mono_mode);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = fm_rx_get_rssi_level(fmdev, &rssilvl);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tstrscpy(tuner->name, \"FM\", sizeof(tuner->name));\n\ttuner->type = V4L2_TUNER_RADIO;\n\t \n\ttuner->rangelow = bottom_freq * 16;\n\ttuner->rangehigh = top_freq * 16;\n\ttuner->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO |\n\t((fmdev->rx.rds.flag == FM_RDS_ENABLE) ? V4L2_TUNER_SUB_RDS : 0);\n\ttuner->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_RDS |\n\t\t\t    V4L2_TUNER_CAP_LOW |\n\t\t\t    V4L2_TUNER_CAP_HWSEEK_BOUNDED |\n\t\t\t    V4L2_TUNER_CAP_HWSEEK_WRAP;\n\ttuner->audmode = (stereo_mono_mode ?\n\t\t\t  V4L2_TUNER_MODE_MONO : V4L2_TUNER_MODE_STEREO);\n\n\t \n\trssilvl += 128;\n\n\t \n\ttuner->signal = rssilvl * 257;\n\ttuner->afc = 0;\n\n\treturn ret;\n}\n\n \nstatic int fm_v4l2_vidioc_s_tuner(struct file *file, void *priv,\n\t\tconst struct v4l2_tuner *tuner)\n{\n\tstruct fmdev *fmdev = video_drvdata(file);\n\tu16 aud_mode;\n\tu8 rds_mode;\n\tint ret;\n\n\tif (tuner->index != 0)\n\t\treturn -EINVAL;\n\n\taud_mode = (tuner->audmode == V4L2_TUNER_MODE_STEREO) ?\n\t\t\tFM_STEREO_MODE : FM_MONO_MODE;\n\trds_mode = (tuner->rxsubchans & V4L2_TUNER_SUB_RDS) ?\n\t\t\tFM_RDS_ENABLE : FM_RDS_DISABLE;\n\n\tif (fmdev->curr_fmmode != FM_MODE_RX) {\n\t\tret = fmc_set_mode(fmdev, FM_MODE_RX);\n\t\tif (ret < 0) {\n\t\t\tfmerr(\"Failed to set RX mode\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = fmc_set_stereo_mono(fmdev, aud_mode);\n\tif (ret < 0) {\n\t\tfmerr(\"Failed to set RX stereo/mono mode\\n\");\n\t\treturn ret;\n\t}\n\n\tret = fmc_set_rds_mode(fmdev, rds_mode);\n\tif (ret < 0)\n\t\tfmerr(\"Failed to set RX RDS mode\\n\");\n\n\treturn ret;\n}\n\n \nstatic int fm_v4l2_vidioc_g_freq(struct file *file, void *priv,\n\t\tstruct v4l2_frequency *freq)\n{\n\tstruct fmdev *fmdev = video_drvdata(file);\n\tint ret;\n\n\tret = fmc_get_freq(fmdev, &freq->frequency);\n\tif (ret < 0) {\n\t\tfmerr(\"Failed to get frequency\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tfreq->frequency = (u32) freq->frequency * 16;\n\n\treturn 0;\n}\n\n \nstatic int fm_v4l2_vidioc_s_freq(struct file *file, void *priv,\n\t\tconst struct v4l2_frequency *freq)\n{\n\tstruct fmdev *fmdev = video_drvdata(file);\n\n\t \n\treturn fmc_set_freq(fmdev, freq->frequency / 16);\n}\n\n \nstatic int fm_v4l2_vidioc_s_hw_freq_seek(struct file *file, void *priv,\n\t\tconst struct v4l2_hw_freq_seek *seek)\n{\n\tstruct fmdev *fmdev = video_drvdata(file);\n\tint ret;\n\n\tif (file->f_flags & O_NONBLOCK)\n\t\treturn -EWOULDBLOCK;\n\n\tif (fmdev->curr_fmmode != FM_MODE_RX) {\n\t\tret = fmc_set_mode(fmdev, FM_MODE_RX);\n\t\tif (ret != 0) {\n\t\t\tfmerr(\"Failed to set RX mode\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = fm_rx_seek(fmdev, seek->seek_upward, seek->wrap_around,\n\t\t\tseek->spacing);\n\tif (ret < 0)\n\t\tfmerr(\"RX seek failed - %d\\n\", ret);\n\n\treturn ret;\n}\n \nstatic int fm_v4l2_vidioc_g_modulator(struct file *file, void *priv,\n\t\tstruct v4l2_modulator *mod)\n{\n\tstruct fmdev *fmdev = video_drvdata(file);\n\n\tif (mod->index != 0)\n\t\treturn -EINVAL;\n\n\tif (fmdev->curr_fmmode != FM_MODE_TX)\n\t\treturn -EPERM;\n\n\tmod->txsubchans = ((fmdev->tx_data.aud_mode == FM_STEREO_MODE) ?\n\t\t\t\tV4L2_TUNER_SUB_STEREO : V4L2_TUNER_SUB_MONO) |\n\t\t\t\t((fmdev->tx_data.rds.flag == FM_RDS_ENABLE) ?\n\t\t\t\tV4L2_TUNER_SUB_RDS : 0);\n\n\tmod->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_RDS |\n\t\t\t\tV4L2_TUNER_CAP_LOW;\n\n\treturn 0;\n}\n\n \nstatic int fm_v4l2_vidioc_s_modulator(struct file *file, void *priv,\n\t\tconst struct v4l2_modulator *mod)\n{\n\tstruct fmdev *fmdev = video_drvdata(file);\n\tu8 rds_mode;\n\tu16 aud_mode;\n\tint ret;\n\n\tif (mod->index != 0)\n\t\treturn -EINVAL;\n\n\tif (fmdev->curr_fmmode != FM_MODE_TX) {\n\t\tret = fmc_set_mode(fmdev, FM_MODE_TX);\n\t\tif (ret != 0) {\n\t\t\tfmerr(\"Failed to set TX mode\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\taud_mode = (mod->txsubchans & V4L2_TUNER_SUB_STEREO) ?\n\t\t\tFM_STEREO_MODE : FM_MONO_MODE;\n\trds_mode = (mod->txsubchans & V4L2_TUNER_SUB_RDS) ?\n\t\t\tFM_RDS_ENABLE : FM_RDS_DISABLE;\n\tret = fm_tx_set_stereo_mono(fmdev, aud_mode);\n\tif (ret < 0) {\n\t\tfmerr(\"Failed to set mono/stereo mode for TX\\n\");\n\t\treturn ret;\n\t}\n\tret = fm_tx_set_rds_mode(fmdev, rds_mode);\n\tif (ret < 0)\n\t\tfmerr(\"Failed to set rds mode for TX\\n\");\n\n\treturn ret;\n}\n\nstatic const struct v4l2_file_operations fm_drv_fops = {\n\t.owner = THIS_MODULE,\n\t.read = fm_v4l2_fops_read,\n\t.write = fm_v4l2_fops_write,\n\t.poll = fm_v4l2_fops_poll,\n\t.unlocked_ioctl = video_ioctl2,\n\t.open = fm_v4l2_fops_open,\n\t.release = fm_v4l2_fops_release,\n};\n\nstatic const struct v4l2_ctrl_ops fm_ctrl_ops = {\n\t.s_ctrl = fm_v4l2_s_ctrl,\n\t.g_volatile_ctrl = fm_g_volatile_ctrl,\n};\nstatic const struct v4l2_ioctl_ops fm_drv_ioctl_ops = {\n\t.vidioc_querycap = fm_v4l2_vidioc_querycap,\n\t.vidioc_g_audio = fm_v4l2_vidioc_g_audio,\n\t.vidioc_s_audio = fm_v4l2_vidioc_s_audio,\n\t.vidioc_g_tuner = fm_v4l2_vidioc_g_tuner,\n\t.vidioc_s_tuner = fm_v4l2_vidioc_s_tuner,\n\t.vidioc_g_frequency = fm_v4l2_vidioc_g_freq,\n\t.vidioc_s_frequency = fm_v4l2_vidioc_s_freq,\n\t.vidioc_s_hw_freq_seek = fm_v4l2_vidioc_s_hw_freq_seek,\n\t.vidioc_g_modulator = fm_v4l2_vidioc_g_modulator,\n\t.vidioc_s_modulator = fm_v4l2_vidioc_s_modulator\n};\n\n \nstatic const struct video_device fm_viddev_template = {\n\t.fops = &fm_drv_fops,\n\t.ioctl_ops = &fm_drv_ioctl_ops,\n\t.name = FM_DRV_NAME,\n\t.release = video_device_release_empty,\n\t \n\t.vfl_dir = VFL_DIR_M2M,\n\t.device_caps = V4L2_CAP_HW_FREQ_SEEK | V4L2_CAP_TUNER | V4L2_CAP_RADIO |\n\t\t       V4L2_CAP_MODULATOR | V4L2_CAP_AUDIO |\n\t\t       V4L2_CAP_READWRITE | V4L2_CAP_RDS_CAPTURE,\n};\n\nint fm_v4l2_init_video_device(struct fmdev *fmdev, int radio_nr)\n{\n\tstruct v4l2_ctrl *ctrl;\n\tint ret;\n\n\tstrscpy(fmdev->v4l2_dev.name, FM_DRV_NAME,\n\t\tsizeof(fmdev->v4l2_dev.name));\n\tret = v4l2_device_register(NULL, &fmdev->v4l2_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmutex_init(&fmdev->mutex);\n\n\t \n\tgradio_dev = fm_viddev_template;\n\n\tvideo_set_drvdata(&gradio_dev, fmdev);\n\n\tgradio_dev.lock = &fmdev->mutex;\n\tgradio_dev.v4l2_dev = &fmdev->v4l2_dev;\n\n\t \n\tif (video_register_device(&gradio_dev, VFL_TYPE_RADIO, radio_nr)) {\n\t\tv4l2_device_unregister(&fmdev->v4l2_dev);\n\t\tfmerr(\"Could not register video device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfmdev->radio_dev = &gradio_dev;\n\n\t \n\tfmdev->radio_dev->ctrl_handler = &fmdev->ctrl_handler;\n\n\tret = v4l2_ctrl_handler_init(&fmdev->ctrl_handler, 5);\n\tif (ret < 0) {\n\t\tfmerr(\"(fmdev): Can't init ctrl handler\\n\");\n\t\tv4l2_ctrl_handler_free(&fmdev->ctrl_handler);\n\t\tvideo_unregister_device(fmdev->radio_dev);\n\t\tv4l2_device_unregister(&fmdev->v4l2_dev);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tv4l2_ctrl_new_std(&fmdev->ctrl_handler, &fm_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_VOLUME, FM_RX_VOLUME_MIN,\n\t\t\tFM_RX_VOLUME_MAX, 1, FM_RX_VOLUME_MAX);\n\n\tv4l2_ctrl_new_std(&fmdev->ctrl_handler, &fm_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\n\n\tv4l2_ctrl_new_std_menu(&fmdev->ctrl_handler, &fm_ctrl_ops,\n\t\t\tV4L2_CID_TUNE_PREEMPHASIS, V4L2_PREEMPHASIS_75_uS,\n\t\t\t0, V4L2_PREEMPHASIS_75_uS);\n\n\tv4l2_ctrl_new_std(&fmdev->ctrl_handler, &fm_ctrl_ops,\n\t\t\tV4L2_CID_TUNE_POWER_LEVEL, FM_PWR_LVL_LOW,\n\t\t\tFM_PWR_LVL_HIGH, 1, FM_PWR_LVL_HIGH);\n\n\tctrl = v4l2_ctrl_new_std(&fmdev->ctrl_handler, &fm_ctrl_ops,\n\t\t\tV4L2_CID_TUNE_ANTENNA_CAPACITOR, 0,\n\t\t\t255, 1, 255);\n\n\tif (ctrl)\n\t\tctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\n\treturn 0;\n}\n\nvoid *fm_v4l2_deinit_video_device(void)\n{\n\tstruct fmdev *fmdev;\n\n\n\tfmdev = video_get_drvdata(&gradio_dev);\n\n\t \n\tv4l2_ctrl_handler_free(&fmdev->ctrl_handler);\n\n\t \n\tvideo_unregister_device(&gradio_dev);\n\n\tv4l2_device_unregister(&fmdev->v4l2_dev);\n\n\treturn fmdev;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}