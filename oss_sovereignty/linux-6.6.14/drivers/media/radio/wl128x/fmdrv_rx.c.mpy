{
  "module_name": "fmdrv_rx.c",
  "hash_id": "b1b7c7d13c174ce9dc1eefa44df204ee7c14de5837c3afd6540d0e4ebac33916",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/wl128x/fmdrv_rx.c",
  "human_readable_source": "\n \n\n#include \"fmdrv.h\"\n#include \"fmdrv_common.h\"\n#include \"fmdrv_rx.h\"\n\nvoid fm_rx_reset_rds_cache(struct fmdev *fmdev)\n{\n\tfmdev->rx.rds.flag = FM_RDS_DISABLE;\n\tfmdev->rx.rds.last_blk_idx = 0;\n\tfmdev->rx.rds.wr_idx = 0;\n\tfmdev->rx.rds.rd_idx = 0;\n\n\tif (fmdev->rx.af_mode == FM_RX_RDS_AF_SWITCH_MODE_ON)\n\t\tfmdev->irq_info.mask |= FM_LEV_EVENT;\n}\n\nvoid fm_rx_reset_station_info(struct fmdev *fmdev)\n{\n\tfmdev->rx.stat_info.picode = FM_NO_PI_CODE;\n\tfmdev->rx.stat_info.afcache_size = 0;\n\tfmdev->rx.stat_info.af_list_max = 0;\n}\n\nint fm_rx_set_freq(struct fmdev *fmdev, u32 freq)\n{\n\tunsigned long timeleft;\n\tu16 payload, curr_frq, intr_flag;\n\tu32 curr_frq_in_khz;\n\tu32 resp_len;\n\tint ret;\n\n\tif (freq < fmdev->rx.region.bot_freq || freq > fmdev->rx.region.top_freq) {\n\t\tfmerr(\"Invalid frequency %d\\n\", freq);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpayload = FM_RX_AUDIO_ENABLE_I2S_AND_ANALOG;\n\n\tret = fmc_send_cmd(fmdev, AUDIO_ENABLE_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpayload = FM_RX_IFFREQ_HILO_AUTOMATIC;\n\tret = fmc_send_cmd(fmdev, HILO_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpayload = (freq - fmdev->rx.region.bot_freq) / FM_FREQ_MUL;\n\n\tret = fmc_send_cmd(fmdev, FREQ_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = fmc_send_cmd(fmdev, FLAG_GET, REG_RD, NULL, 2, NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tintr_flag = fmdev->irq_info.mask;\n\tfmdev->irq_info.mask = (FM_FR_EVENT | FM_BL_EVENT);\n\tpayload = fmdev->irq_info.mask;\n\tret = fmc_send_cmd(fmdev, INT_MASK_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpayload = FM_TUNER_PRESET_MODE;\n\tret = fmc_send_cmd(fmdev, TUNER_MODE_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\t \n\tinit_completion(&fmdev->maintask_comp);\n\ttimeleft = wait_for_completion_timeout(&fmdev->maintask_comp,\n\t\t\tFM_DRV_TX_TIMEOUT);\n\tif (!timeleft) {\n\t\tfmerr(\"Timeout(%d sec),didn't get tune ended int\\n\",\n\t\t\t   jiffies_to_msecs(FM_DRV_TX_TIMEOUT) / 1000);\n\t\tret = -ETIMEDOUT;\n\t\tgoto exit;\n\t}\n\n\t \n\tret = fmc_send_cmd(fmdev, FREQ_SET, REG_RD, NULL, 2, &curr_frq, &resp_len);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tcurr_frq = be16_to_cpu((__force __be16)curr_frq);\n\tcurr_frq_in_khz = (fmdev->rx.region.bot_freq + ((u32)curr_frq * FM_FREQ_MUL));\n\n\tif (curr_frq_in_khz != freq) {\n\t\tpr_info(\"Frequency is set to (%d) but requested freq is (%d)\\n\",\n\t\t\tcurr_frq_in_khz, freq);\n\t}\n\n\t \n\tfmdev->rx.freq = curr_frq_in_khz;\nexit:\n\t \n\tfmdev->irq_info.mask = intr_flag;\n\tpayload = fmdev->irq_info.mask;\n\tret = fmc_send_cmd(fmdev, INT_MASK_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfm_rx_reset_rds_cache(fmdev);\n\tfm_rx_reset_station_info(fmdev);\n\n\treturn ret;\n}\n\nstatic int fm_rx_set_channel_spacing(struct fmdev *fmdev, u32 spacing)\n{\n\tu16 payload;\n\tint ret;\n\n\tif (spacing > 0 && spacing <= 50000)\n\t\tspacing = FM_CHANNEL_SPACING_50KHZ;\n\telse if (spacing > 50000 && spacing <= 100000)\n\t\tspacing = FM_CHANNEL_SPACING_100KHZ;\n\telse\n\t\tspacing = FM_CHANNEL_SPACING_200KHZ;\n\n\t \n\tpayload = spacing;\n\tret = fmc_send_cmd(fmdev, CHANL_BW_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfmdev->rx.region.chanl_space = spacing * FM_FREQ_MUL;\n\n\treturn ret;\n}\n\nint fm_rx_seek(struct fmdev *fmdev, u32 seek_upward,\n\t\tu32 wrap_around, u32 spacing)\n{\n\tu32 resp_len;\n\tu16 curr_frq, next_frq, last_frq;\n\tu16 payload, int_reason, intr_flag;\n\tu16 offset, space_idx;\n\tunsigned long timeleft;\n\tint ret;\n\n\t \n\tret = fm_rx_set_channel_spacing(fmdev, spacing);\n\tif (ret < 0) {\n\t\tfmerr(\"Failed to set channel spacing\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = fmc_send_cmd(fmdev, FREQ_SET, REG_RD, NULL,\n\t\t\tsizeof(curr_frq), &curr_frq, &resp_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcurr_frq = be16_to_cpu((__force __be16)curr_frq);\n\tlast_frq = (fmdev->rx.region.top_freq - fmdev->rx.region.bot_freq) / FM_FREQ_MUL;\n\n\t \n\tspace_idx = fmdev->rx.region.chanl_space / FM_FREQ_MUL;\n\toffset = curr_frq % space_idx;\n\n\tnext_frq = seek_upward ? curr_frq + space_idx   :\n\t\t\t\tcurr_frq - space_idx   ;\n\n\t \n\tif ((short)next_frq < 0)\n\t\tnext_frq = last_frq - offset;\n\telse if (next_frq > last_frq)\n\t\tnext_frq = 0 + offset;\n\nagain:\n\t \n\tpayload = next_frq;\n\tret = fmc_send_cmd(fmdev, FREQ_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpayload = (seek_upward ? FM_SEARCH_DIRECTION_UP : FM_SEARCH_DIRECTION_DOWN);\n\tret = fmc_send_cmd(fmdev, SEARCH_DIR_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = fmc_send_cmd(fmdev, FLAG_GET, REG_RD, NULL, 2, NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tintr_flag = fmdev->irq_info.mask;\n\tfmdev->irq_info.mask = (FM_FR_EVENT | FM_BL_EVENT);\n\tpayload = fmdev->irq_info.mask;\n\tret = fmc_send_cmd(fmdev, INT_MASK_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpayload = FM_TUNER_AUTONOMOUS_SEARCH_MODE;\n\tret = fmc_send_cmd(fmdev, TUNER_MODE_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tinit_completion(&fmdev->maintask_comp);\n\ttimeleft = wait_for_completion_timeout(&fmdev->maintask_comp,\n\t\t\tFM_DRV_RX_SEEK_TIMEOUT);\n\tif (!timeleft) {\n\t\tfmerr(\"Timeout(%d sec),didn't get tune ended int\\n\",\n\t\t\t   jiffies_to_msecs(FM_DRV_RX_SEEK_TIMEOUT) / 1000);\n\t\treturn -ENODATA;\n\t}\n\n\tint_reason = fmdev->irq_info.flag & (FM_TUNE_COMPLETE | FM_BAND_LIMIT);\n\n\t \n\tfmdev->irq_info.mask = intr_flag;\n\tpayload = fmdev->irq_info.mask;\n\tret = fmc_send_cmd(fmdev, INT_MASK_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (int_reason & FM_BL_EVENT) {\n\t\tif (wrap_around == 0) {\n\t\t\tfmdev->rx.freq = seek_upward ?\n\t\t\t\tfmdev->rx.region.top_freq :\n\t\t\t\tfmdev->rx.region.bot_freq;\n\t\t} else {\n\t\t\tfmdev->rx.freq = seek_upward ?\n\t\t\t\tfmdev->rx.region.bot_freq :\n\t\t\t\tfmdev->rx.region.top_freq;\n\t\t\t \n\t\t\tnext_frq = (fmdev->rx.freq -\n\t\t\t\t\tfmdev->rx.region.bot_freq) / FM_FREQ_MUL;\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\t \n\t\tret = fmc_send_cmd(fmdev, FREQ_SET, REG_RD, NULL, 2,\n\t\t\t\t&curr_frq, &resp_len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcurr_frq = be16_to_cpu((__force __be16)curr_frq);\n\t\tfmdev->rx.freq = (fmdev->rx.region.bot_freq +\n\t\t\t\t((u32)curr_frq * FM_FREQ_MUL));\n\n\t}\n\t \n\tfm_rx_reset_rds_cache(fmdev);\n\tfm_rx_reset_station_info(fmdev);\n\n\treturn ret;\n}\n\nint fm_rx_set_volume(struct fmdev *fmdev, u16 vol_to_set)\n{\n\tu16 payload;\n\tint ret;\n\n\tif (fmdev->curr_fmmode != FM_MODE_RX)\n\t\treturn -EPERM;\n\n\tif (vol_to_set > FM_RX_VOLUME_MAX) {\n\t\tfmerr(\"Volume is not within(%d-%d) range\\n\",\n\t\t\t   FM_RX_VOLUME_MIN, FM_RX_VOLUME_MAX);\n\t\treturn -EINVAL;\n\t}\n\tvol_to_set *= FM_RX_VOLUME_GAIN_STEP;\n\n\tpayload = vol_to_set;\n\tret = fmc_send_cmd(fmdev, VOLUME_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfmdev->rx.volume = vol_to_set;\n\treturn ret;\n}\n\n \nint fm_rx_get_volume(struct fmdev *fmdev, u16 *curr_vol)\n{\n\tif (fmdev->curr_fmmode != FM_MODE_RX)\n\t\treturn -EPERM;\n\n\tif (curr_vol == NULL) {\n\t\tfmerr(\"Invalid memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t*curr_vol = fmdev->rx.volume / FM_RX_VOLUME_GAIN_STEP;\n\n\treturn 0;\n}\n\n \nint fm_rx_get_band_freq_range(struct fmdev *fmdev, u32 *bot_freq, u32 *top_freq)\n{\n\tif (bot_freq != NULL)\n\t\t*bot_freq = fmdev->rx.region.bot_freq;\n\n\tif (top_freq != NULL)\n\t\t*top_freq = fmdev->rx.region.top_freq;\n\n\treturn 0;\n}\n\n \nvoid fm_rx_get_region(struct fmdev *fmdev, u8 *region)\n{\n\t*region = fmdev->rx.region.fm_band;\n}\n\n \nint fm_rx_set_region(struct fmdev *fmdev, u8 region_to_set)\n{\n\tu16 payload;\n\tu32 new_frq = 0;\n\tint ret;\n\n\tif (region_to_set != FM_BAND_EUROPE_US &&\n\t    region_to_set != FM_BAND_JAPAN) {\n\t\tfmerr(\"Invalid band\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (fmdev->rx.region.fm_band == region_to_set) {\n\t\tfmerr(\"Requested band is already configured\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tpayload = (u16)region_to_set;\n\tret = fmc_send_cmd(fmdev, BAND_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfmc_update_region_info(fmdev, region_to_set);\n\n\t \n\tif (fmdev->rx.freq < fmdev->rx.region.bot_freq)\n\t\tnew_frq = fmdev->rx.region.bot_freq;\n\telse if (fmdev->rx.freq > fmdev->rx.region.top_freq)\n\t\tnew_frq = fmdev->rx.region.top_freq;\n\n\tif (new_frq) {\n\t\tfmdbg(\"Current freq is not within band limit boundary,switching to %d KHz\\n\",\n\t\t      new_frq);\n\t\t  \n\t\tret = fm_rx_set_freq(fmdev, new_frq);\n\t}\n\n\treturn ret;\n}\n\n \nint fm_rx_get_mute_mode(struct fmdev *fmdev, u8 *curr_mute_mode)\n{\n\tif (fmdev->curr_fmmode != FM_MODE_RX)\n\t\treturn -EPERM;\n\n\tif (curr_mute_mode == NULL) {\n\t\tfmerr(\"Invalid memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t*curr_mute_mode = fmdev->rx.mute_mode;\n\n\treturn 0;\n}\n\nstatic int fm_config_rx_mute_reg(struct fmdev *fmdev)\n{\n\tu16 payload, muteval;\n\tint ret;\n\n\tmuteval = 0;\n\tswitch (fmdev->rx.mute_mode) {\n\tcase FM_MUTE_ON:\n\t\tmuteval = FM_RX_AC_MUTE_MODE;\n\t\tbreak;\n\n\tcase FM_MUTE_OFF:\n\t\tmuteval = FM_RX_UNMUTE_MODE;\n\t\tbreak;\n\n\tcase FM_MUTE_ATTENUATE:\n\t\tmuteval = FM_RX_SOFT_MUTE_FORCE_MODE;\n\t\tbreak;\n\t}\n\tif (fmdev->rx.rf_depend_mute == FM_RX_RF_DEPENDENT_MUTE_ON)\n\t\tmuteval |= FM_RX_RF_DEP_MODE;\n\telse\n\t\tmuteval &= ~FM_RX_RF_DEP_MODE;\n\n\tpayload = muteval;\n\tret = fmc_send_cmd(fmdev, MUTE_STATUS_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nint fm_rx_set_mute_mode(struct fmdev *fmdev, u8 mute_mode_toset)\n{\n\tu8 org_state;\n\tint ret;\n\n\tif (fmdev->rx.mute_mode == mute_mode_toset)\n\t\treturn 0;\n\n\torg_state = fmdev->rx.mute_mode;\n\tfmdev->rx.mute_mode = mute_mode_toset;\n\n\tret = fm_config_rx_mute_reg(fmdev);\n\tif (ret < 0) {\n\t\tfmdev->rx.mute_mode = org_state;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nint fm_rx_get_rfdepend_softmute(struct fmdev *fmdev, u8 *curr_mute_mode)\n{\n\tif (fmdev->curr_fmmode != FM_MODE_RX)\n\t\treturn -EPERM;\n\n\tif (curr_mute_mode == NULL) {\n\t\tfmerr(\"Invalid memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t*curr_mute_mode = fmdev->rx.rf_depend_mute;\n\n\treturn 0;\n}\n\n \nint fm_rx_set_rfdepend_softmute(struct fmdev *fmdev, u8 rfdepend_mute)\n{\n\tu8 org_state;\n\tint ret;\n\n\tif (fmdev->curr_fmmode != FM_MODE_RX)\n\t\treturn -EPERM;\n\n\tif (rfdepend_mute != FM_RX_RF_DEPENDENT_MUTE_ON &&\n\t    rfdepend_mute != FM_RX_RF_DEPENDENT_MUTE_OFF) {\n\t\tfmerr(\"Invalid RF dependent soft mute\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (fmdev->rx.rf_depend_mute == rfdepend_mute)\n\t\treturn 0;\n\n\torg_state = fmdev->rx.rf_depend_mute;\n\tfmdev->rx.rf_depend_mute = rfdepend_mute;\n\n\tret = fm_config_rx_mute_reg(fmdev);\n\tif (ret < 0) {\n\t\tfmdev->rx.rf_depend_mute = org_state;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nint fm_rx_get_rssi_level(struct fmdev *fmdev, u16 *rssilvl)\n{\n\t__be16 curr_rssi_lel;\n\tu32 resp_len;\n\tint ret;\n\n\tif (rssilvl == NULL) {\n\t\tfmerr(\"Invalid memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\t \n\tret = fmc_send_cmd(fmdev, RSSI_LVL_GET, REG_RD, NULL, 2,\n\t\t\t&curr_rssi_lel, &resp_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*rssilvl = be16_to_cpu(curr_rssi_lel);\n\n\treturn 0;\n}\n\n \nint fm_rx_set_rssi_threshold(struct fmdev *fmdev, short rssi_lvl_toset)\n{\n\tu16 payload;\n\tint ret;\n\n\tif (rssi_lvl_toset < FM_RX_RSSI_THRESHOLD_MIN ||\n\t\t\trssi_lvl_toset > FM_RX_RSSI_THRESHOLD_MAX) {\n\t\tfmerr(\"Invalid RSSI threshold level\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpayload = (u16)rssi_lvl_toset;\n\tret = fmc_send_cmd(fmdev, SEARCH_LVL_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfmdev->rx.rssi_threshold = rssi_lvl_toset;\n\n\treturn 0;\n}\n\n \nint fm_rx_get_rssi_threshold(struct fmdev *fmdev, short *curr_rssi_lvl)\n{\n\tif (fmdev->curr_fmmode != FM_MODE_RX)\n\t\treturn -EPERM;\n\n\tif (curr_rssi_lvl == NULL) {\n\t\tfmerr(\"Invalid memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t*curr_rssi_lvl = fmdev->rx.rssi_threshold;\n\n\treturn 0;\n}\n\n \nint fm_rx_set_stereo_mono(struct fmdev *fmdev, u16 mode)\n{\n\tu16 payload;\n\tint ret;\n\n\tif (mode != FM_STEREO_MODE && mode != FM_MONO_MODE) {\n\t\tfmerr(\"Invalid mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpayload = (u16)mode;\n\tret = fmc_send_cmd(fmdev, MOST_MODE_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpayload = FM_STEREO_SOFT_BLEND;\n\tret = fmc_send_cmd(fmdev, MOST_BLEND_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nint fm_rx_get_stereo_mono(struct fmdev *fmdev, u16 *mode)\n{\n\t__be16 curr_mode;\n\tu32 resp_len;\n\tint ret;\n\n\tif (mode == NULL) {\n\t\tfmerr(\"Invalid memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = fmc_send_cmd(fmdev, MOST_MODE_SET, REG_RD, NULL, 2,\n\t\t\t&curr_mode, &resp_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*mode = be16_to_cpu(curr_mode);\n\n\treturn 0;\n}\n\n \nint fm_rx_set_deemphasis_mode(struct fmdev *fmdev, u16 mode)\n{\n\tu16 payload;\n\tint ret;\n\n\tif (fmdev->curr_fmmode != FM_MODE_RX)\n\t\treturn -EPERM;\n\n\tif (mode != FM_RX_EMPHASIS_FILTER_50_USEC &&\n\t\t\tmode != FM_RX_EMPHASIS_FILTER_75_USEC) {\n\t\tfmerr(\"Invalid rx de-emphasis mode (%d)\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\tpayload = mode;\n\tret = fmc_send_cmd(fmdev, DEMPH_MODE_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfmdev->rx.deemphasis_mode = mode;\n\n\treturn 0;\n}\n\n \nint fm_rx_get_deemph_mode(struct fmdev *fmdev, u16 *curr_deemphasis_mode)\n{\n\tif (fmdev->curr_fmmode != FM_MODE_RX)\n\t\treturn -EPERM;\n\n\tif (curr_deemphasis_mode == NULL) {\n\t\tfmerr(\"Invalid memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t*curr_deemphasis_mode = fmdev->rx.deemphasis_mode;\n\n\treturn 0;\n}\n\n \nint fm_rx_set_rds_mode(struct fmdev *fmdev, u8 rds_en_dis)\n{\n\tu16 payload;\n\tint ret;\n\n\tif (rds_en_dis != FM_RDS_ENABLE && rds_en_dis != FM_RDS_DISABLE) {\n\t\tfmerr(\"Invalid rds option\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rds_en_dis == FM_RDS_ENABLE\n\t    && fmdev->rx.rds.flag == FM_RDS_DISABLE) {\n\t\t \n\t\tpayload = FM_RX_PWR_SET_FM_AND_RDS_BLK_ON;\n\t\tret = fmc_send_cmd(fmdev, POWER_SET, REG_WR, &payload,\n\t\t\t\tsizeof(payload), NULL, NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tpayload = FM_RX_RDS_FLUSH_FIFO;\n\t\tret = fmc_send_cmd(fmdev, RDS_CNTRL_SET, REG_WR, &payload,\n\t\tsizeof(payload), NULL, NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = fmc_send_cmd(fmdev, FLAG_GET, REG_RD, NULL, 2,\n\t\t\t\tNULL, NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tpayload = FM_RX_RDS_FIFO_THRESHOLD;\n\t\tret = fmc_send_cmd(fmdev, RDS_MEM_SET, REG_WR, &payload,\n\t\tsizeof(payload), NULL, NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tfmdev->irq_info.mask |= FM_RDS_EVENT;\n\t\tpayload = fmdev->irq_info.mask;\n\t\tret = fmc_send_cmd(fmdev, INT_MASK_SET, REG_WR, &payload,\n\t\t\t\tsizeof(payload), NULL, NULL);\n\t\tif (ret < 0) {\n\t\t\tfmdev->irq_info.mask &= ~FM_RDS_EVENT;\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tfmdev->rx.rds.flag = FM_RDS_ENABLE;\n\t} else if (rds_en_dis == FM_RDS_DISABLE\n\t\t   && fmdev->rx.rds.flag == FM_RDS_ENABLE) {\n\t\t \n\t\tpayload = FM_RX_PWR_SET_FM_ON_RDS_OFF;\n\t\tret = fmc_send_cmd(fmdev, POWER_SET, REG_WR, &payload,\n\t\t\t\tsizeof(payload), NULL, NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tfmdev->rx.rds.last_blk_idx = 0;\n\t\tfmdev->rx.rds.wr_idx = 0;\n\t\tfmdev->rx.rds.rd_idx = 0;\n\t\tfm_rx_reset_station_info(fmdev);\n\n\t\t \n\t\tfmdev->irq_info.mask &= ~(FM_RDS_EVENT);\n\t\tfmdev->rx.rds.flag = FM_RDS_DISABLE;\n\t}\n\n\treturn 0;\n}\n\n \nint fm_rx_get_rds_mode(struct fmdev *fmdev, u8 *curr_rds_en_dis)\n{\n\tif (fmdev->curr_fmmode != FM_MODE_RX)\n\t\treturn -EPERM;\n\n\tif (curr_rds_en_dis == NULL) {\n\t\tfmerr(\"Invalid memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t*curr_rds_en_dis = fmdev->rx.rds.flag;\n\n\treturn 0;\n}\n\n \nint fm_rx_set_rds_system(struct fmdev *fmdev, u8 rds_mode)\n{\n\tu16 payload;\n\tint ret;\n\n\tif (fmdev->curr_fmmode != FM_MODE_RX)\n\t\treturn -EPERM;\n\n\tif (rds_mode != FM_RDS_SYSTEM_RDS && rds_mode != FM_RDS_SYSTEM_RBDS) {\n\t\tfmerr(\"Invalid rds mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tpayload = (u16)rds_mode;\n\tret = fmc_send_cmd(fmdev, RDS_SYSTEM_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfmdev->rx.rds_mode = rds_mode;\n\n\treturn 0;\n}\n\n \nint fm_rx_set_af_switch(struct fmdev *fmdev, u8 af_mode)\n{\n\tu16 payload;\n\tint ret;\n\n\tif (fmdev->curr_fmmode != FM_MODE_RX)\n\t\treturn -EPERM;\n\n\tif (af_mode != FM_RX_RDS_AF_SWITCH_MODE_ON &&\n\t    af_mode != FM_RX_RDS_AF_SWITCH_MODE_OFF) {\n\t\tfmerr(\"Invalid af mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (af_mode == FM_RX_RDS_AF_SWITCH_MODE_ON)\n\t\tfmdev->irq_info.mask |= FM_LEV_EVENT;\n\telse\n\t\tfmdev->irq_info.mask &= ~FM_LEV_EVENT;\n\n\tpayload = fmdev->irq_info.mask;\n\tret = fmc_send_cmd(fmdev, INT_MASK_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfmdev->rx.af_mode = af_mode;\n\n\treturn 0;\n}\n\n \nint fm_rx_get_af_switch(struct fmdev *fmdev, u8 *af_mode)\n{\n\tif (fmdev->curr_fmmode != FM_MODE_RX)\n\t\treturn -EPERM;\n\n\tif (af_mode == NULL) {\n\t\tfmerr(\"Invalid memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t*af_mode = fmdev->rx.af_mode;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}