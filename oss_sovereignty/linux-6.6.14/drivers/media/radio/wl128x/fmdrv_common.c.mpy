{
  "module_name": "fmdrv_common.c",
  "hash_id": "b29fc65de64827a3e89284abaa35ae0939fcd062cd8fd3c77ee83be93cef4592",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/radio/wl128x/fmdrv_common.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/nospec.h>\n#include <linux/jiffies.h>\n\n#include \"fmdrv.h\"\n#include \"fmdrv_v4l2.h\"\n#include \"fmdrv_common.h\"\n#include <linux/ti_wilink_st.h>\n#include \"fmdrv_rx.h\"\n#include \"fmdrv_tx.h\"\n\n \nstatic struct region_info region_configs[] = {\n\t \n\t{\n\t .chanl_space = FM_CHANNEL_SPACING_200KHZ * FM_FREQ_MUL,\n\t .bot_freq = 87500,\t \n\t .top_freq = 108000,\t \n\t .fm_band = 0,\n\t },\n\t \n\t{\n\t .chanl_space = FM_CHANNEL_SPACING_200KHZ * FM_FREQ_MUL,\n\t .bot_freq = 76000,\t \n\t .top_freq = 90000,\t \n\t .fm_band = 1,\n\t },\n};\n\n \nstatic u8 default_radio_region;\t \nmodule_param(default_radio_region, byte, 0);\nMODULE_PARM_DESC(default_radio_region, \"Region: 0=Europe/US, 1=Japan\");\n\n \nstatic u32 default_rds_buf = 300;\nmodule_param(default_rds_buf, uint, 0444);\nMODULE_PARM_DESC(default_rds_buf, \"RDS buffer entries\");\n\n \nstatic u32 radio_nr = -1;\nmodule_param(radio_nr, int, 0444);\nMODULE_PARM_DESC(radio_nr, \"Radio Nr\");\n\n \nstatic void fm_irq_send_flag_getcmd(struct fmdev *);\nstatic void fm_irq_handle_flag_getcmd_resp(struct fmdev *);\nstatic void fm_irq_handle_hw_malfunction(struct fmdev *);\nstatic void fm_irq_handle_rds_start(struct fmdev *);\nstatic void fm_irq_send_rdsdata_getcmd(struct fmdev *);\nstatic void fm_irq_handle_rdsdata_getcmd_resp(struct fmdev *);\nstatic void fm_irq_handle_rds_finish(struct fmdev *);\nstatic void fm_irq_handle_tune_op_ended(struct fmdev *);\nstatic void fm_irq_handle_power_enb(struct fmdev *);\nstatic void fm_irq_handle_low_rssi_start(struct fmdev *);\nstatic void fm_irq_afjump_set_pi(struct fmdev *);\nstatic void fm_irq_handle_set_pi_resp(struct fmdev *);\nstatic void fm_irq_afjump_set_pimask(struct fmdev *);\nstatic void fm_irq_handle_set_pimask_resp(struct fmdev *);\nstatic void fm_irq_afjump_setfreq(struct fmdev *);\nstatic void fm_irq_handle_setfreq_resp(struct fmdev *);\nstatic void fm_irq_afjump_enableint(struct fmdev *);\nstatic void fm_irq_afjump_enableint_resp(struct fmdev *);\nstatic void fm_irq_start_afjump(struct fmdev *);\nstatic void fm_irq_handle_start_afjump_resp(struct fmdev *);\nstatic void fm_irq_afjump_rd_freq(struct fmdev *);\nstatic void fm_irq_afjump_rd_freq_resp(struct fmdev *);\nstatic void fm_irq_handle_low_rssi_finish(struct fmdev *);\nstatic void fm_irq_send_intmsk_cmd(struct fmdev *);\nstatic void fm_irq_handle_intmsk_cmd_resp(struct fmdev *);\n\n \nenum fmc_irq_handler_index {\n\tFM_SEND_FLAG_GETCMD_IDX,\n\tFM_HANDLE_FLAG_GETCMD_RESP_IDX,\n\n\t \n\tFM_HW_MAL_FUNC_IDX,\n\n\t \n\tFM_RDS_START_IDX,\n\tFM_RDS_SEND_RDS_GETCMD_IDX,\n\tFM_RDS_HANDLE_RDS_GETCMD_RESP_IDX,\n\tFM_RDS_FINISH_IDX,\n\n\t \n\tFM_HW_TUNE_OP_ENDED_IDX,\n\n\t \n\tFM_HW_POWER_ENB_IDX,\n\n\t \n\tFM_LOW_RSSI_START_IDX,\n\tFM_AF_JUMP_SETPI_IDX,\n\tFM_AF_JUMP_HANDLE_SETPI_RESP_IDX,\n\tFM_AF_JUMP_SETPI_MASK_IDX,\n\tFM_AF_JUMP_HANDLE_SETPI_MASK_RESP_IDX,\n\tFM_AF_JUMP_SET_AF_FREQ_IDX,\n\tFM_AF_JUMP_HANDLE_SET_AFFREQ_RESP_IDX,\n\tFM_AF_JUMP_ENABLE_INT_IDX,\n\tFM_AF_JUMP_ENABLE_INT_RESP_IDX,\n\tFM_AF_JUMP_START_AFJUMP_IDX,\n\tFM_AF_JUMP_HANDLE_START_AFJUMP_RESP_IDX,\n\tFM_AF_JUMP_RD_FREQ_IDX,\n\tFM_AF_JUMP_RD_FREQ_RESP_IDX,\n\tFM_LOW_RSSI_FINISH_IDX,\n\n\t \n\tFM_SEND_INTMSK_CMD_IDX,\n\tFM_HANDLE_INTMSK_CMD_RESP_IDX,\n};\n\n \nstatic int_handler_prototype int_handler_table[] = {\n\tfm_irq_send_flag_getcmd,\n\tfm_irq_handle_flag_getcmd_resp,\n\tfm_irq_handle_hw_malfunction,\n\tfm_irq_handle_rds_start,  \n\tfm_irq_send_rdsdata_getcmd,\n\tfm_irq_handle_rdsdata_getcmd_resp,\n\tfm_irq_handle_rds_finish,\n\tfm_irq_handle_tune_op_ended,\n\tfm_irq_handle_power_enb,  \n\tfm_irq_handle_low_rssi_start,\n\tfm_irq_afjump_set_pi,\n\tfm_irq_handle_set_pi_resp,\n\tfm_irq_afjump_set_pimask,\n\tfm_irq_handle_set_pimask_resp,\n\tfm_irq_afjump_setfreq,\n\tfm_irq_handle_setfreq_resp,\n\tfm_irq_afjump_enableint,\n\tfm_irq_afjump_enableint_resp,\n\tfm_irq_start_afjump,\n\tfm_irq_handle_start_afjump_resp,\n\tfm_irq_afjump_rd_freq,\n\tfm_irq_afjump_rd_freq_resp,\n\tfm_irq_handle_low_rssi_finish,\n\tfm_irq_send_intmsk_cmd,  \n\tfm_irq_handle_intmsk_cmd_resp\n};\n\nstatic long (*g_st_write) (struct sk_buff *skb);\nstatic struct completion wait_for_fmdrv_reg_comp;\n\nstatic inline void fm_irq_call(struct fmdev *fmdev)\n{\n\tfmdev->irq_info.handlers[fmdev->irq_info.stage](fmdev);\n}\n\n \nstatic inline void fm_irq_call_stage(struct fmdev *fmdev, u8 stage)\n{\n\tfmdev->irq_info.stage = stage;\n\tfm_irq_call(fmdev);\n}\n\nstatic inline void fm_irq_timeout_stage(struct fmdev *fmdev, u8 stage)\n{\n\tfmdev->irq_info.stage = stage;\n\tmod_timer(&fmdev->irq_info.timer, jiffies + FM_DRV_TX_TIMEOUT);\n}\n\n#ifdef FM_DUMP_TXRX_PKT\n  \ninline void dump_tx_skb_data(struct sk_buff *skb)\n{\n\tint len, len_org;\n\tu8 index;\n\tstruct fm_cmd_msg_hdr *cmd_hdr;\n\n\tcmd_hdr = (struct fm_cmd_msg_hdr *)skb->data;\n\tprintk(KERN_INFO \"<<%shdr:%02x len:%02x opcode:%02x type:%s dlen:%02x\",\n\t       fm_cb(skb)->completion ? \" \" : \"*\", cmd_hdr->hdr,\n\t       cmd_hdr->len, cmd_hdr->op,\n\t       cmd_hdr->rd_wr ? \"RD\" : \"WR\", cmd_hdr->dlen);\n\n\tlen_org = skb->len - FM_CMD_MSG_HDR_SIZE;\n\tif (len_org > 0) {\n\t\tprintk(KERN_CONT \"\\n   data(%d): \", cmd_hdr->dlen);\n\t\tlen = min(len_org, 14);\n\t\tfor (index = 0; index < len; index++)\n\t\t\tprintk(KERN_CONT \"%x \",\n\t\t\t       skb->data[FM_CMD_MSG_HDR_SIZE + index]);\n\t\tprintk(KERN_CONT \"%s\", (len_org > 14) ? \"..\" : \"\");\n\t}\n\tprintk(KERN_CONT \"\\n\");\n}\n\n  \ninline void dump_rx_skb_data(struct sk_buff *skb)\n{\n\tint len, len_org;\n\tu8 index;\n\tstruct fm_event_msg_hdr *evt_hdr;\n\n\tevt_hdr = (struct fm_event_msg_hdr *)skb->data;\n\tprintk(KERN_INFO \">> hdr:%02x len:%02x sts:%02x numhci:%02x opcode:%02x type:%s dlen:%02x\",\n\t       evt_hdr->hdr, evt_hdr->len,\n\t       evt_hdr->status, evt_hdr->num_fm_hci_cmds, evt_hdr->op,\n\t       (evt_hdr->rd_wr) ? \"RD\" : \"WR\", evt_hdr->dlen);\n\n\tlen_org = skb->len - FM_EVT_MSG_HDR_SIZE;\n\tif (len_org > 0) {\n\t\tprintk(KERN_CONT \"\\n   data(%d): \", evt_hdr->dlen);\n\t\tlen = min(len_org, 14);\n\t\tfor (index = 0; index < len; index++)\n\t\t\tprintk(KERN_CONT \"%x \",\n\t\t\t       skb->data[FM_EVT_MSG_HDR_SIZE + index]);\n\t\tprintk(KERN_CONT \"%s\", (len_org > 14) ? \"..\" : \"\");\n\t}\n\tprintk(KERN_CONT \"\\n\");\n}\n#endif\n\nvoid fmc_update_region_info(struct fmdev *fmdev, u8 region_to_set)\n{\n\tfmdev->rx.region = region_configs[region_to_set];\n}\n\n \nstatic void recv_tasklet(struct tasklet_struct *t)\n{\n\tstruct fmdev *fmdev;\n\tstruct fm_irq *irq_info;\n\tstruct fm_event_msg_hdr *evt_hdr;\n\tstruct sk_buff *skb;\n\tu8 num_fm_hci_cmds;\n\tunsigned long flags;\n\n\tfmdev = from_tasklet(fmdev, t, tx_task);\n\tirq_info = &fmdev->irq_info;\n\t \n\twhile ((skb = skb_dequeue(&fmdev->rx_q))) {\n\t\tif (skb->len < sizeof(struct fm_event_msg_hdr)) {\n\t\t\tfmerr(\"skb(%p) has only %d bytes, at least need %zu bytes to decode\\n\",\n\t\t\t      skb,\n\t\t\t      skb->len, sizeof(struct fm_event_msg_hdr));\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tevt_hdr = (void *)skb->data;\n\t\tnum_fm_hci_cmds = evt_hdr->num_fm_hci_cmds;\n\n\t\t \n\t\tif (evt_hdr->op == FM_INTERRUPT) {\n\t\t\t \n\t\t\tif (!test_bit(FM_INTTASK_RUNNING, &fmdev->flag)) {\n\t\t\t\tset_bit(FM_INTTASK_RUNNING, &fmdev->flag);\n\t\t\t\tif (irq_info->stage != 0) {\n\t\t\t\t\tfmerr(\"Inval stage resetting to zero\\n\");\n\t\t\t\t\tirq_info->stage = 0;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tirq_info->handlers[irq_info->stage](fmdev);\n\t\t\t} else {\n\t\t\t\tset_bit(FM_INTTASK_SCHEDULE_PENDING, &fmdev->flag);\n\t\t\t}\n\t\t\tkfree_skb(skb);\n\t\t}\n\t\t \n\t\telse if (evt_hdr->op == fmdev->pre_op && fmdev->resp_comp != NULL) {\n\n\t\t\tspin_lock_irqsave(&fmdev->resp_skb_lock, flags);\n\t\t\tfmdev->resp_skb = skb;\n\t\t\tspin_unlock_irqrestore(&fmdev->resp_skb_lock, flags);\n\t\t\tcomplete(fmdev->resp_comp);\n\n\t\t\tfmdev->resp_comp = NULL;\n\t\t\tatomic_set(&fmdev->tx_cnt, 1);\n\t\t}\n\t\t \n\t\telse if (evt_hdr->op == fmdev->pre_op && fmdev->resp_comp == NULL) {\n\t\t\tif (fmdev->resp_skb != NULL)\n\t\t\t\tfmerr(\"Response SKB ptr not NULL\\n\");\n\n\t\t\tspin_lock_irqsave(&fmdev->resp_skb_lock, flags);\n\t\t\tfmdev->resp_skb = skb;\n\t\t\tspin_unlock_irqrestore(&fmdev->resp_skb_lock, flags);\n\n\t\t\t \n\t\t\tirq_info->handlers[irq_info->stage](fmdev);\n\n\t\t\tkfree_skb(skb);\n\t\t\tatomic_set(&fmdev->tx_cnt, 1);\n\t\t} else {\n\t\t\tfmerr(\"Nobody claimed SKB(%p),purging\\n\", skb);\n\t\t}\n\n\t\t \n\t\tif (num_fm_hci_cmds && atomic_read(&fmdev->tx_cnt))\n\t\t\tif (!skb_queue_empty(&fmdev->tx_q))\n\t\t\t\ttasklet_schedule(&fmdev->tx_task);\n\t}\n}\n\n \nstatic void send_tasklet(struct tasklet_struct *t)\n{\n\tstruct fmdev *fmdev;\n\tstruct sk_buff *skb;\n\tint len;\n\n\tfmdev = from_tasklet(fmdev, t, tx_task);\n\n\tif (!atomic_read(&fmdev->tx_cnt))\n\t\treturn;\n\n\t \n\tif (time_is_before_jiffies(fmdev->last_tx_jiffies + FM_DRV_TX_TIMEOUT)) {\n\t\tfmerr(\"TX timeout occurred\\n\");\n\t\tatomic_set(&fmdev->tx_cnt, 1);\n\t}\n\n\t \n\tskb = skb_dequeue(&fmdev->tx_q);\n\tif (!skb)\n\t\treturn;\n\n\tatomic_dec(&fmdev->tx_cnt);\n\tfmdev->pre_op = fm_cb(skb)->fm_op;\n\n\tif (fmdev->resp_comp != NULL)\n\t\tfmerr(\"Response completion handler is not NULL\\n\");\n\n\tfmdev->resp_comp = fm_cb(skb)->completion;\n\n\t \n\tlen = g_st_write(skb);\n\tif (len < 0) {\n\t\tkfree_skb(skb);\n\t\tfmdev->resp_comp = NULL;\n\t\tfmerr(\"TX tasklet failed to send skb(%p)\\n\", skb);\n\t\tatomic_set(&fmdev->tx_cnt, 1);\n\t} else {\n\t\tfmdev->last_tx_jiffies = jiffies;\n\t}\n}\n\n \nstatic int fm_send_cmd(struct fmdev *fmdev, u8 fm_op, u16 type,\tvoid *payload,\n\t\tint payload_len, struct completion *wait_completion)\n{\n\tstruct sk_buff *skb;\n\tstruct fm_cmd_msg_hdr *hdr;\n\tint size;\n\n\tif (fm_op >= FM_INTERRUPT) {\n\t\tfmerr(\"Invalid fm opcode - %d\\n\", fm_op);\n\t\treturn -EINVAL;\n\t}\n\tif (test_bit(FM_FW_DW_INPROGRESS, &fmdev->flag) && payload == NULL) {\n\t\tfmerr(\"Payload data is NULL during fw download\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!test_bit(FM_FW_DW_INPROGRESS, &fmdev->flag))\n\t\tsize =\n\t\t    FM_CMD_MSG_HDR_SIZE + ((payload == NULL) ? 0 : payload_len);\n\telse\n\t\tsize = payload_len;\n\n\tskb = alloc_skb(size, GFP_ATOMIC);\n\tif (!skb) {\n\t\tfmerr(\"No memory to create new SKB\\n\");\n\t\treturn -ENOMEM;\n\t}\n\t \n\tif (!test_bit(FM_FW_DW_INPROGRESS, &fmdev->flag) ||\n\t\t\ttest_bit(FM_INTTASK_RUNNING, &fmdev->flag)) {\n\t\t \n\t\thdr = skb_put(skb, FM_CMD_MSG_HDR_SIZE);\n\t\thdr->hdr = FM_PKT_LOGICAL_CHAN_NUMBER;\t \n\n\t\t \n\t\thdr->len = ((payload == NULL) ? 0 : payload_len) + 3;\n\n\t\t \n\t\thdr->op = fm_op;\n\n\t\t \n\t\thdr->rd_wr = type;\n\t\thdr->dlen = payload_len;\n\t\tfm_cb(skb)->fm_op = fm_op;\n\n\t\t \n\t\tif (payload != NULL)\n\t\t\t*(__be16 *)payload = cpu_to_be16(*(u16 *)payload);\n\n\t} else if (payload != NULL) {\n\t\tfm_cb(skb)->fm_op = *((u8 *)payload + 2);\n\t}\n\tif (payload != NULL)\n\t\tskb_put_data(skb, payload, payload_len);\n\n\tfm_cb(skb)->completion = wait_completion;\n\tskb_queue_tail(&fmdev->tx_q, skb);\n\ttasklet_schedule(&fmdev->tx_task);\n\n\treturn 0;\n}\n\n \nint fmc_send_cmd(struct fmdev *fmdev, u8 fm_op, u16 type, void *payload,\n\t\tunsigned int payload_len, void *response, int *response_len)\n{\n\tstruct sk_buff *skb;\n\tstruct fm_event_msg_hdr *evt_hdr;\n\tunsigned long flags;\n\tint ret;\n\n\tinit_completion(&fmdev->maintask_comp);\n\tret = fm_send_cmd(fmdev, fm_op, type, payload, payload_len,\n\t\t\t    &fmdev->maintask_comp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!wait_for_completion_timeout(&fmdev->maintask_comp,\n\t\t\t\t\t FM_DRV_TX_TIMEOUT)) {\n\t\tfmerr(\"Timeout(%d sec),didn't get regcompletion signal from RX tasklet\\n\",\n\t\t\t   jiffies_to_msecs(FM_DRV_TX_TIMEOUT) / 1000);\n\t\treturn -ETIMEDOUT;\n\t}\n\tif (!fmdev->resp_skb) {\n\t\tfmerr(\"Response SKB is missing\\n\");\n\t\treturn -EFAULT;\n\t}\n\tspin_lock_irqsave(&fmdev->resp_skb_lock, flags);\n\tskb = fmdev->resp_skb;\n\tfmdev->resp_skb = NULL;\n\tspin_unlock_irqrestore(&fmdev->resp_skb_lock, flags);\n\n\tevt_hdr = (void *)skb->data;\n\tif (evt_hdr->status != 0) {\n\t\tfmerr(\"Received event pkt status(%d) is not zero\\n\",\n\t\t\t   evt_hdr->status);\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\t \n\tif (response != NULL && response_len != NULL && evt_hdr->dlen &&\n\t    evt_hdr->dlen <= payload_len) {\n\t\t \n\t\tskb_pull(skb, sizeof(struct fm_event_msg_hdr));\n\t\tmemcpy(response, skb->data, evt_hdr->dlen);\n\t\t*response_len = evt_hdr->dlen;\n\t} else if (response_len != NULL && evt_hdr->dlen == 0) {\n\t\t*response_len = 0;\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\n \nstatic inline int check_cmdresp_status(struct fmdev *fmdev,\n\t\tstruct sk_buff **skb)\n{\n\tstruct fm_event_msg_hdr *fm_evt_hdr;\n\tunsigned long flags;\n\n\tdel_timer(&fmdev->irq_info.timer);\n\n\tspin_lock_irqsave(&fmdev->resp_skb_lock, flags);\n\t*skb = fmdev->resp_skb;\n\tfmdev->resp_skb = NULL;\n\tspin_unlock_irqrestore(&fmdev->resp_skb_lock, flags);\n\n\tfm_evt_hdr = (void *)(*skb)->data;\n\tif (fm_evt_hdr->status != 0) {\n\t\tfmerr(\"irq: opcode %x response status is not zero Initiating irq recovery process\\n\",\n\t\t\t\tfm_evt_hdr->op);\n\n\t\tmod_timer(&fmdev->irq_info.timer, jiffies + FM_DRV_TX_TIMEOUT);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void fm_irq_common_cmd_resp_helper(struct fmdev *fmdev, u8 stage)\n{\n\tstruct sk_buff *skb;\n\n\tif (!check_cmdresp_status(fmdev, &skb))\n\t\tfm_irq_call_stage(fmdev, stage);\n}\n\n \nstatic void int_timeout_handler(struct timer_list *t)\n{\n\tstruct fmdev *fmdev;\n\tstruct fm_irq *fmirq;\n\n\tfmdbg(\"irq: timeout,trying to re-enable fm interrupts\\n\");\n\tfmdev = from_timer(fmdev, t, irq_info.timer);\n\tfmirq = &fmdev->irq_info;\n\tfmirq->retry++;\n\n\tif (fmirq->retry > FM_IRQ_TIMEOUT_RETRY_MAX) {\n\t\t \n\t\tfmirq->stage = 0;\n\t\tfmirq->retry = 0;\n\t\tfmerr(\"Recovery action failed duringirq processing, max retry reached\\n\");\n\t\treturn;\n\t}\n\tfm_irq_call_stage(fmdev, FM_SEND_INTMSK_CMD_IDX);\n}\n\n \nstatic void fm_irq_send_flag_getcmd(struct fmdev *fmdev)\n{\n\tu16 flag;\n\n\t \n\tif (!fm_send_cmd(fmdev, FLAG_GET, REG_RD, NULL, sizeof(flag), NULL))\n\t\tfm_irq_timeout_stage(fmdev, FM_HANDLE_FLAG_GETCMD_RESP_IDX);\n}\n\nstatic void fm_irq_handle_flag_getcmd_resp(struct fmdev *fmdev)\n{\n\tstruct sk_buff *skb;\n\tstruct fm_event_msg_hdr *fm_evt_hdr;\n\n\tif (check_cmdresp_status(fmdev, &skb))\n\t\treturn;\n\n\tfm_evt_hdr = (void *)skb->data;\n\tif (fm_evt_hdr->dlen > sizeof(fmdev->irq_info.flag))\n\t\treturn;\n\n\t \n\tskb_pull(skb, sizeof(struct fm_event_msg_hdr));\n\tmemcpy(&fmdev->irq_info.flag, skb->data, fm_evt_hdr->dlen);\n\n\tfmdev->irq_info.flag = be16_to_cpu((__force __be16)fmdev->irq_info.flag);\n\tfmdbg(\"irq: flag register(0x%x)\\n\", fmdev->irq_info.flag);\n\n\t \n\tfm_irq_call_stage(fmdev, FM_HW_MAL_FUNC_IDX);\n}\n\nstatic void fm_irq_handle_hw_malfunction(struct fmdev *fmdev)\n{\n\tif (fmdev->irq_info.flag & FM_MAL_EVENT & fmdev->irq_info.mask)\n\t\tfmerr(\"irq: HW MAL int received - do nothing\\n\");\n\n\t \n\tfm_irq_call_stage(fmdev, FM_RDS_START_IDX);\n}\n\nstatic void fm_irq_handle_rds_start(struct fmdev *fmdev)\n{\n\tif (fmdev->irq_info.flag & FM_RDS_EVENT & fmdev->irq_info.mask) {\n\t\tfmdbg(\"irq: rds threshold reached\\n\");\n\t\tfmdev->irq_info.stage = FM_RDS_SEND_RDS_GETCMD_IDX;\n\t} else {\n\t\t \n\t\tfmdev->irq_info.stage = FM_HW_TUNE_OP_ENDED_IDX;\n\t}\n\n\tfm_irq_call(fmdev);\n}\n\nstatic void fm_irq_send_rdsdata_getcmd(struct fmdev *fmdev)\n{\n\t \n\tif (!fm_send_cmd(fmdev, RDS_DATA_GET, REG_RD, NULL,\n\t\t\t    (FM_RX_RDS_FIFO_THRESHOLD * 3), NULL))\n\t\tfm_irq_timeout_stage(fmdev, FM_RDS_HANDLE_RDS_GETCMD_RESP_IDX);\n}\n\n \nstatic void fm_rx_update_af_cache(struct fmdev *fmdev, u8 af)\n{\n\tstruct tuned_station_info *stat_info = &fmdev->rx.stat_info;\n\tu8 reg_idx = fmdev->rx.region.fm_band;\n\tu8 index;\n\tu32 freq;\n\n\t \n\tif ((af >= FM_RDS_1_AF_FOLLOWS) && (af <= FM_RDS_25_AF_FOLLOWS)) {\n\t\tfmdev->rx.stat_info.af_list_max = (af - FM_RDS_1_AF_FOLLOWS + 1);\n\t\tfmdev->rx.stat_info.afcache_size = 0;\n\t\tfmdbg(\"No of expected AF : %d\\n\", fmdev->rx.stat_info.af_list_max);\n\t\treturn;\n\t}\n\n\tif (af < FM_RDS_MIN_AF)\n\t\treturn;\n\tif (reg_idx == FM_BAND_EUROPE_US && af > FM_RDS_MAX_AF)\n\t\treturn;\n\tif (reg_idx == FM_BAND_JAPAN && af > FM_RDS_MAX_AF_JAPAN)\n\t\treturn;\n\n\tfreq = fmdev->rx.region.bot_freq + (af * 100);\n\tif (freq == fmdev->rx.freq) {\n\t\tfmdbg(\"Current freq(%d) is matching with received AF(%d)\\n\",\n\t\t\t\tfmdev->rx.freq, freq);\n\t\treturn;\n\t}\n\t \n\tfor (index = 0; index < stat_info->afcache_size; index++) {\n\t\tif (stat_info->af_cache[index] == freq)\n\t\t\tbreak;\n\t}\n\t \n\tif (index == stat_info->af_list_max) {\n\t\tfmdbg(\"AF cache is full\\n\");\n\t\treturn;\n\t}\n\t \n\tif (index == stat_info->afcache_size) {\n\t\tfmdbg(\"Storing AF %d to cache index %d\\n\", freq, index);\n\t\tstat_info->af_cache[index] = freq;\n\t\tstat_info->afcache_size++;\n\t}\n}\n\n \nstatic void fm_rdsparse_swapbytes(struct fmdev *fmdev,\n\t\tstruct fm_rdsdata_format *rds_format)\n{\n\tu8 index = 0;\n\tu8 *rds_buff;\n\n\t \n\tif (fmdev->asci_id != 0x6350) {\n\t\trds_buff = &rds_format->data.groupdatabuff.buff[0];\n\t\twhile (index + 1 < FM_RX_RDS_INFO_FIELD_MAX) {\n\t\t\tswap(rds_buff[index], rds_buff[index + 1]);\n\t\t\tindex += 2;\n\t\t}\n\t}\n}\n\nstatic void fm_irq_handle_rdsdata_getcmd_resp(struct fmdev *fmdev)\n{\n\tstruct sk_buff *skb;\n\tstruct fm_rdsdata_format rds_fmt;\n\tstruct fm_rds *rds = &fmdev->rx.rds;\n\tunsigned long group_idx, flags;\n\tu8 *rds_data, meta_data, tmpbuf[FM_RDS_BLK_SIZE];\n\tu8 type, blk_idx, idx;\n\tu16 cur_picode;\n\tu32 rds_len;\n\n\tif (check_cmdresp_status(fmdev, &skb))\n\t\treturn;\n\n\t \n\tskb_pull(skb, sizeof(struct fm_event_msg_hdr));\n\trds_data = skb->data;\n\trds_len = skb->len;\n\n\t \n\twhile (rds_len >= FM_RDS_BLK_SIZE) {\n\t\tmeta_data = rds_data[2];\n\t\t \n\t\ttype = (meta_data & 0x07);\n\n\t\t \n\t\tblk_idx = (type <= FM_RDS_BLOCK_C ? type : (type - 1));\n\t\tfmdbg(\"Block index:%d(%s)\\n\", blk_idx,\n\t\t\t   (meta_data & FM_RDS_STATUS_ERR_MASK) ? \"Bad\" : \"Ok\");\n\n\t\tif ((meta_data & FM_RDS_STATUS_ERR_MASK) != 0)\n\t\t\tbreak;\n\n\t\tif (blk_idx > FM_RDS_BLK_IDX_D) {\n\t\t\tfmdbg(\"Block sequence mismatch\\n\");\n\t\t\trds->last_blk_idx = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tidx = array_index_nospec(blk_idx * (FM_RDS_BLK_SIZE - 1),\n\t\t\t\t\t FM_RX_RDS_INFO_FIELD_MAX - (FM_RDS_BLK_SIZE - 1));\n\n\t\tmemcpy(&rds_fmt.data.groupdatabuff.buff[idx], rds_data,\n\t\t       FM_RDS_BLK_SIZE - 1);\n\n\t\trds->last_blk_idx = blk_idx;\n\n\t\t \n\t\tif (blk_idx == FM_RDS_BLK_IDX_D) {\n\t\t\tfmdbg(\"Good block received\\n\");\n\t\t\tfm_rdsparse_swapbytes(fmdev, &rds_fmt);\n\n\t\t\t \n\t\t\tcur_picode = be16_to_cpu((__force __be16)rds_fmt.data.groupgeneral.pidata);\n\t\t\tif (fmdev->rx.stat_info.picode != cur_picode)\n\t\t\t\tfmdev->rx.stat_info.picode = cur_picode;\n\n\t\t\tfmdbg(\"picode:%d\\n\", cur_picode);\n\n\t\t\tgroup_idx = (rds_fmt.data.groupgeneral.blk_b[0] >> 3);\n\t\t\tfmdbg(\"(fmdrv):Group:%ld%s\\n\", group_idx/2,\n\t\t\t\t\t(group_idx % 2) ? \"B\" : \"A\");\n\n\t\t\tgroup_idx = 1 << (rds_fmt.data.groupgeneral.blk_b[0] >> 3);\n\t\t\tif (group_idx == FM_RDS_GROUP_TYPE_MASK_0A) {\n\t\t\t\tfm_rx_update_af_cache(fmdev, rds_fmt.data.group0A.af[0]);\n\t\t\t\tfm_rx_update_af_cache(fmdev, rds_fmt.data.group0A.af[1]);\n\t\t\t}\n\t\t}\n\t\trds_len -= FM_RDS_BLK_SIZE;\n\t\trds_data += FM_RDS_BLK_SIZE;\n\t}\n\n\t \n\trds_data = skb->data;\n\trds_len = skb->len;\n\n\tspin_lock_irqsave(&fmdev->rds_buff_lock, flags);\n\twhile (rds_len > 0) {\n\t\t \n\t\ttype = (rds_data[2] & 0x07);\n\t\tblk_idx = (type <= FM_RDS_BLOCK_C ? type : (type - 1));\n\t\ttmpbuf[2] = blk_idx;\t \n\t\ttmpbuf[2] |= blk_idx << 3;\t \n\n\t\t \n\t\ttmpbuf[0] = rds_data[0];\n\t\ttmpbuf[1] = rds_data[1];\n\n\t\tmemcpy(&rds->buff[rds->wr_idx], &tmpbuf, FM_RDS_BLK_SIZE);\n\t\trds->wr_idx = (rds->wr_idx + FM_RDS_BLK_SIZE) % rds->buf_size;\n\n\t\t \n\t\tif (rds->wr_idx == rds->rd_idx) {\n\t\t\tfmdbg(\"RDS buffer overflow\\n\");\n\t\t\trds->wr_idx = 0;\n\t\t\trds->rd_idx = 0;\n\t\t\tbreak;\n\t\t}\n\t\trds_len -= FM_RDS_BLK_SIZE;\n\t\trds_data += FM_RDS_BLK_SIZE;\n\t}\n\tspin_unlock_irqrestore(&fmdev->rds_buff_lock, flags);\n\n\t \n\tif (rds->wr_idx != rds->rd_idx)\n\t\twake_up_interruptible(&rds->read_queue);\n\n\tfm_irq_call_stage(fmdev, FM_RDS_FINISH_IDX);\n}\n\nstatic void fm_irq_handle_rds_finish(struct fmdev *fmdev)\n{\n\tfm_irq_call_stage(fmdev, FM_HW_TUNE_OP_ENDED_IDX);\n}\n\nstatic void fm_irq_handle_tune_op_ended(struct fmdev *fmdev)\n{\n\tif (fmdev->irq_info.flag & (FM_FR_EVENT | FM_BL_EVENT) & fmdev->\n\t    irq_info.mask) {\n\t\tfmdbg(\"irq: tune ended/bandlimit reached\\n\");\n\t\tif (test_and_clear_bit(FM_AF_SWITCH_INPROGRESS, &fmdev->flag)) {\n\t\t\tfmdev->irq_info.stage = FM_AF_JUMP_RD_FREQ_IDX;\n\t\t} else {\n\t\t\tcomplete(&fmdev->maintask_comp);\n\t\t\tfmdev->irq_info.stage = FM_HW_POWER_ENB_IDX;\n\t\t}\n\t} else\n\t\tfmdev->irq_info.stage = FM_HW_POWER_ENB_IDX;\n\n\tfm_irq_call(fmdev);\n}\n\nstatic void fm_irq_handle_power_enb(struct fmdev *fmdev)\n{\n\tif (fmdev->irq_info.flag & FM_POW_ENB_EVENT) {\n\t\tfmdbg(\"irq: Power Enabled/Disabled\\n\");\n\t\tcomplete(&fmdev->maintask_comp);\n\t}\n\n\tfm_irq_call_stage(fmdev, FM_LOW_RSSI_START_IDX);\n}\n\nstatic void fm_irq_handle_low_rssi_start(struct fmdev *fmdev)\n{\n\tif ((fmdev->rx.af_mode == FM_RX_RDS_AF_SWITCH_MODE_ON) &&\n\t    (fmdev->irq_info.flag & FM_LEV_EVENT & fmdev->irq_info.mask) &&\n\t    (fmdev->rx.freq != FM_UNDEFINED_FREQ) &&\n\t    (fmdev->rx.stat_info.afcache_size != 0)) {\n\t\tfmdbg(\"irq: rssi level has fallen below threshold level\\n\");\n\n\t\t \n\t\tfmdev->irq_info.mask &= ~FM_LEV_EVENT;\n\n\t\tfmdev->rx.afjump_idx = 0;\n\t\tfmdev->rx.freq_before_jump = fmdev->rx.freq;\n\t\tfmdev->irq_info.stage = FM_AF_JUMP_SETPI_IDX;\n\t} else {\n\t\t \n\t\tfmdev->irq_info.stage = FM_SEND_INTMSK_CMD_IDX;\n\t}\n\n\tfm_irq_call(fmdev);\n}\n\nstatic void fm_irq_afjump_set_pi(struct fmdev *fmdev)\n{\n\tu16 payload;\n\n\t \n\tpayload = fmdev->rx.stat_info.picode;\n\tif (!fm_send_cmd(fmdev, RDS_PI_SET, REG_WR, &payload, sizeof(payload), NULL))\n\t\tfm_irq_timeout_stage(fmdev, FM_AF_JUMP_HANDLE_SETPI_RESP_IDX);\n}\n\nstatic void fm_irq_handle_set_pi_resp(struct fmdev *fmdev)\n{\n\tfm_irq_common_cmd_resp_helper(fmdev, FM_AF_JUMP_SETPI_MASK_IDX);\n}\n\n \nstatic void fm_irq_afjump_set_pimask(struct fmdev *fmdev)\n{\n\tu16 payload;\n\n\tpayload = 0x0000;\n\tif (!fm_send_cmd(fmdev, RDS_PI_MASK_SET, REG_WR, &payload, sizeof(payload), NULL))\n\t\tfm_irq_timeout_stage(fmdev, FM_AF_JUMP_HANDLE_SETPI_MASK_RESP_IDX);\n}\n\nstatic void fm_irq_handle_set_pimask_resp(struct fmdev *fmdev)\n{\n\tfm_irq_common_cmd_resp_helper(fmdev, FM_AF_JUMP_SET_AF_FREQ_IDX);\n}\n\nstatic void fm_irq_afjump_setfreq(struct fmdev *fmdev)\n{\n\tu16 frq_index;\n\tu16 payload;\n\n\tfmdbg(\"Switch to %d KHz\\n\", fmdev->rx.stat_info.af_cache[fmdev->rx.afjump_idx]);\n\tfrq_index = (fmdev->rx.stat_info.af_cache[fmdev->rx.afjump_idx] -\n\t     fmdev->rx.region.bot_freq) / FM_FREQ_MUL;\n\n\tpayload = frq_index;\n\tif (!fm_send_cmd(fmdev, AF_FREQ_SET, REG_WR, &payload, sizeof(payload), NULL))\n\t\tfm_irq_timeout_stage(fmdev, FM_AF_JUMP_HANDLE_SET_AFFREQ_RESP_IDX);\n}\n\nstatic void fm_irq_handle_setfreq_resp(struct fmdev *fmdev)\n{\n\tfm_irq_common_cmd_resp_helper(fmdev, FM_AF_JUMP_ENABLE_INT_IDX);\n}\n\nstatic void fm_irq_afjump_enableint(struct fmdev *fmdev)\n{\n\tu16 payload;\n\n\t \n\tpayload = FM_FR_EVENT;\n\tif (!fm_send_cmd(fmdev, INT_MASK_SET, REG_WR, &payload, sizeof(payload), NULL))\n\t\tfm_irq_timeout_stage(fmdev, FM_AF_JUMP_ENABLE_INT_RESP_IDX);\n}\n\nstatic void fm_irq_afjump_enableint_resp(struct fmdev *fmdev)\n{\n\tfm_irq_common_cmd_resp_helper(fmdev, FM_AF_JUMP_START_AFJUMP_IDX);\n}\n\nstatic void fm_irq_start_afjump(struct fmdev *fmdev)\n{\n\tu16 payload;\n\n\tpayload = FM_TUNER_AF_JUMP_MODE;\n\tif (!fm_send_cmd(fmdev, TUNER_MODE_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL))\n\t\tfm_irq_timeout_stage(fmdev, FM_AF_JUMP_HANDLE_START_AFJUMP_RESP_IDX);\n}\n\nstatic void fm_irq_handle_start_afjump_resp(struct fmdev *fmdev)\n{\n\tstruct sk_buff *skb;\n\n\tif (check_cmdresp_status(fmdev, &skb))\n\t\treturn;\n\n\tfmdev->irq_info.stage = FM_SEND_FLAG_GETCMD_IDX;\n\tset_bit(FM_AF_SWITCH_INPROGRESS, &fmdev->flag);\n\tclear_bit(FM_INTTASK_RUNNING, &fmdev->flag);\n}\n\nstatic void fm_irq_afjump_rd_freq(struct fmdev *fmdev)\n{\n\tu16 payload;\n\n\tif (!fm_send_cmd(fmdev, FREQ_SET, REG_RD, NULL, sizeof(payload), NULL))\n\t\tfm_irq_timeout_stage(fmdev, FM_AF_JUMP_RD_FREQ_RESP_IDX);\n}\n\nstatic void fm_irq_afjump_rd_freq_resp(struct fmdev *fmdev)\n{\n\tstruct sk_buff *skb;\n\tu16 read_freq;\n\tu32 curr_freq, jumped_freq;\n\n\tif (check_cmdresp_status(fmdev, &skb))\n\t\treturn;\n\n\t \n\tskb_pull(skb, sizeof(struct fm_event_msg_hdr));\n\tmemcpy(&read_freq, skb->data, sizeof(read_freq));\n\tread_freq = be16_to_cpu((__force __be16)read_freq);\n\tcurr_freq = fmdev->rx.region.bot_freq + ((u32)read_freq * FM_FREQ_MUL);\n\n\tjumped_freq = fmdev->rx.stat_info.af_cache[fmdev->rx.afjump_idx];\n\n\t \n\tif ((curr_freq != fmdev->rx.freq_before_jump) && (curr_freq == jumped_freq)) {\n\t\tfmdbg(\"Successfully switched to alternate freq %d\\n\", curr_freq);\n\t\tfmdev->rx.freq = curr_freq;\n\t\tfm_rx_reset_rds_cache(fmdev);\n\n\t\t \n\t\tif (fmdev->rx.af_mode == FM_RX_RDS_AF_SWITCH_MODE_ON)\n\t\t\tfmdev->irq_info.mask |= FM_LEV_EVENT;\n\n\t\tfmdev->irq_info.stage = FM_LOW_RSSI_FINISH_IDX;\n\t} else {\t\t \n\t\tfmdev->rx.afjump_idx++;\n\n\t\t \n\t\tif (fmdev->rx.afjump_idx >= fmdev->rx.stat_info.afcache_size) {\n\t\t\tfmdbg(\"AF switch processing failed\\n\");\n\t\t\tfmdev->irq_info.stage = FM_LOW_RSSI_FINISH_IDX;\n\t\t} else {\t \n\n\t\t\tfmdbg(\"Trying next freq in AF cache\\n\");\n\t\t\tfmdev->irq_info.stage = FM_AF_JUMP_SETPI_IDX;\n\t\t}\n\t}\n\tfm_irq_call(fmdev);\n}\n\nstatic void fm_irq_handle_low_rssi_finish(struct fmdev *fmdev)\n{\n\tfm_irq_call_stage(fmdev, FM_SEND_INTMSK_CMD_IDX);\n}\n\nstatic void fm_irq_send_intmsk_cmd(struct fmdev *fmdev)\n{\n\tu16 payload;\n\n\t \n\tpayload = fmdev->irq_info.mask;\n\n\tif (!fm_send_cmd(fmdev, INT_MASK_SET, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL))\n\t\tfm_irq_timeout_stage(fmdev, FM_HANDLE_INTMSK_CMD_RESP_IDX);\n}\n\nstatic void fm_irq_handle_intmsk_cmd_resp(struct fmdev *fmdev)\n{\n\tstruct sk_buff *skb;\n\n\tif (check_cmdresp_status(fmdev, &skb))\n\t\treturn;\n\t \n\tfmdev->irq_info.stage = FM_SEND_FLAG_GETCMD_IDX;\n\n\t \n\tif (test_and_clear_bit(FM_INTTASK_SCHEDULE_PENDING, &fmdev->flag))\n\t\tfmdev->irq_info.handlers[fmdev->irq_info.stage](fmdev);\n\telse\n\t\tclear_bit(FM_INTTASK_RUNNING, &fmdev->flag);\n}\n\n \nint fmc_is_rds_data_available(struct fmdev *fmdev, struct file *file,\n\t\t\t\tstruct poll_table_struct *pts)\n{\n\tpoll_wait(file, &fmdev->rx.rds.read_queue, pts);\n\tif (fmdev->rx.rds.rd_idx != fmdev->rx.rds.wr_idx)\n\t\treturn 0;\n\n\treturn -EAGAIN;\n}\n\n \nint fmc_transfer_rds_from_internal_buff(struct fmdev *fmdev, struct file *file,\n\t\tu8 __user *buf, size_t count)\n{\n\tu32 block_count;\n\tu8 tmpbuf[FM_RDS_BLK_SIZE];\n\tunsigned long flags;\n\tint ret;\n\n\tif (fmdev->rx.rds.wr_idx == fmdev->rx.rds.rd_idx) {\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EWOULDBLOCK;\n\n\t\tret = wait_event_interruptible(fmdev->rx.rds.read_queue,\n\t\t\t\t(fmdev->rx.rds.wr_idx != fmdev->rx.rds.rd_idx));\n\t\tif (ret)\n\t\t\treturn -EINTR;\n\t}\n\n\t \n\tcount /= FM_RDS_BLK_SIZE;\n\tblock_count = 0;\n\tret = 0;\n\n\twhile (block_count < count) {\n\t\tspin_lock_irqsave(&fmdev->rds_buff_lock, flags);\n\n\t\tif (fmdev->rx.rds.wr_idx == fmdev->rx.rds.rd_idx) {\n\t\t\tspin_unlock_irqrestore(&fmdev->rds_buff_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(tmpbuf, &fmdev->rx.rds.buff[fmdev->rx.rds.rd_idx],\n\t\t\t\t\tFM_RDS_BLK_SIZE);\n\t\tfmdev->rx.rds.rd_idx += FM_RDS_BLK_SIZE;\n\t\tif (fmdev->rx.rds.rd_idx >= fmdev->rx.rds.buf_size)\n\t\t\tfmdev->rx.rds.rd_idx = 0;\n\n\t\tspin_unlock_irqrestore(&fmdev->rds_buff_lock, flags);\n\n\t\tif (copy_to_user(buf, tmpbuf, FM_RDS_BLK_SIZE))\n\t\t\tbreak;\n\n\t\tblock_count++;\n\t\tbuf += FM_RDS_BLK_SIZE;\n\t\tret += FM_RDS_BLK_SIZE;\n\t}\n\treturn ret;\n}\n\nint fmc_set_freq(struct fmdev *fmdev, u32 freq_to_set)\n{\n\tswitch (fmdev->curr_fmmode) {\n\tcase FM_MODE_RX:\n\t\treturn fm_rx_set_freq(fmdev, freq_to_set);\n\n\tcase FM_MODE_TX:\n\t\treturn fm_tx_set_freq(fmdev, freq_to_set);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint fmc_get_freq(struct fmdev *fmdev, u32 *cur_tuned_frq)\n{\n\tif (fmdev->rx.freq == FM_UNDEFINED_FREQ) {\n\t\tfmerr(\"RX frequency is not set\\n\");\n\t\treturn -EPERM;\n\t}\n\tif (cur_tuned_frq == NULL) {\n\t\tfmerr(\"Invalid memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tswitch (fmdev->curr_fmmode) {\n\tcase FM_MODE_RX:\n\t\t*cur_tuned_frq = fmdev->rx.freq;\n\t\treturn 0;\n\n\tcase FM_MODE_TX:\n\t\t*cur_tuned_frq = 0;\t \n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n}\n\nint fmc_set_region(struct fmdev *fmdev, u8 region_to_set)\n{\n\tswitch (fmdev->curr_fmmode) {\n\tcase FM_MODE_RX:\n\t\treturn fm_rx_set_region(fmdev, region_to_set);\n\n\tcase FM_MODE_TX:\n\t\treturn fm_tx_set_region(fmdev, region_to_set);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint fmc_set_mute_mode(struct fmdev *fmdev, u8 mute_mode_toset)\n{\n\tswitch (fmdev->curr_fmmode) {\n\tcase FM_MODE_RX:\n\t\treturn fm_rx_set_mute_mode(fmdev, mute_mode_toset);\n\n\tcase FM_MODE_TX:\n\t\treturn fm_tx_set_mute_mode(fmdev, mute_mode_toset);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint fmc_set_stereo_mono(struct fmdev *fmdev, u16 mode)\n{\n\tswitch (fmdev->curr_fmmode) {\n\tcase FM_MODE_RX:\n\t\treturn fm_rx_set_stereo_mono(fmdev, mode);\n\n\tcase FM_MODE_TX:\n\t\treturn fm_tx_set_stereo_mono(fmdev, mode);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint fmc_set_rds_mode(struct fmdev *fmdev, u8 rds_en_dis)\n{\n\tswitch (fmdev->curr_fmmode) {\n\tcase FM_MODE_RX:\n\t\treturn fm_rx_set_rds_mode(fmdev, rds_en_dis);\n\n\tcase FM_MODE_TX:\n\t\treturn fm_tx_set_rds_mode(fmdev, rds_en_dis);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int fm_power_down(struct fmdev *fmdev)\n{\n\tu16 payload;\n\tint ret;\n\n\tif (!test_bit(FM_CORE_READY, &fmdev->flag)) {\n\t\tfmerr(\"FM core is not ready\\n\");\n\t\treturn -EPERM;\n\t}\n\tif (fmdev->curr_fmmode == FM_MODE_OFF) {\n\t\tfmdbg(\"FM chip is already in OFF state\\n\");\n\t\treturn 0;\n\t}\n\n\tpayload = 0x0;\n\tret = fmc_send_cmd(fmdev, FM_POWER_MODE, REG_WR, &payload,\n\t\tsizeof(payload), NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn fmc_release(fmdev);\n}\n\n \nstatic int fm_download_firmware(struct fmdev *fmdev, const u8 *fw_name)\n{\n\tconst struct firmware *fw_entry;\n\tstruct bts_header *fw_header;\n\tstruct bts_action *action;\n\tstruct bts_action_delay *delay;\n\tu8 *fw_data;\n\tint ret, fw_len;\n\n\tset_bit(FM_FW_DW_INPROGRESS, &fmdev->flag);\n\n\tret = request_firmware(&fw_entry, fw_name,\n\t\t\t\t&fmdev->radio_dev->dev);\n\tif (ret < 0) {\n\t\tfmerr(\"Unable to read firmware(%s) content\\n\", fw_name);\n\t\treturn ret;\n\t}\n\tfmdbg(\"Firmware(%s) length : %zu bytes\\n\", fw_name, fw_entry->size);\n\n\tfw_data = (void *)fw_entry->data;\n\tfw_len = fw_entry->size;\n\n\tfw_header = (struct bts_header *)fw_data;\n\tif (fw_header->magic != FM_FW_FILE_HEADER_MAGIC) {\n\t\tfmerr(\"%s not a legal TI firmware file\\n\", fw_name);\n\t\tret = -EINVAL;\n\t\tgoto rel_fw;\n\t}\n\tfmdbg(\"FW(%s) magic number : 0x%x\\n\", fw_name, fw_header->magic);\n\n\t \n\tfw_data += sizeof(struct bts_header);\n\tfw_len -= sizeof(struct bts_header);\n\n\twhile (fw_data && fw_len > 0) {\n\t\taction = (struct bts_action *)fw_data;\n\n\t\tswitch (action->type) {\n\t\tcase ACTION_SEND_COMMAND:\t \n\t\t\tret = fmc_send_cmd(fmdev, 0, 0, action->data,\n\t\t\t\t\t   action->size, NULL, NULL);\n\t\t\tif (ret)\n\t\t\t\tgoto rel_fw;\n\n\t\t\tbreak;\n\n\t\tcase ACTION_DELAY:\t \n\t\t\tdelay = (struct bts_action_delay *)action->data;\n\t\t\tmdelay(delay->msec);\n\t\t\tbreak;\n\t\t}\n\n\t\tfw_data += (sizeof(struct bts_action) + (action->size));\n\t\tfw_len -= (sizeof(struct bts_action) + (action->size));\n\t}\n\tfmdbg(\"Transferred only %d of %d bytes of the firmware to chip\\n\",\n\t      fw_entry->size - fw_len, fw_entry->size);\nrel_fw:\n\trelease_firmware(fw_entry);\n\tclear_bit(FM_FW_DW_INPROGRESS, &fmdev->flag);\n\n\treturn ret;\n}\n\n \nstatic int load_default_rx_configuration(struct fmdev *fmdev)\n{\n\tint ret;\n\n\tret = fm_rx_set_volume(fmdev, FM_DEFAULT_RX_VOLUME);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn fm_rx_set_rssi_threshold(fmdev, FM_DEFAULT_RSSI_THRESHOLD);\n}\n\n \nstatic int fm_power_up(struct fmdev *fmdev, u8 mode)\n{\n\tu16 payload;\n\t__be16 asic_id = 0, asic_ver = 0;\n\tint resp_len, ret;\n\tu8 fw_name[50];\n\n\tif (mode >= FM_MODE_ENTRY_MAX) {\n\t\tfmerr(\"Invalid firmware download option\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = fmc_prepare(fmdev);\n\tif (ret < 0) {\n\t\tfmerr(\"Unable to prepare FM Common\\n\");\n\t\treturn ret;\n\t}\n\n\tpayload = FM_ENABLE;\n\tif (fmc_send_cmd(fmdev, FM_POWER_MODE, REG_WR, &payload,\n\t\t\tsizeof(payload), NULL, NULL))\n\t\tgoto rel;\n\n\t \n\tmsleep(20);\n\n\tif (fmc_send_cmd(fmdev, ASIC_ID_GET, REG_RD, NULL,\n\t\t\tsizeof(asic_id), &asic_id, &resp_len))\n\t\tgoto rel;\n\n\tif (fmc_send_cmd(fmdev, ASIC_VER_GET, REG_RD, NULL,\n\t\t\tsizeof(asic_ver), &asic_ver, &resp_len))\n\t\tgoto rel;\n\n\tfmdbg(\"ASIC ID: 0x%x , ASIC Version: %d\\n\",\n\t\tbe16_to_cpu(asic_id), be16_to_cpu(asic_ver));\n\n\tsprintf(fw_name, \"%s_%x.%d.bts\", FM_FMC_FW_FILE_START,\n\t\tbe16_to_cpu(asic_id), be16_to_cpu(asic_ver));\n\n\tret = fm_download_firmware(fmdev, fw_name);\n\tif (ret < 0) {\n\t\tfmdbg(\"Failed to download firmware file %s\\n\", fw_name);\n\t\tgoto rel;\n\t}\n\tsprintf(fw_name, \"%s_%x.%d.bts\", (mode == FM_MODE_RX) ?\n\t\t\tFM_RX_FW_FILE_START : FM_TX_FW_FILE_START,\n\t\t\tbe16_to_cpu(asic_id), be16_to_cpu(asic_ver));\n\n\tret = fm_download_firmware(fmdev, fw_name);\n\tif (ret < 0) {\n\t\tfmdbg(\"Failed to download firmware file %s\\n\", fw_name);\n\t\tgoto rel;\n\t} else\n\t\treturn ret;\nrel:\n\treturn fmc_release(fmdev);\n}\n\n \nint fmc_set_mode(struct fmdev *fmdev, u8 fm_mode)\n{\n\tint ret = 0;\n\n\tif (fm_mode >= FM_MODE_ENTRY_MAX) {\n\t\tfmerr(\"Invalid FM mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (fmdev->curr_fmmode == fm_mode) {\n\t\tfmdbg(\"Already fm is in mode(%d)\\n\", fm_mode);\n\t\treturn ret;\n\t}\n\n\tswitch (fm_mode) {\n\tcase FM_MODE_OFF:\t \n\t\tret = fm_power_down(fmdev);\n\t\tif (ret < 0) {\n\t\t\tfmerr(\"Failed to set OFF mode\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\n\tcase FM_MODE_TX:\t \n\tcase FM_MODE_RX:\t \n\t\t \n\t\tif (fmdev->curr_fmmode != FM_MODE_OFF) {\n\t\t\tret = fm_power_down(fmdev);\n\t\t\tif (ret < 0) {\n\t\t\t\tfmerr(\"Failed to set OFF mode\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tmsleep(30);\n\t\t}\n\t\tret = fm_power_up(fmdev, fm_mode);\n\t\tif (ret < 0) {\n\t\t\tfmerr(\"Failed to load firmware\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tfmdev->curr_fmmode = fm_mode;\n\n\t \n\tif (fmdev->curr_fmmode == FM_MODE_RX) {\n\t\tfmdbg(\"Loading default rx configuration..\\n\");\n\t\tret = load_default_rx_configuration(fmdev);\n\t\tif (ret < 0)\n\t\t\tfmerr(\"Failed to load default values\\n\");\n\t}\n\n\treturn ret;\n}\n\n \nint fmc_get_mode(struct fmdev *fmdev, u8 *fmmode)\n{\n\tif (!test_bit(FM_CORE_READY, &fmdev->flag)) {\n\t\tfmerr(\"FM core is not ready\\n\");\n\t\treturn -EPERM;\n\t}\n\tif (fmmode == NULL) {\n\t\tfmerr(\"Invalid memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t*fmmode = fmdev->curr_fmmode;\n\treturn 0;\n}\n\n \nstatic long fm_st_receive(void *arg, struct sk_buff *skb)\n{\n\tstruct fmdev *fmdev;\n\n\tfmdev = arg;\n\n\tif (skb == NULL) {\n\t\tfmerr(\"Invalid SKB received from ST\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (skb->cb[0] != FM_PKT_LOGICAL_CHAN_NUMBER) {\n\t\tfmerr(\"Received SKB (%p) is not FM Channel 8 pkt\\n\", skb);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(skb_push(skb, 1), &skb->cb[0], 1);\n\tskb_queue_tail(&fmdev->rx_q, skb);\n\ttasklet_schedule(&fmdev->rx_task);\n\n\treturn 0;\n}\n\n \nstatic void fm_st_reg_comp_cb(void *arg, int data)\n{\n\tstruct fmdev *fmdev;\n\n\tfmdev = (struct fmdev *)arg;\n\tfmdev->streg_cbdata = data;\n\tcomplete(&wait_for_fmdrv_reg_comp);\n}\n\n \nint fmc_prepare(struct fmdev *fmdev)\n{\n\tstatic struct st_proto_s fm_st_proto;\n\tint ret;\n\n\tif (test_bit(FM_CORE_READY, &fmdev->flag)) {\n\t\tfmdbg(\"FM Core is already up\\n\");\n\t\treturn 0;\n\t}\n\n\tmemset(&fm_st_proto, 0, sizeof(fm_st_proto));\n\tfm_st_proto.recv = fm_st_receive;\n\tfm_st_proto.match_packet = NULL;\n\tfm_st_proto.reg_complete_cb = fm_st_reg_comp_cb;\n\tfm_st_proto.write = NULL;  \n\tfm_st_proto.priv_data = fmdev;\n\tfm_st_proto.chnl_id = 0x08;\n\tfm_st_proto.max_frame_size = 0xff;\n\tfm_st_proto.hdr_len = 1;\n\tfm_st_proto.offset_len_in_hdr = 0;\n\tfm_st_proto.len_size = 1;\n\tfm_st_proto.reserve = 1;\n\n\tret = st_register(&fm_st_proto);\n\tif (ret == -EINPROGRESS) {\n\t\tinit_completion(&wait_for_fmdrv_reg_comp);\n\t\tfmdev->streg_cbdata = -EINPROGRESS;\n\t\tfmdbg(\"%s waiting for ST reg completion signal\\n\", __func__);\n\n\t\tif (!wait_for_completion_timeout(&wait_for_fmdrv_reg_comp,\n\t\t\t\t\t\t FM_ST_REG_TIMEOUT)) {\n\t\t\tfmerr(\"Timeout(%d sec), didn't get reg completion signal from ST\\n\",\n\t\t\t\t\tjiffies_to_msecs(FM_ST_REG_TIMEOUT) / 1000);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tif (fmdev->streg_cbdata != 0) {\n\t\t\tfmerr(\"ST reg comp CB called with error status %d\\n\",\n\t\t\t      fmdev->streg_cbdata);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tret = 0;\n\t} else if (ret < 0) {\n\t\tfmerr(\"st_register failed %d\\n\", ret);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (fm_st_proto.write != NULL) {\n\t\tg_st_write = fm_st_proto.write;\n\t} else {\n\t\tfmerr(\"Failed to get ST write func pointer\\n\");\n\t\tret = st_unregister(&fm_st_proto);\n\t\tif (ret < 0)\n\t\t\tfmerr(\"st_unregister failed %d\\n\", ret);\n\t\treturn -EAGAIN;\n\t}\n\n\tspin_lock_init(&fmdev->rds_buff_lock);\n\tspin_lock_init(&fmdev->resp_skb_lock);\n\n\t \n\tskb_queue_head_init(&fmdev->tx_q);\n\ttasklet_setup(&fmdev->tx_task, send_tasklet);\n\n\t \n\tskb_queue_head_init(&fmdev->rx_q);\n\ttasklet_setup(&fmdev->rx_task, recv_tasklet);\n\n\tfmdev->irq_info.stage = 0;\n\tatomic_set(&fmdev->tx_cnt, 1);\n\tfmdev->resp_comp = NULL;\n\n\ttimer_setup(&fmdev->irq_info.timer, int_timeout_handler, 0);\n\t \n\tfmdev->irq_info.mask = FM_MAL_EVENT;\n\n\t \n\tfmdev->rx.region = region_configs[default_radio_region];\n\n\tfmdev->rx.mute_mode = FM_MUTE_OFF;\n\tfmdev->rx.rf_depend_mute = FM_RX_RF_DEPENDENT_MUTE_OFF;\n\tfmdev->rx.rds.flag = FM_RDS_DISABLE;\n\tfmdev->rx.freq = FM_UNDEFINED_FREQ;\n\tfmdev->rx.rds_mode = FM_RDS_SYSTEM_RDS;\n\tfmdev->rx.af_mode = FM_RX_RDS_AF_SWITCH_MODE_OFF;\n\tfmdev->irq_info.retry = 0;\n\n\tfm_rx_reset_rds_cache(fmdev);\n\tinit_waitqueue_head(&fmdev->rx.rds.read_queue);\n\n\tfm_rx_reset_station_info(fmdev);\n\tset_bit(FM_CORE_READY, &fmdev->flag);\n\n\treturn ret;\n}\n\n \nint fmc_release(struct fmdev *fmdev)\n{\n\tstatic struct st_proto_s fm_st_proto;\n\tint ret;\n\n\tif (!test_bit(FM_CORE_READY, &fmdev->flag)) {\n\t\tfmdbg(\"FM Core is already down\\n\");\n\t\treturn 0;\n\t}\n\t \n\twake_up_interruptible(&fmdev->rx.rds.read_queue);\n\n\ttasklet_kill(&fmdev->tx_task);\n\ttasklet_kill(&fmdev->rx_task);\n\n\tskb_queue_purge(&fmdev->tx_q);\n\tskb_queue_purge(&fmdev->rx_q);\n\n\tfmdev->resp_comp = NULL;\n\tfmdev->rx.freq = 0;\n\n\tmemset(&fm_st_proto, 0, sizeof(fm_st_proto));\n\tfm_st_proto.chnl_id = 0x08;\n\n\tret = st_unregister(&fm_st_proto);\n\n\tif (ret < 0)\n\t\tfmerr(\"Failed to de-register FM from ST %d\\n\", ret);\n\telse\n\t\tfmdbg(\"Successfully unregistered from ST\\n\");\n\n\tclear_bit(FM_CORE_READY, &fmdev->flag);\n\treturn ret;\n}\n\n \nstatic int __init fm_drv_init(void)\n{\n\tstruct fmdev *fmdev = NULL;\n\tint ret = -ENOMEM;\n\n\tfmdbg(\"FM driver version %s\\n\", FM_DRV_VERSION);\n\n\tfmdev = kzalloc(sizeof(struct fmdev), GFP_KERNEL);\n\tif (NULL == fmdev) {\n\t\tfmerr(\"Can't allocate operation structure memory\\n\");\n\t\treturn ret;\n\t}\n\tfmdev->rx.rds.buf_size = default_rds_buf * FM_RDS_BLK_SIZE;\n\tfmdev->rx.rds.buff = kzalloc(fmdev->rx.rds.buf_size, GFP_KERNEL);\n\tif (NULL == fmdev->rx.rds.buff) {\n\t\tfmerr(\"Can't allocate rds ring buffer\\n\");\n\t\tgoto rel_dev;\n\t}\n\n\tret = fm_v4l2_init_video_device(fmdev, radio_nr);\n\tif (ret < 0)\n\t\tgoto rel_rdsbuf;\n\n\tfmdev->irq_info.handlers = int_handler_table;\n\tfmdev->curr_fmmode = FM_MODE_OFF;\n\tfmdev->tx_data.pwr_lvl = FM_PWR_LVL_DEF;\n\tfmdev->tx_data.preemph = FM_TX_PREEMPH_50US;\n\treturn ret;\n\nrel_rdsbuf:\n\tkfree(fmdev->rx.rds.buff);\nrel_dev:\n\tkfree(fmdev);\n\n\treturn ret;\n}\n\n \nstatic void __exit fm_drv_exit(void)\n{\n\tstruct fmdev *fmdev = NULL;\n\n\tfmdev = fm_v4l2_deinit_video_device();\n\tif (fmdev != NULL) {\n\t\tkfree(fmdev->rx.rds.buff);\n\t\tkfree(fmdev);\n\t}\n}\n\nmodule_init(fm_drv_init);\nmodule_exit(fm_drv_exit);\n\n \nMODULE_AUTHOR(\"Manjunatha Halli <manjunatha_halli@ti.com>\");\nMODULE_DESCRIPTION(\"FM Driver for TI's Connectivity chip. \" FM_DRV_VERSION);\nMODULE_VERSION(FM_DRV_VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}