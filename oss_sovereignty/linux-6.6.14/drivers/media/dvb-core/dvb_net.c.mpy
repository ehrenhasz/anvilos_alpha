{
  "module_name": "dvb_net.c",
  "hash_id": "3e2dbf9c21a5dba979b9485430a1d70b7dcd363b400eaadd4c3f46a7a59c3000",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-core/dvb_net.c",
  "human_readable_source": "\n \n\n \n\n \n\n#define pr_fmt(fmt) \"dvb_net: \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/nospec.h>\n#include <linux/etherdevice.h>\n#include <linux/dvb/net.h>\n#include <linux/uio.h>\n#include <linux/uaccess.h>\n#include <linux/crc32.h>\n#include <linux/mutex.h>\n#include <linux/sched.h>\n\n#include <media/dvb_demux.h>\n#include <media/dvb_net.h>\n\nstatic inline __u32 iov_crc32( __u32 c, struct kvec *iov, unsigned int cnt )\n{\n\tunsigned int j;\n\tfor (j = 0; j < cnt; j++)\n\t\tc = crc32_be( c, iov[j].iov_base, iov[j].iov_len );\n\treturn c;\n}\n\n\n#define DVB_NET_MULTICAST_MAX 10\n\n#ifdef DVB_ULE_DEBUG\n \nstatic unsigned char ule_hist[100*TS_SZ] = { 0 };\nstatic unsigned char *ule_where = ule_hist, ule_dump;\n\nstatic void hexdump(const unsigned char *buf, unsigned short len)\n{\n\tprint_hex_dump_debug(\"\", DUMP_PREFIX_OFFSET, 16, 1, buf, len, true);\n}\n#endif\n\nstruct dvb_net_priv {\n\tint in_use;\n\tu16 pid;\n\tstruct net_device *net;\n\tstruct dvb_net *host;\n\tstruct dmx_demux *demux;\n\tstruct dmx_section_feed *secfeed;\n\tstruct dmx_section_filter *secfilter;\n\tstruct dmx_ts_feed *tsfeed;\n\tint multi_num;\n\tstruct dmx_section_filter *multi_secfilter[DVB_NET_MULTICAST_MAX];\n\tunsigned char multi_macs[DVB_NET_MULTICAST_MAX][6];\n\tint rx_mode;\n#define RX_MODE_UNI 0\n#define RX_MODE_MULTI 1\n#define RX_MODE_ALL_MULTI 2\n#define RX_MODE_PROMISC 3\n\tstruct work_struct set_multicast_list_wq;\n\tstruct work_struct restart_net_feed_wq;\n\tunsigned char feedtype;\t\t\t \n\tint need_pusi;\t\t\t\t \n\tunsigned char tscc;\t\t\t \n\tstruct sk_buff *ule_skb;\t\t \n\tunsigned char *ule_next_hdr;\t\t \n\tunsigned short ule_sndu_len;\t\t \n\tunsigned short ule_sndu_type;\t\t \n\tunsigned char ule_sndu_type_1;\t\t \n\tunsigned char ule_dbit;\t\t\t \n\tunsigned char ule_bridged;\t\t \n\tint ule_sndu_remain;\t\t\t \n\tunsigned long ts_count;\t\t\t \n\tstruct mutex mutex;\n};\n\n\n \nstatic __be16 dvb_net_eth_type_trans(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\tstruct ethhdr *eth;\n\tunsigned char *rawp;\n\n\tskb_reset_mac_header(skb);\n\tskb_pull(skb,dev->hard_header_len);\n\teth = eth_hdr(skb);\n\n\tif (*eth->h_dest & 1) {\n\t\tif(ether_addr_equal(eth->h_dest,dev->broadcast))\n\t\t\tskb->pkt_type=PACKET_BROADCAST;\n\t\telse\n\t\t\tskb->pkt_type=PACKET_MULTICAST;\n\t}\n\n\tif (ntohs(eth->h_proto) >= ETH_P_802_3_MIN)\n\t\treturn eth->h_proto;\n\n\trawp = skb->data;\n\n\t \n\tif (*(unsigned short *)rawp == 0xFFFF)\n\t\treturn htons(ETH_P_802_3);\n\n\t \n\treturn htons(ETH_P_802_2);\n}\n\n#define TS_SZ\t188\n#define TS_SYNC\t0x47\n#define TS_TEI\t0x80\n#define TS_SC\t0xC0\n#define TS_PUSI\t0x40\n#define TS_AF_A\t0x20\n#define TS_AF_D\t0x10\n\n \n\n#define ULE_TEST\t0\n#define ULE_BRIDGED\t1\n\n#define ULE_OPTEXTHDR_PADDING 0\n\nstatic int ule_test_sndu( struct dvb_net_priv *p )\n{\n\treturn -1;\n}\n\nstatic int ule_bridged_sndu( struct dvb_net_priv *p )\n{\n\tstruct ethhdr *hdr = (struct ethhdr*) p->ule_next_hdr;\n\tif(ntohs(hdr->h_proto) < ETH_P_802_3_MIN) {\n\t\tint framelen = p->ule_sndu_len - ((p->ule_next_hdr+sizeof(struct ethhdr)) - p->ule_skb->data);\n\t\t \n\t\tif(framelen != ntohs(hdr->h_proto)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t \n\tp->ule_bridged = 1;\n\treturn 0;\n}\n\nstatic int ule_exthdr_padding(struct dvb_net_priv *p)\n{\n\treturn 0;\n}\n\n \nstatic int handle_one_ule_extension( struct dvb_net_priv *p )\n{\n\t \n\tstatic int (*ule_mandatory_ext_handlers[255])( struct dvb_net_priv *p ) =\n\t\t{ [0] = ule_test_sndu, [1] = ule_bridged_sndu, [2] = NULL,  };\n\n\t \n\tstatic int (*ule_optional_ext_handlers[255])( struct dvb_net_priv *p ) =\n\t\t{ [0] = ule_exthdr_padding, [1] = NULL, };\n\n\tint ext_len = 0;\n\tunsigned char hlen = (p->ule_sndu_type & 0x0700) >> 8;\n\tunsigned char htype = p->ule_sndu_type & 0x00FF;\n\n\t \n\tif (hlen == 0) {\n\t\t \n\t\tif (ule_mandatory_ext_handlers[htype]) {\n\t\t\text_len = ule_mandatory_ext_handlers[htype]( p );\n\t\t\tif(ext_len >= 0) {\n\t\t\t\tp->ule_next_hdr += ext_len;\n\t\t\t\tif (!p->ule_bridged) {\n\t\t\t\t\tp->ule_sndu_type = ntohs(*(__be16 *)p->ule_next_hdr);\n\t\t\t\t\tp->ule_next_hdr += 2;\n\t\t\t\t} else {\n\t\t\t\t\tp->ule_sndu_type = ntohs(*(__be16 *)(p->ule_next_hdr + ((p->ule_dbit ? 2 : 3) * ETH_ALEN)));\n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} else\n\t\t\text_len = -1;\t \n\t} else {\n\t\t \n\t\text_len = hlen << 1;\n\t\t \n\t\tif (ule_optional_ext_handlers[htype])\n\t\t\t(void)ule_optional_ext_handlers[htype]( p );\n\t\tp->ule_next_hdr += ext_len;\n\t\tp->ule_sndu_type = ntohs( *(__be16 *)(p->ule_next_hdr-2) );\n\t\t \n\t}\n\n\treturn ext_len;\n}\n\nstatic int handle_ule_extensions( struct dvb_net_priv *p )\n{\n\tint total_ext_len = 0, l;\n\n\tp->ule_next_hdr = p->ule_skb->data;\n\tdo {\n\t\tl = handle_one_ule_extension( p );\n\t\tif (l < 0)\n\t\t\treturn l;\t \n\t\ttotal_ext_len += l;\n\t\tpr_debug(\"ule_next_hdr=%p, ule_sndu_type=%i, l=%i, total_ext_len=%i\\n\",\n\t\t\t p->ule_next_hdr, (int)p->ule_sndu_type,\n\t\t\t l, total_ext_len);\n\n\t} while (p->ule_sndu_type < ETH_P_802_3_MIN);\n\n\treturn total_ext_len;\n}\n\n\n \nstatic inline void reset_ule( struct dvb_net_priv *p )\n{\n\tp->ule_skb = NULL;\n\tp->ule_next_hdr = NULL;\n\tp->ule_sndu_len = 0;\n\tp->ule_sndu_type = 0;\n\tp->ule_sndu_type_1 = 0;\n\tp->ule_sndu_remain = 0;\n\tp->ule_dbit = 0xFF;\n\tp->ule_bridged = 0;\n}\n\n \n\nstruct dvb_net_ule_handle {\n\tstruct net_device *dev;\n\tstruct dvb_net_priv *priv;\n\tstruct ethhdr *ethh;\n\tconst u8 *buf;\n\tsize_t buf_len;\n\tunsigned long skipped;\n\tconst u8 *ts, *ts_end, *from_where;\n\tu8 ts_remain, how_much, new_ts;\n\tbool error;\n};\n\nstatic int dvb_net_ule_new_ts_cell(struct dvb_net_ule_handle *h)\n{\n\t \n\n#ifdef DVB_ULE_DEBUG\n\tif (ule_where >= &ule_hist[100*TS_SZ])\n\t\tule_where = ule_hist;\n\tmemcpy(ule_where, h->ts, TS_SZ);\n\tif (ule_dump) {\n\t\thexdump(ule_where, TS_SZ);\n\t\tule_dump = 0;\n\t}\n\tule_where += TS_SZ;\n#endif\n\n\t \n\tif ((h->ts[0] != TS_SYNC) || (h->ts[1] & TS_TEI) ||\n\t    ((h->ts[3] & TS_SC) != 0)) {\n\t\tpr_warn(\"%lu: Invalid TS cell: SYNC %#x, TEI %u, SC %#x.\\n\",\n\t\t\th->priv->ts_count, h->ts[0],\n\t\t\t(h->ts[1] & TS_TEI) >> 7,\n\t\t\t(h->ts[3] & TS_SC) >> 6);\n\n\t\t \n\t\tif (h->priv->ule_skb) {\n\t\t\tdev_kfree_skb(h->priv->ule_skb);\n\t\t\t \n\t\t\th->dev->stats.rx_errors++;\n\t\t\th->dev->stats.rx_frame_errors++;\n\t\t}\n\t\treset_ule(h->priv);\n\t\th->priv->need_pusi = 1;\n\n\t\t \n\t\th->ts += TS_SZ;\n\t\th->priv->ts_count++;\n\t\treturn 1;\n\t}\n\n\th->ts_remain = 184;\n\th->from_where = h->ts + 4;\n\n\treturn 0;\n}\n\nstatic int dvb_net_ule_ts_pusi(struct dvb_net_ule_handle *h)\n{\n\tif (h->ts[1] & TS_PUSI) {\n\t\t \n\t\t \n\t\th->priv->tscc = h->ts[3] & 0x0F;\n\t\t \n\t\tif (h->ts[4] > h->ts_remain) {\n\t\t\tpr_err(\"%lu: Invalid ULE packet (pointer field %d)\\n\",\n\t\t\t\th->priv->ts_count, h->ts[4]);\n\t\t\th->ts += TS_SZ;\n\t\t\th->priv->ts_count++;\n\t\t\treturn 1;\n\t\t}\n\t\t \n\t\th->from_where = &h->ts[5] + h->ts[4];\n\t\th->ts_remain -= 1 + h->ts[4];\n\t\th->skipped = 0;\n\t} else {\n\t\th->skipped++;\n\t\th->ts += TS_SZ;\n\t\th->priv->ts_count++;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int dvb_net_ule_new_ts(struct dvb_net_ule_handle *h)\n{\n\t \n\tif ((h->ts[3] & 0x0F) == h->priv->tscc)\n\t\th->priv->tscc = (h->priv->tscc + 1) & 0x0F;\n\telse {\n\t\t \n\t\tpr_warn(\"%lu: TS discontinuity: got %#x, expected %#x.\\n\",\n\t\t\th->priv->ts_count, h->ts[3] & 0x0F,\n\t\t\th->priv->tscc);\n\t\t \n\t\tif (h->priv->ule_skb) {\n\t\t\tdev_kfree_skb(h->priv->ule_skb);\n\t\t\t \n\t\t\t\n\t\t\th->dev->stats.rx_errors++;\n\t\t\th->dev->stats.rx_frame_errors++;\n\t\t}\n\t\treset_ule(h->priv);\n\t\t \n\t\th->priv->need_pusi = 1;\n\t\treturn 1;\n\t}\n\t \n\tif (h->ts[1] & TS_PUSI) {\n\t\tif (!h->priv->need_pusi) {\n\t\t\tif (!(*h->from_where < (h->ts_remain-1)) ||\n\t\t\t    *h->from_where != h->priv->ule_sndu_remain) {\n\t\t\t\t \n\t\t\t\tpr_warn(\"%lu: Invalid pointer field: %u.\\n\",\n\t\t\t\t\th->priv->ts_count,\n\t\t\t\t\t*h->from_where);\n\n\t\t\t\t \n\t\t\t\tif (h->priv->ule_skb) {\n\t\t\t\t\th->error = true;\n\t\t\t\t\tdev_kfree_skb(h->priv->ule_skb);\n\t\t\t\t}\n\n\t\t\t\tif (h->error || h->priv->ule_sndu_remain) {\n\t\t\t\t\th->dev->stats.rx_errors++;\n\t\t\t\t\th->dev->stats.rx_frame_errors++;\n\t\t\t\t\th->error = false;\n\t\t\t\t}\n\n\t\t\t\treset_ule(h->priv);\n\t\t\t\th->priv->need_pusi = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t \n\t\t\th->from_where += 1;\n\t\t\th->ts_remain -= 1;\n\t\t} else\n\t\t\th->priv->need_pusi = 0;\n\n\t\tif (h->priv->ule_sndu_remain > 183) {\n\t\t\t \n\t\t\th->dev->stats.rx_errors++;\n\t\t\th->dev->stats.rx_length_errors++;\n\t\t\tpr_warn(\"%lu: Expected %d more SNDU bytes, but got PUSI (pf %d, h->ts_remain %d).  Flushing incomplete payload.\\n\",\n\t\t\t\th->priv->ts_count,\n\t\t\t\th->priv->ule_sndu_remain,\n\t\t\t\th->ts[4], h->ts_remain);\n\t\t\tdev_kfree_skb(h->priv->ule_skb);\n\t\t\t \n\t\t\treset_ule(h->priv);\n\t\t\t \n\t\t\th->from_where += h->ts[4];\n\t\t\th->ts_remain -= h->ts[4];\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n \nstatic int dvb_net_ule_new_payload(struct dvb_net_ule_handle *h)\n{\n\tif (h->ts_remain < 2) {\n\t\tpr_warn(\"Invalid payload packing: only %d bytes left in TS.  Resyncing.\\n\",\n\t\t\th->ts_remain);\n\t\th->priv->ule_sndu_len = 0;\n\t\th->priv->need_pusi = 1;\n\t\th->ts += TS_SZ;\n\t\treturn 1;\n\t}\n\n\tif (!h->priv->ule_sndu_len) {\n\t\t \n\t\th->priv->ule_sndu_len = h->from_where[0] << 8 |\n\t\t\t\t\th->from_where[1];\n\t\tif (h->priv->ule_sndu_len & 0x8000) {\n\t\t\t \n\t\t\th->priv->ule_sndu_len &= 0x7FFF;\n\t\t\th->priv->ule_dbit = 1;\n\t\t} else\n\t\t\th->priv->ule_dbit = 0;\n\n\t\tif (h->priv->ule_sndu_len < 5) {\n\t\t\tpr_warn(\"%lu: Invalid ULE SNDU length %u. Resyncing.\\n\",\n\t\t\t\th->priv->ts_count,\n\t\t\t\th->priv->ule_sndu_len);\n\t\t\th->dev->stats.rx_errors++;\n\t\t\th->dev->stats.rx_length_errors++;\n\t\t\th->priv->ule_sndu_len = 0;\n\t\t\th->priv->need_pusi = 1;\n\t\t\th->new_ts = 1;\n\t\t\th->ts += TS_SZ;\n\t\t\th->priv->ts_count++;\n\t\t\treturn 1;\n\t\t}\n\t\th->ts_remain -= 2;\t \n\t\th->from_where += 2;\n\t}\n\n\th->priv->ule_sndu_remain = h->priv->ule_sndu_len + 2;\n\t \n\tswitch (h->ts_remain) {\n\tcase 1:\n\t\th->priv->ule_sndu_remain--;\n\t\th->priv->ule_sndu_type = h->from_where[0] << 8;\n\n\t\t \n\t\th->priv->ule_sndu_type_1 = 1;\n\t\th->ts_remain -= 1;\n\t\th->from_where += 1;\n\t\tfallthrough;\n\tcase 0:\n\t\th->new_ts = 1;\n\t\th->ts += TS_SZ;\n\t\th->priv->ts_count++;\n\t\treturn 1;\n\n\tdefault:  \n\t\t \n\t\tif (h->priv->ule_sndu_type_1) {\n\t\t\th->priv->ule_sndu_type_1 = 0;\n\t\t\th->priv->ule_sndu_type |= h->from_where[0];\n\t\t\th->from_where += 1;  \n\t\t\th->ts_remain -= 1;\n\t\t} else {\n\t\t\t \n\t\t\th->priv->ule_sndu_type = h->from_where[0] << 8 |\n\t\t\t\t\t\t h->from_where[1];\n\t\t\th->from_where += 2;  \n\t\t\th->ts_remain -= 2;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\th->priv->ule_skb = dev_alloc_skb(h->priv->ule_sndu_len +\n\t\t\t\t\t ETH_HLEN + ETH_ALEN);\n\tif (!h->priv->ule_skb) {\n\t\tpr_notice(\"%s: Memory squeeze, dropping packet.\\n\",\n\t\t\t  h->dev->name);\n\t\th->dev->stats.rx_dropped++;\n\t\treturn -1;\n\t}\n\n\t \n\th->priv->ule_sndu_remain = h->priv->ule_sndu_len;\n\th->priv->ule_skb->dev = h->dev;\n\t \n\tskb_reserve(h->priv->ule_skb, ETH_HLEN + ETH_ALEN);\n\n\treturn 0;\n}\n\n\nstatic int dvb_net_ule_should_drop(struct dvb_net_ule_handle *h)\n{\n\tstatic const u8 bc_addr[ETH_ALEN] = { [0 ... ETH_ALEN - 1] = 0xff };\n\n\t \n\tif (h->priv->rx_mode == RX_MODE_PROMISC)\n\t\treturn 0;\n\n\tif (h->priv->ule_skb->data[0] & 0x01) {\n\t\t \n\t\tif (!ether_addr_equal(h->priv->ule_skb->data, bc_addr)) {\n\t\t\t \n\t\t\tif (h->priv->rx_mode == RX_MODE_MULTI) {\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < h->priv->multi_num &&\n\t\t\t\t     !ether_addr_equal(h->priv->ule_skb->data,\n\t\t\t\t\t\t       h->priv->multi_macs[i]);\n\t\t\t\t     i++)\n\t\t\t\t\t;\n\t\t\t\tif (i == h->priv->multi_num)\n\t\t\t\t\treturn 1;\n\t\t\t} else if (h->priv->rx_mode != RX_MODE_ALL_MULTI)\n\t\t\t\treturn 1;  \n\t\t\t \n\t\t}\n\t\t \n\t} else if (!ether_addr_equal(h->priv->ule_skb->data, h->dev->dev_addr))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n\nstatic void dvb_net_ule_check_crc(struct dvb_net_ule_handle *h,\n\t\t\t\t  struct kvec iov[3],\n\t\t\t\t  u32 ule_crc, u32 expected_crc)\n{\n\tu8 dest_addr[ETH_ALEN];\n\n\tif (ule_crc != expected_crc) {\n\t\tpr_warn(\"%lu: CRC32 check FAILED: %08x / %08x, SNDU len %d type %#x, ts_remain %d, next 2: %x.\\n\",\n\t\t\th->priv->ts_count, ule_crc, expected_crc,\n\t\t\th->priv->ule_sndu_len, h->priv->ule_sndu_type,\n\t\t\th->ts_remain,\n\t\t\th->ts_remain > 2 ?\n\t\t\t\t*(unsigned short *)h->from_where : 0);\n\n\t#ifdef DVB_ULE_DEBUG\n\t\thexdump(iov[0].iov_base, iov[0].iov_len);\n\t\thexdump(iov[1].iov_base, iov[1].iov_len);\n\t\thexdump(iov[2].iov_base, iov[2].iov_len);\n\n\t\tif (ule_where == ule_hist) {\n\t\t\thexdump(&ule_hist[98*TS_SZ], TS_SZ);\n\t\t\thexdump(&ule_hist[99*TS_SZ], TS_SZ);\n\t\t} else if (ule_where == &ule_hist[TS_SZ]) {\n\t\t\thexdump(&ule_hist[99*TS_SZ], TS_SZ);\n\t\t\thexdump(ule_hist, TS_SZ);\n\t\t} else {\n\t\t\thexdump(ule_where - TS_SZ - TS_SZ, TS_SZ);\n\t\t\thexdump(ule_where - TS_SZ, TS_SZ);\n\t\t}\n\t\tule_dump = 1;\n\t#endif\n\n\t\th->dev->stats.rx_errors++;\n\t\th->dev->stats.rx_crc_errors++;\n\t\tdev_kfree_skb(h->priv->ule_skb);\n\n\t\treturn;\n\t}\n\n\t \n\n\t \n\th->priv->ule_skb->tail -= 4;\n\th->priv->ule_skb->len -= 4;\n\n\tif (!h->priv->ule_dbit) {\n\t\tif (dvb_net_ule_should_drop(h)) {\n\t\t\tnetdev_dbg(h->dev,\n\t\t\t\t   \"Dropping SNDU: MAC destination address does not match: dest addr: %pM, h->dev addr: %pM\\n\",\n\t\t\t\t   h->priv->ule_skb->data, h->dev->dev_addr);\n\t\t\tdev_kfree_skb(h->priv->ule_skb);\n\t\t\treturn;\n\t\t}\n\n\t\tskb_copy_from_linear_data(h->priv->ule_skb, dest_addr,\n\t\t\t\t\t  ETH_ALEN);\n\t\tskb_pull(h->priv->ule_skb, ETH_ALEN);\n\t} else {\n\t\t \n\t\teth_zero_addr(dest_addr);\n\t}\n\n\t \n\tif (h->priv->ule_sndu_type < ETH_P_802_3_MIN) {\n\t\t \n\t\tint l = handle_ule_extensions(h->priv);\n\n\t\tif (l < 0) {\n\t\t\t \n\n\t\t\t \n\t\t\tdev_kfree_skb(h->priv->ule_skb);\n\t\t\treturn;\n\t\t}\n\t\tskb_pull(h->priv->ule_skb, l);\n\t}\n\n\t \n\tif (!h->priv->ule_bridged) {\n\t\tskb_push(h->priv->ule_skb, ETH_HLEN);\n\t\th->ethh = (struct ethhdr *)h->priv->ule_skb->data;\n\t\tmemcpy(h->ethh->h_dest, dest_addr, ETH_ALEN);\n\t\teth_zero_addr(h->ethh->h_source);\n\t\th->ethh->h_proto = htons(h->priv->ule_sndu_type);\n\t}\n\t \n\th->priv->ule_bridged = 0;\n\n\t \n\th->priv->ule_skb->protocol = dvb_net_eth_type_trans(h->priv->ule_skb,\n\t\t\t\t\t\t\t   h->dev);\n\t \n#if 0\n\tif (h->priv->ule_dbit && skb->pkt_type == PACKET_OTHERHOST)\n\t\th->priv->ule_skb->pkt_type = PACKET_HOST;\n#endif\n\th->dev->stats.rx_packets++;\n\th->dev->stats.rx_bytes += h->priv->ule_skb->len;\n\tnetif_rx(h->priv->ule_skb);\n}\n\nstatic void dvb_net_ule(struct net_device *dev, const u8 *buf, size_t buf_len)\n{\n\tint ret;\n\tstruct dvb_net_ule_handle h = {\n\t\t.dev = dev,\n\t\t.priv = netdev_priv(dev),\n\t\t.ethh = NULL,\n\t\t.buf = buf,\n\t\t.buf_len = buf_len,\n\t\t.skipped = 0L,\n\t\t.ts = NULL,\n\t\t.ts_end = NULL,\n\t\t.from_where = NULL,\n\t\t.ts_remain = 0,\n\t\t.how_much = 0,\n\t\t.new_ts = 1,\n\t\t.error = false,\n\t};\n\n\t \n\tfor (h.ts = h.buf, h.ts_end = h.buf + h.buf_len;\n\t     h.ts < h.ts_end;  ) {\n\t\tif (h.new_ts) {\n\t\t\t \n\t\t\tif (dvb_net_ule_new_ts_cell(&h))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (h.priv->need_pusi) {\n\t\t\tif (dvb_net_ule_ts_pusi(&h))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (h.new_ts) {\n\t\t\tif (dvb_net_ule_new_ts(&h))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (h.priv->ule_skb == NULL) {\n\t\t\tret = dvb_net_ule_new_payload(&h);\n\t\t\tif (ret < 0)\n\t\t\t\treturn;\n\t\t\tif (ret)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\th.how_much = min(h.priv->ule_sndu_remain, (int)h.ts_remain);\n\t\tskb_put_data(h.priv->ule_skb, h.from_where, h.how_much);\n\t\th.priv->ule_sndu_remain -= h.how_much;\n\t\th.ts_remain -= h.how_much;\n\t\th.from_where += h.how_much;\n\n\t\t \n\t\tif (h.priv->ule_sndu_remain <= 0) {\n\t\t\t \n\t\t\t__be16 ulen = htons(h.priv->ule_sndu_len);\n\t\t\t__be16 utype = htons(h.priv->ule_sndu_type);\n\t\t\tconst u8 *tail;\n\t\t\tstruct kvec iov[3] = {\n\t\t\t\t{ &ulen, sizeof ulen },\n\t\t\t\t{ &utype, sizeof utype },\n\t\t\t\t{ h.priv->ule_skb->data,\n\t\t\t\t  h.priv->ule_skb->len - 4 }\n\t\t\t};\n\t\t\tu32 ule_crc = ~0L, expected_crc;\n\t\t\tif (h.priv->ule_dbit) {\n\t\t\t\t \n\t\t\t\tulen |= htons(0x8000);\n\t\t\t}\n\n\t\t\tule_crc = iov_crc32(ule_crc, iov, 3);\n\t\t\ttail = skb_tail_pointer(h.priv->ule_skb);\n\t\t\texpected_crc = *(tail - 4) << 24 |\n\t\t\t\t       *(tail - 3) << 16 |\n\t\t\t\t       *(tail - 2) << 8 |\n\t\t\t\t       *(tail - 1);\n\n\t\t\tdvb_net_ule_check_crc(&h, iov, ule_crc, expected_crc);\n\n\t\t\t \n\t\t\treset_ule(h.priv);\n\t\t}\n\n\t\t \n\t\tif (h.ts_remain >= 2 && *((unsigned short *)h.from_where) != 0xFFFF) {\n\t\t\t \n\t\t\th.new_ts = 0;\n\t\t\th.priv->ule_skb = NULL;\n\t\t\th.priv->ule_sndu_type_1 = 0;\n\t\t\th.priv->ule_sndu_len = 0;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t} else {\n\t\t\th.new_ts = 1;\n\t\t\th.ts += TS_SZ;\n\t\t\th.priv->ts_count++;\n\t\t\tif (h.priv->ule_skb == NULL) {\n\t\t\t\th.priv->need_pusi = 1;\n\t\t\t\th.priv->ule_sndu_type_1 = 0;\n\t\t\t\th.priv->ule_sndu_len = 0;\n\t\t\t}\n\t\t}\n\t}\t \n}\n\nstatic int dvb_net_ts_callback(const u8 *buffer1, size_t buffer1_len,\n\t\t\t       const u8 *buffer2, size_t buffer2_len,\n\t\t\t       struct dmx_ts_feed *feed,\n\t\t\t       u32 *buffer_flags)\n{\n\tstruct net_device *dev = feed->priv;\n\n\tif (buffer2)\n\t\tpr_warn(\"buffer2 not NULL: %p.\\n\", buffer2);\n\tif (buffer1_len > 32768)\n\t\tpr_warn(\"length > 32k: %zu.\\n\", buffer1_len);\n\t \n\tdvb_net_ule(dev, buffer1, buffer1_len);\n\treturn 0;\n}\n\n\nstatic void dvb_net_sec(struct net_device *dev,\n\t\t\tconst u8 *pkt, int pkt_len)\n{\n\tu8 *eth;\n\tstruct sk_buff *skb;\n\tstruct net_device_stats *stats = &dev->stats;\n\tint snap = 0;\n\n\t \n\tif (pkt_len < 16) {\n\t\tpr_warn(\"%s: IP/MPE packet length = %d too small.\\n\",\n\t\t\tdev->name, pkt_len);\n\t\tstats->rx_errors++;\n\t\tstats->rx_length_errors++;\n\t\treturn;\n\t}\n \n#if 0\n\tif ((pkt[5] & 0xfd) != 0xc1) {\n\t\t \n#else\n\tif ((pkt[5] & 0x3c) != 0x00) {\n\t\t \n#endif\n\t\tstats->rx_errors++;\n\t\tstats->rx_crc_errors++;\n\t\treturn;\n\t}\n\tif (pkt[5] & 0x02) {\n\t\t \n\t\tif (pkt_len < 24 || memcmp(&pkt[12], \"\\xaa\\xaa\\x03\\0\\0\\0\", 6)) {\n\t\t\tstats->rx_dropped++;\n\t\t\treturn;\n\t\t}\n\t\tsnap = 8;\n\t}\n\tif (pkt[7]) {\n\t\t \n\t\tstats->rx_errors++;\n\t\tstats->rx_frame_errors++;\n\t\treturn;\n\t}\n\n\t \n\tif (!(skb = dev_alloc_skb(pkt_len - 4 - 12 + 14 + 2 - snap))) {\n\t\t\n\t\tstats->rx_dropped++;\n\t\treturn;\n\t}\n\tskb_reserve(skb, 2);     \n\tskb->dev = dev;\n\n\t \n\teth = skb_put(skb, pkt_len - 12 - 4 + 14 - snap);\n\tmemcpy(eth + 14, pkt + 12 + snap, pkt_len - 12 - 4 - snap);\n\n\t \n\teth[0]=pkt[0x0b];\n\teth[1]=pkt[0x0a];\n\teth[2]=pkt[0x09];\n\teth[3]=pkt[0x08];\n\teth[4]=pkt[0x04];\n\teth[5]=pkt[0x03];\n\n\teth[6]=eth[7]=eth[8]=eth[9]=eth[10]=eth[11]=0;\n\n\tif (snap) {\n\t\teth[12] = pkt[18];\n\t\teth[13] = pkt[19];\n\t} else {\n\t\t \n\t\tif (pkt[12] >> 4 == 6) {  \n\t\t\teth[12] = 0x86;\t \n\t\t\teth[13] = 0xdd;\n\t\t} else {\n\t\t\teth[12] = 0x08;\t \n\t\t\teth[13] = 0x00;\n\t\t}\n\t}\n\n\tskb->protocol = dvb_net_eth_type_trans(skb, dev);\n\n\tstats->rx_packets++;\n\tstats->rx_bytes+=skb->len;\n\tnetif_rx(skb);\n}\n\nstatic int dvb_net_sec_callback(const u8 *buffer1, size_t buffer1_len,\n\t\t const u8 *buffer2, size_t buffer2_len,\n\t\t struct dmx_section_filter *filter, u32 *buffer_flags)\n{\n\tstruct net_device *dev = filter->priv;\n\n\t \n\tdvb_net_sec (dev, buffer1, buffer1_len);\n\treturn 0;\n}\n\nstatic netdev_tx_t dvb_net_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic u8 mask_normal[6]={0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\nstatic u8 mask_allmulti[6]={0xff, 0xff, 0xff, 0x00, 0x00, 0x00};\nstatic u8 mac_allmulti[6]={0x01, 0x00, 0x5e, 0x00, 0x00, 0x00};\nstatic u8 mask_promisc[6]={0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\nstatic int dvb_net_filter_sec_set(struct net_device *dev,\n\t\t   struct dmx_section_filter **secfilter,\n\t\t   const u8 *mac, u8 *mac_mask)\n{\n\tstruct dvb_net_priv *priv = netdev_priv(dev);\n\tint ret;\n\n\t*secfilter=NULL;\n\tret = priv->secfeed->allocate_filter(priv->secfeed, secfilter);\n\tif (ret<0) {\n\t\tpr_err(\"%s: could not get filter\\n\", dev->name);\n\t\treturn ret;\n\t}\n\n\t(*secfilter)->priv=(void *) dev;\n\n\tmemset((*secfilter)->filter_value, 0x00, DMX_MAX_FILTER_SIZE);\n\tmemset((*secfilter)->filter_mask,  0x00, DMX_MAX_FILTER_SIZE);\n\tmemset((*secfilter)->filter_mode,  0xff, DMX_MAX_FILTER_SIZE);\n\n\t(*secfilter)->filter_value[0]=0x3e;\n\t(*secfilter)->filter_value[3]=mac[5];\n\t(*secfilter)->filter_value[4]=mac[4];\n\t(*secfilter)->filter_value[8]=mac[3];\n\t(*secfilter)->filter_value[9]=mac[2];\n\t(*secfilter)->filter_value[10]=mac[1];\n\t(*secfilter)->filter_value[11]=mac[0];\n\n\t(*secfilter)->filter_mask[0] = 0xff;\n\t(*secfilter)->filter_mask[3] = mac_mask[5];\n\t(*secfilter)->filter_mask[4] = mac_mask[4];\n\t(*secfilter)->filter_mask[8] = mac_mask[3];\n\t(*secfilter)->filter_mask[9] = mac_mask[2];\n\t(*secfilter)->filter_mask[10] = mac_mask[1];\n\t(*secfilter)->filter_mask[11]=mac_mask[0];\n\n\tnetdev_dbg(dev, \"filter mac=%pM mask=%pM\\n\", mac, mac_mask);\n\n\treturn 0;\n}\n\nstatic int dvb_net_feed_start(struct net_device *dev)\n{\n\tint ret = 0, i;\n\tstruct dvb_net_priv *priv = netdev_priv(dev);\n\tstruct dmx_demux *demux = priv->demux;\n\tconst unsigned char *mac = (const unsigned char *) dev->dev_addr;\n\n\tnetdev_dbg(dev, \"rx_mode %i\\n\", priv->rx_mode);\n\tmutex_lock(&priv->mutex);\n\tif (priv->tsfeed || priv->secfeed || priv->secfilter || priv->multi_secfilter[0])\n\t\tpr_err(\"%s: BUG %d\\n\", __func__, __LINE__);\n\n\tpriv->secfeed=NULL;\n\tpriv->secfilter=NULL;\n\tpriv->tsfeed = NULL;\n\n\tif (priv->feedtype == DVB_NET_FEEDTYPE_MPE) {\n\t\tnetdev_dbg(dev, \"alloc secfeed\\n\");\n\t\tret=demux->allocate_section_feed(demux, &priv->secfeed,\n\t\t\t\t\t dvb_net_sec_callback);\n\t\tif (ret<0) {\n\t\t\tpr_err(\"%s: could not allocate section feed\\n\",\n\t\t\t       dev->name);\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = priv->secfeed->set(priv->secfeed, priv->pid, 1);\n\n\t\tif (ret<0) {\n\t\t\tpr_err(\"%s: could not set section feed\\n\", dev->name);\n\t\t\tpriv->demux->release_section_feed(priv->demux, priv->secfeed);\n\t\t\tpriv->secfeed=NULL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (priv->rx_mode != RX_MODE_PROMISC) {\n\t\t\tnetdev_dbg(dev, \"set secfilter\\n\");\n\t\t\tdvb_net_filter_sec_set(dev, &priv->secfilter, mac, mask_normal);\n\t\t}\n\n\t\tswitch (priv->rx_mode) {\n\t\tcase RX_MODE_MULTI:\n\t\t\tfor (i = 0; i < priv->multi_num; i++) {\n\t\t\t\tnetdev_dbg(dev, \"set multi_secfilter[%d]\\n\", i);\n\t\t\t\tdvb_net_filter_sec_set(dev, &priv->multi_secfilter[i],\n\t\t\t\t\t\t       priv->multi_macs[i], mask_normal);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RX_MODE_ALL_MULTI:\n\t\t\tpriv->multi_num=1;\n\t\t\tnetdev_dbg(dev, \"set multi_secfilter[0]\\n\");\n\t\t\tdvb_net_filter_sec_set(dev, &priv->multi_secfilter[0],\n\t\t\t\t\t       mac_allmulti, mask_allmulti);\n\t\t\tbreak;\n\t\tcase RX_MODE_PROMISC:\n\t\t\tpriv->multi_num=0;\n\t\t\tnetdev_dbg(dev, \"set secfilter\\n\");\n\t\t\tdvb_net_filter_sec_set(dev, &priv->secfilter, mac, mask_promisc);\n\t\t\tbreak;\n\t\t}\n\n\t\tnetdev_dbg(dev, \"start filtering\\n\");\n\t\tpriv->secfeed->start_filtering(priv->secfeed);\n\t} else if (priv->feedtype == DVB_NET_FEEDTYPE_ULE) {\n\t\tktime_t timeout = ns_to_ktime(10 * NSEC_PER_MSEC);\n\n\t\t \n\t\tnetdev_dbg(dev, \"alloc tsfeed\\n\");\n\t\tret = demux->allocate_ts_feed(demux, &priv->tsfeed, dvb_net_ts_callback);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"%s: could not allocate ts feed\\n\", dev->name);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tpriv->tsfeed->priv = (void *)dev;\n\t\tret = priv->tsfeed->set(priv->tsfeed,\n\t\t\t\t\tpriv->pid,  \n\t\t\t\t\tTS_PACKET,  \n\t\t\t\t\tDMX_PES_OTHER,  \n\t\t\t\t\ttimeout     \n\t\t\t\t\t);\n\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"%s: could not set ts feed\\n\", dev->name);\n\t\t\tpriv->demux->release_ts_feed(priv->demux, priv->tsfeed);\n\t\t\tpriv->tsfeed = NULL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tnetdev_dbg(dev, \"start filtering\\n\");\n\t\tpriv->tsfeed->start_filtering(priv->tsfeed);\n\t} else\n\t\tret = -EINVAL;\n\nerror:\n\tmutex_unlock(&priv->mutex);\n\treturn ret;\n}\n\nstatic int dvb_net_feed_stop(struct net_device *dev)\n{\n\tstruct dvb_net_priv *priv = netdev_priv(dev);\n\tint i, ret = 0;\n\n\tmutex_lock(&priv->mutex);\n\tif (priv->feedtype == DVB_NET_FEEDTYPE_MPE) {\n\t\tif (priv->secfeed) {\n\t\t\tif (priv->secfeed->is_filtering) {\n\t\t\t\tnetdev_dbg(dev, \"stop secfeed\\n\");\n\t\t\t\tpriv->secfeed->stop_filtering(priv->secfeed);\n\t\t\t}\n\n\t\t\tif (priv->secfilter) {\n\t\t\t\tnetdev_dbg(dev, \"release secfilter\\n\");\n\t\t\t\tpriv->secfeed->release_filter(priv->secfeed,\n\t\t\t\t\t\t\t      priv->secfilter);\n\t\t\t\tpriv->secfilter=NULL;\n\t\t\t}\n\n\t\t\tfor (i=0; i<priv->multi_num; i++) {\n\t\t\t\tif (priv->multi_secfilter[i]) {\n\t\t\t\t\tnetdev_dbg(dev, \"release multi_filter[%d]\\n\",\n\t\t\t\t\t\t   i);\n\t\t\t\t\tpriv->secfeed->release_filter(priv->secfeed,\n\t\t\t\t\t\t\t\t      priv->multi_secfilter[i]);\n\t\t\t\t\tpriv->multi_secfilter[i] = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpriv->demux->release_section_feed(priv->demux, priv->secfeed);\n\t\t\tpriv->secfeed = NULL;\n\t\t} else\n\t\t\tpr_err(\"%s: no feed to stop\\n\", dev->name);\n\t} else if (priv->feedtype == DVB_NET_FEEDTYPE_ULE) {\n\t\tif (priv->tsfeed) {\n\t\t\tif (priv->tsfeed->is_filtering) {\n\t\t\t\tnetdev_dbg(dev, \"stop tsfeed\\n\");\n\t\t\t\tpriv->tsfeed->stop_filtering(priv->tsfeed);\n\t\t\t}\n\t\t\tpriv->demux->release_ts_feed(priv->demux, priv->tsfeed);\n\t\t\tpriv->tsfeed = NULL;\n\t\t}\n\t\telse\n\t\t\tpr_err(\"%s: no ts feed to stop\\n\", dev->name);\n\t} else\n\t\tret = -EINVAL;\n\tmutex_unlock(&priv->mutex);\n\treturn ret;\n}\n\n\nstatic int dvb_set_mc_filter(struct net_device *dev, unsigned char *addr)\n{\n\tstruct dvb_net_priv *priv = netdev_priv(dev);\n\n\tif (priv->multi_num == DVB_NET_MULTICAST_MAX)\n\t\treturn -ENOMEM;\n\n\tmemcpy(priv->multi_macs[priv->multi_num], addr, ETH_ALEN);\n\n\tpriv->multi_num++;\n\treturn 0;\n}\n\n\nstatic void wq_set_multicast_list (struct work_struct *work)\n{\n\tstruct dvb_net_priv *priv =\n\t\tcontainer_of(work, struct dvb_net_priv, set_multicast_list_wq);\n\tstruct net_device *dev = priv->net;\n\n\tdvb_net_feed_stop(dev);\n\tpriv->rx_mode = RX_MODE_UNI;\n\tnetif_addr_lock_bh(dev);\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tnetdev_dbg(dev, \"promiscuous mode\\n\");\n\t\tpriv->rx_mode = RX_MODE_PROMISC;\n\t} else if ((dev->flags & IFF_ALLMULTI)) {\n\t\tnetdev_dbg(dev, \"allmulti mode\\n\");\n\t\tpriv->rx_mode = RX_MODE_ALL_MULTI;\n\t} else if (!netdev_mc_empty(dev)) {\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tnetdev_dbg(dev, \"set_mc_list, %d entries\\n\",\n\t\t\t   netdev_mc_count(dev));\n\n\t\tpriv->rx_mode = RX_MODE_MULTI;\n\t\tpriv->multi_num = 0;\n\n\t\tnetdev_for_each_mc_addr(ha, dev)\n\t\t\tdvb_set_mc_filter(dev, ha->addr);\n\t}\n\n\tnetif_addr_unlock_bh(dev);\n\tdvb_net_feed_start(dev);\n}\n\n\nstatic void dvb_net_set_multicast_list (struct net_device *dev)\n{\n\tstruct dvb_net_priv *priv = netdev_priv(dev);\n\tschedule_work(&priv->set_multicast_list_wq);\n}\n\n\nstatic void wq_restart_net_feed (struct work_struct *work)\n{\n\tstruct dvb_net_priv *priv =\n\t\tcontainer_of(work, struct dvb_net_priv, restart_net_feed_wq);\n\tstruct net_device *dev = priv->net;\n\n\tif (netif_running(dev)) {\n\t\tdvb_net_feed_stop(dev);\n\t\tdvb_net_feed_start(dev);\n\t}\n}\n\n\nstatic int dvb_net_set_mac (struct net_device *dev, void *p)\n{\n\tstruct dvb_net_priv *priv = netdev_priv(dev);\n\tstruct sockaddr *addr=p;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\n\tif (netif_running(dev))\n\t\tschedule_work(&priv->restart_net_feed_wq);\n\n\treturn 0;\n}\n\n\nstatic int dvb_net_open(struct net_device *dev)\n{\n\tstruct dvb_net_priv *priv = netdev_priv(dev);\n\n\tpriv->in_use++;\n\tdvb_net_feed_start(dev);\n\treturn 0;\n}\n\n\nstatic int dvb_net_stop(struct net_device *dev)\n{\n\tstruct dvb_net_priv *priv = netdev_priv(dev);\n\n\tpriv->in_use--;\n\treturn dvb_net_feed_stop(dev);\n}\n\nstatic const struct header_ops dvb_header_ops = {\n\t.create\t\t= eth_header,\n\t.parse\t\t= eth_header_parse,\n};\n\n\nstatic const struct net_device_ops dvb_netdev_ops = {\n\t.ndo_open\t\t= dvb_net_open,\n\t.ndo_stop\t\t= dvb_net_stop,\n\t.ndo_start_xmit\t\t= dvb_net_tx,\n\t.ndo_set_rx_mode\t= dvb_net_set_multicast_list,\n\t.ndo_set_mac_address    = dvb_net_set_mac,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic void dvb_net_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\tdev->header_ops\t\t= &dvb_header_ops;\n\tdev->netdev_ops\t\t= &dvb_netdev_ops;\n\tdev->mtu\t\t= 4096;\n\tdev->max_mtu\t\t= 4096;\n\n\tdev->flags |= IFF_NOARP;\n}\n\nstatic int get_if(struct dvb_net *dvbnet)\n{\n\tint i;\n\n\tfor (i=0; i<DVB_NET_DEVICES_MAX; i++)\n\t\tif (!dvbnet->state[i])\n\t\t\tbreak;\n\n\tif (i == DVB_NET_DEVICES_MAX)\n\t\treturn -1;\n\n\tdvbnet->state[i]=1;\n\treturn i;\n}\n\nstatic int dvb_net_add_if(struct dvb_net *dvbnet, u16 pid, u8 feedtype)\n{\n\tstruct net_device *net;\n\tstruct dvb_net_priv *priv;\n\tint result;\n\tint if_num;\n\n\tif (feedtype != DVB_NET_FEEDTYPE_MPE && feedtype != DVB_NET_FEEDTYPE_ULE)\n\t\treturn -EINVAL;\n\tif ((if_num = get_if(dvbnet)) < 0)\n\t\treturn -EINVAL;\n\n\tnet = alloc_netdev(sizeof(struct dvb_net_priv), \"dvb\",\n\t\t\t   NET_NAME_UNKNOWN, dvb_net_setup);\n\tif (!net)\n\t\treturn -ENOMEM;\n\n\tif (dvbnet->dvbdev->id)\n\t\tsnprintf(net->name, IFNAMSIZ, \"dvb%d%u%d\",\n\t\t\t dvbnet->dvbdev->adapter->num, dvbnet->dvbdev->id, if_num);\n\telse\n\t\t \n\t\tsnprintf(net->name, IFNAMSIZ, \"dvb%d_%d\",\n\t\t\t dvbnet->dvbdev->adapter->num, if_num);\n\n\tnet->addr_len = 6;\n\teth_hw_addr_set(net, dvbnet->dvbdev->adapter->proposed_mac);\n\n\tdvbnet->device[if_num] = net;\n\n\tpriv = netdev_priv(net);\n\tpriv->net = net;\n\tpriv->demux = dvbnet->demux;\n\tpriv->pid = pid;\n\tpriv->rx_mode = RX_MODE_UNI;\n\tpriv->need_pusi = 1;\n\tpriv->tscc = 0;\n\tpriv->feedtype = feedtype;\n\treset_ule(priv);\n\n\tINIT_WORK(&priv->set_multicast_list_wq, wq_set_multicast_list);\n\tINIT_WORK(&priv->restart_net_feed_wq, wq_restart_net_feed);\n\tmutex_init(&priv->mutex);\n\n\tnet->base_addr = pid;\n\n\tif ((result = register_netdev(net)) < 0) {\n\t\tdvbnet->device[if_num] = NULL;\n\t\tfree_netdev(net);\n\t\treturn result;\n\t}\n\tpr_info(\"created network interface %s\\n\", net->name);\n\n\treturn if_num;\n}\n\nstatic int dvb_net_remove_if(struct dvb_net *dvbnet, unsigned long num)\n{\n\tstruct net_device *net = dvbnet->device[num];\n\tstruct dvb_net_priv *priv;\n\n\tif (!dvbnet->state[num])\n\t\treturn -EINVAL;\n\tpriv = netdev_priv(net);\n\tif (priv->in_use)\n\t\treturn -EBUSY;\n\n\tdvb_net_stop(net);\n\tflush_work(&priv->set_multicast_list_wq);\n\tflush_work(&priv->restart_net_feed_wq);\n\tpr_info(\"removed network interface %s\\n\", net->name);\n\tunregister_netdev(net);\n\tdvbnet->state[num]=0;\n\tdvbnet->device[num] = NULL;\n\tfree_netdev(net);\n\n\treturn 0;\n}\n\nstatic int dvb_net_do_ioctl(struct file *file,\n\t\t  unsigned int cmd, void *parg)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dvb_net *dvbnet = dvbdev->priv;\n\tint ret = 0;\n\n\tif (((file->f_flags&O_ACCMODE)==O_RDONLY))\n\t\treturn -EPERM;\n\n\tif (mutex_lock_interruptible(&dvbnet->ioctl_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase NET_ADD_IF:\n\t{\n\t\tstruct dvb_net_if *dvbnetif = parg;\n\t\tint result;\n\n\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto ioctl_error;\n\t\t}\n\n\t\tif (!try_module_get(dvbdev->adapter->module)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto ioctl_error;\n\t\t}\n\n\t\tresult=dvb_net_add_if(dvbnet, dvbnetif->pid, dvbnetif->feedtype);\n\t\tif (result<0) {\n\t\t\tmodule_put(dvbdev->adapter->module);\n\t\t\tret = result;\n\t\t\tgoto ioctl_error;\n\t\t}\n\t\tdvbnetif->if_num=result;\n\t\tbreak;\n\t}\n\tcase NET_GET_IF:\n\t{\n\t\tstruct net_device *netdev;\n\t\tstruct dvb_net_priv *priv_data;\n\t\tstruct dvb_net_if *dvbnetif = parg;\n\t\tint if_num = dvbnetif->if_num;\n\n\t\tif (if_num >= DVB_NET_DEVICES_MAX) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto ioctl_error;\n\t\t}\n\t\tif_num = array_index_nospec(if_num, DVB_NET_DEVICES_MAX);\n\n\t\tif (!dvbnet->state[if_num]) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto ioctl_error;\n\t\t}\n\n\t\tnetdev = dvbnet->device[if_num];\n\n\t\tpriv_data = netdev_priv(netdev);\n\t\tdvbnetif->pid=priv_data->pid;\n\t\tdvbnetif->feedtype=priv_data->feedtype;\n\t\tbreak;\n\t}\n\tcase NET_REMOVE_IF:\n\t{\n\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto ioctl_error;\n\t\t}\n\t\tif ((unsigned long) parg >= DVB_NET_DEVICES_MAX) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto ioctl_error;\n\t\t}\n\t\tret = dvb_net_remove_if(dvbnet, (unsigned long) parg);\n\t\tif (!ret)\n\t\t\tmodule_put(dvbdev->adapter->module);\n\t\tbreak;\n\t}\n\n\t \n\tcase __NET_ADD_IF_OLD:\n\t{\n\t\tstruct __dvb_net_if_old *dvbnetif = parg;\n\t\tint result;\n\n\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto ioctl_error;\n\t\t}\n\n\t\tif (!try_module_get(dvbdev->adapter->module)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto ioctl_error;\n\t\t}\n\n\t\tresult=dvb_net_add_if(dvbnet, dvbnetif->pid, DVB_NET_FEEDTYPE_MPE);\n\t\tif (result<0) {\n\t\t\tmodule_put(dvbdev->adapter->module);\n\t\t\tret = result;\n\t\t\tgoto ioctl_error;\n\t\t}\n\t\tdvbnetif->if_num=result;\n\t\tbreak;\n\t}\n\tcase __NET_GET_IF_OLD:\n\t{\n\t\tstruct net_device *netdev;\n\t\tstruct dvb_net_priv *priv_data;\n\t\tstruct __dvb_net_if_old *dvbnetif = parg;\n\t\tint if_num = dvbnetif->if_num;\n\n\t\tif (if_num >= DVB_NET_DEVICES_MAX) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto ioctl_error;\n\t\t}\n\t\tif_num = array_index_nospec(if_num, DVB_NET_DEVICES_MAX);\n\n\t\tif (!dvbnet->state[if_num]) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto ioctl_error;\n\t\t}\n\n\t\tnetdev = dvbnet->device[if_num];\n\n\t\tpriv_data = netdev_priv(netdev);\n\t\tdvbnetif->pid=priv_data->pid;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tret = -ENOTTY;\n\t\tbreak;\n\t}\n\nioctl_error:\n\tmutex_unlock(&dvbnet->ioctl_mutex);\n\treturn ret;\n}\n\nstatic long dvb_net_ioctl(struct file *file,\n\t      unsigned int cmd, unsigned long arg)\n{\n\treturn dvb_usercopy(file, cmd, arg, dvb_net_do_ioctl);\n}\n\nstatic int locked_dvb_net_open(struct inode *inode, struct file *file)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dvb_net *dvbnet = dvbdev->priv;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&dvbnet->remove_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (dvbnet->exit) {\n\t\tmutex_unlock(&dvbnet->remove_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tret = dvb_generic_open(inode, file);\n\n\tmutex_unlock(&dvbnet->remove_mutex);\n\n\treturn ret;\n}\n\nstatic int dvb_net_close(struct inode *inode, struct file *file)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dvb_net *dvbnet = dvbdev->priv;\n\n\tmutex_lock(&dvbnet->remove_mutex);\n\n\tdvb_generic_release(inode, file);\n\n\tif (dvbdev->users == 1 && dvbnet->exit == 1) {\n\t\tmutex_unlock(&dvbnet->remove_mutex);\n\t\twake_up(&dvbdev->wait_queue);\n\t} else {\n\t\tmutex_unlock(&dvbnet->remove_mutex);\n\t}\n\n\treturn 0;\n}\n\n\nstatic const struct file_operations dvb_net_fops = {\n\t.owner = THIS_MODULE,\n\t.unlocked_ioctl = dvb_net_ioctl,\n\t.open =\tlocked_dvb_net_open,\n\t.release = dvb_net_close,\n\t.llseek = noop_llseek,\n};\n\nstatic const struct dvb_device dvbdev_net = {\n\t.priv = NULL,\n\t.users = 1,\n\t.writers = 1,\n#if defined(CONFIG_MEDIA_CONTROLLER_DVB)\n\t.name = \"dvb-net\",\n#endif\n\t.fops = &dvb_net_fops,\n};\n\nvoid dvb_net_release (struct dvb_net *dvbnet)\n{\n\tint i;\n\n\tmutex_lock(&dvbnet->remove_mutex);\n\tdvbnet->exit = 1;\n\tmutex_unlock(&dvbnet->remove_mutex);\n\n\tif (dvbnet->dvbdev->users < 1)\n\t\twait_event(dvbnet->dvbdev->wait_queue,\n\t\t\t\tdvbnet->dvbdev->users == 1);\n\n\tdvb_unregister_device(dvbnet->dvbdev);\n\n\tfor (i=0; i<DVB_NET_DEVICES_MAX; i++) {\n\t\tif (!dvbnet->state[i])\n\t\t\tcontinue;\n\t\tdvb_net_remove_if(dvbnet, i);\n\t}\n}\nEXPORT_SYMBOL(dvb_net_release);\n\n\nint dvb_net_init (struct dvb_adapter *adap, struct dvb_net *dvbnet,\n\t\t  struct dmx_demux *dmx)\n{\n\tint i;\n\n\tmutex_init(&dvbnet->ioctl_mutex);\n\tmutex_init(&dvbnet->remove_mutex);\n\tdvbnet->demux = dmx;\n\n\tfor (i=0; i<DVB_NET_DEVICES_MAX; i++)\n\t\tdvbnet->state[i] = 0;\n\n\treturn dvb_register_device(adap, &dvbnet->dvbdev, &dvbdev_net,\n\t\t\t     dvbnet, DVB_DEVICE_NET, 0);\n}\nEXPORT_SYMBOL(dvb_net_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}