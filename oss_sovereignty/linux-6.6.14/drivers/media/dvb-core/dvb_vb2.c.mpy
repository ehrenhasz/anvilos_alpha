{
  "module_name": "dvb_vb2.c",
  "hash_id": "0f0882aa0d74b9cd84efab2251d79fb16b2ec7e784df48a05d67c5c28880fb8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-core/dvb_vb2.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n\n#include <media/dvbdev.h>\n#include <media/dvb_vb2.h>\n\n#define DVB_V2_MAX_SIZE\t\t(4096 * 188)\n\nstatic int vb2_debug;\nmodule_param(vb2_debug, int, 0644);\n\n#define dprintk(level, fmt, arg...)\t\t\t\t\t      \\\n\tdo {\t\t\t\t\t\t\t\t      \\\n\t\tif (vb2_debug >= level)\t\t\t\t\t      \\\n\t\t\tpr_info(\"vb2: %s: \" fmt, __func__, ## arg); \\\n\t} while (0)\n\nstatic int _queue_setup(struct vb2_queue *vq,\n\t\t\tunsigned int *nbuffers, unsigned int *nplanes,\n\t\t\tunsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct dvb_vb2_ctx *ctx = vb2_get_drv_priv(vq);\n\n\tctx->buf_cnt = *nbuffers;\n\t*nplanes = 1;\n\tsizes[0] = ctx->buf_siz;\n\n\t \n\n\tdprintk(3, \"[%s] count=%d, size=%d\\n\", ctx->name,\n\t\t*nbuffers, sizes[0]);\n\n\treturn 0;\n}\n\nstatic int _buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct dvb_vb2_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned long size = ctx->buf_siz;\n\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tdprintk(1, \"[%s] data will not fit into plane (%lu < %lu)\\n\",\n\t\t\tctx->name, vb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, size);\n\tdprintk(3, \"[%s]\\n\", ctx->name);\n\n\treturn 0;\n}\n\nstatic void _buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct dvb_vb2_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct dvb_buffer *buf = container_of(vb, struct dvb_buffer, vb);\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&ctx->slock, flags);\n\tlist_add_tail(&buf->list, &ctx->dvb_q);\n\tspin_unlock_irqrestore(&ctx->slock, flags);\n\n\tdprintk(3, \"[%s]\\n\", ctx->name);\n}\n\nstatic int _start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct dvb_vb2_ctx *ctx = vb2_get_drv_priv(vq);\n\n\tdprintk(3, \"[%s] count=%d\\n\", ctx->name, count);\n\treturn 0;\n}\n\nstatic void _stop_streaming(struct vb2_queue *vq)\n{\n\tstruct dvb_vb2_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct dvb_buffer *buf;\n\tunsigned long flags = 0;\n\n\tdprintk(3, \"[%s]\\n\", ctx->name);\n\n\tspin_lock_irqsave(&ctx->slock, flags);\n\twhile (!list_empty(&ctx->dvb_q)) {\n\t\tbuf = list_entry(ctx->dvb_q.next,\n\t\t\t\t struct dvb_buffer, list);\n\t\tvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\n\t\tlist_del(&buf->list);\n\t}\n\tspin_unlock_irqrestore(&ctx->slock, flags);\n}\n\nstatic void _dmxdev_lock(struct vb2_queue *vq)\n{\n\tstruct dvb_vb2_ctx *ctx = vb2_get_drv_priv(vq);\n\n\tmutex_lock(&ctx->mutex);\n\tdprintk(3, \"[%s]\\n\", ctx->name);\n}\n\nstatic void _dmxdev_unlock(struct vb2_queue *vq)\n{\n\tstruct dvb_vb2_ctx *ctx = vb2_get_drv_priv(vq);\n\n\tif (mutex_is_locked(&ctx->mutex))\n\t\tmutex_unlock(&ctx->mutex);\n\tdprintk(3, \"[%s]\\n\", ctx->name);\n}\n\nstatic const struct vb2_ops dvb_vb2_qops = {\n\t.queue_setup\t\t= _queue_setup,\n\t.buf_prepare\t\t= _buffer_prepare,\n\t.buf_queue\t\t= _buffer_queue,\n\t.start_streaming\t= _start_streaming,\n\t.stop_streaming\t\t= _stop_streaming,\n\t.wait_prepare\t\t= _dmxdev_unlock,\n\t.wait_finish\t\t= _dmxdev_lock,\n};\n\nstatic void _fill_dmx_buffer(struct vb2_buffer *vb, void *pb)\n{\n\tstruct dvb_vb2_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct dmx_buffer *b = pb;\n\n\tb->index = vb->index;\n\tb->length = vb->planes[0].length;\n\tb->bytesused = vb->planes[0].bytesused;\n\tb->offset = vb->planes[0].m.offset;\n\tdprintk(3, \"[%s]\\n\", ctx->name);\n}\n\nstatic int _fill_vb2_buffer(struct vb2_buffer *vb, struct vb2_plane *planes)\n{\n\tstruct dvb_vb2_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tplanes[0].bytesused = 0;\n\tdprintk(3, \"[%s]\\n\", ctx->name);\n\n\treturn 0;\n}\n\nstatic const struct vb2_buf_ops dvb_vb2_buf_ops = {\n\t.fill_user_buffer\t= _fill_dmx_buffer,\n\t.fill_vb2_buffer\t= _fill_vb2_buffer,\n};\n\n \nint dvb_vb2_init(struct dvb_vb2_ctx *ctx, const char *name, int nonblocking)\n{\n\tstruct vb2_queue *q = &ctx->vb_q;\n\tint ret;\n\n\tmemset(ctx, 0, sizeof(struct dvb_vb2_ctx));\n\tq->type = DVB_BUF_TYPE_CAPTURE;\n\t \n\tq->is_output = 0;\n\t \n\tq->io_modes = VB2_MMAP;\n\tq->drv_priv = ctx;\n\tq->buf_struct_size = sizeof(struct dvb_buffer);\n\tq->min_buffers_needed = 1;\n\tq->ops = &dvb_vb2_qops;\n\tq->mem_ops = &vb2_vmalloc_memops;\n\tq->buf_ops = &dvb_vb2_buf_ops;\n\tq->num_buffers = 0;\n\tret = vb2_core_queue_init(q);\n\tif (ret) {\n\t\tctx->state = DVB_VB2_STATE_NONE;\n\t\tdprintk(1, \"[%s] errno=%d\\n\", ctx->name, ret);\n\t\treturn ret;\n\t}\n\n\tmutex_init(&ctx->mutex);\n\tspin_lock_init(&ctx->slock);\n\tINIT_LIST_HEAD(&ctx->dvb_q);\n\n\tstrscpy(ctx->name, name, DVB_VB2_NAME_MAX);\n\tctx->nonblocking = nonblocking;\n\tctx->state = DVB_VB2_STATE_INIT;\n\n\tdprintk(3, \"[%s]\\n\", ctx->name);\n\n\treturn 0;\n}\n\nint dvb_vb2_release(struct dvb_vb2_ctx *ctx)\n{\n\tstruct vb2_queue *q = (struct vb2_queue *)&ctx->vb_q;\n\n\tif (ctx->state & DVB_VB2_STATE_INIT)\n\t\tvb2_core_queue_release(q);\n\n\tctx->state = DVB_VB2_STATE_NONE;\n\tdprintk(3, \"[%s]\\n\", ctx->name);\n\n\treturn 0;\n}\n\nint dvb_vb2_stream_on(struct dvb_vb2_ctx *ctx)\n{\n\tstruct vb2_queue *q = &ctx->vb_q;\n\tint ret;\n\n\tret = vb2_core_streamon(q, q->type);\n\tif (ret) {\n\t\tctx->state = DVB_VB2_STATE_NONE;\n\t\tdprintk(1, \"[%s] errno=%d\\n\", ctx->name, ret);\n\t\treturn ret;\n\t}\n\tctx->state |= DVB_VB2_STATE_STREAMON;\n\tdprintk(3, \"[%s]\\n\", ctx->name);\n\n\treturn 0;\n}\n\nint dvb_vb2_stream_off(struct dvb_vb2_ctx *ctx)\n{\n\tstruct vb2_queue *q = (struct vb2_queue *)&ctx->vb_q;\n\tint ret;\n\n\tctx->state &= ~DVB_VB2_STATE_STREAMON;\n\tret = vb2_core_streamoff(q, q->type);\n\tif (ret) {\n\t\tctx->state = DVB_VB2_STATE_NONE;\n\t\tdprintk(1, \"[%s] errno=%d\\n\", ctx->name, ret);\n\t\treturn ret;\n\t}\n\tdprintk(3, \"[%s]\\n\", ctx->name);\n\n\treturn 0;\n}\n\nint dvb_vb2_is_streaming(struct dvb_vb2_ctx *ctx)\n{\n\treturn (ctx->state & DVB_VB2_STATE_STREAMON);\n}\n\nint dvb_vb2_fill_buffer(struct dvb_vb2_ctx *ctx,\n\t\t\tconst unsigned char *src, int len,\n\t\t\tenum dmx_buffer_flags *buffer_flags)\n{\n\tunsigned long flags = 0;\n\tvoid *vbuf = NULL;\n\tint todo = len;\n\tunsigned char *psrc = (unsigned char *)src;\n\tint ll = 0;\n\n\t \n\tif (!src || !len)\n\t\treturn 0;\n\tspin_lock_irqsave(&ctx->slock, flags);\n\tif (buffer_flags && *buffer_flags) {\n\t\tctx->flags |= *buffer_flags;\n\t\t*buffer_flags = 0;\n\t}\n\twhile (todo) {\n\t\tif (!ctx->buf) {\n\t\t\tif (list_empty(&ctx->dvb_q)) {\n\t\t\t\tdprintk(3, \"[%s] Buffer overflow!!!\\n\",\n\t\t\t\t\tctx->name);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tctx->buf = list_entry(ctx->dvb_q.next,\n\t\t\t\t\t      struct dvb_buffer, list);\n\t\t\tctx->remain = vb2_plane_size(&ctx->buf->vb, 0);\n\t\t\tctx->offset = 0;\n\t\t}\n\n\t\tif (!dvb_vb2_is_streaming(ctx)) {\n\t\t\tvb2_buffer_done(&ctx->buf->vb, VB2_BUF_STATE_ERROR);\n\t\t\tlist_del(&ctx->buf->list);\n\t\t\tctx->buf = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tll = min(todo, ctx->remain);\n\t\tvbuf = vb2_plane_vaddr(&ctx->buf->vb, 0);\n\t\tmemcpy(vbuf + ctx->offset, psrc, ll);\n\t\ttodo -= ll;\n\t\tpsrc += ll;\n\n\t\tctx->remain -= ll;\n\t\tctx->offset += ll;\n\n\t\tif (ctx->remain == 0) {\n\t\t\tvb2_buffer_done(&ctx->buf->vb, VB2_BUF_STATE_DONE);\n\t\t\tlist_del(&ctx->buf->list);\n\t\t\tctx->buf = NULL;\n\t\t}\n\t}\n\n\tif (ctx->nonblocking && ctx->buf) {\n\t\tvb2_set_plane_payload(&ctx->buf->vb, 0, ll);\n\t\tvb2_buffer_done(&ctx->buf->vb, VB2_BUF_STATE_DONE);\n\t\tlist_del(&ctx->buf->list);\n\t\tctx->buf = NULL;\n\t}\n\tspin_unlock_irqrestore(&ctx->slock, flags);\n\n\tif (todo)\n\t\tdprintk(1, \"[%s] %d bytes are dropped.\\n\", ctx->name, todo);\n\telse\n\t\tdprintk(3, \"[%s]\\n\", ctx->name);\n\n\tdprintk(3, \"[%s] %d bytes are copied\\n\", ctx->name, len - todo);\n\treturn (len - todo);\n}\n\nint dvb_vb2_reqbufs(struct dvb_vb2_ctx *ctx, struct dmx_requestbuffers *req)\n{\n\tint ret;\n\n\t \n\tif (req->size > DVB_V2_MAX_SIZE)\n\t\treq->size = DVB_V2_MAX_SIZE;\n\n\t \n\n\tctx->buf_siz = req->size;\n\tctx->buf_cnt = req->count;\n\tret = vb2_core_reqbufs(&ctx->vb_q, VB2_MEMORY_MMAP, 0, &req->count);\n\tif (ret) {\n\t\tctx->state = DVB_VB2_STATE_NONE;\n\t\tdprintk(1, \"[%s] count=%d size=%d errno=%d\\n\", ctx->name,\n\t\t\tctx->buf_cnt, ctx->buf_siz, ret);\n\t\treturn ret;\n\t}\n\tctx->state |= DVB_VB2_STATE_REQBUFS;\n\tdprintk(3, \"[%s] count=%d size=%d\\n\", ctx->name,\n\t\tctx->buf_cnt, ctx->buf_siz);\n\n\treturn 0;\n}\n\nint dvb_vb2_querybuf(struct dvb_vb2_ctx *ctx, struct dmx_buffer *b)\n{\n\tstruct vb2_queue *q = &ctx->vb_q;\n\n\tif (b->index >= q->num_buffers) {\n\t\tdprintk(1, \"[%s] buffer index out of range\\n\", ctx->name);\n\t\treturn -EINVAL;\n\t}\n\tvb2_core_querybuf(&ctx->vb_q, b->index, b);\n\tdprintk(3, \"[%s] index=%d\\n\", ctx->name, b->index);\n\treturn 0;\n}\n\nint dvb_vb2_expbuf(struct dvb_vb2_ctx *ctx, struct dmx_exportbuffer *exp)\n{\n\tstruct vb2_queue *q = &ctx->vb_q;\n\tint ret;\n\n\tret = vb2_core_expbuf(&ctx->vb_q, &exp->fd, q->type, exp->index,\n\t\t\t      0, exp->flags);\n\tif (ret) {\n\t\tdprintk(1, \"[%s] index=%d errno=%d\\n\", ctx->name,\n\t\t\texp->index, ret);\n\t\treturn ret;\n\t}\n\tdprintk(3, \"[%s] index=%d fd=%d\\n\", ctx->name, exp->index, exp->fd);\n\n\treturn 0;\n}\n\nint dvb_vb2_qbuf(struct dvb_vb2_ctx *ctx, struct dmx_buffer *b)\n{\n\tstruct vb2_queue *q = &ctx->vb_q;\n\tint ret;\n\n\tif (b->index >= q->num_buffers) {\n\t\tdprintk(1, \"[%s] buffer index out of range\\n\", ctx->name);\n\t\treturn -EINVAL;\n\t}\n\tret = vb2_core_qbuf(&ctx->vb_q, b->index, b, NULL);\n\tif (ret) {\n\t\tdprintk(1, \"[%s] index=%d errno=%d\\n\", ctx->name,\n\t\t\tb->index, ret);\n\t\treturn ret;\n\t}\n\tdprintk(5, \"[%s] index=%d\\n\", ctx->name, b->index);\n\n\treturn 0;\n}\n\nint dvb_vb2_dqbuf(struct dvb_vb2_ctx *ctx, struct dmx_buffer *b)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tret = vb2_core_dqbuf(&ctx->vb_q, &b->index, b, ctx->nonblocking);\n\tif (ret) {\n\t\tdprintk(1, \"[%s] errno=%d\\n\", ctx->name, ret);\n\t\treturn ret;\n\t}\n\n\tspin_lock_irqsave(&ctx->slock, flags);\n\tb->count = ctx->count++;\n\tb->flags = ctx->flags;\n\tctx->flags = 0;\n\tspin_unlock_irqrestore(&ctx->slock, flags);\n\n\tdprintk(5, \"[%s] index=%d, count=%d, flags=%d\\n\",\n\t\tctx->name, b->index, ctx->count, b->flags);\n\n\n\treturn 0;\n}\n\nint dvb_vb2_mmap(struct dvb_vb2_ctx *ctx, struct vm_area_struct *vma)\n{\n\tint ret;\n\n\tret = vb2_mmap(&ctx->vb_q, vma);\n\tif (ret) {\n\t\tdprintk(1, \"[%s] errno=%d\\n\", ctx->name, ret);\n\t\treturn ret;\n\t}\n\tdprintk(3, \"[%s] ret=%d\\n\", ctx->name, ret);\n\n\treturn 0;\n}\n\n__poll_t dvb_vb2_poll(struct dvb_vb2_ctx *ctx, struct file *file,\n\t\t      poll_table *wait)\n{\n\tdprintk(3, \"[%s]\\n\", ctx->name);\n\treturn vb2_core_poll(&ctx->vb_q, file, wait);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}