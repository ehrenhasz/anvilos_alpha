{
  "module_name": "dvbdev.c",
  "hash_id": "9d3516a9cf47078cedcea1faa75a3f47402436c2d3580c9832f6d7de4ec3e098",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-core/dvbdev.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"dvbdev: \" fmt\n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/mutex.h>\n#include <media/dvbdev.h>\n\n \n#include <media/tuner.h>\n\nstatic DEFINE_MUTEX(dvbdev_mutex);\nstatic LIST_HEAD(dvbdevfops_list);\nstatic int dvbdev_debug;\n\nmodule_param(dvbdev_debug, int, 0644);\nMODULE_PARM_DESC(dvbdev_debug, \"Turn on/off device debugging (default:off).\");\n\n#define dprintk(fmt, arg...) do {\t\t\t\t\t\\\n\tif (dvbdev_debug)\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt),\t\t\t\\\n\t\t       __func__, ##arg);\t\t\t\t\\\n} while (0)\n\nstatic LIST_HEAD(dvb_adapter_list);\nstatic DEFINE_MUTEX(dvbdev_register_lock);\n\nstatic const char * const dnames[] = {\n\t[DVB_DEVICE_VIDEO] =\t\t\"video\",\n\t[DVB_DEVICE_AUDIO] =\t\t\"audio\",\n\t[DVB_DEVICE_SEC] =\t\t\"sec\",\n\t[DVB_DEVICE_FRONTEND] =\t\t\"frontend\",\n\t[DVB_DEVICE_DEMUX] =\t\t\"demux\",\n\t[DVB_DEVICE_DVR] =\t\t\"dvr\",\n\t[DVB_DEVICE_CA] =\t\t\"ca\",\n\t[DVB_DEVICE_NET] =\t\t\"net\",\n\t[DVB_DEVICE_OSD] =\t\t\"osd\"\n};\n\n#ifdef CONFIG_DVB_DYNAMIC_MINORS\n#define MAX_DVB_MINORS\t\t256\n#define DVB_MAX_IDS\t\tMAX_DVB_MINORS\n#else\n#define DVB_MAX_IDS\t\t4\n\nstatic const u8 minor_type[] = {\n\t[DVB_DEVICE_VIDEO]      = 0,\n\t[DVB_DEVICE_AUDIO]      = 1,\n\t[DVB_DEVICE_SEC]        = 2,\n\t[DVB_DEVICE_FRONTEND]   = 3,\n\t[DVB_DEVICE_DEMUX]      = 4,\n\t[DVB_DEVICE_DVR]        = 5,\n\t[DVB_DEVICE_CA]         = 6,\n\t[DVB_DEVICE_NET]        = 7,\n\t[DVB_DEVICE_OSD]        = 8,\n};\n\n#define nums2minor(num, type, id) \\\n\t(((num) << 6) | ((id) << 4) | minor_type[type])\n\n#define MAX_DVB_MINORS\t\t(DVB_MAX_ADAPTERS * 64)\n#endif\n\nstatic struct class *dvb_class;\n\nstatic struct dvb_device *dvb_minors[MAX_DVB_MINORS];\nstatic DECLARE_RWSEM(minor_rwsem);\n\nstatic int dvb_device_open(struct inode *inode, struct file *file)\n{\n\tstruct dvb_device *dvbdev;\n\n\tmutex_lock(&dvbdev_mutex);\n\tdown_read(&minor_rwsem);\n\tdvbdev = dvb_minors[iminor(inode)];\n\n\tif (dvbdev && dvbdev->fops) {\n\t\tint err = 0;\n\t\tconst struct file_operations *new_fops;\n\n\t\tnew_fops = fops_get(dvbdev->fops);\n\t\tif (!new_fops)\n\t\t\tgoto fail;\n\t\tfile->private_data = dvb_device_get(dvbdev);\n\t\treplace_fops(file, new_fops);\n\t\tif (file->f_op->open)\n\t\t\terr = file->f_op->open(inode, file);\n\t\tup_read(&minor_rwsem);\n\t\tmutex_unlock(&dvbdev_mutex);\n\t\tif (err)\n\t\t\tdvb_device_put(dvbdev);\n\t\treturn err;\n\t}\nfail:\n\tup_read(&minor_rwsem);\n\tmutex_unlock(&dvbdev_mutex);\n\treturn -ENODEV;\n}\n\nstatic const struct file_operations dvb_device_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.open =\t\tdvb_device_open,\n\t.llseek =\tnoop_llseek,\n};\n\nstatic struct cdev dvb_device_cdev;\n\nint dvb_generic_open(struct inode *inode, struct file *file)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\n\tif (!dvbdev)\n\t\treturn -ENODEV;\n\n\tif (!dvbdev->users)\n\t\treturn -EBUSY;\n\n\tif ((file->f_flags & O_ACCMODE) == O_RDONLY) {\n\t\tif (!dvbdev->readers)\n\t\t\treturn -EBUSY;\n\t\tdvbdev->readers--;\n\t} else {\n\t\tif (!dvbdev->writers)\n\t\t\treturn -EBUSY;\n\t\tdvbdev->writers--;\n\t}\n\n\tdvbdev->users--;\n\treturn 0;\n}\nEXPORT_SYMBOL(dvb_generic_open);\n\nint dvb_generic_release(struct inode *inode, struct file *file)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\n\tif (!dvbdev)\n\t\treturn -ENODEV;\n\n\tif ((file->f_flags & O_ACCMODE) == O_RDONLY)\n\t\tdvbdev->readers++;\n\telse\n\t\tdvbdev->writers++;\n\n\tdvbdev->users++;\n\n\tdvb_device_put(dvbdev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dvb_generic_release);\n\nlong dvb_generic_ioctl(struct file *file,\n\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\n\tif (!dvbdev)\n\t\treturn -ENODEV;\n\n\tif (!dvbdev->kernel_ioctl)\n\t\treturn -EINVAL;\n\n\treturn dvb_usercopy(file, cmd, arg, dvbdev->kernel_ioctl);\n}\nEXPORT_SYMBOL(dvb_generic_ioctl);\n\nstatic int dvbdev_get_free_id(struct dvb_adapter *adap, int type)\n{\n\tu32 id = 0;\n\n\twhile (id < DVB_MAX_IDS) {\n\t\tstruct dvb_device *dev;\n\n\t\tlist_for_each_entry(dev, &adap->device_list, list_head)\n\t\t\tif (dev->type == type && dev->id == id)\n\t\t\t\tgoto skip;\n\t\treturn id;\nskip:\n\t\tid++;\n\t}\n\treturn -ENFILE;\n}\n\nstatic void dvb_media_device_free(struct dvb_device *dvbdev)\n{\n#if defined(CONFIG_MEDIA_CONTROLLER_DVB)\n\tif (dvbdev->entity) {\n\t\tmedia_device_unregister_entity(dvbdev->entity);\n\t\tkfree(dvbdev->entity);\n\t\tkfree(dvbdev->pads);\n\t\tdvbdev->entity = NULL;\n\t\tdvbdev->pads = NULL;\n\t}\n\n\tif (dvbdev->tsout_entity) {\n\t\tint i;\n\n\t\tfor (i = 0; i < dvbdev->tsout_num_entities; i++) {\n\t\t\tmedia_device_unregister_entity(&dvbdev->tsout_entity[i]);\n\t\t\tkfree(dvbdev->tsout_entity[i].name);\n\t\t}\n\t\tkfree(dvbdev->tsout_entity);\n\t\tkfree(dvbdev->tsout_pads);\n\t\tdvbdev->tsout_entity = NULL;\n\t\tdvbdev->tsout_pads = NULL;\n\n\t\tdvbdev->tsout_num_entities = 0;\n\t}\n\n\tif (dvbdev->intf_devnode) {\n\t\tmedia_devnode_remove(dvbdev->intf_devnode);\n\t\tdvbdev->intf_devnode = NULL;\n\t}\n\n\tif (dvbdev->adapter->conn) {\n\t\tmedia_device_unregister_entity(dvbdev->adapter->conn);\n\t\tkfree(dvbdev->adapter->conn);\n\t\tdvbdev->adapter->conn = NULL;\n\t\tkfree(dvbdev->adapter->conn_pads);\n\t\tdvbdev->adapter->conn_pads = NULL;\n\t}\n#endif\n}\n\n#if defined(CONFIG_MEDIA_CONTROLLER_DVB)\nstatic int dvb_create_tsout_entity(struct dvb_device *dvbdev,\n\t\t\t\t   const char *name, int npads)\n{\n\tint i;\n\n\tdvbdev->tsout_pads = kcalloc(npads, sizeof(*dvbdev->tsout_pads),\n\t\t\t\t     GFP_KERNEL);\n\tif (!dvbdev->tsout_pads)\n\t\treturn -ENOMEM;\n\n\tdvbdev->tsout_entity = kcalloc(npads, sizeof(*dvbdev->tsout_entity),\n\t\t\t\t       GFP_KERNEL);\n\tif (!dvbdev->tsout_entity)\n\t\treturn -ENOMEM;\n\n\tdvbdev->tsout_num_entities = npads;\n\n\tfor (i = 0; i < npads; i++) {\n\t\tstruct media_pad *pads = &dvbdev->tsout_pads[i];\n\t\tstruct media_entity *entity = &dvbdev->tsout_entity[i];\n\t\tint ret;\n\n\t\tentity->name = kasprintf(GFP_KERNEL, \"%s #%d\", name, i);\n\t\tif (!entity->name)\n\t\t\treturn -ENOMEM;\n\n\t\tentity->function = MEDIA_ENT_F_IO_DTV;\n\t\tpads->flags = MEDIA_PAD_FL_SINK;\n\n\t\tret = media_entity_pads_init(entity, 1, pads);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = media_device_register_entity(dvbdev->adapter->mdev,\n\t\t\t\t\t\t   entity);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n#define DEMUX_TSOUT\t\"demux-tsout\"\n#define DVR_TSOUT\t\"dvr-tsout\"\n\nstatic int dvb_create_media_entity(struct dvb_device *dvbdev,\n\t\t\t\t   int type, int demux_sink_pads)\n{\n\tint i, ret, npads;\n\n\tswitch (type) {\n\tcase DVB_DEVICE_FRONTEND:\n\t\tnpads = 2;\n\t\tbreak;\n\tcase DVB_DEVICE_DVR:\n\t\tret = dvb_create_tsout_entity(dvbdev, DVR_TSOUT,\n\t\t\t\t\t      demux_sink_pads);\n\t\treturn ret;\n\tcase DVB_DEVICE_DEMUX:\n\t\tnpads = 1 + demux_sink_pads;\n\t\tret = dvb_create_tsout_entity(dvbdev, DEMUX_TSOUT,\n\t\t\t\t\t      demux_sink_pads);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase DVB_DEVICE_CA:\n\t\tnpads = 2;\n\t\tbreak;\n\tcase DVB_DEVICE_NET:\n\t\t \n\t\treturn 0;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tdvbdev->entity = kzalloc(sizeof(*dvbdev->entity), GFP_KERNEL);\n\tif (!dvbdev->entity)\n\t\treturn -ENOMEM;\n\n\tdvbdev->entity->name = dvbdev->name;\n\n\tif (npads) {\n\t\tdvbdev->pads = kcalloc(npads, sizeof(*dvbdev->pads),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!dvbdev->pads) {\n\t\t\tkfree(dvbdev->entity);\n\t\t\tdvbdev->entity = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase DVB_DEVICE_FRONTEND:\n\t\tdvbdev->entity->function = MEDIA_ENT_F_DTV_DEMOD;\n\t\tdvbdev->pads[0].flags = MEDIA_PAD_FL_SINK;\n\t\tdvbdev->pads[1].flags = MEDIA_PAD_FL_SOURCE;\n\t\tbreak;\n\tcase DVB_DEVICE_DEMUX:\n\t\tdvbdev->entity->function = MEDIA_ENT_F_TS_DEMUX;\n\t\tdvbdev->pads[0].flags = MEDIA_PAD_FL_SINK;\n\t\tfor (i = 1; i < npads; i++)\n\t\t\tdvbdev->pads[i].flags = MEDIA_PAD_FL_SOURCE;\n\t\tbreak;\n\tcase DVB_DEVICE_CA:\n\t\tdvbdev->entity->function = MEDIA_ENT_F_DTV_CA;\n\t\tdvbdev->pads[0].flags = MEDIA_PAD_FL_SINK;\n\t\tdvbdev->pads[1].flags = MEDIA_PAD_FL_SOURCE;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tkfree(dvbdev->entity);\n\t\tkfree(dvbdev->pads);\n\t\tdvbdev->entity = NULL;\n\t\tdvbdev->pads = NULL;\n\t\treturn 0;\n\t}\n\n\tif (npads) {\n\t\tret = media_entity_pads_init(dvbdev->entity, npads, dvbdev->pads);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tret = media_device_register_entity(dvbdev->adapter->mdev,\n\t\t\t\t\t   dvbdev->entity);\n\tif (ret)\n\t\treturn ret;\n\n\tpr_info(\"%s: media entity '%s' registered.\\n\",\n\t\t__func__, dvbdev->entity->name);\n\n\treturn 0;\n}\n#endif\n\nstatic int dvb_register_media_device(struct dvb_device *dvbdev,\n\t\t\t\t     int type, int minor,\n\t\t\t\t     unsigned int demux_sink_pads)\n{\n#if defined(CONFIG_MEDIA_CONTROLLER_DVB)\n\tstruct media_link *link;\n\tu32 intf_type;\n\tint ret;\n\n\tif (!dvbdev->adapter->mdev)\n\t\treturn 0;\n\n\tret = dvb_create_media_entity(dvbdev, type, demux_sink_pads);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (type) {\n\tcase DVB_DEVICE_FRONTEND:\n\t\tintf_type = MEDIA_INTF_T_DVB_FE;\n\t\tbreak;\n\tcase DVB_DEVICE_DEMUX:\n\t\tintf_type = MEDIA_INTF_T_DVB_DEMUX;\n\t\tbreak;\n\tcase DVB_DEVICE_DVR:\n\t\tintf_type = MEDIA_INTF_T_DVB_DVR;\n\t\tbreak;\n\tcase DVB_DEVICE_CA:\n\t\tintf_type = MEDIA_INTF_T_DVB_CA;\n\t\tbreak;\n\tcase DVB_DEVICE_NET:\n\t\tintf_type = MEDIA_INTF_T_DVB_NET;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tdvbdev->intf_devnode = media_devnode_create(dvbdev->adapter->mdev,\n\t\t\t\t\t\t    intf_type, 0,\n\t\t\t\t\t\t    DVB_MAJOR, minor);\n\n\tif (!dvbdev->intf_devnode)\n\t\treturn -ENOMEM;\n\n\t \n\n\tif (!dvbdev->entity)\n\t\treturn 0;\n\n\tlink = media_create_intf_link(dvbdev->entity,\n\t\t\t\t      &dvbdev->intf_devnode->intf,\n\t\t\t\t      MEDIA_LNK_FL_ENABLED |\n\t\t\t\t      MEDIA_LNK_FL_IMMUTABLE);\n\tif (!link)\n\t\treturn -ENOMEM;\n#endif\n\treturn 0;\n}\n\nint dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,\n\t\t\tconst struct dvb_device *template, void *priv,\n\t\t\tenum dvb_device_type type, int demux_sink_pads)\n{\n\tstruct dvb_device *dvbdev;\n\tstruct file_operations *dvbdevfops = NULL;\n\tstruct dvbdevfops_node *node = NULL, *new_node = NULL;\n\tstruct device *clsdev;\n\tint minor;\n\tint id, ret;\n\n\tmutex_lock(&dvbdev_register_lock);\n\n\tid = dvbdev_get_free_id(adap, type);\n\tif (id < 0) {\n\t\tmutex_unlock(&dvbdev_register_lock);\n\t\t*pdvbdev = NULL;\n\t\tpr_err(\"%s: couldn't find free device id\\n\", __func__);\n\t\treturn -ENFILE;\n\t}\n\n\t*pdvbdev = dvbdev = kzalloc(sizeof(*dvbdev), GFP_KERNEL);\n\tif (!dvbdev) {\n\t\tmutex_unlock(&dvbdev_register_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tlist_for_each_entry(node, &dvbdevfops_list, list_head) {\n\t\tif (node->fops->owner == adap->module &&\n\t\t    node->type == type && node->template == template) {\n\t\t\tdvbdevfops = node->fops;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!dvbdevfops) {\n\t\tdvbdevfops = kmemdup(template->fops, sizeof(*dvbdevfops), GFP_KERNEL);\n\t\tif (!dvbdevfops) {\n\t\t\tkfree(dvbdev);\n\t\t\tmutex_unlock(&dvbdev_register_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tnew_node = kzalloc(sizeof(*new_node), GFP_KERNEL);\n\t\tif (!new_node) {\n\t\t\tkfree(dvbdevfops);\n\t\t\tkfree(dvbdev);\n\t\t\tmutex_unlock(&dvbdev_register_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tnew_node->fops = dvbdevfops;\n\t\tnew_node->type = type;\n\t\tnew_node->template = template;\n\t\tlist_add_tail(&new_node->list_head, &dvbdevfops_list);\n\t}\n\n\tmemcpy(dvbdev, template, sizeof(struct dvb_device));\n\tkref_init(&dvbdev->ref);\n\tdvbdev->type = type;\n\tdvbdev->id = id;\n\tdvbdev->adapter = adap;\n\tdvbdev->priv = priv;\n\tdvbdev->fops = dvbdevfops;\n\tinit_waitqueue_head(&dvbdev->wait_queue);\n\tdvbdevfops->owner = adap->module;\n\tlist_add_tail(&dvbdev->list_head, &adap->device_list);\n\tdown_write(&minor_rwsem);\n#ifdef CONFIG_DVB_DYNAMIC_MINORS\n\tfor (minor = 0; minor < MAX_DVB_MINORS; minor++)\n\t\tif (!dvb_minors[minor])\n\t\t\tbreak;\n\tif (minor == MAX_DVB_MINORS) {\n\t\tif (new_node) {\n\t\t\tlist_del(&new_node->list_head);\n\t\t\tkfree(dvbdevfops);\n\t\t\tkfree(new_node);\n\t\t}\n\t\tlist_del(&dvbdev->list_head);\n\t\tkfree(dvbdev);\n\t\tup_write(&minor_rwsem);\n\t\tmutex_unlock(&dvbdev_register_lock);\n\t\treturn -EINVAL;\n\t}\n#else\n\tminor = nums2minor(adap->num, type, id);\n#endif\n\tdvbdev->minor = minor;\n\tdvb_minors[minor] = dvb_device_get(dvbdev);\n\tup_write(&minor_rwsem);\n\tret = dvb_register_media_device(dvbdev, type, minor, demux_sink_pads);\n\tif (ret) {\n\t\tpr_err(\"%s: dvb_register_media_device failed to create the mediagraph\\n\",\n\t\t       __func__);\n\t\tif (new_node) {\n\t\t\tlist_del(&new_node->list_head);\n\t\t\tkfree(dvbdevfops);\n\t\t\tkfree(new_node);\n\t\t}\n\t\tdvb_media_device_free(dvbdev);\n\t\tlist_del(&dvbdev->list_head);\n\t\tkfree(dvbdev);\n\t\tmutex_unlock(&dvbdev_register_lock);\n\t\treturn ret;\n\t}\n\n\tclsdev = device_create(dvb_class, adap->device,\n\t\t\t       MKDEV(DVB_MAJOR, minor),\n\t\t\t       dvbdev, \"dvb%d.%s%d\", adap->num, dnames[type], id);\n\tif (IS_ERR(clsdev)) {\n\t\tpr_err(\"%s: failed to create device dvb%d.%s%d (%ld)\\n\",\n\t\t       __func__, adap->num, dnames[type], id, PTR_ERR(clsdev));\n\t\tif (new_node) {\n\t\t\tlist_del(&new_node->list_head);\n\t\t\tkfree(dvbdevfops);\n\t\t\tkfree(new_node);\n\t\t}\n\t\tdvb_media_device_free(dvbdev);\n\t\tlist_del(&dvbdev->list_head);\n\t\tkfree(dvbdev);\n\t\tmutex_unlock(&dvbdev_register_lock);\n\t\treturn PTR_ERR(clsdev);\n\t}\n\n\tdprintk(\"DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\\n\",\n\t\tadap->num, dnames[type], id, minor, minor);\n\n\tmutex_unlock(&dvbdev_register_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL(dvb_register_device);\n\nvoid dvb_remove_device(struct dvb_device *dvbdev)\n{\n\tif (!dvbdev)\n\t\treturn;\n\n\tdown_write(&minor_rwsem);\n\tdvb_minors[dvbdev->minor] = NULL;\n\tdvb_device_put(dvbdev);\n\tup_write(&minor_rwsem);\n\n\tdvb_media_device_free(dvbdev);\n\n\tdevice_destroy(dvb_class, MKDEV(DVB_MAJOR, dvbdev->minor));\n\n\tlist_del(&dvbdev->list_head);\n}\nEXPORT_SYMBOL(dvb_remove_device);\n\nstatic void dvb_free_device(struct kref *ref)\n{\n\tstruct dvb_device *dvbdev = container_of(ref, struct dvb_device, ref);\n\n\tkfree(dvbdev);\n}\n\nstruct dvb_device *dvb_device_get(struct dvb_device *dvbdev)\n{\n\tkref_get(&dvbdev->ref);\n\treturn dvbdev;\n}\nEXPORT_SYMBOL(dvb_device_get);\n\nvoid dvb_device_put(struct dvb_device *dvbdev)\n{\n\tif (dvbdev)\n\t\tkref_put(&dvbdev->ref, dvb_free_device);\n}\n\nvoid dvb_unregister_device(struct dvb_device *dvbdev)\n{\n\tdvb_remove_device(dvbdev);\n\tdvb_device_put(dvbdev);\n}\nEXPORT_SYMBOL(dvb_unregister_device);\n\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\nstatic int dvb_create_io_intf_links(struct dvb_adapter *adap,\n\t\t\t\t    struct media_interface *intf,\n\t\t\t\t    char *name)\n{\n\tstruct media_device *mdev = adap->mdev;\n\tstruct media_entity *entity;\n\tstruct media_link *link;\n\n\tmedia_device_for_each_entity(entity, mdev) {\n\t\tif (entity->function == MEDIA_ENT_F_IO_DTV) {\n\t\t\tif (strncmp(entity->name, name, strlen(name)))\n\t\t\t\tcontinue;\n\t\t\tlink = media_create_intf_link(entity, intf,\n\t\t\t\t\t\t      MEDIA_LNK_FL_ENABLED |\n\t\t\t\t\t\t      MEDIA_LNK_FL_IMMUTABLE);\n\t\t\tif (!link)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dvb_create_media_graph(struct dvb_adapter *adap,\n\t\t\t   bool create_rf_connector)\n{\n\tstruct media_device *mdev = adap->mdev;\n\tstruct media_entity *entity, *tuner = NULL, *demod = NULL, *conn;\n\tstruct media_entity *demux = NULL, *ca = NULL;\n\tstruct media_link *link;\n\tstruct media_interface *intf;\n\tunsigned int demux_pad = 0;\n\tunsigned int dvr_pad = 0;\n\tunsigned int ntuner = 0, ndemod = 0;\n\tint ret, pad_source, pad_sink;\n\tstatic const char *connector_name = \"Television\";\n\n\tif (!mdev)\n\t\treturn 0;\n\n\tmedia_device_for_each_entity(entity, mdev) {\n\t\tswitch (entity->function) {\n\t\tcase MEDIA_ENT_F_TUNER:\n\t\t\ttuner = entity;\n\t\t\tntuner++;\n\t\t\tbreak;\n\t\tcase MEDIA_ENT_F_DTV_DEMOD:\n\t\t\tdemod = entity;\n\t\t\tndemod++;\n\t\t\tbreak;\n\t\tcase MEDIA_ENT_F_TS_DEMUX:\n\t\t\tdemux = entity;\n\t\t\tbreak;\n\t\tcase MEDIA_ENT_F_DTV_CA:\n\t\t\tca = entity;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (ntuner > 1)\n\t\ttuner = NULL;\n\tif (ndemod > 1)\n\t\tdemod = NULL;\n\n\tif (create_rf_connector) {\n\t\tconn = kzalloc(sizeof(*conn), GFP_KERNEL);\n\t\tif (!conn)\n\t\t\treturn -ENOMEM;\n\t\tadap->conn = conn;\n\n\t\tadap->conn_pads = kzalloc(sizeof(*adap->conn_pads), GFP_KERNEL);\n\t\tif (!adap->conn_pads)\n\t\t\treturn -ENOMEM;\n\n\t\tconn->flags = MEDIA_ENT_FL_CONNECTOR;\n\t\tconn->function = MEDIA_ENT_F_CONN_RF;\n\t\tconn->name = connector_name;\n\t\tadap->conn_pads->flags = MEDIA_PAD_FL_SOURCE;\n\n\t\tret = media_entity_pads_init(conn, 1, adap->conn_pads);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = media_device_register_entity(mdev, conn);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!ntuner) {\n\t\t\tret = media_create_pad_links(mdev,\n\t\t\t\t\t\t     MEDIA_ENT_F_CONN_RF,\n\t\t\t\t\t\t     conn, 0,\n\t\t\t\t\t\t     MEDIA_ENT_F_DTV_DEMOD,\n\t\t\t\t\t\t     demod, 0,\n\t\t\t\t\t\t     MEDIA_LNK_FL_ENABLED,\n\t\t\t\t\t\t     false);\n\t\t} else {\n\t\t\tpad_sink = media_get_pad_index(tuner, MEDIA_PAD_FL_SINK,\n\t\t\t\t\t\t       PAD_SIGNAL_ANALOG);\n\t\t\tif (pad_sink < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tret = media_create_pad_links(mdev,\n\t\t\t\t\t\t     MEDIA_ENT_F_CONN_RF,\n\t\t\t\t\t\t     conn, 0,\n\t\t\t\t\t\t     MEDIA_ENT_F_TUNER,\n\t\t\t\t\t\t     tuner, pad_sink,\n\t\t\t\t\t\t     MEDIA_LNK_FL_ENABLED,\n\t\t\t\t\t\t     false);\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ntuner && ndemod) {\n\t\t \n\t\tpad_source = media_get_pad_index(tuner, MEDIA_PAD_FL_SOURCE,\n\t\t\t\t\t\t PAD_SIGNAL_ANALOG);\n\t\tif (pad_source < 0)\n\t\t\treturn -EINVAL;\n\t\tret = media_create_pad_links(mdev,\n\t\t\t\t\t     MEDIA_ENT_F_TUNER,\n\t\t\t\t\t     tuner, pad_source,\n\t\t\t\t\t     MEDIA_ENT_F_DTV_DEMOD,\n\t\t\t\t\t     demod, 0, MEDIA_LNK_FL_ENABLED,\n\t\t\t\t\t     false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ndemod && demux) {\n\t\tret = media_create_pad_links(mdev,\n\t\t\t\t\t     MEDIA_ENT_F_DTV_DEMOD,\n\t\t\t\t\t     demod, 1,\n\t\t\t\t\t     MEDIA_ENT_F_TS_DEMUX,\n\t\t\t\t\t     demux, 0, MEDIA_LNK_FL_ENABLED,\n\t\t\t\t\t     false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (demux && ca) {\n\t\tret = media_create_pad_link(demux, 1, ca,\n\t\t\t\t\t    0, MEDIA_LNK_FL_ENABLED);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (demux) {\n\t\tmedia_device_for_each_entity(entity, mdev) {\n\t\t\tif (entity->function == MEDIA_ENT_F_IO_DTV) {\n\t\t\t\tif (!strncmp(entity->name, DVR_TSOUT,\n\t\t\t\t\t     strlen(DVR_TSOUT))) {\n\t\t\t\t\tret = media_create_pad_link(demux,\n\t\t\t\t\t\t\t\t    ++dvr_pad,\n\t\t\t\t\t\t\t\t    entity, 0, 0);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tif (!strncmp(entity->name, DEMUX_TSOUT,\n\t\t\t\t\t     strlen(DEMUX_TSOUT))) {\n\t\t\t\t\tret = media_create_pad_link(demux,\n\t\t\t\t\t\t\t\t    ++demux_pad,\n\t\t\t\t\t\t\t\t    entity, 0, 0);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tmedia_device_for_each_intf(intf, mdev) {\n\t\tif (intf->type == MEDIA_INTF_T_DVB_CA && ca) {\n\t\t\tlink = media_create_intf_link(ca, intf,\n\t\t\t\t\t\t      MEDIA_LNK_FL_ENABLED |\n\t\t\t\t\t\t      MEDIA_LNK_FL_IMMUTABLE);\n\t\t\tif (!link)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (intf->type == MEDIA_INTF_T_DVB_FE && tuner) {\n\t\t\tlink = media_create_intf_link(tuner, intf,\n\t\t\t\t\t\t      MEDIA_LNK_FL_ENABLED |\n\t\t\t\t\t\t      MEDIA_LNK_FL_IMMUTABLE);\n\t\t\tif (!link)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n#if 0\n\t\t \n\t\tif (intf->type == MEDIA_INTF_T_DVB_DVR && demux) {\n\t\t\tlink = media_create_intf_link(demux, intf,\n\t\t\t\t\t\t      MEDIA_LNK_FL_ENABLED |\n\t\t\t\t\t\t      MEDIA_LNK_FL_IMMUTABLE);\n\t\t\tif (!link)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n#endif\n\t\tif (intf->type == MEDIA_INTF_T_DVB_DVR) {\n\t\t\tret = dvb_create_io_intf_links(adap, intf, DVR_TSOUT);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tif (intf->type == MEDIA_INTF_T_DVB_DEMUX) {\n\t\t\tret = dvb_create_io_intf_links(adap, intf, DEMUX_TSOUT);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dvb_create_media_graph);\n#endif\n\nstatic int dvbdev_check_free_adapter_num(int num)\n{\n\tstruct list_head *entry;\n\n\tlist_for_each(entry, &dvb_adapter_list) {\n\t\tstruct dvb_adapter *adap;\n\n\t\tadap = list_entry(entry, struct dvb_adapter, list_head);\n\t\tif (adap->num == num)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int dvbdev_get_free_adapter_num(void)\n{\n\tint num = 0;\n\n\twhile (num < DVB_MAX_ADAPTERS) {\n\t\tif (dvbdev_check_free_adapter_num(num))\n\t\t\treturn num;\n\t\tnum++;\n\t}\n\n\treturn -ENFILE;\n}\n\nint dvb_register_adapter(struct dvb_adapter *adap, const char *name,\n\t\t\t struct module *module, struct device *device,\n\t\t\t short *adapter_nums)\n{\n\tint i, num;\n\n\tmutex_lock(&dvbdev_register_lock);\n\n\tfor (i = 0; i < DVB_MAX_ADAPTERS; ++i) {\n\t\tnum = adapter_nums[i];\n\t\tif (num >= 0  &&  num < DVB_MAX_ADAPTERS) {\n\t\t \n\t\t\tif (dvbdev_check_free_adapter_num(num))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tnum = dvbdev_get_free_adapter_num();\n\t\t\tbreak;\n\t\t}\n\t\tnum = -1;\n\t}\n\n\tif (num < 0) {\n\t\tmutex_unlock(&dvbdev_register_lock);\n\t\treturn -ENFILE;\n\t}\n\n\tmemset(adap, 0, sizeof(struct dvb_adapter));\n\tINIT_LIST_HEAD(&adap->device_list);\n\n\tpr_info(\"DVB: registering new adapter (%s)\\n\", name);\n\n\tadap->num = num;\n\tadap->name = name;\n\tadap->module = module;\n\tadap->device = device;\n\tadap->mfe_shared = 0;\n\tadap->mfe_dvbdev = NULL;\n\tmutex_init(&adap->mfe_lock);\n\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tmutex_init(&adap->mdev_lock);\n#endif\n\n\tlist_add_tail(&adap->list_head, &dvb_adapter_list);\n\n\tmutex_unlock(&dvbdev_register_lock);\n\n\treturn num;\n}\nEXPORT_SYMBOL(dvb_register_adapter);\n\nint dvb_unregister_adapter(struct dvb_adapter *adap)\n{\n\tmutex_lock(&dvbdev_register_lock);\n\tlist_del(&adap->list_head);\n\tmutex_unlock(&dvbdev_register_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL(dvb_unregister_adapter);\n\n \nint dvb_usercopy(struct file *file,\n\t\t unsigned int cmd, unsigned long arg,\n\t\t int (*func)(struct file *file,\n\t\t\t     unsigned int cmd, void *arg))\n{\n\tchar    sbuf[128];\n\tvoid    *mbuf = NULL;\n\tvoid    *parg = NULL;\n\tint     err  = -EINVAL;\n\n\t \n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_NONE:\n\t\t \n\t\tparg = (void *)arg;\n\t\tbreak;\n\tcase _IOC_READ:  \n\tcase _IOC_WRITE:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n\t\t\tparg = sbuf;\n\t\t} else {\n\t\t\t \n\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\n\t\t\tif (!mbuf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tparg = mbuf;\n\t\t}\n\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\n\t \n\terr = func(file, cmd, parg);\n\tif (err == -ENOIOCTLCMD)\n\t\terr = -ENOTTY;\n\n\tif (err < 0)\n\t\tgoto out;\n\n\t \n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_READ:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\t}\n\nout:\n\tkfree(mbuf);\n\treturn err;\n}\n\n#if IS_ENABLED(CONFIG_I2C)\nstruct i2c_client *dvb_module_probe(const char *module_name,\n\t\t\t\t    const char *name,\n\t\t\t\t    struct i2c_adapter *adap,\n\t\t\t\t    unsigned char addr,\n\t\t\t\t    void *platform_data)\n{\n\tstruct i2c_client *client;\n\tstruct i2c_board_info *board_info;\n\n\tboard_info = kzalloc(sizeof(*board_info), GFP_KERNEL);\n\tif (!board_info)\n\t\treturn NULL;\n\n\tif (name)\n\t\tstrscpy(board_info->type, name, I2C_NAME_SIZE);\n\telse\n\t\tstrscpy(board_info->type, module_name, I2C_NAME_SIZE);\n\n\tboard_info->addr = addr;\n\tboard_info->platform_data = platform_data;\n\trequest_module(module_name);\n\tclient = i2c_new_client_device(adap, board_info);\n\tif (!i2c_client_has_driver(client)) {\n\t\tkfree(board_info);\n\t\treturn NULL;\n\t}\n\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\tclient = NULL;\n\t}\n\n\tkfree(board_info);\n\treturn client;\n}\nEXPORT_SYMBOL_GPL(dvb_module_probe);\n\nvoid dvb_module_release(struct i2c_client *client)\n{\n\tif (!client)\n\t\treturn;\n\n\tmodule_put(client->dev.driver->owner);\n\ti2c_unregister_device(client);\n}\nEXPORT_SYMBOL_GPL(dvb_module_release);\n#endif\n\nstatic int dvb_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct dvb_device *dvbdev = dev_get_drvdata(dev);\n\n\tadd_uevent_var(env, \"DVB_ADAPTER_NUM=%d\", dvbdev->adapter->num);\n\tadd_uevent_var(env, \"DVB_DEVICE_TYPE=%s\", dnames[dvbdev->type]);\n\tadd_uevent_var(env, \"DVB_DEVICE_NUM=%d\", dvbdev->id);\n\treturn 0;\n}\n\nstatic char *dvb_devnode(const struct device *dev, umode_t *mode)\n{\n\tconst struct dvb_device *dvbdev = dev_get_drvdata(dev);\n\n\treturn kasprintf(GFP_KERNEL, \"dvb/adapter%d/%s%d\",\n\t\tdvbdev->adapter->num, dnames[dvbdev->type], dvbdev->id);\n}\n\nstatic int __init init_dvbdev(void)\n{\n\tint retval;\n\tdev_t dev = MKDEV(DVB_MAJOR, 0);\n\n\tretval = register_chrdev_region(dev, MAX_DVB_MINORS, \"DVB\");\n\tif (retval != 0) {\n\t\tpr_err(\"dvb-core: unable to get major %d\\n\", DVB_MAJOR);\n\t\treturn retval;\n\t}\n\n\tcdev_init(&dvb_device_cdev, &dvb_device_fops);\n\tretval = cdev_add(&dvb_device_cdev, dev, MAX_DVB_MINORS);\n\tif (retval != 0) {\n\t\tpr_err(\"dvb-core: unable register character device\\n\");\n\t\tgoto error;\n\t}\n\n\tdvb_class = class_create(\"dvb\");\n\tif (IS_ERR(dvb_class)) {\n\t\tretval = PTR_ERR(dvb_class);\n\t\tgoto error;\n\t}\n\tdvb_class->dev_uevent = dvb_uevent;\n\tdvb_class->devnode = dvb_devnode;\n\treturn 0;\n\nerror:\n\tcdev_del(&dvb_device_cdev);\n\tunregister_chrdev_region(dev, MAX_DVB_MINORS);\n\treturn retval;\n}\n\nstatic void __exit exit_dvbdev(void)\n{\n\tstruct dvbdevfops_node *node, *next;\n\n\tclass_destroy(dvb_class);\n\tcdev_del(&dvb_device_cdev);\n\tunregister_chrdev_region(MKDEV(DVB_MAJOR, 0), MAX_DVB_MINORS);\n\n\tlist_for_each_entry_safe(node, next, &dvbdevfops_list, list_head) {\n\t\tlist_del(&node->list_head);\n\t\tkfree(node->fops);\n\t\tkfree(node);\n\t}\n}\n\nsubsys_initcall(init_dvbdev);\nmodule_exit(exit_dvbdev);\n\nMODULE_DESCRIPTION(\"DVB Core Driver\");\nMODULE_AUTHOR(\"Marcus Metzler, Ralph Metzler, Holger Waechtler\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}