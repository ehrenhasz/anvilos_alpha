{
  "module_name": "dmxdev.c",
  "hash_id": "13c6a70dad76a04b04f3b12d3880deaab5b2b52489afdbf46daf04927c4baa5b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-core/dmxdev.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"dmxdev: \" fmt\n\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/poll.h>\n#include <linux/ioctl.h>\n#include <linux/wait.h>\n#include <linux/uaccess.h>\n#include <media/dmxdev.h>\n#include <media/dvb_vb2.h>\n\nstatic int debug;\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off debugging (default:off).\");\n\n#define dprintk(fmt, arg...) do {\t\t\t\t\t\\\n\tif (debug)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt),\t\t\t\\\n\t\t\t__func__, ##arg);\t\t\t\t\\\n} while (0)\n\nstatic int dvb_dmxdev_buffer_write(struct dvb_ringbuffer *buf,\n\t\t\t\t   const u8 *src, size_t len)\n{\n\tssize_t free;\n\n\tif (!len)\n\t\treturn 0;\n\tif (!buf->data)\n\t\treturn 0;\n\n\tfree = dvb_ringbuffer_free(buf);\n\tif (len > free) {\n\t\tdprintk(\"buffer overflow\\n\");\n\t\treturn -EOVERFLOW;\n\t}\n\n\treturn dvb_ringbuffer_write(buf, src, len);\n}\n\nstatic ssize_t dvb_dmxdev_buffer_read(struct dvb_ringbuffer *src,\n\t\t\t\t      int non_blocking, char __user *buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tsize_t todo;\n\tssize_t avail;\n\tssize_t ret = 0;\n\n\tif (!src->data)\n\t\treturn 0;\n\n\tif (src->error) {\n\t\tret = src->error;\n\t\tdvb_ringbuffer_flush(src);\n\t\treturn ret;\n\t}\n\n\tfor (todo = count; todo > 0; todo -= ret) {\n\t\tif (non_blocking && dvb_ringbuffer_empty(src)) {\n\t\t\tret = -EWOULDBLOCK;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = wait_event_interruptible(src->queue,\n\t\t\t\t\t       !dvb_ringbuffer_empty(src) ||\n\t\t\t\t\t       (src->error != 0));\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (src->error) {\n\t\t\tret = src->error;\n\t\t\tdvb_ringbuffer_flush(src);\n\t\t\tbreak;\n\t\t}\n\n\t\tavail = dvb_ringbuffer_avail(src);\n\t\tif (avail > todo)\n\t\t\tavail = todo;\n\n\t\tret = dvb_ringbuffer_read_user(src, buf, avail);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tbuf += ret;\n\t}\n\n\treturn (count - todo) ? (count - todo) : ret;\n}\n\nstatic struct dmx_frontend *get_fe(struct dmx_demux *demux, int type)\n{\n\tstruct list_head *head, *pos;\n\n\thead = demux->get_frontends(demux);\n\tif (!head)\n\t\treturn NULL;\n\tlist_for_each(pos, head)\n\t\tif (DMX_FE_ENTRY(pos)->source == type)\n\t\t\treturn DMX_FE_ENTRY(pos);\n\n\treturn NULL;\n}\n\nstatic int dvb_dvr_open(struct inode *inode, struct file *file)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dmxdev *dmxdev = dvbdev->priv;\n\tstruct dmx_frontend *front;\n\tbool need_ringbuffer = false;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (mutex_lock_interruptible(&dmxdev->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (dmxdev->exit) {\n\t\tmutex_unlock(&dmxdev->mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tdmxdev->may_do_mmap = 0;\n\n\t \n\n\tif ((file->f_flags & O_ACCMODE) == O_RDONLY)\n\t\tneed_ringbuffer = true;\n\telse if ((file->f_flags & O_ACCMODE) == O_RDWR) {\n\t\tif (!(dmxdev->capabilities & DMXDEV_CAP_DUPLEX)) {\n#ifdef CONFIG_DVB_MMAP\n\t\t\tdmxdev->may_do_mmap = 1;\n\t\t\tneed_ringbuffer = true;\n#else\n\t\t\tmutex_unlock(&dmxdev->mutex);\n\t\t\treturn -EOPNOTSUPP;\n#endif\n\t\t}\n\t}\n\n\tif (need_ringbuffer) {\n\t\tvoid *mem;\n\n\t\tif (!dvbdev->readers) {\n\t\t\tmutex_unlock(&dmxdev->mutex);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tmem = vmalloc(DVR_BUFFER_SIZE);\n\t\tif (!mem) {\n\t\t\tmutex_unlock(&dmxdev->mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdvb_ringbuffer_init(&dmxdev->dvr_buffer, mem, DVR_BUFFER_SIZE);\n\t\tif (dmxdev->may_do_mmap)\n\t\t\tdvb_vb2_init(&dmxdev->dvr_vb2_ctx, \"dvr\",\n\t\t\t\t     file->f_flags & O_NONBLOCK);\n\t\tdvbdev->readers--;\n\t}\n\n\tif ((file->f_flags & O_ACCMODE) == O_WRONLY) {\n\t\tdmxdev->dvr_orig_fe = dmxdev->demux->frontend;\n\n\t\tif (!dmxdev->demux->write) {\n\t\t\tmutex_unlock(&dmxdev->mutex);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tfront = get_fe(dmxdev->demux, DMX_MEMORY_FE);\n\n\t\tif (!front) {\n\t\t\tmutex_unlock(&dmxdev->mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdmxdev->demux->disconnect_frontend(dmxdev->demux);\n\t\tdmxdev->demux->connect_frontend(dmxdev->demux, front);\n\t}\n\tdvbdev->users++;\n\tmutex_unlock(&dmxdev->mutex);\n\treturn 0;\n}\n\nstatic int dvb_dvr_release(struct inode *inode, struct file *file)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dmxdev *dmxdev = dvbdev->priv;\n\n\tmutex_lock(&dmxdev->mutex);\n\n\tif ((file->f_flags & O_ACCMODE) == O_WRONLY) {\n\t\tdmxdev->demux->disconnect_frontend(dmxdev->demux);\n\t\tdmxdev->demux->connect_frontend(dmxdev->demux,\n\t\t\t\t\t\tdmxdev->dvr_orig_fe);\n\t}\n\n\tif (((file->f_flags & O_ACCMODE) == O_RDONLY) ||\n\t    dmxdev->may_do_mmap) {\n\t\tif (dmxdev->may_do_mmap) {\n\t\t\tif (dvb_vb2_is_streaming(&dmxdev->dvr_vb2_ctx))\n\t\t\t\tdvb_vb2_stream_off(&dmxdev->dvr_vb2_ctx);\n\t\t\tdvb_vb2_release(&dmxdev->dvr_vb2_ctx);\n\t\t}\n\t\tdvbdev->readers++;\n\t\tif (dmxdev->dvr_buffer.data) {\n\t\t\tvoid *mem = dmxdev->dvr_buffer.data;\n\t\t\t \n\t\t\tmb();\n\t\t\tspin_lock_irq(&dmxdev->lock);\n\t\t\tdmxdev->dvr_buffer.data = NULL;\n\t\t\tspin_unlock_irq(&dmxdev->lock);\n\t\t\tvfree(mem);\n\t\t}\n\t}\n\t \n\tdvbdev->users--;\n\tif (dvbdev->users == 1 && dmxdev->exit == 1) {\n\t\tmutex_unlock(&dmxdev->mutex);\n\t\twake_up(&dvbdev->wait_queue);\n\t} else\n\t\tmutex_unlock(&dmxdev->mutex);\n\n\treturn 0;\n}\n\nstatic ssize_t dvb_dvr_write(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dmxdev *dmxdev = dvbdev->priv;\n\tint ret;\n\n\tif (!dmxdev->demux->write)\n\t\treturn -EOPNOTSUPP;\n\tif ((file->f_flags & O_ACCMODE) != O_WRONLY)\n\t\treturn -EINVAL;\n\tif (mutex_lock_interruptible(&dmxdev->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (dmxdev->exit) {\n\t\tmutex_unlock(&dmxdev->mutex);\n\t\treturn -ENODEV;\n\t}\n\tret = dmxdev->demux->write(dmxdev->demux, buf, count);\n\tmutex_unlock(&dmxdev->mutex);\n\treturn ret;\n}\n\nstatic ssize_t dvb_dvr_read(struct file *file, char __user *buf, size_t count,\n\t\t\t    loff_t *ppos)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dmxdev *dmxdev = dvbdev->priv;\n\n\tif (dmxdev->exit)\n\t\treturn -ENODEV;\n\n\treturn dvb_dmxdev_buffer_read(&dmxdev->dvr_buffer,\n\t\t\t\t      file->f_flags & O_NONBLOCK,\n\t\t\t\t      buf, count, ppos);\n}\n\nstatic int dvb_dvr_set_buffer_size(struct dmxdev *dmxdev,\n\t\t\t\t      unsigned long size)\n{\n\tstruct dvb_ringbuffer *buf = &dmxdev->dvr_buffer;\n\tvoid *newmem;\n\tvoid *oldmem;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (buf->size == size)\n\t\treturn 0;\n\tif (!size)\n\t\treturn -EINVAL;\n\n\tnewmem = vmalloc(size);\n\tif (!newmem)\n\t\treturn -ENOMEM;\n\n\toldmem = buf->data;\n\n\tspin_lock_irq(&dmxdev->lock);\n\tbuf->data = newmem;\n\tbuf->size = size;\n\n\t \n\tdvb_ringbuffer_reset(buf);\n\tspin_unlock_irq(&dmxdev->lock);\n\n\tvfree(oldmem);\n\n\treturn 0;\n}\n\nstatic inline void dvb_dmxdev_filter_state_set(struct dmxdev_filter\n\t\t\t\t\t       *dmxdevfilter, int state)\n{\n\tspin_lock_irq(&dmxdevfilter->dev->lock);\n\tdmxdevfilter->state = state;\n\tspin_unlock_irq(&dmxdevfilter->dev->lock);\n}\n\nstatic int dvb_dmxdev_set_buffer_size(struct dmxdev_filter *dmxdevfilter,\n\t\t\t\t      unsigned long size)\n{\n\tstruct dvb_ringbuffer *buf = &dmxdevfilter->buffer;\n\tvoid *newmem;\n\tvoid *oldmem;\n\n\tif (buf->size == size)\n\t\treturn 0;\n\tif (!size)\n\t\treturn -EINVAL;\n\tif (dmxdevfilter->state >= DMXDEV_STATE_GO)\n\t\treturn -EBUSY;\n\n\tnewmem = vmalloc(size);\n\tif (!newmem)\n\t\treturn -ENOMEM;\n\n\toldmem = buf->data;\n\n\tspin_lock_irq(&dmxdevfilter->dev->lock);\n\tbuf->data = newmem;\n\tbuf->size = size;\n\n\t \n\tdvb_ringbuffer_reset(buf);\n\tspin_unlock_irq(&dmxdevfilter->dev->lock);\n\n\tvfree(oldmem);\n\n\treturn 0;\n}\n\nstatic void dvb_dmxdev_filter_timeout(struct timer_list *t)\n{\n\tstruct dmxdev_filter *dmxdevfilter = from_timer(dmxdevfilter, t, timer);\n\n\tdmxdevfilter->buffer.error = -ETIMEDOUT;\n\tspin_lock_irq(&dmxdevfilter->dev->lock);\n\tdmxdevfilter->state = DMXDEV_STATE_TIMEDOUT;\n\tspin_unlock_irq(&dmxdevfilter->dev->lock);\n\twake_up(&dmxdevfilter->buffer.queue);\n}\n\nstatic void dvb_dmxdev_filter_timer(struct dmxdev_filter *dmxdevfilter)\n{\n\tstruct dmx_sct_filter_params *para = &dmxdevfilter->params.sec;\n\n\tdel_timer(&dmxdevfilter->timer);\n\tif (para->timeout) {\n\t\tdmxdevfilter->timer.expires =\n\t\t    jiffies + 1 + (HZ / 2 + HZ * para->timeout) / 1000;\n\t\tadd_timer(&dmxdevfilter->timer);\n\t}\n}\n\nstatic int dvb_dmxdev_section_callback(const u8 *buffer1, size_t buffer1_len,\n\t\t\t\t       const u8 *buffer2, size_t buffer2_len,\n\t\t\t\t       struct dmx_section_filter *filter,\n\t\t\t\t       u32 *buffer_flags)\n{\n\tstruct dmxdev_filter *dmxdevfilter = filter->priv;\n\tint ret;\n\n\tif (!dvb_vb2_is_streaming(&dmxdevfilter->vb2_ctx) &&\n\t    dmxdevfilter->buffer.error) {\n\t\twake_up(&dmxdevfilter->buffer.queue);\n\t\treturn 0;\n\t}\n\tspin_lock(&dmxdevfilter->dev->lock);\n\tif (dmxdevfilter->state != DMXDEV_STATE_GO) {\n\t\tspin_unlock(&dmxdevfilter->dev->lock);\n\t\treturn 0;\n\t}\n\tdel_timer(&dmxdevfilter->timer);\n\tdprintk(\"section callback %*ph\\n\", 6, buffer1);\n\tif (dvb_vb2_is_streaming(&dmxdevfilter->vb2_ctx)) {\n\t\tret = dvb_vb2_fill_buffer(&dmxdevfilter->vb2_ctx,\n\t\t\t\t\t  buffer1, buffer1_len,\n\t\t\t\t\t  buffer_flags);\n\t\tif (ret == buffer1_len)\n\t\t\tret = dvb_vb2_fill_buffer(&dmxdevfilter->vb2_ctx,\n\t\t\t\t\t\t  buffer2, buffer2_len,\n\t\t\t\t\t\t  buffer_flags);\n\t} else {\n\t\tret = dvb_dmxdev_buffer_write(&dmxdevfilter->buffer,\n\t\t\t\t\t      buffer1, buffer1_len);\n\t\tif (ret == buffer1_len) {\n\t\t\tret = dvb_dmxdev_buffer_write(&dmxdevfilter->buffer,\n\t\t\t\t\t\t      buffer2, buffer2_len);\n\t\t}\n\t}\n\tif (ret < 0)\n\t\tdmxdevfilter->buffer.error = ret;\n\tif (dmxdevfilter->params.sec.flags & DMX_ONESHOT)\n\t\tdmxdevfilter->state = DMXDEV_STATE_DONE;\n\tspin_unlock(&dmxdevfilter->dev->lock);\n\twake_up(&dmxdevfilter->buffer.queue);\n\treturn 0;\n}\n\nstatic int dvb_dmxdev_ts_callback(const u8 *buffer1, size_t buffer1_len,\n\t\t\t\t  const u8 *buffer2, size_t buffer2_len,\n\t\t\t\t  struct dmx_ts_feed *feed,\n\t\t\t\t  u32 *buffer_flags)\n{\n\tstruct dmxdev_filter *dmxdevfilter = feed->priv;\n\tstruct dvb_ringbuffer *buffer;\n#ifdef CONFIG_DVB_MMAP\n\tstruct dvb_vb2_ctx *ctx;\n#endif\n\tint ret;\n\n\tspin_lock(&dmxdevfilter->dev->lock);\n\tif (dmxdevfilter->params.pes.output == DMX_OUT_DECODER) {\n\t\tspin_unlock(&dmxdevfilter->dev->lock);\n\t\treturn 0;\n\t}\n\n\tif (dmxdevfilter->params.pes.output == DMX_OUT_TAP ||\n\t    dmxdevfilter->params.pes.output == DMX_OUT_TSDEMUX_TAP) {\n\t\tbuffer = &dmxdevfilter->buffer;\n#ifdef CONFIG_DVB_MMAP\n\t\tctx = &dmxdevfilter->vb2_ctx;\n#endif\n\t} else {\n\t\tbuffer = &dmxdevfilter->dev->dvr_buffer;\n#ifdef CONFIG_DVB_MMAP\n\t\tctx = &dmxdevfilter->dev->dvr_vb2_ctx;\n#endif\n\t}\n\n\tif (dvb_vb2_is_streaming(ctx)) {\n\t\tret = dvb_vb2_fill_buffer(ctx, buffer1, buffer1_len,\n\t\t\t\t\t  buffer_flags);\n\t\tif (ret == buffer1_len)\n\t\t\tret = dvb_vb2_fill_buffer(ctx, buffer2, buffer2_len,\n\t\t\t\t\t\t  buffer_flags);\n\t} else {\n\t\tif (buffer->error) {\n\t\t\tspin_unlock(&dmxdevfilter->dev->lock);\n\t\t\twake_up(&buffer->queue);\n\t\t\treturn 0;\n\t\t}\n\t\tret = dvb_dmxdev_buffer_write(buffer, buffer1, buffer1_len);\n\t\tif (ret == buffer1_len)\n\t\t\tret = dvb_dmxdev_buffer_write(buffer,\n\t\t\t\t\t\t      buffer2, buffer2_len);\n\t}\n\tif (ret < 0)\n\t\tbuffer->error = ret;\n\tspin_unlock(&dmxdevfilter->dev->lock);\n\twake_up(&buffer->queue);\n\treturn 0;\n}\n\n \nstatic int dvb_dmxdev_feed_stop(struct dmxdev_filter *dmxdevfilter)\n{\n\tstruct dmxdev_feed *feed;\n\n\tdvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_SET);\n\n\tswitch (dmxdevfilter->type) {\n\tcase DMXDEV_TYPE_SEC:\n\t\tdel_timer(&dmxdevfilter->timer);\n\t\tdmxdevfilter->feed.sec->stop_filtering(dmxdevfilter->feed.sec);\n\t\tbreak;\n\tcase DMXDEV_TYPE_PES:\n\t\tlist_for_each_entry(feed, &dmxdevfilter->feed.ts, next)\n\t\t\tfeed->ts->stop_filtering(feed->ts);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int dvb_dmxdev_feed_start(struct dmxdev_filter *filter)\n{\n\tstruct dmxdev_feed *feed;\n\tint ret;\n\n\tdvb_dmxdev_filter_state_set(filter, DMXDEV_STATE_GO);\n\n\tswitch (filter->type) {\n\tcase DMXDEV_TYPE_SEC:\n\t\treturn filter->feed.sec->start_filtering(filter->feed.sec);\n\tcase DMXDEV_TYPE_PES:\n\t\tlist_for_each_entry(feed, &filter->feed.ts, next) {\n\t\t\tret = feed->ts->start_filtering(feed->ts);\n\t\t\tif (ret < 0) {\n\t\t\t\tdvb_dmxdev_feed_stop(filter);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dvb_dmxdev_feed_restart(struct dmxdev_filter *filter)\n{\n\tint i;\n\tstruct dmxdev *dmxdev = filter->dev;\n\tu16 pid = filter->params.sec.pid;\n\n\tfor (i = 0; i < dmxdev->filternum; i++)\n\t\tif (dmxdev->filter[i].state >= DMXDEV_STATE_GO &&\n\t\t    dmxdev->filter[i].type == DMXDEV_TYPE_SEC &&\n\t\t    dmxdev->filter[i].params.sec.pid == pid) {\n\t\t\tdvb_dmxdev_feed_start(&dmxdev->filter[i]);\n\t\t\treturn 0;\n\t\t}\n\n\tfilter->dev->demux->release_section_feed(dmxdev->demux,\n\t\t\t\t\t\t filter->feed.sec);\n\n\treturn 0;\n}\n\nstatic int dvb_dmxdev_filter_stop(struct dmxdev_filter *dmxdevfilter)\n{\n\tstruct dmxdev_feed *feed;\n\tstruct dmx_demux *demux;\n\n\tif (dmxdevfilter->state < DMXDEV_STATE_GO)\n\t\treturn 0;\n\n\tswitch (dmxdevfilter->type) {\n\tcase DMXDEV_TYPE_SEC:\n\t\tif (!dmxdevfilter->feed.sec)\n\t\t\tbreak;\n\t\tdvb_dmxdev_feed_stop(dmxdevfilter);\n\t\tif (dmxdevfilter->filter.sec)\n\t\t\tdmxdevfilter->feed.sec->\n\t\t\t    release_filter(dmxdevfilter->feed.sec,\n\t\t\t\t\t   dmxdevfilter->filter.sec);\n\t\tdvb_dmxdev_feed_restart(dmxdevfilter);\n\t\tdmxdevfilter->feed.sec = NULL;\n\t\tbreak;\n\tcase DMXDEV_TYPE_PES:\n\t\tdvb_dmxdev_feed_stop(dmxdevfilter);\n\t\tdemux = dmxdevfilter->dev->demux;\n\t\tlist_for_each_entry(feed, &dmxdevfilter->feed.ts, next) {\n\t\t\tdemux->release_ts_feed(demux, feed->ts);\n\t\t\tfeed->ts = NULL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (dmxdevfilter->state == DMXDEV_STATE_ALLOCATED)\n\t\t\treturn 0;\n\t\treturn -EINVAL;\n\t}\n\n\tdvb_ringbuffer_flush(&dmxdevfilter->buffer);\n\treturn 0;\n}\n\nstatic void dvb_dmxdev_delete_pids(struct dmxdev_filter *dmxdevfilter)\n{\n\tstruct dmxdev_feed *feed, *tmp;\n\n\t \n\tlist_for_each_entry_safe(feed, tmp, &dmxdevfilter->feed.ts, next) {\n\t\tlist_del(&feed->next);\n\t\tkfree(feed);\n\t}\n\n\tBUG_ON(!list_empty(&dmxdevfilter->feed.ts));\n}\n\nstatic inline int dvb_dmxdev_filter_reset(struct dmxdev_filter *dmxdevfilter)\n{\n\tif (dmxdevfilter->state < DMXDEV_STATE_SET)\n\t\treturn 0;\n\n\tif (dmxdevfilter->type == DMXDEV_TYPE_PES)\n\t\tdvb_dmxdev_delete_pids(dmxdevfilter);\n\n\tdmxdevfilter->type = DMXDEV_TYPE_NONE;\n\tdvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_ALLOCATED);\n\treturn 0;\n}\n\nstatic int dvb_dmxdev_start_feed(struct dmxdev *dmxdev,\n\t\t\t\t struct dmxdev_filter *filter,\n\t\t\t\t struct dmxdev_feed *feed)\n{\n\tktime_t timeout = ktime_set(0, 0);\n\tstruct dmx_pes_filter_params *para = &filter->params.pes;\n\tenum dmx_output otype;\n\tint ret;\n\tint ts_type;\n\tenum dmx_ts_pes ts_pes;\n\tstruct dmx_ts_feed *tsfeed;\n\n\tfeed->ts = NULL;\n\totype = para->output;\n\n\tts_pes = para->pes_type;\n\n\tif (ts_pes < DMX_PES_OTHER)\n\t\tts_type = TS_DECODER;\n\telse\n\t\tts_type = 0;\n\n\tif (otype == DMX_OUT_TS_TAP)\n\t\tts_type |= TS_PACKET;\n\telse if (otype == DMX_OUT_TSDEMUX_TAP)\n\t\tts_type |= TS_PACKET | TS_DEMUX;\n\telse if (otype == DMX_OUT_TAP)\n\t\tts_type |= TS_PACKET | TS_DEMUX | TS_PAYLOAD_ONLY;\n\n\tret = dmxdev->demux->allocate_ts_feed(dmxdev->demux, &feed->ts,\n\t\t\t\t\t      dvb_dmxdev_ts_callback);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttsfeed = feed->ts;\n\ttsfeed->priv = filter;\n\n\tret = tsfeed->set(tsfeed, feed->pid, ts_type, ts_pes, timeout);\n\tif (ret < 0) {\n\t\tdmxdev->demux->release_ts_feed(dmxdev->demux, tsfeed);\n\t\treturn ret;\n\t}\n\n\tret = tsfeed->start_filtering(tsfeed);\n\tif (ret < 0) {\n\t\tdmxdev->demux->release_ts_feed(dmxdev->demux, tsfeed);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int dvb_dmxdev_filter_start(struct dmxdev_filter *filter)\n{\n\tstruct dmxdev *dmxdev = filter->dev;\n\tstruct dmxdev_feed *feed;\n\tvoid *mem;\n\tint ret, i;\n\n\tif (filter->state < DMXDEV_STATE_SET)\n\t\treturn -EINVAL;\n\n\tif (filter->state >= DMXDEV_STATE_GO)\n\t\tdvb_dmxdev_filter_stop(filter);\n\n\tif (!filter->buffer.data) {\n\t\tmem = vmalloc(filter->buffer.size);\n\t\tif (!mem)\n\t\t\treturn -ENOMEM;\n\t\tspin_lock_irq(&filter->dev->lock);\n\t\tfilter->buffer.data = mem;\n\t\tspin_unlock_irq(&filter->dev->lock);\n\t}\n\n\tdvb_ringbuffer_flush(&filter->buffer);\n\n\tswitch (filter->type) {\n\tcase DMXDEV_TYPE_SEC:\n\t{\n\t\tstruct dmx_sct_filter_params *para = &filter->params.sec;\n\t\tstruct dmx_section_filter **secfilter = &filter->filter.sec;\n\t\tstruct dmx_section_feed **secfeed = &filter->feed.sec;\n\n\t\t*secfilter = NULL;\n\t\t*secfeed = NULL;\n\n\n\t\t \n\t\tfor (i = 0; i < dmxdev->filternum; i++) {\n\t\t\tif (dmxdev->filter[i].state >= DMXDEV_STATE_GO &&\n\t\t\t    dmxdev->filter[i].type == DMXDEV_TYPE_SEC &&\n\t\t\t    dmxdev->filter[i].params.sec.pid == para->pid) {\n\t\t\t\t*secfeed = dmxdev->filter[i].feed.sec;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!*secfeed) {\n\t\t\tret = dmxdev->demux->allocate_section_feed(dmxdev->demux,\n\t\t\t\t\t\t\t\t   secfeed,\n\t\t\t\t\t\t\t\t   dvb_dmxdev_section_callback);\n\t\t\tif (!*secfeed) {\n\t\t\t\tpr_err(\"DVB (%s): could not alloc feed\\n\",\n\t\t\t\t       __func__);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = (*secfeed)->set(*secfeed, para->pid,\n\t\t\t\t\t      (para->flags & DMX_CHECK_CRC) ? 1 : 0);\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"DVB (%s): could not set feed\\n\",\n\t\t\t\t       __func__);\n\t\t\t\tdvb_dmxdev_feed_restart(filter);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tdvb_dmxdev_feed_stop(filter);\n\t\t}\n\n\t\tret = (*secfeed)->allocate_filter(*secfeed, secfilter);\n\t\tif (ret < 0) {\n\t\t\tdvb_dmxdev_feed_restart(filter);\n\t\t\tfilter->feed.sec->start_filtering(*secfeed);\n\t\t\tdprintk(\"could not get filter\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t(*secfilter)->priv = filter;\n\n\t\tmemcpy(&((*secfilter)->filter_value[3]),\n\t\t       &(para->filter.filter[1]), DMX_FILTER_SIZE - 1);\n\t\tmemcpy(&(*secfilter)->filter_mask[3],\n\t\t       &para->filter.mask[1], DMX_FILTER_SIZE - 1);\n\t\tmemcpy(&(*secfilter)->filter_mode[3],\n\t\t       &para->filter.mode[1], DMX_FILTER_SIZE - 1);\n\n\t\t(*secfilter)->filter_value[0] = para->filter.filter[0];\n\t\t(*secfilter)->filter_mask[0] = para->filter.mask[0];\n\t\t(*secfilter)->filter_mode[0] = para->filter.mode[0];\n\t\t(*secfilter)->filter_mask[1] = 0;\n\t\t(*secfilter)->filter_mask[2] = 0;\n\n\t\tfilter->todo = 0;\n\n\t\tret = filter->feed.sec->start_filtering(filter->feed.sec);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdvb_dmxdev_filter_timer(filter);\n\t\tbreak;\n\t}\n\tcase DMXDEV_TYPE_PES:\n\t\tlist_for_each_entry(feed, &filter->feed.ts, next) {\n\t\t\tret = dvb_dmxdev_start_feed(dmxdev, filter, feed);\n\t\t\tif (ret < 0) {\n\t\t\t\tdvb_dmxdev_filter_stop(filter);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdvb_dmxdev_filter_state_set(filter, DMXDEV_STATE_GO);\n\treturn 0;\n}\n\nstatic int dvb_demux_open(struct inode *inode, struct file *file)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dmxdev *dmxdev = dvbdev->priv;\n\tint i;\n\tstruct dmxdev_filter *dmxdevfilter;\n\n\tif (!dmxdev->filter)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&dmxdev->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (dmxdev->exit) {\n\t\tmutex_unlock(&dmxdev->mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < dmxdev->filternum; i++)\n\t\tif (dmxdev->filter[i].state == DMXDEV_STATE_FREE)\n\t\t\tbreak;\n\n\tif (i == dmxdev->filternum) {\n\t\tmutex_unlock(&dmxdev->mutex);\n\t\treturn -EMFILE;\n\t}\n\n\tdmxdevfilter = &dmxdev->filter[i];\n\tmutex_init(&dmxdevfilter->mutex);\n\tfile->private_data = dmxdevfilter;\n\n#ifdef CONFIG_DVB_MMAP\n\tdmxdev->may_do_mmap = 1;\n#else\n\tdmxdev->may_do_mmap = 0;\n#endif\n\n\tdvb_ringbuffer_init(&dmxdevfilter->buffer, NULL, 8192);\n\tdvb_vb2_init(&dmxdevfilter->vb2_ctx, \"demux_filter\",\n\t\t     file->f_flags & O_NONBLOCK);\n\tdmxdevfilter->type = DMXDEV_TYPE_NONE;\n\tdvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_ALLOCATED);\n\ttimer_setup(&dmxdevfilter->timer, dvb_dmxdev_filter_timeout, 0);\n\n\tdvbdev->users++;\n\n\tmutex_unlock(&dmxdev->mutex);\n\treturn 0;\n}\n\nstatic int dvb_dmxdev_filter_free(struct dmxdev *dmxdev,\n\t\t\t\t  struct dmxdev_filter *dmxdevfilter)\n{\n\tmutex_lock(&dmxdev->mutex);\n\tmutex_lock(&dmxdevfilter->mutex);\n\tif (dvb_vb2_is_streaming(&dmxdevfilter->vb2_ctx))\n\t\tdvb_vb2_stream_off(&dmxdevfilter->vb2_ctx);\n\tdvb_vb2_release(&dmxdevfilter->vb2_ctx);\n\n\n\tdvb_dmxdev_filter_stop(dmxdevfilter);\n\tdvb_dmxdev_filter_reset(dmxdevfilter);\n\n\tif (dmxdevfilter->buffer.data) {\n\t\tvoid *mem = dmxdevfilter->buffer.data;\n\n\t\tspin_lock_irq(&dmxdev->lock);\n\t\tdmxdevfilter->buffer.data = NULL;\n\t\tspin_unlock_irq(&dmxdev->lock);\n\t\tvfree(mem);\n\t}\n\n\tdvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_FREE);\n\twake_up(&dmxdevfilter->buffer.queue);\n\tmutex_unlock(&dmxdevfilter->mutex);\n\tmutex_unlock(&dmxdev->mutex);\n\treturn 0;\n}\n\nstatic inline void invert_mode(struct dmx_filter *filter)\n{\n\tint i;\n\n\tfor (i = 0; i < DMX_FILTER_SIZE; i++)\n\t\tfilter->mode[i] ^= 0xff;\n}\n\nstatic int dvb_dmxdev_add_pid(struct dmxdev *dmxdev,\n\t\t\t      struct dmxdev_filter *filter, u16 pid)\n{\n\tstruct dmxdev_feed *feed;\n\n\tif ((filter->type != DMXDEV_TYPE_PES) ||\n\t    (filter->state < DMXDEV_STATE_SET))\n\t\treturn -EINVAL;\n\n\t \n\tif ((filter->params.pes.output != DMX_OUT_TSDEMUX_TAP) &&\n\t    (!list_empty(&filter->feed.ts)))\n\t\treturn -EINVAL;\n\n\tfeed = kzalloc(sizeof(struct dmxdev_feed), GFP_KERNEL);\n\tif (feed == NULL)\n\t\treturn -ENOMEM;\n\n\tfeed->pid = pid;\n\tlist_add(&feed->next, &filter->feed.ts);\n\n\tif (filter->state >= DMXDEV_STATE_GO)\n\t\treturn dvb_dmxdev_start_feed(dmxdev, filter, feed);\n\n\treturn 0;\n}\n\nstatic int dvb_dmxdev_remove_pid(struct dmxdev *dmxdev,\n\t\t\t\t  struct dmxdev_filter *filter, u16 pid)\n{\n\tstruct dmxdev_feed *feed, *tmp;\n\n\tif ((filter->type != DMXDEV_TYPE_PES) ||\n\t    (filter->state < DMXDEV_STATE_SET))\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry_safe(feed, tmp, &filter->feed.ts, next) {\n\t\tif ((feed->pid == pid) && (feed->ts != NULL)) {\n\t\t\tfeed->ts->stop_filtering(feed->ts);\n\t\t\tfilter->dev->demux->release_ts_feed(filter->dev->demux,\n\t\t\t\t\t\t\t    feed->ts);\n\t\t\tlist_del(&feed->next);\n\t\t\tkfree(feed);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dvb_dmxdev_filter_set(struct dmxdev *dmxdev,\n\t\t\t\t struct dmxdev_filter *dmxdevfilter,\n\t\t\t\t struct dmx_sct_filter_params *params)\n{\n\tdprintk(\"%s: PID=0x%04x, flags=%02x, timeout=%d\\n\",\n\t\t__func__, params->pid, params->flags, params->timeout);\n\n\tdvb_dmxdev_filter_stop(dmxdevfilter);\n\n\tdmxdevfilter->type = DMXDEV_TYPE_SEC;\n\tmemcpy(&dmxdevfilter->params.sec,\n\t       params, sizeof(struct dmx_sct_filter_params));\n\tinvert_mode(&dmxdevfilter->params.sec.filter);\n\tdvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_SET);\n\n\tif (params->flags & DMX_IMMEDIATE_START)\n\t\treturn dvb_dmxdev_filter_start(dmxdevfilter);\n\n\treturn 0;\n}\n\nstatic int dvb_dmxdev_pes_filter_set(struct dmxdev *dmxdev,\n\t\t\t\t     struct dmxdev_filter *dmxdevfilter,\n\t\t\t\t     struct dmx_pes_filter_params *params)\n{\n\tint ret;\n\n\tdvb_dmxdev_filter_stop(dmxdevfilter);\n\tdvb_dmxdev_filter_reset(dmxdevfilter);\n\n\tif ((unsigned int)params->pes_type > DMX_PES_OTHER)\n\t\treturn -EINVAL;\n\n\tdmxdevfilter->type = DMXDEV_TYPE_PES;\n\tmemcpy(&dmxdevfilter->params, params,\n\t       sizeof(struct dmx_pes_filter_params));\n\tINIT_LIST_HEAD(&dmxdevfilter->feed.ts);\n\n\tdvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_SET);\n\n\tret = dvb_dmxdev_add_pid(dmxdev, dmxdevfilter,\n\t\t\t\t dmxdevfilter->params.pes.pid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (params->flags & DMX_IMMEDIATE_START)\n\t\treturn dvb_dmxdev_filter_start(dmxdevfilter);\n\n\treturn 0;\n}\n\nstatic ssize_t dvb_dmxdev_read_sec(struct dmxdev_filter *dfil,\n\t\t\t\t   struct file *file, char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tint result, hcount;\n\tint done = 0;\n\n\tif (dfil->todo <= 0) {\n\t\thcount = 3 + dfil->todo;\n\t\tif (hcount > count)\n\t\t\thcount = count;\n\t\tresult = dvb_dmxdev_buffer_read(&dfil->buffer,\n\t\t\t\t\t\tfile->f_flags & O_NONBLOCK,\n\t\t\t\t\t\tbuf, hcount, ppos);\n\t\tif (result < 0) {\n\t\t\tdfil->todo = 0;\n\t\t\treturn result;\n\t\t}\n\t\tif (copy_from_user(dfil->secheader - dfil->todo, buf, result))\n\t\t\treturn -EFAULT;\n\t\tbuf += result;\n\t\tdone = result;\n\t\tcount -= result;\n\t\tdfil->todo -= result;\n\t\tif (dfil->todo > -3)\n\t\t\treturn done;\n\t\tdfil->todo = ((dfil->secheader[1] << 8) | dfil->secheader[2]) & 0xfff;\n\t\tif (!count)\n\t\t\treturn done;\n\t}\n\tif (count > dfil->todo)\n\t\tcount = dfil->todo;\n\tresult = dvb_dmxdev_buffer_read(&dfil->buffer,\n\t\t\t\t\tfile->f_flags & O_NONBLOCK,\n\t\t\t\t\tbuf, count, ppos);\n\tif (result < 0)\n\t\treturn result;\n\tdfil->todo -= result;\n\treturn (result + done);\n}\n\nstatic ssize_t\ndvb_demux_read(struct file *file, char __user *buf, size_t count,\n\t       loff_t *ppos)\n{\n\tstruct dmxdev_filter *dmxdevfilter = file->private_data;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&dmxdevfilter->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (dmxdevfilter->type == DMXDEV_TYPE_SEC)\n\t\tret = dvb_dmxdev_read_sec(dmxdevfilter, file, buf, count, ppos);\n\telse\n\t\tret = dvb_dmxdev_buffer_read(&dmxdevfilter->buffer,\n\t\t\t\t\t     file->f_flags & O_NONBLOCK,\n\t\t\t\t\t     buf, count, ppos);\n\n\tmutex_unlock(&dmxdevfilter->mutex);\n\treturn ret;\n}\n\nstatic int dvb_demux_do_ioctl(struct file *file,\n\t\t\t      unsigned int cmd, void *parg)\n{\n\tstruct dmxdev_filter *dmxdevfilter = file->private_data;\n\tstruct dmxdev *dmxdev = dmxdevfilter->dev;\n\tunsigned long arg = (unsigned long)parg;\n\tint ret = 0;\n\n\tif (mutex_lock_interruptible(&dmxdev->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase DMX_START:\n\t\tif (mutex_lock_interruptible(&dmxdevfilter->mutex)) {\n\t\t\tmutex_unlock(&dmxdev->mutex);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t\tif (dmxdevfilter->state < DMXDEV_STATE_SET)\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tret = dvb_dmxdev_filter_start(dmxdevfilter);\n\t\tmutex_unlock(&dmxdevfilter->mutex);\n\t\tbreak;\n\n\tcase DMX_STOP:\n\t\tif (mutex_lock_interruptible(&dmxdevfilter->mutex)) {\n\t\t\tmutex_unlock(&dmxdev->mutex);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t\tret = dvb_dmxdev_filter_stop(dmxdevfilter);\n\t\tmutex_unlock(&dmxdevfilter->mutex);\n\t\tbreak;\n\n\tcase DMX_SET_FILTER:\n\t\tif (mutex_lock_interruptible(&dmxdevfilter->mutex)) {\n\t\t\tmutex_unlock(&dmxdev->mutex);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t\tret = dvb_dmxdev_filter_set(dmxdev, dmxdevfilter, parg);\n\t\tmutex_unlock(&dmxdevfilter->mutex);\n\t\tbreak;\n\n\tcase DMX_SET_PES_FILTER:\n\t\tif (mutex_lock_interruptible(&dmxdevfilter->mutex)) {\n\t\t\tmutex_unlock(&dmxdev->mutex);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t\tret = dvb_dmxdev_pes_filter_set(dmxdev, dmxdevfilter, parg);\n\t\tmutex_unlock(&dmxdevfilter->mutex);\n\t\tbreak;\n\n\tcase DMX_SET_BUFFER_SIZE:\n\t\tif (mutex_lock_interruptible(&dmxdevfilter->mutex)) {\n\t\t\tmutex_unlock(&dmxdev->mutex);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t\tret = dvb_dmxdev_set_buffer_size(dmxdevfilter, arg);\n\t\tmutex_unlock(&dmxdevfilter->mutex);\n\t\tbreak;\n\n\tcase DMX_GET_PES_PIDS:\n\t\tif (!dmxdev->demux->get_pes_pids) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tdmxdev->demux->get_pes_pids(dmxdev->demux, parg);\n\t\tbreak;\n\n\tcase DMX_GET_STC:\n\t\tif (!dmxdev->demux->get_stc) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = dmxdev->demux->get_stc(dmxdev->demux,\n\t\t\t\t\t     ((struct dmx_stc *)parg)->num,\n\t\t\t\t\t     &((struct dmx_stc *)parg)->stc,\n\t\t\t\t\t     &((struct dmx_stc *)parg)->base);\n\t\tbreak;\n\n\tcase DMX_ADD_PID:\n\t\tif (mutex_lock_interruptible(&dmxdevfilter->mutex)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tret = dvb_dmxdev_add_pid(dmxdev, dmxdevfilter, *(u16 *)parg);\n\t\tmutex_unlock(&dmxdevfilter->mutex);\n\t\tbreak;\n\n\tcase DMX_REMOVE_PID:\n\t\tif (mutex_lock_interruptible(&dmxdevfilter->mutex)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tret = dvb_dmxdev_remove_pid(dmxdev, dmxdevfilter, *(u16 *)parg);\n\t\tmutex_unlock(&dmxdevfilter->mutex);\n\t\tbreak;\n\n#ifdef CONFIG_DVB_MMAP\n\tcase DMX_REQBUFS:\n\t\tif (mutex_lock_interruptible(&dmxdevfilter->mutex)) {\n\t\t\tmutex_unlock(&dmxdev->mutex);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t\tret = dvb_vb2_reqbufs(&dmxdevfilter->vb2_ctx, parg);\n\t\tmutex_unlock(&dmxdevfilter->mutex);\n\t\tbreak;\n\n\tcase DMX_QUERYBUF:\n\t\tif (mutex_lock_interruptible(&dmxdevfilter->mutex)) {\n\t\t\tmutex_unlock(&dmxdev->mutex);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t\tret = dvb_vb2_querybuf(&dmxdevfilter->vb2_ctx, parg);\n\t\tmutex_unlock(&dmxdevfilter->mutex);\n\t\tbreak;\n\n\tcase DMX_EXPBUF:\n\t\tif (mutex_lock_interruptible(&dmxdevfilter->mutex)) {\n\t\t\tmutex_unlock(&dmxdev->mutex);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t\tret = dvb_vb2_expbuf(&dmxdevfilter->vb2_ctx, parg);\n\t\tmutex_unlock(&dmxdevfilter->mutex);\n\t\tbreak;\n\n\tcase DMX_QBUF:\n\t\tif (mutex_lock_interruptible(&dmxdevfilter->mutex)) {\n\t\t\tmutex_unlock(&dmxdev->mutex);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t\tret = dvb_vb2_qbuf(&dmxdevfilter->vb2_ctx, parg);\n\t\tif (ret == 0 && !dvb_vb2_is_streaming(&dmxdevfilter->vb2_ctx))\n\t\t\tret = dvb_vb2_stream_on(&dmxdevfilter->vb2_ctx);\n\t\tmutex_unlock(&dmxdevfilter->mutex);\n\t\tbreak;\n\n\tcase DMX_DQBUF:\n\t\tif (mutex_lock_interruptible(&dmxdevfilter->mutex)) {\n\t\t\tmutex_unlock(&dmxdev->mutex);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t\tret = dvb_vb2_dqbuf(&dmxdevfilter->vb2_ctx, parg);\n\t\tmutex_unlock(&dmxdevfilter->mutex);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tret = -ENOTTY;\n\t\tbreak;\n\t}\n\tmutex_unlock(&dmxdev->mutex);\n\treturn ret;\n}\n\nstatic long dvb_demux_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\treturn dvb_usercopy(file, cmd, arg, dvb_demux_do_ioctl);\n}\n\nstatic __poll_t dvb_demux_poll(struct file *file, poll_table *wait)\n{\n\tstruct dmxdev_filter *dmxdevfilter = file->private_data;\n\t__poll_t mask = 0;\n\n\tpoll_wait(file, &dmxdevfilter->buffer.queue, wait);\n\n\tif ((!dmxdevfilter) || dmxdevfilter->dev->exit)\n\t\treturn EPOLLERR;\n\tif (dvb_vb2_is_streaming(&dmxdevfilter->vb2_ctx))\n\t\treturn dvb_vb2_poll(&dmxdevfilter->vb2_ctx, file, wait);\n\n\tif (dmxdevfilter->state != DMXDEV_STATE_GO &&\n\t    dmxdevfilter->state != DMXDEV_STATE_DONE &&\n\t    dmxdevfilter->state != DMXDEV_STATE_TIMEDOUT)\n\t\treturn 0;\n\n\tif (dmxdevfilter->buffer.error)\n\t\tmask |= (EPOLLIN | EPOLLRDNORM | EPOLLPRI | EPOLLERR);\n\n\tif (!dvb_ringbuffer_empty(&dmxdevfilter->buffer))\n\t\tmask |= (EPOLLIN | EPOLLRDNORM | EPOLLPRI);\n\n\treturn mask;\n}\n\n#ifdef CONFIG_DVB_MMAP\nstatic int dvb_demux_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct dmxdev_filter *dmxdevfilter = file->private_data;\n\tstruct dmxdev *dmxdev = dmxdevfilter->dev;\n\tint ret;\n\n\tif (!dmxdev->may_do_mmap)\n\t\treturn -ENOTTY;\n\n\tif (mutex_lock_interruptible(&dmxdev->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (mutex_lock_interruptible(&dmxdevfilter->mutex)) {\n\t\tmutex_unlock(&dmxdev->mutex);\n\t\treturn -ERESTARTSYS;\n\t}\n\tret = dvb_vb2_mmap(&dmxdevfilter->vb2_ctx, vma);\n\n\tmutex_unlock(&dmxdevfilter->mutex);\n\tmutex_unlock(&dmxdev->mutex);\n\n\treturn ret;\n}\n#endif\n\nstatic int dvb_demux_release(struct inode *inode, struct file *file)\n{\n\tstruct dmxdev_filter *dmxdevfilter = file->private_data;\n\tstruct dmxdev *dmxdev = dmxdevfilter->dev;\n\tint ret;\n\n\tret = dvb_dmxdev_filter_free(dmxdev, dmxdevfilter);\n\n\tmutex_lock(&dmxdev->mutex);\n\tdmxdev->dvbdev->users--;\n\tif (dmxdev->dvbdev->users == 1 && dmxdev->exit == 1) {\n\t\tmutex_unlock(&dmxdev->mutex);\n\t\twake_up(&dmxdev->dvbdev->wait_queue);\n\t} else\n\t\tmutex_unlock(&dmxdev->mutex);\n\n\treturn ret;\n}\n\nstatic const struct file_operations dvb_demux_fops = {\n\t.owner = THIS_MODULE,\n\t.read = dvb_demux_read,\n\t.unlocked_ioctl = dvb_demux_ioctl,\n\t.compat_ioctl = dvb_demux_ioctl,\n\t.open = dvb_demux_open,\n\t.release = dvb_demux_release,\n\t.poll = dvb_demux_poll,\n\t.llseek = default_llseek,\n#ifdef CONFIG_DVB_MMAP\n\t.mmap = dvb_demux_mmap,\n#endif\n};\n\nstatic const struct dvb_device dvbdev_demux = {\n\t.priv = NULL,\n\t.users = 1,\n\t.writers = 1,\n#if defined(CONFIG_MEDIA_CONTROLLER_DVB)\n\t.name = \"dvb-demux\",\n#endif\n\t.fops = &dvb_demux_fops\n};\n\nstatic int dvb_dvr_do_ioctl(struct file *file,\n\t\t\t    unsigned int cmd, void *parg)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dmxdev *dmxdev = dvbdev->priv;\n\tunsigned long arg = (unsigned long)parg;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&dmxdev->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase DMX_SET_BUFFER_SIZE:\n\t\tret = dvb_dvr_set_buffer_size(dmxdev, arg);\n\t\tbreak;\n\n#ifdef CONFIG_DVB_MMAP\n\tcase DMX_REQBUFS:\n\t\tret = dvb_vb2_reqbufs(&dmxdev->dvr_vb2_ctx, parg);\n\t\tbreak;\n\n\tcase DMX_QUERYBUF:\n\t\tret = dvb_vb2_querybuf(&dmxdev->dvr_vb2_ctx, parg);\n\t\tbreak;\n\n\tcase DMX_EXPBUF:\n\t\tret = dvb_vb2_expbuf(&dmxdev->dvr_vb2_ctx, parg);\n\t\tbreak;\n\n\tcase DMX_QBUF:\n\t\tret = dvb_vb2_qbuf(&dmxdev->dvr_vb2_ctx, parg);\n\t\tif (ret == 0 && !dvb_vb2_is_streaming(&dmxdev->dvr_vb2_ctx))\n\t\t\tret = dvb_vb2_stream_on(&dmxdev->dvr_vb2_ctx);\n\t\tbreak;\n\n\tcase DMX_DQBUF:\n\t\tret = dvb_vb2_dqbuf(&dmxdev->dvr_vb2_ctx, parg);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tret = -ENOTTY;\n\t\tbreak;\n\t}\n\tmutex_unlock(&dmxdev->mutex);\n\treturn ret;\n}\n\nstatic long dvb_dvr_ioctl(struct file *file,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\treturn dvb_usercopy(file, cmd, arg, dvb_dvr_do_ioctl);\n}\n\nstatic __poll_t dvb_dvr_poll(struct file *file, poll_table *wait)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dmxdev *dmxdev = dvbdev->priv;\n\t__poll_t mask = 0;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tpoll_wait(file, &dmxdev->dvr_buffer.queue, wait);\n\n\tif (dmxdev->exit)\n\t\treturn EPOLLERR;\n\tif (dvb_vb2_is_streaming(&dmxdev->dvr_vb2_ctx))\n\t\treturn dvb_vb2_poll(&dmxdev->dvr_vb2_ctx, file, wait);\n\n\tif (((file->f_flags & O_ACCMODE) == O_RDONLY) ||\n\t    dmxdev->may_do_mmap) {\n\t\tif (dmxdev->dvr_buffer.error)\n\t\t\tmask |= (EPOLLIN | EPOLLRDNORM | EPOLLPRI | EPOLLERR);\n\n\t\tif (!dvb_ringbuffer_empty(&dmxdev->dvr_buffer))\n\t\t\tmask |= (EPOLLIN | EPOLLRDNORM | EPOLLPRI);\n\t} else\n\t\tmask |= (EPOLLOUT | EPOLLWRNORM | EPOLLPRI);\n\n\treturn mask;\n}\n\n#ifdef CONFIG_DVB_MMAP\nstatic int dvb_dvr_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dmxdev *dmxdev = dvbdev->priv;\n\tint ret;\n\n\tif (!dmxdev->may_do_mmap)\n\t\treturn -ENOTTY;\n\n\tif (dmxdev->exit)\n\t\treturn -ENODEV;\n\n\tif (mutex_lock_interruptible(&dmxdev->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tret = dvb_vb2_mmap(&dmxdev->dvr_vb2_ctx, vma);\n\tmutex_unlock(&dmxdev->mutex);\n\treturn ret;\n}\n#endif\n\nstatic const struct file_operations dvb_dvr_fops = {\n\t.owner = THIS_MODULE,\n\t.read = dvb_dvr_read,\n\t.write = dvb_dvr_write,\n\t.unlocked_ioctl = dvb_dvr_ioctl,\n\t.open = dvb_dvr_open,\n\t.release = dvb_dvr_release,\n\t.poll = dvb_dvr_poll,\n\t.llseek = default_llseek,\n#ifdef CONFIG_DVB_MMAP\n\t.mmap = dvb_dvr_mmap,\n#endif\n};\n\nstatic const struct dvb_device dvbdev_dvr = {\n\t.priv = NULL,\n\t.readers = 1,\n\t.users = 1,\n#if defined(CONFIG_MEDIA_CONTROLLER_DVB)\n\t.name = \"dvb-dvr\",\n#endif\n\t.fops = &dvb_dvr_fops\n};\nint dvb_dmxdev_init(struct dmxdev *dmxdev, struct dvb_adapter *dvb_adapter)\n{\n\tint i, ret;\n\n\tif (dmxdev->demux->open(dmxdev->demux) < 0)\n\t\treturn -EUSERS;\n\n\tdmxdev->filter = vmalloc(array_size(sizeof(struct dmxdev_filter),\n\t\t\t\t\t    dmxdev->filternum));\n\tif (!dmxdev->filter)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dmxdev->mutex);\n\tspin_lock_init(&dmxdev->lock);\n\tfor (i = 0; i < dmxdev->filternum; i++) {\n\t\tdmxdev->filter[i].dev = dmxdev;\n\t\tdmxdev->filter[i].buffer.data = NULL;\n\t\tdvb_dmxdev_filter_state_set(&dmxdev->filter[i],\n\t\t\t\t\t    DMXDEV_STATE_FREE);\n\t}\n\n\tret = dvb_register_device(dvb_adapter, &dmxdev->dvbdev, &dvbdev_demux, dmxdev,\n\t\t\t    DVB_DEVICE_DEMUX, dmxdev->filternum);\n\tif (ret < 0)\n\t\tgoto err_register_dvbdev;\n\n\tret = dvb_register_device(dvb_adapter, &dmxdev->dvr_dvbdev, &dvbdev_dvr,\n\t\t\t    dmxdev, DVB_DEVICE_DVR, dmxdev->filternum);\n\tif (ret < 0)\n\t\tgoto err_register_dvr_dvbdev;\n\n\tdvb_ringbuffer_init(&dmxdev->dvr_buffer, NULL, 8192);\n\n\treturn 0;\n\nerr_register_dvr_dvbdev:\n\tdvb_unregister_device(dmxdev->dvbdev);\nerr_register_dvbdev:\n\tvfree(dmxdev->filter);\n\tdmxdev->filter = NULL;\n\treturn ret;\n}\n\nEXPORT_SYMBOL(dvb_dmxdev_init);\n\nvoid dvb_dmxdev_release(struct dmxdev *dmxdev)\n{\n\tmutex_lock(&dmxdev->mutex);\n\tdmxdev->exit = 1;\n\tmutex_unlock(&dmxdev->mutex);\n\n\tif (dmxdev->dvbdev->users > 1) {\n\t\twait_event(dmxdev->dvbdev->wait_queue,\n\t\t\t\tdmxdev->dvbdev->users == 1);\n\t}\n\tif (dmxdev->dvr_dvbdev->users > 1) {\n\t\twait_event(dmxdev->dvr_dvbdev->wait_queue,\n\t\t\t\tdmxdev->dvr_dvbdev->users == 1);\n\t}\n\n\tdvb_unregister_device(dmxdev->dvbdev);\n\tdvb_unregister_device(dmxdev->dvr_dvbdev);\n\n\tvfree(dmxdev->filter);\n\tdmxdev->filter = NULL;\n\tdmxdev->demux->close(dmxdev->demux);\n}\n\nEXPORT_SYMBOL(dvb_dmxdev_release);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}