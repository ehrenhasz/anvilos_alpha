{
  "module_name": "dvb_ca_en50221.c",
  "hash_id": "dd60e1cbd5667e04a3ed387af6c15f3fcb1034754cf85aaa98846466af558fda",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-core/dvb_ca_en50221.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"dvb_ca_en50221: \" fmt\n\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/nospec.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/sched/signal.h>\n#include <linux/kthread.h>\n\n#include <media/dvb_ca_en50221.h>\n#include <media/dvb_ringbuffer.h>\n\nstatic int dvb_ca_en50221_debug;\n\nmodule_param_named(cam_debug, dvb_ca_en50221_debug, int, 0644);\nMODULE_PARM_DESC(cam_debug, \"enable verbose debug messages\");\n\n#define dprintk(fmt, arg...) do {\t\t\t\t\t\\\n\tif (dvb_ca_en50221_debug)\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt), __func__, ##arg);\\\n} while (0)\n\n#define INIT_TIMEOUT_SECS 10\n\n#define HOST_LINK_BUF_SIZE 0x200\n\n#define RX_BUFFER_SIZE 65535\n\n#define MAX_RX_PACKETS_PER_ITERATION 10\n\n#define CTRLIF_DATA      0\n#define CTRLIF_COMMAND   1\n#define CTRLIF_STATUS    1\n#define CTRLIF_SIZE_LOW  2\n#define CTRLIF_SIZE_HIGH 3\n\n#define CMDREG_HC        1\t \n#define CMDREG_SW        2\t \n#define CMDREG_SR        4\t \n#define CMDREG_RS        8\t \n#define CMDREG_FRIE   0x40\t \n#define CMDREG_DAIE   0x80\t \n#define IRQEN (CMDREG_DAIE)\n\n#define STATUSREG_RE     1\t \n#define STATUSREG_WE     2\t \n#define STATUSREG_FR  0x40\t \n#define STATUSREG_DA  0x80\t \n\n#define DVB_CA_SLOTSTATE_NONE           0\n#define DVB_CA_SLOTSTATE_UNINITIALISED  1\n#define DVB_CA_SLOTSTATE_RUNNING        2\n#define DVB_CA_SLOTSTATE_INVALID        3\n#define DVB_CA_SLOTSTATE_WAITREADY      4\n#define DVB_CA_SLOTSTATE_VALIDATE       5\n#define DVB_CA_SLOTSTATE_WAITFR         6\n#define DVB_CA_SLOTSTATE_LINKINIT       7\n\n \nstruct dvb_ca_slot {\n\t \n\tint slot_state;\n\n\t \n\tstruct mutex slot_lock;\n\n\t \n\tatomic_t camchange_count;\n\n\t \n\tint camchange_type;\n\n\t \n\tu32 config_base;\n\n\t \n\tu8 config_option;\n\n\t \n\tu8 da_irq_supported:1;\n\n\t \n\tint link_buf_size;\n\n\t \n\tstruct dvb_ringbuffer rx_buffer;\n\n\t \n\tunsigned long timeout;\n};\n\n \nstruct dvb_ca_private {\n\tstruct kref refcount;\n\n\t \n\tstruct dvb_ca_en50221 *pub;\n\n\t \n\tstruct dvb_device *dvbdev;\n\n\t \n\tu32 flags;\n\n\t \n\tunsigned int slot_count;\n\n\t \n\tstruct dvb_ca_slot *slot_info;\n\n\t \n\twait_queue_head_t wait_queue;\n\n\t \n\tstruct task_struct *thread;\n\n\t \n\tunsigned int open:1;\n\n\t \n\tunsigned int wakeup:1;\n\n\t \n\tunsigned long delay;\n\n\t \n\tint next_read_slot;\n\n\t \n\tstruct mutex ioctl_mutex;\n\n\t \n\tstruct mutex remove_mutex;\n\n\t \n\tint exit;\n};\n\nstatic void dvb_ca_private_free(struct dvb_ca_private *ca)\n{\n\tunsigned int i;\n\n\tdvb_device_put(ca->dvbdev);\n\tfor (i = 0; i < ca->slot_count; i++)\n\t\tvfree(ca->slot_info[i].rx_buffer.data);\n\n\tkfree(ca->slot_info);\n\tkfree(ca);\n}\n\nstatic void dvb_ca_private_release(struct kref *ref)\n{\n\tstruct dvb_ca_private *ca;\n\n\tca = container_of(ref, struct dvb_ca_private, refcount);\n\tdvb_ca_private_free(ca);\n}\n\nstatic void dvb_ca_private_get(struct dvb_ca_private *ca)\n{\n\tkref_get(&ca->refcount);\n}\n\nstatic void dvb_ca_private_put(struct dvb_ca_private *ca)\n{\n\tkref_put(&ca->refcount, dvb_ca_private_release);\n}\n\nstatic void dvb_ca_en50221_thread_wakeup(struct dvb_ca_private *ca);\nstatic int dvb_ca_en50221_read_data(struct dvb_ca_private *ca, int slot,\n\t\t\t\t    u8 *ebuf, int ecount);\nstatic int dvb_ca_en50221_write_data(struct dvb_ca_private *ca, int slot,\n\t\t\t\t     u8 *ebuf, int ecount, int size_write_flag);\n\n \nstatic char *findstr(char *haystack, int hlen, char *needle, int nlen)\n{\n\tint i;\n\n\tif (hlen < nlen)\n\t\treturn NULL;\n\n\tfor (i = 0; i <= hlen - nlen; i++) {\n\t\tif (!strncmp(haystack + i, needle, nlen))\n\t\t\treturn haystack + i;\n\t}\n\n\treturn NULL;\n}\n\n \n \n\n \nstatic int dvb_ca_en50221_check_camstatus(struct dvb_ca_private *ca, int slot)\n{\n\tstruct dvb_ca_slot *sl = &ca->slot_info[slot];\n\tint slot_status;\n\tint cam_present_now;\n\tint cam_changed;\n\n\t \n\tif (ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE)\n\t\treturn (atomic_read(&sl->camchange_count) != 0);\n\n\t \n\tslot_status = ca->pub->poll_slot_status(ca->pub, slot, ca->open);\n\n\tcam_present_now = (slot_status & DVB_CA_EN50221_POLL_CAM_PRESENT) ? 1 : 0;\n\tcam_changed = (slot_status & DVB_CA_EN50221_POLL_CAM_CHANGED) ? 1 : 0;\n\tif (!cam_changed) {\n\t\tint cam_present_old = (sl->slot_state != DVB_CA_SLOTSTATE_NONE);\n\n\t\tcam_changed = (cam_present_now != cam_present_old);\n\t}\n\n\tif (cam_changed) {\n\t\tif (!cam_present_now)\n\t\t\tsl->camchange_type = DVB_CA_EN50221_CAMCHANGE_REMOVED;\n\t\telse\n\t\t\tsl->camchange_type = DVB_CA_EN50221_CAMCHANGE_INSERTED;\n\t\tatomic_set(&sl->camchange_count, 1);\n\t} else {\n\t\tif ((sl->slot_state == DVB_CA_SLOTSTATE_WAITREADY) &&\n\t\t    (slot_status & DVB_CA_EN50221_POLL_CAM_READY)) {\n\t\t\t \n\t\t\tsl->slot_state = DVB_CA_SLOTSTATE_VALIDATE;\n\t\t}\n\t}\n\n\treturn cam_changed;\n}\n\n \nstatic int dvb_ca_en50221_wait_if_status(struct dvb_ca_private *ca, int slot,\n\t\t\t\t\t u8 waitfor, int timeout_hz)\n{\n\tunsigned long timeout;\n\tunsigned long start;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\tstart = jiffies;\n\ttimeout = jiffies + timeout_hz;\n\twhile (1) {\n\t\tint res;\n\n\t\t \n\t\tres = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS);\n\t\tif (res < 0)\n\t\t\treturn -EIO;\n\n\t\t \n\t\tif (res & waitfor) {\n\t\t\tdprintk(\"%s succeeded timeout:%lu\\n\",\n\t\t\t\t__func__, jiffies - start);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\n\t\t \n\t\tusleep_range(1000, 1100);\n\t}\n\n\tdprintk(\"%s failed timeout:%lu\\n\", __func__, jiffies - start);\n\n\t \n\treturn -ETIMEDOUT;\n}\n\n \nstatic int dvb_ca_en50221_link_init(struct dvb_ca_private *ca, int slot)\n{\n\tstruct dvb_ca_slot *sl = &ca->slot_info[slot];\n\tint ret;\n\tint buf_size;\n\tu8 buf[2];\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\tsl->da_irq_supported = 0;\n\n\t \n\tsl->link_buf_size = 2;\n\n\t \n\tret = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND,\n\t\t\t\t\t IRQEN | CMDREG_SR);\n\tif (ret)\n\t\treturn ret;\n\tret = dvb_ca_en50221_wait_if_status(ca, slot, STATUSREG_DA, HZ);\n\tif (ret)\n\t\treturn ret;\n\tret = dvb_ca_en50221_read_data(ca, slot, buf, 2);\n\tif (ret != 2)\n\t\treturn -EIO;\n\tret = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, IRQEN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tbuf_size = (buf[0] << 8) | buf[1];\n\tif (buf_size > HOST_LINK_BUF_SIZE)\n\t\tbuf_size = HOST_LINK_BUF_SIZE;\n\tsl->link_buf_size = buf_size;\n\tbuf[0] = buf_size >> 8;\n\tbuf[1] = buf_size & 0xff;\n\tdprintk(\"Chosen link buffer size of %i\\n\", buf_size);\n\n\t \n\tret = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND,\n\t\t\t\t\t IRQEN | CMDREG_SW);\n\tif (ret)\n\t\treturn ret;\n\tret = dvb_ca_en50221_wait_if_status(ca, slot, STATUSREG_FR, HZ / 10);\n\tif (ret)\n\t\treturn ret;\n\tret = dvb_ca_en50221_write_data(ca, slot, buf, 2, CMDREG_SW);\n\tif (ret != 2)\n\t\treturn -EIO;\n\tret = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, IRQEN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn 0;\n}\n\n \nstatic int dvb_ca_en50221_read_tuple(struct dvb_ca_private *ca, int slot,\n\t\t\t\t     int *address, int *tuple_type,\n\t\t\t\t     int *tuple_length, u8 *tuple)\n{\n\tint i;\n\tint _tuple_type;\n\tint _tuple_length;\n\tint _address = *address;\n\n\t \n\t_tuple_type = ca->pub->read_attribute_mem(ca->pub, slot, _address);\n\tif (_tuple_type < 0)\n\t\treturn _tuple_type;\n\tif (_tuple_type == 0xff) {\n\t\tdprintk(\"END OF CHAIN TUPLE type:0x%x\\n\", _tuple_type);\n\t\t*address += 2;\n\t\t*tuple_type = _tuple_type;\n\t\t*tuple_length = 0;\n\t\treturn 0;\n\t}\n\t_tuple_length = ca->pub->read_attribute_mem(ca->pub, slot,\n\t\t\t\t\t\t    _address + 2);\n\tif (_tuple_length < 0)\n\t\treturn _tuple_length;\n\t_address += 4;\n\n\tdprintk(\"TUPLE type:0x%x length:%i\\n\", _tuple_type, _tuple_length);\n\n\t \n\tfor (i = 0; i < _tuple_length; i++) {\n\t\ttuple[i] = ca->pub->read_attribute_mem(ca->pub, slot,\n\t\t\t\t\t\t       _address + (i * 2));\n\t\tdprintk(\"  0x%02x: 0x%02x %c\\n\",\n\t\t\ti, tuple[i] & 0xff,\n\t\t\t((tuple[i] > 31) && (tuple[i] < 127)) ? tuple[i] : '.');\n\t}\n\t_address += (_tuple_length * 2);\n\n\t \n\t*tuple_type = _tuple_type;\n\t*tuple_length = _tuple_length;\n\t*address = _address;\n\treturn 0;\n}\n\n \nstatic int dvb_ca_en50221_parse_attributes(struct dvb_ca_private *ca, int slot)\n{\n\tstruct dvb_ca_slot *sl;\n\tint address = 0;\n\tint tuple_length;\n\tint tuple_type;\n\tu8 tuple[257];\n\tchar *dvb_str;\n\tint rasz;\n\tint status;\n\tint got_cftableentry = 0;\n\tint end_chain = 0;\n\tint i;\n\tu16 manfid = 0;\n\tu16 devid = 0;\n\n\t \n\tstatus = dvb_ca_en50221_read_tuple(ca, slot, &address, &tuple_type,\n\t\t\t\t\t   &tuple_length, tuple);\n\tif (status < 0)\n\t\treturn status;\n\tif (tuple_type != 0x1D)\n\t\treturn -EINVAL;\n\n\t \n\tstatus = dvb_ca_en50221_read_tuple(ca, slot, &address, &tuple_type,\n\t\t\t\t\t   &tuple_length, tuple);\n\tif (status < 0)\n\t\treturn status;\n\tif (tuple_type != 0x1C)\n\t\treturn -EINVAL;\n\n\t \n\tstatus = dvb_ca_en50221_read_tuple(ca, slot, &address, &tuple_type,\n\t\t\t\t\t   &tuple_length, tuple);\n\tif (status < 0)\n\t\treturn status;\n\tif (tuple_type != 0x15)\n\t\treturn -EINVAL;\n\n\t \n\tstatus = dvb_ca_en50221_read_tuple(ca, slot, &address, &tuple_type,\n\t\t\t\t\t   &tuple_length, tuple);\n\tif (status < 0)\n\t\treturn status;\n\tif (tuple_type != 0x20)\n\t\treturn -EINVAL;\n\tif (tuple_length != 4)\n\t\treturn -EINVAL;\n\tmanfid = (tuple[1] << 8) | tuple[0];\n\tdevid = (tuple[3] << 8) | tuple[2];\n\n\t \n\tstatus = dvb_ca_en50221_read_tuple(ca, slot, &address, &tuple_type,\n\t\t\t\t\t   &tuple_length, tuple);\n\tif (status < 0)\n\t\treturn status;\n\tif (tuple_type != 0x1A)\n\t\treturn -EINVAL;\n\tif (tuple_length < 3)\n\t\treturn -EINVAL;\n\n\t \n\trasz = tuple[0] & 3;\n\tif (tuple_length < (3 + rasz + 14))\n\t\treturn -EINVAL;\n\tsl = &ca->slot_info[slot];\n\tsl->config_base = 0;\n\tfor (i = 0; i < rasz + 1; i++)\n\t\tsl->config_base |= (tuple[2 + i] << (8 * i));\n\n\t \n\tdvb_str = findstr((char *)tuple, tuple_length, \"DVB_CI_V\", 8);\n\tif (!dvb_str)\n\t\treturn -EINVAL;\n\tif (tuple_length < ((dvb_str - (char *)tuple) + 12))\n\t\treturn -EINVAL;\n\n\t \n\tif (strncmp(dvb_str + 8, \"1.00\", 4)) {\n\t\tpr_err(\"dvb_ca adapter %d: Unsupported DVB CAM module version %c%c%c%c\\n\",\n\t\t       ca->dvbdev->adapter->num, dvb_str[8], dvb_str[9],\n\t\t       dvb_str[10], dvb_str[11]);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twhile ((!end_chain) && (address < 0x1000)) {\n\t\tstatus = dvb_ca_en50221_read_tuple(ca, slot, &address,\n\t\t\t\t\t\t   &tuple_type, &tuple_length,\n\t\t\t\t\t\t   tuple);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tswitch (tuple_type) {\n\t\tcase 0x1B:\t \n\t\t\tif (tuple_length < (2 + 11 + 17))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (got_cftableentry)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tsl->config_option = tuple[0] & 0x3f;\n\n\t\t\t \n\t\t\tif (!findstr((char *)tuple, tuple_length,\n\t\t\t\t     \"DVB_HOST\", 8) ||\n\t\t\t    !findstr((char *)tuple, tuple_length,\n\t\t\t\t     \"DVB_CI_MODULE\", 13))\n\t\t\t\tbreak;\n\n\t\t\tgot_cftableentry = 1;\n\t\t\tbreak;\n\n\t\tcase 0x14:\t \n\t\t\tbreak;\n\n\t\tcase 0xFF:\t \n\t\t\tend_chain = 1;\n\t\t\tbreak;\n\n\t\tdefault:\t \n\t\t\tdprintk(\"dvb_ca: Skipping unknown tuple type:0x%x length:0x%x\\n\",\n\t\t\t\ttuple_type, tuple_length);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((address > 0x1000) || (!got_cftableentry))\n\t\treturn -EINVAL;\n\n\tdprintk(\"Valid DVB CAM detected MANID:%x DEVID:%x CONFIGBASE:0x%x CONFIGOPTION:0x%x\\n\",\n\t\tmanfid, devid, sl->config_base, sl->config_option);\n\n\t \n\treturn 0;\n}\n\n \nstatic int dvb_ca_en50221_set_configoption(struct dvb_ca_private *ca, int slot)\n{\n\tstruct dvb_ca_slot *sl = &ca->slot_info[slot];\n\tint configoption;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\tca->pub->write_attribute_mem(ca->pub, slot, sl->config_base,\n\t\t\t\t     sl->config_option);\n\n\t \n\tconfigoption = ca->pub->read_attribute_mem(ca->pub, slot,\n\t\t\t\t\t\t   sl->config_base);\n\tdprintk(\"Set configoption 0x%x, read configoption 0x%x\\n\",\n\t\tsl->config_option, configoption & 0x3f);\n\n\t \n\treturn 0;\n}\n\n \nstatic int dvb_ca_en50221_read_data(struct dvb_ca_private *ca, int slot,\n\t\t\t\t    u8 *ebuf, int ecount)\n{\n\tstruct dvb_ca_slot *sl = &ca->slot_info[slot];\n\tint bytes_read;\n\tint status;\n\tu8 buf[HOST_LINK_BUF_SIZE];\n\tint i;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\tif (!ebuf) {\n\t\tint buf_free;\n\n\t\tif (!sl->rx_buffer.data) {\n\t\t\tstatus = -EIO;\n\t\t\tgoto exit;\n\t\t}\n\t\tbuf_free = dvb_ringbuffer_free(&sl->rx_buffer);\n\n\t\tif (buf_free < (sl->link_buf_size +\n\t\t\t\tDVB_RINGBUFFER_PKTHDRSIZE)) {\n\t\t\tstatus = -EAGAIN;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (ca->pub->read_data &&\n\t    (sl->slot_state != DVB_CA_SLOTSTATE_LINKINIT)) {\n\t\tif (!ebuf)\n\t\t\tstatus = ca->pub->read_data(ca->pub, slot, buf,\n\t\t\t\t\t\t    sizeof(buf));\n\t\telse\n\t\t\tstatus = ca->pub->read_data(ca->pub, slot, buf, ecount);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tbytes_read =  status;\n\t\tif (status == 0)\n\t\t\tgoto exit;\n\t} else {\n\t\t \n\t\tstatus = ca->pub->read_cam_control(ca->pub, slot,\n\t\t\t\t\t\t   CTRLIF_STATUS);\n\t\tif (status < 0)\n\t\t\tgoto exit;\n\t\tif (!(status & STATUSREG_DA)) {\n\t\t\t \n\t\t\tstatus = 0;\n\t\t\tgoto exit;\n\t\t}\n\n\t\t \n\t\tstatus = ca->pub->read_cam_control(ca->pub, slot,\n\t\t\t\t\t\t   CTRLIF_SIZE_HIGH);\n\t\tif (status < 0)\n\t\t\tgoto exit;\n\t\tbytes_read = status << 8;\n\t\tstatus = ca->pub->read_cam_control(ca->pub, slot,\n\t\t\t\t\t\t   CTRLIF_SIZE_LOW);\n\t\tif (status < 0)\n\t\t\tgoto exit;\n\t\tbytes_read |= status;\n\n\t\t \n\t\tif (!ebuf) {\n\t\t\tif (bytes_read > sl->link_buf_size) {\n\t\t\t\tpr_err(\"dvb_ca adapter %d: CAM tried to send a buffer larger than the link buffer size (%i > %i)!\\n\",\n\t\t\t\t       ca->dvbdev->adapter->num, bytes_read,\n\t\t\t\t       sl->link_buf_size);\n\t\t\t\tsl->slot_state = DVB_CA_SLOTSTATE_LINKINIT;\n\t\t\t\tstatus = -EIO;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tif (bytes_read < 2) {\n\t\t\t\tpr_err(\"dvb_ca adapter %d: CAM sent a buffer that was less than 2 bytes!\\n\",\n\t\t\t\t       ca->dvbdev->adapter->num);\n\t\t\t\tsl->slot_state = DVB_CA_SLOTSTATE_LINKINIT;\n\t\t\t\tstatus = -EIO;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tif (bytes_read > ecount) {\n\t\t\t\tpr_err(\"dvb_ca adapter %d: CAM tried to send a buffer larger than the ecount size!\\n\",\n\t\t\t\t       ca->dvbdev->adapter->num);\n\t\t\t\tstatus = -EIO;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < bytes_read; i++) {\n\t\t\t \n\t\t\tstatus = ca->pub->read_cam_control(ca->pub, slot,\n\t\t\t\t\t\t\t   CTRLIF_DATA);\n\t\t\tif (status < 0)\n\t\t\t\tgoto exit;\n\n\t\t\t \n\t\t\tbuf[i] = status;\n\t\t}\n\n\t\t \n\t\tstatus = ca->pub->read_cam_control(ca->pub, slot,\n\t\t\t\t\t\t   CTRLIF_STATUS);\n\t\tif (status < 0)\n\t\t\tgoto exit;\n\t\tif (status & STATUSREG_RE) {\n\t\t\tsl->slot_state = DVB_CA_SLOTSTATE_LINKINIT;\n\t\t\tstatus = -EIO;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t \n\tif (!ebuf) {\n\t\tif (!sl->rx_buffer.data) {\n\t\t\tstatus = -EIO;\n\t\t\tgoto exit;\n\t\t}\n\t\tdvb_ringbuffer_pkt_write(&sl->rx_buffer, buf, bytes_read);\n\t} else {\n\t\tmemcpy(ebuf, buf, bytes_read);\n\t}\n\n\tdprintk(\"Received CA packet for slot %i connection id 0x%x last_frag:%i size:0x%x\\n\", slot,\n\t\tbuf[0], (buf[1] & 0x80) == 0, bytes_read);\n\n\t \n\tif ((buf[1] & 0x80) == 0x00)\n\t\twake_up_interruptible(&ca->wait_queue);\n\n\tstatus = bytes_read;\n\nexit:\n\treturn status;\n}\n\n \nstatic int dvb_ca_en50221_write_data(struct dvb_ca_private *ca, int slot,\n\t\t\t\t     u8 *buf, int bytes_write, int size_write_flag)\n{\n\tstruct dvb_ca_slot *sl = &ca->slot_info[slot];\n\tint status;\n\tint i;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\tif (bytes_write > sl->link_buf_size)\n\t\treturn -EINVAL;\n\n\tif (ca->pub->write_data &&\n\t    (sl->slot_state != DVB_CA_SLOTSTATE_LINKINIT))\n\t\treturn ca->pub->write_data(ca->pub, slot, buf, bytes_write);\n\n\t \n\tstatus = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS);\n\tif (status < 0)\n\t\tgoto exitnowrite;\n\tif (status & (STATUSREG_DA | STATUSREG_RE)) {\n\t\tif (status & STATUSREG_DA)\n\t\t\tdvb_ca_en50221_thread_wakeup(ca);\n\n\t\tstatus = -EAGAIN;\n\t\tgoto exitnowrite;\n\t}\n\n\t \n\tstatus = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND,\n\t\t\t\t\t    IRQEN | CMDREG_HC | size_write_flag);\n\tif (status)\n\t\tgoto exit;\n\n\t \n\tstatus = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS);\n\tif (status < 0)\n\t\tgoto exit;\n\tif (!(status & STATUSREG_FR)) {\n\t\t \n\t\tstatus = -EAGAIN;\n\t\tgoto exit;\n\t}\n\n\t \n\tstatus = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS);\n\tif (status < 0)\n\t\tgoto exit;\n\n\tif (status & (STATUSREG_DA | STATUSREG_RE)) {\n\t\tif (status & STATUSREG_DA)\n\t\t\tdvb_ca_en50221_thread_wakeup(ca);\n\n\t\tstatus = -EAGAIN;\n\t\tgoto exit;\n\t}\n\n\t \n\tstatus = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_SIZE_HIGH,\n\t\t\t\t\t    bytes_write >> 8);\n\tif (status)\n\t\tgoto exit;\n\tstatus = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_SIZE_LOW,\n\t\t\t\t\t    bytes_write & 0xff);\n\tif (status)\n\t\tgoto exit;\n\n\t \n\tfor (i = 0; i < bytes_write; i++) {\n\t\tstatus = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_DATA,\n\t\t\t\t\t\t    buf[i]);\n\t\tif (status)\n\t\t\tgoto exit;\n\t}\n\n\t \n\tstatus = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS);\n\tif (status < 0)\n\t\tgoto exit;\n\tif (status & STATUSREG_WE) {\n\t\tsl->slot_state = DVB_CA_SLOTSTATE_LINKINIT;\n\t\tstatus = -EIO;\n\t\tgoto exit;\n\t}\n\tstatus = bytes_write;\n\n\tdprintk(\"Wrote CA packet for slot %i, connection id 0x%x last_frag:%i size:0x%x\\n\", slot,\n\t\tbuf[0], (buf[1] & 0x80) == 0, bytes_write);\n\nexit:\n\tca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, IRQEN);\n\nexitnowrite:\n\treturn status;\n}\n\n \n \n\n \nstatic int dvb_ca_en50221_slot_shutdown(struct dvb_ca_private *ca, int slot)\n{\n\tdprintk(\"%s\\n\", __func__);\n\n\tca->pub->slot_shutdown(ca->pub, slot);\n\tca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_NONE;\n\n\t \n\twake_up_interruptible(&ca->wait_queue);\n\n\tdprintk(\"Slot %i shutdown\\n\", slot);\n\n\t \n\treturn 0;\n}\n\n \nvoid dvb_ca_en50221_camchange_irq(struct dvb_ca_en50221 *pubca, int slot,\n\t\t\t\t  int change_type)\n{\n\tstruct dvb_ca_private *ca = pubca->private;\n\tstruct dvb_ca_slot *sl = &ca->slot_info[slot];\n\n\tdprintk(\"CAMCHANGE IRQ slot:%i change_type:%i\\n\", slot, change_type);\n\n\tswitch (change_type) {\n\tcase DVB_CA_EN50221_CAMCHANGE_REMOVED:\n\tcase DVB_CA_EN50221_CAMCHANGE_INSERTED:\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tsl->camchange_type = change_type;\n\tatomic_inc(&sl->camchange_count);\n\tdvb_ca_en50221_thread_wakeup(ca);\n}\nEXPORT_SYMBOL(dvb_ca_en50221_camchange_irq);\n\n \nvoid dvb_ca_en50221_camready_irq(struct dvb_ca_en50221 *pubca, int slot)\n{\n\tstruct dvb_ca_private *ca = pubca->private;\n\tstruct dvb_ca_slot *sl = &ca->slot_info[slot];\n\n\tdprintk(\"CAMREADY IRQ slot:%i\\n\", slot);\n\n\tif (sl->slot_state == DVB_CA_SLOTSTATE_WAITREADY) {\n\t\tsl->slot_state = DVB_CA_SLOTSTATE_VALIDATE;\n\t\tdvb_ca_en50221_thread_wakeup(ca);\n\t}\n}\nEXPORT_SYMBOL(dvb_ca_en50221_camready_irq);\n\n \nvoid dvb_ca_en50221_frda_irq(struct dvb_ca_en50221 *pubca, int slot)\n{\n\tstruct dvb_ca_private *ca = pubca->private;\n\tstruct dvb_ca_slot *sl = &ca->slot_info[slot];\n\tint flags;\n\n\tdprintk(\"FR/DA IRQ slot:%i\\n\", slot);\n\n\tswitch (sl->slot_state) {\n\tcase DVB_CA_SLOTSTATE_LINKINIT:\n\t\tflags = ca->pub->read_cam_control(pubca, slot, CTRLIF_STATUS);\n\t\tif (flags & STATUSREG_DA) {\n\t\t\tdprintk(\"CAM supports DA IRQ\\n\");\n\t\t\tsl->da_irq_supported = 1;\n\t\t}\n\t\tbreak;\n\n\tcase DVB_CA_SLOTSTATE_RUNNING:\n\t\tif (ca->open)\n\t\t\tdvb_ca_en50221_thread_wakeup(ca);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(dvb_ca_en50221_frda_irq);\n\n \n \n\n \nstatic void dvb_ca_en50221_thread_wakeup(struct dvb_ca_private *ca)\n{\n\tdprintk(\"%s\\n\", __func__);\n\n\tca->wakeup = 1;\n\tmb();\n\twake_up_process(ca->thread);\n}\n\n \nstatic void dvb_ca_en50221_thread_update_delay(struct dvb_ca_private *ca)\n{\n\tint delay;\n\tint curdelay = 100000000;\n\tint slot;\n\n\t \n\tfor (slot = 0; slot < ca->slot_count; slot++) {\n\t\tstruct dvb_ca_slot *sl = &ca->slot_info[slot];\n\n\t\tswitch (sl->slot_state) {\n\t\tdefault:\n\t\tcase DVB_CA_SLOTSTATE_NONE:\n\t\t\tdelay = HZ * 60;   \n\t\t\tif (!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE))\n\t\t\t\tdelay = HZ * 5;   \n\t\t\tbreak;\n\t\tcase DVB_CA_SLOTSTATE_INVALID:\n\t\t\tdelay = HZ * 60;   \n\t\t\tif (!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE))\n\t\t\t\tdelay = HZ / 10;   \n\t\t\tbreak;\n\n\t\tcase DVB_CA_SLOTSTATE_UNINITIALISED:\n\t\tcase DVB_CA_SLOTSTATE_WAITREADY:\n\t\tcase DVB_CA_SLOTSTATE_VALIDATE:\n\t\tcase DVB_CA_SLOTSTATE_WAITFR:\n\t\tcase DVB_CA_SLOTSTATE_LINKINIT:\n\t\t\tdelay = HZ / 10;   \n\t\t\tbreak;\n\n\t\tcase DVB_CA_SLOTSTATE_RUNNING:\n\t\t\tdelay = HZ * 60;   \n\t\t\tif (!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE))\n\t\t\t\tdelay = HZ / 10;   \n\t\t\tif (ca->open) {\n\t\t\t\tif ((!sl->da_irq_supported) ||\n\t\t\t\t    (!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_DA)))\n\t\t\t\t\tdelay = HZ / 10;   \n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (delay < curdelay)\n\t\t\tcurdelay = delay;\n\t}\n\n\tca->delay = curdelay;\n}\n\n \n\nstatic int dvb_ca_en50221_poll_cam_gone(struct dvb_ca_private *ca, int slot)\n{\n\tint changed = 0;\n\tint status;\n\n\t \n\tif ((!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE)) &&\n\t    (ca->pub->poll_slot_status)) {\n\t\tstatus = ca->pub->poll_slot_status(ca->pub, slot, 0);\n\t\tif (!(status &\n\t\t\tDVB_CA_EN50221_POLL_CAM_PRESENT)) {\n\t\t\tca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_NONE;\n\t\t\tdvb_ca_en50221_thread_update_delay(ca);\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\treturn changed;\n}\n\n \nstatic void dvb_ca_en50221_thread_state_machine(struct dvb_ca_private *ca,\n\t\t\t\t\t\tint slot)\n{\n\tstruct dvb_ca_slot *sl = &ca->slot_info[slot];\n\tint flags;\n\tint pktcount;\n\tvoid *rxbuf;\n\n\tmutex_lock(&sl->slot_lock);\n\n\t \n\twhile (dvb_ca_en50221_check_camstatus(ca, slot)) {\n\t\t \n\t\tif (sl->slot_state != DVB_CA_SLOTSTATE_NONE)\n\t\t\tdvb_ca_en50221_slot_shutdown(ca, slot);\n\n\t\t \n\t\tif (sl->camchange_type == DVB_CA_EN50221_CAMCHANGE_INSERTED)\n\t\t\tsl->slot_state = DVB_CA_SLOTSTATE_UNINITIALISED;\n\n\t\t \n\t\tdvb_ca_en50221_thread_update_delay(ca);\n\t\tatomic_dec(&sl->camchange_count);\n\t}\n\n\t \n\tswitch (sl->slot_state) {\n\tcase DVB_CA_SLOTSTATE_NONE:\n\tcase DVB_CA_SLOTSTATE_INVALID:\n\t\t \n\t\tbreak;\n\n\tcase DVB_CA_SLOTSTATE_UNINITIALISED:\n\t\tsl->slot_state = DVB_CA_SLOTSTATE_WAITREADY;\n\t\tca->pub->slot_reset(ca->pub, slot);\n\t\tsl->timeout = jiffies + (INIT_TIMEOUT_SECS * HZ);\n\t\tbreak;\n\n\tcase DVB_CA_SLOTSTATE_WAITREADY:\n\t\tif (time_after(jiffies, sl->timeout)) {\n\t\t\tpr_err(\"dvb_ca adaptor %d: PC card did not respond :(\\n\",\n\t\t\t       ca->dvbdev->adapter->num);\n\t\t\tsl->slot_state = DVB_CA_SLOTSTATE_INVALID;\n\t\t\tdvb_ca_en50221_thread_update_delay(ca);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tbreak;\n\n\tcase DVB_CA_SLOTSTATE_VALIDATE:\n\t\tif (dvb_ca_en50221_parse_attributes(ca, slot) != 0) {\n\t\t\tif (dvb_ca_en50221_poll_cam_gone(ca, slot))\n\t\t\t\tbreak;\n\n\t\t\tpr_err(\"dvb_ca adapter %d: Invalid PC card inserted :(\\n\",\n\t\t\t       ca->dvbdev->adapter->num);\n\t\t\tsl->slot_state = DVB_CA_SLOTSTATE_INVALID;\n\t\t\tdvb_ca_en50221_thread_update_delay(ca);\n\t\t\tbreak;\n\t\t}\n\t\tif (dvb_ca_en50221_set_configoption(ca, slot) != 0) {\n\t\t\tpr_err(\"dvb_ca adapter %d: Unable to initialise CAM :(\\n\",\n\t\t\t       ca->dvbdev->adapter->num);\n\t\t\tsl->slot_state = DVB_CA_SLOTSTATE_INVALID;\n\t\t\tdvb_ca_en50221_thread_update_delay(ca);\n\t\t\tbreak;\n\t\t}\n\t\tif (ca->pub->write_cam_control(ca->pub, slot,\n\t\t\t\t\t       CTRLIF_COMMAND,\n\t\t\t\t\t       CMDREG_RS) != 0) {\n\t\t\tpr_err(\"dvb_ca adapter %d: Unable to reset CAM IF\\n\",\n\t\t\t       ca->dvbdev->adapter->num);\n\t\t\tsl->slot_state = DVB_CA_SLOTSTATE_INVALID;\n\t\t\tdvb_ca_en50221_thread_update_delay(ca);\n\t\t\tbreak;\n\t\t}\n\t\tdprintk(\"DVB CAM validated successfully\\n\");\n\n\t\tsl->timeout = jiffies + (INIT_TIMEOUT_SECS * HZ);\n\t\tsl->slot_state = DVB_CA_SLOTSTATE_WAITFR;\n\t\tca->wakeup = 1;\n\t\tbreak;\n\n\tcase DVB_CA_SLOTSTATE_WAITFR:\n\t\tif (time_after(jiffies, sl->timeout)) {\n\t\t\tpr_err(\"dvb_ca adapter %d: DVB CAM did not respond :(\\n\",\n\t\t\t       ca->dvbdev->adapter->num);\n\t\t\tsl->slot_state = DVB_CA_SLOTSTATE_INVALID;\n\t\t\tdvb_ca_en50221_thread_update_delay(ca);\n\t\t\tbreak;\n\t\t}\n\n\t\tflags = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS);\n\t\tif (flags & STATUSREG_FR) {\n\t\t\tsl->slot_state = DVB_CA_SLOTSTATE_LINKINIT;\n\t\t\tca->wakeup = 1;\n\t\t}\n\t\tbreak;\n\n\tcase DVB_CA_SLOTSTATE_LINKINIT:\n\t\tif (dvb_ca_en50221_link_init(ca, slot) != 0) {\n\t\t\tif (dvb_ca_en50221_poll_cam_gone(ca, slot))\n\t\t\t\tbreak;\n\n\t\t\tpr_err(\"dvb_ca adapter %d: DVB CAM link initialisation failed :(\\n\",\n\t\t\t       ca->dvbdev->adapter->num);\n\t\t\tsl->slot_state = DVB_CA_SLOTSTATE_UNINITIALISED;\n\t\t\tdvb_ca_en50221_thread_update_delay(ca);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!sl->rx_buffer.data) {\n\t\t\trxbuf = vmalloc(RX_BUFFER_SIZE);\n\t\t\tif (!rxbuf) {\n\t\t\t\tpr_err(\"dvb_ca adapter %d: Unable to allocate CAM rx buffer :(\\n\",\n\t\t\t\t       ca->dvbdev->adapter->num);\n\t\t\t\tsl->slot_state = DVB_CA_SLOTSTATE_INVALID;\n\t\t\t\tdvb_ca_en50221_thread_update_delay(ca);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdvb_ringbuffer_init(&sl->rx_buffer, rxbuf,\n\t\t\t\t\t    RX_BUFFER_SIZE);\n\t\t}\n\n\t\tca->pub->slot_ts_enable(ca->pub, slot);\n\t\tsl->slot_state = DVB_CA_SLOTSTATE_RUNNING;\n\t\tdvb_ca_en50221_thread_update_delay(ca);\n\t\tpr_info(\"dvb_ca adapter %d: DVB CAM detected and initialised successfully\\n\",\n\t\t\tca->dvbdev->adapter->num);\n\t\tbreak;\n\n\tcase DVB_CA_SLOTSTATE_RUNNING:\n\t\tif (!ca->open)\n\t\t\tbreak;\n\n\t\t \n\t\tpktcount = 0;\n\t\twhile (dvb_ca_en50221_read_data(ca, slot, NULL, 0) > 0) {\n\t\t\tif (!ca->open)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (dvb_ca_en50221_check_camstatus(ca, slot)) {\n\t\t\t\t \n\t\t\t\tca->wakeup = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (++pktcount >= MAX_RX_PACKETS_PER_ITERATION) {\n\t\t\t\t \n\t\t\t\tca->wakeup = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&sl->slot_lock);\n}\n\n \nstatic int dvb_ca_en50221_thread(void *data)\n{\n\tstruct dvb_ca_private *ca = data;\n\tint slot;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\tdvb_ca_en50221_thread_update_delay(ca);\n\n\t \n\twhile (!kthread_should_stop()) {\n\t\t \n\t\tif (!ca->wakeup) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule_timeout(ca->delay);\n\t\t\tif (kthread_should_stop())\n\t\t\t\treturn 0;\n\t\t}\n\t\tca->wakeup = 0;\n\n\t\t \n\t\tfor (slot = 0; slot < ca->slot_count; slot++)\n\t\t\tdvb_ca_en50221_thread_state_machine(ca, slot);\n\t}\n\n\treturn 0;\n}\n\n \n \n\n \nstatic int dvb_ca_en50221_io_do_ioctl(struct file *file,\n\t\t\t\t      unsigned int cmd, void *parg)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dvb_ca_private *ca = dvbdev->priv;\n\tint err = 0;\n\tint slot;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (mutex_lock_interruptible(&ca->ioctl_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase CA_RESET:\n\t\tfor (slot = 0; slot < ca->slot_count; slot++) {\n\t\t\tstruct dvb_ca_slot *sl = &ca->slot_info[slot];\n\n\t\t\tmutex_lock(&sl->slot_lock);\n\t\t\tif (sl->slot_state != DVB_CA_SLOTSTATE_NONE) {\n\t\t\t\tdvb_ca_en50221_slot_shutdown(ca, slot);\n\t\t\t\tif (ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE)\n\t\t\t\t\tdvb_ca_en50221_camchange_irq(ca->pub,\n\t\t\t\t\t\t\t\t     slot,\n\t\t\t\t\t\t\t\t     DVB_CA_EN50221_CAMCHANGE_INSERTED);\n\t\t\t}\n\t\t\tmutex_unlock(&sl->slot_lock);\n\t\t}\n\t\tca->next_read_slot = 0;\n\t\tdvb_ca_en50221_thread_wakeup(ca);\n\t\tbreak;\n\n\tcase CA_GET_CAP: {\n\t\tstruct ca_caps *caps = parg;\n\n\t\tcaps->slot_num = ca->slot_count;\n\t\tcaps->slot_type = CA_CI_LINK;\n\t\tcaps->descr_num = 0;\n\t\tcaps->descr_type = 0;\n\t\tbreak;\n\t}\n\n\tcase CA_GET_SLOT_INFO: {\n\t\tstruct ca_slot_info *info = parg;\n\t\tstruct dvb_ca_slot *sl;\n\n\t\tslot = info->num;\n\t\tif ((slot >= ca->slot_count) || (slot < 0)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tslot = array_index_nospec(slot, ca->slot_count);\n\n\t\tinfo->type = CA_CI_LINK;\n\t\tinfo->flags = 0;\n\t\tsl = &ca->slot_info[slot];\n\t\tif ((sl->slot_state != DVB_CA_SLOTSTATE_NONE) &&\n\t\t    (sl->slot_state != DVB_CA_SLOTSTATE_INVALID)) {\n\t\t\tinfo->flags = CA_CI_MODULE_PRESENT;\n\t\t}\n\t\tif (sl->slot_state == DVB_CA_SLOTSTATE_RUNNING)\n\t\t\tinfo->flags |= CA_CI_MODULE_READY;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\nout_unlock:\n\tmutex_unlock(&ca->ioctl_mutex);\n\treturn err;\n}\n\n \nstatic long dvb_ca_en50221_io_ioctl(struct file *file,\n\t\t\t\t    unsigned int cmd, unsigned long arg)\n{\n\treturn dvb_usercopy(file, cmd, arg, dvb_ca_en50221_io_do_ioctl);\n}\n\n \nstatic ssize_t dvb_ca_en50221_io_write(struct file *file,\n\t\t\t\t       const char __user *buf, size_t count,\n\t\t\t\t       loff_t *ppos)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dvb_ca_private *ca = dvbdev->priv;\n\tstruct dvb_ca_slot *sl;\n\tu8 slot, connection_id;\n\tint status;\n\tu8 fragbuf[HOST_LINK_BUF_SIZE];\n\tint fragpos = 0;\n\tint fraglen;\n\tunsigned long timeout;\n\tint written;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\tif (count < 2)\n\t\treturn -EINVAL;\n\n\t \n\tif (copy_from_user(&slot, buf, 1))\n\t\treturn -EFAULT;\n\tif (copy_from_user(&connection_id, buf + 1, 1))\n\t\treturn -EFAULT;\n\tbuf += 2;\n\tcount -= 2;\n\n\tif (slot >= ca->slot_count)\n\t\treturn -EINVAL;\n\tslot = array_index_nospec(slot, ca->slot_count);\n\tsl = &ca->slot_info[slot];\n\n\t \n\tif (sl->slot_state != DVB_CA_SLOTSTATE_RUNNING)\n\t\treturn -EINVAL;\n\n\t \n\twhile (fragpos < count) {\n\t\tfraglen = sl->link_buf_size - 2;\n\t\tif (fraglen < 0)\n\t\t\tbreak;\n\t\tif (fraglen > HOST_LINK_BUF_SIZE - 2)\n\t\t\tfraglen = HOST_LINK_BUF_SIZE - 2;\n\t\tif ((count - fragpos) < fraglen)\n\t\t\tfraglen = count - fragpos;\n\n\t\tfragbuf[0] = connection_id;\n\t\tfragbuf[1] = ((fragpos + fraglen) < count) ? 0x80 : 0x00;\n\t\tstatus = copy_from_user(fragbuf + 2, buf + fragpos, fraglen);\n\t\tif (status) {\n\t\t\tstatus = -EFAULT;\n\t\t\tgoto exit;\n\t\t}\n\n\t\ttimeout = jiffies + HZ / 2;\n\t\twritten = 0;\n\t\twhile (!time_after(jiffies, timeout)) {\n\t\t\t \n\t\t\tif (sl->slot_state != DVB_CA_SLOTSTATE_RUNNING) {\n\t\t\t\tstatus = -EIO;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tmutex_lock(&sl->slot_lock);\n\t\t\tstatus = dvb_ca_en50221_write_data(ca, slot, fragbuf,\n\t\t\t\t\t\t\t   fraglen + 2, 0);\n\t\t\tmutex_unlock(&sl->slot_lock);\n\t\t\tif (status == (fraglen + 2)) {\n\t\t\t\twritten = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (status != -EAGAIN)\n\t\t\t\tgoto exit;\n\n\t\t\tusleep_range(1000, 1100);\n\t\t}\n\t\tif (!written) {\n\t\t\tstatus = -EIO;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tfragpos += fraglen;\n\t}\n\tstatus = count + 2;\n\nexit:\n\treturn status;\n}\n\n \nstatic int dvb_ca_en50221_io_read_condition(struct dvb_ca_private *ca,\n\t\t\t\t\t    int *result, int *_slot)\n{\n\tint slot;\n\tint slot_count = 0;\n\tint idx;\n\tsize_t fraglen;\n\tint connection_id = -1;\n\tint found = 0;\n\tu8 hdr[2];\n\n\tslot = ca->next_read_slot;\n\twhile ((slot_count < ca->slot_count) && (!found)) {\n\t\tstruct dvb_ca_slot *sl = &ca->slot_info[slot];\n\n\t\tif (sl->slot_state != DVB_CA_SLOTSTATE_RUNNING)\n\t\t\tgoto nextslot;\n\n\t\tif (!sl->rx_buffer.data)\n\t\t\treturn 0;\n\n\t\tidx = dvb_ringbuffer_pkt_next(&sl->rx_buffer, -1, &fraglen);\n\t\twhile (idx != -1) {\n\t\t\tdvb_ringbuffer_pkt_read(&sl->rx_buffer, idx, 0, hdr, 2);\n\t\t\tif (connection_id == -1)\n\t\t\t\tconnection_id = hdr[0];\n\t\t\tif ((hdr[0] == connection_id) &&\n\t\t\t    ((hdr[1] & 0x80) == 0)) {\n\t\t\t\t*_slot = slot;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tidx = dvb_ringbuffer_pkt_next(&sl->rx_buffer, idx,\n\t\t\t\t\t\t      &fraglen);\n\t\t}\n\nnextslot:\n\t\tslot = (slot + 1) % ca->slot_count;\n\t\tslot_count++;\n\t}\n\n\tca->next_read_slot = slot;\n\treturn found;\n}\n\n \nstatic ssize_t dvb_ca_en50221_io_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dvb_ca_private *ca = dvbdev->priv;\n\tstruct dvb_ca_slot *sl;\n\tint status;\n\tint result = 0;\n\tu8 hdr[2];\n\tint slot;\n\tint connection_id = -1;\n\tsize_t idx, idx2;\n\tint last_fragment = 0;\n\tsize_t fraglen;\n\tint pktlen;\n\tint dispose = 0;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\tif (count < 2)\n\t\treturn -EINVAL;\n\n\t \n\tstatus = dvb_ca_en50221_io_read_condition(ca, &result, &slot);\n\tif (status == 0) {\n\t\t \n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EWOULDBLOCK;\n\n\t\t \n\t\tstatus = wait_event_interruptible(ca->wait_queue,\n\t\t\t\t\t\t  dvb_ca_en50221_io_read_condition\n\t\t\t\t\t\t  (ca, &result, &slot));\n\t}\n\tif ((status < 0) || (result < 0)) {\n\t\tif (result)\n\t\t\treturn result;\n\t\treturn status;\n\t}\n\n\tsl = &ca->slot_info[slot];\n\tidx = dvb_ringbuffer_pkt_next(&sl->rx_buffer, -1, &fraglen);\n\tpktlen = 2;\n\tdo {\n\t\tif (idx == -1) {\n\t\t\tpr_err(\"dvb_ca adapter %d: BUG: read packet ended before last_fragment encountered\\n\",\n\t\t\t       ca->dvbdev->adapter->num);\n\t\t\tstatus = -EIO;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tdvb_ringbuffer_pkt_read(&sl->rx_buffer, idx, 0, hdr, 2);\n\t\tif (connection_id == -1)\n\t\t\tconnection_id = hdr[0];\n\t\tif (hdr[0] == connection_id) {\n\t\t\tif (pktlen < count) {\n\t\t\t\tif ((pktlen + fraglen - 2) > count)\n\t\t\t\t\tfraglen = count - pktlen;\n\t\t\t\telse\n\t\t\t\t\tfraglen -= 2;\n\n\t\t\t\tstatus =\n\t\t\t\t   dvb_ringbuffer_pkt_read_user(&sl->rx_buffer,\n\t\t\t\t\t\t\t\tidx, 2,\n\t\t\t\t\t\t\t\tbuf + pktlen,\n\t\t\t\t\t\t\t\tfraglen);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tgoto exit;\n\n\t\t\t\tpktlen += fraglen;\n\t\t\t}\n\n\t\t\tif ((hdr[1] & 0x80) == 0)\n\t\t\t\tlast_fragment = 1;\n\t\t\tdispose = 1;\n\t\t}\n\n\t\tidx2 = dvb_ringbuffer_pkt_next(&sl->rx_buffer, idx, &fraglen);\n\t\tif (dispose)\n\t\t\tdvb_ringbuffer_pkt_dispose(&sl->rx_buffer, idx);\n\t\tidx = idx2;\n\t\tdispose = 0;\n\t} while (!last_fragment);\n\n\thdr[0] = slot;\n\thdr[1] = connection_id;\n\tstatus = copy_to_user(buf, hdr, 2);\n\tif (status) {\n\t\tstatus = -EFAULT;\n\t\tgoto exit;\n\t}\n\tstatus = pktlen;\n\nexit:\n\treturn status;\n}\n\n \nstatic int dvb_ca_en50221_io_open(struct inode *inode, struct file *file)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dvb_ca_private *ca = dvbdev->priv;\n\tint err;\n\tint i;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tmutex_lock(&ca->remove_mutex);\n\n\tif (ca->exit) {\n\t\tmutex_unlock(&ca->remove_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!try_module_get(ca->pub->owner)) {\n\t\tmutex_unlock(&ca->remove_mutex);\n\t\treturn -EIO;\n\t}\n\n\terr = dvb_generic_open(inode, file);\n\tif (err < 0) {\n\t\tmodule_put(ca->pub->owner);\n\t\tmutex_unlock(&ca->remove_mutex);\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < ca->slot_count; i++) {\n\t\tstruct dvb_ca_slot *sl = &ca->slot_info[i];\n\n\t\tif (sl->slot_state == DVB_CA_SLOTSTATE_RUNNING) {\n\t\t\tif (!sl->rx_buffer.data) {\n\t\t\t\t \n\t\t\t\tdvb_ringbuffer_flush(&sl->rx_buffer);\n\t\t\t}\n\t\t}\n\t}\n\n\tca->open = 1;\n\tdvb_ca_en50221_thread_update_delay(ca);\n\tdvb_ca_en50221_thread_wakeup(ca);\n\n\tdvb_ca_private_get(ca);\n\n\tmutex_unlock(&ca->remove_mutex);\n\treturn 0;\n}\n\n \nstatic int dvb_ca_en50221_io_release(struct inode *inode, struct file *file)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dvb_ca_private *ca = dvbdev->priv;\n\tint err;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tmutex_lock(&ca->remove_mutex);\n\n\t \n\tca->open = 0;\n\tdvb_ca_en50221_thread_update_delay(ca);\n\n\terr = dvb_generic_release(inode, file);\n\n\tmodule_put(ca->pub->owner);\n\n\tdvb_ca_private_put(ca);\n\n\tif (dvbdev->users == 1 && ca->exit == 1) {\n\t\tmutex_unlock(&ca->remove_mutex);\n\t\twake_up(&dvbdev->wait_queue);\n\t} else {\n\t\tmutex_unlock(&ca->remove_mutex);\n\t}\n\n\treturn err;\n}\n\n \nstatic __poll_t dvb_ca_en50221_io_poll(struct file *file, poll_table *wait)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dvb_ca_private *ca = dvbdev->priv;\n\t__poll_t mask = 0;\n\tint slot;\n\tint result = 0;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tpoll_wait(file, &ca->wait_queue, wait);\n\n\tif (dvb_ca_en50221_io_read_condition(ca, &result, &slot) == 1)\n\t\tmask |= EPOLLIN;\n\n\t \n\tif (mask)\n\t\treturn mask;\n\n\tif (dvb_ca_en50221_io_read_condition(ca, &result, &slot) == 1)\n\t\tmask |= EPOLLIN;\n\n\treturn mask;\n}\n\nstatic const struct file_operations dvb_ca_fops = {\n\t.owner = THIS_MODULE,\n\t.read = dvb_ca_en50221_io_read,\n\t.write = dvb_ca_en50221_io_write,\n\t.unlocked_ioctl = dvb_ca_en50221_io_ioctl,\n\t.open = dvb_ca_en50221_io_open,\n\t.release = dvb_ca_en50221_io_release,\n\t.poll = dvb_ca_en50221_io_poll,\n\t.llseek = noop_llseek,\n};\n\nstatic const struct dvb_device dvbdev_ca = {\n\t.priv = NULL,\n\t.users = 1,\n\t.readers = 1,\n\t.writers = 1,\n#if defined(CONFIG_MEDIA_CONTROLLER_DVB)\n\t.name = \"dvb-ca-en50221\",\n#endif\n\t.fops = &dvb_ca_fops,\n};\n\n \n \n\n \nint dvb_ca_en50221_init(struct dvb_adapter *dvb_adapter,\n\t\t\tstruct dvb_ca_en50221 *pubca, int flags, int slot_count)\n{\n\tint ret;\n\tstruct dvb_ca_private *ca = NULL;\n\tint i;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (slot_count < 1)\n\t\treturn -EINVAL;\n\n\t \n\tca = kzalloc(sizeof(*ca), GFP_KERNEL);\n\tif (!ca) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\tkref_init(&ca->refcount);\n\tca->pub = pubca;\n\tca->flags = flags;\n\tca->slot_count = slot_count;\n\tca->slot_info = kcalloc(slot_count, sizeof(struct dvb_ca_slot),\n\t\t\t\tGFP_KERNEL);\n\tif (!ca->slot_info) {\n\t\tret = -ENOMEM;\n\t\tgoto free_ca;\n\t}\n\tinit_waitqueue_head(&ca->wait_queue);\n\tca->open = 0;\n\tca->wakeup = 0;\n\tca->next_read_slot = 0;\n\tpubca->private = ca;\n\n\t \n\tret = dvb_register_device(dvb_adapter, &ca->dvbdev, &dvbdev_ca, ca,\n\t\t\t\t  DVB_DEVICE_CA, 0);\n\tif (ret)\n\t\tgoto free_slot_info;\n\n\t \n\tfor (i = 0; i < slot_count; i++) {\n\t\tstruct dvb_ca_slot *sl = &ca->slot_info[i];\n\n\t\tmemset(sl, 0, sizeof(struct dvb_ca_slot));\n\t\tsl->slot_state = DVB_CA_SLOTSTATE_NONE;\n\t\tatomic_set(&sl->camchange_count, 0);\n\t\tsl->camchange_type = DVB_CA_EN50221_CAMCHANGE_REMOVED;\n\t\tmutex_init(&sl->slot_lock);\n\t}\n\n\tmutex_init(&ca->ioctl_mutex);\n\tmutex_init(&ca->remove_mutex);\n\n\tif (signal_pending(current)) {\n\t\tret = -EINTR;\n\t\tgoto unregister_device;\n\t}\n\tmb();\n\n\t \n\tca->thread = kthread_run(dvb_ca_en50221_thread, ca, \"kdvb-ca-%i:%i\",\n\t\t\t\t ca->dvbdev->adapter->num, ca->dvbdev->id);\n\tif (IS_ERR(ca->thread)) {\n\t\tret = PTR_ERR(ca->thread);\n\t\tpr_err(\"dvb_ca_init: failed to start kernel_thread (%d)\\n\",\n\t\t       ret);\n\t\tgoto unregister_device;\n\t}\n\treturn 0;\n\nunregister_device:\n\tdvb_unregister_device(ca->dvbdev);\nfree_slot_info:\n\tkfree(ca->slot_info);\nfree_ca:\n\tkfree(ca);\nexit:\n\tpubca->private = NULL;\n\treturn ret;\n}\nEXPORT_SYMBOL(dvb_ca_en50221_init);\n\n \nvoid dvb_ca_en50221_release(struct dvb_ca_en50221 *pubca)\n{\n\tstruct dvb_ca_private *ca = pubca->private;\n\tint i;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tmutex_lock(&ca->remove_mutex);\n\tca->exit = 1;\n\tmutex_unlock(&ca->remove_mutex);\n\n\tif (ca->dvbdev->users < 1)\n\t\twait_event(ca->dvbdev->wait_queue,\n\t\t\t\tca->dvbdev->users == 1);\n\n\t \n\tkthread_stop(ca->thread);\n\n\tfor (i = 0; i < ca->slot_count; i++)\n\t\tdvb_ca_en50221_slot_shutdown(ca, i);\n\n\tdvb_remove_device(ca->dvbdev);\n\tdvb_ca_private_put(ca);\n\tpubca->private = NULL;\n}\nEXPORT_SYMBOL(dvb_ca_en50221_release);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}