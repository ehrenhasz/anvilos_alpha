{
  "module_name": "dvb_demux.c",
  "hash_id": "71e0b07a3f56e31d4f21b22c62891175849bb80eac95cf544192cc7583f8a689",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-core/dvb_demux.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"dvb_demux: \" fmt\n\n#include <linux/sched/signal.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/poll.h>\n#include <linux/string.h>\n#include <linux/crc32.h>\n#include <linux/uaccess.h>\n#include <asm/div64.h>\n\n#include <media/dvb_demux.h>\n\nstatic int dvb_demux_tscheck;\nmodule_param(dvb_demux_tscheck, int, 0644);\nMODULE_PARM_DESC(dvb_demux_tscheck,\n\t\t\"enable transport stream continuity and TEI check\");\n\nstatic int dvb_demux_speedcheck;\nmodule_param(dvb_demux_speedcheck, int, 0644);\nMODULE_PARM_DESC(dvb_demux_speedcheck,\n\t\t\"enable transport stream speed check\");\n\nstatic int dvb_demux_feed_err_pkts = 1;\nmodule_param(dvb_demux_feed_err_pkts, int, 0644);\nMODULE_PARM_DESC(dvb_demux_feed_err_pkts,\n\t\t \"when set to 0, drop packets with the TEI bit set (1 by default)\");\n\n#define dprintk(fmt, arg...) \\\n\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt),  __func__, ##arg)\n\n#define dprintk_tscheck(x...) do {\t\t\t\\\n\tif (dvb_demux_tscheck && printk_ratelimit())\t\\\n\t\tdprintk(x);\t\t\t\t\\\n} while (0)\n\n#ifdef CONFIG_DVB_DEMUX_SECTION_LOSS_LOG\n#  define dprintk_sect_loss(x...) dprintk(x)\n#else\n#  define dprintk_sect_loss(x...)\n#endif\n\n#define set_buf_flags(__feed, __flag)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\t(__feed)->buffer_flags |= (__flag);\t\\\n\t} while (0)\n\n \n\nstatic inline u16 section_length(const u8 *buf)\n{\n\treturn 3 + ((buf[1] & 0x0f) << 8) + buf[2];\n}\n\nstatic inline u16 ts_pid(const u8 *buf)\n{\n\treturn ((buf[1] & 0x1f) << 8) + buf[2];\n}\n\nstatic inline u8 payload(const u8 *tsp)\n{\n\tif (!(tsp[3] & 0x10))\t\n\t\treturn 0;\n\n\tif (tsp[3] & 0x20) {\t\n\t\tif (tsp[4] > 183)\t\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn 184 - 1 - tsp[4];\n\t}\n\n\treturn 184;\n}\n\nstatic u32 dvb_dmx_crc32(struct dvb_demux_feed *f, const u8 *src, size_t len)\n{\n\treturn (f->feed.sec.crc_val = crc32_be(f->feed.sec.crc_val, src, len));\n}\n\nstatic void dvb_dmx_memcopy(struct dvb_demux_feed *f, u8 *d, const u8 *s,\n\t\t\t    size_t len)\n{\n\tmemcpy(d, s, len);\n}\n\n \n\nstatic inline int dvb_dmx_swfilter_payload(struct dvb_demux_feed *feed,\n\t\t\t\t\t   const u8 *buf)\n{\n\tint count = payload(buf);\n\tint p;\n\tint ccok;\n\tu8 cc;\n\n\tif (count == 0)\n\t\treturn -1;\n\n\tp = 188 - count;\n\n\tcc = buf[3] & 0x0f;\n\tccok = ((feed->cc + 1) & 0x0f) == cc;\n\tif (!ccok) {\n\t\tset_buf_flags(feed, DMX_BUFFER_FLAG_DISCONTINUITY_DETECTED);\n\t\tdprintk_sect_loss(\"missed packet: %d instead of %d!\\n\",\n\t\t\t\t  cc, (feed->cc + 1) & 0x0f);\n\t}\n\tfeed->cc = cc;\n\n\tif (buf[1] & 0x40)\t\n\t\tfeed->peslen = 0xfffa;\n\n\tfeed->peslen += count;\n\n\treturn feed->cb.ts(&buf[p], count, NULL, 0, &feed->feed.ts,\n\t\t\t   &feed->buffer_flags);\n}\n\nstatic int dvb_dmx_swfilter_sectionfilter(struct dvb_demux_feed *feed,\n\t\t\t\t\t  struct dvb_demux_filter *f)\n{\n\tu8 neq = 0;\n\tint i;\n\n\tfor (i = 0; i < DVB_DEMUX_MASK_MAX; i++) {\n\t\tu8 xor = f->filter.filter_value[i] ^ feed->feed.sec.secbuf[i];\n\n\t\tif (f->maskandmode[i] & xor)\n\t\t\treturn 0;\n\n\t\tneq |= f->maskandnotmode[i] & xor;\n\t}\n\n\tif (f->doneq && !neq)\n\t\treturn 0;\n\n\treturn feed->cb.sec(feed->feed.sec.secbuf, feed->feed.sec.seclen,\n\t\t\t    NULL, 0, &f->filter, &feed->buffer_flags);\n}\n\nstatic inline int dvb_dmx_swfilter_section_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct dvb_demux_filter *f = feed->filter;\n\tstruct dmx_section_feed *sec = &feed->feed.sec;\n\tint section_syntax_indicator;\n\n\tif (!sec->is_filtering)\n\t\treturn 0;\n\n\tif (!f)\n\t\treturn 0;\n\n\tif (sec->check_crc) {\n\t\tsection_syntax_indicator = ((sec->secbuf[1] & 0x80) != 0);\n\t\tif (section_syntax_indicator &&\n\t\t    demux->check_crc32(feed, sec->secbuf, sec->seclen)) {\n\t\t\tset_buf_flags(feed, DMX_BUFFER_FLAG_HAD_CRC32_DISCARD);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tdo {\n\t\tif (dvb_dmx_swfilter_sectionfilter(feed, f) < 0)\n\t\t\treturn -1;\n\t} while ((f = f->next) && sec->is_filtering);\n\n\tsec->seclen = 0;\n\n\treturn 0;\n}\n\nstatic void dvb_dmx_swfilter_section_new(struct dvb_demux_feed *feed)\n{\n\tstruct dmx_section_feed *sec = &feed->feed.sec;\n\n\tif (sec->secbufp < sec->tsfeedp) {\n\t\tint n = sec->tsfeedp - sec->secbufp;\n\n\t\t \n\t\tif (sec->secbuf[0] != 0xff || sec->secbuf[n - 1] != 0xff) {\n\t\t\tset_buf_flags(feed,\n\t\t\t\t      DMX_BUFFER_FLAG_DISCONTINUITY_DETECTED);\n\t\t\tdprintk_sect_loss(\"section ts padding loss: %d/%d\\n\",\n\t\t\t\t\t  n, sec->tsfeedp);\n\t\t\tdprintk_sect_loss(\"pad data: %*ph\\n\", n, sec->secbuf);\n\t\t}\n\t}\n\n\tsec->tsfeedp = sec->secbufp = sec->seclen = 0;\n\tsec->secbuf = sec->secbuf_base;\n}\n\n \nstatic int dvb_dmx_swfilter_section_copy_dump(struct dvb_demux_feed *feed,\n\t\t\t\t\t      const u8 *buf, u8 len)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct dmx_section_feed *sec = &feed->feed.sec;\n\tu16 limit, seclen;\n\n\tif (sec->tsfeedp >= DMX_MAX_SECFEED_SIZE)\n\t\treturn 0;\n\n\tif (sec->tsfeedp + len > DMX_MAX_SECFEED_SIZE) {\n\t\tset_buf_flags(feed, DMX_BUFFER_FLAG_DISCONTINUITY_DETECTED);\n\t\tdprintk_sect_loss(\"section buffer full loss: %d/%d\\n\",\n\t\t\t\t  sec->tsfeedp + len - DMX_MAX_SECFEED_SIZE,\n\t\t\t\t  DMX_MAX_SECFEED_SIZE);\n\t\tlen = DMX_MAX_SECFEED_SIZE - sec->tsfeedp;\n\t}\n\n\tif (len <= 0)\n\t\treturn 0;\n\n\tdemux->memcopy(feed, sec->secbuf_base + sec->tsfeedp, buf, len);\n\tsec->tsfeedp += len;\n\n\t \n\tlimit = sec->tsfeedp;\n\tif (limit > DMX_MAX_SECFEED_SIZE)\n\t\treturn -1;\t \n\n\t \n\tsec->secbuf = sec->secbuf_base + sec->secbufp;\n\n\twhile (sec->secbufp + 2 < limit) {\n\t\tseclen = section_length(sec->secbuf);\n\t\tif (seclen <= 0 || seclen > DMX_MAX_SECTION_SIZE\n\t\t    || seclen + sec->secbufp > limit)\n\t\t\treturn 0;\n\t\tsec->seclen = seclen;\n\t\tsec->crc_val = ~0;\n\t\t \n\t\tif (feed->pusi_seen) {\n\t\t\tdvb_dmx_swfilter_section_feed(feed);\n\t\t} else {\n\t\t\tset_buf_flags(feed,\n\t\t\t\t      DMX_BUFFER_FLAG_DISCONTINUITY_DETECTED);\n\t\t\tdprintk_sect_loss(\"pusi not seen, discarding section data\\n\");\n\t\t}\n\t\tsec->secbufp += seclen;\t \n\t\tsec->secbuf += seclen;\t \n\t}\n\n\treturn 0;\n}\n\nstatic int dvb_dmx_swfilter_section_packet(struct dvb_demux_feed *feed,\n\t\t\t\t\t   const u8 *buf)\n{\n\tu8 p, count;\n\tint ccok, dc_i = 0;\n\tu8 cc;\n\n\tcount = payload(buf);\n\n\tif (count == 0)\t\t \n\t\treturn -1;\n\n\tp = 188 - count;\t \n\n\tcc = buf[3] & 0x0f;\n\tccok = ((feed->cc + 1) & 0x0f) == cc;\n\n\tif (buf[3] & 0x20) {\n\t\t \n\t\tif ((buf[4] > 0) && (buf[5] & 0x80))\n\t\t\tdc_i = 1;\n\t}\n\n\tif (!ccok || dc_i) {\n\t\tif (dc_i) {\n\t\t\tset_buf_flags(feed,\n\t\t\t\t      DMX_BUFFER_FLAG_DISCONTINUITY_INDICATOR);\n\t\t\tdprintk_sect_loss(\"%d frame with disconnect indicator\\n\",\n\t\t\t\tcc);\n\t\t} else {\n\t\t\tset_buf_flags(feed,\n\t\t\t\t      DMX_BUFFER_FLAG_DISCONTINUITY_DETECTED);\n\t\t\tdprintk_sect_loss(\"discontinuity: %d instead of %d. %d bytes lost\\n\",\n\t\t\t\tcc, (feed->cc + 1) & 0x0f, count + 4);\n\t\t}\n\t\t \n\n\t\t \n\n\t\tfeed->pusi_seen = false;\n\t\tdvb_dmx_swfilter_section_new(feed);\n\t}\n\tfeed->cc = cc;\n\n\tif (buf[1] & 0x40) {\n\t\t \n\t\tif (count > 1 && buf[p] < count) {\n\t\t\tconst u8 *before = &buf[p + 1];\n\t\t\tu8 before_len = buf[p];\n\t\t\tconst u8 *after = &before[before_len];\n\t\t\tu8 after_len = count - 1 - before_len;\n\n\t\t\tdvb_dmx_swfilter_section_copy_dump(feed, before,\n\t\t\t\t\t\t\t   before_len);\n\t\t\t \n\t\t\tfeed->pusi_seen = true;\n\t\t\tdvb_dmx_swfilter_section_new(feed);\n\t\t\tdvb_dmx_swfilter_section_copy_dump(feed, after,\n\t\t\t\t\t\t\t   after_len);\n\t\t} else if (count > 0) {\n\t\t\tset_buf_flags(feed,\n\t\t\t\t      DMX_BUFFER_FLAG_DISCONTINUITY_DETECTED);\n\t\t\tdprintk_sect_loss(\"PUSI=1 but %d bytes lost\\n\", count);\n\t\t}\n\t} else {\n\t\t \n\t\tdvb_dmx_swfilter_section_copy_dump(feed, &buf[p], count);\n\t}\n\n\treturn 0;\n}\n\nstatic inline void dvb_dmx_swfilter_packet_type(struct dvb_demux_feed *feed,\n\t\t\t\t\t\tconst u8 *buf)\n{\n\tswitch (feed->type) {\n\tcase DMX_TYPE_TS:\n\t\tif (!feed->feed.ts.is_filtering)\n\t\t\tbreak;\n\t\tif (feed->ts_type & TS_PACKET) {\n\t\t\tif (feed->ts_type & TS_PAYLOAD_ONLY)\n\t\t\t\tdvb_dmx_swfilter_payload(feed, buf);\n\t\t\telse\n\t\t\t\tfeed->cb.ts(buf, 188, NULL, 0, &feed->feed.ts,\n\t\t\t\t\t    &feed->buffer_flags);\n\t\t}\n\t\t \n\t\tif (feed->ts_type & TS_DECODER)\n\t\t\tif (feed->demux->write_to_decoder)\n\t\t\t\tfeed->demux->write_to_decoder(feed, buf, 188);\n\t\tbreak;\n\n\tcase DMX_TYPE_SEC:\n\t\tif (!feed->feed.sec.is_filtering)\n\t\t\tbreak;\n\t\tif (dvb_dmx_swfilter_section_packet(feed, buf) < 0)\n\t\t\tfeed->feed.sec.seclen = feed->feed.sec.secbufp = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n#define DVR_FEED(f)\t\t\t\t\t\t\t\\\n\t(((f)->type == DMX_TYPE_TS) &&\t\t\t\t\t\\\n\t((f)->feed.ts.is_filtering) &&\t\t\t\t\t\\\n\t(((f)->ts_type & (TS_PACKET | TS_DEMUX)) == TS_PACKET))\n\nstatic void dvb_dmx_swfilter_packet(struct dvb_demux *demux, const u8 *buf)\n{\n\tstruct dvb_demux_feed *feed;\n\tu16 pid = ts_pid(buf);\n\tint dvr_done = 0;\n\n\tif (dvb_demux_speedcheck) {\n\t\tktime_t cur_time;\n\t\tu64 speed_bytes, speed_timedelta;\n\n\t\tdemux->speed_pkts_cnt++;\n\n\t\t \n\t\tif (!(demux->speed_pkts_cnt % SPEED_PKTS_INTERVAL)) {\n\t\t\tcur_time = ktime_get();\n\n\t\t\tif (ktime_to_ns(demux->speed_last_time) != 0) {\n\t\t\t\tspeed_bytes = (u64)demux->speed_pkts_cnt\n\t\t\t\t\t* 188 * 8;\n\t\t\t\t \n\t\t\t\tspeed_bytes = 1000 * div64_u64(speed_bytes,\n\t\t\t\t\t\t1024);\n\t\t\t\tspeed_timedelta = ktime_ms_delta(cur_time,\n\t\t\t\t\t\t\tdemux->speed_last_time);\n\t\t\t\tif (speed_timedelta)\n\t\t\t\t\tdprintk(\"TS speed %llu Kbits/sec \\n\",\n\t\t\t\t\t\tdiv64_u64(speed_bytes,\n\t\t\t\t\t\t\t  speed_timedelta));\n\t\t\t}\n\n\t\t\tdemux->speed_last_time = cur_time;\n\t\t\tdemux->speed_pkts_cnt = 0;\n\t\t}\n\t}\n\n\tif (buf[1] & 0x80) {\n\t\tlist_for_each_entry(feed, &demux->feed_list, list_head) {\n\t\t\tif ((feed->pid != pid) && (feed->pid != 0x2000))\n\t\t\t\tcontinue;\n\t\t\tset_buf_flags(feed, DMX_BUFFER_FLAG_TEI);\n\t\t}\n\t\tdprintk_tscheck(\"TEI detected. PID=0x%x data1=0x%x\\n\",\n\t\t\t\tpid, buf[1]);\n\t\t \n\t\tif (!dvb_demux_feed_err_pkts)\n\t\t\treturn;\n\t} else  \n\t\tif (demux->cnt_storage && dvb_demux_tscheck) {\n\t\t\t \n\t\t\tif (pid < MAX_PID) {\n\t\t\t\tif (buf[3] & 0x10)\n\t\t\t\t\tdemux->cnt_storage[pid] =\n\t\t\t\t\t\t(demux->cnt_storage[pid] + 1) & 0xf;\n\n\t\t\t\tif ((buf[3] & 0xf) != demux->cnt_storage[pid]) {\n\t\t\t\t\tlist_for_each_entry(feed, &demux->feed_list, list_head) {\n\t\t\t\t\t\tif ((feed->pid != pid) && (feed->pid != 0x2000))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tset_buf_flags(feed,\n\t\t\t\t\t\t\t      DMX_BUFFER_PKT_COUNTER_MISMATCH);\n\t\t\t\t\t}\n\n\t\t\t\t\tdprintk_tscheck(\"TS packet counter mismatch. PID=0x%x expected 0x%x got 0x%x\\n\",\n\t\t\t\t\t\t\tpid, demux->cnt_storage[pid],\n\t\t\t\t\t\t\tbuf[3] & 0xf);\n\t\t\t\t\tdemux->cnt_storage[pid] = buf[3] & 0xf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t}\n\n\tlist_for_each_entry(feed, &demux->feed_list, list_head) {\n\t\tif ((feed->pid != pid) && (feed->pid != 0x2000))\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((DVR_FEED(feed)) && (dvr_done++))\n\t\t\tcontinue;\n\n\t\tif (feed->pid == pid)\n\t\t\tdvb_dmx_swfilter_packet_type(feed, buf);\n\t\telse if (feed->pid == 0x2000)\n\t\t\tfeed->cb.ts(buf, 188, NULL, 0, &feed->feed.ts,\n\t\t\t\t    &feed->buffer_flags);\n\t}\n}\n\nvoid dvb_dmx_swfilter_packets(struct dvb_demux *demux, const u8 *buf,\n\t\t\t      size_t count)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&demux->lock, flags);\n\n\twhile (count--) {\n\t\tif (buf[0] == 0x47)\n\t\t\tdvb_dmx_swfilter_packet(demux, buf);\n\t\tbuf += 188;\n\t}\n\n\tspin_unlock_irqrestore(&demux->lock, flags);\n}\n\nEXPORT_SYMBOL(dvb_dmx_swfilter_packets);\n\nstatic inline int find_next_packet(const u8 *buf, int pos, size_t count,\n\t\t\t\t   const int pktsize)\n{\n\tint start = pos, lost;\n\n\twhile (pos < count) {\n\t\tif (buf[pos] == 0x47 ||\n\t\t    (pktsize == 204 && buf[pos] == 0xB8))\n\t\t\tbreak;\n\t\tpos++;\n\t}\n\n\tlost = pos - start;\n\tif (lost) {\n\t\t \n\t\tint backtrack = pos - pktsize;\n\t\tif (backtrack >= 0 && (buf[backtrack] == 0x47 ||\n\t\t    (pktsize == 204 && buf[backtrack] == 0xB8)))\n\t\t\treturn backtrack;\n\t}\n\n\treturn pos;\n}\n\n \nstatic inline void _dvb_dmx_swfilter(struct dvb_demux *demux, const u8 *buf,\n\t\tsize_t count, const int pktsize)\n{\n\tint p = 0, i, j;\n\tconst u8 *q;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&demux->lock, flags);\n\n\tif (demux->tsbufp) {  \n\t\ti = demux->tsbufp;\n\t\tj = pktsize - i;\n\t\tif (count < j) {\n\t\t\tmemcpy(&demux->tsbuf[i], buf, count);\n\t\t\tdemux->tsbufp += count;\n\t\t\tgoto bailout;\n\t\t}\n\t\tmemcpy(&demux->tsbuf[i], buf, j);\n\t\tif (demux->tsbuf[0] == 0x47)  \n\t\t\tdvb_dmx_swfilter_packet(demux, demux->tsbuf);\n\t\tdemux->tsbufp = 0;\n\t\tp += j;\n\t}\n\n\twhile (1) {\n\t\tp = find_next_packet(buf, p, count, pktsize);\n\t\tif (p >= count)\n\t\t\tbreak;\n\t\tif (count - p < pktsize)\n\t\t\tbreak;\n\n\t\tq = &buf[p];\n\n\t\tif (pktsize == 204 && (*q == 0xB8)) {\n\t\t\tmemcpy(demux->tsbuf, q, 188);\n\t\t\tdemux->tsbuf[0] = 0x47;\n\t\t\tq = demux->tsbuf;\n\t\t}\n\t\tdvb_dmx_swfilter_packet(demux, q);\n\t\tp += pktsize;\n\t}\n\n\ti = count - p;\n\tif (i) {\n\t\tmemcpy(demux->tsbuf, &buf[p], i);\n\t\tdemux->tsbufp = i;\n\t\tif (pktsize == 204 && demux->tsbuf[0] == 0xB8)\n\t\t\tdemux->tsbuf[0] = 0x47;\n\t}\n\nbailout:\n\tspin_unlock_irqrestore(&demux->lock, flags);\n}\n\nvoid dvb_dmx_swfilter(struct dvb_demux *demux, const u8 *buf, size_t count)\n{\n\t_dvb_dmx_swfilter(demux, buf, count, 188);\n}\nEXPORT_SYMBOL(dvb_dmx_swfilter);\n\nvoid dvb_dmx_swfilter_204(struct dvb_demux *demux, const u8 *buf, size_t count)\n{\n\t_dvb_dmx_swfilter(demux, buf, count, 204);\n}\nEXPORT_SYMBOL(dvb_dmx_swfilter_204);\n\nvoid dvb_dmx_swfilter_raw(struct dvb_demux *demux, const u8 *buf, size_t count)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&demux->lock, flags);\n\n\tdemux->feed->cb.ts(buf, count, NULL, 0, &demux->feed->feed.ts,\n\t\t\t   &demux->feed->buffer_flags);\n\n\tspin_unlock_irqrestore(&demux->lock, flags);\n}\nEXPORT_SYMBOL(dvb_dmx_swfilter_raw);\n\nstatic struct dvb_demux_filter *dvb_dmx_filter_alloc(struct dvb_demux *demux)\n{\n\tint i;\n\n\tfor (i = 0; i < demux->filternum; i++)\n\t\tif (demux->filter[i].state == DMX_STATE_FREE)\n\t\t\tbreak;\n\n\tif (i == demux->filternum)\n\t\treturn NULL;\n\n\tdemux->filter[i].state = DMX_STATE_ALLOCATED;\n\n\treturn &demux->filter[i];\n}\n\nstatic struct dvb_demux_feed *dvb_dmx_feed_alloc(struct dvb_demux *demux)\n{\n\tint i;\n\n\tfor (i = 0; i < demux->feednum; i++)\n\t\tif (demux->feed[i].state == DMX_STATE_FREE)\n\t\t\tbreak;\n\n\tif (i == demux->feednum)\n\t\treturn NULL;\n\n\tdemux->feed[i].state = DMX_STATE_ALLOCATED;\n\n\treturn &demux->feed[i];\n}\n\nstatic int dvb_demux_feed_find(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux_feed *entry;\n\n\tlist_for_each_entry(entry, &feed->demux->feed_list, list_head)\n\t\tif (entry == feed)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void dvb_demux_feed_add(struct dvb_demux_feed *feed)\n{\n\tspin_lock_irq(&feed->demux->lock);\n\tif (dvb_demux_feed_find(feed)) {\n\t\tpr_err(\"%s: feed already in list (type=%x state=%x pid=%x)\\n\",\n\t\t       __func__, feed->type, feed->state, feed->pid);\n\t\tgoto out;\n\t}\n\n\tlist_add(&feed->list_head, &feed->demux->feed_list);\nout:\n\tspin_unlock_irq(&feed->demux->lock);\n}\n\nstatic void dvb_demux_feed_del(struct dvb_demux_feed *feed)\n{\n\tspin_lock_irq(&feed->demux->lock);\n\tif (!(dvb_demux_feed_find(feed))) {\n\t\tpr_err(\"%s: feed not in list (type=%x state=%x pid=%x)\\n\",\n\t\t       __func__, feed->type, feed->state, feed->pid);\n\t\tgoto out;\n\t}\n\n\tlist_del(&feed->list_head);\nout:\n\tspin_unlock_irq(&feed->demux->lock);\n}\n\nstatic int dmx_ts_feed_set(struct dmx_ts_feed *ts_feed, u16 pid, int ts_type,\n\t\t\t   enum dmx_ts_pes pes_type, ktime_t timeout)\n{\n\tstruct dvb_demux_feed *feed = (struct dvb_demux_feed *)ts_feed;\n\tstruct dvb_demux *demux = feed->demux;\n\n\tif (pid > DMX_MAX_PID)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&demux->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (ts_type & TS_DECODER) {\n\t\tif (pes_type >= DMX_PES_OTHER) {\n\t\t\tmutex_unlock(&demux->mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (demux->pesfilter[pes_type] &&\n\t\t    demux->pesfilter[pes_type] != feed) {\n\t\t\tmutex_unlock(&demux->mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdemux->pesfilter[pes_type] = feed;\n\t\tdemux->pids[pes_type] = pid;\n\t}\n\n\tdvb_demux_feed_add(feed);\n\n\tfeed->pid = pid;\n\tfeed->timeout = timeout;\n\tfeed->ts_type = ts_type;\n\tfeed->pes_type = pes_type;\n\n\tfeed->state = DMX_STATE_READY;\n\tmutex_unlock(&demux->mutex);\n\n\treturn 0;\n}\n\nstatic int dmx_ts_feed_start_filtering(struct dmx_ts_feed *ts_feed)\n{\n\tstruct dvb_demux_feed *feed = (struct dvb_demux_feed *)ts_feed;\n\tstruct dvb_demux *demux = feed->demux;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&demux->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (feed->state != DMX_STATE_READY || feed->type != DMX_TYPE_TS) {\n\t\tmutex_unlock(&demux->mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!demux->start_feed) {\n\t\tmutex_unlock(&demux->mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((ret = demux->start_feed(feed)) < 0) {\n\t\tmutex_unlock(&demux->mutex);\n\t\treturn ret;\n\t}\n\n\tspin_lock_irq(&demux->lock);\n\tts_feed->is_filtering = 1;\n\tfeed->state = DMX_STATE_GO;\n\tspin_unlock_irq(&demux->lock);\n\tmutex_unlock(&demux->mutex);\n\n\treturn 0;\n}\n\nstatic int dmx_ts_feed_stop_filtering(struct dmx_ts_feed *ts_feed)\n{\n\tstruct dvb_demux_feed *feed = (struct dvb_demux_feed *)ts_feed;\n\tstruct dvb_demux *demux = feed->demux;\n\tint ret;\n\n\tmutex_lock(&demux->mutex);\n\n\tif (feed->state < DMX_STATE_GO) {\n\t\tmutex_unlock(&demux->mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!demux->stop_feed) {\n\t\tmutex_unlock(&demux->mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tret = demux->stop_feed(feed);\n\n\tspin_lock_irq(&demux->lock);\n\tts_feed->is_filtering = 0;\n\tfeed->state = DMX_STATE_ALLOCATED;\n\tspin_unlock_irq(&demux->lock);\n\tmutex_unlock(&demux->mutex);\n\n\treturn ret;\n}\n\nstatic int dvbdmx_allocate_ts_feed(struct dmx_demux *dmx,\n\t\t\t\t   struct dmx_ts_feed **ts_feed,\n\t\t\t\t   dmx_ts_cb callback)\n{\n\tstruct dvb_demux *demux = (struct dvb_demux *)dmx;\n\tstruct dvb_demux_feed *feed;\n\n\tif (mutex_lock_interruptible(&demux->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (!(feed = dvb_dmx_feed_alloc(demux))) {\n\t\tmutex_unlock(&demux->mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tfeed->type = DMX_TYPE_TS;\n\tfeed->cb.ts = callback;\n\tfeed->demux = demux;\n\tfeed->pid = 0xffff;\n\tfeed->peslen = 0xfffa;\n\tfeed->buffer_flags = 0;\n\n\t(*ts_feed) = &feed->feed.ts;\n\t(*ts_feed)->parent = dmx;\n\t(*ts_feed)->priv = NULL;\n\t(*ts_feed)->is_filtering = 0;\n\t(*ts_feed)->start_filtering = dmx_ts_feed_start_filtering;\n\t(*ts_feed)->stop_filtering = dmx_ts_feed_stop_filtering;\n\t(*ts_feed)->set = dmx_ts_feed_set;\n\n\tif (!(feed->filter = dvb_dmx_filter_alloc(demux))) {\n\t\tfeed->state = DMX_STATE_FREE;\n\t\tmutex_unlock(&demux->mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tfeed->filter->type = DMX_TYPE_TS;\n\tfeed->filter->feed = feed;\n\tfeed->filter->state = DMX_STATE_READY;\n\n\tmutex_unlock(&demux->mutex);\n\n\treturn 0;\n}\n\nstatic int dvbdmx_release_ts_feed(struct dmx_demux *dmx,\n\t\t\t\t  struct dmx_ts_feed *ts_feed)\n{\n\tstruct dvb_demux *demux = (struct dvb_demux *)dmx;\n\tstruct dvb_demux_feed *feed = (struct dvb_demux_feed *)ts_feed;\n\n\tmutex_lock(&demux->mutex);\n\n\tif (feed->state == DMX_STATE_FREE) {\n\t\tmutex_unlock(&demux->mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tfeed->state = DMX_STATE_FREE;\n\tfeed->filter->state = DMX_STATE_FREE;\n\n\tdvb_demux_feed_del(feed);\n\n\tfeed->pid = 0xffff;\n\n\tif (feed->ts_type & TS_DECODER && feed->pes_type < DMX_PES_OTHER)\n\t\tdemux->pesfilter[feed->pes_type] = NULL;\n\n\tmutex_unlock(&demux->mutex);\n\treturn 0;\n}\n\n \n\nstatic int dmx_section_feed_allocate_filter(struct dmx_section_feed *feed,\n\t\t\t\t\t    struct dmx_section_filter **filter)\n{\n\tstruct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;\n\tstruct dvb_demux *dvbdemux = dvbdmxfeed->demux;\n\tstruct dvb_demux_filter *dvbdmxfilter;\n\n\tif (mutex_lock_interruptible(&dvbdemux->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tdvbdmxfilter = dvb_dmx_filter_alloc(dvbdemux);\n\tif (!dvbdmxfilter) {\n\t\tmutex_unlock(&dvbdemux->mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tspin_lock_irq(&dvbdemux->lock);\n\t*filter = &dvbdmxfilter->filter;\n\t(*filter)->parent = feed;\n\t(*filter)->priv = NULL;\n\tdvbdmxfilter->feed = dvbdmxfeed;\n\tdvbdmxfilter->type = DMX_TYPE_SEC;\n\tdvbdmxfilter->state = DMX_STATE_READY;\n\tdvbdmxfilter->next = dvbdmxfeed->filter;\n\tdvbdmxfeed->filter = dvbdmxfilter;\n\tspin_unlock_irq(&dvbdemux->lock);\n\n\tmutex_unlock(&dvbdemux->mutex);\n\treturn 0;\n}\n\nstatic int dmx_section_feed_set(struct dmx_section_feed *feed,\n\t\t\t\tu16 pid, int check_crc)\n{\n\tstruct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;\n\tstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\n\n\tif (pid > 0x1fff)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&dvbdmx->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tdvb_demux_feed_add(dvbdmxfeed);\n\n\tdvbdmxfeed->pid = pid;\n\tdvbdmxfeed->feed.sec.check_crc = check_crc;\n\n\tdvbdmxfeed->state = DMX_STATE_READY;\n\tmutex_unlock(&dvbdmx->mutex);\n\treturn 0;\n}\n\nstatic void prepare_secfilters(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tint i;\n\tstruct dvb_demux_filter *f;\n\tstruct dmx_section_filter *sf;\n\tu8 mask, mode, doneq;\n\n\tif (!(f = dvbdmxfeed->filter))\n\t\treturn;\n\tdo {\n\t\tsf = &f->filter;\n\t\tdoneq = false;\n\t\tfor (i = 0; i < DVB_DEMUX_MASK_MAX; i++) {\n\t\t\tmode = sf->filter_mode[i];\n\t\t\tmask = sf->filter_mask[i];\n\t\t\tf->maskandmode[i] = mask & mode;\n\t\t\tdoneq |= f->maskandnotmode[i] = mask & ~mode;\n\t\t}\n\t\tf->doneq = doneq ? true : false;\n\t} while ((f = f->next));\n}\n\nstatic int dmx_section_feed_start_filtering(struct dmx_section_feed *feed)\n{\n\tstruct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;\n\tstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&dvbdmx->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (feed->is_filtering) {\n\t\tmutex_unlock(&dvbdmx->mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!dvbdmxfeed->filter) {\n\t\tmutex_unlock(&dvbdmx->mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tdvbdmxfeed->feed.sec.tsfeedp = 0;\n\tdvbdmxfeed->feed.sec.secbuf = dvbdmxfeed->feed.sec.secbuf_base;\n\tdvbdmxfeed->feed.sec.secbufp = 0;\n\tdvbdmxfeed->feed.sec.seclen = 0;\n\tdvbdmxfeed->pusi_seen = false;\n\n\tif (!dvbdmx->start_feed) {\n\t\tmutex_unlock(&dvbdmx->mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tprepare_secfilters(dvbdmxfeed);\n\n\tif ((ret = dvbdmx->start_feed(dvbdmxfeed)) < 0) {\n\t\tmutex_unlock(&dvbdmx->mutex);\n\t\treturn ret;\n\t}\n\n\tspin_lock_irq(&dvbdmx->lock);\n\tfeed->is_filtering = 1;\n\tdvbdmxfeed->state = DMX_STATE_GO;\n\tspin_unlock_irq(&dvbdmx->lock);\n\n\tmutex_unlock(&dvbdmx->mutex);\n\treturn 0;\n}\n\nstatic int dmx_section_feed_stop_filtering(struct dmx_section_feed *feed)\n{\n\tstruct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;\n\tstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\n\tint ret;\n\n\tmutex_lock(&dvbdmx->mutex);\n\n\tif (!dvbdmx->stop_feed) {\n\t\tmutex_unlock(&dvbdmx->mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tret = dvbdmx->stop_feed(dvbdmxfeed);\n\n\tspin_lock_irq(&dvbdmx->lock);\n\tdvbdmxfeed->state = DMX_STATE_READY;\n\tfeed->is_filtering = 0;\n\tspin_unlock_irq(&dvbdmx->lock);\n\n\tmutex_unlock(&dvbdmx->mutex);\n\treturn ret;\n}\n\nstatic int dmx_section_feed_release_filter(struct dmx_section_feed *feed,\n\t\t\t\t\t   struct dmx_section_filter *filter)\n{\n\tstruct dvb_demux_filter *dvbdmxfilter = (struct dvb_demux_filter *)filter, *f;\n\tstruct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;\n\tstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\n\n\tmutex_lock(&dvbdmx->mutex);\n\n\tif (dvbdmxfilter->feed != dvbdmxfeed) {\n\t\tmutex_unlock(&dvbdmx->mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tif (feed->is_filtering) {\n\t\t \n\t\tmutex_unlock(&dvbdmx->mutex);\n\t\tfeed->stop_filtering(feed);\n\t\tmutex_lock(&dvbdmx->mutex);\n\t}\n\n\tspin_lock_irq(&dvbdmx->lock);\n\tf = dvbdmxfeed->filter;\n\n\tif (f == dvbdmxfilter) {\n\t\tdvbdmxfeed->filter = dvbdmxfilter->next;\n\t} else {\n\t\twhile (f->next != dvbdmxfilter)\n\t\t\tf = f->next;\n\t\tf->next = f->next->next;\n\t}\n\n\tdvbdmxfilter->state = DMX_STATE_FREE;\n\tspin_unlock_irq(&dvbdmx->lock);\n\tmutex_unlock(&dvbdmx->mutex);\n\treturn 0;\n}\n\nstatic int dvbdmx_allocate_section_feed(struct dmx_demux *demux,\n\t\t\t\t\tstruct dmx_section_feed **feed,\n\t\t\t\t\tdmx_section_cb callback)\n{\n\tstruct dvb_demux *dvbdmx = (struct dvb_demux *)demux;\n\tstruct dvb_demux_feed *dvbdmxfeed;\n\n\tif (mutex_lock_interruptible(&dvbdmx->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (!(dvbdmxfeed = dvb_dmx_feed_alloc(dvbdmx))) {\n\t\tmutex_unlock(&dvbdmx->mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tdvbdmxfeed->type = DMX_TYPE_SEC;\n\tdvbdmxfeed->cb.sec = callback;\n\tdvbdmxfeed->demux = dvbdmx;\n\tdvbdmxfeed->pid = 0xffff;\n\tdvbdmxfeed->buffer_flags = 0;\n\tdvbdmxfeed->feed.sec.secbuf = dvbdmxfeed->feed.sec.secbuf_base;\n\tdvbdmxfeed->feed.sec.secbufp = dvbdmxfeed->feed.sec.seclen = 0;\n\tdvbdmxfeed->feed.sec.tsfeedp = 0;\n\tdvbdmxfeed->filter = NULL;\n\n\t(*feed) = &dvbdmxfeed->feed.sec;\n\t(*feed)->is_filtering = 0;\n\t(*feed)->parent = demux;\n\t(*feed)->priv = NULL;\n\n\t(*feed)->set = dmx_section_feed_set;\n\t(*feed)->allocate_filter = dmx_section_feed_allocate_filter;\n\t(*feed)->start_filtering = dmx_section_feed_start_filtering;\n\t(*feed)->stop_filtering = dmx_section_feed_stop_filtering;\n\t(*feed)->release_filter = dmx_section_feed_release_filter;\n\n\tmutex_unlock(&dvbdmx->mutex);\n\treturn 0;\n}\n\nstatic int dvbdmx_release_section_feed(struct dmx_demux *demux,\n\t\t\t\t       struct dmx_section_feed *feed)\n{\n\tstruct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;\n\tstruct dvb_demux *dvbdmx = (struct dvb_demux *)demux;\n\n\tmutex_lock(&dvbdmx->mutex);\n\n\tif (dvbdmxfeed->state == DMX_STATE_FREE) {\n\t\tmutex_unlock(&dvbdmx->mutex);\n\t\treturn -EINVAL;\n\t}\n\tdvbdmxfeed->state = DMX_STATE_FREE;\n\n\tdvb_demux_feed_del(dvbdmxfeed);\n\n\tdvbdmxfeed->pid = 0xffff;\n\n\tmutex_unlock(&dvbdmx->mutex);\n\treturn 0;\n}\n\n \n\nstatic int dvbdmx_open(struct dmx_demux *demux)\n{\n\tstruct dvb_demux *dvbdemux = (struct dvb_demux *)demux;\n\n\tif (dvbdemux->users >= MAX_DVB_DEMUX_USERS)\n\t\treturn -EUSERS;\n\n\tdvbdemux->users++;\n\treturn 0;\n}\n\nstatic int dvbdmx_close(struct dmx_demux *demux)\n{\n\tstruct dvb_demux *dvbdemux = (struct dvb_demux *)demux;\n\n\tif (dvbdemux->users == 0)\n\t\treturn -ENODEV;\n\n\tdvbdemux->users--;\n\t \n\treturn 0;\n}\n\nstatic int dvbdmx_write(struct dmx_demux *demux, const char __user *buf, size_t count)\n{\n\tstruct dvb_demux *dvbdemux = (struct dvb_demux *)demux;\n\tvoid *p;\n\n\tif ((!demux->frontend) || (demux->frontend->source != DMX_MEMORY_FE))\n\t\treturn -EINVAL;\n\n\tp = memdup_user(buf, count);\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\tif (mutex_lock_interruptible(&dvbdemux->mutex)) {\n\t\tkfree(p);\n\t\treturn -ERESTARTSYS;\n\t}\n\tdvb_dmx_swfilter(dvbdemux, p, count);\n\tkfree(p);\n\tmutex_unlock(&dvbdemux->mutex);\n\n\tif (signal_pending(current))\n\t\treturn -EINTR;\n\treturn count;\n}\n\nstatic int dvbdmx_add_frontend(struct dmx_demux *demux,\n\t\t\t       struct dmx_frontend *frontend)\n{\n\tstruct dvb_demux *dvbdemux = (struct dvb_demux *)demux;\n\tstruct list_head *head = &dvbdemux->frontend_list;\n\n\tlist_add(&(frontend->connectivity_list), head);\n\n\treturn 0;\n}\n\nstatic int dvbdmx_remove_frontend(struct dmx_demux *demux,\n\t\t\t\t  struct dmx_frontend *frontend)\n{\n\tstruct dvb_demux *dvbdemux = (struct dvb_demux *)demux;\n\tstruct list_head *pos, *n, *head = &dvbdemux->frontend_list;\n\n\tlist_for_each_safe(pos, n, head) {\n\t\tif (DMX_FE_ENTRY(pos) == frontend) {\n\t\t\tlist_del(pos);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic struct list_head *dvbdmx_get_frontends(struct dmx_demux *demux)\n{\n\tstruct dvb_demux *dvbdemux = (struct dvb_demux *)demux;\n\n\tif (list_empty(&dvbdemux->frontend_list))\n\t\treturn NULL;\n\n\treturn &dvbdemux->frontend_list;\n}\n\nstatic int dvbdmx_connect_frontend(struct dmx_demux *demux,\n\t\t\t\t   struct dmx_frontend *frontend)\n{\n\tstruct dvb_demux *dvbdemux = (struct dvb_demux *)demux;\n\n\tif (demux->frontend)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dvbdemux->mutex);\n\n\tdemux->frontend = frontend;\n\tmutex_unlock(&dvbdemux->mutex);\n\treturn 0;\n}\n\nstatic int dvbdmx_disconnect_frontend(struct dmx_demux *demux)\n{\n\tstruct dvb_demux *dvbdemux = (struct dvb_demux *)demux;\n\n\tmutex_lock(&dvbdemux->mutex);\n\n\tdemux->frontend = NULL;\n\tmutex_unlock(&dvbdemux->mutex);\n\treturn 0;\n}\n\nstatic int dvbdmx_get_pes_pids(struct dmx_demux *demux, u16 * pids)\n{\n\tstruct dvb_demux *dvbdemux = (struct dvb_demux *)demux;\n\n\tmemcpy(pids, dvbdemux->pids, 5 * sizeof(u16));\n\treturn 0;\n}\n\nint dvb_dmx_init(struct dvb_demux *dvbdemux)\n{\n\tint i;\n\tstruct dmx_demux *dmx = &dvbdemux->dmx;\n\n\tdvbdemux->cnt_storage = NULL;\n\tdvbdemux->users = 0;\n\tdvbdemux->filter = vmalloc(array_size(sizeof(struct dvb_demux_filter),\n\t\t\t\t\t      dvbdemux->filternum));\n\n\tif (!dvbdemux->filter)\n\t\treturn -ENOMEM;\n\n\tdvbdemux->feed = vmalloc(array_size(sizeof(struct dvb_demux_feed),\n\t\t\t\t\t    dvbdemux->feednum));\n\tif (!dvbdemux->feed) {\n\t\tvfree(dvbdemux->filter);\n\t\tdvbdemux->filter = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < dvbdemux->filternum; i++) {\n\t\tdvbdemux->filter[i].state = DMX_STATE_FREE;\n\t\tdvbdemux->filter[i].index = i;\n\t}\n\tfor (i = 0; i < dvbdemux->feednum; i++) {\n\t\tdvbdemux->feed[i].state = DMX_STATE_FREE;\n\t\tdvbdemux->feed[i].index = i;\n\t}\n\n\tdvbdemux->cnt_storage = vmalloc(MAX_PID + 1);\n\tif (!dvbdemux->cnt_storage)\n\t\tpr_warn(\"Couldn't allocate memory for TS/TEI check. Disabling it\\n\");\n\n\tINIT_LIST_HEAD(&dvbdemux->frontend_list);\n\n\tfor (i = 0; i < DMX_PES_OTHER; i++) {\n\t\tdvbdemux->pesfilter[i] = NULL;\n\t\tdvbdemux->pids[i] = 0xffff;\n\t}\n\n\tINIT_LIST_HEAD(&dvbdemux->feed_list);\n\n\tdvbdemux->playing = 0;\n\tdvbdemux->recording = 0;\n\tdvbdemux->tsbufp = 0;\n\n\tif (!dvbdemux->check_crc32)\n\t\tdvbdemux->check_crc32 = dvb_dmx_crc32;\n\n\tif (!dvbdemux->memcopy)\n\t\tdvbdemux->memcopy = dvb_dmx_memcopy;\n\n\tdmx->frontend = NULL;\n\tdmx->priv = dvbdemux;\n\tdmx->open = dvbdmx_open;\n\tdmx->close = dvbdmx_close;\n\tdmx->write = dvbdmx_write;\n\tdmx->allocate_ts_feed = dvbdmx_allocate_ts_feed;\n\tdmx->release_ts_feed = dvbdmx_release_ts_feed;\n\tdmx->allocate_section_feed = dvbdmx_allocate_section_feed;\n\tdmx->release_section_feed = dvbdmx_release_section_feed;\n\n\tdmx->add_frontend = dvbdmx_add_frontend;\n\tdmx->remove_frontend = dvbdmx_remove_frontend;\n\tdmx->get_frontends = dvbdmx_get_frontends;\n\tdmx->connect_frontend = dvbdmx_connect_frontend;\n\tdmx->disconnect_frontend = dvbdmx_disconnect_frontend;\n\tdmx->get_pes_pids = dvbdmx_get_pes_pids;\n\n\tmutex_init(&dvbdemux->mutex);\n\tspin_lock_init(&dvbdemux->lock);\n\n\treturn 0;\n}\n\nEXPORT_SYMBOL(dvb_dmx_init);\n\nvoid dvb_dmx_release(struct dvb_demux *dvbdemux)\n{\n\tvfree(dvbdemux->cnt_storage);\n\tvfree(dvbdemux->filter);\n\tvfree(dvbdemux->feed);\n}\n\nEXPORT_SYMBOL(dvb_dmx_release);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}