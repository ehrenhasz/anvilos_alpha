{
  "module_name": "dvb_ringbuffer.c",
  "hash_id": "6972d530ba49c6c11fe4a17411d41f4127175935b853f7b2ea139ce8b1628118",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-core/dvb_ringbuffer.c",
  "human_readable_source": " \n\n\n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\n#include <media/dvb_ringbuffer.h>\n\n#define PKT_READY 0\n#define PKT_DISPOSED 1\n\n\nvoid dvb_ringbuffer_init(struct dvb_ringbuffer *rbuf, void *data, size_t len)\n{\n\trbuf->pread=rbuf->pwrite=0;\n\trbuf->data=data;\n\trbuf->size=len;\n\trbuf->error=0;\n\n\tinit_waitqueue_head(&rbuf->queue);\n\n\tspin_lock_init(&(rbuf->lock));\n}\n\n\n\nint dvb_ringbuffer_empty(struct dvb_ringbuffer *rbuf)\n{\n\t \n\treturn (rbuf->pread == smp_load_acquire(&rbuf->pwrite));\n}\n\n\n\nssize_t dvb_ringbuffer_free(struct dvb_ringbuffer *rbuf)\n{\n\tssize_t free;\n\n\t \n\tfree = READ_ONCE(rbuf->pread) - rbuf->pwrite;\n\tif (free <= 0)\n\t\tfree += rbuf->size;\n\treturn free-1;\n}\n\n\n\nssize_t dvb_ringbuffer_avail(struct dvb_ringbuffer *rbuf)\n{\n\tssize_t avail;\n\n\t \n\tavail = smp_load_acquire(&rbuf->pwrite) - rbuf->pread;\n\tif (avail < 0)\n\t\tavail += rbuf->size;\n\treturn avail;\n}\n\n\n\nvoid dvb_ringbuffer_flush(struct dvb_ringbuffer *rbuf)\n{\n\t \n\tsmp_store_release(&rbuf->pread, smp_load_acquire(&rbuf->pwrite));\n\trbuf->error = 0;\n}\nEXPORT_SYMBOL(dvb_ringbuffer_flush);\n\nvoid dvb_ringbuffer_reset(struct dvb_ringbuffer *rbuf)\n{\n\t \n\tsmp_store_release(&rbuf->pread, 0);\n\t \n\tsmp_store_release(&rbuf->pwrite, 0);\n\trbuf->error = 0;\n}\n\nvoid dvb_ringbuffer_flush_spinlock_wakeup(struct dvb_ringbuffer *rbuf)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rbuf->lock, flags);\n\tdvb_ringbuffer_flush(rbuf);\n\tspin_unlock_irqrestore(&rbuf->lock, flags);\n\n\twake_up(&rbuf->queue);\n}\n\nssize_t dvb_ringbuffer_read_user(struct dvb_ringbuffer *rbuf, u8 __user *buf, size_t len)\n{\n\tsize_t todo = len;\n\tsize_t split;\n\n\tsplit = (rbuf->pread + len > rbuf->size) ? rbuf->size - rbuf->pread : 0;\n\tif (split > 0) {\n\t\tif (copy_to_user(buf, rbuf->data+rbuf->pread, split))\n\t\t\treturn -EFAULT;\n\t\tbuf += split;\n\t\ttodo -= split;\n\t\t \n\t\tsmp_store_release(&rbuf->pread, 0);\n\t}\n\tif (copy_to_user(buf, rbuf->data+rbuf->pread, todo))\n\t\treturn -EFAULT;\n\n\t \n\tsmp_store_release(&rbuf->pread, (rbuf->pread + todo) % rbuf->size);\n\n\treturn len;\n}\n\nvoid dvb_ringbuffer_read(struct dvb_ringbuffer *rbuf, u8 *buf, size_t len)\n{\n\tsize_t todo = len;\n\tsize_t split;\n\n\tsplit = (rbuf->pread + len > rbuf->size) ? rbuf->size - rbuf->pread : 0;\n\tif (split > 0) {\n\t\tmemcpy(buf, rbuf->data+rbuf->pread, split);\n\t\tbuf += split;\n\t\ttodo -= split;\n\t\t \n\t\tsmp_store_release(&rbuf->pread, 0);\n\t}\n\tmemcpy(buf, rbuf->data+rbuf->pread, todo);\n\n\t \n\tsmp_store_release(&rbuf->pread, (rbuf->pread + todo) % rbuf->size);\n}\n\n\nssize_t dvb_ringbuffer_write(struct dvb_ringbuffer *rbuf, const u8 *buf, size_t len)\n{\n\tsize_t todo = len;\n\tsize_t split;\n\n\tsplit = (rbuf->pwrite + len > rbuf->size) ? rbuf->size - rbuf->pwrite : 0;\n\n\tif (split > 0) {\n\t\tmemcpy(rbuf->data+rbuf->pwrite, buf, split);\n\t\tbuf += split;\n\t\ttodo -= split;\n\t\t \n\t\tsmp_store_release(&rbuf->pwrite, 0);\n\t}\n\tmemcpy(rbuf->data+rbuf->pwrite, buf, todo);\n\t \n\tsmp_store_release(&rbuf->pwrite, (rbuf->pwrite + todo) % rbuf->size);\n\n\treturn len;\n}\n\nssize_t dvb_ringbuffer_write_user(struct dvb_ringbuffer *rbuf,\n\t\t\t\t  const u8 __user *buf, size_t len)\n{\n\tint status;\n\tsize_t todo = len;\n\tsize_t split;\n\n\tsplit = (rbuf->pwrite + len > rbuf->size) ? rbuf->size - rbuf->pwrite : 0;\n\n\tif (split > 0) {\n\t\tstatus = copy_from_user(rbuf->data+rbuf->pwrite, buf, split);\n\t\tif (status)\n\t\t\treturn len - todo;\n\t\tbuf += split;\n\t\ttodo -= split;\n\t\t \n\t\tsmp_store_release(&rbuf->pwrite, 0);\n\t}\n\tstatus = copy_from_user(rbuf->data+rbuf->pwrite, buf, todo);\n\tif (status)\n\t\treturn len - todo;\n\t \n\tsmp_store_release(&rbuf->pwrite, (rbuf->pwrite + todo) % rbuf->size);\n\n\treturn len;\n}\n\nssize_t dvb_ringbuffer_pkt_write(struct dvb_ringbuffer *rbuf, u8* buf, size_t len)\n{\n\tint status;\n\tssize_t oldpwrite = rbuf->pwrite;\n\n\tDVB_RINGBUFFER_WRITE_BYTE(rbuf, len >> 8);\n\tDVB_RINGBUFFER_WRITE_BYTE(rbuf, len & 0xff);\n\tDVB_RINGBUFFER_WRITE_BYTE(rbuf, PKT_READY);\n\tstatus = dvb_ringbuffer_write(rbuf, buf, len);\n\n\tif (status < 0) rbuf->pwrite = oldpwrite;\n\treturn status;\n}\n\nssize_t dvb_ringbuffer_pkt_read_user(struct dvb_ringbuffer *rbuf, size_t idx,\n\t\t\t\tint offset, u8 __user *buf, size_t len)\n{\n\tsize_t todo;\n\tsize_t split;\n\tsize_t pktlen;\n\n\tpktlen = rbuf->data[idx] << 8;\n\tpktlen |= rbuf->data[(idx + 1) % rbuf->size];\n\tif (offset > pktlen) return -EINVAL;\n\tif ((offset + len) > pktlen) len = pktlen - offset;\n\n\tidx = (idx + DVB_RINGBUFFER_PKTHDRSIZE + offset) % rbuf->size;\n\ttodo = len;\n\tsplit = ((idx + len) > rbuf->size) ? rbuf->size - idx : 0;\n\tif (split > 0) {\n\t\tif (copy_to_user(buf, rbuf->data+idx, split))\n\t\t\treturn -EFAULT;\n\t\tbuf += split;\n\t\ttodo -= split;\n\t\tidx = 0;\n\t}\n\tif (copy_to_user(buf, rbuf->data+idx, todo))\n\t\treturn -EFAULT;\n\n\treturn len;\n}\n\nssize_t dvb_ringbuffer_pkt_read(struct dvb_ringbuffer *rbuf, size_t idx,\n\t\t\t\tint offset, u8* buf, size_t len)\n{\n\tsize_t todo;\n\tsize_t split;\n\tsize_t pktlen;\n\n\tpktlen = rbuf->data[idx] << 8;\n\tpktlen |= rbuf->data[(idx + 1) % rbuf->size];\n\tif (offset > pktlen) return -EINVAL;\n\tif ((offset + len) > pktlen) len = pktlen - offset;\n\n\tidx = (idx + DVB_RINGBUFFER_PKTHDRSIZE + offset) % rbuf->size;\n\ttodo = len;\n\tsplit = ((idx + len) > rbuf->size) ? rbuf->size - idx : 0;\n\tif (split > 0) {\n\t\tmemcpy(buf, rbuf->data+idx, split);\n\t\tbuf += split;\n\t\ttodo -= split;\n\t\tidx = 0;\n\t}\n\tmemcpy(buf, rbuf->data+idx, todo);\n\treturn len;\n}\n\nvoid dvb_ringbuffer_pkt_dispose(struct dvb_ringbuffer *rbuf, size_t idx)\n{\n\tsize_t pktlen;\n\n\trbuf->data[(idx + 2) % rbuf->size] = PKT_DISPOSED;\n\n\t\n\twhile(dvb_ringbuffer_avail(rbuf) > DVB_RINGBUFFER_PKTHDRSIZE) {\n\t\tif (DVB_RINGBUFFER_PEEK(rbuf, 2) == PKT_DISPOSED) {\n\t\t\tpktlen = DVB_RINGBUFFER_PEEK(rbuf, 0) << 8;\n\t\t\tpktlen |= DVB_RINGBUFFER_PEEK(rbuf, 1);\n\t\t\tDVB_RINGBUFFER_SKIP(rbuf, pktlen + DVB_RINGBUFFER_PKTHDRSIZE);\n\t\t} else {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nssize_t dvb_ringbuffer_pkt_next(struct dvb_ringbuffer *rbuf, size_t idx, size_t* pktlen)\n{\n\tint consumed;\n\tint curpktlen;\n\tint curpktstatus;\n\n\tif (idx == -1) {\n\t       idx = rbuf->pread;\n\t} else {\n\t\tcurpktlen = rbuf->data[idx] << 8;\n\t\tcurpktlen |= rbuf->data[(idx + 1) % rbuf->size];\n\t\tidx = (idx + curpktlen + DVB_RINGBUFFER_PKTHDRSIZE) % rbuf->size;\n\t}\n\n\tconsumed = (idx - rbuf->pread);\n\tif (consumed < 0)\n\t\tconsumed += rbuf->size;\n\n\twhile((dvb_ringbuffer_avail(rbuf) - consumed) > DVB_RINGBUFFER_PKTHDRSIZE) {\n\n\t\tcurpktlen = rbuf->data[idx] << 8;\n\t\tcurpktlen |= rbuf->data[(idx + 1) % rbuf->size];\n\t\tcurpktstatus = rbuf->data[(idx + 2) % rbuf->size];\n\n\t\tif (curpktstatus == PKT_READY) {\n\t\t\t*pktlen = curpktlen;\n\t\t\treturn idx;\n\t\t}\n\n\t\tconsumed += curpktlen + DVB_RINGBUFFER_PKTHDRSIZE;\n\t\tidx = (idx + curpktlen + DVB_RINGBUFFER_PKTHDRSIZE) % rbuf->size;\n\t}\n\n\t\n\treturn -1;\n}\n\n\n\nEXPORT_SYMBOL(dvb_ringbuffer_init);\nEXPORT_SYMBOL(dvb_ringbuffer_empty);\nEXPORT_SYMBOL(dvb_ringbuffer_free);\nEXPORT_SYMBOL(dvb_ringbuffer_avail);\nEXPORT_SYMBOL(dvb_ringbuffer_flush_spinlock_wakeup);\nEXPORT_SYMBOL(dvb_ringbuffer_read_user);\nEXPORT_SYMBOL(dvb_ringbuffer_read);\nEXPORT_SYMBOL(dvb_ringbuffer_write);\nEXPORT_SYMBOL(dvb_ringbuffer_write_user);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}