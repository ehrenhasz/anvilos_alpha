{
  "module_name": "dvb_frontend.c",
  "hash_id": "9de3524ef62e06a3597e914cf578cdcfae727a21a358cf14a947bffa7767a98c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-core/dvb_frontend.c",
  "human_readable_source": "\n \n\n \n#define __DVB_CORE__\n\n#define pr_fmt(fmt) \"dvb_frontend: \" fmt\n\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/semaphore.h>\n#include <linux/module.h>\n#include <linux/nospec.h>\n#include <linux/list.h>\n#include <linux/freezer.h>\n#include <linux/jiffies.h>\n#include <linux/kthread.h>\n#include <linux/ktime.h>\n#include <linux/compat.h>\n#include <asm/processor.h>\n\n#include <media/dvb_frontend.h>\n#include <media/dvbdev.h>\n#include <linux/dvb/version.h>\n\nstatic int dvb_frontend_debug;\nstatic int dvb_shutdown_timeout;\nstatic int dvb_force_auto_inversion;\nstatic int dvb_override_tune_delay;\nstatic int dvb_powerdown_on_sleep = 1;\nstatic int dvb_mfe_wait_time = 5;\n\nmodule_param_named(frontend_debug, dvb_frontend_debug, int, 0644);\nMODULE_PARM_DESC(frontend_debug, \"Turn on/off frontend core debugging (default:off).\");\nmodule_param(dvb_shutdown_timeout, int, 0644);\nMODULE_PARM_DESC(dvb_shutdown_timeout, \"wait <shutdown_timeout> seconds after close() before suspending hardware\");\nmodule_param(dvb_force_auto_inversion, int, 0644);\nMODULE_PARM_DESC(dvb_force_auto_inversion, \"0: normal (default), 1: INVERSION_AUTO forced always\");\nmodule_param(dvb_override_tune_delay, int, 0644);\nMODULE_PARM_DESC(dvb_override_tune_delay, \"0: normal (default), >0 => delay in milliseconds to wait for lock after a tune attempt\");\nmodule_param(dvb_powerdown_on_sleep, int, 0644);\nMODULE_PARM_DESC(dvb_powerdown_on_sleep, \"0: do not power down, 1: turn LNB voltage off on sleep (default)\");\nmodule_param(dvb_mfe_wait_time, int, 0644);\nMODULE_PARM_DESC(dvb_mfe_wait_time, \"Wait up to <mfe_wait_time> seconds on open() for multi-frontend to become available (default:5 seconds)\");\n\n#define dprintk(fmt, arg...) \\\n\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt), __func__, ##arg)\n\n#define FESTATE_IDLE 1\n#define FESTATE_RETUNE 2\n#define FESTATE_TUNING_FAST 4\n#define FESTATE_TUNING_SLOW 8\n#define FESTATE_TUNED 16\n#define FESTATE_ZIGZAG_FAST 32\n#define FESTATE_ZIGZAG_SLOW 64\n#define FESTATE_DISEQC 128\n#define FESTATE_ERROR 256\n#define FESTATE_WAITFORLOCK (FESTATE_TUNING_FAST | FESTATE_TUNING_SLOW | FESTATE_ZIGZAG_FAST | FESTATE_ZIGZAG_SLOW | FESTATE_DISEQC)\n#define FESTATE_SEARCHING_FAST (FESTATE_TUNING_FAST | FESTATE_ZIGZAG_FAST)\n#define FESTATE_SEARCHING_SLOW (FESTATE_TUNING_SLOW | FESTATE_ZIGZAG_SLOW)\n#define FESTATE_LOSTLOCK (FESTATE_ZIGZAG_FAST | FESTATE_ZIGZAG_SLOW)\n\n \n\nstatic DEFINE_MUTEX(frontend_mutex);\n\nstruct dvb_frontend_private {\n\t \n\tstruct dvb_device *dvbdev;\n\tstruct dvb_frontend_parameters parameters_out;\n\tstruct dvb_fe_events events;\n\tstruct semaphore sem;\n\tstruct list_head list_head;\n\twait_queue_head_t wait_queue;\n\tstruct task_struct *thread;\n\tunsigned long release_jiffies;\n\tunsigned int wakeup;\n\tenum fe_status status;\n\tunsigned long tune_mode_flags;\n\tunsigned int delay;\n\tunsigned int reinitialise;\n\tint tone;\n\tint voltage;\n\n\t \n\tunsigned int state;\n\tunsigned int bending;\n\tint lnb_drift;\n\tunsigned int inversion;\n\tunsigned int auto_step;\n\tunsigned int auto_sub_step;\n\tunsigned int started_auto_step;\n\tunsigned int min_delay;\n\tunsigned int max_drift;\n\tunsigned int step_size;\n\tint quality;\n\tunsigned int check_wrapped;\n\tenum dvbfe_search algo_status;\n\n#if defined(CONFIG_MEDIA_CONTROLLER_DVB)\n\tstruct media_pipeline pipe;\n#endif\n};\n\nstatic void dvb_frontend_invoke_release(struct dvb_frontend *fe,\n\t\t\t\t\tvoid (*release)(struct dvb_frontend *fe));\n\nstatic void __dvb_frontend_free(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\n\tif (fepriv)\n\t\tdvb_device_put(fepriv->dvbdev);\n\n\tdvb_frontend_invoke_release(fe, fe->ops.release);\n\n\tkfree(fepriv);\n}\n\nstatic void dvb_frontend_free(struct kref *ref)\n{\n\tstruct dvb_frontend *fe =\n\t\tcontainer_of(ref, struct dvb_frontend, refcount);\n\n\t__dvb_frontend_free(fe);\n}\n\nstatic void dvb_frontend_put(struct dvb_frontend *fe)\n{\n\t \n\tif (fe->ops.detach)\n\t\tfe->ops.detach(fe);\n\t \n\tif (fe->frontend_priv)\n\t\tkref_put(&fe->refcount, dvb_frontend_free);\n\telse\n\t\t__dvb_frontend_free(fe);\n}\n\nstatic void dvb_frontend_get(struct dvb_frontend *fe)\n{\n\tkref_get(&fe->refcount);\n}\n\nstatic void dvb_frontend_wakeup(struct dvb_frontend *fe);\nstatic int dtv_get_frontend(struct dvb_frontend *fe,\n\t\t\t    struct dtv_frontend_properties *c,\n\t\t\t    struct dvb_frontend_parameters *p_out);\nstatic int\ndtv_property_legacy_params_sync(struct dvb_frontend *fe,\n\t\t\t\tconst struct dtv_frontend_properties *c,\n\t\t\t\tstruct dvb_frontend_parameters *p);\n\nstatic bool has_get_frontend(struct dvb_frontend *fe)\n{\n\treturn fe->ops.get_frontend;\n}\n\n \nenum dvbv3_emulation_type {\n\tDVBV3_UNKNOWN,\n\tDVBV3_QPSK,\n\tDVBV3_QAM,\n\tDVBV3_OFDM,\n\tDVBV3_ATSC,\n};\n\nstatic enum dvbv3_emulation_type dvbv3_type(u32 delivery_system)\n{\n\tswitch (delivery_system) {\n\tcase SYS_DVBC_ANNEX_A:\n\tcase SYS_DVBC_ANNEX_C:\n\t\treturn DVBV3_QAM;\n\tcase SYS_DVBS:\n\tcase SYS_DVBS2:\n\tcase SYS_TURBO:\n\tcase SYS_ISDBS:\n\tcase SYS_DSS:\n\t\treturn DVBV3_QPSK;\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\tcase SYS_ISDBT:\n\tcase SYS_DTMB:\n\t\treturn DVBV3_OFDM;\n\tcase SYS_ATSC:\n\tcase SYS_ATSCMH:\n\tcase SYS_DVBC_ANNEX_B:\n\t\treturn DVBV3_ATSC;\n\tcase SYS_UNDEFINED:\n\tcase SYS_ISDBC:\n\tcase SYS_DVBH:\n\tcase SYS_DAB:\n\tdefault:\n\t\t \n\t\treturn DVBV3_UNKNOWN;\n\t}\n}\n\nstatic void dvb_frontend_add_event(struct dvb_frontend *fe,\n\t\t\t\t   enum fe_status status)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct dvb_fe_events *events = &fepriv->events;\n\tstruct dvb_frontend_event *e;\n\tint wp;\n\n\tdev_dbg(fe->dvb->device, \"%s:\\n\", __func__);\n\n\tif ((status & FE_HAS_LOCK) && has_get_frontend(fe))\n\t\tdtv_get_frontend(fe, c, &fepriv->parameters_out);\n\n\tmutex_lock(&events->mtx);\n\n\twp = (events->eventw + 1) % MAX_EVENT;\n\tif (wp == events->eventr) {\n\t\tevents->overflow = 1;\n\t\tevents->eventr = (events->eventr + 1) % MAX_EVENT;\n\t}\n\n\te = &events->events[events->eventw];\n\te->status = status;\n\te->parameters = fepriv->parameters_out;\n\n\tevents->eventw = wp;\n\n\tmutex_unlock(&events->mtx);\n\n\twake_up_interruptible(&events->wait_queue);\n}\n\nstatic int dvb_frontend_test_event(struct dvb_frontend_private *fepriv,\n\t\t\t\t   struct dvb_fe_events *events)\n{\n\tint ret;\n\n\tup(&fepriv->sem);\n\tret = events->eventw != events->eventr;\n\tdown(&fepriv->sem);\n\n\treturn ret;\n}\n\nstatic int dvb_frontend_get_event(struct dvb_frontend *fe,\n\t\t\t\t  struct dvb_frontend_event *event, int flags)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tstruct dvb_fe_events *events = &fepriv->events;\n\n\tdev_dbg(fe->dvb->device, \"%s:\\n\", __func__);\n\n\tif (events->overflow) {\n\t\tevents->overflow = 0;\n\t\treturn -EOVERFLOW;\n\t}\n\n\tif (events->eventw == events->eventr) {\n\t\tstruct wait_queue_entry wait;\n\t\tint ret = 0;\n\n\t\tif (flags & O_NONBLOCK)\n\t\t\treturn -EWOULDBLOCK;\n\n\t\tinit_waitqueue_entry(&wait, current);\n\t\tadd_wait_queue(&events->wait_queue, &wait);\n\t\twhile (!dvb_frontend_test_event(fepriv, events)) {\n\t\t\twait_woken(&wait, TASK_INTERRUPTIBLE, 0);\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tret = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tremove_wait_queue(&events->wait_queue, &wait);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&events->mtx);\n\t*event = events->events[events->eventr];\n\tevents->eventr = (events->eventr + 1) % MAX_EVENT;\n\tmutex_unlock(&events->mtx);\n\n\treturn 0;\n}\n\nstatic void dvb_frontend_clear_events(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tstruct dvb_fe_events *events = &fepriv->events;\n\n\tmutex_lock(&events->mtx);\n\tevents->eventr = events->eventw;\n\tmutex_unlock(&events->mtx);\n}\n\nstatic void dvb_frontend_init(struct dvb_frontend *fe)\n{\n\tdev_dbg(fe->dvb->device,\n\t\t\"%s: initialising adapter %i frontend %i (%s)...\\n\",\n\t\t__func__, fe->dvb->num, fe->id, fe->ops.info.name);\n\n\tif (fe->ops.init)\n\t\tfe->ops.init(fe);\n\tif (fe->ops.tuner_ops.init) {\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\t\tfe->ops.tuner_ops.init(fe);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n}\n\nvoid dvb_frontend_reinitialise(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\n\tfepriv->reinitialise = 1;\n\tdvb_frontend_wakeup(fe);\n}\nEXPORT_SYMBOL(dvb_frontend_reinitialise);\n\nstatic void dvb_frontend_swzigzag_update_delay(struct dvb_frontend_private *fepriv, int locked)\n{\n\tint q2;\n\tstruct dvb_frontend *fe = fepriv->dvbdev->priv;\n\n\tdev_dbg(fe->dvb->device, \"%s:\\n\", __func__);\n\n\tif (locked)\n\t\t(fepriv->quality) = (fepriv->quality * 220 + 36 * 256) / 256;\n\telse\n\t\t(fepriv->quality) = (fepriv->quality * 220 + 0) / 256;\n\n\tq2 = fepriv->quality - 128;\n\tq2 *= q2;\n\n\tfepriv->delay = fepriv->min_delay + q2 * HZ / (128 * 128);\n}\n\n \nstatic int dvb_frontend_swzigzag_autotune(struct dvb_frontend *fe, int check_wrapped)\n{\n\tint autoinversion;\n\tint ready = 0;\n\tint fe_set_err = 0;\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache, tmp;\n\tint original_inversion = c->inversion;\n\tu32 original_frequency = c->frequency;\n\n\t \n\tautoinversion = ((!(fe->ops.info.caps & FE_CAN_INVERSION_AUTO)) &&\n\t\t\t (c->inversion == INVERSION_AUTO));\n\n\t \n\twhile (!ready) {\n\t\t \n\t\tfepriv->lnb_drift = fepriv->auto_step * fepriv->step_size;\n\n\t\t \n\t\tif (fepriv->lnb_drift > fepriv->max_drift) {\n\t\t\tfepriv->auto_step = 0;\n\t\t\tfepriv->auto_sub_step = 0;\n\t\t\tfepriv->lnb_drift = 0;\n\t\t}\n\n\t\t \n\t\tswitch (fepriv->auto_sub_step) {\n\t\tcase 0:\n\t\t\t \n\t\t\tready = 1;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tif (!autoinversion) break;\n\n\t\t\tfepriv->inversion = (fepriv->inversion == INVERSION_OFF) ? INVERSION_ON : INVERSION_OFF;\n\t\t\tready = 1;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tif (fepriv->lnb_drift == 0) break;\n\n\t\t\tfepriv->lnb_drift = -fepriv->lnb_drift;\n\t\t\tready = 1;\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tif (fepriv->lnb_drift == 0) break;\n\t\t\tif (!autoinversion) break;\n\n\t\t\tfepriv->inversion = (fepriv->inversion == INVERSION_OFF) ? INVERSION_ON : INVERSION_OFF;\n\t\t\tfepriv->lnb_drift = -fepriv->lnb_drift;\n\t\t\tready = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfepriv->auto_step++;\n\t\t\tfepriv->auto_sub_step = -1;  \n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ready) fepriv->auto_sub_step++;\n\t}\n\n\t \n\tif ((fepriv->auto_step == fepriv->started_auto_step) &&\n\t    (fepriv->auto_sub_step == 0) && check_wrapped) {\n\t\treturn 1;\n\t}\n\n\tdev_dbg(fe->dvb->device,\n\t\t\"%s: drift:%i inversion:%i auto_step:%i auto_sub_step:%i started_auto_step:%i\\n\",\n\t\t__func__, fepriv->lnb_drift, fepriv->inversion,\n\t\tfepriv->auto_step, fepriv->auto_sub_step,\n\t\tfepriv->started_auto_step);\n\n\t \n\tc->frequency += fepriv->lnb_drift;\n\tif (autoinversion)\n\t\tc->inversion = fepriv->inversion;\n\ttmp = *c;\n\tif (fe->ops.set_frontend)\n\t\tfe_set_err = fe->ops.set_frontend(fe);\n\t*c = tmp;\n\tif (fe_set_err < 0) {\n\t\tfepriv->state = FESTATE_ERROR;\n\t\treturn fe_set_err;\n\t}\n\n\tc->frequency = original_frequency;\n\tc->inversion = original_inversion;\n\n\tfepriv->auto_sub_step++;\n\treturn 0;\n}\n\nstatic void dvb_frontend_swzigzag(struct dvb_frontend *fe)\n{\n\tenum fe_status s = FE_NONE;\n\tint retval = 0;\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache, tmp;\n\n\tif (fepriv->max_drift)\n\t\tdev_warn_once(fe->dvb->device,\n\t\t\t      \"Frontend requested software zigzag, but didn't set the frequency step size\\n\");\n\n\t \n\tif (fepriv->state & FESTATE_IDLE) {\n\t\tfepriv->delay = 3 * HZ;\n\t\tfepriv->quality = 0;\n\t\treturn;\n\t}\n\n\t \n\tif (fepriv->tune_mode_flags & FE_TUNE_MODE_ONESHOT) {\n\t\tif (fepriv->state & FESTATE_RETUNE) {\n\t\t\ttmp = *c;\n\t\t\tif (fe->ops.set_frontend)\n\t\t\t\tretval = fe->ops.set_frontend(fe);\n\t\t\t*c = tmp;\n\t\t\tif (retval < 0)\n\t\t\t\tfepriv->state = FESTATE_ERROR;\n\t\t\telse\n\t\t\t\tfepriv->state = FESTATE_TUNED;\n\t\t}\n\t\tfepriv->delay = 3 * HZ;\n\t\tfepriv->quality = 0;\n\t\treturn;\n\t}\n\n\t \n\tif (fepriv->state & FESTATE_RETUNE) {\n\t\ts = 0;\n\t} else {\n\t\tif (fe->ops.read_status)\n\t\t\tfe->ops.read_status(fe, &s);\n\t\tif (s != fepriv->status) {\n\t\t\tdvb_frontend_add_event(fe, s);\n\t\t\tfepriv->status = s;\n\t\t}\n\t}\n\n\t \n\tif ((fepriv->state & FESTATE_WAITFORLOCK) && (s & FE_HAS_LOCK)) {\n\t\tdvb_frontend_swzigzag_update_delay(fepriv, s & FE_HAS_LOCK);\n\t\tfepriv->state = FESTATE_TUNED;\n\n\t\t \n\t\tif ((!(fe->ops.info.caps & FE_CAN_INVERSION_AUTO)) &&\n\t\t    (c->inversion == INVERSION_AUTO)) {\n\t\t\tc->inversion = fepriv->inversion;\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (fepriv->state & FESTATE_TUNED) {\n\t\tdvb_frontend_swzigzag_update_delay(fepriv, s & FE_HAS_LOCK);\n\n\t\t \n\t\tif (s & FE_HAS_LOCK) {\n\t\t\treturn;\n\t\t} else {  \n\t\t\tfepriv->state = FESTATE_ZIGZAG_FAST;\n\t\t\tfepriv->started_auto_step = fepriv->auto_step;\n\t\t\tfepriv->check_wrapped = 0;\n\t\t}\n\t}\n\n\t \n\tif ((fepriv->state & FESTATE_LOSTLOCK) &&\n\t    (fe->ops.info.caps & FE_CAN_RECOVER) && (fepriv->max_drift == 0)) {\n\t\tdvb_frontend_swzigzag_update_delay(fepriv, s & FE_HAS_LOCK);\n\t\treturn;\n\t}\n\n\t \n\tif (fepriv->state & FESTATE_DISEQC) {\n\t\tdvb_frontend_swzigzag_update_delay(fepriv, s & FE_HAS_LOCK);\n\t\treturn;\n\t}\n\n\t \n\tif (fepriv->state & FESTATE_RETUNE) {\n\t\tfepriv->lnb_drift = 0;\n\t\tfepriv->auto_step = 0;\n\t\tfepriv->auto_sub_step = 0;\n\t\tfepriv->started_auto_step = 0;\n\t\tfepriv->check_wrapped = 0;\n\t}\n\n\t \n\tif ((fepriv->state & FESTATE_SEARCHING_FAST) || (fepriv->state & FESTATE_RETUNE)) {\n\t\tfepriv->delay = fepriv->min_delay;\n\n\t\t \n\t\tretval = dvb_frontend_swzigzag_autotune(fe,\n\t\t\t\t\t\t\tfepriv->check_wrapped);\n\t\tif (retval < 0) {\n\t\t\treturn;\n\t\t} else if (retval) {\n\t\t\t \n\t\t\tfepriv->state = FESTATE_SEARCHING_SLOW;\n\t\t\tfepriv->started_auto_step = fepriv->auto_step;\n\t\t\treturn;\n\t\t}\n\t\tfepriv->check_wrapped = 1;\n\n\t\t \n\t\tif (fepriv->state & FESTATE_RETUNE) {\n\t\t\tfepriv->state = FESTATE_TUNING_FAST;\n\t\t}\n\t}\n\n\t \n\tif (fepriv->state & FESTATE_SEARCHING_SLOW) {\n\t\tdvb_frontend_swzigzag_update_delay(fepriv, s & FE_HAS_LOCK);\n\n\t\t \n\t\tdvb_frontend_swzigzag_autotune(fe, 0);\n\t}\n}\n\nstatic int dvb_frontend_is_exiting(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\n\tif (fe->exit != DVB_FE_NO_EXIT)\n\t\treturn 1;\n\n\tif (fepriv->dvbdev->writers == 1)\n\t\tif (time_after_eq(jiffies, fepriv->release_jiffies +\n\t\t\t\t  dvb_shutdown_timeout * HZ))\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int dvb_frontend_should_wakeup(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\n\tif (fepriv->wakeup) {\n\t\tfepriv->wakeup = 0;\n\t\treturn 1;\n\t}\n\treturn dvb_frontend_is_exiting(fe);\n}\n\nstatic void dvb_frontend_wakeup(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\n\tfepriv->wakeup = 1;\n\twake_up_interruptible(&fepriv->wait_queue);\n}\n\nstatic int dvb_frontend_thread(void *data)\n{\n\tstruct dvb_frontend *fe = data;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tenum fe_status s = FE_NONE;\n\tenum dvbfe_algo algo;\n\tbool re_tune = false;\n\tbool semheld = false;\n\n\tdev_dbg(fe->dvb->device, \"%s:\\n\", __func__);\n\n\tfepriv->check_wrapped = 0;\n\tfepriv->quality = 0;\n\tfepriv->delay = 3 * HZ;\n\tfepriv->status = 0;\n\tfepriv->wakeup = 0;\n\tfepriv->reinitialise = 0;\n\n\tdvb_frontend_init(fe);\n\n\tset_freezable();\n\twhile (1) {\n\t\tup(&fepriv->sem);\t     \nrestart:\n\t\twait_event_interruptible_timeout(fepriv->wait_queue,\n\t\t\t\t\t\t dvb_frontend_should_wakeup(fe) ||\n\t\t\t\t\t\t kthread_should_stop() ||\n\t\t\t\t\t\t freezing(current),\n\t\t\tfepriv->delay);\n\n\t\tif (kthread_should_stop() || dvb_frontend_is_exiting(fe)) {\n\t\t\t \n\t\t\tif (!down_interruptible(&fepriv->sem))\n\t\t\t\tsemheld = true;\n\t\t\tfe->exit = DVB_FE_NORMAL_EXIT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (try_to_freeze())\n\t\t\tgoto restart;\n\n\t\tif (down_interruptible(&fepriv->sem))\n\t\t\tbreak;\n\n\t\tif (fepriv->reinitialise) {\n\t\t\tdvb_frontend_init(fe);\n\t\t\tif (fe->ops.set_tone && fepriv->tone != -1)\n\t\t\t\tfe->ops.set_tone(fe, fepriv->tone);\n\t\t\tif (fe->ops.set_voltage && fepriv->voltage != -1)\n\t\t\t\tfe->ops.set_voltage(fe, fepriv->voltage);\n\t\t\tfepriv->reinitialise = 0;\n\t\t}\n\n\t\t \n\t\tif (fe->ops.get_frontend_algo) {\n\t\t\talgo = fe->ops.get_frontend_algo(fe);\n\t\t\tswitch (algo) {\n\t\t\tcase DVBFE_ALGO_HW:\n\t\t\t\tdev_dbg(fe->dvb->device, \"%s: Frontend ALGO = DVBFE_ALGO_HW\\n\", __func__);\n\n\t\t\t\tif (fepriv->state & FESTATE_RETUNE) {\n\t\t\t\t\tdev_dbg(fe->dvb->device, \"%s: Retune requested, FESTATE_RETUNE\\n\", __func__);\n\t\t\t\t\tre_tune = true;\n\t\t\t\t\tfepriv->state = FESTATE_TUNED;\n\t\t\t\t} else {\n\t\t\t\t\tre_tune = false;\n\t\t\t\t}\n\n\t\t\t\tif (fe->ops.tune)\n\t\t\t\t\tfe->ops.tune(fe, re_tune, fepriv->tune_mode_flags, &fepriv->delay, &s);\n\n\t\t\t\tif (s != fepriv->status && !(fepriv->tune_mode_flags & FE_TUNE_MODE_ONESHOT)) {\n\t\t\t\t\tdev_dbg(fe->dvb->device, \"%s: state changed, adding current state\\n\", __func__);\n\t\t\t\t\tdvb_frontend_add_event(fe, s);\n\t\t\t\t\tfepriv->status = s;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DVBFE_ALGO_SW:\n\t\t\t\tdev_dbg(fe->dvb->device, \"%s: Frontend ALGO = DVBFE_ALGO_SW\\n\", __func__);\n\t\t\t\tdvb_frontend_swzigzag(fe);\n\t\t\t\tbreak;\n\t\t\tcase DVBFE_ALGO_CUSTOM:\n\t\t\t\tdev_dbg(fe->dvb->device, \"%s: Frontend ALGO = DVBFE_ALGO_CUSTOM, state=%d\\n\", __func__, fepriv->state);\n\t\t\t\tif (fepriv->state & FESTATE_RETUNE) {\n\t\t\t\t\tdev_dbg(fe->dvb->device, \"%s: Retune requested, FESTAT_RETUNE\\n\", __func__);\n\t\t\t\t\tfepriv->state = FESTATE_TUNED;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (fepriv->algo_status & DVBFE_ALGO_SEARCH_AGAIN) {\n\t\t\t\t\tif (fe->ops.search) {\n\t\t\t\t\t\tfepriv->algo_status = fe->ops.search(fe);\n\t\t\t\t\t\t \n\t\t\t\t\t} else {\n\t\t\t\t\t\tfepriv->algo_status &= ~DVBFE_ALGO_SEARCH_AGAIN;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (fepriv->algo_status != DVBFE_ALGO_SEARCH_SUCCESS) {\n\t\t\t\t\tfepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;\n\t\t\t\t\tfepriv->delay = HZ / 2;\n\t\t\t\t}\n\t\t\t\tdtv_property_legacy_params_sync(fe, c, &fepriv->parameters_out);\n\t\t\t\tfe->ops.read_status(fe, &s);\n\t\t\t\tif (s != fepriv->status) {\n\t\t\t\t\tdvb_frontend_add_event(fe, s);  \n\t\t\t\t\tfepriv->status = s;\n\t\t\t\t\tif (!(s & FE_HAS_LOCK)) {\n\t\t\t\t\t\tfepriv->delay = HZ / 10;\n\t\t\t\t\t\tfepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfepriv->delay = 60 * HZ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_dbg(fe->dvb->device, \"%s: UNDEFINED ALGO !\\n\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tdvb_frontend_swzigzag(fe);\n\t\t}\n\t}\n\n\tif (dvb_powerdown_on_sleep) {\n\t\tif (fe->ops.set_voltage)\n\t\t\tfe->ops.set_voltage(fe, SEC_VOLTAGE_OFF);\n\t\tif (fe->ops.tuner_ops.sleep) {\n\t\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\t\t\tfe->ops.tuner_ops.sleep(fe);\n\t\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t\t}\n\t\tif (fe->ops.sleep)\n\t\t\tfe->ops.sleep(fe);\n\t}\n\n\tfepriv->thread = NULL;\n\tif (kthread_should_stop())\n\t\tfe->exit = DVB_FE_DEVICE_REMOVED;\n\telse\n\t\tfe->exit = DVB_FE_NO_EXIT;\n\tmb();\n\n\tif (semheld)\n\t\tup(&fepriv->sem);\n\tdvb_frontend_wakeup(fe);\n\treturn 0;\n}\n\nstatic void dvb_frontend_stop(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\n\tdev_dbg(fe->dvb->device, \"%s:\\n\", __func__);\n\n\tif (fe->exit != DVB_FE_DEVICE_REMOVED)\n\t\tfe->exit = DVB_FE_NORMAL_EXIT;\n\tmb();\n\n\tif (!fepriv->thread)\n\t\treturn;\n\n\tkthread_stop(fepriv->thread);\n\n\tsema_init(&fepriv->sem, 1);\n\tfepriv->state = FESTATE_IDLE;\n\n\t \n\tif (fepriv->thread)\n\t\tdev_warn(fe->dvb->device,\n\t\t\t \"dvb_frontend_stop: warning: thread %p won't exit\\n\",\n\t\t\t fepriv->thread);\n}\n\n \nvoid dvb_frontend_sleep_until(ktime_t *waketime, u32 add_usec)\n{\n\ts32 delta;\n\n\t*waketime = ktime_add_us(*waketime, add_usec);\n\tdelta = ktime_us_delta(ktime_get_boottime(), *waketime);\n\tif (delta > 2500) {\n\t\tmsleep((delta - 1500) / 1000);\n\t\tdelta = ktime_us_delta(ktime_get_boottime(), *waketime);\n\t}\n\tif (delta > 0)\n\t\tudelay(delta);\n}\nEXPORT_SYMBOL(dvb_frontend_sleep_until);\n\nstatic int dvb_frontend_start(struct dvb_frontend *fe)\n{\n\tint ret;\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tstruct task_struct *fe_thread;\n\n\tdev_dbg(fe->dvb->device, \"%s:\\n\", __func__);\n\n\tif (fepriv->thread) {\n\t\tif (fe->exit == DVB_FE_NO_EXIT)\n\t\t\treturn 0;\n\t\telse\n\t\t\tdvb_frontend_stop(fe);\n\t}\n\n\tif (signal_pending(current))\n\t\treturn -EINTR;\n\tif (down_interruptible(&fepriv->sem))\n\t\treturn -EINTR;\n\n\tfepriv->state = FESTATE_IDLE;\n\tfe->exit = DVB_FE_NO_EXIT;\n\tfepriv->thread = NULL;\n\tmb();\n\n\tfe_thread = kthread_run(dvb_frontend_thread, fe,\n\t\t\t\t\"kdvb-ad-%i-fe-%i\", fe->dvb->num, fe->id);\n\tif (IS_ERR(fe_thread)) {\n\t\tret = PTR_ERR(fe_thread);\n\t\tdev_warn(fe->dvb->device,\n\t\t\t \"dvb_frontend_start: failed to start kthread (%d)\\n\",\n\t\t\t ret);\n\t\tup(&fepriv->sem);\n\t\treturn ret;\n\t}\n\tfepriv->thread = fe_thread;\n\treturn 0;\n}\n\nstatic void dvb_frontend_get_frequency_limits(struct dvb_frontend *fe,\n\t\t\t\t\t      u32 *freq_min, u32 *freq_max,\n\t\t\t\t\t      u32 *tolerance)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 tuner_min = fe->ops.tuner_ops.info.frequency_min_hz;\n\tu32 tuner_max = fe->ops.tuner_ops.info.frequency_max_hz;\n\tu32 frontend_min = fe->ops.info.frequency_min_hz;\n\tu32 frontend_max = fe->ops.info.frequency_max_hz;\n\n\t*freq_min = max(frontend_min, tuner_min);\n\n\tif (frontend_max == 0)\n\t\t*freq_max = tuner_max;\n\telse if (tuner_max == 0)\n\t\t*freq_max = frontend_max;\n\telse\n\t\t*freq_max = min(frontend_max, tuner_max);\n\n\tif (*freq_min == 0 || *freq_max == 0)\n\t\tdev_warn(fe->dvb->device,\n\t\t\t \"DVB: adapter %i frontend %u frequency limits undefined - fix the driver\\n\",\n\t\t\t fe->dvb->num, fe->id);\n\n\tdev_dbg(fe->dvb->device, \"frequency interval: tuner: %u...%u, frontend: %u...%u\",\n\t\ttuner_min, tuner_max, frontend_min, frontend_max);\n\n\t \n\tswitch (c->delivery_system) {\n\tcase SYS_DSS:\n\tcase SYS_DVBS:\n\tcase SYS_DVBS2:\n\tcase SYS_TURBO:\n\tcase SYS_ISDBS:\n\t\t*freq_min /= kHz;\n\t\t*freq_max /= kHz;\n\t\tif (tolerance)\n\t\t\t*tolerance = fe->ops.info.frequency_tolerance_hz / kHz;\n\n\t\tbreak;\n\tdefault:\n\t\tif (tolerance)\n\t\t\t*tolerance = fe->ops.info.frequency_tolerance_hz;\n\t\tbreak;\n\t}\n}\n\nstatic u32 dvb_frontend_get_stepsize(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 fe_step = fe->ops.info.frequency_stepsize_hz;\n\tu32 tuner_step = fe->ops.tuner_ops.info.frequency_step_hz;\n\tu32 step = max(fe_step, tuner_step);\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DSS:\n\tcase SYS_DVBS:\n\tcase SYS_DVBS2:\n\tcase SYS_TURBO:\n\tcase SYS_ISDBS:\n\t\tstep /= kHz;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn step;\n}\n\nstatic int dvb_frontend_check_parameters(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 freq_min;\n\tu32 freq_max;\n\n\t \n\tdvb_frontend_get_frequency_limits(fe, &freq_min, &freq_max, NULL);\n\tif ((freq_min && c->frequency < freq_min) ||\n\t    (freq_max && c->frequency > freq_max)) {\n\t\tdev_warn(fe->dvb->device, \"DVB: adapter %i frontend %i frequency %u out of range (%u..%u)\\n\",\n\t\t\t fe->dvb->num, fe->id, c->frequency,\n\t\t\t freq_min, freq_max);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (c->delivery_system) {\n\tcase SYS_DSS:\n\tcase SYS_DVBS:\n\tcase SYS_DVBS2:\n\tcase SYS_TURBO:\n\tcase SYS_DVBC_ANNEX_A:\n\tcase SYS_DVBC_ANNEX_C:\n\t\tif ((fe->ops.info.symbol_rate_min &&\n\t\t     c->symbol_rate < fe->ops.info.symbol_rate_min) ||\n\t\t    (fe->ops.info.symbol_rate_max &&\n\t\t     c->symbol_rate > fe->ops.info.symbol_rate_max)) {\n\t\t\tdev_warn(fe->dvb->device, \"DVB: adapter %i frontend %i symbol rate %u out of range (%u..%u)\\n\",\n\t\t\t\t fe->dvb->num, fe->id, c->symbol_rate,\n\t\t\t\t fe->ops.info.symbol_rate_min,\n\t\t\t\t fe->ops.info.symbol_rate_max);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int dvb_frontend_clear_cache(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint i;\n\tu32 delsys;\n\n\tdelsys = c->delivery_system;\n\tmemset(c, 0, offsetof(struct dtv_frontend_properties, strength));\n\tc->delivery_system = delsys;\n\n\tdev_dbg(fe->dvb->device, \"%s: Clearing cache for delivery system %d\\n\",\n\t\t__func__, c->delivery_system);\n\n\tc->transmission_mode = TRANSMISSION_MODE_AUTO;\n\tc->bandwidth_hz = 0;\t \n\tc->guard_interval = GUARD_INTERVAL_AUTO;\n\tc->hierarchy = HIERARCHY_AUTO;\n\tc->symbol_rate = 0;\n\tc->code_rate_HP = FEC_AUTO;\n\tc->code_rate_LP = FEC_AUTO;\n\tc->fec_inner = FEC_AUTO;\n\tc->rolloff = ROLLOFF_AUTO;\n\tc->voltage = SEC_VOLTAGE_OFF;\n\tc->sectone = SEC_TONE_OFF;\n\tc->pilot = PILOT_AUTO;\n\n\tc->isdbt_partial_reception = 0;\n\tc->isdbt_sb_mode = 0;\n\tc->isdbt_sb_subchannel = 0;\n\tc->isdbt_sb_segment_idx = 0;\n\tc->isdbt_sb_segment_count = 0;\n\tc->isdbt_layer_enabled = 7;\t \n\tfor (i = 0; i < 3; i++) {\n\t\tc->layer[i].fec = FEC_AUTO;\n\t\tc->layer[i].modulation = QAM_AUTO;\n\t\tc->layer[i].interleaving = 0;\n\t\tc->layer[i].segment_count = 0;\n\t}\n\n\tc->stream_id = NO_STREAM_ID_FILTER;\n\tc->scrambling_sequence_index = 0; \n\n\tswitch (c->delivery_system) {\n\tcase SYS_DSS:\n\t\tc->modulation = QPSK;\n\t\tc->rolloff = ROLLOFF_20;\n\t\tbreak;\n\tcase SYS_DVBS:\n\tcase SYS_DVBS2:\n\tcase SYS_TURBO:\n\t\tc->modulation = QPSK;    \n\t\tc->rolloff = ROLLOFF_35; \n\t\tbreak;\n\tcase SYS_ATSC:\n\t\tc->modulation = VSB_8;\n\t\tbreak;\n\tcase SYS_ISDBS:\n\t\tc->symbol_rate = 28860000;\n\t\tc->rolloff = ROLLOFF_35;\n\t\tc->bandwidth_hz = c->symbol_rate / 100 * 135;\n\t\tbreak;\n\tdefault:\n\t\tc->modulation = QAM_AUTO;\n\t\tbreak;\n\t}\n\n\tc->lna = LNA_AUTO;\n\n\treturn 0;\n}\n\n#define _DTV_CMD(n) \\\n\t[n] =  #n\n\nstatic char *dtv_cmds[DTV_MAX_COMMAND + 1] = {\n\t_DTV_CMD(DTV_TUNE),\n\t_DTV_CMD(DTV_CLEAR),\n\n\t \n\t_DTV_CMD(DTV_FREQUENCY),\n\t_DTV_CMD(DTV_BANDWIDTH_HZ),\n\t_DTV_CMD(DTV_MODULATION),\n\t_DTV_CMD(DTV_INVERSION),\n\t_DTV_CMD(DTV_DISEQC_MASTER),\n\t_DTV_CMD(DTV_SYMBOL_RATE),\n\t_DTV_CMD(DTV_INNER_FEC),\n\t_DTV_CMD(DTV_VOLTAGE),\n\t_DTV_CMD(DTV_TONE),\n\t_DTV_CMD(DTV_PILOT),\n\t_DTV_CMD(DTV_ROLLOFF),\n\t_DTV_CMD(DTV_DELIVERY_SYSTEM),\n\t_DTV_CMD(DTV_HIERARCHY),\n\t_DTV_CMD(DTV_CODE_RATE_HP),\n\t_DTV_CMD(DTV_CODE_RATE_LP),\n\t_DTV_CMD(DTV_GUARD_INTERVAL),\n\t_DTV_CMD(DTV_TRANSMISSION_MODE),\n\t_DTV_CMD(DTV_INTERLEAVING),\n\n\t_DTV_CMD(DTV_ISDBT_PARTIAL_RECEPTION),\n\t_DTV_CMD(DTV_ISDBT_SOUND_BROADCASTING),\n\t_DTV_CMD(DTV_ISDBT_SB_SUBCHANNEL_ID),\n\t_DTV_CMD(DTV_ISDBT_SB_SEGMENT_IDX),\n\t_DTV_CMD(DTV_ISDBT_SB_SEGMENT_COUNT),\n\t_DTV_CMD(DTV_ISDBT_LAYER_ENABLED),\n\t_DTV_CMD(DTV_ISDBT_LAYERA_FEC),\n\t_DTV_CMD(DTV_ISDBT_LAYERA_MODULATION),\n\t_DTV_CMD(DTV_ISDBT_LAYERA_SEGMENT_COUNT),\n\t_DTV_CMD(DTV_ISDBT_LAYERA_TIME_INTERLEAVING),\n\t_DTV_CMD(DTV_ISDBT_LAYERB_FEC),\n\t_DTV_CMD(DTV_ISDBT_LAYERB_MODULATION),\n\t_DTV_CMD(DTV_ISDBT_LAYERB_SEGMENT_COUNT),\n\t_DTV_CMD(DTV_ISDBT_LAYERB_TIME_INTERLEAVING),\n\t_DTV_CMD(DTV_ISDBT_LAYERC_FEC),\n\t_DTV_CMD(DTV_ISDBT_LAYERC_MODULATION),\n\t_DTV_CMD(DTV_ISDBT_LAYERC_SEGMENT_COUNT),\n\t_DTV_CMD(DTV_ISDBT_LAYERC_TIME_INTERLEAVING),\n\n\t_DTV_CMD(DTV_STREAM_ID),\n\t_DTV_CMD(DTV_DVBT2_PLP_ID_LEGACY),\n\t_DTV_CMD(DTV_SCRAMBLING_SEQUENCE_INDEX),\n\t_DTV_CMD(DTV_LNA),\n\n\t \n\t_DTV_CMD(DTV_DISEQC_SLAVE_REPLY),\n\t_DTV_CMD(DTV_API_VERSION),\n\n\t_DTV_CMD(DTV_ENUM_DELSYS),\n\n\t_DTV_CMD(DTV_ATSCMH_PARADE_ID),\n\t_DTV_CMD(DTV_ATSCMH_RS_FRAME_ENSEMBLE),\n\n\t_DTV_CMD(DTV_ATSCMH_FIC_VER),\n\t_DTV_CMD(DTV_ATSCMH_NOG),\n\t_DTV_CMD(DTV_ATSCMH_TNOG),\n\t_DTV_CMD(DTV_ATSCMH_SGN),\n\t_DTV_CMD(DTV_ATSCMH_PRC),\n\t_DTV_CMD(DTV_ATSCMH_RS_FRAME_MODE),\n\t_DTV_CMD(DTV_ATSCMH_RS_CODE_MODE_PRI),\n\t_DTV_CMD(DTV_ATSCMH_RS_CODE_MODE_SEC),\n\t_DTV_CMD(DTV_ATSCMH_SCCC_BLOCK_MODE),\n\t_DTV_CMD(DTV_ATSCMH_SCCC_CODE_MODE_A),\n\t_DTV_CMD(DTV_ATSCMH_SCCC_CODE_MODE_B),\n\t_DTV_CMD(DTV_ATSCMH_SCCC_CODE_MODE_C),\n\t_DTV_CMD(DTV_ATSCMH_SCCC_CODE_MODE_D),\n\n\t \n\t_DTV_CMD(DTV_STAT_SIGNAL_STRENGTH),\n\t_DTV_CMD(DTV_STAT_CNR),\n\t_DTV_CMD(DTV_STAT_PRE_ERROR_BIT_COUNT),\n\t_DTV_CMD(DTV_STAT_PRE_TOTAL_BIT_COUNT),\n\t_DTV_CMD(DTV_STAT_POST_ERROR_BIT_COUNT),\n\t_DTV_CMD(DTV_STAT_POST_TOTAL_BIT_COUNT),\n\t_DTV_CMD(DTV_STAT_ERROR_BLOCK_COUNT),\n\t_DTV_CMD(DTV_STAT_TOTAL_BLOCK_COUNT),\n};\n\nstatic char *dtv_cmd_name(u32 cmd)\n{\n\tcmd = array_index_nospec(cmd, DTV_MAX_COMMAND);\n\treturn dtv_cmds[cmd];\n}\n\n \nstatic int dtv_property_cache_sync(struct dvb_frontend *fe,\n\t\t\t\t   struct dtv_frontend_properties *c,\n\t\t\t\t   const struct dvb_frontend_parameters *p)\n{\n\tc->frequency = p->frequency;\n\tc->inversion = p->inversion;\n\n\tswitch (dvbv3_type(c->delivery_system)) {\n\tcase DVBV3_QPSK:\n\t\tdev_dbg(fe->dvb->device, \"%s: Preparing QPSK req\\n\", __func__);\n\t\tc->symbol_rate = p->u.qpsk.symbol_rate;\n\t\tc->fec_inner = p->u.qpsk.fec_inner;\n\t\tbreak;\n\tcase DVBV3_QAM:\n\t\tdev_dbg(fe->dvb->device, \"%s: Preparing QAM req\\n\", __func__);\n\t\tc->symbol_rate = p->u.qam.symbol_rate;\n\t\tc->fec_inner = p->u.qam.fec_inner;\n\t\tc->modulation = p->u.qam.modulation;\n\t\tbreak;\n\tcase DVBV3_OFDM:\n\t\tdev_dbg(fe->dvb->device, \"%s: Preparing OFDM req\\n\", __func__);\n\n\t\tswitch (p->u.ofdm.bandwidth) {\n\t\tcase BANDWIDTH_10_MHZ:\n\t\t\tc->bandwidth_hz = 10000000;\n\t\t\tbreak;\n\t\tcase BANDWIDTH_8_MHZ:\n\t\t\tc->bandwidth_hz = 8000000;\n\t\t\tbreak;\n\t\tcase BANDWIDTH_7_MHZ:\n\t\t\tc->bandwidth_hz = 7000000;\n\t\t\tbreak;\n\t\tcase BANDWIDTH_6_MHZ:\n\t\t\tc->bandwidth_hz = 6000000;\n\t\t\tbreak;\n\t\tcase BANDWIDTH_5_MHZ:\n\t\t\tc->bandwidth_hz = 5000000;\n\t\t\tbreak;\n\t\tcase BANDWIDTH_1_712_MHZ:\n\t\t\tc->bandwidth_hz = 1712000;\n\t\t\tbreak;\n\t\tcase BANDWIDTH_AUTO:\n\t\t\tc->bandwidth_hz = 0;\n\t\t}\n\n\t\tc->code_rate_HP = p->u.ofdm.code_rate_HP;\n\t\tc->code_rate_LP = p->u.ofdm.code_rate_LP;\n\t\tc->modulation = p->u.ofdm.constellation;\n\t\tc->transmission_mode = p->u.ofdm.transmission_mode;\n\t\tc->guard_interval = p->u.ofdm.guard_interval;\n\t\tc->hierarchy = p->u.ofdm.hierarchy_information;\n\t\tbreak;\n\tcase DVBV3_ATSC:\n\t\tdev_dbg(fe->dvb->device, \"%s: Preparing ATSC req\\n\", __func__);\n\t\tc->modulation = p->u.vsb.modulation;\n\t\tif (c->delivery_system == SYS_ATSCMH)\n\t\t\tbreak;\n\t\tif ((c->modulation == VSB_8) || (c->modulation == VSB_16))\n\t\t\tc->delivery_system = SYS_ATSC;\n\t\telse\n\t\t\tc->delivery_system = SYS_DVBC_ANNEX_B;\n\t\tbreak;\n\tcase DVBV3_UNKNOWN:\n\t\tdev_err(fe->dvb->device,\n\t\t\t\"%s: doesn't know how to handle a DVBv3 call to delivery system %i\\n\",\n\t\t\t__func__, c->delivery_system);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\ndtv_property_legacy_params_sync(struct dvb_frontend *fe,\n\t\t\t\tconst struct dtv_frontend_properties *c,\n\t\t\t\tstruct dvb_frontend_parameters *p)\n{\n\tp->frequency = c->frequency;\n\tp->inversion = c->inversion;\n\n\tswitch (dvbv3_type(c->delivery_system)) {\n\tcase DVBV3_UNKNOWN:\n\t\tdev_err(fe->dvb->device,\n\t\t\t\"%s: doesn't know how to handle a DVBv3 call to delivery system %i\\n\",\n\t\t\t__func__, c->delivery_system);\n\t\treturn -EINVAL;\n\tcase DVBV3_QPSK:\n\t\tdev_dbg(fe->dvb->device, \"%s: Preparing QPSK req\\n\", __func__);\n\t\tp->u.qpsk.symbol_rate = c->symbol_rate;\n\t\tp->u.qpsk.fec_inner = c->fec_inner;\n\t\tbreak;\n\tcase DVBV3_QAM:\n\t\tdev_dbg(fe->dvb->device, \"%s: Preparing QAM req\\n\", __func__);\n\t\tp->u.qam.symbol_rate = c->symbol_rate;\n\t\tp->u.qam.fec_inner = c->fec_inner;\n\t\tp->u.qam.modulation = c->modulation;\n\t\tbreak;\n\tcase DVBV3_OFDM:\n\t\tdev_dbg(fe->dvb->device, \"%s: Preparing OFDM req\\n\", __func__);\n\t\tswitch (c->bandwidth_hz) {\n\t\tcase 10000000:\n\t\t\tp->u.ofdm.bandwidth = BANDWIDTH_10_MHZ;\n\t\t\tbreak;\n\t\tcase 8000000:\n\t\t\tp->u.ofdm.bandwidth = BANDWIDTH_8_MHZ;\n\t\t\tbreak;\n\t\tcase 7000000:\n\t\t\tp->u.ofdm.bandwidth = BANDWIDTH_7_MHZ;\n\t\t\tbreak;\n\t\tcase 6000000:\n\t\t\tp->u.ofdm.bandwidth = BANDWIDTH_6_MHZ;\n\t\t\tbreak;\n\t\tcase 5000000:\n\t\t\tp->u.ofdm.bandwidth = BANDWIDTH_5_MHZ;\n\t\t\tbreak;\n\t\tcase 1712000:\n\t\t\tp->u.ofdm.bandwidth = BANDWIDTH_1_712_MHZ;\n\t\t\tbreak;\n\t\tcase 0:\n\t\tdefault:\n\t\t\tp->u.ofdm.bandwidth = BANDWIDTH_AUTO;\n\t\t}\n\t\tp->u.ofdm.code_rate_HP = c->code_rate_HP;\n\t\tp->u.ofdm.code_rate_LP = c->code_rate_LP;\n\t\tp->u.ofdm.constellation = c->modulation;\n\t\tp->u.ofdm.transmission_mode = c->transmission_mode;\n\t\tp->u.ofdm.guard_interval = c->guard_interval;\n\t\tp->u.ofdm.hierarchy_information = c->hierarchy;\n\t\tbreak;\n\tcase DVBV3_ATSC:\n\t\tdev_dbg(fe->dvb->device, \"%s: Preparing VSB req\\n\", __func__);\n\t\tp->u.vsb.modulation = c->modulation;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int dtv_get_frontend(struct dvb_frontend *fe,\n\t\t\t    struct dtv_frontend_properties *c,\n\t\t\t    struct dvb_frontend_parameters *p_out)\n{\n\tint r;\n\n\tif (fe->ops.get_frontend) {\n\t\tr = fe->ops.get_frontend(fe, c);\n\t\tif (unlikely(r < 0))\n\t\t\treturn r;\n\t\tif (p_out)\n\t\t\tdtv_property_legacy_params_sync(fe, c, p_out);\n\t\treturn 0;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic int dvb_frontend_handle_ioctl(struct file *file,\n\t\t\t\t     unsigned int cmd, void *parg);\n\nstatic int dtv_property_process_get(struct dvb_frontend *fe,\n\t\t\t\t    const struct dtv_frontend_properties *c,\n\t\t\t\t    struct dtv_property *tvp,\n\t\t\t\t    struct file *file)\n{\n\tint ncaps;\n\tunsigned int len = 1;\n\n\tswitch (tvp->cmd) {\n\tcase DTV_ENUM_DELSYS:\n\t\tncaps = 0;\n\t\twhile (ncaps < MAX_DELSYS && fe->ops.delsys[ncaps]) {\n\t\t\ttvp->u.buffer.data[ncaps] = fe->ops.delsys[ncaps];\n\t\t\tncaps++;\n\t\t}\n\t\ttvp->u.buffer.len = ncaps;\n\t\tlen = ncaps;\n\t\tbreak;\n\tcase DTV_FREQUENCY:\n\t\ttvp->u.data = c->frequency;\n\t\tbreak;\n\tcase DTV_MODULATION:\n\t\ttvp->u.data = c->modulation;\n\t\tbreak;\n\tcase DTV_BANDWIDTH_HZ:\n\t\ttvp->u.data = c->bandwidth_hz;\n\t\tbreak;\n\tcase DTV_INVERSION:\n\t\ttvp->u.data = c->inversion;\n\t\tbreak;\n\tcase DTV_SYMBOL_RATE:\n\t\ttvp->u.data = c->symbol_rate;\n\t\tbreak;\n\tcase DTV_INNER_FEC:\n\t\ttvp->u.data = c->fec_inner;\n\t\tbreak;\n\tcase DTV_PILOT:\n\t\ttvp->u.data = c->pilot;\n\t\tbreak;\n\tcase DTV_ROLLOFF:\n\t\ttvp->u.data = c->rolloff;\n\t\tbreak;\n\tcase DTV_DELIVERY_SYSTEM:\n\t\ttvp->u.data = c->delivery_system;\n\t\tbreak;\n\tcase DTV_VOLTAGE:\n\t\ttvp->u.data = c->voltage;\n\t\tbreak;\n\tcase DTV_TONE:\n\t\ttvp->u.data = c->sectone;\n\t\tbreak;\n\tcase DTV_API_VERSION:\n\t\ttvp->u.data = (DVB_API_VERSION << 8) | DVB_API_VERSION_MINOR;\n\t\tbreak;\n\tcase DTV_CODE_RATE_HP:\n\t\ttvp->u.data = c->code_rate_HP;\n\t\tbreak;\n\tcase DTV_CODE_RATE_LP:\n\t\ttvp->u.data = c->code_rate_LP;\n\t\tbreak;\n\tcase DTV_GUARD_INTERVAL:\n\t\ttvp->u.data = c->guard_interval;\n\t\tbreak;\n\tcase DTV_TRANSMISSION_MODE:\n\t\ttvp->u.data = c->transmission_mode;\n\t\tbreak;\n\tcase DTV_HIERARCHY:\n\t\ttvp->u.data = c->hierarchy;\n\t\tbreak;\n\tcase DTV_INTERLEAVING:\n\t\ttvp->u.data = c->interleaving;\n\t\tbreak;\n\n\t \n\tcase DTV_ISDBT_PARTIAL_RECEPTION:\n\t\ttvp->u.data = c->isdbt_partial_reception;\n\t\tbreak;\n\tcase DTV_ISDBT_SOUND_BROADCASTING:\n\t\ttvp->u.data = c->isdbt_sb_mode;\n\t\tbreak;\n\tcase DTV_ISDBT_SB_SUBCHANNEL_ID:\n\t\ttvp->u.data = c->isdbt_sb_subchannel;\n\t\tbreak;\n\tcase DTV_ISDBT_SB_SEGMENT_IDX:\n\t\ttvp->u.data = c->isdbt_sb_segment_idx;\n\t\tbreak;\n\tcase DTV_ISDBT_SB_SEGMENT_COUNT:\n\t\ttvp->u.data = c->isdbt_sb_segment_count;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYER_ENABLED:\n\t\ttvp->u.data = c->isdbt_layer_enabled;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERA_FEC:\n\t\ttvp->u.data = c->layer[0].fec;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERA_MODULATION:\n\t\ttvp->u.data = c->layer[0].modulation;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERA_SEGMENT_COUNT:\n\t\ttvp->u.data = c->layer[0].segment_count;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERA_TIME_INTERLEAVING:\n\t\ttvp->u.data = c->layer[0].interleaving;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERB_FEC:\n\t\ttvp->u.data = c->layer[1].fec;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERB_MODULATION:\n\t\ttvp->u.data = c->layer[1].modulation;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERB_SEGMENT_COUNT:\n\t\ttvp->u.data = c->layer[1].segment_count;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERB_TIME_INTERLEAVING:\n\t\ttvp->u.data = c->layer[1].interleaving;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERC_FEC:\n\t\ttvp->u.data = c->layer[2].fec;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERC_MODULATION:\n\t\ttvp->u.data = c->layer[2].modulation;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERC_SEGMENT_COUNT:\n\t\ttvp->u.data = c->layer[2].segment_count;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERC_TIME_INTERLEAVING:\n\t\ttvp->u.data = c->layer[2].interleaving;\n\t\tbreak;\n\n\t \n\tcase DTV_STREAM_ID:\n\tcase DTV_DVBT2_PLP_ID_LEGACY:\n\t\ttvp->u.data = c->stream_id;\n\t\tbreak;\n\n\t \n\tcase DTV_SCRAMBLING_SEQUENCE_INDEX:\n\t\ttvp->u.data = c->scrambling_sequence_index;\n\t\tbreak;\n\n\t \n\tcase DTV_ATSCMH_FIC_VER:\n\t\ttvp->u.data = fe->dtv_property_cache.atscmh_fic_ver;\n\t\tbreak;\n\tcase DTV_ATSCMH_PARADE_ID:\n\t\ttvp->u.data = fe->dtv_property_cache.atscmh_parade_id;\n\t\tbreak;\n\tcase DTV_ATSCMH_NOG:\n\t\ttvp->u.data = fe->dtv_property_cache.atscmh_nog;\n\t\tbreak;\n\tcase DTV_ATSCMH_TNOG:\n\t\ttvp->u.data = fe->dtv_property_cache.atscmh_tnog;\n\t\tbreak;\n\tcase DTV_ATSCMH_SGN:\n\t\ttvp->u.data = fe->dtv_property_cache.atscmh_sgn;\n\t\tbreak;\n\tcase DTV_ATSCMH_PRC:\n\t\ttvp->u.data = fe->dtv_property_cache.atscmh_prc;\n\t\tbreak;\n\tcase DTV_ATSCMH_RS_FRAME_MODE:\n\t\ttvp->u.data = fe->dtv_property_cache.atscmh_rs_frame_mode;\n\t\tbreak;\n\tcase DTV_ATSCMH_RS_FRAME_ENSEMBLE:\n\t\ttvp->u.data = fe->dtv_property_cache.atscmh_rs_frame_ensemble;\n\t\tbreak;\n\tcase DTV_ATSCMH_RS_CODE_MODE_PRI:\n\t\ttvp->u.data = fe->dtv_property_cache.atscmh_rs_code_mode_pri;\n\t\tbreak;\n\tcase DTV_ATSCMH_RS_CODE_MODE_SEC:\n\t\ttvp->u.data = fe->dtv_property_cache.atscmh_rs_code_mode_sec;\n\t\tbreak;\n\tcase DTV_ATSCMH_SCCC_BLOCK_MODE:\n\t\ttvp->u.data = fe->dtv_property_cache.atscmh_sccc_block_mode;\n\t\tbreak;\n\tcase DTV_ATSCMH_SCCC_CODE_MODE_A:\n\t\ttvp->u.data = fe->dtv_property_cache.atscmh_sccc_code_mode_a;\n\t\tbreak;\n\tcase DTV_ATSCMH_SCCC_CODE_MODE_B:\n\t\ttvp->u.data = fe->dtv_property_cache.atscmh_sccc_code_mode_b;\n\t\tbreak;\n\tcase DTV_ATSCMH_SCCC_CODE_MODE_C:\n\t\ttvp->u.data = fe->dtv_property_cache.atscmh_sccc_code_mode_c;\n\t\tbreak;\n\tcase DTV_ATSCMH_SCCC_CODE_MODE_D:\n\t\ttvp->u.data = fe->dtv_property_cache.atscmh_sccc_code_mode_d;\n\t\tbreak;\n\n\tcase DTV_LNA:\n\t\ttvp->u.data = c->lna;\n\t\tbreak;\n\n\t \n\tcase DTV_STAT_SIGNAL_STRENGTH:\n\t\ttvp->u.st = c->strength;\n\t\tif (tvp->u.buffer.len > MAX_DTV_STATS * sizeof(u32))\n\t\t\ttvp->u.buffer.len = MAX_DTV_STATS * sizeof(u32);\n\t\tlen = tvp->u.buffer.len;\n\t\tbreak;\n\tcase DTV_STAT_CNR:\n\t\ttvp->u.st = c->cnr;\n\t\tif (tvp->u.buffer.len > MAX_DTV_STATS * sizeof(u32))\n\t\t\ttvp->u.buffer.len = MAX_DTV_STATS * sizeof(u32);\n\t\tlen = tvp->u.buffer.len;\n\t\tbreak;\n\tcase DTV_STAT_PRE_ERROR_BIT_COUNT:\n\t\ttvp->u.st = c->pre_bit_error;\n\t\tif (tvp->u.buffer.len > MAX_DTV_STATS * sizeof(u32))\n\t\t\ttvp->u.buffer.len = MAX_DTV_STATS * sizeof(u32);\n\t\tlen = tvp->u.buffer.len;\n\t\tbreak;\n\tcase DTV_STAT_PRE_TOTAL_BIT_COUNT:\n\t\ttvp->u.st = c->pre_bit_count;\n\t\tif (tvp->u.buffer.len > MAX_DTV_STATS * sizeof(u32))\n\t\t\ttvp->u.buffer.len = MAX_DTV_STATS * sizeof(u32);\n\t\tlen = tvp->u.buffer.len;\n\t\tbreak;\n\tcase DTV_STAT_POST_ERROR_BIT_COUNT:\n\t\ttvp->u.st = c->post_bit_error;\n\t\tif (tvp->u.buffer.len > MAX_DTV_STATS * sizeof(u32))\n\t\t\ttvp->u.buffer.len = MAX_DTV_STATS * sizeof(u32);\n\t\tlen = tvp->u.buffer.len;\n\t\tbreak;\n\tcase DTV_STAT_POST_TOTAL_BIT_COUNT:\n\t\ttvp->u.st = c->post_bit_count;\n\t\tif (tvp->u.buffer.len > MAX_DTV_STATS * sizeof(u32))\n\t\t\ttvp->u.buffer.len = MAX_DTV_STATS * sizeof(u32);\n\t\tlen = tvp->u.buffer.len;\n\t\tbreak;\n\tcase DTV_STAT_ERROR_BLOCK_COUNT:\n\t\ttvp->u.st = c->block_error;\n\t\tif (tvp->u.buffer.len > MAX_DTV_STATS * sizeof(u32))\n\t\t\ttvp->u.buffer.len = MAX_DTV_STATS * sizeof(u32);\n\t\tlen = tvp->u.buffer.len;\n\t\tbreak;\n\tcase DTV_STAT_TOTAL_BLOCK_COUNT:\n\t\ttvp->u.st = c->block_count;\n\t\tif (tvp->u.buffer.len > MAX_DTV_STATS * sizeof(u32))\n\t\t\ttvp->u.buffer.len = MAX_DTV_STATS * sizeof(u32);\n\t\tlen = tvp->u.buffer.len;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(fe->dvb->device,\n\t\t\t\"%s: FE property %d doesn't exist\\n\",\n\t\t\t__func__, tvp->cmd);\n\t\treturn -EINVAL;\n\t}\n\n\tif (len < 1)\n\t\tlen = 1;\n\n\tdev_dbg(fe->dvb->device,\n\t\t\"%s: GET cmd 0x%08x (%s) len %d: %*ph\\n\",\n\t\t__func__, tvp->cmd, dtv_cmd_name(tvp->cmd),\n\t\ttvp->u.buffer.len, tvp->u.buffer.len, tvp->u.buffer.data);\n\n\treturn 0;\n}\n\nstatic int dtv_set_frontend(struct dvb_frontend *fe);\n\nstatic bool is_dvbv3_delsys(u32 delsys)\n{\n\treturn (delsys == SYS_DVBT) || (delsys == SYS_DVBC_ANNEX_A) ||\n\t       (delsys == SYS_DVBS) || (delsys == SYS_ATSC);\n}\n\n \nstatic int emulate_delivery_system(struct dvb_frontend *fe, u32 delsys)\n{\n\tint i;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tc->delivery_system = delsys;\n\n\t \n\tif (c->delivery_system == SYS_ISDBT) {\n\t\tdev_dbg(fe->dvb->device,\n\t\t\t\"%s: Using defaults for SYS_ISDBT\\n\",\n\t\t\t__func__);\n\n\t\tif (!c->bandwidth_hz)\n\t\t\tc->bandwidth_hz = 6000000;\n\n\t\tc->isdbt_partial_reception = 0;\n\t\tc->isdbt_sb_mode = 0;\n\t\tc->isdbt_sb_subchannel = 0;\n\t\tc->isdbt_sb_segment_idx = 0;\n\t\tc->isdbt_sb_segment_count = 0;\n\t\tc->isdbt_layer_enabled = 7;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tc->layer[i].fec = FEC_AUTO;\n\t\t\tc->layer[i].modulation = QAM_AUTO;\n\t\t\tc->layer[i].interleaving = 0;\n\t\t\tc->layer[i].segment_count = 0;\n\t\t}\n\t}\n\tdev_dbg(fe->dvb->device, \"%s: change delivery system on cache to %d\\n\",\n\t\t__func__, c->delivery_system);\n\n\treturn 0;\n}\n\n \nstatic int dvbv5_set_delivery_system(struct dvb_frontend *fe,\n\t\t\t\t     u32 desired_system)\n{\n\tint ncaps;\n\tu32 delsys = SYS_UNDEFINED;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tenum dvbv3_emulation_type type;\n\n\t \n\tif (desired_system == SYS_UNDEFINED)\n\t\tdesired_system = fe->ops.delsys[0];\n\n\t \n\tncaps = 0;\n\twhile (ncaps < MAX_DELSYS && fe->ops.delsys[ncaps]) {\n\t\tif (fe->ops.delsys[ncaps] == desired_system) {\n\t\t\tc->delivery_system = desired_system;\n\t\t\tdev_dbg(fe->dvb->device,\n\t\t\t\t\"%s: Changing delivery system to %d\\n\",\n\t\t\t\t__func__, desired_system);\n\t\t\treturn 0;\n\t\t}\n\t\tncaps++;\n\t}\n\n\t \n\tif (!is_dvbv3_delsys(desired_system)) {\n\t\tdev_dbg(fe->dvb->device,\n\t\t\t\"%s: Delivery system %d not supported.\\n\",\n\t\t\t__func__, desired_system);\n\t\treturn -EINVAL;\n\t}\n\n\ttype = dvbv3_type(desired_system);\n\n\t \n\tncaps = 0;\n\twhile (ncaps < MAX_DELSYS && fe->ops.delsys[ncaps]) {\n\t\tif (dvbv3_type(fe->ops.delsys[ncaps]) == type)\n\t\t\tdelsys = fe->ops.delsys[ncaps];\n\t\tncaps++;\n\t}\n\n\t \n\tif (delsys == SYS_UNDEFINED) {\n\t\tdev_dbg(fe->dvb->device,\n\t\t\t\"%s: Delivery system %d not supported on emulation mode.\\n\",\n\t\t\t__func__, desired_system);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(fe->dvb->device,\n\t\t\"%s: Using delivery system %d emulated as if it were %d\\n\",\n\t\t__func__, delsys, desired_system);\n\n\treturn emulate_delivery_system(fe, desired_system);\n}\n\n \nstatic int dvbv3_set_delivery_system(struct dvb_frontend *fe)\n{\n\tint ncaps;\n\tu32 delsys = SYS_UNDEFINED;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\t \n\tif (c->delivery_system == SYS_UNDEFINED)\n\t\tc->delivery_system = fe->ops.delsys[0];\n\n\t \n\tif (is_dvbv3_delsys(c->delivery_system)) {\n\t\tdev_dbg(fe->dvb->device,\n\t\t\t\"%s: Using delivery system to %d\\n\",\n\t\t\t__func__, c->delivery_system);\n\t\treturn 0;\n\t}\n\n\t \n\tncaps = 0;\n\twhile (ncaps < MAX_DELSYS && fe->ops.delsys[ncaps]) {\n\t\tif (dvbv3_type(fe->ops.delsys[ncaps]) != DVBV3_UNKNOWN) {\n\t\t\tdelsys = fe->ops.delsys[ncaps];\n\t\t\tbreak;\n\t\t}\n\t\tncaps++;\n\t}\n\tif (delsys == SYS_UNDEFINED) {\n\t\tdev_dbg(fe->dvb->device,\n\t\t\t\"%s: Couldn't find a delivery system that works with FE_SET_FRONTEND\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\treturn emulate_delivery_system(fe, delsys);\n}\n\nstatic void prepare_tuning_algo_parameters(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tstruct dvb_frontend_tune_settings fetunesettings = { 0 };\n\n\t \n\tif (fe->ops.get_tune_settings && (fe->ops.get_tune_settings(fe, &fetunesettings) == 0)) {\n\t\tfepriv->min_delay = (fetunesettings.min_delay_ms * HZ) / 1000;\n\t\tfepriv->max_drift = fetunesettings.max_drift;\n\t\tfepriv->step_size = fetunesettings.step_size;\n\t} else {\n\t\t \n\t\tswitch (c->delivery_system) {\n\t\tcase SYS_DSS:\n\t\tcase SYS_DVBS:\n\t\tcase SYS_DVBS2:\n\t\tcase SYS_ISDBS:\n\t\tcase SYS_TURBO:\n\t\tcase SYS_DVBC_ANNEX_A:\n\t\tcase SYS_DVBC_ANNEX_C:\n\t\t\tfepriv->min_delay = HZ / 20;\n\t\t\tfepriv->step_size = c->symbol_rate / 16000;\n\t\t\tfepriv->max_drift = c->symbol_rate / 2000;\n\t\t\tbreak;\n\t\tcase SYS_DVBT:\n\t\tcase SYS_DVBT2:\n\t\tcase SYS_ISDBT:\n\t\tcase SYS_DTMB:\n\t\t\tfepriv->min_delay = HZ / 20;\n\t\t\tfepriv->step_size = dvb_frontend_get_stepsize(fe) * 2;\n\t\t\tfepriv->max_drift = fepriv->step_size + 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tfepriv->min_delay = HZ / 20;\n\t\t\tfepriv->step_size = 0;  \n\t\t\tfepriv->max_drift = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (dvb_override_tune_delay > 0)\n\t\tfepriv->min_delay = (dvb_override_tune_delay * HZ) / 1000;\n}\n\n \nstatic int dtv_property_process_set(struct dvb_frontend *fe,\n\t\t\t\t    struct file *file,\n\t\t\t\t    u32 cmd, u32 data)\n{\n\tint r = 0;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\t \n\tif (!cmd || cmd > DTV_MAX_COMMAND)\n\t\tdev_warn(fe->dvb->device, \"%s: SET cmd 0x%08x undefined\\n\",\n\t\t\t __func__, cmd);\n\telse\n\t\tdev_dbg(fe->dvb->device,\n\t\t\t\"%s: SET cmd 0x%08x (%s) to 0x%08x\\n\",\n\t\t\t__func__, cmd, dtv_cmd_name(cmd), data);\n\tswitch (cmd) {\n\tcase DTV_CLEAR:\n\t\t \n\t\tdvb_frontend_clear_cache(fe);\n\t\tbreak;\n\tcase DTV_TUNE:\n\t\t \n\t\tdev_dbg(fe->dvb->device,\n\t\t\t\"%s: Setting the frontend from property cache\\n\",\n\t\t\t__func__);\n\n\t\tr = dtv_set_frontend(fe);\n\t\tbreak;\n\tcase DTV_FREQUENCY:\n\t\tc->frequency = data;\n\t\tbreak;\n\tcase DTV_MODULATION:\n\t\tc->modulation = data;\n\t\tbreak;\n\tcase DTV_BANDWIDTH_HZ:\n\t\tc->bandwidth_hz = data;\n\t\tbreak;\n\tcase DTV_INVERSION:\n\t\tc->inversion = data;\n\t\tbreak;\n\tcase DTV_SYMBOL_RATE:\n\t\tc->symbol_rate = data;\n\t\tbreak;\n\tcase DTV_INNER_FEC:\n\t\tc->fec_inner = data;\n\t\tbreak;\n\tcase DTV_PILOT:\n\t\tc->pilot = data;\n\t\tbreak;\n\tcase DTV_ROLLOFF:\n\t\tc->rolloff = data;\n\t\tbreak;\n\tcase DTV_DELIVERY_SYSTEM:\n\t\tr = dvbv5_set_delivery_system(fe, data);\n\t\tbreak;\n\tcase DTV_VOLTAGE:\n\t\tc->voltage = data;\n\t\tr = dvb_frontend_handle_ioctl(file, FE_SET_VOLTAGE,\n\t\t\t\t\t      (void *)c->voltage);\n\t\tbreak;\n\tcase DTV_TONE:\n\t\tc->sectone = data;\n\t\tr = dvb_frontend_handle_ioctl(file, FE_SET_TONE,\n\t\t\t\t\t      (void *)c->sectone);\n\t\tbreak;\n\tcase DTV_CODE_RATE_HP:\n\t\tc->code_rate_HP = data;\n\t\tbreak;\n\tcase DTV_CODE_RATE_LP:\n\t\tc->code_rate_LP = data;\n\t\tbreak;\n\tcase DTV_GUARD_INTERVAL:\n\t\tc->guard_interval = data;\n\t\tbreak;\n\tcase DTV_TRANSMISSION_MODE:\n\t\tc->transmission_mode = data;\n\t\tbreak;\n\tcase DTV_HIERARCHY:\n\t\tc->hierarchy = data;\n\t\tbreak;\n\tcase DTV_INTERLEAVING:\n\t\tc->interleaving = data;\n\t\tbreak;\n\n\t \n\tcase DTV_ISDBT_PARTIAL_RECEPTION:\n\t\tc->isdbt_partial_reception = data;\n\t\tbreak;\n\tcase DTV_ISDBT_SOUND_BROADCASTING:\n\t\tc->isdbt_sb_mode = data;\n\t\tbreak;\n\tcase DTV_ISDBT_SB_SUBCHANNEL_ID:\n\t\tc->isdbt_sb_subchannel = data;\n\t\tbreak;\n\tcase DTV_ISDBT_SB_SEGMENT_IDX:\n\t\tc->isdbt_sb_segment_idx = data;\n\t\tbreak;\n\tcase DTV_ISDBT_SB_SEGMENT_COUNT:\n\t\tc->isdbt_sb_segment_count = data;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYER_ENABLED:\n\t\tc->isdbt_layer_enabled = data;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERA_FEC:\n\t\tc->layer[0].fec = data;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERA_MODULATION:\n\t\tc->layer[0].modulation = data;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERA_SEGMENT_COUNT:\n\t\tc->layer[0].segment_count = data;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERA_TIME_INTERLEAVING:\n\t\tc->layer[0].interleaving = data;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERB_FEC:\n\t\tc->layer[1].fec = data;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERB_MODULATION:\n\t\tc->layer[1].modulation = data;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERB_SEGMENT_COUNT:\n\t\tc->layer[1].segment_count = data;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERB_TIME_INTERLEAVING:\n\t\tc->layer[1].interleaving = data;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERC_FEC:\n\t\tc->layer[2].fec = data;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERC_MODULATION:\n\t\tc->layer[2].modulation = data;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERC_SEGMENT_COUNT:\n\t\tc->layer[2].segment_count = data;\n\t\tbreak;\n\tcase DTV_ISDBT_LAYERC_TIME_INTERLEAVING:\n\t\tc->layer[2].interleaving = data;\n\t\tbreak;\n\n\t \n\tcase DTV_STREAM_ID:\n\tcase DTV_DVBT2_PLP_ID_LEGACY:\n\t\tc->stream_id = data;\n\t\tbreak;\n\n\t \n\tcase DTV_SCRAMBLING_SEQUENCE_INDEX:\n\t\tc->scrambling_sequence_index = data;\n\t\tbreak;\n\n\t \n\tcase DTV_ATSCMH_PARADE_ID:\n\t\tfe->dtv_property_cache.atscmh_parade_id = data;\n\t\tbreak;\n\tcase DTV_ATSCMH_RS_FRAME_ENSEMBLE:\n\t\tfe->dtv_property_cache.atscmh_rs_frame_ensemble = data;\n\t\tbreak;\n\n\tcase DTV_LNA:\n\t\tc->lna = data;\n\t\tif (fe->ops.set_lna)\n\t\t\tr = fe->ops.set_lna(fe);\n\t\tif (r < 0)\n\t\t\tc->lna = LNA_AUTO;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn r;\n}\n\nstatic int dvb_frontend_do_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t void *parg)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dvb_frontend *fe = dvbdev->priv;\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tint err;\n\n\tdev_dbg(fe->dvb->device, \"%s: (%d)\\n\", __func__, _IOC_NR(cmd));\n\tif (down_interruptible(&fepriv->sem))\n\t\treturn -ERESTARTSYS;\n\n\tif (fe->exit != DVB_FE_NO_EXIT) {\n\t\tup(&fepriv->sem);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif ((file->f_flags & O_ACCMODE) == O_RDONLY\n\t    && (_IOC_DIR(cmd) != _IOC_READ\n\t\t|| cmd == FE_GET_EVENT\n\t\t|| cmd == FE_DISEQC_RECV_SLAVE_REPLY)) {\n\t\tup(&fepriv->sem);\n\t\treturn -EPERM;\n\t}\n\n\terr = dvb_frontend_handle_ioctl(file, cmd, parg);\n\n\tup(&fepriv->sem);\n\treturn err;\n}\n\nstatic long dvb_frontend_ioctl(struct file *file, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\n\tif (!dvbdev)\n\t\treturn -ENODEV;\n\n\treturn dvb_usercopy(file, cmd, arg, dvb_frontend_do_ioctl);\n}\n\n#ifdef CONFIG_COMPAT\nstruct compat_dtv_property {\n\t__u32 cmd;\n\t__u32 reserved[3];\n\tunion {\n\t\t__u32 data;\n\t\tstruct dtv_fe_stats st;\n\t\tstruct {\n\t\t\t__u8 data[32];\n\t\t\t__u32 len;\n\t\t\t__u32 reserved1[3];\n\t\t\tcompat_uptr_t reserved2;\n\t\t} buffer;\n\t} u;\n\tint result;\n} __attribute__ ((packed));\n\nstruct compat_dtv_properties {\n\t__u32 num;\n\tcompat_uptr_t props;\n};\n\n#define COMPAT_FE_SET_PROPERTY\t   _IOW('o', 82, struct compat_dtv_properties)\n#define COMPAT_FE_GET_PROPERTY\t   _IOR('o', 83, struct compat_dtv_properties)\n\nstatic int dvb_frontend_handle_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\t    unsigned long arg)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dvb_frontend *fe = dvbdev->priv;\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tint i, err = 0;\n\n\tif (cmd == COMPAT_FE_SET_PROPERTY) {\n\t\tstruct compat_dtv_properties prop, *tvps = NULL;\n\t\tstruct compat_dtv_property *tvp = NULL;\n\n\t\tif (copy_from_user(&prop, compat_ptr(arg), sizeof(prop)))\n\t\t\treturn -EFAULT;\n\n\t\ttvps = &prop;\n\n\t\t \n\t\tif (!tvps->num || (tvps->num > DTV_IOCTL_MAX_MSGS))\n\t\t\treturn -EINVAL;\n\n\t\ttvp = memdup_user(compat_ptr(tvps->props), tvps->num * sizeof(*tvp));\n\t\tif (IS_ERR(tvp))\n\t\t\treturn PTR_ERR(tvp);\n\n\t\tfor (i = 0; i < tvps->num; i++) {\n\t\t\terr = dtv_property_process_set(fe, file,\n\t\t\t\t\t\t       (tvp + i)->cmd,\n\t\t\t\t\t\t       (tvp + i)->u.data);\n\t\t\tif (err < 0) {\n\t\t\t\tkfree(tvp);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tkfree(tvp);\n\t} else if (cmd == COMPAT_FE_GET_PROPERTY) {\n\t\tstruct compat_dtv_properties prop, *tvps = NULL;\n\t\tstruct compat_dtv_property *tvp = NULL;\n\t\tstruct dtv_frontend_properties getp = fe->dtv_property_cache;\n\n\t\tif (copy_from_user(&prop, compat_ptr(arg), sizeof(prop)))\n\t\t\treturn -EFAULT;\n\n\t\ttvps = &prop;\n\n\t\t \n\t\tif (!tvps->num || (tvps->num > DTV_IOCTL_MAX_MSGS))\n\t\t\treturn -EINVAL;\n\n\t\ttvp = memdup_user(compat_ptr(tvps->props), tvps->num * sizeof(*tvp));\n\t\tif (IS_ERR(tvp))\n\t\t\treturn PTR_ERR(tvp);\n\n\t\t \n\t\tif (fepriv->state != FESTATE_IDLE) {\n\t\t\terr = dtv_get_frontend(fe, &getp, NULL);\n\t\t\tif (err < 0) {\n\t\t\t\tkfree(tvp);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < tvps->num; i++) {\n\t\t\terr = dtv_property_process_get(\n\t\t\t    fe, &getp, (struct dtv_property *)(tvp + i), file);\n\t\t\tif (err < 0) {\n\t\t\t\tkfree(tvp);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tif (copy_to_user((void __user *)compat_ptr(tvps->props), tvp,\n\t\t\t\t tvps->num * sizeof(struct compat_dtv_property))) {\n\t\t\tkfree(tvp);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tkfree(tvp);\n\t}\n\n\treturn err;\n}\n\nstatic long dvb_frontend_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t      unsigned long arg)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dvb_frontend *fe = dvbdev->priv;\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tint err;\n\n\tif (cmd == COMPAT_FE_SET_PROPERTY || cmd == COMPAT_FE_GET_PROPERTY) {\n\t\tif (down_interruptible(&fepriv->sem))\n\t\t\treturn -ERESTARTSYS;\n\n\t\terr = dvb_frontend_handle_compat_ioctl(file, cmd, arg);\n\n\t\tup(&fepriv->sem);\n\t\treturn err;\n\t}\n\n\treturn dvb_frontend_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\n}\n#endif\n\nstatic int dtv_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 rolloff = 0;\n\n\tif (dvb_frontend_check_parameters(fe) < 0)\n\t\treturn -EINVAL;\n\n\t \n\tdtv_property_legacy_params_sync(fe, c, &fepriv->parameters_out);\n\n\t \n\tswitch (c->delivery_system) {\n\tcase SYS_ATSC:\n\tcase SYS_DVBC_ANNEX_B:\n\t\tc->bandwidth_hz = 6000000;\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\trolloff = 115;\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_C:\n\t\trolloff = 113;\n\t\tbreak;\n\tcase SYS_DSS:\n\t\trolloff = 120;\n\t\tbreak;\n\tcase SYS_DVBS:\n\tcase SYS_TURBO:\n\tcase SYS_ISDBS:\n\t\trolloff = 135;\n\t\tbreak;\n\tcase SYS_DVBS2:\n\t\tswitch (c->rolloff) {\n\t\tcase ROLLOFF_20:\n\t\t\trolloff = 120;\n\t\t\tbreak;\n\t\tcase ROLLOFF_25:\n\t\t\trolloff = 125;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase ROLLOFF_35:\n\t\t\trolloff = 135;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (rolloff)\n\t\tc->bandwidth_hz = mult_frac(c->symbol_rate, rolloff, 100);\n\n\t \n\tif (dvb_force_auto_inversion)\n\t\tc->inversion = INVERSION_AUTO;\n\n\t \n\tif (c->hierarchy == HIERARCHY_NONE && c->code_rate_LP == FEC_NONE)\n\t\tc->code_rate_LP = FEC_AUTO;\n\n\tprepare_tuning_algo_parameters(fe);\n\n\tfepriv->state = FESTATE_RETUNE;\n\n\t \n\tfepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;\n\n\tdvb_frontend_clear_events(fe);\n\tdvb_frontend_add_event(fe, 0);\n\tdvb_frontend_wakeup(fe);\n\tfepriv->status = 0;\n\n\treturn 0;\n}\n\nstatic int dvb_get_property(struct dvb_frontend *fe, struct file *file,\n\t\t\t    struct dtv_properties *tvps)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tstruct dtv_property *tvp = NULL;\n\tstruct dtv_frontend_properties getp;\n\tint i, err;\n\n\tmemcpy(&getp, &fe->dtv_property_cache, sizeof(getp));\n\n\tdev_dbg(fe->dvb->device, \"%s: properties.num = %d\\n\",\n\t\t__func__, tvps->num);\n\tdev_dbg(fe->dvb->device, \"%s: properties.props = %p\\n\",\n\t\t__func__, tvps->props);\n\n\t \n\tif (!tvps->num || tvps->num > DTV_IOCTL_MAX_MSGS)\n\t\treturn -EINVAL;\n\n\ttvp = memdup_user((void __user *)tvps->props, tvps->num * sizeof(*tvp));\n\tif (IS_ERR(tvp))\n\t\treturn PTR_ERR(tvp);\n\n\t \n\tif (fepriv->state != FESTATE_IDLE) {\n\t\terr = dtv_get_frontend(fe, &getp, NULL);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\tfor (i = 0; i < tvps->num; i++) {\n\t\terr = dtv_property_process_get(fe, &getp,\n\t\t\t\t\t       tvp + i, file);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (copy_to_user((void __user *)tvps->props, tvp,\n\t\t\t tvps->num * sizeof(struct dtv_property))) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terr = 0;\nout:\n\tkfree(tvp);\n\treturn err;\n}\n\nstatic int dvb_get_frontend(struct dvb_frontend *fe,\n\t\t\t    struct dvb_frontend_parameters *p_out)\n{\n\tstruct dtv_frontend_properties getp;\n\n\t \n\tmemcpy(&getp, &fe->dtv_property_cache, sizeof(getp));\n\n\treturn dtv_get_frontend(fe, &getp, p_out);\n}\n\nstatic int dvb_frontend_handle_ioctl(struct file *file,\n\t\t\t\t     unsigned int cmd, void *parg)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dvb_frontend *fe = dvbdev->priv;\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint i, err = -ENOTSUPP;\n\n\tdev_dbg(fe->dvb->device, \"%s:\\n\", __func__);\n\n\tswitch (cmd) {\n\tcase FE_SET_PROPERTY: {\n\t\tstruct dtv_properties *tvps = parg;\n\t\tstruct dtv_property *tvp = NULL;\n\n\t\tdev_dbg(fe->dvb->device, \"%s: properties.num = %d\\n\",\n\t\t\t__func__, tvps->num);\n\t\tdev_dbg(fe->dvb->device, \"%s: properties.props = %p\\n\",\n\t\t\t__func__, tvps->props);\n\n\t\t \n\t\tif (!tvps->num || (tvps->num > DTV_IOCTL_MAX_MSGS))\n\t\t\treturn -EINVAL;\n\n\t\ttvp = memdup_user((void __user *)tvps->props, tvps->num * sizeof(*tvp));\n\t\tif (IS_ERR(tvp))\n\t\t\treturn PTR_ERR(tvp);\n\n\t\tfor (i = 0; i < tvps->num; i++) {\n\t\t\terr = dtv_property_process_set(fe, file,\n\t\t\t\t\t\t       (tvp + i)->cmd,\n\t\t\t\t\t\t       (tvp + i)->u.data);\n\t\t\tif (err < 0) {\n\t\t\t\tkfree(tvp);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tkfree(tvp);\n\t\terr = 0;\n\t\tbreak;\n\t}\n\tcase FE_GET_PROPERTY:\n\t\terr = dvb_get_property(fe, file, parg);\n\t\tbreak;\n\n\tcase FE_GET_INFO: {\n\t\tstruct dvb_frontend_info *info = parg;\n\t\tmemset(info, 0, sizeof(*info));\n\n\t\tstrscpy(info->name, fe->ops.info.name, sizeof(info->name));\n\t\tinfo->symbol_rate_min = fe->ops.info.symbol_rate_min;\n\t\tinfo->symbol_rate_max = fe->ops.info.symbol_rate_max;\n\t\tinfo->symbol_rate_tolerance = fe->ops.info.symbol_rate_tolerance;\n\t\tinfo->caps = fe->ops.info.caps;\n\t\tinfo->frequency_stepsize = dvb_frontend_get_stepsize(fe);\n\t\tdvb_frontend_get_frequency_limits(fe, &info->frequency_min,\n\t\t\t\t\t\t  &info->frequency_max,\n\t\t\t\t\t\t  &info->frequency_tolerance);\n\n\t\t \n\t\tswitch (dvbv3_type(c->delivery_system)) {\n\t\tcase DVBV3_QPSK:\n\t\t\tinfo->type = FE_QPSK;\n\t\t\tbreak;\n\t\tcase DVBV3_ATSC:\n\t\t\tinfo->type = FE_ATSC;\n\t\t\tbreak;\n\t\tcase DVBV3_QAM:\n\t\t\tinfo->type = FE_QAM;\n\t\t\tbreak;\n\t\tcase DVBV3_OFDM:\n\t\t\tinfo->type = FE_OFDM;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(fe->dvb->device,\n\t\t\t\t\"%s: doesn't know how to handle a DVBv3 call to delivery system %i\\n\",\n\t\t\t\t__func__, c->delivery_system);\n\t\t\tinfo->type = FE_OFDM;\n\t\t}\n\t\tdev_dbg(fe->dvb->device, \"%s: current delivery system on cache: %d, V3 type: %d\\n\",\n\t\t\t__func__, c->delivery_system, info->type);\n\n\t\t \n\t\tif (!(fepriv->tune_mode_flags & FE_TUNE_MODE_ONESHOT))\n\t\t\tinfo->caps |= FE_CAN_INVERSION_AUTO;\n\t\terr = 0;\n\t\tbreak;\n\t}\n\n\tcase FE_READ_STATUS: {\n\t\tenum fe_status *status = parg;\n\n\t\t \n\t\tif (fepriv->state == FESTATE_RETUNE ||\n\t\t    fepriv->state == FESTATE_ERROR) {\n\t\t\terr = 0;\n\t\t\t*status = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (fe->ops.read_status)\n\t\t\terr = fe->ops.read_status(fe, status);\n\t\tbreak;\n\t}\n\n\tcase FE_DISEQC_RESET_OVERLOAD:\n\t\tif (fe->ops.diseqc_reset_overload) {\n\t\t\terr = fe->ops.diseqc_reset_overload(fe);\n\t\t\tfepriv->state = FESTATE_DISEQC;\n\t\t\tfepriv->status = 0;\n\t\t}\n\t\tbreak;\n\n\tcase FE_DISEQC_SEND_MASTER_CMD:\n\t\tif (fe->ops.diseqc_send_master_cmd) {\n\t\t\tstruct dvb_diseqc_master_cmd *cmd = parg;\n\n\t\t\tif (cmd->msg_len > sizeof(cmd->msg)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = fe->ops.diseqc_send_master_cmd(fe, cmd);\n\t\t\tfepriv->state = FESTATE_DISEQC;\n\t\t\tfepriv->status = 0;\n\t\t}\n\t\tbreak;\n\n\tcase FE_DISEQC_SEND_BURST:\n\t\tif (fe->ops.diseqc_send_burst) {\n\t\t\terr = fe->ops.diseqc_send_burst(fe, (long)parg);\n\t\t\tfepriv->state = FESTATE_DISEQC;\n\t\t\tfepriv->status = 0;\n\t\t}\n\t\tbreak;\n\n\tcase FE_SET_TONE:\n\t\tif (fe->ops.set_tone) {\n\t\t\tfepriv->tone = (long)parg;\n\t\t\terr = fe->ops.set_tone(fe, fepriv->tone);\n\t\t\tfepriv->state = FESTATE_DISEQC;\n\t\t\tfepriv->status = 0;\n\t\t}\n\t\tbreak;\n\n\tcase FE_SET_VOLTAGE:\n\t\tif (fe->ops.set_voltage) {\n\t\t\tfepriv->voltage = (long)parg;\n\t\t\terr = fe->ops.set_voltage(fe, fepriv->voltage);\n\t\t\tfepriv->state = FESTATE_DISEQC;\n\t\t\tfepriv->status = 0;\n\t\t}\n\t\tbreak;\n\n\tcase FE_DISEQC_RECV_SLAVE_REPLY:\n\t\tif (fe->ops.diseqc_recv_slave_reply)\n\t\t\terr = fe->ops.diseqc_recv_slave_reply(fe, parg);\n\t\tbreak;\n\n\tcase FE_ENABLE_HIGH_LNB_VOLTAGE:\n\t\tif (fe->ops.enable_high_lnb_voltage)\n\t\t\terr = fe->ops.enable_high_lnb_voltage(fe, (long)parg);\n\t\tbreak;\n\n\tcase FE_SET_FRONTEND_TUNE_MODE:\n\t\tfepriv->tune_mode_flags = (unsigned long)parg;\n\t\terr = 0;\n\t\tbreak;\n\t \n\n\tcase FE_DISHNETWORK_SEND_LEGACY_CMD:\n\t\tif (fe->ops.dishnetwork_send_legacy_command) {\n\t\t\terr = fe->ops.dishnetwork_send_legacy_command(fe,\n\t\t\t\t\t\t\t (unsigned long)parg);\n\t\t\tfepriv->state = FESTATE_DISEQC;\n\t\t\tfepriv->status = 0;\n\t\t} else if (fe->ops.set_voltage) {\n\t\t\t \n\t\t\tunsigned long swcmd = ((unsigned long)parg) << 1;\n\t\t\tktime_t nexttime;\n\t\t\tktime_t tv[10];\n\t\t\tint i;\n\t\t\tu8 last = 1;\n\n\t\t\tif (dvb_frontend_debug)\n\t\t\t\tdprintk(\"switch command: 0x%04lx\\n\",\n\t\t\t\t\tswcmd);\n\t\t\tnexttime = ktime_get_boottime();\n\t\t\tif (dvb_frontend_debug)\n\t\t\t\ttv[0] = nexttime;\n\t\t\t \n\t\t\tfe->ops.set_voltage(fe, SEC_VOLTAGE_18);\n\t\t\tdvb_frontend_sleep_until(&nexttime, 32000);\n\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tif (dvb_frontend_debug)\n\t\t\t\t\ttv[i + 1] = ktime_get_boottime();\n\t\t\t\tif ((swcmd & 0x01) != last) {\n\t\t\t\t\t \n\t\t\t\t\tfe->ops.set_voltage(fe, (last) ? SEC_VOLTAGE_13 : SEC_VOLTAGE_18);\n\t\t\t\t\tlast = (last) ? 0 : 1;\n\t\t\t\t}\n\t\t\t\tswcmd = swcmd >> 1;\n\t\t\t\tif (i != 8)\n\t\t\t\t\tdvb_frontend_sleep_until(&nexttime, 8000);\n\t\t\t}\n\t\t\tif (dvb_frontend_debug) {\n\t\t\t\tdprintk(\"(adapter %d): switch delay (should be 32k followed by all 8k)\\n\",\n\t\t\t\t\tfe->dvb->num);\n\t\t\t\tfor (i = 1; i < 10; i++)\n\t\t\t\t\tpr_info(\"%d: %d\\n\", i,\n\t\t\t\t\t\t(int)ktime_us_delta(tv[i], tv[i - 1]));\n\t\t\t}\n\t\t\terr = 0;\n\t\t\tfepriv->state = FESTATE_DISEQC;\n\t\t\tfepriv->status = 0;\n\t\t}\n\t\tbreak;\n\n\t \n\n\tcase FE_READ_BER:\n\t\tif (fe->ops.read_ber) {\n\t\t\tif (fepriv->thread)\n\t\t\t\terr = fe->ops.read_ber(fe, parg);\n\t\t\telse\n\t\t\t\terr = -EAGAIN;\n\t\t}\n\t\tbreak;\n\n\tcase FE_READ_SIGNAL_STRENGTH:\n\t\tif (fe->ops.read_signal_strength) {\n\t\t\tif (fepriv->thread)\n\t\t\t\terr = fe->ops.read_signal_strength(fe, parg);\n\t\t\telse\n\t\t\t\terr = -EAGAIN;\n\t\t}\n\t\tbreak;\n\n\tcase FE_READ_SNR:\n\t\tif (fe->ops.read_snr) {\n\t\t\tif (fepriv->thread)\n\t\t\t\terr = fe->ops.read_snr(fe, parg);\n\t\t\telse\n\t\t\t\terr = -EAGAIN;\n\t\t}\n\t\tbreak;\n\n\tcase FE_READ_UNCORRECTED_BLOCKS:\n\t\tif (fe->ops.read_ucblocks) {\n\t\t\tif (fepriv->thread)\n\t\t\t\terr = fe->ops.read_ucblocks(fe, parg);\n\t\t\telse\n\t\t\t\terr = -EAGAIN;\n\t\t}\n\t\tbreak;\n\n\t \n\n\tcase FE_SET_FRONTEND:\n\t\terr = dvbv3_set_delivery_system(fe);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = dtv_property_cache_sync(fe, c, parg);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = dtv_set_frontend(fe);\n\t\tbreak;\n\n\tcase FE_GET_EVENT:\n\t\terr = dvb_frontend_get_event(fe, parg, file->f_flags);\n\t\tbreak;\n\n\tcase FE_GET_FRONTEND:\n\t\terr = dvb_get_frontend(fe, parg);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}  \n\n\treturn err;\n}\n\nstatic __poll_t dvb_frontend_poll(struct file *file, struct poll_table_struct *wait)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dvb_frontend *fe = dvbdev->priv;\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\n\tdev_dbg_ratelimited(fe->dvb->device, \"%s:\\n\", __func__);\n\n\tpoll_wait(file, &fepriv->events.wait_queue, wait);\n\n\tif (fepriv->events.eventw != fepriv->events.eventr)\n\t\treturn (EPOLLIN | EPOLLRDNORM | EPOLLPRI);\n\n\treturn 0;\n}\n\nstatic int dvb_frontend_open(struct inode *inode, struct file *file)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dvb_frontend *fe = dvbdev->priv;\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tstruct dvb_adapter *adapter = fe->dvb;\n\tint ret;\n\n\tdev_dbg(fe->dvb->device, \"%s:\\n\", __func__);\n\tif (fe->exit == DVB_FE_DEVICE_REMOVED)\n\t\treturn -ENODEV;\n\n\tif (adapter->mfe_shared == 2) {\n\t\tmutex_lock(&adapter->mfe_lock);\n\t\tif ((file->f_flags & O_ACCMODE) != O_RDONLY) {\n\t\t\tif (adapter->mfe_dvbdev &&\n\t\t\t    !adapter->mfe_dvbdev->writers) {\n\t\t\t\tmutex_unlock(&adapter->mfe_lock);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\tadapter->mfe_dvbdev = dvbdev;\n\t\t}\n\t} else if (adapter->mfe_shared) {\n\t\tmutex_lock(&adapter->mfe_lock);\n\n\t\tif (!adapter->mfe_dvbdev)\n\t\t\tadapter->mfe_dvbdev = dvbdev;\n\n\t\telse if (adapter->mfe_dvbdev != dvbdev) {\n\t\t\tstruct dvb_device\n\t\t\t\t*mfedev = adapter->mfe_dvbdev;\n\t\t\tstruct dvb_frontend\n\t\t\t\t*mfe = mfedev->priv;\n\t\t\tstruct dvb_frontend_private\n\t\t\t\t*mfepriv = mfe->frontend_priv;\n\t\t\tint mferetry = (dvb_mfe_wait_time << 1);\n\n\t\t\tmutex_unlock(&adapter->mfe_lock);\n\t\t\twhile (mferetry-- && (mfedev->users != -1 ||\n\t\t\t\t\t      mfepriv->thread)) {\n\t\t\t\tif (msleep_interruptible(500)) {\n\t\t\t\t\tif (signal_pending(current))\n\t\t\t\t\t\treturn -EINTR;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmutex_lock(&adapter->mfe_lock);\n\t\t\tif (adapter->mfe_dvbdev != dvbdev) {\n\t\t\t\tmfedev = adapter->mfe_dvbdev;\n\t\t\t\tmfe = mfedev->priv;\n\t\t\t\tmfepriv = mfe->frontend_priv;\n\t\t\t\tif (mfedev->users != -1 ||\n\t\t\t\t    mfepriv->thread) {\n\t\t\t\t\tmutex_unlock(&adapter->mfe_lock);\n\t\t\t\t\treturn -EBUSY;\n\t\t\t\t}\n\t\t\t\tadapter->mfe_dvbdev = dvbdev;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dvbdev->users == -1 && fe->ops.ts_bus_ctrl) {\n\t\tif ((ret = fe->ops.ts_bus_ctrl(fe, 1)) < 0)\n\t\t\tgoto err0;\n\n\t\t \n\t\tfepriv->reinitialise = 1;\n\t}\n\n\tif ((ret = dvb_generic_open(inode, file)) < 0)\n\t\tgoto err1;\n\n\tif ((file->f_flags & O_ACCMODE) != O_RDONLY) {\n\t\t \n\t\tfepriv->tune_mode_flags &= ~FE_TUNE_MODE_ONESHOT;\n\t\tfepriv->tone = -1;\n\t\tfepriv->voltage = -1;\n\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\t\tmutex_lock(&fe->dvb->mdev_lock);\n\t\tif (fe->dvb->mdev) {\n\t\t\tmutex_lock(&fe->dvb->mdev->graph_mutex);\n\t\t\tif (fe->dvb->mdev->enable_source)\n\t\t\t\tret = fe->dvb->mdev->enable_source(\n\t\t\t\t\t\t\t   dvbdev->entity,\n\t\t\t\t\t\t\t   &fepriv->pipe);\n\t\t\tmutex_unlock(&fe->dvb->mdev->graph_mutex);\n\t\t\tif (ret) {\n\t\t\t\tmutex_unlock(&fe->dvb->mdev_lock);\n\t\t\t\tdev_err(fe->dvb->device,\n\t\t\t\t\t\"Tuner is busy. Error %d\\n\", ret);\n\t\t\t\tgoto err2;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&fe->dvb->mdev_lock);\n#endif\n\t\tret = dvb_frontend_start(fe);\n\t\tif (ret)\n\t\t\tgoto err3;\n\n\t\t \n\t\tfepriv->events.eventr = fepriv->events.eventw = 0;\n\t}\n\n\tdvb_frontend_get(fe);\n\n\tif (adapter->mfe_shared)\n\t\tmutex_unlock(&adapter->mfe_lock);\n\treturn ret;\n\nerr3:\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tmutex_lock(&fe->dvb->mdev_lock);\n\tif (fe->dvb->mdev) {\n\t\tmutex_lock(&fe->dvb->mdev->graph_mutex);\n\t\tif (fe->dvb->mdev->disable_source)\n\t\t\tfe->dvb->mdev->disable_source(dvbdev->entity);\n\t\tmutex_unlock(&fe->dvb->mdev->graph_mutex);\n\t}\n\tmutex_unlock(&fe->dvb->mdev_lock);\nerr2:\n#endif\n\tdvb_generic_release(inode, file);\nerr1:\n\tif (dvbdev->users == -1 && fe->ops.ts_bus_ctrl)\n\t\tfe->ops.ts_bus_ctrl(fe, 0);\nerr0:\n\tif (adapter->mfe_shared)\n\t\tmutex_unlock(&adapter->mfe_lock);\n\treturn ret;\n}\n\nstatic int dvb_frontend_release(struct inode *inode, struct file *file)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dvb_frontend *fe = dvbdev->priv;\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tint ret;\n\n\tdev_dbg(fe->dvb->device, \"%s:\\n\", __func__);\n\n\tif ((file->f_flags & O_ACCMODE) != O_RDONLY) {\n\t\tfepriv->release_jiffies = jiffies;\n\t\tmb();\n\t}\n\n\tret = dvb_generic_release(inode, file);\n\n\tif (dvbdev->users == -1) {\n\t\twake_up(&fepriv->wait_queue);\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\t\tmutex_lock(&fe->dvb->mdev_lock);\n\t\tif (fe->dvb->mdev) {\n\t\t\tmutex_lock(&fe->dvb->mdev->graph_mutex);\n\t\t\tif (fe->dvb->mdev->disable_source)\n\t\t\t\tfe->dvb->mdev->disable_source(dvbdev->entity);\n\t\t\tmutex_unlock(&fe->dvb->mdev->graph_mutex);\n\t\t}\n\t\tmutex_unlock(&fe->dvb->mdev_lock);\n#endif\n\t\tif (fe->exit != DVB_FE_NO_EXIT)\n\t\t\twake_up(&dvbdev->wait_queue);\n\t\tif (fe->ops.ts_bus_ctrl)\n\t\t\tfe->ops.ts_bus_ctrl(fe, 0);\n\t}\n\n\tdvb_frontend_put(fe);\n\n\treturn ret;\n}\n\nstatic const struct file_operations dvb_frontend_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= dvb_frontend_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= dvb_frontend_compat_ioctl,\n#endif\n\t.poll\t\t= dvb_frontend_poll,\n\t.open\t\t= dvb_frontend_open,\n\t.release\t= dvb_frontend_release,\n\t.llseek\t\t= noop_llseek,\n};\n\nint dvb_frontend_suspend(struct dvb_frontend *fe)\n{\n\tint ret = 0;\n\n\tdev_dbg(fe->dvb->device, \"%s: adap=%d fe=%d\\n\", __func__, fe->dvb->num,\n\t\tfe->id);\n\n\tif (fe->ops.tuner_ops.suspend)\n\t\tret = fe->ops.tuner_ops.suspend(fe);\n\telse if (fe->ops.tuner_ops.sleep)\n\t\tret = fe->ops.tuner_ops.sleep(fe);\n\n\tif (fe->ops.suspend)\n\t\tret = fe->ops.suspend(fe);\n\telse if (fe->ops.sleep)\n\t\tret = fe->ops.sleep(fe);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dvb_frontend_suspend);\n\nint dvb_frontend_resume(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tint ret = 0;\n\n\tdev_dbg(fe->dvb->device, \"%s: adap=%d fe=%d\\n\", __func__, fe->dvb->num,\n\t\tfe->id);\n\n\tfe->exit = DVB_FE_DEVICE_RESUME;\n\tif (fe->ops.resume)\n\t\tret = fe->ops.resume(fe);\n\telse if (fe->ops.init)\n\t\tret = fe->ops.init(fe);\n\n\tif (fe->ops.tuner_ops.resume)\n\t\tret = fe->ops.tuner_ops.resume(fe);\n\telse if (fe->ops.tuner_ops.init)\n\t\tret = fe->ops.tuner_ops.init(fe);\n\n\tif (fe->ops.set_tone && fepriv->tone != -1)\n\t\tfe->ops.set_tone(fe, fepriv->tone);\n\tif (fe->ops.set_voltage && fepriv->voltage != -1)\n\t\tfe->ops.set_voltage(fe, fepriv->voltage);\n\n\tfe->exit = DVB_FE_NO_EXIT;\n\tfepriv->state = FESTATE_RETUNE;\n\tdvb_frontend_wakeup(fe);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dvb_frontend_resume);\n\nint dvb_register_frontend(struct dvb_adapter *dvb,\n\t\t\t  struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv;\n\tconst struct dvb_device dvbdev_template = {\n\t\t.users = ~0,\n\t\t.writers = 1,\n\t\t.readers = (~0) - 1,\n\t\t.fops = &dvb_frontend_fops,\n#if defined(CONFIG_MEDIA_CONTROLLER_DVB)\n\t\t.name = fe->ops.info.name,\n#endif\n\t};\n\tint ret;\n\n\tdev_dbg(dvb->device, \"%s:\\n\", __func__);\n\n\tif (mutex_lock_interruptible(&frontend_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tfe->frontend_priv = kzalloc(sizeof(struct dvb_frontend_private), GFP_KERNEL);\n\tif (!fe->frontend_priv) {\n\t\tmutex_unlock(&frontend_mutex);\n\t\treturn -ENOMEM;\n\t}\n\tfepriv = fe->frontend_priv;\n\n\tkref_init(&fe->refcount);\n\n\t \n\tdvb_frontend_get(fe);\n\n\tsema_init(&fepriv->sem, 1);\n\tinit_waitqueue_head(&fepriv->wait_queue);\n\tinit_waitqueue_head(&fepriv->events.wait_queue);\n\tmutex_init(&fepriv->events.mtx);\n\tfe->dvb = dvb;\n\tfepriv->inversion = INVERSION_OFF;\n\n\tdev_info(fe->dvb->device,\n\t\t \"DVB: registering adapter %i frontend %i (%s)...\\n\",\n\t\t fe->dvb->num, fe->id, fe->ops.info.name);\n\n\tret = dvb_register_device(fe->dvb, &fepriv->dvbdev, &dvbdev_template,\n\t\t\t    fe, DVB_DEVICE_FRONTEND, 0);\n\tif (ret) {\n\t\tdvb_frontend_put(fe);\n\t\tmutex_unlock(&frontend_mutex);\n\t\treturn ret;\n\t}\n\n\t \n\n\tfe->dtv_property_cache.delivery_system = fe->ops.delsys[0];\n\tdvb_frontend_clear_cache(fe);\n\n\tmutex_unlock(&frontend_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(dvb_register_frontend);\n\nint dvb_unregister_frontend(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\n\tdev_dbg(fe->dvb->device, \"%s:\\n\", __func__);\n\n\tmutex_lock(&frontend_mutex);\n\tdvb_frontend_stop(fe);\n\tdvb_remove_device(fepriv->dvbdev);\n\n\t \n\tmutex_unlock(&frontend_mutex);\n\tdvb_frontend_put(fe);\n\treturn 0;\n}\nEXPORT_SYMBOL(dvb_unregister_frontend);\n\nstatic void dvb_frontend_invoke_release(struct dvb_frontend *fe,\n\t\t\t\t\tvoid (*release)(struct dvb_frontend *fe))\n{\n\tif (release) {\n\t\trelease(fe);\n#ifdef CONFIG_MEDIA_ATTACH\n\t\tdvb_detach(release);\n#endif\n\t}\n}\n\nvoid dvb_frontend_detach(struct dvb_frontend *fe)\n{\n\tdvb_frontend_invoke_release(fe, fe->ops.release_sec);\n\tdvb_frontend_invoke_release(fe, fe->ops.tuner_ops.release);\n\tdvb_frontend_invoke_release(fe, fe->ops.analog_ops.release);\n\tdvb_frontend_put(fe);\n}\nEXPORT_SYMBOL(dvb_frontend_detach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}