{
  "module_name": "mc-devnode.c",
  "hash_id": "cb2e702bb6b69eed82de3939f0473caae215dd9b7b7443399754eae54301491c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/mc/mc-devnode.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n\n#include <media/media-devnode.h>\n#include <media/media-device.h>\n\n#define MEDIA_NUM_DEVICES\t256\n#define MEDIA_NAME\t\t\"media\"\n\nstatic dev_t media_dev_t;\n\n \nstatic DEFINE_MUTEX(media_devnode_lock);\nstatic DECLARE_BITMAP(media_devnode_nums, MEDIA_NUM_DEVICES);\n\n \nstatic void media_devnode_release(struct device *cd)\n{\n\tstruct media_devnode *devnode = to_media_devnode(cd);\n\n\tmutex_lock(&media_devnode_lock);\n\t \n\tclear_bit(devnode->minor, media_devnode_nums);\n\tmutex_unlock(&media_devnode_lock);\n\n\t \n\tif (devnode->release)\n\t\tdevnode->release(devnode);\n\n\tkfree(devnode);\n\tpr_debug(\"%s: Media Devnode Deallocated\\n\", __func__);\n}\n\nstatic struct bus_type media_bus_type = {\n\t.name = MEDIA_NAME,\n};\n\nstatic ssize_t media_read(struct file *filp, char __user *buf,\n\t\tsize_t sz, loff_t *off)\n{\n\tstruct media_devnode *devnode = media_devnode_data(filp);\n\n\tif (!devnode->fops->read)\n\t\treturn -EINVAL;\n\tif (!media_devnode_is_registered(devnode))\n\t\treturn -EIO;\n\treturn devnode->fops->read(filp, buf, sz, off);\n}\n\nstatic ssize_t media_write(struct file *filp, const char __user *buf,\n\t\tsize_t sz, loff_t *off)\n{\n\tstruct media_devnode *devnode = media_devnode_data(filp);\n\n\tif (!devnode->fops->write)\n\t\treturn -EINVAL;\n\tif (!media_devnode_is_registered(devnode))\n\t\treturn -EIO;\n\treturn devnode->fops->write(filp, buf, sz, off);\n}\n\nstatic __poll_t media_poll(struct file *filp,\n\t\t\t       struct poll_table_struct *poll)\n{\n\tstruct media_devnode *devnode = media_devnode_data(filp);\n\n\tif (!media_devnode_is_registered(devnode))\n\t\treturn EPOLLERR | EPOLLHUP;\n\tif (!devnode->fops->poll)\n\t\treturn DEFAULT_POLLMASK;\n\treturn devnode->fops->poll(filp, poll);\n}\n\nstatic long\n__media_ioctl(struct file *filp, unsigned int cmd, unsigned long arg,\n\t      long (*ioctl_func)(struct file *filp, unsigned int cmd,\n\t\t\t\t unsigned long arg))\n{\n\tstruct media_devnode *devnode = media_devnode_data(filp);\n\n\tif (!ioctl_func)\n\t\treturn -ENOTTY;\n\n\tif (!media_devnode_is_registered(devnode))\n\t\treturn -EIO;\n\n\treturn ioctl_func(filp, cmd, arg);\n}\n\nstatic long media_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct media_devnode *devnode = media_devnode_data(filp);\n\n\treturn __media_ioctl(filp, cmd, arg, devnode->fops->ioctl);\n}\n\n#ifdef CONFIG_COMPAT\n\nstatic long media_compat_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tstruct media_devnode *devnode = media_devnode_data(filp);\n\n\treturn __media_ioctl(filp, cmd, arg, devnode->fops->compat_ioctl);\n}\n\n#endif  \n\n \nstatic int media_open(struct inode *inode, struct file *filp)\n{\n\tstruct media_devnode *devnode;\n\tint ret;\n\n\t \n\tmutex_lock(&media_devnode_lock);\n\tdevnode = container_of(inode->i_cdev, struct media_devnode, cdev);\n\t \n\tif (!media_devnode_is_registered(devnode)) {\n\t\tmutex_unlock(&media_devnode_lock);\n\t\treturn -ENXIO;\n\t}\n\t \n\tget_device(&devnode->dev);\n\tmutex_unlock(&media_devnode_lock);\n\n\tfilp->private_data = devnode;\n\n\tif (devnode->fops->open) {\n\t\tret = devnode->fops->open(filp);\n\t\tif (ret) {\n\t\t\tput_device(&devnode->dev);\n\t\t\tfilp->private_data = NULL;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int media_release(struct inode *inode, struct file *filp)\n{\n\tstruct media_devnode *devnode = media_devnode_data(filp);\n\n\tif (devnode->fops->release)\n\t\tdevnode->fops->release(filp);\n\n\tfilp->private_data = NULL;\n\n\t \n\tput_device(&devnode->dev);\n\n\tpr_debug(\"%s: Media Release\\n\", __func__);\n\treturn 0;\n}\n\nstatic const struct file_operations media_devnode_fops = {\n\t.owner = THIS_MODULE,\n\t.read = media_read,\n\t.write = media_write,\n\t.open = media_open,\n\t.unlocked_ioctl = media_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = media_compat_ioctl,\n#endif  \n\t.release = media_release,\n\t.poll = media_poll,\n\t.llseek = no_llseek,\n};\n\nint __must_check media_devnode_register(struct media_device *mdev,\n\t\t\t\t\tstruct media_devnode *devnode,\n\t\t\t\t\tstruct module *owner)\n{\n\tint minor;\n\tint ret;\n\n\t \n\tmutex_lock(&media_devnode_lock);\n\tminor = find_first_zero_bit(media_devnode_nums, MEDIA_NUM_DEVICES);\n\tif (minor == MEDIA_NUM_DEVICES) {\n\t\tmutex_unlock(&media_devnode_lock);\n\t\tpr_err(\"could not get a free minor\\n\");\n\t\tkfree(devnode);\n\t\treturn -ENFILE;\n\t}\n\n\tset_bit(minor, media_devnode_nums);\n\tmutex_unlock(&media_devnode_lock);\n\n\tdevnode->minor = minor;\n\tdevnode->media_dev = mdev;\n\n\t \n\tdevnode->dev.bus = &media_bus_type;\n\tdevnode->dev.devt = MKDEV(MAJOR(media_dev_t), devnode->minor);\n\tdevnode->dev.release = media_devnode_release;\n\tif (devnode->parent)\n\t\tdevnode->dev.parent = devnode->parent;\n\tdev_set_name(&devnode->dev, \"media%d\", devnode->minor);\n\tdevice_initialize(&devnode->dev);\n\n\t \n\tcdev_init(&devnode->cdev, &media_devnode_fops);\n\tdevnode->cdev.owner = owner;\n\tkobject_set_name(&devnode->cdev.kobj, \"media%d\", devnode->minor);\n\n\t \n\tret = cdev_device_add(&devnode->cdev, &devnode->dev);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: cdev_device_add failed\\n\", __func__);\n\t\tgoto cdev_add_error;\n\t}\n\n\t \n\tset_bit(MEDIA_FLAG_REGISTERED, &devnode->flags);\n\n\treturn 0;\n\ncdev_add_error:\n\tmutex_lock(&media_devnode_lock);\n\tclear_bit(devnode->minor, media_devnode_nums);\n\tdevnode->media_dev = NULL;\n\tmutex_unlock(&media_devnode_lock);\n\n\tput_device(&devnode->dev);\n\treturn ret;\n}\n\nvoid media_devnode_unregister_prepare(struct media_devnode *devnode)\n{\n\t \n\tif (!media_devnode_is_registered(devnode))\n\t\treturn;\n\n\tmutex_lock(&media_devnode_lock);\n\tclear_bit(MEDIA_FLAG_REGISTERED, &devnode->flags);\n\tmutex_unlock(&media_devnode_lock);\n}\n\nvoid media_devnode_unregister(struct media_devnode *devnode)\n{\n\tmutex_lock(&media_devnode_lock);\n\t \n\tcdev_device_del(&devnode->cdev, &devnode->dev);\n\tdevnode->media_dev = NULL;\n\tmutex_unlock(&media_devnode_lock);\n\n\tput_device(&devnode->dev);\n}\n\n \nstatic int __init media_devnode_init(void)\n{\n\tint ret;\n\n\tpr_info(\"Linux media interface: v0.10\\n\");\n\tret = alloc_chrdev_region(&media_dev_t, 0, MEDIA_NUM_DEVICES,\n\t\t\t\t  MEDIA_NAME);\n\tif (ret < 0) {\n\t\tpr_warn(\"unable to allocate major\\n\");\n\t\treturn ret;\n\t}\n\n\tret = bus_register(&media_bus_type);\n\tif (ret < 0) {\n\t\tunregister_chrdev_region(media_dev_t, MEDIA_NUM_DEVICES);\n\t\tpr_warn(\"bus_register failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit media_devnode_exit(void)\n{\n\tbus_unregister(&media_bus_type);\n\tunregister_chrdev_region(media_dev_t, MEDIA_NUM_DEVICES);\n}\n\nsubsys_initcall(media_devnode_init);\nmodule_exit(media_devnode_exit)\n\nMODULE_AUTHOR(\"Laurent Pinchart <laurent.pinchart@ideasonboard.com>\");\nMODULE_DESCRIPTION(\"Device node registration for media drivers\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}