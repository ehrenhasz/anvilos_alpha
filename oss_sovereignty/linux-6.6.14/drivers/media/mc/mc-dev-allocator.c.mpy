{
  "module_name": "mc-dev-allocator.c",
  "hash_id": "a33b4d89fe0bb35926fa4a7599d412cea004f4a3e5907cee3dc957e7f2e1f8d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/mc/mc-dev-allocator.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kref.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n#include <media/media-device.h>\n#include <media/media-dev-allocator.h>\n\nstatic LIST_HEAD(media_device_list);\nstatic DEFINE_MUTEX(media_device_lock);\n\nstruct media_device_instance {\n\tstruct media_device mdev;\n\tstruct module *owner;\n\tstruct list_head list;\n\tstruct kref refcount;\n};\n\nstatic inline struct media_device_instance *\nto_media_device_instance(struct media_device *mdev)\n{\n\treturn container_of(mdev, struct media_device_instance, mdev);\n}\n\nstatic void media_device_instance_release(struct kref *kref)\n{\n\tstruct media_device_instance *mdi =\n\t\tcontainer_of(kref, struct media_device_instance, refcount);\n\n\tdev_dbg(mdi->mdev.dev, \"%s: releasing Media Device\\n\", __func__);\n\n\tmutex_lock(&media_device_lock);\n\n\tmedia_device_unregister(&mdi->mdev);\n\tmedia_device_cleanup(&mdi->mdev);\n\n\tlist_del(&mdi->list);\n\tmutex_unlock(&media_device_lock);\n\n\tkfree(mdi);\n}\n\n \nstatic struct media_device *__media_device_get(struct device *dev,\n\t\t\t\t\t\tconst char *module_name,\n\t\t\t\t\t\tstruct module *owner)\n{\n\tstruct media_device_instance *mdi;\n\n\tlist_for_each_entry(mdi, &media_device_list, list) {\n\t\tif (mdi->mdev.dev != dev)\n\t\t\tcontinue;\n\n\t\tkref_get(&mdi->refcount);\n\n\t\t \n\t\tif (owner != mdi->owner && !try_module_get(mdi->owner))\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s: module %s get owner reference error\\n\",\n\t\t\t\t\t__func__, module_name);\n\t\telse\n\t\t\tdev_dbg(dev, \"%s: module %s got owner reference\\n\",\n\t\t\t\t\t__func__, module_name);\n\t\treturn &mdi->mdev;\n\t}\n\n\tmdi = kzalloc(sizeof(*mdi), GFP_KERNEL);\n\tif (!mdi)\n\t\treturn NULL;\n\n\tmdi->owner = owner;\n\tkref_init(&mdi->refcount);\n\tlist_add_tail(&mdi->list, &media_device_list);\n\n\tdev_dbg(dev, \"%s: Allocated media device for owner %s\\n\",\n\t\t\t__func__, module_name);\n\treturn &mdi->mdev;\n}\n\nstruct media_device *media_device_usb_allocate(struct usb_device *udev,\n\t\t\t\t\t       const char *module_name,\n\t\t\t\t\t       struct module *owner)\n{\n\tstruct media_device *mdev;\n\n\tmutex_lock(&media_device_lock);\n\tmdev = __media_device_get(&udev->dev, module_name, owner);\n\tif (!mdev) {\n\t\tmutex_unlock(&media_device_lock);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t \n\tif (!mdev->dev)\n\t\t__media_device_usb_init(mdev, udev, udev->product,\n\t\t\t\t\tmodule_name);\n\tmutex_unlock(&media_device_lock);\n\treturn mdev;\n}\nEXPORT_SYMBOL_GPL(media_device_usb_allocate);\n\nvoid media_device_delete(struct media_device *mdev, const char *module_name,\n\t\t\t struct module *owner)\n{\n\tstruct media_device_instance *mdi = to_media_device_instance(mdev);\n\n\tmutex_lock(&media_device_lock);\n\t \n\tif (mdi->owner != owner) {\n\t\tmodule_put(mdi->owner);\n\t\tdev_dbg(mdi->mdev.dev,\n\t\t\t\"%s: module %s put owner module reference\\n\",\n\t\t\t__func__, module_name);\n\t}\n\tmutex_unlock(&media_device_lock);\n\tkref_put(&mdi->refcount, media_device_instance_release);\n}\nEXPORT_SYMBOL_GPL(media_device_delete);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}