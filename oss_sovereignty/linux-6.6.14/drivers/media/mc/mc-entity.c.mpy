{
  "module_name": "mc-entity.c",
  "hash_id": "ded42ad9cf2c7a8a3c8b809769fb2c661b1a0f3cc51c237d27a40fbd15f8068e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/mc/mc-entity.c",
  "human_readable_source": "\n \n\n#include <linux/bitmap.h>\n#include <linux/list.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <media/media-entity.h>\n#include <media/media-device.h>\n\nstatic inline const char *intf_type(struct media_interface *intf)\n{\n\tswitch (intf->type) {\n\tcase MEDIA_INTF_T_DVB_FE:\n\t\treturn \"dvb-frontend\";\n\tcase MEDIA_INTF_T_DVB_DEMUX:\n\t\treturn \"dvb-demux\";\n\tcase MEDIA_INTF_T_DVB_DVR:\n\t\treturn \"dvb-dvr\";\n\tcase MEDIA_INTF_T_DVB_CA:\n\t\treturn  \"dvb-ca\";\n\tcase MEDIA_INTF_T_DVB_NET:\n\t\treturn \"dvb-net\";\n\tcase MEDIA_INTF_T_V4L_VIDEO:\n\t\treturn \"v4l-video\";\n\tcase MEDIA_INTF_T_V4L_VBI:\n\t\treturn \"v4l-vbi\";\n\tcase MEDIA_INTF_T_V4L_RADIO:\n\t\treturn \"v4l-radio\";\n\tcase MEDIA_INTF_T_V4L_SUBDEV:\n\t\treturn \"v4l-subdev\";\n\tcase MEDIA_INTF_T_V4L_SWRADIO:\n\t\treturn \"v4l-swradio\";\n\tcase MEDIA_INTF_T_V4L_TOUCH:\n\t\treturn \"v4l-touch\";\n\tdefault:\n\t\treturn \"unknown-intf\";\n\t}\n};\n\nstatic inline const char *link_type_name(struct media_link *link)\n{\n\tswitch (link->flags & MEDIA_LNK_FL_LINK_TYPE) {\n\tcase MEDIA_LNK_FL_DATA_LINK:\n\t\treturn \"data\";\n\tcase MEDIA_LNK_FL_INTERFACE_LINK:\n\t\treturn \"interface\";\n\tcase MEDIA_LNK_FL_ANCILLARY_LINK:\n\t\treturn \"ancillary\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\n__must_check int media_entity_enum_init(struct media_entity_enum *ent_enum,\n\t\t\t\t\tstruct media_device *mdev)\n{\n\tint idx_max;\n\n\tidx_max = ALIGN(mdev->entity_internal_idx_max + 1, BITS_PER_LONG);\n\tent_enum->bmap = bitmap_zalloc(idx_max, GFP_KERNEL);\n\tif (!ent_enum->bmap)\n\t\treturn -ENOMEM;\n\n\tent_enum->idx_max = idx_max;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(media_entity_enum_init);\n\nvoid media_entity_enum_cleanup(struct media_entity_enum *ent_enum)\n{\n\tbitmap_free(ent_enum->bmap);\n}\nEXPORT_SYMBOL_GPL(media_entity_enum_cleanup);\n\n \nstatic void dev_dbg_obj(const char *event_name,  struct media_gobj *gobj)\n{\n#if defined(DEBUG) || defined (CONFIG_DYNAMIC_DEBUG)\n\tswitch (media_type(gobj)) {\n\tcase MEDIA_GRAPH_ENTITY:\n\t\tdev_dbg(gobj->mdev->dev,\n\t\t\t\"%s id %u: entity '%s'\\n\",\n\t\t\tevent_name, media_id(gobj),\n\t\t\tgobj_to_entity(gobj)->name);\n\t\tbreak;\n\tcase MEDIA_GRAPH_LINK:\n\t{\n\t\tstruct media_link *link = gobj_to_link(gobj);\n\n\t\tdev_dbg(gobj->mdev->dev,\n\t\t\t\"%s id %u: %s link id %u ==> id %u\\n\",\n\t\t\tevent_name, media_id(gobj), link_type_name(link),\n\t\t\tmedia_id(link->gobj0),\n\t\t\tmedia_id(link->gobj1));\n\t\tbreak;\n\t}\n\tcase MEDIA_GRAPH_PAD:\n\t{\n\t\tstruct media_pad *pad = gobj_to_pad(gobj);\n\n\t\tdev_dbg(gobj->mdev->dev,\n\t\t\t\"%s id %u: %s%spad '%s':%d\\n\",\n\t\t\tevent_name, media_id(gobj),\n\t\t\tpad->flags & MEDIA_PAD_FL_SINK   ? \"sink \" : \"\",\n\t\t\tpad->flags & MEDIA_PAD_FL_SOURCE ? \"source \" : \"\",\n\t\t\tpad->entity->name, pad->index);\n\t\tbreak;\n\t}\n\tcase MEDIA_GRAPH_INTF_DEVNODE:\n\t{\n\t\tstruct media_interface *intf = gobj_to_intf(gobj);\n\t\tstruct media_intf_devnode *devnode = intf_to_devnode(intf);\n\n\t\tdev_dbg(gobj->mdev->dev,\n\t\t\t\"%s id %u: intf_devnode %s - major: %d, minor: %d\\n\",\n\t\t\tevent_name, media_id(gobj),\n\t\t\tintf_type(intf),\n\t\t\tdevnode->major, devnode->minor);\n\t\tbreak;\n\t}\n\t}\n#endif\n}\n\nvoid media_gobj_create(struct media_device *mdev,\n\t\t\t   enum media_gobj_type type,\n\t\t\t   struct media_gobj *gobj)\n{\n\tBUG_ON(!mdev);\n\n\tgobj->mdev = mdev;\n\n\t \n\tgobj->id = media_gobj_gen_id(type, ++mdev->id);\n\n\tswitch (type) {\n\tcase MEDIA_GRAPH_ENTITY:\n\t\tlist_add_tail(&gobj->list, &mdev->entities);\n\t\tbreak;\n\tcase MEDIA_GRAPH_PAD:\n\t\tlist_add_tail(&gobj->list, &mdev->pads);\n\t\tbreak;\n\tcase MEDIA_GRAPH_LINK:\n\t\tlist_add_tail(&gobj->list, &mdev->links);\n\t\tbreak;\n\tcase MEDIA_GRAPH_INTF_DEVNODE:\n\t\tlist_add_tail(&gobj->list, &mdev->interfaces);\n\t\tbreak;\n\t}\n\n\tmdev->topology_version++;\n\n\tdev_dbg_obj(__func__, gobj);\n}\n\nvoid media_gobj_destroy(struct media_gobj *gobj)\n{\n\t \n\tif (gobj->mdev == NULL)\n\t\treturn;\n\n\tdev_dbg_obj(__func__, gobj);\n\n\tgobj->mdev->topology_version++;\n\n\t \n\tlist_del(&gobj->list);\n\n\tgobj->mdev = NULL;\n}\n\n \n#define MEDIA_ENTITY_MAX_PADS\t\t512\n\nint media_entity_pads_init(struct media_entity *entity, u16 num_pads,\n\t\t\t   struct media_pad *pads)\n{\n\tstruct media_device *mdev = entity->graph_obj.mdev;\n\tstruct media_pad *iter;\n\tunsigned int i = 0;\n\n\tif (num_pads >= MEDIA_ENTITY_MAX_PADS)\n\t\treturn -E2BIG;\n\n\tentity->num_pads = num_pads;\n\tentity->pads = pads;\n\n\tif (mdev)\n\t\tmutex_lock(&mdev->graph_mutex);\n\n\tmedia_entity_for_each_pad(entity, iter) {\n\t\titer->entity = entity;\n\t\titer->index = i++;\n\t\tif (mdev)\n\t\t\tmedia_gobj_create(mdev, MEDIA_GRAPH_PAD,\n\t\t\t\t\t  &iter->graph_obj);\n\t}\n\n\tif (mdev)\n\t\tmutex_unlock(&mdev->graph_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(media_entity_pads_init);\n\n \n\n \nstatic bool media_entity_has_pad_interdep(struct media_entity *entity,\n\t\t\t\t\t  unsigned int pad0, unsigned int pad1)\n{\n\tif (pad0 >= entity->num_pads || pad1 >= entity->num_pads)\n\t\treturn false;\n\n\tif (entity->pads[pad0].flags & entity->pads[pad1].flags &\n\t    (MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_SOURCE))\n\t\treturn false;\n\n\tif (!entity->ops || !entity->ops->has_pad_interdep)\n\t\treturn true;\n\n\treturn entity->ops->has_pad_interdep(entity, pad0, pad1);\n}\n\nstatic struct media_entity *\nmedia_entity_other(struct media_entity *entity, struct media_link *link)\n{\n\tif (link->source->entity == entity)\n\t\treturn link->sink->entity;\n\telse\n\t\treturn link->source->entity;\n}\n\n \nstatic void stack_push(struct media_graph *graph,\n\t\t       struct media_entity *entity)\n{\n\tif (graph->top == MEDIA_ENTITY_ENUM_MAX_DEPTH - 1) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tgraph->top++;\n\tgraph->stack[graph->top].link = entity->links.next;\n\tgraph->stack[graph->top].entity = entity;\n}\n\nstatic struct media_entity *stack_pop(struct media_graph *graph)\n{\n\tstruct media_entity *entity;\n\n\tentity = graph->stack[graph->top].entity;\n\tgraph->top--;\n\n\treturn entity;\n}\n\n#define link_top(en)\t((en)->stack[(en)->top].link)\n#define stack_top(en)\t((en)->stack[(en)->top].entity)\n\n \n__must_check int media_graph_walk_init(\n\tstruct media_graph *graph, struct media_device *mdev)\n{\n\treturn media_entity_enum_init(&graph->ent_enum, mdev);\n}\nEXPORT_SYMBOL_GPL(media_graph_walk_init);\n\n \nvoid media_graph_walk_cleanup(struct media_graph *graph)\n{\n\tmedia_entity_enum_cleanup(&graph->ent_enum);\n}\nEXPORT_SYMBOL_GPL(media_graph_walk_cleanup);\n\nvoid media_graph_walk_start(struct media_graph *graph,\n\t\t\t    struct media_entity *entity)\n{\n\tmedia_entity_enum_zero(&graph->ent_enum);\n\tmedia_entity_enum_set(&graph->ent_enum, entity);\n\n\tgraph->top = 0;\n\tgraph->stack[graph->top].entity = NULL;\n\tstack_push(graph, entity);\n\tdev_dbg(entity->graph_obj.mdev->dev,\n\t\t\"begin graph walk at '%s'\\n\", entity->name);\n}\nEXPORT_SYMBOL_GPL(media_graph_walk_start);\n\nstatic void media_graph_walk_iter(struct media_graph *graph)\n{\n\tstruct media_entity *entity = stack_top(graph);\n\tstruct media_link *link;\n\tstruct media_entity *next;\n\n\tlink = list_entry(link_top(graph), typeof(*link), list);\n\n\t \n\tif ((link->flags & MEDIA_LNK_FL_LINK_TYPE) != MEDIA_LNK_FL_DATA_LINK) {\n\t\tlink_top(graph) = link_top(graph)->next;\n\t\treturn;\n\t}\n\n\t \n\tif (!(link->flags & MEDIA_LNK_FL_ENABLED)) {\n\t\tlink_top(graph) = link_top(graph)->next;\n\t\tdev_dbg(entity->graph_obj.mdev->dev,\n\t\t\t\"walk: skipping disabled link '%s':%u -> '%s':%u\\n\",\n\t\t\tlink->source->entity->name, link->source->index,\n\t\t\tlink->sink->entity->name, link->sink->index);\n\t\treturn;\n\t}\n\n\t \n\tnext = media_entity_other(entity, link);\n\n\t \n\tif (media_entity_enum_test_and_set(&graph->ent_enum, next)) {\n\t\tlink_top(graph) = link_top(graph)->next;\n\t\tdev_dbg(entity->graph_obj.mdev->dev,\n\t\t\t\"walk: skipping entity '%s' (already seen)\\n\",\n\t\t\tnext->name);\n\t\treturn;\n\t}\n\n\t \n\tlink_top(graph) = link_top(graph)->next;\n\tstack_push(graph, next);\n\tdev_dbg(entity->graph_obj.mdev->dev, \"walk: pushing '%s' on stack\\n\",\n\t\tnext->name);\n\tlockdep_assert_held(&entity->graph_obj.mdev->graph_mutex);\n}\n\nstruct media_entity *media_graph_walk_next(struct media_graph *graph)\n{\n\tstruct media_entity *entity;\n\n\tif (stack_top(graph) == NULL)\n\t\treturn NULL;\n\n\t \n\twhile (link_top(graph) != &stack_top(graph)->links)\n\t\tmedia_graph_walk_iter(graph);\n\n\tentity = stack_pop(graph);\n\tdev_dbg(entity->graph_obj.mdev->dev,\n\t\t\"walk: returning entity '%s'\\n\", entity->name);\n\n\treturn entity;\n}\nEXPORT_SYMBOL_GPL(media_graph_walk_next);\n\n \n\n \n\n \nstruct media_pipeline_walk_entry {\n\tstruct media_pad *pad;\n\tstruct list_head *links;\n};\n\n \nstruct media_pipeline_walk {\n\tstruct media_device *mdev;\n\n\tstruct {\n\t\tunsigned int size;\n\t\tint top;\n\t\tstruct media_pipeline_walk_entry *entries;\n\t} stack;\n};\n\n#define MEDIA_PIPELINE_STACK_GROW_STEP\t\t16\n\nstatic struct media_pipeline_walk_entry *\nmedia_pipeline_walk_top(struct media_pipeline_walk *walk)\n{\n\treturn &walk->stack.entries[walk->stack.top];\n}\n\nstatic bool media_pipeline_walk_empty(struct media_pipeline_walk *walk)\n{\n\treturn walk->stack.top == -1;\n}\n\n \nstatic int media_pipeline_walk_resize(struct media_pipeline_walk *walk)\n{\n\tstruct media_pipeline_walk_entry *entries;\n\tunsigned int new_size;\n\n\t \n\tif (walk->stack.size >= 256)\n\t\treturn -E2BIG;\n\n\tnew_size = walk->stack.size + MEDIA_PIPELINE_STACK_GROW_STEP;\n\n\tentries = krealloc(walk->stack.entries,\n\t\t\t   new_size * sizeof(*walk->stack.entries),\n\t\t\t   GFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\twalk->stack.entries = entries;\n\twalk->stack.size = new_size;\n\n\treturn 0;\n}\n\n \nstatic int media_pipeline_walk_push(struct media_pipeline_walk *walk,\n\t\t\t\t    struct media_pad *pad)\n{\n\tstruct media_pipeline_walk_entry *entry;\n\tint ret;\n\n\tif (walk->stack.top + 1 >= walk->stack.size) {\n\t\tret = media_pipeline_walk_resize(walk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\twalk->stack.top++;\n\tentry = media_pipeline_walk_top(walk);\n\tentry->pad = pad;\n\tentry->links = pad->entity->links.next;\n\n\tdev_dbg(walk->mdev->dev,\n\t\t\"media pipeline: pushed entry %u: '%s':%u\\n\",\n\t\twalk->stack.top, pad->entity->name, pad->index);\n\n\treturn 0;\n}\n\n \nstatic void media_pipeline_walk_pop(struct media_pipeline_walk *walk)\n{\n\tstruct media_pipeline_walk_entry *entry;\n\n\tif (WARN_ON(walk->stack.top < 0))\n\t\treturn;\n\n\tentry = media_pipeline_walk_top(walk);\n\n\tif (entry->links->next == &entry->pad->entity->links) {\n\t\tdev_dbg(walk->mdev->dev,\n\t\t\t\"media pipeline: entry %u has no more links, popping\\n\",\n\t\t\twalk->stack.top);\n\n\t\twalk->stack.top--;\n\t\treturn;\n\t}\n\n\tentry->links = entry->links->next;\n\n\tdev_dbg(walk->mdev->dev,\n\t\t\"media pipeline: moved entry %u to next link\\n\",\n\t\twalk->stack.top);\n}\n\n \nstatic void media_pipeline_walk_destroy(struct media_pipeline_walk *walk)\n{\n\tkfree(walk->stack.entries);\n}\n\n \nstatic int media_pipeline_add_pad(struct media_pipeline *pipe,\n\t\t\t\t  struct media_pipeline_walk *walk,\n\t\t\t\t  struct media_pad *pad)\n{\n\tstruct media_pipeline_pad *ppad;\n\n\tlist_for_each_entry(ppad, &pipe->pads, list) {\n\t\tif (ppad->pad == pad) {\n\t\t\tdev_dbg(pad->graph_obj.mdev->dev,\n\t\t\t\t\"media pipeline: already contains pad '%s':%u\\n\",\n\t\t\t\tpad->entity->name, pad->index);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tppad = kzalloc(sizeof(*ppad), GFP_KERNEL);\n\tif (!ppad)\n\t\treturn -ENOMEM;\n\n\tppad->pipe = pipe;\n\tppad->pad = pad;\n\n\tlist_add_tail(&ppad->list, &pipe->pads);\n\n\tdev_dbg(pad->graph_obj.mdev->dev,\n\t\t\"media pipeline: added pad '%s':%u\\n\",\n\t\tpad->entity->name, pad->index);\n\n\treturn media_pipeline_walk_push(walk, pad);\n}\n\n \nstatic int media_pipeline_explore_next_link(struct media_pipeline *pipe,\n\t\t\t\t\t    struct media_pipeline_walk *walk)\n{\n\tstruct media_pipeline_walk_entry *entry = media_pipeline_walk_top(walk);\n\tstruct media_pad *pad;\n\tstruct media_link *link;\n\tstruct media_pad *local;\n\tstruct media_pad *remote;\n\tint ret;\n\n\tpad = entry->pad;\n\tlink = list_entry(entry->links, typeof(*link), list);\n\tmedia_pipeline_walk_pop(walk);\n\n\tdev_dbg(walk->mdev->dev,\n\t\t\"media pipeline: exploring link '%s':%u -> '%s':%u\\n\",\n\t\tlink->source->entity->name, link->source->index,\n\t\tlink->sink->entity->name, link->sink->index);\n\n\t \n\tif (!(link->flags & MEDIA_LNK_FL_ENABLED)) {\n\t\tdev_dbg(walk->mdev->dev,\n\t\t\t\"media pipeline: skipping link (disabled)\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (link->source->entity == pad->entity) {\n\t\tlocal = link->source;\n\t\tremote = link->sink;\n\t} else {\n\t\tlocal = link->sink;\n\t\tremote = link->source;\n\t}\n\n\t \n\tif (pad != local &&\n\t    !media_entity_has_pad_interdep(pad->entity, pad->index, local->index)) {\n\t\tdev_dbg(walk->mdev->dev,\n\t\t\t\"media pipeline: skipping link (no route)\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tret = media_pipeline_add_pad(pipe, walk, local);\n\tif (ret)\n\t\treturn ret;\n\n\tret = media_pipeline_add_pad(pipe, walk, remote);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void media_pipeline_cleanup(struct media_pipeline *pipe)\n{\n\twhile (!list_empty(&pipe->pads)) {\n\t\tstruct media_pipeline_pad *ppad;\n\n\t\tppad = list_first_entry(&pipe->pads, typeof(*ppad), list);\n\t\tlist_del(&ppad->list);\n\t\tkfree(ppad);\n\t}\n}\n\nstatic int media_pipeline_populate(struct media_pipeline *pipe,\n\t\t\t\t   struct media_pad *pad)\n{\n\tstruct media_pipeline_walk walk = { };\n\tstruct media_pipeline_pad *ppad;\n\tint ret;\n\n\t \n\tINIT_LIST_HEAD(&pipe->pads);\n\tpipe->mdev = pad->graph_obj.mdev;\n\n\twalk.mdev = pipe->mdev;\n\twalk.stack.top = -1;\n\tret = media_pipeline_add_pad(pipe, &walk, pad);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\twhile (!media_pipeline_walk_empty(&walk)) {\n\t\tret = media_pipeline_explore_next_link(pipe, &walk);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\n\tdev_dbg(pad->graph_obj.mdev->dev,\n\t\t\"media pipeline populated, found pads:\\n\");\n\n\tlist_for_each_entry(ppad, &pipe->pads, list)\n\t\tdev_dbg(pad->graph_obj.mdev->dev, \"- '%s':%u\\n\",\n\t\t\tppad->pad->entity->name, ppad->pad->index);\n\n\tWARN_ON(walk.stack.top != -1);\n\n\tret = 0;\n\ndone:\n\tmedia_pipeline_walk_destroy(&walk);\n\n\tif (ret)\n\t\tmedia_pipeline_cleanup(pipe);\n\n\treturn ret;\n}\n\n__must_check int __media_pipeline_start(struct media_pad *pad,\n\t\t\t\t\tstruct media_pipeline *pipe)\n{\n\tstruct media_device *mdev = pad->graph_obj.mdev;\n\tstruct media_pipeline_pad *err_ppad;\n\tstruct media_pipeline_pad *ppad;\n\tint ret;\n\n\tlockdep_assert_held(&mdev->graph_mutex);\n\n\t \n\tif (WARN_ON(pad->pipe && pad->pipe != pipe))\n\t\treturn -EINVAL;\n\n\t \n\tif (pipe->start_count) {\n\t\tpipe->start_count++;\n\t\treturn 0;\n\t}\n\n\t \n\tret = media_pipeline_populate(pipe, pad);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tlist_for_each_entry(ppad, &pipe->pads, list) {\n\t\tstruct media_pad *pad = ppad->pad;\n\t\tstruct media_entity *entity = pad->entity;\n\t\tbool has_enabled_link = false;\n\t\tbool has_link = false;\n\t\tstruct media_link *link;\n\n\t\tdev_dbg(mdev->dev, \"Validating pad '%s':%u\\n\", pad->entity->name,\n\t\t\tpad->index);\n\n\t\t \n\t\tif (pad->pipe) {\n\t\t\tdev_dbg(mdev->dev, \"Failed to start pipeline: pad '%s':%u busy\\n\",\n\t\t\t\tpad->entity->name, pad->index);\n\t\t\tret = -EBUSY;\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tfor_each_media_entity_data_link(entity, link) {\n\t\t\t \n\t\t\tif (link->sink != pad && link->source != pad)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (link->flags & MEDIA_LNK_FL_ENABLED)\n\t\t\t\thas_enabled_link = true;\n\t\t\thas_link = true;\n\n\t\t\t \n\t\t\tif (!(link->flags & MEDIA_LNK_FL_ENABLED))\n\t\t\t\tcontinue;\n\n\t\t\tif (link->sink != pad)\n\t\t\t\tcontinue;\n\n\t\t\tif (!entity->ops || !entity->ops->link_validate)\n\t\t\t\tcontinue;\n\n\t\t\tret = entity->ops->link_validate(link);\n\t\t\tif (ret) {\n\t\t\t\tdev_dbg(mdev->dev,\n\t\t\t\t\t\"Link '%s':%u -> '%s':%u failed validation: %d\\n\",\n\t\t\t\t\tlink->source->entity->name,\n\t\t\t\t\tlink->source->index,\n\t\t\t\t\tlink->sink->entity->name,\n\t\t\t\t\tlink->sink->index, ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tdev_dbg(mdev->dev,\n\t\t\t\t\"Link '%s':%u -> '%s':%u is valid\\n\",\n\t\t\t\tlink->source->entity->name,\n\t\t\t\tlink->source->index,\n\t\t\t\tlink->sink->entity->name,\n\t\t\t\tlink->sink->index);\n\t\t}\n\n\t\t \n\t\tif ((pad->flags & MEDIA_PAD_FL_MUST_CONNECT) && has_link &&\n\t\t    !has_enabled_link) {\n\t\t\tdev_dbg(mdev->dev,\n\t\t\t\t\"Pad '%s':%u must be connected by an enabled link\\n\",\n\t\t\t\tpad->entity->name, pad->index);\n\t\t\tret = -ENOLINK;\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tpad->pipe = pipe;\n\t}\n\n\tpipe->start_count++;\n\n\treturn 0;\n\nerror:\n\t \n\n\tlist_for_each_entry(err_ppad, &pipe->pads, list) {\n\t\tif (err_ppad == ppad)\n\t\t\tbreak;\n\n\t\terr_ppad->pad->pipe = NULL;\n\t}\n\n\tmedia_pipeline_cleanup(pipe);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__media_pipeline_start);\n\n__must_check int media_pipeline_start(struct media_pad *pad,\n\t\t\t\t      struct media_pipeline *pipe)\n{\n\tstruct media_device *mdev = pad->graph_obj.mdev;\n\tint ret;\n\n\tmutex_lock(&mdev->graph_mutex);\n\tret = __media_pipeline_start(pad, pipe);\n\tmutex_unlock(&mdev->graph_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(media_pipeline_start);\n\nvoid __media_pipeline_stop(struct media_pad *pad)\n{\n\tstruct media_pipeline *pipe = pad->pipe;\n\tstruct media_pipeline_pad *ppad;\n\n\t \n\tif (WARN_ON(!pipe))\n\t\treturn;\n\n\tif (--pipe->start_count)\n\t\treturn;\n\n\tlist_for_each_entry(ppad, &pipe->pads, list)\n\t\tppad->pad->pipe = NULL;\n\n\tmedia_pipeline_cleanup(pipe);\n\n\tif (pipe->allocated)\n\t\tkfree(pipe);\n}\nEXPORT_SYMBOL_GPL(__media_pipeline_stop);\n\nvoid media_pipeline_stop(struct media_pad *pad)\n{\n\tstruct media_device *mdev = pad->graph_obj.mdev;\n\n\tmutex_lock(&mdev->graph_mutex);\n\t__media_pipeline_stop(pad);\n\tmutex_unlock(&mdev->graph_mutex);\n}\nEXPORT_SYMBOL_GPL(media_pipeline_stop);\n\n__must_check int media_pipeline_alloc_start(struct media_pad *pad)\n{\n\tstruct media_device *mdev = pad->graph_obj.mdev;\n\tstruct media_pipeline *new_pipe = NULL;\n\tstruct media_pipeline *pipe;\n\tint ret;\n\n\tmutex_lock(&mdev->graph_mutex);\n\n\t \n\tpipe = media_pad_pipeline(pad);\n\tif (!pipe) {\n\t\tnew_pipe = kzalloc(sizeof(*new_pipe), GFP_KERNEL);\n\t\tif (!new_pipe) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpipe = new_pipe;\n\t\tpipe->allocated = true;\n\t}\n\n\tret = __media_pipeline_start(pad, pipe);\n\tif (ret)\n\t\tkfree(new_pipe);\n\nout:\n\tmutex_unlock(&mdev->graph_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(media_pipeline_alloc_start);\n\nstruct media_pad *\n__media_pipeline_pad_iter_next(struct media_pipeline *pipe,\n\t\t\t       struct media_pipeline_pad_iter *iter,\n\t\t\t       struct media_pad *pad)\n{\n\tif (!pad)\n\t\titer->cursor = pipe->pads.next;\n\n\tif (iter->cursor == &pipe->pads)\n\t\treturn NULL;\n\n\tpad = list_entry(iter->cursor, struct media_pipeline_pad, list)->pad;\n\titer->cursor = iter->cursor->next;\n\n\treturn pad;\n}\nEXPORT_SYMBOL_GPL(__media_pipeline_pad_iter_next);\n\nint media_pipeline_entity_iter_init(struct media_pipeline *pipe,\n\t\t\t\t    struct media_pipeline_entity_iter *iter)\n{\n\treturn media_entity_enum_init(&iter->ent_enum, pipe->mdev);\n}\nEXPORT_SYMBOL_GPL(media_pipeline_entity_iter_init);\n\nvoid media_pipeline_entity_iter_cleanup(struct media_pipeline_entity_iter *iter)\n{\n\tmedia_entity_enum_cleanup(&iter->ent_enum);\n}\nEXPORT_SYMBOL_GPL(media_pipeline_entity_iter_cleanup);\n\nstruct media_entity *\n__media_pipeline_entity_iter_next(struct media_pipeline *pipe,\n\t\t\t\t  struct media_pipeline_entity_iter *iter,\n\t\t\t\t  struct media_entity *entity)\n{\n\tif (!entity)\n\t\titer->cursor = pipe->pads.next;\n\n\twhile (iter->cursor != &pipe->pads) {\n\t\tstruct media_pipeline_pad *ppad;\n\t\tstruct media_entity *entity;\n\n\t\tppad = list_entry(iter->cursor, struct media_pipeline_pad, list);\n\t\tentity = ppad->pad->entity;\n\t\titer->cursor = iter->cursor->next;\n\n\t\tif (!media_entity_enum_test_and_set(&iter->ent_enum, entity))\n\t\t\treturn entity;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(__media_pipeline_entity_iter_next);\n\n \n\nstatic struct media_link *media_add_link(struct list_head *head)\n{\n\tstruct media_link *link;\n\n\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\tif (link == NULL)\n\t\treturn NULL;\n\n\tlist_add_tail(&link->list, head);\n\n\treturn link;\n}\n\nstatic void __media_entity_remove_link(struct media_entity *entity,\n\t\t\t\t       struct media_link *link)\n{\n\tstruct media_link *rlink, *tmp;\n\tstruct media_entity *remote;\n\n\t \n\tif ((link->flags & MEDIA_LNK_FL_LINK_TYPE) == MEDIA_LNK_FL_DATA_LINK) {\n\t\tif (link->source->entity == entity)\n\t\t\tremote = link->sink->entity;\n\t\telse\n\t\t\tremote = link->source->entity;\n\n\t\tlist_for_each_entry_safe(rlink, tmp, &remote->links, list) {\n\t\t\tif (rlink != link->reverse)\n\t\t\t\tcontinue;\n\n\t\t\tif (link->source->entity == entity)\n\t\t\t\tremote->num_backlinks--;\n\n\t\t\t \n\t\t\tlist_del(&rlink->list);\n\t\t\tmedia_gobj_destroy(&rlink->graph_obj);\n\t\t\tkfree(rlink);\n\n\t\t\tif (--remote->num_links == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_del(&link->list);\n\tmedia_gobj_destroy(&link->graph_obj);\n\tkfree(link);\n}\n\nint media_get_pad_index(struct media_entity *entity, u32 pad_type,\n\t\t\tenum media_pad_signal_type sig_type)\n{\n\tunsigned int i;\n\n\tif (!entity)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < entity->num_pads; i++) {\n\t\tif ((entity->pads[i].flags &\n\t\t     (MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_SOURCE)) != pad_type)\n\t\t\tcontinue;\n\n\t\tif (entity->pads[i].sig_type == sig_type)\n\t\t\treturn i;\n\t}\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(media_get_pad_index);\n\nint\nmedia_create_pad_link(struct media_entity *source, u16 source_pad,\n\t\t\t struct media_entity *sink, u16 sink_pad, u32 flags)\n{\n\tstruct media_link *link;\n\tstruct media_link *backlink;\n\n\tif (WARN_ON(!source || !sink) ||\n\t    WARN_ON(source_pad >= source->num_pads) ||\n\t    WARN_ON(sink_pad >= sink->num_pads))\n\t\treturn -EINVAL;\n\tif (WARN_ON(!(source->pads[source_pad].flags & MEDIA_PAD_FL_SOURCE)))\n\t\treturn -EINVAL;\n\tif (WARN_ON(!(sink->pads[sink_pad].flags & MEDIA_PAD_FL_SINK)))\n\t\treturn -EINVAL;\n\n\tlink = media_add_link(&source->links);\n\tif (link == NULL)\n\t\treturn -ENOMEM;\n\n\tlink->source = &source->pads[source_pad];\n\tlink->sink = &sink->pads[sink_pad];\n\tlink->flags = flags & ~MEDIA_LNK_FL_INTERFACE_LINK;\n\n\t \n\tmedia_gobj_create(source->graph_obj.mdev, MEDIA_GRAPH_LINK,\n\t\t\t&link->graph_obj);\n\n\t \n\tbacklink = media_add_link(&sink->links);\n\tif (backlink == NULL) {\n\t\t__media_entity_remove_link(source, link);\n\t\treturn -ENOMEM;\n\t}\n\n\tbacklink->source = &source->pads[source_pad];\n\tbacklink->sink = &sink->pads[sink_pad];\n\tbacklink->flags = flags;\n\tbacklink->is_backlink = true;\n\n\t \n\tmedia_gobj_create(sink->graph_obj.mdev, MEDIA_GRAPH_LINK,\n\t\t\t&backlink->graph_obj);\n\n\tlink->reverse = backlink;\n\tbacklink->reverse = link;\n\n\tsink->num_backlinks++;\n\tsink->num_links++;\n\tsource->num_links++;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(media_create_pad_link);\n\nint media_create_pad_links(const struct media_device *mdev,\n\t\t\t   const u32 source_function,\n\t\t\t   struct media_entity *source,\n\t\t\t   const u16 source_pad,\n\t\t\t   const u32 sink_function,\n\t\t\t   struct media_entity *sink,\n\t\t\t   const u16 sink_pad,\n\t\t\t   u32 flags,\n\t\t\t   const bool allow_both_undefined)\n{\n\tstruct media_entity *entity;\n\tunsigned function;\n\tint ret;\n\n\t \n\tif (source && sink)\n\t\treturn media_create_pad_link(source, source_pad,\n\t\t\t\t\t     sink, sink_pad, flags);\n\n\t \n\tif (!source && !sink) {\n\t\tif (!allow_both_undefined)\n\t\t\treturn 0;\n\t\tmedia_device_for_each_entity(source, mdev) {\n\t\t\tif (source->function != source_function)\n\t\t\t\tcontinue;\n\t\t\tmedia_device_for_each_entity(sink, mdev) {\n\t\t\t\tif (sink->function != sink_function)\n\t\t\t\t\tcontinue;\n\t\t\t\tret = media_create_pad_link(source, source_pad,\n\t\t\t\t\t\t\t    sink, sink_pad,\n\t\t\t\t\t\t\t    flags);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tflags &= ~(MEDIA_LNK_FL_ENABLED |\n\t\t\t\t\t   MEDIA_LNK_FL_IMMUTABLE);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tif (source)\n\t\tfunction = sink_function;\n\telse\n\t\tfunction = source_function;\n\n\tmedia_device_for_each_entity(entity, mdev) {\n\t\tif (entity->function != function)\n\t\t\tcontinue;\n\n\t\tif (source)\n\t\t\tret = media_create_pad_link(source, source_pad,\n\t\t\t\t\t\t    entity, sink_pad, flags);\n\t\telse\n\t\t\tret = media_create_pad_link(entity, source_pad,\n\t\t\t\t\t\t    sink, sink_pad, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tflags &= ~(MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(media_create_pad_links);\n\nvoid __media_entity_remove_links(struct media_entity *entity)\n{\n\tstruct media_link *link, *tmp;\n\n\tlist_for_each_entry_safe(link, tmp, &entity->links, list)\n\t\t__media_entity_remove_link(entity, link);\n\n\tentity->num_links = 0;\n\tentity->num_backlinks = 0;\n}\nEXPORT_SYMBOL_GPL(__media_entity_remove_links);\n\nvoid media_entity_remove_links(struct media_entity *entity)\n{\n\tstruct media_device *mdev = entity->graph_obj.mdev;\n\n\t \n\tif (mdev == NULL)\n\t\treturn;\n\n\tmutex_lock(&mdev->graph_mutex);\n\t__media_entity_remove_links(entity);\n\tmutex_unlock(&mdev->graph_mutex);\n}\nEXPORT_SYMBOL_GPL(media_entity_remove_links);\n\nstatic int __media_entity_setup_link_notify(struct media_link *link, u32 flags)\n{\n\tint ret;\n\n\t \n\tret = media_entity_call(link->source->entity, link_setup,\n\t\t\t\tlink->source, link->sink, flags);\n\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\treturn ret;\n\n\tret = media_entity_call(link->sink->entity, link_setup,\n\t\t\t\tlink->sink, link->source, flags);\n\tif (ret < 0 && ret != -ENOIOCTLCMD) {\n\t\tmedia_entity_call(link->source->entity, link_setup,\n\t\t\t\t  link->source, link->sink, link->flags);\n\t\treturn ret;\n\t}\n\n\tlink->flags = flags;\n\tlink->reverse->flags = link->flags;\n\n\treturn 0;\n}\n\nint __media_entity_setup_link(struct media_link *link, u32 flags)\n{\n\tconst u32 mask = MEDIA_LNK_FL_ENABLED;\n\tstruct media_device *mdev;\n\tstruct media_pad *source, *sink;\n\tint ret = -EBUSY;\n\n\tif (link == NULL)\n\t\treturn -EINVAL;\n\n\t \n\tif ((link->flags & ~mask) != (flags & ~mask))\n\t\treturn -EINVAL;\n\n\tif (link->flags & MEDIA_LNK_FL_IMMUTABLE)\n\t\treturn link->flags == flags ? 0 : -EINVAL;\n\n\tif (link->flags == flags)\n\t\treturn 0;\n\n\tsource = link->source;\n\tsink = link->sink;\n\n\tif (!(link->flags & MEDIA_LNK_FL_DYNAMIC) &&\n\t    (media_pad_is_streaming(source) || media_pad_is_streaming(sink)))\n\t\treturn -EBUSY;\n\n\tmdev = source->graph_obj.mdev;\n\n\tif (mdev->ops && mdev->ops->link_notify) {\n\t\tret = mdev->ops->link_notify(link, flags,\n\t\t\t\t\t     MEDIA_DEV_NOTIFY_PRE_LINK_CH);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = __media_entity_setup_link_notify(link, flags);\n\n\tif (mdev->ops && mdev->ops->link_notify)\n\t\tmdev->ops->link_notify(link, flags,\n\t\t\t\t       MEDIA_DEV_NOTIFY_POST_LINK_CH);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__media_entity_setup_link);\n\nint media_entity_setup_link(struct media_link *link, u32 flags)\n{\n\tint ret;\n\n\tmutex_lock(&link->graph_obj.mdev->graph_mutex);\n\tret = __media_entity_setup_link(link, flags);\n\tmutex_unlock(&link->graph_obj.mdev->graph_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(media_entity_setup_link);\n\nstruct media_link *\nmedia_entity_find_link(struct media_pad *source, struct media_pad *sink)\n{\n\tstruct media_link *link;\n\n\tfor_each_media_entity_data_link(source->entity, link) {\n\t\tif (link->source->entity == source->entity &&\n\t\t    link->source->index == source->index &&\n\t\t    link->sink->entity == sink->entity &&\n\t\t    link->sink->index == sink->index)\n\t\t\treturn link;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(media_entity_find_link);\n\nstruct media_pad *media_pad_remote_pad_first(const struct media_pad *pad)\n{\n\tstruct media_link *link;\n\n\tfor_each_media_entity_data_link(pad->entity, link) {\n\t\tif (!(link->flags & MEDIA_LNK_FL_ENABLED))\n\t\t\tcontinue;\n\n\t\tif (link->source == pad)\n\t\t\treturn link->sink;\n\n\t\tif (link->sink == pad)\n\t\t\treturn link->source;\n\t}\n\n\treturn NULL;\n\n}\nEXPORT_SYMBOL_GPL(media_pad_remote_pad_first);\n\nstruct media_pad *\nmedia_entity_remote_pad_unique(const struct media_entity *entity,\n\t\t\t       unsigned int type)\n{\n\tstruct media_pad *pad = NULL;\n\tstruct media_link *link;\n\n\tlist_for_each_entry(link, &entity->links, list) {\n\t\tstruct media_pad *local_pad;\n\t\tstruct media_pad *remote_pad;\n\n\t\tif (((link->flags & MEDIA_LNK_FL_LINK_TYPE) !=\n\t\t     MEDIA_LNK_FL_DATA_LINK) ||\n\t\t    !(link->flags & MEDIA_LNK_FL_ENABLED))\n\t\t\tcontinue;\n\n\t\tif (type == MEDIA_PAD_FL_SOURCE) {\n\t\t\tlocal_pad = link->sink;\n\t\t\tremote_pad = link->source;\n\t\t} else {\n\t\t\tlocal_pad = link->source;\n\t\t\tremote_pad = link->sink;\n\t\t}\n\n\t\tif (local_pad->entity == entity) {\n\t\t\tif (pad)\n\t\t\t\treturn ERR_PTR(-ENOTUNIQ);\n\n\t\t\tpad = remote_pad;\n\t\t}\n\t}\n\n\tif (!pad)\n\t\treturn ERR_PTR(-ENOLINK);\n\n\treturn pad;\n}\nEXPORT_SYMBOL_GPL(media_entity_remote_pad_unique);\n\nstruct media_pad *media_pad_remote_pad_unique(const struct media_pad *pad)\n{\n\tstruct media_pad *found_pad = NULL;\n\tstruct media_link *link;\n\n\tlist_for_each_entry(link, &pad->entity->links, list) {\n\t\tstruct media_pad *remote_pad;\n\n\t\tif (!(link->flags & MEDIA_LNK_FL_ENABLED))\n\t\t\tcontinue;\n\n\t\tif (link->sink == pad)\n\t\t\tremote_pad = link->source;\n\t\telse if (link->source == pad)\n\t\t\tremote_pad = link->sink;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (found_pad)\n\t\t\treturn ERR_PTR(-ENOTUNIQ);\n\n\t\tfound_pad = remote_pad;\n\t}\n\n\tif (!found_pad)\n\t\treturn ERR_PTR(-ENOLINK);\n\n\treturn found_pad;\n}\nEXPORT_SYMBOL_GPL(media_pad_remote_pad_unique);\n\nint media_entity_get_fwnode_pad(struct media_entity *entity,\n\t\t\t\tconst struct fwnode_handle *fwnode,\n\t\t\t\tunsigned long direction_flags)\n{\n\tstruct fwnode_endpoint endpoint;\n\tunsigned int i;\n\tint ret;\n\n\tif (!entity->ops || !entity->ops->get_fwnode_pad) {\n\t\tfor (i = 0; i < entity->num_pads; i++) {\n\t\t\tif (entity->pads[i].flags & direction_flags)\n\t\t\t\treturn i;\n\t\t}\n\n\t\treturn -ENXIO;\n\t}\n\n\tret = fwnode_graph_parse_endpoint(fwnode, &endpoint);\n\tif (ret)\n\t\treturn ret;\n\n\tret = entity->ops->get_fwnode_pad(entity, &endpoint);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret >= entity->num_pads)\n\t\treturn -ENXIO;\n\n\tif (!(entity->pads[ret].flags & direction_flags))\n\t\treturn -ENXIO;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(media_entity_get_fwnode_pad);\n\nstruct media_pipeline *media_entity_pipeline(struct media_entity *entity)\n{\n\tstruct media_pad *pad;\n\n\tmedia_entity_for_each_pad(entity, pad) {\n\t\tif (pad->pipe)\n\t\t\treturn pad->pipe;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(media_entity_pipeline);\n\nstruct media_pipeline *media_pad_pipeline(struct media_pad *pad)\n{\n\treturn pad->pipe;\n}\nEXPORT_SYMBOL_GPL(media_pad_pipeline);\n\nstatic void media_interface_init(struct media_device *mdev,\n\t\t\t\t struct media_interface *intf,\n\t\t\t\t u32 gobj_type,\n\t\t\t\t u32 intf_type, u32 flags)\n{\n\tintf->type = intf_type;\n\tintf->flags = flags;\n\tINIT_LIST_HEAD(&intf->links);\n\n\tmedia_gobj_create(mdev, gobj_type, &intf->graph_obj);\n}\n\n \n\nstruct media_intf_devnode *media_devnode_create(struct media_device *mdev,\n\t\t\t\t\t\tu32 type, u32 flags,\n\t\t\t\t\t\tu32 major, u32 minor)\n{\n\tstruct media_intf_devnode *devnode;\n\n\tdevnode = kzalloc(sizeof(*devnode), GFP_KERNEL);\n\tif (!devnode)\n\t\treturn NULL;\n\n\tdevnode->major = major;\n\tdevnode->minor = minor;\n\n\tmedia_interface_init(mdev, &devnode->intf, MEDIA_GRAPH_INTF_DEVNODE,\n\t\t\t     type, flags);\n\n\treturn devnode;\n}\nEXPORT_SYMBOL_GPL(media_devnode_create);\n\nvoid media_devnode_remove(struct media_intf_devnode *devnode)\n{\n\tmedia_remove_intf_links(&devnode->intf);\n\tmedia_gobj_destroy(&devnode->intf.graph_obj);\n\tkfree(devnode);\n}\nEXPORT_SYMBOL_GPL(media_devnode_remove);\n\nstruct media_link *media_create_intf_link(struct media_entity *entity,\n\t\t\t\t\t    struct media_interface *intf,\n\t\t\t\t\t    u32 flags)\n{\n\tstruct media_link *link;\n\n\tlink = media_add_link(&intf->links);\n\tif (link == NULL)\n\t\treturn NULL;\n\n\tlink->intf = intf;\n\tlink->entity = entity;\n\tlink->flags = flags | MEDIA_LNK_FL_INTERFACE_LINK;\n\n\t \n\tmedia_gobj_create(intf->graph_obj.mdev, MEDIA_GRAPH_LINK,\n\t\t\t&link->graph_obj);\n\n\treturn link;\n}\nEXPORT_SYMBOL_GPL(media_create_intf_link);\n\nvoid __media_remove_intf_link(struct media_link *link)\n{\n\tlist_del(&link->list);\n\tmedia_gobj_destroy(&link->graph_obj);\n\tkfree(link);\n}\nEXPORT_SYMBOL_GPL(__media_remove_intf_link);\n\nvoid media_remove_intf_link(struct media_link *link)\n{\n\tstruct media_device *mdev = link->graph_obj.mdev;\n\n\t \n\tif (mdev == NULL)\n\t\treturn;\n\n\tmutex_lock(&mdev->graph_mutex);\n\t__media_remove_intf_link(link);\n\tmutex_unlock(&mdev->graph_mutex);\n}\nEXPORT_SYMBOL_GPL(media_remove_intf_link);\n\nvoid __media_remove_intf_links(struct media_interface *intf)\n{\n\tstruct media_link *link, *tmp;\n\n\tlist_for_each_entry_safe(link, tmp, &intf->links, list)\n\t\t__media_remove_intf_link(link);\n\n}\nEXPORT_SYMBOL_GPL(__media_remove_intf_links);\n\nvoid media_remove_intf_links(struct media_interface *intf)\n{\n\tstruct media_device *mdev = intf->graph_obj.mdev;\n\n\t \n\tif (mdev == NULL)\n\t\treturn;\n\n\tmutex_lock(&mdev->graph_mutex);\n\t__media_remove_intf_links(intf);\n\tmutex_unlock(&mdev->graph_mutex);\n}\nEXPORT_SYMBOL_GPL(media_remove_intf_links);\n\nstruct media_link *media_create_ancillary_link(struct media_entity *primary,\n\t\t\t\t\t       struct media_entity *ancillary)\n{\n\tstruct media_link *link;\n\n\tlink = media_add_link(&primary->links);\n\tif (!link)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlink->gobj0 = &primary->graph_obj;\n\tlink->gobj1 = &ancillary->graph_obj;\n\tlink->flags = MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED |\n\t\t      MEDIA_LNK_FL_ANCILLARY_LINK;\n\n\t \n\tmedia_gobj_create(primary->graph_obj.mdev, MEDIA_GRAPH_LINK,\n\t\t\t  &link->graph_obj);\n\n\treturn link;\n}\nEXPORT_SYMBOL_GPL(media_create_ancillary_link);\n\nstruct media_link *__media_entity_next_link(struct media_entity *entity,\n\t\t\t\t\t    struct media_link *link,\n\t\t\t\t\t    unsigned long link_type)\n{\n\tlink = link ? list_next_entry(link, list)\n\t\t    : list_first_entry(&entity->links, typeof(*link), list);\n\n\tlist_for_each_entry_from(link, &entity->links, list)\n\t\tif ((link->flags & MEDIA_LNK_FL_LINK_TYPE) == link_type)\n\t\t\treturn link;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(__media_entity_next_link);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}