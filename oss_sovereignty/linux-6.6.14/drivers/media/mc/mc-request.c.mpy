{
  "module_name": "mc-request.c",
  "hash_id": "6a7c8945a3be495296780c89bedb93011f1957decc9a35b60f09262f7efebf51",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/mc/mc-request.c",
  "human_readable_source": "\n \n\n#include <linux/anon_inodes.h>\n#include <linux/file.h>\n#include <linux/refcount.h>\n\n#include <media/media-device.h>\n#include <media/media-request.h>\n\nstatic const char * const request_state[] = {\n\t[MEDIA_REQUEST_STATE_IDLE]\t = \"idle\",\n\t[MEDIA_REQUEST_STATE_VALIDATING] = \"validating\",\n\t[MEDIA_REQUEST_STATE_QUEUED]\t = \"queued\",\n\t[MEDIA_REQUEST_STATE_COMPLETE]\t = \"complete\",\n\t[MEDIA_REQUEST_STATE_CLEANING]\t = \"cleaning\",\n\t[MEDIA_REQUEST_STATE_UPDATING]\t = \"updating\",\n};\n\nstatic const char *\nmedia_request_state_str(enum media_request_state state)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(request_state) != NR_OF_MEDIA_REQUEST_STATE);\n\n\tif (WARN_ON(state >= ARRAY_SIZE(request_state)))\n\t\treturn \"invalid\";\n\treturn request_state[state];\n}\n\nstatic void media_request_clean(struct media_request *req)\n{\n\tstruct media_request_object *obj, *obj_safe;\n\n\t \n\tWARN_ON(req->state != MEDIA_REQUEST_STATE_CLEANING);\n\tWARN_ON(req->updating_count);\n\tWARN_ON(req->access_count);\n\n\tlist_for_each_entry_safe(obj, obj_safe, &req->objects, list) {\n\t\tmedia_request_object_unbind(obj);\n\t\tmedia_request_object_put(obj);\n\t}\n\n\treq->updating_count = 0;\n\treq->access_count = 0;\n\tWARN_ON(req->num_incomplete_objects);\n\treq->num_incomplete_objects = 0;\n\twake_up_interruptible_all(&req->poll_wait);\n}\n\nstatic void media_request_release(struct kref *kref)\n{\n\tstruct media_request *req =\n\t\tcontainer_of(kref, struct media_request, kref);\n\tstruct media_device *mdev = req->mdev;\n\n\tdev_dbg(mdev->dev, \"request: release %s\\n\", req->debug_str);\n\n\t \n\treq->state = MEDIA_REQUEST_STATE_CLEANING;\n\n\tmedia_request_clean(req);\n\n\tif (mdev->ops->req_free)\n\t\tmdev->ops->req_free(req);\n\telse\n\t\tkfree(req);\n}\n\nvoid media_request_put(struct media_request *req)\n{\n\tkref_put(&req->kref, media_request_release);\n}\nEXPORT_SYMBOL_GPL(media_request_put);\n\nstatic int media_request_close(struct inode *inode, struct file *filp)\n{\n\tstruct media_request *req = filp->private_data;\n\n\tmedia_request_put(req);\n\treturn 0;\n}\n\nstatic __poll_t media_request_poll(struct file *filp,\n\t\t\t\t   struct poll_table_struct *wait)\n{\n\tstruct media_request *req = filp->private_data;\n\tunsigned long flags;\n\t__poll_t ret = 0;\n\n\tif (!(poll_requested_events(wait) & EPOLLPRI))\n\t\treturn 0;\n\n\tpoll_wait(filp, &req->poll_wait, wait);\n\tspin_lock_irqsave(&req->lock, flags);\n\tif (req->state == MEDIA_REQUEST_STATE_COMPLETE) {\n\t\tret = EPOLLPRI;\n\t\tgoto unlock;\n\t}\n\tif (req->state != MEDIA_REQUEST_STATE_QUEUED) {\n\t\tret = EPOLLERR;\n\t\tgoto unlock;\n\t}\n\nunlock:\n\tspin_unlock_irqrestore(&req->lock, flags);\n\treturn ret;\n}\n\nstatic long media_request_ioctl_queue(struct media_request *req)\n{\n\tstruct media_device *mdev = req->mdev;\n\tenum media_request_state state;\n\tunsigned long flags;\n\tint ret;\n\n\tdev_dbg(mdev->dev, \"request: queue %s\\n\", req->debug_str);\n\n\t \n\tmutex_lock(&mdev->req_queue_mutex);\n\n\tmedia_request_get(req);\n\n\tspin_lock_irqsave(&req->lock, flags);\n\tif (req->state == MEDIA_REQUEST_STATE_IDLE)\n\t\treq->state = MEDIA_REQUEST_STATE_VALIDATING;\n\tstate = req->state;\n\tspin_unlock_irqrestore(&req->lock, flags);\n\tif (state != MEDIA_REQUEST_STATE_VALIDATING) {\n\t\tdev_dbg(mdev->dev,\n\t\t\t\"request: unable to queue %s, request in state %s\\n\",\n\t\t\treq->debug_str, media_request_state_str(state));\n\t\tmedia_request_put(req);\n\t\tmutex_unlock(&mdev->req_queue_mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tret = mdev->ops->req_validate(req);\n\n\t \n\tspin_lock_irqsave(&req->lock, flags);\n\treq->state = ret ? MEDIA_REQUEST_STATE_IDLE\n\t\t\t : MEDIA_REQUEST_STATE_QUEUED;\n\tspin_unlock_irqrestore(&req->lock, flags);\n\n\tif (!ret)\n\t\tmdev->ops->req_queue(req);\n\n\tmutex_unlock(&mdev->req_queue_mutex);\n\n\tif (ret) {\n\t\tdev_dbg(mdev->dev, \"request: can't queue %s (%d)\\n\",\n\t\t\treq->debug_str, ret);\n\t\tmedia_request_put(req);\n\t}\n\n\treturn ret;\n}\n\nstatic long media_request_ioctl_reinit(struct media_request *req)\n{\n\tstruct media_device *mdev = req->mdev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&req->lock, flags);\n\tif (req->state != MEDIA_REQUEST_STATE_IDLE &&\n\t    req->state != MEDIA_REQUEST_STATE_COMPLETE) {\n\t\tdev_dbg(mdev->dev,\n\t\t\t\"request: %s not in idle or complete state, cannot reinit\\n\",\n\t\t\treq->debug_str);\n\t\tspin_unlock_irqrestore(&req->lock, flags);\n\t\treturn -EBUSY;\n\t}\n\tif (req->access_count) {\n\t\tdev_dbg(mdev->dev,\n\t\t\t\"request: %s is being accessed, cannot reinit\\n\",\n\t\t\treq->debug_str);\n\t\tspin_unlock_irqrestore(&req->lock, flags);\n\t\treturn -EBUSY;\n\t}\n\treq->state = MEDIA_REQUEST_STATE_CLEANING;\n\tspin_unlock_irqrestore(&req->lock, flags);\n\n\tmedia_request_clean(req);\n\n\tspin_lock_irqsave(&req->lock, flags);\n\treq->state = MEDIA_REQUEST_STATE_IDLE;\n\tspin_unlock_irqrestore(&req->lock, flags);\n\n\treturn 0;\n}\n\nstatic long media_request_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tstruct media_request *req = filp->private_data;\n\n\tswitch (cmd) {\n\tcase MEDIA_REQUEST_IOC_QUEUE:\n\t\treturn media_request_ioctl_queue(req);\n\tcase MEDIA_REQUEST_IOC_REINIT:\n\t\treturn media_request_ioctl_reinit(req);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic const struct file_operations request_fops = {\n\t.owner = THIS_MODULE,\n\t.poll = media_request_poll,\n\t.unlocked_ioctl = media_request_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = media_request_ioctl,\n#endif  \n\t.release = media_request_close,\n};\n\nstruct media_request *\nmedia_request_get_by_fd(struct media_device *mdev, int request_fd)\n{\n\tstruct fd f;\n\tstruct media_request *req;\n\n\tif (!mdev || !mdev->ops ||\n\t    !mdev->ops->req_validate || !mdev->ops->req_queue)\n\t\treturn ERR_PTR(-EBADR);\n\n\tf = fdget(request_fd);\n\tif (!f.file)\n\t\tgoto err_no_req_fd;\n\n\tif (f.file->f_op != &request_fops)\n\t\tgoto err_fput;\n\treq = f.file->private_data;\n\tif (req->mdev != mdev)\n\t\tgoto err_fput;\n\n\t \n\tmedia_request_get(req);\n\tfdput(f);\n\n\treturn req;\n\nerr_fput:\n\tfdput(f);\n\nerr_no_req_fd:\n\tdev_dbg(mdev->dev, \"cannot find request_fd %d\\n\", request_fd);\n\treturn ERR_PTR(-EINVAL);\n}\nEXPORT_SYMBOL_GPL(media_request_get_by_fd);\n\nint media_request_alloc(struct media_device *mdev, int *alloc_fd)\n{\n\tstruct media_request *req;\n\tstruct file *filp;\n\tint fd;\n\tint ret;\n\n\t \n\tif (WARN_ON(!mdev->ops->req_alloc ^ !mdev->ops->req_free))\n\t\treturn -ENOMEM;\n\n\tif (mdev->ops->req_alloc)\n\t\treq = mdev->ops->req_alloc(mdev);\n\telse\n\t\treq = kzalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0) {\n\t\tret = fd;\n\t\tgoto err_free_req;\n\t}\n\n\tfilp = anon_inode_getfile(\"request\", &request_fops, NULL, O_CLOEXEC);\n\tif (IS_ERR(filp)) {\n\t\tret = PTR_ERR(filp);\n\t\tgoto err_put_fd;\n\t}\n\n\tfilp->private_data = req;\n\treq->mdev = mdev;\n\treq->state = MEDIA_REQUEST_STATE_IDLE;\n\treq->num_incomplete_objects = 0;\n\tkref_init(&req->kref);\n\tINIT_LIST_HEAD(&req->objects);\n\tspin_lock_init(&req->lock);\n\tinit_waitqueue_head(&req->poll_wait);\n\treq->updating_count = 0;\n\treq->access_count = 0;\n\n\t*alloc_fd = fd;\n\n\tsnprintf(req->debug_str, sizeof(req->debug_str), \"%u:%d\",\n\t\t atomic_inc_return(&mdev->request_id), fd);\n\tdev_dbg(mdev->dev, \"request: allocated %s\\n\", req->debug_str);\n\n\tfd_install(fd, filp);\n\n\treturn 0;\n\nerr_put_fd:\n\tput_unused_fd(fd);\n\nerr_free_req:\n\tif (mdev->ops->req_free)\n\t\tmdev->ops->req_free(req);\n\telse\n\t\tkfree(req);\n\n\treturn ret;\n}\n\nstatic void media_request_object_release(struct kref *kref)\n{\n\tstruct media_request_object *obj =\n\t\tcontainer_of(kref, struct media_request_object, kref);\n\tstruct media_request *req = obj->req;\n\n\tif (WARN_ON(req))\n\t\tmedia_request_object_unbind(obj);\n\tobj->ops->release(obj);\n}\n\nstruct media_request_object *\nmedia_request_object_find(struct media_request *req,\n\t\t\t  const struct media_request_object_ops *ops,\n\t\t\t  void *priv)\n{\n\tstruct media_request_object *obj;\n\tstruct media_request_object *found = NULL;\n\tunsigned long flags;\n\n\tif (WARN_ON(!ops || !priv))\n\t\treturn NULL;\n\n\tspin_lock_irqsave(&req->lock, flags);\n\tlist_for_each_entry(obj, &req->objects, list) {\n\t\tif (obj->ops == ops && obj->priv == priv) {\n\t\t\tmedia_request_object_get(obj);\n\t\t\tfound = obj;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&req->lock, flags);\n\treturn found;\n}\nEXPORT_SYMBOL_GPL(media_request_object_find);\n\nvoid media_request_object_put(struct media_request_object *obj)\n{\n\tkref_put(&obj->kref, media_request_object_release);\n}\nEXPORT_SYMBOL_GPL(media_request_object_put);\n\nvoid media_request_object_init(struct media_request_object *obj)\n{\n\tobj->ops = NULL;\n\tobj->req = NULL;\n\tobj->priv = NULL;\n\tobj->completed = false;\n\tINIT_LIST_HEAD(&obj->list);\n\tkref_init(&obj->kref);\n}\nEXPORT_SYMBOL_GPL(media_request_object_init);\n\nint media_request_object_bind(struct media_request *req,\n\t\t\t      const struct media_request_object_ops *ops,\n\t\t\t      void *priv, bool is_buffer,\n\t\t\t      struct media_request_object *obj)\n{\n\tunsigned long flags;\n\tint ret = -EBUSY;\n\n\tif (WARN_ON(!ops->release))\n\t\treturn -EBADR;\n\n\tspin_lock_irqsave(&req->lock, flags);\n\n\tif (WARN_ON(req->state != MEDIA_REQUEST_STATE_UPDATING &&\n\t\t    req->state != MEDIA_REQUEST_STATE_QUEUED))\n\t\tgoto unlock;\n\n\tobj->req = req;\n\tobj->ops = ops;\n\tobj->priv = priv;\n\n\tif (is_buffer)\n\t\tlist_add_tail(&obj->list, &req->objects);\n\telse\n\t\tlist_add(&obj->list, &req->objects);\n\treq->num_incomplete_objects++;\n\tret = 0;\n\nunlock:\n\tspin_unlock_irqrestore(&req->lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(media_request_object_bind);\n\nvoid media_request_object_unbind(struct media_request_object *obj)\n{\n\tstruct media_request *req = obj->req;\n\tunsigned long flags;\n\tbool completed = false;\n\n\tif (WARN_ON(!req))\n\t\treturn;\n\n\tspin_lock_irqsave(&req->lock, flags);\n\tlist_del(&obj->list);\n\tobj->req = NULL;\n\n\tif (req->state == MEDIA_REQUEST_STATE_COMPLETE)\n\t\tgoto unlock;\n\n\tif (WARN_ON(req->state == MEDIA_REQUEST_STATE_VALIDATING))\n\t\tgoto unlock;\n\n\tif (req->state == MEDIA_REQUEST_STATE_CLEANING) {\n\t\tif (!obj->completed)\n\t\t\treq->num_incomplete_objects--;\n\t\tgoto unlock;\n\t}\n\n\tif (WARN_ON(!req->num_incomplete_objects))\n\t\tgoto unlock;\n\n\treq->num_incomplete_objects--;\n\tif (req->state == MEDIA_REQUEST_STATE_QUEUED &&\n\t    !req->num_incomplete_objects) {\n\t\treq->state = MEDIA_REQUEST_STATE_COMPLETE;\n\t\tcompleted = true;\n\t\twake_up_interruptible_all(&req->poll_wait);\n\t}\n\nunlock:\n\tspin_unlock_irqrestore(&req->lock, flags);\n\tif (obj->ops->unbind)\n\t\tobj->ops->unbind(obj);\n\tif (completed)\n\t\tmedia_request_put(req);\n}\nEXPORT_SYMBOL_GPL(media_request_object_unbind);\n\nvoid media_request_object_complete(struct media_request_object *obj)\n{\n\tstruct media_request *req = obj->req;\n\tunsigned long flags;\n\tbool completed = false;\n\n\tspin_lock_irqsave(&req->lock, flags);\n\tif (obj->completed)\n\t\tgoto unlock;\n\tobj->completed = true;\n\tif (WARN_ON(!req->num_incomplete_objects) ||\n\t    WARN_ON(req->state != MEDIA_REQUEST_STATE_QUEUED))\n\t\tgoto unlock;\n\n\tif (!--req->num_incomplete_objects) {\n\t\treq->state = MEDIA_REQUEST_STATE_COMPLETE;\n\t\twake_up_interruptible_all(&req->poll_wait);\n\t\tcompleted = true;\n\t}\nunlock:\n\tspin_unlock_irqrestore(&req->lock, flags);\n\tif (completed)\n\t\tmedia_request_put(req);\n}\nEXPORT_SYMBOL_GPL(media_request_object_complete);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}