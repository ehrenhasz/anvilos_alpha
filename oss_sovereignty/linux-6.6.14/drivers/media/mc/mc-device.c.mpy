{
  "module_name": "mc-device.c",
  "hash_id": "401e57a5c1a5e260516491134deb07792d4358b2284959ecd11444c5f79330a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/mc/mc-device.c",
  "human_readable_source": "\n \n\n#include <linux/compat.h>\n#include <linux/export.h>\n#include <linux/idr.h>\n#include <linux/ioctl.h>\n#include <linux/media.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/usb.h>\n#include <linux/version.h>\n\n#include <media/media-device.h>\n#include <media/media-devnode.h>\n#include <media/media-entity.h>\n#include <media/media-request.h>\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\n \n#define MEDIA_ENT_SUBTYPE_MASK\t\t\t0x0000ffff\n#define MEDIA_ENT_T_DEVNODE_UNKNOWN\t\t(MEDIA_ENT_F_OLD_BASE | \\\n\t\t\t\t\t\t MEDIA_ENT_SUBTYPE_MASK)\n\n \n\nstatic inline void __user *media_get_uptr(__u64 arg)\n{\n\treturn (void __user *)(uintptr_t)arg;\n}\n\nstatic int media_device_open(struct file *filp)\n{\n\treturn 0;\n}\n\nstatic int media_device_close(struct file *filp)\n{\n\treturn 0;\n}\n\nstatic long media_device_get_info(struct media_device *dev, void *arg)\n{\n\tstruct media_device_info *info = arg;\n\n\tmemset(info, 0, sizeof(*info));\n\n\tif (dev->driver_name[0])\n\t\tstrscpy(info->driver, dev->driver_name, sizeof(info->driver));\n\telse\n\t\tstrscpy(info->driver, dev->dev->driver->name,\n\t\t\tsizeof(info->driver));\n\n\tstrscpy(info->model, dev->model, sizeof(info->model));\n\tstrscpy(info->serial, dev->serial, sizeof(info->serial));\n\tstrscpy(info->bus_info, dev->bus_info, sizeof(info->bus_info));\n\n\tinfo->media_version = LINUX_VERSION_CODE;\n\tinfo->driver_version = info->media_version;\n\tinfo->hw_revision = dev->hw_revision;\n\n\treturn 0;\n}\n\nstatic struct media_entity *find_entity(struct media_device *mdev, u32 id)\n{\n\tstruct media_entity *entity;\n\tint next = id & MEDIA_ENT_ID_FLAG_NEXT;\n\n\tid &= ~MEDIA_ENT_ID_FLAG_NEXT;\n\n\tmedia_device_for_each_entity(entity, mdev) {\n\t\tif (((media_entity_id(entity) == id) && !next) ||\n\t\t    ((media_entity_id(entity) > id) && next)) {\n\t\t\treturn entity;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic long media_device_enum_entities(struct media_device *mdev, void *arg)\n{\n\tstruct media_entity_desc *entd = arg;\n\tstruct media_entity *ent;\n\n\tent = find_entity(mdev, entd->id);\n\tif (ent == NULL)\n\t\treturn -EINVAL;\n\n\tmemset(entd, 0, sizeof(*entd));\n\n\tentd->id = media_entity_id(ent);\n\tif (ent->name)\n\t\tstrscpy(entd->name, ent->name, sizeof(entd->name));\n\tentd->type = ent->function;\n\tentd->revision = 0;\t\t \n\tentd->flags = ent->flags;\n\tentd->group_id = 0;\t\t \n\tentd->pads = ent->num_pads;\n\tentd->links = ent->num_links - ent->num_backlinks;\n\n\t \n\tif (ent->function < MEDIA_ENT_F_OLD_BASE ||\n\t    ent->function > MEDIA_ENT_F_TUNER) {\n\t\tif (is_media_entity_v4l2_subdev(ent))\n\t\t\tentd->type = MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN;\n\t\telse if (ent->function != MEDIA_ENT_F_IO_V4L)\n\t\t\tentd->type = MEDIA_ENT_T_DEVNODE_UNKNOWN;\n\t}\n\n\tmemcpy(&entd->raw, &ent->info, sizeof(ent->info));\n\n\treturn 0;\n}\n\nstatic void media_device_kpad_to_upad(const struct media_pad *kpad,\n\t\t\t\t      struct media_pad_desc *upad)\n{\n\tupad->entity = media_entity_id(kpad->entity);\n\tupad->index = kpad->index;\n\tupad->flags = kpad->flags;\n}\n\nstatic long media_device_enum_links(struct media_device *mdev, void *arg)\n{\n\tstruct media_links_enum *links = arg;\n\tstruct media_entity *entity;\n\n\tentity = find_entity(mdev, links->entity);\n\tif (entity == NULL)\n\t\treturn -EINVAL;\n\n\tif (links->pads) {\n\t\tunsigned int p;\n\n\t\tfor (p = 0; p < entity->num_pads; p++) {\n\t\t\tstruct media_pad_desc pad;\n\n\t\t\tmemset(&pad, 0, sizeof(pad));\n\t\t\tmedia_device_kpad_to_upad(&entity->pads[p], &pad);\n\t\t\tif (copy_to_user(&links->pads[p], &pad, sizeof(pad)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (links->links) {\n\t\tstruct media_link *link;\n\t\tstruct media_link_desc __user *ulink_desc = links->links;\n\n\t\tlist_for_each_entry(link, &entity->links, list) {\n\t\t\tstruct media_link_desc klink_desc;\n\n\t\t\t \n\t\t\tif (link->source->entity != entity)\n\t\t\t\tcontinue;\n\t\t\tmemset(&klink_desc, 0, sizeof(klink_desc));\n\t\t\tmedia_device_kpad_to_upad(link->source,\n\t\t\t\t\t\t  &klink_desc.source);\n\t\t\tmedia_device_kpad_to_upad(link->sink,\n\t\t\t\t\t\t  &klink_desc.sink);\n\t\t\tklink_desc.flags = link->flags;\n\t\t\tif (copy_to_user(ulink_desc, &klink_desc,\n\t\t\t\t\t sizeof(*ulink_desc)))\n\t\t\t\treturn -EFAULT;\n\t\t\tulink_desc++;\n\t\t}\n\t}\n\tmemset(links->reserved, 0, sizeof(links->reserved));\n\n\treturn 0;\n}\n\nstatic long media_device_setup_link(struct media_device *mdev, void *arg)\n{\n\tstruct media_link_desc *linkd = arg;\n\tstruct media_link *link = NULL;\n\tstruct media_entity *source;\n\tstruct media_entity *sink;\n\n\t \n\tsource = find_entity(mdev, linkd->source.entity);\n\tsink = find_entity(mdev, linkd->sink.entity);\n\n\tif (source == NULL || sink == NULL)\n\t\treturn -EINVAL;\n\n\tif (linkd->source.index >= source->num_pads ||\n\t    linkd->sink.index >= sink->num_pads)\n\t\treturn -EINVAL;\n\n\tlink = media_entity_find_link(&source->pads[linkd->source.index],\n\t\t\t\t      &sink->pads[linkd->sink.index]);\n\tif (link == NULL)\n\t\treturn -EINVAL;\n\n\tmemset(linkd->reserved, 0, sizeof(linkd->reserved));\n\n\t \n\treturn __media_entity_setup_link(link, linkd->flags);\n}\n\nstatic long media_device_get_topology(struct media_device *mdev, void *arg)\n{\n\tstruct media_v2_topology *topo = arg;\n\tstruct media_entity *entity;\n\tstruct media_interface *intf;\n\tstruct media_pad *pad;\n\tstruct media_link *link;\n\tstruct media_v2_entity kentity, __user *uentity;\n\tstruct media_v2_interface kintf, __user *uintf;\n\tstruct media_v2_pad kpad, __user *upad;\n\tstruct media_v2_link klink, __user *ulink;\n\tunsigned int i;\n\tint ret = 0;\n\n\ttopo->topology_version = mdev->topology_version;\n\n\t \n\ti = 0;\n\tuentity = media_get_uptr(topo->ptr_entities);\n\tmedia_device_for_each_entity(entity, mdev) {\n\t\ti++;\n\t\tif (ret || !uentity)\n\t\t\tcontinue;\n\n\t\tif (i > topo->num_entities) {\n\t\t\tret = -ENOSPC;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmemset(&kentity, 0, sizeof(kentity));\n\t\tkentity.id = entity->graph_obj.id;\n\t\tkentity.function = entity->function;\n\t\tkentity.flags = entity->flags;\n\t\tstrscpy(kentity.name, entity->name,\n\t\t\tsizeof(kentity.name));\n\n\t\tif (copy_to_user(uentity, &kentity, sizeof(kentity)))\n\t\t\tret = -EFAULT;\n\t\tuentity++;\n\t}\n\ttopo->num_entities = i;\n\ttopo->reserved1 = 0;\n\n\t \n\ti = 0;\n\tuintf = media_get_uptr(topo->ptr_interfaces);\n\tmedia_device_for_each_intf(intf, mdev) {\n\t\ti++;\n\t\tif (ret || !uintf)\n\t\t\tcontinue;\n\n\t\tif (i > topo->num_interfaces) {\n\t\t\tret = -ENOSPC;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmemset(&kintf, 0, sizeof(kintf));\n\n\t\t \n\t\tkintf.id = intf->graph_obj.id;\n\t\tkintf.intf_type = intf->type;\n\t\tkintf.flags = intf->flags;\n\n\t\tif (media_type(&intf->graph_obj) == MEDIA_GRAPH_INTF_DEVNODE) {\n\t\t\tstruct media_intf_devnode *devnode;\n\n\t\t\tdevnode = intf_to_devnode(intf);\n\n\t\t\tkintf.devnode.major = devnode->major;\n\t\t\tkintf.devnode.minor = devnode->minor;\n\t\t}\n\n\t\tif (copy_to_user(uintf, &kintf, sizeof(kintf)))\n\t\t\tret = -EFAULT;\n\t\tuintf++;\n\t}\n\ttopo->num_interfaces = i;\n\ttopo->reserved2 = 0;\n\n\t \n\ti = 0;\n\tupad = media_get_uptr(topo->ptr_pads);\n\tmedia_device_for_each_pad(pad, mdev) {\n\t\ti++;\n\t\tif (ret || !upad)\n\t\t\tcontinue;\n\n\t\tif (i > topo->num_pads) {\n\t\t\tret = -ENOSPC;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmemset(&kpad, 0, sizeof(kpad));\n\n\t\t \n\t\tkpad.id = pad->graph_obj.id;\n\t\tkpad.entity_id = pad->entity->graph_obj.id;\n\t\tkpad.flags = pad->flags;\n\t\tkpad.index = pad->index;\n\n\t\tif (copy_to_user(upad, &kpad, sizeof(kpad)))\n\t\t\tret = -EFAULT;\n\t\tupad++;\n\t}\n\ttopo->num_pads = i;\n\ttopo->reserved3 = 0;\n\n\t \n\ti = 0;\n\tulink = media_get_uptr(topo->ptr_links);\n\tmedia_device_for_each_link(link, mdev) {\n\t\tif (link->is_backlink)\n\t\t\tcontinue;\n\n\t\ti++;\n\n\t\tif (ret || !ulink)\n\t\t\tcontinue;\n\n\t\tif (i > topo->num_links) {\n\t\t\tret = -ENOSPC;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmemset(&klink, 0, sizeof(klink));\n\n\t\t \n\t\tklink.id = link->graph_obj.id;\n\t\tklink.source_id = link->gobj0->id;\n\t\tklink.sink_id = link->gobj1->id;\n\t\tklink.flags = link->flags;\n\n\t\tif (copy_to_user(ulink, &klink, sizeof(klink)))\n\t\t\tret = -EFAULT;\n\t\tulink++;\n\t}\n\ttopo->num_links = i;\n\ttopo->reserved4 = 0;\n\n\treturn ret;\n}\n\nstatic long media_device_request_alloc(struct media_device *mdev, void *arg)\n{\n#ifdef CONFIG_MEDIA_CONTROLLER_REQUEST_API\n\tint *alloc_fd = arg;\n\n\tif (!mdev->ops || !mdev->ops->req_validate || !mdev->ops->req_queue)\n\t\treturn -ENOTTY;\n\n\treturn media_request_alloc(mdev, alloc_fd);\n#else\n\treturn -ENOTTY;\n#endif\n}\n\nstatic long copy_arg_from_user(void *karg, void __user *uarg, unsigned int cmd)\n{\n\tif ((_IOC_DIR(cmd) & _IOC_WRITE) &&\n\t    copy_from_user(karg, uarg, _IOC_SIZE(cmd)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long copy_arg_to_user(void __user *uarg, void *karg, unsigned int cmd)\n{\n\tif ((_IOC_DIR(cmd) & _IOC_READ) &&\n\t    copy_to_user(uarg, karg, _IOC_SIZE(cmd)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \n#define MEDIA_IOC_FL_GRAPH_MUTEX\tBIT(0)\n\n#define MEDIA_IOC_ARG(__cmd, func, fl, from_user, to_user)\t\t\\\n\t[_IOC_NR(MEDIA_IOC_##__cmd)] = {\t\t\t\t\\\n\t\t.cmd = MEDIA_IOC_##__cmd,\t\t\t\t\\\n\t\t.fn = func,\t\t\t\t\t\t\\\n\t\t.flags = fl,\t\t\t\t\t\t\\\n\t\t.arg_from_user = from_user,\t\t\t\t\\\n\t\t.arg_to_user = to_user,\t\t\t\t\t\\\n\t}\n\n#define MEDIA_IOC(__cmd, func, fl)\t\t\t\t\t\\\n\tMEDIA_IOC_ARG(__cmd, func, fl, copy_arg_from_user, copy_arg_to_user)\n\n \nstruct media_ioctl_info {\n\tunsigned int cmd;\n\tunsigned short flags;\n\tlong (*fn)(struct media_device *dev, void *arg);\n\tlong (*arg_from_user)(void *karg, void __user *uarg, unsigned int cmd);\n\tlong (*arg_to_user)(void __user *uarg, void *karg, unsigned int cmd);\n};\n\nstatic const struct media_ioctl_info ioctl_info[] = {\n\tMEDIA_IOC(DEVICE_INFO, media_device_get_info, MEDIA_IOC_FL_GRAPH_MUTEX),\n\tMEDIA_IOC(ENUM_ENTITIES, media_device_enum_entities, MEDIA_IOC_FL_GRAPH_MUTEX),\n\tMEDIA_IOC(ENUM_LINKS, media_device_enum_links, MEDIA_IOC_FL_GRAPH_MUTEX),\n\tMEDIA_IOC(SETUP_LINK, media_device_setup_link, MEDIA_IOC_FL_GRAPH_MUTEX),\n\tMEDIA_IOC(G_TOPOLOGY, media_device_get_topology, MEDIA_IOC_FL_GRAPH_MUTEX),\n\tMEDIA_IOC(REQUEST_ALLOC, media_device_request_alloc, 0),\n};\n\nstatic long media_device_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t       unsigned long __arg)\n{\n\tstruct media_devnode *devnode = media_devnode_data(filp);\n\tstruct media_device *dev = devnode->media_dev;\n\tconst struct media_ioctl_info *info;\n\tvoid __user *arg = (void __user *)__arg;\n\tchar __karg[256], *karg = __karg;\n\tlong ret;\n\n\tif (_IOC_NR(cmd) >= ARRAY_SIZE(ioctl_info)\n\t    || ioctl_info[_IOC_NR(cmd)].cmd != cmd)\n\t\treturn -ENOIOCTLCMD;\n\n\tinfo = &ioctl_info[_IOC_NR(cmd)];\n\n\tif (_IOC_SIZE(info->cmd) > sizeof(__karg)) {\n\t\tkarg = kmalloc(_IOC_SIZE(info->cmd), GFP_KERNEL);\n\t\tif (!karg)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (info->arg_from_user) {\n\t\tret = info->arg_from_user(karg, arg, cmd);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\tif (info->flags & MEDIA_IOC_FL_GRAPH_MUTEX)\n\t\tmutex_lock(&dev->graph_mutex);\n\n\tret = info->fn(dev, karg);\n\n\tif (info->flags & MEDIA_IOC_FL_GRAPH_MUTEX)\n\t\tmutex_unlock(&dev->graph_mutex);\n\n\tif (!ret && info->arg_to_user)\n\t\tret = info->arg_to_user(arg, karg, cmd);\n\nout_free:\n\tif (karg != __karg)\n\t\tkfree(karg);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\n\nstruct media_links_enum32 {\n\t__u32 entity;\n\tcompat_uptr_t pads;  \n\tcompat_uptr_t links;  \n\t__u32 reserved[4];\n};\n\nstatic long media_device_enum_links32(struct media_device *mdev,\n\t\t\t\t      struct media_links_enum32 __user *ulinks)\n{\n\tstruct media_links_enum links;\n\tcompat_uptr_t pads_ptr, links_ptr;\n\tint ret;\n\n\tmemset(&links, 0, sizeof(links));\n\n\tif (get_user(links.entity, &ulinks->entity)\n\t    || get_user(pads_ptr, &ulinks->pads)\n\t    || get_user(links_ptr, &ulinks->links))\n\t\treturn -EFAULT;\n\n\tlinks.pads = compat_ptr(pads_ptr);\n\tlinks.links = compat_ptr(links_ptr);\n\n\tret = media_device_enum_links(mdev, &links);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(ulinks->reserved, links.reserved,\n\t\t\t sizeof(ulinks->reserved)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n#define MEDIA_IOC_ENUM_LINKS32\t\t_IOWR('|', 0x02, struct media_links_enum32)\n\nstatic long media_device_compat_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t      unsigned long arg)\n{\n\tstruct media_devnode *devnode = media_devnode_data(filp);\n\tstruct media_device *dev = devnode->media_dev;\n\tlong ret;\n\n\tswitch (cmd) {\n\tcase MEDIA_IOC_ENUM_LINKS32:\n\t\tmutex_lock(&dev->graph_mutex);\n\t\tret = media_device_enum_links32(dev,\n\t\t\t\t(struct media_links_enum32 __user *)arg);\n\t\tmutex_unlock(&dev->graph_mutex);\n\t\tbreak;\n\n\tdefault:\n\t\treturn media_device_ioctl(filp, cmd, arg);\n\t}\n\n\treturn ret;\n}\n#endif  \n\nstatic const struct media_file_operations media_device_fops = {\n\t.owner = THIS_MODULE,\n\t.open = media_device_open,\n\t.ioctl = media_device_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = media_device_compat_ioctl,\n#endif  \n\t.release = media_device_close,\n};\n\n \n\nstatic ssize_t model_show(struct device *cd,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct media_devnode *devnode = to_media_devnode(cd);\n\tstruct media_device *mdev = devnode->media_dev;\n\n\treturn sprintf(buf, \"%.*s\\n\", (int)sizeof(mdev->model), mdev->model);\n}\n\nstatic DEVICE_ATTR_RO(model);\n\n \n\nstatic void media_device_release(struct media_devnode *devnode)\n{\n\tdev_dbg(devnode->parent, \"Media device released\\n\");\n}\n\nstatic void __media_device_unregister_entity(struct media_entity *entity)\n{\n\tstruct media_device *mdev = entity->graph_obj.mdev;\n\tstruct media_link *link, *tmp;\n\tstruct media_interface *intf;\n\tstruct media_pad *iter;\n\n\tida_free(&mdev->entity_internal_idx, entity->internal_idx);\n\n\t \n\tlist_for_each_entry(intf, &mdev->interfaces, graph_obj.list) {\n\t\tlist_for_each_entry_safe(link, tmp, &intf->links, list) {\n\t\t\tif (link->entity == entity)\n\t\t\t\t__media_remove_intf_link(link);\n\t\t}\n\t}\n\n\t \n\t__media_entity_remove_links(entity);\n\n\t \n\tmedia_entity_for_each_pad(entity, iter)\n\t\tmedia_gobj_destroy(&iter->graph_obj);\n\n\t \n\tmedia_gobj_destroy(&entity->graph_obj);\n\n\t \n}\n\nint __must_check media_device_register_entity(struct media_device *mdev,\n\t\t\t\t\t      struct media_entity *entity)\n{\n\tstruct media_entity_notify *notify, *next;\n\tstruct media_pad *iter;\n\tint ret;\n\n\tif (entity->function == MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN ||\n\t    entity->function == MEDIA_ENT_F_UNKNOWN)\n\t\tdev_warn(mdev->dev,\n\t\t\t \"Entity type for entity %s was not initialized!\\n\",\n\t\t\t entity->name);\n\n\t \n\tWARN_ON(entity->graph_obj.mdev != NULL);\n\tentity->graph_obj.mdev = mdev;\n\tINIT_LIST_HEAD(&entity->links);\n\tentity->num_links = 0;\n\tentity->num_backlinks = 0;\n\n\tret = ida_alloc_min(&mdev->entity_internal_idx, 1, GFP_KERNEL);\n\tif (ret < 0)\n\t\treturn ret;\n\tentity->internal_idx = ret;\n\n\tmutex_lock(&mdev->graph_mutex);\n\tmdev->entity_internal_idx_max =\n\t\tmax(mdev->entity_internal_idx_max, entity->internal_idx);\n\n\t \n\tmedia_gobj_create(mdev, MEDIA_GRAPH_ENTITY, &entity->graph_obj);\n\n\t \n\tmedia_entity_for_each_pad(entity, iter)\n\t\tmedia_gobj_create(mdev, MEDIA_GRAPH_PAD, &iter->graph_obj);\n\n\t \n\tlist_for_each_entry_safe(notify, next, &mdev->entity_notify, list)\n\t\tnotify->notify(entity, notify->notify_data);\n\n\tif (mdev->entity_internal_idx_max\n\t    >= mdev->pm_count_walk.ent_enum.idx_max) {\n\t\tstruct media_graph new = { .top = 0 };\n\n\t\t \n\t\tret = media_graph_walk_init(&new, mdev);\n\t\tif (ret) {\n\t\t\t__media_device_unregister_entity(entity);\n\t\t\tmutex_unlock(&mdev->graph_mutex);\n\t\t\treturn ret;\n\t\t}\n\t\tmedia_graph_walk_cleanup(&mdev->pm_count_walk);\n\t\tmdev->pm_count_walk = new;\n\t}\n\tmutex_unlock(&mdev->graph_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(media_device_register_entity);\n\nvoid media_device_unregister_entity(struct media_entity *entity)\n{\n\tstruct media_device *mdev = entity->graph_obj.mdev;\n\n\tif (mdev == NULL)\n\t\treturn;\n\n\tmutex_lock(&mdev->graph_mutex);\n\t__media_device_unregister_entity(entity);\n\tmutex_unlock(&mdev->graph_mutex);\n}\nEXPORT_SYMBOL_GPL(media_device_unregister_entity);\n\nvoid media_device_init(struct media_device *mdev)\n{\n\tINIT_LIST_HEAD(&mdev->entities);\n\tINIT_LIST_HEAD(&mdev->interfaces);\n\tINIT_LIST_HEAD(&mdev->pads);\n\tINIT_LIST_HEAD(&mdev->links);\n\tINIT_LIST_HEAD(&mdev->entity_notify);\n\n\tmutex_init(&mdev->req_queue_mutex);\n\tmutex_init(&mdev->graph_mutex);\n\tida_init(&mdev->entity_internal_idx);\n\n\tatomic_set(&mdev->request_id, 0);\n\n\tif (!*mdev->bus_info)\n\t\tmedia_set_bus_info(mdev->bus_info, sizeof(mdev->bus_info),\n\t\t\t\t   mdev->dev);\n\n\tdev_dbg(mdev->dev, \"Media device initialized\\n\");\n}\nEXPORT_SYMBOL_GPL(media_device_init);\n\nvoid media_device_cleanup(struct media_device *mdev)\n{\n\tida_destroy(&mdev->entity_internal_idx);\n\tmdev->entity_internal_idx_max = 0;\n\tmedia_graph_walk_cleanup(&mdev->pm_count_walk);\n\tmutex_destroy(&mdev->graph_mutex);\n\tmutex_destroy(&mdev->req_queue_mutex);\n}\nEXPORT_SYMBOL_GPL(media_device_cleanup);\n\nint __must_check __media_device_register(struct media_device *mdev,\n\t\t\t\t\t struct module *owner)\n{\n\tstruct media_devnode *devnode;\n\tint ret;\n\n\tdevnode = kzalloc(sizeof(*devnode), GFP_KERNEL);\n\tif (!devnode)\n\t\treturn -ENOMEM;\n\n\t \n\tmdev->devnode = devnode;\n\tdevnode->fops = &media_device_fops;\n\tdevnode->parent = mdev->dev;\n\tdevnode->release = media_device_release;\n\n\t \n\tmdev->topology_version = 0;\n\n\tret = media_devnode_register(mdev, devnode, owner);\n\tif (ret < 0) {\n\t\t \n\t\tmdev->devnode = NULL;\n\t\treturn ret;\n\t}\n\n\tret = device_create_file(&devnode->dev, &dev_attr_model);\n\tif (ret < 0) {\n\t\t \n\t\tmdev->devnode = NULL;\n\t\tmedia_devnode_unregister_prepare(devnode);\n\t\tmedia_devnode_unregister(devnode);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(mdev->dev, \"Media device registered\\n\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__media_device_register);\n\nvoid media_device_register_entity_notify(struct media_device *mdev,\n\t\t\t\t\tstruct media_entity_notify *nptr)\n{\n\tmutex_lock(&mdev->graph_mutex);\n\tlist_add_tail(&nptr->list, &mdev->entity_notify);\n\tmutex_unlock(&mdev->graph_mutex);\n}\nEXPORT_SYMBOL_GPL(media_device_register_entity_notify);\n\n \nstatic void __media_device_unregister_entity_notify(struct media_device *mdev,\n\t\t\t\t\tstruct media_entity_notify *nptr)\n{\n\tlist_del(&nptr->list);\n}\n\nvoid media_device_unregister_entity_notify(struct media_device *mdev,\n\t\t\t\t\tstruct media_entity_notify *nptr)\n{\n\tmutex_lock(&mdev->graph_mutex);\n\t__media_device_unregister_entity_notify(mdev, nptr);\n\tmutex_unlock(&mdev->graph_mutex);\n}\nEXPORT_SYMBOL_GPL(media_device_unregister_entity_notify);\n\nvoid media_device_unregister(struct media_device *mdev)\n{\n\tstruct media_entity *entity;\n\tstruct media_entity *next;\n\tstruct media_interface *intf, *tmp_intf;\n\tstruct media_entity_notify *notify, *nextp;\n\n\tif (mdev == NULL)\n\t\treturn;\n\n\tmutex_lock(&mdev->graph_mutex);\n\n\t \n\tif (!media_devnode_is_registered(mdev->devnode)) {\n\t\tmutex_unlock(&mdev->graph_mutex);\n\t\treturn;\n\t}\n\n\t \n\tmedia_devnode_unregister_prepare(mdev->devnode);\n\n\t \n\tlist_for_each_entry_safe(entity, next, &mdev->entities, graph_obj.list)\n\t\t__media_device_unregister_entity(entity);\n\n\t \n\tlist_for_each_entry_safe(notify, nextp, &mdev->entity_notify, list)\n\t\t__media_device_unregister_entity_notify(mdev, notify);\n\n\t \n\tlist_for_each_entry_safe(intf, tmp_intf, &mdev->interfaces,\n\t\t\t\t graph_obj.list) {\n\t\t \n\t\t__media_remove_intf_links(intf);\n\t\tmedia_gobj_destroy(&intf->graph_obj);\n\t}\n\n\tmutex_unlock(&mdev->graph_mutex);\n\n\tdev_dbg(mdev->dev, \"Media device unregistered\\n\");\n\n\tdevice_remove_file(&mdev->devnode->dev, &dev_attr_model);\n\tmedia_devnode_unregister(mdev->devnode);\n\t \n\tmdev->devnode = NULL;\n}\nEXPORT_SYMBOL_GPL(media_device_unregister);\n\n#if IS_ENABLED(CONFIG_PCI)\nvoid media_device_pci_init(struct media_device *mdev,\n\t\t\t   struct pci_dev *pci_dev,\n\t\t\t   const char *name)\n{\n\tmdev->dev = &pci_dev->dev;\n\n\tif (name)\n\t\tstrscpy(mdev->model, name, sizeof(mdev->model));\n\telse\n\t\tstrscpy(mdev->model, pci_name(pci_dev), sizeof(mdev->model));\n\n\tsprintf(mdev->bus_info, \"PCI:%s\", pci_name(pci_dev));\n\n\tmdev->hw_revision = (pci_dev->subsystem_vendor << 16)\n\t\t\t    | pci_dev->subsystem_device;\n\n\tmedia_device_init(mdev);\n}\nEXPORT_SYMBOL_GPL(media_device_pci_init);\n#endif\n\n#if IS_ENABLED(CONFIG_USB)\nvoid __media_device_usb_init(struct media_device *mdev,\n\t\t\t     struct usb_device *udev,\n\t\t\t     const char *board_name,\n\t\t\t     const char *driver_name)\n{\n\tmdev->dev = &udev->dev;\n\n\tif (driver_name)\n\t\tstrscpy(mdev->driver_name, driver_name,\n\t\t\tsizeof(mdev->driver_name));\n\n\tif (board_name)\n\t\tstrscpy(mdev->model, board_name, sizeof(mdev->model));\n\telse if (udev->product)\n\t\tstrscpy(mdev->model, udev->product, sizeof(mdev->model));\n\telse\n\t\tstrscpy(mdev->model, \"unknown model\", sizeof(mdev->model));\n\tif (udev->serial)\n\t\tstrscpy(mdev->serial, udev->serial, sizeof(mdev->serial));\n\tusb_make_path(udev, mdev->bus_info, sizeof(mdev->bus_info));\n\tmdev->hw_revision = le16_to_cpu(udev->descriptor.bcdDevice);\n\n\tmedia_device_init(mdev);\n}\nEXPORT_SYMBOL_GPL(__media_device_usb_init);\n#endif\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}