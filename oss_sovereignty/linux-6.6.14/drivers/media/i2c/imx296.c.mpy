{
  "module_name": "imx296.c",
  "hash_id": "cb5cbea8c8234c232dd030a14ed5d4e5fcb40790aa2b90a1c695c30ce9265536",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/imx296.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n#define IMX296_PIXEL_ARRAY_WIDTH\t\t\t1456\n#define IMX296_PIXEL_ARRAY_HEIGHT\t\t\t1088\n\n#define IMX296_REG_8BIT(n)\t\t\t\t((1 << 16) | (n))\n#define IMX296_REG_16BIT(n)\t\t\t\t((2 << 16) | (n))\n#define IMX296_REG_24BIT(n)\t\t\t\t((3 << 16) | (n))\n#define IMX296_REG_SIZE_SHIFT\t\t\t\t16\n#define IMX296_REG_ADDR_MASK\t\t\t\t0xffff\n\n#define IMX296_CTRL00\t\t\t\t\tIMX296_REG_8BIT(0x3000)\n#define IMX296_CTRL00_STANDBY\t\t\t\tBIT(0)\n#define IMX296_CTRL08\t\t\t\t\tIMX296_REG_8BIT(0x3008)\n#define IMX296_CTRL08_REGHOLD\t\t\t\tBIT(0)\n#define IMX296_CTRL0A\t\t\t\t\tIMX296_REG_8BIT(0x300a)\n#define IMX296_CTRL0A_XMSTA\t\t\t\tBIT(0)\n#define IMX296_CTRL0B\t\t\t\t\tIMX296_REG_8BIT(0x300b)\n#define IMX296_CTRL0B_TRIGEN\t\t\t\tBIT(0)\n#define IMX296_CTRL0D\t\t\t\t\tIMX296_REG_8BIT(0x300d)\n#define IMX296_CTRL0D_WINMODE_ALL\t\t\t(0 << 0)\n#define IMX296_CTRL0D_WINMODE_FD_BINNING\t\t(2 << 0)\n#define IMX296_CTRL0D_HADD_ON_BINNING\t\t\tBIT(5)\n#define IMX296_CTRL0D_SAT_CNT\t\t\t\tBIT(6)\n#define IMX296_CTRL0E\t\t\t\t\tIMX296_REG_8BIT(0x300e)\n#define IMX296_CTRL0E_VREVERSE\t\t\t\tBIT(0)\n#define IMX296_CTRL0E_HREVERSE\t\t\t\tBIT(1)\n#define IMX296_VMAX\t\t\t\t\tIMX296_REG_24BIT(0x3010)\n#define IMX296_HMAX\t\t\t\t\tIMX296_REG_16BIT(0x3014)\n#define IMX296_TMDCTRL\t\t\t\t\tIMX296_REG_8BIT(0x301d)\n#define IMX296_TMDCTRL_LATCH\t\t\t\tBIT(0)\n#define IMX296_TMDOUT\t\t\t\t\tIMX296_REG_16BIT(0x301e)\n#define IMX296_TMDOUT_MASK\t\t\t\t0x3ff\n#define IMX296_WDSEL\t\t\t\t\tIMX296_REG_8BIT(0x3021)\n#define IMX296_WDSEL_NORMAL\t\t\t\t(0 << 0)\n#define IMX296_WDSEL_MULTI_2\t\t\t\t(1 << 0)\n#define IMX296_WDSEL_MULTI_4\t\t\t\t(3 << 0)\n#define IMX296_BLKLEVELAUTO\t\t\t\tIMX296_REG_8BIT(0x3022)\n#define IMX296_BLKLEVELAUTO_ON\t\t\t\t0x01\n#define IMX296_BLKLEVELAUTO_OFF\t\t\t\t0xf0\n#define IMX296_SST\t\t\t\t\tIMX296_REG_8BIT(0x3024)\n#define IMX296_SST_EN\t\t\t\t\tBIT(0)\n#define IMX296_CTRLTOUT\t\t\t\t\tIMX296_REG_8BIT(0x3026)\n#define IMX296_CTRLTOUT_TOUT1SEL_LOW\t\t\t(0 << 0)\n#define IMX296_CTRLTOUT_TOUT1SEL_PULSE\t\t\t(3 << 0)\n#define IMX296_CTRLTOUT_TOUT2SEL_LOW\t\t\t(0 << 2)\n#define IMX296_CTRLTOUT_TOUT2SEL_PULSE\t\t\t(3 << 2)\n#define IMX296_CTRLTRIG\t\t\t\t\tIMX296_REG_8BIT(0x3029)\n#define IMX296_CTRLTRIG_TOUT1_SEL_LOW\t\t\t(0 << 0)\n#define IMX296_CTRLTRIG_TOUT1_SEL_PULSE1\t\t(1 << 0)\n#define IMX296_CTRLTRIG_TOUT2_SEL_LOW\t\t\t(0 << 4)\n#define IMX296_CTRLTRIG_TOUT2_SEL_PULSE2\t\t(2 << 4)\n#define IMX296_SYNCSEL\t\t\t\t\tIMX296_REG_8BIT(0x3036)\n#define IMX296_SYNCSEL_NORMAL\t\t\t\t0xc0\n#define IMX296_SYNCSEL_HIZ\t\t\t\t0xf0\n#define IMX296_PULSE1\t\t\t\t\tIMX296_REG_8BIT(0x306d)\n#define IMX296_PULSE1_EN_NOR\t\t\t\tBIT(0)\n#define IMX296_PULSE1_EN_TRIG\t\t\t\tBIT(1)\n#define IMX296_PULSE1_POL_HIGH\t\t\t\t(0 << 2)\n#define IMX296_PULSE1_POL_LOW\t\t\t\t(1 << 2)\n#define IMX296_PULSE1_UP\t\t\t\tIMX296_REG_24BIT(0x3070)\n#define IMX296_PULSE1_DN\t\t\t\tIMX296_REG_24BIT(0x3074)\n#define IMX296_PULSE2\t\t\t\t\tIMX296_REG_8BIT(0x3079)\n#define IMX296_PULSE2_EN_NOR\t\t\t\tBIT(0)\n#define IMX296_PULSE2_EN_TRIG\t\t\t\tBIT(1)\n#define IMX296_PULSE2_POL_HIGH\t\t\t\t(0 << 2)\n#define IMX296_PULSE2_POL_LOW\t\t\t\t(1 << 2)\n#define IMX296_PULSE2_UP\t\t\t\tIMX296_REG_24BIT(0x307c)\n#define IMX296_PULSE2_DN\t\t\t\tIMX296_REG_24BIT(0x3080)\n#define IMX296_INCKSEL(n)\t\t\t\tIMX296_REG_8BIT(0x3089 + (n))\n#define IMX296_SHS1\t\t\t\t\tIMX296_REG_24BIT(0x308d)\n#define IMX296_SHS2\t\t\t\t\tIMX296_REG_24BIT(0x3090)\n#define IMX296_SHS3\t\t\t\t\tIMX296_REG_24BIT(0x3094)\n#define IMX296_SHS4\t\t\t\t\tIMX296_REG_24BIT(0x3098)\n#define IMX296_VBLANKLP\t\t\t\t\tIMX296_REG_8BIT(0x309c)\n#define IMX296_VBLANKLP_NORMAL\t\t\t\t0x04\n#define IMX296_VBLANKLP_LOW_POWER\t\t\t0x2c\n#define IMX296_EXP_CNT\t\t\t\t\tIMX296_REG_8BIT(0x30a3)\n#define IMX296_EXP_CNT_RESET\t\t\t\tBIT(0)\n#define IMX296_EXP_MAX\t\t\t\t\tIMX296_REG_16BIT(0x30a6)\n#define IMX296_VINT\t\t\t\t\tIMX296_REG_8BIT(0x30aa)\n#define IMX296_VINT_EN\t\t\t\t\tBIT(0)\n#define IMX296_LOWLAGTRG\t\t\t\tIMX296_REG_8BIT(0x30ae)\n#define IMX296_LOWLAGTRG_FAST\t\t\t\tBIT(0)\n#define IMX296_I2CCTRL\t\t\t\t\tIMX296_REG_8BIT(0x30ef)\n#define IMX296_I2CCTRL_I2CACKEN\t\t\t\tBIT(0)\n\n#define IMX296_SENSOR_INFO\t\t\t\tIMX296_REG_16BIT(0x3148)\n#define IMX296_SENSOR_INFO_MONO\t\t\t\tBIT(15)\n#define IMX296_SENSOR_INFO_IMX296LQ\t\t\t0x4a00\n#define IMX296_SENSOR_INFO_IMX296LL\t\t\t0xca00\n#define IMX296_S_SHSA\t\t\t\t\tIMX296_REG_16BIT(0x31ca)\n#define IMX296_S_SHSB\t\t\t\t\tIMX296_REG_16BIT(0x31d2)\n \n\n#define IMX296_GAINCTRL\t\t\t\t\tIMX296_REG_8BIT(0x3200)\n#define IMX296_GAINCTRL_WD_GAIN_MODE_NORMAL\t\t0x01\n#define IMX296_GAINCTRL_WD_GAIN_MODE_MULTI\t\t0x41\n#define IMX296_GAIN\t\t\t\t\tIMX296_REG_16BIT(0x3204)\n#define IMX296_GAIN_MIN\t\t\t\t\t0\n#define IMX296_GAIN_MAX\t\t\t\t\t480\n#define IMX296_GAIN1\t\t\t\t\tIMX296_REG_16BIT(0x3208)\n#define IMX296_GAIN2\t\t\t\t\tIMX296_REG_16BIT(0x320c)\n#define IMX296_GAIN3\t\t\t\t\tIMX296_REG_16BIT(0x3210)\n#define IMX296_GAINDLY\t\t\t\t\tIMX296_REG_8BIT(0x3212)\n#define IMX296_GAINDLY_NONE\t\t\t\t0x08\n#define IMX296_GAINDLY_1FRAME\t\t\t\t0x09\n#define IMX296_PGCTRL\t\t\t\t\tIMX296_REG_8BIT(0x3238)\n#define IMX296_PGCTRL_REGEN\t\t\t\tBIT(0)\n#define IMX296_PGCTRL_THRU\t\t\t\tBIT(1)\n#define IMX296_PGCTRL_CLKEN\t\t\t\tBIT(2)\n#define IMX296_PGCTRL_MODE(n)\t\t\t\t((n) << 3)\n#define IMX296_PGHPOS\t\t\t\t\tIMX296_REG_16BIT(0x3239)\n#define IMX296_PGVPOS\t\t\t\t\tIMX296_REG_16BIT(0x323c)\n#define IMX296_PGHPSTEP\t\t\t\t\tIMX296_REG_8BIT(0x323e)\n#define IMX296_PGVPSTEP\t\t\t\t\tIMX296_REG_8BIT(0x323f)\n#define IMX296_PGHPNUM\t\t\t\t\tIMX296_REG_8BIT(0x3240)\n#define IMX296_PGVPNUM\t\t\t\t\tIMX296_REG_8BIT(0x3241)\n#define IMX296_PGDATA1\t\t\t\t\tIMX296_REG_16BIT(0x3244)\n#define IMX296_PGDATA2\t\t\t\t\tIMX296_REG_16BIT(0x3246)\n#define IMX296_PGHGSTEP\t\t\t\t\tIMX296_REG_8BIT(0x3249)\n#define IMX296_BLKLEVEL\t\t\t\t\tIMX296_REG_16BIT(0x3254)\n\n#define IMX296_FID0_ROI\t\t\t\t\tIMX296_REG_8BIT(0x3300)\n#define IMX296_FID0_ROIH1ON\t\t\t\tBIT(0)\n#define IMX296_FID0_ROIV1ON\t\t\t\tBIT(1)\n#define IMX296_FID0_ROIPH1\t\t\t\tIMX296_REG_16BIT(0x3310)\n#define IMX296_FID0_ROIPV1\t\t\t\tIMX296_REG_16BIT(0x3312)\n#define IMX296_FID0_ROIWH1\t\t\t\tIMX296_REG_16BIT(0x3314)\n#define IMX296_FID0_ROIWH1_MIN\t\t\t\t80\n#define IMX296_FID0_ROIWV1\t\t\t\tIMX296_REG_16BIT(0x3316)\n#define IMX296_FID0_ROIWV1_MIN\t\t\t\t4\n\n#define IMX296_CM_HSST_STARTTMG\t\t\t\tIMX296_REG_16BIT(0x4018)\n#define IMX296_CM_HSST_ENDTMG\t\t\t\tIMX296_REG_16BIT(0x401a)\n#define IMX296_DA_HSST_STARTTMG\t\t\t\tIMX296_REG_16BIT(0x404d)\n#define IMX296_DA_HSST_ENDTMG\t\t\t\tIMX296_REG_16BIT(0x4050)\n#define IMX296_LM_HSST_STARTTMG\t\t\t\tIMX296_REG_16BIT(0x4094)\n#define IMX296_LM_HSST_ENDTMG\t\t\t\tIMX296_REG_16BIT(0x4096)\n#define IMX296_SST_SIEASTA1_SET\t\t\t\tIMX296_REG_8BIT(0x40c9)\n#define IMX296_SST_SIEASTA1PRE_1U\t\t\tIMX296_REG_16BIT(0x40cc)\n#define IMX296_SST_SIEASTA1PRE_1D\t\t\tIMX296_REG_16BIT(0x40ce)\n#define IMX296_SST_SIEASTA1PRE_2U\t\t\tIMX296_REG_16BIT(0x40d0)\n#define IMX296_SST_SIEASTA1PRE_2D\t\t\tIMX296_REG_16BIT(0x40d2)\n#define IMX296_HSST\t\t\t\t\tIMX296_REG_8BIT(0x40dc)\n#define IMX296_HSST_EN\t\t\t\t\tBIT(2)\n\n#define IMX296_CKREQSEL\t\t\t\t\tIMX296_REG_8BIT(0x4101)\n#define IMX296_CKREQSEL_HS\t\t\t\tBIT(2)\n#define IMX296_GTTABLENUM\t\t\t\tIMX296_REG_8BIT(0x4114)\n#define IMX296_CTRL418C\t\t\t\t\tIMX296_REG_8BIT(0x418c)\n\nstruct imx296_clk_params {\n\tunsigned int freq;\n\tu8 incksel[4];\n\tu8 ctrl418c;\n};\n\nstatic const struct imx296_clk_params imx296_clk_params[] = {\n\t{ 37125000, { 0x80, 0x0b, 0x80, 0x08 }, 116 },\n\t{ 54000000, { 0xb0, 0x0f, 0xb0, 0x0c }, 168 },\n\t{ 74250000, { 0x80, 0x0f, 0x80, 0x0c }, 232 },\n};\n\nstatic const char * const imx296_supply_names[] = {\n\t\"dvdd\",\n\t\"ovdd\",\n\t\"avdd\",\n};\n\nstruct imx296 {\n\tstruct device *dev;\n\tstruct clk *clk;\n\tstruct regulator_bulk_data supplies[ARRAY_SIZE(imx296_supply_names)];\n\tstruct gpio_desc *reset;\n\tstruct regmap *regmap;\n\n\tconst struct imx296_clk_params *clk_params;\n\tbool mono;\n\n\tbool streaming;\n\n\tstruct v4l2_subdev subdev;\n\tstruct media_pad pad;\n\n\tstruct v4l2_ctrl_handler ctrls;\n\tstruct v4l2_ctrl *hblank;\n\tstruct v4l2_ctrl *vblank;\n};\n\nstatic inline struct imx296 *to_imx296(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct imx296, subdev);\n}\n\nstatic int imx296_read(struct imx296 *sensor, u32 addr)\n{\n\tu8 data[3] = { 0, 0, 0 };\n\tint ret;\n\n\tret = regmap_raw_read(sensor->regmap, addr & IMX296_REG_ADDR_MASK, data,\n\t\t\t      (addr >> IMX296_REG_SIZE_SHIFT) & 3);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (data[2] << 16) | (data[1] << 8) | data[0];\n}\n\nstatic int imx296_write(struct imx296 *sensor, u32 addr, u32 value, int *err)\n{\n\tu8 data[3] = { value & 0xff, (value >> 8) & 0xff, value >> 16 };\n\tint ret;\n\n\tif (err && *err)\n\t\treturn *err;\n\n\tret = regmap_raw_write(sensor->regmap, addr & IMX296_REG_ADDR_MASK,\n\t\t\t       data, (addr >> IMX296_REG_SIZE_SHIFT) & 3);\n\tif (ret < 0) {\n\t\tdev_err(sensor->dev, \"%u-bit write to 0x%04x failed: %d\\n\",\n\t\t\t((addr >> IMX296_REG_SIZE_SHIFT) & 3) * 8,\n\t\t\taddr & IMX296_REG_ADDR_MASK, ret);\n\t\tif (err)\n\t\t\t*err = ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int imx296_power_on(struct imx296 *sensor)\n{\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(sensor->supplies),\n\t\t\t\t    sensor->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tudelay(1);\n\n\tret = gpiod_direction_output(sensor->reset, 0);\n\tif (ret < 0)\n\t\tgoto err_supply;\n\n\tudelay(1);\n\n\tret = clk_prepare_enable(sensor->clk);\n\tif (ret < 0)\n\t\tgoto err_reset;\n\n\t \n\tusleep_range(1000, 2000);\n\n\treturn 0;\n\nerr_reset:\n\tgpiod_direction_output(sensor->reset, 1);\nerr_supply:\n\tregulator_bulk_disable(ARRAY_SIZE(sensor->supplies), sensor->supplies);\n\treturn ret;\n}\n\nstatic void imx296_power_off(struct imx296 *sensor)\n{\n\tclk_disable_unprepare(sensor->clk);\n\tgpiod_direction_output(sensor->reset, 1);\n\tregulator_bulk_disable(ARRAY_SIZE(sensor->supplies), sensor->supplies);\n}\n\n \n\nstatic const char * const imx296_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Multiple Pixels\",\n\t\"Sequence 1\",\n\t\"Sequence 2\",\n\t\"Gradient\",\n\t\"Row\",\n\t\"Column\",\n\t\"Cross\",\n\t\"Stripe\",\n\t\"Checks\",\n};\n\nstatic int imx296_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct imx296 *sensor = container_of(ctrl->handler, struct imx296, ctrls);\n\tconst struct v4l2_mbus_framefmt *format;\n\tstruct v4l2_subdev_state *state;\n\tunsigned int vmax;\n\tint ret = 0;\n\n\tif (!sensor->streaming)\n\t\treturn 0;\n\n\tstate = v4l2_subdev_get_locked_active_state(&sensor->subdev);\n\tformat = v4l2_subdev_get_pad_format(&sensor->subdev, state, 0);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE:\n\t\t \n\t\tvmax = format->height + sensor->vblank->cur.val;\n\t\tctrl->val = min_t(int, ctrl->val, vmax);\n\t\timx296_write(sensor, IMX296_SHS1, vmax - ctrl->val, &ret);\n\t\tbreak;\n\n\tcase V4L2_CID_ANALOGUE_GAIN:\n\t\timx296_write(sensor, IMX296_GAIN, ctrl->val, &ret);\n\t\tbreak;\n\n\tcase V4L2_CID_VBLANK:\n\t\timx296_write(sensor, IMX296_VMAX, format->height + ctrl->val,\n\t\t\t     &ret);\n\t\tbreak;\n\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tif (ctrl->val) {\n\t\t\timx296_write(sensor, IMX296_PGHPOS, 8, &ret);\n\t\t\timx296_write(sensor, IMX296_PGVPOS, 8, &ret);\n\t\t\timx296_write(sensor, IMX296_PGHPSTEP, 8, &ret);\n\t\t\timx296_write(sensor, IMX296_PGVPSTEP, 8, &ret);\n\t\t\timx296_write(sensor, IMX296_PGHPNUM, 100, &ret);\n\t\t\timx296_write(sensor, IMX296_PGVPNUM, 100, &ret);\n\t\t\timx296_write(sensor, IMX296_PGDATA1, 0x300, &ret);\n\t\t\timx296_write(sensor, IMX296_PGDATA2, 0x100, &ret);\n\t\t\timx296_write(sensor, IMX296_PGHGSTEP, 0, &ret);\n\t\t\timx296_write(sensor, IMX296_BLKLEVEL, 0, &ret);\n\t\t\timx296_write(sensor, IMX296_BLKLEVELAUTO,\n\t\t\t\t     IMX296_BLKLEVELAUTO_OFF, &ret);\n\t\t\timx296_write(sensor, IMX296_PGCTRL,\n\t\t\t\t     IMX296_PGCTRL_REGEN |\n\t\t\t\t     IMX296_PGCTRL_CLKEN |\n\t\t\t\t     IMX296_PGCTRL_MODE(ctrl->val - 1), &ret);\n\t\t} else {\n\t\t\timx296_write(sensor, IMX296_PGCTRL,\n\t\t\t\t     IMX296_PGCTRL_CLKEN, &ret);\n\t\t\timx296_write(sensor, IMX296_BLKLEVEL, 0x3c, &ret);\n\t\t\timx296_write(sensor, IMX296_BLKLEVELAUTO,\n\t\t\t\t     IMX296_BLKLEVELAUTO_ON, &ret);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops imx296_ctrl_ops = {\n\t.s_ctrl = imx296_s_ctrl,\n};\n\nstatic int imx296_ctrls_init(struct imx296 *sensor)\n{\n\tstruct v4l2_fwnode_device_properties props;\n\tunsigned int hblank;\n\tint ret;\n\n\tret = v4l2_fwnode_device_parse(sensor->dev, &props);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv4l2_ctrl_handler_init(&sensor->ctrls, 9);\n\n\tv4l2_ctrl_new_std(&sensor->ctrls, &imx296_ctrl_ops,\n\t\t\t  V4L2_CID_EXPOSURE, 1, 1048575, 1, 1104);\n\tv4l2_ctrl_new_std(&sensor->ctrls, &imx296_ctrl_ops,\n\t\t\t  V4L2_CID_ANALOGUE_GAIN, IMX296_GAIN_MIN,\n\t\t\t  IMX296_GAIN_MAX, 1, IMX296_GAIN_MIN);\n\n\t \n\thblank = 1100 * 1188000000ULL / 10 / 74250000\n\t       - IMX296_PIXEL_ARRAY_WIDTH;\n\tsensor->hblank = v4l2_ctrl_new_std(&sensor->ctrls, &imx296_ctrl_ops,\n\t\t\t\t\t   V4L2_CID_HBLANK, hblank, hblank, 1,\n\t\t\t\t\t   hblank);\n\tif (sensor->hblank)\n\t\tsensor->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tsensor->vblank = v4l2_ctrl_new_std(&sensor->ctrls, &imx296_ctrl_ops,\n\t\t\t\t\t   V4L2_CID_VBLANK, 30,\n\t\t\t\t\t   1048575 - IMX296_PIXEL_ARRAY_HEIGHT,\n\t\t\t\t\t   1, 30);\n\t \n\tv4l2_ctrl_new_std(&sensor->ctrls, NULL, V4L2_CID_PIXEL_RATE,\n\t\t\t  1122000000 / 10, 1198000000 / 10, 1, 1188000000 / 10);\n\tv4l2_ctrl_new_std_menu_items(&sensor->ctrls, &imx296_ctrl_ops,\n\t\t\t\t     V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(imx296_test_pattern_menu) - 1,\n\t\t\t\t     0, 0, imx296_test_pattern_menu);\n\n\tv4l2_ctrl_new_fwnode_properties(&sensor->ctrls, &imx296_ctrl_ops,\n\t\t\t\t\t&props);\n\n\tif (sensor->ctrls.error) {\n\t\tdev_err(sensor->dev, \"failed to add controls (%d)\\n\",\n\t\t\tsensor->ctrls.error);\n\t\tv4l2_ctrl_handler_free(&sensor->ctrls);\n\t\treturn sensor->ctrls.error;\n\t}\n\n\tsensor->subdev.ctrl_handler = &sensor->ctrls;\n\n\treturn 0;\n}\n\n \n\n \nstatic const struct {\n\tunsigned int reg;\n\tunsigned int value;\n} imx296_init_table[] = {\n\t{ IMX296_REG_8BIT(0x3005), 0xf0 },\n\t{ IMX296_REG_8BIT(0x309e), 0x04 },\n\t{ IMX296_REG_8BIT(0x30a0), 0x04 },\n\t{ IMX296_REG_8BIT(0x30a1), 0x3c },\n\t{ IMX296_REG_8BIT(0x30a4), 0x5f },\n\t{ IMX296_REG_8BIT(0x30a8), 0x91 },\n\t{ IMX296_REG_8BIT(0x30ac), 0x28 },\n\t{ IMX296_REG_8BIT(0x30af), 0x09 },\n\t{ IMX296_REG_8BIT(0x30df), 0x00 },\n\t{ IMX296_REG_8BIT(0x3165), 0x00 },\n\t{ IMX296_REG_8BIT(0x3169), 0x10 },\n\t{ IMX296_REG_8BIT(0x316a), 0x02 },\n\t{ IMX296_REG_8BIT(0x31c8), 0xf3 },\t \n\t{ IMX296_REG_8BIT(0x31d0), 0xf4 },\t \n\t{ IMX296_REG_8BIT(0x321a), 0x00 },\n\t{ IMX296_REG_8BIT(0x3226), 0x02 },\n\t{ IMX296_REG_8BIT(0x3256), 0x01 },\n\t{ IMX296_REG_8BIT(0x3541), 0x72 },\n\t{ IMX296_REG_8BIT(0x3516), 0x77 },\n\t{ IMX296_REG_8BIT(0x350b), 0x7f },\n\t{ IMX296_REG_8BIT(0x3758), 0xa3 },\n\t{ IMX296_REG_8BIT(0x3759), 0x00 },\n\t{ IMX296_REG_8BIT(0x375a), 0x85 },\n\t{ IMX296_REG_8BIT(0x375b), 0x00 },\n\t{ IMX296_REG_8BIT(0x3832), 0xf5 },\n\t{ IMX296_REG_8BIT(0x3833), 0x00 },\n\t{ IMX296_REG_8BIT(0x38a2), 0xf6 },\n\t{ IMX296_REG_8BIT(0x38a3), 0x00 },\n\t{ IMX296_REG_8BIT(0x3a00), 0x80 },\n\t{ IMX296_REG_8BIT(0x3d48), 0xa3 },\n\t{ IMX296_REG_8BIT(0x3d49), 0x00 },\n\t{ IMX296_REG_8BIT(0x3d4a), 0x85 },\n\t{ IMX296_REG_8BIT(0x3d4b), 0x00 },\n\t{ IMX296_REG_8BIT(0x400e), 0x58 },\n\t{ IMX296_REG_8BIT(0x4014), 0x1c },\n\t{ IMX296_REG_8BIT(0x4041), 0x2a },\n\t{ IMX296_REG_8BIT(0x40a2), 0x06 },\n\t{ IMX296_REG_8BIT(0x40c1), 0xf6 },\n\t{ IMX296_REG_8BIT(0x40c7), 0x0f },\n\t{ IMX296_REG_8BIT(0x40c8), 0x00 },\n\t{ IMX296_REG_8BIT(0x4174), 0x00 },\n};\n\nstatic int imx296_setup(struct imx296 *sensor, struct v4l2_subdev_state *state)\n{\n\tconst struct v4l2_mbus_framefmt *format;\n\tconst struct v4l2_rect *crop;\n\tunsigned int i;\n\tint ret = 0;\n\n\tformat = v4l2_subdev_get_pad_format(&sensor->subdev, state, 0);\n\tcrop = v4l2_subdev_get_pad_crop(&sensor->subdev, state, 0);\n\n\tfor (i = 0; i < ARRAY_SIZE(imx296_init_table); ++i)\n\t\timx296_write(sensor, imx296_init_table[i].reg,\n\t\t\t     imx296_init_table[i].value, &ret);\n\n\tif (crop->width != IMX296_PIXEL_ARRAY_WIDTH ||\n\t    crop->height != IMX296_PIXEL_ARRAY_HEIGHT) {\n\t\timx296_write(sensor, IMX296_FID0_ROI,\n\t\t\t     IMX296_FID0_ROIH1ON | IMX296_FID0_ROIV1ON, &ret);\n\t\timx296_write(sensor, IMX296_FID0_ROIPH1, crop->left, &ret);\n\t\timx296_write(sensor, IMX296_FID0_ROIPV1, crop->top, &ret);\n\t\timx296_write(sensor, IMX296_FID0_ROIWH1, crop->width, &ret);\n\t\timx296_write(sensor, IMX296_FID0_ROIWV1, crop->height, &ret);\n\t} else {\n\t\timx296_write(sensor, IMX296_FID0_ROI, 0, &ret);\n\t}\n\n\timx296_write(sensor, IMX296_CTRL0D,\n\t\t     (crop->width != format->width ?\n\t\t      IMX296_CTRL0D_HADD_ON_BINNING : 0) |\n\t\t     (crop->height != format->height ?\n\t\t      IMX296_CTRL0D_WINMODE_FD_BINNING : 0),\n\t\t     &ret);\n\n\t \n\timx296_write(sensor, IMX296_HMAX, 1100, &ret);\n\timx296_write(sensor, IMX296_VMAX,\n\t\t     format->height + sensor->vblank->cur.val, &ret);\n\n\tfor (i = 0; i < ARRAY_SIZE(sensor->clk_params->incksel); ++i)\n\t\timx296_write(sensor, IMX296_INCKSEL(i),\n\t\t\t     sensor->clk_params->incksel[i], &ret);\n\timx296_write(sensor, IMX296_GTTABLENUM, 0xc5, &ret);\n\timx296_write(sensor, IMX296_CTRL418C, sensor->clk_params->ctrl418c,\n\t\t     &ret);\n\n\timx296_write(sensor, IMX296_GAINDLY, IMX296_GAINDLY_NONE, &ret);\n\timx296_write(sensor, IMX296_BLKLEVEL, 0x03c, &ret);\n\n\treturn ret;\n}\n\nstatic int imx296_stream_on(struct imx296 *sensor)\n{\n\tint ret = 0;\n\n\timx296_write(sensor, IMX296_CTRL00, 0, &ret);\n\tusleep_range(2000, 5000);\n\timx296_write(sensor, IMX296_CTRL0A, 0, &ret);\n\n\treturn ret;\n}\n\nstatic int imx296_stream_off(struct imx296 *sensor)\n{\n\tint ret = 0;\n\n\timx296_write(sensor, IMX296_CTRL0A, IMX296_CTRL0A_XMSTA, &ret);\n\timx296_write(sensor, IMX296_CTRL00, IMX296_CTRL00_STANDBY, &ret);\n\n\treturn ret;\n}\n\nstatic int imx296_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct imx296 *sensor = to_imx296(sd);\n\tstruct v4l2_subdev_state *state;\n\tint ret;\n\n\tstate = v4l2_subdev_lock_and_get_active_state(sd);\n\n\tif (!enable) {\n\t\tret = imx296_stream_off(sensor);\n\n\t\tpm_runtime_mark_last_busy(sensor->dev);\n\t\tpm_runtime_put_autosuspend(sensor->dev);\n\n\t\tsensor->streaming = false;\n\n\t\tgoto unlock;\n\t}\n\n\tret = pm_runtime_resume_and_get(sensor->dev);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tret = imx296_setup(sensor, state);\n\tif (ret < 0)\n\t\tgoto err_pm;\n\n\t \n\tsensor->streaming = true;\n\n\tret = __v4l2_ctrl_handler_setup(&sensor->ctrls);\n\tif (ret < 0)\n\t\tgoto err_pm;\n\n\tret = imx296_stream_on(sensor);\n\tif (ret)\n\t\tgoto err_pm;\n\nunlock:\n\tv4l2_subdev_unlock_state(state);\n\n\treturn ret;\n\nerr_pm:\n\t \n\tpm_runtime_put_sync(sensor->dev);\n\tsensor->streaming = false;\n\n\tgoto unlock;\n}\n\nstatic int imx296_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct imx296 *sensor = to_imx296(sd);\n\n\tif (code->index != 0)\n\t\treturn -EINVAL;\n\n\tcode->code = sensor->mono ? MEDIA_BUS_FMT_Y10_1X10\n\t\t   : MEDIA_BUS_FMT_SBGGR10_1X10;\n\n\treturn 0;\n}\n\nstatic int imx296_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tconst struct v4l2_mbus_framefmt *format;\n\n\tformat = v4l2_subdev_get_pad_format(sd, state, fse->pad);\n\n\tif (fse->index >= 2 || fse->code != format->code)\n\t\treturn -EINVAL;\n\n\tfse->min_width = IMX296_PIXEL_ARRAY_WIDTH / (fse->index + 1);\n\tfse->max_width = fse->min_width;\n\tfse->min_height = IMX296_PIXEL_ARRAY_HEIGHT / (fse->index + 1);\n\tfse->max_height = fse->min_height;\n\n\treturn 0;\n}\n\nstatic int imx296_set_format(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *state,\n\t\t\t     struct v4l2_subdev_format *fmt)\n{\n\tstruct imx296 *sensor = to_imx296(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct v4l2_rect *crop;\n\n\tcrop = v4l2_subdev_get_pad_crop(sd, state, fmt->pad);\n\tformat = v4l2_subdev_get_pad_format(sd, state, fmt->pad);\n\n\t \n\tif (crop->width == IMX296_PIXEL_ARRAY_WIDTH &&\n\t    crop->height == IMX296_PIXEL_ARRAY_HEIGHT) {\n\t\tunsigned int width;\n\t\tunsigned int height;\n\t\tunsigned int hratio;\n\t\tunsigned int vratio;\n\n\t\t \n\t\twidth = clamp_t(unsigned int, fmt->format.width,\n\t\t\t\tcrop->width / 2, crop->width);\n\t\theight = clamp_t(unsigned int, fmt->format.height,\n\t\t\t\t crop->height / 2, crop->height);\n\n\t\thratio = DIV_ROUND_CLOSEST(crop->width, width);\n\t\tvratio = DIV_ROUND_CLOSEST(crop->height, height);\n\n\t\tformat->width = crop->width / hratio;\n\t\tformat->height = crop->height / vratio;\n\t} else {\n\t\tformat->width = crop->width;\n\t\tformat->height = crop->height;\n\t}\n\n\tformat->code = sensor->mono ? MEDIA_BUS_FMT_Y10_1X10\n\t\t     : MEDIA_BUS_FMT_SBGGR10_1X10;\n\tformat->field = V4L2_FIELD_NONE;\n\tformat->colorspace = V4L2_COLORSPACE_RAW;\n\tformat->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tformat->quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\tformat->xfer_func = V4L2_XFER_FUNC_NONE;\n\n\tfmt->format = *format;\n\n\treturn 0;\n}\n\nstatic int imx296_get_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = *v4l2_subdev_get_pad_crop(sd, state, sel->pad);\n\t\tbreak;\n\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_NATIVE_SIZE:\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = IMX296_PIXEL_ARRAY_WIDTH;\n\t\tsel->r.height = IMX296_PIXEL_ARRAY_HEIGHT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int imx296_set_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct v4l2_rect *crop;\n\tstruct v4l2_rect rect;\n\n\tif (sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\t \n\trect.left = clamp(ALIGN(sel->r.left, 4), 0,\n\t\t\t  IMX296_PIXEL_ARRAY_WIDTH - IMX296_FID0_ROIWH1_MIN);\n\trect.top = clamp(ALIGN(sel->r.top, 4), 0,\n\t\t\t IMX296_PIXEL_ARRAY_HEIGHT - IMX296_FID0_ROIWV1_MIN);\n\trect.width = clamp_t(unsigned int, ALIGN(sel->r.width, 4),\n\t\t\t     IMX296_FID0_ROIWH1_MIN, IMX296_PIXEL_ARRAY_WIDTH);\n\trect.height = clamp_t(unsigned int, ALIGN(sel->r.height, 4),\n\t\t\t      IMX296_FID0_ROIWV1_MIN, IMX296_PIXEL_ARRAY_HEIGHT);\n\n\trect.width = min_t(unsigned int, rect.width,\n\t\t\t   IMX296_PIXEL_ARRAY_WIDTH - rect.left);\n\trect.height = min_t(unsigned int, rect.height,\n\t\t\t    IMX296_PIXEL_ARRAY_HEIGHT - rect.top);\n\n\tcrop = v4l2_subdev_get_pad_crop(sd, state, sel->pad);\n\n\tif (rect.width != crop->width || rect.height != crop->height) {\n\t\t \n\t\tformat = v4l2_subdev_get_pad_format(sd, state, sel->pad);\n\t\tformat->width = rect.width;\n\t\tformat->height = rect.height;\n\t}\n\n\t*crop = rect;\n\tsel->r = rect;\n\n\treturn 0;\n}\n\nstatic int imx296_init_cfg(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *state)\n{\n\tstruct v4l2_subdev_selection sel = {\n\t\t.target = V4L2_SEL_TGT_CROP,\n\t\t.r.width = IMX296_PIXEL_ARRAY_WIDTH,\n\t\t.r.height = IMX296_PIXEL_ARRAY_HEIGHT,\n\t};\n\tstruct v4l2_subdev_format format = {\n\t\t.format = {\n\t\t\t.width = IMX296_PIXEL_ARRAY_WIDTH,\n\t\t\t.height = IMX296_PIXEL_ARRAY_HEIGHT,\n\t\t},\n\t};\n\n\timx296_set_selection(sd, state, &sel);\n\timx296_set_format(sd, state, &format);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops imx296_subdev_video_ops = {\n\t.s_stream = imx296_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops imx296_subdev_pad_ops = {\n\t.enum_mbus_code = imx296_enum_mbus_code,\n\t.enum_frame_size = imx296_enum_frame_size,\n\t.get_fmt = v4l2_subdev_get_fmt,\n\t.set_fmt = imx296_set_format,\n\t.get_selection = imx296_get_selection,\n\t.set_selection = imx296_set_selection,\n\t.init_cfg = imx296_init_cfg,\n};\n\nstatic const struct v4l2_subdev_ops imx296_subdev_ops = {\n\t.video = &imx296_subdev_video_ops,\n\t.pad = &imx296_subdev_pad_ops,\n};\n\nstatic int imx296_subdev_init(struct imx296 *sensor)\n{\n\tstruct i2c_client *client = to_i2c_client(sensor->dev);\n\tint ret;\n\n\tv4l2_i2c_subdev_init(&sensor->subdev, client, &imx296_subdev_ops);\n\n\tret = imx296_ctrls_init(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsensor->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsensor->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tsensor->subdev.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tret = media_entity_pads_init(&sensor->subdev.entity, 1, &sensor->pad);\n\tif (ret < 0) {\n\t\tv4l2_ctrl_handler_free(&sensor->ctrls);\n\t\treturn ret;\n\t}\n\n\tsensor->subdev.state_lock = sensor->subdev.ctrl_handler->lock;\n\n\tv4l2_subdev_init_finalize(&sensor->subdev);\n\n\treturn ret;\n}\n\nstatic void imx296_subdev_cleanup(struct imx296 *sensor)\n{\n\tmedia_entity_cleanup(&sensor->subdev.entity);\n\tv4l2_ctrl_handler_free(&sensor->ctrls);\n}\n\n \n\nstatic int __maybe_unused imx296_runtime_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct imx296 *sensor = to_imx296(subdev);\n\n\treturn imx296_power_on(sensor);\n}\n\nstatic int __maybe_unused imx296_runtime_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct imx296 *sensor = to_imx296(subdev);\n\n\timx296_power_off(sensor);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops imx296_pm_ops = {\n\tSET_RUNTIME_PM_OPS(imx296_runtime_suspend, imx296_runtime_resume, NULL)\n};\n\n \n\nstatic int imx296_read_temperature(struct imx296 *sensor, int *temp)\n{\n\tint tmdout;\n\tint ret;\n\n\tret = imx296_write(sensor, IMX296_TMDCTRL, IMX296_TMDCTRL_LATCH, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttmdout = imx296_read(sensor, IMX296_TMDOUT);\n\tif (tmdout < 0)\n\t\treturn tmdout;\n\n\ttmdout &= IMX296_TMDOUT_MASK;\n\n\t ;\n\t*temp = 246312 - 304 * tmdout;\n\n\treturn imx296_write(sensor, IMX296_TMDCTRL, 0, NULL);\n}\n\nstatic int imx296_identify_model(struct imx296 *sensor)\n{\n\tunsigned int model;\n\tint temp = 0;\n\tint ret;\n\n\tmodel = (uintptr_t)of_device_get_match_data(sensor->dev);\n\tif (model) {\n\t\tdev_dbg(sensor->dev,\n\t\t\t\"sensor model auto-detection disabled, forcing 0x%04x\\n\",\n\t\t\tmodel);\n\t\tsensor->mono = model & IMX296_SENSOR_INFO_MONO;\n\t\treturn 0;\n\t}\n\n\t \n\tret = imx296_write(sensor, IMX296_CTRL00, 0, NULL);\n\tif (ret < 0) {\n\t\tdev_err(sensor->dev,\n\t\t\t\"failed to get sensor out of standby (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = imx296_read(sensor, IMX296_SENSOR_INFO);\n\tif (ret < 0) {\n\t\tdev_err(sensor->dev, \"failed to read sensor information (%d)\\n\",\n\t\t\tret);\n\t\tgoto done;\n\t}\n\n\tmodel = (ret >> 6) & 0x1ff;\n\n\tswitch (model) {\n\tcase 296:\n\t\tsensor->mono = ret & IMX296_SENSOR_INFO_MONO;\n\t\tbreak;\n\t \n\tcase 297:\n\tdefault:\n\t\tdev_err(sensor->dev, \"invalid device model 0x%04x\\n\", ret);\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tret = imx296_read_temperature(sensor, &temp);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tdev_info(sensor->dev, \"found IMX%u%s (%u.%uC)\\n\", model,\n\t\t sensor->mono ? \"LL\" : \"LQ\", temp / 1000, (temp / 100) % 10);\n\ndone:\n\timx296_write(sensor, IMX296_CTRL00, IMX296_CTRL00_STANDBY, NULL);\n\treturn ret;\n}\n\nstatic const struct regmap_config imx296_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\n\t.wr_table = &(const struct regmap_access_table) {\n\t\t.no_ranges = (const struct regmap_range[]) {\n\t\t\t{\n\t\t\t\t.range_min = IMX296_SENSOR_INFO & 0xffff,\n\t\t\t\t.range_max = (IMX296_SENSOR_INFO & 0xffff) + 1,\n\t\t\t},\n\t\t},\n\t\t.n_no_ranges = 1,\n\t},\n};\n\nstatic int imx296_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\n\tunsigned long clk_rate;\n\tstruct imx296 *sensor;\n\tunsigned int i;\n\tint ret;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_warn(&adapter->dev,\n\t\t\t \"I2C-Adapter doesn't support I2C_FUNC_SMBUS_BYTE\\n\");\n\t\treturn -EIO;\n\t}\n\n\tsensor = devm_kzalloc(&client->dev, sizeof(*sensor), GFP_KERNEL);\n\tif (!sensor)\n\t\treturn -ENOMEM;\n\n\tsensor->dev = &client->dev;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(sensor->supplies); ++i)\n\t\tsensor->supplies[i].supply = imx296_supply_names[i];\n\n\tret = devm_regulator_bulk_get(sensor->dev, ARRAY_SIZE(sensor->supplies),\n\t\t\t\t      sensor->supplies);\n\tif (ret) {\n\t\tdev_err_probe(sensor->dev, ret, \"failed to get supplies\\n\");\n\t\treturn ret;\n\t}\n\n\tsensor->reset = devm_gpiod_get_optional(sensor->dev, \"reset\",\n\t\t\t\t\t\tGPIOD_OUT_HIGH);\n\tif (IS_ERR(sensor->reset))\n\t\treturn dev_err_probe(sensor->dev, PTR_ERR(sensor->reset),\n\t\t\t\t     \"failed to get reset GPIO\\n\");\n\n\tsensor->clk = devm_clk_get(sensor->dev, \"inck\");\n\tif (IS_ERR(sensor->clk))\n\t\treturn dev_err_probe(sensor->dev, PTR_ERR(sensor->clk),\n\t\t\t\t     \"failed to get clock\\n\");\n\n\tclk_rate = clk_get_rate(sensor->clk);\n\tfor (i = 0; i < ARRAY_SIZE(imx296_clk_params); ++i) {\n\t\tif (clk_rate == imx296_clk_params[i].freq) {\n\t\t\tsensor->clk_params = &imx296_clk_params[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!sensor->clk_params) {\n\t\tdev_err(sensor->dev, \"unsupported clock rate %lu\\n\", clk_rate);\n\t\treturn -EINVAL;\n\t}\n\n\tsensor->regmap = devm_regmap_init_i2c(client, &imx296_regmap_config);\n\tif (IS_ERR(sensor->regmap))\n\t\treturn PTR_ERR(sensor->regmap);\n\n\t \n\tret = imx296_power_on(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = imx296_identify_model(sensor);\n\tif (ret < 0)\n\t\tgoto err_power;\n\n\t \n\tret = imx296_subdev_init(sensor);\n\tif (ret < 0)\n\t\tgoto err_power;\n\n\t \n\tpm_runtime_set_active(sensor->dev);\n\tpm_runtime_get_noresume(sensor->dev);\n\tpm_runtime_enable(sensor->dev);\n\n\t \n\tret = v4l2_async_register_subdev(&sensor->subdev);\n\tif (ret < 0)\n\t\tgoto err_pm;\n\n\t \n\tpm_runtime_set_autosuspend_delay(sensor->dev, 1000);\n\tpm_runtime_use_autosuspend(sensor->dev);\n\tpm_runtime_put_autosuspend(sensor->dev);\n\n\treturn 0;\n\nerr_pm:\n\tpm_runtime_disable(sensor->dev);\n\tpm_runtime_put_noidle(sensor->dev);\n\timx296_subdev_cleanup(sensor);\nerr_power:\n\timx296_power_off(sensor);\n\treturn ret;\n}\n\nstatic void imx296_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct imx296 *sensor = to_imx296(subdev);\n\n\tv4l2_async_unregister_subdev(subdev);\n\n\timx296_subdev_cleanup(sensor);\n\n\t \n\tpm_runtime_disable(sensor->dev);\n\tif (!pm_runtime_status_suspended(sensor->dev))\n\t\timx296_power_off(sensor);\n\tpm_runtime_set_suspended(sensor->dev);\n}\n\nstatic const struct of_device_id imx296_of_match[] = {\n\t{ .compatible = \"sony,imx296\", .data = NULL },\n\t{ .compatible = \"sony,imx296ll\", .data = (void *)IMX296_SENSOR_INFO_IMX296LL },\n\t{ .compatible = \"sony,imx296lq\", .data = (void *)IMX296_SENSOR_INFO_IMX296LQ },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, imx296_of_match);\n\nstatic struct i2c_driver imx296_i2c_driver = {\n\t.driver = {\n\t\t.of_match_table = imx296_of_match,\n\t\t.name = \"imx296\",\n\t\t.pm = &imx296_pm_ops\n\t},\n\t.probe = imx296_probe,\n\t.remove = imx296_remove,\n};\n\nmodule_i2c_driver(imx296_i2c_driver);\n\nMODULE_DESCRIPTION(\"Sony IMX296 Camera driver\");\nMODULE_AUTHOR(\"Laurent Pinchart <laurent.pinchart@ideasonboard.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}