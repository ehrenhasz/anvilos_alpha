{
  "module_name": "adv7170.c",
  "hash_id": "4e2c2da15c5b47b38c7d1fd4e5aa52554768641c8fc6c8ffb55cfd9db8894a01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/adv7170.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/ioctl.h>\n#include <linux/uaccess.h>\n#include <linux/i2c.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n\nMODULE_DESCRIPTION(\"Analog Devices ADV7170 video encoder driver\");\nMODULE_AUTHOR(\"Maxim Yevtyushkin\");\nMODULE_LICENSE(\"GPL\");\n\n\nstatic int debug;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"Debug level (0-1)\");\n\n \n\nstruct adv7170 {\n\tstruct v4l2_subdev sd;\n\tunsigned char reg[128];\n\n\tv4l2_std_id norm;\n\tint input;\n};\n\nstatic inline struct adv7170 *to_adv7170(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct adv7170, sd);\n}\n\nstatic char *inputs[] = { \"pass_through\", \"play_back\" };\n\nstatic u32 adv7170_codes[] = {\n\tMEDIA_BUS_FMT_UYVY8_2X8,\n\tMEDIA_BUS_FMT_UYVY8_1X16,\n};\n\n \n\nstatic inline int adv7170_write(struct v4l2_subdev *sd, u8 reg, u8 value)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct adv7170 *encoder = to_adv7170(sd);\n\n\tencoder->reg[reg] = value;\n\treturn i2c_smbus_write_byte_data(client, reg, value);\n}\n\nstatic inline int adv7170_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\nstatic int adv7170_write_block(struct v4l2_subdev *sd,\n\t\t     const u8 *data, unsigned int len)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct adv7170 *encoder = to_adv7170(sd);\n\tint ret = -1;\n\tu8 reg;\n\n\t \n\tif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\t \n\t\tu8 block_data[32];\n\t\tint block_len;\n\n\t\twhile (len >= 2) {\n\t\t\tblock_len = 0;\n\t\t\tblock_data[block_len++] = reg = data[0];\n\t\t\tdo {\n\t\t\t\tblock_data[block_len++] =\n\t\t\t\t    encoder->reg[reg++] = data[1];\n\t\t\t\tlen -= 2;\n\t\t\t\tdata += 2;\n\t\t\t} while (len >= 2 && data[0] == reg && block_len < 32);\n\t\t\tret = i2c_master_send(client, block_data, block_len);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\twhile (len >= 2) {\n\t\t\treg = *data++;\n\t\t\tret = adv7170_write(sd, reg, *data++);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tlen -= 2;\n\t\t}\n\t}\n\treturn ret;\n}\n\n \n\n#define TR0MODE     0x4c\n#define TR0RST\t    0x80\n\n#define TR1CAPT\t    0x00\n#define TR1PLAY\t    0x00\n\nstatic const unsigned char init_NTSC[] = {\n\t0x00, 0x10,\t\t \n\t0x01, 0x20,\t\t \n\t0x02, 0x0e,\t\t \n\t0x03, 0x80,\t\t \n\t0x04, 0x30,\t\t \n\t0x05, 0x00,\t\t \n\t0x06, 0x00,\t\t \n\t0x07, TR0MODE,\t\t \n\t0x08, TR1CAPT,\t\t \n\t0x09, 0x16,\t\t \n\t0x0a, 0x7c,\t\t \n\t0x0b, 0xf0,\t\t \n\t0x0c, 0x21,\t\t \n\t0x0d, 0x00,\t\t \n\t0x0e, 0x00,\t\t \n\t0x0f, 0x00,\t\t \n\t0x10, 0x00,\t\t \n\t0x11, 0x00,\t\t \n\t0x12, 0x00,\t\t \n\t0x13, 0x00,\t\t \n\t0x14, 0x00,\t\t \n\t0x15, 0x00,\t\t \n\t0x16, 0x00,\t\t \n\t0x17, 0x00,\t\t \n\t0x18, 0x00,\t\t \n\t0x19, 0x00,\t\t \n};\n\nstatic const unsigned char init_PAL[] = {\n\t0x00, 0x71,\t\t \n\t0x01, 0x20,\t\t \n\t0x02, 0x0e,\t\t \n\t0x03, 0x80,\t\t \n\t0x04, 0x30,\t\t \n\t0x05, 0x00,\t\t \n\t0x06, 0x00,\t\t \n\t0x07, TR0MODE,\t\t \n\t0x08, TR1CAPT,\t\t \n\t0x09, 0xcb,\t\t \n\t0x0a, 0x8a,\t\t \n\t0x0b, 0x09,\t\t \n\t0x0c, 0x2a,\t\t \n\t0x0d, 0x00,\t\t \n\t0x0e, 0x00,\t\t \n\t0x0f, 0x00,\t\t \n\t0x10, 0x00,\t\t \n\t0x11, 0x00,\t\t \n\t0x12, 0x00,\t\t \n\t0x13, 0x00,\t\t \n\t0x14, 0x00,\t\t \n\t0x15, 0x00,\t\t \n\t0x16, 0x00,\t\t \n\t0x17, 0x00,\t\t \n\t0x18, 0x00,\t\t \n\t0x19, 0x00,\t\t \n};\n\n\nstatic int adv7170_s_std_output(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct adv7170 *encoder = to_adv7170(sd);\n\n\tv4l2_dbg(1, debug, sd, \"set norm %llx\\n\", (unsigned long long)std);\n\n\tif (std & V4L2_STD_NTSC) {\n\t\tadv7170_write_block(sd, init_NTSC, sizeof(init_NTSC));\n\t\tif (encoder->input == 0)\n\t\t\tadv7170_write(sd, 0x02, 0x0e);\t \n\t\tadv7170_write(sd, 0x07, TR0MODE | TR0RST);\n\t\tadv7170_write(sd, 0x07, TR0MODE);\n\t} else if (std & V4L2_STD_PAL) {\n\t\tadv7170_write_block(sd, init_PAL, sizeof(init_PAL));\n\t\tif (encoder->input == 0)\n\t\t\tadv7170_write(sd, 0x02, 0x0e);\t \n\t\tadv7170_write(sd, 0x07, TR0MODE | TR0RST);\n\t\tadv7170_write(sd, 0x07, TR0MODE);\n\t} else {\n\t\tv4l2_dbg(1, debug, sd, \"illegal norm: %llx\\n\",\n\t\t\t\t(unsigned long long)std);\n\t\treturn -EINVAL;\n\t}\n\tv4l2_dbg(1, debug, sd, \"switched to %llx\\n\", (unsigned long long)std);\n\tencoder->norm = std;\n\treturn 0;\n}\n\nstatic int adv7170_s_routing(struct v4l2_subdev *sd,\n\t\t\t     u32 input, u32 output, u32 config)\n{\n\tstruct adv7170 *encoder = to_adv7170(sd);\n\n\t \n\n\tv4l2_dbg(1, debug, sd, \"set input from %s\\n\",\n\t\t\tinput == 0 ? \"decoder\" : \"ZR36060\");\n\n\tswitch (input) {\n\tcase 0:\n\t\tadv7170_write(sd, 0x01, 0x20);\n\t\tadv7170_write(sd, 0x08, TR1CAPT);\t \n\t\tadv7170_write(sd, 0x02, 0x0e);\t \n\t\tadv7170_write(sd, 0x07, TR0MODE | TR0RST);\n\t\tadv7170_write(sd, 0x07, TR0MODE);\n\t\t \n\t\tbreak;\n\n\tcase 1:\n\t\tadv7170_write(sd, 0x01, 0x00);\n\t\tadv7170_write(sd, 0x08, TR1PLAY);\t \n\t\tadv7170_write(sd, 0x02, 0x08);\n\t\tadv7170_write(sd, 0x07, TR0MODE | TR0RST);\n\t\tadv7170_write(sd, 0x07, TR0MODE);\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tv4l2_dbg(1, debug, sd, \"illegal input: %d\\n\", input);\n\t\treturn -EINVAL;\n\t}\n\tv4l2_dbg(1, debug, sd, \"switched to %s\\n\", inputs[input]);\n\tencoder->input = input;\n\treturn 0;\n}\n\nstatic int adv7170_enum_mbus_code(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index >= ARRAY_SIZE(adv7170_codes))\n\t\treturn -EINVAL;\n\n\tcode->code = adv7170_codes[code->index];\n\treturn 0;\n}\n\nstatic int adv7170_get_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tu8 val = adv7170_read(sd, 0x7);\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tif ((val & 0x40) == (1 << 6))\n\t\tmf->code = MEDIA_BUS_FMT_UYVY8_1X16;\n\telse\n\t\tmf->code = MEDIA_BUS_FMT_UYVY8_2X8;\n\n\tmf->colorspace  = V4L2_COLORSPACE_SMPTE170M;\n\tmf->width       = 0;\n\tmf->height      = 0;\n\tmf->field       = V4L2_FIELD_ANY;\n\n\treturn 0;\n}\n\nstatic int adv7170_set_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tu8 val = adv7170_read(sd, 0x7);\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tswitch (mf->code) {\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\t\tval &= ~0x40;\n\t\tbreak;\n\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\t\tval |= 0x40;\n\t\tbreak;\n\n\tdefault:\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t\"illegal v4l2_mbus_framefmt code: %d\\n\", mf->code);\n\t\treturn -EINVAL;\n\t}\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn adv7170_write(sd, 0x7, val);\n\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_subdev_video_ops adv7170_video_ops = {\n\t.s_std_output = adv7170_s_std_output,\n\t.s_routing = adv7170_s_routing,\n};\n\nstatic const struct v4l2_subdev_pad_ops adv7170_pad_ops = {\n\t.enum_mbus_code = adv7170_enum_mbus_code,\n\t.get_fmt = adv7170_get_fmt,\n\t.set_fmt = adv7170_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops adv7170_ops = {\n\t.video = &adv7170_video_ops,\n\t.pad = &adv7170_pad_ops,\n};\n\n \n\nstatic int adv7170_probe(struct i2c_client *client)\n{\n\tstruct adv7170 *encoder;\n\tstruct v4l2_subdev *sd;\n\tint i;\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tv4l_info(client, \"chip found @ 0x%x (%s)\\n\",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tencoder = devm_kzalloc(&client->dev, sizeof(*encoder), GFP_KERNEL);\n\tif (encoder == NULL)\n\t\treturn -ENOMEM;\n\tsd = &encoder->sd;\n\tv4l2_i2c_subdev_init(sd, client, &adv7170_ops);\n\tencoder->norm = V4L2_STD_NTSC;\n\tencoder->input = 0;\n\n\ti = adv7170_write_block(sd, init_NTSC, sizeof(init_NTSC));\n\tif (i >= 0) {\n\t\ti = adv7170_write(sd, 0x07, TR0MODE | TR0RST);\n\t\ti = adv7170_write(sd, 0x07, TR0MODE);\n\t\ti = adv7170_read(sd, 0x12);\n\t\tv4l2_dbg(1, debug, sd, \"revision %d\\n\", i & 1);\n\t}\n\tif (i < 0)\n\t\tv4l2_dbg(1, debug, sd, \"init error 0x%x\\n\", i);\n\treturn 0;\n}\n\nstatic void adv7170_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\n\tv4l2_device_unregister_subdev(sd);\n}\n\n \n\nstatic const struct i2c_device_id adv7170_id[] = {\n\t{ \"adv7170\", 0 },\n\t{ \"adv7171\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adv7170_id);\n\nstatic struct i2c_driver adv7170_driver = {\n\t.driver = {\n\t\t.name\t= \"adv7170\",\n\t},\n\t.probe\t\t= adv7170_probe,\n\t.remove\t\t= adv7170_remove,\n\t.id_table\t= adv7170_id,\n};\n\nmodule_i2c_driver(adv7170_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}