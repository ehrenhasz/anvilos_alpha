{
  "module_name": "tvp5150.c",
  "hash_id": "11d864721d3f386ea96552daa37f8bd8aec92caaccac3cff7b77fed2956cd5a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/tvp5150.c",
  "human_readable_source": "\n\n\n\n\n\n#include <dt-bindings/media/tvp5150.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <media/v4l2-async.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-mc.h>\n#include <media/v4l2-rect.h>\n\n#include \"tvp5150_reg.h\"\n\n#define TVP5150_H_MAX\t\t720U\n#define TVP5150_V_MAX_525_60\t480U\n#define TVP5150_V_MAX_OTHERS\t576U\n#define TVP5150_MAX_CROP_LEFT\t511\n#define TVP5150_MAX_CROP_TOP\t127\n#define TVP5150_CROP_SHIFT\t2\n#define TVP5150_MBUS_FMT\tMEDIA_BUS_FMT_UYVY8_2X8\n#define TVP5150_FIELD\t\tV4L2_FIELD_ALTERNATE\n#define TVP5150_COLORSPACE\tV4L2_COLORSPACE_SMPTE170M\n#define TVP5150_STD_MASK\t(V4L2_STD_NTSC     | \\\n\t\t\t\t V4L2_STD_NTSC_443 | \\\n\t\t\t\t V4L2_STD_PAL      | \\\n\t\t\t\t V4L2_STD_PAL_M    | \\\n\t\t\t\t V4L2_STD_PAL_N    | \\\n\t\t\t\t V4L2_STD_PAL_Nc   | \\\n\t\t\t\t V4L2_STD_SECAM)\n\n#define TVP5150_MAX_CONNECTORS\t3  \n\nMODULE_DESCRIPTION(\"Texas Instruments TVP5150A/TVP5150AM1/TVP5151 video decoder driver\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab\");\nMODULE_LICENSE(\"GPL v2\");\n\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Debug level (0-2)\");\n\n#define dprintk0(__dev, __arg...) dev_dbg_lvl(__dev, 0, 0, __arg)\n\nenum tvp5150_pads {\n\tTVP5150_PAD_AIP1A,\n\tTVP5150_PAD_AIP1B,\n\tTVP5150_PAD_VID_OUT,\n\tTVP5150_NUM_PADS\n};\n\nstruct tvp5150_connector {\n\tstruct v4l2_fwnode_connector base;\n\tstruct media_entity ent;\n\tstruct media_pad pad;\n};\n\nstruct tvp5150 {\n\tstruct v4l2_subdev sd;\n\n\tstruct media_pad pads[TVP5150_NUM_PADS];\n\tstruct tvp5150_connector connectors[TVP5150_MAX_CONNECTORS];\n\tstruct tvp5150_connector *cur_connector;\n\tunsigned int connectors_num;\n\n\tstruct v4l2_ctrl_handler hdl;\n\tstruct v4l2_rect rect;\n\tstruct regmap *regmap;\n\tint irq;\n\n\tv4l2_std_id norm;\t \n\tv4l2_std_id detected_norm;\n\tu32 input;\n\tu32 output;\n\tu32 oe;\n\tint enable;\n\tbool lock;\n\n\tu16 dev_id;\n\tu16 rom_ver;\n\n\tenum v4l2_mbus_type mbus_type;\n};\n\nstatic inline struct tvp5150 *to_tvp5150(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct tvp5150, sd);\n}\n\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct tvp5150, hdl)->sd;\n}\n\nstatic int tvp5150_read(struct v4l2_subdev *sd, unsigned char addr)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\tint ret, val;\n\n\tret = regmap_read(decoder->regmap, addr, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn val;\n}\n\nstatic void dump_reg_range(struct v4l2_subdev *sd, char *s, u8 init,\n\t\t\t\tconst u8 end, int max_line)\n{\n\tu8 buf[16];\n\tint i = 0, j, len;\n\n\tif (max_line > 16) {\n\t\tdprintk0(sd->dev, \"too much data to dump\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = init; i < end; i += max_line) {\n\t\tlen = (end - i > max_line) ? max_line : end - i;\n\n\t\tfor (j = 0; j < len; j++)\n\t\t\tbuf[j] = tvp5150_read(sd, i + j);\n\n\t\tdprintk0(sd->dev, \"%s reg %02x = %*ph\\n\", s, i, len, buf);\n\t}\n}\n\nstatic int tvp5150_log_status(struct v4l2_subdev *sd)\n{\n\tdprintk0(sd->dev, \"tvp5150: Video input source selection #1 = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_VD_IN_SRC_SEL_1));\n\tdprintk0(sd->dev, \"tvp5150: Analog channel controls = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_ANAL_CHL_CTL));\n\tdprintk0(sd->dev, \"tvp5150: Operation mode controls = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_OP_MODE_CTL));\n\tdprintk0(sd->dev, \"tvp5150: Miscellaneous controls = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_MISC_CTL));\n\tdprintk0(sd->dev, \"tvp5150: Autoswitch mask= 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_AUTOSW_MSK));\n\tdprintk0(sd->dev, \"tvp5150: Color killer threshold control = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_COLOR_KIL_THSH_CTL));\n\tdprintk0(sd->dev, \"tvp5150: Luminance processing controls #1 #2 and #3 = %02x %02x %02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_LUMA_PROC_CTL_1),\n\t\ttvp5150_read(sd, TVP5150_LUMA_PROC_CTL_2),\n\t\ttvp5150_read(sd, TVP5150_LUMA_PROC_CTL_3));\n\tdprintk0(sd->dev, \"tvp5150: Brightness control = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_BRIGHT_CTL));\n\tdprintk0(sd->dev, \"tvp5150: Color saturation control = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_SATURATION_CTL));\n\tdprintk0(sd->dev, \"tvp5150: Hue control = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_HUE_CTL));\n\tdprintk0(sd->dev, \"tvp5150: Contrast control = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_CONTRAST_CTL));\n\tdprintk0(sd->dev, \"tvp5150: Outputs and data rates select = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_DATA_RATE_SEL));\n\tdprintk0(sd->dev, \"tvp5150: Configuration shared pins = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_CONF_SHARED_PIN));\n\tdprintk0(sd->dev, \"tvp5150: Active video cropping start = 0x%02x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_ACT_VD_CROP_ST_MSB),\n\t\ttvp5150_read(sd, TVP5150_ACT_VD_CROP_ST_LSB));\n\tdprintk0(sd->dev, \"tvp5150: Active video cropping stop  = 0x%02x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_ACT_VD_CROP_STP_MSB),\n\t\ttvp5150_read(sd, TVP5150_ACT_VD_CROP_STP_LSB));\n\tdprintk0(sd->dev, \"tvp5150: Genlock/RTC = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_GENLOCK));\n\tdprintk0(sd->dev, \"tvp5150: Horizontal sync start = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_HORIZ_SYNC_START));\n\tdprintk0(sd->dev, \"tvp5150: Vertical blanking start = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_VERT_BLANKING_START));\n\tdprintk0(sd->dev, \"tvp5150: Vertical blanking stop = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_VERT_BLANKING_STOP));\n\tdprintk0(sd->dev, \"tvp5150: Chrominance processing control #1 and #2 = %02x %02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_CHROMA_PROC_CTL_1),\n\t\ttvp5150_read(sd, TVP5150_CHROMA_PROC_CTL_2));\n\tdprintk0(sd->dev, \"tvp5150: Interrupt reset register B = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_INT_RESET_REG_B));\n\tdprintk0(sd->dev, \"tvp5150: Interrupt enable register B = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_INT_ENABLE_REG_B));\n\tdprintk0(sd->dev, \"tvp5150: Interrupt configuration register B = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_INTT_CONFIG_REG_B));\n\tdprintk0(sd->dev, \"tvp5150: Video standard = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_VIDEO_STD));\n\tdprintk0(sd->dev, \"tvp5150: Chroma gain factor: Cb=0x%02x Cr=0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_CB_GAIN_FACT),\n\t\ttvp5150_read(sd, TVP5150_CR_GAIN_FACTOR));\n\tdprintk0(sd->dev, \"tvp5150: Macrovision on counter = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_MACROVISION_ON_CTR));\n\tdprintk0(sd->dev, \"tvp5150: Macrovision off counter = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_MACROVISION_OFF_CTR));\n\tdprintk0(sd->dev, \"tvp5150: ITU-R BT.656.%d timing(TVP5150AM1 only)\\n\",\n\t\t(tvp5150_read(sd, TVP5150_REV_SELECT) & 1) ? 3 : 4);\n\tdprintk0(sd->dev, \"tvp5150: Device ID = %02x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_MSB_DEV_ID),\n\t\ttvp5150_read(sd, TVP5150_LSB_DEV_ID));\n\tdprintk0(sd->dev, \"tvp5150: ROM version = (hex) %02x.%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_ROM_MAJOR_VER),\n\t\ttvp5150_read(sd, TVP5150_ROM_MINOR_VER));\n\tdprintk0(sd->dev, \"tvp5150: Vertical line count = 0x%02x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_VERT_LN_COUNT_MSB),\n\t\ttvp5150_read(sd, TVP5150_VERT_LN_COUNT_LSB));\n\tdprintk0(sd->dev, \"tvp5150: Interrupt status register B = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_INT_STATUS_REG_B));\n\tdprintk0(sd->dev, \"tvp5150: Interrupt active register B = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_INT_ACTIVE_REG_B));\n\tdprintk0(sd->dev, \"tvp5150: Status regs #1 to #5 = %02x %02x %02x %02x %02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_STATUS_REG_1),\n\t\ttvp5150_read(sd, TVP5150_STATUS_REG_2),\n\t\ttvp5150_read(sd, TVP5150_STATUS_REG_3),\n\t\ttvp5150_read(sd, TVP5150_STATUS_REG_4),\n\t\ttvp5150_read(sd, TVP5150_STATUS_REG_5));\n\n\tdump_reg_range(sd, \"Teletext filter 1\",   TVP5150_TELETEXT_FIL1_INI,\n\t\t\tTVP5150_TELETEXT_FIL1_END, 8);\n\tdump_reg_range(sd, \"Teletext filter 2\",   TVP5150_TELETEXT_FIL2_INI,\n\t\t\tTVP5150_TELETEXT_FIL2_END, 8);\n\n\tdprintk0(sd->dev, \"tvp5150: Teletext filter enable = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_TELETEXT_FIL_ENA));\n\tdprintk0(sd->dev, \"tvp5150: Interrupt status register A = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_INT_STATUS_REG_A));\n\tdprintk0(sd->dev, \"tvp5150: Interrupt enable register A = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_INT_ENABLE_REG_A));\n\tdprintk0(sd->dev, \"tvp5150: Interrupt configuration = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_INT_CONF));\n\tdprintk0(sd->dev, \"tvp5150: VDP status register = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_VDP_STATUS_REG));\n\tdprintk0(sd->dev, \"tvp5150: FIFO word count = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_FIFO_WORD_COUNT));\n\tdprintk0(sd->dev, \"tvp5150: FIFO interrupt threshold = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_FIFO_INT_THRESHOLD));\n\tdprintk0(sd->dev, \"tvp5150: FIFO reset = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_FIFO_RESET));\n\tdprintk0(sd->dev, \"tvp5150: Line number interrupt = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_LINE_NUMBER_INT));\n\tdprintk0(sd->dev, \"tvp5150: Pixel alignment register = 0x%02x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_PIX_ALIGN_REG_HIGH),\n\t\ttvp5150_read(sd, TVP5150_PIX_ALIGN_REG_LOW));\n\tdprintk0(sd->dev, \"tvp5150: FIFO output control = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_FIFO_OUT_CTRL));\n\tdprintk0(sd->dev, \"tvp5150: Full field enable = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_FULL_FIELD_ENA));\n\tdprintk0(sd->dev, \"tvp5150: Full field mode register = 0x%02x\\n\",\n\t\ttvp5150_read(sd, TVP5150_FULL_FIELD_MODE_REG));\n\n\tdump_reg_range(sd, \"CC   data\",   TVP5150_CC_DATA_INI,\n\t\t\tTVP5150_CC_DATA_END, 8);\n\n\tdump_reg_range(sd, \"WSS  data\",   TVP5150_WSS_DATA_INI,\n\t\t\tTVP5150_WSS_DATA_END, 8);\n\n\tdump_reg_range(sd, \"VPS  data\",   TVP5150_VPS_DATA_INI,\n\t\t\tTVP5150_VPS_DATA_END, 8);\n\n\tdump_reg_range(sd, \"VITC data\",   TVP5150_VITC_DATA_INI,\n\t\t\tTVP5150_VITC_DATA_END, 10);\n\n\tdump_reg_range(sd, \"Line mode\",   TVP5150_LINE_MODE_INI,\n\t\t\tTVP5150_LINE_MODE_END, 8);\n\treturn 0;\n}\n\n \n\nstatic void tvp5150_selmux(struct v4l2_subdev *sd)\n{\n\tint opmode = 0;\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\tunsigned int mask, val;\n\tint input = 0;\n\n\t \n\tif ((decoder->dev_id == 0x5150 && decoder->rom_ver == 0x0400) ||\n\t    (decoder->dev_id == 0x5151 && decoder->rom_ver == 0x0100)) {\n\t\tif (!decoder->enable)\n\t\t\tinput = 8;\n\t}\n\n\tswitch (decoder->input) {\n\tcase TVP5150_COMPOSITE1:\n\t\tinput |= 2;\n\t\tfallthrough;\n\tcase TVP5150_COMPOSITE0:\n\t\tbreak;\n\tcase TVP5150_SVIDEO:\n\tdefault:\n\t\tinput |= 1;\n\t\tbreak;\n\t}\n\n\tdev_dbg_lvl(sd->dev, 1, debug,\n\t\t    \"Selecting video route: route input=%s, output=%s => tvp5150 input=0x%02x, opmode=0x%02x\\n\",\n\t\t    decoder->input == 0 ? \"aip1a\" :\n\t\t    decoder->input == 2 ? \"aip1b\" : \"svideo\",\n\t\t    decoder->output == 0 ? \"normal\" : \"black-frame-gen\",\n\t\t    input, opmode);\n\n\tregmap_write(decoder->regmap, TVP5150_OP_MODE_CTL, opmode);\n\tregmap_write(decoder->regmap, TVP5150_VD_IN_SRC_SEL_1, input);\n\n\t \n\tmask = TVP5150_MISC_CTL_GPCL | TVP5150_MISC_CTL_HVLK;\n\tif (decoder->input == TVP5150_SVIDEO)\n\t\tval = TVP5150_MISC_CTL_HVLK;\n\telse\n\t\tval = TVP5150_MISC_CTL_GPCL;\n\tregmap_update_bits(decoder->regmap, TVP5150_MISC_CTL, mask, val);\n};\n\nstruct i2c_reg_value {\n\tunsigned char reg;\n\tunsigned char value;\n};\n\n \nstatic const struct i2c_reg_value tvp5150_init_default[] = {\n\t{  \n\t\tTVP5150_VD_IN_SRC_SEL_1, 0x00\n\t},\n\t{  \n\t\tTVP5150_ANAL_CHL_CTL, 0x15\n\t},\n\t{  \n\t\tTVP5150_OP_MODE_CTL, 0x00\n\t},\n\t{  \n\t\tTVP5150_MISC_CTL, 0x01\n\t},\n\t{  \n\t\tTVP5150_COLOR_KIL_THSH_CTL, 0x10\n\t},\n\t{  \n\t\tTVP5150_LUMA_PROC_CTL_1, 0x60\n\t},\n\t{  \n\t\tTVP5150_LUMA_PROC_CTL_2, 0x00\n\t},\n\t{  \n\t\tTVP5150_BRIGHT_CTL, 0x80\n\t},\n\t{  \n\t\tTVP5150_SATURATION_CTL, 0x80\n\t},\n\t{  \n\t\tTVP5150_HUE_CTL, 0x00\n\t},\n\t{  \n\t\tTVP5150_CONTRAST_CTL, 0x80\n\t},\n\t{  \n\t\tTVP5150_DATA_RATE_SEL, 0x47\n\t},\n\t{  \n\t\tTVP5150_LUMA_PROC_CTL_3, 0x00\n\t},\n\t{  \n\t\tTVP5150_CONF_SHARED_PIN, 0x08\n\t},\n\t{  \n\t\tTVP5150_ACT_VD_CROP_ST_MSB, 0x00\n\t},\n\t{  \n\t\tTVP5150_ACT_VD_CROP_ST_LSB, 0x00\n\t},\n\t{  \n\t\tTVP5150_ACT_VD_CROP_STP_MSB, 0x00\n\t},\n\t{  \n\t\tTVP5150_ACT_VD_CROP_STP_LSB, 0x00\n\t},\n\t{  \n\t\tTVP5150_GENLOCK, 0x01\n\t},\n\t{  \n\t\tTVP5150_HORIZ_SYNC_START, 0x80\n\t},\n\t{  \n\t\tTVP5150_VERT_BLANKING_START, 0x00\n\t},\n\t{  \n\t\tTVP5150_VERT_BLANKING_STOP, 0x00\n\t},\n\t{  \n\t\tTVP5150_CHROMA_PROC_CTL_1, 0x0c\n\t},\n\t{  \n\t\tTVP5150_CHROMA_PROC_CTL_2, 0x14\n\t},\n\t{  \n\t\tTVP5150_INT_RESET_REG_B, 0x00\n\t},\n\t{  \n\t\tTVP5150_INT_ENABLE_REG_B, 0x00\n\t},\n\t{  \n\t\tTVP5150_INTT_CONFIG_REG_B, 0x00\n\t},\n\t{  \n\t\tTVP5150_VIDEO_STD, 0x00\n\t},\n\t{  \n\t\tTVP5150_MACROVISION_ON_CTR, 0x0f\n\t},\n\t{  \n\t\tTVP5150_MACROVISION_OFF_CTR, 0x01\n\t},\n\t{  \n\t\tTVP5150_TELETEXT_FIL_ENA, 0x00\n\t},\n\t{  \n\t\tTVP5150_INT_STATUS_REG_A, 0x00\n\t},\n\t{  \n\t\tTVP5150_INT_ENABLE_REG_A, 0x00\n\t},\n\t{  \n\t\tTVP5150_INT_CONF, 0x04\n\t},\n\t{  \n\t\tTVP5150_FIFO_INT_THRESHOLD, 0x80\n\t},\n\t{  \n\t\tTVP5150_FIFO_RESET, 0x00\n\t},\n\t{  \n\t\tTVP5150_LINE_NUMBER_INT, 0x00\n\t},\n\t{  \n\t\tTVP5150_PIX_ALIGN_REG_LOW, 0x4e\n\t},\n\t{  \n\t\tTVP5150_PIX_ALIGN_REG_HIGH, 0x00\n\t},\n\t{  \n\t\tTVP5150_FIFO_OUT_CTRL, 0x01\n\t},\n\t{  \n\t\tTVP5150_FULL_FIELD_ENA, 0x00\n\t},\n\t{  \n\t\tTVP5150_LINE_MODE_INI, 0x00\n\t},\n\t{  \n\t\tTVP5150_FULL_FIELD_MODE_REG, 0x7f\n\t},\n\t{  \n\t\t0xff, 0xff\n\t}\n};\n\n \nstatic const struct i2c_reg_value tvp5150_init_enable[] = {\n\t{\t \n\t\tTVP5150_ANAL_CHL_CTL, 0x15\n\t}, {\t \n\t\tTVP5150_MISC_CTL, TVP5150_MISC_CTL_GPCL |\n\t\t\t\t  TVP5150_MISC_CTL_INTREQ_OE |\n\t\t\t\t  TVP5150_MISC_CTL_YCBCR_OE |\n\t\t\t\t  TVP5150_MISC_CTL_SYNC_OE |\n\t\t\t\t  TVP5150_MISC_CTL_VBLANK |\n\t\t\t\t  TVP5150_MISC_CTL_CLOCK_OE,\n\t}, {\t \n\t\tTVP5150_AUTOSW_MSK, 0x0\n\t}, {\t \n\t\tTVP5150_DATA_RATE_SEL, 0x47\n\t}, {\n\t\tTVP5150_CHROMA_PROC_CTL_1, 0x0c\n\t}, {\n\t\tTVP5150_CHROMA_PROC_CTL_2, 0x54\n\t}, {\t \n\t\t0x27, 0x20\n\t}, {\n\t\t0xff, 0xff\n\t}\n};\n\nstruct tvp5150_vbi_type {\n\tunsigned int vbi_type;\n\tunsigned int ini_line;\n\tunsigned int end_line;\n\tunsigned int by_field :1;\n};\n\nstruct i2c_vbi_ram_value {\n\tu16 reg;\n\tstruct tvp5150_vbi_type type;\n\tunsigned char values[16];\n};\n\n \n\nstatic struct i2c_vbi_ram_value vbi_ram_default[] = {\n\n\t \n#if 0\n\t[0] = {0x010,  \n\t\t{V4L2_SLICED_TELETEXT_SECAM, 6, 23, 1},\n\t\t{ 0xaa, 0xaa, 0xff, 0xff, 0xe7, 0x2e, 0x20, 0x26,\n\t\t  0xe6, 0xb4, 0x0e, 0x00, 0x00, 0x00, 0x10, 0x00 }\n\t},\n#endif\n\t[1] = {0x030,  \n\t\t{V4L2_SLICED_TELETEXT_B, 6, 22, 1},\n\t\t{ 0xaa, 0xaa, 0xff, 0xff, 0x27, 0x2e, 0x20, 0x2b,\n\t\t  0xa6, 0x72, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00 }\n\t},\n#if 0\n\t[2] = {0x050,  \n\t\t{V4L2_SLICED_TELETEXT_PAL_C, 6, 22, 1},\n\t\t{ 0xaa, 0xaa, 0xff, 0xff, 0xe7, 0x2e, 0x20, 0x22,\n\t\t  0xa6, 0x98, 0x0d, 0x00, 0x00, 0x00, 0x10, 0x00 }\n\t},\n\t[3] = {0x070,  \n\t\t{V4L2_SLICED_TELETEXT_NTSC_B, 10, 21, 1},\n\t\t{ 0xaa, 0xaa, 0xff, 0xff, 0x27, 0x2e, 0x20, 0x23,\n\t\t  0x69, 0x93, 0x0d, 0x00, 0x00, 0x00, 0x10, 0x00 }\n\t},\n\t[4] = {0x090,  \n\t\t{V4L2_SLICED_TELETEXT_NTSC_C, 10, 21, 1},\n\t\t{ 0xaa, 0xaa, 0xff, 0xff, 0xe7, 0x2e, 0x20, 0x22,\n\t\t  0x69, 0x93, 0x0d, 0x00, 0x00, 0x00, 0x15, 0x00 }\n\t},\n\t[5] = {0x0b0,  \n\t\t{V4L2_SLICED_TELETEXT_NTSC_D, 10, 21, 1},\n\t\t{ 0xaa, 0xaa, 0xff, 0xff, 0xa7, 0x2e, 0x20, 0x23,\n\t\t  0x69, 0x93, 0x0d, 0x00, 0x00, 0x00, 0x10, 0x00 }\n\t},\n\t[6] = {0x0d0,  \n\t\t{V4L2_SLICED_CAPTION_625, 22, 22, 1},\n\t\t{ 0xaa, 0x2a, 0xff, 0x3f, 0x04, 0x51, 0x6e, 0x02,\n\t\t  0xa6, 0x7b, 0x09, 0x00, 0x00, 0x00, 0x27, 0x00 }\n\t},\n#endif\n\t[7] = {0x0f0,  \n\t\t{V4L2_SLICED_CAPTION_525, 21, 21, 1},\n\t\t{ 0xaa, 0x2a, 0xff, 0x3f, 0x04, 0x51, 0x6e, 0x02,\n\t\t  0x69, 0x8c, 0x09, 0x00, 0x00, 0x00, 0x27, 0x00 }\n\t},\n\t[8] = {0x110,  \n\t\t{V4L2_SLICED_WSS_625, 23, 23, 1},\n\t\t{ 0x5b, 0x55, 0xc5, 0xff, 0x00, 0x71, 0x6e, 0x42,\n\t\t  0xa6, 0xcd, 0x0f, 0x00, 0x00, 0x00, 0x3a, 0x00 }\n\t},\n#if 0\n\t[9] = {0x130,  \n\t\t{V4L2_SLICED_WSS_525, 20, 20, 1},\n\t\t{ 0x38, 0x00, 0x3f, 0x00, 0x00, 0x71, 0x6e, 0x43,\n\t\t  0x69, 0x7c, 0x08, 0x00, 0x00, 0x00, 0x39, 0x00 }\n\t},\n\t[10] = {0x150,  \n\t\t{V4l2_SLICED_VITC_625, 6, 22, 0},\n\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x6d, 0x49,\n\t\t  0xa6, 0x85, 0x08, 0x00, 0x00, 0x00, 0x4c, 0x00 }\n\t},\n\t[11] = {0x170,  \n\t\t{V4l2_SLICED_VITC_525, 10, 20, 0},\n\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x6d, 0x49,\n\t\t  0x69, 0x94, 0x08, 0x00, 0x00, 0x00, 0x4c, 0x00 }\n\t},\n#endif\n\t[12] = {0x190,  \n\t\t{V4L2_SLICED_VPS, 16, 16, 0},\n\t\t{ 0xaa, 0xaa, 0xff, 0xff, 0xba, 0xce, 0x2b, 0x0d,\n\t\t  0xa6, 0xda, 0x0b, 0x00, 0x00, 0x00, 0x60, 0x00 }\n\t},\n\t \n};\n\nstatic int tvp5150_write_inittab(struct v4l2_subdev *sd,\n\t\t\t\tconst struct i2c_reg_value *regs)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\n\twhile (regs->reg != 0xff) {\n\t\tregmap_write(decoder->regmap, regs->reg, regs->value);\n\t\tregs++;\n\t}\n\treturn 0;\n}\n\nstatic int tvp5150_vdp_init(struct v4l2_subdev *sd)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\tstruct regmap *map = decoder->regmap;\n\tunsigned int i;\n\tint j;\n\n\t \n\tregmap_write(map, TVP5150_FULL_FIELD_ENA, 0);\n\n\t \n\tfor (i = TVP5150_LINE_MODE_INI; i <= TVP5150_LINE_MODE_END; i++)\n\t\tregmap_write(map, i, 0xff);\n\n\t \n\tfor (j = 0; j < ARRAY_SIZE(vbi_ram_default); j++) {\n\t\tconst struct i2c_vbi_ram_value *regs = &vbi_ram_default[j];\n\n\t\tif (!regs->type.vbi_type)\n\t\t\tcontinue;\n\n\t\tregmap_write(map, TVP5150_CONF_RAM_ADDR_HIGH, regs->reg >> 8);\n\t\tregmap_write(map, TVP5150_CONF_RAM_ADDR_LOW, regs->reg);\n\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tregmap_write(map, TVP5150_VDP_CONF_RAM_DATA,\n\t\t\t\t     regs->values[i]);\n\t}\n\treturn 0;\n}\n\n \nstatic int tvp5150_g_sliced_vbi_cap(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_sliced_vbi_cap *cap)\n{\n\tint line, i;\n\n\tdev_dbg_lvl(sd->dev, 1, debug, \"g_sliced_vbi_cap\\n\");\n\tmemset(cap, 0, sizeof(*cap));\n\n\tfor (i = 0; i < ARRAY_SIZE(vbi_ram_default); i++) {\n\t\tconst struct i2c_vbi_ram_value *regs = &vbi_ram_default[i];\n\n\t\tif (!regs->type.vbi_type)\n\t\t\tcontinue;\n\n\t\tfor (line = regs->type.ini_line;\n\t\t     line <= regs->type.end_line;\n\t\t     line++) {\n\t\t\tcap->service_lines[0][line] |= regs->type.vbi_type;\n\t\t}\n\t\tcap->service_set |= regs->type.vbi_type;\n\t}\n\treturn 0;\n}\n\n \nstatic int tvp5150_set_vbi(struct v4l2_subdev *sd,\n\t\t\tunsigned int type, u8 flags, int line,\n\t\t\tconst int fields)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\tv4l2_std_id std = decoder->norm;\n\tu8 reg;\n\tint i, pos = 0;\n\n\tif (std == V4L2_STD_ALL) {\n\t\tdev_err(sd->dev, \"VBI can't be configured without knowing number of lines\\n\");\n\t\treturn 0;\n\t} else if (std & V4L2_STD_625_50) {\n\t\t \n\t\tline += 3;\n\t}\n\n\tif (line < 6 || line > 27)\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(vbi_ram_default); i++) {\n\t\tconst struct i2c_vbi_ram_value *regs =  &vbi_ram_default[i];\n\n\t\tif (!regs->type.vbi_type)\n\t\t\tcontinue;\n\n\t\tif ((type & regs->type.vbi_type) &&\n\t\t    (line >= regs->type.ini_line) &&\n\t\t    (line <= regs->type.end_line))\n\t\t\tbreak;\n\t\tpos++;\n\t}\n\n\ttype = pos | (flags & 0xf0);\n\treg = ((line - 6) << 1) + TVP5150_LINE_MODE_INI;\n\n\tif (fields & 1)\n\t\tregmap_write(decoder->regmap, reg, type);\n\n\tif (fields & 2)\n\t\tregmap_write(decoder->regmap, reg + 1, type);\n\n\treturn type;\n}\n\nstatic int tvp5150_get_vbi(struct v4l2_subdev *sd, int line)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\tv4l2_std_id std = decoder->norm;\n\tu8 reg;\n\tint pos, type = 0;\n\tint i, ret = 0;\n\n\tif (std == V4L2_STD_ALL) {\n\t\tdev_err(sd->dev, \"VBI can't be configured without knowing number of lines\\n\");\n\t\treturn 0;\n\t} else if (std & V4L2_STD_625_50) {\n\t\t \n\t\tline += 3;\n\t}\n\n\tif (line < 6 || line > 27)\n\t\treturn 0;\n\n\treg = ((line - 6) << 1) + TVP5150_LINE_MODE_INI;\n\n\tfor (i = 0; i <= 1; i++) {\n\t\tret = tvp5150_read(sd, reg + i);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sd->dev, \"%s: failed with error = %d\\n\",\n\t\t\t\t __func__, ret);\n\t\t\treturn 0;\n\t\t}\n\t\tpos = ret & 0x0f;\n\t\tif (pos < ARRAY_SIZE(vbi_ram_default))\n\t\t\ttype |= vbi_ram_default[pos].type.vbi_type;\n\t}\n\n\treturn type;\n}\n\nstatic int tvp5150_set_std(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\tint fmt = 0;\n\n\t \n\n\tif (std == V4L2_STD_NTSC_443) {\n\t\tfmt = VIDEO_STD_NTSC_4_43_BIT;\n\t} else if (std == V4L2_STD_PAL_M) {\n\t\tfmt = VIDEO_STD_PAL_M_BIT;\n\t} else if (std == V4L2_STD_PAL_N || std == V4L2_STD_PAL_Nc) {\n\t\tfmt = VIDEO_STD_PAL_COMBINATION_N_BIT;\n\t} else {\n\t\t \n\t\tif (std & V4L2_STD_NTSC)\n\t\t\tfmt = VIDEO_STD_NTSC_MJ_BIT;\n\t\telse if (std & V4L2_STD_PAL)\n\t\t\tfmt = VIDEO_STD_PAL_BDGHIN_BIT;\n\t\telse if (std & V4L2_STD_SECAM)\n\t\t\tfmt = VIDEO_STD_SECAM_BIT;\n\t}\n\n\tdev_dbg_lvl(sd->dev, 1, debug, \"Set video std register to %d.\\n\", fmt);\n\tregmap_write(decoder->regmap, TVP5150_VIDEO_STD, fmt);\n\treturn 0;\n}\n\nstatic int tvp5150_g_std(struct v4l2_subdev *sd, v4l2_std_id *std)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\n\t*std = decoder->norm;\n\n\treturn 0;\n}\n\nstatic int tvp5150_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\tstruct tvp5150_connector *cur_con = decoder->cur_connector;\n\tv4l2_std_id supported_stds;\n\n\tif (decoder->norm == std)\n\t\treturn 0;\n\n\t \n\tif (!decoder->connectors_num)\n\t\tsupported_stds = V4L2_STD_ALL;\n\telse\n\t\tsupported_stds = cur_con->base.connector.analog.sdtv_stds;\n\n\t \n\tif ((supported_stds & std) == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (std & V4L2_STD_525_60)\n\t\tdecoder->rect.height = TVP5150_V_MAX_525_60;\n\telse\n\t\tdecoder->rect.height = TVP5150_V_MAX_OTHERS;\n\n\t \n\tdecoder->norm = supported_stds & std;\n\n\treturn tvp5150_set_std(sd, std);\n}\n\nstatic v4l2_std_id tvp5150_read_std(struct v4l2_subdev *sd)\n{\n\tint val = tvp5150_read(sd, TVP5150_STATUS_REG_5);\n\n\tswitch (val & 0x0F) {\n\tcase 0x01:\n\t\treturn V4L2_STD_NTSC;\n\tcase 0x03:\n\t\treturn V4L2_STD_PAL;\n\tcase 0x05:\n\t\treturn V4L2_STD_PAL_M;\n\tcase 0x07:\n\t\treturn V4L2_STD_PAL_N | V4L2_STD_PAL_Nc;\n\tcase 0x09:\n\t\treturn V4L2_STD_NTSC_443;\n\tcase 0xb:\n\t\treturn V4L2_STD_SECAM;\n\tdefault:\n\t\treturn V4L2_STD_UNKNOWN;\n\t}\n}\n\nstatic int query_lock(struct v4l2_subdev *sd)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\tint status;\n\n\tif (decoder->irq)\n\t\treturn decoder->lock;\n\n\tregmap_read(decoder->regmap, TVP5150_STATUS_REG_1, &status);\n\n\t \n\treturn (status & 0x0e) == 0x0e;\n}\n\nstatic int tvp5150_querystd(struct v4l2_subdev *sd, v4l2_std_id *std_id)\n{\n\t*std_id = query_lock(sd) ? tvp5150_read_std(sd) : V4L2_STD_UNKNOWN;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_event tvp5150_ev_fmt = {\n\t.type = V4L2_EVENT_SOURCE_CHANGE,\n\t.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,\n};\n\nstatic irqreturn_t tvp5150_isr(int irq, void *dev_id)\n{\n\tstruct tvp5150 *decoder = dev_id;\n\tstruct regmap *map = decoder->regmap;\n\tunsigned int mask, active = 0, status = 0;\n\n\tmask = TVP5150_MISC_CTL_YCBCR_OE | TVP5150_MISC_CTL_SYNC_OE |\n\t       TVP5150_MISC_CTL_CLOCK_OE;\n\n\tregmap_read(map, TVP5150_INT_STATUS_REG_A, &status);\n\tif (status) {\n\t\tregmap_write(map, TVP5150_INT_STATUS_REG_A, status);\n\n\t\tif (status & TVP5150_INT_A_LOCK) {\n\t\t\tdecoder->lock = !!(status & TVP5150_INT_A_LOCK_STATUS);\n\t\t\tdev_dbg_lvl(decoder->sd.dev, 1, debug,\n\t\t\t\t    \"sync lo%s signal\\n\",\n\t\t\t\t    decoder->lock ? \"ck\" : \"ss\");\n\t\t\tv4l2_subdev_notify_event(&decoder->sd, &tvp5150_ev_fmt);\n\t\t\tregmap_update_bits(map, TVP5150_MISC_CTL, mask,\n\t\t\t\t\t   decoder->lock ? decoder->oe : 0);\n\t\t}\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tregmap_read(map, TVP5150_INT_ACTIVE_REG_B, &active);\n\tif (active) {\n\t\tstatus = 0;\n\t\tregmap_read(map, TVP5150_INT_STATUS_REG_B, &status);\n\t\tif (status)\n\t\t\tregmap_write(map, TVP5150_INT_RESET_REG_B, status);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tvp5150_reset(struct v4l2_subdev *sd, u32 val)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\tstruct regmap *map = decoder->regmap;\n\n\t \n\ttvp5150_write_inittab(sd, tvp5150_init_default);\n\n\tif (decoder->irq) {\n\t\t \n\t\tregmap_write(map, TVP5150_CONF_SHARED_PIN, 0x0);\n\t\t \n\t\tregmap_write(map, TVP5150_INT_CONF, TVP5150_VDPOE | 0x1);\n\t\tregmap_write(map, TVP5150_INTT_CONFIG_REG_B, 0x1);\n\t} else {\n\t\t \n\t\tregmap_write(map, TVP5150_CONF_SHARED_PIN, 0x2);\n\t\t \n\t\tregmap_write(map, TVP5150_INT_CONF, TVP5150_VDPOE);\n\t\tregmap_write(map, TVP5150_INTT_CONFIG_REG_B, 0x0);\n\t}\n\n\t \n\ttvp5150_vdp_init(sd);\n\n\t \n\ttvp5150_selmux(sd);\n\n\t \n\tv4l2_ctrl_handler_setup(&decoder->hdl);\n\n\treturn 0;\n}\n\nstatic int tvp5150_enable(struct v4l2_subdev *sd)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\tv4l2_std_id std;\n\n\t \n\ttvp5150_write_inittab(sd, tvp5150_init_enable);\n\n\tif (decoder->norm == V4L2_STD_ALL)\n\t\tstd = tvp5150_read_std(sd);\n\telse\n\t\tstd = decoder->norm;\n\n\t \n\ttvp5150_set_std(sd, std);\n\n\t \n\tswitch (decoder->mbus_type) {\n\tcase V4L2_MBUS_PARALLEL:\n\t\t \n\t\tregmap_update_bits(decoder->regmap, TVP5150_DATA_RATE_SEL,\n\t\t\t\t   0x7, 0x0);\n\t\tdecoder->oe = TVP5150_MISC_CTL_YCBCR_OE |\n\t\t\t      TVP5150_MISC_CTL_CLOCK_OE |\n\t\t\t      TVP5150_MISC_CTL_SYNC_OE;\n\t\tbreak;\n\tcase V4L2_MBUS_BT656:\n\t\tdecoder->oe = TVP5150_MISC_CTL_YCBCR_OE |\n\t\t\t      TVP5150_MISC_CTL_CLOCK_OE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n};\n\nstatic int tvp5150_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tregmap_write(decoder->regmap, TVP5150_BRIGHT_CTL, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_CONTRAST:\n\t\tregmap_write(decoder->regmap, TVP5150_CONTRAST_CTL, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_SATURATION:\n\t\tregmap_write(decoder->regmap, TVP5150_SATURATION_CTL,\n\t\t\t     ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_HUE:\n\t\tregmap_write(decoder->regmap, TVP5150_HUE_CTL, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tdecoder->enable = ctrl->val ? false : true;\n\t\ttvp5150_selmux(sd);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic void tvp5150_set_default(v4l2_std_id std, struct v4l2_rect *crop)\n{\n\t \n\tcrop->top = 0;\n\tcrop->left = 0;\n\tcrop->width = TVP5150_H_MAX;\n\tif (std & V4L2_STD_525_60)\n\t\tcrop->height = TVP5150_V_MAX_525_60;\n\telse\n\t\tcrop->height = TVP5150_V_MAX_OTHERS;\n}\n\nstatic struct v4l2_rect *\ntvp5150_get_pad_crop(struct tvp5150 *decoder,\n\t\t     struct v4l2_subdev_state *sd_state, unsigned int pad,\n\t\t     enum v4l2_subdev_format_whence which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &decoder->rect;\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n#if defined(CONFIG_VIDEO_V4L2_SUBDEV_API)\n\t\treturn v4l2_subdev_get_try_crop(&decoder->sd, sd_state, pad);\n#else\n\t\treturn ERR_PTR(-EINVAL);\n#endif\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n}\n\nstatic int tvp5150_fill_fmt(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *f;\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\n\tif (!format || (format->pad != TVP5150_PAD_VID_OUT))\n\t\treturn -EINVAL;\n\n\tf = &format->format;\n\n\tf->width = decoder->rect.width;\n\tf->height = decoder->rect.height / 2;\n\n\tf->code = TVP5150_MBUS_FMT;\n\tf->field = TVP5150_FIELD;\n\tf->colorspace = TVP5150_COLORSPACE;\n\n\tdev_dbg_lvl(sd->dev, 1, debug, \"width = %d, height = %d\\n\", f->width,\n\t\t    f->height);\n\treturn 0;\n}\n\nstatic unsigned int tvp5150_get_hmax(struct v4l2_subdev *sd)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\tv4l2_std_id std;\n\n\t \n\tif (decoder->norm == V4L2_STD_ALL)\n\t\tstd = tvp5150_read_std(sd);\n\telse\n\t\tstd = decoder->norm;\n\n\treturn (std & V4L2_STD_525_60) ?\n\t\tTVP5150_V_MAX_525_60 : TVP5150_V_MAX_OTHERS;\n}\n\nstatic void tvp5150_set_hw_selection(struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_rect *rect)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\tunsigned int hmax = tvp5150_get_hmax(sd);\n\n\tregmap_write(decoder->regmap, TVP5150_VERT_BLANKING_START, rect->top);\n\tregmap_write(decoder->regmap, TVP5150_VERT_BLANKING_STOP,\n\t\t     rect->top + rect->height - hmax);\n\tregmap_write(decoder->regmap, TVP5150_ACT_VD_CROP_ST_MSB,\n\t\t     rect->left >> TVP5150_CROP_SHIFT);\n\tregmap_write(decoder->regmap, TVP5150_ACT_VD_CROP_ST_LSB,\n\t\t     rect->left | (1 << TVP5150_CROP_SHIFT));\n\tregmap_write(decoder->regmap, TVP5150_ACT_VD_CROP_STP_MSB,\n\t\t     (rect->left + rect->width - TVP5150_MAX_CROP_LEFT) >>\n\t\t     TVP5150_CROP_SHIFT);\n\tregmap_write(decoder->regmap, TVP5150_ACT_VD_CROP_STP_LSB,\n\t\t     rect->left + rect->width - TVP5150_MAX_CROP_LEFT);\n}\n\nstatic int tvp5150_set_selection(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_selection *sel)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\tstruct v4l2_rect *rect = &sel->r;\n\tstruct v4l2_rect *crop;\n\tunsigned int hmax;\n\n\tif (sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\tdev_dbg_lvl(sd->dev, 1, debug, \"%s left=%d, top=%d, width=%d, height=%d\\n\",\n\t\t__func__, rect->left, rect->top, rect->width, rect->height);\n\n\t \n\trect->left = clamp(rect->left, 0, TVP5150_MAX_CROP_LEFT);\n\trect->top = clamp(rect->top, 0, TVP5150_MAX_CROP_TOP);\n\thmax = tvp5150_get_hmax(sd);\n\n\t \n\tv4l_bound_align_image(&rect->width,\n\t\t\t      TVP5150_H_MAX - TVP5150_MAX_CROP_LEFT - rect->left,\n\t\t\t      TVP5150_H_MAX - rect->left, 1, &rect->height,\n\t\t\t      hmax - TVP5150_MAX_CROP_TOP - rect->top,\n\t\t\t      hmax - rect->top, 0, 0);\n\n\tif (!IS_ENABLED(CONFIG_VIDEO_V4L2_SUBDEV_API) &&\n\t    sel->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn 0;\n\n\tcrop = tvp5150_get_pad_crop(decoder, sd_state, sel->pad, sel->which);\n\tif (IS_ERR(crop))\n\t\treturn PTR_ERR(crop);\n\n\t \n\tif (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE &&\n\t    !v4l2_rect_equal(rect, crop))\n\t\ttvp5150_set_hw_selection(sd, rect);\n\n\t*crop = *rect;\n\n\treturn 0;\n}\n\nstatic int tvp5150_get_selection(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_selection *sel)\n{\n\tstruct tvp5150 *decoder = container_of(sd, struct tvp5150, sd);\n\tstruct v4l2_rect *crop;\n\tv4l2_std_id std;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = TVP5150_H_MAX;\n\n\t\t \n\t\tif (decoder->norm == V4L2_STD_ALL)\n\t\t\tstd = tvp5150_read_std(sd);\n\t\telse\n\t\t\tstd = decoder->norm;\n\t\tif (std & V4L2_STD_525_60)\n\t\t\tsel->r.height = TVP5150_V_MAX_525_60;\n\t\telse\n\t\t\tsel->r.height = TVP5150_V_MAX_OTHERS;\n\t\treturn 0;\n\tcase V4L2_SEL_TGT_CROP:\n\t\tcrop = tvp5150_get_pad_crop(decoder, sd_state, sel->pad,\n\t\t\t\t\t    sel->which);\n\t\tif (IS_ERR(crop))\n\t\t\treturn PTR_ERR(crop);\n\t\tsel->r = *crop;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tvp5150_get_mbus_config(struct v4l2_subdev *sd,\n\t\t\t\t   unsigned int pad,\n\t\t\t\t   struct v4l2_mbus_config *cfg)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\n\tcfg->type = decoder->mbus_type;\n\tcfg->bus.parallel.flags = V4L2_MBUS_MASTER\n\t\t\t\t| V4L2_MBUS_PCLK_SAMPLE_RISING\n\t\t\t\t| V4L2_MBUS_FIELD_EVEN_LOW\n\t\t\t\t| V4L2_MBUS_DATA_ACTIVE_HIGH;\n\n\treturn 0;\n}\n\n \nstatic int tvp5150_init_cfg(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\tv4l2_std_id std;\n\n\t \n\tif (decoder->norm == V4L2_STD_ALL) {\n\t\tstd = tvp5150_read_std(sd);\n\t\tif (std != decoder->detected_norm) {\n\t\t\tdecoder->detected_norm = std;\n\t\t\ttvp5150_set_default(std, &decoder->rect);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tvp5150_enum_mbus_code(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index)\n\t\treturn -EINVAL;\n\n\tcode->code = TVP5150_MBUS_FMT;\n\treturn 0;\n}\n\nstatic int tvp5150_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\n\tif (fse->index >= 8 || fse->code != TVP5150_MBUS_FMT)\n\t\treturn -EINVAL;\n\n\tfse->code = TVP5150_MBUS_FMT;\n\tfse->min_width = decoder->rect.width;\n\tfse->max_width = decoder->rect.width;\n\tfse->min_height = decoder->rect.height / 2;\n\tfse->max_height = decoder->rect.height / 2;\n\n\treturn 0;\n}\n\n \n#if defined(CONFIG_MEDIA_CONTROLLER)\nstatic int tvp5150_set_link(struct media_pad *connector_pad,\n\t\t\t    struct media_pad *tvp5150_pad, u32 flags)\n{\n\tstruct media_link *link;\n\n\tlink = media_entity_find_link(connector_pad, tvp5150_pad);\n\tif (!link)\n\t\treturn -EINVAL;\n\n\tlink->flags = flags;\n\tlink->reverse->flags = link->flags;\n\n\treturn 0;\n}\n\nstatic int tvp5150_disable_all_input_links(struct tvp5150 *decoder)\n{\n\tstruct media_pad *connector_pad;\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < TVP5150_NUM_PADS - 1; i++) {\n\t\tconnector_pad = media_pad_remote_pad_first(&decoder->pads[i]);\n\t\tif (!connector_pad)\n\t\t\tcontinue;\n\n\t\terr = tvp5150_set_link(connector_pad, &decoder->pads[i], 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int tvp5150_s_routing(struct v4l2_subdev *sd, u32 input, u32 output,\n\t\t\t     u32 config);\n\nstatic int tvp5150_link_setup(struct media_entity *entity,\n\t\t\t      const struct media_pad *tvp5150_pad,\n\t\t\t      const struct media_pad *remote, u32 flags)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\tstruct media_pad *other_tvp5150_pad =\n\t\t&decoder->pads[tvp5150_pad->index ^ 1];\n\tstruct v4l2_fwnode_connector *v4l2c;\n\tbool is_svideo = false;\n\tunsigned int i;\n\tint err;\n\n\t \n\tif (tvp5150_pad->flags & MEDIA_PAD_FL_SOURCE)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < decoder->connectors_num; i++) {\n\t\tif (remote->entity == &decoder->connectors[i].ent) {\n\t\t\tv4l2c = &decoder->connectors[i].base;\n\t\t\tis_svideo = v4l2c->type == V4L2_CONN_SVIDEO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdev_dbg_lvl(sd->dev, 1, debug, \"link setup '%s':%d->'%s':%d[%d]\",\n\t\t    remote->entity->name, remote->index,\n\t\t    tvp5150_pad->entity->name, tvp5150_pad->index,\n\t\t    flags & MEDIA_LNK_FL_ENABLED);\n\tif (is_svideo)\n\t\tdev_dbg_lvl(sd->dev, 1, debug,\n\t\t\t    \"link setup '%s':%d->'%s':%d[%d]\",\n\t\t\t    remote->entity->name, remote->index,\n\t\t\t    other_tvp5150_pad->entity->name,\n\t\t\t    other_tvp5150_pad->index,\n\t\t\t    flags & MEDIA_LNK_FL_ENABLED);\n\n\t \n\terr = tvp5150_disable_all_input_links(decoder);\n\tif (err)\n\t\treturn err;\n\n\ttvp5150_s_routing(sd, is_svideo ? TVP5150_SVIDEO : tvp5150_pad->index,\n\t\t\t  flags & MEDIA_LNK_FL_ENABLED ? TVP5150_NORMAL :\n\t\t\t  TVP5150_BLACK_SCREEN, 0);\n\n\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\tstruct v4l2_fwnode_connector_analog *v4l2ca;\n\t\tu32 new_norm;\n\n\t\t \n\t\tif (is_svideo) {\n\t\t\terr = tvp5150_set_link((struct media_pad *)remote,\n\t\t\t\t\t       other_tvp5150_pad, flags);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (!decoder->connectors_num)\n\t\t\treturn 0;\n\n\t\t \n\t\tdecoder->cur_connector =\n\t\t\tcontainer_of(remote, struct tvp5150_connector, pad);\n\n\t\t \n\t\tv4l2ca = &decoder->cur_connector->base.connector.analog;\n\t\tnew_norm = decoder->norm & v4l2ca->sdtv_stds;\n\t\tif (decoder->norm == new_norm)\n\t\t\treturn 0;\n\n\t\t \n\t\ttvp5150_s_std(sd, new_norm ? new_norm : v4l2ca->sdtv_stds);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct media_entity_operations tvp5150_sd_media_ops = {\n\t.link_setup = tvp5150_link_setup,\n};\n#endif\n \nstatic int __maybe_unused tvp5150_runtime_suspend(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\n\tif (decoder->irq)\n\t\t \n\t\treturn regmap_update_bits(decoder->regmap,\n\t\t\t\t\t  TVP5150_INT_ENABLE_REG_A,\n\t\t\t\t\t  TVP5150_INT_A_LOCK, 0);\n\treturn 0;\n}\n\nstatic int __maybe_unused tvp5150_runtime_resume(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\n\tif (decoder->irq)\n\t\t \n\t\treturn regmap_update_bits(decoder->regmap,\n\t\t\t\t\t  TVP5150_INT_ENABLE_REG_A,\n\t\t\t\t\t  TVP5150_INT_A_LOCK,\n\t\t\t\t\t  TVP5150_INT_A_LOCK);\n\treturn 0;\n}\n\nstatic int tvp5150_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\tunsigned int mask, val = 0;\n\tint ret;\n\n\tmask = TVP5150_MISC_CTL_YCBCR_OE | TVP5150_MISC_CTL_SYNC_OE |\n\t       TVP5150_MISC_CTL_CLOCK_OE;\n\n\tif (enable) {\n\t\tret = pm_runtime_resume_and_get(sd->dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttvp5150_enable(sd);\n\n\t\t \n\t\tif (decoder->irq)\n\t\t\tval = decoder->lock ? decoder->oe : 0;\n\t\telse\n\t\t\tval = decoder->oe;\n\n\t\tv4l2_subdev_notify_event(&decoder->sd, &tvp5150_ev_fmt);\n\t} else {\n\t\tpm_runtime_put(sd->dev);\n\t}\n\n\tregmap_update_bits(decoder->regmap, TVP5150_MISC_CTL, mask, val);\n\n\treturn 0;\n}\n\nstatic int tvp5150_s_routing(struct v4l2_subdev *sd,\n\t\t\t     u32 input, u32 output, u32 config)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\n\tdecoder->input = input;\n\tdecoder->output = output;\n\n\tif (output == TVP5150_BLACK_SCREEN)\n\t\tdecoder->enable = false;\n\telse\n\t\tdecoder->enable = true;\n\n\ttvp5150_selmux(sd);\n\treturn 0;\n}\n\nstatic int tvp5150_s_raw_fmt(struct v4l2_subdev *sd, struct v4l2_vbi_format *fmt)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\n\t \n\n\tif (fmt->sample_format == V4L2_PIX_FMT_GREY)\n\t\tregmap_write(decoder->regmap, TVP5150_LUMA_PROC_CTL_1, 0x70);\n\tif (fmt->count[0] == 18 && fmt->count[1] == 18) {\n\t\tregmap_write(decoder->regmap, TVP5150_VERT_BLANKING_START,\n\t\t\t     0x00);\n\t\tregmap_write(decoder->regmap, TVP5150_VERT_BLANKING_STOP, 0x01);\n\t}\n\treturn 0;\n}\n\nstatic int tvp5150_s_sliced_fmt(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_format *svbi)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\tint i;\n\n\tif (svbi->service_set != 0) {\n\t\tfor (i = 0; i <= 23; i++) {\n\t\t\tsvbi->service_lines[1][i] = 0;\n\t\t\tsvbi->service_lines[0][i] =\n\t\t\t\ttvp5150_set_vbi(sd, svbi->service_lines[0][i],\n\t\t\t\t\t\t0xf0, i, 3);\n\t\t}\n\t\t \n\t\tregmap_write(decoder->regmap, TVP5150_FIFO_OUT_CTRL, 1);\n\t} else {\n\t\t \n\t\tregmap_write(decoder->regmap, TVP5150_FIFO_OUT_CTRL, 0);\n\n\t\t \n\t\tregmap_write(decoder->regmap, TVP5150_FULL_FIELD_ENA, 0);\n\n\t\t \n\t\tfor (i = TVP5150_LINE_MODE_INI; i <= TVP5150_LINE_MODE_END; i++)\n\t\t\tregmap_write(decoder->regmap, i, 0xff);\n\t}\n\treturn 0;\n}\n\nstatic int tvp5150_g_sliced_fmt(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_format *svbi)\n{\n\tint i, mask = 0;\n\n\tmemset(svbi->service_lines, 0, sizeof(svbi->service_lines));\n\n\tfor (i = 0; i <= 23; i++) {\n\t\tsvbi->service_lines[0][i] =\n\t\t\ttvp5150_get_vbi(sd, i);\n\t\tmask |= svbi->service_lines[0][i];\n\t}\n\tsvbi->service_set = mask;\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int tvp5150_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\n{\n\tint res;\n\n\tres = tvp5150_read(sd, reg->reg & 0xff);\n\tif (res < 0) {\n\t\tdev_err(sd->dev, \"%s: failed with error = %d\\n\", __func__, res);\n\t\treturn res;\n\t}\n\n\treg->val = res;\n\treg->size = 1;\n\treturn 0;\n}\n\nstatic int tvp5150_s_register(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg)\n{\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\n\treturn regmap_write(decoder->regmap, reg->reg & 0xff, reg->val & 0xff);\n}\n#endif\n\nstatic int tvp5150_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,\n\t\t\t\t   struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\treturn v4l2_src_change_event_subdev_subscribe(sd, fh, sub);\n\tcase V4L2_EVENT_CTRL:\n\t\treturn v4l2_ctrl_subdev_subscribe_event(sd, fh, sub);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tvp5150_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\n{\n\tint status = tvp5150_read(sd, 0x88);\n\n\tvt->signal = ((status & 0x04) && (status & 0x02)) ? 0xffff : 0x0;\n\treturn 0;\n}\n\nstatic int tvp5150_registered(struct v4l2_subdev *sd)\n{\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\tunsigned int i;\n\tint ret;\n\n\t \n\tfor (i = 0; i < decoder->connectors_num; i++) {\n\t\tstruct media_entity *con = &decoder->connectors[i].ent;\n\t\tstruct media_pad *pad = &decoder->connectors[i].pad;\n\t\tstruct v4l2_fwnode_connector *v4l2c =\n\t\t\t&decoder->connectors[i].base;\n\t\tstruct v4l2_connector_link *link =\n\t\t\tv4l2_connector_first_link(v4l2c);\n\t\tunsigned int port = link->fwnode_link.remote_port;\n\t\tunsigned int flags = i ? 0 : MEDIA_LNK_FL_ENABLED;\n\t\tbool is_svideo = v4l2c->type == V4L2_CONN_SVIDEO;\n\n\t\tpad->flags = MEDIA_PAD_FL_SOURCE;\n\t\tret = media_entity_pads_init(con, 1, pad);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tret = media_device_register_entity(sd->v4l2_dev->mdev, con);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tret = media_create_pad_link(con, 0, &sd->entity, port, flags);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tif (is_svideo) {\n\t\t\t \n\t\t\tlink = v4l2_connector_last_link(v4l2c);\n\t\t\tport = link->fwnode_link.remote_port;\n\t\t\tret = media_create_pad_link(con, 0, &sd->entity, port,\n\t\t\t\t\t\t    flags);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\tif (flags == MEDIA_LNK_FL_ENABLED) {\n\t\t\tdecoder->input =\n\t\t\t\tis_svideo ? TVP5150_SVIDEO :\n\t\t\t\tport == 0 ? TVP5150_COMPOSITE0 :\n\t\t\t\tTVP5150_COMPOSITE1;\n\n\t\t\ttvp5150_selmux(sd);\n\t\t\tdecoder->cur_connector = &decoder->connectors[i];\n\t\t\ttvp5150_s_std(sd, v4l2c->connector.analog.sdtv_stds);\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (i = 0; i < decoder->connectors_num; i++) {\n\t\tmedia_device_unregister_entity(&decoder->connectors[i].ent);\n\t\tmedia_entity_cleanup(&decoder->connectors[i].ent);\n\t}\n\treturn ret;\n#endif\n\n\treturn 0;\n}\n\nstatic int tvp5150_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\treturn pm_runtime_resume_and_get(sd->dev);\n}\n\nstatic int tvp5150_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tpm_runtime_put(sd->dev);\n\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_ctrl_ops tvp5150_ctrl_ops = {\n\t.s_ctrl = tvp5150_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops tvp5150_core_ops = {\n\t.log_status = tvp5150_log_status,\n\t.reset = tvp5150_reset,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = tvp5150_g_register,\n\t.s_register = tvp5150_s_register,\n#endif\n\t.subscribe_event = tvp5150_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n};\n\nstatic const struct v4l2_subdev_tuner_ops tvp5150_tuner_ops = {\n\t.g_tuner = tvp5150_g_tuner,\n};\n\nstatic const struct v4l2_subdev_video_ops tvp5150_video_ops = {\n\t.s_std = tvp5150_s_std,\n\t.g_std = tvp5150_g_std,\n\t.querystd = tvp5150_querystd,\n\t.s_stream = tvp5150_s_stream,\n\t.s_routing = tvp5150_s_routing,\n};\n\nstatic const struct v4l2_subdev_vbi_ops tvp5150_vbi_ops = {\n\t.g_sliced_vbi_cap = tvp5150_g_sliced_vbi_cap,\n\t.g_sliced_fmt = tvp5150_g_sliced_fmt,\n\t.s_sliced_fmt = tvp5150_s_sliced_fmt,\n\t.s_raw_fmt = tvp5150_s_raw_fmt,\n};\n\nstatic const struct v4l2_subdev_pad_ops tvp5150_pad_ops = {\n\t.init_cfg = tvp5150_init_cfg,\n\t.enum_mbus_code = tvp5150_enum_mbus_code,\n\t.enum_frame_size = tvp5150_enum_frame_size,\n\t.set_fmt = tvp5150_fill_fmt,\n\t.get_fmt = tvp5150_fill_fmt,\n\t.get_selection = tvp5150_get_selection,\n\t.set_selection = tvp5150_set_selection,\n\t.get_mbus_config = tvp5150_get_mbus_config,\n};\n\nstatic const struct v4l2_subdev_ops tvp5150_ops = {\n\t.core = &tvp5150_core_ops,\n\t.tuner = &tvp5150_tuner_ops,\n\t.video = &tvp5150_video_ops,\n\t.vbi = &tvp5150_vbi_ops,\n\t.pad = &tvp5150_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops tvp5150_internal_ops = {\n\t.registered = tvp5150_registered,\n\t.open = tvp5150_open,\n\t.close = tvp5150_close,\n};\n\n \n\nstatic const struct regmap_range tvp5150_readable_ranges[] = {\n\t{\n\t\t.range_min = TVP5150_VD_IN_SRC_SEL_1,\n\t\t.range_max = TVP5150_AUTOSW_MSK,\n\t}, {\n\t\t.range_min = TVP5150_COLOR_KIL_THSH_CTL,\n\t\t.range_max = TVP5150_CONF_SHARED_PIN,\n\t}, {\n\t\t.range_min = TVP5150_ACT_VD_CROP_ST_MSB,\n\t\t.range_max = TVP5150_HORIZ_SYNC_START,\n\t}, {\n\t\t.range_min = TVP5150_VERT_BLANKING_START,\n\t\t.range_max = TVP5150_INTT_CONFIG_REG_B,\n\t}, {\n\t\t.range_min = TVP5150_VIDEO_STD,\n\t\t.range_max = TVP5150_VIDEO_STD,\n\t}, {\n\t\t.range_min = TVP5150_CB_GAIN_FACT,\n\t\t.range_max = TVP5150_REV_SELECT,\n\t}, {\n\t\t.range_min = TVP5150_MSB_DEV_ID,\n\t\t.range_max = TVP5150_STATUS_REG_5,\n\t}, {\n\t\t.range_min = TVP5150_CC_DATA_INI,\n\t\t.range_max = TVP5150_TELETEXT_FIL_ENA,\n\t}, {\n\t\t.range_min = TVP5150_INT_STATUS_REG_A,\n\t\t.range_max = TVP5150_FIFO_OUT_CTRL,\n\t}, {\n\t\t.range_min = TVP5150_FULL_FIELD_ENA,\n\t\t.range_max = TVP5150_FULL_FIELD_MODE_REG,\n\t},\n};\n\nstatic bool tvp5150_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TVP5150_VERT_LN_COUNT_MSB:\n\tcase TVP5150_VERT_LN_COUNT_LSB:\n\tcase TVP5150_INT_STATUS_REG_A:\n\tcase TVP5150_INT_STATUS_REG_B:\n\tcase TVP5150_INT_ACTIVE_REG_B:\n\tcase TVP5150_STATUS_REG_1:\n\tcase TVP5150_STATUS_REG_2:\n\tcase TVP5150_STATUS_REG_3:\n\tcase TVP5150_STATUS_REG_4:\n\tcase TVP5150_STATUS_REG_5:\n\t \n\tcase TVP5150_VBI_FIFO_READ_DATA:\n\tcase TVP5150_VDP_STATUS_REG:\n\tcase TVP5150_FIFO_WORD_COUNT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_access_table tvp5150_readable_table = {\n\t.yes_ranges = tvp5150_readable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(tvp5150_readable_ranges),\n};\n\nstatic struct regmap_config tvp5150_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xff,\n\n\t.cache_type = REGCACHE_RBTREE,\n\n\t.rd_table = &tvp5150_readable_table,\n\t.volatile_reg = tvp5150_volatile_reg,\n};\n\nstatic int tvp5150_detect_version(struct tvp5150 *core)\n{\n\tstruct v4l2_subdev *sd = &core->sd;\n\tstruct i2c_client *c = v4l2_get_subdevdata(sd);\n\tu8 regs[4];\n\tint res;\n\n\t \n\tres = regmap_bulk_read(core->regmap, TVP5150_MSB_DEV_ID, regs, 4);\n\tif (res < 0) {\n\t\tdev_err(&c->dev, \"reading ID registers failed: %d\\n\", res);\n\t\treturn res;\n\t}\n\n\tcore->dev_id = (regs[0] << 8) | regs[1];\n\tcore->rom_ver = (regs[2] << 8) | regs[3];\n\n\tdev_info(sd->dev, \"tvp%04x (%u.%u) chip found @ 0x%02x (%s)\\n\",\n\t\t  core->dev_id, regs[2], regs[3], c->addr << 1,\n\t\t  c->adapter->name);\n\n\tif (core->dev_id == 0x5150 && core->rom_ver == 0x0321) {\n\t\tdev_info(sd->dev, \"tvp5150a detected.\\n\");\n\t} else if (core->dev_id == 0x5150 && core->rom_ver == 0x0400) {\n\t\tdev_info(sd->dev, \"tvp5150am1 detected.\\n\");\n\n\t\t \n\t\tregmap_write(core->regmap, TVP5150_REV_SELECT, 0);\n\t} else if (core->dev_id == 0x5151 && core->rom_ver == 0x0100) {\n\t\tdev_info(sd->dev, \"tvp5151 detected.\\n\");\n\t} else {\n\t\tdev_info(sd->dev, \"*** unknown tvp%04x chip detected.\\n\",\n\t\t\t  core->dev_id);\n\t}\n\n\treturn 0;\n}\n\nstatic int tvp5150_init(struct i2c_client *c)\n{\n\tstruct gpio_desc *pdn_gpio;\n\tstruct gpio_desc *reset_gpio;\n\n\tpdn_gpio = devm_gpiod_get_optional(&c->dev, \"pdn\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(pdn_gpio))\n\t\treturn PTR_ERR(pdn_gpio);\n\n\tif (pdn_gpio) {\n\t\tgpiod_set_value_cansleep(pdn_gpio, 0);\n\t\t \n\t\tmsleep(20);\n\t}\n\n\treset_gpio = devm_gpiod_get_optional(&c->dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(reset_gpio))\n\t\treturn PTR_ERR(reset_gpio);\n\n\tif (reset_gpio) {\n\t\t \n\t\tndelay(500);\n\t\tgpiod_set_value_cansleep(reset_gpio, 0);\n\t\t \n\t\tusleep_range(200, 250);\n\t}\n\n\treturn 0;\n}\n\n#if defined(CONFIG_MEDIA_CONTROLLER)\nstatic int tvp5150_mc_init(struct tvp5150 *decoder)\n{\n\tstruct v4l2_subdev *sd = &decoder->sd;\n\tunsigned int i;\n\n\tsd->entity.ops = &tvp5150_sd_media_ops;\n\tsd->entity.function = MEDIA_ENT_F_ATV_DECODER;\n\n\tfor (i = 0; i < TVP5150_NUM_PADS - 1; i++) {\n\t\tdecoder->pads[i].flags = MEDIA_PAD_FL_SINK;\n\t\tdecoder->pads[i].sig_type = PAD_SIGNAL_ANALOG;\n\t}\n\n\tdecoder->pads[i].flags = MEDIA_PAD_FL_SOURCE;\n\tdecoder->pads[i].sig_type = PAD_SIGNAL_DV;\n\n\treturn media_entity_pads_init(&sd->entity, TVP5150_NUM_PADS,\n\t\t\t\t      decoder->pads);\n}\n\n#else  \n\nstatic inline int tvp5150_mc_init(struct tvp5150 *decoder)\n{\n\treturn 0;\n}\n#endif  \n\nstatic int tvp5150_validate_connectors(struct tvp5150 *decoder)\n{\n\tstruct device *dev = decoder->sd.dev;\n\tstruct tvp5150_connector *tvpc;\n\tstruct v4l2_fwnode_connector *v4l2c;\n\tunsigned int i;\n\n\tif (!decoder->connectors_num) {\n\t\tdev_err(dev, \"No valid connector found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < decoder->connectors_num; i++) {\n\t\tstruct v4l2_connector_link *link0 = NULL;\n\t\tstruct v4l2_connector_link *link1;\n\n\t\ttvpc = &decoder->connectors[i];\n\t\tv4l2c = &tvpc->base;\n\n\t\tif (v4l2c->type == V4L2_CONN_COMPOSITE) {\n\t\t\tif (v4l2c->nr_of_links != 1) {\n\t\t\t\tdev_err(dev, \"Composite: connector needs 1 link\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tlink0 = v4l2_connector_first_link(v4l2c);\n\t\t\tif (!link0) {\n\t\t\t\tdev_err(dev, \"Composite: invalid first link\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (link0->fwnode_link.remote_id == 1) {\n\t\t\t\tdev_err(dev, \"Composite: invalid endpoint id\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tif (v4l2c->type == V4L2_CONN_SVIDEO) {\n\t\t\tif (v4l2c->nr_of_links != 2) {\n\t\t\t\tdev_err(dev, \"SVideo: connector needs 2 links\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tlink0 = v4l2_connector_first_link(v4l2c);\n\t\t\tif (!link0) {\n\t\t\t\tdev_err(dev, \"SVideo: invalid first link\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tlink1 = v4l2_connector_last_link(v4l2c);\n\t\t\tif (link0->fwnode_link.remote_port ==\n\t\t\t    link1->fwnode_link.remote_port) {\n\t\t\t\tdev_err(dev, \"SVideo: invalid link setup\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tif (!(v4l2c->connector.analog.sdtv_stds & TVP5150_STD_MASK)) {\n\t\t\tdev_err(dev, \"Unsupported tv-norm on connector %s\\n\",\n\t\t\t\tv4l2c->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tvp5150_parse_dt(struct tvp5150 *decoder, struct device_node *np)\n{\n\tstruct device *dev = decoder->sd.dev;\n\tstruct v4l2_fwnode_endpoint bus_cfg = {\n\t\t.bus_type = V4L2_MBUS_UNKNOWN\n\t};\n\tstruct device_node *ep_np;\n\tstruct tvp5150_connector *tvpc;\n\tstruct v4l2_fwnode_connector *v4l2c;\n\tunsigned int flags, ep_num;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tep_num = of_graph_get_endpoint_count(np);\n\tif (ep_num < 2 || ep_num > 5) {\n\t\tdev_err(dev, \"At least 1 input and 1 output must be connected to the device.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor_each_endpoint_of_node(np, ep_np) {\n\t\tstruct fwnode_handle *ep_fwnode = of_fwnode_handle(ep_np);\n\t\tunsigned int next_connector = decoder->connectors_num;\n\t\tstruct of_endpoint ep;\n\n\t\tof_graph_parse_endpoint(ep_np, &ep);\n\t\tif (ep.port > 1 || ep.id > 1) {\n\t\t\tdev_dbg(dev, \"Ignore connector on port@%u/ep@%u\\n\",\n\t\t\t\tep.port, ep.id);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttvpc = &decoder->connectors[next_connector];\n\t\tv4l2c = &tvpc->base;\n\n\t\tif (ep.port == 0 || (ep.port == 1 && ep.id == 0)) {\n\t\t\tret = v4l2_fwnode_connector_parse(ep_fwnode, v4l2c);\n\t\t\tif (ret)\n\t\t\t\tgoto err_put;\n\t\t\tret = v4l2_fwnode_connector_add_link(ep_fwnode, v4l2c);\n\t\t\tif (ret)\n\t\t\t\tgoto err_put;\n\t\t\tdecoder->connectors_num++;\n\t\t} else {\n\t\t\t \n\t\t\tfor (i = 0; i < TVP5150_MAX_CONNECTORS; i++) {\n\t\t\t\ttvpc = &decoder->connectors[i];\n\t\t\t\tv4l2c = &tvpc->base;\n\t\t\t\tif (v4l2c->type == V4L2_CONN_SVIDEO)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret = v4l2_fwnode_connector_add_link(ep_fwnode, v4l2c);\n\t\t\tif (ret)\n\t\t\t\tgoto err_put;\n\t\t}\n\t}\n\n\tret = tvp5150_validate_connectors(decoder);\n\tif (ret)\n\t\tgoto err_free;\n\n\tfor (i = 0; i < decoder->connectors_num; i++) {\n\t\ttvpc = &decoder->connectors[i];\n\t\tv4l2c = &tvpc->base;\n\t\ttvpc->ent.flags = MEDIA_ENT_FL_CONNECTOR;\n\t\ttvpc->ent.function = v4l2c->type == V4L2_CONN_SVIDEO ?\n\t\t\tMEDIA_ENT_F_CONN_SVIDEO : MEDIA_ENT_F_CONN_COMPOSITE;\n\t\ttvpc->ent.name = devm_kasprintf(dev, GFP_KERNEL, \"%s %s\",\n\t\t\t\t\t\tv4l2c->name, v4l2c->label ?\n\t\t\t\t\t\tv4l2c->label : \"\");\n\t\tif (!tvpc->ent.name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free;\n\t\t}\n\t}\n\n\tep_np = of_graph_get_endpoint_by_regs(np, TVP5150_PAD_VID_OUT, 0);\n\tif (!ep_np) {\n\t\tret = -EINVAL;\n\t\tdev_err(dev, \"Error no output endpoint available\\n\");\n\t\tgoto err_free;\n\t}\n\tret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(ep_np), &bus_cfg);\n\tof_node_put(ep_np);\n\tif (ret)\n\t\tgoto err_free;\n\n\tflags = bus_cfg.bus.parallel.flags;\n\tif (bus_cfg.bus_type == V4L2_MBUS_PARALLEL &&\n\t    !(flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH &&\n\t      flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH &&\n\t      flags & V4L2_MBUS_FIELD_EVEN_LOW)) {\n\t\tret = -EINVAL;\n\t\tgoto err_free;\n\t}\n\n\tdecoder->mbus_type = bus_cfg.bus_type;\n\n\treturn 0;\n\nerr_put:\n\tof_node_put(ep_np);\nerr_free:\n\tfor (i = 0; i < TVP5150_MAX_CONNECTORS; i++)\n\t\tv4l2_fwnode_connector_free(&decoder->connectors[i].base);\n\n\treturn ret;\n}\n\nstatic const char * const tvp5150_test_patterns[2] = {\n\t\"Disabled\",\n\t\"Black screen\"\n};\n\nstatic int tvp5150_probe(struct i2c_client *c)\n{\n\tstruct tvp5150 *core;\n\tstruct v4l2_subdev *sd;\n\tstruct device_node *np = c->dev.of_node;\n\tstruct regmap *map;\n\tunsigned int i;\n\tint res;\n\n\t \n\tif (!i2c_check_functionality(c->adapter,\n\t     I2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))\n\t\treturn -EIO;\n\n\tres = tvp5150_init(c);\n\tif (res)\n\t\treturn res;\n\n\tcore = devm_kzalloc(&c->dev, sizeof(*core), GFP_KERNEL);\n\tif (!core)\n\t\treturn -ENOMEM;\n\n\tmap = devm_regmap_init_i2c(c, &tvp5150_config);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tcore->regmap = map;\n\tsd = &core->sd;\n\tv4l2_i2c_subdev_init(sd, c, &tvp5150_ops);\n\tsd->internal_ops = &tvp5150_internal_ops;\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;\n\n\tif (IS_ENABLED(CONFIG_OF) && np) {\n\t\tres = tvp5150_parse_dt(core, np);\n\t\tif (res) {\n\t\t\tdev_err(sd->dev, \"DT parsing error: %d\\n\", res);\n\t\t\treturn res;\n\t\t}\n\t} else {\n\t\t \n\t\tcore->mbus_type = V4L2_MBUS_BT656;\n\t}\n\n\tres = tvp5150_mc_init(core);\n\tif (res)\n\t\treturn res;\n\n\tres = tvp5150_detect_version(core);\n\tif (res < 0)\n\t\treturn res;\n\n\t \n\tfor (i = 0; i < core->connectors_num; i++) {\n\t\tstruct v4l2_fwnode_connector *v4l2c;\n\n\t\tv4l2c = &core->connectors[i].base;\n\t\tcore->norm |= v4l2c->connector.analog.sdtv_stds;\n\t}\n\n\tif (!core->connectors_num)\n\t\tcore->norm = V4L2_STD_ALL;\n\n\tcore->detected_norm = V4L2_STD_UNKNOWN;\n\tcore->input = TVP5150_COMPOSITE1;\n\tcore->enable = true;\n\n\tv4l2_ctrl_handler_init(&core->hdl, 5);\n\tv4l2_ctrl_new_std(&core->hdl, &tvp5150_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(&core->hdl, &tvp5150_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(&core->hdl, &tvp5150_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(&core->hdl, &tvp5150_ctrl_ops,\n\t\t\tV4L2_CID_HUE, -128, 127, 1, 0);\n\tv4l2_ctrl_new_std(&core->hdl, &tvp5150_ctrl_ops,\n\t\t\tV4L2_CID_PIXEL_RATE, 27000000,\n\t\t\t27000000, 1, 27000000);\n\tv4l2_ctrl_new_std_menu_items(&core->hdl, &tvp5150_ctrl_ops,\n\t\t\t\t     V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(tvp5150_test_patterns) - 1,\n\t\t\t\t     0, 0, tvp5150_test_patterns);\n\tsd->ctrl_handler = &core->hdl;\n\tif (core->hdl.error) {\n\t\tres = core->hdl.error;\n\t\tgoto err;\n\t}\n\n\ttvp5150_set_default(tvp5150_read_std(sd), &core->rect);\n\n\tcore->irq = c->irq;\n\ttvp5150_reset(sd, 0);\t \n\tif (c->irq) {\n\t\tres = devm_request_threaded_irq(&c->dev, c->irq, NULL,\n\t\t\t\t\t\ttvp5150_isr, IRQF_TRIGGER_HIGH |\n\t\t\t\t\t\tIRQF_ONESHOT, \"tvp5150\", core);\n\t\tif (res)\n\t\t\tgoto err;\n\t}\n\n\tres = v4l2_async_register_subdev(sd);\n\tif (res < 0)\n\t\tgoto err;\n\n\tif (debug > 1)\n\t\ttvp5150_log_status(sd);\n\n\tpm_runtime_set_active(&c->dev);\n\tpm_runtime_enable(&c->dev);\n\tpm_runtime_idle(&c->dev);\n\n\treturn 0;\n\nerr:\n\tv4l2_ctrl_handler_free(&core->hdl);\n\treturn res;\n}\n\nstatic void tvp5150_remove(struct i2c_client *c)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(c);\n\tstruct tvp5150 *decoder = to_tvp5150(sd);\n\tunsigned int i;\n\n\tdev_dbg_lvl(sd->dev, 1, debug,\n\t\t\"tvp5150.c: removing tvp5150 adapter on address 0x%x\\n\",\n\t\tc->addr << 1);\n\n\tfor (i = 0; i < decoder->connectors_num; i++)\n\t\tv4l2_fwnode_connector_free(&decoder->connectors[i].base);\n\tfor (i = 0; i < decoder->connectors_num; i++) {\n\t\tmedia_device_unregister_entity(&decoder->connectors[i].ent);\n\t\tmedia_entity_cleanup(&decoder->connectors[i].ent);\n\t}\n\tv4l2_async_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(&decoder->hdl);\n\tpm_runtime_disable(&c->dev);\n\tpm_runtime_set_suspended(&c->dev);\n}\n\n \n\nstatic const struct dev_pm_ops tvp5150_pm_ops = {\n\tSET_RUNTIME_PM_OPS(tvp5150_runtime_suspend,\n\t\t\t   tvp5150_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct i2c_device_id tvp5150_id[] = {\n\t{ \"tvp5150\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tvp5150_id);\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id tvp5150_of_match[] = {\n\t{ .compatible = \"ti,tvp5150\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, tvp5150_of_match);\n#endif\n\nstatic struct i2c_driver tvp5150_driver = {\n\t.driver = {\n\t\t.of_match_table = of_match_ptr(tvp5150_of_match),\n\t\t.name\t= \"tvp5150\",\n\t\t.pm\t= &tvp5150_pm_ops,\n\t},\n\t.probe\t\t= tvp5150_probe,\n\t.remove\t\t= tvp5150_remove,\n\t.id_table\t= tvp5150_id,\n};\n\nmodule_i2c_driver(tvp5150_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}