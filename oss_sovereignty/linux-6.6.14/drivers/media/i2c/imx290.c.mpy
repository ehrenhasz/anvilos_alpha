{
  "module_name": "imx290.c",
  "hash_id": "41b250e16452557c8aaa4575a0586ead5af3e6fe26cb4f5c2547333bb60e02a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/imx290.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#include <asm/unaligned.h>\n\n#include <media/media-entity.h>\n#include <media/v4l2-cci.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n#define IMX290_STANDBY\t\t\t\t\tCCI_REG8(0x3000)\n#define IMX290_REGHOLD\t\t\t\t\tCCI_REG8(0x3001)\n#define IMX290_XMSTA\t\t\t\t\tCCI_REG8(0x3002)\n#define IMX290_ADBIT\t\t\t\t\tCCI_REG8(0x3005)\n#define IMX290_ADBIT_10BIT\t\t\t\t(0 << 0)\n#define IMX290_ADBIT_12BIT\t\t\t\t(1 << 0)\n#define IMX290_CTRL_07\t\t\t\t\tCCI_REG8(0x3007)\n#define IMX290_VREVERSE\t\t\t\t\tBIT(0)\n#define IMX290_HREVERSE\t\t\t\t\tBIT(1)\n#define IMX290_WINMODE_1080P\t\t\t\t(0 << 4)\n#define IMX290_WINMODE_720P\t\t\t\t(1 << 4)\n#define IMX290_WINMODE_CROP\t\t\t\t(4 << 4)\n#define IMX290_FR_FDG_SEL\t\t\t\tCCI_REG8(0x3009)\n#define IMX290_BLKLEVEL\t\t\t\t\tCCI_REG16(0x300a)\n#define IMX290_GAIN\t\t\t\t\tCCI_REG8(0x3014)\n#define IMX290_VMAX\t\t\t\t\tCCI_REG24(0x3018)\n#define IMX290_VMAX_MAX\t\t\t\t\t0x3ffff\n#define IMX290_HMAX\t\t\t\t\tCCI_REG16(0x301c)\n#define IMX290_HMAX_MAX\t\t\t\t\t0xffff\n#define IMX290_SHS1\t\t\t\t\tCCI_REG24(0x3020)\n#define IMX290_WINWV_OB\t\t\t\t\tCCI_REG8(0x303a)\n#define IMX290_WINPV\t\t\t\t\tCCI_REG16(0x303c)\n#define IMX290_WINWV\t\t\t\t\tCCI_REG16(0x303e)\n#define IMX290_WINPH\t\t\t\t\tCCI_REG16(0x3040)\n#define IMX290_WINWH\t\t\t\t\tCCI_REG16(0x3042)\n#define IMX290_OUT_CTRL\t\t\t\t\tCCI_REG8(0x3046)\n#define IMX290_ODBIT_10BIT\t\t\t\t(0 << 0)\n#define IMX290_ODBIT_12BIT\t\t\t\t(1 << 0)\n#define IMX290_OPORTSEL_PARALLEL\t\t\t(0x0 << 4)\n#define IMX290_OPORTSEL_LVDS_2CH\t\t\t(0xd << 4)\n#define IMX290_OPORTSEL_LVDS_4CH\t\t\t(0xe << 4)\n#define IMX290_OPORTSEL_LVDS_8CH\t\t\t(0xf << 4)\n#define IMX290_XSOUTSEL\t\t\t\t\tCCI_REG8(0x304b)\n#define IMX290_XSOUTSEL_XVSOUTSEL_HIGH\t\t\t(0 << 0)\n#define IMX290_XSOUTSEL_XVSOUTSEL_VSYNC\t\t\t(2 << 0)\n#define IMX290_XSOUTSEL_XHSOUTSEL_HIGH\t\t\t(0 << 2)\n#define IMX290_XSOUTSEL_XHSOUTSEL_HSYNC\t\t\t(2 << 2)\n#define IMX290_INCKSEL1\t\t\t\t\tCCI_REG8(0x305c)\n#define IMX290_INCKSEL2\t\t\t\t\tCCI_REG8(0x305d)\n#define IMX290_INCKSEL3\t\t\t\t\tCCI_REG8(0x305e)\n#define IMX290_INCKSEL4\t\t\t\t\tCCI_REG8(0x305f)\n#define IMX290_PGCTRL\t\t\t\t\tCCI_REG8(0x308c)\n#define IMX290_ADBIT1\t\t\t\t\tCCI_REG8(0x3129)\n#define IMX290_ADBIT1_10BIT\t\t\t\t0x1d\n#define IMX290_ADBIT1_12BIT\t\t\t\t0x00\n#define IMX290_INCKSEL5\t\t\t\t\tCCI_REG8(0x315e)\n#define IMX290_INCKSEL6\t\t\t\t\tCCI_REG8(0x3164)\n#define IMX290_ADBIT2\t\t\t\t\tCCI_REG8(0x317c)\n#define IMX290_ADBIT2_10BIT\t\t\t\t0x12\n#define IMX290_ADBIT2_12BIT\t\t\t\t0x00\n#define IMX290_CHIP_ID\t\t\t\t\tCCI_REG16(0x319a)\n#define IMX290_ADBIT3\t\t\t\t\tCCI_REG8(0x31ec)\n#define IMX290_ADBIT3_10BIT\t\t\t\t0x37\n#define IMX290_ADBIT3_12BIT\t\t\t\t0x0e\n#define IMX290_REPETITION\t\t\t\tCCI_REG8(0x3405)\n#define IMX290_PHY_LANE_NUM\t\t\t\tCCI_REG8(0x3407)\n#define IMX290_OPB_SIZE_V\t\t\t\tCCI_REG8(0x3414)\n#define IMX290_Y_OUT_SIZE\t\t\t\tCCI_REG16(0x3418)\n#define IMX290_CSI_DT_FMT\t\t\t\tCCI_REG16(0x3441)\n#define IMX290_CSI_DT_FMT_RAW10\t\t\t\t0x0a0a\n#define IMX290_CSI_DT_FMT_RAW12\t\t\t\t0x0c0c\n#define IMX290_CSI_LANE_MODE\t\t\t\tCCI_REG8(0x3443)\n#define IMX290_EXTCK_FREQ\t\t\t\tCCI_REG16(0x3444)\n#define IMX290_TCLKPOST\t\t\t\t\tCCI_REG16(0x3446)\n#define IMX290_THSZERO\t\t\t\t\tCCI_REG16(0x3448)\n#define IMX290_THSPREPARE\t\t\t\tCCI_REG16(0x344a)\n#define IMX290_TCLKTRAIL\t\t\t\tCCI_REG16(0x344c)\n#define IMX290_THSTRAIL\t\t\t\t\tCCI_REG16(0x344e)\n#define IMX290_TCLKZERO\t\t\t\t\tCCI_REG16(0x3450)\n#define IMX290_TCLKPREPARE\t\t\t\tCCI_REG16(0x3452)\n#define IMX290_TLPX\t\t\t\t\tCCI_REG16(0x3454)\n#define IMX290_X_OUT_SIZE\t\t\t\tCCI_REG16(0x3472)\n#define IMX290_INCKSEL7\t\t\t\t\tCCI_REG8(0x3480)\n\n#define IMX290_PGCTRL_REGEN\t\t\t\tBIT(0)\n#define IMX290_PGCTRL_THRU\t\t\t\tBIT(1)\n#define IMX290_PGCTRL_MODE(n)\t\t\t\t((n) << 4)\n\n \n#define IMX290_EXPOSURE_OFFSET\t\t\t\t2\n\n#define IMX290_PIXEL_RATE\t\t\t\t148500000\n\n \n\n#define IMX290_PIXEL_ARRAY_WIDTH\t\t\t1945\n#define IMX290_PIXEL_ARRAY_HEIGHT\t\t\t1097\n#define IMX920_PIXEL_ARRAY_MARGIN_LEFT\t\t\t12\n#define IMX920_PIXEL_ARRAY_MARGIN_RIGHT\t\t\t13\n#define IMX920_PIXEL_ARRAY_MARGIN_TOP\t\t\t8\n#define IMX920_PIXEL_ARRAY_MARGIN_BOTTOM\t\t9\n#define IMX290_PIXEL_ARRAY_RECORDING_WIDTH\t\t1920\n#define IMX290_PIXEL_ARRAY_RECORDING_HEIGHT\t\t1080\n\n \n#define IMX290_BLACK_LEVEL_DEFAULT\t\t\t3840\n\n#define IMX290_NUM_SUPPLIES\t\t\t\t3\n\nenum imx290_colour_variant {\n\tIMX290_VARIANT_COLOUR,\n\tIMX290_VARIANT_MONO,\n\tIMX290_VARIANT_MAX\n};\n\nenum imx290_model {\n\tIMX290_MODEL_IMX290LQR,\n\tIMX290_MODEL_IMX290LLR,\n\tIMX290_MODEL_IMX327LQR,\n};\n\nstruct imx290_model_info {\n\tenum imx290_colour_variant colour_variant;\n\tconst struct cci_reg_sequence *init_regs;\n\tsize_t init_regs_num;\n\tconst char *name;\n};\n\nenum imx290_clk_freq {\n\tIMX290_CLK_37_125,\n\tIMX290_CLK_74_25,\n\tIMX290_NUM_CLK\n};\n\n \nstruct imx290_clk_cfg {\n\tu8 incksel1;\n\tu8 incksel2;\n\tu8 incksel3;\n\tu8 incksel4;\n\tu8 incksel5;\n\tu8 incksel6;\n};\n\nstruct imx290_mode {\n\tu32 width;\n\tu32 height;\n\tu32 hmax_min;\n\tu32 vmax_min;\n\tu8 link_freq_index;\n\tu8 ctrl_07;\n\n\tconst struct cci_reg_sequence *data;\n\tu32 data_size;\n\n\tconst struct imx290_clk_cfg *clk_cfg;\n};\n\nstruct imx290_csi_cfg {\n\tu16 repetition;\n\tu16 tclkpost;\n\tu16 thszero;\n\tu16 thsprepare;\n\tu16 tclktrail;\n\tu16 thstrail;\n\tu16 tclkzero;\n\tu16 tclkprepare;\n\tu16 tlpx;\n};\n\nstruct imx290 {\n\tstruct device *dev;\n\tstruct clk *xclk;\n\tstruct regmap *regmap;\n\tenum imx290_clk_freq xclk_idx;\n\tu8 nlanes;\n\tconst struct imx290_model_info *model;\n\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pad;\n\n\tconst struct imx290_mode *current_mode;\n\n\tstruct regulator_bulk_data supplies[IMX290_NUM_SUPPLIES];\n\tstruct gpio_desc *rst_gpio;\n\n\tstruct v4l2_ctrl_handler ctrls;\n\tstruct v4l2_ctrl *link_freq;\n\tstruct v4l2_ctrl *hblank;\n\tstruct v4l2_ctrl *vblank;\n\tstruct v4l2_ctrl *exposure;\n\tstruct {\n\t\tstruct v4l2_ctrl *hflip;\n\t\tstruct v4l2_ctrl *vflip;\n\t};\n};\n\nstatic inline struct imx290 *to_imx290(struct v4l2_subdev *_sd)\n{\n\treturn container_of(_sd, struct imx290, sd);\n}\n\n \n\nstatic const struct cci_reg_sequence imx290_global_init_settings[] = {\n\t{ IMX290_WINWV_OB, 12 },\n\t{ IMX290_WINPH, 0 },\n\t{ IMX290_WINPV, 0 },\n\t{ IMX290_WINWH, 1948 },\n\t{ IMX290_WINWV, 1097 },\n\t{ IMX290_XSOUTSEL, IMX290_XSOUTSEL_XVSOUTSEL_VSYNC |\n\t\t\t   IMX290_XSOUTSEL_XHSOUTSEL_HSYNC },\n\t{ CCI_REG8(0x3011), 0x02 },\n\t{ CCI_REG8(0x3012), 0x64 },\n\t{ CCI_REG8(0x3013), 0x00 },\n};\n\nstatic const struct cci_reg_sequence imx290_global_init_settings_290[] = {\n\t{ CCI_REG8(0x300f), 0x00 },\n\t{ CCI_REG8(0x3010), 0x21 },\n\t{ CCI_REG8(0x3016), 0x09 },\n\t{ CCI_REG8(0x3070), 0x02 },\n\t{ CCI_REG8(0x3071), 0x11 },\n\t{ CCI_REG8(0x309b), 0x10 },\n\t{ CCI_REG8(0x309c), 0x22 },\n\t{ CCI_REG8(0x30a2), 0x02 },\n\t{ CCI_REG8(0x30a6), 0x20 },\n\t{ CCI_REG8(0x30a8), 0x20 },\n\t{ CCI_REG8(0x30aa), 0x20 },\n\t{ CCI_REG8(0x30ac), 0x20 },\n\t{ CCI_REG8(0x30b0), 0x43 },\n\t{ CCI_REG8(0x3119), 0x9e },\n\t{ CCI_REG8(0x311c), 0x1e },\n\t{ CCI_REG8(0x311e), 0x08 },\n\t{ CCI_REG8(0x3128), 0x05 },\n\t{ CCI_REG8(0x313d), 0x83 },\n\t{ CCI_REG8(0x3150), 0x03 },\n\t{ CCI_REG8(0x317e), 0x00 },\n\t{ CCI_REG8(0x32b8), 0x50 },\n\t{ CCI_REG8(0x32b9), 0x10 },\n\t{ CCI_REG8(0x32ba), 0x00 },\n\t{ CCI_REG8(0x32bb), 0x04 },\n\t{ CCI_REG8(0x32c8), 0x50 },\n\t{ CCI_REG8(0x32c9), 0x10 },\n\t{ CCI_REG8(0x32ca), 0x00 },\n\t{ CCI_REG8(0x32cb), 0x04 },\n\t{ CCI_REG8(0x332c), 0xd3 },\n\t{ CCI_REG8(0x332d), 0x10 },\n\t{ CCI_REG8(0x332e), 0x0d },\n\t{ CCI_REG8(0x3358), 0x06 },\n\t{ CCI_REG8(0x3359), 0xe1 },\n\t{ CCI_REG8(0x335a), 0x11 },\n\t{ CCI_REG8(0x3360), 0x1e },\n\t{ CCI_REG8(0x3361), 0x61 },\n\t{ CCI_REG8(0x3362), 0x10 },\n\t{ CCI_REG8(0x33b0), 0x50 },\n\t{ CCI_REG8(0x33b2), 0x1a },\n\t{ CCI_REG8(0x33b3), 0x04 },\n};\n\n#define IMX290_NUM_CLK_REGS\t2\nstatic const struct cci_reg_sequence xclk_regs[][IMX290_NUM_CLK_REGS] = {\n\t[IMX290_CLK_37_125] = {\n\t\t{ IMX290_EXTCK_FREQ, (37125 * 256) / 1000 },\n\t\t{ IMX290_INCKSEL7, 0x49 },\n\t},\n\t[IMX290_CLK_74_25] = {\n\t\t{ IMX290_EXTCK_FREQ, (74250 * 256) / 1000 },\n\t\t{ IMX290_INCKSEL7, 0x92 },\n\t},\n};\n\nstatic const struct cci_reg_sequence imx290_global_init_settings_327[] = {\n\t{ CCI_REG8(0x309e), 0x4A },\n\t{ CCI_REG8(0x309f), 0x4A },\n\t{ CCI_REG8(0x313b), 0x61 },\n};\n\nstatic const struct cci_reg_sequence imx290_1080p_settings[] = {\n\t \n\t{ IMX290_WINWV_OB, 12 },\n\t{ IMX290_OPB_SIZE_V, 10 },\n\t{ IMX290_X_OUT_SIZE, 1920 },\n\t{ IMX290_Y_OUT_SIZE, 1080 },\n};\n\nstatic const struct cci_reg_sequence imx290_720p_settings[] = {\n\t \n\t{ IMX290_WINWV_OB, 6 },\n\t{ IMX290_OPB_SIZE_V, 4 },\n\t{ IMX290_X_OUT_SIZE, 1280 },\n\t{ IMX290_Y_OUT_SIZE, 720 },\n};\n\nstatic const struct cci_reg_sequence imx290_10bit_settings[] = {\n\t{ IMX290_ADBIT, IMX290_ADBIT_10BIT },\n\t{ IMX290_OUT_CTRL, IMX290_ODBIT_10BIT },\n\t{ IMX290_ADBIT1, IMX290_ADBIT1_10BIT },\n\t{ IMX290_ADBIT2, IMX290_ADBIT2_10BIT },\n\t{ IMX290_ADBIT3, IMX290_ADBIT3_10BIT },\n\t{ IMX290_CSI_DT_FMT, IMX290_CSI_DT_FMT_RAW10 },\n};\n\nstatic const struct cci_reg_sequence imx290_12bit_settings[] = {\n\t{ IMX290_ADBIT, IMX290_ADBIT_12BIT },\n\t{ IMX290_OUT_CTRL, IMX290_ODBIT_12BIT },\n\t{ IMX290_ADBIT1, IMX290_ADBIT1_12BIT },\n\t{ IMX290_ADBIT2, IMX290_ADBIT2_12BIT },\n\t{ IMX290_ADBIT3, IMX290_ADBIT3_12BIT },\n\t{ IMX290_CSI_DT_FMT, IMX290_CSI_DT_FMT_RAW12 },\n};\n\nstatic const struct imx290_csi_cfg imx290_csi_222_75mhz = {\n\t \n\t.repetition = 0x10,\n\t.tclkpost = 87,\n\t.thszero = 55,\n\t.thsprepare = 31,\n\t.tclktrail = 31,\n\t.thstrail = 31,\n\t.tclkzero = 119,\n\t.tclkprepare = 31,\n\t.tlpx = 23,\n};\n\nstatic const struct imx290_csi_cfg imx290_csi_445_5mhz = {\n\t \n\t.repetition = 0x00,\n\t.tclkpost = 119,\n\t.thszero = 103,\n\t.thsprepare = 71,\n\t.tclktrail = 55,\n\t.thstrail = 63,\n\t.tclkzero = 255,\n\t.tclkprepare = 63,\n\t.tlpx = 55,\n};\n\nstatic const struct imx290_csi_cfg imx290_csi_148_5mhz = {\n\t \n\t.repetition = 0x10,\n\t.tclkpost = 79,\n\t.thszero = 47,\n\t.thsprepare = 23,\n\t.tclktrail = 23,\n\t.thstrail = 23,\n\t.tclkzero = 87,\n\t.tclkprepare = 23,\n\t.tlpx = 23,\n};\n\nstatic const struct imx290_csi_cfg imx290_csi_297mhz = {\n\t \n\t.repetition = 0x00,\n\t.tclkpost = 103,\n\t.thszero = 87,\n\t.thsprepare = 47,\n\t.tclktrail = 39,\n\t.thstrail = 47,\n\t.tclkzero = 191,\n\t.tclkprepare = 47,\n\t.tlpx = 39,\n};\n\n \n#define FREQ_INDEX_1080P\t0\n#define FREQ_INDEX_720P\t\t1\nstatic const s64 imx290_link_freq_2lanes[] = {\n\t[FREQ_INDEX_1080P] = 445500000,\n\t[FREQ_INDEX_720P] = 297000000,\n};\n\nstatic const s64 imx290_link_freq_4lanes[] = {\n\t[FREQ_INDEX_1080P] = 222750000,\n\t[FREQ_INDEX_720P] = 148500000,\n};\n\n \nstatic inline const s64 *imx290_link_freqs_ptr(const struct imx290 *imx290)\n{\n\tif (imx290->nlanes == 2)\n\t\treturn imx290_link_freq_2lanes;\n\telse\n\t\treturn imx290_link_freq_4lanes;\n}\n\nstatic inline int imx290_link_freqs_num(const struct imx290 *imx290)\n{\n\tif (imx290->nlanes == 2)\n\t\treturn ARRAY_SIZE(imx290_link_freq_2lanes);\n\telse\n\t\treturn ARRAY_SIZE(imx290_link_freq_4lanes);\n}\n\nstatic const struct imx290_clk_cfg imx290_1080p_clock_config[] = {\n\t[IMX290_CLK_37_125] = {\n\t\t \n\t\t.incksel1 = 0x18,\n\t\t.incksel2 = 0x03,\n\t\t.incksel3 = 0x20,\n\t\t.incksel4 = 0x01,\n\t\t.incksel5 = 0x1a,\n\t\t.incksel6 = 0x1a,\n\t},\n\t[IMX290_CLK_74_25] = {\n\t\t \n\t\t.incksel1 = 0x0c,\n\t\t.incksel2 = 0x03,\n\t\t.incksel3 = 0x10,\n\t\t.incksel4 = 0x01,\n\t\t.incksel5 = 0x1b,\n\t\t.incksel6 = 0x1b,\n\t},\n};\n\nstatic const struct imx290_clk_cfg imx290_720p_clock_config[] = {\n\t[IMX290_CLK_37_125] = {\n\t\t \n\t\t.incksel1 = 0x20,\n\t\t.incksel2 = 0x00,\n\t\t.incksel3 = 0x20,\n\t\t.incksel4 = 0x01,\n\t\t.incksel5 = 0x1a,\n\t\t.incksel6 = 0x1a,\n\t},\n\t[IMX290_CLK_74_25] = {\n\t\t \n\t\t.incksel1 = 0x10,\n\t\t.incksel2 = 0x00,\n\t\t.incksel3 = 0x10,\n\t\t.incksel4 = 0x01,\n\t\t.incksel5 = 0x1b,\n\t\t.incksel6 = 0x1b,\n\t},\n};\n\n \nstatic const struct imx290_mode imx290_modes_2lanes[] = {\n\t{\n\t\t.width = 1920,\n\t\t.height = 1080,\n\t\t.hmax_min = 2200,\n\t\t.vmax_min = 1125,\n\t\t.link_freq_index = FREQ_INDEX_1080P,\n\t\t.ctrl_07 = IMX290_WINMODE_1080P,\n\t\t.data = imx290_1080p_settings,\n\t\t.data_size = ARRAY_SIZE(imx290_1080p_settings),\n\t\t.clk_cfg = imx290_1080p_clock_config,\n\t},\n\t{\n\t\t.width = 1280,\n\t\t.height = 720,\n\t\t.hmax_min = 3300,\n\t\t.vmax_min = 750,\n\t\t.link_freq_index = FREQ_INDEX_720P,\n\t\t.ctrl_07 = IMX290_WINMODE_720P,\n\t\t.data = imx290_720p_settings,\n\t\t.data_size = ARRAY_SIZE(imx290_720p_settings),\n\t\t.clk_cfg = imx290_720p_clock_config,\n\t},\n};\n\nstatic const struct imx290_mode imx290_modes_4lanes[] = {\n\t{\n\t\t.width = 1920,\n\t\t.height = 1080,\n\t\t.hmax_min = 2200,\n\t\t.vmax_min = 1125,\n\t\t.link_freq_index = FREQ_INDEX_1080P,\n\t\t.ctrl_07 = IMX290_WINMODE_1080P,\n\t\t.data = imx290_1080p_settings,\n\t\t.data_size = ARRAY_SIZE(imx290_1080p_settings),\n\t\t.clk_cfg = imx290_1080p_clock_config,\n\t},\n\t{\n\t\t.width = 1280,\n\t\t.height = 720,\n\t\t.hmax_min = 3300,\n\t\t.vmax_min = 750,\n\t\t.link_freq_index = FREQ_INDEX_720P,\n\t\t.ctrl_07 = IMX290_WINMODE_720P,\n\t\t.data = imx290_720p_settings,\n\t\t.data_size = ARRAY_SIZE(imx290_720p_settings),\n\t\t.clk_cfg = imx290_720p_clock_config,\n\t},\n};\n\nstatic inline const struct imx290_mode *imx290_modes_ptr(const struct imx290 *imx290)\n{\n\tif (imx290->nlanes == 2)\n\t\treturn imx290_modes_2lanes;\n\telse\n\t\treturn imx290_modes_4lanes;\n}\n\nstatic inline int imx290_modes_num(const struct imx290 *imx290)\n{\n\tif (imx290->nlanes == 2)\n\t\treturn ARRAY_SIZE(imx290_modes_2lanes);\n\telse\n\t\treturn ARRAY_SIZE(imx290_modes_4lanes);\n}\n\nstruct imx290_format_info {\n\tu32 code[IMX290_VARIANT_MAX];\n\tu8 bpp;\n\tconst struct cci_reg_sequence *regs;\n\tunsigned int num_regs;\n};\n\nstatic const struct imx290_format_info imx290_formats[] = {\n\t{\n\t\t.code = {\n\t\t\t[IMX290_VARIANT_COLOUR] = MEDIA_BUS_FMT_SRGGB10_1X10,\n\t\t\t[IMX290_VARIANT_MONO] = MEDIA_BUS_FMT_Y10_1X10\n\t\t},\n\t\t.bpp = 10,\n\t\t.regs = imx290_10bit_settings,\n\t\t.num_regs = ARRAY_SIZE(imx290_10bit_settings),\n\t}, {\n\t\t.code = {\n\t\t\t[IMX290_VARIANT_COLOUR] = MEDIA_BUS_FMT_SRGGB12_1X12,\n\t\t\t[IMX290_VARIANT_MONO] = MEDIA_BUS_FMT_Y12_1X12\n\t\t},\n\t\t.bpp = 12,\n\t\t.regs = imx290_12bit_settings,\n\t\t.num_regs = ARRAY_SIZE(imx290_12bit_settings),\n\t}\n};\n\nstatic const struct imx290_format_info *\nimx290_format_info(const struct imx290 *imx290, u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(imx290_formats); ++i) {\n\t\tconst struct imx290_format_info *info = &imx290_formats[i];\n\n\t\tif (info->code[imx290->model->colour_variant] == code)\n\t\t\treturn info;\n\t}\n\n\treturn NULL;\n}\n\nstatic int imx290_set_register_array(struct imx290 *imx290,\n\t\t\t\t     const struct cci_reg_sequence *settings,\n\t\t\t\t     unsigned int num_settings)\n{\n\tint ret;\n\n\tret = cci_multi_reg_write(imx290->regmap, settings, num_settings, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tusleep_range(10000, 11000);\n\n\treturn 0;\n}\n\nstatic int imx290_set_clock(struct imx290 *imx290)\n{\n\tconst struct imx290_mode *mode = imx290->current_mode;\n\tenum imx290_clk_freq clk_idx = imx290->xclk_idx;\n\tconst struct imx290_clk_cfg *clk_cfg = &mode->clk_cfg[clk_idx];\n\tint ret;\n\n\tret = imx290_set_register_array(imx290, xclk_regs[clk_idx],\n\t\t\t\t\tIMX290_NUM_CLK_REGS);\n\n\tcci_write(imx290->regmap, IMX290_INCKSEL1, clk_cfg->incksel1, &ret);\n\tcci_write(imx290->regmap, IMX290_INCKSEL2, clk_cfg->incksel2, &ret);\n\tcci_write(imx290->regmap, IMX290_INCKSEL3, clk_cfg->incksel3, &ret);\n\tcci_write(imx290->regmap, IMX290_INCKSEL4, clk_cfg->incksel4, &ret);\n\tcci_write(imx290->regmap, IMX290_INCKSEL5, clk_cfg->incksel5, &ret);\n\tcci_write(imx290->regmap, IMX290_INCKSEL6, clk_cfg->incksel6, &ret);\n\n\treturn ret;\n}\n\nstatic int imx290_set_data_lanes(struct imx290 *imx290)\n{\n\tint ret = 0;\n\n\tcci_write(imx290->regmap, IMX290_PHY_LANE_NUM, imx290->nlanes - 1,\n\t\t  &ret);\n\tcci_write(imx290->regmap, IMX290_CSI_LANE_MODE, imx290->nlanes - 1,\n\t\t  &ret);\n\tcci_write(imx290->regmap, IMX290_FR_FDG_SEL, 0x01, &ret);\n\n\treturn ret;\n}\n\nstatic int imx290_set_black_level(struct imx290 *imx290,\n\t\t\t\t  const struct v4l2_mbus_framefmt *format,\n\t\t\t\t  unsigned int black_level, int *err)\n{\n\tunsigned int bpp = imx290_format_info(imx290, format->code)->bpp;\n\n\treturn cci_write(imx290->regmap, IMX290_BLKLEVEL,\n\t\t\t black_level >> (16 - bpp), err);\n}\n\nstatic int imx290_set_csi_config(struct imx290 *imx290)\n{\n\tconst s64 *link_freqs = imx290_link_freqs_ptr(imx290);\n\tconst struct imx290_csi_cfg *csi_cfg;\n\tint ret = 0;\n\n\tswitch (link_freqs[imx290->current_mode->link_freq_index]) {\n\tcase 445500000:\n\t\tcsi_cfg = &imx290_csi_445_5mhz;\n\t\tbreak;\n\tcase 297000000:\n\t\tcsi_cfg = &imx290_csi_297mhz;\n\t\tbreak;\n\tcase 222750000:\n\t\tcsi_cfg = &imx290_csi_222_75mhz;\n\t\tbreak;\n\tcase 148500000:\n\t\tcsi_cfg = &imx290_csi_148_5mhz;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcci_write(imx290->regmap, IMX290_REPETITION, csi_cfg->repetition, &ret);\n\tcci_write(imx290->regmap, IMX290_TCLKPOST, csi_cfg->tclkpost, &ret);\n\tcci_write(imx290->regmap, IMX290_THSZERO, csi_cfg->thszero, &ret);\n\tcci_write(imx290->regmap, IMX290_THSPREPARE, csi_cfg->thsprepare, &ret);\n\tcci_write(imx290->regmap, IMX290_TCLKTRAIL, csi_cfg->tclktrail, &ret);\n\tcci_write(imx290->regmap, IMX290_THSTRAIL, csi_cfg->thstrail, &ret);\n\tcci_write(imx290->regmap, IMX290_TCLKZERO, csi_cfg->tclkzero, &ret);\n\tcci_write(imx290->regmap, IMX290_TCLKPREPARE, csi_cfg->tclkprepare,\n\t\t  &ret);\n\tcci_write(imx290->regmap, IMX290_TLPX, csi_cfg->tlpx, &ret);\n\n\treturn ret;\n}\n\nstatic int imx290_setup_format(struct imx290 *imx290,\n\t\t\t       const struct v4l2_mbus_framefmt *format)\n{\n\tconst struct imx290_format_info *info;\n\tint ret;\n\n\tinfo = imx290_format_info(imx290, format->code);\n\n\tret = imx290_set_register_array(imx290, info->regs, info->num_regs);\n\tif (ret < 0) {\n\t\tdev_err(imx290->dev, \"Could not set format registers\\n\");\n\t\treturn ret;\n\t}\n\n\treturn imx290_set_black_level(imx290, format,\n\t\t\t\t      IMX290_BLACK_LEVEL_DEFAULT, &ret);\n}\n\n \nstatic void imx290_exposure_update(struct imx290 *imx290,\n\t\t\t\t   const struct imx290_mode *mode)\n{\n\tunsigned int exposure_max;\n\n\texposure_max = imx290->vblank->val + mode->height -\n\t\t       IMX290_EXPOSURE_OFFSET;\n\t__v4l2_ctrl_modify_range(imx290->exposure, 1, exposure_max, 1,\n\t\t\t\t exposure_max);\n}\n\nstatic int imx290_set_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct imx290 *imx290 = container_of(ctrl->handler,\n\t\t\t\t\t     struct imx290, ctrls);\n\tconst struct v4l2_mbus_framefmt *format;\n\tstruct v4l2_subdev_state *state;\n\tint ret = 0, vmax;\n\n\t \n\tif (ctrl->flags & V4L2_CTRL_FLAG_READ_ONLY)\n\t\treturn 0;\n\n\tif (ctrl->id == V4L2_CID_VBLANK) {\n\t\t \n\t\timx290_exposure_update(imx290, imx290->current_mode);\n\t}\n\n\t \n\tif (!pm_runtime_get_if_in_use(imx290->dev))\n\t\treturn 0;\n\n\tstate = v4l2_subdev_get_locked_active_state(&imx290->sd);\n\tformat = v4l2_subdev_get_pad_format(&imx290->sd, state, 0);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_ANALOGUE_GAIN:\n\t\tret = cci_write(imx290->regmap, IMX290_GAIN, ctrl->val, NULL);\n\t\tbreak;\n\n\tcase V4L2_CID_VBLANK:\n\t\tret = cci_write(imx290->regmap, IMX290_VMAX,\n\t\t\t\tctrl->val + imx290->current_mode->height, NULL);\n\t\t \n\t\tctrl = imx290->exposure;\n\t\tfallthrough;\n\tcase V4L2_CID_EXPOSURE:\n\t\tvmax = imx290->vblank->val + imx290->current_mode->height;\n\t\tret = cci_write(imx290->regmap, IMX290_SHS1,\n\t\t\t\tvmax - ctrl->val - 1, NULL);\n\t\tbreak;\n\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tif (ctrl->val) {\n\t\t\timx290_set_black_level(imx290, format, 0, &ret);\n\t\t\tusleep_range(10000, 11000);\n\t\t\tcci_write(imx290->regmap, IMX290_PGCTRL,\n\t\t\t\t  (u8)(IMX290_PGCTRL_REGEN |\n\t\t\t\t       IMX290_PGCTRL_THRU |\n\t\t\t\t       IMX290_PGCTRL_MODE(ctrl->val)), &ret);\n\t\t} else {\n\t\t\tcci_write(imx290->regmap, IMX290_PGCTRL, 0x00, &ret);\n\t\t\tusleep_range(10000, 11000);\n\t\t\timx290_set_black_level(imx290, format,\n\t\t\t\t\t       IMX290_BLACK_LEVEL_DEFAULT, &ret);\n\t\t}\n\t\tbreak;\n\n\tcase V4L2_CID_HBLANK:\n\t\tret = cci_write(imx290->regmap, IMX290_HMAX,\n\t\t\t\tctrl->val + imx290->current_mode->width, NULL);\n\t\tbreak;\n\n\tcase V4L2_CID_HFLIP:\n\tcase V4L2_CID_VFLIP:\n\t{\n\t\tu32 reg;\n\n\t\treg = imx290->current_mode->ctrl_07;\n\t\tif (imx290->hflip->val)\n\t\t\treg |= IMX290_HREVERSE;\n\t\tif (imx290->vflip->val)\n\t\t\treg |= IMX290_VREVERSE;\n\t\tret = cci_write(imx290->regmap, IMX290_CTRL_07, reg, NULL);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tpm_runtime_mark_last_busy(imx290->dev);\n\tpm_runtime_put_autosuspend(imx290->dev);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops imx290_ctrl_ops = {\n\t.s_ctrl = imx290_set_ctrl,\n};\n\nstatic const char * const imx290_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Sequence Pattern 1\",\n\t\"Horizontal Color-bar Chart\",\n\t\"Vertical Color-bar Chart\",\n\t\"Sequence Pattern 2\",\n\t\"Gradation Pattern 1\",\n\t\"Gradation Pattern 2\",\n\t\"000/555h Toggle Pattern\",\n};\n\nstatic void imx290_ctrl_update(struct imx290 *imx290,\n\t\t\t       const struct imx290_mode *mode)\n{\n\tunsigned int hblank_min = mode->hmax_min - mode->width;\n\tunsigned int hblank_max = IMX290_HMAX_MAX - mode->width;\n\tunsigned int vblank_min = mode->vmax_min - mode->height;\n\tunsigned int vblank_max = IMX290_VMAX_MAX - mode->height;\n\n\t__v4l2_ctrl_s_ctrl(imx290->link_freq, mode->link_freq_index);\n\n\t__v4l2_ctrl_modify_range(imx290->hblank, hblank_min, hblank_max, 1,\n\t\t\t\t hblank_min);\n\t__v4l2_ctrl_modify_range(imx290->vblank, vblank_min, vblank_max, 1,\n\t\t\t\t vblank_min);\n}\n\nstatic int imx290_ctrl_init(struct imx290 *imx290)\n{\n\tstruct v4l2_fwnode_device_properties props;\n\tint ret;\n\n\tret = v4l2_fwnode_device_parse(imx290->dev, &props);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv4l2_ctrl_handler_init(&imx290->ctrls, 11);\n\n\t \n\tv4l2_ctrl_new_std(&imx290->ctrls, &imx290_ctrl_ops,\n\t\t\t  V4L2_CID_ANALOGUE_GAIN, 0, 100, 1, 0);\n\n\t \n\timx290->exposure = v4l2_ctrl_new_std(&imx290->ctrls, &imx290_ctrl_ops,\n\t\t\t\t\t     V4L2_CID_EXPOSURE, 1, 65535, 1,\n\t\t\t\t\t     65535);\n\n\t \n\timx290->link_freq =\n\t\tv4l2_ctrl_new_int_menu(&imx290->ctrls, &imx290_ctrl_ops,\n\t\t\t\t       V4L2_CID_LINK_FREQ,\n\t\t\t\t       imx290_link_freqs_num(imx290) - 1, 0,\n\t\t\t\t       imx290_link_freqs_ptr(imx290));\n\tif (imx290->link_freq)\n\t\timx290->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tv4l2_ctrl_new_std(&imx290->ctrls, &imx290_ctrl_ops, V4L2_CID_PIXEL_RATE,\n\t\t\t  IMX290_PIXEL_RATE, IMX290_PIXEL_RATE, 1,\n\t\t\t  IMX290_PIXEL_RATE);\n\n\tv4l2_ctrl_new_std_menu_items(&imx290->ctrls, &imx290_ctrl_ops,\n\t\t\t\t     V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(imx290_test_pattern_menu) - 1,\n\t\t\t\t     0, 0, imx290_test_pattern_menu);\n\n\t \n\timx290->hblank = v4l2_ctrl_new_std(&imx290->ctrls, &imx290_ctrl_ops,\n\t\t\t\t\t   V4L2_CID_HBLANK, 1, 1, 1, 1);\n\n\timx290->vblank = v4l2_ctrl_new_std(&imx290->ctrls, &imx290_ctrl_ops,\n\t\t\t\t\t   V4L2_CID_VBLANK, 1, 1, 1, 1);\n\n\timx290->hflip = v4l2_ctrl_new_std(&imx290->ctrls, &imx290_ctrl_ops,\n\t\t\t\t\t  V4L2_CID_HFLIP, 0, 1, 1, 0);\n\timx290->vflip = v4l2_ctrl_new_std(&imx290->ctrls, &imx290_ctrl_ops,\n\t\t\t\t\t  V4L2_CID_VFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_cluster(2, &imx290->hflip);\n\n\tv4l2_ctrl_new_fwnode_properties(&imx290->ctrls, &imx290_ctrl_ops,\n\t\t\t\t\t&props);\n\n\timx290->sd.ctrl_handler = &imx290->ctrls;\n\n\tif (imx290->ctrls.error) {\n\t\tret = imx290->ctrls.error;\n\t\tv4l2_ctrl_handler_free(&imx290->ctrls);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic int imx290_start_streaming(struct imx290 *imx290,\n\t\t\t\t  struct v4l2_subdev_state *state)\n{\n\tconst struct v4l2_mbus_framefmt *format;\n\tint ret;\n\n\t \n\tret = imx290_set_register_array(imx290, imx290_global_init_settings,\n\t\t\t\t\tARRAY_SIZE(imx290_global_init_settings));\n\tif (ret < 0) {\n\t\tdev_err(imx290->dev, \"Could not set init registers\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = imx290_set_register_array(imx290, imx290->model->init_regs,\n\t\t\t\t\timx290->model->init_regs_num);\n\tif (ret < 0) {\n\t\tdev_err(imx290->dev, \"Could not set model specific init registers\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = imx290_set_clock(imx290);\n\tif (ret < 0) {\n\t\tdev_err(imx290->dev, \"Could not set clocks - %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = imx290_set_data_lanes(imx290);\n\tif (ret < 0) {\n\t\tdev_err(imx290->dev, \"Could not set data lanes - %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = imx290_set_csi_config(imx290);\n\tif (ret < 0) {\n\t\tdev_err(imx290->dev, \"Could not set csi cfg - %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tformat = v4l2_subdev_get_pad_format(&imx290->sd, state, 0);\n\tret = imx290_setup_format(imx290, format);\n\tif (ret < 0) {\n\t\tdev_err(imx290->dev, \"Could not set frame format - %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = imx290_set_register_array(imx290, imx290->current_mode->data,\n\t\t\t\t\timx290->current_mode->data_size);\n\tif (ret < 0) {\n\t\tdev_err(imx290->dev, \"Could not set current mode - %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = __v4l2_ctrl_handler_setup(imx290->sd.ctrl_handler);\n\tif (ret) {\n\t\tdev_err(imx290->dev, \"Could not sync v4l2 controls - %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcci_write(imx290->regmap, IMX290_STANDBY, 0x00, &ret);\n\n\tmsleep(30);\n\n\t \n\treturn cci_write(imx290->regmap, IMX290_XMSTA, 0x00, &ret);\n}\n\n \nstatic int imx290_stop_streaming(struct imx290 *imx290)\n{\n\tint ret = 0;\n\n\tcci_write(imx290->regmap, IMX290_STANDBY, 0x01, &ret);\n\n\tmsleep(30);\n\n\treturn cci_write(imx290->regmap, IMX290_XMSTA, 0x01, &ret);\n}\n\nstatic int imx290_set_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct imx290 *imx290 = to_imx290(sd);\n\tstruct v4l2_subdev_state *state;\n\tint ret = 0;\n\n\tstate = v4l2_subdev_lock_and_get_active_state(sd);\n\n\tif (enable) {\n\t\tret = pm_runtime_resume_and_get(imx290->dev);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\n\t\tret = imx290_start_streaming(imx290, state);\n\t\tif (ret) {\n\t\t\tdev_err(imx290->dev, \"Start stream failed\\n\");\n\t\t\tpm_runtime_put_sync(imx290->dev);\n\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\timx290_stop_streaming(imx290);\n\t\tpm_runtime_mark_last_busy(imx290->dev);\n\t\tpm_runtime_put_autosuspend(imx290->dev);\n\t}\n\n\t \n\t__v4l2_ctrl_grab(imx290->vflip, enable);\n\t__v4l2_ctrl_grab(imx290->hflip, enable);\n\nunlock:\n\tv4l2_subdev_unlock_state(state);\n\treturn ret;\n}\n\nstatic int imx290_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tconst struct imx290 *imx290 = to_imx290(sd);\n\n\tif (code->index >= ARRAY_SIZE(imx290_formats))\n\t\treturn -EINVAL;\n\n\tcode->code = imx290_formats[code->index].code[imx290->model->colour_variant];\n\n\treturn 0;\n}\n\nstatic int imx290_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tconst struct imx290 *imx290 = to_imx290(sd);\n\tconst struct imx290_mode *imx290_modes = imx290_modes_ptr(imx290);\n\n\tif (!imx290_format_info(imx290, fse->code))\n\t\treturn -EINVAL;\n\n\tif (fse->index >= imx290_modes_num(imx290))\n\t\treturn -EINVAL;\n\n\tfse->min_width = imx290_modes[fse->index].width;\n\tfse->max_width = imx290_modes[fse->index].width;\n\tfse->min_height = imx290_modes[fse->index].height;\n\tfse->max_height = imx290_modes[fse->index].height;\n\n\treturn 0;\n}\n\nstatic int imx290_set_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *fmt)\n{\n\tstruct imx290 *imx290 = to_imx290(sd);\n\tconst struct imx290_mode *mode;\n\tstruct v4l2_mbus_framefmt *format;\n\n\tmode = v4l2_find_nearest_size(imx290_modes_ptr(imx290),\n\t\t\t\t      imx290_modes_num(imx290), width, height,\n\t\t\t\t      fmt->format.width, fmt->format.height);\n\n\tfmt->format.width = mode->width;\n\tfmt->format.height = mode->height;\n\n\tif (!imx290_format_info(imx290, fmt->format.code))\n\t\tfmt->format.code = imx290_formats[0].code[imx290->model->colour_variant];\n\n\tfmt->format.field = V4L2_FIELD_NONE;\n\tfmt->format.colorspace = V4L2_COLORSPACE_RAW;\n\tfmt->format.ycbcr_enc = V4L2_YCBCR_ENC_601;\n\tfmt->format.quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\tfmt->format.xfer_func = V4L2_XFER_FUNC_NONE;\n\n\tformat = v4l2_subdev_get_pad_format(sd, sd_state, 0);\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\timx290->current_mode = mode;\n\n\t\timx290_ctrl_update(imx290, mode);\n\t\timx290_exposure_update(imx290, mode);\n\t}\n\n\t*format = fmt->format;\n\n\treturn 0;\n}\n\nstatic int imx290_get_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct imx290 *imx290 = to_imx290(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP: {\n\t\tformat = v4l2_subdev_get_pad_format(sd, sd_state, 0);\n\n\t\t \n\t\tsel->r.top = IMX920_PIXEL_ARRAY_MARGIN_TOP\n\t\t\t   + (IMX290_PIXEL_ARRAY_RECORDING_HEIGHT - format->height) / 2\n\t\t\t   + imx290->vflip->val;\n\t\tsel->r.left = IMX920_PIXEL_ARRAY_MARGIN_LEFT\n\t\t\t    + (IMX290_PIXEL_ARRAY_RECORDING_WIDTH - format->width) / 2\n\t\t\t    + imx290->hflip->val;\n\t\tsel->r.width = format->width;\n\t\tsel->r.height = format->height;\n\n\t\treturn 0;\n\t}\n\n\tcase V4L2_SEL_TGT_NATIVE_SIZE:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.top = 0;\n\t\tsel->r.left = 0;\n\t\tsel->r.width = IMX290_PIXEL_ARRAY_WIDTH;\n\t\tsel->r.height = IMX290_PIXEL_ARRAY_HEIGHT;\n\n\t\treturn 0;\n\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tsel->r.top = IMX920_PIXEL_ARRAY_MARGIN_TOP;\n\t\tsel->r.left = IMX920_PIXEL_ARRAY_MARGIN_LEFT;\n\t\tsel->r.width = IMX290_PIXEL_ARRAY_RECORDING_WIDTH;\n\t\tsel->r.height = IMX290_PIXEL_ARRAY_RECORDING_HEIGHT;\n\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int imx290_entity_init_cfg(struct v4l2_subdev *subdev,\n\t\t\t\t  struct v4l2_subdev_state *sd_state)\n{\n\tstruct v4l2_subdev_format fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_TRY,\n\t\t.format = {\n\t\t\t.width = 1920,\n\t\t\t.height = 1080,\n\t\t},\n\t};\n\n\timx290_set_fmt(subdev, sd_state, &fmt);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops imx290_core_ops = {\n\t.subscribe_event = v4l2_ctrl_subdev_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n};\n\nstatic const struct v4l2_subdev_video_ops imx290_video_ops = {\n\t.s_stream = imx290_set_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops imx290_pad_ops = {\n\t.init_cfg = imx290_entity_init_cfg,\n\t.enum_mbus_code = imx290_enum_mbus_code,\n\t.enum_frame_size = imx290_enum_frame_size,\n\t.get_fmt = v4l2_subdev_get_fmt,\n\t.set_fmt = imx290_set_fmt,\n\t.get_selection = imx290_get_selection,\n};\n\nstatic const struct v4l2_subdev_ops imx290_subdev_ops = {\n\t.core = &imx290_core_ops,\n\t.video = &imx290_video_ops,\n\t.pad = &imx290_pad_ops,\n};\n\nstatic const struct media_entity_operations imx290_subdev_entity_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic int imx290_subdev_init(struct imx290 *imx290)\n{\n\tstruct i2c_client *client = to_i2c_client(imx290->dev);\n\tstruct v4l2_subdev_state *state;\n\tint ret;\n\n\timx290->current_mode = &imx290_modes_ptr(imx290)[0];\n\n\tv4l2_i2c_subdev_init(&imx290->sd, client, &imx290_subdev_ops);\n\timx290->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |\n\t\t\t    V4L2_SUBDEV_FL_HAS_EVENTS;\n\timx290->sd.dev = imx290->dev;\n\timx290->sd.entity.ops = &imx290_subdev_entity_ops;\n\timx290->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\n\timx290->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tret = media_entity_pads_init(&imx290->sd.entity, 1, &imx290->pad);\n\tif (ret < 0) {\n\t\tdev_err(imx290->dev, \"Could not register media entity\\n\");\n\t\treturn ret;\n\t}\n\n\tret = imx290_ctrl_init(imx290);\n\tif (ret < 0) {\n\t\tdev_err(imx290->dev, \"Control initialization error %d\\n\", ret);\n\t\tgoto err_media;\n\t}\n\n\timx290->sd.state_lock = imx290->ctrls.lock;\n\n\tret = v4l2_subdev_init_finalize(&imx290->sd);\n\tif (ret < 0) {\n\t\tdev_err(imx290->dev, \"subdev initialization error %d\\n\", ret);\n\t\tgoto err_ctrls;\n\t}\n\n\tstate = v4l2_subdev_lock_and_get_active_state(&imx290->sd);\n\timx290_ctrl_update(imx290, imx290->current_mode);\n\tv4l2_subdev_unlock_state(state);\n\n\treturn 0;\n\nerr_ctrls:\n\tv4l2_ctrl_handler_free(&imx290->ctrls);\nerr_media:\n\tmedia_entity_cleanup(&imx290->sd.entity);\n\treturn ret;\n}\n\nstatic void imx290_subdev_cleanup(struct imx290 *imx290)\n{\n\tv4l2_subdev_cleanup(&imx290->sd);\n\tmedia_entity_cleanup(&imx290->sd.entity);\n\tv4l2_ctrl_handler_free(&imx290->ctrls);\n}\n\n \n\nstatic int imx290_power_on(struct imx290 *imx290)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(imx290->xclk);\n\tif (ret) {\n\t\tdev_err(imx290->dev, \"Failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(imx290->supplies),\n\t\t\t\t    imx290->supplies);\n\tif (ret) {\n\t\tdev_err(imx290->dev, \"Failed to enable regulators\\n\");\n\t\tclk_disable_unprepare(imx290->xclk);\n\t\treturn ret;\n\t}\n\n\tusleep_range(1, 2);\n\tgpiod_set_value_cansleep(imx290->rst_gpio, 0);\n\tusleep_range(30000, 31000);\n\n\treturn 0;\n}\n\nstatic void imx290_power_off(struct imx290 *imx290)\n{\n\tclk_disable_unprepare(imx290->xclk);\n\tgpiod_set_value_cansleep(imx290->rst_gpio, 1);\n\tregulator_bulk_disable(ARRAY_SIZE(imx290->supplies), imx290->supplies);\n}\n\nstatic int imx290_runtime_resume(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct imx290 *imx290 = to_imx290(sd);\n\n\treturn imx290_power_on(imx290);\n}\n\nstatic int imx290_runtime_suspend(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct imx290 *imx290 = to_imx290(sd);\n\n\timx290_power_off(imx290);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops imx290_pm_ops = {\n\tRUNTIME_PM_OPS(imx290_runtime_suspend, imx290_runtime_resume, NULL)\n};\n\n \n\nstatic const char * const imx290_supply_name[IMX290_NUM_SUPPLIES] = {\n\t\"vdda\",\n\t\"vddd\",\n\t\"vdddo\",\n};\n\nstatic int imx290_get_regulators(struct device *dev, struct imx290 *imx290)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(imx290->supplies); i++)\n\t\timx290->supplies[i].supply = imx290_supply_name[i];\n\n\treturn devm_regulator_bulk_get(dev, ARRAY_SIZE(imx290->supplies),\n\t\t\t\t       imx290->supplies);\n}\n\nstatic int imx290_init_clk(struct imx290 *imx290)\n{\n\tu32 xclk_freq;\n\tint ret;\n\n\tret = device_property_read_u32(imx290->dev, \"clock-frequency\",\n\t\t\t\t       &xclk_freq);\n\tif (ret) {\n\t\tdev_err(imx290->dev, \"Could not get xclk frequency\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tswitch (xclk_freq) {\n\tcase 37125000:\n\t\timx290->xclk_idx = IMX290_CLK_37_125;\n\t\tbreak;\n\tcase 74250000:\n\t\timx290->xclk_idx = IMX290_CLK_74_25;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(imx290->dev, \"External clock frequency %u is not supported\\n\",\n\t\t\txclk_freq);\n\t\treturn -EINVAL;\n\t}\n\n\tret = clk_set_rate(imx290->xclk, xclk_freq);\n\tif (ret) {\n\t\tdev_err(imx290->dev, \"Could not set xclk frequency\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic s64 imx290_check_link_freqs(const struct imx290 *imx290,\n\t\t\t\t   const struct v4l2_fwnode_endpoint *ep)\n{\n\tint i, j;\n\tconst s64 *freqs = imx290_link_freqs_ptr(imx290);\n\tint freqs_count = imx290_link_freqs_num(imx290);\n\n\tfor (i = 0; i < freqs_count; i++) {\n\t\tfor (j = 0; j < ep->nr_of_link_frequencies; j++)\n\t\t\tif (freqs[i] == ep->link_frequencies[j])\n\t\t\t\tbreak;\n\t\tif (j == ep->nr_of_link_frequencies)\n\t\t\treturn freqs[i];\n\t}\n\treturn 0;\n}\n\nstatic const struct imx290_model_info imx290_models[] = {\n\t[IMX290_MODEL_IMX290LQR] = {\n\t\t.colour_variant = IMX290_VARIANT_COLOUR,\n\t\t.init_regs = imx290_global_init_settings_290,\n\t\t.init_regs_num = ARRAY_SIZE(imx290_global_init_settings_290),\n\t\t.name = \"imx290\",\n\t},\n\t[IMX290_MODEL_IMX290LLR] = {\n\t\t.colour_variant = IMX290_VARIANT_MONO,\n\t\t.init_regs = imx290_global_init_settings_290,\n\t\t.init_regs_num = ARRAY_SIZE(imx290_global_init_settings_290),\n\t\t.name = \"imx290\",\n\t},\n\t[IMX290_MODEL_IMX327LQR] = {\n\t\t.colour_variant = IMX290_VARIANT_COLOUR,\n\t\t.init_regs = imx290_global_init_settings_327,\n\t\t.init_regs_num = ARRAY_SIZE(imx290_global_init_settings_327),\n\t\t.name = \"imx327\",\n\t},\n};\n\nstatic int imx290_parse_dt(struct imx290 *imx290)\n{\n\t \n\tstruct v4l2_fwnode_endpoint ep = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY\n\t};\n\tstruct fwnode_handle *endpoint;\n\tint ret;\n\ts64 fq;\n\n\timx290->model = of_device_get_match_data(imx290->dev);\n\n\tendpoint = fwnode_graph_get_next_endpoint(dev_fwnode(imx290->dev), NULL);\n\tif (!endpoint) {\n\t\tdev_err(imx290->dev, \"Endpoint node not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = v4l2_fwnode_endpoint_alloc_parse(endpoint, &ep);\n\tfwnode_handle_put(endpoint);\n\tif (ret == -ENXIO) {\n\t\tdev_err(imx290->dev, \"Unsupported bus type, should be CSI2\\n\");\n\t\tgoto done;\n\t} else if (ret) {\n\t\tdev_err(imx290->dev, \"Parsing endpoint node failed\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\timx290->nlanes = ep.bus.mipi_csi2.num_data_lanes;\n\tif (imx290->nlanes != 2 && imx290->nlanes != 4) {\n\t\tdev_err(imx290->dev, \"Invalid data lanes: %d\\n\", imx290->nlanes);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tdev_dbg(imx290->dev, \"Using %u data lanes\\n\", imx290->nlanes);\n\n\tif (!ep.nr_of_link_frequencies) {\n\t\tdev_err(imx290->dev, \"link-frequency property not found in DT\\n\");\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t \n\tfq = imx290_check_link_freqs(imx290, &ep);\n\tif (fq) {\n\t\tdev_err(imx290->dev, \"Link frequency of %lld is not supported\\n\",\n\t\t\tfq);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tret = 0;\n\ndone:\n\tv4l2_fwnode_endpoint_free(&ep);\n\treturn ret;\n}\n\nstatic int imx290_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct imx290 *imx290;\n\tint ret;\n\n\timx290 = devm_kzalloc(dev, sizeof(*imx290), GFP_KERNEL);\n\tif (!imx290)\n\t\treturn -ENOMEM;\n\n\timx290->dev = dev;\n\timx290->regmap = devm_cci_regmap_init_i2c(client, 16);\n\tif (IS_ERR(imx290->regmap)) {\n\t\tdev_err(dev, \"Unable to initialize I2C\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = imx290_parse_dt(imx290);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\timx290->xclk = devm_clk_get(dev, \"xclk\");\n\tif (IS_ERR(imx290->xclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(imx290->xclk),\n\t\t\t\t     \"Could not get xclk\\n\");\n\n\tret = imx290_get_regulators(dev, imx290);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Cannot get regulators\\n\");\n\n\timx290->rst_gpio = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t   GPIOD_OUT_HIGH);\n\tif (IS_ERR(imx290->rst_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(imx290->rst_gpio),\n\t\t\t\t     \"Cannot get reset gpio\\n\");\n\n\t \n\tret = imx290_init_clk(imx290);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = imx290_power_on(imx290);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Could not power on the device\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tpm_runtime_set_active(dev);\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_set_autosuspend_delay(dev, 1000);\n\tpm_runtime_use_autosuspend(dev);\n\n\t \n\tret = imx290_subdev_init(imx290);\n\tif (ret)\n\t\tgoto err_pm;\n\n\tv4l2_i2c_subdev_set_name(&imx290->sd, client,\n\t\t\t\t imx290->model->name, NULL);\n\n\t \n\tret = v4l2_async_register_subdev(&imx290->sd);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Could not register v4l2 device\\n\");\n\t\tgoto err_subdev;\n\t}\n\n\t \n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n\nerr_subdev:\n\timx290_subdev_cleanup(imx290);\nerr_pm:\n\tpm_runtime_disable(dev);\n\tpm_runtime_put_noidle(dev);\n\timx290_power_off(imx290);\n\treturn ret;\n}\n\nstatic void imx290_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct imx290 *imx290 = to_imx290(sd);\n\n\tv4l2_async_unregister_subdev(sd);\n\timx290_subdev_cleanup(imx290);\n\n\t \n\tpm_runtime_disable(imx290->dev);\n\tif (!pm_runtime_status_suspended(imx290->dev))\n\t\timx290_power_off(imx290);\n\tpm_runtime_set_suspended(imx290->dev);\n}\n\nstatic const struct of_device_id imx290_of_match[] = {\n\t{\n\t\t \n\t\t.compatible = \"sony,imx290\",\n\t\t.data = &imx290_models[IMX290_MODEL_IMX290LQR],\n\t}, {\n\t\t.compatible = \"sony,imx290lqr\",\n\t\t.data = &imx290_models[IMX290_MODEL_IMX290LQR],\n\t}, {\n\t\t.compatible = \"sony,imx290llr\",\n\t\t.data = &imx290_models[IMX290_MODEL_IMX290LLR],\n\t}, {\n\t\t.compatible = \"sony,imx327lqr\",\n\t\t.data = &imx290_models[IMX290_MODEL_IMX327LQR],\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, imx290_of_match);\n\nstatic struct i2c_driver imx290_i2c_driver = {\n\t.probe = imx290_probe,\n\t.remove = imx290_remove,\n\t.driver = {\n\t\t.name = \"imx290\",\n\t\t.pm = pm_ptr(&imx290_pm_ops),\n\t\t.of_match_table = imx290_of_match,\n\t},\n};\n\nmodule_i2c_driver(imx290_i2c_driver);\n\nMODULE_DESCRIPTION(\"Sony IMX290 CMOS Image Sensor Driver\");\nMODULE_AUTHOR(\"FRAMOS GmbH\");\nMODULE_AUTHOR(\"Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}