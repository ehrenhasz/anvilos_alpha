{
  "module_name": "saa6752hs.c",
  "hash_id": "cb549f1d09f49d5da0ef6d881ac2e68b94a2396d3c79b32efb0088933181484f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/saa6752hs.c",
  "human_readable_source": "\n  \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/i2c.h>\n#include <linux/types.h>\n#include <linux/videodev2.h>\n#include <linux/init.h>\n#include <linux/crc32.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-common.h>\n\n#define MPEG_VIDEO_TARGET_BITRATE_MAX  27000\n#define MPEG_VIDEO_MAX_BITRATE_MAX     27000\n#define MPEG_TOTAL_TARGET_BITRATE_MAX  27000\n#define MPEG_PID_MAX ((1 << 14) - 1)\n\n\nMODULE_DESCRIPTION(\"device driver for saa6752hs MPEG2 encoder\");\nMODULE_AUTHOR(\"Andrew de Quincey\");\nMODULE_LICENSE(\"GPL\");\n\nenum saa6752hs_videoformat {\n\tSAA6752HS_VF_D1 = 0,     \n\tSAA6752HS_VF_2_3_D1 = 1, \n\tSAA6752HS_VF_1_2_D1 = 2, \n\tSAA6752HS_VF_SIF = 3,    \n\tSAA6752HS_VF_UNKNOWN,\n};\n\nstruct saa6752hs_mpeg_params {\n\t \n\t__u16\t\t\t\tts_pid_pmt;\n\t__u16\t\t\t\tts_pid_audio;\n\t__u16\t\t\t\tts_pid_video;\n\t__u16\t\t\t\tts_pid_pcr;\n\n\t \n\tenum v4l2_mpeg_audio_encoding    au_encoding;\n\tenum v4l2_mpeg_audio_l2_bitrate  au_l2_bitrate;\n\tenum v4l2_mpeg_audio_ac3_bitrate au_ac3_bitrate;\n\n\t \n\tenum v4l2_mpeg_video_aspect\tvi_aspect;\n\tenum v4l2_mpeg_video_bitrate_mode vi_bitrate_mode;\n\t__u32\t\t\t\tvi_bitrate;\n\t__u32\t\t\t\tvi_bitrate_peak;\n};\n\nstatic const struct v4l2_format v4l2_format_table[] =\n{\n\t[SAA6752HS_VF_D1] =\n\t\t{ .fmt = { .pix = { .width = 720, .height = 576 }}},\n\t[SAA6752HS_VF_2_3_D1] =\n\t\t{ .fmt = { .pix = { .width = 480, .height = 576 }}},\n\t[SAA6752HS_VF_1_2_D1] =\n\t\t{ .fmt = { .pix = { .width = 352, .height = 576 }}},\n\t[SAA6752HS_VF_SIF] =\n\t\t{ .fmt = { .pix = { .width = 352, .height = 288 }}},\n\t[SAA6752HS_VF_UNKNOWN] =\n\t\t{ .fmt = { .pix = { .width = 0, .height = 0}}},\n};\n\nstruct saa6752hs_state {\n\tstruct v4l2_subdev            sd;\n\tstruct v4l2_ctrl_handler      hdl;\n\tstruct {  \n\t\tstruct v4l2_ctrl *video_bitrate_mode;\n\t\tstruct v4l2_ctrl *video_bitrate;\n\t\tstruct v4l2_ctrl *video_bitrate_peak;\n\t};\n\tu32\t\t\t      revision;\n\tint\t\t\t      has_ac3;\n\tstruct saa6752hs_mpeg_params  params;\n\tenum saa6752hs_videoformat    video_format;\n\tv4l2_std_id                   standard;\n};\n\nenum saa6752hs_command {\n\tSAA6752HS_COMMAND_RESET = 0,\n\tSAA6752HS_COMMAND_STOP = 1,\n\tSAA6752HS_COMMAND_START = 2,\n\tSAA6752HS_COMMAND_PAUSE = 3,\n\tSAA6752HS_COMMAND_RECONFIGURE = 4,\n\tSAA6752HS_COMMAND_SLEEP = 5,\n\tSAA6752HS_COMMAND_RECONFIGURE_FORCE = 6,\n\n\tSAA6752HS_COMMAND_MAX\n};\n\nstatic inline struct saa6752hs_state *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct saa6752hs_state, sd);\n}\n\n \n\nstatic const u8 PAT[] = {\n\t0xc2,  \n\t0x00,  \n\n\t0x47,  \n\t0x40, 0x00,  \n\t0x10,  \n\n\t0x00,  \n\n\t0x00,  \n\t0xb0, 0x0d,  \n\n\t0x00, 0x01,  \n\n\t0xc1,  \n\n\t0x00, 0x00,  \n\n\t0x00, 0x01,  \n\n\t0xe0, 0x00,  \n\n\t0x00, 0x00, 0x00, 0x00  \n};\n\nstatic const u8 PMT[] = {\n\t0xc2,  \n\t0x01,  \n\n\t0x47,  \n\t0x40, 0x00,  \n\t0x10,  \n\n\t0x00,  \n\n\t0x02,  \n\t0xb0, 0x17,  \n\n\t0x00, 0x01,  \n\n\t0xc1,  \n\n\t0x00, 0x00,  \n\n\t0xe0, 0x00,  \n\n\t0xf0, 0x00,  \n\n\t0x02, 0xe0, 0x00, 0xf0, 0x00,  \n\t0x04, 0xe0, 0x00, 0xf0, 0x00,  \n\n\t0x00, 0x00, 0x00, 0x00  \n};\n\nstatic const u8 PMT_AC3[] = {\n\t0xc2,  \n\t0x01,  \n\t0x47,  \n\n\t0x40,  \n\t0x10,  \n\t0x10,  \n\n\t0x00,  \n\n\t0x02,  \n\t0xb0, 0x1a,  \n\n\t0x00, 0x01,  \n\n\t0xc1,  \n\n\t0x00, 0x00,  \n\n\t0xe1, 0x04,  \n\n\t0xf0, 0x00,  \n\n\t0x02, 0xe1, 0x00, 0xf0, 0x00,  \n\t0x06, 0xe1, 0x03, 0xf0, 0x03,  \n\t0x6a,  \n\t0x01,  \n\t0x00,  \n\n\t0xED, 0xDE, 0x2D, 0xF3  \n};\n\nstatic const struct saa6752hs_mpeg_params param_defaults =\n{\n\t.ts_pid_pmt      = 16,\n\t.ts_pid_video    = 260,\n\t.ts_pid_audio    = 256,\n\t.ts_pid_pcr      = 259,\n\n\t.vi_aspect       = V4L2_MPEG_VIDEO_ASPECT_4x3,\n\t.vi_bitrate      = 4000,\n\t.vi_bitrate_peak = 6000,\n\t.vi_bitrate_mode = V4L2_MPEG_VIDEO_BITRATE_MODE_VBR,\n\n\t.au_encoding     = V4L2_MPEG_AUDIO_ENCODING_LAYER_2,\n\t.au_l2_bitrate   = V4L2_MPEG_AUDIO_L2_BITRATE_256K,\n\t.au_ac3_bitrate  = V4L2_MPEG_AUDIO_AC3_BITRATE_256K,\n};\n\n \n\nstatic int saa6752hs_chip_command(struct i2c_client *client,\n\t\t\t\t  enum saa6752hs_command command)\n{\n\tunsigned char buf[3];\n\tunsigned long timeout;\n\tint status = 0;\n\n\t \n\tswitch(command) {\n\tcase SAA6752HS_COMMAND_RESET:\n\t\tbuf[0] = 0x00;\n\t\tbreak;\n\n\tcase SAA6752HS_COMMAND_STOP:\n\t\tbuf[0] = 0x03;\n\t\tbreak;\n\n\tcase SAA6752HS_COMMAND_START:\n\t\tbuf[0] = 0x02;\n\t\tbreak;\n\n\tcase SAA6752HS_COMMAND_PAUSE:\n\t\tbuf[0] = 0x04;\n\t\tbreak;\n\n\tcase SAA6752HS_COMMAND_RECONFIGURE:\n\t\tbuf[0] = 0x05;\n\t\tbreak;\n\n\tcase SAA6752HS_COMMAND_SLEEP:\n\t\tbuf[0] = 0x06;\n\t\tbreak;\n\n\tcase SAA6752HS_COMMAND_RECONFIGURE_FORCE:\n\t\tbuf[0] = 0x07;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ti2c_master_send(client, buf, 1);\n\ttimeout = jiffies + HZ * 3;\n\tfor (;;) {\n\t\t \n\t\tbuf[0] = 0x10;\n\t\ti2c_master_send(client, buf, 1);\n\t\ti2c_master_recv(client, buf, 1);\n\n\t\tif (!(buf[0] & 0x20))\n\t\t\tbreak;\n\t\tif (time_after(jiffies,timeout)) {\n\t\t\tstatus = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(10);\n\t}\n\n\t \n\tmsleep(50);\n\n\treturn status;\n}\n\n\nstatic inline void set_reg8(struct i2c_client *client, uint8_t reg, uint8_t val)\n{\n\tu8 buf[2];\n\n\tbuf[0] = reg;\n\tbuf[1] = val;\n\ti2c_master_send(client, buf, 2);\n}\n\nstatic inline void set_reg16(struct i2c_client *client, uint8_t reg, uint16_t val)\n{\n\tu8 buf[3];\n\n\tbuf[0] = reg;\n\tbuf[1] = val >> 8;\n\tbuf[2] = val & 0xff;\n\ti2c_master_send(client, buf, 3);\n}\n\nstatic int saa6752hs_set_bitrate(struct i2c_client *client,\n\t\t\t\t struct saa6752hs_state *h)\n{\n\tstruct saa6752hs_mpeg_params *params = &h->params;\n\tint tot_bitrate;\n\tint is_384k;\n\n\t \n\tset_reg8(client, 0x71,\n\t\tparams->vi_bitrate_mode != V4L2_MPEG_VIDEO_BITRATE_MODE_VBR);\n\n\t \n\tif (params->vi_bitrate_mode == V4L2_MPEG_VIDEO_BITRATE_MODE_VBR) {\n\t\t \n\t\tset_reg16(client, 0x80, params->vi_bitrate);\n\n\t\t \n\t\tset_reg16(client, 0x81, params->vi_bitrate_peak);\n\t\ttot_bitrate = params->vi_bitrate_peak;\n\t} else {\n\t\t \n\t\tset_reg16(client, 0x81, params->vi_bitrate);\n\t\ttot_bitrate = params->vi_bitrate;\n\t}\n\n\t \n\tset_reg8(client, 0x93,\n\t\t\tparams->au_encoding == V4L2_MPEG_AUDIO_ENCODING_AC3);\n\n\t \n\tif (params->au_encoding == V4L2_MPEG_AUDIO_ENCODING_AC3)\n\t\tis_384k = V4L2_MPEG_AUDIO_AC3_BITRATE_384K == params->au_ac3_bitrate;\n\telse\n\t\tis_384k = V4L2_MPEG_AUDIO_L2_BITRATE_384K == params->au_l2_bitrate;\n\tset_reg8(client, 0x94, is_384k);\n\ttot_bitrate += is_384k ? 384 : 256;\n\n\t \n\ttot_bitrate += 768;\n\tif (tot_bitrate > MPEG_TOTAL_TARGET_BITRATE_MAX)\n\t\ttot_bitrate = MPEG_TOTAL_TARGET_BITRATE_MAX;\n\n\t \n\tset_reg16(client, 0xb1, tot_bitrate);\n\treturn 0;\n}\n\nstatic int saa6752hs_try_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct saa6752hs_state *h =\n\t\tcontainer_of(ctrl->handler, struct saa6752hs_state, hdl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\n\t\t \n\t\tif (ctrl->val == V4L2_MPEG_VIDEO_BITRATE_MODE_VBR &&\n\t\t    h->video_bitrate_peak->val < h->video_bitrate->val)\n\t\t\th->video_bitrate_peak->val = h->video_bitrate->val;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int saa6752hs_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct saa6752hs_state *h =\n\t\tcontainer_of(ctrl->handler, struct saa6752hs_state, hdl);\n\tstruct saa6752hs_mpeg_params *params = &h->params;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_MPEG_STREAM_TYPE:\n\t\tbreak;\n\tcase V4L2_CID_MPEG_STREAM_PID_PMT:\n\t\tparams->ts_pid_pmt = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_STREAM_PID_AUDIO:\n\t\tparams->ts_pid_audio = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_STREAM_PID_VIDEO:\n\t\tparams->ts_pid_video = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_STREAM_PID_PCR:\n\t\tparams->ts_pid_pcr = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_AUDIO_ENCODING:\n\t\tparams->au_encoding = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_AUDIO_L2_BITRATE:\n\t\tparams->au_l2_bitrate = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_AUDIO_AC3_BITRATE:\n\t\tparams->au_ac3_bitrate = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ:\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_ENCODING:\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_ASPECT:\n\t\tparams->vi_aspect = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\n\t\tparams->vi_bitrate_mode = ctrl->val;\n\t\tparams->vi_bitrate = h->video_bitrate->val / 1000;\n\t\tparams->vi_bitrate_peak = h->video_bitrate_peak->val / 1000;\n\t\tv4l2_ctrl_activate(h->video_bitrate_peak,\n\t\t\t\tctrl->val == V4L2_MPEG_VIDEO_BITRATE_MODE_VBR);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int saa6752hs_init(struct v4l2_subdev *sd, u32 leading_null_bytes)\n{\n\tunsigned char buf[9], buf2[4];\n\tstruct saa6752hs_state *h = to_state(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tunsigned size;\n\tu32 crc;\n\tunsigned char localPAT[256];\n\tunsigned char localPMT[256];\n\n\t \n\tset_reg8(client, 0x41, h->video_format);\n\n\t \n\tset_reg8(client, 0x40, (h->standard & V4L2_STD_525_60) ? 1 : 0);\n\n\t \n\tsaa6752hs_set_bitrate(client, h);\n\n\t \n\tset_reg16(client, 0x72, 0x030d);\n\n\t \n\tset_reg8(client, 0x82, 0x04);\n\n\t \n\tset_reg8(client, 0x83, 0x0c);\n\n\t \n\tset_reg8(client, 0xd0, 0x81);\n\n\t \n\tset_reg8(client, 0xb0, 0x05);\n\n\t \n\tset_reg16(client, 0xf6, leading_null_bytes);\n\n\t \n\tmemcpy(localPAT, PAT, sizeof(PAT));\n\tlocalPAT[17] = 0xe0 | ((h->params.ts_pid_pmt >> 8) & 0x0f);\n\tlocalPAT[18] = h->params.ts_pid_pmt & 0xff;\n\tcrc = crc32_be(~0, &localPAT[7], sizeof(PAT) - 7 - 4);\n\tlocalPAT[sizeof(PAT) - 4] = (crc >> 24) & 0xFF;\n\tlocalPAT[sizeof(PAT) - 3] = (crc >> 16) & 0xFF;\n\tlocalPAT[sizeof(PAT) - 2] = (crc >> 8) & 0xFF;\n\tlocalPAT[sizeof(PAT) - 1] = crc & 0xFF;\n\n\t \n\tif (h->params.au_encoding == V4L2_MPEG_AUDIO_ENCODING_AC3) {\n\t\tsize = sizeof(PMT_AC3);\n\t\tmemcpy(localPMT, PMT_AC3, size);\n\t} else {\n\t\tsize = sizeof(PMT);\n\t\tmemcpy(localPMT, PMT, size);\n\t}\n\tlocalPMT[3] = 0x40 | ((h->params.ts_pid_pmt >> 8) & 0x0f);\n\tlocalPMT[4] = h->params.ts_pid_pmt & 0xff;\n\tlocalPMT[15] = 0xE0 | ((h->params.ts_pid_pcr >> 8) & 0x0F);\n\tlocalPMT[16] = h->params.ts_pid_pcr & 0xFF;\n\tlocalPMT[20] = 0xE0 | ((h->params.ts_pid_video >> 8) & 0x0F);\n\tlocalPMT[21] = h->params.ts_pid_video & 0xFF;\n\tlocalPMT[25] = 0xE0 | ((h->params.ts_pid_audio >> 8) & 0x0F);\n\tlocalPMT[26] = h->params.ts_pid_audio & 0xFF;\n\tcrc = crc32_be(~0, &localPMT[7], size - 7 - 4);\n\tlocalPMT[size - 4] = (crc >> 24) & 0xFF;\n\tlocalPMT[size - 3] = (crc >> 16) & 0xFF;\n\tlocalPMT[size - 2] = (crc >> 8) & 0xFF;\n\tlocalPMT[size - 1] = crc & 0xFF;\n\n\t \n\tset_reg16(client, 0xc1, h->params.ts_pid_audio);\n\n\t \n\tset_reg16(client, 0xc0, h->params.ts_pid_video);\n\n\t \n\tset_reg16(client, 0xc4, h->params.ts_pid_pcr);\n\n\t \n\ti2c_master_send(client, localPAT, sizeof(PAT));\n\ti2c_master_send(client, localPMT, size);\n\n\t \n\tset_reg8(client, 0xa4, 1);\n\tset_reg8(client, 0xa4, 0);\n\n\t \n\tsaa6752hs_chip_command(client, SAA6752HS_COMMAND_START);\n\n\t \n\tbuf[0] = 0xE1;\n\tbuf[1] = 0xA7;\n\tbuf[2] = 0xFE;\n\tbuf[3] = 0x82;\n\tbuf[4] = 0xB0;\n\ti2c_master_send(client, buf, 5);\n\ti2c_master_recv(client, buf2, 4);\n\n\t \n\tbuf[0] = 0xE0;\n\tbuf[1] = 0xA7;\n\tbuf[2] = 0xFE;\n\tbuf[3] = 0x82;\n\tbuf[4] = 0xB0;\n\tbuf[5] = buf2[0];\n\tswitch (h->params.vi_aspect) {\n\tcase V4L2_MPEG_VIDEO_ASPECT_16x9:\n\t\tbuf[6] = buf2[1] | 0x40;\n\t\tbreak;\n\tcase V4L2_MPEG_VIDEO_ASPECT_4x3:\n\tdefault:\n\t\tbuf[6] = buf2[1] & 0xBF;\n\t\tbreak;\n\t}\n\tbuf[7] = buf2[2];\n\tbuf[8] = buf2[3];\n\ti2c_master_send(client, buf, 9);\n\n\treturn 0;\n}\n\nstatic int saa6752hs_get_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *f = &format->format;\n\tstruct saa6752hs_state *h = to_state(sd);\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tif (h->video_format == SAA6752HS_VF_UNKNOWN)\n\t\th->video_format = SAA6752HS_VF_D1;\n\tf->width = v4l2_format_table[h->video_format].fmt.pix.width;\n\tf->height = v4l2_format_table[h->video_format].fmt.pix.height;\n\tf->code = MEDIA_BUS_FMT_FIXED;\n\tf->field = V4L2_FIELD_INTERLACED;\n\tf->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\treturn 0;\n}\n\nstatic int saa6752hs_set_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *f = &format->format;\n\tstruct saa6752hs_state *h = to_state(sd);\n\tint dist_352, dist_480, dist_720;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tf->code = MEDIA_BUS_FMT_FIXED;\n\n\tdist_352 = abs(f->width - 352);\n\tdist_480 = abs(f->width - 480);\n\tdist_720 = abs(f->width - 720);\n\tif (dist_720 < dist_480) {\n\t\tf->width = 720;\n\t\tf->height = 576;\n\t} else if (dist_480 < dist_352) {\n\t\tf->width = 480;\n\t\tf->height = 576;\n\t} else {\n\t\tf->width = 352;\n\t\tif (abs(f->height - 576) < abs(f->height - 288))\n\t\t\tf->height = 576;\n\t\telse\n\t\t\tf->height = 288;\n\t}\n\tf->field = V4L2_FIELD_INTERLACED;\n\tf->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tsd_state->pads->try_fmt = *f;\n\t\treturn 0;\n\t}\n\n\t \n\n\tif (f->code != MEDIA_BUS_FMT_FIXED)\n\t\treturn -EINVAL;\n\n\tif (f->width == 720)\n\t\th->video_format = SAA6752HS_VF_D1;\n\telse if (f->width == 480)\n\t\th->video_format = SAA6752HS_VF_2_3_D1;\n\telse if (f->height == 576)\n\t\th->video_format = SAA6752HS_VF_1_2_D1;\n\telse\n\t\th->video_format = SAA6752HS_VF_SIF;\n\treturn 0;\n}\n\nstatic int saa6752hs_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct saa6752hs_state *h = to_state(sd);\n\n\th->standard = std;\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_ctrl_ops saa6752hs_ctrl_ops = {\n\t.try_ctrl = saa6752hs_try_ctrl,\n\t.s_ctrl = saa6752hs_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops saa6752hs_core_ops = {\n\t.init = saa6752hs_init,\n};\n\nstatic const struct v4l2_subdev_video_ops saa6752hs_video_ops = {\n\t.s_std = saa6752hs_s_std,\n};\n\nstatic const struct v4l2_subdev_pad_ops saa6752hs_pad_ops = {\n\t.get_fmt = saa6752hs_get_fmt,\n\t.set_fmt = saa6752hs_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops saa6752hs_ops = {\n\t.core = &saa6752hs_core_ops,\n\t.video = &saa6752hs_video_ops,\n\t.pad = &saa6752hs_pad_ops,\n};\n\nstatic int saa6752hs_probe(struct i2c_client *client)\n{\n\tstruct saa6752hs_state *h;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_ctrl_handler *hdl;\n\tu8 addr = 0x13;\n\tu8 data[12];\n\n\tv4l_info(client, \"chip found @ 0x%x (%s)\\n\",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\th = devm_kzalloc(&client->dev, sizeof(*h), GFP_KERNEL);\n\tif (h == NULL)\n\t\treturn -ENOMEM;\n\tsd = &h->sd;\n\tv4l2_i2c_subdev_init(sd, client, &saa6752hs_ops);\n\n\ti2c_master_send(client, &addr, 1);\n\ti2c_master_recv(client, data, sizeof(data));\n\th->revision = (data[8] << 8) | data[9];\n\th->has_ac3 = 0;\n\tif (h->revision == 0x0206) {\n\t\th->has_ac3 = 1;\n\t\tv4l_info(client, \"supports AC-3\\n\");\n\t}\n\th->params = param_defaults;\n\n\thdl = &h->hdl;\n\tv4l2_ctrl_handler_init(hdl, 14);\n\tv4l2_ctrl_new_std_menu(hdl, &saa6752hs_ctrl_ops,\n\t\tV4L2_CID_MPEG_AUDIO_ENCODING,\n\t\th->has_ac3 ? V4L2_MPEG_AUDIO_ENCODING_AC3 :\n\t\t\tV4L2_MPEG_AUDIO_ENCODING_LAYER_2,\n\t\t0x0d, V4L2_MPEG_AUDIO_ENCODING_LAYER_2);\n\n\tv4l2_ctrl_new_std_menu(hdl, &saa6752hs_ctrl_ops,\n\t\tV4L2_CID_MPEG_AUDIO_L2_BITRATE,\n\t\tV4L2_MPEG_AUDIO_L2_BITRATE_384K,\n\t\t~((1 << V4L2_MPEG_AUDIO_L2_BITRATE_256K) |\n\t\t  (1 << V4L2_MPEG_AUDIO_L2_BITRATE_384K)),\n\t\tV4L2_MPEG_AUDIO_L2_BITRATE_256K);\n\n\tif (h->has_ac3)\n\t\tv4l2_ctrl_new_std_menu(hdl, &saa6752hs_ctrl_ops,\n\t\t\tV4L2_CID_MPEG_AUDIO_AC3_BITRATE,\n\t\t\tV4L2_MPEG_AUDIO_AC3_BITRATE_384K,\n\t\t\t~((1 << V4L2_MPEG_AUDIO_AC3_BITRATE_256K) |\n\t\t\t  (1 << V4L2_MPEG_AUDIO_AC3_BITRATE_384K)),\n\t\t\tV4L2_MPEG_AUDIO_AC3_BITRATE_256K);\n\n\tv4l2_ctrl_new_std_menu(hdl, &saa6752hs_ctrl_ops,\n\t\tV4L2_CID_MPEG_AUDIO_SAMPLING_FREQ,\n\t\tV4L2_MPEG_AUDIO_SAMPLING_FREQ_48000,\n\t\t~(1 << V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000),\n\t\tV4L2_MPEG_AUDIO_SAMPLING_FREQ_48000);\n\n\tv4l2_ctrl_new_std_menu(hdl, &saa6752hs_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_ENCODING,\n\t\tV4L2_MPEG_VIDEO_ENCODING_MPEG_2,\n\t\t~(1 << V4L2_MPEG_VIDEO_ENCODING_MPEG_2),\n\t\tV4L2_MPEG_VIDEO_ENCODING_MPEG_2);\n\n\tv4l2_ctrl_new_std_menu(hdl, &saa6752hs_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_ASPECT,\n\t\tV4L2_MPEG_VIDEO_ASPECT_16x9, 0x01,\n\t\tV4L2_MPEG_VIDEO_ASPECT_4x3);\n\n\th->video_bitrate_peak = v4l2_ctrl_new_std(hdl, &saa6752hs_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_BITRATE_PEAK,\n\t\t1000000, 27000000, 1000, 8000000);\n\n\tv4l2_ctrl_new_std_menu(hdl, &saa6752hs_ctrl_ops,\n\t\tV4L2_CID_MPEG_STREAM_TYPE,\n\t\tV4L2_MPEG_STREAM_TYPE_MPEG2_TS,\n\t\t~(1 << V4L2_MPEG_STREAM_TYPE_MPEG2_TS),\n\t\tV4L2_MPEG_STREAM_TYPE_MPEG2_TS);\n\n\th->video_bitrate_mode = v4l2_ctrl_new_std_menu(hdl, &saa6752hs_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_BITRATE_MODE,\n\t\tV4L2_MPEG_VIDEO_BITRATE_MODE_CBR, 0,\n\t\tV4L2_MPEG_VIDEO_BITRATE_MODE_VBR);\n\th->video_bitrate = v4l2_ctrl_new_std(hdl, &saa6752hs_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_BITRATE, 1000000, 27000000, 1000, 6000000);\n\tv4l2_ctrl_new_std(hdl, &saa6752hs_ctrl_ops,\n\t\tV4L2_CID_MPEG_STREAM_PID_PMT, 0, (1 << 14) - 1, 1, 16);\n\tv4l2_ctrl_new_std(hdl, &saa6752hs_ctrl_ops,\n\t\tV4L2_CID_MPEG_STREAM_PID_AUDIO, 0, (1 << 14) - 1, 1, 260);\n\tv4l2_ctrl_new_std(hdl, &saa6752hs_ctrl_ops,\n\t\tV4L2_CID_MPEG_STREAM_PID_VIDEO, 0, (1 << 14) - 1, 1, 256);\n\tv4l2_ctrl_new_std(hdl, &saa6752hs_ctrl_ops,\n\t\tV4L2_CID_MPEG_STREAM_PID_PCR, 0, (1 << 14) - 1, 1, 259);\n\tsd->ctrl_handler = hdl;\n\tif (hdl->error) {\n\t\tint err = hdl->error;\n\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\treturn err;\n\t}\n\tv4l2_ctrl_cluster(3, &h->video_bitrate_mode);\n\tv4l2_ctrl_handler_setup(hdl);\n\th->standard = 0;  \n\treturn 0;\n}\n\nstatic void saa6752hs_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\n\tv4l2_device_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(&to_state(sd)->hdl);\n}\n\nstatic const struct i2c_device_id saa6752hs_id[] = {\n\t{ \"saa6752hs\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, saa6752hs_id);\n\nstatic struct i2c_driver saa6752hs_driver = {\n\t.driver = {\n\t\t.name\t= \"saa6752hs\",\n\t},\n\t.probe\t\t= saa6752hs_probe,\n\t.remove\t\t= saa6752hs_remove,\n\t.id_table\t= saa6752hs_id,\n};\n\nmodule_i2c_driver(saa6752hs_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}