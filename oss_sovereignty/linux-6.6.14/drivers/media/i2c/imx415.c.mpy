{
  "module_name": "imx415.c",
  "hash_id": "4a3d0450198b6003d267ca5cfe463ae8e846cd215f9296450e6095cd6dee223d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/imx415.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n#define IMX415_PIXEL_ARRAY_TOP\t  0\n#define IMX415_PIXEL_ARRAY_LEFT\t  0\n#define IMX415_PIXEL_ARRAY_WIDTH  3864\n#define IMX415_PIXEL_ARRAY_HEIGHT 2192\n#define IMX415_PIXEL_ARRAY_VBLANK 58\n\n#define IMX415_NUM_CLK_PARAM_REGS 11\n\n#define IMX415_REG_8BIT(n)\t  ((1 << 16) | (n))\n#define IMX415_REG_16BIT(n)\t  ((2 << 16) | (n))\n#define IMX415_REG_24BIT(n)\t  ((3 << 16) | (n))\n#define IMX415_REG_SIZE_SHIFT\t  16\n#define IMX415_REG_ADDR_MASK\t  0xffff\n\n#define IMX415_MODE\t\t  IMX415_REG_8BIT(0x3000)\n#define IMX415_MODE_OPERATING\t  (0)\n#define IMX415_MODE_STANDBY\t  BIT(0)\n#define IMX415_REGHOLD\t\t  IMX415_REG_8BIT(0x3001)\n#define IMX415_REGHOLD_INVALID\t  (0)\n#define IMX415_REGHOLD_VALID\t  BIT(0)\n#define IMX415_XMSTA\t\t  IMX415_REG_8BIT(0x3002)\n#define IMX415_XMSTA_START\t  (0)\n#define IMX415_XMSTA_STOP\t  BIT(0)\n#define IMX415_BCWAIT_TIME\t  IMX415_REG_16BIT(0x3008)\n#define IMX415_CPWAIT_TIME\t  IMX415_REG_16BIT(0x300A)\n#define IMX415_WINMODE\t\t  IMX415_REG_8BIT(0x301C)\n#define IMX415_ADDMODE\t\t  IMX415_REG_8BIT(0x3022)\n#define IMX415_REVERSE\t\t  IMX415_REG_8BIT(0x3030)\n#define IMX415_HREVERSE_SHIFT\t  (0)\n#define IMX415_VREVERSE_SHIFT\t  BIT(0)\n#define IMX415_ADBIT\t\t  IMX415_REG_8BIT(0x3031)\n#define IMX415_MDBIT\t\t  IMX415_REG_8BIT(0x3032)\n#define IMX415_SYS_MODE\t\t  IMX415_REG_8BIT(0x3033)\n#define IMX415_OUTSEL\t\t  IMX415_REG_8BIT(0x30C0)\n#define IMX415_DRV\t\t  IMX415_REG_8BIT(0x30C1)\n#define IMX415_VMAX\t\t  IMX415_REG_24BIT(0x3024)\n#define IMX415_HMAX\t\t  IMX415_REG_16BIT(0x3028)\n#define IMX415_SHR0\t\t  IMX415_REG_24BIT(0x3050)\n#define IMX415_GAIN_PCG_0\t  IMX415_REG_16BIT(0x3090)\n#define IMX415_AGAIN_MIN\t  0\n#define IMX415_AGAIN_MAX\t  100\n#define IMX415_AGAIN_STEP\t  1\n#define IMX415_BLKLEVEL\t\t  IMX415_REG_16BIT(0x30E2)\n#define IMX415_BLKLEVEL_DEFAULT\t  50\n#define IMX415_TPG_EN_DUOUT\t  IMX415_REG_8BIT(0x30E4)\n#define IMX415_TPG_PATSEL_DUOUT\t  IMX415_REG_8BIT(0x30E6)\n#define IMX415_TPG_COLORWIDTH\t  IMX415_REG_8BIT(0x30E8)\n#define IMX415_TESTCLKEN_MIPI\t  IMX415_REG_8BIT(0x3110)\n#define IMX415_INCKSEL1\t\t  IMX415_REG_8BIT(0x3115)\n#define IMX415_INCKSEL2\t\t  IMX415_REG_8BIT(0x3116)\n#define IMX415_INCKSEL3\t\t  IMX415_REG_16BIT(0x3118)\n#define IMX415_INCKSEL4\t\t  IMX415_REG_16BIT(0x311A)\n#define IMX415_INCKSEL5\t\t  IMX415_REG_8BIT(0x311E)\n#define IMX415_DIG_CLP_MODE\t  IMX415_REG_8BIT(0x32C8)\n#define IMX415_WRJ_OPEN\t\t  IMX415_REG_8BIT(0x3390)\n#define IMX415_SENSOR_INFO\t  IMX415_REG_16BIT(0x3F12)\n#define IMX415_SENSOR_INFO_MASK\t  0xFFF\n#define IMX415_CHIP_ID\t\t  0x514\n#define IMX415_LANEMODE\t\t  IMX415_REG_16BIT(0x4001)\n#define IMX415_LANEMODE_2\t  1\n#define IMX415_LANEMODE_4\t  3\n#define IMX415_TXCLKESC_FREQ\t  IMX415_REG_16BIT(0x4004)\n#define IMX415_INCKSEL6\t\t  IMX415_REG_8BIT(0x400C)\n#define IMX415_TCLKPOST\t\t  IMX415_REG_16BIT(0x4018)\n#define IMX415_TCLKPREPARE\t  IMX415_REG_16BIT(0x401A)\n#define IMX415_TCLKTRAIL\t  IMX415_REG_16BIT(0x401C)\n#define IMX415_TCLKZERO\t\t  IMX415_REG_16BIT(0x401E)\n#define IMX415_THSPREPARE\t  IMX415_REG_16BIT(0x4020)\n#define IMX415_THSZERO\t\t  IMX415_REG_16BIT(0x4022)\n#define IMX415_THSTRAIL\t\t  IMX415_REG_16BIT(0x4024)\n#define IMX415_THSEXIT\t\t  IMX415_REG_16BIT(0x4026)\n#define IMX415_TLPX\t\t  IMX415_REG_16BIT(0x4028)\n#define IMX415_INCKSEL7\t\t  IMX415_REG_8BIT(0x4074)\n\nstruct imx415_reg {\n\tu32 address;\n\tu32 val;\n};\n\nstatic const char *const imx415_supply_names[] = {\n\t\"dvdd\",\n\t\"ovdd\",\n\t\"avdd\",\n};\n\n \nstatic const s64 link_freq_menu_items[] = {\n\t594000000 / 2,\t720000000 / 2,\t891000000 / 2,\n\t1440000000 / 2, 1485000000 / 2,\n};\n\nstruct imx415_clk_params {\n\tu64 lane_rate;\n\tu64 inck;\n\tstruct imx415_reg regs[IMX415_NUM_CLK_PARAM_REGS];\n};\n\n \nstatic const struct imx415_clk_params imx415_clk_params[] = {\n\t{\n\t\t.lane_rate = 594000000,\n\t\t.inck = 27000000,\n\t\t.regs[0] = { IMX415_BCWAIT_TIME, 0x05D },\n\t\t.regs[1] = { IMX415_CPWAIT_TIME, 0x042 },\n\t\t.regs[2] = { IMX415_SYS_MODE, 0x7 },\n\t\t.regs[3] = { IMX415_INCKSEL1, 0x00 },\n\t\t.regs[4] = { IMX415_INCKSEL2, 0x23 },\n\t\t.regs[5] = { IMX415_INCKSEL3, 0x084 },\n\t\t.regs[6] = { IMX415_INCKSEL4, 0x0E7 },\n\t\t.regs[7] = { IMX415_INCKSEL5, 0x23 },\n\t\t.regs[8] = { IMX415_INCKSEL6, 0x0 },\n\t\t.regs[9] = { IMX415_INCKSEL7, 0x1 },\n\t\t.regs[10] = { IMX415_TXCLKESC_FREQ, 0x06C0 },\n\t},\n\t{\n\t\t.lane_rate = 720000000,\n\t\t.inck = 24000000,\n\t\t.regs[0] = { IMX415_BCWAIT_TIME, 0x054 },\n\t\t.regs[1] = { IMX415_CPWAIT_TIME, 0x03B },\n\t\t.regs[2] = { IMX415_SYS_MODE, 0x9 },\n\t\t.regs[3] = { IMX415_INCKSEL1, 0x00 },\n\t\t.regs[4] = { IMX415_INCKSEL2, 0x23 },\n\t\t.regs[5] = { IMX415_INCKSEL3, 0x0B4 },\n\t\t.regs[6] = { IMX415_INCKSEL4, 0x0FC },\n\t\t.regs[7] = { IMX415_INCKSEL5, 0x23 },\n\t\t.regs[8] = { IMX415_INCKSEL6, 0x0 },\n\t\t.regs[9] = { IMX415_INCKSEL7, 0x1 },\n\t\t.regs[10] = { IMX415_TXCLKESC_FREQ, 0x0600 },\n\t},\n\t{\n\t\t.lane_rate = 891000000,\n\t\t.inck = 27000000,\n\t\t.regs[0] = { IMX415_BCWAIT_TIME, 0x05D },\n\t\t.regs[1] = { IMX415_CPWAIT_TIME, 0x042 },\n\t\t.regs[2] = { IMX415_SYS_MODE, 0x5 },\n\t\t.regs[3] = { IMX415_INCKSEL1, 0x00 },\n\t\t.regs[4] = { IMX415_INCKSEL2, 0x23 },\n\t\t.regs[5] = { IMX415_INCKSEL3, 0x0C6 },\n\t\t.regs[6] = { IMX415_INCKSEL4, 0x0E7 },\n\t\t.regs[7] = { IMX415_INCKSEL5, 0x23 },\n\t\t.regs[8] = { IMX415_INCKSEL6, 0x0 },\n\t\t.regs[9] = { IMX415_INCKSEL7, 0x1 },\n\t\t.regs[10] = { IMX415_TXCLKESC_FREQ, 0x06C0 },\n\t},\n\t{\n\t\t.lane_rate = 1440000000,\n\t\t.inck = 24000000,\n\t\t.regs[0] = { IMX415_BCWAIT_TIME, 0x054 },\n\t\t.regs[1] = { IMX415_CPWAIT_TIME, 0x03B },\n\t\t.regs[2] = { IMX415_SYS_MODE, 0x8 },\n\t\t.regs[3] = { IMX415_INCKSEL1, 0x00 },\n\t\t.regs[4] = { IMX415_INCKSEL2, 0x23 },\n\t\t.regs[5] = { IMX415_INCKSEL3, 0x0B4 },\n\t\t.regs[6] = { IMX415_INCKSEL4, 0x0FC },\n\t\t.regs[7] = { IMX415_INCKSEL5, 0x23 },\n\t\t.regs[8] = { IMX415_INCKSEL6, 0x1 },\n\t\t.regs[9] = { IMX415_INCKSEL7, 0x0 },\n\t\t.regs[10] = { IMX415_TXCLKESC_FREQ, 0x0600 },\n\t},\n\t{\n\t\t.lane_rate = 1485000000,\n\t\t.inck = 27000000,\n\t\t.regs[0] = { IMX415_BCWAIT_TIME, 0x05D },\n\t\t.regs[1] = { IMX415_CPWAIT_TIME, 0x042 },\n\t\t.regs[2] = { IMX415_SYS_MODE, 0x8 },\n\t\t.regs[3] = { IMX415_INCKSEL1, 0x00 },\n\t\t.regs[4] = { IMX415_INCKSEL2, 0x23 },\n\t\t.regs[5] = { IMX415_INCKSEL3, 0x0A5 },\n\t\t.regs[6] = { IMX415_INCKSEL4, 0x0E7 },\n\t\t.regs[7] = { IMX415_INCKSEL5, 0x23 },\n\t\t.regs[8] = { IMX415_INCKSEL6, 0x1 },\n\t\t.regs[9] = { IMX415_INCKSEL7, 0x0 },\n\t\t.regs[10] = { IMX415_TXCLKESC_FREQ, 0x06C0 },\n\t},\n};\n\n \nstatic const struct imx415_reg imx415_mode_2_720[] = {\n\t{ IMX415_VMAX, 0x08CA },\n\t{ IMX415_HMAX, 0x07F0 },\n\t{ IMX415_LANEMODE, IMX415_LANEMODE_2 },\n\t{ IMX415_TCLKPOST, 0x006F },\n\t{ IMX415_TCLKPREPARE, 0x002F },\n\t{ IMX415_TCLKTRAIL, 0x002F },\n\t{ IMX415_TCLKZERO, 0x00BF },\n\t{ IMX415_THSPREPARE, 0x002F },\n\t{ IMX415_THSZERO, 0x0057 },\n\t{ IMX415_THSTRAIL, 0x002F },\n\t{ IMX415_THSEXIT, 0x004F },\n\t{ IMX415_TLPX, 0x0027 },\n};\n\n \nstatic const struct imx415_reg imx415_mode_2_1440[] = {\n\t{ IMX415_VMAX, 0x08CA },\n\t{ IMX415_HMAX, 0x042A },\n\t{ IMX415_LANEMODE, IMX415_LANEMODE_2 },\n\t{ IMX415_TCLKPOST, 0x009F },\n\t{ IMX415_TCLKPREPARE, 0x0057 },\n\t{ IMX415_TCLKTRAIL, 0x0057 },\n\t{ IMX415_TCLKZERO, 0x0187 },\n\t{ IMX415_THSPREPARE, 0x005F },\n\t{ IMX415_THSZERO, 0x00A7 },\n\t{ IMX415_THSTRAIL, 0x005F },\n\t{ IMX415_THSEXIT, 0x0097 },\n\t{ IMX415_TLPX, 0x004F },\n};\n\n \nstatic const struct imx415_reg imx415_mode_4_891[] = {\n\t{ IMX415_VMAX, 0x08CA },\n\t{ IMX415_HMAX, 0x044C },\n\t{ IMX415_LANEMODE, IMX415_LANEMODE_4 },\n\t{ IMX415_TCLKPOST, 0x007F },\n\t{ IMX415_TCLKPREPARE, 0x0037 },\n\t{ IMX415_TCLKTRAIL, 0x0037 },\n\t{ IMX415_TCLKZERO, 0x00F7 },\n\t{ IMX415_THSPREPARE, 0x003F },\n\t{ IMX415_THSZERO, 0x006F },\n\t{ IMX415_THSTRAIL, 0x003F },\n\t{ IMX415_THSEXIT, 0x005F },\n\t{ IMX415_TLPX, 0x002F },\n};\n\nstruct imx415_mode_reg_list {\n\tu32 num_of_regs;\n\tconst struct imx415_reg *regs;\n};\n\n \nstruct imx415_mode {\n\tu64 lane_rate;\n\tu32 lanes;\n\tu32 hmax_pix;\n\tu64 pixel_rate;\n\tstruct imx415_mode_reg_list reg_list;\n};\n\n \nstatic const struct imx415_mode supported_modes[] = {\n\t{\n\t\t.lane_rate = 720000000,\n\t\t.lanes = 2,\n\t\t.hmax_pix = 4064,\n\t\t.pixel_rate = 144000000,\n\t\t.reg_list = {\n\t\t\t.num_of_regs = ARRAY_SIZE(imx415_mode_2_720),\n\t\t\t.regs = imx415_mode_2_720,\n\t\t},\n\t},\n\t{\n\t\t.lane_rate = 1440000000,\n\t\t.lanes = 2,\n\t\t.hmax_pix = 4510,\n\t\t.pixel_rate = 304615385,\n\t\t.reg_list = {\n\t\t\t.num_of_regs = ARRAY_SIZE(imx415_mode_2_1440),\n\t\t\t.regs = imx415_mode_2_1440,\n\t\t},\n\t},\n\t{\n\t\t.lane_rate = 891000000,\n\t\t.lanes = 4,\n\t\t.hmax_pix = 4400,\n\t\t.pixel_rate = 297000000,\n\t\t.reg_list = {\n\t\t\t.num_of_regs = ARRAY_SIZE(imx415_mode_4_891),\n\t\t\t.regs = imx415_mode_4_891,\n\t\t},\n\t},\n};\n\nstatic const struct regmap_config imx415_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n};\n\nstatic const char *const imx415_test_pattern_menu[] = {\n\t\"disabled\",\n\t\"solid black\",\n\t\"solid white\",\n\t\"solid dark gray\",\n\t\"solid light gray\",\n\t\"stripes light/dark grey\",\n\t\"stripes dark/light grey\",\n\t\"stripes black/dark grey\",\n\t\"stripes dark grey/black\",\n\t\"stripes black/white\",\n\t\"stripes white/black\",\n\t\"horizontal color bar\",\n\t\"vertical color bar\",\n};\n\nstruct imx415 {\n\tstruct device *dev;\n\tstruct clk *clk;\n\tstruct regulator_bulk_data supplies[ARRAY_SIZE(imx415_supply_names)];\n\tstruct gpio_desc *reset;\n\tstruct regmap *regmap;\n\n\tconst struct imx415_clk_params *clk_params;\n\n\tbool streaming;\n\n\tstruct v4l2_subdev subdev;\n\tstruct media_pad pad;\n\n\tstruct v4l2_ctrl_handler ctrls;\n\tstruct v4l2_ctrl *vblank;\n\tstruct v4l2_ctrl *hflip;\n\tstruct v4l2_ctrl *vflip;\n\n\tunsigned int cur_mode;\n\tunsigned int num_data_lanes;\n};\n\n \nstatic const struct imx415_reg imx415_init_table[] = {\n\t \n\t{ IMX415_WINMODE, 0x00 },\n\t{ IMX415_ADDMODE, 0x00 },\n\t{ IMX415_REVERSE, 0x00 },\n\t \n\t{ IMX415_ADBIT, 0x00 },\n\t{ IMX415_MDBIT, 0x00 },\n\t \n\t{ IMX415_OUTSEL, 0x22 },\n\t{ IMX415_DRV, 0x00 },\n\n\t \n\t{ IMX415_REG_8BIT(0x32D4), 0x21 },\n\t{ IMX415_REG_8BIT(0x32EC), 0xA1 },\n\t{ IMX415_REG_8BIT(0x3452), 0x7F },\n\t{ IMX415_REG_8BIT(0x3453), 0x03 },\n\t{ IMX415_REG_8BIT(0x358A), 0x04 },\n\t{ IMX415_REG_8BIT(0x35A1), 0x02 },\n\t{ IMX415_REG_8BIT(0x36BC), 0x0C },\n\t{ IMX415_REG_8BIT(0x36CC), 0x53 },\n\t{ IMX415_REG_8BIT(0x36CD), 0x00 },\n\t{ IMX415_REG_8BIT(0x36CE), 0x3C },\n\t{ IMX415_REG_8BIT(0x36D0), 0x8C },\n\t{ IMX415_REG_8BIT(0x36D1), 0x00 },\n\t{ IMX415_REG_8BIT(0x36D2), 0x71 },\n\t{ IMX415_REG_8BIT(0x36D4), 0x3C },\n\t{ IMX415_REG_8BIT(0x36D6), 0x53 },\n\t{ IMX415_REG_8BIT(0x36D7), 0x00 },\n\t{ IMX415_REG_8BIT(0x36D8), 0x71 },\n\t{ IMX415_REG_8BIT(0x36DA), 0x8C },\n\t{ IMX415_REG_8BIT(0x36DB), 0x00 },\n\t{ IMX415_REG_8BIT(0x3724), 0x02 },\n\t{ IMX415_REG_8BIT(0x3726), 0x02 },\n\t{ IMX415_REG_8BIT(0x3732), 0x02 },\n\t{ IMX415_REG_8BIT(0x3734), 0x03 },\n\t{ IMX415_REG_8BIT(0x3736), 0x03 },\n\t{ IMX415_REG_8BIT(0x3742), 0x03 },\n\t{ IMX415_REG_8BIT(0x3862), 0xE0 },\n\t{ IMX415_REG_8BIT(0x38CC), 0x30 },\n\t{ IMX415_REG_8BIT(0x38CD), 0x2F },\n\t{ IMX415_REG_8BIT(0x395C), 0x0C },\n\t{ IMX415_REG_8BIT(0x3A42), 0xD1 },\n\t{ IMX415_REG_8BIT(0x3A4C), 0x77 },\n\t{ IMX415_REG_8BIT(0x3AE0), 0x02 },\n\t{ IMX415_REG_8BIT(0x3AEC), 0x0C },\n\t{ IMX415_REG_8BIT(0x3B00), 0x2E },\n\t{ IMX415_REG_8BIT(0x3B06), 0x29 },\n\t{ IMX415_REG_8BIT(0x3B98), 0x25 },\n\t{ IMX415_REG_8BIT(0x3B99), 0x21 },\n\t{ IMX415_REG_8BIT(0x3B9B), 0x13 },\n\t{ IMX415_REG_8BIT(0x3B9C), 0x13 },\n\t{ IMX415_REG_8BIT(0x3B9D), 0x13 },\n\t{ IMX415_REG_8BIT(0x3B9E), 0x13 },\n\t{ IMX415_REG_8BIT(0x3BA1), 0x00 },\n\t{ IMX415_REG_8BIT(0x3BA2), 0x06 },\n\t{ IMX415_REG_8BIT(0x3BA3), 0x0B },\n\t{ IMX415_REG_8BIT(0x3BA4), 0x10 },\n\t{ IMX415_REG_8BIT(0x3BA5), 0x14 },\n\t{ IMX415_REG_8BIT(0x3BA6), 0x18 },\n\t{ IMX415_REG_8BIT(0x3BA7), 0x1A },\n\t{ IMX415_REG_8BIT(0x3BA8), 0x1A },\n\t{ IMX415_REG_8BIT(0x3BA9), 0x1A },\n\t{ IMX415_REG_8BIT(0x3BAC), 0xED },\n\t{ IMX415_REG_8BIT(0x3BAD), 0x01 },\n\t{ IMX415_REG_8BIT(0x3BAE), 0xF6 },\n\t{ IMX415_REG_8BIT(0x3BAF), 0x02 },\n\t{ IMX415_REG_8BIT(0x3BB0), 0xA2 },\n\t{ IMX415_REG_8BIT(0x3BB1), 0x03 },\n\t{ IMX415_REG_8BIT(0x3BB2), 0xE0 },\n\t{ IMX415_REG_8BIT(0x3BB3), 0x03 },\n\t{ IMX415_REG_8BIT(0x3BB4), 0xE0 },\n\t{ IMX415_REG_8BIT(0x3BB5), 0x03 },\n\t{ IMX415_REG_8BIT(0x3BB6), 0xE0 },\n\t{ IMX415_REG_8BIT(0x3BB7), 0x03 },\n\t{ IMX415_REG_8BIT(0x3BB8), 0xE0 },\n\t{ IMX415_REG_8BIT(0x3BBA), 0xE0 },\n\t{ IMX415_REG_8BIT(0x3BBC), 0xDA },\n\t{ IMX415_REG_8BIT(0x3BBE), 0x88 },\n\t{ IMX415_REG_8BIT(0x3BC0), 0x44 },\n\t{ IMX415_REG_8BIT(0x3BC2), 0x7B },\n\t{ IMX415_REG_8BIT(0x3BC4), 0xA2 },\n\t{ IMX415_REG_8BIT(0x3BC8), 0xBD },\n\t{ IMX415_REG_8BIT(0x3BCA), 0xBD },\n};\n\nstatic inline struct imx415 *to_imx415(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct imx415, subdev);\n}\n\nstatic int imx415_read(struct imx415 *sensor, u32 addr)\n{\n\tu8 data[3] = { 0 };\n\tint ret;\n\n\tret = regmap_raw_read(sensor->regmap, addr & IMX415_REG_ADDR_MASK, data,\n\t\t\t      (addr >> IMX415_REG_SIZE_SHIFT) & 3);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (data[2] << 16) | (data[1] << 8) | data[0];\n}\n\nstatic int imx415_write(struct imx415 *sensor, u32 addr, u32 value)\n{\n\tu8 data[3] = { value & 0xff, (value >> 8) & 0xff, value >> 16 };\n\tint ret;\n\n\tret = regmap_raw_write(sensor->regmap, addr & IMX415_REG_ADDR_MASK,\n\t\t\t       data, (addr >> IMX415_REG_SIZE_SHIFT) & 3);\n\tif (ret < 0)\n\t\tdev_err_ratelimited(sensor->dev,\n\t\t\t\t    \"%u-bit write to 0x%04x failed: %d\\n\",\n\t\t\t\t    ((addr >> IMX415_REG_SIZE_SHIFT) & 3) * 8,\n\t\t\t\t    addr & IMX415_REG_ADDR_MASK, ret);\n\n\treturn 0;\n}\n\nstatic int imx415_set_testpattern(struct imx415 *sensor, int val)\n{\n\tint ret;\n\n\tif (val) {\n\t\tret = imx415_write(sensor, IMX415_BLKLEVEL, 0x00);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = imx415_write(sensor, IMX415_TPG_EN_DUOUT, 0x01);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = imx415_write(sensor, IMX415_TPG_PATSEL_DUOUT, val - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = imx415_write(sensor, IMX415_TPG_COLORWIDTH, 0x01);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = imx415_write(sensor, IMX415_TESTCLKEN_MIPI, 0x20);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = imx415_write(sensor, IMX415_DIG_CLP_MODE, 0x00);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = imx415_write(sensor, IMX415_WRJ_OPEN, 0x00);\n\t} else {\n\t\tret = imx415_write(sensor, IMX415_BLKLEVEL,\n\t\t\t\t   IMX415_BLKLEVEL_DEFAULT);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = imx415_write(sensor, IMX415_TPG_EN_DUOUT, 0x00);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = imx415_write(sensor, IMX415_TESTCLKEN_MIPI, 0x00);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = imx415_write(sensor, IMX415_DIG_CLP_MODE, 0x01);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = imx415_write(sensor, IMX415_WRJ_OPEN, 0x01);\n\t}\n\treturn 0;\n}\n\nstatic int imx415_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct imx415 *sensor = container_of(ctrl->handler, struct imx415,\n\t\t\t\t\t     ctrls);\n\tconst struct v4l2_mbus_framefmt *format;\n\tstruct v4l2_subdev_state *state;\n\tunsigned int vmax;\n\tunsigned int flip;\n\n\tif (!sensor->streaming)\n\t\treturn 0;\n\n\tstate = v4l2_subdev_get_locked_active_state(&sensor->subdev);\n\tformat = v4l2_subdev_get_pad_format(&sensor->subdev, state, 0);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE:\n\t\t \n\t\tvmax = format->height + sensor->vblank->cur.val;\n\t\tctrl->val = min_t(int, ctrl->val, vmax);\n\t\treturn imx415_write(sensor, IMX415_SHR0, vmax - ctrl->val);\n\n\tcase V4L2_CID_ANALOGUE_GAIN:\n\t\t \n\t\treturn imx415_write(sensor, IMX415_GAIN_PCG_0, ctrl->val);\n\n\tcase V4L2_CID_HFLIP:\n\tcase V4L2_CID_VFLIP:\n\t\tflip = (sensor->hflip->val << IMX415_HREVERSE_SHIFT) |\n\t\t       (sensor->vflip->val << IMX415_VREVERSE_SHIFT);\n\t\treturn imx415_write(sensor, IMX415_REVERSE, flip);\n\n\tcase V4L2_CID_TEST_PATTERN:\n\t\treturn imx415_set_testpattern(sensor, ctrl->val);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct v4l2_ctrl_ops imx415_ctrl_ops = {\n\t.s_ctrl = imx415_s_ctrl,\n};\n\nstatic int imx415_ctrls_init(struct imx415 *sensor)\n{\n\tstruct v4l2_fwnode_device_properties props;\n\tstruct v4l2_ctrl *ctrl;\n\tu64 pixel_rate = supported_modes[sensor->cur_mode].pixel_rate;\n\tu64 lane_rate = supported_modes[sensor->cur_mode].lane_rate;\n\tu32 exposure_max = IMX415_PIXEL_ARRAY_HEIGHT +\n\t\t\t   IMX415_PIXEL_ARRAY_VBLANK - 8;\n\tu32 hblank;\n\tunsigned int i;\n\tint ret;\n\n\tret = v4l2_fwnode_device_parse(sensor->dev, &props);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv4l2_ctrl_handler_init(&sensor->ctrls, 10);\n\n\tfor (i = 0; i < ARRAY_SIZE(link_freq_menu_items); ++i) {\n\t\tif (lane_rate == link_freq_menu_items[i] * 2)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(link_freq_menu_items)) {\n\t\treturn dev_err_probe(sensor->dev, -EINVAL,\n\t\t\t\t     \"lane rate %llu not supported\\n\",\n\t\t\t\t     lane_rate);\n\t}\n\n\tctrl = v4l2_ctrl_new_int_menu(&sensor->ctrls, &imx415_ctrl_ops,\n\t\t\t\t      V4L2_CID_LINK_FREQ,\n\t\t\t\t      ARRAY_SIZE(link_freq_menu_items) - 1, i,\n\t\t\t\t      link_freq_menu_items);\n\n\tif (ctrl)\n\t\tctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tv4l2_ctrl_new_std(&sensor->ctrls, &imx415_ctrl_ops, V4L2_CID_EXPOSURE,\n\t\t\t  4, exposure_max, 1, exposure_max);\n\n\tv4l2_ctrl_new_std(&sensor->ctrls, &imx415_ctrl_ops,\n\t\t\t  V4L2_CID_ANALOGUE_GAIN, IMX415_AGAIN_MIN,\n\t\t\t  IMX415_AGAIN_MAX, IMX415_AGAIN_STEP,\n\t\t\t  IMX415_AGAIN_MIN);\n\n\thblank = supported_modes[sensor->cur_mode].hmax_pix -\n\t\t IMX415_PIXEL_ARRAY_WIDTH;\n\tctrl = v4l2_ctrl_new_std(&sensor->ctrls, &imx415_ctrl_ops,\n\t\t\t\t V4L2_CID_HBLANK, hblank, hblank, 1, hblank);\n\tif (ctrl)\n\t\tctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tsensor->vblank = v4l2_ctrl_new_std(&sensor->ctrls, &imx415_ctrl_ops,\n\t\t\t\t\t   V4L2_CID_VBLANK,\n\t\t\t\t\t   IMX415_PIXEL_ARRAY_VBLANK,\n\t\t\t\t\t   IMX415_PIXEL_ARRAY_VBLANK, 1,\n\t\t\t\t\t   IMX415_PIXEL_ARRAY_VBLANK);\n\tif (sensor->vblank)\n\t\tsensor->vblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\t \n\tv4l2_ctrl_new_std(&sensor->ctrls, NULL, V4L2_CID_PIXEL_RATE, pixel_rate,\n\t\t\t  pixel_rate, 1, pixel_rate);\n\n\tsensor->hflip = v4l2_ctrl_new_std(&sensor->ctrls, &imx415_ctrl_ops,\n\t\t\t\t\t  V4L2_CID_HFLIP, 0, 1, 1, 0);\n\tsensor->vflip = v4l2_ctrl_new_std(&sensor->ctrls, &imx415_ctrl_ops,\n\t\t\t\t\t  V4L2_CID_VFLIP, 0, 1, 1, 0);\n\n\tv4l2_ctrl_new_std_menu_items(&sensor->ctrls, &imx415_ctrl_ops,\n\t\t\t\t     V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(imx415_test_pattern_menu) - 1,\n\t\t\t\t     0, 0, imx415_test_pattern_menu);\n\n\tv4l2_ctrl_new_fwnode_properties(&sensor->ctrls, &imx415_ctrl_ops,\n\t\t\t\t\t&props);\n\n\tif (sensor->ctrls.error) {\n\t\tdev_err_probe(sensor->dev, sensor->ctrls.error,\n\t\t\t      \"failed to add controls\\n\");\n\t\tv4l2_ctrl_handler_free(&sensor->ctrls);\n\t\treturn sensor->ctrls.error;\n\t}\n\tsensor->subdev.ctrl_handler = &sensor->ctrls;\n\n\treturn 0;\n}\n\nstatic int imx415_set_mode(struct imx415 *sensor, int mode)\n{\n\tconst struct imx415_reg *reg;\n\tunsigned int i;\n\tint ret = 0;\n\n\tif (mode >= ARRAY_SIZE(supported_modes)) {\n\t\tdev_err(sensor->dev, \"Mode %d not supported\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < supported_modes[mode].reg_list.num_of_regs; ++i) {\n\t\treg = &supported_modes[mode].reg_list.regs[i];\n\t\tret = imx415_write(sensor, reg->address, reg->val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < IMX415_NUM_CLK_PARAM_REGS; ++i) {\n\t\treg = &sensor->clk_params->regs[i];\n\t\tret = imx415_write(sensor, reg->address, reg->val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int imx415_setup(struct imx415 *sensor, struct v4l2_subdev_state *state)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(imx415_init_table); ++i) {\n\t\tret = imx415_write(sensor, imx415_init_table[i].address,\n\t\t\t\t   imx415_init_table[i].val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn imx415_set_mode(sensor, sensor->cur_mode);\n}\n\nstatic int imx415_wakeup(struct imx415 *sensor)\n{\n\tint ret;\n\n\tret = imx415_write(sensor, IMX415_MODE, IMX415_MODE_OPERATING);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmsleep(80);\n\n\treturn 0;\n}\n\nstatic int imx415_stream_on(struct imx415 *sensor)\n{\n\tint ret;\n\n\tret = imx415_wakeup(sensor);\n\tif (ret)\n\t\treturn ret;\n\n\treturn imx415_write(sensor, IMX415_XMSTA, IMX415_XMSTA_START);\n}\n\nstatic int imx415_stream_off(struct imx415 *sensor)\n{\n\tint ret;\n\n\tret = imx415_write(sensor, IMX415_XMSTA, IMX415_XMSTA_STOP);\n\tif (ret)\n\t\treturn ret;\n\n\treturn imx415_write(sensor, IMX415_MODE, IMX415_MODE_STANDBY);\n}\n\nstatic int imx415_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct imx415 *sensor = to_imx415(sd);\n\tstruct v4l2_subdev_state *state;\n\tint ret;\n\n\tstate = v4l2_subdev_lock_and_get_active_state(sd);\n\n\tif (!enable) {\n\t\tret = imx415_stream_off(sensor);\n\n\t\tpm_runtime_mark_last_busy(sensor->dev);\n\t\tpm_runtime_put_autosuspend(sensor->dev);\n\n\t\tsensor->streaming = false;\n\n\t\tgoto unlock;\n\t}\n\n\tret = pm_runtime_resume_and_get(sensor->dev);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tret = imx415_setup(sensor, state);\n\tif (ret)\n\t\tgoto err_pm;\n\n\t \n\tsensor->streaming = true;\n\n\tret = __v4l2_ctrl_handler_setup(&sensor->ctrls);\n\tif (ret < 0)\n\t\tgoto err_pm;\n\n\tret = imx415_stream_on(sensor);\n\tif (ret)\n\t\tgoto err_pm;\n\n\tret = 0;\n\nunlock:\n\tv4l2_subdev_unlock_state(state);\n\n\treturn ret;\n\nerr_pm:\n\t \n\tpm_runtime_put_sync(sensor->dev);\n\tsensor->streaming = false;\n\n\tgoto unlock;\n}\n\nstatic int imx415_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index != 0)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_SGBRG10_1X10;\n\n\treturn 0;\n}\n\nstatic int imx415_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tconst struct v4l2_mbus_framefmt *format;\n\n\tformat = v4l2_subdev_get_pad_format(sd, state, fse->pad);\n\n\tif (fse->index > 0 || fse->code != format->code)\n\t\treturn -EINVAL;\n\n\tfse->min_width = IMX415_PIXEL_ARRAY_WIDTH;\n\tfse->max_width = fse->min_width;\n\tfse->min_height = IMX415_PIXEL_ARRAY_HEIGHT;\n\tfse->max_height = fse->min_height;\n\treturn 0;\n}\n\nstatic int imx415_get_format(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *state,\n\t\t\t     struct v4l2_subdev_format *fmt)\n{\n\tfmt->format = *v4l2_subdev_get_pad_format(sd, state, fmt->pad);\n\n\treturn 0;\n}\n\nstatic int imx415_set_format(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *state,\n\t\t\t     struct v4l2_subdev_format *fmt)\n{\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = v4l2_subdev_get_pad_format(sd, state, fmt->pad);\n\n\tformat->width = fmt->format.width;\n\tformat->height = fmt->format.height;\n\tformat->code = MEDIA_BUS_FMT_SGBRG10_1X10;\n\tformat->field = V4L2_FIELD_NONE;\n\tformat->colorspace = V4L2_COLORSPACE_RAW;\n\tformat->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tformat->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tformat->xfer_func = V4L2_XFER_FUNC_NONE;\n\n\tfmt->format = *format;\n\treturn 0;\n}\n\nstatic int imx415_get_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.top = IMX415_PIXEL_ARRAY_TOP;\n\t\tsel->r.left = IMX415_PIXEL_ARRAY_LEFT;\n\t\tsel->r.width = IMX415_PIXEL_ARRAY_WIDTH;\n\t\tsel->r.height = IMX415_PIXEL_ARRAY_HEIGHT;\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int imx415_init_cfg(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *state)\n{\n\tstruct v4l2_subdev_format format = {\n\t\t.format = {\n\t\t\t.width = IMX415_PIXEL_ARRAY_WIDTH,\n\t\t\t.height = IMX415_PIXEL_ARRAY_HEIGHT,\n\t\t},\n\t};\n\n\timx415_set_format(sd, state, &format);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops imx415_subdev_video_ops = {\n\t.s_stream = imx415_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops imx415_subdev_pad_ops = {\n\t.enum_mbus_code = imx415_enum_mbus_code,\n\t.enum_frame_size = imx415_enum_frame_size,\n\t.get_fmt = imx415_get_format,\n\t.set_fmt = imx415_set_format,\n\t.get_selection = imx415_get_selection,\n\t.init_cfg = imx415_init_cfg,\n};\n\nstatic const struct v4l2_subdev_ops imx415_subdev_ops = {\n\t.video = &imx415_subdev_video_ops,\n\t.pad = &imx415_subdev_pad_ops,\n};\n\nstatic int imx415_subdev_init(struct imx415 *sensor)\n{\n\tstruct i2c_client *client = to_i2c_client(sensor->dev);\n\tint ret;\n\n\tv4l2_i2c_subdev_init(&sensor->subdev, client, &imx415_subdev_ops);\n\n\tret = imx415_ctrls_init(sensor);\n\tif (ret)\n\t\treturn ret;\n\n\tsensor->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |\n\t\t\t\tV4L2_SUBDEV_FL_HAS_EVENTS;\n\tsensor->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tsensor->subdev.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tret = media_entity_pads_init(&sensor->subdev.entity, 1, &sensor->pad);\n\tif (ret < 0) {\n\t\tv4l2_ctrl_handler_free(&sensor->ctrls);\n\t\treturn ret;\n\t}\n\n\tsensor->subdev.state_lock = sensor->subdev.ctrl_handler->lock;\n\tv4l2_subdev_init_finalize(&sensor->subdev);\n\n\treturn 0;\n}\n\nstatic void imx415_subdev_cleanup(struct imx415 *sensor)\n{\n\tmedia_entity_cleanup(&sensor->subdev.entity);\n\tv4l2_ctrl_handler_free(&sensor->ctrls);\n}\n\nstatic int imx415_power_on(struct imx415 *sensor)\n{\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(sensor->supplies),\n\t\t\t\t    sensor->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgpiod_set_value_cansleep(sensor->reset, 0);\n\n\tudelay(1);\n\n\tret = clk_prepare_enable(sensor->clk);\n\tif (ret < 0)\n\t\tgoto err_reset;\n\n\t \n\tusleep_range(100, 200);\n\n\treturn 0;\n\nerr_reset:\n\tgpiod_set_value_cansleep(sensor->reset, 1);\n\tregulator_bulk_disable(ARRAY_SIZE(sensor->supplies), sensor->supplies);\n\treturn ret;\n}\n\nstatic void imx415_power_off(struct imx415 *sensor)\n{\n\tclk_disable_unprepare(sensor->clk);\n\tgpiod_set_value_cansleep(sensor->reset, 1);\n\tregulator_bulk_disable(ARRAY_SIZE(sensor->supplies), sensor->supplies);\n}\n\nstatic int imx415_identify_model(struct imx415 *sensor)\n{\n\tint model, ret;\n\n\t \n\tret = imx415_wakeup(sensor);\n\tif (ret)\n\t\treturn dev_err_probe(sensor->dev, ret,\n\t\t\t\t     \"failed to get sensor out of standby\\n\");\n\n\tret = imx415_read(sensor, IMX415_SENSOR_INFO);\n\tif (ret < 0) {\n\t\tdev_err_probe(sensor->dev, ret,\n\t\t\t      \"failed to read sensor information\\n\");\n\t\tgoto done;\n\t}\n\n\tmodel = ret & IMX415_SENSOR_INFO_MASK;\n\n\tswitch (model) {\n\tcase IMX415_CHIP_ID:\n\t\tdev_info(sensor->dev, \"Detected IMX415 image sensor\\n\");\n\t\tbreak;\n\tdefault:\n\t\tret = dev_err_probe(sensor->dev, -ENODEV,\n\t\t\t\t    \"invalid device model 0x%04x\\n\", model);\n\t\tgoto done;\n\t}\n\n\tret = 0;\n\ndone:\n\timx415_write(sensor, IMX415_MODE, IMX415_MODE_STANDBY);\n\treturn ret;\n}\n\nstatic int imx415_check_inck(unsigned long inck, u64 link_frequency)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(imx415_clk_params); ++i) {\n\t\tif ((imx415_clk_params[i].lane_rate == link_frequency * 2) &&\n\t\t    imx415_clk_params[i].inck == inck)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(imx415_clk_params))\n\t\treturn -EINVAL;\n\telse\n\t\treturn 0;\n}\n\nstatic int imx415_parse_hw_config(struct imx415 *sensor)\n{\n\tstruct v4l2_fwnode_endpoint bus_cfg = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY,\n\t};\n\tstruct fwnode_handle *ep;\n\tu64 lane_rate;\n\tunsigned long inck;\n\tunsigned int i, j;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(sensor->supplies); ++i)\n\t\tsensor->supplies[i].supply = imx415_supply_names[i];\n\n\tret = devm_regulator_bulk_get(sensor->dev, ARRAY_SIZE(sensor->supplies),\n\t\t\t\t      sensor->supplies);\n\tif (ret)\n\t\treturn dev_err_probe(sensor->dev, ret,\n\t\t\t\t     \"failed to get supplies\\n\");\n\n\tsensor->reset = devm_gpiod_get_optional(sensor->dev, \"reset\",\n\t\t\t\t\t\tGPIOD_OUT_HIGH);\n\tif (IS_ERR(sensor->reset))\n\t\treturn dev_err_probe(sensor->dev, PTR_ERR(sensor->reset),\n\t\t\t\t     \"failed to get reset GPIO\\n\");\n\n\tsensor->clk = devm_clk_get(sensor->dev, \"inck\");\n\tif (IS_ERR(sensor->clk))\n\t\treturn dev_err_probe(sensor->dev, PTR_ERR(sensor->clk),\n\t\t\t\t     \"failed to get clock\\n\");\n\n\tep = fwnode_graph_get_next_endpoint(dev_fwnode(sensor->dev), NULL);\n\tif (!ep)\n\t\treturn -ENXIO;\n\n\tret = v4l2_fwnode_endpoint_alloc_parse(ep, &bus_cfg);\n\tfwnode_handle_put(ep);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (bus_cfg.bus.mipi_csi2.num_data_lanes) {\n\tcase 2:\n\tcase 4:\n\t\tsensor->num_data_lanes = bus_cfg.bus.mipi_csi2.num_data_lanes;\n\t\tbreak;\n\tdefault:\n\t\tret = dev_err_probe(sensor->dev, -EINVAL,\n\t\t\t\t    \"invalid number of CSI2 data lanes %d\\n\",\n\t\t\t\t    bus_cfg.bus.mipi_csi2.num_data_lanes);\n\t\tgoto done_endpoint_free;\n\t}\n\n\tif (!bus_cfg.nr_of_link_frequencies) {\n\t\tret = dev_err_probe(sensor->dev, -EINVAL,\n\t\t\t\t    \"no link frequencies defined\");\n\t\tgoto done_endpoint_free;\n\t}\n\n\t \n\tinck = clk_get_rate(sensor->clk);\n\tfor (i = 0; i < bus_cfg.nr_of_link_frequencies; ++i) {\n\t\tif (imx415_check_inck(inck, bus_cfg.link_frequencies[i])) {\n\t\t\tdev_dbg(sensor->dev,\n\t\t\t\t\"INCK %lu Hz not supported for this link freq\",\n\t\t\t\tinck);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < ARRAY_SIZE(supported_modes); ++j) {\n\t\t\tif (sensor->num_data_lanes != supported_modes[j].lanes)\n\t\t\t\tcontinue;\n\t\t\tif (bus_cfg.link_frequencies[i] * 2 !=\n\t\t\t    supported_modes[j].lane_rate)\n\t\t\t\tcontinue;\n\t\t\tsensor->cur_mode = j;\n\t\t\tbreak;\n\t\t}\n\t\tif (j < ARRAY_SIZE(supported_modes))\n\t\t\tbreak;\n\t}\n\tif (i == bus_cfg.nr_of_link_frequencies) {\n\t\tret = dev_err_probe(sensor->dev, -EINVAL,\n\t\t\t\t    \"no valid sensor mode defined\\n\");\n\t\tgoto done_endpoint_free;\n\t}\n\n\tlane_rate = supported_modes[sensor->cur_mode].lane_rate;\n\tfor (i = 0; i < ARRAY_SIZE(imx415_clk_params); ++i) {\n\t\tif (lane_rate == imx415_clk_params[i].lane_rate &&\n\t\t    inck == imx415_clk_params[i].inck) {\n\t\t\tsensor->clk_params = &imx415_clk_params[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == ARRAY_SIZE(imx415_clk_params)) {\n\t\tret = dev_err_probe(sensor->dev, -EINVAL,\n\t\t\t\t    \"Mode %d not supported\\n\",\n\t\t\t\t    sensor->cur_mode);\n\t\tgoto done_endpoint_free;\n\t}\n\n\tret = 0;\n\tdev_dbg(sensor->dev, \"clock: %lu Hz, lane_rate: %llu bps, lanes: %d\\n\",\n\t\tinck, lane_rate, sensor->num_data_lanes);\n\ndone_endpoint_free:\n\tv4l2_fwnode_endpoint_free(&bus_cfg);\n\n\treturn ret;\n}\n\nstatic int imx415_probe(struct i2c_client *client)\n{\n\tstruct imx415 *sensor;\n\tint ret;\n\n\tsensor = devm_kzalloc(&client->dev, sizeof(*sensor), GFP_KERNEL);\n\tif (!sensor)\n\t\treturn -ENOMEM;\n\n\tsensor->dev = &client->dev;\n\n\tret = imx415_parse_hw_config(sensor);\n\tif (ret)\n\t\treturn ret;\n\n\tsensor->regmap = devm_regmap_init_i2c(client, &imx415_regmap_config);\n\tif (IS_ERR(sensor->regmap))\n\t\treturn PTR_ERR(sensor->regmap);\n\n\t \n\tret = imx415_power_on(sensor);\n\tif (ret)\n\t\treturn ret;\n\n\tret = imx415_identify_model(sensor);\n\tif (ret)\n\t\tgoto err_power;\n\n\tret = imx415_subdev_init(sensor);\n\tif (ret)\n\t\tgoto err_power;\n\n\t \n\tpm_runtime_set_active(sensor->dev);\n\tpm_runtime_get_noresume(sensor->dev);\n\tpm_runtime_enable(sensor->dev);\n\n\tret = v4l2_async_register_subdev_sensor(&sensor->subdev);\n\tif (ret < 0)\n\t\tgoto err_pm;\n\n\t \n\tpm_runtime_set_autosuspend_delay(sensor->dev, 1000);\n\tpm_runtime_use_autosuspend(sensor->dev);\n\tpm_runtime_put_autosuspend(sensor->dev);\n\n\treturn 0;\n\nerr_pm:\n\tpm_runtime_disable(sensor->dev);\n\tpm_runtime_put_noidle(sensor->dev);\n\timx415_subdev_cleanup(sensor);\nerr_power:\n\timx415_power_off(sensor);\n\treturn ret;\n}\n\nstatic void imx415_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct imx415 *sensor = to_imx415(subdev);\n\n\tv4l2_async_unregister_subdev(subdev);\n\n\timx415_subdev_cleanup(sensor);\n\n\t \n\tpm_runtime_disable(sensor->dev);\n\tif (!pm_runtime_status_suspended(sensor->dev))\n\t\timx415_power_off(sensor);\n\tpm_runtime_set_suspended(sensor->dev);\n}\n\nstatic int imx415_runtime_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct imx415 *sensor = to_imx415(subdev);\n\n\treturn imx415_power_on(sensor);\n}\n\nstatic int imx415_runtime_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct imx415 *sensor = to_imx415(subdev);\n\n\timx415_power_off(sensor);\n\n\treturn 0;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(imx415_pm_ops, imx415_runtime_suspend,\n\t\t\t\t imx415_runtime_resume, NULL);\n\nstatic const struct of_device_id imx415_of_match[] = {\n\t{ .compatible = \"sony,imx415\" },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, imx415_of_match);\n\nstatic struct i2c_driver imx415_driver = {\n\t.probe = imx415_probe,\n\t.remove = imx415_remove,\n\t.driver = {\n\t\t.name = \"imx415\",\n\t\t.of_match_table = imx415_of_match,\n\t\t.pm = pm_ptr(&imx415_pm_ops),\n\t},\n};\n\nmodule_i2c_driver(imx415_driver);\n\nMODULE_DESCRIPTION(\"Sony IMX415 image sensor driver\");\nMODULE_AUTHOR(\"Gerald Loacker <gerald.loacker@wolfvision.net>\");\nMODULE_AUTHOR(\"Michael Riesch <michael.riesch@wolfvision.net>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}