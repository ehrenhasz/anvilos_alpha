{
  "module_name": "ov6650.c",
  "hash_id": "fb6506512aa5274df6c161a8200ded1797a1550124644eb7ee50d252cf665648",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ov6650.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/v4l2-mediabus.h>\n#include <linux/module.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n\n \n#define REG_GAIN\t\t0x00\t \n#define REG_BLUE\t\t0x01\n#define REG_RED\t\t\t0x02\n#define REG_SAT\t\t\t0x03\t \n#define REG_HUE\t\t\t0x04\t \n\n#define REG_BRT\t\t\t0x06\n\n#define REG_PIDH\t\t0x0a\n#define REG_PIDL\t\t0x0b\n\n#define REG_AECH\t\t0x10\n#define REG_CLKRC\t\t0x11\t \n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\t \n#define REG_COMA\t\t0x12\t \n#define REG_COMB\t\t0x13\n#define REG_COMC\t\t0x14\n#define REG_COMD\t\t0x15\n#define REG_COML\t\t0x16\n#define REG_HSTRT\t\t0x17\n#define REG_HSTOP\t\t0x18\n#define REG_VSTRT\t\t0x19\n#define REG_VSTOP\t\t0x1a\n#define REG_PSHFT\t\t0x1b\n#define REG_MIDH\t\t0x1c\n#define REG_MIDL\t\t0x1d\n#define REG_HSYNS\t\t0x1e\n#define REG_HSYNE\t\t0x1f\n#define REG_COME\t\t0x20\n#define REG_YOFF\t\t0x21\n#define REG_UOFF\t\t0x22\n#define REG_VOFF\t\t0x23\n#define REG_AEW\t\t\t0x24\n#define REG_AEB\t\t\t0x25\n#define REG_COMF\t\t0x26\n#define REG_COMG\t\t0x27\n#define REG_COMH\t\t0x28\n#define REG_COMI\t\t0x29\n\n#define REG_FRARL\t\t0x2b\n#define REG_COMJ\t\t0x2c\n#define REG_COMK\t\t0x2d\n#define REG_AVGY\t\t0x2e\n#define REG_REF0\t\t0x2f\n#define REG_REF1\t\t0x30\n#define REG_REF2\t\t0x31\n#define REG_FRAJH\t\t0x32\n#define REG_FRAJL\t\t0x33\n#define REG_FACT\t\t0x34\n#define REG_L1AEC\t\t0x35\n#define REG_AVGU\t\t0x36\n#define REG_AVGV\t\t0x37\n\n#define REG_SPCB\t\t0x60\n#define REG_SPCC\t\t0x61\n#define REG_GAM1\t\t0x62\n#define REG_GAM2\t\t0x63\n#define REG_GAM3\t\t0x64\n#define REG_SPCD\t\t0x65\n\n#define REG_SPCE\t\t0x68\n#define REG_ADCL\t\t0x69\n\n#define REG_RMCO\t\t0x6c\n#define REG_GMCO\t\t0x6d\n#define REG_BMCO\t\t0x6e\n\n\n \n#define OV6650_PIDH\t\t0x66\t \n#define OV6650_PIDL\t\t0x50\t \n#define OV6650_MIDH\t\t0x7F\t \n#define OV6650_MIDL\t\t0xA2\t \n\n#define DEF_GAIN\t\t0x00\n#define DEF_BLUE\t\t0x80\n#define DEF_RED\t\t\t0x80\n\n#define SAT_SHIFT\t\t4\n#define SAT_MASK\t\t(0xf << SAT_SHIFT)\n#define SET_SAT(x)\t\t(((x) << SAT_SHIFT) & SAT_MASK)\n\n#define HUE_EN\t\t\tBIT(5)\n#define HUE_MASK\t\t0x1f\n#define DEF_HUE\t\t\t0x10\n#define SET_HUE(x)\t\t(HUE_EN | ((x) & HUE_MASK))\n\n#define DEF_AECH\t\t0x4D\n\n#define CLKRC_8MHz\t\t0x00\n#define CLKRC_12MHz\t\t0x40\n#define CLKRC_16MHz\t\t0x80\n#define CLKRC_24MHz\t\t0xc0\n#define CLKRC_DIV_MASK\t\t0x3f\n#define GET_CLKRC_DIV(x)\t(((x) & CLKRC_DIV_MASK) + 1)\n#define DEF_CLKRC\t\t0x00\n\n#define COMA_RESET\t\tBIT(7)\n#define COMA_QCIF\t\tBIT(5)\n#define COMA_RAW_RGB\t\tBIT(4)\n#define COMA_RGB\t\tBIT(3)\n#define COMA_BW\t\t\tBIT(2)\n#define COMA_WORD_SWAP\t\tBIT(1)\n#define COMA_BYTE_SWAP\t\tBIT(0)\n#define DEF_COMA\t\t0x00\n\n#define COMB_FLIP_V\t\tBIT(7)\n#define COMB_FLIP_H\t\tBIT(5)\n#define COMB_BAND_FILTER\tBIT(4)\n#define COMB_AWB\t\tBIT(2)\n#define COMB_AGC\t\tBIT(1)\n#define COMB_AEC\t\tBIT(0)\n#define DEF_COMB\t\t0x5f\n\n#define COML_ONE_CHANNEL\tBIT(7)\n\n#define DEF_HSTRT\t\t0x24\n#define DEF_HSTOP\t\t0xd4\n#define DEF_VSTRT\t\t0x04\n#define DEF_VSTOP\t\t0x94\n\n#define COMF_HREF_LOW\t\tBIT(4)\n\n#define COMJ_PCLK_RISING\tBIT(4)\n#define COMJ_VSYNC_HIGH\t\tBIT(0)\n\n \n#define W_QCIF\t\t\t(DEF_HSTOP - DEF_HSTRT)\n#define W_CIF\t\t\t(W_QCIF << 1)\n#define H_QCIF\t\t\t(DEF_VSTOP - DEF_VSTRT)\n#define H_CIF\t\t\t(H_QCIF << 1)\n\n#define FRAME_RATE_MAX\t\t30\n\n\nstruct ov6650_reg {\n\tu8\treg;\n\tu8\tval;\n};\n\nstruct ov6650 {\n\tstruct v4l2_subdev\tsubdev;\n\tstruct v4l2_ctrl_handler hdl;\n\tstruct {\n\t\t \n\t\tstruct v4l2_ctrl *autoexposure;\n\t\tstruct v4l2_ctrl *exposure;\n\t};\n\tstruct {\n\t\t \n\t\tstruct v4l2_ctrl *autogain;\n\t\tstruct v4l2_ctrl *gain;\n\t};\n\tstruct {\n\t\t \n\t\tstruct v4l2_ctrl *autowb;\n\t\tstruct v4l2_ctrl *blue;\n\t\tstruct v4l2_ctrl *red;\n\t};\n\tstruct clk\t\t*clk;\n\tbool\t\t\thalf_scale;\t \n\tstruct v4l2_rect\trect;\t\t \n\tstruct v4l2_fract\ttpf;\t\t \n\tu32 code;\n};\n\nstruct ov6650_xclk {\n\tunsigned long\trate;\n\tu8\t\tclkrc;\n};\n\nstatic const struct ov6650_xclk ov6650_xclk[] = {\n{\n\t.rate\t= 8000000,\n\t.clkrc\t= CLKRC_8MHz,\n},\n{\n\t.rate\t= 12000000,\n\t.clkrc\t= CLKRC_12MHz,\n},\n{\n\t.rate\t= 16000000,\n\t.clkrc\t= CLKRC_16MHz,\n},\n{\n\t.rate\t= 24000000,\n\t.clkrc\t= CLKRC_24MHz,\n},\n};\n\nstatic u32 ov6650_codes[] = {\n\tMEDIA_BUS_FMT_YUYV8_2X8,\n\tMEDIA_BUS_FMT_UYVY8_2X8,\n\tMEDIA_BUS_FMT_YVYU8_2X8,\n\tMEDIA_BUS_FMT_VYUY8_2X8,\n\tMEDIA_BUS_FMT_SBGGR8_1X8,\n\tMEDIA_BUS_FMT_Y8_1X8,\n};\n\nstatic const struct v4l2_mbus_framefmt ov6650_def_fmt = {\n\t.width\t\t= W_CIF,\n\t.height\t\t= H_CIF,\n\t.code\t\t= MEDIA_BUS_FMT_SBGGR8_1X8,\n\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t.field\t\t= V4L2_FIELD_NONE,\n\t.ycbcr_enc\t= V4L2_YCBCR_ENC_DEFAULT,\n\t.quantization\t= V4L2_QUANTIZATION_DEFAULT,\n\t.xfer_func\t= V4L2_XFER_FUNC_DEFAULT,\n};\n\n \nstatic int ov6650_reg_read(struct i2c_client *client, u8 reg, u8 *val)\n{\n\tint ret;\n\tu8 data = reg;\n\tstruct i2c_msg msg = {\n\t\t.addr\t= client->addr,\n\t\t.flags\t= 0,\n\t\t.len\t= 1,\n\t\t.buf\t= &data,\n\t};\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tmsg.flags = I2C_M_RD;\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t*val = data;\n\treturn 0;\n\nerr:\n\tdev_err(&client->dev, \"Failed reading register 0x%02x!\\n\", reg);\n\treturn ret;\n}\n\n \nstatic int ov6650_reg_write(struct i2c_client *client, u8 reg, u8 val)\n{\n\tint ret;\n\tunsigned char data[2] = { reg, val };\n\tstruct i2c_msg msg = {\n\t\t.addr\t= client->addr,\n\t\t.flags\t= 0,\n\t\t.len\t= 2,\n\t\t.buf\t= data,\n\t};\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tudelay(100);\n\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed writing register 0x%02x!\\n\", reg);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n\n \nstatic int ov6650_reg_rmw(struct i2c_client *client, u8 reg, u8 set, u8 mask)\n{\n\tu8 val;\n\tint ret;\n\n\tret = ov6650_reg_read(client, reg, &val);\n\tif (ret) {\n\t\tdev_err(&client->dev,\n\t\t\t\"[Read]-Modify-Write of register 0x%02x failed!\\n\",\n\t\t\treg);\n\t\treturn ret;\n\t}\n\n\tval &= ~mask;\n\tval |= set;\n\n\tret = ov6650_reg_write(client, reg, val);\n\tif (ret)\n\t\tdev_err(&client->dev,\n\t\t\t\"Read-Modify-[Write] of register 0x%02x failed!\\n\",\n\t\t\treg);\n\n\treturn ret;\n}\n\nstatic struct ov6650 *to_ov6650(const struct i2c_client *client)\n{\n\treturn container_of(i2c_get_clientdata(client), struct ov6650, subdev);\n}\n\n \nstatic int ov6650_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\treturn 0;\n}\n\n \nstatic int ov6550_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ov6650 *priv = container_of(ctrl->handler, struct ov6650, hdl);\n\tstruct v4l2_subdev *sd = &priv->subdev;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tuint8_t reg, reg2;\n\tint ret;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTOGAIN:\n\t\tret = ov6650_reg_read(client, REG_GAIN, &reg);\n\t\tif (!ret)\n\t\t\tpriv->gain->val = reg;\n\t\treturn ret;\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\tret = ov6650_reg_read(client, REG_BLUE, &reg);\n\t\tif (!ret)\n\t\t\tret = ov6650_reg_read(client, REG_RED, &reg2);\n\t\tif (!ret) {\n\t\t\tpriv->blue->val = reg;\n\t\t\tpriv->red->val = reg2;\n\t\t}\n\t\treturn ret;\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tret = ov6650_reg_read(client, REG_AECH, &reg);\n\t\tif (!ret)\n\t\t\tpriv->exposure->val = reg;\n\t\treturn ret;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic int ov6550_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ov6650 *priv = container_of(ctrl->handler, struct ov6650, hdl);\n\tstruct v4l2_subdev *sd = &priv->subdev;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTOGAIN:\n\t\tret = ov6650_reg_rmw(client, REG_COMB,\n\t\t\t\tctrl->val ? COMB_AGC : 0, COMB_AGC);\n\t\tif (!ret && !ctrl->val)\n\t\t\tret = ov6650_reg_write(client, REG_GAIN, priv->gain->val);\n\t\treturn ret;\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\tret = ov6650_reg_rmw(client, REG_COMB,\n\t\t\t\tctrl->val ? COMB_AWB : 0, COMB_AWB);\n\t\tif (!ret && !ctrl->val) {\n\t\t\tret = ov6650_reg_write(client, REG_BLUE, priv->blue->val);\n\t\t\tif (!ret)\n\t\t\t\tret = ov6650_reg_write(client, REG_RED,\n\t\t\t\t\t\t\tpriv->red->val);\n\t\t}\n\t\treturn ret;\n\tcase V4L2_CID_SATURATION:\n\t\treturn ov6650_reg_rmw(client, REG_SAT, SET_SAT(ctrl->val),\n\t\t\t\tSAT_MASK);\n\tcase V4L2_CID_HUE:\n\t\treturn ov6650_reg_rmw(client, REG_HUE, SET_HUE(ctrl->val),\n\t\t\t\tHUE_MASK);\n\tcase V4L2_CID_BRIGHTNESS:\n\t\treturn ov6650_reg_write(client, REG_BRT, ctrl->val);\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tret = ov6650_reg_rmw(client, REG_COMB, ctrl->val ==\n\t\t\t\tV4L2_EXPOSURE_AUTO ? COMB_AEC : 0, COMB_AEC);\n\t\tif (!ret && ctrl->val == V4L2_EXPOSURE_MANUAL)\n\t\t\tret = ov6650_reg_write(client, REG_AECH,\n\t\t\t\t\t\tpriv->exposure->val);\n\t\treturn ret;\n\tcase V4L2_CID_GAMMA:\n\t\treturn ov6650_reg_write(client, REG_GAM1, ctrl->val);\n\tcase V4L2_CID_VFLIP:\n\t\treturn ov6650_reg_rmw(client, REG_COMB,\n\t\t\t\tctrl->val ? COMB_FLIP_V : 0, COMB_FLIP_V);\n\tcase V4L2_CID_HFLIP:\n\t\treturn ov6650_reg_rmw(client, REG_COMB,\n\t\t\t\tctrl->val ? COMB_FLIP_H : 0, COMB_FLIP_H);\n\t}\n\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int ov6650_get_register(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_dbg_register *reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\tu8 val;\n\n\tif (reg->reg & ~0xff)\n\t\treturn -EINVAL;\n\n\treg->size = 1;\n\n\tret = ov6650_reg_read(client, reg->reg, &val);\n\tif (!ret)\n\t\treg->val = (__u64)val;\n\n\treturn ret;\n}\n\nstatic int ov6650_set_register(struct v4l2_subdev *sd,\n\t\t\t\tconst struct v4l2_dbg_register *reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tif (reg->reg & ~0xff || reg->val & ~0xff)\n\t\treturn -EINVAL;\n\n\treturn ov6650_reg_write(client, reg->reg, reg->val);\n}\n#endif\n\nstatic int ov6650_s_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov6650 *priv = to_ov6650(client);\n\tint ret = 0;\n\n\tif (on)\n\t\tret = clk_prepare_enable(priv->clk);\n\telse\n\t\tclk_disable_unprepare(priv->clk);\n\n\treturn ret;\n}\n\nstatic int ov6650_get_selection(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov6650 *priv = to_ov6650(client);\n\tstruct v4l2_rect *rect;\n\n\tif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\t \n\t\trect = &sd_state->pads->try_crop;\n\n\t} else {\n\t\t \n\t\trect = &priv->rect;\n\t}\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.left = DEF_HSTRT << 1;\n\t\tsel->r.top = DEF_VSTRT << 1;\n\t\tsel->r.width = W_CIF;\n\t\tsel->r.height = H_CIF;\n\t\treturn 0;\n\n\tcase V4L2_SEL_TGT_CROP:\n\t\t \n\t\tsel->r = *rect;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic bool is_unscaled_ok(int width, int height, struct v4l2_rect *rect)\n{\n\treturn width > rect->width >> 1 || height > rect->height >> 1;\n}\n\nstatic void ov6650_bind_align_crop_rectangle(struct v4l2_rect *rect)\n{\n\tv4l_bound_align_image(&rect->width, 2, W_CIF, 1,\n\t\t\t      &rect->height, 2, H_CIF, 1, 0);\n\tv4l_bound_align_image(&rect->left, DEF_HSTRT << 1,\n\t\t\t      (DEF_HSTRT << 1) + W_CIF - (__s32)rect->width, 1,\n\t\t\t      &rect->top, DEF_VSTRT << 1,\n\t\t\t      (DEF_VSTRT << 1) + H_CIF - (__s32)rect->height,\n\t\t\t      1, 0);\n}\n\nstatic int ov6650_set_selection(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov6650 *priv = to_ov6650(client);\n\tint ret;\n\n\tif (sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\tov6650_bind_align_crop_rectangle(&sel->r);\n\n\tif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tstruct v4l2_rect *crop = &sd_state->pads->try_crop;\n\t\tstruct v4l2_mbus_framefmt *mf = &sd_state->pads->try_fmt;\n\t\t \n\t\tbool half_scale = !is_unscaled_ok(mf->width, mf->height, crop);\n\n\t\t \n\t\t*crop = sel->r;\n\n\t\t \n\t\tmf->width = crop->width >> half_scale;\n\t\tmf->height = crop->height >> half_scale;\n\n\t\treturn 0;\n\t}\n\n\t \n\n\t \n\tret = ov6650_reg_write(client, REG_HSTRT, sel->r.left >> 1);\n\tif (!ret) {\n\t\tpriv->rect.width += priv->rect.left - sel->r.left;\n\t\tpriv->rect.left = sel->r.left;\n\t\tret = ov6650_reg_write(client, REG_HSTOP,\n\t\t\t\t       (sel->r.left + sel->r.width) >> 1);\n\t}\n\tif (!ret) {\n\t\tpriv->rect.width = sel->r.width;\n\t\tret = ov6650_reg_write(client, REG_VSTRT, sel->r.top >> 1);\n\t}\n\tif (!ret) {\n\t\tpriv->rect.height += priv->rect.top - sel->r.top;\n\t\tpriv->rect.top = sel->r.top;\n\t\tret = ov6650_reg_write(client, REG_VSTOP,\n\t\t\t\t       (sel->r.top + sel->r.height) >> 1);\n\t}\n\tif (!ret)\n\t\tpriv->rect.height = sel->r.height;\n\n\treturn ret;\n}\n\nstatic int ov6650_get_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov6650 *priv = to_ov6650(client);\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\t \n\t*mf = ov6650_def_fmt;\n\n\t \n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tmf->width = sd_state->pads->try_fmt.width;\n\t\tmf->height = sd_state->pads->try_fmt.height;\n\t\tmf->code = sd_state->pads->try_fmt.code;\n\n\t} else {\n\t\tmf->width = priv->rect.width >> priv->half_scale;\n\t\tmf->height = priv->rect.height >> priv->half_scale;\n\t\tmf->code = priv->code;\n\t}\n\treturn 0;\n}\n\n#define to_clkrc(div)\t((div) - 1)\n\n \nstatic int ov6650_s_fmt(struct v4l2_subdev *sd, u32 code, bool half_scale)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov6650 *priv = to_ov6650(client);\n\tu8 coma_set = 0, coma_mask = 0, coml_set, coml_mask;\n\tint ret;\n\n\t \n\tswitch (code) {\n\tcase MEDIA_BUS_FMT_Y8_1X8:\n\t\tdev_dbg(&client->dev, \"pixel format GREY8_1X8\\n\");\n\t\tcoma_mask |= COMA_RGB | COMA_WORD_SWAP | COMA_BYTE_SWAP;\n\t\tcoma_set |= COMA_BW;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\t\tdev_dbg(&client->dev, \"pixel format YUYV8_2X8_LE\\n\");\n\t\tcoma_mask |= COMA_RGB | COMA_BW | COMA_BYTE_SWAP;\n\t\tcoma_set |= COMA_WORD_SWAP;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YVYU8_2X8:\n\t\tdev_dbg(&client->dev, \"pixel format YVYU8_2X8_LE (untested)\\n\");\n\t\tcoma_mask |= COMA_RGB | COMA_BW | COMA_WORD_SWAP |\n\t\t\t\tCOMA_BYTE_SWAP;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\t\tdev_dbg(&client->dev, \"pixel format YUYV8_2X8_BE\\n\");\n\t\tif (half_scale) {\n\t\t\tcoma_mask |= COMA_RGB | COMA_BW | COMA_WORD_SWAP;\n\t\t\tcoma_set |= COMA_BYTE_SWAP;\n\t\t} else {\n\t\t\tcoma_mask |= COMA_RGB | COMA_BW;\n\t\t\tcoma_set |= COMA_BYTE_SWAP | COMA_WORD_SWAP;\n\t\t}\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_VYUY8_2X8:\n\t\tdev_dbg(&client->dev, \"pixel format YVYU8_2X8_BE (untested)\\n\");\n\t\tif (half_scale) {\n\t\t\tcoma_mask |= COMA_RGB | COMA_BW;\n\t\t\tcoma_set |= COMA_BYTE_SWAP | COMA_WORD_SWAP;\n\t\t} else {\n\t\t\tcoma_mask |= COMA_RGB | COMA_BW | COMA_WORD_SWAP;\n\t\t\tcoma_set |= COMA_BYTE_SWAP;\n\t\t}\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\t\tdev_dbg(&client->dev, \"pixel format SBGGR8_1X8 (untested)\\n\");\n\t\tcoma_mask |= COMA_BW | COMA_BYTE_SWAP | COMA_WORD_SWAP;\n\t\tcoma_set |= COMA_RAW_RGB | COMA_RGB;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev, \"Pixel format not handled: 0x%x\\n\", code);\n\t\treturn -EINVAL;\n\t}\n\n\tif (code == MEDIA_BUS_FMT_Y8_1X8 ||\n\t\t\tcode == MEDIA_BUS_FMT_SBGGR8_1X8) {\n\t\tcoml_mask = COML_ONE_CHANNEL;\n\t\tcoml_set = 0;\n\t} else {\n\t\tcoml_mask = 0;\n\t\tcoml_set = COML_ONE_CHANNEL;\n\t}\n\n\tif (half_scale) {\n\t\tdev_dbg(&client->dev, \"max resolution: QCIF\\n\");\n\t\tcoma_set |= COMA_QCIF;\n\t} else {\n\t\tdev_dbg(&client->dev, \"max resolution: CIF\\n\");\n\t\tcoma_mask |= COMA_QCIF;\n\t}\n\n\tret = ov6650_reg_rmw(client, REG_COMA, coma_set, coma_mask);\n\tif (!ret) {\n\t\tpriv->half_scale = half_scale;\n\n\t\tret = ov6650_reg_rmw(client, REG_COML, coml_set, coml_mask);\n\t}\n\tif (!ret)\n\t\tpriv->code = code;\n\n\treturn ret;\n}\n\nstatic int ov6650_set_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov6650 *priv = to_ov6650(client);\n\tstruct v4l2_rect *crop;\n\tbool half_scale;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tswitch (mf->code) {\n\tcase MEDIA_BUS_FMT_Y10_1X10:\n\t\tmf->code = MEDIA_BUS_FMT_Y8_1X8;\n\t\tfallthrough;\n\tcase MEDIA_BUS_FMT_Y8_1X8:\n\tcase MEDIA_BUS_FMT_YVYU8_2X8:\n\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\tcase MEDIA_BUS_FMT_VYUY8_2X8:\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\t\tbreak;\n\tdefault:\n\t\tmf->code = MEDIA_BUS_FMT_SBGGR8_1X8;\n\t\tfallthrough;\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\t\tbreak;\n\t}\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\tcrop = &sd_state->pads->try_crop;\n\telse\n\t\tcrop = &priv->rect;\n\n\thalf_scale = !is_unscaled_ok(mf->width, mf->height, crop);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\t \n\t\tsd_state->pads->try_fmt.width = crop->width >> half_scale;\n\t\tsd_state->pads->try_fmt.height = crop->height >> half_scale;\n\t\tsd_state->pads->try_fmt.code = mf->code;\n\n\t\t \n\t\t*mf = ov6650_def_fmt;\n\t\tmf->width = sd_state->pads->try_fmt.width;\n\t\tmf->height = sd_state->pads->try_fmt.height;\n\t\tmf->code = sd_state->pads->try_fmt.code;\n\n\t} else {\n\t\tint ret = 0;\n\n\t\t \n\t\tif (mf->code != priv->code || half_scale != priv->half_scale)\n\t\t\tret = ov6650_s_fmt(sd, mf->code, half_scale);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\t*mf = ov6650_def_fmt;\n\t\tmf->width = priv->rect.width >> priv->half_scale;\n\t\tmf->height = priv->rect.height >> priv->half_scale;\n\t\tmf->code = priv->code;\n\t}\n\treturn 0;\n}\n\nstatic int ov6650_enum_mbus_code(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index >= ARRAY_SIZE(ov6650_codes))\n\t\treturn -EINVAL;\n\n\tcode->code = ov6650_codes[code->index];\n\treturn 0;\n}\n\nstatic int ov6650_enum_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_subdev_frame_interval_enum *fie)\n{\n\tint i;\n\n\t \n\tif (fie->index > CLKRC_DIV_MASK ||\n\t    GET_CLKRC_DIV(fie->index) > FRAME_RATE_MAX)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(ov6650_codes); i++)\n\t\tif (fie->code == ov6650_codes[i])\n\t\t\tbreak;\n\tif (i == ARRAY_SIZE(ov6650_codes))\n\t\treturn -EINVAL;\n\n\tif (!fie->width || fie->width > W_CIF ||\n\t    !fie->height || fie->height > H_CIF)\n\t\treturn -EINVAL;\n\n\tfie->interval.numerator = GET_CLKRC_DIV(fie->index);\n\tfie->interval.denominator = FRAME_RATE_MAX;\n\n\treturn 0;\n}\n\nstatic int ov6650_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *ival)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov6650 *priv = to_ov6650(client);\n\n\tival->interval = priv->tpf;\n\n\tdev_dbg(&client->dev, \"Frame interval: %u/%u s\\n\",\n\t\tival->interval.numerator, ival->interval.denominator);\n\n\treturn 0;\n}\n\nstatic int ov6650_s_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *ival)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov6650 *priv = to_ov6650(client);\n\tstruct v4l2_fract *tpf = &ival->interval;\n\tint div, ret;\n\n\tif (tpf->numerator == 0 || tpf->denominator == 0)\n\t\tdiv = 1;   \n\telse\n\t\tdiv = (tpf->numerator * FRAME_RATE_MAX) / tpf->denominator;\n\n\tif (div == 0)\n\t\tdiv = 1;\n\telse if (div > GET_CLKRC_DIV(CLKRC_DIV_MASK))\n\t\tdiv = GET_CLKRC_DIV(CLKRC_DIV_MASK);\n\n\tret = ov6650_reg_rmw(client, REG_CLKRC, to_clkrc(div), CLKRC_DIV_MASK);\n\tif (!ret) {\n\t\tpriv->tpf.numerator = div;\n\t\tpriv->tpf.denominator = FRAME_RATE_MAX;\n\n\t\t*tpf = priv->tpf;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ov6650_reset(struct i2c_client *client)\n{\n\tint ret;\n\n\tdev_dbg(&client->dev, \"reset\\n\");\n\n\tret = ov6650_reg_rmw(client, REG_COMA, COMA_RESET, 0);\n\tif (ret)\n\t\tdev_err(&client->dev,\n\t\t\t\"An error occurred while entering soft reset!\\n\");\n\n\treturn ret;\n}\n\n \nstatic int ov6650_prog_dflt(struct i2c_client *client, u8 clkrc)\n{\n\tint ret;\n\n\tdev_dbg(&client->dev, \"initializing\\n\");\n\n\tret = ov6650_reg_write(client, REG_COMA, 0);\t \n\tif (!ret)\n\t\tret = ov6650_reg_write(client, REG_CLKRC, clkrc);\n\tif (!ret)\n\t\tret = ov6650_reg_rmw(client, REG_COMB, 0, COMB_BAND_FILTER);\n\n\treturn ret;\n}\n\nstatic int ov6650_video_probe(struct v4l2_subdev *sd)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov6650 *priv = to_ov6650(client);\n\tconst struct ov6650_xclk *xclk = NULL;\n\tunsigned long rate;\n\tu8 pidh, pidl, midh, midl;\n\tint i, ret = 0;\n\n\tpriv->clk = devm_clk_get(&client->dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tret = PTR_ERR(priv->clk);\n\t\tdev_err(&client->dev, \"clk request err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trate = clk_get_rate(priv->clk);\n\tfor (i = 0; rate && i < ARRAY_SIZE(ov6650_xclk); i++) {\n\t\tif (rate != ov6650_xclk[i].rate)\n\t\t\tcontinue;\n\n\t\txclk = &ov6650_xclk[i];\n\t\tdev_info(&client->dev, \"using host default clock rate %lukHz\\n\",\n\t\t\t rate / 1000);\n\t\tbreak;\n\t}\n\tfor (i = 0; !xclk && i < ARRAY_SIZE(ov6650_xclk); i++) {\n\t\tret = clk_set_rate(priv->clk, ov6650_xclk[i].rate);\n\t\tif (ret || clk_get_rate(priv->clk) != ov6650_xclk[i].rate)\n\t\t\tcontinue;\n\n\t\txclk = &ov6650_xclk[i];\n\t\tdev_info(&client->dev, \"using negotiated clock rate %lukHz\\n\",\n\t\t\t xclk->rate / 1000);\n\t\tbreak;\n\t}\n\tif (!xclk) {\n\t\tdev_err(&client->dev, \"unable to get supported clock rate\\n\");\n\t\tif (!ret)\n\t\t\tret = -EINVAL;\n\t\treturn ret;\n\t}\n\n\tret = ov6650_s_power(sd, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmsleep(20);\n\n\t \n\tret = ov6650_reg_read(client, REG_PIDH, &pidh);\n\tif (!ret)\n\t\tret = ov6650_reg_read(client, REG_PIDL, &pidl);\n\tif (!ret)\n\t\tret = ov6650_reg_read(client, REG_MIDH, &midh);\n\tif (!ret)\n\t\tret = ov6650_reg_read(client, REG_MIDL, &midl);\n\n\tif (ret)\n\t\tgoto done;\n\n\tif ((pidh != OV6650_PIDH) || (pidl != OV6650_PIDL)) {\n\t\tdev_err(&client->dev, \"Product ID error 0x%02x:0x%02x\\n\",\n\t\t\t\tpidh, pidl);\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tdev_info(&client->dev,\n\t\t\"ov6650 Product ID 0x%02x:0x%02x Manufacturer ID 0x%02x:0x%02x\\n\",\n\t\tpidh, pidl, midh, midl);\n\n\tret = ov6650_reset(client);\n\tif (!ret)\n\t\tret = ov6650_prog_dflt(client, xclk->clkrc);\n\tif (!ret) {\n\t\t \n\t\tret = ov6650_s_fmt(sd, ov6650_def_fmt.code, false);\n\t}\n\tif (!ret)\n\t\tret = v4l2_ctrl_handler_setup(&priv->hdl);\n\ndone:\n\tov6650_s_power(sd, 0);\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops ov6550_ctrl_ops = {\n\t.g_volatile_ctrl = ov6550_g_volatile_ctrl,\n\t.s_ctrl = ov6550_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops ov6650_core_ops = {\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register\t\t= ov6650_get_register,\n\t.s_register\t\t= ov6650_set_register,\n#endif\n\t.s_power\t\t= ov6650_s_power,\n};\n\n \nstatic int ov6650_get_mbus_config(struct v4l2_subdev *sd,\n\t\t\t\t  unsigned int pad,\n\t\t\t\t  struct v4l2_mbus_config *cfg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tu8 comj, comf;\n\tint ret;\n\n\tret = ov6650_reg_read(client, REG_COMJ, &comj);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov6650_reg_read(client, REG_COMF, &comf);\n\tif (ret)\n\t\treturn ret;\n\n\tcfg->type = V4L2_MBUS_PARALLEL;\n\n\tcfg->bus.parallel.flags = V4L2_MBUS_MASTER | V4L2_MBUS_DATA_ACTIVE_HIGH\n\t\t| ((comj & COMJ_VSYNC_HIGH)  ? V4L2_MBUS_VSYNC_ACTIVE_HIGH\n\t\t\t\t\t     : V4L2_MBUS_VSYNC_ACTIVE_LOW)\n\t\t| ((comf & COMF_HREF_LOW)    ? V4L2_MBUS_HSYNC_ACTIVE_LOW\n\t\t\t\t\t     : V4L2_MBUS_HSYNC_ACTIVE_HIGH)\n\t\t| ((comj & COMJ_PCLK_RISING) ? V4L2_MBUS_PCLK_SAMPLE_RISING\n\t\t\t\t\t     : V4L2_MBUS_PCLK_SAMPLE_FALLING);\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops ov6650_video_ops = {\n\t.s_stream\t= ov6650_s_stream,\n\t.g_frame_interval = ov6650_g_frame_interval,\n\t.s_frame_interval = ov6650_s_frame_interval,\n};\n\nstatic const struct v4l2_subdev_pad_ops ov6650_pad_ops = {\n\t.enum_mbus_code\t\t= ov6650_enum_mbus_code,\n\t.enum_frame_interval\t= ov6650_enum_frame_interval,\n\t.get_selection\t\t= ov6650_get_selection,\n\t.set_selection\t\t= ov6650_set_selection,\n\t.get_fmt\t\t= ov6650_get_fmt,\n\t.set_fmt\t\t= ov6650_set_fmt,\n\t.get_mbus_config\t= ov6650_get_mbus_config,\n};\n\nstatic const struct v4l2_subdev_ops ov6650_subdev_ops = {\n\t.core\t= &ov6650_core_ops,\n\t.video\t= &ov6650_video_ops,\n\t.pad\t= &ov6650_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops ov6650_internal_ops = {\n\t.registered = ov6650_video_probe,\n};\n\n \nstatic int ov6650_probe(struct i2c_client *client)\n{\n\tstruct ov6650 *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tv4l2_i2c_subdev_init(&priv->subdev, client, &ov6650_subdev_ops);\n\tv4l2_ctrl_handler_init(&priv->hdl, 13);\n\tv4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\n\t\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\n\t\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\tpriv->autogain = v4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\n\t\t\tV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\tpriv->gain = v4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, 0, 0x3f, 1, DEF_GAIN);\n\tpriv->autowb = v4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\n\t\t\tV4L2_CID_AUTO_WHITE_BALANCE, 0, 1, 1, 1);\n\tpriv->blue = v4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\n\t\t\tV4L2_CID_BLUE_BALANCE, 0, 0xff, 1, DEF_BLUE);\n\tpriv->red = v4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\n\t\t\tV4L2_CID_RED_BALANCE, 0, 0xff, 1, DEF_RED);\n\tv4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 0xf, 1, 0x8);\n\tv4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\n\t\t\tV4L2_CID_HUE, 0, HUE_MASK, 1, DEF_HUE);\n\tv4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 0xff, 1, 0x80);\n\tpriv->autoexposure = v4l2_ctrl_new_std_menu(&priv->hdl,\n\t\t\t&ov6550_ctrl_ops, V4L2_CID_EXPOSURE_AUTO,\n\t\t\tV4L2_EXPOSURE_MANUAL, 0, V4L2_EXPOSURE_AUTO);\n\tpriv->exposure = v4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE, 0, 0xff, 1, DEF_AECH);\n\tv4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\n\t\t\tV4L2_CID_GAMMA, 0, 0xff, 1, 0x12);\n\n\tpriv->subdev.ctrl_handler = &priv->hdl;\n\tif (priv->hdl.error) {\n\t\tret = priv->hdl.error;\n\t\tgoto ectlhdlfree;\n\t}\n\n\tv4l2_ctrl_auto_cluster(2, &priv->autogain, 0, true);\n\tv4l2_ctrl_auto_cluster(3, &priv->autowb, 0, true);\n\tv4l2_ctrl_auto_cluster(2, &priv->autoexposure,\n\t\t\t\tV4L2_EXPOSURE_MANUAL, true);\n\n\tpriv->rect.left\t  = DEF_HSTRT << 1;\n\tpriv->rect.top\t  = DEF_VSTRT << 1;\n\tpriv->rect.width  = W_CIF;\n\tpriv->rect.height = H_CIF;\n\n\t \n\tpriv->tpf.numerator   = GET_CLKRC_DIV(DEF_CLKRC);\n\tpriv->tpf.denominator = FRAME_RATE_MAX;\n\n\tpriv->subdev.internal_ops = &ov6650_internal_ops;\n\n\tret = v4l2_async_register_subdev(&priv->subdev);\n\tif (!ret)\n\t\treturn 0;\nectlhdlfree:\n\tv4l2_ctrl_handler_free(&priv->hdl);\n\n\treturn ret;\n}\n\nstatic void ov6650_remove(struct i2c_client *client)\n{\n\tstruct ov6650 *priv = to_ov6650(client);\n\n\tv4l2_async_unregister_subdev(&priv->subdev);\n\tv4l2_ctrl_handler_free(&priv->hdl);\n}\n\nstatic const struct i2c_device_id ov6650_id[] = {\n\t{ \"ov6650\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ov6650_id);\n\nstatic struct i2c_driver ov6650_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ov6650\",\n\t},\n\t.probe    = ov6650_probe,\n\t.remove   = ov6650_remove,\n\t.id_table = ov6650_id,\n};\n\nmodule_i2c_driver(ov6650_i2c_driver);\n\nMODULE_DESCRIPTION(\"V4L2 subdevice driver for OmniVision OV6650 camera sensor\");\nMODULE_AUTHOR(\"Janusz Krzysztofik <jmkrzyszt@gmail.com\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}