{
  "module_name": "rj54n1cb0c.c",
  "hash_id": "42c461fa437aa09a04849a9e57d100454be3e938c1acfe5fa65d61bac8109f1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/rj54n1cb0c.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/v4l2-mediabus.h>\n#include <linux/videodev2.h>\n\n#include <media/i2c/rj54n1cb0c.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-subdev.h>\n\n#define RJ54N1_DEV_CODE\t\t\t0x0400\n#define RJ54N1_DEV_CODE2\t\t0x0401\n#define RJ54N1_OUT_SEL\t\t\t0x0403\n#define RJ54N1_XY_OUTPUT_SIZE_S_H\t0x0404\n#define RJ54N1_X_OUTPUT_SIZE_S_L\t0x0405\n#define RJ54N1_Y_OUTPUT_SIZE_S_L\t0x0406\n#define RJ54N1_XY_OUTPUT_SIZE_P_H\t0x0407\n#define RJ54N1_X_OUTPUT_SIZE_P_L\t0x0408\n#define RJ54N1_Y_OUTPUT_SIZE_P_L\t0x0409\n#define RJ54N1_LINE_LENGTH_PCK_S_H\t0x040a\n#define RJ54N1_LINE_LENGTH_PCK_S_L\t0x040b\n#define RJ54N1_LINE_LENGTH_PCK_P_H\t0x040c\n#define RJ54N1_LINE_LENGTH_PCK_P_L\t0x040d\n#define RJ54N1_RESIZE_N\t\t\t0x040e\n#define RJ54N1_RESIZE_N_STEP\t\t0x040f\n#define RJ54N1_RESIZE_STEP\t\t0x0410\n#define RJ54N1_RESIZE_HOLD_H\t\t0x0411\n#define RJ54N1_RESIZE_HOLD_L\t\t0x0412\n#define RJ54N1_H_OBEN_OFS\t\t0x0413\n#define RJ54N1_V_OBEN_OFS\t\t0x0414\n#define RJ54N1_RESIZE_CONTROL\t\t0x0415\n#define RJ54N1_STILL_CONTROL\t\t0x0417\n#define RJ54N1_INC_USE_SEL_H\t\t0x0425\n#define RJ54N1_INC_USE_SEL_L\t\t0x0426\n#define RJ54N1_MIRROR_STILL_MODE\t0x0427\n#define RJ54N1_INIT_START\t\t0x0428\n#define RJ54N1_SCALE_1_2_LEV\t\t0x0429\n#define RJ54N1_SCALE_4_LEV\t\t0x042a\n#define RJ54N1_Y_GAIN\t\t\t0x04d8\n#define RJ54N1_APT_GAIN_UP\t\t0x04fa\n#define RJ54N1_RA_SEL_UL\t\t0x0530\n#define RJ54N1_BYTE_SWAP\t\t0x0531\n#define RJ54N1_OUT_SIGPO\t\t0x053b\n#define RJ54N1_WB_SEL_WEIGHT_I\t\t0x054e\n#define RJ54N1_BIT8_WB\t\t\t0x0569\n#define RJ54N1_HCAPS_WB\t\t\t0x056a\n#define RJ54N1_VCAPS_WB\t\t\t0x056b\n#define RJ54N1_HCAPE_WB\t\t\t0x056c\n#define RJ54N1_VCAPE_WB\t\t\t0x056d\n#define RJ54N1_EXPOSURE_CONTROL\t\t0x058c\n#define RJ54N1_FRAME_LENGTH_S_H\t\t0x0595\n#define RJ54N1_FRAME_LENGTH_S_L\t\t0x0596\n#define RJ54N1_FRAME_LENGTH_P_H\t\t0x0597\n#define RJ54N1_FRAME_LENGTH_P_L\t\t0x0598\n#define RJ54N1_PEAK_H\t\t\t0x05b7\n#define RJ54N1_PEAK_50\t\t\t0x05b8\n#define RJ54N1_PEAK_60\t\t\t0x05b9\n#define RJ54N1_PEAK_DIFF\t\t0x05ba\n#define RJ54N1_IOC\t\t\t0x05ef\n#define RJ54N1_TG_BYPASS\t\t0x0700\n#define RJ54N1_PLL_L\t\t\t0x0701\n#define RJ54N1_PLL_N\t\t\t0x0702\n#define RJ54N1_PLL_EN\t\t\t0x0704\n#define RJ54N1_RATIO_TG\t\t\t0x0706\n#define RJ54N1_RATIO_T\t\t\t0x0707\n#define RJ54N1_RATIO_R\t\t\t0x0708\n#define RJ54N1_RAMP_TGCLK_EN\t\t0x0709\n#define RJ54N1_OCLK_DSP\t\t\t0x0710\n#define RJ54N1_RATIO_OP\t\t\t0x0711\n#define RJ54N1_RATIO_O\t\t\t0x0712\n#define RJ54N1_OCLK_SEL_EN\t\t0x0713\n#define RJ54N1_CLK_RST\t\t\t0x0717\n#define RJ54N1_RESET_STANDBY\t\t0x0718\n#define RJ54N1_FWFLG\t\t\t0x07fe\n\n#define E_EXCLK\t\t\t\t(1 << 7)\n#define SOFT_STDBY\t\t\t(1 << 4)\n#define SEN_RSTX\t\t\t(1 << 2)\n#define TG_RSTX\t\t\t\t(1 << 1)\n#define DSP_RSTX\t\t\t(1 << 0)\n\n#define RESIZE_HOLD_SEL\t\t\t(1 << 2)\n#define RESIZE_GO\t\t\t(1 << 1)\n\n \n#define RJ54N1_COLUMN_SKIP\t\t0\n#define RJ54N1_ROW_SKIP\t\t\t0\n#define RJ54N1_MAX_WIDTH\t\t1600\n#define RJ54N1_MAX_HEIGHT\t\t1200\n\n#define PLL_L\t\t\t\t2\n#define PLL_N\t\t\t\t0x31\n\n \n\n \nstruct rj54n1_datafmt {\n\tu32\tcode;\n\tenum v4l2_colorspace\t\tcolorspace;\n};\n\n \nstatic const struct rj54n1_datafmt *rj54n1_find_datafmt(\n\tu32 code, const struct rj54n1_datafmt *fmt,\n\tint n)\n{\n\tint i;\n\tfor (i = 0; i < n; i++)\n\t\tif (fmt[i].code == code)\n\t\t\treturn fmt + i;\n\n\treturn NULL;\n}\n\nstatic const struct rj54n1_datafmt rj54n1_colour_fmts[] = {\n\t{MEDIA_BUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_JPEG},\n\t{MEDIA_BUS_FMT_YVYU8_2X8, V4L2_COLORSPACE_JPEG},\n\t{MEDIA_BUS_FMT_RGB565_2X8_LE, V4L2_COLORSPACE_SRGB},\n\t{MEDIA_BUS_FMT_RGB565_2X8_BE, V4L2_COLORSPACE_SRGB},\n\t{MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE, V4L2_COLORSPACE_SRGB},\n\t{MEDIA_BUS_FMT_SBGGR10_2X8_PADLO_LE, V4L2_COLORSPACE_SRGB},\n\t{MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_BE, V4L2_COLORSPACE_SRGB},\n\t{MEDIA_BUS_FMT_SBGGR10_2X8_PADLO_BE, V4L2_COLORSPACE_SRGB},\n\t{MEDIA_BUS_FMT_SBGGR10_1X10, V4L2_COLORSPACE_SRGB},\n};\n\nstruct rj54n1_clock_div {\n\tu8 ratio_tg;\t \n\tu8 ratio_t;\n\tu8 ratio_r;\n\tu8 ratio_op;\n\tu8 ratio_o;\n};\n\nstruct rj54n1 {\n\tstruct v4l2_subdev subdev;\n\tstruct v4l2_ctrl_handler hdl;\n\tstruct clk *clk;\n\tstruct gpio_desc *pwup_gpio;\n\tstruct gpio_desc *enable_gpio;\n\tstruct rj54n1_clock_div clk_div;\n\tconst struct rj54n1_datafmt *fmt;\n\tstruct v4l2_rect rect;\t \n\tunsigned int tgclk_mhz;\n\tbool auto_wb;\n\tunsigned short width;\t \n\tunsigned short height;\n\tunsigned short resize;\t \n\tunsigned short scale;\n\tu8 bank;\n};\n\nstruct rj54n1_reg_val {\n\tu16 reg;\n\tu8 val;\n};\n\nstatic const struct rj54n1_reg_val bank_4[] = {\n\t{0x417, 0},\n\t{0x42c, 0},\n\t{0x42d, 0xf0},\n\t{0x42e, 0},\n\t{0x42f, 0x50},\n\t{0x430, 0xf5},\n\t{0x431, 0x16},\n\t{0x432, 0x20},\n\t{0x433, 0},\n\t{0x434, 0xc8},\n\t{0x43c, 8},\n\t{0x43e, 0x90},\n\t{0x445, 0x83},\n\t{0x4ba, 0x58},\n\t{0x4bb, 4},\n\t{0x4bc, 0x20},\n\t{0x4db, 4},\n\t{0x4fe, 2},\n};\n\nstatic const struct rj54n1_reg_val bank_5[] = {\n\t{0x514, 0},\n\t{0x516, 0},\n\t{0x518, 0},\n\t{0x51a, 0},\n\t{0x51d, 0xff},\n\t{0x56f, 0x28},\n\t{0x575, 0x40},\n\t{0x5bc, 0x48},\n\t{0x5c1, 6},\n\t{0x5e5, 0x11},\n\t{0x5e6, 0x43},\n\t{0x5e7, 0x33},\n\t{0x5e8, 0x21},\n\t{0x5e9, 0x30},\n\t{0x5ea, 0x0},\n\t{0x5eb, 0xa5},\n\t{0x5ec, 0xff},\n\t{0x5fe, 2},\n};\n\nstatic const struct rj54n1_reg_val bank_7[] = {\n\t{0x70a, 0},\n\t{0x714, 0xff},\n\t{0x715, 0xff},\n\t{0x716, 0x1f},\n\t{0x7FE, 2},\n};\n\nstatic const struct rj54n1_reg_val bank_8[] = {\n\t{0x800, 0x00},\n\t{0x801, 0x01},\n\t{0x802, 0x61},\n\t{0x805, 0x00},\n\t{0x806, 0x00},\n\t{0x807, 0x00},\n\t{0x808, 0x00},\n\t{0x809, 0x01},\n\t{0x80A, 0x61},\n\t{0x80B, 0x00},\n\t{0x80C, 0x01},\n\t{0x80D, 0x00},\n\t{0x80E, 0x00},\n\t{0x80F, 0x00},\n\t{0x810, 0x00},\n\t{0x811, 0x01},\n\t{0x812, 0x61},\n\t{0x813, 0x00},\n\t{0x814, 0x11},\n\t{0x815, 0x00},\n\t{0x816, 0x41},\n\t{0x817, 0x00},\n\t{0x818, 0x51},\n\t{0x819, 0x01},\n\t{0x81A, 0x1F},\n\t{0x81B, 0x00},\n\t{0x81C, 0x01},\n\t{0x81D, 0x00},\n\t{0x81E, 0x11},\n\t{0x81F, 0x00},\n\t{0x820, 0x41},\n\t{0x821, 0x00},\n\t{0x822, 0x51},\n\t{0x823, 0x00},\n\t{0x824, 0x00},\n\t{0x825, 0x00},\n\t{0x826, 0x47},\n\t{0x827, 0x01},\n\t{0x828, 0x4F},\n\t{0x829, 0x00},\n\t{0x82A, 0x00},\n\t{0x82B, 0x00},\n\t{0x82C, 0x30},\n\t{0x82D, 0x00},\n\t{0x82E, 0x40},\n\t{0x82F, 0x00},\n\t{0x830, 0xB3},\n\t{0x831, 0x00},\n\t{0x832, 0xE3},\n\t{0x833, 0x00},\n\t{0x834, 0x00},\n\t{0x835, 0x00},\n\t{0x836, 0x00},\n\t{0x837, 0x00},\n\t{0x838, 0x00},\n\t{0x839, 0x01},\n\t{0x83A, 0x61},\n\t{0x83B, 0x00},\n\t{0x83C, 0x01},\n\t{0x83D, 0x00},\n\t{0x83E, 0x00},\n\t{0x83F, 0x00},\n\t{0x840, 0x00},\n\t{0x841, 0x01},\n\t{0x842, 0x61},\n\t{0x843, 0x00},\n\t{0x844, 0x1D},\n\t{0x845, 0x00},\n\t{0x846, 0x00},\n\t{0x847, 0x00},\n\t{0x848, 0x00},\n\t{0x849, 0x01},\n\t{0x84A, 0x1F},\n\t{0x84B, 0x00},\n\t{0x84C, 0x05},\n\t{0x84D, 0x00},\n\t{0x84E, 0x19},\n\t{0x84F, 0x01},\n\t{0x850, 0x21},\n\t{0x851, 0x01},\n\t{0x852, 0x5D},\n\t{0x853, 0x00},\n\t{0x854, 0x00},\n\t{0x855, 0x00},\n\t{0x856, 0x19},\n\t{0x857, 0x01},\n\t{0x858, 0x21},\n\t{0x859, 0x00},\n\t{0x85A, 0x00},\n\t{0x85B, 0x00},\n\t{0x85C, 0x00},\n\t{0x85D, 0x00},\n\t{0x85E, 0x00},\n\t{0x85F, 0x00},\n\t{0x860, 0xB3},\n\t{0x861, 0x00},\n\t{0x862, 0xE3},\n\t{0x863, 0x00},\n\t{0x864, 0x00},\n\t{0x865, 0x00},\n\t{0x866, 0x00},\n\t{0x867, 0x00},\n\t{0x868, 0x00},\n\t{0x869, 0xE2},\n\t{0x86A, 0x00},\n\t{0x86B, 0x01},\n\t{0x86C, 0x06},\n\t{0x86D, 0x00},\n\t{0x86E, 0x00},\n\t{0x86F, 0x00},\n\t{0x870, 0x60},\n\t{0x871, 0x8C},\n\t{0x872, 0x10},\n\t{0x873, 0x00},\n\t{0x874, 0xE0},\n\t{0x875, 0x00},\n\t{0x876, 0x27},\n\t{0x877, 0x01},\n\t{0x878, 0x00},\n\t{0x879, 0x00},\n\t{0x87A, 0x00},\n\t{0x87B, 0x03},\n\t{0x87C, 0x00},\n\t{0x87D, 0x00},\n\t{0x87E, 0x00},\n\t{0x87F, 0x00},\n\t{0x880, 0x00},\n\t{0x881, 0x00},\n\t{0x882, 0x00},\n\t{0x883, 0x00},\n\t{0x884, 0x00},\n\t{0x885, 0x00},\n\t{0x886, 0xF8},\n\t{0x887, 0x00},\n\t{0x888, 0x03},\n\t{0x889, 0x00},\n\t{0x88A, 0x64},\n\t{0x88B, 0x00},\n\t{0x88C, 0x03},\n\t{0x88D, 0x00},\n\t{0x88E, 0xB1},\n\t{0x88F, 0x00},\n\t{0x890, 0x03},\n\t{0x891, 0x01},\n\t{0x892, 0x1D},\n\t{0x893, 0x00},\n\t{0x894, 0x03},\n\t{0x895, 0x01},\n\t{0x896, 0x4B},\n\t{0x897, 0x00},\n\t{0x898, 0xE5},\n\t{0x899, 0x00},\n\t{0x89A, 0x01},\n\t{0x89B, 0x00},\n\t{0x89C, 0x01},\n\t{0x89D, 0x04},\n\t{0x89E, 0xC8},\n\t{0x89F, 0x00},\n\t{0x8A0, 0x01},\n\t{0x8A1, 0x01},\n\t{0x8A2, 0x61},\n\t{0x8A3, 0x00},\n\t{0x8A4, 0x01},\n\t{0x8A5, 0x00},\n\t{0x8A6, 0x00},\n\t{0x8A7, 0x00},\n\t{0x8A8, 0x00},\n\t{0x8A9, 0x00},\n\t{0x8AA, 0x7F},\n\t{0x8AB, 0x03},\n\t{0x8AC, 0x00},\n\t{0x8AD, 0x00},\n\t{0x8AE, 0x00},\n\t{0x8AF, 0x00},\n\t{0x8B0, 0x00},\n\t{0x8B1, 0x00},\n\t{0x8B6, 0x00},\n\t{0x8B7, 0x01},\n\t{0x8B8, 0x00},\n\t{0x8B9, 0x00},\n\t{0x8BA, 0x02},\n\t{0x8BB, 0x00},\n\t{0x8BC, 0xFF},\n\t{0x8BD, 0x00},\n\t{0x8FE, 2},\n};\n\nstatic const struct rj54n1_reg_val bank_10[] = {\n\t{0x10bf, 0x69}\n};\n\n \nstatic const struct rj54n1_clock_div clk_div = {\n\t.ratio_tg\t= 3  ,\n\t.ratio_t\t= 4  ,\n\t.ratio_r\t= 4  ,\n\t.ratio_op\t= 1  ,\n\t.ratio_o\t= 9  ,\n};\n\nstatic struct rj54n1 *to_rj54n1(const struct i2c_client *client)\n{\n\treturn container_of(i2c_get_clientdata(client), struct rj54n1, subdev);\n}\n\nstatic int reg_read(struct i2c_client *client, const u16 reg)\n{\n\tstruct rj54n1 *rj54n1 = to_rj54n1(client);\n\tint ret;\n\n\t \n\tif (rj54n1->bank != reg >> 8) {\n\t\tdev_dbg(&client->dev, \"[0x%x] = 0x%x\\n\", 0xff, reg >> 8);\n\t\tret = i2c_smbus_write_byte_data(client, 0xff, reg >> 8);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\trj54n1->bank = reg >> 8;\n\t}\n\treturn i2c_smbus_read_byte_data(client, reg & 0xff);\n}\n\nstatic int reg_write(struct i2c_client *client, const u16 reg,\n\t\t     const u8 data)\n{\n\tstruct rj54n1 *rj54n1 = to_rj54n1(client);\n\tint ret;\n\n\t \n\tif (rj54n1->bank != reg >> 8) {\n\t\tdev_dbg(&client->dev, \"[0x%x] = 0x%x\\n\", 0xff, reg >> 8);\n\t\tret = i2c_smbus_write_byte_data(client, 0xff, reg >> 8);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\trj54n1->bank = reg >> 8;\n\t}\n\tdev_dbg(&client->dev, \"[0x%x] = 0x%x\\n\", reg & 0xff, data);\n\treturn i2c_smbus_write_byte_data(client, reg & 0xff, data);\n}\n\nstatic int reg_set(struct i2c_client *client, const u16 reg,\n\t\t   const u8 data, const u8 mask)\n{\n\tint ret;\n\n\tret = reg_read(client, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn reg_write(client, reg, (ret & ~mask) | (data & mask));\n}\n\nstatic int reg_write_multiple(struct i2c_client *client,\n\t\t\t      const struct rj54n1_reg_val *rv, const int n)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < n; i++) {\n\t\tret = reg_write(client, rv->reg, rv->val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\trv++;\n\t}\n\n\treturn 0;\n}\n\nstatic int rj54n1_enum_mbus_code(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index >= ARRAY_SIZE(rj54n1_colour_fmts))\n\t\treturn -EINVAL;\n\n\tcode->code = rj54n1_colour_fmts[code->index].code;\n\treturn 0;\n}\n\nstatic int rj54n1_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\t \n\treturn reg_set(client, RJ54N1_STILL_CONTROL, (!enable) << 7, 0x80);\n}\n\nstatic int rj54n1_set_rect(struct i2c_client *client,\n\t\t\t   u16 reg_x, u16 reg_y, u16 reg_xy,\n\t\t\t   u32 width, u32 height)\n{\n\tint ret;\n\n\tret = reg_write(client, reg_xy,\n\t\t\t((width >> 4) & 0x70) |\n\t\t\t((height >> 8) & 7));\n\n\tif (!ret)\n\t\tret = reg_write(client, reg_x, width & 0xff);\n\tif (!ret)\n\t\tret = reg_write(client, reg_y, height & 0xff);\n\n\treturn ret;\n}\n\n \nstatic int rj54n1_commit(struct i2c_client *client)\n{\n\tint ret = reg_write(client, RJ54N1_INIT_START, 1);\n\tmsleep(10);\n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_INIT_START, 0);\n\treturn ret;\n}\n\nstatic int rj54n1_sensor_scale(struct v4l2_subdev *sd, s32 *in_w, s32 *in_h,\n\t\t\t       s32 *out_w, s32 *out_h);\n\nstatic int rj54n1_set_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct rj54n1 *rj54n1 = to_rj54n1(client);\n\tconst struct v4l2_rect *rect = &sel->r;\n\tint output_w, output_h, input_w = rect->width, input_h = rect->height;\n\tint ret;\n\n\tif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||\n\t    sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\t \n\tv4l_bound_align_image(&input_w, 8, RJ54N1_MAX_WIDTH, 0,\n\t\t\t      &input_h, 8, RJ54N1_MAX_HEIGHT, 0, 0);\n\n\toutput_w = (input_w * 1024 + rj54n1->resize / 2) / rj54n1->resize;\n\toutput_h = (input_h * 1024 + rj54n1->resize / 2) / rj54n1->resize;\n\n\tdev_dbg(&client->dev, \"Scaling for %dx%d : %u = %dx%d\\n\",\n\t\tinput_w, input_h, rj54n1->resize, output_w, output_h);\n\n\tret = rj54n1_sensor_scale(sd, &input_w, &input_h, &output_w, &output_h);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trj54n1->width\t\t= output_w;\n\trj54n1->height\t\t= output_h;\n\trj54n1->resize\t\t= ret;\n\trj54n1->rect.width\t= input_w;\n\trj54n1->rect.height\t= input_h;\n\n\treturn 0;\n}\n\nstatic int rj54n1_get_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct rj54n1 *rj54n1 = to_rj54n1(client);\n\n\tif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.left = RJ54N1_COLUMN_SKIP;\n\t\tsel->r.top = RJ54N1_ROW_SKIP;\n\t\tsel->r.width = RJ54N1_MAX_WIDTH;\n\t\tsel->r.height = RJ54N1_MAX_HEIGHT;\n\t\treturn 0;\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = rj54n1->rect;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int rj54n1_get_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct rj54n1 *rj54n1 = to_rj54n1(client);\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tmf->code\t= rj54n1->fmt->code;\n\tmf->colorspace\t= rj54n1->fmt->colorspace;\n\tmf->ycbcr_enc\t= V4L2_YCBCR_ENC_601;\n\tmf->xfer_func\t= V4L2_XFER_FUNC_SRGB;\n\tmf->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tmf->field\t= V4L2_FIELD_NONE;\n\tmf->width\t= rj54n1->width;\n\tmf->height\t= rj54n1->height;\n\n\treturn 0;\n}\n\n \nstatic int rj54n1_sensor_scale(struct v4l2_subdev *sd, s32 *in_w, s32 *in_h,\n\t\t\t       s32 *out_w, s32 *out_h)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct rj54n1 *rj54n1 = to_rj54n1(client);\n\tunsigned int skip, resize, input_w = *in_w, input_h = *in_h,\n\t\toutput_w = *out_w, output_h = *out_h;\n\tu16 inc_sel, wb_bit8, wb_left, wb_right, wb_top, wb_bottom;\n\tunsigned int peak, peak_50, peak_60;\n\tint ret;\n\n\t \n\tif (output_w > max(512U, input_w / 2)) {\n\t\tif (2 * output_w > RJ54N1_MAX_WIDTH) {\n\t\t\tinput_w = RJ54N1_MAX_WIDTH;\n\t\t\toutput_w = RJ54N1_MAX_WIDTH / 2;\n\t\t} else {\n\t\t\tinput_w = output_w * 2;\n\t\t}\n\n\t\tdev_dbg(&client->dev, \"Adjusted output width: in %u, out %u\\n\",\n\t\t\tinput_w, output_w);\n\t}\n\n\tif (output_h > max(384U, input_h / 2)) {\n\t\tif (2 * output_h > RJ54N1_MAX_HEIGHT) {\n\t\t\tinput_h = RJ54N1_MAX_HEIGHT;\n\t\t\toutput_h = RJ54N1_MAX_HEIGHT / 2;\n\t\t} else {\n\t\t\tinput_h = output_h * 2;\n\t\t}\n\n\t\tdev_dbg(&client->dev, \"Adjusted output height: in %u, out %u\\n\",\n\t\t\tinput_h, output_h);\n\t}\n\n\t \n\tret = rj54n1_set_rect(client, RJ54N1_X_OUTPUT_SIZE_S_L,\n\t\t\t      RJ54N1_Y_OUTPUT_SIZE_S_L,\n\t\t\t      RJ54N1_XY_OUTPUT_SIZE_S_H, output_w, output_h);\n\tif (!ret)\n\t\tret = rj54n1_set_rect(client, RJ54N1_X_OUTPUT_SIZE_P_L,\n\t\t\t      RJ54N1_Y_OUTPUT_SIZE_P_L,\n\t\t\t      RJ54N1_XY_OUTPUT_SIZE_P_H, output_w, output_h);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (output_w > input_w && output_h > input_h) {\n\t\tinput_w = output_w;\n\t\tinput_h = output_h;\n\n\t\tresize = 1024;\n\t} else {\n\t\tunsigned int resize_x, resize_y;\n\t\tresize_x = (input_w * 1024 + output_w / 2) / output_w;\n\t\tresize_y = (input_h * 1024 + output_h / 2) / output_h;\n\n\t\t \n\t\tif (resize_x > resize_y &&\n\t\t    (output_h * resize_x + 512) / 1024 > RJ54N1_MAX_HEIGHT)\n\t\t\tresize = (RJ54N1_MAX_HEIGHT * 1024 + output_h / 2) /\n\t\t\t\toutput_h;\n\t\telse if (resize_y > resize_x &&\n\t\t\t (output_w * resize_y + 512) / 1024 > RJ54N1_MAX_WIDTH)\n\t\t\tresize = (RJ54N1_MAX_WIDTH * 1024 + output_w / 2) /\n\t\t\t\toutput_w;\n\t\telse\n\t\t\tresize = max(resize_x, resize_y);\n\n\t\t \n\t\tswitch (resize) {\n\t\tcase 2040 ... 2047:\n\t\t\tresize = 2039;\n\t\t\tbreak;\n\t\tcase 4080 ... 4095:\n\t\t\tresize = 4079;\n\t\t\tbreak;\n\t\tcase 8160 ... 8191:\n\t\t\tresize = 8159;\n\t\t\tbreak;\n\t\tcase 16320 ... 16384:\n\t\t\tresize = 16319;\n\t\t}\n\t}\n\n\t \n\tret = reg_write(client, RJ54N1_RESIZE_HOLD_L, resize & 0xff);\n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_RESIZE_HOLD_H, resize >> 8);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tskip = min(resize / 1024, 15U);\n\n\tinc_sel = 1 << skip;\n\n\tif (inc_sel <= 2)\n\t\tinc_sel = 0xc;\n\telse if (resize & 1023 && skip < 15)\n\t\tinc_sel |= 1 << (skip + 1);\n\n\tret = reg_write(client, RJ54N1_INC_USE_SEL_L, inc_sel & 0xfc);\n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_INC_USE_SEL_H, inc_sel >> 8);\n\n\tif (!rj54n1->auto_wb) {\n\t\t \n\t\twb_left\t  = output_w / 16;\n\t\twb_right  = (3 * output_w / 4 - 3) / 4;\n\t\twb_top\t  = output_h / 16;\n\t\twb_bottom = (3 * output_h / 4 - 3) / 4;\n\t\twb_bit8\t  = ((wb_left >> 2) & 0x40) | ((wb_top >> 4) & 0x10) |\n\t\t\t((wb_right >> 6) & 4) | ((wb_bottom >> 8) & 1);\n\n\t\tif (!ret)\n\t\t\tret = reg_write(client, RJ54N1_BIT8_WB, wb_bit8);\n\t\tif (!ret)\n\t\t\tret = reg_write(client, RJ54N1_HCAPS_WB, wb_left);\n\t\tif (!ret)\n\t\t\tret = reg_write(client, RJ54N1_VCAPS_WB, wb_top);\n\t\tif (!ret)\n\t\t\tret = reg_write(client, RJ54N1_HCAPE_WB, wb_right);\n\t\tif (!ret)\n\t\t\tret = reg_write(client, RJ54N1_VCAPE_WB, wb_bottom);\n\t}\n\n\t \n\tpeak = 12 * RJ54N1_MAX_WIDTH * (1 << 14) * resize / rj54n1->tgclk_mhz /\n\t\t10000;\n\tpeak_50 = peak / 6;\n\tpeak_60 = peak / 5;\n\n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_PEAK_H,\n\t\t\t\t((peak_50 >> 4) & 0xf0) | (peak_60 >> 8));\n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_PEAK_50, peak_50);\n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_PEAK_60, peak_60);\n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_PEAK_DIFF, peak / 150);\n\n\t \n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_RESIZE_CONTROL,\n\t\t\t\tRESIZE_HOLD_SEL | RESIZE_GO | 1);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmsleep(230);\n\n\tret = reg_write(client, RJ54N1_RESIZE_CONTROL, RESIZE_HOLD_SEL | 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*in_w = (output_w * resize + 512) / 1024;\n\t*in_h = (output_h * resize + 512) / 1024;\n\t*out_w = output_w;\n\t*out_h = output_h;\n\n\tdev_dbg(&client->dev, \"Scaled for %dx%d : %u = %ux%u, skip %u\\n\",\n\t\t*in_w, *in_h, resize, output_w, output_h, skip);\n\n\treturn resize;\n}\n\nstatic int rj54n1_set_clock(struct i2c_client *client)\n{\n\tstruct rj54n1 *rj54n1 = to_rj54n1(client);\n\tint ret;\n\n\t \n\tret = reg_write(client, RJ54N1_RESET_STANDBY, E_EXCLK | SOFT_STDBY);\n\t \n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_RESET_STANDBY, E_EXCLK);\n\n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_PLL_L, PLL_L);\n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_PLL_N, PLL_N);\n\n\t \n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_RATIO_TG,\n\t\t\t\trj54n1->clk_div.ratio_tg);\n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_RATIO_T,\n\t\t\t\trj54n1->clk_div.ratio_t);\n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_RATIO_R,\n\t\t\t\trj54n1->clk_div.ratio_r);\n\n\t \n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_RAMP_TGCLK_EN, 3);\n\n\t \n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_OCLK_DSP, 0);\n\n\t \n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_RATIO_OP,\n\t\t\t\trj54n1->clk_div.ratio_op);\n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_RATIO_O,\n\t\t\t\trj54n1->clk_div.ratio_o);\n\n\t \n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_OCLK_SEL_EN, 1);\n\n\t \n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_TG_BYPASS, 2);\n\n\t \n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_RESET_STANDBY,\n\t\t\t\tE_EXCLK | SEN_RSTX);\n\t \n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_PLL_EN, 1);\n\n\t \n\tmsleep(10);\n\n\t \n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_CLK_RST, 1);\n\n\tif (!ret)\n\t\tret = reg_read(client, RJ54N1_CLK_RST);\n\tif (ret != 1) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Resetting RJ54N1CB0C clock failed: %d!\\n\", ret);\n\t\treturn -EIO;\n\t}\n\n\t \n\tret = reg_set(client, RJ54N1_OCLK_DSP, 1, 1);\n\n\t \n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_OCLK_SEL_EN, 1);\n\n\treturn ret;\n}\n\nstatic int rj54n1_reg_init(struct i2c_client *client)\n{\n\tstruct rj54n1 *rj54n1 = to_rj54n1(client);\n\tint ret = rj54n1_set_clock(client);\n\n\tif (!ret)\n\t\tret = reg_write_multiple(client, bank_7, ARRAY_SIZE(bank_7));\n\tif (!ret)\n\t\tret = reg_write_multiple(client, bank_10, ARRAY_SIZE(bank_10));\n\n\t \n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_SCALE_1_2_LEV, 3 | (7 << 4));\n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_SCALE_4_LEV, 0xf);\n\n\t \n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_RESIZE_CONTROL,\n\t\t\t\tRESIZE_HOLD_SEL | 1);\n\n\t \n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_Y_GAIN, 0x84);\n\n\t \n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_MIRROR_STILL_MODE, 0x27);\n\n\tif (!ret)\n\t\tret = reg_write_multiple(client, bank_4, ARRAY_SIZE(bank_4));\n\n\t \n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_EXPOSURE_CONTROL, 0x80);\n\t \n\tif (!ret)\n\t\tret = reg_read(client, RJ54N1_WB_SEL_WEIGHT_I);\n\tif (ret >= 0) {\n\t\trj54n1->auto_wb = ret & 0x80;\n\t\tret = reg_write_multiple(client, bank_5, ARRAY_SIZE(bank_5));\n\t}\n\tif (!ret)\n\t\tret = reg_write_multiple(client, bank_8, ARRAY_SIZE(bank_8));\n\n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_RESET_STANDBY,\n\t\t\t\tE_EXCLK | DSP_RSTX | SEN_RSTX);\n\n\t \n\tif (!ret)\n\t\tret = rj54n1_commit(client);\n\n\t \n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_RESET_STANDBY,\n\t\t\t\tE_EXCLK | DSP_RSTX | TG_RSTX | SEN_RSTX);\n\n\t \n\tif (!ret)\n\t\tret = reg_write(client, RJ54N1_FWFLG, 2);\n\n\t \n\tmsleep(700);\n\n\treturn ret;\n}\n\nstatic int rj54n1_set_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct rj54n1 *rj54n1 = to_rj54n1(client);\n\tconst struct rj54n1_datafmt *fmt;\n\tint output_w, output_h, max_w, max_h,\n\t\tinput_w = rj54n1->rect.width, input_h = rj54n1->rect.height;\n\tint align = mf->code == MEDIA_BUS_FMT_SBGGR10_1X10 ||\n\t\tmf->code == MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_BE ||\n\t\tmf->code == MEDIA_BUS_FMT_SBGGR10_2X8_PADLO_BE ||\n\t\tmf->code == MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE ||\n\t\tmf->code == MEDIA_BUS_FMT_SBGGR10_2X8_PADLO_LE;\n\tint ret;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tdev_dbg(&client->dev, \"%s: code = %d, width = %u, height = %u\\n\",\n\t\t__func__, mf->code, mf->width, mf->height);\n\n\tfmt = rj54n1_find_datafmt(mf->code, rj54n1_colour_fmts,\n\t\t\t\t  ARRAY_SIZE(rj54n1_colour_fmts));\n\tif (!fmt) {\n\t\tfmt = rj54n1->fmt;\n\t\tmf->code = fmt->code;\n\t}\n\n\tmf->field\t= V4L2_FIELD_NONE;\n\tmf->colorspace\t= fmt->colorspace;\n\n\tv4l_bound_align_image(&mf->width, 112, RJ54N1_MAX_WIDTH, align,\n\t\t\t      &mf->height, 84, RJ54N1_MAX_HEIGHT, align, 0);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tsd_state->pads->try_fmt = *mf;\n\t\treturn 0;\n\t}\n\n\t \n\tret = reg_read(client, RJ54N1_RESET_STANDBY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!(ret & E_EXCLK)) {\n\t\tret = rj54n1_reg_init(client);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tswitch (mf->code) {\n\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\t\tret = reg_write(client, RJ54N1_OUT_SEL, 0);\n\t\tif (!ret)\n\t\t\tret = reg_set(client, RJ54N1_BYTE_SWAP, 8, 8);\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YVYU8_2X8:\n\t\tret = reg_write(client, RJ54N1_OUT_SEL, 0);\n\t\tif (!ret)\n\t\t\tret = reg_set(client, RJ54N1_BYTE_SWAP, 0, 8);\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB565_2X8_LE:\n\t\tret = reg_write(client, RJ54N1_OUT_SEL, 0x11);\n\t\tif (!ret)\n\t\t\tret = reg_set(client, RJ54N1_BYTE_SWAP, 8, 8);\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB565_2X8_BE:\n\t\tret = reg_write(client, RJ54N1_OUT_SEL, 0x11);\n\t\tif (!ret)\n\t\t\tret = reg_set(client, RJ54N1_BYTE_SWAP, 0, 8);\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR10_2X8_PADLO_LE:\n\t\tret = reg_write(client, RJ54N1_OUT_SEL, 4);\n\t\tif (!ret)\n\t\t\tret = reg_set(client, RJ54N1_BYTE_SWAP, 8, 8);\n\t\tif (!ret)\n\t\t\tret = reg_write(client, RJ54N1_RA_SEL_UL, 0);\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE:\n\t\tret = reg_write(client, RJ54N1_OUT_SEL, 4);\n\t\tif (!ret)\n\t\t\tret = reg_set(client, RJ54N1_BYTE_SWAP, 8, 8);\n\t\tif (!ret)\n\t\t\tret = reg_write(client, RJ54N1_RA_SEL_UL, 8);\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR10_2X8_PADLO_BE:\n\t\tret = reg_write(client, RJ54N1_OUT_SEL, 4);\n\t\tif (!ret)\n\t\t\tret = reg_set(client, RJ54N1_BYTE_SWAP, 0, 8);\n\t\tif (!ret)\n\t\t\tret = reg_write(client, RJ54N1_RA_SEL_UL, 0);\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_BE:\n\t\tret = reg_write(client, RJ54N1_OUT_SEL, 4);\n\t\tif (!ret)\n\t\t\tret = reg_set(client, RJ54N1_BYTE_SWAP, 0, 8);\n\t\tif (!ret)\n\t\t\tret = reg_write(client, RJ54N1_RA_SEL_UL, 8);\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR10_1X10:\n\t\tret = reg_write(client, RJ54N1_OUT_SEL, 5);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\t \n\tif (!ret)\n\t\tret = reg_set(client, RJ54N1_OCLK_SEL_EN,\n\t\t\t      (mf->code == MEDIA_BUS_FMT_SBGGR10_1X10) << 1, 2);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmax_w = mf->width * (16 * 1024 - 1) / 1024;\n\tif (input_w > max_w)\n\t\tinput_w = max_w;\n\tmax_h = mf->height * (16 * 1024 - 1) / 1024;\n\tif (input_h > max_h)\n\t\tinput_h = max_h;\n\n\toutput_w = mf->width;\n\toutput_h = mf->height;\n\n\tret = rj54n1_sensor_scale(sd, &input_w, &input_h, &output_w, &output_h);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfmt = rj54n1_find_datafmt(mf->code, rj54n1_colour_fmts,\n\t\t\t\t  ARRAY_SIZE(rj54n1_colour_fmts));\n\n\trj54n1->fmt\t\t= fmt;\n\trj54n1->resize\t\t= ret;\n\trj54n1->rect.width\t= input_w;\n\trj54n1->rect.height\t= input_h;\n\trj54n1->width\t\t= output_w;\n\trj54n1->height\t\t= output_h;\n\n\tmf->width\t\t= output_w;\n\tmf->height\t\t= output_h;\n\tmf->field\t\t= V4L2_FIELD_NONE;\n\tmf->colorspace\t\t= fmt->colorspace;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int rj54n1_g_register(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_dbg_register *reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tif (reg->reg < 0x400 || reg->reg > 0x1fff)\n\t\t \n\t\treturn -EINVAL;\n\n\treg->size = 1;\n\treg->val = reg_read(client, reg->reg);\n\n\tif (reg->val > 0xff)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int rj54n1_s_register(struct v4l2_subdev *sd,\n\t\t\t     const struct v4l2_dbg_register *reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tif (reg->reg < 0x400 || reg->reg > 0x1fff)\n\t\t \n\t\treturn -EINVAL;\n\n\tif (reg_write(client, reg->reg, reg->val) < 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n#endif\n\nstatic int rj54n1_s_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct rj54n1 *rj54n1 = to_rj54n1(client);\n\n\tif (on) {\n\t\tif (rj54n1->pwup_gpio)\n\t\t\tgpiod_set_value(rj54n1->pwup_gpio, 1);\n\t\tif (rj54n1->enable_gpio)\n\t\t\tgpiod_set_value(rj54n1->enable_gpio, 1);\n\n\t\tmsleep(1);\n\n\t\treturn clk_prepare_enable(rj54n1->clk);\n\t}\n\n\tclk_disable_unprepare(rj54n1->clk);\n\n\tif (rj54n1->enable_gpio)\n\t\tgpiod_set_value(rj54n1->enable_gpio, 0);\n\tif (rj54n1->pwup_gpio)\n\t\tgpiod_set_value(rj54n1->pwup_gpio, 0);\n\n\treturn 0;\n}\n\nstatic int rj54n1_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct rj54n1 *rj54n1 = container_of(ctrl->handler, struct rj54n1, hdl);\n\tstruct v4l2_subdev *sd = &rj54n1->subdev;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint data;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_VFLIP:\n\t\tif (ctrl->val)\n\t\t\tdata = reg_set(client, RJ54N1_MIRROR_STILL_MODE, 0, 1);\n\t\telse\n\t\t\tdata = reg_set(client, RJ54N1_MIRROR_STILL_MODE, 1, 1);\n\t\tif (data < 0)\n\t\t\treturn -EIO;\n\t\treturn 0;\n\tcase V4L2_CID_HFLIP:\n\t\tif (ctrl->val)\n\t\t\tdata = reg_set(client, RJ54N1_MIRROR_STILL_MODE, 0, 2);\n\t\telse\n\t\t\tdata = reg_set(client, RJ54N1_MIRROR_STILL_MODE, 2, 2);\n\t\tif (data < 0)\n\t\t\treturn -EIO;\n\t\treturn 0;\n\tcase V4L2_CID_GAIN:\n\t\tif (reg_write(client, RJ54N1_Y_GAIN, ctrl->val * 2) < 0)\n\t\t\treturn -EIO;\n\t\treturn 0;\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\t \n\t\tif (reg_set(client, RJ54N1_WB_SEL_WEIGHT_I, ctrl->val << 7,\n\t\t\t    0x80) < 0)\n\t\t\treturn -EIO;\n\t\trj54n1->auto_wb = ctrl->val;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct v4l2_ctrl_ops rj54n1_ctrl_ops = {\n\t.s_ctrl = rj54n1_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops rj54n1_subdev_core_ops = {\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register\t= rj54n1_g_register,\n\t.s_register\t= rj54n1_s_register,\n#endif\n\t.s_power\t= rj54n1_s_power,\n};\n\nstatic const struct v4l2_subdev_video_ops rj54n1_subdev_video_ops = {\n\t.s_stream\t= rj54n1_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops rj54n1_subdev_pad_ops = {\n\t.enum_mbus_code = rj54n1_enum_mbus_code,\n\t.get_selection\t= rj54n1_get_selection,\n\t.set_selection\t= rj54n1_set_selection,\n\t.get_fmt\t= rj54n1_get_fmt,\n\t.set_fmt\t= rj54n1_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops rj54n1_subdev_ops = {\n\t.core\t= &rj54n1_subdev_core_ops,\n\t.video\t= &rj54n1_subdev_video_ops,\n\t.pad\t= &rj54n1_subdev_pad_ops,\n};\n\n \nstatic int rj54n1_video_probe(struct i2c_client *client,\n\t\t\t      struct rj54n1_pdata *priv)\n{\n\tstruct rj54n1 *rj54n1 = to_rj54n1(client);\n\tint data1, data2;\n\tint ret;\n\n\tret = rj54n1_s_power(&rj54n1->subdev, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdata1 = reg_read(client, RJ54N1_DEV_CODE);\n\tdata2 = reg_read(client, RJ54N1_DEV_CODE2);\n\n\tif (data1 != 0x51 || data2 != 0x10) {\n\t\tret = -ENODEV;\n\t\tdev_info(&client->dev, \"No RJ54N1CB0C found, read 0x%x:0x%x\\n\",\n\t\t\t data1, data2);\n\t\tgoto done;\n\t}\n\n\t \n\tret = reg_write(client, RJ54N1_IOC, priv->ioctl_high << 7);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tdev_info(&client->dev, \"Detected a RJ54N1CB0C chip ID 0x%x:0x%x\\n\",\n\t\t data1, data2);\n\n\tret = v4l2_ctrl_handler_setup(&rj54n1->hdl);\n\ndone:\n\trj54n1_s_power(&rj54n1->subdev, 0);\n\treturn ret;\n}\n\nstatic int rj54n1_probe(struct i2c_client *client)\n{\n\tstruct rj54n1 *rj54n1;\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct rj54n1_pdata *rj54n1_priv;\n\tint ret;\n\n\tif (!client->dev.platform_data) {\n\t\tdev_err(&client->dev, \"RJ54N1CB0C: missing platform data!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trj54n1_priv = client->dev.platform_data;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_warn(&adapter->dev,\n\t\t\t \"I2C-Adapter doesn't support I2C_FUNC_SMBUS_BYTE\\n\");\n\t\treturn -EIO;\n\t}\n\n\trj54n1 = devm_kzalloc(&client->dev, sizeof(struct rj54n1), GFP_KERNEL);\n\tif (!rj54n1)\n\t\treturn -ENOMEM;\n\n\tv4l2_i2c_subdev_init(&rj54n1->subdev, client, &rj54n1_subdev_ops);\n\tv4l2_ctrl_handler_init(&rj54n1->hdl, 4);\n\tv4l2_ctrl_new_std(&rj54n1->hdl, &rj54n1_ctrl_ops,\n\t\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(&rj54n1->hdl, &rj54n1_ctrl_ops,\n\t\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(&rj54n1->hdl, &rj54n1_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, 0, 127, 1, 66);\n\tv4l2_ctrl_new_std(&rj54n1->hdl, &rj54n1_ctrl_ops,\n\t\t\tV4L2_CID_AUTO_WHITE_BALANCE, 0, 1, 1, 1);\n\trj54n1->subdev.ctrl_handler = &rj54n1->hdl;\n\tif (rj54n1->hdl.error)\n\t\treturn rj54n1->hdl.error;\n\n\trj54n1->clk_div\t\t= clk_div;\n\trj54n1->rect.left\t= RJ54N1_COLUMN_SKIP;\n\trj54n1->rect.top\t= RJ54N1_ROW_SKIP;\n\trj54n1->rect.width\t= RJ54N1_MAX_WIDTH;\n\trj54n1->rect.height\t= RJ54N1_MAX_HEIGHT;\n\trj54n1->width\t\t= RJ54N1_MAX_WIDTH;\n\trj54n1->height\t\t= RJ54N1_MAX_HEIGHT;\n\trj54n1->fmt\t\t= &rj54n1_colour_fmts[0];\n\trj54n1->resize\t\t= 1024;\n\trj54n1->tgclk_mhz\t= (rj54n1_priv->mclk_freq / PLL_L * PLL_N) /\n\t\t(clk_div.ratio_tg + 1) / (clk_div.ratio_t + 1);\n\n\trj54n1->clk = clk_get(&client->dev, NULL);\n\tif (IS_ERR(rj54n1->clk)) {\n\t\tret = PTR_ERR(rj54n1->clk);\n\t\tgoto err_free_ctrl;\n\t}\n\n\trj54n1->pwup_gpio = gpiod_get_optional(&client->dev, \"powerup\",\n\t\t\t\t\t       GPIOD_OUT_LOW);\n\tif (IS_ERR(rj54n1->pwup_gpio)) {\n\t\tdev_info(&client->dev, \"Unable to get GPIO \\\"powerup\\\": %ld\\n\",\n\t\t\t PTR_ERR(rj54n1->pwup_gpio));\n\t\tret = PTR_ERR(rj54n1->pwup_gpio);\n\t\tgoto err_clk_put;\n\t}\n\n\trj54n1->enable_gpio = gpiod_get_optional(&client->dev, \"enable\",\n\t\t\t\t\t\t GPIOD_OUT_LOW);\n\tif (IS_ERR(rj54n1->enable_gpio)) {\n\t\tdev_info(&client->dev, \"Unable to get GPIO \\\"enable\\\": %ld\\n\",\n\t\t\t PTR_ERR(rj54n1->enable_gpio));\n\t\tret = PTR_ERR(rj54n1->enable_gpio);\n\t\tgoto err_gpio_put;\n\t}\n\n\tret = rj54n1_video_probe(client, rj54n1_priv);\n\tif (ret < 0)\n\t\tgoto err_gpio_put;\n\n\tret = v4l2_async_register_subdev(&rj54n1->subdev);\n\tif (ret)\n\t\tgoto err_gpio_put;\n\n\treturn 0;\n\nerr_gpio_put:\n\tif (rj54n1->enable_gpio)\n\t\tgpiod_put(rj54n1->enable_gpio);\n\n\tif (rj54n1->pwup_gpio)\n\t\tgpiod_put(rj54n1->pwup_gpio);\n\nerr_clk_put:\n\tclk_put(rj54n1->clk);\n\nerr_free_ctrl:\n\tv4l2_ctrl_handler_free(&rj54n1->hdl);\n\n\treturn ret;\n}\n\nstatic void rj54n1_remove(struct i2c_client *client)\n{\n\tstruct rj54n1 *rj54n1 = to_rj54n1(client);\n\n\tif (rj54n1->enable_gpio)\n\t\tgpiod_put(rj54n1->enable_gpio);\n\tif (rj54n1->pwup_gpio)\n\t\tgpiod_put(rj54n1->pwup_gpio);\n\n\tclk_put(rj54n1->clk);\n\tv4l2_ctrl_handler_free(&rj54n1->hdl);\n\tv4l2_async_unregister_subdev(&rj54n1->subdev);\n}\n\nstatic const struct i2c_device_id rj54n1_id[] = {\n\t{ \"rj54n1cb0c\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, rj54n1_id);\n\nstatic struct i2c_driver rj54n1_i2c_driver = {\n\t.driver = {\n\t\t.name = \"rj54n1cb0c\",\n\t},\n\t.probe\t\t= rj54n1_probe,\n\t.remove\t\t= rj54n1_remove,\n\t.id_table\t= rj54n1_id,\n};\n\nmodule_i2c_driver(rj54n1_i2c_driver);\n\nMODULE_DESCRIPTION(\"Sharp RJ54N1CB0C Camera driver\");\nMODULE_AUTHOR(\"Guennadi Liakhovetski <g.liakhovetski@gmx.de>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}