{
  "module_name": "lm3646.c",
  "hash_id": "a278c80e13a817abfbe6db0c4325d959c8a2b8df31cf8348aee7a7621995c04c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/lm3646.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/regmap.h>\n#include <linux/videodev2.h>\n#include <media/i2c/lm3646.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n\n \n#define REG_ENABLE\t\t0x01\n#define REG_TORCH_BR\t0x05\n#define REG_FLASH_BR\t0x05\n#define REG_FLASH_TOUT\t0x04\n#define REG_FLAG\t\t0x08\n#define REG_STROBE_SRC\t0x06\n#define REG_LED1_FLASH_BR 0x06\n#define REG_LED1_TORCH_BR 0x07\n\n#define MASK_ENABLE\t\t0x03\n#define MASK_TORCH_BR\t0x70\n#define MASK_FLASH_BR\t0x0F\n#define MASK_FLASH_TOUT\t0x07\n#define MASK_FLAG\t\t0xFF\n#define MASK_STROBE_SRC\t0x80\n\n \n#define FAULT_TIMEOUT\t(1<<0)\n#define FAULT_SHORT_CIRCUIT\t(1<<1)\n#define FAULT_UVLO\t\t(1<<2)\n#define FAULT_IVFM\t\t(1<<3)\n#define FAULT_OCP\t\t(1<<4)\n#define FAULT_OVERTEMP\t(1<<5)\n#define FAULT_NTC_TRIP\t(1<<6)\n#define FAULT_OVP\t\t(1<<7)\n\nenum led_mode {\n\tMODE_SHDN = 0x0,\n\tMODE_TORCH = 0x2,\n\tMODE_FLASH = 0x3,\n};\n\n \nstruct lm3646_flash {\n\tstruct device *dev;\n\tstruct lm3646_platform_data *pdata;\n\tstruct regmap *regmap;\n\n\tstruct v4l2_ctrl_handler ctrls_led;\n\tstruct v4l2_subdev subdev_led;\n\n\tu8 mode_reg;\n};\n\n#define to_lm3646_flash(_ctrl)\t\\\n\tcontainer_of(_ctrl->handler, struct lm3646_flash, ctrls_led)\n\n \nstatic int lm3646_mode_ctrl(struct lm3646_flash *flash,\n\t\t\t    enum v4l2_flash_led_mode led_mode)\n{\n\tswitch (led_mode) {\n\tcase V4L2_FLASH_LED_MODE_NONE:\n\t\treturn regmap_write(flash->regmap,\n\t\t\t\t    REG_ENABLE, flash->mode_reg | MODE_SHDN);\n\tcase V4L2_FLASH_LED_MODE_TORCH:\n\t\treturn regmap_write(flash->regmap,\n\t\t\t\t    REG_ENABLE, flash->mode_reg | MODE_TORCH);\n\tcase V4L2_FLASH_LED_MODE_FLASH:\n\t\treturn regmap_write(flash->regmap,\n\t\t\t\t    REG_ENABLE, flash->mode_reg | MODE_FLASH);\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic int lm3646_get_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct lm3646_flash *flash = to_lm3646_flash(ctrl);\n\tunsigned int reg_val;\n\tint rval;\n\n\tif (ctrl->id != V4L2_CID_FLASH_FAULT)\n\t\treturn -EINVAL;\n\n\trval = regmap_read(flash->regmap, REG_FLAG, &reg_val);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tctrl->val = 0;\n\tif (reg_val & FAULT_TIMEOUT)\n\t\tctrl->val |= V4L2_FLASH_FAULT_TIMEOUT;\n\tif (reg_val & FAULT_SHORT_CIRCUIT)\n\t\tctrl->val |= V4L2_FLASH_FAULT_SHORT_CIRCUIT;\n\tif (reg_val & FAULT_UVLO)\n\t\tctrl->val |= V4L2_FLASH_FAULT_UNDER_VOLTAGE;\n\tif (reg_val & FAULT_IVFM)\n\t\tctrl->val |= V4L2_FLASH_FAULT_INPUT_VOLTAGE;\n\tif (reg_val & FAULT_OCP)\n\t\tctrl->val |= V4L2_FLASH_FAULT_OVER_CURRENT;\n\tif (reg_val & FAULT_OVERTEMP)\n\t\tctrl->val |= V4L2_FLASH_FAULT_OVER_TEMPERATURE;\n\tif (reg_val & FAULT_NTC_TRIP)\n\t\tctrl->val |= V4L2_FLASH_FAULT_LED_OVER_TEMPERATURE;\n\tif (reg_val & FAULT_OVP)\n\t\tctrl->val |= V4L2_FLASH_FAULT_OVER_VOLTAGE;\n\n\treturn 0;\n}\n\nstatic int lm3646_set_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct lm3646_flash *flash = to_lm3646_flash(ctrl);\n\tunsigned int reg_val;\n\tint rval;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_FLASH_LED_MODE:\n\n\t\tif (ctrl->val != V4L2_FLASH_LED_MODE_FLASH)\n\t\t\treturn lm3646_mode_ctrl(flash, ctrl->val);\n\t\t \n\t\treturn lm3646_mode_ctrl(flash, V4L2_FLASH_LED_MODE_NONE);\n\n\tcase V4L2_CID_FLASH_STROBE_SOURCE:\n\t\treturn regmap_update_bits(flash->regmap,\n\t\t\t\t\t  REG_STROBE_SRC, MASK_STROBE_SRC,\n\t\t\t\t\t  (ctrl->val) << 7);\n\n\tcase V4L2_CID_FLASH_STROBE:\n\n\t\t \n\t\trval = regmap_read(flash->regmap, REG_ENABLE, &reg_val);\n\t\tif (rval < 0 || ((reg_val & MASK_ENABLE) != MODE_SHDN))\n\t\t\treturn rval;\n\t\t \n\t\treturn lm3646_mode_ctrl(flash, V4L2_FLASH_LED_MODE_FLASH);\n\n\tcase V4L2_CID_FLASH_STROBE_STOP:\n\n\t\t \n\t\trval = regmap_read(flash->regmap, REG_ENABLE, &reg_val);\n\t\tif (rval < 0)\n\t\t\treturn rval;\n\t\tif ((reg_val & MASK_ENABLE) == MODE_FLASH)\n\t\t\treturn lm3646_mode_ctrl(flash,\n\t\t\t\t\t\tV4L2_FLASH_LED_MODE_NONE);\n\t\treturn rval;\n\n\tcase V4L2_CID_FLASH_TIMEOUT:\n\t\treturn regmap_update_bits(flash->regmap,\n\t\t\t\t\t  REG_FLASH_TOUT, MASK_FLASH_TOUT,\n\t\t\t\t\t  LM3646_FLASH_TOUT_ms_TO_REG\n\t\t\t\t\t  (ctrl->val));\n\n\tcase V4L2_CID_FLASH_INTENSITY:\n\t\treturn regmap_update_bits(flash->regmap,\n\t\t\t\t\t  REG_FLASH_BR, MASK_FLASH_BR,\n\t\t\t\t\t  LM3646_TOTAL_FLASH_BRT_uA_TO_REG\n\t\t\t\t\t  (ctrl->val));\n\n\tcase V4L2_CID_FLASH_TORCH_INTENSITY:\n\t\treturn regmap_update_bits(flash->regmap,\n\t\t\t\t\t  REG_TORCH_BR, MASK_TORCH_BR,\n\t\t\t\t\t  LM3646_TOTAL_TORCH_BRT_uA_TO_REG\n\t\t\t\t\t  (ctrl->val) << 4);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct v4l2_ctrl_ops lm3646_led_ctrl_ops = {\n\t.g_volatile_ctrl = lm3646_get_ctrl,\n\t.s_ctrl = lm3646_set_ctrl,\n};\n\nstatic int lm3646_init_controls(struct lm3646_flash *flash)\n{\n\tstruct v4l2_ctrl *fault;\n\tstruct v4l2_ctrl_handler *hdl = &flash->ctrls_led;\n\tconst struct v4l2_ctrl_ops *ops = &lm3646_led_ctrl_ops;\n\n\tv4l2_ctrl_handler_init(hdl, 8);\n\t \n\tv4l2_ctrl_new_std_menu(hdl, ops, V4L2_CID_FLASH_LED_MODE,\n\t\t\t       V4L2_FLASH_LED_MODE_TORCH, ~0x7,\n\t\t\t       V4L2_FLASH_LED_MODE_NONE);\n\n\t \n\tv4l2_ctrl_new_std_menu(hdl, ops, V4L2_CID_FLASH_STROBE_SOURCE,\n\t\t\t       0x1, ~0x3, V4L2_FLASH_STROBE_SOURCE_SOFTWARE);\n\n\t \n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_FLASH_STROBE, 0, 0, 0, 0);\n\t \n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_FLASH_STROBE_STOP, 0, 0, 0, 0);\n\n\t \n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_FLASH_TIMEOUT,\n\t\t\t  LM3646_FLASH_TOUT_MIN,\n\t\t\t  LM3646_FLASH_TOUT_MAX,\n\t\t\t  LM3646_FLASH_TOUT_STEP, flash->pdata->flash_timeout);\n\n\t \n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_FLASH_INTENSITY,\n\t\t\t  LM3646_TOTAL_FLASH_BRT_MIN,\n\t\t\t  LM3646_TOTAL_FLASH_BRT_MAX,\n\t\t\t  LM3646_TOTAL_FLASH_BRT_STEP,\n\t\t\t  LM3646_TOTAL_FLASH_BRT_MAX);\n\n\t \n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_FLASH_TORCH_INTENSITY,\n\t\t\t  LM3646_TOTAL_TORCH_BRT_MIN,\n\t\t\t  LM3646_TOTAL_TORCH_BRT_MAX,\n\t\t\t  LM3646_TOTAL_TORCH_BRT_STEP,\n\t\t\t  LM3646_TOTAL_TORCH_BRT_MAX);\n\n\t \n\tfault = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_FLASH_FAULT, 0,\n\t\t\t\t  V4L2_FLASH_FAULT_OVER_VOLTAGE\n\t\t\t\t  | V4L2_FLASH_FAULT_OVER_TEMPERATURE\n\t\t\t\t  | V4L2_FLASH_FAULT_SHORT_CIRCUIT\n\t\t\t\t  | V4L2_FLASH_FAULT_TIMEOUT, 0, 0);\n\tif (fault != NULL)\n\t\tfault->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\n\tif (hdl->error)\n\t\treturn hdl->error;\n\n\tflash->subdev_led.ctrl_handler = hdl;\n\treturn 0;\n}\n\n \nstatic const struct v4l2_subdev_ops lm3646_ops = {\n\t.core = NULL,\n};\n\nstatic const struct regmap_config lm3646_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xFF,\n};\n\nstatic int lm3646_subdev_init(struct lm3646_flash *flash)\n{\n\tstruct i2c_client *client = to_i2c_client(flash->dev);\n\tint rval;\n\n\tv4l2_i2c_subdev_init(&flash->subdev_led, client, &lm3646_ops);\n\tflash->subdev_led.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tstrscpy(flash->subdev_led.name, LM3646_NAME,\n\t\tsizeof(flash->subdev_led.name));\n\trval = lm3646_init_controls(flash);\n\tif (rval)\n\t\tgoto err_out;\n\trval = media_entity_pads_init(&flash->subdev_led.entity, 0, NULL);\n\tif (rval < 0)\n\t\tgoto err_out;\n\tflash->subdev_led.entity.function = MEDIA_ENT_F_FLASH;\n\treturn rval;\n\nerr_out:\n\tv4l2_ctrl_handler_free(&flash->ctrls_led);\n\treturn rval;\n}\n\nstatic int lm3646_init_device(struct lm3646_flash *flash)\n{\n\tunsigned int reg_val;\n\tint rval;\n\n\t \n\trval = regmap_read(flash->regmap, REG_ENABLE, &reg_val);\n\tif (rval < 0)\n\t\treturn rval;\n\tflash->mode_reg = reg_val & 0xfc;\n\n\t \n\trval = lm3646_mode_ctrl(flash, V4L2_FLASH_LED_MODE_NONE);\n\tif (rval < 0)\n\t\treturn rval;\n\n\t \n\trval = regmap_update_bits(flash->regmap,\n\t\t\t\t  REG_LED1_FLASH_BR, 0x7F,\n\t\t\t\t  LM3646_LED1_FLASH_BRT_uA_TO_REG\n\t\t\t\t  (flash->pdata->led1_flash_brt));\n\n\tif (rval < 0)\n\t\treturn rval;\n\n\t \n\trval = regmap_update_bits(flash->regmap,\n\t\t\t\t  REG_LED1_TORCH_BR, 0x7F,\n\t\t\t\t  LM3646_LED1_TORCH_BRT_uA_TO_REG\n\t\t\t\t  (flash->pdata->led1_torch_brt));\n\tif (rval < 0)\n\t\treturn rval;\n\n\t \n\treturn regmap_read(flash->regmap, REG_FLAG, &reg_val);\n}\n\nstatic int lm3646_probe(struct i2c_client *client)\n{\n\tstruct lm3646_flash *flash;\n\tstruct lm3646_platform_data *pdata = dev_get_platdata(&client->dev);\n\tint rval;\n\n\tflash = devm_kzalloc(&client->dev, sizeof(*flash), GFP_KERNEL);\n\tif (flash == NULL)\n\t\treturn -ENOMEM;\n\n\tflash->regmap = devm_regmap_init_i2c(client, &lm3646_regmap);\n\tif (IS_ERR(flash->regmap))\n\t\treturn PTR_ERR(flash->regmap);\n\n\t \n\tif (pdata == NULL) {\n\t\tpdata = devm_kzalloc(&client->dev,\n\t\t\t\t     sizeof(struct lm3646_platform_data),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (pdata == NULL)\n\t\t\treturn -ENOMEM;\n\t\t \n\t\tpdata->flash_timeout = LM3646_FLASH_TOUT_MAX;\n\t\tpdata->led1_torch_brt = LM3646_LED1_TORCH_BRT_MAX;\n\t\tpdata->led1_flash_brt = LM3646_LED1_FLASH_BRT_MAX;\n\t}\n\tflash->pdata = pdata;\n\tflash->dev = &client->dev;\n\n\trval = lm3646_subdev_init(flash);\n\tif (rval < 0)\n\t\treturn rval;\n\n\trval = lm3646_init_device(flash);\n\tif (rval < 0)\n\t\treturn rval;\n\n\ti2c_set_clientdata(client, flash);\n\n\treturn 0;\n}\n\nstatic void lm3646_remove(struct i2c_client *client)\n{\n\tstruct lm3646_flash *flash = i2c_get_clientdata(client);\n\n\tv4l2_device_unregister_subdev(&flash->subdev_led);\n\tv4l2_ctrl_handler_free(&flash->ctrls_led);\n\tmedia_entity_cleanup(&flash->subdev_led.entity);\n}\n\nstatic const struct i2c_device_id lm3646_id_table[] = {\n\t{LM3646_NAME, 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, lm3646_id_table);\n\nstatic struct i2c_driver lm3646_i2c_driver = {\n\t.driver = {\n\t\t   .name = LM3646_NAME,\n\t\t   },\n\t.probe = lm3646_probe,\n\t.remove = lm3646_remove,\n\t.id_table = lm3646_id_table,\n};\n\nmodule_i2c_driver(lm3646_i2c_driver);\n\nMODULE_AUTHOR(\"Daniel Jeong <gshark.jeong@gmail.com>\");\nMODULE_AUTHOR(\"Ldd Mlp <ldd-mlp@list.ti.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments LM3646 Dual Flash LED driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}