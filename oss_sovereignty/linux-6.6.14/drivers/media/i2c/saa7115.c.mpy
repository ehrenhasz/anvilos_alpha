{
  "module_name": "saa7115.c",
  "hash_id": "86999de4532b5afb6d206c7330d41074a9c360ec4192e06a40218ae27c97e2aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/saa7115.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"saa711x_regs.h\"\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-mc.h>\n#include <media/i2c/saa7115.h>\n#include <asm/div64.h>\n\n#define VRES_60HZ\t(480+16)\n\nMODULE_DESCRIPTION(\"Philips SAA7111/SAA7113/SAA7114/SAA7115/SAA7118 video decoder driver\");\nMODULE_AUTHOR(  \"Maxim Yevtyushkin, Kevin Thayer, Chris Kennedy, \"\n\t\t\"Hans Verkuil, Mauro Carvalho Chehab\");\nMODULE_LICENSE(\"GPL\");\n\nstatic bool debug;\nmodule_param(debug, bool, 0644);\n\nMODULE_PARM_DESC(debug, \"Debug level (0-1)\");\n\n\nenum saa711x_model {\n\tSAA7111A,\n\tSAA7111,\n\tSAA7113,\n\tGM7113C,\n\tSAA7114,\n\tSAA7115,\n\tSAA7118,\n};\n\nenum saa711x_pads {\n\tSAA711X_PAD_IF_INPUT,\n\tSAA711X_PAD_VID_OUT,\n\tSAA711X_NUM_PADS\n};\n\nstruct saa711x_state {\n\tstruct v4l2_subdev sd;\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tstruct media_pad pads[SAA711X_NUM_PADS];\n#endif\n\tstruct v4l2_ctrl_handler hdl;\n\n\tstruct {\n\t\t \n\t\tstruct v4l2_ctrl *agc;\n\t\tstruct v4l2_ctrl *gain;\n\t};\n\n\tv4l2_std_id std;\n\tint input;\n\tint output;\n\tint enable;\n\tint radio;\n\tint width;\n\tint height;\n\tenum saa711x_model ident;\n\tu32 audclk_freq;\n\tu32 crystal_freq;\n\tbool ucgc;\n\tu8 cgcdiv;\n\tbool apll;\n\tbool double_asclk;\n};\n\nstatic inline struct saa711x_state *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct saa711x_state, sd);\n}\n\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct saa711x_state, hdl)->sd;\n}\n\n \n\nstatic inline int saa711x_write(struct v4l2_subdev *sd, u8 reg, u8 value)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn i2c_smbus_write_byte_data(client, reg, value);\n}\n\n \nstatic int saa711x_has_reg(const int id, const u8 reg)\n{\n\tif (id == SAA7111)\n\t\treturn reg < 0x20 && reg != 0x01 && reg != 0x0f &&\n\t\t       (reg < 0x13 || reg > 0x19) && reg != 0x1d && reg != 0x1e;\n\tif (id == SAA7111A)\n\t\treturn reg < 0x20 && reg != 0x01 && reg != 0x0f &&\n\t\t       reg != 0x14 && reg != 0x18 && reg != 0x19 &&\n\t\t       reg != 0x1d && reg != 0x1e;\n\n\t \n\tif (unlikely((reg >= 0x3b && reg <= 0x3f) || reg == 0x5c || reg == 0x5f ||\n\t    reg == 0xa3 || reg == 0xa7 || reg == 0xab || reg == 0xaf || (reg >= 0xb5 && reg <= 0xb7) ||\n\t    reg == 0xd3 || reg == 0xd7 || reg == 0xdb || reg == 0xdf || (reg >= 0xe5 && reg <= 0xe7) ||\n\t    reg == 0x82 || (reg >= 0x89 && reg <= 0x8e)))\n\t\treturn 0;\n\n\tswitch (id) {\n\tcase GM7113C:\n\t\treturn reg != 0x14 && (reg < 0x18 || reg > 0x1e) && reg < 0x20;\n\tcase SAA7113:\n\t\treturn reg != 0x14 && (reg < 0x18 || reg > 0x1e) && (reg < 0x20 || reg > 0x3f) &&\n\t\t       reg != 0x5d && reg < 0x63;\n\tcase SAA7114:\n\t\treturn (reg < 0x1a || reg > 0x1e) && (reg < 0x20 || reg > 0x2f) &&\n\t\t       (reg < 0x63 || reg > 0x7f) && reg != 0x33 && reg != 0x37 &&\n\t\t       reg != 0x81 && reg < 0xf0;\n\tcase SAA7115:\n\t\treturn (reg < 0x20 || reg > 0x2f) && reg != 0x65 && (reg < 0xfc || reg > 0xfe);\n\tcase SAA7118:\n\t\treturn (reg < 0x1a || reg > 0x1d) && (reg < 0x20 || reg > 0x22) &&\n\t\t       (reg < 0x26 || reg > 0x28) && reg != 0x33 && reg != 0x37 &&\n\t\t       (reg < 0x63 || reg > 0x7f) && reg != 0x81 && reg < 0xf0;\n\t}\n\treturn 1;\n}\n\nstatic int saa711x_writeregs(struct v4l2_subdev *sd, const unsigned char *regs)\n{\n\tstruct saa711x_state *state = to_state(sd);\n\tunsigned char reg, data;\n\n\twhile (*regs != 0x00) {\n\t\treg = *(regs++);\n\t\tdata = *(regs++);\n\n\t\t \n\t\tif (saa711x_has_reg(state->ident, reg)) {\n\t\t\tif (saa711x_write(sd, reg, data) < 0)\n\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tv4l2_dbg(1, debug, sd, \"tried to access reserved reg 0x%02x\\n\", reg);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic inline int saa711x_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\n \n\n \nstatic const unsigned char saa7111_init[] = {\n\tR_01_INC_DELAY, 0x00,\t\t \n\n\t \n\tR_02_INPUT_CNTL_1, 0xd0,\t \n\tR_03_INPUT_CNTL_2, 0x23,\t \n\tR_04_INPUT_CNTL_3, 0x00,\t \n\tR_05_INPUT_CNTL_4, 0x00,\t \n\n\t \n\tR_06_H_SYNC_START, 0xf3,\t \n\tR_07_H_SYNC_STOP, 0xe8,\t\t \n\tR_08_SYNC_CNTL, 0xc8,\t\t \n\tR_09_LUMA_CNTL, 0x01,\t\t \n\tR_0A_LUMA_BRIGHT_CNTL, 0x80,\n\tR_0B_LUMA_CONTRAST_CNTL, 0x47,\t \n\tR_0C_CHROMA_SAT_CNTL, 0x40,\n\tR_0D_CHROMA_HUE_CNTL, 0x00,\n\tR_0E_CHROMA_CNTL_1, 0x01,\t \n\tR_0F_CHROMA_GAIN_CNTL, 0x00,\t \n\tR_10_CHROMA_CNTL_2, 0x48,\t \n\tR_11_MODE_DELAY_CNTL, 0x1c,\t \n\tR_12_RT_SIGNAL_CNTL, 0x00,\t \n\tR_13_RT_X_PORT_OUT_CNTL, 0x00,\t \n\tR_14_ANAL_ADC_COMPAT_CNTL, 0x00,\n\tR_15_VGATE_START_FID_CHG, 0x00,\n\tR_16_VGATE_STOP, 0x00,\n\tR_17_MISC_VGATE_CONF_AND_MSB, 0x00,\n\n\t0x00, 0x00\n};\n\n \n\n \nstatic const unsigned char saa7113_init[] = {\n\tR_01_INC_DELAY, 0x08,\n\tR_02_INPUT_CNTL_1, 0xc2,\n\tR_03_INPUT_CNTL_2, 0x30,\n\tR_04_INPUT_CNTL_3, 0x00,\n\tR_05_INPUT_CNTL_4, 0x00,\n\tR_06_H_SYNC_START, 0x89,\t \n\tR_07_H_SYNC_STOP, 0x0d,\n\tR_08_SYNC_CNTL, 0x88,\t\t \n\tR_09_LUMA_CNTL, 0x01,\n\tR_0A_LUMA_BRIGHT_CNTL, 0x80,\n\tR_0B_LUMA_CONTRAST_CNTL, 0x47,\n\tR_0C_CHROMA_SAT_CNTL, 0x40,\n\tR_0D_CHROMA_HUE_CNTL, 0x00,\n\tR_0E_CHROMA_CNTL_1, 0x01,\n\tR_0F_CHROMA_GAIN_CNTL, 0x2a,\n\tR_10_CHROMA_CNTL_2, 0x08,\t \n\tR_11_MODE_DELAY_CNTL, 0x0c,\n\tR_12_RT_SIGNAL_CNTL, 0x07,\t \n\tR_13_RT_X_PORT_OUT_CNTL, 0x00,\n\tR_14_ANAL_ADC_COMPAT_CNTL, 0x00,\n\tR_15_VGATE_START_FID_CHG, 0x00,\n\tR_16_VGATE_STOP, 0x00,\n\tR_17_MISC_VGATE_CONF_AND_MSB, 0x00,\n\n\t0x00, 0x00\n};\n\n \nstatic const unsigned char gm7113c_init[] = {\n\tR_01_INC_DELAY, 0x08,\n\tR_02_INPUT_CNTL_1, 0xc0,\n\tR_03_INPUT_CNTL_2, 0x33,\n\tR_04_INPUT_CNTL_3, 0x00,\n\tR_05_INPUT_CNTL_4, 0x00,\n\tR_06_H_SYNC_START, 0xe9,\n\tR_07_H_SYNC_STOP, 0x0d,\n\tR_08_SYNC_CNTL, 0x98,\n\tR_09_LUMA_CNTL, 0x01,\n\tR_0A_LUMA_BRIGHT_CNTL, 0x80,\n\tR_0B_LUMA_CONTRAST_CNTL, 0x47,\n\tR_0C_CHROMA_SAT_CNTL, 0x40,\n\tR_0D_CHROMA_HUE_CNTL, 0x00,\n\tR_0E_CHROMA_CNTL_1, 0x01,\n\tR_0F_CHROMA_GAIN_CNTL, 0x2a,\n\tR_10_CHROMA_CNTL_2, 0x00,\n\tR_11_MODE_DELAY_CNTL, 0x0c,\n\tR_12_RT_SIGNAL_CNTL, 0x01,\n\tR_13_RT_X_PORT_OUT_CNTL, 0x00,\n\tR_14_ANAL_ADC_COMPAT_CNTL, 0x00,\n\tR_15_VGATE_START_FID_CHG, 0x00,\n\tR_16_VGATE_STOP, 0x00,\n\tR_17_MISC_VGATE_CONF_AND_MSB, 0x00,\n\n\t0x00, 0x00\n};\n\n \n\n \nstatic const unsigned char saa7115_init_auto_input[] = {\n\t\t \n\tR_01_INC_DELAY, 0x48,\t\t\t \n\tR_03_INPUT_CNTL_2, 0x20,\t\t \n\tR_04_INPUT_CNTL_3, 0x90,\t\t \n\tR_05_INPUT_CNTL_4, 0x90,\t\t \n\t\t \n\tR_06_H_SYNC_START, 0xeb,\t\t \n\tR_07_H_SYNC_STOP, 0xe0,\t\t\t \n\tR_09_LUMA_CNTL, 0x53,\t\t\t \n\tR_0A_LUMA_BRIGHT_CNTL, 0x80,\t\t \n\tR_0B_LUMA_CONTRAST_CNTL, 0x44,\t\t \n\tR_0C_CHROMA_SAT_CNTL, 0x40,\t\t \n\tR_0D_CHROMA_HUE_CNTL, 0x00,\n\tR_0F_CHROMA_GAIN_CNTL, 0x00,\t\t \n\tR_10_CHROMA_CNTL_2, 0x06,\t\t \n\tR_11_MODE_DELAY_CNTL, 0x00,\n\tR_12_RT_SIGNAL_CNTL, 0x9d,\t\t \n\tR_13_RT_X_PORT_OUT_CNTL, 0x80,\t\t \n\tR_14_ANAL_ADC_COMPAT_CNTL, 0x00,\n\tR_18_RAW_DATA_GAIN_CNTL, 0x40,\t\t \n\tR_19_RAW_DATA_OFF_CNTL, 0x80,\n\tR_1A_COLOR_KILL_LVL_CNTL, 0x77,\t\t \n\tR_1B_MISC_TVVCRDET, 0x42,\t\t \n\tR_1C_ENHAN_COMB_CTRL1, 0xa9,\t\t \n\tR_1D_ENHAN_COMB_CTRL2, 0x01,\t\t \n\n\n\tR_80_GLOBAL_CNTL_1, 0x0,\t\t \n\n\t\t \n\tR_88_POWER_SAVE_ADC_PORT_CNTL, 0xd0,\t \n\tR_88_POWER_SAVE_ADC_PORT_CNTL, 0xf0,\t \n\t0x00, 0x00\n};\n\n \nstatic const unsigned char saa7115_cfg_reset_scaler[] = {\n\tR_87_I_PORT_I_O_ENA_OUT_CLK_AND_GATED, 0x00,\t \n\tR_88_POWER_SAVE_ADC_PORT_CNTL, 0xd0,\t\t \n\tR_88_POWER_SAVE_ADC_PORT_CNTL, 0xf0,\t\t \n\tR_87_I_PORT_I_O_ENA_OUT_CLK_AND_GATED, 0x01,\t \n\t0x00, 0x00\n};\n\n \n\nstatic const unsigned char saa7115_cfg_60hz_video[] = {\n\tR_80_GLOBAL_CNTL_1, 0x00,\t\t\t \n\tR_88_POWER_SAVE_ADC_PORT_CNTL, 0xd0,\t\t \n\n\tR_15_VGATE_START_FID_CHG, 0x03,\n\tR_16_VGATE_STOP, 0x11,\n\tR_17_MISC_VGATE_CONF_AND_MSB, 0x9c,\n\n\tR_08_SYNC_CNTL, 0x68,\t\t\t \n\tR_0E_CHROMA_CNTL_1, 0x07,\t\t \n\n\tR_5A_V_OFF_FOR_SLICER, 0x06,\t\t \n\n\t \n\tR_90_A_TASK_HANDLING_CNTL, 0x80,\n\tR_91_A_X_PORT_FORMATS_AND_CONF, 0x48,\n\tR_92_A_X_PORT_INPUT_REFERENCE_SIGNAL, 0x40,\n\tR_93_A_I_PORT_OUTPUT_FORMATS_AND_CONF, 0x84,\n\n\t \n\tR_94_A_HORIZ_INPUT_WINDOW_START, 0x01,\n\tR_95_A_HORIZ_INPUT_WINDOW_START_MSB, 0x00,\n\n\t \n\tR_96_A_HORIZ_INPUT_WINDOW_LENGTH, 0xd0,\n\tR_97_A_HORIZ_INPUT_WINDOW_LENGTH_MSB, 0x02,\n\n\tR_98_A_VERT_INPUT_WINDOW_START, 0x05,\n\tR_99_A_VERT_INPUT_WINDOW_START_MSB, 0x00,\n\n\tR_9A_A_VERT_INPUT_WINDOW_LENGTH, 0x0c,\n\tR_9B_A_VERT_INPUT_WINDOW_LENGTH_MSB, 0x00,\n\n\tR_9C_A_HORIZ_OUTPUT_WINDOW_LENGTH, 0xa0,\n\tR_9D_A_HORIZ_OUTPUT_WINDOW_LENGTH_MSB, 0x05,\n\n\tR_9E_A_VERT_OUTPUT_WINDOW_LENGTH, 0x0c,\n\tR_9F_A_VERT_OUTPUT_WINDOW_LENGTH_MSB, 0x00,\n\n\t \n\tR_C0_B_TASK_HANDLING_CNTL, 0x00,\n\tR_C1_B_X_PORT_FORMATS_AND_CONF, 0x08,\n\tR_C2_B_INPUT_REFERENCE_SIGNAL_DEFINITION, 0x00,\n\tR_C3_B_I_PORT_FORMATS_AND_CONF, 0x80,\n\n\t \n\tR_C4_B_HORIZ_INPUT_WINDOW_START, 0x02,\n\tR_C5_B_HORIZ_INPUT_WINDOW_START_MSB, 0x00,\n\n\t \n\tR_C6_B_HORIZ_INPUT_WINDOW_LENGTH, 0xd0,\n\tR_C7_B_HORIZ_INPUT_WINDOW_LENGTH_MSB, 0x02,\n\n\t \n\tR_C8_B_VERT_INPUT_WINDOW_START, 0x12,\n\tR_C9_B_VERT_INPUT_WINDOW_START_MSB, 0x00,\n\n\t \n\tR_CA_B_VERT_INPUT_WINDOW_LENGTH, VRES_60HZ>>1,\n\tR_CB_B_VERT_INPUT_WINDOW_LENGTH_MSB, VRES_60HZ>>9,\n\n\t \n\tR_CC_B_HORIZ_OUTPUT_WINDOW_LENGTH, 0xd0,\n\tR_CD_B_HORIZ_OUTPUT_WINDOW_LENGTH_MSB, 0x02,\n\n\tR_F0_LFCO_PER_LINE, 0xad,\t\t \n\tR_F1_P_I_PARAM_SELECT, 0x05,\t\t \n\tR_F5_PULSGEN_LINE_LENGTH, 0xad,\n\tR_F6_PULSE_A_POS_LSB_AND_PULSEGEN_CONFIG, 0x01,\n\n\t0x00, 0x00\n};\n\nstatic const unsigned char saa7115_cfg_50hz_video[] = {\n\tR_80_GLOBAL_CNTL_1, 0x00,\n\tR_88_POWER_SAVE_ADC_PORT_CNTL, 0xd0,\t \n\n\tR_15_VGATE_START_FID_CHG, 0x37,\t\t \n\tR_16_VGATE_STOP, 0x16,\n\tR_17_MISC_VGATE_CONF_AND_MSB, 0x99,\n\n\tR_08_SYNC_CNTL, 0x28,\t\t\t \n\tR_0E_CHROMA_CNTL_1, 0x07,\n\n\tR_5A_V_OFF_FOR_SLICER, 0x03,\t\t \n\n\t \n\tR_90_A_TASK_HANDLING_CNTL, 0x81,\n\tR_91_A_X_PORT_FORMATS_AND_CONF, 0x48,\n\tR_92_A_X_PORT_INPUT_REFERENCE_SIGNAL, 0x40,\n\tR_93_A_I_PORT_OUTPUT_FORMATS_AND_CONF, 0x84,\n\n\t \n\t \n\t \n\tR_94_A_HORIZ_INPUT_WINDOW_START, 0x00,\n\tR_95_A_HORIZ_INPUT_WINDOW_START_MSB, 0x00,\n\n\t \n\tR_96_A_HORIZ_INPUT_WINDOW_LENGTH, 0xd0,\n\tR_97_A_HORIZ_INPUT_WINDOW_LENGTH_MSB, 0x02,\n\n\tR_98_A_VERT_INPUT_WINDOW_START, 0x03,\n\tR_99_A_VERT_INPUT_WINDOW_START_MSB, 0x00,\n\n\t \n\tR_9A_A_VERT_INPUT_WINDOW_LENGTH, 0x12,\n\tR_9B_A_VERT_INPUT_WINDOW_LENGTH_MSB, 0x00,\n\n\t \n\tR_9C_A_HORIZ_OUTPUT_WINDOW_LENGTH, 0xa0,\n\tR_9D_A_HORIZ_OUTPUT_WINDOW_LENGTH_MSB, 0x05,\t \n\tR_9E_A_VERT_OUTPUT_WINDOW_LENGTH, 0x12,\t\t \n\tR_9F_A_VERT_OUTPUT_WINDOW_LENGTH_MSB, 0x00,\t \n\n\t \n\tR_C0_B_TASK_HANDLING_CNTL, 0x00,\n\tR_C1_B_X_PORT_FORMATS_AND_CONF, 0x08,\n\tR_C2_B_INPUT_REFERENCE_SIGNAL_DEFINITION, 0x00,\n\tR_C3_B_I_PORT_FORMATS_AND_CONF, 0x80,\n\n\t \n\t \n\t \n\tR_C4_B_HORIZ_INPUT_WINDOW_START, 0x00,\n\tR_C5_B_HORIZ_INPUT_WINDOW_START_MSB, 0x00,\n\n\t \n\tR_C6_B_HORIZ_INPUT_WINDOW_LENGTH, 0xd0,\n\tR_C7_B_HORIZ_INPUT_WINDOW_LENGTH_MSB, 0x02,\n\n\t \n\tR_C8_B_VERT_INPUT_WINDOW_START, 0x16,\n\tR_C9_B_VERT_INPUT_WINDOW_START_MSB, 0x00,\n\n\t \n\tR_CA_B_VERT_INPUT_WINDOW_LENGTH, 0x20,\n\tR_CB_B_VERT_INPUT_WINDOW_LENGTH_MSB, 0x01,\n\n\t \n\tR_CC_B_HORIZ_OUTPUT_WINDOW_LENGTH, 0xd0,\n\tR_CD_B_HORIZ_OUTPUT_WINDOW_LENGTH_MSB, 0x02,\n\n\tR_F0_LFCO_PER_LINE, 0xb0,\t\t \n\tR_F1_P_I_PARAM_SELECT, 0x05,\t\t \n\tR_F5_PULSGEN_LINE_LENGTH, 0xb0,\n\tR_F6_PULSE_A_POS_LSB_AND_PULSEGEN_CONFIG, 0x01,\n\n\t0x00, 0x00\n};\n\n \n\nstatic const unsigned char saa7115_cfg_vbi_on[] = {\n\tR_80_GLOBAL_CNTL_1, 0x00,\t\t\t \n\tR_88_POWER_SAVE_ADC_PORT_CNTL, 0xd0,\t\t \n\tR_80_GLOBAL_CNTL_1, 0x30,\t\t\t \n\tR_88_POWER_SAVE_ADC_PORT_CNTL, 0xf0,\t\t \n\tR_87_I_PORT_I_O_ENA_OUT_CLK_AND_GATED, 0x01,\t \n\n\t0x00, 0x00\n};\n\nstatic const unsigned char saa7115_cfg_vbi_off[] = {\n\tR_80_GLOBAL_CNTL_1, 0x00,\t\t\t \n\tR_88_POWER_SAVE_ADC_PORT_CNTL, 0xd0,\t\t \n\tR_80_GLOBAL_CNTL_1, 0x20,\t\t\t \n\tR_88_POWER_SAVE_ADC_PORT_CNTL, 0xf0,\t\t \n\tR_87_I_PORT_I_O_ENA_OUT_CLK_AND_GATED, 0x01,\t \n\n\t0x00, 0x00\n};\n\n\nstatic const unsigned char saa7115_init_misc[] = {\n\tR_81_V_SYNC_FLD_ID_SRC_SEL_AND_RETIMED_V_F, 0x01,\n\tR_83_X_PORT_I_O_ENA_AND_OUT_CLK, 0x01,\n\tR_84_I_PORT_SIGNAL_DEF, 0x20,\n\tR_85_I_PORT_SIGNAL_POLAR, 0x21,\n\tR_86_I_PORT_FIFO_FLAG_CNTL_AND_ARBIT, 0xc5,\n\tR_87_I_PORT_I_O_ENA_OUT_CLK_AND_GATED, 0x01,\n\n\t \n\tR_A0_A_HORIZ_PRESCALING, 0x01,\n\tR_A1_A_ACCUMULATION_LENGTH, 0x00,\n\tR_A2_A_PRESCALER_DC_GAIN_AND_FIR_PREFILTER, 0x00,\n\n\t \n\tR_A4_A_LUMA_BRIGHTNESS_CNTL, 0x80,\n\tR_A5_A_LUMA_CONTRAST_CNTL, 0x40,\n\tR_A6_A_CHROMA_SATURATION_CNTL, 0x40,\n\n\t \n\tR_A8_A_HORIZ_LUMA_SCALING_INC, 0x00,\n\tR_A9_A_HORIZ_LUMA_SCALING_INC_MSB, 0x02,\n\n\tR_AA_A_HORIZ_LUMA_PHASE_OFF, 0x00,\n\n\t \n\tR_AC_A_HORIZ_CHROMA_SCALING_INC, 0x00,\n\tR_AD_A_HORIZ_CHROMA_SCALING_INC_MSB, 0x01,\n\n\t \n\tR_AE_A_HORIZ_CHROMA_PHASE_OFF, 0x00,\n\n\tR_B0_A_VERT_LUMA_SCALING_INC, 0x00,\n\tR_B1_A_VERT_LUMA_SCALING_INC_MSB, 0x04,\n\n\tR_B2_A_VERT_CHROMA_SCALING_INC, 0x00,\n\tR_B3_A_VERT_CHROMA_SCALING_INC_MSB, 0x04,\n\n\tR_B4_A_VERT_SCALING_MODE_CNTL, 0x01,\n\n\tR_B8_A_VERT_CHROMA_PHASE_OFF_00, 0x00,\n\tR_B9_A_VERT_CHROMA_PHASE_OFF_01, 0x00,\n\tR_BA_A_VERT_CHROMA_PHASE_OFF_10, 0x00,\n\tR_BB_A_VERT_CHROMA_PHASE_OFF_11, 0x00,\n\n\tR_BC_A_VERT_LUMA_PHASE_OFF_00, 0x00,\n\tR_BD_A_VERT_LUMA_PHASE_OFF_01, 0x00,\n\tR_BE_A_VERT_LUMA_PHASE_OFF_10, 0x00,\n\tR_BF_A_VERT_LUMA_PHASE_OFF_11, 0x00,\n\n\t \n\tR_D0_B_HORIZ_PRESCALING, 0x01,\n\tR_D1_B_ACCUMULATION_LENGTH, 0x00,\n\tR_D2_B_PRESCALER_DC_GAIN_AND_FIR_PREFILTER, 0x00,\n\n\t \n\tR_D4_B_LUMA_BRIGHTNESS_CNTL, 0x80,\n\tR_D5_B_LUMA_CONTRAST_CNTL, 0x40,\n\tR_D6_B_CHROMA_SATURATION_CNTL, 0x40,\n\n\t \n\tR_D8_B_HORIZ_LUMA_SCALING_INC, 0x00,\n\tR_D9_B_HORIZ_LUMA_SCALING_INC_MSB, 0x04,\n\n\tR_DA_B_HORIZ_LUMA_PHASE_OFF, 0x00,\n\n\t \n\tR_DC_B_HORIZ_CHROMA_SCALING, 0x00,\n\tR_DD_B_HORIZ_CHROMA_SCALING_MSB, 0x02,\n\n\t \n\tR_DE_B_HORIZ_PHASE_OFFSET_CRHOMA, 0x00,\n\n\tR_E0_B_VERT_LUMA_SCALING_INC, 0x00,\n\tR_E1_B_VERT_LUMA_SCALING_INC_MSB, 0x04,\n\n\tR_E2_B_VERT_CHROMA_SCALING_INC, 0x00,\n\tR_E3_B_VERT_CHROMA_SCALING_INC_MSB, 0x04,\n\n\tR_E4_B_VERT_SCALING_MODE_CNTL, 0x01,\n\n\tR_E8_B_VERT_CHROMA_PHASE_OFF_00, 0x00,\n\tR_E9_B_VERT_CHROMA_PHASE_OFF_01, 0x00,\n\tR_EA_B_VERT_CHROMA_PHASE_OFF_10, 0x00,\n\tR_EB_B_VERT_CHROMA_PHASE_OFF_11, 0x00,\n\n\tR_EC_B_VERT_LUMA_PHASE_OFF_00, 0x00,\n\tR_ED_B_VERT_LUMA_PHASE_OFF_01, 0x00,\n\tR_EE_B_VERT_LUMA_PHASE_OFF_10, 0x00,\n\tR_EF_B_VERT_LUMA_PHASE_OFF_11, 0x00,\n\n\tR_F2_NOMINAL_PLL2_DTO, 0x50,\t\t \n\tR_F3_PLL_INCREMENT, 0x46,\n\tR_F4_PLL2_STATUS, 0x00,\n\tR_F7_PULSE_A_POS_MSB, 0x4b,\t\t \n\tR_F8_PULSE_B_POS, 0x00,\n\tR_F9_PULSE_B_POS_MSB, 0x4b,\n\tR_FA_PULSE_C_POS, 0x00,\n\tR_FB_PULSE_C_POS_MSB, 0x4b,\n\n\t \n\tR_FF_S_PLL_MAX_PHASE_ERR_THRESH_NUM_LINES, 0x88,\n\n\t \n\tR_40_SLICER_CNTL_1, 0x20,              \n\tR_41_LCR_BASE, 0xff,\n\tR_41_LCR_BASE+1, 0xff,\n\tR_41_LCR_BASE+2, 0xff,\n\tR_41_LCR_BASE+3, 0xff,\n\tR_41_LCR_BASE+4, 0xff,\n\tR_41_LCR_BASE+5, 0xff,\n\tR_41_LCR_BASE+6, 0xff,\n\tR_41_LCR_BASE+7, 0xff,\n\tR_41_LCR_BASE+8, 0xff,\n\tR_41_LCR_BASE+9, 0xff,\n\tR_41_LCR_BASE+10, 0xff,\n\tR_41_LCR_BASE+11, 0xff,\n\tR_41_LCR_BASE+12, 0xff,\n\tR_41_LCR_BASE+13, 0xff,\n\tR_41_LCR_BASE+14, 0xff,\n\tR_41_LCR_BASE+15, 0xff,\n\tR_41_LCR_BASE+16, 0xff,\n\tR_41_LCR_BASE+17, 0xff,\n\tR_41_LCR_BASE+18, 0xff,\n\tR_41_LCR_BASE+19, 0xff,\n\tR_41_LCR_BASE+20, 0xff,\n\tR_41_LCR_BASE+21, 0xff,\n\tR_41_LCR_BASE+22, 0xff,\n\tR_58_PROGRAM_FRAMING_CODE, 0x40,\n\tR_59_H_OFF_FOR_SLICER, 0x47,\n\tR_5B_FLD_OFF_AND_MSB_FOR_H_AND_V_OFF, 0x83,\n\tR_5D_DID, 0xbd,\n\tR_5E_SDID, 0x35,\n\n\tR_02_INPUT_CNTL_1, 0xc4,  \n\n\tR_80_GLOBAL_CNTL_1, 0x20,\t\t \n\tR_88_POWER_SAVE_ADC_PORT_CNTL, 0xd0,\n\tR_88_POWER_SAVE_ADC_PORT_CNTL, 0xf0,\n\t0x00, 0x00\n};\n\nstatic int saa711x_odd_parity(u8 c)\n{\n\tc ^= (c >> 4);\n\tc ^= (c >> 2);\n\tc ^= (c >> 1);\n\n\treturn c & 1;\n}\n\nstatic int saa711x_decode_vps(u8 *dst, u8 *p)\n{\n\tstatic const u8 biphase_tbl[] = {\n\t\t0xf0, 0x78, 0x70, 0xf0, 0xb4, 0x3c, 0x34, 0xb4,\n\t\t0xb0, 0x38, 0x30, 0xb0, 0xf0, 0x78, 0x70, 0xf0,\n\t\t0xd2, 0x5a, 0x52, 0xd2, 0x96, 0x1e, 0x16, 0x96,\n\t\t0x92, 0x1a, 0x12, 0x92, 0xd2, 0x5a, 0x52, 0xd2,\n\t\t0xd0, 0x58, 0x50, 0xd0, 0x94, 0x1c, 0x14, 0x94,\n\t\t0x90, 0x18, 0x10, 0x90, 0xd0, 0x58, 0x50, 0xd0,\n\t\t0xf0, 0x78, 0x70, 0xf0, 0xb4, 0x3c, 0x34, 0xb4,\n\t\t0xb0, 0x38, 0x30, 0xb0, 0xf0, 0x78, 0x70, 0xf0,\n\t\t0xe1, 0x69, 0x61, 0xe1, 0xa5, 0x2d, 0x25, 0xa5,\n\t\t0xa1, 0x29, 0x21, 0xa1, 0xe1, 0x69, 0x61, 0xe1,\n\t\t0xc3, 0x4b, 0x43, 0xc3, 0x87, 0x0f, 0x07, 0x87,\n\t\t0x83, 0x0b, 0x03, 0x83, 0xc3, 0x4b, 0x43, 0xc3,\n\t\t0xc1, 0x49, 0x41, 0xc1, 0x85, 0x0d, 0x05, 0x85,\n\t\t0x81, 0x09, 0x01, 0x81, 0xc1, 0x49, 0x41, 0xc1,\n\t\t0xe1, 0x69, 0x61, 0xe1, 0xa5, 0x2d, 0x25, 0xa5,\n\t\t0xa1, 0x29, 0x21, 0xa1, 0xe1, 0x69, 0x61, 0xe1,\n\t\t0xe0, 0x68, 0x60, 0xe0, 0xa4, 0x2c, 0x24, 0xa4,\n\t\t0xa0, 0x28, 0x20, 0xa0, 0xe0, 0x68, 0x60, 0xe0,\n\t\t0xc2, 0x4a, 0x42, 0xc2, 0x86, 0x0e, 0x06, 0x86,\n\t\t0x82, 0x0a, 0x02, 0x82, 0xc2, 0x4a, 0x42, 0xc2,\n\t\t0xc0, 0x48, 0x40, 0xc0, 0x84, 0x0c, 0x04, 0x84,\n\t\t0x80, 0x08, 0x00, 0x80, 0xc0, 0x48, 0x40, 0xc0,\n\t\t0xe0, 0x68, 0x60, 0xe0, 0xa4, 0x2c, 0x24, 0xa4,\n\t\t0xa0, 0x28, 0x20, 0xa0, 0xe0, 0x68, 0x60, 0xe0,\n\t\t0xf0, 0x78, 0x70, 0xf0, 0xb4, 0x3c, 0x34, 0xb4,\n\t\t0xb0, 0x38, 0x30, 0xb0, 0xf0, 0x78, 0x70, 0xf0,\n\t\t0xd2, 0x5a, 0x52, 0xd2, 0x96, 0x1e, 0x16, 0x96,\n\t\t0x92, 0x1a, 0x12, 0x92, 0xd2, 0x5a, 0x52, 0xd2,\n\t\t0xd0, 0x58, 0x50, 0xd0, 0x94, 0x1c, 0x14, 0x94,\n\t\t0x90, 0x18, 0x10, 0x90, 0xd0, 0x58, 0x50, 0xd0,\n\t\t0xf0, 0x78, 0x70, 0xf0, 0xb4, 0x3c, 0x34, 0xb4,\n\t\t0xb0, 0x38, 0x30, 0xb0, 0xf0, 0x78, 0x70, 0xf0,\n\t};\n\tint i;\n\tu8 c, err = 0;\n\n\tfor (i = 0; i < 2 * 13; i += 2) {\n\t\terr |= biphase_tbl[p[i]] | biphase_tbl[p[i + 1]];\n\t\tc = (biphase_tbl[p[i + 1]] & 0xf) | ((biphase_tbl[p[i]] & 0xf) << 4);\n\t\tdst[i / 2] = c;\n\t}\n\treturn err & 0xf0;\n}\n\nstatic int saa711x_decode_wss(u8 *p)\n{\n\tstatic const int wss_bits[8] = {\n\t\t0, 0, 0, 1, 0, 1, 1, 1\n\t};\n\tunsigned char parity;\n\tint wss = 0;\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tint b1 = wss_bits[p[i] & 7];\n\t\tint b2 = wss_bits[(p[i] >> 3) & 7];\n\n\t\tif (b1 == b2)\n\t\t\treturn -1;\n\t\twss |= b2 << i;\n\t}\n\tparity = wss & 15;\n\tparity ^= parity >> 2;\n\tparity ^= parity >> 1;\n\n\tif (!(parity & 1))\n\t\treturn -1;\n\n\treturn wss;\n}\n\nstatic int saa711x_s_clock_freq(struct v4l2_subdev *sd, u32 freq)\n{\n\tstruct saa711x_state *state = to_state(sd);\n\tu32 acpf;\n\tu32 acni;\n\tu32 hz;\n\tu64 f;\n\tu8 acc = 0;\t \n\n\t \n\tif (!saa711x_has_reg(state->ident, R_30_AUD_MAST_CLK_CYCLES_PER_FIELD))\n\t\treturn 0;\n\n\tv4l2_dbg(1, debug, sd, \"set audio clock freq: %d\\n\", freq);\n\n\t \n\tif (freq < 32000 || freq > 48000)\n\t\treturn -EINVAL;\n\n\t \n\thz = (state->std & V4L2_STD_525_60) ? 5994 : 5000;\n\t \n\tacpf = (25600 * freq) / hz;\n\t \n\tf = freq;\n\tf = f << 31;\n\tdo_div(f, state->crystal_freq);\n\tacni = f;\n\tif (state->ucgc) {\n\t\tacpf = acpf * state->cgcdiv / 16;\n\t\tacni = acni * state->cgcdiv / 16;\n\t\tacc = 0x80;\n\t\tif (state->cgcdiv == 3)\n\t\t\tacc |= 0x40;\n\t}\n\tif (state->apll)\n\t\tacc |= 0x08;\n\n\tif (state->double_asclk) {\n\t\tacpf <<= 1;\n\t\tacni <<= 1;\n\t}\n\tsaa711x_write(sd, R_38_CLK_RATIO_AMXCLK_TO_ASCLK, 0x03);\n\tsaa711x_write(sd, R_39_CLK_RATIO_ASCLK_TO_ALRCLK, 0x10 << state->double_asclk);\n\tsaa711x_write(sd, R_3A_AUD_CLK_GEN_BASIC_SETUP, acc);\n\n\tsaa711x_write(sd, R_30_AUD_MAST_CLK_CYCLES_PER_FIELD, acpf & 0xff);\n\tsaa711x_write(sd, R_30_AUD_MAST_CLK_CYCLES_PER_FIELD+1,\n\t\t\t\t\t\t\t(acpf >> 8) & 0xff);\n\tsaa711x_write(sd, R_30_AUD_MAST_CLK_CYCLES_PER_FIELD+2,\n\t\t\t\t\t\t\t(acpf >> 16) & 0x03);\n\n\tsaa711x_write(sd, R_34_AUD_MAST_CLK_NOMINAL_INC, acni & 0xff);\n\tsaa711x_write(sd, R_34_AUD_MAST_CLK_NOMINAL_INC+1, (acni >> 8) & 0xff);\n\tsaa711x_write(sd, R_34_AUD_MAST_CLK_NOMINAL_INC+2, (acni >> 16) & 0x3f);\n\tstate->audclk_freq = freq;\n\treturn 0;\n}\n\nstatic int saa711x_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\tstruct saa711x_state *state = to_state(sd);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_CHROMA_AGC:\n\t\t \n\t\tif (state->agc->val)\n\t\t\tstate->gain->val =\n\t\t\t\tsaa711x_read(sd, R_0F_CHROMA_GAIN_CNTL) & 0x7f;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int saa711x_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\tstruct saa711x_state *state = to_state(sd);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsaa711x_write(sd, R_0A_LUMA_BRIGHT_CNTL, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_CONTRAST:\n\t\tsaa711x_write(sd, R_0B_LUMA_CONTRAST_CNTL, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_SATURATION:\n\t\tsaa711x_write(sd, R_0C_CHROMA_SAT_CNTL, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_HUE:\n\t\tsaa711x_write(sd, R_0D_CHROMA_HUE_CNTL, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_CHROMA_AGC:\n\t\t \n\t\tif (state->agc->val)\n\t\t\tsaa711x_write(sd, R_0F_CHROMA_GAIN_CNTL, state->gain->val);\n\t\telse\n\t\t\tsaa711x_write(sd, R_0F_CHROMA_GAIN_CNTL, state->gain->val | 0x80);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int saa711x_set_size(struct v4l2_subdev *sd, int width, int height)\n{\n\tstruct saa711x_state *state = to_state(sd);\n\tint HPSC, HFSC;\n\tint VSCY;\n\tint res;\n\tint is_50hz = state->std & V4L2_STD_625_50;\n\tint Vsrc = is_50hz ? 576 : 480;\n\n\tv4l2_dbg(1, debug, sd, \"decoder set size to %ix%i\\n\", width, height);\n\n\t \n\tif ((width < 1) || (width > 1440))\n\t\treturn -EINVAL;\n\tif ((height < 1) || (height > Vsrc))\n\t\treturn -EINVAL;\n\n\tif (!saa711x_has_reg(state->ident, R_D0_B_HORIZ_PRESCALING)) {\n\t\t \n\t\tif (width != 720)\n\t\t\treturn -EINVAL;\n\t\tif (height != Vsrc)\n\t\t\treturn -EINVAL;\n\t}\n\n\tstate->width = width;\n\tstate->height = height;\n\n\tif (!saa711x_has_reg(state->ident, R_CC_B_HORIZ_OUTPUT_WINDOW_LENGTH))\n\t\treturn 0;\n\n\t \n\t \n\t \n\n\tsaa711x_write(sd, R_CC_B_HORIZ_OUTPUT_WINDOW_LENGTH,\n\t\t\t\t\t(u8) (width & 0xff));\n\tsaa711x_write(sd, R_CD_B_HORIZ_OUTPUT_WINDOW_LENGTH_MSB,\n\t\t\t\t\t(u8) ((width >> 8) & 0xff));\n\n\t \n\tres = height / 2;\n\n\t \n\tif (!is_50hz)\n\t\tres += (VRES_60HZ - 480) >> 1;\n\n\t\t \n\tsaa711x_write(sd, R_CE_B_VERT_OUTPUT_WINDOW_LENGTH,\n\t\t\t\t\t(u8) (res & 0xff));\n\tsaa711x_write(sd, R_CF_B_VERT_OUTPUT_WINDOW_LENGTH_MSB,\n\t\t\t\t\t(u8) ((res >> 8) & 0xff));\n\n\t \n\t \n\tHPSC = (int)(720 / width);\n\t \n\tHPSC = HPSC ? HPSC : 1;\n\tHFSC = (int)((1024 * 720) / (HPSC * width));\n\t \n\tsaa711x_write(sd, R_D0_B_HORIZ_PRESCALING,\n\t\t\t\t(u8) (HPSC & 0x3f));\n\n\tv4l2_dbg(1, debug, sd, \"Hpsc: 0x%05x, Hfsc: 0x%05x\\n\", HPSC, HFSC);\n\t \n\tsaa711x_write(sd, R_D8_B_HORIZ_LUMA_SCALING_INC,\n\t\t\t\t(u8) (HFSC & 0xff));\n\tsaa711x_write(sd, R_D9_B_HORIZ_LUMA_SCALING_INC_MSB,\n\t\t\t\t(u8) ((HFSC >> 8) & 0xff));\n\t \n\tsaa711x_write(sd, R_DC_B_HORIZ_CHROMA_SCALING,\n\t\t\t\t(u8) ((HFSC >> 1) & 0xff));\n\tsaa711x_write(sd, R_DD_B_HORIZ_CHROMA_SCALING_MSB,\n\t\t\t\t(u8) ((HFSC >> 9) & 0xff));\n\n\tVSCY = (int)((1024 * Vsrc) / height);\n\tv4l2_dbg(1, debug, sd, \"Vsrc: %d, Vscy: 0x%05x\\n\", Vsrc, VSCY);\n\n\t \n\tsaa711x_write(sd, R_D5_B_LUMA_CONTRAST_CNTL,\n\t\t\t\t\t(u8) (64 * 1024 / VSCY));\n\tsaa711x_write(sd, R_D6_B_CHROMA_SATURATION_CNTL,\n\t\t\t\t\t(u8) (64 * 1024 / VSCY));\n\n\t\t \n\tsaa711x_write(sd, R_E0_B_VERT_LUMA_SCALING_INC,\n\t\t\t\t\t(u8) (VSCY & 0xff));\n\tsaa711x_write(sd, R_E1_B_VERT_LUMA_SCALING_INC_MSB,\n\t\t\t\t\t(u8) ((VSCY >> 8) & 0xff));\n\t\t \n\tsaa711x_write(sd, R_E2_B_VERT_CHROMA_SCALING_INC,\n\t\t\t\t\t(u8) (VSCY & 0xff));\n\tsaa711x_write(sd, R_E3_B_VERT_CHROMA_SCALING_INC_MSB,\n\t\t\t\t\t(u8) ((VSCY >> 8) & 0xff));\n\n\tsaa711x_writeregs(sd, saa7115_cfg_reset_scaler);\n\n\t \n\tsaa711x_write(sd, R_80_GLOBAL_CNTL_1,\n\t\t\t\tsaa711x_read(sd, R_80_GLOBAL_CNTL_1) | 0x20);\n\n\treturn 0;\n}\n\nstatic void saa711x_set_v4lstd(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct saa711x_state *state = to_state(sd);\n\n\t \n\tif (std == state->std)\n\t\treturn;\n\n\tstate->std = std;\n\n\t \n\tif (std & V4L2_STD_525_60) {\n\t\tv4l2_dbg(1, debug, sd, \"decoder set standard 60 Hz\\n\");\n\t\tif (state->ident == GM7113C) {\n\t\t\tu8 reg = saa711x_read(sd, R_08_SYNC_CNTL);\n\t\t\treg &= ~(SAA7113_R_08_FSEL | SAA7113_R_08_AUFD);\n\t\t\treg |= SAA7113_R_08_FSEL;\n\t\t\tsaa711x_write(sd, R_08_SYNC_CNTL, reg);\n\t\t} else {\n\t\t\tsaa711x_writeregs(sd, saa7115_cfg_60hz_video);\n\t\t}\n\t\tsaa711x_set_size(sd, 720, 480);\n\t} else {\n\t\tv4l2_dbg(1, debug, sd, \"decoder set standard 50 Hz\\n\");\n\t\tif (state->ident == GM7113C) {\n\t\t\tu8 reg = saa711x_read(sd, R_08_SYNC_CNTL);\n\t\t\treg &= ~(SAA7113_R_08_FSEL | SAA7113_R_08_AUFD);\n\t\t\tsaa711x_write(sd, R_08_SYNC_CNTL, reg);\n\t\t} else {\n\t\t\tsaa711x_writeregs(sd, saa7115_cfg_50hz_video);\n\t\t}\n\t\tsaa711x_set_size(sd, 720, 576);\n\t}\n\n\t \n\tif (state->ident <= SAA7113 ||\n\t    state->ident == GM7113C) {\n\t\tu8 reg = saa711x_read(sd, R_0E_CHROMA_CNTL_1) & 0x8f;\n\n\t\tif (std == V4L2_STD_PAL_M) {\n\t\t\treg |= 0x30;\n\t\t} else if (std == V4L2_STD_PAL_Nc) {\n\t\t\treg |= 0x20;\n\t\t} else if (std == V4L2_STD_PAL_60) {\n\t\t\treg |= 0x10;\n\t\t} else if (std == V4L2_STD_NTSC_M_JP) {\n\t\t\treg |= 0x40;\n\t\t} else if (std & V4L2_STD_SECAM) {\n\t\t\treg |= 0x50;\n\t\t}\n\t\tsaa711x_write(sd, R_0E_CHROMA_CNTL_1, reg);\n\t} else {\n\t\t \n\t\tint taskb = saa711x_read(sd, R_80_GLOBAL_CNTL_1) & 0x10;\n\n\t\tif (taskb && state->ident == SAA7114)\n\t\t\tsaa711x_writeregs(sd, saa7115_cfg_vbi_on);\n\n\t\t \n\t\tsaa711x_s_clock_freq(sd, state->audclk_freq);\n\t}\n}\n\n \nstatic void saa711x_set_lcr(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_format *fmt)\n{\n\tstruct saa711x_state *state = to_state(sd);\n\tint is_50hz = (state->std & V4L2_STD_625_50);\n\tu8 lcr[24];\n\tint i, x;\n\n#if 1\n\t \n\tif (!saa711x_has_reg(state->ident, R_41_LCR_BASE))\n\t\treturn;\n\n#else\n\t \n\tif (state->ident != SAA7115)\n\t\treturn;\n#endif\n\n\tfor (i = 0; i <= 23; i++)\n\t\tlcr[i] = 0xff;\n\n\tif (fmt == NULL) {\n\t\t \n\t\tif (is_50hz)\n\t\t\tfor (i = 6; i <= 23; i++)\n\t\t\t\tlcr[i] = 0xdd;\n\t\telse\n\t\t\tfor (i = 10; i <= 21; i++)\n\t\t\t\tlcr[i] = 0xdd;\n\t} else {\n\t\t \n\t\t \n\t\tif (is_50hz) {\n\t\t\tfor (i = 0; i <= 5; i++)\n\t\t\t\tfmt->service_lines[0][i] =\n\t\t\t\t\tfmt->service_lines[1][i] = 0;\n\t\t}\n\t\telse {\n\t\t\tfor (i = 0; i <= 9; i++)\n\t\t\t\tfmt->service_lines[0][i] =\n\t\t\t\t\tfmt->service_lines[1][i] = 0;\n\t\t\tfor (i = 22; i <= 23; i++)\n\t\t\t\tfmt->service_lines[0][i] =\n\t\t\t\t\tfmt->service_lines[1][i] = 0;\n\t\t}\n\n\t\t \n\t\tfor (i = 6; i <= 23; i++) {\n\t\t\tlcr[i] = 0;\n\t\t\tfor (x = 0; x <= 1; x++) {\n\t\t\t\tswitch (fmt->service_lines[1-x][i]) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tlcr[i] |= 0xf << (4 * x);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase V4L2_SLICED_TELETEXT_B:\n\t\t\t\t\t\tlcr[i] |= 1 << (4 * x);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase V4L2_SLICED_CAPTION_525:\n\t\t\t\t\t\tlcr[i] |= 4 << (4 * x);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase V4L2_SLICED_WSS_625:\n\t\t\t\t\t\tlcr[i] |= 5 << (4 * x);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase V4L2_SLICED_VPS:\n\t\t\t\t\t\tlcr[i] |= 7 << (4 * x);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 2; i <= 23; i++) {\n\t\tsaa711x_write(sd, i - 2 + R_41_LCR_BASE, lcr[i]);\n\t}\n\n\t \n\tsaa711x_writeregs(sd, fmt == NULL ?\n\t\t\t\tsaa7115_cfg_vbi_on :\n\t\t\t\tsaa7115_cfg_vbi_off);\n}\n\nstatic int saa711x_g_sliced_fmt(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_format *sliced)\n{\n\tstatic const u16 lcr2vbi[] = {\n\t\t0, V4L2_SLICED_TELETEXT_B, 0,\t \n\t\t0, V4L2_SLICED_CAPTION_525,\t \n\t\tV4L2_SLICED_WSS_625, 0,\t\t \n\t\tV4L2_SLICED_VPS, 0, 0, 0, 0,\t \n\t\t0, 0, 0, 0\n\t};\n\tint i;\n\n\tmemset(sliced->service_lines, 0, sizeof(sliced->service_lines));\n\tsliced->service_set = 0;\n\t \n\tif (saa711x_read(sd, R_80_GLOBAL_CNTL_1) & 0x10)\n\t\treturn 0;\n\tfor (i = 2; i <= 23; i++) {\n\t\tu8 v = saa711x_read(sd, i - 2 + R_41_LCR_BASE);\n\n\t\tsliced->service_lines[0][i] = lcr2vbi[v >> 4];\n\t\tsliced->service_lines[1][i] = lcr2vbi[v & 0xf];\n\t\tsliced->service_set |=\n\t\t\tsliced->service_lines[0][i] | sliced->service_lines[1][i];\n\t}\n\treturn 0;\n}\n\nstatic int saa711x_s_raw_fmt(struct v4l2_subdev *sd, struct v4l2_vbi_format *fmt)\n{\n\tsaa711x_set_lcr(sd, NULL);\n\treturn 0;\n}\n\nstatic int saa711x_s_sliced_fmt(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_format *fmt)\n{\n\tsaa711x_set_lcr(sd, fmt);\n\treturn 0;\n}\n\nstatic int saa711x_set_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *fmt = &format->format;\n\n\tif (format->pad || fmt->code != MEDIA_BUS_FMT_FIXED)\n\t\treturn -EINVAL;\n\tfmt->field = V4L2_FIELD_INTERLACED;\n\tfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn 0;\n\treturn saa711x_set_size(sd, fmt->width, fmt->height);\n}\n\n \nstatic int saa711x_decode_vbi_line(struct v4l2_subdev *sd, struct v4l2_decode_vbi_line *vbi)\n{\n\tstruct saa711x_state *state = to_state(sd);\n\tstatic const char vbi_no_data_pattern[] = {\n\t\t0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0\n\t};\n\tu8 *p = vbi->p;\n\tu32 wss;\n\tint id1, id2;    \n\n\tvbi->type = 0;   \n\tid1 = p[2];\n\tid2 = p[3];\n\t \n\tif (state->std & V4L2_STD_525_60)\n\t\tid1 ^= 0x40;\n\n\t \n\tp += 4;\n\tvbi->p = p;\n\n\t \n\tvbi->is_second_field = ((id1 & 0x40) != 0);\n\tvbi->line = (id1 & 0x3f) << 3;\n\tvbi->line |= (id2 & 0x70) >> 4;\n\n\t \n\tid2 &= 0xf;\n\n\t \n\tif (!memcmp(p, vbi_no_data_pattern, sizeof(vbi_no_data_pattern)))\n\t\treturn 0;\n\n\t \n\tswitch (id2) {\n\tcase 1:\n\t\tvbi->type = V4L2_SLICED_TELETEXT_B;\n\t\tbreak;\n\tcase 4:\n\t\tif (!saa711x_odd_parity(p[0]) || !saa711x_odd_parity(p[1]))\n\t\t\treturn 0;\n\t\tvbi->type = V4L2_SLICED_CAPTION_525;\n\t\tbreak;\n\tcase 5:\n\t\twss = saa711x_decode_wss(p);\n\t\tif (wss == -1)\n\t\t\treturn 0;\n\t\tp[0] = wss & 0xff;\n\t\tp[1] = wss >> 8;\n\t\tvbi->type = V4L2_SLICED_WSS_625;\n\t\tbreak;\n\tcase 7:\n\t\tif (saa711x_decode_vps(p, p) != 0)\n\t\t\treturn 0;\n\t\tvbi->type = V4L2_SLICED_VPS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int saa711x_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\n{\n\tstruct saa711x_state *state = to_state(sd);\n\tint status;\n\n\tif (state->radio)\n\t\treturn 0;\n\tstatus = saa711x_read(sd, R_1F_STATUS_BYTE_2_VD_DEC);\n\n\tv4l2_dbg(1, debug, sd, \"status: 0x%02x\\n\", status);\n\tvt->signal = ((status & (1 << 6)) == 0) ? 0xffff : 0x0;\n\treturn 0;\n}\n\nstatic int saa711x_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct saa711x_state *state = to_state(sd);\n\n\tstate->radio = 0;\n\tsaa711x_set_v4lstd(sd, std);\n\treturn 0;\n}\n\nstatic int saa711x_s_radio(struct v4l2_subdev *sd)\n{\n\tstruct saa711x_state *state = to_state(sd);\n\n\tstate->radio = 1;\n\treturn 0;\n}\n\nstatic int saa711x_s_routing(struct v4l2_subdev *sd,\n\t\t\t     u32 input, u32 output, u32 config)\n{\n\tstruct saa711x_state *state = to_state(sd);\n\tu8 mask = (state->ident <= SAA7111A) ? 0xf8 : 0xf0;\n\n\tv4l2_dbg(1, debug, sd, \"decoder set input %d output %d\\n\",\n\t\tinput, output);\n\n\t \n\tif ((state->ident <= SAA7113 ||\n\t     state->ident == GM7113C) &&\n\t    (input == SAA7115_COMPOSITE4 ||\n\t     input == SAA7115_COMPOSITE5)) {\n\t\treturn -EINVAL;\n\t}\n\tif (input > SAA7115_SVIDEO3)\n\t\treturn -EINVAL;\n\tif (state->input == input && state->output == output)\n\t\treturn 0;\n\tv4l2_dbg(1, debug, sd, \"now setting %s input %s output\\n\",\n\t\t(input >= SAA7115_SVIDEO0) ? \"S-Video\" : \"Composite\",\n\t\t(output == SAA7115_IPORT_ON) ? \"iport on\" : \"iport off\");\n\tstate->input = input;\n\n\t \n\tif (state->ident <= SAA7111A) {\n\t\tif (input >= SAA7115_COMPOSITE4)\n\t\t\tinput -= 2;\n\t\t \n\t\tsaa711x_write(sd, R_10_CHROMA_CNTL_2,\n\t\t\t\t(saa711x_read(sd, R_10_CHROMA_CNTL_2) & 0x3f) |\n\t\t\t\t((output & 0xc0) ^ 0x40));\n\t\tsaa711x_write(sd, R_13_RT_X_PORT_OUT_CNTL,\n\t\t\t\t(saa711x_read(sd, R_13_RT_X_PORT_OUT_CNTL) & 0xf0) |\n\t\t\t\t((output & 2) ? 0x0a : 0));\n\t}\n\n\t \n\tsaa711x_write(sd, R_02_INPUT_CNTL_1,\n\t\t      (saa711x_read(sd, R_02_INPUT_CNTL_1) & mask) |\n\t\t       input);\n\n\t \n\tsaa711x_write(sd, R_09_LUMA_CNTL,\n\t\t\t(saa711x_read(sd, R_09_LUMA_CNTL) & 0x7f) |\n\t\t\t(state->input >= SAA7115_SVIDEO0 ? 0x80 : 0x0));\n\n\tstate->output = output;\n\tif (state->ident == SAA7114 ||\n\t\t\tstate->ident == SAA7115) {\n\t\tsaa711x_write(sd, R_83_X_PORT_I_O_ENA_AND_OUT_CLK,\n\t\t\t\t(saa711x_read(sd, R_83_X_PORT_I_O_ENA_AND_OUT_CLK) & 0xfe) |\n\t\t\t\t(state->output & 0x01));\n\t}\n\tif (state->ident > SAA7111A) {\n\t\tif (config & SAA7115_IDQ_IS_DEFAULT)\n\t\t\tsaa711x_write(sd, R_85_I_PORT_SIGNAL_POLAR, 0x20);\n\t\telse\n\t\t\tsaa711x_write(sd, R_85_I_PORT_SIGNAL_POLAR, 0x21);\n\t}\n\treturn 0;\n}\n\nstatic int saa711x_s_gpio(struct v4l2_subdev *sd, u32 val)\n{\n\tstruct saa711x_state *state = to_state(sd);\n\n\tif (state->ident > SAA7111A)\n\t\treturn -EINVAL;\n\tsaa711x_write(sd, 0x11, (saa711x_read(sd, 0x11) & 0x7f) |\n\t\t(val ? 0x80 : 0));\n\treturn 0;\n}\n\nstatic int saa711x_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct saa711x_state *state = to_state(sd);\n\n\tv4l2_dbg(1, debug, sd, \"%s output\\n\",\n\t\t\tenable ? \"enable\" : \"disable\");\n\n\tif (state->enable == enable)\n\t\treturn 0;\n\tstate->enable = enable;\n\tif (!saa711x_has_reg(state->ident, R_87_I_PORT_I_O_ENA_OUT_CLK_AND_GATED))\n\t\treturn 0;\n\tsaa711x_write(sd, R_87_I_PORT_I_O_ENA_OUT_CLK_AND_GATED, state->enable);\n\treturn 0;\n}\n\nstatic int saa711x_s_crystal_freq(struct v4l2_subdev *sd, u32 freq, u32 flags)\n{\n\tstruct saa711x_state *state = to_state(sd);\n\n\tif (freq != SAA7115_FREQ_32_11_MHZ && freq != SAA7115_FREQ_24_576_MHZ)\n\t\treturn -EINVAL;\n\tstate->crystal_freq = freq;\n\tstate->double_asclk = flags & SAA7115_FREQ_FL_DOUBLE_ASCLK;\n\tstate->cgcdiv = (flags & SAA7115_FREQ_FL_CGCDIV) ? 3 : 4;\n\tstate->ucgc = flags & SAA7115_FREQ_FL_UCGC;\n\tstate->apll = flags & SAA7115_FREQ_FL_APLL;\n\tsaa711x_s_clock_freq(sd, state->audclk_freq);\n\treturn 0;\n}\n\nstatic int saa711x_reset(struct v4l2_subdev *sd, u32 val)\n{\n\tv4l2_dbg(1, debug, sd, \"decoder RESET\\n\");\n\tsaa711x_writeregs(sd, saa7115_cfg_reset_scaler);\n\treturn 0;\n}\n\nstatic int saa711x_g_vbi_data(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_data *data)\n{\n\t \n\tswitch (data->id) {\n\tcase V4L2_SLICED_WSS_625:\n\t\tif (saa711x_read(sd, 0x6b) & 0xc0)\n\t\t\treturn -EIO;\n\t\tdata->data[0] = saa711x_read(sd, 0x6c);\n\t\tdata->data[1] = saa711x_read(sd, 0x6d);\n\t\treturn 0;\n\tcase V4L2_SLICED_CAPTION_525:\n\t\tif (data->field == 0) {\n\t\t\t \n\t\t\tif (saa711x_read(sd, 0x66) & 0x30)\n\t\t\t\treturn -EIO;\n\t\t\tdata->data[0] = saa711x_read(sd, 0x69);\n\t\t\tdata->data[1] = saa711x_read(sd, 0x6a);\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tif (saa711x_read(sd, 0x66) & 0xc0)\n\t\t\treturn -EIO;\n\t\tdata->data[0] = saa711x_read(sd, 0x67);\n\t\tdata->data[1] = saa711x_read(sd, 0x68);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int saa711x_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)\n{\n\tstruct saa711x_state *state = to_state(sd);\n\tint reg1f, reg1e;\n\n\t \n\n\treg1f = saa711x_read(sd, R_1F_STATUS_BYTE_2_VD_DEC);\n\n\tif (state->ident == SAA7115) {\n\t\treg1e = saa711x_read(sd, R_1E_STATUS_BYTE_1_VD_DEC);\n\n\t\tv4l2_dbg(1, debug, sd, \"Status byte 1 (0x1e)=0x%02x\\n\", reg1e);\n\n\t\tswitch (reg1e & 0x03) {\n\t\tcase 1:\n\t\t\t*std &= V4L2_STD_NTSC;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t \n\t\t\t*std &= V4L2_STD_PAL   | V4L2_STD_PAL_N  | V4L2_STD_PAL_Nc |\n\t\t\t\tV4L2_STD_PAL_M | V4L2_STD_PAL_60;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t*std &= V4L2_STD_SECAM;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*std = V4L2_STD_UNKNOWN;\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tv4l2_dbg(1, debug, sd, \"Status byte 2 (0x1f)=0x%02x\\n\", reg1f);\n\n\t \n\tif (reg1f & 0x40) {\n\t\t*std = V4L2_STD_UNKNOWN;\n\t\tgoto ret;\n\t}\n\n\tif (reg1f & 0x20)\n\t\t*std &= V4L2_STD_525_60;\n\telse\n\t\t*std &= V4L2_STD_625_50;\n\nret:\n\tv4l2_dbg(1, debug, sd, \"detected std mask = %08Lx\\n\", *std);\n\n\treturn 0;\n}\n\nstatic int saa711x_g_input_status(struct v4l2_subdev *sd, u32 *status)\n{\n\tstruct saa711x_state *state = to_state(sd);\n\tint reg1e = 0x80;\n\tint reg1f;\n\n\t*status = V4L2_IN_ST_NO_SIGNAL;\n\tif (state->ident == SAA7115)\n\t\treg1e = saa711x_read(sd, R_1E_STATUS_BYTE_1_VD_DEC);\n\treg1f = saa711x_read(sd, R_1F_STATUS_BYTE_2_VD_DEC);\n\tif ((reg1f & 0xc1) == 0x81 && (reg1e & 0xc0) == 0x80)\n\t\t*status = 0;\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int saa711x_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\n{\n\treg->val = saa711x_read(sd, reg->reg & 0xff);\n\treg->size = 1;\n\treturn 0;\n}\n\nstatic int saa711x_s_register(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg)\n{\n\tsaa711x_write(sd, reg->reg & 0xff, reg->val & 0xff);\n\treturn 0;\n}\n#endif\n\nstatic int saa711x_log_status(struct v4l2_subdev *sd)\n{\n\tstruct saa711x_state *state = to_state(sd);\n\tint reg1e, reg1f;\n\tint signalOk;\n\tint vcr;\n\n\tv4l2_info(sd, \"Audio frequency: %d Hz\\n\", state->audclk_freq);\n\tif (state->ident != SAA7115) {\n\t\t \n\t\treg1f = saa711x_read(sd, R_1F_STATUS_BYTE_2_VD_DEC);\n\t\tsignalOk = (reg1f & 0xc1) == 0x81;\n\t\tv4l2_info(sd, \"Video signal:    %s\\n\", signalOk ? \"ok\" : \"bad\");\n\t\tv4l2_info(sd, \"Frequency:       %s\\n\", (reg1f & 0x20) ? \"60 Hz\" : \"50 Hz\");\n\t\treturn 0;\n\t}\n\n\t \n\treg1e = saa711x_read(sd, R_1E_STATUS_BYTE_1_VD_DEC);\n\treg1f = saa711x_read(sd, R_1F_STATUS_BYTE_2_VD_DEC);\n\n\tsignalOk = (reg1f & 0xc1) == 0x81 && (reg1e & 0xc0) == 0x80;\n\tvcr = !(reg1f & 0x10);\n\n\tif (state->input >= 6)\n\t\tv4l2_info(sd, \"Input:           S-Video %d\\n\", state->input - 6);\n\telse\n\t\tv4l2_info(sd, \"Input:           Composite %d\\n\", state->input);\n\tv4l2_info(sd, \"Video signal:    %s\\n\", signalOk ? (vcr ? \"VCR\" : \"broadcast/DVD\") : \"bad\");\n\tv4l2_info(sd, \"Frequency:       %s\\n\", (reg1f & 0x20) ? \"60 Hz\" : \"50 Hz\");\n\n\tswitch (reg1e & 0x03) {\n\tcase 1:\n\t\tv4l2_info(sd, \"Detected format: NTSC\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tv4l2_info(sd, \"Detected format: PAL\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tv4l2_info(sd, \"Detected format: SECAM\\n\");\n\t\tbreak;\n\tdefault:\n\t\tv4l2_info(sd, \"Detected format: BW/No color\\n\");\n\t\tbreak;\n\t}\n\tv4l2_info(sd, \"Width, Height:   %d, %d\\n\", state->width, state->height);\n\tv4l2_ctrl_handler_log_status(&state->hdl, sd->name);\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_ctrl_ops saa711x_ctrl_ops = {\n\t.s_ctrl = saa711x_s_ctrl,\n\t.g_volatile_ctrl = saa711x_g_volatile_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops saa711x_core_ops = {\n\t.log_status = saa711x_log_status,\n\t.reset = saa711x_reset,\n\t.s_gpio = saa711x_s_gpio,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = saa711x_g_register,\n\t.s_register = saa711x_s_register,\n#endif\n};\n\nstatic const struct v4l2_subdev_tuner_ops saa711x_tuner_ops = {\n\t.s_radio = saa711x_s_radio,\n\t.g_tuner = saa711x_g_tuner,\n};\n\nstatic const struct v4l2_subdev_audio_ops saa711x_audio_ops = {\n\t.s_clock_freq = saa711x_s_clock_freq,\n};\n\nstatic const struct v4l2_subdev_video_ops saa711x_video_ops = {\n\t.s_std = saa711x_s_std,\n\t.s_routing = saa711x_s_routing,\n\t.s_crystal_freq = saa711x_s_crystal_freq,\n\t.s_stream = saa711x_s_stream,\n\t.querystd = saa711x_querystd,\n\t.g_input_status = saa711x_g_input_status,\n};\n\nstatic const struct v4l2_subdev_vbi_ops saa711x_vbi_ops = {\n\t.g_vbi_data = saa711x_g_vbi_data,\n\t.decode_vbi_line = saa711x_decode_vbi_line,\n\t.g_sliced_fmt = saa711x_g_sliced_fmt,\n\t.s_sliced_fmt = saa711x_s_sliced_fmt,\n\t.s_raw_fmt = saa711x_s_raw_fmt,\n};\n\nstatic const struct v4l2_subdev_pad_ops saa711x_pad_ops = {\n\t.set_fmt = saa711x_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops saa711x_ops = {\n\t.core = &saa711x_core_ops,\n\t.tuner = &saa711x_tuner_ops,\n\t.audio = &saa711x_audio_ops,\n\t.video = &saa711x_video_ops,\n\t.vbi = &saa711x_vbi_ops,\n\t.pad = &saa711x_pad_ops,\n};\n\n#define CHIP_VER_SIZE\t16\n\n \n\nstatic void saa711x_write_platform_data(struct saa711x_state *state,\n\t\t\t\t\tstruct saa7115_platform_data *data)\n{\n\tstruct v4l2_subdev *sd = &state->sd;\n\tu8 work;\n\n\tif (state->ident != GM7113C &&\n\t    state->ident != SAA7113)\n\t\treturn;\n\n\tif (data->saa7113_r08_htc) {\n\t\twork = saa711x_read(sd, R_08_SYNC_CNTL);\n\t\twork &= ~SAA7113_R_08_HTC_MASK;\n\t\twork |= ((*data->saa7113_r08_htc) << SAA7113_R_08_HTC_OFFSET);\n\t\tsaa711x_write(sd, R_08_SYNC_CNTL, work);\n\t}\n\n\tif (data->saa7113_r10_vrln) {\n\t\twork = saa711x_read(sd, R_10_CHROMA_CNTL_2);\n\t\twork &= ~SAA7113_R_10_VRLN_MASK;\n\t\tif (*data->saa7113_r10_vrln)\n\t\t\twork |= (1 << SAA7113_R_10_VRLN_OFFSET);\n\t\tsaa711x_write(sd, R_10_CHROMA_CNTL_2, work);\n\t}\n\n\tif (data->saa7113_r10_ofts) {\n\t\twork = saa711x_read(sd, R_10_CHROMA_CNTL_2);\n\t\twork &= ~SAA7113_R_10_OFTS_MASK;\n\t\twork |= (*data->saa7113_r10_ofts << SAA7113_R_10_OFTS_OFFSET);\n\t\tsaa711x_write(sd, R_10_CHROMA_CNTL_2, work);\n\t}\n\n\tif (data->saa7113_r12_rts0) {\n\t\twork = saa711x_read(sd, R_12_RT_SIGNAL_CNTL);\n\t\twork &= ~SAA7113_R_12_RTS0_MASK;\n\t\twork |= (*data->saa7113_r12_rts0 << SAA7113_R_12_RTS0_OFFSET);\n\n\t\t \n\t\tWARN_ON(*data->saa7113_r12_rts0 == SAA7113_RTS_DOT_IN);\n\t\tsaa711x_write(sd, R_12_RT_SIGNAL_CNTL, work);\n\t}\n\n\tif (data->saa7113_r12_rts1) {\n\t\twork = saa711x_read(sd, R_12_RT_SIGNAL_CNTL);\n\t\twork &= ~SAA7113_R_12_RTS1_MASK;\n\t\twork |= (*data->saa7113_r12_rts1 << SAA7113_R_12_RTS1_OFFSET);\n\t\tsaa711x_write(sd, R_12_RT_SIGNAL_CNTL, work);\n\t}\n\n\tif (data->saa7113_r13_adlsb) {\n\t\twork = saa711x_read(sd, R_13_RT_X_PORT_OUT_CNTL);\n\t\twork &= ~SAA7113_R_13_ADLSB_MASK;\n\t\tif (*data->saa7113_r13_adlsb)\n\t\t\twork |= (1 << SAA7113_R_13_ADLSB_OFFSET);\n\t\tsaa711x_write(sd, R_13_RT_X_PORT_OUT_CNTL, work);\n\t}\n}\n\n \nstatic int saa711x_detect_chip(struct i2c_client *client,\n\t\t\t       const struct i2c_device_id *id,\n\t\t\t       char *name)\n{\n\tchar chip_ver[CHIP_VER_SIZE];\n\tchar chip_id;\n\tint i;\n\tint autodetect;\n\n\tautodetect = !id || id->driver_data == 1;\n\n\t \n\tfor (i = 0; i < CHIP_VER_SIZE; i++) {\n\t\ti2c_smbus_write_byte_data(client, 0, i);\n\t\tchip_ver[i] = i2c_smbus_read_byte_data(client, 0);\n\t\tname[i] = (chip_ver[i] & 0x0f) + '0';\n\t\tif (name[i] > '9')\n\t\t\tname[i] += 'a' - '9' - 1;\n\t}\n\tname[i] = '\\0';\n\n\t \n\tif (!memcmp(name + 1, \"f711\", 4)) {\n\t\tchip_id = name[5];\n\t\tsnprintf(name, CHIP_VER_SIZE, \"saa711%c\", chip_id);\n\n\t\tif (!autodetect && strcmp(name, id->name))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (chip_id) {\n\t\tcase '1':\n\t\t\tif (chip_ver[0] & 0xf0) {\n\t\t\t\tsnprintf(name, CHIP_VER_SIZE, \"saa711%ca\", chip_id);\n\t\t\t\tv4l_info(client, \"saa7111a variant found\\n\");\n\t\t\t\treturn SAA7111A;\n\t\t\t}\n\t\t\treturn SAA7111;\n\t\tcase '3':\n\t\t\treturn SAA7113;\n\t\tcase '4':\n\t\t\treturn SAA7114;\n\t\tcase '5':\n\t\t\treturn SAA7115;\n\t\tcase '8':\n\t\t\treturn SAA7118;\n\t\tdefault:\n\t\t\tv4l2_info(client,\n\t\t\t\t  \"WARNING: Philips/NXP chip unknown - Falling back to saa7111\\n\");\n\t\t\treturn SAA7111;\n\t\t}\n\t}\n\n\t \n\tif (!memcmp(name, \"0000\", 4)) {\n\t\tchip_id = 0;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tchip_id = chip_id << 1;\n\t\t\tchip_id |= (chip_ver[i] & 0x80) ? 1 : 0;\n\t\t}\n\n\t\t \n\n\t\tstrscpy(name, \"gm7113c\", CHIP_VER_SIZE);\n\n\t\tif (!autodetect && strcmp(name, id->name))\n\t\t\treturn -EINVAL;\n\n\t\tv4l_dbg(1, debug, client,\n\t\t\t\"It seems to be a %s chip (%*ph) @ 0x%x.\\n\",\n\t\t\tname, 16, chip_ver, client->addr << 1);\n\n\t\treturn GM7113C;\n\t}\n\n\t \n\tif (!memcmp(name, \"1111111111111111\", CHIP_VER_SIZE)) {\n\t\tstrscpy(name, \"cjc7113\", CHIP_VER_SIZE);\n\n\t\tif (!autodetect && strcmp(name, id->name))\n\t\t\treturn -EINVAL;\n\n\t\tv4l_dbg(1, debug, client,\n\t\t\t\"It seems to be a %s chip (%*ph) @ 0x%x.\\n\",\n\t\t\tname, 16, chip_ver, client->addr << 1);\n\n\t\t \n\t\treturn SAA7113;\n\t}\n\n\t \n\tv4l_dbg(1, debug, client, \"chip %*ph @ 0x%x is unknown.\\n\",\n\t\t16, chip_ver, client->addr << 1);\n\treturn -ENODEV;\n}\n\nstatic int saa711x_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct saa711x_state *state;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct saa7115_platform_data *pdata;\n\tint ident;\n\tchar name[CHIP_VER_SIZE + 1];\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tint ret;\n#endif\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tident = saa711x_detect_chip(client, id, name);\n\tif (ident == -EINVAL) {\n\t\t \n\t\tv4l_warn(client, \"found %s while %s was expected\\n\",\n\t\t\t name, id->name);\n\t\treturn -ENODEV;\n\t}\n\tif (ident < 0)\n\t\treturn ident;\n\n\tstrscpy(client->name, name, sizeof(client->name));\n\n\tstate = devm_kzalloc(&client->dev, sizeof(*state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\tsd = &state->sd;\n\tv4l2_i2c_subdev_init(sd, client, &saa711x_ops);\n\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tstate->pads[SAA711X_PAD_IF_INPUT].flags = MEDIA_PAD_FL_SINK;\n\tstate->pads[SAA711X_PAD_IF_INPUT].sig_type = PAD_SIGNAL_ANALOG;\n\tstate->pads[SAA711X_PAD_VID_OUT].flags = MEDIA_PAD_FL_SOURCE;\n\tstate->pads[SAA711X_PAD_VID_OUT].sig_type = PAD_SIGNAL_DV;\n\n\tsd->entity.function = MEDIA_ENT_F_ATV_DECODER;\n\n\tret = media_entity_pads_init(&sd->entity, SAA711X_NUM_PADS,\n\t\t\t\t     state->pads);\n\tif (ret < 0)\n\t\treturn ret;\n#endif\n\n\tv4l_info(client, \"%s found @ 0x%x (%s)\\n\", name,\n\t\t client->addr << 1, client->adapter->name);\n\thdl = &state->hdl;\n\tv4l2_ctrl_handler_init(hdl, 6);\n\t \n\tv4l2_ctrl_new_std(hdl, &saa711x_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(hdl, &saa711x_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 127, 1, 64);\n\tv4l2_ctrl_new_std(hdl, &saa711x_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 127, 1, 64);\n\tv4l2_ctrl_new_std(hdl, &saa711x_ctrl_ops,\n\t\t\tV4L2_CID_HUE, -128, 127, 1, 0);\n\tstate->agc = v4l2_ctrl_new_std(hdl, &saa711x_ctrl_ops,\n\t\t\tV4L2_CID_CHROMA_AGC, 0, 1, 1, 1);\n\tstate->gain = v4l2_ctrl_new_std(hdl, &saa711x_ctrl_ops,\n\t\t\tV4L2_CID_CHROMA_GAIN, 0, 127, 1, 40);\n\tsd->ctrl_handler = hdl;\n\tif (hdl->error) {\n\t\tint err = hdl->error;\n\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\treturn err;\n\t}\n\tv4l2_ctrl_auto_cluster(2, &state->agc, 0, true);\n\n\tstate->input = -1;\n\tstate->output = SAA7115_IPORT_ON;\n\tstate->enable = 1;\n\tstate->radio = 0;\n\tstate->ident = ident;\n\n\tstate->audclk_freq = 48000;\n\n\tv4l2_dbg(1, debug, sd, \"writing init values\\n\");\n\n\t \n\tstate->crystal_freq = SAA7115_FREQ_24_576_MHZ;\n\tpdata = client->dev.platform_data;\n\tswitch (state->ident) {\n\tcase SAA7111:\n\tcase SAA7111A:\n\t\tsaa711x_writeregs(sd, saa7111_init);\n\t\tbreak;\n\tcase GM7113C:\n\t\tsaa711x_writeregs(sd, gm7113c_init);\n\t\tbreak;\n\tcase SAA7113:\n\t\tif (pdata && pdata->saa7113_force_gm7113c_init)\n\t\t\tsaa711x_writeregs(sd, gm7113c_init);\n\t\telse\n\t\t\tsaa711x_writeregs(sd, saa7113_init);\n\t\tbreak;\n\tdefault:\n\t\tstate->crystal_freq = SAA7115_FREQ_32_11_MHZ;\n\t\tsaa711x_writeregs(sd, saa7115_init_auto_input);\n\t}\n\tif (state->ident > SAA7111A && state->ident != GM7113C)\n\t\tsaa711x_writeregs(sd, saa7115_init_misc);\n\n\tif (pdata)\n\t\tsaa711x_write_platform_data(state, pdata);\n\n\tsaa711x_set_v4lstd(sd, V4L2_STD_NTSC);\n\tv4l2_ctrl_handler_setup(hdl);\n\n\tv4l2_dbg(1, debug, sd, \"status: (1E) 0x%02x, (1F) 0x%02x\\n\",\n\t\tsaa711x_read(sd, R_1E_STATUS_BYTE_1_VD_DEC),\n\t\tsaa711x_read(sd, R_1F_STATUS_BYTE_2_VD_DEC));\n\treturn 0;\n}\n\n \n\nstatic void saa711x_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\n\tv4l2_device_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(sd->ctrl_handler);\n}\n\nstatic const struct i2c_device_id saa711x_id[] = {\n\t{ \"saa7115_auto\", 1 },  \n\t{ \"saa7111\", 0 },\n\t{ \"saa7113\", 0 },\n\t{ \"saa7114\", 0 },\n\t{ \"saa7115\", 0 },\n\t{ \"saa7118\", 0 },\n\t{ \"gm7113c\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, saa711x_id);\n\nstatic struct i2c_driver saa711x_driver = {\n\t.driver = {\n\t\t.name\t= \"saa7115\",\n\t},\n\t.probe\t\t= saa711x_probe,\n\t.remove\t\t= saa711x_remove,\n\t.id_table\t= saa711x_id,\n};\n\nmodule_i2c_driver(saa711x_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}