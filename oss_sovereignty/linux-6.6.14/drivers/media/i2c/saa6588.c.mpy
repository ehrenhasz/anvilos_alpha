{
  "module_name": "saa6588.c",
  "hash_id": "e48a938f6e57036f4af1d71d67c538ff7f021fcca69079bf166b0ba5e6458c9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/saa6588.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/i2c.h>\n#include <linux/types.h>\n#include <linux/videodev2.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/uaccess.h>\n\n#include <media/i2c/saa6588.h>\n#include <media/v4l2-device.h>\n\n\n \nstatic unsigned int debug;\nstatic unsigned int xtal;\nstatic unsigned int mmbs;\nstatic unsigned int plvl;\nstatic unsigned int bufblocks = 100;\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable debug messages\");\nmodule_param(xtal, int, 0);\nMODULE_PARM_DESC(xtal, \"select oscillator frequency (0..3), default 0\");\nmodule_param(mmbs, int, 0);\nMODULE_PARM_DESC(mmbs, \"enable MMBS mode: 0=off (default), 1=on\");\nmodule_param(plvl, int, 0);\nMODULE_PARM_DESC(plvl, \"select pause level (0..3), default 0\");\nmodule_param(bufblocks, int, 0);\nMODULE_PARM_DESC(bufblocks, \"number of buffered blocks, default 100\");\n\nMODULE_DESCRIPTION(\"v4l2 driver module for SAA6588 RDS decoder\");\nMODULE_AUTHOR(\"Hans J. Koch <koch@hjk-az.de>\");\n\nMODULE_LICENSE(\"GPL\");\n\n \n\n#define UNSET       (-1U)\n#define PREFIX      \"saa6588: \"\n#define dprintk     if (debug) printk\n\nstruct saa6588 {\n\tstruct v4l2_subdev sd;\n\tstruct delayed_work work;\n\tspinlock_t lock;\n\tunsigned char *buffer;\n\tunsigned int buf_size;\n\tunsigned int rd_index;\n\tunsigned int wr_index;\n\tunsigned int block_count;\n\tunsigned char last_blocknum;\n\twait_queue_head_t read_queue;\n\tint data_available_for_read;\n\tu8 sync;\n};\n\nstatic inline struct saa6588 *to_saa6588(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct saa6588, sd);\n}\n\n \n\n \n\n \n\n \n#define cModeStandard           0x00\n#define cModeFastPI             0x01\n#define cModeReducedRequest     0x02\n#define cModeInvalid            0x03\n\n \n#define cProcessingModeRDS      0x00\n#define cProcessingModeRBDS     0x04\n\n \n#define cErrCorrectionNone      0x00\n#define cErrCorrection2Bits     0x08\n#define cErrCorrection5Bits     0x10\n#define cErrCorrectionNoneRBDS  0x18\n\n \n#define cSyncNormal             0x00\n#define cSyncRestart            0x20\n\n \n#define cSigQualityDetectOFF    0x00\n#define cSigQualityDetectON     0x40\n\n \n#define cSigQualityTriggered    0x00\n#define cSigQualityContinous    0x80\n\n \n\n \n#define cFlywheelMaxBlocksMask  0x3F\n#define cFlywheelDefault        0x20\n\n \n#define cPauseLevel_11mV\t0x00\n#define cPauseLevel_17mV        0x40\n#define cPauseLevel_27mV        0x80\n#define cPauseLevel_43mV        0xC0\n\n \n\n \n#define cQualityDetectSensMask  0x1F\n#define cQualityDetectDefault   0x0F\n\n \n#define cSelectOscFreqOFF\t0x00\n#define cSelectOscFreqON\t0x20\n\n \n#define cOscFreq_4332kHz\t0x00\n#define cOscFreq_8664kHz\t0x40\n#define cOscFreq_12996kHz\t0x80\n#define cOscFreq_17328kHz\t0xC0\n\n \n\nstatic bool block_from_buf(struct saa6588 *s, unsigned char *buf)\n{\n\tint i;\n\n\tif (s->rd_index == s->wr_index) {\n\t\tif (debug > 2)\n\t\t\tdprintk(PREFIX \"Read: buffer empty.\\n\");\n\t\treturn false;\n\t}\n\n\tif (debug > 2) {\n\t\tdprintk(PREFIX \"Read: \");\n\t\tfor (i = s->rd_index; i < s->rd_index + 3; i++)\n\t\t\tdprintk(\"0x%02x \", s->buffer[i]);\n\t}\n\n\tmemcpy(buf, &s->buffer[s->rd_index], 3);\n\n\ts->rd_index += 3;\n\tif (s->rd_index >= s->buf_size)\n\t\ts->rd_index = 0;\n\ts->block_count--;\n\n\tif (debug > 2)\n\t\tdprintk(\"%d blocks total.\\n\", s->block_count);\n\n\treturn true;\n}\n\nstatic void read_from_buf(struct saa6588 *s, struct saa6588_command *a)\n{\n\tunsigned char __user *buf_ptr = a->buffer;\n\tunsigned char buf[3];\n\tunsigned long flags;\n\tunsigned int rd_blocks;\n\tunsigned int i;\n\n\ta->result = 0;\n\tif (!a->buffer)\n\t\treturn;\n\n\twhile (!a->nonblocking && !s->data_available_for_read) {\n\t\tint ret = wait_event_interruptible(s->read_queue,\n\t\t\t\t\t     s->data_available_for_read);\n\t\tif (ret == -ERESTARTSYS) {\n\t\t\ta->result = -EINTR;\n\t\t\treturn;\n\t\t}\n\t}\n\n\trd_blocks = a->block_count;\n\tspin_lock_irqsave(&s->lock, flags);\n\tif (rd_blocks > s->block_count)\n\t\trd_blocks = s->block_count;\n\tspin_unlock_irqrestore(&s->lock, flags);\n\n\tif (!rd_blocks)\n\t\treturn;\n\n\tfor (i = 0; i < rd_blocks; i++) {\n\t\tbool got_block;\n\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\tgot_block = block_from_buf(s, buf);\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t\tif (!got_block)\n\t\t\tbreak;\n\t\tif (copy_to_user(buf_ptr, buf, 3)) {\n\t\t\ta->result = -EFAULT;\n\t\t\treturn;\n\t\t}\n\t\tbuf_ptr += 3;\n\t\ta->result += 3;\n\t}\n\tspin_lock_irqsave(&s->lock, flags);\n\ts->data_available_for_read = (s->block_count > 0);\n\tspin_unlock_irqrestore(&s->lock, flags);\n}\n\nstatic void block_to_buf(struct saa6588 *s, unsigned char *blockbuf)\n{\n\tunsigned int i;\n\n\tif (debug > 3)\n\t\tdprintk(PREFIX \"New block: \");\n\n\tfor (i = 0; i < 3; ++i) {\n\t\tif (debug > 3)\n\t\t\tdprintk(\"0x%02x \", blockbuf[i]);\n\t\ts->buffer[s->wr_index] = blockbuf[i];\n\t\ts->wr_index++;\n\t}\n\n\tif (s->wr_index >= s->buf_size)\n\t\ts->wr_index = 0;\n\n\tif (s->wr_index == s->rd_index) {\n\t\ts->rd_index += 3;\n\t\tif (s->rd_index >= s->buf_size)\n\t\t\ts->rd_index = 0;\n\t} else\n\t\ts->block_count++;\n\n\tif (debug > 3)\n\t\tdprintk(\"%d blocks total.\\n\", s->block_count);\n}\n\nstatic void saa6588_i2c_poll(struct saa6588 *s)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&s->sd);\n\tunsigned long flags;\n\tunsigned char tmpbuf[6];\n\tunsigned char blocknum;\n\tunsigned char tmp;\n\n\t \n\tif (6 != i2c_master_recv(client, &tmpbuf[0], 6)) {\n\t\tif (debug > 1)\n\t\t\tdprintk(PREFIX \"read error!\\n\");\n\t\treturn;\n\t}\n\n\ts->sync = tmpbuf[0] & 0x10;\n\tif (!s->sync)\n\t\treturn;\n\tblocknum = tmpbuf[0] >> 5;\n\tif (blocknum == s->last_blocknum) {\n\t\tif (debug > 3)\n\t\t\tdprintk(\"Saw block %d again.\\n\", blocknum);\n\t\treturn;\n\t}\n\n\ts->last_blocknum = blocknum;\n\n\t \n\n\tswap(tmpbuf[2], tmpbuf[0]);\n\n\t \n\tif (blocknum == 6)\n\t\tblocknum = V4L2_RDS_BLOCK_INVALID;\n\t \n\telse if (!mmbs && blocknum == 5)\n\t\tblocknum = V4L2_RDS_BLOCK_INVALID;\n\ttmp = blocknum;\n\ttmp |= blocknum << 3;\t \n\tif ((tmpbuf[2] & 0x03) == 0x03)\n\t\ttmp |= V4L2_RDS_BLOCK_ERROR;\t  \n\telse if ((tmpbuf[2] & 0x03) != 0x00)\n\t\ttmp |= V4L2_RDS_BLOCK_CORRECTED;  \n\ttmpbuf[2] = tmp;\t \n\n\tspin_lock_irqsave(&s->lock, flags);\n\tblock_to_buf(s, tmpbuf);\n\tspin_unlock_irqrestore(&s->lock, flags);\n\ts->data_available_for_read = 1;\n\twake_up_interruptible(&s->read_queue);\n}\n\nstatic void saa6588_work(struct work_struct *work)\n{\n\tstruct saa6588 *s = container_of(work, struct saa6588, work.work);\n\n\tsaa6588_i2c_poll(s);\n\tschedule_delayed_work(&s->work, msecs_to_jiffies(20));\n}\n\nstatic void saa6588_configure(struct saa6588 *s)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&s->sd);\n\tunsigned char buf[3];\n\tint rc;\n\n\tbuf[0] = cSyncRestart;\n\tif (mmbs)\n\t\tbuf[0] |= cProcessingModeRBDS;\n\n\tbuf[1] = cFlywheelDefault;\n\tswitch (plvl) {\n\tcase 0:\n\t\tbuf[1] |= cPauseLevel_11mV;\n\t\tbreak;\n\tcase 1:\n\t\tbuf[1] |= cPauseLevel_17mV;\n\t\tbreak;\n\tcase 2:\n\t\tbuf[1] |= cPauseLevel_27mV;\n\t\tbreak;\n\tcase 3:\n\t\tbuf[1] |= cPauseLevel_43mV;\n\t\tbreak;\n\tdefault:\t\t \n\t\tbreak;\n\t}\n\n\tbuf[2] = cQualityDetectDefault | cSelectOscFreqON;\n\n\tswitch (xtal) {\n\tcase 0:\n\t\tbuf[2] |= cOscFreq_4332kHz;\n\t\tbreak;\n\tcase 1:\n\t\tbuf[2] |= cOscFreq_8664kHz;\n\t\tbreak;\n\tcase 2:\n\t\tbuf[2] |= cOscFreq_12996kHz;\n\t\tbreak;\n\tcase 3:\n\t\tbuf[2] |= cOscFreq_17328kHz;\n\t\tbreak;\n\tdefault:\t\t \n\t\tbreak;\n\t}\n\n\tdprintk(PREFIX \"writing: 0w=0x%02x 1w=0x%02x 2w=0x%02x\\n\",\n\t\tbuf[0], buf[1], buf[2]);\n\n\trc = i2c_master_send(client, buf, 3);\n\tif (rc != 3)\n\t\tprintk(PREFIX \"i2c i/o error: rc == %d (should be 3)\\n\", rc);\n}\n\n \n\nstatic long saa6588_command(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\n{\n\tstruct saa6588 *s = to_saa6588(sd);\n\tstruct saa6588_command *a = arg;\n\n\tswitch (cmd) {\n\t\t \n\tcase SAA6588_CMD_CLOSE:\n\t\ts->data_available_for_read = 1;\n\t\twake_up_interruptible(&s->read_queue);\n\t\ts->data_available_for_read = 0;\n\t\ta->result = 0;\n\t\tbreak;\n\t\t \n\tcase SAA6588_CMD_READ:\n\t\tread_from_buf(s, a);\n\t\tbreak;\n\t\t \n\tcase SAA6588_CMD_POLL:\n\t\ta->poll_mask = 0;\n\t\tif (s->data_available_for_read)\n\t\t\ta->poll_mask |= EPOLLIN | EPOLLRDNORM;\n\t\tpoll_wait(a->instance, &s->read_queue, a->event_list);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn 0;\n}\n\nstatic int saa6588_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\n{\n\tstruct saa6588 *s = to_saa6588(sd);\n\n\tvt->capability |= V4L2_TUNER_CAP_RDS | V4L2_TUNER_CAP_RDS_BLOCK_IO;\n\tif (s->sync)\n\t\tvt->rxsubchans |= V4L2_TUNER_SUB_RDS;\n\treturn 0;\n}\n\nstatic int saa6588_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *vt)\n{\n\tstruct saa6588 *s = to_saa6588(sd);\n\n\tsaa6588_configure(s);\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_subdev_core_ops saa6588_core_ops = {\n\t.command = saa6588_command,\n};\n\nstatic const struct v4l2_subdev_tuner_ops saa6588_tuner_ops = {\n\t.g_tuner = saa6588_g_tuner,\n\t.s_tuner = saa6588_s_tuner,\n};\n\nstatic const struct v4l2_subdev_ops saa6588_ops = {\n\t.core = &saa6588_core_ops,\n\t.tuner = &saa6588_tuner_ops,\n};\n\n \n\nstatic int saa6588_probe(struct i2c_client *client)\n{\n\tstruct saa6588 *s;\n\tstruct v4l2_subdev *sd;\n\n\tv4l_info(client, \"saa6588 found @ 0x%x (%s)\\n\",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\ts = devm_kzalloc(&client->dev, sizeof(*s), GFP_KERNEL);\n\tif (s == NULL)\n\t\treturn -ENOMEM;\n\n\ts->buf_size = bufblocks * 3;\n\n\ts->buffer = devm_kzalloc(&client->dev, s->buf_size, GFP_KERNEL);\n\tif (s->buffer == NULL)\n\t\treturn -ENOMEM;\n\tsd = &s->sd;\n\tv4l2_i2c_subdev_init(sd, client, &saa6588_ops);\n\tspin_lock_init(&s->lock);\n\ts->block_count = 0;\n\ts->wr_index = 0;\n\ts->rd_index = 0;\n\ts->last_blocknum = 0xff;\n\tinit_waitqueue_head(&s->read_queue);\n\ts->data_available_for_read = 0;\n\n\tsaa6588_configure(s);\n\n\t \n\tINIT_DELAYED_WORK(&s->work, saa6588_work);\n\tschedule_delayed_work(&s->work, 0);\n\treturn 0;\n}\n\nstatic void saa6588_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct saa6588 *s = to_saa6588(sd);\n\n\tv4l2_device_unregister_subdev(sd);\n\n\tcancel_delayed_work_sync(&s->work);\n}\n\n \n\nstatic const struct i2c_device_id saa6588_id[] = {\n\t{ \"saa6588\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, saa6588_id);\n\nstatic struct i2c_driver saa6588_driver = {\n\t.driver = {\n\t\t.name\t= \"saa6588\",\n\t},\n\t.probe\t\t= saa6588_probe,\n\t.remove\t\t= saa6588_remove,\n\t.id_table\t= saa6588_id,\n};\n\nmodule_i2c_driver(saa6588_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}