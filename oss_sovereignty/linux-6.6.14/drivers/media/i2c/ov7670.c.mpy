{
  "module_name": "ov7670.c",
  "hash_id": "8e1a1eeb9ccdada2b485300ac241b5005d35d08e2854f4b20011b79cb26eb142",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ov7670.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/videodev2.h>\n#include <linux/gpio/consumer.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-mediabus.h>\n#include <media/v4l2-image-sizes.h>\n#include <media/i2c/ov7670.h>\n\nMODULE_AUTHOR(\"Jonathan Corbet <corbet@lwn.net>\");\nMODULE_DESCRIPTION(\"A low-level driver for OmniVision ov7670 sensors\");\nMODULE_LICENSE(\"GPL\");\n\nstatic bool debug;\nmodule_param(debug, bool, 0644);\nMODULE_PARM_DESC(debug, \"Debug level (0-1)\");\n\n \n#define OV7670_I2C_ADDR 0x42\n\n#define PLL_FACTOR\t4\n\n \n#define REG_GAIN\t0x00\t \n#define REG_BLUE\t0x01\t \n#define REG_RED\t\t0x02\t \n#define REG_VREF\t0x03\t \n#define REG_COM1\t0x04\t \n#define  COM1_CCIR656\t  0x40   \n#define REG_BAVE\t0x05\t \n#define REG_GbAVE\t0x06\t \n#define REG_AECHH\t0x07\t \n#define REG_RAVE\t0x08\t \n#define REG_COM2\t0x09\t \n#define  COM2_SSLEEP\t  0x10\t \n#define REG_PID\t\t0x0a\t \n#define REG_VER\t\t0x0b\t \n#define REG_COM3\t0x0c\t \n#define  COM3_SWAP\t  0x40\t   \n#define  COM3_SCALEEN\t  0x08\t   \n#define  COM3_DCWEN\t  0x04\t   \n#define REG_COM4\t0x0d\t \n#define REG_COM5\t0x0e\t \n#define REG_COM6\t0x0f\t \n#define REG_AECH\t0x10\t \n#define REG_CLKRC\t0x11\t \n#define   CLK_EXT\t  0x40\t   \n#define   CLK_SCALE\t  0x3f\t   \n#define REG_COM7\t0x12\t \n#define   COM7_RESET\t  0x80\t   \n#define   COM7_FMT_MASK\t  0x38\n#define   COM7_FMT_VGA\t  0x00\n#define\t  COM7_FMT_CIF\t  0x20\t   \n#define   COM7_FMT_QVGA\t  0x10\t   \n#define   COM7_FMT_QCIF\t  0x08\t   \n#define\t  COM7_RGB\t  0x04\t   \n#define\t  COM7_YUV\t  0x00\t   \n#define\t  COM7_BAYER\t  0x01\t   \n#define\t  COM7_PBAYER\t  0x05\t   \n#define REG_COM8\t0x13\t \n#define   COM8_FASTAEC\t  0x80\t   \n#define   COM8_AECSTEP\t  0x40\t   \n#define   COM8_BFILT\t  0x20\t   \n#define   COM8_AGC\t  0x04\t   \n#define   COM8_AWB\t  0x02\t   \n#define   COM8_AEC\t  0x01\t   \n#define REG_COM9\t0x14\t \n#define REG_COM10\t0x15\t \n#define   COM10_HSYNC\t  0x40\t   \n#define   COM10_PCLK_HB\t  0x20\t   \n#define   COM10_HREF_REV  0x08\t   \n#define   COM10_VS_LEAD\t  0x04\t   \n#define   COM10_VS_NEG\t  0x02\t   \n#define   COM10_HS_NEG\t  0x01\t   \n#define REG_HSTART\t0x17\t \n#define REG_HSTOP\t0x18\t \n#define REG_VSTART\t0x19\t \n#define REG_VSTOP\t0x1a\t \n#define REG_PSHFT\t0x1b\t \n#define REG_MIDH\t0x1c\t \n#define REG_MIDL\t0x1d\t \n#define REG_MVFP\t0x1e\t \n#define   MVFP_MIRROR\t  0x20\t   \n#define   MVFP_FLIP\t  0x10\t   \n\n#define REG_AEW\t\t0x24\t \n#define REG_AEB\t\t0x25\t \n#define REG_VPT\t\t0x26\t \n#define REG_HSYST\t0x30\t \n#define REG_HSYEN\t0x31\t \n#define REG_HREF\t0x32\t \n#define REG_TSLB\t0x3a\t \n#define   TSLB_YLAST\t  0x04\t   \n#define REG_COM11\t0x3b\t \n#define   COM11_NIGHT\t  0x80\t   \n#define   COM11_NMFR\t  0x60\t   \n#define   COM11_HZAUTO\t  0x10\t   \n#define\t  COM11_50HZ\t  0x08\t   \n#define   COM11_EXP\t  0x02\n#define REG_COM12\t0x3c\t \n#define   COM12_HREF\t  0x80\t   \n#define REG_COM13\t0x3d\t \n#define   COM13_GAMMA\t  0x80\t   \n#define\t  COM13_UVSAT\t  0x40\t   \n#define   COM13_UVSWAP\t  0x01\t   \n#define REG_COM14\t0x3e\t \n#define   COM14_DCWEN\t  0x10\t   \n#define REG_EDGE\t0x3f\t \n#define REG_COM15\t0x40\t \n#define   COM15_R10F0\t  0x00\t   \n#define\t  COM15_R01FE\t  0x80\t   \n#define   COM15_R00FF\t  0xc0\t   \n#define   COM15_RGB565\t  0x10\t   \n#define   COM15_RGB555\t  0x30\t   \n#define REG_COM16\t0x41\t \n#define   COM16_AWBGAIN   0x08\t   \n#define REG_COM17\t0x42\t \n#define   COM17_AECWIN\t  0xc0\t   \n#define   COM17_CBAR\t  0x08\t   \n\n \n#define\tREG_CMATRIX_BASE 0x4f\n#define   CMATRIX_LEN 6\n#define REG_CMATRIX_SIGN 0x58\n\n\n#define REG_BRIGHT\t0x55\t \n#define REG_CONTRAS\t0x56\t \n\n#define REG_GFIX\t0x69\t \n\n#define REG_DBLV\t0x6b\t \n#define   DBLV_BYPASS\t  0x0a\t   \n#define   DBLV_X4\t  0x4a\t   \n#define   DBLV_X6\t  0x8a\t   \n#define   DBLV_X8\t  0xca\t   \n\n#define REG_SCALING_XSC\t0x70\t \n#define   TEST_PATTTERN_0 0x80\n#define REG_SCALING_YSC\t0x71\t \n#define   TEST_PATTTERN_1 0x80\n\n#define REG_REG76\t0x76\t \n#define   R76_BLKPCOR\t  0x80\t   \n#define   R76_WHTPCOR\t  0x40\t   \n\n#define REG_RGB444\t0x8c\t \n#define   R444_ENABLE\t  0x02\t   \n#define   R444_RGBX\t  0x01\t   \n\n#define REG_HAECC1\t0x9f\t \n#define REG_HAECC2\t0xa0\t \n\n#define REG_BD50MAX\t0xa5\t \n#define REG_HAECC3\t0xa6\t \n#define REG_HAECC4\t0xa7\t \n#define REG_HAECC5\t0xa8\t \n#define REG_HAECC6\t0xa9\t \n#define REG_HAECC7\t0xaa\t \n#define REG_BD60MAX\t0xab\t \n\nenum ov7670_model {\n\tMODEL_OV7670 = 0,\n\tMODEL_OV7675,\n};\n\nstruct ov7670_win_size {\n\tint\twidth;\n\tint\theight;\n\tunsigned char com7_bit;\n\tint\thstart;\t\t \n\tint\thstop;\t\t \n\tint\tvstart;\t\t \n\tint\tvstop;\t\t \n\tstruct regval_list *regs;  \n};\n\nstruct ov7670_devtype {\n\t \n\tstruct ov7670_win_size *win_sizes;\n\tunsigned int n_win_sizes;\n\t \n\tint (*set_framerate)(struct v4l2_subdev *, struct v4l2_fract *);\n\tvoid (*get_framerate)(struct v4l2_subdev *, struct v4l2_fract *);\n};\n\n \nstruct ov7670_format_struct;   \nstruct ov7670_info {\n\tstruct v4l2_subdev sd;\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tstruct media_pad pad;\n#endif\n\tstruct v4l2_ctrl_handler hdl;\n\tstruct {\n\t\t \n\t\tstruct v4l2_ctrl *auto_gain;\n\t\tstruct v4l2_ctrl *gain;\n\t};\n\tstruct {\n\t\t \n\t\tstruct v4l2_ctrl *auto_exposure;\n\t\tstruct v4l2_ctrl *exposure;\n\t};\n\tstruct {\n\t\t \n\t\tstruct v4l2_ctrl *saturation;\n\t\tstruct v4l2_ctrl *hue;\n\t};\n\tstruct v4l2_mbus_framefmt format;\n\tstruct ov7670_format_struct *fmt;   \n\tstruct ov7670_win_size *wsize;\n\tstruct clk *clk;\n\tint on;\n\tstruct gpio_desc *resetb_gpio;\n\tstruct gpio_desc *pwdn_gpio;\n\tunsigned int mbus_config;\t \n\tint min_width;\t\t\t \n\tint min_height;\t\t\t \n\tint clock_speed;\t\t \n\tu8 clkrc;\t\t\t \n\tbool use_smbus;\t\t\t \n\tbool pll_bypass;\n\tbool pclk_hb_disable;\n\tconst struct ov7670_devtype *devtype;  \n};\n\nstatic inline struct ov7670_info *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct ov7670_info, sd);\n}\n\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct ov7670_info, hdl)->sd;\n}\n\n\n\n \n\nstruct regval_list {\n\tunsigned char reg_num;\n\tunsigned char value;\n};\n\nstatic struct regval_list ov7670_default_regs[] = {\n\t{ REG_COM7, COM7_RESET },\n \n\t{ REG_CLKRC, 0x1 },\t \n\t{ REG_TSLB,  0x04 },\t \n\t{ REG_COM7, 0 },\t \n\t \n\t{ REG_HSTART, 0x13 },\t{ REG_HSTOP, 0x01 },\n\t{ REG_HREF, 0xb6 },\t{ REG_VSTART, 0x02 },\n\t{ REG_VSTOP, 0x7a },\t{ REG_VREF, 0x0a },\n\n\t{ REG_COM3, 0 },\t{ REG_COM14, 0 },\n\t \n\t{ REG_SCALING_XSC, 0x3a },\n\t{ REG_SCALING_YSC, 0x35 },\n\t{ 0x72, 0x11 },\t\t{ 0x73, 0xf0 },\n\t{ 0xa2, 0x02 },\t\t{ REG_COM10, 0x0 },\n\n\t \n\t{ 0x7a, 0x20 },\t\t{ 0x7b, 0x10 },\n\t{ 0x7c, 0x1e },\t\t{ 0x7d, 0x35 },\n\t{ 0x7e, 0x5a },\t\t{ 0x7f, 0x69 },\n\t{ 0x80, 0x76 },\t\t{ 0x81, 0x80 },\n\t{ 0x82, 0x88 },\t\t{ 0x83, 0x8f },\n\t{ 0x84, 0x96 },\t\t{ 0x85, 0xa3 },\n\t{ 0x86, 0xaf },\t\t{ 0x87, 0xc4 },\n\t{ 0x88, 0xd7 },\t\t{ 0x89, 0xe8 },\n\n\t \n\t{ REG_COM8, COM8_FASTAEC | COM8_AECSTEP | COM8_BFILT },\n\t{ REG_GAIN, 0 },\t{ REG_AECH, 0 },\n\t{ REG_COM4, 0x40 },  \n\t{ REG_COM9, 0x18 },  \n\t{ REG_BD50MAX, 0x05 },\t{ REG_BD60MAX, 0x07 },\n\t{ REG_AEW, 0x95 },\t{ REG_AEB, 0x33 },\n\t{ REG_VPT, 0xe3 },\t{ REG_HAECC1, 0x78 },\n\t{ REG_HAECC2, 0x68 },\t{ 0xa1, 0x03 },  \n\t{ REG_HAECC3, 0xd8 },\t{ REG_HAECC4, 0xd8 },\n\t{ REG_HAECC5, 0xf0 },\t{ REG_HAECC6, 0x90 },\n\t{ REG_HAECC7, 0x94 },\n\t{ REG_COM8, COM8_FASTAEC|COM8_AECSTEP|COM8_BFILT|COM8_AGC|COM8_AEC },\n\n\t \n\t{ REG_COM5, 0x61 },\t{ REG_COM6, 0x4b },\n\t{ 0x16, 0x02 },\t\t{ REG_MVFP, 0x07 },\n\t{ 0x21, 0x02 },\t\t{ 0x22, 0x91 },\n\t{ 0x29, 0x07 },\t\t{ 0x33, 0x0b },\n\t{ 0x35, 0x0b },\t\t{ 0x37, 0x1d },\n\t{ 0x38, 0x71 },\t\t{ 0x39, 0x2a },\n\t{ REG_COM12, 0x78 },\t{ 0x4d, 0x40 },\n\t{ 0x4e, 0x20 },\t\t{ REG_GFIX, 0 },\n\t{ 0x6b, 0x4a },\t\t{ 0x74, 0x10 },\n\t{ 0x8d, 0x4f },\t\t{ 0x8e, 0 },\n\t{ 0x8f, 0 },\t\t{ 0x90, 0 },\n\t{ 0x91, 0 },\t\t{ 0x96, 0 },\n\t{ 0x9a, 0 },\t\t{ 0xb0, 0x84 },\n\t{ 0xb1, 0x0c },\t\t{ 0xb2, 0x0e },\n\t{ 0xb3, 0x82 },\t\t{ 0xb8, 0x0a },\n\n\t \n\t{ 0x43, 0x0a },\t\t{ 0x44, 0xf0 },\n\t{ 0x45, 0x34 },\t\t{ 0x46, 0x58 },\n\t{ 0x47, 0x28 },\t\t{ 0x48, 0x3a },\n\t{ 0x59, 0x88 },\t\t{ 0x5a, 0x88 },\n\t{ 0x5b, 0x44 },\t\t{ 0x5c, 0x67 },\n\t{ 0x5d, 0x49 },\t\t{ 0x5e, 0x0e },\n\t{ 0x6c, 0x0a },\t\t{ 0x6d, 0x55 },\n\t{ 0x6e, 0x11 },\t\t{ 0x6f, 0x9f },  \n\t{ 0x6a, 0x40 },\t\t{ REG_BLUE, 0x40 },\n\t{ REG_RED, 0x60 },\n\t{ REG_COM8, COM8_FASTAEC|COM8_AECSTEP|COM8_BFILT|COM8_AGC|COM8_AEC|COM8_AWB },\n\n\t \n\t{ 0x4f, 0x80 },\t\t{ 0x50, 0x80 },\n\t{ 0x51, 0 },\t\t{ 0x52, 0x22 },\n\t{ 0x53, 0x5e },\t\t{ 0x54, 0x80 },\n\t{ 0x58, 0x9e },\n\n\t{ REG_COM16, COM16_AWBGAIN },\t{ REG_EDGE, 0 },\n\t{ 0x75, 0x05 },\t\t{ 0x76, 0xe1 },\n\t{ 0x4c, 0 },\t\t{ 0x77, 0x01 },\n\t{ REG_COM13, 0xc3 },\t{ 0x4b, 0x09 },\n\t{ 0xc9, 0x60 },\t\t{ REG_COM16, 0x38 },\n\t{ 0x56, 0x40 },\n\n\t{ 0x34, 0x11 },\t\t{ REG_COM11, COM11_EXP|COM11_HZAUTO },\n\t{ 0xa4, 0x88 },\t\t{ 0x96, 0 },\n\t{ 0x97, 0x30 },\t\t{ 0x98, 0x20 },\n\t{ 0x99, 0x30 },\t\t{ 0x9a, 0x84 },\n\t{ 0x9b, 0x29 },\t\t{ 0x9c, 0x03 },\n\t{ 0x9d, 0x4c },\t\t{ 0x9e, 0x3f },\n\t{ 0x78, 0x04 },\n\n\t \n\t{ 0x79, 0x01 },\t\t{ 0xc8, 0xf0 },\n\t{ 0x79, 0x0f },\t\t{ 0xc8, 0x00 },\n\t{ 0x79, 0x10 },\t\t{ 0xc8, 0x7e },\n\t{ 0x79, 0x0a },\t\t{ 0xc8, 0x80 },\n\t{ 0x79, 0x0b },\t\t{ 0xc8, 0x01 },\n\t{ 0x79, 0x0c },\t\t{ 0xc8, 0x0f },\n\t{ 0x79, 0x0d },\t\t{ 0xc8, 0x20 },\n\t{ 0x79, 0x09 },\t\t{ 0xc8, 0x80 },\n\t{ 0x79, 0x02 },\t\t{ 0xc8, 0xc0 },\n\t{ 0x79, 0x03 },\t\t{ 0xc8, 0x40 },\n\t{ 0x79, 0x05 },\t\t{ 0xc8, 0x30 },\n\t{ 0x79, 0x26 },\n\n\t{ 0xff, 0xff },\t \n};\n\n\n \n\n\nstatic struct regval_list ov7670_fmt_yuv422[] = {\n\t{ REG_COM7, 0x0 },   \n\t{ REG_RGB444, 0 },\t \n\t{ REG_COM1, 0 },\t \n\t{ REG_COM15, COM15_R00FF },\n\t{ REG_COM9, 0x48 },  \n\t{ 0x4f, 0x80 },\t\t \n\t{ 0x50, 0x80 },\t\t \n\t{ 0x51, 0    },\t\t \n\t{ 0x52, 0x22 },\t\t \n\t{ 0x53, 0x5e },\t\t \n\t{ 0x54, 0x80 },\t\t \n\t{ REG_COM13, COM13_GAMMA|COM13_UVSAT },\n\t{ 0xff, 0xff },\n};\n\nstatic struct regval_list ov7670_fmt_rgb565[] = {\n\t{ REG_COM7, COM7_RGB },\t \n\t{ REG_RGB444, 0 },\t \n\t{ REG_COM1, 0x0 },\t \n\t{ REG_COM15, COM15_RGB565 },\n\t{ REG_COM9, 0x38 },\t \n\t{ 0x4f, 0xb3 },\t\t \n\t{ 0x50, 0xb3 },\t\t \n\t{ 0x51, 0    },\t\t \n\t{ 0x52, 0x3d },\t\t \n\t{ 0x53, 0xa7 },\t\t \n\t{ 0x54, 0xe4 },\t\t \n\t{ REG_COM13, COM13_GAMMA|COM13_UVSAT },\n\t{ 0xff, 0xff },\n};\n\nstatic struct regval_list ov7670_fmt_rgb444[] = {\n\t{ REG_COM7, COM7_RGB },\t \n\t{ REG_RGB444, R444_ENABLE },\t \n\t{ REG_COM1, 0x0 },\t \n\t{ REG_COM15, COM15_R01FE|COM15_RGB565 },  \n\t{ REG_COM9, 0x38 },\t \n\t{ 0x4f, 0xb3 },\t\t \n\t{ 0x50, 0xb3 },\t\t \n\t{ 0x51, 0    },\t\t \n\t{ 0x52, 0x3d },\t\t \n\t{ 0x53, 0xa7 },\t\t \n\t{ 0x54, 0xe4 },\t\t \n\t{ REG_COM13, COM13_GAMMA|COM13_UVSAT|0x2 },   \n\t{ 0xff, 0xff },\n};\n\nstatic struct regval_list ov7670_fmt_raw[] = {\n\t{ REG_COM7, COM7_BAYER },\n\t{ REG_COM13, 0x08 },  \n\t{ REG_COM16, 0x3d },  \n\t{ REG_REG76, 0xe1 },  \n\t{ 0xff, 0xff },\n};\n\n\n\n \nstatic int ov7670_read_smbus(struct v4l2_subdev *sd, unsigned char reg,\n\t\tunsigned char *value)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, reg);\n\tif (ret >= 0) {\n\t\t*value = (unsigned char)ret;\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\n\nstatic int ov7670_write_smbus(struct v4l2_subdev *sd, unsigned char reg,\n\t\tunsigned char value)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret = i2c_smbus_write_byte_data(client, reg, value);\n\n\tif (reg == REG_COM7 && (value & COM7_RESET))\n\t\tmsleep(5);   \n\treturn ret;\n}\n\n \nstatic int ov7670_read_i2c(struct v4l2_subdev *sd, unsigned char reg,\n\t\tunsigned char *value)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tu8 data = reg;\n\tstruct i2c_msg msg;\n\tint ret;\n\n\t \n\tmsg.addr = client->addr;\n\tmsg.flags = 0;\n\tmsg.len = 1;\n\tmsg.buf = &data;\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"Error %d on register write\\n\", ret);\n\t\treturn ret;\n\t}\n\t \n\tmsg.flags = I2C_M_RD;\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret >= 0) {\n\t\t*value = data;\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\n\nstatic int ov7670_write_i2c(struct v4l2_subdev *sd, unsigned char reg,\n\t\tunsigned char value)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct i2c_msg msg;\n\tunsigned char data[2] = { reg, value };\n\tint ret;\n\n\tmsg.addr = client->addr;\n\tmsg.flags = 0;\n\tmsg.len = 2;\n\tmsg.buf = data;\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret > 0)\n\t\tret = 0;\n\tif (reg == REG_COM7 && (value & COM7_RESET))\n\t\tmsleep(5);   \n\treturn ret;\n}\n\nstatic int ov7670_read(struct v4l2_subdev *sd, unsigned char reg,\n\t\tunsigned char *value)\n{\n\tstruct ov7670_info *info = to_state(sd);\n\n\tif (info->use_smbus)\n\t\treturn ov7670_read_smbus(sd, reg, value);\n\telse\n\t\treturn ov7670_read_i2c(sd, reg, value);\n}\n\nstatic int ov7670_write(struct v4l2_subdev *sd, unsigned char reg,\n\t\tunsigned char value)\n{\n\tstruct ov7670_info *info = to_state(sd);\n\n\tif (info->use_smbus)\n\t\treturn ov7670_write_smbus(sd, reg, value);\n\telse\n\t\treturn ov7670_write_i2c(sd, reg, value);\n}\n\nstatic int ov7670_update_bits(struct v4l2_subdev *sd, unsigned char reg,\n\t\tunsigned char mask, unsigned char value)\n{\n\tunsigned char orig;\n\tint ret;\n\n\tret = ov7670_read(sd, reg, &orig);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov7670_write(sd, reg, (orig & ~mask) | (value & mask));\n}\n\n \nstatic int ov7670_write_array(struct v4l2_subdev *sd, struct regval_list *vals)\n{\n\twhile (vals->reg_num != 0xff || vals->value != 0xff) {\n\t\tint ret = ov7670_write(sd, vals->reg_num, vals->value);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tvals++;\n\t}\n\treturn 0;\n}\n\n\n \nstatic int ov7670_reset(struct v4l2_subdev *sd, u32 val)\n{\n\tov7670_write(sd, REG_COM7, COM7_RESET);\n\tmsleep(1);\n\treturn 0;\n}\n\n\nstatic int ov7670_init(struct v4l2_subdev *sd, u32 val)\n{\n\treturn ov7670_write_array(sd, ov7670_default_regs);\n}\n\nstatic int ov7670_detect(struct v4l2_subdev *sd)\n{\n\tunsigned char v;\n\tint ret;\n\n\tret = ov7670_init(sd, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = ov7670_read(sd, REG_MIDH, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (v != 0x7f)  \n\t\treturn -ENODEV;\n\tret = ov7670_read(sd, REG_MIDL, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (v != 0xa2)\n\t\treturn -ENODEV;\n\t \n\tret = ov7670_read(sd, REG_PID, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (v != 0x76)   \n\t\treturn -ENODEV;\n\tret = ov7670_read(sd, REG_VER, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (v != 0x73)   \n\t\treturn -ENODEV;\n\treturn 0;\n}\n\n\n \nstatic struct ov7670_format_struct {\n\tu32 mbus_code;\n\tenum v4l2_colorspace colorspace;\n\tstruct regval_list *regs;\n\tint cmatrix[CMATRIX_LEN];\n} ov7670_formats[] = {\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.regs\t\t= ov7670_fmt_yuv422,\n\t\t.cmatrix\t= { 128, -128, 0, -34, -94, 128 },\n\t},\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_RGB444_2X8_PADHI_LE,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.regs\t\t= ov7670_fmt_rgb444,\n\t\t.cmatrix\t= { 179, -179, 0, -61, -176, 228 },\n\t},\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_RGB565_2X8_LE,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.regs\t\t= ov7670_fmt_rgb565,\n\t\t.cmatrix\t= { 179, -179, 0, -61, -176, 228 },\n\t},\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.regs\t\t= ov7670_fmt_raw,\n\t\t.cmatrix\t= { 0, 0, 0, 0, 0, 0 },\n\t},\n};\n#define N_OV7670_FMTS ARRAY_SIZE(ov7670_formats)\n\n\n \n\n \nstatic struct regval_list ov7670_qcif_regs[] = {\n\t{ REG_COM3, COM3_SCALEEN|COM3_DCWEN },\n\t{ REG_COM3, COM3_DCWEN },\n\t{ REG_COM14, COM14_DCWEN | 0x01},\n\t{ 0x73, 0xf1 },\n\t{ 0xa2, 0x52 },\n\t{ 0x7b, 0x1c },\n\t{ 0x7c, 0x28 },\n\t{ 0x7d, 0x3c },\n\t{ 0x7f, 0x69 },\n\t{ REG_COM9, 0x38 },\n\t{ 0xa1, 0x0b },\n\t{ 0x74, 0x19 },\n\t{ 0x9a, 0x80 },\n\t{ 0x43, 0x14 },\n\t{ REG_COM13, 0xc0 },\n\t{ 0xff, 0xff },\n};\n\nstatic struct ov7670_win_size ov7670_win_sizes[] = {\n\t \n\t{\n\t\t.width\t\t= VGA_WIDTH,\n\t\t.height\t\t= VGA_HEIGHT,\n\t\t.com7_bit\t= COM7_FMT_VGA,\n\t\t.hstart\t\t= 158,\t \n\t\t.hstop\t\t=  14,\t \n\t\t.vstart\t\t=  10,\n\t\t.vstop\t\t= 490,\n\t\t.regs\t\t= NULL,\n\t},\n\t \n\t{\n\t\t.width\t\t= CIF_WIDTH,\n\t\t.height\t\t= CIF_HEIGHT,\n\t\t.com7_bit\t= COM7_FMT_CIF,\n\t\t.hstart\t\t= 170,\t \n\t\t.hstop\t\t=  90,\n\t\t.vstart\t\t=  14,\n\t\t.vstop\t\t= 494,\n\t\t.regs\t\t= NULL,\n\t},\n\t \n\t{\n\t\t.width\t\t= QVGA_WIDTH,\n\t\t.height\t\t= QVGA_HEIGHT,\n\t\t.com7_bit\t= COM7_FMT_QVGA,\n\t\t.hstart\t\t= 168,\t \n\t\t.hstop\t\t=  24,\n\t\t.vstart\t\t=  12,\n\t\t.vstop\t\t= 492,\n\t\t.regs\t\t= NULL,\n\t},\n\t \n\t{\n\t\t.width\t\t= QCIF_WIDTH,\n\t\t.height\t\t= QCIF_HEIGHT,\n\t\t.com7_bit\t= COM7_FMT_VGA,  \n\t\t.hstart\t\t= 456,\t \n\t\t.hstop\t\t=  24,\n\t\t.vstart\t\t=  14,\n\t\t.vstop\t\t= 494,\n\t\t.regs\t\t= ov7670_qcif_regs,\n\t}\n};\n\nstatic struct ov7670_win_size ov7675_win_sizes[] = {\n\t \n\t{\n\t\t.width\t\t= VGA_WIDTH,\n\t\t.height\t\t= VGA_HEIGHT,\n\t\t.com7_bit\t= COM7_FMT_VGA,\n\t\t.hstart\t\t= 158,\t \n\t\t.hstop\t\t=  14,\t \n\t\t.vstart\t\t=  14,   \n\t\t.vstop\t\t= 494,\n\t\t.regs\t\t= NULL,\n\t}\n};\n\nstatic void ov7675_get_framerate(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_fract *tpf)\n{\n\tstruct ov7670_info *info = to_state(sd);\n\tu32 clkrc = info->clkrc;\n\tint pll_factor;\n\n\tif (info->pll_bypass)\n\t\tpll_factor = 1;\n\telse\n\t\tpll_factor = PLL_FACTOR;\n\n\tclkrc++;\n\tif (info->fmt->mbus_code == MEDIA_BUS_FMT_SBGGR8_1X8)\n\t\tclkrc = (clkrc >> 1);\n\n\ttpf->numerator = 1;\n\ttpf->denominator = (5 * pll_factor * info->clock_speed) /\n\t\t\t(4 * clkrc);\n}\n\nstatic int ov7675_apply_framerate(struct v4l2_subdev *sd)\n{\n\tstruct ov7670_info *info = to_state(sd);\n\tint ret;\n\n\tret = ov7670_write(sd, REG_CLKRC, info->clkrc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ov7670_write(sd, REG_DBLV,\n\t\t\t    info->pll_bypass ? DBLV_BYPASS : DBLV_X4);\n}\n\nstatic int ov7675_set_framerate(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_fract *tpf)\n{\n\tstruct ov7670_info *info = to_state(sd);\n\tu32 clkrc;\n\tint pll_factor;\n\n\t \n\tif (tpf->numerator == 0 || tpf->denominator == 0) {\n\t\tclkrc = 0;\n\t} else {\n\t\tpll_factor = info->pll_bypass ? 1 : PLL_FACTOR;\n\t\tclkrc = (5 * pll_factor * info->clock_speed * tpf->numerator) /\n\t\t\t(4 * tpf->denominator);\n\t\tif (info->fmt->mbus_code == MEDIA_BUS_FMT_SBGGR8_1X8)\n\t\t\tclkrc = (clkrc << 1);\n\t\tclkrc--;\n\t}\n\n\t \n\tif (clkrc <= 0)\n\t\tclkrc = CLK_EXT;\n\telse if (clkrc > CLK_SCALE)\n\t\tclkrc = CLK_SCALE;\n\tinfo->clkrc = clkrc;\n\n\t \n\tov7675_get_framerate(sd, tpf);\n\n\t \n\tif (info->on)\n\t\treturn ov7675_apply_framerate(sd);\n\n\treturn 0;\n}\n\nstatic void ov7670_get_framerate_legacy(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_fract *tpf)\n{\n\tstruct ov7670_info *info = to_state(sd);\n\n\ttpf->numerator = 1;\n\ttpf->denominator = info->clock_speed;\n\tif ((info->clkrc & CLK_EXT) == 0 && (info->clkrc & CLK_SCALE) > 1)\n\t\ttpf->denominator /= (info->clkrc & CLK_SCALE);\n}\n\nstatic int ov7670_set_framerate_legacy(struct v4l2_subdev *sd,\n\t\t\t\t\tstruct v4l2_fract *tpf)\n{\n\tstruct ov7670_info *info = to_state(sd);\n\tint div;\n\n\tif (tpf->numerator == 0 || tpf->denominator == 0)\n\t\tdiv = 1;   \n\telse\n\t\tdiv = (tpf->numerator * info->clock_speed) / tpf->denominator;\n\tif (div == 0)\n\t\tdiv = 1;\n\telse if (div > CLK_SCALE)\n\t\tdiv = CLK_SCALE;\n\tinfo->clkrc = (info->clkrc & 0x80) | div;\n\ttpf->numerator = 1;\n\ttpf->denominator = info->clock_speed / div;\n\n\t \n\tif (info->on)\n\t\treturn ov7670_write(sd, REG_CLKRC, info->clkrc);\n\n\treturn 0;\n}\n\n \nstatic int ov7670_set_hw(struct v4l2_subdev *sd, int hstart, int hstop,\n\t\tint vstart, int vstop)\n{\n\tint ret;\n\tunsigned char v;\n\t \n\tret = ov7670_write(sd, REG_HSTART, (hstart >> 3) & 0xff);\n\tif (ret)\n\t\treturn ret;\n\tret = ov7670_write(sd, REG_HSTOP, (hstop >> 3) & 0xff);\n\tif (ret)\n\t\treturn ret;\n\tret = ov7670_read(sd, REG_HREF, &v);\n\tif (ret)\n\t\treturn ret;\n\tv = (v & 0xc0) | ((hstop & 0x7) << 3) | (hstart & 0x7);\n\tmsleep(10);\n\tret = ov7670_write(sd, REG_HREF, v);\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = ov7670_write(sd, REG_VSTART, (vstart >> 2) & 0xff);\n\tif (ret)\n\t\treturn ret;\n\tret = ov7670_write(sd, REG_VSTOP, (vstop >> 2) & 0xff);\n\tif (ret)\n\t\treturn ret;\n\tret = ov7670_read(sd, REG_VREF, &v);\n\tif (ret)\n\t\treturn ret;\n\tv = (v & 0xf0) | ((vstop & 0x3) << 2) | (vstart & 0x3);\n\tmsleep(10);\n\treturn ov7670_write(sd, REG_VREF, v);\n}\n\n\nstatic int ov7670_enum_mbus_code(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index >= N_OV7670_FMTS)\n\t\treturn -EINVAL;\n\n\tcode->code = ov7670_formats[code->index].mbus_code;\n\treturn 0;\n}\n\nstatic int ov7670_try_fmt_internal(struct v4l2_subdev *sd,\n\t\tstruct v4l2_mbus_framefmt *fmt,\n\t\tstruct ov7670_format_struct **ret_fmt,\n\t\tstruct ov7670_win_size **ret_wsize)\n{\n\tint index, i;\n\tstruct ov7670_win_size *wsize;\n\tstruct ov7670_info *info = to_state(sd);\n\tunsigned int n_win_sizes = info->devtype->n_win_sizes;\n\tunsigned int win_sizes_limit = n_win_sizes;\n\n\tfor (index = 0; index < N_OV7670_FMTS; index++)\n\t\tif (ov7670_formats[index].mbus_code == fmt->code)\n\t\t\tbreak;\n\tif (index >= N_OV7670_FMTS) {\n\t\t \n\t\tindex = 0;\n\t\tfmt->code = ov7670_formats[0].mbus_code;\n\t}\n\tif (ret_fmt != NULL)\n\t\t*ret_fmt = ov7670_formats + index;\n\t \n\tfmt->field = V4L2_FIELD_NONE;\n\n\t \n\tif (info->min_width || info->min_height)\n\t\tfor (i = 0; i < n_win_sizes; i++) {\n\t\t\twsize = info->devtype->win_sizes + i;\n\n\t\t\tif (wsize->width < info->min_width ||\n\t\t\t\twsize->height < info->min_height) {\n\t\t\t\twin_sizes_limit = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t \n\tfor (wsize = info->devtype->win_sizes;\n\t     wsize < info->devtype->win_sizes + win_sizes_limit; wsize++)\n\t\tif (fmt->width >= wsize->width && fmt->height >= wsize->height)\n\t\t\tbreak;\n\tif (wsize >= info->devtype->win_sizes + win_sizes_limit)\n\t\twsize--;    \n\tif (ret_wsize != NULL)\n\t\t*ret_wsize = wsize;\n\t \n\tfmt->width = wsize->width;\n\tfmt->height = wsize->height;\n\tfmt->colorspace = ov7670_formats[index].colorspace;\n\n\tinfo->format = *fmt;\n\n\treturn 0;\n}\n\nstatic int ov7670_apply_fmt(struct v4l2_subdev *sd)\n{\n\tstruct ov7670_info *info = to_state(sd);\n\tstruct ov7670_win_size *wsize = info->wsize;\n\tunsigned char com7, com10 = 0;\n\tint ret;\n\n\t \n\tcom7 = info->fmt->regs[0].value;\n\tcom7 |= wsize->com7_bit;\n\tret = ov7670_write(sd, REG_COM7, com7);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (info->mbus_config & V4L2_MBUS_VSYNC_ACTIVE_LOW)\n\t\tcom10 |= COM10_VS_NEG;\n\tif (info->mbus_config & V4L2_MBUS_HSYNC_ACTIVE_LOW)\n\t\tcom10 |= COM10_HREF_REV;\n\tif (info->pclk_hb_disable)\n\t\tcom10 |= COM10_PCLK_HB;\n\tret = ov7670_write(sd, REG_COM10, com10);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov7670_write_array(sd, info->fmt->regs + 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov7670_set_hw(sd, wsize->hstart, wsize->hstop, wsize->vstart,\n\t\t\t    wsize->vstop);\n\tif (ret)\n\t\treturn ret;\n\n\tif (wsize->regs) {\n\t\tret = ov7670_write_array(sd, wsize->regs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = ov7670_write(sd, REG_CLKRC, info->clkrc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int ov7670_set_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct ov7670_info *info = to_state(sd);\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\n\tstruct v4l2_mbus_framefmt *mbus_fmt;\n#endif\n\tint ret;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tret = ov7670_try_fmt_internal(sd, &format->format, NULL, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\n\t\tmbus_fmt = v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t\t      format->pad);\n\t\t*mbus_fmt = format->format;\n#endif\n\t\treturn 0;\n\t}\n\n\tret = ov7670_try_fmt_internal(sd, &format->format, &info->fmt, &info->wsize);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (info->on)\n\t\treturn ov7670_apply_fmt(sd);\n\n\treturn 0;\n}\n\nstatic int ov7670_get_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct ov7670_info *info = to_state(sd);\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\n\tstruct v4l2_mbus_framefmt *mbus_fmt;\n#endif\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\n\t\tmbus_fmt = v4l2_subdev_get_try_format(sd, sd_state, 0);\n\t\tformat->format = *mbus_fmt;\n\t\treturn 0;\n#else\n\t\treturn -EINVAL;\n#endif\n\t} else {\n\t\tformat->format = info->format;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ov7670_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *ival)\n{\n\tstruct ov7670_info *info = to_state(sd);\n\n\n\tinfo->devtype->get_framerate(sd, &ival->interval);\n\n\treturn 0;\n}\n\nstatic int ov7670_s_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *ival)\n{\n\tstruct v4l2_fract *tpf = &ival->interval;\n\tstruct ov7670_info *info = to_state(sd);\n\n\n\treturn info->devtype->set_framerate(sd, tpf);\n}\n\n\n \n\nstatic int ov7670_frame_rates[] = { 30, 15, 10, 5, 1 };\n\nstatic int ov7670_enum_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t\t      struct v4l2_subdev_frame_interval_enum *fie)\n{\n\tstruct ov7670_info *info = to_state(sd);\n\tunsigned int n_win_sizes = info->devtype->n_win_sizes;\n\tint i;\n\n\tif (fie->pad)\n\t\treturn -EINVAL;\n\tif (fie->index >= ARRAY_SIZE(ov7670_frame_rates))\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < n_win_sizes; i++) {\n\t\tstruct ov7670_win_size *win = &info->devtype->win_sizes[i];\n\n\t\tif (info->min_width && win->width < info->min_width)\n\t\t\tcontinue;\n\t\tif (info->min_height && win->height < info->min_height)\n\t\t\tcontinue;\n\t\tif (fie->width == win->width && fie->height == win->height)\n\t\t\tbreak;\n\t}\n\tif (i == n_win_sizes)\n\t\treturn -EINVAL;\n\tfie->interval.numerator = 1;\n\tfie->interval.denominator = ov7670_frame_rates[fie->index];\n\treturn 0;\n}\n\n \nstatic int ov7670_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct ov7670_info *info = to_state(sd);\n\tint i;\n\tint num_valid = -1;\n\t__u32 index = fse->index;\n\tunsigned int n_win_sizes = info->devtype->n_win_sizes;\n\n\tif (fse->pad)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < n_win_sizes; i++) {\n\t\tstruct ov7670_win_size *win = &info->devtype->win_sizes[i];\n\n\t\tif (info->min_width && win->width < info->min_width)\n\t\t\tcontinue;\n\t\tif (info->min_height && win->height < info->min_height)\n\t\t\tcontinue;\n\t\tif (index == ++num_valid) {\n\t\t\tfse->min_width = fse->max_width = win->width;\n\t\t\tfse->min_height = fse->max_height = win->height;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n \n\nstatic int ov7670_store_cmatrix(struct v4l2_subdev *sd,\n\t\tint matrix[CMATRIX_LEN])\n{\n\tint i, ret;\n\tunsigned char signbits = 0;\n\n\t \n\tret = ov7670_read(sd, REG_CMATRIX_SIGN, &signbits);\n\tsignbits &= 0xc0;\n\n\tfor (i = 0; i < CMATRIX_LEN; i++) {\n\t\tunsigned char raw;\n\n\t\tif (matrix[i] < 0) {\n\t\t\tsignbits |= (1 << i);\n\t\t\tif (matrix[i] < -255)\n\t\t\t\traw = 0xff;\n\t\t\telse\n\t\t\t\traw = (-1 * matrix[i]) & 0xff;\n\t\t} else {\n\t\t\tif (matrix[i] > 255)\n\t\t\t\traw = 0xff;\n\t\t\telse\n\t\t\t\traw = matrix[i] & 0xff;\n\t\t}\n\t\tret = ov7670_write(sd, REG_CMATRIX_BASE + i, raw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn ov7670_write(sd, REG_CMATRIX_SIGN, signbits);\n}\n\n\n \n#define SIN_STEP 5\nstatic const int ov7670_sin_table[] = {\n\t   0,\t 87,   173,   258,   342,   422,\n\t 499,\t573,   642,   707,   766,   819,\n\t 866,\t906,   939,   965,   984,   996,\n\t1000\n};\n\nstatic int ov7670_sine(int theta)\n{\n\tint chs = 1;\n\tint sine;\n\n\tif (theta < 0) {\n\t\ttheta = -theta;\n\t\tchs = -1;\n\t}\n\tif (theta <= 90)\n\t\tsine = ov7670_sin_table[theta/SIN_STEP];\n\telse {\n\t\ttheta -= 90;\n\t\tsine = 1000 - ov7670_sin_table[theta/SIN_STEP];\n\t}\n\treturn sine*chs;\n}\n\nstatic int ov7670_cosine(int theta)\n{\n\ttheta = 90 - theta;\n\tif (theta > 180)\n\t\ttheta -= 360;\n\telse if (theta < -180)\n\t\ttheta += 360;\n\treturn ov7670_sine(theta);\n}\n\n\n\n\nstatic void ov7670_calc_cmatrix(struct ov7670_info *info,\n\t\tint matrix[CMATRIX_LEN], int sat, int hue)\n{\n\tint i;\n\t \n\tfor (i = 0; i < CMATRIX_LEN; i++)\n\t\tmatrix[i] = (info->fmt->cmatrix[i] * sat) >> 7;\n\t \n\tif (hue != 0) {\n\t\tint sinth, costh, tmpmatrix[CMATRIX_LEN];\n\n\t\tmemcpy(tmpmatrix, matrix, CMATRIX_LEN*sizeof(int));\n\t\tsinth = ov7670_sine(hue);\n\t\tcosth = ov7670_cosine(hue);\n\n\t\tmatrix[0] = (matrix[3]*sinth + matrix[0]*costh)/1000;\n\t\tmatrix[1] = (matrix[4]*sinth + matrix[1]*costh)/1000;\n\t\tmatrix[2] = (matrix[5]*sinth + matrix[2]*costh)/1000;\n\t\tmatrix[3] = (matrix[3]*costh - matrix[0]*sinth)/1000;\n\t\tmatrix[4] = (matrix[4]*costh - matrix[1]*sinth)/1000;\n\t\tmatrix[5] = (matrix[5]*costh - matrix[2]*sinth)/1000;\n\t}\n}\n\n\n\nstatic int ov7670_s_sat_hue(struct v4l2_subdev *sd, int sat, int hue)\n{\n\tstruct ov7670_info *info = to_state(sd);\n\tint matrix[CMATRIX_LEN];\n\n\tov7670_calc_cmatrix(info, matrix, sat, hue);\n\treturn ov7670_store_cmatrix(sd, matrix);\n}\n\n\n \n\nstatic unsigned char ov7670_abs_to_sm(unsigned char v)\n{\n\tif (v > 127)\n\t\treturn v & 0x7f;\n\treturn (128 - v) | 0x80;\n}\n\nstatic int ov7670_s_brightness(struct v4l2_subdev *sd, int value)\n{\n\tunsigned char com8 = 0, v;\n\n\tov7670_read(sd, REG_COM8, &com8);\n\tcom8 &= ~COM8_AEC;\n\tov7670_write(sd, REG_COM8, com8);\n\tv = ov7670_abs_to_sm(value);\n\treturn ov7670_write(sd, REG_BRIGHT, v);\n}\n\nstatic int ov7670_s_contrast(struct v4l2_subdev *sd, int value)\n{\n\treturn ov7670_write(sd, REG_CONTRAS, (unsigned char) value);\n}\n\nstatic int ov7670_s_hflip(struct v4l2_subdev *sd, int value)\n{\n\tunsigned char v = 0;\n\tint ret;\n\n\tret = ov7670_read(sd, REG_MVFP, &v);\n\tif (ret)\n\t\treturn ret;\n\tif (value)\n\t\tv |= MVFP_MIRROR;\n\telse\n\t\tv &= ~MVFP_MIRROR;\n\tmsleep(10);   \n\treturn ov7670_write(sd, REG_MVFP, v);\n}\n\nstatic int ov7670_s_vflip(struct v4l2_subdev *sd, int value)\n{\n\tunsigned char v = 0;\n\tint ret;\n\n\tret = ov7670_read(sd, REG_MVFP, &v);\n\tif (ret)\n\t\treturn ret;\n\tif (value)\n\t\tv |= MVFP_FLIP;\n\telse\n\t\tv &= ~MVFP_FLIP;\n\tmsleep(10);   \n\treturn ov7670_write(sd, REG_MVFP, v);\n}\n\n \nstatic int ov7670_g_gain(struct v4l2_subdev *sd, __s32 *value)\n{\n\tint ret;\n\tunsigned char gain;\n\n\tret = ov7670_read(sd, REG_GAIN, &gain);\n\tif (ret)\n\t\treturn ret;\n\t*value = gain;\n\treturn 0;\n}\n\nstatic int ov7670_s_gain(struct v4l2_subdev *sd, int value)\n{\n\tint ret;\n\tunsigned char com8;\n\n\tret = ov7670_write(sd, REG_GAIN, value & 0xff);\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = ov7670_read(sd, REG_COM8, &com8);\n\tif (ret)\n\t\treturn ret;\n\treturn ov7670_write(sd, REG_COM8, com8 & ~COM8_AGC);\n}\n\n \nstatic int ov7670_s_autogain(struct v4l2_subdev *sd, int value)\n{\n\tint ret;\n\tunsigned char com8;\n\n\tret = ov7670_read(sd, REG_COM8, &com8);\n\tif (ret == 0) {\n\t\tif (value)\n\t\t\tcom8 |= COM8_AGC;\n\t\telse\n\t\t\tcom8 &= ~COM8_AGC;\n\t\tret = ov7670_write(sd, REG_COM8, com8);\n\t}\n\treturn ret;\n}\n\nstatic int ov7670_s_exp(struct v4l2_subdev *sd, int value)\n{\n\tint ret;\n\tunsigned char com1, com8, aech, aechh;\n\n\tret = ov7670_read(sd, REG_COM1, &com1) +\n\t\tov7670_read(sd, REG_COM8, &com8) +\n\t\tov7670_read(sd, REG_AECHH, &aechh);\n\tif (ret)\n\t\treturn ret;\n\n\tcom1 = (com1 & 0xfc) | (value & 0x03);\n\taech = (value >> 2) & 0xff;\n\taechh = (aechh & 0xc0) | ((value >> 10) & 0x3f);\n\tret = ov7670_write(sd, REG_COM1, com1) +\n\t\tov7670_write(sd, REG_AECH, aech) +\n\t\tov7670_write(sd, REG_AECHH, aechh);\n\t \n\tif (ret == 0)\n\t\tret = ov7670_write(sd, REG_COM8, com8 & ~COM8_AEC);\n\treturn ret;\n}\n\n \nstatic int ov7670_s_autoexp(struct v4l2_subdev *sd,\n\t\tenum v4l2_exposure_auto_type value)\n{\n\tint ret;\n\tunsigned char com8;\n\n\tret = ov7670_read(sd, REG_COM8, &com8);\n\tif (ret == 0) {\n\t\tif (value == V4L2_EXPOSURE_AUTO)\n\t\t\tcom8 |= COM8_AEC;\n\t\telse\n\t\t\tcom8 &= ~COM8_AEC;\n\t\tret = ov7670_write(sd, REG_COM8, com8);\n\t}\n\treturn ret;\n}\n\nstatic const char * const ov7670_test_pattern_menu[] = {\n\t\"No test output\",\n\t\"Shifting \\\"1\\\"\",\n\t\"8-bar color bar\",\n\t\"Fade to gray color bar\",\n};\n\nstatic int ov7670_s_test_pattern(struct v4l2_subdev *sd, int value)\n{\n\tint ret;\n\n\tret = ov7670_update_bits(sd, REG_SCALING_XSC, TEST_PATTTERN_0,\n\t\t\t\tvalue & BIT(0) ? TEST_PATTTERN_0 : 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov7670_update_bits(sd, REG_SCALING_YSC, TEST_PATTTERN_1,\n\t\t\t\tvalue & BIT(1) ? TEST_PATTTERN_1 : 0);\n}\n\nstatic int ov7670_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\tstruct ov7670_info *info = to_state(sd);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTOGAIN:\n\t\treturn ov7670_g_gain(sd, &info->gain->val);\n\t}\n\treturn -EINVAL;\n}\n\nstatic int ov7670_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\tstruct ov7670_info *info = to_state(sd);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\treturn ov7670_s_brightness(sd, ctrl->val);\n\tcase V4L2_CID_CONTRAST:\n\t\treturn ov7670_s_contrast(sd, ctrl->val);\n\tcase V4L2_CID_SATURATION:\n\t\treturn ov7670_s_sat_hue(sd,\n\t\t\t\tinfo->saturation->val, info->hue->val);\n\tcase V4L2_CID_VFLIP:\n\t\treturn ov7670_s_vflip(sd, ctrl->val);\n\tcase V4L2_CID_HFLIP:\n\t\treturn ov7670_s_hflip(sd, ctrl->val);\n\tcase V4L2_CID_AUTOGAIN:\n\t\t \n\t\tif (!ctrl->val) {\n\t\t\t \n\t\t\treturn ov7670_s_gain(sd, info->gain->val);\n\t\t}\n\t\treturn ov7670_s_autogain(sd, ctrl->val);\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\t \n\t\tif (ctrl->val == V4L2_EXPOSURE_MANUAL) {\n\t\t\t \n\t\t\treturn ov7670_s_exp(sd, info->exposure->val);\n\t\t}\n\t\treturn ov7670_s_autoexp(sd, ctrl->val);\n\tcase V4L2_CID_TEST_PATTERN:\n\t\treturn ov7670_s_test_pattern(sd, ctrl->val);\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct v4l2_ctrl_ops ov7670_ctrl_ops = {\n\t.s_ctrl = ov7670_s_ctrl,\n\t.g_volatile_ctrl = ov7670_g_volatile_ctrl,\n};\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int ov7670_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\n{\n\tunsigned char val = 0;\n\tint ret;\n\n\tret = ov7670_read(sd, reg->reg & 0xff, &val);\n\treg->val = val;\n\treg->size = 1;\n\treturn ret;\n}\n\nstatic int ov7670_s_register(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg)\n{\n\tov7670_write(sd, reg->reg & 0xff, reg->val & 0xff);\n\treturn 0;\n}\n#endif\n\nstatic void ov7670_power_on(struct v4l2_subdev *sd)\n{\n\tstruct ov7670_info *info = to_state(sd);\n\n\tif (info->on)\n\t\treturn;\n\n\tclk_prepare_enable(info->clk);\n\n\tif (info->pwdn_gpio)\n\t\tgpiod_set_value(info->pwdn_gpio, 0);\n\tif (info->resetb_gpio) {\n\t\tgpiod_set_value(info->resetb_gpio, 1);\n\t\tusleep_range(500, 1000);\n\t\tgpiod_set_value(info->resetb_gpio, 0);\n\t}\n\tif (info->pwdn_gpio || info->resetb_gpio || info->clk)\n\t\tusleep_range(3000, 5000);\n\n\tinfo->on = true;\n}\n\nstatic void ov7670_power_off(struct v4l2_subdev *sd)\n{\n\tstruct ov7670_info *info = to_state(sd);\n\n\tif (!info->on)\n\t\treturn;\n\n\tclk_disable_unprepare(info->clk);\n\n\tif (info->pwdn_gpio)\n\t\tgpiod_set_value(info->pwdn_gpio, 1);\n\n\tinfo->on = false;\n}\n\nstatic int ov7670_s_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct ov7670_info *info = to_state(sd);\n\n\tif (info->on == on)\n\t\treturn 0;\n\n\tif (on) {\n\t\tov7670_power_on(sd);\n\t\tov7670_init(sd, 0);\n\t\tov7670_apply_fmt(sd);\n\t\tov7675_apply_framerate(sd);\n\t\tv4l2_ctrl_handler_setup(&info->hdl);\n\t} else {\n\t\tov7670_power_off(sd);\n\t}\n\n\treturn 0;\n}\n\nstatic void ov7670_get_default_format(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_mbus_framefmt *format)\n{\n\tstruct ov7670_info *info = to_state(sd);\n\n\tformat->width = info->devtype->win_sizes[0].width;\n\tformat->height = info->devtype->win_sizes[0].height;\n\tformat->colorspace = info->fmt->colorspace;\n\tformat->code = info->fmt->mbus_code;\n\tformat->field = V4L2_FIELD_NONE;\n}\n\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\nstatic int ov7670_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_mbus_framefmt *format =\n\t\t\t\tv4l2_subdev_get_try_format(sd, fh->state, 0);\n\n\tov7670_get_default_format(sd, format);\n\n\treturn 0;\n}\n#endif\n\n \n\nstatic const struct v4l2_subdev_core_ops ov7670_core_ops = {\n\t.reset = ov7670_reset,\n\t.init = ov7670_init,\n\t.s_power = ov7670_s_power,\n\t.log_status = v4l2_ctrl_subdev_log_status,\n\t.subscribe_event = v4l2_ctrl_subdev_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = ov7670_g_register,\n\t.s_register = ov7670_s_register,\n#endif\n};\n\nstatic const struct v4l2_subdev_video_ops ov7670_video_ops = {\n\t.s_frame_interval = ov7670_s_frame_interval,\n\t.g_frame_interval = ov7670_g_frame_interval,\n};\n\nstatic const struct v4l2_subdev_pad_ops ov7670_pad_ops = {\n\t.enum_frame_interval = ov7670_enum_frame_interval,\n\t.enum_frame_size = ov7670_enum_frame_size,\n\t.enum_mbus_code = ov7670_enum_mbus_code,\n\t.get_fmt = ov7670_get_fmt,\n\t.set_fmt = ov7670_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops ov7670_ops = {\n\t.core = &ov7670_core_ops,\n\t.video = &ov7670_video_ops,\n\t.pad = &ov7670_pad_ops,\n};\n\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\nstatic const struct v4l2_subdev_internal_ops ov7670_subdev_internal_ops = {\n\t.open = ov7670_open,\n};\n#endif\n\n \n\nstatic const struct ov7670_devtype ov7670_devdata[] = {\n\t[MODEL_OV7670] = {\n\t\t.win_sizes = ov7670_win_sizes,\n\t\t.n_win_sizes = ARRAY_SIZE(ov7670_win_sizes),\n\t\t.set_framerate = ov7670_set_framerate_legacy,\n\t\t.get_framerate = ov7670_get_framerate_legacy,\n\t},\n\t[MODEL_OV7675] = {\n\t\t.win_sizes = ov7675_win_sizes,\n\t\t.n_win_sizes = ARRAY_SIZE(ov7675_win_sizes),\n\t\t.set_framerate = ov7675_set_framerate,\n\t\t.get_framerate = ov7675_get_framerate,\n\t},\n};\n\nstatic int ov7670_init_gpio(struct i2c_client *client, struct ov7670_info *info)\n{\n\tinfo->pwdn_gpio = devm_gpiod_get_optional(&client->dev, \"powerdown\",\n\t\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(info->pwdn_gpio)) {\n\t\tdev_info(&client->dev, \"can't get %s GPIO\\n\", \"powerdown\");\n\t\treturn PTR_ERR(info->pwdn_gpio);\n\t}\n\n\tinfo->resetb_gpio = devm_gpiod_get_optional(&client->dev, \"reset\",\n\t\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(info->resetb_gpio)) {\n\t\tdev_info(&client->dev, \"can't get %s GPIO\\n\", \"reset\");\n\t\treturn PTR_ERR(info->resetb_gpio);\n\t}\n\n\tusleep_range(3000, 5000);\n\n\treturn 0;\n}\n\n \nstatic int ov7670_parse_dt(struct device *dev,\n\t\t\t   struct ov7670_info *info)\n{\n\tstruct fwnode_handle *fwnode = dev_fwnode(dev);\n\tstruct v4l2_fwnode_endpoint bus_cfg = { .bus_type = 0 };\n\tstruct fwnode_handle *ep;\n\tint ret;\n\n\tif (!fwnode)\n\t\treturn -EINVAL;\n\n\tinfo->pclk_hb_disable = false;\n\tif (fwnode_property_present(fwnode, \"ov7670,pclk-hb-disable\"))\n\t\tinfo->pclk_hb_disable = true;\n\n\tep = fwnode_graph_get_next_endpoint(fwnode, NULL);\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tret = v4l2_fwnode_endpoint_parse(ep, &bus_cfg);\n\tfwnode_handle_put(ep);\n\tif (ret)\n\t\treturn ret;\n\n\tif (bus_cfg.bus_type != V4L2_MBUS_PARALLEL) {\n\t\tdev_err(dev, \"Unsupported media bus type\\n\");\n\t\treturn -EINVAL;\n\t}\n\tinfo->mbus_config = bus_cfg.bus.parallel.flags;\n\n\treturn 0;\n}\n\nstatic int ov7670_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct v4l2_fract tpf;\n\tstruct v4l2_subdev *sd;\n\tstruct ov7670_info *info;\n\tint ret;\n\n\tinfo = devm_kzalloc(&client->dev, sizeof(*info), GFP_KERNEL);\n\tif (info == NULL)\n\t\treturn -ENOMEM;\n\tsd = &info->sd;\n\tv4l2_i2c_subdev_init(sd, client, &ov7670_ops);\n\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\n\tsd->internal_ops = &ov7670_subdev_internal_ops;\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;\n#endif\n\n\tinfo->clock_speed = 30;  \n\n\tif (dev_fwnode(&client->dev)) {\n\t\tret = ov7670_parse_dt(&client->dev, info);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t} else if (client->dev.platform_data) {\n\t\tstruct ov7670_config *config = client->dev.platform_data;\n\n\t\t \n\t\tinfo->min_width = config->min_width;\n\t\tinfo->min_height = config->min_height;\n\t\tinfo->use_smbus = config->use_smbus;\n\n\t\tif (config->clock_speed)\n\t\t\tinfo->clock_speed = config->clock_speed;\n\n\t\tif (config->pll_bypass)\n\t\t\tinfo->pll_bypass = true;\n\n\t\tif (config->pclk_hb_disable)\n\t\t\tinfo->pclk_hb_disable = true;\n\t}\n\n\tinfo->clk = devm_clk_get_optional(&client->dev, \"xclk\");\n\tif (IS_ERR(info->clk))\n\t\treturn PTR_ERR(info->clk);\n\n\tret = ov7670_init_gpio(client, info);\n\tif (ret)\n\t\treturn ret;\n\n\tov7670_power_on(sd);\n\n\tif (info->clk) {\n\t\tinfo->clock_speed = clk_get_rate(info->clk) / 1000000;\n\t\tif (info->clock_speed < 10 || info->clock_speed > 48) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto power_off;\n\t\t}\n\t}\n\n\t \n\tret = ov7670_detect(sd);\n\tif (ret) {\n\t\tv4l_dbg(1, debug, client,\n\t\t\t\"chip found @ 0x%x (%s) is not an ov7670 chip.\\n\",\n\t\t\tclient->addr << 1, client->adapter->name);\n\t\tgoto power_off;\n\t}\n\tv4l_info(client, \"chip found @ 0x%02x (%s)\\n\",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tinfo->devtype = &ov7670_devdata[id->driver_data];\n\tinfo->fmt = &ov7670_formats[0];\n\tinfo->wsize = &info->devtype->win_sizes[0];\n\n\tov7670_get_default_format(sd, &info->format);\n\n\tinfo->clkrc = 0;\n\n\t \n\ttpf.numerator = 1;\n\ttpf.denominator = 30;\n\tinfo->devtype->set_framerate(sd, &tpf);\n\n\tv4l2_ctrl_handler_init(&info->hdl, 10);\n\tv4l2_ctrl_new_std(&info->hdl, &ov7670_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(&info->hdl, &ov7670_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 127, 1, 64);\n\tv4l2_ctrl_new_std(&info->hdl, &ov7670_ctrl_ops,\n\t\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(&info->hdl, &ov7670_ctrl_ops,\n\t\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\tinfo->saturation = v4l2_ctrl_new_std(&info->hdl, &ov7670_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 256, 1, 128);\n\tinfo->hue = v4l2_ctrl_new_std(&info->hdl, &ov7670_ctrl_ops,\n\t\t\tV4L2_CID_HUE, -180, 180, 5, 0);\n\tinfo->gain = v4l2_ctrl_new_std(&info->hdl, &ov7670_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, 0, 255, 1, 128);\n\tinfo->auto_gain = v4l2_ctrl_new_std(&info->hdl, &ov7670_ctrl_ops,\n\t\t\tV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\tinfo->exposure = v4l2_ctrl_new_std(&info->hdl, &ov7670_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE, 0, 65535, 1, 500);\n\tinfo->auto_exposure = v4l2_ctrl_new_std_menu(&info->hdl, &ov7670_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE_AUTO, V4L2_EXPOSURE_MANUAL, 0,\n\t\t\tV4L2_EXPOSURE_AUTO);\n\tv4l2_ctrl_new_std_menu_items(&info->hdl, &ov7670_ctrl_ops,\n\t\t\tV4L2_CID_TEST_PATTERN,\n\t\t\tARRAY_SIZE(ov7670_test_pattern_menu) - 1, 0, 0,\n\t\t\tov7670_test_pattern_menu);\n\tsd->ctrl_handler = &info->hdl;\n\tif (info->hdl.error) {\n\t\tret = info->hdl.error;\n\n\t\tgoto hdl_free;\n\t}\n\t \n\tv4l2_ctrl_auto_cluster(2, &info->auto_gain, 0, true);\n\tv4l2_ctrl_auto_cluster(2, &info->auto_exposure,\n\t\t\t       V4L2_EXPOSURE_MANUAL, false);\n\tv4l2_ctrl_cluster(2, &info->saturation);\n\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tinfo->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tinfo->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tret = media_entity_pads_init(&info->sd.entity, 1, &info->pad);\n\tif (ret < 0)\n\t\tgoto hdl_free;\n#endif\n\n\tv4l2_ctrl_handler_setup(&info->hdl);\n\n\tret = v4l2_async_register_subdev(&info->sd);\n\tif (ret < 0)\n\t\tgoto entity_cleanup;\n\n\tov7670_power_off(sd);\n\treturn 0;\n\nentity_cleanup:\n\tmedia_entity_cleanup(&info->sd.entity);\nhdl_free:\n\tv4l2_ctrl_handler_free(&info->hdl);\npower_off:\n\tov7670_power_off(sd);\n\treturn ret;\n}\n\nstatic void ov7670_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov7670_info *info = to_state(sd);\n\n\tv4l2_async_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(&info->hdl);\n\tmedia_entity_cleanup(&info->sd.entity);\n}\n\nstatic const struct i2c_device_id ov7670_id[] = {\n\t{ \"ov7670\", MODEL_OV7670 },\n\t{ \"ov7675\", MODEL_OV7675 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ov7670_id);\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id ov7670_of_match[] = {\n\t{ .compatible = \"ovti,ov7670\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ov7670_of_match);\n#endif\n\nstatic struct i2c_driver ov7670_driver = {\n\t.driver = {\n\t\t.name\t= \"ov7670\",\n\t\t.of_match_table = of_match_ptr(ov7670_of_match),\n\t},\n\t.probe\t\t= ov7670_probe,\n\t.remove\t\t= ov7670_remove,\n\t.id_table\t= ov7670_id,\n};\n\nmodule_i2c_driver(ov7670_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}