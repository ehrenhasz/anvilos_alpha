{
  "module_name": "adv7842.c",
  "hash_id": "f82130adb39065087033b64d9b571c8ba1bf545aef525e6cdd22edaba8f3553b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/adv7842.c",
  "human_readable_source": "\n \n\n \n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/videodev2.h>\n#include <linux/workqueue.h>\n#include <linux/v4l2-dv-timings.h>\n#include <linux/hdmi.h>\n#include <media/cec.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-dv-timings.h>\n#include <media/i2c/adv7842.h>\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"debug level (0-2)\");\n\nMODULE_DESCRIPTION(\"Analog Devices ADV7842 video decoder driver\");\nMODULE_AUTHOR(\"Hans Verkuil <hans.verkuil@cisco.com>\");\nMODULE_AUTHOR(\"Martin Bugge <marbugge@cisco.com>\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define ADV7842_fsc (28636360)\n\n#define ADV7842_RGB_OUT\t\t\t\t\t(1 << 1)\n\n#define ADV7842_OP_FORMAT_SEL_8BIT\t\t\t(0 << 0)\n#define ADV7842_OP_FORMAT_SEL_10BIT\t\t\t(1 << 0)\n#define ADV7842_OP_FORMAT_SEL_12BIT\t\t\t(2 << 0)\n\n#define ADV7842_OP_MODE_SEL_SDR_422\t\t\t(0 << 5)\n#define ADV7842_OP_MODE_SEL_DDR_422\t\t\t(1 << 5)\n#define ADV7842_OP_MODE_SEL_SDR_444\t\t\t(2 << 5)\n#define ADV7842_OP_MODE_SEL_DDR_444\t\t\t(3 << 5)\n#define ADV7842_OP_MODE_SEL_SDR_422_2X\t\t\t(4 << 5)\n#define ADV7842_OP_MODE_SEL_ADI_CM\t\t\t(5 << 5)\n\n#define ADV7842_OP_CH_SEL_GBR\t\t\t\t(0 << 5)\n#define ADV7842_OP_CH_SEL_GRB\t\t\t\t(1 << 5)\n#define ADV7842_OP_CH_SEL_BGR\t\t\t\t(2 << 5)\n#define ADV7842_OP_CH_SEL_RGB\t\t\t\t(3 << 5)\n#define ADV7842_OP_CH_SEL_BRG\t\t\t\t(4 << 5)\n#define ADV7842_OP_CH_SEL_RBG\t\t\t\t(5 << 5)\n\n#define ADV7842_OP_SWAP_CB_CR\t\t\t\t(1 << 0)\n\n#define ADV7842_MAX_ADDRS (3)\n\n \n\nstruct adv7842_format_info {\n\tu32 code;\n\tu8 op_ch_sel;\n\tbool rgb_out;\n\tbool swap_cb_cr;\n\tu8 op_format_sel;\n};\n\nstruct adv7842_state {\n\tstruct adv7842_platform_data pdata;\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pads[ADV7842_PAD_SOURCE + 1];\n\tstruct v4l2_ctrl_handler hdl;\n\tenum adv7842_mode mode;\n\tstruct v4l2_dv_timings timings;\n\tenum adv7842_vid_std_select vid_std_select;\n\n\tconst struct adv7842_format_info *format;\n\n\tv4l2_std_id norm;\n\tstruct {\n\t\tu8 edid[512];\n\t\tu32 blocks;\n\t\tu32 present;\n\t} hdmi_edid;\n\tstruct {\n\t\tu8 edid[128];\n\t\tu32 blocks;\n\t\tu32 present;\n\t} vga_edid;\n\tstruct v4l2_fract aspect_ratio;\n\tu32 rgb_quantization_range;\n\tbool is_cea_format;\n\tstruct delayed_work delayed_work_enable_hotplug;\n\tbool restart_stdi_once;\n\tbool hdmi_port_a;\n\n\t \n\tstruct i2c_client *i2c_sdp_io;\n\tstruct i2c_client *i2c_sdp;\n\tstruct i2c_client *i2c_cp;\n\tstruct i2c_client *i2c_vdp;\n\tstruct i2c_client *i2c_afe;\n\tstruct i2c_client *i2c_hdmi;\n\tstruct i2c_client *i2c_repeater;\n\tstruct i2c_client *i2c_edid;\n\tstruct i2c_client *i2c_infoframe;\n\tstruct i2c_client *i2c_cec;\n\tstruct i2c_client *i2c_avlink;\n\n\t \n\tstruct v4l2_ctrl *detect_tx_5v_ctrl;\n\tstruct v4l2_ctrl *analog_sampling_phase_ctrl;\n\tstruct v4l2_ctrl *free_run_color_ctrl_manual;\n\tstruct v4l2_ctrl *free_run_color_ctrl;\n\tstruct v4l2_ctrl *rgb_quantization_range_ctrl;\n\n\tstruct cec_adapter *cec_adap;\n\tu8   cec_addr[ADV7842_MAX_ADDRS];\n\tu8   cec_valid_addrs;\n\tbool cec_enabled_adap;\n};\n\n \nstatic const struct v4l2_dv_timings adv7842_timings_exceptions[] = {\n\tV4L2_DV_BT_CEA_1280X720P30,\n\t{ }\n};\n\nstatic bool adv7842_check_dv_timings(const struct v4l2_dv_timings *t, void *hdl)\n{\n\tint i;\n\n\tfor (i = 0; adv7842_timings_exceptions[i].bt.width; i++)\n\t\tif (v4l2_match_dv_timings(t, adv7842_timings_exceptions + i, 0, false))\n\t\t\treturn false;\n\treturn true;\n}\n\nstruct adv7842_video_standards {\n\tstruct v4l2_dv_timings timings;\n\tu8 vid_std;\n\tu8 v_freq;\n};\n\n \nstatic const struct adv7842_video_standards adv7842_prim_mode_comp[] = {\n\t \n\t{ V4L2_DV_BT_CEA_720X576P50, 0x0b, 0x00 },\n\t{ V4L2_DV_BT_CEA_1280X720P50, 0x19, 0x01 },\n\t{ V4L2_DV_BT_CEA_1280X720P60, 0x19, 0x00 },\n\t{ V4L2_DV_BT_CEA_1920X1080P24, 0x1e, 0x04 },\n\t{ V4L2_DV_BT_CEA_1920X1080P25, 0x1e, 0x03 },\n\t{ V4L2_DV_BT_CEA_1920X1080P30, 0x1e, 0x02 },\n\t{ V4L2_DV_BT_CEA_1920X1080P50, 0x1e, 0x01 },\n\t{ V4L2_DV_BT_CEA_1920X1080P60, 0x1e, 0x00 },\n\t \n\t{ },\n};\n\n \nstatic const struct adv7842_video_standards adv7842_prim_mode_gr[] = {\n\t{ V4L2_DV_BT_DMT_640X480P60, 0x08, 0x00 },\n\t{ V4L2_DV_BT_DMT_640X480P72, 0x09, 0x00 },\n\t{ V4L2_DV_BT_DMT_640X480P75, 0x0a, 0x00 },\n\t{ V4L2_DV_BT_DMT_640X480P85, 0x0b, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P56, 0x00, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P60, 0x01, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P72, 0x02, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P75, 0x03, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P85, 0x04, 0x00 },\n\t{ V4L2_DV_BT_DMT_1024X768P60, 0x0c, 0x00 },\n\t{ V4L2_DV_BT_DMT_1024X768P70, 0x0d, 0x00 },\n\t{ V4L2_DV_BT_DMT_1024X768P75, 0x0e, 0x00 },\n\t{ V4L2_DV_BT_DMT_1024X768P85, 0x0f, 0x00 },\n\t{ V4L2_DV_BT_DMT_1280X1024P60, 0x05, 0x00 },\n\t{ V4L2_DV_BT_DMT_1280X1024P75, 0x06, 0x00 },\n\t{ V4L2_DV_BT_DMT_1360X768P60, 0x12, 0x00 },\n\t{ V4L2_DV_BT_DMT_1366X768P60, 0x13, 0x00 },\n\t{ V4L2_DV_BT_DMT_1400X1050P60, 0x14, 0x00 },\n\t{ V4L2_DV_BT_DMT_1400X1050P75, 0x15, 0x00 },\n\t{ V4L2_DV_BT_DMT_1600X1200P60, 0x16, 0x00 },  \n\t \n\t{ V4L2_DV_BT_DMT_1680X1050P60, 0x18, 0x00 },\n\t{ V4L2_DV_BT_DMT_1920X1200P60_RB, 0x19, 0x00 },  \n\t{ },\n};\n\n \nstatic const struct adv7842_video_standards adv7842_prim_mode_hdmi_comp[] = {\n\t{ V4L2_DV_BT_CEA_720X480P59_94, 0x0a, 0x00 },\n\t{ V4L2_DV_BT_CEA_720X576P50, 0x0b, 0x00 },\n\t{ V4L2_DV_BT_CEA_1280X720P50, 0x13, 0x01 },\n\t{ V4L2_DV_BT_CEA_1280X720P60, 0x13, 0x00 },\n\t{ V4L2_DV_BT_CEA_1920X1080P24, 0x1e, 0x04 },\n\t{ V4L2_DV_BT_CEA_1920X1080P25, 0x1e, 0x03 },\n\t{ V4L2_DV_BT_CEA_1920X1080P30, 0x1e, 0x02 },\n\t{ V4L2_DV_BT_CEA_1920X1080P50, 0x1e, 0x01 },\n\t{ V4L2_DV_BT_CEA_1920X1080P60, 0x1e, 0x00 },\n\t{ },\n};\n\n \nstatic const struct adv7842_video_standards adv7842_prim_mode_hdmi_gr[] = {\n\t{ V4L2_DV_BT_DMT_640X480P60, 0x08, 0x00 },\n\t{ V4L2_DV_BT_DMT_640X480P72, 0x09, 0x00 },\n\t{ V4L2_DV_BT_DMT_640X480P75, 0x0a, 0x00 },\n\t{ V4L2_DV_BT_DMT_640X480P85, 0x0b, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P56, 0x00, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P60, 0x01, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P72, 0x02, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P75, 0x03, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P85, 0x04, 0x00 },\n\t{ V4L2_DV_BT_DMT_1024X768P60, 0x0c, 0x00 },\n\t{ V4L2_DV_BT_DMT_1024X768P70, 0x0d, 0x00 },\n\t{ V4L2_DV_BT_DMT_1024X768P75, 0x0e, 0x00 },\n\t{ V4L2_DV_BT_DMT_1024X768P85, 0x0f, 0x00 },\n\t{ V4L2_DV_BT_DMT_1280X1024P60, 0x05, 0x00 },\n\t{ V4L2_DV_BT_DMT_1280X1024P75, 0x06, 0x00 },\n\t{ },\n};\n\nstatic const struct v4l2_event adv7842_ev_fmt = {\n\t.type = V4L2_EVENT_SOURCE_CHANGE,\n\t.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,\n};\n\n \n\nstatic inline struct adv7842_state *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct adv7842_state, sd);\n}\n\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct adv7842_state, hdl)->sd;\n}\n\nstatic inline unsigned htotal(const struct v4l2_bt_timings *t)\n{\n\treturn V4L2_DV_BT_FRAME_WIDTH(t);\n}\n\nstatic inline unsigned vtotal(const struct v4l2_bt_timings *t)\n{\n\treturn V4L2_DV_BT_FRAME_HEIGHT(t);\n}\n\n\n \n\nstatic s32 adv_smbus_read_byte_data_check(struct i2c_client *client,\n\t\t\t\t\t  u8 command, bool check)\n{\n\tunion i2c_smbus_data data;\n\n\tif (!i2c_smbus_xfer(client->adapter, client->addr, client->flags,\n\t\t\t    I2C_SMBUS_READ, command,\n\t\t\t    I2C_SMBUS_BYTE_DATA, &data))\n\t\treturn data.byte;\n\tif (check)\n\t\tv4l_err(client, \"error reading %02x, %02x\\n\",\n\t\t\tclient->addr, command);\n\treturn -EIO;\n}\n\nstatic s32 adv_smbus_read_byte_data(struct i2c_client *client, u8 command)\n{\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tint ret = adv_smbus_read_byte_data_check(client, command, true);\n\n\t\tif (ret >= 0) {\n\t\t\tif (i)\n\t\t\t\tv4l_err(client, \"read ok after %d retries\\n\", i);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tv4l_err(client, \"read failed\\n\");\n\treturn -EIO;\n}\n\nstatic s32 adv_smbus_write_byte_data(struct i2c_client *client,\n\t\t\t\t     u8 command, u8 value)\n{\n\tunion i2c_smbus_data data;\n\tint err;\n\tint i;\n\n\tdata.byte = value;\n\tfor (i = 0; i < 3; i++) {\n\t\terr = i2c_smbus_xfer(client->adapter, client->addr,\n\t\t\t\t     client->flags,\n\t\t\t\t     I2C_SMBUS_WRITE, command,\n\t\t\t\t     I2C_SMBUS_BYTE_DATA, &data);\n\t\tif (!err)\n\t\t\tbreak;\n\t}\n\tif (err < 0)\n\t\tv4l_err(client, \"error writing %02x, %02x, %02x\\n\",\n\t\t\tclient->addr, command, value);\n\treturn err;\n}\n\nstatic void adv_smbus_write_byte_no_check(struct i2c_client *client,\n\t\t\t\t\t  u8 command, u8 value)\n{\n\tunion i2c_smbus_data data;\n\tdata.byte = value;\n\n\ti2c_smbus_xfer(client->adapter, client->addr,\n\t\t       client->flags,\n\t\t       I2C_SMBUS_WRITE, command,\n\t\t       I2C_SMBUS_BYTE_DATA, &data);\n}\n\n \n\nstatic inline int io_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn adv_smbus_read_byte_data(client, reg);\n}\n\nstatic inline int io_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn adv_smbus_write_byte_data(client, reg, val);\n}\n\nstatic inline int io_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\n{\n\treturn io_write(sd, reg, (io_read(sd, reg) & mask) | val);\n}\n\nstatic inline int io_write_clr_set(struct v4l2_subdev *sd,\n\t\t\t\t   u8 reg, u8 mask, u8 val)\n{\n\treturn io_write(sd, reg, (io_read(sd, reg) & ~mask) | val);\n}\n\nstatic inline int avlink_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_read_byte_data(state->i2c_avlink, reg);\n}\n\nstatic inline int avlink_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_write_byte_data(state->i2c_avlink, reg, val);\n}\n\nstatic inline int cec_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_read_byte_data(state->i2c_cec, reg);\n}\n\nstatic inline int cec_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_write_byte_data(state->i2c_cec, reg, val);\n}\n\nstatic inline int cec_write_clr_set(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\n{\n\treturn cec_write(sd, reg, (cec_read(sd, reg) & ~mask) | val);\n}\n\nstatic inline int infoframe_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_read_byte_data(state->i2c_infoframe, reg);\n}\n\nstatic inline int infoframe_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_write_byte_data(state->i2c_infoframe, reg, val);\n}\n\nstatic inline int sdp_io_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_read_byte_data(state->i2c_sdp_io, reg);\n}\n\nstatic inline int sdp_io_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_write_byte_data(state->i2c_sdp_io, reg, val);\n}\n\nstatic inline int sdp_io_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\n{\n\treturn sdp_io_write(sd, reg, (sdp_io_read(sd, reg) & mask) | val);\n}\n\nstatic inline int sdp_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_read_byte_data(state->i2c_sdp, reg);\n}\n\nstatic inline int sdp_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_write_byte_data(state->i2c_sdp, reg, val);\n}\n\nstatic inline int sdp_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\n{\n\treturn sdp_write(sd, reg, (sdp_read(sd, reg) & mask) | val);\n}\n\nstatic inline int afe_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_read_byte_data(state->i2c_afe, reg);\n}\n\nstatic inline int afe_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_write_byte_data(state->i2c_afe, reg, val);\n}\n\nstatic inline int afe_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\n{\n\treturn afe_write(sd, reg, (afe_read(sd, reg) & mask) | val);\n}\n\nstatic inline int rep_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_read_byte_data(state->i2c_repeater, reg);\n}\n\nstatic inline int rep_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_write_byte_data(state->i2c_repeater, reg, val);\n}\n\nstatic inline int rep_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\n{\n\treturn rep_write(sd, reg, (rep_read(sd, reg) & mask) | val);\n}\n\nstatic inline int edid_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_read_byte_data(state->i2c_edid, reg);\n}\n\nstatic inline int edid_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_write_byte_data(state->i2c_edid, reg, val);\n}\n\nstatic inline int hdmi_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_read_byte_data(state->i2c_hdmi, reg);\n}\n\nstatic inline int hdmi_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_write_byte_data(state->i2c_hdmi, reg, val);\n}\n\nstatic inline int hdmi_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\n{\n\treturn hdmi_write(sd, reg, (hdmi_read(sd, reg) & mask) | val);\n}\n\nstatic inline int cp_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_read_byte_data(state->i2c_cp, reg);\n}\n\nstatic inline int cp_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_write_byte_data(state->i2c_cp, reg, val);\n}\n\nstatic inline int cp_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\n{\n\treturn cp_write(sd, reg, (cp_read(sd, reg) & mask) | val);\n}\n\nstatic inline int vdp_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_read_byte_data(state->i2c_vdp, reg);\n}\n\nstatic inline int vdp_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn adv_smbus_write_byte_data(state->i2c_vdp, reg, val);\n}\n\nstatic void main_reset(struct v4l2_subdev *sd)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tv4l2_dbg(1, debug, sd, \"%s:\\n\", __func__);\n\n\tadv_smbus_write_byte_no_check(client, 0xff, 0x80);\n\n\tmdelay(5);\n}\n\n \n\nstatic const struct adv7842_format_info adv7842_formats[] = {\n\t{ MEDIA_BUS_FMT_RGB888_1X24, ADV7842_OP_CH_SEL_RGB, true, false,\n\t  ADV7842_OP_MODE_SEL_SDR_444 | ADV7842_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, ADV7842_OP_CH_SEL_RGB, false, false,\n\t  ADV7842_OP_MODE_SEL_SDR_422 | ADV7842_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, ADV7842_OP_CH_SEL_RGB, false, true,\n\t  ADV7842_OP_MODE_SEL_SDR_422 | ADV7842_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_YUYV10_2X10, ADV7842_OP_CH_SEL_RGB, false, false,\n\t  ADV7842_OP_MODE_SEL_SDR_422 | ADV7842_OP_FORMAT_SEL_10BIT },\n\t{ MEDIA_BUS_FMT_YVYU10_2X10, ADV7842_OP_CH_SEL_RGB, false, true,\n\t  ADV7842_OP_MODE_SEL_SDR_422 | ADV7842_OP_FORMAT_SEL_10BIT },\n\t{ MEDIA_BUS_FMT_YUYV12_2X12, ADV7842_OP_CH_SEL_RGB, false, false,\n\t  ADV7842_OP_MODE_SEL_SDR_422 | ADV7842_OP_FORMAT_SEL_12BIT },\n\t{ MEDIA_BUS_FMT_YVYU12_2X12, ADV7842_OP_CH_SEL_RGB, false, true,\n\t  ADV7842_OP_MODE_SEL_SDR_422 | ADV7842_OP_FORMAT_SEL_12BIT },\n\t{ MEDIA_BUS_FMT_UYVY8_1X16, ADV7842_OP_CH_SEL_RBG, false, false,\n\t  ADV7842_OP_MODE_SEL_SDR_422_2X | ADV7842_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_VYUY8_1X16, ADV7842_OP_CH_SEL_RBG, false, true,\n\t  ADV7842_OP_MODE_SEL_SDR_422_2X | ADV7842_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_YUYV8_1X16, ADV7842_OP_CH_SEL_RGB, false, false,\n\t  ADV7842_OP_MODE_SEL_SDR_422_2X | ADV7842_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_YVYU8_1X16, ADV7842_OP_CH_SEL_RGB, false, true,\n\t  ADV7842_OP_MODE_SEL_SDR_422_2X | ADV7842_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_UYVY10_1X20, ADV7842_OP_CH_SEL_RBG, false, false,\n\t  ADV7842_OP_MODE_SEL_SDR_422_2X | ADV7842_OP_FORMAT_SEL_10BIT },\n\t{ MEDIA_BUS_FMT_VYUY10_1X20, ADV7842_OP_CH_SEL_RBG, false, true,\n\t  ADV7842_OP_MODE_SEL_SDR_422_2X | ADV7842_OP_FORMAT_SEL_10BIT },\n\t{ MEDIA_BUS_FMT_YUYV10_1X20, ADV7842_OP_CH_SEL_RGB, false, false,\n\t  ADV7842_OP_MODE_SEL_SDR_422_2X | ADV7842_OP_FORMAT_SEL_10BIT },\n\t{ MEDIA_BUS_FMT_YVYU10_1X20, ADV7842_OP_CH_SEL_RGB, false, true,\n\t  ADV7842_OP_MODE_SEL_SDR_422_2X | ADV7842_OP_FORMAT_SEL_10BIT },\n\t{ MEDIA_BUS_FMT_UYVY12_1X24, ADV7842_OP_CH_SEL_RBG, false, false,\n\t  ADV7842_OP_MODE_SEL_SDR_422_2X | ADV7842_OP_FORMAT_SEL_12BIT },\n\t{ MEDIA_BUS_FMT_VYUY12_1X24, ADV7842_OP_CH_SEL_RBG, false, true,\n\t  ADV7842_OP_MODE_SEL_SDR_422_2X | ADV7842_OP_FORMAT_SEL_12BIT },\n\t{ MEDIA_BUS_FMT_YUYV12_1X24, ADV7842_OP_CH_SEL_RGB, false, false,\n\t  ADV7842_OP_MODE_SEL_SDR_422_2X | ADV7842_OP_FORMAT_SEL_12BIT },\n\t{ MEDIA_BUS_FMT_YVYU12_1X24, ADV7842_OP_CH_SEL_RGB, false, true,\n\t  ADV7842_OP_MODE_SEL_SDR_422_2X | ADV7842_OP_FORMAT_SEL_12BIT },\n};\n\nstatic const struct adv7842_format_info *\nadv7842_format_info(struct adv7842_state *state, u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(adv7842_formats); ++i) {\n\t\tif (adv7842_formats[i].code == code)\n\t\t\treturn &adv7842_formats[i];\n\t}\n\n\treturn NULL;\n}\n\n \n\nstatic inline bool is_analog_input(struct v4l2_subdev *sd)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn ((state->mode == ADV7842_MODE_RGB) ||\n\t\t(state->mode == ADV7842_MODE_COMP));\n}\n\nstatic inline bool is_digital_input(struct v4l2_subdev *sd)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\treturn state->mode == ADV7842_MODE_HDMI;\n}\n\nstatic const struct v4l2_dv_timings_cap adv7842_timings_cap_analog = {\n\t.type = V4L2_DV_BT_656_1120,\n\t \n\t.reserved = { 0 },\n\tV4L2_INIT_BT_TIMINGS(640, 1920, 350, 1200, 25000000, 170000000,\n\t\tV4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_DMT |\n\t\t\tV4L2_DV_BT_STD_GTF | V4L2_DV_BT_STD_CVT,\n\t\tV4L2_DV_BT_CAP_PROGRESSIVE | V4L2_DV_BT_CAP_REDUCED_BLANKING |\n\t\t\tV4L2_DV_BT_CAP_CUSTOM)\n};\n\nstatic const struct v4l2_dv_timings_cap adv7842_timings_cap_digital = {\n\t.type = V4L2_DV_BT_656_1120,\n\t \n\t.reserved = { 0 },\n\tV4L2_INIT_BT_TIMINGS(640, 1920, 350, 1200, 25000000, 225000000,\n\t\tV4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_DMT |\n\t\t\tV4L2_DV_BT_STD_GTF | V4L2_DV_BT_STD_CVT,\n\t\tV4L2_DV_BT_CAP_PROGRESSIVE | V4L2_DV_BT_CAP_REDUCED_BLANKING |\n\t\t\tV4L2_DV_BT_CAP_CUSTOM)\n};\n\nstatic inline const struct v4l2_dv_timings_cap *\nadv7842_get_dv_timings_cap(struct v4l2_subdev *sd)\n{\n\treturn is_digital_input(sd) ? &adv7842_timings_cap_digital :\n\t\t\t\t      &adv7842_timings_cap_analog;\n}\n\n \n\nstatic u16 adv7842_read_cable_det(struct v4l2_subdev *sd)\n{\n\tu8 reg = io_read(sd, 0x6f);\n\tu16 val = 0;\n\n\tif (reg & 0x02)\n\t\tval |= 1;  \n\tif (reg & 0x01)\n\t\tval |= 2;  \n\treturn val;\n}\n\nstatic void adv7842_delayed_work_enable_hotplug(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct adv7842_state *state = container_of(dwork,\n\t\t\tstruct adv7842_state, delayed_work_enable_hotplug);\n\tstruct v4l2_subdev *sd = &state->sd;\n\tint present = state->hdmi_edid.present;\n\tu8 mask = 0;\n\n\tv4l2_dbg(2, debug, sd, \"%s: enable hotplug on ports: 0x%x\\n\",\n\t\t\t__func__, present);\n\n\tif (present & (0x04 << ADV7842_EDID_PORT_A))\n\t\tmask |= 0x20;\n\tif (present & (0x04 << ADV7842_EDID_PORT_B))\n\t\tmask |= 0x10;\n\tio_write_and_or(sd, 0x20, 0xcf, mask);\n}\n\nstatic int edid_write_vga_segment(struct v4l2_subdev *sd)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct adv7842_state *state = to_state(sd);\n\tconst u8 *edid = state->vga_edid.edid;\n\tu32 blocks = state->vga_edid.blocks;\n\tint err = 0;\n\tint i;\n\n\tv4l2_dbg(2, debug, sd, \"%s: write EDID on VGA port\\n\", __func__);\n\n\tif (!state->vga_edid.present)\n\t\treturn 0;\n\n\t \n\tio_write_and_or(sd, 0x20, 0xcf, 0x00);\n\n\t \n\trep_write_and_or(sd, 0x7f, 0x7f, 0x00);\n\n\t \n\trep_write_and_or(sd, 0x77, 0xef, 0x10);\n\n\tfor (i = 0; !err && i < blocks * 128; i += I2C_SMBUS_BLOCK_MAX)\n\t\terr = i2c_smbus_write_i2c_block_data(state->i2c_edid, i,\n\t\t\t\t\t\t     I2C_SMBUS_BLOCK_MAX,\n\t\t\t\t\t\t     edid + i);\n\tif (err)\n\t\treturn err;\n\n\t \n\trep_write_and_or(sd, 0x7f, 0x7f, 0x80);\n\n\tfor (i = 0; i < 1000; i++) {\n\t\tif (rep_read(sd, 0x79) & 0x20)\n\t\t\tbreak;\n\t\tmdelay(1);\n\t}\n\tif (i == 1000) {\n\t\tv4l_err(client, \"error enabling edid on VGA port\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tschedule_delayed_work(&state->delayed_work_enable_hotplug, HZ / 5);\n\n\treturn 0;\n}\n\nstatic int edid_write_hdmi_segment(struct v4l2_subdev *sd, u8 port)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct adv7842_state *state = to_state(sd);\n\tconst u8 *edid = state->hdmi_edid.edid;\n\tu32 blocks = state->hdmi_edid.blocks;\n\tunsigned int spa_loc;\n\tu16 pa, parent_pa;\n\tint err = 0;\n\tint i;\n\n\tv4l2_dbg(2, debug, sd, \"%s: write EDID on port %c\\n\",\n\t\t\t__func__, (port == ADV7842_EDID_PORT_A) ? 'A' : 'B');\n\n\t \n\tio_write_and_or(sd, 0x20, 0xcf, 0x00);\n\n\t \n\trep_write_and_or(sd, 0x77, 0xf3, 0x00);\n\n\tif (!state->hdmi_edid.present) {\n\t\tcec_phys_addr_invalidate(state->cec_adap);\n\t\treturn 0;\n\t}\n\n\tpa = v4l2_get_edid_phys_addr(edid, blocks * 128, &spa_loc);\n\terr = v4l2_phys_addr_validate(pa, &parent_pa, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!spa_loc) {\n\t\t \n\t\tspa_loc = 128;\n\t\tpa = (edid[spa_loc] << 8) | edid[spa_loc + 1];\n\t}\n\n\n\tfor (i = 0; !err && i < blocks * 128; i += I2C_SMBUS_BLOCK_MAX) {\n\t\t \n\t\tif (i % 256 == 0)\n\t\t\trep_write_and_or(sd, 0x77, 0xef, i >= 256 ? 0x10 : 0x00);\n\t\terr = i2c_smbus_write_i2c_block_data(state->i2c_edid, i,\n\t\t\t\t\t\t     I2C_SMBUS_BLOCK_MAX, edid + i);\n\t}\n\tif (err)\n\t\treturn err;\n\n\tif (port == ADV7842_EDID_PORT_A) {\n\t\trep_write(sd, 0x72, pa >> 8);\n\t\trep_write(sd, 0x73, pa & 0xff);\n\t} else {\n\t\trep_write(sd, 0x74, pa >> 8);\n\t\trep_write(sd, 0x75, pa & 0xff);\n\t}\n\trep_write(sd, 0x76, spa_loc & 0xff);\n\trep_write_and_or(sd, 0x77, 0xbf, (spa_loc >> 2) & 0x40);\n\n\t \n\trep_write_and_or(sd, 0x77, 0xf3, state->hdmi_edid.present);\n\n\tfor (i = 0; i < 1000; i++) {\n\t\tif (rep_read(sd, 0x7d) & state->hdmi_edid.present)\n\t\t\tbreak;\n\t\tmdelay(1);\n\t}\n\tif (i == 1000) {\n\t\tv4l_err(client, \"error enabling edid on port %c\\n\",\n\t\t\t\t(port == ADV7842_EDID_PORT_A) ? 'A' : 'B');\n\t\treturn -EIO;\n\t}\n\tcec_s_phys_addr(state->cec_adap, parent_pa, false);\n\n\t \n\tschedule_delayed_work(&state->delayed_work_enable_hotplug, HZ / 5);\n\n\treturn 0;\n}\n\n \n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic void adv7842_inv_register(struct v4l2_subdev *sd)\n{\n\tv4l2_info(sd, \"0x000-0x0ff: IO Map\\n\");\n\tv4l2_info(sd, \"0x100-0x1ff: AVLink Map\\n\");\n\tv4l2_info(sd, \"0x200-0x2ff: CEC Map\\n\");\n\tv4l2_info(sd, \"0x300-0x3ff: InfoFrame Map\\n\");\n\tv4l2_info(sd, \"0x400-0x4ff: SDP_IO Map\\n\");\n\tv4l2_info(sd, \"0x500-0x5ff: SDP Map\\n\");\n\tv4l2_info(sd, \"0x600-0x6ff: AFE Map\\n\");\n\tv4l2_info(sd, \"0x700-0x7ff: Repeater Map\\n\");\n\tv4l2_info(sd, \"0x800-0x8ff: EDID Map\\n\");\n\tv4l2_info(sd, \"0x900-0x9ff: HDMI Map\\n\");\n\tv4l2_info(sd, \"0xa00-0xaff: CP Map\\n\");\n\tv4l2_info(sd, \"0xb00-0xbff: VDP Map\\n\");\n}\n\nstatic int adv7842_g_register(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_dbg_register *reg)\n{\n\treg->size = 1;\n\tswitch (reg->reg >> 8) {\n\tcase 0:\n\t\treg->val = io_read(sd, reg->reg & 0xff);\n\t\tbreak;\n\tcase 1:\n\t\treg->val = avlink_read(sd, reg->reg & 0xff);\n\t\tbreak;\n\tcase 2:\n\t\treg->val = cec_read(sd, reg->reg & 0xff);\n\t\tbreak;\n\tcase 3:\n\t\treg->val = infoframe_read(sd, reg->reg & 0xff);\n\t\tbreak;\n\tcase 4:\n\t\treg->val = sdp_io_read(sd, reg->reg & 0xff);\n\t\tbreak;\n\tcase 5:\n\t\treg->val = sdp_read(sd, reg->reg & 0xff);\n\t\tbreak;\n\tcase 6:\n\t\treg->val = afe_read(sd, reg->reg & 0xff);\n\t\tbreak;\n\tcase 7:\n\t\treg->val = rep_read(sd, reg->reg & 0xff);\n\t\tbreak;\n\tcase 8:\n\t\treg->val = edid_read(sd, reg->reg & 0xff);\n\t\tbreak;\n\tcase 9:\n\t\treg->val = hdmi_read(sd, reg->reg & 0xff);\n\t\tbreak;\n\tcase 0xa:\n\t\treg->val = cp_read(sd, reg->reg & 0xff);\n\t\tbreak;\n\tcase 0xb:\n\t\treg->val = vdp_read(sd, reg->reg & 0xff);\n\t\tbreak;\n\tdefault:\n\t\tv4l2_info(sd, \"Register %03llx not supported\\n\", reg->reg);\n\t\tadv7842_inv_register(sd);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int adv7842_s_register(struct v4l2_subdev *sd,\n\t\tconst struct v4l2_dbg_register *reg)\n{\n\tu8 val = reg->val & 0xff;\n\n\tswitch (reg->reg >> 8) {\n\tcase 0:\n\t\tio_write(sd, reg->reg & 0xff, val);\n\t\tbreak;\n\tcase 1:\n\t\tavlink_write(sd, reg->reg & 0xff, val);\n\t\tbreak;\n\tcase 2:\n\t\tcec_write(sd, reg->reg & 0xff, val);\n\t\tbreak;\n\tcase 3:\n\t\tinfoframe_write(sd, reg->reg & 0xff, val);\n\t\tbreak;\n\tcase 4:\n\t\tsdp_io_write(sd, reg->reg & 0xff, val);\n\t\tbreak;\n\tcase 5:\n\t\tsdp_write(sd, reg->reg & 0xff, val);\n\t\tbreak;\n\tcase 6:\n\t\tafe_write(sd, reg->reg & 0xff, val);\n\t\tbreak;\n\tcase 7:\n\t\trep_write(sd, reg->reg & 0xff, val);\n\t\tbreak;\n\tcase 8:\n\t\tedid_write(sd, reg->reg & 0xff, val);\n\t\tbreak;\n\tcase 9:\n\t\thdmi_write(sd, reg->reg & 0xff, val);\n\t\tbreak;\n\tcase 0xa:\n\t\tcp_write(sd, reg->reg & 0xff, val);\n\t\tbreak;\n\tcase 0xb:\n\t\tvdp_write(sd, reg->reg & 0xff, val);\n\t\tbreak;\n\tdefault:\n\t\tv4l2_info(sd, \"Register %03llx not supported\\n\", reg->reg);\n\t\tadv7842_inv_register(sd);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n#endif\n\nstatic int adv7842_s_detect_tx_5v_ctrl(struct v4l2_subdev *sd)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\tu16 cable_det = adv7842_read_cable_det(sd);\n\n\tv4l2_dbg(1, debug, sd, \"%s: 0x%x\\n\", __func__, cable_det);\n\n\treturn v4l2_ctrl_s_ctrl(state->detect_tx_5v_ctrl, cable_det);\n}\n\nstatic int find_and_set_predefined_video_timings(struct v4l2_subdev *sd,\n\t\tu8 prim_mode,\n\t\tconst struct adv7842_video_standards *predef_vid_timings,\n\t\tconst struct v4l2_dv_timings *timings)\n{\n\tint i;\n\n\tfor (i = 0; predef_vid_timings[i].timings.bt.width; i++) {\n\t\tif (!v4l2_match_dv_timings(timings, &predef_vid_timings[i].timings,\n\t\t\t\t  is_digital_input(sd) ? 250000 : 1000000, false))\n\t\t\tcontinue;\n\t\t \n\t\tio_write(sd, 0x00, predef_vid_timings[i].vid_std);\n\t\t \n\t\tio_write(sd, 0x01, (predef_vid_timings[i].v_freq << 4) + prim_mode);\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nstatic int configure_predefined_video_timings(struct v4l2_subdev *sd,\n\t\tstruct v4l2_dv_timings *timings)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\tint err;\n\n\tv4l2_dbg(1, debug, sd, \"%s\\n\", __func__);\n\n\t \n\tio_write(sd, 0x16, 0x43);\n\tio_write(sd, 0x17, 0x5a);\n\t \n\tcp_write_and_or(sd, 0x81, 0xef, 0x00);\n\tcp_write(sd, 0x26, 0x00);\n\tcp_write(sd, 0x27, 0x00);\n\tcp_write(sd, 0x28, 0x00);\n\tcp_write(sd, 0x29, 0x00);\n\tcp_write(sd, 0x8f, 0x40);\n\tcp_write(sd, 0x90, 0x00);\n\tcp_write(sd, 0xa5, 0x00);\n\tcp_write(sd, 0xa6, 0x00);\n\tcp_write(sd, 0xa7, 0x00);\n\tcp_write(sd, 0xab, 0x00);\n\tcp_write(sd, 0xac, 0x00);\n\n\tswitch (state->mode) {\n\tcase ADV7842_MODE_COMP:\n\tcase ADV7842_MODE_RGB:\n\t\terr = find_and_set_predefined_video_timings(sd,\n\t\t\t\t0x01, adv7842_prim_mode_comp, timings);\n\t\tif (err)\n\t\t\terr = find_and_set_predefined_video_timings(sd,\n\t\t\t\t\t0x02, adv7842_prim_mode_gr, timings);\n\t\tbreak;\n\tcase ADV7842_MODE_HDMI:\n\t\terr = find_and_set_predefined_video_timings(sd,\n\t\t\t\t0x05, adv7842_prim_mode_hdmi_comp, timings);\n\t\tif (err)\n\t\t\terr = find_and_set_predefined_video_timings(sd,\n\t\t\t\t\t0x06, adv7842_prim_mode_hdmi_gr, timings);\n\t\tbreak;\n\tdefault:\n\t\tv4l2_dbg(2, debug, sd, \"%s: Unknown mode %d\\n\",\n\t\t\t\t__func__, state->mode);\n\t\terr = -1;\n\t\tbreak;\n\t}\n\n\n\treturn err;\n}\n\nstatic void configure_custom_video_timings(struct v4l2_subdev *sd,\n\t\tconst struct v4l2_bt_timings *bt)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tu32 width = htotal(bt);\n\tu32 height = vtotal(bt);\n\tu16 cp_start_sav = bt->hsync + bt->hbackporch - 4;\n\tu16 cp_start_eav = width - bt->hfrontporch;\n\tu16 cp_start_vbi = height - bt->vfrontporch + 1;\n\tu16 cp_end_vbi = bt->vsync + bt->vbackporch + 1;\n\tu16 ch1_fr_ll = (((u32)bt->pixelclock / 100) > 0) ?\n\t\t((width * (ADV7842_fsc / 100)) / ((u32)bt->pixelclock / 100)) : 0;\n\tconst u8 pll[2] = {\n\t\t0xc0 | ((width >> 8) & 0x1f),\n\t\twidth & 0xff\n\t};\n\n\tv4l2_dbg(2, debug, sd, \"%s\\n\", __func__);\n\n\tswitch (state->mode) {\n\tcase ADV7842_MODE_COMP:\n\tcase ADV7842_MODE_RGB:\n\t\t \n\t\tio_write(sd, 0x00, 0x07);  \n\t\tio_write(sd, 0x01, 0x02);  \n\t\t \n\t\tcp_write_and_or(sd, 0x81, 0xef, 0x10);\n\n\t\t \n\t\t \n\t\t \n\t\tif (i2c_smbus_write_i2c_block_data(client, 0x16, 2, pll)) {\n\t\t\tv4l2_err(sd, \"writing to reg 0x16 and 0x17 failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tcp_write(sd, 0x26, (cp_start_sav >> 8) & 0xf);\n\t\tcp_write(sd, 0x27, (cp_start_sav & 0xff));\n\t\tcp_write(sd, 0x28, (cp_start_eav >> 8) & 0xf);\n\t\tcp_write(sd, 0x29, (cp_start_eav & 0xff));\n\n\t\t \n\t\tcp_write(sd, 0xa5, (cp_start_vbi >> 4) & 0xff);\n\t\tcp_write(sd, 0xa6, ((cp_start_vbi & 0xf) << 4) |\n\t\t\t\t\t((cp_end_vbi >> 8) & 0xf));\n\t\tcp_write(sd, 0xa7, cp_end_vbi & 0xff);\n\t\tbreak;\n\tcase ADV7842_MODE_HDMI:\n\t\t \n\t\tio_write(sd, 0x00, 0x02);  \n\t\tio_write(sd, 0x01, 0x06);  \n\t\tbreak;\n\tdefault:\n\t\tv4l2_dbg(2, debug, sd, \"%s: Unknown mode %d\\n\",\n\t\t\t\t__func__, state->mode);\n\t\tbreak;\n\t}\n\n\tcp_write(sd, 0x8f, (ch1_fr_ll >> 8) & 0x7);\n\tcp_write(sd, 0x90, ch1_fr_ll & 0xff);\n\tcp_write(sd, 0xab, (height >> 4) & 0xff);\n\tcp_write(sd, 0xac, (height & 0x0f) << 4);\n}\n\nstatic void adv7842_set_offset(struct v4l2_subdev *sd, bool auto_offset, u16 offset_a, u16 offset_b, u16 offset_c)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\tu8 offset_buf[4];\n\n\tif (auto_offset) {\n\t\toffset_a = 0x3ff;\n\t\toffset_b = 0x3ff;\n\t\toffset_c = 0x3ff;\n\t}\n\n\tv4l2_dbg(2, debug, sd, \"%s: %s offset: a = 0x%x, b = 0x%x, c = 0x%x\\n\",\n\t\t __func__, auto_offset ? \"Auto\" : \"Manual\",\n\t\t offset_a, offset_b, offset_c);\n\n\toffset_buf[0]= (cp_read(sd, 0x77) & 0xc0) | ((offset_a & 0x3f0) >> 4);\n\toffset_buf[1] = ((offset_a & 0x00f) << 4) | ((offset_b & 0x3c0) >> 6);\n\toffset_buf[2] = ((offset_b & 0x03f) << 2) | ((offset_c & 0x300) >> 8);\n\toffset_buf[3] = offset_c & 0x0ff;\n\n\t \n\tif (i2c_smbus_write_i2c_block_data(state->i2c_cp, 0x77, 4, offset_buf))\n\t\tv4l2_err(sd, \"%s: i2c error writing to CP reg 0x77, 0x78, 0x79, 0x7a\\n\", __func__);\n}\n\nstatic void adv7842_set_gain(struct v4l2_subdev *sd, bool auto_gain, u16 gain_a, u16 gain_b, u16 gain_c)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\tu8 gain_buf[4];\n\tu8 gain_man = 1;\n\tu8 agc_mode_man = 1;\n\n\tif (auto_gain) {\n\t\tgain_man = 0;\n\t\tagc_mode_man = 0;\n\t\tgain_a = 0x100;\n\t\tgain_b = 0x100;\n\t\tgain_c = 0x100;\n\t}\n\n\tv4l2_dbg(2, debug, sd, \"%s: %s gain: a = 0x%x, b = 0x%x, c = 0x%x\\n\",\n\t\t __func__, auto_gain ? \"Auto\" : \"Manual\",\n\t\t gain_a, gain_b, gain_c);\n\n\tgain_buf[0] = ((gain_man << 7) | (agc_mode_man << 6) | ((gain_a & 0x3f0) >> 4));\n\tgain_buf[1] = (((gain_a & 0x00f) << 4) | ((gain_b & 0x3c0) >> 6));\n\tgain_buf[2] = (((gain_b & 0x03f) << 2) | ((gain_c & 0x300) >> 8));\n\tgain_buf[3] = ((gain_c & 0x0ff));\n\n\t \n\tif (i2c_smbus_write_i2c_block_data(state->i2c_cp, 0x73, 4, gain_buf))\n\t\tv4l2_err(sd, \"%s: i2c error writing to CP reg 0x73, 0x74, 0x75, 0x76\\n\", __func__);\n}\n\nstatic void set_rgb_quantization_range(struct v4l2_subdev *sd)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\tbool rgb_output = io_read(sd, 0x02) & 0x02;\n\tbool hdmi_signal = hdmi_read(sd, 0x05) & 0x80;\n\tu8 y = HDMI_COLORSPACE_RGB;\n\n\tif (hdmi_signal && (io_read(sd, 0x60) & 1))\n\t\ty = infoframe_read(sd, 0x01) >> 5;\n\n\tv4l2_dbg(2, debug, sd, \"%s: RGB quantization range: %d, RGB out: %d, HDMI: %d\\n\",\n\t\t\t__func__, state->rgb_quantization_range,\n\t\t\trgb_output, hdmi_signal);\n\n\tadv7842_set_gain(sd, true, 0x0, 0x0, 0x0);\n\tadv7842_set_offset(sd, true, 0x0, 0x0, 0x0);\n\tio_write_clr_set(sd, 0x02, 0x04, rgb_output ? 0 : 4);\n\n\tswitch (state->rgb_quantization_range) {\n\tcase V4L2_DV_RGB_RANGE_AUTO:\n\t\tif (state->mode == ADV7842_MODE_RGB) {\n\t\t\t \n\t\t\tio_write_and_or(sd, 0x02, 0x0f, 0x10);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->mode == ADV7842_MODE_COMP) {\n\t\t\t \n\t\t\tio_write_and_or(sd, 0x02, 0x0f, 0xf0);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hdmi_signal) {\n\t\t\t \n\t\t\tio_write_and_or(sd, 0x02, 0x0f, 0xf0);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (state->timings.bt.flags & V4L2_DV_FL_IS_CE_VIDEO) {\n\t\t\t \n\t\t\tio_write_and_or(sd, 0x02, 0x0f, 0x00);\n\t\t} else {\n\t\t\t \n\t\t\tio_write_and_or(sd, 0x02, 0x0f, 0x10);\n\n\t\t\tif (is_digital_input(sd) && rgb_output) {\n\t\t\t\tadv7842_set_offset(sd, false, 0x40, 0x40, 0x40);\n\t\t\t} else {\n\t\t\t\tadv7842_set_gain(sd, false, 0xe0, 0xe0, 0xe0);\n\t\t\t\tadv7842_set_offset(sd, false, 0x70, 0x70, 0x70);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase V4L2_DV_RGB_RANGE_LIMITED:\n\t\tif (state->mode == ADV7842_MODE_COMP) {\n\t\t\t \n\t\t\tio_write_and_or(sd, 0x02, 0x0f, 0x20);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (y != HDMI_COLORSPACE_RGB)\n\t\t\tbreak;\n\n\t\t \n\t\tio_write_and_or(sd, 0x02, 0x0f, 0x00);\n\n\t\tbreak;\n\tcase V4L2_DV_RGB_RANGE_FULL:\n\t\tif (state->mode == ADV7842_MODE_COMP) {\n\t\t\t \n\t\t\tio_write_and_or(sd, 0x02, 0x0f, 0x60);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (y != HDMI_COLORSPACE_RGB)\n\t\t\tbreak;\n\n\t\t \n\t\tio_write_and_or(sd, 0x02, 0x0f, 0x10);\n\n\t\tif (is_analog_input(sd) || hdmi_signal)\n\t\t\tbreak;\n\n\t\t \n\t\tif (rgb_output) {\n\t\t\tadv7842_set_offset(sd, false, 0x40, 0x40, 0x40);\n\t\t} else {\n\t\t\tadv7842_set_gain(sd, false, 0xe0, 0xe0, 0xe0);\n\t\t\tadv7842_set_offset(sd, false, 0x70, 0x70, 0x70);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int adv7842_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\tstruct adv7842_state *state = to_state(sd);\n\n\t \n\tswitch (ctrl->id) {\n\t \n\tcase V4L2_CID_BRIGHTNESS:\n\t\tcp_write(sd, 0x3c, ctrl->val);\n\t\tsdp_write(sd, 0x14, ctrl->val);\n\t\t \n\t\treturn 0;\n\tcase V4L2_CID_CONTRAST:\n\t\tcp_write(sd, 0x3a, ctrl->val);\n\t\tsdp_write(sd, 0x13, ctrl->val);\n\t\t \n\t\treturn 0;\n\tcase V4L2_CID_SATURATION:\n\t\tcp_write(sd, 0x3b, ctrl->val);\n\t\tsdp_write(sd, 0x15, ctrl->val);\n\t\t \n\t\treturn 0;\n\tcase V4L2_CID_HUE:\n\t\tcp_write(sd, 0x3d, ctrl->val);\n\t\tsdp_write(sd, 0x16, ctrl->val);\n\t\t \n\t\treturn 0;\n\t\t \n\tcase V4L2_CID_ADV_RX_ANALOG_SAMPLING_PHASE:\n\t\tafe_write(sd, 0xc8, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_ADV_RX_FREE_RUN_COLOR_MANUAL:\n\t\tcp_write_and_or(sd, 0xbf, ~0x04, (ctrl->val << 2));\n\t\tsdp_write_and_or(sd, 0xdd, ~0x04, (ctrl->val << 2));\n\t\treturn 0;\n\tcase V4L2_CID_ADV_RX_FREE_RUN_COLOR: {\n\t\tu8 R = (ctrl->val & 0xff0000) >> 16;\n\t\tu8 G = (ctrl->val & 0x00ff00) >> 8;\n\t\tu8 B = (ctrl->val & 0x0000ff);\n\t\t \n\t\tint Y = 66 * R + 129 * G + 25 * B;\n\t\tint U = -38 * R - 74 * G + 112 * B;\n\t\tint V = 112 * R - 94 * G - 18 * B;\n\n\t\t \n\t\tY = (Y + 128) >> 8;\n\t\tU = (U + 128) >> 8;\n\t\tV = (V + 128) >> 8;\n\t\t \n\t\tY += 16;\n\t\tU += 128;\n\t\tV += 128;\n\n\t\tv4l2_dbg(1, debug, sd, \"R %x, G %x, B %x\\n\", R, G, B);\n\t\tv4l2_dbg(1, debug, sd, \"Y %x, U %x, V %x\\n\", Y, U, V);\n\n\t\t \n\t\tcp_write(sd, 0xc1, R);\n\t\tcp_write(sd, 0xc0, G);\n\t\tcp_write(sd, 0xc2, B);\n\t\t \n\t\tsdp_write(sd, 0xde, Y);\n\t\tsdp_write(sd, 0xdf, (V & 0xf0) | ((U >> 4) & 0x0f));\n\t\treturn 0;\n\t}\n\tcase V4L2_CID_DV_RX_RGB_RANGE:\n\t\tstate->rgb_quantization_range = ctrl->val;\n\t\tset_rgb_quantization_range(sd);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int adv7842_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\n\tif (ctrl->id == V4L2_CID_DV_RX_IT_CONTENT_TYPE) {\n\t\tctrl->val = V4L2_DV_IT_CONTENT_TYPE_NO_ITC;\n\t\tif ((io_read(sd, 0x60) & 1) && (infoframe_read(sd, 0x03) & 0x80))\n\t\t\tctrl->val = (infoframe_read(sd, 0x05) >> 4) & 3;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic inline bool no_power(struct v4l2_subdev *sd)\n{\n\treturn io_read(sd, 0x0c) & 0x24;\n}\n\nstatic inline bool no_cp_signal(struct v4l2_subdev *sd)\n{\n\treturn ((cp_read(sd, 0xb5) & 0xd0) != 0xd0) || !(cp_read(sd, 0xb1) & 0x80);\n}\n\nstatic inline bool is_hdmi(struct v4l2_subdev *sd)\n{\n\treturn hdmi_read(sd, 0x05) & 0x80;\n}\n\nstatic int adv7842_g_input_status(struct v4l2_subdev *sd, u32 *status)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\t*status = 0;\n\n\tif (io_read(sd, 0x0c) & 0x24)\n\t\t*status |= V4L2_IN_ST_NO_POWER;\n\n\tif (state->mode == ADV7842_MODE_SDP) {\n\t\t \n\t\tif (!(sdp_read(sd, 0x5A) & 0x01))\n\t\t\t*status |= V4L2_IN_ST_NO_SIGNAL;\n\n\t\tv4l2_dbg(1, debug, sd, \"%s: SDP status = 0x%x\\n\",\n\t\t\t\t__func__, *status);\n\t\treturn 0;\n\t}\n\t \n\tif ((cp_read(sd, 0xb5) & 0xd0) != 0xd0 ||\n\t\t\t!(cp_read(sd, 0xb1) & 0x80))\n\t\t \n\t\t*status |= V4L2_IN_ST_NO_SIGNAL;\n\n\tif (is_digital_input(sd) && ((io_read(sd, 0x74) & 0x03) != 0x03))\n\t\t*status |= V4L2_IN_ST_NO_SIGNAL;\n\n\tv4l2_dbg(1, debug, sd, \"%s: CP status = 0x%x\\n\",\n\t\t\t__func__, *status);\n\n\treturn 0;\n}\n\nstruct stdi_readback {\n\tu16 bl, lcf, lcvs;\n\tu8 hs_pol, vs_pol;\n\tbool interlaced;\n};\n\nstatic int stdi2dv_timings(struct v4l2_subdev *sd,\n\t\tstruct stdi_readback *stdi,\n\t\tstruct v4l2_dv_timings *timings)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\tu32 hfreq = (ADV7842_fsc * 8) / stdi->bl;\n\tu32 pix_clk;\n\tint i;\n\n\tfor (i = 0; v4l2_dv_timings_presets[i].bt.width; i++) {\n\t\tconst struct v4l2_bt_timings *bt = &v4l2_dv_timings_presets[i].bt;\n\n\t\tif (!v4l2_valid_dv_timings(&v4l2_dv_timings_presets[i],\n\t\t\t\t\t   adv7842_get_dv_timings_cap(sd),\n\t\t\t\t\t   adv7842_check_dv_timings, NULL))\n\t\t\tcontinue;\n\t\tif (vtotal(bt) != stdi->lcf + 1)\n\t\t\tcontinue;\n\t\tif (bt->vsync != stdi->lcvs)\n\t\t\tcontinue;\n\n\t\tpix_clk = hfreq * htotal(bt);\n\n\t\tif ((pix_clk < bt->pixelclock + 1000000) &&\n\t\t    (pix_clk > bt->pixelclock - 1000000)) {\n\t\t\t*timings = v4l2_dv_timings_presets[i];\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (v4l2_detect_cvt(stdi->lcf + 1, hfreq, stdi->lcvs, 0,\n\t\t\t(stdi->hs_pol == '+' ? V4L2_DV_HSYNC_POS_POL : 0) |\n\t\t\t(stdi->vs_pol == '+' ? V4L2_DV_VSYNC_POS_POL : 0),\n\t\t\tfalse, timings))\n\t\treturn 0;\n\tif (v4l2_detect_gtf(stdi->lcf + 1, hfreq, stdi->lcvs,\n\t\t\t(stdi->hs_pol == '+' ? V4L2_DV_HSYNC_POS_POL : 0) |\n\t\t\t(stdi->vs_pol == '+' ? V4L2_DV_VSYNC_POS_POL : 0),\n\t\t\tfalse, state->aspect_ratio, timings))\n\t\treturn 0;\n\n\tv4l2_dbg(2, debug, sd,\n\t\t\"%s: No format candidate found for lcvs = %d, lcf=%d, bl = %d, %chsync, %cvsync\\n\",\n\t\t__func__, stdi->lcvs, stdi->lcf, stdi->bl,\n\t\tstdi->hs_pol, stdi->vs_pol);\n\treturn -1;\n}\n\nstatic int read_stdi(struct v4l2_subdev *sd, struct stdi_readback *stdi)\n{\n\tu32 status;\n\n\tadv7842_g_input_status(sd, &status);\n\tif (status & V4L2_IN_ST_NO_SIGNAL) {\n\t\tv4l2_dbg(2, debug, sd, \"%s: no signal\\n\", __func__);\n\t\treturn -ENOLINK;\n\t}\n\n\tstdi->bl = ((cp_read(sd, 0xb1) & 0x3f) << 8) | cp_read(sd, 0xb2);\n\tstdi->lcf = ((cp_read(sd, 0xb3) & 0x7) << 8) | cp_read(sd, 0xb4);\n\tstdi->lcvs = cp_read(sd, 0xb3) >> 3;\n\n\tif ((cp_read(sd, 0xb5) & 0x80) && ((cp_read(sd, 0xb5) & 0x03) == 0x01)) {\n\t\tstdi->hs_pol = ((cp_read(sd, 0xb5) & 0x10) ?\n\t\t\t((cp_read(sd, 0xb5) & 0x08) ? '+' : '-') : 'x');\n\t\tstdi->vs_pol = ((cp_read(sd, 0xb5) & 0x40) ?\n\t\t\t((cp_read(sd, 0xb5) & 0x20) ? '+' : '-') : 'x');\n\t} else {\n\t\tstdi->hs_pol = 'x';\n\t\tstdi->vs_pol = 'x';\n\t}\n\tstdi->interlaced = (cp_read(sd, 0xb1) & 0x40) ? true : false;\n\n\tif (stdi->lcf < 239 || stdi->bl < 8 || stdi->bl == 0x3fff) {\n\t\tv4l2_dbg(2, debug, sd, \"%s: invalid signal\\n\", __func__);\n\t\treturn -ENOLINK;\n\t}\n\n\tv4l2_dbg(2, debug, sd,\n\t\t\"%s: lcf (frame height - 1) = %d, bl = %d, lcvs (vsync) = %d, %chsync, %cvsync, %s\\n\",\n\t\t __func__, stdi->lcf, stdi->bl, stdi->lcvs,\n\t\t stdi->hs_pol, stdi->vs_pol,\n\t\t stdi->interlaced ? \"interlaced\" : \"progressive\");\n\n\treturn 0;\n}\n\nstatic int adv7842_enum_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_enum_dv_timings *timings)\n{\n\tif (timings->pad != 0)\n\t\treturn -EINVAL;\n\n\treturn v4l2_enum_dv_timings_cap(timings,\n\t\tadv7842_get_dv_timings_cap(sd), adv7842_check_dv_timings, NULL);\n}\n\nstatic int adv7842_dv_timings_cap(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_dv_timings_cap *cap)\n{\n\tif (cap->pad != 0)\n\t\treturn -EINVAL;\n\n\t*cap = *adv7842_get_dv_timings_cap(sd);\n\treturn 0;\n}\n\n \nstatic void adv7842_fill_optional_dv_timings_fields(struct v4l2_subdev *sd,\n\t\tstruct v4l2_dv_timings *timings)\n{\n\tv4l2_find_dv_timings_cap(timings, adv7842_get_dv_timings_cap(sd),\n\t\t\tis_digital_input(sd) ? 250000 : 1000000,\n\t\t\tadv7842_check_dv_timings, NULL);\n\ttimings->bt.flags |= V4L2_DV_FL_CAN_DETECT_REDUCED_FPS;\n}\n\nstatic int adv7842_query_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_dv_timings *timings)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\tstruct v4l2_bt_timings *bt = &timings->bt;\n\tstruct stdi_readback stdi = { 0 };\n\n\tv4l2_dbg(1, debug, sd, \"%s:\\n\", __func__);\n\n\tmemset(timings, 0, sizeof(struct v4l2_dv_timings));\n\n\t \n\tif (state->mode == ADV7842_MODE_SDP)\n\t\treturn -ENODATA;\n\n\t \n\tif (read_stdi(sd, &stdi)) {\n\t\tstate->restart_stdi_once = true;\n\t\tv4l2_dbg(1, debug, sd, \"%s: no valid signal\\n\", __func__);\n\t\treturn -ENOLINK;\n\t}\n\tbt->interlaced = stdi.interlaced ?\n\t\tV4L2_DV_INTERLACED : V4L2_DV_PROGRESSIVE;\n\tbt->standards = V4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_DMT |\n\t\t\tV4L2_DV_BT_STD_GTF | V4L2_DV_BT_STD_CVT;\n\n\tif (is_digital_input(sd)) {\n\t\tu32 freq;\n\n\t\ttimings->type = V4L2_DV_BT_656_1120;\n\n\t\tbt->width = (hdmi_read(sd, 0x07) & 0x0f) * 256 + hdmi_read(sd, 0x08);\n\t\tbt->height = (hdmi_read(sd, 0x09) & 0x0f) * 256 + hdmi_read(sd, 0x0a);\n\t\tfreq = ((hdmi_read(sd, 0x51) << 1) + (hdmi_read(sd, 0x52) >> 7)) * 1000000;\n\t\tfreq += ((hdmi_read(sd, 0x52) & 0x7f) * 7813);\n\t\tif (is_hdmi(sd)) {\n\t\t\t \n\t\t\tfreq = freq * 8 / (((hdmi_read(sd, 0x0b) & 0xc0) >> 6) * 2 + 8);\n\t\t}\n\t\tbt->pixelclock = freq;\n\t\tbt->hfrontporch = (hdmi_read(sd, 0x20) & 0x03) * 256 +\n\t\t\thdmi_read(sd, 0x21);\n\t\tbt->hsync = (hdmi_read(sd, 0x22) & 0x03) * 256 +\n\t\t\thdmi_read(sd, 0x23);\n\t\tbt->hbackporch = (hdmi_read(sd, 0x24) & 0x03) * 256 +\n\t\t\thdmi_read(sd, 0x25);\n\t\tbt->vfrontporch = ((hdmi_read(sd, 0x2a) & 0x1f) * 256 +\n\t\t\thdmi_read(sd, 0x2b)) / 2;\n\t\tbt->vsync = ((hdmi_read(sd, 0x2e) & 0x1f) * 256 +\n\t\t\thdmi_read(sd, 0x2f)) / 2;\n\t\tbt->vbackporch = ((hdmi_read(sd, 0x32) & 0x1f) * 256 +\n\t\t\thdmi_read(sd, 0x33)) / 2;\n\t\tbt->polarities = ((hdmi_read(sd, 0x05) & 0x10) ? V4L2_DV_VSYNC_POS_POL : 0) |\n\t\t\t((hdmi_read(sd, 0x05) & 0x20) ? V4L2_DV_HSYNC_POS_POL : 0);\n\t\tif (bt->interlaced == V4L2_DV_INTERLACED) {\n\t\t\tbt->height += (hdmi_read(sd, 0x0b) & 0x0f) * 256 +\n\t\t\t\t\thdmi_read(sd, 0x0c);\n\t\t\tbt->il_vfrontporch = ((hdmi_read(sd, 0x2c) & 0x1f) * 256 +\n\t\t\t\t\thdmi_read(sd, 0x2d)) / 2;\n\t\t\tbt->il_vsync = ((hdmi_read(sd, 0x30) & 0x1f) * 256 +\n\t\t\t\t\thdmi_read(sd, 0x31)) / 2;\n\t\t\tbt->il_vbackporch = ((hdmi_read(sd, 0x34) & 0x1f) * 256 +\n\t\t\t\t\thdmi_read(sd, 0x35)) / 2;\n\t\t} else {\n\t\t\tbt->il_vfrontporch = 0;\n\t\t\tbt->il_vsync = 0;\n\t\t\tbt->il_vbackporch = 0;\n\t\t}\n\t\tadv7842_fill_optional_dv_timings_fields(sd, timings);\n\t\tif ((timings->bt.flags & V4L2_DV_FL_CAN_REDUCE_FPS) &&\n\t\t    freq < bt->pixelclock) {\n\t\t\tu32 reduced_freq = ((u32)bt->pixelclock / 1001) * 1000;\n\t\t\tu32 delta_freq = abs(freq - reduced_freq);\n\n\t\t\tif (delta_freq < ((u32)bt->pixelclock - reduced_freq) / 2)\n\t\t\t\ttimings->bt.flags |= V4L2_DV_FL_REDUCED_FPS;\n\t\t}\n\t} else {\n\t\t \n\t\tif (!stdi2dv_timings(sd, &stdi, timings))\n\t\t\tgoto found;\n\t\tstdi.lcvs += 1;\n\t\tv4l2_dbg(1, debug, sd, \"%s: lcvs + 1 = %d\\n\", __func__, stdi.lcvs);\n\t\tif (!stdi2dv_timings(sd, &stdi, timings))\n\t\t\tgoto found;\n\t\tstdi.lcvs -= 2;\n\t\tv4l2_dbg(1, debug, sd, \"%s: lcvs - 1 = %d\\n\", __func__, stdi.lcvs);\n\t\tif (stdi2dv_timings(sd, &stdi, timings)) {\n\t\t\t \n\t\t\tif (state->restart_stdi_once) {\n\t\t\t\tv4l2_dbg(1, debug, sd, \"%s: restart STDI\\n\", __func__);\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tcp_write_and_or(sd, 0x86, 0xf9, 0x00);\n\t\t\t\t \n\t\t\t\tcp_write_and_or(sd, 0x86, 0xf9, 0x04);\n\t\t\t\t \n\t\t\t\tcp_write_and_or(sd, 0x86, 0xf9, 0x02);\n\t\t\t\tstate->restart_stdi_once = false;\n\t\t\t\treturn -ENOLINK;\n\t\t\t}\n\t\t\tv4l2_dbg(1, debug, sd, \"%s: format not supported\\n\", __func__);\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tstate->restart_stdi_once = true;\n\t}\nfound:\n\n\tif (debug > 1)\n\t\tv4l2_print_dv_timings(sd->name, \"adv7842_query_dv_timings:\",\n\t\t\t\ttimings, true);\n\treturn 0;\n}\n\nstatic int adv7842_s_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_dv_timings *timings)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\tstruct v4l2_bt_timings *bt;\n\tint err;\n\n\tv4l2_dbg(1, debug, sd, \"%s:\\n\", __func__);\n\n\tif (state->mode == ADV7842_MODE_SDP)\n\t\treturn -ENODATA;\n\n\tif (v4l2_match_dv_timings(&state->timings, timings, 0, false)) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: no change\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tbt = &timings->bt;\n\n\tif (!v4l2_valid_dv_timings(timings, adv7842_get_dv_timings_cap(sd),\n\t\t\t\t   adv7842_check_dv_timings, NULL))\n\t\treturn -ERANGE;\n\n\tadv7842_fill_optional_dv_timings_fields(sd, timings);\n\n\tstate->timings = *timings;\n\n\tcp_write(sd, 0x91, bt->interlaced ? 0x40 : 0x00);\n\n\t \n\terr = configure_predefined_video_timings(sd, timings);\n\tif (err) {\n\t\t \n\t\tconfigure_custom_video_timings(sd, bt);\n\t}\n\n\tset_rgb_quantization_range(sd);\n\n\n\tif (debug > 1)\n\t\tv4l2_print_dv_timings(sd->name, \"adv7842_s_dv_timings: \",\n\t\t\t\t      timings, true);\n\treturn 0;\n}\n\nstatic int adv7842_g_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_dv_timings *timings)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\tif (state->mode == ADV7842_MODE_SDP)\n\t\treturn -ENODATA;\n\t*timings = state->timings;\n\treturn 0;\n}\n\nstatic void enable_input(struct v4l2_subdev *sd)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\tset_rgb_quantization_range(sd);\n\tswitch (state->mode) {\n\tcase ADV7842_MODE_SDP:\n\tcase ADV7842_MODE_COMP:\n\tcase ADV7842_MODE_RGB:\n\t\tio_write(sd, 0x15, 0xb0);    \n\t\tbreak;\n\tcase ADV7842_MODE_HDMI:\n\t\thdmi_write(sd, 0x01, 0x00);  \n\t\tio_write(sd, 0x15, 0xa0);    \n\t\thdmi_write_and_or(sd, 0x1a, 0xef, 0x00);  \n\t\tbreak;\n\tdefault:\n\t\tv4l2_dbg(2, debug, sd, \"%s: Unknown mode %d\\n\",\n\t\t\t __func__, state->mode);\n\t\tbreak;\n\t}\n}\n\nstatic void disable_input(struct v4l2_subdev *sd)\n{\n\thdmi_write_and_or(sd, 0x1a, 0xef, 0x10);  \n\tmsleep(16);  \n\tio_write(sd, 0x15, 0xbe);    \n\thdmi_write(sd, 0x01, 0x78);  \n}\n\nstatic void sdp_csc_coeff(struct v4l2_subdev *sd,\n\t\t\t  const struct adv7842_sdp_csc_coeff *c)\n{\n\t \n\tsdp_io_write_and_or(sd, 0xe0, 0xbf, c->manual ? 0x00 : 0x40);\n\n\tif (!c->manual)\n\t\treturn;\n\n\t \n\tsdp_io_write_and_or(sd, 0xe0, 0x7f, c->scaling == 2 ? 0x80 : 0x00);\n\n\t \n\tsdp_io_write_and_or(sd, 0xe0, 0xe0, c->A1 >> 8);\n\tsdp_io_write(sd, 0xe1, c->A1);\n\tsdp_io_write_and_or(sd, 0xe2, 0xe0, c->A2 >> 8);\n\tsdp_io_write(sd, 0xe3, c->A2);\n\tsdp_io_write_and_or(sd, 0xe4, 0xe0, c->A3 >> 8);\n\tsdp_io_write(sd, 0xe5, c->A3);\n\n\t \n\tsdp_io_write_and_or(sd, 0xe6, 0x80, c->A4 >> 8);\n\tsdp_io_write(sd, 0xe7, c->A4);\n\n\t \n\tsdp_io_write_and_or(sd, 0xe8, 0xe0, c->B1 >> 8);\n\tsdp_io_write(sd, 0xe9, c->B1);\n\tsdp_io_write_and_or(sd, 0xea, 0xe0, c->B2 >> 8);\n\tsdp_io_write(sd, 0xeb, c->B2);\n\tsdp_io_write_and_or(sd, 0xec, 0xe0, c->B3 >> 8);\n\tsdp_io_write(sd, 0xed, c->B3);\n\n\t \n\tsdp_io_write_and_or(sd, 0xee, 0x80, c->B4 >> 8);\n\tsdp_io_write(sd, 0xef, c->B4);\n\n\t \n\tsdp_io_write_and_or(sd, 0xf0, 0xe0, c->C1 >> 8);\n\tsdp_io_write(sd, 0xf1, c->C1);\n\tsdp_io_write_and_or(sd, 0xf2, 0xe0, c->C2 >> 8);\n\tsdp_io_write(sd, 0xf3, c->C2);\n\tsdp_io_write_and_or(sd, 0xf4, 0xe0, c->C3 >> 8);\n\tsdp_io_write(sd, 0xf5, c->C3);\n\n\t \n\tsdp_io_write_and_or(sd, 0xf6, 0x80, c->C4 >> 8);\n\tsdp_io_write(sd, 0xf7, c->C4);\n}\n\nstatic void select_input(struct v4l2_subdev *sd,\n\t\t\t enum adv7842_vid_std_select vid_std_select)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\tswitch (state->mode) {\n\tcase ADV7842_MODE_SDP:\n\t\tio_write(sd, 0x00, vid_std_select);  \n\t\tio_write(sd, 0x01, 0);  \n\t\t \n\t\tcp_write_and_or(sd, 0x81, 0xef, 0x10);\n\n\t\tafe_write(sd, 0x00, 0x00);  \n\t\tafe_write(sd, 0xc8, 0x00);  \n\n\t\tio_write(sd, 0xdd, 0x90);  \n\t\t \n\n\t\t \n\t\tafe_write_and_or(sd, 0x02, 0x7f, 0x80);\n\t\tif (vid_std_select == ADV7842_SDP_VID_STD_CVBS_SD_4x1) {\n\t\t\tafe_write(sd, 0x03, 0xa0);  \n\t\t\tafe_write(sd, 0x04, 0x00);  \n\t\t} else {\n\t\t\tafe_write(sd, 0x03, 0xa0);  \n\t\t\tafe_write(sd, 0x04, 0xc0);  \n\t\t}\n\t\tafe_write(sd, 0x0c, 0x1f);  \n\t\tafe_write(sd, 0x12, 0x63);  \n\n\t\tsdp_io_write(sd, 0xb2, 0x60);  \n\t\tsdp_io_write(sd, 0xc8, 0xe3);  \n\n\t\t \n\t\tsdp_write(sd, 0x00, 0x3F);  \n\t\tsdp_write(sd, 0x01, 0x00);  \n\n\t\tsdp_write(sd, 0x03, 0xE4);  \n\t\tsdp_write(sd, 0x04, 0x0B);  \n\t\tsdp_write(sd, 0x05, 0xC3);  \n\t\tsdp_write(sd, 0x06, 0xFE);  \n\t\tsdp_write(sd, 0x12, 0x0D);  \n\t\tsdp_write(sd, 0xA7, 0x00);  \n\t\tsdp_io_write(sd, 0xB0, 0x00);  \n\n\t\t \n\t\tsdp_write_and_or(sd, 0x12, 0xf6, 0x09);\n\n\t\tbreak;\n\n\tcase ADV7842_MODE_COMP:\n\tcase ADV7842_MODE_RGB:\n\t\t \n\t\tafe_write_and_or(sd, 0x02, 0x7f, 0x00);\n\t\t \n\t\tio_write(sd, 0x00, vid_std_select);  \n\t\tio_write(sd, 0x01, 0x02);  \n\t\tcp_write_and_or(sd, 0x81, 0xef, 0x10);  \n\n\t\tafe_write(sd, 0x00, 0x00);  \n\t\tafe_write(sd, 0xc8, 0x00);  \n\t\tif (state->mode == ADV7842_MODE_COMP) {\n\t\t\t \n\t\t\tio_write_and_or(sd, 0x02, 0x0f, 0x60);\n\t\t} else {\n\t\t\t \n\t\t\tio_write_and_or(sd, 0x02, 0x0f, 0x10);\n\t\t}\n\n\t\t \n\t\t \n\t\tafe_write(sd, 0x0c, 0x1f);  \n\t\tafe_write(sd, 0x12, 0x63);  \n\n\t\t \n\t\tcp_write(sd, 0x73, 0x10);\n\t\tcp_write(sd, 0x74, 0x04);\n\t\tcp_write(sd, 0x75, 0x01);\n\t\tcp_write(sd, 0x76, 0x00);\n\n\t\tcp_write(sd, 0x3e, 0x04);  \n\t\tcp_write(sd, 0xc3, 0x39);  \n\t\tcp_write(sd, 0x40, 0x5c);  \n\t\tbreak;\n\n\tcase ADV7842_MODE_HDMI:\n\t\t \n\t\tafe_write_and_or(sd, 0x02, 0x7f, 0x00);\n\t\t \n\t\tif (state->hdmi_port_a)\n\t\t\thdmi_write(sd, 0x00, 0x02);  \n\t\telse\n\t\t\thdmi_write(sd, 0x00, 0x03);  \n\t\tio_write(sd, 0x00, vid_std_select);  \n\t\tio_write(sd, 0x01, 5);  \n\t\tcp_write_and_or(sd, 0x81, 0xef, 0x00);  \n\n\t\t \n\t\t \n\t\thdmi_write(sd, 0xc0, 0x00);\n\t\thdmi_write(sd, 0x0d, 0x34);  \n\t\thdmi_write(sd, 0x3d, 0x10);  \n\t\thdmi_write(sd, 0x44, 0x85);  \n\t\thdmi_write(sd, 0x46, 0x1f);  \n\t\thdmi_write(sd, 0x57, 0xb6);  \n\t\thdmi_write(sd, 0x58, 0x03);  \n\t\thdmi_write(sd, 0x60, 0x88);  \n\t\thdmi_write(sd, 0x61, 0x88);  \n\t\thdmi_write(sd, 0x6c, 0x18);  \n\t\thdmi_write(sd, 0x75, 0x10);  \n\t\thdmi_write(sd, 0x85, 0x1f);  \n\t\thdmi_write(sd, 0x87, 0x70);  \n\t\thdmi_write(sd, 0x89, 0x04);  \n\t\thdmi_write(sd, 0x8a, 0x1e);  \n\t\thdmi_write(sd, 0x93, 0x04);  \n\t\thdmi_write(sd, 0x94, 0x1e);  \n\t\thdmi_write(sd, 0x99, 0xa1);  \n\t\thdmi_write(sd, 0x9b, 0x09);  \n\t\thdmi_write(sd, 0x9d, 0x02);  \n\n\t\tafe_write(sd, 0x00, 0xff);  \n\t\tafe_write(sd, 0xc8, 0x40);  \n\n\t\t \n\t\tcp_write(sd, 0x73, 0x10);\n\t\tcp_write(sd, 0x74, 0x04);\n\t\tcp_write(sd, 0x75, 0x01);\n\t\tcp_write(sd, 0x76, 0x00);\n\n\t\t \n\t\t \n\t\tafe_write(sd, 0x12, 0xfb);  \n\t\tafe_write(sd, 0x0c, 0x0d);  \n\t\tcp_write(sd, 0x3e, 0x00);  \n\n\t\t \n\t\tcp_write(sd, 0xc3, 0x33);  \n\n\t\t \n\t\tio_write_and_or(sd, 0x02, 0x0f, 0xf0);\n\t\tbreak;\n\n\tdefault:\n\t\tv4l2_dbg(2, debug, sd, \"%s: Unknown mode %d\\n\",\n\t\t\t __func__, state->mode);\n\t\tbreak;\n\t}\n}\n\nstatic int adv7842_s_routing(struct v4l2_subdev *sd,\n\t\tu32 input, u32 output, u32 config)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\tv4l2_dbg(2, debug, sd, \"%s: input %d\\n\", __func__, input);\n\n\tswitch (input) {\n\tcase ADV7842_SELECT_HDMI_PORT_A:\n\t\tstate->mode = ADV7842_MODE_HDMI;\n\t\tstate->vid_std_select = ADV7842_HDMI_COMP_VID_STD_HD_1250P;\n\t\tstate->hdmi_port_a = true;\n\t\tbreak;\n\tcase ADV7842_SELECT_HDMI_PORT_B:\n\t\tstate->mode = ADV7842_MODE_HDMI;\n\t\tstate->vid_std_select = ADV7842_HDMI_COMP_VID_STD_HD_1250P;\n\t\tstate->hdmi_port_a = false;\n\t\tbreak;\n\tcase ADV7842_SELECT_VGA_COMP:\n\t\tstate->mode = ADV7842_MODE_COMP;\n\t\tstate->vid_std_select = ADV7842_RGB_VID_STD_AUTO_GRAPH_MODE;\n\t\tbreak;\n\tcase ADV7842_SELECT_VGA_RGB:\n\t\tstate->mode = ADV7842_MODE_RGB;\n\t\tstate->vid_std_select = ADV7842_RGB_VID_STD_AUTO_GRAPH_MODE;\n\t\tbreak;\n\tcase ADV7842_SELECT_SDP_CVBS:\n\t\tstate->mode = ADV7842_MODE_SDP;\n\t\tstate->vid_std_select = ADV7842_SDP_VID_STD_CVBS_SD_4x1;\n\t\tbreak;\n\tcase ADV7842_SELECT_SDP_YC:\n\t\tstate->mode = ADV7842_MODE_SDP;\n\t\tstate->vid_std_select = ADV7842_SDP_VID_STD_YC_SD4_x1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdisable_input(sd);\n\tselect_input(sd, state->vid_std_select);\n\tenable_input(sd);\n\n\tv4l2_subdev_notify_event(sd, &adv7842_ev_fmt);\n\n\treturn 0;\n}\n\nstatic int adv7842_enum_mbus_code(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index >= ARRAY_SIZE(adv7842_formats))\n\t\treturn -EINVAL;\n\tcode->code = adv7842_formats[code->index].code;\n\treturn 0;\n}\n\nstatic void adv7842_fill_format(struct adv7842_state *state,\n\t\t\t\tstruct v4l2_mbus_framefmt *format)\n{\n\tmemset(format, 0, sizeof(*format));\n\n\tformat->width = state->timings.bt.width;\n\tformat->height = state->timings.bt.height;\n\tformat->field = V4L2_FIELD_NONE;\n\tformat->colorspace = V4L2_COLORSPACE_SRGB;\n\n\tif (state->timings.bt.flags & V4L2_DV_FL_IS_CE_VIDEO)\n\t\tformat->colorspace = (state->timings.bt.height <= 576) ?\n\t\t\tV4L2_COLORSPACE_SMPTE170M : V4L2_COLORSPACE_REC709;\n}\n\n \nstatic unsigned int adv7842_op_ch_sel(struct adv7842_state *state)\n{\n#define _SEL(a, b, c, d, e, f)\t{ \\\n\tADV7842_OP_CH_SEL_##a, ADV7842_OP_CH_SEL_##b, ADV7842_OP_CH_SEL_##c, \\\n\tADV7842_OP_CH_SEL_##d, ADV7842_OP_CH_SEL_##e, ADV7842_OP_CH_SEL_##f }\n#define _BUS(x)\t\t\t[ADV7842_BUS_ORDER_##x]\n\n\tstatic const unsigned int op_ch_sel[6][6] = {\n\t\t_BUS(RGB)   = _SEL(GBR, GRB, BGR, RGB, BRG, RBG),\n\t\t_BUS(GRB)   = _SEL(BGR, RGB, GBR, GRB, RBG, BRG),\n\t\t_BUS(RBG)   = _SEL(GRB, GBR, BRG, RBG, BGR, RGB),\n\t\t_BUS(BGR)   = _SEL(RBG, BRG, RGB, BGR, GRB, GBR),\n\t\t_BUS(BRG)   = _SEL(BRG, RBG, GRB, GBR, RGB, BGR),\n\t\t_BUS(GBR)   = _SEL(RGB, BGR, RBG, BRG, GBR, GRB),\n\t};\n\n\treturn op_ch_sel[state->pdata.bus_order][state->format->op_ch_sel >> 5];\n}\n\nstatic void adv7842_setup_format(struct adv7842_state *state)\n{\n\tstruct v4l2_subdev *sd = &state->sd;\n\n\tio_write_clr_set(sd, 0x02, 0x02,\n\t\t\tstate->format->rgb_out ? ADV7842_RGB_OUT : 0);\n\tio_write(sd, 0x03, state->format->op_format_sel |\n\t\t state->pdata.op_format_mode_sel);\n\tio_write_clr_set(sd, 0x04, 0xe0, adv7842_op_ch_sel(state));\n\tio_write_clr_set(sd, 0x05, 0x01,\n\t\t\tstate->format->swap_cb_cr ? ADV7842_OP_SWAP_CB_CR : 0);\n\tset_rgb_quantization_range(sd);\n}\n\nstatic int adv7842_get_format(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *format)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\tif (format->pad != ADV7842_PAD_SOURCE)\n\t\treturn -EINVAL;\n\n\tif (state->mode == ADV7842_MODE_SDP) {\n\t\t \n\t\tif (!(sdp_read(sd, 0x5a) & 0x01))\n\t\t\treturn -EINVAL;\n\t\tformat->format.code = MEDIA_BUS_FMT_YUYV8_2X8;\n\t\tformat->format.width = 720;\n\t\t \n\t\tif (state->norm & V4L2_STD_525_60)\n\t\t\tformat->format.height = 480;\n\t\telse\n\t\t\tformat->format.height = 576;\n\t\tformat->format.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\t\treturn 0;\n\t}\n\n\tadv7842_fill_format(state, &format->format);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tstruct v4l2_mbus_framefmt *fmt;\n\n\t\tfmt = v4l2_subdev_get_try_format(sd, sd_state, format->pad);\n\t\tformat->format.code = fmt->code;\n\t} else {\n\t\tformat->format.code = state->format->code;\n\t}\n\n\treturn 0;\n}\n\nstatic int adv7842_set_format(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *format)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\tconst struct adv7842_format_info *info;\n\n\tif (format->pad != ADV7842_PAD_SOURCE)\n\t\treturn -EINVAL;\n\n\tif (state->mode == ADV7842_MODE_SDP)\n\t\treturn adv7842_get_format(sd, sd_state, format);\n\n\tinfo = adv7842_format_info(state, format->format.code);\n\tif (info == NULL)\n\t\tinfo = adv7842_format_info(state, MEDIA_BUS_FMT_YUYV8_2X8);\n\n\tadv7842_fill_format(state, &format->format);\n\tformat->format.code = info->code;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tstruct v4l2_mbus_framefmt *fmt;\n\n\t\tfmt = v4l2_subdev_get_try_format(sd, sd_state, format->pad);\n\t\tfmt->code = format->format.code;\n\t} else {\n\t\tstate->format = info;\n\t\tadv7842_setup_format(state);\n\t}\n\n\treturn 0;\n}\n\nstatic void adv7842_irq_enable(struct v4l2_subdev *sd, bool enable)\n{\n\tif (enable) {\n\t\t \n\t\tio_write(sd, 0x46, 0x9c);\n\t\t \n\t\tio_write(sd, 0x5a, 0x10);\n\t\t \n\t\tio_write(sd, 0x73, 0x03);\n\t\t \n\t\tio_write(sd, 0x78, 0x03);\n\t\t \n\t\tio_write(sd, 0xa0, 0x09);\n\t\t \n\t\tio_write(sd, 0x69, 0x08);\n\t} else {\n\t\tio_write(sd, 0x46, 0x0);\n\t\tio_write(sd, 0x5a, 0x0);\n\t\tio_write(sd, 0x73, 0x0);\n\t\tio_write(sd, 0x78, 0x0);\n\t\tio_write(sd, 0xa0, 0x0);\n\t\tio_write(sd, 0x69, 0x0);\n\t}\n}\n\n#if IS_ENABLED(CONFIG_VIDEO_ADV7842_CEC)\nstatic void adv7842_cec_tx_raw_status(struct v4l2_subdev *sd, u8 tx_raw_status)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\tif ((cec_read(sd, 0x11) & 0x01) == 0) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: tx raw: tx disabled\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (tx_raw_status & 0x02) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: tx raw: arbitration lost\\n\",\n\t\t\t __func__);\n\t\tcec_transmit_done(state->cec_adap, CEC_TX_STATUS_ARB_LOST,\n\t\t\t\t  1, 0, 0, 0);\n\t\treturn;\n\t}\n\tif (tx_raw_status & 0x04) {\n\t\tu8 status;\n\t\tu8 nack_cnt;\n\t\tu8 low_drive_cnt;\n\n\t\tv4l2_dbg(1, debug, sd, \"%s: tx raw: retry failed\\n\", __func__);\n\t\t \n\t\tstatus = CEC_TX_STATUS_MAX_RETRIES;\n\t\tnack_cnt = cec_read(sd, 0x14) & 0xf;\n\t\tif (nack_cnt)\n\t\t\tstatus |= CEC_TX_STATUS_NACK;\n\t\tlow_drive_cnt = cec_read(sd, 0x14) >> 4;\n\t\tif (low_drive_cnt)\n\t\t\tstatus |= CEC_TX_STATUS_LOW_DRIVE;\n\t\tcec_transmit_done(state->cec_adap, status,\n\t\t\t\t  0, nack_cnt, low_drive_cnt, 0);\n\t\treturn;\n\t}\n\tif (tx_raw_status & 0x01) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: tx raw: ready ok\\n\", __func__);\n\t\tcec_transmit_done(state->cec_adap, CEC_TX_STATUS_OK, 0, 0, 0, 0);\n\t\treturn;\n\t}\n}\n\nstatic void adv7842_cec_isr(struct v4l2_subdev *sd, bool *handled)\n{\n\tu8 cec_irq;\n\n\t \n\tcec_irq = io_read(sd, 0x93) & 0x0f;\n\tif (!cec_irq)\n\t\treturn;\n\n\tv4l2_dbg(1, debug, sd, \"%s: cec: irq 0x%x\\n\", __func__, cec_irq);\n\tadv7842_cec_tx_raw_status(sd, cec_irq);\n\tif (cec_irq & 0x08) {\n\t\tstruct adv7842_state *state = to_state(sd);\n\t\tstruct cec_msg msg;\n\n\t\tmsg.len = cec_read(sd, 0x25) & 0x1f;\n\t\tif (msg.len > CEC_MAX_MSG_SIZE)\n\t\t\tmsg.len = CEC_MAX_MSG_SIZE;\n\n\t\tif (msg.len) {\n\t\t\tu8 i;\n\n\t\t\tfor (i = 0; i < msg.len; i++)\n\t\t\t\tmsg.msg[i] = cec_read(sd, i + 0x15);\n\t\t\tcec_write(sd, 0x26, 0x01);  \n\t\t\tcec_received_msg(state->cec_adap, &msg);\n\t\t}\n\t}\n\n\tio_write(sd, 0x94, cec_irq);\n\n\tif (handled)\n\t\t*handled = true;\n}\n\nstatic int adv7842_cec_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\tstruct adv7842_state *state = cec_get_drvdata(adap);\n\tstruct v4l2_subdev *sd = &state->sd;\n\n\tif (!state->cec_enabled_adap && enable) {\n\t\tcec_write_clr_set(sd, 0x2a, 0x01, 0x01);  \n\t\tcec_write(sd, 0x2c, 0x01);\t \n\t\tcec_write_clr_set(sd, 0x11, 0x01, 0);  \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\tio_write_clr_set(sd, 0x96, 0x0f, 0x0f);\n\t\tcec_write(sd, 0x26, 0x01);             \n\t} else if (state->cec_enabled_adap && !enable) {\n\t\t \n\t\tio_write_clr_set(sd, 0x96, 0x0f, 0x00);\n\t\t \n\t\tcec_write_clr_set(sd, 0x27, 0x70, 0x00);\n\t\t \n\t\tcec_write_clr_set(sd, 0x2a, 0x01, 0x00);\n\t\tstate->cec_valid_addrs = 0;\n\t}\n\tstate->cec_enabled_adap = enable;\n\treturn 0;\n}\n\nstatic int adv7842_cec_adap_log_addr(struct cec_adapter *adap, u8 addr)\n{\n\tstruct adv7842_state *state = cec_get_drvdata(adap);\n\tstruct v4l2_subdev *sd = &state->sd;\n\tunsigned int i, free_idx = ADV7842_MAX_ADDRS;\n\n\tif (!state->cec_enabled_adap)\n\t\treturn addr == CEC_LOG_ADDR_INVALID ? 0 : -EIO;\n\n\tif (addr == CEC_LOG_ADDR_INVALID) {\n\t\tcec_write_clr_set(sd, 0x27, 0x70, 0);\n\t\tstate->cec_valid_addrs = 0;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ADV7842_MAX_ADDRS; i++) {\n\t\tbool is_valid = state->cec_valid_addrs & (1 << i);\n\n\t\tif (free_idx == ADV7842_MAX_ADDRS && !is_valid)\n\t\t\tfree_idx = i;\n\t\tif (is_valid && state->cec_addr[i] == addr)\n\t\t\treturn 0;\n\t}\n\tif (i == ADV7842_MAX_ADDRS) {\n\t\ti = free_idx;\n\t\tif (i == ADV7842_MAX_ADDRS)\n\t\t\treturn -ENXIO;\n\t}\n\tstate->cec_addr[i] = addr;\n\tstate->cec_valid_addrs |= 1 << i;\n\n\tswitch (i) {\n\tcase 0:\n\t\t \n\t\tcec_write_clr_set(sd, 0x27, 0x10, 0x10);\n\t\t \n\t\tcec_write_clr_set(sd, 0x28, 0x0f, addr);\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tcec_write_clr_set(sd, 0x27, 0x20, 0x20);\n\t\t \n\t\tcec_write_clr_set(sd, 0x28, 0xf0, addr << 4);\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tcec_write_clr_set(sd, 0x27, 0x40, 0x40);\n\t\t \n\t\tcec_write_clr_set(sd, 0x29, 0x0f, addr);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int adv7842_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\t     u32 signal_free_time, struct cec_msg *msg)\n{\n\tstruct adv7842_state *state = cec_get_drvdata(adap);\n\tstruct v4l2_subdev *sd = &state->sd;\n\tu8 len = msg->len;\n\tunsigned int i;\n\n\t \n\tcec_write_clr_set(sd, 0x12, 0x70, max(1, attempts - 1) << 4);\n\n\tif (len > 16) {\n\t\tv4l2_err(sd, \"%s: len exceeded 16 (%d)\\n\", __func__, len);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < len; i++)\n\t\tcec_write(sd, i, msg->msg[i]);\n\n\t \n\tcec_write(sd, 0x10, len);\n\t \n\tcec_write(sd, 0x11, 0x01);\n\treturn 0;\n}\n\nstatic const struct cec_adap_ops adv7842_cec_adap_ops = {\n\t.adap_enable = adv7842_cec_adap_enable,\n\t.adap_log_addr = adv7842_cec_adap_log_addr,\n\t.adap_transmit = adv7842_cec_adap_transmit,\n};\n#endif\n\nstatic int adv7842_isr(struct v4l2_subdev *sd, u32 status, bool *handled)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\tu8 fmt_change_cp, fmt_change_digital, fmt_change_sdp;\n\tu8 irq_status[6];\n\n\tadv7842_irq_enable(sd, false);\n\n\t \n\tirq_status[0] = io_read(sd, 0x43);\n\tirq_status[1] = io_read(sd, 0x57);\n\tirq_status[2] = io_read(sd, 0x70);\n\tirq_status[3] = io_read(sd, 0x75);\n\tirq_status[4] = io_read(sd, 0x9d);\n\tirq_status[5] = io_read(sd, 0x66);\n\n\t \n\tif (irq_status[0])\n\t\tio_write(sd, 0x44, irq_status[0]);\n\tif (irq_status[1])\n\t\tio_write(sd, 0x58, irq_status[1]);\n\tif (irq_status[2])\n\t\tio_write(sd, 0x71, irq_status[2]);\n\tif (irq_status[3])\n\t\tio_write(sd, 0x76, irq_status[3]);\n\tif (irq_status[4])\n\t\tio_write(sd, 0x9e, irq_status[4]);\n\tif (irq_status[5])\n\t\tio_write(sd, 0x67, irq_status[5]);\n\n\tadv7842_irq_enable(sd, true);\n\n\tv4l2_dbg(1, debug, sd, \"%s: irq %x, %x, %x, %x, %x, %x\\n\", __func__,\n\t\t irq_status[0], irq_status[1], irq_status[2],\n\t\t irq_status[3], irq_status[4], irq_status[5]);\n\n\t \n\tfmt_change_cp = irq_status[0] & 0x9c;\n\n\t \n\tif (state->mode == ADV7842_MODE_SDP)\n\t\tfmt_change_sdp = (irq_status[1] & 0x30) | (irq_status[4] & 0x09);\n\telse\n\t\tfmt_change_sdp = 0;\n\n\t \n\tif (is_digital_input(sd))\n\t\tfmt_change_digital = irq_status[3] & 0x03;\n\telse\n\t\tfmt_change_digital = 0;\n\n\t \n\tif (fmt_change_cp || fmt_change_digital || fmt_change_sdp) {\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t \"%s: fmt_change_cp = 0x%x, fmt_change_digital = 0x%x, fmt_change_sdp = 0x%x\\n\",\n\t\t\t __func__, fmt_change_cp, fmt_change_digital,\n\t\t\t fmt_change_sdp);\n\t\tv4l2_subdev_notify_event(sd, &adv7842_ev_fmt);\n\t\tif (handled)\n\t\t\t*handled = true;\n\t}\n\n\t \n\tif (irq_status[5] & 0x08) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: irq %s mode\\n\", __func__,\n\t\t\t (io_read(sd, 0x65) & 0x08) ? \"HDMI\" : \"DVI\");\n\t\tset_rgb_quantization_range(sd);\n\t\tif (handled)\n\t\t\t*handled = true;\n\t}\n\n#if IS_ENABLED(CONFIG_VIDEO_ADV7842_CEC)\n\t \n\tadv7842_cec_isr(sd, handled);\n#endif\n\n\t \n\tif (irq_status[2] & 0x3) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: irq tx_5v\\n\", __func__);\n\t\tadv7842_s_detect_tx_5v_ctrl(sd);\n\t\tif (handled)\n\t\t\t*handled = true;\n\t}\n\treturn 0;\n}\n\nstatic int adv7842_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\tu32 blocks = 0;\n\tu8 *data = NULL;\n\n\tmemset(edid->reserved, 0, sizeof(edid->reserved));\n\n\tswitch (edid->pad) {\n\tcase ADV7842_EDID_PORT_A:\n\tcase ADV7842_EDID_PORT_B:\n\t\tif (state->hdmi_edid.present & (0x04 << edid->pad)) {\n\t\t\tdata = state->hdmi_edid.edid;\n\t\t\tblocks = state->hdmi_edid.blocks;\n\t\t}\n\t\tbreak;\n\tcase ADV7842_EDID_PORT_VGA:\n\t\tif (state->vga_edid.present) {\n\t\t\tdata = state->vga_edid.edid;\n\t\t\tblocks = state->vga_edid.blocks;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (edid->start_block == 0 && edid->blocks == 0) {\n\t\tedid->blocks = blocks;\n\t\treturn 0;\n\t}\n\n\tif (!data)\n\t\treturn -ENODATA;\n\n\tif (edid->start_block >= blocks)\n\t\treturn -EINVAL;\n\n\tif (edid->start_block + edid->blocks > blocks)\n\t\tedid->blocks = blocks - edid->start_block;\n\n\tmemcpy(edid->edid, data + edid->start_block * 128, edid->blocks * 128);\n\n\treturn 0;\n}\n\n \nstatic int adv7842_set_edid(struct v4l2_subdev *sd, struct v4l2_edid *e)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\tunsigned int max_blocks = e->pad == ADV7842_EDID_PORT_VGA ? 1 : 4;\n\tint err = 0;\n\n\tmemset(e->reserved, 0, sizeof(e->reserved));\n\n\tif (e->pad > ADV7842_EDID_PORT_VGA)\n\t\treturn -EINVAL;\n\tif (e->start_block != 0)\n\t\treturn -EINVAL;\n\tif (e->pad < ADV7842_EDID_PORT_VGA && state->vga_edid.blocks)\n\t\tmax_blocks = 2;\n\tif (e->pad == ADV7842_EDID_PORT_VGA && state->hdmi_edid.blocks > 2)\n\t\treturn -EBUSY;\n\tif (e->blocks > max_blocks) {\n\t\te->blocks = max_blocks;\n\t\treturn -E2BIG;\n\t}\n\n\t \n\tif (e->blocks)\n\t\tstate->aspect_ratio = v4l2_calc_aspect_ratio(e->edid[0x15],\n\t\t\t\t\t\t\t     e->edid[0x16]);\n\n\tswitch (e->pad) {\n\tcase ADV7842_EDID_PORT_VGA:\n\t\tmemset(state->vga_edid.edid, 0, sizeof(state->vga_edid.edid));\n\t\tstate->vga_edid.blocks = e->blocks;\n\t\tstate->vga_edid.present = e->blocks ? 0x1 : 0x0;\n\t\tif (e->blocks)\n\t\t\tmemcpy(state->vga_edid.edid, e->edid, 128);\n\t\terr = edid_write_vga_segment(sd);\n\t\tbreak;\n\tcase ADV7842_EDID_PORT_A:\n\tcase ADV7842_EDID_PORT_B:\n\t\tmemset(state->hdmi_edid.edid, 0, sizeof(state->hdmi_edid.edid));\n\t\tstate->hdmi_edid.blocks = e->blocks;\n\t\tif (e->blocks) {\n\t\t\tstate->hdmi_edid.present |= 0x04 << e->pad;\n\t\t\tmemcpy(state->hdmi_edid.edid, e->edid, 128 * e->blocks);\n\t\t} else {\n\t\t\tstate->hdmi_edid.present &= ~(0x04 << e->pad);\n\t\t\tadv7842_s_detect_tx_5v_ctrl(sd);\n\t\t}\n\t\terr = edid_write_hdmi_segment(sd, e->pad);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (err < 0)\n\t\tv4l2_err(sd, \"error %d writing edid on port %d\\n\", err, e->pad);\n\treturn err;\n}\n\nstruct adv7842_cfg_read_infoframe {\n\tconst char *desc;\n\tu8 present_mask;\n\tu8 head_addr;\n\tu8 payload_addr;\n};\n\nstatic void log_infoframe(struct v4l2_subdev *sd, const struct adv7842_cfg_read_infoframe *cri)\n{\n\tint i;\n\tu8 buffer[32];\n\tunion hdmi_infoframe frame;\n\tu8 len;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct device *dev = &client->dev;\n\n\tif (!(io_read(sd, 0x60) & cri->present_mask)) {\n\t\tv4l2_info(sd, \"%s infoframe not received\\n\", cri->desc);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t\tbuffer[i] = infoframe_read(sd, cri->head_addr + i);\n\n\tlen = buffer[2] + 1;\n\n\tif (len + 3 > sizeof(buffer)) {\n\t\tv4l2_err(sd, \"%s: invalid %s infoframe length %d\\n\", __func__, cri->desc, len);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < len; i++)\n\t\tbuffer[i + 3] = infoframe_read(sd, cri->payload_addr + i);\n\n\tif (hdmi_infoframe_unpack(&frame, buffer, len + 3) < 0) {\n\t\tv4l2_err(sd, \"%s: unpack of %s infoframe failed\\n\", __func__, cri->desc);\n\t\treturn;\n\t}\n\n\thdmi_infoframe_log(KERN_INFO, dev, &frame);\n}\n\nstatic void adv7842_log_infoframes(struct v4l2_subdev *sd)\n{\n\tint i;\n\tstatic const struct adv7842_cfg_read_infoframe cri[] = {\n\t\t{ \"AVI\", 0x01, 0xe0, 0x00 },\n\t\t{ \"Audio\", 0x02, 0xe3, 0x1c },\n\t\t{ \"SDP\", 0x04, 0xe6, 0x2a },\n\t\t{ \"Vendor\", 0x10, 0xec, 0x54 }\n\t};\n\n\tif (!(hdmi_read(sd, 0x05) & 0x80)) {\n\t\tv4l2_info(sd, \"receive DVI-D signal, no infoframes\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(cri); i++)\n\t\tlog_infoframe(sd, &cri[i]);\n}\n\n#if 0\n \nstatic const char * const prim_mode_txt[] = {\n\t\"SDP\",\n\t\"Component\",\n\t\"Graphics\",\n\t\"Reserved\",\n\t\"CVBS & HDMI AUDIO\",\n\t\"HDMI-Comp\",\n\t\"HDMI-GR\",\n\t\"Reserved\",\n\t\"Reserved\",\n\t\"Reserved\",\n\t\"Reserved\",\n\t\"Reserved\",\n\t\"Reserved\",\n\t\"Reserved\",\n\t\"Reserved\",\n\t\"Reserved\",\n};\n#endif\n\nstatic int adv7842_sdp_log_status(struct v4l2_subdev *sd)\n{\n\t \n\tu8 sdp_signal_detected = sdp_read(sd, 0x5A) & 0x01;\n\n\tv4l2_info(sd, \"Chip powered %s\\n\", no_power(sd) ? \"off\" : \"on\");\n\tv4l2_info(sd, \"Prim-mode = 0x%x, video std = 0x%x\\n\",\n\t\t  io_read(sd, 0x01) & 0x0f, io_read(sd, 0x00) & 0x3f);\n\n\tv4l2_info(sd, \"SDP: free run: %s\\n\",\n\t\t(sdp_read(sd, 0x56) & 0x01) ? \"on\" : \"off\");\n\tv4l2_info(sd, \"SDP: %s\\n\", sdp_signal_detected ?\n\t\t\"valid SD/PR signal detected\" : \"invalid/no signal\");\n\tif (sdp_signal_detected) {\n\t\tstatic const char * const sdp_std_txt[] = {\n\t\t\t\"NTSC-M/J\",\n\t\t\t\"1?\",\n\t\t\t\"NTSC-443\",\n\t\t\t\"60HzSECAM\",\n\t\t\t\"PAL-M\",\n\t\t\t\"5?\",\n\t\t\t\"PAL-60\",\n\t\t\t\"7?\", \"8?\", \"9?\", \"a?\", \"b?\",\n\t\t\t\"PAL-CombN\",\n\t\t\t\"d?\",\n\t\t\t\"PAL-BGHID\",\n\t\t\t\"SECAM\"\n\t\t};\n\t\tv4l2_info(sd, \"SDP: standard %s\\n\",\n\t\t\tsdp_std_txt[sdp_read(sd, 0x52) & 0x0f]);\n\t\tv4l2_info(sd, \"SDP: %s\\n\",\n\t\t\t(sdp_read(sd, 0x59) & 0x08) ? \"50Hz\" : \"60Hz\");\n\t\tv4l2_info(sd, \"SDP: %s\\n\",\n\t\t\t(sdp_read(sd, 0x57) & 0x08) ? \"Interlaced\" : \"Progressive\");\n\t\tv4l2_info(sd, \"SDP: deinterlacer %s\\n\",\n\t\t\t(sdp_read(sd, 0x12) & 0x08) ? \"enabled\" : \"disabled\");\n\t\tv4l2_info(sd, \"SDP: csc %s mode\\n\",\n\t\t\t(sdp_io_read(sd, 0xe0) & 0x40) ? \"auto\" : \"manual\");\n\t}\n\treturn 0;\n}\n\nstatic int adv7842_cp_log_status(struct v4l2_subdev *sd)\n{\n\t \n\tstruct adv7842_state *state = to_state(sd);\n\tstruct v4l2_dv_timings timings;\n\tu8 reg_io_0x02 = io_read(sd, 0x02);\n\tu8 reg_io_0x21 = io_read(sd, 0x21);\n\tu8 reg_rep_0x77 = rep_read(sd, 0x77);\n\tu8 reg_rep_0x7d = rep_read(sd, 0x7d);\n\tbool audio_pll_locked = hdmi_read(sd, 0x04) & 0x01;\n\tbool audio_sample_packet_detect = hdmi_read(sd, 0x18) & 0x01;\n\tbool audio_mute = io_read(sd, 0x65) & 0x40;\n\n\tstatic const char * const csc_coeff_sel_rb[16] = {\n\t\t\"bypassed\", \"YPbPr601 -> RGB\", \"reserved\", \"YPbPr709 -> RGB\",\n\t\t\"reserved\", \"RGB -> YPbPr601\", \"reserved\", \"RGB -> YPbPr709\",\n\t\t\"reserved\", \"YPbPr709 -> YPbPr601\", \"YPbPr601 -> YPbPr709\",\n\t\t\"reserved\", \"reserved\", \"reserved\", \"reserved\", \"manual\"\n\t};\n\tstatic const char * const input_color_space_txt[16] = {\n\t\t\"RGB limited range (16-235)\", \"RGB full range (0-255)\",\n\t\t\"YCbCr Bt.601 (16-235)\", \"YCbCr Bt.709 (16-235)\",\n\t\t\"xvYCC Bt.601\", \"xvYCC Bt.709\",\n\t\t\"YCbCr Bt.601 (0-255)\", \"YCbCr Bt.709 (0-255)\",\n\t\t\"invalid\", \"invalid\", \"invalid\", \"invalid\", \"invalid\",\n\t\t\"invalid\", \"invalid\", \"automatic\"\n\t};\n\tstatic const char * const rgb_quantization_range_txt[] = {\n\t\t\"Automatic\",\n\t\t\"RGB limited range (16-235)\",\n\t\t\"RGB full range (0-255)\",\n\t};\n\tstatic const char * const deep_color_mode_txt[4] = {\n\t\t\"8-bits per channel\",\n\t\t\"10-bits per channel\",\n\t\t\"12-bits per channel\",\n\t\t\"16-bits per channel (not supported)\"\n\t};\n\n\tv4l2_info(sd, \"-----Chip status-----\\n\");\n\tv4l2_info(sd, \"Chip power: %s\\n\", no_power(sd) ? \"off\" : \"on\");\n\tv4l2_info(sd, \"HDMI/DVI-D port selected: %s\\n\",\n\t\t\tstate->hdmi_port_a ? \"A\" : \"B\");\n\tv4l2_info(sd, \"EDID A %s, B %s\\n\",\n\t\t  ((reg_rep_0x7d & 0x04) && (reg_rep_0x77 & 0x04)) ?\n\t\t  \"enabled\" : \"disabled\",\n\t\t  ((reg_rep_0x7d & 0x08) && (reg_rep_0x77 & 0x08)) ?\n\t\t  \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"HPD A %s, B %s\\n\",\n\t\t  reg_io_0x21 & 0x02 ? \"enabled\" : \"disabled\",\n\t\t  reg_io_0x21 & 0x01 ? \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"CEC: %s\\n\", state->cec_enabled_adap ?\n\t\t\t\"enabled\" : \"disabled\");\n\tif (state->cec_enabled_adap) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ADV7842_MAX_ADDRS; i++) {\n\t\t\tbool is_valid = state->cec_valid_addrs & (1 << i);\n\n\t\t\tif (is_valid)\n\t\t\t\tv4l2_info(sd, \"CEC Logical Address: 0x%x\\n\",\n\t\t\t\t\t  state->cec_addr[i]);\n\t\t}\n\t}\n\n\tv4l2_info(sd, \"-----Signal status-----\\n\");\n\tif (state->hdmi_port_a) {\n\t\tv4l2_info(sd, \"Cable detected (+5V power): %s\\n\",\n\t\t\t  io_read(sd, 0x6f) & 0x02 ? \"true\" : \"false\");\n\t\tv4l2_info(sd, \"TMDS signal detected: %s\\n\",\n\t\t\t  (io_read(sd, 0x6a) & 0x02) ? \"true\" : \"false\");\n\t\tv4l2_info(sd, \"TMDS signal locked: %s\\n\",\n\t\t\t  (io_read(sd, 0x6a) & 0x20) ? \"true\" : \"false\");\n\t} else {\n\t\tv4l2_info(sd, \"Cable detected (+5V power):%s\\n\",\n\t\t\t  io_read(sd, 0x6f) & 0x01 ? \"true\" : \"false\");\n\t\tv4l2_info(sd, \"TMDS signal detected: %s\\n\",\n\t\t\t  (io_read(sd, 0x6a) & 0x01) ? \"true\" : \"false\");\n\t\tv4l2_info(sd, \"TMDS signal locked: %s\\n\",\n\t\t\t  (io_read(sd, 0x6a) & 0x10) ? \"true\" : \"false\");\n\t}\n\tv4l2_info(sd, \"CP free run: %s\\n\",\n\t\t  (!!(cp_read(sd, 0xff) & 0x10) ? \"on\" : \"off\"));\n\tv4l2_info(sd, \"Prim-mode = 0x%x, video std = 0x%x, v_freq = 0x%x\\n\",\n\t\t  io_read(sd, 0x01) & 0x0f, io_read(sd, 0x00) & 0x3f,\n\t\t  (io_read(sd, 0x01) & 0x70) >> 4);\n\n\tv4l2_info(sd, \"-----Video Timings-----\\n\");\n\tif (no_cp_signal(sd)) {\n\t\tv4l2_info(sd, \"STDI: not locked\\n\");\n\t} else {\n\t\tu32 bl = ((cp_read(sd, 0xb1) & 0x3f) << 8) | cp_read(sd, 0xb2);\n\t\tu32 lcf = ((cp_read(sd, 0xb3) & 0x7) << 8) | cp_read(sd, 0xb4);\n\t\tu32 lcvs = cp_read(sd, 0xb3) >> 3;\n\t\tu32 fcl = ((cp_read(sd, 0xb8) & 0x1f) << 8) | cp_read(sd, 0xb9);\n\t\tchar hs_pol = ((cp_read(sd, 0xb5) & 0x10) ?\n\t\t\t\t((cp_read(sd, 0xb5) & 0x08) ? '+' : '-') : 'x');\n\t\tchar vs_pol = ((cp_read(sd, 0xb5) & 0x40) ?\n\t\t\t\t((cp_read(sd, 0xb5) & 0x20) ? '+' : '-') : 'x');\n\t\tv4l2_info(sd,\n\t\t\t\"STDI: lcf (frame height - 1) = %d, bl = %d, lcvs (vsync) = %d, fcl = %d, %s, %chsync, %cvsync\\n\",\n\t\t\tlcf, bl, lcvs, fcl,\n\t\t\t(cp_read(sd, 0xb1) & 0x40) ?\n\t\t\t\t\"interlaced\" : \"progressive\",\n\t\t\ths_pol, vs_pol);\n\t}\n\tif (adv7842_query_dv_timings(sd, &timings))\n\t\tv4l2_info(sd, \"No video detected\\n\");\n\telse\n\t\tv4l2_print_dv_timings(sd->name, \"Detected format: \",\n\t\t\t\t      &timings, true);\n\tv4l2_print_dv_timings(sd->name, \"Configured format: \",\n\t\t\t&state->timings, true);\n\n\tif (no_cp_signal(sd))\n\t\treturn 0;\n\n\tv4l2_info(sd, \"-----Color space-----\\n\");\n\tv4l2_info(sd, \"RGB quantization range ctrl: %s\\n\",\n\t\t  rgb_quantization_range_txt[state->rgb_quantization_range]);\n\tv4l2_info(sd, \"Input color space: %s\\n\",\n\t\t  input_color_space_txt[reg_io_0x02 >> 4]);\n\tv4l2_info(sd, \"Output color space: %s %s, alt-gamma %s\\n\",\n\t\t  (reg_io_0x02 & 0x02) ? \"RGB\" : \"YCbCr\",\n\t\t  (((reg_io_0x02 >> 2) & 0x01) ^ (reg_io_0x02 & 0x01)) ?\n\t\t\t\"(16-235)\" : \"(0-255)\",\n\t\t  (reg_io_0x02 & 0x08) ? \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"Color space conversion: %s\\n\",\n\t\t  csc_coeff_sel_rb[cp_read(sd, 0xf4) >> 4]);\n\n\tif (!is_digital_input(sd))\n\t\treturn 0;\n\n\tv4l2_info(sd, \"-----%s status-----\\n\", is_hdmi(sd) ? \"HDMI\" : \"DVI-D\");\n\tv4l2_info(sd, \"HDCP encrypted content: %s\\n\",\n\t\t\t(hdmi_read(sd, 0x05) & 0x40) ? \"true\" : \"false\");\n\tv4l2_info(sd, \"HDCP keys read: %s%s\\n\",\n\t\t\t(hdmi_read(sd, 0x04) & 0x20) ? \"yes\" : \"no\",\n\t\t\t(hdmi_read(sd, 0x04) & 0x10) ? \"ERROR\" : \"\");\n\tif (!is_hdmi(sd))\n\t\treturn 0;\n\n\tv4l2_info(sd, \"Audio: pll %s, samples %s, %s\\n\",\n\t\t\taudio_pll_locked ? \"locked\" : \"not locked\",\n\t\t\taudio_sample_packet_detect ? \"detected\" : \"not detected\",\n\t\t\taudio_mute ? \"muted\" : \"enabled\");\n\tif (audio_pll_locked && audio_sample_packet_detect) {\n\t\tv4l2_info(sd, \"Audio format: %s\\n\",\n\t\t\t(hdmi_read(sd, 0x07) & 0x40) ? \"multi-channel\" : \"stereo\");\n\t}\n\tv4l2_info(sd, \"Audio CTS: %u\\n\", (hdmi_read(sd, 0x5b) << 12) +\n\t\t\t(hdmi_read(sd, 0x5c) << 8) +\n\t\t\t(hdmi_read(sd, 0x5d) & 0xf0));\n\tv4l2_info(sd, \"Audio N: %u\\n\", ((hdmi_read(sd, 0x5d) & 0x0f) << 16) +\n\t\t\t(hdmi_read(sd, 0x5e) << 8) +\n\t\t\thdmi_read(sd, 0x5f));\n\tv4l2_info(sd, \"AV Mute: %s\\n\",\n\t\t\t(hdmi_read(sd, 0x04) & 0x40) ? \"on\" : \"off\");\n\tv4l2_info(sd, \"Deep color mode: %s\\n\",\n\t\t\tdeep_color_mode_txt[hdmi_read(sd, 0x0b) >> 6]);\n\n\tadv7842_log_infoframes(sd);\n\n\treturn 0;\n}\n\nstatic int adv7842_log_status(struct v4l2_subdev *sd)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\tif (state->mode == ADV7842_MODE_SDP)\n\t\treturn adv7842_sdp_log_status(sd);\n\treturn adv7842_cp_log_status(sd);\n}\n\nstatic int adv7842_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\tv4l2_dbg(1, debug, sd, \"%s:\\n\", __func__);\n\n\tif (state->mode != ADV7842_MODE_SDP)\n\t\treturn -ENODATA;\n\n\tif (!(sdp_read(sd, 0x5A) & 0x01)) {\n\t\t*std = 0;\n\t\tv4l2_dbg(1, debug, sd, \"%s: no valid signal\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tswitch (sdp_read(sd, 0x52) & 0x0f) {\n\tcase 0:\n\t\t \n\t\t*std &= V4L2_STD_NTSC;\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\t*std &= V4L2_STD_NTSC_443;\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\t*std &= V4L2_STD_SECAM;\n\t\tbreak;\n\tcase 4:\n\t\t \n\t\t*std &= V4L2_STD_PAL_M;\n\t\tbreak;\n\tcase 6:\n\t\t \n\t\t*std &= V4L2_STD_PAL_60;\n\t\tbreak;\n\tcase 0xc:\n\t\t \n\t\t*std &= V4L2_STD_PAL_Nc;\n\t\tbreak;\n\tcase 0xe:\n\t\t \n\t\t*std &= V4L2_STD_PAL;\n\t\tbreak;\n\tcase 0xf:\n\t\t \n\t\t*std &= V4L2_STD_SECAM;\n\t\tbreak;\n\tdefault:\n\t\t*std &= V4L2_STD_ALL;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void adv7842_s_sdp_io(struct v4l2_subdev *sd, struct adv7842_sdp_io_sync_adjustment *s)\n{\n\tif (s && s->adjust) {\n\t\tsdp_io_write(sd, 0x94, (s->hs_beg >> 8) & 0xf);\n\t\tsdp_io_write(sd, 0x95, s->hs_beg & 0xff);\n\t\tsdp_io_write(sd, 0x96, (s->hs_width >> 8) & 0xf);\n\t\tsdp_io_write(sd, 0x97, s->hs_width & 0xff);\n\t\tsdp_io_write(sd, 0x98, (s->de_beg >> 8) & 0xf);\n\t\tsdp_io_write(sd, 0x99, s->de_beg & 0xff);\n\t\tsdp_io_write(sd, 0x9a, (s->de_end >> 8) & 0xf);\n\t\tsdp_io_write(sd, 0x9b, s->de_end & 0xff);\n\t\tsdp_io_write(sd, 0xa8, s->vs_beg_o);\n\t\tsdp_io_write(sd, 0xa9, s->vs_beg_e);\n\t\tsdp_io_write(sd, 0xaa, s->vs_end_o);\n\t\tsdp_io_write(sd, 0xab, s->vs_end_e);\n\t\tsdp_io_write(sd, 0xac, s->de_v_beg_o);\n\t\tsdp_io_write(sd, 0xad, s->de_v_beg_e);\n\t\tsdp_io_write(sd, 0xae, s->de_v_end_o);\n\t\tsdp_io_write(sd, 0xaf, s->de_v_end_e);\n\t} else {\n\t\t \n\t\tsdp_io_write(sd, 0x94, 0x00);\n\t\tsdp_io_write(sd, 0x95, 0x00);\n\t\tsdp_io_write(sd, 0x96, 0x00);\n\t\tsdp_io_write(sd, 0x97, 0x20);\n\t\tsdp_io_write(sd, 0x98, 0x00);\n\t\tsdp_io_write(sd, 0x99, 0x00);\n\t\tsdp_io_write(sd, 0x9a, 0x00);\n\t\tsdp_io_write(sd, 0x9b, 0x00);\n\t\tsdp_io_write(sd, 0xa8, 0x04);\n\t\tsdp_io_write(sd, 0xa9, 0x04);\n\t\tsdp_io_write(sd, 0xaa, 0x04);\n\t\tsdp_io_write(sd, 0xab, 0x04);\n\t\tsdp_io_write(sd, 0xac, 0x04);\n\t\tsdp_io_write(sd, 0xad, 0x04);\n\t\tsdp_io_write(sd, 0xae, 0x04);\n\t\tsdp_io_write(sd, 0xaf, 0x04);\n\t}\n}\n\nstatic int adv7842_s_std(struct v4l2_subdev *sd, v4l2_std_id norm)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\tstruct adv7842_platform_data *pdata = &state->pdata;\n\n\tv4l2_dbg(1, debug, sd, \"%s:\\n\", __func__);\n\n\tif (state->mode != ADV7842_MODE_SDP)\n\t\treturn -ENODATA;\n\n\tif (norm & V4L2_STD_625_50)\n\t\tadv7842_s_sdp_io(sd, &pdata->sdp_io_sync_625);\n\telse if (norm & V4L2_STD_525_60)\n\t\tadv7842_s_sdp_io(sd, &pdata->sdp_io_sync_525);\n\telse\n\t\tadv7842_s_sdp_io(sd, NULL);\n\n\tif (norm & V4L2_STD_ALL) {\n\t\tstate->norm = norm;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int adv7842_g_std(struct v4l2_subdev *sd, v4l2_std_id *norm)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\tv4l2_dbg(1, debug, sd, \"%s:\\n\", __func__);\n\n\tif (state->mode != ADV7842_MODE_SDP)\n\t\treturn -ENODATA;\n\n\t*norm = state->norm;\n\treturn 0;\n}\n\n \n\nstatic int adv7842_core_init(struct v4l2_subdev *sd)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\tstruct adv7842_platform_data *pdata = &state->pdata;\n\thdmi_write(sd, 0x48,\n\t\t   (pdata->disable_pwrdnb ? 0x80 : 0) |\n\t\t   (pdata->disable_cable_det_rst ? 0x40 : 0));\n\n\tdisable_input(sd);\n\n\t \n\trep_write_and_or(sd, 0x77, 0xd3, 0x20);\n\n\t \n\tio_write(sd, 0x0c, 0x42);    \n\tio_write(sd, 0x15, 0x80);    \n\n\t \n\tio_write(sd, 0x02, 0xf0 | pdata->alt_gamma << 3);\n\tio_write_and_or(sd, 0x05, 0xf0, pdata->blank_data << 3 |\n\t\t\tpdata->insert_av_codes << 2 |\n\t\t\tpdata->replicate_av_codes << 1);\n\tadv7842_setup_format(state);\n\n\t \n\thdmi_write_and_or(sd, 0x1a, 0xf1, 0x08);  \n\n\t \n\tio_write_and_or(sd, 0x14, 0xc0,\n\t\t\tpdata->dr_str_data << 4 |\n\t\t\tpdata->dr_str_clk << 2 |\n\t\t\tpdata->dr_str_sync);\n\n\t \n\tcp_write_and_or(sd, 0xba, 0xfc, pdata->hdmi_free_run_enable |\n\t\t\t\t\t(pdata->hdmi_free_run_mode << 1));\n\n\t \n\tsdp_write_and_or(sd, 0xdd, 0xf0, pdata->sdp_free_run_force |\n\t\t\t\t\t (pdata->sdp_free_run_cbar_en << 1) |\n\t\t\t\t\t (pdata->sdp_free_run_man_col_en << 2) |\n\t\t\t\t\t (pdata->sdp_free_run_auto << 3));\n\n\t \n\tcp_write(sd, 0x69, 0x14);    \n\tio_write(sd, 0x06, 0xa6);    \n\tcp_write(sd, 0xf3, 0xdc);  \n\tafe_write(sd, 0xb5, 0x01);   \n\n\tafe_write(sd, 0x02, pdata->ain_sel);  \n\tio_write_and_or(sd, 0x30, ~(1 << 4), pdata->output_bus_lsb_to_msb << 4);\n\n\tsdp_csc_coeff(sd, &pdata->sdp_csc_coeff);\n\n\t \n\tif (pdata->sd_ram_size >= 128) {\n\t\tsdp_write(sd, 0x12, 0x0d);  \n\t\tif (pdata->sd_ram_ddr) {\n\t\t\t \n\t\t\tsdp_io_write(sd, 0x6f, 0x00);  \n\t\t\tsdp_io_write(sd, 0x75, 0x0a);  \n\t\t\tsdp_io_write(sd, 0x7a, 0xa5);  \n\t\t\tsdp_io_write(sd, 0x7b, 0x8f);  \n\t\t\tsdp_io_write(sd, 0x60, 0x01);  \n\t\t} else {\n\t\t\tsdp_io_write(sd, 0x75, 0x0a);  \n\t\t\tsdp_io_write(sd, 0x74, 0x00);  \n\t\t\tsdp_io_write(sd, 0x79, 0x33);  \n\t\t\tsdp_io_write(sd, 0x6f, 0x01);  \n\t\t\tsdp_io_write(sd, 0x7a, 0xa5);  \n\t\t\tsdp_io_write(sd, 0x7b, 0x8f);  \n\t\t\tsdp_io_write(sd, 0x60, 0x01);  \n\t\t}\n\t} else {\n\t\t \n\t\tsdp_io_write(sd, 0x29, 0x10);  \n\t}\n\n\tselect_input(sd, pdata->vid_std_select);\n\n\tenable_input(sd);\n\n\tif (pdata->hpa_auto) {\n\t\t \n\t\thdmi_write(sd, 0x69, 0x5c);\n\t} else {\n\t\t \n\t\thdmi_write(sd, 0x69, 0xa3);\n\t\t \n\t\tio_write_and_or(sd, 0x20, 0xcf, 0x00);\n\t}\n\n\t \n\tio_write(sd, 0x19, 0x80 | pdata->llc_dll_phase);\n\tio_write(sd, 0x33, 0x40);\n\n\t \n\tio_write(sd, 0x40, 0xf2);  \n\n\tadv7842_irq_enable(sd, true);\n\n\treturn v4l2_ctrl_handler_setup(sd->ctrl_handler);\n}\n\n \n\nstatic int adv7842_ddr_ram_test(struct v4l2_subdev *sd)\n{\n\t \n\tint i;\n\tint pass = 0;\n\tint fail = 0;\n\tint complete = 0;\n\n\tio_write(sd, 0x00, 0x01);   \n\tio_write(sd, 0x01, 0x00);   \n\tafe_write(sd, 0x80, 0x92);  \n\tafe_write(sd, 0x9B, 0x01);  \n\tafe_write(sd, 0x9C, 0x60);  \n\tafe_write(sd, 0x9E, 0x02);  \n\tafe_write(sd, 0xA0, 0x0B);  \n\tafe_write(sd, 0xC3, 0x02);  \n\tio_write(sd, 0x0C, 0x40);   \n\tio_write(sd, 0x15, 0xBA);   \n\tsdp_write(sd, 0x12, 0x00);  \n\tio_write(sd, 0xFF, 0x04);   \n\n\tusleep_range(5000, 6000);\n\n\tsdp_write(sd, 0x12, 0x00);     \n\tsdp_io_write(sd, 0x2A, 0x01);  \n\tsdp_io_write(sd, 0x7c, 0x19);  \n\tsdp_io_write(sd, 0x80, 0x87);  \n\tsdp_io_write(sd, 0x81, 0x4a);  \n\tsdp_io_write(sd, 0x82, 0x2c);  \n\tsdp_io_write(sd, 0x83, 0x0e);  \n\tsdp_io_write(sd, 0x84, 0x94);  \n\tsdp_io_write(sd, 0x85, 0x62);  \n\tsdp_io_write(sd, 0x7d, 0x00);  \n\tsdp_io_write(sd, 0x7e, 0x1a);  \n\n\tusleep_range(5000, 6000);\n\n\tsdp_io_write(sd, 0xd9, 0xd5);  \n\tsdp_write(sd, 0x12, 0x05);  \n\n\tmsleep(20);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tu8 result = sdp_io_read(sd, 0xdb);\n\t\tif (result & 0x10) {\n\t\t\tcomplete++;\n\t\t\tif (result & 0x20)\n\t\t\t\tfail++;\n\t\t\telse\n\t\t\t\tpass++;\n\t\t}\n\t\tmsleep(20);\n\t}\n\n\tv4l2_dbg(1, debug, sd,\n\t\t\"Ram Test: completed %d of %d: pass %d, fail %d\\n\",\n\t\tcomplete, i, pass, fail);\n\n\tif (!complete || fail)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic void adv7842_rewrite_i2c_addresses(struct v4l2_subdev *sd,\n\t\tstruct adv7842_platform_data *pdata)\n{\n\tio_write(sd, 0xf1, pdata->i2c_sdp << 1);\n\tio_write(sd, 0xf2, pdata->i2c_sdp_io << 1);\n\tio_write(sd, 0xf3, pdata->i2c_avlink << 1);\n\tio_write(sd, 0xf4, pdata->i2c_cec << 1);\n\tio_write(sd, 0xf5, pdata->i2c_infoframe << 1);\n\n\tio_write(sd, 0xf8, pdata->i2c_afe << 1);\n\tio_write(sd, 0xf9, pdata->i2c_repeater << 1);\n\tio_write(sd, 0xfa, pdata->i2c_edid << 1);\n\tio_write(sd, 0xfb, pdata->i2c_hdmi << 1);\n\n\tio_write(sd, 0xfd, pdata->i2c_cp << 1);\n\tio_write(sd, 0xfe, pdata->i2c_vdp << 1);\n}\n\nstatic int adv7842_command_ram_test(struct v4l2_subdev *sd)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct adv7842_state *state = to_state(sd);\n\tstruct adv7842_platform_data *pdata = client->dev.platform_data;\n\tstruct v4l2_dv_timings timings;\n\tint ret = 0;\n\n\tif (!pdata)\n\t\treturn -ENODEV;\n\n\tif (!pdata->sd_ram_size || !pdata->sd_ram_ddr) {\n\t\tv4l2_info(sd, \"no sdram or no ddr sdram\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmain_reset(sd);\n\n\tadv7842_rewrite_i2c_addresses(sd, pdata);\n\n\t \n\tret = adv7842_ddr_ram_test(sd);\n\n\tmain_reset(sd);\n\n\tadv7842_rewrite_i2c_addresses(sd, pdata);\n\n\t \n\tadv7842_core_init(sd);\n\n\tdisable_input(sd);\n\n\tselect_input(sd, state->vid_std_select);\n\n\tenable_input(sd);\n\n\tedid_write_vga_segment(sd);\n\tedid_write_hdmi_segment(sd, ADV7842_EDID_PORT_A);\n\tedid_write_hdmi_segment(sd, ADV7842_EDID_PORT_B);\n\n\ttimings = state->timings;\n\n\tmemset(&state->timings, 0, sizeof(struct v4l2_dv_timings));\n\n\tadv7842_s_dv_timings(sd, &timings);\n\n\treturn ret;\n}\n\nstatic long adv7842_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\n{\n\tswitch (cmd) {\n\tcase ADV7842_CMD_RAM_TEST:\n\t\treturn adv7842_command_ram_test(sd);\n\t}\n\treturn -ENOTTY;\n}\n\nstatic int adv7842_subscribe_event(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_fh *fh,\n\t\t\t\t   struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\treturn v4l2_src_change_event_subdev_subscribe(sd, fh, sub);\n\tcase V4L2_EVENT_CTRL:\n\t\treturn v4l2_ctrl_subdev_subscribe_event(sd, fh, sub);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adv7842_registered(struct v4l2_subdev *sd)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint err;\n\n\terr = cec_register_adapter(state->cec_adap, &client->dev);\n\tif (err)\n\t\tcec_delete_adapter(state->cec_adap);\n\treturn err;\n}\n\nstatic void adv7842_unregistered(struct v4l2_subdev *sd)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\n\tcec_unregister_adapter(state->cec_adap);\n}\n\n \n\nstatic const struct v4l2_ctrl_ops adv7842_ctrl_ops = {\n\t.s_ctrl = adv7842_s_ctrl,\n\t.g_volatile_ctrl = adv7842_g_volatile_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops adv7842_core_ops = {\n\t.log_status = adv7842_log_status,\n\t.ioctl = adv7842_ioctl,\n\t.interrupt_service_routine = adv7842_isr,\n\t.subscribe_event = adv7842_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = adv7842_g_register,\n\t.s_register = adv7842_s_register,\n#endif\n};\n\nstatic const struct v4l2_subdev_video_ops adv7842_video_ops = {\n\t.g_std = adv7842_g_std,\n\t.s_std = adv7842_s_std,\n\t.s_routing = adv7842_s_routing,\n\t.querystd = adv7842_querystd,\n\t.g_input_status = adv7842_g_input_status,\n\t.s_dv_timings = adv7842_s_dv_timings,\n\t.g_dv_timings = adv7842_g_dv_timings,\n\t.query_dv_timings = adv7842_query_dv_timings,\n};\n\nstatic const struct v4l2_subdev_pad_ops adv7842_pad_ops = {\n\t.enum_mbus_code = adv7842_enum_mbus_code,\n\t.get_fmt = adv7842_get_format,\n\t.set_fmt = adv7842_set_format,\n\t.get_edid = adv7842_get_edid,\n\t.set_edid = adv7842_set_edid,\n\t.enum_dv_timings = adv7842_enum_dv_timings,\n\t.dv_timings_cap = adv7842_dv_timings_cap,\n};\n\nstatic const struct v4l2_subdev_ops adv7842_ops = {\n\t.core = &adv7842_core_ops,\n\t.video = &adv7842_video_ops,\n\t.pad = &adv7842_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops adv7842_int_ops = {\n\t.registered = adv7842_registered,\n\t.unregistered = adv7842_unregistered,\n};\n\n \n\nstatic const struct v4l2_ctrl_config adv7842_ctrl_analog_sampling_phase = {\n\t.ops = &adv7842_ctrl_ops,\n\t.id = V4L2_CID_ADV_RX_ANALOG_SAMPLING_PHASE,\n\t.name = \"Analog Sampling Phase\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.min = 0,\n\t.max = 0x1f,\n\t.step = 1,\n\t.def = 0,\n};\n\nstatic const struct v4l2_ctrl_config adv7842_ctrl_free_run_color_manual = {\n\t.ops = &adv7842_ctrl_ops,\n\t.id = V4L2_CID_ADV_RX_FREE_RUN_COLOR_MANUAL,\n\t.name = \"Free Running Color, Manual\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.step = 1,\n\t.def = 1,\n};\n\nstatic const struct v4l2_ctrl_config adv7842_ctrl_free_run_color = {\n\t.ops = &adv7842_ctrl_ops,\n\t.id = V4L2_CID_ADV_RX_FREE_RUN_COLOR,\n\t.name = \"Free Running Color\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.max = 0xffffff,\n\t.step = 0x1,\n};\n\n\nstatic void adv7842_unregister_clients(struct v4l2_subdev *sd)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\ti2c_unregister_device(state->i2c_avlink);\n\ti2c_unregister_device(state->i2c_cec);\n\ti2c_unregister_device(state->i2c_infoframe);\n\ti2c_unregister_device(state->i2c_sdp_io);\n\ti2c_unregister_device(state->i2c_sdp);\n\ti2c_unregister_device(state->i2c_afe);\n\ti2c_unregister_device(state->i2c_repeater);\n\ti2c_unregister_device(state->i2c_edid);\n\ti2c_unregister_device(state->i2c_hdmi);\n\ti2c_unregister_device(state->i2c_cp);\n\ti2c_unregister_device(state->i2c_vdp);\n\n\tstate->i2c_avlink = NULL;\n\tstate->i2c_cec = NULL;\n\tstate->i2c_infoframe = NULL;\n\tstate->i2c_sdp_io = NULL;\n\tstate->i2c_sdp = NULL;\n\tstate->i2c_afe = NULL;\n\tstate->i2c_repeater = NULL;\n\tstate->i2c_edid = NULL;\n\tstate->i2c_hdmi = NULL;\n\tstate->i2c_cp = NULL;\n\tstate->i2c_vdp = NULL;\n}\n\nstatic struct i2c_client *adv7842_dummy_client(struct v4l2_subdev *sd, const char *desc,\n\t\t\t\t\t       u8 addr, u8 io_reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct i2c_client *cp;\n\n\tio_write(sd, io_reg, addr << 1);\n\n\tif (addr == 0) {\n\t\tv4l2_err(sd, \"no %s i2c addr configured\\n\", desc);\n\t\treturn NULL;\n\t}\n\n\tcp = i2c_new_dummy_device(client->adapter, io_read(sd, io_reg) >> 1);\n\tif (IS_ERR(cp)) {\n\t\tv4l2_err(sd, \"register %s on i2c addr 0x%x failed with %ld\\n\",\n\t\t\t desc, addr, PTR_ERR(cp));\n\t\tcp = NULL;\n\t}\n\n\treturn cp;\n}\n\nstatic int adv7842_register_clients(struct v4l2_subdev *sd)\n{\n\tstruct adv7842_state *state = to_state(sd);\n\tstruct adv7842_platform_data *pdata = &state->pdata;\n\n\tstate->i2c_avlink = adv7842_dummy_client(sd, \"avlink\", pdata->i2c_avlink, 0xf3);\n\tstate->i2c_cec = adv7842_dummy_client(sd, \"cec\", pdata->i2c_cec, 0xf4);\n\tstate->i2c_infoframe = adv7842_dummy_client(sd, \"infoframe\", pdata->i2c_infoframe, 0xf5);\n\tstate->i2c_sdp_io = adv7842_dummy_client(sd, \"sdp_io\", pdata->i2c_sdp_io, 0xf2);\n\tstate->i2c_sdp = adv7842_dummy_client(sd, \"sdp\", pdata->i2c_sdp, 0xf1);\n\tstate->i2c_afe = adv7842_dummy_client(sd, \"afe\", pdata->i2c_afe, 0xf8);\n\tstate->i2c_repeater = adv7842_dummy_client(sd, \"repeater\", pdata->i2c_repeater, 0xf9);\n\tstate->i2c_edid = adv7842_dummy_client(sd, \"edid\", pdata->i2c_edid, 0xfa);\n\tstate->i2c_hdmi = adv7842_dummy_client(sd, \"hdmi\", pdata->i2c_hdmi, 0xfb);\n\tstate->i2c_cp = adv7842_dummy_client(sd, \"cp\", pdata->i2c_cp, 0xfd);\n\tstate->i2c_vdp = adv7842_dummy_client(sd, \"vdp\", pdata->i2c_vdp, 0xfe);\n\n\tif (!state->i2c_avlink ||\n\t    !state->i2c_cec ||\n\t    !state->i2c_infoframe ||\n\t    !state->i2c_sdp_io ||\n\t    !state->i2c_sdp ||\n\t    !state->i2c_afe ||\n\t    !state->i2c_repeater ||\n\t    !state->i2c_edid ||\n\t    !state->i2c_hdmi ||\n\t    !state->i2c_cp ||\n\t    !state->i2c_vdp)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int adv7842_probe(struct i2c_client *client)\n{\n\tstruct adv7842_state *state;\n\tstatic const struct v4l2_dv_timings cea640x480 =\n\t\tV4L2_DV_BT_CEA_640X480P59_94;\n\tstruct adv7842_platform_data *pdata = client->dev.platform_data;\n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct v4l2_ctrl *ctrl;\n\tstruct v4l2_subdev *sd;\n\tunsigned int i;\n\tu16 rev;\n\tint err;\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tv4l_dbg(1, debug, client, \"detecting adv7842 client on address 0x%x\\n\",\n\t\tclient->addr << 1);\n\n\tif (!pdata) {\n\t\tv4l_err(client, \"No platform data!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tstate = devm_kzalloc(&client->dev, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\t \n\tstate->pdata = *pdata;\n\tstate->timings = cea640x480;\n\tstate->format = adv7842_format_info(state, MEDIA_BUS_FMT_YUYV8_2X8);\n\n\tsd = &state->sd;\n\tv4l2_i2c_subdev_init(sd, client, &adv7842_ops);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;\n\tsd->internal_ops = &adv7842_int_ops;\n\tstate->mode = pdata->mode;\n\n\tstate->hdmi_port_a = pdata->input == ADV7842_SELECT_HDMI_PORT_A;\n\tstate->restart_stdi_once = true;\n\n\t \n\trev = adv_smbus_read_byte_data_check(client, 0xea, false) << 8 |\n\t\tadv_smbus_read_byte_data_check(client, 0xeb, false);\n\tif (rev != 0x2012) {\n\t\tv4l2_info(sd, \"got rev=0x%04x on first read attempt\\n\", rev);\n\t\trev = adv_smbus_read_byte_data_check(client, 0xea, false) << 8 |\n\t\t\tadv_smbus_read_byte_data_check(client, 0xeb, false);\n\t}\n\tif (rev != 0x2012) {\n\t\tv4l2_info(sd, \"not an adv7842 on address 0x%x (rev=0x%04x)\\n\",\n\t\t\t  client->addr << 1, rev);\n\t\treturn -ENODEV;\n\t}\n\n\tif (pdata->chip_reset)\n\t\tmain_reset(sd);\n\n\t \n\thdl = &state->hdl;\n\tv4l2_ctrl_handler_init(hdl, 6);\n\n\t \n\tv4l2_ctrl_new_std(hdl, &adv7842_ctrl_ops,\n\t\t\t  V4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &adv7842_ctrl_ops,\n\t\t\t  V4L2_CID_CONTRAST, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(hdl, &adv7842_ctrl_ops,\n\t\t\t  V4L2_CID_SATURATION, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(hdl, &adv7842_ctrl_ops,\n\t\t\t  V4L2_CID_HUE, 0, 128, 1, 0);\n\tctrl = v4l2_ctrl_new_std_menu(hdl, &adv7842_ctrl_ops,\n\t\t\tV4L2_CID_DV_RX_IT_CONTENT_TYPE, V4L2_DV_IT_CONTENT_TYPE_NO_ITC,\n\t\t\t0, V4L2_DV_IT_CONTENT_TYPE_NO_ITC);\n\tif (ctrl)\n\t\tctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\n\t \n\tstate->detect_tx_5v_ctrl = v4l2_ctrl_new_std(hdl, NULL,\n\t\t\tV4L2_CID_DV_RX_POWER_PRESENT, 0, 3, 0, 0);\n\tstate->analog_sampling_phase_ctrl = v4l2_ctrl_new_custom(hdl,\n\t\t\t&adv7842_ctrl_analog_sampling_phase, NULL);\n\tstate->free_run_color_ctrl_manual = v4l2_ctrl_new_custom(hdl,\n\t\t\t&adv7842_ctrl_free_run_color_manual, NULL);\n\tstate->free_run_color_ctrl = v4l2_ctrl_new_custom(hdl,\n\t\t\t&adv7842_ctrl_free_run_color, NULL);\n\tstate->rgb_quantization_range_ctrl =\n\t\tv4l2_ctrl_new_std_menu(hdl, &adv7842_ctrl_ops,\n\t\t\tV4L2_CID_DV_RX_RGB_RANGE, V4L2_DV_RGB_RANGE_FULL,\n\t\t\t0, V4L2_DV_RGB_RANGE_AUTO);\n\tsd->ctrl_handler = hdl;\n\tif (hdl->error) {\n\t\terr = hdl->error;\n\t\tgoto err_hdl;\n\t}\n\tif (adv7842_s_detect_tx_5v_ctrl(sd)) {\n\t\terr = -ENODEV;\n\t\tgoto err_hdl;\n\t}\n\n\tif (adv7842_register_clients(sd) < 0) {\n\t\terr = -ENOMEM;\n\t\tv4l2_err(sd, \"failed to create all i2c clients\\n\");\n\t\tgoto err_i2c;\n\t}\n\n\n\tINIT_DELAYED_WORK(&state->delayed_work_enable_hotplug,\n\t\t\tadv7842_delayed_work_enable_hotplug);\n\n\tsd->entity.function = MEDIA_ENT_F_DV_DECODER;\n\tfor (i = 0; i < ADV7842_PAD_SOURCE; ++i)\n\t\tstate->pads[i].flags = MEDIA_PAD_FL_SINK;\n\tstate->pads[ADV7842_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\terr = media_entity_pads_init(&sd->entity, ADV7842_PAD_SOURCE + 1,\n\t\t\t\t     state->pads);\n\tif (err)\n\t\tgoto err_work_queues;\n\n\terr = adv7842_core_init(sd);\n\tif (err)\n\t\tgoto err_entity;\n\n#if IS_ENABLED(CONFIG_VIDEO_ADV7842_CEC)\n\tstate->cec_adap = cec_allocate_adapter(&adv7842_cec_adap_ops,\n\t\tstate, dev_name(&client->dev),\n\t\tCEC_CAP_DEFAULTS, ADV7842_MAX_ADDRS);\n\terr = PTR_ERR_OR_ZERO(state->cec_adap);\n\tif (err)\n\t\tgoto err_entity;\n#endif\n\n\tv4l2_info(sd, \"%s found @ 0x%x (%s)\\n\", client->name,\n\t\t  client->addr << 1, client->adapter->name);\n\treturn 0;\n\nerr_entity:\n\tmedia_entity_cleanup(&sd->entity);\nerr_work_queues:\n\tcancel_delayed_work(&state->delayed_work_enable_hotplug);\nerr_i2c:\n\tadv7842_unregister_clients(sd);\nerr_hdl:\n\tv4l2_ctrl_handler_free(hdl);\n\treturn err;\n}\n\n \n\nstatic void adv7842_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct adv7842_state *state = to_state(sd);\n\n\tadv7842_irq_enable(sd, false);\n\tcancel_delayed_work_sync(&state->delayed_work_enable_hotplug);\n\tv4l2_device_unregister_subdev(sd);\n\tmedia_entity_cleanup(&sd->entity);\n\tadv7842_unregister_clients(sd);\n\tv4l2_ctrl_handler_free(sd->ctrl_handler);\n}\n\n \n\nstatic const struct i2c_device_id adv7842_id[] = {\n\t{ \"adv7842\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adv7842_id);\n\n \n\nstatic struct i2c_driver adv7842_driver = {\n\t.driver = {\n\t\t.name = \"adv7842\",\n\t},\n\t.probe = adv7842_probe,\n\t.remove = adv7842_remove,\n\t.id_table = adv7842_id,\n};\n\nmodule_i2c_driver(adv7842_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}