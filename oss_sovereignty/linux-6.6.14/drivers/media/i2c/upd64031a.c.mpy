{
  "module_name": "upd64031a.c",
  "hash_id": "ca6a6286bd78829dc2dc9e40feaf5ee042a50a2a6d00cd560efe331c25bca383",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/upd64031a.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/i2c.h>\n#include <linux/videodev2.h>\n#include <linux/slab.h>\n#include <media/v4l2-device.h>\n#include <media/i2c/upd64031a.h>\n\n \n\n \n#define GR_MODE_MASK              0xc0\n#define DIRECT_3DYCS_CONNECT_MASK 0xc0\n#define SYNC_CIRCUIT_MASK         0xa0\n\n \n\nMODULE_DESCRIPTION(\"uPD64031A driver\");\nMODULE_AUTHOR(\"T. Adachi, Takeru KOMORIYA, Hans Verkuil\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int debug;\nmodule_param(debug, int, 0644);\n\nMODULE_PARM_DESC(debug, \"Debug level (0-1)\");\n\n\nenum {\n\tR00 = 0, R01, R02, R03, R04,\n\tR05, R06, R07, R08, R09,\n\tR0A, R0B, R0C, R0D, R0E, R0F,\n\t \n\tTOT_REGS\n};\n\nstruct upd64031a_state {\n\tstruct v4l2_subdev sd;\n\tu8 regs[TOT_REGS];\n\tu8 gr_mode;\n\tu8 direct_3dycs_connect;\n\tu8 ext_comp_sync;\n\tu8 ext_vert_sync;\n};\n\nstatic inline struct upd64031a_state *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct upd64031a_state, sd);\n}\n\nstatic u8 upd64031a_init[] = {\n\t0x00, 0xb8, 0x48, 0xd2, 0xe6,\n\t0x03, 0x10, 0x0b, 0xaf, 0x7f,\n\t0x00, 0x00, 0x1d, 0x5e, 0x00,\n\t0xd0\n};\n\n \n\nstatic u8 upd64031a_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tu8 buf[2];\n\n\tif (reg >= sizeof(buf))\n\t\treturn 0xff;\n\ti2c_master_recv(client, buf, 2);\n\treturn buf[reg];\n}\n\n \n\nstatic void upd64031a_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tu8 buf[2];\n\n\tbuf[0] = reg;\n\tbuf[1] = val;\n\tv4l2_dbg(1, debug, sd, \"write reg: %02X val: %02X\\n\", reg, val);\n\tif (i2c_master_send(client, buf, 2) != 2)\n\t\tv4l2_err(sd, \"I/O error write 0x%02x/0x%02x\\n\", reg, val);\n}\n\n \n\n \nstatic int upd64031a_s_frequency(struct v4l2_subdev *sd, const struct v4l2_frequency *freq)\n{\n\tstruct upd64031a_state *state = to_state(sd);\n\tu8 reg = state->regs[R00];\n\n\tv4l2_dbg(1, debug, sd, \"changed input or channel\\n\");\n\tupd64031a_write(sd, R00, reg | 0x10);\n\tupd64031a_write(sd, R00, reg & ~0x10);\n\treturn 0;\n}\n\n \n\nstatic int upd64031a_s_routing(struct v4l2_subdev *sd,\n\t\t\t       u32 input, u32 output, u32 config)\n{\n\tstruct upd64031a_state *state = to_state(sd);\n\tu8 r00, r05, r08;\n\n\tstate->gr_mode = (input & 3) << 6;\n\tstate->direct_3dycs_connect = (input & 0xc) << 4;\n\tstate->ext_comp_sync =\n\t\t(input & UPD64031A_COMPOSITE_EXTERNAL) << 1;\n\tstate->ext_vert_sync =\n\t\t(input & UPD64031A_VERTICAL_EXTERNAL) << 2;\n\tr00 = (state->regs[R00] & ~GR_MODE_MASK) | state->gr_mode;\n\tr05 = (state->regs[R00] & ~SYNC_CIRCUIT_MASK) |\n\t\tstate->ext_comp_sync | state->ext_vert_sync;\n\tr08 = (state->regs[R08] & ~DIRECT_3DYCS_CONNECT_MASK) |\n\t\tstate->direct_3dycs_connect;\n\tupd64031a_write(sd, R00, r00);\n\tupd64031a_write(sd, R05, r05);\n\tupd64031a_write(sd, R08, r08);\n\treturn upd64031a_s_frequency(sd, NULL);\n}\n\nstatic int upd64031a_log_status(struct v4l2_subdev *sd)\n{\n\tv4l2_info(sd, \"Status: SA00=0x%02x SA01=0x%02x\\n\",\n\t\t\tupd64031a_read(sd, 0), upd64031a_read(sd, 1));\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int upd64031a_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\n{\n\treg->val = upd64031a_read(sd, reg->reg & 0xff);\n\treg->size = 1;\n\treturn 0;\n}\n\nstatic int upd64031a_s_register(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg)\n{\n\tupd64031a_write(sd, reg->reg & 0xff, reg->val & 0xff);\n\treturn 0;\n}\n#endif\n\n \n\nstatic const struct v4l2_subdev_core_ops upd64031a_core_ops = {\n\t.log_status = upd64031a_log_status,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = upd64031a_g_register,\n\t.s_register = upd64031a_s_register,\n#endif\n};\n\nstatic const struct v4l2_subdev_tuner_ops upd64031a_tuner_ops = {\n\t.s_frequency = upd64031a_s_frequency,\n};\n\nstatic const struct v4l2_subdev_video_ops upd64031a_video_ops = {\n\t.s_routing = upd64031a_s_routing,\n};\n\nstatic const struct v4l2_subdev_ops upd64031a_ops = {\n\t.core = &upd64031a_core_ops,\n\t.tuner = &upd64031a_tuner_ops,\n\t.video = &upd64031a_video_ops,\n};\n\n \n\n \n\nstatic int upd64031a_probe(struct i2c_client *client)\n{\n\tstruct upd64031a_state *state;\n\tstruct v4l2_subdev *sd;\n\tint i;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tv4l_info(client, \"chip found @ 0x%x (%s)\\n\",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tstate = devm_kzalloc(&client->dev, sizeof(*state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\tsd = &state->sd;\n\tv4l2_i2c_subdev_init(sd, client, &upd64031a_ops);\n\tmemcpy(state->regs, upd64031a_init, sizeof(state->regs));\n\tstate->gr_mode = UPD64031A_GR_ON << 6;\n\tstate->direct_3dycs_connect = UPD64031A_3DYCS_COMPOSITE << 4;\n\tstate->ext_comp_sync = state->ext_vert_sync = 0;\n\tfor (i = 0; i < TOT_REGS; i++)\n\t\tupd64031a_write(sd, i, state->regs[i]);\n\treturn 0;\n}\n\nstatic void upd64031a_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\n\tv4l2_device_unregister_subdev(sd);\n}\n\n \n\nstatic const struct i2c_device_id upd64031a_id[] = {\n\t{ \"upd64031a\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, upd64031a_id);\n\nstatic struct i2c_driver upd64031a_driver = {\n\t.driver = {\n\t\t.name\t= \"upd64031a\",\n\t},\n\t.probe\t\t= upd64031a_probe,\n\t.remove\t\t= upd64031a_remove,\n\t.id_table\t= upd64031a_id,\n};\n\nmodule_i2c_driver(upd64031a_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}