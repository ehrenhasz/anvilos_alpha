{
  "module_name": "ov7251.c",
  "hash_id": "060ada7f05051107e7288f69b7cef7a371b306910aaf07e53ece08c0461021bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ov7251.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n#define OV7251_SC_MODE_SELECT\t\t0x0100\n#define OV7251_SC_MODE_SELECT_SW_STANDBY\t0x0\n#define OV7251_SC_MODE_SELECT_STREAMING\t\t0x1\n\n#define OV7251_CHIP_ID_HIGH\t\t0x300a\n#define OV7251_CHIP_ID_HIGH_BYTE\t0x77\n#define OV7251_CHIP_ID_LOW\t\t0x300b\n#define OV7251_CHIP_ID_LOW_BYTE\t\t0x50\n#define OV7251_SC_GP_IO_IN1\t\t0x3029\n#define OV7251_AEC_EXPO_0\t\t0x3500\n#define OV7251_AEC_EXPO_1\t\t0x3501\n#define OV7251_AEC_EXPO_2\t\t0x3502\n#define OV7251_AEC_AGC_ADJ_0\t\t0x350a\n#define OV7251_AEC_AGC_ADJ_1\t\t0x350b\n#define OV7251_TIMING_FORMAT1\t\t0x3820\n#define OV7251_TIMING_FORMAT1_VFLIP\tBIT(2)\n#define OV7251_TIMING_FORMAT2\t\t0x3821\n#define OV7251_TIMING_FORMAT2_MIRROR\tBIT(2)\n#define OV7251_PRE_ISP_00\t\t0x5e00\n#define OV7251_PRE_ISP_00_TEST_PATTERN\tBIT(7)\n#define OV7251_PLL1_PRE_DIV_REG\t\t0x30b4\n#define OV7251_PLL1_MULT_REG\t\t0x30b3\n#define OV7251_PLL1_DIVIDER_REG\t\t0x30b1\n#define OV7251_PLL1_PIX_DIV_REG\t\t0x30b0\n#define OV7251_PLL1_MIPI_DIV_REG\t0x30b5\n#define OV7251_PLL2_PRE_DIV_REG\t\t0x3098\n#define OV7251_PLL2_MULT_REG\t\t0x3099\n#define OV7251_PLL2_DIVIDER_REG\t\t0x309d\n#define OV7251_PLL2_SYS_DIV_REG\t\t0x309a\n#define OV7251_PLL2_ADC_DIV_REG\t\t0x309b\n\n#define OV7251_NATIVE_WIDTH\t\t656\n#define OV7251_NATIVE_HEIGHT\t\t496\n#define OV7251_ACTIVE_START_LEFT\t4\n#define OV7251_ACTIVE_START_TOP\t\t4\n#define OV7251_ACTIVE_WIDTH\t\t648\n#define OV7251_ACTIVE_HEIGHT\t\t488\n\n#define OV7251_FIXED_PPL\t\t928\n#define OV7251_TIMING_VTS_REG\t\t0x380e\n#define OV7251_TIMING_MIN_VTS\t\t1\n#define OV7251_TIMING_MAX_VTS\t\t0xffff\n#define OV7251_INTEGRATION_MARGIN\t20\n\nstruct reg_value {\n\tu16 reg;\n\tu8 val;\n};\n\nstruct ov7251_mode_info {\n\tu32 width;\n\tu32 height;\n\tu32 vts;\n\tconst struct reg_value *data;\n\tu32 data_size;\n\tu32 pixel_clock;\n\tu32 link_freq;\n\tu16 exposure_max;\n\tu16 exposure_def;\n\tstruct v4l2_fract timeperframe;\n};\n\nstruct ov7251_pll1_cfg {\n\tunsigned int pre_div;\n\tunsigned int mult;\n\tunsigned int div;\n\tunsigned int pix_div;\n\tunsigned int mipi_div;\n};\n\nstruct ov7251_pll2_cfg {\n\tunsigned int pre_div;\n\tunsigned int mult;\n\tunsigned int div;\n\tunsigned int sys_div;\n\tunsigned int adc_div;\n};\n\n \nstruct ov7251_pll_cfgs {\n\tconst struct ov7251_pll2_cfg *pll2;\n\tconst struct ov7251_pll1_cfg *pll1[];\n};\n\nenum xclk_rate {\n\tOV7251_19_2_MHZ,\n\tOV7251_24_MHZ,\n\tOV7251_NUM_SUPPORTED_RATES\n};\n\nenum supported_link_freqs {\n\tOV7251_LINK_FREQ_240_MHZ,\n\tOV7251_LINK_FREQ_319_2_MHZ,\n\tOV7251_NUM_SUPPORTED_LINK_FREQS\n};\n\nstruct ov7251 {\n\tstruct i2c_client *i2c_client;\n\tstruct device *dev;\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pad;\n\tstruct v4l2_fwnode_endpoint ep;\n\tstruct v4l2_mbus_framefmt fmt;\n\tstruct v4l2_rect crop;\n\tstruct clk *xclk;\n\tu32 xclk_freq;\n\n\tstruct regulator *io_regulator;\n\tstruct regulator *core_regulator;\n\tstruct regulator *analog_regulator;\n\n\tconst struct ov7251_pll_cfgs *pll_cfgs;\n\tenum supported_link_freqs link_freq_idx;\n\tconst struct ov7251_mode_info *current_mode;\n\n\tstruct v4l2_ctrl_handler ctrls;\n\tstruct v4l2_ctrl *pixel_clock;\n\tstruct v4l2_ctrl *link_freq;\n\tstruct v4l2_ctrl *exposure;\n\tstruct v4l2_ctrl *gain;\n\tstruct v4l2_ctrl *hblank;\n\tstruct v4l2_ctrl *vblank;\n\n\t \n\tu8 aec_pk_manual;\n\tu8 pre_isp_00;\n\tu8 timing_format1;\n\tu8 timing_format2;\n\n\tstruct mutex lock;  \n\tbool power_on;\n\n\tstruct gpio_desc *enable_gpio;\n};\n\nstatic inline struct ov7251 *to_ov7251(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct ov7251, sd);\n}\n\nstatic const struct ov7251_pll1_cfg ov7251_pll1_cfg_19_2_mhz_240_mhz = {\n\t.pre_div = 0x03,\n\t.mult = 0x4b,\n\t.div = 0x01,\n\t.pix_div = 0x0a,\n\t.mipi_div = 0x05,\n};\n\nstatic const struct ov7251_pll1_cfg ov7251_pll1_cfg_19_2_mhz_319_2_mhz = {\n\t.pre_div = 0x01,\n\t.mult = 0x85,\n\t.div = 0x04,\n\t.pix_div = 0x0a,\n\t.mipi_div = 0x05,\n};\n\nstatic const struct ov7251_pll1_cfg ov7251_pll1_cfg_24_mhz_240_mhz = {\n\t.pre_div = 0x03,\n\t.mult = 0x64,\n\t.div = 0x01,\n\t.pix_div = 0x0a,\n\t.mipi_div = 0x05,\n};\n\nstatic const struct ov7251_pll1_cfg ov7251_pll1_cfg_24_mhz_319_2_mhz = {\n\t.pre_div = 0x05,\n\t.mult = 0x85,\n\t.div = 0x02,\n\t.pix_div = 0x0a,\n\t.mipi_div = 0x05,\n};\n\nstatic const struct ov7251_pll2_cfg ov7251_pll2_cfg_19_2_mhz = {\n\t.pre_div = 0x04,\n\t.mult = 0x32,\n\t.div = 0x00,\n\t.sys_div = 0x05,\n\t.adc_div = 0x04,\n};\n\nstatic const struct ov7251_pll2_cfg ov7251_pll2_cfg_24_mhz = {\n\t.pre_div = 0x04,\n\t.mult = 0x28,\n\t.div = 0x00,\n\t.sys_div = 0x05,\n\t.adc_div = 0x04,\n};\n\nstatic const struct ov7251_pll_cfgs ov7251_pll_cfgs_19_2_mhz = {\n\t.pll2 = &ov7251_pll2_cfg_19_2_mhz,\n\t.pll1 = {\n\t\t[OV7251_LINK_FREQ_240_MHZ] = &ov7251_pll1_cfg_19_2_mhz_240_mhz,\n\t\t[OV7251_LINK_FREQ_319_2_MHZ] = &ov7251_pll1_cfg_19_2_mhz_319_2_mhz,\n\t},\n};\n\nstatic const struct ov7251_pll_cfgs ov7251_pll_cfgs_24_mhz = {\n\t.pll2 = &ov7251_pll2_cfg_24_mhz,\n\t.pll1 = {\n\t\t[OV7251_LINK_FREQ_240_MHZ] = &ov7251_pll1_cfg_24_mhz_240_mhz,\n\t\t[OV7251_LINK_FREQ_319_2_MHZ] = &ov7251_pll1_cfg_24_mhz_319_2_mhz,\n\t},\n};\n\nstatic const struct ov7251_pll_cfgs *ov7251_pll_cfgs[] = {\n\t[OV7251_19_2_MHZ] = &ov7251_pll_cfgs_19_2_mhz,\n\t[OV7251_24_MHZ] = &ov7251_pll_cfgs_24_mhz,\n};\n\nstatic const struct reg_value ov7251_global_init_setting[] = {\n\t{ 0x0103, 0x01 },\n\t{ 0x303b, 0x02 },\n};\n\nstatic const struct reg_value ov7251_setting_vga_30fps[] = {\n\t{ 0x3005, 0x00 },\n\t{ 0x3012, 0xc0 },\n\t{ 0x3013, 0xd2 },\n\t{ 0x3014, 0x04 },\n\t{ 0x3016, 0xf0 },\n\t{ 0x3017, 0xf0 },\n\t{ 0x3018, 0xf0 },\n\t{ 0x301a, 0xf0 },\n\t{ 0x301b, 0xf0 },\n\t{ 0x301c, 0xf0 },\n\t{ 0x3023, 0x05 },\n\t{ 0x3037, 0xf0 },\n\t{ 0x3106, 0xda },\n\t{ 0x3503, 0x07 },\n\t{ 0x3509, 0x10 },\n\t{ 0x3600, 0x1c },\n\t{ 0x3602, 0x62 },\n\t{ 0x3620, 0xb7 },\n\t{ 0x3622, 0x04 },\n\t{ 0x3626, 0x21 },\n\t{ 0x3627, 0x30 },\n\t{ 0x3630, 0x44 },\n\t{ 0x3631, 0x35 },\n\t{ 0x3634, 0x60 },\n\t{ 0x3636, 0x00 },\n\t{ 0x3662, 0x01 },\n\t{ 0x3663, 0x70 },\n\t{ 0x3664, 0x50 },\n\t{ 0x3666, 0x0a },\n\t{ 0x3669, 0x1a },\n\t{ 0x366a, 0x00 },\n\t{ 0x366b, 0x50 },\n\t{ 0x3673, 0x01 },\n\t{ 0x3674, 0xff },\n\t{ 0x3675, 0x03 },\n\t{ 0x3705, 0xc1 },\n\t{ 0x3709, 0x40 },\n\t{ 0x373c, 0x08 },\n\t{ 0x3742, 0x00 },\n\t{ 0x3757, 0xb3 },\n\t{ 0x3788, 0x00 },\n\t{ 0x37a8, 0x01 },\n\t{ 0x37a9, 0xc0 },\n\t{ 0x3800, 0x00 },\n\t{ 0x3801, 0x04 },\n\t{ 0x3802, 0x00 },\n\t{ 0x3803, 0x04 },\n\t{ 0x3804, 0x02 },\n\t{ 0x3805, 0x8b },\n\t{ 0x3806, 0x01 },\n\t{ 0x3807, 0xeb },\n\t{ 0x3808, 0x02 },  \n\t{ 0x3809, 0x80 },  \n\t{ 0x380a, 0x01 },  \n\t{ 0x380b, 0xe0 },  \n\t{ 0x380c, 0x03 },  \n\t{ 0x380d, 0xa0 },  \n\t{ 0x380e, 0x06 },  \n\t{ 0x380f, 0xbc },  \n\t{ 0x3810, 0x00 },\n\t{ 0x3811, 0x04 },\n\t{ 0x3812, 0x00 },\n\t{ 0x3813, 0x05 },\n\t{ 0x3814, 0x11 },\n\t{ 0x3815, 0x11 },\n\t{ 0x3820, 0x40 },\n\t{ 0x3821, 0x00 },\n\t{ 0x382f, 0x0e },\n\t{ 0x3832, 0x00 },\n\t{ 0x3833, 0x05 },\n\t{ 0x3834, 0x00 },\n\t{ 0x3835, 0x0c },\n\t{ 0x3837, 0x00 },\n\t{ 0x3b80, 0x00 },\n\t{ 0x3b81, 0xa5 },\n\t{ 0x3b82, 0x10 },\n\t{ 0x3b83, 0x00 },\n\t{ 0x3b84, 0x08 },\n\t{ 0x3b85, 0x00 },\n\t{ 0x3b86, 0x01 },\n\t{ 0x3b87, 0x00 },\n\t{ 0x3b88, 0x00 },\n\t{ 0x3b89, 0x00 },\n\t{ 0x3b8a, 0x00 },\n\t{ 0x3b8b, 0x05 },\n\t{ 0x3b8c, 0x00 },\n\t{ 0x3b8d, 0x00 },\n\t{ 0x3b8e, 0x00 },\n\t{ 0x3b8f, 0x1a },\n\t{ 0x3b94, 0x05 },\n\t{ 0x3b95, 0xf2 },\n\t{ 0x3b96, 0x40 },\n\t{ 0x3c00, 0x89 },\n\t{ 0x3c01, 0x63 },\n\t{ 0x3c02, 0x01 },\n\t{ 0x3c03, 0x00 },\n\t{ 0x3c04, 0x00 },\n\t{ 0x3c05, 0x03 },\n\t{ 0x3c06, 0x00 },\n\t{ 0x3c07, 0x06 },\n\t{ 0x3c0c, 0x01 },\n\t{ 0x3c0d, 0xd0 },\n\t{ 0x3c0e, 0x02 },\n\t{ 0x3c0f, 0x0a },\n\t{ 0x4001, 0x42 },\n\t{ 0x4004, 0x04 },\n\t{ 0x4005, 0x00 },\n\t{ 0x404e, 0x01 },\n\t{ 0x4300, 0xff },\n\t{ 0x4301, 0x00 },\n\t{ 0x4315, 0x00 },\n\t{ 0x4501, 0x48 },\n\t{ 0x4600, 0x00 },\n\t{ 0x4601, 0x4e },\n\t{ 0x4801, 0x0f },\n\t{ 0x4806, 0x0f },\n\t{ 0x4819, 0xaa },\n\t{ 0x4823, 0x3e },\n\t{ 0x4837, 0x19 },\n\t{ 0x4a0d, 0x00 },\n\t{ 0x4a47, 0x7f },\n\t{ 0x4a49, 0xf0 },\n\t{ 0x4a4b, 0x30 },\n\t{ 0x5000, 0x85 },\n\t{ 0x5001, 0x80 },\n};\n\nstatic const struct reg_value ov7251_setting_vga_60fps[] = {\n\t{ 0x3005, 0x00 },\n\t{ 0x3012, 0xc0 },\n\t{ 0x3013, 0xd2 },\n\t{ 0x3014, 0x04 },\n\t{ 0x3016, 0x10 },\n\t{ 0x3017, 0x00 },\n\t{ 0x3018, 0x00 },\n\t{ 0x301a, 0x00 },\n\t{ 0x301b, 0x00 },\n\t{ 0x301c, 0x00 },\n\t{ 0x3023, 0x05 },\n\t{ 0x3037, 0xf0 },\n\t{ 0x3106, 0xda },\n\t{ 0x3503, 0x07 },\n\t{ 0x3509, 0x10 },\n\t{ 0x3600, 0x1c },\n\t{ 0x3602, 0x62 },\n\t{ 0x3620, 0xb7 },\n\t{ 0x3622, 0x04 },\n\t{ 0x3626, 0x21 },\n\t{ 0x3627, 0x30 },\n\t{ 0x3630, 0x44 },\n\t{ 0x3631, 0x35 },\n\t{ 0x3634, 0x60 },\n\t{ 0x3636, 0x00 },\n\t{ 0x3662, 0x01 },\n\t{ 0x3663, 0x70 },\n\t{ 0x3664, 0x50 },\n\t{ 0x3666, 0x0a },\n\t{ 0x3669, 0x1a },\n\t{ 0x366a, 0x00 },\n\t{ 0x366b, 0x50 },\n\t{ 0x3673, 0x01 },\n\t{ 0x3674, 0xff },\n\t{ 0x3675, 0x03 },\n\t{ 0x3705, 0xc1 },\n\t{ 0x3709, 0x40 },\n\t{ 0x373c, 0x08 },\n\t{ 0x3742, 0x00 },\n\t{ 0x3757, 0xb3 },\n\t{ 0x3788, 0x00 },\n\t{ 0x37a8, 0x01 },\n\t{ 0x37a9, 0xc0 },\n\t{ 0x3800, 0x00 },\n\t{ 0x3801, 0x04 },\n\t{ 0x3802, 0x00 },\n\t{ 0x3803, 0x04 },\n\t{ 0x3804, 0x02 },\n\t{ 0x3805, 0x8b },\n\t{ 0x3806, 0x01 },\n\t{ 0x3807, 0xeb },\n\t{ 0x3808, 0x02 },  \n\t{ 0x3809, 0x80 },  \n\t{ 0x380a, 0x01 },  \n\t{ 0x380b, 0xe0 },  \n\t{ 0x380c, 0x03 },  \n\t{ 0x380d, 0xa0 },  \n\t{ 0x380e, 0x03 },  \n\t{ 0x380f, 0x5c },  \n\t{ 0x3810, 0x00 },\n\t{ 0x3811, 0x04 },\n\t{ 0x3812, 0x00 },\n\t{ 0x3813, 0x05 },\n\t{ 0x3814, 0x11 },\n\t{ 0x3815, 0x11 },\n\t{ 0x3820, 0x40 },\n\t{ 0x3821, 0x00 },\n\t{ 0x382f, 0x0e },\n\t{ 0x3832, 0x00 },\n\t{ 0x3833, 0x05 },\n\t{ 0x3834, 0x00 },\n\t{ 0x3835, 0x0c },\n\t{ 0x3837, 0x00 },\n\t{ 0x3b80, 0x00 },\n\t{ 0x3b81, 0xa5 },\n\t{ 0x3b82, 0x10 },\n\t{ 0x3b83, 0x00 },\n\t{ 0x3b84, 0x08 },\n\t{ 0x3b85, 0x00 },\n\t{ 0x3b86, 0x01 },\n\t{ 0x3b87, 0x00 },\n\t{ 0x3b88, 0x00 },\n\t{ 0x3b89, 0x00 },\n\t{ 0x3b8a, 0x00 },\n\t{ 0x3b8b, 0x05 },\n\t{ 0x3b8c, 0x00 },\n\t{ 0x3b8d, 0x00 },\n\t{ 0x3b8e, 0x00 },\n\t{ 0x3b8f, 0x1a },\n\t{ 0x3b94, 0x05 },\n\t{ 0x3b95, 0xf2 },\n\t{ 0x3b96, 0x40 },\n\t{ 0x3c00, 0x89 },\n\t{ 0x3c01, 0x63 },\n\t{ 0x3c02, 0x01 },\n\t{ 0x3c03, 0x00 },\n\t{ 0x3c04, 0x00 },\n\t{ 0x3c05, 0x03 },\n\t{ 0x3c06, 0x00 },\n\t{ 0x3c07, 0x06 },\n\t{ 0x3c0c, 0x01 },\n\t{ 0x3c0d, 0xd0 },\n\t{ 0x3c0e, 0x02 },\n\t{ 0x3c0f, 0x0a },\n\t{ 0x4001, 0x42 },\n\t{ 0x4004, 0x04 },\n\t{ 0x4005, 0x00 },\n\t{ 0x404e, 0x01 },\n\t{ 0x4300, 0xff },\n\t{ 0x4301, 0x00 },\n\t{ 0x4315, 0x00 },\n\t{ 0x4501, 0x48 },\n\t{ 0x4600, 0x00 },\n\t{ 0x4601, 0x4e },\n\t{ 0x4801, 0x0f },\n\t{ 0x4806, 0x0f },\n\t{ 0x4819, 0xaa },\n\t{ 0x4823, 0x3e },\n\t{ 0x4837, 0x19 },\n\t{ 0x4a0d, 0x00 },\n\t{ 0x4a47, 0x7f },\n\t{ 0x4a49, 0xf0 },\n\t{ 0x4a4b, 0x30 },\n\t{ 0x5000, 0x85 },\n\t{ 0x5001, 0x80 },\n};\n\nstatic const struct reg_value ov7251_setting_vga_90fps[] = {\n\t{ 0x3005, 0x00 },\n\t{ 0x3012, 0xc0 },\n\t{ 0x3013, 0xd2 },\n\t{ 0x3014, 0x04 },\n\t{ 0x3016, 0x10 },\n\t{ 0x3017, 0x00 },\n\t{ 0x3018, 0x00 },\n\t{ 0x301a, 0x00 },\n\t{ 0x301b, 0x00 },\n\t{ 0x301c, 0x00 },\n\t{ 0x3023, 0x05 },\n\t{ 0x3037, 0xf0 },\n\t{ 0x3106, 0xda },\n\t{ 0x3503, 0x07 },\n\t{ 0x3509, 0x10 },\n\t{ 0x3600, 0x1c },\n\t{ 0x3602, 0x62 },\n\t{ 0x3620, 0xb7 },\n\t{ 0x3622, 0x04 },\n\t{ 0x3626, 0x21 },\n\t{ 0x3627, 0x30 },\n\t{ 0x3630, 0x44 },\n\t{ 0x3631, 0x35 },\n\t{ 0x3634, 0x60 },\n\t{ 0x3636, 0x00 },\n\t{ 0x3662, 0x01 },\n\t{ 0x3663, 0x70 },\n\t{ 0x3664, 0x50 },\n\t{ 0x3666, 0x0a },\n\t{ 0x3669, 0x1a },\n\t{ 0x366a, 0x00 },\n\t{ 0x366b, 0x50 },\n\t{ 0x3673, 0x01 },\n\t{ 0x3674, 0xff },\n\t{ 0x3675, 0x03 },\n\t{ 0x3705, 0xc1 },\n\t{ 0x3709, 0x40 },\n\t{ 0x373c, 0x08 },\n\t{ 0x3742, 0x00 },\n\t{ 0x3757, 0xb3 },\n\t{ 0x3788, 0x00 },\n\t{ 0x37a8, 0x01 },\n\t{ 0x37a9, 0xc0 },\n\t{ 0x3800, 0x00 },\n\t{ 0x3801, 0x04 },\n\t{ 0x3802, 0x00 },\n\t{ 0x3803, 0x04 },\n\t{ 0x3804, 0x02 },\n\t{ 0x3805, 0x8b },\n\t{ 0x3806, 0x01 },\n\t{ 0x3807, 0xeb },\n\t{ 0x3808, 0x02 },  \n\t{ 0x3809, 0x80 },  \n\t{ 0x380a, 0x01 },  \n\t{ 0x380b, 0xe0 },  \n\t{ 0x380c, 0x03 },  \n\t{ 0x380d, 0xa0 },  \n\t{ 0x380e, 0x02 },  \n\t{ 0x380f, 0x3c },  \n\t{ 0x3810, 0x00 },\n\t{ 0x3811, 0x04 },\n\t{ 0x3812, 0x00 },\n\t{ 0x3813, 0x05 },\n\t{ 0x3814, 0x11 },\n\t{ 0x3815, 0x11 },\n\t{ 0x3820, 0x40 },\n\t{ 0x3821, 0x00 },\n\t{ 0x382f, 0x0e },\n\t{ 0x3832, 0x00 },\n\t{ 0x3833, 0x05 },\n\t{ 0x3834, 0x00 },\n\t{ 0x3835, 0x0c },\n\t{ 0x3837, 0x00 },\n\t{ 0x3b80, 0x00 },\n\t{ 0x3b81, 0xa5 },\n\t{ 0x3b82, 0x10 },\n\t{ 0x3b83, 0x00 },\n\t{ 0x3b84, 0x08 },\n\t{ 0x3b85, 0x00 },\n\t{ 0x3b86, 0x01 },\n\t{ 0x3b87, 0x00 },\n\t{ 0x3b88, 0x00 },\n\t{ 0x3b89, 0x00 },\n\t{ 0x3b8a, 0x00 },\n\t{ 0x3b8b, 0x05 },\n\t{ 0x3b8c, 0x00 },\n\t{ 0x3b8d, 0x00 },\n\t{ 0x3b8e, 0x00 },\n\t{ 0x3b8f, 0x1a },\n\t{ 0x3b94, 0x05 },\n\t{ 0x3b95, 0xf2 },\n\t{ 0x3b96, 0x40 },\n\t{ 0x3c00, 0x89 },\n\t{ 0x3c01, 0x63 },\n\t{ 0x3c02, 0x01 },\n\t{ 0x3c03, 0x00 },\n\t{ 0x3c04, 0x00 },\n\t{ 0x3c05, 0x03 },\n\t{ 0x3c06, 0x00 },\n\t{ 0x3c07, 0x06 },\n\t{ 0x3c0c, 0x01 },\n\t{ 0x3c0d, 0xd0 },\n\t{ 0x3c0e, 0x02 },\n\t{ 0x3c0f, 0x0a },\n\t{ 0x4001, 0x42 },\n\t{ 0x4004, 0x04 },\n\t{ 0x4005, 0x00 },\n\t{ 0x404e, 0x01 },\n\t{ 0x4300, 0xff },\n\t{ 0x4301, 0x00 },\n\t{ 0x4315, 0x00 },\n\t{ 0x4501, 0x48 },\n\t{ 0x4600, 0x00 },\n\t{ 0x4601, 0x4e },\n\t{ 0x4801, 0x0f },\n\t{ 0x4806, 0x0f },\n\t{ 0x4819, 0xaa },\n\t{ 0x4823, 0x3e },\n\t{ 0x4837, 0x19 },\n\t{ 0x4a0d, 0x00 },\n\t{ 0x4a47, 0x7f },\n\t{ 0x4a49, 0xf0 },\n\t{ 0x4a4b, 0x30 },\n\t{ 0x5000, 0x85 },\n\t{ 0x5001, 0x80 },\n};\n\nstatic const unsigned long supported_xclk_rates[] = {\n\t[OV7251_19_2_MHZ] = 19200000,\n\t[OV7251_24_MHZ] = 24000000,\n};\n\nstatic const s64 link_freq[] = {\n\t[OV7251_LINK_FREQ_240_MHZ] = 240000000,\n\t[OV7251_LINK_FREQ_319_2_MHZ] = 319200000,\n};\n\nstatic const s64 pixel_rates[] = {\n\t[OV7251_LINK_FREQ_240_MHZ] = 48000000,\n\t[OV7251_LINK_FREQ_319_2_MHZ] = 63840000,\n};\n\nstatic const struct ov7251_mode_info ov7251_mode_info_data[] = {\n\t{\n\t\t.width = 640,\n\t\t.height = 480,\n\t\t.vts = 1724,\n\t\t.data = ov7251_setting_vga_30fps,\n\t\t.data_size = ARRAY_SIZE(ov7251_setting_vga_30fps),\n\t\t.exposure_max = 1704,\n\t\t.exposure_def = 504,\n\t\t.timeperframe = {\n\t\t\t.numerator = 100,\n\t\t\t.denominator = 3000\n\t\t}\n\t},\n\t{\n\t\t.width = 640,\n\t\t.height = 480,\n\t\t.vts = 860,\n\t\t.data = ov7251_setting_vga_60fps,\n\t\t.data_size = ARRAY_SIZE(ov7251_setting_vga_60fps),\n\t\t.exposure_max = 840,\n\t\t.exposure_def = 504,\n\t\t.timeperframe = {\n\t\t\t.numerator = 100,\n\t\t\t.denominator = 6014\n\t\t}\n\t},\n\t{\n\t\t.width = 640,\n\t\t.height = 480,\n\t\t.vts = 572,\n\t\t.data = ov7251_setting_vga_90fps,\n\t\t.data_size = ARRAY_SIZE(ov7251_setting_vga_90fps),\n\t\t.exposure_max = 552,\n\t\t.exposure_def = 504,\n\t\t.timeperframe = {\n\t\t\t.numerator = 100,\n\t\t\t.denominator = 9043\n\t\t}\n\t},\n};\n\nstatic int ov7251_regulators_enable(struct ov7251 *ov7251)\n{\n\tint ret;\n\n\t \n\n\tret = regulator_enable(ov7251->io_regulator);\n\tif (ret < 0) {\n\t\tdev_err(ov7251->dev, \"set io voltage failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regulator_enable(ov7251->analog_regulator);\n\tif (ret) {\n\t\tdev_err(ov7251->dev, \"set analog voltage failed\\n\");\n\t\tgoto err_disable_io;\n\t}\n\n\tret = regulator_enable(ov7251->core_regulator);\n\tif (ret) {\n\t\tdev_err(ov7251->dev, \"set core voltage failed\\n\");\n\t\tgoto err_disable_analog;\n\t}\n\n\treturn 0;\n\nerr_disable_analog:\n\tregulator_disable(ov7251->analog_regulator);\n\nerr_disable_io:\n\tregulator_disable(ov7251->io_regulator);\n\n\treturn ret;\n}\n\nstatic void ov7251_regulators_disable(struct ov7251 *ov7251)\n{\n\tint ret;\n\n\tret = regulator_disable(ov7251->core_regulator);\n\tif (ret < 0)\n\t\tdev_err(ov7251->dev, \"core regulator disable failed\\n\");\n\n\tret = regulator_disable(ov7251->analog_regulator);\n\tif (ret < 0)\n\t\tdev_err(ov7251->dev, \"analog regulator disable failed\\n\");\n\n\tret = regulator_disable(ov7251->io_regulator);\n\tif (ret < 0)\n\t\tdev_err(ov7251->dev, \"io regulator disable failed\\n\");\n}\n\nstatic int ov7251_write_reg(struct ov7251 *ov7251, u16 reg, u8 val)\n{\n\tu8 regbuf[3];\n\tint ret;\n\n\tregbuf[0] = reg >> 8;\n\tregbuf[1] = reg & 0xff;\n\tregbuf[2] = val;\n\n\tret = i2c_master_send(ov7251->i2c_client, regbuf, 3);\n\tif (ret < 0) {\n\t\tdev_err(ov7251->dev, \"%s: write reg error %d: reg=%x, val=%x\\n\",\n\t\t\t__func__, ret, reg, val);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov7251_write_seq_regs(struct ov7251 *ov7251, u16 reg, u8 *val,\n\t\t\t\t u8 num)\n{\n\tu8 regbuf[5];\n\tu8 nregbuf = sizeof(reg) + num * sizeof(*val);\n\tint ret = 0;\n\n\tif (nregbuf > sizeof(regbuf))\n\t\treturn -EINVAL;\n\n\tregbuf[0] = reg >> 8;\n\tregbuf[1] = reg & 0xff;\n\n\tmemcpy(regbuf + 2, val, num);\n\n\tret = i2c_master_send(ov7251->i2c_client, regbuf, nregbuf);\n\tif (ret < 0) {\n\t\tdev_err(ov7251->dev,\n\t\t\t\"%s: write seq regs error %d: first reg=%x\\n\",\n\t\t\t__func__, ret, reg);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov7251_read_reg(struct ov7251 *ov7251, u16 reg, u8 *val)\n{\n\tu8 regbuf[2];\n\tint ret;\n\n\tregbuf[0] = reg >> 8;\n\tregbuf[1] = reg & 0xff;\n\n\tret = i2c_master_send(ov7251->i2c_client, regbuf, 2);\n\tif (ret < 0) {\n\t\tdev_err(ov7251->dev, \"%s: write reg error %d: reg=%x\\n\",\n\t\t\t__func__, ret, reg);\n\t\treturn ret;\n\t}\n\n\tret = i2c_master_recv(ov7251->i2c_client, val, 1);\n\tif (ret < 0) {\n\t\tdev_err(ov7251->dev, \"%s: read reg error %d: reg=%x\\n\",\n\t\t\t__func__, ret, reg);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov7251_pll_configure(struct ov7251 *ov7251)\n{\n\tconst struct ov7251_pll_cfgs *configs;\n\tint ret;\n\n\tconfigs = ov7251->pll_cfgs;\n\n\tret = ov7251_write_reg(ov7251, OV7251_PLL1_PRE_DIV_REG,\n\t\t\t       configs->pll1[ov7251->link_freq_idx]->pre_div);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov7251_write_reg(ov7251, OV7251_PLL1_MULT_REG,\n\t\t\t       configs->pll1[ov7251->link_freq_idx]->mult);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = ov7251_write_reg(ov7251, OV7251_PLL1_DIVIDER_REG,\n\t\t\t       configs->pll1[ov7251->link_freq_idx]->div);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov7251_write_reg(ov7251, OV7251_PLL1_PIX_DIV_REG,\n\t\t\t       configs->pll1[ov7251->link_freq_idx]->pix_div);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov7251_write_reg(ov7251, OV7251_PLL1_MIPI_DIV_REG,\n\t\t\t       configs->pll1[ov7251->link_freq_idx]->mipi_div);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov7251_write_reg(ov7251, OV7251_PLL2_PRE_DIV_REG,\n\t\t\t       configs->pll2->pre_div);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov7251_write_reg(ov7251, OV7251_PLL2_MULT_REG,\n\t\t\t       configs->pll2->mult);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov7251_write_reg(ov7251, OV7251_PLL2_DIVIDER_REG,\n\t\t\t       configs->pll2->div);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov7251_write_reg(ov7251, OV7251_PLL2_SYS_DIV_REG,\n\t\t\t       configs->pll2->sys_div);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov7251_write_reg(ov7251, OV7251_PLL2_ADC_DIV_REG,\n\t\t\t       configs->pll2->adc_div);\n\n\treturn ret;\n}\n\nstatic int ov7251_set_exposure(struct ov7251 *ov7251, s32 exposure)\n{\n\tu16 reg;\n\tu8 val[3];\n\n\treg = OV7251_AEC_EXPO_0;\n\tval[0] = (exposure & 0xf000) >> 12;  \n\tval[1] = (exposure & 0x0ff0) >> 4;   \n\tval[2] = (exposure & 0x000f) << 4;   \n\n\treturn ov7251_write_seq_regs(ov7251, reg, val, 3);\n}\n\nstatic int ov7251_set_gain(struct ov7251 *ov7251, s32 gain)\n{\n\tu16 reg;\n\tu8 val[2];\n\n\treg = OV7251_AEC_AGC_ADJ_0;\n\tval[0] = (gain & 0x0300) >> 8;  \n\tval[1] = gain & 0xff;           \n\n\treturn ov7251_write_seq_regs(ov7251, reg, val, 2);\n}\n\nstatic int ov7251_set_register_array(struct ov7251 *ov7251,\n\t\t\t\t     const struct reg_value *settings,\n\t\t\t\t     unsigned int num_settings)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < num_settings; ++i, ++settings) {\n\t\tret = ov7251_write_reg(ov7251, settings->reg, settings->val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov7251_set_power_on(struct device *dev)\n{\n\tstruct i2c_client *client = container_of(dev, struct i2c_client, dev);\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov7251 *ov7251 = to_ov7251(sd);\n\tint ret;\n\tu32 wait_us;\n\n\tret = ov7251_regulators_enable(ov7251);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(ov7251->xclk);\n\tif (ret < 0) {\n\t\tdev_err(ov7251->dev, \"clk prepare enable failed\\n\");\n\t\tov7251_regulators_disable(ov7251);\n\t\treturn ret;\n\t}\n\n\tgpiod_set_value_cansleep(ov7251->enable_gpio, 1);\n\n\t \n\twait_us = DIV_ROUND_UP(65536 * 1000,\n\t\t\t       DIV_ROUND_UP(ov7251->xclk_freq, 1000));\n\tusleep_range(wait_us, wait_us + 1000);\n\n\tret = ov7251_set_register_array(ov7251,\n\t\t\t\t\tov7251_global_init_setting,\n\t\t\t\t\tARRAY_SIZE(ov7251_global_init_setting));\n\tif (ret < 0) {\n\t\tdev_err(ov7251->dev, \"error during global init\\n\");\n\t\tgpiod_set_value_cansleep(ov7251->enable_gpio, 0);\n\t\tclk_disable_unprepare(ov7251->xclk);\n\t\tov7251_regulators_disable(ov7251);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int ov7251_set_power_off(struct device *dev)\n{\n\tstruct i2c_client *client = container_of(dev, struct i2c_client, dev);\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov7251 *ov7251 = to_ov7251(sd);\n\n\tclk_disable_unprepare(ov7251->xclk);\n\tgpiod_set_value_cansleep(ov7251->enable_gpio, 0);\n\tov7251_regulators_disable(ov7251);\n\n\treturn 0;\n}\n\nstatic int ov7251_set_hflip(struct ov7251 *ov7251, s32 value)\n{\n\tu8 val = ov7251->timing_format2;\n\tint ret;\n\n\tif (value)\n\t\tval |= OV7251_TIMING_FORMAT2_MIRROR;\n\telse\n\t\tval &= ~OV7251_TIMING_FORMAT2_MIRROR;\n\n\tret = ov7251_write_reg(ov7251, OV7251_TIMING_FORMAT2, val);\n\tif (!ret)\n\t\tov7251->timing_format2 = val;\n\n\treturn ret;\n}\n\nstatic int ov7251_set_vflip(struct ov7251 *ov7251, s32 value)\n{\n\tu8 val = ov7251->timing_format1;\n\tint ret;\n\n\tif (value)\n\t\tval |= OV7251_TIMING_FORMAT1_VFLIP;\n\telse\n\t\tval &= ~OV7251_TIMING_FORMAT1_VFLIP;\n\n\tret = ov7251_write_reg(ov7251, OV7251_TIMING_FORMAT1, val);\n\tif (!ret)\n\t\tov7251->timing_format1 = val;\n\n\treturn ret;\n}\n\nstatic int ov7251_set_test_pattern(struct ov7251 *ov7251, s32 value)\n{\n\tu8 val = ov7251->pre_isp_00;\n\tint ret;\n\n\tif (value)\n\t\tval |= OV7251_PRE_ISP_00_TEST_PATTERN;\n\telse\n\t\tval &= ~OV7251_PRE_ISP_00_TEST_PATTERN;\n\n\tret = ov7251_write_reg(ov7251, OV7251_PRE_ISP_00, val);\n\tif (!ret)\n\t\tov7251->pre_isp_00 = val;\n\n\treturn ret;\n}\n\nstatic const char * const ov7251_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Vertical Pattern Bars\",\n};\n\nstatic int ov7251_vts_configure(struct ov7251 *ov7251, s32 vblank)\n{\n\tu8 vts[2];\n\n\tvts[0] = ((ov7251->current_mode->height + vblank) & 0xff00) >> 8;\n\tvts[1] = ((ov7251->current_mode->height + vblank) & 0x00ff);\n\n\treturn ov7251_write_seq_regs(ov7251, OV7251_TIMING_VTS_REG, vts, 2);\n}\n\nstatic int ov7251_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ov7251 *ov7251 = container_of(ctrl->handler,\n\t\t\t\t\t     struct ov7251, ctrls);\n\tint ret;\n\n\t \n\tif (ctrl->id == V4L2_CID_VBLANK) {\n\t\tint exposure_max;\n\n\t\texposure_max = ov7251->current_mode->height + ctrl->val -\n\t\t\t       OV7251_INTEGRATION_MARGIN;\n\t\t__v4l2_ctrl_modify_range(ov7251->exposure,\n\t\t\t\t\t ov7251->exposure->minimum,\n\t\t\t\t\t exposure_max,\n\t\t\t\t\t ov7251->exposure->step,\n\t\t\t\t\t min(ov7251->exposure->val,\n\t\t\t\t\t     exposure_max));\n\t}\n\n\t \n\n\tif (!pm_runtime_get_if_in_use(ov7251->dev))\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE:\n\t\tret = ov7251_set_exposure(ov7251, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_GAIN:\n\t\tret = ov7251_set_gain(ov7251, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tret = ov7251_set_test_pattern(ov7251, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tret = ov7251_set_hflip(ov7251, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tret = ov7251_set_vflip(ov7251, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_VBLANK:\n\t\tret = ov7251_vts_configure(ov7251, ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tpm_runtime_put(ov7251->dev);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops ov7251_ctrl_ops = {\n\t.s_ctrl = ov7251_s_ctrl,\n};\n\nstatic int ov7251_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index > 0)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_Y10_1X10;\n\n\treturn 0;\n}\n\nstatic int ov7251_enum_frame_size(struct v4l2_subdev *subdev,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tif (fse->code != MEDIA_BUS_FMT_Y10_1X10)\n\t\treturn -EINVAL;\n\n\tif (fse->index >= ARRAY_SIZE(ov7251_mode_info_data))\n\t\treturn -EINVAL;\n\n\tfse->min_width = ov7251_mode_info_data[fse->index].width;\n\tfse->max_width = ov7251_mode_info_data[fse->index].width;\n\tfse->min_height = ov7251_mode_info_data[fse->index].height;\n\tfse->max_height = ov7251_mode_info_data[fse->index].height;\n\n\treturn 0;\n}\n\nstatic int ov7251_enum_frame_ival(struct v4l2_subdev *subdev,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_interval_enum *fie)\n{\n\tunsigned int index = fie->index;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ov7251_mode_info_data); i++) {\n\t\tif (fie->width != ov7251_mode_info_data[i].width ||\n\t\t    fie->height != ov7251_mode_info_data[i].height)\n\t\t\tcontinue;\n\n\t\tif (index-- == 0) {\n\t\t\tfie->interval = ov7251_mode_info_data[i].timeperframe;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic struct v4l2_mbus_framefmt *\n__ov7251_get_pad_format(struct ov7251 *ov7251,\n\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\tunsigned int pad,\n\t\t\tenum v4l2_subdev_format_whence which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\treturn v4l2_subdev_get_try_format(&ov7251->sd, sd_state, pad);\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &ov7251->fmt;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic int ov7251_get_format(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_format *format)\n{\n\tstruct ov7251 *ov7251 = to_ov7251(sd);\n\n\tmutex_lock(&ov7251->lock);\n\tformat->format = *__ov7251_get_pad_format(ov7251, sd_state,\n\t\t\t\t\t\t  format->pad,\n\t\t\t\t\t\t  format->which);\n\tmutex_unlock(&ov7251->lock);\n\n\treturn 0;\n}\n\nstatic struct v4l2_rect *\n__ov7251_get_pad_crop(struct ov7251 *ov7251,\n\t\t      struct v4l2_subdev_state *sd_state,\n\t\t      unsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\treturn v4l2_subdev_get_try_crop(&ov7251->sd, sd_state, pad);\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &ov7251->crop;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic inline u32 avg_fps(const struct v4l2_fract *t)\n{\n\treturn (t->denominator + (t->numerator >> 1)) / t->numerator;\n}\n\nstatic const struct ov7251_mode_info *\nov7251_find_mode_by_ival(struct ov7251 *ov7251, struct v4l2_fract *timeperframe)\n{\n\tconst struct ov7251_mode_info *mode = ov7251->current_mode;\n\tunsigned int fps_req = avg_fps(timeperframe);\n\tunsigned int max_dist_match = (unsigned int) -1;\n\tunsigned int i, n = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(ov7251_mode_info_data); i++) {\n\t\tunsigned int dist;\n\t\tunsigned int fps_tmp;\n\n\t\tif (mode->width != ov7251_mode_info_data[i].width ||\n\t\t    mode->height != ov7251_mode_info_data[i].height)\n\t\t\tcontinue;\n\n\t\tfps_tmp = avg_fps(&ov7251_mode_info_data[i].timeperframe);\n\n\t\tdist = abs(fps_req - fps_tmp);\n\n\t\tif (dist < max_dist_match) {\n\t\t\tn = i;\n\t\t\tmax_dist_match = dist;\n\t\t}\n\t}\n\n\treturn &ov7251_mode_info_data[n];\n}\n\nstatic int ov7251_set_format(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_format *format)\n{\n\tstruct ov7251 *ov7251 = to_ov7251(sd);\n\tstruct v4l2_mbus_framefmt *__format;\n\tint vblank_max, vblank_def;\n\tstruct v4l2_rect *__crop;\n\tconst struct ov7251_mode_info *new_mode;\n\tint ret = 0;\n\n\tmutex_lock(&ov7251->lock);\n\n\t__crop = __ov7251_get_pad_crop(ov7251, sd_state, format->pad,\n\t\t\t\t       format->which);\n\n\tnew_mode = v4l2_find_nearest_size(ov7251_mode_info_data,\n\t\t\t\tARRAY_SIZE(ov7251_mode_info_data),\n\t\t\t\twidth, height,\n\t\t\t\tformat->format.width, format->format.height);\n\n\t__crop->width = new_mode->width;\n\t__crop->height = new_mode->height;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\tret = __v4l2_ctrl_modify_range(ov7251->exposure,\n\t\t\t\t\t       1, new_mode->exposure_max,\n\t\t\t\t\t       1, new_mode->exposure_def);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tret = __v4l2_ctrl_s_ctrl(ov7251->exposure,\n\t\t\t\t\t new_mode->exposure_def);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tret = __v4l2_ctrl_s_ctrl(ov7251->gain, 16);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tvblank_max = OV7251_TIMING_MAX_VTS - new_mode->height;\n\t\tvblank_def = new_mode->vts - new_mode->height;\n\t\tret = __v4l2_ctrl_modify_range(ov7251->vblank,\n\t\t\t\t\t       OV7251_TIMING_MIN_VTS,\n\t\t\t\t\t       vblank_max, 1, vblank_def);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tov7251->current_mode = new_mode;\n\t}\n\n\t__format = __ov7251_get_pad_format(ov7251, sd_state, format->pad,\n\t\t\t\t\t   format->which);\n\t__format->width = __crop->width;\n\t__format->height = __crop->height;\n\t__format->code = MEDIA_BUS_FMT_Y10_1X10;\n\t__format->field = V4L2_FIELD_NONE;\n\t__format->colorspace = V4L2_COLORSPACE_SRGB;\n\t__format->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(__format->colorspace);\n\t__format->quantization = V4L2_MAP_QUANTIZATION_DEFAULT(true,\n\t\t\t\t__format->colorspace, __format->ycbcr_enc);\n\t__format->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(__format->colorspace);\n\n\tformat->format = *__format;\n\nexit:\n\tmutex_unlock(&ov7251->lock);\n\n\treturn ret;\n}\n\nstatic int ov7251_entity_init_cfg(struct v4l2_subdev *subdev,\n\t\t\t\t  struct v4l2_subdev_state *sd_state)\n{\n\tstruct v4l2_subdev_format fmt = {\n\t\t.which = sd_state ? V4L2_SUBDEV_FORMAT_TRY\n\t\t: V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.format = {\n\t\t\t.width = 640,\n\t\t\t.height = 480\n\t\t}\n\t};\n\n\tov7251_set_format(subdev, sd_state, &fmt);\n\n\treturn 0;\n}\n\nstatic int ov7251_get_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct ov7251 *ov7251 = to_ov7251(sd);\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP:\n\tmutex_lock(&ov7251->lock);\n\t\tsel->r = *__ov7251_get_pad_crop(ov7251, sd_state, sel->pad,\n\t\t\t\t\t\tsel->which);\n\t\tmutex_unlock(&ov7251->lock);\n\t\tbreak;\n\tcase V4L2_SEL_TGT_NATIVE_SIZE:\n\t\tsel->r.top = 0;\n\t\tsel->r.left = 0;\n\t\tsel->r.width = OV7251_NATIVE_WIDTH;\n\t\tsel->r.height = OV7251_NATIVE_HEIGHT;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.top = OV7251_ACTIVE_START_TOP;\n\t\tsel->r.left = OV7251_ACTIVE_START_LEFT;\n\t\tsel->r.width = OV7251_ACTIVE_WIDTH;\n\t\tsel->r.height = OV7251_ACTIVE_HEIGHT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov7251_s_stream(struct v4l2_subdev *subdev, int enable)\n{\n\tstruct ov7251 *ov7251 = to_ov7251(subdev);\n\tint ret;\n\n\tmutex_lock(&ov7251->lock);\n\n\tif (enable) {\n\t\tret = pm_runtime_get_sync(ov7251->dev);\n\t\tif (ret < 0)\n\t\t\tgoto err_power_down;\n\n\t\tret = ov7251_pll_configure(ov7251);\n\t\tif (ret) {\n\t\t\tdev_err(ov7251->dev, \"error configuring PLLs\\n\");\n\t\t\tgoto err_power_down;\n\t\t}\n\n\t\tret = ov7251_set_register_array(ov7251,\n\t\t\t\t\tov7251->current_mode->data,\n\t\t\t\t\tov7251->current_mode->data_size);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ov7251->dev, \"could not set mode %dx%d\\n\",\n\t\t\t\tov7251->current_mode->width,\n\t\t\t\tov7251->current_mode->height);\n\t\t\tgoto err_power_down;\n\t\t}\n\t\tret = __v4l2_ctrl_handler_setup(&ov7251->ctrls);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ov7251->dev, \"could not sync v4l2 controls\\n\");\n\t\t\tgoto err_power_down;\n\t\t}\n\t\tret = ov7251_write_reg(ov7251, OV7251_SC_MODE_SELECT,\n\t\t\t\t       OV7251_SC_MODE_SELECT_STREAMING);\n\t\tif (ret)\n\t\t\tgoto err_power_down;\n\t} else {\n\t\tret = ov7251_write_reg(ov7251, OV7251_SC_MODE_SELECT,\n\t\t\t\t       OV7251_SC_MODE_SELECT_SW_STANDBY);\n\t\tpm_runtime_put(ov7251->dev);\n\t}\n\n\tmutex_unlock(&ov7251->lock);\n\treturn ret;\n\nerr_power_down:\n\tpm_runtime_put(ov7251->dev);\n\tmutex_unlock(&ov7251->lock);\n\treturn ret;\n}\n\nstatic int ov7251_get_frame_interval(struct v4l2_subdev *subdev,\n\t\t\t\t     struct v4l2_subdev_frame_interval *fi)\n{\n\tstruct ov7251 *ov7251 = to_ov7251(subdev);\n\n\tmutex_lock(&ov7251->lock);\n\tfi->interval = ov7251->current_mode->timeperframe;\n\tmutex_unlock(&ov7251->lock);\n\n\treturn 0;\n}\n\nstatic int ov7251_set_frame_interval(struct v4l2_subdev *subdev,\n\t\t\t\t     struct v4l2_subdev_frame_interval *fi)\n{\n\tstruct ov7251 *ov7251 = to_ov7251(subdev);\n\tconst struct ov7251_mode_info *new_mode;\n\tint ret = 0;\n\n\tmutex_lock(&ov7251->lock);\n\tnew_mode = ov7251_find_mode_by_ival(ov7251, &fi->interval);\n\n\tif (new_mode != ov7251->current_mode) {\n\t\tret = __v4l2_ctrl_modify_range(ov7251->exposure,\n\t\t\t\t\t       1, new_mode->exposure_max,\n\t\t\t\t\t       1, new_mode->exposure_def);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tret = __v4l2_ctrl_s_ctrl(ov7251->exposure,\n\t\t\t\t\t new_mode->exposure_def);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tret = __v4l2_ctrl_s_ctrl(ov7251->gain, 16);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tov7251->current_mode = new_mode;\n\t}\n\n\tfi->interval = ov7251->current_mode->timeperframe;\n\nexit:\n\tmutex_unlock(&ov7251->lock);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_video_ops ov7251_video_ops = {\n\t.s_stream = ov7251_s_stream,\n\t.g_frame_interval = ov7251_get_frame_interval,\n\t.s_frame_interval = ov7251_set_frame_interval,\n};\n\nstatic const struct v4l2_subdev_pad_ops ov7251_subdev_pad_ops = {\n\t.init_cfg = ov7251_entity_init_cfg,\n\t.enum_mbus_code = ov7251_enum_mbus_code,\n\t.enum_frame_size = ov7251_enum_frame_size,\n\t.enum_frame_interval = ov7251_enum_frame_ival,\n\t.get_fmt = ov7251_get_format,\n\t.set_fmt = ov7251_set_format,\n\t.get_selection = ov7251_get_selection,\n};\n\nstatic const struct v4l2_subdev_ops ov7251_subdev_ops = {\n\t.video = &ov7251_video_ops,\n\t.pad = &ov7251_subdev_pad_ops,\n};\n\nstatic int ov7251_check_hwcfg(struct ov7251 *ov7251)\n{\n\tstruct fwnode_handle *fwnode = dev_fwnode(ov7251->dev);\n\tstruct v4l2_fwnode_endpoint bus_cfg = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY,\n\t};\n\tstruct fwnode_handle *endpoint;\n\tunsigned int i, j;\n\tint ret;\n\n\tendpoint = fwnode_graph_get_next_endpoint(fwnode, NULL);\n\tif (!endpoint)\n\t\treturn -EPROBE_DEFER;  \n\n\tret = v4l2_fwnode_endpoint_alloc_parse(endpoint, &bus_cfg);\n\tfwnode_handle_put(endpoint);\n\tif (ret)\n\t\treturn dev_err_probe(ov7251->dev, ret,\n\t\t\t\t     \"parsing endpoint node failed\\n\");\n\n\tif (!bus_cfg.nr_of_link_frequencies) {\n\t\tret = dev_err_probe(ov7251->dev, -EINVAL,\n\t\t\t\t    \"no link frequencies defined\\n\");\n\t\tgoto out_free_bus_cfg;\n\t}\n\n\tfor (i = 0; i < bus_cfg.nr_of_link_frequencies; i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(link_freq); j++)\n\t\t\tif (bus_cfg.link_frequencies[i] == link_freq[j])\n\t\t\t\tbreak;\n\n\t\tif (j < ARRAY_SIZE(link_freq))\n\t\t\tbreak;\n\t}\n\n\tif (i == bus_cfg.nr_of_link_frequencies) {\n\t\tret = dev_err_probe(ov7251->dev, -EINVAL,\n\t\t\t\t    \"no supported link freq found\\n\");\n\t\tgoto out_free_bus_cfg;\n\t}\n\n\tov7251->link_freq_idx = i;\n\nout_free_bus_cfg:\n\tv4l2_fwnode_endpoint_free(&bus_cfg);\n\n\treturn ret;\n}\n\nstatic int ov7251_detect_chip(struct ov7251 *ov7251)\n{\n\tu8 chip_id_high, chip_id_low, chip_rev;\n\tint ret;\n\n\tret = ov7251_read_reg(ov7251, OV7251_CHIP_ID_HIGH, &chip_id_high);\n\tif (ret < 0 || chip_id_high != OV7251_CHIP_ID_HIGH_BYTE)\n\t\treturn dev_err_probe(ov7251->dev, -ENODEV,\n\t\t\t\t     \"could not read ID high\\n\");\n\n\tret = ov7251_read_reg(ov7251, OV7251_CHIP_ID_LOW, &chip_id_low);\n\tif (ret < 0 || chip_id_low != OV7251_CHIP_ID_LOW_BYTE)\n\t\treturn dev_err_probe(ov7251->dev, -ENODEV,\n\t\t\t\t     \"could not read ID low\\n\");\n\n\tret = ov7251_read_reg(ov7251, OV7251_SC_GP_IO_IN1, &chip_rev);\n\tif (ret < 0)\n\t\treturn dev_err_probe(ov7251->dev, -ENODEV,\n\t\t\t\t     \"could not read revision\\n\");\n\tchip_rev >>= 4;\n\n\tdev_info(ov7251->dev,\n\t\t \"OV7251 revision %x (%s) detected at address 0x%02x\\n\",\n\t\t chip_rev,\n\t\t chip_rev == 0x4 ? \"1A / 1B\" :\n\t\t chip_rev == 0x5 ? \"1C / 1D\" :\n\t\t chip_rev == 0x6 ? \"1E\" :\n\t\t chip_rev == 0x7 ? \"1F\" : \"unknown\",\n\t\t ov7251->i2c_client->addr);\n\n\treturn 0;\n}\n\nstatic int ov7251_init_ctrls(struct ov7251 *ov7251)\n{\n\tint vblank_max, vblank_def;\n\ts64 pixel_rate;\n\tint hblank;\n\n\tv4l2_ctrl_handler_init(&ov7251->ctrls, 7);\n\tov7251->ctrls.lock = &ov7251->lock;\n\n\tv4l2_ctrl_new_std(&ov7251->ctrls, &ov7251_ctrl_ops,\n\t\t\t  V4L2_CID_HFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(&ov7251->ctrls, &ov7251_ctrl_ops,\n\t\t\t  V4L2_CID_VFLIP, 0, 1, 1, 0);\n\tov7251->exposure = v4l2_ctrl_new_std(&ov7251->ctrls, &ov7251_ctrl_ops,\n\t\t\t\t\t     V4L2_CID_EXPOSURE, 1, 32, 1, 32);\n\tov7251->gain = v4l2_ctrl_new_std(&ov7251->ctrls, &ov7251_ctrl_ops,\n\t\t\t\t\t V4L2_CID_GAIN, 16, 1023, 1, 16);\n\tv4l2_ctrl_new_std_menu_items(&ov7251->ctrls, &ov7251_ctrl_ops,\n\t\t\t\t     V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(ov7251_test_pattern_menu) - 1,\n\t\t\t\t     0, 0, ov7251_test_pattern_menu);\n\n\tpixel_rate = pixel_rates[ov7251->link_freq_idx];\n\tov7251->pixel_clock = v4l2_ctrl_new_std(&ov7251->ctrls,\n\t\t\t\t\t\t&ov7251_ctrl_ops,\n\t\t\t\t\t\tV4L2_CID_PIXEL_RATE,\n\t\t\t\t\t\tpixel_rate, INT_MAX,\n\t\t\t\t\t\tpixel_rate, pixel_rate);\n\tov7251->link_freq = v4l2_ctrl_new_int_menu(&ov7251->ctrls,\n\t\t\t\t\t\t   &ov7251_ctrl_ops,\n\t\t\t\t\t\t   V4L2_CID_LINK_FREQ,\n\t\t\t\t\t\t   ARRAY_SIZE(link_freq) - 1,\n\t\t\t\t\t\t   ov7251->link_freq_idx,\n\t\t\t\t\t\t   link_freq);\n\tif (ov7251->link_freq)\n\t\tov7251->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\tif (ov7251->pixel_clock)\n\t\tov7251->pixel_clock->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\thblank = OV7251_FIXED_PPL - ov7251->current_mode->width;\n\tov7251->hblank = v4l2_ctrl_new_std(&ov7251->ctrls, &ov7251_ctrl_ops,\n\t\t\t\t\t   V4L2_CID_HBLANK, hblank, hblank, 1,\n\t\t\t\t\t   hblank);\n\tif (ov7251->hblank)\n\t\tov7251->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tvblank_max = OV7251_TIMING_MAX_VTS - ov7251->current_mode->height;\n\tvblank_def = ov7251->current_mode->vts - ov7251->current_mode->height;\n\tov7251->vblank = v4l2_ctrl_new_std(&ov7251->ctrls, &ov7251_ctrl_ops,\n\t\t\t\t\t   V4L2_CID_VBLANK,\n\t\t\t\t\t   OV7251_TIMING_MIN_VTS, vblank_max, 1,\n\t\t\t\t\t   vblank_def);\n\n\tov7251->sd.ctrl_handler = &ov7251->ctrls;\n\n\tif (ov7251->ctrls.error) {\n\t\tv4l2_ctrl_handler_free(&ov7251->ctrls);\n\t\treturn ov7251->ctrls.error;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov7251_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct ov7251 *ov7251;\n\tunsigned int rate = 0, clk_rate = 0;\n\tint ret;\n\tint i;\n\n\tov7251 = devm_kzalloc(dev, sizeof(struct ov7251), GFP_KERNEL);\n\tif (!ov7251)\n\t\treturn -ENOMEM;\n\n\tov7251->i2c_client = client;\n\tov7251->dev = dev;\n\n\tret = ov7251_check_hwcfg(ov7251);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tov7251->xclk = devm_clk_get_optional(dev, NULL);\n\tif (IS_ERR(ov7251->xclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(ov7251->xclk),\n\t\t\t\t     \"could not get xclk\");\n\n\t \n\tret = fwnode_property_read_u32(dev_fwnode(dev), \"clock-frequency\",\n\t\t\t\t       &rate);\n\tif (ret && !ov7251->xclk)\n\t\treturn dev_err_probe(dev, ret, \"invalid clock config\\n\");\n\n\tclk_rate = clk_get_rate(ov7251->xclk);\n\tov7251->xclk_freq = clk_rate ? clk_rate : rate;\n\n\tif (ov7251->xclk_freq == 0)\n\t\treturn dev_err_probe(dev, -EINVAL, \"invalid clock frequency\\n\");\n\n\tif (!ret && ov7251->xclk) {\n\t\tret = clk_set_rate(ov7251->xclk, rate);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t\t     \"failed to set clock rate\\n\");\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(supported_xclk_rates); i++)\n\t\tif (ov7251->xclk_freq == supported_xclk_rates[i])\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(supported_xclk_rates))\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"clock rate %u Hz is unsupported\\n\",\n\t\t\t\t     ov7251->xclk_freq);\n\n\tov7251->pll_cfgs = ov7251_pll_cfgs[i];\n\n\tov7251->io_regulator = devm_regulator_get(dev, \"vdddo\");\n\tif (IS_ERR(ov7251->io_regulator)) {\n\t\tdev_err(dev, \"cannot get io regulator\\n\");\n\t\treturn PTR_ERR(ov7251->io_regulator);\n\t}\n\n\tov7251->core_regulator = devm_regulator_get(dev, \"vddd\");\n\tif (IS_ERR(ov7251->core_regulator)) {\n\t\tdev_err(dev, \"cannot get core regulator\\n\");\n\t\treturn PTR_ERR(ov7251->core_regulator);\n\t}\n\n\tov7251->analog_regulator = devm_regulator_get(dev, \"vdda\");\n\tif (IS_ERR(ov7251->analog_regulator)) {\n\t\tdev_err(dev, \"cannot get analog regulator\\n\");\n\t\treturn PTR_ERR(ov7251->analog_regulator);\n\t}\n\n\tov7251->enable_gpio = devm_gpiod_get(dev, \"enable\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ov7251->enable_gpio)) {\n\t\tdev_err(dev, \"cannot get enable gpio\\n\");\n\t\treturn PTR_ERR(ov7251->enable_gpio);\n\t}\n\n\tmutex_init(&ov7251->lock);\n\n\tov7251->current_mode = &ov7251_mode_info_data[0];\n\tret = ov7251_init_ctrls(ov7251);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"error during v4l2 ctrl init\\n\");\n\t\tgoto destroy_mutex;\n\t}\n\n\tv4l2_i2c_subdev_init(&ov7251->sd, client, &ov7251_subdev_ops);\n\tov7251->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tov7251->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tov7251->sd.dev = &client->dev;\n\tov7251->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\n\tret = media_entity_pads_init(&ov7251->sd.entity, 1, &ov7251->pad);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not register media entity\\n\");\n\t\tgoto free_ctrl;\n\t}\n\n\tret = ov7251_set_power_on(ov7251->dev);\n\tif (ret)\n\t\tgoto free_entity;\n\n\tret = ov7251_detect_chip(ov7251);\n\tif (ret)\n\t\tgoto power_down;\n\n\tpm_runtime_set_active(&client->dev);\n\tpm_runtime_get_noresume(&client->dev);\n\tpm_runtime_enable(&client->dev);\n\n\tret = ov7251_read_reg(ov7251, OV7251_PRE_ISP_00,\n\t\t\t      &ov7251->pre_isp_00);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not read test pattern value\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_pm_runtime;\n\t}\n\n\tret = ov7251_read_reg(ov7251, OV7251_TIMING_FORMAT1,\n\t\t\t      &ov7251->timing_format1);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not read vflip value\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_pm_runtime;\n\t}\n\n\tret = ov7251_read_reg(ov7251, OV7251_TIMING_FORMAT2,\n\t\t\t      &ov7251->timing_format2);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not read hflip value\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_pm_runtime;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(&client->dev, 1000);\n\tpm_runtime_use_autosuspend(&client->dev);\n\tpm_runtime_put_autosuspend(&client->dev);\n\n\tret = v4l2_async_register_subdev(&ov7251->sd);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not register v4l2 device\\n\");\n\t\tgoto free_entity;\n\t}\n\n\tov7251_entity_init_cfg(&ov7251->sd, NULL);\n\n\treturn 0;\n\nerr_pm_runtime:\n\tpm_runtime_disable(ov7251->dev);\n\tpm_runtime_put_noidle(ov7251->dev);\npower_down:\n\tov7251_set_power_off(ov7251->dev);\nfree_entity:\n\tmedia_entity_cleanup(&ov7251->sd.entity);\nfree_ctrl:\n\tv4l2_ctrl_handler_free(&ov7251->ctrls);\ndestroy_mutex:\n\tmutex_destroy(&ov7251->lock);\n\n\treturn ret;\n}\n\nstatic void ov7251_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov7251 *ov7251 = to_ov7251(sd);\n\n\tv4l2_async_unregister_subdev(&ov7251->sd);\n\tmedia_entity_cleanup(&ov7251->sd.entity);\n\tv4l2_ctrl_handler_free(&ov7251->ctrls);\n\tmutex_destroy(&ov7251->lock);\n\n\tpm_runtime_disable(ov7251->dev);\n\tif (!pm_runtime_status_suspended(ov7251->dev))\n\t\tov7251_set_power_off(ov7251->dev);\n\tpm_runtime_set_suspended(ov7251->dev);\n}\n\nstatic const struct dev_pm_ops ov7251_pm_ops = {\n\tSET_RUNTIME_PM_OPS(ov7251_set_power_off, ov7251_set_power_on, NULL)\n};\n\nstatic const struct of_device_id ov7251_of_match[] = {\n\t{ .compatible = \"ovti,ov7251\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ov7251_of_match);\n\nstatic const struct acpi_device_id ov7251_acpi_match[] = {\n\t{ \"INT347E\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, ov7251_acpi_match);\n\nstatic struct i2c_driver ov7251_i2c_driver = {\n\t.driver = {\n\t\t.of_match_table = ov7251_of_match,\n\t\t.acpi_match_table = ov7251_acpi_match,\n\t\t.name  = \"ov7251\",\n\t\t.pm = &ov7251_pm_ops,\n\t},\n\t.probe = ov7251_probe,\n\t.remove = ov7251_remove,\n};\n\nmodule_i2c_driver(ov7251_i2c_driver);\n\nMODULE_DESCRIPTION(\"Omnivision OV7251 Camera Driver\");\nMODULE_AUTHOR(\"Todor Tomov <todor.tomov@linaro.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}