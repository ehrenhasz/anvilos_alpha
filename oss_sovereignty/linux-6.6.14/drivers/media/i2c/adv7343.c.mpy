{
  "module_name": "adv7343.c",
  "hash_id": "4bb021d8691e50c87d3328773fdfc73e36525d157ed8d07f73d11218b6b862ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/adv7343.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/videodev2.h>\n#include <linux/uaccess.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n\n#include <media/i2c/adv7343.h>\n#include <media/v4l2-async.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n\n#include \"adv7343_regs.h\"\n\nMODULE_DESCRIPTION(\"ADV7343 video encoder driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Debug level 0-1\");\n\nstruct adv7343_state {\n\tstruct v4l2_subdev sd;\n\tstruct v4l2_ctrl_handler hdl;\n\tconst struct adv7343_platform_data *pdata;\n\tu8 reg00;\n\tu8 reg01;\n\tu8 reg02;\n\tu8 reg35;\n\tu8 reg80;\n\tu8 reg82;\n\tu32 output;\n\tv4l2_std_id std;\n};\n\nstatic inline struct adv7343_state *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct adv7343_state, sd);\n}\n\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct adv7343_state, hdl)->sd;\n}\n\nstatic inline int adv7343_write(struct v4l2_subdev *sd, u8 reg, u8 value)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn i2c_smbus_write_byte_data(client, reg, value);\n}\n\nstatic const u8 adv7343_init_reg_val[] = {\n\tADV7343_SOFT_RESET, ADV7343_SOFT_RESET_DEFAULT,\n\tADV7343_POWER_MODE_REG, ADV7343_POWER_MODE_REG_DEFAULT,\n\n\tADV7343_HD_MODE_REG1, ADV7343_HD_MODE_REG1_DEFAULT,\n\tADV7343_HD_MODE_REG2, ADV7343_HD_MODE_REG2_DEFAULT,\n\tADV7343_HD_MODE_REG3, ADV7343_HD_MODE_REG3_DEFAULT,\n\tADV7343_HD_MODE_REG4, ADV7343_HD_MODE_REG4_DEFAULT,\n\tADV7343_HD_MODE_REG5, ADV7343_HD_MODE_REG5_DEFAULT,\n\tADV7343_HD_MODE_REG6, ADV7343_HD_MODE_REG6_DEFAULT,\n\tADV7343_HD_MODE_REG7, ADV7343_HD_MODE_REG7_DEFAULT,\n\n\tADV7343_SD_MODE_REG1, ADV7343_SD_MODE_REG1_DEFAULT,\n\tADV7343_SD_MODE_REG2, ADV7343_SD_MODE_REG2_DEFAULT,\n\tADV7343_SD_MODE_REG3, ADV7343_SD_MODE_REG3_DEFAULT,\n\tADV7343_SD_MODE_REG4, ADV7343_SD_MODE_REG4_DEFAULT,\n\tADV7343_SD_MODE_REG5, ADV7343_SD_MODE_REG5_DEFAULT,\n\tADV7343_SD_MODE_REG6, ADV7343_SD_MODE_REG6_DEFAULT,\n\tADV7343_SD_MODE_REG7, ADV7343_SD_MODE_REG7_DEFAULT,\n\tADV7343_SD_MODE_REG8, ADV7343_SD_MODE_REG8_DEFAULT,\n\n\tADV7343_SD_HUE_REG, ADV7343_SD_HUE_REG_DEFAULT,\n\tADV7343_SD_CGMS_WSS0, ADV7343_SD_CGMS_WSS0_DEFAULT,\n\tADV7343_SD_BRIGHTNESS_WSS, ADV7343_SD_BRIGHTNESS_WSS_DEFAULT,\n};\n\n \nstatic const struct adv7343_std_info stdinfo[] = {\n\t{\n\t\t \n\t\tSD_STD_NTSC, 569408542, V4L2_STD_NTSC,\n\t}, {\n\t\t \n\t\tSD_STD_PAL_M, 568782678, V4L2_STD_PAL_M,\n\t}, {\n\t\t \n\t\tSD_STD_PAL_N, 569807903, V4L2_STD_PAL_Nc,\n\t}, {\n\t\t \n\t\tSD_STD_PAL_N, 705268427, V4L2_STD_PAL_N,\n\t}, {\n\t\t \n\t\tSD_STD_PAL_BDGHI, 705268427, V4L2_STD_PAL,\n\t}, {\n\t\t \n\t\tSD_STD_NTSC, 705268427, V4L2_STD_NTSC_443,\n\t}, {\n\t\t \n\t\tSD_STD_PAL_M, 705268427, V4L2_STD_PAL_60,\n\t},\n};\n\nstatic int adv7343_setstd(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct adv7343_state *state = to_state(sd);\n\tstruct adv7343_std_info *std_info;\n\tint num_std;\n\tchar *fsc_ptr;\n\tu8 reg, val;\n\tint err = 0;\n\tint i = 0;\n\n\tstd_info = (struct adv7343_std_info *)stdinfo;\n\tnum_std = ARRAY_SIZE(stdinfo);\n\n\tfor (i = 0; i < num_std; i++) {\n\t\tif (std_info[i].stdid & std)\n\t\t\tbreak;\n\t}\n\n\tif (i == num_std) {\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t\t\"Invalid std or std is not supported: %llx\\n\",\n\t\t\t\t\t\t(unsigned long long)std);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tval = state->reg80 & (~(SD_STD_MASK));\n\tval |= std_info[i].standard_val3;\n\terr = adv7343_write(sd, ADV7343_SD_MODE_REG1, val);\n\tif (err < 0)\n\t\tgoto setstd_exit;\n\n\tstate->reg80 = val;\n\n\t \n\tval = state->reg01 & (~((u8) INPUT_MODE_MASK));\n\tval |= SD_INPUT_MODE;\n\terr = adv7343_write(sd, ADV7343_MODE_SELECT_REG, val);\n\tif (err < 0)\n\t\tgoto setstd_exit;\n\n\tstate->reg01 = val;\n\n\t \n\tfsc_ptr = (unsigned char *)&std_info[i].fsc_val;\n\treg = ADV7343_FSC_REG0;\n\tfor (i = 0; i < 4; i++, reg++, fsc_ptr++) {\n\t\terr = adv7343_write(sd, reg, *fsc_ptr);\n\t\tif (err < 0)\n\t\t\tgoto setstd_exit;\n\t}\n\n\tval = state->reg80;\n\n\t \n\tif (std & (V4L2_STD_NTSC | V4L2_STD_NTSC_443))\n\t\tval &= 0x03;\n\telse if (std & ~V4L2_STD_SECAM)\n\t\tval |= 0x04;\n\n\terr = adv7343_write(sd, ADV7343_SD_MODE_REG1, val);\n\tif (err < 0)\n\t\tgoto setstd_exit;\n\n\tstate->reg80 = val;\n\nsetstd_exit:\n\tif (err != 0)\n\t\tv4l2_err(sd, \"Error setting std, write failed\\n\");\n\n\treturn err;\n}\n\nstatic int adv7343_setoutput(struct v4l2_subdev *sd, u32 output_type)\n{\n\tstruct adv7343_state *state = to_state(sd);\n\tunsigned char val;\n\tint err = 0;\n\n\tif (output_type > ADV7343_SVIDEO_ID) {\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t\"Invalid output type or output type not supported:%d\\n\",\n\t\t\t\t\t\t\t\toutput_type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tval = state->reg00 & 0x03;\n\n\t \n\tif (!state->pdata)\n\t\tif (output_type == ADV7343_COMPOSITE_ID)\n\t\t\tval |= ADV7343_COMPOSITE_POWER_VALUE;\n\t\telse if (output_type == ADV7343_COMPONENT_ID)\n\t\t\tval |= ADV7343_COMPONENT_POWER_VALUE;\n\t\telse\n\t\t\tval |= ADV7343_SVIDEO_POWER_VALUE;\n\telse\n\t\tval = state->pdata->mode_config.sleep_mode << 0 |\n\t\t      state->pdata->mode_config.pll_control << 1 |\n\t\t      state->pdata->mode_config.dac[2] << 2 |\n\t\t      state->pdata->mode_config.dac[1] << 3 |\n\t\t      state->pdata->mode_config.dac[0] << 4 |\n\t\t      state->pdata->mode_config.dac[5] << 5 |\n\t\t      state->pdata->mode_config.dac[4] << 6 |\n\t\t      state->pdata->mode_config.dac[3] << 7;\n\n\terr = adv7343_write(sd, ADV7343_POWER_MODE_REG, val);\n\tif (err < 0)\n\t\tgoto setoutput_exit;\n\n\tstate->reg00 = val;\n\n\t \n\tval = state->reg02 | YUV_OUTPUT_SELECT;\n\terr = adv7343_write(sd, ADV7343_MODE_REG0, val);\n\tif (err < 0)\n\t\tgoto setoutput_exit;\n\n\tstate->reg02 = val;\n\n\t \n\tval = state->reg82 & (SD_DAC_1_DI & SD_DAC_2_DI);\n\n\tif (state->pdata && state->pdata->sd_config.sd_dac_out[0])\n\t\tval = val | (state->pdata->sd_config.sd_dac_out[0] << 1);\n\telse if (state->pdata && !state->pdata->sd_config.sd_dac_out[0])\n\t\tval = val & ~(state->pdata->sd_config.sd_dac_out[0] << 1);\n\n\tif (state->pdata && state->pdata->sd_config.sd_dac_out[1])\n\t\tval = val | (state->pdata->sd_config.sd_dac_out[1] << 2);\n\telse if (state->pdata && !state->pdata->sd_config.sd_dac_out[1])\n\t\tval = val & ~(state->pdata->sd_config.sd_dac_out[1] << 2);\n\n\terr = adv7343_write(sd, ADV7343_SD_MODE_REG2, val);\n\tif (err < 0)\n\t\tgoto setoutput_exit;\n\n\tstate->reg82 = val;\n\n\t \n\tval = state->reg35 & (HD_RGB_INPUT_DI & HD_DAC_SWAP_DI);\n\terr = adv7343_write(sd, ADV7343_HD_MODE_REG6, val);\n\tif (err < 0)\n\t\tgoto setoutput_exit;\n\n\tstate->reg35 = val;\n\nsetoutput_exit:\n\tif (err != 0)\n\t\tv4l2_err(sd, \"Error setting output, write failed\\n\");\n\n\treturn err;\n}\n\nstatic int adv7343_log_status(struct v4l2_subdev *sd)\n{\n\tstruct adv7343_state *state = to_state(sd);\n\n\tv4l2_info(sd, \"Standard: %llx\\n\", (unsigned long long)state->std);\n\tv4l2_info(sd, \"Output: %s\\n\", (state->output == 0) ? \"Composite\" :\n\t\t\t((state->output == 1) ? \"Component\" : \"S-Video\"));\n\treturn 0;\n}\n\nstatic int adv7343_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\treturn adv7343_write(sd, ADV7343_SD_BRIGHTNESS_WSS,\n\t\t\t\t\tctrl->val);\n\n\tcase V4L2_CID_HUE:\n\t\treturn adv7343_write(sd, ADV7343_SD_HUE_REG, ctrl->val);\n\n\tcase V4L2_CID_GAIN:\n\t\treturn adv7343_write(sd, ADV7343_DAC2_OUTPUT_LEVEL, ctrl->val);\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct v4l2_ctrl_ops adv7343_ctrl_ops = {\n\t.s_ctrl = adv7343_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops adv7343_core_ops = {\n\t.log_status = adv7343_log_status,\n};\n\nstatic int adv7343_s_std_output(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct adv7343_state *state = to_state(sd);\n\tint err = 0;\n\n\tif (state->std == std)\n\t\treturn 0;\n\n\terr = adv7343_setstd(sd, std);\n\tif (!err)\n\t\tstate->std = std;\n\n\treturn err;\n}\n\nstatic int adv7343_s_routing(struct v4l2_subdev *sd,\n\t\tu32 input, u32 output, u32 config)\n{\n\tstruct adv7343_state *state = to_state(sd);\n\tint err = 0;\n\n\tif (state->output == output)\n\t\treturn 0;\n\n\terr = adv7343_setoutput(sd, output);\n\tif (!err)\n\t\tstate->output = output;\n\n\treturn err;\n}\n\nstatic const struct v4l2_subdev_video_ops adv7343_video_ops = {\n\t.s_std_output\t= adv7343_s_std_output,\n\t.s_routing\t= adv7343_s_routing,\n};\n\nstatic const struct v4l2_subdev_ops adv7343_ops = {\n\t.core\t= &adv7343_core_ops,\n\t.video\t= &adv7343_video_ops,\n};\n\nstatic int adv7343_initialize(struct v4l2_subdev *sd)\n{\n\tstruct adv7343_state *state = to_state(sd);\n\tint err = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(adv7343_init_reg_val); i += 2) {\n\n\t\terr = adv7343_write(sd, adv7343_init_reg_val[i],\n\t\t\t\t\tadv7343_init_reg_val[i+1]);\n\t\tif (err) {\n\t\t\tv4l2_err(sd, \"Error initializing\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\terr = adv7343_setoutput(sd, state->output);\n\tif (err < 0) {\n\t\tv4l2_err(sd, \"Error setting output during init\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = adv7343_setstd(sd, state->std);\n\tif (err < 0) {\n\t\tv4l2_err(sd, \"Error setting std during init\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic struct adv7343_platform_data *\nadv7343_get_pdata(struct i2c_client *client)\n{\n\tstruct adv7343_platform_data *pdata;\n\tstruct device_node *np;\n\n\tif (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)\n\t\treturn client->dev.platform_data;\n\n\tnp = of_graph_get_next_endpoint(client->dev.of_node, NULL);\n\tif (!np)\n\t\treturn NULL;\n\n\tpdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\tgoto done;\n\n\tpdata->mode_config.sleep_mode =\n\t\t\tof_property_read_bool(np, \"adi,power-mode-sleep-mode\");\n\n\tpdata->mode_config.pll_control =\n\t\t\tof_property_read_bool(np, \"adi,power-mode-pll-ctrl\");\n\n\tof_property_read_u32_array(np, \"adi,dac-enable\",\n\t\t\t\t   pdata->mode_config.dac, 6);\n\n\tof_property_read_u32_array(np, \"adi,sd-dac-enable\",\n\t\t\t\t   pdata->sd_config.sd_dac_out, 2);\n\ndone:\n\tof_node_put(np);\n\treturn pdata;\n}\n\nstatic int adv7343_probe(struct i2c_client *client)\n{\n\tstruct adv7343_state *state;\n\tint err;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tv4l_info(client, \"chip found @ 0x%x (%s)\\n\",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tstate = devm_kzalloc(&client->dev, sizeof(struct adv7343_state),\n\t\t\t     GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tstate->pdata = adv7343_get_pdata(client);\n\n\tstate->reg00\t= 0x80;\n\tstate->reg01\t= 0x00;\n\tstate->reg02\t= 0x20;\n\tstate->reg35\t= 0x00;\n\tstate->reg80\t= ADV7343_SD_MODE_REG1_DEFAULT;\n\tstate->reg82\t= ADV7343_SD_MODE_REG2_DEFAULT;\n\n\tstate->output = ADV7343_COMPOSITE_ID;\n\tstate->std = V4L2_STD_NTSC;\n\n\tv4l2_i2c_subdev_init(&state->sd, client, &adv7343_ops);\n\n\tv4l2_ctrl_handler_init(&state->hdl, 2);\n\tv4l2_ctrl_new_std(&state->hdl, &adv7343_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, ADV7343_BRIGHTNESS_MIN,\n\t\t\t\t\t     ADV7343_BRIGHTNESS_MAX, 1,\n\t\t\t\t\t     ADV7343_BRIGHTNESS_DEF);\n\tv4l2_ctrl_new_std(&state->hdl, &adv7343_ctrl_ops,\n\t\t\tV4L2_CID_HUE, ADV7343_HUE_MIN,\n\t\t\t\t      ADV7343_HUE_MAX, 1,\n\t\t\t\t      ADV7343_HUE_DEF);\n\tv4l2_ctrl_new_std(&state->hdl, &adv7343_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, ADV7343_GAIN_MIN,\n\t\t\t\t       ADV7343_GAIN_MAX, 1,\n\t\t\t\t       ADV7343_GAIN_DEF);\n\tstate->sd.ctrl_handler = &state->hdl;\n\tif (state->hdl.error) {\n\t\terr = state->hdl.error;\n\t\tgoto done;\n\t}\n\tv4l2_ctrl_handler_setup(&state->hdl);\n\n\terr = adv7343_initialize(&state->sd);\n\tif (err)\n\t\tgoto done;\n\n\terr = v4l2_async_register_subdev(&state->sd);\n\ndone:\n\tif (err < 0)\n\t\tv4l2_ctrl_handler_free(&state->hdl);\n\n\treturn err;\n}\n\nstatic void adv7343_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct adv7343_state *state = to_state(sd);\n\n\tv4l2_async_unregister_subdev(&state->sd);\n\tv4l2_ctrl_handler_free(&state->hdl);\n}\n\nstatic const struct i2c_device_id adv7343_id[] = {\n\t{\"adv7343\", 0},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(i2c, adv7343_id);\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id adv7343_of_match[] = {\n\t{.compatible = \"adi,adv7343\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, adv7343_of_match);\n#endif\n\nstatic struct i2c_driver adv7343_driver = {\n\t.driver = {\n\t\t.of_match_table = of_match_ptr(adv7343_of_match),\n\t\t.name\t= \"adv7343\",\n\t},\n\t.probe\t\t= adv7343_probe,\n\t.remove\t\t= adv7343_remove,\n\t.id_table\t= adv7343_id,\n};\n\nmodule_i2c_driver(adv7343_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}