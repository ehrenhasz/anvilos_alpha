{
  "module_name": "ccs.h",
  "hash_id": "02f5ed976f451953e67795c18afc69a7122a07e23c124c47dc8b3459654da73c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ccs/ccs.h",
  "human_readable_source": " \n \n\n#ifndef __CCS_H__\n#define __CCS_H__\n\n#include <linux/mutex.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-subdev.h>\n\n#include \"ccs-data.h\"\n#include \"ccs-limits.h\"\n#include \"ccs-quirk.h\"\n#include \"ccs-regs.h\"\n#include \"ccs-reg-access.h\"\n#include \"../ccs-pll.h\"\n#include \"smiapp-reg-defs.h\"\n\n \n#define SMIA_VERSION_1\t\t\t10\n#define SMIAPP_VERSION_0_8\t\t8  \n#define SMIAPP_VERSION_0_9\t\t9  \n#define SMIAPP_VERSION_1\t\t10\n\n#define SMIAPP_PROFILE_0\t\t0\n#define SMIAPP_PROFILE_1\t\t1\n#define SMIAPP_PROFILE_2\t\t2\n\n#define SMIAPP_NVM_PAGE_SIZE\t\t64\t \n\n#define SMIAPP_RESET_DELAY_CLOCKS\t2400\n#define SMIAPP_RESET_DELAY(clk)\t\t\t\t\\\n\t(1000 +\t(SMIAPP_RESET_DELAY_CLOCKS * 1000\t\\\n\t\t + (clk) / 1000 - 1) / ((clk) / 1000))\n\n#define CCS_COLOUR_COMPONENTS\t\t4\n\n#define SMIAPP_NAME\t\t\t\"smiapp\"\n#define CCS_NAME\t\t\t\"ccs\"\n\n#define CCS_DFL_I2C_ADDR\t(0x20 >> 1)  \n#define CCS_ALT_I2C_ADDR\t(0x6e >> 1)  \n\n#define CCS_LIM(sensor, limit) \\\n\tccs_get_limit(sensor, CCS_L_##limit, 0)\n\n#define CCS_LIM_AT(sensor, limit, offset)\t\\\n\tccs_get_limit(sensor, CCS_L_##limit, CCS_L_##limit##_OFFSET(offset))\n\nstruct ccs_flash_strobe_parms {\n\tu8 mode;\n\tu32 strobe_width_high_us;\n\tu16 strobe_delay;\n\tu16 stobe_start_point;\n\tu8 trigger;\n};\n\nstruct ccs_hwconfig {\n\t \n\tunsigned short i2c_addr_dfl;\t \n\tunsigned short i2c_addr_alt;\t \n\n\tu32 ext_clk;\t\t\t \n\n\tunsigned int lanes;\t\t \n\tu32 csi_signalling_mode;\t \n\tu64 *op_sys_clock;\n\n\tstruct ccs_flash_strobe_parms *strobe_setup;\n};\n\nstruct ccs_quirk;\n\n#define CCS_MODULE_IDENT_FLAG_REV_LE\t\t(1 << 0)\n\nstruct ccs_module_ident {\n\tu16 mipi_manufacturer_id;\n\tu16 model_id;\n\tu8 smia_manufacturer_id;\n\tu8 revision_number_major;\n\n\tu8 flags;\n\n\tchar *name;\n\tconst struct ccs_quirk *quirk;\n};\n\nstruct ccs_module_info {\n\tu32 smia_manufacturer_id;\n\tu32 mipi_manufacturer_id;\n\tu32 model_id;\n\tu32 revision_number;\n\n\tu32 module_year;\n\tu32 module_month;\n\tu32 module_day;\n\n\tu32 sensor_smia_manufacturer_id;\n\tu32 sensor_mipi_manufacturer_id;\n\tu32 sensor_model_id;\n\tu32 sensor_revision_number;\n\tu32 sensor_firmware_version;\n\n\tu32 smia_version;\n\tu32 smiapp_version;\n\tu32 ccs_version;\n\n\tchar *name;\n\tconst struct ccs_quirk *quirk;\n};\n\n#define CCS_IDENT_FQ(manufacturer, model, rev, fl, _name, _quirk)\t\\\n\t{ .smia_manufacturer_id = manufacturer,\t\t\t\t\\\n\t  .model_id = model,\t\t\t\t\t\t\\\n\t  .revision_number_major = rev,\t\t\t\t\t\\\n\t  .flags = fl,\t\t\t\t\t\t\t\\\n\t  .name = _name,\t\t\t\t\t\t\\\n\t  .quirk = _quirk, }\n\n#define CCS_IDENT_LQ(manufacturer, model, rev, _name, _quirk)\t\\\n\t{ .smia_manufacturer_id = manufacturer,\t\t\t\t\\\n\t  .model_id = model,\t\t\t\t\t\t\\\n\t  .revision_number_major = rev,\t\t\t\t\t\\\n\t  .flags = CCS_MODULE_IDENT_FLAG_REV_LE,\t\t\t\\\n\t  .name = _name,\t\t\t\t\t\t\\\n\t  .quirk = _quirk, }\n\n#define CCS_IDENT_L(manufacturer, model, rev, _name)\t\t\t\\\n\t{ .smia_manufacturer_id = manufacturer,\t\t\t\t\\\n\t  .model_id = model,\t\t\t\t\t\t\\\n\t  .revision_number_major = rev,\t\t\t\t\t\\\n\t  .flags = CCS_MODULE_IDENT_FLAG_REV_LE,\t\t\t\\\n\t  .name = _name, }\n\n#define CCS_IDENT_Q(manufacturer, model, rev, _name, _quirk)\t\t\\\n\t{ .smia_manufacturer_id = manufacturer,\t\t\t\t\\\n\t  .model_id = model,\t\t\t\t\t\t\\\n\t  .revision_number_major = rev,\t\t\t\t\t\\\n\t  .flags = 0,\t\t\t\t\t\t\t\\\n\t  .name = _name,\t\t\t\t\t\t\\\n\t  .quirk = _quirk, }\n\n#define CCS_IDENT(manufacturer, model, rev, _name)\t\t\t\\\n\t{ .smia_manufacturer_id = manufacturer,\t\t\t\t\\\n\t  .model_id = model,\t\t\t\t\t\t\\\n\t  .revision_number_major = rev,\t\t\t\t\t\\\n\t  .flags = 0,\t\t\t\t\t\t\t\\\n\t  .name = _name, }\n\nstruct ccs_csi_data_format {\n\tu32 code;\n\tu8 width;\n\tu8 compressed;\n\tu8 pixel_order;\n};\n\n#define CCS_SUBDEVS\t\t\t3\n\n#define CCS_PA_PAD_SRC\t\t\t0\n#define CCS_PAD_SINK\t\t\t0\n#define CCS_PAD_SRC\t\t\t1\n#define CCS_PADS\t\t\t2\n\nstruct ccs_binning_subtype {\n\tu8 horizontal:4;\n\tu8 vertical:4;\n} __packed;\n\nstruct ccs_subdev {\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pads[CCS_PADS];\n\tstruct v4l2_rect sink_fmt;\n\tstruct v4l2_rect crop[CCS_PADS];\n\tstruct v4l2_rect compose;  \n\tunsigned short sink_pad;\n\tunsigned short source_pad;\n\tint npads;\n\tstruct ccs_sensor *sensor;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n};\n\n \nstruct ccs_sensor {\n\t \n\tstruct mutex mutex;\n\tstruct ccs_subdev ssds[CCS_SUBDEVS];\n\tu32 ssds_used;\n\tstruct ccs_subdev *src;\n\tstruct ccs_subdev *binner;\n\tstruct ccs_subdev *scaler;\n\tstruct ccs_subdev *pixel_array;\n\tstruct ccs_hwconfig hwcfg;\n\tstruct regulator_bulk_data *regulators;\n\tstruct clk *ext_clk;\n\tstruct gpio_desc *xshutdown;\n\tstruct gpio_desc *reset;\n\tvoid *ccs_limits;\n\tu8 nbinning_subtypes;\n\tstruct ccs_binning_subtype binning_subtypes[CCS_LIM_BINNING_SUB_TYPE_MAX_N + 1];\n\tu32 mbus_frame_fmts;\n\tconst struct ccs_csi_data_format *csi_format;\n\tconst struct ccs_csi_data_format *internal_csi_format;\n\tu32 default_mbus_frame_fmts;\n\tint default_pixel_order;\n\tstruct ccs_data_container sdata, mdata;\n\n\tu8 binning_horizontal;\n\tu8 binning_vertical;\n\n\tu8 scale_m;\n\tu8 scaling_mode;\n\n\tu8 frame_skip;\n\tu16 embedded_start;  \n\tu16 embedded_end;\n\tu16 image_start;  \n\tu16 visible_pixel_start;  \n\n\tbool streaming;\n\tbool dev_init_done;\n\tu8 compressed_min_bpp;\n\n\tstruct ccs_module_info minfo;\n\n\tstruct ccs_pll pll;\n\n\t \n\tunsigned long *valid_link_freqs;\n\n\t \n\tstruct v4l2_ctrl *exposure;\n\tstruct v4l2_ctrl *hflip;\n\tstruct v4l2_ctrl *vflip;\n\tstruct v4l2_ctrl *vblank;\n\tstruct v4l2_ctrl *hblank;\n\tstruct v4l2_ctrl *pixel_rate_parray;\n\tstruct v4l2_ctrl *luminance_level;\n\t \n\tstruct v4l2_ctrl *link_freq;\n\tstruct v4l2_ctrl *pixel_rate_csi;\n\t \n\tstruct v4l2_ctrl *test_data[CCS_COLOUR_COMPONENTS];\n};\n\n#define to_ccs_subdev(_sd)\t\t\t\t\\\n\tcontainer_of(_sd, struct ccs_subdev, sd)\n\n#define to_ccs_sensor(_sd)\t\\\n\t(to_ccs_subdev(_sd)->sensor)\n\nvoid ccs_replace_limit(struct ccs_sensor *sensor,\n\t\t       unsigned int limit, unsigned int offset, u32 val);\nu32 ccs_get_limit(struct ccs_sensor *sensor, unsigned int limit,\n\t\t  unsigned int offset);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}