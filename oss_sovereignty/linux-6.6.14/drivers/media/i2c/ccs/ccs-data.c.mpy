{
  "module_name": "ccs-data.c",
  "hash_id": "c12fd84d5ae89f67bd922e01ab101b90554cf30fa32e99a8c6ef56ca537d8c56",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ccs/ccs-data.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/limits.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\n#include \"ccs-data-defs.h\"\n\nstruct bin_container {\n\tvoid *base;\n\tvoid *now;\n\tvoid *end;\n\tsize_t size;\n};\n\nstatic void *bin_alloc(struct bin_container *bin, size_t len)\n{\n\tvoid *ptr;\n\n\tlen = ALIGN(len, 8);\n\n\tif (bin->end - bin->now < len)\n\t\treturn NULL;\n\n\tptr = bin->now;\n\tbin->now += len;\n\n\treturn ptr;\n}\n\nstatic void bin_reserve(struct bin_container *bin, size_t len)\n{\n\tbin->size += ALIGN(len, 8);\n}\n\nstatic int bin_backing_alloc(struct bin_container *bin)\n{\n\tbin->base = bin->now = kvzalloc(bin->size, GFP_KERNEL);\n\tif (!bin->base)\n\t\treturn -ENOMEM;\n\n\tbin->end = bin->base + bin->size;\n\n\treturn 0;\n}\n\n#define is_contained(var, endp)\t\t\t\t\\\n\t(sizeof(*var) <= (endp) - (void *)(var))\n#define has_headroom(ptr, headroom, endp)\t\\\n\t((headroom) <= (endp) - (void *)(ptr))\n#define is_contained_with_headroom(var, headroom, endp)\t\t\\\n\t(sizeof(*var) + (headroom) <= (endp) - (void *)(var))\n\nstatic int\nccs_data_parse_length_specifier(const struct __ccs_data_length_specifier *__len,\n\t\t\t\tsize_t *__hlen, size_t *__plen,\n\t\t\t\tconst void *endp)\n{\n\tsize_t hlen, plen;\n\n\tif (!is_contained(__len, endp))\n\t\treturn -ENODATA;\n\n\tswitch (__len->length >> CCS_DATA_LENGTH_SPECIFIER_SIZE_SHIFT) {\n\tcase CCS_DATA_LENGTH_SPECIFIER_1:\n\t\thlen = sizeof(*__len);\n\t\tplen = __len->length &\n\t\t\t((1 << CCS_DATA_LENGTH_SPECIFIER_SIZE_SHIFT) - 1);\n\t\tbreak;\n\tcase CCS_DATA_LENGTH_SPECIFIER_2: {\n\t\tstruct __ccs_data_length_specifier2 *__len2 = (void *)__len;\n\n\t\tif (!is_contained(__len2, endp))\n\t\t\treturn -ENODATA;\n\n\t\thlen = sizeof(*__len2);\n\t\tplen = ((size_t)\n\t\t\t(__len2->length[0] &\n\t\t\t ((1 << CCS_DATA_LENGTH_SPECIFIER_SIZE_SHIFT) - 1))\n\t\t\t<< 8) + __len2->length[1];\n\t\tbreak;\n\t}\n\tcase CCS_DATA_LENGTH_SPECIFIER_3: {\n\t\tstruct __ccs_data_length_specifier3 *__len3 = (void *)__len;\n\n\t\tif (!is_contained(__len3, endp))\n\t\t\treturn -ENODATA;\n\n\t\thlen = sizeof(*__len3);\n\t\tplen = ((size_t)\n\t\t\t(__len3->length[0] &\n\t\t\t ((1 << CCS_DATA_LENGTH_SPECIFIER_SIZE_SHIFT) - 1))\n\t\t\t<< 16) + (__len3->length[0] << 8) + __len3->length[1];\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!has_headroom(__len, hlen + plen, endp))\n\t\treturn -ENODATA;\n\n\t*__hlen = hlen;\n\t*__plen = plen;\n\n\treturn 0;\n}\n\nstatic u8\nccs_data_parse_format_version(const struct __ccs_data_block *block)\n{\n\treturn block->id >> CCS_DATA_BLOCK_HEADER_ID_VERSION_SHIFT;\n}\n\nstatic u8 ccs_data_parse_block_id(const struct __ccs_data_block *block,\n\t\t\t\t       bool is_first)\n{\n\tif (!is_first)\n\t\treturn block->id;\n\n\treturn block->id & ((1 << CCS_DATA_BLOCK_HEADER_ID_VERSION_SHIFT) - 1);\n}\n\nstatic int ccs_data_parse_version(struct bin_container *bin,\n\t\t\t\t  struct ccs_data_container *ccsdata,\n\t\t\t\t  const void *payload, const void *endp)\n{\n\tconst struct __ccs_data_block_version *v = payload;\n\tstruct ccs_data_block_version *vv;\n\n\tif (v + 1 != endp)\n\t\treturn -ENODATA;\n\n\tif (!bin->base) {\n\t\tbin_reserve(bin, sizeof(*ccsdata->version));\n\t\treturn 0;\n\t}\n\n\tccsdata->version = bin_alloc(bin, sizeof(*ccsdata->version));\n\tif (!ccsdata->version)\n\t\treturn -ENOMEM;\n\n\tvv = ccsdata->version;\n\tvv->version_major = ((u16)v->static_data_version_major[0] << 8) +\n\t\tv->static_data_version_major[1];\n\tvv->version_minor = ((u16)v->static_data_version_minor[0] << 8) +\n\t\tv->static_data_version_minor[1];\n\tvv->date_year =  ((u16)v->year[0] << 8) + v->year[1];\n\tvv->date_month = v->month;\n\tvv->date_day = v->day;\n\n\treturn 0;\n}\n\nstatic void print_ccs_data_version(struct device *dev,\n\t\t\t\t   struct ccs_data_block_version *v)\n{\n\tdev_dbg(dev,\n\t\t\"static data version %4.4x.%4.4x, date %4.4u-%2.2u-%2.2u\\n\",\n\t\tv->version_major, v->version_minor,\n\t\tv->date_year, v->date_month, v->date_day);\n}\n\nstatic int ccs_data_block_parse_header(const struct __ccs_data_block *block,\n\t\t\t\t       bool is_first, unsigned int *__block_id,\n\t\t\t\t       const void **payload,\n\t\t\t\t       const struct __ccs_data_block **next_block,\n\t\t\t\t       const void *endp, struct device *dev,\n\t\t\t\t       bool verbose)\n{\n\tsize_t plen, hlen;\n\tu8 block_id;\n\tint rval;\n\n\tif (!is_contained(block, endp))\n\t\treturn -ENODATA;\n\n\trval = ccs_data_parse_length_specifier(&block->length, &hlen, &plen,\n\t\t\t\t\t       endp);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tblock_id = ccs_data_parse_block_id(block, is_first);\n\n\tif (verbose)\n\t\tdev_dbg(dev,\n\t\t\t\"Block ID 0x%2.2x, header length %zu, payload length %zu\\n\",\n\t\t\tblock_id, hlen, plen);\n\n\tif (!has_headroom(&block->length, hlen + plen, endp))\n\t\treturn -ENODATA;\n\n\tif (__block_id)\n\t\t*__block_id = block_id;\n\n\tif (payload)\n\t\t*payload = (void *)&block->length + hlen;\n\n\tif (next_block)\n\t\t*next_block = (void *)&block->length + hlen + plen;\n\n\treturn 0;\n}\n\nstatic int ccs_data_parse_regs(struct bin_container *bin,\n\t\t\t       struct ccs_reg **__regs,\n\t\t\t       size_t *__num_regs, const void *payload,\n\t\t\t       const void *endp, struct device *dev)\n{\n\tstruct ccs_reg *regs_base = NULL, *regs = NULL;\n\tsize_t num_regs = 0;\n\tu16 addr = 0;\n\n\tif (bin->base && __regs) {\n\t\tregs = regs_base = bin_alloc(bin, sizeof(*regs) * *__num_regs);\n\t\tif (!regs)\n\t\t\treturn -ENOMEM;\n\t}\n\n\twhile (payload < endp && num_regs < INT_MAX) {\n\t\tconst struct __ccs_data_block_regs *r = payload;\n\t\tsize_t len;\n\t\tconst void *data;\n\n\t\tif (!is_contained(r, endp))\n\t\t\treturn -ENODATA;\n\n\t\tswitch (r->reg_len >> CCS_DATA_BLOCK_REGS_SEL_SHIFT) {\n\t\tcase CCS_DATA_BLOCK_REGS_SEL_REGS:\n\t\t\taddr += r->reg_len & CCS_DATA_BLOCK_REGS_ADDR_MASK;\n\t\t\tlen = ((r->reg_len & CCS_DATA_BLOCK_REGS_LEN_MASK)\n\t\t\t       >> CCS_DATA_BLOCK_REGS_LEN_SHIFT) + 1;\n\n\t\t\tif (!is_contained_with_headroom(r, len, endp))\n\t\t\t\treturn -ENODATA;\n\n\t\t\tdata = r + 1;\n\t\t\tbreak;\n\t\tcase CCS_DATA_BLOCK_REGS_SEL_REGS2: {\n\t\t\tconst struct __ccs_data_block_regs2 *r2 = payload;\n\n\t\t\tif (!is_contained(r2, endp))\n\t\t\t\treturn -ENODATA;\n\n\t\t\taddr += ((u16)(r2->reg_len &\n\t\t\t\t       CCS_DATA_BLOCK_REGS_2_ADDR_MASK) << 8)\n\t\t\t\t+ r2->addr;\n\t\t\tlen = ((r2->reg_len & CCS_DATA_BLOCK_REGS_2_LEN_MASK)\n\t\t\t       >> CCS_DATA_BLOCK_REGS_2_LEN_SHIFT) + 1;\n\n\t\t\tif (!is_contained_with_headroom(r2, len, endp))\n\t\t\t\treturn -ENODATA;\n\n\t\t\tdata = r2 + 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase CCS_DATA_BLOCK_REGS_SEL_REGS3: {\n\t\t\tconst struct __ccs_data_block_regs3 *r3 = payload;\n\n\t\t\tif (!is_contained(r3, endp))\n\t\t\t\treturn -ENODATA;\n\n\t\t\taddr = ((u16)r3->addr[0] << 8) + r3->addr[1];\n\t\t\tlen = (r3->reg_len & CCS_DATA_BLOCK_REGS_3_LEN_MASK) + 1;\n\n\t\t\tif (!is_contained_with_headroom(r3, len, endp))\n\t\t\t\treturn -ENODATA;\n\n\t\t\tdata = r3 + 1;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnum_regs++;\n\n\t\tif (!bin->base) {\n\t\t\tbin_reserve(bin, len);\n\t\t} else if (__regs) {\n\t\t\tif (!regs)\n\t\t\t\treturn -EIO;\n\n\t\t\tregs->addr = addr;\n\t\t\tregs->len = len;\n\t\t\tregs->value = bin_alloc(bin, len);\n\t\t\tif (!regs->value)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tmemcpy(regs->value, data, len);\n\t\t\tregs++;\n\t\t}\n\n\t\taddr += len;\n\t\tpayload = data + len;\n\t}\n\n\tif (!bin->base)\n\t\tbin_reserve(bin, sizeof(*regs) * num_regs);\n\n\tif (__num_regs)\n\t\t*__num_regs = num_regs;\n\n\tif (bin->base && __regs) {\n\t\tif (!regs_base)\n\t\t\treturn -EIO;\n\n\t\t*__regs = regs_base;\n\t}\n\n\treturn 0;\n}\n\nstatic int ccs_data_parse_reg_rules(struct bin_container *bin,\n\t\t\t\t    struct ccs_reg **__regs,\n\t\t\t\t    size_t *__num_regs,\n\t\t\t\t    const void *payload,\n\t\t\t\t    const void *endp, struct device *dev)\n{\n\tint rval;\n\n\tif (!bin->base)\n\t\treturn ccs_data_parse_regs(bin, NULL, NULL, payload, endp, dev);\n\n\trval = ccs_data_parse_regs(bin, NULL, __num_regs, payload, endp, dev);\n\tif (rval)\n\t\treturn rval;\n\n\treturn ccs_data_parse_regs(bin, __regs, __num_regs, payload, endp,\n\t\t\t\t   dev);\n}\n\nstatic void assign_ffd_entry(struct ccs_frame_format_desc *desc,\n\t\t\t     const struct __ccs_data_block_ffd_entry *ent)\n{\n\tdesc->pixelcode = ent->pixelcode;\n\tdesc->value = ((u16)ent->value[0] << 8) + ent->value[1];\n}\n\nstatic int ccs_data_parse_ffd(struct bin_container *bin,\n\t\t\t      struct ccs_frame_format_descs **ffd,\n\t\t\t      const void *payload,\n\t\t\t      const void *endp, struct device *dev)\n{\n\tconst struct __ccs_data_block_ffd *__ffd = payload;\n\tconst struct __ccs_data_block_ffd_entry *__entry;\n\tunsigned int i;\n\n\tif (!is_contained(__ffd, endp))\n\t\treturn -ENODATA;\n\n\tif ((void *)__ffd + sizeof(*__ffd) +\n\t    ((u32)__ffd->num_column_descs +\n\t     (u32)__ffd->num_row_descs) *\n\t    sizeof(struct __ccs_data_block_ffd_entry) != endp)\n\t\treturn -ENODATA;\n\n\tif (!bin->base) {\n\t\tbin_reserve(bin, sizeof(**ffd));\n\t\tbin_reserve(bin, __ffd->num_column_descs *\n\t\t\t    sizeof(struct ccs_frame_format_desc));\n\t\tbin_reserve(bin, __ffd->num_row_descs *\n\t\t\t    sizeof(struct ccs_frame_format_desc));\n\n\t\treturn 0;\n\t}\n\n\t*ffd = bin_alloc(bin, sizeof(**ffd));\n\tif (!*ffd)\n\t\treturn -ENOMEM;\n\n\t(*ffd)->num_column_descs = __ffd->num_column_descs;\n\t(*ffd)->num_row_descs = __ffd->num_row_descs;\n\t__entry = (void *)(__ffd + 1);\n\n\t(*ffd)->column_descs = bin_alloc(bin, __ffd->num_column_descs *\n\t\t\t\t\t sizeof(*(*ffd)->column_descs));\n\tif (!(*ffd)->column_descs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < __ffd->num_column_descs; i++, __entry++)\n\t\tassign_ffd_entry(&(*ffd)->column_descs[i], __entry);\n\n\t(*ffd)->row_descs = bin_alloc(bin, __ffd->num_row_descs *\n\t\t\t\t      sizeof(*(*ffd)->row_descs));\n\tif (!(*ffd)->row_descs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < __ffd->num_row_descs; i++, __entry++)\n\t\tassign_ffd_entry(&(*ffd)->row_descs[i], __entry);\n\n\tif (__entry != endp)\n\t\treturn -EPROTO;\n\n\treturn 0;\n}\n\nstatic int ccs_data_parse_pdaf_readout(struct bin_container *bin,\n\t\t\t\t       struct ccs_pdaf_readout **pdaf_readout,\n\t\t\t\t       const void *payload,\n\t\t\t\t       const void *endp, struct device *dev)\n{\n\tconst struct __ccs_data_block_pdaf_readout *__pdaf = payload;\n\n\tif (!is_contained(__pdaf, endp))\n\t\treturn -ENODATA;\n\n\tif (!bin->base) {\n\t\tbin_reserve(bin, sizeof(**pdaf_readout));\n\t} else {\n\t\t*pdaf_readout = bin_alloc(bin, sizeof(**pdaf_readout));\n\t\tif (!*pdaf_readout)\n\t\t\treturn -ENOMEM;\n\n\t\t(*pdaf_readout)->pdaf_readout_info_order =\n\t\t\t__pdaf->pdaf_readout_info_order;\n\t}\n\n\treturn ccs_data_parse_ffd(bin, !bin->base ? NULL : &(*pdaf_readout)->ffd,\n\t\t\t\t  __pdaf + 1, endp, dev);\n}\n\nstatic int ccs_data_parse_rules(struct bin_container *bin,\n\t\t\t\tstruct ccs_rule **__rules,\n\t\t\t\tsize_t *__num_rules, const void *payload,\n\t\t\t\tconst void *endp, struct device *dev)\n{\n\tstruct ccs_rule *rules_base = NULL, *rules = NULL, *next_rule = NULL;\n\tsize_t num_rules = 0;\n\tconst void *__next_rule = payload;\n\tint rval;\n\n\tif (bin->base) {\n\t\trules_base = next_rule =\n\t\t\tbin_alloc(bin, sizeof(*rules) * *__num_rules);\n\t\tif (!rules_base)\n\t\t\treturn -ENOMEM;\n\t}\n\n\twhile (__next_rule < endp) {\n\t\tsize_t rule_hlen, rule_plen, rule_plen2;\n\t\tconst u8 *__rule_type;\n\t\tconst void *rule_payload;\n\n\t\t \n\t\trval = ccs_data_parse_length_specifier(__next_rule, &rule_hlen,\n\t\t\t\t\t\t       &rule_plen, endp);\n\n\t\tif (rval < 0)\n\t\t\treturn rval;\n\n\t\t__rule_type = __next_rule + rule_hlen;\n\n\t\tif (!is_contained(__rule_type, endp))\n\t\t\treturn -ENODATA;\n\n\t\trule_payload = __rule_type + 1;\n\t\trule_plen2 = rule_plen - sizeof(*__rule_type);\n\n\t\tif (*__rule_type == CCS_DATA_BLOCK_RULE_ID_IF) {\n\t\t\tconst struct __ccs_data_block_rule_if *__if_rules =\n\t\t\t\trule_payload;\n\t\t\tconst size_t __num_if_rules =\n\t\t\t\trule_plen2 / sizeof(*__if_rules);\n\t\t\tstruct ccs_if_rule *if_rule;\n\n\t\t\tif (!has_headroom(__if_rules,\n\t\t\t\t\t  sizeof(*__if_rules) * __num_if_rules,\n\t\t\t\t\t  rule_payload + rule_plen2))\n\t\t\t\treturn -ENODATA;\n\n\t\t\t \n\t\t\tif (__if_rules + __num_if_rules !=\n\t\t\t    rule_payload + rule_plen2)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (!bin->base) {\n\t\t\t\tbin_reserve(bin,\n\t\t\t\t\t    sizeof(*if_rule) *\n\t\t\t\t\t    __num_if_rules);\n\t\t\t\tnum_rules++;\n\t\t\t} else {\n\t\t\t\tunsigned int i;\n\n\t\t\t\tif (!next_rule)\n\t\t\t\t\treturn -EIO;\n\n\t\t\t\trules = next_rule;\n\t\t\t\tnext_rule++;\n\n\t\t\t\tif_rule = bin_alloc(bin,\n\t\t\t\t\t\t    sizeof(*if_rule) *\n\t\t\t\t\t\t    __num_if_rules);\n\t\t\t\tif (!if_rule)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tfor (i = 0; i < __num_if_rules; i++) {\n\t\t\t\t\tif_rule[i].addr =\n\t\t\t\t\t\t((u16)__if_rules[i].addr[0]\n\t\t\t\t\t\t << 8) +\n\t\t\t\t\t\t__if_rules[i].addr[1];\n\t\t\t\t\tif_rule[i].value = __if_rules[i].value;\n\t\t\t\t\tif_rule[i].mask = __if_rules[i].mask;\n\t\t\t\t}\n\n\t\t\t\trules->if_rules = if_rule;\n\t\t\t\trules->num_if_rules = __num_if_rules;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (bin->base && !rules)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tswitch (*__rule_type) {\n\t\t\tcase CCS_DATA_BLOCK_RULE_ID_READ_ONLY_REGS:\n\t\t\t\trval = ccs_data_parse_reg_rules(bin,\n\t\t\t\t\t\t\t\trules ?\n\t\t\t\t\t\t\t\t&rules->read_only_regs : NULL,\n\t\t\t\t\t\t\t\trules ?\n\t\t\t\t\t\t\t\t&rules->num_read_only_regs : NULL,\n\t\t\t\t\t\t\t\trule_payload,\n\t\t\t\t\t\t\t\trule_payload + rule_plen2,\n\t\t\t\t\t\t\t\tdev);\n\t\t\t\tif (rval)\n\t\t\t\t\treturn rval;\n\t\t\t\tbreak;\n\t\t\tcase CCS_DATA_BLOCK_RULE_ID_FFD:\n\t\t\t\trval = ccs_data_parse_ffd(bin, rules ?\n\t\t\t\t\t\t\t  &rules->frame_format : NULL,\n\t\t\t\t\t\t\t  rule_payload,\n\t\t\t\t\t\t\t  rule_payload + rule_plen2,\n\t\t\t\t\t\t\t  dev);\n\t\t\t\tif (rval)\n\t\t\t\t\treturn rval;\n\t\t\t\tbreak;\n\t\t\tcase CCS_DATA_BLOCK_RULE_ID_MSR:\n\t\t\t\trval = ccs_data_parse_reg_rules(bin,\n\t\t\t\t\t\t\t\trules ?\n\t\t\t\t\t\t\t\t&rules->manufacturer_regs : NULL,\n\t\t\t\t\t\t\t\trules ?\n\t\t\t\t\t\t\t\t&rules->num_manufacturer_regs : NULL,\n\t\t\t\t\t\t\t\trule_payload,\n\t\t\t\t\t\t\t\trule_payload + rule_plen2,\n\t\t\t\t\t\t\t\tdev);\n\t\t\t\tif (rval)\n\t\t\t\t\treturn rval;\n\t\t\t\tbreak;\n\t\t\tcase CCS_DATA_BLOCK_RULE_ID_PDAF_READOUT:\n\t\t\t\trval = ccs_data_parse_pdaf_readout(bin,\n\t\t\t\t\t\t\t\t   rules ?\n\t\t\t\t\t\t\t\t   &rules->pdaf_readout : NULL,\n\t\t\t\t\t\t\t\t   rule_payload,\n\t\t\t\t\t\t\t\t   rule_payload + rule_plen2,\n\t\t\t\t\t\t\t\t   dev);\n\t\t\t\tif (rval)\n\t\t\t\t\treturn rval;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_dbg(dev,\n\t\t\t\t\t\"Don't know how to handle rule type %u!\\n\",\n\t\t\t\t\t*__rule_type);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\t__next_rule = __next_rule + rule_hlen + rule_plen;\n\t}\n\n\tif (!bin->base) {\n\t\tbin_reserve(bin, sizeof(*rules) * num_rules);\n\t\t*__num_rules = num_rules;\n\t} else {\n\t\tif (!rules_base)\n\t\t\treturn -EIO;\n\n\t\t*__rules = rules_base;\n\t}\n\n\treturn 0;\n}\n\nstatic int ccs_data_parse_pdaf(struct bin_container *bin, struct ccs_pdaf_pix_loc **pdaf,\n\t\t\t       const void *payload, const void *endp,\n\t\t\t       struct device *dev)\n{\n\tconst struct __ccs_data_block_pdaf_pix_loc *__pdaf = payload;\n\tconst struct __ccs_data_block_pdaf_pix_loc_block_desc_group *__bdesc_group;\n\tconst struct __ccs_data_block_pdaf_pix_loc_pixel_desc *__pixel_desc;\n\tunsigned int i;\n\tu16 num_block_desc_groups;\n\tu8 max_block_type_id = 0;\n\tconst u8 *__num_pixel_descs;\n\n\tif (!is_contained(__pdaf, endp))\n\t\treturn -ENODATA;\n\n\tif (bin->base) {\n\t\t*pdaf = bin_alloc(bin, sizeof(**pdaf));\n\t\tif (!*pdaf)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tbin_reserve(bin, sizeof(**pdaf));\n\t}\n\n\tnum_block_desc_groups =\n\t\t((u16)__pdaf->num_block_desc_groups[0] << 8) +\n\t\t__pdaf->num_block_desc_groups[1];\n\n\tif (bin->base) {\n\t\t(*pdaf)->main_offset_x =\n\t\t\t((u16)__pdaf->main_offset_x[0] << 8) +\n\t\t\t__pdaf->main_offset_x[1];\n\t\t(*pdaf)->main_offset_y =\n\t\t\t((u16)__pdaf->main_offset_y[0] << 8) +\n\t\t\t__pdaf->main_offset_y[1];\n\t\t(*pdaf)->global_pdaf_type = __pdaf->global_pdaf_type;\n\t\t(*pdaf)->block_width = __pdaf->block_width;\n\t\t(*pdaf)->block_height = __pdaf->block_height;\n\t\t(*pdaf)->num_block_desc_groups = num_block_desc_groups;\n\t}\n\n\t__bdesc_group = (const void *)(__pdaf + 1);\n\n\tif (bin->base) {\n\t\t(*pdaf)->block_desc_groups =\n\t\t\tbin_alloc(bin,\n\t\t\t\t  sizeof(struct ccs_pdaf_pix_loc_block_desc_group) *\n\t\t\t\t  num_block_desc_groups);\n\t\tif (!(*pdaf)->block_desc_groups)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tbin_reserve(bin, sizeof(struct ccs_pdaf_pix_loc_block_desc_group) *\n\t\t\t    num_block_desc_groups);\n\t}\n\n\tfor (i = 0; i < num_block_desc_groups; i++) {\n\t\tconst struct __ccs_data_block_pdaf_pix_loc_block_desc *__bdesc;\n\t\tu16 num_block_descs;\n\t\tunsigned int j;\n\n\t\tif (!is_contained(__bdesc_group, endp))\n\t\t\treturn -ENODATA;\n\n\t\tnum_block_descs =\n\t\t\t((u16)__bdesc_group->num_block_descs[0] << 8) +\n\t\t\t__bdesc_group->num_block_descs[1];\n\n\t\tif (bin->base) {\n\t\t\t(*pdaf)->block_desc_groups[i].repeat_y =\n\t\t\t\t__bdesc_group->repeat_y;\n\t\t\t(*pdaf)->block_desc_groups[i].num_block_descs =\n\t\t\t\tnum_block_descs;\n\t\t}\n\n\t\t__bdesc = (const void *)(__bdesc_group + 1);\n\n\t\tif (bin->base) {\n\t\t\t(*pdaf)->block_desc_groups[i].block_descs =\n\t\t\t\tbin_alloc(bin,\n\t\t\t\t\t  sizeof(struct ccs_pdaf_pix_loc_block_desc) *\n\t\t\t\t\t  num_block_descs);\n\t\t\tif (!(*pdaf)->block_desc_groups[i].block_descs)\n\t\t\t\treturn -ENOMEM;\n\t\t} else {\n\t\t\tbin_reserve(bin, sizeof(struct ccs_pdaf_pix_loc_block_desc) *\n\t\t\t\t    num_block_descs);\n\t\t}\n\n\t\tfor (j = 0; j < num_block_descs; j++, __bdesc++) {\n\t\t\tstruct ccs_pdaf_pix_loc_block_desc *bdesc;\n\n\t\t\tif (!is_contained(__bdesc, endp))\n\t\t\t\treturn -ENODATA;\n\n\t\t\tif (max_block_type_id <= __bdesc->block_type_id)\n\t\t\t\tmax_block_type_id = __bdesc->block_type_id + 1;\n\n\t\t\tif (!bin->base)\n\t\t\t\tcontinue;\n\n\t\t\tbdesc = &(*pdaf)->block_desc_groups[i].block_descs[j];\n\n\t\t\tbdesc->repeat_x = ((u16)__bdesc->repeat_x[0] << 8)\n\t\t\t\t+ __bdesc->repeat_x[1];\n\n\t\t\tif (__bdesc->block_type_id >= num_block_descs)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tbdesc->block_type_id = __bdesc->block_type_id;\n\t\t}\n\n\t\t__bdesc_group = (const void *)__bdesc;\n\t}\n\n\t__num_pixel_descs = (const void *)__bdesc_group;\n\n\tif (bin->base) {\n\t\t(*pdaf)->pixel_desc_groups =\n\t\t\tbin_alloc(bin,\n\t\t\t\t  sizeof(struct ccs_pdaf_pix_loc_pixel_desc_group) *\n\t\t\t\t  max_block_type_id);\n\t\tif (!(*pdaf)->pixel_desc_groups)\n\t\t\treturn -ENOMEM;\n\t\t(*pdaf)->num_pixel_desc_grups = max_block_type_id;\n\t} else {\n\t\tbin_reserve(bin, sizeof(struct ccs_pdaf_pix_loc_pixel_desc_group) *\n\t\t\t    max_block_type_id);\n\t}\n\n\tfor (i = 0; i < max_block_type_id; i++) {\n\t\tstruct ccs_pdaf_pix_loc_pixel_desc_group *pdgroup = NULL;\n\t\tunsigned int j;\n\n\t\tif (!is_contained(__num_pixel_descs, endp))\n\t\t\treturn -ENODATA;\n\n\t\tif (bin->base) {\n\t\t\tpdgroup = &(*pdaf)->pixel_desc_groups[i];\n\t\t\tpdgroup->descs =\n\t\t\t\tbin_alloc(bin,\n\t\t\t\t\t  sizeof(struct ccs_pdaf_pix_loc_pixel_desc) *\n\t\t\t\t\t  *__num_pixel_descs);\n\t\t\tif (!pdgroup->descs)\n\t\t\t\treturn -ENOMEM;\n\t\t\tpdgroup->num_descs = *__num_pixel_descs;\n\t\t} else {\n\t\t\tbin_reserve(bin, sizeof(struct ccs_pdaf_pix_loc_pixel_desc) *\n\t\t\t\t    *__num_pixel_descs);\n\t\t}\n\n\t\t__pixel_desc = (const void *)(__num_pixel_descs + 1);\n\n\t\tfor (j = 0; j < *__num_pixel_descs; j++, __pixel_desc++) {\n\t\t\tstruct ccs_pdaf_pix_loc_pixel_desc *pdesc;\n\n\t\t\tif (!is_contained(__pixel_desc, endp))\n\t\t\t\treturn -ENODATA;\n\n\t\t\tif (!bin->base)\n\t\t\t\tcontinue;\n\n\t\t\tif (!pdgroup)\n\t\t\t\treturn -EIO;\n\n\t\t\tpdesc = &pdgroup->descs[j];\n\t\t\tpdesc->pixel_type = __pixel_desc->pixel_type;\n\t\t\tpdesc->small_offset_x = __pixel_desc->small_offset_x;\n\t\t\tpdesc->small_offset_y = __pixel_desc->small_offset_y;\n\t\t}\n\n\t\t__num_pixel_descs = (const void *)(__pixel_desc + 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int ccs_data_parse_license(struct bin_container *bin,\n\t\t\t\t  char **__license,\n\t\t\t\t  size_t *__license_length,\n\t\t\t\t  const void *payload, const void *endp)\n{\n\tsize_t size = endp - payload;\n\tchar *license;\n\n\tif (!bin->base) {\n\t\tbin_reserve(bin, size);\n\t\treturn 0;\n\t}\n\n\tlicense = bin_alloc(bin, size);\n\tif (!license)\n\t\treturn -ENOMEM;\n\n\tmemcpy(license, payload, size);\n\n\t*__license = license;\n\t*__license_length = size;\n\n\treturn 0;\n}\n\nstatic int ccs_data_parse_end(bool *end, const void *payload, const void *endp,\n\t\t\t      struct device *dev)\n{\n\tconst struct __ccs_data_block_end *__end = payload;\n\n\tif (__end + 1 != endp) {\n\t\tdev_dbg(dev, \"Invalid end block length %u\\n\",\n\t\t\t(unsigned int)(endp - payload));\n\t\treturn -ENODATA;\n\t}\n\n\t*end = true;\n\n\treturn 0;\n}\n\nstatic int __ccs_data_parse(struct bin_container *bin,\n\t\t\t    struct ccs_data_container *ccsdata,\n\t\t\t    const void *data, size_t len, struct device *dev,\n\t\t\t    bool verbose)\n{\n\tconst struct __ccs_data_block *block = data;\n\tconst struct __ccs_data_block *endp = data + len;\n\tunsigned int version;\n\tbool is_first = true;\n\tint rval;\n\n\tversion = ccs_data_parse_format_version(block);\n\tif (version != CCS_STATIC_DATA_VERSION) {\n\t\tdev_dbg(dev, \"Don't know how to handle version %u\\n\", version);\n\t\treturn -EINVAL;\n\t}\n\n\tif (verbose)\n\t\tdev_dbg(dev, \"Parsing CCS static data version %u\\n\", version);\n\n\tif (!bin->base)\n\t\t*ccsdata = (struct ccs_data_container){ 0 };\n\n\twhile (block < endp) {\n\t\tconst struct __ccs_data_block *next_block;\n\t\tunsigned int block_id;\n\t\tconst void *payload;\n\n\t\trval = ccs_data_block_parse_header(block, is_first, &block_id,\n\t\t\t\t\t\t   &payload, &next_block, endp,\n\t\t\t\t\t\t   dev,\n\t\t\t\t\t\t   bin->base ? false : verbose);\n\n\t\tif (rval < 0)\n\t\t\treturn rval;\n\n\t\tswitch (block_id) {\n\t\tcase CCS_DATA_BLOCK_ID_DUMMY:\n\t\t\tbreak;\n\t\tcase CCS_DATA_BLOCK_ID_DATA_VERSION:\n\t\t\trval = ccs_data_parse_version(bin, ccsdata, payload,\n\t\t\t\t\t\t      next_block);\n\t\t\tif (rval < 0)\n\t\t\t\treturn rval;\n\t\t\tbreak;\n\t\tcase CCS_DATA_BLOCK_ID_SENSOR_READ_ONLY_REGS:\n\t\t\trval = ccs_data_parse_regs(\n\t\t\t\tbin, &ccsdata->sensor_read_only_regs,\n\t\t\t\t&ccsdata->num_sensor_read_only_regs, payload,\n\t\t\t\tnext_block, dev);\n\t\t\tif (rval < 0)\n\t\t\t\treturn rval;\n\t\t\tbreak;\n\t\tcase CCS_DATA_BLOCK_ID_SENSOR_MANUFACTURER_REGS:\n\t\t\trval = ccs_data_parse_regs(\n\t\t\t\tbin, &ccsdata->sensor_manufacturer_regs,\n\t\t\t\t&ccsdata->num_sensor_manufacturer_regs, payload,\n\t\t\t\tnext_block, dev);\n\t\t\tif (rval < 0)\n\t\t\t\treturn rval;\n\t\t\tbreak;\n\t\tcase CCS_DATA_BLOCK_ID_MODULE_READ_ONLY_REGS:\n\t\t\trval = ccs_data_parse_regs(\n\t\t\t\tbin, &ccsdata->module_read_only_regs,\n\t\t\t\t&ccsdata->num_module_read_only_regs, payload,\n\t\t\t\tnext_block, dev);\n\t\t\tif (rval < 0)\n\t\t\t\treturn rval;\n\t\t\tbreak;\n\t\tcase CCS_DATA_BLOCK_ID_MODULE_MANUFACTURER_REGS:\n\t\t\trval = ccs_data_parse_regs(\n\t\t\t\tbin, &ccsdata->module_manufacturer_regs,\n\t\t\t\t&ccsdata->num_module_manufacturer_regs, payload,\n\t\t\t\tnext_block, dev);\n\t\t\tif (rval < 0)\n\t\t\t\treturn rval;\n\t\t\tbreak;\n\t\tcase CCS_DATA_BLOCK_ID_SENSOR_PDAF_PIXEL_LOCATION:\n\t\t\trval = ccs_data_parse_pdaf(bin, &ccsdata->sensor_pdaf,\n\t\t\t\t\t\t   payload, next_block, dev);\n\t\t\tif (rval < 0)\n\t\t\t\treturn rval;\n\t\t\tbreak;\n\t\tcase CCS_DATA_BLOCK_ID_MODULE_PDAF_PIXEL_LOCATION:\n\t\t\trval = ccs_data_parse_pdaf(bin, &ccsdata->module_pdaf,\n\t\t\t\t\t\t   payload, next_block, dev);\n\t\t\tif (rval < 0)\n\t\t\t\treturn rval;\n\t\t\tbreak;\n\t\tcase CCS_DATA_BLOCK_ID_SENSOR_RULE_BASED_BLOCK:\n\t\t\trval = ccs_data_parse_rules(\n\t\t\t\tbin, &ccsdata->sensor_rules,\n\t\t\t\t&ccsdata->num_sensor_rules, payload, next_block,\n\t\t\t\tdev);\n\t\t\tif (rval < 0)\n\t\t\t\treturn rval;\n\t\t\tbreak;\n\t\tcase CCS_DATA_BLOCK_ID_MODULE_RULE_BASED_BLOCK:\n\t\t\trval = ccs_data_parse_rules(\n\t\t\t\tbin, &ccsdata->module_rules,\n\t\t\t\t&ccsdata->num_module_rules, payload, next_block,\n\t\t\t\tdev);\n\t\t\tif (rval < 0)\n\t\t\t\treturn rval;\n\t\t\tbreak;\n\t\tcase CCS_DATA_BLOCK_ID_LICENSE:\n\t\t\trval = ccs_data_parse_license(bin, &ccsdata->license,\n\t\t\t\t\t\t      &ccsdata->license_length,\n\t\t\t\t\t\t      payload, next_block);\n\t\t\tif (rval < 0)\n\t\t\t\treturn rval;\n\t\t\tbreak;\n\t\tcase CCS_DATA_BLOCK_ID_END:\n\t\t\trval = ccs_data_parse_end(&ccsdata->end, payload,\n\t\t\t\t\t\t  next_block, dev);\n\t\t\tif (rval < 0)\n\t\t\t\treturn rval;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(dev, \"WARNING: not handling block ID 0x%2.2x\\n\",\n\t\t\t\tblock_id);\n\t\t}\n\n\t\tblock = next_block;\n\t\tis_first = false;\n\t}\n\n\treturn 0;\n}\n\n \nint ccs_data_parse(struct ccs_data_container *ccsdata, const void *data,\n\t\t   size_t len, struct device *dev, bool verbose)\n{\n\tstruct bin_container bin = { 0 };\n\tint rval;\n\n\trval = __ccs_data_parse(&bin, ccsdata, data, len, dev, verbose);\n\tif (rval)\n\t\treturn rval;\n\n\trval = bin_backing_alloc(&bin);\n\tif (rval)\n\t\treturn rval;\n\n\trval = __ccs_data_parse(&bin, ccsdata, data, len, dev, false);\n\tif (rval)\n\t\tgoto out_free;\n\n\tif (verbose && ccsdata->version)\n\t\tprint_ccs_data_version(dev, ccsdata->version);\n\n\tif (bin.now != bin.end) {\n\t\trval = -EPROTO;\n\t\tdev_dbg(dev, \"parsing mismatch; base %p; now %p; end %p\\n\",\n\t\t\tbin.base, bin.now, bin.end);\n\t\tgoto out_free;\n\t}\n\n\tccsdata->backing = bin.base;\n\n\treturn 0;\n\nout_free:\n\tkvfree(bin.base);\n\n\treturn rval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}