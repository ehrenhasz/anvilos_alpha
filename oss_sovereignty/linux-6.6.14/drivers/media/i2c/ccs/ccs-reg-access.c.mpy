{
  "module_name": "ccs-reg-access.c",
  "hash_id": "c55617a12d5683d90f453df3b9899ed067d47c970c7b2953b52dce07e54918f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ccs/ccs-reg-access.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n\n#include \"ccs.h\"\n#include \"ccs-limits.h\"\n\nstatic u32 float_to_u32_mul_1000000(struct i2c_client *client, u32 phloat)\n{\n\ts32 exp;\n\tu64 man;\n\n\tif (phloat >= 0x80000000) {\n\t\tdev_err(&client->dev, \"this is a negative number\\n\");\n\t\treturn 0;\n\t}\n\n\tif (phloat == 0x7f800000)\n\t\treturn ~0;  \n\n\tif ((phloat & 0x7f800000) == 0x7f800000) {\n\t\tdev_err(&client->dev, \"NaN or other special number\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (phloat == 0)\n\t\treturn 0;  \n\n\tif (phloat > 0x4f800000)\n\t\treturn ~0;  \n\n\t \n\texp = ((int32_t)phloat >> 23) - 127;\n\n\t \n\tman = ((phloat & 0x7fffff) | 0x800000) * 1000000ULL;\n\n\tif (exp < 0)\n\t\tman >>= -exp;\n\telse\n\t\tman <<= exp;\n\n\tman >>= 23;  \n\n\treturn man & 0xffffffff;\n}\n\n\n \nstatic int ____ccs_read_addr(struct ccs_sensor *sensor, u16 reg, u16 len,\n\t\t\t     u32 *val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tstruct i2c_msg msg;\n\tunsigned char data_buf[sizeof(u32)] = { 0 };\n\tunsigned char offset_buf[sizeof(u16)];\n\tint r;\n\n\tif (len > sizeof(data_buf))\n\t\treturn -EINVAL;\n\n\tmsg.addr = client->addr;\n\tmsg.flags = 0;\n\tmsg.len = sizeof(offset_buf);\n\tmsg.buf = offset_buf;\n\tput_unaligned_be16(reg, offset_buf);\n\n\tr = i2c_transfer(client->adapter, &msg, 1);\n\tif (r != 1) {\n\t\tif (r >= 0)\n\t\t\tr = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tmsg.len = len;\n\tmsg.flags = I2C_M_RD;\n\tmsg.buf = &data_buf[sizeof(data_buf) - len];\n\n\tr = i2c_transfer(client->adapter, &msg, 1);\n\tif (r != 1) {\n\t\tif (r >= 0)\n\t\t\tr = -EBUSY;\n\t\tgoto err;\n\t}\n\n\t*val = get_unaligned_be32(data_buf);\n\n\treturn 0;\n\nerr:\n\tdev_err(&client->dev, \"read from offset 0x%x error %d\\n\", reg, r);\n\n\treturn r;\n}\n\n \nstatic int ____ccs_read_addr_8only(struct ccs_sensor *sensor, u16 reg,\n\t\t\t\t   u16 len, u32 *val)\n{\n\tunsigned int i;\n\tint rval;\n\n\t*val = 0;\n\n\tfor (i = 0; i < len; i++) {\n\t\tu32 val8;\n\n\t\trval = ____ccs_read_addr(sensor, reg + i, 1, &val8);\n\t\tif (rval < 0)\n\t\t\treturn rval;\n\t\t*val |= val8 << ((len - i - 1) << 3);\n\t}\n\n\treturn 0;\n}\n\nunsigned int ccs_reg_width(u32 reg)\n{\n\tif (reg & CCS_FL_16BIT)\n\t\treturn sizeof(u16);\n\tif (reg & CCS_FL_32BIT)\n\t\treturn sizeof(u32);\n\n\treturn sizeof(u8);\n}\n\nstatic u32 ireal32_to_u32_mul_1000000(struct i2c_client *client, u32 val)\n{\n\tif (val >> 10 > U32_MAX / 15625) {\n\t\tdev_warn(&client->dev, \"value %u overflows!\\n\", val);\n\t\treturn U32_MAX;\n\t}\n\n\treturn ((val >> 10) * 15625) +\n\t\t(val & GENMASK(9, 0)) * 15625 / 1024;\n}\n\nu32 ccs_reg_conv(struct ccs_sensor *sensor, u32 reg, u32 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\n\tif (reg & CCS_FL_FLOAT_IREAL) {\n\t\tif (CCS_LIM(sensor, CLOCK_CAPA_TYPE_CAPABILITY) &\n\t\t    CCS_CLOCK_CAPA_TYPE_CAPABILITY_IREAL)\n\t\t\tval = ireal32_to_u32_mul_1000000(client, val);\n\t\telse\n\t\t\tval = float_to_u32_mul_1000000(client, val);\n\t} else if (reg & CCS_FL_IREAL) {\n\t\tval = ireal32_to_u32_mul_1000000(client, val);\n\t}\n\n\treturn val;\n}\n\n \nstatic int __ccs_read_addr(struct ccs_sensor *sensor, u32 reg, u32 *val,\n\t\t\t   bool only8, bool conv)\n{\n\tunsigned int len = ccs_reg_width(reg);\n\tint rval;\n\n\tif (!only8)\n\t\trval = ____ccs_read_addr(sensor, CCS_REG_ADDR(reg), len, val);\n\telse\n\t\trval = ____ccs_read_addr_8only(sensor, CCS_REG_ADDR(reg), len,\n\t\t\t\t\t       val);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tif (!conv)\n\t\treturn 0;\n\n\t*val = ccs_reg_conv(sensor, reg, *val);\n\n\treturn 0;\n}\n\nstatic int __ccs_read_data(struct ccs_reg *regs, size_t num_regs,\n\t\t\t   u32 reg, u32 *val)\n{\n\tunsigned int width = ccs_reg_width(reg);\n\tsize_t i;\n\n\tfor (i = 0; i < num_regs; i++, regs++) {\n\t\tu8 *data;\n\n\t\tif (regs->addr + regs->len < CCS_REG_ADDR(reg) + width)\n\t\t\tcontinue;\n\n\t\tif (regs->addr > CCS_REG_ADDR(reg))\n\t\t\tbreak;\n\n\t\tdata = &regs->value[CCS_REG_ADDR(reg) - regs->addr];\n\n\t\tswitch (width) {\n\t\tcase sizeof(u8):\n\t\t\t*val = *data;\n\t\t\tbreak;\n\t\tcase sizeof(u16):\n\t\t\t*val = get_unaligned_be16(data);\n\t\t\tbreak;\n\t\tcase sizeof(u32):\n\t\t\t*val = get_unaligned_be32(data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int ccs_read_data(struct ccs_sensor *sensor, u32 reg, u32 *val)\n{\n\tif (!__ccs_read_data(sensor->sdata.sensor_read_only_regs,\n\t\t\t     sensor->sdata.num_sensor_read_only_regs,\n\t\t\t     reg, val))\n\t\treturn 0;\n\n\treturn __ccs_read_data(sensor->mdata.module_read_only_regs,\n\t\t\t       sensor->mdata.num_module_read_only_regs,\n\t\t\t       reg, val);\n}\n\nstatic int ccs_read_addr_raw(struct ccs_sensor *sensor, u32 reg, u32 *val,\n\t\t\t     bool force8, bool quirk, bool conv, bool data)\n{\n\tint rval;\n\n\tif (data) {\n\t\trval = ccs_read_data(sensor, reg, val);\n\t\tif (!rval)\n\t\t\treturn 0;\n\t}\n\n\tif (quirk) {\n\t\t*val = 0;\n\t\trval = ccs_call_quirk(sensor, reg_access, false, &reg, val);\n\t\tif (rval == -ENOIOCTLCMD)\n\t\t\treturn 0;\n\t\tif (rval < 0)\n\t\t\treturn rval;\n\n\t\tif (force8)\n\t\t\treturn __ccs_read_addr(sensor, reg, val, true, conv);\n\t}\n\n\treturn __ccs_read_addr(sensor, reg, val,\n\t\t\t       ccs_needs_quirk(sensor,\n\t\t\t\t\t       CCS_QUIRK_FLAG_8BIT_READ_ONLY),\n\t\t\t       conv);\n}\n\nint ccs_read_addr(struct ccs_sensor *sensor, u32 reg, u32 *val)\n{\n\treturn ccs_read_addr_raw(sensor, reg, val, false, true, true, true);\n}\n\nint ccs_read_addr_8only(struct ccs_sensor *sensor, u32 reg, u32 *val)\n{\n\treturn ccs_read_addr_raw(sensor, reg, val, true, true, true, true);\n}\n\nint ccs_read_addr_noconv(struct ccs_sensor *sensor, u32 reg, u32 *val)\n{\n\treturn ccs_read_addr_raw(sensor, reg, val, false, true, false, true);\n}\n\nstatic int ccs_write_retry(struct i2c_client *client, struct i2c_msg *msg)\n{\n\tunsigned int retries;\n\tint r;\n\n\tfor (retries = 0; retries < 10; retries++) {\n\t\t \n\t\tr = i2c_transfer(client->adapter, msg, 1);\n\t\tif (r != 1) {\n\t\t\tusleep_range(1000, 2000);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (retries)\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"sensor i2c stall encountered. retries: %d\\n\",\n\t\t\t\tretries);\n\t\treturn 0;\n\t}\n\n\treturn r;\n}\n\nint ccs_write_addr_no_quirk(struct ccs_sensor *sensor, u32 reg, u32 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tstruct i2c_msg msg;\n\tunsigned char data[6];\n\tunsigned int len = ccs_reg_width(reg);\n\tint r;\n\n\tif (len > sizeof(data) - 2)\n\t\treturn -EINVAL;\n\n\tmsg.addr = client->addr;\n\tmsg.flags = 0;  \n\tmsg.len = 2 + len;\n\tmsg.buf = data;\n\n\tput_unaligned_be16(CCS_REG_ADDR(reg), data);\n\tput_unaligned_be32(val << (8 * (sizeof(val) - len)), data + 2);\n\n\tdev_dbg(&client->dev, \"writing reg 0x%4.4x value 0x%*.*x (%u)\\n\",\n\t\tCCS_REG_ADDR(reg), ccs_reg_width(reg) << 1,\n\t\tccs_reg_width(reg) << 1, val, val);\n\n\tr = ccs_write_retry(client, &msg);\n\tif (r)\n\t\tdev_err(&client->dev,\n\t\t\t\"wrote 0x%x to offset 0x%x error %d\\n\", val,\n\t\t\tCCS_REG_ADDR(reg), r);\n\n\treturn r;\n}\n\n \nint ccs_write_addr(struct ccs_sensor *sensor, u32 reg, u32 val)\n{\n\tint rval;\n\n\trval = ccs_call_quirk(sensor, reg_access, true, &reg, &val);\n\tif (rval == -ENOIOCTLCMD)\n\t\treturn 0;\n\tif (rval < 0)\n\t\treturn rval;\n\n\treturn ccs_write_addr_no_quirk(sensor, reg, val);\n}\n\n#define MAX_WRITE_LEN\t32U\n\nint ccs_write_data_regs(struct ccs_sensor *sensor, struct ccs_reg *regs,\n\t\t\tsize_t num_regs)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tunsigned char buf[2 + MAX_WRITE_LEN];\n\tstruct i2c_msg msg = {\n\t\t.addr = client->addr,\n\t\t.buf = buf,\n\t};\n\tsize_t i;\n\n\tfor (i = 0; i < num_regs; i++, regs++) {\n\t\tunsigned char *regdata = regs->value;\n\t\tunsigned int j;\n\n\t\tfor (j = 0; j < regs->len;\n\t\t     j += msg.len - 2, regdata += msg.len - 2) {\n\t\t\tchar printbuf[(MAX_WRITE_LEN << 1) +\n\t\t\t\t      1  ] = { 0 };\n\t\t\tint rval;\n\n\t\t\tmsg.len = min(regs->len - j, MAX_WRITE_LEN);\n\n\t\t\tbin2hex(printbuf, regdata, msg.len);\n\t\t\tdev_dbg(&client->dev,\n\t\t\t\t\"writing msr reg 0x%4.4x value 0x%s\\n\",\n\t\t\t\tregs->addr + j, printbuf);\n\n\t\t\tput_unaligned_be16(regs->addr + j, buf);\n\t\t\tmemcpy(buf + 2, regdata, msg.len);\n\n\t\t\tmsg.len += 2;\n\n\t\t\trval = ccs_write_retry(client, &msg);\n\t\t\tif (rval) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"error writing %u octets to address 0x%4.4x\\n\",\n\t\t\t\t\tmsg.len, regs->addr + j);\n\t\t\t\treturn rval;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}