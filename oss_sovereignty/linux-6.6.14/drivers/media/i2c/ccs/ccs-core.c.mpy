{
  "module_name": "ccs-core.c",
  "hash_id": "d2d257c683835eb8424fca968e78f69e38fe0dc6dc1f2647b2bf4606c27fb883",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ccs/ccs-core.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/smiapp.h>\n#include <linux/v4l2-mediabus.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-device.h>\n#include <uapi/linux/ccs.h>\n\n#include \"ccs.h\"\n\n#define CCS_ALIGN_DIM(dim, flags)\t\\\n\t((flags) & V4L2_SEL_FLAG_GE\t\\\n\t ? ALIGN((dim), 2)\t\t\\\n\t : (dim) & ~1)\n\nstatic struct ccs_limit_offset {\n\tu16\tlim;\n\tu16\tinfo;\n} ccs_limit_offsets[CCS_L_LAST + 1];\n\n \nstatic const struct ccs_module_ident ccs_module_idents[] = {\n\tCCS_IDENT_L(0x01, 0x022b, -1, \"vs6555\"),\n\tCCS_IDENT_L(0x01, 0x022e, -1, \"vw6558\"),\n\tCCS_IDENT_L(0x07, 0x7698, -1, \"ovm7698\"),\n\tCCS_IDENT_L(0x0b, 0x4242, -1, \"smiapp-003\"),\n\tCCS_IDENT_L(0x0c, 0x208a, -1, \"tcm8330md\"),\n\tCCS_IDENT_LQ(0x0c, 0x2134, -1, \"tcm8500md\", &smiapp_tcm8500md_quirk),\n\tCCS_IDENT_L(0x0c, 0x213e, -1, \"et8en2\"),\n\tCCS_IDENT_L(0x0c, 0x2184, -1, \"tcm8580md\"),\n\tCCS_IDENT_LQ(0x0c, 0x560f, -1, \"jt8ew9\", &smiapp_jt8ew9_quirk),\n\tCCS_IDENT_LQ(0x10, 0x4141, -1, \"jt8ev1\", &smiapp_jt8ev1_quirk),\n\tCCS_IDENT_LQ(0x10, 0x4241, -1, \"imx125es\", &smiapp_imx125es_quirk),\n};\n\n#define CCS_DEVICE_FLAG_IS_SMIA\t\tBIT(0)\n\nstruct ccs_device {\n\tunsigned char flags;\n};\n\nstatic const char * const ccs_regulators[] = { \"vcore\", \"vio\", \"vana\" };\n\n \n\nstatic void ccs_assign_limit(void *ptr, unsigned int width, u32 val)\n{\n\tswitch (width) {\n\tcase sizeof(u8):\n\t\t*(u8 *)ptr = val;\n\t\tbreak;\n\tcase sizeof(u16):\n\t\t*(u16 *)ptr = val;\n\t\tbreak;\n\tcase sizeof(u32):\n\t\t*(u32 *)ptr = val;\n\t\tbreak;\n\t}\n}\n\nstatic int ccs_limit_ptr(struct ccs_sensor *sensor, unsigned int limit,\n\t\t\t unsigned int offset, void **__ptr)\n{\n\tconst struct ccs_limit *linfo;\n\n\tif (WARN_ON(limit >= CCS_L_LAST))\n\t\treturn -EINVAL;\n\n\tlinfo = &ccs_limits[ccs_limit_offsets[limit].info];\n\n\tif (WARN_ON(!sensor->ccs_limits) ||\n\t    WARN_ON(offset + ccs_reg_width(linfo->reg) >\n\t\t    ccs_limit_offsets[limit + 1].lim))\n\t\treturn -EINVAL;\n\n\t*__ptr = sensor->ccs_limits + ccs_limit_offsets[limit].lim + offset;\n\n\treturn 0;\n}\n\nvoid ccs_replace_limit(struct ccs_sensor *sensor,\n\t\t       unsigned int limit, unsigned int offset, u32 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tconst struct ccs_limit *linfo;\n\tvoid *ptr;\n\tint ret;\n\n\tret = ccs_limit_ptr(sensor, limit, offset, &ptr);\n\tif (ret)\n\t\treturn;\n\n\tlinfo = &ccs_limits[ccs_limit_offsets[limit].info];\n\n\tdev_dbg(&client->dev, \"quirk: 0x%8.8x \\\"%s\\\" %u = %u, 0x%x\\n\",\n\t\tlinfo->reg, linfo->name, offset, val, val);\n\n\tccs_assign_limit(ptr, ccs_reg_width(linfo->reg), val);\n}\n\nu32 ccs_get_limit(struct ccs_sensor *sensor, unsigned int limit,\n\t\t  unsigned int offset)\n{\n\tvoid *ptr;\n\tu32 val;\n\tint ret;\n\n\tret = ccs_limit_ptr(sensor, limit, offset, &ptr);\n\tif (ret)\n\t\treturn 0;\n\n\tswitch (ccs_reg_width(ccs_limits[ccs_limit_offsets[limit].info].reg)) {\n\tcase sizeof(u8):\n\t\tval = *(u8 *)ptr;\n\t\tbreak;\n\tcase sizeof(u16):\n\t\tval = *(u16 *)ptr;\n\t\tbreak;\n\tcase sizeof(u32):\n\t\tval = *(u32 *)ptr;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\treturn ccs_reg_conv(sensor, ccs_limits[limit].reg, val);\n}\n\nstatic int ccs_read_all_limits(struct ccs_sensor *sensor)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tvoid *ptr, *alloc, *end;\n\tunsigned int i, l;\n\tint ret;\n\n\tkfree(sensor->ccs_limits);\n\tsensor->ccs_limits = NULL;\n\n\talloc = kzalloc(ccs_limit_offsets[CCS_L_LAST].lim, GFP_KERNEL);\n\tif (!alloc)\n\t\treturn -ENOMEM;\n\n\tend = alloc + ccs_limit_offsets[CCS_L_LAST].lim;\n\n\tfor (i = 0, l = 0, ptr = alloc; ccs_limits[i].size; i++) {\n\t\tu32 reg = ccs_limits[i].reg;\n\t\tunsigned int width = ccs_reg_width(reg);\n\t\tunsigned int j;\n\n\t\tif (l == CCS_L_LAST) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"internal error --- end of limit array\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tfor (j = 0; j < ccs_limits[i].size / width;\n\t\t     j++, reg += width, ptr += width) {\n\t\t\tu32 val;\n\n\t\t\tret = ccs_read_addr_noconv(sensor, reg, &val);\n\t\t\tif (ret)\n\t\t\t\tgoto out_err;\n\n\t\t\tif (ptr + width > end) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"internal error --- no room for regs\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\tif (!val && j)\n\t\t\t\tbreak;\n\n\t\t\tccs_assign_limit(ptr, width, val);\n\n\t\t\tdev_dbg(&client->dev, \"0x%8.8x \\\"%s\\\" = %u, 0x%x\\n\",\n\t\t\t\treg, ccs_limits[i].name, val, val);\n\t\t}\n\n\t\tif (ccs_limits[i].flags & CCS_L_FL_SAME_REG)\n\t\t\tcontinue;\n\n\t\tl++;\n\t\tptr = alloc + ccs_limit_offsets[l].lim;\n\t}\n\n\tif (l != CCS_L_LAST) {\n\t\tdev_err(&client->dev,\n\t\t\t\"internal error --- insufficient limits\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tsensor->ccs_limits = alloc;\n\n\tif (CCS_LIM(sensor, SCALER_N_MIN) < 16)\n\t\tccs_replace_limit(sensor, CCS_L_SCALER_N_MIN, 0, 16);\n\n\treturn 0;\n\nout_err:\n\tkfree(alloc);\n\n\treturn ret;\n}\n\nstatic int ccs_read_frame_fmt(struct ccs_sensor *sensor)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tu8 fmt_model_type, fmt_model_subtype, ncol_desc, nrow_desc;\n\tunsigned int i;\n\tint pixel_count = 0;\n\tint line_count = 0;\n\n\tfmt_model_type = CCS_LIM(sensor, FRAME_FORMAT_MODEL_TYPE);\n\tfmt_model_subtype = CCS_LIM(sensor, FRAME_FORMAT_MODEL_SUBTYPE);\n\n\tncol_desc = (fmt_model_subtype\n\t\t     & CCS_FRAME_FORMAT_MODEL_SUBTYPE_COLUMNS_MASK)\n\t\t>> CCS_FRAME_FORMAT_MODEL_SUBTYPE_COLUMNS_SHIFT;\n\tnrow_desc = fmt_model_subtype\n\t\t& CCS_FRAME_FORMAT_MODEL_SUBTYPE_ROWS_MASK;\n\n\tdev_dbg(&client->dev, \"format_model_type %s\\n\",\n\t\tfmt_model_type == CCS_FRAME_FORMAT_MODEL_TYPE_2_BYTE\n\t\t? \"2 byte\" :\n\t\tfmt_model_type == CCS_FRAME_FORMAT_MODEL_TYPE_4_BYTE\n\t\t? \"4 byte\" : \"is simply bad\");\n\n\tdev_dbg(&client->dev, \"%u column and %u row descriptors\\n\",\n\t\tncol_desc, nrow_desc);\n\n\tfor (i = 0; i < ncol_desc + nrow_desc; i++) {\n\t\tu32 desc;\n\t\tu32 pixelcode;\n\t\tu32 pixels;\n\t\tchar *which;\n\t\tchar *what;\n\n\t\tif (fmt_model_type == CCS_FRAME_FORMAT_MODEL_TYPE_2_BYTE) {\n\t\t\tdesc = CCS_LIM_AT(sensor, FRAME_FORMAT_DESCRIPTOR, i);\n\n\t\t\tpixelcode =\n\t\t\t\t(desc\n\t\t\t\t & CCS_FRAME_FORMAT_DESCRIPTOR_PCODE_MASK)\n\t\t\t\t>> CCS_FRAME_FORMAT_DESCRIPTOR_PCODE_SHIFT;\n\t\t\tpixels = desc & CCS_FRAME_FORMAT_DESCRIPTOR_PIXELS_MASK;\n\t\t} else if (fmt_model_type\n\t\t\t   == CCS_FRAME_FORMAT_MODEL_TYPE_4_BYTE) {\n\t\t\tdesc = CCS_LIM_AT(sensor, FRAME_FORMAT_DESCRIPTOR_4, i);\n\n\t\t\tpixelcode =\n\t\t\t\t(desc\n\t\t\t\t & CCS_FRAME_FORMAT_DESCRIPTOR_4_PCODE_MASK)\n\t\t\t\t>> CCS_FRAME_FORMAT_DESCRIPTOR_4_PCODE_SHIFT;\n\t\t\tpixels = desc &\n\t\t\t\tCCS_FRAME_FORMAT_DESCRIPTOR_4_PIXELS_MASK;\n\t\t} else {\n\t\t\tdev_dbg(&client->dev,\n\t\t\t\t\"invalid frame format model type %u\\n\",\n\t\t\t\tfmt_model_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (i < ncol_desc)\n\t\t\twhich = \"columns\";\n\t\telse\n\t\t\twhich = \"rows\";\n\n\t\tswitch (pixelcode) {\n\t\tcase CCS_FRAME_FORMAT_DESCRIPTOR_PCODE_EMBEDDED:\n\t\t\twhat = \"embedded\";\n\t\t\tbreak;\n\t\tcase CCS_FRAME_FORMAT_DESCRIPTOR_PCODE_DUMMY_PIXEL:\n\t\t\twhat = \"dummy\";\n\t\t\tbreak;\n\t\tcase CCS_FRAME_FORMAT_DESCRIPTOR_PCODE_BLACK_PIXEL:\n\t\t\twhat = \"black\";\n\t\t\tbreak;\n\t\tcase CCS_FRAME_FORMAT_DESCRIPTOR_PCODE_DARK_PIXEL:\n\t\t\twhat = \"dark\";\n\t\t\tbreak;\n\t\tcase CCS_FRAME_FORMAT_DESCRIPTOR_PCODE_VISIBLE_PIXEL:\n\t\t\twhat = \"visible\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twhat = \"invalid\";\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(&client->dev,\n\t\t\t\"%s pixels: %u %s (pixelcode %u)\\n\",\n\t\t\twhat, pixels, which, pixelcode);\n\n\t\tif (i < ncol_desc) {\n\t\t\tif (pixelcode ==\n\t\t\t    CCS_FRAME_FORMAT_DESCRIPTOR_PCODE_VISIBLE_PIXEL)\n\t\t\t\tsensor->visible_pixel_start = pixel_count;\n\t\t\tpixel_count += pixels;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tswitch (pixelcode) {\n\t\tcase CCS_FRAME_FORMAT_DESCRIPTOR_PCODE_EMBEDDED:\n\t\t\tif (sensor->embedded_end)\n\t\t\t\tbreak;\n\t\t\tsensor->embedded_start = line_count;\n\t\t\tsensor->embedded_end = line_count + pixels;\n\t\t\tbreak;\n\t\tcase CCS_FRAME_FORMAT_DESCRIPTOR_PCODE_VISIBLE_PIXEL:\n\t\t\tsensor->image_start = line_count;\n\t\t\tbreak;\n\t\t}\n\t\tline_count += pixels;\n\t}\n\n\tif (sensor->embedded_end > sensor->image_start) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"adjusting image start line to %u (was %u)\\n\",\n\t\t\tsensor->embedded_end, sensor->image_start);\n\t\tsensor->image_start = sensor->embedded_end;\n\t}\n\n\tdev_dbg(&client->dev, \"embedded data from lines %u to %u\\n\",\n\t\tsensor->embedded_start, sensor->embedded_end);\n\tdev_dbg(&client->dev, \"image data starts at line %u\\n\",\n\t\tsensor->image_start);\n\n\treturn 0;\n}\n\nstatic int ccs_pll_configure(struct ccs_sensor *sensor)\n{\n\tstruct ccs_pll *pll = &sensor->pll;\n\tint rval;\n\n\trval = ccs_write(sensor, VT_PIX_CLK_DIV, pll->vt_bk.pix_clk_div);\n\tif (rval < 0)\n\t\treturn rval;\n\n\trval = ccs_write(sensor, VT_SYS_CLK_DIV, pll->vt_bk.sys_clk_div);\n\tif (rval < 0)\n\t\treturn rval;\n\n\trval = ccs_write(sensor, PRE_PLL_CLK_DIV, pll->vt_fr.pre_pll_clk_div);\n\tif (rval < 0)\n\t\treturn rval;\n\n\trval = ccs_write(sensor, PLL_MULTIPLIER, pll->vt_fr.pll_multiplier);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tif (!(CCS_LIM(sensor, PHY_CTRL_CAPABILITY) &\n\t      CCS_PHY_CTRL_CAPABILITY_AUTO_PHY_CTL)) {\n\t\t \n\t\trval = ccs_write(sensor, REQUESTED_LINK_RATE,\n\t\t\t\t DIV_ROUND_UP(pll->op_bk.sys_clk_freq_hz,\n\t\t\t\t\t      1000000 / 256 / 256) *\n\t\t\t\t (pll->flags & CCS_PLL_FLAG_LANE_SPEED_MODEL ?\n\t\t\t\t  sensor->pll.csi2.lanes : 1) <<\n\t\t\t\t (pll->flags & CCS_PLL_FLAG_OP_SYS_DDR ?\n\t\t\t\t  1 : 0));\n\t\tif (rval < 0)\n\t\t\treturn rval;\n\t}\n\n\tif (sensor->pll.flags & CCS_PLL_FLAG_NO_OP_CLOCKS)\n\t\treturn 0;\n\n\trval = ccs_write(sensor, OP_PIX_CLK_DIV, pll->op_bk.pix_clk_div);\n\tif (rval < 0)\n\t\treturn rval;\n\n\trval = ccs_write(sensor, OP_SYS_CLK_DIV, pll->op_bk.sys_clk_div);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tif (!(pll->flags & CCS_PLL_FLAG_DUAL_PLL))\n\t\treturn 0;\n\n\trval = ccs_write(sensor, PLL_MODE, CCS_PLL_MODE_DUAL);\n\tif (rval < 0)\n\t\treturn rval;\n\n\trval = ccs_write(sensor, OP_PRE_PLL_CLK_DIV,\n\t\t\t pll->op_fr.pre_pll_clk_div);\n\tif (rval < 0)\n\t\treturn rval;\n\n\treturn ccs_write(sensor, OP_PLL_MULTIPLIER, pll->op_fr.pll_multiplier);\n}\n\nstatic int ccs_pll_try(struct ccs_sensor *sensor, struct ccs_pll *pll)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tstruct ccs_pll_limits lim = {\n\t\t.vt_fr = {\n\t\t\t.min_pre_pll_clk_div = CCS_LIM(sensor, MIN_PRE_PLL_CLK_DIV),\n\t\t\t.max_pre_pll_clk_div = CCS_LIM(sensor, MAX_PRE_PLL_CLK_DIV),\n\t\t\t.min_pll_ip_clk_freq_hz = CCS_LIM(sensor, MIN_PLL_IP_CLK_FREQ_MHZ),\n\t\t\t.max_pll_ip_clk_freq_hz = CCS_LIM(sensor, MAX_PLL_IP_CLK_FREQ_MHZ),\n\t\t\t.min_pll_multiplier = CCS_LIM(sensor, MIN_PLL_MULTIPLIER),\n\t\t\t.max_pll_multiplier = CCS_LIM(sensor, MAX_PLL_MULTIPLIER),\n\t\t\t.min_pll_op_clk_freq_hz = CCS_LIM(sensor, MIN_PLL_OP_CLK_FREQ_MHZ),\n\t\t\t.max_pll_op_clk_freq_hz = CCS_LIM(sensor, MAX_PLL_OP_CLK_FREQ_MHZ),\n\t\t},\n\t\t.op_fr = {\n\t\t\t.min_pre_pll_clk_div = CCS_LIM(sensor, MIN_OP_PRE_PLL_CLK_DIV),\n\t\t\t.max_pre_pll_clk_div = CCS_LIM(sensor, MAX_OP_PRE_PLL_CLK_DIV),\n\t\t\t.min_pll_ip_clk_freq_hz = CCS_LIM(sensor, MIN_OP_PLL_IP_CLK_FREQ_MHZ),\n\t\t\t.max_pll_ip_clk_freq_hz = CCS_LIM(sensor, MAX_OP_PLL_IP_CLK_FREQ_MHZ),\n\t\t\t.min_pll_multiplier = CCS_LIM(sensor, MIN_OP_PLL_MULTIPLIER),\n\t\t\t.max_pll_multiplier = CCS_LIM(sensor, MAX_OP_PLL_MULTIPLIER),\n\t\t\t.min_pll_op_clk_freq_hz = CCS_LIM(sensor, MIN_OP_PLL_OP_CLK_FREQ_MHZ),\n\t\t\t.max_pll_op_clk_freq_hz = CCS_LIM(sensor, MAX_OP_PLL_OP_CLK_FREQ_MHZ),\n\t\t},\n\t\t.op_bk = {\n\t\t\t .min_sys_clk_div = CCS_LIM(sensor, MIN_OP_SYS_CLK_DIV),\n\t\t\t .max_sys_clk_div = CCS_LIM(sensor, MAX_OP_SYS_CLK_DIV),\n\t\t\t .min_pix_clk_div = CCS_LIM(sensor, MIN_OP_PIX_CLK_DIV),\n\t\t\t .max_pix_clk_div = CCS_LIM(sensor, MAX_OP_PIX_CLK_DIV),\n\t\t\t .min_sys_clk_freq_hz = CCS_LIM(sensor, MIN_OP_SYS_CLK_FREQ_MHZ),\n\t\t\t .max_sys_clk_freq_hz = CCS_LIM(sensor, MAX_OP_SYS_CLK_FREQ_MHZ),\n\t\t\t .min_pix_clk_freq_hz = CCS_LIM(sensor, MIN_OP_PIX_CLK_FREQ_MHZ),\n\t\t\t .max_pix_clk_freq_hz = CCS_LIM(sensor, MAX_OP_PIX_CLK_FREQ_MHZ),\n\t\t },\n\t\t.vt_bk = {\n\t\t\t .min_sys_clk_div = CCS_LIM(sensor, MIN_VT_SYS_CLK_DIV),\n\t\t\t .max_sys_clk_div = CCS_LIM(sensor, MAX_VT_SYS_CLK_DIV),\n\t\t\t .min_pix_clk_div = CCS_LIM(sensor, MIN_VT_PIX_CLK_DIV),\n\t\t\t .max_pix_clk_div = CCS_LIM(sensor, MAX_VT_PIX_CLK_DIV),\n\t\t\t .min_sys_clk_freq_hz = CCS_LIM(sensor, MIN_VT_SYS_CLK_FREQ_MHZ),\n\t\t\t .max_sys_clk_freq_hz = CCS_LIM(sensor, MAX_VT_SYS_CLK_FREQ_MHZ),\n\t\t\t .min_pix_clk_freq_hz = CCS_LIM(sensor, MIN_VT_PIX_CLK_FREQ_MHZ),\n\t\t\t .max_pix_clk_freq_hz = CCS_LIM(sensor, MAX_VT_PIX_CLK_FREQ_MHZ),\n\t\t },\n\t\t.min_line_length_pck_bin = CCS_LIM(sensor, MIN_LINE_LENGTH_PCK_BIN),\n\t\t.min_line_length_pck = CCS_LIM(sensor, MIN_LINE_LENGTH_PCK),\n\t};\n\n\treturn ccs_pll_calculate(&client->dev, &lim, pll);\n}\n\nstatic int ccs_pll_update(struct ccs_sensor *sensor)\n{\n\tstruct ccs_pll *pll = &sensor->pll;\n\tint rval;\n\n\tpll->binning_horizontal = sensor->binning_horizontal;\n\tpll->binning_vertical = sensor->binning_vertical;\n\tpll->link_freq =\n\t\tsensor->link_freq->qmenu_int[sensor->link_freq->val];\n\tpll->scale_m = sensor->scale_m;\n\tpll->bits_per_pixel = sensor->csi_format->compressed;\n\n\trval = ccs_pll_try(sensor, pll);\n\tif (rval < 0)\n\t\treturn rval;\n\n\t__v4l2_ctrl_s_ctrl_int64(sensor->pixel_rate_parray,\n\t\t\t\t pll->pixel_rate_pixel_array);\n\t__v4l2_ctrl_s_ctrl_int64(sensor->pixel_rate_csi, pll->pixel_rate_csi);\n\n\treturn 0;\n}\n\n\n \n\nstatic void __ccs_update_exposure_limits(struct ccs_sensor *sensor)\n{\n\tstruct v4l2_ctrl *ctrl = sensor->exposure;\n\tint max;\n\n\tmax = sensor->pixel_array->crop[CCS_PA_PAD_SRC].height\n\t\t+ sensor->vblank->val\n\t\t- CCS_LIM(sensor, COARSE_INTEGRATION_TIME_MAX_MARGIN);\n\n\t__v4l2_ctrl_modify_range(ctrl, ctrl->minimum, max, ctrl->step, max);\n}\n\n \nstatic const struct ccs_csi_data_format ccs_csi_data_formats[] = {\n\t{ MEDIA_BUS_FMT_SGRBG16_1X16, 16, 16, CCS_PIXEL_ORDER_GRBG, },\n\t{ MEDIA_BUS_FMT_SRGGB16_1X16, 16, 16, CCS_PIXEL_ORDER_RGGB, },\n\t{ MEDIA_BUS_FMT_SBGGR16_1X16, 16, 16, CCS_PIXEL_ORDER_BGGR, },\n\t{ MEDIA_BUS_FMT_SGBRG16_1X16, 16, 16, CCS_PIXEL_ORDER_GBRG, },\n\t{ MEDIA_BUS_FMT_SGRBG14_1X14, 14, 14, CCS_PIXEL_ORDER_GRBG, },\n\t{ MEDIA_BUS_FMT_SRGGB14_1X14, 14, 14, CCS_PIXEL_ORDER_RGGB, },\n\t{ MEDIA_BUS_FMT_SBGGR14_1X14, 14, 14, CCS_PIXEL_ORDER_BGGR, },\n\t{ MEDIA_BUS_FMT_SGBRG14_1X14, 14, 14, CCS_PIXEL_ORDER_GBRG, },\n\t{ MEDIA_BUS_FMT_SGRBG12_1X12, 12, 12, CCS_PIXEL_ORDER_GRBG, },\n\t{ MEDIA_BUS_FMT_SRGGB12_1X12, 12, 12, CCS_PIXEL_ORDER_RGGB, },\n\t{ MEDIA_BUS_FMT_SBGGR12_1X12, 12, 12, CCS_PIXEL_ORDER_BGGR, },\n\t{ MEDIA_BUS_FMT_SGBRG12_1X12, 12, 12, CCS_PIXEL_ORDER_GBRG, },\n\t{ MEDIA_BUS_FMT_SGRBG10_1X10, 10, 10, CCS_PIXEL_ORDER_GRBG, },\n\t{ MEDIA_BUS_FMT_SRGGB10_1X10, 10, 10, CCS_PIXEL_ORDER_RGGB, },\n\t{ MEDIA_BUS_FMT_SBGGR10_1X10, 10, 10, CCS_PIXEL_ORDER_BGGR, },\n\t{ MEDIA_BUS_FMT_SGBRG10_1X10, 10, 10, CCS_PIXEL_ORDER_GBRG, },\n\t{ MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8, 10, 8, CCS_PIXEL_ORDER_GRBG, },\n\t{ MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8, 10, 8, CCS_PIXEL_ORDER_RGGB, },\n\t{ MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8, 10, 8, CCS_PIXEL_ORDER_BGGR, },\n\t{ MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8, 10, 8, CCS_PIXEL_ORDER_GBRG, },\n\t{ MEDIA_BUS_FMT_SGRBG8_1X8, 8, 8, CCS_PIXEL_ORDER_GRBG, },\n\t{ MEDIA_BUS_FMT_SRGGB8_1X8, 8, 8, CCS_PIXEL_ORDER_RGGB, },\n\t{ MEDIA_BUS_FMT_SBGGR8_1X8, 8, 8, CCS_PIXEL_ORDER_BGGR, },\n\t{ MEDIA_BUS_FMT_SGBRG8_1X8, 8, 8, CCS_PIXEL_ORDER_GBRG, },\n};\n\nstatic const char *pixel_order_str[] = { \"GRBG\", \"RGGB\", \"BGGR\", \"GBRG\" };\n\n#define to_csi_format_idx(fmt) (((unsigned long)(fmt)\t\t\t\\\n\t\t\t\t - (unsigned long)ccs_csi_data_formats) \\\n\t\t\t\t/ sizeof(*ccs_csi_data_formats))\n\nstatic u32 ccs_pixel_order(struct ccs_sensor *sensor)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tint flip = 0;\n\n\tif (sensor->hflip) {\n\t\tif (sensor->hflip->val)\n\t\t\tflip |= CCS_IMAGE_ORIENTATION_HORIZONTAL_MIRROR;\n\n\t\tif (sensor->vflip->val)\n\t\t\tflip |= CCS_IMAGE_ORIENTATION_VERTICAL_FLIP;\n\t}\n\n\tdev_dbg(&client->dev, \"flip %u\\n\", flip);\n\treturn sensor->default_pixel_order ^ flip;\n}\n\nstatic void ccs_update_mbus_formats(struct ccs_sensor *sensor)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tunsigned int csi_format_idx =\n\t\tto_csi_format_idx(sensor->csi_format) & ~3;\n\tunsigned int internal_csi_format_idx =\n\t\tto_csi_format_idx(sensor->internal_csi_format) & ~3;\n\tunsigned int pixel_order = ccs_pixel_order(sensor);\n\n\tif (WARN_ON_ONCE(max(internal_csi_format_idx, csi_format_idx) +\n\t\t\t pixel_order >= ARRAY_SIZE(ccs_csi_data_formats)))\n\t\treturn;\n\n\tsensor->mbus_frame_fmts =\n\t\tsensor->default_mbus_frame_fmts << pixel_order;\n\tsensor->csi_format =\n\t\t&ccs_csi_data_formats[csi_format_idx + pixel_order];\n\tsensor->internal_csi_format =\n\t\t&ccs_csi_data_formats[internal_csi_format_idx\n\t\t\t\t\t + pixel_order];\n\n\tdev_dbg(&client->dev, \"new pixel order %s\\n\",\n\t\tpixel_order_str[pixel_order]);\n}\n\nstatic const char * const ccs_test_patterns[] = {\n\t\"Disabled\",\n\t\"Solid Colour\",\n\t\"Eight Vertical Colour Bars\",\n\t\"Colour Bars With Fade to Grey\",\n\t\"Pseudorandom Sequence (PN9)\",\n};\n\nstatic int ccs_set_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ccs_sensor *sensor =\n\t\tcontainer_of(ctrl->handler, struct ccs_subdev, ctrl_handler)\n\t\t\t->sensor;\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tint pm_status;\n\tu32 orient = 0;\n\tunsigned int i;\n\tint exposure;\n\tint rval;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_HFLIP:\n\tcase V4L2_CID_VFLIP:\n\t\tif (sensor->streaming)\n\t\t\treturn -EBUSY;\n\n\t\tif (sensor->hflip->val)\n\t\t\torient |= CCS_IMAGE_ORIENTATION_HORIZONTAL_MIRROR;\n\n\t\tif (sensor->vflip->val)\n\t\t\torient |= CCS_IMAGE_ORIENTATION_VERTICAL_FLIP;\n\n\t\tccs_update_mbus_formats(sensor);\n\n\t\tbreak;\n\tcase V4L2_CID_VBLANK:\n\t\texposure = sensor->exposure->val;\n\n\t\t__ccs_update_exposure_limits(sensor);\n\n\t\tif (exposure > sensor->exposure->maximum) {\n\t\t\tsensor->exposure->val =\tsensor->exposure->maximum;\n\t\t\trval = ccs_set_ctrl(sensor->exposure);\n\t\t\tif (rval < 0)\n\t\t\t\treturn rval;\n\t\t}\n\n\t\tbreak;\n\tcase V4L2_CID_LINK_FREQ:\n\t\tif (sensor->streaming)\n\t\t\treturn -EBUSY;\n\n\t\trval = ccs_pll_update(sensor);\n\t\tif (rval)\n\t\t\treturn rval;\n\n\t\treturn 0;\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tfor (i = 0; i < ARRAY_SIZE(sensor->test_data); i++)\n\t\t\tv4l2_ctrl_activate(\n\t\t\t\tsensor->test_data[i],\n\t\t\t\tctrl->val ==\n\t\t\t\tV4L2_SMIAPP_TEST_PATTERN_MODE_SOLID_COLOUR);\n\n\t\tbreak;\n\t}\n\n\tpm_status = pm_runtime_get_if_active(&client->dev, true);\n\tif (!pm_status)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_ANALOGUE_GAIN:\n\t\trval = ccs_write(sensor, ANALOG_GAIN_CODE_GLOBAL, ctrl->val);\n\n\t\tbreak;\n\n\tcase V4L2_CID_CCS_ANALOGUE_LINEAR_GAIN:\n\t\trval = ccs_write(sensor, ANALOG_LINEAR_GAIN_GLOBAL, ctrl->val);\n\n\t\tbreak;\n\n\tcase V4L2_CID_CCS_ANALOGUE_EXPONENTIAL_GAIN:\n\t\trval = ccs_write(sensor, ANALOG_EXPONENTIAL_GAIN_GLOBAL,\n\t\t\t\t ctrl->val);\n\n\t\tbreak;\n\n\tcase V4L2_CID_DIGITAL_GAIN:\n\t\tif (CCS_LIM(sensor, DIGITAL_GAIN_CAPABILITY) ==\n\t\t    CCS_DIGITAL_GAIN_CAPABILITY_GLOBAL) {\n\t\t\trval = ccs_write(sensor, DIGITAL_GAIN_GLOBAL,\n\t\t\t\t\t ctrl->val);\n\t\t\tbreak;\n\t\t}\n\n\t\trval = ccs_write_addr(sensor,\n\t\t\t\t      SMIAPP_REG_U16_DIGITAL_GAIN_GREENR,\n\t\t\t\t      ctrl->val);\n\t\tif (rval)\n\t\t\tbreak;\n\n\t\trval = ccs_write_addr(sensor,\n\t\t\t\t      SMIAPP_REG_U16_DIGITAL_GAIN_RED,\n\t\t\t\t      ctrl->val);\n\t\tif (rval)\n\t\t\tbreak;\n\n\t\trval = ccs_write_addr(sensor,\n\t\t\t\t      SMIAPP_REG_U16_DIGITAL_GAIN_BLUE,\n\t\t\t\t      ctrl->val);\n\t\tif (rval)\n\t\t\tbreak;\n\n\t\trval = ccs_write_addr(sensor,\n\t\t\t\t      SMIAPP_REG_U16_DIGITAL_GAIN_GREENB,\n\t\t\t\t      ctrl->val);\n\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE:\n\t\trval = ccs_write(sensor, COARSE_INTEGRATION_TIME, ctrl->val);\n\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\tcase V4L2_CID_VFLIP:\n\t\trval = ccs_write(sensor, IMAGE_ORIENTATION, orient);\n\n\t\tbreak;\n\tcase V4L2_CID_VBLANK:\n\t\trval = ccs_write(sensor, FRAME_LENGTH_LINES,\n\t\t\t\t sensor->pixel_array->crop[\n\t\t\t\t\t CCS_PA_PAD_SRC].height\n\t\t\t\t + ctrl->val);\n\n\t\tbreak;\n\tcase V4L2_CID_HBLANK:\n\t\trval = ccs_write(sensor, LINE_LENGTH_PCK,\n\t\t\t\t sensor->pixel_array->crop[CCS_PA_PAD_SRC].width\n\t\t\t\t + ctrl->val);\n\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN:\n\t\trval = ccs_write(sensor, TEST_PATTERN_MODE, ctrl->val);\n\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN_RED:\n\t\trval = ccs_write(sensor, TEST_DATA_RED, ctrl->val);\n\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN_GREENR:\n\t\trval = ccs_write(sensor, TEST_DATA_GREENR, ctrl->val);\n\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN_BLUE:\n\t\trval = ccs_write(sensor, TEST_DATA_BLUE, ctrl->val);\n\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN_GREENB:\n\t\trval = ccs_write(sensor, TEST_DATA_GREENB, ctrl->val);\n\n\t\tbreak;\n\tcase V4L2_CID_CCS_SHADING_CORRECTION:\n\t\trval = ccs_write(sensor, SHADING_CORRECTION_EN,\n\t\t\t\t ctrl->val ? CCS_SHADING_CORRECTION_EN_ENABLE :\n\t\t\t\t 0);\n\n\t\tif (!rval && sensor->luminance_level)\n\t\t\tv4l2_ctrl_activate(sensor->luminance_level, ctrl->val);\n\n\t\tbreak;\n\tcase V4L2_CID_CCS_LUMINANCE_CORRECTION_LEVEL:\n\t\trval = ccs_write(sensor, LUMINANCE_CORRECTION_LEVEL, ctrl->val);\n\n\t\tbreak;\n\tcase V4L2_CID_PIXEL_RATE:\n\t\t \n\t\trval = 0;\n\n\t\tbreak;\n\tdefault:\n\t\trval = -EINVAL;\n\t}\n\n\tif (pm_status > 0) {\n\t\tpm_runtime_mark_last_busy(&client->dev);\n\t\tpm_runtime_put_autosuspend(&client->dev);\n\t}\n\n\treturn rval;\n}\n\nstatic const struct v4l2_ctrl_ops ccs_ctrl_ops = {\n\t.s_ctrl = ccs_set_ctrl,\n};\n\nstatic int ccs_init_controls(struct ccs_sensor *sensor)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tstruct v4l2_fwnode_device_properties props;\n\tint rval;\n\n\trval = v4l2_ctrl_handler_init(&sensor->pixel_array->ctrl_handler, 19);\n\tif (rval)\n\t\treturn rval;\n\n\tsensor->pixel_array->ctrl_handler.lock = &sensor->mutex;\n\n\trval = v4l2_fwnode_device_parse(&client->dev, &props);\n\tif (rval)\n\t\treturn rval;\n\n\trval = v4l2_ctrl_new_fwnode_properties(&sensor->pixel_array->ctrl_handler,\n\t\t\t\t\t       &ccs_ctrl_ops, &props);\n\tif (rval)\n\t\treturn rval;\n\n\tswitch (CCS_LIM(sensor, ANALOG_GAIN_CAPABILITY)) {\n\tcase CCS_ANALOG_GAIN_CAPABILITY_GLOBAL: {\n\t\tstruct {\n\t\t\tconst char *name;\n\t\t\tu32 id;\n\t\t\ts32 value;\n\t\t} const gain_ctrls[] = {\n\t\t\t{ \"Analogue Gain m0\", V4L2_CID_CCS_ANALOGUE_GAIN_M0,\n\t\t\t  CCS_LIM(sensor, ANALOG_GAIN_M0), },\n\t\t\t{ \"Analogue Gain c0\", V4L2_CID_CCS_ANALOGUE_GAIN_C0,\n\t\t\t  CCS_LIM(sensor, ANALOG_GAIN_C0), },\n\t\t\t{ \"Analogue Gain m1\", V4L2_CID_CCS_ANALOGUE_GAIN_M1,\n\t\t\t  CCS_LIM(sensor, ANALOG_GAIN_M1), },\n\t\t\t{ \"Analogue Gain c1\", V4L2_CID_CCS_ANALOGUE_GAIN_C1,\n\t\t\t  CCS_LIM(sensor, ANALOG_GAIN_C1), },\n\t\t};\n\t\tstruct v4l2_ctrl_config ctrl_cfg = {\n\t\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t\t.ops = &ccs_ctrl_ops,\n\t\t\t.flags = V4L2_CTRL_FLAG_READ_ONLY,\n\t\t\t.step = 1,\n\t\t};\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(gain_ctrls); i++) {\n\t\t\tctrl_cfg.name = gain_ctrls[i].name;\n\t\t\tctrl_cfg.id = gain_ctrls[i].id;\n\t\t\tctrl_cfg.min = ctrl_cfg.max = ctrl_cfg.def =\n\t\t\t\tgain_ctrls[i].value;\n\n\t\t\tv4l2_ctrl_new_custom(&sensor->pixel_array->ctrl_handler,\n\t\t\t\t\t     &ctrl_cfg, NULL);\n\t\t}\n\n\t\tv4l2_ctrl_new_std(&sensor->pixel_array->ctrl_handler,\n\t\t\t\t  &ccs_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,\n\t\t\t\t  CCS_LIM(sensor, ANALOG_GAIN_CODE_MIN),\n\t\t\t\t  CCS_LIM(sensor, ANALOG_GAIN_CODE_MAX),\n\t\t\t\t  max(CCS_LIM(sensor, ANALOG_GAIN_CODE_STEP),\n\t\t\t\t      1U),\n\t\t\t\t  CCS_LIM(sensor, ANALOG_GAIN_CODE_MIN));\n\t}\n\t\tbreak;\n\n\tcase CCS_ANALOG_GAIN_CAPABILITY_ALTERNATE_GLOBAL: {\n\t\tstruct {\n\t\t\tconst char *name;\n\t\t\tu32 id;\n\t\t\tu16 min, max, step;\n\t\t} const gain_ctrls[] = {\n\t\t\t{\n\t\t\t\t\"Analogue Linear Gain\",\n\t\t\t\tV4L2_CID_CCS_ANALOGUE_LINEAR_GAIN,\n\t\t\t\tCCS_LIM(sensor, ANALOG_LINEAR_GAIN_MIN),\n\t\t\t\tCCS_LIM(sensor, ANALOG_LINEAR_GAIN_MAX),\n\t\t\t\tmax(CCS_LIM(sensor,\n\t\t\t\t\t    ANALOG_LINEAR_GAIN_STEP_SIZE),\n\t\t\t\t    1U),\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"Analogue Exponential Gain\",\n\t\t\t\tV4L2_CID_CCS_ANALOGUE_EXPONENTIAL_GAIN,\n\t\t\t\tCCS_LIM(sensor, ANALOG_EXPONENTIAL_GAIN_MIN),\n\t\t\t\tCCS_LIM(sensor, ANALOG_EXPONENTIAL_GAIN_MAX),\n\t\t\t\tmax(CCS_LIM(sensor,\n\t\t\t\t\t    ANALOG_EXPONENTIAL_GAIN_STEP_SIZE),\n\t\t\t\t    1U),\n\t\t\t},\n\t\t};\n\t\tstruct v4l2_ctrl_config ctrl_cfg = {\n\t\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t\t.ops = &ccs_ctrl_ops,\n\t\t};\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(gain_ctrls); i++) {\n\t\t\tctrl_cfg.name = gain_ctrls[i].name;\n\t\t\tctrl_cfg.min = ctrl_cfg.def = gain_ctrls[i].min;\n\t\t\tctrl_cfg.max = gain_ctrls[i].max;\n\t\t\tctrl_cfg.step = gain_ctrls[i].step;\n\t\t\tctrl_cfg.id = gain_ctrls[i].id;\n\n\t\t\tv4l2_ctrl_new_custom(&sensor->pixel_array->ctrl_handler,\n\t\t\t\t\t     &ctrl_cfg, NULL);\n\t\t}\n\t}\n\t}\n\n\tif (CCS_LIM(sensor, SHADING_CORRECTION_CAPABILITY) &\n\t    (CCS_SHADING_CORRECTION_CAPABILITY_COLOR_SHADING |\n\t     CCS_SHADING_CORRECTION_CAPABILITY_LUMINANCE_CORRECTION)) {\n\t\tconst struct v4l2_ctrl_config ctrl_cfg = {\n\t\t\t.name = \"Shading Correction\",\n\t\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t\t.id = V4L2_CID_CCS_SHADING_CORRECTION,\n\t\t\t.ops = &ccs_ctrl_ops,\n\t\t\t.max = 1,\n\t\t\t.step = 1,\n\t\t};\n\n\t\tv4l2_ctrl_new_custom(&sensor->pixel_array->ctrl_handler,\n\t\t\t\t     &ctrl_cfg, NULL);\n\t}\n\n\tif (CCS_LIM(sensor, SHADING_CORRECTION_CAPABILITY) &\n\t    CCS_SHADING_CORRECTION_CAPABILITY_LUMINANCE_CORRECTION) {\n\t\tconst struct v4l2_ctrl_config ctrl_cfg = {\n\t\t\t.name = \"Luminance Correction Level\",\n\t\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t\t.id = V4L2_CID_CCS_LUMINANCE_CORRECTION_LEVEL,\n\t\t\t.ops = &ccs_ctrl_ops,\n\t\t\t.max = 255,\n\t\t\t.step = 1,\n\t\t\t.def = 128,\n\t\t};\n\n\t\tsensor->luminance_level =\n\t\t\tv4l2_ctrl_new_custom(&sensor->pixel_array->ctrl_handler,\n\t\t\t\t\t     &ctrl_cfg, NULL);\n\t}\n\n\tif (CCS_LIM(sensor, DIGITAL_GAIN_CAPABILITY) ==\n\t    CCS_DIGITAL_GAIN_CAPABILITY_GLOBAL ||\n\t    CCS_LIM(sensor, DIGITAL_GAIN_CAPABILITY) ==\n\t    SMIAPP_DIGITAL_GAIN_CAPABILITY_PER_CHANNEL)\n\t\tv4l2_ctrl_new_std(&sensor->pixel_array->ctrl_handler,\n\t\t\t\t  &ccs_ctrl_ops, V4L2_CID_DIGITAL_GAIN,\n\t\t\t\t  CCS_LIM(sensor, DIGITAL_GAIN_MIN),\n\t\t\t\t  CCS_LIM(sensor, DIGITAL_GAIN_MAX),\n\t\t\t\t  max(CCS_LIM(sensor, DIGITAL_GAIN_STEP_SIZE),\n\t\t\t\t      1U),\n\t\t\t\t  0x100);\n\n\t \n\tsensor->exposure = v4l2_ctrl_new_std(\n\t\t&sensor->pixel_array->ctrl_handler, &ccs_ctrl_ops,\n\t\tV4L2_CID_EXPOSURE, 0, 0, 1, 0);\n\n\tsensor->hflip = v4l2_ctrl_new_std(\n\t\t&sensor->pixel_array->ctrl_handler, &ccs_ctrl_ops,\n\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\tsensor->vflip = v4l2_ctrl_new_std(\n\t\t&sensor->pixel_array->ctrl_handler, &ccs_ctrl_ops,\n\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\n\tsensor->vblank = v4l2_ctrl_new_std(\n\t\t&sensor->pixel_array->ctrl_handler, &ccs_ctrl_ops,\n\t\tV4L2_CID_VBLANK, 0, 1, 1, 0);\n\n\tif (sensor->vblank)\n\t\tsensor->vblank->flags |= V4L2_CTRL_FLAG_UPDATE;\n\n\tsensor->hblank = v4l2_ctrl_new_std(\n\t\t&sensor->pixel_array->ctrl_handler, &ccs_ctrl_ops,\n\t\tV4L2_CID_HBLANK, 0, 1, 1, 0);\n\n\tif (sensor->hblank)\n\t\tsensor->hblank->flags |= V4L2_CTRL_FLAG_UPDATE;\n\n\tsensor->pixel_rate_parray = v4l2_ctrl_new_std(\n\t\t&sensor->pixel_array->ctrl_handler, &ccs_ctrl_ops,\n\t\tV4L2_CID_PIXEL_RATE, 1, INT_MAX, 1, 1);\n\n\tv4l2_ctrl_new_std_menu_items(&sensor->pixel_array->ctrl_handler,\n\t\t\t\t     &ccs_ctrl_ops, V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(ccs_test_patterns) - 1,\n\t\t\t\t     0, 0, ccs_test_patterns);\n\n\tif (sensor->pixel_array->ctrl_handler.error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"pixel array controls initialization failed (%d)\\n\",\n\t\t\tsensor->pixel_array->ctrl_handler.error);\n\t\treturn sensor->pixel_array->ctrl_handler.error;\n\t}\n\n\tsensor->pixel_array->sd.ctrl_handler =\n\t\t&sensor->pixel_array->ctrl_handler;\n\n\tv4l2_ctrl_cluster(2, &sensor->hflip);\n\n\trval = v4l2_ctrl_handler_init(&sensor->src->ctrl_handler, 0);\n\tif (rval)\n\t\treturn rval;\n\n\tsensor->src->ctrl_handler.lock = &sensor->mutex;\n\n\tsensor->pixel_rate_csi = v4l2_ctrl_new_std(\n\t\t&sensor->src->ctrl_handler, &ccs_ctrl_ops,\n\t\tV4L2_CID_PIXEL_RATE, 1, INT_MAX, 1, 1);\n\n\tif (sensor->src->ctrl_handler.error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"src controls initialization failed (%d)\\n\",\n\t\t\tsensor->src->ctrl_handler.error);\n\t\treturn sensor->src->ctrl_handler.error;\n\t}\n\n\tsensor->src->sd.ctrl_handler = &sensor->src->ctrl_handler;\n\n\treturn 0;\n}\n\n \nstatic int ccs_init_late_controls(struct ccs_sensor *sensor)\n{\n\tunsigned long *valid_link_freqs = &sensor->valid_link_freqs[\n\t\tsensor->csi_format->compressed - sensor->compressed_min_bpp];\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sensor->test_data); i++) {\n\t\tint max_value = (1 << sensor->csi_format->width) - 1;\n\n\t\tsensor->test_data[i] = v4l2_ctrl_new_std(\n\t\t\t\t&sensor->pixel_array->ctrl_handler,\n\t\t\t\t&ccs_ctrl_ops, V4L2_CID_TEST_PATTERN_RED + i,\n\t\t\t\t0, max_value, 1, max_value);\n\t}\n\n\tsensor->link_freq = v4l2_ctrl_new_int_menu(\n\t\t&sensor->src->ctrl_handler, &ccs_ctrl_ops,\n\t\tV4L2_CID_LINK_FREQ, __fls(*valid_link_freqs),\n\t\t__ffs(*valid_link_freqs), sensor->hwcfg.op_sys_clock);\n\n\treturn sensor->src->ctrl_handler.error;\n}\n\nstatic void ccs_free_controls(struct ccs_sensor *sensor)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < sensor->ssds_used; i++)\n\t\tv4l2_ctrl_handler_free(&sensor->ssds[i].ctrl_handler);\n}\n\nstatic int ccs_get_mbus_formats(struct ccs_sensor *sensor)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tstruct ccs_pll *pll = &sensor->pll;\n\tu8 compressed_max_bpp = 0;\n\tunsigned int type, n;\n\tunsigned int i, pixel_order;\n\tint rval;\n\n\ttype = CCS_LIM(sensor, DATA_FORMAT_MODEL_TYPE);\n\n\tdev_dbg(&client->dev, \"data_format_model_type %u\\n\", type);\n\n\trval = ccs_read(sensor, PIXEL_ORDER, &pixel_order);\n\tif (rval)\n\t\treturn rval;\n\n\tif (pixel_order >= ARRAY_SIZE(pixel_order_str)) {\n\t\tdev_dbg(&client->dev, \"bad pixel order %u\\n\", pixel_order);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&client->dev, \"pixel order %u (%s)\\n\", pixel_order,\n\t\tpixel_order_str[pixel_order]);\n\n\tswitch (type) {\n\tcase CCS_DATA_FORMAT_MODEL_TYPE_NORMAL:\n\t\tn = SMIAPP_DATA_FORMAT_MODEL_TYPE_NORMAL_N;\n\t\tbreak;\n\tcase CCS_DATA_FORMAT_MODEL_TYPE_EXTENDED:\n\t\tn = CCS_LIM_DATA_FORMAT_DESCRIPTOR_MAX_N + 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsensor->default_pixel_order = pixel_order;\n\tsensor->mbus_frame_fmts = 0;\n\n\tfor (i = 0; i < n; i++) {\n\t\tunsigned int fmt, j;\n\n\t\tfmt = CCS_LIM_AT(sensor, DATA_FORMAT_DESCRIPTOR, i);\n\n\t\tdev_dbg(&client->dev, \"%u: bpp %u, compressed %u\\n\",\n\t\t\ti, fmt >> 8, (u8)fmt);\n\n\t\tfor (j = 0; j < ARRAY_SIZE(ccs_csi_data_formats); j++) {\n\t\t\tconst struct ccs_csi_data_format *f =\n\t\t\t\t&ccs_csi_data_formats[j];\n\n\t\t\tif (f->pixel_order != CCS_PIXEL_ORDER_GRBG)\n\t\t\t\tcontinue;\n\n\t\t\tif (f->width != fmt >>\n\t\t\t    CCS_DATA_FORMAT_DESCRIPTOR_UNCOMPRESSED_SHIFT ||\n\t\t\t    f->compressed !=\n\t\t\t    (fmt & CCS_DATA_FORMAT_DESCRIPTOR_COMPRESSED_MASK))\n\t\t\t\tcontinue;\n\n\t\t\tdev_dbg(&client->dev, \"jolly good! %u\\n\", j);\n\n\t\t\tsensor->default_mbus_frame_fmts |= 1 << j;\n\t\t}\n\t}\n\n\t \n\tpll->binning_horizontal = 1;\n\tpll->binning_vertical = 1;\n\tpll->scale_m = sensor->scale_m;\n\n\tfor (i = 0; i < ARRAY_SIZE(ccs_csi_data_formats); i++) {\n\t\tsensor->compressed_min_bpp =\n\t\t\tmin(ccs_csi_data_formats[i].compressed,\n\t\t\t    sensor->compressed_min_bpp);\n\t\tcompressed_max_bpp =\n\t\t\tmax(ccs_csi_data_formats[i].compressed,\n\t\t\t    compressed_max_bpp);\n\t}\n\n\tsensor->valid_link_freqs = devm_kcalloc(\n\t\t&client->dev,\n\t\tcompressed_max_bpp - sensor->compressed_min_bpp + 1,\n\t\tsizeof(*sensor->valid_link_freqs), GFP_KERNEL);\n\tif (!sensor->valid_link_freqs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(ccs_csi_data_formats); i++) {\n\t\tconst struct ccs_csi_data_format *f =\n\t\t\t&ccs_csi_data_formats[i];\n\t\tunsigned long *valid_link_freqs =\n\t\t\t&sensor->valid_link_freqs[\n\t\t\t\tf->compressed - sensor->compressed_min_bpp];\n\t\tunsigned int j;\n\n\t\tif (!(sensor->default_mbus_frame_fmts & 1 << i))\n\t\t\tcontinue;\n\n\t\tpll->bits_per_pixel = f->compressed;\n\n\t\tfor (j = 0; sensor->hwcfg.op_sys_clock[j]; j++) {\n\t\t\tpll->link_freq = sensor->hwcfg.op_sys_clock[j];\n\n\t\t\trval = ccs_pll_try(sensor, pll);\n\t\t\tdev_dbg(&client->dev, \"link freq %u Hz, bpp %u %s\\n\",\n\t\t\t\tpll->link_freq, pll->bits_per_pixel,\n\t\t\t\trval ? \"not ok\" : \"ok\");\n\t\t\tif (rval)\n\t\t\t\tcontinue;\n\n\t\t\tset_bit(j, valid_link_freqs);\n\t\t}\n\n\t\tif (!*valid_link_freqs) {\n\t\t\tdev_info(&client->dev,\n\t\t\t\t \"no valid link frequencies for %u bpp\\n\",\n\t\t\t\t f->compressed);\n\t\t\tsensor->default_mbus_frame_fmts &= ~BIT(i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!sensor->csi_format\n\t\t    || f->width > sensor->csi_format->width\n\t\t    || (f->width == sensor->csi_format->width\n\t\t\t&& f->compressed > sensor->csi_format->compressed)) {\n\t\t\tsensor->csi_format = f;\n\t\t\tsensor->internal_csi_format = f;\n\t\t}\n\t}\n\n\tif (!sensor->csi_format) {\n\t\tdev_err(&client->dev, \"no supported mbus code found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tccs_update_mbus_formats(sensor);\n\n\treturn 0;\n}\n\nstatic void ccs_update_blanking(struct ccs_sensor *sensor)\n{\n\tstruct v4l2_ctrl *vblank = sensor->vblank;\n\tstruct v4l2_ctrl *hblank = sensor->hblank;\n\tu16 min_fll, max_fll, min_llp, max_llp, min_lbp;\n\tint min, max;\n\n\tif (sensor->binning_vertical > 1 || sensor->binning_horizontal > 1) {\n\t\tmin_fll = CCS_LIM(sensor, MIN_FRAME_LENGTH_LINES_BIN);\n\t\tmax_fll = CCS_LIM(sensor, MAX_FRAME_LENGTH_LINES_BIN);\n\t\tmin_llp = CCS_LIM(sensor, MIN_LINE_LENGTH_PCK_BIN);\n\t\tmax_llp = CCS_LIM(sensor, MAX_LINE_LENGTH_PCK_BIN);\n\t\tmin_lbp = CCS_LIM(sensor, MIN_LINE_BLANKING_PCK_BIN);\n\t} else {\n\t\tmin_fll = CCS_LIM(sensor, MIN_FRAME_LENGTH_LINES);\n\t\tmax_fll = CCS_LIM(sensor, MAX_FRAME_LENGTH_LINES);\n\t\tmin_llp = CCS_LIM(sensor, MIN_LINE_LENGTH_PCK);\n\t\tmax_llp = CCS_LIM(sensor, MAX_LINE_LENGTH_PCK);\n\t\tmin_lbp = CCS_LIM(sensor, MIN_LINE_BLANKING_PCK);\n\t}\n\n\tmin = max_t(int,\n\t\t    CCS_LIM(sensor, MIN_FRAME_BLANKING_LINES),\n\t\t    min_fll - sensor->pixel_array->crop[CCS_PA_PAD_SRC].height);\n\tmax = max_fll -\tsensor->pixel_array->crop[CCS_PA_PAD_SRC].height;\n\n\t__v4l2_ctrl_modify_range(vblank, min, max, vblank->step, min);\n\n\tmin = max_t(int,\n\t\t    min_llp - sensor->pixel_array->crop[CCS_PA_PAD_SRC].width,\n\t\t    min_lbp);\n\tmax = max_llp - sensor->pixel_array->crop[CCS_PA_PAD_SRC].width;\n\n\t__v4l2_ctrl_modify_range(hblank, min, max, hblank->step, min);\n\n\t__ccs_update_exposure_limits(sensor);\n}\n\nstatic int ccs_pll_blanking_update(struct ccs_sensor *sensor)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tint rval;\n\n\trval = ccs_pll_update(sensor);\n\tif (rval < 0)\n\t\treturn rval;\n\n\t \n\tccs_update_blanking(sensor);\n\n\tdev_dbg(&client->dev, \"vblank\\t\\t%d\\n\", sensor->vblank->val);\n\tdev_dbg(&client->dev, \"hblank\\t\\t%d\\n\", sensor->hblank->val);\n\n\tdev_dbg(&client->dev, \"real timeperframe\\t100/%d\\n\",\n\t\tsensor->pll.pixel_rate_pixel_array /\n\t\t((sensor->pixel_array->crop[CCS_PA_PAD_SRC].width\n\t\t  + sensor->hblank->val) *\n\t\t (sensor->pixel_array->crop[CCS_PA_PAD_SRC].height\n\t\t  + sensor->vblank->val) / 100));\n\n\treturn 0;\n}\n\n \n\nstatic int ccs_read_nvm_page(struct ccs_sensor *sensor, u32 p, u8 *nvm,\n\t\t\t     u8 *status)\n{\n\tunsigned int i;\n\tint rval;\n\tu32 s;\n\n\t*status = 0;\n\n\trval = ccs_write(sensor, DATA_TRANSFER_IF_1_PAGE_SELECT, p);\n\tif (rval)\n\t\treturn rval;\n\n\trval = ccs_write(sensor, DATA_TRANSFER_IF_1_CTRL,\n\t\t\t CCS_DATA_TRANSFER_IF_1_CTRL_ENABLE);\n\tif (rval)\n\t\treturn rval;\n\n\trval = ccs_read(sensor, DATA_TRANSFER_IF_1_STATUS, &s);\n\tif (rval)\n\t\treturn rval;\n\n\tif (s & CCS_DATA_TRANSFER_IF_1_STATUS_IMPROPER_IF_USAGE) {\n\t\t*status = s;\n\t\treturn -ENODATA;\n\t}\n\n\tif (CCS_LIM(sensor, DATA_TRANSFER_IF_CAPABILITY) &\n\t    CCS_DATA_TRANSFER_IF_CAPABILITY_POLLING) {\n\t\tfor (i = 1000; i > 0; i--) {\n\t\t\tif (s & CCS_DATA_TRANSFER_IF_1_STATUS_READ_IF_READY)\n\t\t\t\tbreak;\n\n\t\t\trval = ccs_read(sensor, DATA_TRANSFER_IF_1_STATUS, &s);\n\t\t\tif (rval)\n\t\t\t\treturn rval;\n\t\t}\n\n\t\tif (!i)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\tfor (i = 0; i <= CCS_LIM_DATA_TRANSFER_IF_1_DATA_MAX_P; i++) {\n\t\tu32 v;\n\n\t\trval = ccs_read(sensor, DATA_TRANSFER_IF_1_DATA(i), &v);\n\t\tif (rval)\n\t\t\treturn rval;\n\n\t\t*nvm++ = v;\n\t}\n\n\treturn 0;\n}\n\nstatic int ccs_read_nvm(struct ccs_sensor *sensor, unsigned char *nvm,\n\t\t\tsize_t nvm_size)\n{\n\tu8 status = 0;\n\tu32 p;\n\tint rval = 0, rval2;\n\n\tfor (p = 0; p < nvm_size / (CCS_LIM_DATA_TRANSFER_IF_1_DATA_MAX_P + 1)\n\t\t     && !rval; p++) {\n\t\trval = ccs_read_nvm_page(sensor, p, nvm, &status);\n\t\tnvm += CCS_LIM_DATA_TRANSFER_IF_1_DATA_MAX_P + 1;\n\t}\n\n\tif (rval == -ENODATA &&\n\t    status & CCS_DATA_TRANSFER_IF_1_STATUS_IMPROPER_IF_USAGE)\n\t\trval = 0;\n\n\trval2 = ccs_write(sensor, DATA_TRANSFER_IF_1_CTRL, 0);\n\tif (rval < 0)\n\t\treturn rval;\n\telse\n\t\treturn rval2 ?: p * (CCS_LIM_DATA_TRANSFER_IF_1_DATA_MAX_P + 1);\n}\n\n \nstatic int ccs_change_cci_addr(struct ccs_sensor *sensor)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tint rval;\n\tu32 val;\n\n\tclient->addr = sensor->hwcfg.i2c_addr_dfl;\n\n\trval = ccs_write(sensor, CCI_ADDRESS_CTRL,\n\t\t\t sensor->hwcfg.i2c_addr_alt << 1);\n\tif (rval)\n\t\treturn rval;\n\n\tclient->addr = sensor->hwcfg.i2c_addr_alt;\n\n\t \n\trval = ccs_read(sensor, CCI_ADDRESS_CTRL, &val);\n\tif (rval)\n\t\treturn rval;\n\n\tif (val != sensor->hwcfg.i2c_addr_alt << 1)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\n \nstatic int ccs_setup_flash_strobe(struct ccs_sensor *sensor)\n{\n\tstruct ccs_flash_strobe_parms *strobe_setup;\n\tunsigned int ext_freq = sensor->hwcfg.ext_clk;\n\tu32 tmp;\n\tu32 strobe_adjustment;\n\tu32 strobe_width_high_rs;\n\tint rval;\n\n\tstrobe_setup = sensor->hwcfg.strobe_setup;\n\n\t \n\ttmp = div_u64(1000000ULL * ((1 << 16) - 1) * ((1 << 8) - 1) -\n\t\t      1000000 + 1, ext_freq);\n\tstrobe_setup->strobe_width_high_us =\n\t\tclamp_t(u32, strobe_setup->strobe_width_high_us, 1, tmp);\n\n\ttmp = div_u64(((u64)strobe_setup->strobe_width_high_us * (u64)ext_freq +\n\t\t\t1000000 - 1), 1000000ULL);\n\tstrobe_adjustment = (tmp + (1 << 16) - 1 - 1) / ((1 << 16) - 1);\n\tstrobe_width_high_rs = (tmp + strobe_adjustment - 1) /\n\t\t\t\tstrobe_adjustment;\n\n\trval = ccs_write(sensor, FLASH_MODE_RS, strobe_setup->mode);\n\tif (rval < 0)\n\t\tgoto out;\n\n\trval = ccs_write(sensor, FLASH_STROBE_ADJUSTMENT, strobe_adjustment);\n\tif (rval < 0)\n\t\tgoto out;\n\n\trval = ccs_write(sensor, TFLASH_STROBE_WIDTH_HIGH_RS_CTRL,\n\t\t\t strobe_width_high_rs);\n\tif (rval < 0)\n\t\tgoto out;\n\n\trval = ccs_write(sensor, TFLASH_STROBE_DELAY_RS_CTRL,\n\t\t\t strobe_setup->strobe_delay);\n\tif (rval < 0)\n\t\tgoto out;\n\n\trval = ccs_write(sensor, FLASH_STROBE_START_POINT,\n\t\t\t strobe_setup->stobe_start_point);\n\tif (rval < 0)\n\t\tgoto out;\n\n\trval = ccs_write(sensor, FLASH_TRIGGER_RS, strobe_setup->trigger);\n\nout:\n\tsensor->hwcfg.strobe_setup->trigger = 0;\n\n\treturn rval;\n}\n\n \n\nstatic int ccs_write_msr_regs(struct ccs_sensor *sensor)\n{\n\tint rval;\n\n\trval = ccs_write_data_regs(sensor,\n\t\t\t\t   sensor->sdata.sensor_manufacturer_regs,\n\t\t\t\t   sensor->sdata.num_sensor_manufacturer_regs);\n\tif (rval)\n\t\treturn rval;\n\n\treturn ccs_write_data_regs(sensor,\n\t\t\t\t   sensor->mdata.module_manufacturer_regs,\n\t\t\t\t   sensor->mdata.num_module_manufacturer_regs);\n}\n\nstatic int ccs_update_phy_ctrl(struct ccs_sensor *sensor)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tu8 val;\n\n\tif (!sensor->ccs_limits)\n\t\treturn 0;\n\n\tif (CCS_LIM(sensor, PHY_CTRL_CAPABILITY) &\n\t    CCS_PHY_CTRL_CAPABILITY_AUTO_PHY_CTL) {\n\t\tval = CCS_PHY_CTRL_AUTO;\n\t} else if (CCS_LIM(sensor, PHY_CTRL_CAPABILITY) &\n\t\t   CCS_PHY_CTRL_CAPABILITY_UI_PHY_CTL) {\n\t\tval = CCS_PHY_CTRL_UI;\n\t} else {\n\t\tdev_err(&client->dev, \"manual PHY control not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ccs_write(sensor, PHY_CTRL, val);\n}\n\nstatic int ccs_power_on(struct device *dev)\n{\n\tstruct v4l2_subdev *subdev = dev_get_drvdata(dev);\n\tstruct ccs_subdev *ssd = to_ccs_subdev(subdev);\n\t \n\tstruct ccs_sensor *sensor =\n\t\tcontainer_of(ssd, struct ccs_sensor, ssds[0]);\n\tconst struct ccs_device *ccsdev = device_get_match_data(dev);\n\tint rval;\n\n\trval = regulator_bulk_enable(ARRAY_SIZE(ccs_regulators),\n\t\t\t\t     sensor->regulators);\n\tif (rval) {\n\t\tdev_err(dev, \"failed to enable vana regulator\\n\");\n\t\treturn rval;\n\t}\n\n\tif (sensor->reset || sensor->xshutdown || sensor->ext_clk) {\n\t\tunsigned int sleep;\n\n\t\trval = clk_prepare_enable(sensor->ext_clk);\n\t\tif (rval < 0) {\n\t\t\tdev_dbg(dev, \"failed to enable xclk\\n\");\n\t\t\tgoto out_xclk_fail;\n\t\t}\n\n\t\tgpiod_set_value(sensor->reset, 0);\n\t\tgpiod_set_value(sensor->xshutdown, 1);\n\n\t\tif (ccsdev->flags & CCS_DEVICE_FLAG_IS_SMIA)\n\t\t\tsleep = SMIAPP_RESET_DELAY(sensor->hwcfg.ext_clk);\n\t\telse\n\t\t\tsleep = 5000;\n\n\t\tusleep_range(sleep, sleep);\n\t}\n\n\t \n\n\tif (!sensor->reset && !sensor->xshutdown) {\n\t\tu8 retry = 100;\n\t\tu32 reset;\n\n\t\trval = ccs_write(sensor, SOFTWARE_RESET, CCS_SOFTWARE_RESET_ON);\n\t\tif (rval < 0) {\n\t\t\tdev_err(dev, \"software reset failed\\n\");\n\t\t\tgoto out_cci_addr_fail;\n\t\t}\n\n\t\tdo {\n\t\t\trval = ccs_read(sensor, SOFTWARE_RESET, &reset);\n\t\t\treset = !rval && reset == CCS_SOFTWARE_RESET_OFF;\n\t\t\tif (reset)\n\t\t\t\tbreak;\n\n\t\t\tusleep_range(1000, 2000);\n\t\t} while (--retry);\n\n\t\tif (!reset) {\n\t\t\tdev_err(dev, \"software reset failed\\n\");\n\t\t\trval = -EIO;\n\t\t\tgoto out_cci_addr_fail;\n\t\t}\n\t}\n\n\tif (sensor->hwcfg.i2c_addr_alt) {\n\t\trval = ccs_change_cci_addr(sensor);\n\t\tif (rval) {\n\t\t\tdev_err(dev, \"cci address change error\\n\");\n\t\t\tgoto out_cci_addr_fail;\n\t\t}\n\t}\n\n\trval = ccs_write(sensor, COMPRESSION_MODE,\n\t\t\t CCS_COMPRESSION_MODE_DPCM_PCM_SIMPLE);\n\tif (rval) {\n\t\tdev_err(dev, \"compression mode set failed\\n\");\n\t\tgoto out_cci_addr_fail;\n\t}\n\n\trval = ccs_write(sensor, EXTCLK_FREQUENCY_MHZ,\n\t\t\t sensor->hwcfg.ext_clk / (1000000 / (1 << 8)));\n\tif (rval) {\n\t\tdev_err(dev, \"extclk frequency set failed\\n\");\n\t\tgoto out_cci_addr_fail;\n\t}\n\n\trval = ccs_write(sensor, CSI_LANE_MODE, sensor->hwcfg.lanes - 1);\n\tif (rval) {\n\t\tdev_err(dev, \"csi lane mode set failed\\n\");\n\t\tgoto out_cci_addr_fail;\n\t}\n\n\trval = ccs_write(sensor, FAST_STANDBY_CTRL,\n\t\t\t CCS_FAST_STANDBY_CTRL_FRAME_TRUNCATION);\n\tif (rval) {\n\t\tdev_err(dev, \"fast standby set failed\\n\");\n\t\tgoto out_cci_addr_fail;\n\t}\n\n\trval = ccs_write(sensor, CSI_SIGNALING_MODE,\n\t\t\t sensor->hwcfg.csi_signalling_mode);\n\tif (rval) {\n\t\tdev_err(dev, \"csi signalling mode set failed\\n\");\n\t\tgoto out_cci_addr_fail;\n\t}\n\n\trval = ccs_update_phy_ctrl(sensor);\n\tif (rval < 0)\n\t\tgoto out_cci_addr_fail;\n\n\trval = ccs_write_msr_regs(sensor);\n\tif (rval)\n\t\tgoto out_cci_addr_fail;\n\n\trval = ccs_call_quirk(sensor, post_poweron);\n\tif (rval) {\n\t\tdev_err(dev, \"post_poweron quirks failed\\n\");\n\t\tgoto out_cci_addr_fail;\n\t}\n\n\treturn 0;\n\nout_cci_addr_fail:\n\tgpiod_set_value(sensor->reset, 1);\n\tgpiod_set_value(sensor->xshutdown, 0);\n\tclk_disable_unprepare(sensor->ext_clk);\n\nout_xclk_fail:\n\tregulator_bulk_disable(ARRAY_SIZE(ccs_regulators),\n\t\t\t       sensor->regulators);\n\n\treturn rval;\n}\n\nstatic int ccs_power_off(struct device *dev)\n{\n\tstruct v4l2_subdev *subdev = dev_get_drvdata(dev);\n\tstruct ccs_subdev *ssd = to_ccs_subdev(subdev);\n\tstruct ccs_sensor *sensor =\n\t\tcontainer_of(ssd, struct ccs_sensor, ssds[0]);\n\n\t \n\tif (sensor->hwcfg.i2c_addr_alt)\n\t\tccs_write(sensor, SOFTWARE_RESET, CCS_SOFTWARE_RESET_ON);\n\n\tgpiod_set_value(sensor->reset, 1);\n\tgpiod_set_value(sensor->xshutdown, 0);\n\tclk_disable_unprepare(sensor->ext_clk);\n\tusleep_range(5000, 5000);\n\tregulator_bulk_disable(ARRAY_SIZE(ccs_regulators),\n\t\t\t       sensor->regulators);\n\tsensor->streaming = false;\n\n\treturn 0;\n}\n\n \n\nstatic int ccs_start_streaming(struct ccs_sensor *sensor)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tunsigned int binning_mode;\n\tint rval;\n\n\tmutex_lock(&sensor->mutex);\n\n\trval = ccs_write(sensor, CSI_DATA_FORMAT,\n\t\t\t (sensor->csi_format->width << 8) |\n\t\t\t sensor->csi_format->compressed);\n\tif (rval)\n\t\tgoto out;\n\n\t \n\tif (sensor->binning_horizontal == 1 &&\n\t    sensor->binning_vertical == 1) {\n\t\tbinning_mode = 0;\n\t} else {\n\t\tu8 binning_type =\n\t\t\t(sensor->binning_horizontal << 4)\n\t\t\t| sensor->binning_vertical;\n\n\t\trval = ccs_write(sensor, BINNING_TYPE, binning_type);\n\t\tif (rval < 0)\n\t\t\tgoto out;\n\n\t\tbinning_mode = 1;\n\t}\n\trval = ccs_write(sensor, BINNING_MODE, binning_mode);\n\tif (rval < 0)\n\t\tgoto out;\n\n\t \n\trval = ccs_pll_configure(sensor);\n\tif (rval)\n\t\tgoto out;\n\n\t \n\trval = ccs_write(sensor, X_ADDR_START,\n\t\t\t sensor->pixel_array->crop[CCS_PA_PAD_SRC].left);\n\tif (rval < 0)\n\t\tgoto out;\n\n\trval = ccs_write(sensor, Y_ADDR_START,\n\t\t\t sensor->pixel_array->crop[CCS_PA_PAD_SRC].top);\n\tif (rval < 0)\n\t\tgoto out;\n\n\t \n\trval = ccs_write(\n\t\tsensor, X_ADDR_END,\n\t\tsensor->pixel_array->crop[CCS_PA_PAD_SRC].left\n\t\t+ sensor->pixel_array->crop[CCS_PA_PAD_SRC].width - 1);\n\tif (rval < 0)\n\t\tgoto out;\n\n\trval = ccs_write(\n\t\tsensor, Y_ADDR_END,\n\t\tsensor->pixel_array->crop[CCS_PA_PAD_SRC].top\n\t\t+ sensor->pixel_array->crop[CCS_PA_PAD_SRC].height - 1);\n\tif (rval < 0)\n\t\tgoto out;\n\n\t \n\n\t \n\tif (CCS_LIM(sensor, DIGITAL_CROP_CAPABILITY)\n\t    == CCS_DIGITAL_CROP_CAPABILITY_INPUT_CROP) {\n\t\trval = ccs_write(\n\t\t\tsensor, DIGITAL_CROP_X_OFFSET,\n\t\t\tsensor->scaler->crop[CCS_PAD_SINK].left);\n\t\tif (rval < 0)\n\t\t\tgoto out;\n\n\t\trval = ccs_write(\n\t\t\tsensor, DIGITAL_CROP_Y_OFFSET,\n\t\t\tsensor->scaler->crop[CCS_PAD_SINK].top);\n\t\tif (rval < 0)\n\t\t\tgoto out;\n\n\t\trval = ccs_write(\n\t\t\tsensor, DIGITAL_CROP_IMAGE_WIDTH,\n\t\t\tsensor->scaler->crop[CCS_PAD_SINK].width);\n\t\tif (rval < 0)\n\t\t\tgoto out;\n\n\t\trval = ccs_write(\n\t\t\tsensor, DIGITAL_CROP_IMAGE_HEIGHT,\n\t\t\tsensor->scaler->crop[CCS_PAD_SINK].height);\n\t\tif (rval < 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (CCS_LIM(sensor, SCALING_CAPABILITY)\n\t    != CCS_SCALING_CAPABILITY_NONE) {\n\t\trval = ccs_write(sensor, SCALING_MODE, sensor->scaling_mode);\n\t\tif (rval < 0)\n\t\t\tgoto out;\n\n\t\trval = ccs_write(sensor, SCALE_M, sensor->scale_m);\n\t\tif (rval < 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\trval = ccs_write(sensor, X_OUTPUT_SIZE,\n\t\t\t sensor->src->crop[CCS_PAD_SRC].width);\n\tif (rval < 0)\n\t\tgoto out;\n\trval = ccs_write(sensor, Y_OUTPUT_SIZE,\n\t\t\t sensor->src->crop[CCS_PAD_SRC].height);\n\tif (rval < 0)\n\t\tgoto out;\n\n\tif (CCS_LIM(sensor, FLASH_MODE_CAPABILITY) &\n\t    (CCS_FLASH_MODE_CAPABILITY_SINGLE_STROBE |\n\t     SMIAPP_FLASH_MODE_CAPABILITY_MULTIPLE_STROBE) &&\n\t    sensor->hwcfg.strobe_setup != NULL &&\n\t    sensor->hwcfg.strobe_setup->trigger != 0) {\n\t\trval = ccs_setup_flash_strobe(sensor);\n\t\tif (rval)\n\t\t\tgoto out;\n\t}\n\n\trval = ccs_call_quirk(sensor, pre_streamon);\n\tif (rval) {\n\t\tdev_err(&client->dev, \"pre_streamon quirks failed\\n\");\n\t\tgoto out;\n\t}\n\n\trval = ccs_write(sensor, MODE_SELECT, CCS_MODE_SELECT_STREAMING);\n\nout:\n\tmutex_unlock(&sensor->mutex);\n\n\treturn rval;\n}\n\nstatic int ccs_stop_streaming(struct ccs_sensor *sensor)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tint rval;\n\n\tmutex_lock(&sensor->mutex);\n\trval = ccs_write(sensor, MODE_SELECT, CCS_MODE_SELECT_SOFTWARE_STANDBY);\n\tif (rval)\n\t\tgoto out;\n\n\trval = ccs_call_quirk(sensor, post_streamoff);\n\tif (rval)\n\t\tdev_err(&client->dev, \"post_streamoff quirks failed\\n\");\n\nout:\n\tmutex_unlock(&sensor->mutex);\n\treturn rval;\n}\n\n \n\nstatic int ccs_pm_get_init(struct ccs_sensor *sensor)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tint rval;\n\n\t \n\trval = pm_runtime_get_sync(&client->dev);\n\tif (rval < 0)\n\t\tgoto error;\n\n\t \n\tif (rval == 1)\n\t\treturn 0;\n\n\t \n\trval = v4l2_ctrl_handler_setup(&sensor->pixel_array->ctrl_handler);\n\tif (rval)\n\t\tgoto error;\n\n\trval = v4l2_ctrl_handler_setup(&sensor->src->ctrl_handler);\n\tif (rval)\n\t\tgoto error;\n\n\t \n\treturn 0;\nerror:\n\tpm_runtime_put(&client->dev);\n\treturn rval;\n}\n\nstatic int ccs_set_stream(struct v4l2_subdev *subdev, int enable)\n{\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tint rval;\n\n\tif (sensor->streaming == enable)\n\t\treturn 0;\n\n\tif (!enable) {\n\t\tccs_stop_streaming(sensor);\n\t\tsensor->streaming = false;\n\t\tpm_runtime_mark_last_busy(&client->dev);\n\t\tpm_runtime_put_autosuspend(&client->dev);\n\n\t\treturn 0;\n\t}\n\n\trval = ccs_pm_get_init(sensor);\n\tif (rval)\n\t\treturn rval;\n\n\tsensor->streaming = true;\n\n\trval = ccs_start_streaming(sensor);\n\tif (rval < 0) {\n\t\tsensor->streaming = false;\n\t\tpm_runtime_mark_last_busy(&client->dev);\n\t\tpm_runtime_put_autosuspend(&client->dev);\n\t}\n\n\treturn rval;\n}\n\nstatic int ccs_pre_streamon(struct v4l2_subdev *subdev, u32 flags)\n{\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tint rval;\n\n\tif (flags & V4L2_SUBDEV_PRE_STREAMON_FL_MANUAL_LP) {\n\t\tswitch (sensor->hwcfg.csi_signalling_mode) {\n\t\tcase CCS_CSI_SIGNALING_MODE_CSI_2_DPHY:\n\t\t\tif (!(CCS_LIM(sensor, PHY_CTRL_CAPABILITY_2) &\n\t\t\t      CCS_PHY_CTRL_CAPABILITY_2_MANUAL_LP_DPHY))\n\t\t\t\treturn -EACCES;\n\t\t\tbreak;\n\t\tcase CCS_CSI_SIGNALING_MODE_CSI_2_CPHY:\n\t\t\tif (!(CCS_LIM(sensor, PHY_CTRL_CAPABILITY_2) &\n\t\t\t      CCS_PHY_CTRL_CAPABILITY_2_MANUAL_LP_CPHY))\n\t\t\t\treturn -EACCES;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\n\trval = ccs_pm_get_init(sensor);\n\tif (rval)\n\t\treturn rval;\n\n\tif (flags & V4L2_SUBDEV_PRE_STREAMON_FL_MANUAL_LP) {\n\t\trval = ccs_write(sensor, MANUAL_LP_CTRL,\n\t\t\t\t CCS_MANUAL_LP_CTRL_ENABLE);\n\t\tif (rval)\n\t\t\tpm_runtime_put(&client->dev);\n\t}\n\n\treturn rval;\n}\n\nstatic int ccs_post_streamoff(struct v4l2_subdev *subdev)\n{\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\n\treturn pm_runtime_put(&client->dev);\n}\n\nstatic int ccs_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(subdev);\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tunsigned int i;\n\tint idx = -1;\n\tint rval = -EINVAL;\n\n\tmutex_lock(&sensor->mutex);\n\n\tdev_err(&client->dev, \"subdev %s, pad %u, index %u\\n\",\n\t\tsubdev->name, code->pad, code->index);\n\n\tif (subdev != &sensor->src->sd || code->pad != CCS_PAD_SRC) {\n\t\tif (code->index)\n\t\t\tgoto out;\n\n\t\tcode->code = sensor->internal_csi_format->code;\n\t\trval = 0;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(ccs_csi_data_formats); i++) {\n\t\tif (sensor->mbus_frame_fmts & (1 << i))\n\t\t\tidx++;\n\n\t\tif (idx == code->index) {\n\t\t\tcode->code = ccs_csi_data_formats[i].code;\n\t\t\tdev_err(&client->dev, \"found index %u, i %u, code %x\\n\",\n\t\t\t\tcode->index, i, code->code);\n\t\t\trval = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&sensor->mutex);\n\n\treturn rval;\n}\n\nstatic u32 __ccs_get_mbus_code(struct v4l2_subdev *subdev, unsigned int pad)\n{\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\n\tif (subdev == &sensor->src->sd && pad == CCS_PAD_SRC)\n\t\treturn sensor->csi_format->code;\n\telse\n\t\treturn sensor->internal_csi_format->code;\n}\n\nstatic int __ccs_get_format(struct v4l2_subdev *subdev,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    struct v4l2_subdev_format *fmt)\n{\n\tstruct ccs_subdev *ssd = to_ccs_subdev(subdev);\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tfmt->format = *v4l2_subdev_get_try_format(subdev, sd_state,\n\t\t\t\t\t\t\t  fmt->pad);\n\t} else {\n\t\tstruct v4l2_rect *r;\n\n\t\tif (fmt->pad == ssd->source_pad)\n\t\t\tr = &ssd->crop[ssd->source_pad];\n\t\telse\n\t\t\tr = &ssd->sink_fmt;\n\n\t\tfmt->format.code = __ccs_get_mbus_code(subdev, fmt->pad);\n\t\tfmt->format.width = r->width;\n\t\tfmt->format.height = r->height;\n\t\tfmt->format.field = V4L2_FIELD_NONE;\n\t}\n\n\treturn 0;\n}\n\nstatic int ccs_get_format(struct v4l2_subdev *subdev,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *fmt)\n{\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tint rval;\n\n\tmutex_lock(&sensor->mutex);\n\trval = __ccs_get_format(subdev, sd_state, fmt);\n\tmutex_unlock(&sensor->mutex);\n\n\treturn rval;\n}\n\nstatic void ccs_get_crop_compose(struct v4l2_subdev *subdev,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_rect **crops,\n\t\t\t\t struct v4l2_rect **comps, int which)\n{\n\tstruct ccs_subdev *ssd = to_ccs_subdev(subdev);\n\tunsigned int i;\n\n\tif (which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\tif (crops)\n\t\t\tfor (i = 0; i < subdev->entity.num_pads; i++)\n\t\t\t\tcrops[i] = &ssd->crop[i];\n\t\tif (comps)\n\t\t\t*comps = &ssd->compose;\n\t} else {\n\t\tif (crops) {\n\t\t\tfor (i = 0; i < subdev->entity.num_pads; i++)\n\t\t\t\tcrops[i] = v4l2_subdev_get_try_crop(subdev,\n\t\t\t\t\t\t\t\t    sd_state,\n\t\t\t\t\t\t\t\t    i);\n\t\t}\n\t\tif (comps)\n\t\t\t*comps = v4l2_subdev_get_try_compose(subdev, sd_state,\n\t\t\t\t\t\t\t     CCS_PAD_SINK);\n\t}\n}\n\n \nstatic void ccs_propagate(struct v4l2_subdev *subdev,\n\t\t\t  struct v4l2_subdev_state *sd_state, int which,\n\t\t\t  int target)\n{\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tstruct ccs_subdev *ssd = to_ccs_subdev(subdev);\n\tstruct v4l2_rect *comp, *crops[CCS_PADS];\n\n\tccs_get_crop_compose(subdev, sd_state, crops, &comp, which);\n\n\tswitch (target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tcomp->width = crops[CCS_PAD_SINK]->width;\n\t\tcomp->height = crops[CCS_PAD_SINK]->height;\n\t\tif (which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\t\tif (ssd == sensor->scaler) {\n\t\t\t\tsensor->scale_m = CCS_LIM(sensor, SCALER_N_MIN);\n\t\t\t\tsensor->scaling_mode =\n\t\t\t\t\tCCS_SCALING_MODE_NO_SCALING;\n\t\t\t} else if (ssd == sensor->binner) {\n\t\t\t\tsensor->binning_horizontal = 1;\n\t\t\t\tsensor->binning_vertical = 1;\n\t\t\t}\n\t\t}\n\t\tfallthrough;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\t*crops[CCS_PAD_SRC] = *comp;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n}\n\nstatic const struct ccs_csi_data_format\n*ccs_validate_csi_data_format(struct ccs_sensor *sensor, u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ccs_csi_data_formats); i++) {\n\t\tif (sensor->mbus_frame_fmts & (1 << i) &&\n\t\t    ccs_csi_data_formats[i].code == code)\n\t\t\treturn &ccs_csi_data_formats[i];\n\t}\n\n\treturn sensor->csi_format;\n}\n\nstatic int ccs_set_format_source(struct v4l2_subdev *subdev,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_format *fmt)\n{\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tconst struct ccs_csi_data_format *csi_format,\n\t\t*old_csi_format = sensor->csi_format;\n\tunsigned long *valid_link_freqs;\n\tu32 code = fmt->format.code;\n\tunsigned int i;\n\tint rval;\n\n\trval = __ccs_get_format(subdev, sd_state, fmt);\n\tif (rval)\n\t\treturn rval;\n\n\t \n\tif (subdev != &sensor->src->sd)\n\t\treturn 0;\n\n\tcsi_format = ccs_validate_csi_data_format(sensor, code);\n\n\tfmt->format.code = csi_format->code;\n\n\tif (fmt->which != V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn 0;\n\n\tsensor->csi_format = csi_format;\n\n\tif (csi_format->width != old_csi_format->width)\n\t\tfor (i = 0; i < ARRAY_SIZE(sensor->test_data); i++)\n\t\t\t__v4l2_ctrl_modify_range(\n\t\t\t\tsensor->test_data[i], 0,\n\t\t\t\t(1 << csi_format->width) - 1, 1, 0);\n\n\tif (csi_format->compressed == old_csi_format->compressed)\n\t\treturn 0;\n\n\tvalid_link_freqs =\n\t\t&sensor->valid_link_freqs[sensor->csi_format->compressed\n\t\t\t\t\t  - sensor->compressed_min_bpp];\n\n\t__v4l2_ctrl_modify_range(\n\t\tsensor->link_freq, 0,\n\t\t__fls(*valid_link_freqs), ~*valid_link_freqs,\n\t\t__ffs(*valid_link_freqs));\n\n\treturn ccs_pll_update(sensor);\n}\n\nstatic int ccs_set_format(struct v4l2_subdev *subdev,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *fmt)\n{\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tstruct ccs_subdev *ssd = to_ccs_subdev(subdev);\n\tstruct v4l2_rect *crops[CCS_PADS];\n\n\tmutex_lock(&sensor->mutex);\n\n\tif (fmt->pad == ssd->source_pad) {\n\t\tint rval;\n\n\t\trval = ccs_set_format_source(subdev, sd_state, fmt);\n\n\t\tmutex_unlock(&sensor->mutex);\n\n\t\treturn rval;\n\t}\n\n\t \n\tfmt->format.code = __ccs_get_mbus_code(subdev, fmt->pad);\n\tfmt->format.width &= ~1;\n\tfmt->format.height &= ~1;\n\tfmt->format.field = V4L2_FIELD_NONE;\n\n\tfmt->format.width =\n\t\tclamp(fmt->format.width,\n\t\t      CCS_LIM(sensor, MIN_X_OUTPUT_SIZE),\n\t\t      CCS_LIM(sensor, MAX_X_OUTPUT_SIZE));\n\tfmt->format.height =\n\t\tclamp(fmt->format.height,\n\t\t      CCS_LIM(sensor, MIN_Y_OUTPUT_SIZE),\n\t\t      CCS_LIM(sensor, MAX_Y_OUTPUT_SIZE));\n\n\tccs_get_crop_compose(subdev, sd_state, crops, NULL, fmt->which);\n\n\tcrops[ssd->sink_pad]->left = 0;\n\tcrops[ssd->sink_pad]->top = 0;\n\tcrops[ssd->sink_pad]->width = fmt->format.width;\n\tcrops[ssd->sink_pad]->height = fmt->format.height;\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\tssd->sink_fmt = *crops[ssd->sink_pad];\n\tccs_propagate(subdev, sd_state, fmt->which, V4L2_SEL_TGT_CROP);\n\n\tmutex_unlock(&sensor->mutex);\n\n\treturn 0;\n}\n\n \n#define SCALING_GOODNESS\t\t100000\n#define SCALING_GOODNESS_EXTREME\t100000000\nstatic int scaling_goodness(struct v4l2_subdev *subdev, int w, int ask_w,\n\t\t\t    int h, int ask_h, u32 flags)\n{\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tstruct i2c_client *client = v4l2_get_subdevdata(subdev);\n\tint val = 0;\n\n\tw &= ~1;\n\task_w &= ~1;\n\th &= ~1;\n\task_h &= ~1;\n\n\tif (flags & V4L2_SEL_FLAG_GE) {\n\t\tif (w < ask_w)\n\t\t\tval -= SCALING_GOODNESS;\n\t\tif (h < ask_h)\n\t\t\tval -= SCALING_GOODNESS;\n\t}\n\n\tif (flags & V4L2_SEL_FLAG_LE) {\n\t\tif (w > ask_w)\n\t\t\tval -= SCALING_GOODNESS;\n\t\tif (h > ask_h)\n\t\t\tval -= SCALING_GOODNESS;\n\t}\n\n\tval -= abs(w - ask_w);\n\tval -= abs(h - ask_h);\n\n\tif (w < CCS_LIM(sensor, MIN_X_OUTPUT_SIZE))\n\t\tval -= SCALING_GOODNESS_EXTREME;\n\n\tdev_dbg(&client->dev, \"w %d ask_w %d h %d ask_h %d goodness %d\\n\",\n\t\tw, ask_w, h, ask_h, val);\n\n\treturn val;\n}\n\nstatic void ccs_set_compose_binner(struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_selection *sel,\n\t\t\t\t   struct v4l2_rect **crops,\n\t\t\t\t   struct v4l2_rect *comp)\n{\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tunsigned int i;\n\tunsigned int binh = 1, binv = 1;\n\tint best = scaling_goodness(\n\t\tsubdev,\n\t\tcrops[CCS_PAD_SINK]->width, sel->r.width,\n\t\tcrops[CCS_PAD_SINK]->height, sel->r.height, sel->flags);\n\n\tfor (i = 0; i < sensor->nbinning_subtypes; i++) {\n\t\tint this = scaling_goodness(\n\t\t\tsubdev,\n\t\t\tcrops[CCS_PAD_SINK]->width\n\t\t\t/ sensor->binning_subtypes[i].horizontal,\n\t\t\tsel->r.width,\n\t\t\tcrops[CCS_PAD_SINK]->height\n\t\t\t/ sensor->binning_subtypes[i].vertical,\n\t\t\tsel->r.height, sel->flags);\n\n\t\tif (this > best) {\n\t\t\tbinh = sensor->binning_subtypes[i].horizontal;\n\t\t\tbinv = sensor->binning_subtypes[i].vertical;\n\t\t\tbest = this;\n\t\t}\n\t}\n\tif (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\tsensor->binning_vertical = binv;\n\t\tsensor->binning_horizontal = binh;\n\t}\n\n\tsel->r.width = (crops[CCS_PAD_SINK]->width / binh) & ~1;\n\tsel->r.height = (crops[CCS_PAD_SINK]->height / binv) & ~1;\n}\n\n \nstatic void ccs_set_compose_scaler(struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_selection *sel,\n\t\t\t\t   struct v4l2_rect **crops,\n\t\t\t\t   struct v4l2_rect *comp)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(subdev);\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tu32 min, max, a, b, max_m;\n\tu32 scale_m = CCS_LIM(sensor, SCALER_N_MIN);\n\tint mode = CCS_SCALING_MODE_HORIZONTAL;\n\tu32 try[4];\n\tu32 ntry = 0;\n\tunsigned int i;\n\tint best = INT_MIN;\n\n\tsel->r.width = min_t(unsigned int, sel->r.width,\n\t\t\t     crops[CCS_PAD_SINK]->width);\n\tsel->r.height = min_t(unsigned int, sel->r.height,\n\t\t\t      crops[CCS_PAD_SINK]->height);\n\n\ta = crops[CCS_PAD_SINK]->width\n\t\t* CCS_LIM(sensor, SCALER_N_MIN) / sel->r.width;\n\tb = crops[CCS_PAD_SINK]->height\n\t\t* CCS_LIM(sensor, SCALER_N_MIN) / sel->r.height;\n\tmax_m = crops[CCS_PAD_SINK]->width\n\t\t* CCS_LIM(sensor, SCALER_N_MIN)\n\t\t/ CCS_LIM(sensor, MIN_X_OUTPUT_SIZE);\n\n\ta = clamp(a, CCS_LIM(sensor, SCALER_M_MIN),\n\t\t  CCS_LIM(sensor, SCALER_M_MAX));\n\tb = clamp(b, CCS_LIM(sensor, SCALER_M_MIN),\n\t\t  CCS_LIM(sensor, SCALER_M_MAX));\n\tmax_m = clamp(max_m, CCS_LIM(sensor, SCALER_M_MIN),\n\t\t      CCS_LIM(sensor, SCALER_M_MAX));\n\n\tdev_dbg(&client->dev, \"scaling: a %u b %u max_m %u\\n\", a, b, max_m);\n\n\tmin = min(max_m, min(a, b));\n\tmax = min(max_m, max(a, b));\n\n\ttry[ntry] = min;\n\tntry++;\n\tif (min != max) {\n\t\ttry[ntry] = max;\n\t\tntry++;\n\t}\n\tif (max != max_m) {\n\t\ttry[ntry] = min + 1;\n\t\tntry++;\n\t\tif (min != max) {\n\t\t\ttry[ntry] = max + 1;\n\t\t\tntry++;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ntry; i++) {\n\t\tint this = scaling_goodness(\n\t\t\tsubdev,\n\t\t\tcrops[CCS_PAD_SINK]->width\n\t\t\t/ try[i] * CCS_LIM(sensor, SCALER_N_MIN),\n\t\t\tsel->r.width,\n\t\t\tcrops[CCS_PAD_SINK]->height,\n\t\t\tsel->r.height,\n\t\t\tsel->flags);\n\n\t\tdev_dbg(&client->dev, \"trying factor %u (%u)\\n\", try[i], i);\n\n\t\tif (this > best) {\n\t\t\tscale_m = try[i];\n\t\t\tmode = CCS_SCALING_MODE_HORIZONTAL;\n\t\t\tbest = this;\n\t\t}\n\n\t\tif (CCS_LIM(sensor, SCALING_CAPABILITY)\n\t\t    == CCS_SCALING_CAPABILITY_HORIZONTAL)\n\t\t\tcontinue;\n\n\t\tthis = scaling_goodness(\n\t\t\tsubdev, crops[CCS_PAD_SINK]->width\n\t\t\t/ try[i]\n\t\t\t* CCS_LIM(sensor, SCALER_N_MIN),\n\t\t\tsel->r.width,\n\t\t\tcrops[CCS_PAD_SINK]->height\n\t\t\t/ try[i]\n\t\t\t* CCS_LIM(sensor, SCALER_N_MIN),\n\t\t\tsel->r.height,\n\t\t\tsel->flags);\n\n\t\tif (this > best) {\n\t\t\tscale_m = try[i];\n\t\t\tmode = SMIAPP_SCALING_MODE_BOTH;\n\t\t\tbest = this;\n\t\t}\n\t}\n\n\tsel->r.width =\n\t\t(crops[CCS_PAD_SINK]->width\n\t\t / scale_m\n\t\t * CCS_LIM(sensor, SCALER_N_MIN)) & ~1;\n\tif (mode == SMIAPP_SCALING_MODE_BOTH)\n\t\tsel->r.height =\n\t\t\t(crops[CCS_PAD_SINK]->height\n\t\t\t / scale_m\n\t\t\t * CCS_LIM(sensor, SCALER_N_MIN))\n\t\t\t& ~1;\n\telse\n\t\tsel->r.height = crops[CCS_PAD_SINK]->height;\n\n\tif (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\tsensor->scale_m = scale_m;\n\t\tsensor->scaling_mode = mode;\n\t}\n}\n \nstatic int ccs_set_compose(struct v4l2_subdev *subdev,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_selection *sel)\n{\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tstruct ccs_subdev *ssd = to_ccs_subdev(subdev);\n\tstruct v4l2_rect *comp, *crops[CCS_PADS];\n\n\tccs_get_crop_compose(subdev, sd_state, crops, &comp, sel->which);\n\n\tsel->r.top = 0;\n\tsel->r.left = 0;\n\n\tif (ssd == sensor->binner)\n\t\tccs_set_compose_binner(subdev, sd_state, sel, crops, comp);\n\telse\n\t\tccs_set_compose_scaler(subdev, sd_state, sel, crops, comp);\n\n\t*comp = sel->r;\n\tccs_propagate(subdev, sd_state, sel->which, V4L2_SEL_TGT_COMPOSE);\n\n\tif (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn ccs_pll_blanking_update(sensor);\n\n\treturn 0;\n}\n\nstatic int __ccs_sel_supported(struct v4l2_subdev *subdev,\n\t\t\t       struct v4l2_subdev_selection *sel)\n{\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tstruct ccs_subdev *ssd = to_ccs_subdev(subdev);\n\n\t \n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tif (ssd == sensor->pixel_array && sel->pad == CCS_PA_PAD_SRC)\n\t\t\treturn 0;\n\t\tif (ssd == sensor->src && sel->pad == CCS_PAD_SRC)\n\t\t\treturn 0;\n\t\tif (ssd == sensor->scaler && sel->pad == CCS_PAD_SINK &&\n\t\t    CCS_LIM(sensor, DIGITAL_CROP_CAPABILITY)\n\t\t    == CCS_DIGITAL_CROP_CAPABILITY_INPUT_CROP)\n\t\t\treturn 0;\n\t\treturn -EINVAL;\n\tcase V4L2_SEL_TGT_NATIVE_SIZE:\n\t\tif (ssd == sensor->pixel_array && sel->pad == CCS_PA_PAD_SRC)\n\t\t\treturn 0;\n\t\treturn -EINVAL;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\tif (sel->pad == ssd->source_pad)\n\t\t\treturn -EINVAL;\n\t\tif (ssd == sensor->binner)\n\t\t\treturn 0;\n\t\tif (ssd == sensor->scaler && CCS_LIM(sensor, SCALING_CAPABILITY)\n\t\t    != CCS_SCALING_CAPABILITY_NONE)\n\t\t\treturn 0;\n\t\tfallthrough;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ccs_set_crop(struct v4l2_subdev *subdev,\n\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tstruct ccs_subdev *ssd = to_ccs_subdev(subdev);\n\tstruct v4l2_rect *src_size, *crops[CCS_PADS];\n\tstruct v4l2_rect _r;\n\n\tccs_get_crop_compose(subdev, sd_state, crops, NULL, sel->which);\n\n\tif (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\tif (sel->pad == ssd->sink_pad)\n\t\t\tsrc_size = &ssd->sink_fmt;\n\t\telse\n\t\t\tsrc_size = &ssd->compose;\n\t} else {\n\t\tif (sel->pad == ssd->sink_pad) {\n\t\t\t_r.left = 0;\n\t\t\t_r.top = 0;\n\t\t\t_r.width = v4l2_subdev_get_try_format(subdev,\n\t\t\t\t\t\t\t      sd_state,\n\t\t\t\t\t\t\t      sel->pad)\n\t\t\t\t->width;\n\t\t\t_r.height = v4l2_subdev_get_try_format(subdev,\n\t\t\t\t\t\t\t       sd_state,\n\t\t\t\t\t\t\t       sel->pad)\n\t\t\t\t->height;\n\t\t\tsrc_size = &_r;\n\t\t} else {\n\t\t\tsrc_size = v4l2_subdev_get_try_compose(\n\t\t\t\tsubdev, sd_state, ssd->sink_pad);\n\t\t}\n\t}\n\n\tif (ssd == sensor->src && sel->pad == CCS_PAD_SRC) {\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t}\n\n\tsel->r.width = min(sel->r.width, src_size->width);\n\tsel->r.height = min(sel->r.height, src_size->height);\n\n\tsel->r.left = min_t(int, sel->r.left, src_size->width - sel->r.width);\n\tsel->r.top = min_t(int, sel->r.top, src_size->height - sel->r.height);\n\n\t*crops[sel->pad] = sel->r;\n\n\tif (ssd != sensor->pixel_array && sel->pad == CCS_PAD_SINK)\n\t\tccs_propagate(subdev, sd_state, sel->which, V4L2_SEL_TGT_CROP);\n\n\treturn 0;\n}\n\nstatic void ccs_get_native_size(struct ccs_subdev *ssd, struct v4l2_rect *r)\n{\n\tr->top = 0;\n\tr->left = 0;\n\tr->width = CCS_LIM(ssd->sensor, X_ADDR_MAX) + 1;\n\tr->height = CCS_LIM(ssd->sensor, Y_ADDR_MAX) + 1;\n}\n\nstatic int __ccs_get_selection(struct v4l2_subdev *subdev,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_selection *sel)\n{\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tstruct ccs_subdev *ssd = to_ccs_subdev(subdev);\n\tstruct v4l2_rect *comp, *crops[CCS_PADS];\n\tstruct v4l2_rect sink_fmt;\n\tint ret;\n\n\tret = __ccs_sel_supported(subdev, sel);\n\tif (ret)\n\t\treturn ret;\n\n\tccs_get_crop_compose(subdev, sd_state, crops, &comp, sel->which);\n\n\tif (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\tsink_fmt = ssd->sink_fmt;\n\t} else {\n\t\tstruct v4l2_mbus_framefmt *fmt =\n\t\t\tv4l2_subdev_get_try_format(subdev, sd_state,\n\t\t\t\t\t\t   ssd->sink_pad);\n\n\t\tsink_fmt.left = 0;\n\t\tsink_fmt.top = 0;\n\t\tsink_fmt.width = fmt->width;\n\t\tsink_fmt.height = fmt->height;\n\t}\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_NATIVE_SIZE:\n\t\tif (ssd == sensor->pixel_array)\n\t\t\tccs_get_native_size(ssd, &sel->r);\n\t\telse if (sel->pad == ssd->sink_pad)\n\t\t\tsel->r = sink_fmt;\n\t\telse\n\t\t\tsel->r = *comp;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\tsel->r = *crops[sel->pad];\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tsel->r = *comp;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ccs_get_selection(struct v4l2_subdev *subdev,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_selection *sel)\n{\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tint rval;\n\n\tmutex_lock(&sensor->mutex);\n\trval = __ccs_get_selection(subdev, sd_state, sel);\n\tmutex_unlock(&sensor->mutex);\n\n\treturn rval;\n}\n\nstatic int ccs_set_selection(struct v4l2_subdev *subdev,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_selection *sel)\n{\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tint ret;\n\n\tret = __ccs_sel_supported(subdev, sel);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&sensor->mutex);\n\n\tsel->r.left = max(0, sel->r.left & ~1);\n\tsel->r.top = max(0, sel->r.top & ~1);\n\tsel->r.width = CCS_ALIGN_DIM(sel->r.width, sel->flags);\n\tsel->r.height =\tCCS_ALIGN_DIM(sel->r.height, sel->flags);\n\n\tsel->r.width = max_t(unsigned int, CCS_LIM(sensor, MIN_X_OUTPUT_SIZE),\n\t\t\t     sel->r.width);\n\tsel->r.height = max_t(unsigned int, CCS_LIM(sensor, MIN_Y_OUTPUT_SIZE),\n\t\t\t      sel->r.height);\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tret = ccs_set_crop(subdev, sd_state, sel);\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tret = ccs_set_compose(subdev, sd_state, sel);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&sensor->mutex);\n\treturn ret;\n}\n\nstatic int ccs_get_skip_frames(struct v4l2_subdev *subdev, u32 *frames)\n{\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\n\t*frames = sensor->frame_skip;\n\treturn 0;\n}\n\nstatic int ccs_get_skip_top_lines(struct v4l2_subdev *subdev, u32 *lines)\n{\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\n\t*lines = sensor->image_start;\n\n\treturn 0;\n}\n\n \n\nstatic ssize_t\nnvm_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct i2c_client *client = v4l2_get_subdevdata(subdev);\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tint rval;\n\n\tif (!sensor->dev_init_done)\n\t\treturn -EBUSY;\n\n\trval = ccs_pm_get_init(sensor);\n\tif (rval < 0)\n\t\treturn -ENODEV;\n\n\trval = ccs_read_nvm(sensor, buf, PAGE_SIZE);\n\tif (rval < 0) {\n\t\tpm_runtime_put(&client->dev);\n\t\tdev_err(&client->dev, \"nvm read failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpm_runtime_mark_last_busy(&client->dev);\n\tpm_runtime_put_autosuspend(&client->dev);\n\n\t \n\treturn rval;\n}\nstatic DEVICE_ATTR_RO(nvm);\n\nstatic ssize_t\nident_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(to_i2c_client(dev));\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tstruct ccs_module_info *minfo = &sensor->minfo;\n\n\tif (minfo->mipi_manufacturer_id)\n\t\treturn sysfs_emit(buf, \"%4.4x%4.4x%2.2x\\n\",\n\t\t\t\t    minfo->mipi_manufacturer_id, minfo->model_id,\n\t\t\t\t    minfo->revision_number) + 1;\n\telse\n\t\treturn sysfs_emit(buf, \"%2.2x%4.4x%2.2x\\n\",\n\t\t\t\t    minfo->smia_manufacturer_id, minfo->model_id,\n\t\t\t\t    minfo->revision_number) + 1;\n}\nstatic DEVICE_ATTR_RO(ident);\n\n \n\nstatic int ccs_identify_module(struct ccs_sensor *sensor)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tstruct ccs_module_info *minfo = &sensor->minfo;\n\tunsigned int i;\n\tu32 rev;\n\tint rval = 0;\n\n\t \n\trval = ccs_read(sensor, MODULE_MANUFACTURER_ID,\n\t\t\t&minfo->mipi_manufacturer_id);\n\tif (!rval && !minfo->mipi_manufacturer_id)\n\t\trval = ccs_read_addr_8only(sensor,\n\t\t\t\t\t   SMIAPP_REG_U8_MANUFACTURER_ID,\n\t\t\t\t\t   &minfo->smia_manufacturer_id);\n\tif (!rval)\n\t\trval = ccs_read_addr_8only(sensor, CCS_R_MODULE_MODEL_ID,\n\t\t\t\t\t   &minfo->model_id);\n\tif (!rval)\n\t\trval = ccs_read_addr_8only(sensor,\n\t\t\t\t\t   CCS_R_MODULE_REVISION_NUMBER_MAJOR,\n\t\t\t\t\t   &rev);\n\tif (!rval) {\n\t\trval = ccs_read_addr_8only(sensor,\n\t\t\t\t\t   CCS_R_MODULE_REVISION_NUMBER_MINOR,\n\t\t\t\t\t   &minfo->revision_number);\n\t\tminfo->revision_number |= rev << 8;\n\t}\n\tif (!rval)\n\t\trval = ccs_read_addr_8only(sensor, CCS_R_MODULE_DATE_YEAR,\n\t\t\t\t\t   &minfo->module_year);\n\tif (!rval)\n\t\trval = ccs_read_addr_8only(sensor, CCS_R_MODULE_DATE_MONTH,\n\t\t\t\t\t   &minfo->module_month);\n\tif (!rval)\n\t\trval = ccs_read_addr_8only(sensor, CCS_R_MODULE_DATE_DAY,\n\t\t\t\t\t   &minfo->module_day);\n\n\t \n\tif (!rval)\n\t\trval = ccs_read(sensor, SENSOR_MANUFACTURER_ID,\n\t\t\t\t&minfo->sensor_mipi_manufacturer_id);\n\tif (!rval && !minfo->sensor_mipi_manufacturer_id)\n\t\trval = ccs_read_addr_8only(sensor,\n\t\t\t\t\t   CCS_R_SENSOR_MANUFACTURER_ID,\n\t\t\t\t\t   &minfo->sensor_smia_manufacturer_id);\n\tif (!rval)\n\t\trval = ccs_read_addr_8only(sensor,\n\t\t\t\t\t   CCS_R_SENSOR_MODEL_ID,\n\t\t\t\t\t   &minfo->sensor_model_id);\n\tif (!rval)\n\t\trval = ccs_read_addr_8only(sensor,\n\t\t\t\t\t   CCS_R_SENSOR_REVISION_NUMBER,\n\t\t\t\t\t   &minfo->sensor_revision_number);\n\tif (!rval && !minfo->sensor_revision_number)\n\t\trval = ccs_read_addr_8only(sensor,\n\t\t\t\t\t   CCS_R_SENSOR_REVISION_NUMBER_16,\n\t\t\t\t\t   &minfo->sensor_revision_number);\n\tif (!rval)\n\t\trval = ccs_read_addr_8only(sensor,\n\t\t\t\t\t   CCS_R_SENSOR_FIRMWARE_VERSION,\n\t\t\t\t\t   &minfo->sensor_firmware_version);\n\n\t \n\tif (!rval)\n\t\trval = ccs_read(sensor, MIPI_CCS_VERSION, &minfo->ccs_version);\n\tif (!rval && !minfo->ccs_version)\n\t\trval = ccs_read_addr_8only(sensor, SMIAPP_REG_U8_SMIA_VERSION,\n\t\t\t\t\t   &minfo->smia_version);\n\tif (!rval && !minfo->ccs_version)\n\t\trval = ccs_read_addr_8only(sensor, SMIAPP_REG_U8_SMIAPP_VERSION,\n\t\t\t\t\t   &minfo->smiapp_version);\n\n\tif (rval) {\n\t\tdev_err(&client->dev, \"sensor detection failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (minfo->mipi_manufacturer_id)\n\t\tdev_dbg(&client->dev, \"MIPI CCS module 0x%4.4x-0x%4.4x\\n\",\n\t\t\tminfo->mipi_manufacturer_id, minfo->model_id);\n\telse\n\t\tdev_dbg(&client->dev, \"SMIA module 0x%2.2x-0x%4.4x\\n\",\n\t\t\tminfo->smia_manufacturer_id, minfo->model_id);\n\n\tdev_dbg(&client->dev,\n\t\t\"module revision 0x%4.4x date %2.2d-%2.2d-%2.2d\\n\",\n\t\tminfo->revision_number, minfo->module_year, minfo->module_month,\n\t\tminfo->module_day);\n\n\tif (minfo->sensor_mipi_manufacturer_id)\n\t\tdev_dbg(&client->dev, \"MIPI CCS sensor 0x%4.4x-0x%4.4x\\n\",\n\t\t\tminfo->sensor_mipi_manufacturer_id,\n\t\t\tminfo->sensor_model_id);\n\telse\n\t\tdev_dbg(&client->dev, \"SMIA sensor 0x%2.2x-0x%4.4x\\n\",\n\t\t\tminfo->sensor_smia_manufacturer_id,\n\t\t\tminfo->sensor_model_id);\n\n\tdev_dbg(&client->dev,\n\t\t\"sensor revision 0x%4.4x firmware version 0x%2.2x\\n\",\n\t\tminfo->sensor_revision_number, minfo->sensor_firmware_version);\n\n\tif (minfo->ccs_version) {\n\t\tdev_dbg(&client->dev, \"MIPI CCS version %u.%u\",\n\t\t\t(minfo->ccs_version & CCS_MIPI_CCS_VERSION_MAJOR_MASK)\n\t\t\t>> CCS_MIPI_CCS_VERSION_MAJOR_SHIFT,\n\t\t\t(minfo->ccs_version & CCS_MIPI_CCS_VERSION_MINOR_MASK));\n\t\tminfo->name = CCS_NAME;\n\t} else {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"smia version %2.2d smiapp version %2.2d\\n\",\n\t\t\tminfo->smia_version, minfo->smiapp_version);\n\t\tminfo->name = SMIAPP_NAME;\n\t\t \n\t\tif (minfo->sensor_smia_manufacturer_id &&\n\t\t    !minfo->smia_manufacturer_id && !minfo->model_id) {\n\t\t\tminfo->smia_manufacturer_id =\n\t\t\t\tminfo->sensor_smia_manufacturer_id;\n\t\t\tminfo->model_id = minfo->sensor_model_id;\n\t\t\tminfo->revision_number = minfo->sensor_revision_number;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(ccs_module_idents); i++) {\n\t\tif (ccs_module_idents[i].mipi_manufacturer_id &&\n\t\t    ccs_module_idents[i].mipi_manufacturer_id\n\t\t    != minfo->mipi_manufacturer_id)\n\t\t\tcontinue;\n\t\tif (ccs_module_idents[i].smia_manufacturer_id &&\n\t\t    ccs_module_idents[i].smia_manufacturer_id\n\t\t    != minfo->smia_manufacturer_id)\n\t\t\tcontinue;\n\t\tif (ccs_module_idents[i].model_id != minfo->model_id)\n\t\t\tcontinue;\n\t\tif (ccs_module_idents[i].flags\n\t\t    & CCS_MODULE_IDENT_FLAG_REV_LE) {\n\t\t\tif (ccs_module_idents[i].revision_number_major\n\t\t\t    < (minfo->revision_number >> 8))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (ccs_module_idents[i].revision_number_major\n\t\t\t    != (minfo->revision_number >> 8))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tminfo->name = ccs_module_idents[i].name;\n\t\tminfo->quirk = ccs_module_idents[i].quirk;\n\t\tbreak;\n\t}\n\n\tif (i >= ARRAY_SIZE(ccs_module_idents))\n\t\tdev_warn(&client->dev,\n\t\t\t \"no quirks for this module; let's hope it's fully compliant\\n\");\n\n\tdev_dbg(&client->dev, \"the sensor is called %s\\n\", minfo->name);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_ops ccs_ops;\nstatic const struct v4l2_subdev_internal_ops ccs_internal_ops;\nstatic const struct media_entity_operations ccs_entity_ops;\n\nstatic int ccs_register_subdev(struct ccs_sensor *sensor,\n\t\t\t       struct ccs_subdev *ssd,\n\t\t\t       struct ccs_subdev *sink_ssd,\n\t\t\t       u16 source_pad, u16 sink_pad, u32 link_flags)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\tint rval;\n\n\tif (!sink_ssd)\n\t\treturn 0;\n\n\trval = media_entity_pads_init(&ssd->sd.entity, ssd->npads, ssd->pads);\n\tif (rval) {\n\t\tdev_err(&client->dev, \"media_entity_pads_init failed\\n\");\n\t\treturn rval;\n\t}\n\n\trval = v4l2_device_register_subdev(sensor->src->sd.v4l2_dev, &ssd->sd);\n\tif (rval) {\n\t\tdev_err(&client->dev, \"v4l2_device_register_subdev failed\\n\");\n\t\treturn rval;\n\t}\n\n\trval = media_create_pad_link(&ssd->sd.entity, source_pad,\n\t\t\t\t     &sink_ssd->sd.entity, sink_pad,\n\t\t\t\t     link_flags);\n\tif (rval) {\n\t\tdev_err(&client->dev, \"media_create_pad_link failed\\n\");\n\t\tv4l2_device_unregister_subdev(&ssd->sd);\n\t\treturn rval;\n\t}\n\n\treturn 0;\n}\n\nstatic void ccs_unregistered(struct v4l2_subdev *subdev)\n{\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tunsigned int i;\n\n\tfor (i = 1; i < sensor->ssds_used; i++)\n\t\tv4l2_device_unregister_subdev(&sensor->ssds[i].sd);\n}\n\nstatic int ccs_registered(struct v4l2_subdev *subdev)\n{\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tint rval;\n\n\tif (sensor->scaler) {\n\t\trval = ccs_register_subdev(sensor, sensor->binner,\n\t\t\t\t\t   sensor->scaler,\n\t\t\t\t\t   CCS_PAD_SRC, CCS_PAD_SINK,\n\t\t\t\t\t   MEDIA_LNK_FL_ENABLED |\n\t\t\t\t\t   MEDIA_LNK_FL_IMMUTABLE);\n\t\tif (rval < 0)\n\t\t\treturn rval;\n\t}\n\n\trval = ccs_register_subdev(sensor, sensor->pixel_array, sensor->binner,\n\t\t\t\t   CCS_PA_PAD_SRC, CCS_PAD_SINK,\n\t\t\t\t   MEDIA_LNK_FL_ENABLED |\n\t\t\t\t   MEDIA_LNK_FL_IMMUTABLE);\n\tif (rval)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\tccs_unregistered(subdev);\n\n\treturn rval;\n}\n\nstatic void ccs_cleanup(struct ccs_sensor *sensor)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\n\tdevice_remove_file(&client->dev, &dev_attr_nvm);\n\tdevice_remove_file(&client->dev, &dev_attr_ident);\n\n\tccs_free_controls(sensor);\n}\n\nstatic void ccs_create_subdev(struct ccs_sensor *sensor,\n\t\t\t      struct ccs_subdev *ssd, const char *name,\n\t\t\t      unsigned short num_pads, u32 function)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\n\n\tif (!ssd)\n\t\treturn;\n\n\tif (ssd != sensor->src)\n\t\tv4l2_subdev_init(&ssd->sd, &ccs_ops);\n\n\tssd->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tssd->sd.entity.function = function;\n\tssd->sensor = sensor;\n\n\tssd->npads = num_pads;\n\tssd->source_pad = num_pads - 1;\n\n\tv4l2_i2c_subdev_set_name(&ssd->sd, client, sensor->minfo.name, name);\n\n\tccs_get_native_size(ssd, &ssd->sink_fmt);\n\n\tssd->compose.width = ssd->sink_fmt.width;\n\tssd->compose.height = ssd->sink_fmt.height;\n\tssd->crop[ssd->source_pad] = ssd->compose;\n\tssd->pads[ssd->source_pad].flags = MEDIA_PAD_FL_SOURCE;\n\tif (ssd != sensor->pixel_array) {\n\t\tssd->crop[ssd->sink_pad] = ssd->compose;\n\t\tssd->pads[ssd->sink_pad].flags = MEDIA_PAD_FL_SINK;\n\t}\n\n\tssd->sd.entity.ops = &ccs_entity_ops;\n\n\tif (ssd == sensor->src)\n\t\treturn;\n\n\tssd->sd.internal_ops = &ccs_internal_ops;\n\tssd->sd.owner = THIS_MODULE;\n\tssd->sd.dev = &client->dev;\n\tv4l2_set_subdevdata(&ssd->sd, client);\n}\n\nstatic int ccs_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct ccs_subdev *ssd = to_ccs_subdev(sd);\n\tstruct ccs_sensor *sensor = ssd->sensor;\n\tunsigned int i;\n\n\tmutex_lock(&sensor->mutex);\n\n\tfor (i = 0; i < ssd->npads; i++) {\n\t\tstruct v4l2_mbus_framefmt *try_fmt =\n\t\t\tv4l2_subdev_get_try_format(sd, fh->state, i);\n\t\tstruct v4l2_rect *try_crop =\n\t\t\tv4l2_subdev_get_try_crop(sd, fh->state, i);\n\t\tstruct v4l2_rect *try_comp;\n\n\t\tccs_get_native_size(ssd, try_crop);\n\n\t\ttry_fmt->width = try_crop->width;\n\t\ttry_fmt->height = try_crop->height;\n\t\ttry_fmt->code = sensor->internal_csi_format->code;\n\t\ttry_fmt->field = V4L2_FIELD_NONE;\n\n\t\tif (ssd == sensor->pixel_array)\n\t\t\tcontinue;\n\n\t\ttry_comp = v4l2_subdev_get_try_compose(sd, fh->state, i);\n\t\t*try_comp = *try_crop;\n\t}\n\n\tmutex_unlock(&sensor->mutex);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops ccs_video_ops = {\n\t.s_stream = ccs_set_stream,\n\t.pre_streamon = ccs_pre_streamon,\n\t.post_streamoff = ccs_post_streamoff,\n};\n\nstatic const struct v4l2_subdev_pad_ops ccs_pad_ops = {\n\t.enum_mbus_code = ccs_enum_mbus_code,\n\t.get_fmt = ccs_get_format,\n\t.set_fmt = ccs_set_format,\n\t.get_selection = ccs_get_selection,\n\t.set_selection = ccs_set_selection,\n};\n\nstatic const struct v4l2_subdev_sensor_ops ccs_sensor_ops = {\n\t.g_skip_frames = ccs_get_skip_frames,\n\t.g_skip_top_lines = ccs_get_skip_top_lines,\n};\n\nstatic const struct v4l2_subdev_ops ccs_ops = {\n\t.video = &ccs_video_ops,\n\t.pad = &ccs_pad_ops,\n\t.sensor = &ccs_sensor_ops,\n};\n\nstatic const struct media_entity_operations ccs_entity_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic const struct v4l2_subdev_internal_ops ccs_internal_src_ops = {\n\t.registered = ccs_registered,\n\t.unregistered = ccs_unregistered,\n\t.open = ccs_open,\n};\n\nstatic const struct v4l2_subdev_internal_ops ccs_internal_ops = {\n\t.open = ccs_open,\n};\n\n \n\nstatic int __maybe_unused ccs_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tbool streaming = sensor->streaming;\n\tint rval;\n\n\trval = pm_runtime_resume_and_get(dev);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tif (sensor->streaming)\n\t\tccs_stop_streaming(sensor);\n\n\t \n\tsensor->streaming = streaming;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ccs_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tint rval = 0;\n\n\tpm_runtime_put(dev);\n\n\tif (sensor->streaming)\n\t\trval = ccs_start_streaming(sensor);\n\n\treturn rval;\n}\n\nstatic int ccs_get_hwconfig(struct ccs_sensor *sensor, struct device *dev)\n{\n\tstruct ccs_hwconfig *hwcfg = &sensor->hwcfg;\n\tstruct v4l2_fwnode_endpoint bus_cfg = { .bus_type = V4L2_MBUS_UNKNOWN };\n\tstruct fwnode_handle *ep;\n\tstruct fwnode_handle *fwnode = dev_fwnode(dev);\n\tunsigned int i;\n\tint rval;\n\n\tep = fwnode_graph_get_endpoint_by_id(fwnode, 0, 0,\n\t\t\t\t\t     FWNODE_GRAPH_ENDPOINT_NEXT);\n\tif (!ep)\n\t\treturn -ENODEV;\n\n\t \n\trval = v4l2_fwnode_endpoint_alloc_parse(ep, &bus_cfg);\n\tif (rval)\n\t\tgoto out_err;\n\n\tswitch (bus_cfg.bus_type) {\n\tcase V4L2_MBUS_CSI2_DPHY:\n\t\thwcfg->csi_signalling_mode = CCS_CSI_SIGNALING_MODE_CSI_2_DPHY;\n\t\thwcfg->lanes = bus_cfg.bus.mipi_csi2.num_data_lanes;\n\t\tbreak;\n\tcase V4L2_MBUS_CSI2_CPHY:\n\t\thwcfg->csi_signalling_mode = CCS_CSI_SIGNALING_MODE_CSI_2_CPHY;\n\t\thwcfg->lanes = bus_cfg.bus.mipi_csi2.num_data_lanes;\n\t\tbreak;\n\tcase V4L2_MBUS_CSI1:\n\tcase V4L2_MBUS_CCP2:\n\t\thwcfg->csi_signalling_mode = (bus_cfg.bus.mipi_csi1.strobe) ?\n\t\tSMIAPP_CSI_SIGNALLING_MODE_CCP2_DATA_STROBE :\n\t\tSMIAPP_CSI_SIGNALLING_MODE_CCP2_DATA_CLOCK;\n\t\thwcfg->lanes = 1;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported bus %u\\n\", bus_cfg.bus_type);\n\t\trval = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\trval = fwnode_property_read_u32(dev_fwnode(dev), \"clock-frequency\",\n\t\t\t\t\t&hwcfg->ext_clk);\n\tif (rval)\n\t\tdev_info(dev, \"can't get clock-frequency\\n\");\n\n\tdev_dbg(dev, \"clk %u, mode %u\\n\", hwcfg->ext_clk,\n\t\thwcfg->csi_signalling_mode);\n\n\tif (!bus_cfg.nr_of_link_frequencies) {\n\t\tdev_warn(dev, \"no link frequencies defined\\n\");\n\t\trval = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\thwcfg->op_sys_clock = devm_kcalloc(\n\t\tdev, bus_cfg.nr_of_link_frequencies + 1  ,\n\t\tsizeof(*hwcfg->op_sys_clock), GFP_KERNEL);\n\tif (!hwcfg->op_sys_clock) {\n\t\trval = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tfor (i = 0; i < bus_cfg.nr_of_link_frequencies; i++) {\n\t\thwcfg->op_sys_clock[i] = bus_cfg.link_frequencies[i];\n\t\tdev_dbg(dev, \"freq %u: %lld\\n\", i, hwcfg->op_sys_clock[i]);\n\t}\n\n\tv4l2_fwnode_endpoint_free(&bus_cfg);\n\tfwnode_handle_put(ep);\n\n\treturn 0;\n\nout_err:\n\tv4l2_fwnode_endpoint_free(&bus_cfg);\n\tfwnode_handle_put(ep);\n\n\treturn rval;\n}\n\nstatic int ccs_firmware_name(struct i2c_client *client,\n\t\t\t     struct ccs_sensor *sensor, char *filename,\n\t\t\t     size_t filename_size, bool is_module)\n{\n\tconst struct ccs_device *ccsdev = device_get_match_data(&client->dev);\n\tbool is_ccs = !(ccsdev->flags & CCS_DEVICE_FLAG_IS_SMIA);\n\tbool is_smiapp = sensor->minfo.smiapp_version;\n\tu16 manufacturer_id;\n\tu16 model_id;\n\tu16 revision_number;\n\n\t \n\tif (is_module || (!is_ccs && !is_smiapp)) {\n\t\tmanufacturer_id = is_ccs ?\n\t\t\tsensor->minfo.mipi_manufacturer_id :\n\t\t\tsensor->minfo.smia_manufacturer_id;\n\t\tmodel_id = sensor->minfo.model_id;\n\t\trevision_number = sensor->minfo.revision_number;\n\t} else {\n\t\tmanufacturer_id = is_ccs ?\n\t\t\tsensor->minfo.sensor_mipi_manufacturer_id :\n\t\t\tsensor->minfo.sensor_smia_manufacturer_id;\n\t\tmodel_id = sensor->minfo.sensor_model_id;\n\t\trevision_number = sensor->minfo.sensor_revision_number;\n\t}\n\n\treturn snprintf(filename, filename_size,\n\t\t\t\"ccs/%s-%s-%0*x-%4.4x-%0*x.fw\",\n\t\t\tis_ccs ? \"ccs\" : is_smiapp ? \"smiapp\" : \"smia\",\n\t\t\tis_module || (!is_ccs && !is_smiapp) ?\n\t\t\t\t\"module\" : \"sensor\",\n\t\t\tis_ccs ? 4 : 2, manufacturer_id, model_id,\n\t\t\t!is_ccs && !is_module ? 2 : 4, revision_number);\n}\n\nstatic int ccs_probe(struct i2c_client *client)\n{\n\tconst struct ccs_device *ccsdev = device_get_match_data(&client->dev);\n\tstruct ccs_sensor *sensor;\n\tconst struct firmware *fw;\n\tchar filename[40];\n\tunsigned int i;\n\tint rval;\n\n\tsensor = devm_kzalloc(&client->dev, sizeof(*sensor), GFP_KERNEL);\n\tif (sensor == NULL)\n\t\treturn -ENOMEM;\n\n\trval = ccs_get_hwconfig(sensor, &client->dev);\n\tif (rval)\n\t\treturn rval;\n\n\tsensor->src = &sensor->ssds[sensor->ssds_used];\n\n\tv4l2_i2c_subdev_init(&sensor->src->sd, client, &ccs_ops);\n\tsensor->src->sd.internal_ops = &ccs_internal_src_ops;\n\n\tsensor->regulators = devm_kcalloc(&client->dev,\n\t\t\t\t\t  ARRAY_SIZE(ccs_regulators),\n\t\t\t\t\t  sizeof(*sensor->regulators),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!sensor->regulators)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(ccs_regulators); i++)\n\t\tsensor->regulators[i].supply = ccs_regulators[i];\n\n\trval = devm_regulator_bulk_get(&client->dev, ARRAY_SIZE(ccs_regulators),\n\t\t\t\t       sensor->regulators);\n\tif (rval) {\n\t\tdev_err(&client->dev, \"could not get regulators\\n\");\n\t\treturn rval;\n\t}\n\n\tsensor->ext_clk = devm_clk_get(&client->dev, NULL);\n\tif (PTR_ERR(sensor->ext_clk) == -ENOENT) {\n\t\tdev_info(&client->dev, \"no clock defined, continuing...\\n\");\n\t\tsensor->ext_clk = NULL;\n\t} else if (IS_ERR(sensor->ext_clk)) {\n\t\tdev_err(&client->dev, \"could not get clock (%ld)\\n\",\n\t\t\tPTR_ERR(sensor->ext_clk));\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tif (sensor->ext_clk) {\n\t\tif (sensor->hwcfg.ext_clk) {\n\t\t\tunsigned long rate;\n\n\t\t\trval = clk_set_rate(sensor->ext_clk,\n\t\t\t\t\t    sensor->hwcfg.ext_clk);\n\t\t\tif (rval < 0) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"unable to set clock freq to %u\\n\",\n\t\t\t\t\tsensor->hwcfg.ext_clk);\n\t\t\t\treturn rval;\n\t\t\t}\n\n\t\t\trate = clk_get_rate(sensor->ext_clk);\n\t\t\tif (rate != sensor->hwcfg.ext_clk) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"can't set clock freq, asked for %u but got %lu\\n\",\n\t\t\t\t\tsensor->hwcfg.ext_clk, rate);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tsensor->hwcfg.ext_clk = clk_get_rate(sensor->ext_clk);\n\t\t\tdev_dbg(&client->dev, \"obtained clock freq %u\\n\",\n\t\t\t\tsensor->hwcfg.ext_clk);\n\t\t}\n\t} else if (sensor->hwcfg.ext_clk) {\n\t\tdev_dbg(&client->dev, \"assuming clock freq %u\\n\",\n\t\t\tsensor->hwcfg.ext_clk);\n\t} else {\n\t\tdev_err(&client->dev, \"unable to obtain clock freq\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!sensor->hwcfg.ext_clk) {\n\t\tdev_err(&client->dev, \"cannot work with xclk frequency 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsensor->reset = devm_gpiod_get_optional(&client->dev, \"reset\",\n\t\t\t\t\t\tGPIOD_OUT_HIGH);\n\tif (IS_ERR(sensor->reset))\n\t\treturn PTR_ERR(sensor->reset);\n\t \n\tif (!sensor->reset)\n\t\tsensor->xshutdown = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t\t    \"xshutdown\",\n\t\t\t\t\t\t\t    GPIOD_OUT_LOW);\n\tif (IS_ERR(sensor->xshutdown))\n\t\treturn PTR_ERR(sensor->xshutdown);\n\n\trval = ccs_power_on(&client->dev);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tmutex_init(&sensor->mutex);\n\n\trval = ccs_identify_module(sensor);\n\tif (rval) {\n\t\trval = -ENODEV;\n\t\tgoto out_power_off;\n\t}\n\n\trval = ccs_firmware_name(client, sensor, filename, sizeof(filename),\n\t\t\t\t false);\n\tif (rval >= sizeof(filename)) {\n\t\trval = -ENOMEM;\n\t\tgoto out_power_off;\n\t}\n\n\trval = request_firmware(&fw, filename, &client->dev);\n\tif (!rval) {\n\t\tccs_data_parse(&sensor->sdata, fw->data, fw->size, &client->dev,\n\t\t\t       true);\n\t\trelease_firmware(fw);\n\t}\n\n\tif (!(ccsdev->flags & CCS_DEVICE_FLAG_IS_SMIA) ||\n\t    sensor->minfo.smiapp_version) {\n\t\trval = ccs_firmware_name(client, sensor, filename,\n\t\t\t\t\t sizeof(filename), true);\n\t\tif (rval >= sizeof(filename)) {\n\t\t\trval = -ENOMEM;\n\t\t\tgoto out_release_sdata;\n\t\t}\n\n\t\trval = request_firmware(&fw, filename, &client->dev);\n\t\tif (!rval) {\n\t\t\tccs_data_parse(&sensor->mdata, fw->data, fw->size,\n\t\t\t\t       &client->dev, true);\n\t\t\trelease_firmware(fw);\n\t\t}\n\t}\n\n\trval = ccs_read_all_limits(sensor);\n\tif (rval)\n\t\tgoto out_release_mdata;\n\n\trval = ccs_read_frame_fmt(sensor);\n\tif (rval) {\n\t\trval = -ENODEV;\n\t\tgoto out_free_ccs_limits;\n\t}\n\n\trval = ccs_update_phy_ctrl(sensor);\n\tif (rval < 0)\n\t\tgoto out_free_ccs_limits;\n\n\trval = ccs_call_quirk(sensor, limits);\n\tif (rval) {\n\t\tdev_err(&client->dev, \"limits quirks failed\\n\");\n\t\tgoto out_free_ccs_limits;\n\t}\n\n\tif (CCS_LIM(sensor, BINNING_CAPABILITY)) {\n\t\tsensor->nbinning_subtypes =\n\t\t\tmin_t(u8, CCS_LIM(sensor, BINNING_SUB_TYPES),\n\t\t\t      CCS_LIM_BINNING_SUB_TYPE_MAX_N);\n\n\t\tfor (i = 0; i < sensor->nbinning_subtypes; i++) {\n\t\t\tsensor->binning_subtypes[i].horizontal =\n\t\t\t\tCCS_LIM_AT(sensor, BINNING_SUB_TYPE, i) >>\n\t\t\t\tCCS_BINNING_SUB_TYPE_COLUMN_SHIFT;\n\t\t\tsensor->binning_subtypes[i].vertical =\n\t\t\t\tCCS_LIM_AT(sensor, BINNING_SUB_TYPE, i) &\n\t\t\t\tCCS_BINNING_SUB_TYPE_ROW_MASK;\n\n\t\t\tdev_dbg(&client->dev, \"binning %xx%x\\n\",\n\t\t\t\tsensor->binning_subtypes[i].horizontal,\n\t\t\t\tsensor->binning_subtypes[i].vertical);\n\t\t}\n\t}\n\tsensor->binning_horizontal = 1;\n\tsensor->binning_vertical = 1;\n\n\tif (device_create_file(&client->dev, &dev_attr_ident) != 0) {\n\t\tdev_err(&client->dev, \"sysfs ident entry creation failed\\n\");\n\t\trval = -ENOENT;\n\t\tgoto out_free_ccs_limits;\n\t}\n\n\tif (sensor->minfo.smiapp_version &&\n\t    CCS_LIM(sensor, DATA_TRANSFER_IF_CAPABILITY) &\n\t    CCS_DATA_TRANSFER_IF_CAPABILITY_SUPPORTED) {\n\t\tif (device_create_file(&client->dev, &dev_attr_nvm) != 0) {\n\t\t\tdev_err(&client->dev, \"sysfs nvm entry failed\\n\");\n\t\t\trval = -EBUSY;\n\t\t\tgoto out_cleanup;\n\t\t}\n\t}\n\n\tif (!CCS_LIM(sensor, MIN_OP_SYS_CLK_DIV) ||\n\t    !CCS_LIM(sensor, MAX_OP_SYS_CLK_DIV) ||\n\t    !CCS_LIM(sensor, MIN_OP_PIX_CLK_DIV) ||\n\t    !CCS_LIM(sensor, MAX_OP_PIX_CLK_DIV)) {\n\t\t \n\t\tsensor->pll.flags |= CCS_PLL_FLAG_NO_OP_CLOCKS;\n\t} else if (CCS_LIM(sensor, SCALING_CAPABILITY)\n\t\t   != CCS_SCALING_CAPABILITY_NONE ||\n\t\t   CCS_LIM(sensor, DIGITAL_CROP_CAPABILITY)\n\t\t   == CCS_DIGITAL_CROP_CAPABILITY_INPUT_CROP) {\n\t\t \n\t\tsensor->scaler = &sensor->ssds[sensor->ssds_used];\n\t\tsensor->ssds_used++;\n\t}\n\tsensor->binner = &sensor->ssds[sensor->ssds_used];\n\tsensor->ssds_used++;\n\tsensor->pixel_array = &sensor->ssds[sensor->ssds_used];\n\tsensor->ssds_used++;\n\n\tsensor->scale_m = CCS_LIM(sensor, SCALER_N_MIN);\n\n\t \n\tsensor->pll.bus_type = CCS_PLL_BUS_TYPE_CSI2_DPHY;\n\tsensor->pll.csi2.lanes = sensor->hwcfg.lanes;\n\tif (CCS_LIM(sensor, CLOCK_CALCULATION) &\n\t    CCS_CLOCK_CALCULATION_LANE_SPEED) {\n\t\tsensor->pll.flags |= CCS_PLL_FLAG_LANE_SPEED_MODEL;\n\t\tif (CCS_LIM(sensor, CLOCK_CALCULATION) &\n\t\t    CCS_CLOCK_CALCULATION_LINK_DECOUPLED) {\n\t\t\tsensor->pll.vt_lanes =\n\t\t\t\tCCS_LIM(sensor, NUM_OF_VT_LANES) + 1;\n\t\t\tsensor->pll.op_lanes =\n\t\t\t\tCCS_LIM(sensor, NUM_OF_OP_LANES) + 1;\n\t\t\tsensor->pll.flags |= CCS_PLL_FLAG_LINK_DECOUPLED;\n\t\t} else {\n\t\t\tsensor->pll.vt_lanes = sensor->pll.csi2.lanes;\n\t\t\tsensor->pll.op_lanes = sensor->pll.csi2.lanes;\n\t\t}\n\t}\n\tif (CCS_LIM(sensor, CLOCK_TREE_PLL_CAPABILITY) &\n\t    CCS_CLOCK_TREE_PLL_CAPABILITY_EXT_DIVIDER)\n\t\tsensor->pll.flags |= CCS_PLL_FLAG_EXT_IP_PLL_DIVIDER;\n\tif (CCS_LIM(sensor, CLOCK_TREE_PLL_CAPABILITY) &\n\t    CCS_CLOCK_TREE_PLL_CAPABILITY_FLEXIBLE_OP_PIX_CLK_DIV)\n\t\tsensor->pll.flags |= CCS_PLL_FLAG_FLEXIBLE_OP_PIX_CLK_DIV;\n\tif (CCS_LIM(sensor, FIFO_SUPPORT_CAPABILITY) &\n\t    CCS_FIFO_SUPPORT_CAPABILITY_DERATING)\n\t\tsensor->pll.flags |= CCS_PLL_FLAG_FIFO_DERATING;\n\tif (CCS_LIM(sensor, FIFO_SUPPORT_CAPABILITY) &\n\t    CCS_FIFO_SUPPORT_CAPABILITY_DERATING_OVERRATING)\n\t\tsensor->pll.flags |= CCS_PLL_FLAG_FIFO_DERATING |\n\t\t\t\t     CCS_PLL_FLAG_FIFO_OVERRATING;\n\tif (CCS_LIM(sensor, CLOCK_TREE_PLL_CAPABILITY) &\n\t    CCS_CLOCK_TREE_PLL_CAPABILITY_DUAL_PLL) {\n\t\tif (CCS_LIM(sensor, CLOCK_TREE_PLL_CAPABILITY) &\n\t\t    CCS_CLOCK_TREE_PLL_CAPABILITY_SINGLE_PLL) {\n\t\t\tu32 v;\n\n\t\t\t \n\t\t\trval = ccs_read(sensor, PLL_MODE, &v);\n\t\t\tif (rval)\n\t\t\t\tgoto out_cleanup;\n\n\t\t\tif (v == CCS_PLL_MODE_DUAL)\n\t\t\t\tsensor->pll.flags |= CCS_PLL_FLAG_DUAL_PLL;\n\t\t} else {\n\t\t\tsensor->pll.flags |= CCS_PLL_FLAG_DUAL_PLL;\n\t\t}\n\t\tif (CCS_LIM(sensor, CLOCK_CALCULATION) &\n\t\t    CCS_CLOCK_CALCULATION_DUAL_PLL_OP_SYS_DDR)\n\t\t\tsensor->pll.flags |= CCS_PLL_FLAG_OP_SYS_DDR;\n\t\tif (CCS_LIM(sensor, CLOCK_CALCULATION) &\n\t\t    CCS_CLOCK_CALCULATION_DUAL_PLL_OP_PIX_DDR)\n\t\t\tsensor->pll.flags |= CCS_PLL_FLAG_OP_PIX_DDR;\n\t}\n\tsensor->pll.op_bits_per_lane = CCS_LIM(sensor, OP_BITS_PER_LANE);\n\tsensor->pll.ext_clk_freq_hz = sensor->hwcfg.ext_clk;\n\tsensor->pll.scale_n = CCS_LIM(sensor, SCALER_N_MIN);\n\n\tccs_create_subdev(sensor, sensor->scaler, \" scaler\", 2,\n\t\t\t  MEDIA_ENT_F_PROC_VIDEO_SCALER);\n\tccs_create_subdev(sensor, sensor->binner, \" binner\", 2,\n\t\t\t  MEDIA_ENT_F_PROC_VIDEO_SCALER);\n\tccs_create_subdev(sensor, sensor->pixel_array, \" pixel_array\", 1,\n\t\t\t  MEDIA_ENT_F_CAM_SENSOR);\n\n\trval = ccs_init_controls(sensor);\n\tif (rval < 0)\n\t\tgoto out_cleanup;\n\n\trval = ccs_call_quirk(sensor, init);\n\tif (rval)\n\t\tgoto out_cleanup;\n\n\trval = ccs_get_mbus_formats(sensor);\n\tif (rval) {\n\t\trval = -ENODEV;\n\t\tgoto out_cleanup;\n\t}\n\n\trval = ccs_init_late_controls(sensor);\n\tif (rval) {\n\t\trval = -ENODEV;\n\t\tgoto out_cleanup;\n\t}\n\n\tmutex_lock(&sensor->mutex);\n\trval = ccs_pll_blanking_update(sensor);\n\tmutex_unlock(&sensor->mutex);\n\tif (rval) {\n\t\tdev_err(&client->dev, \"update mode failed\\n\");\n\t\tgoto out_cleanup;\n\t}\n\n\tsensor->streaming = false;\n\tsensor->dev_init_done = true;\n\n\trval = media_entity_pads_init(&sensor->src->sd.entity, 2,\n\t\t\t\t sensor->src->pads);\n\tif (rval < 0)\n\t\tgoto out_media_entity_cleanup;\n\n\trval = ccs_write_msr_regs(sensor);\n\tif (rval)\n\t\tgoto out_media_entity_cleanup;\n\n\tpm_runtime_set_active(&client->dev);\n\tpm_runtime_get_noresume(&client->dev);\n\tpm_runtime_enable(&client->dev);\n\n\trval = v4l2_async_register_subdev_sensor(&sensor->src->sd);\n\tif (rval < 0)\n\t\tgoto out_disable_runtime_pm;\n\n\tpm_runtime_set_autosuspend_delay(&client->dev, 1000);\n\tpm_runtime_use_autosuspend(&client->dev);\n\tpm_runtime_put_autosuspend(&client->dev);\n\n\treturn 0;\n\nout_disable_runtime_pm:\n\tpm_runtime_put_noidle(&client->dev);\n\tpm_runtime_disable(&client->dev);\n\nout_media_entity_cleanup:\n\tmedia_entity_cleanup(&sensor->src->sd.entity);\n\nout_cleanup:\n\tccs_cleanup(sensor);\n\nout_release_mdata:\n\tkvfree(sensor->mdata.backing);\n\nout_release_sdata:\n\tkvfree(sensor->sdata.backing);\n\nout_free_ccs_limits:\n\tkfree(sensor->ccs_limits);\n\nout_power_off:\n\tccs_power_off(&client->dev);\n\tmutex_destroy(&sensor->mutex);\n\n\treturn rval;\n}\n\nstatic void ccs_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct ccs_sensor *sensor = to_ccs_sensor(subdev);\n\tunsigned int i;\n\n\tv4l2_async_unregister_subdev(subdev);\n\n\tpm_runtime_disable(&client->dev);\n\tif (!pm_runtime_status_suspended(&client->dev))\n\t\tccs_power_off(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\n\tfor (i = 0; i < sensor->ssds_used; i++) {\n\t\tv4l2_device_unregister_subdev(&sensor->ssds[i].sd);\n\t\tmedia_entity_cleanup(&sensor->ssds[i].sd.entity);\n\t}\n\tccs_cleanup(sensor);\n\tmutex_destroy(&sensor->mutex);\n\tkfree(sensor->ccs_limits);\n\tkvfree(sensor->sdata.backing);\n\tkvfree(sensor->mdata.backing);\n}\n\nstatic const struct ccs_device smia_device = {\n\t.flags = CCS_DEVICE_FLAG_IS_SMIA,\n};\n\nstatic const struct ccs_device ccs_device = {};\n\nstatic const struct acpi_device_id ccs_acpi_table[] = {\n\t{ .id = \"MIPI0200\", .driver_data = (unsigned long)&ccs_device },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, ccs_acpi_table);\n\nstatic const struct of_device_id ccs_of_table[] = {\n\t{ .compatible = \"mipi-ccs-1.1\", .data = &ccs_device },\n\t{ .compatible = \"mipi-ccs-1.0\", .data = &ccs_device },\n\t{ .compatible = \"mipi-ccs\", .data = &ccs_device },\n\t{ .compatible = \"nokia,smia\", .data = &smia_device },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ccs_of_table);\n\nstatic const struct dev_pm_ops ccs_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(ccs_suspend, ccs_resume)\n\tSET_RUNTIME_PM_OPS(ccs_power_off, ccs_power_on, NULL)\n};\n\nstatic struct i2c_driver ccs_i2c_driver = {\n\t.driver\t= {\n\t\t.acpi_match_table = ccs_acpi_table,\n\t\t.of_match_table = ccs_of_table,\n\t\t.name = CCS_NAME,\n\t\t.pm = &ccs_pm_ops,\n\t},\n\t.probe = ccs_probe,\n\t.remove\t= ccs_remove,\n};\n\nstatic int ccs_module_init(void)\n{\n\tunsigned int i, l;\n\n\tfor (i = 0, l = 0; ccs_limits[i].size && l < CCS_L_LAST; i++) {\n\t\tif (!(ccs_limits[i].flags & CCS_L_FL_SAME_REG)) {\n\t\t\tccs_limit_offsets[l + 1].lim =\n\t\t\t\tALIGN(ccs_limit_offsets[l].lim +\n\t\t\t\t      ccs_limits[i].size,\n\t\t\t\t      ccs_reg_width(ccs_limits[i + 1].reg));\n\t\t\tccs_limit_offsets[l].info = i;\n\t\t\tl++;\n\t\t} else {\n\t\t\tccs_limit_offsets[l].lim += ccs_limits[i].size;\n\t\t}\n\t}\n\n\tif (WARN_ON(ccs_limits[i].size))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(l != CCS_L_LAST))\n\t\treturn -EINVAL;\n\n\treturn i2c_register_driver(THIS_MODULE, &ccs_i2c_driver);\n}\n\nstatic void ccs_module_cleanup(void)\n{\n\ti2c_del_driver(&ccs_i2c_driver);\n}\n\nmodule_init(ccs_module_init);\nmodule_exit(ccs_module_cleanup);\n\nMODULE_AUTHOR(\"Sakari Ailus <sakari.ailus@linux.intel.com>\");\nMODULE_DESCRIPTION(\"Generic MIPI CCS/SMIA/SMIA++ camera sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"smiapp\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}