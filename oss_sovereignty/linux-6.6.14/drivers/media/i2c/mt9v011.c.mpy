{
  "module_name": "mt9v011.c",
  "hash_id": "efa48678978458e5cc276aa8061472f38bcd9876f61f031fde0a4df61a0ba32e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/mt9v011.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <asm/div64.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n#include <media/i2c/mt9v011.h>\n\nMODULE_DESCRIPTION(\"Micron mt9v011 sensor driver\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab\");\nMODULE_LICENSE(\"GPL v2\");\n\nstatic int debug;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"Debug level (0-2)\");\n\n#define R00_MT9V011_CHIP_VERSION\t0x00\n#define R01_MT9V011_ROWSTART\t\t0x01\n#define R02_MT9V011_COLSTART\t\t0x02\n#define R03_MT9V011_HEIGHT\t\t0x03\n#define R04_MT9V011_WIDTH\t\t0x04\n#define R05_MT9V011_HBLANK\t\t0x05\n#define R06_MT9V011_VBLANK\t\t0x06\n#define R07_MT9V011_OUT_CTRL\t\t0x07\n#define R09_MT9V011_SHUTTER_WIDTH\t0x09\n#define R0A_MT9V011_CLK_SPEED\t\t0x0a\n#define R0B_MT9V011_RESTART\t\t0x0b\n#define R0C_MT9V011_SHUTTER_DELAY\t0x0c\n#define R0D_MT9V011_RESET\t\t0x0d\n#define R1E_MT9V011_DIGITAL_ZOOM\t0x1e\n#define R20_MT9V011_READ_MODE\t\t0x20\n#define R2B_MT9V011_GREEN_1_GAIN\t0x2b\n#define R2C_MT9V011_BLUE_GAIN\t\t0x2c\n#define R2D_MT9V011_RED_GAIN\t\t0x2d\n#define R2E_MT9V011_GREEN_2_GAIN\t0x2e\n#define R35_MT9V011_GLOBAL_GAIN\t\t0x35\n#define RF1_MT9V011_CHIP_ENABLE\t\t0xf1\n\n#define MT9V011_VERSION\t\t\t0x8232\n#define MT9V011_REV_B_VERSION\t\t0x8243\n\nstruct mt9v011 {\n\tstruct v4l2_subdev sd;\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tstruct media_pad pad;\n#endif\n\tstruct v4l2_ctrl_handler ctrls;\n\tunsigned width, height;\n\tunsigned xtal;\n\tunsigned hflip:1;\n\tunsigned vflip:1;\n\n\tu16 global_gain, exposure;\n\ts16 red_bal, blue_bal;\n};\n\nstatic inline struct mt9v011 *to_mt9v011(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct mt9v011, sd);\n}\n\nstatic int mt9v011_read(struct v4l2_subdev *sd, unsigned char addr)\n{\n\tstruct i2c_client *c = v4l2_get_subdevdata(sd);\n\t__be16 buffer;\n\tint rc, val;\n\n\trc = i2c_master_send(c, &addr, 1);\n\tif (rc != 1)\n\t\tv4l2_dbg(0, debug, sd,\n\t\t\t \"i2c i/o error: rc == %d (should be 1)\\n\", rc);\n\n\tmsleep(10);\n\n\trc = i2c_master_recv(c, (char *)&buffer, 2);\n\tif (rc != 2)\n\t\tv4l2_dbg(0, debug, sd,\n\t\t\t \"i2c i/o error: rc == %d (should be 2)\\n\", rc);\n\n\tval = be16_to_cpu(buffer);\n\n\tv4l2_dbg(2, debug, sd, \"mt9v011: read 0x%02x = 0x%04x\\n\", addr, val);\n\n\treturn val;\n}\n\nstatic void mt9v011_write(struct v4l2_subdev *sd, unsigned char addr,\n\t\t\t\t u16 value)\n{\n\tstruct i2c_client *c = v4l2_get_subdevdata(sd);\n\tunsigned char buffer[3];\n\tint rc;\n\n\tbuffer[0] = addr;\n\tbuffer[1] = value >> 8;\n\tbuffer[2] = value & 0xff;\n\n\tv4l2_dbg(2, debug, sd,\n\t\t \"mt9v011: writing 0x%02x 0x%04x\\n\", buffer[0], value);\n\trc = i2c_master_send(c, buffer, 3);\n\tif (rc != 3)\n\t\tv4l2_dbg(0, debug, sd,\n\t\t\t \"i2c i/o error: rc == %d (should be 3)\\n\", rc);\n}\n\n\nstruct i2c_reg_value {\n\tunsigned char reg;\n\tu16           value;\n};\n\n \nstatic const struct i2c_reg_value mt9v011_init_default[] = {\n\t\t{ R0D_MT9V011_RESET, 0x0001 },\n\t\t{ R0D_MT9V011_RESET, 0x0000 },\n\n\t\t{ R0C_MT9V011_SHUTTER_DELAY, 0x0000 },\n\t\t{ R09_MT9V011_SHUTTER_WIDTH, 0x1fc },\n\n\t\t{ R0A_MT9V011_CLK_SPEED, 0x0000 },\n\t\t{ R1E_MT9V011_DIGITAL_ZOOM,  0x0000 },\n\n\t\t{ R07_MT9V011_OUT_CTRL, 0x0002 },\t \n};\n\n\nstatic u16 calc_mt9v011_gain(s16 lineargain)\n{\n\n\tu16 digitalgain = 0;\n\tu16 analogmult = 0;\n\tu16 analoginit = 0;\n\n\tif (lineargain < 0)\n\t\tlineargain = 0;\n\n\t \n\tlineargain += 0x0020;\n\n\tif (lineargain > 2047)\n\t\tlineargain = 2047;\n\n\tif (lineargain > 1023) {\n\t\tdigitalgain = 3;\n\t\tanalogmult = 3;\n\t\tanaloginit = lineargain / 16;\n\t} else if (lineargain > 511) {\n\t\tdigitalgain = 1;\n\t\tanalogmult = 3;\n\t\tanaloginit = lineargain / 8;\n\t} else if (lineargain > 255) {\n\t\tanalogmult = 3;\n\t\tanaloginit = lineargain / 4;\n\t} else if (lineargain > 127) {\n\t\tanalogmult = 1;\n\t\tanaloginit = lineargain / 2;\n\t} else\n\t\tanaloginit = lineargain;\n\n\treturn analoginit + (analogmult << 7) + (digitalgain << 9);\n\n}\n\nstatic void set_balance(struct v4l2_subdev *sd)\n{\n\tstruct mt9v011 *core = to_mt9v011(sd);\n\tu16 green_gain, blue_gain, red_gain;\n\tu16 exposure;\n\ts16 bal;\n\n\texposure = core->exposure;\n\n\tgreen_gain = calc_mt9v011_gain(core->global_gain);\n\n\tbal = core->global_gain;\n\tbal += (core->blue_bal * core->global_gain / (1 << 7));\n\tblue_gain = calc_mt9v011_gain(bal);\n\n\tbal = core->global_gain;\n\tbal += (core->red_bal * core->global_gain / (1 << 7));\n\tred_gain = calc_mt9v011_gain(bal);\n\n\tmt9v011_write(sd, R2B_MT9V011_GREEN_1_GAIN, green_gain);\n\tmt9v011_write(sd, R2E_MT9V011_GREEN_2_GAIN, green_gain);\n\tmt9v011_write(sd, R2C_MT9V011_BLUE_GAIN, blue_gain);\n\tmt9v011_write(sd, R2D_MT9V011_RED_GAIN, red_gain);\n\tmt9v011_write(sd, R09_MT9V011_SHUTTER_WIDTH, exposure);\n}\n\nstatic void calc_fps(struct v4l2_subdev *sd, u32 *numerator, u32 *denominator)\n{\n\tstruct mt9v011 *core = to_mt9v011(sd);\n\tunsigned height, width, hblank, vblank, speed;\n\tunsigned row_time, t_time;\n\tu64 frames_per_ms;\n\tunsigned tmp;\n\n\theight = mt9v011_read(sd, R03_MT9V011_HEIGHT);\n\twidth = mt9v011_read(sd, R04_MT9V011_WIDTH);\n\thblank = mt9v011_read(sd, R05_MT9V011_HBLANK);\n\tvblank = mt9v011_read(sd, R06_MT9V011_VBLANK);\n\tspeed = mt9v011_read(sd, R0A_MT9V011_CLK_SPEED);\n\n\trow_time = (width + 113 + hblank) * (speed + 2);\n\tt_time = row_time * (height + vblank + 1);\n\n\tframes_per_ms = core->xtal * 1000l;\n\tdo_div(frames_per_ms, t_time);\n\ttmp = frames_per_ms;\n\n\tv4l2_dbg(1, debug, sd, \"Programmed to %u.%03u fps (%d pixel clcks)\\n\",\n\t\ttmp / 1000, tmp % 1000, t_time);\n\n\tif (numerator && denominator) {\n\t\t*numerator = 1000;\n\t\t*denominator = (u32)frames_per_ms;\n\t}\n}\n\nstatic u16 calc_speed(struct v4l2_subdev *sd, u32 numerator, u32 denominator)\n{\n\tstruct mt9v011 *core = to_mt9v011(sd);\n\tunsigned height, width, hblank, vblank;\n\tunsigned row_time, line_time;\n\tu64 t_time, speed;\n\n\t \n\tif (!numerator || !denominator)\n\t\treturn 0;\n\n\theight = mt9v011_read(sd, R03_MT9V011_HEIGHT);\n\twidth = mt9v011_read(sd, R04_MT9V011_WIDTH);\n\thblank = mt9v011_read(sd, R05_MT9V011_HBLANK);\n\tvblank = mt9v011_read(sd, R06_MT9V011_VBLANK);\n\n\trow_time = width + 113 + hblank;\n\tline_time = height + vblank + 1;\n\n\tt_time = core->xtal * ((u64)numerator);\n\t \n\tt_time += denominator / 2;\n\tdo_div(t_time, denominator);\n\n\tspeed = t_time;\n\tdo_div(speed, row_time * line_time);\n\n\t \n\tif (speed < 2)\n\t\tspeed = 0;\n\telse\n\t\tspeed -= 2;\n\n\t \n\tif (speed > 15)\n\t\treturn 15;\n\n\treturn (u16)speed;\n}\n\nstatic void set_res(struct v4l2_subdev *sd)\n{\n\tstruct mt9v011 *core = to_mt9v011(sd);\n\tunsigned vstart, hstart;\n\n\t \n\n\thstart = 20 + (640 - core->width) / 2;\n\tmt9v011_write(sd, R02_MT9V011_COLSTART, hstart);\n\tmt9v011_write(sd, R04_MT9V011_WIDTH, core->width);\n\tmt9v011_write(sd, R05_MT9V011_HBLANK, 771 - core->width);\n\n\tvstart = 8 + (480 - core->height) / 2;\n\tmt9v011_write(sd, R01_MT9V011_ROWSTART, vstart);\n\tmt9v011_write(sd, R03_MT9V011_HEIGHT, core->height);\n\tmt9v011_write(sd, R06_MT9V011_VBLANK, 508 - core->height);\n\n\tcalc_fps(sd, NULL, NULL);\n};\n\nstatic void set_read_mode(struct v4l2_subdev *sd)\n{\n\tstruct mt9v011 *core = to_mt9v011(sd);\n\tunsigned mode = 0x1000;\n\n\tif (core->hflip)\n\t\tmode |= 0x4000;\n\n\tif (core->vflip)\n\t\tmode |= 0x8000;\n\n\tmt9v011_write(sd, R20_MT9V011_READ_MODE, mode);\n}\n\nstatic int mt9v011_reset(struct v4l2_subdev *sd, u32 val)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mt9v011_init_default); i++)\n\t\tmt9v011_write(sd, mt9v011_init_default[i].reg,\n\t\t\t       mt9v011_init_default[i].value);\n\n\tset_balance(sd);\n\tset_res(sd);\n\tset_read_mode(sd);\n\n\treturn 0;\n}\n\nstatic int mt9v011_enum_mbus_code(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index > 0)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_SGRBG8_1X8;\n\treturn 0;\n}\n\nstatic int mt9v011_set_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *fmt = &format->format;\n\tstruct mt9v011 *core = to_mt9v011(sd);\n\n\tif (format->pad || fmt->code != MEDIA_BUS_FMT_SGRBG8_1X8)\n\t\treturn -EINVAL;\n\n\tv4l_bound_align_image(&fmt->width, 48, 639, 1,\n\t\t\t      &fmt->height, 32, 480, 1, 0);\n\tfmt->field = V4L2_FIELD_NONE;\n\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\tcore->width = fmt->width;\n\t\tcore->height = fmt->height;\n\n\t\tset_res(sd);\n\t} else {\n\t\tsd_state->pads->try_fmt = *fmt;\n\t}\n\n\treturn 0;\n}\n\nstatic int mt9v011_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_frame_interval *ival)\n{\n\tcalc_fps(sd,\n\t\t &ival->interval.numerator,\n\t\t &ival->interval.denominator);\n\n\treturn 0;\n}\n\nstatic int mt9v011_s_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_frame_interval *ival)\n{\n\tstruct v4l2_fract *tpf = &ival->interval;\n\tu16 speed;\n\n\tspeed = calc_speed(sd, tpf->numerator, tpf->denominator);\n\n\tmt9v011_write(sd, R0A_MT9V011_CLK_SPEED, speed);\n\tv4l2_dbg(1, debug, sd, \"Setting speed to %d\\n\", speed);\n\n\t \n\tcalc_fps(sd, &tpf->numerator, &tpf->denominator);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int mt9v011_g_register(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_dbg_register *reg)\n{\n\treg->val = mt9v011_read(sd, reg->reg & 0xff);\n\treg->size = 2;\n\n\treturn 0;\n}\n\nstatic int mt9v011_s_register(struct v4l2_subdev *sd,\n\t\t\t      const struct v4l2_dbg_register *reg)\n{\n\tmt9v011_write(sd, reg->reg & 0xff, reg->val & 0xffff);\n\n\treturn 0;\n}\n#endif\n\nstatic int mt9v011_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct mt9v011 *core =\n\t\tcontainer_of(ctrl->handler, struct mt9v011, ctrls);\n\tstruct v4l2_subdev *sd = &core->sd;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_GAIN:\n\t\tcore->global_gain = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE:\n\t\tcore->exposure = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_RED_BALANCE:\n\t\tcore->red_bal = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_BLUE_BALANCE:\n\t\tcore->blue_bal = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tcore->hflip = ctrl->val;\n\t\tset_read_mode(sd);\n\t\treturn 0;\n\tcase V4L2_CID_VFLIP:\n\t\tcore->vflip = ctrl->val;\n\t\tset_read_mode(sd);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tset_balance(sd);\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops mt9v011_ctrl_ops = {\n\t.s_ctrl = mt9v011_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops mt9v011_core_ops = {\n\t.reset = mt9v011_reset,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = mt9v011_g_register,\n\t.s_register = mt9v011_s_register,\n#endif\n};\n\nstatic const struct v4l2_subdev_video_ops mt9v011_video_ops = {\n\t.g_frame_interval = mt9v011_g_frame_interval,\n\t.s_frame_interval = mt9v011_s_frame_interval,\n};\n\nstatic const struct v4l2_subdev_pad_ops mt9v011_pad_ops = {\n\t.enum_mbus_code = mt9v011_enum_mbus_code,\n\t.set_fmt = mt9v011_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops mt9v011_ops = {\n\t.core  = &mt9v011_core_ops,\n\t.video = &mt9v011_video_ops,\n\t.pad   = &mt9v011_pad_ops,\n};\n\n\n \n\nstatic int mt9v011_probe(struct i2c_client *c)\n{\n\tu16 version;\n\tstruct mt9v011 *core;\n\tstruct v4l2_subdev *sd;\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tint ret;\n#endif\n\n\t \n\tif (!i2c_check_functionality(c->adapter,\n\t     I2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))\n\t\treturn -EIO;\n\n\tcore = devm_kzalloc(&c->dev, sizeof(struct mt9v011), GFP_KERNEL);\n\tif (!core)\n\t\treturn -ENOMEM;\n\n\tsd = &core->sd;\n\tv4l2_i2c_subdev_init(sd, c, &mt9v011_ops);\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tcore->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tsd->entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\n\tret = media_entity_pads_init(&sd->entity, 1, &core->pad);\n\tif (ret < 0)\n\t\treturn ret;\n#endif\n\n\t \n\tversion = mt9v011_read(sd, R00_MT9V011_CHIP_VERSION);\n\tif ((version != MT9V011_VERSION) &&\n\t    (version != MT9V011_REV_B_VERSION)) {\n\t\tv4l2_info(sd, \"*** unknown micron chip detected (0x%04x).\\n\",\n\t\t\t  version);\n\t\treturn -EINVAL;\n\t}\n\n\tv4l2_ctrl_handler_init(&core->ctrls, 5);\n\tv4l2_ctrl_new_std(&core->ctrls, &mt9v011_ctrl_ops,\n\t\t\t  V4L2_CID_GAIN, 0, (1 << 12) - 1 - 0x20, 1, 0x20);\n\tv4l2_ctrl_new_std(&core->ctrls, &mt9v011_ctrl_ops,\n\t\t\t  V4L2_CID_EXPOSURE, 0, 2047, 1, 0x01fc);\n\tv4l2_ctrl_new_std(&core->ctrls, &mt9v011_ctrl_ops,\n\t\t\t  V4L2_CID_RED_BALANCE, -(1 << 9), (1 << 9) - 1, 1, 0);\n\tv4l2_ctrl_new_std(&core->ctrls, &mt9v011_ctrl_ops,\n\t\t\t  V4L2_CID_BLUE_BALANCE, -(1 << 9), (1 << 9) - 1, 1, 0);\n\tv4l2_ctrl_new_std(&core->ctrls, &mt9v011_ctrl_ops,\n\t\t\t  V4L2_CID_HFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(&core->ctrls, &mt9v011_ctrl_ops,\n\t\t\t  V4L2_CID_VFLIP, 0, 1, 1, 0);\n\n\tif (core->ctrls.error) {\n\t\tint ret = core->ctrls.error;\n\n\t\tv4l2_err(sd, \"control initialization error %d\\n\", ret);\n\t\tv4l2_ctrl_handler_free(&core->ctrls);\n\t\treturn ret;\n\t}\n\tcore->sd.ctrl_handler = &core->ctrls;\n\n\tcore->global_gain = 0x0024;\n\tcore->exposure = 0x01fc;\n\tcore->width  = 640;\n\tcore->height = 480;\n\tcore->xtal = 27000000;\t \n\n\tif (c->dev.platform_data) {\n\t\tstruct mt9v011_platform_data *pdata = c->dev.platform_data;\n\n\t\tcore->xtal = pdata->xtal;\n\t\tv4l2_dbg(1, debug, sd, \"xtal set to %d.%03d MHz\\n\",\n\t\t\tcore->xtal / 1000000, (core->xtal / 1000) % 1000);\n\t}\n\n\tv4l_info(c, \"chip found @ 0x%02x (%s - chip version 0x%04x)\\n\",\n\t\t c->addr << 1, c->adapter->name, version);\n\n\treturn 0;\n}\n\nstatic void mt9v011_remove(struct i2c_client *c)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(c);\n\tstruct mt9v011 *core = to_mt9v011(sd);\n\n\tv4l2_dbg(1, debug, sd,\n\t\t\"mt9v011.c: removing mt9v011 adapter on address 0x%x\\n\",\n\t\tc->addr << 1);\n\n\tv4l2_device_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(&core->ctrls);\n}\n\n \n\nstatic const struct i2c_device_id mt9v011_id[] = {\n\t{ \"mt9v011\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, mt9v011_id);\n\nstatic struct i2c_driver mt9v011_driver = {\n\t.driver = {\n\t\t.name\t= \"mt9v011\",\n\t},\n\t.probe\t\t= mt9v011_probe,\n\t.remove\t\t= mt9v011_remove,\n\t.id_table\t= mt9v011_id,\n};\n\nmodule_i2c_driver(mt9v011_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}