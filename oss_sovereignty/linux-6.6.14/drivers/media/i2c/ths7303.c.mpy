{
  "module_name": "ths7303.c",
  "hash_id": "afd5c1ca5ad2071cd55ff0b6f41a9a7e1db8cae838c30c212f6cd9855490bf94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ths7303.c",
  "human_readable_source": " \n\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <media/i2c/ths7303.h>\n#include <media/v4l2-device.h>\n\n#define THS7303_CHANNEL_1\t1\n#define THS7303_CHANNEL_2\t2\n#define THS7303_CHANNEL_3\t3\n\nstruct ths7303_state {\n\tstruct v4l2_subdev\t\tsd;\n\tconst struct ths7303_platform_data *pdata;\n\tstruct v4l2_bt_timings\t\tbt;\n\tint std_id;\n\tint stream_on;\n};\n\nenum ths7303_filter_mode {\n\tTHS7303_FILTER_MODE_480I_576I,\n\tTHS7303_FILTER_MODE_480P_576P,\n\tTHS7303_FILTER_MODE_720P_1080I,\n\tTHS7303_FILTER_MODE_1080P,\n\tTHS7303_FILTER_MODE_DISABLE\n};\n\nMODULE_DESCRIPTION(\"TI THS7303 video amplifier driver\");\nMODULE_AUTHOR(\"Chaithrika U S\");\nMODULE_LICENSE(\"GPL\");\n\nstatic inline struct ths7303_state *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct ths7303_state, sd);\n}\n\nstatic int ths7303_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\nstatic int ths7303_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = i2c_smbus_write_byte_data(client, reg, val);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t}\n\treturn ret;\n}\n\n \nstatic int ths7303_setval(struct v4l2_subdev *sd,\n\t\t\t  enum ths7303_filter_mode mode)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ths7303_state *state = to_state(sd);\n\tconst struct ths7303_platform_data *pdata = state->pdata;\n\tu8 val, sel = 0;\n\tint err, disable = 0;\n\n\tif (!client)\n\t\treturn -EINVAL;\n\n\tswitch (mode) {\n\tcase THS7303_FILTER_MODE_1080P:\n\t\tsel = 0x3;\t \n\t\tbreak;\n\tcase THS7303_FILTER_MODE_720P_1080I:\n\t\tsel = 0x2;\t \n\t\tbreak;\n\tcase THS7303_FILTER_MODE_480P_576P:\n\t\tsel = 0x1;\t \n\t\tbreak;\n\tcase THS7303_FILTER_MODE_480I_576I:\n\t\tsel = 0x0;\t \n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdisable = 1;\n\t}\n\n\tval = (sel << 6) | (sel << 3);\n\tif (!disable)\n\t\tval |= (pdata->ch_1 & 0x27);\n\terr = ths7303_write(sd, THS7303_CHANNEL_1, val);\n\tif (err)\n\t\tgoto out;\n\n\tval = (sel << 6) | (sel << 3);\n\tif (!disable)\n\t\tval |= (pdata->ch_2 & 0x27);\n\terr = ths7303_write(sd, THS7303_CHANNEL_2, val);\n\tif (err)\n\t\tgoto out;\n\n\tval = (sel << 6) | (sel << 3);\n\tif (!disable)\n\t\tval |= (pdata->ch_3 & 0x27);\n\terr = ths7303_write(sd, THS7303_CHANNEL_3, val);\n\tif (err)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tpr_info(\"write byte data failed\\n\");\n\treturn err;\n}\n\nstatic int ths7303_s_std_output(struct v4l2_subdev *sd, v4l2_std_id norm)\n{\n\tstruct ths7303_state *state = to_state(sd);\n\n\tif (norm & (V4L2_STD_ALL & ~V4L2_STD_SECAM)) {\n\t\tstate->std_id = 1;\n\t\tstate->bt.pixelclock = 0;\n\t\treturn ths7303_setval(sd, THS7303_FILTER_MODE_480I_576I);\n\t}\n\n\treturn ths7303_setval(sd, THS7303_FILTER_MODE_DISABLE);\n}\n\nstatic int ths7303_config(struct v4l2_subdev *sd)\n{\n\tstruct ths7303_state *state = to_state(sd);\n\tint res;\n\n\tif (!state->stream_on) {\n\t\tths7303_write(sd, THS7303_CHANNEL_1,\n\t\t\t      (ths7303_read(sd, THS7303_CHANNEL_1) & 0xf8) |\n\t\t\t      0x00);\n\t\tths7303_write(sd, THS7303_CHANNEL_2,\n\t\t\t      (ths7303_read(sd, THS7303_CHANNEL_2) & 0xf8) |\n\t\t\t      0x00);\n\t\tths7303_write(sd, THS7303_CHANNEL_3,\n\t\t\t      (ths7303_read(sd, THS7303_CHANNEL_3) & 0xf8) |\n\t\t\t      0x00);\n\t\treturn 0;\n\t}\n\n\tif (state->bt.pixelclock > 120000000)\n\t\tres = ths7303_setval(sd, THS7303_FILTER_MODE_1080P);\n\telse if (state->bt.pixelclock > 70000000)\n\t\tres = ths7303_setval(sd, THS7303_FILTER_MODE_720P_1080I);\n\telse if (state->bt.pixelclock > 20000000)\n\t\tres = ths7303_setval(sd, THS7303_FILTER_MODE_480P_576P);\n\telse if (state->std_id)\n\t\tres = ths7303_setval(sd, THS7303_FILTER_MODE_480I_576I);\n\telse\n\t\t \n\t\tres = ths7303_setval(sd, THS7303_FILTER_MODE_DISABLE);\n\n\treturn res;\n\n}\n\nstatic int ths7303_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct ths7303_state *state = to_state(sd);\n\n\tstate->stream_on = enable;\n\n\treturn ths7303_config(sd);\n}\n\n \nstatic int ths7303_s_dv_timings(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_dv_timings *dv_timings)\n{\n\tstruct ths7303_state *state = to_state(sd);\n\n\tif (!dv_timings || dv_timings->type != V4L2_DV_BT_656_1120)\n\t\treturn -EINVAL;\n\n\tstate->bt = dv_timings->bt;\n\tstate->std_id = 0;\n\n\treturn ths7303_config(sd);\n}\n\nstatic const struct v4l2_subdev_video_ops ths7303_video_ops = {\n\t.s_stream\t= ths7303_s_stream,\n\t.s_std_output\t= ths7303_s_std_output,\n\t.s_dv_timings   = ths7303_s_dv_timings,\n};\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\nstatic int ths7303_g_register(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_dbg_register *reg)\n{\n\treg->size = 1;\n\treg->val = ths7303_read(sd, reg->reg);\n\treturn 0;\n}\n\nstatic int ths7303_s_register(struct v4l2_subdev *sd,\n\t\t\t      const struct v4l2_dbg_register *reg)\n{\n\tths7303_write(sd, reg->reg, reg->val);\n\treturn 0;\n}\n#endif\n\nstatic const char * const stc_lpf_sel_txt[4] = {\n\t\"500-kHz Filter\",\n\t\"2.5-MHz Filter\",\n\t\"5-MHz Filter\",\n\t\"5-MHz Filter\",\n};\n\nstatic const char * const in_mux_sel_txt[2] = {\n\t\"Input A Select\",\n\t\"Input B Select\",\n};\n\nstatic const char * const lpf_freq_sel_txt[4] = {\n\t\"9-MHz LPF\",\n\t\"16-MHz LPF\",\n\t\"35-MHz LPF\",\n\t\"Bypass LPF\",\n};\n\nstatic const char * const in_bias_sel_dis_cont_txt[8] = {\n\t\"Disable Channel\",\n\t\"Mute Function - No Output\",\n\t\"DC Bias Select\",\n\t\"DC Bias + 250 mV Offset Select\",\n\t\"AC Bias Select\",\n\t\"Sync Tip Clamp with low bias\",\n\t\"Sync Tip Clamp with mid bias\",\n\t\"Sync Tip Clamp with high bias\",\n};\n\nstatic void ths7303_log_channel_status(struct v4l2_subdev *sd, u8 reg)\n{\n\tu8 val = ths7303_read(sd, reg);\n\n\tif ((val & 0x7) == 0) {\n\t\tv4l2_info(sd, \"Channel %d Off\\n\", reg);\n\t\treturn;\n\t}\n\n\tv4l2_info(sd, \"Channel %d On\\n\", reg);\n\tv4l2_info(sd, \"  value 0x%x\\n\", val);\n\tv4l2_info(sd, \"  %s\\n\", stc_lpf_sel_txt[(val >> 6) & 0x3]);\n\tv4l2_info(sd, \"  %s\\n\", in_mux_sel_txt[(val >> 5) & 0x1]);\n\tv4l2_info(sd, \"  %s\\n\", lpf_freq_sel_txt[(val >> 3) & 0x3]);\n\tv4l2_info(sd, \"  %s\\n\", in_bias_sel_dis_cont_txt[(val >> 0) & 0x7]);\n}\n\nstatic int ths7303_log_status(struct v4l2_subdev *sd)\n{\n\tstruct ths7303_state *state = to_state(sd);\n\n\tv4l2_info(sd, \"stream %s\\n\", state->stream_on ? \"On\" : \"Off\");\n\n\tif (state->bt.pixelclock) {\n\t\tstruct v4l2_bt_timings *bt = &state->bt;\n\t\tu32 frame_width, frame_height;\n\n\t\tframe_width = V4L2_DV_BT_FRAME_WIDTH(bt);\n\t\tframe_height = V4L2_DV_BT_FRAME_HEIGHT(bt);\n\t\tv4l2_info(sd,\n\t\t\t  \"timings: %dx%d%s%d (%dx%d). Pix freq. = %d Hz. Polarities = 0x%x\\n\",\n\t\t\t  bt->width, bt->height, bt->interlaced ? \"i\" : \"p\",\n\t\t\t  (frame_height * frame_width) > 0 ?\n\t\t\t  (int)bt->pixelclock /\n\t\t\t  (frame_height * frame_width) : 0,\n\t\t\t  frame_width, frame_height,\n\t\t\t  (int)bt->pixelclock, bt->polarities);\n\t} else {\n\t\tv4l2_info(sd, \"no timings set\\n\");\n\t}\n\n\tths7303_log_channel_status(sd, THS7303_CHANNEL_1);\n\tths7303_log_channel_status(sd, THS7303_CHANNEL_2);\n\tths7303_log_channel_status(sd, THS7303_CHANNEL_3);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops ths7303_core_ops = {\n\t.log_status = ths7303_log_status,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = ths7303_g_register,\n\t.s_register = ths7303_s_register,\n#endif\n};\n\nstatic const struct v4l2_subdev_ops ths7303_ops = {\n\t.core\t= &ths7303_core_ops,\n\t.video\t= &ths7303_video_ops,\n};\n\nstatic int ths7303_probe(struct i2c_client *client)\n{\n\tstruct ths7303_platform_data *pdata = client->dev.platform_data;\n\tstruct ths7303_state *state;\n\tstruct v4l2_subdev *sd;\n\n\tif (pdata == NULL) {\n\t\tdev_err(&client->dev, \"No platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tv4l_info(client, \"chip found @ 0x%x (%s)\\n\",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tstate = devm_kzalloc(&client->dev, sizeof(struct ths7303_state),\n\t\t\t     GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->pdata = pdata;\n\tsd = &state->sd;\n\tv4l2_i2c_subdev_init(sd, client, &ths7303_ops);\n\n\t \n\tif (ths7303_setval(sd, THS7303_FILTER_MODE_480I_576I) < 0) {\n\t\tv4l_err(client, \"Setting to 480I_576I filter mode failed!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void ths7303_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\n\tv4l2_device_unregister_subdev(sd);\n}\n\nstatic const struct i2c_device_id ths7303_id[] = {\n\t{\"ths7303\", 0},\n\t{\"ths7353\", 0},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(i2c, ths7303_id);\n\nstatic struct i2c_driver ths7303_driver = {\n\t.driver = {\n\t\t.name\t= \"ths73x3\",\n\t},\n\t.probe\t\t= ths7303_probe,\n\t.remove\t\t= ths7303_remove,\n\t.id_table\t= ths7303_id,\n};\n\nmodule_i2c_driver(ths7303_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}