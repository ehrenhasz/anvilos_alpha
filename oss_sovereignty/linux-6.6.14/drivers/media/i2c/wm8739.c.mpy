{
  "module_name": "wm8739.c",
  "hash_id": "5dae047b7680f686665f1bc7623668d81a0cd0b72361c4920c4e81db453f4d43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/wm8739.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/ioctl.h>\n#include <linux/uaccess.h>\n#include <linux/i2c.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n\nMODULE_DESCRIPTION(\"wm8739 driver\");\nMODULE_AUTHOR(\"T. Adachi, Hans Verkuil\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int debug;\n\nmodule_param(debug, int, 0644);\n\nMODULE_PARM_DESC(debug, \"Debug level (0-1)\");\n\n\n \n\nenum {\n\tR0 = 0, R1,\n\tR5 = 5, R6, R7, R8, R9, R15 = 15,\n\tTOT_REGS\n};\n\nstruct wm8739_state {\n\tstruct v4l2_subdev sd;\n\tstruct v4l2_ctrl_handler hdl;\n\tstruct {\n\t\t \n\t\tstruct v4l2_ctrl *volume;\n\t\tstruct v4l2_ctrl *mute;\n\t\tstruct v4l2_ctrl *balance;\n\t};\n\tu32 clock_freq;\n};\n\nstatic inline struct wm8739_state *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct wm8739_state, sd);\n}\n\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct wm8739_state, hdl)->sd;\n}\n\n \n\nstatic int wm8739_write(struct v4l2_subdev *sd, int reg, u16 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint i;\n\n\tif (reg < 0 || reg >= TOT_REGS) {\n\t\tv4l2_err(sd, \"Invalid register R%d\\n\", reg);\n\t\treturn -1;\n\t}\n\n\tv4l2_dbg(1, debug, sd, \"write: %02x %02x\\n\", reg, val);\n\n\tfor (i = 0; i < 3; i++)\n\t\tif (i2c_smbus_write_byte_data(client,\n\t\t\t\t(reg << 1) | (val >> 8), val & 0xff) == 0)\n\t\t\treturn 0;\n\tv4l2_err(sd, \"I2C: cannot write %03x to register R%d\\n\", val, reg);\n\treturn -1;\n}\n\nstatic int wm8739_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\tstruct wm8739_state *state = to_state(sd);\n\tunsigned int work_l, work_r;\n\tu8 vol_l;\t \n\tu8 vol_r;\t \n\tu16 mute;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_VOLUME:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twork_l = (min(65536 - state->balance->val, 32768) * state->volume->val) / 32768;\n\twork_r = (min(state->balance->val, 32768) * state->volume->val) / 32768;\n\n\tvol_l = (long)work_l * 31 / 65535;\n\tvol_r = (long)work_r * 31 / 65535;\n\n\t \n\tmute = state->mute->val ? 0x80 : 0;\n\n\t \n\twm8739_write(sd, R0, (vol_l & 0x1f) | mute);\n\twm8739_write(sd, R1, (vol_r & 0x1f) | mute);\n\treturn 0;\n}\n\n \n\nstatic int wm8739_s_clock_freq(struct v4l2_subdev *sd, u32 audiofreq)\n{\n\tstruct wm8739_state *state = to_state(sd);\n\n\tstate->clock_freq = audiofreq;\n\t \n\twm8739_write(sd, R9, 0x000);\n\tswitch (audiofreq) {\n\tcase 44100:\n\t\t \n\t\twm8739_write(sd, R8, 0x020);\n\t\tbreak;\n\tcase 48000:\n\t\t \n\t\twm8739_write(sd, R8, 0x000);\n\t\tbreak;\n\tcase 32000:\n\t\t \n\t\twm8739_write(sd, R8, 0x018);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t \n\twm8739_write(sd, R9, 0x001);\n\treturn 0;\n}\n\nstatic int wm8739_log_status(struct v4l2_subdev *sd)\n{\n\tstruct wm8739_state *state = to_state(sd);\n\n\tv4l2_info(sd, \"Frequency: %u Hz\\n\", state->clock_freq);\n\tv4l2_ctrl_handler_log_status(&state->hdl, sd->name);\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_ctrl_ops wm8739_ctrl_ops = {\n\t.s_ctrl = wm8739_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops wm8739_core_ops = {\n\t.log_status = wm8739_log_status,\n};\n\nstatic const struct v4l2_subdev_audio_ops wm8739_audio_ops = {\n\t.s_clock_freq = wm8739_s_clock_freq,\n};\n\nstatic const struct v4l2_subdev_ops wm8739_ops = {\n\t.core = &wm8739_core_ops,\n\t.audio = &wm8739_audio_ops,\n};\n\n \n\n \n\nstatic int wm8739_probe(struct i2c_client *client)\n{\n\tstruct wm8739_state *state;\n\tstruct v4l2_subdev *sd;\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tv4l_info(client, \"chip found @ 0x%x (%s)\\n\",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tstate = devm_kzalloc(&client->dev, sizeof(*state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\tsd = &state->sd;\n\tv4l2_i2c_subdev_init(sd, client, &wm8739_ops);\n\tv4l2_ctrl_handler_init(&state->hdl, 2);\n\tstate->volume = v4l2_ctrl_new_std(&state->hdl, &wm8739_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_VOLUME, 0, 65535, 65535 / 100, 50736);\n\tstate->mute = v4l2_ctrl_new_std(&state->hdl, &wm8739_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_MUTE, 0, 1, 1, 0);\n\tstate->balance = v4l2_ctrl_new_std(&state->hdl, &wm8739_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_BALANCE, 0, 65535, 65535 / 100, 32768);\n\tsd->ctrl_handler = &state->hdl;\n\tif (state->hdl.error) {\n\t\tint err = state->hdl.error;\n\n\t\tv4l2_ctrl_handler_free(&state->hdl);\n\t\treturn err;\n\t}\n\tv4l2_ctrl_cluster(3, &state->volume);\n\n\tstate->clock_freq = 48000;\n\n\t \n\n\t \n\twm8739_write(sd, R15, 0x00);\n\t \n\twm8739_write(sd, R5, 0x000);\n\t \n\twm8739_write(sd, R6, 0x000);\n\t \n\twm8739_write(sd, R7, 0x049);\n\t \n\twm8739_write(sd, R8, 0x000);\n\t \n\twm8739_write(sd, R9, 0x001);\n\t \n\tv4l2_ctrl_handler_setup(&state->hdl);\n\treturn 0;\n}\n\nstatic void wm8739_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct wm8739_state *state = to_state(sd);\n\n\tv4l2_device_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(&state->hdl);\n}\n\nstatic const struct i2c_device_id wm8739_id[] = {\n\t{ \"wm8739\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8739_id);\n\nstatic struct i2c_driver wm8739_driver = {\n\t.driver = {\n\t\t.name\t= \"wm8739\",\n\t},\n\t.probe\t\t= wm8739_probe,\n\t.remove\t\t= wm8739_remove,\n\t.id_table\t= wm8739_id,\n};\n\nmodule_i2c_driver(wm8739_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}