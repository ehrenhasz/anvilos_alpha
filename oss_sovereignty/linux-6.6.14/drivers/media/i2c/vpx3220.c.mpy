{
  "module_name": "vpx3220.c",
  "hash_id": "b307c5cfbd3b2491f6ccfa94c049ca38d5a8cd49384bcd25ad2c8633b4c4694d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/vpx3220.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/i2c.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n\nMODULE_DESCRIPTION(\"vpx3220a/vpx3216b/vpx3214c video decoder driver\");\nMODULE_AUTHOR(\"Laurent Pinchart\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int debug;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"Debug level (0-1)\");\n\n\n#define VPX_TIMEOUT_COUNT  10\n\n \n\nstruct vpx3220 {\n\tstruct v4l2_subdev sd;\n\tstruct v4l2_ctrl_handler hdl;\n\tunsigned char reg[255];\n\n\tv4l2_std_id norm;\n\tint input;\n\tint enable;\n};\n\nstatic inline struct vpx3220 *to_vpx3220(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct vpx3220, sd);\n}\n\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct vpx3220, hdl)->sd;\n}\n\nstatic char *inputs[] = { \"internal\", \"composite\", \"svideo\" };\n\n \n\nstatic inline int vpx3220_write(struct v4l2_subdev *sd, u8 reg, u8 value)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct vpx3220 *decoder = i2c_get_clientdata(client);\n\n\tdecoder->reg[reg] = value;\n\treturn i2c_smbus_write_byte_data(client, reg, value);\n}\n\nstatic inline int vpx3220_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\nstatic int vpx3220_fp_status(struct v4l2_subdev *sd)\n{\n\tunsigned char status;\n\tunsigned int i;\n\n\tfor (i = 0; i < VPX_TIMEOUT_COUNT; i++) {\n\t\tstatus = vpx3220_read(sd, 0x29);\n\n\t\tif (!(status & 4))\n\t\t\treturn 0;\n\n\t\tudelay(10);\n\n\t\tif (need_resched())\n\t\t\tcond_resched();\n\t}\n\n\treturn -1;\n}\n\nstatic int vpx3220_fp_write(struct v4l2_subdev *sd, u8 fpaddr, u16 data)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\t \n\tif (i2c_smbus_write_word_data(client, 0x27, swab16(fpaddr)) == -1) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: failed\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tif (vpx3220_fp_status(sd) < 0)\n\t\treturn -1;\n\n\t \n\tif (i2c_smbus_write_word_data(client, 0x28, swab16(data)) == -1) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: failed\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int vpx3220_fp_read(struct v4l2_subdev *sd, u16 fpaddr)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\ts16 data;\n\n\t \n\tif (i2c_smbus_write_word_data(client, 0x26, swab16(fpaddr)) == -1) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: failed\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tif (vpx3220_fp_status(sd) < 0)\n\t\treturn -1;\n\n\t \n\tdata = i2c_smbus_read_word_data(client, 0x28);\n\tif (data == -1) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: failed\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\treturn swab16(data);\n}\n\nstatic int vpx3220_write_block(struct v4l2_subdev *sd, const u8 *data, unsigned int len)\n{\n\tu8 reg;\n\tint ret = -1;\n\n\twhile (len >= 2) {\n\t\treg = *data++;\n\t\tret = vpx3220_write(sd, reg, *data++);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tlen -= 2;\n\t}\n\n\treturn ret;\n}\n\nstatic int vpx3220_write_fp_block(struct v4l2_subdev *sd,\n\t\tconst u16 *data, unsigned int len)\n{\n\tu8 reg;\n\tint ret = 0;\n\n\twhile (len > 1) {\n\t\treg = *data++;\n\t\tret |= vpx3220_fp_write(sd, reg, *data++);\n\t\tlen -= 2;\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic const unsigned short init_ntsc[] = {\n\t0x1c, 0x00,\t\t \n\t0x88, 17,\t\t \n\t0x89, 240,\t\t \n\t0x8a, 240,\t\t \n\t0x8b, 000,\t\t \n\t0x8c, 640,\t\t \n\t0x8d, 640,\t\t \n\t0x8f, 0xc00,\t\t \n\t0xf0, 0x73,\t\t \n\t0xf2, 0x13,\t\t \n\t0xe7, 0x1e1,\t\t \n};\n\nstatic const unsigned short init_pal[] = {\n\t0x88, 23,\t\t \n\t0x89, 288,\t\t \n\t0x8a, 288,\t\t \n\t0x8b, 16,\t\t \n\t0x8c, 768,\t\t \n\t0x8d, 784,\t\t \n\t0x8f, 0xc00,\t\t \n\t0xf0, 0x77,\t\t \n\t0xf2, 0x3d1,\t\t \n\t0xe7, 0x241,\t\t \n};\n\nstatic const unsigned short init_secam[] = {\n\t0x88, 23,\t\t \n\t0x89, 288,\t\t \n\t0x8a, 288,\t\t \n\t0x8b, 16,\t\t \n\t0x8c, 768,\t\t \n\t0x8d, 784,\t\t \n\t0x8f, 0xc00,\t\t \n\t0xf0, 0x77,\t\t \n\t0xf2, 0x3d5,\t\t \n\t0xe7, 0x241,\t\t \n};\n\nstatic const unsigned char init_common[] = {\n\t0xf2, 0x00,\t\t \n\t0x33, 0x0d,\t\t \n\t0xd8, 0xa8,\t\t \n\t0x20, 0x03,\t\t \n\t0xe0, 0xff,\t\t \n\t0xe1, 0x00,\n\t0xe2, 0x7f,\n\t0xe3, 0x80,\n\t0xe4, 0x7f,\n\t0xe5, 0x80,\n\t0xe6, 0x00,\t\t \n\t0xe7, 0xe0,\t\t \n\t0xe8, 0xf8,\t\t \n\t0xea, 0x18,\t\t \n\t0xf0, 0x8a,\t\t \n\t0xf1, 0x18,\t\t \n\t0xf8, 0x12,\t\t \n\t0xf9, 0x24,\t\t \n};\n\nstatic const unsigned short init_fp[] = {\n\t0x59, 0,\n\t0xa0, 2070,\t\t \n\t0xa3, 0,\n\t0xa4, 0,\n\t0xa8, 30,\n\t0xb2, 768,\n\t0xbe, 27,\n\t0x58, 0,\n\t0x26, 0,\n\t0x4b, 0x298,\t\t \n};\n\n\nstatic int vpx3220_init(struct v4l2_subdev *sd, u32 val)\n{\n\tstruct vpx3220 *decoder = to_vpx3220(sd);\n\n\tvpx3220_write_block(sd, init_common, sizeof(init_common));\n\tvpx3220_write_fp_block(sd, init_fp, sizeof(init_fp) >> 1);\n\tif (decoder->norm & V4L2_STD_NTSC)\n\t\tvpx3220_write_fp_block(sd, init_ntsc, sizeof(init_ntsc) >> 1);\n\telse if (decoder->norm & V4L2_STD_PAL)\n\t\tvpx3220_write_fp_block(sd, init_pal, sizeof(init_pal) >> 1);\n\telse if (decoder->norm & V4L2_STD_SECAM)\n\t\tvpx3220_write_fp_block(sd, init_secam, sizeof(init_secam) >> 1);\n\telse\n\t\tvpx3220_write_fp_block(sd, init_pal, sizeof(init_pal) >> 1);\n\treturn 0;\n}\n\nstatic int vpx3220_status(struct v4l2_subdev *sd, u32 *pstatus, v4l2_std_id *pstd)\n{\n\tint res = V4L2_IN_ST_NO_SIGNAL, status;\n\tv4l2_std_id std = pstd ? *pstd : V4L2_STD_ALL;\n\n\tstatus = vpx3220_fp_read(sd, 0x0f3);\n\n\tv4l2_dbg(1, debug, sd, \"status: 0x%04x\\n\", status);\n\n\tif (status < 0)\n\t\treturn status;\n\n\tif ((status & 0x20) == 0) {\n\t\tres = 0;\n\n\t\tswitch (status & 0x18) {\n\t\tcase 0x00:\n\t\tcase 0x10:\n\t\tcase 0x14:\n\t\tcase 0x18:\n\t\t\tstd &= V4L2_STD_PAL;\n\t\t\tbreak;\n\n\t\tcase 0x08:\n\t\t\tstd &= V4L2_STD_SECAM;\n\t\t\tbreak;\n\n\t\tcase 0x04:\n\t\tcase 0x0c:\n\t\tcase 0x1c:\n\t\t\tstd &= V4L2_STD_NTSC;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tstd = V4L2_STD_UNKNOWN;\n\t}\n\tif (pstd)\n\t\t*pstd = std;\n\tif (pstatus)\n\t\t*pstatus = res;\n\treturn 0;\n}\n\nstatic int vpx3220_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)\n{\n\tv4l2_dbg(1, debug, sd, \"querystd\\n\");\n\treturn vpx3220_status(sd, NULL, std);\n}\n\nstatic int vpx3220_g_input_status(struct v4l2_subdev *sd, u32 *status)\n{\n\tv4l2_dbg(1, debug, sd, \"g_input_status\\n\");\n\treturn vpx3220_status(sd, status, NULL);\n}\n\nstatic int vpx3220_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct vpx3220 *decoder = to_vpx3220(sd);\n\tint temp_input;\n\n\t \n\ttemp_input = vpx3220_fp_read(sd, 0xf2);\n\n\tv4l2_dbg(1, debug, sd, \"s_std %llx\\n\", (unsigned long long)std);\n\tif (std & V4L2_STD_NTSC) {\n\t\tvpx3220_write_fp_block(sd, init_ntsc, sizeof(init_ntsc) >> 1);\n\t\tv4l2_dbg(1, debug, sd, \"norm switched to NTSC\\n\");\n\t} else if (std & V4L2_STD_PAL) {\n\t\tvpx3220_write_fp_block(sd, init_pal, sizeof(init_pal) >> 1);\n\t\tv4l2_dbg(1, debug, sd, \"norm switched to PAL\\n\");\n\t} else if (std & V4L2_STD_SECAM) {\n\t\tvpx3220_write_fp_block(sd, init_secam, sizeof(init_secam) >> 1);\n\t\tv4l2_dbg(1, debug, sd, \"norm switched to SECAM\\n\");\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tdecoder->norm = std;\n\n\t \n\tvpx3220_fp_write(sd, 0xf2, temp_input | 0x0010);\n\tudelay(10);\n\treturn 0;\n}\n\nstatic int vpx3220_s_routing(struct v4l2_subdev *sd,\n\t\t\t     u32 input, u32 output, u32 config)\n{\n\tint data;\n\n\t \n\n\tstatic const int input_vals[3][2] = {\n\t\t{0x0c, 0},\n\t\t{0x0d, 0},\n\t\t{0x0e, 1}\n\t};\n\n\tif (input > 2)\n\t\treturn -EINVAL;\n\n\tv4l2_dbg(1, debug, sd, \"input switched to %s\\n\", inputs[input]);\n\n\tvpx3220_write(sd, 0x33, input_vals[input][0]);\n\n\tdata = vpx3220_fp_read(sd, 0xf2) & ~(0x0020);\n\tif (data < 0)\n\t\treturn data;\n\t \n\tvpx3220_fp_write(sd, 0xf2,\n\t\t\tdata | (input_vals[input][1] << 5) | 0x0010);\n\n\tudelay(10);\n\treturn 0;\n}\n\nstatic int vpx3220_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tv4l2_dbg(1, debug, sd, \"s_stream %s\\n\", enable ? \"on\" : \"off\");\n\n\tvpx3220_write(sd, 0xf2, (enable ? 0x1b : 0x00));\n\treturn 0;\n}\n\nstatic int vpx3220_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tvpx3220_write(sd, 0xe6, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_CONTRAST:\n\t\t \n\t\tvpx3220_write(sd, 0xe7, ctrl->val + 192);\n\t\treturn 0;\n\tcase V4L2_CID_SATURATION:\n\t\tvpx3220_fp_write(sd, 0xa0, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_HUE:\n\t\tvpx3220_fp_write(sd, 0x1c, ctrl->val);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n \n\nstatic const struct v4l2_ctrl_ops vpx3220_ctrl_ops = {\n\t.s_ctrl = vpx3220_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops vpx3220_core_ops = {\n\t.init = vpx3220_init,\n};\n\nstatic const struct v4l2_subdev_video_ops vpx3220_video_ops = {\n\t.s_std = vpx3220_s_std,\n\t.s_routing = vpx3220_s_routing,\n\t.s_stream = vpx3220_s_stream,\n\t.querystd = vpx3220_querystd,\n\t.g_input_status = vpx3220_g_input_status,\n};\n\nstatic const struct v4l2_subdev_ops vpx3220_ops = {\n\t.core = &vpx3220_core_ops,\n\t.video = &vpx3220_video_ops,\n};\n\n \n\nstatic int vpx3220_probe(struct i2c_client *client)\n{\n\tstruct vpx3220 *decoder;\n\tstruct v4l2_subdev *sd;\n\tconst char *name = NULL;\n\tu8 ver;\n\tu16 pn;\n\n\t \n\tif (!i2c_check_functionality(client->adapter,\n\t\tI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA))\n\t\treturn -ENODEV;\n\n\tdecoder = devm_kzalloc(&client->dev, sizeof(*decoder), GFP_KERNEL);\n\tif (decoder == NULL)\n\t\treturn -ENOMEM;\n\tsd = &decoder->sd;\n\tv4l2_i2c_subdev_init(sd, client, &vpx3220_ops);\n\tdecoder->norm = V4L2_STD_PAL;\n\tdecoder->input = 0;\n\tdecoder->enable = 1;\n\tv4l2_ctrl_handler_init(&decoder->hdl, 4);\n\tv4l2_ctrl_new_std(&decoder->hdl, &vpx3220_ctrl_ops,\n\t\tV4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\n\tv4l2_ctrl_new_std(&decoder->hdl, &vpx3220_ctrl_ops,\n\t\tV4L2_CID_CONTRAST, 0, 63, 1, 32);\n\tv4l2_ctrl_new_std(&decoder->hdl, &vpx3220_ctrl_ops,\n\t\tV4L2_CID_SATURATION, 0, 4095, 1, 2048);\n\tv4l2_ctrl_new_std(&decoder->hdl, &vpx3220_ctrl_ops,\n\t\tV4L2_CID_HUE, -512, 511, 1, 0);\n\tsd->ctrl_handler = &decoder->hdl;\n\tif (decoder->hdl.error) {\n\t\tint err = decoder->hdl.error;\n\n\t\tv4l2_ctrl_handler_free(&decoder->hdl);\n\t\treturn err;\n\t}\n\tv4l2_ctrl_handler_setup(&decoder->hdl);\n\n\tver = i2c_smbus_read_byte_data(client, 0x00);\n\tpn = (i2c_smbus_read_byte_data(client, 0x02) << 8) +\n\t\ti2c_smbus_read_byte_data(client, 0x01);\n\tif (ver == 0xec) {\n\t\tswitch (pn) {\n\t\tcase 0x4680:\n\t\t\tname = \"vpx3220a\";\n\t\t\tbreak;\n\t\tcase 0x4260:\n\t\t\tname = \"vpx3216b\";\n\t\t\tbreak;\n\t\tcase 0x4280:\n\t\t\tname = \"vpx3214c\";\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (name)\n\t\tv4l2_info(sd, \"%s found @ 0x%x (%s)\\n\", name,\n\t\t\tclient->addr << 1, client->adapter->name);\n\telse\n\t\tv4l2_info(sd, \"chip (%02x:%04x) found @ 0x%x (%s)\\n\",\n\t\t\tver, pn, client->addr << 1, client->adapter->name);\n\n\tvpx3220_write_block(sd, init_common, sizeof(init_common));\n\tvpx3220_write_fp_block(sd, init_fp, sizeof(init_fp) >> 1);\n\t \n\tvpx3220_write_fp_block(sd, init_pal, sizeof(init_pal) >> 1);\n\treturn 0;\n}\n\nstatic void vpx3220_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct vpx3220 *decoder = to_vpx3220(sd);\n\n\tv4l2_device_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(&decoder->hdl);\n}\n\nstatic const struct i2c_device_id vpx3220_id[] = {\n\t{ \"vpx3220a\", 0 },\n\t{ \"vpx3216b\", 0 },\n\t{ \"vpx3214c\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, vpx3220_id);\n\nstatic struct i2c_driver vpx3220_driver = {\n\t.driver = {\n\t\t.name\t= \"vpx3220\",\n\t},\n\t.probe\t\t= vpx3220_probe,\n\t.remove\t\t= vpx3220_remove,\n\t.id_table\t= vpx3220_id,\n};\n\nmodule_i2c_driver(vpx3220_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}