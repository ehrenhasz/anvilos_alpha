{
  "module_name": "imx214.c",
  "hash_id": "f988c6b0d01137b1685ccf34fc42ecb905cd4db98b0d8d62d22dcf5cbb716d00",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/imx214.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <media/media-entity.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n#define IMX214_DEFAULT_CLK_FREQ\t24000000\n#define IMX214_DEFAULT_LINK_FREQ 480000000\n#define IMX214_DEFAULT_PIXEL_RATE ((IMX214_DEFAULT_LINK_FREQ * 8LL) / 10)\n#define IMX214_FPS 30\n#define IMX214_MBUS_CODE MEDIA_BUS_FMT_SRGGB10_1X10\n\nstatic const char * const imx214_supply_name[] = {\n\t\"vdda\",\n\t\"vddd\",\n\t\"vdddo\",\n};\n\n#define IMX214_NUM_SUPPLIES ARRAY_SIZE(imx214_supply_name)\n\nstruct imx214 {\n\tstruct device *dev;\n\tstruct clk *xclk;\n\tstruct regmap *regmap;\n\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pad;\n\tstruct v4l2_mbus_framefmt fmt;\n\tstruct v4l2_rect crop;\n\n\tstruct v4l2_ctrl_handler ctrls;\n\tstruct v4l2_ctrl *pixel_rate;\n\tstruct v4l2_ctrl *link_freq;\n\tstruct v4l2_ctrl *exposure;\n\tstruct v4l2_ctrl *unit_size;\n\n\tstruct regulator_bulk_data\tsupplies[IMX214_NUM_SUPPLIES];\n\n\tstruct gpio_desc *enable_gpio;\n\n\t \n\tstruct mutex mutex;\n\n\tbool streaming;\n};\n\nstruct reg_8 {\n\tu16 addr;\n\tu8 val;\n};\n\nenum {\n\tIMX214_TABLE_WAIT_MS = 0,\n\tIMX214_TABLE_END,\n\tIMX214_MAX_RETRIES,\n\tIMX214_WAIT_MS\n};\n\n \nstatic const struct reg_8 mode_4096x2304[] = {\n\t{0x0114, 0x03},\n\t{0x0220, 0x00},\n\t{0x0221, 0x11},\n\t{0x0222, 0x01},\n\t{0x0340, 0x0C},\n\t{0x0341, 0x7A},\n\t{0x0342, 0x13},\n\t{0x0343, 0x90},\n\t{0x0344, 0x00},\n\t{0x0345, 0x38},\n\t{0x0346, 0x01},\n\t{0x0347, 0x98},\n\t{0x0348, 0x10},\n\t{0x0349, 0x37},\n\t{0x034A, 0x0A},\n\t{0x034B, 0x97},\n\t{0x0381, 0x01},\n\t{0x0383, 0x01},\n\t{0x0385, 0x01},\n\t{0x0387, 0x01},\n\t{0x0900, 0x00},\n\t{0x0901, 0x00},\n\t{0x0902, 0x00},\n\t{0x3000, 0x35},\n\t{0x3054, 0x01},\n\t{0x305C, 0x11},\n\n\t{0x0112, 0x0A},\n\t{0x0113, 0x0A},\n\t{0x034C, 0x10},\n\t{0x034D, 0x00},\n\t{0x034E, 0x09},\n\t{0x034F, 0x00},\n\t{0x0401, 0x00},\n\t{0x0404, 0x00},\n\t{0x0405, 0x10},\n\t{0x0408, 0x00},\n\t{0x0409, 0x00},\n\t{0x040A, 0x00},\n\t{0x040B, 0x00},\n\t{0x040C, 0x10},\n\t{0x040D, 0x00},\n\t{0x040E, 0x09},\n\t{0x040F, 0x00},\n\n\t{0x0301, 0x05},\n\t{0x0303, 0x02},\n\t{0x0305, 0x03},\n\t{0x0306, 0x00},\n\t{0x0307, 0x96},\n\t{0x0309, 0x0A},\n\t{0x030B, 0x01},\n\t{0x0310, 0x00},\n\n\t{0x0820, 0x12},\n\t{0x0821, 0xC0},\n\t{0x0822, 0x00},\n\t{0x0823, 0x00},\n\n\t{0x3A03, 0x09},\n\t{0x3A04, 0x50},\n\t{0x3A05, 0x01},\n\n\t{0x0B06, 0x01},\n\t{0x30A2, 0x00},\n\n\t{0x30B4, 0x00},\n\n\t{0x3A02, 0xFF},\n\n\t{0x3011, 0x00},\n\t{0x3013, 0x01},\n\n\t{0x0202, 0x0C},\n\t{0x0203, 0x70},\n\t{0x0224, 0x01},\n\t{0x0225, 0xF4},\n\n\t{0x0204, 0x00},\n\t{0x0205, 0x00},\n\t{0x020E, 0x01},\n\t{0x020F, 0x00},\n\t{0x0210, 0x01},\n\t{0x0211, 0x00},\n\t{0x0212, 0x01},\n\t{0x0213, 0x00},\n\t{0x0214, 0x01},\n\t{0x0215, 0x00},\n\t{0x0216, 0x00},\n\t{0x0217, 0x00},\n\n\t{0x4170, 0x00},\n\t{0x4171, 0x10},\n\t{0x4176, 0x00},\n\t{0x4177, 0x3C},\n\t{0xAE20, 0x04},\n\t{0xAE21, 0x5C},\n\n\t{IMX214_TABLE_WAIT_MS, 10},\n\t{0x0138, 0x01},\n\t{IMX214_TABLE_END, 0x00}\n};\n\nstatic const struct reg_8 mode_1920x1080[] = {\n\t{0x0114, 0x03},\n\t{0x0220, 0x00},\n\t{0x0221, 0x11},\n\t{0x0222, 0x01},\n\t{0x0340, 0x0C},\n\t{0x0341, 0x7A},\n\t{0x0342, 0x13},\n\t{0x0343, 0x90},\n\t{0x0344, 0x04},\n\t{0x0345, 0x78},\n\t{0x0346, 0x03},\n\t{0x0347, 0xFC},\n\t{0x0348, 0x0B},\n\t{0x0349, 0xF7},\n\t{0x034A, 0x08},\n\t{0x034B, 0x33},\n\t{0x0381, 0x01},\n\t{0x0383, 0x01},\n\t{0x0385, 0x01},\n\t{0x0387, 0x01},\n\t{0x0900, 0x00},\n\t{0x0901, 0x00},\n\t{0x0902, 0x00},\n\t{0x3000, 0x35},\n\t{0x3054, 0x01},\n\t{0x305C, 0x11},\n\n\t{0x0112, 0x0A},\n\t{0x0113, 0x0A},\n\t{0x034C, 0x07},\n\t{0x034D, 0x80},\n\t{0x034E, 0x04},\n\t{0x034F, 0x38},\n\t{0x0401, 0x00},\n\t{0x0404, 0x00},\n\t{0x0405, 0x10},\n\t{0x0408, 0x00},\n\t{0x0409, 0x00},\n\t{0x040A, 0x00},\n\t{0x040B, 0x00},\n\t{0x040C, 0x07},\n\t{0x040D, 0x80},\n\t{0x040E, 0x04},\n\t{0x040F, 0x38},\n\n\t{0x0301, 0x05},\n\t{0x0303, 0x02},\n\t{0x0305, 0x03},\n\t{0x0306, 0x00},\n\t{0x0307, 0x96},\n\t{0x0309, 0x0A},\n\t{0x030B, 0x01},\n\t{0x0310, 0x00},\n\n\t{0x0820, 0x12},\n\t{0x0821, 0xC0},\n\t{0x0822, 0x00},\n\t{0x0823, 0x00},\n\n\t{0x3A03, 0x04},\n\t{0x3A04, 0xF8},\n\t{0x3A05, 0x02},\n\n\t{0x0B06, 0x01},\n\t{0x30A2, 0x00},\n\n\t{0x30B4, 0x00},\n\n\t{0x3A02, 0xFF},\n\n\t{0x3011, 0x00},\n\t{0x3013, 0x01},\n\n\t{0x0202, 0x0C},\n\t{0x0203, 0x70},\n\t{0x0224, 0x01},\n\t{0x0225, 0xF4},\n\n\t{0x0204, 0x00},\n\t{0x0205, 0x00},\n\t{0x020E, 0x01},\n\t{0x020F, 0x00},\n\t{0x0210, 0x01},\n\t{0x0211, 0x00},\n\t{0x0212, 0x01},\n\t{0x0213, 0x00},\n\t{0x0214, 0x01},\n\t{0x0215, 0x00},\n\t{0x0216, 0x00},\n\t{0x0217, 0x00},\n\n\t{0x4170, 0x00},\n\t{0x4171, 0x10},\n\t{0x4176, 0x00},\n\t{0x4177, 0x3C},\n\t{0xAE20, 0x04},\n\t{0xAE21, 0x5C},\n\n\t{IMX214_TABLE_WAIT_MS, 10},\n\t{0x0138, 0x01},\n\t{IMX214_TABLE_END, 0x00}\n};\n\nstatic const struct reg_8 mode_table_common[] = {\n\t \n\n\t \n\t{0x0100, 0x00},\n\n\t \n\t{0x9300, 0x02},\n\n\t \n\t{0x0136, 0x18},\n\t{0x0137, 0x00},\n\n\t \n\t \n\t{0x0101, 0x00},\n\t{0x0105, 0x01},\n\t{0x0106, 0x01},\n\t{0x4550, 0x02},\n\t{0x4601, 0x00},\n\t{0x4642, 0x05},\n\t{0x6227, 0x11},\n\t{0x6276, 0x00},\n\t{0x900E, 0x06},\n\t{0xA802, 0x90},\n\t{0xA803, 0x11},\n\t{0xA804, 0x62},\n\t{0xA805, 0x77},\n\t{0xA806, 0xAE},\n\t{0xA807, 0x34},\n\t{0xA808, 0xAE},\n\t{0xA809, 0x35},\n\t{0xA80A, 0x62},\n\t{0xA80B, 0x83},\n\t{0xAE33, 0x00},\n\n\t \n\t{0x4174, 0x00},\n\t{0x4175, 0x11},\n\t{0x4612, 0x29},\n\t{0x461B, 0x12},\n\t{0x461F, 0x06},\n\t{0x4635, 0x07},\n\t{0x4637, 0x30},\n\t{0x463F, 0x18},\n\t{0x4641, 0x0D},\n\t{0x465B, 0x12},\n\t{0x465F, 0x11},\n\t{0x4663, 0x11},\n\t{0x4667, 0x0F},\n\t{0x466F, 0x0F},\n\t{0x470E, 0x09},\n\t{0x4909, 0xAB},\n\t{0x490B, 0x95},\n\t{0x4915, 0x5D},\n\t{0x4A5F, 0xFF},\n\t{0x4A61, 0xFF},\n\t{0x4A73, 0x62},\n\t{0x4A85, 0x00},\n\t{0x4A87, 0xFF},\n\n\t \n\t{0x5041, 0x04},\n\t{0x583C, 0x04},\n\t{0x620E, 0x04},\n\t{0x6EB2, 0x01},\n\t{0x6EB3, 0x00},\n\t{0x9300, 0x02},\n\n\t \n\t \n\t{0x3001, 0x07},\n\t{0x6D12, 0x3F},\n\t{0x6D13, 0xFF},\n\t{0x9344, 0x03},\n\t{0x9706, 0x10},\n\t{0x9707, 0x03},\n\t{0x9708, 0x03},\n\t{0x9E04, 0x01},\n\t{0x9E05, 0x00},\n\t{0x9E0C, 0x01},\n\t{0x9E0D, 0x02},\n\t{0x9E24, 0x00},\n\t{0x9E25, 0x8C},\n\t{0x9E26, 0x00},\n\t{0x9E27, 0x94},\n\t{0x9E28, 0x00},\n\t{0x9E29, 0x96},\n\n\t \n\t{0x69DB, 0x01},\n\n\t \n\t{0x6957, 0x01},\n\n\t \n\t{0x6987, 0x17},\n\t{0x698A, 0x03},\n\t{0x698B, 0x03},\n\n\t \n\t{0x0B8E, 0x01},\n\t{0x0B8F, 0x00},\n\t{0x0B90, 0x01},\n\t{0x0B91, 0x00},\n\t{0x0B92, 0x01},\n\t{0x0B93, 0x00},\n\t{0x0B94, 0x01},\n\t{0x0B95, 0x00},\n\n\t \n\t{0x6E50, 0x00},\n\t{0x6E51, 0x32},\n\t{0x9340, 0x00},\n\t{0x9341, 0x3C},\n\t{0x9342, 0x03},\n\t{0x9343, 0xFF},\n\t{IMX214_TABLE_END, 0x00}\n};\n\n \nstatic const struct imx214_mode {\n\tu32 width;\n\tu32 height;\n\tconst struct reg_8 *reg_table;\n} imx214_modes[] = {\n\t{\n\t\t.width = 4096,\n\t\t.height = 2304,\n\t\t.reg_table = mode_4096x2304,\n\t},\n\t{\n\t\t.width = 1920,\n\t\t.height = 1080,\n\t\t.reg_table = mode_1920x1080,\n\t},\n};\n\nstatic inline struct imx214 *to_imx214(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct imx214, sd);\n}\n\nstatic int __maybe_unused imx214_power_on(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct imx214 *imx214 = to_imx214(sd);\n\tint ret;\n\n\tret = regulator_bulk_enable(IMX214_NUM_SUPPLIES, imx214->supplies);\n\tif (ret < 0) {\n\t\tdev_err(imx214->dev, \"failed to enable regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tusleep_range(2000, 3000);\n\n\tret = clk_prepare_enable(imx214->xclk);\n\tif (ret < 0) {\n\t\tregulator_bulk_disable(IMX214_NUM_SUPPLIES, imx214->supplies);\n\t\tdev_err(imx214->dev, \"clk prepare enable failed\\n\");\n\t\treturn ret;\n\t}\n\n\tgpiod_set_value_cansleep(imx214->enable_gpio, 1);\n\tusleep_range(12000, 15000);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused imx214_power_off(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct imx214 *imx214 = to_imx214(sd);\n\n\tgpiod_set_value_cansleep(imx214->enable_gpio, 0);\n\n\tclk_disable_unprepare(imx214->xclk);\n\n\tregulator_bulk_disable(IMX214_NUM_SUPPLIES, imx214->supplies);\n\tusleep_range(10, 20);\n\n\treturn 0;\n}\n\nstatic int imx214_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index > 0)\n\t\treturn -EINVAL;\n\n\tcode->code = IMX214_MBUS_CODE;\n\n\treturn 0;\n}\n\nstatic int imx214_enum_frame_size(struct v4l2_subdev *subdev,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tif (fse->code != IMX214_MBUS_CODE)\n\t\treturn -EINVAL;\n\n\tif (fse->index >= ARRAY_SIZE(imx214_modes))\n\t\treturn -EINVAL;\n\n\tfse->min_width = fse->max_width = imx214_modes[fse->index].width;\n\tfse->min_height = fse->max_height = imx214_modes[fse->index].height;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int imx214_s_register(struct v4l2_subdev *subdev,\n\t\t\t     const struct v4l2_dbg_register *reg)\n{\n\tstruct imx214 *imx214 = container_of(subdev, struct imx214, sd);\n\n\treturn regmap_write(imx214->regmap, reg->reg, reg->val);\n}\n\nstatic int imx214_g_register(struct v4l2_subdev *subdev,\n\t\t\t     struct v4l2_dbg_register *reg)\n{\n\tstruct imx214 *imx214 = container_of(subdev, struct imx214, sd);\n\tunsigned int aux;\n\tint ret;\n\n\treg->size = 1;\n\tret = regmap_read(imx214->regmap, reg->reg, &aux);\n\treg->val = aux;\n\n\treturn ret;\n}\n#endif\n\nstatic const struct v4l2_subdev_core_ops imx214_core_ops = {\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = imx214_g_register,\n\t.s_register = imx214_s_register,\n#endif\n};\n\nstatic struct v4l2_mbus_framefmt *\n__imx214_get_pad_format(struct imx214 *imx214,\n\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\tunsigned int pad,\n\t\t\tenum v4l2_subdev_format_whence which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\treturn v4l2_subdev_get_try_format(&imx214->sd, sd_state, pad);\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &imx214->fmt;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic int imx214_get_format(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_format *format)\n{\n\tstruct imx214 *imx214 = to_imx214(sd);\n\n\tmutex_lock(&imx214->mutex);\n\tformat->format = *__imx214_get_pad_format(imx214, sd_state,\n\t\t\t\t\t\t  format->pad,\n\t\t\t\t\t\t  format->which);\n\tmutex_unlock(&imx214->mutex);\n\n\treturn 0;\n}\n\nstatic struct v4l2_rect *\n__imx214_get_pad_crop(struct imx214 *imx214,\n\t\t      struct v4l2_subdev_state *sd_state,\n\t\t      unsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\treturn v4l2_subdev_get_try_crop(&imx214->sd, sd_state, pad);\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &imx214->crop;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic int imx214_set_format(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_format *format)\n{\n\tstruct imx214 *imx214 = to_imx214(sd);\n\tstruct v4l2_mbus_framefmt *__format;\n\tstruct v4l2_rect *__crop;\n\tconst struct imx214_mode *mode;\n\n\tmutex_lock(&imx214->mutex);\n\n\t__crop = __imx214_get_pad_crop(imx214, sd_state, format->pad,\n\t\t\t\t       format->which);\n\n\tmode = v4l2_find_nearest_size(imx214_modes,\n\t\t\t\t      ARRAY_SIZE(imx214_modes), width, height,\n\t\t\t\t      format->format.width,\n\t\t\t\t      format->format.height);\n\n\t__crop->width = mode->width;\n\t__crop->height = mode->height;\n\n\t__format = __imx214_get_pad_format(imx214, sd_state, format->pad,\n\t\t\t\t\t   format->which);\n\t__format->width = __crop->width;\n\t__format->height = __crop->height;\n\t__format->code = IMX214_MBUS_CODE;\n\t__format->field = V4L2_FIELD_NONE;\n\t__format->colorspace = V4L2_COLORSPACE_SRGB;\n\t__format->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(__format->colorspace);\n\t__format->quantization = V4L2_MAP_QUANTIZATION_DEFAULT(true,\n\t\t\t\t__format->colorspace, __format->ycbcr_enc);\n\t__format->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(__format->colorspace);\n\n\tformat->format = *__format;\n\n\tmutex_unlock(&imx214->mutex);\n\n\treturn 0;\n}\n\nstatic int imx214_get_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct imx214 *imx214 = to_imx214(sd);\n\n\tif (sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&imx214->mutex);\n\tsel->r = *__imx214_get_pad_crop(imx214, sd_state, sel->pad,\n\t\t\t\t\tsel->which);\n\tmutex_unlock(&imx214->mutex);\n\treturn 0;\n}\n\nstatic int imx214_entity_init_cfg(struct v4l2_subdev *subdev,\n\t\t\t\t  struct v4l2_subdev_state *sd_state)\n{\n\tstruct v4l2_subdev_format fmt = { };\n\n\tfmt.which = sd_state ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\n\tfmt.format.width = imx214_modes[0].width;\n\tfmt.format.height = imx214_modes[0].height;\n\n\timx214_set_format(subdev, sd_state, &fmt);\n\n\treturn 0;\n}\n\nstatic int imx214_set_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct imx214 *imx214 = container_of(ctrl->handler,\n\t\t\t\t\t     struct imx214, ctrls);\n\tu8 vals[2];\n\tint ret;\n\n\t \n\tif (!pm_runtime_get_if_in_use(imx214->dev))\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE:\n\t\tvals[1] = ctrl->val;\n\t\tvals[0] = ctrl->val >> 8;\n\t\tret = regmap_bulk_write(imx214->regmap, 0x202, vals, 2);\n\t\tif (ret < 0)\n\t\t\tdev_err(imx214->dev, \"Error %d\\n\", ret);\n\t\tret = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tpm_runtime_put(imx214->dev);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops imx214_ctrl_ops = {\n\t.s_ctrl = imx214_set_ctrl,\n};\n\n#define MAX_CMD 4\nstatic int imx214_write_table(struct imx214 *imx214,\n\t\t\t      const struct reg_8 table[])\n{\n\tu8 vals[MAX_CMD];\n\tint i;\n\tint ret;\n\n\tfor (; table->addr != IMX214_TABLE_END ; table++) {\n\t\tif (table->addr == IMX214_TABLE_WAIT_MS) {\n\t\t\tusleep_range(table->val * 1000,\n\t\t\t\t     table->val * 1000 + 500);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < MAX_CMD; i++) {\n\t\t\tif (table[i].addr != (table[0].addr + i))\n\t\t\t\tbreak;\n\t\t\tvals[i] = table[i].val;\n\t\t}\n\n\t\tret = regmap_bulk_write(imx214->regmap, table->addr, vals, i);\n\n\t\tif (ret) {\n\t\t\tdev_err(imx214->dev, \"write_table error: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\ttable += i - 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int imx214_start_streaming(struct imx214 *imx214)\n{\n\tconst struct imx214_mode *mode;\n\tint ret;\n\n\tmutex_lock(&imx214->mutex);\n\tret = imx214_write_table(imx214, mode_table_common);\n\tif (ret < 0) {\n\t\tdev_err(imx214->dev, \"could not sent common table %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tmode = v4l2_find_nearest_size(imx214_modes,\n\t\t\t\tARRAY_SIZE(imx214_modes), width, height,\n\t\t\t\timx214->fmt.width, imx214->fmt.height);\n\tret = imx214_write_table(imx214, mode->reg_table);\n\tif (ret < 0) {\n\t\tdev_err(imx214->dev, \"could not sent mode table %d\\n\", ret);\n\t\tgoto error;\n\t}\n\tret = __v4l2_ctrl_handler_setup(&imx214->ctrls);\n\tif (ret < 0) {\n\t\tdev_err(imx214->dev, \"could not sync v4l2 controls\\n\");\n\t\tgoto error;\n\t}\n\tret = regmap_write(imx214->regmap, 0x100, 1);\n\tif (ret < 0) {\n\t\tdev_err(imx214->dev, \"could not sent start table %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tmutex_unlock(&imx214->mutex);\n\treturn 0;\n\nerror:\n\tmutex_unlock(&imx214->mutex);\n\treturn ret;\n}\n\nstatic int imx214_stop_streaming(struct imx214 *imx214)\n{\n\tint ret;\n\n\tret = regmap_write(imx214->regmap, 0x100, 0);\n\tif (ret < 0)\n\t\tdev_err(imx214->dev, \"could not sent stop table %d\\n\",\tret);\n\n\treturn ret;\n}\n\nstatic int imx214_s_stream(struct v4l2_subdev *subdev, int enable)\n{\n\tstruct imx214 *imx214 = to_imx214(subdev);\n\tint ret;\n\n\tif (imx214->streaming == enable)\n\t\treturn 0;\n\n\tif (enable) {\n\t\tret = pm_runtime_resume_and_get(imx214->dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = imx214_start_streaming(imx214);\n\t\tif (ret < 0)\n\t\t\tgoto err_rpm_put;\n\t} else {\n\t\tret = imx214_stop_streaming(imx214);\n\t\tif (ret < 0)\n\t\t\tgoto err_rpm_put;\n\t\tpm_runtime_put(imx214->dev);\n\t}\n\n\timx214->streaming = enable;\n\treturn 0;\n\nerr_rpm_put:\n\tpm_runtime_put(imx214->dev);\n\treturn ret;\n}\n\nstatic int imx214_g_frame_interval(struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_subdev_frame_interval *fival)\n{\n\tfival->interval.numerator = 1;\n\tfival->interval.denominator = IMX214_FPS;\n\n\treturn 0;\n}\n\nstatic int imx214_enum_frame_interval(struct v4l2_subdev *subdev,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_frame_interval_enum *fie)\n{\n\tconst struct imx214_mode *mode;\n\n\tif (fie->index != 0)\n\t\treturn -EINVAL;\n\n\tmode = v4l2_find_nearest_size(imx214_modes,\n\t\t\t\tARRAY_SIZE(imx214_modes), width, height,\n\t\t\t\tfie->width, fie->height);\n\n\tfie->code = IMX214_MBUS_CODE;\n\tfie->width = mode->width;\n\tfie->height = mode->height;\n\tfie->interval.numerator = 1;\n\tfie->interval.denominator = IMX214_FPS;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops imx214_video_ops = {\n\t.s_stream = imx214_s_stream,\n\t.g_frame_interval = imx214_g_frame_interval,\n\t.s_frame_interval = imx214_g_frame_interval,\n};\n\nstatic const struct v4l2_subdev_pad_ops imx214_subdev_pad_ops = {\n\t.enum_mbus_code = imx214_enum_mbus_code,\n\t.enum_frame_size = imx214_enum_frame_size,\n\t.enum_frame_interval = imx214_enum_frame_interval,\n\t.get_fmt = imx214_get_format,\n\t.set_fmt = imx214_set_format,\n\t.get_selection = imx214_get_selection,\n\t.init_cfg = imx214_entity_init_cfg,\n};\n\nstatic const struct v4l2_subdev_ops imx214_subdev_ops = {\n\t.core = &imx214_core_ops,\n\t.video = &imx214_video_ops,\n\t.pad = &imx214_subdev_pad_ops,\n};\n\nstatic const struct regmap_config sensor_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic int imx214_get_regulators(struct device *dev, struct imx214 *imx214)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < IMX214_NUM_SUPPLIES; i++)\n\t\timx214->supplies[i].supply = imx214_supply_name[i];\n\n\treturn devm_regulator_bulk_get(dev, IMX214_NUM_SUPPLIES,\n\t\t\t\t       imx214->supplies);\n}\n\nstatic int imx214_parse_fwnode(struct device *dev)\n{\n\tstruct fwnode_handle *endpoint;\n\tstruct v4l2_fwnode_endpoint bus_cfg = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY,\n\t};\n\tunsigned int i;\n\tint ret;\n\n\tendpoint = fwnode_graph_get_next_endpoint(dev_fwnode(dev), NULL);\n\tif (!endpoint) {\n\t\tdev_err(dev, \"endpoint node not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = v4l2_fwnode_endpoint_alloc_parse(endpoint, &bus_cfg);\n\tif (ret) {\n\t\tdev_err(dev, \"parsing endpoint node failed\\n\");\n\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < bus_cfg.nr_of_link_frequencies; i++)\n\t\tif (bus_cfg.link_frequencies[i] == IMX214_DEFAULT_LINK_FREQ)\n\t\t\tbreak;\n\n\tif (i == bus_cfg.nr_of_link_frequencies) {\n\t\tdev_err(dev, \"link-frequencies %d not supported, Please review your DT\\n\",\n\t\t\tIMX214_DEFAULT_LINK_FREQ);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\ndone:\n\tv4l2_fwnode_endpoint_free(&bus_cfg);\n\tfwnode_handle_put(endpoint);\n\treturn ret;\n}\n\nstatic int __maybe_unused imx214_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct imx214 *imx214 = to_imx214(sd);\n\n\tif (imx214->streaming)\n\t\timx214_stop_streaming(imx214);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused imx214_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct imx214 *imx214 = to_imx214(sd);\n\tint ret;\n\n\tif (imx214->streaming) {\n\t\tret = imx214_start_streaming(imx214);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\timx214_stop_streaming(imx214);\n\timx214->streaming = 0;\n\treturn ret;\n}\n\nstatic int imx214_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct imx214 *imx214;\n\tstatic const s64 link_freq[] = {\n\t\tIMX214_DEFAULT_LINK_FREQ,\n\t};\n\tstatic const struct v4l2_area unit_size = {\n\t\t.width = 1120,\n\t\t.height = 1120,\n\t};\n\tint ret;\n\n\tret = imx214_parse_fwnode(dev);\n\tif (ret)\n\t\treturn ret;\n\n\timx214 = devm_kzalloc(dev, sizeof(*imx214), GFP_KERNEL);\n\tif (!imx214)\n\t\treturn -ENOMEM;\n\n\timx214->dev = dev;\n\n\timx214->xclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(imx214->xclk)) {\n\t\tdev_err(dev, \"could not get xclk\");\n\t\treturn PTR_ERR(imx214->xclk);\n\t}\n\n\tret = clk_set_rate(imx214->xclk, IMX214_DEFAULT_CLK_FREQ);\n\tif (ret) {\n\t\tdev_err(dev, \"could not set xclk frequency\\n\");\n\t\treturn ret;\n\t}\n\n\tret = imx214_get_regulators(dev, imx214);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"cannot get regulators\\n\");\n\t\treturn ret;\n\t}\n\n\timx214->enable_gpio = devm_gpiod_get(dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(imx214->enable_gpio)) {\n\t\tdev_err(dev, \"cannot get enable gpio\\n\");\n\t\treturn PTR_ERR(imx214->enable_gpio);\n\t}\n\n\timx214->regmap = devm_regmap_init_i2c(client, &sensor_regmap_config);\n\tif (IS_ERR(imx214->regmap)) {\n\t\tdev_err(dev, \"regmap init failed\\n\");\n\t\treturn PTR_ERR(imx214->regmap);\n\t}\n\n\tv4l2_i2c_subdev_init(&imx214->sd, client, &imx214_subdev_ops);\n\n\t \n\timx214_power_on(imx214->dev);\n\n\tpm_runtime_set_active(imx214->dev);\n\tpm_runtime_enable(imx214->dev);\n\tpm_runtime_idle(imx214->dev);\n\n\tv4l2_ctrl_handler_init(&imx214->ctrls, 3);\n\n\timx214->pixel_rate = v4l2_ctrl_new_std(&imx214->ctrls, NULL,\n\t\t\t\t\t       V4L2_CID_PIXEL_RATE, 0,\n\t\t\t\t\t       IMX214_DEFAULT_PIXEL_RATE, 1,\n\t\t\t\t\t       IMX214_DEFAULT_PIXEL_RATE);\n\timx214->link_freq = v4l2_ctrl_new_int_menu(&imx214->ctrls, NULL,\n\t\t\t\t\t\t   V4L2_CID_LINK_FREQ,\n\t\t\t\t\t\t   ARRAY_SIZE(link_freq) - 1,\n\t\t\t\t\t\t   0, link_freq);\n\tif (imx214->link_freq)\n\t\timx214->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\t \n\timx214->exposure = v4l2_ctrl_new_std(&imx214->ctrls, &imx214_ctrl_ops,\n\t\t\t\t\t     V4L2_CID_EXPOSURE,\n\t\t\t\t\t     0, 3184, 1, 0x0c70);\n\n\timx214->unit_size = v4l2_ctrl_new_std_compound(&imx214->ctrls,\n\t\t\t\tNULL,\n\t\t\t\tV4L2_CID_UNIT_CELL_SIZE,\n\t\t\t\tv4l2_ctrl_ptr_create((void *)&unit_size));\n\tret = imx214->ctrls.error;\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s control init failed (%d)\\n\",\n\t\t\t__func__, ret);\n\t\tgoto free_ctrl;\n\t}\n\n\timx214->sd.ctrl_handler = &imx214->ctrls;\n\tmutex_init(&imx214->mutex);\n\timx214->ctrls.lock = &imx214->mutex;\n\n\timx214->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\timx214->pad.flags = MEDIA_PAD_FL_SOURCE;\n\timx214->sd.dev = &client->dev;\n\timx214->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\n\tret = media_entity_pads_init(&imx214->sd.entity, 1, &imx214->pad);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not register media entity\\n\");\n\t\tgoto free_ctrl;\n\t}\n\n\timx214_entity_init_cfg(&imx214->sd, NULL);\n\n\tret = v4l2_async_register_subdev_sensor(&imx214->sd);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not register v4l2 device\\n\");\n\t\tgoto free_entity;\n\t}\n\n\treturn 0;\n\nfree_entity:\n\tmedia_entity_cleanup(&imx214->sd.entity);\nfree_ctrl:\n\tmutex_destroy(&imx214->mutex);\n\tv4l2_ctrl_handler_free(&imx214->ctrls);\n\tpm_runtime_disable(imx214->dev);\n\n\treturn ret;\n}\n\nstatic void imx214_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct imx214 *imx214 = to_imx214(sd);\n\n\tv4l2_async_unregister_subdev(&imx214->sd);\n\tmedia_entity_cleanup(&imx214->sd.entity);\n\tv4l2_ctrl_handler_free(&imx214->ctrls);\n\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\n\tmutex_destroy(&imx214->mutex);\n}\n\nstatic const struct of_device_id imx214_of_match[] = {\n\t{ .compatible = \"sony,imx214\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, imx214_of_match);\n\nstatic const struct dev_pm_ops imx214_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(imx214_suspend, imx214_resume)\n\tSET_RUNTIME_PM_OPS(imx214_power_off, imx214_power_on, NULL)\n};\n\nstatic struct i2c_driver imx214_i2c_driver = {\n\t.driver = {\n\t\t.of_match_table = imx214_of_match,\n\t\t.pm = &imx214_pm_ops,\n\t\t.name  = \"imx214\",\n\t},\n\t.probe = imx214_probe,\n\t.remove = imx214_remove,\n};\n\nmodule_i2c_driver(imx214_i2c_driver);\n\nMODULE_DESCRIPTION(\"Sony IMX214 Camera driver\");\nMODULE_AUTHOR(\"Ricardo Ribalda <ribalda@kernel.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}