{
  "module_name": "msp3400-driver.c",
  "hash_id": "08330a130e89b1b3a9099c1600c58c1a4be61b96583ee2f389fec8ef3f39d6c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/msp3400-driver.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/drv-intf/msp3400.h>\n#include <media/i2c/tvaudio.h>\n#include \"msp3400-driver.h\"\n\n \n\nMODULE_DESCRIPTION(\"device driver for msp34xx TV sound processor\");\nMODULE_AUTHOR(\"Gerd Knorr\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic int opmode   = OPMODE_AUTO;\nint msp_debug;\t\t  \nbool msp_once;\t\t  \nbool msp_amsound;\t  \nint msp_standard = 1;     \nbool msp_dolby;\n\nint msp_stereo_thresh = 0x190;  \n\n \nmodule_param(opmode,           int, 0444);\n\n \nmodule_param_named(once, msp_once,                      bool, 0644);\nmodule_param_named(debug, msp_debug,                    int,  0644);\nmodule_param_named(stereo_threshold, msp_stereo_thresh, int,  0644);\nmodule_param_named(standard, msp_standard,              int,  0644);\nmodule_param_named(amsound, msp_amsound,                bool, 0644);\nmodule_param_named(dolby, msp_dolby,                    bool, 0644);\n\nMODULE_PARM_DESC(opmode, \"Forces a MSP3400 opmode. 0=Manual, 1=Autodetect, 2=Autodetect and autoselect\");\nMODULE_PARM_DESC(once, \"No continuous stereo monitoring\");\nMODULE_PARM_DESC(debug, \"Enable debug messages [0-3]\");\nMODULE_PARM_DESC(stereo_threshold, \"Sets signal threshold to activate stereo\");\nMODULE_PARM_DESC(standard, \"Specify audio standard: 32 = NTSC, 64 = radio, Default: Autodetect\");\nMODULE_PARM_DESC(amsound, \"Hardwire AM sound at 6.5Hz (France), FM can autoscan\");\nMODULE_PARM_DESC(dolby, \"Activates Dolby processing\");\n\n \n\n \n#define I2C_MSP_CONTROL 0x00\n \n#define I2C_MSP_DEM     0x10\n \n#define I2C_MSP_DSP     0x12\n\n\n \n \n\nint msp_reset(struct i2c_client *client)\n{\n\t \n\tstatic u8 reset_off[3] = { I2C_MSP_CONTROL, 0x80, 0x00 };\n\tstatic u8 reset_on[3]  = { I2C_MSP_CONTROL, 0x00, 0x00 };\n\tstatic u8 write[3]     = { I2C_MSP_DSP + 1, 0x00, 0x1e };\n\tu8 read[2];\n\tstruct i2c_msg reset[2] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_IGNORE_NAK,\n\t\t\t.len = 3,\n\t\t\t.buf = reset_off\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_IGNORE_NAK,\n\t\t\t.len = 3,\n\t\t\t.buf = reset_on\n\t\t},\n\t};\n\tstruct i2c_msg test[2] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.len = 3,\n\t\t\t.buf = write\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 2,\n\t\t\t.buf = read\n\t\t},\n\t};\n\n\tdev_dbg_lvl(&client->dev, 3, msp_debug, \"msp_reset\\n\");\n\tif (i2c_transfer(client->adapter, &reset[0], 1) != 1 ||\n\t    i2c_transfer(client->adapter, &reset[1], 1) != 1 ||\n\t    i2c_transfer(client->adapter, test, 2) != 2) {\n\t\tdev_err(&client->dev, \"chip reset failed\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int msp_read(struct i2c_client *client, int dev, int addr)\n{\n\tint err, retval;\n\tu8 write[3];\n\tu8 read[2];\n\tstruct i2c_msg msgs[2] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.len = 3,\n\t\t\t.buf = write\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 2,\n\t\t\t.buf = read\n\t\t}\n\t};\n\n\twrite[0] = dev + 1;\n\twrite[1] = addr >> 8;\n\twrite[2] = addr & 0xff;\n\n\tfor (err = 0; err < 3; err++) {\n\t\tif (i2c_transfer(client->adapter, msgs, 2) == 2)\n\t\t\tbreak;\n\t\tdev_warn(&client->dev, \"I/O error #%d (read 0x%02x/0x%02x)\\n\", err,\n\t\t       dev, addr);\n\t\tschedule_timeout_interruptible(msecs_to_jiffies(10));\n\t}\n\tif (err == 3) {\n\t\tdev_warn(&client->dev, \"resetting chip, sound will go off.\\n\");\n\t\tmsp_reset(client);\n\t\treturn -1;\n\t}\n\tretval = read[0] << 8 | read[1];\n\tdev_dbg_lvl(&client->dev, 3, msp_debug, \"msp_read(0x%x, 0x%x): 0x%x\\n\",\n\t\t\tdev, addr, retval);\n\treturn retval;\n}\n\nint msp_read_dem(struct i2c_client *client, int addr)\n{\n\treturn msp_read(client, I2C_MSP_DEM, addr);\n}\n\nint msp_read_dsp(struct i2c_client *client, int addr)\n{\n\treturn msp_read(client, I2C_MSP_DSP, addr);\n}\n\nstatic int msp_write(struct i2c_client *client, int dev, int addr, int val)\n{\n\tint err;\n\tu8 buffer[5];\n\n\tbuffer[0] = dev;\n\tbuffer[1] = addr >> 8;\n\tbuffer[2] = addr &  0xff;\n\tbuffer[3] = val  >> 8;\n\tbuffer[4] = val  &  0xff;\n\n\tdev_dbg_lvl(&client->dev, 3, msp_debug, \"msp_write(0x%x, 0x%x, 0x%x)\\n\",\n\t\t\tdev, addr, val);\n\tfor (err = 0; err < 3; err++) {\n\t\tif (i2c_master_send(client, buffer, 5) == 5)\n\t\t\tbreak;\n\t\tdev_warn(&client->dev, \"I/O error #%d (write 0x%02x/0x%02x)\\n\", err,\n\t\t       dev, addr);\n\t\tschedule_timeout_interruptible(msecs_to_jiffies(10));\n\t}\n\tif (err == 3) {\n\t\tdev_warn(&client->dev, \"resetting chip, sound will go off.\\n\");\n\t\tmsp_reset(client);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint msp_write_dem(struct i2c_client *client, int addr, int val)\n{\n\treturn msp_write(client, I2C_MSP_DEM, addr, val);\n}\n\nint msp_write_dsp(struct i2c_client *client, int addr, int val)\n{\n\treturn msp_write(client, I2C_MSP_DSP, addr, val);\n}\n\n \n\nstatic int scarts[3][9] = {\n\t \n\t \n\t{ 0x0320, 0x0000, 0x0200, 0x0300, 0x0020, -1,     -1,     0x0100, 0x0320 },\n\t \n\t{ 0x0c40, 0x0440, 0x0400, 0x0000, 0x0840, 0x0c00, 0x0040, 0x0800, 0x0c40 },\n\t \n\t{ 0x3080, 0x1000, 0x1080, 0x2080, 0x3080, 0x0000, 0x0080, 0x2000, 0x3000 },\n};\n\nstatic char *scart_names[] = {\n\t\"in1\", \"in2\", \"in3\", \"in4\", \"in1 da\", \"in2 da\", \"mono\", \"mute\"\n};\n\nvoid msp_set_scart(struct i2c_client *client, int in, int out)\n{\n\tstruct msp_state *state = to_state(i2c_get_clientdata(client));\n\n\tstate->in_scart = in;\n\n\tif (in >= 0 && in <= 7 && out >= 0 && out <= 2) {\n\t\tif (-1 == scarts[out][in + 1])\n\t\t\treturn;\n\n\t\tstate->acb &= ~scarts[out][0];\n\t\tstate->acb |=  scarts[out][in + 1];\n\t} else\n\t\tstate->acb = 0xf60;  \n\n\tdev_dbg_lvl(&client->dev, 1, msp_debug, \"scart switch: %s => %d (ACB=0x%04x)\\n\",\n\t\t\t\t\tscart_names[in], out, state->acb);\n\tmsp_write_dsp(client, 0x13, state->acb);\n\n\t \n\tif (state->has_i2s_conf)\n\t\tmsp_write_dem(client, 0x40, state->i2s_mode);\n}\n\n \n\nstatic void msp_wake_thread(struct i2c_client *client)\n{\n\tstruct msp_state *state = to_state(i2c_get_clientdata(client));\n\n\tif (NULL == state->kthread)\n\t\treturn;\n\tstate->watch_stereo = 0;\n\tstate->restart = 1;\n\twake_up_interruptible(&state->wq);\n}\n\nint msp_sleep(struct msp_state *state, int timeout)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue(&state->wq, &wait);\n\tif (!kthread_should_stop()) {\n\t\tif (timeout < 0) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule();\n\t\t} else {\n\t\t\tschedule_timeout_interruptible\n\t\t\t\t\t\t(msecs_to_jiffies(timeout));\n\t\t}\n\t}\n\n\tremove_wait_queue(&state->wq, &wait);\n\ttry_to_freeze();\n\treturn state->restart;\n}\n\n \n\nstatic int msp_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct msp_state *state = ctrl_to_state(ctrl);\n\tstruct i2c_client *client = v4l2_get_subdevdata(&state->sd);\n\tint val = ctrl->val;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_VOLUME: {\n\t\t \n\t\tint reallymuted = state->muted->val | state->scan_in_progress;\n\n\t\tif (!reallymuted)\n\t\t\tval = (val * 0x7f / 65535) << 8;\n\n\t\tdev_dbg_lvl(&client->dev, 1, msp_debug, \"mute=%s scanning=%s volume=%d\\n\",\n\t\t\t\tstate->muted->val ? \"on\" : \"off\",\n\t\t\t\tstate->scan_in_progress ? \"yes\" : \"no\",\n\t\t\t\tstate->volume->val);\n\n\t\tmsp_write_dsp(client, 0x0000, val);\n\t\tmsp_write_dsp(client, 0x0007, reallymuted ? 0x1 : (val | 0x1));\n\t\tif (state->has_scart2_out_volume)\n\t\t\tmsp_write_dsp(client, 0x0040, reallymuted ? 0x1 : (val | 0x1));\n\t\tif (state->has_headphones)\n\t\t\tmsp_write_dsp(client, 0x0006, val);\n\t\tbreak;\n\t}\n\n\tcase V4L2_CID_AUDIO_BASS:\n\t\tval = ((val - 32768) * 0x60 / 65535) << 8;\n\t\tmsp_write_dsp(client, 0x0002, val);\n\t\tif (state->has_headphones)\n\t\t\tmsp_write_dsp(client, 0x0031, val);\n\t\tbreak;\n\n\tcase V4L2_CID_AUDIO_TREBLE:\n\t\tval = ((val - 32768) * 0x60 / 65535) << 8;\n\t\tmsp_write_dsp(client, 0x0003, val);\n\t\tif (state->has_headphones)\n\t\t\tmsp_write_dsp(client, 0x0032, val);\n\t\tbreak;\n\n\tcase V4L2_CID_AUDIO_LOUDNESS:\n\t\tval = val ? ((5 * 4) << 8) : 0;\n\t\tmsp_write_dsp(client, 0x0004, val);\n\t\tif (state->has_headphones)\n\t\t\tmsp_write_dsp(client, 0x0033, val);\n\t\tbreak;\n\n\tcase V4L2_CID_AUDIO_BALANCE:\n\t\tval = (u8)((val / 256) - 128);\n\t\tmsp_write_dsp(client, 0x0001, val << 8);\n\t\tif (state->has_headphones)\n\t\t\tmsp_write_dsp(client, 0x0030, val << 8);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nvoid msp_update_volume(struct msp_state *state)\n{\n\t \n\tv4l2_ctrl_lock(state->volume);\n\tstate->volume->val = state->volume->cur.val;\n\tstate->muted->val = state->muted->cur.val;\n\tmsp_s_ctrl(state->volume);\n\tv4l2_ctrl_unlock(state->volume);\n}\n\n \nstatic int msp_s_radio(struct v4l2_subdev *sd)\n{\n\tstruct msp_state *state = to_state(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tif (state->radio)\n\t\treturn 0;\n\tstate->radio = 1;\n\tdev_dbg_lvl(&client->dev, 1, msp_debug, \"switching to radio mode\\n\");\n\tstate->watch_stereo = 0;\n\tswitch (state->opmode) {\n\tcase OPMODE_MANUAL:\n\t\t \n\t\tmsp3400c_set_mode(client, MSP_MODE_FM_RADIO);\n\t\tmsp3400c_set_carrier(client, MSP_CARRIER(10.7),\n\t\t\t\tMSP_CARRIER(10.7));\n\t\tmsp_update_volume(state);\n\t\tbreak;\n\tcase OPMODE_AUTODETECT:\n\tcase OPMODE_AUTOSELECT:\n\t\t \n\t\tmsp_wake_thread(client);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int msp_s_frequency(struct v4l2_subdev *sd, const struct v4l2_frequency *freq)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\t \n\tmsp_wake_thread(client);\n\treturn 0;\n}\n\nstatic int msp_querystd(struct v4l2_subdev *sd, v4l2_std_id *id)\n{\n\tstruct msp_state *state = to_state(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\t*id &= state->detected_std;\n\n\tdev_dbg_lvl(&client->dev, 2, msp_debug,\n\t\t\"detected standard: %s(0x%08Lx)\\n\",\n\t\tmsp_standard_std_name(state->std), state->detected_std);\n\n\treturn 0;\n}\n\nstatic int msp_s_std(struct v4l2_subdev *sd, v4l2_std_id id)\n{\n\tstruct msp_state *state = to_state(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint update = state->radio || state->v4l2_std != id;\n\n\tstate->v4l2_std = id;\n\tstate->radio = 0;\n\tif (update)\n\t\tmsp_wake_thread(client);\n\treturn 0;\n}\n\nstatic int msp_s_routing(struct v4l2_subdev *sd,\n\t\t\t u32 input, u32 output, u32 config)\n{\n\tstruct msp_state *state = to_state(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint tuner = (input >> 3) & 1;\n\tint sc_in = input & 0x7;\n\tint sc1_out = output & 0xf;\n\tint sc2_out = (output >> 4) & 0xf;\n\tu16 val, reg;\n\tint i;\n\tint extern_input = 1;\n\n\tif (state->route_in == input && state->route_out == output)\n\t\treturn 0;\n\tstate->route_in = input;\n\tstate->route_out = output;\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\tif (((input >> (4 + i * 4)) & 0xf) == 0)\n\t\t\textern_input = 0;\n\t}\n\tstate->mode = extern_input ? MSP_MODE_EXTERN : MSP_MODE_AM_DETECT;\n\tstate->rxsubchans = V4L2_TUNER_SUB_STEREO;\n\tmsp_set_scart(client, sc_in, 0);\n\tmsp_set_scart(client, sc1_out, 1);\n\tmsp_set_scart(client, sc2_out, 2);\n\tmsp_set_audmode(client);\n\treg = (state->opmode == OPMODE_AUTOSELECT) ? 0x30 : 0xbb;\n\tval = msp_read_dem(client, reg);\n\tmsp_write_dem(client, reg, (val & ~0x100) | (tuner << 8));\n\t \n\tmsp_wake_thread(client);\n\treturn 0;\n}\n\nstatic int msp_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\n{\n\tstruct msp_state *state = to_state(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tif (vt->type != V4L2_TUNER_ANALOG_TV)\n\t\treturn 0;\n\tif (!state->radio) {\n\t\tif (state->opmode == OPMODE_AUTOSELECT)\n\t\t\tmsp_detect_stereo(client);\n\t\tvt->rxsubchans = state->rxsubchans;\n\t}\n\tvt->audmode = state->audmode;\n\tvt->capability |= V4L2_TUNER_CAP_STEREO |\n\t\tV4L2_TUNER_CAP_LANG1 | V4L2_TUNER_CAP_LANG2;\n\treturn 0;\n}\n\nstatic int msp_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *vt)\n{\n\tstruct msp_state *state = to_state(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tif (state->radio)   \n\t\treturn 0;\n\tif (state->audmode == vt->audmode)\n\t\treturn 0;\n\tstate->audmode = vt->audmode;\n\t \n\tmsp_set_audmode(client);\n\treturn 0;\n}\n\nstatic int msp_s_i2s_clock_freq(struct v4l2_subdev *sd, u32 freq)\n{\n\tstruct msp_state *state = to_state(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tdev_dbg_lvl(&client->dev, 1, msp_debug, \"Setting I2S speed to %d\\n\", freq);\n\n\tswitch (freq) {\n\t\tcase 1024000:\n\t\t\tstate->i2s_mode = 0;\n\t\t\tbreak;\n\t\tcase 2048000:\n\t\t\tstate->i2s_mode = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int msp_log_status(struct v4l2_subdev *sd)\n{\n\tstruct msp_state *state = to_state(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tconst char *p;\n\tchar prefix[V4L2_SUBDEV_NAME_SIZE + 20];\n\n\tif (state->opmode == OPMODE_AUTOSELECT)\n\t\tmsp_detect_stereo(client);\n\tdev_info(&client->dev, \"%s rev1 = 0x%04x rev2 = 0x%04x\\n\",\n\t\t\tclient->name, state->rev1, state->rev2);\n\tsnprintf(prefix, sizeof(prefix), \"%s: Audio:    \", sd->name);\n\tv4l2_ctrl_handler_log_status(&state->hdl, prefix);\n\tswitch (state->mode) {\n\t\tcase MSP_MODE_AM_DETECT: p = \"AM (for carrier detect)\"; break;\n\t\tcase MSP_MODE_FM_RADIO: p = \"FM Radio\"; break;\n\t\tcase MSP_MODE_FM_TERRA: p = \"Terrestrial FM-mono/stereo\"; break;\n\t\tcase MSP_MODE_FM_SAT: p = \"Satellite FM-mono\"; break;\n\t\tcase MSP_MODE_FM_NICAM1: p = \"NICAM/FM (B/G, D/K)\"; break;\n\t\tcase MSP_MODE_FM_NICAM2: p = \"NICAM/FM (I)\"; break;\n\t\tcase MSP_MODE_AM_NICAM: p = \"NICAM/AM (L)\"; break;\n\t\tcase MSP_MODE_BTSC: p = \"BTSC\"; break;\n\t\tcase MSP_MODE_EXTERN: p = \"External input\"; break;\n\t\tdefault: p = \"unknown\"; break;\n\t}\n\tif (state->mode == MSP_MODE_EXTERN) {\n\t\tdev_info(&client->dev, \"Mode:     %s\\n\", p);\n\t} else if (state->opmode == OPMODE_MANUAL) {\n\t\tdev_info(&client->dev, \"Mode:     %s (%s%s)\\n\", p,\n\t\t\t\t(state->rxsubchans & V4L2_TUNER_SUB_STEREO) ? \"stereo\" : \"mono\",\n\t\t\t\t(state->rxsubchans & V4L2_TUNER_SUB_LANG2) ? \", dual\" : \"\");\n\t} else {\n\t\tif (state->opmode == OPMODE_AUTODETECT)\n\t\t\tdev_info(&client->dev, \"Mode:     %s\\n\", p);\n\t\tdev_info(&client->dev, \"Standard: %s (%s%s)\\n\",\n\t\t\t\tmsp_standard_std_name(state->std),\n\t\t\t\t(state->rxsubchans & V4L2_TUNER_SUB_STEREO) ? \"stereo\" : \"mono\",\n\t\t\t\t(state->rxsubchans & V4L2_TUNER_SUB_LANG2) ? \", dual\" : \"\");\n\t}\n\tdev_info(&client->dev, \"Audmode:  0x%04x\\n\", state->audmode);\n\tdev_info(&client->dev, \"Routing:  0x%08x (input) 0x%08x (output)\\n\",\n\t\t\tstate->route_in, state->route_out);\n\tdev_info(&client->dev, \"ACB:      0x%04x\\n\", state->acb);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int msp_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tdev_dbg_lvl(&client->dev, 1, msp_debug, \"suspend\\n\");\n\tmsp_reset(client);\n\treturn 0;\n}\n\nstatic int msp_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tdev_dbg_lvl(&client->dev, 1, msp_debug, \"resume\\n\");\n\tmsp_wake_thread(client);\n\treturn 0;\n}\n#endif\n\n \n\nstatic const struct v4l2_ctrl_ops msp_ctrl_ops = {\n\t.s_ctrl = msp_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops msp_core_ops = {\n\t.log_status = msp_log_status,\n};\n\nstatic const struct v4l2_subdev_video_ops msp_video_ops = {\n\t.s_std = msp_s_std,\n\t.querystd = msp_querystd,\n};\n\nstatic const struct v4l2_subdev_tuner_ops msp_tuner_ops = {\n\t.s_frequency = msp_s_frequency,\n\t.g_tuner = msp_g_tuner,\n\t.s_tuner = msp_s_tuner,\n\t.s_radio = msp_s_radio,\n};\n\nstatic const struct v4l2_subdev_audio_ops msp_audio_ops = {\n\t.s_routing = msp_s_routing,\n\t.s_i2s_clock_freq = msp_s_i2s_clock_freq,\n};\n\nstatic const struct v4l2_subdev_ops msp_ops = {\n\t.core = &msp_core_ops,\n\t.video = &msp_video_ops,\n\t.tuner = &msp_tuner_ops,\n\t.audio = &msp_audio_ops,\n};\n\n \n\n\nstatic const char * const opmode_str[] = {\n\t[OPMODE_MANUAL] = \"manual\",\n\t[OPMODE_AUTODETECT] = \"autodetect\",\n\t[OPMODE_AUTOSELECT] = \"autodetect and autoselect\",\n};\n\nstatic int msp_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct msp_state *state;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_ctrl_handler *hdl;\n\tint (*thread_func)(void *data) = NULL;\n\tint msp_hard;\n\tint msp_family;\n\tint msp_revision;\n\tint msp_product, msp_prod_hi, msp_prod_lo;\n\tint msp_rom;\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tint ret;\n#endif\n\n\tif (!id)\n\t\tstrscpy(client->name, \"msp3400\", sizeof(client->name));\n\n\tif (msp_reset(client) == -1) {\n\t\tdev_dbg_lvl(&client->dev, 1, msp_debug, \"msp3400 not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tstate = devm_kzalloc(&client->dev, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tsd = &state->sd;\n\tv4l2_i2c_subdev_init(sd, client, &msp_ops);\n\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tstate->pads[MSP3400_PAD_IF_INPUT].flags = MEDIA_PAD_FL_SINK;\n\tstate->pads[MSP3400_PAD_IF_INPUT].sig_type = PAD_SIGNAL_AUDIO;\n\tstate->pads[MSP3400_PAD_OUT].flags = MEDIA_PAD_FL_SOURCE;\n\tstate->pads[MSP3400_PAD_OUT].sig_type = PAD_SIGNAL_AUDIO;\n\n\tsd->entity.function = MEDIA_ENT_F_IF_AUD_DECODER;\n\n\tret = media_entity_pads_init(&sd->entity, 2, state->pads);\n\tif (ret < 0)\n\t\treturn ret;\n#endif\n\n\tstate->v4l2_std = V4L2_STD_NTSC;\n\tstate->detected_std = V4L2_STD_ALL;\n\tstate->audmode = V4L2_TUNER_MODE_STEREO;\n\tstate->input = -1;\n\tstate->i2s_mode = 0;\n\tinit_waitqueue_head(&state->wq);\n\t \n\tstate->route_in = MSP_INPUT_DEFAULT;\n\tstate->route_out = MSP_OUTPUT_DEFAULT;\n\n\tstate->rev1 = msp_read_dsp(client, 0x1e);\n\tif (state->rev1 != -1)\n\t\tstate->rev2 = msp_read_dsp(client, 0x1f);\n\tdev_dbg_lvl(&client->dev, 1, msp_debug, \"rev1=0x%04x, rev2=0x%04x\\n\",\n\t\t\tstate->rev1, state->rev2);\n\tif (state->rev1 == -1 || (state->rev1 == 0 && state->rev2 == 0)) {\n\t\tdev_dbg_lvl(&client->dev, 1, msp_debug,\n\t\t\t\t\"not an msp3400 (cannot read chip version)\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmsp_family = ((state->rev1 >> 4) & 0x0f) + 3;\n\tmsp_product = (state->rev2 >> 8) & 0xff;\n\tmsp_prod_hi = msp_product / 10;\n\tmsp_prod_lo = msp_product % 10;\n\tmsp_revision = (state->rev1 & 0x0f) + '@';\n\tmsp_hard = ((state->rev1 >> 8) & 0xff) + '@';\n\tmsp_rom = state->rev2 & 0x1f;\n\t \n\tstate->ident = msp_family * 10000 + 4000 + msp_product * 10 +\n\t\t\tmsp_revision - '@';\n\n\t \n\tstate->has_nicam =\n\t\tmsp_prod_hi == 1 || msp_prod_hi == 5;\n\t \n\tstate->has_radio =\n\t\tmsp_revision >= 'G';\n\t \n\tstate->has_headphones =\n\t\tmsp_prod_lo < 5;\n\t \n\tstate->has_scart2 =\n\t\tmsp_family >= 4 || msp_prod_lo < 7;\n\t \n\tstate->has_scart3 =\n\t\tmsp_family >= 4 || msp_prod_lo < 5;\n\t \n\tstate->has_scart4 =\n\t\tmsp_family >= 4 || (msp_revision >= 'D' && msp_prod_lo < 5);\n\t \n\tstate->has_scart2_out =\n\t\tmsp_family >= 4 || msp_prod_lo < 5;\n\t \n\tstate->has_scart2_out_volume =\n\t\tmsp_revision > 'C' && state->has_scart2_out;\n\t \n\tstate->has_i2s_conf =\n\t\tmsp_revision >= 'G' && msp_prod_lo < 7;\n\t \n\tstate->has_subwoofer =\n\t\tmsp_revision >= 'D' && msp_prod_lo < 5;\n\t \n\tstate->has_sound_processing =\n\t\tmsp_prod_lo < 7;\n\t \n\tstate->has_virtual_dolby_surround =\n\t\tmsp_revision == 'G' && msp_prod_lo == 1;\n\t \n\tstate->has_dolby_pro_logic =\n\t\tmsp_revision == 'G' && msp_prod_lo == 2;\n\t \n\tstate->force_btsc =\n\t\tmsp_family == 3 && msp_revision == 'G' && msp_prod_hi == 3;\n\n\tstate->opmode = opmode;\n\tif (state->opmode < OPMODE_MANUAL\n\t    || state->opmode > OPMODE_AUTOSELECT) {\n\t\t \n\t\tif (msp_revision >= 'G')\n\t\t\tstate->opmode = OPMODE_AUTOSELECT;\n\t\t \n\t\telse if (msp_revision >= 'D')\n\t\t\tstate->opmode = OPMODE_AUTODETECT;\n\t\telse\n\t\t\tstate->opmode = OPMODE_MANUAL;\n\t}\n\n\thdl = &state->hdl;\n\tv4l2_ctrl_handler_init(hdl, 6);\n\tif (state->has_sound_processing) {\n\t\tv4l2_ctrl_new_std(hdl, &msp_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_BASS, 0, 65535, 65535 / 100, 32768);\n\t\tv4l2_ctrl_new_std(hdl, &msp_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_TREBLE, 0, 65535, 65535 / 100, 32768);\n\t\tv4l2_ctrl_new_std(hdl, &msp_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_LOUDNESS, 0, 1, 1, 0);\n\t}\n\tstate->volume = v4l2_ctrl_new_std(hdl, &msp_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_VOLUME, 0, 65535, 65535 / 100, 58880);\n\tv4l2_ctrl_new_std(hdl, &msp_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_BALANCE, 0, 65535, 65535 / 100, 32768);\n\tstate->muted = v4l2_ctrl_new_std(hdl, &msp_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_MUTE, 0, 1, 1, 0);\n\tsd->ctrl_handler = hdl;\n\tif (hdl->error) {\n\t\tint err = hdl->error;\n\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\treturn err;\n\t}\n\n\tv4l2_ctrl_cluster(2, &state->volume);\n\tv4l2_ctrl_handler_setup(hdl);\n\n\tdev_info(&client->dev,\n\t\t \"MSP%d4%02d%c-%c%d found on %s: supports %s%s%s, mode is %s\\n\",\n\t\t msp_family, msp_product,\n\t\t msp_revision, msp_hard, msp_rom,\n\t\t client->adapter->name,\n\t\t (state->has_nicam) ? \"nicam\" : \"\",\n\t\t (state->has_nicam && state->has_radio) ? \" and \" : \"\",\n\t\t (state->has_radio) ? \"radio\" : \"\",\n\t\t opmode_str[state->opmode]);\n\n\t \n\tswitch (state->opmode) {\n\tcase OPMODE_MANUAL:\n\t\tthread_func = msp3400c_thread;\n\t\tbreak;\n\tcase OPMODE_AUTODETECT:\n\t\tthread_func = msp3410d_thread;\n\t\tbreak;\n\tcase OPMODE_AUTOSELECT:\n\t\tthread_func = msp34xxg_thread;\n\t\tbreak;\n\t}\n\n\t \n\tif (thread_func) {\n\t\tstate->kthread = kthread_run(thread_func, client, \"msp34xx\");\n\n\t\tif (IS_ERR(state->kthread))\n\t\t\tdev_warn(&client->dev, \"kernel_thread() failed\\n\");\n\t\tmsp_wake_thread(client);\n\t}\n\treturn 0;\n}\n\nstatic void msp_remove(struct i2c_client *client)\n{\n\tstruct msp_state *state = to_state(i2c_get_clientdata(client));\n\n\tv4l2_device_unregister_subdev(&state->sd);\n\t \n\tif (state->kthread) {\n\t\tstate->restart = 1;\n\t\tkthread_stop(state->kthread);\n\t}\n\tmsp_reset(client);\n\n\tv4l2_ctrl_handler_free(&state->hdl);\n}\n\n \n\nstatic const struct dev_pm_ops msp3400_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(msp_suspend, msp_resume)\n};\n\nstatic const struct i2c_device_id msp_id[] = {\n\t{ \"msp3400\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, msp_id);\n\nstatic struct i2c_driver msp_driver = {\n\t.driver = {\n\t\t.name\t= \"msp3400\",\n\t\t.pm\t= &msp3400_pm_ops,\n\t},\n\t.probe\t\t= msp_probe,\n\t.remove\t\t= msp_remove,\n\t.id_table\t= msp_id,\n};\n\nmodule_i2c_driver(msp_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}