{
  "module_name": "video-i2c.c",
  "hash_id": "bfb01f55447ba30672b3521112cf3a4f4a4c767926a8bb8124cc826c095308d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/video-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/hwmon.h>\n#include <linux/kthread.h>\n#include <linux/i2c.h>\n#include <linux/list.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/pm_runtime.h>\n#include <linux/nvmem-provider.h>\n#include <linux/regmap.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-vmalloc.h>\n\n#define VIDEO_I2C_DRIVER\t\"video-i2c\"\n\n \n#define AMG88XX_REG_PCTL\t0x00\n#define AMG88XX_PCTL_NORMAL\t\t0x00\n#define AMG88XX_PCTL_SLEEP\t\t0x10\n\n \n#define AMG88XX_REG_RST\t\t0x01\n#define AMG88XX_RST_FLAG\t\t0x30\n#define AMG88XX_RST_INIT\t\t0x3f\n\n \n#define AMG88XX_REG_FPSC\t0x02\n#define AMG88XX_FPSC_1FPS\t\tBIT(0)\n\n \n#define AMG88XX_REG_TTHL\t0x0e\n\n \n#define AMG88XX_REG_T01L\t0x80\n\n \n#define MLX90640_RAM_START_ADDR\t\t0x0400\n\n \n#define MLX90640_EEPROM_START_ADDR\t0x2400\n\n \n#define MLX90640_REG_CTL1\t\t0x800d\n#define MLX90640_REG_CTL1_MASK\t\tGENMASK(9, 7)\n#define MLX90640_REG_CTL1_MASK_SHIFT\t7\n\nstruct video_i2c_chip;\n\nstruct video_i2c_buffer {\n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head list;\n};\n\nstruct video_i2c_data {\n\tstruct regmap *regmap;\n\tconst struct video_i2c_chip *chip;\n\tstruct mutex lock;\n\tspinlock_t slock;\n\tunsigned int sequence;\n\tstruct mutex queue_lock;\n\n\tstruct v4l2_device v4l2_dev;\n\tstruct video_device vdev;\n\tstruct vb2_queue vb_vidq;\n\n\tstruct task_struct *kthread_vid_cap;\n\tstruct list_head vid_cap_active;\n\n\tstruct v4l2_fract frame_interval;\n};\n\nstatic const struct v4l2_fmtdesc amg88xx_format = {\n\t.pixelformat = V4L2_PIX_FMT_Y12,\n};\n\nstatic const struct v4l2_frmsize_discrete amg88xx_size = {\n\t.width = 8,\n\t.height = 8,\n};\n\nstatic const struct v4l2_fmtdesc mlx90640_format = {\n\t.pixelformat = V4L2_PIX_FMT_Y16_BE,\n};\n\nstatic const struct v4l2_frmsize_discrete mlx90640_size = {\n\t.width = 32,\n\t.height = 26,  \n};\n\nstatic const struct regmap_config amg88xx_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xff\n};\n\nstatic const struct regmap_config mlx90640_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 16,\n};\n\nstruct video_i2c_chip {\n\t \n\tconst struct v4l2_fmtdesc *format;\n\tconst struct v4l2_frmsize_discrete *size;\n\n\t \n\tconst struct v4l2_fract *frame_intervals;\n\tunsigned int num_frame_intervals;\n\n\t \n\tunsigned int buffer_size;\n\n\t \n\tunsigned int bpp;\n\n\tconst struct regmap_config *regmap_config;\n\tstruct nvmem_config *nvmem_config;\n\n\t \n\tint (*setup)(struct video_i2c_data *data);\n\n\t \n\tint (*xfer)(struct video_i2c_data *data, char *buf);\n\n\t \n\tint (*set_power)(struct video_i2c_data *data, bool on);\n\n\t \n\tint (*hwmon_init)(struct video_i2c_data *data);\n};\n\nstatic int mlx90640_nvram_read(void *priv, unsigned int offset, void *val,\n\t\t\t     size_t bytes)\n{\n\tstruct video_i2c_data *data = priv;\n\n\treturn regmap_bulk_read(data->regmap, MLX90640_EEPROM_START_ADDR + offset, val, bytes);\n}\n\nstatic struct nvmem_config mlx90640_nvram_config = {\n\t.name = \"mlx90640_nvram\",\n\t.word_size = 2,\n\t.stride = 1,\n\t.size = 1664,\n\t.reg_read = mlx90640_nvram_read,\n};\n\nstatic int amg88xx_xfer(struct video_i2c_data *data, char *buf)\n{\n\treturn regmap_bulk_read(data->regmap, AMG88XX_REG_T01L, buf,\n\t\t\t\tdata->chip->buffer_size);\n}\n\nstatic int mlx90640_xfer(struct video_i2c_data *data, char *buf)\n{\n\treturn regmap_bulk_read(data->regmap, MLX90640_RAM_START_ADDR, buf,\n\t\t\t\tdata->chip->buffer_size);\n}\n\nstatic int amg88xx_setup(struct video_i2c_data *data)\n{\n\tunsigned int mask = AMG88XX_FPSC_1FPS;\n\tunsigned int val;\n\n\tif (data->frame_interval.numerator == data->frame_interval.denominator)\n\t\tval = mask;\n\telse\n\t\tval = 0;\n\n\treturn regmap_update_bits(data->regmap, AMG88XX_REG_FPSC, mask, val);\n}\n\nstatic int mlx90640_setup(struct video_i2c_data *data)\n{\n\tunsigned int n, idx;\n\n\tfor (n = 0; n < data->chip->num_frame_intervals - 1; n++) {\n\t\tif (V4L2_FRACT_COMPARE(data->frame_interval, ==,\n\t\t\t\t       data->chip->frame_intervals[n]))\n\t\t\tbreak;\n\t}\n\n\tidx = data->chip->num_frame_intervals - n - 1;\n\n\treturn regmap_update_bits(data->regmap, MLX90640_REG_CTL1,\n\t\t\t\t  MLX90640_REG_CTL1_MASK,\n\t\t\t\t  idx << MLX90640_REG_CTL1_MASK_SHIFT);\n}\n\nstatic int amg88xx_set_power_on(struct video_i2c_data *data)\n{\n\tint ret;\n\n\tret = regmap_write(data->regmap, AMG88XX_REG_PCTL, AMG88XX_PCTL_NORMAL);\n\tif (ret)\n\t\treturn ret;\n\n\tmsleep(50);\n\n\tret = regmap_write(data->regmap, AMG88XX_REG_RST, AMG88XX_RST_INIT);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(2000, 3000);\n\n\tret = regmap_write(data->regmap, AMG88XX_REG_RST, AMG88XX_RST_FLAG);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmsleep(200);\n\n\treturn 0;\n}\n\nstatic int amg88xx_set_power_off(struct video_i2c_data *data)\n{\n\tint ret;\n\n\tret = regmap_write(data->regmap, AMG88XX_REG_PCTL, AMG88XX_PCTL_SLEEP);\n\tif (ret)\n\t\treturn ret;\n\t \n\tmsleep(100);\n\n\treturn 0;\n}\n\nstatic int amg88xx_set_power(struct video_i2c_data *data, bool on)\n{\n\tif (on)\n\t\treturn amg88xx_set_power_on(data);\n\n\treturn amg88xx_set_power_off(data);\n}\n\n#if IS_REACHABLE(CONFIG_HWMON)\n\nstatic const u32 amg88xx_temp_config[] = {\n\tHWMON_T_INPUT,\n\t0\n};\n\nstatic const struct hwmon_channel_info amg88xx_temp = {\n\t.type = hwmon_temp,\n\t.config = amg88xx_temp_config,\n};\n\nstatic const struct hwmon_channel_info * const amg88xx_info[] = {\n\t&amg88xx_temp,\n\tNULL\n};\n\nstatic umode_t amg88xx_is_visible(const void *drvdata,\n\t\t\t\t  enum hwmon_sensor_types type,\n\t\t\t\t  u32 attr, int channel)\n{\n\treturn 0444;\n}\n\nstatic int amg88xx_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\tu32 attr, int channel, long *val)\n{\n\tstruct video_i2c_data *data = dev_get_drvdata(dev);\n\t__le16 buf;\n\tint tmp;\n\n\ttmp = pm_runtime_resume_and_get(regmap_get_device(data->regmap));\n\tif (tmp < 0)\n\t\treturn tmp;\n\n\ttmp = regmap_bulk_read(data->regmap, AMG88XX_REG_TTHL, &buf, 2);\n\tpm_runtime_mark_last_busy(regmap_get_device(data->regmap));\n\tpm_runtime_put_autosuspend(regmap_get_device(data->regmap));\n\tif (tmp)\n\t\treturn tmp;\n\n\ttmp = le16_to_cpu(buf);\n\n\t \n\tif (tmp & BIT(11))\n\t\ttmp = -(tmp & 0x7ff);\n\n\t*val = (tmp * 625) / 10;\n\n\treturn 0;\n}\n\nstatic const struct hwmon_ops amg88xx_hwmon_ops = {\n\t.is_visible = amg88xx_is_visible,\n\t.read = amg88xx_read,\n};\n\nstatic const struct hwmon_chip_info amg88xx_chip_info = {\n\t.ops = &amg88xx_hwmon_ops,\n\t.info = amg88xx_info,\n};\n\nstatic int amg88xx_hwmon_init(struct video_i2c_data *data)\n{\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tvoid *hwmon = devm_hwmon_device_register_with_info(dev, \"amg88xx\", data,\n\t\t\t\t\t\t&amg88xx_chip_info, NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwmon);\n}\n#else\n#define\tamg88xx_hwmon_init\tNULL\n#endif\n\nenum {\n\tAMG88XX,\n\tMLX90640,\n};\n\nstatic const struct v4l2_fract amg88xx_frame_intervals[] = {\n\t{ 1, 10 },\n\t{ 1, 1 },\n};\n\nstatic const struct v4l2_fract mlx90640_frame_intervals[] = {\n\t{ 1, 64 },\n\t{ 1, 32 },\n\t{ 1, 16 },\n\t{ 1, 8 },\n\t{ 1, 4 },\n\t{ 1, 2 },\n\t{ 1, 1 },\n\t{ 2, 1 },\n};\n\nstatic const struct video_i2c_chip video_i2c_chip[] = {\n\t[AMG88XX] = {\n\t\t.size\t\t= &amg88xx_size,\n\t\t.format\t\t= &amg88xx_format,\n\t\t.frame_intervals\t= amg88xx_frame_intervals,\n\t\t.num_frame_intervals\t= ARRAY_SIZE(amg88xx_frame_intervals),\n\t\t.buffer_size\t= 128,\n\t\t.bpp\t\t= 16,\n\t\t.regmap_config\t= &amg88xx_regmap_config,\n\t\t.setup\t\t= &amg88xx_setup,\n\t\t.xfer\t\t= &amg88xx_xfer,\n\t\t.set_power\t= amg88xx_set_power,\n\t\t.hwmon_init\t= amg88xx_hwmon_init,\n\t},\n\t[MLX90640] = {\n\t\t.size\t\t= &mlx90640_size,\n\t\t.format\t\t= &mlx90640_format,\n\t\t.frame_intervals\t= mlx90640_frame_intervals,\n\t\t.num_frame_intervals\t= ARRAY_SIZE(mlx90640_frame_intervals),\n\t\t.buffer_size\t= 1664,\n\t\t.bpp\t\t= 16,\n\t\t.regmap_config\t= &mlx90640_regmap_config,\n\t\t.nvmem_config\t= &mlx90640_nvram_config,\n\t\t.setup\t\t= mlx90640_setup,\n\t\t.xfer\t\t= mlx90640_xfer,\n\t},\n};\n\nstatic const struct v4l2_file_operations video_i2c_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= v4l2_fh_open,\n\t.release\t= vb2_fop_release,\n\t.poll\t\t= vb2_fop_poll,\n\t.read\t\t= vb2_fop_read,\n\t.mmap\t\t= vb2_fop_mmap,\n\t.unlocked_ioctl = video_ioctl2,\n};\n\nstatic int queue_setup(struct vb2_queue *vq,\n\t\t       unsigned int *nbuffers, unsigned int *nplanes,\n\t\t       unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct video_i2c_data *data = vb2_get_drv_priv(vq);\n\tunsigned int size = data->chip->buffer_size;\n\n\tif (vq->num_buffers + *nbuffers < 2)\n\t\t*nbuffers = 2;\n\n\tif (*nplanes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t*nplanes = 1;\n\tsizes[0] = size;\n\n\treturn 0;\n}\n\nstatic int buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct video_i2c_data *data = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned int size = data->chip->buffer_size;\n\n\tif (vb2_plane_size(vb, 0) < size)\n\t\treturn -EINVAL;\n\n\tvbuf->field = V4L2_FIELD_NONE;\n\tvb2_set_plane_payload(vb, 0, size);\n\n\treturn 0;\n}\n\nstatic void buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct video_i2c_data *data = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct video_i2c_buffer *buf =\n\t\t\tcontainer_of(vbuf, struct video_i2c_buffer, vb);\n\n\tspin_lock(&data->slock);\n\tlist_add_tail(&buf->list, &data->vid_cap_active);\n\tspin_unlock(&data->slock);\n}\n\nstatic int video_i2c_thread_vid_cap(void *priv)\n{\n\tstruct video_i2c_data *data = priv;\n\tu32 delay = mult_frac(1000000UL, data->frame_interval.numerator,\n\t\t\t       data->frame_interval.denominator);\n\ts64 end_us = ktime_to_us(ktime_get());\n\n\tset_freezable();\n\n\tdo {\n\t\tstruct video_i2c_buffer *vid_cap_buf = NULL;\n\t\ts64 current_us;\n\t\tint schedule_delay;\n\n\t\ttry_to_freeze();\n\n\t\tspin_lock(&data->slock);\n\n\t\tif (!list_empty(&data->vid_cap_active)) {\n\t\t\tvid_cap_buf = list_last_entry(&data->vid_cap_active,\n\t\t\t\t\t\t struct video_i2c_buffer, list);\n\t\t\tlist_del(&vid_cap_buf->list);\n\t\t}\n\n\t\tspin_unlock(&data->slock);\n\n\t\tif (vid_cap_buf) {\n\t\t\tstruct vb2_buffer *vb2_buf = &vid_cap_buf->vb.vb2_buf;\n\t\t\tvoid *vbuf = vb2_plane_vaddr(vb2_buf, 0);\n\t\t\tint ret;\n\n\t\t\tret = data->chip->xfer(data, vbuf);\n\t\t\tvb2_buf->timestamp = ktime_get_ns();\n\t\t\tvid_cap_buf->vb.sequence = data->sequence++;\n\t\t\tvb2_buffer_done(vb2_buf, ret ?\n\t\t\t\tVB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\n\t\t}\n\n\t\tend_us += delay;\n\t\tcurrent_us = ktime_to_us(ktime_get());\n\t\tif (current_us < end_us) {\n\t\t\tschedule_delay = end_us - current_us;\n\t\t\tusleep_range(schedule_delay * 3 / 4, schedule_delay);\n\t\t} else {\n\t\t\tend_us = current_us;\n\t\t}\n\t} while (!kthread_should_stop());\n\n\treturn 0;\n}\n\nstatic void video_i2c_del_list(struct vb2_queue *vq, enum vb2_buffer_state state)\n{\n\tstruct video_i2c_data *data = vb2_get_drv_priv(vq);\n\tstruct video_i2c_buffer *buf, *tmp;\n\n\tspin_lock(&data->slock);\n\n\tlist_for_each_entry_safe(buf, tmp, &data->vid_cap_active, list) {\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t}\n\n\tspin_unlock(&data->slock);\n}\n\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct video_i2c_data *data = vb2_get_drv_priv(vq);\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tint ret;\n\n\tif (data->kthread_vid_cap)\n\t\treturn 0;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\tgoto error_del_list;\n\n\tret = data->chip->setup(data);\n\tif (ret)\n\t\tgoto error_rpm_put;\n\n\tdata->sequence = 0;\n\tdata->kthread_vid_cap = kthread_run(video_i2c_thread_vid_cap, data,\n\t\t\t\t\t    \"%s-vid-cap\", data->v4l2_dev.name);\n\tret = PTR_ERR_OR_ZERO(data->kthread_vid_cap);\n\tif (!ret)\n\t\treturn 0;\n\nerror_rpm_put:\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\nerror_del_list:\n\tvideo_i2c_del_list(vq, VB2_BUF_STATE_QUEUED);\n\n\treturn ret;\n}\n\nstatic void stop_streaming(struct vb2_queue *vq)\n{\n\tstruct video_i2c_data *data = vb2_get_drv_priv(vq);\n\n\tif (data->kthread_vid_cap == NULL)\n\t\treturn;\n\n\tkthread_stop(data->kthread_vid_cap);\n\tdata->kthread_vid_cap = NULL;\n\tpm_runtime_mark_last_busy(regmap_get_device(data->regmap));\n\tpm_runtime_put_autosuspend(regmap_get_device(data->regmap));\n\n\tvideo_i2c_del_list(vq, VB2_BUF_STATE_ERROR);\n}\n\nstatic const struct vb2_ops video_i2c_video_qops = {\n\t.queue_setup\t\t= queue_setup,\n\t.buf_prepare\t\t= buffer_prepare,\n\t.buf_queue\t\t= buffer_queue,\n\t.start_streaming\t= start_streaming,\n\t.stop_streaming\t\t= stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nstatic int video_i2c_querycap(struct file *file, void  *priv,\n\t\t\t\tstruct v4l2_capability *vcap)\n{\n\tstruct video_i2c_data *data = video_drvdata(file);\n\tstruct device *dev = regmap_get_device(data->regmap);\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tstrscpy(vcap->driver, data->v4l2_dev.name, sizeof(vcap->driver));\n\tstrscpy(vcap->card, data->vdev.name, sizeof(vcap->card));\n\n\tsprintf(vcap->bus_info, \"I2C:%d-%d\", client->adapter->nr, client->addr);\n\n\treturn 0;\n}\n\nstatic int video_i2c_g_input(struct file *file, void *fh, unsigned int *inp)\n{\n\t*inp = 0;\n\n\treturn 0;\n}\n\nstatic int video_i2c_s_input(struct file *file, void *fh, unsigned int inp)\n{\n\treturn (inp > 0) ? -EINVAL : 0;\n}\n\nstatic int video_i2c_enum_input(struct file *file, void *fh,\n\t\t\t\t  struct v4l2_input *vin)\n{\n\tif (vin->index > 0)\n\t\treturn -EINVAL;\n\n\tstrscpy(vin->name, \"Camera\", sizeof(vin->name));\n\n\tvin->type = V4L2_INPUT_TYPE_CAMERA;\n\n\treturn 0;\n}\n\nstatic int video_i2c_enum_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t\tstruct v4l2_fmtdesc *fmt)\n{\n\tstruct video_i2c_data *data = video_drvdata(file);\n\tenum v4l2_buf_type type = fmt->type;\n\n\tif (fmt->index > 0)\n\t\treturn -EINVAL;\n\n\t*fmt = *data->chip->format;\n\tfmt->type = type;\n\n\treturn 0;\n}\n\nstatic int video_i2c_enum_framesizes(struct file *file, void *fh,\n\t\t\t\t       struct v4l2_frmsizeenum *fsize)\n{\n\tconst struct video_i2c_data *data = video_drvdata(file);\n\tconst struct v4l2_frmsize_discrete *size = data->chip->size;\n\n\t \n\tif (fsize->index > 0)\n\t\treturn -EINVAL;\n\n\tif (fsize->pixel_format != data->chip->format->pixelformat)\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\tfsize->discrete.width = size->width;\n\tfsize->discrete.height = size->height;\n\n\treturn 0;\n}\n\nstatic int video_i2c_enum_frameintervals(struct file *file, void *priv,\n\t\t\t\t\t   struct v4l2_frmivalenum *fe)\n{\n\tconst struct video_i2c_data *data = video_drvdata(file);\n\tconst struct v4l2_frmsize_discrete *size = data->chip->size;\n\n\tif (fe->index >= data->chip->num_frame_intervals)\n\t\treturn -EINVAL;\n\n\tif (fe->width != size->width || fe->height != size->height)\n\t\treturn -EINVAL;\n\n\tfe->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\tfe->discrete = data->chip->frame_intervals[fe->index];\n\n\treturn 0;\n}\n\nstatic int video_i2c_try_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t       struct v4l2_format *fmt)\n{\n\tconst struct video_i2c_data *data = video_drvdata(file);\n\tconst struct v4l2_frmsize_discrete *size = data->chip->size;\n\tstruct v4l2_pix_format *pix = &fmt->fmt.pix;\n\tunsigned int bpp = data->chip->bpp / 8;\n\n\tpix->width = size->width;\n\tpix->height = size->height;\n\tpix->pixelformat = data->chip->format->pixelformat;\n\tpix->field = V4L2_FIELD_NONE;\n\tpix->bytesperline = pix->width * bpp;\n\tpix->sizeimage = pix->bytesperline * pix->height;\n\tpix->colorspace = V4L2_COLORSPACE_RAW;\n\n\treturn 0;\n}\n\nstatic int video_i2c_s_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t     struct v4l2_format *fmt)\n{\n\tstruct video_i2c_data *data = video_drvdata(file);\n\n\tif (vb2_is_busy(&data->vb_vidq))\n\t\treturn -EBUSY;\n\n\treturn video_i2c_try_fmt_vid_cap(file, fh, fmt);\n}\n\nstatic int video_i2c_g_parm(struct file *filp, void *priv,\n\t\t\t      struct v4l2_streamparm *parm)\n{\n\tstruct video_i2c_data *data = video_drvdata(filp);\n\n\tif (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tparm->parm.capture.readbuffers = 1;\n\tparm->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\n\tparm->parm.capture.timeperframe = data->frame_interval;\n\n\treturn 0;\n}\n\nstatic int video_i2c_s_parm(struct file *filp, void *priv,\n\t\t\t      struct v4l2_streamparm *parm)\n{\n\tstruct video_i2c_data *data = video_drvdata(filp);\n\tint i;\n\n\tfor (i = 0; i < data->chip->num_frame_intervals - 1; i++) {\n\t\tif (V4L2_FRACT_COMPARE(parm->parm.capture.timeperframe, <=,\n\t\t\t\t       data->chip->frame_intervals[i]))\n\t\t\tbreak;\n\t}\n\tdata->frame_interval = data->chip->frame_intervals[i];\n\n\treturn video_i2c_g_parm(filp, priv, parm);\n}\n\nstatic const struct v4l2_ioctl_ops video_i2c_ioctl_ops = {\n\t.vidioc_querycap\t\t= video_i2c_querycap,\n\t.vidioc_g_input\t\t\t= video_i2c_g_input,\n\t.vidioc_s_input\t\t\t= video_i2c_s_input,\n\t.vidioc_enum_input\t\t= video_i2c_enum_input,\n\t.vidioc_enum_fmt_vid_cap\t= video_i2c_enum_fmt_vid_cap,\n\t.vidioc_enum_framesizes\t\t= video_i2c_enum_framesizes,\n\t.vidioc_enum_frameintervals\t= video_i2c_enum_frameintervals,\n\t.vidioc_g_fmt_vid_cap\t\t= video_i2c_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= video_i2c_s_fmt_vid_cap,\n\t.vidioc_g_parm\t\t\t= video_i2c_g_parm,\n\t.vidioc_s_parm\t\t\t= video_i2c_s_parm,\n\t.vidioc_try_fmt_vid_cap\t\t= video_i2c_try_fmt_vid_cap,\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n};\n\nstatic void video_i2c_release(struct video_device *vdev)\n{\n\tstruct video_i2c_data *data = video_get_drvdata(vdev);\n\n\tv4l2_device_unregister(&data->v4l2_dev);\n\tmutex_destroy(&data->lock);\n\tmutex_destroy(&data->queue_lock);\n\tregmap_exit(data->regmap);\n\tkfree(data);\n}\n\nstatic int video_i2c_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct video_i2c_data *data;\n\tstruct v4l2_device *v4l2_dev;\n\tstruct vb2_queue *queue;\n\tint ret = -ENODEV;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tif (dev_fwnode(&client->dev))\n\t\tdata->chip = device_get_match_data(&client->dev);\n\telse if (id)\n\t\tdata->chip = &video_i2c_chip[id->driver_data];\n\telse\n\t\tgoto error_free_device;\n\n\tdata->regmap = regmap_init_i2c(client, data->chip->regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\tret = PTR_ERR(data->regmap);\n\t\tgoto error_free_device;\n\t}\n\n\tv4l2_dev = &data->v4l2_dev;\n\tstrscpy(v4l2_dev->name, VIDEO_I2C_DRIVER, sizeof(v4l2_dev->name));\n\n\tret = v4l2_device_register(&client->dev, v4l2_dev);\n\tif (ret < 0)\n\t\tgoto error_regmap_exit;\n\n\tmutex_init(&data->lock);\n\tmutex_init(&data->queue_lock);\n\n\tqueue = &data->vb_vidq;\n\tqueue->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tqueue->io_modes = VB2_DMABUF | VB2_MMAP | VB2_USERPTR | VB2_READ;\n\tqueue->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tqueue->drv_priv = data;\n\tqueue->buf_struct_size = sizeof(struct video_i2c_buffer);\n\tqueue->min_buffers_needed = 1;\n\tqueue->ops = &video_i2c_video_qops;\n\tqueue->mem_ops = &vb2_vmalloc_memops;\n\n\tret = vb2_queue_init(queue);\n\tif (ret < 0)\n\t\tgoto error_unregister_device;\n\n\tdata->vdev.queue = queue;\n\tdata->vdev.queue->lock = &data->queue_lock;\n\n\tsnprintf(data->vdev.name, sizeof(data->vdev.name),\n\t\t\t\t \"I2C %d-%d Transport Video\",\n\t\t\t\t client->adapter->nr, client->addr);\n\n\tdata->vdev.v4l2_dev = v4l2_dev;\n\tdata->vdev.fops = &video_i2c_fops;\n\tdata->vdev.lock = &data->lock;\n\tdata->vdev.ioctl_ops = &video_i2c_ioctl_ops;\n\tdata->vdev.release = video_i2c_release;\n\tdata->vdev.device_caps = V4L2_CAP_VIDEO_CAPTURE |\n\t\t\t\t V4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\n\n\tspin_lock_init(&data->slock);\n\tINIT_LIST_HEAD(&data->vid_cap_active);\n\n\tdata->frame_interval = data->chip->frame_intervals[0];\n\n\tvideo_set_drvdata(&data->vdev, data);\n\ti2c_set_clientdata(client, data);\n\n\tif (data->chip->set_power) {\n\t\tret = data->chip->set_power(data, true);\n\t\tif (ret)\n\t\t\tgoto error_unregister_device;\n\t}\n\n\tpm_runtime_get_noresume(&client->dev);\n\tpm_runtime_set_active(&client->dev);\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_set_autosuspend_delay(&client->dev, 2000);\n\tpm_runtime_use_autosuspend(&client->dev);\n\n\tif (data->chip->hwmon_init) {\n\t\tret = data->chip->hwmon_init(data);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(&client->dev,\n\t\t\t\t \"failed to register hwmon device\\n\");\n\t\t}\n\t}\n\n\tif (data->chip->nvmem_config) {\n\t\tstruct nvmem_config *config = data->chip->nvmem_config;\n\t\tstruct nvmem_device *device;\n\n\t\tconfig->priv = data;\n\t\tconfig->dev = &client->dev;\n\n\t\tdevice = devm_nvmem_register(&client->dev, config);\n\n\t\tif (IS_ERR(device)) {\n\t\t\tdev_warn(&client->dev,\n\t\t\t\t \"failed to register nvmem device\\n\");\n\t\t}\n\t}\n\n\tret = video_register_device(&data->vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret < 0)\n\t\tgoto error_pm_disable;\n\n\tpm_runtime_mark_last_busy(&client->dev);\n\tpm_runtime_put_autosuspend(&client->dev);\n\n\treturn 0;\n\nerror_pm_disable:\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\tpm_runtime_put_noidle(&client->dev);\n\n\tif (data->chip->set_power)\n\t\tdata->chip->set_power(data, false);\n\nerror_unregister_device:\n\tv4l2_device_unregister(v4l2_dev);\n\tmutex_destroy(&data->lock);\n\tmutex_destroy(&data->queue_lock);\n\nerror_regmap_exit:\n\tregmap_exit(data->regmap);\n\nerror_free_device:\n\tkfree(data);\n\n\treturn ret;\n}\n\nstatic void video_i2c_remove(struct i2c_client *client)\n{\n\tstruct video_i2c_data *data = i2c_get_clientdata(client);\n\n\tpm_runtime_get_sync(&client->dev);\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\tpm_runtime_put_noidle(&client->dev);\n\n\tif (data->chip->set_power)\n\t\tdata->chip->set_power(data, false);\n\n\tvideo_unregister_device(&data->vdev);\n}\n\n#ifdef CONFIG_PM\n\nstatic int video_i2c_pm_runtime_suspend(struct device *dev)\n{\n\tstruct video_i2c_data *data = i2c_get_clientdata(to_i2c_client(dev));\n\n\tif (!data->chip->set_power)\n\t\treturn 0;\n\n\treturn data->chip->set_power(data, false);\n}\n\nstatic int video_i2c_pm_runtime_resume(struct device *dev)\n{\n\tstruct video_i2c_data *data = i2c_get_clientdata(to_i2c_client(dev));\n\n\tif (!data->chip->set_power)\n\t\treturn 0;\n\n\treturn data->chip->set_power(data, true);\n}\n\n#endif\n\nstatic const struct dev_pm_ops video_i2c_pm_ops = {\n\tSET_RUNTIME_PM_OPS(video_i2c_pm_runtime_suspend,\n\t\t\t   video_i2c_pm_runtime_resume, NULL)\n};\n\nstatic const struct i2c_device_id video_i2c_id_table[] = {\n\t{ \"amg88xx\", AMG88XX },\n\t{ \"mlx90640\", MLX90640 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, video_i2c_id_table);\n\nstatic const struct of_device_id video_i2c_of_match[] = {\n\t{ .compatible = \"panasonic,amg88xx\", .data = &video_i2c_chip[AMG88XX] },\n\t{ .compatible = \"melexis,mlx90640\", .data = &video_i2c_chip[MLX90640] },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, video_i2c_of_match);\n\nstatic struct i2c_driver video_i2c_driver = {\n\t.driver = {\n\t\t.name\t= VIDEO_I2C_DRIVER,\n\t\t.of_match_table = video_i2c_of_match,\n\t\t.pm\t= &video_i2c_pm_ops,\n\t},\n\t.probe\t\t= video_i2c_probe,\n\t.remove\t\t= video_i2c_remove,\n\t.id_table\t= video_i2c_id_table,\n};\n\nmodule_i2c_driver(video_i2c_driver);\n\nMODULE_AUTHOR(\"Matt Ranostay <matt.ranostay@konsulko.com>\");\nMODULE_DESCRIPTION(\"I2C transport video support\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}