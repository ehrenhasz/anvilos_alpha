{
  "module_name": "s5k6a3.c",
  "hash_id": "eb574bd6210d0b7ee27619293b3c91533b7566291820cd911e000f64e14d6fa0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/s5k6a3.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-async.h>\n#include <media/v4l2-subdev.h>\n\n#define S5K6A3_SENSOR_MAX_WIDTH\t\t1412\n#define S5K6A3_SENSOR_MAX_HEIGHT\t1412\n#define S5K6A3_SENSOR_MIN_WIDTH\t\t32\n#define S5K6A3_SENSOR_MIN_HEIGHT\t32\n\n#define S5K6A3_DEFAULT_WIDTH\t\t1296\n#define S5K6A3_DEFAULT_HEIGHT\t\t732\n\n#define S5K6A3_DRV_NAME\t\t\t\"S5K6A3\"\n#define S5K6A3_CLK_NAME\t\t\t\"extclk\"\n#define S5K6A3_DEFAULT_CLK_FREQ\t\t24000000U\n\nenum {\n\tS5K6A3_SUPP_VDDA,\n\tS5K6A3_SUPP_VDDIO,\n\tS5K6A3_SUPP_AFVDD,\n\tS5K6A3_NUM_SUPPLIES,\n};\n\n \nstruct s5k6a3 {\n\tstruct device *dev;\n\tstruct v4l2_subdev subdev;\n\tstruct media_pad pad;\n\tstruct regulator_bulk_data supplies[S5K6A3_NUM_SUPPLIES];\n\tstruct gpio_desc *gpio_reset;\n\tstruct mutex lock;\n\tstruct v4l2_mbus_framefmt format;\n\tstruct clk *clock;\n\tu32 clock_frequency;\n\tint power_count;\n};\n\nstatic const char * const s5k6a3_supply_names[] = {\n\t[S5K6A3_SUPP_VDDA]\t= \"svdda\",\n\t[S5K6A3_SUPP_VDDIO]\t= \"svddio\",\n\t[S5K6A3_SUPP_AFVDD]\t= \"afvdd\",\n};\n\nstatic inline struct s5k6a3 *sd_to_s5k6a3(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct s5k6a3, subdev);\n}\n\nstatic const struct v4l2_mbus_framefmt s5k6a3_formats[] = {\n\t{\n\t\t.code = MEDIA_BUS_FMT_SGRBG10_1X10,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.field = V4L2_FIELD_NONE,\n\t}\n};\n\nstatic const struct v4l2_mbus_framefmt *find_sensor_format(\n\tstruct v4l2_mbus_framefmt *mf)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(s5k6a3_formats); i++)\n\t\tif (mf->code == s5k6a3_formats[i].code)\n\t\t\treturn &s5k6a3_formats[i];\n\n\treturn &s5k6a3_formats[0];\n}\n\nstatic int s5k6a3_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index >= ARRAY_SIZE(s5k6a3_formats))\n\t\treturn -EINVAL;\n\n\tcode->code = s5k6a3_formats[code->index].code;\n\treturn 0;\n}\n\nstatic void s5k6a3_try_format(struct v4l2_mbus_framefmt *mf)\n{\n\tconst struct v4l2_mbus_framefmt *fmt;\n\n\tfmt = find_sensor_format(mf);\n\tmf->code = fmt->code;\n\tmf->field = V4L2_FIELD_NONE;\n\tv4l_bound_align_image(&mf->width, S5K6A3_SENSOR_MIN_WIDTH,\n\t\t\t      S5K6A3_SENSOR_MAX_WIDTH, 0,\n\t\t\t      &mf->height, S5K6A3_SENSOR_MIN_HEIGHT,\n\t\t\t      S5K6A3_SENSOR_MAX_HEIGHT, 0, 0);\n}\n\nstatic struct v4l2_mbus_framefmt *__s5k6a3_get_format(\n\t\tstruct s5k6a3 *sensor, struct v4l2_subdev_state *sd_state,\n\t\tu32 pad, enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn sd_state ? v4l2_subdev_get_try_format(&sensor->subdev,\n\t\t\t\t\t\t\t     sd_state, pad) : NULL;\n\n\treturn &sensor->format;\n}\n\nstatic int s5k6a3_set_fmt(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_format *fmt)\n{\n\tstruct s5k6a3 *sensor = sd_to_s5k6a3(sd);\n\tstruct v4l2_mbus_framefmt *mf;\n\n\ts5k6a3_try_format(&fmt->format);\n\n\tmf = __s5k6a3_get_format(sensor, sd_state, fmt->pad, fmt->which);\n\tif (mf) {\n\t\tmutex_lock(&sensor->lock);\n\t\t*mf = fmt->format;\n\t\tmutex_unlock(&sensor->lock);\n\t}\n\treturn 0;\n}\n\nstatic int s5k6a3_get_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *fmt)\n{\n\tstruct s5k6a3 *sensor = sd_to_s5k6a3(sd);\n\tstruct v4l2_mbus_framefmt *mf;\n\n\tmf = __s5k6a3_get_format(sensor, sd_state, fmt->pad, fmt->which);\n\n\tmutex_lock(&sensor->lock);\n\tfmt->format = *mf;\n\tmutex_unlock(&sensor->lock);\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops s5k6a3_pad_ops = {\n\t.enum_mbus_code\t= s5k6a3_enum_mbus_code,\n\t.get_fmt\t= s5k6a3_get_fmt,\n\t.set_fmt\t= s5k6a3_set_fmt,\n};\n\nstatic int s5k6a3_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_mbus_framefmt *format = v4l2_subdev_get_try_format(sd,\n\t\t\t\t\t\t\t\t       fh->state,\n\t\t\t\t\t\t\t\t       0);\n\n\t*format\t\t= s5k6a3_formats[0];\n\tformat->width\t= S5K6A3_DEFAULT_WIDTH;\n\tformat->height\t= S5K6A3_DEFAULT_HEIGHT;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_internal_ops s5k6a3_sd_internal_ops = {\n\t.open = s5k6a3_open,\n};\n\nstatic int __s5k6a3_power_on(struct s5k6a3 *sensor)\n{\n\tint i = S5K6A3_SUPP_VDDA;\n\tint ret;\n\n\tret = clk_set_rate(sensor->clock, sensor->clock_frequency);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pm_runtime_get(sensor->dev);\n\tif (ret < 0)\n\t\tgoto error_rpm_put;\n\n\tret = regulator_enable(sensor->supplies[i].consumer);\n\tif (ret < 0)\n\t\tgoto error_rpm_put;\n\n\tret = clk_prepare_enable(sensor->clock);\n\tif (ret < 0)\n\t\tgoto error_reg_dis;\n\n\tfor (i++; i < S5K6A3_NUM_SUPPLIES; i++) {\n\t\tret = regulator_enable(sensor->supplies[i].consumer);\n\t\tif (ret < 0)\n\t\t\tgoto error_clk;\n\t}\n\n\tgpiod_set_value_cansleep(sensor->gpio_reset, 0);\n\tusleep_range(600, 800);\n\tgpiod_set_value_cansleep(sensor->gpio_reset, 1);\n\tusleep_range(600, 800);\n\tgpiod_set_value_cansleep(sensor->gpio_reset, 0);\n\n\t \n\tmsleep(20);\n\treturn 0;\n\nerror_clk:\n\tclk_disable_unprepare(sensor->clock);\nerror_reg_dis:\n\tfor (--i; i >= 0; --i)\n\t\tregulator_disable(sensor->supplies[i].consumer);\nerror_rpm_put:\n\tpm_runtime_put(sensor->dev);\n\treturn ret;\n}\n\nstatic int __s5k6a3_power_off(struct s5k6a3 *sensor)\n{\n\tint i;\n\n\tgpiod_set_value_cansleep(sensor->gpio_reset, 1);\n\n\tfor (i = S5K6A3_NUM_SUPPLIES - 1; i >= 0; i--)\n\t\tregulator_disable(sensor->supplies[i].consumer);\n\n\tclk_disable_unprepare(sensor->clock);\n\tpm_runtime_put(sensor->dev);\n\treturn 0;\n}\n\nstatic int s5k6a3_s_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct s5k6a3 *sensor = sd_to_s5k6a3(sd);\n\tint ret = 0;\n\n\tmutex_lock(&sensor->lock);\n\n\tif (sensor->power_count == !on) {\n\t\tif (on)\n\t\t\tret = __s5k6a3_power_on(sensor);\n\t\telse\n\t\t\tret = __s5k6a3_power_off(sensor);\n\n\t\tif (ret == 0)\n\t\t\tsensor->power_count += on ? 1 : -1;\n\t}\n\n\tmutex_unlock(&sensor->lock);\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_core_ops s5k6a3_core_ops = {\n\t.s_power = s5k6a3_s_power,\n};\n\nstatic const struct v4l2_subdev_ops s5k6a3_subdev_ops = {\n\t.core = &s5k6a3_core_ops,\n\t.pad = &s5k6a3_pad_ops,\n};\n\nstatic int s5k6a3_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct s5k6a3 *sensor;\n\tstruct v4l2_subdev *sd;\n\tint i, ret;\n\n\tsensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);\n\tif (!sensor)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&sensor->lock);\n\tsensor->dev = dev;\n\n\tsensor->clock = devm_clk_get(sensor->dev, S5K6A3_CLK_NAME);\n\tif (IS_ERR(sensor->clock))\n\t\treturn PTR_ERR(sensor->clock);\n\n\tsensor->gpio_reset = devm_gpiod_get(dev, NULL, GPIOD_OUT_HIGH);\n\tret = PTR_ERR_OR_ZERO(sensor->gpio_reset);\n\tif (ret)\n\t\treturn ret;\n\n\tif (of_property_read_u32(dev->of_node, \"clock-frequency\",\n\t\t\t\t &sensor->clock_frequency)) {\n\t\tsensor->clock_frequency = S5K6A3_DEFAULT_CLK_FREQ;\n\t\tdev_info(dev, \"using default %u Hz clock frequency\\n\",\n\t\t\t\t\tsensor->clock_frequency);\n\t}\n\n\tfor (i = 0; i < S5K6A3_NUM_SUPPLIES; i++)\n\t\tsensor->supplies[i].supply = s5k6a3_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&client->dev, S5K6A3_NUM_SUPPLIES,\n\t\t\t\t      sensor->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsd = &sensor->subdev;\n\tv4l2_i2c_subdev_init(sd, client, &s5k6a3_subdev_ops);\n\tsensor->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsd->internal_ops = &s5k6a3_sd_internal_ops;\n\n\tsensor->format.code = s5k6a3_formats[0].code;\n\tsensor->format.width = S5K6A3_DEFAULT_WIDTH;\n\tsensor->format.height = S5K6A3_DEFAULT_HEIGHT;\n\n\tsd->entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tsensor->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tret = media_entity_pads_init(&sd->entity, 1, &sensor->pad);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpm_runtime_no_callbacks(dev);\n\tpm_runtime_enable(dev);\n\n\tret = v4l2_async_register_subdev(sd);\n\n\tif (ret < 0) {\n\t\tpm_runtime_disable(&client->dev);\n\t\tmedia_entity_cleanup(&sd->entity);\n\t}\n\n\treturn ret;\n}\n\nstatic void s5k6a3_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\n\tpm_runtime_disable(&client->dev);\n\tv4l2_async_unregister_subdev(sd);\n\tmedia_entity_cleanup(&sd->entity);\n}\n\nstatic const struct i2c_device_id s5k6a3_ids[] = {\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, s5k6a3_ids);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id s5k6a3_of_match[] = {\n\t{ .compatible = \"samsung,s5k6a3\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, s5k6a3_of_match);\n#endif\n\nstatic struct i2c_driver s5k6a3_driver = {\n\t.driver = {\n\t\t.of_match_table\t= of_match_ptr(s5k6a3_of_match),\n\t\t.name\t\t= S5K6A3_DRV_NAME,\n\t},\n\t.probe\t\t= s5k6a3_probe,\n\t.remove\t\t= s5k6a3_remove,\n\t.id_table\t= s5k6a3_ids,\n};\n\nmodule_i2c_driver(s5k6a3_driver);\n\nMODULE_DESCRIPTION(\"S5K6A3 image sensor subdev driver\");\nMODULE_AUTHOR(\"Sylwester Nawrocki <s.nawrocki@samsung.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}