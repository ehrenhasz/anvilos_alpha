{
  "module_name": "s5k5baf.c",
  "hash_id": "af90ea9a5ccb1daf2b629c91e613eb7a1b4a96168ccedff90acaab88f7ec9808",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/s5k5baf.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/media.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n#include <media/media-entity.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-subdev.h>\n#include <media/v4l2-mediabus.h>\n#include <media/v4l2-fwnode.h>\n\nstatic int debug;\nmodule_param(debug, int, 0644);\n\n#define S5K5BAF_DRIVER_NAME\t\t\"s5k5baf\"\n#define S5K5BAF_DEFAULT_MCLK_FREQ\t24000000U\n#define S5K5BAF_CLK_NAME\t\t\"mclk\"\n\n#define S5K5BAF_FW_FILENAME\t\t\"s5k5baf-cfg.bin\"\n#define S5K5BAF_FW_TAG\t\t\t\"SF00\"\n#define S5K5BAG_FW_TAG_LEN\t\t2\n#define S5K5BAG_FW_MAX_COUNT\t\t16\n\n#define S5K5BAF_CIS_WIDTH\t\t1600\n#define S5K5BAF_CIS_HEIGHT\t\t1200\n#define S5K5BAF_WIN_WIDTH_MIN\t\t8\n#define S5K5BAF_WIN_HEIGHT_MIN\t\t8\n#define S5K5BAF_GAIN_RED_DEF\t\t127\n#define S5K5BAF_GAIN_GREEN_DEF\t\t95\n#define S5K5BAF_GAIN_BLUE_DEF\t\t180\n \n#define S5K5BAF_DEF_NUM_LANES\t\t1\n\n#define AHB_MSB_ADDR_PTR\t\t0xfcfc\n\n \n#define PAGE_IF_HW\t\t\t0xd000\n#define PAGE_IF_SW\t\t\t0x7000\n\n \n#define REG_SW_LOAD_COMPLETE\t\t0x0014\n#define REG_CMDWR_PAGE\t\t\t0x0028\n#define REG_CMDWR_ADDR\t\t\t0x002a\n#define REG_CMDRD_PAGE\t\t\t0x002c\n#define REG_CMDRD_ADDR\t\t\t0x002e\n#define REG_CMD_BUF\t\t\t0x0f12\n#define REG_SET_HOST_INT\t\t0x1000\n#define REG_CLEAR_HOST_INT\t\t0x1030\n#define REG_PATTERN_SET\t\t\t0x3100\n#define REG_PATTERN_WIDTH\t\t0x3118\n#define REG_PATTERN_HEIGHT\t\t0x311a\n#define REG_PATTERN_PARAM\t\t0x311c\n\n \n\n \n#define REG_FW_APIVER\t\t\t0x012e\n#define  S5K5BAF_FW_APIVER\t\t0x0001\n#define REG_FW_REVISION\t\t\t0x0130\n#define REG_FW_SENSOR_ID\t\t0x0152\n\n \n \n#define REG_I_INCLK_FREQ_L\t\t0x01b8\n#define REG_I_INCLK_FREQ_H\t\t0x01ba\n#define  MIN_MCLK_FREQ_KHZ\t\t6000U\n#define  MAX_MCLK_FREQ_KHZ\t\t48000U\n#define REG_I_USE_NPVI_CLOCKS\t\t0x01c6\n#define  NPVI_CLOCKS\t\t\t1\n#define REG_I_USE_NMIPI_CLOCKS\t\t0x01c8\n#define  NMIPI_CLOCKS\t\t\t1\n#define REG_I_BLOCK_INTERNAL_PLL_CALC\t0x01ca\n\n \n#define REG_I_OPCLK_4KHZ(n)\t\t((n) * 6 + 0x01cc)\n#define REG_I_MIN_OUTRATE_4KHZ(n)\t((n) * 6 + 0x01ce)\n#define REG_I_MAX_OUTRATE_4KHZ(n)\t((n) * 6 + 0x01d0)\n#define  SCLK_PVI_FREQ\t\t\t24000\n#define  SCLK_MIPI_FREQ\t\t\t48000\n#define  PCLK_MIN_FREQ\t\t\t6000\n#define  PCLK_MAX_FREQ\t\t\t48000\n#define REG_I_USE_REGS_API\t\t0x01de\n#define REG_I_INIT_PARAMS_UPDATED\t0x01e0\n#define REG_I_ERROR_INFO\t\t0x01e2\n\n \n#define REG_USER_BRIGHTNESS\t\t0x01e4\n#define REG_USER_CONTRAST\t\t0x01e6\n#define REG_USER_SATURATION\t\t0x01e8\n#define REG_USER_SHARPBLUR\t\t0x01ea\n\n#define REG_G_SPEC_EFFECTS\t\t0x01ee\n#define REG_G_ENABLE_PREV\t\t0x01f0\n#define REG_G_ENABLE_PREV_CHG\t\t0x01f2\n#define REG_G_NEW_CFG_SYNC\t\t0x01f8\n#define REG_G_PREVREQ_IN_WIDTH\t\t0x01fa\n#define REG_G_PREVREQ_IN_HEIGHT\t\t0x01fc\n#define REG_G_PREVREQ_IN_XOFFS\t\t0x01fe\n#define REG_G_PREVREQ_IN_YOFFS\t\t0x0200\n#define REG_G_PREVZOOM_IN_WIDTH\t\t0x020a\n#define REG_G_PREVZOOM_IN_HEIGHT\t0x020c\n#define REG_G_PREVZOOM_IN_XOFFS\t\t0x020e\n#define REG_G_PREVZOOM_IN_YOFFS\t\t0x0210\n#define REG_G_INPUTS_CHANGE_REQ\t\t0x021a\n#define REG_G_ACTIVE_PREV_CFG\t\t0x021c\n#define REG_G_PREV_CFG_CHG\t\t0x021e\n#define REG_G_PREV_OPEN_AFTER_CH\t0x0220\n#define REG_G_PREV_CFG_ERROR\t\t0x0222\n#define  CFG_ERROR_RANGE\t\t0x0b\n#define REG_G_PREV_CFG_BYPASS_CHANGED\t0x022a\n#define REG_G_ACTUAL_P_FR_TIME\t\t0x023a\n#define REG_G_ACTUAL_P_OUT_RATE\t\t0x023c\n#define REG_G_ACTUAL_C_FR_TIME\t\t0x023e\n#define REG_G_ACTUAL_C_OUT_RATE\t\t0x0240\n\n \n#define PREG(n, x)\t\t\t((n) * 0x26 + x)\n#define REG_P_OUT_WIDTH(n)\t\tPREG(n, 0x0242)\n#define REG_P_OUT_HEIGHT(n)\t\tPREG(n, 0x0244)\n#define REG_P_FMT(n)\t\t\tPREG(n, 0x0246)\n#define REG_P_MAX_OUT_RATE(n)\t\tPREG(n, 0x0248)\n#define REG_P_MIN_OUT_RATE(n)\t\tPREG(n, 0x024a)\n#define REG_P_PVI_MASK(n)\t\tPREG(n, 0x024c)\n#define  PVI_MASK_MIPI\t\t\t0x52\n#define REG_P_CLK_INDEX(n)\t\tPREG(n, 0x024e)\n#define  CLK_PVI_INDEX\t\t\t0\n#define  CLK_MIPI_INDEX\t\t\tNPVI_CLOCKS\n#define REG_P_FR_RATE_TYPE(n)\t\tPREG(n, 0x0250)\n#define  FR_RATE_DYNAMIC\t\t0\n#define  FR_RATE_FIXED\t\t\t1\n#define  FR_RATE_FIXED_ACCURATE\t\t2\n#define REG_P_FR_RATE_Q_TYPE(n)\t\tPREG(n, 0x0252)\n#define  FR_RATE_Q_DYNAMIC\t\t0\n#define  FR_RATE_Q_BEST_FRRATE\t\t1  \n#define  FR_RATE_Q_BEST_QUALITY\t\t2  \n \n#define REG_P_MAX_FR_TIME(n)\t\tPREG(n, 0x0254)\n#define REG_P_MIN_FR_TIME(n)\t\tPREG(n, 0x0256)\n#define  S5K5BAF_MIN_FR_TIME\t\t333   \n#define  S5K5BAF_MAX_FR_TIME\t\t6500  \n \n#define REG_P_SATURATION(n)\t\tPREG(n, 0x0258)\n#define REG_P_SHARP_BLUR(n)\t\tPREG(n, 0x025a)\n#define REG_P_GLAMOUR(n)\t\tPREG(n, 0x025c)\n#define REG_P_COLORTEMP(n)\t\tPREG(n, 0x025e)\n#define REG_P_GAMMA_INDEX(n)\t\tPREG(n, 0x0260)\n#define REG_P_PREV_MIRROR(n)\t\tPREG(n, 0x0262)\n#define REG_P_CAP_MIRROR(n)\t\tPREG(n, 0x0264)\n#define REG_P_CAP_ROTATION(n)\t\tPREG(n, 0x0266)\n\n \n \n#define REG_SF_USR_EXPOSURE_L\t\t0x03bc\n#define REG_SF_USR_EXPOSURE_H\t\t0x03be\n#define REG_SF_USR_EXPOSURE_CHG\t\t0x03c0\n#define REG_SF_USR_TOT_GAIN\t\t0x03c2\n#define REG_SF_USR_TOT_GAIN_CHG\t\t0x03c4\n#define REG_SF_RGAIN\t\t\t0x03c6\n#define REG_SF_RGAIN_CHG\t\t0x03c8\n#define REG_SF_GGAIN\t\t\t0x03ca\n#define REG_SF_GGAIN_CHG\t\t0x03cc\n#define REG_SF_BGAIN\t\t\t0x03ce\n#define REG_SF_BGAIN_CHG\t\t0x03d0\n#define REG_SF_WBGAIN_CHG\t\t0x03d2\n#define REG_SF_FLICKER_QUANT\t\t0x03d4\n#define REG_SF_FLICKER_QUANT_CHG\t0x03d6\n\n \n#define REG_OIF_EN_MIPI_LANES\t\t0x03f2\n#define REG_OIF_EN_PACKETS\t\t0x03f4\n#define  EN_PACKETS_CSI2\t\t0xc3\n#define REG_OIF_CFG_CHG\t\t\t0x03f6\n\n \n#define REG_DBG_AUTOALG_EN\t\t0x03f8\n#define  AALG_ALL_EN\t\t\tBIT(0)\n#define  AALG_AE_EN\t\t\tBIT(1)\n#define  AALG_DIVLEI_EN\t\t\tBIT(2)\n#define  AALG_WB_EN\t\t\tBIT(3)\n#define  AALG_USE_WB_FOR_ISP\t\tBIT(4)\n#define  AALG_FLICKER_EN\t\tBIT(5)\n#define  AALG_FIT_EN\t\t\tBIT(6)\n#define  AALG_WRHW_EN\t\t\tBIT(7)\n\n \n#define REG_PTR_CCM_HORIZON\t\t0x06d0\n#define REG_PTR_CCM_INCANDESCENT\t0x06d4\n#define REG_PTR_CCM_WARM_WHITE\t\t0x06d8\n#define REG_PTR_CCM_COOL_WHITE\t\t0x06dc\n#define REG_PTR_CCM_DL50\t\t0x06e0\n#define REG_PTR_CCM_DL65\t\t0x06e4\n#define REG_PTR_CCM_OUTDOOR\t\t0x06ec\n\n#define REG_ARR_CCM(n)\t\t\t(0x2800 + 36 * (n))\n\nstatic const char * const s5k5baf_supply_names[] = {\n\t\"vdda\",\t\t \n\t\"vddreg\",\t \n\t\"vddio\",\t \n};\n#define S5K5BAF_NUM_SUPPLIES ARRAY_SIZE(s5k5baf_supply_names)\n\nenum s5k5baf_gpio_id {\n\tSTBY,\n\tRSET,\n\tNUM_GPIOS,\n};\n\n#define PAD_CIS 0\n#define PAD_OUT 1\n#define NUM_CIS_PADS 1\n#define NUM_ISP_PADS 2\n\nstruct s5k5baf_pixfmt {\n\tu32 code;\n\tu32 colorspace;\n\t \n\tu16 reg_p_fmt;\n};\n\nstruct s5k5baf_ctrls {\n\tstruct v4l2_ctrl_handler handler;\n\tstruct {  \n\t\tstruct v4l2_ctrl *awb;\n\t\tstruct v4l2_ctrl *gain_red;\n\t\tstruct v4l2_ctrl *gain_blue;\n\t};\n\tstruct {  \n\t\tstruct v4l2_ctrl *hflip;\n\t\tstruct v4l2_ctrl *vflip;\n\t};\n\tstruct {  \n\t\tstruct v4l2_ctrl *auto_exp;\n\t\tstruct v4l2_ctrl *exposure;\n\t\tstruct v4l2_ctrl *gain;\n\t};\n};\n\nenum {\n\tS5K5BAF_FW_ID_PATCH,\n\tS5K5BAF_FW_ID_CCM,\n\tS5K5BAF_FW_ID_CIS,\n};\n\nstruct s5k5baf_fw {\n\tu16 count;\n\tstruct {\n\t\tu16 id;\n\t\tu16 offset;\n\t} seq[];\n};\n\nstruct s5k5baf {\n\tstruct gpio_desc *gpios[NUM_GPIOS];\n\tenum v4l2_mbus_type bus_type;\n\tu8 nlanes;\n\tstruct regulator_bulk_data supplies[S5K5BAF_NUM_SUPPLIES];\n\n\tstruct clk *clock;\n\tu32 mclk_frequency;\n\n\tstruct s5k5baf_fw *fw;\n\n\tstruct v4l2_subdev cis_sd;\n\tstruct media_pad cis_pad;\n\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pads[NUM_ISP_PADS];\n\n\t \n\tstruct mutex lock;\n\n\tint error;\n\n\tstruct v4l2_rect crop_sink;\n\tstruct v4l2_rect compose;\n\tstruct v4l2_rect crop_source;\n\t \n\tint pixfmt;\n\t \n\tu16 fiv;\n\t \n\tu16 req_fiv;\n\t \n\tu16 auto_alg;\n\n\tstruct s5k5baf_ctrls ctrls;\n\n\tunsigned int streaming:1;\n\tunsigned int apply_cfg:1;\n\tunsigned int apply_crop:1;\n\tunsigned int valid_auto_alg:1;\n\tunsigned int power;\n};\n\nstatic const struct s5k5baf_pixfmt s5k5baf_formats[] = {\n\t{ MEDIA_BUS_FMT_VYUY8_2X8,\tV4L2_COLORSPACE_JPEG,\t5 },\n\t \n\t{ MEDIA_BUS_FMT_VYUY8_2X8,\tV4L2_COLORSPACE_REC709,\t6 },\n\t{ MEDIA_BUS_FMT_RGB565_2X8_BE,\tV4L2_COLORSPACE_JPEG,\t0 },\n};\n\nstatic struct v4l2_rect s5k5baf_cis_rect = {\n\t0, 0, S5K5BAF_CIS_WIDTH, S5K5BAF_CIS_HEIGHT\n};\n\n \nstatic int s5k5baf_fw_parse(struct device *dev, struct s5k5baf_fw **fw,\n\t\t\t    size_t count, const __le16 *data)\n{\n\tstruct s5k5baf_fw *f;\n\tu16 *d, i, *end;\n\tint ret;\n\n\tif (count < S5K5BAG_FW_TAG_LEN + 1) {\n\t\tdev_err(dev, \"firmware file too short (%zu)\\n\", count);\n\t\treturn -EINVAL;\n\t}\n\n\tret = memcmp(data, S5K5BAF_FW_TAG, S5K5BAG_FW_TAG_LEN * sizeof(u16));\n\tif (ret != 0) {\n\t\tdev_err(dev, \"invalid firmware magic number\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata += S5K5BAG_FW_TAG_LEN;\n\tcount -= S5K5BAG_FW_TAG_LEN;\n\n\td = devm_kcalloc(dev, count, sizeof(u16), GFP_KERNEL);\n\tif (!d)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < count; ++i)\n\t\td[i] = le16_to_cpu(data[i]);\n\n\tf = (struct s5k5baf_fw *)d;\n\tif (count < 1 + 2 * f->count) {\n\t\tdev_err(dev, \"invalid firmware header (count=%d size=%zu)\\n\",\n\t\t\tf->count, 2 * (count + S5K5BAG_FW_TAG_LEN));\n\t\treturn -EINVAL;\n\t}\n\tend = d + count;\n\td += 1 + 2 * f->count;\n\n\tfor (i = 0; i < f->count; ++i) {\n\t\tif (f->seq[i].offset + d <= end)\n\t\t\tcontinue;\n\t\tdev_err(dev, \"invalid firmware header (seq=%d)\\n\", i);\n\t\treturn -EINVAL;\n\t}\n\n\t*fw = f;\n\n\treturn 0;\n}\n\nstatic inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct s5k5baf, ctrls.handler)->sd;\n}\n\nstatic inline bool s5k5baf_is_cis_subdev(struct v4l2_subdev *sd)\n{\n\treturn sd->entity.function == MEDIA_ENT_F_CAM_SENSOR;\n}\n\nstatic inline struct s5k5baf *to_s5k5baf(struct v4l2_subdev *sd)\n{\n\tif (s5k5baf_is_cis_subdev(sd))\n\t\treturn container_of(sd, struct s5k5baf, cis_sd);\n\telse\n\t\treturn container_of(sd, struct s5k5baf, sd);\n}\n\nstatic u16 s5k5baf_i2c_read(struct s5k5baf *state, u16 addr)\n{\n\tstruct i2c_client *c = v4l2_get_subdevdata(&state->sd);\n\t__be16 w, r;\n\tu16 res;\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = c->addr, .flags = 0,\n\t\t  .len = 2, .buf = (u8 *)&w },\n\t\t{ .addr = c->addr, .flags = I2C_M_RD,\n\t\t  .len = 2, .buf = (u8 *)&r },\n\t};\n\tint ret;\n\n\tif (state->error)\n\t\treturn 0;\n\n\tw = cpu_to_be16(addr);\n\tret = i2c_transfer(c->adapter, msg, 2);\n\tres = be16_to_cpu(r);\n\n\tv4l2_dbg(3, debug, c, \"i2c_read: 0x%04x : 0x%04x\\n\", addr, res);\n\n\tif (ret != 2) {\n\t\tv4l2_err(c, \"i2c_read: error during transfer (%d)\\n\", ret);\n\t\tstate->error = ret;\n\t}\n\treturn res;\n}\n\nstatic void s5k5baf_i2c_write(struct s5k5baf *state, u16 addr, u16 val)\n{\n\tu8 buf[4] = { addr >> 8, addr & 0xFF, val >> 8, val & 0xFF };\n\tstruct i2c_client *c = v4l2_get_subdevdata(&state->sd);\n\tint ret;\n\n\tif (state->error)\n\t\treturn;\n\n\tret = i2c_master_send(c, buf, 4);\n\tv4l2_dbg(3, debug, c, \"i2c_write: 0x%04x : 0x%04x\\n\", addr, val);\n\n\tif (ret != 4) {\n\t\tv4l2_err(c, \"i2c_write: error during transfer (%d)\\n\", ret);\n\t\tstate->error = ret;\n\t}\n}\n\nstatic u16 s5k5baf_read(struct s5k5baf *state, u16 addr)\n{\n\ts5k5baf_i2c_write(state, REG_CMDRD_ADDR, addr);\n\treturn s5k5baf_i2c_read(state, REG_CMD_BUF);\n}\n\nstatic void s5k5baf_write(struct s5k5baf *state, u16 addr, u16 val)\n{\n\ts5k5baf_i2c_write(state, REG_CMDWR_ADDR, addr);\n\ts5k5baf_i2c_write(state, REG_CMD_BUF, val);\n}\n\nstatic void s5k5baf_write_arr_seq(struct s5k5baf *state, u16 addr,\n\t\t\t\t  u16 count, const u16 *seq)\n{\n\tstruct i2c_client *c = v4l2_get_subdevdata(&state->sd);\n\t__be16 buf[65];\n\n\ts5k5baf_i2c_write(state, REG_CMDWR_ADDR, addr);\n\tif (state->error)\n\t\treturn;\n\n\tv4l2_dbg(3, debug, c, \"i2c_write_seq(count=%d): %*ph\\n\", count,\n\t\t min(2 * count, 64), seq);\n\n\tbuf[0] = cpu_to_be16(REG_CMD_BUF);\n\n\twhile (count > 0) {\n\t\tint n = min_t(int, count, ARRAY_SIZE(buf) - 1);\n\t\tint ret, i;\n\n\t\tfor (i = 1; i <= n; ++i)\n\t\t\tbuf[i] = cpu_to_be16(*seq++);\n\n\t\ti *= 2;\n\t\tret = i2c_master_send(c, (char *)buf, i);\n\t\tif (ret != i) {\n\t\t\tv4l2_err(c, \"i2c_write_seq: error during transfer (%d)\\n\", ret);\n\t\t\tstate->error = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount -= n;\n\t}\n}\n\n#define s5k5baf_write_seq(state, addr, seq...) \\\n\ts5k5baf_write_arr_seq(state, addr, sizeof((char[]){ seq }), \\\n\t\t\t      (const u16 []){ seq })\n\n \n#define NSEQ(seq...) sizeof((char[]){ seq }), seq\n\n \nstatic void s5k5baf_write_nseq(struct s5k5baf *state, const u16 *nseq)\n{\n\tint count;\n\n\twhile ((count = *nseq++)) {\n\t\tu16 addr = *nseq++;\n\t\t--count;\n\n\t\ts5k5baf_write_arr_seq(state, addr, count, nseq);\n\t\tnseq += count;\n\t}\n}\n\nstatic void s5k5baf_synchronize(struct s5k5baf *state, int timeout, u16 addr)\n{\n\tunsigned long end = jiffies + msecs_to_jiffies(timeout);\n\tu16 reg;\n\n\ts5k5baf_write(state, addr, 1);\n\tdo {\n\t\treg = s5k5baf_read(state, addr);\n\t\tif (state->error || !reg)\n\t\t\treturn;\n\t\tusleep_range(5000, 10000);\n\t} while (time_is_after_jiffies(end));\n\n\tv4l2_err(&state->sd, \"timeout on register synchronize (%#x)\\n\", addr);\n\tstate->error = -ETIMEDOUT;\n}\n\nstatic u16 *s5k5baf_fw_get_seq(struct s5k5baf *state, u16 seq_id)\n{\n\tstruct s5k5baf_fw *fw = state->fw;\n\tu16 *data;\n\tint i;\n\n\tif (fw == NULL)\n\t\treturn NULL;\n\n\tdata = &fw->seq[0].id + 2 * fw->count;\n\n\tfor (i = 0; i < fw->count; ++i) {\n\t\tif (fw->seq[i].id == seq_id)\n\t\t\treturn data + fw->seq[i].offset;\n\t}\n\n\treturn NULL;\n}\n\nstatic void s5k5baf_hw_patch(struct s5k5baf *state)\n{\n\tu16 *seq = s5k5baf_fw_get_seq(state, S5K5BAF_FW_ID_PATCH);\n\n\tif (seq)\n\t\ts5k5baf_write_nseq(state, seq);\n}\n\nstatic void s5k5baf_hw_set_clocks(struct s5k5baf *state)\n{\n\tunsigned long mclk = state->mclk_frequency / 1000;\n\tu16 status;\n\tstatic const u16 nseq_clk_cfg[] = {\n\t\tNSEQ(REG_I_USE_NPVI_CLOCKS,\n\t\t  NPVI_CLOCKS, NMIPI_CLOCKS, 0,\n\t\t  SCLK_PVI_FREQ / 4, PCLK_MIN_FREQ / 4, PCLK_MAX_FREQ / 4,\n\t\t  SCLK_MIPI_FREQ / 4, PCLK_MIN_FREQ / 4, PCLK_MAX_FREQ / 4),\n\t\tNSEQ(REG_I_USE_REGS_API, 1),\n\t\t0\n\t};\n\n\ts5k5baf_write_seq(state, REG_I_INCLK_FREQ_L, mclk & 0xffff, mclk >> 16);\n\ts5k5baf_write_nseq(state, nseq_clk_cfg);\n\n\ts5k5baf_synchronize(state, 250, REG_I_INIT_PARAMS_UPDATED);\n\tstatus = s5k5baf_read(state, REG_I_ERROR_INFO);\n\tif (!state->error && status) {\n\t\tv4l2_err(&state->sd, \"error configuring PLL (%d)\\n\", status);\n\t\tstate->error = -EINVAL;\n\t}\n}\n\n \nstatic void s5k5baf_hw_set_ccm(struct s5k5baf *state)\n{\n\tu16 *seq = s5k5baf_fw_get_seq(state, S5K5BAF_FW_ID_CCM);\n\n\tif (seq)\n\t\ts5k5baf_write_nseq(state, seq);\n}\n\n \nstatic void s5k5baf_hw_set_cis(struct s5k5baf *state)\n{\n\tu16 *seq = s5k5baf_fw_get_seq(state, S5K5BAF_FW_ID_CIS);\n\n\tif (!seq)\n\t\treturn;\n\n\ts5k5baf_i2c_write(state, REG_CMDWR_PAGE, PAGE_IF_HW);\n\ts5k5baf_write_nseq(state, seq);\n\ts5k5baf_i2c_write(state, REG_CMDWR_PAGE, PAGE_IF_SW);\n}\n\nstatic void s5k5baf_hw_sync_cfg(struct s5k5baf *state)\n{\n\ts5k5baf_write(state, REG_G_PREV_CFG_CHG, 1);\n\tif (state->apply_crop) {\n\t\ts5k5baf_write(state, REG_G_INPUTS_CHANGE_REQ, 1);\n\t\ts5k5baf_write(state, REG_G_PREV_CFG_BYPASS_CHANGED, 1);\n\t}\n\ts5k5baf_synchronize(state, 500, REG_G_NEW_CFG_SYNC);\n}\n \nstatic void s5k5baf_hw_set_mirror(struct s5k5baf *state)\n{\n\tu16 flip = state->ctrls.vflip->val | (state->ctrls.vflip->val << 1);\n\n\ts5k5baf_write(state, REG_P_PREV_MIRROR(0), flip);\n\tif (state->streaming)\n\t\ts5k5baf_hw_sync_cfg(state);\n}\n\nstatic void s5k5baf_hw_set_alg(struct s5k5baf *state, u16 alg, bool enable)\n{\n\tu16 cur_alg, new_alg;\n\n\tif (!state->valid_auto_alg)\n\t\tcur_alg = s5k5baf_read(state, REG_DBG_AUTOALG_EN);\n\telse\n\t\tcur_alg = state->auto_alg;\n\n\tnew_alg = enable ? (cur_alg | alg) : (cur_alg & ~alg);\n\n\tif (new_alg != cur_alg)\n\t\ts5k5baf_write(state, REG_DBG_AUTOALG_EN, new_alg);\n\n\tif (state->error)\n\t\treturn;\n\n\tstate->valid_auto_alg = 1;\n\tstate->auto_alg = new_alg;\n}\n\n \nstatic void s5k5baf_hw_set_awb(struct s5k5baf *state, int awb)\n{\n\tstruct s5k5baf_ctrls *ctrls = &state->ctrls;\n\n\tif (!awb)\n\t\ts5k5baf_write_seq(state, REG_SF_RGAIN,\n\t\t\t\t  ctrls->gain_red->val, 1,\n\t\t\t\t  S5K5BAF_GAIN_GREEN_DEF, 1,\n\t\t\t\t  ctrls->gain_blue->val, 1,\n\t\t\t\t  1);\n\n\ts5k5baf_hw_set_alg(state, AALG_WB_EN, awb);\n}\n\n \nstatic void s5k5baf_hw_set_user_exposure(struct s5k5baf *state, int exposure)\n{\n\tunsigned int time = exposure / 10;\n\n\ts5k5baf_write_seq(state, REG_SF_USR_EXPOSURE_L,\n\t\t\t  time & 0xffff, time >> 16, 1);\n}\n\nstatic void s5k5baf_hw_set_user_gain(struct s5k5baf *state, int gain)\n{\n\ts5k5baf_write_seq(state, REG_SF_USR_TOT_GAIN, gain, 1);\n}\n\n \nstatic void s5k5baf_hw_set_auto_exposure(struct s5k5baf *state, int value)\n{\n\tif (value == V4L2_EXPOSURE_AUTO) {\n\t\ts5k5baf_hw_set_alg(state, AALG_AE_EN | AALG_DIVLEI_EN, true);\n\t} else {\n\t\tunsigned int exp_time = state->ctrls.exposure->val;\n\n\t\ts5k5baf_hw_set_user_exposure(state, exp_time);\n\t\ts5k5baf_hw_set_user_gain(state, state->ctrls.gain->val);\n\t\ts5k5baf_hw_set_alg(state, AALG_AE_EN | AALG_DIVLEI_EN, false);\n\t}\n}\n\nstatic void s5k5baf_hw_set_anti_flicker(struct s5k5baf *state, int v)\n{\n\tif (v == V4L2_CID_POWER_LINE_FREQUENCY_AUTO) {\n\t\ts5k5baf_hw_set_alg(state, AALG_FLICKER_EN, true);\n\t} else {\n\t\t \n\t\ts5k5baf_write_seq(state, REG_SF_FLICKER_QUANT, v, 1);\n\t\ts5k5baf_hw_set_alg(state, AALG_FLICKER_EN, false);\n\t}\n}\n\nstatic void s5k5baf_hw_set_colorfx(struct s5k5baf *state, int val)\n{\n\tstatic const u16 colorfx[] = {\n\t\t[V4L2_COLORFX_NONE] = 0,\n\t\t[V4L2_COLORFX_BW] = 1,\n\t\t[V4L2_COLORFX_NEGATIVE] = 2,\n\t\t[V4L2_COLORFX_SEPIA] = 3,\n\t\t[V4L2_COLORFX_SKY_BLUE] = 4,\n\t\t[V4L2_COLORFX_SKETCH] = 5,\n\t};\n\n\ts5k5baf_write(state, REG_G_SPEC_EFFECTS, colorfx[val]);\n}\n\nstatic int s5k5baf_find_pixfmt(struct v4l2_mbus_framefmt *mf)\n{\n\tint i, c = -1;\n\n\tfor (i = 0; i < ARRAY_SIZE(s5k5baf_formats); i++) {\n\t\tif (mf->colorspace != s5k5baf_formats[i].colorspace)\n\t\t\tcontinue;\n\t\tif (mf->code == s5k5baf_formats[i].code)\n\t\t\treturn i;\n\t\tif (c < 0)\n\t\t\tc = i;\n\t}\n\treturn (c < 0) ? 0 : c;\n}\n\nstatic int s5k5baf_clear_error(struct s5k5baf *state)\n{\n\tint ret = state->error;\n\n\tstate->error = 0;\n\treturn ret;\n}\n\nstatic int s5k5baf_hw_set_video_bus(struct s5k5baf *state)\n{\n\tu16 en_pkts;\n\n\tif (state->bus_type == V4L2_MBUS_CSI2_DPHY)\n\t\ten_pkts = EN_PACKETS_CSI2;\n\telse\n\t\ten_pkts = 0;\n\n\ts5k5baf_write_seq(state, REG_OIF_EN_MIPI_LANES,\n\t\t\t  state->nlanes, en_pkts, 1);\n\n\treturn s5k5baf_clear_error(state);\n}\n\nstatic u16 s5k5baf_get_cfg_error(struct s5k5baf *state)\n{\n\tu16 err = s5k5baf_read(state, REG_G_PREV_CFG_ERROR);\n\tif (err)\n\t\ts5k5baf_write(state, REG_G_PREV_CFG_ERROR, 0);\n\treturn err;\n}\n\nstatic void s5k5baf_hw_set_fiv(struct s5k5baf *state, u16 fiv)\n{\n\ts5k5baf_write(state, REG_P_MAX_FR_TIME(0), fiv);\n\ts5k5baf_hw_sync_cfg(state);\n}\n\nstatic void s5k5baf_hw_find_min_fiv(struct s5k5baf *state)\n{\n\tu16 err, fiv;\n\tint n;\n\n\tfiv = s5k5baf_read(state,  REG_G_ACTUAL_P_FR_TIME);\n\tif (state->error)\n\t\treturn;\n\n\tfor (n = 5; n > 0; --n) {\n\t\ts5k5baf_hw_set_fiv(state, fiv);\n\t\terr = s5k5baf_get_cfg_error(state);\n\t\tif (state->error)\n\t\t\treturn;\n\t\tswitch (err) {\n\t\tcase CFG_ERROR_RANGE:\n\t\t\t++fiv;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tstate->fiv = fiv;\n\t\t\tv4l2_info(&state->sd,\n\t\t\t\t  \"found valid frame interval: %d00us\\n\", fiv);\n\t\t\treturn;\n\t\tdefault:\n\t\t\tv4l2_err(&state->sd,\n\t\t\t\t \"error setting frame interval: %d\\n\", err);\n\t\t\tstate->error = -EINVAL;\n\t\t}\n\t}\n\tv4l2_err(&state->sd, \"cannot find correct frame interval\\n\");\n\tstate->error = -ERANGE;\n}\n\nstatic void s5k5baf_hw_validate_cfg(struct s5k5baf *state)\n{\n\tu16 err;\n\n\terr = s5k5baf_get_cfg_error(state);\n\tif (state->error)\n\t\treturn;\n\n\tswitch (err) {\n\tcase 0:\n\t\tstate->apply_cfg = 1;\n\t\treturn;\n\tcase CFG_ERROR_RANGE:\n\t\ts5k5baf_hw_find_min_fiv(state);\n\t\tif (!state->error)\n\t\t\tstate->apply_cfg = 1;\n\t\treturn;\n\tdefault:\n\t\tv4l2_err(&state->sd,\n\t\t\t \"error setting format: %d\\n\", err);\n\t\tstate->error = -EINVAL;\n\t}\n}\n\nstatic void s5k5baf_rescale(struct v4l2_rect *r, const struct v4l2_rect *v,\n\t\t\t    const struct v4l2_rect *n,\n\t\t\t    const struct v4l2_rect *d)\n{\n\tr->left = v->left * n->width / d->width;\n\tr->top = v->top * n->height / d->height;\n\tr->width = v->width * n->width / d->width;\n\tr->height = v->height * n->height / d->height;\n}\n\nstatic int s5k5baf_hw_set_crop_rects(struct s5k5baf *state)\n{\n\tstruct v4l2_rect *p, r;\n\tu16 err;\n\tint ret;\n\n\tp = &state->crop_sink;\n\ts5k5baf_write_seq(state, REG_G_PREVREQ_IN_WIDTH, p->width, p->height,\n\t\t\t  p->left, p->top);\n\n\ts5k5baf_rescale(&r, &state->crop_source, &state->crop_sink,\n\t\t\t&state->compose);\n\ts5k5baf_write_seq(state, REG_G_PREVZOOM_IN_WIDTH, r.width, r.height,\n\t\t\t  r.left, r.top);\n\n\ts5k5baf_synchronize(state, 500, REG_G_INPUTS_CHANGE_REQ);\n\ts5k5baf_synchronize(state, 500, REG_G_PREV_CFG_BYPASS_CHANGED);\n\terr = s5k5baf_get_cfg_error(state);\n\tret = s5k5baf_clear_error(state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (err) {\n\tcase 0:\n\t\tbreak;\n\tcase CFG_ERROR_RANGE:\n\t\t \n\t\ts5k5baf_hw_set_fiv(state, S5K5BAF_MAX_FR_TIME);\n\t\terr = s5k5baf_get_cfg_error(state);\n\t\tret = s5k5baf_clear_error(state);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (err) {\n\t\t\tv4l2_err(&state->sd,\n\t\t\t\t \"crop error on max frame interval: %d\\n\", err);\n\t\t\tstate->error = -EINVAL;\n\t\t}\n\t\ts5k5baf_hw_set_fiv(state, state->req_fiv);\n\t\ts5k5baf_hw_validate_cfg(state);\n\t\tbreak;\n\tdefault:\n\t\tv4l2_err(&state->sd, \"crop error: %d\\n\", err);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!state->apply_cfg)\n\t\treturn 0;\n\n\tp = &state->crop_source;\n\ts5k5baf_write_seq(state, REG_P_OUT_WIDTH(0), p->width, p->height);\n\ts5k5baf_hw_set_fiv(state, state->req_fiv);\n\ts5k5baf_hw_validate_cfg(state);\n\n\treturn s5k5baf_clear_error(state);\n}\n\nstatic void s5k5baf_hw_set_config(struct s5k5baf *state)\n{\n\tu16 reg_fmt = s5k5baf_formats[state->pixfmt].reg_p_fmt;\n\tstruct v4l2_rect *r = &state->crop_source;\n\n\ts5k5baf_write_seq(state, REG_P_OUT_WIDTH(0),\n\t\t\t  r->width, r->height, reg_fmt,\n\t\t\t  PCLK_MAX_FREQ >> 2, PCLK_MIN_FREQ >> 2,\n\t\t\t  PVI_MASK_MIPI, CLK_MIPI_INDEX,\n\t\t\t  FR_RATE_FIXED, FR_RATE_Q_DYNAMIC,\n\t\t\t  state->req_fiv, S5K5BAF_MIN_FR_TIME);\n\ts5k5baf_hw_sync_cfg(state);\n\ts5k5baf_hw_validate_cfg(state);\n}\n\n\nstatic void s5k5baf_hw_set_test_pattern(struct s5k5baf *state, int id)\n{\n\ts5k5baf_i2c_write(state, REG_PATTERN_WIDTH, 800);\n\ts5k5baf_i2c_write(state, REG_PATTERN_HEIGHT, 511);\n\ts5k5baf_i2c_write(state, REG_PATTERN_PARAM, 0);\n\ts5k5baf_i2c_write(state, REG_PATTERN_SET, id);\n}\n\nstatic void s5k5baf_gpio_assert(struct s5k5baf *state, int id)\n{\n\tgpiod_set_value_cansleep(state->gpios[id], 1);\n}\n\nstatic void s5k5baf_gpio_deassert(struct s5k5baf *state, int id)\n{\n\tgpiod_set_value_cansleep(state->gpios[id], 0);\n}\n\nstatic int s5k5baf_power_on(struct s5k5baf *state)\n{\n\tint ret;\n\n\tret = regulator_bulk_enable(S5K5BAF_NUM_SUPPLIES, state->supplies);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = clk_set_rate(state->clock, state->mclk_frequency);\n\tif (ret < 0)\n\t\tgoto err_reg_dis;\n\n\tret = clk_prepare_enable(state->clock);\n\tif (ret < 0)\n\t\tgoto err_reg_dis;\n\n\tv4l2_dbg(1, debug, &state->sd, \"clock frequency: %ld\\n\",\n\t\t clk_get_rate(state->clock));\n\n\ts5k5baf_gpio_deassert(state, STBY);\n\tusleep_range(50, 100);\n\ts5k5baf_gpio_deassert(state, RSET);\n\treturn 0;\n\nerr_reg_dis:\n\tregulator_bulk_disable(S5K5BAF_NUM_SUPPLIES, state->supplies);\nerr:\n\tv4l2_err(&state->sd, \"%s() failed (%d)\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int s5k5baf_power_off(struct s5k5baf *state)\n{\n\tint ret;\n\n\tstate->streaming = 0;\n\tstate->apply_cfg = 0;\n\tstate->apply_crop = 0;\n\n\ts5k5baf_gpio_assert(state, RSET);\n\ts5k5baf_gpio_assert(state, STBY);\n\n\tif (!IS_ERR(state->clock))\n\t\tclk_disable_unprepare(state->clock);\n\n\tret = regulator_bulk_disable(S5K5BAF_NUM_SUPPLIES,\n\t\t\t\t\tstate->supplies);\n\tif (ret < 0)\n\t\tv4l2_err(&state->sd, \"failed to disable regulators\\n\");\n\n\treturn 0;\n}\n\nstatic void s5k5baf_hw_init(struct s5k5baf *state)\n{\n\ts5k5baf_i2c_write(state, AHB_MSB_ADDR_PTR, PAGE_IF_HW);\n\ts5k5baf_i2c_write(state, REG_CLEAR_HOST_INT, 0);\n\ts5k5baf_i2c_write(state, REG_SW_LOAD_COMPLETE, 1);\n\ts5k5baf_i2c_write(state, REG_CMDRD_PAGE, PAGE_IF_SW);\n\ts5k5baf_i2c_write(state, REG_CMDWR_PAGE, PAGE_IF_SW);\n}\n\n \n\nstatic void s5k5baf_initialize_data(struct s5k5baf *state)\n{\n\tstate->pixfmt = 0;\n\tstate->req_fiv = 10000 / 15;\n\tstate->fiv = state->req_fiv;\n\tstate->valid_auto_alg = 0;\n}\n\nstatic int s5k5baf_load_setfile(struct s5k5baf *state)\n{\n\tstruct i2c_client *c = v4l2_get_subdevdata(&state->sd);\n\tconst struct firmware *fw;\n\tint ret;\n\n\tret = request_firmware(&fw, S5K5BAF_FW_FILENAME, &c->dev);\n\tif (ret < 0) {\n\t\tdev_warn(&c->dev, \"firmware file (%s) not loaded\\n\",\n\t\t\t S5K5BAF_FW_FILENAME);\n\t\treturn ret;\n\t}\n\n\tret = s5k5baf_fw_parse(&c->dev, &state->fw, fw->size / 2,\n\t\t\t       (__le16 *)fw->data);\n\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic int s5k5baf_set_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct s5k5baf *state = to_s5k5baf(sd);\n\tint ret = 0;\n\n\tmutex_lock(&state->lock);\n\n\tif (state->power != !on)\n\t\tgoto out;\n\n\tif (on) {\n\t\tif (state->fw == NULL)\n\t\t\ts5k5baf_load_setfile(state);\n\n\t\ts5k5baf_initialize_data(state);\n\t\tret = s5k5baf_power_on(state);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\ts5k5baf_hw_init(state);\n\t\ts5k5baf_hw_patch(state);\n\t\ts5k5baf_i2c_write(state, REG_SET_HOST_INT, 1);\n\t\ts5k5baf_hw_set_clocks(state);\n\n\t\tret = s5k5baf_hw_set_video_bus(state);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\ts5k5baf_hw_set_cis(state);\n\t\ts5k5baf_hw_set_ccm(state);\n\n\t\tret = s5k5baf_clear_error(state);\n\t\tif (!ret)\n\t\t\tstate->power++;\n\t} else {\n\t\ts5k5baf_power_off(state);\n\t\tstate->power--;\n\t}\n\nout:\n\tmutex_unlock(&state->lock);\n\n\tif (!ret && on)\n\t\tret = v4l2_ctrl_handler_setup(&state->ctrls.handler);\n\n\treturn ret;\n}\n\nstatic void s5k5baf_hw_set_stream(struct s5k5baf *state, int enable)\n{\n\ts5k5baf_write_seq(state, REG_G_ENABLE_PREV, enable, 1);\n}\n\nstatic int s5k5baf_s_stream(struct v4l2_subdev *sd, int on)\n{\n\tstruct s5k5baf *state = to_s5k5baf(sd);\n\tint ret;\n\n\tmutex_lock(&state->lock);\n\n\tif (state->streaming == !!on) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (on) {\n\t\ts5k5baf_hw_set_config(state);\n\t\tret = s5k5baf_hw_set_crop_rects(state);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\ts5k5baf_hw_set_stream(state, 1);\n\t\ts5k5baf_i2c_write(state, 0xb0cc, 0x000b);\n\t} else {\n\t\ts5k5baf_hw_set_stream(state, 0);\n\t}\n\tret = s5k5baf_clear_error(state);\n\tif (!ret)\n\t\tstate->streaming = !state->streaming;\n\nout:\n\tmutex_unlock(&state->lock);\n\n\treturn ret;\n}\n\nstatic int s5k5baf_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *fi)\n{\n\tstruct s5k5baf *state = to_s5k5baf(sd);\n\n\tmutex_lock(&state->lock);\n\tfi->interval.numerator = state->fiv;\n\tfi->interval.denominator = 10000;\n\tmutex_unlock(&state->lock);\n\n\treturn 0;\n}\n\nstatic void s5k5baf_set_frame_interval(struct s5k5baf *state,\n\t\t\t\t       struct v4l2_subdev_frame_interval *fi)\n{\n\tstruct v4l2_fract *i = &fi->interval;\n\n\tif (fi->interval.denominator == 0)\n\t\tstate->req_fiv = S5K5BAF_MAX_FR_TIME;\n\telse\n\t\tstate->req_fiv = clamp_t(u32,\n\t\t\t\t\t i->numerator * 10000 / i->denominator,\n\t\t\t\t\t S5K5BAF_MIN_FR_TIME,\n\t\t\t\t\t S5K5BAF_MAX_FR_TIME);\n\n\tstate->fiv = state->req_fiv;\n\tif (state->apply_cfg) {\n\t\ts5k5baf_hw_set_fiv(state, state->req_fiv);\n\t\ts5k5baf_hw_validate_cfg(state);\n\t}\n\t*i = (struct v4l2_fract){ state->fiv, 10000 };\n\tif (state->fiv == state->req_fiv)\n\t\tv4l2_info(&state->sd, \"frame interval changed to %d00us\\n\",\n\t\t\t  state->fiv);\n}\n\nstatic int s5k5baf_s_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *fi)\n{\n\tstruct s5k5baf *state = to_s5k5baf(sd);\n\n\tmutex_lock(&state->lock);\n\ts5k5baf_set_frame_interval(state, fi);\n\tmutex_unlock(&state->lock);\n\treturn 0;\n}\n\n \nstatic int s5k5baf_enum_frame_interval(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_frame_interval_enum *fie)\n{\n\tif (fie->index > S5K5BAF_MAX_FR_TIME - S5K5BAF_MIN_FR_TIME ||\n\t    fie->pad != PAD_CIS)\n\t\treturn -EINVAL;\n\n\tv4l_bound_align_image(&fie->width, S5K5BAF_WIN_WIDTH_MIN,\n\t\t\t      S5K5BAF_CIS_WIDTH, 1,\n\t\t\t      &fie->height, S5K5BAF_WIN_HEIGHT_MIN,\n\t\t\t      S5K5BAF_CIS_HEIGHT, 1, 0);\n\n\tfie->interval.numerator = S5K5BAF_MIN_FR_TIME + fie->index;\n\tfie->interval.denominator = 10000;\n\n\treturn 0;\n}\n\nstatic int s5k5baf_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad == PAD_CIS) {\n\t\tif (code->index > 0)\n\t\t\treturn -EINVAL;\n\t\tcode->code = MEDIA_BUS_FMT_FIXED;\n\t\treturn 0;\n\t}\n\n\tif (code->index >= ARRAY_SIZE(s5k5baf_formats))\n\t\treturn -EINVAL;\n\n\tcode->code = s5k5baf_formats[code->index].code;\n\treturn 0;\n}\n\nstatic int s5k5baf_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tint i;\n\n\tif (fse->index > 0)\n\t\treturn -EINVAL;\n\n\tif (fse->pad == PAD_CIS) {\n\t\tfse->code = MEDIA_BUS_FMT_FIXED;\n\t\tfse->min_width = S5K5BAF_CIS_WIDTH;\n\t\tfse->max_width = S5K5BAF_CIS_WIDTH;\n\t\tfse->min_height = S5K5BAF_CIS_HEIGHT;\n\t\tfse->max_height = S5K5BAF_CIS_HEIGHT;\n\t\treturn 0;\n\t}\n\n\ti = ARRAY_SIZE(s5k5baf_formats);\n\twhile (--i)\n\t\tif (fse->code == s5k5baf_formats[i].code)\n\t\t\tbreak;\n\tfse->code = s5k5baf_formats[i].code;\n\tfse->min_width = S5K5BAF_WIN_WIDTH_MIN;\n\tfse->max_width = S5K5BAF_CIS_WIDTH;\n\tfse->max_height = S5K5BAF_WIN_HEIGHT_MIN;\n\tfse->min_height = S5K5BAF_CIS_HEIGHT;\n\n\treturn 0;\n}\n\nstatic void s5k5baf_try_cis_format(struct v4l2_mbus_framefmt *mf)\n{\n\tmf->width = S5K5BAF_CIS_WIDTH;\n\tmf->height = S5K5BAF_CIS_HEIGHT;\n\tmf->code = MEDIA_BUS_FMT_FIXED;\n\tmf->colorspace = V4L2_COLORSPACE_JPEG;\n\tmf->field = V4L2_FIELD_NONE;\n}\n\nstatic int s5k5baf_try_isp_format(struct v4l2_mbus_framefmt *mf)\n{\n\tint pixfmt;\n\n\tv4l_bound_align_image(&mf->width, S5K5BAF_WIN_WIDTH_MIN,\n\t\t\t      S5K5BAF_CIS_WIDTH, 1,\n\t\t\t      &mf->height, S5K5BAF_WIN_HEIGHT_MIN,\n\t\t\t      S5K5BAF_CIS_HEIGHT, 1, 0);\n\n\tpixfmt = s5k5baf_find_pixfmt(mf);\n\n\tmf->colorspace = s5k5baf_formats[pixfmt].colorspace;\n\tmf->code = s5k5baf_formats[pixfmt].code;\n\tmf->field = V4L2_FIELD_NONE;\n\n\treturn pixfmt;\n}\n\nstatic int s5k5baf_get_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct s5k5baf *state = to_s5k5baf(sd);\n\tconst struct s5k5baf_pixfmt *pixfmt;\n\tstruct v4l2_mbus_framefmt *mf;\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tmf = v4l2_subdev_get_try_format(sd, sd_state, fmt->pad);\n\t\tfmt->format = *mf;\n\t\treturn 0;\n\t}\n\n\tmf = &fmt->format;\n\tif (fmt->pad == PAD_CIS) {\n\t\ts5k5baf_try_cis_format(mf);\n\t\treturn 0;\n\t}\n\tmf->field = V4L2_FIELD_NONE;\n\tmutex_lock(&state->lock);\n\tpixfmt = &s5k5baf_formats[state->pixfmt];\n\tmf->width = state->crop_source.width;\n\tmf->height = state->crop_source.height;\n\tmf->code = pixfmt->code;\n\tmf->colorspace = pixfmt->colorspace;\n\tmutex_unlock(&state->lock);\n\n\treturn 0;\n}\n\nstatic int s5k5baf_set_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct v4l2_mbus_framefmt *mf = &fmt->format;\n\tstruct s5k5baf *state = to_s5k5baf(sd);\n\tconst struct s5k5baf_pixfmt *pixfmt;\n\tint ret = 0;\n\n\tmf->field = V4L2_FIELD_NONE;\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\t*v4l2_subdev_get_try_format(sd, sd_state, fmt->pad) = *mf;\n\t\treturn 0;\n\t}\n\n\tif (fmt->pad == PAD_CIS) {\n\t\ts5k5baf_try_cis_format(mf);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&state->lock);\n\n\tif (state->streaming) {\n\t\tmutex_unlock(&state->lock);\n\t\treturn -EBUSY;\n\t}\n\n\tstate->pixfmt = s5k5baf_try_isp_format(mf);\n\tpixfmt = &s5k5baf_formats[state->pixfmt];\n\tmf->code = pixfmt->code;\n\tmf->colorspace = pixfmt->colorspace;\n\tmf->width = state->crop_source.width;\n\tmf->height = state->crop_source.height;\n\n\tmutex_unlock(&state->lock);\n\treturn ret;\n}\n\nenum selection_rect { R_CIS, R_CROP_SINK, R_COMPOSE, R_CROP_SOURCE, R_INVALID };\n\nstatic enum selection_rect s5k5baf_get_sel_rect(u32 pad, u32 target)\n{\n\tswitch (target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\treturn pad ? R_COMPOSE : R_CIS;\n\tcase V4L2_SEL_TGT_CROP:\n\t\treturn pad ? R_CROP_SOURCE : R_CROP_SINK;\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\treturn pad ? R_INVALID : R_CROP_SINK;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\treturn pad ? R_INVALID : R_COMPOSE;\n\tdefault:\n\t\treturn R_INVALID;\n\t}\n}\n\nstatic int s5k5baf_is_bound_target(u32 target)\n{\n\treturn target == V4L2_SEL_TGT_CROP_BOUNDS ||\n\t\ttarget == V4L2_SEL_TGT_COMPOSE_BOUNDS;\n}\n\nstatic int s5k5baf_get_selection(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_selection *sel)\n{\n\tenum selection_rect rtype;\n\tstruct s5k5baf *state = to_s5k5baf(sd);\n\n\trtype = s5k5baf_get_sel_rect(sel->pad, sel->target);\n\n\tswitch (rtype) {\n\tcase R_INVALID:\n\t\treturn -EINVAL;\n\tcase R_CIS:\n\t\tsel->r = s5k5baf_cis_rect;\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tif (rtype == R_COMPOSE)\n\t\t\tsel->r = *v4l2_subdev_get_try_compose(sd, sd_state,\n\t\t\t\t\t\t\t      sel->pad);\n\t\telse\n\t\t\tsel->r = *v4l2_subdev_get_try_crop(sd, sd_state,\n\t\t\t\t\t\t\t   sel->pad);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&state->lock);\n\tswitch (rtype) {\n\tcase R_CROP_SINK:\n\t\tsel->r = state->crop_sink;\n\t\tbreak;\n\tcase R_COMPOSE:\n\t\tsel->r = state->compose;\n\t\tbreak;\n\tcase R_CROP_SOURCE:\n\t\tsel->r = state->crop_source;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (s5k5baf_is_bound_target(sel->target)) {\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t}\n\tmutex_unlock(&state->lock);\n\n\treturn 0;\n}\n\n \nstatic void s5k5baf_bound_range(u32 *start, u32 *len, u32 max)\n{\n\tif (*len > max)\n\t\t*len = max;\n\tif (*start + *len > max)\n\t\t*start = max - *len;\n\t*start &= ~1;\n\t*len &= ~1;\n\tif (*len < S5K5BAF_WIN_WIDTH_MIN)\n\t\t*len = S5K5BAF_WIN_WIDTH_MIN;\n}\n\nstatic void s5k5baf_bound_rect(struct v4l2_rect *r, u32 width, u32 height)\n{\n\ts5k5baf_bound_range(&r->left, &r->width, width);\n\ts5k5baf_bound_range(&r->top, &r->height, height);\n}\n\nstatic void s5k5baf_set_rect_and_adjust(struct v4l2_rect **rects,\n\t\t\t\t\tenum selection_rect first,\n\t\t\t\t\tstruct v4l2_rect *v)\n{\n\tstruct v4l2_rect *r, *br;\n\tenum selection_rect i = first;\n\n\t*rects[first] = *v;\n\tdo {\n\t\tr = rects[i];\n\t\tbr = rects[i - 1];\n\t\ts5k5baf_bound_rect(r, br->width, br->height);\n\t} while (++i != R_INVALID);\n\t*v = *rects[first];\n}\n\nstatic bool s5k5baf_cmp_rect(const struct v4l2_rect *r1,\n\t\t\t     const struct v4l2_rect *r2)\n{\n\treturn !memcmp(r1, r2, sizeof(*r1));\n}\n\nstatic int s5k5baf_set_selection(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_selection *sel)\n{\n\tstatic enum selection_rect rtype;\n\tstruct s5k5baf *state = to_s5k5baf(sd);\n\tstruct v4l2_rect **rects;\n\tint ret = 0;\n\n\trtype = s5k5baf_get_sel_rect(sel->pad, sel->target);\n\tif (rtype == R_INVALID || s5k5baf_is_bound_target(sel->target))\n\t\treturn -EINVAL;\n\n\t \n\tif (rtype == R_COMPOSE) {\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t}\n\n\tif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\trects = (struct v4l2_rect * []) {\n\t\t\t\t&s5k5baf_cis_rect,\n\t\t\t\tv4l2_subdev_get_try_crop(sd, sd_state,\n\t\t\t\t\t\t\t PAD_CIS),\n\t\t\t\tv4l2_subdev_get_try_compose(sd, sd_state,\n\t\t\t\t\t\t\t    PAD_CIS),\n\t\t\t\tv4l2_subdev_get_try_crop(sd, sd_state,\n\t\t\t\t\t\t\t PAD_OUT)\n\t\t\t};\n\t\ts5k5baf_set_rect_and_adjust(rects, rtype, &sel->r);\n\t\treturn 0;\n\t}\n\n\trects = (struct v4l2_rect * []) {\n\t\t\t&s5k5baf_cis_rect,\n\t\t\t&state->crop_sink,\n\t\t\t&state->compose,\n\t\t\t&state->crop_source\n\t\t};\n\tmutex_lock(&state->lock);\n\tif (state->streaming) {\n\t\t \n\t\tif (rtype < R_CROP_SOURCE) {\n\t\t\tif (sel->r.width < state->crop_source.width)\n\t\t\t\tsel->r.width = state->crop_source.width;\n\t\t\tif (sel->r.height < state->crop_source.height)\n\t\t\t\tsel->r.height = state->crop_source.height;\n\t\t} else {\n\t\t\tsel->r.width = state->crop_source.width;\n\t\t\tsel->r.height = state->crop_source.height;\n\t\t}\n\t}\n\ts5k5baf_set_rect_and_adjust(rects, rtype, &sel->r);\n\tif (!s5k5baf_cmp_rect(&state->crop_sink, &s5k5baf_cis_rect) ||\n\t    !s5k5baf_cmp_rect(&state->compose, &s5k5baf_cis_rect))\n\t\tstate->apply_crop = 1;\n\tif (state->streaming)\n\t\tret = s5k5baf_hw_set_crop_rects(state);\n\tmutex_unlock(&state->lock);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_pad_ops s5k5baf_cis_pad_ops = {\n\t.enum_mbus_code\t\t= s5k5baf_enum_mbus_code,\n\t.enum_frame_size\t= s5k5baf_enum_frame_size,\n\t.get_fmt\t\t= s5k5baf_get_fmt,\n\t.set_fmt\t\t= s5k5baf_set_fmt,\n};\n\nstatic const struct v4l2_subdev_pad_ops s5k5baf_pad_ops = {\n\t.enum_mbus_code\t\t= s5k5baf_enum_mbus_code,\n\t.enum_frame_size\t= s5k5baf_enum_frame_size,\n\t.enum_frame_interval\t= s5k5baf_enum_frame_interval,\n\t.get_fmt\t\t= s5k5baf_get_fmt,\n\t.set_fmt\t\t= s5k5baf_set_fmt,\n\t.get_selection\t\t= s5k5baf_get_selection,\n\t.set_selection\t\t= s5k5baf_set_selection,\n};\n\nstatic const struct v4l2_subdev_video_ops s5k5baf_video_ops = {\n\t.g_frame_interval\t= s5k5baf_g_frame_interval,\n\t.s_frame_interval\t= s5k5baf_s_frame_interval,\n\t.s_stream\t\t= s5k5baf_s_stream,\n};\n\n \n\nstatic int s5k5baf_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = ctrl_to_sd(ctrl);\n\tstruct s5k5baf *state = to_s5k5baf(sd);\n\tint ret;\n\n\tv4l2_dbg(1, debug, sd, \"ctrl: %s, value: %d\\n\", ctrl->name, ctrl->val);\n\n\tmutex_lock(&state->lock);\n\n\tif (state->power == 0)\n\t\tgoto unlock;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\ts5k5baf_hw_set_awb(state, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_BRIGHTNESS:\n\t\ts5k5baf_write(state, REG_USER_BRIGHTNESS, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_COLORFX:\n\t\ts5k5baf_hw_set_colorfx(state, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_CONTRAST:\n\t\ts5k5baf_write(state, REG_USER_CONTRAST, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\ts5k5baf_hw_set_auto_exposure(state, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_HFLIP:\n\t\ts5k5baf_hw_set_mirror(state);\n\t\tbreak;\n\n\tcase V4L2_CID_POWER_LINE_FREQUENCY:\n\t\ts5k5baf_hw_set_anti_flicker(state, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_SATURATION:\n\t\ts5k5baf_write(state, REG_USER_SATURATION, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_SHARPNESS:\n\t\ts5k5baf_write(state, REG_USER_SHARPBLUR, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_WHITE_BALANCE_TEMPERATURE:\n\t\ts5k5baf_write(state, REG_P_COLORTEMP(0), ctrl->val);\n\t\tif (state->apply_cfg)\n\t\t\ts5k5baf_hw_sync_cfg(state);\n\t\tbreak;\n\n\tcase V4L2_CID_TEST_PATTERN:\n\t\ts5k5baf_hw_set_test_pattern(state, ctrl->val);\n\t\tbreak;\n\t}\nunlock:\n\tret = s5k5baf_clear_error(state);\n\tmutex_unlock(&state->lock);\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops s5k5baf_ctrl_ops = {\n\t.s_ctrl\t= s5k5baf_s_ctrl,\n};\n\nstatic const char * const s5k5baf_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Blank\",\n\t\"Bars\",\n\t\"Gradients\",\n\t\"Textile\",\n\t\"Textile2\",\n\t\"Squares\"\n};\n\nstatic int s5k5baf_initialize_ctrls(struct s5k5baf *state)\n{\n\tconst struct v4l2_ctrl_ops *ops = &s5k5baf_ctrl_ops;\n\tstruct s5k5baf_ctrls *ctrls = &state->ctrls;\n\tstruct v4l2_ctrl_handler *hdl = &ctrls->handler;\n\tint ret;\n\n\tret = v4l2_ctrl_handler_init(hdl, 16);\n\tif (ret < 0) {\n\t\tv4l2_err(&state->sd, \"cannot init ctrl handler (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tctrls->awb = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_AUTO_WHITE_BALANCE,\n\t\t\t\t       0, 1, 1, 1);\n\tctrls->gain_red = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_RED_BALANCE,\n\t\t\t\t\t    0, 255, 1, S5K5BAF_GAIN_RED_DEF);\n\tctrls->gain_blue = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_BLUE_BALANCE,\n\t\t\t\t\t     0, 255, 1, S5K5BAF_GAIN_BLUE_DEF);\n\tv4l2_ctrl_auto_cluster(3, &ctrls->awb, 0, false);\n\n\tctrls->hflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HFLIP, 0, 1, 1, 0);\n\tctrls->vflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_cluster(2, &ctrls->hflip);\n\n\tctrls->auto_exp = v4l2_ctrl_new_std_menu(hdl, ops,\n\t\t\t\tV4L2_CID_EXPOSURE_AUTO,\n\t\t\t\tV4L2_EXPOSURE_MANUAL, 0, V4L2_EXPOSURE_AUTO);\n\t \n\tctrls->exposure = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_EXPOSURE,\n\t\t\t\t\t    0, 6000000U, 1, 100000U);\n\t \n\tctrls->gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_GAIN,\n\t\t\t\t\t0, 256, 1, 256);\n\tv4l2_ctrl_auto_cluster(3, &ctrls->auto_exp, 0, false);\n\n\tv4l2_ctrl_new_std_menu(hdl, ops, V4L2_CID_POWER_LINE_FREQUENCY,\n\t\t\t       V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 0,\n\t\t\t       V4L2_CID_POWER_LINE_FREQUENCY_AUTO);\n\n\tv4l2_ctrl_new_std_menu(hdl, ops, V4L2_CID_COLORFX,\n\t\t\t       V4L2_COLORFX_SKY_BLUE, ~0x6f, V4L2_COLORFX_NONE);\n\n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_WHITE_BALANCE_TEMPERATURE,\n\t\t\t  0, 256, 1, 0);\n\n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_SATURATION, -127, 127, 1, 0);\n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_BRIGHTNESS, -127, 127, 1, 0);\n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_CONTRAST, -127, 127, 1, 0);\n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_SHARPNESS, -127, 127, 1, 0);\n\n\tv4l2_ctrl_new_std_menu_items(hdl, ops, V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(s5k5baf_test_pattern_menu) - 1,\n\t\t\t\t     0, 0, s5k5baf_test_pattern_menu);\n\n\tif (hdl->error) {\n\t\tv4l2_err(&state->sd, \"error creating controls (%d)\\n\",\n\t\t\t hdl->error);\n\t\tret = hdl->error;\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\treturn ret;\n\t}\n\n\tstate->sd.ctrl_handler = hdl;\n\treturn 0;\n}\n\n \nstatic int s5k5baf_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_mbus_framefmt *mf;\n\n\tmf = v4l2_subdev_get_try_format(sd, fh->state, PAD_CIS);\n\ts5k5baf_try_cis_format(mf);\n\n\tif (s5k5baf_is_cis_subdev(sd))\n\t\treturn 0;\n\n\tmf = v4l2_subdev_get_try_format(sd, fh->state, PAD_OUT);\n\tmf->colorspace = s5k5baf_formats[0].colorspace;\n\tmf->code = s5k5baf_formats[0].code;\n\tmf->width = s5k5baf_cis_rect.width;\n\tmf->height = s5k5baf_cis_rect.height;\n\tmf->field = V4L2_FIELD_NONE;\n\n\t*v4l2_subdev_get_try_crop(sd, fh->state, PAD_CIS) = s5k5baf_cis_rect;\n\t*v4l2_subdev_get_try_compose(sd, fh->state, PAD_CIS) = s5k5baf_cis_rect;\n\t*v4l2_subdev_get_try_crop(sd, fh->state, PAD_OUT) = s5k5baf_cis_rect;\n\n\treturn 0;\n}\n\nstatic int s5k5baf_check_fw_revision(struct s5k5baf *state)\n{\n\tu16 api_ver = 0, fw_rev = 0, s_id = 0;\n\tint ret;\n\n\tapi_ver = s5k5baf_read(state, REG_FW_APIVER);\n\tfw_rev = s5k5baf_read(state, REG_FW_REVISION) & 0xff;\n\ts_id = s5k5baf_read(state, REG_FW_SENSOR_ID);\n\tret = s5k5baf_clear_error(state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv4l2_info(&state->sd, \"FW API=%#x, revision=%#x sensor_id=%#x\\n\",\n\t\t  api_ver, fw_rev, s_id);\n\n\tif (api_ver != S5K5BAF_FW_APIVER) {\n\t\tv4l2_err(&state->sd, \"FW API version not supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int s5k5baf_registered(struct v4l2_subdev *sd)\n{\n\tstruct s5k5baf *state = to_s5k5baf(sd);\n\tint ret;\n\n\tret = v4l2_device_register_subdev(sd->v4l2_dev, &state->cis_sd);\n\tif (ret < 0)\n\t\tv4l2_err(sd, \"failed to register subdev %s\\n\",\n\t\t\t state->cis_sd.name);\n\telse\n\t\tret = media_create_pad_link(&state->cis_sd.entity, PAD_CIS,\n\t\t\t\t\t       &state->sd.entity, PAD_CIS,\n\t\t\t\t\t       MEDIA_LNK_FL_IMMUTABLE |\n\t\t\t\t\t       MEDIA_LNK_FL_ENABLED);\n\treturn ret;\n}\n\nstatic void s5k5baf_unregistered(struct v4l2_subdev *sd)\n{\n\tstruct s5k5baf *state = to_s5k5baf(sd);\n\tv4l2_device_unregister_subdev(&state->cis_sd);\n}\n\nstatic const struct v4l2_subdev_ops s5k5baf_cis_subdev_ops = {\n\t.pad\t= &s5k5baf_cis_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops s5k5baf_cis_subdev_internal_ops = {\n\t.open = s5k5baf_open,\n};\n\nstatic const struct v4l2_subdev_internal_ops s5k5baf_subdev_internal_ops = {\n\t.registered = s5k5baf_registered,\n\t.unregistered = s5k5baf_unregistered,\n\t.open = s5k5baf_open,\n};\n\nstatic const struct v4l2_subdev_core_ops s5k5baf_core_ops = {\n\t.s_power = s5k5baf_set_power,\n\t.log_status = v4l2_ctrl_subdev_log_status,\n};\n\nstatic const struct v4l2_subdev_ops s5k5baf_subdev_ops = {\n\t.core = &s5k5baf_core_ops,\n\t.pad = &s5k5baf_pad_ops,\n\t.video = &s5k5baf_video_ops,\n};\n\nstatic int s5k5baf_configure_gpios(struct s5k5baf *state)\n{\n\tstatic const char * const name[] = { \"stbyn\", \"rstn\" };\n\tstatic const char * const label[] = { \"S5K5BAF_STBY\", \"S5K5BAF_RST\" };\n\tstruct i2c_client *c = v4l2_get_subdevdata(&state->sd);\n\tstruct gpio_desc *gpio;\n\tint ret, i;\n\n\tfor (i = 0; i < NUM_GPIOS; ++i) {\n\t\tgpio = devm_gpiod_get(&c->dev, name[i], GPIOD_OUT_HIGH);\n\t\tret = PTR_ERR_OR_ZERO(gpio);\n\t\tif (ret) {\n\t\t\tv4l2_err(c, \"failed to request gpio %s: %d\\n\",\n\t\t\t\t name[i], ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = gpiod_set_consumer_name(gpio, label[i]);\n\t\tif (ret) {\n\t\t\tv4l2_err(c, \"failed to set up name for gpio %s: %d\\n\",\n\t\t\t\t name[i], ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tstate->gpios[i] = gpio;\n\t}\n\treturn 0;\n}\n\nstatic int s5k5baf_parse_device_node(struct s5k5baf *state, struct device *dev)\n{\n\tstruct device_node *node = dev->of_node;\n\tstruct device_node *node_ep;\n\tstruct v4l2_fwnode_endpoint ep = { .bus_type = 0 };\n\tint ret;\n\n\tif (!node) {\n\t\tdev_err(dev, \"no device-tree node provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32(node, \"clock-frequency\",\n\t\t\t\t   &state->mclk_frequency);\n\tif (ret < 0) {\n\t\tstate->mclk_frequency = S5K5BAF_DEFAULT_MCLK_FREQ;\n\t\tdev_info(dev, \"using default %u Hz clock frequency\\n\",\n\t\t\t state->mclk_frequency);\n\t}\n\n\tnode_ep = of_graph_get_next_endpoint(node, NULL);\n\tif (!node_ep) {\n\t\tdev_err(dev, \"no endpoint defined at node %pOF\\n\", node);\n\t\treturn -EINVAL;\n\t}\n\n\tret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(node_ep), &ep);\n\tof_node_put(node_ep);\n\tif (ret)\n\t\treturn ret;\n\n\tstate->bus_type = ep.bus_type;\n\n\tswitch (state->bus_type) {\n\tcase V4L2_MBUS_CSI2_DPHY:\n\t\tstate->nlanes = ep.bus.mipi_csi2.num_data_lanes;\n\t\tbreak;\n\tcase V4L2_MBUS_PARALLEL:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported bus in endpoint defined at node %pOF\\n\",\n\t\t\tnode);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int s5k5baf_configure_subdevs(struct s5k5baf *state,\n\t\t\t\t     struct i2c_client *c)\n{\n\tstruct v4l2_subdev *sd;\n\tint ret;\n\n\tsd = &state->cis_sd;\n\tv4l2_subdev_init(sd, &s5k5baf_cis_subdev_ops);\n\tsd->owner = THIS_MODULE;\n\tv4l2_set_subdevdata(sd, state);\n\tsnprintf(sd->name, sizeof(sd->name), \"S5K5BAF-CIS %d-%04x\",\n\t\t i2c_adapter_id(c->adapter), c->addr);\n\n\tsd->internal_ops = &s5k5baf_cis_subdev_internal_ops;\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tstate->cis_pad.flags = MEDIA_PAD_FL_SOURCE;\n\tsd->entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tret = media_entity_pads_init(&sd->entity, NUM_CIS_PADS, &state->cis_pad);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tsd = &state->sd;\n\tv4l2_i2c_subdev_init(sd, c, &s5k5baf_subdev_ops);\n\tsnprintf(sd->name, sizeof(sd->name), \"S5K5BAF-ISP %d-%04x\",\n\t\t i2c_adapter_id(c->adapter), c->addr);\n\n\tsd->internal_ops = &s5k5baf_subdev_internal_ops;\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tstate->pads[PAD_CIS].flags = MEDIA_PAD_FL_SINK;\n\tstate->pads[PAD_OUT].flags = MEDIA_PAD_FL_SOURCE;\n\tsd->entity.function = MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN;\n\tret = media_entity_pads_init(&sd->entity, NUM_ISP_PADS, state->pads);\n\n\tif (!ret)\n\t\treturn 0;\n\n\tmedia_entity_cleanup(&state->cis_sd.entity);\nerr:\n\tdev_err(&c->dev, \"cannot init media entity %s\\n\", sd->name);\n\treturn ret;\n}\n\nstatic int s5k5baf_configure_regulators(struct s5k5baf *state)\n{\n\tstruct i2c_client *c = v4l2_get_subdevdata(&state->sd);\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < S5K5BAF_NUM_SUPPLIES; i++)\n\t\tstate->supplies[i].supply = s5k5baf_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&c->dev, S5K5BAF_NUM_SUPPLIES,\n\t\t\t\t      state->supplies);\n\tif (ret < 0)\n\t\tv4l2_err(c, \"failed to get regulators\\n\");\n\treturn ret;\n}\n\nstatic int s5k5baf_probe(struct i2c_client *c)\n{\n\tstruct s5k5baf *state;\n\tint ret;\n\n\tstate = devm_kzalloc(&c->dev, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&state->lock);\n\tstate->crop_sink = s5k5baf_cis_rect;\n\tstate->compose = s5k5baf_cis_rect;\n\tstate->crop_source = s5k5baf_cis_rect;\n\n\tret = s5k5baf_parse_device_node(state, &c->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = s5k5baf_configure_subdevs(state, c);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = s5k5baf_configure_gpios(state);\n\tif (ret < 0)\n\t\tgoto err_me;\n\n\tret = s5k5baf_configure_regulators(state);\n\tif (ret < 0)\n\t\tgoto err_me;\n\n\tstate->clock = devm_clk_get(state->sd.dev, S5K5BAF_CLK_NAME);\n\tif (IS_ERR(state->clock)) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto err_me;\n\t}\n\n\tret = s5k5baf_power_on(state);\n\tif (ret < 0) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto err_me;\n\t}\n\ts5k5baf_hw_init(state);\n\tret = s5k5baf_check_fw_revision(state);\n\n\ts5k5baf_power_off(state);\n\tif (ret < 0)\n\t\tgoto err_me;\n\n\tret = s5k5baf_initialize_ctrls(state);\n\tif (ret < 0)\n\t\tgoto err_me;\n\n\tret = v4l2_async_register_subdev(&state->sd);\n\tif (ret < 0)\n\t\tgoto err_ctrl;\n\n\treturn 0;\n\nerr_ctrl:\n\tv4l2_ctrl_handler_free(state->sd.ctrl_handler);\nerr_me:\n\tmedia_entity_cleanup(&state->sd.entity);\n\tmedia_entity_cleanup(&state->cis_sd.entity);\n\treturn ret;\n}\n\nstatic void s5k5baf_remove(struct i2c_client *c)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(c);\n\tstruct s5k5baf *state = to_s5k5baf(sd);\n\n\tv4l2_async_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(sd->ctrl_handler);\n\tmedia_entity_cleanup(&sd->entity);\n\n\tsd = &state->cis_sd;\n\tv4l2_device_unregister_subdev(sd);\n\tmedia_entity_cleanup(&sd->entity);\n}\n\nstatic const struct i2c_device_id s5k5baf_id[] = {\n\t{ S5K5BAF_DRIVER_NAME, 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, s5k5baf_id);\n\nstatic const struct of_device_id s5k5baf_of_match[] = {\n\t{ .compatible = \"samsung,s5k5baf\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, s5k5baf_of_match);\n\nstatic struct i2c_driver s5k5baf_i2c_driver = {\n\t.driver = {\n\t\t.of_match_table = s5k5baf_of_match,\n\t\t.name = S5K5BAF_DRIVER_NAME\n\t},\n\t.probe\t\t= s5k5baf_probe,\n\t.remove\t\t= s5k5baf_remove,\n\t.id_table\t= s5k5baf_id,\n};\n\nmodule_i2c_driver(s5k5baf_i2c_driver);\n\nMODULE_DESCRIPTION(\"Samsung S5K5BAF(X) UXGA camera driver\");\nMODULE_AUTHOR(\"Andrzej Hajda <a.hajda@samsung.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}