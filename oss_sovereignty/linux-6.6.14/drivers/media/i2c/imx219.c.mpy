{
  "module_name": "imx219.c",
  "hash_id": "0459f0d1766941f39b8dd4b74b2f87d5891002ea84adf6fbe4963a855c475973",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/imx219.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n\n#include <media/v4l2-cci.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-mediabus.h>\n\n \n#define IMX219_REG_CHIP_ID\t\tCCI_REG16(0x0000)\n#define IMX219_CHIP_ID\t\t\t0x0219\n\n#define IMX219_REG_MODE_SELECT\t\tCCI_REG8(0x0100)\n#define IMX219_MODE_STANDBY\t\t0x00\n#define IMX219_MODE_STREAMING\t\t0x01\n\n#define IMX219_REG_CSI_LANE_MODE\tCCI_REG8(0x0114)\n#define IMX219_CSI_2_LANE_MODE\t\t0x01\n#define IMX219_CSI_4_LANE_MODE\t\t0x03\n\n#define IMX219_REG_DPHY_CTRL\t\tCCI_REG8(0x0128)\n#define IMX219_DPHY_CTRL_TIMING_AUTO\t0\n#define IMX219_DPHY_CTRL_TIMING_MANUAL\t1\n\n#define IMX219_REG_EXCK_FREQ\t\tCCI_REG16(0x012a)\n#define IMX219_EXCK_FREQ(n)\t\t((n) * 256)\t\t \n\n \n#define IMX219_REG_ANALOG_GAIN\t\tCCI_REG8(0x0157)\n#define IMX219_ANA_GAIN_MIN\t\t0\n#define IMX219_ANA_GAIN_MAX\t\t232\n#define IMX219_ANA_GAIN_STEP\t\t1\n#define IMX219_ANA_GAIN_DEFAULT\t\t0x0\n\n \n#define IMX219_REG_DIGITAL_GAIN\t\tCCI_REG16(0x0158)\n#define IMX219_DGTL_GAIN_MIN\t\t0x0100\n#define IMX219_DGTL_GAIN_MAX\t\t0x0fff\n#define IMX219_DGTL_GAIN_DEFAULT\t0x0100\n#define IMX219_DGTL_GAIN_STEP\t\t1\n\n \n#define IMX219_REG_EXPOSURE\t\tCCI_REG16(0x015a)\n#define IMX219_EXPOSURE_MIN\t\t4\n#define IMX219_EXPOSURE_STEP\t\t1\n#define IMX219_EXPOSURE_DEFAULT\t\t0x640\n#define IMX219_EXPOSURE_MAX\t\t65535\n\n \n#define IMX219_REG_VTS\t\t\tCCI_REG16(0x0160)\n#define IMX219_VTS_15FPS\t\t0x0dc6\n#define IMX219_VTS_30FPS_1080P\t\t0x06e3\n#define IMX219_VTS_30FPS_BINNED\t\t0x06e3\n#define IMX219_VTS_30FPS_640x480\t0x06e3\n#define IMX219_VTS_MAX\t\t\t0xffff\n\n#define IMX219_VBLANK_MIN\t\t4\n\n \n#define IMX219_FLL_MIN\t\t\t0x08a6\n#define IMX219_FLL_MAX\t\t\t0xffff\n#define IMX219_FLL_STEP\t\t\t1\n#define IMX219_FLL_DEFAULT\t\t0x0c98\n\n \n#define IMX219_PPL_DEFAULT\t\t3448\n\n#define IMX219_REG_LINE_LENGTH_A\tCCI_REG16(0x0162)\n#define IMX219_REG_X_ADD_STA_A\t\tCCI_REG16(0x0164)\n#define IMX219_REG_X_ADD_END_A\t\tCCI_REG16(0x0166)\n#define IMX219_REG_Y_ADD_STA_A\t\tCCI_REG16(0x0168)\n#define IMX219_REG_Y_ADD_END_A\t\tCCI_REG16(0x016a)\n#define IMX219_REG_X_OUTPUT_SIZE\tCCI_REG16(0x016c)\n#define IMX219_REG_Y_OUTPUT_SIZE\tCCI_REG16(0x016e)\n#define IMX219_REG_X_ODD_INC_A\t\tCCI_REG8(0x0170)\n#define IMX219_REG_Y_ODD_INC_A\t\tCCI_REG8(0x0171)\n#define IMX219_REG_ORIENTATION\t\tCCI_REG8(0x0172)\n\n \n#define IMX219_REG_BINNING_MODE\t\tCCI_REG16(0x0174)\n#define IMX219_BINNING_NONE\t\t0x0000\n#define IMX219_BINNING_2X2\t\t0x0101\n#define IMX219_BINNING_2X2_ANALOG\t0x0303\n\n#define IMX219_REG_CSI_DATA_FORMAT_A\tCCI_REG16(0x018c)\n\n \n#define IMX219_REG_VTPXCK_DIV\t\tCCI_REG8(0x0301)\n#define IMX219_REG_VTSYCK_DIV\t\tCCI_REG8(0x0303)\n#define IMX219_REG_PREPLLCK_VT_DIV\tCCI_REG8(0x0304)\n#define IMX219_REG_PREPLLCK_OP_DIV\tCCI_REG8(0x0305)\n#define IMX219_REG_PLL_VT_MPY\t\tCCI_REG16(0x0306)\n#define IMX219_REG_OPPXCK_DIV\t\tCCI_REG8(0x0309)\n#define IMX219_REG_OPSYCK_DIV\t\tCCI_REG8(0x030b)\n#define IMX219_REG_PLL_OP_MPY\t\tCCI_REG16(0x030c)\n\n \n#define IMX219_REG_TEST_PATTERN\t\tCCI_REG16(0x0600)\n#define IMX219_TEST_PATTERN_DISABLE\t0\n#define IMX219_TEST_PATTERN_SOLID_COLOR\t1\n#define IMX219_TEST_PATTERN_COLOR_BARS\t2\n#define IMX219_TEST_PATTERN_GREY_COLOR\t3\n#define IMX219_TEST_PATTERN_PN9\t\t4\n\n \n#define IMX219_REG_TESTP_RED\t\tCCI_REG16(0x0602)\n#define IMX219_REG_TESTP_GREENR\t\tCCI_REG16(0x0604)\n#define IMX219_REG_TESTP_BLUE\t\tCCI_REG16(0x0606)\n#define IMX219_REG_TESTP_GREENB\t\tCCI_REG16(0x0608)\n#define IMX219_TESTP_COLOUR_MIN\t\t0\n#define IMX219_TESTP_COLOUR_MAX\t\t0x03ff\n#define IMX219_TESTP_COLOUR_STEP\t1\n#define IMX219_TESTP_RED_DEFAULT\tIMX219_TESTP_COLOUR_MAX\n#define IMX219_TESTP_GREENR_DEFAULT\t0\n#define IMX219_TESTP_BLUE_DEFAULT\t0\n#define IMX219_TESTP_GREENB_DEFAULT\t0\n\n#define IMX219_REG_TP_WINDOW_WIDTH\tCCI_REG16(0x0624)\n#define IMX219_REG_TP_WINDOW_HEIGHT\tCCI_REG16(0x0626)\n\n \n#define IMX219_XCLK_FREQ\t\t24000000\n\n \n#define IMX219_PIXEL_RATE\t\t182400000\n#define IMX219_PIXEL_RATE_4LANE\t\t280800000\n\n#define IMX219_DEFAULT_LINK_FREQ\t456000000\n#define IMX219_DEFAULT_LINK_FREQ_4LANE\t363000000\n\n \n#define IMX219_NATIVE_WIDTH\t\t3296U\n#define IMX219_NATIVE_HEIGHT\t\t2480U\n#define IMX219_PIXEL_ARRAY_LEFT\t\t8U\n#define IMX219_PIXEL_ARRAY_TOP\t\t8U\n#define IMX219_PIXEL_ARRAY_WIDTH\t3280U\n#define IMX219_PIXEL_ARRAY_HEIGHT\t2464U\n\nstruct imx219_reg_list {\n\tunsigned int num_of_regs;\n\tconst struct cci_reg_sequence *regs;\n};\n\n \nstruct imx219_mode {\n\t \n\tunsigned int width;\n\t \n\tunsigned int height;\n\n\t \n\tstruct v4l2_rect crop;\n\n\t \n\tunsigned int vts_def;\n\n\t \n\tstruct imx219_reg_list reg_list;\n\n\t \n\tbool binning;\n};\n\nstatic const struct cci_reg_sequence imx219_common_regs[] = {\n\t{ IMX219_REG_MODE_SELECT, 0x00 },\t \n\n\t \n\t{ CCI_REG8(0x30eb), 0x0c },\n\t{ CCI_REG8(0x30eb), 0x05 },\n\t{ CCI_REG8(0x300a), 0xff },\n\t{ CCI_REG8(0x300b), 0xff },\n\t{ CCI_REG8(0x30eb), 0x05 },\n\t{ CCI_REG8(0x30eb), 0x09 },\n\n\t \n\t{ IMX219_REG_VTPXCK_DIV, 5 },\n\t{ IMX219_REG_VTSYCK_DIV, 1 },\n\t{ IMX219_REG_PREPLLCK_VT_DIV, 3 },\t \n\t{ IMX219_REG_PREPLLCK_OP_DIV, 3 },\t \n\t{ IMX219_REG_PLL_VT_MPY, 57 },\n\t{ IMX219_REG_OPSYCK_DIV, 1 },\n\t{ IMX219_REG_PLL_OP_MPY, 114 },\n\n\t \n\t{ CCI_REG8(0x455e), 0x00 },\n\t{ CCI_REG8(0x471e), 0x4b },\n\t{ CCI_REG8(0x4767), 0x0f },\n\t{ CCI_REG8(0x4750), 0x14 },\n\t{ CCI_REG8(0x4540), 0x00 },\n\t{ CCI_REG8(0x47b4), 0x14 },\n\t{ CCI_REG8(0x4713), 0x30 },\n\t{ CCI_REG8(0x478b), 0x10 },\n\t{ CCI_REG8(0x478f), 0x10 },\n\t{ CCI_REG8(0x4793), 0x10 },\n\t{ CCI_REG8(0x4797), 0x0e },\n\t{ CCI_REG8(0x479b), 0x0e },\n\n\t \n\t{ IMX219_REG_LINE_LENGTH_A, 3448 },\n\t{ IMX219_REG_X_ODD_INC_A, 1 },\n\t{ IMX219_REG_Y_ODD_INC_A, 1 },\n\n\t \n\t{ IMX219_REG_DPHY_CTRL, IMX219_DPHY_CTRL_TIMING_AUTO },\n\t{ IMX219_REG_EXCK_FREQ, IMX219_EXCK_FREQ(IMX219_XCLK_FREQ / 1000000) },\n};\n\n \nstatic const struct cci_reg_sequence mode_3280x2464_regs[] = {\n\t{ IMX219_REG_X_ADD_STA_A, 0 },\n\t{ IMX219_REG_X_ADD_END_A, 3279 },\n\t{ IMX219_REG_Y_ADD_STA_A, 0 },\n\t{ IMX219_REG_Y_ADD_END_A, 2463 },\n\t{ IMX219_REG_X_OUTPUT_SIZE, 3280 },\n\t{ IMX219_REG_Y_OUTPUT_SIZE, 2464 },\n\t{ IMX219_REG_TP_WINDOW_WIDTH, 3280 },\n\t{ IMX219_REG_TP_WINDOW_HEIGHT, 2464 },\n};\n\nstatic const struct cci_reg_sequence mode_1920_1080_regs[] = {\n\t{ IMX219_REG_X_ADD_STA_A, 680 },\n\t{ IMX219_REG_X_ADD_END_A, 2599 },\n\t{ IMX219_REG_Y_ADD_STA_A, 692 },\n\t{ IMX219_REG_Y_ADD_END_A, 1771 },\n\t{ IMX219_REG_X_OUTPUT_SIZE, 1920 },\n\t{ IMX219_REG_Y_OUTPUT_SIZE, 1080 },\n\t{ IMX219_REG_TP_WINDOW_WIDTH, 1920 },\n\t{ IMX219_REG_TP_WINDOW_HEIGHT, 1080 },\n};\n\nstatic const struct cci_reg_sequence mode_1640_1232_regs[] = {\n\t{ IMX219_REG_X_ADD_STA_A, 0 },\n\t{ IMX219_REG_X_ADD_END_A, 3279 },\n\t{ IMX219_REG_Y_ADD_STA_A, 0 },\n\t{ IMX219_REG_Y_ADD_END_A, 2463 },\n\t{ IMX219_REG_X_OUTPUT_SIZE, 1640 },\n\t{ IMX219_REG_Y_OUTPUT_SIZE, 1232 },\n\t{ IMX219_REG_TP_WINDOW_WIDTH, 1640 },\n\t{ IMX219_REG_TP_WINDOW_HEIGHT, 1232 },\n};\n\nstatic const struct cci_reg_sequence mode_640_480_regs[] = {\n\t{ IMX219_REG_X_ADD_STA_A, 1000 },\n\t{ IMX219_REG_X_ADD_END_A, 2279 },\n\t{ IMX219_REG_Y_ADD_STA_A, 752 },\n\t{ IMX219_REG_Y_ADD_END_A, 1711 },\n\t{ IMX219_REG_X_OUTPUT_SIZE, 640 },\n\t{ IMX219_REG_Y_OUTPUT_SIZE, 480 },\n\t{ IMX219_REG_TP_WINDOW_WIDTH, 1640 },\n\t{ IMX219_REG_TP_WINDOW_HEIGHT, 1232 },\n};\n\nstatic const struct cci_reg_sequence raw8_framefmt_regs[] = {\n\t{ IMX219_REG_CSI_DATA_FORMAT_A, 0x0808 },\n\t{ IMX219_REG_OPPXCK_DIV, 8 },\n};\n\nstatic const struct cci_reg_sequence raw10_framefmt_regs[] = {\n\t{ IMX219_REG_CSI_DATA_FORMAT_A, 0x0a0a },\n\t{ IMX219_REG_OPPXCK_DIV, 10 },\n};\n\nstatic const s64 imx219_link_freq_menu[] = {\n\tIMX219_DEFAULT_LINK_FREQ,\n};\n\nstatic const s64 imx219_link_freq_4lane_menu[] = {\n\tIMX219_DEFAULT_LINK_FREQ_4LANE,\n};\n\nstatic const char * const imx219_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Color Bars\",\n\t\"Solid Color\",\n\t\"Grey Color Bars\",\n\t\"PN9\"\n};\n\nstatic const int imx219_test_pattern_val[] = {\n\tIMX219_TEST_PATTERN_DISABLE,\n\tIMX219_TEST_PATTERN_COLOR_BARS,\n\tIMX219_TEST_PATTERN_SOLID_COLOR,\n\tIMX219_TEST_PATTERN_GREY_COLOR,\n\tIMX219_TEST_PATTERN_PN9,\n};\n\n \nstatic const char * const imx219_supply_name[] = {\n\t \n\t\"VANA\",   \n\t\"VDIG\",   \n\t\"VDDL\",   \n};\n\n#define IMX219_NUM_SUPPLIES ARRAY_SIZE(imx219_supply_name)\n\n \nstatic const u32 imx219_mbus_formats[] = {\n\tMEDIA_BUS_FMT_SRGGB10_1X10,\n\tMEDIA_BUS_FMT_SGRBG10_1X10,\n\tMEDIA_BUS_FMT_SGBRG10_1X10,\n\tMEDIA_BUS_FMT_SBGGR10_1X10,\n\n\tMEDIA_BUS_FMT_SRGGB8_1X8,\n\tMEDIA_BUS_FMT_SGRBG8_1X8,\n\tMEDIA_BUS_FMT_SGBRG8_1X8,\n\tMEDIA_BUS_FMT_SBGGR8_1X8,\n};\n\n \n#define IMX219_XCLR_MIN_DELAY_US\t6200\n#define IMX219_XCLR_DELAY_RANGE_US\t1000\n\n \nstatic const struct imx219_mode supported_modes[] = {\n\t{\n\t\t \n\t\t.width = 3280,\n\t\t.height = 2464,\n\t\t.crop = {\n\t\t\t.left = IMX219_PIXEL_ARRAY_LEFT,\n\t\t\t.top = IMX219_PIXEL_ARRAY_TOP,\n\t\t\t.width = 3280,\n\t\t\t.height = 2464\n\t\t},\n\t\t.vts_def = IMX219_VTS_15FPS,\n\t\t.reg_list = {\n\t\t\t.num_of_regs = ARRAY_SIZE(mode_3280x2464_regs),\n\t\t\t.regs = mode_3280x2464_regs,\n\t\t},\n\t\t.binning = false,\n\t},\n\t{\n\t\t \n\t\t.width = 1920,\n\t\t.height = 1080,\n\t\t.crop = {\n\t\t\t.left = 688,\n\t\t\t.top = 700,\n\t\t\t.width = 1920,\n\t\t\t.height = 1080\n\t\t},\n\t\t.vts_def = IMX219_VTS_30FPS_1080P,\n\t\t.reg_list = {\n\t\t\t.num_of_regs = ARRAY_SIZE(mode_1920_1080_regs),\n\t\t\t.regs = mode_1920_1080_regs,\n\t\t},\n\t\t.binning = false,\n\t},\n\t{\n\t\t \n\t\t.width = 1640,\n\t\t.height = 1232,\n\t\t.crop = {\n\t\t\t.left = IMX219_PIXEL_ARRAY_LEFT,\n\t\t\t.top = IMX219_PIXEL_ARRAY_TOP,\n\t\t\t.width = 3280,\n\t\t\t.height = 2464\n\t\t},\n\t\t.vts_def = IMX219_VTS_30FPS_BINNED,\n\t\t.reg_list = {\n\t\t\t.num_of_regs = ARRAY_SIZE(mode_1640_1232_regs),\n\t\t\t.regs = mode_1640_1232_regs,\n\t\t},\n\t\t.binning = true,\n\t},\n\t{\n\t\t \n\t\t.width = 640,\n\t\t.height = 480,\n\t\t.crop = {\n\t\t\t.left = 1008,\n\t\t\t.top = 760,\n\t\t\t.width = 1280,\n\t\t\t.height = 960\n\t\t},\n\t\t.vts_def = IMX219_VTS_30FPS_640x480,\n\t\t.reg_list = {\n\t\t\t.num_of_regs = ARRAY_SIZE(mode_640_480_regs),\n\t\t\t.regs = mode_640_480_regs,\n\t\t},\n\t\t.binning = true,\n\t},\n};\n\nstruct imx219 {\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pad;\n\n\tstruct regmap *regmap;\n\tstruct clk *xclk;  \n\tu32 xclk_freq;\n\n\tstruct gpio_desc *reset_gpio;\n\tstruct regulator_bulk_data supplies[IMX219_NUM_SUPPLIES];\n\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\t \n\tstruct v4l2_ctrl *pixel_rate;\n\tstruct v4l2_ctrl *link_freq;\n\tstruct v4l2_ctrl *exposure;\n\tstruct v4l2_ctrl *vflip;\n\tstruct v4l2_ctrl *hflip;\n\tstruct v4l2_ctrl *vblank;\n\tstruct v4l2_ctrl *hblank;\n\n\t \n\tconst struct imx219_mode *mode;\n\n\t \n\tbool streaming;\n\n\t \n\tu8 lanes;\n};\n\nstatic inline struct imx219 *to_imx219(struct v4l2_subdev *_sd)\n{\n\treturn container_of(_sd, struct imx219, sd);\n}\n\n \nstatic u32 imx219_get_format_code(struct imx219 *imx219, u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(imx219_mbus_formats); i++)\n\t\tif (imx219_mbus_formats[i] == code)\n\t\t\tbreak;\n\n\tif (i >= ARRAY_SIZE(imx219_mbus_formats))\n\t\ti = 0;\n\n\ti = (i & ~3) | (imx219->vflip->val ? 2 : 0) |\n\t    (imx219->hflip->val ? 1 : 0);\n\n\treturn imx219_mbus_formats[i];\n}\n\nstatic int imx219_set_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct imx219 *imx219 =\n\t\tcontainer_of(ctrl->handler, struct imx219, ctrl_handler);\n\tstruct i2c_client *client = v4l2_get_subdevdata(&imx219->sd);\n\tint ret = 0;\n\n\tif (ctrl->id == V4L2_CID_VBLANK) {\n\t\tint exposure_max, exposure_def;\n\n\t\t \n\t\texposure_max = imx219->mode->height + ctrl->val - 4;\n\t\texposure_def = (exposure_max < IMX219_EXPOSURE_DEFAULT) ?\n\t\t\texposure_max : IMX219_EXPOSURE_DEFAULT;\n\t\t__v4l2_ctrl_modify_range(imx219->exposure,\n\t\t\t\t\t imx219->exposure->minimum,\n\t\t\t\t\t exposure_max, imx219->exposure->step,\n\t\t\t\t\t exposure_def);\n\t}\n\n\t \n\tif (pm_runtime_get_if_in_use(&client->dev) == 0)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_ANALOGUE_GAIN:\n\t\tcci_write(imx219->regmap, IMX219_REG_ANALOG_GAIN,\n\t\t\t  ctrl->val, &ret);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE:\n\t\tcci_write(imx219->regmap, IMX219_REG_EXPOSURE,\n\t\t\t  ctrl->val, &ret);\n\t\tbreak;\n\tcase V4L2_CID_DIGITAL_GAIN:\n\t\tcci_write(imx219->regmap, IMX219_REG_DIGITAL_GAIN,\n\t\t\t  ctrl->val, &ret);\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tcci_write(imx219->regmap, IMX219_REG_TEST_PATTERN,\n\t\t\t  imx219_test_pattern_val[ctrl->val], &ret);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\tcase V4L2_CID_VFLIP:\n\t\tcci_write(imx219->regmap, IMX219_REG_ORIENTATION,\n\t\t\t  imx219->hflip->val | imx219->vflip->val << 1, &ret);\n\t\tbreak;\n\tcase V4L2_CID_VBLANK:\n\t\tcci_write(imx219->regmap, IMX219_REG_VTS,\n\t\t\t  imx219->mode->height + ctrl->val, &ret);\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN_RED:\n\t\tcci_write(imx219->regmap, IMX219_REG_TESTP_RED,\n\t\t\t  ctrl->val, &ret);\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN_GREENR:\n\t\tcci_write(imx219->regmap, IMX219_REG_TESTP_GREENR,\n\t\t\t  ctrl->val, &ret);\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN_BLUE:\n\t\tcci_write(imx219->regmap, IMX219_REG_TESTP_BLUE,\n\t\t\t  ctrl->val, &ret);\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN_GREENB:\n\t\tcci_write(imx219->regmap, IMX219_REG_TESTP_GREENB,\n\t\t\t  ctrl->val, &ret);\n\t\tbreak;\n\tdefault:\n\t\tdev_info(&client->dev,\n\t\t\t \"ctrl(id:0x%x,val:0x%x) is not handled\\n\",\n\t\t\t ctrl->id, ctrl->val);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tpm_runtime_put(&client->dev);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops imx219_ctrl_ops = {\n\t.s_ctrl = imx219_set_ctrl,\n};\n\nstatic void imx219_update_pad_format(struct imx219 *imx219,\n\t\t\t\t     const struct imx219_mode *mode,\n\t\t\t\t     struct v4l2_mbus_framefmt *fmt, u32 code)\n{\n\t \n\tfmt->code = imx219_get_format_code(imx219, code);\n\tfmt->width = mode->width;\n\tfmt->height = mode->height;\n\tfmt->field = V4L2_FIELD_NONE;\n\tfmt->colorspace = V4L2_COLORSPACE_RAW;\n\tfmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\tfmt->xfer_func = V4L2_XFER_FUNC_NONE;\n}\n\nstatic int imx219_init_cfg(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *state)\n{\n\tstruct imx219 *imx219 = to_imx219(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct v4l2_rect *crop;\n\n\t \n\tformat = v4l2_subdev_get_pad_format(sd, state, 0);\n\timx219_update_pad_format(imx219, &supported_modes[0], format,\n\t\t\t\t MEDIA_BUS_FMT_SRGGB10_1X10);\n\n\t \n\tcrop = v4l2_subdev_get_pad_crop(sd, state, 0);\n\tcrop->top = IMX219_PIXEL_ARRAY_TOP;\n\tcrop->left = IMX219_PIXEL_ARRAY_LEFT;\n\tcrop->width = IMX219_PIXEL_ARRAY_WIDTH;\n\tcrop->height = IMX219_PIXEL_ARRAY_HEIGHT;\n\n\treturn 0;\n}\n\nstatic int imx219_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct imx219 *imx219 = to_imx219(sd);\n\n\tif (code->index >= (ARRAY_SIZE(imx219_mbus_formats) / 4))\n\t\treturn -EINVAL;\n\n\tcode->code = imx219_get_format_code(imx219, imx219_mbus_formats[code->index * 4]);\n\n\treturn 0;\n}\n\nstatic int imx219_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct imx219 *imx219 = to_imx219(sd);\n\tu32 code;\n\n\tif (fse->index >= ARRAY_SIZE(supported_modes))\n\t\treturn -EINVAL;\n\n\tcode = imx219_get_format_code(imx219, fse->code);\n\tif (fse->code != code)\n\t\treturn -EINVAL;\n\n\tfse->min_width = supported_modes[fse->index].width;\n\tfse->max_width = fse->min_width;\n\tfse->min_height = supported_modes[fse->index].height;\n\tfse->max_height = fse->min_height;\n\n\treturn 0;\n}\n\nstatic int imx219_set_pad_format(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_format *fmt)\n{\n\tstruct imx219 *imx219 = to_imx219(sd);\n\tconst struct imx219_mode *mode;\n\tint exposure_max, exposure_def, hblank;\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct v4l2_rect *crop;\n\n\tmode = v4l2_find_nearest_size(supported_modes,\n\t\t\t\t      ARRAY_SIZE(supported_modes),\n\t\t\t\t      width, height,\n\t\t\t\t      fmt->format.width, fmt->format.height);\n\n\timx219_update_pad_format(imx219, mode, &fmt->format, fmt->format.code);\n\n\tformat = v4l2_subdev_get_pad_format(sd, sd_state, 0);\n\tcrop = v4l2_subdev_get_pad_crop(sd, sd_state, 0);\n\n\t*format = fmt->format;\n\t*crop = mode->crop;\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\timx219->mode = mode;\n\t\t \n\t\t__v4l2_ctrl_modify_range(imx219->vblank, IMX219_VBLANK_MIN,\n\t\t\t\t\t IMX219_VTS_MAX - mode->height, 1,\n\t\t\t\t\t mode->vts_def - mode->height);\n\t\t__v4l2_ctrl_s_ctrl(imx219->vblank,\n\t\t\t\t   mode->vts_def - mode->height);\n\t\t \n\t\texposure_max = mode->vts_def - 4;\n\t\texposure_def = (exposure_max < IMX219_EXPOSURE_DEFAULT) ?\n\t\t\texposure_max : IMX219_EXPOSURE_DEFAULT;\n\t\t__v4l2_ctrl_modify_range(imx219->exposure,\n\t\t\t\t\t imx219->exposure->minimum,\n\t\t\t\t\t exposure_max, imx219->exposure->step,\n\t\t\t\t\t exposure_def);\n\t\t \n\t\thblank = IMX219_PPL_DEFAULT - mode->width;\n\t\t__v4l2_ctrl_modify_range(imx219->hblank, hblank, hblank, 1,\n\t\t\t\t\t hblank);\n\t}\n\n\treturn 0;\n}\n\nstatic int imx219_set_framefmt(struct imx219 *imx219,\n\t\t\t       const struct v4l2_mbus_framefmt *format)\n{\n\tswitch (format->code) {\n\tcase MEDIA_BUS_FMT_SRGGB8_1X8:\n\tcase MEDIA_BUS_FMT_SGRBG8_1X8:\n\tcase MEDIA_BUS_FMT_SGBRG8_1X8:\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\t\treturn cci_multi_reg_write(imx219->regmap, raw8_framefmt_regs,\n\t\t\t\t\t   ARRAY_SIZE(raw8_framefmt_regs), NULL);\n\n\tcase MEDIA_BUS_FMT_SRGGB10_1X10:\n\tcase MEDIA_BUS_FMT_SGRBG10_1X10:\n\tcase MEDIA_BUS_FMT_SGBRG10_1X10:\n\tcase MEDIA_BUS_FMT_SBGGR10_1X10:\n\t\treturn cci_multi_reg_write(imx219->regmap, raw10_framefmt_regs,\n\t\t\t\t\t   ARRAY_SIZE(raw10_framefmt_regs), NULL);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int imx219_set_binning(struct imx219 *imx219,\n\t\t\t      const struct v4l2_mbus_framefmt *format)\n{\n\tif (!imx219->mode->binning)\n\t\treturn cci_write(imx219->regmap, IMX219_REG_BINNING_MODE,\n\t\t\t\t IMX219_BINNING_NONE, NULL);\n\n\tswitch (format->code) {\n\tcase MEDIA_BUS_FMT_SRGGB8_1X8:\n\tcase MEDIA_BUS_FMT_SGRBG8_1X8:\n\tcase MEDIA_BUS_FMT_SGBRG8_1X8:\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\t\treturn cci_write(imx219->regmap, IMX219_REG_BINNING_MODE,\n\t\t\t\t IMX219_BINNING_2X2_ANALOG, NULL);\n\n\tcase MEDIA_BUS_FMT_SRGGB10_1X10:\n\tcase MEDIA_BUS_FMT_SGRBG10_1X10:\n\tcase MEDIA_BUS_FMT_SGBRG10_1X10:\n\tcase MEDIA_BUS_FMT_SBGGR10_1X10:\n\t\treturn cci_write(imx219->regmap, IMX219_REG_BINNING_MODE,\n\t\t\t\t IMX219_BINNING_2X2, NULL);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int imx219_get_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP: {\n\t\tsel->r = *v4l2_subdev_get_pad_crop(sd, sd_state, 0);\n\t\treturn 0;\n\t}\n\n\tcase V4L2_SEL_TGT_NATIVE_SIZE:\n\t\tsel->r.top = 0;\n\t\tsel->r.left = 0;\n\t\tsel->r.width = IMX219_NATIVE_WIDTH;\n\t\tsel->r.height = IMX219_NATIVE_HEIGHT;\n\n\t\treturn 0;\n\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.top = IMX219_PIXEL_ARRAY_TOP;\n\t\tsel->r.left = IMX219_PIXEL_ARRAY_LEFT;\n\t\tsel->r.width = IMX219_PIXEL_ARRAY_WIDTH;\n\t\tsel->r.height = IMX219_PIXEL_ARRAY_HEIGHT;\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int imx219_configure_lanes(struct imx219 *imx219)\n{\n\treturn cci_write(imx219->regmap, IMX219_REG_CSI_LANE_MODE,\n\t\t\t imx219->lanes == 2 ? IMX219_CSI_2_LANE_MODE :\n\t\t\t IMX219_CSI_4_LANE_MODE, NULL);\n};\n\nstatic int imx219_start_streaming(struct imx219 *imx219,\n\t\t\t\t  struct v4l2_subdev_state *state)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&imx219->sd);\n\tconst struct v4l2_mbus_framefmt *format;\n\tconst struct imx219_reg_list *reg_list;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(&client->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = cci_multi_reg_write(imx219->regmap, imx219_common_regs,\n\t\t\t\t  ARRAY_SIZE(imx219_common_regs), NULL);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s failed to send mfg header\\n\", __func__);\n\t\tgoto err_rpm_put;\n\t}\n\n\t \n\tret = imx219_configure_lanes(imx219);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s failed to configure lanes\\n\", __func__);\n\t\tgoto err_rpm_put;\n\t}\n\n\t \n\treg_list = &imx219->mode->reg_list;\n\tret = cci_multi_reg_write(imx219->regmap, reg_list->regs,\n\t\t\t\t  reg_list->num_of_regs, NULL);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s failed to set mode\\n\", __func__);\n\t\tgoto err_rpm_put;\n\t}\n\n\tformat = v4l2_subdev_get_pad_format(&imx219->sd, state, 0);\n\tret = imx219_set_framefmt(imx219, format);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s failed to set frame format: %d\\n\",\n\t\t\t__func__, ret);\n\t\tgoto err_rpm_put;\n\t}\n\n\tret = imx219_set_binning(imx219, format);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s failed to set binning: %d\\n\",\n\t\t\t__func__, ret);\n\t\tgoto err_rpm_put;\n\t}\n\n\t \n\tret =  __v4l2_ctrl_handler_setup(imx219->sd.ctrl_handler);\n\tif (ret)\n\t\tgoto err_rpm_put;\n\n\t \n\tret = cci_write(imx219->regmap, IMX219_REG_MODE_SELECT,\n\t\t\tIMX219_MODE_STREAMING, NULL);\n\tif (ret)\n\t\tgoto err_rpm_put;\n\n\t \n\t__v4l2_ctrl_grab(imx219->vflip, true);\n\t__v4l2_ctrl_grab(imx219->hflip, true);\n\n\treturn 0;\n\nerr_rpm_put:\n\tpm_runtime_put(&client->dev);\n\treturn ret;\n}\n\nstatic void imx219_stop_streaming(struct imx219 *imx219)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&imx219->sd);\n\tint ret;\n\n\t \n\tret = cci_write(imx219->regmap, IMX219_REG_MODE_SELECT,\n\t\t\tIMX219_MODE_STANDBY, NULL);\n\tif (ret)\n\t\tdev_err(&client->dev, \"%s failed to set stream\\n\", __func__);\n\n\t__v4l2_ctrl_grab(imx219->vflip, false);\n\t__v4l2_ctrl_grab(imx219->hflip, false);\n\n\tpm_runtime_put(&client->dev);\n}\n\nstatic int imx219_set_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct imx219 *imx219 = to_imx219(sd);\n\tstruct v4l2_subdev_state *state;\n\tint ret = 0;\n\n\tstate = v4l2_subdev_lock_and_get_active_state(sd);\n\n\tif (imx219->streaming == enable)\n\t\tgoto unlock;\n\n\tif (enable) {\n\t\t \n\t\tret = imx219_start_streaming(imx219, state);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t} else {\n\t\timx219_stop_streaming(imx219);\n\t}\n\n\timx219->streaming = enable;\n\nunlock:\n\tv4l2_subdev_unlock_state(state);\n\treturn ret;\n}\n\n \nstatic int imx219_power_on(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct imx219 *imx219 = to_imx219(sd);\n\tint ret;\n\n\tret = regulator_bulk_enable(IMX219_NUM_SUPPLIES,\n\t\t\t\t    imx219->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: failed to enable regulators\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(imx219->xclk);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: failed to enable clock\\n\",\n\t\t\t__func__);\n\t\tgoto reg_off;\n\t}\n\n\tgpiod_set_value_cansleep(imx219->reset_gpio, 1);\n\tusleep_range(IMX219_XCLR_MIN_DELAY_US,\n\t\t     IMX219_XCLR_MIN_DELAY_US + IMX219_XCLR_DELAY_RANGE_US);\n\n\treturn 0;\n\nreg_off:\n\tregulator_bulk_disable(IMX219_NUM_SUPPLIES, imx219->supplies);\n\n\treturn ret;\n}\n\nstatic int imx219_power_off(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct imx219 *imx219 = to_imx219(sd);\n\n\tgpiod_set_value_cansleep(imx219->reset_gpio, 0);\n\tregulator_bulk_disable(IMX219_NUM_SUPPLIES, imx219->supplies);\n\tclk_disable_unprepare(imx219->xclk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused imx219_suspend(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct imx219 *imx219 = to_imx219(sd);\n\n\tif (imx219->streaming)\n\t\timx219_stop_streaming(imx219);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused imx219_resume(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct imx219 *imx219 = to_imx219(sd);\n\tstruct v4l2_subdev_state *state;\n\tint ret;\n\n\tif (imx219->streaming) {\n\t\tstate = v4l2_subdev_lock_and_get_active_state(sd);\n\t\tret = imx219_start_streaming(imx219, state);\n\t\tv4l2_subdev_unlock_state(state);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\timx219_stop_streaming(imx219);\n\timx219->streaming = false;\n\n\treturn ret;\n}\n\nstatic int imx219_get_regulators(struct imx219 *imx219)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&imx219->sd);\n\tunsigned int i;\n\n\tfor (i = 0; i < IMX219_NUM_SUPPLIES; i++)\n\t\timx219->supplies[i].supply = imx219_supply_name[i];\n\n\treturn devm_regulator_bulk_get(&client->dev,\n\t\t\t\t       IMX219_NUM_SUPPLIES,\n\t\t\t\t       imx219->supplies);\n}\n\n \nstatic int imx219_identify_module(struct imx219 *imx219)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&imx219->sd);\n\tint ret;\n\tu64 val;\n\n\tret = cci_read(imx219->regmap, IMX219_REG_CHIP_ID, &val, NULL);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to read chip id %x\\n\",\n\t\t\tIMX219_CHIP_ID);\n\t\treturn ret;\n\t}\n\n\tif (val != IMX219_CHIP_ID) {\n\t\tdev_err(&client->dev, \"chip id mismatch: %x!=%llx\\n\",\n\t\t\tIMX219_CHIP_ID, val);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops imx219_core_ops = {\n\t.subscribe_event = v4l2_ctrl_subdev_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n};\n\nstatic const struct v4l2_subdev_video_ops imx219_video_ops = {\n\t.s_stream = imx219_set_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops imx219_pad_ops = {\n\t.init_cfg = imx219_init_cfg,\n\t.enum_mbus_code = imx219_enum_mbus_code,\n\t.get_fmt = v4l2_subdev_get_fmt,\n\t.set_fmt = imx219_set_pad_format,\n\t.get_selection = imx219_get_selection,\n\t.enum_frame_size = imx219_enum_frame_size,\n};\n\nstatic const struct v4l2_subdev_ops imx219_subdev_ops = {\n\t.core = &imx219_core_ops,\n\t.video = &imx219_video_ops,\n\t.pad = &imx219_pad_ops,\n};\n\n\nstatic unsigned long imx219_get_pixel_rate(struct imx219 *imx219)\n{\n\treturn (imx219->lanes == 2) ? IMX219_PIXEL_RATE : IMX219_PIXEL_RATE_4LANE;\n}\n\n \nstatic int imx219_init_controls(struct imx219 *imx219)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&imx219->sd);\n\tstruct v4l2_ctrl_handler *ctrl_hdlr;\n\tunsigned int height = imx219->mode->height;\n\tstruct v4l2_fwnode_device_properties props;\n\tint exposure_max, exposure_def, hblank;\n\tint i, ret;\n\n\tctrl_hdlr = &imx219->ctrl_handler;\n\tret = v4l2_ctrl_handler_init(ctrl_hdlr, 12);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\timx219->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr, &imx219_ctrl_ops,\n\t\t\t\t\t       V4L2_CID_PIXEL_RATE,\n\t\t\t\t\t       imx219_get_pixel_rate(imx219),\n\t\t\t\t\t       imx219_get_pixel_rate(imx219), 1,\n\t\t\t\t\t       imx219_get_pixel_rate(imx219));\n\n\timx219->link_freq =\n\t\tv4l2_ctrl_new_int_menu(ctrl_hdlr, &imx219_ctrl_ops,\n\t\t\t\t       V4L2_CID_LINK_FREQ,\n\t\t\t\t       ARRAY_SIZE(imx219_link_freq_menu) - 1, 0,\n\t\t\t\t       (imx219->lanes == 2) ? imx219_link_freq_menu :\n\t\t\t\t       imx219_link_freq_4lane_menu);\n\tif (imx219->link_freq)\n\t\timx219->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\t \n\timx219->vblank = v4l2_ctrl_new_std(ctrl_hdlr, &imx219_ctrl_ops,\n\t\t\t\t\t   V4L2_CID_VBLANK, IMX219_VBLANK_MIN,\n\t\t\t\t\t   IMX219_VTS_MAX - height, 1,\n\t\t\t\t\t   imx219->mode->vts_def - height);\n\thblank = IMX219_PPL_DEFAULT - imx219->mode->width;\n\timx219->hblank = v4l2_ctrl_new_std(ctrl_hdlr, &imx219_ctrl_ops,\n\t\t\t\t\t   V4L2_CID_HBLANK, hblank, hblank,\n\t\t\t\t\t   1, hblank);\n\tif (imx219->hblank)\n\t\timx219->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\texposure_max = imx219->mode->vts_def - 4;\n\texposure_def = (exposure_max < IMX219_EXPOSURE_DEFAULT) ?\n\t\texposure_max : IMX219_EXPOSURE_DEFAULT;\n\timx219->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &imx219_ctrl_ops,\n\t\t\t\t\t     V4L2_CID_EXPOSURE,\n\t\t\t\t\t     IMX219_EXPOSURE_MIN, exposure_max,\n\t\t\t\t\t     IMX219_EXPOSURE_STEP,\n\t\t\t\t\t     exposure_def);\n\n\tv4l2_ctrl_new_std(ctrl_hdlr, &imx219_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,\n\t\t\t  IMX219_ANA_GAIN_MIN, IMX219_ANA_GAIN_MAX,\n\t\t\t  IMX219_ANA_GAIN_STEP, IMX219_ANA_GAIN_DEFAULT);\n\n\tv4l2_ctrl_new_std(ctrl_hdlr, &imx219_ctrl_ops, V4L2_CID_DIGITAL_GAIN,\n\t\t\t  IMX219_DGTL_GAIN_MIN, IMX219_DGTL_GAIN_MAX,\n\t\t\t  IMX219_DGTL_GAIN_STEP, IMX219_DGTL_GAIN_DEFAULT);\n\n\timx219->hflip = v4l2_ctrl_new_std(ctrl_hdlr, &imx219_ctrl_ops,\n\t\t\t\t\t  V4L2_CID_HFLIP, 0, 1, 1, 0);\n\tif (imx219->hflip)\n\t\timx219->hflip->flags |= V4L2_CTRL_FLAG_MODIFY_LAYOUT;\n\n\timx219->vflip = v4l2_ctrl_new_std(ctrl_hdlr, &imx219_ctrl_ops,\n\t\t\t\t\t  V4L2_CID_VFLIP, 0, 1, 1, 0);\n\tif (imx219->vflip)\n\t\timx219->vflip->flags |= V4L2_CTRL_FLAG_MODIFY_LAYOUT;\n\n\tv4l2_ctrl_new_std_menu_items(ctrl_hdlr, &imx219_ctrl_ops,\n\t\t\t\t     V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(imx219_test_pattern_menu) - 1,\n\t\t\t\t     0, 0, imx219_test_pattern_menu);\n\tfor (i = 0; i < 4; i++) {\n\t\t \n\t\tv4l2_ctrl_new_std(ctrl_hdlr, &imx219_ctrl_ops,\n\t\t\t\t  V4L2_CID_TEST_PATTERN_RED + i,\n\t\t\t\t  IMX219_TESTP_COLOUR_MIN,\n\t\t\t\t  IMX219_TESTP_COLOUR_MAX,\n\t\t\t\t  IMX219_TESTP_COLOUR_STEP,\n\t\t\t\t  IMX219_TESTP_COLOUR_MAX);\n\t\t \n\t}\n\n\tif (ctrl_hdlr->error) {\n\t\tret = ctrl_hdlr->error;\n\t\tdev_err(&client->dev, \"%s control init failed (%d)\\n\",\n\t\t\t__func__, ret);\n\t\tgoto error;\n\t}\n\n\tret = v4l2_fwnode_device_parse(&client->dev, &props);\n\tif (ret)\n\t\tgoto error;\n\n\tret = v4l2_ctrl_new_fwnode_properties(ctrl_hdlr, &imx219_ctrl_ops,\n\t\t\t\t\t      &props);\n\tif (ret)\n\t\tgoto error;\n\n\timx219->sd.ctrl_handler = ctrl_hdlr;\n\n\treturn 0;\n\nerror:\n\tv4l2_ctrl_handler_free(ctrl_hdlr);\n\n\treturn ret;\n}\n\nstatic void imx219_free_controls(struct imx219 *imx219)\n{\n\tv4l2_ctrl_handler_free(imx219->sd.ctrl_handler);\n}\n\nstatic int imx219_check_hwcfg(struct device *dev, struct imx219 *imx219)\n{\n\tstruct fwnode_handle *endpoint;\n\tstruct v4l2_fwnode_endpoint ep_cfg = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY\n\t};\n\tint ret = -EINVAL;\n\n\tendpoint = fwnode_graph_get_next_endpoint(dev_fwnode(dev), NULL);\n\tif (!endpoint) {\n\t\tdev_err(dev, \"endpoint node not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (v4l2_fwnode_endpoint_alloc_parse(endpoint, &ep_cfg)) {\n\t\tdev_err(dev, \"could not parse endpoint\\n\");\n\t\tgoto error_out;\n\t}\n\n\t \n\tif (ep_cfg.bus.mipi_csi2.num_data_lanes != 2 &&\n\t    ep_cfg.bus.mipi_csi2.num_data_lanes != 4) {\n\t\tdev_err(dev, \"only 2 or 4 data lanes are currently supported\\n\");\n\t\tgoto error_out;\n\t}\n\timx219->lanes = ep_cfg.bus.mipi_csi2.num_data_lanes;\n\n\t \n\tif (!ep_cfg.nr_of_link_frequencies) {\n\t\tdev_err(dev, \"link-frequency property not found in DT\\n\");\n\t\tgoto error_out;\n\t}\n\n\tif (ep_cfg.nr_of_link_frequencies != 1 ||\n\t   (ep_cfg.link_frequencies[0] != ((imx219->lanes == 2) ?\n\t    IMX219_DEFAULT_LINK_FREQ : IMX219_DEFAULT_LINK_FREQ_4LANE))) {\n\t\tdev_err(dev, \"Link frequency not supported: %lld\\n\",\n\t\t\tep_cfg.link_frequencies[0]);\n\t\tgoto error_out;\n\t}\n\n\tret = 0;\n\nerror_out:\n\tv4l2_fwnode_endpoint_free(&ep_cfg);\n\tfwnode_handle_put(endpoint);\n\n\treturn ret;\n}\n\nstatic int imx219_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct imx219 *imx219;\n\tint ret;\n\n\timx219 = devm_kzalloc(&client->dev, sizeof(*imx219), GFP_KERNEL);\n\tif (!imx219)\n\t\treturn -ENOMEM;\n\n\tv4l2_i2c_subdev_init(&imx219->sd, client, &imx219_subdev_ops);\n\n\t \n\tif (imx219_check_hwcfg(dev, imx219))\n\t\treturn -EINVAL;\n\n\timx219->regmap = devm_cci_regmap_init_i2c(client, 16);\n\tif (IS_ERR(imx219->regmap)) {\n\t\tret = PTR_ERR(imx219->regmap);\n\t\tdev_err(dev, \"failed to initialize CCI: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\timx219->xclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(imx219->xclk)) {\n\t\tdev_err(dev, \"failed to get xclk\\n\");\n\t\treturn PTR_ERR(imx219->xclk);\n\t}\n\n\timx219->xclk_freq = clk_get_rate(imx219->xclk);\n\tif (imx219->xclk_freq != IMX219_XCLK_FREQ) {\n\t\tdev_err(dev, \"xclk frequency not supported: %d Hz\\n\",\n\t\t\timx219->xclk_freq);\n\t\treturn -EINVAL;\n\t}\n\n\tret = imx219_get_regulators(imx219);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get regulators\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\timx219->reset_gpio = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t     GPIOD_OUT_HIGH);\n\n\t \n\tret = imx219_power_on(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = imx219_identify_module(imx219);\n\tif (ret)\n\t\tgoto error_power_off;\n\n\t \n\timx219->mode = &supported_modes[0];\n\n\t \n\tret = cci_write(imx219->regmap, IMX219_REG_MODE_SELECT,\n\t\t\tIMX219_MODE_STREAMING, NULL);\n\tif (ret < 0)\n\t\tgoto error_power_off;\n\n\tusleep_range(100, 110);\n\n\t \n\tret = cci_write(imx219->regmap, IMX219_REG_MODE_SELECT,\n\t\t\tIMX219_MODE_STANDBY, NULL);\n\tif (ret < 0)\n\t\tgoto error_power_off;\n\n\tusleep_range(100, 110);\n\n\tret = imx219_init_controls(imx219);\n\tif (ret)\n\t\tgoto error_power_off;\n\n\t \n\timx219->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |\n\t\t\t    V4L2_SUBDEV_FL_HAS_EVENTS;\n\timx219->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\n\t \n\timx219->pad.flags = MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&imx219->sd.entity, 1, &imx219->pad);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to init entity pads: %d\\n\", ret);\n\t\tgoto error_handler_free;\n\t}\n\n\timx219->sd.state_lock = imx219->ctrl_handler.lock;\n\tret = v4l2_subdev_init_finalize(&imx219->sd);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"subdev init error: %d\\n\", ret);\n\t\tgoto error_media_entity;\n\t}\n\n\tret = v4l2_async_register_subdev_sensor(&imx219->sd);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to register sensor sub-device: %d\\n\", ret);\n\t\tgoto error_subdev_cleanup;\n\t}\n\n\t \n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_idle(dev);\n\n\treturn 0;\n\nerror_subdev_cleanup:\n\tv4l2_subdev_cleanup(&imx219->sd);\n\nerror_media_entity:\n\tmedia_entity_cleanup(&imx219->sd.entity);\n\nerror_handler_free:\n\timx219_free_controls(imx219);\n\nerror_power_off:\n\timx219_power_off(dev);\n\n\treturn ret;\n}\n\nstatic void imx219_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct imx219 *imx219 = to_imx219(sd);\n\n\tv4l2_async_unregister_subdev(sd);\n\tv4l2_subdev_cleanup(sd);\n\tmedia_entity_cleanup(&sd->entity);\n\timx219_free_controls(imx219);\n\n\tpm_runtime_disable(&client->dev);\n\tif (!pm_runtime_status_suspended(&client->dev))\n\t\timx219_power_off(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n}\n\nstatic const struct of_device_id imx219_dt_ids[] = {\n\t{ .compatible = \"sony,imx219\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx219_dt_ids);\n\nstatic const struct dev_pm_ops imx219_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(imx219_suspend, imx219_resume)\n\tSET_RUNTIME_PM_OPS(imx219_power_off, imx219_power_on, NULL)\n};\n\nstatic struct i2c_driver imx219_i2c_driver = {\n\t.driver = {\n\t\t.name = \"imx219\",\n\t\t.of_match_table\t= imx219_dt_ids,\n\t\t.pm = &imx219_pm_ops,\n\t},\n\t.probe = imx219_probe,\n\t.remove = imx219_remove,\n};\n\nmodule_i2c_driver(imx219_i2c_driver);\n\nMODULE_AUTHOR(\"Dave Stevenson <dave.stevenson@raspberrypi.com\");\nMODULE_DESCRIPTION(\"Sony IMX219 sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}