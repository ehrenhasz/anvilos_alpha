{
  "module_name": "ccs-pll.c",
  "hash_id": "a9b7abe7ac5a7bbaadcbf45141dc7853638c12c42d14e16dd448f2a96f96a891",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ccs-pll.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/gcd.h>\n#include <linux/lcm.h>\n#include <linux/module.h>\n\n#include \"ccs-pll.h\"\n\n \nstatic inline u32 clk_div_even(u32 a)\n{\n\treturn max_t(u32, 1, a & ~1);\n}\n\n \nstatic inline u32 clk_div_even_up(u32 a)\n{\n\tif (a == 1)\n\t\treturn 1;\n\treturn (a + 1) & ~1;\n}\n\nstatic inline u32 is_one_or_even(u32 a)\n{\n\tif (a == 1)\n\t\treturn 1;\n\tif (a & 1)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic inline u32 one_or_more(u32 a)\n{\n\treturn a ?: 1;\n}\n\nstatic int bounds_check(struct device *dev, u32 val,\n\t\t\tu32 min, u32 max, const char *prefix,\n\t\t\tchar *str)\n{\n\tif (val >= min && val <= max)\n\t\treturn 0;\n\n\tdev_dbg(dev, \"%s_%s out of bounds: %d (%d--%d)\\n\", prefix,\n\t\tstr, val, min, max);\n\n\treturn -EINVAL;\n}\n\n#define PLL_OP 1\n#define PLL_VT 2\n\nstatic const char *pll_string(unsigned int which)\n{\n\tswitch (which) {\n\tcase PLL_OP:\n\t\treturn \"op\";\n\tcase PLL_VT:\n\t\treturn \"vt\";\n\t}\n\n\treturn NULL;\n}\n\n#define PLL_FL(f) CCS_PLL_FLAG_##f\n\nstatic void print_pll(struct device *dev, struct ccs_pll *pll)\n{\n\tconst struct {\n\t\tstruct ccs_pll_branch_fr *fr;\n\t\tstruct ccs_pll_branch_bk *bk;\n\t\tunsigned int which;\n\t} branches[] = {\n\t\t{ &pll->vt_fr, &pll->vt_bk, PLL_VT },\n\t\t{ &pll->op_fr, &pll->op_bk, PLL_OP }\n\t}, *br;\n\tunsigned int i;\n\n\tdev_dbg(dev, \"ext_clk_freq_hz\\t\\t%u\\n\", pll->ext_clk_freq_hz);\n\n\tfor (i = 0, br = branches; i < ARRAY_SIZE(branches); i++, br++) {\n\t\tconst char *s = pll_string(br->which);\n\n\t\tif (pll->flags & CCS_PLL_FLAG_DUAL_PLL ||\n\t\t    br->which == PLL_VT) {\n\t\t\tdev_dbg(dev, \"%s_pre_pll_clk_div\\t\\t%u\\n\",  s,\n\t\t\t\tbr->fr->pre_pll_clk_div);\n\t\t\tdev_dbg(dev, \"%s_pll_multiplier\\t\\t%u\\n\",  s,\n\t\t\t\tbr->fr->pll_multiplier);\n\n\t\t\tdev_dbg(dev, \"%s_pll_ip_clk_freq_hz\\t%u\\n\", s,\n\t\t\t\tbr->fr->pll_ip_clk_freq_hz);\n\t\t\tdev_dbg(dev, \"%s_pll_op_clk_freq_hz\\t%u\\n\", s,\n\t\t\t\tbr->fr->pll_op_clk_freq_hz);\n\t\t}\n\n\t\tif (!(pll->flags & CCS_PLL_FLAG_NO_OP_CLOCKS) ||\n\t\t    br->which == PLL_VT) {\n\t\t\tdev_dbg(dev, \"%s_sys_clk_div\\t\\t%u\\n\",  s,\n\t\t\t\tbr->bk->sys_clk_div);\n\t\t\tdev_dbg(dev, \"%s_pix_clk_div\\t\\t%u\\n\", s,\n\t\t\t\tbr->bk->pix_clk_div);\n\n\t\t\tdev_dbg(dev, \"%s_sys_clk_freq_hz\\t%u\\n\", s,\n\t\t\t\tbr->bk->sys_clk_freq_hz);\n\t\t\tdev_dbg(dev, \"%s_pix_clk_freq_hz\\t%u\\n\", s,\n\t\t\t\tbr->bk->pix_clk_freq_hz);\n\t\t}\n\t}\n\n\tdev_dbg(dev, \"pixel rate in pixel array:\\t%u\\n\",\n\t\tpll->pixel_rate_pixel_array);\n\tdev_dbg(dev, \"pixel rate on CSI-2 bus:\\t%u\\n\",\n\t\tpll->pixel_rate_csi);\n\n\tdev_dbg(dev, \"flags%s%s%s%s%s%s%s%s%s\\n\",\n\t\tpll->flags & PLL_FL(LANE_SPEED_MODEL) ? \" lane-speed\" : \"\",\n\t\tpll->flags & PLL_FL(LINK_DECOUPLED) ? \" link-decoupled\" : \"\",\n\t\tpll->flags & PLL_FL(EXT_IP_PLL_DIVIDER) ?\n\t\t\" ext-ip-pll-divider\" : \"\",\n\t\tpll->flags & PLL_FL(FLEXIBLE_OP_PIX_CLK_DIV) ?\n\t\t\" flexible-op-pix-div\" : \"\",\n\t\tpll->flags & PLL_FL(FIFO_DERATING) ? \" fifo-derating\" : \"\",\n\t\tpll->flags & PLL_FL(FIFO_OVERRATING) ? \" fifo-overrating\" : \"\",\n\t\tpll->flags & PLL_FL(DUAL_PLL) ? \" dual-pll\" : \"\",\n\t\tpll->flags & PLL_FL(OP_SYS_DDR) ? \" op-sys-ddr\" : \"\",\n\t\tpll->flags & PLL_FL(OP_PIX_DDR) ? \" op-pix-ddr\" : \"\");\n}\n\nstatic u32 op_sys_ddr(u32 flags)\n{\n\treturn flags & CCS_PLL_FLAG_OP_SYS_DDR ? 1 : 0;\n}\n\nstatic u32 op_pix_ddr(u32 flags)\n{\n\treturn flags & CCS_PLL_FLAG_OP_PIX_DDR ? 1 : 0;\n}\n\nstatic int check_fr_bounds(struct device *dev,\n\t\t\t   const struct ccs_pll_limits *lim,\n\t\t\t   struct ccs_pll *pll, unsigned int which)\n{\n\tconst struct ccs_pll_branch_limits_fr *lim_fr;\n\tstruct ccs_pll_branch_fr *pll_fr;\n\tconst char *s = pll_string(which);\n\tint rval;\n\n\tif (which == PLL_OP) {\n\t\tlim_fr = &lim->op_fr;\n\t\tpll_fr = &pll->op_fr;\n\t} else {\n\t\tlim_fr = &lim->vt_fr;\n\t\tpll_fr = &pll->vt_fr;\n\t}\n\n\trval = bounds_check(dev, pll_fr->pre_pll_clk_div,\n\t\t\t    lim_fr->min_pre_pll_clk_div,\n\t\t\t    lim_fr->max_pre_pll_clk_div, s, \"pre_pll_clk_div\");\n\n\tif (!rval)\n\t\trval = bounds_check(dev, pll_fr->pll_ip_clk_freq_hz,\n\t\t\t\t    lim_fr->min_pll_ip_clk_freq_hz,\n\t\t\t\t    lim_fr->max_pll_ip_clk_freq_hz,\n\t\t\t\t    s, \"pll_ip_clk_freq_hz\");\n\tif (!rval)\n\t\trval = bounds_check(dev, pll_fr->pll_multiplier,\n\t\t\t\t    lim_fr->min_pll_multiplier,\n\t\t\t\t    lim_fr->max_pll_multiplier,\n\t\t\t\t    s, \"pll_multiplier\");\n\tif (!rval)\n\t\trval = bounds_check(dev, pll_fr->pll_op_clk_freq_hz,\n\t\t\t\t    lim_fr->min_pll_op_clk_freq_hz,\n\t\t\t\t    lim_fr->max_pll_op_clk_freq_hz,\n\t\t\t\t    s, \"pll_op_clk_freq_hz\");\n\n\treturn rval;\n}\n\nstatic int check_bk_bounds(struct device *dev,\n\t\t\t   const struct ccs_pll_limits *lim,\n\t\t\t   struct ccs_pll *pll, unsigned int which)\n{\n\tconst struct ccs_pll_branch_limits_bk *lim_bk;\n\tstruct ccs_pll_branch_bk *pll_bk;\n\tconst char *s = pll_string(which);\n\tint rval;\n\n\tif (which == PLL_OP) {\n\t\tif (pll->flags & CCS_PLL_FLAG_NO_OP_CLOCKS)\n\t\t\treturn 0;\n\n\t\tlim_bk = &lim->op_bk;\n\t\tpll_bk = &pll->op_bk;\n\t} else {\n\t\tlim_bk = &lim->vt_bk;\n\t\tpll_bk = &pll->vt_bk;\n\t}\n\n\trval = bounds_check(dev, pll_bk->sys_clk_div,\n\t\t\t    lim_bk->min_sys_clk_div,\n\t\t\t    lim_bk->max_sys_clk_div, s, \"op_sys_clk_div\");\n\tif (!rval)\n\t\trval = bounds_check(dev, pll_bk->sys_clk_freq_hz,\n\t\t\t\t    lim_bk->min_sys_clk_freq_hz,\n\t\t\t\t    lim_bk->max_sys_clk_freq_hz,\n\t\t\t\t    s, \"sys_clk_freq_hz\");\n\tif (!rval)\n\t\trval = bounds_check(dev, pll_bk->sys_clk_div,\n\t\t\t\t    lim_bk->min_sys_clk_div,\n\t\t\t\t    lim_bk->max_sys_clk_div,\n\t\t\t\t    s, \"sys_clk_div\");\n\tif (!rval)\n\t\trval = bounds_check(dev, pll_bk->pix_clk_freq_hz,\n\t\t\t\t    lim_bk->min_pix_clk_freq_hz,\n\t\t\t\t    lim_bk->max_pix_clk_freq_hz,\n\t\t\t\t    s, \"pix_clk_freq_hz\");\n\n\treturn rval;\n}\n\nstatic int check_ext_bounds(struct device *dev, struct ccs_pll *pll)\n{\n\tif (!(pll->flags & CCS_PLL_FLAG_FIFO_DERATING) &&\n\t    pll->pixel_rate_pixel_array > pll->pixel_rate_csi) {\n\t\tdev_dbg(dev, \"device does not support derating\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(pll->flags & CCS_PLL_FLAG_FIFO_OVERRATING) &&\n\t    pll->pixel_rate_pixel_array < pll->pixel_rate_csi) {\n\t\tdev_dbg(dev, \"device does not support overrating\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nccs_pll_find_vt_sys_div(struct device *dev, const struct ccs_pll_limits *lim,\n\t\t\tstruct ccs_pll *pll, struct ccs_pll_branch_fr *pll_fr,\n\t\t\tu16 min_vt_div, u16 max_vt_div,\n\t\t\tu16 *min_sys_div, u16 *max_sys_div)\n{\n\t \n\t*min_sys_div = lim->vt_bk.min_sys_clk_div;\n\tdev_dbg(dev, \"min_sys_div: %u\\n\", *min_sys_div);\n\t*min_sys_div = max_t(u16, *min_sys_div,\n\t\t\t     DIV_ROUND_UP(min_vt_div,\n\t\t\t\t\t  lim->vt_bk.max_pix_clk_div));\n\tdev_dbg(dev, \"min_sys_div: max_vt_pix_clk_div: %u\\n\", *min_sys_div);\n\t*min_sys_div = max_t(u16, *min_sys_div,\n\t\t\t     pll_fr->pll_op_clk_freq_hz\n\t\t\t     / lim->vt_bk.max_sys_clk_freq_hz);\n\tdev_dbg(dev, \"min_sys_div: max_pll_op_clk_freq_hz: %u\\n\", *min_sys_div);\n\t*min_sys_div = clk_div_even_up(*min_sys_div);\n\tdev_dbg(dev, \"min_sys_div: one or even: %u\\n\", *min_sys_div);\n\n\t*max_sys_div = lim->vt_bk.max_sys_clk_div;\n\tdev_dbg(dev, \"max_sys_div: %u\\n\", *max_sys_div);\n\t*max_sys_div = min_t(u16, *max_sys_div,\n\t\t\t     DIV_ROUND_UP(max_vt_div,\n\t\t\t\t\t  lim->vt_bk.min_pix_clk_div));\n\tdev_dbg(dev, \"max_sys_div: min_vt_pix_clk_div: %u\\n\", *max_sys_div);\n\t*max_sys_div = min_t(u16, *max_sys_div,\n\t\t\t     DIV_ROUND_UP(pll_fr->pll_op_clk_freq_hz,\n\t\t\t\t\t  lim->vt_bk.min_pix_clk_freq_hz));\n\tdev_dbg(dev, \"max_sys_div: min_vt_pix_clk_freq_hz: %u\\n\", *max_sys_div);\n}\n\n#define CPHY_CONST\t\t7\n#define DPHY_CONST\t\t16\n#define PHY_CONST_DIV\t\t16\n\nstatic inline int\n__ccs_pll_calculate_vt_tree(struct device *dev,\n\t\t\t    const struct ccs_pll_limits *lim,\n\t\t\t    struct ccs_pll *pll, u32 mul, u32 div)\n{\n\tconst struct ccs_pll_branch_limits_fr *lim_fr = &lim->vt_fr;\n\tconst struct ccs_pll_branch_limits_bk *lim_bk = &lim->vt_bk;\n\tstruct ccs_pll_branch_fr *pll_fr = &pll->vt_fr;\n\tstruct ccs_pll_branch_bk *pll_bk = &pll->vt_bk;\n\tu32 more_mul;\n\tu16 best_pix_div = SHRT_MAX >> 1, best_div = lim_bk->max_sys_clk_div;\n\tu16 vt_div, min_sys_div, max_sys_div, sys_div;\n\n\tpll_fr->pll_ip_clk_freq_hz =\n\t\tpll->ext_clk_freq_hz / pll_fr->pre_pll_clk_div;\n\n\tdev_dbg(dev, \"vt_pll_ip_clk_freq_hz %u\\n\", pll_fr->pll_ip_clk_freq_hz);\n\n\tmore_mul = one_or_more(DIV_ROUND_UP(lim_fr->min_pll_op_clk_freq_hz,\n\t\t\t\t\t    pll_fr->pll_ip_clk_freq_hz * mul));\n\n\tdev_dbg(dev, \"more_mul: %u\\n\", more_mul);\n\tmore_mul *= DIV_ROUND_UP(lim_fr->min_pll_multiplier, mul * more_mul);\n\tdev_dbg(dev, \"more_mul2: %u\\n\", more_mul);\n\n\tpll_fr->pll_multiplier = mul * more_mul;\n\n\tif (pll_fr->pll_multiplier * pll_fr->pll_ip_clk_freq_hz >\n\t    lim_fr->max_pll_op_clk_freq_hz)\n\t\treturn -EINVAL;\n\n\tpll_fr->pll_op_clk_freq_hz =\n\t\tpll_fr->pll_ip_clk_freq_hz * pll_fr->pll_multiplier;\n\n\tvt_div = div * more_mul;\n\n\tccs_pll_find_vt_sys_div(dev, lim, pll, pll_fr, vt_div, vt_div,\n\t\t\t\t&min_sys_div, &max_sys_div);\n\n\tmax_sys_div = (vt_div & 1) ? 1 : max_sys_div;\n\n\tdev_dbg(dev, \"vt min/max_sys_div: %u,%u\\n\", min_sys_div, max_sys_div);\n\n\tfor (sys_div = min_sys_div; sys_div <= max_sys_div;\n\t     sys_div += 2 - (sys_div & 1)) {\n\t\tu16 pix_div;\n\n\t\tif (vt_div % sys_div)\n\t\t\tcontinue;\n\n\t\tpix_div = vt_div / sys_div;\n\n\t\tif (pix_div < lim_bk->min_pix_clk_div ||\n\t\t    pix_div > lim_bk->max_pix_clk_div) {\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"pix_div %u too small or too big (%u--%u)\\n\",\n\t\t\t\tpix_div,\n\t\t\t\tlim_bk->min_pix_clk_div,\n\t\t\t\tlim_bk->max_pix_clk_div);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdev_dbg(dev, \"sys/pix/best_pix: %u,%u,%u\\n\", sys_div, pix_div,\n\t\t\tbest_pix_div);\n\n\t\tif (pix_div * sys_div <= best_pix_div) {\n\t\t\tbest_pix_div = pix_div;\n\t\t\tbest_div = pix_div * sys_div;\n\t\t}\n\t}\n\tif (best_pix_div == SHRT_MAX >> 1)\n\t\treturn -EINVAL;\n\n\tpll_bk->sys_clk_div = best_div / best_pix_div;\n\tpll_bk->pix_clk_div = best_pix_div;\n\n\tpll_bk->sys_clk_freq_hz =\n\t\tpll_fr->pll_op_clk_freq_hz / pll_bk->sys_clk_div;\n\tpll_bk->pix_clk_freq_hz =\n\t\tpll_bk->sys_clk_freq_hz / pll_bk->pix_clk_div;\n\n\tpll->pixel_rate_pixel_array =\n\t\tpll_bk->pix_clk_freq_hz * pll->vt_lanes;\n\n\treturn 0;\n}\n\nstatic int ccs_pll_calculate_vt_tree(struct device *dev,\n\t\t\t\t     const struct ccs_pll_limits *lim,\n\t\t\t\t     struct ccs_pll *pll)\n{\n\tconst struct ccs_pll_branch_limits_fr *lim_fr = &lim->vt_fr;\n\tstruct ccs_pll_branch_fr *pll_fr = &pll->vt_fr;\n\tu16 min_pre_pll_clk_div = lim_fr->min_pre_pll_clk_div;\n\tu16 max_pre_pll_clk_div = lim_fr->max_pre_pll_clk_div;\n\tu32 pre_mul, pre_div;\n\n\tpre_div = gcd(pll->pixel_rate_csi,\n\t\t      pll->ext_clk_freq_hz * pll->vt_lanes);\n\tpre_mul = pll->pixel_rate_csi / pre_div;\n\tpre_div = pll->ext_clk_freq_hz * pll->vt_lanes / pre_div;\n\n\t \n\tmax_pre_pll_clk_div =\n\t\tmin_t(u16, max_pre_pll_clk_div,\n\t\t      DIV_ROUND_UP(pll->ext_clk_freq_hz,\n\t\t\t\t   lim_fr->min_pll_ip_clk_freq_hz));\n\n\tmin_pre_pll_clk_div = max_t(u16, min_pre_pll_clk_div,\n\t\t\t\t    pll->ext_clk_freq_hz /\n\t\t\t\t    lim_fr->max_pll_ip_clk_freq_hz);\n\n\tdev_dbg(dev, \"vt min/max_pre_pll_clk_div: %u,%u\\n\",\n\t\tmin_pre_pll_clk_div, max_pre_pll_clk_div);\n\n\tfor (pll_fr->pre_pll_clk_div = min_pre_pll_clk_div;\n\t     pll_fr->pre_pll_clk_div <= max_pre_pll_clk_div;\n\t     pll_fr->pre_pll_clk_div +=\n\t\t     (pll->flags & CCS_PLL_FLAG_EXT_IP_PLL_DIVIDER) ? 1 :\n\t\t     2 - (pll_fr->pre_pll_clk_div & 1)) {\n\t\tu32 mul, div;\n\t\tint rval;\n\n\t\tdiv = gcd(pre_mul * pll_fr->pre_pll_clk_div, pre_div);\n\t\tmul = pre_mul * pll_fr->pre_pll_clk_div / div;\n\t\tdiv = pre_div / div;\n\n\t\tdev_dbg(dev, \"vt pre-div/mul/div: %u,%u,%u\\n\",\n\t\t\tpll_fr->pre_pll_clk_div, mul, div);\n\n\t\trval = __ccs_pll_calculate_vt_tree(dev, lim, pll,\n\t\t\t\t\t\t   mul, div);\n\t\tif (rval)\n\t\t\tcontinue;\n\n\t\trval = check_fr_bounds(dev, lim, pll, PLL_VT);\n\t\tif (rval)\n\t\t\tcontinue;\n\n\t\trval = check_bk_bounds(dev, lim, pll, PLL_VT);\n\t\tif (rval)\n\t\t\tcontinue;\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void\nccs_pll_calculate_vt(struct device *dev, const struct ccs_pll_limits *lim,\n\t\t     const struct ccs_pll_branch_limits_bk *op_lim_bk,\n\t\t     struct ccs_pll *pll, struct ccs_pll_branch_fr *pll_fr,\n\t\t     struct ccs_pll_branch_bk *op_pll_bk, bool cphy,\n\t\t     u32 phy_const)\n{\n\tu16 sys_div;\n\tu16 best_pix_div = SHRT_MAX >> 1;\n\tu16 vt_op_binning_div;\n\tu16 min_vt_div, max_vt_div, vt_div;\n\tu16 min_sys_div, max_sys_div;\n\n\tif (pll->flags & CCS_PLL_FLAG_NO_OP_CLOCKS)\n\t\tgoto out_calc_pixel_rate;\n\n\t \n\tif (!(pll->flags & CCS_PLL_FLAG_FIFO_DERATING)) {\n\t\tmin_vt_div =\n\t\t\top_pll_bk->sys_clk_div * op_pll_bk->pix_clk_div\n\t\t\t* pll->vt_lanes * phy_const / pll->op_lanes\n\t\t\t/ (PHY_CONST_DIV << op_pix_ddr(pll->flags));\n\t} else {\n\t\t \n\t\tif (lim->min_line_length_pck_bin > lim->min_line_length_pck\n\t\t    / pll->binning_horizontal)\n\t\t\tvt_op_binning_div = pll->binning_horizontal;\n\t\telse\n\t\t\tvt_op_binning_div = 1;\n\t\tdev_dbg(dev, \"vt_op_binning_div: %u\\n\", vt_op_binning_div);\n\n\t\t \n\t\tdev_dbg(dev, \"scale_m: %u\\n\", pll->scale_m);\n\t\tmin_vt_div =\n\t\t\tDIV_ROUND_UP(pll->bits_per_pixel\n\t\t\t\t     * op_pll_bk->sys_clk_div * pll->scale_n\n\t\t\t\t     * pll->vt_lanes * phy_const,\n\t\t\t\t     (pll->flags &\n\t\t\t\t      CCS_PLL_FLAG_LANE_SPEED_MODEL ?\n\t\t\t\t      pll->csi2.lanes : 1)\n\t\t\t\t     * vt_op_binning_div * pll->scale_m\n\t\t\t\t     * PHY_CONST_DIV << op_pix_ddr(pll->flags));\n\t}\n\n\t \n\tdev_dbg(dev, \"min_vt_div: %u\\n\", min_vt_div);\n\tmin_vt_div = max_t(u16, min_vt_div,\n\t\t\t   DIV_ROUND_UP(pll_fr->pll_op_clk_freq_hz,\n\t\t\t\t\tlim->vt_bk.max_pix_clk_freq_hz));\n\tdev_dbg(dev, \"min_vt_div: max_vt_pix_clk_freq_hz: %u\\n\",\n\t\tmin_vt_div);\n\tmin_vt_div = max_t(u16, min_vt_div, lim->vt_bk.min_pix_clk_div\n\t\t\t\t\t    * lim->vt_bk.min_sys_clk_div);\n\tdev_dbg(dev, \"min_vt_div: min_vt_clk_div: %u\\n\", min_vt_div);\n\n\tmax_vt_div = lim->vt_bk.max_sys_clk_div * lim->vt_bk.max_pix_clk_div;\n\tdev_dbg(dev, \"max_vt_div: %u\\n\", max_vt_div);\n\tmax_vt_div = min_t(u16, max_vt_div,\n\t\t\t   DIV_ROUND_UP(pll_fr->pll_op_clk_freq_hz,\n\t\t\t\t      lim->vt_bk.min_pix_clk_freq_hz));\n\tdev_dbg(dev, \"max_vt_div: min_vt_pix_clk_freq_hz: %u\\n\",\n\t\tmax_vt_div);\n\n\tccs_pll_find_vt_sys_div(dev, lim, pll, pll_fr, min_vt_div,\n\t\t\t\tmax_vt_div, &min_sys_div, &max_sys_div);\n\n\t \n\tfor (vt_div = min_vt_div; vt_div <= max_vt_div; vt_div++) {\n\t\tu16 __max_sys_div = vt_div & 1 ? 1 : max_sys_div;\n\n\t\tfor (sys_div = min_sys_div; sys_div <= __max_sys_div;\n\t\t     sys_div += 2 - (sys_div & 1)) {\n\t\t\tu16 pix_div;\n\t\t\tu16 rounded_div;\n\n\t\t\tpix_div = DIV_ROUND_UP(vt_div, sys_div);\n\n\t\t\tif (pix_div < lim->vt_bk.min_pix_clk_div\n\t\t\t    || pix_div > lim->vt_bk.max_pix_clk_div) {\n\t\t\t\tdev_dbg(dev,\n\t\t\t\t\t\"pix_div %u too small or too big (%u--%u)\\n\",\n\t\t\t\t\tpix_div,\n\t\t\t\t\tlim->vt_bk.min_pix_clk_div,\n\t\t\t\t\tlim->vt_bk.max_pix_clk_div);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trounded_div = roundup(vt_div, best_pix_div);\n\n\t\t\t \n\t\t\tif (pix_div * sys_div <= rounded_div)\n\t\t\t\tbest_pix_div = pix_div;\n\n\t\t\t \n\t\t\tif (vt_div == rounded_div)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (best_pix_div < SHRT_MAX >> 1)\n\t\t\tbreak;\n\t}\n\n\tpll->vt_bk.sys_clk_div = DIV_ROUND_UP(vt_div, best_pix_div);\n\tpll->vt_bk.pix_clk_div = best_pix_div;\n\n\tpll->vt_bk.sys_clk_freq_hz =\n\t\tpll_fr->pll_op_clk_freq_hz / pll->vt_bk.sys_clk_div;\n\tpll->vt_bk.pix_clk_freq_hz =\n\t\tpll->vt_bk.sys_clk_freq_hz / pll->vt_bk.pix_clk_div;\n\nout_calc_pixel_rate:\n\tpll->pixel_rate_pixel_array =\n\t\tpll->vt_bk.pix_clk_freq_hz * pll->vt_lanes;\n}\n\n \nstatic int\nccs_pll_calculate_op(struct device *dev, const struct ccs_pll_limits *lim,\n\t\t     const struct ccs_pll_branch_limits_fr *op_lim_fr,\n\t\t     const struct ccs_pll_branch_limits_bk *op_lim_bk,\n\t\t     struct ccs_pll *pll, struct ccs_pll_branch_fr *op_pll_fr,\n\t\t     struct ccs_pll_branch_bk *op_pll_bk, u32 mul,\n\t\t     u32 div, u32 op_sys_clk_freq_hz_sdr, u32 l,\n\t\t     bool cphy, u32 phy_const)\n{\n\t \n\tu32 more_mul_min, more_mul_max;\n\tu32 more_mul_factor;\n\tu32 i;\n\n\t \n\tdev_dbg(dev, \"op_pre_pll_clk_div %u\\n\", op_pll_fr->pre_pll_clk_div);\n\n\t \n\tmore_mul_max = op_lim_fr->max_pll_multiplier / mul;\n\tdev_dbg(dev, \"more_mul_max: max_op_pll_multiplier check: %u\\n\",\n\t\tmore_mul_max);\n\t \n\tmore_mul_max =\n\t\tmin_t(u32,\n\t\t      more_mul_max,\n\t\t      op_lim_fr->max_pll_op_clk_freq_hz\n\t\t      / (pll->ext_clk_freq_hz /\n\t\t\t op_pll_fr->pre_pll_clk_div * mul));\n\tdev_dbg(dev, \"more_mul_max: max_pll_op_clk_freq_hz check: %u\\n\",\n\t\tmore_mul_max);\n\t \n\tmore_mul_max = min(more_mul_max,\n\t\t\t   op_lim_bk->max_sys_clk_div * op_pll_fr->pre_pll_clk_div\n\t\t\t   / div);\n\tdev_dbg(dev, \"more_mul_max: max_op_sys_clk_div check: %u\\n\",\n\t\tmore_mul_max);\n\t \n\tmore_mul_max = min(more_mul_max, op_lim_fr->max_pll_multiplier / mul);\n\tdev_dbg(dev, \"more_mul_max: min_pll_multiplier check: %u\\n\",\n\t\tmore_mul_max);\n\n\t \n\tmore_mul_min = DIV_ROUND_UP(op_lim_fr->min_pll_op_clk_freq_hz,\n\t\t\t\t    pll->ext_clk_freq_hz /\n\t\t\t\t    op_pll_fr->pre_pll_clk_div * mul);\n\tdev_dbg(dev, \"more_mul_min: min_op_pll_op_clk_freq_hz check: %u\\n\",\n\t\tmore_mul_min);\n\t \n\tmore_mul_min = max(more_mul_min,\n\t\t\t   DIV_ROUND_UP(op_lim_fr->min_pll_multiplier, mul));\n\tdev_dbg(dev, \"more_mul_min: min_op_pll_multiplier check: %u\\n\",\n\t\tmore_mul_min);\n\n\tif (more_mul_min > more_mul_max) {\n\t\tdev_dbg(dev,\n\t\t\t\"unable to compute more_mul_min and more_mul_max\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmore_mul_factor = lcm(div, op_pll_fr->pre_pll_clk_div) / div;\n\tdev_dbg(dev, \"more_mul_factor: %u\\n\", more_mul_factor);\n\tmore_mul_factor = lcm(more_mul_factor, op_lim_bk->min_sys_clk_div);\n\tdev_dbg(dev, \"more_mul_factor: min_op_sys_clk_div: %d\\n\",\n\t\tmore_mul_factor);\n\ti = roundup(more_mul_min, more_mul_factor);\n\tif (!is_one_or_even(i))\n\t\ti <<= 1;\n\n\tdev_dbg(dev, \"final more_mul: %u\\n\", i);\n\tif (i > more_mul_max) {\n\t\tdev_dbg(dev, \"final more_mul is bad, max %u\\n\", more_mul_max);\n\t\treturn -EINVAL;\n\t}\n\n\top_pll_fr->pll_multiplier = mul * i;\n\top_pll_bk->sys_clk_div = div * i / op_pll_fr->pre_pll_clk_div;\n\tdev_dbg(dev, \"op_sys_clk_div: %u\\n\", op_pll_bk->sys_clk_div);\n\n\top_pll_fr->pll_ip_clk_freq_hz = pll->ext_clk_freq_hz\n\t\t/ op_pll_fr->pre_pll_clk_div;\n\n\top_pll_fr->pll_op_clk_freq_hz = op_pll_fr->pll_ip_clk_freq_hz\n\t\t* op_pll_fr->pll_multiplier;\n\n\tif (pll->flags & CCS_PLL_FLAG_LANE_SPEED_MODEL)\n\t\top_pll_bk->pix_clk_div =\n\t\t\t(pll->bits_per_pixel\n\t\t\t * pll->op_lanes * (phy_const << op_sys_ddr(pll->flags))\n\t\t\t / PHY_CONST_DIV / pll->csi2.lanes / l)\n\t\t\t>> op_pix_ddr(pll->flags);\n\telse\n\t\top_pll_bk->pix_clk_div =\n\t\t\t(pll->bits_per_pixel\n\t\t\t * (phy_const << op_sys_ddr(pll->flags))\n\t\t\t / PHY_CONST_DIV / l) >> op_pix_ddr(pll->flags);\n\n\top_pll_bk->pix_clk_freq_hz =\n\t\t(op_sys_clk_freq_hz_sdr >> op_pix_ddr(pll->flags))\n\t\t/ op_pll_bk->pix_clk_div;\n\top_pll_bk->sys_clk_freq_hz =\n\t\top_sys_clk_freq_hz_sdr >> op_sys_ddr(pll->flags);\n\n\tdev_dbg(dev, \"op_pix_clk_div: %u\\n\", op_pll_bk->pix_clk_div);\n\n\treturn 0;\n}\n\nint ccs_pll_calculate(struct device *dev, const struct ccs_pll_limits *lim,\n\t\t      struct ccs_pll *pll)\n{\n\tconst struct ccs_pll_branch_limits_fr *op_lim_fr;\n\tconst struct ccs_pll_branch_limits_bk *op_lim_bk;\n\tstruct ccs_pll_branch_fr *op_pll_fr;\n\tstruct ccs_pll_branch_bk *op_pll_bk;\n\tbool cphy = pll->bus_type == CCS_PLL_BUS_TYPE_CSI2_CPHY;\n\tu32 phy_const = cphy ? CPHY_CONST : DPHY_CONST;\n\tu32 op_sys_clk_freq_hz_sdr;\n\tu16 min_op_pre_pll_clk_div;\n\tu16 max_op_pre_pll_clk_div;\n\tu32 mul, div;\n\tu32 l = (!pll->op_bits_per_lane ||\n\t\t pll->op_bits_per_lane >= pll->bits_per_pixel) ? 1 : 2;\n\tu32 i;\n\tint rval = -EINVAL;\n\n\tif (!(pll->flags & CCS_PLL_FLAG_LANE_SPEED_MODEL)) {\n\t\tpll->op_lanes = 1;\n\t\tpll->vt_lanes = 1;\n\t}\n\n\tif (pll->flags & CCS_PLL_FLAG_DUAL_PLL) {\n\t\top_lim_fr = &lim->op_fr;\n\t\top_lim_bk = &lim->op_bk;\n\t\top_pll_fr = &pll->op_fr;\n\t\top_pll_bk = &pll->op_bk;\n\t} else if (pll->flags & CCS_PLL_FLAG_NO_OP_CLOCKS) {\n\t\t \n\t\top_lim_fr = &lim->vt_fr;\n\t\top_lim_bk = &lim->vt_bk;\n\t\top_pll_fr = &pll->vt_fr;\n\t\top_pll_bk = &pll->vt_bk;\n\t} else {\n\t\top_lim_fr = &lim->vt_fr;\n\t\top_lim_bk = &lim->op_bk;\n\t\top_pll_fr = &pll->vt_fr;\n\t\top_pll_bk = &pll->op_bk;\n\t}\n\n\tif (!pll->op_lanes || !pll->vt_lanes || !pll->bits_per_pixel ||\n\t    !pll->ext_clk_freq_hz || !pll->link_freq || !pll->scale_m ||\n\t    !op_lim_fr->min_pll_ip_clk_freq_hz ||\n\t    !op_lim_fr->max_pll_ip_clk_freq_hz ||\n\t    !op_lim_fr->min_pll_op_clk_freq_hz ||\n\t    !op_lim_fr->max_pll_op_clk_freq_hz ||\n\t    !op_lim_bk->max_sys_clk_div || !op_lim_fr->max_pll_multiplier)\n\t\treturn -EINVAL;\n\n\t \n\tif (!(pll->flags & CCS_PLL_FLAG_FLEXIBLE_OP_PIX_CLK_DIV) &&\n\t    (pll->bits_per_pixel * pll->op_lanes) %\n\t    (pll->csi2.lanes * l << op_pix_ddr(pll->flags))) {\n\t\tdev_dbg(dev, \"op_pix_clk_div not an integer (bpp %u, op lanes %u, lanes %u, l %u)\\n\",\n\t\t\tpll->bits_per_pixel, pll->op_lanes, pll->csi2.lanes, l);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"vt_lanes: %u\\n\", pll->vt_lanes);\n\tdev_dbg(dev, \"op_lanes: %u\\n\", pll->op_lanes);\n\n\tdev_dbg(dev, \"binning: %ux%u\\n\", pll->binning_horizontal,\n\t\tpll->binning_vertical);\n\n\tswitch (pll->bus_type) {\n\tcase CCS_PLL_BUS_TYPE_CSI2_DPHY:\n\tcase CCS_PLL_BUS_TYPE_CSI2_CPHY:\n\t\top_sys_clk_freq_hz_sdr = pll->link_freq * 2\n\t\t\t* (pll->flags & CCS_PLL_FLAG_LANE_SPEED_MODEL ?\n\t\t\t   1 : pll->csi2.lanes);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpll->pixel_rate_csi =\n\t\tdiv_u64((uint64_t)op_sys_clk_freq_hz_sdr\n\t\t\t* (pll->flags & CCS_PLL_FLAG_LANE_SPEED_MODEL ?\n\t\t\t   pll->csi2.lanes : 1) * PHY_CONST_DIV,\n\t\t\tphy_const * pll->bits_per_pixel * l);\n\n\t \n\tdev_dbg(dev, \"min / max op_pre_pll_clk_div: %u / %u\\n\",\n\t\top_lim_fr->min_pre_pll_clk_div, op_lim_fr->max_pre_pll_clk_div);\n\tmax_op_pre_pll_clk_div =\n\t\tmin_t(u16, op_lim_fr->max_pre_pll_clk_div,\n\t\t      clk_div_even(pll->ext_clk_freq_hz /\n\t\t\t\t   op_lim_fr->min_pll_ip_clk_freq_hz));\n\tmin_op_pre_pll_clk_div =\n\t\tmax_t(u16, op_lim_fr->min_pre_pll_clk_div,\n\t\t      clk_div_even_up(\n\t\t\t      DIV_ROUND_UP(pll->ext_clk_freq_hz,\n\t\t\t\t\t   op_lim_fr->max_pll_ip_clk_freq_hz)));\n\tdev_dbg(dev, \"pre-pll check: min / max op_pre_pll_clk_div: %u / %u\\n\",\n\t\tmin_op_pre_pll_clk_div, max_op_pre_pll_clk_div);\n\n\ti = gcd(op_sys_clk_freq_hz_sdr,\n\t\tpll->ext_clk_freq_hz << op_pix_ddr(pll->flags));\n\tmul = op_sys_clk_freq_hz_sdr / i;\n\tdiv = (pll->ext_clk_freq_hz << op_pix_ddr(pll->flags)) / i;\n\tdev_dbg(dev, \"mul %u / div %u\\n\", mul, div);\n\n\tmin_op_pre_pll_clk_div =\n\t\tmax_t(u16, min_op_pre_pll_clk_div,\n\t\t      clk_div_even_up(\n\t\t\t      mul /\n\t\t\t      one_or_more(\n\t\t\t\t      DIV_ROUND_UP(op_lim_fr->max_pll_op_clk_freq_hz,\n\t\t\t\t\t\t   pll->ext_clk_freq_hz))));\n\tdev_dbg(dev, \"pll_op check: min / max op_pre_pll_clk_div: %u / %u\\n\",\n\t\tmin_op_pre_pll_clk_div, max_op_pre_pll_clk_div);\n\n\tfor (op_pll_fr->pre_pll_clk_div = min_op_pre_pll_clk_div;\n\t     op_pll_fr->pre_pll_clk_div <= max_op_pre_pll_clk_div;\n\t     op_pll_fr->pre_pll_clk_div +=\n\t\t     (pll->flags & CCS_PLL_FLAG_EXT_IP_PLL_DIVIDER) ? 1 :\n\t\t     2 - (op_pll_fr->pre_pll_clk_div & 1)) {\n\t\trval = ccs_pll_calculate_op(dev, lim, op_lim_fr, op_lim_bk, pll,\n\t\t\t\t\t    op_pll_fr, op_pll_bk, mul, div,\n\t\t\t\t\t    op_sys_clk_freq_hz_sdr, l, cphy,\n\t\t\t\t\t    phy_const);\n\t\tif (rval)\n\t\t\tcontinue;\n\n\t\trval = check_fr_bounds(dev, lim, pll,\n\t\t\t\t       pll->flags & CCS_PLL_FLAG_DUAL_PLL ?\n\t\t\t\t       PLL_OP : PLL_VT);\n\t\tif (rval)\n\t\t\tcontinue;\n\n\t\trval = check_bk_bounds(dev, lim, pll, PLL_OP);\n\t\tif (rval)\n\t\t\tcontinue;\n\n\t\tif (pll->flags & CCS_PLL_FLAG_DUAL_PLL)\n\t\t\tbreak;\n\n\t\tccs_pll_calculate_vt(dev, lim, op_lim_bk, pll, op_pll_fr,\n\t\t\t\t     op_pll_bk, cphy, phy_const);\n\n\t\trval = check_bk_bounds(dev, lim, pll, PLL_VT);\n\t\tif (rval)\n\t\t\tcontinue;\n\t\trval = check_ext_bounds(dev, pll);\n\t\tif (rval)\n\t\t\tcontinue;\n\n\t\tbreak;\n\t}\n\n\tif (rval) {\n\t\tdev_dbg(dev, \"unable to compute pre_pll divisor\\n\");\n\n\t\treturn rval;\n\t}\n\n\tif (pll->flags & CCS_PLL_FLAG_DUAL_PLL) {\n\t\trval = ccs_pll_calculate_vt_tree(dev, lim, pll);\n\n\t\tif (rval)\n\t\t\treturn rval;\n\t}\n\n\tprint_pll(dev, pll);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ccs_pll_calculate);\n\nMODULE_AUTHOR(\"Sakari Ailus <sakari.ailus@linux.intel.com>\");\nMODULE_DESCRIPTION(\"Generic MIPI CCS/SMIA/SMIA++ PLL calculator\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}