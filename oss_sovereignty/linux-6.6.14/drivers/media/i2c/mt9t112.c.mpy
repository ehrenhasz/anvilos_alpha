{
  "module_name": "mt9t112.c",
  "hash_id": "829d0321aa8c94b41d8899011a02e09aa2984d221a302fc6ed255e4f8757ac92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/mt9t112.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/v4l2-mediabus.h>\n#include <linux/videodev2.h>\n\n#include <media/i2c/mt9t112.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-image-sizes.h>\n#include <media/v4l2-subdev.h>\n\n \n \n\n \n \n#define MAX_WIDTH   2048\n#define MAX_HEIGHT  1536\n\n \n#define ECHECKER(ret, x)\t\t\\\n\tdo {\t\t\t\t\\\n\t\t(ret) = (x);\t\t\\\n\t\tif ((ret) < 0)\t\t\\\n\t\t\treturn (ret);\t\\\n\t} while (0)\n\n#define mt9t112_reg_write(ret, client, a, b) \\\n\tECHECKER(ret, __mt9t112_reg_write(client, a, b))\n#define mt9t112_mcu_write(ret, client, a, b) \\\n\tECHECKER(ret, __mt9t112_mcu_write(client, a, b))\n\n#define mt9t112_reg_mask_set(ret, client, a, b, c) \\\n\tECHECKER(ret, __mt9t112_reg_mask_set(client, a, b, c))\n#define mt9t112_mcu_mask_set(ret, client, a, b, c) \\\n\tECHECKER(ret, __mt9t112_mcu_mask_set(client, a, b, c))\n\n#define mt9t112_reg_read(ret, client, a) \\\n\tECHECKER(ret, __mt9t112_reg_read(client, a))\n\n \n#define _VAR(id, offset, base)\t(base | (id & 0x1f) << 10 | (offset & 0x3ff))\n#define VAR(id, offset)  _VAR(id, offset, 0x0000)\n#define VAR8(id, offset) _VAR(id, offset, 0x8000)\n\n \nstruct mt9t112_format {\n\tu32 code;\n\tenum v4l2_colorspace colorspace;\n\tu16 fmt;\n\tu16 order;\n};\n\nstruct mt9t112_priv {\n\tstruct v4l2_subdev\t\t subdev;\n\tstruct mt9t112_platform_data\t*info;\n\tstruct i2c_client\t\t*client;\n\tstruct v4l2_rect\t\t frame;\n\tstruct clk\t\t\t*clk;\n\tstruct gpio_desc\t\t*standby_gpio;\n\tconst struct mt9t112_format\t*format;\n\tint\t\t\t\t num_formats;\n\tbool\t\t\t\t init_done;\n};\n\n \n\nstatic const struct mt9t112_format mt9t112_cfmts[] = {\n\t{\n\t\t.code\t\t= MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.fmt\t\t= 1,\n\t\t.order\t\t= 0,\n\t}, {\n\t\t.code\t\t= MEDIA_BUS_FMT_VYUY8_2X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.fmt\t\t= 1,\n\t\t.order\t\t= 1,\n\t}, {\n\t\t.code\t\t= MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.fmt\t\t= 1,\n\t\t.order\t\t= 2,\n\t}, {\n\t\t.code\t\t= MEDIA_BUS_FMT_YVYU8_2X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.fmt\t\t= 1,\n\t\t.order\t\t= 3,\n\t}, {\n\t\t.code\t\t= MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.fmt\t\t= 8,\n\t\t.order\t\t= 2,\n\t}, {\n\t\t.code\t\t= MEDIA_BUS_FMT_RGB565_2X8_LE,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.fmt\t\t= 4,\n\t\t.order\t\t= 2,\n\t},\n};\n\n \nstatic struct mt9t112_priv *to_mt9t112(const struct i2c_client *client)\n{\n\treturn container_of(i2c_get_clientdata(client),\n\t\t\t    struct mt9t112_priv,\n\t\t\t    subdev);\n}\n\nstatic int __mt9t112_reg_read(const struct i2c_client *client, u16 command)\n{\n\tstruct i2c_msg msg[2];\n\tu8 buf[2];\n\tint ret;\n\n\tcommand = swab16(command);\n\n\tmsg[0].addr  = client->addr;\n\tmsg[0].flags = 0;\n\tmsg[0].len   = 2;\n\tmsg[0].buf   = (u8 *)&command;\n\n\tmsg[1].addr  = client->addr;\n\tmsg[1].flags = I2C_M_RD;\n\tmsg[1].len   = 2;\n\tmsg[1].buf   = buf;\n\n\t \n\tret = i2c_transfer(client->adapter, msg, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmemcpy(&ret, buf, 2);\n\n\treturn swab16(ret);\n}\n\nstatic int __mt9t112_reg_write(const struct i2c_client *client,\n\t\t\t       u16 command, u16 data)\n{\n\tstruct i2c_msg msg;\n\tu8 buf[4];\n\tint ret;\n\n\tcommand = swab16(command);\n\tdata = swab16(data);\n\n\tmemcpy(buf + 0, &command, 2);\n\tmemcpy(buf + 2, &data,    2);\n\n\tmsg.addr  = client->addr;\n\tmsg.flags = 0;\n\tmsg.len   = 4;\n\tmsg.buf   = buf;\n\n\t \n\tret = i2c_transfer(client->adapter, &msg, 1);\n\n\treturn ret >= 0 ? 0 : ret;\n}\n\nstatic int __mt9t112_reg_mask_set(const struct i2c_client *client,\n\t\t\t\t  u16  command, u16  mask, u16  set)\n{\n\tint val = __mt9t112_reg_read(client, command);\n\n\tif (val < 0)\n\t\treturn val;\n\n\tval &= ~mask;\n\tval |= set & mask;\n\n\treturn __mt9t112_reg_write(client, command, val);\n}\n\n \nstatic int __mt9t112_mcu_read(const struct i2c_client *client, u16 command)\n{\n\tint ret;\n\n\tret = __mt9t112_reg_write(client, 0x098E, command);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn __mt9t112_reg_read(client, 0x0990);\n}\n\nstatic int __mt9t112_mcu_write(const struct i2c_client *client,\n\t\t\t       u16 command, u16 data)\n{\n\tint ret;\n\n\tret = __mt9t112_reg_write(client, 0x098E, command);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn __mt9t112_reg_write(client, 0x0990, data);\n}\n\nstatic int __mt9t112_mcu_mask_set(const struct i2c_client *client,\n\t\t\t\t  u16  command, u16  mask, u16  set)\n{\n\tint val = __mt9t112_mcu_read(client, command);\n\n\tif (val < 0)\n\t\treturn val;\n\n\tval &= ~mask;\n\tval |= set & mask;\n\n\treturn __mt9t112_mcu_write(client, command, val);\n}\n\nstatic int mt9t112_reset(const struct i2c_client *client)\n{\n\tint ret;\n\n\tmt9t112_reg_mask_set(ret, client, 0x001a, 0x0001, 0x0001);\n\tusleep_range(1000, 5000);\n\tmt9t112_reg_mask_set(ret, client, 0x001a, 0x0001, 0x0000);\n\n\treturn ret;\n}\n\n#ifndef EXT_CLOCK\n#define CLOCK_INFO(a, b)\n#else\n#define CLOCK_INFO(a, b) mt9t112_clock_info(a, b)\nstatic int mt9t112_clock_info(const struct i2c_client *client, u32 ext)\n{\n\tint m, n, p1, p2, p3, p4, p5, p6, p7;\n\tu32 vco, clk;\n\tchar *enable;\n\n\text /= 1000;  \n\n\tmt9t112_reg_read(n, client, 0x0012);\n\tp1 = n & 0x000f;\n\tn = n >> 4;\n\tp2 = n & 0x000f;\n\tn = n >> 4;\n\tp3 = n & 0x000f;\n\n\tmt9t112_reg_read(n, client, 0x002a);\n\tp4 = n & 0x000f;\n\tn = n >> 4;\n\tp5 = n & 0x000f;\n\tn = n >> 4;\n\tp6 = n & 0x000f;\n\n\tmt9t112_reg_read(n, client, 0x002c);\n\tp7 = n & 0x000f;\n\n\tmt9t112_reg_read(n, client, 0x0010);\n\tm = n & 0x00ff;\n\tn = (n >> 8) & 0x003f;\n\n\tenable = ((ext < 6000) || (ext > 54000)) ? \"X\" : \"\";\n\tdev_dbg(&client->dev, \"EXTCLK          : %10u K %s\\n\", ext, enable);\n\n\tvco = 2 * m * ext / (n + 1);\n\tenable = ((vco < 384000) || (vco > 768000)) ? \"X\" : \"\";\n\tdev_dbg(&client->dev, \"VCO             : %10u K %s\\n\", vco, enable);\n\n\tclk = vco / (p1 + 1) / (p2 + 1);\n\tenable = (clk > 96000) ? \"X\" : \"\";\n\tdev_dbg(&client->dev, \"PIXCLK          : %10u K %s\\n\", clk, enable);\n\n\tclk = vco / (p3 + 1);\n\tenable = (clk > 768000) ? \"X\" : \"\";\n\tdev_dbg(&client->dev, \"MIPICLK         : %10u K %s\\n\", clk, enable);\n\n\tclk = vco / (p6 + 1);\n\tenable = (clk > 96000) ? \"X\" : \"\";\n\tdev_dbg(&client->dev, \"MCU CLK         : %10u K %s\\n\", clk, enable);\n\n\tclk = vco / (p5 + 1);\n\tenable = (clk > 54000) ? \"X\" : \"\";\n\tdev_dbg(&client->dev, \"SOC CLK         : %10u K %s\\n\", clk, enable);\n\n\tclk = vco / (p4 + 1);\n\tenable = (clk > 70000) ? \"X\" : \"\";\n\tdev_dbg(&client->dev, \"Sensor CLK      : %10u K %s\\n\", clk, enable);\n\n\tclk = vco / (p7 + 1);\n\tdev_dbg(&client->dev, \"External sensor : %10u K\\n\", clk);\n\n\tclk = ext / (n + 1);\n\tenable = ((clk < 2000) || (clk > 24000)) ? \"X\" : \"\";\n\tdev_dbg(&client->dev, \"PFD             : %10u K %s\\n\", clk, enable);\n\n\treturn 0;\n}\n#endif\n\nstatic int mt9t112_set_a_frame_size(const struct i2c_client *client,\n\t\t\t\t    u16 width, u16 height)\n{\n\tint ret;\n\tu16 wstart = (MAX_WIDTH - width) / 2;\n\tu16 hstart = (MAX_HEIGHT - height) / 2;\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(26, 0), width);\n\tmt9t112_mcu_write(ret, client, VAR(26, 2), height);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 43), 8 + width);\n\tmt9t112_mcu_write(ret, client, VAR(18, 45), 8 + height);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 2), 4 + hstart);\n\tmt9t112_mcu_write(ret, client, VAR(18, 4), 4 + wstart);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 6), 11 + height + hstart);\n\tmt9t112_mcu_write(ret, client, VAR(18, 8), 11 + width  + wstart);\n\n\tmt9t112_mcu_write(ret, client, VAR8(1, 0), 0x06);\n\n\treturn ret;\n}\n\nstatic int mt9t112_set_pll_dividers(const struct i2c_client *client,\n\t\t\t\t    u8 m, u8 n, u8 p1, u8 p2, u8 p3, u8 p4,\n\t\t\t\t    u8 p5, u8 p6, u8 p7)\n{\n\tint ret;\n\tu16 val;\n\n\t \n\tval = (n << 8) | (m << 0);\n\tmt9t112_reg_mask_set(ret, client, 0x0010, 0x3fff, val);\n\n\t \n\tval = ((p3 & 0x0F) << 8) | ((p2 & 0x0F) << 4) | ((p1 & 0x0F) << 0);\n\tmt9t112_reg_mask_set(ret, client, 0x0012, 0x0fff, val);\n\n\t \n\tval = (0x7 << 12) | ((p6 & 0x0F) <<  8) | ((p5 & 0x0F) <<  4) |\n\t      ((p4 & 0x0F) <<  0);\n\tmt9t112_reg_mask_set(ret, client, 0x002A, 0x7fff, val);\n\n\t \n\tval = (0x1 << 12) | ((p7 & 0x0F) <<  0);\n\tmt9t112_reg_mask_set(ret, client, 0x002C, 0x100f, val);\n\n\treturn ret;\n}\n\nstatic int mt9t112_init_pll(const struct i2c_client *client)\n{\n\tstruct mt9t112_priv *priv = to_mt9t112(client);\n\tint data, i, ret;\n\n\tmt9t112_reg_mask_set(ret, client, 0x0014, 0x003, 0x0001);\n\n\t \n\tmt9t112_reg_write(ret, client, 0x0014, 0x2145);\n\n\t \n\tmt9t112_set_pll_dividers(client,\n\t\t\t\t priv->info->divider.m, priv->info->divider.n,\n\t\t\t\t priv->info->divider.p1, priv->info->divider.p2,\n\t\t\t\t priv->info->divider.p3, priv->info->divider.p4,\n\t\t\t\t priv->info->divider.p5, priv->info->divider.p6,\n\t\t\t\t priv->info->divider.p7);\n\n\t \n\tmt9t112_reg_write(ret, client, 0x0014, 0x2525);\n\tmt9t112_reg_write(ret, client, 0x0014, 0x2527);\n\tmt9t112_reg_write(ret, client, 0x0014, 0x3427);\n\tmt9t112_reg_write(ret, client, 0x0014, 0x3027);\n\n\tmdelay(10);\n\n\t \n\tmt9t112_reg_write(ret, client, 0x0014, 0x3046);\n\t \n\tmt9t112_reg_write(ret, client, 0x0016, 0x0400);\n\tmt9t112_reg_write(ret, client, 0x0022, 0x0190);\n\tmt9t112_reg_write(ret, client, 0x3B84, 0x0212);\n\n\t \n\tmt9t112_reg_write(ret, client, 0x002E, 0x0500);\n\n\tmt9t112_reg_mask_set(ret, client, 0x0018, 0x0002, 0x0002);\n\tmt9t112_reg_mask_set(ret, client, 0x3B82, 0x0004, 0x0004);\n\n\t \n\tmt9t112_reg_mask_set(ret, client, 0x0018, 0x0004, 0x0004);\n\n\t \n\tmt9t112_reg_mask_set(ret, client, 0x0018, 0x0001, 0);\n\n\tmdelay(50);\n\n\t \n\tmt9t112_reg_write(ret, client, 0x0614, 0x0001);\n\tmdelay(1);\n\tmt9t112_reg_write(ret, client, 0x0614, 0x0001);\n\tmdelay(1);\n\tmt9t112_reg_write(ret, client, 0x0614, 0x0001);\n\tmdelay(1);\n\tmt9t112_reg_write(ret, client, 0x0614, 0x0001);\n\tmdelay(1);\n\tmt9t112_reg_write(ret, client, 0x0614, 0x0001);\n\tmdelay(1);\n\tmt9t112_reg_write(ret, client, 0x0614, 0x0001);\n\tmdelay(1);\n\n\t \n\tfor (i = 0; i < 100; i++) {\n\t\tmt9t112_reg_read(data, client, 0x0018);\n\t\tif (!(data & 0x4000))\n\t\t\tbreak;\n\n\t\tmdelay(10);\n\t}\n\n\treturn ret;\n}\n\nstatic int mt9t112_init_setting(const struct i2c_client *client)\n{\n\tint ret;\n\n\t \n\tmt9t112_mcu_mask_set(ret, client, VAR(26, 160), 0x0040, 0x0000);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 12), 0x0024);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 15), 0x00CC);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 17), 0x01f1);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 19), 0x00fF);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 29), 0x032D);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 31), 0x073a);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 37), 0x07d0);\n\n\t \n\tmt9t112_mcu_mask_set(ret, client, VAR(27, 160), 0x0040, 0x0000);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 74), 0x004);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 76), 0x004);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 78), 0x60B);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 80), 0x80B);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 87), 0x008C);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 89), 0x01F1);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 91), 0x00FF);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 101), 0x0668);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 103), 0x0AF0);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 109), 0x0AF0);\n\n\t \n\n\t \n\tmt9t112_mcu_write(ret, client, VAR8(8, 5), 0x01);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(27, 17), 0x0003);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(26, 17), 0x0003);\n\n\t \n\n\t \n\tmt9t112_mcu_write(ret, client, VAR8(18, 165), 0x25);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR8(18, 166), 0x28);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR8(18, 167), 0x2C);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR8(18, 168), 0x2F);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR8(18, 68), 0xBA);\n\n\t \n\t \n\tmt9t112_mcu_write(ret, client, VAR8(18, 303), 0x00);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR8(18, 69), 0x9B);\n\n\t \n\t \n\tmt9t112_mcu_write(ret, client, VAR8(18, 301), 0x00);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR8(18, 140), 0x82);\n\n\t \n\t \n\tmt9t112_mcu_write(ret, client, VAR8(18, 304), 0x00);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR8(18, 141), 0x6D);\n\n\t \n\t \n\tmt9t112_mcu_write(ret, client, VAR8(18, 302), 0x00);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR8(8, 2), 0x10);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR8(8, 9), 0x02);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR8(8, 10), 0x03);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR8(8, 12), 0x0A);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 70), 0x0014);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(18, 142), 0x0014);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR8(18, 0x0044), 133);\n\tmt9t112_mcu_write(ret, client, VAR8(18, 0x0045), 110);\n\tmt9t112_mcu_write(ret, client, VAR8(18, 0x008c), 130);\n\tmt9t112_mcu_write(ret, client, VAR8(18, 0x008d), 108);\n\n\tmt9t112_mcu_write(ret, client, VAR8(18, 0x00A5), 27);\n\tmt9t112_mcu_write(ret, client, VAR8(18, 0x00a6), 30);\n\tmt9t112_mcu_write(ret, client, VAR8(18, 0x00a7), 32);\n\tmt9t112_mcu_write(ret, client, VAR8(18, 0x00a8), 35);\n\n\treturn ret;\n}\n\nstatic int mt9t112_auto_focus_setting(const struct i2c_client *client)\n{\n\tint ret;\n\n\tmt9t112_mcu_write(ret, client, VAR(12, 13),\t0x000F);\n\tmt9t112_mcu_write(ret, client, VAR(12, 23),\t0x0F0F);\n\tmt9t112_mcu_write(ret, client, VAR8(1, 0),\t0x06);\n\n\tmt9t112_reg_write(ret, client, 0x0614, 0x0000);\n\n\tmt9t112_mcu_write(ret, client, VAR8(1, 0),\t0x05);\n\tmt9t112_mcu_write(ret, client, VAR8(12, 2),\t0x02);\n\tmt9t112_mcu_write(ret, client, VAR(12, 3),\t0x0002);\n\tmt9t112_mcu_write(ret, client, VAR(17, 3),\t0x8001);\n\tmt9t112_mcu_write(ret, client, VAR(17, 11),\t0x0025);\n\tmt9t112_mcu_write(ret, client, VAR(17, 13),\t0x0193);\n\tmt9t112_mcu_write(ret, client, VAR8(17, 33),\t0x18);\n\tmt9t112_mcu_write(ret, client, VAR8(1, 0),\t0x05);\n\n\treturn ret;\n}\n\nstatic int mt9t112_auto_focus_trigger(const struct i2c_client *client)\n{\n\tint ret;\n\n\tmt9t112_mcu_write(ret, client, VAR8(12, 25), 0x01);\n\n\treturn ret;\n}\n\nstatic int mt9t112_init_camera(const struct i2c_client *client)\n{\n\tint ret;\n\n\tECHECKER(ret, mt9t112_reset(client));\n\tECHECKER(ret, mt9t112_init_pll(client));\n\tECHECKER(ret, mt9t112_init_setting(client));\n\tECHECKER(ret, mt9t112_auto_focus_setting(client));\n\n\tmt9t112_reg_mask_set(ret, client, 0x0018, 0x0004, 0);\n\n\t \n\tmt9t112_reg_write(ret, client, 0x3084, 0x2409);\n\tmt9t112_reg_write(ret, client, 0x3092, 0x0A49);\n\tmt9t112_reg_write(ret, client, 0x3094, 0x4949);\n\tmt9t112_reg_write(ret, client, 0x3096, 0x4950);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(26, 160), 0x0A2E);\n\tmt9t112_mcu_write(ret, client, VAR(27, 160), 0x0A2E);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR(27, 144), 0x0CB4);\n\n\t \n\tmt9t112_mcu_write(ret, client, VAR8(27, 142), 0x01);\n\n\t \n\tmt9t112_reg_write(ret, client, 0x316C, 0x350F);\n\n\t \n\tmt9t112_reg_write(ret, client, 0x1E, 0x777);\n\n\treturn ret;\n}\n\n \n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int mt9t112_g_register(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_dbg_register *reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint                ret;\n\n\treg->size = 2;\n\tmt9t112_reg_read(ret, client, reg->reg);\n\n\treg->val = (__u64)ret;\n\n\treturn 0;\n}\n\nstatic int mt9t112_s_register(struct v4l2_subdev *sd,\n\t\t\t      const struct v4l2_dbg_register *reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tmt9t112_reg_write(ret, client, reg->reg, reg->val);\n\n\treturn ret;\n}\n#endif\n\nstatic int mt9t112_power_on(struct mt9t112_priv *priv)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->standby_gpio) {\n\t\tgpiod_set_value(priv->standby_gpio, 0);\n\t\tmsleep(100);\n\t}\n\n\treturn 0;\n}\n\nstatic int mt9t112_power_off(struct mt9t112_priv *priv)\n{\n\tclk_disable_unprepare(priv->clk);\n\tif (priv->standby_gpio) {\n\t\tgpiod_set_value(priv->standby_gpio, 1);\n\t\tmsleep(100);\n\t}\n\n\treturn 0;\n}\n\nstatic int mt9t112_s_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9t112_priv *priv = to_mt9t112(client);\n\n\treturn on ? mt9t112_power_on(priv) :\n\t\t    mt9t112_power_off(priv);\n}\n\nstatic const struct v4l2_subdev_core_ops mt9t112_subdev_core_ops = {\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register\t= mt9t112_g_register,\n\t.s_register\t= mt9t112_s_register,\n#endif\n\t.s_power\t= mt9t112_s_power,\n};\n\n \nstatic int mt9t112_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9t112_priv *priv = to_mt9t112(client);\n\tint ret = 0;\n\n\tif (!enable) {\n\t\t \n\t\tmt9t112_set_a_frame_size(client, VGA_WIDTH, VGA_HEIGHT);\n\t\treturn ret;\n\t}\n\n\tif (!priv->init_done) {\n\t\tu16 param = MT9T112_FLAG_PCLK_RISING_EDGE & priv->info->flags ?\n\t\t\t    0x0001 : 0x0000;\n\n\t\tECHECKER(ret, mt9t112_init_camera(client));\n\n\t\t \n\t\tmt9t112_reg_write(ret, client, 0x3C20, param);\n\n\t\tmdelay(5);\n\n\t\tpriv->init_done = true;\n\t}\n\n\tmt9t112_mcu_write(ret, client, VAR(26, 7), priv->format->fmt);\n\tmt9t112_mcu_write(ret, client, VAR(26, 9), priv->format->order);\n\tmt9t112_mcu_write(ret, client, VAR8(1, 0), 0x06);\n\n\tmt9t112_set_a_frame_size(client, priv->frame.width, priv->frame.height);\n\n\tECHECKER(ret, mt9t112_auto_focus_trigger(client));\n\n\tdev_dbg(&client->dev, \"format : %d\\n\", priv->format->code);\n\tdev_dbg(&client->dev, \"size   : %d x %d\\n\",\n\t\tpriv->frame.width,\n\t\tpriv->frame.height);\n\n\tCLOCK_INFO(client, EXT_CLOCK);\n\n\treturn ret;\n}\n\nstatic int mt9t112_set_params(struct mt9t112_priv *priv,\n\t\t\t      const struct v4l2_rect *rect,\n\t\t\t      u32 code)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < priv->num_formats; i++)\n\t\tif (mt9t112_cfmts[i].code == code)\n\t\t\tbreak;\n\n\tif (i == priv->num_formats)\n\t\treturn -EINVAL;\n\n\tpriv->frame = *rect;\n\n\t \n\tv4l_bound_align_image(&priv->frame.width, 0, MAX_WIDTH, 0,\n\t\t\t      &priv->frame.height, 0, MAX_HEIGHT, 0, 0);\n\n\tpriv->format = mt9t112_cfmts + i;\n\n\treturn 0;\n}\n\nstatic int mt9t112_get_selection(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_selection *sel)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9t112_priv *priv = to_mt9t112(client);\n\n\tif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = MAX_WIDTH;\n\t\tsel->r.height = MAX_HEIGHT;\n\t\treturn 0;\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = priv->frame;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mt9t112_set_selection(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_selection *sel)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9t112_priv *priv = to_mt9t112(client);\n\tconst struct v4l2_rect *rect = &sel->r;\n\n\tif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||\n\t    sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\treturn mt9t112_set_params(priv, rect, priv->format->code);\n}\n\nstatic int mt9t112_get_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9t112_priv *priv = to_mt9t112(client);\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tmf->width\t= priv->frame.width;\n\tmf->height\t= priv->frame.height;\n\tmf->colorspace\t= priv->format->colorspace;\n\tmf->code\t= priv->format->code;\n\tmf->field\t= V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\nstatic int mt9t112_s_fmt(struct v4l2_subdev *sd,\n\t\t\t struct v4l2_mbus_framefmt *mf)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9t112_priv *priv = to_mt9t112(client);\n\tstruct v4l2_rect rect = {\n\t\t.width = mf->width,\n\t\t.height = mf->height,\n\t\t.left = priv->frame.left,\n\t\t.top = priv->frame.top,\n\t};\n\tint ret;\n\n\tret = mt9t112_set_params(priv, &rect, mf->code);\n\n\tif (!ret)\n\t\tmf->colorspace = priv->format->colorspace;\n\n\treturn ret;\n}\n\nstatic int mt9t112_set_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *format)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tstruct mt9t112_priv *priv = to_mt9t112(client);\n\tint i;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < priv->num_formats; i++)\n\t\tif (mt9t112_cfmts[i].code == mf->code)\n\t\t\tbreak;\n\n\tif (i == priv->num_formats) {\n\t\tmf->code = MEDIA_BUS_FMT_UYVY8_2X8;\n\t\tmf->colorspace = V4L2_COLORSPACE_JPEG;\n\t} else {\n\t\tmf->colorspace = mt9t112_cfmts[i].colorspace;\n\t}\n\n\tv4l_bound_align_image(&mf->width, 0, MAX_WIDTH, 0,\n\t\t\t      &mf->height, 0, MAX_HEIGHT, 0, 0);\n\n\tmf->field = V4L2_FIELD_NONE;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn mt9t112_s_fmt(sd, mf);\n\tsd_state->pads->try_fmt = *mf;\n\n\treturn 0;\n}\n\nstatic int mt9t112_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9t112_priv *priv = to_mt9t112(client);\n\n\tif (code->pad || code->index >= priv->num_formats)\n\t\treturn -EINVAL;\n\n\tcode->code = mt9t112_cfmts[code->index].code;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops mt9t112_subdev_video_ops = {\n\t.s_stream\t= mt9t112_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops mt9t112_subdev_pad_ops = {\n\t.enum_mbus_code\t= mt9t112_enum_mbus_code,\n\t.get_selection\t= mt9t112_get_selection,\n\t.set_selection\t= mt9t112_set_selection,\n\t.get_fmt\t= mt9t112_get_fmt,\n\t.set_fmt\t= mt9t112_set_fmt,\n};\n\n \nstatic const struct v4l2_subdev_ops mt9t112_subdev_ops = {\n\t.core\t= &mt9t112_subdev_core_ops,\n\t.video\t= &mt9t112_subdev_video_ops,\n\t.pad\t= &mt9t112_subdev_pad_ops,\n};\n\nstatic int mt9t112_camera_probe(struct i2c_client *client)\n{\n\tstruct mt9t112_priv *priv = to_mt9t112(client);\n\tconst char          *devname;\n\tint                  chipid;\n\tint\t\t     ret;\n\n\tret = mt9t112_s_power(&priv->subdev, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmt9t112_reg_read(chipid, client, 0x0000);\n\n\tswitch (chipid) {\n\tcase 0x2680:\n\t\tdevname = \"mt9t111\";\n\t\tpriv->num_formats = 1;\n\t\tbreak;\n\tcase 0x2682:\n\t\tdevname = \"mt9t112\";\n\t\tpriv->num_formats = ARRAY_SIZE(mt9t112_cfmts);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev, \"Product ID error %04x\\n\", chipid);\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tdev_info(&client->dev, \"%s chip ID %04x\\n\", devname, chipid);\n\ndone:\n\tmt9t112_s_power(&priv->subdev, 0);\n\n\treturn ret;\n}\n\nstatic int mt9t112_probe(struct i2c_client *client)\n{\n\tstruct mt9t112_priv *priv;\n\tint ret;\n\n\tif (!client->dev.platform_data) {\n\t\tdev_err(&client->dev, \"mt9t112: missing platform data!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->info = client->dev.platform_data;\n\tpriv->init_done = false;\n\n\tv4l2_i2c_subdev_init(&priv->subdev, client, &mt9t112_subdev_ops);\n\n\tpriv->clk = devm_clk_get(&client->dev, \"extclk\");\n\tif (PTR_ERR(priv->clk) == -ENOENT) {\n\t\tpriv->clk = NULL;\n\t} else if (IS_ERR(priv->clk)) {\n\t\tdev_err(&client->dev, \"Unable to get clock \\\"extclk\\\"\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\tpriv->standby_gpio = devm_gpiod_get_optional(&client->dev, \"standby\",\n\t\t\t\t\t\t     GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->standby_gpio)) {\n\t\tdev_err(&client->dev, \"Unable to get gpio \\\"standby\\\"\\n\");\n\t\treturn PTR_ERR(priv->standby_gpio);\n\t}\n\n\tret = mt9t112_camera_probe(client);\n\tif (ret)\n\t\treturn ret;\n\n\treturn v4l2_async_register_subdev(&priv->subdev);\n}\n\nstatic void mt9t112_remove(struct i2c_client *client)\n{\n\tstruct mt9t112_priv *priv = to_mt9t112(client);\n\n\tclk_disable_unprepare(priv->clk);\n\tv4l2_async_unregister_subdev(&priv->subdev);\n}\n\nstatic const struct i2c_device_id mt9t112_id[] = {\n\t{ \"mt9t112\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, mt9t112_id);\n\nstatic struct i2c_driver mt9t112_i2c_driver = {\n\t.driver = {\n\t\t.name = \"mt9t112\",\n\t},\n\t.probe    = mt9t112_probe,\n\t.remove   = mt9t112_remove,\n\t.id_table = mt9t112_id,\n};\n\nmodule_i2c_driver(mt9t112_i2c_driver);\n\nMODULE_DESCRIPTION(\"V4L2 driver for MT9T111/MT9T112 camera sensor\");\nMODULE_AUTHOR(\"Kuninori Morimoto\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}