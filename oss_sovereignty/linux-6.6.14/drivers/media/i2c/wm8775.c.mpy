{
  "module_name": "wm8775.c",
  "hash_id": "88c17876fe908e66726fe21712d8320a6d46ab1bb2cc6e3fbf0c52238ddb1df9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/wm8775.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/ioctl.h>\n#include <linux/uaccess.h>\n#include <linux/i2c.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n#include <media/i2c/wm8775.h>\n\nMODULE_DESCRIPTION(\"wm8775 driver\");\nMODULE_AUTHOR(\"Ulf Eklund, Hans Verkuil\");\nMODULE_LICENSE(\"GPL\");\n\n\n\n \n\nenum {\n\tR7 = 7, R11 = 11,\n\tR12, R13, R14, R15, R16, R17, R18, R19, R20, R21, R23 = 23,\n\tTOT_REGS\n};\n\n#define ALC_HOLD 0x85  \n#define ALC_EN 0x100   \n\nstruct wm8775_state {\n\tstruct v4l2_subdev sd;\n\tstruct v4l2_ctrl_handler hdl;\n\tstruct v4l2_ctrl *mute;\n\tstruct v4l2_ctrl *vol;\n\tstruct v4l2_ctrl *bal;\n\tstruct v4l2_ctrl *loud;\n\tu8 input;\t\t \n};\n\nstatic inline struct wm8775_state *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct wm8775_state, sd);\n}\n\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct wm8775_state, hdl)->sd;\n}\n\nstatic int wm8775_write(struct v4l2_subdev *sd, int reg, u16 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint i;\n\n\tif (reg < 0 || reg >= TOT_REGS) {\n\t\tv4l2_err(sd, \"Invalid register R%d\\n\", reg);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t\tif (i2c_smbus_write_byte_data(client,\n\t\t\t\t(reg << 1) | (val >> 8), val & 0xff) == 0)\n\t\t\treturn 0;\n\tv4l2_err(sd, \"I2C: cannot write %03x to register R%d\\n\", val, reg);\n\treturn -1;\n}\n\nstatic void wm8775_set_audio(struct v4l2_subdev *sd, int quietly)\n{\n\tstruct wm8775_state *state = to_state(sd);\n\tu8 vol_l, vol_r;\n\tint muted = 0 != state->mute->val;\n\tu16 volume = (u16)state->vol->val;\n\tu16 balance = (u16)state->bal->val;\n\n\t \n\tvol_l = (min(65536 - balance, 32768) * volume) >> 23;\n\tvol_r = (min(balance, (u16)32768) * volume) >> 23;\n\n\t \n\tif (muted || quietly)\n\t\twm8775_write(sd, R21, 0x0c0 | state->input);\n\n\twm8775_write(sd, R14, vol_l | 0x100);  \n\twm8775_write(sd, R15, vol_r | 0x100);  \n\n\t \n\tif (!muted)\n\t\twm8775_write(sd, R21, state->input);\n}\n\nstatic int wm8775_s_routing(struct v4l2_subdev *sd,\n\t\t\t    u32 input, u32 output, u32 config)\n{\n\tstruct wm8775_state *state = to_state(sd);\n\n\t \n\tif (input > 15) {\n\t\tv4l2_err(sd, \"Invalid input %d.\\n\", input);\n\t\treturn -EINVAL;\n\t}\n\tstate->input = input;\n\tif (v4l2_ctrl_g_ctrl(state->mute))\n\t\treturn 0;\n\tif (!v4l2_ctrl_g_ctrl(state->vol))\n\t\treturn 0;\n\twm8775_set_audio(sd, 1);\n\treturn 0;\n}\n\nstatic int wm8775_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\tcase V4L2_CID_AUDIO_VOLUME:\n\tcase V4L2_CID_AUDIO_BALANCE:\n\t\twm8775_set_audio(sd, 0);\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_LOUDNESS:\n\t\twm8775_write(sd, R17, (ctrl->val ? ALC_EN : 0) | ALC_HOLD);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int wm8775_log_status(struct v4l2_subdev *sd)\n{\n\tstruct wm8775_state *state = to_state(sd);\n\n\tv4l2_info(sd, \"Input: %d\\n\", state->input);\n\tv4l2_ctrl_handler_log_status(&state->hdl, sd->name);\n\treturn 0;\n}\n\nstatic int wm8775_s_frequency(struct v4l2_subdev *sd, const struct v4l2_frequency *freq)\n{\n\twm8775_set_audio(sd, 0);\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_ctrl_ops wm8775_ctrl_ops = {\n\t.s_ctrl = wm8775_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops wm8775_core_ops = {\n\t.log_status = wm8775_log_status,\n};\n\nstatic const struct v4l2_subdev_tuner_ops wm8775_tuner_ops = {\n\t.s_frequency = wm8775_s_frequency,\n};\n\nstatic const struct v4l2_subdev_audio_ops wm8775_audio_ops = {\n\t.s_routing = wm8775_s_routing,\n};\n\nstatic const struct v4l2_subdev_ops wm8775_ops = {\n\t.core = &wm8775_core_ops,\n\t.tuner = &wm8775_tuner_ops,\n\t.audio = &wm8775_audio_ops,\n};\n\n \n\n \n\n \n\nstatic int wm8775_probe(struct i2c_client *client)\n{\n\tstruct wm8775_state *state;\n\tstruct v4l2_subdev *sd;\n\tint err;\n\tbool is_nova_s = false;\n\n\tif (client->dev.platform_data) {\n\t\tstruct wm8775_platform_data *data = client->dev.platform_data;\n\t\tis_nova_s = data->is_nova_s;\n\t}\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tv4l_info(client, \"chip found @ 0x%02x (%s)\\n\",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tstate = devm_kzalloc(&client->dev, sizeof(*state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\tsd = &state->sd;\n\tv4l2_i2c_subdev_init(sd, client, &wm8775_ops);\n\tstate->input = 2;\n\n\tv4l2_ctrl_handler_init(&state->hdl, 4);\n\tstate->mute = v4l2_ctrl_new_std(&state->hdl, &wm8775_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_MUTE, 0, 1, 1, 0);\n\tstate->vol = v4l2_ctrl_new_std(&state->hdl, &wm8775_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_VOLUME, 0, 65535, (65535+99)/100, 0xCF00);  \n\tstate->bal = v4l2_ctrl_new_std(&state->hdl, &wm8775_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_BALANCE, 0, 65535, (65535+99)/100, 32768);\n\tstate->loud = v4l2_ctrl_new_std(&state->hdl, &wm8775_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_LOUDNESS, 0, 1, 1, 1);\n\tsd->ctrl_handler = &state->hdl;\n\terr = state->hdl.error;\n\tif (err) {\n\t\tv4l2_ctrl_handler_free(&state->hdl);\n\t\treturn err;\n\t}\n\n\t \n\n\t \n\twm8775_write(sd, R23, 0x000);\n\t \n\twm8775_write(sd, R7, 0x000);\n\t \n\twm8775_write(sd, R11, 0x021);\n\t \n\twm8775_write(sd, R12, 0x102);\n\t \n\twm8775_write(sd, R13, 0x000);\n\n\tif (!is_nova_s) {\n\t\t \n\t\twm8775_write(sd, R14, 0x1d4);\n\t\t \n\t\twm8775_write(sd, R15, 0x1d4);\n\t\t \n\t\twm8775_write(sd, R16, 0x1bf);\n\t\t \n\t\twm8775_write(sd, R17, 0x185);\n\t} else {\n\t\t \n\t\twm8775_write(sd, R16, 0x1bb);\n\t\t \n\t\twm8775_write(sd, R17, (state->loud->val ? ALC_EN : 0) | ALC_HOLD);\n\t}\n\t \n\twm8775_write(sd, R18, 0x0a2);\n\t \n\twm8775_write(sd, R19, 0x005);\n\tif (!is_nova_s) {\n\t\t \n\t\twm8775_write(sd, R20, 0x07a);\n\t\t \n\t\twm8775_write(sd, R21, 0x102);\n\t} else {\n\t\t \n\t\twm8775_write(sd, R20, 0x0fb);\n\n\t\twm8775_set_audio(sd, 1);       \n\t}\n\treturn 0;\n}\n\nstatic void wm8775_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct wm8775_state *state = to_state(sd);\n\n\tv4l2_device_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(&state->hdl);\n}\n\nstatic const struct i2c_device_id wm8775_id[] = {\n\t{ \"wm8775\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8775_id);\n\nstatic struct i2c_driver wm8775_driver = {\n\t.driver = {\n\t\t.name\t= \"wm8775\",\n\t},\n\t.probe\t\t= wm8775_probe,\n\t.remove\t\t= wm8775_remove,\n\t.id_table\t= wm8775_id,\n};\n\nmodule_i2c_driver(wm8775_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}