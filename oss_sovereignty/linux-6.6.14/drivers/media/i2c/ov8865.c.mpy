{
  "module_name": "ov8865.c",
  "hash_id": "52694b2240edafe0d04ebb3601d476bd2448f3e5653c0c7688c6c27a602ac309",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ov8865.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-image-sizes.h>\n#include <media/v4l2-mediabus.h>\n\n \n\n \n\n#define OV8865_SW_STANDBY_REG\t\t\t0x100\n#define OV8865_SW_STANDBY_STREAM_ON\t\tBIT(0)\n\n#define OV8865_SW_RESET_REG\t\t\t0x103\n#define OV8865_SW_RESET_RESET\t\t\tBIT(0)\n\n#define OV8865_PLL_CTRL0_REG\t\t\t0x300\n#define OV8865_PLL_CTRL0_PRE_DIV(v)\t\t((v) & GENMASK(2, 0))\n#define OV8865_PLL_CTRL1_REG\t\t\t0x301\n#define OV8865_PLL_CTRL1_MUL_H(v)\t\t(((v) & GENMASK(9, 8)) >> 8)\n#define OV8865_PLL_CTRL2_REG\t\t\t0x302\n#define OV8865_PLL_CTRL2_MUL_L(v)\t\t((v) & GENMASK(7, 0))\n#define OV8865_PLL_CTRL3_REG\t\t\t0x303\n#define OV8865_PLL_CTRL3_M_DIV(v)\t\t(((v) - 1) & GENMASK(3, 0))\n#define OV8865_PLL_CTRL4_REG\t\t\t0x304\n#define OV8865_PLL_CTRL4_MIPI_DIV(v)\t\t((v) & GENMASK(1, 0))\n#define OV8865_PLL_CTRL5_REG\t\t\t0x305\n#define OV8865_PLL_CTRL5_SYS_PRE_DIV(v)\t\t((v) & GENMASK(1, 0))\n#define OV8865_PLL_CTRL6_REG\t\t\t0x306\n#define OV8865_PLL_CTRL6_SYS_DIV(v)\t\t(((v) - 1) & BIT(0))\n\n#define OV8865_PLL_CTRL8_REG\t\t\t0x308\n#define OV8865_PLL_CTRL9_REG\t\t\t0x309\n#define OV8865_PLL_CTRLA_REG\t\t\t0x30a\n#define OV8865_PLL_CTRLA_PRE_DIV_HALF(v)\t(((v) - 1) & BIT(0))\n#define OV8865_PLL_CTRLB_REG\t\t\t0x30b\n#define OV8865_PLL_CTRLB_PRE_DIV(v)\t\t((v) & GENMASK(2, 0))\n#define OV8865_PLL_CTRLC_REG\t\t\t0x30c\n#define OV8865_PLL_CTRLC_MUL_H(v)\t\t(((v) & GENMASK(9, 8)) >> 8)\n#define OV8865_PLL_CTRLD_REG\t\t\t0x30d\n#define OV8865_PLL_CTRLD_MUL_L(v)\t\t((v) & GENMASK(7, 0))\n#define OV8865_PLL_CTRLE_REG\t\t\t0x30e\n#define OV8865_PLL_CTRLE_SYS_DIV(v)\t\t((v) & GENMASK(2, 0))\n#define OV8865_PLL_CTRLF_REG\t\t\t0x30f\n#define OV8865_PLL_CTRLF_SYS_PRE_DIV(v)\t\t(((v) - 1) & GENMASK(3, 0))\n#define OV8865_PLL_CTRL10_REG\t\t\t0x310\n#define OV8865_PLL_CTRL11_REG\t\t\t0x311\n#define OV8865_PLL_CTRL12_REG\t\t\t0x312\n#define OV8865_PLL_CTRL12_PRE_DIV_HALF(v)\t((((v) - 1) << 4) & BIT(4))\n#define OV8865_PLL_CTRL12_DAC_DIV(v)\t\t(((v) - 1) & GENMASK(3, 0))\n\n#define OV8865_PLL_CTRL1B_REG\t\t\t0x31b\n#define OV8865_PLL_CTRL1C_REG\t\t\t0x31c\n\n#define OV8865_PLL_CTRL1E_REG\t\t\t0x31e\n#define OV8865_PLL_CTRL1E_PLL1_NO_LAT\t\tBIT(3)\n\n#define OV8865_PAD_OEN0_REG\t\t\t0x3000\n\n#define OV8865_PAD_OEN2_REG\t\t\t0x3002\n\n#define OV8865_CLK_RST5_REG\t\t\t0x3005\n\n#define OV8865_CHIP_ID_HH_REG\t\t\t0x300a\n#define OV8865_CHIP_ID_HH_VALUE\t\t\t0x00\n#define OV8865_CHIP_ID_H_REG\t\t\t0x300b\n#define OV8865_CHIP_ID_H_VALUE\t\t\t0x88\n#define OV8865_CHIP_ID_L_REG\t\t\t0x300c\n#define OV8865_CHIP_ID_L_VALUE\t\t\t0x65\n#define OV8865_PAD_OUT2_REG\t\t\t0x300d\n\n#define OV8865_PAD_SEL2_REG\t\t\t0x3010\n#define OV8865_PAD_PK_REG\t\t\t0x3011\n#define OV8865_PAD_PK_DRIVE_STRENGTH_1X\t\t(0 << 5)\n#define OV8865_PAD_PK_DRIVE_STRENGTH_2X\t\t(1 << 5)\n#define OV8865_PAD_PK_DRIVE_STRENGTH_3X\t\t(2 << 5)\n#define OV8865_PAD_PK_DRIVE_STRENGTH_4X\t\t(3 << 5)\n\n#define OV8865_PUMP_CLK_DIV_REG\t\t\t0x3015\n#define OV8865_PUMP_CLK_DIV_PUMP_N(v)\t\t(((v) << 4) & GENMASK(6, 4))\n#define OV8865_PUMP_CLK_DIV_PUMP_P(v)\t\t((v) & GENMASK(2, 0))\n\n#define OV8865_MIPI_SC_CTRL0_REG\t\t0x3018\n#define OV8865_MIPI_SC_CTRL0_LANES(v)\t\t((((v) - 1) << 5) & \\\n\t\t\t\t\t\t GENMASK(7, 5))\n#define OV8865_MIPI_SC_CTRL0_MIPI_EN\t\tBIT(4)\n#define OV8865_MIPI_SC_CTRL0_UNKNOWN\t\tBIT(1)\n#define OV8865_MIPI_SC_CTRL0_LANES_PD_MIPI\tBIT(0)\n#define OV8865_MIPI_SC_CTRL1_REG\t\t0x3019\n#define OV8865_CLK_RST0_REG\t\t\t0x301a\n#define OV8865_CLK_RST1_REG\t\t\t0x301b\n#define OV8865_CLK_RST2_REG\t\t\t0x301c\n#define OV8865_CLK_RST3_REG\t\t\t0x301d\n#define OV8865_CLK_RST4_REG\t\t\t0x301e\n\n#define OV8865_PCLK_SEL_REG\t\t\t0x3020\n#define OV8865_PCLK_SEL_PCLK_DIV_MASK\t\tBIT(3)\n#define OV8865_PCLK_SEL_PCLK_DIV(v)\t\t((((v) - 1) << 3) & BIT(3))\n\n#define OV8865_MISC_CTRL_REG\t\t\t0x3021\n#define OV8865_MIPI_SC_CTRL2_REG\t\t0x3022\n#define OV8865_MIPI_SC_CTRL2_CLK_LANES_PD_MIPI\tBIT(1)\n#define OV8865_MIPI_SC_CTRL2_PD_MIPI_RST_SYNC\tBIT(0)\n\n#define OV8865_MIPI_BIT_SEL_REG\t\t\t0x3031\n#define OV8865_MIPI_BIT_SEL(v)\t\t\t(((v) << 0) & GENMASK(4, 0))\n#define OV8865_CLK_SEL0_REG\t\t\t0x3032\n#define OV8865_CLK_SEL0_PLL1_SYS_SEL(v)\t\t(((v) << 7) & BIT(7))\n#define OV8865_CLK_SEL1_REG\t\t\t0x3033\n#define OV8865_CLK_SEL1_MIPI_EOF\t\tBIT(5)\n#define OV8865_CLK_SEL1_UNKNOWN\t\t\tBIT(2)\n#define OV8865_CLK_SEL1_PLL_SCLK_SEL_MASK\tBIT(1)\n#define OV8865_CLK_SEL1_PLL_SCLK_SEL(v)\t\t(((v) << 1) & BIT(1))\n\n#define OV8865_SCLK_CTRL_REG\t\t\t0x3106\n#define OV8865_SCLK_CTRL_SCLK_DIV(v)\t\t(((v) << 4) & GENMASK(7, 4))\n#define OV8865_SCLK_CTRL_SCLK_PRE_DIV(v)\t(((v) << 2) & GENMASK(3, 2))\n#define OV8865_SCLK_CTRL_UNKNOWN\t\tBIT(0)\n\n \n\n#define OV8865_EXPOSURE_CTRL_HH_REG\t\t0x3500\n#define OV8865_EXPOSURE_CTRL_HH(v)\t\t(((v) & GENMASK(19, 16)) >> 16)\n#define OV8865_EXPOSURE_CTRL_H_REG\t\t0x3501\n#define OV8865_EXPOSURE_CTRL_H(v)\t\t(((v) & GENMASK(15, 8)) >> 8)\n#define OV8865_EXPOSURE_CTRL_L_REG\t\t0x3502\n#define OV8865_EXPOSURE_CTRL_L(v)\t\t((v) & GENMASK(7, 0))\n#define OV8865_EXPOSURE_GAIN_MANUAL_REG\t\t0x3503\n#define OV8865_INTEGRATION_TIME_MARGIN\t\t8\n\n#define OV8865_GAIN_CTRL_H_REG\t\t\t0x3508\n#define OV8865_GAIN_CTRL_H(v)\t\t\t(((v) & GENMASK(12, 8)) >> 8)\n#define OV8865_GAIN_CTRL_L_REG\t\t\t0x3509\n#define OV8865_GAIN_CTRL_L(v)\t\t\t((v) & GENMASK(7, 0))\n\n \n\n#define OV8865_CROP_START_X_H_REG\t\t0x3800\n#define OV8865_CROP_START_X_H(v)\t\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV8865_CROP_START_X_L_REG\t\t0x3801\n#define OV8865_CROP_START_X_L(v)\t\t((v) & GENMASK(7, 0))\n#define OV8865_CROP_START_Y_H_REG\t\t0x3802\n#define OV8865_CROP_START_Y_H(v)\t\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV8865_CROP_START_Y_L_REG\t\t0x3803\n#define OV8865_CROP_START_Y_L(v)\t\t((v) & GENMASK(7, 0))\n#define OV8865_CROP_END_X_H_REG\t\t\t0x3804\n#define OV8865_CROP_END_X_H(v)\t\t\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV8865_CROP_END_X_L_REG\t\t\t0x3805\n#define OV8865_CROP_END_X_L(v)\t\t\t((v) & GENMASK(7, 0))\n#define OV8865_CROP_END_Y_H_REG\t\t\t0x3806\n#define OV8865_CROP_END_Y_H(v)\t\t\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV8865_CROP_END_Y_L_REG\t\t\t0x3807\n#define OV8865_CROP_END_Y_L(v)\t\t\t((v) & GENMASK(7, 0))\n#define OV8865_OUTPUT_SIZE_X_H_REG\t\t0x3808\n#define OV8865_OUTPUT_SIZE_X_H(v)\t\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV8865_OUTPUT_SIZE_X_L_REG\t\t0x3809\n#define OV8865_OUTPUT_SIZE_X_L(v)\t\t((v) & GENMASK(7, 0))\n#define OV8865_OUTPUT_SIZE_Y_H_REG\t\t0x380a\n#define OV8865_OUTPUT_SIZE_Y_H(v)\t\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV8865_OUTPUT_SIZE_Y_L_REG\t\t0x380b\n#define OV8865_OUTPUT_SIZE_Y_L(v)\t\t((v) & GENMASK(7, 0))\n#define OV8865_HTS_H_REG\t\t\t0x380c\n#define OV8865_HTS_H(v)\t\t\t\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV8865_HTS_L_REG\t\t\t0x380d\n#define OV8865_HTS_L(v)\t\t\t\t((v) & GENMASK(7, 0))\n#define OV8865_VTS_H_REG\t\t\t0x380e\n#define OV8865_VTS_H(v)\t\t\t\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV8865_VTS_L_REG\t\t\t0x380f\n#define OV8865_VTS_L(v)\t\t\t\t((v) & GENMASK(7, 0))\n#define OV8865_TIMING_MAX_VTS\t\t\t0xffff\n#define OV8865_TIMING_MIN_VTS\t\t\t0x04\n#define OV8865_OFFSET_X_H_REG\t\t\t0x3810\n#define OV8865_OFFSET_X_H(v)\t\t\t(((v) & GENMASK(15, 8)) >> 8)\n#define OV8865_OFFSET_X_L_REG\t\t\t0x3811\n#define OV8865_OFFSET_X_L(v)\t\t\t((v) & GENMASK(7, 0))\n#define OV8865_OFFSET_Y_H_REG\t\t\t0x3812\n#define OV8865_OFFSET_Y_H(v)\t\t\t(((v) & GENMASK(14, 8)) >> 8)\n#define OV8865_OFFSET_Y_L_REG\t\t\t0x3813\n#define OV8865_OFFSET_Y_L(v)\t\t\t((v) & GENMASK(7, 0))\n#define OV8865_INC_X_ODD_REG\t\t\t0x3814\n#define OV8865_INC_X_ODD(v)\t\t\t((v) & GENMASK(4, 0))\n#define OV8865_INC_X_EVEN_REG\t\t\t0x3815\n#define OV8865_INC_X_EVEN(v)\t\t\t((v) & GENMASK(4, 0))\n#define OV8865_VSYNC_START_H_REG\t\t0x3816\n#define OV8865_VSYNC_START_H(v)\t\t\t(((v) & GENMASK(15, 8)) >> 8)\n#define OV8865_VSYNC_START_L_REG\t\t0x3817\n#define OV8865_VSYNC_START_L(v)\t\t\t((v) & GENMASK(7, 0))\n#define OV8865_VSYNC_END_H_REG\t\t\t0x3818\n#define OV8865_VSYNC_END_H(v)\t\t\t(((v) & GENMASK(15, 8)) >> 8)\n#define OV8865_VSYNC_END_L_REG\t\t\t0x3819\n#define OV8865_VSYNC_END_L(v)\t\t\t((v) & GENMASK(7, 0))\n#define OV8865_HSYNC_FIRST_H_REG\t\t0x381a\n#define OV8865_HSYNC_FIRST_H(v)\t\t\t(((v) & GENMASK(15, 8)) >> 8)\n#define OV8865_HSYNC_FIRST_L_REG\t\t0x381b\n#define OV8865_HSYNC_FIRST_L(v)\t\t\t((v) & GENMASK(7, 0))\n\n#define OV8865_FORMAT1_REG\t\t\t0x3820\n#define OV8865_FORMAT1_FLIP_VERT_ISP_EN\t\tBIT(2)\n#define OV8865_FORMAT1_FLIP_VERT_SENSOR_EN\tBIT(1)\n#define OV8865_FORMAT2_REG\t\t\t0x3821\n#define OV8865_FORMAT2_HSYNC_EN\t\t\tBIT(6)\n#define OV8865_FORMAT2_FST_VBIN_EN\t\tBIT(5)\n#define OV8865_FORMAT2_FST_HBIN_EN\t\tBIT(4)\n#define OV8865_FORMAT2_ISP_HORZ_VAR2_EN\t\tBIT(3)\n#define OV8865_FORMAT2_FLIP_HORZ_ISP_EN\t\tBIT(2)\n#define OV8865_FORMAT2_FLIP_HORZ_SENSOR_EN\tBIT(1)\n#define OV8865_FORMAT2_SYNC_HBIN_EN\t\tBIT(0)\n\n#define OV8865_INC_Y_ODD_REG\t\t\t0x382a\n#define OV8865_INC_Y_ODD(v)\t\t\t((v) & GENMASK(4, 0))\n#define OV8865_INC_Y_EVEN_REG\t\t\t0x382b\n#define OV8865_INC_Y_EVEN(v)\t\t\t((v) & GENMASK(4, 0))\n\n#define OV8865_ABLC_NUM_REG\t\t\t0x3830\n#define OV8865_ABLC_NUM(v)\t\t\t((v) & GENMASK(4, 0))\n\n#define OV8865_ZLINE_NUM_REG\t\t\t0x3836\n#define OV8865_ZLINE_NUM(v)\t\t\t((v) & GENMASK(4, 0))\n\n#define OV8865_AUTO_SIZE_CTRL_REG\t\t0x3841\n#define OV8865_AUTO_SIZE_CTRL_OFFSET_Y_REG\tBIT(5)\n#define OV8865_AUTO_SIZE_CTRL_OFFSET_X_REG\tBIT(4)\n#define OV8865_AUTO_SIZE_CTRL_CROP_END_Y_REG\tBIT(3)\n#define OV8865_AUTO_SIZE_CTRL_CROP_END_X_REG\tBIT(2)\n#define OV8865_AUTO_SIZE_CTRL_CROP_START_Y_REG\tBIT(1)\n#define OV8865_AUTO_SIZE_CTRL_CROP_START_X_REG\tBIT(0)\n#define OV8865_AUTO_SIZE_X_OFFSET_H_REG\t\t0x3842\n#define OV8865_AUTO_SIZE_X_OFFSET_L_REG\t\t0x3843\n#define OV8865_AUTO_SIZE_Y_OFFSET_H_REG\t\t0x3844\n#define OV8865_AUTO_SIZE_Y_OFFSET_L_REG\t\t0x3845\n#define OV8865_AUTO_SIZE_BOUNDARIES_REG\t\t0x3846\n#define OV8865_AUTO_SIZE_BOUNDARIES_Y(v)\t(((v) << 4) & GENMASK(7, 4))\n#define OV8865_AUTO_SIZE_BOUNDARIES_X(v)\t((v) & GENMASK(3, 0))\n\n \n\n#define OV8865_PSRAM_CTRL8_REG\t\t\t0x3f08\n\n \n\n#define OV8865_BLC_CTRL0_REG\t\t\t0x4000\n#define OV8865_BLC_CTRL0_TRIG_RANGE_EN\t\tBIT(7)\n#define OV8865_BLC_CTRL0_TRIG_FORMAT_EN\t\tBIT(6)\n#define OV8865_BLC_CTRL0_TRIG_GAIN_EN\t\tBIT(5)\n#define OV8865_BLC_CTRL0_TRIG_EXPOSURE_EN\tBIT(4)\n#define OV8865_BLC_CTRL0_TRIG_MANUAL_EN\t\tBIT(3)\n#define OV8865_BLC_CTRL0_FREEZE_EN\t\tBIT(2)\n#define OV8865_BLC_CTRL0_ALWAYS_EN\t\tBIT(1)\n#define OV8865_BLC_CTRL0_FILTER_EN\t\tBIT(0)\n#define OV8865_BLC_CTRL1_REG\t\t\t0x4001\n#define OV8865_BLC_CTRL1_DITHER_EN\t\tBIT(7)\n#define OV8865_BLC_CTRL1_ZERO_LINE_DIFF_EN\tBIT(6)\n#define OV8865_BLC_CTRL1_COL_SHIFT_256\t\t(0 << 4)\n#define OV8865_BLC_CTRL1_COL_SHIFT_128\t\t(1 << 4)\n#define OV8865_BLC_CTRL1_COL_SHIFT_64\t\t(2 << 4)\n#define OV8865_BLC_CTRL1_COL_SHIFT_32\t\t(3 << 4)\n#define OV8865_BLC_CTRL1_OFFSET_LIMIT_EN\tBIT(2)\n#define OV8865_BLC_CTRL1_COLUMN_CANCEL_EN\tBIT(1)\n#define OV8865_BLC_CTRL2_REG\t\t\t0x4002\n#define OV8865_BLC_CTRL3_REG\t\t\t0x4003\n#define OV8865_BLC_CTRL4_REG\t\t\t0x4004\n#define OV8865_BLC_CTRL5_REG\t\t\t0x4005\n#define OV8865_BLC_CTRL6_REG\t\t\t0x4006\n#define OV8865_BLC_CTRL7_REG\t\t\t0x4007\n#define OV8865_BLC_CTRL8_REG\t\t\t0x4008\n#define OV8865_BLC_CTRL9_REG\t\t\t0x4009\n#define OV8865_BLC_CTRLA_REG\t\t\t0x400a\n#define OV8865_BLC_CTRLB_REG\t\t\t0x400b\n#define OV8865_BLC_CTRLC_REG\t\t\t0x400c\n#define OV8865_BLC_CTRLD_REG\t\t\t0x400d\n#define OV8865_BLC_CTRLD_OFFSET_TRIGGER(v)\t((v) & GENMASK(7, 0))\n\n#define OV8865_BLC_CTRL1F_REG\t\t\t0x401f\n#define OV8865_BLC_CTRL1F_RB_REVERSE\t\tBIT(3)\n#define OV8865_BLC_CTRL1F_INTERPOL_X_EN\t\tBIT(2)\n#define OV8865_BLC_CTRL1F_INTERPOL_Y_EN\t\tBIT(1)\n\n#define OV8865_BLC_ANCHOR_LEFT_START_H_REG\t0x4020\n#define OV8865_BLC_ANCHOR_LEFT_START_H(v)\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV8865_BLC_ANCHOR_LEFT_START_L_REG\t0x4021\n#define OV8865_BLC_ANCHOR_LEFT_START_L(v)\t((v) & GENMASK(7, 0))\n#define OV8865_BLC_ANCHOR_LEFT_END_H_REG\t0x4022\n#define OV8865_BLC_ANCHOR_LEFT_END_H(v)\t\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV8865_BLC_ANCHOR_LEFT_END_L_REG\t0x4023\n#define OV8865_BLC_ANCHOR_LEFT_END_L(v)\t\t((v) & GENMASK(7, 0))\n#define OV8865_BLC_ANCHOR_RIGHT_START_H_REG\t0x4024\n#define OV8865_BLC_ANCHOR_RIGHT_START_H(v)\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV8865_BLC_ANCHOR_RIGHT_START_L_REG\t0x4025\n#define OV8865_BLC_ANCHOR_RIGHT_START_L(v)\t((v) & GENMASK(7, 0))\n#define OV8865_BLC_ANCHOR_RIGHT_END_H_REG\t0x4026\n#define OV8865_BLC_ANCHOR_RIGHT_END_H(v)\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV8865_BLC_ANCHOR_RIGHT_END_L_REG\t0x4027\n#define OV8865_BLC_ANCHOR_RIGHT_END_L(v)\t((v) & GENMASK(7, 0))\n\n#define OV8865_BLC_TOP_ZLINE_START_REG\t\t0x4028\n#define OV8865_BLC_TOP_ZLINE_START(v)\t\t((v) & GENMASK(5, 0))\n#define OV8865_BLC_TOP_ZLINE_NUM_REG\t\t0x4029\n#define OV8865_BLC_TOP_ZLINE_NUM(v)\t\t((v) & GENMASK(4, 0))\n#define OV8865_BLC_TOP_BLKLINE_START_REG\t0x402a\n#define OV8865_BLC_TOP_BLKLINE_START(v)\t\t((v) & GENMASK(5, 0))\n#define OV8865_BLC_TOP_BLKLINE_NUM_REG\t\t0x402b\n#define OV8865_BLC_TOP_BLKLINE_NUM(v)\t\t((v) & GENMASK(4, 0))\n#define OV8865_BLC_BOT_ZLINE_START_REG\t\t0x402c\n#define OV8865_BLC_BOT_ZLINE_START(v)\t\t((v) & GENMASK(5, 0))\n#define OV8865_BLC_BOT_ZLINE_NUM_REG\t\t0x402d\n#define OV8865_BLC_BOT_ZLINE_NUM(v)\t\t((v) & GENMASK(4, 0))\n#define OV8865_BLC_BOT_BLKLINE_START_REG\t0x402e\n#define OV8865_BLC_BOT_BLKLINE_START(v)\t\t((v) & GENMASK(5, 0))\n#define OV8865_BLC_BOT_BLKLINE_NUM_REG\t\t0x402f\n#define OV8865_BLC_BOT_BLKLINE_NUM(v)\t\t((v) & GENMASK(4, 0))\n\n#define OV8865_BLC_OFFSET_LIMIT_REG\t\t0x4034\n#define OV8865_BLC_OFFSET_LIMIT(v)\t\t((v) & GENMASK(7, 0))\n\n \n\n#define OV8865_VFIFO_READ_START_H_REG\t\t0x4600\n#define OV8865_VFIFO_READ_START_H(v)\t\t(((v) & GENMASK(15, 8)) >> 8)\n#define OV8865_VFIFO_READ_START_L_REG\t\t0x4601\n#define OV8865_VFIFO_READ_START_L(v)\t\t((v) & GENMASK(7, 0))\n\n \n\n#define OV8865_MIPI_CTRL0_REG\t\t\t0x4800\n#define OV8865_MIPI_CTRL1_REG\t\t\t0x4801\n#define OV8865_MIPI_CTRL2_REG\t\t\t0x4802\n#define OV8865_MIPI_CTRL3_REG\t\t\t0x4803\n#define OV8865_MIPI_CTRL4_REG\t\t\t0x4804\n#define OV8865_MIPI_CTRL5_REG\t\t\t0x4805\n#define OV8865_MIPI_CTRL6_REG\t\t\t0x4806\n#define OV8865_MIPI_CTRL7_REG\t\t\t0x4807\n#define OV8865_MIPI_CTRL8_REG\t\t\t0x4808\n\n#define OV8865_MIPI_FCNT_MAX_H_REG\t\t0x4810\n#define OV8865_MIPI_FCNT_MAX_L_REG\t\t0x4811\n\n#define OV8865_MIPI_CTRL13_REG\t\t\t0x4813\n#define OV8865_MIPI_CTRL14_REG\t\t\t0x4814\n#define OV8865_MIPI_CTRL15_REG\t\t\t0x4815\n#define OV8865_MIPI_EMBEDDED_DT_REG\t\t0x4816\n\n#define OV8865_MIPI_HS_ZERO_MIN_H_REG\t\t0x4818\n#define OV8865_MIPI_HS_ZERO_MIN_L_REG\t\t0x4819\n#define OV8865_MIPI_HS_TRAIL_MIN_H_REG\t\t0x481a\n#define OV8865_MIPI_HS_TRAIL_MIN_L_REG\t\t0x481b\n#define OV8865_MIPI_CLK_ZERO_MIN_H_REG\t\t0x481c\n#define OV8865_MIPI_CLK_ZERO_MIN_L_REG\t\t0x481d\n#define OV8865_MIPI_CLK_PREPARE_MAX_REG\t\t0x481e\n#define OV8865_MIPI_CLK_PREPARE_MIN_REG\t\t0x481f\n#define OV8865_MIPI_CLK_POST_MIN_H_REG\t\t0x4820\n#define OV8865_MIPI_CLK_POST_MIN_L_REG\t\t0x4821\n#define OV8865_MIPI_CLK_TRAIL_MIN_H_REG\t\t0x4822\n#define OV8865_MIPI_CLK_TRAIL_MIN_L_REG\t\t0x4823\n#define OV8865_MIPI_LPX_P_MIN_H_REG\t\t0x4824\n#define OV8865_MIPI_LPX_P_MIN_L_REG\t\t0x4825\n#define OV8865_MIPI_HS_PREPARE_MIN_REG\t\t0x4826\n#define OV8865_MIPI_HS_PREPARE_MAX_REG\t\t0x4827\n#define OV8865_MIPI_HS_EXIT_MIN_H_REG\t\t0x4828\n#define OV8865_MIPI_HS_EXIT_MIN_L_REG\t\t0x4829\n#define OV8865_MIPI_UI_HS_ZERO_MIN_REG\t\t0x482a\n#define OV8865_MIPI_UI_HS_TRAIL_MIN_REG\t\t0x482b\n#define OV8865_MIPI_UI_CLK_ZERO_MIN_REG\t\t0x482c\n#define OV8865_MIPI_UI_CLK_PREPARE_REG\t\t0x482d\n#define OV8865_MIPI_UI_CLK_POST_MIN_REG\t\t0x482e\n#define OV8865_MIPI_UI_CLK_TRAIL_MIN_REG\t0x482f\n#define OV8865_MIPI_UI_LPX_P_MIN_REG\t\t0x4830\n#define OV8865_MIPI_UI_HS_PREPARE_REG\t\t0x4831\n#define OV8865_MIPI_UI_HS_EXIT_MIN_REG\t\t0x4832\n#define OV8865_MIPI_PKT_START_SIZE_REG\t\t0x4833\n\n#define OV8865_MIPI_PCLK_PERIOD_REG\t\t0x4837\n#define OV8865_MIPI_LP_GPIO0_REG\t\t0x4838\n#define OV8865_MIPI_LP_GPIO1_REG\t\t0x4839\n\n#define OV8865_MIPI_CTRL3C_REG\t\t\t0x483c\n#define OV8865_MIPI_LP_GPIO4_REG\t\t0x483d\n\n#define OV8865_MIPI_CTRL4A_REG\t\t\t0x484a\n#define OV8865_MIPI_CTRL4B_REG\t\t\t0x484b\n#define OV8865_MIPI_CTRL4C_REG\t\t\t0x484c\n#define OV8865_MIPI_LANE_TEST_PATTERN_REG\t0x484d\n#define OV8865_MIPI_FRAME_END_DELAY_REG\t\t0x484e\n#define OV8865_MIPI_CLOCK_TEST_PATTERN_REG\t0x484f\n#define OV8865_MIPI_LANE_SEL01_REG\t\t0x4850\n#define OV8865_MIPI_LANE_SEL01_LANE0(v)\t\t(((v) << 0) & GENMASK(2, 0))\n#define OV8865_MIPI_LANE_SEL01_LANE1(v)\t\t(((v) << 4) & GENMASK(6, 4))\n#define OV8865_MIPI_LANE_SEL23_REG\t\t0x4851\n#define OV8865_MIPI_LANE_SEL23_LANE2(v)\t\t(((v) << 0) & GENMASK(2, 0))\n#define OV8865_MIPI_LANE_SEL23_LANE3(v)\t\t(((v) << 4) & GENMASK(6, 4))\n\n \n\n#define OV8865_ISP_CTRL0_REG\t\t\t0x5000\n#define OV8865_ISP_CTRL0_LENC_EN\t\tBIT(7)\n#define OV8865_ISP_CTRL0_WHITE_BALANCE_EN\tBIT(4)\n#define OV8865_ISP_CTRL0_DPC_BLACK_EN\t\tBIT(2)\n#define OV8865_ISP_CTRL0_DPC_WHITE_EN\t\tBIT(1)\n#define OV8865_ISP_CTRL1_REG\t\t\t0x5001\n#define OV8865_ISP_CTRL1_BLC_EN\t\t\tBIT(0)\n#define OV8865_ISP_CTRL2_REG\t\t\t0x5002\n#define OV8865_ISP_CTRL2_DEBUG\t\t\tBIT(3)\n#define OV8865_ISP_CTRL2_VARIOPIXEL_EN\t\tBIT(2)\n#define OV8865_ISP_CTRL2_VSYNC_LATCH_EN\t\tBIT(0)\n#define OV8865_ISP_CTRL3_REG\t\t\t0x5003\n\n#define OV8865_ISP_GAIN_RED_H_REG\t\t0x5018\n#define OV8865_ISP_GAIN_RED_H(v)\t\t(((v) & GENMASK(13, 6)) >> 6)\n#define OV8865_ISP_GAIN_RED_L_REG\t\t0x5019\n#define OV8865_ISP_GAIN_RED_L(v)\t\t((v) & GENMASK(5, 0))\n#define OV8865_ISP_GAIN_GREEN_H_REG\t\t0x501a\n#define OV8865_ISP_GAIN_GREEN_H(v)\t\t(((v) & GENMASK(13, 6)) >> 6)\n#define OV8865_ISP_GAIN_GREEN_L_REG\t\t0x501b\n#define OV8865_ISP_GAIN_GREEN_L(v)\t\t((v) & GENMASK(5, 0))\n#define OV8865_ISP_GAIN_BLUE_H_REG\t\t0x501c\n#define OV8865_ISP_GAIN_BLUE_H(v)\t\t(((v) & GENMASK(13, 6)) >> 6)\n#define OV8865_ISP_GAIN_BLUE_L_REG\t\t0x501d\n#define OV8865_ISP_GAIN_BLUE_L(v)\t\t((v) & GENMASK(5, 0))\n\n \n\n#define OV8865_VAP_CTRL0_REG\t\t\t0x5900\n#define OV8865_VAP_CTRL1_REG\t\t\t0x5901\n#define OV8865_VAP_CTRL1_HSUB_COEF(v)\t\t((((v) - 1) << 2) & \\\n\t\t\t\t\t\t GENMASK(3, 2))\n#define OV8865_VAP_CTRL1_VSUB_COEF(v)\t\t(((v) - 1) & GENMASK(1, 0))\n\n \n\n#define OV8865_PRE_CTRL0_REG\t\t\t0x5e00\n#define OV8865_PRE_CTRL0_PATTERN_EN\t\tBIT(7)\n#define OV8865_PRE_CTRL0_ROLLING_BAR_EN\t\tBIT(6)\n#define OV8865_PRE_CTRL0_TRANSPARENT_MODE\tBIT(5)\n#define OV8865_PRE_CTRL0_SQUARES_BW_MODE\tBIT(4)\n#define OV8865_PRE_CTRL0_PATTERN_COLOR_BARS\t0\n#define OV8865_PRE_CTRL0_PATTERN_RANDOM_DATA\t1\n#define OV8865_PRE_CTRL0_PATTERN_COLOR_SQUARES\t2\n#define OV8865_PRE_CTRL0_PATTERN_BLACK\t\t3\n\n \n\n#define OV8865_NATIVE_WIDTH\t\t\t3296\n#define OV8865_NATIVE_HEIGHT\t\t\t2528\n#define OV8865_ACTIVE_START_LEFT\t\t16\n#define OV8865_ACTIVE_START_TOP\t\t\t40\n#define OV8865_ACTIVE_WIDTH\t\t\t3264\n#define OV8865_ACTIVE_HEIGHT\t\t\t2448\n\n \n\n#define ov8865_subdev_sensor(s) \\\n\tcontainer_of(s, struct ov8865_sensor, subdev)\n\n#define ov8865_ctrl_subdev(c) \\\n\t(&container_of((c)->handler, struct ov8865_sensor, \\\n\t\t       ctrls.handler)->subdev)\n\n \n\nstruct ov8865_register_value {\n\tu16 address;\n\tu8 value;\n\tunsigned int delay_ms;\n};\n\n \n\nstruct ov8865_pll1_config {\n\tunsigned int pll_pre_div_half;\n\tunsigned int pll_pre_div;\n\tunsigned int pll_mul;\n\tunsigned int m_div;\n\tunsigned int mipi_div;\n\tunsigned int pclk_div;\n\tunsigned int sys_pre_div;\n\tunsigned int sys_div;\n};\n\n \n\nstruct ov8865_pll2_config {\n\tunsigned int pll_pre_div_half;\n\tunsigned int pll_pre_div;\n\tunsigned int pll_mul;\n\tunsigned int dac_div;\n\tunsigned int sys_pre_div;\n\tunsigned int sys_div;\n};\n\nstruct ov8865_sclk_config {\n\tunsigned int sys_sel;\n\tunsigned int sclk_sel;\n\tunsigned int sclk_pre_div;\n\tunsigned int sclk_div;\n};\n\nstruct ov8865_pll_configs {\n\tconst struct ov8865_pll1_config *pll1_config;\n\tconst struct ov8865_pll2_config *pll2_config_native;\n\tconst struct ov8865_pll2_config *pll2_config_binning;\n};\n\n \n\nenum extclk_rate {\n\tOV8865_19_2_MHZ,\n\tOV8865_24_MHZ,\n\tOV8865_NUM_SUPPORTED_RATES\n};\n\nstatic const unsigned long supported_extclk_rates[] = {\n\t[OV8865_19_2_MHZ] = 19200000,\n\t[OV8865_24_MHZ] = 24000000,\n};\n\n \n\nstruct ov8865_mode {\n\tunsigned int crop_start_x;\n\tunsigned int offset_x;\n\tunsigned int output_size_x;\n\tunsigned int crop_end_x;\n\tunsigned int hts;\n\n\tunsigned int crop_start_y;\n\tunsigned int offset_y;\n\tunsigned int output_size_y;\n\tunsigned int crop_end_y;\n\tunsigned int vts;\n\n\t \n\tbool size_auto;\n\tunsigned int size_auto_boundary_x;\n\tunsigned int size_auto_boundary_y;\n\n\tbool binning_x;\n\tbool binning_y;\n\tbool variopixel;\n\tunsigned int variopixel_hsub_coef;\n\tunsigned int variopixel_vsub_coef;\n\n\t \n\tbool sync_hbin;\n\tbool horz_var2;\n\n\tunsigned int inc_x_odd;\n\tunsigned int inc_x_even;\n\tunsigned int inc_y_odd;\n\tunsigned int inc_y_even;\n\n\tunsigned int vfifo_read_start;\n\n\tunsigned int ablc_num;\n\tunsigned int zline_num;\n\n\tunsigned int blc_top_zero_line_start;\n\tunsigned int blc_top_zero_line_num;\n\tunsigned int blc_top_black_line_start;\n\tunsigned int blc_top_black_line_num;\n\n\tunsigned int blc_bottom_zero_line_start;\n\tunsigned int blc_bottom_zero_line_num;\n\tunsigned int blc_bottom_black_line_start;\n\tunsigned int blc_bottom_black_line_num;\n\n\tu8 blc_col_shift_mask;\n\n\tunsigned int blc_anchor_left_start;\n\tunsigned int blc_anchor_left_end;\n\tunsigned int blc_anchor_right_start;\n\tunsigned int blc_anchor_right_end;\n\n\tbool pll2_binning;\n\n\tconst struct ov8865_register_value *register_values;\n\tunsigned int register_values_count;\n};\n\nstruct ov8865_state {\n\tconst struct ov8865_mode *mode;\n\tu32 mbus_code;\n\n\tbool streaming;\n};\n\nstruct ov8865_ctrls {\n\tstruct v4l2_ctrl *link_freq;\n\tstruct v4l2_ctrl *pixel_rate;\n\tstruct v4l2_ctrl *hblank;\n\tstruct v4l2_ctrl *vblank;\n\tstruct v4l2_ctrl *exposure;\n\n\tstruct v4l2_ctrl_handler handler;\n};\n\nstruct ov8865_sensor {\n\tstruct device *dev;\n\tstruct i2c_client *i2c_client;\n\tstruct gpio_desc *reset;\n\tstruct gpio_desc *powerdown;\n\tstruct regulator *avdd;\n\tstruct regulator *dvdd;\n\tstruct regulator *dovdd;\n\n\tunsigned long extclk_rate;\n\tconst struct ov8865_pll_configs *pll_configs;\n\tstruct clk *extclk;\n\n\tstruct v4l2_fwnode_endpoint endpoint;\n\tstruct v4l2_subdev subdev;\n\tstruct media_pad pad;\n\n\tstruct mutex mutex;\n\n\tstruct ov8865_state state;\n\tstruct ov8865_ctrls ctrls;\n};\n\n \n\n \n\nstatic const struct ov8865_pll1_config ov8865_pll1_config_native_19_2mhz = {\n\t\t.pll_pre_div_half\t= 1,\n\t\t.pll_pre_div\t\t= 2,\n\t\t.pll_mul\t\t= 75,\n\t\t.m_div\t\t\t= 1,\n\t\t.mipi_div\t\t= 3,\n\t\t.pclk_div\t\t= 1,\n\t\t.sys_pre_div\t\t= 1,\n\t\t.sys_div\t\t= 2,\n};\n\nstatic const struct ov8865_pll1_config ov8865_pll1_config_native_24mhz = {\n\t\t.pll_pre_div_half\t= 1,\n\t\t.pll_pre_div\t\t= 0,\n\t\t.pll_mul\t\t= 30,\n\t\t.m_div\t\t\t= 1,\n\t\t.mipi_div\t\t= 3,\n\t\t.pclk_div\t\t= 1,\n\t\t.sys_pre_div\t\t= 1,\n\t\t.sys_div\t\t= 2,\n};\n\n \n\nstatic const struct ov8865_pll2_config ov8865_pll2_config_native_19_2mhz = {\n\t\t.pll_pre_div_half\t= 1,\n\t\t.pll_pre_div\t\t= 5,\n\t\t.pll_mul\t\t= 75,\n\t\t.dac_div\t\t= 1,\n\t\t.sys_pre_div\t\t= 1,\n\t\t.sys_div\t\t= 3,\n};\n\nstatic const struct ov8865_pll2_config ov8865_pll2_config_native_24mhz = {\n\t\t.pll_pre_div_half\t= 1,\n\t\t.pll_pre_div\t\t= 0,\n\t\t.pll_mul\t\t= 30,\n\t\t.dac_div\t\t= 2,\n\t\t.sys_pre_div\t\t= 5,\n\t\t.sys_div\t\t= 0,\n};\n\n \n\nstatic const struct ov8865_pll2_config ov8865_pll2_config_binning_19_2mhz = {\n\t.pll_pre_div_half\t= 1,\n\t.pll_pre_div\t\t= 2,\n\t.pll_mul\t\t= 75,\n\t.dac_div\t\t= 2,\n\t.sys_pre_div\t\t= 10,\n\t.sys_div\t\t= 0,\n};\n\nstatic const struct ov8865_pll2_config ov8865_pll2_config_binning_24mhz = {\n\t.pll_pre_div_half\t= 1,\n\t.pll_pre_div\t\t= 0,\n\t.pll_mul\t\t= 30,\n\t.dac_div\t\t= 2,\n\t.sys_pre_div\t\t= 10,\n\t.sys_div\t\t= 0,\n};\n\nstatic const struct ov8865_pll_configs ov8865_pll_configs_19_2mhz = {\n\t.pll1_config = &ov8865_pll1_config_native_19_2mhz,\n\t.pll2_config_native = &ov8865_pll2_config_native_19_2mhz,\n\t.pll2_config_binning = &ov8865_pll2_config_binning_19_2mhz,\n};\n\nstatic const struct ov8865_pll_configs ov8865_pll_configs_24mhz = {\n\t.pll1_config = &ov8865_pll1_config_native_24mhz,\n\t.pll2_config_native = &ov8865_pll2_config_native_24mhz,\n\t.pll2_config_binning = &ov8865_pll2_config_binning_24mhz,\n};\n\nstatic const struct ov8865_pll_configs *ov8865_pll_configs[] = {\n\t&ov8865_pll_configs_19_2mhz,\n\t&ov8865_pll_configs_24mhz,\n};\n\nstatic const struct ov8865_sclk_config ov8865_sclk_config_native = {\n\t.sys_sel\t\t= 1,\n\t.sclk_sel\t\t= 0,\n\t.sclk_pre_div\t\t= 0,\n\t.sclk_div\t\t= 0,\n};\n\nstatic const struct ov8865_register_value ov8865_register_values_native[] = {\n\t \n\n\t{ 0x3700, 0x48 },\n\t{ 0x3701, 0x18 },\n\t{ 0x3702, 0x50 },\n\t{ 0x3703, 0x32 },\n\t{ 0x3704, 0x28 },\n\t{ 0x3706, 0x70 },\n\t{ 0x3707, 0x08 },\n\t{ 0x3708, 0x48 },\n\t{ 0x3709, 0x80 },\n\t{ 0x370a, 0x01 },\n\t{ 0x370b, 0x70 },\n\t{ 0x370c, 0x07 },\n\t{ 0x3718, 0x14 },\n\t{ 0x3712, 0x44 },\n\t{ 0x371e, 0x31 },\n\t{ 0x371f, 0x7f },\n\t{ 0x3720, 0x0a },\n\t{ 0x3721, 0x0a },\n\t{ 0x3724, 0x04 },\n\t{ 0x3725, 0x04 },\n\t{ 0x3726, 0x0c },\n\t{ 0x3728, 0x0a },\n\t{ 0x3729, 0x03 },\n\t{ 0x372a, 0x06 },\n\t{ 0x372b, 0xa6 },\n\t{ 0x372c, 0xa6 },\n\t{ 0x372d, 0xa6 },\n\t{ 0x372e, 0x0c },\n\t{ 0x372f, 0x20 },\n\t{ 0x3730, 0x02 },\n\t{ 0x3731, 0x0c },\n\t{ 0x3732, 0x28 },\n\t{ 0x3736, 0x30 },\n\t{ 0x373a, 0x04 },\n\t{ 0x373b, 0x18 },\n\t{ 0x373c, 0x14 },\n\t{ 0x373e, 0x06 },\n\t{ 0x375a, 0x0c },\n\t{ 0x375b, 0x26 },\n\t{ 0x375d, 0x04 },\n\t{ 0x375f, 0x28 },\n\t{ 0x3767, 0x1e },\n\t{ 0x3772, 0x46 },\n\t{ 0x3773, 0x04 },\n\t{ 0x3774, 0x2c },\n\t{ 0x3775, 0x13 },\n\t{ 0x3776, 0x10 },\n\t{ 0x37a0, 0x88 },\n\t{ 0x37a1, 0x7a },\n\t{ 0x37a2, 0x7a },\n\t{ 0x37a3, 0x02 },\n\t{ 0x37a5, 0x09 },\n\t{ 0x37a7, 0x88 },\n\t{ 0x37a8, 0xb0 },\n\t{ 0x37a9, 0xb0 },\n\t{ 0x37aa, 0x88 },\n\t{ 0x37ab, 0x5c },\n\t{ 0x37ac, 0x5c },\n\t{ 0x37ad, 0x55 },\n\t{ 0x37ae, 0x19 },\n\t{ 0x37af, 0x19 },\n\t{ 0x37b3, 0x84 },\n\t{ 0x37b4, 0x84 },\n\t{ 0x37b5, 0x66 },\n\n\t \n\n\t{ OV8865_PSRAM_CTRL8_REG, 0x16 },\n\n\t \n\n\t{ 0x4500, 0x68 },\n};\n\nstatic const struct ov8865_register_value ov8865_register_values_binning[] = {\n\t \n\n\t{ 0x3700, 0x24 },\n\t{ 0x3701, 0x0c },\n\t{ 0x3702, 0x28 },\n\t{ 0x3703, 0x19 },\n\t{ 0x3704, 0x14 },\n\t{ 0x3706, 0x38 },\n\t{ 0x3707, 0x04 },\n\t{ 0x3708, 0x24 },\n\t{ 0x3709, 0x40 },\n\t{ 0x370a, 0x00 },\n\t{ 0x370b, 0xb8 },\n\t{ 0x370c, 0x04 },\n\t{ 0x3718, 0x12 },\n\t{ 0x3712, 0x42 },\n\t{ 0x371e, 0x19 },\n\t{ 0x371f, 0x40 },\n\t{ 0x3720, 0x05 },\n\t{ 0x3721, 0x05 },\n\t{ 0x3724, 0x02 },\n\t{ 0x3725, 0x02 },\n\t{ 0x3726, 0x06 },\n\t{ 0x3728, 0x05 },\n\t{ 0x3729, 0x02 },\n\t{ 0x372a, 0x03 },\n\t{ 0x372b, 0x53 },\n\t{ 0x372c, 0xa3 },\n\t{ 0x372d, 0x53 },\n\t{ 0x372e, 0x06 },\n\t{ 0x372f, 0x10 },\n\t{ 0x3730, 0x01 },\n\t{ 0x3731, 0x06 },\n\t{ 0x3732, 0x14 },\n\t{ 0x3736, 0x20 },\n\t{ 0x373a, 0x02 },\n\t{ 0x373b, 0x0c },\n\t{ 0x373c, 0x0a },\n\t{ 0x373e, 0x03 },\n\t{ 0x375a, 0x06 },\n\t{ 0x375b, 0x13 },\n\t{ 0x375d, 0x02 },\n\t{ 0x375f, 0x14 },\n\t{ 0x3767, 0x1c },\n\t{ 0x3772, 0x23 },\n\t{ 0x3773, 0x02 },\n\t{ 0x3774, 0x16 },\n\t{ 0x3775, 0x12 },\n\t{ 0x3776, 0x08 },\n\t{ 0x37a0, 0x44 },\n\t{ 0x37a1, 0x3d },\n\t{ 0x37a2, 0x3d },\n\t{ 0x37a3, 0x01 },\n\t{ 0x37a5, 0x08 },\n\t{ 0x37a7, 0x44 },\n\t{ 0x37a8, 0x58 },\n\t{ 0x37a9, 0x58 },\n\t{ 0x37aa, 0x44 },\n\t{ 0x37ab, 0x2e },\n\t{ 0x37ac, 0x2e },\n\t{ 0x37ad, 0x33 },\n\t{ 0x37ae, 0x0d },\n\t{ 0x37af, 0x0d },\n\t{ 0x37b3, 0x42 },\n\t{ 0x37b4, 0x42 },\n\t{ 0x37b5, 0x33 },\n\n\t \n\n\t{ OV8865_PSRAM_CTRL8_REG, 0x0b },\n\n\t \n\n\t{ 0x4500, 0x40 },\n};\n\nstatic const struct ov8865_mode ov8865_modes[] = {\n\t \n\t{\n\t\t \n\t\t.output_size_x\t\t\t= 3264,\n\t\t.hts\t\t\t\t= 3888,\n\n\t\t \n\t\t.output_size_y\t\t\t= 2448,\n\t\t.vts\t\t\t\t= 2470,\n\n\t\t.size_auto\t\t\t= true,\n\t\t.size_auto_boundary_x\t\t= 8,\n\t\t.size_auto_boundary_y\t\t= 4,\n\n\t\t \n\t\t.inc_x_odd\t\t\t= 1,\n\t\t.inc_x_even\t\t\t= 1,\n\t\t.inc_y_odd\t\t\t= 1,\n\t\t.inc_y_even\t\t\t= 1,\n\n\t\t \n\t\t.vfifo_read_start\t\t= 16,\n\n\t\t.ablc_num\t\t\t= 4,\n\t\t.zline_num\t\t\t= 1,\n\n\t\t \n\n\t\t.blc_top_zero_line_start\t= 0,\n\t\t.blc_top_zero_line_num\t\t= 2,\n\t\t.blc_top_black_line_start\t= 4,\n\t\t.blc_top_black_line_num\t\t= 4,\n\n\t\t.blc_bottom_zero_line_start\t= 2,\n\t\t.blc_bottom_zero_line_num\t= 2,\n\t\t.blc_bottom_black_line_start\t= 8,\n\t\t.blc_bottom_black_line_num\t= 2,\n\n\t\t.blc_anchor_left_start\t\t= 576,\n\t\t.blc_anchor_left_end\t\t= 831,\n\t\t.blc_anchor_right_start\t\t= 1984,\n\t\t.blc_anchor_right_end\t\t= 2239,\n\n\t\t \n\t\t.pll2_binning\t\t\t= false,\n\n\t\t \n\t\t.register_values\t= ov8865_register_values_native,\n\t\t.register_values_count\t=\n\t\t\tARRAY_SIZE(ov8865_register_values_native),\n\t},\n\t \n\t{\n\t\t \n\t\t.output_size_x\t\t\t= 3264,\n\t\t.hts\t\t\t\t= 3888,\n\n\t\t \n\t\t.output_size_y\t\t\t= 1836,\n\t\t.vts\t\t\t\t= 2470,\n\n\t\t.size_auto\t\t\t= true,\n\t\t.size_auto_boundary_x\t\t= 8,\n\t\t.size_auto_boundary_y\t\t= 4,\n\n\t\t \n\t\t.inc_x_odd\t\t\t= 1,\n\t\t.inc_x_even\t\t\t= 1,\n\t\t.inc_y_odd\t\t\t= 1,\n\t\t.inc_y_even\t\t\t= 1,\n\n\t\t \n\t\t.vfifo_read_start\t\t= 16,\n\n\t\t.ablc_num\t\t\t= 4,\n\t\t.zline_num\t\t\t= 1,\n\n\t\t \n\n\t\t.blc_top_zero_line_start\t= 0,\n\t\t.blc_top_zero_line_num\t\t= 2,\n\t\t.blc_top_black_line_start\t= 4,\n\t\t.blc_top_black_line_num\t\t= 4,\n\n\t\t.blc_bottom_zero_line_start\t= 2,\n\t\t.blc_bottom_zero_line_num\t= 2,\n\t\t.blc_bottom_black_line_start\t= 8,\n\t\t.blc_bottom_black_line_num\t= 2,\n\n\t\t.blc_anchor_left_start\t\t= 576,\n\t\t.blc_anchor_left_end\t\t= 831,\n\t\t.blc_anchor_right_start\t\t= 1984,\n\t\t.blc_anchor_right_end\t\t= 2239,\n\n\t\t \n\t\t.pll2_binning\t\t\t= false,\n\n\t\t \n\t\t.register_values\t= ov8865_register_values_native,\n\t\t.register_values_count\t=\n\t\t\tARRAY_SIZE(ov8865_register_values_native),\n\t},\n\t \n\t{\n\t\t \n\t\t.output_size_x\t\t\t= 1632,\n\t\t.hts\t\t\t\t= 1923,\n\n\t\t \n\t\t.output_size_y\t\t\t= 1224,\n\t\t.vts\t\t\t\t= 1248,\n\n\t\t.size_auto\t\t\t= true,\n\t\t.size_auto_boundary_x\t\t= 8,\n\t\t.size_auto_boundary_y\t\t= 8,\n\n\t\t \n\t\t.inc_x_odd\t\t\t= 3,\n\t\t.inc_x_even\t\t\t= 1,\n\t\t.inc_y_odd\t\t\t= 3,\n\t\t.inc_y_even\t\t\t= 1,\n\n\t\t \n\t\t.binning_y\t\t\t= true,\n\t\t.sync_hbin\t\t\t= true,\n\n\t\t \n\t\t.vfifo_read_start\t\t= 116,\n\n\t\t.ablc_num\t\t\t= 8,\n\t\t.zline_num\t\t\t= 2,\n\n\t\t \n\n\t\t.blc_top_zero_line_start\t= 0,\n\t\t.blc_top_zero_line_num\t\t= 2,\n\t\t.blc_top_black_line_start\t= 4,\n\t\t.blc_top_black_line_num\t\t= 4,\n\n\t\t.blc_bottom_zero_line_start\t= 2,\n\t\t.blc_bottom_zero_line_num\t= 2,\n\t\t.blc_bottom_black_line_start\t= 8,\n\t\t.blc_bottom_black_line_num\t= 2,\n\n\t\t.blc_anchor_left_start\t\t= 288,\n\t\t.blc_anchor_left_end\t\t= 415,\n\t\t.blc_anchor_right_start\t\t= 992,\n\t\t.blc_anchor_right_end\t\t= 1119,\n\n\t\t \n\t\t.pll2_binning\t\t\t= true,\n\n\t\t \n\t\t.register_values\t= ov8865_register_values_binning,\n\t\t.register_values_count\t=\n\t\t\tARRAY_SIZE(ov8865_register_values_binning),\n\t},\n\t \n\t{\n\t\t \n\t\t.output_size_x\t\t\t= 800,\n\t\t.hts\t\t\t\t= 1250,\n\n\t\t \n\t\t.output_size_y\t\t\t= 600,\n\t\t.vts\t\t\t\t= 640,\n\n\t\t.size_auto\t\t\t= true,\n\t\t.size_auto_boundary_x\t\t= 8,\n\t\t.size_auto_boundary_y\t\t= 8,\n\n\t\t \n\t\t.inc_x_odd\t\t\t= 3,\n\t\t.inc_x_even\t\t\t= 1,\n\t\t.inc_y_odd\t\t\t= 5,\n\t\t.inc_y_even\t\t\t= 3,\n\n\t\t \n\t\t.binning_y\t\t\t= true,\n\t\t.variopixel\t\t\t= true,\n\t\t.variopixel_hsub_coef\t\t= 2,\n\t\t.variopixel_vsub_coef\t\t= 1,\n\t\t.sync_hbin\t\t\t= true,\n\t\t.horz_var2\t\t\t= true,\n\n\t\t \n\t\t.vfifo_read_start\t\t= 80,\n\n\t\t.ablc_num\t\t\t= 8,\n\t\t.zline_num\t\t\t= 2,\n\n\t\t \n\n\t\t.blc_top_zero_line_start\t= 0,\n\t\t.blc_top_zero_line_num\t\t= 2,\n\t\t.blc_top_black_line_start\t= 2,\n\t\t.blc_top_black_line_num\t\t= 2,\n\n\t\t.blc_bottom_zero_line_start\t= 0,\n\t\t.blc_bottom_zero_line_num\t= 0,\n\t\t.blc_bottom_black_line_start\t= 4,\n\t\t.blc_bottom_black_line_num\t= 2,\n\n\t\t.blc_col_shift_mask\t= OV8865_BLC_CTRL1_COL_SHIFT_128,\n\n\t\t.blc_anchor_left_start\t\t= 288,\n\t\t.blc_anchor_left_end\t\t= 415,\n\t\t.blc_anchor_right_start\t\t= 992,\n\t\t.blc_anchor_right_end\t\t= 1119,\n\n\t\t \n\t\t.pll2_binning\t\t\t= true,\n\n\t\t \n\t\t.register_values\t= ov8865_register_values_binning,\n\t\t.register_values_count\t=\n\t\t\tARRAY_SIZE(ov8865_register_values_binning),\n\t},\n};\n\nstatic const u32 ov8865_mbus_codes[] = {\n\tMEDIA_BUS_FMT_SBGGR10_1X10,\n};\n\nstatic const struct ov8865_register_value ov8865_init_sequence[] = {\n\t \n\n\t{ 0x3604, 0x04 },\n\t{ 0x3602, 0x30 },\n\t{ 0x3605, 0x00 },\n\t{ 0x3607, 0x20 },\n\t{ 0x3608, 0x11 },\n\t{ 0x3609, 0x68 },\n\t{ 0x360a, 0x40 },\n\t{ 0x360c, 0xdd },\n\t{ 0x360e, 0x0c },\n\t{ 0x3610, 0x07 },\n\t{ 0x3612, 0x86 },\n\t{ 0x3613, 0x58 },\n\t{ 0x3614, 0x28 },\n\t{ 0x3617, 0x40 },\n\t{ 0x3618, 0x5a },\n\t{ 0x3619, 0x9b },\n\t{ 0x361c, 0x00 },\n\t{ 0x361d, 0x60 },\n\t{ 0x3631, 0x60 },\n\t{ 0x3633, 0x10 },\n\t{ 0x3634, 0x10 },\n\t{ 0x3635, 0x10 },\n\t{ 0x3636, 0x10 },\n\t{ 0x3638, 0xff },\n\t{ 0x3641, 0x55 },\n\t{ 0x3646, 0x86 },\n\t{ 0x3647, 0x27 },\n\t{ 0x364a, 0x1b },\n\n\t \n\n\t{ 0x3700, 0x24 },\n\t{ 0x3701, 0x0c },\n\t{ 0x3702, 0x28 },\n\t{ 0x3703, 0x19 },\n\t{ 0x3704, 0x14 },\n\t{ 0x3705, 0x00 },\n\t{ 0x3706, 0x38 },\n\t{ 0x3707, 0x04 },\n\t{ 0x3708, 0x24 },\n\t{ 0x3709, 0x40 },\n\t{ 0x370a, 0x00 },\n\t{ 0x370b, 0xb8 },\n\t{ 0x370c, 0x04 },\n\t{ 0x3718, 0x12 },\n\t{ 0x3719, 0x31 },\n\t{ 0x3712, 0x42 },\n\t{ 0x3714, 0x12 },\n\t{ 0x371e, 0x19 },\n\t{ 0x371f, 0x40 },\n\t{ 0x3720, 0x05 },\n\t{ 0x3721, 0x05 },\n\t{ 0x3724, 0x02 },\n\t{ 0x3725, 0x02 },\n\t{ 0x3726, 0x06 },\n\t{ 0x3728, 0x05 },\n\t{ 0x3729, 0x02 },\n\t{ 0x372a, 0x03 },\n\t{ 0x372b, 0x53 },\n\t{ 0x372c, 0xa3 },\n\t{ 0x372d, 0x53 },\n\t{ 0x372e, 0x06 },\n\t{ 0x372f, 0x10 },\n\t{ 0x3730, 0x01 },\n\t{ 0x3731, 0x06 },\n\t{ 0x3732, 0x14 },\n\t{ 0x3733, 0x10 },\n\t{ 0x3734, 0x40 },\n\t{ 0x3736, 0x20 },\n\t{ 0x373a, 0x02 },\n\t{ 0x373b, 0x0c },\n\t{ 0x373c, 0x0a },\n\t{ 0x373e, 0x03 },\n\t{ 0x3755, 0x40 },\n\t{ 0x3758, 0x00 },\n\t{ 0x3759, 0x4c },\n\t{ 0x375a, 0x06 },\n\t{ 0x375b, 0x13 },\n\t{ 0x375c, 0x40 },\n\t{ 0x375d, 0x02 },\n\t{ 0x375e, 0x00 },\n\t{ 0x375f, 0x14 },\n\t{ 0x3767, 0x1c },\n\t{ 0x3768, 0x04 },\n\t{ 0x3769, 0x20 },\n\t{ 0x376c, 0xc0 },\n\t{ 0x376d, 0xc0 },\n\t{ 0x376a, 0x08 },\n\t{ 0x3761, 0x00 },\n\t{ 0x3762, 0x00 },\n\t{ 0x3763, 0x00 },\n\t{ 0x3766, 0xff },\n\t{ 0x376b, 0x42 },\n\t{ 0x3772, 0x23 },\n\t{ 0x3773, 0x02 },\n\t{ 0x3774, 0x16 },\n\t{ 0x3775, 0x12 },\n\t{ 0x3776, 0x08 },\n\t{ 0x37a0, 0x44 },\n\t{ 0x37a1, 0x3d },\n\t{ 0x37a2, 0x3d },\n\t{ 0x37a3, 0x01 },\n\t{ 0x37a4, 0x00 },\n\t{ 0x37a5, 0x08 },\n\t{ 0x37a6, 0x00 },\n\t{ 0x37a7, 0x44 },\n\t{ 0x37a8, 0x58 },\n\t{ 0x37a9, 0x58 },\n\t{ 0x3760, 0x00 },\n\t{ 0x376f, 0x01 },\n\t{ 0x37aa, 0x44 },\n\t{ 0x37ab, 0x2e },\n\t{ 0x37ac, 0x2e },\n\t{ 0x37ad, 0x33 },\n\t{ 0x37ae, 0x0d },\n\t{ 0x37af, 0x0d },\n\t{ 0x37b0, 0x00 },\n\t{ 0x37b1, 0x00 },\n\t{ 0x37b2, 0x00 },\n\t{ 0x37b3, 0x42 },\n\t{ 0x37b4, 0x42 },\n\t{ 0x37b5, 0x33 },\n\t{ 0x37b6, 0x00 },\n\t{ 0x37b7, 0x00 },\n\t{ 0x37b8, 0x00 },\n\t{ 0x37b9, 0xff },\n\n\t \n\n\t{ 0x4503, 0x10 },\n};\n\nstatic const s64 ov8865_link_freq_menu[] = {\n\t360000000,\n};\n\nstatic const char *const ov8865_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Random data\",\n\t\"Color bars\",\n\t\"Color bars with rolling bar\",\n\t\"Color squares\",\n\t\"Color squares with rolling bar\"\n};\n\nstatic const u8 ov8865_test_pattern_bits[] = {\n\t0,\n\tOV8865_PRE_CTRL0_PATTERN_EN | OV8865_PRE_CTRL0_PATTERN_RANDOM_DATA,\n\tOV8865_PRE_CTRL0_PATTERN_EN | OV8865_PRE_CTRL0_PATTERN_COLOR_BARS,\n\tOV8865_PRE_CTRL0_PATTERN_EN | OV8865_PRE_CTRL0_ROLLING_BAR_EN |\n\tOV8865_PRE_CTRL0_PATTERN_COLOR_BARS,\n\tOV8865_PRE_CTRL0_PATTERN_EN | OV8865_PRE_CTRL0_PATTERN_COLOR_SQUARES,\n\tOV8865_PRE_CTRL0_PATTERN_EN | OV8865_PRE_CTRL0_ROLLING_BAR_EN |\n\tOV8865_PRE_CTRL0_PATTERN_COLOR_SQUARES,\n};\n\n \n\nstatic int ov8865_read(struct ov8865_sensor *sensor, u16 address, u8 *value)\n{\n\tunsigned char data[2] = { address >> 8, address & 0xff };\n\tstruct i2c_client *client = sensor->i2c_client;\n\tint ret;\n\n\tret = i2c_master_send(client, data, sizeof(data));\n\tif (ret < 0) {\n\t\tdev_dbg(&client->dev, \"i2c send error at address %#04x\\n\",\n\t\t\taddress);\n\t\treturn ret;\n\t}\n\n\tret = i2c_master_recv(client, value, 1);\n\tif (ret < 0) {\n\t\tdev_dbg(&client->dev, \"i2c recv error at address %#04x\\n\",\n\t\t\taddress);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov8865_write(struct ov8865_sensor *sensor, u16 address, u8 value)\n{\n\tunsigned char data[3] = { address >> 8, address & 0xff, value };\n\tstruct i2c_client *client = sensor->i2c_client;\n\tint ret;\n\n\tret = i2c_master_send(client, data, sizeof(data));\n\tif (ret < 0) {\n\t\tdev_dbg(&client->dev, \"i2c send error at address %#04x\\n\",\n\t\t\taddress);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov8865_write_sequence(struct ov8865_sensor *sensor,\n\t\t\t\t const struct ov8865_register_value *sequence,\n\t\t\t\t unsigned int sequence_count)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < sequence_count; i++) {\n\t\tret = ov8865_write(sensor, sequence[i].address,\n\t\t\t\t   sequence[i].value);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (sequence[i].delay_ms)\n\t\t\tmsleep(sequence[i].delay_ms);\n\t}\n\n\treturn ret;\n}\n\nstatic int ov8865_update_bits(struct ov8865_sensor *sensor, u16 address,\n\t\t\t      u8 mask, u8 bits)\n{\n\tu8 value = 0;\n\tint ret;\n\n\tret = ov8865_read(sensor, address, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tvalue &= ~mask;\n\tvalue |= bits;\n\n\treturn ov8865_write(sensor, address, value);\n}\n\n \n\nstatic int ov8865_sw_reset(struct ov8865_sensor *sensor)\n{\n\treturn ov8865_write(sensor, OV8865_SW_RESET_REG, OV8865_SW_RESET_RESET);\n}\n\nstatic int ov8865_sw_standby(struct ov8865_sensor *sensor, int standby)\n{\n\tu8 value = 0;\n\n\tif (!standby)\n\t\tvalue = OV8865_SW_STANDBY_STREAM_ON;\n\n\treturn ov8865_write(sensor, OV8865_SW_STANDBY_REG, value);\n}\n\nstatic int ov8865_chip_id_check(struct ov8865_sensor *sensor)\n{\n\tu16 regs[] = { OV8865_CHIP_ID_HH_REG, OV8865_CHIP_ID_H_REG,\n\t\t       OV8865_CHIP_ID_L_REG };\n\tu8 values[] = { OV8865_CHIP_ID_HH_VALUE, OV8865_CHIP_ID_H_VALUE,\n\t\t\tOV8865_CHIP_ID_L_VALUE };\n\tunsigned int i;\n\tu8 value;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(regs); i++) {\n\t\tret = ov8865_read(sensor, regs[i], &value);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (value != values[i]) {\n\t\t\tdev_err(sensor->dev,\n\t\t\t\t\"chip id value mismatch: %#x instead of %#x\\n\",\n\t\t\t\tvalue, values[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ov8865_charge_pump_configure(struct ov8865_sensor *sensor)\n{\n\treturn ov8865_write(sensor, OV8865_PUMP_CLK_DIV_REG,\n\t\t\t    OV8865_PUMP_CLK_DIV_PUMP_P(1));\n}\n\nstatic int ov8865_mipi_configure(struct ov8865_sensor *sensor)\n{\n\tstruct v4l2_mbus_config_mipi_csi2 *bus_mipi_csi2 =\n\t\t&sensor->endpoint.bus.mipi_csi2;\n\tunsigned int lanes_count = bus_mipi_csi2->num_data_lanes;\n\tint ret;\n\n\tret = ov8865_write(sensor, OV8865_MIPI_SC_CTRL0_REG,\n\t\t\t   OV8865_MIPI_SC_CTRL0_LANES(lanes_count) |\n\t\t\t   OV8865_MIPI_SC_CTRL0_MIPI_EN |\n\t\t\t   OV8865_MIPI_SC_CTRL0_UNKNOWN);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_MIPI_SC_CTRL2_REG,\n\t\t\t   OV8865_MIPI_SC_CTRL2_PD_MIPI_RST_SYNC);\n\tif (ret)\n\t\treturn ret;\n\n\tif (lanes_count >= 2) {\n\t\tret = ov8865_write(sensor, OV8865_MIPI_LANE_SEL01_REG,\n\t\t\t\t   OV8865_MIPI_LANE_SEL01_LANE0(0) |\n\t\t\t\t   OV8865_MIPI_LANE_SEL01_LANE1(1));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (lanes_count >= 4) {\n\t\tret = ov8865_write(sensor, OV8865_MIPI_LANE_SEL23_REG,\n\t\t\t\t   OV8865_MIPI_LANE_SEL23_LANE2(2) |\n\t\t\t\t   OV8865_MIPI_LANE_SEL23_LANE3(3));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = ov8865_update_bits(sensor, OV8865_CLK_SEL1_REG,\n\t\t\t\t OV8865_CLK_SEL1_MIPI_EOF,\n\t\t\t\t OV8865_CLK_SEL1_MIPI_EOF);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn ov8865_write(sensor, OV8865_MIPI_PCLK_PERIOD_REG, 0x16);\n}\n\nstatic int ov8865_black_level_configure(struct ov8865_sensor *sensor)\n{\n\tint ret;\n\n\t \n\tret = ov8865_write(sensor, OV8865_BLC_CTRL0_REG,\n\t\t\t   OV8865_BLC_CTRL0_TRIG_RANGE_EN |\n\t\t\t   OV8865_BLC_CTRL0_TRIG_FORMAT_EN |\n\t\t\t   OV8865_BLC_CTRL0_TRIG_GAIN_EN |\n\t\t\t   OV8865_BLC_CTRL0_TRIG_EXPOSURE_EN |\n\t\t\t   OV8865_BLC_CTRL0_FILTER_EN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov8865_write(sensor, OV8865_BLC_CTRLD_REG,\n\t\t\t   OV8865_BLC_CTRLD_OFFSET_TRIGGER(16));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_BLC_CTRL1F_REG, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn ov8865_write(sensor, OV8865_BLC_OFFSET_LIMIT_REG,\n\t\t\t    OV8865_BLC_OFFSET_LIMIT(63));\n}\n\nstatic int ov8865_isp_configure(struct ov8865_sensor *sensor)\n{\n\tint ret;\n\n\t \n\tret = ov8865_write(sensor, OV8865_ISP_CTRL0_REG,\n\t\t\t   OV8865_ISP_CTRL0_WHITE_BALANCE_EN |\n\t\t\t   OV8865_ISP_CTRL0_DPC_BLACK_EN |\n\t\t\t   OV8865_ISP_CTRL0_DPC_WHITE_EN);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov8865_write(sensor, OV8865_ISP_CTRL1_REG,\n\t\t\t    OV8865_ISP_CTRL1_BLC_EN);\n}\n\nstatic unsigned long ov8865_mode_pll1_rate(struct ov8865_sensor *sensor,\n\t\t\t\t\t   const struct ov8865_mode *mode)\n{\n\tconst struct ov8865_pll1_config *config;\n\tunsigned long pll1_rate;\n\n\tconfig = sensor->pll_configs->pll1_config;\n\tpll1_rate = sensor->extclk_rate * config->pll_mul / config->pll_pre_div_half;\n\n\tswitch (config->pll_pre_div) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\tpll1_rate *= 3;\n\t\tpll1_rate /= 2;\n\t\tbreak;\n\tcase 3:\n\t\tpll1_rate *= 5;\n\t\tpll1_rate /= 2;\n\t\tbreak;\n\tcase 4:\n\t\tpll1_rate /= 3;\n\t\tbreak;\n\tcase 5:\n\t\tpll1_rate /= 4;\n\t\tbreak;\n\tcase 7:\n\t\tpll1_rate /= 8;\n\t\tbreak;\n\tdefault:\n\t\tpll1_rate /= config->pll_pre_div;\n\t\tbreak;\n\t}\n\n\treturn pll1_rate;\n}\n\nstatic int ov8865_mode_pll1_configure(struct ov8865_sensor *sensor,\n\t\t\t\t      const struct ov8865_mode *mode,\n\t\t\t\t      u32 mbus_code)\n{\n\tconst struct ov8865_pll1_config *config;\n\tu8 value;\n\tint ret;\n\n\tconfig = sensor->pll_configs->pll1_config;\n\n\tswitch (mbus_code) {\n\tcase MEDIA_BUS_FMT_SBGGR10_1X10:\n\t\tvalue = OV8865_MIPI_BIT_SEL(10);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = ov8865_write(sensor, OV8865_MIPI_BIT_SEL_REG, value);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_PLL_CTRLA_REG,\n\t\t\t   OV8865_PLL_CTRLA_PRE_DIV_HALF(config->pll_pre_div_half));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_PLL_CTRL0_REG,\n\t\t\t   OV8865_PLL_CTRL0_PRE_DIV(config->pll_pre_div));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_PLL_CTRL1_REG,\n\t\t\t   OV8865_PLL_CTRL1_MUL_H(config->pll_mul));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_PLL_CTRL2_REG,\n\t\t\t   OV8865_PLL_CTRL2_MUL_L(config->pll_mul));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_PLL_CTRL3_REG,\n\t\t\t   OV8865_PLL_CTRL3_M_DIV(config->m_div));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_PLL_CTRL4_REG,\n\t\t\t   OV8865_PLL_CTRL4_MIPI_DIV(config->mipi_div));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_update_bits(sensor, OV8865_PCLK_SEL_REG,\n\t\t\t\t OV8865_PCLK_SEL_PCLK_DIV_MASK,\n\t\t\t\t OV8865_PCLK_SEL_PCLK_DIV(config->pclk_div));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_PLL_CTRL5_REG,\n\t\t\t   OV8865_PLL_CTRL5_SYS_PRE_DIV(config->sys_pre_div));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_PLL_CTRL6_REG,\n\t\t\t   OV8865_PLL_CTRL6_SYS_DIV(config->sys_div));\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov8865_update_bits(sensor, OV8865_PLL_CTRL1E_REG,\n\t\t\t\t  OV8865_PLL_CTRL1E_PLL1_NO_LAT,\n\t\t\t\t  OV8865_PLL_CTRL1E_PLL1_NO_LAT);\n}\n\nstatic int ov8865_mode_pll2_configure(struct ov8865_sensor *sensor,\n\t\t\t\t      const struct ov8865_mode *mode)\n{\n\tconst struct ov8865_pll2_config *config;\n\tint ret;\n\n\tconfig = mode->pll2_binning ? sensor->pll_configs->pll2_config_binning :\n\t\t\t\t      sensor->pll_configs->pll2_config_native;\n\n\tret = ov8865_write(sensor, OV8865_PLL_CTRL12_REG,\n\t\t\t   OV8865_PLL_CTRL12_PRE_DIV_HALF(config->pll_pre_div_half) |\n\t\t\t   OV8865_PLL_CTRL12_DAC_DIV(config->dac_div));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_PLL_CTRLB_REG,\n\t\t\t   OV8865_PLL_CTRLB_PRE_DIV(config->pll_pre_div));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_PLL_CTRLC_REG,\n\t\t\t   OV8865_PLL_CTRLC_MUL_H(config->pll_mul));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_PLL_CTRLD_REG,\n\t\t\t   OV8865_PLL_CTRLD_MUL_L(config->pll_mul));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_PLL_CTRLF_REG,\n\t\t\t   OV8865_PLL_CTRLF_SYS_PRE_DIV(config->sys_pre_div));\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov8865_write(sensor, OV8865_PLL_CTRLE_REG,\n\t\t\t    OV8865_PLL_CTRLE_SYS_DIV(config->sys_div));\n}\n\nstatic int ov8865_mode_sclk_configure(struct ov8865_sensor *sensor,\n\t\t\t\t      const struct ov8865_mode *mode)\n{\n\tconst struct ov8865_sclk_config *config = &ov8865_sclk_config_native;\n\tint ret;\n\n\tret = ov8865_write(sensor, OV8865_CLK_SEL0_REG,\n\t\t\t   OV8865_CLK_SEL0_PLL1_SYS_SEL(config->sys_sel));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_update_bits(sensor, OV8865_CLK_SEL1_REG,\n\t\t\t\t OV8865_CLK_SEL1_PLL_SCLK_SEL_MASK,\n\t\t\t\t OV8865_CLK_SEL1_PLL_SCLK_SEL(config->sclk_sel));\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov8865_write(sensor, OV8865_SCLK_CTRL_REG,\n\t\t\t    OV8865_SCLK_CTRL_UNKNOWN |\n\t\t\t    OV8865_SCLK_CTRL_SCLK_DIV(config->sclk_div) |\n\t\t\t    OV8865_SCLK_CTRL_SCLK_PRE_DIV(config->sclk_pre_div));\n}\n\nstatic int ov8865_mode_binning_configure(struct ov8865_sensor *sensor,\n\t\t\t\t\t const struct ov8865_mode *mode)\n{\n\tunsigned int variopixel_hsub_coef, variopixel_vsub_coef;\n\tu8 value;\n\tint ret;\n\n\tret = ov8865_write(sensor, OV8865_FORMAT1_REG, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tvalue = OV8865_FORMAT2_HSYNC_EN;\n\n\tif (mode->binning_x)\n\t\tvalue |= OV8865_FORMAT2_FST_HBIN_EN;\n\n\tif (mode->binning_y)\n\t\tvalue |= OV8865_FORMAT2_FST_VBIN_EN;\n\n\tif (mode->sync_hbin)\n\t\tvalue |= OV8865_FORMAT2_SYNC_HBIN_EN;\n\n\tif (mode->horz_var2)\n\t\tvalue |= OV8865_FORMAT2_ISP_HORZ_VAR2_EN;\n\n\tret = ov8865_write(sensor, OV8865_FORMAT2_REG, value);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_update_bits(sensor, OV8865_ISP_CTRL2_REG,\n\t\t\t\t OV8865_ISP_CTRL2_VARIOPIXEL_EN,\n\t\t\t\t mode->variopixel ?\n\t\t\t\t OV8865_ISP_CTRL2_VARIOPIXEL_EN : 0);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mode->variopixel) {\n\t\t \n\t\tvariopixel_hsub_coef = mode->variopixel_hsub_coef;\n\t\tvariopixel_vsub_coef = mode->variopixel_vsub_coef;\n\t} else {\n\t\tvariopixel_hsub_coef = 1;\n\t\tvariopixel_vsub_coef = 1;\n\t}\n\n\tret = ov8865_write(sensor, OV8865_VAP_CTRL1_REG,\n\t\t\t   OV8865_VAP_CTRL1_HSUB_COEF(variopixel_hsub_coef) |\n\t\t\t   OV8865_VAP_CTRL1_VSUB_COEF(variopixel_vsub_coef));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_INC_X_ODD_REG,\n\t\t\t   OV8865_INC_X_ODD(mode->inc_x_odd));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_INC_X_EVEN_REG,\n\t\t\t   OV8865_INC_X_EVEN(mode->inc_x_even));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_INC_Y_ODD_REG,\n\t\t\t   OV8865_INC_Y_ODD(mode->inc_y_odd));\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov8865_write(sensor, OV8865_INC_Y_EVEN_REG,\n\t\t\t    OV8865_INC_Y_EVEN(mode->inc_y_even));\n}\n\nstatic int ov8865_mode_black_level_configure(struct ov8865_sensor *sensor,\n\t\t\t\t\t     const struct ov8865_mode *mode)\n{\n\tint ret;\n\n\t \n\tret = ov8865_write(sensor, OV8865_BLC_CTRL1_REG,\n\t\t\t   mode->blc_col_shift_mask |\n\t\t\t   OV8865_BLC_CTRL1_OFFSET_LIMIT_EN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov8865_write(sensor, OV8865_BLC_TOP_ZLINE_START_REG,\n\t\t\t   OV8865_BLC_TOP_ZLINE_START(mode->blc_top_zero_line_start));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_BLC_TOP_ZLINE_NUM_REG,\n\t\t\t   OV8865_BLC_TOP_ZLINE_NUM(mode->blc_top_zero_line_num));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov8865_write(sensor, OV8865_BLC_TOP_BLKLINE_START_REG,\n\t\t\t   OV8865_BLC_TOP_BLKLINE_START(mode->blc_top_black_line_start));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_BLC_TOP_BLKLINE_NUM_REG,\n\t\t\t   OV8865_BLC_TOP_BLKLINE_NUM(mode->blc_top_black_line_num));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov8865_write(sensor, OV8865_BLC_BOT_ZLINE_START_REG,\n\t\t\t   OV8865_BLC_BOT_ZLINE_START(mode->blc_bottom_zero_line_start));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_BLC_BOT_ZLINE_NUM_REG,\n\t\t\t   OV8865_BLC_BOT_ZLINE_NUM(mode->blc_bottom_zero_line_num));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov8865_write(sensor, OV8865_BLC_BOT_BLKLINE_START_REG,\n\t\t\t   OV8865_BLC_BOT_BLKLINE_START(mode->blc_bottom_black_line_start));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_BLC_BOT_BLKLINE_NUM_REG,\n\t\t\t   OV8865_BLC_BOT_BLKLINE_NUM(mode->blc_bottom_black_line_num));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov8865_write(sensor, OV8865_BLC_ANCHOR_LEFT_START_H_REG,\n\t\t\t   OV8865_BLC_ANCHOR_LEFT_START_H(mode->blc_anchor_left_start));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_BLC_ANCHOR_LEFT_START_L_REG,\n\t\t\t   OV8865_BLC_ANCHOR_LEFT_START_L(mode->blc_anchor_left_start));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_BLC_ANCHOR_LEFT_END_H_REG,\n\t\t\t   OV8865_BLC_ANCHOR_LEFT_END_H(mode->blc_anchor_left_end));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_BLC_ANCHOR_LEFT_END_L_REG,\n\t\t\t   OV8865_BLC_ANCHOR_LEFT_END_L(mode->blc_anchor_left_end));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_BLC_ANCHOR_RIGHT_START_H_REG,\n\t\t\t   OV8865_BLC_ANCHOR_RIGHT_START_H(mode->blc_anchor_right_start));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_BLC_ANCHOR_RIGHT_START_L_REG,\n\t\t\t   OV8865_BLC_ANCHOR_RIGHT_START_L(mode->blc_anchor_right_start));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_BLC_ANCHOR_RIGHT_END_H_REG,\n\t\t\t   OV8865_BLC_ANCHOR_RIGHT_END_H(mode->blc_anchor_right_end));\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov8865_write(sensor, OV8865_BLC_ANCHOR_RIGHT_END_L_REG,\n\t\t\t    OV8865_BLC_ANCHOR_RIGHT_END_L(mode->blc_anchor_right_end));\n}\n\nstatic int ov8865_mode_configure(struct ov8865_sensor *sensor,\n\t\t\t\t const struct ov8865_mode *mode, u32 mbus_code)\n{\n\tint ret;\n\n\t \n\n\tret = ov8865_write(sensor, OV8865_OUTPUT_SIZE_X_H_REG,\n\t\t\t   OV8865_OUTPUT_SIZE_X_H(mode->output_size_x));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_OUTPUT_SIZE_X_L_REG,\n\t\t\t   OV8865_OUTPUT_SIZE_X_L(mode->output_size_x));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov8865_write(sensor, OV8865_HTS_H_REG, OV8865_HTS_H(mode->hts));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_HTS_L_REG, OV8865_HTS_L(mode->hts));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov8865_write(sensor, OV8865_OUTPUT_SIZE_Y_H_REG,\n\t\t\t   OV8865_OUTPUT_SIZE_Y_H(mode->output_size_y));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_OUTPUT_SIZE_Y_L_REG,\n\t\t\t   OV8865_OUTPUT_SIZE_Y_L(mode->output_size_y));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov8865_write(sensor, OV8865_VTS_H_REG, OV8865_VTS_H(mode->vts));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_VTS_L_REG, OV8865_VTS_L(mode->vts));\n\tif (ret)\n\t\treturn ret;\n\n\tif (mode->size_auto) {\n\t\t \n\n\t\tret = ov8865_write(sensor, OV8865_AUTO_SIZE_CTRL_REG,\n\t\t\t\t   OV8865_AUTO_SIZE_CTRL_OFFSET_Y_REG |\n\t\t\t\t   OV8865_AUTO_SIZE_CTRL_OFFSET_X_REG |\n\t\t\t\t   OV8865_AUTO_SIZE_CTRL_CROP_END_Y_REG |\n\t\t\t\t   OV8865_AUTO_SIZE_CTRL_CROP_END_X_REG |\n\t\t\t\t   OV8865_AUTO_SIZE_CTRL_CROP_START_Y_REG |\n\t\t\t\t   OV8865_AUTO_SIZE_CTRL_CROP_START_X_REG);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ov8865_write(sensor, OV8865_AUTO_SIZE_BOUNDARIES_REG,\n\t\t\t\t   OV8865_AUTO_SIZE_BOUNDARIES_Y(mode->size_auto_boundary_y) |\n\t\t\t\t   OV8865_AUTO_SIZE_BOUNDARIES_X(mode->size_auto_boundary_x));\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\n\t\tret = ov8865_write(sensor, OV8865_CROP_START_X_H_REG,\n\t\t\t\t   OV8865_CROP_START_X_H(mode->crop_start_x));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ov8865_write(sensor, OV8865_CROP_START_X_L_REG,\n\t\t\t\t   OV8865_CROP_START_X_L(mode->crop_start_x));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\n\t\tret = ov8865_write(sensor, OV8865_OFFSET_X_H_REG,\n\t\t\t\t   OV8865_OFFSET_X_H(mode->offset_x));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ov8865_write(sensor, OV8865_OFFSET_X_L_REG,\n\t\t\t\t   OV8865_OFFSET_X_L(mode->offset_x));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\n\t\tret = ov8865_write(sensor, OV8865_CROP_END_X_H_REG,\n\t\t\t\t   OV8865_CROP_END_X_H(mode->crop_end_x));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ov8865_write(sensor, OV8865_CROP_END_X_L_REG,\n\t\t\t\t   OV8865_CROP_END_X_L(mode->crop_end_x));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\n\t\tret = ov8865_write(sensor, OV8865_CROP_START_Y_H_REG,\n\t\t\t\t   OV8865_CROP_START_Y_H(mode->crop_start_y));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ov8865_write(sensor, OV8865_CROP_START_Y_L_REG,\n\t\t\t\t   OV8865_CROP_START_Y_L(mode->crop_start_y));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\n\t\tret = ov8865_write(sensor, OV8865_OFFSET_Y_H_REG,\n\t\t\t\t   OV8865_OFFSET_Y_H(mode->offset_y));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ov8865_write(sensor, OV8865_OFFSET_Y_L_REG,\n\t\t\t\t   OV8865_OFFSET_Y_L(mode->offset_y));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\n\t\tret = ov8865_write(sensor, OV8865_CROP_END_Y_H_REG,\n\t\t\t\t   OV8865_CROP_END_Y_H(mode->crop_end_y));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ov8865_write(sensor, OV8865_CROP_END_Y_L_REG,\n\t\t\t\t   OV8865_CROP_END_Y_L(mode->crop_end_y));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\n\tret = ov8865_write(sensor, OV8865_VFIFO_READ_START_H_REG,\n\t\t\t   OV8865_VFIFO_READ_START_H(mode->vfifo_read_start));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_VFIFO_READ_START_L_REG,\n\t\t\t   OV8865_VFIFO_READ_START_L(mode->vfifo_read_start));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_ABLC_NUM_REG,\n\t\t\t   OV8865_ABLC_NUM(mode->ablc_num));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_ZLINE_NUM_REG,\n\t\t\t   OV8865_ZLINE_NUM(mode->zline_num));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov8865_mode_binning_configure(sensor, mode);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov8865_mode_black_level_configure(sensor, mode);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov8865_mode_pll1_configure(sensor, mode, mbus_code);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_mode_pll2_configure(sensor, mode);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_mode_sclk_configure(sensor, mode);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tif (mode->register_values) {\n\t\tret = ov8865_write_sequence(sensor, mode->register_values,\n\t\t\t\t\t    mode->register_values_count);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned long ov8865_mode_mipi_clk_rate(struct ov8865_sensor *sensor,\n\t\t\t\t\t       const struct ov8865_mode *mode)\n{\n\tconst struct ov8865_pll1_config *config;\n\tunsigned long pll1_rate;\n\n\tconfig = sensor->pll_configs->pll1_config;\n\n\tpll1_rate = ov8865_mode_pll1_rate(sensor, mode);\n\n\treturn pll1_rate / config->m_div / 2;\n}\n\n \n\nstatic int ov8865_exposure_configure(struct ov8865_sensor *sensor, u32 exposure)\n{\n\tint ret;\n\n\t \n\texposure *= 16;\n\n\tret = ov8865_write(sensor, OV8865_EXPOSURE_CTRL_HH_REG,\n\t\t\t   OV8865_EXPOSURE_CTRL_HH(exposure));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov8865_write(sensor, OV8865_EXPOSURE_CTRL_H_REG,\n\t\t\t   OV8865_EXPOSURE_CTRL_H(exposure));\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov8865_write(sensor, OV8865_EXPOSURE_CTRL_L_REG,\n\t\t\t    OV8865_EXPOSURE_CTRL_L(exposure));\n}\n\n \n\nstatic int ov8865_analog_gain_configure(struct ov8865_sensor *sensor, u32 gain)\n{\n\tint ret;\n\n\tret = ov8865_write(sensor, OV8865_GAIN_CTRL_H_REG,\n\t\t\t   OV8865_GAIN_CTRL_H(gain));\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov8865_write(sensor, OV8865_GAIN_CTRL_L_REG,\n\t\t\t    OV8865_GAIN_CTRL_L(gain));\n}\n\n \n\nstatic int ov8865_red_balance_configure(struct ov8865_sensor *sensor,\n\t\t\t\t\tu32 red_balance)\n{\n\tint ret;\n\n\tret = ov8865_write(sensor, OV8865_ISP_GAIN_RED_H_REG,\n\t\t\t   OV8865_ISP_GAIN_RED_H(red_balance));\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov8865_write(sensor, OV8865_ISP_GAIN_RED_L_REG,\n\t\t\t    OV8865_ISP_GAIN_RED_L(red_balance));\n}\n\nstatic int ov8865_blue_balance_configure(struct ov8865_sensor *sensor,\n\t\t\t\t\t u32 blue_balance)\n{\n\tint ret;\n\n\tret = ov8865_write(sensor, OV8865_ISP_GAIN_BLUE_H_REG,\n\t\t\t   OV8865_ISP_GAIN_BLUE_H(blue_balance));\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov8865_write(sensor, OV8865_ISP_GAIN_BLUE_L_REG,\n\t\t\t    OV8865_ISP_GAIN_BLUE_L(blue_balance));\n}\n\n \n\nstatic int ov8865_flip_vert_configure(struct ov8865_sensor *sensor, bool enable)\n{\n\tu8 bits = OV8865_FORMAT1_FLIP_VERT_ISP_EN |\n\t\t  OV8865_FORMAT1_FLIP_VERT_SENSOR_EN;\n\n\treturn ov8865_update_bits(sensor, OV8865_FORMAT1_REG, bits,\n\t\t\t\t  enable ? bits : 0);\n}\n\nstatic int ov8865_flip_horz_configure(struct ov8865_sensor *sensor, bool enable)\n{\n\tu8 bits = OV8865_FORMAT2_FLIP_HORZ_ISP_EN |\n\t\t  OV8865_FORMAT2_FLIP_HORZ_SENSOR_EN;\n\n\treturn ov8865_update_bits(sensor, OV8865_FORMAT2_REG, bits,\n\t\t\t\t  enable ? bits : 0);\n}\n\n \n\nstatic int ov8865_test_pattern_configure(struct ov8865_sensor *sensor,\n\t\t\t\t\t unsigned int index)\n{\n\tif (index >= ARRAY_SIZE(ov8865_test_pattern_bits))\n\t\treturn -EINVAL;\n\n\treturn ov8865_write(sensor, OV8865_PRE_CTRL0_REG,\n\t\t\t    ov8865_test_pattern_bits[index]);\n}\n\n \n\nstatic int ov8865_vts_configure(struct ov8865_sensor *sensor, u32 vblank)\n{\n\tu16 vts = sensor->state.mode->output_size_y + vblank;\n\tint ret;\n\n\tret = ov8865_write(sensor, OV8865_VTS_H_REG, OV8865_VTS_H(vts));\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov8865_write(sensor, OV8865_VTS_L_REG, OV8865_VTS_L(vts));\n}\n\n \n\nstatic int ov8865_state_mipi_configure(struct ov8865_sensor *sensor,\n\t\t\t\t       const struct ov8865_mode *mode,\n\t\t\t\t       u32 mbus_code)\n{\n\tstruct ov8865_ctrls *ctrls = &sensor->ctrls;\n\tstruct v4l2_mbus_config_mipi_csi2 *bus_mipi_csi2 =\n\t\t&sensor->endpoint.bus.mipi_csi2;\n\tunsigned long mipi_clk_rate;\n\tunsigned int bits_per_sample;\n\tunsigned int lanes_count;\n\tunsigned int i, j;\n\ts64 mipi_pixel_rate;\n\n\tmipi_clk_rate = ov8865_mode_mipi_clk_rate(sensor, mode);\n\tif (!mipi_clk_rate)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(ov8865_link_freq_menu); i++) {\n\t\ts64 freq = ov8865_link_freq_menu[i];\n\n\t\tif (freq == mipi_clk_rate)\n\t\t\tbreak;\n\t}\n\n\tfor (j = 0; j < sensor->endpoint.nr_of_link_frequencies; j++) {\n\t\tu64 freq = sensor->endpoint.link_frequencies[j];\n\n\t\tif (freq == mipi_clk_rate)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(ov8865_link_freq_menu)) {\n\t\tdev_err(sensor->dev,\n\t\t\t\"failed to find %lu clk rate in link freq\\n\",\n\t\t\tmipi_clk_rate);\n\t} else if (j == sensor->endpoint.nr_of_link_frequencies) {\n\t\tdev_err(sensor->dev,\n\t\t\t\"failed to find %lu clk rate in endpoint link-frequencies\\n\",\n\t\t\tmipi_clk_rate);\n\t} else {\n\t\t__v4l2_ctrl_s_ctrl(ctrls->link_freq, i);\n\t}\n\n\tswitch (mbus_code) {\n\tcase MEDIA_BUS_FMT_SBGGR10_1X10:\n\t\tbits_per_sample = 10;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tlanes_count = bus_mipi_csi2->num_data_lanes;\n\tmipi_pixel_rate = mipi_clk_rate * 2 * lanes_count / bits_per_sample;\n\n\t__v4l2_ctrl_s_ctrl_int64(ctrls->pixel_rate, mipi_pixel_rate);\n\n\treturn 0;\n}\n\nstatic int ov8865_state_configure(struct ov8865_sensor *sensor,\n\t\t\t\t  const struct ov8865_mode *mode,\n\t\t\t\t  u32 mbus_code)\n{\n\tint ret;\n\n\tif (sensor->state.streaming)\n\t\treturn -EBUSY;\n\n\t \n\tif (pm_runtime_enabled(sensor->dev) &&\n\t    !pm_runtime_suspended(sensor->dev)) {\n\t\tret = ov8865_mode_configure(sensor, mode, mbus_code);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = ov8865_state_mipi_configure(sensor, mode, mbus_code);\n\tif (ret)\n\t\treturn ret;\n\n\tsensor->state.mode = mode;\n\tsensor->state.mbus_code = mbus_code;\n\n\treturn 0;\n}\n\nstatic int ov8865_state_init(struct ov8865_sensor *sensor)\n{\n\treturn ov8865_state_configure(sensor, &ov8865_modes[0],\n\t\t\t\t      ov8865_mbus_codes[0]);\n}\n\n \n\nstatic int ov8865_sensor_init(struct ov8865_sensor *sensor)\n{\n\tint ret;\n\n\tret = ov8865_sw_reset(sensor);\n\tif (ret) {\n\t\tdev_err(sensor->dev, \"failed to perform sw reset\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ov8865_sw_standby(sensor, 1);\n\tif (ret) {\n\t\tdev_err(sensor->dev, \"failed to set sensor standby\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ov8865_chip_id_check(sensor);\n\tif (ret) {\n\t\tdev_err(sensor->dev, \"failed to check sensor chip id\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ov8865_write_sequence(sensor, ov8865_init_sequence,\n\t\t\t\t    ARRAY_SIZE(ov8865_init_sequence));\n\tif (ret) {\n\t\tdev_err(sensor->dev, \"failed to write init sequence\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ov8865_charge_pump_configure(sensor);\n\tif (ret) {\n\t\tdev_err(sensor->dev, \"failed to configure pad\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ov8865_mipi_configure(sensor);\n\tif (ret) {\n\t\tdev_err(sensor->dev, \"failed to configure MIPI\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ov8865_isp_configure(sensor);\n\tif (ret) {\n\t\tdev_err(sensor->dev, \"failed to configure ISP\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ov8865_black_level_configure(sensor);\n\tif (ret) {\n\t\tdev_err(sensor->dev, \"failed to configure black level\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = ov8865_state_configure(sensor, sensor->state.mode,\n\t\t\t\t     sensor->state.mbus_code);\n\tif (ret) {\n\t\tdev_err(sensor->dev, \"failed to configure state\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov8865_sensor_power(struct ov8865_sensor *sensor, bool on)\n{\n\t \n\tint ret = 0;\n\n\tif (on) {\n\t\tgpiod_set_value_cansleep(sensor->reset, 1);\n\t\tgpiod_set_value_cansleep(sensor->powerdown, 1);\n\n\t\tret = regulator_enable(sensor->dovdd);\n\t\tif (ret) {\n\t\t\tdev_err(sensor->dev,\n\t\t\t\t\"failed to enable DOVDD regulator\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regulator_enable(sensor->avdd);\n\t\tif (ret) {\n\t\t\tdev_err(sensor->dev,\n\t\t\t\t\"failed to enable AVDD regulator\\n\");\n\t\t\tgoto disable_dovdd;\n\t\t}\n\n\t\tret = regulator_enable(sensor->dvdd);\n\t\tif (ret) {\n\t\t\tdev_err(sensor->dev,\n\t\t\t\t\"failed to enable DVDD regulator\\n\");\n\t\t\tgoto disable_avdd;\n\t\t}\n\n\t\tret = clk_prepare_enable(sensor->extclk);\n\t\tif (ret) {\n\t\t\tdev_err(sensor->dev, \"failed to enable EXTCLK clock\\n\");\n\t\t\tgoto disable_dvdd;\n\t\t}\n\n\t\tgpiod_set_value_cansleep(sensor->reset, 0);\n\t\tgpiod_set_value_cansleep(sensor->powerdown, 0);\n\n\t\t \n\t\tusleep_range(10000, 12000);\n\t} else {\n\t\tgpiod_set_value_cansleep(sensor->powerdown, 1);\n\t\tgpiod_set_value_cansleep(sensor->reset, 1);\n\n\t\tclk_disable_unprepare(sensor->extclk);\n\ndisable_dvdd:\n\t\tregulator_disable(sensor->dvdd);\ndisable_avdd:\n\t\tregulator_disable(sensor->avdd);\ndisable_dovdd:\n\t\tregulator_disable(sensor->dovdd);\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic int ov8865_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *subdev = ov8865_ctrl_subdev(ctrl);\n\tstruct ov8865_sensor *sensor = ov8865_subdev_sensor(subdev);\n\tunsigned int index;\n\tint ret;\n\n\t \n\tif (ctrl->id == V4L2_CID_VBLANK) {\n\t\tint exposure_max;\n\n\t\texposure_max = sensor->state.mode->output_size_y + ctrl->val -\n\t\t\t       OV8865_INTEGRATION_TIME_MARGIN;\n\t\t__v4l2_ctrl_modify_range(sensor->ctrls.exposure,\n\t\t\t\t\t sensor->ctrls.exposure->minimum,\n\t\t\t\t\t exposure_max,\n\t\t\t\t\t sensor->ctrls.exposure->step,\n\t\t\t\t\t min(sensor->ctrls.exposure->val,\n\t\t\t\t\t     exposure_max));\n\t}\n\n\t \n\tif (pm_runtime_suspended(sensor->dev))\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE:\n\t\tret = ov8865_exposure_configure(sensor, ctrl->val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase V4L2_CID_ANALOGUE_GAIN:\n\t\tret = ov8865_analog_gain_configure(sensor, ctrl->val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase V4L2_CID_RED_BALANCE:\n\t\treturn ov8865_red_balance_configure(sensor, ctrl->val);\n\tcase V4L2_CID_BLUE_BALANCE:\n\t\treturn ov8865_blue_balance_configure(sensor, ctrl->val);\n\tcase V4L2_CID_HFLIP:\n\t\treturn ov8865_flip_horz_configure(sensor, !!ctrl->val);\n\tcase V4L2_CID_VFLIP:\n\t\treturn ov8865_flip_vert_configure(sensor, !!ctrl->val);\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tindex = (unsigned int)ctrl->val;\n\t\treturn ov8865_test_pattern_configure(sensor, index);\n\tcase V4L2_CID_VBLANK:\n\t\treturn ov8865_vts_configure(sensor, ctrl->val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops ov8865_ctrl_ops = {\n\t.s_ctrl\t\t\t= ov8865_s_ctrl,\n};\n\nstatic int ov8865_ctrls_init(struct ov8865_sensor *sensor)\n{\n\tstruct ov8865_ctrls *ctrls = &sensor->ctrls;\n\tstruct v4l2_ctrl_handler *handler = &ctrls->handler;\n\tconst struct v4l2_ctrl_ops *ops = &ov8865_ctrl_ops;\n\tconst struct ov8865_mode *mode = &ov8865_modes[0];\n\tstruct v4l2_fwnode_device_properties props;\n\tunsigned int vblank_max, vblank_def;\n\tunsigned int hblank;\n\tint ret;\n\n\tv4l2_ctrl_handler_init(handler, 32);\n\n\t \n\thandler->lock = &sensor->mutex;\n\n\t \n\n\tctrls->exposure = v4l2_ctrl_new_std(handler, ops, V4L2_CID_EXPOSURE, 2,\n\t\t\t\t\t    65535, 1, 32);\n\n\t \n\n\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_ANALOGUE_GAIN, 128, 2048, 128,\n\t\t\t  128);\n\n\t \n\n\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_RED_BALANCE, 1, 32767, 1,\n\t\t\t  1024);\n\n\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_BLUE_BALANCE, 1, 32767, 1,\n\t\t\t  1024);\n\n\t \n\n\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_HFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_VFLIP, 0, 1, 1, 0);\n\n\t \n\n\tv4l2_ctrl_new_std_menu_items(handler, ops, V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(ov8865_test_pattern_menu) - 1,\n\t\t\t\t     0, 0, ov8865_test_pattern_menu);\n\n\t \n\thblank = mode->hts - mode->output_size_x;\n\tctrls->hblank = v4l2_ctrl_new_std(handler, ops, V4L2_CID_HBLANK, hblank,\n\t\t\t\t\t  hblank, 1, hblank);\n\n\tif (ctrls->hblank)\n\t\tctrls->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tvblank_max = OV8865_TIMING_MAX_VTS - mode->output_size_y;\n\tvblank_def = mode->vts - mode->output_size_y;\n\tctrls->vblank = v4l2_ctrl_new_std(handler, ops, V4L2_CID_VBLANK,\n\t\t\t\t\t  OV8865_TIMING_MIN_VTS, vblank_max, 1,\n\t\t\t\t\t  vblank_def);\n\n\t \n\n\tctrls->link_freq =\n\t\tv4l2_ctrl_new_int_menu(handler, NULL, V4L2_CID_LINK_FREQ,\n\t\t\t\t       ARRAY_SIZE(ov8865_link_freq_menu) - 1,\n\t\t\t\t       0, ov8865_link_freq_menu);\n\n\tctrls->pixel_rate =\n\t\tv4l2_ctrl_new_std(handler, NULL, V4L2_CID_PIXEL_RATE, 1,\n\t\t\t\t  INT_MAX, 1, 1);\n\n\t \n\tret = v4l2_fwnode_device_parse(sensor->dev, &props);\n\tif (ret)\n\t\tgoto error_ctrls;\n\n\tret = v4l2_ctrl_new_fwnode_properties(handler, ops, &props);\n\tif (ret)\n\t\tgoto error_ctrls;\n\n\tif (handler->error) {\n\t\tret = handler->error;\n\t\tgoto error_ctrls;\n\t}\n\n\tctrls->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\tctrls->pixel_rate->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tsensor->subdev.ctrl_handler = handler;\n\n\treturn 0;\n\nerror_ctrls:\n\tv4l2_ctrl_handler_free(handler);\n\n\treturn ret;\n}\n\n \n\nstatic int ov8865_s_stream(struct v4l2_subdev *subdev, int enable)\n{\n\tstruct ov8865_sensor *sensor = ov8865_subdev_sensor(subdev);\n\tstruct ov8865_state *state = &sensor->state;\n\tint ret;\n\n\tif (enable) {\n\t\tret = pm_runtime_resume_and_get(sensor->dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&sensor->mutex);\n\tret = ov8865_sw_standby(sensor, !enable);\n\tmutex_unlock(&sensor->mutex);\n\n\tif (ret)\n\t\treturn ret;\n\n\tstate->streaming = !!enable;\n\n\tif (!enable)\n\t\tpm_runtime_put(sensor->dev);\n\n\treturn 0;\n}\n\nstatic int ov8865_g_frame_interval(struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_subdev_frame_interval *interval)\n{\n\tstruct ov8865_sensor *sensor = ov8865_subdev_sensor(subdev);\n\tconst struct ov8865_mode *mode;\n\tunsigned int framesize;\n\tunsigned int fps;\n\n\tmutex_lock(&sensor->mutex);\n\n\tmode = sensor->state.mode;\n\tframesize = mode->hts * (mode->output_size_y +\n\t\t\t\t sensor->ctrls.vblank->val);\n\tfps = DIV_ROUND_CLOSEST(sensor->ctrls.pixel_rate->val, framesize);\n\n\tinterval->interval.numerator = 1;\n\tinterval->interval.denominator = fps;\n\n\tmutex_unlock(&sensor->mutex);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops ov8865_subdev_video_ops = {\n\t.s_stream\t\t= ov8865_s_stream,\n\t.g_frame_interval\t= ov8865_g_frame_interval,\n\t.s_frame_interval\t= ov8865_g_frame_interval,\n};\n\n \n\nstatic int ov8865_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code_enum)\n{\n\tif (code_enum->index >= ARRAY_SIZE(ov8865_mbus_codes))\n\t\treturn -EINVAL;\n\n\tcode_enum->code = ov8865_mbus_codes[code_enum->index];\n\n\treturn 0;\n}\n\nstatic void ov8865_mbus_format_fill(struct v4l2_mbus_framefmt *mbus_format,\n\t\t\t\t    u32 mbus_code,\n\t\t\t\t    const struct ov8865_mode *mode)\n{\n\tmbus_format->width = mode->output_size_x;\n\tmbus_format->height = mode->output_size_y;\n\tmbus_format->code = mbus_code;\n\n\tmbus_format->field = V4L2_FIELD_NONE;\n\tmbus_format->colorspace = V4L2_COLORSPACE_RAW;\n\tmbus_format->ycbcr_enc =\n\t\tV4L2_MAP_YCBCR_ENC_DEFAULT(mbus_format->colorspace);\n\tmbus_format->quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\tmbus_format->xfer_func =\n\t\tV4L2_MAP_XFER_FUNC_DEFAULT(mbus_format->colorspace);\n}\n\nstatic int ov8865_get_fmt(struct v4l2_subdev *subdev,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct ov8865_sensor *sensor = ov8865_subdev_sensor(subdev);\n\tstruct v4l2_mbus_framefmt *mbus_format = &format->format;\n\n\tmutex_lock(&sensor->mutex);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\t*mbus_format = *v4l2_subdev_get_try_format(subdev, sd_state,\n\t\t\t\t\t\t\t   format->pad);\n\telse\n\t\tov8865_mbus_format_fill(mbus_format, sensor->state.mbus_code,\n\t\t\t\t\tsensor->state.mode);\n\n\tmutex_unlock(&sensor->mutex);\n\n\treturn 0;\n}\n\nstatic int ov8865_set_fmt(struct v4l2_subdev *subdev,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct ov8865_sensor *sensor = ov8865_subdev_sensor(subdev);\n\tstruct v4l2_mbus_framefmt *mbus_format = &format->format;\n\tconst struct ov8865_mode *mode;\n\tu32 mbus_code = 0;\n\tunsigned int hblank;\n\tunsigned int index;\n\tint exposure_max;\n\tint ret = 0;\n\n\tmutex_lock(&sensor->mutex);\n\n\tif (sensor->state.streaming) {\n\t\tret = -EBUSY;\n\t\tgoto complete;\n\t}\n\n\t \n\tfor (index = 0; index < ARRAY_SIZE(ov8865_mbus_codes); index++) {\n\t\tif (ov8865_mbus_codes[index] == mbus_format->code) {\n\t\t\tmbus_code = mbus_format->code;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!mbus_code)\n\t\tmbus_code = ov8865_mbus_codes[0];\n\n\t \n\tmode = v4l2_find_nearest_size(ov8865_modes, ARRAY_SIZE(ov8865_modes),\n\t\t\t\t      output_size_x, output_size_y,\n\t\t\t\t      mbus_format->width, mbus_format->height);\n\tif (!mode) {\n\t\tret = -EINVAL;\n\t\tgoto complete;\n\t}\n\n\tov8865_mbus_format_fill(mbus_format, mbus_code, mode);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\t*v4l2_subdev_get_try_format(subdev, sd_state, format->pad) =\n\t\t\t*mbus_format;\n\telse if (sensor->state.mode != mode ||\n\t\t sensor->state.mbus_code != mbus_code)\n\t\tret = ov8865_state_configure(sensor, mode, mbus_code);\n\n\t__v4l2_ctrl_modify_range(sensor->ctrls.vblank, OV8865_TIMING_MIN_VTS,\n\t\t\t\t OV8865_TIMING_MAX_VTS - mode->output_size_y,\n\t\t\t\t 1, mode->vts - mode->output_size_y);\n\n\thblank = mode->hts - mode->output_size_x;\n\t__v4l2_ctrl_modify_range(sensor->ctrls.hblank, hblank, hblank, 1,\n\t\t\t\t hblank);\n\n\texposure_max = mode->vts - OV8865_INTEGRATION_TIME_MARGIN;\n\t__v4l2_ctrl_modify_range(sensor->ctrls.exposure,\n\t\t\t\t sensor->ctrls.exposure->minimum, exposure_max,\n\t\t\t\t sensor->ctrls.exposure->step,\n\t\t\t\t min(sensor->ctrls.exposure->val,\n\t\t\t\t     exposure_max));\n\ncomplete:\n\tmutex_unlock(&sensor->mutex);\n\n\treturn ret;\n}\n\nstatic int ov8865_enum_frame_size(struct v4l2_subdev *subdev,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *size_enum)\n{\n\tconst struct ov8865_mode *mode;\n\n\tif (size_enum->index >= ARRAY_SIZE(ov8865_modes))\n\t\treturn -EINVAL;\n\n\tmode = &ov8865_modes[size_enum->index];\n\n\tsize_enum->min_width = size_enum->max_width = mode->output_size_x;\n\tsize_enum->min_height = size_enum->max_height = mode->output_size_y;\n\n\treturn 0;\n}\n\nstatic void\n__ov8865_get_pad_crop(struct ov8865_sensor *sensor,\n\t\t      struct v4l2_subdev_state *state, unsigned int pad,\n\t\t      enum v4l2_subdev_format_whence which, struct v4l2_rect *r)\n{\n\tconst struct ov8865_mode *mode = sensor->state.mode;\n\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\t*r = *v4l2_subdev_get_try_crop(&sensor->subdev, state, pad);\n\t\tbreak;\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\tr->height = mode->output_size_y;\n\t\tr->width = mode->output_size_x;\n\t\tr->top = (OV8865_NATIVE_HEIGHT - mode->output_size_y) / 2;\n\t\tr->left = (OV8865_NATIVE_WIDTH - mode->output_size_x) / 2;\n\t\tbreak;\n\t}\n}\n\nstatic int ov8865_get_selection(struct v4l2_subdev *subdev,\n\t\t\t\tstruct v4l2_subdev_state *state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct ov8865_sensor *sensor = ov8865_subdev_sensor(subdev);\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tmutex_lock(&sensor->mutex);\n\t\t__ov8865_get_pad_crop(sensor, state, sel->pad,\n\t\t\t\t      sel->which, &sel->r);\n\t\tmutex_unlock(&sensor->mutex);\n\t\tbreak;\n\tcase V4L2_SEL_TGT_NATIVE_SIZE:\n\t\tsel->r.top = 0;\n\t\tsel->r.left = 0;\n\t\tsel->r.width = OV8865_NATIVE_WIDTH;\n\t\tsel->r.height = OV8865_NATIVE_HEIGHT;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tsel->r.top = OV8865_ACTIVE_START_TOP;\n\t\tsel->r.left = OV8865_ACTIVE_START_LEFT;\n\t\tsel->r.width = OV8865_ACTIVE_WIDTH;\n\t\tsel->r.height = OV8865_ACTIVE_HEIGHT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops ov8865_subdev_pad_ops = {\n\t.enum_mbus_code\t\t= ov8865_enum_mbus_code,\n\t.get_fmt\t\t= ov8865_get_fmt,\n\t.set_fmt\t\t= ov8865_set_fmt,\n\t.enum_frame_size\t= ov8865_enum_frame_size,\n\t.get_selection\t\t= ov8865_get_selection,\n\t.set_selection\t\t= ov8865_get_selection,\n};\n\nstatic const struct v4l2_subdev_ops ov8865_subdev_ops = {\n\t.video\t\t= &ov8865_subdev_video_ops,\n\t.pad\t\t= &ov8865_subdev_pad_ops,\n};\n\nstatic int ov8865_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct ov8865_sensor *sensor = ov8865_subdev_sensor(subdev);\n\tstruct ov8865_state *state = &sensor->state;\n\tint ret = 0;\n\n\tmutex_lock(&sensor->mutex);\n\n\tif (state->streaming) {\n\t\tret = ov8865_sw_standby(sensor, true);\n\t\tif (ret)\n\t\t\tgoto complete;\n\t}\n\n\tret = ov8865_sensor_power(sensor, false);\n\tif (ret)\n\t\tov8865_sw_standby(sensor, false);\n\ncomplete:\n\tmutex_unlock(&sensor->mutex);\n\n\treturn ret;\n}\n\nstatic int ov8865_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct ov8865_sensor *sensor = ov8865_subdev_sensor(subdev);\n\tstruct ov8865_state *state = &sensor->state;\n\tint ret = 0;\n\n\tmutex_lock(&sensor->mutex);\n\n\tret = ov8865_sensor_power(sensor, true);\n\tif (ret)\n\t\tgoto complete;\n\n\tret = ov8865_sensor_init(sensor);\n\tif (ret)\n\t\tgoto error_power;\n\n\tret = __v4l2_ctrl_handler_setup(&sensor->ctrls.handler);\n\tif (ret)\n\t\tgoto error_power;\n\n\tif (state->streaming) {\n\t\tret = ov8865_sw_standby(sensor, false);\n\t\tif (ret)\n\t\t\tgoto error_power;\n\t}\n\n\tgoto complete;\n\nerror_power:\n\tov8865_sensor_power(sensor, false);\n\ncomplete:\n\tmutex_unlock(&sensor->mutex);\n\n\treturn ret;\n}\n\nstatic int ov8865_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct fwnode_handle *handle;\n\tstruct ov8865_sensor *sensor;\n\tstruct v4l2_subdev *subdev;\n\tstruct media_pad *pad;\n\tunsigned int rate = 0;\n\tunsigned int i;\n\tint ret;\n\n\tsensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);\n\tif (!sensor)\n\t\treturn -ENOMEM;\n\n\tsensor->dev = dev;\n\tsensor->i2c_client = client;\n\n\t \n\n\t \n\tsensor->dvdd = devm_regulator_get(dev, \"dvdd\");\n\tif (IS_ERR(sensor->dvdd))\n\t\treturn dev_err_probe(dev, PTR_ERR(sensor->dvdd),\n\t\t\t\t     \"cannot get DVDD regulator\\n\");\n\n\t \n\tsensor->dovdd = devm_regulator_get(dev, \"dovdd\");\n\tif (IS_ERR(sensor->dovdd))\n\t\treturn dev_err_probe(dev, PTR_ERR(sensor->dovdd),\n\t\t\t\t     \"cannot get DOVDD regulator\\n\");\n\n\t \n\tsensor->avdd = devm_regulator_get(dev, \"avdd\");\n\tif (IS_ERR(sensor->avdd))\n\t\treturn dev_err_probe(dev, PTR_ERR(sensor->avdd),\n\t\t\t\t     \"cannot get AVDD (analog) regulator\\n\");\n\n\t \n\n\thandle = fwnode_graph_get_next_endpoint(dev_fwnode(dev), NULL);\n\tif (!handle)\n\t\treturn -EPROBE_DEFER;\n\n\tsensor->endpoint.bus_type = V4L2_MBUS_CSI2_DPHY;\n\n\tret = v4l2_fwnode_endpoint_alloc_parse(handle, &sensor->endpoint);\n\tfwnode_handle_put(handle);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to parse endpoint node\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\n\tsensor->powerdown = devm_gpiod_get_optional(dev, \"powerdown\",\n\t\t\t\t\t\t    GPIOD_OUT_HIGH);\n\tif (IS_ERR(sensor->powerdown)) {\n\t\tret = PTR_ERR(sensor->powerdown);\n\t\tgoto error_endpoint;\n\t}\n\n\tsensor->reset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(sensor->reset)) {\n\t\tret = PTR_ERR(sensor->reset);\n\t\tgoto error_endpoint;\n\t}\n\n\t \n\n\tsensor->extclk = devm_clk_get(dev, NULL);\n\tif (PTR_ERR(sensor->extclk) == -ENOENT) {\n\t\tdev_info(dev, \"no external clock found, continuing...\\n\");\n\t\tsensor->extclk = NULL;\n\t} else if (IS_ERR(sensor->extclk)) {\n\t\tdev_err(dev, \"failed to get external clock\\n\");\n\t\tret = PTR_ERR(sensor->extclk);\n\t\tgoto error_endpoint;\n\t}\n\n\t \n\tret = fwnode_property_read_u32(dev_fwnode(dev), \"clock-frequency\",\n\t\t\t\t       &rate);\n\tif (!ret && sensor->extclk) {\n\t\tret = clk_set_rate(sensor->extclk, rate);\n\t\tif (ret) {\n\t\t\tdev_err_probe(dev, ret, \"failed to set clock rate\\n\");\n\t\t\tgoto error_endpoint;\n\t\t}\n\t} else if (ret && !sensor->extclk) {\n\t\tdev_err_probe(dev, ret, \"invalid clock config\\n\");\n\t\tgoto error_endpoint;\n\t}\n\n\tsensor->extclk_rate = rate ? rate : clk_get_rate(sensor->extclk);\n\n\tfor (i = 0; i < ARRAY_SIZE(supported_extclk_rates); i++) {\n\t\tif (sensor->extclk_rate == supported_extclk_rates[i])\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(supported_extclk_rates)) {\n\t\tdev_err(dev, \"clock rate %lu Hz is unsupported\\n\",\n\t\t\tsensor->extclk_rate);\n\t\tret = -EINVAL;\n\t\tgoto error_endpoint;\n\t}\n\n\tsensor->pll_configs = ov8865_pll_configs[i];\n\n\t \n\n\tsubdev = &sensor->subdev;\n\tv4l2_i2c_subdev_init(subdev, client, &ov8865_subdev_ops);\n\n\tsubdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsubdev->entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\n\tpad = &sensor->pad;\n\tpad->flags = MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&subdev->entity, 1, pad);\n\tif (ret)\n\t\tgoto error_entity;\n\n\t \n\n\tmutex_init(&sensor->mutex);\n\n\t \n\n\tret = ov8865_ctrls_init(sensor);\n\tif (ret)\n\t\tgoto error_mutex;\n\n\tmutex_lock(&sensor->mutex);\n\tret = ov8865_state_init(sensor);\n\tmutex_unlock(&sensor->mutex);\n\tif (ret)\n\t\tgoto error_ctrls;\n\n\t \n\n\tpm_runtime_set_suspended(sensor->dev);\n\tpm_runtime_enable(sensor->dev);\n\n\t \n\n\tret = v4l2_async_register_subdev_sensor(subdev);\n\tif (ret)\n\t\tgoto error_pm;\n\n\treturn 0;\n\nerror_pm:\n\tpm_runtime_disable(sensor->dev);\n\nerror_ctrls:\n\tv4l2_ctrl_handler_free(&sensor->ctrls.handler);\n\nerror_mutex:\n\tmutex_destroy(&sensor->mutex);\n\nerror_entity:\n\tmedia_entity_cleanup(&sensor->subdev.entity);\n\nerror_endpoint:\n\tv4l2_fwnode_endpoint_free(&sensor->endpoint);\n\n\treturn ret;\n}\n\nstatic void ov8865_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct ov8865_sensor *sensor = ov8865_subdev_sensor(subdev);\n\n\tv4l2_async_unregister_subdev(subdev);\n\tpm_runtime_disable(sensor->dev);\n\tv4l2_ctrl_handler_free(&sensor->ctrls.handler);\n\tmutex_destroy(&sensor->mutex);\n\tmedia_entity_cleanup(&subdev->entity);\n\n\tv4l2_fwnode_endpoint_free(&sensor->endpoint);\n}\n\nstatic const struct dev_pm_ops ov8865_pm_ops = {\n\tSET_RUNTIME_PM_OPS(ov8865_suspend, ov8865_resume, NULL)\n};\n\nstatic const struct acpi_device_id ov8865_acpi_match[] = {\n\t{\"INT347A\"},\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, ov8865_acpi_match);\n\nstatic const struct of_device_id ov8865_of_match[] = {\n\t{ .compatible = \"ovti,ov8865\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ov8865_of_match);\n\nstatic struct i2c_driver ov8865_driver = {\n\t.driver = {\n\t\t.name = \"ov8865\",\n\t\t.of_match_table = ov8865_of_match,\n\t\t.acpi_match_table = ov8865_acpi_match,\n\t\t.pm = &ov8865_pm_ops,\n\t},\n\t.probe = ov8865_probe,\n\t.remove = ov8865_remove,\n};\n\nmodule_i2c_driver(ov8865_driver);\n\nMODULE_AUTHOR(\"Paul Kocialkowski <paul.kocialkowski@bootlin.com>\");\nMODULE_DESCRIPTION(\"V4L2 driver for the OmniVision OV8865 image sensor\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}