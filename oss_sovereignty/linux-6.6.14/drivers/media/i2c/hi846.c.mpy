{
  "module_name": "hi846.c",
  "hash_id": "64779b6b2a35402e96f23d7852d36bac032c4e42e18e8c1beee5f653fbef2177",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/hi846.c",
  "human_readable_source": "\n\n\n#include <asm/unaligned.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n\n#define HI846_MEDIA_BUS_FORMAT\t\tMEDIA_BUS_FMT_SGBRG10_1X10\n#define HI846_RGB_DEPTH\t\t\t10\n\n \n#define HI846_REG_FLL\t\t\t0x0006\n#define HI846_FLL_MAX\t\t\t0xffff\n\n \n#define HI846_REG_LLP\t\t\t0x0008\n#define HI846_LINE_LENGTH\t\t3800\n\n#define HI846_REG_BINNING_MODE\t\t0x000c\n\n#define HI846_REG_IMAGE_ORIENTATION\t0x000e\n\n#define HI846_REG_UNKNOWN_0022\t\t0x0022\n\n#define HI846_REG_Y_ADDR_START_VACT_H\t0x0026\n#define HI846_REG_Y_ADDR_START_VACT_L\t0x0027\n#define HI846_REG_UNKNOWN_0028\t\t0x0028\n\n#define HI846_REG_Y_ADDR_END_VACT_H\t0x002c\n#define HI846_REG_Y_ADDR_END_VACT_L\t0x002d\n\n#define HI846_REG_Y_ODD_INC_FOBP\t0x002e\n#define HI846_REG_Y_EVEN_INC_FOBP\t0x002f\n\n#define HI846_REG_Y_ODD_INC_VACT\t0x0032\n#define HI846_REG_Y_EVEN_INC_VACT\t0x0033\n\n#define HI846_REG_GROUPED_PARA_HOLD\t0x0046\n\n#define HI846_REG_TG_ENABLE\t\t0x004c\n\n#define HI846_REG_UNKNOWN_005C\t\t0x005c\n\n#define HI846_REG_UNKNOWN_006A\t\t0x006a\n\n \n#define HI846_REG_EXPOSURE\t\t0x0074\n#define HI846_EXPOSURE_MIN\t\t6\n#define HI846_EXPOSURE_MAX_MARGIN\t2\n#define HI846_EXPOSURE_STEP\t\t1\n\n \n#define HI846_REG_ANALOG_GAIN\t\t0x0077\n#define HI846_ANAL_GAIN_MIN\t\t0\n#define HI846_ANAL_GAIN_MAX\t\t240\n#define HI846_ANAL_GAIN_STEP\t\t8\n\n \n#define HI846_REG_MWB_GR_GAIN_H\t\t0x0078\n#define HI846_REG_MWB_GR_GAIN_L\t\t0x0079\n#define HI846_REG_MWB_GB_GAIN_H\t\t0x007a\n#define HI846_REG_MWB_GB_GAIN_L\t\t0x007b\n#define HI846_REG_MWB_R_GAIN_H\t\t0x007c\n#define HI846_REG_MWB_R_GAIN_L\t\t0x007d\n#define HI846_REG_MWB_B_GAIN_H\t\t0x007e\n#define HI846_REG_MWB_B_GAIN_L\t\t0x007f\n#define HI846_DGTL_GAIN_MIN\t\t512\n#define HI846_DGTL_GAIN_MAX\t\t8191\n#define HI846_DGTL_GAIN_STEP\t\t1\n#define HI846_DGTL_GAIN_DEFAULT\t\t512\n\n#define HI846_REG_X_ADDR_START_HACT_H\t0x0120\n#define HI846_REG_X_ADDR_END_HACT_H\t0x0122\n\n#define HI846_REG_UNKNOWN_012A\t\t0x012a\n\n#define HI846_REG_UNKNOWN_0200\t\t0x0200\n\n#define HI846_REG_UNKNOWN_021C\t\t0x021c\n#define HI846_REG_UNKNOWN_021E\t\t0x021e\n\n#define HI846_REG_UNKNOWN_0402\t\t0x0402\n#define HI846_REG_UNKNOWN_0404\t\t0x0404\n#define HI846_REG_UNKNOWN_0408\t\t0x0408\n#define HI846_REG_UNKNOWN_0410\t\t0x0410\n#define HI846_REG_UNKNOWN_0412\t\t0x0412\n#define HI846_REG_UNKNOWN_0414\t\t0x0414\n\n#define HI846_REG_UNKNOWN_0418\t\t0x0418\n\n#define HI846_REG_UNKNOWN_051E\t\t0x051e\n\n \n#define HI846_REG_X_START_H\t\t0x0804\n#define HI846_REG_X_START_L\t\t0x0805\n\n \n#define HI846_REG_UNKNOWN_0900\t\t0x0900\n#define HI846_REG_MIPI_TX_OP_EN\t\t0x0901\n#define HI846_REG_MIPI_TX_OP_MODE\t0x0902\n#define HI846_RAW8\t\t\tBIT(5)\n\n#define HI846_REG_UNKNOWN_090C\t\t0x090c\n#define HI846_REG_UNKNOWN_090E\t\t0x090e\n\n#define HI846_REG_UNKNOWN_0914\t\t0x0914\n#define HI846_REG_TLPX\t\t\t0x0915\n#define HI846_REG_TCLK_PREPARE\t\t0x0916\n#define HI846_REG_TCLK_ZERO\t\t0x0917\n#define HI846_REG_UNKNOWN_0918\t\t0x0918\n#define HI846_REG_THS_PREPARE\t\t0x0919\n#define HI846_REG_THS_ZERO\t\t0x091a\n#define HI846_REG_THS_TRAIL\t\t0x091b\n#define HI846_REG_TCLK_POST\t\t0x091c\n#define HI846_REG_TCLK_TRAIL_MIN\t0x091d\n#define HI846_REG_UNKNOWN_091E\t\t0x091e\n\n#define HI846_REG_UNKNOWN_0954\t\t0x0954\n#define HI846_REG_UNKNOWN_0956\t\t0x0956\n#define HI846_REG_UNKNOWN_0958\t\t0x0958\n#define HI846_REG_UNKNOWN_095A\t\t0x095a\n\n \n#define HI846_REG_MODE_SELECT\t\t0x0a00\n#define HI846_MODE_STANDBY\t\t0x00\n#define HI846_MODE_STREAMING\t\t0x01\n#define HI846_REG_FAST_STANDBY_MODE\t0x0a02\n#define HI846_REG_ISP_EN_H\t\t0x0a04\n\n \n#define HI846_REG_ISP\t\t\t0x0a05\n#define HI846_REG_ISP_TPG_EN\t\t0x01\n#define HI846_REG_TEST_PATTERN\t\t0x020a  \n\n#define HI846_REG_UNKNOWN_0A0C\t\t0x0a0c\n\n \n#define HI846_REG_X_OUTPUT_SIZE_H\t0x0a12\n#define HI846_REG_X_OUTPUT_SIZE_L\t0x0a13\n#define HI846_REG_Y_OUTPUT_SIZE_H\t0x0a14\n#define HI846_REG_Y_OUTPUT_SIZE_L\t0x0a15\n\n \n#define HI846_REG_PEDESTAL_EN\t\t0x0a1a\n\n#define HI846_REG_UNKNOWN_0A1E\t\t0x0a1e\n\n \n#define HI846_REG_HBIN_MODE\t\t0x0a22\n\n#define HI846_REG_UNKNOWN_0A24\t\t0x0a24\n#define HI846_REG_UNKNOWN_0B02\t\t0x0b02\n#define HI846_REG_UNKNOWN_0B10\t\t0x0b10\n#define HI846_REG_UNKNOWN_0B12\t\t0x0b12\n#define HI846_REG_UNKNOWN_0B14\t\t0x0b14\n\n \n#define HI846_REG_BLC_CTL0\t\t0x0c00\n\n#define HI846_REG_UNKNOWN_0C06\t\t0x0c06\n#define HI846_REG_UNKNOWN_0C10\t\t0x0c10\n#define HI846_REG_UNKNOWN_0C12\t\t0x0c12\n#define HI846_REG_UNKNOWN_0C14\t\t0x0c14\n#define HI846_REG_UNKNOWN_0C16\t\t0x0c16\n\n#define HI846_REG_UNKNOWN_0E04\t\t0x0e04\n\n#define HI846_REG_CHIP_ID_L\t\t0x0f16\n#define HI846_REG_CHIP_ID_H\t\t0x0f17\n#define HI846_CHIP_ID_L\t\t\t0x46\n#define HI846_CHIP_ID_H\t\t\t0x08\n\n#define HI846_REG_UNKNOWN_0F04\t\t0x0f04\n#define HI846_REG_UNKNOWN_0F08\t\t0x0f08\n\n \n#define HI846_REG_PLL_CFG_MIPI2_H\t0x0f2a\n#define HI846_REG_PLL_CFG_MIPI2_L\t0x0f2b\n\n#define HI846_REG_UNKNOWN_0F30\t\t0x0f30\n#define HI846_REG_PLL_CFG_RAMP1_H\t0x0f32\n#define HI846_REG_UNKNOWN_0F36\t\t0x0f36\n#define HI846_REG_PLL_CFG_MIPI1_H\t0x0f38\n\n#define HI846_REG_UNKNOWN_2008\t\t0x2008\n#define HI846_REG_UNKNOWN_326E\t\t0x326e\n\nstruct hi846_reg {\n\tu16 address;\n\tu16 val;\n};\n\nstruct hi846_reg_list {\n\tu32 num_of_regs;\n\tconst struct hi846_reg *regs;\n};\n\nstruct hi846_mode {\n\t \n\tu32 width;\n\n\t \n\tu32 height;\n\n\t \n\tu32 llp;\n\n\t \n\tu8 link_freq_index;\n\n\tu16 fps;\n\n\t \n\tu16 frame_len;\n\n\tconst struct hi846_reg_list reg_list_config;\n\tconst struct hi846_reg_list reg_list_2lane;\n\tconst struct hi846_reg_list reg_list_4lane;\n\n\t \n\tstruct v4l2_rect crop;\n};\n\nstatic const struct hi846_reg hi846_init_2lane[] = {\n\t{HI846_REG_MODE_SELECT,\t\t0x0000},\n\t \n\t{0x2000, 0x100a},\n\t{0x2002, 0x00ff},\n\t{0x2004, 0x0007},\n\t{0x2006, 0x3fff},\n\t{0x2008, 0x3fff},\n\t{0x200a, 0xc216},\n\t{0x200c, 0x1292},\n\t{0x200e, 0xc01a},\n\t{0x2010, 0x403d},\n\t{0x2012, 0x000e},\n\t{0x2014, 0x403e},\n\t{0x2016, 0x0b80},\n\t{0x2018, 0x403f},\n\t{0x201a, 0x82ae},\n\t{0x201c, 0x1292},\n\t{0x201e, 0xc00c},\n\t{0x2020, 0x4130},\n\t{0x2022, 0x43e2},\n\t{0x2024, 0x0180},\n\t{0x2026, 0x4130},\n\t{0x2028, 0x7400},\n\t{0x202a, 0x5000},\n\t{0x202c, 0x0253},\n\t{0x202e, 0x0ad1},\n\t{0x2030, 0x2360},\n\t{0x2032, 0x0009},\n\t{0x2034, 0x5020},\n\t{0x2036, 0x000b},\n\t{0x2038, 0x0002},\n\t{0x203a, 0x0044},\n\t{0x203c, 0x0016},\n\t{0x203e, 0x1792},\n\t{0x2040, 0x7002},\n\t{0x2042, 0x154f},\n\t{0x2044, 0x00d5},\n\t{0x2046, 0x000b},\n\t{0x2048, 0x0019},\n\t{0x204a, 0x1698},\n\t{0x204c, 0x000e},\n\t{0x204e, 0x099a},\n\t{0x2050, 0x0058},\n\t{0x2052, 0x7000},\n\t{0x2054, 0x1799},\n\t{0x2056, 0x0310},\n\t{0x2058, 0x03c3},\n\t{0x205a, 0x004c},\n\t{0x205c, 0x064a},\n\t{0x205e, 0x0001},\n\t{0x2060, 0x0007},\n\t{0x2062, 0x0bc7},\n\t{0x2064, 0x0055},\n\t{0x2066, 0x7000},\n\t{0x2068, 0x1550},\n\t{0x206a, 0x158a},\n\t{0x206c, 0x0004},\n\t{0x206e, 0x1488},\n\t{0x2070, 0x7010},\n\t{0x2072, 0x1508},\n\t{0x2074, 0x0004},\n\t{0x2076, 0x0016},\n\t{0x2078, 0x03d5},\n\t{0x207a, 0x0055},\n\t{0x207c, 0x08ca},\n\t{0x207e, 0x2019},\n\t{0x2080, 0x0007},\n\t{0x2082, 0x7057},\n\t{0x2084, 0x0fc7},\n\t{0x2086, 0x5041},\n\t{0x2088, 0x12c8},\n\t{0x208a, 0x5060},\n\t{0x208c, 0x5080},\n\t{0x208e, 0x2084},\n\t{0x2090, 0x12c8},\n\t{0x2092, 0x7800},\n\t{0x2094, 0x0802},\n\t{0x2096, 0x040f},\n\t{0x2098, 0x1007},\n\t{0x209a, 0x0803},\n\t{0x209c, 0x080b},\n\t{0x209e, 0x3803},\n\t{0x20a0, 0x0807},\n\t{0x20a2, 0x0404},\n\t{0x20a4, 0x0400},\n\t{0x20a6, 0xffff},\n\t{0x20a8, 0xf0b2},\n\t{0x20aa, 0xffef},\n\t{0x20ac, 0x0a84},\n\t{0x20ae, 0x1292},\n\t{0x20b0, 0xc02e},\n\t{0x20b2, 0x4130},\n\t{0x23fe, 0xc056},\n\t{0x3232, 0xfc0c},\n\t{0x3236, 0xfc22},\n\t{0x3248, 0xfca8},\n\t{0x326a, 0x8302},\n\t{0x326c, 0x830a},\n\t{0x326e, 0x0000},\n\t{0x32ca, 0xfc28},\n\t{0x32cc, 0xc3bc},\n\t{0x32ce, 0xc34c},\n\t{0x32d0, 0xc35a},\n\t{0x32d2, 0xc368},\n\t{0x32d4, 0xc376},\n\t{0x32d6, 0xc3c2},\n\t{0x32d8, 0xc3e6},\n\t{0x32da, 0x0003},\n\t{0x32dc, 0x0003},\n\t{0x32de, 0x00c7},\n\t{0x32e0, 0x0031},\n\t{0x32e2, 0x0031},\n\t{0x32e4, 0x0031},\n\t{0x32e6, 0xfc28},\n\t{0x32e8, 0xc3bc},\n\t{0x32ea, 0xc384},\n\t{0x32ec, 0xc392},\n\t{0x32ee, 0xc3a0},\n\t{0x32f0, 0xc3ae},\n\t{0x32f2, 0xc3c4},\n\t{0x32f4, 0xc3e6},\n\t{0x32f6, 0x0003},\n\t{0x32f8, 0x0003},\n\t{0x32fa, 0x00c7},\n\t{0x32fc, 0x0031},\n\t{0x32fe, 0x0031},\n\t{0x3300, 0x0031},\n\t{0x3302, 0x82ca},\n\t{0x3304, 0xc164},\n\t{0x3306, 0x82e6},\n\t{0x3308, 0xc19c},\n\t{0x330a, 0x001f},\n\t{0x330c, 0x001a},\n\t{0x330e, 0x0034},\n\t{0x3310, 0x0000},\n\t{0x3312, 0x0000},\n\t{0x3314, 0xfc94},\n\t{0x3316, 0xc3d8},\n\t \n\t{HI846_REG_MODE_SELECT,\t\t\t0x0000},\n\t{HI846_REG_UNKNOWN_0E04,\t\t0x0012},\n\t{HI846_REG_Y_ODD_INC_FOBP,\t\t0x1111},\n\t{HI846_REG_Y_ODD_INC_VACT,\t\t0x1111},\n\t{HI846_REG_UNKNOWN_0022,\t\t0x0008},\n\t{HI846_REG_Y_ADDR_START_VACT_H,\t\t0x0040},\n\t{HI846_REG_UNKNOWN_0028,\t\t0x0017},\n\t{HI846_REG_Y_ADDR_END_VACT_H,\t\t0x09cf},\n\t{HI846_REG_UNKNOWN_005C,\t\t0x2101},\n\t{HI846_REG_FLL,\t\t\t\t0x09de},\n\t{HI846_REG_LLP,\t\t\t\t0x0ed8},\n\t{HI846_REG_IMAGE_ORIENTATION,\t\t0x0100},\n\t{HI846_REG_BINNING_MODE,\t\t0x0022},\n\t{HI846_REG_HBIN_MODE,\t\t\t0x0000},\n\t{HI846_REG_UNKNOWN_0A24,\t\t0x0000},\n\t{HI846_REG_X_START_H,\t\t\t0x0000},\n\t{HI846_REG_X_OUTPUT_SIZE_H,\t\t0x0cc0},\n\t{HI846_REG_Y_OUTPUT_SIZE_H,\t\t0x0990},\n\t{HI846_REG_EXPOSURE,\t\t\t0x09d8},\n\t{HI846_REG_ANALOG_GAIN,\t\t\t0x0000},\n\t{HI846_REG_GROUPED_PARA_HOLD,\t\t0x0000},\n\t{HI846_REG_UNKNOWN_051E,\t\t0x0000},\n\t{HI846_REG_UNKNOWN_0200,\t\t0x0400},\n\t{HI846_REG_PEDESTAL_EN,\t\t\t0x0c00},\n\t{HI846_REG_UNKNOWN_0A0C,\t\t0x0010},\n\t{HI846_REG_UNKNOWN_0A1E,\t\t0x0ccf},\n\t{HI846_REG_UNKNOWN_0402,\t\t0x0110},\n\t{HI846_REG_UNKNOWN_0404,\t\t0x00f4},\n\t{HI846_REG_UNKNOWN_0408,\t\t0x0000},\n\t{HI846_REG_UNKNOWN_0410,\t\t0x008d},\n\t{HI846_REG_UNKNOWN_0412,\t\t0x011a},\n\t{HI846_REG_UNKNOWN_0414,\t\t0x864c},\n\t{HI846_REG_UNKNOWN_021C,\t\t0x0003},\n\t{HI846_REG_UNKNOWN_021E,\t\t0x0235},\n\t{HI846_REG_BLC_CTL0,\t\t\t0x9150},\n\t{HI846_REG_UNKNOWN_0C06,\t\t0x0021},\n\t{HI846_REG_UNKNOWN_0C10,\t\t0x0040},\n\t{HI846_REG_UNKNOWN_0C12,\t\t0x0040},\n\t{HI846_REG_UNKNOWN_0C14,\t\t0x0040},\n\t{HI846_REG_UNKNOWN_0C16,\t\t0x0040},\n\t{HI846_REG_FAST_STANDBY_MODE,\t\t0x0100},\n\t{HI846_REG_ISP_EN_H,\t\t\t0x014a},\n\t{HI846_REG_UNKNOWN_0418,\t\t0x0000},\n\t{HI846_REG_UNKNOWN_012A,\t\t0x03b4},\n\t{HI846_REG_X_ADDR_START_HACT_H,\t\t0x0046},\n\t{HI846_REG_X_ADDR_END_HACT_H,\t\t0x0376},\n\t{HI846_REG_UNKNOWN_0B02,\t\t0xe04d},\n\t{HI846_REG_UNKNOWN_0B10,\t\t0x6821},\n\t{HI846_REG_UNKNOWN_0B12,\t\t0x0120},\n\t{HI846_REG_UNKNOWN_0B14,\t\t0x0001},\n\t{HI846_REG_UNKNOWN_2008,\t\t0x38fd},\n\t{HI846_REG_UNKNOWN_326E,\t\t0x0000},\n\t{HI846_REG_UNKNOWN_0900,\t\t0x0320},\n\t{HI846_REG_MIPI_TX_OP_MODE,\t\t0xc31a},\n\t{HI846_REG_UNKNOWN_0914,\t\t0xc109},\n\t{HI846_REG_TCLK_PREPARE,\t\t0x061a},\n\t{HI846_REG_UNKNOWN_0918,\t\t0x0306},\n\t{HI846_REG_THS_ZERO,\t\t\t0x0b09},\n\t{HI846_REG_TCLK_POST,\t\t\t0x0c07},\n\t{HI846_REG_UNKNOWN_091E,\t\t0x0a00},\n\t{HI846_REG_UNKNOWN_090C,\t\t0x042a},\n\t{HI846_REG_UNKNOWN_090E,\t\t0x006b},\n\t{HI846_REG_UNKNOWN_0954,\t\t0x0089},\n\t{HI846_REG_UNKNOWN_0956,\t\t0x0000},\n\t{HI846_REG_UNKNOWN_0958,\t\t0xca00},\n\t{HI846_REG_UNKNOWN_095A,\t\t0x9240},\n\t{HI846_REG_UNKNOWN_0F08,\t\t0x2f04},\n\t{HI846_REG_UNKNOWN_0F30,\t\t0x001f},\n\t{HI846_REG_UNKNOWN_0F36,\t\t0x001f},\n\t{HI846_REG_UNKNOWN_0F04,\t\t0x3a00},\n\t{HI846_REG_PLL_CFG_RAMP1_H,\t\t0x025a},\n\t{HI846_REG_PLL_CFG_MIPI1_H,\t\t0x025a},\n\t{HI846_REG_PLL_CFG_MIPI2_H,\t\t0x0024},\n\t{HI846_REG_UNKNOWN_006A,\t\t0x0100},\n\t{HI846_REG_TG_ENABLE,\t\t\t0x0100},\n};\n\nstatic const struct hi846_reg hi846_init_4lane[] = {\n\t{0x2000, 0x987a},\n\t{0x2002, 0x00ff},\n\t{0x2004, 0x0047},\n\t{0x2006, 0x3fff},\n\t{0x2008, 0x3fff},\n\t{0x200a, 0xc216},\n\t{0x200c, 0x1292},\n\t{0x200e, 0xc01a},\n\t{0x2010, 0x403d},\n\t{0x2012, 0x000e},\n\t{0x2014, 0x403e},\n\t{0x2016, 0x0b80},\n\t{0x2018, 0x403f},\n\t{0x201a, 0x82ae},\n\t{0x201c, 0x1292},\n\t{0x201e, 0xc00c},\n\t{0x2020, 0x4130},\n\t{0x2022, 0x43e2},\n\t{0x2024, 0x0180},\n\t{0x2026, 0x4130},\n\t{0x2028, 0x7400},\n\t{0x202a, 0x5000},\n\t{0x202c, 0x0253},\n\t{0x202e, 0x0ad1},\n\t{0x2030, 0x2360},\n\t{0x2032, 0x0009},\n\t{0x2034, 0x5020},\n\t{0x2036, 0x000b},\n\t{0x2038, 0x0002},\n\t{0x203a, 0x0044},\n\t{0x203c, 0x0016},\n\t{0x203e, 0x1792},\n\t{0x2040, 0x7002},\n\t{0x2042, 0x154f},\n\t{0x2044, 0x00d5},\n\t{0x2046, 0x000b},\n\t{0x2048, 0x0019},\n\t{0x204a, 0x1698},\n\t{0x204c, 0x000e},\n\t{0x204e, 0x099a},\n\t{0x2050, 0x0058},\n\t{0x2052, 0x7000},\n\t{0x2054, 0x1799},\n\t{0x2056, 0x0310},\n\t{0x2058, 0x03c3},\n\t{0x205a, 0x004c},\n\t{0x205c, 0x064a},\n\t{0x205e, 0x0001},\n\t{0x2060, 0x0007},\n\t{0x2062, 0x0bc7},\n\t{0x2064, 0x0055},\n\t{0x2066, 0x7000},\n\t{0x2068, 0x1550},\n\t{0x206a, 0x158a},\n\t{0x206c, 0x0004},\n\t{0x206e, 0x1488},\n\t{0x2070, 0x7010},\n\t{0x2072, 0x1508},\n\t{0x2074, 0x0004},\n\t{0x2076, 0x0016},\n\t{0x2078, 0x03d5},\n\t{0x207a, 0x0055},\n\t{0x207c, 0x08ca},\n\t{0x207e, 0x2019},\n\t{0x2080, 0x0007},\n\t{0x2082, 0x7057},\n\t{0x2084, 0x0fc7},\n\t{0x2086, 0x5041},\n\t{0x2088, 0x12c8},\n\t{0x208a, 0x5060},\n\t{0x208c, 0x5080},\n\t{0x208e, 0x2084},\n\t{0x2090, 0x12c8},\n\t{0x2092, 0x7800},\n\t{0x2094, 0x0802},\n\t{0x2096, 0x040f},\n\t{0x2098, 0x1007},\n\t{0x209a, 0x0803},\n\t{0x209c, 0x080b},\n\t{0x209e, 0x3803},\n\t{0x20a0, 0x0807},\n\t{0x20a2, 0x0404},\n\t{0x20a4, 0x0400},\n\t{0x20a6, 0xffff},\n\t{0x20a8, 0xf0b2},\n\t{0x20aa, 0xffef},\n\t{0x20ac, 0x0a84},\n\t{0x20ae, 0x1292},\n\t{0x20b0, 0xc02e},\n\t{0x20b2, 0x4130},\n\t{0x20b4, 0xf0b2},\n\t{0x20b6, 0xffbf},\n\t{0x20b8, 0x2004},\n\t{0x20ba, 0x403f},\n\t{0x20bc, 0x00c3},\n\t{0x20be, 0x4fe2},\n\t{0x20c0, 0x8318},\n\t{0x20c2, 0x43cf},\n\t{0x20c4, 0x0000},\n\t{0x20c6, 0x9382},\n\t{0x20c8, 0xc314},\n\t{0x20ca, 0x2003},\n\t{0x20cc, 0x12b0},\n\t{0x20ce, 0xcab0},\n\t{0x20d0, 0x4130},\n\t{0x20d2, 0x12b0},\n\t{0x20d4, 0xc90a},\n\t{0x20d6, 0x4130},\n\t{0x20d8, 0x42d2},\n\t{0x20da, 0x8318},\n\t{0x20dc, 0x00c3},\n\t{0x20de, 0x9382},\n\t{0x20e0, 0xc314},\n\t{0x20e2, 0x2009},\n\t{0x20e4, 0x120b},\n\t{0x20e6, 0x120a},\n\t{0x20e8, 0x1209},\n\t{0x20ea, 0x1208},\n\t{0x20ec, 0x1207},\n\t{0x20ee, 0x1206},\n\t{0x20f0, 0x4030},\n\t{0x20f2, 0xc15e},\n\t{0x20f4, 0x4130},\n\t{0x20f6, 0x1292},\n\t{0x20f8, 0xc008},\n\t{0x20fa, 0x4130},\n\t{0x20fc, 0x42d2},\n\t{0x20fe, 0x82a1},\n\t{0x2100, 0x00c2},\n\t{0x2102, 0x1292},\n\t{0x2104, 0xc040},\n\t{0x2106, 0x4130},\n\t{0x2108, 0x1292},\n\t{0x210a, 0xc006},\n\t{0x210c, 0x42a2},\n\t{0x210e, 0x7324},\n\t{0x2110, 0x9382},\n\t{0x2112, 0xc314},\n\t{0x2114, 0x2011},\n\t{0x2116, 0x425f},\n\t{0x2118, 0x82a1},\n\t{0x211a, 0xf25f},\n\t{0x211c, 0x00c1},\n\t{0x211e, 0xf35f},\n\t{0x2120, 0x2406},\n\t{0x2122, 0x425f},\n\t{0x2124, 0x00c0},\n\t{0x2126, 0xf37f},\n\t{0x2128, 0x522f},\n\t{0x212a, 0x4f82},\n\t{0x212c, 0x7324},\n\t{0x212e, 0x425f},\n\t{0x2130, 0x82d4},\n\t{0x2132, 0xf35f},\n\t{0x2134, 0x4fc2},\n\t{0x2136, 0x01b3},\n\t{0x2138, 0x93c2},\n\t{0x213a, 0x829f},\n\t{0x213c, 0x2421},\n\t{0x213e, 0x403e},\n\t{0x2140, 0xfffe},\n\t{0x2142, 0x40b2},\n\t{0x2144, 0xec78},\n\t{0x2146, 0x831c},\n\t{0x2148, 0x40b2},\n\t{0x214a, 0xec78},\n\t{0x214c, 0x831e},\n\t{0x214e, 0x40b2},\n\t{0x2150, 0xec78},\n\t{0x2152, 0x8320},\n\t{0x2154, 0xb3d2},\n\t{0x2156, 0x008c},\n\t{0x2158, 0x2405},\n\t{0x215a, 0x4e0f},\n\t{0x215c, 0x503f},\n\t{0x215e, 0xffd8},\n\t{0x2160, 0x4f82},\n\t{0x2162, 0x831c},\n\t{0x2164, 0x90f2},\n\t{0x2166, 0x0003},\n\t{0x2168, 0x008c},\n\t{0x216a, 0x2401},\n\t{0x216c, 0x4130},\n\t{0x216e, 0x421f},\n\t{0x2170, 0x831c},\n\t{0x2172, 0x5e0f},\n\t{0x2174, 0x4f82},\n\t{0x2176, 0x831e},\n\t{0x2178, 0x5e0f},\n\t{0x217a, 0x4f82},\n\t{0x217c, 0x8320},\n\t{0x217e, 0x3ff6},\n\t{0x2180, 0x432e},\n\t{0x2182, 0x3fdf},\n\t{0x2184, 0x421f},\n\t{0x2186, 0x7100},\n\t{0x2188, 0x4f0e},\n\t{0x218a, 0x503e},\n\t{0x218c, 0xffd8},\n\t{0x218e, 0x4e82},\n\t{0x2190, 0x7a04},\n\t{0x2192, 0x421e},\n\t{0x2194, 0x831c},\n\t{0x2196, 0x5f0e},\n\t{0x2198, 0x4e82},\n\t{0x219a, 0x7a06},\n\t{0x219c, 0x0b00},\n\t{0x219e, 0x7304},\n\t{0x21a0, 0x0050},\n\t{0x21a2, 0x40b2},\n\t{0x21a4, 0xd081},\n\t{0x21a6, 0x0b88},\n\t{0x21a8, 0x421e},\n\t{0x21aa, 0x831e},\n\t{0x21ac, 0x5f0e},\n\t{0x21ae, 0x4e82},\n\t{0x21b0, 0x7a0e},\n\t{0x21b2, 0x521f},\n\t{0x21b4, 0x8320},\n\t{0x21b6, 0x4f82},\n\t{0x21b8, 0x7a10},\n\t{0x21ba, 0x0b00},\n\t{0x21bc, 0x7304},\n\t{0x21be, 0x007a},\n\t{0x21c0, 0x40b2},\n\t{0x21c2, 0x0081},\n\t{0x21c4, 0x0b88},\n\t{0x21c6, 0x4392},\n\t{0x21c8, 0x7a0a},\n\t{0x21ca, 0x0800},\n\t{0x21cc, 0x7a0c},\n\t{0x21ce, 0x0b00},\n\t{0x21d0, 0x7304},\n\t{0x21d2, 0x022b},\n\t{0x21d4, 0x40b2},\n\t{0x21d6, 0xd081},\n\t{0x21d8, 0x0b88},\n\t{0x21da, 0x0b00},\n\t{0x21dc, 0x7304},\n\t{0x21de, 0x0255},\n\t{0x21e0, 0x40b2},\n\t{0x21e2, 0x0081},\n\t{0x21e4, 0x0b88},\n\t{0x21e6, 0x4130},\n\t{0x23fe, 0xc056},\n\t{0x3232, 0xfc0c},\n\t{0x3236, 0xfc22},\n\t{0x3238, 0xfcfc},\n\t{0x323a, 0xfd84},\n\t{0x323c, 0xfd08},\n\t{0x3246, 0xfcd8},\n\t{0x3248, 0xfca8},\n\t{0x324e, 0xfcb4},\n\t{0x326a, 0x8302},\n\t{0x326c, 0x830a},\n\t{0x326e, 0x0000},\n\t{0x32ca, 0xfc28},\n\t{0x32cc, 0xc3bc},\n\t{0x32ce, 0xc34c},\n\t{0x32d0, 0xc35a},\n\t{0x32d2, 0xc368},\n\t{0x32d4, 0xc376},\n\t{0x32d6, 0xc3c2},\n\t{0x32d8, 0xc3e6},\n\t{0x32da, 0x0003},\n\t{0x32dc, 0x0003},\n\t{0x32de, 0x00c7},\n\t{0x32e0, 0x0031},\n\t{0x32e2, 0x0031},\n\t{0x32e4, 0x0031},\n\t{0x32e6, 0xfc28},\n\t{0x32e8, 0xc3bc},\n\t{0x32ea, 0xc384},\n\t{0x32ec, 0xc392},\n\t{0x32ee, 0xc3a0},\n\t{0x32f0, 0xc3ae},\n\t{0x32f2, 0xc3c4},\n\t{0x32f4, 0xc3e6},\n\t{0x32f6, 0x0003},\n\t{0x32f8, 0x0003},\n\t{0x32fa, 0x00c7},\n\t{0x32fc, 0x0031},\n\t{0x32fe, 0x0031},\n\t{0x3300, 0x0031},\n\t{0x3302, 0x82ca},\n\t{0x3304, 0xc164},\n\t{0x3306, 0x82e6},\n\t{0x3308, 0xc19c},\n\t{0x330a, 0x001f},\n\t{0x330c, 0x001a},\n\t{0x330e, 0x0034},\n\t{0x3310, 0x0000},\n\t{0x3312, 0x0000},\n\t{0x3314, 0xfc94},\n\t{0x3316, 0xc3d8},\n\n\t{0x0a00, 0x0000},\n\t{0x0e04, 0x0012},\n\t{0x002e, 0x1111},\n\t{0x0032, 0x1111},\n\t{0x0022, 0x0008},\n\t{0x0026, 0x0040},\n\t{0x0028, 0x0017},\n\t{0x002c, 0x09cf},\n\t{0x005c, 0x2101},\n\t{0x0006, 0x09de},\n\t{0x0008, 0x0ed8},\n\t{0x000e, 0x0100},\n\t{0x000c, 0x0022},\n\t{0x0a22, 0x0000},\n\t{0x0a24, 0x0000},\n\t{0x0804, 0x0000},\n\t{0x0a12, 0x0cc0},\n\t{0x0a14, 0x0990},\n\t{0x0074, 0x09d8},\n\t{0x0076, 0x0000},\n\t{0x051e, 0x0000},\n\t{0x0200, 0x0400},\n\t{0x0a1a, 0x0c00},\n\t{0x0a0c, 0x0010},\n\t{0x0a1e, 0x0ccf},\n\t{0x0402, 0x0110},\n\t{0x0404, 0x00f4},\n\t{0x0408, 0x0000},\n\t{0x0410, 0x008d},\n\t{0x0412, 0x011a},\n\t{0x0414, 0x864c},\n\t \n\t{0x021c, 0x0003},\n\t{0x021e, 0x0235},\n\t \n\t{0x0c00, 0x9950},\n\t{0x0c06, 0x0021},\n\t{0x0c10, 0x0040},\n\t{0x0c12, 0x0040},\n\t{0x0c14, 0x0040},\n\t{0x0c16, 0x0040},\n\t{0x0a02, 0x0100},\n\t{0x0a04, 0x015a},\n\t{0x0418, 0x0000},\n\t{0x0128, 0x0028},\n\t{0x012a, 0xffff},\n\t{0x0120, 0x0046},\n\t{0x0122, 0x0376},\n\t{0x012c, 0x0020},\n\t{0x012e, 0xffff},\n\t{0x0124, 0x0040},\n\t{0x0126, 0x0378},\n\t{0x0746, 0x0050},\n\t{0x0748, 0x01d5},\n\t{0x074a, 0x022b},\n\t{0x074c, 0x03b0},\n\t{0x0756, 0x043f},\n\t{0x0758, 0x3f1d},\n\t{0x0b02, 0xe04d},\n\t{0x0b10, 0x6821},\n\t{0x0b12, 0x0120},\n\t{0x0b14, 0x0001},\n\t{0x2008, 0x38fd},\n\t{0x326e, 0x0000},\n\t{0x0900, 0x0300},\n\t{0x0902, 0xc319},\n\t{0x0914, 0xc109},\n\t{0x0916, 0x061a},\n\t{0x0918, 0x0407},\n\t{0x091a, 0x0a0b},\n\t{0x091c, 0x0e08},\n\t{0x091e, 0x0a00},\n\t{0x090c, 0x0427},\n\t{0x090e, 0x0059},\n\t{0x0954, 0x0089},\n\t{0x0956, 0x0000},\n\t{0x0958, 0xca80},\n\t{0x095a, 0x9240},\n\t{0x0f08, 0x2f04},\n\t{0x0f30, 0x001f},\n\t{0x0f36, 0x001f},\n\t{0x0f04, 0x3a00},\n\t{0x0f32, 0x025a},\n\t{0x0f38, 0x025a},\n\t{0x0f2a, 0x4124},\n\t{0x006a, 0x0100},\n\t{0x004c, 0x0100},\n\t{0x0044, 0x0001},\n};\n\nstatic const struct hi846_reg mode_640x480_config[] = {\n\t{HI846_REG_MODE_SELECT,\t\t\t0x0000},\n\t{HI846_REG_Y_ODD_INC_FOBP,\t\t0x7711},\n\t{HI846_REG_Y_ODD_INC_VACT,\t\t0x7711},\n\t{HI846_REG_Y_ADDR_START_VACT_H,\t\t0x0148},\n\t{HI846_REG_Y_ADDR_END_VACT_H,\t\t0x08c7},\n\t{HI846_REG_UNKNOWN_005C,\t\t0x4404},\n\t{HI846_REG_FLL,\t\t\t\t0x0277},\n\t{HI846_REG_LLP,\t\t\t\t0x0ed8},\n\t{HI846_REG_BINNING_MODE,\t\t0x0322},\n\t{HI846_REG_HBIN_MODE,\t\t\t0x0200},\n\t{HI846_REG_UNKNOWN_0A24,\t\t0x0000},\n\t{HI846_REG_X_START_H,\t\t\t0x0058},\n\t{HI846_REG_X_OUTPUT_SIZE_H,\t\t0x0280},\n\t{HI846_REG_Y_OUTPUT_SIZE_H,\t\t0x01e0},\n\n\t \n\t{HI846_REG_UNKNOWN_021C,\t\t0x0003},\n\t{HI846_REG_UNKNOWN_021E,\t\t0x0235},\n\n\t{HI846_REG_ISP_EN_H,\t\t\t0x016a},\n\t{HI846_REG_UNKNOWN_0418,\t\t0x0210},\n\t{HI846_REG_UNKNOWN_0B02,\t\t0xe04d},\n\t{HI846_REG_UNKNOWN_0B10,\t\t0x7021},\n\t{HI846_REG_UNKNOWN_0B12,\t\t0x0120},\n\t{HI846_REG_UNKNOWN_0B14,\t\t0x0001},\n\t{HI846_REG_UNKNOWN_2008,\t\t0x38fd},\n\t{HI846_REG_UNKNOWN_326E,\t\t0x0000},\n};\n\nstatic const struct hi846_reg mode_640x480_mipi_2lane[] = {\n\t{HI846_REG_UNKNOWN_0900,\t\t0x0300},\n\t{HI846_REG_MIPI_TX_OP_MODE,\t\t0x4319},\n\t{HI846_REG_UNKNOWN_0914,\t\t0xc105},\n\t{HI846_REG_TCLK_PREPARE,\t\t0x030c},\n\t{HI846_REG_UNKNOWN_0918,\t\t0x0304},\n\t{HI846_REG_THS_ZERO,\t\t\t0x0708},\n\t{HI846_REG_TCLK_POST,\t\t\t0x0b04},\n\t{HI846_REG_UNKNOWN_091E,\t\t0x0500},\n\t{HI846_REG_UNKNOWN_090C,\t\t0x0208},\n\t{HI846_REG_UNKNOWN_090E,\t\t0x009a},\n\t{HI846_REG_UNKNOWN_0954,\t\t0x0089},\n\t{HI846_REG_UNKNOWN_0956,\t\t0x0000},\n\t{HI846_REG_UNKNOWN_0958,\t\t0xca80},\n\t{HI846_REG_UNKNOWN_095A,\t\t0x9240},\n\t{HI846_REG_PLL_CFG_MIPI2_H,\t\t0x4924},\n\t{HI846_REG_TG_ENABLE,\t\t\t0x0100},\n};\n\nstatic const struct hi846_reg mode_1280x720_config[] = {\n\t{HI846_REG_MODE_SELECT,\t\t\t0x0000},\n\t{HI846_REG_Y_ODD_INC_FOBP,\t\t0x3311},\n\t{HI846_REG_Y_ODD_INC_VACT,\t\t0x3311},\n\t{HI846_REG_Y_ADDR_START_VACT_H,\t\t0x0238},\n\t{HI846_REG_Y_ADDR_END_VACT_H,\t\t0x07d7},\n\t{HI846_REG_UNKNOWN_005C,\t\t0x4202},\n\t{HI846_REG_FLL,\t\t\t\t0x034a},\n\t{HI846_REG_LLP,\t\t\t\t0x0ed8},\n\t{HI846_REG_BINNING_MODE,\t\t0x0122},\n\t{HI846_REG_HBIN_MODE,\t\t\t0x0100},\n\t{HI846_REG_UNKNOWN_0A24,\t\t0x0000},\n\t{HI846_REG_X_START_H,\t\t\t0x00b0},\n\t{HI846_REG_X_OUTPUT_SIZE_H,\t\t0x0500},\n\t{HI846_REG_Y_OUTPUT_SIZE_H,\t\t0x02d0},\n\t{HI846_REG_EXPOSURE,\t\t\t0x0344},\n\n\t \n\t{HI846_REG_UNKNOWN_021C,\t\t0x0003},\n\t{HI846_REG_UNKNOWN_021E,\t\t0x0235},\n\n\t{HI846_REG_ISP_EN_H,\t\t\t0x016a},\n\t{HI846_REG_UNKNOWN_0418,\t\t0x0410},\n\t{HI846_REG_UNKNOWN_0B02,\t\t0xe04d},\n\t{HI846_REG_UNKNOWN_0B10,\t\t0x6c21},\n\t{HI846_REG_UNKNOWN_0B12,\t\t0x0120},\n\t{HI846_REG_UNKNOWN_0B14,\t\t0x0005},\n\t{HI846_REG_UNKNOWN_2008,\t\t0x38fd},\n\t{HI846_REG_UNKNOWN_326E,\t\t0x0000},\n};\n\nstatic const struct hi846_reg mode_1280x720_mipi_2lane[] = {\n\t{HI846_REG_UNKNOWN_0900,\t\t0x0300},\n\t{HI846_REG_MIPI_TX_OP_MODE,\t\t0x4319},\n\t{HI846_REG_UNKNOWN_0914,\t\t0xc109},\n\t{HI846_REG_TCLK_PREPARE,\t\t0x061a},\n\t{HI846_REG_UNKNOWN_0918,\t\t0x0407},\n\t{HI846_REG_THS_ZERO,\t\t\t0x0a0b},\n\t{HI846_REG_TCLK_POST,\t\t\t0x0e08},\n\t{HI846_REG_UNKNOWN_091E,\t\t0x0a00},\n\t{HI846_REG_UNKNOWN_090C,\t\t0x0427},\n\t{HI846_REG_UNKNOWN_090E,\t\t0x0145},\n\t{HI846_REG_UNKNOWN_0954,\t\t0x0089},\n\t{HI846_REG_UNKNOWN_0956,\t\t0x0000},\n\t{HI846_REG_UNKNOWN_0958,\t\t0xca80},\n\t{HI846_REG_UNKNOWN_095A,\t\t0x9240},\n\t{HI846_REG_PLL_CFG_MIPI2_H,\t\t0x4124},\n\t{HI846_REG_TG_ENABLE,\t\t\t0x0100},\n};\n\nstatic const struct hi846_reg mode_1280x720_mipi_4lane[] = {\n\t \n\t{HI846_REG_UNKNOWN_0900,\t\t0x0300},\n\t{HI846_REG_MIPI_TX_OP_MODE,\t\t0xc319},\n\t{HI846_REG_UNKNOWN_0914,\t\t0xc105},\n\t{HI846_REG_TCLK_PREPARE,\t\t0x030c},\n\t{HI846_REG_UNKNOWN_0918,\t\t0x0304},\n\t{HI846_REG_THS_ZERO,\t\t\t0x0708},\n\t{HI846_REG_TCLK_POST,\t\t\t0x0b04},\n\t{HI846_REG_UNKNOWN_091E,\t\t0x0500},\n\t{HI846_REG_UNKNOWN_090C,\t\t0x0208},\n\t{HI846_REG_UNKNOWN_090E,\t\t0x008a},\n\t{HI846_REG_UNKNOWN_0954,\t\t0x0089},\n\t{HI846_REG_UNKNOWN_0956,\t\t0x0000},\n\t{HI846_REG_UNKNOWN_0958,\t\t0xca80},\n\t{HI846_REG_UNKNOWN_095A,\t\t0x9240},\n\t{HI846_REG_PLL_CFG_MIPI2_H,\t\t0x4924},\n\t{HI846_REG_TG_ENABLE,\t\t\t0x0100},\n};\n\nstatic const struct hi846_reg mode_1632x1224_config[] = {\n\t{HI846_REG_MODE_SELECT,\t\t\t0x0000},\n\t{HI846_REG_Y_ODD_INC_FOBP,\t\t0x3311},\n\t{HI846_REG_Y_ODD_INC_VACT,\t\t0x3311},\n\t{HI846_REG_Y_ADDR_START_VACT_H,\t\t0x0040},\n\t{HI846_REG_Y_ADDR_END_VACT_H,\t\t0x09cf},\n\t{HI846_REG_UNKNOWN_005C,\t\t0x4202},\n\t{HI846_REG_FLL,\t\t\t\t0x09de},\n\t{HI846_REG_LLP,\t\t\t\t0x0ed8},\n\t{HI846_REG_BINNING_MODE,\t\t0x0122},\n\t{HI846_REG_HBIN_MODE,\t\t\t0x0100},\n\t{HI846_REG_UNKNOWN_0A24,\t\t0x0000},\n\t{HI846_REG_X_START_H,\t\t\t0x0000},\n\t{HI846_REG_X_OUTPUT_SIZE_H,\t\t0x0660},\n\t{HI846_REG_Y_OUTPUT_SIZE_H,\t\t0x04c8},\n\t{HI846_REG_EXPOSURE,\t\t\t0x09d8},\n\n\t \n\t{HI846_REG_UNKNOWN_021C,\t\t0x0003},\n\t{HI846_REG_UNKNOWN_021E,\t\t0x0235},\n\n\t{HI846_REG_ISP_EN_H,\t\t\t0x016a},\n\t{HI846_REG_UNKNOWN_0418,\t\t0x0000},\n\t{HI846_REG_UNKNOWN_0B02,\t\t0xe04d},\n\t{HI846_REG_UNKNOWN_0B10,\t\t0x6c21},\n\t{HI846_REG_UNKNOWN_0B12,\t\t0x0120},\n\t{HI846_REG_UNKNOWN_0B14,\t\t0x0005},\n\t{HI846_REG_UNKNOWN_2008,\t\t0x38fd},\n\t{HI846_REG_UNKNOWN_326E,\t\t0x0000},\n};\n\nstatic const struct hi846_reg mode_1632x1224_mipi_2lane[] = {\n\t{HI846_REG_UNKNOWN_0900,\t\t0x0300},\n\t{HI846_REG_MIPI_TX_OP_MODE,\t\t0x4319},\n\t{HI846_REG_UNKNOWN_0914,\t\t0xc109},\n\t{HI846_REG_TCLK_PREPARE,\t\t0x061a},\n\t{HI846_REG_UNKNOWN_0918,\t\t0x0407},\n\t{HI846_REG_THS_ZERO,\t\t\t0x0a0b},\n\t{HI846_REG_TCLK_POST,\t\t\t0x0e08},\n\t{HI846_REG_UNKNOWN_091E,\t\t0x0a00},\n\t{HI846_REG_UNKNOWN_090C,\t\t0x0427},\n\t{HI846_REG_UNKNOWN_090E,\t\t0x0069},\n\t{HI846_REG_UNKNOWN_0954,\t\t0x0089},\n\t{HI846_REG_UNKNOWN_0956,\t\t0x0000},\n\t{HI846_REG_UNKNOWN_0958,\t\t0xca80},\n\t{HI846_REG_UNKNOWN_095A,\t\t0x9240},\n\t{HI846_REG_PLL_CFG_MIPI2_H,\t\t0x4124},\n\t{HI846_REG_TG_ENABLE,\t\t\t0x0100},\n};\n\nstatic const struct hi846_reg mode_1632x1224_mipi_4lane[] = {\n\t{HI846_REG_UNKNOWN_0900,\t\t0x0300},\n\t{HI846_REG_MIPI_TX_OP_MODE,\t\t0xc319},\n\t{HI846_REG_UNKNOWN_0914,\t\t0xc105},\n\t{HI846_REG_TCLK_PREPARE,\t\t0x030c},\n\t{HI846_REG_UNKNOWN_0918,\t\t0x0304},\n\t{HI846_REG_THS_ZERO,\t\t\t0x0708},\n\t{HI846_REG_TCLK_POST,\t\t\t0x0b04},\n\t{HI846_REG_UNKNOWN_091E,\t\t0x0500},\n\t{HI846_REG_UNKNOWN_090C,\t\t0x0208},\n\t{HI846_REG_UNKNOWN_090E,\t\t0x001c},\n\t{HI846_REG_UNKNOWN_0954,\t\t0x0089},\n\t{HI846_REG_UNKNOWN_0956,\t\t0x0000},\n\t{HI846_REG_UNKNOWN_0958,\t\t0xca80},\n\t{HI846_REG_UNKNOWN_095A,\t\t0x9240},\n\t{HI846_REG_PLL_CFG_MIPI2_H,\t\t0x4924},\n\t{HI846_REG_TG_ENABLE,\t\t\t0x0100},\n};\n\nstatic const char * const hi846_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Solid Colour\",\n\t\"100% Colour Bars\",\n\t\"Fade To Grey Colour Bars\",\n\t\"PN9\",\n\t\"Gradient Horizontal\",\n\t\"Gradient Vertical\",\n\t\"Check Board\",\n\t\"Slant Pattern\",\n\t\"Resolution Pattern\",\n};\n\n#define FREQ_INDEX_640\t0\n#define FREQ_INDEX_1280\t1\nstatic const s64 hi846_link_freqs[] = {\n\t[FREQ_INDEX_640] = 80000000,\n\t[FREQ_INDEX_1280] = 200000000,\n};\n\nstatic const struct hi846_reg_list hi846_init_regs_list_2lane = {\n\t.num_of_regs = ARRAY_SIZE(hi846_init_2lane),\n\t.regs = hi846_init_2lane,\n};\n\nstatic const struct hi846_reg_list hi846_init_regs_list_4lane = {\n\t.num_of_regs = ARRAY_SIZE(hi846_init_4lane),\n\t.regs = hi846_init_4lane,\n};\n\nstatic const struct hi846_mode supported_modes[] = {\n\t{\n\t\t.width = 640,\n\t\t.height = 480,\n\t\t.link_freq_index = FREQ_INDEX_640,\n\t\t.fps = 120,\n\t\t.frame_len = 631,\n\t\t.llp = HI846_LINE_LENGTH,\n\t\t.reg_list_config = {\n\t\t\t.num_of_regs = ARRAY_SIZE(mode_640x480_config),\n\t\t\t.regs = mode_640x480_config,\n\t\t},\n\t\t.reg_list_2lane = {\n\t\t\t.num_of_regs = ARRAY_SIZE(mode_640x480_mipi_2lane),\n\t\t\t.regs = mode_640x480_mipi_2lane,\n\t\t},\n\t\t.reg_list_4lane = {\n\t\t\t.num_of_regs = 0,\n\t\t},\n\t\t.crop = {\n\t\t\t.left = 0x58,\n\t\t\t.top = 0x148,\n\t\t\t.width = 640 * 4,\n\t\t\t.height = 480 * 4,\n\t\t},\n\t},\n\t{\n\t\t.width = 1280,\n\t\t.height = 720,\n\t\t.link_freq_index = FREQ_INDEX_1280,\n\t\t.fps = 90,\n\t\t.frame_len = 842,\n\t\t.llp = HI846_LINE_LENGTH,\n\t\t.reg_list_config = {\n\t\t\t.num_of_regs = ARRAY_SIZE(mode_1280x720_config),\n\t\t\t.regs = mode_1280x720_config,\n\t\t},\n\t\t.reg_list_2lane = {\n\t\t\t.num_of_regs = ARRAY_SIZE(mode_1280x720_mipi_2lane),\n\t\t\t.regs = mode_1280x720_mipi_2lane,\n\t\t},\n\t\t.reg_list_4lane = {\n\t\t\t.num_of_regs = ARRAY_SIZE(mode_1280x720_mipi_4lane),\n\t\t\t.regs = mode_1280x720_mipi_4lane,\n\t\t},\n\t\t.crop = {\n\t\t\t.left = 0xb0,\n\t\t\t.top = 0x238,\n\t\t\t.width = 1280 * 2,\n\t\t\t.height = 720 * 2,\n\t\t},\n\t},\n\t{\n\t\t.width = 1632,\n\t\t.height = 1224,\n\t\t.link_freq_index = FREQ_INDEX_1280,\n\t\t.fps = 30,\n\t\t.frame_len = 2526,\n\t\t.llp = HI846_LINE_LENGTH,\n\t\t.reg_list_config = {\n\t\t\t.num_of_regs = ARRAY_SIZE(mode_1632x1224_config),\n\t\t\t.regs = mode_1632x1224_config,\n\t\t},\n\t\t.reg_list_2lane = {\n\t\t\t.num_of_regs = ARRAY_SIZE(mode_1632x1224_mipi_2lane),\n\t\t\t.regs = mode_1632x1224_mipi_2lane,\n\t\t},\n\t\t.reg_list_4lane = {\n\t\t\t.num_of_regs = ARRAY_SIZE(mode_1632x1224_mipi_4lane),\n\t\t\t.regs = mode_1632x1224_mipi_4lane,\n\t\t},\n\t\t.crop = {\n\t\t\t.left = 0x0,\n\t\t\t.top = 0x0,\n\t\t\t.width = 1632 * 2,\n\t\t\t.height = 1224 * 2,\n\t\t},\n\t}\n};\n\nstruct hi846_datafmt {\n\tu32 code;\n\tenum v4l2_colorspace colorspace;\n};\n\nstatic const char * const hi846_supply_names[] = {\n\t\"vddio\",  \n\t\"vdda\",  \n\t\"vddd\",  \n};\n\n#define HI846_NUM_SUPPLIES ARRAY_SIZE(hi846_supply_names)\n\nstruct hi846 {\n\tstruct gpio_desc *rst_gpio;\n\tstruct gpio_desc *shutdown_gpio;\n\tstruct regulator_bulk_data supplies[HI846_NUM_SUPPLIES];\n\tstruct clk *clock;\n\tconst struct hi846_datafmt *fmt;\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pad;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tu8 nr_lanes;\n\n\tstruct v4l2_ctrl *link_freq;\n\tstruct v4l2_ctrl *pixel_rate;\n\tstruct v4l2_ctrl *vblank;\n\tstruct v4l2_ctrl *hblank;\n\tstruct v4l2_ctrl *exposure;\n\n\tstruct mutex mutex;  \n\tconst struct hi846_mode *cur_mode;\n\tbool streaming;\n};\n\nstatic inline struct hi846 *to_hi846(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct hi846, sd);\n}\n\nstatic const struct hi846_datafmt hi846_colour_fmts[] = {\n\t{ HI846_MEDIA_BUS_FORMAT, V4L2_COLORSPACE_RAW },\n};\n\nstatic const struct hi846_datafmt *hi846_find_datafmt(u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hi846_colour_fmts); i++)\n\t\tif (hi846_colour_fmts[i].code == code)\n\t\t\treturn &hi846_colour_fmts[i];\n\n\treturn NULL;\n}\n\nstatic inline u8 hi846_get_link_freq_index(struct hi846 *hi846)\n{\n\treturn hi846->cur_mode->link_freq_index;\n}\n\nstatic u64 hi846_get_link_freq(struct hi846 *hi846)\n{\n\tu8 index = hi846_get_link_freq_index(hi846);\n\n\treturn hi846_link_freqs[index];\n}\n\nstatic u64 hi846_calc_pixel_rate(struct hi846 *hi846)\n{\n\tu64 link_freq = hi846_get_link_freq(hi846);\n\tu64 pixel_rate = link_freq * 2 * hi846->nr_lanes;\n\n\tdo_div(pixel_rate, HI846_RGB_DEPTH);\n\n\treturn pixel_rate;\n}\n\nstatic int hi846_read_reg(struct hi846 *hi846, u16 reg, u8 *val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&hi846->sd);\n\tstruct i2c_msg msgs[2];\n\tu8 addr_buf[2];\n\tu8 data_buf[1] = {0};\n\tint ret;\n\n\tput_unaligned_be16(reg, addr_buf);\n\tmsgs[0].addr = client->addr;\n\tmsgs[0].flags = 0;\n\tmsgs[0].len = sizeof(addr_buf);\n\tmsgs[0].buf = addr_buf;\n\tmsgs[1].addr = client->addr;\n\tmsgs[1].flags = I2C_M_RD;\n\tmsgs[1].len = 1;\n\tmsgs[1].buf = data_buf;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret != ARRAY_SIZE(msgs)) {\n\t\tdev_err(&client->dev, \"i2c read error: %d\\n\", ret);\n\t\treturn -EIO;\n\t}\n\n\t*val = data_buf[0];\n\n\treturn 0;\n}\n\nstatic int hi846_write_reg(struct hi846 *hi846, u16 reg, u8 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&hi846->sd);\n\tu8 buf[3] = { reg >> 8, reg & 0xff, val };\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = client->addr, .flags = 0,\n\t\t  .len = ARRAY_SIZE(buf), .buf = buf },\n\t};\n\tint ret;\n\n\tret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\tif (ret != ARRAY_SIZE(msg)) {\n\t\tdev_err(&client->dev, \"i2c write error\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void hi846_write_reg_16(struct hi846 *hi846, u16 reg, u16 val, int *err)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&hi846->sd);\n\tu8 buf[4];\n\tint ret;\n\n\tif (*err < 0)\n\t\treturn;\n\n\tput_unaligned_be16(reg, buf);\n\tput_unaligned_be16(val, buf + 2);\n\tret = i2c_master_send(client, buf, sizeof(buf));\n\tif (ret != sizeof(buf)) {\n\t\tdev_err(&client->dev, \"i2c_master_send != %zu: %d\\n\",\n\t\t\tsizeof(buf), ret);\n\t\t*err = -EIO;\n\t}\n}\n\nstatic int hi846_write_reg_list(struct hi846 *hi846,\n\t\t\t\tconst struct hi846_reg_list *r_list)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&hi846->sd);\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < r_list->num_of_regs; i++) {\n\t\thi846_write_reg_16(hi846, r_list->regs[i].address,\n\t\t\t\t   r_list->regs[i].val, &ret);\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(&client->dev,\n\t\t\t\t\t    \"failed to write reg 0x%4.4x: %d\",\n\t\t\t\t\t    r_list->regs[i].address, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int hi846_update_digital_gain(struct hi846 *hi846, u16 d_gain)\n{\n\tint ret = 0;\n\n\thi846_write_reg_16(hi846, HI846_REG_MWB_GR_GAIN_H, d_gain, &ret);\n\thi846_write_reg_16(hi846, HI846_REG_MWB_GB_GAIN_H, d_gain, &ret);\n\thi846_write_reg_16(hi846, HI846_REG_MWB_R_GAIN_H, d_gain, &ret);\n\thi846_write_reg_16(hi846, HI846_REG_MWB_B_GAIN_H, d_gain, &ret);\n\n\treturn ret;\n}\n\nstatic int hi846_test_pattern(struct hi846 *hi846, u32 pattern)\n{\n\tint ret;\n\tu8 val;\n\n\tif (pattern) {\n\t\tret = hi846_read_reg(hi846, HI846_REG_ISP, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = hi846_write_reg(hi846, HI846_REG_ISP,\n\t\t\t\t      val | HI846_REG_ISP_TPG_EN);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn hi846_write_reg(hi846, HI846_REG_TEST_PATTERN, pattern);\n}\n\nstatic int hi846_set_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct hi846 *hi846 = container_of(ctrl->handler,\n\t\t\t\t\t     struct hi846, ctrl_handler);\n\tstruct i2c_client *client = v4l2_get_subdevdata(&hi846->sd);\n\ts64 exposure_max;\n\tint ret = 0;\n\tu32 shutter, frame_len;\n\n\t \n\tif (ctrl->id == V4L2_CID_VBLANK) {\n\t\t \n\t\texposure_max = hi846->cur_mode->height + ctrl->val -\n\t\t\t       HI846_EXPOSURE_MAX_MARGIN;\n\t\t__v4l2_ctrl_modify_range(hi846->exposure,\n\t\t\t\t\t hi846->exposure->minimum,\n\t\t\t\t\t exposure_max, hi846->exposure->step,\n\t\t\t\t\t exposure_max);\n\t}\n\n\tret = pm_runtime_get_if_in_use(&client->dev);\n\tif (!ret || ret == -EAGAIN)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_ANALOGUE_GAIN:\n\t\tret = hi846_write_reg(hi846, HI846_REG_ANALOG_GAIN, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_DIGITAL_GAIN:\n\t\tret = hi846_update_digital_gain(hi846, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_EXPOSURE:\n\t\tshutter = ctrl->val;\n\t\tframe_len = hi846->cur_mode->frame_len;\n\n\t\tif (shutter > frame_len - 6) {  \n\t\t\tframe_len = shutter + 6;\n\t\t\tif (frame_len > 0xffff) {  \n\t\t\t\tframe_len = 0xffff;\n\t\t\t}\n\t\t}\n\n\t\tif (shutter < 6)\n\t\t\tshutter = 6;\n\t\tif (shutter > (0xffff - 6))\n\t\t\tshutter = 0xffff - 6;\n\n\t\thi846_write_reg_16(hi846, HI846_REG_FLL, frame_len, &ret);\n\t\thi846_write_reg_16(hi846, HI846_REG_EXPOSURE, shutter, &ret);\n\t\tbreak;\n\n\tcase V4L2_CID_VBLANK:\n\t\t \n\t\thi846_write_reg_16(hi846, HI846_REG_FLL,\n\t\t\t\t   hi846->cur_mode->height + ctrl->val, &ret);\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tret = hi846_test_pattern(hi846, ctrl->val);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tpm_runtime_put(&client->dev);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops hi846_ctrl_ops = {\n\t.s_ctrl = hi846_set_ctrl,\n};\n\nstatic int hi846_init_controls(struct hi846 *hi846)\n{\n\tstruct v4l2_ctrl_handler *ctrl_hdlr;\n\ts64 exposure_max, h_blank;\n\tint ret;\n\tstruct i2c_client *client = v4l2_get_subdevdata(&hi846->sd);\n\tstruct v4l2_fwnode_device_properties props;\n\n\tctrl_hdlr = &hi846->ctrl_handler;\n\tret = v4l2_ctrl_handler_init(ctrl_hdlr, 10);\n\tif (ret)\n\t\treturn ret;\n\n\tctrl_hdlr->lock = &hi846->mutex;\n\n\thi846->link_freq =\n\t\tv4l2_ctrl_new_int_menu(ctrl_hdlr, &hi846_ctrl_ops,\n\t\t\t\t       V4L2_CID_LINK_FREQ,\n\t\t\t\t       ARRAY_SIZE(hi846_link_freqs) - 1,\n\t\t\t\t       0, hi846_link_freqs);\n\tif (hi846->link_freq)\n\t\thi846->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\thi846->pixel_rate =\n\t\tv4l2_ctrl_new_std(ctrl_hdlr, &hi846_ctrl_ops,\n\t\t\t\t  V4L2_CID_PIXEL_RATE, 0,\n\t\t\t\t  hi846_calc_pixel_rate(hi846), 1,\n\t\t\t\t  hi846_calc_pixel_rate(hi846));\n\thi846->vblank = v4l2_ctrl_new_std(ctrl_hdlr, &hi846_ctrl_ops,\n\t\t\t\t\t  V4L2_CID_VBLANK,\n\t\t\t\t\t  hi846->cur_mode->frame_len -\n\t\t\t\t\t  hi846->cur_mode->height,\n\t\t\t\t\t  HI846_FLL_MAX -\n\t\t\t\t\t  hi846->cur_mode->height, 1,\n\t\t\t\t\t  hi846->cur_mode->frame_len -\n\t\t\t\t\t  hi846->cur_mode->height);\n\n\th_blank = hi846->cur_mode->llp - hi846->cur_mode->width;\n\n\thi846->hblank = v4l2_ctrl_new_std(ctrl_hdlr, &hi846_ctrl_ops,\n\t\t\t\t\t  V4L2_CID_HBLANK, h_blank, h_blank, 1,\n\t\t\t\t\t  h_blank);\n\tif (hi846->hblank)\n\t\thi846->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tv4l2_ctrl_new_std(ctrl_hdlr, &hi846_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,\n\t\t\t  HI846_ANAL_GAIN_MIN, HI846_ANAL_GAIN_MAX,\n\t\t\t  HI846_ANAL_GAIN_STEP, HI846_ANAL_GAIN_MIN);\n\tv4l2_ctrl_new_std(ctrl_hdlr, &hi846_ctrl_ops, V4L2_CID_DIGITAL_GAIN,\n\t\t\t  HI846_DGTL_GAIN_MIN, HI846_DGTL_GAIN_MAX,\n\t\t\t  HI846_DGTL_GAIN_STEP, HI846_DGTL_GAIN_DEFAULT);\n\texposure_max = hi846->cur_mode->frame_len - HI846_EXPOSURE_MAX_MARGIN;\n\thi846->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &hi846_ctrl_ops,\n\t\t\t\t\t    V4L2_CID_EXPOSURE,\n\t\t\t\t\t    HI846_EXPOSURE_MIN, exposure_max,\n\t\t\t\t\t    HI846_EXPOSURE_STEP,\n\t\t\t\t\t    exposure_max);\n\tv4l2_ctrl_new_std_menu_items(ctrl_hdlr, &hi846_ctrl_ops,\n\t\t\t\t     V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(hi846_test_pattern_menu) - 1,\n\t\t\t\t     0, 0, hi846_test_pattern_menu);\n\tif (ctrl_hdlr->error) {\n\t\tdev_err(&client->dev, \"v4l ctrl handler error: %d\\n\",\n\t\t\tctrl_hdlr->error);\n\t\tret = ctrl_hdlr->error;\n\t\tgoto error;\n\t}\n\n\tret = v4l2_fwnode_device_parse(&client->dev, &props);\n\tif (ret)\n\t\tgoto error;\n\n\tret = v4l2_ctrl_new_fwnode_properties(ctrl_hdlr, &hi846_ctrl_ops,\n\t\t\t\t\t      &props);\n\tif (ret)\n\t\tgoto error;\n\n\thi846->sd.ctrl_handler = ctrl_hdlr;\n\n\treturn 0;\n\nerror:\n\tv4l2_ctrl_handler_free(ctrl_hdlr);\n\treturn ret;\n}\n\nstatic int hi846_set_video_mode(struct hi846 *hi846, int fps)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&hi846->sd);\n\tu64 frame_length;\n\tint ret = 0;\n\tint dummy_lines;\n\tu64 link_freq = hi846_get_link_freq(hi846);\n\n\tdev_dbg(&client->dev, \"%s: link freq: %llu\\n\", __func__,\n\t\thi846_get_link_freq(hi846));\n\n\tdo_div(link_freq, fps);\n\tframe_length = link_freq;\n\tdo_div(frame_length, HI846_LINE_LENGTH);\n\n\tdummy_lines = (frame_length > hi846->cur_mode->frame_len) ?\n\t\t\t(frame_length - hi846->cur_mode->frame_len) : 0;\n\n\tframe_length = hi846->cur_mode->frame_len + dummy_lines;\n\n\tdev_dbg(&client->dev, \"%s: frame length calculated: %llu\\n\", __func__,\n\t\tframe_length);\n\n\thi846_write_reg_16(hi846, HI846_REG_FLL, frame_length & 0xFFFF, &ret);\n\thi846_write_reg_16(hi846, HI846_REG_LLP,\n\t\t\t   HI846_LINE_LENGTH & 0xFFFF, &ret);\n\n\treturn ret;\n}\n\nstatic int hi846_start_streaming(struct hi846 *hi846)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&hi846->sd);\n\tint ret = 0;\n\tu8 val;\n\n\tif (hi846->nr_lanes == 2)\n\t\tret = hi846_write_reg_list(hi846, &hi846_init_regs_list_2lane);\n\telse\n\t\tret = hi846_write_reg_list(hi846, &hi846_init_regs_list_4lane);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to set plls: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hi846_write_reg_list(hi846, &hi846->cur_mode->reg_list_config);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to set mode: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (hi846->nr_lanes == 2)\n\t\tret = hi846_write_reg_list(hi846,\n\t\t\t\t\t   &hi846->cur_mode->reg_list_2lane);\n\telse\n\t\tret = hi846_write_reg_list(hi846,\n\t\t\t\t\t   &hi846->cur_mode->reg_list_4lane);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to set mipi mode: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thi846_set_video_mode(hi846, hi846->cur_mode->fps);\n\n\tret = __v4l2_ctrl_handler_setup(hi846->sd.ctrl_handler);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = hi846_read_reg(hi846, 0x0034, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (!(val & BIT(2)))\n\t\tdev_info(&client->dev, \"visible pixel width and height is 0\\n\");\n\n\tret = hi846_write_reg(hi846, HI846_REG_MODE_SELECT,\n\t\t\t      HI846_MODE_STREAMING);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to start stream\");\n\t\treturn ret;\n\t}\n\n\thi846->streaming = 1;\n\n\tdev_dbg(&client->dev, \"%s: started streaming successfully\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic void hi846_stop_streaming(struct hi846 *hi846)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&hi846->sd);\n\n\tif (hi846_write_reg(hi846, HI846_REG_MODE_SELECT, HI846_MODE_STANDBY))\n\t\tdev_err(&client->dev, \"failed to stop stream\");\n\n\thi846->streaming = 0;\n}\n\nstatic int hi846_set_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct hi846 *hi846 = to_hi846(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret = 0;\n\n\tif (hi846->streaming == enable)\n\t\treturn 0;\n\n\tmutex_lock(&hi846->mutex);\n\n\tif (enable) {\n\t\tret = pm_runtime_get_sync(&client->dev);\n\t\tif (ret < 0) {\n\t\t\tpm_runtime_put_noidle(&client->dev);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = hi846_start_streaming(hi846);\n\t}\n\n\tif (!enable || ret) {\n\t\thi846_stop_streaming(hi846);\n\t\tpm_runtime_put(&client->dev);\n\t}\n\nout:\n\tmutex_unlock(&hi846->mutex);\n\n\treturn ret;\n}\n\nstatic int hi846_power_on(struct hi846 *hi846)\n{\n\tint ret;\n\n\tret = regulator_bulk_enable(HI846_NUM_SUPPLIES, hi846->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(hi846->clock);\n\tif (ret < 0)\n\t\tgoto err_reg;\n\n\tif (hi846->shutdown_gpio)\n\t\tgpiod_set_value_cansleep(hi846->shutdown_gpio, 0);\n\n\t \n\tusleep_range(30, 60);\n\tif (hi846->rst_gpio)\n\t\tgpiod_set_value_cansleep(hi846->rst_gpio, 0);\n\tusleep_range(30, 60);\n\n\treturn 0;\n\nerr_reg:\n\tregulator_bulk_disable(HI846_NUM_SUPPLIES, hi846->supplies);\n\n\treturn ret;\n}\n\nstatic int hi846_power_off(struct hi846 *hi846)\n{\n\tif (hi846->rst_gpio)\n\t\tgpiod_set_value_cansleep(hi846->rst_gpio, 1);\n\n\tif (hi846->shutdown_gpio)\n\t\tgpiod_set_value_cansleep(hi846->shutdown_gpio, 1);\n\n\tclk_disable_unprepare(hi846->clock);\n\treturn regulator_bulk_disable(HI846_NUM_SUPPLIES, hi846->supplies);\n}\n\nstatic int __maybe_unused hi846_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct hi846 *hi846 = to_hi846(sd);\n\n\tif (hi846->streaming)\n\t\thi846_stop_streaming(hi846);\n\n\treturn hi846_power_off(hi846);\n}\n\nstatic int __maybe_unused hi846_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct hi846 *hi846 = to_hi846(sd);\n\tint ret;\n\n\tret = hi846_power_on(hi846);\n\tif (ret)\n\t\treturn ret;\n\n\tif (hi846->streaming) {\n\t\tret = hi846_start_streaming(hi846);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s: start streaming failed: %d\\n\",\n\t\t\t\t__func__, ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror:\n\thi846_power_off(hi846);\n\treturn ret;\n}\n\nstatic int hi846_set_format(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    struct v4l2_subdev_format *format)\n{\n\tstruct hi846 *hi846 = to_hi846(sd);\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tconst struct hi846_datafmt *fmt = hi846_find_datafmt(mf->code);\n\tu32 tgt_fps;\n\ts32 vblank_def, h_blank;\n\n\tif (!fmt) {\n\t\tmf->code = hi846_colour_fmts[0].code;\n\t\tmf->colorspace = hi846_colour_fmts[0].colorspace;\n\t\tfmt = &hi846_colour_fmts[0];\n\t}\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\t*v4l2_subdev_get_try_format(sd, sd_state, format->pad) = *mf;\n\t\treturn 0;\n\t}\n\n\tif (hi846->nr_lanes == 2) {\n\t\tif (!hi846->cur_mode->reg_list_2lane.num_of_regs) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"this mode is not supported for 2 lanes\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (!hi846->cur_mode->reg_list_4lane.num_of_regs) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"this mode is not supported for 4 lanes\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmutex_lock(&hi846->mutex);\n\n\tif (hi846->streaming) {\n\t\tmutex_unlock(&hi846->mutex);\n\t\treturn -EBUSY;\n\t}\n\n\thi846->fmt = fmt;\n\n\thi846->cur_mode =\n\t\tv4l2_find_nearest_size(supported_modes,\n\t\t\t\t       ARRAY_SIZE(supported_modes),\n\t\t\t\t       width, height, mf->width, mf->height);\n\tdev_dbg(&client->dev, \"%s: found mode: %dx%d\\n\", __func__,\n\t\thi846->cur_mode->width, hi846->cur_mode->height);\n\n\ttgt_fps = hi846->cur_mode->fps;\n\tdev_dbg(&client->dev, \"%s: target fps: %d\\n\", __func__, tgt_fps);\n\n\tmf->width = hi846->cur_mode->width;\n\tmf->height = hi846->cur_mode->height;\n\tmf->code = HI846_MEDIA_BUS_FORMAT;\n\tmf->field = V4L2_FIELD_NONE;\n\n\t__v4l2_ctrl_s_ctrl(hi846->link_freq, hi846_get_link_freq_index(hi846));\n\t__v4l2_ctrl_s_ctrl_int64(hi846->pixel_rate,\n\t\t\t\t hi846_calc_pixel_rate(hi846));\n\n\t \n\tvblank_def = hi846->cur_mode->frame_len - hi846->cur_mode->height;\n\t__v4l2_ctrl_modify_range(hi846->vblank,\n\t\t\t\t hi846->cur_mode->frame_len -\n\t\t\t\t\thi846->cur_mode->height,\n\t\t\t\t HI846_FLL_MAX - hi846->cur_mode->height, 1,\n\t\t\t\t vblank_def);\n\t__v4l2_ctrl_s_ctrl(hi846->vblank, vblank_def);\n\n\th_blank = hi846->cur_mode->llp - hi846->cur_mode->width;\n\n\t__v4l2_ctrl_modify_range(hi846->hblank, h_blank, h_blank, 1,\n\t\t\t\t h_blank);\n\n\tdev_dbg(&client->dev, \"Set fmt w=%d h=%d code=0x%x colorspace=0x%x\\n\",\n\t\tmf->width, mf->height,\n\t\tfmt->code, fmt->colorspace);\n\n\tmutex_unlock(&hi846->mutex);\n\n\treturn 0;\n}\n\nstatic int hi846_get_format(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    struct v4l2_subdev_format *format)\n{\n\tstruct hi846 *hi846 = to_hi846(sd);\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tformat->format = *v4l2_subdev_get_try_format(&hi846->sd,\n\t\t\t\t\t\t\tsd_state,\n\t\t\t\t\t\t\tformat->pad);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&hi846->mutex);\n\tmf->code        = HI846_MEDIA_BUS_FORMAT;\n\tmf->colorspace  = V4L2_COLORSPACE_RAW;\n\tmf->field       = V4L2_FIELD_NONE;\n\tmf->width       = hi846->cur_mode->width;\n\tmf->height      = hi846->cur_mode->height;\n\tmutex_unlock(&hi846->mutex);\n\tdev_dbg(&client->dev,\n\t\t\"Get format w=%d h=%d code=0x%x colorspace=0x%x\\n\",\n\t\tmf->width, mf->height, mf->code, mf->colorspace);\n\n\treturn 0;\n}\n\nstatic int hi846_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index > 0)\n\t\treturn -EINVAL;\n\n\tcode->code = HI846_MEDIA_BUS_FORMAT;\n\n\treturn 0;\n}\n\nstatic int hi846_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tif (fse->pad || fse->index >= ARRAY_SIZE(supported_modes))\n\t\treturn -EINVAL;\n\n\tif (fse->code != HI846_MEDIA_BUS_FORMAT) {\n\t\tdev_err(&client->dev, \"frame size enum not matching\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfse->min_width = supported_modes[fse->index].width;\n\tfse->max_width = supported_modes[fse->index].width;\n\tfse->min_height = supported_modes[fse->index].height;\n\tfse->max_height = supported_modes[fse->index].height;\n\n\tdev_dbg(&client->dev, \"%s: max width: %d max height: %d\\n\", __func__,\n\t\tfse->max_width, fse->max_height);\n\n\treturn 0;\n}\n\nstatic int hi846_get_selection(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_selection *sel)\n{\n\tstruct hi846 *hi846 = to_hi846(sd);\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tmutex_lock(&hi846->mutex);\n\t\tswitch (sel->which) {\n\t\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\t\tv4l2_subdev_get_try_crop(sd, sd_state, sel->pad);\n\t\t\tbreak;\n\t\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\t\tsel->r = hi846->cur_mode->crop;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&hi846->mutex);\n\t\treturn 0;\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_NATIVE_SIZE:\n\t\tsel->r.top = 0;\n\t\tsel->r.left = 0;\n\t\tsel->r.width = 3264;\n\t\tsel->r.height = 2448;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int hi846_init_cfg(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state)\n{\n\tstruct hi846 *hi846 = to_hi846(sd);\n\tstruct v4l2_mbus_framefmt *mf;\n\n\tmf = v4l2_subdev_get_try_format(sd, sd_state, 0);\n\n\tmutex_lock(&hi846->mutex);\n\tmf->code        = HI846_MEDIA_BUS_FORMAT;\n\tmf->colorspace  = V4L2_COLORSPACE_RAW;\n\tmf->field       = V4L2_FIELD_NONE;\n\tmf->width       = hi846->cur_mode->width;\n\tmf->height      = hi846->cur_mode->height;\n\tmutex_unlock(&hi846->mutex);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops hi846_video_ops = {\n\t.s_stream = hi846_set_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops hi846_pad_ops = {\n\t.init_cfg = hi846_init_cfg,\n\t.enum_frame_size = hi846_enum_frame_size,\n\t.enum_mbus_code = hi846_enum_mbus_code,\n\t.set_fmt = hi846_set_format,\n\t.get_fmt = hi846_get_format,\n\t.get_selection = hi846_get_selection,\n};\n\nstatic const struct v4l2_subdev_ops hi846_subdev_ops = {\n\t.video = &hi846_video_ops,\n\t.pad = &hi846_pad_ops,\n};\n\nstatic const struct media_entity_operations hi846_subdev_entity_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic int hi846_identify_module(struct hi846 *hi846)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&hi846->sd);\n\tint ret;\n\tu8 hi, lo;\n\n\tret = hi846_read_reg(hi846, HI846_REG_CHIP_ID_L, &lo);\n\tif (ret)\n\t\treturn ret;\n\n\tif (lo != HI846_CHIP_ID_L) {\n\t\tdev_err(&client->dev, \"wrong chip id low byte: %x\", lo);\n\t\treturn -ENXIO;\n\t}\n\n\tret = hi846_read_reg(hi846, HI846_REG_CHIP_ID_H, &hi);\n\tif (ret)\n\t\treturn ret;\n\n\tif (hi != HI846_CHIP_ID_H) {\n\t\tdev_err(&client->dev, \"wrong chip id high byte: %x\", hi);\n\t\treturn -ENXIO;\n\t}\n\n\tdev_info(&client->dev, \"chip id %02X %02X using %d mipi lanes\\n\",\n\t\t hi, lo, hi846->nr_lanes);\n\n\treturn 0;\n}\n\nstatic s64 hi846_check_link_freqs(struct hi846 *hi846,\n\t\t\t\t  struct v4l2_fwnode_endpoint *ep)\n{\n\tconst s64 *freqs = hi846_link_freqs;\n\tint freqs_count = ARRAY_SIZE(hi846_link_freqs);\n\tint i, j;\n\n\tfor (i = 0; i < freqs_count; i++) {\n\t\tfor (j = 0; j < ep->nr_of_link_frequencies; j++)\n\t\t\tif (freqs[i] == ep->link_frequencies[j])\n\t\t\t\tbreak;\n\t\tif (j == ep->nr_of_link_frequencies)\n\t\t\treturn freqs[i];\n\t}\n\n\treturn 0;\n}\n\nstatic int hi846_parse_dt(struct hi846 *hi846, struct device *dev)\n{\n\tstruct fwnode_handle *ep;\n\tstruct fwnode_handle *fwnode = dev_fwnode(dev);\n\tstruct v4l2_fwnode_endpoint bus_cfg = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY\n\t};\n\tint ret;\n\ts64 fq;\n\n\tep = fwnode_graph_get_next_endpoint(fwnode, NULL);\n\tif (!ep) {\n\t\tdev_err(dev, \"unable to find endpoint node\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tret = v4l2_fwnode_endpoint_alloc_parse(ep, &bus_cfg);\n\tfwnode_handle_put(ep);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to parse endpoint node: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (bus_cfg.bus.mipi_csi2.num_data_lanes != 2 &&\n\t    bus_cfg.bus.mipi_csi2.num_data_lanes != 4) {\n\t\tdev_err(dev, \"number of CSI2 data lanes %d is not supported\",\n\t\t\tbus_cfg.bus.mipi_csi2.num_data_lanes);\n\t\tret = -EINVAL;\n\t\tgoto check_hwcfg_error;\n\t}\n\n\thi846->nr_lanes = bus_cfg.bus.mipi_csi2.num_data_lanes;\n\n\tif (!bus_cfg.nr_of_link_frequencies) {\n\t\tdev_err(dev, \"link-frequency property not found in DT\\n\");\n\t\tret = -EINVAL;\n\t\tgoto check_hwcfg_error;\n\t}\n\n\t \n\tfq = hi846_check_link_freqs(hi846, &bus_cfg);\n\tif (fq) {\n\t\tdev_err(dev, \"Link frequency of %lld is not supported\\n\", fq);\n\t\tret = -EINVAL;\n\t\tgoto check_hwcfg_error;\n\t}\n\n\tv4l2_fwnode_endpoint_free(&bus_cfg);\n\n\thi846->rst_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(hi846->rst_gpio)) {\n\t\tdev_err(dev, \"failed to get reset gpio: %pe\\n\",\n\t\t\thi846->rst_gpio);\n\t\treturn PTR_ERR(hi846->rst_gpio);\n\t}\n\n\thi846->shutdown_gpio = devm_gpiod_get_optional(dev, \"shutdown\",\n\t\t\t\t\t\t       GPIOD_OUT_LOW);\n\tif (IS_ERR(hi846->shutdown_gpio)) {\n\t\tdev_err(dev, \"failed to get shutdown gpio: %pe\\n\",\n\t\t\thi846->shutdown_gpio);\n\t\treturn PTR_ERR(hi846->shutdown_gpio);\n\t}\n\n\treturn 0;\n\ncheck_hwcfg_error:\n\tv4l2_fwnode_endpoint_free(&bus_cfg);\n\treturn ret;\n}\n\nstatic int hi846_probe(struct i2c_client *client)\n{\n\tstruct hi846 *hi846;\n\tint ret;\n\tint i;\n\tu32 mclk_freq;\n\n\thi846 = devm_kzalloc(&client->dev, sizeof(*hi846), GFP_KERNEL);\n\tif (!hi846)\n\t\treturn -ENOMEM;\n\n\tret = hi846_parse_dt(hi846, &client->dev);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to check HW configuration: %d\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\thi846->clock = devm_clk_get(&client->dev, NULL);\n\tif (IS_ERR(hi846->clock)) {\n\t\tdev_err(&client->dev, \"failed to get clock: %pe\\n\",\n\t\t\thi846->clock);\n\t\treturn PTR_ERR(hi846->clock);\n\t}\n\n\tmclk_freq = clk_get_rate(hi846->clock);\n\tif (mclk_freq != 25000000)\n\t\tdev_warn(&client->dev,\n\t\t\t \"External clock freq should be 25000000, not %u.\\n\",\n\t\t\t mclk_freq);\n\n\tfor (i = 0; i < HI846_NUM_SUPPLIES; i++)\n\t\thi846->supplies[i].supply = hi846_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&client->dev, HI846_NUM_SUPPLIES,\n\t\t\t\t      hi846->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv4l2_i2c_subdev_init(&hi846->sd, client, &hi846_subdev_ops);\n\n\tmutex_init(&hi846->mutex);\n\n\tret = hi846_power_on(hi846);\n\tif (ret)\n\t\tgoto err_mutex;\n\n\tret = hi846_identify_module(hi846);\n\tif (ret)\n\t\tgoto err_power_off;\n\n\thi846->cur_mode = &supported_modes[0];\n\n\tret = hi846_init_controls(hi846);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to init controls: %d\", ret);\n\t\tgoto err_power_off;\n\t}\n\n\thi846->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\thi846->sd.entity.ops = &hi846_subdev_entity_ops;\n\thi846->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\thi846->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tret = media_entity_pads_init(&hi846->sd.entity, 1, &hi846->pad);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to init entity pads: %d\", ret);\n\t\tgoto err_v4l2_ctrl_handler_free;\n\t}\n\n\tret = v4l2_async_register_subdev_sensor(&hi846->sd);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to register V4L2 subdev: %d\",\n\t\t\tret);\n\t\tgoto err_media_entity_cleanup;\n\t}\n\n\tpm_runtime_set_active(&client->dev);\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_idle(&client->dev);\n\n\treturn 0;\n\nerr_media_entity_cleanup:\n\tmedia_entity_cleanup(&hi846->sd.entity);\n\nerr_v4l2_ctrl_handler_free:\n\tv4l2_ctrl_handler_free(hi846->sd.ctrl_handler);\n\nerr_power_off:\n\thi846_power_off(hi846);\n\nerr_mutex:\n\tmutex_destroy(&hi846->mutex);\n\n\treturn ret;\n}\n\nstatic void hi846_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct hi846 *hi846 = to_hi846(sd);\n\n\tv4l2_async_unregister_subdev(sd);\n\tmedia_entity_cleanup(&sd->entity);\n\tv4l2_ctrl_handler_free(sd->ctrl_handler);\n\n\tpm_runtime_disable(&client->dev);\n\tif (!pm_runtime_status_suspended(&client->dev))\n\t\thi846_suspend(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\n\tmutex_destroy(&hi846->mutex);\n}\n\nstatic const struct dev_pm_ops hi846_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(hi846_suspend, hi846_resume, NULL)\n};\n\nstatic const struct of_device_id hi846_of_match[] = {\n\t{ .compatible = \"hynix,hi846\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, hi846_of_match);\n\nstatic struct i2c_driver hi846_i2c_driver = {\n\t.driver = {\n\t\t.name = \"hi846\",\n\t\t.pm = &hi846_pm_ops,\n\t\t.of_match_table = hi846_of_match,\n\t},\n\t.probe = hi846_probe,\n\t.remove = hi846_remove,\n};\n\nmodule_i2c_driver(hi846_i2c_driver);\n\nMODULE_AUTHOR(\"Angus Ainslie <angus@akkea.ca>\");\nMODULE_AUTHOR(\"Martin Kepplinger <martin.kepplinger@puri.sm>\");\nMODULE_DESCRIPTION(\"Hynix HI846 sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}