{
  "module_name": "saa7185.c",
  "hash_id": "2093710f329d438f8c33645c84e8aa01974548ffeb09876fc5cabe8d5fca7c64",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/saa7185.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/ioctl.h>\n#include <linux/uaccess.h>\n#include <linux/i2c.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n\nMODULE_DESCRIPTION(\"Philips SAA7185 video encoder driver\");\nMODULE_AUTHOR(\"Dave Perks\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int debug;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"Debug level (0-1)\");\n\n\n \n\nstruct saa7185 {\n\tstruct v4l2_subdev sd;\n\tunsigned char reg[128];\n\n\tv4l2_std_id norm;\n};\n\nstatic inline struct saa7185 *to_saa7185(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct saa7185, sd);\n}\n\n \n\nstatic inline int saa7185_read(struct v4l2_subdev *sd)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn i2c_smbus_read_byte(client);\n}\n\nstatic int saa7185_write(struct v4l2_subdev *sd, u8 reg, u8 value)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct saa7185 *encoder = to_saa7185(sd);\n\n\tv4l2_dbg(1, debug, sd, \"%02x set to %02x\\n\", reg, value);\n\tencoder->reg[reg] = value;\n\treturn i2c_smbus_write_byte_data(client, reg, value);\n}\n\nstatic int saa7185_write_block(struct v4l2_subdev *sd,\n\t\tconst u8 *data, unsigned int len)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct saa7185 *encoder = to_saa7185(sd);\n\tint ret = -1;\n\tu8 reg;\n\n\t \n\tif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\t \n\t\tu8 block_data[32];\n\t\tint block_len;\n\n\t\twhile (len >= 2) {\n\t\t\tblock_len = 0;\n\t\t\tblock_data[block_len++] = reg = data[0];\n\t\t\tdo {\n\t\t\t\tblock_data[block_len++] =\n\t\t\t\t    encoder->reg[reg++] = data[1];\n\t\t\t\tlen -= 2;\n\t\t\t\tdata += 2;\n\t\t\t} while (len >= 2 && data[0] == reg && block_len < 32);\n\t\t\tret = i2c_master_send(client, block_data, block_len);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\twhile (len >= 2) {\n\t\t\treg = *data++;\n\t\t\tret = saa7185_write(sd, reg, *data++);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tlen -= 2;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic const unsigned char init_common[] = {\n\t0x3a, 0x0f,\t\t \n\n\t0x42, 0x6b,\t\t \n\t0x43, 0x00,\t\t \n\t0x44, 0x00,\t\t \n\t0x45, 0x22,\t\t \n\t0x46, 0xac,\t\t \n\t0x47, 0x0e,\t\t \n\t0x48, 0x03,\t\t \n\t0x49, 0x1d,\t\t \n\t0x4a, 0xac,\t\t \n\t0x4b, 0xf0,\t\t \n\t0x4c, 0xc8,\t\t \n\t0x4d, 0xb9,\t\t \n\t0x4e, 0xd4,\t\t \n\t0x4f, 0x38,\t\t \n\t0x50, 0x47,\t\t \n\t0x51, 0xc1,\t\t \n\t0x52, 0xe3,\t\t \n\t0x53, 0x54,\t\t \n\t0x54, 0xa3,\t\t \n\t0x55, 0x54,\t\t \n\t0x56, 0xf2,\t\t \n\t0x57, 0x90,\t\t \n\t0x58, 0x00,\t\t \n\t0x59, 0x00,\t\t \n\n\t0x5a, 0x00,\t\t \n\t0x5b, 0x76,\t\t \n\t0x5c, 0xa5,\t\t \n\t0x5d, 0x3c,\t\t \n\t0x5e, 0x3a,\t\t \n\t0x5f, 0x3a,\t\t \n\t0x60, 0x00,\t\t \n\n\t \n\n\t0x67, 0x00,\t\t \n\t0x68, 0x00,\t\t \n\t0x69, 0x00,\t\t \n\t0x6a, 0x00,\t\t \n\n\t0x6b, 0x91,\t\t \n\t0x6c, 0x20,\t\t \n\t0x6d, 0x00,\t\t \n\n\t0x6e, 0x0e,\t\t \n\t0x6f, 0x00,\t\t \n\t0x70, 0x20,\t\t \n\n\t \n\n\t0x71, 0x15,\t\t \n\t0x72, 0x90,\t\t \n\t0x73, 0x61,\t\t \n\t0x74, 0x00,\t\t \n\t0x75, 0x00,\t\t \n\t0x76, 0x00,\t\t \n\t0x77, 0x15,\t\t \n\t0x78, 0x90,\t\t \n\t0x79, 0x61,\t\t \n\n\t \n\n\t0x7a, 0x70,\t\t \n\n\t \n\n\t0x7b, 0x16,\t\t \n\t0x7c, 0x35,\t\t \n\t0x7d, 0x20,\t\t \n};\n\nstatic const unsigned char init_pal[] = {\n\t0x61, 0x1e,\t\t \n\t0x62, 0xc8,\t\t \n\t0x63, 0xcb,\t\t \n\t0x64, 0x8a,\t\t \n\t0x65, 0x09,\t\t \n\t0x66, 0x2a,\t\t \n};\n\nstatic const unsigned char init_ntsc[] = {\n\t0x61, 0x1d,\t\t \n\t0x62, 0xe6,\t\t \n\t0x63, 0x1f,\t\t \n\t0x64, 0x7c,\t\t \n\t0x65, 0xf0,\t\t \n\t0x66, 0x21,\t\t \n};\n\n\nstatic int saa7185_init(struct v4l2_subdev *sd, u32 val)\n{\n\tstruct saa7185 *encoder = to_saa7185(sd);\n\n\tsaa7185_write_block(sd, init_common, sizeof(init_common));\n\tif (encoder->norm & V4L2_STD_NTSC)\n\t\tsaa7185_write_block(sd, init_ntsc, sizeof(init_ntsc));\n\telse\n\t\tsaa7185_write_block(sd, init_pal, sizeof(init_pal));\n\treturn 0;\n}\n\nstatic int saa7185_s_std_output(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct saa7185 *encoder = to_saa7185(sd);\n\n\tif (std & V4L2_STD_NTSC)\n\t\tsaa7185_write_block(sd, init_ntsc, sizeof(init_ntsc));\n\telse if (std & V4L2_STD_PAL)\n\t\tsaa7185_write_block(sd, init_pal, sizeof(init_pal));\n\telse\n\t\treturn -EINVAL;\n\tencoder->norm = std;\n\treturn 0;\n}\n\nstatic int saa7185_s_routing(struct v4l2_subdev *sd,\n\t\t\t     u32 input, u32 output, u32 config)\n{\n\tstruct saa7185 *encoder = to_saa7185(sd);\n\n\t \n\n\tswitch (input) {\n\tcase 0:\n\t\t \n\t\tsaa7185_write(sd, 0x3a, 0x0f);\n\t\t \n\t\tsaa7185_write(sd, 0x61, (encoder->reg[0x61] & 0xf7) | 0x08);\n\t\tsaa7185_write(sd, 0x6e, 0x01);\n\t\tbreak;\n\n\tcase 1:\n\t\t \n\t\tsaa7185_write(sd, 0x3a, 0x0f);\n\t\t \n\t\tsaa7185_write(sd, 0x61, (encoder->reg[0x61] & 0xf7) | 0x00);\n\t\t \n\t\tsaa7185_write(sd, 0x6e, 0x00);\n\t\tbreak;\n\n\tcase 2:\n\t\t \n\t\tsaa7185_write(sd, 0x3a, 0x8f);\n\t\t \n\t\tsaa7185_write(sd, 0x61, (encoder->reg[0x61] & 0xf7) | 0x08);\n\t\t \n\t\tsaa7185_write(sd, 0x6e, 0x01);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_subdev_core_ops saa7185_core_ops = {\n\t.init = saa7185_init,\n};\n\nstatic const struct v4l2_subdev_video_ops saa7185_video_ops = {\n\t.s_std_output = saa7185_s_std_output,\n\t.s_routing = saa7185_s_routing,\n};\n\nstatic const struct v4l2_subdev_ops saa7185_ops = {\n\t.core = &saa7185_core_ops,\n\t.video = &saa7185_video_ops,\n};\n\n\n \n\nstatic int saa7185_probe(struct i2c_client *client)\n{\n\tint i;\n\tstruct saa7185 *encoder;\n\tstruct v4l2_subdev *sd;\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tv4l_info(client, \"chip found @ 0x%x (%s)\\n\",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tencoder = devm_kzalloc(&client->dev, sizeof(*encoder), GFP_KERNEL);\n\tif (encoder == NULL)\n\t\treturn -ENOMEM;\n\tencoder->norm = V4L2_STD_NTSC;\n\tsd = &encoder->sd;\n\tv4l2_i2c_subdev_init(sd, client, &saa7185_ops);\n\n\ti = saa7185_write_block(sd, init_common, sizeof(init_common));\n\tif (i >= 0)\n\t\ti = saa7185_write_block(sd, init_ntsc, sizeof(init_ntsc));\n\tif (i < 0)\n\t\tv4l2_dbg(1, debug, sd, \"init error %d\\n\", i);\n\telse\n\t\tv4l2_dbg(1, debug, sd, \"revision 0x%x\\n\",\n\t\t\t\tsaa7185_read(sd) >> 5);\n\treturn 0;\n}\n\nstatic void saa7185_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct saa7185 *encoder = to_saa7185(sd);\n\n\tv4l2_device_unregister_subdev(sd);\n\t \n\tsaa7185_write(sd, 0x61, (encoder->reg[0x61]) | 0x40);\n}\n\n \n\nstatic const struct i2c_device_id saa7185_id[] = {\n\t{ \"saa7185\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, saa7185_id);\n\nstatic struct i2c_driver saa7185_driver = {\n\t.driver = {\n\t\t.name\t= \"saa7185\",\n\t},\n\t.probe\t\t= saa7185_probe,\n\t.remove\t\t= saa7185_remove,\n\t.id_table\t= saa7185_id,\n};\n\nmodule_i2c_driver(saa7185_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}