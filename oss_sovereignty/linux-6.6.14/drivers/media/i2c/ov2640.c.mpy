{
  "module_name": "ov2640.c",
  "hash_id": "002d05a951534f13463323d9263108ae99a1805a3c0a525df3445b6e4fdefa85",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ov2640.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/clk.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/v4l2-mediabus.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-subdev.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-image-sizes.h>\n\n#define VAL_SET(x, mask, rshift, lshift)  \\\n\t\t((((x) >> rshift) & mask) << lshift)\n \n#define R_BYPASS    0x05  \n#define   R_BYPASS_DSP_BYPAS    0x01  \n#define   R_BYPASS_USE_DSP      0x00  \n#define QS          0x44  \n#define CTRLI       0x50\n#define   CTRLI_LP_DP           0x80\n#define   CTRLI_ROUND           0x40\n#define   CTRLI_V_DIV_SET(x)    VAL_SET(x, 0x3, 0, 3)\n#define   CTRLI_H_DIV_SET(x)    VAL_SET(x, 0x3, 0, 0)\n#define HSIZE       0x51  \n#define   HSIZE_SET(x)          VAL_SET(x, 0xFF, 2, 0)\n#define VSIZE       0x52  \n#define   VSIZE_SET(x)          VAL_SET(x, 0xFF, 2, 0)\n#define XOFFL       0x53  \n#define   XOFFL_SET(x)          VAL_SET(x, 0xFF, 0, 0)\n#define YOFFL       0x54  \n#define   YOFFL_SET(x)          VAL_SET(x, 0xFF, 0, 0)\n#define VHYX        0x55  \n#define   VHYX_VSIZE_SET(x)     VAL_SET(x, 0x1, (8+2), 7)\n#define   VHYX_HSIZE_SET(x)     VAL_SET(x, 0x1, (8+2), 3)\n#define   VHYX_YOFF_SET(x)      VAL_SET(x, 0x3, 8, 4)\n#define   VHYX_XOFF_SET(x)      VAL_SET(x, 0x3, 8, 0)\n#define DPRP        0x56\n#define TEST        0x57  \n#define   TEST_HSIZE_SET(x)     VAL_SET(x, 0x1, (9+2), 7)\n#define ZMOW        0x5A  \n#define   ZMOW_OUTW_SET(x)      VAL_SET(x, 0xFF, 2, 0)\n#define ZMOH        0x5B  \n#define   ZMOH_OUTH_SET(x)      VAL_SET(x, 0xFF, 2, 0)\n#define ZMHH        0x5C  \n#define   ZMHH_ZSPEED_SET(x)    VAL_SET(x, 0x0F, 0, 4)\n#define   ZMHH_OUTH_SET(x)      VAL_SET(x, 0x1, (8+2), 2)\n#define   ZMHH_OUTW_SET(x)      VAL_SET(x, 0x3, (8+2), 0)\n#define BPADDR      0x7C  \n#define BPDATA      0x7D  \n#define CTRL2       0x86  \n#define   CTRL2_DCW_EN          0x20\n#define   CTRL2_SDE_EN          0x10\n#define   CTRL2_UV_ADJ_EN       0x08\n#define   CTRL2_UV_AVG_EN       0x04\n#define   CTRL2_CMX_EN          0x01\n#define CTRL3       0x87  \n#define   CTRL3_BPC_EN          0x80\n#define   CTRL3_WPC_EN          0x40\n#define SIZEL       0x8C  \n#define   SIZEL_HSIZE8_11_SET(x) VAL_SET(x, 0x1, 11, 6)\n#define   SIZEL_HSIZE8_SET(x)    VAL_SET(x, 0x7, 0, 3)\n#define   SIZEL_VSIZE8_SET(x)    VAL_SET(x, 0x7, 0, 0)\n#define HSIZE8      0xC0  \n#define   HSIZE8_SET(x)         VAL_SET(x, 0xFF, 3, 0)\n#define VSIZE8      0xC1  \n#define   VSIZE8_SET(x)         VAL_SET(x, 0xFF, 3, 0)\n#define CTRL0       0xC2  \n#define   CTRL0_AEC_EN       0x80\n#define   CTRL0_AEC_SEL      0x40\n#define   CTRL0_STAT_SEL     0x20\n#define   CTRL0_VFIRST       0x10\n#define   CTRL0_YUV422       0x08\n#define   CTRL0_YUV_EN       0x04\n#define   CTRL0_RGB_EN       0x02\n#define   CTRL0_RAW_EN       0x01\n#define CTRL1       0xC3  \n#define   CTRL1_CIP          0x80\n#define   CTRL1_DMY          0x40\n#define   CTRL1_RAW_GMA      0x20\n#define   CTRL1_DG           0x10\n#define   CTRL1_AWB          0x08\n#define   CTRL1_AWB_GAIN     0x04\n#define   CTRL1_LENC         0x02\n#define   CTRL1_PRE          0x01\n \n#define R_DVP_SP    0xD3  \n#define   R_DVP_SP_AUTO_MODE 0x80\n#define   R_DVP_SP_DVP_MASK  0x3F  \n#define IMAGE_MODE  0xDA  \n#define   IMAGE_MODE_Y8_DVP_EN   0x40\n#define   IMAGE_MODE_JPEG_EN     0x10\n#define   IMAGE_MODE_YUV422      0x00\n#define   IMAGE_MODE_RAW10       0x04  \n#define   IMAGE_MODE_RGB565      0x08\n#define   IMAGE_MODE_HREF_VSYNC  0x02  \n#define   IMAGE_MODE_LBYTE_FIRST 0x01  \n#define RESET       0xE0  \n#define   RESET_MICROC       0x40\n#define   RESET_SCCB         0x20\n#define   RESET_JPEG         0x10\n#define   RESET_DVP          0x04\n#define   RESET_IPU          0x02\n#define   RESET_CIF          0x01\n#define REGED       0xED  \n#define   REGED_CLK_OUT_DIS  0x10\n#define MS_SP       0xF0  \n#define SS_ID       0xF7  \n#define SS_CTRL     0xF8  \n#define   SS_CTRL_ADD_AUTO_INC  0x20\n#define   SS_CTRL_EN            0x08\n#define   SS_CTRL_DELAY_CLK     0x04\n#define   SS_CTRL_ACC_EN        0x02\n#define   SS_CTRL_SEN_PASS_THR  0x01\n#define MC_BIST     0xF9  \n#define   MC_BIST_RESET           0x80  \n#define   MC_BIST_BOOT_ROM_SEL    0x40\n#define   MC_BIST_12KB_SEL        0x20\n#define   MC_BIST_12KB_MASK       0x30\n#define   MC_BIST_512KB_SEL       0x08\n#define   MC_BIST_512KB_MASK      0x0C\n#define   MC_BIST_BUSY_BIT_R      0x02\n#define   MC_BIST_MC_RES_ONE_SH_W 0x02\n#define   MC_BIST_LAUNCH          0x01\n#define BANK_SEL    0xFF  \n#define   BANK_SEL_DSP     0x00\n#define   BANK_SEL_SENS    0x01\n\n \n#define GAIN        0x00  \n#define COM1        0x03  \n#define   COM1_1_DUMMY_FR          0x40\n#define   COM1_3_DUMMY_FR          0x80\n#define   COM1_7_DUMMY_FR          0xC0\n#define   COM1_VWIN_LSB_UXGA       0x0F\n#define   COM1_VWIN_LSB_SVGA       0x0A\n#define   COM1_VWIN_LSB_CIF        0x06\n#define REG04       0x04  \n#define   REG04_DEF             0x20  \n#define   REG04_HFLIP_IMG       0x80  \n#define   REG04_VFLIP_IMG       0x40  \n#define   REG04_VREF_EN         0x10\n#define   REG04_HREF_EN         0x08\n#define   REG04_AEC_SET(x)      VAL_SET(x, 0x3, 0, 0)\n#define REG08       0x08  \n#define COM2        0x09  \n#define   COM2_SOFT_SLEEP_MODE  0x10  \n\t\t\t\t      \n#define   COM2_OCAP_Nx_SET(N)   (((N) - 1) & 0x03)  \n#define PID         0x0A  \n#define VER         0x0B  \n#define COM3        0x0C  \n#define   COM3_BAND_50H        0x04  \n#define   COM3_BAND_AUTO       0x02  \n#define   COM3_SING_FR_SNAPSH  0x01  \n#define AEC         0x10  \n#define CLKRC       0x11  \n#define   CLKRC_EN             0x80\n#define   CLKRC_DIV_SET(x)     (((x) - 1) & 0x1F)  \n#define COM7        0x12  \n#define   COM7_SRST            0x80  \n#define   COM7_RES_UXGA        0x00  \n#define   COM7_RES_SVGA        0x40  \n#define   COM7_RES_CIF         0x20  \n#define   COM7_ZOOM_EN         0x04  \n#define   COM7_COLOR_BAR_TEST  0x02  \n#define COM8        0x13  \n#define   COM8_DEF             0xC0\n#define   COM8_BNDF_EN         0x20  \n#define   COM8_AGC_EN          0x04  \n#define   COM8_AEC_EN          0x01  \n#define COM9        0x14  \n#define   COM9_AGC_GAIN_2x     0x00  \n#define   COM9_AGC_GAIN_4x     0x20  \n#define   COM9_AGC_GAIN_8x     0x40  \n#define   COM9_AGC_GAIN_16x    0x60  \n#define   COM9_AGC_GAIN_32x    0x80  \n#define   COM9_AGC_GAIN_64x    0xA0  \n#define   COM9_AGC_GAIN_128x   0xC0  \n#define COM10       0x15  \n#define   COM10_PCLK_HREF      0x20  \n#define   COM10_PCLK_RISE      0x10  \n#define   COM10_HREF_INV       0x08  \n#define   COM10_VSINC_INV      0x02  \n#define HSTART      0x17  \n#define HEND        0x18  \n#define VSTART      0x19  \n#define VEND        0x1A  \n#define MIDH        0x1C  \n#define MIDL        0x1D  \n#define AEW         0x24  \n#define AEB         0x25  \n#define VV          0x26  \n#define   VV_HIGH_TH_SET(x)      VAL_SET(x, 0xF, 0, 4)\n#define   VV_LOW_TH_SET(x)       VAL_SET(x, 0xF, 0, 0)\n#define REG2A       0x2A  \n#define FRARL       0x2B  \n#define ADDVFL      0x2D  \n#define ADDVFH      0x2E  \n#define YAVG        0x2F  \n#define REG32       0x32  \n#define   REG32_PCLK_DIV_2    0x80  \n#define   REG32_PCLK_DIV_4    0xC0  \n#define ARCOM2      0x34  \n#define REG45       0x45  \n#define FLL         0x46  \n#define FLH         0x47  \n#define COM19       0x48  \n#define ZOOMS       0x49  \n#define COM22       0x4B  \n#define COM25       0x4E  \n#define   COM25_50HZ_BANDING_AEC_MSBS_MASK      0xC0  \n#define   COM25_60HZ_BANDING_AEC_MSBS_MASK      0x30  \n#define   COM25_50HZ_BANDING_AEC_MSBS_SET(x)    VAL_SET(x, 0x3, 8, 6)\n#define   COM25_60HZ_BANDING_AEC_MSBS_SET(x)    VAL_SET(x, 0x3, 8, 4)\n#define BD50        0x4F  \n#define   BD50_50HZ_BANDING_AEC_LSBS_SET(x)     VAL_SET(x, 0xFF, 0, 0)\n#define BD60        0x50  \n#define   BD60_60HZ_BANDING_AEC_LSBS_SET(x)     VAL_SET(x, 0xFF, 0, 0)\n#define REG5A       0x5A  \n#define   BD50_MAX_AEC_STEP_MASK         0xF0  \n#define   BD60_MAX_AEC_STEP_MASK         0x0F  \n#define   BD50_MAX_AEC_STEP_SET(x)       VAL_SET((x - 1), 0x0F, 0, 4)\n#define   BD60_MAX_AEC_STEP_SET(x)       VAL_SET((x - 1), 0x0F, 0, 0)\n#define REG5D       0x5D  \n#define REG5E       0x5E  \n#define REG5F       0x5F  \n#define REG60       0x60  \n#define HISTO_LOW   0x61  \n#define HISTO_HIGH  0x62  \n\n \n#define MANUFACTURER_ID\t0x7FA2\n#define PID_OV2640\t0x2642\n#define VERSION(pid, ver) ((pid << 8) | (ver & 0xFF))\n\n \nstruct regval_list {\n\tu8 reg_num;\n\tu8 value;\n};\n\nstruct ov2640_win_size {\n\tchar\t\t\t\t*name;\n\tu32\t\t\t\twidth;\n\tu32\t\t\t\theight;\n\tconst struct regval_list\t*regs;\n};\n\n\nstruct ov2640_priv {\n\tstruct v4l2_subdev\t\tsubdev;\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tstruct media_pad pad;\n#endif\n\tstruct v4l2_ctrl_handler\thdl;\n\tu32\tcfmt_code;\n\tstruct clk\t\t\t*clk;\n\tconst struct ov2640_win_size\t*win;\n\n\tstruct gpio_desc *resetb_gpio;\n\tstruct gpio_desc *pwdn_gpio;\n\n\tstruct mutex lock;  \n\tbool streaming;\n\tint power_count;\n};\n\n \n\n#define ENDMARKER { 0xff, 0xff }\n\nstatic const struct regval_list ov2640_init_regs[] = {\n\t{ BANK_SEL, BANK_SEL_DSP },\n\t{ 0x2c,   0xff },\n\t{ 0x2e,   0xdf },\n\t{ BANK_SEL, BANK_SEL_SENS },\n\t{ 0x3c,   0x32 },\n\t{ CLKRC,  CLKRC_DIV_SET(1) },\n\t{ COM2,   COM2_OCAP_Nx_SET(3) },\n\t{ REG04,  REG04_DEF | REG04_HREF_EN },\n\t{ COM8,   COM8_DEF | COM8_BNDF_EN | COM8_AGC_EN | COM8_AEC_EN },\n\t{ COM9,   COM9_AGC_GAIN_8x | 0x08},\n\t{ 0x2c,   0x0c },\n\t{ 0x33,   0x78 },\n\t{ 0x3a,   0x33 },\n\t{ 0x3b,   0xfb },\n\t{ 0x3e,   0x00 },\n\t{ 0x43,   0x11 },\n\t{ 0x16,   0x10 },\n\t{ 0x39,   0x02 },\n\t{ 0x35,   0x88 },\n\t{ 0x22,   0x0a },\n\t{ 0x37,   0x40 },\n\t{ 0x23,   0x00 },\n\t{ ARCOM2, 0xa0 },\n\t{ 0x06,   0x02 },\n\t{ 0x06,   0x88 },\n\t{ 0x07,   0xc0 },\n\t{ 0x0d,   0xb7 },\n\t{ 0x0e,   0x01 },\n\t{ 0x4c,   0x00 },\n\t{ 0x4a,   0x81 },\n\t{ 0x21,   0x99 },\n\t{ AEW,    0x40 },\n\t{ AEB,    0x38 },\n\t{ VV,     VV_HIGH_TH_SET(0x08) | VV_LOW_TH_SET(0x02) },\n\t{ 0x5c,   0x00 },\n\t{ 0x63,   0x00 },\n\t{ FLL,    0x22 },\n\t{ COM3,   0x38 | COM3_BAND_AUTO },\n\t{ REG5D,  0x55 },\n\t{ REG5E,  0x7d },\n\t{ REG5F,  0x7d },\n\t{ REG60,  0x55 },\n\t{ HISTO_LOW,   0x70 },\n\t{ HISTO_HIGH,  0x80 },\n\t{ 0x7c,   0x05 },\n\t{ 0x20,   0x80 },\n\t{ 0x28,   0x30 },\n\t{ 0x6c,   0x00 },\n\t{ 0x6d,   0x80 },\n\t{ 0x6e,   0x00 },\n\t{ 0x70,   0x02 },\n\t{ 0x71,   0x94 },\n\t{ 0x73,   0xc1 },\n\t{ 0x3d,   0x34 },\n\t{ COM7,   COM7_RES_UXGA | COM7_ZOOM_EN },\n\t{ REG5A,  BD50_MAX_AEC_STEP_SET(6)\n\t\t   | BD60_MAX_AEC_STEP_SET(8) },\t\t \n\t{ COM25,  COM25_50HZ_BANDING_AEC_MSBS_SET(0x0bb)\n\t\t   | COM25_60HZ_BANDING_AEC_MSBS_SET(0x09c) },\t \n\t{ BD50,   BD50_50HZ_BANDING_AEC_LSBS_SET(0x0bb) },\t \n\t{ BD60,   BD60_60HZ_BANDING_AEC_LSBS_SET(0x09c) },\t \n\t{ BANK_SEL,  BANK_SEL_DSP },\n\t{ 0xe5,   0x7f },\n\t{ MC_BIST,  MC_BIST_RESET | MC_BIST_BOOT_ROM_SEL },\n\t{ 0x41,   0x24 },\n\t{ RESET,  RESET_JPEG | RESET_DVP },\n\t{ 0x76,   0xff },\n\t{ 0x33,   0xa0 },\n\t{ 0x42,   0x20 },\n\t{ 0x43,   0x18 },\n\t{ 0x4c,   0x00 },\n\t{ CTRL3,  CTRL3_BPC_EN | CTRL3_WPC_EN | 0x10 },\n\t{ 0x88,   0x3f },\n\t{ 0xd7,   0x03 },\n\t{ 0xd9,   0x10 },\n\t{ R_DVP_SP,  R_DVP_SP_AUTO_MODE | 0x2 },\n\t{ 0xc8,   0x08 },\n\t{ 0xc9,   0x80 },\n\t{ BPADDR, 0x00 },\n\t{ BPDATA, 0x00 },\n\t{ BPADDR, 0x03 },\n\t{ BPDATA, 0x48 },\n\t{ BPDATA, 0x48 },\n\t{ BPADDR, 0x08 },\n\t{ BPDATA, 0x20 },\n\t{ BPDATA, 0x10 },\n\t{ BPDATA, 0x0e },\n\t{ 0x90,   0x00 },\n\t{ 0x91,   0x0e },\n\t{ 0x91,   0x1a },\n\t{ 0x91,   0x31 },\n\t{ 0x91,   0x5a },\n\t{ 0x91,   0x69 },\n\t{ 0x91,   0x75 },\n\t{ 0x91,   0x7e },\n\t{ 0x91,   0x88 },\n\t{ 0x91,   0x8f },\n\t{ 0x91,   0x96 },\n\t{ 0x91,   0xa3 },\n\t{ 0x91,   0xaf },\n\t{ 0x91,   0xc4 },\n\t{ 0x91,   0xd7 },\n\t{ 0x91,   0xe8 },\n\t{ 0x91,   0x20 },\n\t{ 0x92,   0x00 },\n\t{ 0x93,   0x06 },\n\t{ 0x93,   0xe3 },\n\t{ 0x93,   0x03 },\n\t{ 0x93,   0x03 },\n\t{ 0x93,   0x00 },\n\t{ 0x93,   0x02 },\n\t{ 0x93,   0x00 },\n\t{ 0x93,   0x00 },\n\t{ 0x93,   0x00 },\n\t{ 0x93,   0x00 },\n\t{ 0x93,   0x00 },\n\t{ 0x93,   0x00 },\n\t{ 0x93,   0x00 },\n\t{ 0x96,   0x00 },\n\t{ 0x97,   0x08 },\n\t{ 0x97,   0x19 },\n\t{ 0x97,   0x02 },\n\t{ 0x97,   0x0c },\n\t{ 0x97,   0x24 },\n\t{ 0x97,   0x30 },\n\t{ 0x97,   0x28 },\n\t{ 0x97,   0x26 },\n\t{ 0x97,   0x02 },\n\t{ 0x97,   0x98 },\n\t{ 0x97,   0x80 },\n\t{ 0x97,   0x00 },\n\t{ 0x97,   0x00 },\n\t{ 0xa4,   0x00 },\n\t{ 0xa8,   0x00 },\n\t{ 0xc5,   0x11 },\n\t{ 0xc6,   0x51 },\n\t{ 0xbf,   0x80 },\n\t{ 0xc7,   0x10 },\t \n\t{ 0xb6,   0x66 },\n\t{ 0xb8,   0xA5 },\n\t{ 0xb7,   0x64 },\n\t{ 0xb9,   0x7C },\n\t{ 0xb3,   0xaf },\n\t{ 0xb4,   0x97 },\n\t{ 0xb5,   0xFF },\n\t{ 0xb0,   0xC5 },\n\t{ 0xb1,   0x94 },\n\t{ 0xb2,   0x0f },\n\t{ 0xc4,   0x5c },\n\t{ 0xa6,   0x00 },\n\t{ 0xa7,   0x20 },\n\t{ 0xa7,   0xd8 },\n\t{ 0xa7,   0x1b },\n\t{ 0xa7,   0x31 },\n\t{ 0xa7,   0x00 },\n\t{ 0xa7,   0x18 },\n\t{ 0xa7,   0x20 },\n\t{ 0xa7,   0xd8 },\n\t{ 0xa7,   0x19 },\n\t{ 0xa7,   0x31 },\n\t{ 0xa7,   0x00 },\n\t{ 0xa7,   0x18 },\n\t{ 0xa7,   0x20 },\n\t{ 0xa7,   0xd8 },\n\t{ 0xa7,   0x19 },\n\t{ 0xa7,   0x31 },\n\t{ 0xa7,   0x00 },\n\t{ 0xa7,   0x18 },\n\t{ 0x7f,   0x00 },\n\t{ 0xe5,   0x1f },\n\t{ 0xe1,   0x77 },\n\t{ 0xdd,   0x7f },\n\t{ CTRL0,  CTRL0_YUV422 | CTRL0_YUV_EN | CTRL0_RGB_EN },\n\tENDMARKER,\n};\n\n \nstatic const struct regval_list ov2640_size_change_preamble_regs[] = {\n\t{ BANK_SEL, BANK_SEL_DSP },\n\t{ RESET, RESET_DVP },\n\t{ SIZEL, SIZEL_HSIZE8_11_SET(UXGA_WIDTH) |\n\t\t SIZEL_HSIZE8_SET(UXGA_WIDTH) |\n\t\t SIZEL_VSIZE8_SET(UXGA_HEIGHT) },\n\t{ HSIZE8, HSIZE8_SET(UXGA_WIDTH) },\n\t{ VSIZE8, VSIZE8_SET(UXGA_HEIGHT) },\n\t{ CTRL2, CTRL2_DCW_EN | CTRL2_SDE_EN |\n\t\t CTRL2_UV_AVG_EN | CTRL2_CMX_EN | CTRL2_UV_ADJ_EN },\n\t{ HSIZE, HSIZE_SET(UXGA_WIDTH) },\n\t{ VSIZE, VSIZE_SET(UXGA_HEIGHT) },\n\t{ XOFFL, XOFFL_SET(0) },\n\t{ YOFFL, YOFFL_SET(0) },\n\t{ VHYX, VHYX_HSIZE_SET(UXGA_WIDTH) | VHYX_VSIZE_SET(UXGA_HEIGHT) |\n\t\tVHYX_XOFF_SET(0) | VHYX_YOFF_SET(0)},\n\t{ TEST, TEST_HSIZE_SET(UXGA_WIDTH) },\n\tENDMARKER,\n};\n\n#define PER_SIZE_REG_SEQ(x, y, v_div, h_div, pclk_div)\t\\\n\t{ CTRLI, CTRLI_LP_DP | CTRLI_V_DIV_SET(v_div) |\t\\\n\t\t CTRLI_H_DIV_SET(h_div)},\t\t\\\n\t{ ZMOW, ZMOW_OUTW_SET(x) },\t\t\t\\\n\t{ ZMOH, ZMOH_OUTH_SET(y) },\t\t\t\\\n\t{ ZMHH, ZMHH_OUTW_SET(x) | ZMHH_OUTH_SET(y) },\t\\\n\t{ R_DVP_SP, pclk_div },\t\t\t\t\\\n\t{ RESET, 0x00}\n\nstatic const struct regval_list ov2640_qcif_regs[] = {\n\tPER_SIZE_REG_SEQ(QCIF_WIDTH, QCIF_HEIGHT, 3, 3, 4),\n\tENDMARKER,\n};\n\nstatic const struct regval_list ov2640_qvga_regs[] = {\n\tPER_SIZE_REG_SEQ(QVGA_WIDTH, QVGA_HEIGHT, 2, 2, 4),\n\tENDMARKER,\n};\n\nstatic const struct regval_list ov2640_cif_regs[] = {\n\tPER_SIZE_REG_SEQ(CIF_WIDTH, CIF_HEIGHT, 2, 2, 8),\n\tENDMARKER,\n};\n\nstatic const struct regval_list ov2640_vga_regs[] = {\n\tPER_SIZE_REG_SEQ(VGA_WIDTH, VGA_HEIGHT, 0, 0, 2),\n\tENDMARKER,\n};\n\nstatic const struct regval_list ov2640_svga_regs[] = {\n\tPER_SIZE_REG_SEQ(SVGA_WIDTH, SVGA_HEIGHT, 1, 1, 2),\n\tENDMARKER,\n};\n\nstatic const struct regval_list ov2640_xga_regs[] = {\n\tPER_SIZE_REG_SEQ(XGA_WIDTH, XGA_HEIGHT, 0, 0, 2),\n\t{ CTRLI,    0x00},\n\tENDMARKER,\n};\n\nstatic const struct regval_list ov2640_sxga_regs[] = {\n\tPER_SIZE_REG_SEQ(SXGA_WIDTH, SXGA_HEIGHT, 0, 0, 2),\n\t{ CTRLI,    0x00},\n\t{ R_DVP_SP, 2 | R_DVP_SP_AUTO_MODE },\n\tENDMARKER,\n};\n\nstatic const struct regval_list ov2640_uxga_regs[] = {\n\tPER_SIZE_REG_SEQ(UXGA_WIDTH, UXGA_HEIGHT, 0, 0, 0),\n\t{ CTRLI,    0x00},\n\t{ R_DVP_SP, 0 | R_DVP_SP_AUTO_MODE },\n\tENDMARKER,\n};\n\n#define OV2640_SIZE(n, w, h, r) \\\n\t{.name = n, .width = w , .height = h, .regs = r }\n\nstatic const struct ov2640_win_size ov2640_supported_win_sizes[] = {\n\tOV2640_SIZE(\"QCIF\", QCIF_WIDTH, QCIF_HEIGHT, ov2640_qcif_regs),\n\tOV2640_SIZE(\"QVGA\", QVGA_WIDTH, QVGA_HEIGHT, ov2640_qvga_regs),\n\tOV2640_SIZE(\"CIF\", CIF_WIDTH, CIF_HEIGHT, ov2640_cif_regs),\n\tOV2640_SIZE(\"VGA\", VGA_WIDTH, VGA_HEIGHT, ov2640_vga_regs),\n\tOV2640_SIZE(\"SVGA\", SVGA_WIDTH, SVGA_HEIGHT, ov2640_svga_regs),\n\tOV2640_SIZE(\"XGA\", XGA_WIDTH, XGA_HEIGHT, ov2640_xga_regs),\n\tOV2640_SIZE(\"SXGA\", SXGA_WIDTH, SXGA_HEIGHT, ov2640_sxga_regs),\n\tOV2640_SIZE(\"UXGA\", UXGA_WIDTH, UXGA_HEIGHT, ov2640_uxga_regs),\n};\n\n \nstatic const struct regval_list ov2640_format_change_preamble_regs[] = {\n\t{ BANK_SEL, BANK_SEL_DSP },\n\t{ R_BYPASS, R_BYPASS_USE_DSP },\n\tENDMARKER,\n};\n\nstatic const struct regval_list ov2640_yuyv_regs[] = {\n\t{ IMAGE_MODE, IMAGE_MODE_YUV422 },\n\t{ 0xd7, 0x03 },\n\t{ 0x33, 0xa0 },\n\t{ 0xe5, 0x1f },\n\t{ 0xe1, 0x67 },\n\t{ RESET,  0x00 },\n\t{ R_BYPASS, R_BYPASS_USE_DSP },\n\tENDMARKER,\n};\n\nstatic const struct regval_list ov2640_uyvy_regs[] = {\n\t{ IMAGE_MODE, IMAGE_MODE_LBYTE_FIRST | IMAGE_MODE_YUV422 },\n\t{ 0xd7, 0x01 },\n\t{ 0x33, 0xa0 },\n\t{ 0xe1, 0x67 },\n\t{ RESET,  0x00 },\n\t{ R_BYPASS, R_BYPASS_USE_DSP },\n\tENDMARKER,\n};\n\nstatic const struct regval_list ov2640_rgb565_be_regs[] = {\n\t{ IMAGE_MODE, IMAGE_MODE_RGB565 },\n\t{ 0xd7, 0x03 },\n\t{ RESET,  0x00 },\n\t{ R_BYPASS, R_BYPASS_USE_DSP },\n\tENDMARKER,\n};\n\nstatic const struct regval_list ov2640_rgb565_le_regs[] = {\n\t{ IMAGE_MODE, IMAGE_MODE_LBYTE_FIRST | IMAGE_MODE_RGB565 },\n\t{ 0xd7, 0x03 },\n\t{ RESET,  0x00 },\n\t{ R_BYPASS, R_BYPASS_USE_DSP },\n\tENDMARKER,\n};\n\nstatic u32 ov2640_codes[] = {\n\tMEDIA_BUS_FMT_YUYV8_2X8,\n\tMEDIA_BUS_FMT_UYVY8_2X8,\n\tMEDIA_BUS_FMT_YVYU8_2X8,\n\tMEDIA_BUS_FMT_VYUY8_2X8,\n\tMEDIA_BUS_FMT_RGB565_2X8_BE,\n\tMEDIA_BUS_FMT_RGB565_2X8_LE,\n};\n\n \nstatic struct ov2640_priv *to_ov2640(const struct i2c_client *client)\n{\n\treturn container_of(i2c_get_clientdata(client), struct ov2640_priv,\n\t\t\t    subdev);\n}\n\nstatic int ov2640_write_array(struct i2c_client *client,\n\t\t\t      const struct regval_list *vals)\n{\n\tint ret;\n\n\twhile ((vals->reg_num != 0xff) || (vals->value != 0xff)) {\n\t\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\t\tvals->reg_num, vals->value);\n\t\tdev_vdbg(&client->dev, \"array: 0x%02x, 0x%02x\",\n\t\t\t vals->reg_num, vals->value);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tvals++;\n\t}\n\treturn 0;\n}\n\nstatic int ov2640_mask_set(struct i2c_client *client,\n\t\t\t   u8  reg, u8  mask, u8  set)\n{\n\ts32 val = i2c_smbus_read_byte_data(client, reg);\n\tif (val < 0)\n\t\treturn val;\n\n\tval &= ~mask;\n\tval |= set & mask;\n\n\tdev_vdbg(&client->dev, \"masks: 0x%02x, 0x%02x\", reg, val);\n\n\treturn i2c_smbus_write_byte_data(client, reg, val);\n}\n\nstatic int ov2640_reset(struct i2c_client *client)\n{\n\tint ret;\n\tstatic const struct regval_list reset_seq[] = {\n\t\t{BANK_SEL, BANK_SEL_SENS},\n\t\t{COM7, COM7_SRST},\n\t\tENDMARKER,\n\t};\n\n\tret = ov2640_write_array(client, reset_seq);\n\tif (ret)\n\t\tgoto err;\n\n\tmsleep(5);\nerr:\n\tdev_dbg(&client->dev, \"%s: (ret %d)\", __func__, ret);\n\treturn ret;\n}\n\nstatic const char * const ov2640_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Eight Vertical Colour Bars\",\n};\n\n \nstatic int ov2640_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd =\n\t\t&container_of(ctrl->handler, struct ov2640_priv, hdl)->subdev;\n\tstruct i2c_client  *client = v4l2_get_subdevdata(sd);\n\tstruct ov2640_priv *priv = to_ov2640(client);\n\tu8 val;\n\tint ret;\n\n\t \n\n\t \n\tif (!priv->power_count)\n\t\treturn 0;\n\n\tret = i2c_smbus_write_byte_data(client, BANK_SEL, BANK_SEL_SENS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_VFLIP:\n\t\tval = ctrl->val ? REG04_VFLIP_IMG | REG04_VREF_EN : 0x00;\n\t\treturn ov2640_mask_set(client, REG04,\n\t\t\t\t       REG04_VFLIP_IMG | REG04_VREF_EN, val);\n\t\t \n\tcase V4L2_CID_HFLIP:\n\t\tval = ctrl->val ? REG04_HFLIP_IMG : 0x00;\n\t\treturn ov2640_mask_set(client, REG04, REG04_HFLIP_IMG, val);\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tval = ctrl->val ? COM7_COLOR_BAR_TEST : 0x00;\n\t\treturn ov2640_mask_set(client, COM7, COM7_COLOR_BAR_TEST, val);\n\t}\n\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int ov2640_g_register(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_dbg_register *reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\treg->size = 1;\n\tif (reg->reg > 0xff)\n\t\treturn -EINVAL;\n\n\tret = i2c_smbus_read_byte_data(client, reg->reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treg->val = ret;\n\n\treturn 0;\n}\n\nstatic int ov2640_s_register(struct v4l2_subdev *sd,\n\t\t\t     const struct v4l2_dbg_register *reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tif (reg->reg > 0xff ||\n\t    reg->val > 0xff)\n\t\treturn -EINVAL;\n\n\treturn i2c_smbus_write_byte_data(client, reg->reg, reg->val);\n}\n#endif\n\nstatic void ov2640_set_power(struct ov2640_priv *priv, int on)\n{\n#ifdef CONFIG_GPIOLIB\n\tif (priv->pwdn_gpio)\n\t\tgpiod_direction_output(priv->pwdn_gpio, !on);\n\tif (on && priv->resetb_gpio) {\n\t\t \n\t\tgpiod_direction_output(priv->resetb_gpio, 1);\n\t\tusleep_range(3000, 5000);\n\t\tgpiod_set_value(priv->resetb_gpio, 0);\n\t}\n#endif\n}\n\nstatic int ov2640_s_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov2640_priv *priv = to_ov2640(client);\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tif (priv->power_count == !on)\n\t\tov2640_set_power(priv, on);\n\tpriv->power_count += on ? 1 : -1;\n\tWARN_ON(priv->power_count < 0);\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\n \nstatic const struct ov2640_win_size *ov2640_select_win(u32 width, u32 height)\n{\n\tint i, default_size = ARRAY_SIZE(ov2640_supported_win_sizes) - 1;\n\n\tfor (i = 0; i < ARRAY_SIZE(ov2640_supported_win_sizes); i++) {\n\t\tif (ov2640_supported_win_sizes[i].width  >= width &&\n\t\t    ov2640_supported_win_sizes[i].height >= height)\n\t\t\treturn &ov2640_supported_win_sizes[i];\n\t}\n\n\treturn &ov2640_supported_win_sizes[default_size];\n}\n\nstatic int ov2640_set_params(struct i2c_client *client,\n\t\t\t     const struct ov2640_win_size *win, u32 code)\n{\n\tconst struct regval_list *selected_cfmt_regs;\n\tu8 val;\n\tint ret;\n\n\tswitch (code) {\n\tcase MEDIA_BUS_FMT_RGB565_2X8_BE:\n\t\tdev_dbg(&client->dev, \"%s: Selected cfmt RGB565 BE\", __func__);\n\t\tselected_cfmt_regs = ov2640_rgb565_be_regs;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB565_2X8_LE:\n\t\tdev_dbg(&client->dev, \"%s: Selected cfmt RGB565 LE\", __func__);\n\t\tselected_cfmt_regs = ov2640_rgb565_le_regs;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\t\tdev_dbg(&client->dev, \"%s: Selected cfmt YUYV (YUV422)\", __func__);\n\t\tselected_cfmt_regs = ov2640_yuyv_regs;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\tdefault:\n\t\tdev_dbg(&client->dev, \"%s: Selected cfmt UYVY\", __func__);\n\t\tselected_cfmt_regs = ov2640_uyvy_regs;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YVYU8_2X8:\n\t\tdev_dbg(&client->dev, \"%s: Selected cfmt YVYU\", __func__);\n\t\tselected_cfmt_regs = ov2640_yuyv_regs;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_VYUY8_2X8:\n\t\tdev_dbg(&client->dev, \"%s: Selected cfmt VYUY\", __func__);\n\t\tselected_cfmt_regs = ov2640_uyvy_regs;\n\t\tbreak;\n\t}\n\n\t \n\tov2640_reset(client);\n\n\t \n\tdev_dbg(&client->dev, \"%s: Init default\", __func__);\n\tret = ov2640_write_array(client, ov2640_init_regs);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tdev_dbg(&client->dev, \"%s: Set size to %s\", __func__, win->name);\n\tret = ov2640_write_array(client, ov2640_size_change_preamble_regs);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = ov2640_write_array(client, win->regs);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tdev_dbg(&client->dev, \"%s: Set cfmt\", __func__);\n\tret = ov2640_write_array(client, ov2640_format_change_preamble_regs);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = ov2640_write_array(client, selected_cfmt_regs);\n\tif (ret < 0)\n\t\tgoto err;\n\tval = (code == MEDIA_BUS_FMT_YVYU8_2X8)\n\t      || (code == MEDIA_BUS_FMT_VYUY8_2X8) ? CTRL0_VFIRST : 0x00;\n\tret = ov2640_mask_set(client, CTRL0, CTRL0_VFIRST, val);\n\tif (ret < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tdev_err(&client->dev, \"%s: Error %d\", __func__, ret);\n\tov2640_reset(client);\n\n\treturn ret;\n}\n\nstatic int ov2640_get_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tstruct i2c_client  *client = v4l2_get_subdevdata(sd);\n\tstruct ov2640_priv *priv = to_ov2640(client);\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\n\t\tmf = v4l2_subdev_get_try_format(sd, sd_state, 0);\n\t\tformat->format = *mf;\n\t\treturn 0;\n#else\n\t\treturn -EINVAL;\n#endif\n\t}\n\n\tmf->width\t= priv->win->width;\n\tmf->height\t= priv->win->height;\n\tmf->code\t= priv->cfmt_code;\n\tmf->colorspace\t= V4L2_COLORSPACE_SRGB;\n\tmf->field\t= V4L2_FIELD_NONE;\n\tmf->ycbcr_enc\t= V4L2_YCBCR_ENC_DEFAULT;\n\tmf->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tmf->xfer_func\t= V4L2_XFER_FUNC_DEFAULT;\n\n\treturn 0;\n}\n\nstatic int ov2640_set_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov2640_priv *priv = to_ov2640(client);\n\tconst struct ov2640_win_size *win;\n\tint ret = 0;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\n\t \n\twin = ov2640_select_win(mf->width, mf->height);\n\tmf->width\t= win->width;\n\tmf->height\t= win->height;\n\n\tmf->field\t= V4L2_FIELD_NONE;\n\tmf->colorspace\t= V4L2_COLORSPACE_SRGB;\n\tmf->ycbcr_enc\t= V4L2_YCBCR_ENC_DEFAULT;\n\tmf->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tmf->xfer_func\t= V4L2_XFER_FUNC_DEFAULT;\n\n\tswitch (mf->code) {\n\tcase MEDIA_BUS_FMT_RGB565_2X8_BE:\n\tcase MEDIA_BUS_FMT_RGB565_2X8_LE:\n\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\tcase MEDIA_BUS_FMT_YVYU8_2X8:\n\tcase MEDIA_BUS_FMT_VYUY8_2X8:\n\t\tbreak;\n\tdefault:\n\t\tmf->code = MEDIA_BUS_FMT_UYVY8_2X8;\n\t\tbreak;\n\t}\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\tstruct ov2640_priv *priv = to_ov2640(client);\n\n\t\tif (priv->streaming) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tpriv->win = win;\n\t\t \n\t\tpriv->cfmt_code = mf->code;\n\t} else {\n\t\tsd_state->pads->try_fmt = *mf;\n\t}\nout:\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int ov2640_init_cfg(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state)\n{\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\n\tstruct v4l2_mbus_framefmt *try_fmt =\n\t\tv4l2_subdev_get_try_format(sd, sd_state, 0);\n\tconst struct ov2640_win_size *win =\n\t\tov2640_select_win(SVGA_WIDTH, SVGA_HEIGHT);\n\n\ttry_fmt->width = win->width;\n\ttry_fmt->height = win->height;\n\ttry_fmt->code = MEDIA_BUS_FMT_UYVY8_2X8;\n\ttry_fmt->colorspace = V4L2_COLORSPACE_SRGB;\n\ttry_fmt->field = V4L2_FIELD_NONE;\n\ttry_fmt->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\ttry_fmt->quantization = V4L2_QUANTIZATION_DEFAULT;\n\ttry_fmt->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n#endif\n\treturn 0;\n}\n\nstatic int ov2640_enum_mbus_code(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index >= ARRAY_SIZE(ov2640_codes))\n\t\treturn -EINVAL;\n\n\tcode->code = ov2640_codes[code->index];\n\treturn 0;\n}\n\nstatic int ov2640_get_selection(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_selection *sel)\n{\n\tif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = UXGA_WIDTH;\n\t\tsel->r.height = UXGA_HEIGHT;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ov2640_s_stream(struct v4l2_subdev *sd, int on)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov2640_priv *priv = to_ov2640(client);\n\tint ret = 0;\n\n\tmutex_lock(&priv->lock);\n\tif (priv->streaming == !on) {\n\t\tif (on) {\n\t\t\tret = ov2640_set_params(client, priv->win,\n\t\t\t\t\t\tpriv->cfmt_code);\n\t\t\tif (!ret)\n\t\t\t\tret = __v4l2_ctrl_handler_setup(&priv->hdl);\n\t\t}\n\t}\n\tif (!ret)\n\t\tpriv->streaming = on;\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int ov2640_video_probe(struct i2c_client *client)\n{\n\tstruct ov2640_priv *priv = to_ov2640(client);\n\tu8 pid, ver, midh, midl;\n\tconst char *devname;\n\tint ret;\n\n\tret = ov2640_s_power(&priv->subdev, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\ti2c_smbus_write_byte_data(client, BANK_SEL, BANK_SEL_SENS);\n\tpid  = i2c_smbus_read_byte_data(client, PID);\n\tver  = i2c_smbus_read_byte_data(client, VER);\n\tmidh = i2c_smbus_read_byte_data(client, MIDH);\n\tmidl = i2c_smbus_read_byte_data(client, MIDL);\n\n\tswitch (VERSION(pid, ver)) {\n\tcase PID_OV2640:\n\t\tdevname     = \"ov2640\";\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev,\n\t\t\t\"Product ID error %x:%x\\n\", pid, ver);\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tdev_info(&client->dev,\n\t\t \"%s Product ID %0x:%0x Manufacturer ID %x:%x\\n\",\n\t\t devname, pid, ver, midh, midl);\n\ndone:\n\tov2640_s_power(&priv->subdev, 0);\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops ov2640_ctrl_ops = {\n\t.s_ctrl = ov2640_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops ov2640_subdev_core_ops = {\n\t.log_status = v4l2_ctrl_subdev_log_status,\n\t.subscribe_event = v4l2_ctrl_subdev_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register\t= ov2640_g_register,\n\t.s_register\t= ov2640_s_register,\n#endif\n\t.s_power\t= ov2640_s_power,\n};\n\nstatic const struct v4l2_subdev_pad_ops ov2640_subdev_pad_ops = {\n\t.init_cfg\t= ov2640_init_cfg,\n\t.enum_mbus_code = ov2640_enum_mbus_code,\n\t.get_selection\t= ov2640_get_selection,\n\t.get_fmt\t= ov2640_get_fmt,\n\t.set_fmt\t= ov2640_set_fmt,\n};\n\nstatic const struct v4l2_subdev_video_ops ov2640_subdev_video_ops = {\n\t.s_stream = ov2640_s_stream,\n};\n\nstatic const struct v4l2_subdev_ops ov2640_subdev_ops = {\n\t.core\t= &ov2640_subdev_core_ops,\n\t.pad\t= &ov2640_subdev_pad_ops,\n\t.video\t= &ov2640_subdev_video_ops,\n};\n\nstatic int ov2640_probe_dt(struct i2c_client *client,\n\t\tstruct ov2640_priv *priv)\n{\n\tint ret;\n\n\t \n\tpriv->resetb_gpio = devm_gpiod_get_optional(&client->dev, \"resetb\",\n\t\t\tGPIOD_OUT_LOW);\n\n\tif (!priv->resetb_gpio)\n\t\tdev_dbg(&client->dev, \"resetb gpio is not assigned!\\n\");\n\n\tret = PTR_ERR_OR_ZERO(priv->resetb_gpio);\n\tif (ret && ret != -ENOSYS) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"Error %d while getting resetb gpio\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tpriv->pwdn_gpio = devm_gpiod_get_optional(&client->dev, \"pwdn\",\n\t\t\tGPIOD_OUT_HIGH);\n\n\tif (!priv->pwdn_gpio)\n\t\tdev_dbg(&client->dev, \"pwdn gpio is not assigned!\\n\");\n\n\tret = PTR_ERR_OR_ZERO(priv->pwdn_gpio);\n\tif (ret && ret != -ENOSYS) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"Error %d while getting pwdn gpio\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ov2640_probe(struct i2c_client *client)\n{\n\tstruct ov2640_priv\t*priv;\n\tstruct i2c_adapter\t*adapter = client->adapter;\n\tint\t\t\tret;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_err(&adapter->dev,\n\t\t\t\"OV2640: I2C-Adapter doesn't support SMBUS\\n\");\n\t\treturn -EIO;\n\t}\n\n\tpriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tif (client->dev.of_node) {\n\t\tpriv->clk = devm_clk_get(&client->dev, \"xvclk\");\n\t\tif (IS_ERR(priv->clk))\n\t\t\treturn PTR_ERR(priv->clk);\n\t\tret = clk_prepare_enable(priv->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = ov2640_probe_dt(client, priv);\n\tif (ret)\n\t\tgoto err_clk;\n\n\tpriv->win = ov2640_select_win(SVGA_WIDTH, SVGA_HEIGHT);\n\tpriv->cfmt_code = MEDIA_BUS_FMT_UYVY8_2X8;\n\n\tv4l2_i2c_subdev_init(&priv->subdev, client, &ov2640_subdev_ops);\n\tpriv->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |\n\t\t\t      V4L2_SUBDEV_FL_HAS_EVENTS;\n\tmutex_init(&priv->lock);\n\tv4l2_ctrl_handler_init(&priv->hdl, 3);\n\tpriv->hdl.lock = &priv->lock;\n\tv4l2_ctrl_new_std(&priv->hdl, &ov2640_ctrl_ops,\n\t\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(&priv->hdl, &ov2640_ctrl_ops,\n\t\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std_menu_items(&priv->hdl, &ov2640_ctrl_ops,\n\t\t\tV4L2_CID_TEST_PATTERN,\n\t\t\tARRAY_SIZE(ov2640_test_pattern_menu) - 1, 0, 0,\n\t\t\tov2640_test_pattern_menu);\n\tpriv->subdev.ctrl_handler = &priv->hdl;\n\tif (priv->hdl.error) {\n\t\tret = priv->hdl.error;\n\t\tgoto err_hdl;\n\t}\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tpriv->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tpriv->subdev.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tret = media_entity_pads_init(&priv->subdev.entity, 1, &priv->pad);\n\tif (ret < 0)\n\t\tgoto err_hdl;\n#endif\n\n\tret = ov2640_video_probe(client);\n\tif (ret < 0)\n\t\tgoto err_videoprobe;\n\n\tret = v4l2_async_register_subdev(&priv->subdev);\n\tif (ret < 0)\n\t\tgoto err_videoprobe;\n\n\tdev_info(&adapter->dev, \"OV2640 Probed\\n\");\n\n\treturn 0;\n\nerr_videoprobe:\n\tmedia_entity_cleanup(&priv->subdev.entity);\nerr_hdl:\n\tv4l2_ctrl_handler_free(&priv->hdl);\n\tmutex_destroy(&priv->lock);\nerr_clk:\n\tclk_disable_unprepare(priv->clk);\n\treturn ret;\n}\n\nstatic void ov2640_remove(struct i2c_client *client)\n{\n\tstruct ov2640_priv       *priv = to_ov2640(client);\n\n\tv4l2_async_unregister_subdev(&priv->subdev);\n\tv4l2_ctrl_handler_free(&priv->hdl);\n\tmutex_destroy(&priv->lock);\n\tmedia_entity_cleanup(&priv->subdev.entity);\n\tv4l2_device_unregister_subdev(&priv->subdev);\n\tclk_disable_unprepare(priv->clk);\n}\n\nstatic const struct i2c_device_id ov2640_id[] = {\n\t{ \"ov2640\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ov2640_id);\n\nstatic const struct of_device_id ov2640_of_match[] = {\n\t{.compatible = \"ovti,ov2640\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ov2640_of_match);\n\nstatic struct i2c_driver ov2640_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ov2640\",\n\t\t.of_match_table = ov2640_of_match,\n\t},\n\t.probe    = ov2640_probe,\n\t.remove   = ov2640_remove,\n\t.id_table = ov2640_id,\n};\n\nmodule_i2c_driver(ov2640_i2c_driver);\n\nMODULE_DESCRIPTION(\"Driver for Omni Vision 2640 sensor\");\nMODULE_AUTHOR(\"Alberto Panizzo\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}