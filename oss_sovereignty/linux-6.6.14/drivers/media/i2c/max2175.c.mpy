{
  "module_name": "max2175.c",
  "hash_id": "28f4fd338343bc68f4ac60d8bd37a47f32e42e7bf5ee27ffdb90ffba26c5df05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/max2175.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/max2175.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n\n#include \"max2175.h\"\n\n#define DRIVER_NAME \"max2175\"\n\n#define mxm_dbg(ctx, fmt, arg...) dev_dbg(&ctx->client->dev, fmt, ## arg)\n#define mxm_err(ctx, fmt, arg...) dev_err(&ctx->client->dev, fmt, ## arg)\n\n \nstruct max2175_rxmode {\n\tenum max2175_band band;\t\t \n\tu32 freq;\t\t\t \n\tu8 i2s_word_size;\t\t \n};\n\n \nstruct max2175_reg_map {\n\tu8 idx;\t\t\t\t \n\tu8 val;\t\t\t\t \n};\n\nstatic const struct max2175_rxmode eu_rx_modes[] = {\n\t \n\t[MAX2175_EU_FM_1_2] = { MAX2175_BAND_FM, 98256000, 1 },\n\t[MAX2175_DAB_1_2]   = { MAX2175_BAND_VHF, 182640000, 0 },\n};\n\nstatic const struct max2175_rxmode na_rx_modes[] = {\n\t \n\t[MAX2175_NA_FM_1_0] = { MAX2175_BAND_FM, 98255520, 1 },\n\t[MAX2175_NA_FM_2_0] = { MAX2175_BAND_FM, 98255520, 6 },\n};\n\n \nstatic const u8 full_fm_eu_1p0[] = {\n\t0x15, 0x04, 0xb8, 0xe3, 0x35, 0x18, 0x7c, 0x00,\n\t0x00, 0x7d, 0x40, 0x08, 0x70, 0x7a, 0x88, 0x91,\n\t0x61, 0x61, 0x61, 0x61, 0x5a, 0x0f, 0x34, 0x1c,\n\t0x14, 0x88, 0x33, 0x02, 0x00, 0x09, 0x00, 0x65,\n\t0x9f, 0x2b, 0x80, 0x00, 0x95, 0x05, 0x2c, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,\n\t0x4a, 0x08, 0xa8, 0x0e, 0x0e, 0x2f, 0x7e, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0xab, 0x5e, 0xa9,\n\t0xae, 0xbb, 0x57, 0x18, 0x3b, 0x03, 0x3b, 0x64,\n\t0x40, 0x60, 0x00, 0x2a, 0xbf, 0x3f, 0xff, 0x9f,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00,\n\t0xff, 0xfc, 0xef, 0x1c, 0x40, 0x00, 0x00, 0x02,\n\t0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0xac, 0x40, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00,\n\t0x00, 0x47, 0x00, 0x00, 0x11, 0x3f, 0x22, 0x00,\n\t0xf1, 0x00, 0x41, 0x03, 0xb0, 0x00, 0x00, 0x00,\n\t0x1b,\n};\n\nstatic const u8 full_fm_na_1p0[] = {\n\t0x13, 0x08, 0x8d, 0xc0, 0x35, 0x18, 0x7d, 0x3f,\n\t0x7d, 0x75, 0x40, 0x08, 0x70, 0x7a, 0x88, 0x91,\n\t0x61, 0x61, 0x61, 0x61, 0x5c, 0x0f, 0x34, 0x1c,\n\t0x14, 0x88, 0x33, 0x02, 0x00, 0x01, 0x00, 0x65,\n\t0x9f, 0x2b, 0x80, 0x00, 0x95, 0x05, 0x2c, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,\n\t0x4a, 0x08, 0xa8, 0x0e, 0x0e, 0xaf, 0x7e, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0xab, 0x5e, 0xa9,\n\t0xae, 0xbb, 0x57, 0x18, 0x3b, 0x03, 0x3b, 0x64,\n\t0x40, 0x60, 0x00, 0x2a, 0xbf, 0x3f, 0xff, 0x9f,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00,\n\t0xff, 0xfc, 0xef, 0x1c, 0x40, 0x00, 0x00, 0x02,\n\t0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0xa6, 0x40, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00,\n\t0x00, 0x35, 0x00, 0x00, 0x11, 0x3f, 0x22, 0x00,\n\t0xf1, 0x00, 0x41, 0x03, 0xb0, 0x00, 0x00, 0x00,\n\t0x1b,\n};\n\n \nstatic const struct max2175_reg_map dab12_map[] = {\n\t{ 0x01, 0x13 }, { 0x02, 0x0d }, { 0x03, 0x15 }, { 0x04, 0x55 },\n\t{ 0x05, 0x0a }, { 0x06, 0xa0 }, { 0x07, 0x40 }, { 0x08, 0x00 },\n\t{ 0x09, 0x00 }, { 0x0a, 0x7d }, { 0x0b, 0x4a }, { 0x0c, 0x28 },\n\t{ 0x0e, 0x43 }, { 0x0f, 0xb5 }, { 0x10, 0x31 }, { 0x11, 0x9e },\n\t{ 0x12, 0x68 }, { 0x13, 0x9e }, { 0x14, 0x68 }, { 0x15, 0x58 },\n\t{ 0x16, 0x2f }, { 0x17, 0x3f }, { 0x18, 0x40 }, { 0x1a, 0x88 },\n\t{ 0x1b, 0xaa }, { 0x1c, 0x9a }, { 0x1d, 0x00 }, { 0x1e, 0x00 },\n\t{ 0x23, 0x80 }, { 0x24, 0x00 }, { 0x25, 0x00 }, { 0x26, 0x00 },\n\t{ 0x27, 0x00 }, { 0x32, 0x08 }, { 0x33, 0xf8 }, { 0x36, 0x2d },\n\t{ 0x37, 0x7e }, { 0x55, 0xaf }, { 0x56, 0x3f }, { 0x57, 0xf8 },\n\t{ 0x58, 0x99 }, { 0x76, 0x00 }, { 0x77, 0x00 }, { 0x78, 0x02 },\n\t{ 0x79, 0x40 }, { 0x82, 0x00 }, { 0x83, 0x00 }, { 0x85, 0x00 },\n\t{ 0x86, 0x20 },\n};\n\n \nstatic const struct max2175_reg_map fmeu1p2_map[] = {\n\t{ 0x01, 0x15 }, { 0x02, 0x04 }, { 0x03, 0xb8 }, { 0x04, 0xe3 },\n\t{ 0x05, 0x35 }, { 0x06, 0x18 }, { 0x07, 0x7c }, { 0x08, 0x00 },\n\t{ 0x09, 0x00 }, { 0x0a, 0x73 }, { 0x0b, 0x40 }, { 0x0c, 0x08 },\n\t{ 0x0e, 0x7a }, { 0x0f, 0x88 }, { 0x10, 0x91 }, { 0x11, 0x61 },\n\t{ 0x12, 0x61 }, { 0x13, 0x61 }, { 0x14, 0x61 }, { 0x15, 0x5a },\n\t{ 0x16, 0x0f }, { 0x17, 0x34 }, { 0x18, 0x1c }, { 0x1a, 0x88 },\n\t{ 0x1b, 0x33 }, { 0x1c, 0x02 }, { 0x1d, 0x00 }, { 0x1e, 0x01 },\n\t{ 0x23, 0x80 }, { 0x24, 0x00 }, { 0x25, 0x95 }, { 0x26, 0x05 },\n\t{ 0x27, 0x2c }, { 0x32, 0x08 }, { 0x33, 0xa8 }, { 0x36, 0x2f },\n\t{ 0x37, 0x7e }, { 0x55, 0xbf }, { 0x56, 0x3f }, { 0x57, 0xff },\n\t{ 0x58, 0x9f }, { 0x76, 0xac }, { 0x77, 0x40 }, { 0x78, 0x00 },\n\t{ 0x79, 0x00 }, { 0x82, 0x47 }, { 0x83, 0x00 }, { 0x85, 0x11 },\n\t{ 0x86, 0x3f },\n};\n\n \nstatic const struct max2175_reg_map fmna1p0_map[] = {\n\t{ 0x01, 0x13 }, { 0x02, 0x08 }, { 0x03, 0x8d }, { 0x04, 0xc0 },\n\t{ 0x05, 0x35 }, { 0x06, 0x18 }, { 0x07, 0x7d }, { 0x08, 0x3f },\n\t{ 0x09, 0x7d }, { 0x0a, 0x75 }, { 0x0b, 0x40 }, { 0x0c, 0x08 },\n\t{ 0x0e, 0x7a }, { 0x0f, 0x88 }, { 0x10, 0x91 }, { 0x11, 0x61 },\n\t{ 0x12, 0x61 }, { 0x13, 0x61 }, { 0x14, 0x61 }, { 0x15, 0x5c },\n\t{ 0x16, 0x0f }, { 0x17, 0x34 }, { 0x18, 0x1c }, { 0x1a, 0x88 },\n\t{ 0x1b, 0x33 }, { 0x1c, 0x02 }, { 0x1d, 0x00 }, { 0x1e, 0x01 },\n\t{ 0x23, 0x80 }, { 0x24, 0x00 }, { 0x25, 0x95 }, { 0x26, 0x05 },\n\t{ 0x27, 0x2c }, { 0x32, 0x08 }, { 0x33, 0xa8 }, { 0x36, 0xaf },\n\t{ 0x37, 0x7e }, { 0x55, 0xbf }, { 0x56, 0x3f }, { 0x57, 0xff },\n\t{ 0x58, 0x9f }, { 0x76, 0xa6 }, { 0x77, 0x40 }, { 0x78, 0x00 },\n\t{ 0x79, 0x00 }, { 0x82, 0x35 }, { 0x83, 0x00 }, { 0x85, 0x11 },\n\t{ 0x86, 0x3f },\n};\n\n \nstatic const struct max2175_reg_map fmna2p0_map[] = {\n\t{ 0x01, 0x13 }, { 0x02, 0x08 }, { 0x03, 0x8d }, { 0x04, 0xc0 },\n\t{ 0x05, 0x35 }, { 0x06, 0x18 }, { 0x07, 0x7c }, { 0x08, 0x54 },\n\t{ 0x09, 0xa7 }, { 0x0a, 0x55 }, { 0x0b, 0x42 }, { 0x0c, 0x48 },\n\t{ 0x0e, 0x7a }, { 0x0f, 0x88 }, { 0x10, 0x91 }, { 0x11, 0x61 },\n\t{ 0x12, 0x61 }, { 0x13, 0x61 }, { 0x14, 0x61 }, { 0x15, 0x5c },\n\t{ 0x16, 0x0f }, { 0x17, 0x34 }, { 0x18, 0x1c }, { 0x1a, 0x88 },\n\t{ 0x1b, 0x33 }, { 0x1c, 0x02 }, { 0x1d, 0x00 }, { 0x1e, 0x01 },\n\t{ 0x23, 0x80 }, { 0x24, 0x00 }, { 0x25, 0x95 }, { 0x26, 0x05 },\n\t{ 0x27, 0x2c }, { 0x32, 0x08 }, { 0x33, 0xa8 }, { 0x36, 0xaf },\n\t{ 0x37, 0x7e }, { 0x55, 0xbf }, { 0x56, 0x3f }, { 0x57, 0xff },\n\t{ 0x58, 0x9f }, { 0x76, 0xac }, { 0x77, 0xc0 }, { 0x78, 0x00 },\n\t{ 0x79, 0x00 }, { 0x82, 0x6b }, { 0x83, 0x00 }, { 0x85, 0x11 },\n\t{ 0x86, 0x3f },\n};\n\nstatic const u16 ch_coeff_dab1[] = {\n\t0x001c, 0x0007, 0xffcd, 0x0056, 0xffa4, 0x0033, 0x0027, 0xff61,\n\t0x010e, 0xfec0, 0x0106, 0xffb8, 0xff1c, 0x023c, 0xfcb2, 0x039b,\n\t0xfd4e, 0x0055, 0x036a, 0xf7de, 0x0d21, 0xee72, 0x1499, 0x6a51,\n};\n\nstatic const u16 ch_coeff_fmeu[] = {\n\t0x0000, 0xffff, 0x0001, 0x0002, 0xfffa, 0xffff, 0x0015, 0xffec,\n\t0xffde, 0x0054, 0xfff9, 0xff52, 0x00b8, 0x00a2, 0xfe0a, 0x00af,\n\t0x02e3, 0xfc14, 0xfe89, 0x089d, 0xfa2e, 0xf30f, 0x25be, 0x4eb6,\n};\n\nstatic const u16 eq_coeff_fmeu1_ra02_m6db[] = {\n\t0x0040, 0xffc6, 0xfffa, 0x002c, 0x000d, 0xff90, 0x0037, 0x006e,\n\t0xffc0, 0xff5b, 0x006a, 0x00f0, 0xff57, 0xfe94, 0x0112, 0x0252,\n\t0xfe0c, 0xfc6a, 0x0385, 0x0553, 0xfa49, 0xf789, 0x0b91, 0x1a10,\n};\n\nstatic const u16 ch_coeff_fmna[] = {\n\t0x0001, 0x0003, 0xfffe, 0xfff4, 0x0000, 0x001f, 0x000c, 0xffbc,\n\t0xffd3, 0x007d, 0x0075, 0xff33, 0xff01, 0x0131, 0x01ef, 0xfe60,\n\t0xfc7a, 0x020e, 0x0656, 0xfd94, 0xf395, 0x02ab, 0x2857, 0x3d3f,\n};\n\nstatic const u16 eq_coeff_fmna1_ra02_m6db[] = {\n\t0xfff1, 0xffe1, 0xffef, 0x000e, 0x0030, 0x002f, 0xfff6, 0xffa7,\n\t0xff9d, 0x000a, 0x00a2, 0x00b5, 0xffea, 0xfed9, 0xfec5, 0x003d,\n\t0x0217, 0x021b, 0xff5a, 0xfc2b, 0xfcbd, 0x02c4, 0x0ac3, 0x0e85,\n};\n\nstatic const u8 adc_presets[2][23] = {\n\t{\n\t\t0x83, 0x00, 0xcf, 0xb4, 0x0f, 0x2c, 0x0c, 0x49,\n\t\t0x00, 0x00, 0x00, 0x8c,\t0x02, 0x02, 0x00, 0x04,\n\t\t0xec, 0x82, 0x4b, 0xcc, 0x01, 0x88, 0x0c,\n\t},\n\t{\n\t\t0x83, 0x00, 0xcf, 0xb4,\t0x0f, 0x2c, 0x0c, 0x49,\n\t\t0x00, 0x00, 0x00, 0x8c,\t0x02, 0x20, 0x33, 0x8c,\n\t\t0x57, 0xd7, 0x59, 0xb7,\t0x65, 0x0e, 0x0c,\n\t},\n};\n\n \nstatic const struct v4l2_frequency_band eu_bands_rf = {\n\t.tuner = 0,\n\t.type = V4L2_TUNER_RF,\n\t.index = 0,\n\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t.rangelow   = 65000000,\n\t.rangehigh  = 240000000,\n};\n\nstatic const struct v4l2_frequency_band na_bands_rf = {\n\t.tuner = 0,\n\t.type = V4L2_TUNER_RF,\n\t.index = 0,\n\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t.rangelow   = 65000000,\n\t.rangehigh  = 108000000,\n};\n\n \nstatic const struct regmap_range max2175_regmap_volatile_range[] = {\n\tregmap_reg_range(0x30, 0x35),\n\tregmap_reg_range(0x3a, 0x45),\n\tregmap_reg_range(0x59, 0x5e),\n\tregmap_reg_range(0x73, 0x75),\n};\n\nstatic const struct regmap_access_table max2175_volatile_regs = {\n\t.yes_ranges = max2175_regmap_volatile_range,\n\t.n_yes_ranges = ARRAY_SIZE(max2175_regmap_volatile_range),\n};\n\nstatic const struct reg_default max2175_reg_defaults[] = {\n\t{ 0x00, 0x07},\n};\n\nstatic const struct regmap_config max2175_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xff,\n\t.reg_defaults = max2175_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(max2175_reg_defaults),\n\t.volatile_table = &max2175_volatile_regs,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstruct max2175 {\n\tstruct v4l2_subdev sd;\t\t \n\tstruct i2c_client *client;\t \n\n\t \n\tstruct v4l2_ctrl_handler ctrl_hdl;\n\tstruct v4l2_ctrl *lna_gain;\t \n\tstruct v4l2_ctrl *if_gain;\t \n\tstruct v4l2_ctrl *pll_lock;\t \n\tstruct v4l2_ctrl *i2s_en;\t \n\tstruct v4l2_ctrl *hsls;\t\t \n\tstruct v4l2_ctrl *rx_mode;\t \n\n\t \n\tstruct regmap *regmap;\n\n\t \n\tu32 freq;\t\t\t \n\tconst struct max2175_rxmode *rx_modes;\t\t \n\tconst struct v4l2_frequency_band *bands_rf;\t \n\n\t \n\tunsigned long xtal_freq;\t \n\tu32 decim_ratio;\n\tbool master;\t\t\t \n\tbool am_hiz;\t\t\t \n\n\t \n\tu8 rom_bbf_bw_am;\n\tu8 rom_bbf_bw_fm;\n\tu8 rom_bbf_bw_dab;\n\n\t \n\tbool mode_resolved;\t\t \n};\n\nstatic inline struct max2175 *max2175_from_sd(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct max2175, sd);\n}\n\nstatic inline struct max2175 *max2175_from_ctrl_hdl(struct v4l2_ctrl_handler *h)\n{\n\treturn container_of(h, struct max2175, ctrl_hdl);\n}\n\n \nstatic inline u8 max2175_get_bitval(u8 val, u8 msb, u8 lsb)\n{\n\treturn (val & GENMASK(msb, lsb)) >> lsb;\n}\n\n \nstatic int max2175_read(struct max2175 *ctx, u8 idx, u8 *val)\n{\n\tu32 regval;\n\tint ret;\n\n\tret = regmap_read(ctx->regmap, idx, &regval);\n\tif (ret)\n\t\tmxm_err(ctx, \"read ret(%d): idx 0x%02x\\n\", ret, idx);\n\telse\n\t\t*val = regval;\n\n\treturn ret;\n}\n\nstatic int max2175_write(struct max2175 *ctx, u8 idx, u8 val)\n{\n\tint ret;\n\n\tret = regmap_write(ctx->regmap, idx, val);\n\tif (ret)\n\t\tmxm_err(ctx, \"write ret(%d): idx 0x%02x val 0x%02x\\n\",\n\t\t\tret, idx, val);\n\n\treturn ret;\n}\n\nstatic u8 max2175_read_bits(struct max2175 *ctx, u8 idx, u8 msb, u8 lsb)\n{\n\tu8 val;\n\n\tif (max2175_read(ctx, idx, &val))\n\t\treturn 0;\n\n\treturn max2175_get_bitval(val, msb, lsb);\n}\n\nstatic int max2175_write_bits(struct max2175 *ctx, u8 idx,\n\t\t\t     u8 msb, u8 lsb, u8 newval)\n{\n\tint ret = regmap_update_bits(ctx->regmap, idx, GENMASK(msb, lsb),\n\t\t\t\t     newval << lsb);\n\n\tif (ret)\n\t\tmxm_err(ctx, \"wbits ret(%d): idx 0x%02x\\n\", ret, idx);\n\n\treturn ret;\n}\n\nstatic int max2175_write_bit(struct max2175 *ctx, u8 idx, u8 bit, u8 newval)\n{\n\treturn max2175_write_bits(ctx, idx, bit, bit, newval);\n}\n\n \nstatic int max2175_poll_timeout(struct max2175 *ctx, u8 idx, u8 msb, u8 lsb,\n\t\t\t\tu8 exp_bitval, u32 timeout_us)\n{\n\tunsigned int val;\n\n\treturn regmap_read_poll_timeout(ctx->regmap, idx, val,\n\t\t\t(max2175_get_bitval(val, msb, lsb) == exp_bitval),\n\t\t\t1000, timeout_us);\n}\n\nstatic int max2175_poll_csm_ready(struct max2175 *ctx)\n{\n\tint ret;\n\n\tret = max2175_poll_timeout(ctx, 69, 1, 1, 0, 50000);\n\tif (ret)\n\t\tmxm_err(ctx, \"csm not ready\\n\");\n\n\treturn ret;\n}\n\n#define MAX2175_IS_BAND_AM(ctx)\t\t\\\n\t(max2175_read_bits(ctx, 5, 1, 0) == MAX2175_BAND_AM)\n\n#define MAX2175_IS_BAND_VHF(ctx)\t\\\n\t(max2175_read_bits(ctx, 5, 1, 0) == MAX2175_BAND_VHF)\n\n#define MAX2175_IS_FM_MODE(ctx)\t\t\\\n\t(max2175_read_bits(ctx, 12, 5, 4) == 0)\n\n#define MAX2175_IS_FMHD_MODE(ctx)\t\\\n\t(max2175_read_bits(ctx, 12, 5, 4) == 1)\n\n#define MAX2175_IS_DAB_MODE(ctx)\t\\\n\t(max2175_read_bits(ctx, 12, 5, 4) == 2)\n\nstatic int max2175_band_from_freq(u32 freq)\n{\n\tif (freq >= 144000 && freq <= 26100000)\n\t\treturn MAX2175_BAND_AM;\n\telse if (freq >= 65000000 && freq <= 108000000)\n\t\treturn MAX2175_BAND_FM;\n\n\treturn MAX2175_BAND_VHF;\n}\n\nstatic void max2175_i2s_enable(struct max2175 *ctx, bool enable)\n{\n\tif (enable)\n\t\t \n\t\tmax2175_write_bits(ctx, 104, 3, 0, 2);\n\telse\n\t\t \n\t\tmax2175_write_bits(ctx, 104, 3, 0, 9);\n\tmxm_dbg(ctx, \"i2s %sabled\\n\", enable ? \"en\" : \"dis\");\n}\n\nstatic void max2175_set_filter_coeffs(struct max2175 *ctx, u8 m_sel,\n\t\t\t\t      u8 bank, const u16 *coeffs)\n{\n\tunsigned int i;\n\tu8 coeff_addr, upper_address = 24;\n\n\tmxm_dbg(ctx, \"set_filter_coeffs: m_sel %d bank %d\\n\", m_sel, bank);\n\tmax2175_write_bits(ctx, 114, 5, 4, m_sel);\n\n\tif (m_sel == 2)\n\t\tupper_address = 12;\n\n\tfor (i = 0; i < upper_address; i++) {\n\t\tcoeff_addr = i + bank * 24;\n\t\tmax2175_write(ctx, 115, coeffs[i] >> 8);\n\t\tmax2175_write(ctx, 116, coeffs[i]);\n\t\tmax2175_write(ctx, 117, coeff_addr | 1 << 7);\n\t}\n\tmax2175_write_bit(ctx, 117, 7, 0);\n}\n\nstatic void max2175_load_fmeu_1p2(struct max2175 *ctx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fmeu1p2_map); i++)\n\t\tmax2175_write(ctx, fmeu1p2_map[i].idx, fmeu1p2_map[i].val);\n\n\tctx->decim_ratio = 36;\n\n\t \n\tmax2175_set_filter_coeffs(ctx, MAX2175_CH_MSEL, 0, ch_coeff_fmeu);\n\tmax2175_set_filter_coeffs(ctx, MAX2175_EQ_MSEL, 0,\n\t\t\t\t  eq_coeff_fmeu1_ra02_m6db);\n}\n\nstatic void max2175_load_dab_1p2(struct max2175 *ctx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dab12_map); i++)\n\t\tmax2175_write(ctx, dab12_map[i].idx, dab12_map[i].val);\n\n\tctx->decim_ratio = 1;\n\n\t \n\tmax2175_set_filter_coeffs(ctx, MAX2175_CH_MSEL, 2, ch_coeff_dab1);\n}\n\nstatic void max2175_load_fmna_1p0(struct max2175 *ctx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fmna1p0_map); i++)\n\t\tmax2175_write(ctx, fmna1p0_map[i].idx, fmna1p0_map[i].val);\n}\n\nstatic void max2175_load_fmna_2p0(struct max2175 *ctx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fmna2p0_map); i++)\n\t\tmax2175_write(ctx, fmna2p0_map[i].idx, fmna2p0_map[i].val);\n}\n\nstatic void max2175_set_bbfilter(struct max2175 *ctx)\n{\n\tif (MAX2175_IS_BAND_AM(ctx)) {\n\t\tmax2175_write_bits(ctx, 12, 3, 0, ctx->rom_bbf_bw_am);\n\t\tmxm_dbg(ctx, \"set_bbfilter AM: rom %d\\n\", ctx->rom_bbf_bw_am);\n\t} else if (MAX2175_IS_DAB_MODE(ctx)) {\n\t\tmax2175_write_bits(ctx, 12, 3, 0, ctx->rom_bbf_bw_dab);\n\t\tmxm_dbg(ctx, \"set_bbfilter DAB: rom %d\\n\", ctx->rom_bbf_bw_dab);\n\t} else {\n\t\tmax2175_write_bits(ctx, 12, 3, 0, ctx->rom_bbf_bw_fm);\n\t\tmxm_dbg(ctx, \"set_bbfilter FM: rom %d\\n\", ctx->rom_bbf_bw_fm);\n\t}\n}\n\nstatic int max2175_set_csm_mode(struct max2175 *ctx,\n\t\t\t  enum max2175_csm_mode new_mode)\n{\n\tint ret = max2175_poll_csm_ready(ctx);\n\n\tif (ret)\n\t\treturn ret;\n\n\tmax2175_write_bits(ctx, 0, 2, 0, new_mode);\n\tmxm_dbg(ctx, \"set csm new mode %d\\n\", new_mode);\n\n\t \n\tswitch (new_mode) {\n\tcase MAX2175_PRESET_TUNE:\n\t\tusleep_range(51100, 51500);\t \n\t\tbreak;\n\t \n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn max2175_poll_csm_ready(ctx);\n}\n\nstatic int max2175_csm_action(struct max2175 *ctx,\n\t\t\t      enum max2175_csm_mode action)\n{\n\tint ret;\n\n\tmxm_dbg(ctx, \"csm_action: %d\\n\", action);\n\n\t \n\tret = max2175_set_csm_mode(ctx, MAX2175_LOAD_TO_BUFFER);\n\tif (ret)\n\t\treturn ret;\n\n\treturn max2175_set_csm_mode(ctx, MAX2175_PRESET_TUNE);\n}\n\nstatic int max2175_set_lo_freq(struct max2175 *ctx, u32 lo_freq)\n{\n\tu8 lo_mult, loband_bits = 0, vcodiv_bits = 0;\n\tu32 int_desired, frac_desired;\n\tenum max2175_band band;\n\tint ret;\n\n\tband = max2175_read_bits(ctx, 5, 1, 0);\n\tswitch (band) {\n\tcase MAX2175_BAND_AM:\n\t\tlo_mult = 16;\n\t\tbreak;\n\tcase MAX2175_BAND_FM:\n\t\tif (lo_freq <= 74700000) {\n\t\t\tlo_mult = 16;\n\t\t} else if (lo_freq > 74700000 && lo_freq <= 110000000) {\n\t\t\tloband_bits = 1;\n\t\t\tlo_mult = 8;\n\t\t} else {\n\t\t\tloband_bits = 1;\n\t\t\tvcodiv_bits = 3;\n\t\t\tlo_mult = 8;\n\t\t}\n\t\tbreak;\n\tcase MAX2175_BAND_VHF:\n\t\tif (lo_freq <= 210000000)\n\t\t\tvcodiv_bits = 2;\n\t\telse\n\t\t\tvcodiv_bits = 1;\n\n\t\tloband_bits = 2;\n\t\tlo_mult = 4;\n\t\tbreak;\n\tdefault:\n\t\tloband_bits = 3;\n\t\tvcodiv_bits = 2;\n\t\tlo_mult = 2;\n\t\tbreak;\n\t}\n\n\tif (band == MAX2175_BAND_L)\n\t\tlo_freq /= lo_mult;\n\telse\n\t\tlo_freq *= lo_mult;\n\n\tint_desired = lo_freq / ctx->xtal_freq;\n\tfrac_desired = div64_ul((u64)(lo_freq % ctx->xtal_freq) << 20,\n\t\t\t\tctx->xtal_freq);\n\n\t \n\tret = max2175_poll_csm_ready(ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tmxm_dbg(ctx, \"lo_mult %u int %u  frac %u\\n\",\n\t\tlo_mult, int_desired, frac_desired);\n\n\t \n\tmax2175_write(ctx, 1, int_desired);\n\tmax2175_write_bits(ctx, 2, 3, 0, (frac_desired >> 16) & 0xf);\n\tmax2175_write(ctx, 3, frac_desired >> 8);\n\tmax2175_write(ctx, 4, frac_desired);\n\tmax2175_write_bits(ctx, 5, 3, 2, loband_bits);\n\tmax2175_write_bits(ctx, 6, 7, 6, vcodiv_bits);\n\n\treturn ret;\n}\n\n \nstatic inline s64 max2175_round_closest(s64 dividend, s32 divisor)\n{\n\tif ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0))\n\t\treturn div_s64(dividend + divisor / 2, divisor);\n\n\treturn div_s64(dividend - divisor / 2, divisor);\n}\n\nstatic int max2175_set_nco_freq(struct max2175 *ctx, s32 nco_freq)\n{\n\ts32 clock_rate = ctx->xtal_freq / ctx->decim_ratio;\n\tu32 nco_reg, abs_nco_freq = abs(nco_freq);\n\ts64 nco_val_desired;\n\tint ret;\n\n\tif (abs_nco_freq < clock_rate / 2) {\n\t\tnco_val_desired = 2 * nco_freq;\n\t} else {\n\t\tnco_val_desired = 2LL * (clock_rate - abs_nco_freq);\n\t\tif (nco_freq < 0)\n\t\t\tnco_val_desired = -nco_val_desired;\n\t}\n\n\tnco_reg = max2175_round_closest(nco_val_desired << 20, clock_rate);\n\n\tif (nco_freq < 0)\n\t\tnco_reg += 0x200000;\n\n\t \n\tret = max2175_poll_csm_ready(ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tmxm_dbg(ctx, \"freq %d desired %lld reg %u\\n\",\n\t\tnco_freq, nco_val_desired, nco_reg);\n\n\t \n\tmax2175_write_bits(ctx, 7, 4, 0, (nco_reg >> 16) & 0x1f);\n\tmax2175_write(ctx, 8, nco_reg >> 8);\n\tmax2175_write(ctx, 9, nco_reg);\n\n\treturn ret;\n}\n\nstatic int max2175_set_rf_freq_non_am_bands(struct max2175 *ctx, u64 freq,\n\t\t\t\t\t    u32 lo_pos)\n{\n\ts64 adj_freq, low_if_freq;\n\tint ret;\n\n\tmxm_dbg(ctx, \"rf_freq: non AM bands\\n\");\n\n\tif (MAX2175_IS_FM_MODE(ctx))\n\t\tlow_if_freq = 128000;\n\telse if (MAX2175_IS_FMHD_MODE(ctx))\n\t\tlow_if_freq = 228000;\n\telse\n\t\treturn max2175_set_lo_freq(ctx, freq);\n\n\tif (MAX2175_IS_BAND_VHF(ctx) == (lo_pos == MAX2175_LO_ABOVE_DESIRED))\n\t\tadj_freq = freq + low_if_freq;\n\telse\n\t\tadj_freq = freq - low_if_freq;\n\n\tret = max2175_set_lo_freq(ctx, adj_freq);\n\tif (ret)\n\t\treturn ret;\n\n\treturn max2175_set_nco_freq(ctx, -low_if_freq);\n}\n\nstatic int max2175_set_rf_freq(struct max2175 *ctx, u64 freq, u32 lo_pos)\n{\n\tint ret;\n\n\tif (MAX2175_IS_BAND_AM(ctx))\n\t\tret = max2175_set_nco_freq(ctx, freq);\n\telse\n\t\tret = max2175_set_rf_freq_non_am_bands(ctx, freq, lo_pos);\n\n\tmxm_dbg(ctx, \"set_rf_freq: ret %d freq %llu\\n\", ret, freq);\n\n\treturn ret;\n}\n\nstatic int max2175_tune_rf_freq(struct max2175 *ctx, u64 freq, u32 hsls)\n{\n\tint ret;\n\n\tret = max2175_set_rf_freq(ctx, freq, hsls);\n\tif (ret)\n\t\treturn ret;\n\n\tret = max2175_csm_action(ctx, MAX2175_BUFFER_PLUS_PRESET_TUNE);\n\tif (ret)\n\t\treturn ret;\n\n\tmxm_dbg(ctx, \"tune_rf_freq: old %u new %llu\\n\", ctx->freq, freq);\n\tctx->freq = freq;\n\n\treturn ret;\n}\n\nstatic void max2175_set_hsls(struct max2175 *ctx, u32 lo_pos)\n{\n\tmxm_dbg(ctx, \"set_hsls: lo_pos %u\\n\", lo_pos);\n\n\tif ((lo_pos == MAX2175_LO_BELOW_DESIRED) == MAX2175_IS_BAND_VHF(ctx))\n\t\tmax2175_write_bit(ctx, 5, 4, 1);\n\telse\n\t\tmax2175_write_bit(ctx, 5, 4, 0);\n}\n\nstatic void max2175_set_eu_rx_mode(struct max2175 *ctx, u32 rx_mode)\n{\n\tswitch (rx_mode) {\n\tcase MAX2175_EU_FM_1_2:\n\t\tmax2175_load_fmeu_1p2(ctx);\n\t\tbreak;\n\n\tcase MAX2175_DAB_1_2:\n\t\tmax2175_load_dab_1p2(ctx);\n\t\tbreak;\n\t}\n\t \n\tif (!ctx->master)\n\t\tmax2175_write_bit(ctx, 30, 7, 1);\n}\n\nstatic void max2175_set_na_rx_mode(struct max2175 *ctx, u32 rx_mode)\n{\n\tswitch (rx_mode) {\n\tcase MAX2175_NA_FM_1_0:\n\t\tmax2175_load_fmna_1p0(ctx);\n\t\tbreak;\n\tcase MAX2175_NA_FM_2_0:\n\t\tmax2175_load_fmna_2p0(ctx);\n\t\tbreak;\n\t}\n\t \n\tif (!ctx->master)\n\t\tmax2175_write_bit(ctx, 30, 7, 1);\n\n\tctx->decim_ratio = 27;\n\n\t \n\tmax2175_set_filter_coeffs(ctx, MAX2175_CH_MSEL, 0, ch_coeff_fmna);\n\tmax2175_set_filter_coeffs(ctx, MAX2175_EQ_MSEL, 0,\n\t\t\t\t  eq_coeff_fmna1_ra02_m6db);\n}\n\nstatic int max2175_set_rx_mode(struct max2175 *ctx, u32 rx_mode)\n{\n\tmxm_dbg(ctx, \"set_rx_mode: %u am_hiz %u\\n\", rx_mode, ctx->am_hiz);\n\tif (ctx->xtal_freq == MAX2175_EU_XTAL_FREQ)\n\t\tmax2175_set_eu_rx_mode(ctx, rx_mode);\n\telse\n\t\tmax2175_set_na_rx_mode(ctx, rx_mode);\n\n\tif (ctx->am_hiz) {\n\t\tmxm_dbg(ctx, \"setting AM HiZ related config\\n\");\n\t\tmax2175_write_bit(ctx, 50, 5, 1);\n\t\tmax2175_write_bit(ctx, 90, 7, 1);\n\t\tmax2175_write_bits(ctx, 73, 1, 0, 2);\n\t\tmax2175_write_bits(ctx, 80, 5, 0, 33);\n\t}\n\n\t \n\tmax2175_set_bbfilter(ctx);\n\n\t \n\tmax2175_set_hsls(ctx, ctx->hsls->cur.val);\n\n\t \n\tmax2175_i2s_enable(ctx, ctx->i2s_en->cur.val);\n\n\tctx->mode_resolved = true;\n\n\treturn 0;\n}\n\nstatic int max2175_rx_mode_from_freq(struct max2175 *ctx, u32 freq, u32 *mode)\n{\n\tunsigned int i;\n\tint band = max2175_band_from_freq(freq);\n\n\t \n\tfor (i = 0; i <= ctx->rx_mode->maximum; i++) {\n\t\tif (ctx->rx_modes[i].band == band) {\n\t\t\t*mode = i;\n\t\t\tmxm_dbg(ctx, \"rx_mode_from_freq: freq %u mode %d\\n\",\n\t\t\t\tfreq, *mode);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic bool max2175_freq_rx_mode_valid(struct max2175 *ctx,\n\t\t\t\t\t u32 mode, u32 freq)\n{\n\tint band = max2175_band_from_freq(freq);\n\n\treturn (ctx->rx_modes[mode].band == band);\n}\n\nstatic void max2175_load_adc_presets(struct max2175 *ctx)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(adc_presets); i++)\n\t\tfor (j = 0; j < ARRAY_SIZE(adc_presets[0]); j++)\n\t\t\tmax2175_write(ctx, 146 + j + i * 55, adc_presets[i][j]);\n}\n\nstatic int max2175_init_power_manager(struct max2175 *ctx)\n{\n\tint ret;\n\n\t \n\tmax2175_write_bit(ctx, 99, 2, 0);\n\tusleep_range(1000, 1500);\n\tmax2175_write_bit(ctx, 99, 2, 1);\n\n\t \n\tret = max2175_poll_timeout(ctx, 69, 7, 7, 1, 50000);\n\tif (ret)\n\t\tmxm_err(ctx, \"init pm failed\\n\");\n\n\treturn ret;\n}\n\nstatic int max2175_recalibrate_adc(struct max2175 *ctx)\n{\n\tint ret;\n\n\t \n\tmax2175_write(ctx, 150, 0xff);\n\tmax2175_write(ctx, 205, 0xff);\n\tmax2175_write(ctx, 147, 0x20);\n\tmax2175_write(ctx, 147, 0x00);\n\tmax2175_write(ctx, 202, 0x20);\n\tmax2175_write(ctx, 202, 0x00);\n\n\tret = max2175_poll_timeout(ctx, 69, 4, 3, 3, 50000);\n\tif (ret)\n\t\tmxm_err(ctx, \"adc recalibration failed\\n\");\n\n\treturn ret;\n}\n\nstatic u8 max2175_read_rom(struct max2175 *ctx, u8 row)\n{\n\tu8 data = 0;\n\n\tmax2175_write_bit(ctx, 56, 4, 0);\n\tmax2175_write_bits(ctx, 56, 3, 0, row);\n\n\tusleep_range(2000, 2500);\n\tmax2175_read(ctx, 58, &data);\n\n\tmax2175_write_bits(ctx, 56, 3, 0, 0);\n\n\tmxm_dbg(ctx, \"read_rom: row %d data 0x%02x\\n\", row, data);\n\n\treturn data;\n}\n\nstatic void max2175_load_from_rom(struct max2175 *ctx)\n{\n\tu8 data = 0;\n\n\tdata = max2175_read_rom(ctx, 0);\n\tctx->rom_bbf_bw_am = data & 0x0f;\n\tmax2175_write_bits(ctx, 81, 3, 0, data >> 4);\n\n\tdata = max2175_read_rom(ctx, 1);\n\tctx->rom_bbf_bw_fm = data & 0x0f;\n\tctx->rom_bbf_bw_dab = data >> 4;\n\n\tdata = max2175_read_rom(ctx, 2);\n\tmax2175_write_bits(ctx, 82, 4, 0, data & 0x1f);\n\tmax2175_write_bits(ctx, 82, 7, 5, data >> 5);\n\n\tdata = max2175_read_rom(ctx, 3);\n\tif (ctx->am_hiz) {\n\t\tdata &= 0x0f;\n\t\tdata |= (max2175_read_rom(ctx, 7) & 0x40) >> 2;\n\t\tif (!data)\n\t\t\tdata |= 2;\n\t} else {\n\t\tdata = (data & 0xf0) >> 4;\n\t\tdata |= (max2175_read_rom(ctx, 7) & 0x80) >> 3;\n\t\tif (!data)\n\t\t\tdata |= 30;\n\t}\n\tmax2175_write_bits(ctx, 80, 5, 0, data + 31);\n\n\tdata = max2175_read_rom(ctx, 6);\n\tmax2175_write_bits(ctx, 81, 7, 6, data >> 6);\n}\n\nstatic void max2175_load_full_fm_eu_1p0(struct max2175 *ctx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(full_fm_eu_1p0); i++)\n\t\tmax2175_write(ctx, i + 1, full_fm_eu_1p0[i]);\n\n\tusleep_range(5000, 5500);\n\tctx->decim_ratio = 36;\n}\n\nstatic void max2175_load_full_fm_na_1p0(struct max2175 *ctx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(full_fm_na_1p0); i++)\n\t\tmax2175_write(ctx, i + 1, full_fm_na_1p0[i]);\n\n\tusleep_range(5000, 5500);\n\tctx->decim_ratio = 27;\n}\n\nstatic int max2175_core_init(struct max2175 *ctx, u32 refout_bits)\n{\n\tint ret;\n\n\t \n\tif (ctx->xtal_freq == MAX2175_EU_XTAL_FREQ)\n\t\tmax2175_load_full_fm_eu_1p0(ctx);\n\telse\n\t\tmax2175_load_full_fm_na_1p0(ctx);\n\n\t \n\tif (!ctx->master)\n\t\tmax2175_write_bit(ctx, 30, 7, 1);\n\n\tmxm_dbg(ctx, \"refout_bits %u\\n\", refout_bits);\n\n\t \n\tmax2175_write_bits(ctx, 56, 7, 5, refout_bits);\n\n\t \n\tmax2175_write_bit(ctx, 99, 1, 0);\n\tusleep_range(1000, 1500);\n\tmax2175_write_bit(ctx, 99, 1, 1);\n\n\t \n\tmax2175_load_adc_presets(ctx);\n\n\t \n\tret = max2175_init_power_manager(ctx);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = max2175_recalibrate_adc(ctx);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmax2175_load_from_rom(ctx);\n\n\tif (ctx->xtal_freq == MAX2175_EU_XTAL_FREQ) {\n\t\t \n\t\tmax2175_set_filter_coeffs(ctx, MAX2175_CH_MSEL, 0,\n\t\t\t\t\t  ch_coeff_fmeu);\n\t\tmax2175_set_filter_coeffs(ctx, MAX2175_EQ_MSEL, 0,\n\t\t\t\t\t  eq_coeff_fmeu1_ra02_m6db);\n\t} else {\n\t\t \n\t\tmax2175_set_filter_coeffs(ctx, MAX2175_CH_MSEL, 0,\n\t\t\t\t\t  ch_coeff_fmna);\n\t\tmax2175_set_filter_coeffs(ctx, MAX2175_EQ_MSEL, 0,\n\t\t\t\t\t  eq_coeff_fmna1_ra02_m6db);\n\t}\n\tmxm_dbg(ctx, \"core initialized\\n\");\n\n\treturn 0;\n}\n\nstatic void max2175_s_ctrl_rx_mode(struct max2175 *ctx, u32 rx_mode)\n{\n\t \n\tmax2175_set_rx_mode(ctx, rx_mode);\n\n\tmxm_dbg(ctx, \"s_ctrl_rx_mode: %u curr freq %u\\n\", rx_mode, ctx->freq);\n\n\t \n\tif (max2175_freq_rx_mode_valid(ctx, rx_mode, ctx->freq))\n\t\tmax2175_tune_rf_freq(ctx, ctx->freq, ctx->hsls->cur.val);\n\telse\n\t\t \n\t\tmax2175_tune_rf_freq(ctx, ctx->rx_modes[rx_mode].freq,\n\t\t\t\t     ctx->hsls->cur.val);\n}\n\nstatic int max2175_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct max2175 *ctx = max2175_from_ctrl_hdl(ctrl->handler);\n\n\tmxm_dbg(ctx, \"s_ctrl: id 0x%x, val %u\\n\", ctrl->id, ctrl->val);\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_MAX2175_I2S_ENABLE:\n\t\tmax2175_i2s_enable(ctx, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_MAX2175_HSLS:\n\t\tmax2175_set_hsls(ctx, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_MAX2175_RX_MODE:\n\t\tmax2175_s_ctrl_rx_mode(ctx, ctrl->val);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 max2175_get_lna_gain(struct max2175 *ctx)\n{\n\tenum max2175_band band = max2175_read_bits(ctx, 5, 1, 0);\n\n\tswitch (band) {\n\tcase MAX2175_BAND_AM:\n\t\treturn max2175_read_bits(ctx, 51, 3, 0);\n\tcase MAX2175_BAND_FM:\n\t\treturn max2175_read_bits(ctx, 50, 3, 0);\n\tcase MAX2175_BAND_VHF:\n\t\treturn max2175_read_bits(ctx, 52, 5, 0);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int max2175_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct max2175 *ctx = max2175_from_ctrl_hdl(ctrl->handler);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_RF_TUNER_LNA_GAIN:\n\t\tctrl->val = max2175_get_lna_gain(ctx);\n\t\tbreak;\n\tcase V4L2_CID_RF_TUNER_IF_GAIN:\n\t\tctrl->val = max2175_read_bits(ctx, 49, 4, 0);\n\t\tbreak;\n\tcase V4L2_CID_RF_TUNER_PLL_LOCK:\n\t\tctrl->val = (max2175_read_bits(ctx, 60, 7, 6) == 3);\n\t\tbreak;\n\t}\n\n\treturn 0;\n};\n\nstatic int max2175_set_freq_and_mode(struct max2175 *ctx, u32 freq)\n{\n\tu32 rx_mode;\n\tint ret;\n\n\t \n\tret = max2175_rx_mode_from_freq(ctx, freq, &rx_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tmxm_dbg(ctx, \"set_freq_and_mode: freq %u rx_mode %d\\n\", freq, rx_mode);\n\n\t \n\tmax2175_set_rx_mode(ctx, rx_mode);\n\tctx->rx_mode->cur.val = rx_mode;\n\n\t \n\treturn max2175_tune_rf_freq(ctx, freq, ctx->hsls->cur.val);\n}\n\nstatic int max2175_s_frequency(struct v4l2_subdev *sd,\n\t\t\t       const struct v4l2_frequency *vf)\n{\n\tstruct max2175 *ctx = max2175_from_sd(sd);\n\tu32 freq;\n\tint ret = 0;\n\n\tmxm_dbg(ctx, \"s_freq: new %u curr %u, mode_resolved %d\\n\",\n\t\tvf->frequency, ctx->freq, ctx->mode_resolved);\n\n\tif (vf->tuner != 0)\n\t\treturn -EINVAL;\n\n\tfreq = clamp(vf->frequency, ctx->bands_rf->rangelow,\n\t\t     ctx->bands_rf->rangehigh);\n\n\t \n\tif (ctx->mode_resolved &&\n\t    max2175_freq_rx_mode_valid(ctx, ctx->rx_mode->cur.val, freq))\n\t\tret = max2175_tune_rf_freq(ctx, freq, ctx->hsls->cur.val);\n\telse\n\t\t \n\t\tret = max2175_set_freq_and_mode(ctx, freq);\n\n\tmxm_dbg(ctx, \"s_freq: ret %d curr %u mode_resolved %d mode %u\\n\",\n\t\tret, ctx->freq, ctx->mode_resolved, ctx->rx_mode->cur.val);\n\n\treturn ret;\n}\n\nstatic int max2175_g_frequency(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_frequency *vf)\n{\n\tstruct max2175 *ctx = max2175_from_sd(sd);\n\n\tif (vf->tuner != 0)\n\t\treturn -EINVAL;\n\n\t \n\tvf->type = V4L2_TUNER_RF;\n\tvf->frequency = ctx->freq;\n\n\treturn 0;\n}\n\nstatic int max2175_enum_freq_bands(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_frequency_band *band)\n{\n\tstruct max2175 *ctx = max2175_from_sd(sd);\n\n\tif (band->tuner != 0 || band->index != 0)\n\t\treturn -EINVAL;\n\n\t*band = *ctx->bands_rf;\n\n\treturn 0;\n}\n\nstatic int max2175_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\n{\n\tstruct max2175 *ctx = max2175_from_sd(sd);\n\n\tif (vt->index > 0)\n\t\treturn -EINVAL;\n\n\tstrscpy(vt->name, \"RF\", sizeof(vt->name));\n\tvt->type = V4L2_TUNER_RF;\n\tvt->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\n\tvt->rangelow = ctx->bands_rf->rangelow;\n\tvt->rangehigh = ctx->bands_rf->rangehigh;\n\n\treturn 0;\n}\n\nstatic int max2175_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *vt)\n{\n\t \n\tif (vt->index > 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_tuner_ops max2175_tuner_ops = {\n\t.s_frequency = max2175_s_frequency,\n\t.g_frequency = max2175_g_frequency,\n\t.enum_freq_bands = max2175_enum_freq_bands,\n\t.g_tuner = max2175_g_tuner,\n\t.s_tuner = max2175_s_tuner,\n};\n\nstatic const struct v4l2_subdev_ops max2175_ops = {\n\t.tuner = &max2175_tuner_ops,\n};\n\nstatic const struct v4l2_ctrl_ops max2175_ctrl_ops = {\n\t.s_ctrl = max2175_s_ctrl,\n\t.g_volatile_ctrl = max2175_g_volatile_ctrl,\n};\n\n \nstatic const struct v4l2_ctrl_config max2175_i2s_en = {\n\t.ops = &max2175_ctrl_ops,\n\t.id = V4L2_CID_MAX2175_I2S_ENABLE,\n\t.name = \"I2S Enable\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.min = 0,\n\t.max = 1,\n\t.step = 1,\n\t.def = 1,\n\t.is_private = 1,\n};\n\n \nstatic const struct v4l2_ctrl_config max2175_hsls = {\n\t.ops = &max2175_ctrl_ops,\n\t.id = V4L2_CID_MAX2175_HSLS,\n\t.name = \"HSLS Above/Below Desired\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.min = 0,\n\t.max = 1,\n\t.step = 1,\n\t.def = 1,\n};\n\n \nstatic const char * const max2175_ctrl_eu_rx_modes[] = {\n\t[MAX2175_EU_FM_1_2]\t= \"EU FM 1.2\",\n\t[MAX2175_DAB_1_2]\t= \"DAB 1.2\",\n};\n\nstatic const char * const max2175_ctrl_na_rx_modes[] = {\n\t[MAX2175_NA_FM_1_0]\t= \"NA FM 1.0\",\n\t[MAX2175_NA_FM_2_0]\t= \"NA FM 2.0\",\n};\n\nstatic const struct v4l2_ctrl_config max2175_eu_rx_mode = {\n\t.ops = &max2175_ctrl_ops,\n\t.id = V4L2_CID_MAX2175_RX_MODE,\n\t.name = \"RX Mode\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.max = ARRAY_SIZE(max2175_ctrl_eu_rx_modes) - 1,\n\t.def = 0,\n\t.qmenu = max2175_ctrl_eu_rx_modes,\n};\n\nstatic const struct v4l2_ctrl_config max2175_na_rx_mode = {\n\t.ops = &max2175_ctrl_ops,\n\t.id = V4L2_CID_MAX2175_RX_MODE,\n\t.name = \"RX Mode\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.max = ARRAY_SIZE(max2175_ctrl_na_rx_modes) - 1,\n\t.def = 0,\n\t.qmenu = max2175_ctrl_na_rx_modes,\n};\n\nstatic int max2175_refout_load_to_bits(struct i2c_client *client, u32 load,\n\t\t\t\t       u32 *bits)\n{\n\tif (load <= 40)\n\t\t*bits = load / 10;\n\telse if (load >= 60 && load <= 70)\n\t\t*bits = load / 10 - 1;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int max2175_probe(struct i2c_client *client)\n{\n\tbool master = true, am_hiz = false;\n\tu32 refout_load, refout_bits = 0;\t \n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct fwnode_handle *fwnode;\n\tstruct device_node *np;\n\tstruct v4l2_subdev *sd;\n\tstruct regmap *regmap;\n\tstruct max2175 *ctx;\n\tstruct clk *clk;\n\tint ret;\n\n\t \n\tnp = of_parse_phandle(client->dev.of_node, \"maxim,master\", 0);\n\tif (np) {\n\t\tmaster = false;\t\t\t \n\t\tof_node_put(np);\n\t}\n\n\tfwnode = of_fwnode_handle(client->dev.of_node);\n\tif (fwnode_property_present(fwnode, \"maxim,am-hiz-filter\"))\n\t\tam_hiz = true;\n\n\tif (!fwnode_property_read_u32(fwnode, \"maxim,refout-load\",\n\t\t\t\t      &refout_load)) {\n\t\tret = max2175_refout_load_to_bits(client, refout_load,\n\t\t\t\t\t\t  &refout_bits);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"invalid refout_load %u\\n\",\n\t\t\t\trefout_load);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tclk = devm_clk_get(&client->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tdev_err(&client->dev, \"cannot get clock %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregmap = devm_regmap_init_i2c(client, &max2175_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tret = PTR_ERR(regmap);\n\t\tdev_err(&client->dev, \"regmap init failed %d\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tctx = devm_kzalloc(&client->dev, sizeof(*ctx), GFP_KERNEL);\n\tif (ctx == NULL)\n\t\treturn -ENOMEM;\n\n\tsd = &ctx->sd;\n\tctx->master = master;\n\tctx->am_hiz = am_hiz;\n\tctx->mode_resolved = false;\n\tctx->regmap = regmap;\n\tctx->xtal_freq = clk_get_rate(clk);\n\tdev_info(&client->dev, \"xtal freq %luHz\\n\", ctx->xtal_freq);\n\n\tv4l2_i2c_subdev_init(sd, client, &max2175_ops);\n\tctx->client = client;\n\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\t \n\thdl = &ctx->ctrl_hdl;\n\tret = v4l2_ctrl_handler_init(hdl, 7);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->lna_gain = v4l2_ctrl_new_std(hdl, &max2175_ctrl_ops,\n\t\t\t\t\t  V4L2_CID_RF_TUNER_LNA_GAIN,\n\t\t\t\t\t  0, 63, 1, 0);\n\tctx->lna_gain->flags |= (V4L2_CTRL_FLAG_VOLATILE |\n\t\t\t\t V4L2_CTRL_FLAG_READ_ONLY);\n\tctx->if_gain = v4l2_ctrl_new_std(hdl, &max2175_ctrl_ops,\n\t\t\t\t\t V4L2_CID_RF_TUNER_IF_GAIN,\n\t\t\t\t\t 0, 31, 1, 0);\n\tctx->if_gain->flags |= (V4L2_CTRL_FLAG_VOLATILE |\n\t\t\t\tV4L2_CTRL_FLAG_READ_ONLY);\n\tctx->pll_lock = v4l2_ctrl_new_std(hdl, &max2175_ctrl_ops,\n\t\t\t\t\t  V4L2_CID_RF_TUNER_PLL_LOCK,\n\t\t\t\t\t  0, 1, 1, 0);\n\tctx->pll_lock->flags |= (V4L2_CTRL_FLAG_VOLATILE |\n\t\t\t\t V4L2_CTRL_FLAG_READ_ONLY);\n\tctx->i2s_en = v4l2_ctrl_new_custom(hdl, &max2175_i2s_en, NULL);\n\tctx->hsls = v4l2_ctrl_new_custom(hdl, &max2175_hsls, NULL);\n\n\tif (ctx->xtal_freq == MAX2175_EU_XTAL_FREQ) {\n\t\tctx->rx_mode = v4l2_ctrl_new_custom(hdl,\n\t\t\t\t\t\t    &max2175_eu_rx_mode, NULL);\n\t\tctx->rx_modes = eu_rx_modes;\n\t\tctx->bands_rf = &eu_bands_rf;\n\t} else {\n\t\tctx->rx_mode = v4l2_ctrl_new_custom(hdl,\n\t\t\t\t\t\t    &max2175_na_rx_mode, NULL);\n\t\tctx->rx_modes = na_rx_modes;\n\t\tctx->bands_rf = &na_bands_rf;\n\t}\n\tctx->sd.ctrl_handler = &ctx->ctrl_hdl;\n\n\t \n\tctx->freq = ctx->bands_rf->rangelow;\n\n\t \n\tret = v4l2_async_register_subdev(sd);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"register subdev failed\\n\");\n\t\tgoto err_reg;\n\t}\n\n\t \n\tret = max2175_core_init(ctx, refout_bits);\n\tif (ret)\n\t\tgoto err_init;\n\n\tret = v4l2_ctrl_handler_setup(hdl);\n\tif (ret)\n\t\tgoto err_init;\n\n\treturn 0;\n\nerr_init:\n\tv4l2_async_unregister_subdev(sd);\nerr_reg:\n\tv4l2_ctrl_handler_free(&ctx->ctrl_hdl);\n\n\treturn ret;\n}\n\nstatic void max2175_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct max2175 *ctx = max2175_from_sd(sd);\n\n\tv4l2_ctrl_handler_free(&ctx->ctrl_hdl);\n\tv4l2_async_unregister_subdev(sd);\n}\n\nstatic const struct i2c_device_id max2175_id[] = {\n\t{ DRIVER_NAME, 0},\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, max2175_id);\n\nstatic const struct of_device_id max2175_of_ids[] = {\n\t{ .compatible = \"maxim,max2175\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max2175_of_ids);\n\nstatic struct i2c_driver max2175_driver = {\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table = max2175_of_ids,\n\t},\n\t.probe\t\t= max2175_probe,\n\t.remove\t\t= max2175_remove,\n\t.id_table\t= max2175_id,\n};\n\nmodule_i2c_driver(max2175_driver);\n\nMODULE_DESCRIPTION(\"Maxim MAX2175 RF to Bits tuner driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Ramesh Shanmugasundaram <ramesh.shanmugasundaram@bp.renesas.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}