{
  "module_name": "ak881x.c",
  "hash_id": "6dfa403edb152bcfe263604ee4dfd777c0368078b7e52f234d5be9af38b02e1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ak881x.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <linux/module.h>\n\n#include <media/i2c/ak881x.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-device.h>\n\n#define AK881X_INTERFACE_MODE\t0\n#define AK881X_VIDEO_PROCESS1\t1\n#define AK881X_VIDEO_PROCESS2\t2\n#define AK881X_VIDEO_PROCESS3\t3\n#define AK881X_DAC_MODE\t\t5\n#define AK881X_STATUS\t\t0x24\n#define AK881X_DEVICE_ID\t0x25\n#define AK881X_DEVICE_REVISION\t0x26\n\nstruct ak881x {\n\tstruct v4l2_subdev subdev;\n\tstruct ak881x_pdata *pdata;\n\tunsigned int lines;\n\tchar revision;\t \n};\n\nstatic int reg_read(struct i2c_client *client, const u8 reg)\n{\n\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\nstatic int reg_write(struct i2c_client *client, const u8 reg,\n\t\t     const u8 data)\n{\n\treturn i2c_smbus_write_byte_data(client, reg, data);\n}\n\nstatic int reg_set(struct i2c_client *client, const u8 reg,\n\t\t   const u8 data, u8 mask)\n{\n\tint ret = reg_read(client, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn reg_write(client, reg, (ret & ~mask) | (data & mask));\n}\n\nstatic struct ak881x *to_ak881x(const struct i2c_client *client)\n{\n\treturn container_of(i2c_get_clientdata(client), struct ak881x, subdev);\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int ak881x_g_register(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_dbg_register *reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tif (reg->reg > 0x26)\n\t\treturn -EINVAL;\n\n\treg->size = 1;\n\treg->val = reg_read(client, reg->reg);\n\n\tif (reg->val > 0xffff)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int ak881x_s_register(struct v4l2_subdev *sd,\n\t\t\t     const struct v4l2_dbg_register *reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tif (reg->reg > 0x26)\n\t\treturn -EINVAL;\n\n\tif (reg_write(client, reg->reg, reg->val) < 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n#endif\n\nstatic int ak881x_fill_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ak881x *ak881x = to_ak881x(client);\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tv4l_bound_align_image(&mf->width, 0, 720, 2,\n\t\t\t      &mf->height, 0, ak881x->lines, 1, 0);\n\tmf->field\t= V4L2_FIELD_INTERLACED;\n\tmf->code\t= MEDIA_BUS_FMT_YUYV8_2X8;\n\tmf->colorspace\t= V4L2_COLORSPACE_SMPTE170M;\n\n\treturn 0;\n}\n\nstatic int ak881x_enum_mbus_code(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_YUYV8_2X8;\n\treturn 0;\n}\n\nstatic int ak881x_get_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ak881x *ak881x = to_ak881x(client);\n\n\tif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = 720;\n\t\tsel->r.height = ak881x->lines;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ak881x_s_std_output(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ak881x *ak881x = to_ak881x(client);\n\tu8 vp1;\n\n\tif (std == V4L2_STD_NTSC_443) {\n\t\tvp1 = 3;\n\t\tak881x->lines = 480;\n\t} else if (std == V4L2_STD_PAL_M) {\n\t\tvp1 = 5;\n\t\tak881x->lines = 480;\n\t} else if (std == V4L2_STD_PAL_60) {\n\t\tvp1 = 7;\n\t\tak881x->lines = 480;\n\t} else if (std & V4L2_STD_NTSC) {\n\t\tvp1 = 0;\n\t\tak881x->lines = 480;\n\t} else if (std & V4L2_STD_PAL) {\n\t\tvp1 = 0xf;\n\t\tak881x->lines = 576;\n\t} else {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\treg_set(client, AK881X_VIDEO_PROCESS1, vp1, 0xf);\n\n\treturn 0;\n}\n\nstatic int ak881x_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ak881x *ak881x = to_ak881x(client);\n\n\tif (enable) {\n\t\tu8 dac;\n\t\t \n\t\t \n\t\tif (ak881x->pdata->flags & AK881X_COMPONENT)\n\t\t\tdac = 3;\n\t\telse\n\t\t\tdac = 4;\n\t\t \n\t\treg_write(client, AK881X_DAC_MODE, dac);\n\t\tdev_dbg(&client->dev, \"chip status 0x%x\\n\",\n\t\t\treg_read(client, AK881X_STATUS));\n\t} else {\n\t\t \n\t\treg_write(client, AK881X_DAC_MODE, 0);\n\t\tdev_dbg(&client->dev, \"chip status 0x%x\\n\",\n\t\t\treg_read(client, AK881X_STATUS));\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops ak881x_subdev_core_ops = {\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register\t= ak881x_g_register,\n\t.s_register\t= ak881x_s_register,\n#endif\n};\n\nstatic const struct v4l2_subdev_video_ops ak881x_subdev_video_ops = {\n\t.s_std_output\t= ak881x_s_std_output,\n\t.s_stream\t= ak881x_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops ak881x_subdev_pad_ops = {\n\t.enum_mbus_code = ak881x_enum_mbus_code,\n\t.get_selection\t= ak881x_get_selection,\n\t.set_fmt\t= ak881x_fill_fmt,\n\t.get_fmt\t= ak881x_fill_fmt,\n};\n\nstatic const struct v4l2_subdev_ops ak881x_subdev_ops = {\n\t.core\t= &ak881x_subdev_core_ops,\n\t.video\t= &ak881x_subdev_video_ops,\n\t.pad\t= &ak881x_subdev_pad_ops,\n};\n\nstatic int ak881x_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct ak881x *ak881x;\n\tu8 ifmode, data;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_warn(&adapter->dev,\n\t\t\t \"I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\\n\");\n\t\treturn -EIO;\n\t}\n\n\tak881x = devm_kzalloc(&client->dev, sizeof(*ak881x), GFP_KERNEL);\n\tif (!ak881x)\n\t\treturn -ENOMEM;\n\n\tv4l2_i2c_subdev_init(&ak881x->subdev, client, &ak881x_subdev_ops);\n\n\tdata = reg_read(client, AK881X_DEVICE_ID);\n\n\tswitch (data) {\n\tcase 0x13:\n\tcase 0x14:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev,\n\t\t\t\"No ak881x chip detected, register read %x\\n\", data);\n\t\treturn -ENODEV;\n\t}\n\n\tak881x->revision = reg_read(client, AK881X_DEVICE_REVISION);\n\tak881x->pdata = client->dev.platform_data;\n\n\tif (ak881x->pdata) {\n\t\tif (ak881x->pdata->flags & AK881X_FIELD)\n\t\t\tifmode = 4;\n\t\telse\n\t\t\tifmode = 0;\n\n\t\tswitch (ak881x->pdata->flags & AK881X_IF_MODE_MASK) {\n\t\tcase AK881X_IF_MODE_BT656:\n\t\t\tifmode |= 1;\n\t\t\tbreak;\n\t\tcase AK881X_IF_MODE_MASTER:\n\t\t\tifmode |= 2;\n\t\t\tbreak;\n\t\tcase AK881X_IF_MODE_SLAVE:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(&client->dev, \"IF mode %x\\n\", ifmode);\n\n\t\t \n\t\treg_write(client, AK881X_INTERFACE_MODE, ifmode | (20 << 3));\n\t}\n\n\t \n\tak881x->lines = 480;\n\n\tdev_info(&client->dev, \"Detected an ak881x chip ID %x, revision %x\\n\",\n\t\t data, ak881x->revision);\n\n\treturn 0;\n}\n\nstatic void ak881x_remove(struct i2c_client *client)\n{\n\tstruct ak881x *ak881x = to_ak881x(client);\n\n\tv4l2_device_unregister_subdev(&ak881x->subdev);\n}\n\nstatic const struct i2c_device_id ak881x_id[] = {\n\t{ \"ak8813\", 0 },\n\t{ \"ak8814\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ak881x_id);\n\nstatic struct i2c_driver ak881x_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ak881x\",\n\t},\n\t.probe\t\t= ak881x_probe,\n\t.remove\t\t= ak881x_remove,\n\t.id_table\t= ak881x_id,\n};\n\nmodule_i2c_driver(ak881x_i2c_driver);\n\nMODULE_DESCRIPTION(\"TV-output driver for ak8813/ak8814\");\nMODULE_AUTHOR(\"Guennadi Liakhovetski <g.liakhovetski@gmx.de>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}