{
  "module_name": "st-mipid02.c",
  "hash_id": "624e85dbc72e0cfd7a7cc8772a9aca72888d02cc4de7941a59aab9fff79b0728",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/st-mipid02.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/regulator/consumer.h>\n#include <media/v4l2-async.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n#define MIPID02_CLK_LANE_WR_REG1\t\t\t0x01\n#define MIPID02_CLK_LANE_REG1\t\t\t\t0x02\n#define MIPID02_CLK_LANE_REG3\t\t\t\t0x04\n#define MIPID02_DATA_LANE0_REG1\t\t\t\t0x05\n#define MIPID02_DATA_LANE0_REG2\t\t\t\t0x06\n#define MIPID02_DATA_LANE1_REG1\t\t\t\t0x09\n#define MIPID02_DATA_LANE1_REG2\t\t\t\t0x0a\n#define MIPID02_MODE_REG1\t\t\t\t0x14\n#define MIPID02_MODE_REG2\t\t\t\t0x15\n#define MIPID02_DATA_ID_RREG\t\t\t\t0x17\n#define MIPID02_DATA_SELECTION_CTRL\t\t\t0x19\n#define MIPID02_PIX_WIDTH_CTRL\t\t\t\t0x1e\n#define MIPID02_PIX_WIDTH_CTRL_EMB\t\t\t0x1f\n\n \n#define CLK_ENABLE\t\t\t\t\tBIT(0)\n \n#define CLK_MIPI_CSI\t\t\t\t\tBIT(1)\n \n#define DATA_ENABLE\t\t\t\t\tBIT(0)\n \n#define DATA_MIPI_CSI\t\t\t\t\tBIT(0)\n \n#define MODE_DATA_SWAP\t\t\t\t\tBIT(2)\n#define MODE_NO_BYPASS\t\t\t\t\tBIT(6)\n \n#define MODE_HSYNC_ACTIVE_HIGH\t\t\t\tBIT(1)\n#define MODE_VSYNC_ACTIVE_HIGH\t\t\t\tBIT(2)\n#define MODE_PCLK_SAMPLE_RISING\t\t\t\tBIT(3)\n \n#define SELECTION_MANUAL_DATA\t\t\t\tBIT(2)\n#define SELECTION_MANUAL_WIDTH\t\t\t\tBIT(3)\n\nstatic const u32 mipid02_supported_fmt_codes[] = {\n\tMEDIA_BUS_FMT_SBGGR8_1X8, MEDIA_BUS_FMT_SGBRG8_1X8,\n\tMEDIA_BUS_FMT_SGRBG8_1X8, MEDIA_BUS_FMT_SRGGB8_1X8,\n\tMEDIA_BUS_FMT_SBGGR10_1X10, MEDIA_BUS_FMT_SGBRG10_1X10,\n\tMEDIA_BUS_FMT_SGRBG10_1X10, MEDIA_BUS_FMT_SRGGB10_1X10,\n\tMEDIA_BUS_FMT_SBGGR12_1X12, MEDIA_BUS_FMT_SGBRG12_1X12,\n\tMEDIA_BUS_FMT_SGRBG12_1X12, MEDIA_BUS_FMT_SRGGB12_1X12,\n\tMEDIA_BUS_FMT_YUYV8_1X16, MEDIA_BUS_FMT_YVYU8_1X16,\n\tMEDIA_BUS_FMT_UYVY8_1X16, MEDIA_BUS_FMT_VYUY8_1X16,\n\tMEDIA_BUS_FMT_RGB565_1X16, MEDIA_BUS_FMT_BGR888_1X24,\n\tMEDIA_BUS_FMT_RGB565_2X8_LE, MEDIA_BUS_FMT_RGB565_2X8_BE,\n\tMEDIA_BUS_FMT_YUYV8_2X8, MEDIA_BUS_FMT_YVYU8_2X8,\n\tMEDIA_BUS_FMT_UYVY8_2X8, MEDIA_BUS_FMT_VYUY8_2X8,\n\tMEDIA_BUS_FMT_JPEG_1X8\n};\n\n \nstatic const char * const mipid02_supply_name[] = {\n\t\"VDDE\",  \n\t\"VDDIN\",  \n};\n\n#define MIPID02_NUM_SUPPLIES\t\tARRAY_SIZE(mipid02_supply_name)\n\n#define MIPID02_SINK_0\t\t\t0\n#define MIPID02_SINK_1\t\t\t1\n#define MIPID02_SOURCE\t\t\t2\n#define MIPID02_PAD_NB\t\t\t3\n\nstruct mipid02_dev {\n\tstruct i2c_client *i2c_client;\n\tstruct regulator_bulk_data supplies[MIPID02_NUM_SUPPLIES];\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pad[MIPID02_PAD_NB];\n\tstruct clk *xclk;\n\tstruct gpio_desc *reset_gpio;\n\t \n\tstruct v4l2_fwnode_endpoint rx;\n\tu64 link_frequency;\n\tstruct v4l2_fwnode_endpoint tx;\n\t \n\tstruct v4l2_async_notifier notifier;\n\tstruct v4l2_subdev *s_subdev;\n\t \n\tstruct {\n\t\tu8 clk_lane_reg1;\n\t\tu8 data_lane0_reg1;\n\t\tu8 data_lane1_reg1;\n\t\tu8 mode_reg1;\n\t\tu8 mode_reg2;\n\t\tu8 data_selection_ctrl;\n\t\tu8 data_id_rreg;\n\t\tu8 pix_width_ctrl;\n\t\tu8 pix_width_ctrl_emb;\n\t} r;\n\t \n\tstruct mutex lock;\n\tbool streaming;\n\tstruct v4l2_mbus_framefmt fmt;\n};\n\nstatic int bpp_from_code(__u32 code)\n{\n\tswitch (code) {\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\tcase MEDIA_BUS_FMT_SGBRG8_1X8:\n\tcase MEDIA_BUS_FMT_SGRBG8_1X8:\n\tcase MEDIA_BUS_FMT_SRGGB8_1X8:\n\t\treturn 8;\n\tcase MEDIA_BUS_FMT_SBGGR10_1X10:\n\tcase MEDIA_BUS_FMT_SGBRG10_1X10:\n\tcase MEDIA_BUS_FMT_SGRBG10_1X10:\n\tcase MEDIA_BUS_FMT_SRGGB10_1X10:\n\t\treturn 10;\n\tcase MEDIA_BUS_FMT_SBGGR12_1X12:\n\tcase MEDIA_BUS_FMT_SGBRG12_1X12:\n\tcase MEDIA_BUS_FMT_SGRBG12_1X12:\n\tcase MEDIA_BUS_FMT_SRGGB12_1X12:\n\t\treturn 12;\n\tcase MEDIA_BUS_FMT_YUYV8_1X16:\n\tcase MEDIA_BUS_FMT_YVYU8_1X16:\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\tcase MEDIA_BUS_FMT_VYUY8_1X16:\n\tcase MEDIA_BUS_FMT_RGB565_1X16:\n\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\tcase MEDIA_BUS_FMT_YVYU8_2X8:\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\tcase MEDIA_BUS_FMT_VYUY8_2X8:\n\tcase MEDIA_BUS_FMT_RGB565_2X8_LE:\n\tcase MEDIA_BUS_FMT_RGB565_2X8_BE:\n\t\treturn 16;\n\tcase MEDIA_BUS_FMT_BGR888_1X24:\n\t\treturn 24;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic u8 data_type_from_code(__u32 code)\n{\n\tswitch (code) {\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\tcase MEDIA_BUS_FMT_SGBRG8_1X8:\n\tcase MEDIA_BUS_FMT_SGRBG8_1X8:\n\tcase MEDIA_BUS_FMT_SRGGB8_1X8:\n\t\treturn 0x2a;\n\tcase MEDIA_BUS_FMT_SBGGR10_1X10:\n\tcase MEDIA_BUS_FMT_SGBRG10_1X10:\n\tcase MEDIA_BUS_FMT_SGRBG10_1X10:\n\tcase MEDIA_BUS_FMT_SRGGB10_1X10:\n\t\treturn 0x2b;\n\tcase MEDIA_BUS_FMT_SBGGR12_1X12:\n\tcase MEDIA_BUS_FMT_SGBRG12_1X12:\n\tcase MEDIA_BUS_FMT_SGRBG12_1X12:\n\tcase MEDIA_BUS_FMT_SRGGB12_1X12:\n\t\treturn 0x2c;\n\tcase MEDIA_BUS_FMT_YUYV8_1X16:\n\tcase MEDIA_BUS_FMT_YVYU8_1X16:\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\tcase MEDIA_BUS_FMT_VYUY8_1X16:\n\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\tcase MEDIA_BUS_FMT_YVYU8_2X8:\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\tcase MEDIA_BUS_FMT_VYUY8_2X8:\n\t\treturn 0x1e;\n\tcase MEDIA_BUS_FMT_BGR888_1X24:\n\t\treturn 0x24;\n\tcase MEDIA_BUS_FMT_RGB565_1X16:\n\tcase MEDIA_BUS_FMT_RGB565_2X8_LE:\n\tcase MEDIA_BUS_FMT_RGB565_2X8_BE:\n\t\treturn 0x22;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void init_format(struct v4l2_mbus_framefmt *fmt)\n{\n\tfmt->code = MEDIA_BUS_FMT_SBGGR8_1X8;\n\tfmt->field = V4L2_FIELD_NONE;\n\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n\tfmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(V4L2_COLORSPACE_SRGB);\n\tfmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\tfmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(V4L2_COLORSPACE_SRGB);\n\tfmt->width = 640;\n\tfmt->height = 480;\n}\n\nstatic __u32 get_fmt_code(__u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mipid02_supported_fmt_codes); i++) {\n\t\tif (code == mipid02_supported_fmt_codes[i])\n\t\t\treturn code;\n\t}\n\n\treturn mipid02_supported_fmt_codes[0];\n}\n\nstatic __u32 serial_to_parallel_code(__u32 serial)\n{\n\tif (serial == MEDIA_BUS_FMT_RGB565_1X16)\n\t\treturn MEDIA_BUS_FMT_RGB565_2X8_LE;\n\tif (serial == MEDIA_BUS_FMT_YUYV8_1X16)\n\t\treturn MEDIA_BUS_FMT_YUYV8_2X8;\n\tif (serial == MEDIA_BUS_FMT_YVYU8_1X16)\n\t\treturn MEDIA_BUS_FMT_YVYU8_2X8;\n\tif (serial == MEDIA_BUS_FMT_UYVY8_1X16)\n\t\treturn MEDIA_BUS_FMT_UYVY8_2X8;\n\tif (serial == MEDIA_BUS_FMT_VYUY8_1X16)\n\t\treturn MEDIA_BUS_FMT_VYUY8_2X8;\n\tif (serial == MEDIA_BUS_FMT_BGR888_1X24)\n\t\treturn MEDIA_BUS_FMT_BGR888_3X8;\n\n\treturn serial;\n}\n\nstatic inline struct mipid02_dev *to_mipid02_dev(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct mipid02_dev, sd);\n}\n\nstatic int mipid02_read_reg(struct mipid02_dev *bridge, u16 reg, u8 *val)\n{\n\tstruct i2c_client *client = bridge->i2c_client;\n\tstruct i2c_msg msg[2];\n\tu8 buf[2];\n\tint ret;\n\n\tbuf[0] = reg >> 8;\n\tbuf[1] = reg & 0xff;\n\n\tmsg[0].addr = client->addr;\n\tmsg[0].flags = client->flags;\n\tmsg[0].buf = buf;\n\tmsg[0].len = sizeof(buf);\n\n\tmsg[1].addr = client->addr;\n\tmsg[1].flags = client->flags | I2C_M_RD;\n\tmsg[1].buf = val;\n\tmsg[1].len = 1;\n\n\tret = i2c_transfer(client->adapter, msg, 2);\n\tif (ret < 0) {\n\t\tdev_dbg(&client->dev, \"%s: %x i2c_transfer, reg: %x => %d\\n\",\n\t\t\t    __func__, client->addr, reg, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mipid02_write_reg(struct mipid02_dev *bridge, u16 reg, u8 val)\n{\n\tstruct i2c_client *client = bridge->i2c_client;\n\tstruct i2c_msg msg;\n\tu8 buf[3];\n\tint ret;\n\n\tbuf[0] = reg >> 8;\n\tbuf[1] = reg & 0xff;\n\tbuf[2] = val;\n\n\tmsg.addr = client->addr;\n\tmsg.flags = client->flags;\n\tmsg.buf = buf;\n\tmsg.len = sizeof(buf);\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret < 0) {\n\t\tdev_dbg(&client->dev, \"%s: i2c_transfer, reg: %x => %d\\n\",\n\t\t\t    __func__, reg, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mipid02_get_regulators(struct mipid02_dev *bridge)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < MIPID02_NUM_SUPPLIES; i++)\n\t\tbridge->supplies[i].supply = mipid02_supply_name[i];\n\n\treturn devm_regulator_bulk_get(&bridge->i2c_client->dev,\n\t\t\t\t       MIPID02_NUM_SUPPLIES,\n\t\t\t\t       bridge->supplies);\n}\n\nstatic void mipid02_apply_reset(struct mipid02_dev *bridge)\n{\n\tgpiod_set_value_cansleep(bridge->reset_gpio, 0);\n\tusleep_range(5000, 10000);\n\tgpiod_set_value_cansleep(bridge->reset_gpio, 1);\n\tusleep_range(5000, 10000);\n\tgpiod_set_value_cansleep(bridge->reset_gpio, 0);\n\tusleep_range(5000, 10000);\n}\n\nstatic int mipid02_set_power_on(struct mipid02_dev *bridge)\n{\n\tstruct i2c_client *client = bridge->i2c_client;\n\tint ret;\n\n\tret = clk_prepare_enable(bridge->xclk);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s: failed to enable clock\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(MIPID02_NUM_SUPPLIES,\n\t\t\t\t    bridge->supplies);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s: failed to enable regulators\\n\",\n\t\t\t    __func__);\n\t\tgoto xclk_off;\n\t}\n\n\tif (bridge->reset_gpio) {\n\t\tdev_dbg(&client->dev, \"apply reset\");\n\t\tmipid02_apply_reset(bridge);\n\t} else {\n\t\tdev_dbg(&client->dev, \"don't apply reset\");\n\t\tusleep_range(5000, 10000);\n\t}\n\n\treturn 0;\n\nxclk_off:\n\tclk_disable_unprepare(bridge->xclk);\n\treturn ret;\n}\n\nstatic void mipid02_set_power_off(struct mipid02_dev *bridge)\n{\n\tregulator_bulk_disable(MIPID02_NUM_SUPPLIES, bridge->supplies);\n\tclk_disable_unprepare(bridge->xclk);\n}\n\nstatic int mipid02_detect(struct mipid02_dev *bridge)\n{\n\tu8 reg;\n\n\t \n\treturn mipid02_read_reg(bridge, MIPID02_CLK_LANE_WR_REG1, &reg);\n}\n\nstatic u32 mipid02_get_link_freq_from_cid_link_freq(struct mipid02_dev *bridge,\n\t\t\t\t\t\t    struct v4l2_subdev *subdev)\n{\n\tstruct v4l2_querymenu qm = {.id = V4L2_CID_LINK_FREQ, };\n\tstruct v4l2_ctrl *ctrl;\n\tint ret;\n\n\tctrl = v4l2_ctrl_find(subdev->ctrl_handler, V4L2_CID_LINK_FREQ);\n\tif (!ctrl)\n\t\treturn 0;\n\tqm.index = v4l2_ctrl_g_ctrl(ctrl);\n\n\tret = v4l2_querymenu(subdev->ctrl_handler, &qm);\n\tif (ret)\n\t\treturn 0;\n\n\treturn qm.value;\n}\n\nstatic u32 mipid02_get_link_freq_from_cid_pixel_rate(struct mipid02_dev *bridge,\n\t\t\t\t\t\t     struct v4l2_subdev *subdev)\n{\n\tstruct v4l2_fwnode_endpoint *ep = &bridge->rx;\n\tstruct v4l2_ctrl *ctrl;\n\tu32 pixel_clock;\n\tu32 bpp = bpp_from_code(bridge->fmt.code);\n\n\tctrl = v4l2_ctrl_find(subdev->ctrl_handler, V4L2_CID_PIXEL_RATE);\n\tif (!ctrl)\n\t\treturn 0;\n\tpixel_clock = v4l2_ctrl_g_ctrl_int64(ctrl);\n\n\treturn pixel_clock * bpp / (2 * ep->bus.mipi_csi2.num_data_lanes);\n}\n\n \nstatic int mipid02_configure_from_rx_speed(struct mipid02_dev *bridge)\n{\n\tstruct i2c_client *client = bridge->i2c_client;\n\tstruct v4l2_subdev *subdev = bridge->s_subdev;\n\tu32 link_freq;\n\n\tlink_freq = mipid02_get_link_freq_from_cid_link_freq(bridge, subdev);\n\tif (!link_freq) {\n\t\tlink_freq = mipid02_get_link_freq_from_cid_pixel_rate(bridge,\n\t\t\t\t\t\t\t\t      subdev);\n\t\tif (!link_freq) {\n\t\t\tdev_err(&client->dev, \"Failed to get link frequency\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tdev_dbg(&client->dev, \"detect link_freq = %d Hz\", link_freq);\n\tbridge->r.clk_lane_reg1 |= (2000000000 / link_freq) << 2;\n\n\treturn 0;\n}\n\nstatic int mipid02_configure_clk_lane(struct mipid02_dev *bridge)\n{\n\tstruct i2c_client *client = bridge->i2c_client;\n\tstruct v4l2_fwnode_endpoint *ep = &bridge->rx;\n\tbool *polarities = ep->bus.mipi_csi2.lane_polarities;\n\n\t \n\tif (ep->bus.mipi_csi2.clock_lane != 0) {\n\t\tdev_err(&client->dev, \"clk lane must be map to lane 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\tbridge->r.clk_lane_reg1 |= (polarities[0] << 1) | CLK_ENABLE;\n\n\treturn 0;\n}\n\nstatic int mipid02_configure_data0_lane(struct mipid02_dev *bridge, int nb,\n\t\t\t\t\tbool are_lanes_swap, bool *polarities)\n{\n\tbool are_pin_swap = are_lanes_swap ? polarities[2] : polarities[1];\n\n\tif (nb == 1 && are_lanes_swap)\n\t\treturn 0;\n\n\t \n\tif (!are_pin_swap)\n\t\tbridge->r.data_lane0_reg1 = 1 << 1;\n\tbridge->r.data_lane0_reg1 |= DATA_ENABLE;\n\n\treturn 0;\n}\n\nstatic int mipid02_configure_data1_lane(struct mipid02_dev *bridge, int nb,\n\t\t\t\t\tbool are_lanes_swap, bool *polarities)\n{\n\tbool are_pin_swap = are_lanes_swap ? polarities[1] : polarities[2];\n\n\tif (nb == 1 && !are_lanes_swap)\n\t\treturn 0;\n\n\tif (are_pin_swap)\n\t\tbridge->r.data_lane1_reg1 = 1 << 1;\n\tbridge->r.data_lane1_reg1 |= DATA_ENABLE;\n\n\treturn 0;\n}\n\nstatic int mipid02_configure_from_rx(struct mipid02_dev *bridge)\n{\n\tstruct v4l2_fwnode_endpoint *ep = &bridge->rx;\n\tbool are_lanes_swap = ep->bus.mipi_csi2.data_lanes[0] == 2;\n\tbool *polarities = ep->bus.mipi_csi2.lane_polarities;\n\tint nb = ep->bus.mipi_csi2.num_data_lanes;\n\tint ret;\n\n\tret = mipid02_configure_clk_lane(bridge);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mipid02_configure_data0_lane(bridge, nb, are_lanes_swap,\n\t\t\t\t\t   polarities);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mipid02_configure_data1_lane(bridge, nb, are_lanes_swap,\n\t\t\t\t\t   polarities);\n\tif (ret)\n\t\treturn ret;\n\n\tbridge->r.mode_reg1 |= are_lanes_swap ? MODE_DATA_SWAP : 0;\n\tbridge->r.mode_reg1 |= (nb - 1) << 1;\n\n\treturn mipid02_configure_from_rx_speed(bridge);\n}\n\nstatic int mipid02_configure_from_tx(struct mipid02_dev *bridge)\n{\n\tstruct v4l2_fwnode_endpoint *ep = &bridge->tx;\n\n\tbridge->r.data_selection_ctrl = SELECTION_MANUAL_WIDTH;\n\tbridge->r.pix_width_ctrl = ep->bus.parallel.bus_width;\n\tbridge->r.pix_width_ctrl_emb = ep->bus.parallel.bus_width;\n\tif (ep->bus.parallel.flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)\n\t\tbridge->r.mode_reg2 |= MODE_HSYNC_ACTIVE_HIGH;\n\tif (ep->bus.parallel.flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)\n\t\tbridge->r.mode_reg2 |= MODE_VSYNC_ACTIVE_HIGH;\n\tif (ep->bus.parallel.flags & V4L2_MBUS_PCLK_SAMPLE_RISING)\n\t\tbridge->r.mode_reg2 |= MODE_PCLK_SAMPLE_RISING;\n\n\treturn 0;\n}\n\nstatic int mipid02_configure_from_code(struct mipid02_dev *bridge)\n{\n\tu8 data_type;\n\n\tbridge->r.data_id_rreg = 0;\n\n\tif (bridge->fmt.code != MEDIA_BUS_FMT_JPEG_1X8) {\n\t\tbridge->r.data_selection_ctrl |= SELECTION_MANUAL_DATA;\n\n\t\tdata_type = data_type_from_code(bridge->fmt.code);\n\t\tif (!data_type)\n\t\t\treturn -EINVAL;\n\t\tbridge->r.data_id_rreg = data_type;\n\t}\n\n\treturn 0;\n}\n\nstatic int mipid02_stream_disable(struct mipid02_dev *bridge)\n{\n\tstruct i2c_client *client = bridge->i2c_client;\n\tint ret = -EINVAL;\n\n\tif (!bridge->s_subdev)\n\t\tgoto error;\n\n\tret = v4l2_subdev_call(bridge->s_subdev, video, s_stream, 0);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tret = mipid02_write_reg(bridge, MIPID02_CLK_LANE_REG1, 0);\n\tif (ret)\n\t\tgoto error;\n\tret = mipid02_write_reg(bridge, MIPID02_DATA_LANE0_REG1, 0);\n\tif (ret)\n\t\tgoto error;\n\tret = mipid02_write_reg(bridge, MIPID02_DATA_LANE1_REG1, 0);\n\tif (ret)\n\t\tgoto error;\nerror:\n\tif (ret)\n\t\tdev_err(&client->dev, \"failed to stream off %d\", ret);\n\n\treturn ret;\n}\n\nstatic int mipid02_stream_enable(struct mipid02_dev *bridge)\n{\n\tstruct i2c_client *client = bridge->i2c_client;\n\tint ret = -EINVAL;\n\n\tif (!bridge->s_subdev)\n\t\tgoto error;\n\n\tmemset(&bridge->r, 0, sizeof(bridge->r));\n\t \n\tret = mipid02_configure_from_rx(bridge);\n\tif (ret)\n\t\tgoto error;\n\tret = mipid02_configure_from_tx(bridge);\n\tif (ret)\n\t\tgoto error;\n\tret = mipid02_configure_from_code(bridge);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tret = mipid02_write_reg(bridge, MIPID02_CLK_LANE_REG1,\n\t\tbridge->r.clk_lane_reg1);\n\tif (ret)\n\t\tgoto error;\n\tret = mipid02_write_reg(bridge, MIPID02_CLK_LANE_REG3, CLK_MIPI_CSI);\n\tif (ret)\n\t\tgoto error;\n\tret = mipid02_write_reg(bridge, MIPID02_DATA_LANE0_REG1,\n\t\tbridge->r.data_lane0_reg1);\n\tif (ret)\n\t\tgoto error;\n\tret = mipid02_write_reg(bridge, MIPID02_DATA_LANE0_REG2,\n\t\tDATA_MIPI_CSI);\n\tif (ret)\n\t\tgoto error;\n\tret = mipid02_write_reg(bridge, MIPID02_DATA_LANE1_REG1,\n\t\tbridge->r.data_lane1_reg1);\n\tif (ret)\n\t\tgoto error;\n\tret = mipid02_write_reg(bridge, MIPID02_DATA_LANE1_REG2,\n\t\tDATA_MIPI_CSI);\n\tif (ret)\n\t\tgoto error;\n\tret = mipid02_write_reg(bridge, MIPID02_MODE_REG1,\n\t\tMODE_NO_BYPASS | bridge->r.mode_reg1);\n\tif (ret)\n\t\tgoto error;\n\tret = mipid02_write_reg(bridge, MIPID02_MODE_REG2,\n\t\tbridge->r.mode_reg2);\n\tif (ret)\n\t\tgoto error;\n\tret = mipid02_write_reg(bridge, MIPID02_DATA_ID_RREG,\n\t\tbridge->r.data_id_rreg);\n\tif (ret)\n\t\tgoto error;\n\tret = mipid02_write_reg(bridge, MIPID02_DATA_SELECTION_CTRL,\n\t\tbridge->r.data_selection_ctrl);\n\tif (ret)\n\t\tgoto error;\n\tret = mipid02_write_reg(bridge, MIPID02_PIX_WIDTH_CTRL,\n\t\tbridge->r.pix_width_ctrl);\n\tif (ret)\n\t\tgoto error;\n\tret = mipid02_write_reg(bridge, MIPID02_PIX_WIDTH_CTRL_EMB,\n\t\tbridge->r.pix_width_ctrl_emb);\n\tif (ret)\n\t\tgoto error;\n\n\tret = v4l2_subdev_call(bridge->s_subdev, video, s_stream, 1);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tdev_err(&client->dev, \"failed to stream on %d\", ret);\n\tmipid02_stream_disable(bridge);\n\n\treturn ret;\n}\n\nstatic int mipid02_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct mipid02_dev *bridge = to_mipid02_dev(sd);\n\tstruct i2c_client *client = bridge->i2c_client;\n\tint ret = 0;\n\n\tdev_dbg(&client->dev, \"%s : requested %d / current = %d\", __func__,\n\t\t    enable, bridge->streaming);\n\tmutex_lock(&bridge->lock);\n\n\tif (bridge->streaming == enable)\n\t\tgoto out;\n\n\tret = enable ? mipid02_stream_enable(bridge) :\n\t\t       mipid02_stream_disable(bridge);\n\tif (!ret)\n\t\tbridge->streaming = enable;\n\nout:\n\tdev_dbg(&client->dev, \"%s current now = %d / %d\", __func__,\n\t\t    bridge->streaming, ret);\n\tmutex_unlock(&bridge->lock);\n\n\treturn ret;\n}\n\nstatic int mipid02_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct mipid02_dev *bridge = to_mipid02_dev(sd);\n\tint ret = 0;\n\n\tswitch (code->pad) {\n\tcase MIPID02_SINK_0:\n\t\tif (code->index >= ARRAY_SIZE(mipid02_supported_fmt_codes))\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tcode->code = mipid02_supported_fmt_codes[code->index];\n\t\tbreak;\n\tcase MIPID02_SOURCE:\n\t\tif (code->index == 0)\n\t\t\tcode->code = serial_to_parallel_code(bridge->fmt.code);\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int mipid02_get_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mbus_fmt = &format->format;\n\tstruct mipid02_dev *bridge = to_mipid02_dev(sd);\n\tstruct i2c_client *client = bridge->i2c_client;\n\tstruct v4l2_mbus_framefmt *fmt;\n\n\tdev_dbg(&client->dev, \"%s probe %d\", __func__, format->pad);\n\n\tif (format->pad >= MIPID02_PAD_NB)\n\t\treturn -EINVAL;\n\t \n\tif (format->pad == MIPID02_SINK_1)\n\t\treturn -EINVAL;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\tfmt = v4l2_subdev_get_try_format(&bridge->sd, sd_state,\n\t\t\t\t\t\t format->pad);\n\telse\n\t\tfmt = &bridge->fmt;\n\n\tmutex_lock(&bridge->lock);\n\n\t*mbus_fmt = *fmt;\n\t \n\tif (format->pad == MIPID02_SOURCE)\n\t\tmbus_fmt->code = serial_to_parallel_code(mbus_fmt->code);\n\n\tmutex_unlock(&bridge->lock);\n\n\treturn 0;\n}\n\nstatic void mipid02_set_fmt_source(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_format *format)\n{\n\tstruct mipid02_dev *bridge = to_mipid02_dev(sd);\n\n\t \n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\tformat->format = bridge->fmt;\n\telse\n\t\tformat->format = *v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t\t\t     MIPID02_SINK_0);\n\n\t \n\tformat->format.code = serial_to_parallel_code(format->format.code);\n\n\t \n\tif (format->which != V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn;\n\n\t*v4l2_subdev_get_try_format(sd, sd_state, MIPID02_SOURCE) =\n\t\tformat->format;\n}\n\nstatic void mipid02_set_fmt_sink(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_format *format)\n{\n\tstruct mipid02_dev *bridge = to_mipid02_dev(sd);\n\tstruct v4l2_mbus_framefmt *fmt;\n\n\tformat->format.code = get_fmt_code(format->format.code);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\tfmt = v4l2_subdev_get_try_format(sd, sd_state, format->pad);\n\telse\n\t\tfmt = &bridge->fmt;\n\n\t*fmt = format->format;\n\n\t \n\tmipid02_set_fmt_source(sd, sd_state, format);\n}\n\nstatic int mipid02_set_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *format)\n{\n\tstruct mipid02_dev *bridge = to_mipid02_dev(sd);\n\tstruct i2c_client *client = bridge->i2c_client;\n\tint ret = 0;\n\n\tdev_dbg(&client->dev, \"%s for %d\", __func__, format->pad);\n\n\tif (format->pad >= MIPID02_PAD_NB)\n\t\treturn -EINVAL;\n\t \n\tif (format->pad == MIPID02_SINK_1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&bridge->lock);\n\n\tif (bridge->streaming) {\n\t\tret = -EBUSY;\n\t\tgoto error;\n\t}\n\n\tif (format->pad == MIPID02_SOURCE)\n\t\tmipid02_set_fmt_source(sd, sd_state, format);\n\telse\n\t\tmipid02_set_fmt_sink(sd, sd_state, format);\n\nerror:\n\tmutex_unlock(&bridge->lock);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_video_ops mipid02_video_ops = {\n\t.s_stream = mipid02_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops mipid02_pad_ops = {\n\t.enum_mbus_code = mipid02_enum_mbus_code,\n\t.get_fmt = mipid02_get_fmt,\n\t.set_fmt = mipid02_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops mipid02_subdev_ops = {\n\t.video = &mipid02_video_ops,\n\t.pad = &mipid02_pad_ops,\n};\n\nstatic const struct media_entity_operations mipid02_subdev_entity_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic int mipid02_async_bound(struct v4l2_async_notifier *notifier,\n\t\t\t       struct v4l2_subdev *s_subdev,\n\t\t\t       struct v4l2_async_connection *asd)\n{\n\tstruct mipid02_dev *bridge = to_mipid02_dev(notifier->sd);\n\tstruct i2c_client *client = bridge->i2c_client;\n\tint source_pad;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"sensor_async_bound call %p\", s_subdev);\n\n\tsource_pad = media_entity_get_fwnode_pad(&s_subdev->entity,\n\t\t\t\t\t\t s_subdev->fwnode,\n\t\t\t\t\t\t MEDIA_PAD_FL_SOURCE);\n\tif (source_pad < 0) {\n\t\tdev_err(&client->dev, \"Couldn't find output pad for subdev %s\\n\",\n\t\t\ts_subdev->name);\n\t\treturn source_pad;\n\t}\n\n\tret = media_create_pad_link(&s_subdev->entity, source_pad,\n\t\t\t\t    &bridge->sd.entity, 0,\n\t\t\t\t    MEDIA_LNK_FL_ENABLED |\n\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Couldn't create media link %d\", ret);\n\t\treturn ret;\n\t}\n\n\tbridge->s_subdev = s_subdev;\n\n\treturn 0;\n}\n\nstatic void mipid02_async_unbind(struct v4l2_async_notifier *notifier,\n\t\t\t\t struct v4l2_subdev *s_subdev,\n\t\t\t\t struct v4l2_async_connection *asd)\n{\n\tstruct mipid02_dev *bridge = to_mipid02_dev(notifier->sd);\n\n\tbridge->s_subdev = NULL;\n}\n\nstatic const struct v4l2_async_notifier_operations mipid02_notifier_ops = {\n\t.bound\t\t= mipid02_async_bound,\n\t.unbind\t\t= mipid02_async_unbind,\n};\n\nstatic int mipid02_parse_rx_ep(struct mipid02_dev *bridge)\n{\n\tstruct v4l2_fwnode_endpoint ep = { .bus_type = V4L2_MBUS_CSI2_DPHY };\n\tstruct i2c_client *client = bridge->i2c_client;\n\tstruct v4l2_async_connection *asd;\n\tstruct device_node *ep_node;\n\tint ret;\n\n\t \n\tep_node = of_graph_get_endpoint_by_regs(bridge->i2c_client->dev.of_node,\n\t\t\t\t\t\t0, 0);\n\tif (!ep_node) {\n\t\tdev_err(&client->dev, \"unable to find port0 ep\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(ep_node), &ep);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Could not parse v4l2 endpoint %d\\n\",\n\t\t\tret);\n\t\tgoto error_of_node_put;\n\t}\n\n\t \n\tif (ep.bus.mipi_csi2.num_data_lanes > 2) {\n\t\tdev_err(&client->dev, \"max supported data lanes is 2 / got %d\",\n\t\t\tep.bus.mipi_csi2.num_data_lanes);\n\t\tret = -EINVAL;\n\t\tgoto error_of_node_put;\n\t}\n\n\t \n\tbridge->rx = ep;\n\n\t \n\tv4l2_async_subdev_nf_init(&bridge->notifier, &bridge->sd);\n\tasd = v4l2_async_nf_add_fwnode_remote(&bridge->notifier,\n\t\t\t\t\t      of_fwnode_handle(ep_node),\n\t\t\t\t\t      struct v4l2_async_connection);\n\tof_node_put(ep_node);\n\n\tif (IS_ERR(asd)) {\n\t\tdev_err(&client->dev, \"fail to register asd to notifier %ld\",\n\t\t\tPTR_ERR(asd));\n\t\treturn PTR_ERR(asd);\n\t}\n\tbridge->notifier.ops = &mipid02_notifier_ops;\n\n\tret = v4l2_async_nf_register(&bridge->notifier);\n\tif (ret)\n\t\tv4l2_async_nf_cleanup(&bridge->notifier);\n\n\treturn ret;\n\nerror_of_node_put:\n\tof_node_put(ep_node);\nerror:\n\n\treturn ret;\n}\n\nstatic int mipid02_parse_tx_ep(struct mipid02_dev *bridge)\n{\n\tstruct v4l2_fwnode_endpoint ep = { .bus_type = V4L2_MBUS_PARALLEL };\n\tstruct i2c_client *client = bridge->i2c_client;\n\tstruct device_node *ep_node;\n\tint ret;\n\n\t \n\tep_node = of_graph_get_endpoint_by_regs(bridge->i2c_client->dev.of_node,\n\t\t\t\t\t\t2, 0);\n\tif (!ep_node) {\n\t\tdev_err(&client->dev, \"unable to find port1 ep\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(ep_node), &ep);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Could not parse v4l2 endpoint\\n\");\n\t\tgoto error_of_node_put;\n\t}\n\n\tof_node_put(ep_node);\n\tbridge->tx = ep;\n\n\treturn 0;\n\nerror_of_node_put:\n\tof_node_put(ep_node);\nerror:\n\n\treturn -EINVAL;\n}\n\nstatic int mipid02_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct mipid02_dev *bridge;\n\tu32 clk_freq;\n\tint ret;\n\n\tbridge = devm_kzalloc(dev, sizeof(*bridge), GFP_KERNEL);\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tinit_format(&bridge->fmt);\n\n\tbridge->i2c_client = client;\n\tv4l2_i2c_subdev_init(&bridge->sd, client, &mipid02_subdev_ops);\n\n\t \n\tbridge->xclk = devm_clk_get(dev, \"xclk\");\n\tif (IS_ERR(bridge->xclk)) {\n\t\tdev_err(dev, \"failed to get xclk\\n\");\n\t\treturn PTR_ERR(bridge->xclk);\n\t}\n\n\tclk_freq = clk_get_rate(bridge->xclk);\n\tif (clk_freq < 6000000 || clk_freq > 27000000) {\n\t\tdev_err(dev, \"xclk freq must be in 6-27 Mhz range. got %d Hz\\n\",\n\t\t\tclk_freq);\n\t\treturn -EINVAL;\n\t}\n\n\tbridge->reset_gpio = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t     GPIOD_OUT_HIGH);\n\n\tif (IS_ERR(bridge->reset_gpio)) {\n\t\tdev_err(dev, \"failed to get reset GPIO\\n\");\n\t\treturn PTR_ERR(bridge->reset_gpio);\n\t}\n\n\tret = mipid02_get_regulators(bridge);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get regulators %d\", ret);\n\t\treturn ret;\n\t}\n\n\tmutex_init(&bridge->lock);\n\tbridge->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tbridge->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tbridge->sd.entity.ops = &mipid02_subdev_entity_ops;\n\tbridge->pad[0].flags = MEDIA_PAD_FL_SINK;\n\tbridge->pad[1].flags = MEDIA_PAD_FL_SINK;\n\tbridge->pad[2].flags = MEDIA_PAD_FL_SOURCE;\n\tret = media_entity_pads_init(&bridge->sd.entity, MIPID02_PAD_NB,\n\t\t\t\t     bridge->pad);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"pads init failed %d\", ret);\n\t\tgoto mutex_cleanup;\n\t}\n\n\t \n\tret = mipid02_set_power_on(bridge);\n\tif (ret)\n\t\tgoto entity_cleanup;\n\n\tret = mipid02_detect(bridge);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to detect mipid02 %d\", ret);\n\t\tgoto power_off;\n\t}\n\n\tret = mipid02_parse_tx_ep(bridge);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to parse tx %d\", ret);\n\t\tgoto power_off;\n\t}\n\n\tret = mipid02_parse_rx_ep(bridge);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to parse rx %d\", ret);\n\t\tgoto power_off;\n\t}\n\n\tret = v4l2_async_register_subdev(&bridge->sd);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"v4l2_async_register_subdev failed %d\",\n\t\t\t    ret);\n\t\tgoto unregister_notifier;\n\t}\n\n\tdev_info(&client->dev, \"mipid02 device probe successfully\");\n\n\treturn 0;\n\nunregister_notifier:\n\tv4l2_async_nf_unregister(&bridge->notifier);\n\tv4l2_async_nf_cleanup(&bridge->notifier);\npower_off:\n\tmipid02_set_power_off(bridge);\nentity_cleanup:\n\tmedia_entity_cleanup(&bridge->sd.entity);\nmutex_cleanup:\n\tmutex_destroy(&bridge->lock);\n\n\treturn ret;\n}\n\nstatic void mipid02_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct mipid02_dev *bridge = to_mipid02_dev(sd);\n\n\tv4l2_async_nf_unregister(&bridge->notifier);\n\tv4l2_async_nf_cleanup(&bridge->notifier);\n\tv4l2_async_unregister_subdev(&bridge->sd);\n\tmipid02_set_power_off(bridge);\n\tmedia_entity_cleanup(&bridge->sd.entity);\n\tmutex_destroy(&bridge->lock);\n}\n\nstatic const struct of_device_id mipid02_dt_ids[] = {\n\t{ .compatible = \"st,st-mipid02\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mipid02_dt_ids);\n\nstatic struct i2c_driver mipid02_i2c_driver = {\n\t.driver = {\n\t\t.name  = \"st-mipid02\",\n\t\t.of_match_table = mipid02_dt_ids,\n\t},\n\t.probe = mipid02_probe,\n\t.remove = mipid02_remove,\n};\n\nmodule_i2c_driver(mipid02_i2c_driver);\n\nMODULE_AUTHOR(\"Mickael Guene <mickael.guene@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics MIPID02 CSI-2 bridge driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}