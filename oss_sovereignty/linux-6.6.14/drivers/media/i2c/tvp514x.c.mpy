{
  "module_name": "tvp514x.c",
  "hash_id": "90d68c5d51c8454a7da67833a50fcb1c363d78662b9fe4c4de71c2970d16eb83",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/tvp514x.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/videodev2.h>\n#include <linux/module.h>\n#include <linux/v4l2-mediabus.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n\n#include <media/v4l2-async.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-mediabus.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-ctrls.h>\n#include <media/i2c/tvp514x.h>\n#include <media/media-entity.h>\n\n#include \"tvp514x_regs.h\"\n\n \n#define I2C_RETRY_COUNT                 (5)\n#define LOCK_RETRY_COUNT                (5)\n#define LOCK_RETRY_DELAY                (200)\n\n \nstatic bool debug;\nmodule_param(debug, bool, 0644);\nMODULE_PARM_DESC(debug, \"Debug level (0-1)\");\n\nMODULE_AUTHOR(\"Texas Instruments\");\nMODULE_DESCRIPTION(\"TVP514X linux decoder driver\");\nMODULE_LICENSE(\"GPL\");\n\n \nenum tvp514x_std {\n\tSTD_NTSC_MJ = 0,\n\tSTD_PAL_BDGHIN,\n\tSTD_INVALID\n};\n\n \nstruct tvp514x_std_info {\n\tunsigned long width;\n\tunsigned long height;\n\tu8 video_std;\n\tstruct v4l2_standard standard;\n};\n\nstatic struct tvp514x_reg tvp514x_reg_list_default[0x40];\n\nstatic int tvp514x_s_stream(struct v4l2_subdev *sd, int enable);\n \nstruct tvp514x_decoder {\n\tstruct v4l2_subdev sd;\n\tstruct v4l2_ctrl_handler hdl;\n\tstruct tvp514x_reg tvp514x_regs[ARRAY_SIZE(tvp514x_reg_list_default)];\n\tconst struct tvp514x_platform_data *pdata;\n\n\tint ver;\n\tint streaming;\n\n\tstruct v4l2_pix_format pix;\n\tint num_fmts;\n\tconst struct v4l2_fmtdesc *fmt_list;\n\n\tenum tvp514x_std current_std;\n\tint num_stds;\n\tconst struct tvp514x_std_info *std_list;\n\t \n\tu32 input;\n\tu32 output;\n\n\t \n\tstruct media_pad pad;\n\tstruct v4l2_mbus_framefmt format;\n\n\tstruct tvp514x_reg *int_seq;\n};\n\n \nstatic struct tvp514x_reg tvp514x_reg_list_default[] = {\n\t \n\t{TOK_WRITE, REG_INPUT_SEL, 0x05},\n\t{TOK_WRITE, REG_AFE_GAIN_CTRL, 0x0F},\n\t \n\t{TOK_WRITE, REG_VIDEO_STD, 0x00},\n\t{TOK_WRITE, REG_OPERATION_MODE, 0x00},\n\t{TOK_SKIP, REG_AUTOSWITCH_MASK, 0x3F},\n\t{TOK_WRITE, REG_COLOR_KILLER, 0x10},\n\t{TOK_WRITE, REG_LUMA_CONTROL1, 0x00},\n\t{TOK_WRITE, REG_LUMA_CONTROL2, 0x00},\n\t{TOK_WRITE, REG_LUMA_CONTROL3, 0x02},\n\t{TOK_WRITE, REG_BRIGHTNESS, 0x80},\n\t{TOK_WRITE, REG_CONTRAST, 0x80},\n\t{TOK_WRITE, REG_SATURATION, 0x80},\n\t{TOK_WRITE, REG_HUE, 0x00},\n\t{TOK_WRITE, REG_CHROMA_CONTROL1, 0x00},\n\t{TOK_WRITE, REG_CHROMA_CONTROL2, 0x0E},\n\t \n\t{TOK_SKIP, 0x0F, 0x00},\n\t{TOK_WRITE, REG_COMP_PR_SATURATION, 0x80},\n\t{TOK_WRITE, REG_COMP_Y_CONTRAST, 0x80},\n\t{TOK_WRITE, REG_COMP_PB_SATURATION, 0x80},\n\t \n\t{TOK_SKIP, 0x13, 0x00},\n\t{TOK_WRITE, REG_COMP_Y_BRIGHTNESS, 0x80},\n\t \n\t{TOK_SKIP, 0x15, 0x00},\n\t \n\t{TOK_SKIP, REG_AVID_START_PIXEL_LSB, 0x55},\n\t{TOK_SKIP, REG_AVID_START_PIXEL_MSB, 0x00},\n\t{TOK_SKIP, REG_AVID_STOP_PIXEL_LSB, 0x25},\n\t{TOK_SKIP, REG_AVID_STOP_PIXEL_MSB, 0x03},\n\t \n\t{TOK_SKIP, REG_HSYNC_START_PIXEL_LSB, 0x00},\n\t{TOK_SKIP, REG_HSYNC_START_PIXEL_MSB, 0x00},\n\t{TOK_SKIP, REG_HSYNC_STOP_PIXEL_LSB, 0x40},\n\t{TOK_SKIP, REG_HSYNC_STOP_PIXEL_MSB, 0x00},\n\t \n\t{TOK_SKIP, REG_VSYNC_START_LINE_LSB, 0x04},\n\t{TOK_SKIP, REG_VSYNC_START_LINE_MSB, 0x00},\n\t{TOK_SKIP, REG_VSYNC_STOP_LINE_LSB, 0x07},\n\t{TOK_SKIP, REG_VSYNC_STOP_LINE_MSB, 0x00},\n\t \n\t{TOK_SKIP, REG_VBLK_START_LINE_LSB, 0x01},\n\t{TOK_SKIP, REG_VBLK_START_LINE_MSB, 0x00},\n\t{TOK_SKIP, REG_VBLK_STOP_LINE_LSB, 0x15},\n\t{TOK_SKIP, REG_VBLK_STOP_LINE_MSB, 0x00},\n\t \n\t{TOK_SKIP, 0x26, 0x00},\n\t \n\t{TOK_SKIP, 0x27, 0x00},\n\t{TOK_SKIP, REG_FAST_SWTICH_CONTROL, 0xCC},\n\t \n\t{TOK_SKIP, 0x29, 0x00},\n\t{TOK_SKIP, REG_FAST_SWTICH_SCART_DELAY, 0x00},\n\t \n\t{TOK_SKIP, 0x2B, 0x00},\n\t{TOK_SKIP, REG_SCART_DELAY, 0x00},\n\t{TOK_SKIP, REG_CTI_DELAY, 0x00},\n\t{TOK_SKIP, REG_CTI_CONTROL, 0x00},\n\t \n\t{TOK_SKIP, 0x2F, 0x00},\n\t \n\t{TOK_SKIP, 0x30, 0x00},\n\t \n\t{TOK_SKIP, 0x31, 0x00},\n\t \n\t{TOK_WRITE, REG_SYNC_CONTROL, 0x00},\n\t \n\t{TOK_WRITE, REG_OUTPUT_FORMATTER1, 0x00},\n\t \n\t{TOK_WRITE, REG_OUTPUT_FORMATTER2, 0x11},\n\t \n\t{TOK_WRITE, REG_OUTPUT_FORMATTER3, 0xEE},\n\t \n\t{TOK_WRITE, REG_OUTPUT_FORMATTER4, 0xAF},\n\t{TOK_WRITE, REG_OUTPUT_FORMATTER5, 0xFF},\n\t{TOK_WRITE, REG_OUTPUT_FORMATTER6, 0xFF},\n\t \n\t{TOK_WRITE, REG_CLEAR_LOST_LOCK, 0x01},\n\t{TOK_TERM, 0, 0},\n};\n\n \nstatic const struct v4l2_fmtdesc tvp514x_fmt_list[] = {\n\t{\n\t .index\t\t= 0,\n\t .type\t\t= V4L2_BUF_TYPE_VIDEO_CAPTURE,\n\t .flags\t\t= 0,\n\t .description\t= \"8-bit UYVY 4:2:2 Format\",\n\t .pixelformat\t= V4L2_PIX_FMT_UYVY,\n\t},\n};\n\n \nstatic const struct tvp514x_std_info tvp514x_std_list[] = {\n\t \n\t[STD_NTSC_MJ] = {\n\t .width = NTSC_NUM_ACTIVE_PIXELS,\n\t .height = NTSC_NUM_ACTIVE_LINES,\n\t .video_std = VIDEO_STD_NTSC_MJ_BIT,\n\t .standard = {\n\t\t      .index = 0,\n\t\t      .id = V4L2_STD_NTSC,\n\t\t      .name = \"NTSC\",\n\t\t      .frameperiod = {1001, 30000},\n\t\t      .framelines = 525\n\t\t     },\n\t \n\t},\n\t[STD_PAL_BDGHIN] = {\n\t .width = PAL_NUM_ACTIVE_PIXELS,\n\t .height = PAL_NUM_ACTIVE_LINES,\n\t .video_std = VIDEO_STD_PAL_BDGHIN_BIT,\n\t .standard = {\n\t\t      .index = 1,\n\t\t      .id = V4L2_STD_PAL,\n\t\t      .name = \"PAL\",\n\t\t      .frameperiod = {1, 25},\n\t\t      .framelines = 625\n\t\t     },\n\t},\n\t \n};\n\n\nstatic inline struct tvp514x_decoder *to_decoder(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct tvp514x_decoder, sd);\n}\n\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct tvp514x_decoder, hdl)->sd;\n}\n\n\n \nstatic int tvp514x_read_reg(struct v4l2_subdev *sd, u8 reg)\n{\n\tint err, retry = 0;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\nread_again:\n\n\terr = i2c_smbus_read_byte_data(client, reg);\n\tif (err < 0) {\n\t\tif (retry <= I2C_RETRY_COUNT) {\n\t\t\tv4l2_warn(sd, \"Read: retry ... %d\\n\", retry);\n\t\t\tretry++;\n\t\t\tmsleep_interruptible(10);\n\t\t\tgoto read_again;\n\t\t}\n\t}\n\n\treturn err;\n}\n\n \nstatic void dump_reg(struct v4l2_subdev *sd, u8 reg)\n{\n\tu32 val;\n\n\tval = tvp514x_read_reg(sd, reg);\n\tv4l2_info(sd, \"Reg(0x%.2X): 0x%.2X\\n\", reg, val);\n}\n\n \nstatic int tvp514x_write_reg(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tint err, retry = 0;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\nwrite_again:\n\n\terr = i2c_smbus_write_byte_data(client, reg, val);\n\tif (err) {\n\t\tif (retry <= I2C_RETRY_COUNT) {\n\t\t\tv4l2_warn(sd, \"Write: retry ... %d\\n\", retry);\n\t\t\tretry++;\n\t\t\tmsleep_interruptible(10);\n\t\t\tgoto write_again;\n\t\t}\n\t}\n\n\treturn err;\n}\n\n \nstatic int tvp514x_write_regs(struct v4l2_subdev *sd,\n\t\t\t      const struct tvp514x_reg reglist[])\n{\n\tint err;\n\tconst struct tvp514x_reg *next = reglist;\n\n\tfor (; next->token != TOK_TERM; next++) {\n\t\tif (next->token == TOK_DELAY) {\n\t\t\tmsleep(next->val);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (next->token == TOK_SKIP)\n\t\t\tcontinue;\n\n\t\terr = tvp514x_write_reg(sd, next->reg, (u8) next->val);\n\t\tif (err) {\n\t\t\tv4l2_err(sd, \"Write failed. Err[%d]\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic enum tvp514x_std tvp514x_query_current_std(struct v4l2_subdev *sd)\n{\n\tu8 std, std_status;\n\n\tstd = tvp514x_read_reg(sd, REG_VIDEO_STD);\n\tif ((std & VIDEO_STD_MASK) == VIDEO_STD_AUTO_SWITCH_BIT)\n\t\t \n\t\tstd_status = tvp514x_read_reg(sd, REG_VIDEO_STD_STATUS);\n\telse\n\t\t \n\t\tstd_status = std;\n\n\tswitch (std_status & VIDEO_STD_MASK) {\n\tcase VIDEO_STD_NTSC_MJ_BIT:\n\t\treturn STD_NTSC_MJ;\n\n\tcase VIDEO_STD_PAL_BDGHIN_BIT:\n\t\treturn STD_PAL_BDGHIN;\n\n\tdefault:\n\t\treturn STD_INVALID;\n\t}\n\n\treturn STD_INVALID;\n}\n\n \nstatic void tvp514x_reg_dump(struct v4l2_subdev *sd)\n{\n\tdump_reg(sd, REG_INPUT_SEL);\n\tdump_reg(sd, REG_AFE_GAIN_CTRL);\n\tdump_reg(sd, REG_VIDEO_STD);\n\tdump_reg(sd, REG_OPERATION_MODE);\n\tdump_reg(sd, REG_COLOR_KILLER);\n\tdump_reg(sd, REG_LUMA_CONTROL1);\n\tdump_reg(sd, REG_LUMA_CONTROL2);\n\tdump_reg(sd, REG_LUMA_CONTROL3);\n\tdump_reg(sd, REG_BRIGHTNESS);\n\tdump_reg(sd, REG_CONTRAST);\n\tdump_reg(sd, REG_SATURATION);\n\tdump_reg(sd, REG_HUE);\n\tdump_reg(sd, REG_CHROMA_CONTROL1);\n\tdump_reg(sd, REG_CHROMA_CONTROL2);\n\tdump_reg(sd, REG_COMP_PR_SATURATION);\n\tdump_reg(sd, REG_COMP_Y_CONTRAST);\n\tdump_reg(sd, REG_COMP_PB_SATURATION);\n\tdump_reg(sd, REG_COMP_Y_BRIGHTNESS);\n\tdump_reg(sd, REG_AVID_START_PIXEL_LSB);\n\tdump_reg(sd, REG_AVID_START_PIXEL_MSB);\n\tdump_reg(sd, REG_AVID_STOP_PIXEL_LSB);\n\tdump_reg(sd, REG_AVID_STOP_PIXEL_MSB);\n\tdump_reg(sd, REG_HSYNC_START_PIXEL_LSB);\n\tdump_reg(sd, REG_HSYNC_START_PIXEL_MSB);\n\tdump_reg(sd, REG_HSYNC_STOP_PIXEL_LSB);\n\tdump_reg(sd, REG_HSYNC_STOP_PIXEL_MSB);\n\tdump_reg(sd, REG_VSYNC_START_LINE_LSB);\n\tdump_reg(sd, REG_VSYNC_START_LINE_MSB);\n\tdump_reg(sd, REG_VSYNC_STOP_LINE_LSB);\n\tdump_reg(sd, REG_VSYNC_STOP_LINE_MSB);\n\tdump_reg(sd, REG_VBLK_START_LINE_LSB);\n\tdump_reg(sd, REG_VBLK_START_LINE_MSB);\n\tdump_reg(sd, REG_VBLK_STOP_LINE_LSB);\n\tdump_reg(sd, REG_VBLK_STOP_LINE_MSB);\n\tdump_reg(sd, REG_SYNC_CONTROL);\n\tdump_reg(sd, REG_OUTPUT_FORMATTER1);\n\tdump_reg(sd, REG_OUTPUT_FORMATTER2);\n\tdump_reg(sd, REG_OUTPUT_FORMATTER3);\n\tdump_reg(sd, REG_OUTPUT_FORMATTER4);\n\tdump_reg(sd, REG_OUTPUT_FORMATTER5);\n\tdump_reg(sd, REG_OUTPUT_FORMATTER6);\n\tdump_reg(sd, REG_CLEAR_LOST_LOCK);\n}\n\n \nstatic int tvp514x_configure(struct v4l2_subdev *sd,\n\t\tstruct tvp514x_decoder *decoder)\n{\n\tint err;\n\n\t \n\terr =\n\t    tvp514x_write_regs(sd, decoder->tvp514x_regs);\n\tif (err)\n\t\treturn err;\n\n\tif (debug)\n\t\ttvp514x_reg_dump(sd);\n\n\treturn 0;\n}\n\n \nstatic int tvp514x_detect(struct v4l2_subdev *sd,\n\t\tstruct tvp514x_decoder *decoder)\n{\n\tu8 chip_id_msb, chip_id_lsb, rom_ver;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tchip_id_msb = tvp514x_read_reg(sd, REG_CHIP_ID_MSB);\n\tchip_id_lsb = tvp514x_read_reg(sd, REG_CHIP_ID_LSB);\n\trom_ver = tvp514x_read_reg(sd, REG_ROM_VERSION);\n\n\tv4l2_dbg(1, debug, sd,\n\t\t \"chip id detected msb:0x%x lsb:0x%x rom version:0x%x\\n\",\n\t\t chip_id_msb, chip_id_lsb, rom_ver);\n\tif ((chip_id_msb != TVP514X_CHIP_ID_MSB)\n\t\t|| ((chip_id_lsb != TVP5146_CHIP_ID_LSB)\n\t\t&& (chip_id_lsb != TVP5147_CHIP_ID_LSB))) {\n\t\t \n\t\tv4l2_err(sd, \"chip id mismatch msb:0x%x lsb:0x%x\\n\",\n\t\t\t\tchip_id_msb, chip_id_lsb);\n\t\treturn -ENODEV;\n\t}\n\n\tdecoder->ver = rom_ver;\n\n\tv4l2_info(sd, \"%s (Version - 0x%.2x) found at 0x%x (%s)\\n\",\n\t\t\tclient->name, decoder->ver,\n\t\t\tclient->addr << 1, client->adapter->name);\n\treturn 0;\n}\n\n \nstatic int tvp514x_querystd(struct v4l2_subdev *sd, v4l2_std_id *std_id)\n{\n\tstruct tvp514x_decoder *decoder = to_decoder(sd);\n\tenum tvp514x_std current_std;\n\tenum tvp514x_input input_sel;\n\tu8 sync_lock_status, lock_mask;\n\n\tif (std_id == NULL)\n\t\treturn -EINVAL;\n\n\t \n\tif (!decoder->streaming) {\n\t\ttvp514x_s_stream(sd, 1);\n\t\tmsleep(LOCK_RETRY_DELAY);\n\t}\n\n\t \n\tcurrent_std = tvp514x_query_current_std(sd);\n\tif (current_std == STD_INVALID) {\n\t\t*std_id = V4L2_STD_UNKNOWN;\n\t\treturn 0;\n\t}\n\n\tinput_sel = decoder->input;\n\n\tswitch (input_sel) {\n\tcase INPUT_CVBS_VI1A:\n\tcase INPUT_CVBS_VI1B:\n\tcase INPUT_CVBS_VI1C:\n\tcase INPUT_CVBS_VI2A:\n\tcase INPUT_CVBS_VI2B:\n\tcase INPUT_CVBS_VI2C:\n\tcase INPUT_CVBS_VI3A:\n\tcase INPUT_CVBS_VI3B:\n\tcase INPUT_CVBS_VI3C:\n\tcase INPUT_CVBS_VI4A:\n\t\tlock_mask = STATUS_CLR_SUBCAR_LOCK_BIT |\n\t\t\tSTATUS_HORZ_SYNC_LOCK_BIT |\n\t\t\tSTATUS_VIRT_SYNC_LOCK_BIT;\n\t\tbreak;\n\n\tcase INPUT_SVIDEO_VI2A_VI1A:\n\tcase INPUT_SVIDEO_VI2B_VI1B:\n\tcase INPUT_SVIDEO_VI2C_VI1C:\n\tcase INPUT_SVIDEO_VI2A_VI3A:\n\tcase INPUT_SVIDEO_VI2B_VI3B:\n\tcase INPUT_SVIDEO_VI2C_VI3C:\n\tcase INPUT_SVIDEO_VI4A_VI1A:\n\tcase INPUT_SVIDEO_VI4A_VI1B:\n\tcase INPUT_SVIDEO_VI4A_VI1C:\n\tcase INPUT_SVIDEO_VI4A_VI3A:\n\tcase INPUT_SVIDEO_VI4A_VI3B:\n\tcase INPUT_SVIDEO_VI4A_VI3C:\n\t\tlock_mask = STATUS_HORZ_SYNC_LOCK_BIT |\n\t\t\tSTATUS_VIRT_SYNC_LOCK_BIT;\n\t\tbreak;\n\t\t \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t \n\tsync_lock_status = tvp514x_read_reg(sd, REG_STATUS1);\n\tif (lock_mask != (sync_lock_status & lock_mask)) {\n\t\t*std_id = V4L2_STD_UNKNOWN;\n\t\treturn 0;\t \n\t}\n\n\t*std_id &= decoder->std_list[current_std].standard.id;\n\n\tv4l2_dbg(1, debug, sd, \"Current STD: %s\\n\",\n\t\t\tdecoder->std_list[current_std].standard.name);\n\treturn 0;\n}\n\n \nstatic int tvp514x_s_std(struct v4l2_subdev *sd, v4l2_std_id std_id)\n{\n\tstruct tvp514x_decoder *decoder = to_decoder(sd);\n\tint err, i;\n\n\tfor (i = 0; i < decoder->num_stds; i++)\n\t\tif (std_id & decoder->std_list[i].standard.id)\n\t\t\tbreak;\n\n\tif ((i == decoder->num_stds) || (i == STD_INVALID))\n\t\treturn -EINVAL;\n\n\terr = tvp514x_write_reg(sd, REG_VIDEO_STD,\n\t\t\t\tdecoder->std_list[i].video_std);\n\tif (err)\n\t\treturn err;\n\n\tdecoder->current_std = i;\n\tdecoder->tvp514x_regs[REG_VIDEO_STD].val =\n\t\tdecoder->std_list[i].video_std;\n\n\tv4l2_dbg(1, debug, sd, \"Standard set to: %s\\n\",\n\t\t\tdecoder->std_list[i].standard.name);\n\treturn 0;\n}\n\n \nstatic int tvp514x_s_routing(struct v4l2_subdev *sd,\n\t\t\t\tu32 input, u32 output, u32 config)\n{\n\tstruct tvp514x_decoder *decoder = to_decoder(sd);\n\tint err;\n\tenum tvp514x_input input_sel;\n\tenum tvp514x_output output_sel;\n\n\tif ((input >= INPUT_INVALID) ||\n\t\t\t(output >= OUTPUT_INVALID))\n\t\t \n\t\treturn -EINVAL;\n\n\tinput_sel = input;\n\toutput_sel = output;\n\n\terr = tvp514x_write_reg(sd, REG_INPUT_SEL, input_sel);\n\tif (err)\n\t\treturn err;\n\n\toutput_sel |= tvp514x_read_reg(sd,\n\t\t\tREG_OUTPUT_FORMATTER1) & 0x7;\n\terr = tvp514x_write_reg(sd, REG_OUTPUT_FORMATTER1,\n\t\t\toutput_sel);\n\tif (err)\n\t\treturn err;\n\n\tdecoder->tvp514x_regs[REG_INPUT_SEL].val = input_sel;\n\tdecoder->tvp514x_regs[REG_OUTPUT_FORMATTER1].val = output_sel;\n\tdecoder->input = input;\n\tdecoder->output = output;\n\n\tv4l2_dbg(1, debug, sd, \"Input set to: %d\\n\", input_sel);\n\n\treturn 0;\n}\n\n \nstatic int tvp514x_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\tstruct tvp514x_decoder *decoder = to_decoder(sd);\n\tint err = -EINVAL, value;\n\n\tvalue = ctrl->val;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\terr = tvp514x_write_reg(sd, REG_BRIGHTNESS, value);\n\t\tif (!err)\n\t\t\tdecoder->tvp514x_regs[REG_BRIGHTNESS].val = value;\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\terr = tvp514x_write_reg(sd, REG_CONTRAST, value);\n\t\tif (!err)\n\t\t\tdecoder->tvp514x_regs[REG_CONTRAST].val = value;\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\terr = tvp514x_write_reg(sd, REG_SATURATION, value);\n\t\tif (!err)\n\t\t\tdecoder->tvp514x_regs[REG_SATURATION].val = value;\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\tif (value == 180)\n\t\t\tvalue = 0x7F;\n\t\telse if (value == -180)\n\t\t\tvalue = 0x80;\n\t\terr = tvp514x_write_reg(sd, REG_HUE, value);\n\t\tif (!err)\n\t\t\tdecoder->tvp514x_regs[REG_HUE].val = value;\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\terr = tvp514x_write_reg(sd, REG_AFE_GAIN_CTRL, value ? 0x0f : 0x0c);\n\t\tif (!err)\n\t\t\tdecoder->tvp514x_regs[REG_AFE_GAIN_CTRL].val = value;\n\t\tbreak;\n\t}\n\n\tv4l2_dbg(1, debug, sd, \"Set Control: ID - %d - %d\\n\",\n\t\t\tctrl->id, ctrl->val);\n\treturn err;\n}\n\n \nstatic int\ntvp514x_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t struct v4l2_subdev_frame_interval *ival)\n{\n\tstruct tvp514x_decoder *decoder = to_decoder(sd);\n\tenum tvp514x_std current_std;\n\n\n\t \n\tcurrent_std = decoder->current_std;\n\n\tival->interval =\n\t\tdecoder->std_list[current_std].standard.frameperiod;\n\n\treturn 0;\n}\n\n \nstatic int\ntvp514x_s_frame_interval(struct v4l2_subdev *sd,\n\t\t\t struct v4l2_subdev_frame_interval *ival)\n{\n\tstruct tvp514x_decoder *decoder = to_decoder(sd);\n\tstruct v4l2_fract *timeperframe;\n\tenum tvp514x_std current_std;\n\n\n\ttimeperframe = &ival->interval;\n\n\t \n\tcurrent_std = decoder->current_std;\n\n\t*timeperframe =\n\t    decoder->std_list[current_std].standard.frameperiod;\n\n\treturn 0;\n}\n\n \nstatic int tvp514x_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tint err = 0;\n\tstruct tvp514x_decoder *decoder = to_decoder(sd);\n\n\tif (decoder->streaming == enable)\n\t\treturn 0;\n\n\tswitch (enable) {\n\tcase 0:\n\t{\n\t\t \n\t\terr = tvp514x_write_reg(sd, REG_OPERATION_MODE, 0x01);\n\t\tif (err) {\n\t\t\tv4l2_err(sd, \"Unable to turn off decoder\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tdecoder->streaming = enable;\n\t\tbreak;\n\t}\n\tcase 1:\n\t{\n\t\t \n\t\terr = tvp514x_write_regs(sd, decoder->int_seq);\n\t\tif (err) {\n\t\t\tv4l2_err(sd, \"Unable to turn on decoder\\n\");\n\t\t\treturn err;\n\t\t}\n\t\t \n\t\terr = tvp514x_detect(sd, decoder);\n\t\tif (err) {\n\t\t\tv4l2_err(sd, \"Unable to detect decoder\\n\");\n\t\t\treturn err;\n\t\t}\n\t\terr = tvp514x_configure(sd, decoder);\n\t\tif (err) {\n\t\t\tv4l2_err(sd, \"Unable to configure decoder\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tdecoder->streaming = enable;\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = -ENODEV;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic const struct v4l2_ctrl_ops tvp514x_ctrl_ops = {\n\t.s_ctrl = tvp514x_s_ctrl,\n};\n\n \nstatic int tvp514x_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tu32 pad = code->pad;\n\tu32 index = code->index;\n\n\tmemset(code, 0, sizeof(*code));\n\tcode->index = index;\n\tcode->pad = pad;\n\n\tif (index != 0)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_UYVY8_2X8;\n\n\treturn 0;\n}\n\n \nstatic int tvp514x_get_pad_format(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct tvp514x_decoder *decoder = to_decoder(sd);\n\t__u32 which = format->which;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tif (which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\tformat->format = decoder->format;\n\t\treturn 0;\n\t}\n\n\tformat->format.code = MEDIA_BUS_FMT_UYVY8_2X8;\n\tformat->format.width = tvp514x_std_list[decoder->current_std].width;\n\tformat->format.height = tvp514x_std_list[decoder->current_std].height;\n\tformat->format.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tformat->format.field = V4L2_FIELD_INTERLACED;\n\n\treturn 0;\n}\n\n \nstatic int tvp514x_set_pad_format(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_format *fmt)\n{\n\tstruct tvp514x_decoder *decoder = to_decoder(sd);\n\n\tif (fmt->format.field != V4L2_FIELD_INTERLACED ||\n\t    fmt->format.code != MEDIA_BUS_FMT_UYVY8_2X8 ||\n\t    fmt->format.colorspace != V4L2_COLORSPACE_SMPTE170M ||\n\t    fmt->format.width != tvp514x_std_list[decoder->current_std].width ||\n\t    fmt->format.height != tvp514x_std_list[decoder->current_std].height)\n\t\treturn -EINVAL;\n\n\tdecoder->format = fmt->format;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops tvp514x_video_ops = {\n\t.s_std = tvp514x_s_std,\n\t.s_routing = tvp514x_s_routing,\n\t.querystd = tvp514x_querystd,\n\t.g_frame_interval = tvp514x_g_frame_interval,\n\t.s_frame_interval = tvp514x_s_frame_interval,\n\t.s_stream = tvp514x_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops tvp514x_pad_ops = {\n\t.enum_mbus_code = tvp514x_enum_mbus_code,\n\t.get_fmt = tvp514x_get_pad_format,\n\t.set_fmt = tvp514x_set_pad_format,\n};\n\nstatic const struct v4l2_subdev_ops tvp514x_ops = {\n\t.video = &tvp514x_video_ops,\n\t.pad = &tvp514x_pad_ops,\n};\n\nstatic const struct tvp514x_decoder tvp514x_dev = {\n\t.streaming = 0,\n\t.fmt_list = tvp514x_fmt_list,\n\t.num_fmts = ARRAY_SIZE(tvp514x_fmt_list),\n\t.pix = {\n\t\t \n\t\t.width\t\t= NTSC_NUM_ACTIVE_PIXELS,\n\t\t.height\t\t= NTSC_NUM_ACTIVE_LINES,\n\t\t.pixelformat\t= V4L2_PIX_FMT_UYVY,\n\t\t.field\t\t= V4L2_FIELD_INTERLACED,\n\t\t.bytesperline\t= NTSC_NUM_ACTIVE_PIXELS * 2,\n\t\t.sizeimage\t= NTSC_NUM_ACTIVE_PIXELS * 2 *\n\t\t\t\t\tNTSC_NUM_ACTIVE_LINES,\n\t\t.colorspace\t= V4L2_COLORSPACE_SMPTE170M,\n\t\t},\n\t.current_std = STD_NTSC_MJ,\n\t.std_list = tvp514x_std_list,\n\t.num_stds = ARRAY_SIZE(tvp514x_std_list),\n\n};\n\nstatic struct tvp514x_platform_data *\ntvp514x_get_pdata(struct i2c_client *client)\n{\n\tstruct tvp514x_platform_data *pdata = NULL;\n\tstruct v4l2_fwnode_endpoint bus_cfg = { .bus_type = 0 };\n\tstruct device_node *endpoint;\n\tunsigned int flags;\n\n\tif (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)\n\t\treturn client->dev.platform_data;\n\n\tendpoint = of_graph_get_next_endpoint(client->dev.of_node, NULL);\n\tif (!endpoint)\n\t\treturn NULL;\n\n\tif (v4l2_fwnode_endpoint_parse(of_fwnode_handle(endpoint), &bus_cfg))\n\t\tgoto done;\n\n\tpdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\tgoto done;\n\n\tflags = bus_cfg.bus.parallel.flags;\n\n\tif (flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)\n\t\tpdata->hs_polarity = 1;\n\n\tif (flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)\n\t\tpdata->vs_polarity = 1;\n\n\tif (flags & V4L2_MBUS_PCLK_SAMPLE_RISING)\n\t\tpdata->clk_polarity = 1;\n\ndone:\n\tof_node_put(endpoint);\n\treturn pdata;\n}\n\n \nstatic int\ntvp514x_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct tvp514x_platform_data *pdata = tvp514x_get_pdata(client);\n\tstruct tvp514x_decoder *decoder;\n\tstruct v4l2_subdev *sd;\n\tint ret;\n\n\tif (pdata == NULL) {\n\t\tdev_err(&client->dev, \"No platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tdecoder = devm_kzalloc(&client->dev, sizeof(*decoder), GFP_KERNEL);\n\tif (!decoder)\n\t\treturn -ENOMEM;\n\n\t \n\t*decoder = tvp514x_dev;\n\t \n\tmemcpy(decoder->tvp514x_regs, tvp514x_reg_list_default,\n\t\t\tsizeof(tvp514x_reg_list_default));\n\n\tdecoder->int_seq = (struct tvp514x_reg *)id->driver_data;\n\n\t \n\tdecoder->pdata = pdata;\n\n\t \n\tdecoder->tvp514x_regs[REG_OUTPUT_FORMATTER2].val |=\n\t\t(decoder->pdata->clk_polarity << 1);\n\tdecoder->tvp514x_regs[REG_SYNC_CONTROL].val |=\n\t\t((decoder->pdata->hs_polarity << 2) |\n\t\t (decoder->pdata->vs_polarity << 3));\n\t \n\tdecoder->tvp514x_regs[REG_VIDEO_STD].val =\n\t\tVIDEO_STD_AUTO_SWITCH_BIT;\n\n\t \n\tsd = &decoder->sd;\n\tv4l2_i2c_subdev_init(sd, client, &tvp514x_ops);\n\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tdecoder->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tdecoder->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tdecoder->sd.entity.function = MEDIA_ENT_F_ATV_DECODER;\n\n\tret = media_entity_pads_init(&decoder->sd.entity, 1, &decoder->pad);\n\tif (ret < 0) {\n\t\tv4l2_err(sd, \"%s decoder driver failed to register !!\\n\",\n\t\t\t sd->name);\n\t\treturn ret;\n\t}\n#endif\n\tv4l2_ctrl_handler_init(&decoder->hdl, 5);\n\tv4l2_ctrl_new_std(&decoder->hdl, &tvp514x_ctrl_ops,\n\t\tV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(&decoder->hdl, &tvp514x_ctrl_ops,\n\t\tV4L2_CID_CONTRAST, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(&decoder->hdl, &tvp514x_ctrl_ops,\n\t\tV4L2_CID_SATURATION, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(&decoder->hdl, &tvp514x_ctrl_ops,\n\t\tV4L2_CID_HUE, -180, 180, 180, 0);\n\tv4l2_ctrl_new_std(&decoder->hdl, &tvp514x_ctrl_ops,\n\t\tV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\tsd->ctrl_handler = &decoder->hdl;\n\tif (decoder->hdl.error) {\n\t\tret = decoder->hdl.error;\n\t\tgoto done;\n\t}\n\tv4l2_ctrl_handler_setup(&decoder->hdl);\n\n\tret = v4l2_async_register_subdev(&decoder->sd);\n\tif (!ret)\n\t\tv4l2_info(sd, \"%s decoder driver registered !!\\n\", sd->name);\n\ndone:\n\tif (ret < 0) {\n\t\tv4l2_ctrl_handler_free(&decoder->hdl);\n\t\tmedia_entity_cleanup(&decoder->sd.entity);\n\t}\n\treturn ret;\n}\n\n \nstatic void tvp514x_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct tvp514x_decoder *decoder = to_decoder(sd);\n\n\tv4l2_async_unregister_subdev(&decoder->sd);\n\tmedia_entity_cleanup(&decoder->sd.entity);\n\tv4l2_ctrl_handler_free(&decoder->hdl);\n}\n \nstatic const struct tvp514x_reg tvp5146_init_reg_seq[] = {\n\t{TOK_WRITE, REG_VBUS_ADDRESS_ACCESS1, 0x02},\n\t{TOK_WRITE, REG_VBUS_ADDRESS_ACCESS2, 0x00},\n\t{TOK_WRITE, REG_VBUS_ADDRESS_ACCESS3, 0x80},\n\t{TOK_WRITE, REG_VBUS_DATA_ACCESS_NO_VBUS_ADDR_INCR, 0x01},\n\t{TOK_WRITE, REG_VBUS_ADDRESS_ACCESS1, 0x60},\n\t{TOK_WRITE, REG_VBUS_ADDRESS_ACCESS2, 0x00},\n\t{TOK_WRITE, REG_VBUS_ADDRESS_ACCESS3, 0xB0},\n\t{TOK_WRITE, REG_VBUS_DATA_ACCESS_NO_VBUS_ADDR_INCR, 0x01},\n\t{TOK_WRITE, REG_VBUS_DATA_ACCESS_NO_VBUS_ADDR_INCR, 0x00},\n\t{TOK_WRITE, REG_OPERATION_MODE, 0x01},\n\t{TOK_WRITE, REG_OPERATION_MODE, 0x00},\n\t{TOK_TERM, 0, 0},\n};\n\n \nstatic const struct tvp514x_reg tvp5147_init_reg_seq[] =\t{\n\t{TOK_WRITE, REG_VBUS_ADDRESS_ACCESS1, 0x02},\n\t{TOK_WRITE, REG_VBUS_ADDRESS_ACCESS2, 0x00},\n\t{TOK_WRITE, REG_VBUS_ADDRESS_ACCESS3, 0x80},\n\t{TOK_WRITE, REG_VBUS_DATA_ACCESS_NO_VBUS_ADDR_INCR, 0x01},\n\t{TOK_WRITE, REG_VBUS_ADDRESS_ACCESS1, 0x60},\n\t{TOK_WRITE, REG_VBUS_ADDRESS_ACCESS2, 0x00},\n\t{TOK_WRITE, REG_VBUS_ADDRESS_ACCESS3, 0xB0},\n\t{TOK_WRITE, REG_VBUS_DATA_ACCESS_NO_VBUS_ADDR_INCR, 0x01},\n\t{TOK_WRITE, REG_VBUS_ADDRESS_ACCESS1, 0x16},\n\t{TOK_WRITE, REG_VBUS_ADDRESS_ACCESS2, 0x00},\n\t{TOK_WRITE, REG_VBUS_ADDRESS_ACCESS3, 0xA0},\n\t{TOK_WRITE, REG_VBUS_DATA_ACCESS_NO_VBUS_ADDR_INCR, 0x16},\n\t{TOK_WRITE, REG_VBUS_ADDRESS_ACCESS1, 0x60},\n\t{TOK_WRITE, REG_VBUS_ADDRESS_ACCESS2, 0x00},\n\t{TOK_WRITE, REG_VBUS_ADDRESS_ACCESS3, 0xB0},\n\t{TOK_WRITE, REG_VBUS_DATA_ACCESS_NO_VBUS_ADDR_INCR, 0x00},\n\t{TOK_WRITE, REG_OPERATION_MODE, 0x01},\n\t{TOK_WRITE, REG_OPERATION_MODE, 0x00},\n\t{TOK_TERM, 0, 0},\n};\n\n \nstatic const struct tvp514x_reg tvp514xm_init_reg_seq[] = {\n\t{TOK_WRITE, REG_OPERATION_MODE, 0x01},\n\t{TOK_WRITE, REG_OPERATION_MODE, 0x00},\n\t{TOK_TERM, 0, 0},\n};\n\n \nstatic const struct i2c_device_id tvp514x_id[] = {\n\t{\"tvp5146\", (unsigned long)tvp5146_init_reg_seq},\n\t{\"tvp5146m2\", (unsigned long)tvp514xm_init_reg_seq},\n\t{\"tvp5147\", (unsigned long)tvp5147_init_reg_seq},\n\t{\"tvp5147m1\", (unsigned long)tvp514xm_init_reg_seq},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(i2c, tvp514x_id);\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id tvp514x_of_match[] = {\n\t{ .compatible = \"ti,tvp5146\", },\n\t{ .compatible = \"ti,tvp5146m2\", },\n\t{ .compatible = \"ti,tvp5147\", },\n\t{ .compatible = \"ti,tvp5147m1\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, tvp514x_of_match);\n#endif\n\nstatic struct i2c_driver tvp514x_driver = {\n\t.driver = {\n\t\t.of_match_table = of_match_ptr(tvp514x_of_match),\n\t\t.name = TVP514X_MODULE_NAME,\n\t},\n\t.probe = tvp514x_probe,\n\t.remove = tvp514x_remove,\n\t.id_table = tvp514x_id,\n};\n\nmodule_i2c_driver(tvp514x_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}