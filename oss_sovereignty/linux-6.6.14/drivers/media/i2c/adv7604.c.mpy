{
  "module_name": "adv7604.c",
  "hash_id": "06b2e07e706bb5aa8d34700c94eeb5362a9617f2c6570f490b2077626c42126a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/adv7604.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/hdmi.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/slab.h>\n#include <linux/v4l2-dv-timings.h>\n#include <linux/videodev2.h>\n#include <linux/workqueue.h>\n#include <linux/regmap.h>\n#include <linux/interrupt.h>\n\n#include <media/i2c/adv7604.h>\n#include <media/cec.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-dv-timings.h>\n#include <media/v4l2-fwnode.h>\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"debug level (0-2)\");\n\nMODULE_DESCRIPTION(\"Analog Devices ADV7604/10/11/12 video decoder driver\");\nMODULE_AUTHOR(\"Hans Verkuil <hans.verkuil@cisco.com>\");\nMODULE_AUTHOR(\"Mats Randgaard <mats.randgaard@cisco.com>\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define ADV76XX_FSC (28636360)\n\n#define ADV76XX_RGB_OUT\t\t\t\t\t(1 << 1)\n\n#define ADV76XX_OP_FORMAT_SEL_8BIT\t\t\t(0 << 0)\n#define ADV7604_OP_FORMAT_SEL_10BIT\t\t\t(1 << 0)\n#define ADV76XX_OP_FORMAT_SEL_12BIT\t\t\t(2 << 0)\n\n#define ADV76XX_OP_MODE_SEL_SDR_422\t\t\t(0 << 5)\n#define ADV7604_OP_MODE_SEL_DDR_422\t\t\t(1 << 5)\n#define ADV76XX_OP_MODE_SEL_SDR_444\t\t\t(2 << 5)\n#define ADV7604_OP_MODE_SEL_DDR_444\t\t\t(3 << 5)\n#define ADV76XX_OP_MODE_SEL_SDR_422_2X\t\t\t(4 << 5)\n#define ADV7604_OP_MODE_SEL_ADI_CM\t\t\t(5 << 5)\n\n#define ADV76XX_OP_CH_SEL_GBR\t\t\t\t(0 << 5)\n#define ADV76XX_OP_CH_SEL_GRB\t\t\t\t(1 << 5)\n#define ADV76XX_OP_CH_SEL_BGR\t\t\t\t(2 << 5)\n#define ADV76XX_OP_CH_SEL_RGB\t\t\t\t(3 << 5)\n#define ADV76XX_OP_CH_SEL_BRG\t\t\t\t(4 << 5)\n#define ADV76XX_OP_CH_SEL_RBG\t\t\t\t(5 << 5)\n\n#define ADV76XX_OP_SWAP_CB_CR\t\t\t\t(1 << 0)\n\n#define ADV76XX_MAX_ADDRS (3)\n\n#define ADV76XX_MAX_EDID_BLOCKS 4\n\nenum adv76xx_type {\n\tADV7604,\n\tADV7611, \n\tADV7612,\n};\n\nstruct adv76xx_reg_seq {\n\tunsigned int reg;\n\tu8 val;\n};\n\nstruct adv76xx_format_info {\n\tu32 code;\n\tu8 op_ch_sel;\n\tbool rgb_out;\n\tbool swap_cb_cr;\n\tu8 op_format_sel;\n};\n\nstruct adv76xx_cfg_read_infoframe {\n\tconst char *desc;\n\tu8 present_mask;\n\tu8 head_addr;\n\tu8 payload_addr;\n};\n\nstruct adv76xx_chip_info {\n\tenum adv76xx_type type;\n\n\tbool has_afe;\n\tunsigned int max_port;\n\tunsigned int num_dv_ports;\n\n\tunsigned int edid_enable_reg;\n\tunsigned int edid_status_reg;\n\tunsigned int edid_segment_reg;\n\tunsigned int edid_segment_mask;\n\tunsigned int edid_spa_loc_reg;\n\tunsigned int edid_spa_loc_msb_mask;\n\tunsigned int edid_spa_port_b_reg;\n\tunsigned int lcf_reg;\n\n\tunsigned int cable_det_mask;\n\tunsigned int tdms_lock_mask;\n\tunsigned int fmt_change_digital_mask;\n\tunsigned int cp_csc;\n\n\tunsigned int cec_irq_status;\n\tunsigned int cec_rx_enable;\n\tunsigned int cec_rx_enable_mask;\n\tbool cec_irq_swap;\n\n\tconst struct adv76xx_format_info *formats;\n\tunsigned int nformats;\n\n\tvoid (*set_termination)(struct v4l2_subdev *sd, bool enable);\n\tvoid (*setup_irqs)(struct v4l2_subdev *sd);\n\tunsigned int (*read_hdmi_pixelclock)(struct v4l2_subdev *sd);\n\tunsigned int (*read_cable_det)(struct v4l2_subdev *sd);\n\n\t \n\tconst struct adv76xx_reg_seq *recommended_settings[2];\n\tunsigned int num_recommended_settings[2];\n\n\tunsigned long page_mask;\n\n\t \n\tunsigned int linewidth_mask;\n\tunsigned int field0_height_mask;\n\tunsigned int field1_height_mask;\n\tunsigned int hfrontporch_mask;\n\tunsigned int hsync_mask;\n\tunsigned int hbackporch_mask;\n\tunsigned int field0_vfrontporch_mask;\n\tunsigned int field1_vfrontporch_mask;\n\tunsigned int field0_vsync_mask;\n\tunsigned int field1_vsync_mask;\n\tunsigned int field0_vbackporch_mask;\n\tunsigned int field1_vbackporch_mask;\n};\n\n \n\nstruct adv76xx_state {\n\tconst struct adv76xx_chip_info *info;\n\tstruct adv76xx_platform_data pdata;\n\n\tstruct gpio_desc *hpd_gpio[4];\n\tstruct gpio_desc *reset_gpio;\n\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pads[ADV76XX_PAD_MAX];\n\tunsigned int source_pad;\n\n\tstruct v4l2_ctrl_handler hdl;\n\n\tenum adv76xx_pad selected_input;\n\n\tstruct v4l2_dv_timings timings;\n\tconst struct adv76xx_format_info *format;\n\n\tstruct {\n\t\tu8 edid[ADV76XX_MAX_EDID_BLOCKS * 128];\n\t\tu32 present;\n\t\tunsigned blocks;\n\t} edid;\n\tu16 spa_port_a[2];\n\tstruct v4l2_fract aspect_ratio;\n\tu32 rgb_quantization_range;\n\tstruct delayed_work delayed_work_enable_hotplug;\n\tbool restart_stdi_once;\n\n\t \n\tstruct cec_adapter *cec_adap;\n\tu8   cec_addr[ADV76XX_MAX_ADDRS];\n\tu8   cec_valid_addrs;\n\tbool cec_enabled_adap;\n\n\t \n\tstruct i2c_client *i2c_clients[ADV76XX_PAGE_MAX];\n\n\t \n\tstruct regmap *regmap[ADV76XX_PAGE_MAX];\n\n\t \n\tstruct v4l2_ctrl *detect_tx_5v_ctrl;\n\tstruct v4l2_ctrl *analog_sampling_phase_ctrl;\n\tstruct v4l2_ctrl *free_run_color_manual_ctrl;\n\tstruct v4l2_ctrl *free_run_color_ctrl;\n\tstruct v4l2_ctrl *rgb_quantization_range_ctrl;\n};\n\nstatic bool adv76xx_has_afe(struct adv76xx_state *state)\n{\n\treturn state->info->has_afe;\n}\n\n \nstatic const struct v4l2_dv_timings adv76xx_timings_exceptions[] = {\n\tV4L2_DV_BT_CEA_1280X720P30,\n\t{ }\n};\n\nstatic bool adv76xx_check_dv_timings(const struct v4l2_dv_timings *t, void *hdl)\n{\n\tint i;\n\n\tfor (i = 0; adv76xx_timings_exceptions[i].bt.width; i++)\n\t\tif (v4l2_match_dv_timings(t, adv76xx_timings_exceptions + i, 0, false))\n\t\t\treturn false;\n\treturn true;\n}\n\nstruct adv76xx_video_standards {\n\tstruct v4l2_dv_timings timings;\n\tu8 vid_std;\n\tu8 v_freq;\n};\n\n \nstatic const struct adv76xx_video_standards adv7604_prim_mode_comp[] = {\n\t \n\t{ V4L2_DV_BT_CEA_720X576P50, 0x0b, 0x00 },\n\t{ V4L2_DV_BT_CEA_1280X720P50, 0x19, 0x01 },\n\t{ V4L2_DV_BT_CEA_1280X720P60, 0x19, 0x00 },\n\t{ V4L2_DV_BT_CEA_1920X1080P24, 0x1e, 0x04 },\n\t{ V4L2_DV_BT_CEA_1920X1080P25, 0x1e, 0x03 },\n\t{ V4L2_DV_BT_CEA_1920X1080P30, 0x1e, 0x02 },\n\t{ V4L2_DV_BT_CEA_1920X1080P50, 0x1e, 0x01 },\n\t{ V4L2_DV_BT_CEA_1920X1080P60, 0x1e, 0x00 },\n\t \n\t{ },\n};\n\n \nstatic const struct adv76xx_video_standards adv7604_prim_mode_gr[] = {\n\t{ V4L2_DV_BT_DMT_640X480P60, 0x08, 0x00 },\n\t{ V4L2_DV_BT_DMT_640X480P72, 0x09, 0x00 },\n\t{ V4L2_DV_BT_DMT_640X480P75, 0x0a, 0x00 },\n\t{ V4L2_DV_BT_DMT_640X480P85, 0x0b, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P56, 0x00, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P60, 0x01, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P72, 0x02, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P75, 0x03, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P85, 0x04, 0x00 },\n\t{ V4L2_DV_BT_DMT_1024X768P60, 0x0c, 0x00 },\n\t{ V4L2_DV_BT_DMT_1024X768P70, 0x0d, 0x00 },\n\t{ V4L2_DV_BT_DMT_1024X768P75, 0x0e, 0x00 },\n\t{ V4L2_DV_BT_DMT_1024X768P85, 0x0f, 0x00 },\n\t{ V4L2_DV_BT_DMT_1280X1024P60, 0x05, 0x00 },\n\t{ V4L2_DV_BT_DMT_1280X1024P75, 0x06, 0x00 },\n\t{ V4L2_DV_BT_DMT_1360X768P60, 0x12, 0x00 },\n\t{ V4L2_DV_BT_DMT_1366X768P60, 0x13, 0x00 },\n\t{ V4L2_DV_BT_DMT_1400X1050P60, 0x14, 0x00 },\n\t{ V4L2_DV_BT_DMT_1400X1050P75, 0x15, 0x00 },\n\t{ V4L2_DV_BT_DMT_1600X1200P60, 0x16, 0x00 },  \n\t \n\t{ V4L2_DV_BT_DMT_1680X1050P60, 0x18, 0x00 },\n\t{ V4L2_DV_BT_DMT_1920X1200P60_RB, 0x19, 0x00 },  \n\t{ },\n};\n\n \nstatic const struct adv76xx_video_standards adv76xx_prim_mode_hdmi_comp[] = {\n\t{ V4L2_DV_BT_CEA_720X480P59_94, 0x0a, 0x00 },\n\t{ V4L2_DV_BT_CEA_720X576P50, 0x0b, 0x00 },\n\t{ V4L2_DV_BT_CEA_1280X720P50, 0x13, 0x01 },\n\t{ V4L2_DV_BT_CEA_1280X720P60, 0x13, 0x00 },\n\t{ V4L2_DV_BT_CEA_1920X1080P24, 0x1e, 0x04 },\n\t{ V4L2_DV_BT_CEA_1920X1080P25, 0x1e, 0x03 },\n\t{ V4L2_DV_BT_CEA_1920X1080P30, 0x1e, 0x02 },\n\t{ V4L2_DV_BT_CEA_1920X1080P50, 0x1e, 0x01 },\n\t{ V4L2_DV_BT_CEA_1920X1080P60, 0x1e, 0x00 },\n\t{ },\n};\n\n \nstatic const struct adv76xx_video_standards adv76xx_prim_mode_hdmi_gr[] = {\n\t{ V4L2_DV_BT_DMT_640X480P60, 0x08, 0x00 },\n\t{ V4L2_DV_BT_DMT_640X480P72, 0x09, 0x00 },\n\t{ V4L2_DV_BT_DMT_640X480P75, 0x0a, 0x00 },\n\t{ V4L2_DV_BT_DMT_640X480P85, 0x0b, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P56, 0x00, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P60, 0x01, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P72, 0x02, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P75, 0x03, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P85, 0x04, 0x00 },\n\t{ V4L2_DV_BT_DMT_1024X768P60, 0x0c, 0x00 },\n\t{ V4L2_DV_BT_DMT_1024X768P70, 0x0d, 0x00 },\n\t{ V4L2_DV_BT_DMT_1024X768P75, 0x0e, 0x00 },\n\t{ V4L2_DV_BT_DMT_1024X768P85, 0x0f, 0x00 },\n\t{ V4L2_DV_BT_DMT_1280X1024P60, 0x05, 0x00 },\n\t{ V4L2_DV_BT_DMT_1280X1024P75, 0x06, 0x00 },\n\t{ },\n};\n\nstatic const struct v4l2_event adv76xx_ev_fmt = {\n\t.type = V4L2_EVENT_SOURCE_CHANGE,\n\t.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,\n};\n\n \n\nstatic inline struct adv76xx_state *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct adv76xx_state, sd);\n}\n\nstatic inline unsigned htotal(const struct v4l2_bt_timings *t)\n{\n\treturn V4L2_DV_BT_FRAME_WIDTH(t);\n}\n\nstatic inline unsigned vtotal(const struct v4l2_bt_timings *t)\n{\n\treturn V4L2_DV_BT_FRAME_HEIGHT(t);\n}\n\n \n\nstatic int adv76xx_read_check(struct adv76xx_state *state,\n\t\t\t     int client_page, u8 reg)\n{\n\tstruct i2c_client *client = state->i2c_clients[client_page];\n\tint err;\n\tunsigned int val;\n\n\terr = regmap_read(state->regmap[client_page], reg, &val);\n\n\tif (err) {\n\t\tv4l_err(client, \"error reading %02x, %02x\\n\",\n\t\t\t\tclient->addr, reg);\n\t\treturn err;\n\t}\n\treturn val;\n}\n\n \nstatic int adv76xx_write_block(struct adv76xx_state *state, int client_page,\n\t\t\t      unsigned int init_reg, const void *val,\n\t\t\t      size_t val_len)\n{\n\tstruct regmap *regmap = state->regmap[client_page];\n\n\tif (val_len > I2C_SMBUS_BLOCK_MAX)\n\t\tval_len = I2C_SMBUS_BLOCK_MAX;\n\n\treturn regmap_raw_write(regmap, init_reg, val, val_len);\n}\n\n \n\nstatic inline int io_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn adv76xx_read_check(state, ADV76XX_PAGE_IO, reg);\n}\n\nstatic inline int io_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn regmap_write(state->regmap[ADV76XX_PAGE_IO], reg, val);\n}\n\nstatic inline int io_write_clr_set(struct v4l2_subdev *sd, u8 reg, u8 mask,\n\t\t\t\t   u8 val)\n{\n\treturn io_write(sd, reg, (io_read(sd, reg) & ~mask) | val);\n}\n\nstatic inline int __always_unused avlink_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn adv76xx_read_check(state, ADV7604_PAGE_AVLINK, reg);\n}\n\nstatic inline int __always_unused avlink_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn regmap_write(state->regmap[ADV7604_PAGE_AVLINK], reg, val);\n}\n\nstatic inline int cec_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn adv76xx_read_check(state, ADV76XX_PAGE_CEC, reg);\n}\n\nstatic inline int cec_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn regmap_write(state->regmap[ADV76XX_PAGE_CEC], reg, val);\n}\n\nstatic inline int cec_write_clr_set(struct v4l2_subdev *sd, u8 reg, u8 mask,\n\t\t\t\t   u8 val)\n{\n\treturn cec_write(sd, reg, (cec_read(sd, reg) & ~mask) | val);\n}\n\nstatic inline int infoframe_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn adv76xx_read_check(state, ADV76XX_PAGE_INFOFRAME, reg);\n}\n\nstatic inline int __always_unused infoframe_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn regmap_write(state->regmap[ADV76XX_PAGE_INFOFRAME], reg, val);\n}\n\nstatic inline int __always_unused afe_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn adv76xx_read_check(state, ADV76XX_PAGE_AFE, reg);\n}\n\nstatic inline int afe_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn regmap_write(state->regmap[ADV76XX_PAGE_AFE], reg, val);\n}\n\nstatic inline int rep_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn adv76xx_read_check(state, ADV76XX_PAGE_REP, reg);\n}\n\nstatic inline int rep_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn regmap_write(state->regmap[ADV76XX_PAGE_REP], reg, val);\n}\n\nstatic inline int rep_write_clr_set(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\n{\n\treturn rep_write(sd, reg, (rep_read(sd, reg) & ~mask) | val);\n}\n\nstatic inline int __always_unused edid_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn adv76xx_read_check(state, ADV76XX_PAGE_EDID, reg);\n}\n\nstatic inline int __always_unused edid_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn regmap_write(state->regmap[ADV76XX_PAGE_EDID], reg, val);\n}\n\nstatic inline int edid_write_block(struct v4l2_subdev *sd,\n\t\t\t\t\tunsigned int total_len, const u8 *val)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tint err = 0;\n\tint i = 0;\n\tint len = 0;\n\n\tv4l2_dbg(2, debug, sd, \"%s: write EDID block (%d byte)\\n\",\n\t\t\t\t__func__, total_len);\n\n\twhile (!err && i < total_len) {\n\t\tlen = (total_len - i) > I2C_SMBUS_BLOCK_MAX ?\n\t\t\t\tI2C_SMBUS_BLOCK_MAX :\n\t\t\t\t(total_len - i);\n\n\t\terr = adv76xx_write_block(state, ADV76XX_PAGE_EDID,\n\t\t\t\ti, val + i, len);\n\t\ti += len;\n\t}\n\n\treturn err;\n}\n\nstatic void adv76xx_set_hpd(struct adv76xx_state *state, unsigned int hpd)\n{\n\tconst struct adv76xx_chip_info *info = state->info;\n\tunsigned int i;\n\n\tif (info->type == ADV7604) {\n\t\tfor (i = 0; i < state->info->num_dv_ports; ++i)\n\t\t\tgpiod_set_value_cansleep(state->hpd_gpio[i], hpd & BIT(i));\n\t} else {\n\t\tfor (i = 0; i < state->info->num_dv_ports; ++i)\n\t\t\tio_write_clr_set(&state->sd, 0x20, 0x80 >> i,\n\t\t\t\t\t (!!(hpd & BIT(i))) << (7 - i));\n\t}\n\n\tv4l2_subdev_notify(&state->sd, ADV76XX_HOTPLUG, &hpd);\n}\n\nstatic void adv76xx_delayed_work_enable_hotplug(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct adv76xx_state *state = container_of(dwork, struct adv76xx_state,\n\t\t\t\t\t\tdelayed_work_enable_hotplug);\n\tstruct v4l2_subdev *sd = &state->sd;\n\n\tv4l2_dbg(2, debug, sd, \"%s: enable hotplug\\n\", __func__);\n\n\tadv76xx_set_hpd(state, state->edid.present);\n}\n\nstatic inline int hdmi_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn adv76xx_read_check(state, ADV76XX_PAGE_HDMI, reg);\n}\n\nstatic u16 hdmi_read16(struct v4l2_subdev *sd, u8 reg, u16 mask)\n{\n\treturn ((hdmi_read(sd, reg) << 8) | hdmi_read(sd, reg + 1)) & mask;\n}\n\nstatic inline int hdmi_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn regmap_write(state->regmap[ADV76XX_PAGE_HDMI], reg, val);\n}\n\nstatic inline int hdmi_write_clr_set(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\n{\n\treturn hdmi_write(sd, reg, (hdmi_read(sd, reg) & ~mask) | val);\n}\n\nstatic inline int __always_unused test_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn regmap_write(state->regmap[ADV76XX_PAGE_TEST], reg, val);\n}\n\nstatic inline int cp_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn adv76xx_read_check(state, ADV76XX_PAGE_CP, reg);\n}\n\nstatic u16 cp_read16(struct v4l2_subdev *sd, u8 reg, u16 mask)\n{\n\treturn ((cp_read(sd, reg) << 8) | cp_read(sd, reg + 1)) & mask;\n}\n\nstatic inline int cp_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn regmap_write(state->regmap[ADV76XX_PAGE_CP], reg, val);\n}\n\nstatic inline int cp_write_clr_set(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\n{\n\treturn cp_write(sd, reg, (cp_read(sd, reg) & ~mask) | val);\n}\n\nstatic inline int __always_unused vdp_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn adv76xx_read_check(state, ADV7604_PAGE_VDP, reg);\n}\n\nstatic inline int __always_unused vdp_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn regmap_write(state->regmap[ADV7604_PAGE_VDP], reg, val);\n}\n\n#define ADV76XX_REG(page, offset)\t(((page) << 8) | (offset))\n#define ADV76XX_REG_SEQ_TERM\t\t0xffff\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int adv76xx_read_reg(struct v4l2_subdev *sd, unsigned int reg)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tunsigned int page = reg >> 8;\n\tunsigned int val;\n\tint err;\n\n\tif (page >= ADV76XX_PAGE_MAX || !(BIT(page) & state->info->page_mask))\n\t\treturn -EINVAL;\n\n\treg &= 0xff;\n\terr = regmap_read(state->regmap[page], reg, &val);\n\n\treturn err ? err : val;\n}\n#endif\n\nstatic int adv76xx_write_reg(struct v4l2_subdev *sd, unsigned int reg, u8 val)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tunsigned int page = reg >> 8;\n\n\tif (page >= ADV76XX_PAGE_MAX || !(BIT(page) & state->info->page_mask))\n\t\treturn -EINVAL;\n\n\treg &= 0xff;\n\n\treturn regmap_write(state->regmap[page], reg, val);\n}\n\nstatic void adv76xx_write_reg_seq(struct v4l2_subdev *sd,\n\t\t\t\t  const struct adv76xx_reg_seq *reg_seq)\n{\n\tunsigned int i;\n\n\tfor (i = 0; reg_seq[i].reg != ADV76XX_REG_SEQ_TERM; i++)\n\t\tadv76xx_write_reg(sd, reg_seq[i].reg, reg_seq[i].val);\n}\n\n \n\nstatic const struct adv76xx_format_info adv7604_formats[] = {\n\t{ MEDIA_BUS_FMT_RGB888_1X24, ADV76XX_OP_CH_SEL_RGB, true, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_444 | ADV76XX_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, ADV76XX_OP_CH_SEL_RGB, false, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_422 | ADV76XX_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, ADV76XX_OP_CH_SEL_RGB, false, true,\n\t  ADV76XX_OP_MODE_SEL_SDR_422 | ADV76XX_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_YUYV10_2X10, ADV76XX_OP_CH_SEL_RGB, false, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_422 | ADV7604_OP_FORMAT_SEL_10BIT },\n\t{ MEDIA_BUS_FMT_YVYU10_2X10, ADV76XX_OP_CH_SEL_RGB, false, true,\n\t  ADV76XX_OP_MODE_SEL_SDR_422 | ADV7604_OP_FORMAT_SEL_10BIT },\n\t{ MEDIA_BUS_FMT_YUYV12_2X12, ADV76XX_OP_CH_SEL_RGB, false, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_422 | ADV76XX_OP_FORMAT_SEL_12BIT },\n\t{ MEDIA_BUS_FMT_YVYU12_2X12, ADV76XX_OP_CH_SEL_RGB, false, true,\n\t  ADV76XX_OP_MODE_SEL_SDR_422 | ADV76XX_OP_FORMAT_SEL_12BIT },\n\t{ MEDIA_BUS_FMT_UYVY8_1X16, ADV76XX_OP_CH_SEL_RBG, false, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV76XX_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_VYUY8_1X16, ADV76XX_OP_CH_SEL_RBG, false, true,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV76XX_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_YUYV8_1X16, ADV76XX_OP_CH_SEL_RGB, false, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV76XX_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_YVYU8_1X16, ADV76XX_OP_CH_SEL_RGB, false, true,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV76XX_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_UYVY10_1X20, ADV76XX_OP_CH_SEL_RBG, false, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV7604_OP_FORMAT_SEL_10BIT },\n\t{ MEDIA_BUS_FMT_VYUY10_1X20, ADV76XX_OP_CH_SEL_RBG, false, true,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV7604_OP_FORMAT_SEL_10BIT },\n\t{ MEDIA_BUS_FMT_YUYV10_1X20, ADV76XX_OP_CH_SEL_RGB, false, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV7604_OP_FORMAT_SEL_10BIT },\n\t{ MEDIA_BUS_FMT_YVYU10_1X20, ADV76XX_OP_CH_SEL_RGB, false, true,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV7604_OP_FORMAT_SEL_10BIT },\n\t{ MEDIA_BUS_FMT_UYVY12_1X24, ADV76XX_OP_CH_SEL_RBG, false, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV76XX_OP_FORMAT_SEL_12BIT },\n\t{ MEDIA_BUS_FMT_VYUY12_1X24, ADV76XX_OP_CH_SEL_RBG, false, true,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV76XX_OP_FORMAT_SEL_12BIT },\n\t{ MEDIA_BUS_FMT_YUYV12_1X24, ADV76XX_OP_CH_SEL_RGB, false, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV76XX_OP_FORMAT_SEL_12BIT },\n\t{ MEDIA_BUS_FMT_YVYU12_1X24, ADV76XX_OP_CH_SEL_RGB, false, true,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV76XX_OP_FORMAT_SEL_12BIT },\n};\n\nstatic const struct adv76xx_format_info adv7611_formats[] = {\n\t{ MEDIA_BUS_FMT_RGB888_1X24, ADV76XX_OP_CH_SEL_RGB, true, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_444 | ADV76XX_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, ADV76XX_OP_CH_SEL_RGB, false, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_422 | ADV76XX_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, ADV76XX_OP_CH_SEL_RGB, false, true,\n\t  ADV76XX_OP_MODE_SEL_SDR_422 | ADV76XX_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_YUYV12_2X12, ADV76XX_OP_CH_SEL_RGB, false, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_422 | ADV76XX_OP_FORMAT_SEL_12BIT },\n\t{ MEDIA_BUS_FMT_YVYU12_2X12, ADV76XX_OP_CH_SEL_RGB, false, true,\n\t  ADV76XX_OP_MODE_SEL_SDR_422 | ADV76XX_OP_FORMAT_SEL_12BIT },\n\t{ MEDIA_BUS_FMT_UYVY8_1X16, ADV76XX_OP_CH_SEL_RBG, false, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV76XX_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_VYUY8_1X16, ADV76XX_OP_CH_SEL_RBG, false, true,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV76XX_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_YUYV8_1X16, ADV76XX_OP_CH_SEL_RGB, false, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV76XX_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_YVYU8_1X16, ADV76XX_OP_CH_SEL_RGB, false, true,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV76XX_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_UYVY12_1X24, ADV76XX_OP_CH_SEL_RBG, false, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV76XX_OP_FORMAT_SEL_12BIT },\n\t{ MEDIA_BUS_FMT_VYUY12_1X24, ADV76XX_OP_CH_SEL_RBG, false, true,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV76XX_OP_FORMAT_SEL_12BIT },\n\t{ MEDIA_BUS_FMT_YUYV12_1X24, ADV76XX_OP_CH_SEL_RGB, false, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV76XX_OP_FORMAT_SEL_12BIT },\n\t{ MEDIA_BUS_FMT_YVYU12_1X24, ADV76XX_OP_CH_SEL_RGB, false, true,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV76XX_OP_FORMAT_SEL_12BIT },\n};\n\nstatic const struct adv76xx_format_info adv7612_formats[] = {\n\t{ MEDIA_BUS_FMT_RGB888_1X24, ADV76XX_OP_CH_SEL_RGB, true, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_444 | ADV76XX_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, ADV76XX_OP_CH_SEL_RGB, false, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_422 | ADV76XX_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, ADV76XX_OP_CH_SEL_RGB, false, true,\n\t  ADV76XX_OP_MODE_SEL_SDR_422 | ADV76XX_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_UYVY8_1X16, ADV76XX_OP_CH_SEL_RBG, false, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV76XX_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_VYUY8_1X16, ADV76XX_OP_CH_SEL_RBG, false, true,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV76XX_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_YUYV8_1X16, ADV76XX_OP_CH_SEL_RGB, false, false,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV76XX_OP_FORMAT_SEL_8BIT },\n\t{ MEDIA_BUS_FMT_YVYU8_1X16, ADV76XX_OP_CH_SEL_RGB, false, true,\n\t  ADV76XX_OP_MODE_SEL_SDR_422_2X | ADV76XX_OP_FORMAT_SEL_8BIT },\n};\n\nstatic const struct adv76xx_format_info *\nadv76xx_format_info(struct adv76xx_state *state, u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < state->info->nformats; ++i) {\n\t\tif (state->info->formats[i].code == code)\n\t\t\treturn &state->info->formats[i];\n\t}\n\n\treturn NULL;\n}\n\n \n\nstatic inline bool is_analog_input(struct v4l2_subdev *sd)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn state->selected_input == ADV7604_PAD_VGA_RGB ||\n\t       state->selected_input == ADV7604_PAD_VGA_COMP;\n}\n\nstatic inline bool is_digital_input(struct v4l2_subdev *sd)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn state->selected_input == ADV76XX_PAD_HDMI_PORT_A ||\n\t       state->selected_input == ADV7604_PAD_HDMI_PORT_B ||\n\t       state->selected_input == ADV7604_PAD_HDMI_PORT_C ||\n\t       state->selected_input == ADV7604_PAD_HDMI_PORT_D;\n}\n\nstatic const struct v4l2_dv_timings_cap adv7604_timings_cap_analog = {\n\t.type = V4L2_DV_BT_656_1120,\n\t \n\t.reserved = { 0 },\n\tV4L2_INIT_BT_TIMINGS(640, 1920, 350, 1200, 25000000, 170000000,\n\t\tV4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_DMT |\n\t\t\tV4L2_DV_BT_STD_GTF | V4L2_DV_BT_STD_CVT,\n\t\tV4L2_DV_BT_CAP_PROGRESSIVE | V4L2_DV_BT_CAP_REDUCED_BLANKING |\n\t\t\tV4L2_DV_BT_CAP_CUSTOM)\n};\n\nstatic const struct v4l2_dv_timings_cap adv76xx_timings_cap_digital = {\n\t.type = V4L2_DV_BT_656_1120,\n\t \n\t.reserved = { 0 },\n\tV4L2_INIT_BT_TIMINGS(640, 1920, 350, 1200, 25000000, 225000000,\n\t\tV4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_DMT |\n\t\t\tV4L2_DV_BT_STD_GTF | V4L2_DV_BT_STD_CVT,\n\t\tV4L2_DV_BT_CAP_PROGRESSIVE | V4L2_DV_BT_CAP_REDUCED_BLANKING |\n\t\t\tV4L2_DV_BT_CAP_CUSTOM)\n};\n\n \nstatic const struct v4l2_dv_timings_cap *\nadv76xx_get_dv_timings_cap(struct v4l2_subdev *sd, int pad)\n{\n\tif (pad == -1) {\n\t\tstruct adv76xx_state *state = to_state(sd);\n\n\t\tpad = state->selected_input;\n\t}\n\n\tswitch (pad) {\n\tcase ADV76XX_PAD_HDMI_PORT_A:\n\tcase ADV7604_PAD_HDMI_PORT_B:\n\tcase ADV7604_PAD_HDMI_PORT_C:\n\tcase ADV7604_PAD_HDMI_PORT_D:\n\t\treturn &adv76xx_timings_cap_digital;\n\n\tcase ADV7604_PAD_VGA_RGB:\n\tcase ADV7604_PAD_VGA_COMP:\n\tdefault:\n\t\treturn &adv7604_timings_cap_analog;\n\t}\n}\n\n\n \n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic void adv76xx_inv_register(struct v4l2_subdev *sd)\n{\n\tv4l2_info(sd, \"0x000-0x0ff: IO Map\\n\");\n\tv4l2_info(sd, \"0x100-0x1ff: AVLink Map\\n\");\n\tv4l2_info(sd, \"0x200-0x2ff: CEC Map\\n\");\n\tv4l2_info(sd, \"0x300-0x3ff: InfoFrame Map\\n\");\n\tv4l2_info(sd, \"0x400-0x4ff: ESDP Map\\n\");\n\tv4l2_info(sd, \"0x500-0x5ff: DPP Map\\n\");\n\tv4l2_info(sd, \"0x600-0x6ff: AFE Map\\n\");\n\tv4l2_info(sd, \"0x700-0x7ff: Repeater Map\\n\");\n\tv4l2_info(sd, \"0x800-0x8ff: EDID Map\\n\");\n\tv4l2_info(sd, \"0x900-0x9ff: HDMI Map\\n\");\n\tv4l2_info(sd, \"0xa00-0xaff: Test Map\\n\");\n\tv4l2_info(sd, \"0xb00-0xbff: CP Map\\n\");\n\tv4l2_info(sd, \"0xc00-0xcff: VDP Map\\n\");\n}\n\nstatic int adv76xx_g_register(struct v4l2_subdev *sd,\n\t\t\t\t\tstruct v4l2_dbg_register *reg)\n{\n\tint ret;\n\n\tret = adv76xx_read_reg(sd, reg->reg);\n\tif (ret < 0) {\n\t\tv4l2_info(sd, \"Register %03llx not supported\\n\", reg->reg);\n\t\tadv76xx_inv_register(sd);\n\t\treturn ret;\n\t}\n\n\treg->size = 1;\n\treg->val = ret;\n\n\treturn 0;\n}\n\nstatic int adv76xx_s_register(struct v4l2_subdev *sd,\n\t\t\t\t\tconst struct v4l2_dbg_register *reg)\n{\n\tint ret;\n\n\tret = adv76xx_write_reg(sd, reg->reg, reg->val);\n\tif (ret < 0) {\n\t\tv4l2_info(sd, \"Register %03llx not supported\\n\", reg->reg);\n\t\tadv76xx_inv_register(sd);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic unsigned int adv7604_read_cable_det(struct v4l2_subdev *sd)\n{\n\tu8 value = io_read(sd, 0x6f);\n\n\treturn ((value & 0x10) >> 4)\n\t     | ((value & 0x08) >> 2)\n\t     | ((value & 0x04) << 0)\n\t     | ((value & 0x02) << 2);\n}\n\nstatic unsigned int adv7611_read_cable_det(struct v4l2_subdev *sd)\n{\n\tu8 value = io_read(sd, 0x6f);\n\n\treturn value & 1;\n}\n\nstatic unsigned int adv7612_read_cable_det(struct v4l2_subdev *sd)\n{\n\t \n\tu8 value = io_read(sd, 0x6f);\n\n\treturn value & 1;\n}\n\nstatic int adv76xx_s_detect_tx_5v_ctrl(struct v4l2_subdev *sd)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tconst struct adv76xx_chip_info *info = state->info;\n\tu16 cable_det = info->read_cable_det(sd);\n\n\treturn v4l2_ctrl_s_ctrl(state->detect_tx_5v_ctrl, cable_det);\n}\n\nstatic int find_and_set_predefined_video_timings(struct v4l2_subdev *sd,\n\t\tu8 prim_mode,\n\t\tconst struct adv76xx_video_standards *predef_vid_timings,\n\t\tconst struct v4l2_dv_timings *timings)\n{\n\tint i;\n\n\tfor (i = 0; predef_vid_timings[i].timings.bt.width; i++) {\n\t\tif (!v4l2_match_dv_timings(timings, &predef_vid_timings[i].timings,\n\t\t\t\tis_digital_input(sd) ? 250000 : 1000000, false))\n\t\t\tcontinue;\n\t\tio_write(sd, 0x00, predef_vid_timings[i].vid_std);  \n\t\tio_write(sd, 0x01, (predef_vid_timings[i].v_freq << 4) +\n\t\t\t\tprim_mode);  \n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nstatic int configure_predefined_video_timings(struct v4l2_subdev *sd,\n\t\tstruct v4l2_dv_timings *timings)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tint err;\n\n\tv4l2_dbg(1, debug, sd, \"%s\", __func__);\n\n\tif (adv76xx_has_afe(state)) {\n\t\t \n\t\tio_write(sd, 0x16, 0x43);\n\t\tio_write(sd, 0x17, 0x5a);\n\t}\n\t \n\tcp_write_clr_set(sd, 0x81, 0x10, 0x00);\n\tcp_write(sd, 0x8f, 0x00);\n\tcp_write(sd, 0x90, 0x00);\n\tcp_write(sd, 0xa2, 0x00);\n\tcp_write(sd, 0xa3, 0x00);\n\tcp_write(sd, 0xa4, 0x00);\n\tcp_write(sd, 0xa5, 0x00);\n\tcp_write(sd, 0xa6, 0x00);\n\tcp_write(sd, 0xa7, 0x00);\n\tcp_write(sd, 0xab, 0x00);\n\tcp_write(sd, 0xac, 0x00);\n\n\tif (is_analog_input(sd)) {\n\t\terr = find_and_set_predefined_video_timings(sd,\n\t\t\t\t0x01, adv7604_prim_mode_comp, timings);\n\t\tif (err)\n\t\t\terr = find_and_set_predefined_video_timings(sd,\n\t\t\t\t\t0x02, adv7604_prim_mode_gr, timings);\n\t} else if (is_digital_input(sd)) {\n\t\terr = find_and_set_predefined_video_timings(sd,\n\t\t\t\t0x05, adv76xx_prim_mode_hdmi_comp, timings);\n\t\tif (err)\n\t\t\terr = find_and_set_predefined_video_timings(sd,\n\t\t\t\t\t0x06, adv76xx_prim_mode_hdmi_gr, timings);\n\t} else {\n\t\tv4l2_dbg(2, debug, sd, \"%s: Unknown port %d selected\\n\",\n\t\t\t\t__func__, state->selected_input);\n\t\terr = -1;\n\t}\n\n\n\treturn err;\n}\n\nstatic void configure_custom_video_timings(struct v4l2_subdev *sd,\n\t\tconst struct v4l2_bt_timings *bt)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tu32 width = htotal(bt);\n\tu32 height = vtotal(bt);\n\tu16 cp_start_sav = bt->hsync + bt->hbackporch - 4;\n\tu16 cp_start_eav = width - bt->hfrontporch;\n\tu16 cp_start_vbi = height - bt->vfrontporch;\n\tu16 cp_end_vbi = bt->vsync + bt->vbackporch;\n\tu16 ch1_fr_ll = (((u32)bt->pixelclock / 100) > 0) ?\n\t\t((width * (ADV76XX_FSC / 100)) / ((u32)bt->pixelclock / 100)) : 0;\n\tconst u8 pll[2] = {\n\t\t0xc0 | ((width >> 8) & 0x1f),\n\t\twidth & 0xff\n\t};\n\n\tv4l2_dbg(2, debug, sd, \"%s\\n\", __func__);\n\n\tif (is_analog_input(sd)) {\n\t\t \n\t\tio_write(sd, 0x00, 0x07);  \n\t\tio_write(sd, 0x01, 0x02);  \n\t\t \n\t\tcp_write_clr_set(sd, 0x81, 0x10, 0x10);\n\n\t\t \n\t\t \n\t\t \n\t\tif (regmap_raw_write(state->regmap[ADV76XX_PAGE_IO],\n\t\t\t\t\t0x16, pll, 2))\n\t\t\tv4l2_err(sd, \"writing to reg 0x16 and 0x17 failed\\n\");\n\n\t\t \n\t\tcp_write(sd, 0xa2, (cp_start_sav >> 4) & 0xff);\n\t\tcp_write(sd, 0xa3, ((cp_start_sav & 0x0f) << 4) |\n\t\t\t\t   ((cp_start_eav >> 8) & 0x0f));\n\t\tcp_write(sd, 0xa4, cp_start_eav & 0xff);\n\n\t\t \n\t\tcp_write(sd, 0xa5, (cp_start_vbi >> 4) & 0xff);\n\t\tcp_write(sd, 0xa6, ((cp_start_vbi & 0xf) << 4) |\n\t\t\t\t   ((cp_end_vbi >> 8) & 0xf));\n\t\tcp_write(sd, 0xa7, cp_end_vbi & 0xff);\n\t} else if (is_digital_input(sd)) {\n\t\t \n\t\tio_write(sd, 0x00, 0x02);  \n\t\tio_write(sd, 0x01, 0x06);  \n\t} else {\n\t\tv4l2_dbg(2, debug, sd, \"%s: Unknown port %d selected\\n\",\n\t\t\t\t__func__, state->selected_input);\n\t}\n\n\tcp_write(sd, 0x8f, (ch1_fr_ll >> 8) & 0x7);\n\tcp_write(sd, 0x90, ch1_fr_ll & 0xff);\n\tcp_write(sd, 0xab, (height >> 4) & 0xff);\n\tcp_write(sd, 0xac, (height & 0x0f) << 4);\n}\n\nstatic void adv76xx_set_offset(struct v4l2_subdev *sd, bool auto_offset, u16 offset_a, u16 offset_b, u16 offset_c)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tu8 offset_buf[4];\n\n\tif (auto_offset) {\n\t\toffset_a = 0x3ff;\n\t\toffset_b = 0x3ff;\n\t\toffset_c = 0x3ff;\n\t}\n\n\tv4l2_dbg(2, debug, sd, \"%s: %s offset: a = 0x%x, b = 0x%x, c = 0x%x\\n\",\n\t\t\t__func__, auto_offset ? \"Auto\" : \"Manual\",\n\t\t\toffset_a, offset_b, offset_c);\n\n\toffset_buf[0] = (cp_read(sd, 0x77) & 0xc0) | ((offset_a & 0x3f0) >> 4);\n\toffset_buf[1] = ((offset_a & 0x00f) << 4) | ((offset_b & 0x3c0) >> 6);\n\toffset_buf[2] = ((offset_b & 0x03f) << 2) | ((offset_c & 0x300) >> 8);\n\toffset_buf[3] = offset_c & 0x0ff;\n\n\t \n\tif (regmap_raw_write(state->regmap[ADV76XX_PAGE_CP],\n\t\t\t0x77, offset_buf, 4))\n\t\tv4l2_err(sd, \"%s: i2c error writing to CP reg 0x77, 0x78, 0x79, 0x7a\\n\", __func__);\n}\n\nstatic void adv76xx_set_gain(struct v4l2_subdev *sd, bool auto_gain, u16 gain_a, u16 gain_b, u16 gain_c)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tu8 gain_buf[4];\n\tu8 gain_man = 1;\n\tu8 agc_mode_man = 1;\n\n\tif (auto_gain) {\n\t\tgain_man = 0;\n\t\tagc_mode_man = 0;\n\t\tgain_a = 0x100;\n\t\tgain_b = 0x100;\n\t\tgain_c = 0x100;\n\t}\n\n\tv4l2_dbg(2, debug, sd, \"%s: %s gain: a = 0x%x, b = 0x%x, c = 0x%x\\n\",\n\t\t\t__func__, auto_gain ? \"Auto\" : \"Manual\",\n\t\t\tgain_a, gain_b, gain_c);\n\n\tgain_buf[0] = ((gain_man << 7) | (agc_mode_man << 6) | ((gain_a & 0x3f0) >> 4));\n\tgain_buf[1] = (((gain_a & 0x00f) << 4) | ((gain_b & 0x3c0) >> 6));\n\tgain_buf[2] = (((gain_b & 0x03f) << 2) | ((gain_c & 0x300) >> 8));\n\tgain_buf[3] = ((gain_c & 0x0ff));\n\n\t \n\tif (regmap_raw_write(state->regmap[ADV76XX_PAGE_CP],\n\t\t\t     0x73, gain_buf, 4))\n\t\tv4l2_err(sd, \"%s: i2c error writing to CP reg 0x73, 0x74, 0x75, 0x76\\n\", __func__);\n}\n\nstatic void set_rgb_quantization_range(struct v4l2_subdev *sd)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tbool rgb_output = io_read(sd, 0x02) & 0x02;\n\tbool hdmi_signal = hdmi_read(sd, 0x05) & 0x80;\n\tu8 y = HDMI_COLORSPACE_RGB;\n\n\tif (hdmi_signal && (io_read(sd, 0x60) & 1))\n\t\ty = infoframe_read(sd, 0x01) >> 5;\n\n\tv4l2_dbg(2, debug, sd, \"%s: RGB quantization range: %d, RGB out: %d, HDMI: %d\\n\",\n\t\t\t__func__, state->rgb_quantization_range,\n\t\t\trgb_output, hdmi_signal);\n\n\tadv76xx_set_gain(sd, true, 0x0, 0x0, 0x0);\n\tadv76xx_set_offset(sd, true, 0x0, 0x0, 0x0);\n\tio_write_clr_set(sd, 0x02, 0x04, rgb_output ? 0 : 4);\n\n\tswitch (state->rgb_quantization_range) {\n\tcase V4L2_DV_RGB_RANGE_AUTO:\n\t\tif (state->selected_input == ADV7604_PAD_VGA_RGB) {\n\t\t\t \n\t\t\tio_write_clr_set(sd, 0x02, 0xf0, 0x10);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->selected_input == ADV7604_PAD_VGA_COMP) {\n\t\t\t \n\t\t\tio_write_clr_set(sd, 0x02, 0xf0, 0xf0);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hdmi_signal) {\n\t\t\t \n\t\t\tio_write_clr_set(sd, 0x02, 0xf0, 0xf0);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (state->timings.bt.flags & V4L2_DV_FL_IS_CE_VIDEO) {\n\t\t\t \n\t\t\tio_write_clr_set(sd, 0x02, 0xf0, 0x00);\n\t\t} else {\n\t\t\t \n\t\t\tio_write_clr_set(sd, 0x02, 0xf0, 0x10);\n\n\t\t\tif (is_digital_input(sd) && rgb_output) {\n\t\t\t\tadv76xx_set_offset(sd, false, 0x40, 0x40, 0x40);\n\t\t\t} else {\n\t\t\t\tadv76xx_set_gain(sd, false, 0xe0, 0xe0, 0xe0);\n\t\t\t\tadv76xx_set_offset(sd, false, 0x70, 0x70, 0x70);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase V4L2_DV_RGB_RANGE_LIMITED:\n\t\tif (state->selected_input == ADV7604_PAD_VGA_COMP) {\n\t\t\t \n\t\t\tio_write_clr_set(sd, 0x02, 0xf0, 0x20);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (y != HDMI_COLORSPACE_RGB)\n\t\t\tbreak;\n\n\t\t \n\t\tio_write_clr_set(sd, 0x02, 0xf0, 0x00);\n\n\t\tbreak;\n\tcase V4L2_DV_RGB_RANGE_FULL:\n\t\tif (state->selected_input == ADV7604_PAD_VGA_COMP) {\n\t\t\t \n\t\t\tio_write_clr_set(sd, 0x02, 0xf0, 0x60);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (y != HDMI_COLORSPACE_RGB)\n\t\t\tbreak;\n\n\t\t \n\t\tio_write_clr_set(sd, 0x02, 0xf0, 0x10);\n\n\t\tif (is_analog_input(sd) || hdmi_signal)\n\t\t\tbreak;\n\n\t\t \n\t\tif (rgb_output) {\n\t\t\tadv76xx_set_offset(sd, false, 0x40, 0x40, 0x40);\n\t\t} else {\n\t\t\tadv76xx_set_gain(sd, false, 0xe0, 0xe0, 0xe0);\n\t\t\tadv76xx_set_offset(sd, false, 0x70, 0x70, 0x70);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int adv76xx_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd =\n\t\t&container_of(ctrl->handler, struct adv76xx_state, hdl)->sd;\n\n\tstruct adv76xx_state *state = to_state(sd);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tcp_write(sd, 0x3c, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_CONTRAST:\n\t\tcp_write(sd, 0x3a, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_SATURATION:\n\t\tcp_write(sd, 0x3b, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_HUE:\n\t\tcp_write(sd, 0x3d, ctrl->val);\n\t\treturn 0;\n\tcase  V4L2_CID_DV_RX_RGB_RANGE:\n\t\tstate->rgb_quantization_range = ctrl->val;\n\t\tset_rgb_quantization_range(sd);\n\t\treturn 0;\n\tcase V4L2_CID_ADV_RX_ANALOG_SAMPLING_PHASE:\n\t\tif (!adv76xx_has_afe(state))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tafe_write(sd, 0xc8, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_ADV_RX_FREE_RUN_COLOR_MANUAL:\n\t\t \n\t\tcp_write_clr_set(sd, 0xbf, 0x04, ctrl->val << 2);\n\t\treturn 0;\n\tcase V4L2_CID_ADV_RX_FREE_RUN_COLOR:\n\t\tcp_write(sd, 0xc0, (ctrl->val & 0xff0000) >> 16);\n\t\tcp_write(sd, 0xc1, (ctrl->val & 0x00ff00) >> 8);\n\t\tcp_write(sd, 0xc2, (u8)(ctrl->val & 0x0000ff));\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int adv76xx_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd =\n\t\t&container_of(ctrl->handler, struct adv76xx_state, hdl)->sd;\n\n\tif (ctrl->id == V4L2_CID_DV_RX_IT_CONTENT_TYPE) {\n\t\tctrl->val = V4L2_DV_IT_CONTENT_TYPE_NO_ITC;\n\t\tif ((io_read(sd, 0x60) & 1) && (infoframe_read(sd, 0x03) & 0x80))\n\t\t\tctrl->val = (infoframe_read(sd, 0x05) >> 4) & 3;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n \n\nstatic inline bool no_power(struct v4l2_subdev *sd)\n{\n\t \n\treturn io_read(sd, 0x0c) & 0x24;\n}\n\nstatic inline bool no_signal_tmds(struct v4l2_subdev *sd)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\treturn !(io_read(sd, 0x6a) & (0x10 >> state->selected_input));\n}\n\nstatic inline bool no_lock_tmds(struct v4l2_subdev *sd)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tconst struct adv76xx_chip_info *info = state->info;\n\n\treturn (io_read(sd, 0x6a) & info->tdms_lock_mask) != info->tdms_lock_mask;\n}\n\nstatic inline bool is_hdmi(struct v4l2_subdev *sd)\n{\n\treturn hdmi_read(sd, 0x05) & 0x80;\n}\n\nstatic inline bool no_lock_sspd(struct v4l2_subdev *sd)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\t \n\tif (adv76xx_has_afe(state))\n\t\treturn false;\n\n\t \n\treturn ((cp_read(sd, 0xb5) & 0xd0) != 0xd0);\n}\n\nstatic inline bool no_lock_stdi(struct v4l2_subdev *sd)\n{\n\t \n\treturn !(cp_read(sd, 0xb1) & 0x80);\n}\n\nstatic inline bool no_signal(struct v4l2_subdev *sd)\n{\n\tbool ret;\n\n\tret = no_power(sd);\n\n\tret |= no_lock_stdi(sd);\n\tret |= no_lock_sspd(sd);\n\n\tif (is_digital_input(sd)) {\n\t\tret |= no_lock_tmds(sd);\n\t\tret |= no_signal_tmds(sd);\n\t}\n\n\treturn ret;\n}\n\nstatic inline bool no_lock_cp(struct v4l2_subdev *sd)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\tif (!adv76xx_has_afe(state))\n\t\treturn false;\n\n\t \n\treturn io_read(sd, 0x12) & 0x01;\n}\n\nstatic inline bool in_free_run(struct v4l2_subdev *sd)\n{\n\treturn cp_read(sd, 0xff) & 0x10;\n}\n\nstatic int adv76xx_g_input_status(struct v4l2_subdev *sd, u32 *status)\n{\n\t*status = 0;\n\t*status |= no_power(sd) ? V4L2_IN_ST_NO_POWER : 0;\n\t*status |= no_signal(sd) ? V4L2_IN_ST_NO_SIGNAL : 0;\n\tif (!in_free_run(sd) && no_lock_cp(sd))\n\t\t*status |= is_digital_input(sd) ?\n\t\t\t   V4L2_IN_ST_NO_SYNC : V4L2_IN_ST_NO_H_LOCK;\n\n\tv4l2_dbg(1, debug, sd, \"%s: status = 0x%x\\n\", __func__, *status);\n\n\treturn 0;\n}\n\n \n\nstruct stdi_readback {\n\tu16 bl, lcf, lcvs;\n\tu8 hs_pol, vs_pol;\n\tbool interlaced;\n};\n\nstatic int stdi2dv_timings(struct v4l2_subdev *sd,\n\t\tstruct stdi_readback *stdi,\n\t\tstruct v4l2_dv_timings *timings)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tu32 hfreq = (ADV76XX_FSC * 8) / stdi->bl;\n\tu32 pix_clk;\n\tint i;\n\n\tfor (i = 0; v4l2_dv_timings_presets[i].bt.width; i++) {\n\t\tconst struct v4l2_bt_timings *bt = &v4l2_dv_timings_presets[i].bt;\n\n\t\tif (!v4l2_valid_dv_timings(&v4l2_dv_timings_presets[i],\n\t\t\t\t\t   adv76xx_get_dv_timings_cap(sd, -1),\n\t\t\t\t\t   adv76xx_check_dv_timings, NULL))\n\t\t\tcontinue;\n\t\tif (vtotal(bt) != stdi->lcf + 1)\n\t\t\tcontinue;\n\t\tif (bt->vsync != stdi->lcvs)\n\t\t\tcontinue;\n\n\t\tpix_clk = hfreq * htotal(bt);\n\n\t\tif ((pix_clk < bt->pixelclock + 1000000) &&\n\t\t    (pix_clk > bt->pixelclock - 1000000)) {\n\t\t\t*timings = v4l2_dv_timings_presets[i];\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (v4l2_detect_cvt(stdi->lcf + 1, hfreq, stdi->lcvs, 0,\n\t\t\t(stdi->hs_pol == '+' ? V4L2_DV_HSYNC_POS_POL : 0) |\n\t\t\t(stdi->vs_pol == '+' ? V4L2_DV_VSYNC_POS_POL : 0),\n\t\t\tfalse, timings))\n\t\treturn 0;\n\tif (v4l2_detect_gtf(stdi->lcf + 1, hfreq, stdi->lcvs,\n\t\t\t(stdi->hs_pol == '+' ? V4L2_DV_HSYNC_POS_POL : 0) |\n\t\t\t(stdi->vs_pol == '+' ? V4L2_DV_VSYNC_POS_POL : 0),\n\t\t\tfalse, state->aspect_ratio, timings))\n\t\treturn 0;\n\n\tv4l2_dbg(2, debug, sd,\n\t\t\"%s: No format candidate found for lcvs = %d, lcf=%d, bl = %d, %chsync, %cvsync\\n\",\n\t\t__func__, stdi->lcvs, stdi->lcf, stdi->bl,\n\t\tstdi->hs_pol, stdi->vs_pol);\n\treturn -1;\n}\n\n\nstatic int read_stdi(struct v4l2_subdev *sd, struct stdi_readback *stdi)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tconst struct adv76xx_chip_info *info = state->info;\n\tu8 polarity;\n\n\tif (no_lock_stdi(sd) || no_lock_sspd(sd)) {\n\t\tv4l2_dbg(2, debug, sd, \"%s: STDI and/or SSPD not locked\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\t \n\tstdi->bl = cp_read16(sd, 0xb1, 0x3fff);\n\tstdi->lcf = cp_read16(sd, info->lcf_reg, 0x7ff);\n\tstdi->lcvs = cp_read(sd, 0xb3) >> 3;\n\tstdi->interlaced = io_read(sd, 0x12) & 0x10;\n\n\tif (adv76xx_has_afe(state)) {\n\t\t \n\t\tpolarity = cp_read(sd, 0xb5);\n\t\tif ((polarity & 0x03) == 0x01) {\n\t\t\tstdi->hs_pol = polarity & 0x10\n\t\t\t\t     ? (polarity & 0x08 ? '+' : '-') : 'x';\n\t\t\tstdi->vs_pol = polarity & 0x40\n\t\t\t\t     ? (polarity & 0x20 ? '+' : '-') : 'x';\n\t\t} else {\n\t\t\tstdi->hs_pol = 'x';\n\t\t\tstdi->vs_pol = 'x';\n\t\t}\n\t} else {\n\t\tpolarity = hdmi_read(sd, 0x05);\n\t\tstdi->hs_pol = polarity & 0x20 ? '+' : '-';\n\t\tstdi->vs_pol = polarity & 0x10 ? '+' : '-';\n\t}\n\n\tif (no_lock_stdi(sd) || no_lock_sspd(sd)) {\n\t\tv4l2_dbg(2, debug, sd,\n\t\t\t\"%s: signal lost during readout of STDI/SSPD\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tif (stdi->lcf < 239 || stdi->bl < 8 || stdi->bl == 0x3fff) {\n\t\tv4l2_dbg(2, debug, sd, \"%s: invalid signal\\n\", __func__);\n\t\tmemset(stdi, 0, sizeof(struct stdi_readback));\n\t\treturn -1;\n\t}\n\n\tv4l2_dbg(2, debug, sd,\n\t\t\"%s: lcf (frame height - 1) = %d, bl = %d, lcvs (vsync) = %d, %chsync, %cvsync, %s\\n\",\n\t\t__func__, stdi->lcf, stdi->bl, stdi->lcvs,\n\t\tstdi->hs_pol, stdi->vs_pol,\n\t\tstdi->interlaced ? \"interlaced\" : \"progressive\");\n\n\treturn 0;\n}\n\nstatic int adv76xx_enum_dv_timings(struct v4l2_subdev *sd,\n\t\t\tstruct v4l2_enum_dv_timings *timings)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\tif (timings->pad >= state->source_pad)\n\t\treturn -EINVAL;\n\n\treturn v4l2_enum_dv_timings_cap(timings,\n\t\tadv76xx_get_dv_timings_cap(sd, timings->pad),\n\t\tadv76xx_check_dv_timings, NULL);\n}\n\nstatic int adv76xx_dv_timings_cap(struct v4l2_subdev *sd,\n\t\t\tstruct v4l2_dv_timings_cap *cap)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tunsigned int pad = cap->pad;\n\n\tif (cap->pad >= state->source_pad)\n\t\treturn -EINVAL;\n\n\t*cap = *adv76xx_get_dv_timings_cap(sd, pad);\n\tcap->pad = pad;\n\n\treturn 0;\n}\n\n \nstatic void adv76xx_fill_optional_dv_timings_fields(struct v4l2_subdev *sd,\n\t\tstruct v4l2_dv_timings *timings)\n{\n\tv4l2_find_dv_timings_cap(timings, adv76xx_get_dv_timings_cap(sd, -1),\n\t\t\t\t is_digital_input(sd) ? 250000 : 1000000,\n\t\t\t\t adv76xx_check_dv_timings, NULL);\n}\n\nstatic unsigned int adv7604_read_hdmi_pixelclock(struct v4l2_subdev *sd)\n{\n\tint a, b;\n\n\ta = hdmi_read(sd, 0x06);\n\tb = hdmi_read(sd, 0x3b);\n\tif (a < 0 || b < 0)\n\t\treturn 0;\n\n\treturn a * 1000000 + ((b & 0x30) >> 4) * 250000;\n}\n\nstatic unsigned int adv7611_read_hdmi_pixelclock(struct v4l2_subdev *sd)\n{\n\tint a, b;\n\n\ta = hdmi_read(sd, 0x51);\n\tb = hdmi_read(sd, 0x52);\n\tif (a < 0 || b < 0)\n\t\treturn 0;\n\n\treturn ((a << 1) | (b >> 7)) * 1000000 + (b & 0x7f) * 1000000 / 128;\n}\n\nstatic unsigned int adv76xx_read_hdmi_pixelclock(struct v4l2_subdev *sd)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tconst struct adv76xx_chip_info *info = state->info;\n\tunsigned int freq, bits_per_channel, pixelrepetition;\n\n\tfreq = info->read_hdmi_pixelclock(sd);\n\tif (is_hdmi(sd)) {\n\t\t \n\t\tbits_per_channel = ((hdmi_read(sd, 0x0b) & 0x60) >> 4) + 8;\n\t\tpixelrepetition = (hdmi_read(sd, 0x05) & 0x0f) + 1;\n\n\t\tfreq = freq * 8 / bits_per_channel / pixelrepetition;\n\t}\n\n\treturn freq;\n}\n\nstatic int adv76xx_query_dv_timings(struct v4l2_subdev *sd,\n\t\t\tstruct v4l2_dv_timings *timings)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tconst struct adv76xx_chip_info *info = state->info;\n\tstruct v4l2_bt_timings *bt = &timings->bt;\n\tstruct stdi_readback stdi;\n\n\tif (!timings)\n\t\treturn -EINVAL;\n\n\tmemset(timings, 0, sizeof(struct v4l2_dv_timings));\n\n\tif (no_signal(sd)) {\n\t\tstate->restart_stdi_once = true;\n\t\tv4l2_dbg(1, debug, sd, \"%s: no valid signal\\n\", __func__);\n\t\treturn -ENOLINK;\n\t}\n\n\t \n\tif (read_stdi(sd, &stdi)) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: STDI/SSPD not locked\\n\", __func__);\n\t\treturn -ENOLINK;\n\t}\n\tbt->interlaced = stdi.interlaced ?\n\t\tV4L2_DV_INTERLACED : V4L2_DV_PROGRESSIVE;\n\n\tif (is_digital_input(sd)) {\n\t\tbool hdmi_signal = hdmi_read(sd, 0x05) & 0x80;\n\t\tu8 vic = 0;\n\t\tu32 w, h;\n\n\t\tw = hdmi_read16(sd, 0x07, info->linewidth_mask);\n\t\th = hdmi_read16(sd, 0x09, info->field0_height_mask);\n\n\t\tif (hdmi_signal && (io_read(sd, 0x60) & 1))\n\t\t\tvic = infoframe_read(sd, 0x04);\n\n\t\tif (vic && v4l2_find_dv_timings_cea861_vic(timings, vic) &&\n\t\t    bt->width == w && bt->height == h)\n\t\t\tgoto found;\n\n\t\ttimings->type = V4L2_DV_BT_656_1120;\n\n\t\tbt->width = w;\n\t\tbt->height = h;\n\t\tbt->pixelclock = adv76xx_read_hdmi_pixelclock(sd);\n\t\tbt->hfrontporch = hdmi_read16(sd, 0x20, info->hfrontporch_mask);\n\t\tbt->hsync = hdmi_read16(sd, 0x22, info->hsync_mask);\n\t\tbt->hbackporch = hdmi_read16(sd, 0x24, info->hbackporch_mask);\n\t\tbt->vfrontporch = hdmi_read16(sd, 0x2a,\n\t\t\tinfo->field0_vfrontporch_mask) / 2;\n\t\tbt->vsync = hdmi_read16(sd, 0x2e, info->field0_vsync_mask) / 2;\n\t\tbt->vbackporch = hdmi_read16(sd, 0x32,\n\t\t\tinfo->field0_vbackporch_mask) / 2;\n\t\tbt->polarities = ((hdmi_read(sd, 0x05) & 0x10) ? V4L2_DV_VSYNC_POS_POL : 0) |\n\t\t\t((hdmi_read(sd, 0x05) & 0x20) ? V4L2_DV_HSYNC_POS_POL : 0);\n\t\tif (bt->interlaced == V4L2_DV_INTERLACED) {\n\t\t\tbt->height += hdmi_read16(sd, 0x0b,\n\t\t\t\tinfo->field1_height_mask);\n\t\t\tbt->il_vfrontporch = hdmi_read16(sd, 0x2c,\n\t\t\t\tinfo->field1_vfrontporch_mask) / 2;\n\t\t\tbt->il_vsync = hdmi_read16(sd, 0x30,\n\t\t\t\tinfo->field1_vsync_mask) / 2;\n\t\t\tbt->il_vbackporch = hdmi_read16(sd, 0x34,\n\t\t\t\tinfo->field1_vbackporch_mask) / 2;\n\t\t}\n\t\tadv76xx_fill_optional_dv_timings_fields(sd, timings);\n\t} else {\n\t\t \n\t\tif (!stdi2dv_timings(sd, &stdi, timings))\n\t\t\tgoto found;\n\t\tstdi.lcvs += 1;\n\t\tv4l2_dbg(1, debug, sd, \"%s: lcvs + 1 = %d\\n\", __func__, stdi.lcvs);\n\t\tif (!stdi2dv_timings(sd, &stdi, timings))\n\t\t\tgoto found;\n\t\tstdi.lcvs -= 2;\n\t\tv4l2_dbg(1, debug, sd, \"%s: lcvs - 1 = %d\\n\", __func__, stdi.lcvs);\n\t\tif (stdi2dv_timings(sd, &stdi, timings)) {\n\t\t\t \n\t\t\tif (state->restart_stdi_once) {\n\t\t\t\tv4l2_dbg(1, debug, sd, \"%s: restart STDI\\n\", __func__);\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tcp_write_clr_set(sd, 0x86, 0x06, 0x00);\n\t\t\t\t \n\t\t\t\tcp_write_clr_set(sd, 0x86, 0x06, 0x04);\n\t\t\t\t \n\t\t\t\tcp_write_clr_set(sd, 0x86, 0x06, 0x02);\n\t\t\t\tstate->restart_stdi_once = false;\n\t\t\t\treturn -ENOLINK;\n\t\t\t}\n\t\t\tv4l2_dbg(1, debug, sd, \"%s: format not supported\\n\", __func__);\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tstate->restart_stdi_once = true;\n\t}\nfound:\n\n\tif (no_signal(sd)) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: signal lost during readout\\n\", __func__);\n\t\tmemset(timings, 0, sizeof(struct v4l2_dv_timings));\n\t\treturn -ENOLINK;\n\t}\n\n\tif ((is_analog_input(sd) && bt->pixelclock > 170000000) ||\n\t\t\t(is_digital_input(sd) && bt->pixelclock > 225000000)) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: pixelclock out of range %d\\n\",\n\t\t\t\t__func__, (u32)bt->pixelclock);\n\t\treturn -ERANGE;\n\t}\n\n\tif (debug > 1)\n\t\tv4l2_print_dv_timings(sd->name, \"adv76xx_query_dv_timings: \",\n\t\t\t\t      timings, true);\n\n\treturn 0;\n}\n\nstatic int adv76xx_s_dv_timings(struct v4l2_subdev *sd,\n\t\tstruct v4l2_dv_timings *timings)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tstruct v4l2_bt_timings *bt;\n\tint err;\n\n\tif (!timings)\n\t\treturn -EINVAL;\n\n\tif (v4l2_match_dv_timings(&state->timings, timings, 0, false)) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: no change\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tbt = &timings->bt;\n\n\tif (!v4l2_valid_dv_timings(timings, adv76xx_get_dv_timings_cap(sd, -1),\n\t\t\t\t   adv76xx_check_dv_timings, NULL))\n\t\treturn -ERANGE;\n\n\tadv76xx_fill_optional_dv_timings_fields(sd, timings);\n\n\tstate->timings = *timings;\n\n\tcp_write_clr_set(sd, 0x91, 0x40, bt->interlaced ? 0x40 : 0x00);\n\n\t \n\terr = configure_predefined_video_timings(sd, timings);\n\tif (err) {\n\t\t \n\t\tconfigure_custom_video_timings(sd, bt);\n\t}\n\n\tset_rgb_quantization_range(sd);\n\n\tif (debug > 1)\n\t\tv4l2_print_dv_timings(sd->name, \"adv76xx_s_dv_timings: \",\n\t\t\t\t      timings, true);\n\treturn 0;\n}\n\nstatic int adv76xx_g_dv_timings(struct v4l2_subdev *sd,\n\t\tstruct v4l2_dv_timings *timings)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\t*timings = state->timings;\n\treturn 0;\n}\n\nstatic void adv7604_set_termination(struct v4l2_subdev *sd, bool enable)\n{\n\thdmi_write(sd, 0x01, enable ? 0x00 : 0x78);\n}\n\nstatic void adv7611_set_termination(struct v4l2_subdev *sd, bool enable)\n{\n\thdmi_write(sd, 0x83, enable ? 0xfe : 0xff);\n}\n\nstatic void enable_input(struct v4l2_subdev *sd)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\tif (is_analog_input(sd)) {\n\t\tio_write(sd, 0x15, 0xb0);    \n\t} else if (is_digital_input(sd)) {\n\t\thdmi_write_clr_set(sd, 0x00, 0x03, state->selected_input);\n\t\tstate->info->set_termination(sd, true);\n\t\tio_write(sd, 0x15, 0xa0);    \n\t\thdmi_write_clr_set(sd, 0x1a, 0x10, 0x00);  \n\t} else {\n\t\tv4l2_dbg(2, debug, sd, \"%s: Unknown port %d selected\\n\",\n\t\t\t\t__func__, state->selected_input);\n\t}\n}\n\nstatic void disable_input(struct v4l2_subdev *sd)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\thdmi_write_clr_set(sd, 0x1a, 0x10, 0x10);  \n\tmsleep(16);  \n\tio_write(sd, 0x15, 0xbe);    \n\tstate->info->set_termination(sd, false);\n}\n\nstatic void select_input(struct v4l2_subdev *sd)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tconst struct adv76xx_chip_info *info = state->info;\n\n\tif (is_analog_input(sd)) {\n\t\tadv76xx_write_reg_seq(sd, info->recommended_settings[0]);\n\n\t\tafe_write(sd, 0x00, 0x08);  \n\t\tafe_write(sd, 0x01, 0x06);  \n\t\tafe_write(sd, 0xc8, 0x00);  \n\t} else if (is_digital_input(sd)) {\n\t\thdmi_write(sd, 0x00, state->selected_input & 0x03);\n\n\t\tadv76xx_write_reg_seq(sd, info->recommended_settings[1]);\n\n\t\tif (adv76xx_has_afe(state)) {\n\t\t\tafe_write(sd, 0x00, 0xff);  \n\t\t\tafe_write(sd, 0x01, 0xfe);  \n\t\t\tafe_write(sd, 0xc8, 0x40);  \n\t\t}\n\n\t\tcp_write(sd, 0x3e, 0x00);  \n\t\tcp_write(sd, 0xc3, 0x39);  \n\t\tcp_write(sd, 0x40, 0x80);  \n\t} else {\n\t\tv4l2_dbg(2, debug, sd, \"%s: Unknown port %d selected\\n\",\n\t\t\t\t__func__, state->selected_input);\n\t}\n\n\t \n\tcp_write_clr_set(sd, 0x3e, 0x80, 0x80);\n}\n\nstatic int adv76xx_s_routing(struct v4l2_subdev *sd,\n\t\tu32 input, u32 output, u32 config)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\tv4l2_dbg(2, debug, sd, \"%s: input %d, selected input %d\",\n\t\t\t__func__, input, state->selected_input);\n\n\tif (input == state->selected_input)\n\t\treturn 0;\n\n\tif (input > state->info->max_port)\n\t\treturn -EINVAL;\n\n\tstate->selected_input = input;\n\n\tdisable_input(sd);\n\tselect_input(sd);\n\tenable_input(sd);\n\n\tv4l2_subdev_notify_event(sd, &adv76xx_ev_fmt);\n\n\treturn 0;\n}\n\nstatic int adv76xx_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\tif (code->index >= state->info->nformats)\n\t\treturn -EINVAL;\n\n\tcode->code = state->info->formats[code->index].code;\n\n\treturn 0;\n}\n\nstatic void adv76xx_fill_format(struct adv76xx_state *state,\n\t\t\t\tstruct v4l2_mbus_framefmt *format)\n{\n\tmemset(format, 0, sizeof(*format));\n\n\tformat->width = state->timings.bt.width;\n\tformat->height = state->timings.bt.height;\n\tformat->field = V4L2_FIELD_NONE;\n\tformat->colorspace = V4L2_COLORSPACE_SRGB;\n\n\tif (state->timings.bt.flags & V4L2_DV_FL_IS_CE_VIDEO)\n\t\tformat->colorspace = (state->timings.bt.height <= 576) ?\n\t\t\tV4L2_COLORSPACE_SMPTE170M : V4L2_COLORSPACE_REC709;\n}\n\n \nstatic unsigned int adv76xx_op_ch_sel(struct adv76xx_state *state)\n{\n#define _SEL(a,b,c,d,e,f)\t{ \\\n\tADV76XX_OP_CH_SEL_##a, ADV76XX_OP_CH_SEL_##b, ADV76XX_OP_CH_SEL_##c, \\\n\tADV76XX_OP_CH_SEL_##d, ADV76XX_OP_CH_SEL_##e, ADV76XX_OP_CH_SEL_##f }\n#define _BUS(x)\t\t\t[ADV7604_BUS_ORDER_##x]\n\n\tstatic const unsigned int op_ch_sel[6][6] = {\n\t\t_BUS(RGB)   = _SEL(GBR, GRB, BGR, RGB, BRG, RBG),\n\t\t_BUS(GRB)   = _SEL(BGR, RGB, GBR, GRB, RBG, BRG),\n\t\t_BUS(RBG)   = _SEL(GRB, GBR, BRG, RBG, BGR, RGB),\n\t\t_BUS(BGR)   = _SEL(RBG, BRG, RGB, BGR, GRB, GBR),\n\t\t_BUS(BRG)   = _SEL(BRG, RBG, GRB, GBR, RGB, BGR),\n\t\t_BUS(GBR)   = _SEL(RGB, BGR, RBG, BRG, GBR, GRB),\n\t};\n\n\treturn op_ch_sel[state->pdata.bus_order][state->format->op_ch_sel >> 5];\n}\n\nstatic void adv76xx_setup_format(struct adv76xx_state *state)\n{\n\tstruct v4l2_subdev *sd = &state->sd;\n\n\tio_write_clr_set(sd, 0x02, 0x02,\n\t\t\tstate->format->rgb_out ? ADV76XX_RGB_OUT : 0);\n\tio_write(sd, 0x03, state->format->op_format_sel |\n\t\t state->pdata.op_format_mode_sel);\n\tio_write_clr_set(sd, 0x04, 0xe0, adv76xx_op_ch_sel(state));\n\tio_write_clr_set(sd, 0x05, 0x01,\n\t\t\tstate->format->swap_cb_cr ? ADV76XX_OP_SWAP_CB_CR : 0);\n\tset_rgb_quantization_range(sd);\n}\n\nstatic int adv76xx_get_format(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *format)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\tif (format->pad != state->source_pad)\n\t\treturn -EINVAL;\n\n\tadv76xx_fill_format(state, &format->format);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tstruct v4l2_mbus_framefmt *fmt;\n\n\t\tfmt = v4l2_subdev_get_try_format(sd, sd_state, format->pad);\n\t\tformat->format.code = fmt->code;\n\t} else {\n\t\tformat->format.code = state->format->code;\n\t}\n\n\treturn 0;\n}\n\nstatic int adv76xx_get_selection(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_selection *sel)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\tif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn -EINVAL;\n\t \n\tif (sel->target > V4L2_SEL_TGT_CROP_BOUNDS)\n\t\treturn -EINVAL;\n\n\tsel->r.left\t= 0;\n\tsel->r.top\t= 0;\n\tsel->r.width\t= state->timings.bt.width;\n\tsel->r.height\t= state->timings.bt.height;\n\n\treturn 0;\n}\n\nstatic int adv76xx_set_format(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *format)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tconst struct adv76xx_format_info *info;\n\n\tif (format->pad != state->source_pad)\n\t\treturn -EINVAL;\n\n\tinfo = adv76xx_format_info(state, format->format.code);\n\tif (!info)\n\t\tinfo = adv76xx_format_info(state, MEDIA_BUS_FMT_YUYV8_2X8);\n\n\tadv76xx_fill_format(state, &format->format);\n\tformat->format.code = info->code;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tstruct v4l2_mbus_framefmt *fmt;\n\n\t\tfmt = v4l2_subdev_get_try_format(sd, sd_state, format->pad);\n\t\tfmt->code = format->format.code;\n\t} else {\n\t\tstate->format = info;\n\t\tadv76xx_setup_format(state);\n\t}\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_VIDEO_ADV7604_CEC)\nstatic void adv76xx_cec_tx_raw_status(struct v4l2_subdev *sd, u8 tx_raw_status)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\tif ((cec_read(sd, 0x11) & 0x01) == 0) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: tx raw: tx disabled\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (tx_raw_status & 0x02) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: tx raw: arbitration lost\\n\",\n\t\t\t __func__);\n\t\tcec_transmit_done(state->cec_adap, CEC_TX_STATUS_ARB_LOST,\n\t\t\t\t  1, 0, 0, 0);\n\t\treturn;\n\t}\n\tif (tx_raw_status & 0x04) {\n\t\tu8 status;\n\t\tu8 nack_cnt;\n\t\tu8 low_drive_cnt;\n\n\t\tv4l2_dbg(1, debug, sd, \"%s: tx raw: retry failed\\n\", __func__);\n\t\t \n\t\tstatus = CEC_TX_STATUS_MAX_RETRIES;\n\t\tnack_cnt = cec_read(sd, 0x14) & 0xf;\n\t\tif (nack_cnt)\n\t\t\tstatus |= CEC_TX_STATUS_NACK;\n\t\tlow_drive_cnt = cec_read(sd, 0x14) >> 4;\n\t\tif (low_drive_cnt)\n\t\t\tstatus |= CEC_TX_STATUS_LOW_DRIVE;\n\t\tcec_transmit_done(state->cec_adap, status,\n\t\t\t\t  0, nack_cnt, low_drive_cnt, 0);\n\t\treturn;\n\t}\n\tif (tx_raw_status & 0x01) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: tx raw: ready ok\\n\", __func__);\n\t\tcec_transmit_done(state->cec_adap, CEC_TX_STATUS_OK, 0, 0, 0, 0);\n\t\treturn;\n\t}\n}\n\nstatic void adv76xx_cec_isr(struct v4l2_subdev *sd, bool *handled)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tconst struct adv76xx_chip_info *info = state->info;\n\tu8 cec_irq;\n\n\t \n\tcec_irq = io_read(sd, info->cec_irq_status) & 0x0f;\n\tif (!cec_irq)\n\t\treturn;\n\n\tv4l2_dbg(1, debug, sd, \"%s: cec: irq 0x%x\\n\", __func__, cec_irq);\n\tadv76xx_cec_tx_raw_status(sd, cec_irq);\n\tif (cec_irq & 0x08) {\n\t\tstruct cec_msg msg;\n\n\t\tmsg.len = cec_read(sd, 0x25) & 0x1f;\n\t\tif (msg.len > CEC_MAX_MSG_SIZE)\n\t\t\tmsg.len = CEC_MAX_MSG_SIZE;\n\n\t\tif (msg.len) {\n\t\t\tu8 i;\n\n\t\t\tfor (i = 0; i < msg.len; i++)\n\t\t\t\tmsg.msg[i] = cec_read(sd, i + 0x15);\n\t\t\tcec_write(sd, info->cec_rx_enable,\n\t\t\t\t  info->cec_rx_enable_mask);  \n\t\t\tcec_received_msg(state->cec_adap, &msg);\n\t\t}\n\t}\n\n\tif (info->cec_irq_swap) {\n\t\t \n\t\tcec_irq = ((cec_irq & 0x08) >> 3) | ((cec_irq & 0x04) >> 1) |\n\t\t\t  ((cec_irq & 0x02) << 1) | ((cec_irq & 0x01) << 3);\n\t}\n\tio_write(sd, info->cec_irq_status + 1, cec_irq);\n\n\tif (handled)\n\t\t*handled = true;\n}\n\nstatic int adv76xx_cec_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\tstruct adv76xx_state *state = cec_get_drvdata(adap);\n\tconst struct adv76xx_chip_info *info = state->info;\n\tstruct v4l2_subdev *sd = &state->sd;\n\n\tif (!state->cec_enabled_adap && enable) {\n\t\tcec_write_clr_set(sd, 0x2a, 0x01, 0x01);  \n\t\tcec_write(sd, 0x2c, 0x01);\t \n\t\tcec_write_clr_set(sd, 0x11, 0x01, 0);  \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\tio_write_clr_set(sd, info->cec_irq_status + 3, 0x0f, 0x0f);\n\t\tcec_write(sd, info->cec_rx_enable, info->cec_rx_enable_mask);\n\t} else if (state->cec_enabled_adap && !enable) {\n\t\t \n\t\tio_write_clr_set(sd, info->cec_irq_status + 3, 0x0f, 0x00);\n\t\t \n\t\tcec_write_clr_set(sd, 0x27, 0x70, 0x00);\n\t\t \n\t\tcec_write_clr_set(sd, 0x2a, 0x01, 0x00);\n\t\tstate->cec_valid_addrs = 0;\n\t}\n\tstate->cec_enabled_adap = enable;\n\tadv76xx_s_detect_tx_5v_ctrl(sd);\n\treturn 0;\n}\n\nstatic int adv76xx_cec_adap_log_addr(struct cec_adapter *adap, u8 addr)\n{\n\tstruct adv76xx_state *state = cec_get_drvdata(adap);\n\tstruct v4l2_subdev *sd = &state->sd;\n\tunsigned int i, free_idx = ADV76XX_MAX_ADDRS;\n\n\tif (!state->cec_enabled_adap)\n\t\treturn addr == CEC_LOG_ADDR_INVALID ? 0 : -EIO;\n\n\tif (addr == CEC_LOG_ADDR_INVALID) {\n\t\tcec_write_clr_set(sd, 0x27, 0x70, 0);\n\t\tstate->cec_valid_addrs = 0;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ADV76XX_MAX_ADDRS; i++) {\n\t\tbool is_valid = state->cec_valid_addrs & (1 << i);\n\n\t\tif (free_idx == ADV76XX_MAX_ADDRS && !is_valid)\n\t\t\tfree_idx = i;\n\t\tif (is_valid && state->cec_addr[i] == addr)\n\t\t\treturn 0;\n\t}\n\tif (i == ADV76XX_MAX_ADDRS) {\n\t\ti = free_idx;\n\t\tif (i == ADV76XX_MAX_ADDRS)\n\t\t\treturn -ENXIO;\n\t}\n\tstate->cec_addr[i] = addr;\n\tstate->cec_valid_addrs |= 1 << i;\n\n\tswitch (i) {\n\tcase 0:\n\t\t \n\t\tcec_write_clr_set(sd, 0x27, 0x10, 0x10);\n\t\t \n\t\tcec_write_clr_set(sd, 0x28, 0x0f, addr);\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tcec_write_clr_set(sd, 0x27, 0x20, 0x20);\n\t\t \n\t\tcec_write_clr_set(sd, 0x28, 0xf0, addr << 4);\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tcec_write_clr_set(sd, 0x27, 0x40, 0x40);\n\t\t \n\t\tcec_write_clr_set(sd, 0x29, 0x0f, addr);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int adv76xx_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\t     u32 signal_free_time, struct cec_msg *msg)\n{\n\tstruct adv76xx_state *state = cec_get_drvdata(adap);\n\tstruct v4l2_subdev *sd = &state->sd;\n\tu8 len = msg->len;\n\tunsigned int i;\n\n\t \n\tcec_write_clr_set(sd, 0x12, 0x70, max(1, attempts - 1) << 4);\n\n\tif (len > 16) {\n\t\tv4l2_err(sd, \"%s: len exceeded 16 (%d)\\n\", __func__, len);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < len; i++)\n\t\tcec_write(sd, i, msg->msg[i]);\n\n\t \n\tcec_write(sd, 0x10, len);\n\t \n\tcec_write(sd, 0x11, 0x01);\n\treturn 0;\n}\n\nstatic const struct cec_adap_ops adv76xx_cec_adap_ops = {\n\t.adap_enable = adv76xx_cec_adap_enable,\n\t.adap_log_addr = adv76xx_cec_adap_log_addr,\n\t.adap_transmit = adv76xx_cec_adap_transmit,\n};\n#endif\n\nstatic int adv76xx_isr(struct v4l2_subdev *sd, u32 status, bool *handled)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tconst struct adv76xx_chip_info *info = state->info;\n\tconst u8 irq_reg_0x43 = io_read(sd, 0x43);\n\tconst u8 irq_reg_0x6b = io_read(sd, 0x6b);\n\tconst u8 irq_reg_0x70 = io_read(sd, 0x70);\n\tu8 fmt_change_digital;\n\tu8 fmt_change;\n\tu8 tx_5v;\n\n\tif (irq_reg_0x43)\n\t\tio_write(sd, 0x44, irq_reg_0x43);\n\tif (irq_reg_0x70)\n\t\tio_write(sd, 0x71, irq_reg_0x70);\n\tif (irq_reg_0x6b)\n\t\tio_write(sd, 0x6c, irq_reg_0x6b);\n\n\tv4l2_dbg(2, debug, sd, \"%s: \", __func__);\n\n\t \n\tfmt_change = irq_reg_0x43 & 0x98;\n\tfmt_change_digital = is_digital_input(sd)\n\t\t\t   ? irq_reg_0x6b & info->fmt_change_digital_mask\n\t\t\t   : 0;\n\n\tif (fmt_change || fmt_change_digital) {\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t\"%s: fmt_change = 0x%x, fmt_change_digital = 0x%x\\n\",\n\t\t\t__func__, fmt_change, fmt_change_digital);\n\n\t\tv4l2_subdev_notify_event(sd, &adv76xx_ev_fmt);\n\n\t\tif (handled)\n\t\t\t*handled = true;\n\t}\n\t \n\tif (irq_reg_0x6b & 0x01) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: irq %s mode\\n\", __func__,\n\t\t\t(io_read(sd, 0x6a) & 0x01) ? \"HDMI\" : \"DVI\");\n\t\tset_rgb_quantization_range(sd);\n\t\tif (handled)\n\t\t\t*handled = true;\n\t}\n\n#if IS_ENABLED(CONFIG_VIDEO_ADV7604_CEC)\n\t \n\tadv76xx_cec_isr(sd, handled);\n#endif\n\n\t \n\ttx_5v = irq_reg_0x70 & info->cable_det_mask;\n\tif (tx_5v) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: tx_5v: 0x%x\\n\", __func__, tx_5v);\n\t\tadv76xx_s_detect_tx_5v_ctrl(sd);\n\t\tif (handled)\n\t\t\t*handled = true;\n\t}\n\treturn 0;\n}\n\nstatic irqreturn_t adv76xx_irq_handler(int irq, void *dev_id)\n{\n\tstruct adv76xx_state *state = dev_id;\n\tbool handled = false;\n\n\tadv76xx_isr(&state->sd, 0, &handled);\n\n\treturn handled ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic int adv76xx_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tu8 *data = NULL;\n\n\tmemset(edid->reserved, 0, sizeof(edid->reserved));\n\n\tswitch (edid->pad) {\n\tcase ADV76XX_PAD_HDMI_PORT_A:\n\tcase ADV7604_PAD_HDMI_PORT_B:\n\tcase ADV7604_PAD_HDMI_PORT_C:\n\tcase ADV7604_PAD_HDMI_PORT_D:\n\t\tif (state->edid.present & (1 << edid->pad))\n\t\t\tdata = state->edid.edid;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (edid->start_block == 0 && edid->blocks == 0) {\n\t\tedid->blocks = data ? state->edid.blocks : 0;\n\t\treturn 0;\n\t}\n\n\tif (!data)\n\t\treturn -ENODATA;\n\n\tif (edid->start_block >= state->edid.blocks)\n\t\treturn -EINVAL;\n\n\tif (edid->start_block + edid->blocks > state->edid.blocks)\n\t\tedid->blocks = state->edid.blocks - edid->start_block;\n\n\tmemcpy(edid->edid, data + edid->start_block * 128, edid->blocks * 128);\n\n\treturn 0;\n}\n\nstatic int adv76xx_set_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tconst struct adv76xx_chip_info *info = state->info;\n\tunsigned int spa_loc;\n\tu16 pa, parent_pa;\n\tint err;\n\tint i;\n\n\tmemset(edid->reserved, 0, sizeof(edid->reserved));\n\n\tif (edid->pad > ADV7604_PAD_HDMI_PORT_D)\n\t\treturn -EINVAL;\n\tif (edid->start_block != 0)\n\t\treturn -EINVAL;\n\tif (edid->blocks == 0) {\n\t\t \n\t\tstate->edid.present &= ~(1 << edid->pad);\n\t\tadv76xx_set_hpd(state, state->edid.present);\n\t\trep_write_clr_set(sd, info->edid_enable_reg, 0x0f, state->edid.present);\n\n\t\t \n\t\tstate->aspect_ratio.numerator = 16;\n\t\tstate->aspect_ratio.denominator = 9;\n\n\t\tif (!state->edid.present) {\n\t\t\tstate->edid.blocks = 0;\n\t\t\tcec_phys_addr_invalidate(state->cec_adap);\n\t\t}\n\n\t\tv4l2_dbg(2, debug, sd, \"%s: clear EDID pad %d, edid.present = 0x%x\\n\",\n\t\t\t\t__func__, edid->pad, state->edid.present);\n\t\treturn 0;\n\t}\n\tif (edid->blocks > ADV76XX_MAX_EDID_BLOCKS) {\n\t\tedid->blocks = ADV76XX_MAX_EDID_BLOCKS;\n\t\treturn -E2BIG;\n\t}\n\n\tpa = v4l2_get_edid_phys_addr(edid->edid, edid->blocks * 128, &spa_loc);\n\terr = v4l2_phys_addr_validate(pa, &parent_pa, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!spa_loc) {\n\t\t \n\t\tspa_loc = 128;\n\t\tpa = (edid->edid[spa_loc] << 8) | edid->edid[spa_loc + 1];\n\t}\n\n\tv4l2_dbg(2, debug, sd, \"%s: write EDID pad %d, edid.present = 0x%x\\n\",\n\t\t\t__func__, edid->pad, state->edid.present);\n\n\t \n\tcancel_delayed_work_sync(&state->delayed_work_enable_hotplug);\n\tadv76xx_set_hpd(state, 0);\n\trep_write_clr_set(sd, info->edid_enable_reg, 0x0f, 0x00);\n\n\tswitch (edid->pad) {\n\tcase ADV76XX_PAD_HDMI_PORT_A:\n\t\tstate->spa_port_a[0] = pa >> 8;\n\t\tstate->spa_port_a[1] = pa & 0xff;\n\t\tbreak;\n\tcase ADV7604_PAD_HDMI_PORT_B:\n\t\trep_write(sd, info->edid_spa_port_b_reg, pa >> 8);\n\t\trep_write(sd, info->edid_spa_port_b_reg + 1, pa & 0xff);\n\t\tbreak;\n\tcase ADV7604_PAD_HDMI_PORT_C:\n\t\trep_write(sd, info->edid_spa_port_b_reg + 2, pa >> 8);\n\t\trep_write(sd, info->edid_spa_port_b_reg + 3, pa & 0xff);\n\t\tbreak;\n\tcase ADV7604_PAD_HDMI_PORT_D:\n\t\trep_write(sd, info->edid_spa_port_b_reg + 4, pa >> 8);\n\t\trep_write(sd, info->edid_spa_port_b_reg + 5, pa & 0xff);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->edid_spa_loc_reg) {\n\t\tu8 mask = info->edid_spa_loc_msb_mask;\n\n\t\trep_write(sd, info->edid_spa_loc_reg, spa_loc & 0xff);\n\t\trep_write_clr_set(sd, info->edid_spa_loc_reg + 1,\n\t\t\t\t  mask, (spa_loc & 0x100) ? mask : 0);\n\t}\n\n\tedid->edid[spa_loc] = state->spa_port_a[0];\n\tedid->edid[spa_loc + 1] = state->spa_port_a[1];\n\n\tmemcpy(state->edid.edid, edid->edid, 128 * edid->blocks);\n\tstate->edid.blocks = edid->blocks;\n\tstate->aspect_ratio = v4l2_calc_aspect_ratio(edid->edid[0x15],\n\t\t\tedid->edid[0x16]);\n\tstate->edid.present |= 1 << edid->pad;\n\n\trep_write_clr_set(sd, info->edid_segment_reg,\n\t\t\t  info->edid_segment_mask, 0);\n\terr = edid_write_block(sd, 128 * min(edid->blocks, 2U), state->edid.edid);\n\tif (err < 0) {\n\t\tv4l2_err(sd, \"error %d writing edid pad %d\\n\", err, edid->pad);\n\t\treturn err;\n\t}\n\tif (edid->blocks > 2) {\n\t\trep_write_clr_set(sd, info->edid_segment_reg,\n\t\t\t\t  info->edid_segment_mask,\n\t\t\t\t  info->edid_segment_mask);\n\t\terr = edid_write_block(sd, 128 * (edid->blocks - 2),\n\t\t\t\t       state->edid.edid + 256);\n\t\tif (err < 0) {\n\t\t\tv4l2_err(sd, \"error %d writing edid pad %d\\n\",\n\t\t\t\t err, edid->pad);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\trep_write_clr_set(sd, info->edid_enable_reg, 0x0f, state->edid.present);\n\n\tfor (i = 0; i < 1000; i++) {\n\t\tif (rep_read(sd, info->edid_status_reg) & state->edid.present)\n\t\t\tbreak;\n\t\tmdelay(1);\n\t}\n\tif (i == 1000) {\n\t\tv4l2_err(sd, \"error enabling edid (0x%x)\\n\", state->edid.present);\n\t\treturn -EIO;\n\t}\n\tcec_s_phys_addr(state->cec_adap, parent_pa, false);\n\n\t \n\tschedule_delayed_work(&state->delayed_work_enable_hotplug, HZ / 10);\n\treturn 0;\n}\n\n \n\nstatic const struct adv76xx_cfg_read_infoframe adv76xx_cri[] = {\n\t{ \"AVI\", 0x01, 0xe0, 0x00 },\n\t{ \"Audio\", 0x02, 0xe3, 0x1c },\n\t{ \"SDP\", 0x04, 0xe6, 0x2a },\n\t{ \"Vendor\", 0x10, 0xec, 0x54 }\n};\n\nstatic int adv76xx_read_infoframe(struct v4l2_subdev *sd, int index,\n\t\t\t\t  union hdmi_infoframe *frame)\n{\n\tuint8_t buffer[32];\n\tu8 len;\n\tint i;\n\n\tif (!(io_read(sd, 0x60) & adv76xx_cri[index].present_mask)) {\n\t\tv4l2_info(sd, \"%s infoframe not received\\n\",\n\t\t\t  adv76xx_cri[index].desc);\n\t\treturn -ENOENT;\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t\tbuffer[i] = infoframe_read(sd,\n\t\t\t\t\t   adv76xx_cri[index].head_addr + i);\n\n\tlen = buffer[2] + 1;\n\n\tif (len + 3 > sizeof(buffer)) {\n\t\tv4l2_err(sd, \"%s: invalid %s infoframe length %d\\n\", __func__,\n\t\t\t adv76xx_cri[index].desc, len);\n\t\treturn -ENOENT;\n\t}\n\n\tfor (i = 0; i < len; i++)\n\t\tbuffer[i + 3] = infoframe_read(sd,\n\t\t\t\t       adv76xx_cri[index].payload_addr + i);\n\n\tif (hdmi_infoframe_unpack(frame, buffer, len + 3) < 0) {\n\t\tv4l2_err(sd, \"%s: unpack of %s infoframe failed\\n\", __func__,\n\t\t\t adv76xx_cri[index].desc);\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}\n\nstatic void adv76xx_log_infoframes(struct v4l2_subdev *sd)\n{\n\tint i;\n\n\tif (!is_hdmi(sd)) {\n\t\tv4l2_info(sd, \"receive DVI-D signal, no infoframes\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(adv76xx_cri); i++) {\n\t\tunion hdmi_infoframe frame;\n\t\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\t\tif (!adv76xx_read_infoframe(sd, i, &frame))\n\t\t\thdmi_infoframe_log(KERN_INFO, &client->dev, &frame);\n\t}\n}\n\nstatic int adv76xx_log_status(struct v4l2_subdev *sd)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tconst struct adv76xx_chip_info *info = state->info;\n\tstruct v4l2_dv_timings timings;\n\tstruct stdi_readback stdi;\n\tu8 reg_io_0x02 = io_read(sd, 0x02);\n\tu8 edid_enabled;\n\tu8 cable_det;\n\n\tstatic const char * const csc_coeff_sel_rb[16] = {\n\t\t\"bypassed\", \"YPbPr601 -> RGB\", \"reserved\", \"YPbPr709 -> RGB\",\n\t\t\"reserved\", \"RGB -> YPbPr601\", \"reserved\", \"RGB -> YPbPr709\",\n\t\t\"reserved\", \"YPbPr709 -> YPbPr601\", \"YPbPr601 -> YPbPr709\",\n\t\t\"reserved\", \"reserved\", \"reserved\", \"reserved\", \"manual\"\n\t};\n\tstatic const char * const input_color_space_txt[16] = {\n\t\t\"RGB limited range (16-235)\", \"RGB full range (0-255)\",\n\t\t\"YCbCr Bt.601 (16-235)\", \"YCbCr Bt.709 (16-235)\",\n\t\t\"xvYCC Bt.601\", \"xvYCC Bt.709\",\n\t\t\"YCbCr Bt.601 (0-255)\", \"YCbCr Bt.709 (0-255)\",\n\t\t\"invalid\", \"invalid\", \"invalid\", \"invalid\", \"invalid\",\n\t\t\"invalid\", \"invalid\", \"automatic\"\n\t};\n\tstatic const char * const hdmi_color_space_txt[16] = {\n\t\t\"RGB limited range (16-235)\", \"RGB full range (0-255)\",\n\t\t\"YCbCr Bt.601 (16-235)\", \"YCbCr Bt.709 (16-235)\",\n\t\t\"xvYCC Bt.601\", \"xvYCC Bt.709\",\n\t\t\"YCbCr Bt.601 (0-255)\", \"YCbCr Bt.709 (0-255)\",\n\t\t\"sYCC\", \"opYCC 601\", \"opRGB\", \"invalid\", \"invalid\",\n\t\t\"invalid\", \"invalid\", \"invalid\"\n\t};\n\tstatic const char * const rgb_quantization_range_txt[] = {\n\t\t\"Automatic\",\n\t\t\"RGB limited range (16-235)\",\n\t\t\"RGB full range (0-255)\",\n\t};\n\tstatic const char * const deep_color_mode_txt[4] = {\n\t\t\"8-bits per channel\",\n\t\t\"10-bits per channel\",\n\t\t\"12-bits per channel\",\n\t\t\"16-bits per channel (not supported)\"\n\t};\n\n\tv4l2_info(sd, \"-----Chip status-----\\n\");\n\tv4l2_info(sd, \"Chip power: %s\\n\", no_power(sd) ? \"off\" : \"on\");\n\tedid_enabled = rep_read(sd, info->edid_status_reg);\n\tv4l2_info(sd, \"EDID enabled port A: %s, B: %s, C: %s, D: %s\\n\",\n\t\t\t((edid_enabled & 0x01) ? \"Yes\" : \"No\"),\n\t\t\t((edid_enabled & 0x02) ? \"Yes\" : \"No\"),\n\t\t\t((edid_enabled & 0x04) ? \"Yes\" : \"No\"),\n\t\t\t((edid_enabled & 0x08) ? \"Yes\" : \"No\"));\n\tv4l2_info(sd, \"CEC: %s\\n\", state->cec_enabled_adap ?\n\t\t\t\"enabled\" : \"disabled\");\n\tif (state->cec_enabled_adap) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ADV76XX_MAX_ADDRS; i++) {\n\t\t\tbool is_valid = state->cec_valid_addrs & (1 << i);\n\n\t\t\tif (is_valid)\n\t\t\t\tv4l2_info(sd, \"CEC Logical Address: 0x%x\\n\",\n\t\t\t\t\t  state->cec_addr[i]);\n\t\t}\n\t}\n\n\tv4l2_info(sd, \"-----Signal status-----\\n\");\n\tcable_det = info->read_cable_det(sd);\n\tv4l2_info(sd, \"Cable detected (+5V power) port A: %s, B: %s, C: %s, D: %s\\n\",\n\t\t\t((cable_det & 0x01) ? \"Yes\" : \"No\"),\n\t\t\t((cable_det & 0x02) ? \"Yes\" : \"No\"),\n\t\t\t((cable_det & 0x04) ? \"Yes\" : \"No\"),\n\t\t\t((cable_det & 0x08) ? \"Yes\" : \"No\"));\n\tv4l2_info(sd, \"TMDS signal detected: %s\\n\",\n\t\t\tno_signal_tmds(sd) ? \"false\" : \"true\");\n\tv4l2_info(sd, \"TMDS signal locked: %s\\n\",\n\t\t\tno_lock_tmds(sd) ? \"false\" : \"true\");\n\tv4l2_info(sd, \"SSPD locked: %s\\n\", no_lock_sspd(sd) ? \"false\" : \"true\");\n\tv4l2_info(sd, \"STDI locked: %s\\n\", no_lock_stdi(sd) ? \"false\" : \"true\");\n\tv4l2_info(sd, \"CP locked: %s\\n\", no_lock_cp(sd) ? \"false\" : \"true\");\n\tv4l2_info(sd, \"CP free run: %s\\n\",\n\t\t\t(in_free_run(sd)) ? \"on\" : \"off\");\n\tv4l2_info(sd, \"Prim-mode = 0x%x, video std = 0x%x, v_freq = 0x%x\\n\",\n\t\t\tio_read(sd, 0x01) & 0x0f, io_read(sd, 0x00) & 0x3f,\n\t\t\t(io_read(sd, 0x01) & 0x70) >> 4);\n\n\tv4l2_info(sd, \"-----Video Timings-----\\n\");\n\tif (read_stdi(sd, &stdi))\n\t\tv4l2_info(sd, \"STDI: not locked\\n\");\n\telse\n\t\tv4l2_info(sd, \"STDI: lcf (frame height - 1) = %d, bl = %d, lcvs (vsync) = %d, %s, %chsync, %cvsync\\n\",\n\t\t\t\tstdi.lcf, stdi.bl, stdi.lcvs,\n\t\t\t\tstdi.interlaced ? \"interlaced\" : \"progressive\",\n\t\t\t\tstdi.hs_pol, stdi.vs_pol);\n\tif (adv76xx_query_dv_timings(sd, &timings))\n\t\tv4l2_info(sd, \"No video detected\\n\");\n\telse\n\t\tv4l2_print_dv_timings(sd->name, \"Detected format: \",\n\t\t\t\t      &timings, true);\n\tv4l2_print_dv_timings(sd->name, \"Configured format: \",\n\t\t\t      &state->timings, true);\n\n\tif (no_signal(sd))\n\t\treturn 0;\n\n\tv4l2_info(sd, \"-----Color space-----\\n\");\n\tv4l2_info(sd, \"RGB quantization range ctrl: %s\\n\",\n\t\t\trgb_quantization_range_txt[state->rgb_quantization_range]);\n\tv4l2_info(sd, \"Input color space: %s\\n\",\n\t\t\tinput_color_space_txt[reg_io_0x02 >> 4]);\n\tv4l2_info(sd, \"Output color space: %s %s, alt-gamma %s\\n\",\n\t\t\t(reg_io_0x02 & 0x02) ? \"RGB\" : \"YCbCr\",\n\t\t\t(((reg_io_0x02 >> 2) & 0x01) ^ (reg_io_0x02 & 0x01)) ?\n\t\t\t\t\"(16-235)\" : \"(0-255)\",\n\t\t\t(reg_io_0x02 & 0x08) ? \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"Color space conversion: %s\\n\",\n\t\t\tcsc_coeff_sel_rb[cp_read(sd, info->cp_csc) >> 4]);\n\n\tif (!is_digital_input(sd))\n\t\treturn 0;\n\n\tv4l2_info(sd, \"-----%s status-----\\n\", is_hdmi(sd) ? \"HDMI\" : \"DVI-D\");\n\tv4l2_info(sd, \"Digital video port selected: %c\\n\",\n\t\t\t(hdmi_read(sd, 0x00) & 0x03) + 'A');\n\tv4l2_info(sd, \"HDCP encrypted content: %s\\n\",\n\t\t\t(hdmi_read(sd, 0x05) & 0x40) ? \"true\" : \"false\");\n\tv4l2_info(sd, \"HDCP keys read: %s%s\\n\",\n\t\t\t(hdmi_read(sd, 0x04) & 0x20) ? \"yes\" : \"no\",\n\t\t\t(hdmi_read(sd, 0x04) & 0x10) ? \"ERROR\" : \"\");\n\tif (is_hdmi(sd)) {\n\t\tbool audio_pll_locked = hdmi_read(sd, 0x04) & 0x01;\n\t\tbool audio_sample_packet_detect = hdmi_read(sd, 0x18) & 0x01;\n\t\tbool audio_mute = io_read(sd, 0x65) & 0x40;\n\n\t\tv4l2_info(sd, \"Audio: pll %s, samples %s, %s\\n\",\n\t\t\t\taudio_pll_locked ? \"locked\" : \"not locked\",\n\t\t\t\taudio_sample_packet_detect ? \"detected\" : \"not detected\",\n\t\t\t\taudio_mute ? \"muted\" : \"enabled\");\n\t\tif (audio_pll_locked && audio_sample_packet_detect) {\n\t\t\tv4l2_info(sd, \"Audio format: %s\\n\",\n\t\t\t\t\t(hdmi_read(sd, 0x07) & 0x20) ? \"multi-channel\" : \"stereo\");\n\t\t}\n\t\tv4l2_info(sd, \"Audio CTS: %u\\n\", (hdmi_read(sd, 0x5b) << 12) +\n\t\t\t\t(hdmi_read(sd, 0x5c) << 8) +\n\t\t\t\t(hdmi_read(sd, 0x5d) & 0xf0));\n\t\tv4l2_info(sd, \"Audio N: %u\\n\", ((hdmi_read(sd, 0x5d) & 0x0f) << 16) +\n\t\t\t\t(hdmi_read(sd, 0x5e) << 8) +\n\t\t\t\thdmi_read(sd, 0x5f));\n\t\tv4l2_info(sd, \"AV Mute: %s\\n\", (hdmi_read(sd, 0x04) & 0x40) ? \"on\" : \"off\");\n\n\t\tv4l2_info(sd, \"Deep color mode: %s\\n\", deep_color_mode_txt[(hdmi_read(sd, 0x0b) & 0x60) >> 5]);\n\t\tv4l2_info(sd, \"HDMI colorspace: %s\\n\", hdmi_color_space_txt[hdmi_read(sd, 0x53) & 0xf]);\n\n\t\tadv76xx_log_infoframes(sd);\n\t}\n\n\treturn 0;\n}\n\nstatic int adv76xx_subscribe_event(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_fh *fh,\n\t\t\t\t   struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\treturn v4l2_src_change_event_subdev_subscribe(sd, fh, sub);\n\tcase V4L2_EVENT_CTRL:\n\t\treturn v4l2_ctrl_subdev_subscribe_event(sd, fh, sub);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adv76xx_registered(struct v4l2_subdev *sd)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint err;\n\n\terr = cec_register_adapter(state->cec_adap, &client->dev);\n\tif (err)\n\t\tcec_delete_adapter(state->cec_adap);\n\treturn err;\n}\n\nstatic void adv76xx_unregistered(struct v4l2_subdev *sd)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\n\tcec_unregister_adapter(state->cec_adap);\n}\n\n \n\nstatic const struct v4l2_ctrl_ops adv76xx_ctrl_ops = {\n\t.s_ctrl = adv76xx_s_ctrl,\n\t.g_volatile_ctrl = adv76xx_g_volatile_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops adv76xx_core_ops = {\n\t.log_status = adv76xx_log_status,\n\t.interrupt_service_routine = adv76xx_isr,\n\t.subscribe_event = adv76xx_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = adv76xx_g_register,\n\t.s_register = adv76xx_s_register,\n#endif\n};\n\nstatic const struct v4l2_subdev_video_ops adv76xx_video_ops = {\n\t.s_routing = adv76xx_s_routing,\n\t.g_input_status = adv76xx_g_input_status,\n\t.s_dv_timings = adv76xx_s_dv_timings,\n\t.g_dv_timings = adv76xx_g_dv_timings,\n\t.query_dv_timings = adv76xx_query_dv_timings,\n};\n\nstatic const struct v4l2_subdev_pad_ops adv76xx_pad_ops = {\n\t.enum_mbus_code = adv76xx_enum_mbus_code,\n\t.get_selection = adv76xx_get_selection,\n\t.get_fmt = adv76xx_get_format,\n\t.set_fmt = adv76xx_set_format,\n\t.get_edid = adv76xx_get_edid,\n\t.set_edid = adv76xx_set_edid,\n\t.dv_timings_cap = adv76xx_dv_timings_cap,\n\t.enum_dv_timings = adv76xx_enum_dv_timings,\n};\n\nstatic const struct v4l2_subdev_ops adv76xx_ops = {\n\t.core = &adv76xx_core_ops,\n\t.video = &adv76xx_video_ops,\n\t.pad = &adv76xx_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops adv76xx_int_ops = {\n\t.registered = adv76xx_registered,\n\t.unregistered = adv76xx_unregistered,\n};\n\n \n\nstatic const struct v4l2_ctrl_config adv7604_ctrl_analog_sampling_phase = {\n\t.ops = &adv76xx_ctrl_ops,\n\t.id = V4L2_CID_ADV_RX_ANALOG_SAMPLING_PHASE,\n\t.name = \"Analog Sampling Phase\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.min = 0,\n\t.max = 0x1f,\n\t.step = 1,\n\t.def = 0,\n};\n\nstatic const struct v4l2_ctrl_config adv76xx_ctrl_free_run_color_manual = {\n\t.ops = &adv76xx_ctrl_ops,\n\t.id = V4L2_CID_ADV_RX_FREE_RUN_COLOR_MANUAL,\n\t.name = \"Free Running Color, Manual\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.min = false,\n\t.max = true,\n\t.step = 1,\n\t.def = false,\n};\n\nstatic const struct v4l2_ctrl_config adv76xx_ctrl_free_run_color = {\n\t.ops = &adv76xx_ctrl_ops,\n\t.id = V4L2_CID_ADV_RX_FREE_RUN_COLOR,\n\t.name = \"Free Running Color\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.min = 0x0,\n\t.max = 0xffffff,\n\t.step = 0x1,\n\t.def = 0x0,\n};\n\n \n\nstruct adv76xx_register_map {\n\tconst char *name;\n\tu8 default_addr;\n};\n\nstatic const struct adv76xx_register_map adv76xx_default_addresses[] = {\n\t[ADV76XX_PAGE_IO] = { \"main\", 0x4c },\n\t[ADV7604_PAGE_AVLINK] = { \"avlink\", 0x42 },\n\t[ADV76XX_PAGE_CEC] = { \"cec\", 0x40 },\n\t[ADV76XX_PAGE_INFOFRAME] = { \"infoframe\", 0x3e },\n\t[ADV7604_PAGE_ESDP] = { \"esdp\", 0x38 },\n\t[ADV7604_PAGE_DPP] = { \"dpp\", 0x3c },\n\t[ADV76XX_PAGE_AFE] = { \"afe\", 0x26 },\n\t[ADV76XX_PAGE_REP] = { \"rep\", 0x32 },\n\t[ADV76XX_PAGE_EDID] = { \"edid\", 0x36 },\n\t[ADV76XX_PAGE_HDMI] = { \"hdmi\", 0x34 },\n\t[ADV76XX_PAGE_TEST] = { \"test\", 0x30 },\n\t[ADV76XX_PAGE_CP] = { \"cp\", 0x22 },\n\t[ADV7604_PAGE_VDP] = { \"vdp\", 0x24 },\n};\n\nstatic int adv76xx_core_init(struct v4l2_subdev *sd)\n{\n\tstruct adv76xx_state *state = to_state(sd);\n\tconst struct adv76xx_chip_info *info = state->info;\n\tstruct adv76xx_platform_data *pdata = &state->pdata;\n\n\thdmi_write(sd, 0x48,\n\t\t(pdata->disable_pwrdnb ? 0x80 : 0) |\n\t\t(pdata->disable_cable_det_rst ? 0x40 : 0));\n\n\tdisable_input(sd);\n\n\tif (pdata->default_input >= 0 &&\n\t    pdata->default_input < state->source_pad) {\n\t\tstate->selected_input = pdata->default_input;\n\t\tselect_input(sd);\n\t\tenable_input(sd);\n\t}\n\n\t \n\tio_write(sd, 0x0c, 0x42);    \n\tio_write(sd, 0x0b, 0x44);    \n\tcp_write(sd, 0xcf, 0x01);    \n\n\t \n\tif (info->type != ADV7604) {\n\t\t \n\t\tio_write_clr_set(sd, 0x20, 0xc0, 0);\n\t\t \n\t\thdmi_write_clr_set(sd, 0x6c, 0xf6, 0x26);\n\t}\n\n\t \n\tio_write_clr_set(sd, 0x02, 0x0f, pdata->alt_gamma << 3);\n\tio_write_clr_set(sd, 0x05, 0x0e, pdata->blank_data << 3 |\n\t\t\tpdata->insert_av_codes << 2 |\n\t\t\tpdata->replicate_av_codes << 1);\n\tadv76xx_setup_format(state);\n\n\tcp_write(sd, 0x69, 0x30);    \n\n\t \n\tio_write(sd, 0x06, 0xa0 | pdata->inv_vs_pol << 2 |\n\t\t pdata->inv_hs_pol << 1 | pdata->inv_llc_pol);\n\n\t \n\tio_write(sd, 0x14, 0x40 | pdata->dr_str_data << 4 |\n\t\t\t\tpdata->dr_str_clk << 2 |\n\t\t\t\tpdata->dr_str_sync);\n\n\tcp_write(sd, 0xba, (pdata->hdmi_free_run_mode << 1) | 0x01);  \n\tcp_write(sd, 0xf3, 0xdc);  \n\tcp_write(sd, 0xf9, 0x23);  \n\tcp_write(sd, 0x45, 0x23);  \n\tcp_write(sd, 0xc9, 0x2d);  \n\n\t \n\thdmi_write_clr_set(sd, 0x15, 0x03, 0x03);  \n\thdmi_write_clr_set(sd, 0x1a, 0x0e, 0x08);  \n\thdmi_write_clr_set(sd, 0x68, 0x06, 0x06);  \n\n\t \n\tafe_write(sd, 0xb5, 0x01);   \n\n\tif (adv76xx_has_afe(state)) {\n\t\tafe_write(sd, 0x02, pdata->ain_sel);  \n\t\tio_write_clr_set(sd, 0x30, 1 << 4, pdata->output_bus_lsb_to_msb << 4);\n\t}\n\n\t \n\tio_write(sd, 0x40, 0xc0 | pdata->int1_config);  \n\tio_write(sd, 0x46, 0x98);  \n\tio_write(sd, 0x6e, info->fmt_change_digital_mask);  \n\tio_write(sd, 0x73, info->cable_det_mask);  \n\tinfo->setup_irqs(sd);\n\n\treturn v4l2_ctrl_handler_setup(sd->ctrl_handler);\n}\n\nstatic void adv7604_setup_irqs(struct v4l2_subdev *sd)\n{\n\tio_write(sd, 0x41, 0xd7);  \n}\n\nstatic void adv7611_setup_irqs(struct v4l2_subdev *sd)\n{\n\tio_write(sd, 0x41, 0xd0);  \n}\n\nstatic void adv7612_setup_irqs(struct v4l2_subdev *sd)\n{\n\tio_write(sd, 0x41, 0xd0);  \n}\n\nstatic void adv76xx_unregister_clients(struct adv76xx_state *state)\n{\n\tunsigned int i;\n\n\tfor (i = 1; i < ARRAY_SIZE(state->i2c_clients); ++i)\n\t\ti2c_unregister_device(state->i2c_clients[i]);\n}\n\nstatic struct i2c_client *adv76xx_dummy_client(struct v4l2_subdev *sd,\n\t\t\t\t\t       unsigned int page)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct adv76xx_state *state = to_state(sd);\n\tstruct adv76xx_platform_data *pdata = &state->pdata;\n\tunsigned int io_reg = 0xf2 + page;\n\tstruct i2c_client *new_client;\n\n\tif (pdata && pdata->i2c_addresses[page])\n\t\tnew_client = i2c_new_dummy_device(client->adapter,\n\t\t\t\t\t   pdata->i2c_addresses[page]);\n\telse\n\t\tnew_client = i2c_new_ancillary_device(client,\n\t\t\t\tadv76xx_default_addresses[page].name,\n\t\t\t\tadv76xx_default_addresses[page].default_addr);\n\n\tif (!IS_ERR(new_client))\n\t\tio_write(sd, io_reg, new_client->addr << 1);\n\n\treturn new_client;\n}\n\nstatic const struct adv76xx_reg_seq adv7604_recommended_settings_afe[] = {\n\t \n\t \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x0d), 0x04 },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x0d), 0x04 },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x3d), 0x00 },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x3e), 0x74 },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x4e), 0x3b },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x57), 0x74 },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x58), 0x63 },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x8d), 0x18 },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x8e), 0x34 },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x93), 0x88 },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x94), 0x2e },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x96), 0x00 },  \n\n\t \n\t \n\t{ ADV76XX_REG(ADV76XX_PAGE_AFE, 0x12), 0x7b },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_AFE, 0x0c), 0x1f },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_CP, 0x3e), 0x04 },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_CP, 0xc3), 0x39 },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_CP, 0x40), 0x5c },  \n\n\t{ ADV76XX_REG_SEQ_TERM, 0 },\n};\n\nstatic const struct adv76xx_reg_seq adv7604_recommended_settings_hdmi[] = {\n\t \n\t \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x0d), 0x84 },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x3d), 0x10 },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x3e), 0x39 },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x4e), 0x3b },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x57), 0xb6 },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x58), 0x03 },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x8d), 0x18 },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x8e), 0x34 },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x93), 0x8b },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x94), 0x2d },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x96), 0x01 },  \n\n\t \n\t \n\t{ ADV76XX_REG(ADV76XX_PAGE_AFE, 0x12), 0xfb },  \n\t{ ADV76XX_REG(ADV76XX_PAGE_AFE, 0x0c), 0x0d },  \n\n\t{ ADV76XX_REG_SEQ_TERM, 0 },\n};\n\nstatic const struct adv76xx_reg_seq adv7611_recommended_settings_hdmi[] = {\n\t \n\t{ ADV76XX_REG(ADV76XX_PAGE_CP, 0x6c), 0x00 },\n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x9b), 0x03 },\n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x6f), 0x08 },\n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x85), 0x1f },\n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x87), 0x70 },\n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x57), 0xda },\n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x58), 0x01 },\n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x03), 0x98 },\n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x4c), 0x44 },\n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x8d), 0x04 },\n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x8e), 0x1e },\n\n\t{ ADV76XX_REG_SEQ_TERM, 0 },\n};\n\nstatic const struct adv76xx_reg_seq adv7612_recommended_settings_hdmi[] = {\n\t{ ADV76XX_REG(ADV76XX_PAGE_CP, 0x6c), 0x00 },\n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x9b), 0x03 },\n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x6f), 0x08 },\n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x85), 0x1f },\n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x87), 0x70 },\n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x57), 0xda },\n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x58), 0x01 },\n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x03), 0x98 },\n\t{ ADV76XX_REG(ADV76XX_PAGE_HDMI, 0x4c), 0x44 },\n\t{ ADV76XX_REG_SEQ_TERM, 0 },\n};\n\nstatic const struct adv76xx_chip_info adv76xx_chip_info[] = {\n\t[ADV7604] = {\n\t\t.type = ADV7604,\n\t\t.has_afe = true,\n\t\t.max_port = ADV7604_PAD_VGA_COMP,\n\t\t.num_dv_ports = 4,\n\t\t.edid_enable_reg = 0x77,\n\t\t.edid_status_reg = 0x7d,\n\t\t.edid_segment_reg = 0x77,\n\t\t.edid_segment_mask = 0x10,\n\t\t.edid_spa_loc_reg = 0x76,\n\t\t.edid_spa_loc_msb_mask = 0x40,\n\t\t.edid_spa_port_b_reg = 0x70,\n\t\t.lcf_reg = 0xb3,\n\t\t.tdms_lock_mask = 0xe0,\n\t\t.cable_det_mask = 0x1e,\n\t\t.fmt_change_digital_mask = 0xc1,\n\t\t.cp_csc = 0xfc,\n\t\t.cec_irq_status = 0x4d,\n\t\t.cec_rx_enable = 0x26,\n\t\t.cec_rx_enable_mask = 0x01,\n\t\t.cec_irq_swap = true,\n\t\t.formats = adv7604_formats,\n\t\t.nformats = ARRAY_SIZE(adv7604_formats),\n\t\t.set_termination = adv7604_set_termination,\n\t\t.setup_irqs = adv7604_setup_irqs,\n\t\t.read_hdmi_pixelclock = adv7604_read_hdmi_pixelclock,\n\t\t.read_cable_det = adv7604_read_cable_det,\n\t\t.recommended_settings = {\n\t\t    [0] = adv7604_recommended_settings_afe,\n\t\t    [1] = adv7604_recommended_settings_hdmi,\n\t\t},\n\t\t.num_recommended_settings = {\n\t\t    [0] = ARRAY_SIZE(adv7604_recommended_settings_afe),\n\t\t    [1] = ARRAY_SIZE(adv7604_recommended_settings_hdmi),\n\t\t},\n\t\t.page_mask = BIT(ADV76XX_PAGE_IO) | BIT(ADV7604_PAGE_AVLINK) |\n\t\t\tBIT(ADV76XX_PAGE_CEC) | BIT(ADV76XX_PAGE_INFOFRAME) |\n\t\t\tBIT(ADV7604_PAGE_ESDP) | BIT(ADV7604_PAGE_DPP) |\n\t\t\tBIT(ADV76XX_PAGE_AFE) | BIT(ADV76XX_PAGE_REP) |\n\t\t\tBIT(ADV76XX_PAGE_EDID) | BIT(ADV76XX_PAGE_HDMI) |\n\t\t\tBIT(ADV76XX_PAGE_TEST) | BIT(ADV76XX_PAGE_CP) |\n\t\t\tBIT(ADV7604_PAGE_VDP),\n\t\t.linewidth_mask = 0xfff,\n\t\t.field0_height_mask = 0xfff,\n\t\t.field1_height_mask = 0xfff,\n\t\t.hfrontporch_mask = 0x3ff,\n\t\t.hsync_mask = 0x3ff,\n\t\t.hbackporch_mask = 0x3ff,\n\t\t.field0_vfrontporch_mask = 0x1fff,\n\t\t.field0_vsync_mask = 0x1fff,\n\t\t.field0_vbackporch_mask = 0x1fff,\n\t\t.field1_vfrontporch_mask = 0x1fff,\n\t\t.field1_vsync_mask = 0x1fff,\n\t\t.field1_vbackporch_mask = 0x1fff,\n\t},\n\t[ADV7611] = {\n\t\t.type = ADV7611,\n\t\t.has_afe = false,\n\t\t.max_port = ADV76XX_PAD_HDMI_PORT_A,\n\t\t.num_dv_ports = 1,\n\t\t.edid_enable_reg = 0x74,\n\t\t.edid_status_reg = 0x76,\n\t\t.edid_segment_reg = 0x7a,\n\t\t.edid_segment_mask = 0x01,\n\t\t.lcf_reg = 0xa3,\n\t\t.tdms_lock_mask = 0x43,\n\t\t.cable_det_mask = 0x01,\n\t\t.fmt_change_digital_mask = 0x03,\n\t\t.cp_csc = 0xf4,\n\t\t.cec_irq_status = 0x93,\n\t\t.cec_rx_enable = 0x2c,\n\t\t.cec_rx_enable_mask = 0x02,\n\t\t.formats = adv7611_formats,\n\t\t.nformats = ARRAY_SIZE(adv7611_formats),\n\t\t.set_termination = adv7611_set_termination,\n\t\t.setup_irqs = adv7611_setup_irqs,\n\t\t.read_hdmi_pixelclock = adv7611_read_hdmi_pixelclock,\n\t\t.read_cable_det = adv7611_read_cable_det,\n\t\t.recommended_settings = {\n\t\t    [1] = adv7611_recommended_settings_hdmi,\n\t\t},\n\t\t.num_recommended_settings = {\n\t\t    [1] = ARRAY_SIZE(adv7611_recommended_settings_hdmi),\n\t\t},\n\t\t.page_mask = BIT(ADV76XX_PAGE_IO) | BIT(ADV76XX_PAGE_CEC) |\n\t\t\tBIT(ADV76XX_PAGE_INFOFRAME) | BIT(ADV76XX_PAGE_AFE) |\n\t\t\tBIT(ADV76XX_PAGE_REP) |  BIT(ADV76XX_PAGE_EDID) |\n\t\t\tBIT(ADV76XX_PAGE_HDMI) | BIT(ADV76XX_PAGE_CP),\n\t\t.linewidth_mask = 0x1fff,\n\t\t.field0_height_mask = 0x1fff,\n\t\t.field1_height_mask = 0x1fff,\n\t\t.hfrontporch_mask = 0x1fff,\n\t\t.hsync_mask = 0x1fff,\n\t\t.hbackporch_mask = 0x1fff,\n\t\t.field0_vfrontporch_mask = 0x3fff,\n\t\t.field0_vsync_mask = 0x3fff,\n\t\t.field0_vbackporch_mask = 0x3fff,\n\t\t.field1_vfrontporch_mask = 0x3fff,\n\t\t.field1_vsync_mask = 0x3fff,\n\t\t.field1_vbackporch_mask = 0x3fff,\n\t},\n\t[ADV7612] = {\n\t\t.type = ADV7612,\n\t\t.has_afe = false,\n\t\t.max_port = ADV76XX_PAD_HDMI_PORT_A,\t \n\t\t.num_dv_ports = 1,\t\t\t \n\t\t.edid_enable_reg = 0x74,\n\t\t.edid_status_reg = 0x76,\n\t\t.edid_segment_reg = 0x7a,\n\t\t.edid_segment_mask = 0x01,\n\t\t.edid_spa_loc_reg = 0x70,\n\t\t.edid_spa_loc_msb_mask = 0x01,\n\t\t.edid_spa_port_b_reg = 0x52,\n\t\t.lcf_reg = 0xa3,\n\t\t.tdms_lock_mask = 0x43,\n\t\t.cable_det_mask = 0x01,\n\t\t.fmt_change_digital_mask = 0x03,\n\t\t.cp_csc = 0xf4,\n\t\t.cec_irq_status = 0x93,\n\t\t.cec_rx_enable = 0x2c,\n\t\t.cec_rx_enable_mask = 0x02,\n\t\t.formats = adv7612_formats,\n\t\t.nformats = ARRAY_SIZE(adv7612_formats),\n\t\t.set_termination = adv7611_set_termination,\n\t\t.setup_irqs = adv7612_setup_irqs,\n\t\t.read_hdmi_pixelclock = adv7611_read_hdmi_pixelclock,\n\t\t.read_cable_det = adv7612_read_cable_det,\n\t\t.recommended_settings = {\n\t\t    [1] = adv7612_recommended_settings_hdmi,\n\t\t},\n\t\t.num_recommended_settings = {\n\t\t    [1] = ARRAY_SIZE(adv7612_recommended_settings_hdmi),\n\t\t},\n\t\t.page_mask = BIT(ADV76XX_PAGE_IO) | BIT(ADV76XX_PAGE_CEC) |\n\t\t\tBIT(ADV76XX_PAGE_INFOFRAME) | BIT(ADV76XX_PAGE_AFE) |\n\t\t\tBIT(ADV76XX_PAGE_REP) |  BIT(ADV76XX_PAGE_EDID) |\n\t\t\tBIT(ADV76XX_PAGE_HDMI) | BIT(ADV76XX_PAGE_CP),\n\t\t.linewidth_mask = 0x1fff,\n\t\t.field0_height_mask = 0x1fff,\n\t\t.field1_height_mask = 0x1fff,\n\t\t.hfrontporch_mask = 0x1fff,\n\t\t.hsync_mask = 0x1fff,\n\t\t.hbackporch_mask = 0x1fff,\n\t\t.field0_vfrontporch_mask = 0x3fff,\n\t\t.field0_vsync_mask = 0x3fff,\n\t\t.field0_vbackporch_mask = 0x3fff,\n\t\t.field1_vfrontporch_mask = 0x3fff,\n\t\t.field1_vsync_mask = 0x3fff,\n\t\t.field1_vbackporch_mask = 0x3fff,\n\t},\n};\n\nstatic const struct i2c_device_id adv76xx_i2c_id[] = {\n\t{ \"adv7604\", (kernel_ulong_t)&adv76xx_chip_info[ADV7604] },\n\t{ \"adv7610\", (kernel_ulong_t)&adv76xx_chip_info[ADV7611] },\n\t{ \"adv7611\", (kernel_ulong_t)&adv76xx_chip_info[ADV7611] },\n\t{ \"adv7612\", (kernel_ulong_t)&adv76xx_chip_info[ADV7612] },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adv76xx_i2c_id);\n\nstatic const struct of_device_id adv76xx_of_id[] __maybe_unused = {\n\t{ .compatible = \"adi,adv7610\", .data = &adv76xx_chip_info[ADV7611] },\n\t{ .compatible = \"adi,adv7611\", .data = &adv76xx_chip_info[ADV7611] },\n\t{ .compatible = \"adi,adv7612\", .data = &adv76xx_chip_info[ADV7612] },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, adv76xx_of_id);\n\nstatic int adv76xx_parse_dt(struct adv76xx_state *state)\n{\n\tstruct v4l2_fwnode_endpoint bus_cfg = { .bus_type = 0 };\n\tstruct device_node *endpoint;\n\tstruct device_node *np;\n\tunsigned int flags;\n\tint ret;\n\tu32 v;\n\n\tnp = state->i2c_clients[ADV76XX_PAGE_IO]->dev.of_node;\n\n\t \n\tendpoint = of_graph_get_next_endpoint(np, NULL);\n\tif (!endpoint)\n\t\treturn -EINVAL;\n\n\tret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(endpoint), &bus_cfg);\n\tof_node_put(endpoint);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!of_property_read_u32(np, \"default-input\", &v))\n\t\tstate->pdata.default_input = v;\n\telse\n\t\tstate->pdata.default_input = -1;\n\n\tflags = bus_cfg.bus.parallel.flags;\n\n\tif (flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)\n\t\tstate->pdata.inv_hs_pol = 1;\n\n\tif (flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)\n\t\tstate->pdata.inv_vs_pol = 1;\n\n\tif (flags & V4L2_MBUS_PCLK_SAMPLE_RISING)\n\t\tstate->pdata.inv_llc_pol = 1;\n\n\tif (bus_cfg.bus_type == V4L2_MBUS_BT656)\n\t\tstate->pdata.insert_av_codes = 1;\n\n\t \n\tstate->pdata.int1_config = ADV76XX_INT1_CONFIG_ACTIVE_HIGH;\n\n\t \n\tstate->pdata.disable_pwrdnb = 0;\n\tstate->pdata.disable_cable_det_rst = 0;\n\tstate->pdata.blank_data = 1;\n\tstate->pdata.op_format_mode_sel = ADV7604_OP_FORMAT_MODE0;\n\tstate->pdata.bus_order = ADV7604_BUS_ORDER_RGB;\n\tstate->pdata.dr_str_data = ADV76XX_DR_STR_MEDIUM_HIGH;\n\tstate->pdata.dr_str_clk = ADV76XX_DR_STR_MEDIUM_HIGH;\n\tstate->pdata.dr_str_sync = ADV76XX_DR_STR_MEDIUM_HIGH;\n\n\treturn 0;\n}\n\nstatic const struct regmap_config adv76xx_regmap_cnf[] = {\n\t{\n\t\t.name\t\t\t= \"io\",\n\t\t.reg_bits\t\t= 8,\n\t\t.val_bits\t\t= 8,\n\n\t\t.max_register\t\t= 0xff,\n\t\t.cache_type\t\t= REGCACHE_NONE,\n\t},\n\t{\n\t\t.name\t\t\t= \"avlink\",\n\t\t.reg_bits\t\t= 8,\n\t\t.val_bits\t\t= 8,\n\n\t\t.max_register\t\t= 0xff,\n\t\t.cache_type\t\t= REGCACHE_NONE,\n\t},\n\t{\n\t\t.name\t\t\t= \"cec\",\n\t\t.reg_bits\t\t= 8,\n\t\t.val_bits\t\t= 8,\n\n\t\t.max_register\t\t= 0xff,\n\t\t.cache_type\t\t= REGCACHE_NONE,\n\t},\n\t{\n\t\t.name\t\t\t= \"infoframe\",\n\t\t.reg_bits\t\t= 8,\n\t\t.val_bits\t\t= 8,\n\n\t\t.max_register\t\t= 0xff,\n\t\t.cache_type\t\t= REGCACHE_NONE,\n\t},\n\t{\n\t\t.name\t\t\t= \"esdp\",\n\t\t.reg_bits\t\t= 8,\n\t\t.val_bits\t\t= 8,\n\n\t\t.max_register\t\t= 0xff,\n\t\t.cache_type\t\t= REGCACHE_NONE,\n\t},\n\t{\n\t\t.name\t\t\t= \"epp\",\n\t\t.reg_bits\t\t= 8,\n\t\t.val_bits\t\t= 8,\n\n\t\t.max_register\t\t= 0xff,\n\t\t.cache_type\t\t= REGCACHE_NONE,\n\t},\n\t{\n\t\t.name\t\t\t= \"afe\",\n\t\t.reg_bits\t\t= 8,\n\t\t.val_bits\t\t= 8,\n\n\t\t.max_register\t\t= 0xff,\n\t\t.cache_type\t\t= REGCACHE_NONE,\n\t},\n\t{\n\t\t.name\t\t\t= \"rep\",\n\t\t.reg_bits\t\t= 8,\n\t\t.val_bits\t\t= 8,\n\n\t\t.max_register\t\t= 0xff,\n\t\t.cache_type\t\t= REGCACHE_NONE,\n\t},\n\t{\n\t\t.name\t\t\t= \"edid\",\n\t\t.reg_bits\t\t= 8,\n\t\t.val_bits\t\t= 8,\n\n\t\t.max_register\t\t= 0xff,\n\t\t.cache_type\t\t= REGCACHE_NONE,\n\t},\n\n\t{\n\t\t.name\t\t\t= \"hdmi\",\n\t\t.reg_bits\t\t= 8,\n\t\t.val_bits\t\t= 8,\n\n\t\t.max_register\t\t= 0xff,\n\t\t.cache_type\t\t= REGCACHE_NONE,\n\t},\n\t{\n\t\t.name\t\t\t= \"test\",\n\t\t.reg_bits\t\t= 8,\n\t\t.val_bits\t\t= 8,\n\n\t\t.max_register\t\t= 0xff,\n\t\t.cache_type\t\t= REGCACHE_NONE,\n\t},\n\t{\n\t\t.name\t\t\t= \"cp\",\n\t\t.reg_bits\t\t= 8,\n\t\t.val_bits\t\t= 8,\n\n\t\t.max_register\t\t= 0xff,\n\t\t.cache_type\t\t= REGCACHE_NONE,\n\t},\n\t{\n\t\t.name\t\t\t= \"vdp\",\n\t\t.reg_bits\t\t= 8,\n\t\t.val_bits\t\t= 8,\n\n\t\t.max_register\t\t= 0xff,\n\t\t.cache_type\t\t= REGCACHE_NONE,\n\t},\n};\n\nstatic int configure_regmap(struct adv76xx_state *state, int region)\n{\n\tint err;\n\n\tif (!state->i2c_clients[region])\n\t\treturn -ENODEV;\n\n\tstate->regmap[region] =\n\t\tdevm_regmap_init_i2c(state->i2c_clients[region],\n\t\t\t\t     &adv76xx_regmap_cnf[region]);\n\n\tif (IS_ERR(state->regmap[region])) {\n\t\terr = PTR_ERR(state->regmap[region]);\n\t\tv4l_err(state->i2c_clients[region],\n\t\t\t\"Error initializing regmap %d with error %d\\n\",\n\t\t\tregion, err);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int configure_regmaps(struct adv76xx_state *state)\n{\n\tint i, err;\n\n\tfor (i = ADV7604_PAGE_AVLINK ; i < ADV76XX_PAGE_MAX; i++) {\n\t\terr = configure_regmap(state, i);\n\t\tif (err && (err != -ENODEV))\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void adv76xx_reset(struct adv76xx_state *state)\n{\n\tif (state->reset_gpio) {\n\t\t \n\t\tgpiod_set_value_cansleep(state->reset_gpio, 0);\n\t\tusleep_range(5000, 10000);\n\t\tgpiod_set_value_cansleep(state->reset_gpio, 1);\n\t\t \n\t\t \n\t\tusleep_range(5000, 10000);\n\t}\n}\n\nstatic int adv76xx_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstatic const struct v4l2_dv_timings cea640x480 =\n\t\tV4L2_DV_BT_CEA_640X480P59_94;\n\tstruct adv76xx_state *state;\n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct v4l2_ctrl *ctrl;\n\tstruct v4l2_subdev *sd;\n\tunsigned int i;\n\tunsigned int val, val2;\n\tint err;\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\tv4l_dbg(1, debug, client, \"detecting adv76xx client on address 0x%x\\n\",\n\t\t\tclient->addr << 1);\n\n\tstate = devm_kzalloc(&client->dev, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->i2c_clients[ADV76XX_PAGE_IO] = client;\n\n\t \n\tstate->restart_stdi_once = true;\n\tstate->selected_input = ~0;\n\n\tif (IS_ENABLED(CONFIG_OF) && client->dev.of_node) {\n\t\tconst struct of_device_id *oid;\n\n\t\toid = of_match_node(adv76xx_of_id, client->dev.of_node);\n\t\tstate->info = oid->data;\n\n\t\terr = adv76xx_parse_dt(state);\n\t\tif (err < 0) {\n\t\t\tv4l_err(client, \"DT parsing error\\n\");\n\t\t\treturn err;\n\t\t}\n\t} else if (client->dev.platform_data) {\n\t\tstruct adv76xx_platform_data *pdata = client->dev.platform_data;\n\n\t\tstate->info = (const struct adv76xx_chip_info *)id->driver_data;\n\t\tstate->pdata = *pdata;\n\t} else {\n\t\tv4l_err(client, \"No platform data!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tfor (i = 0; i < state->info->num_dv_ports; ++i) {\n\t\tstate->hpd_gpio[i] =\n\t\t\tdevm_gpiod_get_index_optional(&client->dev, \"hpd\", i,\n\t\t\t\t\t\t      GPIOD_OUT_LOW);\n\t\tif (IS_ERR(state->hpd_gpio[i]))\n\t\t\treturn PTR_ERR(state->hpd_gpio[i]);\n\n\t\tif (state->hpd_gpio[i])\n\t\t\tv4l_info(client, \"Handling HPD %u GPIO\\n\", i);\n\t}\n\tstate->reset_gpio = devm_gpiod_get_optional(&client->dev, \"reset\",\n\t\t\t\t\t\t\t\tGPIOD_OUT_HIGH);\n\tif (IS_ERR(state->reset_gpio))\n\t\treturn PTR_ERR(state->reset_gpio);\n\n\tadv76xx_reset(state);\n\n\tstate->timings = cea640x480;\n\tstate->format = adv76xx_format_info(state, MEDIA_BUS_FMT_YUYV8_2X8);\n\n\tsd = &state->sd;\n\tv4l2_i2c_subdev_init(sd, client, &adv76xx_ops);\n\tsnprintf(sd->name, sizeof(sd->name), \"%s %d-%04x\",\n\t\tid->name, i2c_adapter_id(client->adapter),\n\t\tclient->addr);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;\n\tsd->internal_ops = &adv76xx_int_ops;\n\n\t \n\terr = configure_regmap(state, ADV76XX_PAGE_IO);\n\n\tif (err) {\n\t\tv4l2_err(sd, \"Error configuring IO regmap region\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tswitch (state->info->type) {\n\tcase ADV7604:\n\t\terr = regmap_read(state->regmap[ADV76XX_PAGE_IO], 0xfb, &val);\n\t\tif (err) {\n\t\t\tv4l2_err(sd, \"Error %d reading IO Regmap\\n\", err);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (val != 0x68) {\n\t\t\tv4l2_err(sd, \"not an ADV7604 on address 0x%x\\n\",\n\t\t\t\t client->addr << 1);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tbreak;\n\tcase ADV7611:\n\tcase ADV7612:\n\t\terr = regmap_read(state->regmap[ADV76XX_PAGE_IO],\n\t\t\t\t0xea,\n\t\t\t\t&val);\n\t\tif (err) {\n\t\t\tv4l2_err(sd, \"Error %d reading IO Regmap\\n\", err);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tval2 = val << 8;\n\t\terr = regmap_read(state->regmap[ADV76XX_PAGE_IO],\n\t\t\t    0xeb,\n\t\t\t    &val);\n\t\tif (err) {\n\t\t\tv4l2_err(sd, \"Error %d reading IO Regmap\\n\", err);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tval |= val2;\n\t\tif ((state->info->type == ADV7611 && val != 0x2051) ||\n\t\t\t(state->info->type == ADV7612 && val != 0x2041)) {\n\t\t\tv4l2_err(sd, \"not an %s on address 0x%x\\n\",\n\t\t\t\t state->info->type == ADV7611 ? \"ADV7610/11\" : \"ADV7612\",\n\t\t\t\t client->addr << 1);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\thdl = &state->hdl;\n\tv4l2_ctrl_handler_init(hdl, adv76xx_has_afe(state) ? 9 : 8);\n\n\tv4l2_ctrl_new_std(hdl, &adv76xx_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &adv76xx_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(hdl, &adv76xx_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(hdl, &adv76xx_ctrl_ops,\n\t\t\tV4L2_CID_HUE, 0, 255, 1, 0);\n\tctrl = v4l2_ctrl_new_std_menu(hdl, &adv76xx_ctrl_ops,\n\t\t\tV4L2_CID_DV_RX_IT_CONTENT_TYPE, V4L2_DV_IT_CONTENT_TYPE_NO_ITC,\n\t\t\t0, V4L2_DV_IT_CONTENT_TYPE_NO_ITC);\n\tif (ctrl)\n\t\tctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\n\tstate->detect_tx_5v_ctrl = v4l2_ctrl_new_std(hdl, NULL,\n\t\t\tV4L2_CID_DV_RX_POWER_PRESENT, 0,\n\t\t\t(1 << state->info->num_dv_ports) - 1, 0, 0);\n\tstate->rgb_quantization_range_ctrl =\n\t\tv4l2_ctrl_new_std_menu(hdl, &adv76xx_ctrl_ops,\n\t\t\tV4L2_CID_DV_RX_RGB_RANGE, V4L2_DV_RGB_RANGE_FULL,\n\t\t\t0, V4L2_DV_RGB_RANGE_AUTO);\n\n\t \n\tif (adv76xx_has_afe(state))\n\t\tstate->analog_sampling_phase_ctrl =\n\t\t\tv4l2_ctrl_new_custom(hdl, &adv7604_ctrl_analog_sampling_phase, NULL);\n\tstate->free_run_color_manual_ctrl =\n\t\tv4l2_ctrl_new_custom(hdl, &adv76xx_ctrl_free_run_color_manual, NULL);\n\tstate->free_run_color_ctrl =\n\t\tv4l2_ctrl_new_custom(hdl, &adv76xx_ctrl_free_run_color, NULL);\n\n\tsd->ctrl_handler = hdl;\n\tif (hdl->error) {\n\t\terr = hdl->error;\n\t\tgoto err_hdl;\n\t}\n\tif (adv76xx_s_detect_tx_5v_ctrl(sd)) {\n\t\terr = -ENODEV;\n\t\tgoto err_hdl;\n\t}\n\n\tfor (i = 1; i < ADV76XX_PAGE_MAX; ++i) {\n\t\tstruct i2c_client *dummy_client;\n\n\t\tif (!(BIT(i) & state->info->page_mask))\n\t\t\tcontinue;\n\n\t\tdummy_client = adv76xx_dummy_client(sd, i);\n\t\tif (IS_ERR(dummy_client)) {\n\t\t\terr = PTR_ERR(dummy_client);\n\t\t\tv4l2_err(sd, \"failed to create i2c client %u\\n\", i);\n\t\t\tgoto err_i2c;\n\t\t}\n\n\t\tstate->i2c_clients[i] = dummy_client;\n\t}\n\n\tINIT_DELAYED_WORK(&state->delayed_work_enable_hotplug,\n\t\t\tadv76xx_delayed_work_enable_hotplug);\n\n\tstate->source_pad = state->info->num_dv_ports\n\t\t\t  + (state->info->has_afe ? 2 : 0);\n\tfor (i = 0; i < state->source_pad; ++i)\n\t\tstate->pads[i].flags = MEDIA_PAD_FL_SINK;\n\tstate->pads[state->source_pad].flags = MEDIA_PAD_FL_SOURCE;\n\tsd->entity.function = MEDIA_ENT_F_DV_DECODER;\n\n\terr = media_entity_pads_init(&sd->entity, state->source_pad + 1,\n\t\t\t\tstate->pads);\n\tif (err)\n\t\tgoto err_work_queues;\n\n\t \n\terr = configure_regmaps(state);\n\tif (err)\n\t\tgoto err_entity;\n\n\terr = adv76xx_core_init(sd);\n\tif (err)\n\t\tgoto err_entity;\n\n\tif (client->irq) {\n\t\terr = devm_request_threaded_irq(&client->dev,\n\t\t\t\t\t\tclient->irq,\n\t\t\t\t\t\tNULL, adv76xx_irq_handler,\n\t\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\t\tclient->name, state);\n\t\tif (err)\n\t\t\tgoto err_entity;\n\t}\n\n#if IS_ENABLED(CONFIG_VIDEO_ADV7604_CEC)\n\tstate->cec_adap = cec_allocate_adapter(&adv76xx_cec_adap_ops,\n\t\tstate, dev_name(&client->dev),\n\t\tCEC_CAP_DEFAULTS, ADV76XX_MAX_ADDRS);\n\terr = PTR_ERR_OR_ZERO(state->cec_adap);\n\tif (err)\n\t\tgoto err_entity;\n#endif\n\n\tv4l2_info(sd, \"%s found @ 0x%x (%s)\\n\", client->name,\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\terr = v4l2_async_register_subdev(sd);\n\tif (err)\n\t\tgoto err_entity;\n\n\treturn 0;\n\nerr_entity:\n\tmedia_entity_cleanup(&sd->entity);\nerr_work_queues:\n\tcancel_delayed_work(&state->delayed_work_enable_hotplug);\nerr_i2c:\n\tadv76xx_unregister_clients(state);\nerr_hdl:\n\tv4l2_ctrl_handler_free(hdl);\n\treturn err;\n}\n\n \n\nstatic void adv76xx_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct adv76xx_state *state = to_state(sd);\n\n\t \n\tio_write(sd, 0x40, 0);\n\tio_write(sd, 0x41, 0);\n\tio_write(sd, 0x46, 0);\n\tio_write(sd, 0x6e, 0);\n\tio_write(sd, 0x73, 0);\n\n\tcancel_delayed_work_sync(&state->delayed_work_enable_hotplug);\n\tv4l2_async_unregister_subdev(sd);\n\tmedia_entity_cleanup(&sd->entity);\n\tadv76xx_unregister_clients(to_state(sd));\n\tv4l2_ctrl_handler_free(sd->ctrl_handler);\n}\n\n \n\nstatic struct i2c_driver adv76xx_driver = {\n\t.driver = {\n\t\t.name = \"adv7604\",\n\t\t.of_match_table = of_match_ptr(adv76xx_of_id),\n\t},\n\t.probe = adv76xx_probe,\n\t.remove = adv76xx_remove,\n\t.id_table = adv76xx_i2c_id,\n};\n\nmodule_i2c_driver(adv76xx_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}