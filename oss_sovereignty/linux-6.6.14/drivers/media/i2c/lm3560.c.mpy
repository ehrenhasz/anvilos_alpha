{
  "module_name": "lm3560.c",
  "hash_id": "7bc442384aa2909d3199ba4eb20dcc79dd0ef94710802e7a40e745632002a243",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/lm3560.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n#include <linux/videodev2.h>\n#include <media/i2c/lm3560.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n\n \n#define REG_ENABLE\t\t0x10\n#define REG_TORCH_BR\t0xa0\n#define REG_FLASH_BR\t0xb0\n#define REG_FLASH_TOUT\t0xc0\n#define REG_FLAG\t\t0xd0\n#define REG_CONFIG1\t\t0xe0\n\n \n#define FAULT_TIMEOUT\t(1<<0)\n#define FAULT_OVERTEMP\t(1<<1)\n#define FAULT_SHORT_CIRCUIT\t(1<<2)\n\nenum led_enable {\n\tMODE_SHDN = 0x0,\n\tMODE_TORCH = 0x2,\n\tMODE_FLASH = 0x3,\n};\n\n \nstruct lm3560_flash {\n\tstruct device *dev;\n\tstruct lm3560_platform_data *pdata;\n\tstruct regmap *regmap;\n\tstruct mutex lock;\n\n\tenum v4l2_flash_led_mode led_mode;\n\tstruct v4l2_ctrl_handler ctrls_led[LM3560_LED_MAX];\n\tstruct v4l2_subdev subdev_led[LM3560_LED_MAX];\n};\n\n#define to_lm3560_flash(_ctrl, _no)\t\\\n\tcontainer_of(_ctrl->handler, struct lm3560_flash, ctrls_led[_no])\n\n \nstatic int lm3560_mode_ctrl(struct lm3560_flash *flash)\n{\n\tint rval = -EINVAL;\n\n\tswitch (flash->led_mode) {\n\tcase V4L2_FLASH_LED_MODE_NONE:\n\t\trval = regmap_update_bits(flash->regmap,\n\t\t\t\t\t  REG_ENABLE, 0x03, MODE_SHDN);\n\t\tbreak;\n\tcase V4L2_FLASH_LED_MODE_TORCH:\n\t\trval = regmap_update_bits(flash->regmap,\n\t\t\t\t\t  REG_ENABLE, 0x03, MODE_TORCH);\n\t\tbreak;\n\tcase V4L2_FLASH_LED_MODE_FLASH:\n\t\trval = regmap_update_bits(flash->regmap,\n\t\t\t\t\t  REG_ENABLE, 0x03, MODE_FLASH);\n\t\tbreak;\n\t}\n\treturn rval;\n}\n\n \nstatic int lm3560_enable_ctrl(struct lm3560_flash *flash,\n\t\t\t      enum lm3560_led_id led_no, bool on)\n{\n\tint rval;\n\n\tif (led_no == LM3560_LED0) {\n\t\tif (on)\n\t\t\trval = regmap_update_bits(flash->regmap,\n\t\t\t\t\t\t  REG_ENABLE, 0x08, 0x08);\n\t\telse\n\t\t\trval = regmap_update_bits(flash->regmap,\n\t\t\t\t\t\t  REG_ENABLE, 0x08, 0x00);\n\t} else {\n\t\tif (on)\n\t\t\trval = regmap_update_bits(flash->regmap,\n\t\t\t\t\t\t  REG_ENABLE, 0x10, 0x10);\n\t\telse\n\t\t\trval = regmap_update_bits(flash->regmap,\n\t\t\t\t\t\t  REG_ENABLE, 0x10, 0x00);\n\t}\n\treturn rval;\n}\n\n \nstatic int lm3560_torch_brt_ctrl(struct lm3560_flash *flash,\n\t\t\t\t enum lm3560_led_id led_no, unsigned int brt)\n{\n\tint rval;\n\tu8 br_bits;\n\n\tif (brt < LM3560_TORCH_BRT_MIN)\n\t\treturn lm3560_enable_ctrl(flash, led_no, false);\n\telse\n\t\trval = lm3560_enable_ctrl(flash, led_no, true);\n\n\tbr_bits = LM3560_TORCH_BRT_uA_TO_REG(brt);\n\tif (led_no == LM3560_LED0)\n\t\trval = regmap_update_bits(flash->regmap,\n\t\t\t\t\t  REG_TORCH_BR, 0x07, br_bits);\n\telse\n\t\trval = regmap_update_bits(flash->regmap,\n\t\t\t\t\t  REG_TORCH_BR, 0x38, br_bits << 3);\n\n\treturn rval;\n}\n\n \nstatic int lm3560_flash_brt_ctrl(struct lm3560_flash *flash,\n\t\t\t\t enum lm3560_led_id led_no, unsigned int brt)\n{\n\tint rval;\n\tu8 br_bits;\n\n\tif (brt < LM3560_FLASH_BRT_MIN)\n\t\treturn lm3560_enable_ctrl(flash, led_no, false);\n\telse\n\t\trval = lm3560_enable_ctrl(flash, led_no, true);\n\n\tbr_bits = LM3560_FLASH_BRT_uA_TO_REG(brt);\n\tif (led_no == LM3560_LED0)\n\t\trval = regmap_update_bits(flash->regmap,\n\t\t\t\t\t  REG_FLASH_BR, 0x0f, br_bits);\n\telse\n\t\trval = regmap_update_bits(flash->regmap,\n\t\t\t\t\t  REG_FLASH_BR, 0xf0, br_bits << 4);\n\n\treturn rval;\n}\n\n \nstatic int lm3560_get_ctrl(struct v4l2_ctrl *ctrl, enum lm3560_led_id led_no)\n{\n\tstruct lm3560_flash *flash = to_lm3560_flash(ctrl, led_no);\n\tint rval = -EINVAL;\n\n\tmutex_lock(&flash->lock);\n\n\tif (ctrl->id == V4L2_CID_FLASH_FAULT) {\n\t\ts32 fault = 0;\n\t\tunsigned int reg_val;\n\t\trval = regmap_read(flash->regmap, REG_FLAG, &reg_val);\n\t\tif (rval < 0)\n\t\t\tgoto out;\n\t\tif (reg_val & FAULT_SHORT_CIRCUIT)\n\t\t\tfault |= V4L2_FLASH_FAULT_SHORT_CIRCUIT;\n\t\tif (reg_val & FAULT_OVERTEMP)\n\t\t\tfault |= V4L2_FLASH_FAULT_OVER_TEMPERATURE;\n\t\tif (reg_val & FAULT_TIMEOUT)\n\t\t\tfault |= V4L2_FLASH_FAULT_TIMEOUT;\n\t\tctrl->cur.val = fault;\n\t}\n\nout:\n\tmutex_unlock(&flash->lock);\n\treturn rval;\n}\n\nstatic int lm3560_set_ctrl(struct v4l2_ctrl *ctrl, enum lm3560_led_id led_no)\n{\n\tstruct lm3560_flash *flash = to_lm3560_flash(ctrl, led_no);\n\tu8 tout_bits;\n\tint rval = -EINVAL;\n\n\tmutex_lock(&flash->lock);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_FLASH_LED_MODE:\n\t\tflash->led_mode = ctrl->val;\n\t\tif (flash->led_mode != V4L2_FLASH_LED_MODE_FLASH)\n\t\t\trval = lm3560_mode_ctrl(flash);\n\t\tbreak;\n\n\tcase V4L2_CID_FLASH_STROBE_SOURCE:\n\t\trval = regmap_update_bits(flash->regmap,\n\t\t\t\t\t  REG_CONFIG1, 0x04, (ctrl->val) << 2);\n\t\tif (rval < 0)\n\t\t\tgoto err_out;\n\t\tbreak;\n\n\tcase V4L2_CID_FLASH_STROBE:\n\t\tif (flash->led_mode != V4L2_FLASH_LED_MODE_FLASH) {\n\t\t\trval = -EBUSY;\n\t\t\tgoto err_out;\n\t\t}\n\t\tflash->led_mode = V4L2_FLASH_LED_MODE_FLASH;\n\t\trval = lm3560_mode_ctrl(flash);\n\t\tbreak;\n\n\tcase V4L2_CID_FLASH_STROBE_STOP:\n\t\tif (flash->led_mode != V4L2_FLASH_LED_MODE_FLASH) {\n\t\t\trval = -EBUSY;\n\t\t\tgoto err_out;\n\t\t}\n\t\tflash->led_mode = V4L2_FLASH_LED_MODE_NONE;\n\t\trval = lm3560_mode_ctrl(flash);\n\t\tbreak;\n\n\tcase V4L2_CID_FLASH_TIMEOUT:\n\t\ttout_bits = LM3560_FLASH_TOUT_ms_TO_REG(ctrl->val);\n\t\trval = regmap_update_bits(flash->regmap,\n\t\t\t\t\t  REG_FLASH_TOUT, 0x1f, tout_bits);\n\t\tbreak;\n\n\tcase V4L2_CID_FLASH_INTENSITY:\n\t\trval = lm3560_flash_brt_ctrl(flash, led_no, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_FLASH_TORCH_INTENSITY:\n\t\trval = lm3560_torch_brt_ctrl(flash, led_no, ctrl->val);\n\t\tbreak;\n\t}\n\nerr_out:\n\tmutex_unlock(&flash->lock);\n\treturn rval;\n}\n\nstatic int lm3560_led1_get_ctrl(struct v4l2_ctrl *ctrl)\n{\n\treturn lm3560_get_ctrl(ctrl, LM3560_LED1);\n}\n\nstatic int lm3560_led1_set_ctrl(struct v4l2_ctrl *ctrl)\n{\n\treturn lm3560_set_ctrl(ctrl, LM3560_LED1);\n}\n\nstatic int lm3560_led0_get_ctrl(struct v4l2_ctrl *ctrl)\n{\n\treturn lm3560_get_ctrl(ctrl, LM3560_LED0);\n}\n\nstatic int lm3560_led0_set_ctrl(struct v4l2_ctrl *ctrl)\n{\n\treturn lm3560_set_ctrl(ctrl, LM3560_LED0);\n}\n\nstatic const struct v4l2_ctrl_ops lm3560_led_ctrl_ops[LM3560_LED_MAX] = {\n\t[LM3560_LED0] = {\n\t\t\t .g_volatile_ctrl = lm3560_led0_get_ctrl,\n\t\t\t .s_ctrl = lm3560_led0_set_ctrl,\n\t\t\t },\n\t[LM3560_LED1] = {\n\t\t\t .g_volatile_ctrl = lm3560_led1_get_ctrl,\n\t\t\t .s_ctrl = lm3560_led1_set_ctrl,\n\t\t\t }\n};\n\nstatic int lm3560_init_controls(struct lm3560_flash *flash,\n\t\t\t\tenum lm3560_led_id led_no)\n{\n\tstruct v4l2_ctrl *fault;\n\tu32 max_flash_brt = flash->pdata->max_flash_brt[led_no];\n\tu32 max_torch_brt = flash->pdata->max_torch_brt[led_no];\n\tstruct v4l2_ctrl_handler *hdl = &flash->ctrls_led[led_no];\n\tconst struct v4l2_ctrl_ops *ops = &lm3560_led_ctrl_ops[led_no];\n\n\tv4l2_ctrl_handler_init(hdl, 8);\n\n\t \n\tv4l2_ctrl_new_std_menu(hdl, ops, V4L2_CID_FLASH_LED_MODE,\n\t\t\t       V4L2_FLASH_LED_MODE_TORCH, ~0x7,\n\t\t\t       V4L2_FLASH_LED_MODE_NONE);\n\tflash->led_mode = V4L2_FLASH_LED_MODE_NONE;\n\n\t \n\tv4l2_ctrl_new_std_menu(hdl, ops, V4L2_CID_FLASH_STROBE_SOURCE,\n\t\t\t       0x1, ~0x3, V4L2_FLASH_STROBE_SOURCE_SOFTWARE);\n\n\t \n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_FLASH_STROBE, 0, 0, 0, 0);\n\n\t \n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_FLASH_STROBE_STOP, 0, 0, 0, 0);\n\n\t \n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_FLASH_TIMEOUT,\n\t\t\t  LM3560_FLASH_TOUT_MIN,\n\t\t\t  flash->pdata->max_flash_timeout,\n\t\t\t  LM3560_FLASH_TOUT_STEP,\n\t\t\t  flash->pdata->max_flash_timeout);\n\n\t \n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_FLASH_INTENSITY,\n\t\t\t  LM3560_FLASH_BRT_MIN, max_flash_brt,\n\t\t\t  LM3560_FLASH_BRT_STEP, max_flash_brt);\n\n\t \n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_FLASH_TORCH_INTENSITY,\n\t\t\t  LM3560_TORCH_BRT_MIN, max_torch_brt,\n\t\t\t  LM3560_TORCH_BRT_STEP, max_torch_brt);\n\n\t \n\tfault = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_FLASH_FAULT, 0,\n\t\t\t\t  V4L2_FLASH_FAULT_OVER_VOLTAGE\n\t\t\t\t  | V4L2_FLASH_FAULT_OVER_TEMPERATURE\n\t\t\t\t  | V4L2_FLASH_FAULT_SHORT_CIRCUIT\n\t\t\t\t  | V4L2_FLASH_FAULT_TIMEOUT, 0, 0);\n\tif (fault != NULL)\n\t\tfault->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\n\tif (hdl->error)\n\t\treturn hdl->error;\n\n\tflash->subdev_led[led_no].ctrl_handler = hdl;\n\treturn 0;\n}\n\n \nstatic const struct v4l2_subdev_ops lm3560_ops = {\n\t.core = NULL,\n};\n\nstatic const struct regmap_config lm3560_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xFF,\n};\n\nstatic int lm3560_subdev_init(struct lm3560_flash *flash,\n\t\t\t      enum lm3560_led_id led_no, char *led_name)\n{\n\tstruct i2c_client *client = to_i2c_client(flash->dev);\n\tint rval;\n\n\tv4l2_i2c_subdev_init(&flash->subdev_led[led_no], client, &lm3560_ops);\n\tflash->subdev_led[led_no].flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tstrscpy(flash->subdev_led[led_no].name, led_name,\n\t\tsizeof(flash->subdev_led[led_no].name));\n\trval = lm3560_init_controls(flash, led_no);\n\tif (rval)\n\t\tgoto err_out;\n\trval = media_entity_pads_init(&flash->subdev_led[led_no].entity, 0, NULL);\n\tif (rval < 0)\n\t\tgoto err_out;\n\tflash->subdev_led[led_no].entity.function = MEDIA_ENT_F_FLASH;\n\n\treturn rval;\n\nerr_out:\n\tv4l2_ctrl_handler_free(&flash->ctrls_led[led_no]);\n\treturn rval;\n}\n\nstatic int lm3560_init_device(struct lm3560_flash *flash)\n{\n\tint rval;\n\tunsigned int reg_val;\n\n\t \n\trval = regmap_update_bits(flash->regmap,\n\t\t\t\t  REG_FLASH_TOUT, 0x60, flash->pdata->peak);\n\tif (rval < 0)\n\t\treturn rval;\n\t \n\tflash->led_mode = V4L2_FLASH_LED_MODE_NONE;\n\trval = lm3560_mode_ctrl(flash);\n\tif (rval < 0)\n\t\treturn rval;\n\t \n\trval = regmap_read(flash->regmap, REG_FLAG, &reg_val);\n\treturn rval;\n}\n\nstatic int lm3560_probe(struct i2c_client *client)\n{\n\tstruct lm3560_flash *flash;\n\tstruct lm3560_platform_data *pdata = dev_get_platdata(&client->dev);\n\tint rval;\n\n\tflash = devm_kzalloc(&client->dev, sizeof(*flash), GFP_KERNEL);\n\tif (flash == NULL)\n\t\treturn -ENOMEM;\n\n\tflash->regmap = devm_regmap_init_i2c(client, &lm3560_regmap);\n\tif (IS_ERR(flash->regmap)) {\n\t\trval = PTR_ERR(flash->regmap);\n\t\treturn rval;\n\t}\n\n\t \n\tif (pdata == NULL) {\n\t\tpdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);\n\t\tif (pdata == NULL)\n\t\t\treturn -ENODEV;\n\t\tpdata->peak = LM3560_PEAK_3600mA;\n\t\tpdata->max_flash_timeout = LM3560_FLASH_TOUT_MAX;\n\t\t \n\t\tpdata->max_flash_brt[LM3560_LED0] = LM3560_FLASH_BRT_MAX;\n\t\tpdata->max_torch_brt[LM3560_LED0] = LM3560_TORCH_BRT_MAX;\n\t\t \n\t\tpdata->max_flash_brt[LM3560_LED1] = LM3560_FLASH_BRT_MAX;\n\t\tpdata->max_torch_brt[LM3560_LED1] = LM3560_TORCH_BRT_MAX;\n\t}\n\tflash->pdata = pdata;\n\tflash->dev = &client->dev;\n\tmutex_init(&flash->lock);\n\n\trval = lm3560_subdev_init(flash, LM3560_LED0, \"lm3560-led0\");\n\tif (rval < 0)\n\t\treturn rval;\n\n\trval = lm3560_subdev_init(flash, LM3560_LED1, \"lm3560-led1\");\n\tif (rval < 0)\n\t\treturn rval;\n\n\trval = lm3560_init_device(flash);\n\tif (rval < 0)\n\t\treturn rval;\n\n\ti2c_set_clientdata(client, flash);\n\n\treturn 0;\n}\n\nstatic void lm3560_remove(struct i2c_client *client)\n{\n\tstruct lm3560_flash *flash = i2c_get_clientdata(client);\n\tunsigned int i;\n\n\tfor (i = LM3560_LED0; i < LM3560_LED_MAX; i++) {\n\t\tv4l2_device_unregister_subdev(&flash->subdev_led[i]);\n\t\tv4l2_ctrl_handler_free(&flash->ctrls_led[i]);\n\t\tmedia_entity_cleanup(&flash->subdev_led[i].entity);\n\t}\n}\n\nstatic const struct i2c_device_id lm3560_id_table[] = {\n\t{LM3559_NAME, 0},\n\t{LM3560_NAME, 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, lm3560_id_table);\n\nstatic struct i2c_driver lm3560_i2c_driver = {\n\t.driver = {\n\t\t   .name = LM3560_NAME,\n\t\t   .pm = NULL,\n\t\t   },\n\t.probe = lm3560_probe,\n\t.remove = lm3560_remove,\n\t.id_table = lm3560_id_table,\n};\n\nmodule_i2c_driver(lm3560_i2c_driver);\n\nMODULE_AUTHOR(\"Daniel Jeong <gshark.jeong@gmail.com>\");\nMODULE_AUTHOR(\"Ldd Mlp <ldd-mlp@list.ti.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments LM3560 LED flash driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}