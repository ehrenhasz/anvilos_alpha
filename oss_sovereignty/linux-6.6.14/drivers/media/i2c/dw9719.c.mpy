{
  "module_name": "dw9719.c",
  "hash_id": "893454740908ae0ca8d0f18c514e0eba46b25290fd5e44cc135cdb4bea6fb984",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/dw9719.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/types.h>\n\n#include <media/v4l2-cci.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-subdev.h>\n\n#define DW9719_MAX_FOCUS_POS\t1023\n#define DW9719_CTRL_STEPS\t16\n#define DW9719_CTRL_DELAY_US\t1000\n\n#define DW9719_INFO\t\t\tCCI_REG8(0)\n#define DW9719_ID\t\t\t0xF1\n\n#define DW9719_CONTROL\t\t\tCCI_REG8(2)\n#define DW9719_ENABLE_RINGING\t\t0x02\n\n#define DW9719_VCM_CURRENT\t\tCCI_REG16(3)\n\n#define DW9719_MODE\t\t\tCCI_REG8(6)\n#define DW9719_MODE_SAC_SHIFT\t\t4\n#define DW9719_MODE_SAC3\t\t4\n\n#define DW9719_VCM_FREQ\t\t\tCCI_REG8(7)\n#define DW9719_DEFAULT_VCM_FREQ\t\t0x60\n\n#define to_dw9719_device(x) container_of(x, struct dw9719_device, sd)\n\nstruct dw9719_device {\n\tstruct v4l2_subdev sd;\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct regulator *regulator;\n\tu32 sac_mode;\n\tu32 vcm_freq;\n\n\tstruct dw9719_v4l2_ctrls {\n\t\tstruct v4l2_ctrl_handler handler;\n\t\tstruct v4l2_ctrl *focus;\n\t} ctrls;\n};\n\nstatic int dw9719_detect(struct dw9719_device *dw9719)\n{\n\tint ret;\n\tu64 val;\n\n\tret = cci_read(dw9719->regmap, DW9719_INFO, &val, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val != DW9719_ID) {\n\t\tdev_err(dw9719->dev, \"Failed to detect correct id\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int dw9719_power_down(struct dw9719_device *dw9719)\n{\n\treturn regulator_disable(dw9719->regulator);\n}\n\nstatic int dw9719_power_up(struct dw9719_device *dw9719)\n{\n\tint ret;\n\n\tret = regulator_enable(dw9719->regulator);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcci_write(dw9719->regmap, DW9719_CONTROL, 1, &ret);\n\n\t \n\tfsleep(100);\n\n\tcci_write(dw9719->regmap, DW9719_CONTROL, DW9719_ENABLE_RINGING, &ret);\n\tcci_write(dw9719->regmap, DW9719_MODE,\n\t\t  dw9719->sac_mode << DW9719_MODE_SAC_SHIFT, &ret);\n\tcci_write(dw9719->regmap, DW9719_VCM_FREQ, dw9719->vcm_freq, &ret);\n\n\tif (ret)\n\t\tdw9719_power_down(dw9719);\n\n\treturn ret;\n}\n\nstatic int dw9719_t_focus_abs(struct dw9719_device *dw9719, s32 value)\n{\n\treturn cci_write(dw9719->regmap, DW9719_VCM_CURRENT, value, NULL);\n}\n\nstatic int dw9719_set_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct dw9719_device *dw9719 = container_of(ctrl->handler,\n\t\t\t\t\t\t    struct dw9719_device,\n\t\t\t\t\t\t    ctrls.handler);\n\tint ret;\n\n\t \n\tif (!pm_runtime_get_if_in_use(dw9719->dev))\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_FOCUS_ABSOLUTE:\n\t\tret = dw9719_t_focus_abs(dw9719, ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tpm_runtime_put(dw9719->dev);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops dw9719_ctrl_ops = {\n\t.s_ctrl = dw9719_set_ctrl,\n};\n\nstatic int dw9719_suspend(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct dw9719_device *dw9719 = to_dw9719_device(sd);\n\tint ret;\n\tint val;\n\n\tfor (val = dw9719->ctrls.focus->val; val >= 0;\n\t     val -= DW9719_CTRL_STEPS) {\n\t\tret = dw9719_t_focus_abs(dw9719, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tusleep_range(DW9719_CTRL_DELAY_US, DW9719_CTRL_DELAY_US + 10);\n\t}\n\n\treturn dw9719_power_down(dw9719);\n}\n\nstatic int dw9719_resume(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct dw9719_device *dw9719 = to_dw9719_device(sd);\n\tint current_focus = dw9719->ctrls.focus->val;\n\tint ret;\n\tint val;\n\n\tret = dw9719_power_up(dw9719);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (val = current_focus % DW9719_CTRL_STEPS; val < current_focus;\n\t     val += DW9719_CTRL_STEPS) {\n\t\tret = dw9719_t_focus_abs(dw9719, val);\n\t\tif (ret)\n\t\t\tgoto err_power_down;\n\n\t\tusleep_range(DW9719_CTRL_DELAY_US, DW9719_CTRL_DELAY_US + 10);\n\t}\n\n\treturn 0;\n\nerr_power_down:\n\tdw9719_power_down(dw9719);\n\treturn ret;\n}\n\nstatic int dw9719_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\treturn pm_runtime_resume_and_get(sd->dev);\n}\n\nstatic int dw9719_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tpm_runtime_put(sd->dev);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_internal_ops dw9719_internal_ops = {\n\t.open = dw9719_open,\n\t.close = dw9719_close,\n};\n\nstatic int dw9719_init_controls(struct dw9719_device *dw9719)\n{\n\tconst struct v4l2_ctrl_ops *ops = &dw9719_ctrl_ops;\n\tint ret;\n\n\tv4l2_ctrl_handler_init(&dw9719->ctrls.handler, 1);\n\n\tdw9719->ctrls.focus = v4l2_ctrl_new_std(&dw9719->ctrls.handler, ops,\n\t\t\t\t\t\tV4L2_CID_FOCUS_ABSOLUTE, 0,\n\t\t\t\t\t\tDW9719_MAX_FOCUS_POS, 1, 0);\n\n\tif (dw9719->ctrls.handler.error) {\n\t\tdev_err(dw9719->dev, \"Error initialising v4l2 ctrls\\n\");\n\t\tret = dw9719->ctrls.handler.error;\n\t\tgoto err_free_handler;\n\t}\n\n\tdw9719->sd.ctrl_handler = &dw9719->ctrls.handler;\n\treturn 0;\n\nerr_free_handler:\n\tv4l2_ctrl_handler_free(&dw9719->ctrls.handler);\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_ops dw9719_ops = { };\n\nstatic int dw9719_probe(struct i2c_client *client)\n{\n\tstruct dw9719_device *dw9719;\n\tint ret;\n\n\tdw9719 = devm_kzalloc(&client->dev, sizeof(*dw9719), GFP_KERNEL);\n\tif (!dw9719)\n\t\treturn -ENOMEM;\n\n\tdw9719->regmap = devm_cci_regmap_init_i2c(client, 8);\n\tif (IS_ERR(dw9719->regmap))\n\t\treturn PTR_ERR(dw9719->regmap);\n\n\tdw9719->dev = &client->dev;\n\tdw9719->sac_mode = DW9719_MODE_SAC3;\n\tdw9719->vcm_freq = DW9719_DEFAULT_VCM_FREQ;\n\n\t \n\tdevice_property_read_u32(&client->dev, \"dongwoon,sac-mode\",\n\t\t\t\t &dw9719->sac_mode);\n\n\t \n\tdevice_property_read_u32(&client->dev, \"dongwoon,vcm-freq\",\n\t\t\t\t &dw9719->vcm_freq);\n\n\tdw9719->regulator = devm_regulator_get(&client->dev, \"vdd\");\n\tif (IS_ERR(dw9719->regulator))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(dw9719->regulator),\n\t\t\t\t     \"getting regulator\\n\");\n\n\tv4l2_i2c_subdev_init(&dw9719->sd, client, &dw9719_ops);\n\tdw9719->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tdw9719->sd.internal_ops = &dw9719_internal_ops;\n\n\tret = dw9719_init_controls(dw9719);\n\tif (ret)\n\t\treturn ret;\n\n\tret = media_entity_pads_init(&dw9719->sd.entity, 0, NULL);\n\tif (ret < 0)\n\t\tgoto err_free_ctrl_handler;\n\n\tdw9719->sd.entity.function = MEDIA_ENT_F_LENS;\n\n\t \n\n\tret = dw9719_power_up(dw9719);\n\tif (ret)\n\t\tgoto err_cleanup_media;\n\n\tret = dw9719_detect(dw9719);\n\tif (ret)\n\t\tgoto err_powerdown;\n\n\tpm_runtime_set_active(&client->dev);\n\tpm_runtime_get_noresume(&client->dev);\n\tpm_runtime_enable(&client->dev);\n\n\tret = v4l2_async_register_subdev(&dw9719->sd);\n\tif (ret < 0)\n\t\tgoto err_pm_runtime;\n\n\tpm_runtime_set_autosuspend_delay(&client->dev, 1000);\n\tpm_runtime_use_autosuspend(&client->dev);\n\tpm_runtime_put_autosuspend(&client->dev);\n\n\treturn ret;\n\nerr_pm_runtime:\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_put_noidle(&client->dev);\nerr_powerdown:\n\tdw9719_power_down(dw9719);\nerr_cleanup_media:\n\tmedia_entity_cleanup(&dw9719->sd.entity);\nerr_free_ctrl_handler:\n\tv4l2_ctrl_handler_free(&dw9719->ctrls.handler);\n\n\treturn ret;\n}\n\nstatic void dw9719_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct dw9719_device *dw9719 =\n\t\tcontainer_of(sd, struct dw9719_device, sd);\n\n\tv4l2_async_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(&dw9719->ctrls.handler);\n\tmedia_entity_cleanup(&dw9719->sd.entity);\n\n\tpm_runtime_disable(&client->dev);\n\tif (!pm_runtime_status_suspended(&client->dev))\n\t\tdw9719_power_down(dw9719);\n\tpm_runtime_set_suspended(&client->dev);\n}\n\nstatic const struct i2c_device_id dw9719_id_table[] = {\n\t{ \"dw9719\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, dw9719_id_table);\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(dw9719_pm_ops, dw9719_suspend, dw9719_resume,\n\t\t\t\t NULL);\n\nstatic struct i2c_driver dw9719_i2c_driver = {\n\t.driver = {\n\t\t.name = \"dw9719\",\n\t\t.pm = pm_sleep_ptr(&dw9719_pm_ops),\n\t},\n\t.probe = dw9719_probe,\n\t.remove = dw9719_remove,\n\t.id_table = dw9719_id_table,\n};\nmodule_i2c_driver(dw9719_i2c_driver);\n\nMODULE_AUTHOR(\"Daniel Scally <djrscally@gmail.com>\");\nMODULE_DESCRIPTION(\"DW9719 VCM Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}