{
  "module_name": "tc358743.c",
  "hash_id": "efaa2d4352dea30c79bbabafa3de126392a6873f341c2ac41f2aea82b3ef2b79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/tc358743.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/timer.h>\n#include <linux/of_graph.h>\n#include <linux/videodev2.h>\n#include <linux/workqueue.h>\n#include <linux/v4l2-dv-timings.h>\n#include <linux/hdmi.h>\n#include <media/cec.h>\n#include <media/v4l2-dv-timings.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fwnode.h>\n#include <media/i2c/tc358743.h>\n\n#include \"tc358743_regs.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"debug level (0-3)\");\n\nMODULE_DESCRIPTION(\"Toshiba TC358743 HDMI to CSI-2 bridge driver\");\nMODULE_AUTHOR(\"Ramakrishnan Muthukrishnan <ram@rkrishnan.org>\");\nMODULE_AUTHOR(\"Mikhail Khelik <mkhelik@cisco.com>\");\nMODULE_AUTHOR(\"Mats Randgaard <matrandg@cisco.com>\");\nMODULE_LICENSE(\"GPL\");\n\n#define EDID_NUM_BLOCKS_MAX 8\n#define EDID_BLOCK_SIZE 128\n\n#define I2C_MAX_XFER_SIZE  (EDID_BLOCK_SIZE + 2)\n\n#define POLL_INTERVAL_CEC_MS\t10\n#define POLL_INTERVAL_MS\t1000\n\nstatic const struct v4l2_dv_timings_cap tc358743_timings_cap = {\n\t.type = V4L2_DV_BT_656_1120,\n\t \n\t.reserved = { 0 },\n\t \n\tV4L2_INIT_BT_TIMINGS(640, 1920, 350, 1200, 13000000, 165000000,\n\t\t\tV4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_DMT |\n\t\t\tV4L2_DV_BT_STD_GTF | V4L2_DV_BT_STD_CVT,\n\t\t\tV4L2_DV_BT_CAP_PROGRESSIVE |\n\t\t\tV4L2_DV_BT_CAP_REDUCED_BLANKING |\n\t\t\tV4L2_DV_BT_CAP_CUSTOM)\n};\n\nstruct tc358743_state {\n\tstruct tc358743_platform_data pdata;\n\tstruct v4l2_mbus_config_mipi_csi2 bus;\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pad;\n\tstruct v4l2_ctrl_handler hdl;\n\tstruct i2c_client *i2c_client;\n\t \n\tstruct mutex confctl_mutex;\n\n\t \n\tstruct v4l2_ctrl *detect_tx_5v_ctrl;\n\tstruct v4l2_ctrl *audio_sampling_rate_ctrl;\n\tstruct v4l2_ctrl *audio_present_ctrl;\n\n\tstruct delayed_work delayed_work_enable_hotplug;\n\n\tstruct timer_list timer;\n\tstruct work_struct work_i2c_poll;\n\n\t \n\tu8 edid_blocks_written;\n\n\tstruct v4l2_dv_timings timings;\n\tu32 mbus_fmt_code;\n\tu8 csi_lanes_in_use;\n\n\tstruct gpio_desc *reset_gpio;\n\n\tstruct cec_adapter *cec_adap;\n};\n\nstatic void tc358743_enable_interrupts(struct v4l2_subdev *sd,\n\t\tbool cable_connected);\nstatic int tc358743_s_ctrl_detect_tx_5v(struct v4l2_subdev *sd);\n\nstatic inline struct tc358743_state *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct tc358743_state, sd);\n}\n\n \n\nstatic void i2c_rd(struct v4l2_subdev *sd, u16 reg, u8 *values, u32 n)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\tstruct i2c_client *client = state->i2c_client;\n\tint err;\n\tu8 buf[2] = { reg >> 8, reg & 0xff };\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 2,\n\t\t\t.buf = buf,\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = n,\n\t\t\t.buf = values,\n\t\t},\n\t};\n\n\terr = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (err != ARRAY_SIZE(msgs)) {\n\t\tv4l2_err(sd, \"%s: reading register 0x%x from 0x%x failed: %d\\n\",\n\t\t\t\t__func__, reg, client->addr, err);\n\t}\n}\n\nstatic void i2c_wr(struct v4l2_subdev *sd, u16 reg, u8 *values, u32 n)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\tstruct i2c_client *client = state->i2c_client;\n\tint err, i;\n\tstruct i2c_msg msg;\n\tu8 data[I2C_MAX_XFER_SIZE];\n\n\tif ((2 + n) > I2C_MAX_XFER_SIZE) {\n\t\tn = I2C_MAX_XFER_SIZE - 2;\n\t\tv4l2_warn(sd, \"i2c wr reg=%04x: len=%d is too big!\\n\",\n\t\t\t  reg, 2 + n);\n\t}\n\n\tmsg.addr = client->addr;\n\tmsg.buf = data;\n\tmsg.len = 2 + n;\n\tmsg.flags = 0;\n\n\tdata[0] = reg >> 8;\n\tdata[1] = reg & 0xff;\n\n\tfor (i = 0; i < n; i++)\n\t\tdata[2 + i] = values[i];\n\n\terr = i2c_transfer(client->adapter, &msg, 1);\n\tif (err != 1) {\n\t\tv4l2_err(sd, \"%s: writing register 0x%x from 0x%x failed: %d\\n\",\n\t\t\t\t__func__, reg, client->addr, err);\n\t\treturn;\n\t}\n\n\tif (debug < 3)\n\t\treturn;\n\n\tswitch (n) {\n\tcase 1:\n\t\tv4l2_info(sd, \"I2C write 0x%04x = 0x%02x\",\n\t\t\t\treg, data[2]);\n\t\tbreak;\n\tcase 2:\n\t\tv4l2_info(sd, \"I2C write 0x%04x = 0x%02x%02x\",\n\t\t\t\treg, data[3], data[2]);\n\t\tbreak;\n\tcase 4:\n\t\tv4l2_info(sd, \"I2C write 0x%04x = 0x%02x%02x%02x%02x\",\n\t\t\t\treg, data[5], data[4], data[3], data[2]);\n\t\tbreak;\n\tdefault:\n\t\tv4l2_info(sd, \"I2C write %d bytes from address 0x%04x\\n\",\n\t\t\t\tn, reg);\n\t}\n}\n\nstatic noinline u32 i2c_rdreg(struct v4l2_subdev *sd, u16 reg, u32 n)\n{\n\t__le32 val = 0;\n\n\ti2c_rd(sd, reg, (u8 __force *)&val, n);\n\n\treturn le32_to_cpu(val);\n}\n\nstatic noinline void i2c_wrreg(struct v4l2_subdev *sd, u16 reg, u32 val, u32 n)\n{\n\t__le32 raw = cpu_to_le32(val);\n\n\ti2c_wr(sd, reg, (u8 __force *)&raw, n);\n}\n\nstatic u8 i2c_rd8(struct v4l2_subdev *sd, u16 reg)\n{\n\treturn i2c_rdreg(sd, reg, 1);\n}\n\nstatic void i2c_wr8(struct v4l2_subdev *sd, u16 reg, u8 val)\n{\n\ti2c_wrreg(sd, reg, val, 1);\n}\n\nstatic void i2c_wr8_and_or(struct v4l2_subdev *sd, u16 reg,\n\t\tu8 mask, u8 val)\n{\n\ti2c_wrreg(sd, reg, (i2c_rdreg(sd, reg, 1) & mask) | val, 1);\n}\n\nstatic u16 i2c_rd16(struct v4l2_subdev *sd, u16 reg)\n{\n\treturn i2c_rdreg(sd, reg, 2);\n}\n\nstatic void i2c_wr16(struct v4l2_subdev *sd, u16 reg, u16 val)\n{\n\ti2c_wrreg(sd, reg, val, 2);\n}\n\nstatic void i2c_wr16_and_or(struct v4l2_subdev *sd, u16 reg, u16 mask, u16 val)\n{\n\ti2c_wrreg(sd, reg, (i2c_rdreg(sd, reg, 2) & mask) | val, 2);\n}\n\nstatic u32 i2c_rd32(struct v4l2_subdev *sd, u16 reg)\n{\n\treturn i2c_rdreg(sd, reg, 4);\n}\n\nstatic void i2c_wr32(struct v4l2_subdev *sd, u16 reg, u32 val)\n{\n\ti2c_wrreg(sd, reg, val, 4);\n}\n\n \n\nstatic inline bool is_hdmi(struct v4l2_subdev *sd)\n{\n\treturn i2c_rd8(sd, SYS_STATUS) & MASK_S_HDMI;\n}\n\nstatic inline bool tx_5v_power_present(struct v4l2_subdev *sd)\n{\n\treturn i2c_rd8(sd, SYS_STATUS) & MASK_S_DDC5V;\n}\n\nstatic inline bool no_signal(struct v4l2_subdev *sd)\n{\n\treturn !(i2c_rd8(sd, SYS_STATUS) & MASK_S_TMDS);\n}\n\nstatic inline bool no_sync(struct v4l2_subdev *sd)\n{\n\treturn !(i2c_rd8(sd, SYS_STATUS) & MASK_S_SYNC);\n}\n\nstatic inline bool audio_present(struct v4l2_subdev *sd)\n{\n\treturn i2c_rd8(sd, AU_STATUS0) & MASK_S_A_SAMPLE;\n}\n\nstatic int get_audio_sampling_rate(struct v4l2_subdev *sd)\n{\n\tstatic const int code_to_rate[] = {\n\t\t44100, 0, 48000, 32000, 22050, 384000, 24000, 352800,\n\t\t88200, 768000, 96000, 705600, 176400, 0, 192000, 0\n\t};\n\n\t \n\tif (no_signal(sd))\n\t\treturn 0;\n\n\treturn code_to_rate[i2c_rd8(sd, FS_SET) & MASK_FS];\n}\n\n \n\nstatic inline unsigned fps(const struct v4l2_bt_timings *t)\n{\n\tif (!V4L2_DV_BT_FRAME_HEIGHT(t) || !V4L2_DV_BT_FRAME_WIDTH(t))\n\t\treturn 0;\n\n\treturn DIV_ROUND_CLOSEST((unsigned)t->pixelclock,\n\t\t\tV4L2_DV_BT_FRAME_HEIGHT(t) * V4L2_DV_BT_FRAME_WIDTH(t));\n}\n\nstatic int tc358743_get_detected_timings(struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_dv_timings *timings)\n{\n\tstruct v4l2_bt_timings *bt = &timings->bt;\n\tunsigned width, height, frame_width, frame_height, frame_interval, fps;\n\n\tmemset(timings, 0, sizeof(struct v4l2_dv_timings));\n\n\tif (no_signal(sd)) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: no valid signal\\n\", __func__);\n\t\treturn -ENOLINK;\n\t}\n\tif (no_sync(sd)) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: no sync on signal\\n\", __func__);\n\t\treturn -ENOLCK;\n\t}\n\n\ttimings->type = V4L2_DV_BT_656_1120;\n\tbt->interlaced = i2c_rd8(sd, VI_STATUS1) & MASK_S_V_INTERLACE ?\n\t\tV4L2_DV_INTERLACED : V4L2_DV_PROGRESSIVE;\n\n\twidth = ((i2c_rd8(sd, DE_WIDTH_H_HI) & 0x1f) << 8) +\n\t\ti2c_rd8(sd, DE_WIDTH_H_LO);\n\theight = ((i2c_rd8(sd, DE_WIDTH_V_HI) & 0x1f) << 8) +\n\t\ti2c_rd8(sd, DE_WIDTH_V_LO);\n\tframe_width = ((i2c_rd8(sd, H_SIZE_HI) & 0x1f) << 8) +\n\t\ti2c_rd8(sd, H_SIZE_LO);\n\tframe_height = (((i2c_rd8(sd, V_SIZE_HI) & 0x3f) << 8) +\n\t\ti2c_rd8(sd, V_SIZE_LO)) / 2;\n\t \n\tframe_interval = ((i2c_rd8(sd, FV_CNT_HI) & 0x3) << 8) +\n\t\ti2c_rd8(sd, FV_CNT_LO);\n\tfps = (frame_interval > 0) ?\n\t\tDIV_ROUND_CLOSEST(10000, frame_interval) : 0;\n\n\tbt->width = width;\n\tbt->height = height;\n\tbt->vsync = frame_height - height;\n\tbt->hsync = frame_width - width;\n\tbt->pixelclock = frame_width * frame_height * fps;\n\tif (bt->interlaced == V4L2_DV_INTERLACED) {\n\t\tbt->height *= 2;\n\t\tbt->il_vsync = bt->vsync + 1;\n\t\tbt->pixelclock /= 2;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void tc358743_delayed_work_enable_hotplug(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct tc358743_state *state = container_of(dwork,\n\t\t\tstruct tc358743_state, delayed_work_enable_hotplug);\n\tstruct v4l2_subdev *sd = &state->sd;\n\n\tv4l2_dbg(2, debug, sd, \"%s:\\n\", __func__);\n\n\ti2c_wr8_and_or(sd, HPD_CTL, ~MASK_HPD_OUT0, MASK_HPD_OUT0);\n}\n\nstatic void tc358743_set_hdmi_hdcp(struct v4l2_subdev *sd, bool enable)\n{\n\tv4l2_dbg(2, debug, sd, \"%s: %s\\n\", __func__, enable ?\n\t\t\t\t\"enable\" : \"disable\");\n\n\tif (enable) {\n\t\ti2c_wr8_and_or(sd, HDCP_REG3, ~KEY_RD_CMD, KEY_RD_CMD);\n\n\t\ti2c_wr8_and_or(sd, HDCP_MODE, ~MASK_MANUAL_AUTHENTICATION, 0);\n\n\t\ti2c_wr8_and_or(sd, HDCP_REG1, 0xff,\n\t\t\t\tMASK_AUTH_UNAUTH_SEL_16_FRAMES |\n\t\t\t\tMASK_AUTH_UNAUTH_AUTO);\n\n\t\ti2c_wr8_and_or(sd, HDCP_REG2, ~MASK_AUTO_P3_RESET,\n\t\t\t\tSET_AUTO_P3_RESET_FRAMES(0x0f));\n\t} else {\n\t\ti2c_wr8_and_or(sd, HDCP_MODE, ~MASK_MANUAL_AUTHENTICATION,\n\t\t\t\tMASK_MANUAL_AUTHENTICATION);\n\t}\n}\n\nstatic void tc358743_disable_edid(struct v4l2_subdev *sd)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\n\tv4l2_dbg(2, debug, sd, \"%s:\\n\", __func__);\n\n\tcancel_delayed_work_sync(&state->delayed_work_enable_hotplug);\n\n\t \n\ti2c_wr8_and_or(sd, HPD_CTL, ~MASK_HPD_OUT0, 0x0);\n}\n\nstatic void tc358743_enable_edid(struct v4l2_subdev *sd)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\n\tif (state->edid_blocks_written == 0) {\n\t\tv4l2_dbg(2, debug, sd, \"%s: no EDID -> no hotplug\\n\", __func__);\n\t\ttc358743_s_ctrl_detect_tx_5v(sd);\n\t\treturn;\n\t}\n\n\tv4l2_dbg(2, debug, sd, \"%s:\\n\", __func__);\n\n\t \n\tschedule_delayed_work(&state->delayed_work_enable_hotplug, HZ / 10);\n\n\ttc358743_enable_interrupts(sd, true);\n\ttc358743_s_ctrl_detect_tx_5v(sd);\n}\n\nstatic void tc358743_erase_bksv(struct v4l2_subdev *sd)\n{\n\tint i;\n\n\tfor (i = 0; i < 5; i++)\n\t\ti2c_wr8(sd, BKSV + i, 0);\n}\n\n \n\nstatic void print_avi_infoframe(struct v4l2_subdev *sd)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct device *dev = &client->dev;\n\tunion hdmi_infoframe frame;\n\tu8 buffer[HDMI_INFOFRAME_SIZE(AVI)];\n\n\tif (!is_hdmi(sd)) {\n\t\tv4l2_info(sd, \"DVI-D signal - AVI infoframe not supported\\n\");\n\t\treturn;\n\t}\n\n\ti2c_rd(sd, PK_AVI_0HEAD, buffer, HDMI_INFOFRAME_SIZE(AVI));\n\n\tif (hdmi_infoframe_unpack(&frame, buffer, sizeof(buffer)) < 0) {\n\t\tv4l2_err(sd, \"%s: unpack of AVI infoframe failed\\n\", __func__);\n\t\treturn;\n\t}\n\n\thdmi_infoframe_log(KERN_INFO, dev, &frame);\n}\n\n \n\nstatic int tc358743_s_ctrl_detect_tx_5v(struct v4l2_subdev *sd)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\n\treturn v4l2_ctrl_s_ctrl(state->detect_tx_5v_ctrl,\n\t\t\ttx_5v_power_present(sd));\n}\n\nstatic int tc358743_s_ctrl_audio_sampling_rate(struct v4l2_subdev *sd)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\n\treturn v4l2_ctrl_s_ctrl(state->audio_sampling_rate_ctrl,\n\t\t\tget_audio_sampling_rate(sd));\n}\n\nstatic int tc358743_s_ctrl_audio_present(struct v4l2_subdev *sd)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\n\treturn v4l2_ctrl_s_ctrl(state->audio_present_ctrl,\n\t\t\taudio_present(sd));\n}\n\nstatic int tc358743_update_controls(struct v4l2_subdev *sd)\n{\n\tint ret = 0;\n\n\tret |= tc358743_s_ctrl_detect_tx_5v(sd);\n\tret |= tc358743_s_ctrl_audio_sampling_rate(sd);\n\tret |= tc358743_s_ctrl_audio_present(sd);\n\n\treturn ret;\n}\n\n \n\nstatic void tc358743_reset_phy(struct v4l2_subdev *sd)\n{\n\tv4l2_dbg(1, debug, sd, \"%s:\\n\", __func__);\n\n\ti2c_wr8_and_or(sd, PHY_RST, ~MASK_RESET_CTRL, 0);\n\ti2c_wr8_and_or(sd, PHY_RST, ~MASK_RESET_CTRL, MASK_RESET_CTRL);\n}\n\nstatic void tc358743_reset(struct v4l2_subdev *sd, uint16_t mask)\n{\n\tu16 sysctl = i2c_rd16(sd, SYSCTL);\n\n\ti2c_wr16(sd, SYSCTL, sysctl | mask);\n\ti2c_wr16(sd, SYSCTL, sysctl & ~mask);\n}\n\nstatic inline void tc358743_sleep_mode(struct v4l2_subdev *sd, bool enable)\n{\n\ti2c_wr16_and_or(sd, SYSCTL, ~MASK_SLEEP,\n\t\t\tenable ? MASK_SLEEP : 0);\n}\n\nstatic inline void enable_stream(struct v4l2_subdev *sd, bool enable)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\n\tv4l2_dbg(3, debug, sd, \"%s: %sable\\n\",\n\t\t\t__func__, enable ? \"en\" : \"dis\");\n\n\tif (enable) {\n\t\t \n\t\ti2c_wr32(sd, TXOPTIONCNTRL, 0);\n\t\t \n\t\ti2c_wr32(sd, TXOPTIONCNTRL, MASK_CONTCLKMODE);\n\t\t \n\t\ti2c_wr8(sd, VI_MUTE, MASK_AUTO_MUTE);\n\t} else {\n\t\t \n\t\ti2c_wr8(sd, VI_MUTE, MASK_AUTO_MUTE | MASK_VI_MUTE);\n\t}\n\n\tmutex_lock(&state->confctl_mutex);\n\ti2c_wr16_and_or(sd, CONFCTL, ~(MASK_VBUFEN | MASK_ABUFEN),\n\t\t\tenable ? (MASK_VBUFEN | MASK_ABUFEN) : 0x0);\n\tmutex_unlock(&state->confctl_mutex);\n}\n\nstatic void tc358743_set_pll(struct v4l2_subdev *sd)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\tstruct tc358743_platform_data *pdata = &state->pdata;\n\tu16 pllctl0 = i2c_rd16(sd, PLLCTL0);\n\tu16 pllctl1 = i2c_rd16(sd, PLLCTL1);\n\tu16 pllctl0_new = SET_PLL_PRD(pdata->pll_prd) |\n\t\tSET_PLL_FBD(pdata->pll_fbd);\n\tu32 hsck = (pdata->refclk_hz / pdata->pll_prd) * pdata->pll_fbd;\n\n\tv4l2_dbg(2, debug, sd, \"%s:\\n\", __func__);\n\n\t \n\tif ((pllctl0 != pllctl0_new) || ((pllctl1 & MASK_PLL_EN) == 0)) {\n\t\tu16 pll_frs;\n\n\t\tif (hsck > 500000000)\n\t\t\tpll_frs = 0x0;\n\t\telse if (hsck > 250000000)\n\t\t\tpll_frs = 0x1;\n\t\telse if (hsck > 125000000)\n\t\t\tpll_frs = 0x2;\n\t\telse\n\t\t\tpll_frs = 0x3;\n\n\t\tv4l2_dbg(1, debug, sd, \"%s: updating PLL clock\\n\", __func__);\n\t\ttc358743_sleep_mode(sd, true);\n\t\ti2c_wr16(sd, PLLCTL0, pllctl0_new);\n\t\ti2c_wr16_and_or(sd, PLLCTL1,\n\t\t\t\t~(MASK_PLL_FRS | MASK_RESETB | MASK_PLL_EN),\n\t\t\t\t(SET_PLL_FRS(pll_frs) | MASK_RESETB |\n\t\t\t\t MASK_PLL_EN));\n\t\tudelay(10);  \n\t\ti2c_wr16_and_or(sd, PLLCTL1, ~MASK_CKEN, MASK_CKEN);\n\t\ttc358743_sleep_mode(sd, false);\n\t}\n}\n\nstatic void tc358743_set_ref_clk(struct v4l2_subdev *sd)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\tstruct tc358743_platform_data *pdata = &state->pdata;\n\tu32 sys_freq;\n\tu32 lockdet_ref;\n\tu32 cec_freq;\n\tu16 fh_min;\n\tu16 fh_max;\n\n\tBUG_ON(!(pdata->refclk_hz == 26000000 ||\n\t\t pdata->refclk_hz == 27000000 ||\n\t\t pdata->refclk_hz == 42000000));\n\n\tsys_freq = pdata->refclk_hz / 10000;\n\ti2c_wr8(sd, SYS_FREQ0, sys_freq & 0x00ff);\n\ti2c_wr8(sd, SYS_FREQ1, (sys_freq & 0xff00) >> 8);\n\n\ti2c_wr8_and_or(sd, PHY_CTL0, ~MASK_PHY_SYSCLK_IND,\n\t\t\t(pdata->refclk_hz == 42000000) ?\n\t\t\tMASK_PHY_SYSCLK_IND : 0x0);\n\n\tfh_min = pdata->refclk_hz / 100000;\n\ti2c_wr8(sd, FH_MIN0, fh_min & 0x00ff);\n\ti2c_wr8(sd, FH_MIN1, (fh_min & 0xff00) >> 8);\n\n\tfh_max = (fh_min * 66) / 10;\n\ti2c_wr8(sd, FH_MAX0, fh_max & 0x00ff);\n\ti2c_wr8(sd, FH_MAX1, (fh_max & 0xff00) >> 8);\n\n\tlockdet_ref = pdata->refclk_hz / 100;\n\ti2c_wr8(sd, LOCKDET_REF0, lockdet_ref & 0x0000ff);\n\ti2c_wr8(sd, LOCKDET_REF1, (lockdet_ref & 0x00ff00) >> 8);\n\ti2c_wr8(sd, LOCKDET_REF2, (lockdet_ref & 0x0f0000) >> 16);\n\n\ti2c_wr8_and_or(sd, NCO_F0_MOD, ~MASK_NCO_F0_MOD,\n\t\t\t(pdata->refclk_hz == 27000000) ?\n\t\t\tMASK_NCO_F0_MOD_27MHZ : 0x0);\n\n\t \n\tcec_freq = (656 * sys_freq) / 4200;\n\ti2c_wr16(sd, CECHCLK, cec_freq);\n\ti2c_wr16(sd, CECLCLK, cec_freq);\n}\n\nstatic void tc358743_set_csi_color_space(struct v4l2_subdev *sd)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\n\tswitch (state->mbus_fmt_code) {\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\t\tv4l2_dbg(2, debug, sd, \"%s: YCbCr 422 16-bit\\n\", __func__);\n\t\ti2c_wr8_and_or(sd, VOUT_SET2,\n\t\t\t\t~(MASK_SEL422 | MASK_VOUT_422FIL_100) & 0xff,\n\t\t\t\tMASK_SEL422 | MASK_VOUT_422FIL_100);\n\t\ti2c_wr8_and_or(sd, VI_REP, ~MASK_VOUT_COLOR_SEL & 0xff,\n\t\t\t\tMASK_VOUT_COLOR_601_YCBCR_LIMITED);\n\t\tmutex_lock(&state->confctl_mutex);\n\t\ti2c_wr16_and_or(sd, CONFCTL, ~MASK_YCBCRFMT,\n\t\t\t\tMASK_YCBCRFMT_422_8_BIT);\n\t\tmutex_unlock(&state->confctl_mutex);\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\t\tv4l2_dbg(2, debug, sd, \"%s: RGB 888 24-bit\\n\", __func__);\n\t\ti2c_wr8_and_or(sd, VOUT_SET2,\n\t\t\t\t~(MASK_SEL422 | MASK_VOUT_422FIL_100) & 0xff,\n\t\t\t\t0x00);\n\t\ti2c_wr8_and_or(sd, VI_REP, ~MASK_VOUT_COLOR_SEL & 0xff,\n\t\t\t\tMASK_VOUT_COLOR_RGB_FULL);\n\t\tmutex_lock(&state->confctl_mutex);\n\t\ti2c_wr16_and_or(sd, CONFCTL, ~MASK_YCBCRFMT, 0);\n\t\tmutex_unlock(&state->confctl_mutex);\n\t\tbreak;\n\tdefault:\n\t\tv4l2_dbg(2, debug, sd, \"%s: Unsupported format code 0x%x\\n\",\n\t\t\t\t__func__, state->mbus_fmt_code);\n\t}\n}\n\nstatic unsigned tc358743_num_csi_lanes_needed(struct v4l2_subdev *sd)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\tstruct v4l2_bt_timings *bt = &state->timings.bt;\n\tstruct tc358743_platform_data *pdata = &state->pdata;\n\tu32 bits_pr_pixel =\n\t\t(state->mbus_fmt_code == MEDIA_BUS_FMT_UYVY8_1X16) ?  16 : 24;\n\tu32 bps = bt->width * bt->height * fps(bt) * bits_pr_pixel;\n\tu32 bps_pr_lane = (pdata->refclk_hz / pdata->pll_prd) * pdata->pll_fbd;\n\n\treturn DIV_ROUND_UP(bps, bps_pr_lane);\n}\n\nstatic void tc358743_set_csi(struct v4l2_subdev *sd)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\tstruct tc358743_platform_data *pdata = &state->pdata;\n\tunsigned lanes = tc358743_num_csi_lanes_needed(sd);\n\n\tv4l2_dbg(3, debug, sd, \"%s:\\n\", __func__);\n\n\tstate->csi_lanes_in_use = lanes;\n\n\ttc358743_reset(sd, MASK_CTXRST);\n\n\tif (lanes < 1)\n\t\ti2c_wr32(sd, CLW_CNTRL, MASK_CLW_LANEDISABLE);\n\tif (lanes < 1)\n\t\ti2c_wr32(sd, D0W_CNTRL, MASK_D0W_LANEDISABLE);\n\tif (lanes < 2)\n\t\ti2c_wr32(sd, D1W_CNTRL, MASK_D1W_LANEDISABLE);\n\tif (lanes < 3)\n\t\ti2c_wr32(sd, D2W_CNTRL, MASK_D2W_LANEDISABLE);\n\tif (lanes < 4)\n\t\ti2c_wr32(sd, D3W_CNTRL, MASK_D3W_LANEDISABLE);\n\n\ti2c_wr32(sd, LINEINITCNT, pdata->lineinitcnt);\n\ti2c_wr32(sd, LPTXTIMECNT, pdata->lptxtimecnt);\n\ti2c_wr32(sd, TCLK_HEADERCNT, pdata->tclk_headercnt);\n\ti2c_wr32(sd, TCLK_TRAILCNT, pdata->tclk_trailcnt);\n\ti2c_wr32(sd, THS_HEADERCNT, pdata->ths_headercnt);\n\ti2c_wr32(sd, TWAKEUP, pdata->twakeup);\n\ti2c_wr32(sd, TCLK_POSTCNT, pdata->tclk_postcnt);\n\ti2c_wr32(sd, THS_TRAILCNT, pdata->ths_trailcnt);\n\ti2c_wr32(sd, HSTXVREGCNT, pdata->hstxvregcnt);\n\n\ti2c_wr32(sd, HSTXVREGEN,\n\t\t\t((lanes > 0) ? MASK_CLM_HSTXVREGEN : 0x0) |\n\t\t\t((lanes > 0) ? MASK_D0M_HSTXVREGEN : 0x0) |\n\t\t\t((lanes > 1) ? MASK_D1M_HSTXVREGEN : 0x0) |\n\t\t\t((lanes > 2) ? MASK_D2M_HSTXVREGEN : 0x0) |\n\t\t\t((lanes > 3) ? MASK_D3M_HSTXVREGEN : 0x0));\n\n\ti2c_wr32(sd, TXOPTIONCNTRL, (state->bus.flags &\n\t\t V4L2_MBUS_CSI2_NONCONTINUOUS_CLOCK) ? 0 : MASK_CONTCLKMODE);\n\ti2c_wr32(sd, STARTCNTRL, MASK_START);\n\ti2c_wr32(sd, CSI_START, MASK_STRT);\n\n\ti2c_wr32(sd, CSI_CONFW, MASK_MODE_SET |\n\t\t\tMASK_ADDRESS_CSI_CONTROL |\n\t\t\tMASK_CSI_MODE |\n\t\t\tMASK_TXHSMD |\n\t\t\t((lanes == 4) ? MASK_NOL_4 :\n\t\t\t (lanes == 3) ? MASK_NOL_3 :\n\t\t\t (lanes == 2) ? MASK_NOL_2 : MASK_NOL_1));\n\n\ti2c_wr32(sd, CSI_CONFW, MASK_MODE_SET |\n\t\t\tMASK_ADDRESS_CSI_ERR_INTENA | MASK_TXBRK | MASK_QUNK |\n\t\t\tMASK_WCER | MASK_INER);\n\n\ti2c_wr32(sd, CSI_CONFW, MASK_MODE_CLEAR |\n\t\t\tMASK_ADDRESS_CSI_ERR_HALT | MASK_TXBRK | MASK_QUNK);\n\n\ti2c_wr32(sd, CSI_CONFW, MASK_MODE_SET |\n\t\t\tMASK_ADDRESS_CSI_INT_ENA | MASK_INTER);\n}\n\nstatic void tc358743_set_hdmi_phy(struct v4l2_subdev *sd)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\tstruct tc358743_platform_data *pdata = &state->pdata;\n\n\t \n\ti2c_wr8_and_or(sd, PHY_EN, ~MASK_ENABLE_PHY, 0x0);\n\ti2c_wr8(sd, PHY_CTL1, SET_PHY_AUTO_RST1_US(1600) |\n\t\t\tSET_FREQ_RANGE_MODE_CYCLES(1));\n\ti2c_wr8_and_or(sd, PHY_CTL2, ~MASK_PHY_AUTO_RSTn,\n\t\t\t(pdata->hdmi_phy_auto_reset_tmds_detected ?\n\t\t\t MASK_PHY_AUTO_RST2 : 0) |\n\t\t\t(pdata->hdmi_phy_auto_reset_tmds_in_range ?\n\t\t\t MASK_PHY_AUTO_RST3 : 0) |\n\t\t\t(pdata->hdmi_phy_auto_reset_tmds_valid ?\n\t\t\t MASK_PHY_AUTO_RST4 : 0));\n\ti2c_wr8(sd, PHY_BIAS, 0x40);\n\ti2c_wr8(sd, PHY_CSQ, SET_CSQ_CNT_LEVEL(0x0a));\n\ti2c_wr8(sd, AVM_CTL, 45);\n\ti2c_wr8_and_or(sd, HDMI_DET, ~MASK_HDMI_DET_V,\n\t\t\tpdata->hdmi_detection_delay << 4);\n\ti2c_wr8_and_or(sd, HV_RST, ~(MASK_H_PI_RST | MASK_V_PI_RST),\n\t\t\t(pdata->hdmi_phy_auto_reset_hsync_out_of_range ?\n\t\t\t MASK_H_PI_RST : 0) |\n\t\t\t(pdata->hdmi_phy_auto_reset_vsync_out_of_range ?\n\t\t\t MASK_V_PI_RST : 0));\n\ti2c_wr8_and_or(sd, PHY_EN, ~MASK_ENABLE_PHY, MASK_ENABLE_PHY);\n}\n\nstatic void tc358743_set_hdmi_audio(struct v4l2_subdev *sd)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\n\t \n\ti2c_wr8(sd, FORCE_MUTE, 0x00);\n\ti2c_wr8(sd, AUTO_CMD0, MASK_AUTO_MUTE7 | MASK_AUTO_MUTE6 |\n\t\t\tMASK_AUTO_MUTE5 | MASK_AUTO_MUTE4 |\n\t\t\tMASK_AUTO_MUTE1 | MASK_AUTO_MUTE0);\n\ti2c_wr8(sd, AUTO_CMD1, MASK_AUTO_MUTE9);\n\ti2c_wr8(sd, AUTO_CMD2, MASK_AUTO_PLAY3 | MASK_AUTO_PLAY2);\n\ti2c_wr8(sd, BUFINIT_START, SET_BUFINIT_START_MS(500));\n\ti2c_wr8(sd, FS_MUTE, 0x00);\n\ti2c_wr8(sd, FS_IMODE, MASK_NLPCM_SMODE | MASK_FS_SMODE);\n\ti2c_wr8(sd, ACR_MODE, MASK_CTS_MODE);\n\ti2c_wr8(sd, ACR_MDF0, MASK_ACR_L2MDF_1976_PPM | MASK_ACR_L1MDF_976_PPM);\n\ti2c_wr8(sd, ACR_MDF1, MASK_ACR_L3MDF_3906_PPM);\n\ti2c_wr8(sd, SDO_MODE1, MASK_SDO_FMT_I2S);\n\ti2c_wr8(sd, DIV_MODE, SET_DIV_DLY_MS(100));\n\n\tmutex_lock(&state->confctl_mutex);\n\ti2c_wr16_and_or(sd, CONFCTL, 0xffff, MASK_AUDCHNUM_2 |\n\t\t\tMASK_AUDOUTSEL_I2S | MASK_AUTOINDEX);\n\tmutex_unlock(&state->confctl_mutex);\n}\n\nstatic void tc358743_set_hdmi_info_frame_mode(struct v4l2_subdev *sd)\n{\n\t \n\ti2c_wr8(sd, PK_INT_MODE, MASK_ISRC2_INT_MODE | MASK_ISRC_INT_MODE |\n\t\t\tMASK_ACP_INT_MODE | MASK_VS_INT_MODE |\n\t\t\tMASK_SPD_INT_MODE | MASK_MS_INT_MODE |\n\t\t\tMASK_AUD_INT_MODE | MASK_AVI_INT_MODE);\n\ti2c_wr8(sd, NO_PKT_LIMIT, 0x2c);\n\ti2c_wr8(sd, NO_PKT_CLR, 0x53);\n\ti2c_wr8(sd, ERR_PK_LIMIT, 0x01);\n\ti2c_wr8(sd, NO_PKT_LIMIT2, 0x30);\n\ti2c_wr8(sd, NO_GDB_LIMIT, 0x10);\n}\n\nstatic void tc358743_initial_setup(struct v4l2_subdev *sd)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\tstruct tc358743_platform_data *pdata = &state->pdata;\n\n\t \n\ti2c_wr16_and_or(sd, SYSCTL, ~(MASK_IRRST | MASK_CECRST),\n\t\t\t\t     (MASK_IRRST | MASK_CECRST));\n\n\ttc358743_reset(sd, MASK_CTXRST | MASK_HDMIRST);\n#ifdef CONFIG_VIDEO_TC358743_CEC\n\ttc358743_reset(sd, MASK_CECRST);\n#endif\n\ttc358743_sleep_mode(sd, false);\n\n\ti2c_wr16(sd, FIFOCTL, pdata->fifo_level);\n\n\ttc358743_set_ref_clk(sd);\n\n\ti2c_wr8_and_or(sd, DDC_CTL, ~MASK_DDC5V_MODE,\n\t\t\tpdata->ddc5v_delay & MASK_DDC5V_MODE);\n\ti2c_wr8_and_or(sd, EDID_MODE, ~MASK_EDID_MODE, MASK_EDID_MODE_E_DDC);\n\n\ttc358743_set_hdmi_phy(sd);\n\ttc358743_set_hdmi_hdcp(sd, pdata->enable_hdcp);\n\ttc358743_set_hdmi_audio(sd);\n\ttc358743_set_hdmi_info_frame_mode(sd);\n\n\t \n\ti2c_wr8_and_or(sd, VI_MODE, ~MASK_RGB_DVI, 0);\n\n\ti2c_wr8_and_or(sd, VOUT_SET2, ~MASK_VOUTCOLORMODE,\n\t\t\tMASK_VOUTCOLORMODE_AUTO);\n\ti2c_wr8(sd, VOUT_SET3, MASK_VOUT_EXTCNT);\n}\n\n \n\n#ifdef CONFIG_VIDEO_TC358743_CEC\nstatic int tc358743_cec_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\tstruct tc358743_state *state = adap->priv;\n\tstruct v4l2_subdev *sd = &state->sd;\n\n\ti2c_wr32(sd, CECIMSK, enable ? MASK_CECTIM | MASK_CECRIM : 0);\n\ti2c_wr32(sd, CECICLR, MASK_CECTICLR | MASK_CECRICLR);\n\ti2c_wr32(sd, CECEN, enable);\n\tif (enable)\n\t\ti2c_wr32(sd, CECREN, MASK_CECREN);\n\treturn 0;\n}\n\nstatic int tc358743_cec_adap_monitor_all_enable(struct cec_adapter *adap,\n\t\t\t\t\t\tbool enable)\n{\n\tstruct tc358743_state *state = adap->priv;\n\tstruct v4l2_subdev *sd = &state->sd;\n\tu32 reg;\n\n\treg = i2c_rd32(sd, CECRCTL1);\n\tif (enable)\n\t\treg |= MASK_CECOTH;\n\telse\n\t\treg &= ~MASK_CECOTH;\n\ti2c_wr32(sd, CECRCTL1, reg);\n\treturn 0;\n}\n\nstatic int tc358743_cec_adap_log_addr(struct cec_adapter *adap, u8 log_addr)\n{\n\tstruct tc358743_state *state = adap->priv;\n\tstruct v4l2_subdev *sd = &state->sd;\n\tunsigned int la = 0;\n\n\tif (log_addr != CEC_LOG_ADDR_INVALID) {\n\t\tla = i2c_rd32(sd, CECADD);\n\t\tla |= 1 << log_addr;\n\t}\n\ti2c_wr32(sd, CECADD, la);\n\treturn 0;\n}\n\nstatic int tc358743_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\t   u32 signal_free_time, struct cec_msg *msg)\n{\n\tstruct tc358743_state *state = adap->priv;\n\tstruct v4l2_subdev *sd = &state->sd;\n\tunsigned int i;\n\n\ti2c_wr32(sd, CECTCTL,\n\t\t (cec_msg_is_broadcast(msg) ? MASK_CECBRD : 0) |\n\t\t (signal_free_time - 1));\n\tfor (i = 0; i < msg->len; i++)\n\t\ti2c_wr32(sd, CECTBUF1 + i * 4,\n\t\t\tmsg->msg[i] | ((i == msg->len - 1) ? MASK_CECTEOM : 0));\n\ti2c_wr32(sd, CECTEN, MASK_CECTEN);\n\treturn 0;\n}\n\nstatic const struct cec_adap_ops tc358743_cec_adap_ops = {\n\t.adap_enable = tc358743_cec_adap_enable,\n\t.adap_log_addr = tc358743_cec_adap_log_addr,\n\t.adap_transmit = tc358743_cec_adap_transmit,\n\t.adap_monitor_all_enable = tc358743_cec_adap_monitor_all_enable,\n};\n\nstatic void tc358743_cec_handler(struct v4l2_subdev *sd, u16 intstatus,\n\t\t\t\t bool *handled)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\tunsigned int cec_rxint, cec_txint;\n\tunsigned int clr = 0;\n\n\tcec_rxint = i2c_rd32(sd, CECRSTAT);\n\tcec_txint = i2c_rd32(sd, CECTSTAT);\n\n\tif (intstatus & MASK_CEC_RINT)\n\t\tclr |= MASK_CECRICLR;\n\tif (intstatus & MASK_CEC_TINT)\n\t\tclr |= MASK_CECTICLR;\n\ti2c_wr32(sd, CECICLR, clr);\n\n\tif ((intstatus & MASK_CEC_TINT) && cec_txint) {\n\t\tif (cec_txint & MASK_CECTIEND)\n\t\t\tcec_transmit_attempt_done(state->cec_adap,\n\t\t\t\t\t\t  CEC_TX_STATUS_OK);\n\t\telse if (cec_txint & MASK_CECTIAL)\n\t\t\tcec_transmit_attempt_done(state->cec_adap,\n\t\t\t\t\t\t  CEC_TX_STATUS_ARB_LOST);\n\t\telse if (cec_txint & MASK_CECTIACK)\n\t\t\tcec_transmit_attempt_done(state->cec_adap,\n\t\t\t\t\t\t  CEC_TX_STATUS_NACK);\n\t\telse if (cec_txint & MASK_CECTIUR) {\n\t\t\t \n\t\t\tcec_transmit_attempt_done(state->cec_adap,\n\t\t\t\t\t\t  CEC_TX_STATUS_ERROR);\n\t\t}\n\t\tif (handled)\n\t\t\t*handled = true;\n\t}\n\tif ((intstatus & MASK_CEC_RINT) &&\n\t    (cec_rxint & MASK_CECRIEND)) {\n\t\tstruct cec_msg msg = {};\n\t\tunsigned int i;\n\t\tunsigned int v;\n\n\t\tv = i2c_rd32(sd, CECRCTR);\n\t\tmsg.len = v & 0x1f;\n\t\tif (msg.len > CEC_MAX_MSG_SIZE)\n\t\t\tmsg.len = CEC_MAX_MSG_SIZE;\n\t\tfor (i = 0; i < msg.len; i++) {\n\t\t\tv = i2c_rd32(sd, CECRBUF1 + i * 4);\n\t\t\tmsg.msg[i] = v & 0xff;\n\t\t}\n\t\tcec_received_msg(state->cec_adap, &msg);\n\t\tif (handled)\n\t\t\t*handled = true;\n\t}\n\ti2c_wr16(sd, INTSTATUS,\n\t\t intstatus & (MASK_CEC_RINT | MASK_CEC_TINT));\n}\n\n#endif\n\n \n\nstatic void tc358743_format_change(struct v4l2_subdev *sd)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\tstruct v4l2_dv_timings timings;\n\tconst struct v4l2_event tc358743_ev_fmt = {\n\t\t.type = V4L2_EVENT_SOURCE_CHANGE,\n\t\t.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,\n\t};\n\n\tif (tc358743_get_detected_timings(sd, &timings)) {\n\t\tenable_stream(sd, false);\n\n\t\tv4l2_dbg(1, debug, sd, \"%s: No signal\\n\",\n\t\t\t\t__func__);\n\t} else {\n\t\tif (!v4l2_match_dv_timings(&state->timings, &timings, 0, false))\n\t\t\tenable_stream(sd, false);\n\n\t\tif (debug)\n\t\t\tv4l2_print_dv_timings(sd->name,\n\t\t\t\t\t\"tc358743_format_change: New format: \",\n\t\t\t\t\t&timings, false);\n\t}\n\n\tif (sd->devnode)\n\t\tv4l2_subdev_notify_event(sd, &tc358743_ev_fmt);\n}\n\nstatic void tc358743_init_interrupts(struct v4l2_subdev *sd)\n{\n\tu16 i;\n\n\t \n\tfor (i = SYS_INT; i <= KEY_INT; i++)\n\t\ti2c_wr8(sd, i, 0xff);\n\n\ti2c_wr16(sd, INTSTATUS, 0xffff);\n}\n\nstatic void tc358743_enable_interrupts(struct v4l2_subdev *sd,\n\t\tbool cable_connected)\n{\n\tv4l2_dbg(2, debug, sd, \"%s: cable connected = %d\\n\", __func__,\n\t\t\tcable_connected);\n\n\tif (cable_connected) {\n\t\ti2c_wr8(sd, SYS_INTM, ~(MASK_M_DDC | MASK_M_DVI_DET |\n\t\t\t\t\tMASK_M_HDMI_DET) & 0xff);\n\t\ti2c_wr8(sd, CLK_INTM, ~MASK_M_IN_DE_CHG);\n\t\ti2c_wr8(sd, CBIT_INTM, ~(MASK_M_CBIT_FS | MASK_M_AF_LOCK |\n\t\t\t\t\tMASK_M_AF_UNLOCK) & 0xff);\n\t\ti2c_wr8(sd, AUDIO_INTM, ~MASK_M_BUFINIT_END);\n\t\ti2c_wr8(sd, MISC_INTM, ~MASK_M_SYNC_CHG);\n\t} else {\n\t\ti2c_wr8(sd, SYS_INTM, ~MASK_M_DDC & 0xff);\n\t\ti2c_wr8(sd, CLK_INTM, 0xff);\n\t\ti2c_wr8(sd, CBIT_INTM, 0xff);\n\t\ti2c_wr8(sd, AUDIO_INTM, 0xff);\n\t\ti2c_wr8(sd, MISC_INTM, 0xff);\n\t}\n}\n\nstatic void tc358743_hdmi_audio_int_handler(struct v4l2_subdev *sd,\n\t\tbool *handled)\n{\n\tu8 audio_int_mask = i2c_rd8(sd, AUDIO_INTM);\n\tu8 audio_int = i2c_rd8(sd, AUDIO_INT) & ~audio_int_mask;\n\n\ti2c_wr8(sd, AUDIO_INT, audio_int);\n\n\tv4l2_dbg(3, debug, sd, \"%s: AUDIO_INT = 0x%02x\\n\", __func__, audio_int);\n\n\ttc358743_s_ctrl_audio_sampling_rate(sd);\n\ttc358743_s_ctrl_audio_present(sd);\n}\n\nstatic void tc358743_csi_err_int_handler(struct v4l2_subdev *sd, bool *handled)\n{\n\tv4l2_err(sd, \"%s: CSI_ERR = 0x%x\\n\", __func__, i2c_rd32(sd, CSI_ERR));\n\n\ti2c_wr32(sd, CSI_INT_CLR, MASK_ICRER);\n}\n\nstatic void tc358743_hdmi_misc_int_handler(struct v4l2_subdev *sd,\n\t\tbool *handled)\n{\n\tu8 misc_int_mask = i2c_rd8(sd, MISC_INTM);\n\tu8 misc_int = i2c_rd8(sd, MISC_INT) & ~misc_int_mask;\n\n\ti2c_wr8(sd, MISC_INT, misc_int);\n\n\tv4l2_dbg(3, debug, sd, \"%s: MISC_INT = 0x%02x\\n\", __func__, misc_int);\n\n\tif (misc_int & MASK_I_SYNC_CHG) {\n\t\t \n\t\tif (no_sync(sd) || no_signal(sd)) {\n\t\t\ttc358743_reset_phy(sd);\n\t\t\ttc358743_erase_bksv(sd);\n\t\t}\n\n\t\ttc358743_format_change(sd);\n\n\t\tmisc_int &= ~MASK_I_SYNC_CHG;\n\t\tif (handled)\n\t\t\t*handled = true;\n\t}\n\n\tif (misc_int) {\n\t\tv4l2_err(sd, \"%s: Unhandled MISC_INT interrupts: 0x%02x\\n\",\n\t\t\t\t__func__, misc_int);\n\t}\n}\n\nstatic void tc358743_hdmi_cbit_int_handler(struct v4l2_subdev *sd,\n\t\tbool *handled)\n{\n\tu8 cbit_int_mask = i2c_rd8(sd, CBIT_INTM);\n\tu8 cbit_int = i2c_rd8(sd, CBIT_INT) & ~cbit_int_mask;\n\n\ti2c_wr8(sd, CBIT_INT, cbit_int);\n\n\tv4l2_dbg(3, debug, sd, \"%s: CBIT_INT = 0x%02x\\n\", __func__, cbit_int);\n\n\tif (cbit_int & MASK_I_CBIT_FS) {\n\n\t\tv4l2_dbg(1, debug, sd, \"%s: Audio sample rate changed\\n\",\n\t\t\t\t__func__);\n\t\ttc358743_s_ctrl_audio_sampling_rate(sd);\n\n\t\tcbit_int &= ~MASK_I_CBIT_FS;\n\t\tif (handled)\n\t\t\t*handled = true;\n\t}\n\n\tif (cbit_int & (MASK_I_AF_LOCK | MASK_I_AF_UNLOCK)) {\n\n\t\tv4l2_dbg(1, debug, sd, \"%s: Audio present changed\\n\",\n\t\t\t\t__func__);\n\t\ttc358743_s_ctrl_audio_present(sd);\n\n\t\tcbit_int &= ~(MASK_I_AF_LOCK | MASK_I_AF_UNLOCK);\n\t\tif (handled)\n\t\t\t*handled = true;\n\t}\n\n\tif (cbit_int) {\n\t\tv4l2_err(sd, \"%s: Unhandled CBIT_INT interrupts: 0x%02x\\n\",\n\t\t\t\t__func__, cbit_int);\n\t}\n}\n\nstatic void tc358743_hdmi_clk_int_handler(struct v4l2_subdev *sd, bool *handled)\n{\n\tu8 clk_int_mask = i2c_rd8(sd, CLK_INTM);\n\tu8 clk_int = i2c_rd8(sd, CLK_INT) & ~clk_int_mask;\n\n\t \n\ti2c_wr8(sd, CLK_INT, clk_int | 0x80 | MASK_I_OUT_H_CHG);\n\n\tv4l2_dbg(3, debug, sd, \"%s: CLK_INT = 0x%02x\\n\", __func__, clk_int);\n\n\tif (clk_int & (MASK_I_IN_DE_CHG)) {\n\n\t\tv4l2_dbg(1, debug, sd, \"%s: DE size or position has changed\\n\",\n\t\t\t\t__func__);\n\n\t\t \n\t\tif (!no_signal(sd) && !no_sync(sd))\n\t\t\ttc358743_format_change(sd);\n\n\t\tclk_int &= ~(MASK_I_IN_DE_CHG);\n\t\tif (handled)\n\t\t\t*handled = true;\n\t}\n\n\tif (clk_int) {\n\t\tv4l2_err(sd, \"%s: Unhandled CLK_INT interrupts: 0x%02x\\n\",\n\t\t\t\t__func__, clk_int);\n\t}\n}\n\nstatic void tc358743_hdmi_sys_int_handler(struct v4l2_subdev *sd, bool *handled)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\tu8 sys_int_mask = i2c_rd8(sd, SYS_INTM);\n\tu8 sys_int = i2c_rd8(sd, SYS_INT) & ~sys_int_mask;\n\n\ti2c_wr8(sd, SYS_INT, sys_int);\n\n\tv4l2_dbg(3, debug, sd, \"%s: SYS_INT = 0x%02x\\n\", __func__, sys_int);\n\n\tif (sys_int & MASK_I_DDC) {\n\t\tbool tx_5v = tx_5v_power_present(sd);\n\n\t\tv4l2_dbg(1, debug, sd, \"%s: Tx 5V power present: %s\\n\",\n\t\t\t\t__func__, tx_5v ?  \"yes\" : \"no\");\n\n\t\tif (tx_5v) {\n\t\t\ttc358743_enable_edid(sd);\n\t\t} else {\n\t\t\ttc358743_enable_interrupts(sd, false);\n\t\t\ttc358743_disable_edid(sd);\n\t\t\tmemset(&state->timings, 0, sizeof(state->timings));\n\t\t\ttc358743_erase_bksv(sd);\n\t\t\ttc358743_update_controls(sd);\n\t\t}\n\n\t\tsys_int &= ~MASK_I_DDC;\n\t\tif (handled)\n\t\t\t*handled = true;\n\t}\n\n\tif (sys_int & MASK_I_DVI) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: HDMI->DVI change detected\\n\",\n\t\t\t\t__func__);\n\n\t\t \n\t\tif (no_sync(sd) || no_signal(sd)) {\n\t\t\ttc358743_reset_phy(sd);\n\t\t\ttc358743_erase_bksv(sd);\n\t\t}\n\n\t\tsys_int &= ~MASK_I_DVI;\n\t\tif (handled)\n\t\t\t*handled = true;\n\t}\n\n\tif (sys_int & MASK_I_HDMI) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: DVI->HDMI change detected\\n\",\n\t\t\t\t__func__);\n\n\t\t \n\t\ti2c_wr8(sd, ANA_CTL, MASK_APPL_PCSX_NORMAL | MASK_ANALOG_ON);\n\n\t\tsys_int &= ~MASK_I_HDMI;\n\t\tif (handled)\n\t\t\t*handled = true;\n\t}\n\n\tif (sys_int) {\n\t\tv4l2_err(sd, \"%s: Unhandled SYS_INT interrupts: 0x%02x\\n\",\n\t\t\t\t__func__, sys_int);\n\t}\n}\n\n \n\nstatic int tc358743_log_status(struct v4l2_subdev *sd)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\tstruct v4l2_dv_timings timings;\n\tuint8_t hdmi_sys_status =  i2c_rd8(sd, SYS_STATUS);\n\tuint16_t sysctl = i2c_rd16(sd, SYSCTL);\n\tu8 vi_status3 =  i2c_rd8(sd, VI_STATUS3);\n\tconst int deep_color_mode[4] = { 8, 10, 12, 16 };\n\tstatic const char * const input_color_space[] = {\n\t\t\"RGB\", \"YCbCr 601\", \"opRGB\", \"YCbCr 709\", \"NA (4)\",\n\t\t\"xvYCC 601\", \"NA(6)\", \"xvYCC 709\", \"NA(8)\", \"sYCC601\",\n\t\t\"NA(10)\", \"NA(11)\", \"NA(12)\", \"opYCC 601\"};\n\n\tv4l2_info(sd, \"-----Chip status-----\\n\");\n\tv4l2_info(sd, \"Chip ID: 0x%02x\\n\",\n\t\t\t(i2c_rd16(sd, CHIPID) & MASK_CHIPID) >> 8);\n\tv4l2_info(sd, \"Chip revision: 0x%02x\\n\",\n\t\t\ti2c_rd16(sd, CHIPID) & MASK_REVID);\n\tv4l2_info(sd, \"Reset: IR: %d, CEC: %d, CSI TX: %d, HDMI: %d\\n\",\n\t\t\t!!(sysctl & MASK_IRRST),\n\t\t\t!!(sysctl & MASK_CECRST),\n\t\t\t!!(sysctl & MASK_CTXRST),\n\t\t\t!!(sysctl & MASK_HDMIRST));\n\tv4l2_info(sd, \"Sleep mode: %s\\n\", sysctl & MASK_SLEEP ? \"on\" : \"off\");\n\tv4l2_info(sd, \"Cable detected (+5V power): %s\\n\",\n\t\t\thdmi_sys_status & MASK_S_DDC5V ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"DDC lines enabled: %s\\n\",\n\t\t\t(i2c_rd8(sd, EDID_MODE) & MASK_EDID_MODE_E_DDC) ?\n\t\t\t\"yes\" : \"no\");\n\tv4l2_info(sd, \"Hotplug enabled: %s\\n\",\n\t\t\t(i2c_rd8(sd, HPD_CTL) & MASK_HPD_OUT0) ?\n\t\t\t\"yes\" : \"no\");\n\tv4l2_info(sd, \"CEC enabled: %s\\n\",\n\t\t\t(i2c_rd16(sd, CECEN) & MASK_CECEN) ?  \"yes\" : \"no\");\n\tv4l2_info(sd, \"-----Signal status-----\\n\");\n\tv4l2_info(sd, \"TMDS signal detected: %s\\n\",\n\t\t\thdmi_sys_status & MASK_S_TMDS ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"Stable sync signal: %s\\n\",\n\t\t\thdmi_sys_status & MASK_S_SYNC ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"PHY PLL locked: %s\\n\",\n\t\t\thdmi_sys_status & MASK_S_PHY_PLL ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"PHY DE detected: %s\\n\",\n\t\t\thdmi_sys_status & MASK_S_PHY_SCDT ? \"yes\" : \"no\");\n\n\tif (tc358743_get_detected_timings(sd, &timings)) {\n\t\tv4l2_info(sd, \"No video detected\\n\");\n\t} else {\n\t\tv4l2_print_dv_timings(sd->name, \"Detected format: \", &timings,\n\t\t\t\ttrue);\n\t}\n\tv4l2_print_dv_timings(sd->name, \"Configured format: \", &state->timings,\n\t\t\ttrue);\n\n\tv4l2_info(sd, \"-----CSI-TX status-----\\n\");\n\tv4l2_info(sd, \"Lanes needed: %d\\n\",\n\t\t\ttc358743_num_csi_lanes_needed(sd));\n\tv4l2_info(sd, \"Lanes in use: %d\\n\",\n\t\t\tstate->csi_lanes_in_use);\n\tv4l2_info(sd, \"Waiting for particular sync signal: %s\\n\",\n\t\t\t(i2c_rd16(sd, CSI_STATUS) & MASK_S_WSYNC) ?\n\t\t\t\"yes\" : \"no\");\n\tv4l2_info(sd, \"Transmit mode: %s\\n\",\n\t\t\t(i2c_rd16(sd, CSI_STATUS) & MASK_S_TXACT) ?\n\t\t\t\"yes\" : \"no\");\n\tv4l2_info(sd, \"Receive mode: %s\\n\",\n\t\t\t(i2c_rd16(sd, CSI_STATUS) & MASK_S_RXACT) ?\n\t\t\t\"yes\" : \"no\");\n\tv4l2_info(sd, \"Stopped: %s\\n\",\n\t\t\t(i2c_rd16(sd, CSI_STATUS) & MASK_S_HLT) ?\n\t\t\t\"yes\" : \"no\");\n\tv4l2_info(sd, \"Color space: %s\\n\",\n\t\t\tstate->mbus_fmt_code == MEDIA_BUS_FMT_UYVY8_1X16 ?\n\t\t\t\"YCbCr 422 16-bit\" :\n\t\t\tstate->mbus_fmt_code == MEDIA_BUS_FMT_RGB888_1X24 ?\n\t\t\t\"RGB 888 24-bit\" : \"Unsupported\");\n\n\tv4l2_info(sd, \"-----%s status-----\\n\", is_hdmi(sd) ? \"HDMI\" : \"DVI-D\");\n\tv4l2_info(sd, \"HDCP encrypted content: %s\\n\",\n\t\t\thdmi_sys_status & MASK_S_HDCP ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"Input color space: %s %s range\\n\",\n\t\t\tinput_color_space[(vi_status3 & MASK_S_V_COLOR) >> 1],\n\t\t\t(vi_status3 & MASK_LIMITED) ? \"limited\" : \"full\");\n\tif (!is_hdmi(sd))\n\t\treturn 0;\n\tv4l2_info(sd, \"AV Mute: %s\\n\", hdmi_sys_status & MASK_S_AVMUTE ? \"on\" :\n\t\t\t\"off\");\n\tv4l2_info(sd, \"Deep color mode: %d-bits per channel\\n\",\n\t\t\tdeep_color_mode[(i2c_rd8(sd, VI_STATUS1) &\n\t\t\t\tMASK_S_DEEPCOLOR) >> 2]);\n\tprint_avi_infoframe(sd);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic void tc358743_print_register_map(struct v4l2_subdev *sd)\n{\n\tv4l2_info(sd, \"0x0000-0x00FF: Global Control Register\\n\");\n\tv4l2_info(sd, \"0x0100-0x01FF: CSI2-TX PHY Register\\n\");\n\tv4l2_info(sd, \"0x0200-0x03FF: CSI2-TX PPI Register\\n\");\n\tv4l2_info(sd, \"0x0400-0x05FF: Reserved\\n\");\n\tv4l2_info(sd, \"0x0600-0x06FF: CEC Register\\n\");\n\tv4l2_info(sd, \"0x0700-0x84FF: Reserved\\n\");\n\tv4l2_info(sd, \"0x8500-0x85FF: HDMIRX System Control Register\\n\");\n\tv4l2_info(sd, \"0x8600-0x86FF: HDMIRX Audio Control Register\\n\");\n\tv4l2_info(sd, \"0x8700-0x87FF: HDMIRX InfoFrame packet data Register\\n\");\n\tv4l2_info(sd, \"0x8800-0x88FF: HDMIRX HDCP Port Register\\n\");\n\tv4l2_info(sd, \"0x8900-0x89FF: HDMIRX Video Output Port & 3D Register\\n\");\n\tv4l2_info(sd, \"0x8A00-0x8BFF: Reserved\\n\");\n\tv4l2_info(sd, \"0x8C00-0x8FFF: HDMIRX EDID-RAM (1024bytes)\\n\");\n\tv4l2_info(sd, \"0x9000-0x90FF: HDMIRX GBD Extraction Control\\n\");\n\tv4l2_info(sd, \"0x9100-0x92FF: HDMIRX GBD RAM read\\n\");\n\tv4l2_info(sd, \"0x9300-      : Reserved\\n\");\n}\n\nstatic int tc358743_get_reg_size(u16 address)\n{\n\t \n\tif (address <= 0x00ff)\n\t\treturn 2;\n\telse if ((address >= 0x0100) && (address <= 0x06FF))\n\t\treturn 4;\n\telse if ((address >= 0x0700) && (address <= 0x84ff))\n\t\treturn 2;\n\telse\n\t\treturn 1;\n}\n\nstatic int tc358743_g_register(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_dbg_register *reg)\n{\n\tif (reg->reg > 0xffff) {\n\t\ttc358743_print_register_map(sd);\n\t\treturn -EINVAL;\n\t}\n\n\treg->size = tc358743_get_reg_size(reg->reg);\n\n\treg->val = i2c_rdreg(sd, reg->reg, reg->size);\n\n\treturn 0;\n}\n\nstatic int tc358743_s_register(struct v4l2_subdev *sd,\n\t\t\t       const struct v4l2_dbg_register *reg)\n{\n\tif (reg->reg > 0xffff) {\n\t\ttc358743_print_register_map(sd);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (reg->reg == HDCP_MODE ||\n\t    reg->reg == HDCP_REG1 ||\n\t    reg->reg == HDCP_REG2 ||\n\t    reg->reg == HDCP_REG3 ||\n\t    reg->reg == BCAPS)\n\t\treturn 0;\n\n\ti2c_wrreg(sd, (u16)reg->reg, reg->val,\n\t\t\ttc358743_get_reg_size(reg->reg));\n\n\treturn 0;\n}\n#endif\n\nstatic int tc358743_isr(struct v4l2_subdev *sd, u32 status, bool *handled)\n{\n\tu16 intstatus = i2c_rd16(sd, INTSTATUS);\n\n\tv4l2_dbg(1, debug, sd, \"%s: IntStatus = 0x%04x\\n\", __func__, intstatus);\n\n\tif (intstatus & MASK_HDMI_INT) {\n\t\tu8 hdmi_int0 = i2c_rd8(sd, HDMI_INT0);\n\t\tu8 hdmi_int1 = i2c_rd8(sd, HDMI_INT1);\n\n\t\tif (hdmi_int0 & MASK_I_MISC)\n\t\t\ttc358743_hdmi_misc_int_handler(sd, handled);\n\t\tif (hdmi_int1 & MASK_I_CBIT)\n\t\t\ttc358743_hdmi_cbit_int_handler(sd, handled);\n\t\tif (hdmi_int1 & MASK_I_CLK)\n\t\t\ttc358743_hdmi_clk_int_handler(sd, handled);\n\t\tif (hdmi_int1 & MASK_I_SYS)\n\t\t\ttc358743_hdmi_sys_int_handler(sd, handled);\n\t\tif (hdmi_int1 & MASK_I_AUD)\n\t\t\ttc358743_hdmi_audio_int_handler(sd, handled);\n\n\t\ti2c_wr16(sd, INTSTATUS, MASK_HDMI_INT);\n\t\tintstatus &= ~MASK_HDMI_INT;\n\t}\n\n#ifdef CONFIG_VIDEO_TC358743_CEC\n\tif (intstatus & (MASK_CEC_RINT | MASK_CEC_TINT)) {\n\t\ttc358743_cec_handler(sd, intstatus, handled);\n\t\ti2c_wr16(sd, INTSTATUS,\n\t\t\t intstatus & (MASK_CEC_RINT | MASK_CEC_TINT));\n\t\tintstatus &= ~(MASK_CEC_RINT | MASK_CEC_TINT);\n\t}\n#endif\n\n\tif (intstatus & MASK_CSI_INT) {\n\t\tu32 csi_int = i2c_rd32(sd, CSI_INT);\n\n\t\tif (csi_int & MASK_INTER)\n\t\t\ttc358743_csi_err_int_handler(sd, handled);\n\n\t\ti2c_wr16(sd, INTSTATUS, MASK_CSI_INT);\n\t}\n\n\tintstatus = i2c_rd16(sd, INTSTATUS);\n\tif (intstatus) {\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t\t\"%s: Unhandled IntStatus interrupts: 0x%02x\\n\",\n\t\t\t\t__func__, intstatus);\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t tc358743_irq_handler(int irq, void *dev_id)\n{\n\tstruct tc358743_state *state = dev_id;\n\tbool handled = false;\n\n\ttc358743_isr(&state->sd, 0, &handled);\n\n\treturn handled ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic void tc358743_irq_poll_timer(struct timer_list *t)\n{\n\tstruct tc358743_state *state = from_timer(state, t, timer);\n\tunsigned int msecs;\n\n\tschedule_work(&state->work_i2c_poll);\n\t \n\tmsecs = state->cec_adap ? POLL_INTERVAL_CEC_MS : POLL_INTERVAL_MS;\n\tmod_timer(&state->timer, jiffies + msecs_to_jiffies(msecs));\n}\n\nstatic void tc358743_work_i2c_poll(struct work_struct *work)\n{\n\tstruct tc358743_state *state = container_of(work,\n\t\t\tstruct tc358743_state, work_i2c_poll);\n\tbool handled;\n\n\ttc358743_isr(&state->sd, 0, &handled);\n}\n\nstatic int tc358743_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,\n\t\t\t\t    struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\treturn v4l2_src_change_event_subdev_subscribe(sd, fh, sub);\n\tcase V4L2_EVENT_CTRL:\n\t\treturn v4l2_ctrl_subdev_subscribe_event(sd, fh, sub);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \n\nstatic int tc358743_g_input_status(struct v4l2_subdev *sd, u32 *status)\n{\n\t*status = 0;\n\t*status |= no_signal(sd) ? V4L2_IN_ST_NO_SIGNAL : 0;\n\t*status |= no_sync(sd) ? V4L2_IN_ST_NO_SYNC : 0;\n\n\tv4l2_dbg(1, debug, sd, \"%s: status = 0x%x\\n\", __func__, *status);\n\n\treturn 0;\n}\n\nstatic int tc358743_s_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_dv_timings *timings)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\n\tif (!timings)\n\t\treturn -EINVAL;\n\n\tif (debug)\n\t\tv4l2_print_dv_timings(sd->name, \"tc358743_s_dv_timings: \",\n\t\t\t\ttimings, false);\n\n\tif (v4l2_match_dv_timings(&state->timings, timings, 0, false)) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: no change\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tif (!v4l2_valid_dv_timings(timings,\n\t\t\t\t&tc358743_timings_cap, NULL, NULL)) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: timings out of range\\n\", __func__);\n\t\treturn -ERANGE;\n\t}\n\n\tstate->timings = *timings;\n\n\tenable_stream(sd, false);\n\ttc358743_set_pll(sd);\n\ttc358743_set_csi(sd);\n\n\treturn 0;\n}\n\nstatic int tc358743_g_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_dv_timings *timings)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\n\t*timings = state->timings;\n\n\treturn 0;\n}\n\nstatic int tc358743_enum_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_enum_dv_timings *timings)\n{\n\tif (timings->pad != 0)\n\t\treturn -EINVAL;\n\n\treturn v4l2_enum_dv_timings_cap(timings,\n\t\t\t&tc358743_timings_cap, NULL, NULL);\n}\n\nstatic int tc358743_query_dv_timings(struct v4l2_subdev *sd,\n\t\tstruct v4l2_dv_timings *timings)\n{\n\tint ret;\n\n\tret = tc358743_get_detected_timings(sd, timings);\n\tif (ret)\n\t\treturn ret;\n\n\tif (debug)\n\t\tv4l2_print_dv_timings(sd->name, \"tc358743_query_dv_timings: \",\n\t\t\t\ttimings, false);\n\n\tif (!v4l2_valid_dv_timings(timings,\n\t\t\t\t&tc358743_timings_cap, NULL, NULL)) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: timings out of range\\n\", __func__);\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\nstatic int tc358743_dv_timings_cap(struct v4l2_subdev *sd,\n\t\tstruct v4l2_dv_timings_cap *cap)\n{\n\tif (cap->pad != 0)\n\t\treturn -EINVAL;\n\n\t*cap = tc358743_timings_cap;\n\n\treturn 0;\n}\n\nstatic int tc358743_get_mbus_config(struct v4l2_subdev *sd,\n\t\t\t\t    unsigned int pad,\n\t\t\t\t    struct v4l2_mbus_config *cfg)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\n\tcfg->type = V4L2_MBUS_CSI2_DPHY;\n\n\t \n\tcfg->bus.mipi_csi2.flags = 0;\n\tcfg->bus.mipi_csi2.num_data_lanes = state->csi_lanes_in_use;\n\n\treturn 0;\n}\n\nstatic int tc358743_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tenable_stream(sd, enable);\n\tif (!enable) {\n\t\t \n\t\ttc358743_set_csi(sd);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int tc358743_enum_mbus_code(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tswitch (code->index) {\n\tcase 0:\n\t\tcode->code = MEDIA_BUS_FMT_RGB888_1X24;\n\t\tbreak;\n\tcase 1:\n\t\tcode->code = MEDIA_BUS_FMT_UYVY8_1X16;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int tc358743_get_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\tu8 vi_rep = i2c_rd8(sd, VI_REP);\n\n\tif (format->pad != 0)\n\t\treturn -EINVAL;\n\n\tformat->format.code = state->mbus_fmt_code;\n\tformat->format.width = state->timings.bt.width;\n\tformat->format.height = state->timings.bt.height;\n\tformat->format.field = V4L2_FIELD_NONE;\n\n\tswitch (vi_rep & MASK_VOUT_COLOR_SEL) {\n\tcase MASK_VOUT_COLOR_RGB_FULL:\n\tcase MASK_VOUT_COLOR_RGB_LIMITED:\n\t\tformat->format.colorspace = V4L2_COLORSPACE_SRGB;\n\t\tbreak;\n\tcase MASK_VOUT_COLOR_601_YCBCR_LIMITED:\n\tcase MASK_VOUT_COLOR_601_YCBCR_FULL:\n\t\tformat->format.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\t\tbreak;\n\tcase MASK_VOUT_COLOR_709_YCBCR_FULL:\n\tcase MASK_VOUT_COLOR_709_YCBCR_LIMITED:\n\t\tformat->format.colorspace = V4L2_COLORSPACE_REC709;\n\t\tbreak;\n\tdefault:\n\t\tformat->format.colorspace = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int tc358743_set_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\n\tu32 code = format->format.code;  \n\tint ret = tc358743_get_fmt(sd, sd_state, format);\n\n\tformat->format.code = code;\n\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (code) {\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn 0;\n\n\tstate->mbus_fmt_code = format->format.code;\n\n\tenable_stream(sd, false);\n\ttc358743_set_pll(sd);\n\ttc358743_set_csi(sd);\n\ttc358743_set_csi_color_space(sd);\n\n\treturn 0;\n}\n\nstatic int tc358743_g_edid(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_edid *edid)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\n\tmemset(edid->reserved, 0, sizeof(edid->reserved));\n\n\tif (edid->pad != 0)\n\t\treturn -EINVAL;\n\n\tif (edid->start_block == 0 && edid->blocks == 0) {\n\t\tedid->blocks = state->edid_blocks_written;\n\t\treturn 0;\n\t}\n\n\tif (state->edid_blocks_written == 0)\n\t\treturn -ENODATA;\n\n\tif (edid->start_block >= state->edid_blocks_written ||\n\t\t\tedid->blocks == 0)\n\t\treturn -EINVAL;\n\n\tif (edid->start_block + edid->blocks > state->edid_blocks_written)\n\t\tedid->blocks = state->edid_blocks_written - edid->start_block;\n\n\ti2c_rd(sd, EDID_RAM + (edid->start_block * EDID_BLOCK_SIZE), edid->edid,\n\t\t\tedid->blocks * EDID_BLOCK_SIZE);\n\n\treturn 0;\n}\n\nstatic int tc358743_s_edid(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_edid *edid)\n{\n\tstruct tc358743_state *state = to_state(sd);\n\tu16 edid_len = edid->blocks * EDID_BLOCK_SIZE;\n\tu16 pa;\n\tint err;\n\tint i;\n\n\tv4l2_dbg(2, debug, sd, \"%s, pad %d, start block %d, blocks %d\\n\",\n\t\t __func__, edid->pad, edid->start_block, edid->blocks);\n\n\tmemset(edid->reserved, 0, sizeof(edid->reserved));\n\n\tif (edid->pad != 0)\n\t\treturn -EINVAL;\n\n\tif (edid->start_block != 0)\n\t\treturn -EINVAL;\n\n\tif (edid->blocks > EDID_NUM_BLOCKS_MAX) {\n\t\tedid->blocks = EDID_NUM_BLOCKS_MAX;\n\t\treturn -E2BIG;\n\t}\n\tpa = cec_get_edid_phys_addr(edid->edid, edid->blocks * 128, NULL);\n\terr = v4l2_phys_addr_validate(pa, &pa, NULL);\n\tif (err)\n\t\treturn err;\n\n\tcec_phys_addr_invalidate(state->cec_adap);\n\n\ttc358743_disable_edid(sd);\n\n\ti2c_wr8(sd, EDID_LEN1, edid_len & 0xff);\n\ti2c_wr8(sd, EDID_LEN2, edid_len >> 8);\n\n\tif (edid->blocks == 0) {\n\t\tstate->edid_blocks_written = 0;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < edid_len; i += EDID_BLOCK_SIZE)\n\t\ti2c_wr(sd, EDID_RAM + i, edid->edid + i, EDID_BLOCK_SIZE);\n\n\tstate->edid_blocks_written = edid->blocks;\n\n\tcec_s_phys_addr(state->cec_adap, pa, false);\n\n\tif (tx_5v_power_present(sd))\n\t\ttc358743_enable_edid(sd);\n\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_subdev_core_ops tc358743_core_ops = {\n\t.log_status = tc358743_log_status,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = tc358743_g_register,\n\t.s_register = tc358743_s_register,\n#endif\n\t.interrupt_service_routine = tc358743_isr,\n\t.subscribe_event = tc358743_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n};\n\nstatic const struct v4l2_subdev_video_ops tc358743_video_ops = {\n\t.g_input_status = tc358743_g_input_status,\n\t.s_dv_timings = tc358743_s_dv_timings,\n\t.g_dv_timings = tc358743_g_dv_timings,\n\t.query_dv_timings = tc358743_query_dv_timings,\n\t.s_stream = tc358743_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops tc358743_pad_ops = {\n\t.enum_mbus_code = tc358743_enum_mbus_code,\n\t.set_fmt = tc358743_set_fmt,\n\t.get_fmt = tc358743_get_fmt,\n\t.get_edid = tc358743_g_edid,\n\t.set_edid = tc358743_s_edid,\n\t.enum_dv_timings = tc358743_enum_dv_timings,\n\t.dv_timings_cap = tc358743_dv_timings_cap,\n\t.get_mbus_config = tc358743_get_mbus_config,\n};\n\nstatic const struct v4l2_subdev_ops tc358743_ops = {\n\t.core = &tc358743_core_ops,\n\t.video = &tc358743_video_ops,\n\t.pad = &tc358743_pad_ops,\n};\n\n \n\nstatic const struct v4l2_ctrl_config tc358743_ctrl_audio_sampling_rate = {\n\t.id = TC358743_CID_AUDIO_SAMPLING_RATE,\n\t.name = \"Audio sampling rate\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.min = 0,\n\t.max = 768000,\n\t.step = 1,\n\t.def = 0,\n\t.flags = V4L2_CTRL_FLAG_READ_ONLY,\n};\n\nstatic const struct v4l2_ctrl_config tc358743_ctrl_audio_present = {\n\t.id = TC358743_CID_AUDIO_PRESENT,\n\t.name = \"Audio present\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.min = 0,\n\t.max = 1,\n\t.step = 1,\n\t.def = 0,\n\t.flags = V4L2_CTRL_FLAG_READ_ONLY,\n};\n\n \n\n#ifdef CONFIG_OF\nstatic void tc358743_gpio_reset(struct tc358743_state *state)\n{\n\tusleep_range(5000, 10000);\n\tgpiod_set_value(state->reset_gpio, 1);\n\tusleep_range(1000, 2000);\n\tgpiod_set_value(state->reset_gpio, 0);\n\tmsleep(20);\n}\n\nstatic int tc358743_probe_of(struct tc358743_state *state)\n{\n\tstruct device *dev = &state->i2c_client->dev;\n\tstruct v4l2_fwnode_endpoint endpoint = { .bus_type = 0 };\n\tstruct device_node *ep;\n\tstruct clk *refclk;\n\tu32 bps_pr_lane;\n\tint ret;\n\n\trefclk = devm_clk_get(dev, \"refclk\");\n\tif (IS_ERR(refclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(refclk),\n\t\t\t\t     \"failed to get refclk\\n\");\n\n\tep = of_graph_get_next_endpoint(dev->of_node, NULL);\n\tif (!ep) {\n\t\tdev_err(dev, \"missing endpoint node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = v4l2_fwnode_endpoint_alloc_parse(of_fwnode_handle(ep), &endpoint);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to parse endpoint\\n\");\n\t\tgoto put_node;\n\t}\n\n\tif (endpoint.bus_type != V4L2_MBUS_CSI2_DPHY ||\n\t    endpoint.bus.mipi_csi2.num_data_lanes == 0 ||\n\t    endpoint.nr_of_link_frequencies == 0) {\n\t\tdev_err(dev, \"missing CSI-2 properties in endpoint\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free_endpoint;\n\t}\n\n\tif (endpoint.bus.mipi_csi2.num_data_lanes > 4) {\n\t\tdev_err(dev, \"invalid number of lanes\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free_endpoint;\n\t}\n\n\tstate->bus = endpoint.bus.mipi_csi2;\n\n\tret = clk_prepare_enable(refclk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed! to enable clock\\n\");\n\t\tgoto free_endpoint;\n\t}\n\n\tstate->pdata.refclk_hz = clk_get_rate(refclk);\n\tstate->pdata.ddc5v_delay = DDC5V_DELAY_100_MS;\n\tstate->pdata.enable_hdcp = false;\n\t \n\tstate->pdata.fifo_level = 16;\n\t \n\tswitch (state->pdata.refclk_hz) {\n\tcase 26000000:\n\tcase 27000000:\n\tcase 42000000:\n\t\tstate->pdata.pll_prd = state->pdata.refclk_hz / 6000000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported refclk rate: %u Hz\\n\",\n\t\t\tstate->pdata.refclk_hz);\n\t\tgoto disable_clk;\n\t}\n\n\t \n\tbps_pr_lane = 2 * endpoint.link_frequencies[0];\n\tif (bps_pr_lane < 62500000U || bps_pr_lane > 1000000000U) {\n\t\tdev_err(dev, \"unsupported bps per lane: %u bps\\n\", bps_pr_lane);\n\t\tret = -EINVAL;\n\t\tgoto disable_clk;\n\t}\n\n\t \n\tstate->pdata.pll_fbd = bps_pr_lane /\n\t\t\t       state->pdata.refclk_hz * state->pdata.pll_prd;\n\n\t \n\tif (bps_pr_lane != 594000000U)\n\t\tdev_warn(dev, \"untested bps per lane: %u bps\\n\", bps_pr_lane);\n\tstate->pdata.lineinitcnt = 0xe80;\n\tstate->pdata.lptxtimecnt = 0x003;\n\t \n\tstate->pdata.tclk_headercnt = 0x1403;\n\tstate->pdata.tclk_trailcnt = 0x00;\n\t \n\tstate->pdata.ths_headercnt = 0x0103;\n\tstate->pdata.twakeup = 0x4882;\n\tstate->pdata.tclk_postcnt = 0x008;\n\tstate->pdata.ths_trailcnt = 0x2;\n\tstate->pdata.hstxvregcnt = 0;\n\n\tstate->reset_gpio = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t    GPIOD_OUT_LOW);\n\tif (IS_ERR(state->reset_gpio)) {\n\t\tdev_err(dev, \"failed to get reset gpio\\n\");\n\t\tret = PTR_ERR(state->reset_gpio);\n\t\tgoto disable_clk;\n\t}\n\n\tif (state->reset_gpio)\n\t\ttc358743_gpio_reset(state);\n\n\tret = 0;\n\tgoto free_endpoint;\n\ndisable_clk:\n\tclk_disable_unprepare(refclk);\nfree_endpoint:\n\tv4l2_fwnode_endpoint_free(&endpoint);\nput_node:\n\tof_node_put(ep);\n\treturn ret;\n}\n#else\nstatic inline int tc358743_probe_of(struct tc358743_state *state)\n{\n\treturn -ENODEV;\n}\n#endif\n\nstatic int tc358743_probe(struct i2c_client *client)\n{\n\tstatic struct v4l2_dv_timings default_timing =\n\t\tV4L2_DV_BT_CEA_640X480P59_94;\n\tstruct tc358743_state *state;\n\tstruct tc358743_platform_data *pdata = client->dev.platform_data;\n\tstruct v4l2_subdev *sd;\n\tu16 irq_mask = MASK_HDMI_MSK | MASK_CSI_MSK;\n\tint err;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\tv4l_dbg(1, debug, client, \"chip found @ 0x%x (%s)\\n\",\n\t\tclient->addr << 1, client->adapter->name);\n\n\tstate = devm_kzalloc(&client->dev, sizeof(struct tc358743_state),\n\t\t\tGFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->i2c_client = client;\n\n\t \n\tif (pdata) {\n\t\tstate->pdata = *pdata;\n\t\tstate->bus.flags = 0;\n\t} else {\n\t\terr = tc358743_probe_of(state);\n\t\tif (err == -ENODEV)\n\t\t\tv4l_err(client, \"No platform data!\\n\");\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tsd = &state->sd;\n\tv4l2_i2c_subdev_init(sd, client, &tc358743_ops);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;\n\n\t \n\tif ((i2c_rd16(sd, CHIPID) & MASK_CHIPID) != 0) {\n\t\tv4l2_info(sd, \"not a TC358743 on address 0x%x\\n\",\n\t\t\t  client->addr << 1);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tv4l2_ctrl_handler_init(&state->hdl, 3);\n\n\tstate->detect_tx_5v_ctrl = v4l2_ctrl_new_std(&state->hdl, NULL,\n\t\t\tV4L2_CID_DV_RX_POWER_PRESENT, 0, 1, 0, 0);\n\n\t \n\tstate->audio_sampling_rate_ctrl = v4l2_ctrl_new_custom(&state->hdl,\n\t\t\t&tc358743_ctrl_audio_sampling_rate, NULL);\n\n\tstate->audio_present_ctrl = v4l2_ctrl_new_custom(&state->hdl,\n\t\t\t&tc358743_ctrl_audio_present, NULL);\n\n\tsd->ctrl_handler = &state->hdl;\n\tif (state->hdl.error) {\n\t\terr = state->hdl.error;\n\t\tgoto err_hdl;\n\t}\n\n\tif (tc358743_update_controls(sd)) {\n\t\terr = -ENODEV;\n\t\tgoto err_hdl;\n\t}\n\n\tstate->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tsd->entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\terr = media_entity_pads_init(&sd->entity, 1, &state->pad);\n\tif (err < 0)\n\t\tgoto err_hdl;\n\n\tstate->mbus_fmt_code = MEDIA_BUS_FMT_RGB888_1X24;\n\n\tsd->dev = &client->dev;\n\terr = v4l2_async_register_subdev(sd);\n\tif (err < 0)\n\t\tgoto err_hdl;\n\n\tmutex_init(&state->confctl_mutex);\n\n\tINIT_DELAYED_WORK(&state->delayed_work_enable_hotplug,\n\t\t\ttc358743_delayed_work_enable_hotplug);\n\n#ifdef CONFIG_VIDEO_TC358743_CEC\n\tstate->cec_adap = cec_allocate_adapter(&tc358743_cec_adap_ops,\n\t\tstate, dev_name(&client->dev),\n\t\tCEC_CAP_DEFAULTS | CEC_CAP_MONITOR_ALL, CEC_MAX_LOG_ADDRS);\n\tif (IS_ERR(state->cec_adap)) {\n\t\terr = PTR_ERR(state->cec_adap);\n\t\tgoto err_hdl;\n\t}\n\tirq_mask |= MASK_CEC_RMSK | MASK_CEC_TMSK;\n#endif\n\n\ttc358743_initial_setup(sd);\n\n\ttc358743_s_dv_timings(sd, &default_timing);\n\n\ttc358743_set_csi_color_space(sd);\n\n\ttc358743_init_interrupts(sd);\n\n\tif (state->i2c_client->irq) {\n\t\terr = devm_request_threaded_irq(&client->dev,\n\t\t\t\t\t\tstate->i2c_client->irq,\n\t\t\t\t\t\tNULL, tc358743_irq_handler,\n\t\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\t\t\"tc358743\", state);\n\t\tif (err)\n\t\t\tgoto err_work_queues;\n\t} else {\n\t\tINIT_WORK(&state->work_i2c_poll,\n\t\t\t  tc358743_work_i2c_poll);\n\t\ttimer_setup(&state->timer, tc358743_irq_poll_timer, 0);\n\t\tstate->timer.expires = jiffies +\n\t\t\t\t       msecs_to_jiffies(POLL_INTERVAL_MS);\n\t\tadd_timer(&state->timer);\n\t}\n\n\terr = cec_register_adapter(state->cec_adap, &client->dev);\n\tif (err < 0) {\n\t\tpr_err(\"%s: failed to register the cec device\\n\", __func__);\n\t\tcec_delete_adapter(state->cec_adap);\n\t\tstate->cec_adap = NULL;\n\t\tgoto err_work_queues;\n\t}\n\n\ttc358743_enable_interrupts(sd, tx_5v_power_present(sd));\n\ti2c_wr16(sd, INTMASK, ~irq_mask);\n\n\terr = v4l2_ctrl_handler_setup(sd->ctrl_handler);\n\tif (err)\n\t\tgoto err_work_queues;\n\n\tv4l2_info(sd, \"%s found @ 0x%x (%s)\\n\", client->name,\n\t\t  client->addr << 1, client->adapter->name);\n\n\treturn 0;\n\nerr_work_queues:\n\tcec_unregister_adapter(state->cec_adap);\n\tif (!state->i2c_client->irq)\n\t\tflush_work(&state->work_i2c_poll);\n\tcancel_delayed_work(&state->delayed_work_enable_hotplug);\n\tmutex_destroy(&state->confctl_mutex);\nerr_hdl:\n\tmedia_entity_cleanup(&sd->entity);\n\tv4l2_ctrl_handler_free(&state->hdl);\n\treturn err;\n}\n\nstatic void tc358743_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct tc358743_state *state = to_state(sd);\n\n\tif (!state->i2c_client->irq) {\n\t\tdel_timer_sync(&state->timer);\n\t\tflush_work(&state->work_i2c_poll);\n\t}\n\tcancel_delayed_work_sync(&state->delayed_work_enable_hotplug);\n\tcec_unregister_adapter(state->cec_adap);\n\tv4l2_async_unregister_subdev(sd);\n\tv4l2_device_unregister_subdev(sd);\n\tmutex_destroy(&state->confctl_mutex);\n\tmedia_entity_cleanup(&sd->entity);\n\tv4l2_ctrl_handler_free(&state->hdl);\n}\n\nstatic const struct i2c_device_id tc358743_id[] = {\n\t{\"tc358743\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, tc358743_id);\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id tc358743_of_match[] = {\n\t{ .compatible = \"toshiba,tc358743\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tc358743_of_match);\n#endif\n\nstatic struct i2c_driver tc358743_driver = {\n\t.driver = {\n\t\t.name = \"tc358743\",\n\t\t.of_match_table = of_match_ptr(tc358743_of_match),\n\t},\n\t.probe = tc358743_probe,\n\t.remove = tc358743_remove,\n\t.id_table = tc358743_id,\n};\n\nmodule_i2c_driver(tc358743_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}