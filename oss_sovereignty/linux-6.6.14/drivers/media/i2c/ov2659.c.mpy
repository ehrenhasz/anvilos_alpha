{
  "module_name": "ov2659.c",
  "hash_id": "380f2f9dd640de30a776734629e481ce1381041bbedb4b115fc139e30d14abff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ov2659.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/pm_runtime.h>\n\n#include <media/i2c/ov2659.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-image-sizes.h>\n#include <media/v4l2-subdev.h>\n\n#define DRIVER_NAME \"ov2659\"\n\n \n#define REG_SOFTWARE_STANDBY\t\t0x0100\n#define REG_SOFTWARE_RESET\t\t0x0103\n#define REG_IO_CTRL00\t\t\t0x3000\n#define REG_IO_CTRL01\t\t\t0x3001\n#define REG_IO_CTRL02\t\t\t0x3002\n#define REG_OUTPUT_VALUE00\t\t0x3008\n#define REG_OUTPUT_VALUE01\t\t0x3009\n#define REG_OUTPUT_VALUE02\t\t0x300d\n#define REG_OUTPUT_SELECT00\t\t0x300e\n#define REG_OUTPUT_SELECT01\t\t0x300f\n#define REG_OUTPUT_SELECT02\t\t0x3010\n#define REG_OUTPUT_DRIVE\t\t0x3011\n#define REG_INPUT_READOUT00\t\t0x302d\n#define REG_INPUT_READOUT01\t\t0x302e\n#define REG_INPUT_READOUT02\t\t0x302f\n\n#define REG_SC_PLL_CTRL0\t\t0x3003\n#define REG_SC_PLL_CTRL1\t\t0x3004\n#define REG_SC_PLL_CTRL2\t\t0x3005\n#define REG_SC_PLL_CTRL3\t\t0x3006\n#define REG_SC_CHIP_ID_H\t\t0x300a\n#define REG_SC_CHIP_ID_L\t\t0x300b\n#define REG_SC_PWC\t\t\t0x3014\n#define REG_SC_CLKRST0\t\t\t0x301a\n#define REG_SC_CLKRST1\t\t\t0x301b\n#define REG_SC_CLKRST2\t\t\t0x301c\n#define REG_SC_CLKRST3\t\t\t0x301d\n#define REG_SC_SUB_ID\t\t\t0x302a\n#define REG_SC_SCCB_ID\t\t\t0x302b\n\n#define REG_GROUP_ADDRESS_00\t\t0x3200\n#define REG_GROUP_ADDRESS_01\t\t0x3201\n#define REG_GROUP_ADDRESS_02\t\t0x3202\n#define REG_GROUP_ADDRESS_03\t\t0x3203\n#define REG_GROUP_ACCESS\t\t0x3208\n\n#define REG_AWB_R_GAIN_H\t\t0x3400\n#define REG_AWB_R_GAIN_L\t\t0x3401\n#define REG_AWB_G_GAIN_H\t\t0x3402\n#define REG_AWB_G_GAIN_L\t\t0x3403\n#define REG_AWB_B_GAIN_H\t\t0x3404\n#define REG_AWB_B_GAIN_L\t\t0x3405\n#define REG_AWB_MANUAL_CONTROL\t\t0x3406\n\n#define REG_TIMING_HS_H\t\t\t0x3800\n#define REG_TIMING_HS_L\t\t\t0x3801\n#define REG_TIMING_VS_H\t\t\t0x3802\n#define REG_TIMING_VS_L\t\t\t0x3803\n#define REG_TIMING_HW_H\t\t\t0x3804\n#define REG_TIMING_HW_L\t\t\t0x3805\n#define REG_TIMING_VH_H\t\t\t0x3806\n#define REG_TIMING_VH_L\t\t\t0x3807\n#define REG_TIMING_DVPHO_H\t\t0x3808\n#define REG_TIMING_DVPHO_L\t\t0x3809\n#define REG_TIMING_DVPVO_H\t\t0x380a\n#define REG_TIMING_DVPVO_L\t\t0x380b\n#define REG_TIMING_HTS_H\t\t0x380c\n#define REG_TIMING_HTS_L\t\t0x380d\n#define REG_TIMING_VTS_H\t\t0x380e\n#define REG_TIMING_VTS_L\t\t0x380f\n#define REG_TIMING_HOFFS_H\t\t0x3810\n#define REG_TIMING_HOFFS_L\t\t0x3811\n#define REG_TIMING_VOFFS_H\t\t0x3812\n#define REG_TIMING_VOFFS_L\t\t0x3813\n#define REG_TIMING_XINC\t\t\t0x3814\n#define REG_TIMING_YINC\t\t\t0x3815\n#define REG_TIMING_VERT_FORMAT\t\t0x3820\n#define REG_TIMING_HORIZ_FORMAT\t\t0x3821\n\n#define REG_FORMAT_CTRL00\t\t0x4300\n\n#define REG_VFIFO_READ_START_H\t\t0x4608\n#define REG_VFIFO_READ_START_L\t\t0x4609\n\n#define REG_DVP_CTRL02\t\t\t0x4708\n\n#define REG_ISP_CTRL00\t\t\t0x5000\n#define REG_ISP_CTRL01\t\t\t0x5001\n#define REG_ISP_CTRL02\t\t\t0x5002\n\n#define REG_LENC_RED_X0_H\t\t0x500c\n#define REG_LENC_RED_X0_L\t\t0x500d\n#define REG_LENC_RED_Y0_H\t\t0x500e\n#define REG_LENC_RED_Y0_L\t\t0x500f\n#define REG_LENC_RED_A1\t\t\t0x5010\n#define REG_LENC_RED_B1\t\t\t0x5011\n#define REG_LENC_RED_A2_B2\t\t0x5012\n#define REG_LENC_GREEN_X0_H\t\t0x5013\n#define REG_LENC_GREEN_X0_L\t\t0x5014\n#define REG_LENC_GREEN_Y0_H\t\t0x5015\n#define REG_LENC_GREEN_Y0_L\t\t0x5016\n#define REG_LENC_GREEN_A1\t\t0x5017\n#define REG_LENC_GREEN_B1\t\t0x5018\n#define REG_LENC_GREEN_A2_B2\t\t0x5019\n#define REG_LENC_BLUE_X0_H\t\t0x501a\n#define REG_LENC_BLUE_X0_L\t\t0x501b\n#define REG_LENC_BLUE_Y0_H\t\t0x501c\n#define REG_LENC_BLUE_Y0_L\t\t0x501d\n#define REG_LENC_BLUE_A1\t\t0x501e\n#define REG_LENC_BLUE_B1\t\t0x501f\n#define REG_LENC_BLUE_A2_B2\t\t0x5020\n\n#define REG_AWB_CTRL00\t\t\t0x5035\n#define REG_AWB_CTRL01\t\t\t0x5036\n#define REG_AWB_CTRL02\t\t\t0x5037\n#define REG_AWB_CTRL03\t\t\t0x5038\n#define REG_AWB_CTRL04\t\t\t0x5039\n#define REG_AWB_LOCAL_LIMIT\t\t0x503a\n#define REG_AWB_CTRL12\t\t\t0x5049\n#define REG_AWB_CTRL13\t\t\t0x504a\n#define REG_AWB_CTRL14\t\t\t0x504b\n\n#define REG_SHARPENMT_THRESH1\t\t0x5064\n#define REG_SHARPENMT_THRESH2\t\t0x5065\n#define REG_SHARPENMT_OFFSET1\t\t0x5066\n#define REG_SHARPENMT_OFFSET2\t\t0x5067\n#define REG_DENOISE_THRESH1\t\t0x5068\n#define REG_DENOISE_THRESH2\t\t0x5069\n#define REG_DENOISE_OFFSET1\t\t0x506a\n#define REG_DENOISE_OFFSET2\t\t0x506b\n#define REG_SHARPEN_THRESH1\t\t0x506c\n#define REG_SHARPEN_THRESH2\t\t0x506d\n#define REG_CIP_CTRL00\t\t\t0x506e\n#define REG_CIP_CTRL01\t\t\t0x506f\n\n#define REG_CMX_SIGN\t\t\t0x5079\n#define REG_CMX_MISC_CTRL\t\t0x507a\n\n#define REG_PRE_ISP_CTRL00\t\t0x50a0\n#define TEST_PATTERN_ENABLE\t\tBIT(7)\n#define VERTICAL_COLOR_BAR_MASK\t\t0x53\n\n#define REG_NULL\t\t\t0x0000\t \n\n#define OV265X_ID(_msb, _lsb)\t\t((_msb) << 8 | (_lsb))\n#define OV2659_ID\t\t\t0x2656\n\nstruct sensor_register {\n\tu16 addr;\n\tu8 value;\n};\n\nstruct ov2659_framesize {\n\tu16 width;\n\tu16 height;\n\tu16 max_exp_lines;\n\tconst struct sensor_register *regs;\n};\n\nstruct ov2659_pll_ctrl {\n\tu8 ctrl1;\n\tu8 ctrl2;\n\tu8 ctrl3;\n};\n\nstruct ov2659_pixfmt {\n\tu32 code;\n\t \n\tstruct sensor_register *format_ctrl_regs;\n};\n\nstruct pll_ctrl_reg {\n\tunsigned int div;\n\tunsigned char reg;\n};\n\nstruct ov2659 {\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pad;\n\tstruct v4l2_mbus_framefmt format;\n\tunsigned int xvclk_frequency;\n\tconst struct ov2659_platform_data *pdata;\n\tstruct mutex lock;\n\tstruct i2c_client *client;\n\tstruct v4l2_ctrl_handler ctrls;\n\tstruct v4l2_ctrl *link_frequency;\n\tstruct clk *clk;\n\tconst struct ov2659_framesize *frame_size;\n\tstruct sensor_register *format_ctrl_regs;\n\tstruct ov2659_pll_ctrl pll;\n\tint streaming;\n\t \n\tstruct gpio_desc *pwdn_gpio;\n\t \n\tstruct gpio_desc *resetb_gpio;\n};\n\nstatic const struct sensor_register ov2659_init_regs[] = {\n\t{ REG_IO_CTRL00, 0x03 },\n\t{ REG_IO_CTRL01, 0xff },\n\t{ REG_IO_CTRL02, 0xe0 },\n\t{ 0x3633, 0x3d },\n\t{ 0x3620, 0x02 },\n\t{ 0x3631, 0x11 },\n\t{ 0x3612, 0x04 },\n\t{ 0x3630, 0x20 },\n\t{ 0x4702, 0x02 },\n\t{ 0x370c, 0x34 },\n\t{ REG_TIMING_HS_H, 0x00 },\n\t{ REG_TIMING_HS_L, 0x00 },\n\t{ REG_TIMING_VS_H, 0x00 },\n\t{ REG_TIMING_VS_L, 0x00 },\n\t{ REG_TIMING_HW_H, 0x06 },\n\t{ REG_TIMING_HW_L, 0x5f },\n\t{ REG_TIMING_VH_H, 0x04 },\n\t{ REG_TIMING_VH_L, 0xb7 },\n\t{ REG_TIMING_DVPHO_H, 0x03 },\n\t{ REG_TIMING_DVPHO_L, 0x20 },\n\t{ REG_TIMING_DVPVO_H, 0x02 },\n\t{ REG_TIMING_DVPVO_L, 0x58 },\n\t{ REG_TIMING_HTS_H, 0x05 },\n\t{ REG_TIMING_HTS_L, 0x14 },\n\t{ REG_TIMING_VTS_H, 0x02 },\n\t{ REG_TIMING_VTS_L, 0x68 },\n\t{ REG_TIMING_HOFFS_L, 0x08 },\n\t{ REG_TIMING_VOFFS_L, 0x02 },\n\t{ REG_TIMING_XINC, 0x31 },\n\t{ REG_TIMING_YINC, 0x31 },\n\t{ 0x3a02, 0x02 },\n\t{ 0x3a03, 0x68 },\n\t{ 0x3a08, 0x00 },\n\t{ 0x3a09, 0x5c },\n\t{ 0x3a0a, 0x00 },\n\t{ 0x3a0b, 0x4d },\n\t{ 0x3a0d, 0x08 },\n\t{ 0x3a0e, 0x06 },\n\t{ 0x3a14, 0x02 },\n\t{ 0x3a15, 0x28 },\n\t{ REG_DVP_CTRL02, 0x01 },\n\t{ 0x3623, 0x00 },\n\t{ 0x3634, 0x76 },\n\t{ 0x3701, 0x44 },\n\t{ 0x3702, 0x18 },\n\t{ 0x3703, 0x24 },\n\t{ 0x3704, 0x24 },\n\t{ 0x3705, 0x0c },\n\t{ REG_TIMING_VERT_FORMAT, 0x81 },\n\t{ REG_TIMING_HORIZ_FORMAT, 0x01 },\n\t{ 0x370a, 0x52 },\n\t{ REG_VFIFO_READ_START_H, 0x00 },\n\t{ REG_VFIFO_READ_START_L, 0x80 },\n\t{ REG_FORMAT_CTRL00, 0x30 },\n\t{ 0x5086, 0x02 },\n\t{ REG_ISP_CTRL00, 0xfb },\n\t{ REG_ISP_CTRL01, 0x1f },\n\t{ REG_ISP_CTRL02, 0x00 },\n\t{ 0x5025, 0x0e },\n\t{ 0x5026, 0x18 },\n\t{ 0x5027, 0x34 },\n\t{ 0x5028, 0x4c },\n\t{ 0x5029, 0x62 },\n\t{ 0x502a, 0x74 },\n\t{ 0x502b, 0x85 },\n\t{ 0x502c, 0x92 },\n\t{ 0x502d, 0x9e },\n\t{ 0x502e, 0xb2 },\n\t{ 0x502f, 0xc0 },\n\t{ 0x5030, 0xcc },\n\t{ 0x5031, 0xe0 },\n\t{ 0x5032, 0xee },\n\t{ 0x5033, 0xf6 },\n\t{ 0x5034, 0x11 },\n\t{ 0x5070, 0x1c },\n\t{ 0x5071, 0x5b },\n\t{ 0x5072, 0x05 },\n\t{ 0x5073, 0x20 },\n\t{ 0x5074, 0x94 },\n\t{ 0x5075, 0xb4 },\n\t{ 0x5076, 0xb4 },\n\t{ 0x5077, 0xaf },\n\t{ 0x5078, 0x05 },\n\t{ REG_CMX_SIGN, 0x98 },\n\t{ REG_CMX_MISC_CTRL, 0x21 },\n\t{ REG_AWB_CTRL00, 0x6a },\n\t{ REG_AWB_CTRL01, 0x11 },\n\t{ REG_AWB_CTRL02, 0x92 },\n\t{ REG_AWB_CTRL03, 0x21 },\n\t{ REG_AWB_CTRL04, 0xe1 },\n\t{ REG_AWB_LOCAL_LIMIT, 0x01 },\n\t{ 0x503c, 0x05 },\n\t{ 0x503d, 0x08 },\n\t{ 0x503e, 0x08 },\n\t{ 0x503f, 0x64 },\n\t{ 0x5040, 0x58 },\n\t{ 0x5041, 0x2a },\n\t{ 0x5042, 0xc5 },\n\t{ 0x5043, 0x2e },\n\t{ 0x5044, 0x3a },\n\t{ 0x5045, 0x3c },\n\t{ 0x5046, 0x44 },\n\t{ 0x5047, 0xf8 },\n\t{ 0x5048, 0x08 },\n\t{ REG_AWB_CTRL12, 0x70 },\n\t{ REG_AWB_CTRL13, 0xf0 },\n\t{ REG_AWB_CTRL14, 0xf0 },\n\t{ REG_LENC_RED_X0_H, 0x03 },\n\t{ REG_LENC_RED_X0_L, 0x20 },\n\t{ REG_LENC_RED_Y0_H, 0x02 },\n\t{ REG_LENC_RED_Y0_L, 0x5c },\n\t{ REG_LENC_RED_A1, 0x48 },\n\t{ REG_LENC_RED_B1, 0x00 },\n\t{ REG_LENC_RED_A2_B2, 0x66 },\n\t{ REG_LENC_GREEN_X0_H, 0x03 },\n\t{ REG_LENC_GREEN_X0_L, 0x30 },\n\t{ REG_LENC_GREEN_Y0_H, 0x02 },\n\t{ REG_LENC_GREEN_Y0_L, 0x7c },\n\t{ REG_LENC_GREEN_A1, 0x40 },\n\t{ REG_LENC_GREEN_B1, 0x00 },\n\t{ REG_LENC_GREEN_A2_B2, 0x66 },\n\t{ REG_LENC_BLUE_X0_H, 0x03 },\n\t{ REG_LENC_BLUE_X0_L, 0x10 },\n\t{ REG_LENC_BLUE_Y0_H, 0x02 },\n\t{ REG_LENC_BLUE_Y0_L, 0x7c },\n\t{ REG_LENC_BLUE_A1, 0x3a },\n\t{ REG_LENC_BLUE_B1, 0x00 },\n\t{ REG_LENC_BLUE_A2_B2, 0x66 },\n\t{ REG_CIP_CTRL00, 0x44 },\n\t{ REG_SHARPENMT_THRESH1, 0x08 },\n\t{ REG_SHARPENMT_THRESH2, 0x10 },\n\t{ REG_SHARPENMT_OFFSET1, 0x12 },\n\t{ REG_SHARPENMT_OFFSET2, 0x02 },\n\t{ REG_SHARPEN_THRESH1, 0x08 },\n\t{ REG_SHARPEN_THRESH2, 0x10 },\n\t{ REG_CIP_CTRL01, 0xa6 },\n\t{ REG_DENOISE_THRESH1, 0x08 },\n\t{ REG_DENOISE_THRESH2, 0x10 },\n\t{ REG_DENOISE_OFFSET1, 0x04 },\n\t{ REG_DENOISE_OFFSET2, 0x12 },\n\t{ 0x507e, 0x40 },\n\t{ 0x507f, 0x20 },\n\t{ 0x507b, 0x02 },\n\t{ REG_CMX_MISC_CTRL, 0x01 },\n\t{ 0x5084, 0x0c },\n\t{ 0x5085, 0x3e },\n\t{ 0x5005, 0x80 },\n\t{ 0x3a0f, 0x30 },\n\t{ 0x3a10, 0x28 },\n\t{ 0x3a1b, 0x32 },\n\t{ 0x3a1e, 0x26 },\n\t{ 0x3a11, 0x60 },\n\t{ 0x3a1f, 0x14 },\n\t{ 0x5060, 0x69 },\n\t{ 0x5061, 0x7d },\n\t{ 0x5062, 0x7d },\n\t{ 0x5063, 0x69 },\n\t{ REG_NULL, 0x00 },\n};\n\n \nstatic struct sensor_register ov2659_720p[] = {\n\t{ REG_TIMING_HS_H, 0x00 },\n\t{ REG_TIMING_HS_L, 0xa0 },\n\t{ REG_TIMING_VS_H, 0x00 },\n\t{ REG_TIMING_VS_L, 0xf0 },\n\t{ REG_TIMING_HW_H, 0x05 },\n\t{ REG_TIMING_HW_L, 0xbf },\n\t{ REG_TIMING_VH_H, 0x03 },\n\t{ REG_TIMING_VH_L, 0xcb },\n\t{ REG_TIMING_DVPHO_H, 0x05 },\n\t{ REG_TIMING_DVPHO_L, 0x00 },\n\t{ REG_TIMING_DVPVO_H, 0x02 },\n\t{ REG_TIMING_DVPVO_L, 0xd0 },\n\t{ REG_TIMING_HTS_H, 0x06 },\n\t{ REG_TIMING_HTS_L, 0x4c },\n\t{ REG_TIMING_VTS_H, 0x02 },\n\t{ REG_TIMING_VTS_L, 0xe8 },\n\t{ REG_TIMING_HOFFS_L, 0x10 },\n\t{ REG_TIMING_VOFFS_L, 0x06 },\n\t{ REG_TIMING_XINC, 0x11 },\n\t{ REG_TIMING_YINC, 0x11 },\n\t{ REG_TIMING_VERT_FORMAT, 0x80 },\n\t{ REG_TIMING_HORIZ_FORMAT, 0x00 },\n\t{ 0x370a, 0x12 },\n\t{ 0x3a03, 0xe8 },\n\t{ 0x3a09, 0x6f },\n\t{ 0x3a0b, 0x5d },\n\t{ 0x3a15, 0x9a },\n\t{ REG_VFIFO_READ_START_H, 0x00 },\n\t{ REG_VFIFO_READ_START_L, 0x80 },\n\t{ REG_ISP_CTRL02, 0x00 },\n\t{ REG_NULL, 0x00 },\n};\n\n \nstatic struct sensor_register ov2659_uxga[] = {\n\t{ REG_TIMING_HS_H, 0x00 },\n\t{ REG_TIMING_HS_L, 0x00 },\n\t{ REG_TIMING_VS_H, 0x00 },\n\t{ REG_TIMING_VS_L, 0x00 },\n\t{ REG_TIMING_HW_H, 0x06 },\n\t{ REG_TIMING_HW_L, 0x5f },\n\t{ REG_TIMING_VH_H, 0x04 },\n\t{ REG_TIMING_VH_L, 0xbb },\n\t{ REG_TIMING_DVPHO_H, 0x06 },\n\t{ REG_TIMING_DVPHO_L, 0x40 },\n\t{ REG_TIMING_DVPVO_H, 0x04 },\n\t{ REG_TIMING_DVPVO_L, 0xb0 },\n\t{ REG_TIMING_HTS_H, 0x07 },\n\t{ REG_TIMING_HTS_L, 0x9f },\n\t{ REG_TIMING_VTS_H, 0x04 },\n\t{ REG_TIMING_VTS_L, 0xd0 },\n\t{ REG_TIMING_HOFFS_L, 0x10 },\n\t{ REG_TIMING_VOFFS_L, 0x06 },\n\t{ REG_TIMING_XINC, 0x11 },\n\t{ REG_TIMING_YINC, 0x11 },\n\t{ 0x3a02, 0x04 },\n\t{ 0x3a03, 0xd0 },\n\t{ 0x3a08, 0x00 },\n\t{ 0x3a09, 0xb8 },\n\t{ 0x3a0a, 0x00 },\n\t{ 0x3a0b, 0x9a },\n\t{ 0x3a0d, 0x08 },\n\t{ 0x3a0e, 0x06 },\n\t{ 0x3a14, 0x04 },\n\t{ 0x3a15, 0x50 },\n\t{ 0x3623, 0x00 },\n\t{ 0x3634, 0x44 },\n\t{ 0x3701, 0x44 },\n\t{ 0x3702, 0x30 },\n\t{ 0x3703, 0x48 },\n\t{ 0x3704, 0x48 },\n\t{ 0x3705, 0x18 },\n\t{ REG_TIMING_VERT_FORMAT, 0x80 },\n\t{ REG_TIMING_HORIZ_FORMAT, 0x00 },\n\t{ 0x370a, 0x12 },\n\t{ REG_VFIFO_READ_START_H, 0x00 },\n\t{ REG_VFIFO_READ_START_L, 0x80 },\n\t{ REG_ISP_CTRL02, 0x00 },\n\t{ REG_NULL, 0x00 },\n};\n\n \nstatic struct sensor_register ov2659_sxga[] = {\n\t{ REG_TIMING_HS_H, 0x00 },\n\t{ REG_TIMING_HS_L, 0x00 },\n\t{ REG_TIMING_VS_H, 0x00 },\n\t{ REG_TIMING_VS_L, 0x00 },\n\t{ REG_TIMING_HW_H, 0x06 },\n\t{ REG_TIMING_HW_L, 0x5f },\n\t{ REG_TIMING_VH_H, 0x04 },\n\t{ REG_TIMING_VH_L, 0xb7 },\n\t{ REG_TIMING_DVPHO_H, 0x05 },\n\t{ REG_TIMING_DVPHO_L, 0x00 },\n\t{ REG_TIMING_DVPVO_H, 0x04 },\n\t{ REG_TIMING_DVPVO_L, 0x00 },\n\t{ REG_TIMING_HTS_H, 0x07 },\n\t{ REG_TIMING_HTS_L, 0x9c },\n\t{ REG_TIMING_VTS_H, 0x04 },\n\t{ REG_TIMING_VTS_L, 0xd0 },\n\t{ REG_TIMING_HOFFS_L, 0x10 },\n\t{ REG_TIMING_VOFFS_L, 0x06 },\n\t{ REG_TIMING_XINC, 0x11 },\n\t{ REG_TIMING_YINC, 0x11 },\n\t{ 0x3a02, 0x02 },\n\t{ 0x3a03, 0x68 },\n\t{ 0x3a08, 0x00 },\n\t{ 0x3a09, 0x5c },\n\t{ 0x3a0a, 0x00 },\n\t{ 0x3a0b, 0x4d },\n\t{ 0x3a0d, 0x08 },\n\t{ 0x3a0e, 0x06 },\n\t{ 0x3a14, 0x02 },\n\t{ 0x3a15, 0x28 },\n\t{ 0x3623, 0x00 },\n\t{ 0x3634, 0x76 },\n\t{ 0x3701, 0x44 },\n\t{ 0x3702, 0x18 },\n\t{ 0x3703, 0x24 },\n\t{ 0x3704, 0x24 },\n\t{ 0x3705, 0x0c },\n\t{ REG_TIMING_VERT_FORMAT, 0x80 },\n\t{ REG_TIMING_HORIZ_FORMAT, 0x00 },\n\t{ 0x370a, 0x52 },\n\t{ REG_VFIFO_READ_START_H, 0x00 },\n\t{ REG_VFIFO_READ_START_L, 0x80 },\n\t{ REG_ISP_CTRL02, 0x00 },\n\t{ REG_NULL, 0x00 },\n};\n\n \nstatic struct sensor_register ov2659_xga[] = {\n\t{ REG_TIMING_HS_H, 0x00 },\n\t{ REG_TIMING_HS_L, 0x00 },\n\t{ REG_TIMING_VS_H, 0x00 },\n\t{ REG_TIMING_VS_L, 0x00 },\n\t{ REG_TIMING_HW_H, 0x06 },\n\t{ REG_TIMING_HW_L, 0x5f },\n\t{ REG_TIMING_VH_H, 0x04 },\n\t{ REG_TIMING_VH_L, 0xb7 },\n\t{ REG_TIMING_DVPHO_H, 0x04 },\n\t{ REG_TIMING_DVPHO_L, 0x00 },\n\t{ REG_TIMING_DVPVO_H, 0x03 },\n\t{ REG_TIMING_DVPVO_L, 0x00 },\n\t{ REG_TIMING_HTS_H, 0x07 },\n\t{ REG_TIMING_HTS_L, 0x9c },\n\t{ REG_TIMING_VTS_H, 0x04 },\n\t{ REG_TIMING_VTS_L, 0xd0 },\n\t{ REG_TIMING_HOFFS_L, 0x10 },\n\t{ REG_TIMING_VOFFS_L, 0x06 },\n\t{ REG_TIMING_XINC, 0x11 },\n\t{ REG_TIMING_YINC, 0x11 },\n\t{ 0x3a02, 0x02 },\n\t{ 0x3a03, 0x68 },\n\t{ 0x3a08, 0x00 },\n\t{ 0x3a09, 0x5c },\n\t{ 0x3a0a, 0x00 },\n\t{ 0x3a0b, 0x4d },\n\t{ 0x3a0d, 0x08 },\n\t{ 0x3a0e, 0x06 },\n\t{ 0x3a14, 0x02 },\n\t{ 0x3a15, 0x28 },\n\t{ 0x3623, 0x00 },\n\t{ 0x3634, 0x76 },\n\t{ 0x3701, 0x44 },\n\t{ 0x3702, 0x18 },\n\t{ 0x3703, 0x24 },\n\t{ 0x3704, 0x24 },\n\t{ 0x3705, 0x0c },\n\t{ REG_TIMING_VERT_FORMAT, 0x80 },\n\t{ REG_TIMING_HORIZ_FORMAT, 0x00 },\n\t{ 0x370a, 0x52 },\n\t{ REG_VFIFO_READ_START_H, 0x00 },\n\t{ REG_VFIFO_READ_START_L, 0x80 },\n\t{ REG_ISP_CTRL02, 0x00 },\n\t{ REG_NULL, 0x00 },\n};\n\n \nstatic struct sensor_register ov2659_svga[] = {\n\t{ REG_TIMING_HS_H, 0x00 },\n\t{ REG_TIMING_HS_L, 0x00 },\n\t{ REG_TIMING_VS_H, 0x00 },\n\t{ REG_TIMING_VS_L, 0x00 },\n\t{ REG_TIMING_HW_H, 0x06 },\n\t{ REG_TIMING_HW_L, 0x5f },\n\t{ REG_TIMING_VH_H, 0x04 },\n\t{ REG_TIMING_VH_L, 0xb7 },\n\t{ REG_TIMING_DVPHO_H, 0x03 },\n\t{ REG_TIMING_DVPHO_L, 0x20 },\n\t{ REG_TIMING_DVPVO_H, 0x02 },\n\t{ REG_TIMING_DVPVO_L, 0x58 },\n\t{ REG_TIMING_HTS_H, 0x05 },\n\t{ REG_TIMING_HTS_L, 0x14 },\n\t{ REG_TIMING_VTS_H, 0x02 },\n\t{ REG_TIMING_VTS_L, 0x68 },\n\t{ REG_TIMING_HOFFS_L, 0x08 },\n\t{ REG_TIMING_VOFFS_L, 0x02 },\n\t{ REG_TIMING_XINC, 0x31 },\n\t{ REG_TIMING_YINC, 0x31 },\n\t{ 0x3a02, 0x02 },\n\t{ 0x3a03, 0x68 },\n\t{ 0x3a08, 0x00 },\n\t{ 0x3a09, 0x5c },\n\t{ 0x3a0a, 0x00 },\n\t{ 0x3a0b, 0x4d },\n\t{ 0x3a0d, 0x08 },\n\t{ 0x3a0e, 0x06 },\n\t{ 0x3a14, 0x02 },\n\t{ 0x3a15, 0x28 },\n\t{ 0x3623, 0x00 },\n\t{ 0x3634, 0x76 },\n\t{ 0x3701, 0x44 },\n\t{ 0x3702, 0x18 },\n\t{ 0x3703, 0x24 },\n\t{ 0x3704, 0x24 },\n\t{ 0x3705, 0x0c },\n\t{ REG_TIMING_VERT_FORMAT, 0x81 },\n\t{ REG_TIMING_HORIZ_FORMAT, 0x01 },\n\t{ 0x370a, 0x52 },\n\t{ REG_VFIFO_READ_START_H, 0x00 },\n\t{ REG_VFIFO_READ_START_L, 0x80 },\n\t{ REG_ISP_CTRL02, 0x00 },\n\t{ REG_NULL, 0x00 },\n};\n\n \nstatic struct sensor_register ov2659_vga[] = {\n\t{ REG_TIMING_HS_H, 0x00 },\n\t{ REG_TIMING_HS_L, 0x00 },\n\t{ REG_TIMING_VS_H, 0x00 },\n\t{ REG_TIMING_VS_L, 0x00 },\n\t{ REG_TIMING_HW_H, 0x06 },\n\t{ REG_TIMING_HW_L, 0x5f },\n\t{ REG_TIMING_VH_H, 0x04 },\n\t{ REG_TIMING_VH_L, 0xb7 },\n\t{ REG_TIMING_DVPHO_H, 0x02 },\n\t{ REG_TIMING_DVPHO_L, 0x80 },\n\t{ REG_TIMING_DVPVO_H, 0x01 },\n\t{ REG_TIMING_DVPVO_L, 0xe0 },\n\t{ REG_TIMING_HTS_H, 0x05 },\n\t{ REG_TIMING_HTS_L, 0x14 },\n\t{ REG_TIMING_VTS_H, 0x02 },\n\t{ REG_TIMING_VTS_L, 0x68 },\n\t{ REG_TIMING_HOFFS_L, 0x08 },\n\t{ REG_TIMING_VOFFS_L, 0x02 },\n\t{ REG_TIMING_XINC, 0x31 },\n\t{ REG_TIMING_YINC, 0x31 },\n\t{ 0x3a02, 0x02 },\n\t{ 0x3a03, 0x68 },\n\t{ 0x3a08, 0x00 },\n\t{ 0x3a09, 0x5c },\n\t{ 0x3a0a, 0x00 },\n\t{ 0x3a0b, 0x4d },\n\t{ 0x3a0d, 0x08 },\n\t{ 0x3a0e, 0x06 },\n\t{ 0x3a14, 0x02 },\n\t{ 0x3a15, 0x28 },\n\t{ 0x3623, 0x00 },\n\t{ 0x3634, 0x76 },\n\t{ 0x3701, 0x44 },\n\t{ 0x3702, 0x18 },\n\t{ 0x3703, 0x24 },\n\t{ 0x3704, 0x24 },\n\t{ 0x3705, 0x0c },\n\t{ REG_TIMING_VERT_FORMAT, 0x81 },\n\t{ REG_TIMING_HORIZ_FORMAT, 0x01 },\n\t{ 0x370a, 0x52 },\n\t{ REG_VFIFO_READ_START_H, 0x00 },\n\t{ REG_VFIFO_READ_START_L, 0xa0 },\n\t{ REG_ISP_CTRL02, 0x10 },\n\t{ REG_NULL, 0x00 },\n};\n\n \nstatic  struct sensor_register ov2659_qvga[] = {\n\t{ REG_TIMING_HS_H, 0x00 },\n\t{ REG_TIMING_HS_L, 0x00 },\n\t{ REG_TIMING_VS_H, 0x00 },\n\t{ REG_TIMING_VS_L, 0x00 },\n\t{ REG_TIMING_HW_H, 0x06 },\n\t{ REG_TIMING_HW_L, 0x5f },\n\t{ REG_TIMING_VH_H, 0x04 },\n\t{ REG_TIMING_VH_L, 0xb7 },\n\t{ REG_TIMING_DVPHO_H, 0x01 },\n\t{ REG_TIMING_DVPHO_L, 0x40 },\n\t{ REG_TIMING_DVPVO_H, 0x00 },\n\t{ REG_TIMING_DVPVO_L, 0xf0 },\n\t{ REG_TIMING_HTS_H, 0x05 },\n\t{ REG_TIMING_HTS_L, 0x14 },\n\t{ REG_TIMING_VTS_H, 0x02 },\n\t{ REG_TIMING_VTS_L, 0x68 },\n\t{ REG_TIMING_HOFFS_L, 0x08 },\n\t{ REG_TIMING_VOFFS_L, 0x02 },\n\t{ REG_TIMING_XINC, 0x31 },\n\t{ REG_TIMING_YINC, 0x31 },\n\t{ 0x3a02, 0x02 },\n\t{ 0x3a03, 0x68 },\n\t{ 0x3a08, 0x00 },\n\t{ 0x3a09, 0x5c },\n\t{ 0x3a0a, 0x00 },\n\t{ 0x3a0b, 0x4d },\n\t{ 0x3a0d, 0x08 },\n\t{ 0x3a0e, 0x06 },\n\t{ 0x3a14, 0x02 },\n\t{ 0x3a15, 0x28 },\n\t{ 0x3623, 0x00 },\n\t{ 0x3634, 0x76 },\n\t{ 0x3701, 0x44 },\n\t{ 0x3702, 0x18 },\n\t{ 0x3703, 0x24 },\n\t{ 0x3704, 0x24 },\n\t{ 0x3705, 0x0c },\n\t{ REG_TIMING_VERT_FORMAT, 0x81 },\n\t{ REG_TIMING_HORIZ_FORMAT, 0x01 },\n\t{ 0x370a, 0x52 },\n\t{ REG_VFIFO_READ_START_H, 0x00 },\n\t{ REG_VFIFO_READ_START_L, 0xa0 },\n\t{ REG_ISP_CTRL02, 0x10 },\n\t{ REG_NULL, 0x00 },\n};\n\nstatic const struct pll_ctrl_reg ctrl3[] = {\n\t{ 1, 0x00 },\n\t{ 2, 0x02 },\n\t{ 3, 0x03 },\n\t{ 4, 0x06 },\n\t{ 6, 0x0d },\n\t{ 8, 0x0e },\n\t{ 12, 0x0f },\n\t{ 16, 0x12 },\n\t{ 24, 0x13 },\n\t{ 32, 0x16 },\n\t{ 48, 0x1b },\n\t{ 64, 0x1e },\n\t{ 96, 0x1f },\n\t{ 0, 0x00 },\n};\n\nstatic const struct pll_ctrl_reg ctrl1[] = {\n\t{ 2, 0x10 },\n\t{ 4, 0x20 },\n\t{ 6, 0x30 },\n\t{ 8, 0x40 },\n\t{ 10, 0x50 },\n\t{ 12, 0x60 },\n\t{ 14, 0x70 },\n\t{ 16, 0x80 },\n\t{ 18, 0x90 },\n\t{ 20, 0xa0 },\n\t{ 22, 0xb0 },\n\t{ 24, 0xc0 },\n\t{ 26, 0xd0 },\n\t{ 28, 0xe0 },\n\t{ 30, 0xf0 },\n\t{ 0, 0x00 },\n};\n\nstatic const struct ov2659_framesize ov2659_framesizes[] = {\n\t{  \n\t\t.width\t\t= 320,\n\t\t.height\t\t= 240,\n\t\t.regs\t\t= ov2659_qvga,\n\t\t.max_exp_lines\t= 248,\n\t}, {  \n\t\t.width\t\t= 640,\n\t\t.height\t\t= 480,\n\t\t.regs\t\t= ov2659_vga,\n\t\t.max_exp_lines\t= 498,\n\t}, {  \n\t\t.width\t\t= 800,\n\t\t.height\t\t= 600,\n\t\t.regs\t\t= ov2659_svga,\n\t\t.max_exp_lines\t= 498,\n\t}, {  \n\t\t.width\t\t= 1024,\n\t\t.height\t\t= 768,\n\t\t.regs\t\t= ov2659_xga,\n\t\t.max_exp_lines\t= 498,\n\t}, {  \n\t\t.width\t\t= 1280,\n\t\t.height\t\t= 720,\n\t\t.regs\t\t= ov2659_720p,\n\t\t.max_exp_lines\t= 498,\n\t}, {  \n\t\t.width\t\t= 1280,\n\t\t.height\t\t= 1024,\n\t\t.regs\t\t= ov2659_sxga,\n\t\t.max_exp_lines\t= 1048,\n\t}, {  \n\t\t.width\t\t= 1600,\n\t\t.height\t\t= 1200,\n\t\t.regs\t\t= ov2659_uxga,\n\t\t.max_exp_lines\t= 498,\n\t},\n};\n\n \nstatic struct sensor_register ov2659_format_yuyv[] = {\n\t{ REG_FORMAT_CTRL00, 0x30 },\n\t{ REG_NULL, 0x0 },\n};\n\n \nstatic struct sensor_register ov2659_format_uyvy[] = {\n\t{ REG_FORMAT_CTRL00, 0x32 },\n\t{ REG_NULL, 0x0 },\n};\n\n \nstatic struct sensor_register ov2659_format_bggr[] = {\n\t{ REG_FORMAT_CTRL00, 0x00 },\n\t{ REG_NULL, 0x0 },\n};\n\n \nstatic struct sensor_register ov2659_format_rgb565[] = {\n\t{ REG_FORMAT_CTRL00, 0x60 },\n\t{ REG_NULL, 0x0 },\n};\n\nstatic const struct ov2659_pixfmt ov2659_formats[] = {\n\t{\n\t\t.code = MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.format_ctrl_regs = ov2659_format_yuyv,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t.format_ctrl_regs = ov2659_format_uyvy,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_RGB565_2X8_BE,\n\t\t.format_ctrl_regs = ov2659_format_rgb565,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.format_ctrl_regs = ov2659_format_bggr,\n\t},\n};\n\nstatic inline struct ov2659 *to_ov2659(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct ov2659, sd);\n}\n\n \nstatic int ov2659_write(struct i2c_client *client, u16 reg, u8 val)\n{\n\tstruct i2c_msg msg;\n\tu8 buf[3];\n\tint ret;\n\n\tbuf[0] = reg >> 8;\n\tbuf[1] = reg & 0xFF;\n\tbuf[2] = val;\n\n\tmsg.addr = client->addr;\n\tmsg.flags = client->flags;\n\tmsg.buf = buf;\n\tmsg.len = sizeof(buf);\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret >= 0)\n\t\treturn 0;\n\n\tdev_dbg(&client->dev,\n\t\t\"ov2659 write reg(0x%x val:0x%x) failed !\\n\", reg, val);\n\n\treturn ret;\n}\n\n \nstatic int ov2659_read(struct i2c_client *client, u16 reg, u8 *val)\n{\n\tstruct i2c_msg msg[2];\n\tu8 buf[2];\n\tint ret;\n\n\tbuf[0] = reg >> 8;\n\tbuf[1] = reg & 0xFF;\n\n\tmsg[0].addr = client->addr;\n\tmsg[0].flags = client->flags;\n\tmsg[0].buf = buf;\n\tmsg[0].len = sizeof(buf);\n\n\tmsg[1].addr = client->addr;\n\tmsg[1].flags = client->flags | I2C_M_RD;\n\tmsg[1].buf = buf;\n\tmsg[1].len = 1;\n\n\tret = i2c_transfer(client->adapter, msg, 2);\n\tif (ret >= 0) {\n\t\t*val = buf[0];\n\t\treturn 0;\n\t}\n\n\tdev_dbg(&client->dev,\n\t\t\"ov2659 read reg(0x%x val:0x%x) failed !\\n\", reg, *val);\n\n\treturn ret;\n}\n\nstatic int ov2659_write_array(struct i2c_client *client,\n\t\t\t      const struct sensor_register *regs)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; ret == 0 && regs[i].addr; i++)\n\t\tret = ov2659_write(client, regs[i].addr, regs[i].value);\n\n\treturn ret;\n}\n\nstatic void ov2659_pll_calc_params(struct ov2659 *ov2659)\n{\n\tconst struct ov2659_platform_data *pdata = ov2659->pdata;\n\tu8 ctrl1_reg = 0, ctrl2_reg = 0, ctrl3_reg = 0;\n\tstruct i2c_client *client = ov2659->client;\n\tunsigned int desired = pdata->link_frequency;\n\tu32 prediv, postdiv, mult;\n\tu32 bestdelta = -1;\n\tu32 delta, actual;\n\tint i, j;\n\n\tfor (i = 0; ctrl1[i].div != 0; i++) {\n\t\tpostdiv = ctrl1[i].div;\n\t\tfor (j = 0; ctrl3[j].div != 0; j++) {\n\t\t\tprediv = ctrl3[j].div;\n\t\t\tfor (mult = 1; mult <= 63; mult++) {\n\t\t\t\tactual  = ov2659->xvclk_frequency;\n\t\t\t\tactual *= mult;\n\t\t\t\tactual /= prediv;\n\t\t\t\tactual /= postdiv;\n\t\t\t\tdelta = actual - desired;\n\t\t\t\tdelta = abs(delta);\n\n\t\t\t\tif ((delta < bestdelta) || (bestdelta == -1)) {\n\t\t\t\t\tbestdelta = delta;\n\t\t\t\t\tctrl1_reg = ctrl1[i].reg;\n\t\t\t\t\tctrl2_reg = mult;\n\t\t\t\t\tctrl3_reg = ctrl3[j].reg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tov2659->pll.ctrl1 = ctrl1_reg;\n\tov2659->pll.ctrl2 = ctrl2_reg;\n\tov2659->pll.ctrl3 = ctrl3_reg;\n\n\tdev_dbg(&client->dev,\n\t\t\"Actual reg config: ctrl1_reg: %02x ctrl2_reg: %02x ctrl3_reg: %02x\\n\",\n\t\tctrl1_reg, ctrl2_reg, ctrl3_reg);\n}\n\nstatic int ov2659_set_pixel_clock(struct ov2659 *ov2659)\n{\n\tstruct i2c_client *client = ov2659->client;\n\tstruct sensor_register pll_regs[] = {\n\t\t{REG_SC_PLL_CTRL1, ov2659->pll.ctrl1},\n\t\t{REG_SC_PLL_CTRL2, ov2659->pll.ctrl2},\n\t\t{REG_SC_PLL_CTRL3, ov2659->pll.ctrl3},\n\t\t{REG_NULL, 0x00},\n\t};\n\n\tdev_dbg(&client->dev, \"%s\\n\", __func__);\n\n\treturn ov2659_write_array(client, pll_regs);\n};\n\nstatic void ov2659_get_default_format(struct v4l2_mbus_framefmt *format)\n{\n\tformat->width = ov2659_framesizes[2].width;\n\tformat->height = ov2659_framesizes[2].height;\n\tformat->colorspace = V4L2_COLORSPACE_SRGB;\n\tformat->code = ov2659_formats[0].code;\n\tformat->field = V4L2_FIELD_NONE;\n}\n\nstatic void ov2659_set_streaming(struct ov2659 *ov2659, int on)\n{\n\tstruct i2c_client *client = ov2659->client;\n\tint ret;\n\n\ton = !!on;\n\n\tdev_dbg(&client->dev, \"%s: on: %d\\n\", __func__, on);\n\n\tret = ov2659_write(client, REG_SOFTWARE_STANDBY, on);\n\tif (ret)\n\t\tdev_err(&client->dev, \"ov2659 soft standby failed\\n\");\n}\n\nstatic int ov2659_init(struct v4l2_subdev *sd, u32 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn ov2659_write_array(client, ov2659_init_regs);\n}\n\n \n\nstatic int ov2659_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tdev_dbg(&client->dev, \"%s:\\n\", __func__);\n\n\tif (code->index >= ARRAY_SIZE(ov2659_formats))\n\t\treturn -EINVAL;\n\n\tcode->code = ov2659_formats[code->index].code;\n\n\treturn 0;\n}\n\nstatic int ov2659_enum_frame_sizes(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint i = ARRAY_SIZE(ov2659_formats);\n\n\tdev_dbg(&client->dev, \"%s:\\n\", __func__);\n\n\tif (fse->index >= ARRAY_SIZE(ov2659_framesizes))\n\t\treturn -EINVAL;\n\n\twhile (--i)\n\t\tif (fse->code == ov2659_formats[i].code)\n\t\t\tbreak;\n\n\tfse->code = ov2659_formats[i].code;\n\n\tfse->min_width  = ov2659_framesizes[fse->index].width;\n\tfse->max_width  = fse->min_width;\n\tfse->max_height = ov2659_framesizes[fse->index].height;\n\tfse->min_height = fse->max_height;\n\n\treturn 0;\n}\n\nstatic int ov2659_get_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *fmt)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov2659 *ov2659 = to_ov2659(sd);\n\n\tdev_dbg(&client->dev, \"ov2659_get_fmt\\n\");\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\n\t\tstruct v4l2_mbus_framefmt *mf;\n\n\t\tmf = v4l2_subdev_get_try_format(sd, sd_state, 0);\n\t\tmutex_lock(&ov2659->lock);\n\t\tfmt->format = *mf;\n\t\tmutex_unlock(&ov2659->lock);\n\t\treturn 0;\n#else\n\t\treturn -EINVAL;\n#endif\n\t}\n\n\tmutex_lock(&ov2659->lock);\n\tfmt->format = ov2659->format;\n\tmutex_unlock(&ov2659->lock);\n\n\tdev_dbg(&client->dev, \"ov2659_get_fmt: %x %dx%d\\n\",\n\t\tov2659->format.code, ov2659->format.width,\n\t\tov2659->format.height);\n\n\treturn 0;\n}\n\nstatic void __ov2659_try_frame_size(struct v4l2_mbus_framefmt *mf,\n\t\t\t\t    const struct ov2659_framesize **size)\n{\n\tconst struct ov2659_framesize *fsize = &ov2659_framesizes[0];\n\tconst struct ov2659_framesize *match = NULL;\n\tint i = ARRAY_SIZE(ov2659_framesizes);\n\tunsigned int min_err = UINT_MAX;\n\n\twhile (i--) {\n\t\tint err = abs(fsize->width - mf->width)\n\t\t\t\t+ abs(fsize->height - mf->height);\n\t\tif ((err < min_err) && (fsize->regs[0].addr)) {\n\t\t\tmin_err = err;\n\t\t\tmatch = fsize;\n\t\t}\n\t\tfsize++;\n\t}\n\n\tif (!match)\n\t\tmatch = &ov2659_framesizes[2];\n\n\tmf->width  = match->width;\n\tmf->height = match->height;\n\n\tif (size)\n\t\t*size = match;\n}\n\nstatic int ov2659_set_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *fmt)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint index = ARRAY_SIZE(ov2659_formats);\n\tstruct v4l2_mbus_framefmt *mf = &fmt->format;\n\tconst struct ov2659_framesize *size = NULL;\n\tstruct ov2659 *ov2659 = to_ov2659(sd);\n\tint ret = 0;\n\n\tdev_dbg(&client->dev, \"ov2659_set_fmt\\n\");\n\n\t__ov2659_try_frame_size(mf, &size);\n\n\twhile (--index >= 0)\n\t\tif (ov2659_formats[index].code == mf->code)\n\t\t\tbreak;\n\n\tif (index < 0) {\n\t\tindex = 0;\n\t\tmf->code = ov2659_formats[index].code;\n\t}\n\n\tmf->colorspace = V4L2_COLORSPACE_SRGB;\n\tmf->field = V4L2_FIELD_NONE;\n\n\tmutex_lock(&ov2659->lock);\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\n\t\tmf = v4l2_subdev_get_try_format(sd, sd_state, fmt->pad);\n\t\t*mf = fmt->format;\n#endif\n\t} else {\n\t\ts64 val;\n\n\t\tif (ov2659->streaming) {\n\t\t\tmutex_unlock(&ov2659->lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tov2659->frame_size = size;\n\t\tov2659->format = fmt->format;\n\t\tov2659->format_ctrl_regs =\n\t\t\tov2659_formats[index].format_ctrl_regs;\n\n\t\tif (ov2659->format.code != MEDIA_BUS_FMT_SBGGR8_1X8)\n\t\t\tval = ov2659->pdata->link_frequency / 2;\n\t\telse\n\t\t\tval = ov2659->pdata->link_frequency;\n\n\t\tret = v4l2_ctrl_s_ctrl_int64(ov2659->link_frequency, val);\n\t\tif (ret < 0)\n\t\t\tdev_warn(&client->dev,\n\t\t\t\t \"failed to set link_frequency rate (%d)\\n\",\n\t\t\t\t ret);\n\t}\n\n\tmutex_unlock(&ov2659->lock);\n\treturn ret;\n}\n\nstatic int ov2659_set_frame_size(struct ov2659 *ov2659)\n{\n\tstruct i2c_client *client = ov2659->client;\n\n\tdev_dbg(&client->dev, \"%s\\n\", __func__);\n\n\treturn ov2659_write_array(ov2659->client, ov2659->frame_size->regs);\n}\n\nstatic int ov2659_set_format(struct ov2659 *ov2659)\n{\n\tstruct i2c_client *client = ov2659->client;\n\n\tdev_dbg(&client->dev, \"%s\\n\", __func__);\n\n\treturn ov2659_write_array(ov2659->client, ov2659->format_ctrl_regs);\n}\n\nstatic int ov2659_s_stream(struct v4l2_subdev *sd, int on)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov2659 *ov2659 = to_ov2659(sd);\n\tint ret = 0;\n\n\tdev_dbg(&client->dev, \"%s: on: %d\\n\", __func__, on);\n\n\tmutex_lock(&ov2659->lock);\n\n\ton = !!on;\n\n\tif (ov2659->streaming == on)\n\t\tgoto unlock;\n\n\tif (!on) {\n\t\t \n\t\tov2659_set_streaming(ov2659, 0);\n\t\tov2659->streaming = on;\n\t\tpm_runtime_put(&client->dev);\n\t\tgoto unlock;\n\t}\n\n\tret = pm_runtime_resume_and_get(&client->dev);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tret = ov2659_init(sd, 0);\n\tif (!ret)\n\t\tret = ov2659_set_pixel_clock(ov2659);\n\tif (!ret)\n\t\tret = ov2659_set_frame_size(ov2659);\n\tif (!ret)\n\t\tret = ov2659_set_format(ov2659);\n\tif (!ret) {\n\t\tov2659_set_streaming(ov2659, 1);\n\t\tov2659->streaming = on;\n\t}\n\nunlock:\n\tmutex_unlock(&ov2659->lock);\n\treturn ret;\n}\n\nstatic int ov2659_set_test_pattern(struct ov2659 *ov2659, int value)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&ov2659->sd);\n\tint ret;\n\tu8 val;\n\n\tret = ov2659_read(client, REG_PRE_ISP_CTRL00, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (value) {\n\tcase 0:\n\t\tval &= ~TEST_PATTERN_ENABLE;\n\t\tbreak;\n\tcase 1:\n\t\tval &= VERTICAL_COLOR_BAR_MASK;\n\t\tval |= TEST_PATTERN_ENABLE;\n\t\tbreak;\n\t}\n\n\treturn ov2659_write(client, REG_PRE_ISP_CTRL00, val);\n}\n\nstatic int ov2659_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ov2659 *ov2659 =\n\t\t\tcontainer_of(ctrl->handler, struct ov2659, ctrls);\n\tstruct i2c_client *client = ov2659->client;\n\n\t \n\tif (!pm_runtime_get_if_in_use(&client->dev))\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_TEST_PATTERN:\n\t\treturn ov2659_set_test_pattern(ov2659, ctrl->val);\n\t}\n\n\tpm_runtime_put(&client->dev);\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops ov2659_ctrl_ops = {\n\t.s_ctrl = ov2659_s_ctrl,\n};\n\nstatic const char * const ov2659_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Vertical Color Bars\",\n};\n\nstatic int ov2659_power_off(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov2659 *ov2659 = to_ov2659(sd);\n\n\tdev_dbg(&client->dev, \"%s:\\n\", __func__);\n\n\tgpiod_set_value(ov2659->pwdn_gpio, 1);\n\n\tclk_disable_unprepare(ov2659->clk);\n\n\treturn 0;\n}\n\nstatic int ov2659_power_on(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov2659 *ov2659 = to_ov2659(sd);\n\tint ret;\n\n\tdev_dbg(&client->dev, \"%s:\\n\", __func__);\n\n\tret = clk_prepare_enable(ov2659->clk);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s: failed to enable clock\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tgpiod_set_value(ov2659->pwdn_gpio, 0);\n\n\tif (ov2659->resetb_gpio) {\n\t\tgpiod_set_value(ov2659->resetb_gpio, 1);\n\t\tusleep_range(500, 1000);\n\t\tgpiod_set_value(ov2659->resetb_gpio, 0);\n\t\tusleep_range(3000, 5000);\n\t}\n\n\treturn 0;\n}\n\n \n\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\nstatic int ov2659_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format =\n\t\t\t\tv4l2_subdev_get_try_format(sd, fh->state, 0);\n\n\tdev_dbg(&client->dev, \"%s:\\n\", __func__);\n\n\tov2659_get_default_format(format);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct v4l2_subdev_core_ops ov2659_subdev_core_ops = {\n\t.log_status = v4l2_ctrl_subdev_log_status,\n\t.subscribe_event = v4l2_ctrl_subdev_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n};\n\nstatic const struct v4l2_subdev_video_ops ov2659_subdev_video_ops = {\n\t.s_stream = ov2659_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops ov2659_subdev_pad_ops = {\n\t.enum_mbus_code = ov2659_enum_mbus_code,\n\t.enum_frame_size = ov2659_enum_frame_sizes,\n\t.get_fmt = ov2659_get_fmt,\n\t.set_fmt = ov2659_set_fmt,\n};\n\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\nstatic const struct v4l2_subdev_ops ov2659_subdev_ops = {\n\t.core  = &ov2659_subdev_core_ops,\n\t.video = &ov2659_subdev_video_ops,\n\t.pad   = &ov2659_subdev_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops ov2659_subdev_internal_ops = {\n\t.open = ov2659_open,\n};\n#endif\n\nstatic int ov2659_detect(struct v4l2_subdev *sd)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tu8 pid = 0;\n\tu8 ver = 0;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"%s:\\n\", __func__);\n\n\tret = ov2659_write(client, REG_SOFTWARE_RESET, 0x01);\n\tif (ret != 0) {\n\t\tdev_err(&client->dev, \"Sensor soft reset failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\tusleep_range(1000, 2000);\n\n\t \n\tret = ov2659_read(client, REG_SC_CHIP_ID_H, &pid);\n\tif (!ret)\n\t\tret = ov2659_read(client, REG_SC_CHIP_ID_L, &ver);\n\n\tif (!ret) {\n\t\tunsigned short id;\n\n\t\tid = OV265X_ID(pid, ver);\n\t\tif (id != OV2659_ID) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Sensor detection failed (%04X)\\n\", id);\n\t\t\tret = -ENODEV;\n\t\t} else {\n\t\t\tdev_info(&client->dev, \"Found OV%04X sensor\\n\", id);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic struct ov2659_platform_data *\nov2659_get_pdata(struct i2c_client *client)\n{\n\tstruct ov2659_platform_data *pdata;\n\tstruct v4l2_fwnode_endpoint bus_cfg = { .bus_type = 0 };\n\tstruct device_node *endpoint;\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)\n\t\treturn client->dev.platform_data;\n\n\tendpoint = of_graph_get_next_endpoint(client->dev.of_node, NULL);\n\tif (!endpoint)\n\t\treturn NULL;\n\n\tret = v4l2_fwnode_endpoint_alloc_parse(of_fwnode_handle(endpoint),\n\t\t\t\t\t       &bus_cfg);\n\tif (ret) {\n\t\tpdata = NULL;\n\t\tgoto done;\n\t}\n\n\tpdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\tgoto done;\n\n\tif (!bus_cfg.nr_of_link_frequencies) {\n\t\tdev_err(&client->dev,\n\t\t\t\"link-frequencies property not found or too many\\n\");\n\t\tpdata = NULL;\n\t\tgoto done;\n\t}\n\n\tpdata->link_frequency = bus_cfg.link_frequencies[0];\n\ndone:\n\tv4l2_fwnode_endpoint_free(&bus_cfg);\n\tof_node_put(endpoint);\n\treturn pdata;\n}\n\nstatic int ov2659_probe(struct i2c_client *client)\n{\n\tconst struct ov2659_platform_data *pdata = ov2659_get_pdata(client);\n\tstruct v4l2_subdev *sd;\n\tstruct ov2659 *ov2659;\n\tint ret;\n\n\tif (!pdata) {\n\t\tdev_err(&client->dev, \"platform data not specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tov2659 = devm_kzalloc(&client->dev, sizeof(*ov2659), GFP_KERNEL);\n\tif (!ov2659)\n\t\treturn -ENOMEM;\n\n\tov2659->pdata = pdata;\n\tov2659->client = client;\n\n\tov2659->clk = devm_clk_get(&client->dev, \"xvclk\");\n\tif (IS_ERR(ov2659->clk))\n\t\treturn PTR_ERR(ov2659->clk);\n\n\tov2659->xvclk_frequency = clk_get_rate(ov2659->clk);\n\tif (ov2659->xvclk_frequency < 6000000 ||\n\t    ov2659->xvclk_frequency > 27000000)\n\t\treturn -EINVAL;\n\n\t \n\tov2659->pwdn_gpio = devm_gpiod_get_optional(&client->dev, \"powerdown\",\n\t\t\t\t\t\t    GPIOD_OUT_LOW);\n\tif (IS_ERR(ov2659->pwdn_gpio))\n\t\treturn PTR_ERR(ov2659->pwdn_gpio);\n\n\t \n\tov2659->resetb_gpio = devm_gpiod_get_optional(&client->dev, \"reset\",\n\t\t\t\t\t\t      GPIOD_OUT_HIGH);\n\tif (IS_ERR(ov2659->resetb_gpio))\n\t\treturn PTR_ERR(ov2659->resetb_gpio);\n\n\tv4l2_ctrl_handler_init(&ov2659->ctrls, 2);\n\tov2659->link_frequency =\n\t\t\tv4l2_ctrl_new_std(&ov2659->ctrls, &ov2659_ctrl_ops,\n\t\t\t\t\t  V4L2_CID_PIXEL_RATE,\n\t\t\t\t\t  pdata->link_frequency / 2,\n\t\t\t\t\t  pdata->link_frequency, 1,\n\t\t\t\t\t  pdata->link_frequency);\n\tv4l2_ctrl_new_std_menu_items(&ov2659->ctrls, &ov2659_ctrl_ops,\n\t\t\t\t     V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(ov2659_test_pattern_menu) - 1,\n\t\t\t\t     0, 0, ov2659_test_pattern_menu);\n\tov2659->sd.ctrl_handler = &ov2659->ctrls;\n\n\tif (ov2659->ctrls.error) {\n\t\tdev_err(&client->dev, \"%s: control initialization error %d\\n\",\n\t\t\t__func__, ov2659->ctrls.error);\n\t\treturn  ov2659->ctrls.error;\n\t}\n\n\tsd = &ov2659->sd;\n\tclient->flags |= I2C_CLIENT_SCCB;\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\n\tv4l2_i2c_subdev_init(sd, client, &ov2659_subdev_ops);\n\n\tsd->internal_ops = &ov2659_subdev_internal_ops;\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |\n\t\t     V4L2_SUBDEV_FL_HAS_EVENTS;\n#endif\n\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tov2659->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tsd->entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tret = media_entity_pads_init(&sd->entity, 1, &ov2659->pad);\n\tif (ret < 0) {\n\t\tv4l2_ctrl_handler_free(&ov2659->ctrls);\n\t\treturn ret;\n\t}\n#endif\n\n\tmutex_init(&ov2659->lock);\n\n\tov2659_get_default_format(&ov2659->format);\n\tov2659->frame_size = &ov2659_framesizes[2];\n\tov2659->format_ctrl_regs = ov2659_formats[0].format_ctrl_regs;\n\n\tret = ov2659_power_on(&client->dev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = ov2659_detect(sd);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tov2659_pll_calc_params(ov2659);\n\n\tret = v4l2_async_register_subdev(&ov2659->sd);\n\tif (ret)\n\t\tgoto error;\n\n\tdev_info(&client->dev, \"%s sensor driver registered !!\\n\", sd->name);\n\n\tpm_runtime_set_active(&client->dev);\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_idle(&client->dev);\n\n\treturn 0;\n\nerror:\n\tv4l2_ctrl_handler_free(&ov2659->ctrls);\n\tov2659_power_off(&client->dev);\n\tmedia_entity_cleanup(&sd->entity);\n\tmutex_destroy(&ov2659->lock);\n\treturn ret;\n}\n\nstatic void ov2659_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov2659 *ov2659 = to_ov2659(sd);\n\n\tv4l2_ctrl_handler_free(&ov2659->ctrls);\n\tv4l2_async_unregister_subdev(sd);\n\tmedia_entity_cleanup(&sd->entity);\n\tmutex_destroy(&ov2659->lock);\n\n\tpm_runtime_disable(&client->dev);\n\tif (!pm_runtime_status_suspended(&client->dev))\n\t\tov2659_power_off(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n}\n\nstatic const struct dev_pm_ops ov2659_pm_ops = {\n\tSET_RUNTIME_PM_OPS(ov2659_power_off, ov2659_power_on, NULL)\n};\n\nstatic const struct i2c_device_id ov2659_id[] = {\n\t{ \"ov2659\", 0 },\n\t{   },\n};\nMODULE_DEVICE_TABLE(i2c, ov2659_id);\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id ov2659_of_match[] = {\n\t{ .compatible = \"ovti,ov2659\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ov2659_of_match);\n#endif\n\nstatic struct i2c_driver ov2659_i2c_driver = {\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t\t.pm\t= &ov2659_pm_ops,\n\t\t.of_match_table = of_match_ptr(ov2659_of_match),\n\t},\n\t.probe\t\t= ov2659_probe,\n\t.remove\t\t= ov2659_remove,\n\t.id_table\t= ov2659_id,\n};\n\nmodule_i2c_driver(ov2659_i2c_driver);\n\nMODULE_AUTHOR(\"Benoit Parrot <bparrot@ti.com>\");\nMODULE_DESCRIPTION(\"OV2659 CMOS Image Sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}