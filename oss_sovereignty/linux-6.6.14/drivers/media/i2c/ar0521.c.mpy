{
  "module_name": "ar0521.c",
  "hash_id": "ce0150f46e7a201506c9eda2f8b867933cae60d79d177545b97ec6af6eef379d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ar0521.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n \n#define AR0521_EXTCLK_MIN\t\t(10 * 1000 * 1000)\n#define AR0521_EXTCLK_MAX\t\t(48 * 1000 * 1000)\n\n \n#define AR0521_PLL_MIN\t\t\t(320 * 1000 * 1000)\n#define AR0521_PLL_MAX\t\t\t(1280 * 1000 * 1000)\n\n \n#define AR0521_PIXEL_CLOCK_RATE\t\t(184 * 1000 * 1000)\n#define AR0521_PIXEL_CLOCK_MIN\t\t(168 * 1000 * 1000)\n#define AR0521_PIXEL_CLOCK_MAX\t\t(414 * 1000 * 1000)\n\n#define AR0521_NATIVE_WIDTH\t\t2604u\n#define AR0521_NATIVE_HEIGHT\t\t1964u\n#define AR0521_MIN_X_ADDR_START\t\t0u\n#define AR0521_MIN_Y_ADDR_START\t\t0u\n#define AR0521_MAX_X_ADDR_END\t\t2603u\n#define AR0521_MAX_Y_ADDR_END\t\t1955u\n\n#define AR0521_WIDTH_MIN\t\t8u\n#define AR0521_WIDTH_MAX\t\t2592u\n#define AR0521_HEIGHT_MIN\t\t8u\n#define AR0521_HEIGHT_MAX\t\t1944u\n\n#define AR0521_WIDTH_BLANKING_MIN\t572u\n#define AR0521_HEIGHT_BLANKING_MIN\t38u  \n#define AR0521_TOTAL_HEIGHT_MAX\t\t65535u  \n#define AR0521_TOTAL_WIDTH_MAX\t\t65532u  \n\n#define AR0521_ANA_GAIN_MIN\t\t0x00\n#define AR0521_ANA_GAIN_MAX\t\t0x3f\n#define AR0521_ANA_GAIN_STEP\t\t0x01\n#define AR0521_ANA_GAIN_DEFAULT\t\t0x00\n\n \n#define AR0521_REG_VT_PIX_CLK_DIV\t\t0x0300\n#define AR0521_REG_FRAME_LENGTH_LINES\t\t0x0340\n\n#define AR0521_REG_CHIP_ID\t\t\t0x3000\n#define AR0521_REG_COARSE_INTEGRATION_TIME\t0x3012\n#define AR0521_REG_ROW_SPEED\t\t\t0x3016\n#define AR0521_REG_EXTRA_DELAY\t\t\t0x3018\n#define AR0521_REG_RESET\t\t\t0x301A\n#define   AR0521_REG_RESET_DEFAULTS\t\t  0x0238\n#define   AR0521_REG_RESET_GROUP_PARAM_HOLD\t  0x8000\n#define   AR0521_REG_RESET_STREAM\t\t  BIT(2)\n#define   AR0521_REG_RESET_RESTART\t\t  BIT(1)\n#define   AR0521_REG_RESET_INIT\t\t\t  BIT(0)\n\n#define AR0521_REG_ANA_GAIN_CODE_GLOBAL\t\t0x3028\n\n#define AR0521_REG_GREEN1_GAIN\t\t\t0x3056\n#define AR0521_REG_BLUE_GAIN\t\t\t0x3058\n#define AR0521_REG_RED_GAIN\t\t\t0x305A\n#define AR0521_REG_GREEN2_GAIN\t\t\t0x305C\n#define AR0521_REG_GLOBAL_GAIN\t\t\t0x305E\n\n#define AR0521_REG_HISPI_TEST_MODE\t\t0x3066\n#define AR0521_REG_HISPI_TEST_MODE_LP11\t\t  0x0004\n\n#define AR0521_REG_TEST_PATTERN_MODE\t\t0x3070\n\n#define AR0521_REG_SERIAL_FORMAT\t\t0x31AE\n#define AR0521_REG_SERIAL_FORMAT_MIPI\t\t  0x0200\n\n#define AR0521_REG_HISPI_CONTROL_STATUS\t\t0x31C6\n#define AR0521_REG_HISPI_CONTROL_STATUS_FRAMER_TEST_MODE_ENABLE 0x80\n\n#define be\t\tcpu_to_be16\n\nstatic const char * const ar0521_supply_names[] = {\n\t\"vdd_io\",\t \n\t\"vdd\",\t\t \n\t\"vaa\",\t\t \n};\n\nstatic const s64 ar0521_link_frequencies[] = {\n\t184000000,\n};\n\nstruct ar0521_ctrls {\n\tstruct v4l2_ctrl_handler handler;\n\tstruct {\n\t\tstruct v4l2_ctrl *gain;\n\t\tstruct v4l2_ctrl *red_balance;\n\t\tstruct v4l2_ctrl *blue_balance;\n\t};\n\tstruct {\n\t\tstruct v4l2_ctrl *hblank;\n\t\tstruct v4l2_ctrl *vblank;\n\t};\n\tstruct v4l2_ctrl *pixrate;\n\tstruct v4l2_ctrl *exposure;\n\tstruct v4l2_ctrl *test_pattern;\n};\n\nstruct ar0521_dev {\n\tstruct i2c_client *i2c_client;\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pad;\n\tstruct clk *extclk;\n\tu32 extclk_freq;\n\n\tstruct regulator *supplies[ARRAY_SIZE(ar0521_supply_names)];\n\tstruct gpio_desc *reset_gpio;\n\n\t \n\tstruct mutex lock;\n\n\tstruct v4l2_mbus_framefmt fmt;\n\tstruct ar0521_ctrls ctrls;\n\tunsigned int lane_count;\n\tstruct {\n\t\tu16 pre;\n\t\tu16 mult;\n\t\tu16 pre2;\n\t\tu16 mult2;\n\t\tu16 vt_pix;\n\t} pll;\n\n\tbool streaming;\n};\n\nstatic inline struct ar0521_dev *to_ar0521_dev(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct ar0521_dev, sd);\n}\n\nstatic inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct ar0521_dev,\n\t\t\t     ctrls.handler)->sd;\n}\n\nstatic u32 div64_round(u64 v, u32 d)\n{\n\treturn div_u64(v + (d >> 1), d);\n}\n\nstatic u32 div64_round_up(u64 v, u32 d)\n{\n\treturn div_u64(v + d - 1, d);\n}\n\nstatic int ar0521_code_to_bpp(struct ar0521_dev *sensor)\n{\n\tswitch (sensor->fmt.code) {\n\tcase MEDIA_BUS_FMT_SGRBG8_1X8:\n\t\treturn 8;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int ar0521_write_regs(struct ar0521_dev *sensor, const __be16 *data,\n\t\t\t     unsigned int count)\n{\n\tstruct i2c_client *client = sensor->i2c_client;\n\tstruct i2c_msg msg;\n\tint ret;\n\n\tmsg.addr = client->addr;\n\tmsg.flags = client->flags;\n\tmsg.buf = (u8 *)data;\n\tmsg.len = count * sizeof(*data);\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\n\tif (ret < 0) {\n\t\tv4l2_err(&sensor->sd, \"%s: I2C write error\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ar0521_write_reg(struct ar0521_dev *sensor, u16 reg, u16 val)\n{\n\t__be16 buf[2] = {be(reg), be(val)};\n\n\treturn ar0521_write_regs(sensor, buf, 2);\n}\n\nstatic int ar0521_set_geometry(struct ar0521_dev *sensor)\n{\n\t \n\tu16 x = clamp((AR0521_WIDTH_MAX - sensor->fmt.width) / 2,\n\t\t       AR0521_MIN_X_ADDR_START, AR0521_MAX_X_ADDR_END);\n\tu16 y = clamp(((AR0521_HEIGHT_MAX - sensor->fmt.height) / 2) & ~1,\n\t\t       AR0521_MIN_Y_ADDR_START, AR0521_MAX_Y_ADDR_END);\n\n\t \n\t__be16 regs[] = {\n\t\tbe(AR0521_REG_FRAME_LENGTH_LINES),\n\t\tbe(sensor->fmt.height + sensor->ctrls.vblank->val),\n\t\tbe(sensor->fmt.width + sensor->ctrls.hblank->val),\n\t\tbe(x),\n\t\tbe(y),\n\t\tbe(x + sensor->fmt.width - 1),\n\t\tbe(y + sensor->fmt.height - 1),\n\t\tbe(sensor->fmt.width),\n\t\tbe(sensor->fmt.height)\n\t};\n\n\treturn ar0521_write_regs(sensor, regs, ARRAY_SIZE(regs));\n}\n\nstatic int ar0521_set_gains(struct ar0521_dev *sensor)\n{\n\tint green = sensor->ctrls.gain->val;\n\tint red = max(green + sensor->ctrls.red_balance->val, 0);\n\tint blue = max(green + sensor->ctrls.blue_balance->val, 0);\n\tunsigned int gain = min(red, min(green, blue));\n\tunsigned int analog = min(gain, 64u);  \n\t__be16 regs[5];\n\n\tred   = min(red   - analog + 64, 511u);\n\tgreen = min(green - analog + 64, 511u);\n\tblue  = min(blue  - analog + 64, 511u);\n\tregs[0] = be(AR0521_REG_GREEN1_GAIN);\n\tregs[1] = be(green << 7 | analog);\n\tregs[2] = be(blue  << 7 | analog);\n\tregs[3] = be(red   << 7 | analog);\n\tregs[4] = be(green << 7 | analog);\n\n\treturn ar0521_write_regs(sensor, regs, ARRAY_SIZE(regs));\n}\n\nstatic u32 calc_pll(struct ar0521_dev *sensor, u32 freq, u16 *pre_ptr, u16 *mult_ptr)\n{\n\tu16 pre = 1, mult = 1, new_pre;\n\tu32 pll = AR0521_PLL_MAX + 1;\n\n\tfor (new_pre = 1; new_pre < 64; new_pre++) {\n\t\tu32 new_pll;\n\t\tu32 new_mult = div64_round_up((u64)freq * new_pre,\n\t\t\t\t\t      sensor->extclk_freq);\n\n\t\tif (new_mult < 32)\n\t\t\tcontinue;  \n\t\tif (new_mult > 254)\n\t\t\tbreak;  \n\t\tif (sensor->extclk_freq * (u64)new_mult < AR0521_PLL_MIN *\n\t\t    new_pre)\n\t\t\tcontinue;\n\t\tif (sensor->extclk_freq * (u64)new_mult > AR0521_PLL_MAX *\n\t\t    new_pre)\n\t\t\tbreak;  \n\t\tnew_pll = div64_round_up(sensor->extclk_freq * (u64)new_mult,\n\t\t\t\t\t new_pre);\n\t\tif (new_pll < pll) {\n\t\t\tpll = new_pll;\n\t\t\tpre = new_pre;\n\t\t\tmult = new_mult;\n\t\t}\n\t}\n\n\tpll = div64_round(sensor->extclk_freq * (u64)mult, pre);\n\t*pre_ptr = pre;\n\t*mult_ptr = mult;\n\treturn pll;\n}\n\nstatic void ar0521_calc_pll(struct ar0521_dev *sensor)\n{\n\tunsigned int pixel_clock;\n\tu16 pre, mult;\n\tu32 vco;\n\tint bpp;\n\n\t \n\tpixel_clock = AR0521_PIXEL_CLOCK_RATE * 2 / sensor->lane_count;\n\tbpp = ar0521_code_to_bpp(sensor);\n\tsensor->pll.vt_pix = bpp / 2;\n\tvco = pixel_clock * sensor->pll.vt_pix;\n\n\tcalc_pll(sensor, vco, &pre, &mult);\n\n\tsensor->pll.pre = sensor->pll.pre2 = pre;\n\tsensor->pll.mult = sensor->pll.mult2 = mult;\n}\n\nstatic int ar0521_pll_config(struct ar0521_dev *sensor)\n{\n\t__be16 pll_regs[] = {\n\t\tbe(AR0521_REG_VT_PIX_CLK_DIV),\n\t\t  be(sensor->pll.vt_pix),  \n\t\t  be(1),  \n\t\t  be((sensor->pll.pre2 << 8) | sensor->pll.pre),\n\t\t  be((sensor->pll.mult2 << 8) | sensor->pll.mult),\n\t\t  be(sensor->pll.vt_pix * 2),  \n\t\t  be(1)   \n\t};\n\n\tar0521_calc_pll(sensor);\n\treturn ar0521_write_regs(sensor, pll_regs, ARRAY_SIZE(pll_regs));\n}\n\nstatic int ar0521_set_stream(struct ar0521_dev *sensor, bool on)\n{\n\tint ret;\n\n\tif (on) {\n\t\tret = pm_runtime_resume_and_get(&sensor->i2c_client->dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = ar0521_write_reg(sensor, AR0521_REG_RESET,\n\t\t\t\t       AR0521_REG_RESET_DEFAULTS);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ar0521_set_geometry(sensor);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ar0521_pll_config(sensor);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret =  __v4l2_ctrl_handler_setup(&sensor->ctrls.handler);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tret = ar0521_write_reg(sensor, AR0521_REG_HISPI_CONTROL_STATUS,\n\t\t\t\t       0);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tret = ar0521_write_reg(sensor, AR0521_REG_RESET,\n\t\t\t\t       AR0521_REG_RESET_DEFAULTS |\n\t\t\t\t       AR0521_REG_RESET_STREAM);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\treturn 0;\n\nerr:\n\t\tpm_runtime_put(&sensor->i2c_client->dev);\n\t\treturn ret;\n\n\t} else {\n\t\t \n\t\tret = ar0521_write_reg(sensor, AR0521_REG_GLOBAL_GAIN, 0x2000);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = ar0521_write_reg(sensor, AR0521_REG_RESET,\n\t\t\t\t       AR0521_REG_RESET_DEFAULTS);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpm_runtime_put(&sensor->i2c_client->dev);\n\t\treturn 0;\n\t}\n}\n\nstatic void ar0521_adj_fmt(struct v4l2_mbus_framefmt *fmt)\n{\n\tfmt->width = clamp(ALIGN(fmt->width, 4), AR0521_WIDTH_MIN,\n\t\t\t   AR0521_WIDTH_MAX);\n\tfmt->height = clamp(ALIGN(fmt->height, 4), AR0521_HEIGHT_MIN,\n\t\t\t    AR0521_HEIGHT_MAX);\n\tfmt->code = MEDIA_BUS_FMT_SGRBG8_1X8;\n\tfmt->field = V4L2_FIELD_NONE;\n\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n\tfmt->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tfmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\tfmt->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n}\n\nstatic int ar0521_get_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct ar0521_dev *sensor = to_ar0521_dev(sd);\n\tstruct v4l2_mbus_framefmt *fmt;\n\n\tmutex_lock(&sensor->lock);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\tfmt = v4l2_subdev_get_try_format(&sensor->sd, sd_state, 0\n\t\t\t\t\t\t  );\n\telse\n\t\tfmt = &sensor->fmt;\n\n\tformat->format = *fmt;\n\n\tmutex_unlock(&sensor->lock);\n\treturn 0;\n}\n\nstatic int ar0521_set_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct ar0521_dev *sensor = to_ar0521_dev(sd);\n\tint max_vblank, max_hblank, exposure_max;\n\tint ret;\n\n\tar0521_adj_fmt(&format->format);\n\n\tmutex_lock(&sensor->lock);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tstruct v4l2_mbus_framefmt *fmt;\n\n\t\tfmt = v4l2_subdev_get_try_format(sd, sd_state, 0  );\n\t\t*fmt = format->format;\n\n\t\tmutex_unlock(&sensor->lock);\n\n\t\treturn 0;\n\t}\n\n\tsensor->fmt = format->format;\n\tar0521_calc_pll(sensor);\n\n\t \n\tmax_hblank = AR0521_TOTAL_WIDTH_MAX - sensor->fmt.width;\n\tret = __v4l2_ctrl_modify_range(sensor->ctrls.hblank,\n\t\t\t\t       sensor->ctrls.hblank->minimum,\n\t\t\t\t       max_hblank, sensor->ctrls.hblank->step,\n\t\t\t\t       sensor->ctrls.hblank->minimum);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = __v4l2_ctrl_s_ctrl(sensor->ctrls.hblank,\n\t\t\t\t sensor->ctrls.hblank->minimum);\n\tif (ret)\n\t\tgoto unlock;\n\n\tmax_vblank = AR0521_TOTAL_HEIGHT_MAX - sensor->fmt.height;\n\tret = __v4l2_ctrl_modify_range(sensor->ctrls.vblank,\n\t\t\t\t       sensor->ctrls.vblank->minimum,\n\t\t\t\t       max_vblank, sensor->ctrls.vblank->step,\n\t\t\t\t       sensor->ctrls.vblank->minimum);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = __v4l2_ctrl_s_ctrl(sensor->ctrls.vblank,\n\t\t\t\t sensor->ctrls.vblank->minimum);\n\tif (ret)\n\t\tgoto unlock;\n\n\texposure_max = sensor->fmt.height + AR0521_HEIGHT_BLANKING_MIN - 4;\n\tret = __v4l2_ctrl_modify_range(sensor->ctrls.exposure,\n\t\t\t\t       sensor->ctrls.exposure->minimum,\n\t\t\t\t       exposure_max,\n\t\t\t\t       sensor->ctrls.exposure->step,\n\t\t\t\t       sensor->ctrls.exposure->default_value);\nunlock:\n\tmutex_unlock(&sensor->lock);\n\n\treturn ret;\n}\n\nstatic int ar0521_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = ctrl_to_sd(ctrl);\n\tstruct ar0521_dev *sensor = to_ar0521_dev(sd);\n\tint exp_max;\n\tint ret;\n\n\t \n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_VBLANK:\n\t\texp_max = sensor->fmt.height + ctrl->val - 4;\n\t\t__v4l2_ctrl_modify_range(sensor->ctrls.exposure,\n\t\t\t\t\t sensor->ctrls.exposure->minimum,\n\t\t\t\t\t exp_max, sensor->ctrls.exposure->step,\n\t\t\t\t\t sensor->ctrls.exposure->default_value);\n\t\tbreak;\n\t}\n\n\t \n\tif (!pm_runtime_get_if_in_use(&sensor->i2c_client->dev))\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_HBLANK:\n\tcase V4L2_CID_VBLANK:\n\t\tret = ar0521_set_geometry(sensor);\n\t\tbreak;\n\tcase V4L2_CID_ANALOGUE_GAIN:\n\t\tret = ar0521_write_reg(sensor, AR0521_REG_ANA_GAIN_CODE_GLOBAL,\n\t\t\t\t       ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_GAIN:\n\tcase V4L2_CID_RED_BALANCE:\n\tcase V4L2_CID_BLUE_BALANCE:\n\t\tret = ar0521_set_gains(sensor);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE:\n\t\tret = ar0521_write_reg(sensor,\n\t\t\t\t       AR0521_REG_COARSE_INTEGRATION_TIME,\n\t\t\t\t       ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tret = ar0521_write_reg(sensor, AR0521_REG_TEST_PATTERN_MODE,\n\t\t\t\t       ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&sensor->i2c_client->dev,\n\t\t\t\"Unsupported control %x\\n\", ctrl->id);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tpm_runtime_put(&sensor->i2c_client->dev);\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops ar0521_ctrl_ops = {\n\t.s_ctrl = ar0521_s_ctrl,\n};\n\nstatic const char * const test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Solid color\",\n\t\"Color bars\",\n\t\"Faded color bars\"\n};\n\nstatic int ar0521_init_controls(struct ar0521_dev *sensor)\n{\n\tconst struct v4l2_ctrl_ops *ops = &ar0521_ctrl_ops;\n\tstruct ar0521_ctrls *ctrls = &sensor->ctrls;\n\tstruct v4l2_ctrl_handler *hdl = &ctrls->handler;\n\tint max_vblank, max_hblank, exposure_max;\n\tstruct v4l2_ctrl *link_freq;\n\tint ret;\n\n\tv4l2_ctrl_handler_init(hdl, 32);\n\n\t \n\thdl->lock = &sensor->lock;\n\n\t \n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_ANALOGUE_GAIN,\n\t\t\t  AR0521_ANA_GAIN_MIN, AR0521_ANA_GAIN_MAX,\n\t\t\t  AR0521_ANA_GAIN_STEP, AR0521_ANA_GAIN_DEFAULT);\n\n\t \n\tctrls->gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_GAIN, 0, 511, 1, 0);\n\tctrls->red_balance = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_RED_BALANCE,\n\t\t\t\t\t       -512, 511, 1, 0);\n\tctrls->blue_balance = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_BLUE_BALANCE,\n\t\t\t\t\t\t-512, 511, 1, 0);\n\tv4l2_ctrl_cluster(3, &ctrls->gain);\n\n\t \n\tmax_hblank = AR0521_TOTAL_WIDTH_MAX - AR0521_WIDTH_MAX;\n\tctrls->hblank = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HBLANK,\n\t\t\t\t\t  AR0521_WIDTH_BLANKING_MIN,\n\t\t\t\t\t  max_hblank, 1,\n\t\t\t\t\t  AR0521_WIDTH_BLANKING_MIN);\n\n\tmax_vblank = AR0521_TOTAL_HEIGHT_MAX - AR0521_HEIGHT_MAX;\n\tctrls->vblank = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VBLANK,\n\t\t\t\t\t  AR0521_HEIGHT_BLANKING_MIN,\n\t\t\t\t\t  max_vblank, 2,\n\t\t\t\t\t  AR0521_HEIGHT_BLANKING_MIN);\n\tv4l2_ctrl_cluster(2, &ctrls->hblank);\n\n\t \n\tctrls->pixrate = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_PIXEL_RATE,\n\t\t\t\t\t   AR0521_PIXEL_CLOCK_MIN,\n\t\t\t\t\t   AR0521_PIXEL_CLOCK_MAX, 1,\n\t\t\t\t\t   AR0521_PIXEL_CLOCK_RATE);\n\n\t \n\texposure_max = AR0521_HEIGHT_MAX + AR0521_HEIGHT_BLANKING_MIN - 4;\n\tctrls->exposure = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_EXPOSURE, 0,\n\t\t\t\t\t    exposure_max, 1, 0x70);\n\n\tlink_freq = v4l2_ctrl_new_int_menu(hdl, ops, V4L2_CID_LINK_FREQ,\n\t\t\t\t\tARRAY_SIZE(ar0521_link_frequencies) - 1,\n\t\t\t\t\t0, ar0521_link_frequencies);\n\tif (link_freq)\n\t\tlink_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tctrls->test_pattern = v4l2_ctrl_new_std_menu_items(hdl, ops,\n\t\t\t\t\tV4L2_CID_TEST_PATTERN,\n\t\t\t\t\tARRAY_SIZE(test_pattern_menu) - 1,\n\t\t\t\t\t0, 0, test_pattern_menu);\n\n\tif (hdl->error) {\n\t\tret = hdl->error;\n\t\tgoto free_ctrls;\n\t}\n\n\tsensor->sd.ctrl_handler = hdl;\n\treturn 0;\n\nfree_ctrls:\n\tv4l2_ctrl_handler_free(hdl);\n\treturn ret;\n}\n\n#define REGS_ENTRY(a)\t{(a), ARRAY_SIZE(a)}\n#define REGS(...)\tREGS_ENTRY(((const __be16[]){__VA_ARGS__}))\n\nstatic const struct initial_reg {\n\tconst __be16 *data;  \n\tunsigned int count;\n} initial_regs[] = {\n\tREGS(be(0x0112), be(0x0808)),  \n\n\t \n\tREGS(be(0x301E), be(0x00AA)),\n\n\t \n\tREGS(be(0x3042),\n\t     be(0x0004),   \n\t     be(0x4580)),  \n\n\tREGS(be(0x30D2),\n\t     be(0x0000),   \n\t     be(0x0000),   \n\t      \n\t     be(0x2FFF)),\n\n\tREGS(be(0x30DA),\n\t     be(0x0FFF),   \n\t     be(0x0FFF),   \n\t     be(0x0000)),  \n\n\t \n\tREGS(be(0x30EE), be(0x1136)),\n\tREGS(be(0x30FA), be(0xFD00)),  \n\tREGS(be(0x3120), be(0x0005)),  \n\tREGS(be(0x3172), be(0x0206)),  \n\t \n\tREGS(be(0x3180), be(0x9434)),\n\n\tREGS(be(0x31B0),\n\t     be(0x008B),   \n\t     be(0x0050)),  \n\n\t \n\tREGS(be(0x31BC), be(0x068C)),\n\tREGS(be(0x31E0), be(0x0781)),  \n\n\t \n\tREGS(be(0x341A), be(0x4735)),  \n\tREGS(be(0x3420), be(0x4735)),  \n\tREGS(be(0x3426), be(0x8A1A)),  \n\tREGS(be(0x342A), be(0x0018)),  \n\n\t \n\tREGS(be(0x3D00),\n\t       be(0x043E), be(0x4760), be(0xFFFF), be(0xFFFF),\n\t       be(0x8000), be(0x0510), be(0xAF08), be(0x0252),\n\t       be(0x486F), be(0x5D5D), be(0x8056), be(0x8313),\n\t       be(0x0087), be(0x6A48), be(0x6982), be(0x0280),\n\t       be(0x8359), be(0x8D02), be(0x8020), be(0x4882),\n\t       be(0x4269), be(0x6A95), be(0x5988), be(0x5A83),\n\t       be(0x5885), be(0x6280), be(0x6289), be(0x6097),\n\t       be(0x5782), be(0x605C), be(0xBF18), be(0x0961),\n\t       be(0x5080), be(0x2090), be(0x4390), be(0x4382),\n\t       be(0x5F8A), be(0x5D5D), be(0x9C63), be(0x8063),\n\t       be(0xA960), be(0x9757), be(0x8260), be(0x5CFF),\n\t       be(0xBF10), be(0x1681), be(0x0802), be(0x8000),\n\t       be(0x141C), be(0x6000), be(0x6022), be(0x4D80),\n\t       be(0x5C97), be(0x6A69), be(0xAC6F), be(0x4645),\n\t       be(0x4400), be(0x0513), be(0x8069), be(0x6AC6),\n\t       be(0x5F95), be(0x5F70), be(0x8040), be(0x4A81),\n\t       be(0x0300), be(0xE703), be(0x0088), be(0x4A83),\n\t       be(0x40FF), be(0xFFFF), be(0xFD70), be(0x8040),\n\t       be(0x4A85), be(0x4FA8), be(0x4F8C), be(0x0070),\n\t       be(0xBE47), be(0x8847), be(0xBC78), be(0x6B89),\n\t       be(0x6A80), be(0x6986), be(0x6B8E), be(0x6B80),\n\t       be(0x6980), be(0x6A88), be(0x7C9F), be(0x866B),\n\t       be(0x8765), be(0x46FF), be(0xE365), be(0xA679),\n\t       be(0x4A40), be(0x4580), be(0x44BC), be(0x7000),\n\t       be(0x8040), be(0x0802), be(0x10EF), be(0x0104),\n\t       be(0x3860), be(0x5D5D), be(0x5682), be(0x1300),\n\t       be(0x8648), be(0x8202), be(0x8082), be(0x598A),\n\t       be(0x0280), be(0x2048), be(0x3060), be(0x8042),\n\t       be(0x9259), be(0x865A), be(0x8258), be(0x8562),\n\t       be(0x8062), be(0x8560), be(0x9257), be(0x8221),\n\t       be(0x10FF), be(0xB757), be(0x9361), be(0x1019),\n\t       be(0x8020), be(0x9043), be(0x8E43), be(0x845F),\n\t       be(0x835D), be(0x805D), be(0x8163), be(0x8063),\n\t       be(0xA060), be(0x9157), be(0x8260), be(0x5CFF),\n\t       be(0xFFFF), be(0xFFE5), be(0x1016), be(0x2048),\n\t       be(0x0802), be(0x1C60), be(0x0014), be(0x0060),\n\t       be(0x2205), be(0x8120), be(0x908F), be(0x6A80),\n\t       be(0x6982), be(0x5F9F), be(0x6F46), be(0x4544),\n\t       be(0x0005), be(0x8013), be(0x8069), be(0x6A80),\n\t       be(0x7000), be(0x0000), be(0x0000), be(0x0000),\n\t       be(0x0000), be(0x0000), be(0x0000), be(0x0000),\n\t       be(0x0000), be(0x0000), be(0x0000), be(0x0000),\n\t       be(0x0000), be(0x0000), be(0x0000), be(0x0000),\n\t       be(0x0000), be(0x0000), be(0x0000), be(0x0000),\n\t       be(0x0000), be(0x0000), be(0x0000), be(0x0000),\n\t       be(0x0000), be(0x0000), be(0x0000), be(0x0000),\n\t       be(0x0000), be(0x0000), be(0x0000), be(0x0000),\n\t       be(0x0000), be(0x0000), be(0x0000), be(0x0000),\n\t       be(0x0000), be(0x0000), be(0x0000), be(0x0000),\n\t       be(0x0000), be(0x0000), be(0x0000), be(0x0000),\n\t       be(0x0000), be(0x0000), be(0x0000), be(0x0000),\n\t       be(0x0000), be(0x0000), be(0x0000), be(0x0000),\n\t       be(0x0000), be(0x0000), be(0x0000), be(0x0000),\n\t       be(0x0000), be(0x0000), be(0x0000), be(0x0000),\n\t       be(0x0000), be(0x0000), be(0x0000)),\n\n\tREGS(be(0x3EB6), be(0x004C)),  \n\n\tREGS(be(0x3EBA),\n\t     be(0xAAAD),   \n\t     be(0x0086)),  \n\n\tREGS(be(0x3EC0),\n\t     be(0x1E00),   \n\t     be(0x100A),   \n\t      \n\t     be(0x3300),\n\t     be(0xEA44),   \n\t     be(0x6F6F),   \n\t     be(0x2F4A),   \n\t     be(0x0506),   \n\t      \n\t     be(0x203B),\n\t     be(0x13F0),   \n\t     be(0xA53D),   \n\t     be(0x862F),   \n\t     be(0x4081),   \n\t     be(0x8003),   \n\t     be(0xA580),   \n\t     be(0xC000),   \n\t     be(0xC103)),  \n\n\t \n\tREGS(be(0x3F00),\n\t     be(0x0017),   \n\t     be(0x02DD),   \n\t      \n\t     be(0x0020),\n\t      \n\t     be(0x0040),\n\t      \n\t     be(0x0070),\n\t      \n\t     be(0x0101),\n\t     be(0x0302)),  \n\n\tREGS(be(0x3F10),\n\t     be(0x0505),   \n\t     be(0x0505),   \n\t     be(0x0505),   \n\t     be(0x01FF),   \n\t     be(0x01FF),   \n\t     be(0x01FF),   \n\t     be(0x0022)),  \n\n\t \n\tREGS(be(0x3F2C), be(0x442E)),\n\n\tREGS(be(0x3F3E),\n\t     be(0x0000),   \n\t     be(0x1511),   \n\t     be(0x1511),   \n\t     be(0x0707)),  \n};\n\nstatic int ar0521_power_off(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct ar0521_dev *sensor = to_ar0521_dev(sd);\n\tint i;\n\n\tclk_disable_unprepare(sensor->extclk);\n\n\tif (sensor->reset_gpio)\n\t\tgpiod_set_value(sensor->reset_gpio, 1);  \n\n\tfor (i = ARRAY_SIZE(ar0521_supply_names) - 1; i >= 0; i--) {\n\t\tif (sensor->supplies[i])\n\t\t\tregulator_disable(sensor->supplies[i]);\n\t}\n\treturn 0;\n}\n\nstatic int ar0521_power_on(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct ar0521_dev *sensor = to_ar0521_dev(sd);\n\tunsigned int cnt;\n\tint ret;\n\n\tfor (cnt = 0; cnt < ARRAY_SIZE(ar0521_supply_names); cnt++)\n\t\tif (sensor->supplies[cnt]) {\n\t\t\tret = regulator_enable(sensor->supplies[cnt]);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto off;\n\n\t\t\tusleep_range(1000, 1500);  \n\t\t}\n\n\tret = clk_prepare_enable(sensor->extclk);\n\tif (ret < 0) {\n\t\tv4l2_err(&sensor->sd, \"error enabling sensor clock\\n\");\n\t\tgoto off;\n\t}\n\tusleep_range(1000, 1500);  \n\n\tif (sensor->reset_gpio)\n\t\t \n\t\tgpiod_set_value(sensor->reset_gpio, 0);\n\tusleep_range(4500, 5000);  \n\n\tfor (cnt = 0; cnt < ARRAY_SIZE(initial_regs); cnt++) {\n\t\tret = ar0521_write_regs(sensor, initial_regs[cnt].data,\n\t\t\t\t\tinitial_regs[cnt].count);\n\t\tif (ret)\n\t\t\tgoto off;\n\t}\n\n\tret = ar0521_write_reg(sensor, AR0521_REG_SERIAL_FORMAT,\n\t\t\t       AR0521_REG_SERIAL_FORMAT_MIPI |\n\t\t\t       sensor->lane_count);\n\tif (ret)\n\t\tgoto off;\n\n\t \n\tret = ar0521_write_reg(sensor, AR0521_REG_HISPI_TEST_MODE,\n\t\t\t       ((0x40 << sensor->lane_count) - 0x40) |\n\t\t\t       AR0521_REG_HISPI_TEST_MODE_LP11);\n\tif (ret)\n\t\tgoto off;\n\n\tret = ar0521_write_reg(sensor, AR0521_REG_ROW_SPEED, 0x110 |\n\t\t\t       4 / sensor->lane_count);\n\tif (ret)\n\t\tgoto off;\n\n\treturn 0;\noff:\n\tar0521_power_off(dev);\n\treturn ret;\n}\n\nstatic int ar0521_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct ar0521_dev *sensor = to_ar0521_dev(sd);\n\n\tif (code->index)\n\t\treturn -EINVAL;\n\n\tcode->code = sensor->fmt.code;\n\treturn 0;\n}\n\nstatic int ar0521_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tif (fse->index)\n\t\treturn -EINVAL;\n\n\tif (fse->code != MEDIA_BUS_FMT_SGRBG8_1X8)\n\t\treturn -EINVAL;\n\n\tfse->min_width = AR0521_WIDTH_MIN;\n\tfse->max_width = AR0521_WIDTH_MAX;\n\tfse->min_height = AR0521_HEIGHT_MIN;\n\tfse->max_height = AR0521_HEIGHT_MAX;\n\n\treturn 0;\n}\n\nstatic int ar0521_pre_streamon(struct v4l2_subdev *sd, u32 flags)\n{\n\tstruct ar0521_dev *sensor = to_ar0521_dev(sd);\n\tint ret;\n\n\tif (!(flags & V4L2_SUBDEV_PRE_STREAMON_FL_MANUAL_LP))\n\t\treturn -EACCES;\n\n\tret = pm_runtime_resume_and_get(&sensor->i2c_client->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ar0521_write_reg(sensor, AR0521_REG_HISPI_CONTROL_STATUS,\n\t\t\tAR0521_REG_HISPI_CONTROL_STATUS_FRAMER_TEST_MODE_ENABLE);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = ar0521_write_reg(sensor, AR0521_REG_RESET,\n\t\t\t       AR0521_REG_RESET_DEFAULTS |\n\t\t\t       AR0521_REG_RESET_STREAM);\n\tif (ret)\n\t\tgoto err;\n\treturn 0;\n\nerr:\n\tpm_runtime_put(&sensor->i2c_client->dev);\n\treturn ret;\n}\n\nstatic int ar0521_post_streamoff(struct v4l2_subdev *sd)\n{\n\tstruct ar0521_dev *sensor = to_ar0521_dev(sd);\n\n\tpm_runtime_put(&sensor->i2c_client->dev);\n\treturn 0;\n}\n\nstatic int ar0521_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct ar0521_dev *sensor = to_ar0521_dev(sd);\n\tint ret;\n\n\tmutex_lock(&sensor->lock);\n\n\tret = ar0521_set_stream(sensor, enable);\n\tif (!ret)\n\t\tsensor->streaming = enable;\n\n\tmutex_unlock(&sensor->lock);\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_core_ops ar0521_core_ops = {\n\t.log_status = v4l2_ctrl_subdev_log_status,\n};\n\nstatic const struct v4l2_subdev_video_ops ar0521_video_ops = {\n\t.s_stream = ar0521_s_stream,\n\t.pre_streamon = ar0521_pre_streamon,\n\t.post_streamoff = ar0521_post_streamoff,\n};\n\nstatic const struct v4l2_subdev_pad_ops ar0521_pad_ops = {\n\t.enum_mbus_code = ar0521_enum_mbus_code,\n\t.enum_frame_size = ar0521_enum_frame_size,\n\t.get_fmt = ar0521_get_fmt,\n\t.set_fmt = ar0521_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops ar0521_subdev_ops = {\n\t.core = &ar0521_core_ops,\n\t.video = &ar0521_video_ops,\n\t.pad = &ar0521_pad_ops,\n};\n\nstatic int __maybe_unused ar0521_suspend(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct ar0521_dev *sensor = to_ar0521_dev(sd);\n\n\tif (sensor->streaming)\n\t\tar0521_set_stream(sensor, 0);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ar0521_resume(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct ar0521_dev *sensor = to_ar0521_dev(sd);\n\n\tif (sensor->streaming)\n\t\treturn ar0521_set_stream(sensor, 1);\n\n\treturn 0;\n}\n\nstatic int ar0521_probe(struct i2c_client *client)\n{\n\tstruct v4l2_fwnode_endpoint ep = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY\n\t};\n\tstruct device *dev = &client->dev;\n\tstruct fwnode_handle *endpoint;\n\tstruct ar0521_dev *sensor;\n\tunsigned int cnt;\n\tint ret;\n\n\tsensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);\n\tif (!sensor)\n\t\treturn -ENOMEM;\n\n\tsensor->i2c_client = client;\n\tsensor->fmt.width = AR0521_WIDTH_MAX;\n\tsensor->fmt.height = AR0521_HEIGHT_MAX;\n\n\tendpoint = fwnode_graph_get_endpoint_by_id(dev_fwnode(dev), 0, 0,\n\t\t\t\t\t\t   FWNODE_GRAPH_ENDPOINT_NEXT);\n\tif (!endpoint) {\n\t\tdev_err(dev, \"endpoint node not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = v4l2_fwnode_endpoint_parse(endpoint, &ep);\n\tfwnode_handle_put(endpoint);\n\tif (ret) {\n\t\tdev_err(dev, \"could not parse endpoint\\n\");\n\t\treturn ret;\n\t}\n\n\tif (ep.bus_type != V4L2_MBUS_CSI2_DPHY) {\n\t\tdev_err(dev, \"invalid bus type, must be MIPI CSI2\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsensor->lane_count = ep.bus.mipi_csi2.num_data_lanes;\n\tswitch (sensor->lane_count) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"invalid number of MIPI data lanes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsensor->extclk = devm_clk_get(dev, \"extclk\");\n\tif (IS_ERR(sensor->extclk)) {\n\t\tdev_err(dev, \"failed to get extclk\\n\");\n\t\treturn PTR_ERR(sensor->extclk);\n\t}\n\n\tsensor->extclk_freq = clk_get_rate(sensor->extclk);\n\n\tif (sensor->extclk_freq < AR0521_EXTCLK_MIN ||\n\t    sensor->extclk_freq > AR0521_EXTCLK_MAX) {\n\t\tdev_err(dev, \"extclk frequency out of range: %u Hz\\n\",\n\t\t\tsensor->extclk_freq);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsensor->reset_gpio = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t     GPIOD_OUT_HIGH);\n\n\tv4l2_i2c_subdev_init(&sensor->sd, client, &ar0521_subdev_ops);\n\n\tsensor->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsensor->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tsensor->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tret = media_entity_pads_init(&sensor->sd.entity, 1, &sensor->pad);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (cnt = 0; cnt < ARRAY_SIZE(ar0521_supply_names); cnt++) {\n\t\tstruct regulator *supply = devm_regulator_get(dev,\n\t\t\t\t\t\tar0521_supply_names[cnt]);\n\n\t\tif (IS_ERR(supply)) {\n\t\t\tdev_info(dev, \"no %s regulator found: %li\\n\",\n\t\t\t\t ar0521_supply_names[cnt], PTR_ERR(supply));\n\t\t\treturn PTR_ERR(supply);\n\t\t}\n\t\tsensor->supplies[cnt] = supply;\n\t}\n\n\tmutex_init(&sensor->lock);\n\n\tret = ar0521_init_controls(sensor);\n\tif (ret)\n\t\tgoto entity_cleanup;\n\n\tar0521_adj_fmt(&sensor->fmt);\n\n\tret = v4l2_async_register_subdev(&sensor->sd);\n\tif (ret)\n\t\tgoto free_ctrls;\n\n\t \n\tret = ar0521_power_on(&client->dev);\n\tif (ret)\n\t\tgoto disable;\n\tpm_runtime_set_active(&client->dev);\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_idle(&client->dev);\n\treturn 0;\n\ndisable:\n\tv4l2_async_unregister_subdev(&sensor->sd);\n\tmedia_entity_cleanup(&sensor->sd.entity);\nfree_ctrls:\n\tv4l2_ctrl_handler_free(&sensor->ctrls.handler);\nentity_cleanup:\n\tmedia_entity_cleanup(&sensor->sd.entity);\n\tmutex_destroy(&sensor->lock);\n\treturn ret;\n}\n\nstatic void ar0521_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ar0521_dev *sensor = to_ar0521_dev(sd);\n\n\tv4l2_async_unregister_subdev(&sensor->sd);\n\tmedia_entity_cleanup(&sensor->sd.entity);\n\tv4l2_ctrl_handler_free(&sensor->ctrls.handler);\n\tpm_runtime_disable(&client->dev);\n\tif (!pm_runtime_status_suspended(&client->dev))\n\t\tar0521_power_off(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\tmutex_destroy(&sensor->lock);\n}\n\nstatic const struct dev_pm_ops ar0521_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(ar0521_suspend, ar0521_resume)\n\tSET_RUNTIME_PM_OPS(ar0521_power_off, ar0521_power_on, NULL)\n};\nstatic const struct of_device_id ar0521_dt_ids[] = {\n\t{.compatible = \"onnn,ar0521\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ar0521_dt_ids);\n\nstatic struct i2c_driver ar0521_i2c_driver = {\n\t.driver = {\n\t\t.name  = \"ar0521\",\n\t\t.pm = &ar0521_pm_ops,\n\t\t.of_match_table = ar0521_dt_ids,\n\t},\n\t.probe = ar0521_probe,\n\t.remove = ar0521_remove,\n};\n\nmodule_i2c_driver(ar0521_i2c_driver);\n\nMODULE_DESCRIPTION(\"AR0521 MIPI Camera subdev driver\");\nMODULE_AUTHOR(\"Krzysztof Ha\u0142asa <khalasa@piap.pl>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}