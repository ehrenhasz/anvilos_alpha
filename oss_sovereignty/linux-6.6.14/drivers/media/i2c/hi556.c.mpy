{
  "module_name": "hi556.c",
  "hash_id": "6490bd153d6f4caa4f743fce8d22711a935c754f6a20791a43a3f42054e2665b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/hi556.c",
  "human_readable_source": "\n\n\n#include <asm/unaligned.h>\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n\n#define HI556_REG_VALUE_08BIT\t\t1\n#define HI556_REG_VALUE_16BIT\t\t2\n#define HI556_REG_VALUE_24BIT\t\t3\n\n#define HI556_LINK_FREQ_437MHZ\t\t437000000ULL\n#define HI556_MCLK\t\t\t19200000\n#define HI556_DATA_LANES\t\t2\n#define HI556_RGB_DEPTH\t\t\t10\n\n#define HI556_REG_CHIP_ID\t\t0x0f16\n#define HI556_CHIP_ID\t\t\t0x0556\n\n#define HI556_REG_MODE_SELECT\t\t0x0a00\n#define HI556_MODE_STANDBY\t\t0x0000\n#define HI556_MODE_STREAMING\t\t0x0100\n\n \n#define HI556_REG_FLL\t\t\t0x0006\n#define HI556_FLL_30FPS\t\t\t0x0814\n#define HI556_FLL_30FPS_MIN\t\t0x0814\n#define HI556_FLL_MAX\t\t\t0x7fff\n\n \n#define HI556_REG_LLP\t\t\t0x0008\n\n \n#define HI556_REG_EXPOSURE\t\t0x0074\n#define HI556_EXPOSURE_MIN\t\t6\n#define HI556_EXPOSURE_MAX_MARGIN\t2\n#define HI556_EXPOSURE_STEP\t\t1\n\n \n#define HI556_REG_ANALOG_GAIN\t\t0x0077\n#define HI556_ANAL_GAIN_MIN\t\t0\n#define HI556_ANAL_GAIN_MAX\t\t240\n#define HI556_ANAL_GAIN_STEP\t\t1\n\n \n#define HI556_REG_MWB_GR_GAIN\t\t0x0078\n#define HI556_REG_MWB_GB_GAIN\t\t0x007a\n#define HI556_REG_MWB_R_GAIN\t\t0x007c\n#define HI556_REG_MWB_B_GAIN\t\t0x007e\n#define HI556_DGTL_GAIN_MIN\t\t0\n#define HI556_DGTL_GAIN_MAX\t\t2048\n#define HI556_DGTL_GAIN_STEP\t\t1\n#define HI556_DGTL_GAIN_DEFAULT\t\t256\n\n \n#define HI556_REG_ISP\t\t\t0X0a05\n#define HI556_REG_ISP_TPG_EN\t\t0x01\n#define HI556_REG_TEST_PATTERN\t\t0x0201\n\n \n#define HI556_NATIVE_WIDTH\t\t2592U\n#define HI556_NATIVE_HEIGHT\t\t1944U\n#define HI556_PIXEL_ARRAY_LEFT\t\t0U\n#define HI556_PIXEL_ARRAY_TOP\t\t0U\n#define HI556_PIXEL_ARRAY_WIDTH\t2592U\n#define HI556_PIXEL_ARRAY_HEIGHT\t1944U\n\nenum {\n\tHI556_LINK_FREQ_437MHZ_INDEX,\n};\n\nstruct hi556_reg {\n\tu16 address;\n\tu16 val;\n};\n\nstruct hi556_reg_list {\n\tu32 num_of_regs;\n\tconst struct hi556_reg *regs;\n};\n\nstruct hi556_link_freq_config {\n\tconst struct hi556_reg_list reg_list;\n};\n\nstruct hi556_mode {\n\t \n\tu32 width;\n\n\t \n\tu32 height;\n\n\t \n\tstruct v4l2_rect crop;\n\n\t \n\tu32 llp;\n\n\t \n\tu32 fll_def;\n\n\t \n\tu32 fll_min;\n\n\t \n\tu32 link_freq_index;\n\n\t \n\tconst struct hi556_reg_list reg_list;\n};\n\n#define to_hi556(_sd) container_of(_sd, struct hi556, sd)\n\n\nstatic const struct hi556_reg mipi_data_rate_874mbps[] = {\n\t{0x0e00, 0x0102},\n\t{0x0e02, 0x0102},\n\t{0x0e0c, 0x0100},\n\t{0x2000, 0x7400},\n\t{0x2002, 0x001c},\n\t{0x2004, 0x0242},\n\t{0x2006, 0x0942},\n\t{0x2008, 0x7007},\n\t{0x200a, 0x0fd9},\n\t{0x200c, 0x0259},\n\t{0x200e, 0x7008},\n\t{0x2010, 0x160e},\n\t{0x2012, 0x0047},\n\t{0x2014, 0x2118},\n\t{0x2016, 0x0041},\n\t{0x2018, 0x00d8},\n\t{0x201a, 0x0145},\n\t{0x201c, 0x0006},\n\t{0x201e, 0x0181},\n\t{0x2020, 0x13cc},\n\t{0x2022, 0x2057},\n\t{0x2024, 0x7001},\n\t{0x2026, 0x0fca},\n\t{0x2028, 0x00cb},\n\t{0x202a, 0x009f},\n\t{0x202c, 0x7002},\n\t{0x202e, 0x13cc},\n\t{0x2030, 0x019b},\n\t{0x2032, 0x014d},\n\t{0x2034, 0x2987},\n\t{0x2036, 0x2766},\n\t{0x2038, 0x0020},\n\t{0x203a, 0x2060},\n\t{0x203c, 0x0e5d},\n\t{0x203e, 0x181d},\n\t{0x2040, 0x2066},\n\t{0x2042, 0x20c4},\n\t{0x2044, 0x5000},\n\t{0x2046, 0x0005},\n\t{0x2048, 0x0000},\n\t{0x204a, 0x01db},\n\t{0x204c, 0x025a},\n\t{0x204e, 0x00c0},\n\t{0x2050, 0x0005},\n\t{0x2052, 0x0006},\n\t{0x2054, 0x0ad9},\n\t{0x2056, 0x0259},\n\t{0x2058, 0x0618},\n\t{0x205a, 0x0258},\n\t{0x205c, 0x2266},\n\t{0x205e, 0x20c8},\n\t{0x2060, 0x2060},\n\t{0x2062, 0x707b},\n\t{0x2064, 0x0fdd},\n\t{0x2066, 0x81b8},\n\t{0x2068, 0x5040},\n\t{0x206a, 0x0020},\n\t{0x206c, 0x5060},\n\t{0x206e, 0x3143},\n\t{0x2070, 0x5081},\n\t{0x2072, 0x025c},\n\t{0x2074, 0x7800},\n\t{0x2076, 0x7400},\n\t{0x2078, 0x001c},\n\t{0x207a, 0x0242},\n\t{0x207c, 0x0942},\n\t{0x207e, 0x0bd9},\n\t{0x2080, 0x0259},\n\t{0x2082, 0x7008},\n\t{0x2084, 0x160e},\n\t{0x2086, 0x0047},\n\t{0x2088, 0x2118},\n\t{0x208a, 0x0041},\n\t{0x208c, 0x00d8},\n\t{0x208e, 0x0145},\n\t{0x2090, 0x0006},\n\t{0x2092, 0x0181},\n\t{0x2094, 0x13cc},\n\t{0x2096, 0x2057},\n\t{0x2098, 0x7001},\n\t{0x209a, 0x0fca},\n\t{0x209c, 0x00cb},\n\t{0x209e, 0x009f},\n\t{0x20a0, 0x7002},\n\t{0x20a2, 0x13cc},\n\t{0x20a4, 0x019b},\n\t{0x20a6, 0x014d},\n\t{0x20a8, 0x2987},\n\t{0x20aa, 0x2766},\n\t{0x20ac, 0x0020},\n\t{0x20ae, 0x2060},\n\t{0x20b0, 0x0e5d},\n\t{0x20b2, 0x181d},\n\t{0x20b4, 0x2066},\n\t{0x20b6, 0x20c4},\n\t{0x20b8, 0x50a0},\n\t{0x20ba, 0x0005},\n\t{0x20bc, 0x0000},\n\t{0x20be, 0x01db},\n\t{0x20c0, 0x025a},\n\t{0x20c2, 0x00c0},\n\t{0x20c4, 0x0005},\n\t{0x20c6, 0x0006},\n\t{0x20c8, 0x0ad9},\n\t{0x20ca, 0x0259},\n\t{0x20cc, 0x0618},\n\t{0x20ce, 0x0258},\n\t{0x20d0, 0x2266},\n\t{0x20d2, 0x20c8},\n\t{0x20d4, 0x2060},\n\t{0x20d6, 0x707b},\n\t{0x20d8, 0x0fdd},\n\t{0x20da, 0x86b8},\n\t{0x20dc, 0x50e0},\n\t{0x20de, 0x0020},\n\t{0x20e0, 0x5100},\n\t{0x20e2, 0x3143},\n\t{0x20e4, 0x5121},\n\t{0x20e6, 0x7800},\n\t{0x20e8, 0x3140},\n\t{0x20ea, 0x01c4},\n\t{0x20ec, 0x01c1},\n\t{0x20ee, 0x01c0},\n\t{0x20f0, 0x01c4},\n\t{0x20f2, 0x2700},\n\t{0x20f4, 0x3d40},\n\t{0x20f6, 0x7800},\n\t{0x20f8, 0xffff},\n\t{0x27fe, 0xe000},\n\t{0x3000, 0x60f8},\n\t{0x3002, 0x187f},\n\t{0x3004, 0x7060},\n\t{0x3006, 0x0114},\n\t{0x3008, 0x60b0},\n\t{0x300a, 0x1473},\n\t{0x300c, 0x0013},\n\t{0x300e, 0x140f},\n\t{0x3010, 0x0040},\n\t{0x3012, 0x100f},\n\t{0x3014, 0x60f8},\n\t{0x3016, 0x187f},\n\t{0x3018, 0x7060},\n\t{0x301a, 0x0114},\n\t{0x301c, 0x60b0},\n\t{0x301e, 0x1473},\n\t{0x3020, 0x0013},\n\t{0x3022, 0x140f},\n\t{0x3024, 0x0040},\n\t{0x3026, 0x000f},\n\n\t{0x0b00, 0x0000},\n\t{0x0b02, 0x0045},\n\t{0x0b04, 0xb405},\n\t{0x0b06, 0xc403},\n\t{0x0b08, 0x0081},\n\t{0x0b0a, 0x8252},\n\t{0x0b0c, 0xf814},\n\t{0x0b0e, 0xc618},\n\t{0x0b10, 0xa828},\n\t{0x0b12, 0x004c},\n\t{0x0b14, 0x4068},\n\t{0x0b16, 0x0000},\n\t{0x0f30, 0x5b15},\n\t{0x0f32, 0x7067},\n\t{0x0954, 0x0009},\n\t{0x0956, 0x0000},\n\t{0x0958, 0xbb80},\n\t{0x095a, 0x5140},\n\t{0x0c00, 0x1110},\n\t{0x0c02, 0x0011},\n\t{0x0c04, 0x0000},\n\t{0x0c06, 0x0200},\n\t{0x0c10, 0x0040},\n\t{0x0c12, 0x0040},\n\t{0x0c14, 0x0040},\n\t{0x0c16, 0x0040},\n\t{0x0a10, 0x4000},\n\t{0x3068, 0xf800},\n\t{0x306a, 0xf876},\n\t{0x006c, 0x0000},\n\t{0x005e, 0x0200},\n\t{0x000e, 0x0100},\n\t{0x0e0a, 0x0001},\n\t{0x004a, 0x0100},\n\t{0x004c, 0x0000},\n\t{0x004e, 0x0100},\n\t{0x000c, 0x0022},\n\t{0x0008, 0x0b00},\n\t{0x005a, 0x0202},\n\t{0x0012, 0x000e},\n\t{0x0018, 0x0a33},\n\t{0x0022, 0x0008},\n\t{0x0028, 0x0017},\n\t{0x0024, 0x0028},\n\t{0x002a, 0x002d},\n\t{0x0026, 0x0030},\n\t{0x002c, 0x07c9},\n\t{0x002e, 0x1111},\n\t{0x0030, 0x1111},\n\t{0x0032, 0x1111},\n\t{0x0006, 0x07bc},\n\t{0x0a22, 0x0000},\n\t{0x0a12, 0x0a20},\n\t{0x0a14, 0x0798},\n\t{0x003e, 0x0000},\n\t{0x0074, 0x080e},\n\t{0x0070, 0x0407},\n\t{0x0002, 0x0000},\n\t{0x0a02, 0x0100},\n\t{0x0a24, 0x0100},\n\t{0x0046, 0x0000},\n\t{0x0076, 0x0000},\n\t{0x0060, 0x0000},\n\t{0x0062, 0x0530},\n\t{0x0064, 0x0500},\n\t{0x0066, 0x0530},\n\t{0x0068, 0x0500},\n\t{0x0122, 0x0300},\n\t{0x015a, 0xff08},\n\t{0x0804, 0x0300},\n\t{0x0806, 0x0100},\n\t{0x005c, 0x0102},\n\t{0x0a1a, 0x0800},\n};\n\nstatic const struct hi556_reg mode_2592x1944_regs[] = {\n\t{0x0a00, 0x0000},\n\t{0x0b0a, 0x8252},\n\t{0x0f30, 0x5b15},\n\t{0x0f32, 0x7067},\n\t{0x004a, 0x0100},\n\t{0x004c, 0x0000},\n\t{0x004e, 0x0100},\n\t{0x000c, 0x0022},\n\t{0x0008, 0x0b00},\n\t{0x005a, 0x0202},\n\t{0x0012, 0x000e},\n\t{0x0018, 0x0a33},\n\t{0x0022, 0x0008},\n\t{0x0028, 0x0017},\n\t{0x0024, 0x0028},\n\t{0x002a, 0x002d},\n\t{0x0026, 0x0030},\n\t{0x002c, 0x07c9},\n\t{0x002e, 0x1111},\n\t{0x0030, 0x1111},\n\t{0x0032, 0x1111},\n\t{0x0006, 0x0814},\n\t{0x0a22, 0x0000},\n\t{0x0a12, 0x0a20},\n\t{0x0a14, 0x0798},\n\t{0x003e, 0x0000},\n\t{0x0074, 0x0812},\n\t{0x0070, 0x0409},\n\t{0x0804, 0x0300},\n\t{0x0806, 0x0100},\n\t{0x0a04, 0x014a},\n\t{0x090c, 0x0fdc},\n\t{0x090e, 0x002d},\n\n\t{0x0902, 0x4319},\n\t{0x0914, 0xc10a},\n\t{0x0916, 0x071f},\n\t{0x0918, 0x0408},\n\t{0x091a, 0x0c0d},\n\t{0x091c, 0x0f09},\n\t{0x091e, 0x0a00},\n\t{0x0958, 0xbb80},\n};\n\nstatic const struct hi556_reg mode_2592x1444_regs[] = {\n\t{0x0a00, 0x0000},\n\t{0x0b0a, 0x8252},\n\t{0x0f30, 0xe545},\n\t{0x0f32, 0x7067},\n\t{0x004a, 0x0100},\n\t{0x004c, 0x0000},\n\t{0x000c, 0x0022},\n\t{0x0008, 0x0b00},\n\t{0x005a, 0x0202},\n\t{0x0012, 0x000e},\n\t{0x0018, 0x0a33},\n\t{0x0022, 0x0008},\n\t{0x0028, 0x0017},\n\t{0x0024, 0x0122},\n\t{0x002a, 0x0127},\n\t{0x0026, 0x012a},\n\t{0x002c, 0x06cf},\n\t{0x002e, 0x1111},\n\t{0x0030, 0x1111},\n\t{0x0032, 0x1111},\n\t{0x0006, 0x0821},\n\t{0x0a22, 0x0000},\n\t{0x0a12, 0x0a20},\n\t{0x0a14, 0x05a4},\n\t{0x003e, 0x0000},\n\t{0x0074, 0x081f},\n\t{0x0070, 0x040f},\n\t{0x0804, 0x0300},\n\t{0x0806, 0x0100},\n\t{0x0a04, 0x014a},\n\t{0x090c, 0x0fdc},\n\t{0x090e, 0x002d},\n\t{0x0902, 0x4319},\n\t{0x0914, 0xc10a},\n\t{0x0916, 0x071f},\n\t{0x0918, 0x0408},\n\t{0x091a, 0x0c0d},\n\t{0x091c, 0x0f09},\n\t{0x091e, 0x0a00},\n\t{0x0958, 0xbb80},\n};\n\nstatic const struct hi556_reg mode_1296x972_regs[] = {\n\t{0x0a00, 0x0000},\n\t{0x0b0a, 0x8259},\n\t{0x0f30, 0x5b15},\n\t{0x0f32, 0x7167},\n\t{0x004a, 0x0100},\n\t{0x004c, 0x0000},\n\t{0x004e, 0x0100},\n\t{0x000c, 0x0122},\n\t{0x0008, 0x0b00},\n\t{0x005a, 0x0404},\n\t{0x0012, 0x000c},\n\t{0x0018, 0x0a33},\n\t{0x0022, 0x0008},\n\t{0x0028, 0x0017},\n\t{0x0024, 0x0022},\n\t{0x002a, 0x002b},\n\t{0x0026, 0x0030},\n\t{0x002c, 0x07c9},\n\t{0x002e, 0x3311},\n\t{0x0030, 0x3311},\n\t{0x0032, 0x3311},\n\t{0x0006, 0x0814},\n\t{0x0a22, 0x0000},\n\t{0x0a12, 0x0510},\n\t{0x0a14, 0x03cc},\n\t{0x003e, 0x0000},\n\t{0x0074, 0x0812},\n\t{0x0070, 0x0409},\n\t{0x0804, 0x0308},\n\t{0x0806, 0x0100},\n\t{0x0a04, 0x016a},\n\t{0x090e, 0x0010},\n\t{0x090c, 0x09c0},\n\n\t{0x0902, 0x4319},\n\t{0x0914, 0xc106},\n\t{0x0916, 0x040e},\n\t{0x0918, 0x0304},\n\t{0x091a, 0x0708},\n\t{0x091c, 0x0e06},\n\t{0x091e, 0x0300},\n\t{0x0958, 0xbb80},\n};\n\nstatic const char * const hi556_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Solid Colour\",\n\t\"100% Colour Bars\",\n\t\"Fade To Grey Colour Bars\",\n\t\"PN9\",\n\t\"Gradient Horizontal\",\n\t\"Gradient Vertical\",\n\t\"Check Board\",\n\t\"Slant Pattern\",\n};\n\nstatic const s64 link_freq_menu_items[] = {\n\tHI556_LINK_FREQ_437MHZ,\n};\n\nstatic const struct hi556_link_freq_config link_freq_configs[] = {\n\t[HI556_LINK_FREQ_437MHZ_INDEX] = {\n\t\t.reg_list = {\n\t\t\t.num_of_regs = ARRAY_SIZE(mipi_data_rate_874mbps),\n\t\t\t.regs = mipi_data_rate_874mbps,\n\t\t}\n\t}\n};\n\nstatic const struct hi556_mode supported_modes[] = {\n\t{\n\t\t.width = HI556_PIXEL_ARRAY_WIDTH,\n\t\t.height = HI556_PIXEL_ARRAY_HEIGHT,\n\t\t.crop = {\n\t\t\t.left = HI556_PIXEL_ARRAY_LEFT,\n\t\t\t.top = HI556_PIXEL_ARRAY_TOP,\n\t\t\t.width = HI556_PIXEL_ARRAY_WIDTH,\n\t\t\t.height = HI556_PIXEL_ARRAY_HEIGHT\n\t\t},\n\t\t.fll_def = HI556_FLL_30FPS,\n\t\t.fll_min = HI556_FLL_30FPS_MIN,\n\t\t.llp = 0x0b00,\n\t\t.reg_list = {\n\t\t\t.num_of_regs = ARRAY_SIZE(mode_2592x1944_regs),\n\t\t\t.regs = mode_2592x1944_regs,\n\t\t},\n\t\t.link_freq_index = HI556_LINK_FREQ_437MHZ_INDEX,\n\t},\n\t{\n\t\t.width = HI556_PIXEL_ARRAY_WIDTH,\n\t\t.height = 1444,\n\t\t.crop = {\n\t\t\t.left = HI556_PIXEL_ARRAY_LEFT,\n\t\t\t.top = 250,\n\t\t\t.width = HI556_PIXEL_ARRAY_WIDTH,\n\t\t\t.height = 1444\n\t\t},\n\t\t.fll_def = 0x821,\n\t\t.fll_min = 0x821,\n\t\t.llp = 0x0b00,\n\t\t.reg_list = {\n\t\t\t.num_of_regs = ARRAY_SIZE(mode_2592x1444_regs),\n\t\t\t.regs = mode_2592x1444_regs,\n\t\t},\n\t\t.link_freq_index = HI556_LINK_FREQ_437MHZ_INDEX,\n\t},\n\t{\n\t\t.width = 1296,\n\t\t.height = 972,\n\t\t.crop = {\n\t\t\t.left = HI556_PIXEL_ARRAY_LEFT,\n\t\t\t.top = HI556_PIXEL_ARRAY_TOP,\n\t\t\t.width = HI556_PIXEL_ARRAY_WIDTH,\n\t\t\t.height = HI556_PIXEL_ARRAY_HEIGHT\n\t\t},\n\t\t.fll_def = HI556_FLL_30FPS,\n\t\t.fll_min = HI556_FLL_30FPS_MIN,\n\t\t.llp = 0x0b00,\n\t\t.reg_list = {\n\t\t\t.num_of_regs = ARRAY_SIZE(mode_1296x972_regs),\n\t\t\t.regs = mode_1296x972_regs,\n\t\t},\n\t\t.link_freq_index = HI556_LINK_FREQ_437MHZ_INDEX,\n\t}\n};\n\nstruct hi556 {\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pad;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\n\t \n\tstruct v4l2_ctrl *link_freq;\n\tstruct v4l2_ctrl *pixel_rate;\n\tstruct v4l2_ctrl *vblank;\n\tstruct v4l2_ctrl *hblank;\n\tstruct v4l2_ctrl *exposure;\n\n\t \n\tconst struct hi556_mode *cur_mode;\n\n\t \n\tstruct mutex mutex;\n\n\t \n\tbool streaming;\n\n\t \n\tbool identified;\n};\n\nstatic u64 to_pixel_rate(u32 f_index)\n{\n\tu64 pixel_rate = link_freq_menu_items[f_index] * 2 * HI556_DATA_LANES;\n\n\tdo_div(pixel_rate, HI556_RGB_DEPTH);\n\n\treturn pixel_rate;\n}\n\nstatic int hi556_read_reg(struct hi556 *hi556, u16 reg, u16 len, u32 *val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&hi556->sd);\n\tstruct i2c_msg msgs[2];\n\tu8 addr_buf[2];\n\tu8 data_buf[4] = {0};\n\tint ret;\n\n\tif (len > 4)\n\t\treturn -EINVAL;\n\n\tput_unaligned_be16(reg, addr_buf);\n\tmsgs[0].addr = client->addr;\n\tmsgs[0].flags = 0;\n\tmsgs[0].len = sizeof(addr_buf);\n\tmsgs[0].buf = addr_buf;\n\tmsgs[1].addr = client->addr;\n\tmsgs[1].flags = I2C_M_RD;\n\tmsgs[1].len = len;\n\tmsgs[1].buf = &data_buf[4 - len];\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret != ARRAY_SIZE(msgs))\n\t\treturn -EIO;\n\n\t*val = get_unaligned_be32(data_buf);\n\n\treturn 0;\n}\n\nstatic int hi556_write_reg(struct hi556 *hi556, u16 reg, u16 len, u32 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&hi556->sd);\n\tu8 buf[6];\n\n\tif (len > 4)\n\t\treturn -EINVAL;\n\n\tput_unaligned_be16(reg, buf);\n\tput_unaligned_be32(val << 8 * (4 - len), buf + 2);\n\tif (i2c_master_send(client, buf, len + 2) != len + 2)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int hi556_write_reg_list(struct hi556 *hi556,\n\t\t\t\tconst struct hi556_reg_list *r_list)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&hi556->sd);\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < r_list->num_of_regs; i++) {\n\t\tret = hi556_write_reg(hi556, r_list->regs[i].address,\n\t\t\t\t      HI556_REG_VALUE_16BIT,\n\t\t\t\t      r_list->regs[i].val);\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(&client->dev,\n\t\t\t\t\t    \"failed to write reg 0x%4.4x. error = %d\",\n\t\t\t\t\t    r_list->regs[i].address, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int hi556_update_digital_gain(struct hi556 *hi556, u32 d_gain)\n{\n\tint ret;\n\n\tret = hi556_write_reg(hi556, HI556_REG_MWB_GR_GAIN,\n\t\t\t      HI556_REG_VALUE_16BIT, d_gain);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hi556_write_reg(hi556, HI556_REG_MWB_GB_GAIN,\n\t\t\t      HI556_REG_VALUE_16BIT, d_gain);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hi556_write_reg(hi556, HI556_REG_MWB_R_GAIN,\n\t\t\t      HI556_REG_VALUE_16BIT, d_gain);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hi556_write_reg(hi556, HI556_REG_MWB_B_GAIN,\n\t\t\t       HI556_REG_VALUE_16BIT, d_gain);\n}\n\nstatic int hi556_test_pattern(struct hi556 *hi556, u32 pattern)\n{\n\tint ret;\n\tu32 val;\n\n\tif (pattern) {\n\t\tret = hi556_read_reg(hi556, HI556_REG_ISP,\n\t\t\t\t     HI556_REG_VALUE_08BIT, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = hi556_write_reg(hi556, HI556_REG_ISP,\n\t\t\t\t      HI556_REG_VALUE_08BIT,\n\t\t\t\t      val | HI556_REG_ISP_TPG_EN);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn hi556_write_reg(hi556, HI556_REG_TEST_PATTERN,\n\t\t\t       HI556_REG_VALUE_08BIT, pattern);\n}\n\nstatic int hi556_set_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct hi556 *hi556 = container_of(ctrl->handler,\n\t\t\t\t\t     struct hi556, ctrl_handler);\n\tstruct i2c_client *client = v4l2_get_subdevdata(&hi556->sd);\n\ts64 exposure_max;\n\tint ret = 0;\n\n\t \n\tif (ctrl->id == V4L2_CID_VBLANK) {\n\t\t \n\t\texposure_max = hi556->cur_mode->height + ctrl->val -\n\t\t\t       HI556_EXPOSURE_MAX_MARGIN;\n\t\t__v4l2_ctrl_modify_range(hi556->exposure,\n\t\t\t\t\t hi556->exposure->minimum,\n\t\t\t\t\t exposure_max, hi556->exposure->step,\n\t\t\t\t\t exposure_max);\n\t}\n\n\t \n\tif (!pm_runtime_get_if_in_use(&client->dev))\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_ANALOGUE_GAIN:\n\t\tret = hi556_write_reg(hi556, HI556_REG_ANALOG_GAIN,\n\t\t\t\t      HI556_REG_VALUE_16BIT, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_DIGITAL_GAIN:\n\t\tret = hi556_update_digital_gain(hi556, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_EXPOSURE:\n\t\tret = hi556_write_reg(hi556, HI556_REG_EXPOSURE,\n\t\t\t\t      HI556_REG_VALUE_16BIT, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_VBLANK:\n\t\t \n\t\tret = hi556_write_reg(hi556, HI556_REG_FLL,\n\t\t\t\t      HI556_REG_VALUE_16BIT,\n\t\t\t\t      hi556->cur_mode->height + ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tret = hi556_test_pattern(hi556, ctrl->val);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tpm_runtime_put(&client->dev);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops hi556_ctrl_ops = {\n\t.s_ctrl = hi556_set_ctrl,\n};\n\nstatic int hi556_init_controls(struct hi556 *hi556)\n{\n\tstruct v4l2_ctrl_handler *ctrl_hdlr;\n\ts64 exposure_max, h_blank;\n\tint ret;\n\n\tctrl_hdlr = &hi556->ctrl_handler;\n\tret = v4l2_ctrl_handler_init(ctrl_hdlr, 8);\n\tif (ret)\n\t\treturn ret;\n\n\tctrl_hdlr->lock = &hi556->mutex;\n\thi556->link_freq = v4l2_ctrl_new_int_menu(ctrl_hdlr, &hi556_ctrl_ops,\n\t\t\t\t\t\t  V4L2_CID_LINK_FREQ,\n\t\t\t\t\tARRAY_SIZE(link_freq_menu_items) - 1,\n\t\t\t\t\t0, link_freq_menu_items);\n\tif (hi556->link_freq)\n\t\thi556->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\thi556->pixel_rate = v4l2_ctrl_new_std\n\t\t\t    (ctrl_hdlr, &hi556_ctrl_ops,\n\t\t\t     V4L2_CID_PIXEL_RATE, 0,\n\t\t\t     to_pixel_rate(HI556_LINK_FREQ_437MHZ_INDEX),\n\t\t\t     1,\n\t\t\t     to_pixel_rate(HI556_LINK_FREQ_437MHZ_INDEX));\n\thi556->vblank = v4l2_ctrl_new_std(ctrl_hdlr, &hi556_ctrl_ops,\n\t\t\t\t\t  V4L2_CID_VBLANK,\n\t\t\t\t\t  hi556->cur_mode->fll_min -\n\t\t\t\t\t  hi556->cur_mode->height,\n\t\t\t\t\t  HI556_FLL_MAX -\n\t\t\t\t\t  hi556->cur_mode->height, 1,\n\t\t\t\t\t  hi556->cur_mode->fll_def -\n\t\t\t\t\t  hi556->cur_mode->height);\n\n\th_blank = hi556->cur_mode->llp - hi556->cur_mode->width;\n\n\thi556->hblank = v4l2_ctrl_new_std(ctrl_hdlr, &hi556_ctrl_ops,\n\t\t\t\t\t  V4L2_CID_HBLANK, h_blank, h_blank, 1,\n\t\t\t\t\t  h_blank);\n\tif (hi556->hblank)\n\t\thi556->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tv4l2_ctrl_new_std(ctrl_hdlr, &hi556_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,\n\t\t\t  HI556_ANAL_GAIN_MIN, HI556_ANAL_GAIN_MAX,\n\t\t\t  HI556_ANAL_GAIN_STEP, HI556_ANAL_GAIN_MIN);\n\tv4l2_ctrl_new_std(ctrl_hdlr, &hi556_ctrl_ops, V4L2_CID_DIGITAL_GAIN,\n\t\t\t  HI556_DGTL_GAIN_MIN, HI556_DGTL_GAIN_MAX,\n\t\t\t  HI556_DGTL_GAIN_STEP, HI556_DGTL_GAIN_DEFAULT);\n\texposure_max = hi556->cur_mode->fll_def - HI556_EXPOSURE_MAX_MARGIN;\n\thi556->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &hi556_ctrl_ops,\n\t\t\t\t\t    V4L2_CID_EXPOSURE,\n\t\t\t\t\t    HI556_EXPOSURE_MIN, exposure_max,\n\t\t\t\t\t    HI556_EXPOSURE_STEP,\n\t\t\t\t\t    exposure_max);\n\tv4l2_ctrl_new_std_menu_items(ctrl_hdlr, &hi556_ctrl_ops,\n\t\t\t\t     V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(hi556_test_pattern_menu) - 1,\n\t\t\t\t     0, 0, hi556_test_pattern_menu);\n\tif (ctrl_hdlr->error)\n\t\treturn ctrl_hdlr->error;\n\n\thi556->sd.ctrl_handler = ctrl_hdlr;\n\n\treturn 0;\n}\n\nstatic void hi556_assign_pad_format(const struct hi556_mode *mode,\n\t\t\t\t    struct v4l2_mbus_framefmt *fmt)\n{\n\tfmt->width = mode->width;\n\tfmt->height = mode->height;\n\tfmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\tfmt->field = V4L2_FIELD_NONE;\n}\n\nstatic int hi556_identify_module(struct hi556 *hi556)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&hi556->sd);\n\tint ret;\n\tu32 val;\n\n\tif (hi556->identified)\n\t\treturn 0;\n\n\tret = hi556_read_reg(hi556, HI556_REG_CHIP_ID,\n\t\t\t     HI556_REG_VALUE_16BIT, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != HI556_CHIP_ID) {\n\t\tdev_err(&client->dev, \"chip id mismatch: %x!=%x\",\n\t\t\tHI556_CHIP_ID, val);\n\t\treturn -ENXIO;\n\t}\n\n\thi556->identified = true;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_rect *\n__hi556_get_pad_crop(struct hi556 *hi556,\n\t\t     struct v4l2_subdev_state *sd_state,\n\t\t     unsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\treturn v4l2_subdev_get_try_crop(&hi556->sd, sd_state, pad);\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &hi556->cur_mode->crop;\n\t}\n\n\treturn NULL;\n}\n\nstatic int hi556_get_selection(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_selection *sel)\n{\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP: {\n\t\tstruct hi556 *hi556 = to_hi556(sd);\n\n\t\tmutex_lock(&hi556->mutex);\n\t\tsel->r = *__hi556_get_pad_crop(hi556, sd_state, sel->pad,\n\t\t\t\t\t\tsel->which);\n\t\tmutex_unlock(&hi556->mutex);\n\n\t\treturn 0;\n\t}\n\n\tcase V4L2_SEL_TGT_NATIVE_SIZE:\n\t\tsel->r.top = 0;\n\t\tsel->r.left = 0;\n\t\tsel->r.width = HI556_NATIVE_WIDTH;\n\t\tsel->r.height = HI556_NATIVE_HEIGHT;\n\n\t\treturn 0;\n\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.top = HI556_PIXEL_ARRAY_TOP;\n\t\tsel->r.left = HI556_PIXEL_ARRAY_LEFT;\n\t\tsel->r.width = HI556_PIXEL_ARRAY_WIDTH;\n\t\tsel->r.height = HI556_PIXEL_ARRAY_HEIGHT;\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int hi556_start_streaming(struct hi556 *hi556)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&hi556->sd);\n\tconst struct hi556_reg_list *reg_list;\n\tint link_freq_index, ret;\n\n\tret = hi556_identify_module(hi556);\n\tif (ret)\n\t\treturn ret;\n\n\tlink_freq_index = hi556->cur_mode->link_freq_index;\n\treg_list = &link_freq_configs[link_freq_index].reg_list;\n\tret = hi556_write_reg_list(hi556, reg_list);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to set plls\");\n\t\treturn ret;\n\t}\n\n\treg_list = &hi556->cur_mode->reg_list;\n\tret = hi556_write_reg_list(hi556, reg_list);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to set mode\");\n\t\treturn ret;\n\t}\n\n\tret = __v4l2_ctrl_handler_setup(hi556->sd.ctrl_handler);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hi556_write_reg(hi556, HI556_REG_MODE_SELECT,\n\t\t\t      HI556_REG_VALUE_16BIT, HI556_MODE_STREAMING);\n\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to set stream\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void hi556_stop_streaming(struct hi556 *hi556)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&hi556->sd);\n\n\tif (hi556_write_reg(hi556, HI556_REG_MODE_SELECT,\n\t\t\t    HI556_REG_VALUE_16BIT, HI556_MODE_STANDBY))\n\t\tdev_err(&client->dev, \"failed to set stream\");\n}\n\nstatic int hi556_set_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct hi556 *hi556 = to_hi556(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret = 0;\n\n\tif (hi556->streaming == enable)\n\t\treturn 0;\n\n\tmutex_lock(&hi556->mutex);\n\tif (enable) {\n\t\tret = pm_runtime_resume_and_get(&client->dev);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&hi556->mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = hi556_start_streaming(hi556);\n\t\tif (ret) {\n\t\t\tenable = 0;\n\t\t\thi556_stop_streaming(hi556);\n\t\t\tpm_runtime_put(&client->dev);\n\t\t}\n\t} else {\n\t\thi556_stop_streaming(hi556);\n\t\tpm_runtime_put(&client->dev);\n\t}\n\n\thi556->streaming = enable;\n\tmutex_unlock(&hi556->mutex);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused hi556_suspend(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct hi556 *hi556 = to_hi556(sd);\n\n\tmutex_lock(&hi556->mutex);\n\tif (hi556->streaming)\n\t\thi556_stop_streaming(hi556);\n\n\tmutex_unlock(&hi556->mutex);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused hi556_resume(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct hi556 *hi556 = to_hi556(sd);\n\tint ret;\n\n\tmutex_lock(&hi556->mutex);\n\tif (hi556->streaming) {\n\t\tret = hi556_start_streaming(hi556);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tmutex_unlock(&hi556->mutex);\n\n\treturn 0;\n\nerror:\n\thi556_stop_streaming(hi556);\n\thi556->streaming = 0;\n\tmutex_unlock(&hi556->mutex);\n\treturn ret;\n}\n\nstatic int hi556_set_format(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    struct v4l2_subdev_format *fmt)\n{\n\tstruct hi556 *hi556 = to_hi556(sd);\n\tconst struct hi556_mode *mode;\n\ts32 vblank_def, h_blank;\n\n\tmode = v4l2_find_nearest_size(supported_modes,\n\t\t\t\t      ARRAY_SIZE(supported_modes), width,\n\t\t\t\t      height, fmt->format.width,\n\t\t\t\t      fmt->format.height);\n\n\tmutex_lock(&hi556->mutex);\n\thi556_assign_pad_format(mode, &fmt->format);\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\t*v4l2_subdev_get_try_format(sd, sd_state, fmt->pad) = fmt->format;\n\t} else {\n\t\thi556->cur_mode = mode;\n\t\t__v4l2_ctrl_s_ctrl(hi556->link_freq, mode->link_freq_index);\n\t\t__v4l2_ctrl_s_ctrl_int64(hi556->pixel_rate,\n\t\t\t\t\t to_pixel_rate(mode->link_freq_index));\n\n\t\t \n\t\tvblank_def = mode->fll_def - mode->height;\n\t\t__v4l2_ctrl_modify_range(hi556->vblank,\n\t\t\t\t\t mode->fll_min - mode->height,\n\t\t\t\t\t HI556_FLL_MAX - mode->height, 1,\n\t\t\t\t\t vblank_def);\n\t\t__v4l2_ctrl_s_ctrl(hi556->vblank, vblank_def);\n\n\t\th_blank = hi556->cur_mode->llp - hi556->cur_mode->width;\n\n\t\t__v4l2_ctrl_modify_range(hi556->hblank, h_blank, h_blank, 1,\n\t\t\t\t\t h_blank);\n\t}\n\n\tmutex_unlock(&hi556->mutex);\n\n\treturn 0;\n}\n\nstatic int hi556_get_format(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    struct v4l2_subdev_format *fmt)\n{\n\tstruct hi556 *hi556 = to_hi556(sd);\n\n\tmutex_lock(&hi556->mutex);\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\tfmt->format = *v4l2_subdev_get_try_format(&hi556->sd,\n\t\t\t\t\t\t\t  sd_state,\n\t\t\t\t\t\t\t  fmt->pad);\n\telse\n\t\thi556_assign_pad_format(hi556->cur_mode, &fmt->format);\n\n\tmutex_unlock(&hi556->mutex);\n\n\treturn 0;\n}\n\nstatic int hi556_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index > 0)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\n\treturn 0;\n}\n\nstatic int hi556_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_frame_size_enum *fse)\n{\n\tif (fse->index >= ARRAY_SIZE(supported_modes))\n\t\treturn -EINVAL;\n\n\tif (fse->code != MEDIA_BUS_FMT_SGRBG10_1X10)\n\t\treturn -EINVAL;\n\n\tfse->min_width = supported_modes[fse->index].width;\n\tfse->max_width = fse->min_width;\n\tfse->min_height = supported_modes[fse->index].height;\n\tfse->max_height = fse->min_height;\n\n\treturn 0;\n}\n\nstatic int hi556_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct hi556 *hi556 = to_hi556(sd);\n\tstruct v4l2_rect *try_crop;\n\n\tmutex_lock(&hi556->mutex);\n\thi556_assign_pad_format(&supported_modes[0],\n\t\t\t\tv4l2_subdev_get_try_format(sd, fh->state, 0));\n\n\t \n\ttry_crop = v4l2_subdev_get_try_crop(sd, fh->state, 0);\n\ttry_crop->top = HI556_PIXEL_ARRAY_TOP;\n\ttry_crop->left = HI556_PIXEL_ARRAY_LEFT;\n\ttry_crop->width = HI556_PIXEL_ARRAY_WIDTH;\n\ttry_crop->height = HI556_PIXEL_ARRAY_HEIGHT;\n\n\tmutex_unlock(&hi556->mutex);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops hi556_video_ops = {\n\t.s_stream = hi556_set_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops hi556_pad_ops = {\n\t.set_fmt = hi556_set_format,\n\t.get_fmt = hi556_get_format,\n\t.get_selection = hi556_get_selection,\n\t.enum_mbus_code = hi556_enum_mbus_code,\n\t.enum_frame_size = hi556_enum_frame_size,\n};\n\nstatic const struct v4l2_subdev_ops hi556_subdev_ops = {\n\t.video = &hi556_video_ops,\n\t.pad = &hi556_pad_ops,\n};\n\nstatic const struct media_entity_operations hi556_subdev_entity_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic const struct v4l2_subdev_internal_ops hi556_internal_ops = {\n\t.open = hi556_open,\n};\n\nstatic int hi556_check_hwcfg(struct device *dev)\n{\n\tstruct fwnode_handle *ep;\n\tstruct fwnode_handle *fwnode = dev_fwnode(dev);\n\tstruct v4l2_fwnode_endpoint bus_cfg = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY\n\t};\n\tu32 mclk;\n\tint ret = 0;\n\tunsigned int i, j;\n\n\tif (!fwnode)\n\t\treturn -ENXIO;\n\n\tret = fwnode_property_read_u32(fwnode, \"clock-frequency\", &mclk);\n\tif (ret) {\n\t\tdev_err(dev, \"can't get clock frequency\");\n\t\treturn ret;\n\t}\n\n\tif (mclk != HI556_MCLK) {\n\t\tdev_err(dev, \"external clock %d is not supported\", mclk);\n\t\treturn -EINVAL;\n\t}\n\n\tep = fwnode_graph_get_next_endpoint(fwnode, NULL);\n\tif (!ep)\n\t\treturn -ENXIO;\n\n\tret = v4l2_fwnode_endpoint_alloc_parse(ep, &bus_cfg);\n\tfwnode_handle_put(ep);\n\tif (ret)\n\t\treturn ret;\n\n\tif (bus_cfg.bus.mipi_csi2.num_data_lanes != 2) {\n\t\tdev_err(dev, \"number of CSI2 data lanes %d is not supported\",\n\t\t\tbus_cfg.bus.mipi_csi2.num_data_lanes);\n\t\tret = -EINVAL;\n\t\tgoto check_hwcfg_error;\n\t}\n\n\tif (!bus_cfg.nr_of_link_frequencies) {\n\t\tdev_err(dev, \"no link frequencies defined\");\n\t\tret = -EINVAL;\n\t\tgoto check_hwcfg_error;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(link_freq_menu_items); i++) {\n\t\tfor (j = 0; j < bus_cfg.nr_of_link_frequencies; j++) {\n\t\t\tif (link_freq_menu_items[i] ==\n\t\t\t\tbus_cfg.link_frequencies[j])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j == bus_cfg.nr_of_link_frequencies) {\n\t\t\tdev_err(dev, \"no link frequency %lld supported\",\n\t\t\t\tlink_freq_menu_items[i]);\n\t\t\tret = -EINVAL;\n\t\t\tgoto check_hwcfg_error;\n\t\t}\n\t}\n\ncheck_hwcfg_error:\n\tv4l2_fwnode_endpoint_free(&bus_cfg);\n\n\treturn ret;\n}\n\nstatic void hi556_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct hi556 *hi556 = to_hi556(sd);\n\n\tv4l2_async_unregister_subdev(sd);\n\tmedia_entity_cleanup(&sd->entity);\n\tv4l2_ctrl_handler_free(sd->ctrl_handler);\n\tpm_runtime_disable(&client->dev);\n\tmutex_destroy(&hi556->mutex);\n}\n\nstatic int hi556_probe(struct i2c_client *client)\n{\n\tstruct hi556 *hi556;\n\tbool full_power;\n\tint ret;\n\n\tret = hi556_check_hwcfg(&client->dev);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to check HW configuration: %d\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\thi556 = devm_kzalloc(&client->dev, sizeof(*hi556), GFP_KERNEL);\n\tif (!hi556)\n\t\treturn -ENOMEM;\n\n\tv4l2_i2c_subdev_init(&hi556->sd, client, &hi556_subdev_ops);\n\n\tfull_power = acpi_dev_state_d0(&client->dev);\n\tif (full_power) {\n\t\tret = hi556_identify_module(hi556);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"failed to find sensor: %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmutex_init(&hi556->mutex);\n\thi556->cur_mode = &supported_modes[0];\n\tret = hi556_init_controls(hi556);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to init controls: %d\", ret);\n\t\tgoto probe_error_v4l2_ctrl_handler_free;\n\t}\n\n\thi556->sd.internal_ops = &hi556_internal_ops;\n\thi556->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\thi556->sd.entity.ops = &hi556_subdev_entity_ops;\n\thi556->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\thi556->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tret = media_entity_pads_init(&hi556->sd.entity, 1, &hi556->pad);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to init entity pads: %d\", ret);\n\t\tgoto probe_error_v4l2_ctrl_handler_free;\n\t}\n\n\tret = v4l2_async_register_subdev_sensor(&hi556->sd);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to register V4L2 subdev: %d\",\n\t\t\tret);\n\t\tgoto probe_error_media_entity_cleanup;\n\t}\n\n\t \n\tif (full_power)\n\t\tpm_runtime_set_active(&client->dev);\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_idle(&client->dev);\n\n\treturn 0;\n\nprobe_error_media_entity_cleanup:\n\tmedia_entity_cleanup(&hi556->sd.entity);\n\nprobe_error_v4l2_ctrl_handler_free:\n\tv4l2_ctrl_handler_free(hi556->sd.ctrl_handler);\n\tmutex_destroy(&hi556->mutex);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops hi556_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(hi556_suspend, hi556_resume)\n};\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id hi556_acpi_ids[] = {\n\t{\"INT3537\"},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(acpi, hi556_acpi_ids);\n#endif\n\nstatic struct i2c_driver hi556_i2c_driver = {\n\t.driver = {\n\t\t.name = \"hi556\",\n\t\t.pm = &hi556_pm_ops,\n\t\t.acpi_match_table = ACPI_PTR(hi556_acpi_ids),\n\t},\n\t.probe = hi556_probe,\n\t.remove = hi556_remove,\n\t.flags = I2C_DRV_ACPI_WAIVE_D0_PROBE,\n};\n\nmodule_i2c_driver(hi556_i2c_driver);\n\nMODULE_AUTHOR(\"Shawn Tu\");\nMODULE_DESCRIPTION(\"Hynix HI556 sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}