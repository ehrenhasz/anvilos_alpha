{
  "module_name": "ov9640.c",
  "hash_id": "8561f5a2a99d7345bc037fce77ac9b69ee29ed39bd47951e60a9e63e49811c7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ov9640.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/v4l2-mediabus.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-async.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n\n#include <linux/gpio/consumer.h>\n\n#include \"ov9640.h\"\n\n#define to_ov9640_sensor(sd)\tcontainer_of(sd, struct ov9640_priv, subdev)\n\n \nstatic const struct ov9640_reg ov9640_regs_dflt[] = {\n\t{ OV9640_COM5,\tOV9640_COM5_SYSCLK | OV9640_COM5_LONGEXP },\n\t{ OV9640_COM6,\tOV9640_COM6_OPT_BLC | OV9640_COM6_ADBLC_BIAS |\n\t\t\tOV9640_COM6_FMT_RST | OV9640_COM6_ADBLC_OPTEN },\n\t{ OV9640_PSHFT,\tOV9640_PSHFT_VAL(0x01) },\n\t{ OV9640_ACOM,\tOV9640_ACOM_2X_ANALOG | OV9640_ACOM_RSVD },\n\t{ OV9640_TSLB,\tOV9640_TSLB_YUYV_UYVY },\n\t{ OV9640_COM16,\tOV9640_COM16_RB_AVG },\n\n\t \n\t{ 0x6c, 0x40 },\t{ 0x6d, 0x30 },\t{ 0x6e, 0x4b },\t{ 0x6f, 0x60 },\n\t{ 0x70, 0x70 },\t{ 0x71, 0x70 },\t{ 0x72, 0x70 },\t{ 0x73, 0x70 },\n\t{ 0x74, 0x60 },\t{ 0x75, 0x60 },\t{ 0x76, 0x50 },\t{ 0x77, 0x48 },\n\t{ 0x78, 0x3a },\t{ 0x79, 0x2e },\t{ 0x7a, 0x28 },\t{ 0x7b, 0x22 },\n\n\t \n\t{ 0x7c, 0x04 },\t{ 0x7d, 0x07 },\t{ 0x7e, 0x10 },\t{ 0x7f, 0x28 },\n\t{ 0x80, 0x36 },\t{ 0x81, 0x44 },\t{ 0x82, 0x52 },\t{ 0x83, 0x60 },\n\t{ 0x84, 0x6c },\t{ 0x85, 0x78 },\t{ 0x86, 0x8c },\t{ 0x87, 0x9e },\n\t{ 0x88, 0xbb },\t{ 0x89, 0xd2 },\t{ 0x8a, 0xe6 },\n};\n\n \nstatic const struct ov9640_reg ov9640_regs_qqcif[] = {\n\t{ OV9640_CLKRC,\tOV9640_CLKRC_DPLL_EN | OV9640_CLKRC_DIV(0x0f) },\n\t{ OV9640_COM1,\tOV9640_COM1_QQFMT | OV9640_COM1_HREF_2SKIP },\n\t{ OV9640_COM4,\tOV9640_COM4_QQ_VP | OV9640_COM4_RSVD },\n\t{ OV9640_COM7,\tOV9640_COM7_QCIF },\n\t{ OV9640_COM12,\tOV9640_COM12_RSVD },\n\t{ OV9640_COM13,\tOV9640_COM13_GAMMA_RAW | OV9640_COM13_MATRIX_EN },\n\t{ OV9640_COM15,\tOV9640_COM15_OR_10F0 },\n};\n\nstatic const struct ov9640_reg ov9640_regs_qqvga[] = {\n\t{ OV9640_CLKRC,\tOV9640_CLKRC_DPLL_EN | OV9640_CLKRC_DIV(0x07) },\n\t{ OV9640_COM1,\tOV9640_COM1_QQFMT | OV9640_COM1_HREF_2SKIP },\n\t{ OV9640_COM4,\tOV9640_COM4_QQ_VP | OV9640_COM4_RSVD },\n\t{ OV9640_COM7,\tOV9640_COM7_QVGA },\n\t{ OV9640_COM12,\tOV9640_COM12_RSVD },\n\t{ OV9640_COM13,\tOV9640_COM13_GAMMA_RAW | OV9640_COM13_MATRIX_EN },\n\t{ OV9640_COM15,\tOV9640_COM15_OR_10F0 },\n};\n\nstatic const struct ov9640_reg ov9640_regs_qcif[] = {\n\t{ OV9640_CLKRC,\tOV9640_CLKRC_DPLL_EN | OV9640_CLKRC_DIV(0x07) },\n\t{ OV9640_COM4,\tOV9640_COM4_QQ_VP | OV9640_COM4_RSVD },\n\t{ OV9640_COM7,\tOV9640_COM7_QCIF },\n\t{ OV9640_COM12,\tOV9640_COM12_RSVD },\n\t{ OV9640_COM13,\tOV9640_COM13_GAMMA_RAW | OV9640_COM13_MATRIX_EN },\n\t{ OV9640_COM15,\tOV9640_COM15_OR_10F0 },\n};\n\nstatic const struct ov9640_reg ov9640_regs_qvga[] = {\n\t{ OV9640_CLKRC,\tOV9640_CLKRC_DPLL_EN | OV9640_CLKRC_DIV(0x03) },\n\t{ OV9640_COM4,\tOV9640_COM4_QQ_VP | OV9640_COM4_RSVD },\n\t{ OV9640_COM7,\tOV9640_COM7_QVGA },\n\t{ OV9640_COM12,\tOV9640_COM12_RSVD },\n\t{ OV9640_COM13,\tOV9640_COM13_GAMMA_RAW | OV9640_COM13_MATRIX_EN },\n\t{ OV9640_COM15,\tOV9640_COM15_OR_10F0 },\n};\n\nstatic const struct ov9640_reg ov9640_regs_cif[] = {\n\t{ OV9640_CLKRC,\tOV9640_CLKRC_DPLL_EN | OV9640_CLKRC_DIV(0x03) },\n\t{ OV9640_COM3,\tOV9640_COM3_VP },\n\t{ OV9640_COM7,\tOV9640_COM7_CIF },\n\t{ OV9640_COM12,\tOV9640_COM12_RSVD },\n\t{ OV9640_COM13,\tOV9640_COM13_GAMMA_RAW | OV9640_COM13_MATRIX_EN },\n\t{ OV9640_COM15,\tOV9640_COM15_OR_10F0 },\n};\n\nstatic const struct ov9640_reg ov9640_regs_vga[] = {\n\t{ OV9640_CLKRC,\tOV9640_CLKRC_DPLL_EN | OV9640_CLKRC_DIV(0x01) },\n\t{ OV9640_COM3,\tOV9640_COM3_VP },\n\t{ OV9640_COM7,\tOV9640_COM7_VGA },\n\t{ OV9640_COM12,\tOV9640_COM12_RSVD },\n\t{ OV9640_COM13,\tOV9640_COM13_GAMMA_RAW | OV9640_COM13_MATRIX_EN },\n\t{ OV9640_COM15,\tOV9640_COM15_OR_10F0 },\n};\n\nstatic const struct ov9640_reg ov9640_regs_sxga[] = {\n\t{ OV9640_CLKRC,\tOV9640_CLKRC_DPLL_EN | OV9640_CLKRC_DIV(0x01) },\n\t{ OV9640_COM3,\tOV9640_COM3_VP },\n\t{ OV9640_COM7,\t0 },\n\t{ OV9640_COM12,\tOV9640_COM12_RSVD },\n\t{ OV9640_COM13,\tOV9640_COM13_GAMMA_RAW | OV9640_COM13_MATRIX_EN },\n\t{ OV9640_COM15,\tOV9640_COM15_OR_10F0 },\n};\n\nstatic const struct ov9640_reg ov9640_regs_yuv[] = {\n\t{ OV9640_MTX1,\t0x58 },\n\t{ OV9640_MTX2,\t0x48 },\n\t{ OV9640_MTX3,\t0x10 },\n\t{ OV9640_MTX4,\t0x28 },\n\t{ OV9640_MTX5,\t0x48 },\n\t{ OV9640_MTX6,\t0x70 },\n\t{ OV9640_MTX7,\t0x40 },\n\t{ OV9640_MTX8,\t0x40 },\n\t{ OV9640_MTX9,\t0x40 },\n\t{ OV9640_MTXS,\t0x0f },\n};\n\nstatic const struct ov9640_reg ov9640_regs_rgb[] = {\n\t{ OV9640_MTX1,\t0x71 },\n\t{ OV9640_MTX2,\t0x3e },\n\t{ OV9640_MTX3,\t0x0c },\n\t{ OV9640_MTX4,\t0x33 },\n\t{ OV9640_MTX5,\t0x72 },\n\t{ OV9640_MTX6,\t0x00 },\n\t{ OV9640_MTX7,\t0x2b },\n\t{ OV9640_MTX8,\t0x66 },\n\t{ OV9640_MTX9,\t0xd2 },\n\t{ OV9640_MTXS,\t0x65 },\n};\n\nstatic const u32 ov9640_codes[] = {\n\tMEDIA_BUS_FMT_UYVY8_2X8,\n\tMEDIA_BUS_FMT_RGB555_2X8_PADHI_LE,\n\tMEDIA_BUS_FMT_RGB565_2X8_LE,\n};\n\n \nstatic int ov9640_reg_read(struct i2c_client *client, u8 reg, u8 *val)\n{\n\tint ret;\n\tu8 data = reg;\n\tstruct i2c_msg msg = {\n\t\t.addr\t= client->addr,\n\t\t.flags\t= 0,\n\t\t.len\t= 1,\n\t\t.buf\t= &data,\n\t};\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tmsg.flags = I2C_M_RD;\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t*val = data;\n\treturn 0;\n\nerr:\n\tdev_err(&client->dev, \"Failed reading register 0x%02x!\\n\", reg);\n\treturn ret;\n}\n\n \nstatic int ov9640_reg_write(struct i2c_client *client, u8 reg, u8 val)\n{\n\tint ret;\n\tu8 _val;\n\tunsigned char data[2] = { reg, val };\n\tstruct i2c_msg msg = {\n\t\t.addr\t= client->addr,\n\t\t.flags\t= 0,\n\t\t.len\t= 2,\n\t\t.buf\t= data,\n\t};\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed writing register 0x%02x!\\n\", reg);\n\t\treturn ret;\n\t}\n\n\t \n\tret = ov9640_reg_read(client, reg, &_val);\n\tif (ret)\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed reading back register 0x%02x!\\n\", reg);\n\n\treturn 0;\n}\n\n\n \nstatic int ov9640_reg_rmw(struct i2c_client *client, u8 reg, u8 set, u8 unset)\n{\n\tu8 val;\n\tint ret;\n\n\tret = ov9640_reg_read(client, reg, &val);\n\tif (ret) {\n\t\tdev_err(&client->dev,\n\t\t\t\"[Read]-Modify-Write of register %02x failed!\\n\", reg);\n\t\treturn ret;\n\t}\n\n\tval |= set;\n\tval &= ~unset;\n\n\tret = ov9640_reg_write(client, reg, val);\n\tif (ret)\n\t\tdev_err(&client->dev,\n\t\t\t\"Read-Modify-[Write] of register %02x failed!\\n\", reg);\n\n\treturn ret;\n}\n\n \nstatic int ov9640_reset(struct i2c_client *client)\n{\n\tint ret;\n\n\tret = ov9640_reg_write(client, OV9640_COM7, OV9640_COM7_SCCB_RESET);\n\tif (ret)\n\t\tdev_err(&client->dev,\n\t\t\t\"An error occurred while entering soft reset!\\n\");\n\n\treturn ret;\n}\n\n \nstatic int ov9640_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\treturn 0;\n}\n\n \nstatic int ov9640_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ov9640_priv *priv = container_of(ctrl->handler,\n\t\t\t\t\t\tstruct ov9640_priv, hdl);\n\tstruct i2c_client *client = v4l2_get_subdevdata(&priv->subdev);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_VFLIP:\n\t\tif (ctrl->val)\n\t\t\treturn ov9640_reg_rmw(client, OV9640_MVFP,\n\t\t\t\t\t      OV9640_MVFP_V, 0);\n\t\treturn ov9640_reg_rmw(client, OV9640_MVFP, 0, OV9640_MVFP_V);\n\tcase V4L2_CID_HFLIP:\n\t\tif (ctrl->val)\n\t\t\treturn ov9640_reg_rmw(client, OV9640_MVFP,\n\t\t\t\t\t      OV9640_MVFP_H, 0);\n\t\treturn ov9640_reg_rmw(client, OV9640_MVFP, 0, OV9640_MVFP_H);\n\t}\n\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int ov9640_get_register(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_dbg_register *reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\tu8 val;\n\n\tif (reg->reg & ~0xff)\n\t\treturn -EINVAL;\n\n\treg->size = 1;\n\n\tret = ov9640_reg_read(client, reg->reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treg->val = (__u64)val;\n\n\treturn 0;\n}\n\nstatic int ov9640_set_register(struct v4l2_subdev *sd,\n\t\t\t\tconst struct v4l2_dbg_register *reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tif (reg->reg & ~0xff || reg->val & ~0xff)\n\t\treturn -EINVAL;\n\n\treturn ov9640_reg_write(client, reg->reg, reg->val);\n}\n#endif\n\nstatic int ov9640_s_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct ov9640_priv *priv = to_ov9640_sensor(sd);\n\tint ret = 0;\n\n\tif (on) {\n\t\tgpiod_set_value(priv->gpio_power, 1);\n\t\tusleep_range(1000, 2000);\n\t\tret = clk_prepare_enable(priv->clk);\n\t\tusleep_range(1000, 2000);\n\t\tgpiod_set_value(priv->gpio_reset, 0);\n\t} else {\n\t\tgpiod_set_value(priv->gpio_reset, 1);\n\t\tusleep_range(1000, 2000);\n\t\tclk_disable_unprepare(priv->clk);\n\t\tusleep_range(1000, 2000);\n\t\tgpiod_set_value(priv->gpio_power, 0);\n\t}\n\n\treturn ret;\n}\n\n \nstatic void ov9640_res_roundup(u32 *width, u32 *height)\n{\n\tunsigned int i;\n\tenum { QQCIF, QQVGA, QCIF, QVGA, CIF, VGA, SXGA };\n\tstatic const u32 res_x[] = { 88, 160, 176, 320, 352, 640, 1280 };\n\tstatic const u32 res_y[] = { 72, 120, 144, 240, 288, 480, 960 };\n\n\tfor (i = 0; i < ARRAY_SIZE(res_x); i++) {\n\t\tif (res_x[i] >= *width && res_y[i] >= *height) {\n\t\t\t*width = res_x[i];\n\t\t\t*height = res_y[i];\n\t\t\treturn;\n\t\t}\n\t}\n\n\t*width = res_x[SXGA];\n\t*height = res_y[SXGA];\n}\n\n \nstatic void ov9640_alter_regs(u32 code,\n\t\t\t      struct ov9640_reg_alt *alt)\n{\n\tswitch (code) {\n\tdefault:\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\t\talt->com12\t= OV9640_COM12_YUV_AVG;\n\t\talt->com13\t= OV9640_COM13_Y_DELAY_EN |\n\t\t\t\t\tOV9640_COM13_YUV_DLY(0x01);\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE:\n\t\talt->com7\t= OV9640_COM7_RGB;\n\t\talt->com13\t= OV9640_COM13_RGB_AVG;\n\t\talt->com15\t= OV9640_COM15_RGB_555;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB565_2X8_LE:\n\t\talt->com7\t= OV9640_COM7_RGB;\n\t\talt->com13\t= OV9640_COM13_RGB_AVG;\n\t\talt->com15\t= OV9640_COM15_RGB_565;\n\t\tbreak;\n\t}\n}\n\n \nstatic int ov9640_write_regs(struct i2c_client *client, u32 width,\n\t\tu32 code, struct ov9640_reg_alt *alts)\n{\n\tconst struct ov9640_reg\t*ov9640_regs, *matrix_regs;\n\tunsigned int\t\tov9640_regs_len, matrix_regs_len;\n\tunsigned int\t\ti;\n\tint\t\t\tret;\n\tu8\t\t\tval;\n\n\t \n\tswitch (width) {\n\tcase W_QQCIF:\n\t\tov9640_regs\t= ov9640_regs_qqcif;\n\t\tov9640_regs_len\t= ARRAY_SIZE(ov9640_regs_qqcif);\n\t\tbreak;\n\tcase W_QQVGA:\n\t\tov9640_regs\t= ov9640_regs_qqvga;\n\t\tov9640_regs_len\t= ARRAY_SIZE(ov9640_regs_qqvga);\n\t\tbreak;\n\tcase W_QCIF:\n\t\tov9640_regs\t= ov9640_regs_qcif;\n\t\tov9640_regs_len\t= ARRAY_SIZE(ov9640_regs_qcif);\n\t\tbreak;\n\tcase W_QVGA:\n\t\tov9640_regs\t= ov9640_regs_qvga;\n\t\tov9640_regs_len\t= ARRAY_SIZE(ov9640_regs_qvga);\n\t\tbreak;\n\tcase W_CIF:\n\t\tov9640_regs\t= ov9640_regs_cif;\n\t\tov9640_regs_len\t= ARRAY_SIZE(ov9640_regs_cif);\n\t\tbreak;\n\tcase W_VGA:\n\t\tov9640_regs\t= ov9640_regs_vga;\n\t\tov9640_regs_len\t= ARRAY_SIZE(ov9640_regs_vga);\n\t\tbreak;\n\tcase W_SXGA:\n\t\tov9640_regs\t= ov9640_regs_sxga;\n\t\tov9640_regs_len\t= ARRAY_SIZE(ov9640_regs_sxga);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev, \"Failed to select resolution!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (code == MEDIA_BUS_FMT_UYVY8_2X8) {\n\t\tmatrix_regs\t= ov9640_regs_yuv;\n\t\tmatrix_regs_len\t= ARRAY_SIZE(ov9640_regs_yuv);\n\t} else {\n\t\tmatrix_regs\t= ov9640_regs_rgb;\n\t\tmatrix_regs_len\t= ARRAY_SIZE(ov9640_regs_rgb);\n\t}\n\n\t \n\tfor (i = 0; i < ov9640_regs_len; i++) {\n\t\tval = ov9640_regs[i].val;\n\n\t\tswitch (ov9640_regs[i].reg) {\n\t\tcase OV9640_COM7:\n\t\t\tval |= alts->com7;\n\t\t\tbreak;\n\t\tcase OV9640_COM12:\n\t\t\tval |= alts->com12;\n\t\t\tbreak;\n\t\tcase OV9640_COM13:\n\t\t\tval |= alts->com13;\n\t\t\tbreak;\n\t\tcase OV9640_COM15:\n\t\t\tval |= alts->com15;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ov9640_reg_write(client, ov9640_regs[i].reg, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < matrix_regs_len; i++) {\n\t\tret = ov9640_reg_write(client, matrix_regs[i].reg,\n\t\t\t\t       matrix_regs[i].val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ov9640_prog_dflt(struct i2c_client *client)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(ov9640_regs_dflt); i++) {\n\t\tret = ov9640_reg_write(client, ov9640_regs_dflt[i].reg,\n\t\t\t\t       ov9640_regs_dflt[i].val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tmsleep(150);\n\n\treturn 0;\n}\n\n \nstatic int ov9640_s_fmt(struct v4l2_subdev *sd,\n\t\t\tstruct v4l2_mbus_framefmt *mf)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov9640_reg_alt alts = {0};\n\tint ret;\n\n\tov9640_alter_regs(mf->code, &alts);\n\n\tov9640_reset(client);\n\n\tret = ov9640_prog_dflt(client);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov9640_write_regs(client, mf->width, mf->code, &alts);\n}\n\nstatic int ov9640_set_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tov9640_res_roundup(&mf->width, &mf->height);\n\n\tmf->field = V4L2_FIELD_NONE;\n\n\tswitch (mf->code) {\n\tcase MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE:\n\tcase MEDIA_BUS_FMT_RGB565_2X8_LE:\n\t\tmf->colorspace = V4L2_COLORSPACE_SRGB;\n\t\tbreak;\n\tdefault:\n\t\tmf->code = MEDIA_BUS_FMT_UYVY8_2X8;\n\t\tfallthrough;\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\t\tmf->colorspace = V4L2_COLORSPACE_JPEG;\n\t\tbreak;\n\t}\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn ov9640_s_fmt(sd, mf);\n\n\tsd_state->pads->try_fmt = *mf;\n\n\treturn 0;\n}\n\nstatic int ov9640_enum_mbus_code(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index >= ARRAY_SIZE(ov9640_codes))\n\t\treturn -EINVAL;\n\n\tcode->code = ov9640_codes[code->index];\n\n\treturn 0;\n}\n\nstatic int ov9640_get_selection(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_selection *sel)\n{\n\tif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn -EINVAL;\n\n\tsel->r.left = 0;\n\tsel->r.top = 0;\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r.width = W_SXGA;\n\t\tsel->r.height = H_SXGA;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ov9640_video_probe(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov9640_priv *priv = to_ov9640_sensor(sd);\n\tu8\t\tpid, ver, midh, midl;\n\tconst char\t*devname;\n\tint\t\tret;\n\n\tret = ov9640_s_power(&priv->subdev, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\n\tret = ov9640_reg_read(client, OV9640_PID, &pid);\n\tif (!ret)\n\t\tret = ov9640_reg_read(client, OV9640_VER, &ver);\n\tif (!ret)\n\t\tret = ov9640_reg_read(client, OV9640_MIDH, &midh);\n\tif (!ret)\n\t\tret = ov9640_reg_read(client, OV9640_MIDL, &midl);\n\tif (ret)\n\t\tgoto done;\n\n\tswitch (VERSION(pid, ver)) {\n\tcase OV9640_V2:\n\t\tdevname\t\t= \"ov9640\";\n\t\tpriv->revision\t= 2;\n\t\tbreak;\n\tcase OV9640_V3:\n\t\tdevname\t\t= \"ov9640\";\n\t\tpriv->revision\t= 3;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev, \"Product ID error %x:%x\\n\", pid, ver);\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tdev_info(&client->dev, \"%s Product ID %0x:%0x Manufacturer ID %x:%x\\n\",\n\t\t devname, pid, ver, midh, midl);\n\n\tret = v4l2_ctrl_handler_setup(&priv->hdl);\n\ndone:\n\tov9640_s_power(&priv->subdev, 0);\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops ov9640_ctrl_ops = {\n\t.s_ctrl = ov9640_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops ov9640_core_ops = {\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register\t\t= ov9640_get_register,\n\t.s_register\t\t= ov9640_set_register,\n#endif\n\t.s_power\t\t= ov9640_s_power,\n};\n\n \nstatic int ov9640_get_mbus_config(struct v4l2_subdev *sd,\n\t\t\t\t  unsigned int pad,\n\t\t\t\t  struct v4l2_mbus_config *cfg)\n{\n\tcfg->type = V4L2_MBUS_PARALLEL;\n\tcfg->bus.parallel.flags = V4L2_MBUS_PCLK_SAMPLE_RISING |\n\t\t\t\t  V4L2_MBUS_MASTER |\n\t\t\t\t  V4L2_MBUS_VSYNC_ACTIVE_HIGH |\n\t\t\t\t  V4L2_MBUS_HSYNC_ACTIVE_HIGH |\n\t\t\t\t  V4L2_MBUS_DATA_ACTIVE_HIGH;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops ov9640_video_ops = {\n\t.s_stream\t= ov9640_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops ov9640_pad_ops = {\n\t.enum_mbus_code = ov9640_enum_mbus_code,\n\t.get_selection\t= ov9640_get_selection,\n\t.set_fmt\t= ov9640_set_fmt,\n\t.get_mbus_config = ov9640_get_mbus_config,\n};\n\nstatic const struct v4l2_subdev_ops ov9640_subdev_ops = {\n\t.core\t= &ov9640_core_ops,\n\t.video\t= &ov9640_video_ops,\n\t.pad\t= &ov9640_pad_ops,\n};\n\n \nstatic int ov9640_probe(struct i2c_client *client)\n{\n\tstruct ov9640_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->gpio_power = devm_gpiod_get(&client->dev, \"Camera power\",\n\t\t\t\t\t  GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->gpio_power)) {\n\t\tret = PTR_ERR(priv->gpio_power);\n\t\treturn ret;\n\t}\n\n\tpriv->gpio_reset = devm_gpiod_get(&client->dev, \"Camera reset\",\n\t\t\t\t\t  GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->gpio_reset)) {\n\t\tret = PTR_ERR(priv->gpio_reset);\n\t\treturn ret;\n\t}\n\n\tv4l2_i2c_subdev_init(&priv->subdev, client, &ov9640_subdev_ops);\n\n\tv4l2_ctrl_handler_init(&priv->hdl, 2);\n\tv4l2_ctrl_new_std(&priv->hdl, &ov9640_ctrl_ops,\n\t\t\t  V4L2_CID_VFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(&priv->hdl, &ov9640_ctrl_ops,\n\t\t\t  V4L2_CID_HFLIP, 0, 1, 1, 0);\n\n\tif (priv->hdl.error) {\n\t\tret = priv->hdl.error;\n\t\tgoto ectrlinit;\n\t}\n\n\tpriv->subdev.ctrl_handler = &priv->hdl;\n\n\tpriv->clk = devm_clk_get(&client->dev, \"mclk\");\n\tif (IS_ERR(priv->clk)) {\n\t\tret = PTR_ERR(priv->clk);\n\t\tgoto ectrlinit;\n\t}\n\n\tret = ov9640_video_probe(client);\n\tif (ret)\n\t\tgoto ectrlinit;\n\n\tpriv->subdev.dev = &client->dev;\n\tret = v4l2_async_register_subdev(&priv->subdev);\n\tif (ret)\n\t\tgoto ectrlinit;\n\n\treturn 0;\n\nectrlinit:\n\tv4l2_ctrl_handler_free(&priv->hdl);\n\n\treturn ret;\n}\n\nstatic void ov9640_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov9640_priv *priv = to_ov9640_sensor(sd);\n\n\tv4l2_async_unregister_subdev(&priv->subdev);\n\tv4l2_ctrl_handler_free(&priv->hdl);\n}\n\nstatic const struct i2c_device_id ov9640_id[] = {\n\t{ \"ov9640\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ov9640_id);\n\nstatic struct i2c_driver ov9640_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ov9640\",\n\t},\n\t.probe    = ov9640_probe,\n\t.remove   = ov9640_remove,\n\t.id_table = ov9640_id,\n};\n\nmodule_i2c_driver(ov9640_i2c_driver);\n\nMODULE_DESCRIPTION(\"OmniVision OV96xx CMOS Image Sensor driver\");\nMODULE_AUTHOR(\"Marek Vasut <marek.vasut@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}