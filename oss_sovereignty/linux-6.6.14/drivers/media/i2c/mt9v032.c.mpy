{
  "module_name": "mt9v032.c",
  "hash_id": "01642ef44ad822ae1e9863601534a7cfe6fc0057d75cc5ebf14f1e8c2da7d9d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/mt9v032.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/log2.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <linux/v4l2-mediabus.h>\n#include <linux/module.h>\n\n#include <media/i2c/mt9v032.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n \n#define MT9V032_PIXEL_ARRAY_HEIGHT\t\t\t485\n#define MT9V032_PIXEL_ARRAY_WIDTH\t\t\t753\n\n#define MT9V032_SYSCLK_FREQ_DEF\t\t\t\t26600000\n\n#define MT9V032_CHIP_VERSION\t\t\t\t0x00\n#define\t\tMT9V032_CHIP_ID_REV1\t\t\t0x1311\n#define\t\tMT9V032_CHIP_ID_REV3\t\t\t0x1313\n#define\t\tMT9V034_CHIP_ID_REV1\t\t\t0X1324\n#define MT9V032_COLUMN_START\t\t\t\t0x01\n#define\t\tMT9V032_COLUMN_START_MIN\t\t1\n#define\t\tMT9V032_COLUMN_START_DEF\t\t1\n#define\t\tMT9V032_COLUMN_START_MAX\t\t752\n#define MT9V032_ROW_START\t\t\t\t0x02\n#define\t\tMT9V032_ROW_START_MIN\t\t\t4\n#define\t\tMT9V032_ROW_START_DEF\t\t\t5\n#define\t\tMT9V032_ROW_START_MAX\t\t\t482\n#define MT9V032_WINDOW_HEIGHT\t\t\t\t0x03\n#define\t\tMT9V032_WINDOW_HEIGHT_MIN\t\t1\n#define\t\tMT9V032_WINDOW_HEIGHT_DEF\t\t480\n#define\t\tMT9V032_WINDOW_HEIGHT_MAX\t\t480\n#define MT9V032_WINDOW_WIDTH\t\t\t\t0x04\n#define\t\tMT9V032_WINDOW_WIDTH_MIN\t\t1\n#define\t\tMT9V032_WINDOW_WIDTH_DEF\t\t752\n#define\t\tMT9V032_WINDOW_WIDTH_MAX\t\t752\n#define MT9V032_HORIZONTAL_BLANKING\t\t\t0x05\n#define\t\tMT9V032_HORIZONTAL_BLANKING_MIN\t\t43\n#define\t\tMT9V034_HORIZONTAL_BLANKING_MIN\t\t61\n#define\t\tMT9V032_HORIZONTAL_BLANKING_DEF\t\t94\n#define\t\tMT9V032_HORIZONTAL_BLANKING_MAX\t\t1023\n#define MT9V032_VERTICAL_BLANKING\t\t\t0x06\n#define\t\tMT9V032_VERTICAL_BLANKING_MIN\t\t4\n#define\t\tMT9V034_VERTICAL_BLANKING_MIN\t\t2\n#define\t\tMT9V032_VERTICAL_BLANKING_DEF\t\t45\n#define\t\tMT9V032_VERTICAL_BLANKING_MAX\t\t3000\n#define\t\tMT9V034_VERTICAL_BLANKING_MAX\t\t32288\n#define MT9V032_CHIP_CONTROL\t\t\t\t0x07\n#define\t\tMT9V032_CHIP_CONTROL_MASTER_MODE\t(1 << 3)\n#define\t\tMT9V032_CHIP_CONTROL_DOUT_ENABLE\t(1 << 7)\n#define\t\tMT9V032_CHIP_CONTROL_SEQUENTIAL\t\t(1 << 8)\n#define MT9V032_SHUTTER_WIDTH1\t\t\t\t0x08\n#define MT9V032_SHUTTER_WIDTH2\t\t\t\t0x09\n#define MT9V032_SHUTTER_WIDTH_CONTROL\t\t\t0x0a\n#define MT9V032_TOTAL_SHUTTER_WIDTH\t\t\t0x0b\n#define\t\tMT9V032_TOTAL_SHUTTER_WIDTH_MIN\t\t1\n#define\t\tMT9V034_TOTAL_SHUTTER_WIDTH_MIN\t\t0\n#define\t\tMT9V032_TOTAL_SHUTTER_WIDTH_DEF\t\t480\n#define\t\tMT9V032_TOTAL_SHUTTER_WIDTH_MAX\t\t32767\n#define\t\tMT9V034_TOTAL_SHUTTER_WIDTH_MAX\t\t32765\n#define MT9V032_RESET\t\t\t\t\t0x0c\n#define MT9V032_READ_MODE\t\t\t\t0x0d\n#define\t\tMT9V032_READ_MODE_ROW_BIN_MASK\t\t(3 << 0)\n#define\t\tMT9V032_READ_MODE_ROW_BIN_SHIFT\t\t0\n#define\t\tMT9V032_READ_MODE_COLUMN_BIN_MASK\t(3 << 2)\n#define\t\tMT9V032_READ_MODE_COLUMN_BIN_SHIFT\t2\n#define\t\tMT9V032_READ_MODE_ROW_FLIP\t\t(1 << 4)\n#define\t\tMT9V032_READ_MODE_COLUMN_FLIP\t\t(1 << 5)\n#define\t\tMT9V032_READ_MODE_DARK_COLUMNS\t\t(1 << 6)\n#define\t\tMT9V032_READ_MODE_DARK_ROWS\t\t(1 << 7)\n#define\t\tMT9V032_READ_MODE_RESERVED\t\t0x0300\n#define MT9V032_PIXEL_OPERATION_MODE\t\t\t0x0f\n#define\t\tMT9V034_PIXEL_OPERATION_MODE_HDR\t(1 << 0)\n#define\t\tMT9V034_PIXEL_OPERATION_MODE_COLOR\t(1 << 1)\n#define\t\tMT9V032_PIXEL_OPERATION_MODE_COLOR\t(1 << 2)\n#define\t\tMT9V032_PIXEL_OPERATION_MODE_HDR\t(1 << 6)\n#define MT9V032_ANALOG_GAIN\t\t\t\t0x35\n#define\t\tMT9V032_ANALOG_GAIN_MIN\t\t\t16\n#define\t\tMT9V032_ANALOG_GAIN_DEF\t\t\t16\n#define\t\tMT9V032_ANALOG_GAIN_MAX\t\t\t64\n#define MT9V032_MAX_ANALOG_GAIN\t\t\t\t0x36\n#define\t\tMT9V032_MAX_ANALOG_GAIN_MAX\t\t127\n#define MT9V032_FRAME_DARK_AVERAGE\t\t\t0x42\n#define MT9V032_DARK_AVG_THRESH\t\t\t\t0x46\n#define\t\tMT9V032_DARK_AVG_LOW_THRESH_MASK\t(255 << 0)\n#define\t\tMT9V032_DARK_AVG_LOW_THRESH_SHIFT\t0\n#define\t\tMT9V032_DARK_AVG_HIGH_THRESH_MASK\t(255 << 8)\n#define\t\tMT9V032_DARK_AVG_HIGH_THRESH_SHIFT\t8\n#define MT9V032_ROW_NOISE_CORR_CONTROL\t\t\t0x70\n#define\t\tMT9V034_ROW_NOISE_CORR_ENABLE\t\t(1 << 0)\n#define\t\tMT9V034_ROW_NOISE_CORR_USE_BLK_AVG\t(1 << 1)\n#define\t\tMT9V032_ROW_NOISE_CORR_ENABLE\t\t(1 << 5)\n#define\t\tMT9V032_ROW_NOISE_CORR_USE_BLK_AVG\t(1 << 7)\n#define MT9V032_PIXEL_CLOCK\t\t\t\t0x74\n#define MT9V034_PIXEL_CLOCK\t\t\t\t0x72\n#define\t\tMT9V032_PIXEL_CLOCK_INV_LINE\t\t(1 << 0)\n#define\t\tMT9V032_PIXEL_CLOCK_INV_FRAME\t\t(1 << 1)\n#define\t\tMT9V032_PIXEL_CLOCK_XOR_LINE\t\t(1 << 2)\n#define\t\tMT9V032_PIXEL_CLOCK_CONT_LINE\t\t(1 << 3)\n#define\t\tMT9V032_PIXEL_CLOCK_INV_PXL_CLK\t\t(1 << 4)\n#define MT9V032_TEST_PATTERN\t\t\t\t0x7f\n#define\t\tMT9V032_TEST_PATTERN_DATA_MASK\t\t(1023 << 0)\n#define\t\tMT9V032_TEST_PATTERN_DATA_SHIFT\t\t0\n#define\t\tMT9V032_TEST_PATTERN_USE_DATA\t\t(1 << 10)\n#define\t\tMT9V032_TEST_PATTERN_GRAY_MASK\t\t(3 << 11)\n#define\t\tMT9V032_TEST_PATTERN_GRAY_NONE\t\t(0 << 11)\n#define\t\tMT9V032_TEST_PATTERN_GRAY_VERTICAL\t(1 << 11)\n#define\t\tMT9V032_TEST_PATTERN_GRAY_HORIZONTAL\t(2 << 11)\n#define\t\tMT9V032_TEST_PATTERN_GRAY_DIAGONAL\t(3 << 11)\n#define\t\tMT9V032_TEST_PATTERN_ENABLE\t\t(1 << 13)\n#define\t\tMT9V032_TEST_PATTERN_FLIP\t\t(1 << 14)\n#define MT9V032_AEGC_DESIRED_BIN\t\t\t0xa5\n#define MT9V032_AEC_UPDATE_FREQUENCY\t\t\t0xa6\n#define MT9V032_AEC_LPF\t\t\t\t\t0xa8\n#define MT9V032_AGC_UPDATE_FREQUENCY\t\t\t0xa9\n#define MT9V032_AGC_LPF\t\t\t\t\t0xaa\n#define MT9V032_AEC_AGC_ENABLE\t\t\t\t0xaf\n#define\t\tMT9V032_AEC_ENABLE\t\t\t(1 << 0)\n#define\t\tMT9V032_AGC_ENABLE\t\t\t(1 << 1)\n#define MT9V034_AEC_MAX_SHUTTER_WIDTH\t\t\t0xad\n#define MT9V032_AEC_MAX_SHUTTER_WIDTH\t\t\t0xbd\n#define MT9V032_THERMAL_INFO\t\t\t\t0xc1\n\nenum mt9v032_model {\n\tMT9V032_MODEL_V022_COLOR,\t \n\tMT9V032_MODEL_V022_MONO,\t \n\tMT9V032_MODEL_V024_COLOR,\t \n\tMT9V032_MODEL_V024_MONO,\t \n\tMT9V032_MODEL_V032_COLOR,\t \n\tMT9V032_MODEL_V032_MONO,\t \n\tMT9V032_MODEL_V034_COLOR,\n\tMT9V032_MODEL_V034_MONO,\n};\n\nstruct mt9v032_model_version {\n\tunsigned int version;\n\tconst char *name;\n};\n\nstruct mt9v032_model_data {\n\tunsigned int min_row_time;\n\tunsigned int min_hblank;\n\tunsigned int min_vblank;\n\tunsigned int max_vblank;\n\tunsigned int min_shutter;\n\tunsigned int max_shutter;\n\tunsigned int pclk_reg;\n\tunsigned int aec_max_shutter_reg;\n\tconst struct v4l2_ctrl_config * const aec_max_shutter_v4l2_ctrl;\n};\n\nstruct mt9v032_model_info {\n\tconst struct mt9v032_model_data *data;\n\tbool color;\n};\n\nstatic const struct mt9v032_model_version mt9v032_versions[] = {\n\t{ MT9V032_CHIP_ID_REV1, \"MT9V022/MT9V032 rev1/2\" },\n\t{ MT9V032_CHIP_ID_REV3, \"MT9V022/MT9V032 rev3\" },\n\t{ MT9V034_CHIP_ID_REV1, \"MT9V024/MT9V034 rev1\" },\n};\n\nstruct mt9v032 {\n\tstruct v4l2_subdev subdev;\n\tstruct media_pad pad;\n\n\tstruct v4l2_mbus_framefmt format;\n\tstruct v4l2_rect crop;\n\tunsigned int hratio;\n\tunsigned int vratio;\n\n\tstruct v4l2_ctrl_handler ctrls;\n\tstruct {\n\t\tstruct v4l2_ctrl *link_freq;\n\t\tstruct v4l2_ctrl *pixel_rate;\n\t};\n\n\tstruct mutex power_lock;\n\tint power_count;\n\n\tstruct regmap *regmap;\n\tstruct clk *clk;\n\tstruct gpio_desc *reset_gpio;\n\tstruct gpio_desc *standby_gpio;\n\n\tstruct mt9v032_platform_data *pdata;\n\tconst struct mt9v032_model_info *model;\n\tconst struct mt9v032_model_version *version;\n\n\tu32 sysclk;\n\tu16 aec_agc;\n\tu16 hblank;\n\tstruct {\n\t\tstruct v4l2_ctrl *test_pattern;\n\t\tstruct v4l2_ctrl *test_pattern_color;\n\t};\n};\n\nstatic struct mt9v032 *to_mt9v032(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct mt9v032, subdev);\n}\n\nstatic int\nmt9v032_update_aec_agc(struct mt9v032 *mt9v032, u16 which, int enable)\n{\n\tstruct regmap *map = mt9v032->regmap;\n\tu16 value = mt9v032->aec_agc;\n\tint ret;\n\n\tif (enable)\n\t\tvalue |= which;\n\telse\n\t\tvalue &= ~which;\n\n\tret = regmap_write(map, MT9V032_AEC_AGC_ENABLE, value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmt9v032->aec_agc = value;\n\treturn 0;\n}\n\nstatic int\nmt9v032_update_hblank(struct mt9v032 *mt9v032)\n{\n\tstruct v4l2_rect *crop = &mt9v032->crop;\n\tunsigned int min_hblank = mt9v032->model->data->min_hblank;\n\tunsigned int hblank;\n\n\tif (mt9v032->version->version == MT9V034_CHIP_ID_REV1)\n\t\tmin_hblank += (mt9v032->hratio - 1) * 10;\n\tmin_hblank = max_t(int, mt9v032->model->data->min_row_time - crop->width,\n\t\t\t   min_hblank);\n\thblank = max_t(unsigned int, mt9v032->hblank, min_hblank);\n\n\treturn regmap_write(mt9v032->regmap, MT9V032_HORIZONTAL_BLANKING,\n\t\t\t    hblank);\n}\n\nstatic int mt9v032_power_on(struct mt9v032 *mt9v032)\n{\n\tstruct regmap *map = mt9v032->regmap;\n\tint ret;\n\n\tgpiod_set_value_cansleep(mt9v032->reset_gpio, 1);\n\n\tret = clk_set_rate(mt9v032->clk, mt9v032->sysclk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = clk_prepare_enable(mt9v032->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tudelay(1);\n\n\tif (mt9v032->reset_gpio) {\n\t\tgpiod_set_value_cansleep(mt9v032->reset_gpio, 0);\n\n\t\t \n\t\tudelay(1);\n\t}\n\n\t \n\tret = regmap_write(map, MT9V032_RESET, 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = regmap_write(map, MT9V032_RESET, 0);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = regmap_write(map, MT9V032_CHIP_CONTROL,\n\t\t\t   MT9V032_CHIP_CONTROL_MASTER_MODE);\n\tif (ret < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tclk_disable_unprepare(mt9v032->clk);\n\treturn ret;\n}\n\nstatic void mt9v032_power_off(struct mt9v032 *mt9v032)\n{\n\tclk_disable_unprepare(mt9v032->clk);\n}\n\nstatic int __mt9v032_set_power(struct mt9v032 *mt9v032, bool on)\n{\n\tstruct regmap *map = mt9v032->regmap;\n\tint ret;\n\n\tif (!on) {\n\t\tmt9v032_power_off(mt9v032);\n\t\treturn 0;\n\t}\n\n\tret = mt9v032_power_on(mt9v032);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (mt9v032->pdata && mt9v032->pdata->clk_pol) {\n\t\tret = regmap_write(map, mt9v032->model->data->pclk_reg,\n\t\t\t\tMT9V032_PIXEL_CLOCK_INV_PXL_CLK);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_write(map, MT9V032_ROW_NOISE_CORR_CONTROL, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn v4l2_ctrl_handler_setup(&mt9v032->ctrls);\n}\n\n \n\nstatic struct v4l2_mbus_framefmt *\n__mt9v032_get_pad_format(struct mt9v032 *mt9v032,\n\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t unsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\treturn v4l2_subdev_get_try_format(&mt9v032->subdev, sd_state,\n\t\t\t\t\t\t  pad);\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &mt9v032->format;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic struct v4l2_rect *\n__mt9v032_get_pad_crop(struct mt9v032 *mt9v032,\n\t\t       struct v4l2_subdev_state *sd_state,\n\t\t       unsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\treturn v4l2_subdev_get_try_crop(&mt9v032->subdev, sd_state,\n\t\t\t\t\t\tpad);\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &mt9v032->crop;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic int mt9v032_s_stream(struct v4l2_subdev *subdev, int enable)\n{\n\tconst u16 mode = MT9V032_CHIP_CONTROL_DOUT_ENABLE\n\t\t       | MT9V032_CHIP_CONTROL_SEQUENTIAL;\n\tstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\n\tstruct v4l2_rect *crop = &mt9v032->crop;\n\tstruct regmap *map = mt9v032->regmap;\n\tunsigned int hbin;\n\tunsigned int vbin;\n\tint ret;\n\n\tif (!enable)\n\t\treturn regmap_update_bits(map, MT9V032_CHIP_CONTROL, mode, 0);\n\n\t \n\thbin = fls(mt9v032->hratio) - 1;\n\tvbin = fls(mt9v032->vratio) - 1;\n\tret = regmap_update_bits(map, MT9V032_READ_MODE,\n\t\t\t\t ~MT9V032_READ_MODE_RESERVED,\n\t\t\t\t hbin << MT9V032_READ_MODE_COLUMN_BIN_SHIFT |\n\t\t\t\t vbin << MT9V032_READ_MODE_ROW_BIN_SHIFT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(map, MT9V032_COLUMN_START, crop->left);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(map, MT9V032_ROW_START, crop->top);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(map, MT9V032_WINDOW_WIDTH, crop->width);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(map, MT9V032_WINDOW_HEIGHT, crop->height);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mt9v032_update_hblank(mt9v032);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn regmap_update_bits(map, MT9V032_CHIP_CONTROL, mode, mode);\n}\n\nstatic int mt9v032_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\n\n\tif (code->index > 0)\n\t\treturn -EINVAL;\n\n\tcode->code = mt9v032->format.code;\n\treturn 0;\n}\n\nstatic int mt9v032_enum_frame_size(struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\n\n\tif (fse->index >= 3)\n\t\treturn -EINVAL;\n\tif (mt9v032->format.code != fse->code)\n\t\treturn -EINVAL;\n\n\tfse->min_width = MT9V032_WINDOW_WIDTH_DEF / (1 << fse->index);\n\tfse->max_width = fse->min_width;\n\tfse->min_height = MT9V032_WINDOW_HEIGHT_DEF / (1 << fse->index);\n\tfse->max_height = fse->min_height;\n\n\treturn 0;\n}\n\nstatic int mt9v032_get_format(struct v4l2_subdev *subdev,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *format)\n{\n\tstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\n\n\tformat->format = *__mt9v032_get_pad_format(mt9v032, sd_state,\n\t\t\t\t\t\t   format->pad,\n\t\t\t\t\t\t   format->which);\n\treturn 0;\n}\n\nstatic void mt9v032_configure_pixel_rate(struct mt9v032 *mt9v032)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9v032->subdev);\n\tint ret;\n\n\tret = v4l2_ctrl_s_ctrl_int64(mt9v032->pixel_rate,\n\t\t\t\t     mt9v032->sysclk / mt9v032->hratio);\n\tif (ret < 0)\n\t\tdev_warn(&client->dev, \"failed to set pixel rate (%d)\\n\", ret);\n}\n\nstatic unsigned int mt9v032_calc_ratio(unsigned int input, unsigned int output)\n{\n\t \n\tif (output * 3 > input * 2)\n\t\treturn 1;\n\tif (output * 3 > input)\n\t\treturn 2;\n\treturn 4;\n}\n\nstatic int mt9v032_set_format(struct v4l2_subdev *subdev,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *format)\n{\n\tstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\n\tstruct v4l2_mbus_framefmt *__format;\n\tstruct v4l2_rect *__crop;\n\tunsigned int width;\n\tunsigned int height;\n\tunsigned int hratio;\n\tunsigned int vratio;\n\n\t__crop = __mt9v032_get_pad_crop(mt9v032, sd_state, format->pad,\n\t\t\t\t\tformat->which);\n\n\t \n\twidth = clamp(ALIGN(format->format.width, 2),\n\t\t      max_t(unsigned int, __crop->width / 4,\n\t\t\t    MT9V032_WINDOW_WIDTH_MIN),\n\t\t      __crop->width);\n\theight = clamp(ALIGN(format->format.height, 2),\n\t\t       max_t(unsigned int, __crop->height / 4,\n\t\t\t     MT9V032_WINDOW_HEIGHT_MIN),\n\t\t       __crop->height);\n\n\thratio = mt9v032_calc_ratio(__crop->width, width);\n\tvratio = mt9v032_calc_ratio(__crop->height, height);\n\n\t__format = __mt9v032_get_pad_format(mt9v032, sd_state, format->pad,\n\t\t\t\t\t    format->which);\n\t__format->width = __crop->width / hratio;\n\t__format->height = __crop->height / vratio;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\tmt9v032->hratio = hratio;\n\t\tmt9v032->vratio = vratio;\n\t\tmt9v032_configure_pixel_rate(mt9v032);\n\t}\n\n\tformat->format = *__format;\n\n\treturn 0;\n}\n\nstatic int mt9v032_get_selection(struct v4l2_subdev *subdev,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_selection *sel)\n{\n\tstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\n\n\tif (sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\tsel->r = *__mt9v032_get_pad_crop(mt9v032, sd_state, sel->pad,\n\t\t\t\t\t sel->which);\n\treturn 0;\n}\n\nstatic int mt9v032_set_selection(struct v4l2_subdev *subdev,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_selection *sel)\n{\n\tstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\n\tstruct v4l2_mbus_framefmt *__format;\n\tstruct v4l2_rect *__crop;\n\tstruct v4l2_rect rect;\n\n\tif (sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\t \n\trect.left = clamp(ALIGN(sel->r.left + 1, 2) - 1,\n\t\t\t  MT9V032_COLUMN_START_MIN,\n\t\t\t  MT9V032_COLUMN_START_MAX);\n\trect.top = clamp(ALIGN(sel->r.top + 1, 2) - 1,\n\t\t\t MT9V032_ROW_START_MIN,\n\t\t\t MT9V032_ROW_START_MAX);\n\trect.width = clamp_t(unsigned int, ALIGN(sel->r.width, 2),\n\t\t\t     MT9V032_WINDOW_WIDTH_MIN,\n\t\t\t     MT9V032_WINDOW_WIDTH_MAX);\n\trect.height = clamp_t(unsigned int, ALIGN(sel->r.height, 2),\n\t\t\t      MT9V032_WINDOW_HEIGHT_MIN,\n\t\t\t      MT9V032_WINDOW_HEIGHT_MAX);\n\n\trect.width = min_t(unsigned int,\n\t\t\t   rect.width, MT9V032_PIXEL_ARRAY_WIDTH - rect.left);\n\trect.height = min_t(unsigned int,\n\t\t\t    rect.height, MT9V032_PIXEL_ARRAY_HEIGHT - rect.top);\n\n\t__crop = __mt9v032_get_pad_crop(mt9v032, sd_state, sel->pad,\n\t\t\t\t\tsel->which);\n\n\tif (rect.width != __crop->width || rect.height != __crop->height) {\n\t\t \n\t\t__format = __mt9v032_get_pad_format(mt9v032, sd_state,\n\t\t\t\t\t\t    sel->pad,\n\t\t\t\t\t\t    sel->which);\n\t\t__format->width = rect.width;\n\t\t__format->height = rect.height;\n\t\tif (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\t\tmt9v032->hratio = 1;\n\t\t\tmt9v032->vratio = 1;\n\t\t\tmt9v032_configure_pixel_rate(mt9v032);\n\t\t}\n\t}\n\n\t*__crop = rect;\n\tsel->r = rect;\n\n\treturn 0;\n}\n\n \n\n#define V4L2_CID_TEST_PATTERN_COLOR\t(V4L2_CID_USER_BASE | 0x1001)\n \n#define V4L2_CID_AEGC_DESIRED_BIN\t(V4L2_CID_USER_BASE | 0x1002)\n \n#define V4L2_CID_AEC_LPF\t\t(V4L2_CID_USER_BASE | 0x1003)\n#define V4L2_CID_AGC_LPF\t\t(V4L2_CID_USER_BASE | 0x1004)\n \n#define V4L2_CID_AEC_UPDATE_INTERVAL\t(V4L2_CID_USER_BASE | 0x1005)\n#define V4L2_CID_AGC_UPDATE_INTERVAL\t(V4L2_CID_USER_BASE | 0x1006)\n \n#define V4L2_CID_AEC_MAX_SHUTTER_WIDTH\t(V4L2_CID_USER_BASE | 0x1007)\n\nstatic int mt9v032_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct mt9v032 *mt9v032 =\n\t\t\tcontainer_of(ctrl->handler, struct mt9v032, ctrls);\n\tstruct regmap *map = mt9v032->regmap;\n\tu32 freq;\n\tu16 data;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTOGAIN:\n\t\treturn mt9v032_update_aec_agc(mt9v032, MT9V032_AGC_ENABLE,\n\t\t\t\t\t      ctrl->val);\n\n\tcase V4L2_CID_GAIN:\n\t\treturn regmap_write(map, MT9V032_ANALOG_GAIN, ctrl->val);\n\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\treturn mt9v032_update_aec_agc(mt9v032, MT9V032_AEC_ENABLE,\n\t\t\t\t\t      !ctrl->val);\n\n\tcase V4L2_CID_EXPOSURE:\n\t\treturn regmap_write(map, MT9V032_TOTAL_SHUTTER_WIDTH,\n\t\t\t\t    ctrl->val);\n\n\tcase V4L2_CID_HBLANK:\n\t\tmt9v032->hblank = ctrl->val;\n\t\treturn mt9v032_update_hblank(mt9v032);\n\n\tcase V4L2_CID_VBLANK:\n\t\treturn regmap_write(map, MT9V032_VERTICAL_BLANKING,\n\t\t\t\t    ctrl->val);\n\n\tcase V4L2_CID_PIXEL_RATE:\n\tcase V4L2_CID_LINK_FREQ:\n\t\tif (mt9v032->link_freq == NULL)\n\t\t\tbreak;\n\n\t\tfreq = mt9v032->pdata->link_freqs[mt9v032->link_freq->val];\n\t\t*mt9v032->pixel_rate->p_new.p_s64 = freq;\n\t\tmt9v032->sysclk = freq;\n\t\tbreak;\n\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tswitch (mt9v032->test_pattern->val) {\n\t\tcase 0:\n\t\t\tdata = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdata = MT9V032_TEST_PATTERN_GRAY_VERTICAL\n\t\t\t     | MT9V032_TEST_PATTERN_ENABLE;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdata = MT9V032_TEST_PATTERN_GRAY_HORIZONTAL\n\t\t\t     | MT9V032_TEST_PATTERN_ENABLE;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdata = MT9V032_TEST_PATTERN_GRAY_DIAGONAL\n\t\t\t     | MT9V032_TEST_PATTERN_ENABLE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdata = (mt9v032->test_pattern_color->val <<\n\t\t\t\tMT9V032_TEST_PATTERN_DATA_SHIFT)\n\t\t\t     | MT9V032_TEST_PATTERN_USE_DATA\n\t\t\t     | MT9V032_TEST_PATTERN_ENABLE\n\t\t\t     | MT9V032_TEST_PATTERN_FLIP;\n\t\t\tbreak;\n\t\t}\n\t\treturn regmap_write(map, MT9V032_TEST_PATTERN, data);\n\n\tcase V4L2_CID_AEGC_DESIRED_BIN:\n\t\treturn regmap_write(map, MT9V032_AEGC_DESIRED_BIN, ctrl->val);\n\n\tcase V4L2_CID_AEC_LPF:\n\t\treturn regmap_write(map, MT9V032_AEC_LPF, ctrl->val);\n\n\tcase V4L2_CID_AGC_LPF:\n\t\treturn regmap_write(map, MT9V032_AGC_LPF, ctrl->val);\n\n\tcase V4L2_CID_AEC_UPDATE_INTERVAL:\n\t\treturn regmap_write(map, MT9V032_AEC_UPDATE_FREQUENCY,\n\t\t\t\t    ctrl->val);\n\n\tcase V4L2_CID_AGC_UPDATE_INTERVAL:\n\t\treturn regmap_write(map, MT9V032_AGC_UPDATE_FREQUENCY,\n\t\t\t\t    ctrl->val);\n\n\tcase V4L2_CID_AEC_MAX_SHUTTER_WIDTH:\n\t\treturn regmap_write(map,\n\t\t\t\t    mt9v032->model->data->aec_max_shutter_reg,\n\t\t\t\t    ctrl->val);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops mt9v032_ctrl_ops = {\n\t.s_ctrl = mt9v032_s_ctrl,\n};\n\nstatic const char * const mt9v032_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Gray Vertical Shade\",\n\t\"Gray Horizontal Shade\",\n\t\"Gray Diagonal Shade\",\n\t\"Plain\",\n};\n\nstatic const struct v4l2_ctrl_config mt9v032_test_pattern_color = {\n\t.ops\t\t= &mt9v032_ctrl_ops,\n\t.id\t\t= V4L2_CID_TEST_PATTERN_COLOR,\n\t.type\t\t= V4L2_CTRL_TYPE_INTEGER,\n\t.name\t\t= \"Test Pattern Color\",\n\t.min\t\t= 0,\n\t.max\t\t= 1023,\n\t.step\t\t= 1,\n\t.def\t\t= 0,\n\t.flags\t\t= 0,\n};\n\nstatic const struct v4l2_ctrl_config mt9v032_aegc_controls[] = {\n\t{\n\t\t.ops\t\t= &mt9v032_ctrl_ops,\n\t\t.id\t\t= V4L2_CID_AEGC_DESIRED_BIN,\n\t\t.type\t\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.name\t\t= \"AEC/AGC Desired Bin\",\n\t\t.min\t\t= 1,\n\t\t.max\t\t= 64,\n\t\t.step\t\t= 1,\n\t\t.def\t\t= 58,\n\t\t.flags\t\t= 0,\n\t}, {\n\t\t.ops\t\t= &mt9v032_ctrl_ops,\n\t\t.id\t\t= V4L2_CID_AEC_LPF,\n\t\t.type\t\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.name\t\t= \"AEC Low Pass Filter\",\n\t\t.min\t\t= 0,\n\t\t.max\t\t= 2,\n\t\t.step\t\t= 1,\n\t\t.def\t\t= 0,\n\t\t.flags\t\t= 0,\n\t}, {\n\t\t.ops\t\t= &mt9v032_ctrl_ops,\n\t\t.id\t\t= V4L2_CID_AGC_LPF,\n\t\t.type\t\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.name\t\t= \"AGC Low Pass Filter\",\n\t\t.min\t\t= 0,\n\t\t.max\t\t= 2,\n\t\t.step\t\t= 1,\n\t\t.def\t\t= 2,\n\t\t.flags\t\t= 0,\n\t}, {\n\t\t.ops\t\t= &mt9v032_ctrl_ops,\n\t\t.id\t\t= V4L2_CID_AEC_UPDATE_INTERVAL,\n\t\t.type\t\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.name\t\t= \"AEC Update Interval\",\n\t\t.min\t\t= 0,\n\t\t.max\t\t= 16,\n\t\t.step\t\t= 1,\n\t\t.def\t\t= 2,\n\t\t.flags\t\t= 0,\n\t}, {\n\t\t.ops\t\t= &mt9v032_ctrl_ops,\n\t\t.id\t\t= V4L2_CID_AGC_UPDATE_INTERVAL,\n\t\t.type\t\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.name\t\t= \"AGC Update Interval\",\n\t\t.min\t\t= 0,\n\t\t.max\t\t= 16,\n\t\t.step\t\t= 1,\n\t\t.def\t\t= 2,\n\t\t.flags\t\t= 0,\n\t}\n};\n\nstatic const struct v4l2_ctrl_config mt9v032_aec_max_shutter_width = {\n\t.ops\t\t= &mt9v032_ctrl_ops,\n\t.id\t\t= V4L2_CID_AEC_MAX_SHUTTER_WIDTH,\n\t.type\t\t= V4L2_CTRL_TYPE_INTEGER,\n\t.name\t\t= \"AEC Max Shutter Width\",\n\t.min\t\t= 1,\n\t.max\t\t= 2047,\n\t.step\t\t= 1,\n\t.def\t\t= 480,\n\t.flags\t\t= 0,\n};\n\nstatic const struct v4l2_ctrl_config mt9v034_aec_max_shutter_width = {\n\t.ops\t\t= &mt9v032_ctrl_ops,\n\t.id\t\t= V4L2_CID_AEC_MAX_SHUTTER_WIDTH,\n\t.type\t\t= V4L2_CTRL_TYPE_INTEGER,\n\t.name\t\t= \"AEC Max Shutter Width\",\n\t.min\t\t= 1,\n\t.max\t\t= 32765,\n\t.step\t\t= 1,\n\t.def\t\t= 480,\n\t.flags\t\t= 0,\n};\n\n \n\nstatic int mt9v032_set_power(struct v4l2_subdev *subdev, int on)\n{\n\tstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\n\tint ret = 0;\n\n\tmutex_lock(&mt9v032->power_lock);\n\n\t \n\tif (mt9v032->power_count == !on) {\n\t\tret = __mt9v032_set_power(mt9v032, !!on);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\t \n\tmt9v032->power_count += on ? 1 : -1;\n\tWARN_ON(mt9v032->power_count < 0);\n\ndone:\n\tmutex_unlock(&mt9v032->power_lock);\n\treturn ret;\n}\n\n \n\nstatic int mt9v032_registered(struct v4l2_subdev *subdev)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(subdev);\n\tstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\n\tunsigned int i;\n\tu32 version;\n\tint ret;\n\n\tdev_info(&client->dev, \"Probing MT9V032 at address 0x%02x\\n\",\n\t\t\tclient->addr);\n\n\tret = mt9v032_power_on(mt9v032);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"MT9V032 power up failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_read(mt9v032->regmap, MT9V032_CHIP_VERSION, &version);\n\n\tmt9v032_power_off(mt9v032);\n\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed reading chip version\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(mt9v032_versions); ++i) {\n\t\tif (mt9v032_versions[i].version == version) {\n\t\t\tmt9v032->version = &mt9v032_versions[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (mt9v032->version == NULL) {\n\t\tdev_err(&client->dev, \"Unsupported chip version 0x%04x\\n\",\n\t\t\tversion);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(&client->dev, \"%s detected at address 0x%02x\\n\",\n\t\t mt9v032->version->name, client->addr);\n\n\tmt9v032_configure_pixel_rate(mt9v032);\n\n\treturn ret;\n}\n\nstatic int mt9v032_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)\n{\n\tstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct v4l2_rect *crop;\n\n\tcrop = v4l2_subdev_get_try_crop(subdev, fh->state, 0);\n\tcrop->left = MT9V032_COLUMN_START_DEF;\n\tcrop->top = MT9V032_ROW_START_DEF;\n\tcrop->width = MT9V032_WINDOW_WIDTH_DEF;\n\tcrop->height = MT9V032_WINDOW_HEIGHT_DEF;\n\n\tformat = v4l2_subdev_get_try_format(subdev, fh->state, 0);\n\n\tif (mt9v032->model->color)\n\t\tformat->code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\telse\n\t\tformat->code = MEDIA_BUS_FMT_Y10_1X10;\n\n\tformat->width = MT9V032_WINDOW_WIDTH_DEF;\n\tformat->height = MT9V032_WINDOW_HEIGHT_DEF;\n\tformat->field = V4L2_FIELD_NONE;\n\tformat->colorspace = V4L2_COLORSPACE_SRGB;\n\n\treturn mt9v032_set_power(subdev, 1);\n}\n\nstatic int mt9v032_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)\n{\n\treturn mt9v032_set_power(subdev, 0);\n}\n\nstatic const struct v4l2_subdev_core_ops mt9v032_subdev_core_ops = {\n\t.s_power\t= mt9v032_set_power,\n};\n\nstatic const struct v4l2_subdev_video_ops mt9v032_subdev_video_ops = {\n\t.s_stream\t= mt9v032_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops mt9v032_subdev_pad_ops = {\n\t.enum_mbus_code = mt9v032_enum_mbus_code,\n\t.enum_frame_size = mt9v032_enum_frame_size,\n\t.get_fmt = mt9v032_get_format,\n\t.set_fmt = mt9v032_set_format,\n\t.get_selection = mt9v032_get_selection,\n\t.set_selection = mt9v032_set_selection,\n};\n\nstatic const struct v4l2_subdev_ops mt9v032_subdev_ops = {\n\t.core\t= &mt9v032_subdev_core_ops,\n\t.video\t= &mt9v032_subdev_video_ops,\n\t.pad\t= &mt9v032_subdev_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops mt9v032_subdev_internal_ops = {\n\t.registered = mt9v032_registered,\n\t.open = mt9v032_open,\n\t.close = mt9v032_close,\n};\n\nstatic const struct regmap_config mt9v032_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = 0xff,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\n \n\nstatic struct mt9v032_platform_data *\nmt9v032_get_pdata(struct i2c_client *client)\n{\n\tstruct mt9v032_platform_data *pdata = NULL;\n\tstruct v4l2_fwnode_endpoint endpoint = { .bus_type = 0 };\n\tstruct device_node *np;\n\tstruct property *prop;\n\n\tif (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)\n\t\treturn client->dev.platform_data;\n\n\tnp = of_graph_get_next_endpoint(client->dev.of_node, NULL);\n\tif (!np)\n\t\treturn NULL;\n\n\tif (v4l2_fwnode_endpoint_parse(of_fwnode_handle(np), &endpoint) < 0)\n\t\tgoto done;\n\n\tpdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\tgoto done;\n\n\tprop = of_find_property(np, \"link-frequencies\", NULL);\n\tif (prop) {\n\t\tu64 *link_freqs;\n\t\tsize_t size = prop->length / sizeof(*link_freqs);\n\n\t\tlink_freqs = devm_kcalloc(&client->dev, size,\n\t\t\t\t\t  sizeof(*link_freqs), GFP_KERNEL);\n\t\tif (!link_freqs)\n\t\t\tgoto done;\n\n\t\tif (of_property_read_u64_array(np, \"link-frequencies\",\n\t\t\t\t\t       link_freqs, size) < 0)\n\t\t\tgoto done;\n\n\t\tpdata->link_freqs = link_freqs;\n\t\tpdata->link_def_freq = link_freqs[0];\n\t}\n\n\tpdata->clk_pol = !!(endpoint.bus.parallel.flags &\n\t\t\t    V4L2_MBUS_PCLK_SAMPLE_RISING);\n\ndone:\n\tof_node_put(np);\n\treturn pdata;\n}\n\nstatic int mt9v032_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *did = i2c_client_get_device_id(client);\n\tstruct mt9v032_platform_data *pdata = mt9v032_get_pdata(client);\n\tstruct mt9v032 *mt9v032;\n\tunsigned int i;\n\tint ret;\n\n\tmt9v032 = devm_kzalloc(&client->dev, sizeof(*mt9v032), GFP_KERNEL);\n\tif (!mt9v032)\n\t\treturn -ENOMEM;\n\n\tmt9v032->regmap = devm_regmap_init_i2c(client, &mt9v032_regmap_config);\n\tif (IS_ERR(mt9v032->regmap))\n\t\treturn PTR_ERR(mt9v032->regmap);\n\n\tmt9v032->clk = devm_clk_get(&client->dev, NULL);\n\tif (IS_ERR(mt9v032->clk))\n\t\treturn PTR_ERR(mt9v032->clk);\n\n\tmt9v032->reset_gpio = devm_gpiod_get_optional(&client->dev, \"reset\",\n\t\t\t\t\t\t      GPIOD_OUT_HIGH);\n\tif (IS_ERR(mt9v032->reset_gpio))\n\t\treturn PTR_ERR(mt9v032->reset_gpio);\n\n\tmt9v032->standby_gpio = devm_gpiod_get_optional(&client->dev, \"standby\",\n\t\t\t\t\t\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(mt9v032->standby_gpio))\n\t\treturn PTR_ERR(mt9v032->standby_gpio);\n\n\tmutex_init(&mt9v032->power_lock);\n\tmt9v032->pdata = pdata;\n\tmt9v032->model = (const void *)did->driver_data;\n\n\tv4l2_ctrl_handler_init(&mt9v032->ctrls, 11 +\n\t\t\t       ARRAY_SIZE(mt9v032_aegc_controls));\n\n\tv4l2_ctrl_new_std(&mt9v032->ctrls, &mt9v032_ctrl_ops,\n\t\t\t  V4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\tv4l2_ctrl_new_std(&mt9v032->ctrls, &mt9v032_ctrl_ops,\n\t\t\t  V4L2_CID_GAIN, MT9V032_ANALOG_GAIN_MIN,\n\t\t\t  MT9V032_ANALOG_GAIN_MAX, 1, MT9V032_ANALOG_GAIN_DEF);\n\tv4l2_ctrl_new_std_menu(&mt9v032->ctrls, &mt9v032_ctrl_ops,\n\t\t\t       V4L2_CID_EXPOSURE_AUTO, V4L2_EXPOSURE_MANUAL, 0,\n\t\t\t       V4L2_EXPOSURE_AUTO);\n\tv4l2_ctrl_new_std(&mt9v032->ctrls, &mt9v032_ctrl_ops,\n\t\t\t  V4L2_CID_EXPOSURE, mt9v032->model->data->min_shutter,\n\t\t\t  mt9v032->model->data->max_shutter, 1,\n\t\t\t  MT9V032_TOTAL_SHUTTER_WIDTH_DEF);\n\tv4l2_ctrl_new_std(&mt9v032->ctrls, &mt9v032_ctrl_ops,\n\t\t\t  V4L2_CID_HBLANK, mt9v032->model->data->min_hblank,\n\t\t\t  MT9V032_HORIZONTAL_BLANKING_MAX, 1,\n\t\t\t  MT9V032_HORIZONTAL_BLANKING_DEF);\n\tv4l2_ctrl_new_std(&mt9v032->ctrls, &mt9v032_ctrl_ops,\n\t\t\t  V4L2_CID_VBLANK, mt9v032->model->data->min_vblank,\n\t\t\t  mt9v032->model->data->max_vblank, 1,\n\t\t\t  MT9V032_VERTICAL_BLANKING_DEF);\n\tmt9v032->test_pattern = v4l2_ctrl_new_std_menu_items(&mt9v032->ctrls,\n\t\t\t\t&mt9v032_ctrl_ops, V4L2_CID_TEST_PATTERN,\n\t\t\t\tARRAY_SIZE(mt9v032_test_pattern_menu) - 1, 0, 0,\n\t\t\t\tmt9v032_test_pattern_menu);\n\tmt9v032->test_pattern_color = v4l2_ctrl_new_custom(&mt9v032->ctrls,\n\t\t\t\t      &mt9v032_test_pattern_color, NULL);\n\n\tv4l2_ctrl_new_custom(&mt9v032->ctrls,\n\t\t\t     mt9v032->model->data->aec_max_shutter_v4l2_ctrl,\n\t\t\t     NULL);\n\tfor (i = 0; i < ARRAY_SIZE(mt9v032_aegc_controls); ++i)\n\t\tv4l2_ctrl_new_custom(&mt9v032->ctrls, &mt9v032_aegc_controls[i],\n\t\t\t\t     NULL);\n\n\tv4l2_ctrl_cluster(2, &mt9v032->test_pattern);\n\n\tmt9v032->pixel_rate =\n\t\tv4l2_ctrl_new_std(&mt9v032->ctrls, &mt9v032_ctrl_ops,\n\t\t\t\t  V4L2_CID_PIXEL_RATE, 1, INT_MAX, 1, 1);\n\n\tif (pdata && pdata->link_freqs) {\n\t\tunsigned int def = 0;\n\n\t\tfor (i = 0; pdata->link_freqs[i]; ++i) {\n\t\t\tif (pdata->link_freqs[i] == pdata->link_def_freq)\n\t\t\t\tdef = i;\n\t\t}\n\n\t\tmt9v032->link_freq =\n\t\t\tv4l2_ctrl_new_int_menu(&mt9v032->ctrls,\n\t\t\t\t\t       &mt9v032_ctrl_ops,\n\t\t\t\t\t       V4L2_CID_LINK_FREQ, i - 1, def,\n\t\t\t\t\t       pdata->link_freqs);\n\t\tv4l2_ctrl_cluster(2, &mt9v032->link_freq);\n\t}\n\n\n\tmt9v032->subdev.ctrl_handler = &mt9v032->ctrls;\n\n\tif (mt9v032->ctrls.error) {\n\t\tdev_err(&client->dev, \"control initialization error %d\\n\",\n\t\t\tmt9v032->ctrls.error);\n\t\tret = mt9v032->ctrls.error;\n\t\tgoto err;\n\t}\n\n\tmt9v032->crop.left = MT9V032_COLUMN_START_DEF;\n\tmt9v032->crop.top = MT9V032_ROW_START_DEF;\n\tmt9v032->crop.width = MT9V032_WINDOW_WIDTH_DEF;\n\tmt9v032->crop.height = MT9V032_WINDOW_HEIGHT_DEF;\n\n\tif (mt9v032->model->color)\n\t\tmt9v032->format.code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\telse\n\t\tmt9v032->format.code = MEDIA_BUS_FMT_Y10_1X10;\n\n\tmt9v032->format.width = MT9V032_WINDOW_WIDTH_DEF;\n\tmt9v032->format.height = MT9V032_WINDOW_HEIGHT_DEF;\n\tmt9v032->format.field = V4L2_FIELD_NONE;\n\tmt9v032->format.colorspace = V4L2_COLORSPACE_SRGB;\n\n\tmt9v032->hratio = 1;\n\tmt9v032->vratio = 1;\n\n\tmt9v032->aec_agc = MT9V032_AEC_ENABLE | MT9V032_AGC_ENABLE;\n\tmt9v032->hblank = MT9V032_HORIZONTAL_BLANKING_DEF;\n\tmt9v032->sysclk = MT9V032_SYSCLK_FREQ_DEF;\n\n\tv4l2_i2c_subdev_init(&mt9v032->subdev, client, &mt9v032_subdev_ops);\n\tmt9v032->subdev.internal_ops = &mt9v032_subdev_internal_ops;\n\tmt9v032->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tmt9v032->subdev.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tmt9v032->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tret = media_entity_pads_init(&mt9v032->subdev.entity, 1, &mt9v032->pad);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tmt9v032->subdev.dev = &client->dev;\n\tret = v4l2_async_register_subdev(&mt9v032->subdev);\n\tif (ret < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tmedia_entity_cleanup(&mt9v032->subdev.entity);\n\tv4l2_ctrl_handler_free(&mt9v032->ctrls);\n\treturn ret;\n}\n\nstatic void mt9v032_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\n\n\tv4l2_async_unregister_subdev(subdev);\n\tv4l2_ctrl_handler_free(&mt9v032->ctrls);\n\tmedia_entity_cleanup(&subdev->entity);\n}\n\nstatic const struct mt9v032_model_data mt9v032_model_data[] = {\n\t{\n\t\t \n\t\t.min_row_time = 660,\n\t\t.min_hblank = MT9V032_HORIZONTAL_BLANKING_MIN,\n\t\t.min_vblank = MT9V032_VERTICAL_BLANKING_MIN,\n\t\t.max_vblank = MT9V032_VERTICAL_BLANKING_MAX,\n\t\t.min_shutter = MT9V032_TOTAL_SHUTTER_WIDTH_MIN,\n\t\t.max_shutter = MT9V032_TOTAL_SHUTTER_WIDTH_MAX,\n\t\t.pclk_reg = MT9V032_PIXEL_CLOCK,\n\t\t.aec_max_shutter_reg = MT9V032_AEC_MAX_SHUTTER_WIDTH,\n\t\t.aec_max_shutter_v4l2_ctrl = &mt9v032_aec_max_shutter_width,\n\t}, {\n\t\t \n\t\t.min_row_time = 690,\n\t\t.min_hblank = MT9V034_HORIZONTAL_BLANKING_MIN,\n\t\t.min_vblank = MT9V034_VERTICAL_BLANKING_MIN,\n\t\t.max_vblank = MT9V034_VERTICAL_BLANKING_MAX,\n\t\t.min_shutter = MT9V034_TOTAL_SHUTTER_WIDTH_MIN,\n\t\t.max_shutter = MT9V034_TOTAL_SHUTTER_WIDTH_MAX,\n\t\t.pclk_reg = MT9V034_PIXEL_CLOCK,\n\t\t.aec_max_shutter_reg = MT9V034_AEC_MAX_SHUTTER_WIDTH,\n\t\t.aec_max_shutter_v4l2_ctrl = &mt9v034_aec_max_shutter_width,\n\t},\n};\n\nstatic const struct mt9v032_model_info mt9v032_models[] = {\n\t[MT9V032_MODEL_V022_COLOR] = {\n\t\t.data = &mt9v032_model_data[0],\n\t\t.color = true,\n\t},\n\t[MT9V032_MODEL_V022_MONO] = {\n\t\t.data = &mt9v032_model_data[0],\n\t\t.color = false,\n\t},\n\t[MT9V032_MODEL_V024_COLOR] = {\n\t\t.data = &mt9v032_model_data[1],\n\t\t.color = true,\n\t},\n\t[MT9V032_MODEL_V024_MONO] = {\n\t\t.data = &mt9v032_model_data[1],\n\t\t.color = false,\n\t},\n\t[MT9V032_MODEL_V032_COLOR] = {\n\t\t.data = &mt9v032_model_data[0],\n\t\t.color = true,\n\t},\n\t[MT9V032_MODEL_V032_MONO] = {\n\t\t.data = &mt9v032_model_data[0],\n\t\t.color = false,\n\t},\n\t[MT9V032_MODEL_V034_COLOR] = {\n\t\t.data = &mt9v032_model_data[1],\n\t\t.color = true,\n\t},\n\t[MT9V032_MODEL_V034_MONO] = {\n\t\t.data = &mt9v032_model_data[1],\n\t\t.color = false,\n\t},\n};\n\nstatic const struct i2c_device_id mt9v032_id[] = {\n\t{ \"mt9v022\", (kernel_ulong_t)&mt9v032_models[MT9V032_MODEL_V022_COLOR] },\n\t{ \"mt9v022m\", (kernel_ulong_t)&mt9v032_models[MT9V032_MODEL_V022_MONO] },\n\t{ \"mt9v024\", (kernel_ulong_t)&mt9v032_models[MT9V032_MODEL_V024_COLOR] },\n\t{ \"mt9v024m\", (kernel_ulong_t)&mt9v032_models[MT9V032_MODEL_V024_MONO] },\n\t{ \"mt9v032\", (kernel_ulong_t)&mt9v032_models[MT9V032_MODEL_V032_COLOR] },\n\t{ \"mt9v032m\", (kernel_ulong_t)&mt9v032_models[MT9V032_MODEL_V032_MONO] },\n\t{ \"mt9v034\", (kernel_ulong_t)&mt9v032_models[MT9V032_MODEL_V034_COLOR] },\n\t{ \"mt9v034m\", (kernel_ulong_t)&mt9v032_models[MT9V032_MODEL_V034_MONO] },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, mt9v032_id);\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id mt9v032_of_match[] = {\n\t{ .compatible = \"aptina,mt9v022\" },\n\t{ .compatible = \"aptina,mt9v022m\" },\n\t{ .compatible = \"aptina,mt9v024\" },\n\t{ .compatible = \"aptina,mt9v024m\" },\n\t{ .compatible = \"aptina,mt9v032\" },\n\t{ .compatible = \"aptina,mt9v032m\" },\n\t{ .compatible = \"aptina,mt9v034\" },\n\t{ .compatible = \"aptina,mt9v034m\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mt9v032_of_match);\n#endif\n\nstatic struct i2c_driver mt9v032_driver = {\n\t.driver = {\n\t\t.name = \"mt9v032\",\n\t\t.of_match_table = of_match_ptr(mt9v032_of_match),\n\t},\n\t.probe\t\t= mt9v032_probe,\n\t.remove\t\t= mt9v032_remove,\n\t.id_table\t= mt9v032_id,\n};\n\nmodule_i2c_driver(mt9v032_driver);\n\nMODULE_DESCRIPTION(\"Aptina MT9V032 Camera driver\");\nMODULE_AUTHOR(\"Laurent Pinchart <laurent.pinchart@ideasonboard.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}