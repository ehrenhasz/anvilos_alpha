{
  "module_name": "cx25840-ir.c",
  "hash_id": "17519d679875f5c84ee6212eacce37963d682cee26ecbc9e0c97962cc7c355b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/cx25840/cx25840-ir.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/kfifo.h>\n#include <linux/module.h>\n#include <media/drv-intf/cx25840.h>\n#include <media/rc-core.h>\n\n#include \"cx25840-core.h\"\n\nstatic unsigned int ir_debug;\nmodule_param(ir_debug, int, 0644);\nMODULE_PARM_DESC(ir_debug, \"enable integrated IR debug messages\");\n\n#define CX25840_IR_REG_BASE\t0x200\n\n#define CX25840_IR_CNTRL_REG\t0x200\n#define CNTRL_WIN_3_3\t0x00000000\n#define CNTRL_WIN_4_3\t0x00000001\n#define CNTRL_WIN_3_4\t0x00000002\n#define CNTRL_WIN_4_4\t0x00000003\n#define CNTRL_WIN\t0x00000003\n#define CNTRL_EDG_NONE\t0x00000000\n#define CNTRL_EDG_FALL\t0x00000004\n#define CNTRL_EDG_RISE\t0x00000008\n#define CNTRL_EDG_BOTH\t0x0000000C\n#define CNTRL_EDG\t0x0000000C\n#define CNTRL_DMD\t0x00000010\n#define CNTRL_MOD\t0x00000020\n#define CNTRL_RFE\t0x00000040\n#define CNTRL_TFE\t0x00000080\n#define CNTRL_RXE\t0x00000100\n#define CNTRL_TXE\t0x00000200\n#define CNTRL_RIC\t0x00000400\n#define CNTRL_TIC\t0x00000800\n#define CNTRL_CPL\t0x00001000\n#define CNTRL_LBM\t0x00002000\n#define CNTRL_R\t\t0x00004000\n\n#define CX25840_IR_TXCLK_REG\t0x204\n#define TXCLK_TCD\t0x0000FFFF\n\n#define CX25840_IR_RXCLK_REG\t0x208\n#define RXCLK_RCD\t0x0000FFFF\n\n#define CX25840_IR_CDUTY_REG\t0x20C\n#define CDUTY_CDC\t0x0000000F\n\n#define CX25840_IR_STATS_REG\t0x210\n#define STATS_RTO\t0x00000001\n#define STATS_ROR\t0x00000002\n#define STATS_RBY\t0x00000004\n#define STATS_TBY\t0x00000008\n#define STATS_RSR\t0x00000010\n#define STATS_TSR\t0x00000020\n\n#define CX25840_IR_IRQEN_REG\t0x214\n#define IRQEN_RTE\t0x00000001\n#define IRQEN_ROE\t0x00000002\n#define IRQEN_RSE\t0x00000010\n#define IRQEN_TSE\t0x00000020\n#define IRQEN_MSK\t0x00000033\n\n#define CX25840_IR_FILTR_REG\t0x218\n#define FILTR_LPF\t0x0000FFFF\n\n#define CX25840_IR_FIFO_REG\t0x23C\n#define FIFO_RXTX\t0x0000FFFF\n#define FIFO_RXTX_LVL\t0x00010000\n#define FIFO_RXTX_RTO\t0x0001FFFF\n#define FIFO_RX_NDV\t0x00020000\n#define FIFO_RX_DEPTH\t8\n#define FIFO_TX_DEPTH\t8\n\n#define CX25840_VIDCLK_FREQ\t108000000  \n#define CX25840_IR_REFCLK_FREQ\t(CX25840_VIDCLK_FREQ / 2)\n\n \nunion cx25840_ir_fifo_rec {\n\tu32 hw_fifo_data;\n\tstruct ir_raw_event ir_core_data;\n};\n\n#define CX25840_IR_RX_KFIFO_SIZE    (256 * sizeof(union cx25840_ir_fifo_rec))\n#define CX25840_IR_TX_KFIFO_SIZE    (256 * sizeof(union cx25840_ir_fifo_rec))\n\nstruct cx25840_ir_state {\n\tstruct i2c_client *c;\n\n\tstruct v4l2_subdev_ir_parameters rx_params;\n\tstruct mutex rx_params_lock;  \n\tatomic_t rxclk_divider;\n\tatomic_t rx_invert;\n\n\tstruct kfifo rx_kfifo;\n\tspinlock_t rx_kfifo_lock;  \n\n\tstruct v4l2_subdev_ir_parameters tx_params;\n\tstruct mutex tx_params_lock;  \n\tatomic_t txclk_divider;\n};\n\nstatic inline struct cx25840_ir_state *to_ir_state(struct v4l2_subdev *sd)\n{\n\tstruct cx25840_state *state = to_state(sd);\n\treturn state ? state->ir_state : NULL;\n}\n\n\n \nstatic inline u16 count_to_clock_divider(unsigned int d)\n{\n\tif (d > RXCLK_RCD + 1)\n\t\td = RXCLK_RCD;\n\telse if (d < 2)\n\t\td = 1;\n\telse\n\t\td--;\n\treturn (u16) d;\n}\n\nstatic inline u16 carrier_freq_to_clock_divider(unsigned int freq)\n{\n\treturn count_to_clock_divider(\n\t\t\t  DIV_ROUND_CLOSEST(CX25840_IR_REFCLK_FREQ, freq * 16));\n}\n\nstatic inline unsigned int clock_divider_to_carrier_freq(unsigned int divider)\n{\n\treturn DIV_ROUND_CLOSEST(CX25840_IR_REFCLK_FREQ, (divider + 1) * 16);\n}\n\nstatic inline unsigned int clock_divider_to_freq(unsigned int divider,\n\t\t\t\t\t\t unsigned int rollovers)\n{\n\treturn DIV_ROUND_CLOSEST(CX25840_IR_REFCLK_FREQ,\n\t\t\t\t (divider + 1) * rollovers);\n}\n\n \nstatic inline u16 count_to_lpf_count(unsigned int d)\n{\n\tif (d > FILTR_LPF)\n\t\td = FILTR_LPF;\n\telse if (d < 4)\n\t\td = 0;\n\treturn (u16) d;\n}\n\nstatic inline u16 ns_to_lpf_count(unsigned int ns)\n{\n\treturn count_to_lpf_count(\n\t\tDIV_ROUND_CLOSEST(CX25840_IR_REFCLK_FREQ / 1000000 * ns, 1000));\n}\n\nstatic inline unsigned int lpf_count_to_ns(unsigned int count)\n{\n\t \n\treturn DIV_ROUND_CLOSEST(count * 1000,\n\t\t\t\t CX25840_IR_REFCLK_FREQ / 1000000);\n}\n\nstatic inline unsigned int lpf_count_to_us(unsigned int count)\n{\n\t \n\treturn DIV_ROUND_CLOSEST(count, CX25840_IR_REFCLK_FREQ / 1000000);\n}\n\n \nstatic u32 clock_divider_to_resolution(u16 divider)\n{\n\t \n\treturn DIV_ROUND_CLOSEST((1 << 2)  * ((u32) divider + 1) * 1000,\n\t\t\t\t CX25840_IR_REFCLK_FREQ / 1000000);\n}\n\nstatic u64 pulse_width_count_to_ns(u16 count, u16 divider)\n{\n\tu64 n;\n\tu32 rem;\n\n\t \n\tn = (((u64) count << 2) | 0x3) * (divider + 1) * 1000;  \n\trem = do_div(n, CX25840_IR_REFCLK_FREQ / 1000000);      \n\tif (rem >= CX25840_IR_REFCLK_FREQ / 1000000 / 2)\n\t\tn++;\n\treturn n;\n}\n\n#if 0\n \nstatic u16 ns_to_pulse_width_count(u32 ns, u16 divider)\n{\n\tu64 n;\n\tu32 d;\n\tu32 rem;\n\n\t \n\tn = ((u64) ns) * CX25840_IR_REFCLK_FREQ / 1000000;  \n\td = (1 << 2) * ((u32) divider + 1) * 1000;  \n\trem = do_div(n, d);\n\tif (rem >= d / 2)\n\t\tn++;\n\n\tif (n > FIFO_RXTX)\n\t\tn = FIFO_RXTX;\n\telse if (n == 0)\n\t\tn = 1;\n\treturn (u16) n;\n}\n\n#endif\nstatic unsigned int pulse_width_count_to_us(u16 count, u16 divider)\n{\n\tu64 n;\n\tu32 rem;\n\n\t \n\tn = (((u64) count << 2) | 0x3) * (divider + 1);     \n\trem = do_div(n, CX25840_IR_REFCLK_FREQ / 1000000);  \n\tif (rem >= CX25840_IR_REFCLK_FREQ / 1000000 / 2)\n\t\tn++;\n\treturn (unsigned int) n;\n}\n\n \nstatic u64 ns_to_pulse_clocks(u32 ns)\n{\n\tu64 clocks;\n\tu32 rem;\n\tclocks = CX25840_IR_REFCLK_FREQ / 1000000 * (u64) ns;  \n\trem = do_div(clocks, 1000);                          \n\tif (rem >= 1000 / 2)\n\t\tclocks++;\n\treturn clocks;\n}\n\nstatic u16 pulse_clocks_to_clock_divider(u64 count)\n{\n\tdo_div(count, (FIFO_RXTX << 2) | 0x3);\n\n\t \n\tif (count > RXCLK_RCD + 1)\n\t\tcount = RXCLK_RCD;\n\telse if (count < 2)\n\t\tcount = 1;\n\telse\n\t\tcount--;\n\treturn (u16) count;\n}\n\n \nenum tx_fifo_watermark {\n\tTX_FIFO_HALF_EMPTY = 0,\n\tTX_FIFO_EMPTY      = CNTRL_TIC,\n};\n\nenum rx_fifo_watermark {\n\tRX_FIFO_HALF_FULL = 0,\n\tRX_FIFO_NOT_EMPTY = CNTRL_RIC,\n};\n\nstatic inline void control_tx_irq_watermark(struct i2c_client *c,\n\t\t\t\t\t    enum tx_fifo_watermark level)\n{\n\tcx25840_and_or4(c, CX25840_IR_CNTRL_REG, ~CNTRL_TIC, level);\n}\n\nstatic inline void control_rx_irq_watermark(struct i2c_client *c,\n\t\t\t\t\t    enum rx_fifo_watermark level)\n{\n\tcx25840_and_or4(c, CX25840_IR_CNTRL_REG, ~CNTRL_RIC, level);\n}\n\nstatic inline void control_tx_enable(struct i2c_client *c, bool enable)\n{\n\tcx25840_and_or4(c, CX25840_IR_CNTRL_REG, ~(CNTRL_TXE | CNTRL_TFE),\n\t\t\tenable ? (CNTRL_TXE | CNTRL_TFE) : 0);\n}\n\nstatic inline void control_rx_enable(struct i2c_client *c, bool enable)\n{\n\tcx25840_and_or4(c, CX25840_IR_CNTRL_REG, ~(CNTRL_RXE | CNTRL_RFE),\n\t\t\tenable ? (CNTRL_RXE | CNTRL_RFE) : 0);\n}\n\nstatic inline void control_tx_modulation_enable(struct i2c_client *c,\n\t\t\t\t\t\tbool enable)\n{\n\tcx25840_and_or4(c, CX25840_IR_CNTRL_REG, ~CNTRL_MOD,\n\t\t\tenable ? CNTRL_MOD : 0);\n}\n\nstatic inline void control_rx_demodulation_enable(struct i2c_client *c,\n\t\t\t\t\t\t  bool enable)\n{\n\tcx25840_and_or4(c, CX25840_IR_CNTRL_REG, ~CNTRL_DMD,\n\t\t\tenable ? CNTRL_DMD : 0);\n}\n\nstatic inline void control_rx_s_edge_detection(struct i2c_client *c,\n\t\t\t\t\t       u32 edge_types)\n{\n\tcx25840_and_or4(c, CX25840_IR_CNTRL_REG, ~CNTRL_EDG_BOTH,\n\t\t\tedge_types & CNTRL_EDG_BOTH);\n}\n\nstatic void control_rx_s_carrier_window(struct i2c_client *c,\n\t\t\t\t\tunsigned int carrier,\n\t\t\t\t\tunsigned int *carrier_range_low,\n\t\t\t\t\tunsigned int *carrier_range_high)\n{\n\tu32 v;\n\tunsigned int c16 = carrier * 16;\n\n\tif (*carrier_range_low < DIV_ROUND_CLOSEST(c16, 16 + 3)) {\n\t\tv = CNTRL_WIN_3_4;\n\t\t*carrier_range_low = DIV_ROUND_CLOSEST(c16, 16 + 4);\n\t} else {\n\t\tv = CNTRL_WIN_3_3;\n\t\t*carrier_range_low = DIV_ROUND_CLOSEST(c16, 16 + 3);\n\t}\n\n\tif (*carrier_range_high > DIV_ROUND_CLOSEST(c16, 16 - 3)) {\n\t\tv |= CNTRL_WIN_4_3;\n\t\t*carrier_range_high = DIV_ROUND_CLOSEST(c16, 16 - 4);\n\t} else {\n\t\tv |= CNTRL_WIN_3_3;\n\t\t*carrier_range_high = DIV_ROUND_CLOSEST(c16, 16 - 3);\n\t}\n\tcx25840_and_or4(c, CX25840_IR_CNTRL_REG, ~CNTRL_WIN, v);\n}\n\nstatic inline void control_tx_polarity_invert(struct i2c_client *c,\n\t\t\t\t\t      bool invert)\n{\n\tcx25840_and_or4(c, CX25840_IR_CNTRL_REG, ~CNTRL_CPL,\n\t\t\tinvert ? CNTRL_CPL : 0);\n}\n\n \nstatic unsigned int txclk_tx_s_carrier(struct i2c_client *c,\n\t\t\t\t       unsigned int freq,\n\t\t\t\t       u16 *divider)\n{\n\t*divider = carrier_freq_to_clock_divider(freq);\n\tcx25840_write4(c, CX25840_IR_TXCLK_REG, *divider);\n\treturn clock_divider_to_carrier_freq(*divider);\n}\n\nstatic unsigned int rxclk_rx_s_carrier(struct i2c_client *c,\n\t\t\t\t       unsigned int freq,\n\t\t\t\t       u16 *divider)\n{\n\t*divider = carrier_freq_to_clock_divider(freq);\n\tcx25840_write4(c, CX25840_IR_RXCLK_REG, *divider);\n\treturn clock_divider_to_carrier_freq(*divider);\n}\n\nstatic u32 txclk_tx_s_max_pulse_width(struct i2c_client *c, u32 ns,\n\t\t\t\t      u16 *divider)\n{\n\tu64 pulse_clocks;\n\n\tif (ns > IR_MAX_DURATION)\n\t\tns = IR_MAX_DURATION;\n\tpulse_clocks = ns_to_pulse_clocks(ns);\n\t*divider = pulse_clocks_to_clock_divider(pulse_clocks);\n\tcx25840_write4(c, CX25840_IR_TXCLK_REG, *divider);\n\treturn (u32) pulse_width_count_to_ns(FIFO_RXTX, *divider);\n}\n\nstatic u32 rxclk_rx_s_max_pulse_width(struct i2c_client *c, u32 ns,\n\t\t\t\t      u16 *divider)\n{\n\tu64 pulse_clocks;\n\n\tif (ns > IR_MAX_DURATION)\n\t\tns = IR_MAX_DURATION;\n\tpulse_clocks = ns_to_pulse_clocks(ns);\n\t*divider = pulse_clocks_to_clock_divider(pulse_clocks);\n\tcx25840_write4(c, CX25840_IR_RXCLK_REG, *divider);\n\treturn (u32) pulse_width_count_to_ns(FIFO_RXTX, *divider);\n}\n\n \nstatic unsigned int cduty_tx_s_duty_cycle(struct i2c_client *c,\n\t\t\t\t\t  unsigned int duty_cycle)\n{\n\tu32 n;\n\tn = DIV_ROUND_CLOSEST(duty_cycle * 100, 625);  \n\tif (n != 0)\n\t\tn--;\n\tif (n > 15)\n\t\tn = 15;\n\tcx25840_write4(c, CX25840_IR_CDUTY_REG, n);\n\treturn DIV_ROUND_CLOSEST((n + 1) * 100, 16);\n}\n\n \nstatic u32 filter_rx_s_min_width(struct i2c_client *c, u32 min_width_ns)\n{\n\tu32 count = ns_to_lpf_count(min_width_ns);\n\tcx25840_write4(c, CX25840_IR_FILTR_REG, count);\n\treturn lpf_count_to_ns(count);\n}\n\n \nstatic inline void irqenable_rx(struct v4l2_subdev *sd, u32 mask)\n{\n\tstruct cx25840_state *state = to_state(sd);\n\n\tif (is_cx23885(state) || is_cx23887(state))\n\t\tmask ^= IRQEN_MSK;\n\tmask &= (IRQEN_RTE | IRQEN_ROE | IRQEN_RSE);\n\tcx25840_and_or4(state->c, CX25840_IR_IRQEN_REG,\n\t\t\t~(IRQEN_RTE | IRQEN_ROE | IRQEN_RSE), mask);\n}\n\nstatic inline void irqenable_tx(struct v4l2_subdev *sd, u32 mask)\n{\n\tstruct cx25840_state *state = to_state(sd);\n\n\tif (is_cx23885(state) || is_cx23887(state))\n\t\tmask ^= IRQEN_MSK;\n\tmask &= IRQEN_TSE;\n\tcx25840_and_or4(state->c, CX25840_IR_IRQEN_REG, ~IRQEN_TSE, mask);\n}\n\n \nint cx25840_ir_irq_handler(struct v4l2_subdev *sd, u32 status, bool *handled)\n{\n\tstruct cx25840_state *state = to_state(sd);\n\tstruct cx25840_ir_state *ir_state = to_ir_state(sd);\n\tstruct i2c_client *c = NULL;\n\tunsigned long flags;\n\n\tunion cx25840_ir_fifo_rec rx_data[FIFO_RX_DEPTH];\n\tunsigned int i, j, k;\n\tu32 events, v;\n\tint tsr, rsr, rto, ror, tse, rse, rte, roe, kror;\n\tu32 cntrl, irqen, stats;\n\n\t*handled = false;\n\tif (ir_state == NULL)\n\t\treturn -ENODEV;\n\n\tc = ir_state->c;\n\n\t \n\tif (!(is_cx23885(state) || is_cx23887(state)))\n\t\treturn -ENODEV;\n\n\tcntrl = cx25840_read4(c, CX25840_IR_CNTRL_REG);\n\tirqen = cx25840_read4(c, CX25840_IR_IRQEN_REG);\n\tif (is_cx23885(state) || is_cx23887(state))\n\t\tirqen ^= IRQEN_MSK;\n\tstats = cx25840_read4(c, CX25840_IR_STATS_REG);\n\n\ttsr = stats & STATS_TSR;  \n\trsr = stats & STATS_RSR;  \n\trto = stats & STATS_RTO;  \n\tror = stats & STATS_ROR;  \n\n\ttse = irqen & IRQEN_TSE;  \n\trse = irqen & IRQEN_RSE;  \n\trte = irqen & IRQEN_RTE;  \n\troe = irqen & IRQEN_ROE;  \n\n\tv4l2_dbg(2, ir_debug, sd, \"IR IRQ Status:  %s %s %s %s %s %s\\n\",\n\t\t tsr ? \"tsr\" : \"   \", rsr ? \"rsr\" : \"   \",\n\t\t rto ? \"rto\" : \"   \", ror ? \"ror\" : \"   \",\n\t\t stats & STATS_TBY ? \"tby\" : \"   \",\n\t\t stats & STATS_RBY ? \"rby\" : \"   \");\n\n\tv4l2_dbg(2, ir_debug, sd, \"IR IRQ Enables: %s %s %s %s\\n\",\n\t\t tse ? \"tse\" : \"   \", rse ? \"rse\" : \"   \",\n\t\t rte ? \"rte\" : \"   \", roe ? \"roe\" : \"   \");\n\n\t \n\tif (tse && tsr) {\n\t\t \n\t\t \n\t\tirqenable_tx(sd, 0);\n\t\tevents = V4L2_SUBDEV_IR_TX_FIFO_SERVICE_REQ;\n\t\tv4l2_subdev_notify(sd, V4L2_SUBDEV_IR_TX_NOTIFY, &events);\n\t\t*handled = true;\n\t}\n\n\t \n\tkror = 0;\n\tif ((rse && rsr) || (rte && rto)) {\n\t\t \n\t\tfor (i = 0, v = FIFO_RX_NDV;\n\t\t     (v & FIFO_RX_NDV) && !kror; i = 0) {\n\t\t\tfor (j = 0;\n\t\t\t     (v & FIFO_RX_NDV) && j < FIFO_RX_DEPTH; j++) {\n\t\t\t\tv = cx25840_read4(c, CX25840_IR_FIFO_REG);\n\t\t\t\trx_data[i].hw_fifo_data = v & ~FIFO_RX_NDV;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i == 0)\n\t\t\t\tbreak;\n\t\t\tj = i * sizeof(union cx25840_ir_fifo_rec);\n\t\t\tk = kfifo_in_locked(&ir_state->rx_kfifo,\n\t\t\t\t\t    (unsigned char *) rx_data, j,\n\t\t\t\t\t    &ir_state->rx_kfifo_lock);\n\t\t\tif (k != j)\n\t\t\t\tkror++;  \n\t\t}\n\t\t*handled = true;\n\t}\n\n\tevents = 0;\n\tv = 0;\n\tif (kror) {\n\t\tevents |= V4L2_SUBDEV_IR_RX_SW_FIFO_OVERRUN;\n\t\tv4l2_err(sd, \"IR receiver software FIFO overrun\\n\");\n\t}\n\tif (roe && ror) {\n\t\t \n\t\tv |= CNTRL_RFE;\n\t\tevents |= V4L2_SUBDEV_IR_RX_HW_FIFO_OVERRUN;\n\t\tv4l2_err(sd, \"IR receiver hardware FIFO overrun\\n\");\n\t}\n\tif (rte && rto) {\n\t\t \n\t\tv |= CNTRL_RXE;\n\t\tevents |= V4L2_SUBDEV_IR_RX_END_OF_RX_DETECTED;\n\t}\n\tif (v) {\n\t\t \n\t\tcx25840_write4(c, CX25840_IR_CNTRL_REG, cntrl & ~v);\n\t\tcx25840_write4(c, CX25840_IR_CNTRL_REG, cntrl);\n\t\t*handled = true;\n\t}\n\tspin_lock_irqsave(&ir_state->rx_kfifo_lock, flags);\n\tif (kfifo_len(&ir_state->rx_kfifo) >= CX25840_IR_RX_KFIFO_SIZE / 2)\n\t\tevents |= V4L2_SUBDEV_IR_RX_FIFO_SERVICE_REQ;\n\tspin_unlock_irqrestore(&ir_state->rx_kfifo_lock, flags);\n\n\tif (events)\n\t\tv4l2_subdev_notify(sd, V4L2_SUBDEV_IR_RX_NOTIFY, &events);\n\treturn 0;\n}\n\n \nstatic int cx25840_ir_rx_read(struct v4l2_subdev *sd, u8 *buf, size_t count,\n\t\t\t      ssize_t *num)\n{\n\tstruct cx25840_ir_state *ir_state = to_ir_state(sd);\n\tbool invert;\n\tu16 divider;\n\tunsigned int i, n;\n\tunion cx25840_ir_fifo_rec *p;\n\tunsigned u, v, w;\n\n\tif (ir_state == NULL)\n\t\treturn -ENODEV;\n\n\tinvert = (bool) atomic_read(&ir_state->rx_invert);\n\tdivider = (u16) atomic_read(&ir_state->rxclk_divider);\n\n\tn = count / sizeof(union cx25840_ir_fifo_rec)\n\t\t* sizeof(union cx25840_ir_fifo_rec);\n\tif (n == 0) {\n\t\t*num = 0;\n\t\treturn 0;\n\t}\n\n\tn = kfifo_out_locked(&ir_state->rx_kfifo, buf, n,\n\t\t\t     &ir_state->rx_kfifo_lock);\n\n\tn /= sizeof(union cx25840_ir_fifo_rec);\n\t*num = n * sizeof(union cx25840_ir_fifo_rec);\n\n\tfor (p = (union cx25840_ir_fifo_rec *) buf, i = 0; i < n; p++, i++) {\n\n\t\tif ((p->hw_fifo_data & FIFO_RXTX_RTO) == FIFO_RXTX_RTO) {\n\t\t\t \n\t\t\tu = 0;\n\t\t\tw = 1;\n\t\t} else {\n\t\t\tu = (p->hw_fifo_data & FIFO_RXTX_LVL) ? 1 : 0;\n\t\t\tif (invert)\n\t\t\t\tu = u ? 0 : 1;\n\t\t\tw = 0;\n\t\t}\n\n\t\tv = (unsigned) pulse_width_count_to_ns(\n\t\t\t\t  (u16)(p->hw_fifo_data & FIFO_RXTX), divider) / 1000;\n\t\tif (v > IR_MAX_DURATION)\n\t\t\tv = IR_MAX_DURATION;\n\n\t\tp->ir_core_data = (struct ir_raw_event)\n\t\t\t{ .pulse = u, .duration = v, .timeout = w };\n\n\t\tv4l2_dbg(2, ir_debug, sd, \"rx read: %10u ns  %s  %s\\n\",\n\t\t\t v, u ? \"mark\" : \"space\", w ? \"(timed out)\" : \"\");\n\t\tif (w)\n\t\t\tv4l2_dbg(2, ir_debug, sd, \"rx read: end of rx\\n\");\n\t}\n\treturn 0;\n}\n\nstatic int cx25840_ir_rx_g_parameters(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_ir_parameters *p)\n{\n\tstruct cx25840_ir_state *ir_state = to_ir_state(sd);\n\n\tif (ir_state == NULL)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ir_state->rx_params_lock);\n\tmemcpy(p, &ir_state->rx_params,\n\t\t\t\t      sizeof(struct v4l2_subdev_ir_parameters));\n\tmutex_unlock(&ir_state->rx_params_lock);\n\treturn 0;\n}\n\nstatic int cx25840_ir_rx_shutdown(struct v4l2_subdev *sd)\n{\n\tstruct cx25840_ir_state *ir_state = to_ir_state(sd);\n\tstruct i2c_client *c;\n\n\tif (ir_state == NULL)\n\t\treturn -ENODEV;\n\n\tc = ir_state->c;\n\tmutex_lock(&ir_state->rx_params_lock);\n\n\t \n\tirqenable_rx(sd, 0);\n\tcontrol_rx_enable(c, false);\n\tcontrol_rx_demodulation_enable(c, false);\n\tcontrol_rx_s_edge_detection(c, CNTRL_EDG_NONE);\n\tfilter_rx_s_min_width(c, 0);\n\tcx25840_write4(c, CX25840_IR_RXCLK_REG, RXCLK_RCD);\n\n\tir_state->rx_params.shutdown = true;\n\n\tmutex_unlock(&ir_state->rx_params_lock);\n\treturn 0;\n}\n\nstatic int cx25840_ir_rx_s_parameters(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_ir_parameters *p)\n{\n\tstruct cx25840_ir_state *ir_state = to_ir_state(sd);\n\tstruct i2c_client *c;\n\tstruct v4l2_subdev_ir_parameters *o;\n\tu16 rxclk_divider;\n\n\tif (ir_state == NULL)\n\t\treturn -ENODEV;\n\n\tif (p->shutdown)\n\t\treturn cx25840_ir_rx_shutdown(sd);\n\n\tif (p->mode != V4L2_SUBDEV_IR_MODE_PULSE_WIDTH)\n\t\treturn -ENOSYS;\n\n\tc = ir_state->c;\n\to = &ir_state->rx_params;\n\n\tmutex_lock(&ir_state->rx_params_lock);\n\n\to->shutdown = p->shutdown;\n\n\tp->mode = V4L2_SUBDEV_IR_MODE_PULSE_WIDTH;\n\to->mode = p->mode;\n\n\tp->bytes_per_data_element = sizeof(union cx25840_ir_fifo_rec);\n\to->bytes_per_data_element = p->bytes_per_data_element;\n\n\t \n\tirqenable_rx(sd, 0);\n\tcontrol_rx_enable(c, false);\n\n\tcontrol_rx_demodulation_enable(c, p->modulation);\n\to->modulation = p->modulation;\n\n\tif (p->modulation) {\n\t\tp->carrier_freq = rxclk_rx_s_carrier(c, p->carrier_freq,\n\t\t\t\t\t\t     &rxclk_divider);\n\n\t\to->carrier_freq = p->carrier_freq;\n\n\t\tp->duty_cycle = 50;\n\t\to->duty_cycle = p->duty_cycle;\n\n\t\tcontrol_rx_s_carrier_window(c, p->carrier_freq,\n\t\t\t\t\t    &p->carrier_range_lower,\n\t\t\t\t\t    &p->carrier_range_upper);\n\t\to->carrier_range_lower = p->carrier_range_lower;\n\t\to->carrier_range_upper = p->carrier_range_upper;\n\n\t\tp->max_pulse_width =\n\t\t\t(u32) pulse_width_count_to_ns(FIFO_RXTX, rxclk_divider);\n\t} else {\n\t\tp->max_pulse_width =\n\t\t\t    rxclk_rx_s_max_pulse_width(c, p->max_pulse_width,\n\t\t\t\t\t\t       &rxclk_divider);\n\t}\n\to->max_pulse_width = p->max_pulse_width;\n\tatomic_set(&ir_state->rxclk_divider, rxclk_divider);\n\n\tp->noise_filter_min_width =\n\t\t\t    filter_rx_s_min_width(c, p->noise_filter_min_width);\n\to->noise_filter_min_width = p->noise_filter_min_width;\n\n\tp->resolution = clock_divider_to_resolution(rxclk_divider);\n\to->resolution = p->resolution;\n\n\t \n\tcontrol_rx_irq_watermark(c, RX_FIFO_HALF_FULL);\n\n\tcontrol_rx_s_edge_detection(c, CNTRL_EDG_BOTH);\n\n\to->invert_level = p->invert_level;\n\tatomic_set(&ir_state->rx_invert, p->invert_level);\n\n\to->interrupt_enable = p->interrupt_enable;\n\to->enable = p->enable;\n\tif (p->enable) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&ir_state->rx_kfifo_lock, flags);\n\t\tkfifo_reset(&ir_state->rx_kfifo);\n\t\tspin_unlock_irqrestore(&ir_state->rx_kfifo_lock, flags);\n\t\tif (p->interrupt_enable)\n\t\t\tirqenable_rx(sd, IRQEN_RSE | IRQEN_RTE | IRQEN_ROE);\n\t\tcontrol_rx_enable(c, p->enable);\n\t}\n\n\tmutex_unlock(&ir_state->rx_params_lock);\n\treturn 0;\n}\n\n \nstatic int cx25840_ir_tx_write(struct v4l2_subdev *sd, u8 *buf, size_t count,\n\t\t\t       ssize_t *num)\n{\n\tstruct cx25840_ir_state *ir_state = to_ir_state(sd);\n\n\tif (ir_state == NULL)\n\t\treturn -ENODEV;\n\n#if 0\n\t \n\tu32 *ns_pulse = (u32 *) buf;\n\tunsigned int n;\n\tu32 fifo_pulse[FIFO_TX_DEPTH];\n\tu32 mark;\n\n\t \n\tn = CX25840_IR_TX_KFIFO_SIZE - kfifo_len(ir_state->tx_kfifo);\n\tn = min(n, (unsigned int) count);\n\tn /= sizeof(u32);\n\n\t \n\tfor (i = 0; i < n; ) {\n\t\tfor (j = 0; j < FIFO_TX_DEPTH / 2 && i < n; j++) {\n\t\t\tmark = ns_pulse[i] & LEVEL_MASK;\n\t\t\tfifo_pulse[j] = ns_to_pulse_width_count(\n\t\t\t\t\t ns_pulse[i] &\n\t\t\t\t\t       ~LEVEL_MASK,\n\t\t\t\t\t ir_state->txclk_divider);\n\t\t\tif (mark)\n\t\t\t\tfifo_pulse[j] &= FIFO_RXTX_LVL;\n\t\t\ti++;\n\t\t}\n\t\tkfifo_put(ir_state->tx_kfifo, (u8 *) fifo_pulse,\n\t\t\t\t\t\t\t       j * sizeof(u32));\n\t}\n\t*num = n * sizeof(u32);\n#else\n\t \n\tirqenable_tx(sd, IRQEN_TSE);\n\t*num = count;\n#endif\n\treturn 0;\n}\n\nstatic int cx25840_ir_tx_g_parameters(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_ir_parameters *p)\n{\n\tstruct cx25840_ir_state *ir_state = to_ir_state(sd);\n\n\tif (ir_state == NULL)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ir_state->tx_params_lock);\n\tmemcpy(p, &ir_state->tx_params,\n\t\t\t\t      sizeof(struct v4l2_subdev_ir_parameters));\n\tmutex_unlock(&ir_state->tx_params_lock);\n\treturn 0;\n}\n\nstatic int cx25840_ir_tx_shutdown(struct v4l2_subdev *sd)\n{\n\tstruct cx25840_ir_state *ir_state = to_ir_state(sd);\n\tstruct i2c_client *c;\n\n\tif (ir_state == NULL)\n\t\treturn -ENODEV;\n\n\tc = ir_state->c;\n\tmutex_lock(&ir_state->tx_params_lock);\n\n\t \n\tirqenable_tx(sd, 0);\n\tcontrol_tx_enable(c, false);\n\tcontrol_tx_modulation_enable(c, false);\n\tcx25840_write4(c, CX25840_IR_TXCLK_REG, TXCLK_TCD);\n\n\tir_state->tx_params.shutdown = true;\n\n\tmutex_unlock(&ir_state->tx_params_lock);\n\treturn 0;\n}\n\nstatic int cx25840_ir_tx_s_parameters(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_ir_parameters *p)\n{\n\tstruct cx25840_ir_state *ir_state = to_ir_state(sd);\n\tstruct i2c_client *c;\n\tstruct v4l2_subdev_ir_parameters *o;\n\tu16 txclk_divider;\n\n\tif (ir_state == NULL)\n\t\treturn -ENODEV;\n\n\tif (p->shutdown)\n\t\treturn cx25840_ir_tx_shutdown(sd);\n\n\tif (p->mode != V4L2_SUBDEV_IR_MODE_PULSE_WIDTH)\n\t\treturn -ENOSYS;\n\n\tc = ir_state->c;\n\to = &ir_state->tx_params;\n\tmutex_lock(&ir_state->tx_params_lock);\n\n\to->shutdown = p->shutdown;\n\n\tp->mode = V4L2_SUBDEV_IR_MODE_PULSE_WIDTH;\n\to->mode = p->mode;\n\n\tp->bytes_per_data_element = sizeof(union cx25840_ir_fifo_rec);\n\to->bytes_per_data_element = p->bytes_per_data_element;\n\n\t \n\tirqenable_tx(sd, 0);\n\tcontrol_tx_enable(c, false);\n\n\tcontrol_tx_modulation_enable(c, p->modulation);\n\to->modulation = p->modulation;\n\n\tif (p->modulation) {\n\t\tp->carrier_freq = txclk_tx_s_carrier(c, p->carrier_freq,\n\t\t\t\t\t\t     &txclk_divider);\n\t\to->carrier_freq = p->carrier_freq;\n\n\t\tp->duty_cycle = cduty_tx_s_duty_cycle(c, p->duty_cycle);\n\t\to->duty_cycle = p->duty_cycle;\n\n\t\tp->max_pulse_width =\n\t\t\t(u32) pulse_width_count_to_ns(FIFO_RXTX, txclk_divider);\n\t} else {\n\t\tp->max_pulse_width =\n\t\t\t    txclk_tx_s_max_pulse_width(c, p->max_pulse_width,\n\t\t\t\t\t\t       &txclk_divider);\n\t}\n\to->max_pulse_width = p->max_pulse_width;\n\tatomic_set(&ir_state->txclk_divider, txclk_divider);\n\n\tp->resolution = clock_divider_to_resolution(txclk_divider);\n\to->resolution = p->resolution;\n\n\t \n\tcontrol_tx_irq_watermark(c, TX_FIFO_HALF_EMPTY);\n\n\tcontrol_tx_polarity_invert(c, p->invert_carrier_sense);\n\to->invert_carrier_sense = p->invert_carrier_sense;\n\n\t \n\to->invert_level = p->invert_level;\n\n\to->interrupt_enable = p->interrupt_enable;\n\to->enable = p->enable;\n\tif (p->enable) {\n\t\t \n\t\tif (p->interrupt_enable)\n\t\t\tirqenable_tx(sd, IRQEN_TSE);\n\t\tcontrol_tx_enable(c, p->enable);\n\t}\n\n\tmutex_unlock(&ir_state->tx_params_lock);\n\treturn 0;\n}\n\n\n \nint cx25840_ir_log_status(struct v4l2_subdev *sd)\n{\n\tstruct cx25840_state *state = to_state(sd);\n\tstruct i2c_client *c = state->c;\n\tchar *s;\n\tint i, j;\n\tu32 cntrl, txclk, rxclk, cduty, stats, irqen, filtr;\n\n\t \n\tif (is_cx23888(state))\n\t\treturn 0;\n\n\tcntrl = cx25840_read4(c, CX25840_IR_CNTRL_REG);\n\ttxclk = cx25840_read4(c, CX25840_IR_TXCLK_REG) & TXCLK_TCD;\n\trxclk = cx25840_read4(c, CX25840_IR_RXCLK_REG) & RXCLK_RCD;\n\tcduty = cx25840_read4(c, CX25840_IR_CDUTY_REG) & CDUTY_CDC;\n\tstats = cx25840_read4(c, CX25840_IR_STATS_REG);\n\tirqen = cx25840_read4(c, CX25840_IR_IRQEN_REG);\n\tif (is_cx23885(state) || is_cx23887(state))\n\t\tirqen ^= IRQEN_MSK;\n\tfiltr = cx25840_read4(c, CX25840_IR_FILTR_REG) & FILTR_LPF;\n\n\tv4l2_info(sd, \"IR Receiver:\\n\");\n\tv4l2_info(sd, \"\\tEnabled:                           %s\\n\",\n\t\t  cntrl & CNTRL_RXE ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tDemodulation from a carrier:       %s\\n\",\n\t\t  cntrl & CNTRL_DMD ? \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"\\tFIFO:                              %s\\n\",\n\t\t  cntrl & CNTRL_RFE ? \"enabled\" : \"disabled\");\n\tswitch (cntrl & CNTRL_EDG) {\n\tcase CNTRL_EDG_NONE:\n\t\ts = \"disabled\";\n\t\tbreak;\n\tcase CNTRL_EDG_FALL:\n\t\ts = \"falling edge\";\n\t\tbreak;\n\tcase CNTRL_EDG_RISE:\n\t\ts = \"rising edge\";\n\t\tbreak;\n\tcase CNTRL_EDG_BOTH:\n\t\ts = \"rising & falling edges\";\n\t\tbreak;\n\tdefault:\n\t\ts = \"??? edge\";\n\t\tbreak;\n\t}\n\tv4l2_info(sd, \"\\tPulse timers' start/stop trigger:  %s\\n\", s);\n\tv4l2_info(sd, \"\\tFIFO data on pulse timer overflow: %s\\n\",\n\t\t  cntrl & CNTRL_R ? \"not loaded\" : \"overflow marker\");\n\tv4l2_info(sd, \"\\tFIFO interrupt watermark:          %s\\n\",\n\t\t  cntrl & CNTRL_RIC ? \"not empty\" : \"half full or greater\");\n\tv4l2_info(sd, \"\\tLoopback mode:                     %s\\n\",\n\t\t  cntrl & CNTRL_LBM ? \"loopback active\" : \"normal receive\");\n\tif (cntrl & CNTRL_DMD) {\n\t\tv4l2_info(sd, \"\\tExpected carrier (16 clocks):      %u Hz\\n\",\n\t\t\t  clock_divider_to_carrier_freq(rxclk));\n\t\tswitch (cntrl & CNTRL_WIN) {\n\t\tcase CNTRL_WIN_3_3:\n\t\t\ti = 3;\n\t\t\tj = 3;\n\t\t\tbreak;\n\t\tcase CNTRL_WIN_4_3:\n\t\t\ti = 4;\n\t\t\tj = 3;\n\t\t\tbreak;\n\t\tcase CNTRL_WIN_3_4:\n\t\t\ti = 3;\n\t\t\tj = 4;\n\t\t\tbreak;\n\t\tcase CNTRL_WIN_4_4:\n\t\t\ti = 4;\n\t\t\tj = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ti = 0;\n\t\t\tj = 0;\n\t\t\tbreak;\n\t\t}\n\t\tv4l2_info(sd, \"\\tNext carrier edge window:\t    16 clocks -%1d/+%1d, %u to %u Hz\\n\",\n\t\t\t  i, j,\n\t\t\t  clock_divider_to_freq(rxclk, 16 + j),\n\t\t\t  clock_divider_to_freq(rxclk, 16 - i));\n\t}\n\tv4l2_info(sd, \"\\tMax measurable pulse width:        %u us, %llu ns\\n\",\n\t\t  pulse_width_count_to_us(FIFO_RXTX, rxclk),\n\t\t  pulse_width_count_to_ns(FIFO_RXTX, rxclk));\n\tv4l2_info(sd, \"\\tLow pass filter:                   %s\\n\",\n\t\t  filtr ? \"enabled\" : \"disabled\");\n\tif (filtr)\n\t\tv4l2_info(sd, \"\\tMin acceptable pulse width (LPF):  %u us, %u ns\\n\",\n\t\t\t  lpf_count_to_us(filtr),\n\t\t\t  lpf_count_to_ns(filtr));\n\tv4l2_info(sd, \"\\tPulse width timer timed-out:       %s\\n\",\n\t\t  stats & STATS_RTO ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tPulse width timer time-out intr:   %s\\n\",\n\t\t  irqen & IRQEN_RTE ? \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"\\tFIFO overrun:                      %s\\n\",\n\t\t  stats & STATS_ROR ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tFIFO overrun interrupt:            %s\\n\",\n\t\t  irqen & IRQEN_ROE ? \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"\\tBusy:                              %s\\n\",\n\t\t  stats & STATS_RBY ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tFIFO service requested:            %s\\n\",\n\t\t  stats & STATS_RSR ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tFIFO service request interrupt:    %s\\n\",\n\t\t  irqen & IRQEN_RSE ? \"enabled\" : \"disabled\");\n\n\tv4l2_info(sd, \"IR Transmitter:\\n\");\n\tv4l2_info(sd, \"\\tEnabled:                           %s\\n\",\n\t\t  cntrl & CNTRL_TXE ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tModulation onto a carrier:         %s\\n\",\n\t\t  cntrl & CNTRL_MOD ? \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"\\tFIFO:                              %s\\n\",\n\t\t  cntrl & CNTRL_TFE ? \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"\\tFIFO interrupt watermark:          %s\\n\",\n\t\t  cntrl & CNTRL_TIC ? \"not empty\" : \"half full or less\");\n\tv4l2_info(sd, \"\\tCarrier polarity:                  %s\\n\",\n\t\t  cntrl & CNTRL_CPL ? \"space:burst mark:noburst\"\n\t\t\t\t    : \"space:noburst mark:burst\");\n\tif (cntrl & CNTRL_MOD) {\n\t\tv4l2_info(sd, \"\\tCarrier (16 clocks):               %u Hz\\n\",\n\t\t\t  clock_divider_to_carrier_freq(txclk));\n\t\tv4l2_info(sd, \"\\tCarrier duty cycle:                %2u/16\\n\",\n\t\t\t  cduty + 1);\n\t}\n\tv4l2_info(sd, \"\\tMax pulse width:                   %u us, %llu ns\\n\",\n\t\t  pulse_width_count_to_us(FIFO_RXTX, txclk),\n\t\t  pulse_width_count_to_ns(FIFO_RXTX, txclk));\n\tv4l2_info(sd, \"\\tBusy:                              %s\\n\",\n\t\t  stats & STATS_TBY ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tFIFO service requested:            %s\\n\",\n\t\t  stats & STATS_TSR ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"\\tFIFO service request interrupt:    %s\\n\",\n\t\t  irqen & IRQEN_TSE ? \"enabled\" : \"disabled\");\n\n\treturn 0;\n}\n\n\nconst struct v4l2_subdev_ir_ops cx25840_ir_ops = {\n\t.rx_read = cx25840_ir_rx_read,\n\t.rx_g_parameters = cx25840_ir_rx_g_parameters,\n\t.rx_s_parameters = cx25840_ir_rx_s_parameters,\n\n\t.tx_write = cx25840_ir_tx_write,\n\t.tx_g_parameters = cx25840_ir_tx_g_parameters,\n\t.tx_s_parameters = cx25840_ir_tx_s_parameters,\n};\n\n\nstatic const struct v4l2_subdev_ir_parameters default_rx_params = {\n\t.bytes_per_data_element = sizeof(union cx25840_ir_fifo_rec),\n\t.mode = V4L2_SUBDEV_IR_MODE_PULSE_WIDTH,\n\n\t.enable = false,\n\t.interrupt_enable = false,\n\t.shutdown = true,\n\n\t.modulation = true,\n\t.carrier_freq = 36000,  \n\n\t \n\t \n\t.noise_filter_min_width = 333333,  \n\t.carrier_range_lower = 35000,\n\t.carrier_range_upper = 37000,\n\t.invert_level = false,\n};\n\nstatic const struct v4l2_subdev_ir_parameters default_tx_params = {\n\t.bytes_per_data_element = sizeof(union cx25840_ir_fifo_rec),\n\t.mode = V4L2_SUBDEV_IR_MODE_PULSE_WIDTH,\n\n\t.enable = false,\n\t.interrupt_enable = false,\n\t.shutdown = true,\n\n\t.modulation = true,\n\t.carrier_freq = 36000,  \n\t.duty_cycle = 25,       \n\t.invert_level = false,\n\t.invert_carrier_sense = false,\n};\n\nint cx25840_ir_probe(struct v4l2_subdev *sd)\n{\n\tstruct cx25840_state *state = to_state(sd);\n\tstruct cx25840_ir_state *ir_state;\n\tstruct v4l2_subdev_ir_parameters default_params;\n\n\t \n\tif (!(is_cx23885(state) || is_cx23887(state)))\n\t\treturn 0;\n\n\tir_state = devm_kzalloc(&state->c->dev, sizeof(*ir_state), GFP_KERNEL);\n\tif (ir_state == NULL)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&ir_state->rx_kfifo_lock);\n\tif (kfifo_alloc(&ir_state->rx_kfifo,\n\t\t\tCX25840_IR_RX_KFIFO_SIZE, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tir_state->c = state->c;\n\tstate->ir_state = ir_state;\n\n\t \n\tif (is_cx23885(state) || is_cx23887(state))\n\t\tcx25840_write4(ir_state->c, CX25840_IR_IRQEN_REG, IRQEN_MSK);\n\telse\n\t\tcx25840_write4(ir_state->c, CX25840_IR_IRQEN_REG, 0);\n\n\tmutex_init(&ir_state->rx_params_lock);\n\tdefault_params = default_rx_params;\n\tv4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);\n\n\tmutex_init(&ir_state->tx_params_lock);\n\tdefault_params = default_tx_params;\n\tv4l2_subdev_call(sd, ir, tx_s_parameters, &default_params);\n\n\treturn 0;\n}\n\nint cx25840_ir_remove(struct v4l2_subdev *sd)\n{\n\tstruct cx25840_state *state = to_state(sd);\n\tstruct cx25840_ir_state *ir_state = to_ir_state(sd);\n\n\tif (ir_state == NULL)\n\t\treturn -ENODEV;\n\n\tcx25840_ir_rx_shutdown(sd);\n\tcx25840_ir_tx_shutdown(sd);\n\n\tkfifo_free(&ir_state->rx_kfifo);\n\tstate->ir_state = NULL;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}