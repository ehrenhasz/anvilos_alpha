{
  "module_name": "cx25840-firmware.c",
  "hash_id": "37ee95c4ba747da4cf368a6a2fda59f2976eab608ba21cedec2a4ac984e7bb31",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/cx25840/cx25840-firmware.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/firmware.h>\n#include <media/v4l2-common.h>\n#include <media/drv-intf/cx25840.h>\n\n#include \"cx25840-core.h\"\n\n \n#define FWSEND 48\n\n#define FWDEV(x) &((x)->dev)\n\nstatic char *firmware = \"\";\n\nmodule_param(firmware, charp, 0444);\n\nMODULE_PARM_DESC(firmware, \"Firmware image to load\");\n\nstatic void start_fw_load(struct i2c_client *client)\n{\n\t \n\tcx25840_write(client, 0x800, 0x00);\n\tcx25840_write(client, 0x801, 0x00);\n\t\n\tcx25840_write(client, 0x803, 0x0b);\n\t \n\tcx25840_write(client, 0x000, 0x20);\n}\n\nstatic void end_fw_load(struct i2c_client *client)\n{\n\t \n\tcx25840_write(client, 0x000, 0x00);\n\t \n\tcx25840_write(client, 0x803, 0x03);\n}\n\n#define CX2388x_FIRMWARE \"v4l-cx23885-avcore-01.fw\"\n#define CX231xx_FIRMWARE \"v4l-cx231xx-avcore-01.fw\"\n#define CX25840_FIRMWARE \"v4l-cx25840.fw\"\n\nstatic const char *get_fw_name(struct i2c_client *client)\n{\n\tstruct cx25840_state *state = to_state(i2c_get_clientdata(client));\n\n\tif (firmware[0])\n\t\treturn firmware;\n\tif (is_cx2388x(state))\n\t\treturn CX2388x_FIRMWARE;\n\tif (is_cx231xx(state))\n\t\treturn CX231xx_FIRMWARE;\n\treturn CX25840_FIRMWARE;\n}\n\nstatic int check_fw_load(struct i2c_client *client, int size)\n{\n\t \n\tint s = cx25840_read(client, 0x801) << 8;\n\ts |= cx25840_read(client, 0x800);\n\n\tif (size != s) {\n\t\tv4l_err(client, \"firmware %s load failed\\n\",\n\t\t\t\tget_fw_name(client));\n\t\treturn -EINVAL;\n\t}\n\n\tv4l_info(client, \"loaded %s firmware (%d bytes)\\n\",\n\t\t\tget_fw_name(client), size);\n\treturn 0;\n}\n\nstatic int fw_write(struct i2c_client *client, const u8 *data, int size)\n{\n\tif (i2c_master_send(client, data, size) < size) {\n\t\tv4l_err(client, \"firmware load i2c failure\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\treturn 0;\n}\n\nint cx25840_loadfw(struct i2c_client *client)\n{\n\tstruct cx25840_state *state = to_state(i2c_get_clientdata(client));\n\tconst struct firmware *fw = NULL;\n\tu8 buffer[FWSEND];\n\tconst u8 *ptr;\n\tconst char *fwname = get_fw_name(client);\n\tint size, retval;\n\tint max_buf_size = FWSEND;\n\tu32 gpio_oe = 0, gpio_da = 0;\n\n\tif (is_cx2388x(state)) {\n\t\t \n\t\tgpio_oe = cx25840_read(client, 0x160);\n\t\tgpio_da = cx25840_read(client, 0x164);\n\t}\n\n\t \n\tif (is_cx231xx(state) && max_buf_size > 16)\n\t\tmax_buf_size = 16;\n\n\tif (request_firmware(&fw, fwname, FWDEV(client)) != 0) {\n\t\tv4l_err(client, \"unable to open firmware %s\\n\", fwname);\n\t\treturn -EINVAL;\n\t}\n\n\tstart_fw_load(client);\n\n\tbuffer[0] = 0x08;\n\tbuffer[1] = 0x02;\n\n\tsize = fw->size;\n\tptr = fw->data;\n\twhile (size > 0) {\n\t\tint len = min(max_buf_size - 2, size);\n\n\t\tmemcpy(buffer + 2, ptr, len);\n\n\t\tretval = fw_write(client, buffer, len + 2);\n\n\t\tif (retval < 0) {\n\t\t\trelease_firmware(fw);\n\t\t\treturn retval;\n\t\t}\n\n\t\tsize -= len;\n\t\tptr += len;\n\t}\n\n\tend_fw_load(client);\n\n\tsize = fw->size;\n\trelease_firmware(fw);\n\n\tif (is_cx2388x(state)) {\n\t\t \n\t\tcx25840_write(client, 0x160, gpio_oe);\n\t\tcx25840_write(client, 0x164, gpio_da);\n\t}\n\n\treturn check_fw_load(client, size);\n}\n\nMODULE_FIRMWARE(CX2388x_FIRMWARE);\nMODULE_FIRMWARE(CX231xx_FIRMWARE);\nMODULE_FIRMWARE(CX25840_FIRMWARE);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}