{
  "module_name": "cx25840-vbi.c",
  "hash_id": "44455c92f4d21fa7c20a71542f3bba83f171700bf071b536d5f25601fdc5a5ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/cx25840/cx25840-vbi.c",
  "human_readable_source": "\n \n\n\n#include <linux/videodev2.h>\n#include <linux/i2c.h>\n#include <media/v4l2-common.h>\n#include <media/drv-intf/cx25840.h>\n\n#include \"cx25840-core.h\"\n\nstatic int odd_parity(u8 c)\n{\n\tc ^= (c >> 4);\n\tc ^= (c >> 2);\n\tc ^= (c >> 1);\n\n\treturn c & 1;\n}\n\nstatic int decode_vps(u8 * dst, u8 * p)\n{\n\tstatic const u8 biphase_tbl[] = {\n\t\t0xf0, 0x78, 0x70, 0xf0, 0xb4, 0x3c, 0x34, 0xb4,\n\t\t0xb0, 0x38, 0x30, 0xb0, 0xf0, 0x78, 0x70, 0xf0,\n\t\t0xd2, 0x5a, 0x52, 0xd2, 0x96, 0x1e, 0x16, 0x96,\n\t\t0x92, 0x1a, 0x12, 0x92, 0xd2, 0x5a, 0x52, 0xd2,\n\t\t0xd0, 0x58, 0x50, 0xd0, 0x94, 0x1c, 0x14, 0x94,\n\t\t0x90, 0x18, 0x10, 0x90, 0xd0, 0x58, 0x50, 0xd0,\n\t\t0xf0, 0x78, 0x70, 0xf0, 0xb4, 0x3c, 0x34, 0xb4,\n\t\t0xb0, 0x38, 0x30, 0xb0, 0xf0, 0x78, 0x70, 0xf0,\n\t\t0xe1, 0x69, 0x61, 0xe1, 0xa5, 0x2d, 0x25, 0xa5,\n\t\t0xa1, 0x29, 0x21, 0xa1, 0xe1, 0x69, 0x61, 0xe1,\n\t\t0xc3, 0x4b, 0x43, 0xc3, 0x87, 0x0f, 0x07, 0x87,\n\t\t0x83, 0x0b, 0x03, 0x83, 0xc3, 0x4b, 0x43, 0xc3,\n\t\t0xc1, 0x49, 0x41, 0xc1, 0x85, 0x0d, 0x05, 0x85,\n\t\t0x81, 0x09, 0x01, 0x81, 0xc1, 0x49, 0x41, 0xc1,\n\t\t0xe1, 0x69, 0x61, 0xe1, 0xa5, 0x2d, 0x25, 0xa5,\n\t\t0xa1, 0x29, 0x21, 0xa1, 0xe1, 0x69, 0x61, 0xe1,\n\t\t0xe0, 0x68, 0x60, 0xe0, 0xa4, 0x2c, 0x24, 0xa4,\n\t\t0xa0, 0x28, 0x20, 0xa0, 0xe0, 0x68, 0x60, 0xe0,\n\t\t0xc2, 0x4a, 0x42, 0xc2, 0x86, 0x0e, 0x06, 0x86,\n\t\t0x82, 0x0a, 0x02, 0x82, 0xc2, 0x4a, 0x42, 0xc2,\n\t\t0xc0, 0x48, 0x40, 0xc0, 0x84, 0x0c, 0x04, 0x84,\n\t\t0x80, 0x08, 0x00, 0x80, 0xc0, 0x48, 0x40, 0xc0,\n\t\t0xe0, 0x68, 0x60, 0xe0, 0xa4, 0x2c, 0x24, 0xa4,\n\t\t0xa0, 0x28, 0x20, 0xa0, 0xe0, 0x68, 0x60, 0xe0,\n\t\t0xf0, 0x78, 0x70, 0xf0, 0xb4, 0x3c, 0x34, 0xb4,\n\t\t0xb0, 0x38, 0x30, 0xb0, 0xf0, 0x78, 0x70, 0xf0,\n\t\t0xd2, 0x5a, 0x52, 0xd2, 0x96, 0x1e, 0x16, 0x96,\n\t\t0x92, 0x1a, 0x12, 0x92, 0xd2, 0x5a, 0x52, 0xd2,\n\t\t0xd0, 0x58, 0x50, 0xd0, 0x94, 0x1c, 0x14, 0x94,\n\t\t0x90, 0x18, 0x10, 0x90, 0xd0, 0x58, 0x50, 0xd0,\n\t\t0xf0, 0x78, 0x70, 0xf0, 0xb4, 0x3c, 0x34, 0xb4,\n\t\t0xb0, 0x38, 0x30, 0xb0, 0xf0, 0x78, 0x70, 0xf0,\n\t};\n\n\tu8 c, err = 0;\n\tint i;\n\n\tfor (i = 0; i < 2 * 13; i += 2) {\n\t\terr |= biphase_tbl[p[i]] | biphase_tbl[p[i + 1]];\n\t\tc = (biphase_tbl[p[i + 1]] & 0xf) |\n\t\t    ((biphase_tbl[p[i]] & 0xf) << 4);\n\t\tdst[i / 2] = c;\n\t}\n\n\treturn err & 0xf0;\n}\n\nint cx25840_g_sliced_fmt(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_format *svbi)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct cx25840_state *state = to_state(sd);\n\tstatic const u16 lcr2vbi[] = {\n\t\t0, V4L2_SLICED_TELETEXT_B, 0,\t \n\t\t0, V4L2_SLICED_WSS_625, 0,\t \n\t\tV4L2_SLICED_CAPTION_525,\t \n\t\t0, 0, V4L2_SLICED_VPS, 0, 0,\t \n\t\t0, 0, 0, 0\n\t};\n\tint is_pal = !(state->std & V4L2_STD_525_60);\n\tint i;\n\n\tmemset(svbi->service_lines, 0, sizeof(svbi->service_lines));\n\tsvbi->service_set = 0;\n\t \n\t \n\tif ((cx25840_read(client, 0x404) & 0x10) == 0)\n\t\treturn 0;\n\n\tif (is_pal) {\n\t\tfor (i = 7; i <= 23; i++) {\n\t\t\tu8 v = cx25840_read(client,\n\t\t\t\t state->vbi_regs_offset + 0x424 + i - 7);\n\n\t\t\tsvbi->service_lines[0][i] = lcr2vbi[v >> 4];\n\t\t\tsvbi->service_lines[1][i] = lcr2vbi[v & 0xf];\n\t\t\tsvbi->service_set |= svbi->service_lines[0][i] |\n\t\t\t\t\t     svbi->service_lines[1][i];\n\t\t}\n\t} else {\n\t\tfor (i = 10; i <= 21; i++) {\n\t\t\tu8 v = cx25840_read(client,\n\t\t\t\tstate->vbi_regs_offset + 0x424 + i - 10);\n\n\t\t\tsvbi->service_lines[0][i] = lcr2vbi[v >> 4];\n\t\t\tsvbi->service_lines[1][i] = lcr2vbi[v & 0xf];\n\t\t\tsvbi->service_set |= svbi->service_lines[0][i] |\n\t\t\t\t\t     svbi->service_lines[1][i];\n\t\t}\n\t}\n\treturn 0;\n}\n\nint cx25840_s_raw_fmt(struct v4l2_subdev *sd, struct v4l2_vbi_format *fmt)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct cx25840_state *state = to_state(sd);\n\tint is_pal = !(state->std & V4L2_STD_525_60);\n\tint vbi_offset = is_pal ? 1 : 0;\n\n\t \n\tcx25840_std_setup(client);\n\n\t \n\tif (is_cx23888(state))\n\t\tcx25840_write(client, 0x54f, vbi_offset);\n\telse\n\t\tcx25840_write(client, 0x47f, vbi_offset);\n\t \n\tcx25840_write(client, 0x404, 0x2e);\n\treturn 0;\n}\n\nint cx25840_s_sliced_fmt(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_format *svbi)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct cx25840_state *state = to_state(sd);\n\tint is_pal = !(state->std & V4L2_STD_525_60);\n\tint vbi_offset = is_pal ? 1 : 0;\n\tint i, x;\n\tu8 lcr[24];\n\n\tfor (x = 0; x <= 23; x++)\n\t\tlcr[x] = 0x00;\n\n\t \n\tcx25840_std_setup(client);\n\n\t \n\t \n\tcx25840_write(client, 0x404, 0x32);\t \n\tcx25840_write(client, 0x406, 0x13);\n\tif (is_cx23888(state))\n\t\tcx25840_write(client, 0x54f, vbi_offset);\n\telse\n\t\tcx25840_write(client, 0x47f, vbi_offset);\n\n\tif (is_pal) {\n\t\tfor (i = 0; i <= 6; i++)\n\t\t\tsvbi->service_lines[0][i] =\n\t\t\t\tsvbi->service_lines[1][i] = 0;\n\t} else {\n\t\tfor (i = 0; i <= 9; i++)\n\t\t\tsvbi->service_lines[0][i] =\n\t\t\t\tsvbi->service_lines[1][i] = 0;\n\n\t\tfor (i = 22; i <= 23; i++)\n\t\t\tsvbi->service_lines[0][i] =\n\t\t\t\tsvbi->service_lines[1][i] = 0;\n\t}\n\n\tfor (i = 7; i <= 23; i++) {\n\t\tfor (x = 0; x <= 1; x++) {\n\t\t\tswitch (svbi->service_lines[1-x][i]) {\n\t\t\tcase V4L2_SLICED_TELETEXT_B:\n\t\t\t\tlcr[i] |= 1 << (4 * x);\n\t\t\t\tbreak;\n\t\t\tcase V4L2_SLICED_WSS_625:\n\t\t\t\tlcr[i] |= 4 << (4 * x);\n\t\t\t\tbreak;\n\t\t\tcase V4L2_SLICED_CAPTION_525:\n\t\t\t\tlcr[i] |= 6 << (4 * x);\n\t\t\t\tbreak;\n\t\t\tcase V4L2_SLICED_VPS:\n\t\t\t\tlcr[i] |= 9 << (4 * x);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (is_pal) {\n\t\tfor (x = 1, i = state->vbi_regs_offset + 0x424;\n\t\t     i <= state->vbi_regs_offset + 0x434; i++, x++)\n\t\t\tcx25840_write(client, i, lcr[6 + x]);\n\t} else {\n\t\tfor (x = 1, i = state->vbi_regs_offset + 0x424;\n\t\t     i <= state->vbi_regs_offset + 0x430; i++, x++)\n\t\t\tcx25840_write(client, i, lcr[9 + x]);\n\t\tfor (i = state->vbi_regs_offset + 0x431;\n\t\t     i <= state->vbi_regs_offset + 0x434; i++)\n\t\t\tcx25840_write(client, i, 0);\n\t}\n\n\tcx25840_write(client, state->vbi_regs_offset + 0x43c, 0x16);\n\t \n\tif (is_cx23888(state))\n\t\tcx25840_write(client, 0x428, is_pal ? 0x2a : 0x22);\n\telse\n\t\tcx25840_write(client, 0x474, is_pal ? 0x2a : 0x22);\n\treturn 0;\n}\n\nint cx25840_decode_vbi_line(struct v4l2_subdev *sd, struct v4l2_decode_vbi_line *vbi)\n{\n\tstruct cx25840_state *state = to_state(sd);\n\tu8 *p = vbi->p;\n\tint id1, id2, l, err = 0;\n\n\tif (p[0] || p[1] != 0xff || p[2] != 0xff ||\n\t\t\t(p[3] != 0x55 && p[3] != 0x91)) {\n\t\tvbi->line = vbi->type = 0;\n\t\treturn 0;\n\t}\n\n\tp += 4;\n\tid1 = p[-1];\n\tid2 = p[0] & 0xf;\n\tl = p[2] & 0x3f;\n\tl += state->vbi_line_offset;\n\tp += 4;\n\n\tswitch (id2) {\n\tcase 1:\n\t\tid2 = V4L2_SLICED_TELETEXT_B;\n\t\tbreak;\n\tcase 4:\n\t\tid2 = V4L2_SLICED_WSS_625;\n\t\tbreak;\n\tcase 6:\n\t\tid2 = V4L2_SLICED_CAPTION_525;\n\t\terr = !odd_parity(p[0]) || !odd_parity(p[1]);\n\t\tbreak;\n\tcase 9:\n\t\tid2 = V4L2_SLICED_VPS;\n\t\tif (decode_vps(p, p) != 0)\n\t\t\terr = 1;\n\t\tbreak;\n\tdefault:\n\t\tid2 = 0;\n\t\terr = 1;\n\t\tbreak;\n\t}\n\n\tvbi->type = err ? 0 : id2;\n\tvbi->line = err ? 0 : l;\n\tvbi->is_second_field = err ? 0 : (id1 == 0x55);\n\tvbi->p = p;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}