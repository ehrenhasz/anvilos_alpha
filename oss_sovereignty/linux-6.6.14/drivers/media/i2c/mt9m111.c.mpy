{
  "module_name": "mt9m111.c",
  "hash_id": "8cb70e21f10c65794418bf861a5232d525b4091c241b356a8003fb78863ecbf2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/mt9m111.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/videodev2.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/regulator/consumer.h>\n#include <linux/v4l2-mediabus.h>\n#include <linux/module.h>\n#include <linux/property.h>\n\n#include <media/v4l2-async.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fwnode.h>\n\n \n\n \n#define MT9M111_CHIP_VERSION\t\t0x000\n#define MT9M111_ROW_START\t\t0x001\n#define MT9M111_COLUMN_START\t\t0x002\n#define MT9M111_WINDOW_HEIGHT\t\t0x003\n#define MT9M111_WINDOW_WIDTH\t\t0x004\n#define MT9M111_HORIZONTAL_BLANKING_B\t0x005\n#define MT9M111_VERTICAL_BLANKING_B\t0x006\n#define MT9M111_HORIZONTAL_BLANKING_A\t0x007\n#define MT9M111_VERTICAL_BLANKING_A\t0x008\n#define MT9M111_SHUTTER_WIDTH\t\t0x009\n#define MT9M111_ROW_SPEED\t\t0x00a\n#define MT9M111_EXTRA_DELAY\t\t0x00b\n#define MT9M111_SHUTTER_DELAY\t\t0x00c\n#define MT9M111_RESET\t\t\t0x00d\n#define MT9M111_READ_MODE_B\t\t0x020\n#define MT9M111_READ_MODE_A\t\t0x021\n#define MT9M111_FLASH_CONTROL\t\t0x023\n#define MT9M111_GREEN1_GAIN\t\t0x02b\n#define MT9M111_BLUE_GAIN\t\t0x02c\n#define MT9M111_RED_GAIN\t\t0x02d\n#define MT9M111_GREEN2_GAIN\t\t0x02e\n#define MT9M111_GLOBAL_GAIN\t\t0x02f\n#define MT9M111_CONTEXT_CONTROL\t\t0x0c8\n#define MT9M111_PAGE_MAP\t\t0x0f0\n#define MT9M111_BYTE_WISE_ADDR\t\t0x0f1\n\n#define MT9M111_RESET_SYNC_CHANGES\t(1 << 15)\n#define MT9M111_RESET_RESTART_BAD_FRAME\t(1 << 9)\n#define MT9M111_RESET_SHOW_BAD_FRAMES\t(1 << 8)\n#define MT9M111_RESET_RESET_SOC\t\t(1 << 5)\n#define MT9M111_RESET_OUTPUT_DISABLE\t(1 << 4)\n#define MT9M111_RESET_CHIP_ENABLE\t(1 << 3)\n#define MT9M111_RESET_ANALOG_STANDBY\t(1 << 2)\n#define MT9M111_RESET_RESTART_FRAME\t(1 << 1)\n#define MT9M111_RESET_RESET_MODE\t(1 << 0)\n\n#define MT9M111_RM_FULL_POWER_RD\t(0 << 10)\n#define MT9M111_RM_LOW_POWER_RD\t\t(1 << 10)\n#define MT9M111_RM_COL_SKIP_4X\t\t(1 << 5)\n#define MT9M111_RM_ROW_SKIP_4X\t\t(1 << 4)\n#define MT9M111_RM_COL_SKIP_2X\t\t(1 << 3)\n#define MT9M111_RM_ROW_SKIP_2X\t\t(1 << 2)\n#define MT9M111_RMB_MIRROR_COLS\t\t(1 << 1)\n#define MT9M111_RMB_MIRROR_ROWS\t\t(1 << 0)\n#define MT9M111_CTXT_CTRL_RESTART\t(1 << 15)\n#define MT9M111_CTXT_CTRL_DEFECTCOR_B\t(1 << 12)\n#define MT9M111_CTXT_CTRL_RESIZE_B\t(1 << 10)\n#define MT9M111_CTXT_CTRL_CTRL2_B\t(1 << 9)\n#define MT9M111_CTXT_CTRL_GAMMA_B\t(1 << 8)\n#define MT9M111_CTXT_CTRL_XENON_EN\t(1 << 7)\n#define MT9M111_CTXT_CTRL_READ_MODE_B\t(1 << 3)\n#define MT9M111_CTXT_CTRL_LED_FLASH_EN\t(1 << 2)\n#define MT9M111_CTXT_CTRL_VBLANK_SEL_B\t(1 << 1)\n#define MT9M111_CTXT_CTRL_HBLANK_SEL_B\t(1 << 0)\n\n \n#define MT9M111_OPER_MODE_CTRL\t\t0x106\n#define MT9M111_OUTPUT_FORMAT_CTRL\t0x108\n#define MT9M111_TPG_CTRL\t\t0x148\n#define MT9M111_REDUCER_XZOOM_B\t\t0x1a0\n#define MT9M111_REDUCER_XSIZE_B\t\t0x1a1\n#define MT9M111_REDUCER_YZOOM_B\t\t0x1a3\n#define MT9M111_REDUCER_YSIZE_B\t\t0x1a4\n#define MT9M111_REDUCER_XZOOM_A\t\t0x1a6\n#define MT9M111_REDUCER_XSIZE_A\t\t0x1a7\n#define MT9M111_REDUCER_YZOOM_A\t\t0x1a9\n#define MT9M111_REDUCER_YSIZE_A\t\t0x1aa\n#define MT9M111_EFFECTS_MODE\t\t0x1e2\n\n#define MT9M111_OUTPUT_FORMAT_CTRL2_A\t0x13a\n#define MT9M111_OUTPUT_FORMAT_CTRL2_B\t0x19b\n\n#define MT9M111_OPMODE_AUTOEXPO_EN\t(1 << 14)\n#define MT9M111_OPMODE_AUTOWHITEBAL_EN\t(1 << 1)\n#define MT9M111_OUTFMT_FLIP_BAYER_COL\t(1 << 9)\n#define MT9M111_OUTFMT_FLIP_BAYER_ROW\t(1 << 8)\n#define MT9M111_OUTFMT_PROCESSED_BAYER\t(1 << 14)\n#define MT9M111_OUTFMT_BYPASS_IFP\t(1 << 10)\n#define MT9M111_OUTFMT_INV_PIX_CLOCK\t(1 << 9)\n#define MT9M111_OUTFMT_RGB\t\t(1 << 8)\n#define MT9M111_OUTFMT_RGB565\t\t(0 << 6)\n#define MT9M111_OUTFMT_RGB555\t\t(1 << 6)\n#define MT9M111_OUTFMT_RGB444x\t\t(2 << 6)\n#define MT9M111_OUTFMT_RGBx444\t\t(3 << 6)\n#define MT9M111_OUTFMT_TST_RAMP_OFF\t(0 << 4)\n#define MT9M111_OUTFMT_TST_RAMP_COL\t(1 << 4)\n#define MT9M111_OUTFMT_TST_RAMP_ROW\t(2 << 4)\n#define MT9M111_OUTFMT_TST_RAMP_FRAME\t(3 << 4)\n#define MT9M111_OUTFMT_SHIFT_3_UP\t(1 << 3)\n#define MT9M111_OUTFMT_AVG_CHROMA\t(1 << 2)\n#define MT9M111_OUTFMT_SWAP_YCbCr_C_Y_RGB_EVEN\t(1 << 1)\n#define MT9M111_OUTFMT_SWAP_YCbCr_Cb_Cr_RGB_R_B\t(1 << 0)\n#define MT9M111_TPG_SEL_MASK\t\tGENMASK(2, 0)\n#define MT9M111_EFFECTS_MODE_MASK\tGENMASK(2, 0)\n#define MT9M111_RM_PWR_MASK\t\tBIT(10)\n#define MT9M111_RM_SKIP2_MASK\t\tGENMASK(3, 2)\n\n \n\n#define reg_read(reg) mt9m111_reg_read(client, MT9M111_##reg)\n#define reg_write(reg, val) mt9m111_reg_write(client, MT9M111_##reg, (val))\n#define reg_set(reg, val) mt9m111_reg_set(client, MT9M111_##reg, (val))\n#define reg_clear(reg, val) mt9m111_reg_clear(client, MT9M111_##reg, (val))\n#define reg_mask(reg, val, mask) mt9m111_reg_mask(client, MT9M111_##reg, \\\n\t\t(val), (mask))\n\n#define MT9M111_MIN_DARK_ROWS\t8\n#define MT9M111_MIN_DARK_COLS\t26\n#define MT9M111_MAX_HEIGHT\t1024\n#define MT9M111_MAX_WIDTH\t1280\n\nstruct mt9m111_context {\n\tu16 read_mode;\n\tu16 blanking_h;\n\tu16 blanking_v;\n\tu16 reducer_xzoom;\n\tu16 reducer_yzoom;\n\tu16 reducer_xsize;\n\tu16 reducer_ysize;\n\tu16 output_fmt_ctrl2;\n\tu16 control;\n};\n\nstatic struct mt9m111_context context_a = {\n\t.read_mode\t\t= MT9M111_READ_MODE_A,\n\t.blanking_h\t\t= MT9M111_HORIZONTAL_BLANKING_A,\n\t.blanking_v\t\t= MT9M111_VERTICAL_BLANKING_A,\n\t.reducer_xzoom\t\t= MT9M111_REDUCER_XZOOM_A,\n\t.reducer_yzoom\t\t= MT9M111_REDUCER_YZOOM_A,\n\t.reducer_xsize\t\t= MT9M111_REDUCER_XSIZE_A,\n\t.reducer_ysize\t\t= MT9M111_REDUCER_YSIZE_A,\n\t.output_fmt_ctrl2\t= MT9M111_OUTPUT_FORMAT_CTRL2_A,\n\t.control\t\t= MT9M111_CTXT_CTRL_RESTART,\n};\n\nstatic struct mt9m111_context context_b = {\n\t.read_mode\t\t= MT9M111_READ_MODE_B,\n\t.blanking_h\t\t= MT9M111_HORIZONTAL_BLANKING_B,\n\t.blanking_v\t\t= MT9M111_VERTICAL_BLANKING_B,\n\t.reducer_xzoom\t\t= MT9M111_REDUCER_XZOOM_B,\n\t.reducer_yzoom\t\t= MT9M111_REDUCER_YZOOM_B,\n\t.reducer_xsize\t\t= MT9M111_REDUCER_XSIZE_B,\n\t.reducer_ysize\t\t= MT9M111_REDUCER_YSIZE_B,\n\t.output_fmt_ctrl2\t= MT9M111_OUTPUT_FORMAT_CTRL2_B,\n\t.control\t\t= MT9M111_CTXT_CTRL_RESTART |\n\t\tMT9M111_CTXT_CTRL_DEFECTCOR_B | MT9M111_CTXT_CTRL_RESIZE_B |\n\t\tMT9M111_CTXT_CTRL_CTRL2_B | MT9M111_CTXT_CTRL_GAMMA_B |\n\t\tMT9M111_CTXT_CTRL_READ_MODE_B | MT9M111_CTXT_CTRL_VBLANK_SEL_B |\n\t\tMT9M111_CTXT_CTRL_HBLANK_SEL_B,\n};\n\n \nstruct mt9m111_datafmt {\n\tu32\tcode;\n\tenum v4l2_colorspace\t\tcolorspace;\n};\n\nstatic const struct mt9m111_datafmt mt9m111_colour_fmts[] = {\n\t{MEDIA_BUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_SRGB},\n\t{MEDIA_BUS_FMT_YVYU8_2X8, V4L2_COLORSPACE_SRGB},\n\t{MEDIA_BUS_FMT_UYVY8_2X8, V4L2_COLORSPACE_SRGB},\n\t{MEDIA_BUS_FMT_VYUY8_2X8, V4L2_COLORSPACE_SRGB},\n\t{MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE, V4L2_COLORSPACE_SRGB},\n\t{MEDIA_BUS_FMT_RGB555_2X8_PADHI_BE, V4L2_COLORSPACE_SRGB},\n\t{MEDIA_BUS_FMT_RGB565_2X8_LE, V4L2_COLORSPACE_SRGB},\n\t{MEDIA_BUS_FMT_RGB565_2X8_BE, V4L2_COLORSPACE_SRGB},\n\t{MEDIA_BUS_FMT_BGR565_2X8_LE, V4L2_COLORSPACE_SRGB},\n\t{MEDIA_BUS_FMT_BGR565_2X8_BE, V4L2_COLORSPACE_SRGB},\n\t{MEDIA_BUS_FMT_SBGGR8_1X8, V4L2_COLORSPACE_SRGB},\n\t{MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE, V4L2_COLORSPACE_SRGB},\n};\n\nenum mt9m111_mode_id {\n\tMT9M111_MODE_SXGA_8FPS,\n\tMT9M111_MODE_SXGA_15FPS,\n\tMT9M111_MODE_QSXGA_30FPS,\n\tMT9M111_NUM_MODES,\n};\n\nstruct mt9m111_mode_info {\n\tunsigned int sensor_w;\n\tunsigned int sensor_h;\n\tunsigned int max_image_w;\n\tunsigned int max_image_h;\n\tunsigned int max_fps;\n\tunsigned int reg_val;\n\tunsigned int reg_mask;\n};\n\nstruct mt9m111 {\n\tstruct v4l2_subdev subdev;\n\tstruct v4l2_ctrl_handler hdl;\n\tstruct v4l2_ctrl *gain;\n\tstruct mt9m111_context *ctx;\n\tstruct v4l2_rect rect;\t \n\tstruct clk *clk;\n\tunsigned int width;\t \n\tunsigned int height;\t \n\tstruct v4l2_fract frame_interval;\n\tconst struct mt9m111_mode_info *current_mode;\n\tstruct mutex power_lock;  \n\tint power_count;\n\tconst struct mt9m111_datafmt *fmt;\n\tint lastpage;\t \n\tstruct regulator *regulator;\n\tbool is_streaming;\n\t \n\tunsigned int pclk_sample:1;\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tstruct media_pad pad;\n#endif\n};\n\nstatic const struct mt9m111_mode_info mt9m111_mode_data[MT9M111_NUM_MODES] = {\n\t[MT9M111_MODE_SXGA_8FPS] = {\n\t\t.sensor_w = 1280,\n\t\t.sensor_h = 1024,\n\t\t.max_image_w = 1280,\n\t\t.max_image_h = 1024,\n\t\t.max_fps = 8,\n\t\t.reg_val = MT9M111_RM_LOW_POWER_RD,\n\t\t.reg_mask = MT9M111_RM_PWR_MASK | MT9M111_RM_SKIP2_MASK,\n\t},\n\t[MT9M111_MODE_SXGA_15FPS] = {\n\t\t.sensor_w = 1280,\n\t\t.sensor_h = 1024,\n\t\t.max_image_w = 1280,\n\t\t.max_image_h = 1024,\n\t\t.max_fps = 15,\n\t\t.reg_val = MT9M111_RM_FULL_POWER_RD,\n\t\t.reg_mask = MT9M111_RM_PWR_MASK | MT9M111_RM_SKIP2_MASK,\n\t},\n\t[MT9M111_MODE_QSXGA_30FPS] = {\n\t\t.sensor_w = 1280,\n\t\t.sensor_h = 1024,\n\t\t.max_image_w = 640,\n\t\t.max_image_h = 512,\n\t\t.max_fps = 30,\n\t\t.reg_val = MT9M111_RM_LOW_POWER_RD | MT9M111_RM_COL_SKIP_2X |\n\t\t\t   MT9M111_RM_ROW_SKIP_2X,\n\t\t.reg_mask = MT9M111_RM_PWR_MASK | MT9M111_RM_SKIP2_MASK,\n\t},\n};\n\n \nstatic const struct mt9m111_datafmt *mt9m111_find_datafmt(struct mt9m111 *mt9m111,\n\t\t\t\t\t\tu32 code)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(mt9m111_colour_fmts); i++)\n\t\tif (mt9m111_colour_fmts[i].code == code)\n\t\t\treturn mt9m111_colour_fmts + i;\n\n\treturn mt9m111->fmt;\n}\n\nstatic struct mt9m111 *to_mt9m111(const struct i2c_client *client)\n{\n\treturn container_of(i2c_get_clientdata(client), struct mt9m111, subdev);\n}\n\nstatic int reg_page_map_set(struct i2c_client *client, const u16 reg)\n{\n\tint ret;\n\tu16 page;\n\tstruct mt9m111 *mt9m111 = to_mt9m111(client);\n\n\tpage = (reg >> 8);\n\tif (page == mt9m111->lastpage)\n\t\treturn 0;\n\tif (page > 2)\n\t\treturn -EINVAL;\n\n\tret = i2c_smbus_write_word_swapped(client, MT9M111_PAGE_MAP, page);\n\tif (!ret)\n\t\tmt9m111->lastpage = page;\n\treturn ret;\n}\n\nstatic int mt9m111_reg_read(struct i2c_client *client, const u16 reg)\n{\n\tint ret;\n\n\tret = reg_page_map_set(client, reg);\n\tif (!ret)\n\t\tret = i2c_smbus_read_word_swapped(client, reg & 0xff);\n\n\tdev_dbg(&client->dev, \"read  reg.%03x -> %04x\\n\", reg, ret);\n\treturn ret;\n}\n\nstatic int mt9m111_reg_write(struct i2c_client *client, const u16 reg,\n\t\t\t     const u16 data)\n{\n\tint ret;\n\n\tret = reg_page_map_set(client, reg);\n\tif (!ret)\n\t\tret = i2c_smbus_write_word_swapped(client, reg & 0xff, data);\n\tdev_dbg(&client->dev, \"write reg.%03x = %04x -> %d\\n\", reg, data, ret);\n\treturn ret;\n}\n\nstatic int mt9m111_reg_set(struct i2c_client *client, const u16 reg,\n\t\t\t   const u16 data)\n{\n\tint ret;\n\n\tret = mt9m111_reg_read(client, reg);\n\tif (ret >= 0)\n\t\tret = mt9m111_reg_write(client, reg, ret | data);\n\treturn ret;\n}\n\nstatic int mt9m111_reg_clear(struct i2c_client *client, const u16 reg,\n\t\t\t     const u16 data)\n{\n\tint ret;\n\n\tret = mt9m111_reg_read(client, reg);\n\tif (ret >= 0)\n\t\tret = mt9m111_reg_write(client, reg, ret & ~data);\n\treturn ret;\n}\n\nstatic int mt9m111_reg_mask(struct i2c_client *client, const u16 reg,\n\t\t\t    const u16 data, const u16 mask)\n{\n\tint ret;\n\n\tret = mt9m111_reg_read(client, reg);\n\tif (ret >= 0)\n\t\tret = mt9m111_reg_write(client, reg, (ret & ~mask) | data);\n\treturn ret;\n}\n\nstatic int mt9m111_set_context(struct mt9m111 *mt9m111,\n\t\t\t       struct mt9m111_context *ctx)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\n\treturn reg_write(CONTEXT_CONTROL, ctx->control);\n}\n\nstatic int mt9m111_setup_rect_ctx(struct mt9m111 *mt9m111,\n\t\t\tstruct mt9m111_context *ctx, struct v4l2_rect *rect,\n\t\t\tunsigned int width, unsigned int height)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\n\tint ret = mt9m111_reg_write(client, ctx->reducer_xzoom, rect->width);\n\tif (!ret)\n\t\tret = mt9m111_reg_write(client, ctx->reducer_yzoom, rect->height);\n\tif (!ret)\n\t\tret = mt9m111_reg_write(client, ctx->reducer_xsize, width);\n\tif (!ret)\n\t\tret = mt9m111_reg_write(client, ctx->reducer_ysize, height);\n\treturn ret;\n}\n\nstatic int mt9m111_setup_geometry(struct mt9m111 *mt9m111, struct v4l2_rect *rect,\n\t\t\tint width, int height, u32 code)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\n\tint ret;\n\n\tret = reg_write(COLUMN_START, rect->left);\n\tif (!ret)\n\t\tret = reg_write(ROW_START, rect->top);\n\n\tif (!ret)\n\t\tret = reg_write(WINDOW_WIDTH, rect->width);\n\tif (!ret)\n\t\tret = reg_write(WINDOW_HEIGHT, rect->height);\n\n\tif (code != MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE) {\n\t\t \n\t\tif (!ret)\n\t\t\tret = mt9m111_setup_rect_ctx(mt9m111, &context_b,\n\t\t\t\t\t\t     rect, width, height);\n\t\tif (!ret)\n\t\t\tret = mt9m111_setup_rect_ctx(mt9m111, &context_a,\n\t\t\t\t\t\t     rect, width, height);\n\t}\n\n\tdev_dbg(&client->dev, \"%s(%x): %ux%u@%u:%u -> %ux%u = %d\\n\",\n\t\t__func__, code, rect->width, rect->height, rect->left, rect->top,\n\t\twidth, height, ret);\n\n\treturn ret;\n}\n\nstatic int mt9m111_enable(struct mt9m111 *mt9m111)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\n\treturn reg_write(RESET, MT9M111_RESET_CHIP_ENABLE);\n}\n\nstatic int mt9m111_reset(struct mt9m111 *mt9m111)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\n\tint ret;\n\n\tret = reg_set(RESET, MT9M111_RESET_RESET_MODE);\n\tif (!ret)\n\t\tret = reg_set(RESET, MT9M111_RESET_RESET_SOC);\n\tif (!ret)\n\t\tret = reg_clear(RESET, MT9M111_RESET_RESET_MODE\n\t\t\t\t| MT9M111_RESET_RESET_SOC);\n\n\treturn ret;\n}\n\nstatic int mt9m111_set_selection(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_selection *sel)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9m111 *mt9m111 = to_mt9m111(client);\n\tstruct v4l2_rect rect = sel->r;\n\tint width, height;\n\tint ret, align = 0;\n\n\tif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||\n\t    sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\tif (mt9m111->fmt->code == MEDIA_BUS_FMT_SBGGR8_1X8 ||\n\t    mt9m111->fmt->code == MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE) {\n\t\t \n\t\talign = 1;\n\t\t \n\t}\n\n\t \n\tv4l_bound_align_image(&rect.width, 2, MT9M111_MAX_WIDTH, align,\n\t\t\t      &rect.height, 2, MT9M111_MAX_HEIGHT, align, 0);\n\trect.left = clamp(rect.left, MT9M111_MIN_DARK_COLS,\n\t\t\t  MT9M111_MIN_DARK_COLS + MT9M111_MAX_WIDTH -\n\t\t\t  (__s32)rect.width);\n\trect.top = clamp(rect.top, MT9M111_MIN_DARK_ROWS,\n\t\t\t MT9M111_MIN_DARK_ROWS + MT9M111_MAX_HEIGHT -\n\t\t\t (__s32)rect.height);\n\n\twidth = min(mt9m111->width, rect.width);\n\theight = min(mt9m111->height, rect.height);\n\n\tret = mt9m111_setup_geometry(mt9m111, &rect, width, height, mt9m111->fmt->code);\n\tif (!ret) {\n\t\tmt9m111->rect = rect;\n\t\tmt9m111->width = width;\n\t\tmt9m111->height = height;\n\t}\n\n\treturn ret;\n}\n\nstatic int mt9m111_get_selection(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_selection *sel)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9m111 *mt9m111 = to_mt9m111(client);\n\n\tif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.left = MT9M111_MIN_DARK_COLS;\n\t\tsel->r.top = MT9M111_MIN_DARK_ROWS;\n\t\tsel->r.width = MT9M111_MAX_WIDTH;\n\t\tsel->r.height = MT9M111_MAX_HEIGHT;\n\t\treturn 0;\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = mt9m111->rect;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mt9m111_get_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tstruct mt9m111 *mt9m111 = container_of(sd, struct mt9m111, subdev);\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\n\t\tmf = v4l2_subdev_get_try_format(sd, sd_state, format->pad);\n\t\tformat->format = *mf;\n\t\treturn 0;\n#else\n\t\treturn -EINVAL;\n#endif\n\t}\n\n\tmf->width\t= mt9m111->width;\n\tmf->height\t= mt9m111->height;\n\tmf->code\t= mt9m111->fmt->code;\n\tmf->colorspace\t= mt9m111->fmt->colorspace;\n\tmf->field\t= V4L2_FIELD_NONE;\n\tmf->ycbcr_enc\t= V4L2_YCBCR_ENC_DEFAULT;\n\tmf->quantization\t= V4L2_QUANTIZATION_DEFAULT;\n\tmf->xfer_func\t= V4L2_XFER_FUNC_DEFAULT;\n\n\treturn 0;\n}\n\nstatic int mt9m111_set_pixfmt(struct mt9m111 *mt9m111,\n\t\t\t      u32 code)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\n\tu16 data_outfmt2, mask_outfmt2 = MT9M111_OUTFMT_PROCESSED_BAYER |\n\t\tMT9M111_OUTFMT_BYPASS_IFP | MT9M111_OUTFMT_RGB |\n\t\tMT9M111_OUTFMT_RGB565 | MT9M111_OUTFMT_RGB555 |\n\t\tMT9M111_OUTFMT_RGB444x | MT9M111_OUTFMT_RGBx444 |\n\t\tMT9M111_OUTFMT_SWAP_YCbCr_C_Y_RGB_EVEN |\n\t\tMT9M111_OUTFMT_SWAP_YCbCr_Cb_Cr_RGB_R_B;\n\tint ret;\n\n\tswitch (code) {\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\t\tdata_outfmt2 = MT9M111_OUTFMT_PROCESSED_BAYER |\n\t\t\tMT9M111_OUTFMT_RGB;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE:\n\t\tdata_outfmt2 = MT9M111_OUTFMT_BYPASS_IFP | MT9M111_OUTFMT_RGB;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE:\n\t\tdata_outfmt2 = MT9M111_OUTFMT_RGB | MT9M111_OUTFMT_RGB555 |\n\t\t\tMT9M111_OUTFMT_SWAP_YCbCr_C_Y_RGB_EVEN;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB555_2X8_PADHI_BE:\n\t\tdata_outfmt2 = MT9M111_OUTFMT_RGB | MT9M111_OUTFMT_RGB555;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB565_2X8_LE:\n\t\tdata_outfmt2 = MT9M111_OUTFMT_RGB | MT9M111_OUTFMT_RGB565 |\n\t\t\tMT9M111_OUTFMT_SWAP_YCbCr_C_Y_RGB_EVEN;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB565_2X8_BE:\n\t\tdata_outfmt2 = MT9M111_OUTFMT_RGB | MT9M111_OUTFMT_RGB565;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_BGR565_2X8_BE:\n\t\tdata_outfmt2 = MT9M111_OUTFMT_RGB | MT9M111_OUTFMT_RGB565 |\n\t\t\tMT9M111_OUTFMT_SWAP_YCbCr_Cb_Cr_RGB_R_B;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_BGR565_2X8_LE:\n\t\tdata_outfmt2 = MT9M111_OUTFMT_RGB | MT9M111_OUTFMT_RGB565 |\n\t\t\tMT9M111_OUTFMT_SWAP_YCbCr_C_Y_RGB_EVEN |\n\t\t\tMT9M111_OUTFMT_SWAP_YCbCr_Cb_Cr_RGB_R_B;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\t\tdata_outfmt2 = 0;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_VYUY8_2X8:\n\t\tdata_outfmt2 = MT9M111_OUTFMT_SWAP_YCbCr_Cb_Cr_RGB_R_B;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\t\tdata_outfmt2 = MT9M111_OUTFMT_SWAP_YCbCr_C_Y_RGB_EVEN;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YVYU8_2X8:\n\t\tdata_outfmt2 = MT9M111_OUTFMT_SWAP_YCbCr_C_Y_RGB_EVEN |\n\t\t\tMT9M111_OUTFMT_SWAP_YCbCr_Cb_Cr_RGB_R_B;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev, \"Pixel format not handled: %x\\n\", code);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (mt9m111->pclk_sample == 0)\n\t\tmask_outfmt2 |= MT9M111_OUTFMT_INV_PIX_CLOCK;\n\n\tret = mt9m111_reg_mask(client, context_a.output_fmt_ctrl2,\n\t\t\t       data_outfmt2, mask_outfmt2);\n\tif (!ret)\n\t\tret = mt9m111_reg_mask(client, context_b.output_fmt_ctrl2,\n\t\t\t\t       data_outfmt2, mask_outfmt2);\n\n\treturn ret;\n}\n\nstatic int mt9m111_set_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9m111 *mt9m111 = container_of(sd, struct mt9m111, subdev);\n\tconst struct mt9m111_datafmt *fmt;\n\tstruct v4l2_rect *rect = &mt9m111->rect;\n\tbool bayer;\n\tint ret;\n\n\tif (mt9m111->is_streaming)\n\t\treturn -EBUSY;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tfmt = mt9m111_find_datafmt(mt9m111, mf->code);\n\n\tbayer = fmt->code == MEDIA_BUS_FMT_SBGGR8_1X8 ||\n\t\tfmt->code == MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE;\n\n\t \n\tif (bayer) {\n\t\trect->width = ALIGN(rect->width, 2);\n\t\trect->height = ALIGN(rect->height, 2);\n\t}\n\n\tif (fmt->code == MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE) {\n\t\t \n\t\tmf->width = rect->width;\n\t\tmf->height = rect->height;\n\t} else {\n\t\t \n\t\tif (mf->width > rect->width)\n\t\t\tmf->width = rect->width;\n\t\tif (mf->height > rect->height)\n\t\t\tmf->height = rect->height;\n\t}\n\n\tdev_dbg(&client->dev, \"%s(): %ux%u, code=%x\\n\", __func__,\n\t\tmf->width, mf->height, fmt->code);\n\n\tmf->code = fmt->code;\n\tmf->colorspace = fmt->colorspace;\n\tmf->field\t= V4L2_FIELD_NONE;\n\tmf->ycbcr_enc\t= V4L2_YCBCR_ENC_DEFAULT;\n\tmf->quantization\t= V4L2_QUANTIZATION_DEFAULT;\n\tmf->xfer_func\t= V4L2_XFER_FUNC_DEFAULT;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tsd_state->pads->try_fmt = *mf;\n\t\treturn 0;\n\t}\n\n\tret = mt9m111_setup_geometry(mt9m111, rect, mf->width, mf->height, mf->code);\n\tif (!ret)\n\t\tret = mt9m111_set_pixfmt(mt9m111, mf->code);\n\tif (!ret) {\n\t\tmt9m111->width\t= mf->width;\n\t\tmt9m111->height\t= mf->height;\n\t\tmt9m111->fmt\t= fmt;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct mt9m111_mode_info *\nmt9m111_find_mode(struct mt9m111 *mt9m111, unsigned int req_fps,\n\t\t  unsigned int width, unsigned int height)\n{\n\tconst struct mt9m111_mode_info *mode;\n\tstruct v4l2_rect *sensor_rect = &mt9m111->rect;\n\tunsigned int gap, gap_best = (unsigned int) -1;\n\tint i, best_gap_idx = MT9M111_MODE_SXGA_15FPS;\n\tbool skip_30fps = false;\n\n\t \n\tif (sensor_rect->width != MT9M111_MAX_WIDTH ||\n\t    sensor_rect->height != MT9M111_MAX_HEIGHT) {\n\t\tdev_info(mt9m111->subdev.dev,\n\t\t\t \"Framerate selection is not supported for cropped \"\n\t\t\t \"images\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tif (width > MT9M111_MAX_WIDTH / 2 || height > MT9M111_MAX_HEIGHT / 2) {\n\t\tdev_dbg(mt9m111->subdev.dev,\n\t\t\t\"Framerates > 15fps are supported only for images \"\n\t\t\t\"not exceeding 640x512\\n\");\n\t\tskip_30fps = true;\n\t}\n\n\t \n\tfor (i = 0; i < MT9M111_NUM_MODES; i++) {\n\t\tunsigned int fps = mt9m111_mode_data[i].max_fps;\n\n\t\tif (fps == 30 && skip_30fps)\n\t\t\tcontinue;\n\n\t\tgap = abs(fps - req_fps);\n\t\tif (gap < gap_best) {\n\t\t\tbest_gap_idx = i;\n\t\t\tgap_best = gap;\n\t\t}\n\t}\n\n\t \n\tmode = &mt9m111_mode_data[best_gap_idx];\n\tmt9m111->ctx = (best_gap_idx == MT9M111_MODE_QSXGA_30FPS) ? &context_a :\n\t\t\t\t\t\t\t\t    &context_b;\n\treturn mode;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int mt9m111_g_register(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_dbg_register *reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint val;\n\n\tif (reg->reg > 0x2ff)\n\t\treturn -EINVAL;\n\n\tval = mt9m111_reg_read(client, reg->reg);\n\treg->size = 2;\n\treg->val = (u64)val;\n\n\tif (reg->val > 0xffff)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int mt9m111_s_register(struct v4l2_subdev *sd,\n\t\t\t      const struct v4l2_dbg_register *reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tif (reg->reg > 0x2ff)\n\t\treturn -EINVAL;\n\n\tif (mt9m111_reg_write(client, reg->reg, reg->val) < 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n#endif\n\nstatic int mt9m111_set_flip(struct mt9m111 *mt9m111, int flip, int mask)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\n\tint ret;\n\n\tif (flip)\n\t\tret = mt9m111_reg_set(client, mt9m111->ctx->read_mode, mask);\n\telse\n\t\tret = mt9m111_reg_clear(client, mt9m111->ctx->read_mode, mask);\n\n\treturn ret;\n}\n\nstatic int mt9m111_get_global_gain(struct mt9m111 *mt9m111)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\n\tint data;\n\n\tdata = reg_read(GLOBAL_GAIN);\n\tif (data >= 0)\n\t\treturn (data & 0x2f) * (1 << ((data >> 10) & 1)) *\n\t\t\t(1 << ((data >> 9) & 1));\n\treturn data;\n}\n\nstatic int mt9m111_set_global_gain(struct mt9m111 *mt9m111, int gain)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\n\tu16 val;\n\n\tif (gain > 63 * 2 * 2)\n\t\treturn -EINVAL;\n\n\tif ((gain >= 64 * 2) && (gain < 63 * 2 * 2))\n\t\tval = (1 << 10) | (1 << 9) | (gain / 4);\n\telse if ((gain >= 64) && (gain < 64 * 2))\n\t\tval = (1 << 9) | (gain / 2);\n\telse\n\t\tval = gain;\n\n\treturn reg_write(GLOBAL_GAIN, val);\n}\n\nstatic int mt9m111_set_autoexposure(struct mt9m111 *mt9m111, int val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\n\n\tif (val == V4L2_EXPOSURE_AUTO)\n\t\treturn reg_set(OPER_MODE_CTRL, MT9M111_OPMODE_AUTOEXPO_EN);\n\treturn reg_clear(OPER_MODE_CTRL, MT9M111_OPMODE_AUTOEXPO_EN);\n}\n\nstatic int mt9m111_set_autowhitebalance(struct mt9m111 *mt9m111, int on)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\n\n\tif (on)\n\t\treturn reg_set(OPER_MODE_CTRL, MT9M111_OPMODE_AUTOWHITEBAL_EN);\n\treturn reg_clear(OPER_MODE_CTRL, MT9M111_OPMODE_AUTOWHITEBAL_EN);\n}\n\nstatic const char * const mt9m111_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Vertical monochrome gradient\",\n\t\"Flat color type 1\",\n\t\"Flat color type 2\",\n\t\"Flat color type 3\",\n\t\"Flat color type 4\",\n\t\"Flat color type 5\",\n\t\"Color bar\",\n};\n\nstatic int mt9m111_set_test_pattern(struct mt9m111 *mt9m111, int val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\n\n\treturn mt9m111_reg_mask(client, MT9M111_TPG_CTRL, val,\n\t\t\t\tMT9M111_TPG_SEL_MASK);\n}\n\nstatic int mt9m111_set_colorfx(struct mt9m111 *mt9m111, int val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\n\tstatic const struct v4l2_control colorfx[] = {\n\t\t{ V4L2_COLORFX_NONE,\t\t0 },\n\t\t{ V4L2_COLORFX_BW,\t\t1 },\n\t\t{ V4L2_COLORFX_SEPIA,\t\t2 },\n\t\t{ V4L2_COLORFX_NEGATIVE,\t3 },\n\t\t{ V4L2_COLORFX_SOLARIZATION,\t4 },\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(colorfx); i++) {\n\t\tif (colorfx[i].id == val) {\n\t\t\treturn mt9m111_reg_mask(client, MT9M111_EFFECTS_MODE,\n\t\t\t\t\t\tcolorfx[i].value,\n\t\t\t\t\t\tMT9M111_EFFECTS_MODE_MASK);\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int mt9m111_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct mt9m111 *mt9m111 = container_of(ctrl->handler,\n\t\t\t\t\t       struct mt9m111, hdl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_VFLIP:\n\t\treturn mt9m111_set_flip(mt9m111, ctrl->val,\n\t\t\t\t\tMT9M111_RMB_MIRROR_ROWS);\n\tcase V4L2_CID_HFLIP:\n\t\treturn mt9m111_set_flip(mt9m111, ctrl->val,\n\t\t\t\t\tMT9M111_RMB_MIRROR_COLS);\n\tcase V4L2_CID_GAIN:\n\t\treturn mt9m111_set_global_gain(mt9m111, ctrl->val);\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\treturn mt9m111_set_autoexposure(mt9m111, ctrl->val);\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\treturn mt9m111_set_autowhitebalance(mt9m111, ctrl->val);\n\tcase V4L2_CID_TEST_PATTERN:\n\t\treturn mt9m111_set_test_pattern(mt9m111, ctrl->val);\n\tcase V4L2_CID_COLORFX:\n\t\treturn mt9m111_set_colorfx(mt9m111, ctrl->val);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int mt9m111_suspend(struct mt9m111 *mt9m111)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\n\tint ret;\n\n\tv4l2_ctrl_s_ctrl(mt9m111->gain, mt9m111_get_global_gain(mt9m111));\n\n\tret = reg_set(RESET, MT9M111_RESET_RESET_MODE);\n\tif (!ret)\n\t\tret = reg_set(RESET, MT9M111_RESET_RESET_SOC |\n\t\t\t      MT9M111_RESET_OUTPUT_DISABLE |\n\t\t\t      MT9M111_RESET_ANALOG_STANDBY);\n\tif (!ret)\n\t\tret = reg_clear(RESET, MT9M111_RESET_CHIP_ENABLE);\n\n\treturn ret;\n}\n\nstatic void mt9m111_restore_state(struct mt9m111 *mt9m111)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\n\n\tmt9m111_set_context(mt9m111, mt9m111->ctx);\n\tmt9m111_set_pixfmt(mt9m111, mt9m111->fmt->code);\n\tmt9m111_setup_geometry(mt9m111, &mt9m111->rect,\n\t\t\tmt9m111->width, mt9m111->height, mt9m111->fmt->code);\n\tv4l2_ctrl_handler_setup(&mt9m111->hdl);\n\tmt9m111_reg_mask(client, mt9m111->ctx->read_mode,\n\t\t\t mt9m111->current_mode->reg_val,\n\t\t\t mt9m111->current_mode->reg_mask);\n}\n\nstatic int mt9m111_resume(struct mt9m111 *mt9m111)\n{\n\tint ret = mt9m111_enable(mt9m111);\n\tif (!ret)\n\t\tret = mt9m111_reset(mt9m111);\n\tif (!ret)\n\t\tmt9m111_restore_state(mt9m111);\n\n\treturn ret;\n}\n\nstatic int mt9m111_init(struct mt9m111 *mt9m111)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\n\tint ret;\n\n\tret = mt9m111_enable(mt9m111);\n\tif (!ret)\n\t\tret = mt9m111_reset(mt9m111);\n\tif (!ret)\n\t\tret = mt9m111_set_context(mt9m111, mt9m111->ctx);\n\tif (ret)\n\t\tdev_err(&client->dev, \"mt9m111 init failed: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int mt9m111_power_on(struct mt9m111 *mt9m111)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\n\tint ret;\n\n\tret = clk_prepare_enable(mt9m111->clk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regulator_enable(mt9m111->regulator);\n\tif (ret < 0)\n\t\tgoto out_clk_disable;\n\n\tret = mt9m111_resume(mt9m111);\n\tif (ret < 0)\n\t\tgoto out_regulator_disable;\n\n\treturn 0;\n\nout_regulator_disable:\n\tregulator_disable(mt9m111->regulator);\n\nout_clk_disable:\n\tclk_disable_unprepare(mt9m111->clk);\n\n\tdev_err(&client->dev, \"Failed to resume the sensor: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void mt9m111_power_off(struct mt9m111 *mt9m111)\n{\n\tmt9m111_suspend(mt9m111);\n\tregulator_disable(mt9m111->regulator);\n\tclk_disable_unprepare(mt9m111->clk);\n}\n\nstatic int mt9m111_s_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct mt9m111 *mt9m111 = container_of(sd, struct mt9m111, subdev);\n\tint ret = 0;\n\n\tmutex_lock(&mt9m111->power_lock);\n\n\t \n\tif (mt9m111->power_count == !on) {\n\t\tif (on)\n\t\t\tret = mt9m111_power_on(mt9m111);\n\t\telse\n\t\t\tmt9m111_power_off(mt9m111);\n\t}\n\n\tif (!ret) {\n\t\t \n\t\tmt9m111->power_count += on ? 1 : -1;\n\t\tWARN_ON(mt9m111->power_count < 0);\n\t}\n\n\tmutex_unlock(&mt9m111->power_lock);\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops mt9m111_ctrl_ops = {\n\t.s_ctrl = mt9m111_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops mt9m111_subdev_core_ops = {\n\t.s_power\t= mt9m111_s_power,\n\t.log_status = v4l2_ctrl_subdev_log_status,\n\t.subscribe_event = v4l2_ctrl_subdev_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register\t= mt9m111_g_register,\n\t.s_register\t= mt9m111_s_register,\n#endif\n};\n\nstatic int mt9m111_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *fi)\n{\n\tstruct mt9m111 *mt9m111 = container_of(sd, struct mt9m111, subdev);\n\n\tfi->interval = mt9m111->frame_interval;\n\n\treturn 0;\n}\n\nstatic int mt9m111_s_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *fi)\n{\n\tstruct mt9m111 *mt9m111 = container_of(sd, struct mt9m111, subdev);\n\tconst struct mt9m111_mode_info *mode;\n\tstruct v4l2_fract *fract = &fi->interval;\n\tint fps;\n\n\tif (mt9m111->is_streaming)\n\t\treturn -EBUSY;\n\n\tif (fi->pad != 0)\n\t\treturn -EINVAL;\n\n\tif (fract->numerator == 0) {\n\t\tfract->denominator = 30;\n\t\tfract->numerator = 1;\n\t}\n\n\tfps = DIV_ROUND_CLOSEST(fract->denominator, fract->numerator);\n\n\t \n\tmode = mt9m111_find_mode(mt9m111, fps, mt9m111->width, mt9m111->height);\n\tif (!mode)\n\t\treturn 0;\n\n\tif (mode->max_fps != fps) {\n\t\tfract->denominator = mode->max_fps;\n\t\tfract->numerator = 1;\n\t}\n\n\tmt9m111->current_mode = mode;\n\tmt9m111->frame_interval = fi->interval;\n\n\treturn 0;\n}\n\nstatic int mt9m111_enum_mbus_code(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index >= ARRAY_SIZE(mt9m111_colour_fmts))\n\t\treturn -EINVAL;\n\n\tcode->code = mt9m111_colour_fmts[code->index].code;\n\treturn 0;\n}\n\nstatic int mt9m111_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct mt9m111 *mt9m111 = container_of(sd, struct mt9m111, subdev);\n\n\tmt9m111->is_streaming = !!enable;\n\treturn 0;\n}\n\nstatic int mt9m111_init_cfg(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state)\n{\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\n\tstruct v4l2_mbus_framefmt *format =\n\t\tv4l2_subdev_get_try_format(sd, sd_state, 0);\n\n\tformat->width\t= MT9M111_MAX_WIDTH;\n\tformat->height\t= MT9M111_MAX_HEIGHT;\n\tformat->code\t= mt9m111_colour_fmts[0].code;\n\tformat->colorspace\t= mt9m111_colour_fmts[0].colorspace;\n\tformat->field\t= V4L2_FIELD_NONE;\n\tformat->ycbcr_enc\t= V4L2_YCBCR_ENC_DEFAULT;\n\tformat->quantization\t= V4L2_QUANTIZATION_DEFAULT;\n\tformat->xfer_func\t= V4L2_XFER_FUNC_DEFAULT;\n#endif\n\treturn 0;\n}\n\nstatic int mt9m111_get_mbus_config(struct v4l2_subdev *sd,\n\t\t\t\t   unsigned int pad,\n\t\t\t\t   struct v4l2_mbus_config *cfg)\n{\n\tstruct mt9m111 *mt9m111 = container_of(sd, struct mt9m111, subdev);\n\n\tcfg->type = V4L2_MBUS_PARALLEL;\n\n\tcfg->bus.parallel.flags = V4L2_MBUS_MASTER |\n\t\t\t\t  V4L2_MBUS_HSYNC_ACTIVE_HIGH |\n\t\t\t\t  V4L2_MBUS_VSYNC_ACTIVE_HIGH |\n\t\t\t\t  V4L2_MBUS_DATA_ACTIVE_HIGH;\n\n\tcfg->bus.parallel.flags |= mt9m111->pclk_sample ?\n\t\t\t\t   V4L2_MBUS_PCLK_SAMPLE_RISING :\n\t\t\t\t   V4L2_MBUS_PCLK_SAMPLE_FALLING;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops mt9m111_subdev_video_ops = {\n\t.s_stream\t= mt9m111_s_stream,\n\t.g_frame_interval = mt9m111_g_frame_interval,\n\t.s_frame_interval = mt9m111_s_frame_interval,\n};\n\nstatic const struct v4l2_subdev_pad_ops mt9m111_subdev_pad_ops = {\n\t.init_cfg\t= mt9m111_init_cfg,\n\t.enum_mbus_code = mt9m111_enum_mbus_code,\n\t.get_selection\t= mt9m111_get_selection,\n\t.set_selection\t= mt9m111_set_selection,\n\t.get_fmt\t= mt9m111_get_fmt,\n\t.set_fmt\t= mt9m111_set_fmt,\n\t.get_mbus_config = mt9m111_get_mbus_config,\n};\n\nstatic const struct v4l2_subdev_ops mt9m111_subdev_ops = {\n\t.core\t= &mt9m111_subdev_core_ops,\n\t.video\t= &mt9m111_subdev_video_ops,\n\t.pad\t= &mt9m111_subdev_pad_ops,\n};\n\n \nstatic int mt9m111_video_probe(struct i2c_client *client)\n{\n\tstruct mt9m111 *mt9m111 = to_mt9m111(client);\n\ts32 data;\n\tint ret;\n\n\tret = mt9m111_s_power(&mt9m111->subdev, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata = reg_read(CHIP_VERSION);\n\n\tswitch (data) {\n\tcase 0x143a:  \n\t\tdev_info(&client->dev,\n\t\t\t\"Detected a MT9M111/MT9M131 chip ID %x\\n\", data);\n\t\tbreak;\n\tcase 0x148c:  \n\t\tdev_info(&client->dev, \"Detected a MT9M112 chip ID %x\\n\", data);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev,\n\t\t\t\"No MT9M111/MT9M112/MT9M131 chip detected register read %x\\n\",\n\t\t\tdata);\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tret = mt9m111_init(mt9m111);\n\tif (ret)\n\t\tgoto done;\n\n\tret = v4l2_ctrl_handler_setup(&mt9m111->hdl);\n\ndone:\n\tmt9m111_s_power(&mt9m111->subdev, 0);\n\treturn ret;\n}\n\nstatic int mt9m111_probe_fw(struct i2c_client *client, struct mt9m111 *mt9m111)\n{\n\tstruct v4l2_fwnode_endpoint bus_cfg = {\n\t\t.bus_type = V4L2_MBUS_PARALLEL\n\t};\n\tstruct fwnode_handle *np;\n\tint ret;\n\n\tnp = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);\n\tif (!np)\n\t\treturn -EINVAL;\n\n\tret = v4l2_fwnode_endpoint_parse(np, &bus_cfg);\n\tif (ret)\n\t\tgoto out_put_fw;\n\n\tmt9m111->pclk_sample = !!(bus_cfg.bus.parallel.flags &\n\t\t\t\t  V4L2_MBUS_PCLK_SAMPLE_RISING);\n\nout_put_fw:\n\tfwnode_handle_put(np);\n\treturn ret;\n}\n\nstatic int mt9m111_probe(struct i2c_client *client)\n{\n\tstruct mt9m111 *mt9m111;\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint ret;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA)) {\n\t\tdev_warn(&adapter->dev,\n\t\t\t \"I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmt9m111 = devm_kzalloc(&client->dev, sizeof(struct mt9m111), GFP_KERNEL);\n\tif (!mt9m111)\n\t\treturn -ENOMEM;\n\n\tif (dev_fwnode(&client->dev)) {\n\t\tret = mt9m111_probe_fw(client, mt9m111);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmt9m111->clk = devm_clk_get(&client->dev, \"mclk\");\n\tif (IS_ERR(mt9m111->clk))\n\t\treturn PTR_ERR(mt9m111->clk);\n\n\tmt9m111->regulator = devm_regulator_get(&client->dev, \"vdd\");\n\tif (IS_ERR(mt9m111->regulator)) {\n\t\tdev_err(&client->dev, \"regulator not found: %ld\\n\",\n\t\t\tPTR_ERR(mt9m111->regulator));\n\t\treturn PTR_ERR(mt9m111->regulator);\n\t}\n\n\t \n\tmt9m111->ctx = &context_b;\n\n\tv4l2_i2c_subdev_init(&mt9m111->subdev, client, &mt9m111_subdev_ops);\n\tmt9m111->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |\n\t\t\t\t V4L2_SUBDEV_FL_HAS_EVENTS;\n\n\tv4l2_ctrl_handler_init(&mt9m111->hdl, 7);\n\tv4l2_ctrl_new_std(&mt9m111->hdl, &mt9m111_ctrl_ops,\n\t\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(&mt9m111->hdl, &mt9m111_ctrl_ops,\n\t\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(&mt9m111->hdl, &mt9m111_ctrl_ops,\n\t\t\tV4L2_CID_AUTO_WHITE_BALANCE, 0, 1, 1, 1);\n\tmt9m111->gain = v4l2_ctrl_new_std(&mt9m111->hdl, &mt9m111_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, 0, 63 * 2 * 2, 1, 32);\n\tv4l2_ctrl_new_std_menu(&mt9m111->hdl,\n\t\t\t&mt9m111_ctrl_ops, V4L2_CID_EXPOSURE_AUTO, 1, 0,\n\t\t\tV4L2_EXPOSURE_AUTO);\n\tv4l2_ctrl_new_std_menu_items(&mt9m111->hdl,\n\t\t\t&mt9m111_ctrl_ops, V4L2_CID_TEST_PATTERN,\n\t\t\tARRAY_SIZE(mt9m111_test_pattern_menu) - 1, 0, 0,\n\t\t\tmt9m111_test_pattern_menu);\n\tv4l2_ctrl_new_std_menu(&mt9m111->hdl, &mt9m111_ctrl_ops,\n\t\t\tV4L2_CID_COLORFX, V4L2_COLORFX_SOLARIZATION,\n\t\t\t~(BIT(V4L2_COLORFX_NONE) |\n\t\t\t\tBIT(V4L2_COLORFX_BW) |\n\t\t\t\tBIT(V4L2_COLORFX_SEPIA) |\n\t\t\t\tBIT(V4L2_COLORFX_NEGATIVE) |\n\t\t\t\tBIT(V4L2_COLORFX_SOLARIZATION)),\n\t\t\tV4L2_COLORFX_NONE);\n\tmt9m111->subdev.ctrl_handler = &mt9m111->hdl;\n\tif (mt9m111->hdl.error) {\n\t\tret = mt9m111->hdl.error;\n\t\treturn ret;\n\t}\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tmt9m111->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tmt9m111->subdev.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tret = media_entity_pads_init(&mt9m111->subdev.entity, 1, &mt9m111->pad);\n\tif (ret < 0)\n\t\tgoto out_hdlfree;\n#endif\n\n\tmt9m111->current_mode = &mt9m111_mode_data[MT9M111_MODE_SXGA_15FPS];\n\tmt9m111->frame_interval.numerator = 1;\n\tmt9m111->frame_interval.denominator = mt9m111->current_mode->max_fps;\n\n\t \n\tmt9m111->rect.left\t= MT9M111_MIN_DARK_COLS;\n\tmt9m111->rect.top\t= MT9M111_MIN_DARK_ROWS;\n\tmt9m111->rect.width\t= MT9M111_MAX_WIDTH;\n\tmt9m111->rect.height\t= MT9M111_MAX_HEIGHT;\n\tmt9m111->width\t\t= mt9m111->rect.width;\n\tmt9m111->height\t\t= mt9m111->rect.height;\n\tmt9m111->fmt\t\t= &mt9m111_colour_fmts[0];\n\tmt9m111->lastpage\t= -1;\n\tmutex_init(&mt9m111->power_lock);\n\n\tret = mt9m111_video_probe(client);\n\tif (ret < 0)\n\t\tgoto out_entityclean;\n\n\tmt9m111->subdev.dev = &client->dev;\n\tret = v4l2_async_register_subdev(&mt9m111->subdev);\n\tif (ret < 0)\n\t\tgoto out_entityclean;\n\n\treturn 0;\n\nout_entityclean:\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tmedia_entity_cleanup(&mt9m111->subdev.entity);\nout_hdlfree:\n#endif\n\tv4l2_ctrl_handler_free(&mt9m111->hdl);\n\n\treturn ret;\n}\n\nstatic void mt9m111_remove(struct i2c_client *client)\n{\n\tstruct mt9m111 *mt9m111 = to_mt9m111(client);\n\n\tv4l2_async_unregister_subdev(&mt9m111->subdev);\n\tmedia_entity_cleanup(&mt9m111->subdev.entity);\n\tv4l2_ctrl_handler_free(&mt9m111->hdl);\n}\nstatic const struct of_device_id mt9m111_of_match[] = {\n\t{ .compatible = \"micron,mt9m111\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mt9m111_of_match);\n\nstatic const struct i2c_device_id mt9m111_id[] = {\n\t{ \"mt9m111\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, mt9m111_id);\n\nstatic struct i2c_driver mt9m111_i2c_driver = {\n\t.driver = {\n\t\t.name = \"mt9m111\",\n\t\t.of_match_table = mt9m111_of_match,\n\t},\n\t.probe\t\t= mt9m111_probe,\n\t.remove\t\t= mt9m111_remove,\n\t.id_table\t= mt9m111_id,\n};\n\nmodule_i2c_driver(mt9m111_i2c_driver);\n\nMODULE_DESCRIPTION(\"Micron/Aptina MT9M111/MT9M112/MT9M131 Camera driver\");\nMODULE_AUTHOR(\"Robert Jarzmik\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}