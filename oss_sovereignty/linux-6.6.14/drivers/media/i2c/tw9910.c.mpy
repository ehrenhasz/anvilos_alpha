{
  "module_name": "tw9910.c",
  "hash_id": "1315a97af87213bf4ca0389267e021a5a47dd8110554f7f00884917b71eb32ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/tw9910.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/v4l2-mediabus.h>\n#include <linux/videodev2.h>\n\n#include <media/i2c/tw9910.h>\n#include <media/v4l2-subdev.h>\n\n#define GET_ID(val)  ((val & 0xF8) >> 3)\n#define GET_REV(val) (val & 0x07)\n\n \n#define ID\t\t0x00  \n#define STATUS1\t\t0x01  \n#define INFORM\t\t0x02  \n#define OPFORM\t\t0x03  \n#define DLYCTR\t\t0x04  \n#define OUTCTR1\t\t0x05  \n#define ACNTL1\t\t0x06  \n#define CROP_HI\t\t0x07  \n#define VDELAY_LO\t0x08  \n#define VACTIVE_LO\t0x09  \n#define HDELAY_LO\t0x0A  \n#define HACTIVE_LO\t0x0B  \n#define CNTRL1\t\t0x0C  \n#define VSCALE_LO\t0x0D  \n#define SCALE_HI\t0x0E  \n#define HSCALE_LO\t0x0F  \n#define BRIGHT\t\t0x10  \n#define CONTRAST\t0x11  \n#define SHARPNESS\t0x12  \n#define SAT_U\t\t0x13  \n#define SAT_V\t\t0x14  \n#define HUE\t\t0x15  \n#define CORING1\t\t0x17\n#define CORING2\t\t0x18  \n#define VBICNTL\t\t0x19  \n#define ACNTL2\t\t0x1A  \n#define OUTCTR2\t\t0x1B  \n#define SDT\t\t0x1C  \n#define SDTR\t\t0x1D  \n#define TEST\t\t0x1F  \n#define CLMPG\t\t0x20  \n#define IAGC\t\t0x21  \n#define AGCGAIN\t\t0x22  \n#define PEAKWT\t\t0x23  \n#define CLMPL\t\t0x24  \n#define SYNCT\t\t0x25  \n#define MISSCNT\t\t0x26  \n#define PCLAMP\t\t0x27  \n#define VCNTL1\t\t0x28  \n#define VCNTL2\t\t0x29  \n#define CKILL\t\t0x2A  \n#define COMB\t\t0x2B  \n#define LDLY\t\t0x2C  \n#define MISC1\t\t0x2D  \n#define LOOP\t\t0x2E  \n#define MISC2\t\t0x2F  \n#define MVSN\t\t0x30  \n#define STATUS2\t\t0x31  \n#define HFREF\t\t0x32  \n#define CLMD\t\t0x33  \n#define IDCNTL\t\t0x34  \n#define CLCNTL1\t\t0x35  \n#define ANAPLLCTL\t0x4C\n#define VBIMIN\t\t0x4D\n#define HSLOWCTL\t0x4E\n#define WSS3\t\t0x4F\n#define FILLDATA\t0x50\n#define SDID\t\t0x51\n#define DID\t\t0x52\n#define WSS1\t\t0x53\n#define WSS2\t\t0x54\n#define VVBI\t\t0x55\n#define LCTL6\t\t0x56\n#define LCTL7\t\t0x57\n#define LCTL8\t\t0x58\n#define LCTL9\t\t0x59\n#define LCTL10\t\t0x5A\n#define LCTL11\t\t0x5B\n#define LCTL12\t\t0x5C\n#define LCTL13\t\t0x5D\n#define LCTL14\t\t0x5E\n#define LCTL15\t\t0x5F\n#define LCTL16\t\t0x60\n#define LCTL17\t\t0x61\n#define LCTL18\t\t0x62\n#define LCTL19\t\t0x63\n#define LCTL20\t\t0x64\n#define LCTL21\t\t0x65\n#define LCTL22\t\t0x66\n#define LCTL23\t\t0x67\n#define LCTL24\t\t0x68\n#define LCTL25\t\t0x69\n#define LCTL26\t\t0x6A\n#define HSBEGIN\t\t0x6B\n#define HSEND\t\t0x6C\n#define OVSDLY\t\t0x6D\n#define OVSEND\t\t0x6E\n#define VBIDELAY\t0x6F\n\n \n\n \n#define FC27_ON     0x40  \n#define FC27_FF     0x00  \n\t\t\t  \n\t\t\t  \n#define IFSEL_S     0x10  \n#define IFSEL_C     0x00  \n\t\t\t  \n#define YSEL_M0     0x00  \n#define YSEL_M1     0x04  \n#define YSEL_M2     0x08  \n#define YSEL_M3     0x10  \n\n \n#define MODE        0x80  \n\t\t\t  \n#define LEN         0x40  \n\t\t\t  \n#define LLCMODE     0x20  \n\t\t\t  \n#define AINC        0x10  \n\t\t\t  \n\t\t\t  \n#define VSCTL       0x08  \n\t\t\t  \n#define OEN_TRI_SEL_MASK\t0x07\n#define OEN_TRI_SEL_ALL_ON\t0x00  \n#define OEN_TRI_SEL_ALL_OFF_r0\t0x06  \n#define OEN_TRI_SEL_ALL_OFF_r1\t0x07  \n\n \n#define VSP_LO      0x00  \n#define VSP_HI      0x80  \n\t\t\t  \n#define VSSL_VSYNC  0x00  \n#define VSSL_VACT   0x10  \n#define VSSL_FIELD  0x20  \n#define VSSL_VVALID 0x30  \n#define VSSL_ZERO   0x70  \n#define HSP_LOW     0x00  \n#define HSP_HI      0x08  \n\t\t\t  \n#define HSSL_HACT   0x00  \n#define HSSL_HSYNC  0x01  \n#define HSSL_DVALID 0x02  \n#define HSSL_HLOCK  0x03  \n#define HSSL_ASYNCW 0x04  \n#define HSSL_ZERO   0x07  \n\n \n#define SRESET      0x80  \n#define ACNTL1_PDN_MASK\t0x0e\n#define CLK_PDN\t\t0x08  \n#define Y_PDN\t\t0x04  \n#define C_PDN\t\t0x02  \n\n \n#define ACNTL2_PDN_MASK\t0x40\n#define PLL_PDN\t\t0x40  \n\n \n\n \n#define RTSEL_MASK  0x07\n#define RTSEL_VLOSS 0x00  \n#define RTSEL_HLOCK 0x01  \n#define RTSEL_SLOCK 0x02  \n#define RTSEL_VLOCK 0x03  \n#define RTSEL_MONO  0x04  \n#define RTSEL_DET50 0x05  \n#define RTSEL_FIELD 0x06  \n#define RTSEL_RTCO  0x07  \n\n \n#define HSYNC_START\t0x0260\n#define HSYNC_END\t0x0300\n\n \n\nstruct regval_list {\n\tunsigned char reg_num;\n\tunsigned char value;\n};\n\nstruct tw9910_scale_ctrl {\n\tchar           *name;\n\tunsigned short  width;\n\tunsigned short  height;\n\tu16             hscale;\n\tu16             vscale;\n};\n\nstruct tw9910_priv {\n\tstruct v4l2_subdev\t\tsubdev;\n\tstruct clk\t\t\t*clk;\n\tstruct tw9910_video_info\t*info;\n\tstruct gpio_desc\t\t*pdn_gpio;\n\tstruct gpio_desc\t\t*rstb_gpio;\n\tconst struct tw9910_scale_ctrl\t*scale;\n\tv4l2_std_id\t\t\tnorm;\n\tu32\t\t\t\trevision;\n};\n\nstatic const struct tw9910_scale_ctrl tw9910_ntsc_scales[] = {\n\t{\n\t\t.name   = \"NTSC SQ\",\n\t\t.width  = 640,\n\t\t.height = 480,\n\t\t.hscale = 0x0100,\n\t\t.vscale = 0x0100,\n\t},\n\t{\n\t\t.name   = \"NTSC CCIR601\",\n\t\t.width  = 720,\n\t\t.height = 480,\n\t\t.hscale = 0x0100,\n\t\t.vscale = 0x0100,\n\t},\n\t{\n\t\t.name   = \"NTSC SQ (CIF)\",\n\t\t.width  = 320,\n\t\t.height = 240,\n\t\t.hscale = 0x0200,\n\t\t.vscale = 0x0200,\n\t},\n\t{\n\t\t.name   = \"NTSC CCIR601 (CIF)\",\n\t\t.width  = 360,\n\t\t.height = 240,\n\t\t.hscale = 0x0200,\n\t\t.vscale = 0x0200,\n\t},\n\t{\n\t\t.name   = \"NTSC SQ (QCIF)\",\n\t\t.width  = 160,\n\t\t.height = 120,\n\t\t.hscale = 0x0400,\n\t\t.vscale = 0x0400,\n\t},\n\t{\n\t\t.name   = \"NTSC CCIR601 (QCIF)\",\n\t\t.width  = 180,\n\t\t.height = 120,\n\t\t.hscale = 0x0400,\n\t\t.vscale = 0x0400,\n\t},\n};\n\nstatic const struct tw9910_scale_ctrl tw9910_pal_scales[] = {\n\t{\n\t\t.name   = \"PAL SQ\",\n\t\t.width  = 768,\n\t\t.height = 576,\n\t\t.hscale = 0x0100,\n\t\t.vscale = 0x0100,\n\t},\n\t{\n\t\t.name   = \"PAL CCIR601\",\n\t\t.width  = 720,\n\t\t.height = 576,\n\t\t.hscale = 0x0100,\n\t\t.vscale = 0x0100,\n\t},\n\t{\n\t\t.name   = \"PAL SQ (CIF)\",\n\t\t.width  = 384,\n\t\t.height = 288,\n\t\t.hscale = 0x0200,\n\t\t.vscale = 0x0200,\n\t},\n\t{\n\t\t.name   = \"PAL CCIR601 (CIF)\",\n\t\t.width  = 360,\n\t\t.height = 288,\n\t\t.hscale = 0x0200,\n\t\t.vscale = 0x0200,\n\t},\n\t{\n\t\t.name   = \"PAL SQ (QCIF)\",\n\t\t.width  = 192,\n\t\t.height = 144,\n\t\t.hscale = 0x0400,\n\t\t.vscale = 0x0400,\n\t},\n\t{\n\t\t.name   = \"PAL CCIR601 (QCIF)\",\n\t\t.width  = 180,\n\t\t.height = 144,\n\t\t.hscale = 0x0400,\n\t\t.vscale = 0x0400,\n\t},\n};\n\n \nstatic struct tw9910_priv *to_tw9910(const struct i2c_client *client)\n{\n\treturn container_of(i2c_get_clientdata(client), struct tw9910_priv,\n\t\t\t    subdev);\n}\n\nstatic int tw9910_mask_set(struct i2c_client *client, u8 command,\n\t\t\t   u8 mask, u8 set)\n{\n\ts32 val = i2c_smbus_read_byte_data(client, command);\n\n\tif (val < 0)\n\t\treturn val;\n\n\tval &= ~mask;\n\tval |= set & mask;\n\n\treturn i2c_smbus_write_byte_data(client, command, val);\n}\n\nstatic int tw9910_set_scale(struct i2c_client *client,\n\t\t\t    const struct tw9910_scale_ctrl *scale)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, SCALE_HI,\n\t\t\t\t\t(scale->vscale & 0x0F00) >> 4 |\n\t\t\t\t\t(scale->hscale & 0x0F00) >> 8);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(client, HSCALE_LO,\n\t\t\t\t\tscale->hscale & 0x00FF);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(client, VSCALE_LO,\n\t\t\t\t\tscale->vscale & 0x00FF);\n\n\treturn ret;\n}\n\nstatic int tw9910_set_hsync(struct i2c_client *client)\n{\n\tstruct tw9910_priv *priv = to_tw9910(client);\n\tint ret;\n\n\t \n\tret = i2c_smbus_write_byte_data(client, HSBEGIN,\n\t\t\t\t\t(HSYNC_START & 0x07F8) >> 3);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = i2c_smbus_write_byte_data(client, HSEND,\n\t\t\t\t\t(HSYNC_END & 0x07F8) >> 3);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\t \n\tif (priv->revision == 1)\n\t\tret = tw9910_mask_set(client, HSLOWCTL, 0x77,\n\t\t\t\t      (HSYNC_START & 0x0007) << 4 |\n\t\t\t\t      (HSYNC_END   & 0x0007));\n\n\treturn ret;\n}\n\nstatic void tw9910_reset(struct i2c_client *client)\n{\n\ttw9910_mask_set(client, ACNTL1, SRESET, SRESET);\n\tusleep_range(1000, 5000);\n}\n\nstatic int tw9910_power(struct i2c_client *client, int enable)\n{\n\tint ret;\n\tu8 acntl1;\n\tu8 acntl2;\n\n\tif (enable) {\n\t\tacntl1 = 0;\n\t\tacntl2 = 0;\n\t} else {\n\t\tacntl1 = CLK_PDN | Y_PDN | C_PDN;\n\t\tacntl2 = PLL_PDN;\n\t}\n\n\tret = tw9910_mask_set(client, ACNTL1, ACNTL1_PDN_MASK, acntl1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn tw9910_mask_set(client, ACNTL2, ACNTL2_PDN_MASK, acntl2);\n}\n\nstatic const struct tw9910_scale_ctrl *tw9910_select_norm(v4l2_std_id norm,\n\t\t\t\t\t\t\t  u32 width, u32 height)\n{\n\tconst struct tw9910_scale_ctrl *scale;\n\tconst struct tw9910_scale_ctrl *ret = NULL;\n\t__u32 diff = 0xffffffff, tmp;\n\tint size, i;\n\n\tif (norm & V4L2_STD_NTSC) {\n\t\tscale = tw9910_ntsc_scales;\n\t\tsize = ARRAY_SIZE(tw9910_ntsc_scales);\n\t} else if (norm & V4L2_STD_PAL) {\n\t\tscale = tw9910_pal_scales;\n\t\tsize = ARRAY_SIZE(tw9910_pal_scales);\n\t} else {\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\ttmp = abs(width - scale[i].width) +\n\t\t      abs(height - scale[i].height);\n\t\tif (tmp < diff) {\n\t\t\tdiff = tmp;\n\t\t\tret = scale + i;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int tw9910_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct tw9910_priv *priv = to_tw9910(client);\n\tu8 val;\n\tint ret;\n\n\tif (!enable) {\n\t\tswitch (priv->revision) {\n\t\tcase 0:\n\t\t\tval = OEN_TRI_SEL_ALL_OFF_r0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tval = OEN_TRI_SEL_ALL_OFF_r1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&client->dev, \"un-supported revision\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tval = OEN_TRI_SEL_ALL_ON;\n\n\t\tif (!priv->scale) {\n\t\t\tdev_err(&client->dev, \"norm select error\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\tdev_dbg(&client->dev, \"%s %dx%d\\n\",\n\t\t\tpriv->scale->name,\n\t\t\tpriv->scale->width,\n\t\t\tpriv->scale->height);\n\t}\n\n\tret = tw9910_mask_set(client, OPFORM, OEN_TRI_SEL_MASK, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn tw9910_power(client, enable);\n}\n\nstatic int tw9910_g_std(struct v4l2_subdev *sd, v4l2_std_id *norm)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct tw9910_priv *priv = to_tw9910(client);\n\n\t*norm = priv->norm;\n\n\treturn 0;\n}\n\nstatic int tw9910_s_std(struct v4l2_subdev *sd, v4l2_std_id norm)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct tw9910_priv *priv = to_tw9910(client);\n\tconst unsigned int hact = 720;\n\tconst unsigned int hdelay = 15;\n\tunsigned int vact;\n\tunsigned int vdelay;\n\tint ret;\n\n\tif (!(norm & (V4L2_STD_NTSC | V4L2_STD_PAL)))\n\t\treturn -EINVAL;\n\n\tpriv->norm = norm;\n\tif (norm & V4L2_STD_525_60) {\n\t\tvact = 240;\n\t\tvdelay = 18;\n\t\tret = tw9910_mask_set(client, VVBI, 0x10, 0x10);\n\t} else {\n\t\tvact = 288;\n\t\tvdelay = 24;\n\t\tret = tw9910_mask_set(client, VVBI, 0x10, 0x00);\n\t}\n\tif (!ret)\n\t\tret = i2c_smbus_write_byte_data(client, CROP_HI,\n\t\t\t\t\t\t((vdelay >> 2) & 0xc0)\t|\n\t\t\t\t\t\t((vact >> 4) & 0x30)\t|\n\t\t\t\t\t\t((hdelay >> 6) & 0x0c)\t|\n\t\t\t\t\t\t((hact >> 8) & 0x03));\n\tif (!ret)\n\t\tret = i2c_smbus_write_byte_data(client, VDELAY_LO,\n\t\t\t\t\t\tvdelay & 0xff);\n\tif (!ret)\n\t\tret = i2c_smbus_write_byte_data(client, VACTIVE_LO,\n\t\t\t\t\t\tvact & 0xff);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int tw9910_g_register(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_dbg_register *reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tif (reg->reg > 0xff)\n\t\treturn -EINVAL;\n\n\treg->size = 1;\n\tret = i2c_smbus_read_byte_data(client, reg->reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treg->val = (__u64)ret;\n\n\treturn 0;\n}\n\nstatic int tw9910_s_register(struct v4l2_subdev *sd,\n\t\t\t     const struct v4l2_dbg_register *reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tif (reg->reg > 0xff ||\n\t    reg->val > 0xff)\n\t\treturn -EINVAL;\n\n\treturn i2c_smbus_write_byte_data(client, reg->reg, reg->val);\n}\n#endif\n\nstatic void tw9910_set_gpio_value(struct gpio_desc *desc, int value)\n{\n\tif (desc) {\n\t\tgpiod_set_value(desc, value);\n\t\tusleep_range(500, 1000);\n\t}\n}\n\nstatic int tw9910_power_on(struct tw9910_priv *priv)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&priv->subdev);\n\tint ret;\n\n\tif (priv->clk) {\n\t\tret = clk_prepare_enable(priv->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\ttw9910_set_gpio_value(priv->pdn_gpio, 0);\n\n\t \n\tpriv->rstb_gpio = gpiod_get_optional(&client->dev, \"rstb\",\n\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->rstb_gpio)) {\n\t\tdev_info(&client->dev, \"Unable to get GPIO \\\"rstb\\\"\");\n\t\tclk_disable_unprepare(priv->clk);\n\t\ttw9910_set_gpio_value(priv->pdn_gpio, 1);\n\t\treturn PTR_ERR(priv->rstb_gpio);\n\t}\n\n\tif (priv->rstb_gpio) {\n\t\ttw9910_set_gpio_value(priv->rstb_gpio, 1);\n\t\ttw9910_set_gpio_value(priv->rstb_gpio, 0);\n\n\t\tgpiod_put(priv->rstb_gpio);\n\t}\n\n\treturn 0;\n}\n\nstatic int tw9910_power_off(struct tw9910_priv *priv)\n{\n\tclk_disable_unprepare(priv->clk);\n\ttw9910_set_gpio_value(priv->pdn_gpio, 1);\n\n\treturn 0;\n}\n\nstatic int tw9910_s_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct tw9910_priv *priv = to_tw9910(client);\n\n\treturn on ? tw9910_power_on(priv) : tw9910_power_off(priv);\n}\n\nstatic int tw9910_set_frame(struct v4l2_subdev *sd, u32 *width, u32 *height)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct tw9910_priv *priv = to_tw9910(client);\n\tint ret = -EINVAL;\n\tu8 val;\n\n\t \n\tpriv->scale = tw9910_select_norm(priv->norm, *width, *height);\n\tif (!priv->scale)\n\t\tgoto tw9910_set_fmt_error;\n\n\t \n\ttw9910_reset(client);\n\n\t \n\tval = 0x00;\n\tif (priv->info->buswidth == 16)\n\t\tval = LEN;\n\n\tret = tw9910_mask_set(client, OPFORM, LEN, val);\n\tif (ret < 0)\n\t\tgoto tw9910_set_fmt_error;\n\n\t \n\tswitch (priv->info->mpout) {\n\tcase TW9910_MPO_VLOSS:\n\t\tval = RTSEL_VLOSS; break;\n\tcase TW9910_MPO_HLOCK:\n\t\tval = RTSEL_HLOCK; break;\n\tcase TW9910_MPO_SLOCK:\n\t\tval = RTSEL_SLOCK; break;\n\tcase TW9910_MPO_VLOCK:\n\t\tval = RTSEL_VLOCK; break;\n\tcase TW9910_MPO_MONO:\n\t\tval = RTSEL_MONO;  break;\n\tcase TW9910_MPO_DET50:\n\t\tval = RTSEL_DET50; break;\n\tcase TW9910_MPO_FIELD:\n\t\tval = RTSEL_FIELD; break;\n\tcase TW9910_MPO_RTCO:\n\t\tval = RTSEL_RTCO;  break;\n\tdefault:\n\t\tval = 0;\n\t}\n\n\tret = tw9910_mask_set(client, VBICNTL, RTSEL_MASK, val);\n\tif (ret < 0)\n\t\tgoto tw9910_set_fmt_error;\n\n\t \n\tret = tw9910_set_scale(client, priv->scale);\n\tif (ret < 0)\n\t\tgoto tw9910_set_fmt_error;\n\n\t \n\tret = tw9910_set_hsync(client);\n\tif (ret < 0)\n\t\tgoto tw9910_set_fmt_error;\n\n\t*width = priv->scale->width;\n\t*height = priv->scale->height;\n\n\treturn ret;\n\ntw9910_set_fmt_error:\n\n\ttw9910_reset(client);\n\tpriv->scale = NULL;\n\n\treturn ret;\n}\n\nstatic int tw9910_get_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct tw9910_priv *priv = to_tw9910(client);\n\n\tif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn -EINVAL;\n\t \n\tif (sel->target > V4L2_SEL_TGT_CROP_BOUNDS)\n\t\treturn -EINVAL;\n\n\tsel->r.left\t= 0;\n\tsel->r.top\t= 0;\n\tif (priv->norm & V4L2_STD_NTSC) {\n\t\tsel->r.width\t= 640;\n\t\tsel->r.height\t= 480;\n\t} else {\n\t\tsel->r.width\t= 768;\n\t\tsel->r.height\t= 576;\n\t}\n\n\treturn 0;\n}\n\nstatic int tw9910_get_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct tw9910_priv *priv = to_tw9910(client);\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tif (!priv->scale) {\n\t\tpriv->scale = tw9910_select_norm(priv->norm, 640, 480);\n\t\tif (!priv->scale)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmf->width\t= priv->scale->width;\n\tmf->height\t= priv->scale->height;\n\tmf->code\t= MEDIA_BUS_FMT_UYVY8_2X8;\n\tmf->colorspace\t= V4L2_COLORSPACE_SMPTE170M;\n\tmf->field\t= V4L2_FIELD_INTERLACED_BT;\n\n\treturn 0;\n}\n\nstatic int tw9910_s_fmt(struct v4l2_subdev *sd,\n\t\t\tstruct v4l2_mbus_framefmt *mf)\n{\n\tu32 width = mf->width, height = mf->height;\n\tint ret;\n\n\tWARN_ON(mf->field != V4L2_FIELD_ANY &&\n\t\tmf->field != V4L2_FIELD_INTERLACED_BT);\n\n\t \n\tif (mf->code != MEDIA_BUS_FMT_UYVY8_2X8)\n\t\treturn -EINVAL;\n\n\tmf->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\tret = tw9910_set_frame(sd, &width, &height);\n\tif (ret)\n\t\treturn ret;\n\n\tmf->width\t= width;\n\tmf->height\t= height;\n\n\treturn 0;\n}\n\nstatic int tw9910_set_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct tw9910_priv *priv = to_tw9910(client);\n\tconst struct tw9910_scale_ctrl *scale;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tif (mf->field == V4L2_FIELD_ANY) {\n\t\tmf->field = V4L2_FIELD_INTERLACED_BT;\n\t} else if (mf->field != V4L2_FIELD_INTERLACED_BT) {\n\t\tdev_err(&client->dev, \"Field type %d invalid\\n\", mf->field);\n\t\treturn -EINVAL;\n\t}\n\n\tmf->code = MEDIA_BUS_FMT_UYVY8_2X8;\n\tmf->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\t \n\tscale = tw9910_select_norm(priv->norm, mf->width, mf->height);\n\tif (!scale)\n\t\treturn -EINVAL;\n\n\tmf->width\t= scale->width;\n\tmf->height\t= scale->height;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn tw9910_s_fmt(sd, mf);\n\n\tsd_state->pads->try_fmt = *mf;\n\n\treturn 0;\n}\n\nstatic int tw9910_video_probe(struct i2c_client *client)\n{\n\tstruct tw9910_priv *priv = to_tw9910(client);\n\ts32 id;\n\tint ret;\n\n\t \n\tif (priv->info->buswidth != 16 && priv->info->buswidth != 8) {\n\t\tdev_err(&client->dev, \"bus width error\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = tw9910_s_power(&priv->subdev, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tid = i2c_smbus_read_byte_data(client, ID);\n\tpriv->revision = GET_REV(id);\n\tid = GET_ID(id);\n\n\tif (id != 0x0b || priv->revision > 0x01) {\n\t\tdev_err(&client->dev, \"Product ID error %x:%x\\n\",\n\t\t\tid, priv->revision);\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tdev_info(&client->dev, \"tw9910 Product ID %0x:%0x\\n\",\n\t\t id, priv->revision);\n\n\tpriv->norm = V4L2_STD_NTSC;\n\tpriv->scale = &tw9910_ntsc_scales[0];\n\ndone:\n\ttw9910_s_power(&priv->subdev, 0);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_core_ops tw9910_subdev_core_ops = {\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register\t= tw9910_g_register,\n\t.s_register\t= tw9910_s_register,\n#endif\n\t.s_power\t= tw9910_s_power,\n};\n\nstatic int tw9910_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_UYVY8_2X8;\n\n\treturn 0;\n}\n\nstatic int tw9910_g_tvnorms(struct v4l2_subdev *sd, v4l2_std_id *norm)\n{\n\t*norm = V4L2_STD_NTSC | V4L2_STD_PAL;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops tw9910_subdev_video_ops = {\n\t.s_std\t\t= tw9910_s_std,\n\t.g_std\t\t= tw9910_g_std,\n\t.s_stream\t= tw9910_s_stream,\n\t.g_tvnorms\t= tw9910_g_tvnorms,\n};\n\nstatic const struct v4l2_subdev_pad_ops tw9910_subdev_pad_ops = {\n\t.enum_mbus_code = tw9910_enum_mbus_code,\n\t.get_selection\t= tw9910_get_selection,\n\t.get_fmt\t= tw9910_get_fmt,\n\t.set_fmt\t= tw9910_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops tw9910_subdev_ops = {\n\t.core\t= &tw9910_subdev_core_ops,\n\t.video\t= &tw9910_subdev_video_ops,\n\t.pad\t= &tw9910_subdev_pad_ops,\n};\n\n \n\nstatic int tw9910_probe(struct i2c_client *client)\n\n{\n\tstruct tw9910_priv\t\t*priv;\n\tstruct tw9910_video_info\t*info;\n\tstruct i2c_adapter\t\t*adapter = client->adapter;\n\tint ret;\n\n\tif (!client->dev.platform_data) {\n\t\tdev_err(&client->dev, \"TW9910: missing platform data!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinfo = client->dev.platform_data;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"I2C-Adapter doesn't support I2C_FUNC_SMBUS_BYTE_DATA\\n\");\n\t\treturn -EIO;\n\t}\n\n\tpriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->info = info;\n\n\tv4l2_i2c_subdev_init(&priv->subdev, client, &tw9910_subdev_ops);\n\n\tpriv->clk = clk_get(&client->dev, \"xti\");\n\tif (PTR_ERR(priv->clk) == -ENOENT) {\n\t\tpriv->clk = NULL;\n\t} else if (IS_ERR(priv->clk)) {\n\t\tdev_err(&client->dev, \"Unable to get xti clock\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\tpriv->pdn_gpio = gpiod_get_optional(&client->dev, \"pdn\",\n\t\t\t\t\t    GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->pdn_gpio)) {\n\t\tdev_info(&client->dev, \"Unable to get GPIO \\\"pdn\\\"\");\n\t\tret = PTR_ERR(priv->pdn_gpio);\n\t\tgoto error_clk_put;\n\t}\n\n\tret = tw9910_video_probe(client);\n\tif (ret < 0)\n\t\tgoto error_gpio_put;\n\n\tret = v4l2_async_register_subdev(&priv->subdev);\n\tif (ret)\n\t\tgoto error_gpio_put;\n\n\treturn ret;\n\nerror_gpio_put:\n\tif (priv->pdn_gpio)\n\t\tgpiod_put(priv->pdn_gpio);\nerror_clk_put:\n\tclk_put(priv->clk);\n\n\treturn ret;\n}\n\nstatic void tw9910_remove(struct i2c_client *client)\n{\n\tstruct tw9910_priv *priv = to_tw9910(client);\n\n\tif (priv->pdn_gpio)\n\t\tgpiod_put(priv->pdn_gpio);\n\tclk_put(priv->clk);\n\tv4l2_async_unregister_subdev(&priv->subdev);\n}\n\nstatic const struct i2c_device_id tw9910_id[] = {\n\t{ \"tw9910\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tw9910_id);\n\nstatic struct i2c_driver tw9910_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tw9910\",\n\t},\n\t.probe    = tw9910_probe,\n\t.remove   = tw9910_remove,\n\t.id_table = tw9910_id,\n};\n\nmodule_i2c_driver(tw9910_i2c_driver);\n\nMODULE_DESCRIPTION(\"V4L2 driver for TW9910 video decoder\");\nMODULE_AUTHOR(\"Kuninori Morimoto\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}