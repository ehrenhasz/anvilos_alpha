{
  "module_name": "tc358746.c",
  "hash_id": "51d59960ded3c2da29c414dc8de599feefed10ae575edde2d76c3ba3531d3f0e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/tc358746.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/phy/phy-mipi-dphy.h>\n#include <linux/property.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/units.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-mc.h>\n\n \n#define CHIPID_REG\t\t\t0x0000\n#define\t\tCHIPID\t\t\tGENMASK(15, 8)\n\n#define SYSCTL_REG\t\t\t0x0002\n#define\t\tSRESET\t\t\tBIT(0)\n\n#define CONFCTL_REG\t\t\t0x0004\n#define\t\tPDATAF_MASK\t\tGENMASK(9, 8)\n#define\t\tPDATAF_MODE0\t\t0\n#define\t\tPDATAF_MODE1\t\t1\n#define\t\tPDATAF_MODE2\t\t2\n#define\t\tPDATAF(val)\t\tFIELD_PREP(PDATAF_MASK, (val))\n#define\t\tPPEN\t\t\tBIT(6)\n#define\t\tDATALANE_MASK\t\tGENMASK(1, 0)\n\n#define FIFOCTL_REG\t\t\t0x0006\n#define DATAFMT_REG\t\t\t0x0008\n#define\t\tPDFMT(val)\t\tFIELD_PREP(GENMASK(7, 4), (val))\n\n#define MCLKCTL_REG\t\t\t0x000c\n#define\t\tMCLK_HIGH_MASK\t\tGENMASK(15, 8)\n#define\t\tMCLK_LOW_MASK\t\tGENMASK(7, 0)\n#define\t\tMCLK_HIGH(val)\t\tFIELD_PREP(MCLK_HIGH_MASK, (val))\n#define\t\tMCLK_LOW(val)\t\tFIELD_PREP(MCLK_LOW_MASK, (val))\n\n#define PLLCTL0_REG\t\t\t0x0016\n#define\t\tPLL_PRD_MASK\t\tGENMASK(15, 12)\n#define\t\tPLL_PRD(val)\t\tFIELD_PREP(PLL_PRD_MASK, (val))\n#define\t\tPLL_FBD_MASK\t\tGENMASK(8, 0)\n#define\t\tPLL_FBD(val)\t\tFIELD_PREP(PLL_FBD_MASK, (val))\n\n#define PLLCTL1_REG\t\t\t0x0018\n#define\t\tPLL_FRS_MASK\t\tGENMASK(11, 10)\n#define\t\tPLL_FRS(val)\t\tFIELD_PREP(PLL_FRS_MASK, (val))\n#define\t\tCKEN\t\t\tBIT(4)\n#define\t\tRESETB\t\t\tBIT(1)\n#define\t\tPLL_EN\t\t\tBIT(0)\n\n#define CLKCTL_REG\t\t\t0x0020\n#define\t\tMCLKDIV_MASK\t\tGENMASK(3, 2)\n#define\t\tMCLKDIV(val)\t\tFIELD_PREP(MCLKDIV_MASK, (val))\n#define\t\tMCLKDIV_8\t\t0\n#define\t\tMCLKDIV_4\t\t1\n#define\t\tMCLKDIV_2\t\t2\n\n#define WORDCNT_REG\t\t\t0x0022\n#define PP_MISC_REG\t\t\t0x0032\n#define\t\tFRMSTOP\t\t\tBIT(15)\n#define\t\tRSTPTR\t\t\tBIT(14)\n\n \n#define CLW_DPHYCONTTX_REG\t\t0x0100\n#define CLW_CNTRL_REG\t\t\t0x0140\n#define D0W_CNTRL_REG\t\t\t0x0144\n#define\t\tLANEDISABLE\t\tBIT(0)\n\n#define STARTCNTRL_REG\t\t\t0x0204\n#define\t\tSTART\t\t\tBIT(0)\n\n#define LINEINITCNT_REG\t\t\t0x0210\n#define LPTXTIMECNT_REG\t\t\t0x0214\n#define TCLK_HEADERCNT_REG\t\t0x0218\n#define\t\tTCLK_ZEROCNT(val)\tFIELD_PREP(GENMASK(15, 8), (val))\n#define\t\tTCLK_PREPARECNT(val)\tFIELD_PREP(GENMASK(6, 0), (val))\n\n#define TCLK_TRAILCNT_REG\t\t0x021C\n#define THS_HEADERCNT_REG\t\t0x0220\n#define\t\tTHS_ZEROCNT(val)\tFIELD_PREP(GENMASK(14, 8), (val))\n#define\t\tTHS_PREPARECNT(val)\tFIELD_PREP(GENMASK(6, 0), (val))\n\n#define TWAKEUP_REG\t\t\t0x0224\n#define TCLK_POSTCNT_REG\t\t0x0228\n#define THS_TRAILCNT_REG\t\t0x022C\n#define HSTXVREGEN_REG\t\t\t0x0234\n#define TXOPTIONCNTRL_REG\t\t0x0238\n#define CSI_CONTROL_REG\t\t\t0x040C\n#define\t\tCSI_MODE\t\tBIT(15)\n#define\t\tTXHSMD\t\t\tBIT(7)\n#define\t\tNOL(val)\t\tFIELD_PREP(GENMASK(2, 1), (val))\n\n#define CSI_CONFW_REG\t\t\t0x0500\n#define\t\tMODE(val)\t\tFIELD_PREP(GENMASK(31, 29), (val))\n#define\t\tMODE_SET\t\t0x5\n#define\t\tADDRESS(val)\t\tFIELD_PREP(GENMASK(28, 24), (val))\n#define\t\tCSI_CONTROL_ADDRESS\t0x3\n#define\t\tDATA(val)\t\tFIELD_PREP(GENMASK(15, 0), (val))\n\n#define CSI_START_REG\t\t\t0x0518\n#define\t\tSTRT\t\t\tBIT(0)\n\nstatic const struct v4l2_mbus_framefmt tc358746_def_fmt = {\n\t.width\t\t= 640,\n\t.height\t\t= 480,\n\t.code\t\t= MEDIA_BUS_FMT_UYVY8_2X8,\n\t.field\t\t= V4L2_FIELD_NONE,\n\t.colorspace\t= V4L2_COLORSPACE_DEFAULT,\n\t.ycbcr_enc\t= V4L2_YCBCR_ENC_DEFAULT,\n\t.quantization\t= V4L2_QUANTIZATION_DEFAULT,\n\t.xfer_func\t= V4L2_XFER_FUNC_DEFAULT,\n};\n\nstatic const char * const tc358746_supplies[] = {\n\t\"vddc\", \"vddio\", \"vddmipi\"\n};\n\nenum {\n\tTC358746_SINK,\n\tTC358746_SOURCE,\n\tTC358746_NR_PADS\n};\n\nstruct tc358746 {\n\tstruct v4l2_subdev\t\tsd;\n\tstruct media_pad\t\tpads[TC358746_NR_PADS];\n\tstruct v4l2_async_notifier\tnotifier;\n\tstruct v4l2_fwnode_endpoint\tcsi_vep;\n\n\tstruct v4l2_ctrl_handler\tctrl_hdl;\n\n\tstruct regmap\t\t\t*regmap;\n\tstruct clk\t\t\t*refclk;\n\tstruct gpio_desc\t\t*reset_gpio;\n\tstruct regulator_bulk_data\tsupplies[ARRAY_SIZE(tc358746_supplies)];\n\n\tstruct clk_hw\t\t\tmclk_hw;\n\tunsigned long\t\t\tmclk_rate;\n\tu8\t\t\t\tmclk_prediv;\n\tu16\t\t\t\tmclk_postdiv;\n\n\tunsigned long\t\t\tpll_rate;\n\tu8\t\t\t\tpll_post_div;\n\tu16\t\t\t\tpll_pre_div;\n\tu16\t\t\t\tpll_mul;\n\n#define TC358746_VB_MAX_SIZE\t\t(511 * 32)\n#define TC358746_VB_DEFAULT_SIZE\t  (1 * 32)\n\tunsigned int\t\t\tvb_size;  \n\n\tstruct phy_configure_opts_mipi_dphy dphy_cfg;\n};\n\nstatic inline struct tc358746 *to_tc358746(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct tc358746, sd);\n}\n\nstatic inline struct tc358746 *clk_hw_to_tc358746(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct tc358746, mclk_hw);\n}\n\nstruct tc358746_format {\n\tu32\t\tcode;\n\tbool\t\tcsi_format;\n\tunsigned char\tbus_width;\n\tunsigned char\tbpp;\n\t \n\tu8\t\tpdformat;  \n\tu8\t\tpdataf;    \n};\n\nenum {\n\tPDFORMAT_RAW8 = 0,\n\tPDFORMAT_RAW10,\n\tPDFORMAT_RAW12,\n\tPDFORMAT_RGB888,\n\tPDFORMAT_RGB666,\n\tPDFORMAT_RGB565,\n\tPDFORMAT_YUV422_8BIT,\n\t \n\tPDFORMAT_RAW14 = 8,\n\tPDFORMAT_YUV422_10BIT,\n\tPDFORMAT_YUV444,\n};\n\n \nstatic const struct tc358746_format tc358746_formats[] = {\n\t{\n\t\t.code = MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t.bus_width = 8,\n\t\t.bpp = 16,\n\t\t.pdformat = PDFORMAT_YUV422_8BIT,\n\t\t.pdataf = PDATAF_MODE0,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_UYVY8_1X16,\n\t\t.csi_format = true,\n\t\t.bus_width = 16,\n\t\t.bpp = 16,\n\t\t.pdformat = PDFORMAT_YUV422_8BIT,\n\t\t.pdataf = PDATAF_MODE1,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_YUYV8_1X16,\n\t\t.csi_format = true,\n\t\t.bus_width = 16,\n\t\t.bpp = 16,\n\t\t.pdformat = PDFORMAT_YUV422_8BIT,\n\t\t.pdataf = PDATAF_MODE2,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_UYVY10_2X10,\n\t\t.bus_width = 10,\n\t\t.bpp = 20,\n\t\t.pdformat = PDFORMAT_YUV422_10BIT,\n\t\t.pdataf = PDATAF_MODE0,  \n\t}\n};\n\n \nstatic const struct tc358746_format *\ntc358746_get_format_by_idx(unsigned int pad, unsigned int index)\n{\n\tunsigned int idx = 0;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tc358746_formats); i++) {\n\t\tconst struct tc358746_format *fmt = &tc358746_formats[i];\n\n\t\tif ((pad == TC358746_SOURCE && fmt->csi_format) ||\n\t\t    (pad == TC358746_SINK)) {\n\t\t\tif (idx == index)\n\t\t\t\treturn fmt;\n\t\t\tidx++;\n\t\t}\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic const struct tc358746_format *\ntc358746_get_format_by_code(unsigned int pad, u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tc358746_formats); i++) {\n\t\tconst struct tc358746_format *fmt = &tc358746_formats[i];\n\n\t\tif (pad == TC358746_SINK && fmt->code == code)\n\t\t\treturn fmt;\n\n\t\tif (pad == TC358746_SOURCE && !fmt->csi_format)\n\t\t\tcontinue;\n\n\t\tif (fmt->code == code)\n\t\t\treturn fmt;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic u32 tc358746_src_mbus_code(u32 code)\n{\n\tswitch (code) {\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\t\treturn MEDIA_BUS_FMT_UYVY8_1X16;\n\tcase MEDIA_BUS_FMT_UYVY10_2X10:\n\t\treturn MEDIA_BUS_FMT_UYVY10_1X20;\n\tdefault:\n\t\treturn code;\n\t}\n}\n\nstatic bool tc358746_valid_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CHIPID_REG ... CSI_START_REG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config tc358746_regmap_config = {\n\t.name = \"tc358746\",\n\t.reg_bits = 16,\n\t.val_bits = 16,\n\t.max_register = CSI_START_REG,\n\t.writeable_reg = tc358746_valid_reg,\n\t.readable_reg = tc358746_valid_reg,\n\t.reg_format_endian = REGMAP_ENDIAN_BIG,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n};\n\nstatic int tc358746_write(struct tc358746 *tc358746, u32 reg, u32 val)\n{\n\tsize_t count;\n\tint err;\n\n\t \n\tcount = reg < CLW_DPHYCONTTX_REG ? 1 : 2;\n\n\terr = regmap_bulk_write(tc358746->regmap, reg, &val, count);\n\tif (err)\n\t\tdev_err(tc358746->sd.dev,\n\t\t\t\"Failed to write reg:0x%04x err:%d\\n\", reg, err);\n\n\treturn err;\n}\n\nstatic int tc358746_read(struct tc358746 *tc358746, u32 reg, u32 *val)\n{\n\tsize_t count;\n\tint err;\n\n\t \n\tcount = reg < CLW_DPHYCONTTX_REG ? 1 : 2;\n\t*val = 0;\n\n\terr = regmap_bulk_read(tc358746->regmap, reg, val, count);\n\tif (err)\n\t\tdev_err(tc358746->sd.dev,\n\t\t\t\"Failed to read reg:0x%04x err:%d\\n\", reg, err);\n\n\treturn err;\n}\n\nstatic int\ntc358746_update_bits(struct tc358746 *tc358746, u32 reg, u32 mask, u32 val)\n{\n\tu32 tmp, orig;\n\tint err;\n\n\terr = tc358746_read(tc358746, reg, &orig);\n\tif (err)\n\t\treturn err;\n\n\ttmp = orig & ~mask;\n\ttmp |= val & mask;\n\n\treturn tc358746_write(tc358746, reg, tmp);\n}\n\nstatic int tc358746_set_bits(struct tc358746 *tc358746, u32 reg, u32 bits)\n{\n\treturn tc358746_update_bits(tc358746, reg, bits, bits);\n}\n\nstatic int tc358746_clear_bits(struct tc358746 *tc358746, u32 reg, u32 bits)\n{\n\treturn tc358746_update_bits(tc358746, reg, bits, 0);\n}\n\nstatic int tc358746_sw_reset(struct tc358746 *tc358746)\n{\n\tint err;\n\n\terr = tc358746_set_bits(tc358746, SYSCTL_REG, SRESET);\n\tif (err)\n\t\treturn err;\n\n\tfsleep(10);\n\n\treturn tc358746_clear_bits(tc358746, SYSCTL_REG, SRESET);\n}\n\nstatic int\ntc358746_apply_pll_config(struct tc358746 *tc358746)\n{\n\tu8 post = tc358746->pll_post_div;\n\tu16 pre = tc358746->pll_pre_div;\n\tu16 mul = tc358746->pll_mul;\n\tu32 val, mask;\n\tint err;\n\n\terr = tc358746_read(tc358746, PLLCTL1_REG, &val);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (FIELD_GET(PLL_EN, val) == 1)\n\t\treturn 0;\n\n\t \n\tval = PLL_PRD(pre - 1) | PLL_FBD(mul - 1);\n\tmask = PLL_PRD_MASK | PLL_FBD_MASK;\n\terr = tc358746_update_bits(tc358746, PLLCTL0_REG, mask, val);\n\tif (err)\n\t\treturn err;\n\n\tval = PLL_FRS(ilog2(post)) | RESETB | PLL_EN;\n\tmask = PLL_FRS_MASK | RESETB | PLL_EN;\n\terr = tc358746_update_bits(tc358746, PLLCTL1_REG, mask, val);\n\tif (err)\n\t\treturn err;\n\n\tfsleep(1000);\n\n\treturn tc358746_set_bits(tc358746, PLLCTL1_REG, CKEN);\n}\n\nstatic int tc358746_apply_misc_config(struct tc358746 *tc358746)\n{\n\tconst struct v4l2_mbus_framefmt *mbusfmt;\n\tstruct v4l2_subdev *sd = &tc358746->sd;\n\tstruct v4l2_subdev_state *sink_state;\n\tconst struct tc358746_format *fmt;\n\tstruct device *dev = sd->dev;\n\tu32 val;\n\tint err;\n\n\tsink_state = v4l2_subdev_lock_and_get_active_state(sd);\n\n\tmbusfmt = v4l2_subdev_get_pad_format(sd, sink_state, TC358746_SINK);\n\tfmt = tc358746_get_format_by_code(TC358746_SINK, mbusfmt->code);\n\n\t \n\tval = PDFMT(fmt->pdformat);\n\tdev_dbg(dev, \"DATAFMT: 0x%x\\n\", val);\n\terr = tc358746_write(tc358746, DATAFMT_REG, val);\n\tif (err)\n\t\tgoto out;\n\n\tval = PDATAF(fmt->pdataf);\n\tdev_dbg(dev, \"CONFCTL[PDATAF]: 0x%x\\n\", fmt->pdataf);\n\terr = tc358746_update_bits(tc358746, CONFCTL_REG, PDATAF_MASK, val);\n\tif (err)\n\t\tgoto out;\n\n\tval = tc358746->vb_size / 32;\n\tdev_dbg(dev, \"FIFOCTL: %u (0x%x)\\n\", val, val);\n\terr = tc358746_write(tc358746, FIFOCTL_REG, val);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tval = mbusfmt->width * fmt->bpp / 8;\n\tdev_dbg(dev, \"WORDCNT: %u (0x%x)\\n\", val, val);\n\terr = tc358746_write(tc358746, WORDCNT_REG, val);\n\nout:\n\tv4l2_subdev_unlock_state(sink_state);\n\n\treturn err;\n}\n\n \nstatic u32 tc358746_cfg_to_cnt(unsigned int cfg_val,\n\t\t\t       unsigned int clk_mhz,\n\t\t\t       unsigned int time_base)\n{\n\treturn DIV_ROUND_UP(cfg_val * clk_mhz, time_base);\n}\n\nstatic u32 tc358746_ps_to_cnt(unsigned int cfg_val,\n\t\t\t      unsigned int clk_mhz)\n{\n\treturn tc358746_cfg_to_cnt(cfg_val, clk_mhz, USEC_PER_SEC);\n}\n\nstatic u32 tc358746_us_to_cnt(unsigned int cfg_val,\n\t\t\t      unsigned int clk_mhz)\n{\n\treturn tc358746_cfg_to_cnt(cfg_val, clk_mhz, 1);\n}\n\nstatic int tc358746_apply_dphy_config(struct tc358746 *tc358746)\n{\n\tstruct phy_configure_opts_mipi_dphy *cfg = &tc358746->dphy_cfg;\n\tbool non_cont_clk = !!(tc358746->csi_vep.bus.mipi_csi2.flags &\n\t\t\t       V4L2_MBUS_CSI2_NONCONTINUOUS_CLOCK);\n\tstruct device *dev = tc358746->sd.dev;\n\tunsigned long hs_byte_clk, hf_clk;\n\tu32 val, val2, lptxcnt;\n\tint err;\n\n\t \n\ths_byte_clk = cfg->hs_clk_rate / 8;\n\ths_byte_clk /= HZ_PER_MHZ;\n\thf_clk = hs_byte_clk / 2;\n\n\tval = tc358746_us_to_cnt(cfg->init, hf_clk) - 1;\n\tdev_dbg(dev, \"LINEINITCNT: %u (0x%x)\\n\", val, val);\n\terr = tc358746_write(tc358746, LINEINITCNT_REG, val);\n\tif (err)\n\t\treturn err;\n\n\tval = tc358746_ps_to_cnt(cfg->lpx, hs_byte_clk) - 1;\n\tlptxcnt = val;\n\tdev_dbg(dev, \"LPTXTIMECNT: %u (0x%x)\\n\", val, val);\n\terr = tc358746_write(tc358746, LPTXTIMECNT_REG, val);\n\tif (err)\n\t\treturn err;\n\n\tval = tc358746_ps_to_cnt(cfg->clk_prepare, hs_byte_clk) - 1;\n\tval2 = tc358746_ps_to_cnt(cfg->clk_zero, hs_byte_clk) - 1;\n\tdev_dbg(dev, \"TCLK_PREPARECNT: %u (0x%x)\\n\", val, val);\n\tdev_dbg(dev, \"TCLK_ZEROCNT: %u (0x%x)\\n\", val2, val2);\n\tdev_dbg(dev, \"TCLK_HEADERCNT: 0x%x\\n\",\n\t\t(u32)(TCLK_PREPARECNT(val) | TCLK_ZEROCNT(val2)));\n\terr = tc358746_write(tc358746, TCLK_HEADERCNT_REG,\n\t\t\t     TCLK_PREPARECNT(val) | TCLK_ZEROCNT(val2));\n\tif (err)\n\t\treturn err;\n\n\tval = tc358746_ps_to_cnt(cfg->clk_trail, hs_byte_clk);\n\tdev_dbg(dev, \"TCLK_TRAILCNT: %u (0x%x)\\n\", val, val);\n\terr = tc358746_write(tc358746, TCLK_TRAILCNT_REG, val);\n\tif (err)\n\t\treturn err;\n\n\tval = tc358746_ps_to_cnt(cfg->hs_prepare, hs_byte_clk) - 1;\n\tval2 = tc358746_ps_to_cnt(cfg->hs_zero, hs_byte_clk) - 1;\n\tdev_dbg(dev, \"THS_PREPARECNT: %u (0x%x)\\n\", val, val);\n\tdev_dbg(dev, \"THS_ZEROCNT: %u (0x%x)\\n\", val2, val2);\n\tdev_dbg(dev, \"THS_HEADERCNT: 0x%x\\n\",\n\t\t(u32)(THS_PREPARECNT(val) | THS_ZEROCNT(val2)));\n\terr = tc358746_write(tc358746, THS_HEADERCNT_REG,\n\t\t\t     THS_PREPARECNT(val) | THS_ZEROCNT(val2));\n\tif (err)\n\t\treturn err;\n\n\t \n\tval = tc358746_us_to_cnt(cfg->wakeup, hs_byte_clk);\n\tval = val / (lptxcnt + 1) - 1;\n\tdev_dbg(dev, \"TWAKEUP: %u (0x%x)\\n\", val, val);\n\terr = tc358746_write(tc358746, TWAKEUP_REG, val);\n\tif (err)\n\t\treturn err;\n\n\tval = tc358746_ps_to_cnt(cfg->clk_post, hs_byte_clk);\n\tdev_dbg(dev, \"TCLK_POSTCNT: %u (0x%x)\\n\", val, val);\n\terr = tc358746_write(tc358746, TCLK_POSTCNT_REG, val);\n\tif (err)\n\t\treturn err;\n\n\tval = tc358746_ps_to_cnt(cfg->hs_trail, hs_byte_clk);\n\tdev_dbg(dev, \"THS_TRAILCNT: %u (0x%x)\\n\", val, val);\n\terr = tc358746_write(tc358746, THS_TRAILCNT_REG, val);\n\tif (err)\n\t\treturn err;\n\n\tdev_dbg(dev, \"CONTCLKMODE: %u\", non_cont_clk ? 0 : 1);\n\n\treturn  tc358746_write(tc358746, TXOPTIONCNTRL_REG, non_cont_clk ? 0 : 1);\n}\n\n#define MAX_DATA_LANES 4\n\nstatic int tc358746_enable_csi_lanes(struct tc358746 *tc358746, int enable)\n{\n\tunsigned int lanes = tc358746->dphy_cfg.lanes;\n\tunsigned int lane;\n\tu32 reg, val;\n\tint err;\n\n\terr = tc358746_update_bits(tc358746, CONFCTL_REG, DATALANE_MASK,\n\t\t\t\t   lanes - 1);\n\tif (err)\n\t\treturn err;\n\n\t \n\tval = enable ? 0 : LANEDISABLE;\n\tdev_dbg(tc358746->sd.dev, \"CLW_CNTRL: 0x%x\\n\", val);\n\terr = tc358746_write(tc358746, CLW_CNTRL_REG, val);\n\tif (err)\n\t\treturn err;\n\n\tfor (lane = 0; lane < MAX_DATA_LANES; lane++) {\n\t\t \n\t\treg = D0W_CNTRL_REG + lane * 0x4;\n\t\tval = (enable && lane < lanes) ? 0 : LANEDISABLE;\n\n\t\tdev_dbg(tc358746->sd.dev, \"D%uW_CNTRL: 0x%x\\n\", lane, val);\n\t\terr = tc358746_write(tc358746, reg, val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tval = 0;\n\tif (enable) {\n\t\t \n\t\tval |= BIT(0);\n\n\t\t \n\t\tfor (lane = 1; lane <= lanes; lane++)\n\t\t\tval |= BIT(lane);\n\t}\n\n\tdev_dbg(tc358746->sd.dev, \"HSTXVREGEN: 0x%x\\n\", val);\n\n\treturn tc358746_write(tc358746, HSTXVREGEN_REG, val);\n}\n\nstatic int tc358746_enable_csi_module(struct tc358746 *tc358746, int enable)\n{\n\tunsigned int lanes = tc358746->dphy_cfg.lanes;\n\tint err;\n\n\t \n\tif (!enable)\n\t\treturn tc358746_sw_reset(tc358746);\n\n\terr = tc358746_write(tc358746, STARTCNTRL_REG, START);\n\tif (err)\n\t\treturn err;\n\n\terr = tc358746_write(tc358746, CSI_START_REG, STRT);\n\tif (err)\n\t\treturn err;\n\n\t \n\treturn tc358746_write(tc358746, CSI_CONFW_REG,\n\t\t\t      MODE(MODE_SET) |\n\t\t\t      ADDRESS(CSI_CONTROL_ADDRESS) |\n\t\t\t      DATA(CSI_MODE | TXHSMD | NOL(lanes - 1)));\n}\n\nstatic int tc358746_enable_parallel_port(struct tc358746 *tc358746, int enable)\n{\n\tint err;\n\n\tif (enable) {\n\t\terr = tc358746_write(tc358746, PP_MISC_REG, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn tc358746_set_bits(tc358746, CONFCTL_REG, PPEN);\n\t}\n\n\terr = tc358746_set_bits(tc358746, PP_MISC_REG, FRMSTOP);\n\tif (err)\n\t\treturn err;\n\n\terr = tc358746_clear_bits(tc358746, CONFCTL_REG, PPEN);\n\tif (err)\n\t\treturn err;\n\n\treturn tc358746_set_bits(tc358746, PP_MISC_REG, RSTPTR);\n}\n\nstatic inline struct v4l2_subdev *tc358746_get_remote_sd(struct media_pad *pad)\n{\n\tpad = media_pad_remote_pad_first(pad);\n\tif (!pad)\n\t\treturn NULL;\n\n\treturn media_entity_to_v4l2_subdev(pad->entity);\n}\n\nstatic int tc358746_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct tc358746 *tc358746 = to_tc358746(sd);\n\tstruct v4l2_subdev *src;\n\tint err;\n\n\tdev_dbg(sd->dev, \"%sable\\n\", enable ? \"en\" : \"dis\");\n\n\tsrc = tc358746_get_remote_sd(&tc358746->pads[TC358746_SINK]);\n\tif (!src)\n\t\treturn -EPIPE;\n\n\tif (enable) {\n\t\terr = pm_runtime_resume_and_get(sd->dev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = tc358746_apply_dphy_config(tc358746);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\terr = tc358746_apply_misc_config(tc358746);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\terr = tc358746_enable_csi_lanes(tc358746, 1);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\terr = tc358746_enable_csi_module(tc358746, 1);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\terr = tc358746_enable_parallel_port(tc358746, 1);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\terr = v4l2_subdev_call(src, video, s_stream, 1);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\treturn 0;\n\nerr_out:\n\t\tpm_runtime_mark_last_busy(sd->dev);\n\t\tpm_runtime_put_sync_autosuspend(sd->dev);\n\n\t\treturn err;\n\t}\n\n\t \n\terr = tc358746_enable_csi_lanes(tc358746, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = tc358746_enable_csi_module(tc358746, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = tc358746_enable_parallel_port(tc358746, 0);\n\tif (err)\n\t\treturn err;\n\n\tpm_runtime_mark_last_busy(sd->dev);\n\tpm_runtime_put_sync_autosuspend(sd->dev);\n\n\treturn v4l2_subdev_call(src, video, s_stream, 0);\n}\n\nstatic int tc358746_init_cfg(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *state)\n{\n\tstruct v4l2_mbus_framefmt *fmt;\n\n\tfmt = v4l2_subdev_get_pad_format(sd, state, TC358746_SINK);\n\t*fmt = tc358746_def_fmt;\n\n\tfmt = v4l2_subdev_get_pad_format(sd, state, TC358746_SOURCE);\n\t*fmt = tc358746_def_fmt;\n\tfmt->code = tc358746_src_mbus_code(tc358746_def_fmt.code);\n\n\treturn 0;\n}\n\nstatic int tc358746_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_mbus_code_enum *code)\n{\n\tconst struct tc358746_format *fmt;\n\n\tfmt = tc358746_get_format_by_idx(code->pad, code->index);\n\tif (IS_ERR(fmt))\n\t\treturn PTR_ERR(fmt);\n\n\tcode->code = fmt->code;\n\n\treturn 0;\n}\n\nstatic int tc358746_set_fmt(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *src_fmt, *sink_fmt;\n\tconst struct tc358746_format *fmt;\n\n\t \n\tif (format->pad == TC358746_SOURCE)\n\t\treturn v4l2_subdev_get_fmt(sd, sd_state, format);\n\n\tsink_fmt = v4l2_subdev_get_pad_format(sd, sd_state, TC358746_SINK);\n\n\tfmt = tc358746_get_format_by_code(format->pad, format->format.code);\n\tif (IS_ERR(fmt))\n\t\tfmt = tc358746_get_format_by_code(format->pad, tc358746_def_fmt.code);\n\n\tformat->format.code = fmt->code;\n\tformat->format.field = V4L2_FIELD_NONE;\n\n\tdev_dbg(sd->dev, \"Update format: %ux%u code:0x%x -> %ux%u code:0x%x\",\n\t\tsink_fmt->width, sink_fmt->height, sink_fmt->code,\n\t\tformat->format.width, format->format.height, format->format.code);\n\n\t*sink_fmt = format->format;\n\n\tsrc_fmt = v4l2_subdev_get_pad_format(sd, sd_state, TC358746_SOURCE);\n\t*src_fmt = *sink_fmt;\n\tsrc_fmt->code = tc358746_src_mbus_code(sink_fmt->code);\n\n\treturn 0;\n}\n\nstatic unsigned long tc358746_find_pll_settings(struct tc358746 *tc358746,\n\t\t\t\t\t\tunsigned long refclk,\n\t\t\t\t\t\tunsigned long fout)\n\n{\n\tstruct device *dev = tc358746->sd.dev;\n\tunsigned long best_freq = 0;\n\tu32 min_delta = 0xffffffff;\n\tu16 prediv_max = 17;\n\tu16 prediv_min = 1;\n\tu16 m_best = 0, mul;\n\tu16 p_best = 1, p;\n\tu8 postdiv;\n\n\tif (fout > 1000 * HZ_PER_MHZ) {\n\t\tdev_err(dev, \"HS-Clock above 1 Ghz are not supported\\n\");\n\t\treturn 0;\n\t}\n\n\tif (fout >= 500 * HZ_PER_MHZ)\n\t\tpostdiv = 1;\n\telse if (fout >= 250 * HZ_PER_MHZ)\n\t\tpostdiv = 2;\n\telse if (fout >= 125 * HZ_PER_MHZ)\n\t\tpostdiv = 4;\n\telse\n\t\tpostdiv = 8;\n\n\tfor (p = prediv_min; p <= prediv_max; p++) {\n\t\tunsigned long delta, fin;\n\t\tu64 tmp;\n\n\t\tfin = DIV_ROUND_CLOSEST(refclk, p);\n\t\tif (fin < 4 * HZ_PER_MHZ || fin > 40 * HZ_PER_MHZ)\n\t\t\tcontinue;\n\n\t\ttmp = fout * p * postdiv;\n\t\tdo_div(tmp, fin);\n\t\tmul = tmp;\n\t\tif (mul > 511)\n\t\t\tcontinue;\n\n\t\ttmp = mul * fin;\n\t\tdo_div(tmp, p * postdiv);\n\n\t\tdelta = abs(fout - tmp);\n\t\tif (delta < min_delta) {\n\t\t\tp_best = p;\n\t\t\tm_best = mul;\n\t\t\tmin_delta = delta;\n\t\t\tbest_freq = tmp;\n\t\t}\n\n\t\tif (delta == 0)\n\t\t\tbreak;\n\t}\n\n\tif (!best_freq) {\n\t\tdev_err(dev, \"Failed find PLL frequency\\n\");\n\t\treturn 0;\n\t}\n\n\ttc358746->pll_post_div = postdiv;\n\ttc358746->pll_pre_div = p_best;\n\ttc358746->pll_mul = m_best;\n\n\tif (best_freq != fout)\n\t\tdev_warn(dev, \"Request PLL freq:%lu, found PLL freq:%lu\\n\",\n\t\t\t fout, best_freq);\n\n\tdev_dbg(dev, \"Found PLL settings: freq:%lu prediv:%u multi:%u postdiv:%u\\n\",\n\t\tbest_freq, p_best, m_best, postdiv);\n\n\treturn best_freq;\n}\n\n#define TC358746_PRECISION 10\n\nstatic int\ntc358746_link_validate(struct v4l2_subdev *sd, struct media_link *link,\n\t\t       struct v4l2_subdev_format *source_fmt,\n\t\t       struct v4l2_subdev_format *sink_fmt)\n{\n\tstruct tc358746 *tc358746 = to_tc358746(sd);\n\tunsigned long csi_bitrate, source_bitrate;\n\tstruct v4l2_subdev_state *sink_state;\n\tstruct v4l2_mbus_framefmt *mbusfmt;\n\tconst struct tc358746_format *fmt;\n\tunsigned int fifo_sz, tmp, n;\n\tstruct v4l2_subdev *source;\n\ts64 source_link_freq;\n\tint err;\n\n\terr = v4l2_subdev_link_validate_default(sd, link, source_fmt, sink_fmt);\n\tif (err)\n\t\treturn err;\n\n\tsink_state = v4l2_subdev_lock_and_get_active_state(sd);\n\tmbusfmt = v4l2_subdev_get_pad_format(sd, sink_state, TC358746_SINK);\n\n\t \n\tfmt = tc358746_get_format_by_code(TC358746_SINK, mbusfmt->code);\n\n\tsource = media_entity_to_v4l2_subdev(link->source->entity);\n\tsource_link_freq = v4l2_get_link_freq(source->ctrl_handler, 0, 0);\n\tif (source_link_freq <= 0) {\n\t\tdev_err(tc358746->sd.dev,\n\t\t\t\"Failed to query or invalid source link frequency\\n\");\n\t\tv4l2_subdev_unlock_state(sink_state);\n\t\t \n\t\treturn source_link_freq ? : -EINVAL;\n\t}\n\tsource_bitrate = source_link_freq * fmt->bus_width;\n\n\tcsi_bitrate = tc358746->dphy_cfg.lanes * tc358746->pll_rate;\n\n\tdev_dbg(tc358746->sd.dev,\n\t\t\"Fifo settings params: source-bitrate:%lu csi-bitrate:%lu\",\n\t\tsource_bitrate, csi_bitrate);\n\n\t \n\tif (csi_bitrate < source_bitrate) {\n\t\tv4l2_subdev_unlock_state(sink_state);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (csi_bitrate == source_bitrate) {\n\t\tfifo_sz = TC358746_VB_DEFAULT_SIZE;\n\t\ttc358746->vb_size = TC358746_VB_DEFAULT_SIZE;\n\t\tgoto out;\n\t}\n\n\t \n\n\tsource_bitrate /= TC358746_PRECISION;\n\tn = csi_bitrate / source_bitrate;\n\ttmp = (mbusfmt->width * TC358746_PRECISION) / n;\n\tfifo_sz = mbusfmt->width - tmp;\n\tfifo_sz *= fmt->bpp;\n\ttc358746->vb_size = round_up(fifo_sz, 32);\n\nout:\n\tdev_dbg(tc358746->sd.dev,\n\t\t\"Found FIFO size[bits]:%u -> aligned to size[bits]:%u\\n\",\n\t\tfifo_sz, tc358746->vb_size);\n\n\tv4l2_subdev_unlock_state(sink_state);\n\n\treturn tc358746->vb_size > TC358746_VB_MAX_SIZE ? -EINVAL : 0;\n}\n\nstatic int tc358746_get_mbus_config(struct v4l2_subdev *sd, unsigned int pad,\n\t\t\t\t    struct v4l2_mbus_config *config)\n{\n\tstruct tc358746 *tc358746 = to_tc358746(sd);\n\n\tif (pad != TC358746_SOURCE)\n\t\treturn -EINVAL;\n\n\tconfig->type = V4L2_MBUS_CSI2_DPHY;\n\tconfig->bus.mipi_csi2 = tc358746->csi_vep.bus.mipi_csi2;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused\ntc358746_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\n{\n\tstruct tc358746 *tc358746 = to_tc358746(sd);\n\tu32 val;\n\tint err;\n\n\t \n\treg->size = reg->reg < CLW_DPHYCONTTX_REG ? 2 : 4;\n\n\tif (!pm_runtime_get_if_in_use(sd->dev))\n\t\treturn 0;\n\n\terr = tc358746_read(tc358746, reg->reg, &val);\n\treg->val = val;\n\n\tpm_runtime_mark_last_busy(sd->dev);\n\tpm_runtime_put_sync_autosuspend(sd->dev);\n\n\treturn err;\n}\n\nstatic int __maybe_unused\ntc358746_s_register(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg)\n{\n\tstruct tc358746 *tc358746 = to_tc358746(sd);\n\n\tif (!pm_runtime_get_if_in_use(sd->dev))\n\t\treturn 0;\n\n\ttc358746_write(tc358746, (u32)reg->reg, (u32)reg->val);\n\n\tpm_runtime_mark_last_busy(sd->dev);\n\tpm_runtime_put_sync_autosuspend(sd->dev);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops tc358746_core_ops = {\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = tc358746_g_register,\n\t.s_register = tc358746_s_register,\n#endif\n};\n\nstatic const struct v4l2_subdev_video_ops tc358746_video_ops = {\n\t.s_stream = tc358746_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops tc358746_pad_ops = {\n\t.init_cfg = tc358746_init_cfg,\n\t.enum_mbus_code = tc358746_enum_mbus_code,\n\t.set_fmt = tc358746_set_fmt,\n\t.get_fmt = v4l2_subdev_get_fmt,\n\t.link_validate = tc358746_link_validate,\n\t.get_mbus_config = tc358746_get_mbus_config,\n};\n\nstatic const struct v4l2_subdev_ops tc358746_ops = {\n\t.core = &tc358746_core_ops,\n\t.video = &tc358746_video_ops,\n\t.pad = &tc358746_pad_ops,\n};\n\nstatic const struct media_entity_operations tc358746_entity_ops = {\n\t.get_fwnode_pad = v4l2_subdev_get_fwnode_pad_1_to_1,\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic int tc358746_mclk_enable(struct clk_hw *hw)\n{\n\tstruct tc358746 *tc358746 = clk_hw_to_tc358746(hw);\n\tunsigned int div;\n\tu32 val;\n\tint err;\n\n\tdiv = tc358746->mclk_postdiv / 2;\n\tval = MCLK_HIGH(div - 1) | MCLK_LOW(div - 1);\n\tdev_dbg(tc358746->sd.dev, \"MCLKCTL: %u (0x%x)\\n\", val, val);\n\terr = tc358746_write(tc358746, MCLKCTL_REG, val);\n\tif (err)\n\t\treturn err;\n\n\tif (tc358746->mclk_prediv == 8)\n\t\tval = MCLKDIV(MCLKDIV_8);\n\telse if (tc358746->mclk_prediv == 4)\n\t\tval = MCLKDIV(MCLKDIV_4);\n\telse\n\t\tval = MCLKDIV(MCLKDIV_2);\n\n\tdev_dbg(tc358746->sd.dev, \"CLKCTL[MCLKDIV]: %u (0x%x)\\n\", val, val);\n\n\treturn tc358746_update_bits(tc358746, CLKCTL_REG, MCLKDIV_MASK, val);\n}\n\nstatic void tc358746_mclk_disable(struct clk_hw *hw)\n{\n\tstruct tc358746 *tc358746 = clk_hw_to_tc358746(hw);\n\n\ttc358746_write(tc358746, MCLKCTL_REG, 0);\n}\n\nstatic long\ntc358746_find_mclk_settings(struct tc358746 *tc358746, unsigned long mclk_rate)\n{\n\tunsigned long pll_rate = tc358746->pll_rate;\n\tconst unsigned char prediv[] = { 2, 4, 8 };\n\tunsigned int mclk_prediv, mclk_postdiv;\n\tstruct device *dev = tc358746->sd.dev;\n\tunsigned int postdiv, mclkdiv;\n\tunsigned long best_mclk_rate;\n\tunsigned int i;\n\n\t \n\n\tif (mclk_rate == tc358746->mclk_rate)\n\t\treturn mclk_rate;\n\n\t \n\tmclkdiv = pll_rate / mclk_rate;\n\tif (mclkdiv <= 8) {\n\t\tmclk_prediv = 2;\n\t\tmclk_postdiv = 4;\n\t\tbest_mclk_rate = pll_rate / (2 * 4);\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(prediv); i++) {\n\t\tpostdiv = mclkdiv / prediv[i];\n\n\t\tif (postdiv % 2)\n\t\t\tcontinue;\n\n\t\tif (postdiv >= 4 && postdiv <= 512) {\n\t\t\tmclk_prediv = prediv[i];\n\t\t\tmclk_postdiv = postdiv;\n\t\t\tbest_mclk_rate = pll_rate / (prediv[i] * postdiv);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tfor (postdiv = 4; postdiv <= 512; postdiv += 2) {\n\t\tunsigned int pre;\n\n\t\tpre = mclkdiv / postdiv;\n\t\tif (pre == 2 || pre == 4 || pre == 8) {\n\t\t\tmclk_prediv = pre;\n\t\t\tmclk_postdiv = postdiv;\n\t\t\tbest_mclk_rate = pll_rate / (pre * postdiv);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tmclk_prediv = 8;\n\tmclk_postdiv = 512;\n\tbest_mclk_rate = pll_rate / (8 * 512);\n\nout:\n\ttc358746->mclk_prediv = mclk_prediv;\n\ttc358746->mclk_postdiv = mclk_postdiv;\n\ttc358746->mclk_rate = best_mclk_rate;\n\n\tif (best_mclk_rate != mclk_rate)\n\t\tdev_warn(dev, \"Request MCLK freq:%lu, found MCLK freq:%lu\\n\",\n\t\t\t mclk_rate, best_mclk_rate);\n\n\tdev_dbg(dev, \"Found MCLK settings: freq:%lu prediv:%u postdiv:%u\\n\",\n\t\tbest_mclk_rate, mclk_prediv, mclk_postdiv);\n\n\treturn best_mclk_rate;\n}\n\nstatic unsigned long\ntc358746_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct tc358746 *tc358746 = clk_hw_to_tc358746(hw);\n\tunsigned int prediv, postdiv;\n\tu32 val;\n\tint err;\n\n\terr = tc358746_read(tc358746, MCLKCTL_REG, &val);\n\tif (err)\n\t\treturn 0;\n\n\tpostdiv = FIELD_GET(MCLK_LOW_MASK, val) + 1;\n\tpostdiv += FIELD_GET(MCLK_HIGH_MASK, val) + 1;\n\n\terr = tc358746_read(tc358746, CLKCTL_REG, &val);\n\tif (err)\n\t\treturn 0;\n\n\tprediv = FIELD_GET(MCLKDIV_MASK, val);\n\tif (prediv == MCLKDIV_8)\n\t\tprediv = 8;\n\telse if (prediv == MCLKDIV_4)\n\t\tprediv = 4;\n\telse\n\t\tprediv = 2;\n\n\treturn tc358746->pll_rate / (prediv * postdiv);\n}\n\nstatic long tc358746_mclk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long *parent_rate)\n{\n\tstruct tc358746 *tc358746 = clk_hw_to_tc358746(hw);\n\n\t*parent_rate = tc358746->pll_rate;\n\n\treturn tc358746_find_mclk_settings(tc358746, rate);\n}\n\nstatic int tc358746_mclk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct tc358746 *tc358746 = clk_hw_to_tc358746(hw);\n\n\ttc358746_find_mclk_settings(tc358746, rate);\n\n\treturn tc358746_mclk_enable(hw);\n}\n\nstatic const struct clk_ops tc358746_mclk_ops = {\n\t.enable = tc358746_mclk_enable,\n\t.disable = tc358746_mclk_disable,\n\t.recalc_rate = tc358746_recalc_rate,\n\t.round_rate = tc358746_mclk_round_rate,\n\t.set_rate = tc358746_mclk_set_rate,\n};\n\nstatic int tc358746_setup_mclk_provider(struct tc358746 *tc358746)\n{\n\tstruct clk_init_data mclk_initdata = { };\n\tstruct device *dev = tc358746->sd.dev;\n\tconst char *mclk_name;\n\tint err;\n\n\t \n\tif (!device_property_present(dev, \"#clock-cells\"))\n\t\treturn 0;\n\n\t \n\ttc358746->mclk_postdiv = 512;\n\ttc358746->mclk_prediv = 8;\n\n\tmclk_name = \"tc358746-mclk\";\n\tdevice_property_read_string(dev, \"clock-output-names\", &mclk_name);\n\n\tmclk_initdata.name = mclk_name;\n\tmclk_initdata.ops = &tc358746_mclk_ops;\n\ttc358746->mclk_hw.init = &mclk_initdata;\n\n\terr = devm_clk_hw_register(dev, &tc358746->mclk_hw);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to register mclk provider\\n\");\n\t\treturn err;\n\t}\n\n\terr = devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get,\n\t\t\t\t\t  &tc358746->mclk_hw);\n\tif (err)\n\t\tdev_err(dev, \"Failed to add mclk provider\\n\");\n\n\treturn err;\n}\n\nstatic int\ntc358746_init_subdev(struct tc358746 *tc358746, struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = &tc358746->sd;\n\tint err;\n\n\tv4l2_i2c_subdev_init(sd, client, &tc358746_ops);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsd->entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tsd->entity.ops = &tc358746_entity_ops;\n\n\ttc358746->pads[TC358746_SINK].flags = MEDIA_PAD_FL_SINK;\n\ttc358746->pads[TC358746_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\terr = media_entity_pads_init(&sd->entity, TC358746_NR_PADS,\n\t\t\t\t     tc358746->pads);\n\tif (err)\n\t\treturn err;\n\n\terr = v4l2_subdev_init_finalize(sd);\n\tif (err)\n\t\tmedia_entity_cleanup(&sd->entity);\n\n\treturn err;\n}\n\nstatic int\ntc358746_init_output_port(struct tc358746 *tc358746, unsigned long refclk)\n{\n\tstruct device *dev = tc358746->sd.dev;\n\tstruct v4l2_fwnode_endpoint *vep;\n\tunsigned long csi_link_rate;\n\tstruct fwnode_handle *ep;\n\tunsigned char csi_lanes;\n\tint err;\n\n\tep = fwnode_graph_get_endpoint_by_id(dev_fwnode(dev), TC358746_SOURCE,\n\t\t\t\t\t     0, 0);\n\tif (!ep) {\n\t\tdev_err(dev, \"Missing endpoint node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tvep = &tc358746->csi_vep;\n\tvep->bus_type = V4L2_MBUS_CSI2_DPHY;\n\terr = v4l2_fwnode_endpoint_alloc_parse(ep, vep);\n\tfwnode_handle_put(ep);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to parse source endpoint\\n\");\n\t\treturn err;\n\t}\n\n\tcsi_lanes = vep->bus.mipi_csi2.num_data_lanes;\n\tif (csi_lanes == 0 || csi_lanes > 4 ||\n\t    vep->nr_of_link_frequencies == 0) {\n\t\tdev_err(dev, \"error: Invalid CSI-2 settings\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tcsi_link_rate = (unsigned long)vep->link_frequencies[0];\n\ttc358746->pll_rate = tc358746_find_pll_settings(tc358746, refclk,\n\t\t\t\t\t\t\tcsi_link_rate * 2);\n\tif (!tc358746->pll_rate) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\terr = phy_mipi_dphy_get_default_config_for_hsclk(tc358746->pll_rate,\n\t\t\t\t\t\tcsi_lanes, &tc358746->dphy_cfg);\n\tif (err)\n\t\tgoto err;\n\n\ttc358746->vb_size = TC358746_VB_DEFAULT_SIZE;\n\n\treturn 0;\n\nerr:\n\tv4l2_fwnode_endpoint_free(vep);\n\n\treturn err;\n}\n\nstatic int tc358746_init_hw(struct tc358746 *tc358746)\n{\n\tstruct device *dev = tc358746->sd.dev;\n\tunsigned int chipid;\n\tu32 val;\n\tint err;\n\n\terr = pm_runtime_resume_and_get(dev);\n\tif (err < 0) {\n\t\tdev_err(dev, \"Failed to resume the device\\n\");\n\t\treturn err;\n\t}\n\n\t  \n\terr = tc358746_sw_reset(tc358746);\n\tif (err) {\n\t\tpm_runtime_put_sync(dev);\n\t\tdev_err(dev, \"Failed to reset the device\\n\");\n\t\treturn err;\n\t}\n\n\terr = tc358746_read(tc358746, CHIPID_REG, &val);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_sync_autosuspend(dev);\n\tif (err)\n\t\treturn -ENODEV;\n\n\tchipid = FIELD_GET(CHIPID, val);\n\tif (chipid != 0x44) {\n\t\tdev_err(dev, \"Invalid chipid 0x%02x\\n\", chipid);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int tc358746_init_controls(struct tc358746 *tc358746)\n{\n\tu64 *link_frequencies = tc358746->csi_vep.link_frequencies;\n\tstruct v4l2_ctrl *ctrl;\n\tint err;\n\n\terr = v4l2_ctrl_handler_init(&tc358746->ctrl_hdl, 1);\n\tif (err)\n\t\treturn err;\n\n\t \n\tctrl = v4l2_ctrl_new_int_menu(&tc358746->ctrl_hdl, NULL,\n\t\t\t\t      V4L2_CID_LINK_FREQ, 0, 0,\n\t\t\t\t      link_frequencies);\n\tif (ctrl)\n\t\tctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\terr = tc358746->ctrl_hdl.error;\n\tif (err) {\n\t\tv4l2_ctrl_handler_free(&tc358746->ctrl_hdl);\n\t\treturn err;\n\t}\n\n\ttc358746->sd.ctrl_handler = &tc358746->ctrl_hdl;\n\n\treturn 0;\n}\n\nstatic int tc358746_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_async_connection *asd)\n{\n\tstruct tc358746 *tc358746 =\n\t\tcontainer_of(notifier, struct tc358746, notifier);\n\tu32 flags = MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE;\n\tstruct media_pad *sink = &tc358746->pads[TC358746_SINK];\n\n\treturn v4l2_create_fwnode_links_to_pad(sd, sink, flags);\n}\n\nstatic const struct v4l2_async_notifier_operations tc358746_notify_ops = {\n\t.bound = tc358746_notify_bound,\n};\n\nstatic int tc358746_async_register(struct tc358746 *tc358746)\n{\n\tstruct v4l2_fwnode_endpoint vep = {\n\t\t.bus_type = V4L2_MBUS_PARALLEL,\n\t};\n\tstruct v4l2_async_connection *asd;\n\tstruct fwnode_handle *ep;\n\tint err;\n\n\tep = fwnode_graph_get_endpoint_by_id(dev_fwnode(tc358746->sd.dev),\n\t\t\t\t\t     TC358746_SINK, 0, 0);\n\tif (!ep)\n\t\treturn -ENOTCONN;\n\n\terr = v4l2_fwnode_endpoint_parse(ep, &vep);\n\tif (err) {\n\t\tfwnode_handle_put(ep);\n\t\treturn err;\n\t}\n\n\tv4l2_async_subdev_nf_init(&tc358746->notifier, &tc358746->sd);\n\tasd = v4l2_async_nf_add_fwnode_remote(&tc358746->notifier, ep,\n\t\t\t\t\t      struct v4l2_async_connection);\n\tfwnode_handle_put(ep);\n\n\tif (IS_ERR(asd)) {\n\t\terr = PTR_ERR(asd);\n\t\tgoto err_cleanup;\n\t}\n\n\ttc358746->notifier.ops = &tc358746_notify_ops;\n\n\terr = v4l2_async_nf_register(&tc358746->notifier);\n\tif (err)\n\t\tgoto err_cleanup;\n\n\terr = v4l2_async_register_subdev(&tc358746->sd);\n\tif (err)\n\t\tgoto err_unregister;\n\n\treturn 0;\n\nerr_unregister:\n\tv4l2_async_nf_unregister(&tc358746->notifier);\nerr_cleanup:\n\tv4l2_async_nf_cleanup(&tc358746->notifier);\n\n\treturn err;\n}\n\nstatic int tc358746_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct tc358746 *tc358746;\n\tunsigned long refclk;\n\tunsigned int i;\n\tint err;\n\n\ttc358746 = devm_kzalloc(&client->dev, sizeof(*tc358746), GFP_KERNEL);\n\tif (!tc358746)\n\t\treturn -ENOMEM;\n\n\ttc358746->regmap = devm_regmap_init_i2c(client, &tc358746_regmap_config);\n\tif (IS_ERR(tc358746->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(tc358746->regmap),\n\t\t\t\t     \"Failed to init regmap\\n\");\n\n\ttc358746->refclk = devm_clk_get(dev, \"refclk\");\n\tif (IS_ERR(tc358746->refclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(tc358746->refclk),\n\t\t\t\t     \"Failed to get refclk\\n\");\n\n\terr = clk_prepare_enable(tc358746->refclk);\n\tif (err)\n\t\treturn dev_err_probe(dev, err,\n\t\t\t\t     \"Failed to enable refclk\\n\");\n\n\trefclk = clk_get_rate(tc358746->refclk);\n\tclk_disable_unprepare(tc358746->refclk);\n\n\tif (refclk < 6 * HZ_PER_MHZ || refclk > 40 * HZ_PER_MHZ)\n\t\treturn dev_err_probe(dev, -EINVAL, \"Invalid refclk range\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(tc358746_supplies); i++)\n\t\ttc358746->supplies[i].supply = tc358746_supplies[i];\n\n\terr = devm_regulator_bulk_get(dev, ARRAY_SIZE(tc358746_supplies),\n\t\t\t\t      tc358746->supplies);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"Failed to get supplies\\n\");\n\n\ttc358746->reset_gpio = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t       GPIOD_OUT_HIGH);\n\tif (IS_ERR(tc358746->reset_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(tc358746->reset_gpio),\n\t\t\t\t     \"Failed to get reset-gpios\\n\");\n\n\terr = tc358746_init_subdev(tc358746, client);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"Failed to init subdev\\n\");\n\n\terr = tc358746_init_output_port(tc358746, refclk);\n\tif (err)\n\t\tgoto err_subdev;\n\n\t \n\terr = tc358746_init_controls(tc358746);\n\tif (err)\n\t\tgoto err_fwnode;\n\n\tdev_set_drvdata(dev, tc358746);\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, 1000);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_enable(dev);\n\n\terr = tc358746_init_hw(tc358746);\n\tif (err)\n\t\tgoto err_pm;\n\n\terr = tc358746_setup_mclk_provider(tc358746);\n\tif (err)\n\t\tgoto err_pm;\n\n\terr = tc358746_async_register(tc358746);\n\tif (err < 0)\n\t\tgoto err_pm;\n\n\tdev_dbg(dev, \"%s found @ 0x%x (%s)\\n\", client->name,\n\t\tclient->addr, client->adapter->name);\n\n\treturn 0;\n\nerr_pm:\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_dont_use_autosuspend(dev);\n\tv4l2_ctrl_handler_free(&tc358746->ctrl_hdl);\nerr_fwnode:\n\tv4l2_fwnode_endpoint_free(&tc358746->csi_vep);\nerr_subdev:\n\tv4l2_subdev_cleanup(&tc358746->sd);\n\tmedia_entity_cleanup(&tc358746->sd.entity);\n\n\treturn err;\n}\n\nstatic void tc358746_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct tc358746 *tc358746 = to_tc358746(sd);\n\n\tv4l2_subdev_cleanup(sd);\n\tv4l2_ctrl_handler_free(&tc358746->ctrl_hdl);\n\tv4l2_fwnode_endpoint_free(&tc358746->csi_vep);\n\tv4l2_async_nf_unregister(&tc358746->notifier);\n\tv4l2_async_nf_cleanup(&tc358746->notifier);\n\tv4l2_async_unregister_subdev(sd);\n\tmedia_entity_cleanup(&sd->entity);\n\n\tpm_runtime_disable(sd->dev);\n\tpm_runtime_set_suspended(sd->dev);\n\tpm_runtime_dont_use_autosuspend(sd->dev);\n}\n\nstatic int tc358746_suspend(struct device *dev)\n{\n\tstruct tc358746 *tc358746 = dev_get_drvdata(dev);\n\tint err;\n\n\tclk_disable_unprepare(tc358746->refclk);\n\n\terr = regulator_bulk_disable(ARRAY_SIZE(tc358746_supplies),\n\t\t\t\t     tc358746->supplies);\n\tif (err)\n\t\tclk_prepare_enable(tc358746->refclk);\n\n\treturn err;\n}\n\nstatic int tc358746_resume(struct device *dev)\n{\n\tstruct tc358746 *tc358746 = dev_get_drvdata(dev);\n\tint err;\n\n\tgpiod_set_value(tc358746->reset_gpio, 1);\n\n\terr = regulator_bulk_enable(ARRAY_SIZE(tc358746_supplies),\n\t\t\t\t    tc358746->supplies);\n\tif (err)\n\t\treturn err;\n\n\t \n\tusleep_range(10, 20);\n\n\tgpiod_set_value(tc358746->reset_gpio, 0);\n\n\terr = clk_prepare_enable(tc358746->refclk);\n\tif (err)\n\t\tgoto err;\n\n\t \n\tusleep_range(1000, 1500);\n\n\t \n\terr = tc358746_apply_pll_config(tc358746);\n\tif (err)\n\t\tgoto err_clk;\n\n\treturn 0;\n\nerr_clk:\n\tclk_disable_unprepare(tc358746->refclk);\nerr:\n\tregulator_bulk_disable(ARRAY_SIZE(tc358746_supplies),\n\t\t\t       tc358746->supplies);\n\treturn err;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(tc358746_pm_ops, tc358746_suspend,\n\t\t\t\t tc358746_resume, NULL);\n\nstatic const struct of_device_id __maybe_unused tc358746_of_match[] = {\n\t{ .compatible = \"toshiba,tc358746\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tc358746_of_match);\n\nstatic struct i2c_driver tc358746_driver = {\n\t.driver = {\n\t\t.name = \"tc358746\",\n\t\t.pm = pm_ptr(&tc358746_pm_ops),\n\t\t.of_match_table = tc358746_of_match,\n\t},\n\t.probe = tc358746_probe,\n\t.remove = tc358746_remove,\n};\n\nmodule_i2c_driver(tc358746_driver);\n\nMODULE_DESCRIPTION(\"Toshiba TC358746 Parallel to CSI-2 bridge driver\");\nMODULE_AUTHOR(\"Marco Felsch <kernel@pengutronix.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}