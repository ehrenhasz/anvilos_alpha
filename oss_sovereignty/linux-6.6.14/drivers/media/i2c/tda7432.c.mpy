{
  "module_name": "tda7432.c",
  "hash_id": "3322b3a898e0a6a4a7c3fda088c75bd7de65095c3bd49b9d8f841be007ba8520",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/tda7432.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <linux/i2c.h>\n\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n\n#ifndef VIDEO_AUDIO_BALANCE\n# define VIDEO_AUDIO_BALANCE 32\n#endif\n\nMODULE_AUTHOR(\"Eric Sandeen <eric_sandeen@bigfoot.com>\");\nMODULE_DESCRIPTION(\"bttv driver for the tda7432 audio processor chip\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int maxvol;\nstatic int loudness;  \nstatic int debug;\t  \nmodule_param(debug, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"Set debugging level from 0 to 3. Default is off(0).\");\nmodule_param(loudness, int, S_IRUGO);\nMODULE_PARM_DESC(loudness, \"Turn loudness on(1) else off(0). Default is off(0).\");\nmodule_param(maxvol, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(maxvol, \"Set maximum volume to +20dB(0) else +0dB(1). Default is +20dB(0).\");\n\n\n \n\nstruct tda7432 {\n\tstruct v4l2_subdev sd;\n\tstruct v4l2_ctrl_handler hdl;\n\tstruct {\n\t\t \n\t\tstruct v4l2_ctrl *bass;\n\t\tstruct v4l2_ctrl *treble;\n\t};\n\tstruct {\n\t\t \n\t\tstruct v4l2_ctrl *mute;\n\t\tstruct v4l2_ctrl *balance;\n\t};\n};\n\nstatic inline struct tda7432 *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct tda7432, sd);\n}\n\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct tda7432, hdl)->sd;\n}\n\n \n\n\t\t \n\n#define TDA7432_IN\t0x00  \n#define TDA7432_VL\t0x01  \n#define TDA7432_TN\t0x02  \n#define TDA7432_LF\t0x03  \n#define TDA7432_LR\t0x04  \n#define TDA7432_RF\t0x05  \n#define TDA7432_RR\t0x06  \n#define TDA7432_LD\t0x07  \n\n\n\t\t \n\n \n\n \n\n \n\n#define TDA7432_STEREO_IN\t0\n#define TDA7432_MONO_IN\t\t2\t \n#define TDA7432_BASS_SYM\t1 << 3\n#define TDA7432_BASS_NORM\t1 << 4\n\n \n\n \n\n#define\tTDA7432_VOL_0DB\t\t0x20\n#define TDA7432_LD_ON\t\t1 << 7\n\n\n \n\n \n\n#define TDA7432_TREBLE_0DB\t\t0xf\n#define TDA7432_TREBLE\t\t\t7\n#define TDA7432_TREBLE_GAIN\t\t1 << 3\n#define TDA7432_BASS_0DB\t\t0xf\n#define TDA7432_BASS\t\t\t7 << 4\n#define TDA7432_BASS_GAIN\t\t1 << 7\n\n\n \n \n \n \n\n \n\n#define TDA7432_ATTEN_0DB\t0x00\n#define TDA7432_MUTE        0x1 << 5\n\n\n \n\n \n\n\n\n \n\nstatic int tda7432_write(struct v4l2_subdev *sd, int subaddr, int val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tunsigned char buffer[2];\n\n\tv4l2_dbg(2, debug, sd, \"In tda7432_write\\n\");\n\tv4l2_dbg(1, debug, sd, \"Writing %d 0x%x\\n\", subaddr, val);\n\tbuffer[0] = subaddr;\n\tbuffer[1] = val;\n\tif (2 != i2c_master_send(client, buffer, 2)) {\n\t\tv4l2_err(sd, \"I/O error, trying (write %d 0x%x)\\n\",\n\t\t       subaddr, val);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int tda7432_set(struct v4l2_subdev *sd)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tunsigned char buf[16];\n\n\tbuf[0]  = TDA7432_IN;\n\tbuf[1]  = TDA7432_STEREO_IN |   \n\t\t  TDA7432_BASS_SYM  |   \n\t\t  TDA7432_BASS_NORM;    \n\tbuf[2]  = 0x3b;\n\tif (loudness)\t\t\t  \n\t\tbuf[2] |= TDA7432_LD_ON;\n\tbuf[3]  = TDA7432_TREBLE_0DB | (TDA7432_BASS_0DB << 4);\n\tbuf[4]  = TDA7432_ATTEN_0DB;\n\tbuf[5]  = TDA7432_ATTEN_0DB;\n\tbuf[6]  = TDA7432_ATTEN_0DB;\n\tbuf[7]  = TDA7432_ATTEN_0DB;\n\tbuf[8]  = loudness;\n\tif (9 != i2c_master_send(client, buf, 9)) {\n\t\tv4l2_err(sd, \"I/O error, trying tda7432_set\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int tda7432_log_status(struct v4l2_subdev *sd)\n{\n\tstruct tda7432 *state = to_state(sd);\n\n\tv4l2_ctrl_handler_log_status(&state->hdl, sd->name);\n\treturn 0;\n}\n\nstatic int tda7432_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\tstruct tda7432 *t = to_state(sd);\n\tu8 bass, treble, volume;\n\tu8 lf, lr, rf, rr;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\tif (t->balance->val < 0) {\n\t\t\t \n\t\t\trr = rf = -t->balance->val;\n\t\t\tlr = lf = TDA7432_ATTEN_0DB;\n\t\t} else if (t->balance->val > 0) {\n\t\t\t \n\t\t\trr = rf = TDA7432_ATTEN_0DB;\n\t\t\tlr = lf = t->balance->val;\n\t\t} else {\n\t\t\t \n\t\t\trr = rf = TDA7432_ATTEN_0DB;\n\t\t\tlr = lf = TDA7432_ATTEN_0DB;\n\t\t}\n\t\tif (t->mute->val) {\n\t\t\tlf |= TDA7432_MUTE;\n\t\t\tlr |= TDA7432_MUTE;\n\t\t\trf |= TDA7432_MUTE;\n\t\t\trr |= TDA7432_MUTE;\n\t\t}\n\t\t \n\t\ttda7432_write(sd, TDA7432_LF, lf);\n\t\ttda7432_write(sd, TDA7432_LR, lr);\n\t\ttda7432_write(sd, TDA7432_RF, rf);\n\t\ttda7432_write(sd, TDA7432_RR, rr);\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_VOLUME:\n\t\tvolume = 0x6f - ctrl->val;\n\t\tif (loudness)\t\t \n\t\t\tvolume |= TDA7432_LD_ON;\n\n\t\ttda7432_write(sd, TDA7432_VL, volume);\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_BASS:\n\t\tbass = t->bass->val;\n\t\ttreble = t->treble->val;\n\t\tif (bass >= 0x8)\n\t\t\tbass = 14 - (bass - 8);\n\t\tif (treble >= 0x8)\n\t\t\ttreble = 14 - (treble - 8);\n\n\t\ttda7432_write(sd, TDA7432_TN, 0x10 | (bass << 4) | treble);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n \n\nstatic const struct v4l2_ctrl_ops tda7432_ctrl_ops = {\n\t.s_ctrl = tda7432_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops tda7432_core_ops = {\n\t.log_status = tda7432_log_status,\n};\n\nstatic const struct v4l2_subdev_ops tda7432_ops = {\n\t.core = &tda7432_core_ops,\n};\n\n \n\n \n\nstatic int tda7432_probe(struct i2c_client *client)\n{\n\tstruct tda7432 *t;\n\tstruct v4l2_subdev *sd;\n\n\tv4l_info(client, \"chip found @ 0x%02x (%s)\\n\",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tt = devm_kzalloc(&client->dev, sizeof(*t), GFP_KERNEL);\n\tif (!t)\n\t\treturn -ENOMEM;\n\tsd = &t->sd;\n\tv4l2_i2c_subdev_init(sd, client, &tda7432_ops);\n\tv4l2_ctrl_handler_init(&t->hdl, 5);\n\tv4l2_ctrl_new_std(&t->hdl, &tda7432_ctrl_ops,\n\t\tV4L2_CID_AUDIO_VOLUME, 0, maxvol ? 0x68 : 0x4f, 1, maxvol ? 0x5d : 0x47);\n\tt->mute = v4l2_ctrl_new_std(&t->hdl, &tda7432_ctrl_ops,\n\t\tV4L2_CID_AUDIO_MUTE, 0, 1, 1, 0);\n\tt->balance = v4l2_ctrl_new_std(&t->hdl, &tda7432_ctrl_ops,\n\t\tV4L2_CID_AUDIO_BALANCE, -31, 31, 1, 0);\n\tt->bass = v4l2_ctrl_new_std(&t->hdl, &tda7432_ctrl_ops,\n\t\tV4L2_CID_AUDIO_BASS, 0, 14, 1, 7);\n\tt->treble = v4l2_ctrl_new_std(&t->hdl, &tda7432_ctrl_ops,\n\t\tV4L2_CID_AUDIO_TREBLE, 0, 14, 1, 7);\n\tsd->ctrl_handler = &t->hdl;\n\tif (t->hdl.error) {\n\t\tint err = t->hdl.error;\n\n\t\tv4l2_ctrl_handler_free(&t->hdl);\n\t\treturn err;\n\t}\n\tv4l2_ctrl_cluster(2, &t->bass);\n\tv4l2_ctrl_cluster(2, &t->mute);\n\tv4l2_ctrl_handler_setup(&t->hdl);\n\tif (loudness < 0 || loudness > 15) {\n\t\tv4l2_warn(sd, \"loudness parameter must be between 0 and 15\\n\");\n\t\tif (loudness < 0)\n\t\t\tloudness = 0;\n\t\tif (loudness > 15)\n\t\t\tloudness = 15;\n\t}\n\n\ttda7432_set(sd);\n\treturn 0;\n}\n\nstatic void tda7432_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct tda7432 *t = to_state(sd);\n\n\ttda7432_set(sd);\n\tv4l2_device_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(&t->hdl);\n}\n\nstatic const struct i2c_device_id tda7432_id[] = {\n\t{ \"tda7432\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tda7432_id);\n\nstatic struct i2c_driver tda7432_driver = {\n\t.driver = {\n\t\t.name\t= \"tda7432\",\n\t},\n\t.probe\t\t= tda7432_probe,\n\t.remove\t\t= tda7432_remove,\n\t.id_table\t= tda7432_id,\n};\n\nmodule_i2c_driver(tda7432_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}