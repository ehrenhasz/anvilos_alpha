{
  "module_name": "s5c73m3-spi.c",
  "hash_id": "58bcbfe142f5dbff43c68a82e6e9351b59c84dfcb9ec260a4071431198bbc396",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/s5c73m3/s5c73m3-spi.c",
  "human_readable_source": "\n \n\n#include <linux/sizes.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/media.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n\n#include \"s5c73m3.h\"\n\n#define S5C73M3_SPI_DRV_NAME \"S5C73M3-SPI\"\n\nstatic const struct of_device_id s5c73m3_spi_ids[] = {\n\t{ .compatible = \"samsung,s5c73m3\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, s5c73m3_spi_ids);\n\nenum spi_direction {\n\tSPI_DIR_RX,\n\tSPI_DIR_TX\n};\n\nstatic int spi_xmit(struct spi_device *spi_dev, void *addr, const int len,\n\t\t\t\t\t\t\tenum spi_direction dir)\n{\n\tstruct spi_message msg;\n\tint r;\n\tstruct spi_transfer xfer = {\n\t\t.len\t= len,\n\t};\n\n\tif (dir == SPI_DIR_TX)\n\t\txfer.tx_buf = addr;\n\telse\n\t\txfer.rx_buf = addr;\n\n\tif (spi_dev == NULL) {\n\t\tpr_err(\"SPI device is uninitialized\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&xfer, &msg);\n\n\tr = spi_sync(spi_dev, &msg);\n\tif (r < 0)\n\t\tdev_err(&spi_dev->dev, \"%s spi_sync failed %d\\n\", __func__, r);\n\n\treturn r;\n}\n\nint s5c73m3_spi_write(struct s5c73m3 *state, const void *addr,\n\t\t      const unsigned int len, const unsigned int tx_size)\n{\n\tstruct spi_device *spi_dev = state->spi_dev;\n\tu32 count = len / tx_size;\n\tu32 extra = len % tx_size;\n\tunsigned int i, j = 0;\n\tu8 padding[32];\n\tint r = 0;\n\n\tmemset(padding, 0, sizeof(padding));\n\n\tfor (i = 0; i < count; i++) {\n\t\tr = spi_xmit(spi_dev, (void *)addr + j, tx_size, SPI_DIR_TX);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tj += tx_size;\n\t}\n\n\tif (extra > 0) {\n\t\tr = spi_xmit(spi_dev, (void *)addr + j, extra, SPI_DIR_TX);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\treturn spi_xmit(spi_dev, padding, sizeof(padding), SPI_DIR_TX);\n}\n\nint s5c73m3_spi_read(struct s5c73m3 *state, void *addr,\n\t\t     const unsigned int len, const unsigned int tx_size)\n{\n\tstruct spi_device *spi_dev = state->spi_dev;\n\tu32 count = len / tx_size;\n\tu32 extra = len % tx_size;\n\tunsigned int i, j = 0;\n\tint r = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tr = spi_xmit(spi_dev, addr + j, tx_size, SPI_DIR_RX);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tj += tx_size;\n\t}\n\n\tif (extra > 0)\n\t\treturn spi_xmit(spi_dev, addr + j, extra, SPI_DIR_RX);\n\n\treturn 0;\n}\n\nstatic int s5c73m3_spi_probe(struct spi_device *spi)\n{\n\tint r;\n\tstruct s5c73m3 *state = container_of(spi->dev.driver, struct s5c73m3,\n\t\t\t\t\t     spidrv.driver);\n\tspi->bits_per_word = 32;\n\n\tr = spi_setup(spi);\n\tif (r < 0) {\n\t\tdev_err(&spi->dev, \"spi_setup() failed\\n\");\n\t\treturn r;\n\t}\n\n\tmutex_lock(&state->lock);\n\tstate->spi_dev = spi;\n\tmutex_unlock(&state->lock);\n\n\tv4l2_info(&state->sensor_sd, \"S5C73M3 SPI probed successfully\\n\");\n\treturn 0;\n}\n\nint s5c73m3_register_spi_driver(struct s5c73m3 *state)\n{\n\tstruct spi_driver *spidrv = &state->spidrv;\n\n\tspidrv->probe = s5c73m3_spi_probe;\n\tspidrv->driver.name = S5C73M3_SPI_DRV_NAME;\n\tspidrv->driver.of_match_table = s5c73m3_spi_ids;\n\n\treturn spi_register_driver(spidrv);\n}\n\nvoid s5c73m3_unregister_spi_driver(struct s5c73m3 *state)\n{\n\tspi_unregister_driver(&state->spidrv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}