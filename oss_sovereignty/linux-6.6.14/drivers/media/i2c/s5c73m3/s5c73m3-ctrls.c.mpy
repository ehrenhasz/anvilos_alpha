{
  "module_name": "s5c73m3-ctrls.c",
  "hash_id": "d68cf5a72e7d50b896cbd1a64fb0af8651ca6417e7786ba3f4974f8107570556",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/s5c73m3/s5c73m3-ctrls.c",
  "human_readable_source": "\n \n\n#include <linux/sizes.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/media.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/videodev2.h>\n#include <media/media-entity.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-subdev.h>\n#include <media/v4l2-mediabus.h>\n\n#include \"s5c73m3.h\"\n\nstatic int s5c73m3_get_af_status(struct s5c73m3 *state, struct v4l2_ctrl *ctrl)\n{\n\tu16 reg = REG_AF_STATUS_UNFOCUSED;\n\n\tint ret = s5c73m3_read(state, REG_AF_STATUS, &reg);\n\n\tswitch (reg) {\n\tcase REG_CAF_STATUS_FIND_SEARCH_DIR:\n\tcase REG_AF_STATUS_FOCUSING:\n\tcase REG_CAF_STATUS_FOCUSING:\n\t\tctrl->val = V4L2_AUTO_FOCUS_STATUS_BUSY;\n\t\tbreak;\n\tcase REG_CAF_STATUS_FOCUSED:\n\tcase REG_AF_STATUS_FOCUSED:\n\t\tctrl->val = V4L2_AUTO_FOCUS_STATUS_REACHED;\n\t\tbreak;\n\tdefault:\n\t\tv4l2_info(&state->sensor_sd, \"Unknown AF status %#x\\n\", reg);\n\t\tfallthrough;\n\tcase REG_CAF_STATUS_UNFOCUSED:\n\tcase REG_AF_STATUS_UNFOCUSED:\n\tcase REG_AF_STATUS_INVALID:\n\t\tctrl->val = V4L2_AUTO_FOCUS_STATUS_FAILED;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int s5c73m3_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = ctrl_to_sensor_sd(ctrl);\n\tstruct s5c73m3 *state = sensor_sd_to_s5c73m3(sd);\n\tint ret;\n\n\tif (state->power == 0)\n\t\treturn -EBUSY;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_FOCUS_AUTO:\n\t\tret = s5c73m3_get_af_status(state, state->ctrls.af_status);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int s5c73m3_set_colorfx(struct s5c73m3 *state, int val)\n{\n\tstatic const unsigned short colorfx[][2] = {\n\t\t{ V4L2_COLORFX_NONE,\t COMM_IMAGE_EFFECT_NONE },\n\t\t{ V4L2_COLORFX_BW,\t COMM_IMAGE_EFFECT_MONO },\n\t\t{ V4L2_COLORFX_SEPIA,\t COMM_IMAGE_EFFECT_SEPIA },\n\t\t{ V4L2_COLORFX_NEGATIVE, COMM_IMAGE_EFFECT_NEGATIVE },\n\t\t{ V4L2_COLORFX_AQUA,\t COMM_IMAGE_EFFECT_AQUA },\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(colorfx); i++) {\n\t\tif (colorfx[i][0] != val)\n\t\t\tcontinue;\n\n\t\tv4l2_dbg(1, s5c73m3_dbg, &state->sensor_sd,\n\t\t\t \"Setting %s color effect\\n\",\n\t\t\t v4l2_ctrl_get_menu(state->ctrls.colorfx->id)[i]);\n\n\t\treturn s5c73m3_isp_command(state, COMM_IMAGE_EFFECT,\n\t\t\t\t\t colorfx[i][1]);\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic int s5c73m3_set_exposure(struct s5c73m3 *state, int auto_exp)\n{\n\tstruct v4l2_subdev *sd = &state->sensor_sd;\n\tstruct s5c73m3_ctrls *ctrls = &state->ctrls;\n\tint ret = 0;\n\n\tif (ctrls->exposure_metering->is_new) {\n\t\tu16 metering;\n\n\t\tswitch (ctrls->exposure_metering->val) {\n\t\tcase V4L2_EXPOSURE_METERING_CENTER_WEIGHTED:\n\t\t\tmetering = COMM_METERING_CENTER;\n\t\t\tbreak;\n\t\tcase V4L2_EXPOSURE_METERING_SPOT:\n\t\t\tmetering = COMM_METERING_SPOT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmetering = COMM_METERING_AVERAGE;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = s5c73m3_isp_command(state, COMM_METERING, metering);\n\t}\n\n\tif (!ret && ctrls->exposure_bias->is_new) {\n\t\tu16 exp_bias = ctrls->exposure_bias->val;\n\t\tret = s5c73m3_isp_command(state, COMM_EV, exp_bias);\n\t}\n\n\tv4l2_dbg(1, s5c73m3_dbg, sd,\n\t\t \"%s: exposure bias: %#x, metering: %#x (%d)\\n\",  __func__,\n\t\t ctrls->exposure_bias->val, ctrls->exposure_metering->val, ret);\n\n\treturn ret;\n}\n\nstatic int s5c73m3_set_white_balance(struct s5c73m3 *state, int val)\n{\n\tstatic const unsigned short wb[][2] = {\n\t\t{ V4L2_WHITE_BALANCE_INCANDESCENT,  COMM_AWB_MODE_INCANDESCENT},\n\t\t{ V4L2_WHITE_BALANCE_FLUORESCENT,   COMM_AWB_MODE_FLUORESCENT1},\n\t\t{ V4L2_WHITE_BALANCE_FLUORESCENT_H, COMM_AWB_MODE_FLUORESCENT2},\n\t\t{ V4L2_WHITE_BALANCE_CLOUDY,        COMM_AWB_MODE_CLOUDY},\n\t\t{ V4L2_WHITE_BALANCE_DAYLIGHT,      COMM_AWB_MODE_DAYLIGHT},\n\t\t{ V4L2_WHITE_BALANCE_AUTO,          COMM_AWB_MODE_AUTO},\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(wb); i++) {\n\t\tif (wb[i][0] != val)\n\t\t\tcontinue;\n\n\t\tv4l2_dbg(1, s5c73m3_dbg, &state->sensor_sd,\n\t\t\t \"Setting white balance to: %s\\n\",\n\t\t\t v4l2_ctrl_get_menu(state->ctrls.auto_wb->id)[i]);\n\n\t\treturn s5c73m3_isp_command(state, COMM_AWB_MODE, wb[i][1]);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int s5c73m3_af_run(struct s5c73m3 *state, bool on)\n{\n\tstruct s5c73m3_ctrls *c = &state->ctrls;\n\n\tif (!on)\n\t\treturn s5c73m3_isp_command(state, COMM_AF_CON,\n\t\t\t\t\t\t\tCOMM_AF_CON_STOP);\n\n\tif (c->focus_auto->val)\n\t\treturn s5c73m3_isp_command(state, COMM_AF_MODE,\n\t\t\t\t\t   COMM_AF_MODE_PREVIEW_CAF_START);\n\n\treturn s5c73m3_isp_command(state, COMM_AF_CON, COMM_AF_CON_START);\n}\n\nstatic int s5c73m3_3a_lock(struct s5c73m3 *state, struct v4l2_ctrl *ctrl)\n{\n\tbool awb_lock = ctrl->val & V4L2_LOCK_WHITE_BALANCE;\n\tbool ae_lock = ctrl->val & V4L2_LOCK_EXPOSURE;\n\tbool af_lock = ctrl->val & V4L2_LOCK_FOCUS;\n\tint ret = 0;\n\n\tif ((ctrl->val ^ ctrl->cur.val) & V4L2_LOCK_EXPOSURE) {\n\t\tret = s5c73m3_isp_command(state, COMM_AE_CON,\n\t\t\t\tae_lock ? COMM_AE_STOP : COMM_AE_START);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (((ctrl->val ^ ctrl->cur.val) & V4L2_LOCK_WHITE_BALANCE)\n\t    && state->ctrls.auto_wb->val) {\n\t\tret = s5c73m3_isp_command(state, COMM_AWB_CON,\n\t\t\tawb_lock ? COMM_AWB_STOP : COMM_AWB_START);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif ((ctrl->val ^ ctrl->cur.val) & V4L2_LOCK_FOCUS)\n\t\tret = s5c73m3_af_run(state, !af_lock);\n\n\treturn ret;\n}\n\nstatic int s5c73m3_set_auto_focus(struct s5c73m3 *state, int caf)\n{\n\tstruct s5c73m3_ctrls *c = &state->ctrls;\n\tint ret = 1;\n\n\tif (c->af_distance->is_new) {\n\t\tu16 mode = (c->af_distance->val == V4L2_AUTO_FOCUS_RANGE_MACRO)\n\t\t\t\t? COMM_AF_MODE_MACRO : COMM_AF_MODE_NORMAL;\n\t\tret = s5c73m3_isp_command(state, COMM_AF_MODE, mode);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\tif (!ret || (c->focus_auto->is_new && c->focus_auto->val) ||\n\t\t\t\t\t\t\tc->af_start->is_new)\n\t\tret = s5c73m3_af_run(state, 1);\n\telse if ((c->focus_auto->is_new && !c->focus_auto->val) ||\n\t\t\t\t\t\t\tc->af_stop->is_new)\n\t\tret = s5c73m3_af_run(state, 0);\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int s5c73m3_set_contrast(struct s5c73m3 *state, int val)\n{\n\tu16 reg = (val < 0) ? -val + 2 : val;\n\treturn s5c73m3_isp_command(state, COMM_CONTRAST, reg);\n}\n\nstatic int s5c73m3_set_saturation(struct s5c73m3 *state, int val)\n{\n\tu16 reg = (val < 0) ? -val + 2 : val;\n\treturn s5c73m3_isp_command(state, COMM_SATURATION, reg);\n}\n\nstatic int s5c73m3_set_sharpness(struct s5c73m3 *state, int val)\n{\n\tu16 reg = (val < 0) ? -val + 2 : val;\n\treturn s5c73m3_isp_command(state, COMM_SHARPNESS, reg);\n}\n\nstatic int s5c73m3_set_iso(struct s5c73m3 *state, int val)\n{\n\tu32 iso;\n\n\tif (val == V4L2_ISO_SENSITIVITY_MANUAL)\n\t\tiso = state->ctrls.iso->val + 1;\n\telse\n\t\tiso = 0;\n\n\treturn s5c73m3_isp_command(state, COMM_ISO, iso);\n}\n\nstatic int s5c73m3_set_stabilization(struct s5c73m3 *state, int val)\n{\n\tstruct v4l2_subdev *sd = &state->sensor_sd;\n\n\tv4l2_dbg(1, s5c73m3_dbg, sd, \"Image stabilization: %d\\n\", val);\n\n\treturn s5c73m3_isp_command(state, COMM_FRAME_RATE, val ?\n\t\t\tCOMM_FRAME_RATE_ANTI_SHAKE : COMM_FRAME_RATE_AUTO_SET);\n}\n\nstatic int s5c73m3_set_jpeg_quality(struct s5c73m3 *state, int quality)\n{\n\tint reg;\n\n\tif (quality <= 65)\n\t\treg = COMM_IMAGE_QUALITY_NORMAL;\n\telse if (quality <= 75)\n\t\treg = COMM_IMAGE_QUALITY_FINE;\n\telse\n\t\treg = COMM_IMAGE_QUALITY_SUPERFINE;\n\n\treturn s5c73m3_isp_command(state, COMM_IMAGE_QUALITY, reg);\n}\n\nstatic int s5c73m3_set_scene_program(struct s5c73m3 *state, int val)\n{\n\tstatic const unsigned short scene_lookup[] = {\n\t\tCOMM_SCENE_MODE_NONE,\t      \n\t\tCOMM_SCENE_MODE_AGAINST_LIGHT, \n\t\tCOMM_SCENE_MODE_BEACH,\t      \n\t\tCOMM_SCENE_MODE_CANDLE,\t      \n\t\tCOMM_SCENE_MODE_DAWN,\t      \n\t\tCOMM_SCENE_MODE_FALL,\t      \n\t\tCOMM_SCENE_MODE_FIRE,\t      \n\t\tCOMM_SCENE_MODE_LANDSCAPE,     \n\t\tCOMM_SCENE_MODE_NIGHT,\t      \n\t\tCOMM_SCENE_MODE_INDOOR,\t      \n\t\tCOMM_SCENE_MODE_PORTRAIT,      \n\t\tCOMM_SCENE_MODE_SPORTS,\t      \n\t\tCOMM_SCENE_MODE_SUNSET,\t      \n\t\tCOMM_SCENE_MODE_TEXT,\t      \n\t};\n\n\tv4l2_dbg(1, s5c73m3_dbg, &state->sensor_sd, \"Setting %s scene mode\\n\",\n\t\t v4l2_ctrl_get_menu(state->ctrls.scene_mode->id)[val]);\n\n\treturn s5c73m3_isp_command(state, COMM_SCENE_MODE, scene_lookup[val]);\n}\n\nstatic int s5c73m3_set_power_line_freq(struct s5c73m3 *state, int val)\n{\n\tunsigned int pwr_line_freq = COMM_FLICKER_NONE;\n\n\tswitch (val) {\n\tcase V4L2_CID_POWER_LINE_FREQUENCY_DISABLED:\n\t\tpwr_line_freq = COMM_FLICKER_NONE;\n\t\tbreak;\n\tcase V4L2_CID_POWER_LINE_FREQUENCY_50HZ:\n\t\tpwr_line_freq = COMM_FLICKER_AUTO_50HZ;\n\t\tbreak;\n\tcase V4L2_CID_POWER_LINE_FREQUENCY_60HZ:\n\t\tpwr_line_freq = COMM_FLICKER_AUTO_60HZ;\n\t\tbreak;\n\tdefault:\n\tcase V4L2_CID_POWER_LINE_FREQUENCY_AUTO:\n\t\tpwr_line_freq = COMM_FLICKER_NONE;\n\t}\n\n\treturn s5c73m3_isp_command(state, COMM_FLICKER_MODE, pwr_line_freq);\n}\n\nstatic int s5c73m3_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = ctrl_to_sensor_sd(ctrl);\n\tstruct s5c73m3 *state = sensor_sd_to_s5c73m3(sd);\n\tint ret = 0;\n\n\tv4l2_dbg(1, s5c73m3_dbg, sd, \"set_ctrl: %s, value: %d\\n\",\n\t\t ctrl->name, ctrl->val);\n\n\tmutex_lock(&state->lock);\n\t \n\tif (state->power == 0)\n\t\tgoto unlock;\n\n\tif (ctrl->flags & V4L2_CTRL_FLAG_INACTIVE) {\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_3A_LOCK:\n\t\tret = s5c73m3_3a_lock(state, ctrl);\n\t\tbreak;\n\n\tcase V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:\n\t\tret = s5c73m3_set_white_balance(state, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_CONTRAST:\n\t\tret = s5c73m3_set_contrast(state, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_COLORFX:\n\t\tret = s5c73m3_set_colorfx(state, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tret = s5c73m3_set_exposure(state, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_FOCUS_AUTO:\n\t\tret = s5c73m3_set_auto_focus(state, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_IMAGE_STABILIZATION:\n\t\tret = s5c73m3_set_stabilization(state, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_ISO_SENSITIVITY:\n\t\tret = s5c73m3_set_iso(state, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_JPEG_COMPRESSION_QUALITY:\n\t\tret = s5c73m3_set_jpeg_quality(state, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_POWER_LINE_FREQUENCY:\n\t\tret = s5c73m3_set_power_line_freq(state, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_SATURATION:\n\t\tret = s5c73m3_set_saturation(state, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_SCENE_MODE:\n\t\tret = s5c73m3_set_scene_program(state, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_SHARPNESS:\n\t\tret = s5c73m3_set_sharpness(state, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_WIDE_DYNAMIC_RANGE:\n\t\tret = s5c73m3_isp_command(state, COMM_WDR, !!ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_ZOOM_ABSOLUTE:\n\t\tret = s5c73m3_isp_command(state, COMM_ZOOM_STEP, ctrl->val);\n\t\tbreak;\n\t}\nunlock:\n\tmutex_unlock(&state->lock);\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops s5c73m3_ctrl_ops = {\n\t.g_volatile_ctrl\t= s5c73m3_g_volatile_ctrl,\n\t.s_ctrl\t\t\t= s5c73m3_s_ctrl,\n};\n\n \nstatic const s64 iso_qmenu[] = {\n\t \n\t100, 200, 400, 800,\n};\n\n \nstatic const s64 ev_bias_qmenu[] = {\n\t \n\t-2000, -1500, -1000, -500, 0, 500, 1000, 1500, 2000\n};\n\nint s5c73m3_init_controls(struct s5c73m3 *state)\n{\n\tconst struct v4l2_ctrl_ops *ops = &s5c73m3_ctrl_ops;\n\tstruct s5c73m3_ctrls *ctrls = &state->ctrls;\n\tstruct v4l2_ctrl_handler *hdl = &ctrls->handler;\n\n\tint ret = v4l2_ctrl_handler_init(hdl, 22);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tctrls->auto_wb = v4l2_ctrl_new_std_menu(hdl, ops,\n\t\t\tV4L2_CID_AUTO_N_PRESET_WHITE_BALANCE,\n\t\t\t9, ~0x15e, V4L2_WHITE_BALANCE_AUTO);\n\n\t \n\tctrls->auto_exposure = v4l2_ctrl_new_std_menu(hdl, ops,\n\t\t\tV4L2_CID_EXPOSURE_AUTO, 0, ~0x01, V4L2_EXPOSURE_AUTO);\n\n\tctrls->exposure_bias = v4l2_ctrl_new_int_menu(hdl, ops,\n\t\t\tV4L2_CID_AUTO_EXPOSURE_BIAS,\n\t\t\tARRAY_SIZE(ev_bias_qmenu) - 1,\n\t\t\tARRAY_SIZE(ev_bias_qmenu)/2 - 1,\n\t\t\tev_bias_qmenu);\n\n\tctrls->exposure_metering = v4l2_ctrl_new_std_menu(hdl, ops,\n\t\t\tV4L2_CID_EXPOSURE_METERING,\n\t\t\t2, ~0x7, V4L2_EXPOSURE_METERING_AVERAGE);\n\n\t \n\tctrls->focus_auto = v4l2_ctrl_new_std(hdl, ops,\n\t\t\tV4L2_CID_FOCUS_AUTO, 0, 1, 1, 0);\n\n\tctrls->af_start = v4l2_ctrl_new_std(hdl, ops,\n\t\t\tV4L2_CID_AUTO_FOCUS_START, 0, 1, 1, 0);\n\n\tctrls->af_stop = v4l2_ctrl_new_std(hdl, ops,\n\t\t\tV4L2_CID_AUTO_FOCUS_STOP, 0, 1, 1, 0);\n\n\tctrls->af_status = v4l2_ctrl_new_std(hdl, ops,\n\t\t\tV4L2_CID_AUTO_FOCUS_STATUS, 0,\n\t\t\t(V4L2_AUTO_FOCUS_STATUS_BUSY |\n\t\t\t V4L2_AUTO_FOCUS_STATUS_REACHED |\n\t\t\t V4L2_AUTO_FOCUS_STATUS_FAILED),\n\t\t\t0, V4L2_AUTO_FOCUS_STATUS_IDLE);\n\n\tctrls->af_distance = v4l2_ctrl_new_std_menu(hdl, ops,\n\t\t\tV4L2_CID_AUTO_FOCUS_RANGE,\n\t\t\tV4L2_AUTO_FOCUS_RANGE_MACRO,\n\t\t\t~(1 << V4L2_AUTO_FOCUS_RANGE_NORMAL |\n\t\t\t  1 << V4L2_AUTO_FOCUS_RANGE_MACRO),\n\t\t\tV4L2_AUTO_FOCUS_RANGE_NORMAL);\n\t \n\tctrls->auto_iso = v4l2_ctrl_new_std_menu(hdl, ops,\n\t\t\tV4L2_CID_ISO_SENSITIVITY_AUTO, 1, 0,\n\t\t\tV4L2_ISO_SENSITIVITY_AUTO);\n\n\tctrls->iso = v4l2_ctrl_new_int_menu(hdl, ops,\n\t\t\tV4L2_CID_ISO_SENSITIVITY, ARRAY_SIZE(iso_qmenu) - 1,\n\t\t\tARRAY_SIZE(iso_qmenu)/2 - 1, iso_qmenu);\n\n\tctrls->contrast = v4l2_ctrl_new_std(hdl, ops,\n\t\t\tV4L2_CID_CONTRAST, -2, 2, 1, 0);\n\n\tctrls->saturation = v4l2_ctrl_new_std(hdl, ops,\n\t\t\tV4L2_CID_SATURATION, -2, 2, 1, 0);\n\n\tctrls->sharpness = v4l2_ctrl_new_std(hdl, ops,\n\t\t\tV4L2_CID_SHARPNESS, -2, 2, 1, 0);\n\n\tctrls->zoom = v4l2_ctrl_new_std(hdl, ops,\n\t\t\tV4L2_CID_ZOOM_ABSOLUTE, 0, 30, 1, 0);\n\n\tctrls->colorfx = v4l2_ctrl_new_std_menu(hdl, ops, V4L2_CID_COLORFX,\n\t\t\tV4L2_COLORFX_AQUA, ~0x40f, V4L2_COLORFX_NONE);\n\n\tctrls->wdr = v4l2_ctrl_new_std(hdl, ops,\n\t\t\tV4L2_CID_WIDE_DYNAMIC_RANGE, 0, 1, 1, 0);\n\n\tctrls->stabilization = v4l2_ctrl_new_std(hdl, ops,\n\t\t\tV4L2_CID_IMAGE_STABILIZATION, 0, 1, 1, 0);\n\n\tv4l2_ctrl_new_std_menu(hdl, ops, V4L2_CID_POWER_LINE_FREQUENCY,\n\t\t\t       V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 0,\n\t\t\t       V4L2_CID_POWER_LINE_FREQUENCY_AUTO);\n\n\tctrls->jpeg_quality = v4l2_ctrl_new_std(hdl, ops,\n\t\t\tV4L2_CID_JPEG_COMPRESSION_QUALITY, 1, 100, 1, 80);\n\n\tctrls->scene_mode = v4l2_ctrl_new_std_menu(hdl, ops,\n\t\t\tV4L2_CID_SCENE_MODE, V4L2_SCENE_MODE_TEXT, ~0x3fff,\n\t\t\tV4L2_SCENE_MODE_NONE);\n\n\tctrls->aaa_lock = v4l2_ctrl_new_std(hdl, ops,\n\t\t\tV4L2_CID_3A_LOCK, 0, 0x7, 0, 0);\n\n\tif (hdl->error) {\n\t\tret = hdl->error;\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\treturn ret;\n\t}\n\n\tv4l2_ctrl_auto_cluster(3, &ctrls->auto_exposure, 0, false);\n\tctrls->auto_iso->flags |= V4L2_CTRL_FLAG_VOLATILE |\n\t\t\t\tV4L2_CTRL_FLAG_UPDATE;\n\tv4l2_ctrl_auto_cluster(2, &ctrls->auto_iso, 0, false);\n\tctrls->af_status->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\tv4l2_ctrl_cluster(5, &ctrls->focus_auto);\n\n\tstate->sensor_sd.ctrl_handler = hdl;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}