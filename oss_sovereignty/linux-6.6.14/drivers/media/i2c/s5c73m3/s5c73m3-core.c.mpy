{
  "module_name": "s5c73m3-core.c",
  "hash_id": "76d45b1b02d1098b6755ba1ce819321c6990fb3823f22cc3d4d5da4a8521f0a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/s5c73m3/s5c73m3-core.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/media.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/regulator/consumer.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/videodev2.h>\n#include <media/media-entity.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-subdev.h>\n#include <media/v4l2-mediabus.h>\n#include <media/v4l2-fwnode.h>\n\n#include \"s5c73m3.h\"\n\nint s5c73m3_dbg;\nmodule_param_named(debug, s5c73m3_dbg, int, 0644);\n\nstatic int boot_from_rom = 1;\nmodule_param(boot_from_rom, int, 0644);\n\nstatic int update_fw;\nmodule_param(update_fw, int, 0644);\n\n#define S5C73M3_EMBEDDED_DATA_MAXLEN\tSZ_4K\n#define S5C73M3_MIPI_DATA_LANES\t\t4\n#define S5C73M3_CLK_NAME\t\t\"cis_extclk\"\n\nstatic const char * const s5c73m3_supply_names[S5C73M3_MAX_SUPPLIES] = {\n\t\"vdd-int\",\t \n\t\"vdda\",\t\t \n\t\"vdd-reg\",\t \n\t\"vddio-host\",\t \n\t\"vddio-cis\",\t \n\t\"vdd-af\",\t \n};\n\nstatic const struct s5c73m3_frame_size s5c73m3_isp_resolutions[] = {\n\t{ 320,\t240,\tCOMM_CHG_MODE_YUV_320_240 },\n\t{ 352,\t288,\tCOMM_CHG_MODE_YUV_352_288 },\n\t{ 640,\t480,\tCOMM_CHG_MODE_YUV_640_480 },\n\t{ 880,\t720,\tCOMM_CHG_MODE_YUV_880_720 },\n\t{ 960,\t720,\tCOMM_CHG_MODE_YUV_960_720 },\n\t{ 1008,\t672,\tCOMM_CHG_MODE_YUV_1008_672 },\n\t{ 1184,\t666,\tCOMM_CHG_MODE_YUV_1184_666 },\n\t{ 1280,\t720,\tCOMM_CHG_MODE_YUV_1280_720 },\n\t{ 1536,\t864,\tCOMM_CHG_MODE_YUV_1536_864 },\n\t{ 1600,\t1200,\tCOMM_CHG_MODE_YUV_1600_1200 },\n\t{ 1632,\t1224,\tCOMM_CHG_MODE_YUV_1632_1224 },\n\t{ 1920,\t1080,\tCOMM_CHG_MODE_YUV_1920_1080 },\n\t{ 1920,\t1440,\tCOMM_CHG_MODE_YUV_1920_1440 },\n\t{ 2304,\t1296,\tCOMM_CHG_MODE_YUV_2304_1296 },\n\t{ 3264,\t2448,\tCOMM_CHG_MODE_YUV_3264_2448 },\n};\n\nstatic const struct s5c73m3_frame_size s5c73m3_jpeg_resolutions[] = {\n\t{ 640,\t480,\tCOMM_CHG_MODE_JPEG_640_480 },\n\t{ 800,\t450,\tCOMM_CHG_MODE_JPEG_800_450 },\n\t{ 800,\t600,\tCOMM_CHG_MODE_JPEG_800_600 },\n\t{ 1024,\t768,\tCOMM_CHG_MODE_JPEG_1024_768 },\n\t{ 1280,\t720,\tCOMM_CHG_MODE_JPEG_1280_720 },\n\t{ 1280,\t960,\tCOMM_CHG_MODE_JPEG_1280_960 },\n\t{ 1600,\t900,\tCOMM_CHG_MODE_JPEG_1600_900 },\n\t{ 1600,\t1200,\tCOMM_CHG_MODE_JPEG_1600_1200 },\n\t{ 2048,\t1152,\tCOMM_CHG_MODE_JPEG_2048_1152 },\n\t{ 2048,\t1536,\tCOMM_CHG_MODE_JPEG_2048_1536 },\n\t{ 2560,\t1440,\tCOMM_CHG_MODE_JPEG_2560_1440 },\n\t{ 2560,\t1920,\tCOMM_CHG_MODE_JPEG_2560_1920 },\n\t{ 3264,\t1836,\tCOMM_CHG_MODE_JPEG_3264_1836 },\n\t{ 3264,\t2176,\tCOMM_CHG_MODE_JPEG_3264_2176 },\n\t{ 3264,\t2448,\tCOMM_CHG_MODE_JPEG_3264_2448 },\n};\n\nstatic const struct s5c73m3_frame_size * const s5c73m3_resolutions[] = {\n\t[RES_ISP] = s5c73m3_isp_resolutions,\n\t[RES_JPEG] = s5c73m3_jpeg_resolutions\n};\n\nstatic const int s5c73m3_resolutions_len[] = {\n\t[RES_ISP] = ARRAY_SIZE(s5c73m3_isp_resolutions),\n\t[RES_JPEG] = ARRAY_SIZE(s5c73m3_jpeg_resolutions)\n};\n\nstatic const struct s5c73m3_interval s5c73m3_intervals[] = {\n\t{ COMM_FRAME_RATE_FIXED_7FPS, {142857, 1000000}, {3264, 2448} },\n\t{ COMM_FRAME_RATE_FIXED_15FPS, {66667, 1000000}, {3264, 2448} },\n\t{ COMM_FRAME_RATE_FIXED_20FPS, {50000, 1000000}, {2304, 1296} },\n\t{ COMM_FRAME_RATE_FIXED_30FPS, {33333, 1000000}, {2304, 1296} },\n};\n\n#define S5C73M3_DEFAULT_FRAME_INTERVAL 3  \n\nstatic void s5c73m3_fill_mbus_fmt(struct v4l2_mbus_framefmt *mf,\n\t\t\t\t  const struct s5c73m3_frame_size *fs,\n\t\t\t\t  u32 code)\n{\n\tmf->width = fs->width;\n\tmf->height = fs->height;\n\tmf->code = code;\n\tmf->colorspace = V4L2_COLORSPACE_JPEG;\n\tmf->field = V4L2_FIELD_NONE;\n}\n\nstatic int s5c73m3_i2c_write(struct i2c_client *client, u16 addr, u16 data)\n{\n\tu8 buf[4] = { addr >> 8, addr & 0xff, data >> 8, data & 0xff };\n\n\tint ret = i2c_master_send(client, buf, sizeof(buf));\n\n\tv4l_dbg(4, s5c73m3_dbg, client, \"%s: addr 0x%04x, data 0x%04x\\n\",\n\t\t __func__, addr, data);\n\n\tif (ret == 4)\n\t\treturn 0;\n\n\treturn ret < 0 ? ret : -EREMOTEIO;\n}\n\nstatic int s5c73m3_i2c_read(struct i2c_client *client, u16 addr, u16 *data)\n{\n\tint ret;\n\tu8 rbuf[2], wbuf[2] = { addr >> 8, addr & 0xff };\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = sizeof(wbuf),\n\t\t\t.buf = wbuf\n\t\t}, {\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = sizeof(rbuf),\n\t\t\t.buf = rbuf\n\t\t}\n\t};\n\t \n\tret = i2c_transfer(client->adapter, msg, 2);\n\tif (ret == 2) {\n\t\t*data = be16_to_cpup((__be16 *)rbuf);\n\t\tv4l2_dbg(4, s5c73m3_dbg, client,\n\t\t\t \"%s: addr: 0x%04x, data: 0x%04x\\n\",\n\t\t\t __func__, addr, *data);\n\t\treturn 0;\n\t}\n\n\tv4l2_err(client, \"I2C read failed: addr: %04x, (%d)\\n\", addr, ret);\n\n\treturn ret >= 0 ? -EREMOTEIO : ret;\n}\n\nint s5c73m3_write(struct s5c73m3 *state, u32 addr, u16 data)\n{\n\tstruct i2c_client *client = state->i2c_client;\n\tint ret;\n\n\tif ((addr ^ state->i2c_write_address) & 0xffff0000) {\n\t\tret = s5c73m3_i2c_write(client, REG_CMDWR_ADDRH, addr >> 16);\n\t\tif (ret < 0) {\n\t\t\tstate->i2c_write_address = 0;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((addr ^ state->i2c_write_address) & 0xffff) {\n\t\tret = s5c73m3_i2c_write(client, REG_CMDWR_ADDRL, addr & 0xffff);\n\t\tif (ret < 0) {\n\t\t\tstate->i2c_write_address = 0;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tstate->i2c_write_address = addr;\n\n\tret = s5c73m3_i2c_write(client, REG_CMDBUF_ADDR, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstate->i2c_write_address += 2;\n\n\treturn ret;\n}\n\nint s5c73m3_read(struct s5c73m3 *state, u32 addr, u16 *data)\n{\n\tstruct i2c_client *client = state->i2c_client;\n\tint ret;\n\n\tif ((addr ^ state->i2c_read_address) & 0xffff0000) {\n\t\tret = s5c73m3_i2c_write(client, REG_CMDRD_ADDRH, addr >> 16);\n\t\tif (ret < 0) {\n\t\t\tstate->i2c_read_address = 0;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((addr ^ state->i2c_read_address) & 0xffff) {\n\t\tret = s5c73m3_i2c_write(client, REG_CMDRD_ADDRL, addr & 0xffff);\n\t\tif (ret < 0) {\n\t\t\tstate->i2c_read_address = 0;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tstate->i2c_read_address = addr;\n\n\tret = s5c73m3_i2c_read(client, REG_CMDBUF_ADDR, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstate->i2c_read_address += 2;\n\n\treturn ret;\n}\n\nstatic int s5c73m3_check_status(struct s5c73m3 *state, unsigned int value)\n{\n\tunsigned long start = jiffies;\n\tunsigned long end = start + msecs_to_jiffies(2000);\n\tint ret;\n\tu16 status;\n\tint count = 0;\n\n\tdo {\n\t\tret = s5c73m3_read(state, REG_STATUS, &status);\n\t\tif (ret < 0 || status == value)\n\t\t\tbreak;\n\t\tusleep_range(500, 1000);\n\t\t++count;\n\t} while (time_is_after_jiffies(end));\n\n\tif (count > 0)\n\t\tv4l2_dbg(1, s5c73m3_dbg, &state->sensor_sd,\n\t\t\t \"status check took %dms\\n\",\n\t\t\t jiffies_to_msecs(jiffies - start));\n\n\tif (ret == 0 && status != value) {\n\t\tu16 i2c_status = 0;\n\t\tu16 i2c_seq_status = 0;\n\n\t\ts5c73m3_read(state, REG_I2C_STATUS, &i2c_status);\n\t\ts5c73m3_read(state, REG_I2C_SEQ_STATUS, &i2c_seq_status);\n\n\t\tv4l2_err(&state->sensor_sd,\n\t\t\t \"wrong status %#x, expected: %#x, i2c_status: %#x/%#x\\n\",\n\t\t\t status, value, i2c_status, i2c_seq_status);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn ret;\n}\n\nint s5c73m3_isp_command(struct s5c73m3 *state, u16 command, u16 data)\n{\n\tint ret;\n\n\tret = s5c73m3_check_status(state, REG_STATUS_ISP_COMMAND_COMPLETED);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = s5c73m3_write(state, 0x00095000, command);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = s5c73m3_write(state, 0x00095002, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn s5c73m3_write(state, REG_STATUS, 0x0001);\n}\n\nstatic int s5c73m3_isp_comm_result(struct s5c73m3 *state, u16 command,\n\t\t\t\t   u16 *data)\n{\n\treturn s5c73m3_read(state, COMM_RESULT_OFFSET + command, data);\n}\n\nstatic int s5c73m3_set_af_softlanding(struct s5c73m3 *state)\n{\n\tunsigned long start = jiffies;\n\tu16 af_softlanding;\n\tint count = 0;\n\tint ret;\n\tconst char *msg;\n\n\tret = s5c73m3_isp_command(state, COMM_AF_SOFTLANDING,\n\t\t\t\t\tCOMM_AF_SOFTLANDING_ON);\n\tif (ret < 0) {\n\t\tv4l2_info(&state->sensor_sd, \"AF soft-landing failed\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (;;) {\n\t\tret = s5c73m3_isp_comm_result(state, COMM_AF_SOFTLANDING,\n\t\t\t\t\t\t\t&af_softlanding);\n\t\tif (ret < 0) {\n\t\t\tmsg = \"failed\";\n\t\t\tbreak;\n\t\t}\n\t\tif (af_softlanding == COMM_AF_SOFTLANDING_RES_COMPLETE) {\n\t\t\tmsg = \"succeeded\";\n\t\t\tbreak;\n\t\t}\n\t\tif (++count > 100) {\n\t\t\tret = -ETIME;\n\t\t\tmsg = \"timed out\";\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(25);\n\t}\n\n\tv4l2_info(&state->sensor_sd, \"AF soft-landing %s after %dms\\n\",\n\t\t  msg, jiffies_to_msecs(jiffies - start));\n\n\treturn ret;\n}\n\nstatic int s5c73m3_load_fw(struct v4l2_subdev *sd)\n{\n\tstruct s5c73m3 *state = sensor_sd_to_s5c73m3(sd);\n\tstruct i2c_client *client = state->i2c_client;\n\tconst struct firmware *fw;\n\tint ret;\n\tchar fw_name[20];\n\n\tsnprintf(fw_name, sizeof(fw_name), \"SlimISP_%.2s.bin\",\n\t\t\t\t\t\t\tstate->fw_file_version);\n\tret = request_firmware(&fw, fw_name, &client->dev);\n\tif (ret < 0) {\n\t\tv4l2_err(sd, \"Firmware request failed (%s)\\n\", fw_name);\n\t\treturn -EINVAL;\n\t}\n\n\tv4l2_info(sd, \"Loading firmware (%s, %zu B)\\n\", fw_name, fw->size);\n\n\tret = s5c73m3_spi_write(state, fw->data, fw->size, 64);\n\n\tif (ret >= 0)\n\t\tstate->isp_ready = 1;\n\telse\n\t\tv4l2_err(sd, \"SPI write failed\\n\");\n\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic int s5c73m3_set_frame_size(struct s5c73m3 *state)\n{\n\tconst struct s5c73m3_frame_size *prev_size =\n\t\t\t\t\tstate->sensor_pix_size[RES_ISP];\n\tconst struct s5c73m3_frame_size *cap_size =\n\t\t\t\t\tstate->sensor_pix_size[RES_JPEG];\n\tunsigned int chg_mode;\n\n\tv4l2_dbg(1, s5c73m3_dbg, &state->sensor_sd,\n\t\t \"Preview size: %dx%d, reg_val: 0x%x\\n\",\n\t\t prev_size->width, prev_size->height, prev_size->reg_val);\n\n\tchg_mode = prev_size->reg_val | COMM_CHG_MODE_NEW;\n\n\tif (state->mbus_code == S5C73M3_JPEG_FMT) {\n\t\tv4l2_dbg(1, s5c73m3_dbg, &state->sensor_sd,\n\t\t\t \"Capture size: %dx%d, reg_val: 0x%x\\n\",\n\t\t\t cap_size->width, cap_size->height, cap_size->reg_val);\n\t\tchg_mode |= cap_size->reg_val;\n\t}\n\n\treturn s5c73m3_isp_command(state, COMM_CHG_MODE, chg_mode);\n}\n\nstatic int s5c73m3_set_frame_rate(struct s5c73m3 *state)\n{\n\tint ret;\n\n\tif (state->ctrls.stabilization->val)\n\t\treturn 0;\n\n\tif (WARN_ON(state->fiv == NULL))\n\t\treturn -EINVAL;\n\n\tret = s5c73m3_isp_command(state, COMM_FRAME_RATE, state->fiv->fps_reg);\n\tif (!ret)\n\t\tstate->apply_fiv = 0;\n\n\treturn ret;\n}\n\nstatic int __s5c73m3_s_stream(struct s5c73m3 *state, struct v4l2_subdev *sd,\n\t\t\t\t\t\t\t\tint on)\n{\n\tu16 mode;\n\tint ret;\n\n\tif (on && state->apply_fmt) {\n\t\tif (state->mbus_code == S5C73M3_JPEG_FMT)\n\t\t\tmode = COMM_IMG_OUTPUT_INTERLEAVED;\n\t\telse\n\t\t\tmode = COMM_IMG_OUTPUT_YUV;\n\n\t\tret = s5c73m3_isp_command(state, COMM_IMG_OUTPUT, mode);\n\t\tif (!ret)\n\t\t\tret = s5c73m3_set_frame_size(state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tstate->apply_fmt = 0;\n\t}\n\n\tret = s5c73m3_isp_command(state, COMM_SENSOR_STREAMING, !!on);\n\tif (ret)\n\t\treturn ret;\n\n\tstate->streaming = !!on;\n\n\tif (!on)\n\t\treturn 0;\n\n\tif (state->apply_fiv) {\n\t\tret = s5c73m3_set_frame_rate(state);\n\t\tif (ret < 0)\n\t\t\tv4l2_err(sd, \"Error setting frame rate(%d)\\n\", ret);\n\t}\n\n\treturn s5c73m3_check_status(state, REG_STATUS_ISP_COMMAND_COMPLETED);\n}\n\nstatic int s5c73m3_oif_s_stream(struct v4l2_subdev *sd, int on)\n{\n\tstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\n\tint ret;\n\n\tmutex_lock(&state->lock);\n\tret = __s5c73m3_s_stream(state, sd, on);\n\tmutex_unlock(&state->lock);\n\n\treturn ret;\n}\n\nstatic int s5c73m3_system_status_wait(struct s5c73m3 *state, u32 value,\n\t\t\t\t      unsigned int delay, unsigned int steps)\n{\n\tu16 reg = 0;\n\n\twhile (steps-- > 0) {\n\t\tint ret = s5c73m3_read(state, 0x30100010, &reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (reg == value)\n\t\t\treturn 0;\n\t\tusleep_range(delay, delay + 25);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int s5c73m3_read_fw_version(struct s5c73m3 *state)\n{\n\tstruct v4l2_subdev *sd = &state->sensor_sd;\n\tint i, ret;\n\tu16 data[2];\n\tint offset;\n\n\toffset = state->isp_ready ? 0x60 : 0;\n\n\tfor (i = 0; i < S5C73M3_SENSOR_FW_LEN / 2; i++) {\n\t\tret = s5c73m3_read(state, offset + i * 2, data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tstate->sensor_fw[i * 2] = (char)(*data & 0xff);\n\t\tstate->sensor_fw[i * 2 + 1] = (char)(*data >> 8);\n\t}\n\tstate->sensor_fw[S5C73M3_SENSOR_FW_LEN] = '\\0';\n\n\n\tfor (i = 0; i < S5C73M3_SENSOR_TYPE_LEN / 2; i++) {\n\t\tret = s5c73m3_read(state, offset + 6 + i * 2, data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tstate->sensor_type[i * 2] = (char)(*data & 0xff);\n\t\tstate->sensor_type[i * 2 + 1] = (char)(*data >> 8);\n\t}\n\tstate->sensor_type[S5C73M3_SENSOR_TYPE_LEN] = '\\0';\n\n\tret = s5c73m3_read(state, offset + 0x14, data);\n\tif (ret >= 0) {\n\t\tret = s5c73m3_read(state, offset + 0x16, data + 1);\n\t\tif (ret >= 0)\n\t\t\tstate->fw_size = data[0] + (data[1] << 16);\n\t}\n\n\tv4l2_info(sd, \"Sensor type: %s, FW version: %s\\n\",\n\t\t  state->sensor_type, state->sensor_fw);\n\treturn ret;\n}\n\nstatic int s5c73m3_fw_update_from(struct s5c73m3 *state)\n{\n\tstruct v4l2_subdev *sd = &state->sensor_sd;\n\tu16 status = COMM_FW_UPDATE_NOT_READY;\n\tint ret;\n\tint count = 0;\n\n\tv4l2_warn(sd, \"Updating F-ROM firmware.\\n\");\n\tdo {\n\t\tif (status == COMM_FW_UPDATE_NOT_READY) {\n\t\t\tret = s5c73m3_isp_command(state, COMM_FW_UPDATE, 0);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = s5c73m3_read(state, 0x00095906, &status);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tswitch (status) {\n\t\tcase COMM_FW_UPDATE_FAIL:\n\t\t\tv4l2_warn(sd, \"Updating F-ROM firmware failed.\\n\");\n\t\t\treturn -EIO;\n\t\tcase COMM_FW_UPDATE_SUCCESS:\n\t\t\tv4l2_warn(sd, \"Updating F-ROM firmware finished.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\t++count;\n\t\tmsleep(20);\n\t} while (count < 500);\n\n\tv4l2_warn(sd, \"Updating F-ROM firmware timed-out.\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic int s5c73m3_spi_boot(struct s5c73m3 *state, bool load_fw)\n{\n\tstruct v4l2_subdev *sd = &state->sensor_sd;\n\tint ret;\n\n\t \n\tret = s5c73m3_write(state, 0x30000004, 0xffff);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(400, 500);\n\n\t \n\tret = s5c73m3_system_status_wait(state, 0x0c, 100, 3);\n\tif (ret < 0) {\n\t\tv4l2_err(sd, \"booting failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = s5c73m3_write(state, 0x30100014, 0x2146);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = s5c73m3_write(state, 0x30100010, 0x210c);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(200, 250);\n\n\t \n\tret = s5c73m3_system_status_wait(state, 0x210d, 100, 300);\n\tif (ret < 0)\n\t\tv4l2_err(sd, \"SPI not ready: %d\\n\", ret);\n\n\t \n\tif (load_fw)\n\t\ts5c73m3_load_fw(sd);\n\n\t \n\tret = s5c73m3_write(state, 0x30000004, 0xfffd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = s5c73m3_write(state, 0x301000a4, 0x0183);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = s5c73m3_write(state, 0x30000004, 0xffff);\n\tif (ret < 0 || !load_fw)\n\t\treturn ret;\n\n\tret = s5c73m3_read_fw_version(state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (load_fw && update_fw) {\n\t\tret = s5c73m3_fw_update_from(state);\n\t\tupdate_fw = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int s5c73m3_set_timing_register_for_vdd(struct s5c73m3 *state)\n{\n\tstatic const u32 regs[][2] = {\n\t\t{ 0x30100018, 0x0618 },\n\t\t{ 0x3010001c, 0x10c1 },\n\t\t{ 0x30100020, 0x249e }\n\t};\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(regs); i++) {\n\t\tret = s5c73m3_write(state, regs[i][0], regs[i][1]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void s5c73m3_set_fw_file_version(struct s5c73m3 *state)\n{\n\tswitch (state->sensor_fw[0]) {\n\tcase 'G':\n\tcase 'O':\n\t\tstate->fw_file_version[0] = 'G';\n\t\tbreak;\n\tcase 'S':\n\tcase 'Z':\n\t\tstate->fw_file_version[0] = 'Z';\n\t\tbreak;\n\t}\n\n\tswitch (state->sensor_fw[1]) {\n\tcase 'C'...'F':\n\t\tstate->fw_file_version[1] = state->sensor_fw[1];\n\t\tbreak;\n\t}\n}\n\nstatic int s5c73m3_get_fw_version(struct s5c73m3 *state)\n{\n\tstruct v4l2_subdev *sd = &state->sensor_sd;\n\tint ret;\n\n\t \n\tret = s5c73m3_write(state, 0x30000004, 0xffff);\n\tif (ret < 0)\n\t\treturn ret;\n\tusleep_range(400, 500);\n\n\t \n\tret = s5c73m3_system_status_wait(state, 0x0c, 100, 3);\n\tif (ret < 0) {\n\n\t\tv4l2_err(sd, \"%s: booting failed: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = s5c73m3_write(state, 0x30100120, 0x0820);\n\tret = s5c73m3_write(state, 0x30100124, 0x0820);\n\n\t \n\tret = s5c73m3_write(state, 0x00010418, 0x0008);\n\n\t \n\tret = s5c73m3_write(state, 0x30100014, 0x2146);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = s5c73m3_write(state, 0x30100010, 0x230c);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(200, 250);\n\n\t \n\tret = s5c73m3_system_status_wait(state, 0x230e, 100, 300);\n\tif (ret < 0)\n\t\tv4l2_err(sd, \"SPI not ready: %d\\n\", ret);\n\n\t \n\tret = s5c73m3_write(state, 0x30000004, 0xfffd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = s5c73m3_write(state, 0x301000a4, 0x0183);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ts5c73m3_set_timing_register_for_vdd(state);\n\n\tret = s5c73m3_read_fw_version(state);\n\n\ts5c73m3_set_fw_file_version(state);\n\n\treturn ret;\n}\n\nstatic int s5c73m3_rom_boot(struct s5c73m3 *state, bool load_fw)\n{\n\tstatic const u32 boot_regs[][2] = {\n\t\t{ 0x3100010c, 0x0044 },\n\t\t{ 0x31000108, 0x000d },\n\t\t{ 0x31000304, 0x0001 },\n\t\t{ 0x00010000, 0x5800 },\n\t\t{ 0x00010002, 0x0002 },\n\t\t{ 0x31000000, 0x0001 },\n\t\t{ 0x30100014, 0x1b85 },\n\t\t{ 0x30100010, 0x230c }\n\t};\n\tstruct v4l2_subdev *sd = &state->sensor_sd;\n\tint i, ret;\n\n\t \n\tret = s5c73m3_write(state, 0x30000004, 0xffff);\n\tif (ret < 0)\n\t\treturn ret;\n\tusleep_range(400, 450);\n\n\t \n\tret = s5c73m3_system_status_wait(state, 0x0c, 100, 4);\n\tif (ret < 0) {\n\t\tv4l2_err(sd, \"Booting failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(boot_regs); i++) {\n\t\tret = s5c73m3_write(state, boot_regs[i][0], boot_regs[i][1]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tmsleep(200);\n\n\t \n\tret = s5c73m3_system_status_wait(state, 0x230e, 1000, 150);\n\tif (ret < 0) {\n\t\tv4l2_err(sd, \"Binary read failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = s5c73m3_write(state, 0x30000004, 0xfffd);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tret = s5c73m3_write(state, 0x301000a4, 0x0183);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tret = s5c73m3_write(state, 0x30000004, 0xffff);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstate->isp_ready = 1;\n\n\treturn s5c73m3_read_fw_version(state);\n}\n\nstatic int s5c73m3_isp_init(struct s5c73m3 *state)\n{\n\tint ret;\n\n\tstate->i2c_read_address = 0;\n\tstate->i2c_write_address = 0;\n\n\tret = s5c73m3_i2c_write(state->i2c_client, AHB_MSB_ADDR_PTR, 0x3310);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (boot_from_rom)\n\t\treturn s5c73m3_rom_boot(state, true);\n\telse\n\t\treturn s5c73m3_spi_boot(state, true);\n}\n\nstatic const struct s5c73m3_frame_size *s5c73m3_find_frame_size(\n\t\t\t\t\tstruct v4l2_mbus_framefmt *fmt,\n\t\t\t\t\tenum s5c73m3_resolution_types idx)\n{\n\tconst struct s5c73m3_frame_size *fs;\n\tconst struct s5c73m3_frame_size *best_fs;\n\tint best_dist = INT_MAX;\n\tint i;\n\n\tfs = s5c73m3_resolutions[idx];\n\tbest_fs = NULL;\n\tfor (i = 0; i < s5c73m3_resolutions_len[idx]; ++i) {\n\t\tint dist = abs(fs->width - fmt->width) +\n\t\t\t\t\t\tabs(fs->height - fmt->height);\n\t\tif (dist < best_dist) {\n\t\t\tbest_dist = dist;\n\t\t\tbest_fs = fs;\n\t\t}\n\t\t++fs;\n\t}\n\n\treturn best_fs;\n}\n\nstatic void s5c73m3_oif_try_format(struct s5c73m3 *state,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_format *fmt,\n\t\t\t\t   const struct s5c73m3_frame_size **fs)\n{\n\tstruct v4l2_subdev *sd = &state->sensor_sd;\n\tu32 code;\n\n\tswitch (fmt->pad) {\n\tcase OIF_ISP_PAD:\n\t\t*fs = s5c73m3_find_frame_size(&fmt->format, RES_ISP);\n\t\tcode = S5C73M3_ISP_FMT;\n\t\tbreak;\n\tcase OIF_JPEG_PAD:\n\t\t*fs = s5c73m3_find_frame_size(&fmt->format, RES_JPEG);\n\t\tcode = S5C73M3_JPEG_FMT;\n\t\tbreak;\n\tcase OIF_SOURCE_PAD:\n\tdefault:\n\t\tif (fmt->format.code == S5C73M3_JPEG_FMT)\n\t\t\tcode = S5C73M3_JPEG_FMT;\n\t\telse\n\t\t\tcode = S5C73M3_ISP_FMT;\n\n\t\tif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\t\t*fs = state->oif_pix_size[RES_ISP];\n\t\telse\n\t\t\t*fs = s5c73m3_find_frame_size(\n\t\t\t\t\t\tv4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t\t\t\t\t   OIF_ISP_PAD),\n\t\t\t\t\t\tRES_ISP);\n\t\tbreak;\n\t}\n\n\ts5c73m3_fill_mbus_fmt(&fmt->format, *fs, code);\n}\n\nstatic void s5c73m3_try_format(struct s5c73m3 *state,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *fmt,\n\t\t\t      const struct s5c73m3_frame_size **fs)\n{\n\tu32 code;\n\n\tif (fmt->pad == S5C73M3_ISP_PAD) {\n\t\t*fs = s5c73m3_find_frame_size(&fmt->format, RES_ISP);\n\t\tcode = S5C73M3_ISP_FMT;\n\t} else {\n\t\t*fs = s5c73m3_find_frame_size(&fmt->format, RES_JPEG);\n\t\tcode = S5C73M3_JPEG_FMT;\n\t}\n\n\ts5c73m3_fill_mbus_fmt(&fmt->format, *fs, code);\n}\n\nstatic int s5c73m3_oif_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *fi)\n{\n\tstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\n\n\tif (fi->pad != OIF_SOURCE_PAD)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&state->lock);\n\tfi->interval = state->fiv->interval;\n\tmutex_unlock(&state->lock);\n\n\treturn 0;\n}\n\nstatic int __s5c73m3_set_frame_interval(struct s5c73m3 *state,\n\t\t\t\t\tstruct v4l2_subdev_frame_interval *fi)\n{\n\tconst struct s5c73m3_frame_size *prev_size =\n\t\t\t\t\t\tstate->sensor_pix_size[RES_ISP];\n\tconst struct s5c73m3_interval *fiv = &s5c73m3_intervals[0];\n\tunsigned int ret, min_err = UINT_MAX;\n\tunsigned int i, fr_time;\n\n\tif (fi->interval.denominator == 0)\n\t\treturn -EINVAL;\n\n\tfr_time = fi->interval.numerator * 1000 / fi->interval.denominator;\n\n\tfor (i = 0; i < ARRAY_SIZE(s5c73m3_intervals); i++) {\n\t\tconst struct s5c73m3_interval *iv = &s5c73m3_intervals[i];\n\n\t\tif (prev_size->width > iv->size.width ||\n\t\t    prev_size->height > iv->size.height)\n\t\t\tcontinue;\n\n\t\tret = abs(iv->interval.numerator / 1000 - fr_time);\n\t\tif (ret < min_err) {\n\t\t\tfiv = iv;\n\t\t\tmin_err = ret;\n\t\t}\n\t}\n\tstate->fiv = fiv;\n\n\tv4l2_dbg(1, s5c73m3_dbg, &state->sensor_sd,\n\t\t \"Changed frame interval to %u us\\n\", fiv->interval.numerator);\n\treturn 0;\n}\n\nstatic int s5c73m3_oif_s_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *fi)\n{\n\tstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\n\tint ret;\n\n\tif (fi->pad != OIF_SOURCE_PAD)\n\t\treturn -EINVAL;\n\n\tv4l2_dbg(1, s5c73m3_dbg, sd, \"Setting %d/%d frame interval\\n\",\n\t\t fi->interval.numerator, fi->interval.denominator);\n\n\tmutex_lock(&state->lock);\n\n\tret = __s5c73m3_set_frame_interval(state, fi);\n\tif (!ret) {\n\t\tif (state->streaming)\n\t\t\tret = s5c73m3_set_frame_rate(state);\n\t\telse\n\t\t\tstate->apply_fiv = 1;\n\t}\n\tmutex_unlock(&state->lock);\n\treturn ret;\n}\n\nstatic int s5c73m3_oif_enum_frame_interval(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_frame_interval_enum *fie)\n{\n\tstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\n\tconst struct s5c73m3_interval *fi;\n\tint ret = 0;\n\n\tif (fie->pad != OIF_SOURCE_PAD)\n\t\treturn -EINVAL;\n\tif (fie->index >= ARRAY_SIZE(s5c73m3_intervals))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&state->lock);\n\tfi = &s5c73m3_intervals[fie->index];\n\tif (fie->width > fi->size.width || fie->height > fi->size.height)\n\t\tret = -EINVAL;\n\telse\n\t\tfie->interval = fi->interval;\n\tmutex_unlock(&state->lock);\n\n\treturn ret;\n}\n\nstatic int s5c73m3_oif_get_pad_code(int pad, int index)\n{\n\tif (pad == OIF_SOURCE_PAD) {\n\t\tif (index > 1)\n\t\t\treturn -EINVAL;\n\t\treturn (index == 0) ? S5C73M3_ISP_FMT : S5C73M3_JPEG_FMT;\n\t}\n\n\tif (index > 0)\n\t\treturn -EINVAL;\n\n\treturn (pad == OIF_ISP_PAD) ? S5C73M3_ISP_FMT : S5C73M3_JPEG_FMT;\n}\n\nstatic int s5c73m3_get_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct s5c73m3 *state = sensor_sd_to_s5c73m3(sd);\n\tconst struct s5c73m3_frame_size *fs;\n\tu32 code;\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tfmt->format = *v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t\t\t  fmt->pad);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&state->lock);\n\n\tswitch (fmt->pad) {\n\tcase S5C73M3_ISP_PAD:\n\t\tcode = S5C73M3_ISP_FMT;\n\t\tfs = state->sensor_pix_size[RES_ISP];\n\t\tbreak;\n\tcase S5C73M3_JPEG_PAD:\n\t\tcode = S5C73M3_JPEG_FMT;\n\t\tfs = state->sensor_pix_size[RES_JPEG];\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&state->lock);\n\t\treturn -EINVAL;\n\t}\n\ts5c73m3_fill_mbus_fmt(&fmt->format, fs, code);\n\n\tmutex_unlock(&state->lock);\n\treturn 0;\n}\n\nstatic int s5c73m3_oif_get_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\n\tconst struct s5c73m3_frame_size *fs;\n\tu32 code;\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tfmt->format = *v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t\t\t  fmt->pad);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&state->lock);\n\n\tswitch (fmt->pad) {\n\tcase OIF_ISP_PAD:\n\t\tcode = S5C73M3_ISP_FMT;\n\t\tfs = state->oif_pix_size[RES_ISP];\n\t\tbreak;\n\tcase OIF_JPEG_PAD:\n\t\tcode = S5C73M3_JPEG_FMT;\n\t\tfs = state->oif_pix_size[RES_JPEG];\n\t\tbreak;\n\tcase OIF_SOURCE_PAD:\n\t\tcode = state->mbus_code;\n\t\tfs = state->oif_pix_size[RES_ISP];\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&state->lock);\n\t\treturn -EINVAL;\n\t}\n\ts5c73m3_fill_mbus_fmt(&fmt->format, fs, code);\n\n\tmutex_unlock(&state->lock);\n\treturn 0;\n}\n\nstatic int s5c73m3_set_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tconst struct s5c73m3_frame_size *frame_size = NULL;\n\tstruct s5c73m3 *state = sensor_sd_to_s5c73m3(sd);\n\tstruct v4l2_mbus_framefmt *mf;\n\tint ret = 0;\n\n\tmutex_lock(&state->lock);\n\n\ts5c73m3_try_format(state, sd_state, fmt, &frame_size);\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tmf = v4l2_subdev_get_try_format(sd, sd_state, fmt->pad);\n\t\t*mf = fmt->format;\n\t} else {\n\t\tswitch (fmt->pad) {\n\t\tcase S5C73M3_ISP_PAD:\n\t\t\tstate->sensor_pix_size[RES_ISP] = frame_size;\n\t\t\tbreak;\n\t\tcase S5C73M3_JPEG_PAD:\n\t\t\tstate->sensor_pix_size[RES_JPEG] = frame_size;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EBUSY;\n\t\t}\n\n\t\tif (state->streaming)\n\t\t\tret = -EBUSY;\n\t\telse\n\t\t\tstate->apply_fmt = 1;\n\t}\n\n\tmutex_unlock(&state->lock);\n\n\treturn ret;\n}\n\nstatic int s5c73m3_oif_set_fmt(struct v4l2_subdev *sd,\n\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t struct v4l2_subdev_format *fmt)\n{\n\tconst struct s5c73m3_frame_size *frame_size = NULL;\n\tstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\n\tstruct v4l2_mbus_framefmt *mf;\n\tint ret = 0;\n\n\tmutex_lock(&state->lock);\n\n\ts5c73m3_oif_try_format(state, sd_state, fmt, &frame_size);\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tmf = v4l2_subdev_get_try_format(sd, sd_state, fmt->pad);\n\t\t*mf = fmt->format;\n\t\tif (fmt->pad == OIF_ISP_PAD) {\n\t\t\tmf = v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t\t\tOIF_SOURCE_PAD);\n\t\t\tmf->width = fmt->format.width;\n\t\t\tmf->height = fmt->format.height;\n\t\t}\n\t} else {\n\t\tswitch (fmt->pad) {\n\t\tcase OIF_ISP_PAD:\n\t\t\tstate->oif_pix_size[RES_ISP] = frame_size;\n\t\t\tbreak;\n\t\tcase OIF_JPEG_PAD:\n\t\t\tstate->oif_pix_size[RES_JPEG] = frame_size;\n\t\t\tbreak;\n\t\tcase OIF_SOURCE_PAD:\n\t\t\tstate->mbus_code = fmt->format.code;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EBUSY;\n\t\t}\n\n\t\tif (state->streaming)\n\t\t\tret = -EBUSY;\n\t\telse\n\t\t\tstate->apply_fmt = 1;\n\t}\n\n\tmutex_unlock(&state->lock);\n\n\treturn ret;\n}\n\nstatic int s5c73m3_oif_get_frame_desc(struct v4l2_subdev *sd, unsigned int pad,\n\t\t\t\t  struct v4l2_mbus_frame_desc *fd)\n{\n\tstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\n\tint i;\n\n\tif (pad != OIF_SOURCE_PAD || fd == NULL)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&state->lock);\n\tfd->num_entries = 2;\n\tfor (i = 0; i < fd->num_entries; i++)\n\t\tfd->entry[i] = state->frame_desc.entry[i];\n\tmutex_unlock(&state->lock);\n\n\treturn 0;\n}\n\nstatic int s5c73m3_oif_set_frame_desc(struct v4l2_subdev *sd, unsigned int pad,\n\t\t\t\t      struct v4l2_mbus_frame_desc *fd)\n{\n\tstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\n\tstruct v4l2_mbus_frame_desc *frame_desc = &state->frame_desc;\n\tint i;\n\n\tif (pad != OIF_SOURCE_PAD || fd == NULL)\n\t\treturn -EINVAL;\n\n\tfd->entry[0].length = 10 * SZ_1M;\n\tfd->entry[1].length = max_t(u32, fd->entry[1].length,\n\t\t\t\t    S5C73M3_EMBEDDED_DATA_MAXLEN);\n\tfd->num_entries = 2;\n\n\tmutex_lock(&state->lock);\n\tfor (i = 0; i < fd->num_entries; i++)\n\t\tframe_desc->entry[i] = fd->entry[i];\n\tmutex_unlock(&state->lock);\n\n\treturn 0;\n}\n\nstatic int s5c73m3_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstatic const int codes[] = {\n\t\t\t[S5C73M3_ISP_PAD] = S5C73M3_ISP_FMT,\n\t\t\t[S5C73M3_JPEG_PAD] = S5C73M3_JPEG_FMT};\n\n\tif (code->index > 0 || code->pad >= S5C73M3_NUM_PADS)\n\t\treturn -EINVAL;\n\n\tcode->code = codes[code->pad];\n\n\treturn 0;\n}\n\nstatic int s5c73m3_oif_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tint ret;\n\n\tret = s5c73m3_oif_get_pad_code(code->pad, code->index);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcode->code = ret;\n\n\treturn 0;\n}\n\nstatic int s5c73m3_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_frame_size_enum *fse)\n{\n\tint idx;\n\n\tif (fse->pad == S5C73M3_ISP_PAD) {\n\t\tif (fse->code != S5C73M3_ISP_FMT)\n\t\t\treturn -EINVAL;\n\t\tidx = RES_ISP;\n\t} else{\n\t\tif (fse->code != S5C73M3_JPEG_FMT)\n\t\t\treturn -EINVAL;\n\t\tidx = RES_JPEG;\n\t}\n\n\tif (fse->index >= s5c73m3_resolutions_len[idx])\n\t\treturn -EINVAL;\n\n\tfse->min_width  = s5c73m3_resolutions[idx][fse->index].width;\n\tfse->max_width  = fse->min_width;\n\tfse->max_height = s5c73m3_resolutions[idx][fse->index].height;\n\tfse->min_height = fse->max_height;\n\n\treturn 0;\n}\n\nstatic int s5c73m3_oif_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\n\tint idx;\n\n\tif (fse->pad == OIF_SOURCE_PAD) {\n\t\tif (fse->index > 0)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (fse->code) {\n\t\tcase S5C73M3_JPEG_FMT:\n\t\tcase S5C73M3_ISP_FMT: {\n\t\t\tunsigned w, h;\n\n\t\t\tif (fse->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\t\t\tstruct v4l2_mbus_framefmt *mf;\n\n\t\t\t\tmf = v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t\t\t\tOIF_ISP_PAD);\n\n\t\t\t\tw = mf->width;\n\t\t\t\th = mf->height;\n\t\t\t} else {\n\t\t\t\tconst struct s5c73m3_frame_size *fs;\n\n\t\t\t\tfs = state->oif_pix_size[RES_ISP];\n\t\t\t\tw = fs->width;\n\t\t\t\th = fs->height;\n\t\t\t}\n\t\t\tfse->max_width = fse->min_width = w;\n\t\t\tfse->max_height = fse->min_height = h;\n\t\t\treturn 0;\n\t\t}\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (fse->code != s5c73m3_oif_get_pad_code(fse->pad, 0))\n\t\treturn -EINVAL;\n\n\tif (fse->pad == OIF_JPEG_PAD)\n\t\tidx = RES_JPEG;\n\telse\n\t\tidx = RES_ISP;\n\n\tif (fse->index >= s5c73m3_resolutions_len[idx])\n\t\treturn -EINVAL;\n\n\tfse->min_width  = s5c73m3_resolutions[idx][fse->index].width;\n\tfse->max_width  = fse->min_width;\n\tfse->max_height = s5c73m3_resolutions[idx][fse->index].height;\n\tfse->min_height = fse->max_height;\n\n\treturn 0;\n}\n\nstatic int s5c73m3_oif_log_status(struct v4l2_subdev *sd)\n{\n\tstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\n\n\tv4l2_ctrl_handler_log_status(sd->ctrl_handler, sd->name);\n\n\tv4l2_info(sd, \"power: %d, apply_fmt: %d\\n\", state->power,\n\t\t\t\t\t\t\tstate->apply_fmt);\n\n\treturn 0;\n}\n\nstatic int s5c73m3_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_mbus_framefmt *mf;\n\n\tmf = v4l2_subdev_get_try_format(sd, fh->state, S5C73M3_ISP_PAD);\n\ts5c73m3_fill_mbus_fmt(mf, &s5c73m3_isp_resolutions[1],\n\t\t\t\t\t\tS5C73M3_ISP_FMT);\n\n\tmf = v4l2_subdev_get_try_format(sd, fh->state, S5C73M3_JPEG_PAD);\n\ts5c73m3_fill_mbus_fmt(mf, &s5c73m3_jpeg_resolutions[1],\n\t\t\t\t\tS5C73M3_JPEG_FMT);\n\n\treturn 0;\n}\n\nstatic int s5c73m3_oif_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_mbus_framefmt *mf;\n\n\tmf = v4l2_subdev_get_try_format(sd, fh->state, OIF_ISP_PAD);\n\ts5c73m3_fill_mbus_fmt(mf, &s5c73m3_isp_resolutions[1],\n\t\t\t\t\t\tS5C73M3_ISP_FMT);\n\n\tmf = v4l2_subdev_get_try_format(sd, fh->state, OIF_JPEG_PAD);\n\ts5c73m3_fill_mbus_fmt(mf, &s5c73m3_jpeg_resolutions[1],\n\t\t\t\t\tS5C73M3_JPEG_FMT);\n\n\tmf = v4l2_subdev_get_try_format(sd, fh->state, OIF_SOURCE_PAD);\n\ts5c73m3_fill_mbus_fmt(mf, &s5c73m3_isp_resolutions[1],\n\t\t\t\t\t\tS5C73M3_ISP_FMT);\n\treturn 0;\n}\n\nstatic int __s5c73m3_power_on(struct s5c73m3 *state)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < S5C73M3_MAX_SUPPLIES; i++) {\n\t\tret = regulator_enable(state->supplies[i].consumer);\n\t\tif (ret)\n\t\t\tgoto err_reg_dis;\n\t}\n\n\tret = clk_set_rate(state->clock, state->mclk_frequency);\n\tif (ret < 0)\n\t\tgoto err_reg_dis;\n\n\tret = clk_prepare_enable(state->clock);\n\tif (ret < 0)\n\t\tgoto err_reg_dis;\n\n\tv4l2_dbg(1, s5c73m3_dbg, &state->oif_sd, \"clock frequency: %ld\\n\",\n\t\t\t\t\tclk_get_rate(state->clock));\n\n\tgpiod_set_value(state->stby, 0);\n\tusleep_range(100, 200);\n\tgpiod_set_value(state->reset, 0);\n\tusleep_range(50, 100);\n\n\treturn 0;\n\nerr_reg_dis:\n\tfor (--i; i >= 0; i--)\n\t\tregulator_disable(state->supplies[i].consumer);\n\treturn ret;\n}\n\nstatic int __s5c73m3_power_off(struct s5c73m3 *state)\n{\n\tint i, ret;\n\n\tgpiod_set_value(state->reset, 1);\n\tusleep_range(10, 50);\n\tgpiod_set_value(state->stby, 1);\n\tusleep_range(100, 200);\n\n\tclk_disable_unprepare(state->clock);\n\n\tstate->streaming = 0;\n\tstate->isp_ready = 0;\n\n\tfor (i = S5C73M3_MAX_SUPPLIES - 1; i >= 0; i--) {\n\t\tret = regulator_disable(state->supplies[i].consumer);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tfor (++i; i < S5C73M3_MAX_SUPPLIES; i++) {\n\t\tint r = regulator_enable(state->supplies[i].consumer);\n\t\tif (r < 0)\n\t\t\tv4l2_err(&state->oif_sd, \"Failed to re-enable %s: %d\\n\",\n\t\t\t\t state->supplies[i].supply, r);\n\t}\n\n\tclk_prepare_enable(state->clock);\n\treturn ret;\n}\n\nstatic int s5c73m3_oif_set_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\n\tint ret = 0;\n\n\tmutex_lock(&state->lock);\n\n\tif (on && !state->power) {\n\t\tret = __s5c73m3_power_on(state);\n\t\tif (!ret)\n\t\t\tret = s5c73m3_isp_init(state);\n\t\tif (!ret) {\n\t\t\tstate->apply_fiv = 1;\n\t\t\tstate->apply_fmt = 1;\n\t\t}\n\t} else if (state->power == !on) {\n\t\tret = s5c73m3_set_af_softlanding(state);\n\t\tif (!ret)\n\t\t\tret = __s5c73m3_power_off(state);\n\t\telse\n\t\t\tv4l2_err(sd, \"Soft landing lens failed\\n\");\n\t}\n\tif (!ret)\n\t\tstate->power += on ? 1 : -1;\n\n\tv4l2_dbg(1, s5c73m3_dbg, sd, \"%s: power: %d\\n\",\n\t\t __func__, state->power);\n\n\tmutex_unlock(&state->lock);\n\treturn ret;\n}\n\nstatic int s5c73m3_oif_registered(struct v4l2_subdev *sd)\n{\n\tstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\n\tint ret;\n\n\tret = v4l2_device_register_subdev(sd->v4l2_dev, &state->sensor_sd);\n\tif (ret) {\n\t\tv4l2_err(sd->v4l2_dev, \"Failed to register %s\\n\",\n\t\t\t\t\t\t\tstate->oif_sd.name);\n\t\treturn ret;\n\t}\n\n\tret = media_create_pad_link(&state->sensor_sd.entity,\n\t\t\tS5C73M3_ISP_PAD, &state->oif_sd.entity, OIF_ISP_PAD,\n\t\t\tMEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);\n\n\tret = media_create_pad_link(&state->sensor_sd.entity,\n\t\t\tS5C73M3_JPEG_PAD, &state->oif_sd.entity, OIF_JPEG_PAD,\n\t\t\tMEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);\n\n\treturn ret;\n}\n\nstatic void s5c73m3_oif_unregistered(struct v4l2_subdev *sd)\n{\n\tstruct s5c73m3 *state = oif_sd_to_s5c73m3(sd);\n\tv4l2_device_unregister_subdev(&state->sensor_sd);\n}\n\nstatic const struct v4l2_subdev_internal_ops s5c73m3_internal_ops = {\n\t.open\t\t= s5c73m3_open,\n};\n\nstatic const struct v4l2_subdev_pad_ops s5c73m3_pad_ops = {\n\t.enum_mbus_code\t\t= s5c73m3_enum_mbus_code,\n\t.enum_frame_size\t= s5c73m3_enum_frame_size,\n\t.get_fmt\t\t= s5c73m3_get_fmt,\n\t.set_fmt\t\t= s5c73m3_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops s5c73m3_subdev_ops = {\n\t.pad\t= &s5c73m3_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops oif_internal_ops = {\n\t.registered\t= s5c73m3_oif_registered,\n\t.unregistered\t= s5c73m3_oif_unregistered,\n\t.open\t\t= s5c73m3_oif_open,\n};\n\nstatic const struct v4l2_subdev_pad_ops s5c73m3_oif_pad_ops = {\n\t.enum_mbus_code\t\t= s5c73m3_oif_enum_mbus_code,\n\t.enum_frame_size\t= s5c73m3_oif_enum_frame_size,\n\t.enum_frame_interval\t= s5c73m3_oif_enum_frame_interval,\n\t.get_fmt\t\t= s5c73m3_oif_get_fmt,\n\t.set_fmt\t\t= s5c73m3_oif_set_fmt,\n\t.get_frame_desc\t\t= s5c73m3_oif_get_frame_desc,\n\t.set_frame_desc\t\t= s5c73m3_oif_set_frame_desc,\n};\n\nstatic const struct v4l2_subdev_core_ops s5c73m3_oif_core_ops = {\n\t.s_power\t= s5c73m3_oif_set_power,\n\t.log_status\t= s5c73m3_oif_log_status,\n};\n\nstatic const struct v4l2_subdev_video_ops s5c73m3_oif_video_ops = {\n\t.s_stream\t\t= s5c73m3_oif_s_stream,\n\t.g_frame_interval\t= s5c73m3_oif_g_frame_interval,\n\t.s_frame_interval\t= s5c73m3_oif_s_frame_interval,\n};\n\nstatic const struct v4l2_subdev_ops oif_subdev_ops = {\n\t.core\t= &s5c73m3_oif_core_ops,\n\t.pad\t= &s5c73m3_oif_pad_ops,\n\t.video\t= &s5c73m3_oif_video_ops,\n};\n\nstatic int s5c73m3_get_dt_data(struct s5c73m3 *state)\n{\n\tstruct device *dev = &state->i2c_client->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct device_node *node_ep;\n\tstruct v4l2_fwnode_endpoint ep = { .bus_type = 0 };\n\tint ret;\n\n\tif (!node)\n\t\treturn -EINVAL;\n\n\tstate->clock = devm_clk_get(dev, S5C73M3_CLK_NAME);\n\tif (IS_ERR(state->clock))\n\t\treturn PTR_ERR(state->clock);\n\n\tif (of_property_read_u32(node, \"clock-frequency\",\n\t\t\t\t &state->mclk_frequency)) {\n\t\tstate->mclk_frequency = S5C73M3_DEFAULT_MCLK_FREQ;\n\t\tdev_info(dev, \"using default %u Hz clock frequency\\n\",\n\t\t\t\t\tstate->mclk_frequency);\n\t}\n\n\t \n\tstate->stby = devm_gpiod_get(dev, \"standby\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(state->stby))\n\t\treturn dev_err_probe(dev, PTR_ERR(state->stby),\n\t\t\t\t     \"failed to request gpio S5C73M3_STBY\\n\");\n\tgpiod_set_consumer_name(state->stby, \"S5C73M3_STBY\");\n\tstate->reset = devm_gpiod_get(dev, \"xshutdown\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(state->reset))\n\t\treturn dev_err_probe(dev, PTR_ERR(state->reset),\n\t\t\t\t     \"failed to request gpio S5C73M3_RST\\n\");\n\tgpiod_set_consumer_name(state->reset, \"S5C73M3_RST\");\n\n\tnode_ep = of_graph_get_next_endpoint(node, NULL);\n\tif (!node_ep) {\n\t\tdev_warn(dev, \"no endpoint defined for node: %pOF\\n\", node);\n\t\treturn 0;\n\t}\n\n\tret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(node_ep), &ep);\n\tof_node_put(node_ep);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ep.bus_type != V4L2_MBUS_CSI2_DPHY) {\n\t\tdev_err(dev, \"unsupported bus type\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (ep.bus.mipi_csi2.num_data_lanes != S5C73M3_MIPI_DATA_LANES)\n\t\tdev_info(dev, \"falling back to 4 MIPI CSI-2 data lanes\\n\");\n\n\treturn 0;\n}\n\nstatic int s5c73m3_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_subdev *oif_sd;\n\tstruct s5c73m3 *state;\n\tint ret, i;\n\n\tstate = devm_kzalloc(dev, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->i2c_client = client;\n\tret = s5c73m3_get_dt_data(state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_init(&state->lock);\n\tsd = &state->sensor_sd;\n\toif_sd = &state->oif_sd;\n\n\tv4l2_subdev_init(sd, &s5c73m3_subdev_ops);\n\tsd->owner = client->dev.driver->owner;\n\tv4l2_set_subdevdata(sd, state);\n\tstrscpy(sd->name, \"S5C73M3\", sizeof(sd->name));\n\n\tsd->internal_ops = &s5c73m3_internal_ops;\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tstate->sensor_pads[S5C73M3_JPEG_PAD].flags = MEDIA_PAD_FL_SOURCE;\n\tstate->sensor_pads[S5C73M3_ISP_PAD].flags = MEDIA_PAD_FL_SOURCE;\n\tsd->entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\n\tret = media_entity_pads_init(&sd->entity, S5C73M3_NUM_PADS,\n\t\t\t\t\t\t\tstate->sensor_pads);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv4l2_i2c_subdev_init(oif_sd, client, &oif_subdev_ops);\n\t \n\tstrscpy(oif_sd->name, \"S5C73M3-OIF\", sizeof(oif_sd->name));\n\n\toif_sd->internal_ops = &oif_internal_ops;\n\toif_sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tstate->oif_pads[OIF_ISP_PAD].flags = MEDIA_PAD_FL_SINK;\n\tstate->oif_pads[OIF_JPEG_PAD].flags = MEDIA_PAD_FL_SINK;\n\tstate->oif_pads[OIF_SOURCE_PAD].flags = MEDIA_PAD_FL_SOURCE;\n\toif_sd->entity.function = MEDIA_ENT_F_PROC_VIDEO_SCALER;\n\n\tret = media_entity_pads_init(&oif_sd->entity, OIF_NUM_PADS,\n\t\t\t\t\t\t\tstate->oif_pads);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < S5C73M3_MAX_SUPPLIES; i++)\n\t\tstate->supplies[i].supply = s5c73m3_supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, S5C73M3_MAX_SUPPLIES,\n\t\t\t       state->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get regulators\\n\");\n\t\tgoto out_err;\n\t}\n\n\tret = s5c73m3_init_controls(state);\n\tif (ret)\n\t\tgoto out_err;\n\n\tstate->sensor_pix_size[RES_ISP] = &s5c73m3_isp_resolutions[1];\n\tstate->sensor_pix_size[RES_JPEG] = &s5c73m3_jpeg_resolutions[1];\n\tstate->oif_pix_size[RES_ISP] = state->sensor_pix_size[RES_ISP];\n\tstate->oif_pix_size[RES_JPEG] = state->sensor_pix_size[RES_JPEG];\n\n\tstate->mbus_code = S5C73M3_ISP_FMT;\n\n\tstate->fiv = &s5c73m3_intervals[S5C73M3_DEFAULT_FRAME_INTERVAL];\n\n\tstate->fw_file_version[0] = 'G';\n\tstate->fw_file_version[1] = 'C';\n\n\tret = s5c73m3_register_spi_driver(state);\n\tif (ret < 0)\n\t\tgoto out_err;\n\n\toif_sd->dev = dev;\n\n\tret = __s5c73m3_power_on(state);\n\tif (ret < 0)\n\t\tgoto out_err1;\n\n\tret = s5c73m3_get_fw_version(state);\n\t__s5c73m3_power_off(state);\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Device detection failed: %d\\n\", ret);\n\t\tgoto out_err1;\n\t}\n\n\tret = v4l2_async_register_subdev(oif_sd);\n\tif (ret < 0)\n\t\tgoto out_err1;\n\n\tv4l2_info(sd, \"%s: completed successfully\\n\", __func__);\n\treturn 0;\n\nout_err1:\n\ts5c73m3_unregister_spi_driver(state);\nout_err:\n\tmedia_entity_cleanup(&sd->entity);\n\treturn ret;\n}\n\nstatic void s5c73m3_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *oif_sd = i2c_get_clientdata(client);\n\tstruct s5c73m3 *state = oif_sd_to_s5c73m3(oif_sd);\n\tstruct v4l2_subdev *sensor_sd = &state->sensor_sd;\n\n\tv4l2_async_unregister_subdev(oif_sd);\n\n\tv4l2_ctrl_handler_free(oif_sd->ctrl_handler);\n\tmedia_entity_cleanup(&oif_sd->entity);\n\n\tv4l2_device_unregister_subdev(sensor_sd);\n\tmedia_entity_cleanup(&sensor_sd->entity);\n\n\ts5c73m3_unregister_spi_driver(state);\n}\n\nstatic const struct i2c_device_id s5c73m3_id[] = {\n\t{ DRIVER_NAME, 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, s5c73m3_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id s5c73m3_of_match[] = {\n\t{ .compatible = \"samsung,s5c73m3\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, s5c73m3_of_match);\n#endif\n\nstatic struct i2c_driver s5c73m3_i2c_driver = {\n\t.driver = {\n\t\t.of_match_table = of_match_ptr(s5c73m3_of_match),\n\t\t.name\t= DRIVER_NAME,\n\t},\n\t.probe\t\t= s5c73m3_probe,\n\t.remove\t\t= s5c73m3_remove,\n\t.id_table\t= s5c73m3_id,\n};\n\nmodule_i2c_driver(s5c73m3_i2c_driver);\n\nMODULE_DESCRIPTION(\"Samsung S5C73M3 camera driver\");\nMODULE_AUTHOR(\"Sylwester Nawrocki <s.nawrocki@samsung.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}