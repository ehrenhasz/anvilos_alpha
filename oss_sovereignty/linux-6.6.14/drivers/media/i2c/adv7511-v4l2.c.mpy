{
  "module_name": "adv7511-v4l2.c",
  "hash_id": "e4f7433195152331ba47ea5e6a9ea684b425eda018df07a157d55b120cdbfbbf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/adv7511-v4l2.c",
  "human_readable_source": "\n \n\n \n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/videodev2.h>\n#include <linux/workqueue.h>\n#include <linux/hdmi.h>\n#include <linux/v4l2-dv-timings.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-dv-timings.h>\n#include <media/i2c/adv7511.h>\n#include <media/cec.h>\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"debug level (0-2)\");\n\nMODULE_DESCRIPTION(\"Analog Devices ADV7511 HDMI Transmitter Device Driver\");\nMODULE_AUTHOR(\"Hans Verkuil\");\nMODULE_LICENSE(\"GPL v2\");\n\n#define MASK_ADV7511_EDID_RDY_INT   0x04\n#define MASK_ADV7511_MSEN_INT       0x40\n#define MASK_ADV7511_HPD_INT        0x80\n\n#define MASK_ADV7511_HPD_DETECT     0x40\n#define MASK_ADV7511_MSEN_DETECT    0x20\n#define MASK_ADV7511_EDID_RDY       0x10\n\n#define EDID_MAX_RETRIES (8)\n#define EDID_DELAY 250\n#define EDID_MAX_SEGM 8\n\n#define ADV7511_MAX_WIDTH 1920\n#define ADV7511_MAX_HEIGHT 1200\n#define ADV7511_MIN_PIXELCLOCK 20000000\n#define ADV7511_MAX_PIXELCLOCK 225000000\n\n#define ADV7511_MAX_ADDRS (3)\n\n \n\nstruct i2c_reg_value {\n\tunsigned char reg;\n\tunsigned char value;\n};\n\nstruct adv7511_state_edid {\n\t \n\tu32 blocks;\n\t \n\tu32 segments;\n\tu8 data[EDID_MAX_SEGM * 256];\n\t \n\tunsigned read_retries;\n\tbool complete;\n};\n\nstruct adv7511_state {\n\tstruct adv7511_platform_data pdata;\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pad;\n\tstruct v4l2_ctrl_handler hdl;\n\tint chip_revision;\n\tu8 i2c_edid_addr;\n\tu8 i2c_pktmem_addr;\n\tu8 i2c_cec_addr;\n\n\tstruct i2c_client *i2c_cec;\n\tstruct cec_adapter *cec_adap;\n\tu8   cec_addr[ADV7511_MAX_ADDRS];\n\tu8   cec_valid_addrs;\n\tbool cec_enabled_adap;\n\n\t \n\tbool power_on;\n\t \n\tbool have_monitor;\n\tbool enabled_irq;\n\t \n\tstruct v4l2_dv_timings dv_timings;\n\tu32 fmt_code;\n\tu32 colorspace;\n\tu32 ycbcr_enc;\n\tu32 quantization;\n\tu32 xfer_func;\n\tu32 content_type;\n\t \n\tstruct v4l2_ctrl *hdmi_mode_ctrl;\n\tstruct v4l2_ctrl *hotplug_ctrl;\n\tstruct v4l2_ctrl *rx_sense_ctrl;\n\tstruct v4l2_ctrl *have_edid0_ctrl;\n\tstruct v4l2_ctrl *rgb_quantization_range_ctrl;\n\tstruct v4l2_ctrl *content_type_ctrl;\n\tstruct i2c_client *i2c_edid;\n\tstruct i2c_client *i2c_pktmem;\n\tstruct adv7511_state_edid edid;\n\t \n\tunsigned edid_detect_counter;\n\tstruct workqueue_struct *work_queue;\n\tstruct delayed_work edid_handler;  \n};\n\nstatic void adv7511_check_monitor_present_status(struct v4l2_subdev *sd);\nstatic bool adv7511_check_edid_status(struct v4l2_subdev *sd);\nstatic void adv7511_setup(struct v4l2_subdev *sd);\nstatic int adv7511_s_i2s_clock_freq(struct v4l2_subdev *sd, u32 freq);\nstatic int adv7511_s_clock_freq(struct v4l2_subdev *sd, u32 freq);\n\n\nstatic const struct v4l2_dv_timings_cap adv7511_timings_cap = {\n\t.type = V4L2_DV_BT_656_1120,\n\t \n\t.reserved = { 0 },\n\tV4L2_INIT_BT_TIMINGS(640, ADV7511_MAX_WIDTH, 350, ADV7511_MAX_HEIGHT,\n\t\tADV7511_MIN_PIXELCLOCK, ADV7511_MAX_PIXELCLOCK,\n\t\tV4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_DMT |\n\t\t\tV4L2_DV_BT_STD_GTF | V4L2_DV_BT_STD_CVT,\n\t\tV4L2_DV_BT_CAP_PROGRESSIVE | V4L2_DV_BT_CAP_REDUCED_BLANKING |\n\t\t\tV4L2_DV_BT_CAP_CUSTOM)\n};\n\nstatic inline struct adv7511_state *get_adv7511_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct adv7511_state, sd);\n}\n\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct adv7511_state, hdl)->sd;\n}\n\n \n\nstatic s32 adv_smbus_read_byte_data_check(struct i2c_client *client,\n\t\t\t\t\t  u8 command, bool check)\n{\n\tunion i2c_smbus_data data;\n\n\tif (!i2c_smbus_xfer(client->adapter, client->addr, client->flags,\n\t\t\t    I2C_SMBUS_READ, command,\n\t\t\t    I2C_SMBUS_BYTE_DATA, &data))\n\t\treturn data.byte;\n\tif (check)\n\t\tv4l_err(client, \"error reading %02x, %02x\\n\",\n\t\t\tclient->addr, command);\n\treturn -1;\n}\n\nstatic s32 adv_smbus_read_byte_data(struct i2c_client *client, u8 command)\n{\n\tint i;\n\tfor (i = 0; i < 3; i++) {\n\t\tint ret = adv_smbus_read_byte_data_check(client, command, true);\n\t\tif (ret >= 0) {\n\t\t\tif (i)\n\t\t\t\tv4l_err(client, \"read ok after %d retries\\n\", i);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tv4l_err(client, \"read failed\\n\");\n\treturn -1;\n}\n\nstatic int adv7511_rd(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn adv_smbus_read_byte_data(client, reg);\n}\n\nstatic int adv7511_wr(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = i2c_smbus_write_byte_data(client, reg, val);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t}\n\tv4l2_err(sd, \"%s: i2c write error\\n\", __func__);\n\treturn ret;\n}\n\n \nstatic inline void adv7511_wr_and_or(struct v4l2_subdev *sd, u8 reg, u8 clr_mask, u8 val_mask)\n{\n\tadv7511_wr(sd, reg, (adv7511_rd(sd, reg) & clr_mask) | val_mask);\n}\n\nstatic int adv7511_edid_rd(struct v4l2_subdev *sd, uint16_t len, uint8_t *buf)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\tint i;\n\n\tv4l2_dbg(1, debug, sd, \"%s:\\n\", __func__);\n\n\tfor (i = 0; i < len; i += I2C_SMBUS_BLOCK_MAX) {\n\t\ts32 ret;\n\n\t\tret = i2c_smbus_read_i2c_block_data(state->i2c_edid, i,\n\t\t\t\t\t\t    I2C_SMBUS_BLOCK_MAX, buf + i);\n\t\tif (ret < 0) {\n\t\t\tv4l2_err(sd, \"%s: i2c read error\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline int adv7511_cec_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\n\treturn i2c_smbus_read_byte_data(state->i2c_cec, reg);\n}\n\nstatic int adv7511_cec_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = i2c_smbus_write_byte_data(state->i2c_cec, reg, val);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t}\n\tv4l2_err(sd, \"%s: I2C Write Problem\\n\", __func__);\n\treturn ret;\n}\n\nstatic inline int adv7511_cec_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask,\n\t\t\t\t   u8 val)\n{\n\treturn adv7511_cec_write(sd, reg, (adv7511_cec_read(sd, reg) & mask) | val);\n}\n\nstatic int adv7511_pktmem_rd(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\n\treturn adv_smbus_read_byte_data(state->i2c_pktmem, reg);\n}\n\nstatic inline bool adv7511_have_hotplug(struct v4l2_subdev *sd)\n{\n\treturn adv7511_rd(sd, 0x42) & MASK_ADV7511_HPD_DETECT;\n}\n\nstatic inline bool adv7511_have_rx_sense(struct v4l2_subdev *sd)\n{\n\treturn adv7511_rd(sd, 0x42) & MASK_ADV7511_MSEN_DETECT;\n}\n\nstatic void adv7511_csc_conversion_mode(struct v4l2_subdev *sd, u8 mode)\n{\n\tadv7511_wr_and_or(sd, 0x18, 0x9f, (mode & 0x3)<<5);\n}\n\nstatic void adv7511_csc_coeff(struct v4l2_subdev *sd,\n\t\t\t      u16 A1, u16 A2, u16 A3, u16 A4,\n\t\t\t      u16 B1, u16 B2, u16 B3, u16 B4,\n\t\t\t      u16 C1, u16 C2, u16 C3, u16 C4)\n{\n\t \n\tadv7511_wr_and_or(sd, 0x18, 0xe0, A1>>8);\n\tadv7511_wr(sd, 0x19, A1);\n\tadv7511_wr_and_or(sd, 0x1A, 0xe0, A2>>8);\n\tadv7511_wr(sd, 0x1B, A2);\n\tadv7511_wr_and_or(sd, 0x1c, 0xe0, A3>>8);\n\tadv7511_wr(sd, 0x1d, A3);\n\tadv7511_wr_and_or(sd, 0x1e, 0xe0, A4>>8);\n\tadv7511_wr(sd, 0x1f, A4);\n\n\t \n\tadv7511_wr_and_or(sd, 0x20, 0xe0, B1>>8);\n\tadv7511_wr(sd, 0x21, B1);\n\tadv7511_wr_and_or(sd, 0x22, 0xe0, B2>>8);\n\tadv7511_wr(sd, 0x23, B2);\n\tadv7511_wr_and_or(sd, 0x24, 0xe0, B3>>8);\n\tadv7511_wr(sd, 0x25, B3);\n\tadv7511_wr_and_or(sd, 0x26, 0xe0, B4>>8);\n\tadv7511_wr(sd, 0x27, B4);\n\n\t \n\tadv7511_wr_and_or(sd, 0x28, 0xe0, C1>>8);\n\tadv7511_wr(sd, 0x29, C1);\n\tadv7511_wr_and_or(sd, 0x2A, 0xe0, C2>>8);\n\tadv7511_wr(sd, 0x2B, C2);\n\tadv7511_wr_and_or(sd, 0x2C, 0xe0, C3>>8);\n\tadv7511_wr(sd, 0x2D, C3);\n\tadv7511_wr_and_or(sd, 0x2E, 0xe0, C4>>8);\n\tadv7511_wr(sd, 0x2F, C4);\n}\n\nstatic void adv7511_csc_rgb_full2limit(struct v4l2_subdev *sd, bool enable)\n{\n\tif (enable) {\n\t\tu8 csc_mode = 0;\n\t\tadv7511_csc_conversion_mode(sd, csc_mode);\n\t\tadv7511_csc_coeff(sd,\n\t\t\t\t  4096-564, 0, 0, 256,\n\t\t\t\t  0, 4096-564, 0, 256,\n\t\t\t\t  0, 0, 4096-564, 256);\n\t\t \n\t\tadv7511_wr_and_or(sd, 0x18, 0x7f, 0x80);\n\t\t \n\t\tadv7511_wr_and_or(sd, 0x57, 0xf3, 0x04);\n\t} else {\n\t\t \n\t\tadv7511_wr_and_or(sd, 0x18, 0x7f, 0x0);\n\t\t \n\t\tadv7511_wr_and_or(sd, 0x57, 0xf3, 0x08);\n\t}\n}\n\nstatic void adv7511_set_rgb_quantization_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\n\t \n\tif (state->fmt_code != MEDIA_BUS_FMT_RGB888_1X24) {\n\t\t \n\t\tadv7511_csc_rgb_full2limit(sd, false);\n\t\treturn;\n\t}\n\n\tswitch (ctrl->val) {\n\tcase V4L2_DV_RGB_RANGE_AUTO:\n\t\t \n\t\tif (state->dv_timings.bt.flags & V4L2_DV_FL_IS_CE_VIDEO) {\n\t\t\t \n\t\t\tadv7511_csc_rgb_full2limit(sd, true);\n\t\t} else {\n\t\t\t \n\t\t\tadv7511_csc_rgb_full2limit(sd, false);\n\t\t}\n\t\tbreak;\n\tcase V4L2_DV_RGB_RANGE_LIMITED:\n\t\t \n\t\tadv7511_csc_rgb_full2limit(sd, true);\n\t\tbreak;\n\tcase V4L2_DV_RGB_RANGE_FULL:\n\t\t \n\t\tadv7511_csc_rgb_full2limit(sd, false);\n\t\tbreak;\n\t}\n}\n\n \n\nstatic int adv7511_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\n\tv4l2_dbg(1, debug, sd, \"%s: ctrl id: %d, ctrl->val %d\\n\", __func__, ctrl->id, ctrl->val);\n\n\tif (state->hdmi_mode_ctrl == ctrl) {\n\t\t \n\t\tadv7511_wr_and_or(sd, 0xaf, 0xfd, ctrl->val == V4L2_DV_TX_MODE_HDMI ? 0x02 : 0x00);\n\t\treturn 0;\n\t}\n\tif (state->rgb_quantization_range_ctrl == ctrl) {\n\t\tadv7511_set_rgb_quantization_mode(sd, ctrl);\n\t\treturn 0;\n\t}\n\tif (state->content_type_ctrl == ctrl) {\n\t\tu8 itc, cn;\n\n\t\tstate->content_type = ctrl->val;\n\t\titc = state->content_type != V4L2_DV_IT_CONTENT_TYPE_NO_ITC;\n\t\tcn = itc ? state->content_type : V4L2_DV_IT_CONTENT_TYPE_GRAPHICS;\n\t\tadv7511_wr_and_or(sd, 0x57, 0x7f, itc << 7);\n\t\tadv7511_wr_and_or(sd, 0x59, 0xcf, cn << 4);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct v4l2_ctrl_ops adv7511_ctrl_ops = {\n\t.s_ctrl = adv7511_s_ctrl,\n};\n\n \n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic void adv7511_inv_register(struct v4l2_subdev *sd)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\n\tv4l2_info(sd, \"0x000-0x0ff: Main Map\\n\");\n\tif (state->i2c_cec)\n\t\tv4l2_info(sd, \"0x100-0x1ff: CEC Map\\n\");\n}\n\nstatic int adv7511_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\n\treg->size = 1;\n\tswitch (reg->reg >> 8) {\n\tcase 0:\n\t\treg->val = adv7511_rd(sd, reg->reg & 0xff);\n\t\tbreak;\n\tcase 1:\n\t\tif (state->i2c_cec) {\n\t\t\treg->val = adv7511_cec_read(sd, reg->reg & 0xff);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tv4l2_info(sd, \"Register %03llx not supported\\n\", reg->reg);\n\t\tadv7511_inv_register(sd);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int adv7511_s_register(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\n\tswitch (reg->reg >> 8) {\n\tcase 0:\n\t\tadv7511_wr(sd, reg->reg & 0xff, reg->val & 0xff);\n\t\tbreak;\n\tcase 1:\n\t\tif (state->i2c_cec) {\n\t\t\tadv7511_cec_write(sd, reg->reg & 0xff, reg->val & 0xff);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tv4l2_info(sd, \"Register %03llx not supported\\n\", reg->reg);\n\t\tadv7511_inv_register(sd);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n#endif\n\nstruct adv7511_cfg_read_infoframe {\n\tconst char *desc;\n\tu8 present_reg;\n\tu8 present_mask;\n\tu8 header[3];\n\tu16 payload_addr;\n};\n\nstatic u8 hdmi_infoframe_checksum(u8 *ptr, size_t size)\n{\n\tu8 csum = 0;\n\tsize_t i;\n\n\t \n\tfor (i = 0; i < size; i++)\n\t\tcsum += ptr[i];\n\n\treturn 256 - csum;\n}\n\nstatic void log_infoframe(struct v4l2_subdev *sd, const struct adv7511_cfg_read_infoframe *cri)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct device *dev = &client->dev;\n\tunion hdmi_infoframe frame;\n\tu8 buffer[32];\n\tu8 len;\n\tint i;\n\n\tif (!(adv7511_rd(sd, cri->present_reg) & cri->present_mask)) {\n\t\tv4l2_info(sd, \"%s infoframe not transmitted\\n\", cri->desc);\n\t\treturn;\n\t}\n\n\tmemcpy(buffer, cri->header, sizeof(cri->header));\n\n\tlen = buffer[2];\n\n\tif (len + 4 > sizeof(buffer)) {\n\t\tv4l2_err(sd, \"%s: invalid %s infoframe length %d\\n\", __func__, cri->desc, len);\n\t\treturn;\n\t}\n\n\tif (cri->payload_addr >= 0x100) {\n\t\tfor (i = 0; i < len; i++)\n\t\t\tbuffer[i + 4] = adv7511_pktmem_rd(sd, cri->payload_addr + i - 0x100);\n\t} else {\n\t\tfor (i = 0; i < len; i++)\n\t\t\tbuffer[i + 4] = adv7511_rd(sd, cri->payload_addr + i);\n\t}\n\tbuffer[3] = 0;\n\tbuffer[3] = hdmi_infoframe_checksum(buffer, len + 4);\n\n\tif (hdmi_infoframe_unpack(&frame, buffer, len + 4) < 0) {\n\t\tv4l2_err(sd, \"%s: unpack of %s infoframe failed\\n\", __func__, cri->desc);\n\t\treturn;\n\t}\n\n\thdmi_infoframe_log(KERN_INFO, dev, &frame);\n}\n\nstatic void adv7511_log_infoframes(struct v4l2_subdev *sd)\n{\n\tstatic const struct adv7511_cfg_read_infoframe cri[] = {\n\t\t{ \"AVI\", 0x44, 0x10, { 0x82, 2, 13 }, 0x55 },\n\t\t{ \"Audio\", 0x44, 0x08, { 0x84, 1, 10 }, 0x73 },\n\t\t{ \"SDP\", 0x40, 0x40, { 0x83, 1, 25 }, 0x103 },\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cri); i++)\n\t\tlog_infoframe(sd, &cri[i]);\n}\n\nstatic int adv7511_log_status(struct v4l2_subdev *sd)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\tstruct adv7511_state_edid *edid = &state->edid;\n\tint i;\n\n\tstatic const char * const states[] = {\n\t\t\"in reset\",\n\t\t\"reading EDID\",\n\t\t\"idle\",\n\t\t\"initializing HDCP\",\n\t\t\"HDCP enabled\",\n\t\t\"initializing HDCP repeater\",\n\t\t\"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"\n\t};\n\tstatic const char * const errors[] = {\n\t\t\"no error\",\n\t\t\"bad receiver BKSV\",\n\t\t\"Ri mismatch\",\n\t\t\"Pj mismatch\",\n\t\t\"i2c error\",\n\t\t\"timed out\",\n\t\t\"max repeater cascade exceeded\",\n\t\t\"hash check failed\",\n\t\t\"too many devices\",\n\t\t\"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"\n\t};\n\n\tv4l2_info(sd, \"power %s\\n\", state->power_on ? \"on\" : \"off\");\n\tv4l2_info(sd, \"%s hotplug, %s Rx Sense, %s EDID (%d block(s))\\n\",\n\t\t  (adv7511_rd(sd, 0x42) & MASK_ADV7511_HPD_DETECT) ? \"detected\" : \"no\",\n\t\t  (adv7511_rd(sd, 0x42) & MASK_ADV7511_MSEN_DETECT) ? \"detected\" : \"no\",\n\t\t  edid->segments ? \"found\" : \"no\",\n\t\t  edid->blocks);\n\tv4l2_info(sd, \"%s output %s\\n\",\n\t\t  (adv7511_rd(sd, 0xaf) & 0x02) ?\n\t\t  \"HDMI\" : \"DVI-D\",\n\t\t  (adv7511_rd(sd, 0xa1) & 0x3c) ?\n\t\t  \"disabled\" : \"enabled\");\n\tv4l2_info(sd, \"state: %s, error: %s, detect count: %u, msk/irq: %02x/%02x\\n\",\n\t\t\t  states[adv7511_rd(sd, 0xc8) & 0xf],\n\t\t\t  errors[adv7511_rd(sd, 0xc8) >> 4], state->edid_detect_counter,\n\t\t\t  adv7511_rd(sd, 0x94), adv7511_rd(sd, 0x96));\n\tv4l2_info(sd, \"RGB quantization: %s range\\n\", adv7511_rd(sd, 0x18) & 0x80 ? \"limited\" : \"full\");\n\tif (adv7511_rd(sd, 0xaf) & 0x02) {\n\t\t \n\t\tu8 manual_cts = adv7511_rd(sd, 0x0a) & 0x80;\n\t\tu32 N = (adv7511_rd(sd, 0x01) & 0xf) << 16 |\n\t\t\tadv7511_rd(sd, 0x02) << 8 |\n\t\t\tadv7511_rd(sd, 0x03);\n\t\tu8 vic_detect = adv7511_rd(sd, 0x3e) >> 2;\n\t\tu8 vic_sent = adv7511_rd(sd, 0x3d) & 0x3f;\n\t\tu32 CTS;\n\n\t\tif (manual_cts)\n\t\t\tCTS = (adv7511_rd(sd, 0x07) & 0xf) << 16 |\n\t\t\t      adv7511_rd(sd, 0x08) << 8 |\n\t\t\t      adv7511_rd(sd, 0x09);\n\t\telse\n\t\t\tCTS = (adv7511_rd(sd, 0x04) & 0xf) << 16 |\n\t\t\t      adv7511_rd(sd, 0x05) << 8 |\n\t\t\t      adv7511_rd(sd, 0x06);\n\t\tv4l2_info(sd, \"CTS %s mode: N %d, CTS %d\\n\",\n\t\t\t  manual_cts ? \"manual\" : \"automatic\", N, CTS);\n\t\tv4l2_info(sd, \"VIC: detected %d, sent %d\\n\",\n\t\t\t  vic_detect, vic_sent);\n\t\tadv7511_log_infoframes(sd);\n\t}\n\tif (state->dv_timings.type == V4L2_DV_BT_656_1120)\n\t\tv4l2_print_dv_timings(sd->name, \"timings: \",\n\t\t\t\t&state->dv_timings, false);\n\telse\n\t\tv4l2_info(sd, \"no timings set\\n\");\n\tv4l2_info(sd, \"i2c edid addr: 0x%x\\n\", state->i2c_edid_addr);\n\n\tif (state->i2c_cec == NULL)\n\t\treturn 0;\n\n\tv4l2_info(sd, \"i2c cec addr: 0x%x\\n\", state->i2c_cec_addr);\n\n\tv4l2_info(sd, \"CEC: %s\\n\", state->cec_enabled_adap ?\n\t\t\t\"enabled\" : \"disabled\");\n\tif (state->cec_enabled_adap) {\n\t\tfor (i = 0; i < ADV7511_MAX_ADDRS; i++) {\n\t\t\tbool is_valid = state->cec_valid_addrs & (1 << i);\n\n\t\t\tif (is_valid)\n\t\t\t\tv4l2_info(sd, \"CEC Logical Address: 0x%x\\n\",\n\t\t\t\t\t  state->cec_addr[i]);\n\t\t}\n\t}\n\tv4l2_info(sd, \"i2c pktmem addr: 0x%x\\n\", state->i2c_pktmem_addr);\n\treturn 0;\n}\n\n \nstatic int adv7511_s_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\tconst int retries = 20;\n\tint i;\n\n\tv4l2_dbg(1, debug, sd, \"%s: power %s\\n\", __func__, on ? \"on\" : \"off\");\n\n\tstate->power_on = on;\n\n\tif (!on) {\n\t\t \n\t\tadv7511_wr_and_or(sd, 0x41, 0xbf, 0x40);\n\t\treturn true;\n\t}\n\n\t \n\t \n\tfor (i = 0; i < retries; i++) {\n\t\tadv7511_wr_and_or(sd, 0x41, 0xbf, 0x0);\n\t\tif ((adv7511_rd(sd, 0x41) & 0x40) == 0)\n\t\t\tbreak;\n\t\tadv7511_wr_and_or(sd, 0x41, 0xbf, 0x40);\n\t\tmsleep(10);\n\t}\n\tif (i == retries) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: failed to powerup the adv7511!\\n\", __func__);\n\t\tadv7511_s_power(sd, 0);\n\t\treturn false;\n\t}\n\tif (i > 1)\n\t\tv4l2_dbg(1, debug, sd, \"%s: needed %d retries to powerup the adv7511\\n\", __func__, i);\n\n\t \n\tadv7511_wr(sd, 0x98, 0x03);\n\tadv7511_wr_and_or(sd, 0x9a, 0xfe, 0x70);\n\tadv7511_wr(sd, 0x9c, 0x30);\n\tadv7511_wr_and_or(sd, 0x9d, 0xfc, 0x01);\n\tadv7511_wr(sd, 0xa2, 0xa4);\n\tadv7511_wr(sd, 0xa3, 0xa4);\n\tadv7511_wr(sd, 0xe0, 0xd0);\n\tadv7511_wr(sd, 0xf9, 0x00);\n\n\tadv7511_wr(sd, 0x43, state->i2c_edid_addr);\n\tadv7511_wr(sd, 0x45, state->i2c_pktmem_addr);\n\n\t \n\tadv7511_wr(sd, 0xc9, 0xf);\n\treturn true;\n}\n\n#if IS_ENABLED(CONFIG_VIDEO_ADV7511_CEC)\nstatic int adv7511_cec_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\tstruct adv7511_state *state = cec_get_drvdata(adap);\n\tstruct v4l2_subdev *sd = &state->sd;\n\n\tif (state->i2c_cec == NULL)\n\t\treturn -EIO;\n\n\tif (!state->cec_enabled_adap && enable) {\n\t\t \n\t\tadv7511_cec_write_and_or(sd, 0x4e, 0xfc, 0x01);\n\t\t \n\t\tadv7511_cec_write(sd, 0x4a, 0x00);\n\t\tadv7511_cec_write(sd, 0x4a, 0x07);\n\t\tadv7511_cec_write_and_or(sd, 0x11, 0xfe, 0);  \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\tif (state->enabled_irq)\n\t\t\tadv7511_wr_and_or(sd, 0x95, 0xc0, 0x39);\n\t} else if (state->cec_enabled_adap && !enable) {\n\t\tif (state->enabled_irq)\n\t\t\tadv7511_wr_and_or(sd, 0x95, 0xc0, 0x00);\n\t\t \n\t\tadv7511_cec_write_and_or(sd, 0x4b, 0x8f, 0x00);\n\t\t \n\t\tadv7511_cec_write_and_or(sd, 0x4e, 0xfc, 0x00);\n\t\tstate->cec_valid_addrs = 0;\n\t}\n\tstate->cec_enabled_adap = enable;\n\treturn 0;\n}\n\nstatic int adv7511_cec_adap_log_addr(struct cec_adapter *adap, u8 addr)\n{\n\tstruct adv7511_state *state = cec_get_drvdata(adap);\n\tstruct v4l2_subdev *sd = &state->sd;\n\tunsigned int i, free_idx = ADV7511_MAX_ADDRS;\n\n\tif (!state->cec_enabled_adap)\n\t\treturn addr == CEC_LOG_ADDR_INVALID ? 0 : -EIO;\n\n\tif (addr == CEC_LOG_ADDR_INVALID) {\n\t\tadv7511_cec_write_and_or(sd, 0x4b, 0x8f, 0);\n\t\tstate->cec_valid_addrs = 0;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ADV7511_MAX_ADDRS; i++) {\n\t\tbool is_valid = state->cec_valid_addrs & (1 << i);\n\n\t\tif (free_idx == ADV7511_MAX_ADDRS && !is_valid)\n\t\t\tfree_idx = i;\n\t\tif (is_valid && state->cec_addr[i] == addr)\n\t\t\treturn 0;\n\t}\n\tif (i == ADV7511_MAX_ADDRS) {\n\t\ti = free_idx;\n\t\tif (i == ADV7511_MAX_ADDRS)\n\t\t\treturn -ENXIO;\n\t}\n\tstate->cec_addr[i] = addr;\n\tstate->cec_valid_addrs |= 1 << i;\n\n\tswitch (i) {\n\tcase 0:\n\t\t \n\t\tadv7511_cec_write_and_or(sd, 0x4b, 0xef, 0x10);\n\t\t \n\t\tadv7511_cec_write_and_or(sd, 0x4c, 0xf0, addr);\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tadv7511_cec_write_and_or(sd, 0x4b, 0xdf, 0x20);\n\t\t \n\t\tadv7511_cec_write_and_or(sd, 0x4c, 0x0f, addr << 4);\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tadv7511_cec_write_and_or(sd, 0x4b, 0xbf, 0x40);\n\t\t \n\t\tadv7511_cec_write_and_or(sd, 0x4d, 0xf0, addr);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int adv7511_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\t     u32 signal_free_time, struct cec_msg *msg)\n{\n\tstruct adv7511_state *state = cec_get_drvdata(adap);\n\tstruct v4l2_subdev *sd = &state->sd;\n\tu8 len = msg->len;\n\tunsigned int i;\n\n\tv4l2_dbg(1, debug, sd, \"%s: len %d\\n\", __func__, len);\n\n\tif (len > 16) {\n\t\tv4l2_err(sd, \"%s: len exceeded 16 (%d)\\n\", __func__, len);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tadv7511_cec_write_and_or(sd, 0x12, ~0x70, max(1, attempts - 1) << 4);\n\n\t \n\tadv7511_wr(sd, 0x97, 0x38);\n\n\t \n\tfor (i = 0; i < len; i++)\n\t\tadv7511_cec_write(sd, i, msg->msg[i]);\n\n\t \n\tadv7511_cec_write(sd, 0x10, len);\n\t \n\tadv7511_cec_write(sd, 0x11, 0x01);\n\treturn 0;\n}\n\nstatic void adv_cec_tx_raw_status(struct v4l2_subdev *sd, u8 tx_raw_status)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\n\tif ((adv7511_cec_read(sd, 0x11) & 0x01) == 0) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: tx raw: tx disabled\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (tx_raw_status & 0x10) {\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t \"%s: tx raw: arbitration lost\\n\", __func__);\n\t\tcec_transmit_done(state->cec_adap, CEC_TX_STATUS_ARB_LOST,\n\t\t\t\t  1, 0, 0, 0);\n\t\treturn;\n\t}\n\tif (tx_raw_status & 0x08) {\n\t\tu8 status;\n\t\tu8 nack_cnt;\n\t\tu8 low_drive_cnt;\n\n\t\tv4l2_dbg(1, debug, sd, \"%s: tx raw: retry failed\\n\", __func__);\n\t\t \n\t\tstatus = CEC_TX_STATUS_MAX_RETRIES;\n\t\tnack_cnt = adv7511_cec_read(sd, 0x14) & 0xf;\n\t\tif (nack_cnt)\n\t\t\tstatus |= CEC_TX_STATUS_NACK;\n\t\tlow_drive_cnt = adv7511_cec_read(sd, 0x14) >> 4;\n\t\tif (low_drive_cnt)\n\t\t\tstatus |= CEC_TX_STATUS_LOW_DRIVE;\n\t\tcec_transmit_done(state->cec_adap, status,\n\t\t\t\t  0, nack_cnt, low_drive_cnt, 0);\n\t\treturn;\n\t}\n\tif (tx_raw_status & 0x20) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: tx raw: ready ok\\n\", __func__);\n\t\tcec_transmit_done(state->cec_adap, CEC_TX_STATUS_OK, 0, 0, 0, 0);\n\t\treturn;\n\t}\n}\n\nstatic const struct cec_adap_ops adv7511_cec_adap_ops = {\n\t.adap_enable = adv7511_cec_adap_enable,\n\t.adap_log_addr = adv7511_cec_adap_log_addr,\n\t.adap_transmit = adv7511_cec_adap_transmit,\n};\n#endif\n\n \nstatic void adv7511_set_isr(struct v4l2_subdev *sd, bool enable)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\tu8 irqs = MASK_ADV7511_HPD_INT | MASK_ADV7511_MSEN_INT;\n\tu8 irqs_rd;\n\tint retries = 100;\n\n\tv4l2_dbg(2, debug, sd, \"%s: %s\\n\", __func__, enable ? \"enable\" : \"disable\");\n\n\tif (state->enabled_irq == enable)\n\t\treturn;\n\tstate->enabled_irq = enable;\n\n\t \n\tif (!enable)\n\t\tirqs = 0;\n\telse if (adv7511_have_hotplug(sd))\n\t\tirqs |= MASK_ADV7511_EDID_RDY_INT;\n\n\t \n\tdo {\n\t\tadv7511_wr(sd, 0x94, irqs);\n\t\tirqs_rd = adv7511_rd(sd, 0x94);\n\t} while (retries-- && irqs_rd != irqs);\n\n\tif (irqs_rd != irqs)\n\t\tv4l2_err(sd, \"Could not set interrupts: hw failure?\\n\");\n\n\tadv7511_wr_and_or(sd, 0x95, 0xc0,\n\t\t\t  (state->cec_enabled_adap && enable) ? 0x39 : 0x00);\n}\n\n \nstatic int adv7511_isr(struct v4l2_subdev *sd, u32 status, bool *handled)\n{\n\tu8 irq_status;\n\tu8 cec_irq;\n\n\t \n\tadv7511_set_isr(sd, false);\n\tirq_status = adv7511_rd(sd, 0x96);\n\tcec_irq = adv7511_rd(sd, 0x97);\n\t \n\tadv7511_wr(sd, 0x96, irq_status);\n\tadv7511_wr(sd, 0x97, cec_irq);\n\n\tv4l2_dbg(1, debug, sd, \"%s: irq 0x%x, cec-irq 0x%x\\n\", __func__,\n\t\t irq_status, cec_irq);\n\n\tif (irq_status & (MASK_ADV7511_HPD_INT | MASK_ADV7511_MSEN_INT))\n\t\tadv7511_check_monitor_present_status(sd);\n\tif (irq_status & MASK_ADV7511_EDID_RDY_INT)\n\t\tadv7511_check_edid_status(sd);\n\n#if IS_ENABLED(CONFIG_VIDEO_ADV7511_CEC)\n\tif (cec_irq & 0x38)\n\t\tadv_cec_tx_raw_status(sd, cec_irq);\n\n\tif (cec_irq & 1) {\n\t\tstruct adv7511_state *state = get_adv7511_state(sd);\n\t\tstruct cec_msg msg;\n\n\t\tmsg.len = adv7511_cec_read(sd, 0x25) & 0x1f;\n\n\t\tv4l2_dbg(1, debug, sd, \"%s: cec msg len %d\\n\", __func__,\n\t\t\t msg.len);\n\n\t\tif (msg.len > CEC_MAX_MSG_SIZE)\n\t\t\tmsg.len = CEC_MAX_MSG_SIZE;\n\n\t\tif (msg.len) {\n\t\t\tu8 i;\n\n\t\t\tfor (i = 0; i < msg.len; i++)\n\t\t\t\tmsg.msg[i] = adv7511_cec_read(sd, i + 0x15);\n\n\t\t\tadv7511_cec_write(sd, 0x4a, 0);  \n\t\t\tadv7511_cec_write(sd, 0x4a, 1);\n\t\t\tcec_received_msg(state->cec_adap, &msg);\n\t\t}\n\t}\n#endif\n\n\t \n\tadv7511_set_isr(sd, true);\n\n\tif (handled)\n\t\t*handled = true;\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops adv7511_core_ops = {\n\t.log_status = adv7511_log_status,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = adv7511_g_register,\n\t.s_register = adv7511_s_register,\n#endif\n\t.s_power = adv7511_s_power,\n\t.interrupt_service_routine = adv7511_isr,\n};\n\n \n\n \nstatic int adv7511_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\n\tv4l2_dbg(1, debug, sd, \"%s: %sable\\n\", __func__, (enable ? \"en\" : \"dis\"));\n\tadv7511_wr_and_or(sd, 0xa1, ~0x3c, (enable ? 0 : 0x3c));\n\tif (enable) {\n\t\tadv7511_check_monitor_present_status(sd);\n\t} else {\n\t\tadv7511_s_power(sd, 0);\n\t\tstate->have_monitor = false;\n\t}\n\treturn 0;\n}\n\nstatic int adv7511_s_dv_timings(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_dv_timings *timings)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\tstruct v4l2_bt_timings *bt = &timings->bt;\n\tu32 fps;\n\n\tv4l2_dbg(1, debug, sd, \"%s:\\n\", __func__);\n\n\t \n\tif (!v4l2_valid_dv_timings(timings, &adv7511_timings_cap, NULL, NULL))\n\t\treturn -EINVAL;\n\n\t \n\tv4l2_find_dv_timings_cap(timings, &adv7511_timings_cap, 0, NULL, NULL);\n\n\t \n\tstate->dv_timings = *timings;\n\n\t \n\tadv7511_wr_and_or(sd, 0x17, 0x9f,\n\t\t((bt->polarities & V4L2_DV_VSYNC_POS_POL) ? 0 : 0x40) |\n\t\t((bt->polarities & V4L2_DV_HSYNC_POS_POL) ? 0 : 0x20));\n\n\tfps = (u32)bt->pixelclock / (V4L2_DV_BT_FRAME_WIDTH(bt) * V4L2_DV_BT_FRAME_HEIGHT(bt));\n\tswitch (fps) {\n\tcase 24:\n\t\tadv7511_wr_and_or(sd, 0xfb, 0xf9, 1 << 1);\n\t\tbreak;\n\tcase 25:\n\t\tadv7511_wr_and_or(sd, 0xfb, 0xf9, 2 << 1);\n\t\tbreak;\n\tcase 30:\n\t\tadv7511_wr_and_or(sd, 0xfb, 0xf9, 3 << 1);\n\t\tbreak;\n\tdefault:\n\t\tadv7511_wr_and_or(sd, 0xfb, 0xf9, 0);\n\t\tbreak;\n\t}\n\n\t \n\tadv7511_set_rgb_quantization_mode(sd, state->rgb_quantization_range_ctrl);\n\n\treturn 0;\n}\n\nstatic int adv7511_g_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_dv_timings *timings)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\n\tv4l2_dbg(1, debug, sd, \"%s:\\n\", __func__);\n\n\tif (!timings)\n\t\treturn -EINVAL;\n\n\t*timings = state->dv_timings;\n\n\treturn 0;\n}\n\nstatic int adv7511_enum_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_enum_dv_timings *timings)\n{\n\tif (timings->pad != 0)\n\t\treturn -EINVAL;\n\n\treturn v4l2_enum_dv_timings_cap(timings, &adv7511_timings_cap, NULL, NULL);\n}\n\nstatic int adv7511_dv_timings_cap(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_dv_timings_cap *cap)\n{\n\tif (cap->pad != 0)\n\t\treturn -EINVAL;\n\n\t*cap = adv7511_timings_cap;\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops adv7511_video_ops = {\n\t.s_stream = adv7511_s_stream,\n\t.s_dv_timings = adv7511_s_dv_timings,\n\t.g_dv_timings = adv7511_g_dv_timings,\n};\n\n \nstatic int adv7511_s_audio_stream(struct v4l2_subdev *sd, int enable)\n{\n\tv4l2_dbg(1, debug, sd, \"%s: %sable\\n\", __func__, (enable ? \"en\" : \"dis\"));\n\n\tif (enable)\n\t\tadv7511_wr_and_or(sd, 0x4b, 0x3f, 0x80);\n\telse\n\t\tadv7511_wr_and_or(sd, 0x4b, 0x3f, 0x40);\n\n\treturn 0;\n}\n\nstatic int adv7511_s_clock_freq(struct v4l2_subdev *sd, u32 freq)\n{\n\tu32 N;\n\n\tswitch (freq) {\n\tcase 32000:  N = 4096;  break;\n\tcase 44100:  N = 6272;  break;\n\tcase 48000:  N = 6144;  break;\n\tcase 88200:  N = 12544; break;\n\tcase 96000:  N = 12288; break;\n\tcase 176400: N = 25088; break;\n\tcase 192000: N = 24576; break;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tadv7511_wr(sd, 0x01, (N >> 16) & 0xf);\n\tadv7511_wr(sd, 0x02, (N >> 8) & 0xff);\n\tadv7511_wr(sd, 0x03, N & 0xff);\n\n\treturn 0;\n}\n\nstatic int adv7511_s_i2s_clock_freq(struct v4l2_subdev *sd, u32 freq)\n{\n\tu32 i2s_sf;\n\n\tswitch (freq) {\n\tcase 32000:  i2s_sf = 0x30; break;\n\tcase 44100:  i2s_sf = 0x00; break;\n\tcase 48000:  i2s_sf = 0x20; break;\n\tcase 88200:  i2s_sf = 0x80; break;\n\tcase 96000:  i2s_sf = 0xa0; break;\n\tcase 176400: i2s_sf = 0xc0; break;\n\tcase 192000: i2s_sf = 0xe0; break;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tadv7511_wr_and_or(sd, 0x15, 0xf, i2s_sf);\n\n\treturn 0;\n}\n\nstatic int adv7511_s_routing(struct v4l2_subdev *sd, u32 input, u32 output, u32 config)\n{\n\t \n\tadv7511_wr_and_or(sd, 0x73, 0xf8, 0x1);\n\t \n\tadv7511_wr(sd, 0x76, 0x00);\n\n\t \n\tadv7511_wr_and_or(sd, 0x14, 0xf0, 0x02);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_audio_ops adv7511_audio_ops = {\n\t.s_stream = adv7511_s_audio_stream,\n\t.s_clock_freq = adv7511_s_clock_freq,\n\t.s_i2s_clock_freq = adv7511_s_i2s_clock_freq,\n\t.s_routing = adv7511_s_routing,\n};\n\n \n\nstatic int adv7511_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\n\tmemset(edid->reserved, 0, sizeof(edid->reserved));\n\n\tif (edid->pad != 0)\n\t\treturn -EINVAL;\n\n\tif (edid->start_block == 0 && edid->blocks == 0) {\n\t\tedid->blocks = state->edid.blocks;\n\t\treturn 0;\n\t}\n\n\tif (state->edid.blocks == 0)\n\t\treturn -ENODATA;\n\n\tif (edid->start_block >= state->edid.blocks)\n\t\treturn -EINVAL;\n\n\tif (edid->start_block + edid->blocks > state->edid.blocks)\n\t\tedid->blocks = state->edid.blocks - edid->start_block;\n\n\tmemcpy(edid->edid, &state->edid.data[edid->start_block * 128],\n\t       128 * edid->blocks);\n\n\treturn 0;\n}\n\nstatic int adv7511_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad != 0)\n\t\treturn -EINVAL;\n\n\tswitch (code->index) {\n\tcase 0:\n\t\tcode->code = MEDIA_BUS_FMT_RGB888_1X24;\n\t\tbreak;\n\tcase 1:\n\t\tcode->code = MEDIA_BUS_FMT_YUYV8_1X16;\n\t\tbreak;\n\tcase 2:\n\t\tcode->code = MEDIA_BUS_FMT_UYVY8_1X16;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void adv7511_fill_format(struct adv7511_state *state,\n\t\t\t\tstruct v4l2_mbus_framefmt *format)\n{\n\tformat->width = state->dv_timings.bt.width;\n\tformat->height = state->dv_timings.bt.height;\n\tformat->field = V4L2_FIELD_NONE;\n}\n\nstatic int adv7511_get_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *format)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\n\tif (format->pad != 0)\n\t\treturn -EINVAL;\n\n\tmemset(&format->format, 0, sizeof(format->format));\n\tadv7511_fill_format(state, &format->format);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tstruct v4l2_mbus_framefmt *fmt;\n\n\t\tfmt = v4l2_subdev_get_try_format(sd, sd_state, format->pad);\n\t\tformat->format.code = fmt->code;\n\t\tformat->format.colorspace = fmt->colorspace;\n\t\tformat->format.ycbcr_enc = fmt->ycbcr_enc;\n\t\tformat->format.quantization = fmt->quantization;\n\t\tformat->format.xfer_func = fmt->xfer_func;\n\t} else {\n\t\tformat->format.code = state->fmt_code;\n\t\tformat->format.colorspace = state->colorspace;\n\t\tformat->format.ycbcr_enc = state->ycbcr_enc;\n\t\tformat->format.quantization = state->quantization;\n\t\tformat->format.xfer_func = state->xfer_func;\n\t}\n\n\treturn 0;\n}\n\nstatic int adv7511_set_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *format)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\t \n\tu8 c = HDMI_COLORIMETRY_NONE;\n\tu8 ec = HDMI_EXTENDED_COLORIMETRY_XV_YCC_601;\n\tu8 y = HDMI_COLORSPACE_RGB;\n\tu8 q = HDMI_QUANTIZATION_RANGE_DEFAULT;\n\tu8 yq = HDMI_YCC_QUANTIZATION_RANGE_LIMITED;\n\tu8 itc = state->content_type != V4L2_DV_IT_CONTENT_TYPE_NO_ITC;\n\tu8 cn = itc ? state->content_type : V4L2_DV_IT_CONTENT_TYPE_GRAPHICS;\n\n\tif (format->pad != 0)\n\t\treturn -EINVAL;\n\tswitch (format->format.code) {\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\tcase MEDIA_BUS_FMT_YUYV8_1X16:\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tadv7511_fill_format(state, &format->format);\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tstruct v4l2_mbus_framefmt *fmt;\n\n\t\tfmt = v4l2_subdev_get_try_format(sd, sd_state, format->pad);\n\t\tfmt->code = format->format.code;\n\t\tfmt->colorspace = format->format.colorspace;\n\t\tfmt->ycbcr_enc = format->format.ycbcr_enc;\n\t\tfmt->quantization = format->format.quantization;\n\t\tfmt->xfer_func = format->format.xfer_func;\n\t\treturn 0;\n\t}\n\n\tswitch (format->format.code) {\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\t\tadv7511_wr_and_or(sd, 0x15, 0xf0, 0x01);\n\t\tadv7511_wr_and_or(sd, 0x16, 0x03, 0xb8);\n\t\ty = HDMI_COLORSPACE_YUV422;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YUYV8_1X16:\n\t\tadv7511_wr_and_or(sd, 0x15, 0xf0, 0x01);\n\t\tadv7511_wr_and_or(sd, 0x16, 0x03, 0xbc);\n\t\ty = HDMI_COLORSPACE_YUV422;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\tdefault:\n\t\tadv7511_wr_and_or(sd, 0x15, 0xf0, 0x00);\n\t\tadv7511_wr_and_or(sd, 0x16, 0x03, 0x00);\n\t\tbreak;\n\t}\n\tstate->fmt_code = format->format.code;\n\tstate->colorspace = format->format.colorspace;\n\tstate->ycbcr_enc = format->format.ycbcr_enc;\n\tstate->quantization = format->format.quantization;\n\tstate->xfer_func = format->format.xfer_func;\n\n\tswitch (format->format.colorspace) {\n\tcase V4L2_COLORSPACE_OPRGB:\n\t\tc = HDMI_COLORIMETRY_EXTENDED;\n\t\tec = y ? HDMI_EXTENDED_COLORIMETRY_OPYCC_601 :\n\t\t\t HDMI_EXTENDED_COLORIMETRY_OPRGB;\n\t\tbreak;\n\tcase V4L2_COLORSPACE_SMPTE170M:\n\t\tc = y ? HDMI_COLORIMETRY_ITU_601 : HDMI_COLORIMETRY_NONE;\n\t\tif (y && format->format.ycbcr_enc == V4L2_YCBCR_ENC_XV601) {\n\t\t\tc = HDMI_COLORIMETRY_EXTENDED;\n\t\t\tec = HDMI_EXTENDED_COLORIMETRY_XV_YCC_601;\n\t\t}\n\t\tbreak;\n\tcase V4L2_COLORSPACE_REC709:\n\t\tc = y ? HDMI_COLORIMETRY_ITU_709 : HDMI_COLORIMETRY_NONE;\n\t\tif (y && format->format.ycbcr_enc == V4L2_YCBCR_ENC_XV709) {\n\t\t\tc = HDMI_COLORIMETRY_EXTENDED;\n\t\t\tec = HDMI_EXTENDED_COLORIMETRY_XV_YCC_709;\n\t\t}\n\t\tbreak;\n\tcase V4L2_COLORSPACE_SRGB:\n\t\tc = y ? HDMI_COLORIMETRY_EXTENDED : HDMI_COLORIMETRY_NONE;\n\t\tec = y ? HDMI_EXTENDED_COLORIMETRY_S_YCC_601 :\n\t\t\t HDMI_EXTENDED_COLORIMETRY_XV_YCC_601;\n\t\tbreak;\n\tcase V4L2_COLORSPACE_BT2020:\n\t\tc = HDMI_COLORIMETRY_EXTENDED;\n\t\tif (y && format->format.ycbcr_enc == V4L2_YCBCR_ENC_BT2020_CONST_LUM)\n\t\t\tec = 5;  \n\t\telse\n\t\t\tec = 6;  \n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tswitch (format->format.quantization) {\n\tcase V4L2_QUANTIZATION_FULL_RANGE:\n\t\tq = y ? HDMI_QUANTIZATION_RANGE_DEFAULT :\n\t\t\tHDMI_QUANTIZATION_RANGE_FULL;\n\t\tyq = q ? q - 1 : HDMI_YCC_QUANTIZATION_RANGE_FULL;\n\t\tbreak;\n\tcase V4L2_QUANTIZATION_LIM_RANGE:\n\t\tq = y ? HDMI_QUANTIZATION_RANGE_DEFAULT :\n\t\t\tHDMI_QUANTIZATION_RANGE_LIMITED;\n\t\tyq = q ? q - 1 : HDMI_YCC_QUANTIZATION_RANGE_LIMITED;\n\t\tbreak;\n\t}\n\n\tadv7511_wr_and_or(sd, 0x4a, 0xbf, 0);\n\tadv7511_wr_and_or(sd, 0x55, 0x9f, y << 5);\n\tadv7511_wr_and_or(sd, 0x56, 0x3f, c << 6);\n\tadv7511_wr_and_or(sd, 0x57, 0x83, (ec << 4) | (q << 2) | (itc << 7));\n\tadv7511_wr_and_or(sd, 0x59, 0x0f, (yq << 6) | (cn << 4));\n\tadv7511_wr_and_or(sd, 0x4a, 0xff, 1);\n\tadv7511_set_rgb_quantization_mode(sd, state->rgb_quantization_range_ctrl);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops adv7511_pad_ops = {\n\t.get_edid = adv7511_get_edid,\n\t.enum_mbus_code = adv7511_enum_mbus_code,\n\t.get_fmt = adv7511_get_fmt,\n\t.set_fmt = adv7511_set_fmt,\n\t.enum_dv_timings = adv7511_enum_dv_timings,\n\t.dv_timings_cap = adv7511_dv_timings_cap,\n};\n\n \n\nstatic const struct v4l2_subdev_ops adv7511_ops = {\n\t.core  = &adv7511_core_ops,\n\t.pad  = &adv7511_pad_ops,\n\t.video = &adv7511_video_ops,\n\t.audio = &adv7511_audio_ops,\n};\n\n \nstatic void adv7511_dbg_dump_edid(int lvl, int debug, struct v4l2_subdev *sd, int segment, u8 *buf)\n{\n\tif (debug >= lvl) {\n\t\tint i, j;\n\t\tv4l2_dbg(lvl, debug, sd, \"edid segment %d\\n\", segment);\n\t\tfor (i = 0; i < 256; i += 16) {\n\t\t\tu8 b[128];\n\t\t\tu8 *bp = b;\n\t\t\tif (i == 128)\n\t\t\t\tv4l2_dbg(lvl, debug, sd, \"\\n\");\n\t\t\tfor (j = i; j < i + 16; j++) {\n\t\t\t\tsprintf(bp, \"0x%02x, \", buf[j]);\n\t\t\t\tbp += 6;\n\t\t\t}\n\t\t\tbp[0] = '\\0';\n\t\t\tv4l2_dbg(lvl, debug, sd, \"%s\\n\", b);\n\t\t}\n\t}\n}\n\nstatic void adv7511_notify_no_edid(struct v4l2_subdev *sd)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\tstruct adv7511_edid_detect ed;\n\n\t \n\ted.present = false;\n\ted.segment = adv7511_rd(sd, 0xc4);\n\ted.phys_addr = CEC_PHYS_ADDR_INVALID;\n\tcec_s_phys_addr(state->cec_adap, ed.phys_addr, false);\n\tv4l2_subdev_notify(sd, ADV7511_EDID_DETECT, (void *)&ed);\n\tv4l2_ctrl_s_ctrl(state->have_edid0_ctrl, 0x0);\n}\n\nstatic void adv7511_edid_handler(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct adv7511_state *state = container_of(dwork, struct adv7511_state, edid_handler);\n\tstruct v4l2_subdev *sd = &state->sd;\n\n\tv4l2_dbg(1, debug, sd, \"%s:\\n\", __func__);\n\n\tif (adv7511_check_edid_status(sd)) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (adv7511_have_hotplug(sd)) {\n\t\t \n\t\tif (state->edid.read_retries) {\n\t\t\tstate->edid.read_retries--;\n\t\t\tv4l2_dbg(1, debug, sd, \"%s: edid read failed\\n\", __func__);\n\t\t\tstate->have_monitor = false;\n\t\t\tadv7511_s_power(sd, false);\n\t\t\tadv7511_s_power(sd, true);\n\t\t\tqueue_delayed_work(state->work_queue, &state->edid_handler, EDID_DELAY);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tadv7511_notify_no_edid(sd);\n\tv4l2_dbg(1, debug, sd, \"%s: no edid found\\n\", __func__);\n}\n\nstatic void adv7511_audio_setup(struct v4l2_subdev *sd)\n{\n\tv4l2_dbg(1, debug, sd, \"%s\\n\", __func__);\n\n\tadv7511_s_i2s_clock_freq(sd, 48000);\n\tadv7511_s_clock_freq(sd, 48000);\n\tadv7511_s_routing(sd, 0, 0, 0);\n}\n\n \nstatic void adv7511_setup(struct v4l2_subdev *sd)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\tv4l2_dbg(1, debug, sd, \"%s\\n\", __func__);\n\n\t \n\tadv7511_wr_and_or(sd, 0x15, 0xf0, 0x0);\n\t \n\tadv7511_wr_and_or(sd, 0x16, 0x7f, 0x0);\n\t \n\tadv7511_wr_and_or(sd, 0x17, 0xf9, 0x06);\n\t \n\tadv7511_wr_and_or(sd, 0x3b, 0x9f, 0x0);\n\t \n\tadv7511_wr_and_or(sd, 0x18, 0x7f, 0x0);\n\t \n\tadv7511_wr_and_or(sd, 0x55, 0x9c, 0x12);\n\t \n\tadv7511_wr_and_or(sd, 0x44, 0xe7, 0x10);\n\t \n\tadv7511_wr(sd, 0x56, 0xa8);\n\t \n\tadv7511_wr_and_or(sd, 0xaf, 0xed, 0x0);\n\n\t \n\tadv7511_wr_and_or(sd, 0xba, 0x1f, 0x60);\n\n\tadv7511_audio_setup(sd);\n\n\tv4l2_ctrl_handler_setup(&state->hdl);\n}\n\nstatic void adv7511_notify_monitor_detect(struct v4l2_subdev *sd)\n{\n\tstruct adv7511_monitor_detect mdt;\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\n\tmdt.present = state->have_monitor;\n\tv4l2_subdev_notify(sd, ADV7511_MONITOR_DETECT, (void *)&mdt);\n}\n\nstatic void adv7511_check_monitor_present_status(struct v4l2_subdev *sd)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\t \n\tu8 status = adv7511_rd(sd, 0x42);\n\n\tv4l2_dbg(1, debug, sd, \"%s: status: 0x%x%s%s\\n\",\n\t\t\t __func__,\n\t\t\t status,\n\t\t\t status & MASK_ADV7511_HPD_DETECT ? \", hotplug\" : \"\",\n\t\t\t status & MASK_ADV7511_MSEN_DETECT ? \", rx-sense\" : \"\");\n\n\t \n\tv4l2_ctrl_s_ctrl(state->hotplug_ctrl, adv7511_have_hotplug(sd) ? 0x1 : 0x0);\n\tv4l2_ctrl_s_ctrl(state->rx_sense_ctrl, adv7511_have_rx_sense(sd) ? 0x1 : 0x0);\n\n\tif ((status & MASK_ADV7511_HPD_DETECT) && ((status & MASK_ADV7511_MSEN_DETECT) || state->edid.segments)) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: hotplug and (rx-sense or edid)\\n\", __func__);\n\t\tif (!state->have_monitor) {\n\t\t\tv4l2_dbg(1, debug, sd, \"%s: monitor detected\\n\", __func__);\n\t\t\tstate->have_monitor = true;\n\t\t\tadv7511_set_isr(sd, true);\n\t\t\tif (!adv7511_s_power(sd, true)) {\n\t\t\t\tv4l2_dbg(1, debug, sd, \"%s: monitor detected, powerup failed\\n\", __func__);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tadv7511_setup(sd);\n\t\t\tadv7511_notify_monitor_detect(sd);\n\t\t\tstate->edid.read_retries = EDID_MAX_RETRIES;\n\t\t\tqueue_delayed_work(state->work_queue, &state->edid_handler, EDID_DELAY);\n\t\t}\n\t} else if (status & MASK_ADV7511_HPD_DETECT) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: hotplug detected\\n\", __func__);\n\t\tstate->edid.read_retries = EDID_MAX_RETRIES;\n\t\tqueue_delayed_work(state->work_queue, &state->edid_handler, EDID_DELAY);\n\t} else if (!(status & MASK_ADV7511_HPD_DETECT)) {\n\t\tv4l2_dbg(1, debug, sd, \"%s: hotplug not detected\\n\", __func__);\n\t\tif (state->have_monitor) {\n\t\t\tv4l2_dbg(1, debug, sd, \"%s: monitor not detected\\n\", __func__);\n\t\t\tstate->have_monitor = false;\n\t\t\tadv7511_notify_monitor_detect(sd);\n\t\t}\n\t\tadv7511_s_power(sd, false);\n\t\tmemset(&state->edid, 0, sizeof(struct adv7511_state_edid));\n\t\tadv7511_notify_no_edid(sd);\n\t}\n}\n\nstatic bool edid_block_verify_crc(u8 *edid_block)\n{\n\tu8 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < 128; i++)\n\t\tsum += edid_block[i];\n\treturn sum == 0;\n}\n\nstatic bool edid_verify_crc(struct v4l2_subdev *sd, u32 segment)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\tu32 blocks = state->edid.blocks;\n\tu8 *data = state->edid.data;\n\n\tif (!edid_block_verify_crc(&data[segment * 256]))\n\t\treturn false;\n\tif ((segment + 1) * 2 <= blocks)\n\t\treturn edid_block_verify_crc(&data[segment * 256 + 128]);\n\treturn true;\n}\n\nstatic bool edid_verify_header(struct v4l2_subdev *sd, u32 segment)\n{\n\tstatic const u8 hdmi_header[] = {\n\t\t0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00\n\t};\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\tu8 *data = state->edid.data;\n\n\tif (segment != 0)\n\t\treturn true;\n\treturn !memcmp(data, hdmi_header, sizeof(hdmi_header));\n}\n\nstatic bool adv7511_check_edid_status(struct v4l2_subdev *sd)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\tu8 edidRdy = adv7511_rd(sd, 0xc5);\n\n\tv4l2_dbg(1, debug, sd, \"%s: edid ready (retries: %d)\\n\",\n\t\t\t __func__, EDID_MAX_RETRIES - state->edid.read_retries);\n\n\tif (state->edid.complete)\n\t\treturn true;\n\n\tif (edidRdy & MASK_ADV7511_EDID_RDY) {\n\t\tint segment = adv7511_rd(sd, 0xc4);\n\t\tstruct adv7511_edid_detect ed;\n\t\tint err;\n\n\t\tif (segment >= EDID_MAX_SEGM) {\n\t\t\tv4l2_err(sd, \"edid segment number too big\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tv4l2_dbg(1, debug, sd, \"%s: got segment %d\\n\", __func__, segment);\n\t\terr = adv7511_edid_rd(sd, 256, &state->edid.data[segment * 256]);\n\t\tif (!err) {\n\t\t\tadv7511_dbg_dump_edid(2, debug, sd, segment, &state->edid.data[segment * 256]);\n\t\t\tif (segment == 0) {\n\t\t\t\tstate->edid.blocks = state->edid.data[0x7e] + 1;\n\t\t\t\tv4l2_dbg(1, debug, sd, \"%s: %d blocks in total\\n\",\n\t\t\t\t\t __func__, state->edid.blocks);\n\t\t\t}\n\t\t}\n\n\t\tif (err || !edid_verify_crc(sd, segment) || !edid_verify_header(sd, segment)) {\n\t\t\t \n\t\t\tif (!err)\n\t\t\t\tv4l2_err(sd, \"%s: edid crc or header error\\n\", __func__);\n\t\t\tstate->have_monitor = false;\n\t\t\tadv7511_s_power(sd, false);\n\t\t\tadv7511_s_power(sd, true);\n\t\t\treturn false;\n\t\t}\n\t\t \n\t\tstate->edid.segments = segment + 1;\n\t\tv4l2_ctrl_s_ctrl(state->have_edid0_ctrl, 0x1);\n\t\tif (((state->edid.data[0x7e] >> 1) + 1) > state->edid.segments) {\n\t\t\t \n\t\t\tv4l2_dbg(1, debug, sd, \"%s: request segment %d\\n\", __func__, state->edid.segments);\n\t\t\tadv7511_wr(sd, 0xc9, 0xf);\n\t\t\tadv7511_wr(sd, 0xc4, state->edid.segments);\n\t\t\tstate->edid.read_retries = EDID_MAX_RETRIES;\n\t\t\tqueue_delayed_work(state->work_queue, &state->edid_handler, EDID_DELAY);\n\t\t\treturn false;\n\t\t}\n\n\t\tv4l2_dbg(1, debug, sd, \"%s: edid complete with %d segment(s)\\n\", __func__, state->edid.segments);\n\t\tstate->edid.complete = true;\n\t\ted.phys_addr = cec_get_edid_phys_addr(state->edid.data,\n\t\t\t\t\t\t      state->edid.segments * 256,\n\t\t\t\t\t\t      NULL);\n\t\t \n\t\ted.present = true;\n\t\ted.segment = 0;\n\t\tstate->edid_detect_counter++;\n\t\tcec_s_phys_addr(state->cec_adap, ed.phys_addr, false);\n\t\tv4l2_subdev_notify(sd, ADV7511_EDID_DETECT, (void *)&ed);\n\t\treturn ed.present;\n\t}\n\n\treturn false;\n}\n\nstatic int adv7511_registered(struct v4l2_subdev *sd)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint err;\n\n\terr = cec_register_adapter(state->cec_adap, &client->dev);\n\tif (err)\n\t\tcec_delete_adapter(state->cec_adap);\n\treturn err;\n}\n\nstatic void adv7511_unregistered(struct v4l2_subdev *sd)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\n\tcec_unregister_adapter(state->cec_adap);\n}\n\nstatic const struct v4l2_subdev_internal_ops adv7511_int_ops = {\n\t.registered = adv7511_registered,\n\t.unregistered = adv7511_unregistered,\n};\n\n \n \nstatic void adv7511_init_setup(struct v4l2_subdev *sd)\n{\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\tstruct adv7511_state_edid *edid = &state->edid;\n\tu32 cec_clk = state->pdata.cec_clk;\n\tu8 ratio;\n\n\tv4l2_dbg(1, debug, sd, \"%s\\n\", __func__);\n\n\t \n\tadv7511_wr(sd, 0x96, 0xff);\n\tadv7511_wr(sd, 0x97, 0xff);\n\t \n\tadv7511_wr_and_or(sd, 0xd6, 0x3f, 0xc0);\n\tmemset(edid, 0, sizeof(struct adv7511_state_edid));\n\tstate->have_monitor = false;\n\tadv7511_set_isr(sd, false);\n\tadv7511_s_stream(sd, false);\n\tadv7511_s_audio_stream(sd, false);\n\n\tif (state->i2c_cec == NULL)\n\t\treturn;\n\n\tv4l2_dbg(1, debug, sd, \"%s: cec_clk %d\\n\", __func__, cec_clk);\n\n\t \n\tadv7511_cec_write(sd, 0x50, 0x01);\n\tadv7511_cec_write(sd, 0x50, 0x00);\n\n\t \n\tadv7511_cec_write(sd, 0x4a, 0x00);\n\tadv7511_cec_write(sd, 0x4a, 0x07);\n\n\tif (cec_clk % 750000 != 0)\n\t\tv4l2_err(sd, \"%s: cec_clk %d, not multiple of 750 Khz\\n\",\n\t\t\t __func__, cec_clk);\n\n\tratio = (cec_clk / 750000) - 1;\n\tadv7511_cec_write(sd, 0x4e, ratio << 2);\n}\n\nstatic int adv7511_probe(struct i2c_client *client)\n{\n\tstruct adv7511_state *state;\n\tstruct adv7511_platform_data *pdata = client->dev.platform_data;\n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct v4l2_subdev *sd;\n\tu8 chip_id[2];\n\tint err = -EIO;\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tstate = devm_kzalloc(&client->dev, sizeof(struct adv7511_state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!pdata) {\n\t\tv4l_err(client, \"No platform data!\\n\");\n\t\treturn -ENODEV;\n\t}\n\tmemcpy(&state->pdata, pdata, sizeof(state->pdata));\n\tstate->fmt_code = MEDIA_BUS_FMT_RGB888_1X24;\n\tstate->colorspace = V4L2_COLORSPACE_SRGB;\n\n\tsd = &state->sd;\n\n\tv4l2_dbg(1, debug, sd, \"detecting adv7511 client on address 0x%x\\n\",\n\t\t\t client->addr << 1);\n\n\tv4l2_i2c_subdev_init(sd, client, &adv7511_ops);\n\tsd->internal_ops = &adv7511_int_ops;\n\n\thdl = &state->hdl;\n\tv4l2_ctrl_handler_init(hdl, 10);\n\t \n\tstate->hdmi_mode_ctrl = v4l2_ctrl_new_std_menu(hdl, &adv7511_ctrl_ops,\n\t\t\tV4L2_CID_DV_TX_MODE, V4L2_DV_TX_MODE_HDMI,\n\t\t\t0, V4L2_DV_TX_MODE_DVI_D);\n\tstate->hotplug_ctrl = v4l2_ctrl_new_std(hdl, NULL,\n\t\t\tV4L2_CID_DV_TX_HOTPLUG, 0, 1, 0, 0);\n\tstate->rx_sense_ctrl = v4l2_ctrl_new_std(hdl, NULL,\n\t\t\tV4L2_CID_DV_TX_RXSENSE, 0, 1, 0, 0);\n\tstate->have_edid0_ctrl = v4l2_ctrl_new_std(hdl, NULL,\n\t\t\tV4L2_CID_DV_TX_EDID_PRESENT, 0, 1, 0, 0);\n\tstate->rgb_quantization_range_ctrl =\n\t\tv4l2_ctrl_new_std_menu(hdl, &adv7511_ctrl_ops,\n\t\t\tV4L2_CID_DV_TX_RGB_RANGE, V4L2_DV_RGB_RANGE_FULL,\n\t\t\t0, V4L2_DV_RGB_RANGE_AUTO);\n\tstate->content_type_ctrl =\n\t\tv4l2_ctrl_new_std_menu(hdl, &adv7511_ctrl_ops,\n\t\t\tV4L2_CID_DV_TX_IT_CONTENT_TYPE, V4L2_DV_IT_CONTENT_TYPE_NO_ITC,\n\t\t\t0, V4L2_DV_IT_CONTENT_TYPE_NO_ITC);\n\tsd->ctrl_handler = hdl;\n\tif (hdl->error) {\n\t\terr = hdl->error;\n\t\tgoto err_hdl;\n\t}\n\tstate->pad.flags = MEDIA_PAD_FL_SINK;\n\tsd->entity.function = MEDIA_ENT_F_DV_ENCODER;\n\terr = media_entity_pads_init(&sd->entity, 1, &state->pad);\n\tif (err)\n\t\tgoto err_hdl;\n\n\t \n\tstate->i2c_edid_addr = state->pdata.i2c_edid << 1;\n\tstate->i2c_cec_addr = state->pdata.i2c_cec << 1;\n\tstate->i2c_pktmem_addr = state->pdata.i2c_pktmem << 1;\n\n\tstate->chip_revision = adv7511_rd(sd, 0x0);\n\tchip_id[0] = adv7511_rd(sd, 0xf5);\n\tchip_id[1] = adv7511_rd(sd, 0xf6);\n\tif (chip_id[0] != 0x75 || chip_id[1] != 0x11) {\n\t\tv4l2_err(sd, \"chip_id != 0x7511, read 0x%02x%02x\\n\", chip_id[0],\n\t\t\t chip_id[1]);\n\t\terr = -EIO;\n\t\tgoto err_entity;\n\t}\n\n\tstate->i2c_edid = i2c_new_dummy_device(client->adapter,\n\t\t\t\t\tstate->i2c_edid_addr >> 1);\n\tif (IS_ERR(state->i2c_edid)) {\n\t\tv4l2_err(sd, \"failed to register edid i2c client\\n\");\n\t\terr = PTR_ERR(state->i2c_edid);\n\t\tgoto err_entity;\n\t}\n\n\tadv7511_wr(sd, 0xe1, state->i2c_cec_addr);\n\tif (state->pdata.cec_clk < 3000000 ||\n\t    state->pdata.cec_clk > 100000000) {\n\t\tv4l2_err(sd, \"%s: cec_clk %u outside range, disabling cec\\n\",\n\t\t\t\t__func__, state->pdata.cec_clk);\n\t\tstate->pdata.cec_clk = 0;\n\t}\n\n\tif (state->pdata.cec_clk) {\n\t\tstate->i2c_cec = i2c_new_dummy_device(client->adapter,\n\t\t\t\t\t       state->i2c_cec_addr >> 1);\n\t\tif (IS_ERR(state->i2c_cec)) {\n\t\t\tv4l2_err(sd, \"failed to register cec i2c client\\n\");\n\t\t\terr = PTR_ERR(state->i2c_cec);\n\t\t\tgoto err_unreg_edid;\n\t\t}\n\t\tadv7511_wr(sd, 0xe2, 0x00);  \n\t} else {\n\t\tadv7511_wr(sd, 0xe2, 0x01);  \n\t}\n\n\tstate->i2c_pktmem = i2c_new_dummy_device(client->adapter, state->i2c_pktmem_addr >> 1);\n\tif (IS_ERR(state->i2c_pktmem)) {\n\t\tv4l2_err(sd, \"failed to register pktmem i2c client\\n\");\n\t\terr = PTR_ERR(state->i2c_pktmem);\n\t\tgoto err_unreg_cec;\n\t}\n\n\tstate->work_queue = create_singlethread_workqueue(sd->name);\n\tif (state->work_queue == NULL) {\n\t\tv4l2_err(sd, \"could not create workqueue\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_unreg_pktmem;\n\t}\n\n\tINIT_DELAYED_WORK(&state->edid_handler, adv7511_edid_handler);\n\n\tadv7511_init_setup(sd);\n\n#if IS_ENABLED(CONFIG_VIDEO_ADV7511_CEC)\n\tstate->cec_adap = cec_allocate_adapter(&adv7511_cec_adap_ops,\n\t\tstate, dev_name(&client->dev), CEC_CAP_DEFAULTS,\n\t\tADV7511_MAX_ADDRS);\n\terr = PTR_ERR_OR_ZERO(state->cec_adap);\n\tif (err) {\n\t\tdestroy_workqueue(state->work_queue);\n\t\tgoto err_unreg_pktmem;\n\t}\n#endif\n\n\tadv7511_set_isr(sd, true);\n\tadv7511_check_monitor_present_status(sd);\n\n\tv4l2_info(sd, \"%s found @ 0x%x (%s)\\n\", client->name,\n\t\t\t  client->addr << 1, client->adapter->name);\n\treturn 0;\n\nerr_unreg_pktmem:\n\ti2c_unregister_device(state->i2c_pktmem);\nerr_unreg_cec:\n\ti2c_unregister_device(state->i2c_cec);\nerr_unreg_edid:\n\ti2c_unregister_device(state->i2c_edid);\nerr_entity:\n\tmedia_entity_cleanup(&sd->entity);\nerr_hdl:\n\tv4l2_ctrl_handler_free(&state->hdl);\n\treturn err;\n}\n\n \n\nstatic void adv7511_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct adv7511_state *state = get_adv7511_state(sd);\n\n\tstate->chip_revision = -1;\n\n\tv4l2_dbg(1, debug, sd, \"%s removed @ 0x%x (%s)\\n\", client->name,\n\t\t client->addr << 1, client->adapter->name);\n\n\tadv7511_set_isr(sd, false);\n\tadv7511_init_setup(sd);\n\tcancel_delayed_work_sync(&state->edid_handler);\n\ti2c_unregister_device(state->i2c_edid);\n\ti2c_unregister_device(state->i2c_cec);\n\ti2c_unregister_device(state->i2c_pktmem);\n\tdestroy_workqueue(state->work_queue);\n\tv4l2_device_unregister_subdev(sd);\n\tmedia_entity_cleanup(&sd->entity);\n\tv4l2_ctrl_handler_free(sd->ctrl_handler);\n}\n\n \n\nstatic const struct i2c_device_id adv7511_id[] = {\n\t{ \"adv7511-v4l2\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adv7511_id);\n\nstatic struct i2c_driver adv7511_driver = {\n\t.driver = {\n\t\t.name = \"adv7511-v4l2\",\n\t},\n\t.probe = adv7511_probe,\n\t.remove = adv7511_remove,\n\t.id_table = adv7511_id,\n};\n\nmodule_i2c_driver(adv7511_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}