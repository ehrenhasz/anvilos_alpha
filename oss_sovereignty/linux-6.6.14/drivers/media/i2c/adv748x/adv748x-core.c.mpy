{
  "module_name": "adv748x-core.c",
  "hash_id": "6d5018b7bd0df78a6316566f3d5517faafff1ffbf847a3f77423edfdd50755b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/adv748x/adv748x-core.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of_graph.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/v4l2-dv-timings.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-dv-timings.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-ioctl.h>\n\n#include \"adv748x.h\"\n\n \n\n#define ADV748X_REGMAP_CONF(n) \\\n{ \\\n\t.name = n, \\\n\t.reg_bits = 8, \\\n\t.val_bits = 8, \\\n\t.max_register = 0xff, \\\n\t.cache_type = REGCACHE_NONE, \\\n}\n\nstatic const struct regmap_config adv748x_regmap_cnf[] = {\n\tADV748X_REGMAP_CONF(\"io\"),\n\tADV748X_REGMAP_CONF(\"dpll\"),\n\tADV748X_REGMAP_CONF(\"cp\"),\n\tADV748X_REGMAP_CONF(\"hdmi\"),\n\tADV748X_REGMAP_CONF(\"edid\"),\n\tADV748X_REGMAP_CONF(\"repeater\"),\n\tADV748X_REGMAP_CONF(\"infoframe\"),\n\tADV748X_REGMAP_CONF(\"cbus\"),\n\tADV748X_REGMAP_CONF(\"cec\"),\n\tADV748X_REGMAP_CONF(\"sdp\"),\n\tADV748X_REGMAP_CONF(\"txa\"),\n\tADV748X_REGMAP_CONF(\"txb\"),\n};\n\nstatic int adv748x_configure_regmap(struct adv748x_state *state, int region)\n{\n\tint err;\n\n\tif (!state->i2c_clients[region])\n\t\treturn -ENODEV;\n\n\tstate->regmap[region] =\n\t\tdevm_regmap_init_i2c(state->i2c_clients[region],\n\t\t\t\t     &adv748x_regmap_cnf[region]);\n\n\tif (IS_ERR(state->regmap[region])) {\n\t\terr = PTR_ERR(state->regmap[region]);\n\t\tadv_err(state,\n\t\t\t\"Error initializing regmap %d with error %d\\n\",\n\t\t\tregion, err);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nstruct adv748x_register_map {\n\tconst char *name;\n\tu8 default_addr;\n};\n\nstatic const struct adv748x_register_map adv748x_default_addresses[] = {\n\t[ADV748X_PAGE_IO] = { \"main\", 0x70 },\n\t[ADV748X_PAGE_DPLL] = { \"dpll\", 0x26 },\n\t[ADV748X_PAGE_CP] = { \"cp\", 0x22 },\n\t[ADV748X_PAGE_HDMI] = { \"hdmi\", 0x34 },\n\t[ADV748X_PAGE_EDID] = { \"edid\", 0x36 },\n\t[ADV748X_PAGE_REPEATER] = { \"repeater\", 0x32 },\n\t[ADV748X_PAGE_INFOFRAME] = { \"infoframe\", 0x31 },\n\t[ADV748X_PAGE_CBUS] = { \"cbus\", 0x30 },\n\t[ADV748X_PAGE_CEC] = { \"cec\", 0x41 },\n\t[ADV748X_PAGE_SDP] = { \"sdp\", 0x79 },\n\t[ADV748X_PAGE_TXB] = { \"txb\", 0x48 },\n\t[ADV748X_PAGE_TXA] = { \"txa\", 0x4a },\n};\n\nstatic int adv748x_read_check(struct adv748x_state *state,\n\t\t\t      int client_page, u8 reg)\n{\n\tstruct i2c_client *client = state->i2c_clients[client_page];\n\tint err;\n\tunsigned int val;\n\n\terr = regmap_read(state->regmap[client_page], reg, &val);\n\n\tif (err) {\n\t\tadv_err(state, \"error reading %02x, %02x\\n\",\n\t\t\t\tclient->addr, reg);\n\t\treturn err;\n\t}\n\n\treturn val;\n}\n\nint adv748x_read(struct adv748x_state *state, u8 page, u8 reg)\n{\n\treturn adv748x_read_check(state, page, reg);\n}\n\nint adv748x_write(struct adv748x_state *state, u8 page, u8 reg, u8 value)\n{\n\treturn regmap_write(state->regmap[page], reg, value);\n}\n\nstatic int adv748x_write_check(struct adv748x_state *state, u8 page, u8 reg,\n\t\t\t       u8 value, int *error)\n{\n\tif (*error)\n\t\treturn *error;\n\n\t*error = adv748x_write(state, page, reg, value);\n\treturn *error;\n}\n\n \nint adv748x_write_block(struct adv748x_state *state, int client_page,\n\t\t\tunsigned int init_reg, const void *val,\n\t\t\tsize_t val_len)\n{\n\tstruct regmap *regmap = state->regmap[client_page];\n\n\tif (val_len > I2C_SMBUS_BLOCK_MAX)\n\t\tval_len = I2C_SMBUS_BLOCK_MAX;\n\n\treturn regmap_raw_write(regmap, init_reg, val, val_len);\n}\n\nstatic int adv748x_set_slave_addresses(struct adv748x_state *state)\n{\n\tstruct i2c_client *client;\n\tunsigned int i;\n\tu8 io_reg;\n\n\tfor (i = ADV748X_PAGE_DPLL; i < ADV748X_PAGE_MAX; ++i) {\n\t\tio_reg = ADV748X_IO_SLAVE_ADDR_BASE + i;\n\t\tclient = state->i2c_clients[i];\n\n\t\tio_write(state, io_reg, client->addr << 1);\n\t}\n\n\treturn 0;\n}\n\nstatic void adv748x_unregister_clients(struct adv748x_state *state)\n{\n\tunsigned int i;\n\n\tfor (i = 1; i < ARRAY_SIZE(state->i2c_clients); ++i)\n\t\ti2c_unregister_device(state->i2c_clients[i]);\n}\n\nstatic int adv748x_initialise_clients(struct adv748x_state *state)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = ADV748X_PAGE_DPLL; i < ADV748X_PAGE_MAX; ++i) {\n\t\tstate->i2c_clients[i] = i2c_new_ancillary_device(\n\t\t\t\tstate->client,\n\t\t\t\tadv748x_default_addresses[i].name,\n\t\t\t\tadv748x_default_addresses[i].default_addr);\n\n\t\tif (IS_ERR(state->i2c_clients[i])) {\n\t\t\tadv_err(state, \"failed to create i2c client %u\\n\", i);\n\t\t\treturn PTR_ERR(state->i2c_clients[i]);\n\t\t}\n\n\t\tret = adv748x_configure_regmap(state, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstruct adv748x_reg_value {\n\tu8 page;\n\tu8 reg;\n\tu8 value;\n};\n\nstatic int adv748x_write_regs(struct adv748x_state *state,\n\t\t\t      const struct adv748x_reg_value *regs)\n{\n\tint ret;\n\n\tfor (; regs->page != ADV748X_PAGE_EOR; regs++) {\n\t\tret = adv748x_write(state, regs->page, regs->reg, regs->value);\n\t\tif (ret < 0) {\n\t\t\tadv_err(state, \"Error regs page: 0x%02x reg: 0x%02x\\n\",\n\t\t\t\tregs->page, regs->reg);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int adv748x_power_up_tx(struct adv748x_csi2 *tx)\n{\n\tstruct adv748x_state *state = tx->state;\n\tu8 page = is_txa(tx) ? ADV748X_PAGE_TXA : ADV748X_PAGE_TXB;\n\tint ret = 0;\n\n\t \n\tadv748x_write_check(state, page, 0x00, 0x80 | tx->active_lanes, &ret);\n\n\t \n\tadv748x_write_check(state, page, 0x00, 0xa0 | tx->active_lanes, &ret);\n\n\t \n\tif (tx->src == &state->hdmi.sd) {\n\t\tadv748x_write_check(state, page, 0xdb, 0x10, &ret);\n\t\tadv748x_write_check(state, page, 0xd6, 0x07, &ret);\n\t} else {\n\t\tadv748x_write_check(state, page, 0xd2, 0x40, &ret);\n\t}\n\n\tadv748x_write_check(state, page, 0xc4, 0x0a, &ret);\n\tadv748x_write_check(state, page, 0x71, 0x33, &ret);\n\tadv748x_write_check(state, page, 0x72, 0x11, &ret);\n\n\t \n\tadv748x_write_check(state, page, 0xf0, 0x00, &ret);\n\n\t \n\tadv748x_write_check(state, page, 0x31, 0x82, &ret);\n\tadv748x_write_check(state, page, 0x1e, 0x40, &ret);\n\n\t \n\tadv748x_write_check(state, page, 0xda, 0x01, &ret);\n\tusleep_range(2000, 2500);\n\n\t \n\tadv748x_write_check(state, page, 0x00, 0x20 | tx->active_lanes, &ret);\n\tusleep_range(1000, 1500);\n\n\t \n\tadv748x_write_check(state, page, 0xc1, 0x2b, &ret);\n\tusleep_range(1000, 1500);\n\tadv748x_write_check(state, page, 0x31, 0x80, &ret);\n\n\treturn ret;\n}\n\nstatic int adv748x_power_down_tx(struct adv748x_csi2 *tx)\n{\n\tstruct adv748x_state *state = tx->state;\n\tu8 page = is_txa(tx) ? ADV748X_PAGE_TXA : ADV748X_PAGE_TXB;\n\tint ret = 0;\n\n\t \n\tadv748x_write_check(state, page, 0x31, 0x82, &ret);\n\tadv748x_write_check(state, page, 0x1e, 0x00, &ret);\n\n\t \n\tadv748x_write_check(state, page, 0x00, 0x80 | tx->active_lanes, &ret);\n\n\t \n\tadv748x_write_check(state, page, 0xda, 0x01, &ret);\n\n\t \n\tadv748x_write_check(state, page, 0xc1, 0x3b, &ret);\n\n\treturn ret;\n}\n\nint adv748x_tx_power(struct adv748x_csi2 *tx, bool on)\n{\n\tint val;\n\n\tif (!is_tx_enabled(tx))\n\t\treturn 0;\n\n\tval = tx_read(tx, ADV748X_CSI_FS_AS_LS);\n\tif (val < 0)\n\t\treturn val;\n\n\t \n\tWARN_ONCE((on && val & ADV748X_CSI_FS_AS_LS_UNKNOWN),\n\t\t\t\"Enabling with unknown bit set\");\n\n\treturn on ? adv748x_power_up_tx(tx) : adv748x_power_down_tx(tx);\n}\n\n \nstatic int adv748x_link_setup(struct media_entity *entity,\n\t\t\t      const struct media_pad *local,\n\t\t\t      const struct media_pad *remote, u32 flags)\n{\n\tstruct v4l2_subdev *rsd = media_entity_to_v4l2_subdev(remote->entity);\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct adv748x_state *state = v4l2_get_subdevdata(sd);\n\tstruct adv748x_csi2 *tx = adv748x_sd_to_csi2(sd);\n\tbool enable = flags & MEDIA_LNK_FL_ENABLED;\n\tu8 io10_mask = ADV748X_IO_10_CSI1_EN |\n\t\t       ADV748X_IO_10_CSI4_EN |\n\t\t       ADV748X_IO_10_CSI4_IN_SEL_AFE;\n\tu8 io10 = 0;\n\n\t \n\tif (enable && tx->src)\n\t\treturn -EINVAL;\n\n\t \n\tif (rsd == &state->afe.sd)\n\t\tstate->afe.tx = enable ? tx : NULL;\n\telse\n\t\tstate->hdmi.tx = enable ? tx : NULL;\n\n\ttx->src = enable ? rsd : NULL;\n\n\tif (state->afe.tx) {\n\t\t \n\t\tio10 |= ADV748X_IO_10_CSI4_EN;\n\t\tif (is_txa(tx)) {\n\t\t\t \n\t\t\ttx->active_lanes = min(tx->num_lanes, 2U);\n\t\t\tio10 |= ADV748X_IO_10_CSI4_IN_SEL_AFE;\n\t\t} else {\n\t\t\t \n\t\t\tio10 |= ADV748X_IO_10_CSI1_EN;\n\t\t}\n\t}\n\n\tif (state->hdmi.tx) {\n\t\t \n\t\ttx->active_lanes = tx->num_lanes;\n\t\tio10 |= ADV748X_IO_10_CSI4_EN;\n\t}\n\n\treturn io_clrset(state, ADV748X_IO_10, io10_mask, io10);\n}\n\nstatic const struct media_entity_operations adv748x_tx_media_ops = {\n\t.link_setup\t= adv748x_link_setup,\n\t.link_validate\t= v4l2_subdev_link_validate,\n};\n\nstatic const struct media_entity_operations adv748x_media_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\n \n\n \nstatic const struct adv748x_reg_value adv748x_init_hdmi[] = {\n\t \n\t{ADV748X_PAGE_IO, 0x00, 0x40},\n\n\t{ADV748X_PAGE_REPEATER, 0x40, 0x83},  \n\n\t{ADV748X_PAGE_HDMI, 0x00, 0x08}, \n\t{ADV748X_PAGE_HDMI, 0x98, 0xff}, \n\t{ADV748X_PAGE_HDMI, 0x99, 0xa3}, \n\t{ADV748X_PAGE_HDMI, 0x9a, 0x00}, \n\t{ADV748X_PAGE_HDMI, 0x9b, 0x0a}, \n\t{ADV748X_PAGE_HDMI, 0x9d, 0x40}, \n\t{ADV748X_PAGE_HDMI, 0xcb, 0x09}, \n\t{ADV748X_PAGE_HDMI, 0x3d, 0x10}, \n\t{ADV748X_PAGE_HDMI, 0x3e, 0x7b}, \n\t{ADV748X_PAGE_HDMI, 0x3f, 0x5e}, \n\t{ADV748X_PAGE_HDMI, 0x4e, 0xfe}, \n\t{ADV748X_PAGE_HDMI, 0x4f, 0x18}, \n\t{ADV748X_PAGE_HDMI, 0x57, 0xa3}, \n\t{ADV748X_PAGE_HDMI, 0x58, 0x04}, \n\t{ADV748X_PAGE_HDMI, 0x85, 0x10}, \n\n\t{ADV748X_PAGE_HDMI, 0x83, 0x00}, \n\t{ADV748X_PAGE_HDMI, 0xa3, 0x01}, \n\t{ADV748X_PAGE_HDMI, 0xbe, 0x00}, \n\n\t{ADV748X_PAGE_HDMI, 0x6c, 0x01}, \n\t{ADV748X_PAGE_HDMI, 0xf8, 0x01}, \n\t{ADV748X_PAGE_HDMI, 0x0f, 0x00}, \n\t \n\n\t{ADV748X_PAGE_IO, 0x04, 0x02},\t \n\t{ADV748X_PAGE_IO, 0x12, 0xf0},\t \n\t{ADV748X_PAGE_IO, 0x17, 0x80},\t \n\t{ADV748X_PAGE_IO, 0x03, 0x86},\t \n\n\t{ADV748X_PAGE_CP, 0x7c, 0x00},\t \n\n\t{ADV748X_PAGE_IO, 0x0c, 0xe0},\t \n\t{ADV748X_PAGE_IO, 0x0e, 0xdd},\t \n\n\t{ADV748X_PAGE_EOR, 0xff, 0xff}\t \n};\n\n \nstatic const struct adv748x_reg_value adv748x_init_afe[] = {\n\t{ADV748X_PAGE_IO, 0x00, 0x30},\t \n\t{ADV748X_PAGE_IO, 0xf2, 0x01},\t \n\n\t{ADV748X_PAGE_IO, 0x0e, 0xff},\t \n\n\t{ADV748X_PAGE_SDP, 0x0f, 0x00},\t \n\t{ADV748X_PAGE_SDP, 0x52, 0xcd},\t \n\n\t{ADV748X_PAGE_SDP, 0x0e, 0x80},\t \n\t{ADV748X_PAGE_SDP, 0x9c, 0x00},\t \n\t{ADV748X_PAGE_SDP, 0x9c, 0xff},\t \n\t{ADV748X_PAGE_SDP, 0x0e, 0x00},\t \n\n\t \n\t{ADV748X_PAGE_SDP, 0x80, 0x51},\t \n\t{ADV748X_PAGE_SDP, 0x81, 0x51},\t \n\t{ADV748X_PAGE_SDP, 0x82, 0x68},\t \n\n\t{ADV748X_PAGE_SDP, 0x03, 0x42},\t \n\t{ADV748X_PAGE_SDP, 0x04, 0xb5},\t \n\t{ADV748X_PAGE_SDP, 0x13, 0x00},\t \n\n\t{ADV748X_PAGE_SDP, 0x17, 0x41},\t \n\t{ADV748X_PAGE_SDP, 0x31, 0x12},\t \n\t{ADV748X_PAGE_SDP, 0xe6, 0x4f},   \n\n\t{ADV748X_PAGE_EOR, 0xff, 0xff}\t \n};\n\nstatic int adv748x_sw_reset(struct adv748x_state *state)\n{\n\tint ret;\n\n\tret = io_write(state, ADV748X_IO_REG_FF, ADV748X_IO_REG_FF_MAIN_RESET);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(5000, 6000);\n\n\t \n\tret = io_clrset(state, ADV748X_IO_REG_01, ADV748X_IO_REG_01_PWRDN_MASK,\n\t\t\tADV748X_IO_REG_01_PWRDNB);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn io_write(state, ADV748X_IO_REG_F2,\n\t\t\tADV748X_IO_REG_F2_READ_AUTO_INC);\n}\n\nstatic int adv748x_reset(struct adv748x_state *state)\n{\n\tint ret;\n\tu8 regval = 0;\n\n\tret = adv748x_sw_reset(state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = adv748x_set_slave_addresses(state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = adv748x_write_regs(state, adv748x_init_hdmi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adv748x_write_regs(state, adv748x_init_afe);\n\tif (ret)\n\t\treturn ret;\n\n\tadv748x_afe_s_input(&state->afe, state->afe.input);\n\n\tadv_dbg(state, \"AFE Default input set to %d\\n\", state->afe.input);\n\n\t \n\tadv748x_tx_power(&state->txa, 1);\n\tadv748x_tx_power(&state->txa, 0);\n\tadv748x_tx_power(&state->txb, 1);\n\tadv748x_tx_power(&state->txb, 0);\n\n\t \n\tio_write(state, ADV748X_IO_PD, ADV748X_IO_PD_RX_EN);\n\n\t \n\tif (is_tx_enabled(&state->txa)) {\n\t\tregval |= ADV748X_IO_10_CSI4_EN;\n\t\tadv748x_csi2_set_virtual_channel(&state->txa, 0);\n\t}\n\tif (is_tx_enabled(&state->txb)) {\n\t\tregval |= ADV748X_IO_10_CSI1_EN;\n\t\tadv748x_csi2_set_virtual_channel(&state->txb, 0);\n\t}\n\tio_write(state, ADV748X_IO_10, regval);\n\n\t \n\tcp_clrset(state, ADV748X_CP_CLMP_POS, ADV748X_CP_CLMP_POS_DIS_AUTO,\n\t\t\t\t\t      ADV748X_CP_CLMP_POS_DIS_AUTO);\n\n\treturn 0;\n}\n\nstatic int adv748x_identify_chip(struct adv748x_state *state)\n{\n\tint msb, lsb;\n\n\tlsb = io_read(state, ADV748X_IO_CHIP_REV_ID_1);\n\tmsb = io_read(state, ADV748X_IO_CHIP_REV_ID_2);\n\n\tif (lsb < 0 || msb < 0) {\n\t\tadv_err(state, \"Failed to read chip revision\\n\");\n\t\treturn -EIO;\n\t}\n\n\tadv_info(state, \"chip found @ 0x%02x revision %02x%02x\\n\",\n\t\t state->client->addr << 1, lsb, msb);\n\n\treturn 0;\n}\n\n \n\nstatic int __maybe_unused adv748x_resume_early(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct adv748x_state *state = i2c_get_clientdata(client);\n\n\treturn adv748x_reset(state);\n}\n\n \n\nvoid adv748x_subdev_init(struct v4l2_subdev *sd, struct adv748x_state *state,\n\t\t\t const struct v4l2_subdev_ops *ops, u32 function,\n\t\t\t const char *ident)\n{\n\tv4l2_subdev_init(sd, ops);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\t \n\tsd->owner = state->dev->driver->owner;\n\tsd->dev = state->dev;\n\n\tv4l2_set_subdevdata(sd, state);\n\n\t \n\tsnprintf(sd->name, sizeof(sd->name), \"%s %d-%04x %s\",\n\t\tstate->dev->driver->name,\n\t\ti2c_adapter_id(state->client->adapter),\n\t\tstate->client->addr, ident);\n\n\tsd->entity.function = function;\n\tsd->entity.ops = is_tx(adv748x_sd_to_csi2(sd)) ?\n\t\t\t &adv748x_tx_media_ops : &adv748x_media_ops;\n}\n\nstatic int adv748x_parse_csi2_lanes(struct adv748x_state *state,\n\t\t\t\t    unsigned int port,\n\t\t\t\t    struct device_node *ep)\n{\n\tstruct v4l2_fwnode_endpoint vep = { .bus_type = V4L2_MBUS_CSI2_DPHY };\n\tunsigned int num_lanes;\n\tint ret;\n\n\tif (port != ADV748X_PORT_TXA && port != ADV748X_PORT_TXB)\n\t\treturn 0;\n\n\tret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(ep), &vep);\n\tif (ret)\n\t\treturn ret;\n\n\tnum_lanes = vep.bus.mipi_csi2.num_data_lanes;\n\n\tif (vep.base.port == ADV748X_PORT_TXA) {\n\t\tif (num_lanes != 1 && num_lanes != 2 && num_lanes != 4) {\n\t\t\tadv_err(state, \"TXA: Invalid number (%u) of lanes\\n\",\n\t\t\t\tnum_lanes);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tstate->txa.num_lanes = num_lanes;\n\t\tstate->txa.active_lanes = num_lanes;\n\t\tadv_dbg(state, \"TXA: using %u lanes\\n\", state->txa.num_lanes);\n\t}\n\n\tif (vep.base.port == ADV748X_PORT_TXB) {\n\t\tif (num_lanes != 1) {\n\t\t\tadv_err(state, \"TXB: Invalid number (%u) of lanes\\n\",\n\t\t\t\tnum_lanes);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tstate->txb.num_lanes = num_lanes;\n\t\tstate->txb.active_lanes = num_lanes;\n\t\tadv_dbg(state, \"TXB: using %u lanes\\n\", state->txb.num_lanes);\n\t}\n\n\treturn 0;\n}\n\nstatic int adv748x_parse_dt(struct adv748x_state *state)\n{\n\tstruct device_node *ep_np = NULL;\n\tstruct of_endpoint ep;\n\tbool out_found = false;\n\tbool in_found = false;\n\tint ret;\n\n\tfor_each_endpoint_of_node(state->dev->of_node, ep_np) {\n\t\tof_graph_parse_endpoint(ep_np, &ep);\n\t\tadv_info(state, \"Endpoint %pOF on port %d\", ep.local_node,\n\t\t\t ep.port);\n\n\t\tif (ep.port >= ADV748X_PORT_MAX) {\n\t\t\tadv_err(state, \"Invalid endpoint %pOF on port %d\",\n\t\t\t\tep.local_node, ep.port);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (state->endpoints[ep.port]) {\n\t\t\tadv_err(state,\n\t\t\t\t\"Multiple port endpoints are not supported\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tof_node_get(ep_np);\n\t\tstate->endpoints[ep.port] = ep_np;\n\n\t\t \n\t\tif (ep.port < ADV748X_PORT_TXA)\n\t\t\tin_found = true;\n\t\telse\n\t\t\tout_found = true;\n\n\t\t \n\t\tret = adv748x_parse_csi2_lanes(state, ep.port, ep_np);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn in_found && out_found ? 0 : -ENODEV;\n}\n\nstatic void adv748x_dt_cleanup(struct adv748x_state *state)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ADV748X_PORT_MAX; i++)\n\t\tof_node_put(state->endpoints[i]);\n}\n\nstatic int adv748x_probe(struct i2c_client *client)\n{\n\tstruct adv748x_state *state;\n\tint ret;\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tstate = devm_kzalloc(&client->dev, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&state->mutex);\n\n\tstate->dev = &client->dev;\n\tstate->client = client;\n\tstate->i2c_clients[ADV748X_PAGE_IO] = client;\n\ti2c_set_clientdata(client, state);\n\n\t \n\tstate->txa.state = state->txb.state = state;\n\tstate->txa.page = ADV748X_PAGE_TXA;\n\tstate->txb.page = ADV748X_PAGE_TXB;\n\tstate->txa.port = ADV748X_PORT_TXA;\n\tstate->txb.port = ADV748X_PORT_TXB;\n\n\t \n\tret = adv748x_parse_dt(state);\n\tif (ret) {\n\t\tadv_err(state, \"Failed to parse device tree\");\n\t\tgoto err_free_mutex;\n\t}\n\n\t \n\tret = adv748x_configure_regmap(state, ADV748X_PAGE_IO);\n\tif (ret) {\n\t\tadv_err(state, \"Error configuring IO regmap region\");\n\t\tgoto err_cleanup_dt;\n\t}\n\n\tret = adv748x_identify_chip(state);\n\tif (ret) {\n\t\tadv_err(state, \"Failed to identify chip\");\n\t\tgoto err_cleanup_dt;\n\t}\n\n\t \n\tret = adv748x_initialise_clients(state);\n\tif (ret) {\n\t\tadv_err(state, \"Failed to setup client regmap pages\");\n\t\tgoto err_cleanup_clients;\n\t}\n\n\t \n\tret = adv748x_reset(state);\n\tif (ret) {\n\t\tadv_err(state, \"Failed to reset hardware\");\n\t\tgoto err_cleanup_clients;\n\t}\n\n\t \n\tret = adv748x_hdmi_init(&state->hdmi);\n\tif (ret) {\n\t\tadv_err(state, \"Failed to probe HDMI\");\n\t\tgoto err_cleanup_clients;\n\t}\n\n\t \n\tret = adv748x_afe_init(&state->afe);\n\tif (ret) {\n\t\tadv_err(state, \"Failed to probe AFE\");\n\t\tgoto err_cleanup_hdmi;\n\t}\n\n\t \n\tret = adv748x_csi2_init(state, &state->txa);\n\tif (ret) {\n\t\tadv_err(state, \"Failed to probe TXA\");\n\t\tgoto err_cleanup_afe;\n\t}\n\n\t \n\tret = adv748x_csi2_init(state, &state->txb);\n\tif (ret) {\n\t\tadv_err(state, \"Failed to probe TXB\");\n\t\tgoto err_cleanup_txa;\n\t}\n\n\treturn 0;\n\nerr_cleanup_txa:\n\tadv748x_csi2_cleanup(&state->txa);\nerr_cleanup_afe:\n\tadv748x_afe_cleanup(&state->afe);\nerr_cleanup_hdmi:\n\tadv748x_hdmi_cleanup(&state->hdmi);\nerr_cleanup_clients:\n\tadv748x_unregister_clients(state);\nerr_cleanup_dt:\n\tadv748x_dt_cleanup(state);\nerr_free_mutex:\n\tmutex_destroy(&state->mutex);\n\n\treturn ret;\n}\n\nstatic void adv748x_remove(struct i2c_client *client)\n{\n\tstruct adv748x_state *state = i2c_get_clientdata(client);\n\n\tadv748x_afe_cleanup(&state->afe);\n\tadv748x_hdmi_cleanup(&state->hdmi);\n\n\tadv748x_csi2_cleanup(&state->txa);\n\tadv748x_csi2_cleanup(&state->txb);\n\n\tadv748x_unregister_clients(state);\n\tadv748x_dt_cleanup(state);\n\tmutex_destroy(&state->mutex);\n}\n\nstatic const struct of_device_id adv748x_of_table[] = {\n\t{ .compatible = \"adi,adv7481\", },\n\t{ .compatible = \"adi,adv7482\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, adv748x_of_table);\n\nstatic const struct dev_pm_ops adv748x_pm_ops = {\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(NULL, adv748x_resume_early)\n};\n\nstatic struct i2c_driver adv748x_driver = {\n\t.driver = {\n\t\t.name = \"adv748x\",\n\t\t.of_match_table = adv748x_of_table,\n\t\t.pm = &adv748x_pm_ops,\n\t},\n\t.probe = adv748x_probe,\n\t.remove = adv748x_remove,\n};\n\nmodule_i2c_driver(adv748x_driver);\n\nMODULE_AUTHOR(\"Kieran Bingham <kieran.bingham@ideasonboard.com>\");\nMODULE_DESCRIPTION(\"ADV748X video decoder\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}