{
  "module_name": "adv748x-afe.c",
  "hash_id": "01ca392fb2dd1dcbcba808853a9a44a739c8e26437c535bbf137c5d007242f98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/adv748x/adv748x-afe.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/v4l2-dv-timings.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-dv-timings.h>\n#include <media/v4l2-ioctl.h>\n\n#include \"adv748x.h\"\n\n \n\n#define ADV748X_AFE_STD_AD_PAL_BG_NTSC_J_SECAM\t\t0x0\n#define ADV748X_AFE_STD_AD_PAL_BG_NTSC_J_SECAM_PED\t0x1\n#define ADV748X_AFE_STD_AD_PAL_N_NTSC_J_SECAM\t\t0x2\n#define ADV748X_AFE_STD_AD_PAL_N_NTSC_M_SECAM\t\t0x3\n#define ADV748X_AFE_STD_NTSC_J\t\t\t\t0x4\n#define ADV748X_AFE_STD_NTSC_M\t\t\t\t0x5\n#define ADV748X_AFE_STD_PAL60\t\t\t\t0x6\n#define ADV748X_AFE_STD_NTSC_443\t\t\t0x7\n#define ADV748X_AFE_STD_PAL_BG\t\t\t\t0x8\n#define ADV748X_AFE_STD_PAL_N\t\t\t\t0x9\n#define ADV748X_AFE_STD_PAL_M\t\t\t\t0xa\n#define ADV748X_AFE_STD_PAL_M_PED\t\t\t0xb\n#define ADV748X_AFE_STD_PAL_COMB_N\t\t\t0xc\n#define ADV748X_AFE_STD_PAL_COMB_N_PED\t\t\t0xd\n#define ADV748X_AFE_STD_PAL_SECAM\t\t\t0xe\n#define ADV748X_AFE_STD_PAL_SECAM_PED\t\t\t0xf\n\nstatic int adv748x_afe_read_ro_map(struct adv748x_state *state, u8 reg)\n{\n\tint ret;\n\n\t \n\tret = sdp_write(state, ADV748X_SDP_MAP_SEL,\n\t\t\tADV748X_SDP_MAP_SEL_RO_MAIN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sdp_read(state, reg);\n}\n\nstatic int adv748x_afe_status(struct adv748x_afe *afe, u32 *signal,\n\t\t\t      v4l2_std_id *std)\n{\n\tstruct adv748x_state *state = adv748x_afe_to_state(afe);\n\tint info;\n\n\t \n\tinfo = adv748x_afe_read_ro_map(state, ADV748X_SDP_RO_10);\n\tif (info < 0)\n\t\treturn info;\n\n\tif (signal)\n\t\t*signal = info & ADV748X_SDP_RO_10_IN_LOCK ?\n\t\t\t\t0 : V4L2_IN_ST_NO_SIGNAL;\n\n\tif (!std)\n\t\treturn 0;\n\n\t \n\tif (!(info & ADV748X_SDP_RO_10_IN_LOCK)) {\n\t\t*std = V4L2_STD_UNKNOWN;\n\t\treturn 0;\n\t}\n\n\tswitch (info & 0x70) {\n\tcase 0x00:\n\t\t*std = V4L2_STD_NTSC;\n\t\tbreak;\n\tcase 0x10:\n\t\t*std = V4L2_STD_NTSC_443;\n\t\tbreak;\n\tcase 0x20:\n\t\t*std = V4L2_STD_PAL_M;\n\t\tbreak;\n\tcase 0x30:\n\t\t*std = V4L2_STD_PAL_60;\n\t\tbreak;\n\tcase 0x40:\n\t\t*std = V4L2_STD_PAL;\n\t\tbreak;\n\tcase 0x50:\n\t\t*std = V4L2_STD_SECAM;\n\t\tbreak;\n\tcase 0x60:\n\t\t*std = V4L2_STD_PAL_Nc | V4L2_STD_PAL_N;\n\t\tbreak;\n\tcase 0x70:\n\t\t*std = V4L2_STD_SECAM;\n\t\tbreak;\n\tdefault:\n\t\t*std = V4L2_STD_UNKNOWN;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void adv748x_afe_fill_format(struct adv748x_afe *afe,\n\t\t\t\t    struct v4l2_mbus_framefmt *fmt)\n{\n\tmemset(fmt, 0, sizeof(*fmt));\n\n\tfmt->code = MEDIA_BUS_FMT_UYVY8_2X8;\n\tfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tfmt->field = V4L2_FIELD_ALTERNATE;\n\n\tfmt->width = 720;\n\tfmt->height = afe->curr_norm & V4L2_STD_525_60 ? 480 : 576;\n\n\t \n\tfmt->height /= 2;\n}\n\nstatic int adv748x_afe_std(v4l2_std_id std)\n{\n\tif (std == V4L2_STD_PAL_60)\n\t\treturn ADV748X_AFE_STD_PAL60;\n\tif (std == V4L2_STD_NTSC_443)\n\t\treturn ADV748X_AFE_STD_NTSC_443;\n\tif (std == V4L2_STD_PAL_N)\n\t\treturn ADV748X_AFE_STD_PAL_N;\n\tif (std == V4L2_STD_PAL_M)\n\t\treturn ADV748X_AFE_STD_PAL_M;\n\tif (std == V4L2_STD_PAL_Nc)\n\t\treturn ADV748X_AFE_STD_PAL_COMB_N;\n\tif (std & V4L2_STD_NTSC)\n\t\treturn ADV748X_AFE_STD_NTSC_M;\n\tif (std & V4L2_STD_PAL)\n\t\treturn ADV748X_AFE_STD_PAL_BG;\n\tif (std & V4L2_STD_SECAM)\n\t\treturn ADV748X_AFE_STD_PAL_SECAM;\n\n\treturn -EINVAL;\n}\n\nstatic void adv748x_afe_set_video_standard(struct adv748x_state *state,\n\t\t\t\t\t  int sdpstd)\n{\n\tsdp_clrset(state, ADV748X_SDP_VID_SEL, ADV748X_SDP_VID_SEL_MASK,\n\t\t   (sdpstd & 0xf) << ADV748X_SDP_VID_SEL_SHIFT);\n}\n\nint adv748x_afe_s_input(struct adv748x_afe *afe, unsigned int input)\n{\n\tstruct adv748x_state *state = adv748x_afe_to_state(afe);\n\n\treturn sdp_write(state, ADV748X_SDP_INSEL, input);\n}\n\nstatic int adv748x_afe_g_pixelaspect(struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_fract *aspect)\n{\n\tstruct adv748x_afe *afe = adv748x_sd_to_afe(sd);\n\n\tif (afe->curr_norm & V4L2_STD_525_60) {\n\t\taspect->numerator = 11;\n\t\taspect->denominator = 10;\n\t} else {\n\t\taspect->numerator = 54;\n\t\taspect->denominator = 59;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int adv748x_afe_g_std(struct v4l2_subdev *sd, v4l2_std_id *norm)\n{\n\tstruct adv748x_afe *afe = adv748x_sd_to_afe(sd);\n\n\t*norm = afe->curr_norm;\n\n\treturn 0;\n}\n\nstatic int adv748x_afe_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct adv748x_afe *afe = adv748x_sd_to_afe(sd);\n\tstruct adv748x_state *state = adv748x_afe_to_state(afe);\n\tint afe_std = adv748x_afe_std(std);\n\n\tif (afe_std < 0)\n\t\treturn afe_std;\n\n\tmutex_lock(&state->mutex);\n\n\tadv748x_afe_set_video_standard(state, afe_std);\n\tafe->curr_norm = std;\n\n\tmutex_unlock(&state->mutex);\n\n\treturn 0;\n}\n\nstatic int adv748x_afe_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)\n{\n\tstruct adv748x_afe *afe = adv748x_sd_to_afe(sd);\n\tstruct adv748x_state *state = adv748x_afe_to_state(afe);\n\tint afe_std;\n\tint ret;\n\n\tmutex_lock(&state->mutex);\n\n\tif (afe->streaming) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\t \n\tadv748x_afe_set_video_standard(state,\n\t\t\t\t       ADV748X_AFE_STD_AD_PAL_BG_NTSC_J_SECAM);\n\n\tmsleep(100);\n\n\t \n\tret = adv748x_afe_status(afe, NULL, std);\n\n\tafe_std = adv748x_afe_std(afe->curr_norm);\n\tif (afe_std < 0)\n\t\tgoto unlock;\n\n\t \n\tadv748x_afe_set_video_standard(state, afe_std);\n\nunlock:\n\tmutex_unlock(&state->mutex);\n\n\treturn ret;\n}\n\nstatic int adv748x_afe_g_tvnorms(struct v4l2_subdev *sd, v4l2_std_id *norm)\n{\n\t*norm = V4L2_STD_ALL;\n\n\treturn 0;\n}\n\nstatic int adv748x_afe_g_input_status(struct v4l2_subdev *sd, u32 *status)\n{\n\tstruct adv748x_afe *afe = adv748x_sd_to_afe(sd);\n\tstruct adv748x_state *state = adv748x_afe_to_state(afe);\n\tint ret;\n\n\tmutex_lock(&state->mutex);\n\n\tret = adv748x_afe_status(afe, status, NULL);\n\n\tmutex_unlock(&state->mutex);\n\n\treturn ret;\n}\n\nstatic int adv748x_afe_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct adv748x_afe *afe = adv748x_sd_to_afe(sd);\n\tstruct adv748x_state *state = adv748x_afe_to_state(afe);\n\tu32 signal = V4L2_IN_ST_NO_SIGNAL;\n\tint ret;\n\n\tmutex_lock(&state->mutex);\n\n\tif (enable) {\n\t\tret = adv748x_afe_s_input(afe, afe->input);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\n\tret = adv748x_tx_power(afe->tx, enable);\n\tif (ret)\n\t\tgoto unlock;\n\n\tafe->streaming = enable;\n\n\tadv748x_afe_status(afe, &signal, NULL);\n\tif (signal != V4L2_IN_ST_NO_SIGNAL)\n\t\tadv_dbg(state, \"Detected SDP signal\\n\");\n\telse\n\t\tadv_dbg(state, \"Couldn't detect SDP video signal\\n\");\n\nunlock:\n\tmutex_unlock(&state->mutex);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_video_ops adv748x_afe_video_ops = {\n\t.g_std = adv748x_afe_g_std,\n\t.s_std = adv748x_afe_s_std,\n\t.querystd = adv748x_afe_querystd,\n\t.g_tvnorms = adv748x_afe_g_tvnorms,\n\t.g_input_status = adv748x_afe_g_input_status,\n\t.s_stream = adv748x_afe_s_stream,\n\t.g_pixelaspect = adv748x_afe_g_pixelaspect,\n};\n\n \n\nstatic int adv748x_afe_propagate_pixelrate(struct adv748x_afe *afe)\n{\n\tstruct v4l2_subdev *tx;\n\n\ttx = adv748x_get_remote_sd(&afe->pads[ADV748X_AFE_SOURCE]);\n\tif (!tx)\n\t\treturn -ENOLINK;\n\n\t \n\treturn adv748x_csi2_set_pixelrate(tx, 14318180);\n}\n\nstatic int adv748x_afe_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t\t      struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index != 0)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_UYVY8_2X8;\n\n\treturn 0;\n}\n\nstatic int adv748x_afe_get_format(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t\t      struct v4l2_subdev_format *sdformat)\n{\n\tstruct adv748x_afe *afe = adv748x_sd_to_afe(sd);\n\tstruct v4l2_mbus_framefmt *mbusformat;\n\n\t \n\tif (sdformat->pad != ADV748X_AFE_SOURCE)\n\t\treturn -EINVAL;\n\n\tif (sdformat->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tmbusformat = v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t\t\tsdformat->pad);\n\t\tsdformat->format = *mbusformat;\n\t} else {\n\t\tadv748x_afe_fill_format(afe, &sdformat->format);\n\t\tadv748x_afe_propagate_pixelrate(afe);\n\t}\n\n\treturn 0;\n}\n\nstatic int adv748x_afe_set_format(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t\t      struct v4l2_subdev_format *sdformat)\n{\n\tstruct v4l2_mbus_framefmt *mbusformat;\n\n\t \n\tif (sdformat->pad != ADV748X_AFE_SOURCE)\n\t\treturn -EINVAL;\n\n\tif (sdformat->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn adv748x_afe_get_format(sd, sd_state, sdformat);\n\n\tmbusformat = v4l2_subdev_get_try_format(sd, sd_state, sdformat->pad);\n\t*mbusformat = sdformat->format;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops adv748x_afe_pad_ops = {\n\t.enum_mbus_code = adv748x_afe_enum_mbus_code,\n\t.set_fmt = adv748x_afe_set_format,\n\t.get_fmt = adv748x_afe_get_format,\n};\n\n \n\nstatic const struct v4l2_subdev_ops adv748x_afe_ops = {\n\t.video = &adv748x_afe_video_ops,\n\t.pad = &adv748x_afe_pad_ops,\n};\n\n \n\nstatic const char * const afe_ctrl_frp_menu[] = {\n\t\"Disabled\",\n\t\"Solid Blue\",\n\t\"Color Bars\",\n\t\"Grey Ramp\",\n\t\"Cb Ramp\",\n\t\"Cr Ramp\",\n\t\"Boundary\"\n};\n\nstatic int adv748x_afe_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct adv748x_afe *afe = adv748x_ctrl_to_afe(ctrl);\n\tstruct adv748x_state *state = adv748x_afe_to_state(afe);\n\tbool enable;\n\tint ret;\n\n\tret = sdp_write(state, 0x0e, 0x00);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tret = sdp_write(state, ADV748X_SDP_BRI, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\t \n\t\tret = sdp_write(state, ADV748X_SDP_HUE, -ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tret = sdp_write(state, ADV748X_SDP_CON, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tret = sdp_write(state, ADV748X_SDP_SD_SAT_U, ctrl->val);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = sdp_write(state, ADV748X_SDP_SD_SAT_V, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tenable = !!ctrl->val;\n\n\t\t \n\t\tret = sdp_clrset(state, ADV748X_SDP_DEF, ADV748X_SDP_DEF_VAL_EN,\n\t\t\t\tenable);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = sdp_clrset(state, ADV748X_SDP_FRP, ADV748X_SDP_FRP_MASK,\n\t\t\t\tenable ? ctrl->val - 1 : 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops adv748x_afe_ctrl_ops = {\n\t.s_ctrl = adv748x_afe_s_ctrl,\n};\n\nstatic int adv748x_afe_init_controls(struct adv748x_afe *afe)\n{\n\tstruct adv748x_state *state = adv748x_afe_to_state(afe);\n\n\tv4l2_ctrl_handler_init(&afe->ctrl_hdl, 5);\n\n\t \n\tafe->ctrl_hdl.lock = &state->mutex;\n\n\tv4l2_ctrl_new_std(&afe->ctrl_hdl, &adv748x_afe_ctrl_ops,\n\t\t\t  V4L2_CID_BRIGHTNESS, ADV748X_SDP_BRI_MIN,\n\t\t\t  ADV748X_SDP_BRI_MAX, 1, ADV748X_SDP_BRI_DEF);\n\tv4l2_ctrl_new_std(&afe->ctrl_hdl, &adv748x_afe_ctrl_ops,\n\t\t\t  V4L2_CID_CONTRAST, ADV748X_SDP_CON_MIN,\n\t\t\t  ADV748X_SDP_CON_MAX, 1, ADV748X_SDP_CON_DEF);\n\tv4l2_ctrl_new_std(&afe->ctrl_hdl, &adv748x_afe_ctrl_ops,\n\t\t\t  V4L2_CID_SATURATION, ADV748X_SDP_SAT_MIN,\n\t\t\t  ADV748X_SDP_SAT_MAX, 1, ADV748X_SDP_SAT_DEF);\n\tv4l2_ctrl_new_std(&afe->ctrl_hdl, &adv748x_afe_ctrl_ops,\n\t\t\t  V4L2_CID_HUE, ADV748X_SDP_HUE_MIN,\n\t\t\t  ADV748X_SDP_HUE_MAX, 1, ADV748X_SDP_HUE_DEF);\n\n\tv4l2_ctrl_new_std_menu_items(&afe->ctrl_hdl, &adv748x_afe_ctrl_ops,\n\t\t\t\t     V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(afe_ctrl_frp_menu) - 1,\n\t\t\t\t     0, 0, afe_ctrl_frp_menu);\n\n\tafe->sd.ctrl_handler = &afe->ctrl_hdl;\n\tif (afe->ctrl_hdl.error) {\n\t\tv4l2_ctrl_handler_free(&afe->ctrl_hdl);\n\t\treturn afe->ctrl_hdl.error;\n\t}\n\n\treturn v4l2_ctrl_handler_setup(&afe->ctrl_hdl);\n}\n\nint adv748x_afe_init(struct adv748x_afe *afe)\n{\n\tstruct adv748x_state *state = adv748x_afe_to_state(afe);\n\tint ret;\n\tunsigned int i;\n\n\tafe->input = 0;\n\tafe->streaming = false;\n\tafe->curr_norm = V4L2_STD_NTSC_M;\n\n\tadv748x_subdev_init(&afe->sd, state, &adv748x_afe_ops,\n\t\t\t    MEDIA_ENT_F_ATV_DECODER, \"afe\");\n\n\t \n\tfor (i = ADV748X_PORT_AIN0; i <= ADV748X_PORT_AIN7; i++) {\n\t\t \n\t\tif (state->endpoints[i]) {\n\t\t\tafe->input = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tadv748x_afe_s_input(afe, afe->input);\n\n\tadv_dbg(state, \"AFE Default input set to %d\\n\", afe->input);\n\n\t \n\tfor (i = ADV748X_AFE_SINK_AIN0; i <= ADV748X_AFE_SINK_AIN7; i++)\n\t\tafe->pads[i].flags = MEDIA_PAD_FL_SINK;\n\n\tafe->pads[ADV748X_AFE_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&afe->sd.entity, ADV748X_AFE_NR_PADS,\n\t\t\tafe->pads);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adv748x_afe_init_controls(afe);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tmedia_entity_cleanup(&afe->sd.entity);\n\n\treturn ret;\n}\n\nvoid adv748x_afe_cleanup(struct adv748x_afe *afe)\n{\n\tv4l2_device_unregister_subdev(&afe->sd);\n\tmedia_entity_cleanup(&afe->sd.entity);\n\tv4l2_ctrl_handler_free(&afe->ctrl_hdl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}