{
  "module_name": "adv748x-csi2.c",
  "hash_id": "efb95b69cff30fabf5fc01ad12a0718474cacff5fde02bea52ff7910283d4b13",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/adv748x/adv748x-csi2.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mutex.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n\n#include \"adv748x.h\"\n\nint adv748x_csi2_set_virtual_channel(struct adv748x_csi2 *tx, unsigned int vc)\n{\n\treturn tx_write(tx, ADV748X_CSI_VC_REF, vc << ADV748X_CSI_VC_REF_SHIFT);\n}\n\n \nstatic int adv748x_csi2_register_link(struct adv748x_csi2 *tx,\n\t\t\t\t      struct v4l2_device *v4l2_dev,\n\t\t\t\t      struct v4l2_subdev *src,\n\t\t\t\t      unsigned int src_pad,\n\t\t\t\t      bool enable)\n{\n\tint ret;\n\n\tif (!src->v4l2_dev) {\n\t\tret = v4l2_device_register_subdev(v4l2_dev, src);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = media_create_pad_link(&src->entity, src_pad,\n\t\t\t\t    &tx->sd.entity, ADV748X_CSI2_SINK,\n\t\t\t\t    enable ? MEDIA_LNK_FL_ENABLED : 0);\n\tif (ret)\n\t\treturn ret;\n\n\tif (enable)\n\t\ttx->src = src;\n\n\treturn 0;\n}\n\n \n\nstatic int adv748x_csi2_registered(struct v4l2_subdev *sd)\n{\n\tstruct adv748x_csi2 *tx = adv748x_sd_to_csi2(sd);\n\tstruct adv748x_state *state = tx->state;\n\tint ret;\n\n\tadv_dbg(state, \"Registered %s (%s)\", is_txa(tx) ? \"TXA\":\"TXB\",\n\t\t\tsd->name);\n\n\t \n\tif (is_afe_enabled(state)) {\n\t\tret = adv748x_csi2_register_link(tx, sd->v4l2_dev,\n\t\t\t\t\t\t &state->afe.sd,\n\t\t\t\t\t\t ADV748X_AFE_SOURCE,\n\t\t\t\t\t\t is_txb(tx));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (is_txb(tx))\n\t\t\tstate->afe.tx = tx;\n\t}\n\n\t \n\tif (is_txb(tx) || !is_hdmi_enabled(state))\n\t\treturn 0;\n\n\tret = adv748x_csi2_register_link(tx, sd->v4l2_dev, &state->hdmi.sd,\n\t\t\t\t\t ADV748X_HDMI_SOURCE, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tstate->hdmi.tx = tx;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_internal_ops adv748x_csi2_internal_ops = {\n\t.registered = adv748x_csi2_registered,\n};\n\n \n\nstatic int adv748x_csi2_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct adv748x_csi2 *tx = adv748x_sd_to_csi2(sd);\n\tstruct v4l2_subdev *src;\n\n\tsrc = adv748x_get_remote_sd(&tx->pads[ADV748X_CSI2_SINK]);\n\tif (!src)\n\t\treturn -EPIPE;\n\n\treturn v4l2_subdev_call(src, video, s_stream, enable);\n}\n\nstatic const struct v4l2_subdev_video_ops adv748x_csi2_video_ops = {\n\t.s_stream = adv748x_csi2_s_stream,\n};\n\n \n\nstatic struct v4l2_mbus_framefmt *\nadv748x_csi2_get_pad_format(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    unsigned int pad, u32 which)\n{\n\tstruct adv748x_csi2 *tx = adv748x_sd_to_csi2(sd);\n\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(sd, sd_state, pad);\n\n\treturn &tx->format;\n}\n\nstatic int adv748x_csi2_get_format(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_format *sdformat)\n{\n\tstruct adv748x_csi2 *tx = adv748x_sd_to_csi2(sd);\n\tstruct adv748x_state *state = tx->state;\n\tstruct v4l2_mbus_framefmt *mbusformat;\n\n\tmbusformat = adv748x_csi2_get_pad_format(sd, sd_state, sdformat->pad,\n\t\t\t\t\t\t sdformat->which);\n\tif (!mbusformat)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&state->mutex);\n\n\tsdformat->format = *mbusformat;\n\n\tmutex_unlock(&state->mutex);\n\n\treturn 0;\n}\n\nstatic int adv748x_csi2_set_format(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_format *sdformat)\n{\n\tstruct adv748x_csi2 *tx = adv748x_sd_to_csi2(sd);\n\tstruct adv748x_state *state = tx->state;\n\tstruct v4l2_mbus_framefmt *mbusformat;\n\tint ret = 0;\n\n\tmbusformat = adv748x_csi2_get_pad_format(sd, sd_state, sdformat->pad,\n\t\t\t\t\t\t sdformat->which);\n\tif (!mbusformat)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&state->mutex);\n\n\tif (sdformat->pad == ADV748X_CSI2_SOURCE) {\n\t\tconst struct v4l2_mbus_framefmt *sink_fmt;\n\n\t\tsink_fmt = adv748x_csi2_get_pad_format(sd, sd_state,\n\t\t\t\t\t\t       ADV748X_CSI2_SINK,\n\t\t\t\t\t\t       sdformat->which);\n\n\t\tif (!sink_fmt) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tsdformat->format = *sink_fmt;\n\t}\n\n\t*mbusformat = sdformat->format;\n\nunlock:\n\tmutex_unlock(&state->mutex);\n\n\treturn ret;\n}\n\nstatic int adv748x_csi2_get_mbus_config(struct v4l2_subdev *sd, unsigned int pad,\n\t\t\t\t\tstruct v4l2_mbus_config *config)\n{\n\tstruct adv748x_csi2 *tx = adv748x_sd_to_csi2(sd);\n\n\tif (pad != ADV748X_CSI2_SOURCE)\n\t\treturn -EINVAL;\n\n\tconfig->type = V4L2_MBUS_CSI2_DPHY;\n\tconfig->bus.mipi_csi2.num_data_lanes = tx->active_lanes;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops adv748x_csi2_pad_ops = {\n\t.get_fmt = adv748x_csi2_get_format,\n\t.set_fmt = adv748x_csi2_set_format,\n\t.get_mbus_config = adv748x_csi2_get_mbus_config,\n};\n\n \n\nstatic const struct v4l2_subdev_ops adv748x_csi2_ops = {\n\t.video = &adv748x_csi2_video_ops,\n\t.pad = &adv748x_csi2_pad_ops,\n};\n\n \n\nint adv748x_csi2_set_pixelrate(struct v4l2_subdev *sd, s64 rate)\n{\n\tstruct adv748x_csi2 *tx = adv748x_sd_to_csi2(sd);\n\n\tif (!tx->pixel_rate)\n\t\treturn -EINVAL;\n\n\treturn v4l2_ctrl_s_ctrl_int64(tx->pixel_rate, rate);\n}\n\nstatic int adv748x_csi2_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_PIXEL_RATE:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct v4l2_ctrl_ops adv748x_csi2_ctrl_ops = {\n\t.s_ctrl = adv748x_csi2_s_ctrl,\n};\n\nstatic int adv748x_csi2_init_controls(struct adv748x_csi2 *tx)\n{\n\n\tv4l2_ctrl_handler_init(&tx->ctrl_hdl, 1);\n\n\ttx->pixel_rate = v4l2_ctrl_new_std(&tx->ctrl_hdl,\n\t\t\t\t\t   &adv748x_csi2_ctrl_ops,\n\t\t\t\t\t   V4L2_CID_PIXEL_RATE, 1, INT_MAX,\n\t\t\t\t\t   1, 1);\n\n\ttx->sd.ctrl_handler = &tx->ctrl_hdl;\n\tif (tx->ctrl_hdl.error) {\n\t\tv4l2_ctrl_handler_free(&tx->ctrl_hdl);\n\t\treturn tx->ctrl_hdl.error;\n\t}\n\n\treturn v4l2_ctrl_handler_setup(&tx->ctrl_hdl);\n}\n\nint adv748x_csi2_init(struct adv748x_state *state, struct adv748x_csi2 *tx)\n{\n\tint ret;\n\n\tif (!is_tx_enabled(tx))\n\t\treturn 0;\n\n\tadv748x_subdev_init(&tx->sd, state, &adv748x_csi2_ops,\n\t\t\t    MEDIA_ENT_F_VID_IF_BRIDGE,\n\t\t\t    is_txa(tx) ? \"txa\" : \"txb\");\n\n\t \n\ttx->sd.internal_ops = &adv748x_csi2_internal_ops;\n\n\ttx->pads[ADV748X_CSI2_SINK].flags = MEDIA_PAD_FL_SINK;\n\ttx->pads[ADV748X_CSI2_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&tx->sd.entity, ADV748X_CSI2_NR_PADS,\n\t\t\t\t     tx->pads);\n\tif (ret)\n\t\treturn ret;\n\n\tret = v4l2_async_subdev_endpoint_add(&tx->sd,\n\t\t\t\t\t     of_fwnode_handle(state->endpoints[tx->port]));\n\tif (ret)\n\t\tgoto err_free_media;\n\n\tret = adv748x_csi2_init_controls(tx);\n\tif (ret)\n\t\tgoto err_cleanup_subdev;\n\n\tret = v4l2_async_register_subdev(&tx->sd);\n\tif (ret)\n\t\tgoto err_free_ctrl;\n\n\treturn 0;\n\nerr_free_ctrl:\n\tv4l2_ctrl_handler_free(&tx->ctrl_hdl);\nerr_cleanup_subdev:\n\tv4l2_subdev_cleanup(&tx->sd);\nerr_free_media:\n\tmedia_entity_cleanup(&tx->sd.entity);\n\n\treturn ret;\n}\n\nvoid adv748x_csi2_cleanup(struct adv748x_csi2 *tx)\n{\n\tif (!is_tx_enabled(tx))\n\t\treturn;\n\n\tv4l2_async_unregister_subdev(&tx->sd);\n\tmedia_entity_cleanup(&tx->sd.entity);\n\tv4l2_ctrl_handler_free(&tx->ctrl_hdl);\n\tv4l2_subdev_cleanup(&tx->sd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}