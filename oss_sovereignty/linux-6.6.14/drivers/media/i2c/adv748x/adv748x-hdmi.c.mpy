{
  "module_name": "adv748x-hdmi.c",
  "hash_id": "86a85070a71eaaa4004c123a0ce29bd8ff9cc10f62f04dc55e6442c1ce592270",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/adv748x/adv748x-hdmi.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mutex.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-dv-timings.h>\n#include <media/v4l2-ioctl.h>\n\n#include <uapi/linux/v4l2-dv-timings.h>\n\n#include \"adv748x.h\"\n\n \n\n#define ADV748X_HDMI_MIN_WIDTH\t\t640\n#define ADV748X_HDMI_MAX_WIDTH\t\t1920\n#define ADV748X_HDMI_MIN_HEIGHT\t\t480\n#define ADV748X_HDMI_MAX_HEIGHT\t\t1200\n\n \n#define ADV748X_HDMI_MIN_PIXELCLOCK\t13000000\n \n#define ADV748X_HDMI_MAX_PIXELCLOCK\t162000000\n\nstatic const struct v4l2_dv_timings_cap adv748x_hdmi_timings_cap = {\n\t.type = V4L2_DV_BT_656_1120,\n\t \n\t.reserved = { 0 },\n\n\tV4L2_INIT_BT_TIMINGS(ADV748X_HDMI_MIN_WIDTH, ADV748X_HDMI_MAX_WIDTH,\n\t\t\t     ADV748X_HDMI_MIN_HEIGHT, ADV748X_HDMI_MAX_HEIGHT,\n\t\t\t     ADV748X_HDMI_MIN_PIXELCLOCK,\n\t\t\t     ADV748X_HDMI_MAX_PIXELCLOCK,\n\t\t\t     V4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_DMT,\n\t\t\t     V4L2_DV_BT_CAP_PROGRESSIVE)\n};\n\nstruct adv748x_hdmi_video_standards {\n\tstruct v4l2_dv_timings timings;\n\tu8 vid_std;\n\tu8 v_freq;\n};\n\nstatic const struct adv748x_hdmi_video_standards\nadv748x_hdmi_video_standards[] = {\n\t{ V4L2_DV_BT_CEA_720X480P59_94, 0x4a, 0x00 },\n\t{ V4L2_DV_BT_CEA_720X576P50, 0x4b, 0x00 },\n\t{ V4L2_DV_BT_CEA_1280X720P60, 0x53, 0x00 },\n\t{ V4L2_DV_BT_CEA_1280X720P50, 0x53, 0x01 },\n\t{ V4L2_DV_BT_CEA_1280X720P30, 0x53, 0x02 },\n\t{ V4L2_DV_BT_CEA_1280X720P25, 0x53, 0x03 },\n\t{ V4L2_DV_BT_CEA_1280X720P24, 0x53, 0x04 },\n\t{ V4L2_DV_BT_CEA_1920X1080P60, 0x5e, 0x00 },\n\t{ V4L2_DV_BT_CEA_1920X1080P50, 0x5e, 0x01 },\n\t{ V4L2_DV_BT_CEA_1920X1080P30, 0x5e, 0x02 },\n\t{ V4L2_DV_BT_CEA_1920X1080P25, 0x5e, 0x03 },\n\t{ V4L2_DV_BT_CEA_1920X1080P24, 0x5e, 0x04 },\n\t \n\t{ V4L2_DV_BT_DMT_800X600P56, 0x80, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P60, 0x81, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P72, 0x82, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P75, 0x83, 0x00 },\n\t{ V4L2_DV_BT_DMT_800X600P85, 0x84, 0x00 },\n\t \n\t{ V4L2_DV_BT_DMT_1280X1024P60, 0x85, 0x00 },\n\t{ V4L2_DV_BT_DMT_1280X1024P75, 0x86, 0x00 },\n\t \n\t{ V4L2_DV_BT_DMT_640X480P60, 0x88, 0x00 },\n\t{ V4L2_DV_BT_DMT_640X480P72, 0x89, 0x00 },\n\t{ V4L2_DV_BT_DMT_640X480P75, 0x8a, 0x00 },\n\t{ V4L2_DV_BT_DMT_640X480P85, 0x8b, 0x00 },\n\t \n\t{ V4L2_DV_BT_DMT_1024X768P60, 0x8c, 0x00 },\n\t{ V4L2_DV_BT_DMT_1024X768P70, 0x8d, 0x00 },\n\t{ V4L2_DV_BT_DMT_1024X768P75, 0x8e, 0x00 },\n\t{ V4L2_DV_BT_DMT_1024X768P85, 0x8f, 0x00 },\n\t \n\t{ V4L2_DV_BT_DMT_1600X1200P60, 0x96, 0x00 },\n};\n\nstatic void adv748x_hdmi_fill_format(struct adv748x_hdmi *hdmi,\n\t\t\t\t     struct v4l2_mbus_framefmt *fmt)\n{\n\tmemset(fmt, 0, sizeof(*fmt));\n\n\tfmt->code = MEDIA_BUS_FMT_RGB888_1X24;\n\tfmt->field = hdmi->timings.bt.interlaced ?\n\t\t\tV4L2_FIELD_ALTERNATE : V4L2_FIELD_NONE;\n\n\t \n\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n\n\tfmt->width = hdmi->timings.bt.width;\n\tfmt->height = hdmi->timings.bt.height;\n\n\tif (fmt->field == V4L2_FIELD_ALTERNATE)\n\t\tfmt->height /= 2;\n}\n\nstatic void adv748x_fill_optional_dv_timings(struct v4l2_dv_timings *timings)\n{\n\tv4l2_find_dv_timings_cap(timings, &adv748x_hdmi_timings_cap,\n\t\t\t\t 250000, NULL, NULL);\n}\n\nstatic bool adv748x_hdmi_has_signal(struct adv748x_state *state)\n{\n\tint val;\n\n\t \n\tval = hdmi_read(state, ADV748X_HDMI_LW1);\n\treturn (val & ADV748X_HDMI_LW1_VERT_FILTER) &&\n\t       (val & ADV748X_HDMI_LW1_DE_REGEN);\n}\n\nstatic int adv748x_hdmi_read_pixelclock(struct adv748x_state *state)\n{\n\tint a, b;\n\n\ta = hdmi_read(state, ADV748X_HDMI_TMDS_1);\n\tb = hdmi_read(state, ADV748X_HDMI_TMDS_2);\n\tif (a < 0 || b < 0)\n\t\treturn -ENODATA;\n\n\t \n\treturn ((a << 1) | (b >> 7)) * 1000000 + (b & 0x7f) * 1000000 / 128;\n}\n\n \nstatic void adv748x_hdmi_set_de_timings(struct adv748x_state *state, int shift)\n{\n\tu8 high, low;\n\n\t \n\thigh = ADV748X_CP_DE_POS_HIGH_SET;\n\thigh |= (shift & 0x300) >> 8;\n\tlow = shift & 0xff;\n\n\t \n\tcp_write(state, ADV748X_CP_DE_POS_HIGH, high);\n\tcp_write(state, ADV748X_CP_DE_POS_END_LOW, low);\n\n\thigh |= (shift & 0x300) >> 6;\n\n\tcp_write(state, ADV748X_CP_DE_POS_HIGH, high);\n\tcp_write(state, ADV748X_CP_DE_POS_START_LOW, low);\n}\n\nstatic int adv748x_hdmi_set_video_timings(struct adv748x_state *state,\n\t\t\t\t\t  const struct v4l2_dv_timings *timings)\n{\n\tconst struct adv748x_hdmi_video_standards *stds =\n\t\tadv748x_hdmi_video_standards;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(adv748x_hdmi_video_standards); i++) {\n\t\tif (v4l2_match_dv_timings(timings, &stds[i].timings, 250000,\n\t\t\t\t\t  false))\n\t\t\tbreak;\n\t}\n\n\tif (i >= ARRAY_SIZE(adv748x_hdmi_video_standards))\n\t\treturn -EINVAL;\n\n\t \n\tswitch (stds[i].vid_std) {\n\tcase 0x53:  \n\t\tadv748x_hdmi_set_de_timings(state, -40);\n\t\tbreak;\n\tcase 0x54:  \n\tcase 0x5e:  \n\t\tadv748x_hdmi_set_de_timings(state, -44);\n\t\tbreak;\n\tdefault:\n\t\tadv748x_hdmi_set_de_timings(state, 0);\n\t\tbreak;\n\t}\n\n\tio_write(state, ADV748X_IO_VID_STD, stds[i].vid_std);\n\tio_clrset(state, ADV748X_IO_DATAPATH, ADV748X_IO_DATAPATH_VFREQ_M,\n\t\t  stds[i].v_freq << ADV748X_IO_DATAPATH_VFREQ_SHIFT);\n\n\treturn 0;\n}\n\n \n\nstatic int adv748x_hdmi_s_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_dv_timings *timings)\n{\n\tstruct adv748x_hdmi *hdmi = adv748x_sd_to_hdmi(sd);\n\tstruct adv748x_state *state = adv748x_hdmi_to_state(hdmi);\n\tint ret;\n\n\tif (!timings)\n\t\treturn -EINVAL;\n\n\tif (v4l2_match_dv_timings(&hdmi->timings, timings, 0, false))\n\t\treturn 0;\n\n\tif (!v4l2_valid_dv_timings(timings, &adv748x_hdmi_timings_cap,\n\t\t\t\t   NULL, NULL))\n\t\treturn -ERANGE;\n\n\tadv748x_fill_optional_dv_timings(timings);\n\n\tmutex_lock(&state->mutex);\n\n\tret = adv748x_hdmi_set_video_timings(state, timings);\n\tif (ret)\n\t\tgoto error;\n\n\thdmi->timings = *timings;\n\n\tcp_clrset(state, ADV748X_CP_VID_ADJ_2, ADV748X_CP_VID_ADJ_2_INTERLACED,\n\t\t  timings->bt.interlaced ?\n\t\t\t\t  ADV748X_CP_VID_ADJ_2_INTERLACED : 0);\n\n\tmutex_unlock(&state->mutex);\n\n\treturn 0;\n\nerror:\n\tmutex_unlock(&state->mutex);\n\treturn ret;\n}\n\nstatic int adv748x_hdmi_g_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_dv_timings *timings)\n{\n\tstruct adv748x_hdmi *hdmi = adv748x_sd_to_hdmi(sd);\n\tstruct adv748x_state *state = adv748x_hdmi_to_state(hdmi);\n\n\tmutex_lock(&state->mutex);\n\n\t*timings = hdmi->timings;\n\n\tmutex_unlock(&state->mutex);\n\n\treturn 0;\n}\n\nstatic int adv748x_hdmi_query_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\t\t struct v4l2_dv_timings *timings)\n{\n\tstruct adv748x_hdmi *hdmi = adv748x_sd_to_hdmi(sd);\n\tstruct adv748x_state *state = adv748x_hdmi_to_state(hdmi);\n\tstruct v4l2_bt_timings *bt = &timings->bt;\n\tint pixelclock;\n\tint polarity;\n\n\tif (!timings)\n\t\treturn -EINVAL;\n\n\tmemset(timings, 0, sizeof(struct v4l2_dv_timings));\n\n\t \n\tif (cp_read(state, ADV748X_CP_PAT_GEN) & ADV748X_CP_PAT_GEN_EN) {\n\t\t*timings = hdmi->timings;\n\t\treturn 0;\n\t}\n\n\tif (!adv748x_hdmi_has_signal(state))\n\t\treturn -ENOLINK;\n\n\tpixelclock = adv748x_hdmi_read_pixelclock(state);\n\tif (pixelclock < 0)\n\t\treturn -ENODATA;\n\n\ttimings->type = V4L2_DV_BT_656_1120;\n\n\tbt->pixelclock = pixelclock;\n\tbt->interlaced = hdmi_read(state, ADV748X_HDMI_F1H1) &\n\t\t\t\tADV748X_HDMI_F1H1_INTERLACED ?\n\t\t\t\tV4L2_DV_INTERLACED : V4L2_DV_PROGRESSIVE;\n\tbt->width = hdmi_read16(state, ADV748X_HDMI_LW1,\n\t\t\t\tADV748X_HDMI_LW1_WIDTH_MASK);\n\tbt->height = hdmi_read16(state, ADV748X_HDMI_F0H1,\n\t\t\t\t ADV748X_HDMI_F0H1_HEIGHT_MASK);\n\tbt->hfrontporch = hdmi_read16(state, ADV748X_HDMI_HFRONT_PORCH,\n\t\t\t\t      ADV748X_HDMI_HFRONT_PORCH_MASK);\n\tbt->hsync = hdmi_read16(state, ADV748X_HDMI_HSYNC_WIDTH,\n\t\t\t\tADV748X_HDMI_HSYNC_WIDTH_MASK);\n\tbt->hbackporch = hdmi_read16(state, ADV748X_HDMI_HBACK_PORCH,\n\t\t\t\t     ADV748X_HDMI_HBACK_PORCH_MASK);\n\tbt->vfrontporch = hdmi_read16(state, ADV748X_HDMI_VFRONT_PORCH,\n\t\t\t\t      ADV748X_HDMI_VFRONT_PORCH_MASK) / 2;\n\tbt->vsync = hdmi_read16(state, ADV748X_HDMI_VSYNC_WIDTH,\n\t\t\t\tADV748X_HDMI_VSYNC_WIDTH_MASK) / 2;\n\tbt->vbackporch = hdmi_read16(state, ADV748X_HDMI_VBACK_PORCH,\n\t\t\t\t     ADV748X_HDMI_VBACK_PORCH_MASK) / 2;\n\n\tpolarity = hdmi_read(state, 0x05);\n\tbt->polarities = (polarity & BIT(4) ? V4L2_DV_VSYNC_POS_POL : 0) |\n\t\t(polarity & BIT(5) ? V4L2_DV_HSYNC_POS_POL : 0);\n\n\tif (bt->interlaced == V4L2_DV_INTERLACED) {\n\t\tbt->height += hdmi_read16(state, 0x0b, 0x1fff);\n\t\tbt->il_vfrontporch = hdmi_read16(state, 0x2c, 0x3fff) / 2;\n\t\tbt->il_vsync = hdmi_read16(state, 0x30, 0x3fff) / 2;\n\t\tbt->il_vbackporch = hdmi_read16(state, 0x34, 0x3fff) / 2;\n\t}\n\n\tadv748x_fill_optional_dv_timings(timings);\n\n\t \n\thdmi->timings = *timings;\n\n\treturn 0;\n}\n\nstatic int adv748x_hdmi_g_input_status(struct v4l2_subdev *sd, u32 *status)\n{\n\tstruct adv748x_hdmi *hdmi = adv748x_sd_to_hdmi(sd);\n\tstruct adv748x_state *state = adv748x_hdmi_to_state(hdmi);\n\n\tmutex_lock(&state->mutex);\n\n\t*status = adv748x_hdmi_has_signal(state) ? 0 : V4L2_IN_ST_NO_SIGNAL;\n\n\tmutex_unlock(&state->mutex);\n\n\treturn 0;\n}\n\nstatic int adv748x_hdmi_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct adv748x_hdmi *hdmi = adv748x_sd_to_hdmi(sd);\n\tstruct adv748x_state *state = adv748x_hdmi_to_state(hdmi);\n\tint ret;\n\n\tmutex_lock(&state->mutex);\n\n\tret = adv748x_tx_power(hdmi->tx, enable);\n\tif (ret)\n\t\tgoto done;\n\n\tif (adv748x_hdmi_has_signal(state))\n\t\tadv_dbg(state, \"Detected HDMI signal\\n\");\n\telse\n\t\tadv_dbg(state, \"Couldn't detect HDMI video signal\\n\");\n\ndone:\n\tmutex_unlock(&state->mutex);\n\treturn ret;\n}\n\nstatic int adv748x_hdmi_g_pixelaspect(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_fract *aspect)\n{\n\taspect->numerator = 1;\n\taspect->denominator = 1;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops adv748x_video_ops_hdmi = {\n\t.s_dv_timings = adv748x_hdmi_s_dv_timings,\n\t.g_dv_timings = adv748x_hdmi_g_dv_timings,\n\t.query_dv_timings = adv748x_hdmi_query_dv_timings,\n\t.g_input_status = adv748x_hdmi_g_input_status,\n\t.s_stream = adv748x_hdmi_s_stream,\n\t.g_pixelaspect = adv748x_hdmi_g_pixelaspect,\n};\n\n \n\nstatic int adv748x_hdmi_propagate_pixelrate(struct adv748x_hdmi *hdmi)\n{\n\tstruct v4l2_subdev *tx;\n\tstruct v4l2_dv_timings timings;\n\n\ttx = adv748x_get_remote_sd(&hdmi->pads[ADV748X_HDMI_SOURCE]);\n\tif (!tx)\n\t\treturn -ENOLINK;\n\n\tadv748x_hdmi_query_dv_timings(&hdmi->sd, &timings);\n\n\treturn adv748x_csi2_set_pixelrate(tx, timings.bt.pixelclock);\n}\n\nstatic int adv748x_hdmi_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index != 0)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_RGB888_1X24;\n\n\treturn 0;\n}\n\nstatic int adv748x_hdmi_get_format(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_format *sdformat)\n{\n\tstruct adv748x_hdmi *hdmi = adv748x_sd_to_hdmi(sd);\n\tstruct v4l2_mbus_framefmt *mbusformat;\n\n\tif (sdformat->pad != ADV748X_HDMI_SOURCE)\n\t\treturn -EINVAL;\n\n\tif (sdformat->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tmbusformat = v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t\t\tsdformat->pad);\n\t\tsdformat->format = *mbusformat;\n\t} else {\n\t\tadv748x_hdmi_fill_format(hdmi, &sdformat->format);\n\t\tadv748x_hdmi_propagate_pixelrate(hdmi);\n\t}\n\n\treturn 0;\n}\n\nstatic int adv748x_hdmi_set_format(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_format *sdformat)\n{\n\tstruct v4l2_mbus_framefmt *mbusformat;\n\n\tif (sdformat->pad != ADV748X_HDMI_SOURCE)\n\t\treturn -EINVAL;\n\n\tif (sdformat->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn adv748x_hdmi_get_format(sd, sd_state, sdformat);\n\n\tmbusformat = v4l2_subdev_get_try_format(sd, sd_state, sdformat->pad);\n\t*mbusformat = sdformat->format;\n\n\treturn 0;\n}\n\nstatic int adv748x_hdmi_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)\n{\n\tstruct adv748x_hdmi *hdmi = adv748x_sd_to_hdmi(sd);\n\n\tmemset(edid->reserved, 0, sizeof(edid->reserved));\n\n\tif (!hdmi->edid.present)\n\t\treturn -ENODATA;\n\n\tif (edid->start_block == 0 && edid->blocks == 0) {\n\t\tedid->blocks = hdmi->edid.blocks;\n\t\treturn 0;\n\t}\n\n\tif (edid->start_block >= hdmi->edid.blocks)\n\t\treturn -EINVAL;\n\n\tif (edid->start_block + edid->blocks > hdmi->edid.blocks)\n\t\tedid->blocks = hdmi->edid.blocks - edid->start_block;\n\n\tmemcpy(edid->edid, hdmi->edid.edid + edid->start_block * 128,\n\t\t\tedid->blocks * 128);\n\n\treturn 0;\n}\n\nstatic inline int adv748x_hdmi_edid_write_block(struct adv748x_hdmi *hdmi,\n\t\t\t\t\tunsigned int total_len, const u8 *val)\n{\n\tstruct adv748x_state *state = adv748x_hdmi_to_state(hdmi);\n\tint err = 0;\n\tint i = 0;\n\tint len = 0;\n\n\tadv_dbg(state, \"%s: write EDID block (%d byte)\\n\",\n\t\t\t\t__func__, total_len);\n\n\twhile (!err && i < total_len) {\n\t\tlen = (total_len - i) > I2C_SMBUS_BLOCK_MAX ?\n\t\t\t\tI2C_SMBUS_BLOCK_MAX :\n\t\t\t\t(total_len - i);\n\n\t\terr = adv748x_write_block(state, ADV748X_PAGE_EDID,\n\t\t\t\ti, val + i, len);\n\t\ti += len;\n\t}\n\n\treturn err;\n}\n\nstatic int adv748x_hdmi_set_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)\n{\n\tstruct adv748x_hdmi *hdmi = adv748x_sd_to_hdmi(sd);\n\tstruct adv748x_state *state = adv748x_hdmi_to_state(hdmi);\n\tint err;\n\n\tmemset(edid->reserved, 0, sizeof(edid->reserved));\n\n\tif (edid->start_block != 0)\n\t\treturn -EINVAL;\n\n\tif (edid->blocks == 0) {\n\t\thdmi->edid.blocks = 0;\n\t\thdmi->edid.present = 0;\n\n\t\t \n\t\thdmi->aspect_ratio.numerator = 16;\n\t\thdmi->aspect_ratio.denominator = 9;\n\n\t\t \n\t\trepeater_write(state, ADV748X_REPEATER_EDID_SZ,\n\t\t\t       edid->blocks << ADV748X_REPEATER_EDID_SZ_SHIFT);\n\n\t\trepeater_write(state, ADV748X_REPEATER_EDID_CTL, 0);\n\n\t\treturn 0;\n\t}\n\n\tif (edid->blocks > 4) {\n\t\tedid->blocks = 4;\n\t\treturn -E2BIG;\n\t}\n\n\tmemcpy(hdmi->edid.edid, edid->edid, 128 * edid->blocks);\n\thdmi->edid.blocks = edid->blocks;\n\thdmi->edid.present = true;\n\n\thdmi->aspect_ratio = v4l2_calc_aspect_ratio(edid->edid[0x15],\n\t\t\tedid->edid[0x16]);\n\n\terr = adv748x_hdmi_edid_write_block(hdmi, 128 * edid->blocks,\n\t\t\thdmi->edid.edid);\n\tif (err < 0) {\n\t\tv4l2_err(sd, \"error %d writing edid pad %d\\n\", err, edid->pad);\n\t\treturn err;\n\t}\n\n\trepeater_write(state, ADV748X_REPEATER_EDID_SZ,\n\t\t       edid->blocks << ADV748X_REPEATER_EDID_SZ_SHIFT);\n\n\trepeater_write(state, ADV748X_REPEATER_EDID_CTL,\n\t\t       ADV748X_REPEATER_EDID_CTL_EN);\n\n\treturn 0;\n}\n\nstatic bool adv748x_hdmi_check_dv_timings(const struct v4l2_dv_timings *timings,\n\t\t\t\t\t  void *hdl)\n{\n\tconst struct adv748x_hdmi_video_standards *stds =\n\t\tadv748x_hdmi_video_standards;\n\tunsigned int i;\n\n\tfor (i = 0; stds[i].timings.bt.width; i++)\n\t\tif (v4l2_match_dv_timings(timings, &stds[i].timings, 0, false))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int adv748x_hdmi_enum_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\t\tstruct v4l2_enum_dv_timings *timings)\n{\n\treturn v4l2_enum_dv_timings_cap(timings, &adv748x_hdmi_timings_cap,\n\t\t\t\t\tadv748x_hdmi_check_dv_timings, NULL);\n}\n\nstatic int adv748x_hdmi_dv_timings_cap(struct v4l2_subdev *sd,\n\t\t\t\t       struct v4l2_dv_timings_cap *cap)\n{\n\t*cap = adv748x_hdmi_timings_cap;\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops adv748x_pad_ops_hdmi = {\n\t.enum_mbus_code = adv748x_hdmi_enum_mbus_code,\n\t.set_fmt = adv748x_hdmi_set_format,\n\t.get_fmt = adv748x_hdmi_get_format,\n\t.get_edid = adv748x_hdmi_get_edid,\n\t.set_edid = adv748x_hdmi_set_edid,\n\t.dv_timings_cap = adv748x_hdmi_dv_timings_cap,\n\t.enum_dv_timings = adv748x_hdmi_enum_dv_timings,\n};\n\n \n\nstatic const struct v4l2_subdev_ops adv748x_ops_hdmi = {\n\t.video = &adv748x_video_ops_hdmi,\n\t.pad = &adv748x_pad_ops_hdmi,\n};\n\n \n\nstatic const char * const hdmi_ctrl_patgen_menu[] = {\n\t\"Disabled\",\n\t\"Solid Color\",\n\t\"Color Bars\",\n\t\"Ramp Grey\",\n\t\"Ramp Blue\",\n\t\"Ramp Red\",\n\t\"Checkered\"\n};\n\nstatic int adv748x_hdmi_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct adv748x_hdmi *hdmi = adv748x_ctrl_to_hdmi(ctrl);\n\tstruct adv748x_state *state = adv748x_hdmi_to_state(hdmi);\n\tint ret;\n\tu8 pattern;\n\n\t \n\tret = cp_clrset(state, ADV748X_CP_VID_ADJ,\n\t\t\tADV748X_CP_VID_ADJ_ENABLE,\n\t\t\tADV748X_CP_VID_ADJ_ENABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tret = cp_write(state, ADV748X_CP_BRI, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\tret = cp_write(state, ADV748X_CP_HUE, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tret = cp_write(state, ADV748X_CP_CON, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tret = cp_write(state, ADV748X_CP_SAT, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tpattern = ctrl->val;\n\n\t\t \n\t\tif (pattern) {\n\t\t\tpattern--;\n\t\t\tpattern |= ADV748X_CP_PAT_GEN_EN;\n\t\t}\n\n\t\tret = cp_write(state, ADV748X_CP_PAT_GEN, pattern);\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops adv748x_hdmi_ctrl_ops = {\n\t.s_ctrl = adv748x_hdmi_s_ctrl,\n};\n\nstatic int adv748x_hdmi_init_controls(struct adv748x_hdmi *hdmi)\n{\n\tstruct adv748x_state *state = adv748x_hdmi_to_state(hdmi);\n\n\tv4l2_ctrl_handler_init(&hdmi->ctrl_hdl, 5);\n\n\t \n\thdmi->ctrl_hdl.lock = &state->mutex;\n\n\tv4l2_ctrl_new_std(&hdmi->ctrl_hdl, &adv748x_hdmi_ctrl_ops,\n\t\t\t  V4L2_CID_BRIGHTNESS, ADV748X_CP_BRI_MIN,\n\t\t\t  ADV748X_CP_BRI_MAX, 1, ADV748X_CP_BRI_DEF);\n\tv4l2_ctrl_new_std(&hdmi->ctrl_hdl, &adv748x_hdmi_ctrl_ops,\n\t\t\t  V4L2_CID_CONTRAST, ADV748X_CP_CON_MIN,\n\t\t\t  ADV748X_CP_CON_MAX, 1, ADV748X_CP_CON_DEF);\n\tv4l2_ctrl_new_std(&hdmi->ctrl_hdl, &adv748x_hdmi_ctrl_ops,\n\t\t\t  V4L2_CID_SATURATION, ADV748X_CP_SAT_MIN,\n\t\t\t  ADV748X_CP_SAT_MAX, 1, ADV748X_CP_SAT_DEF);\n\tv4l2_ctrl_new_std(&hdmi->ctrl_hdl, &adv748x_hdmi_ctrl_ops,\n\t\t\t  V4L2_CID_HUE, ADV748X_CP_HUE_MIN,\n\t\t\t  ADV748X_CP_HUE_MAX, 1, ADV748X_CP_HUE_DEF);\n\n\t \n\n\tv4l2_ctrl_new_std_menu_items(&hdmi->ctrl_hdl, &adv748x_hdmi_ctrl_ops,\n\t\t\t\t     V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(hdmi_ctrl_patgen_menu) - 1,\n\t\t\t\t     0, 0, hdmi_ctrl_patgen_menu);\n\n\thdmi->sd.ctrl_handler = &hdmi->ctrl_hdl;\n\tif (hdmi->ctrl_hdl.error) {\n\t\tv4l2_ctrl_handler_free(&hdmi->ctrl_hdl);\n\t\treturn hdmi->ctrl_hdl.error;\n\t}\n\n\treturn v4l2_ctrl_handler_setup(&hdmi->ctrl_hdl);\n}\n\nint adv748x_hdmi_init(struct adv748x_hdmi *hdmi)\n{\n\tstruct adv748x_state *state = adv748x_hdmi_to_state(hdmi);\n\tstruct v4l2_dv_timings cea1280x720 = V4L2_DV_BT_CEA_1280X720P30;\n\tint ret;\n\n\tadv748x_hdmi_s_dv_timings(&hdmi->sd, &cea1280x720);\n\n\t \n\thdmi->aspect_ratio.numerator = 16;\n\thdmi->aspect_ratio.denominator = 9;\n\n\tadv748x_subdev_init(&hdmi->sd, state, &adv748x_ops_hdmi,\n\t\t\t    MEDIA_ENT_F_IO_DTV, \"hdmi\");\n\n\thdmi->pads[ADV748X_HDMI_SINK].flags = MEDIA_PAD_FL_SINK;\n\thdmi->pads[ADV748X_HDMI_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&hdmi->sd.entity,\n\t\t\t\t     ADV748X_HDMI_NR_PADS, hdmi->pads);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adv748x_hdmi_init_controls(hdmi);\n\tif (ret)\n\t\tgoto err_free_media;\n\n\treturn 0;\n\nerr_free_media:\n\tmedia_entity_cleanup(&hdmi->sd.entity);\n\n\treturn ret;\n}\n\nvoid adv748x_hdmi_cleanup(struct adv748x_hdmi *hdmi)\n{\n\tv4l2_device_unregister_subdev(&hdmi->sd);\n\tmedia_entity_cleanup(&hdmi->sd.entity);\n\tv4l2_ctrl_handler_free(&hdmi->ctrl_hdl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}