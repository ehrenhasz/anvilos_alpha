{
  "module_name": "ir-kbd-i2c.c",
  "hash_id": "cb3f0c6190f4a7dd3ace24179ade386b68855944a23c66302bdcde26a7ae78db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ir-kbd-i2c.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/workqueue.h>\n\n#include <media/rc-core.h>\n#include <media/i2c/ir-kbd-i2c.h>\n\n#define FLAG_TX\t\t1\n#define FLAG_HDPVR\t2\n\nstatic bool enable_hdpvr;\nmodule_param(enable_hdpvr, bool, 0644);\n\nstatic int get_key_haup_common(struct IR_i2c *ir, enum rc_proto *protocol,\n\t\t\t       u32 *scancode, u8 *ptoggle, int size)\n{\n\tunsigned char buf[6];\n\tint start, range, toggle, dev, code, ircode, vendor;\n\n\t \n\tif (size != i2c_master_recv(ir->c, buf, size))\n\t\treturn -EIO;\n\n\tif (buf[0] & 0x80) {\n\t\tint offset = (size == 6) ? 3 : 0;\n\n\t\t \n\t\tstart  = (buf[offset] >> 7) &    1;\n\t\trange  = (buf[offset] >> 6) &    1;\n\t\ttoggle = (buf[offset] >> 5) &    1;\n\t\tdev    =  buf[offset]       & 0x1f;\n\t\tcode   = (buf[offset+1] >> 2) & 0x3f;\n\n\t\t \n\t\tif (!start)\n\t\t\t \n\t\t\treturn 0;\n\n\t\t \n\t\tircode = (start << 12) | (toggle << 11) | (dev << 6) | code;\n\t\tif ((ircode & 0x1fff) == 0x1fff)\n\t\t\treturn 0;\n\n\t\tif (!range)\n\t\t\tcode += 64;\n\n\t\tdev_dbg(&ir->rc->dev,\n\t\t\t\"ir hauppauge (rc5): s%d r%d t%d dev=%d code=%d\\n\",\n\t\t\tstart, range, toggle, dev, code);\n\n\t\t*protocol = RC_PROTO_RC5;\n\t\t*scancode = RC_SCANCODE_RC5(dev, code);\n\t\t*ptoggle = toggle;\n\n\t\treturn 1;\n\t} else if (size == 6 && (buf[0] & 0x40)) {\n\t\tcode = buf[4];\n\t\tdev = buf[3];\n\t\tvendor = get_unaligned_be16(buf + 1);\n\n\t\tif (vendor == 0x800f) {\n\t\t\t*ptoggle = (dev & 0x80) != 0;\n\t\t\t*protocol = RC_PROTO_RC6_MCE;\n\t\t\tdev &= 0x7f;\n\t\t\tdev_dbg(&ir->rc->dev,\n\t\t\t\t\"ir hauppauge (rc6-mce): t%d vendor=%d dev=%d code=%d\\n\",\n\t\t\t\t*ptoggle, vendor, dev, code);\n\t\t} else {\n\t\t\t*ptoggle = 0;\n\t\t\t*protocol = RC_PROTO_RC6_6A_32;\n\t\t\tdev_dbg(&ir->rc->dev,\n\t\t\t\t\"ir hauppauge (rc6-6a-32): vendor=%d dev=%d code=%d\\n\",\n\t\t\t\tvendor, dev, code);\n\t\t}\n\n\t\t*scancode = RC_SCANCODE_RC6_6A(vendor, dev, code);\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_key_haup(struct IR_i2c *ir, enum rc_proto *protocol,\n\t\t\tu32 *scancode, u8 *toggle)\n{\n\treturn get_key_haup_common(ir, protocol, scancode, toggle, 3);\n}\n\nstatic int get_key_haup_xvr(struct IR_i2c *ir, enum rc_proto *protocol,\n\t\t\t    u32 *scancode, u8 *toggle)\n{\n\tint ret;\n\tunsigned char buf[1] = { 0 };\n\n\t \n\tret = i2c_master_send(ir->c, buf, 1);\n\tif (ret != 1)\n\t\treturn (ret < 0) ? ret : -EINVAL;\n\n\treturn get_key_haup_common(ir, protocol, scancode, toggle, 6);\n}\n\nstatic int get_key_pixelview(struct IR_i2c *ir, enum rc_proto *protocol,\n\t\t\t     u32 *scancode, u8 *toggle)\n{\n\tint rc;\n\tunsigned char b;\n\n\t \n\trc = i2c_master_recv(ir->c, &b, 1);\n\tif (rc != 1) {\n\t\tdev_dbg(&ir->rc->dev, \"read error\\n\");\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treturn -EIO;\n\t}\n\n\t*protocol = RC_PROTO_OTHER;\n\t*scancode = b;\n\t*toggle = 0;\n\treturn 1;\n}\n\nstatic int get_key_fusionhdtv(struct IR_i2c *ir, enum rc_proto *protocol,\n\t\t\t      u32 *scancode, u8 *toggle)\n{\n\tint rc;\n\tunsigned char buf[4];\n\n\t \n\trc = i2c_master_recv(ir->c, buf, 4);\n\tif (rc != 4) {\n\t\tdev_dbg(&ir->rc->dev, \"read error\\n\");\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treturn -EIO;\n\t}\n\n\tif (buf[0] != 0 || buf[1] != 0 || buf[2] != 0 || buf[3] != 0)\n\t\tdev_dbg(&ir->rc->dev, \"%s: %*ph\\n\", __func__, 4, buf);\n\n\t \n\tif(buf[0] != 0x1 ||  buf[1] != 0xfe)\n\t\treturn 0;\n\n\t*protocol = RC_PROTO_UNKNOWN;\n\t*scancode = buf[2];\n\t*toggle = 0;\n\treturn 1;\n}\n\nstatic int get_key_knc1(struct IR_i2c *ir, enum rc_proto *protocol,\n\t\t\tu32 *scancode, u8 *toggle)\n{\n\tint rc;\n\tunsigned char b;\n\n\t \n\trc = i2c_master_recv(ir->c, &b, 1);\n\tif (rc != 1) {\n\t\tdev_dbg(&ir->rc->dev, \"read error\\n\");\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treturn -EIO;\n\t}\n\n\t \n\n\tdev_dbg(&ir->rc->dev, \"key %02x\\n\", b);\n\n\tif (b == 0xff)\n\t\treturn 0;\n\n\tif (b == 0xfe)\n\t\t \n\t\treturn 1;\n\n\t*protocol = RC_PROTO_UNKNOWN;\n\t*scancode = b;\n\t*toggle = 0;\n\treturn 1;\n}\n\nstatic int get_key_geniatech(struct IR_i2c *ir, enum rc_proto *protocol,\n\t\t\t     u32 *scancode, u8 *toggle)\n{\n\tint i, rc;\n\tunsigned char b;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\trc = i2c_master_recv(ir->c, &b, 1);\n\t\tif (rc == 1)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t}\n\tif (rc != 1) {\n\t\tdev_dbg(&ir->rc->dev, \"read error\\n\");\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (ir->old == b)\n\t\treturn 0;\n\tir->old = b;\n\n\t \n\tb &= 0x7f;\n\tb = (b - 1) / 2;\n\n\tdev_dbg(&ir->rc->dev, \"key %02x\\n\", b);\n\n\t*protocol = RC_PROTO_RC5;\n\t*scancode = b;\n\t*toggle = ir->old >> 7;\n\treturn 1;\n}\n\nstatic int get_key_avermedia_cardbus(struct IR_i2c *ir, enum rc_proto *protocol,\n\t\t\t\t     u32 *scancode, u8 *toggle)\n{\n\tunsigned char subaddr, key, keygroup;\n\tstruct i2c_msg msg[] = { { .addr = ir->c->addr, .flags = 0,\n\t\t\t\t   .buf = &subaddr, .len = 1},\n\t\t\t\t { .addr = ir->c->addr, .flags = I2C_M_RD,\n\t\t\t\t  .buf = &key, .len = 1} };\n\tsubaddr = 0x0d;\n\tif (2 != i2c_transfer(ir->c->adapter, msg, 2)) {\n\t\tdev_dbg(&ir->rc->dev, \"read error\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (key == 0xff)\n\t\treturn 0;\n\n\tsubaddr = 0x0b;\n\tmsg[1].buf = &keygroup;\n\tif (2 != i2c_transfer(ir->c->adapter, msg, 2)) {\n\t\tdev_dbg(&ir->rc->dev, \"read error\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (keygroup == 0xff)\n\t\treturn 0;\n\n\tdev_dbg(&ir->rc->dev, \"read key 0x%02x/0x%02x\\n\", key, keygroup);\n\tif (keygroup < 2 || keygroup > 4) {\n\t\tdev_warn(&ir->rc->dev, \"warning: invalid key group 0x%02x for key 0x%02x\\n\",\n\t\t\t keygroup, key);\n\t}\n\tkey |= (keygroup & 1) << 6;\n\n\t*protocol = RC_PROTO_UNKNOWN;\n\t*scancode = key;\n\tif (ir->c->addr == 0x41)  \n\t\t*scancode |= keygroup << 8;\n\t*toggle = 0;\n\treturn 1;\n}\n\n \n\nstatic int ir_key_poll(struct IR_i2c *ir)\n{\n\tenum rc_proto protocol;\n\tu32 scancode;\n\tu8 toggle;\n\tint rc;\n\n\tdev_dbg(&ir->rc->dev, \"%s\\n\", __func__);\n\trc = ir->get_key(ir, &protocol, &scancode, &toggle);\n\tif (rc < 0) {\n\t\tdev_warn(&ir->rc->dev, \"error %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (rc) {\n\t\tdev_dbg(&ir->rc->dev, \"%s: proto = 0x%04x, scancode = 0x%08x\\n\",\n\t\t\t__func__, protocol, scancode);\n\t\trc_keydown(ir->rc, protocol, scancode, toggle);\n\t}\n\treturn 0;\n}\n\nstatic void ir_work(struct work_struct *work)\n{\n\tint rc;\n\tstruct IR_i2c *ir = container_of(work, struct IR_i2c, work.work);\n\n\t \n\tif (mutex_trylock(&ir->lock)) {\n\t\trc = ir_key_poll(ir);\n\t\tmutex_unlock(&ir->lock);\n\t\tif (rc == -ENODEV) {\n\t\t\trc_unregister_device(ir->rc);\n\t\t\tir->rc = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tschedule_delayed_work(&ir->work, msecs_to_jiffies(ir->polling_interval));\n}\n\nstatic int ir_open(struct rc_dev *dev)\n{\n\tstruct IR_i2c *ir = dev->priv;\n\n\tschedule_delayed_work(&ir->work, 0);\n\n\treturn 0;\n}\n\nstatic void ir_close(struct rc_dev *dev)\n{\n\tstruct IR_i2c *ir = dev->priv;\n\n\tcancel_delayed_work_sync(&ir->work);\n}\n\n \n#define XTAL_FREQ\t\t18432000\n\n#define ZILOG_SEND\t\t0x80\n#define ZILOG_UIR_END\t\t0x40\n#define ZILOG_INIT_END\t\t0x20\n#define ZILOG_LIR_END\t\t0x10\n\n#define ZILOG_STATUS_OK\t\t0x80\n#define ZILOG_STATUS_TX\t\t0x40\n#define ZILOG_STATUS_SET\t0x20\n\n \nstruct code_block {\n\tu8\tlength;\n\tu16\tpulse[7];\t \n\tu8\tcarrier_pulse;\n\tu8\tcarrier_space;\n\tu16\tspace[8];\t \n\tu8\tcodes[61];\n\tu8\tcsum[2];\n} __packed;\n\nstatic int send_data_block(struct IR_i2c *ir, int cmd,\n\t\t\t   struct code_block *code_block)\n{\n\tint i, j, ret;\n\tu8 buf[5], *p;\n\n\tp = &code_block->length;\n\tfor (i = 0; p < code_block->csum; i++)\n\t\tcode_block->csum[i & 1] ^= *p++;\n\n\tp = &code_block->length;\n\n\tfor (i = 0; i < sizeof(*code_block);) {\n\t\tint tosend = sizeof(*code_block) - i;\n\n\t\tif (tosend > 4)\n\t\t\ttosend = 4;\n\t\tbuf[0] = i + 1;\n\t\tfor (j = 0; j < tosend; ++j)\n\t\t\tbuf[1 + j] = p[i + j];\n\t\tdev_dbg(&ir->rc->dev, \"%*ph\", tosend + 1, buf);\n\t\tret = i2c_master_send(ir->tx_c, buf, tosend + 1);\n\t\tif (ret != tosend + 1) {\n\t\t\tdev_dbg(&ir->rc->dev,\n\t\t\t\t\"i2c_master_send failed with %d\\n\", ret);\n\t\t\treturn ret < 0 ? ret : -EIO;\n\t\t}\n\t\ti += tosend;\n\t}\n\n\tbuf[0] = 0;\n\tbuf[1] = cmd;\n\tret = i2c_master_send(ir->tx_c, buf, 2);\n\tif (ret != 2) {\n\t\tdev_err(&ir->rc->dev, \"i2c_master_send failed with %d\\n\", ret);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\tusleep_range(2000, 5000);\n\n\tret = i2c_master_send(ir->tx_c, buf, 1);\n\tif (ret != 1) {\n\t\tdev_err(&ir->rc->dev, \"i2c_master_send failed with %d\\n\", ret);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int zilog_init(struct IR_i2c *ir)\n{\n\tstruct code_block code_block = { .length = sizeof(code_block) };\n\tu8 buf[4];\n\tint ret;\n\n\tput_unaligned_be16(0x1000, &code_block.pulse[3]);\n\n\tret = send_data_block(ir, ZILOG_INIT_END, &code_block);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i2c_master_recv(ir->tx_c, buf, 4);\n\tif (ret != 4) {\n\t\tdev_err(&ir->c->dev, \"failed to retrieve firmware version: %d\\n\",\n\t\t\tret);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\tdev_info(&ir->c->dev, \"Zilog/Hauppauge IR blaster firmware version %d.%d.%d\\n\",\n\t\t buf[1], buf[2], buf[3]);\n\n\treturn 0;\n}\n\n \nstatic void copy_codes(u8 *dst, u8 *src, unsigned int count)\n{\n\tu8 c, last = 0xff;\n\n\twhile (count--) {\n\t\tc = *src++;\n\t\tif ((c & 0xf0) == last) {\n\t\t\t*dst++ = 0x70 | (c & 0xf);\n\t\t} else {\n\t\t\t*dst++ = c;\n\t\t\tlast = c & 0xf0;\n\t\t}\n\t}\n}\n\n \nstatic int cmp_no_trail(u8 *a, u8 *b, unsigned int count)\n{\n\twhile (--count) {\n\t\tif (*a++ != *b++)\n\t\t\treturn 1;\n\t}\n\n\treturn (*a & 0xf0) - (*b & 0xf0);\n}\n\nstatic int find_slot(u16 *array, unsigned int size, u16 val)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (get_unaligned_be16(&array[i]) == val) {\n\t\t\treturn i;\n\t\t} else if (!array[i]) {\n\t\t\tput_unaligned_be16(val, &array[i]);\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nstatic int zilog_ir_format(struct rc_dev *rcdev, unsigned int *txbuf,\n\t\t\t   unsigned int count, struct code_block *code_block)\n{\n\tstruct IR_i2c *ir = rcdev->priv;\n\tint rep, i, l, p = 0, s, c = 0;\n\tbool repeating;\n\tu8 codes[174];\n\n\tcode_block->carrier_pulse = DIV_ROUND_CLOSEST(\n\t\t\tir->duty_cycle * XTAL_FREQ / 1000, ir->carrier);\n\tcode_block->carrier_space = DIV_ROUND_CLOSEST(\n\t\t\t(100 - ir->duty_cycle) * XTAL_FREQ / 1000, ir->carrier);\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (c >= ARRAY_SIZE(codes) - 1) {\n\t\t\tdev_warn(&rcdev->dev, \"IR too long, cannot transmit\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (txbuf[i] > 142220)\n\t\t\treturn -EINVAL;\n\n\t\tl = DIV_ROUND_CLOSEST((XTAL_FREQ / 1000) * txbuf[i], 40000);\n\n\t\tif (i & 1) {\n\t\t\ts = find_slot(code_block->space,\n\t\t\t\t      ARRAY_SIZE(code_block->space), l);\n\t\t\tif (s == -1) {\n\t\t\t\tdev_warn(&rcdev->dev, \"Too many different lengths spaces, cannot transmit\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t \n\t\t\tcodes[c++] = (p << 4) | s;\n\t\t} else {\n\t\t\tp = find_slot(code_block->pulse,\n\t\t\t\t      ARRAY_SIZE(code_block->pulse), l);\n\t\t\tif (p == -1) {\n\t\t\t\tdev_warn(&rcdev->dev, \"Too many different lengths pulses, cannot transmit\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\ts = 0;\n\tfor (i = 1; i < ARRAY_SIZE(code_block->space); i++) {\n\t\tu16 d = get_unaligned_be16(&code_block->space[i]);\n\n\t\tif (get_unaligned_be16(&code_block->space[s]) > d)\n\t\t\ts = i;\n\t}\n\n\tcodes[c++] = (p << 4) | s;\n\n\tdev_dbg(&rcdev->dev, \"generated %d codes\\n\", c);\n\n\t \n\trepeating = false;\n\n\tfor (rep = c / 3; rep >= 1; rep--) {\n\t\tif (!memcmp(&codes[c - rep * 3], &codes[c - rep * 2], rep) &&\n\t\t    !cmp_no_trail(&codes[c - rep], &codes[c - rep * 2], rep)) {\n\t\t\trepeating = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (repeating) {\n\t\t \n\t\tint leading = c - rep * 3;\n\n\t\tif (leading >= ARRAY_SIZE(code_block->codes) - 3 - rep) {\n\t\t\tdev_warn(&rcdev->dev, \"IR too long, cannot transmit\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev_dbg(&rcdev->dev, \"found trailing %d repeat\\n\", rep);\n\t\tcopy_codes(code_block->codes, codes, leading);\n\t\tcode_block->codes[leading] = 0x82;\n\t\tcopy_codes(code_block->codes + leading + 1, codes + leading,\n\t\t\t   rep);\n\t\tc = leading + 1 + rep;\n\t\tcode_block->codes[c++] = 0xc0;\n\t} else {\n\t\tif (c >= ARRAY_SIZE(code_block->codes) - 3) {\n\t\t\tdev_warn(&rcdev->dev, \"IR too long, cannot transmit\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev_dbg(&rcdev->dev, \"found no trailing repeat\\n\");\n\t\tcode_block->codes[0] = 0x82;\n\t\tcopy_codes(code_block->codes + 1, codes, c);\n\t\tc++;\n\t\tcode_block->codes[c++] = 0xc4;\n\t}\n\n\twhile (c < ARRAY_SIZE(code_block->codes))\n\t\tcode_block->codes[c++] = 0x83;\n\n\treturn 0;\n}\n\nstatic int zilog_tx(struct rc_dev *rcdev, unsigned int *txbuf,\n\t\t    unsigned int count)\n{\n\tstruct IR_i2c *ir = rcdev->priv;\n\tstruct code_block code_block = { .length = sizeof(code_block) };\n\tu8 buf[2];\n\tint ret, i;\n\n\tret = zilog_ir_format(rcdev, txbuf, count, &code_block);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mutex_lock_interruptible(&ir->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tret = send_data_block(ir, ZILOG_UIR_END, &code_block);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = i2c_master_recv(ir->tx_c, buf, 1);\n\tif (ret != 1) {\n\t\tdev_err(&ir->rc->dev, \"i2c_master_recv failed with %d\\n\", ret);\n\t\tgoto out_unlock;\n\t}\n\n\tdev_dbg(&ir->rc->dev, \"code set status: %02x\\n\", buf[0]);\n\n\tif (buf[0] != (ZILOG_STATUS_OK | ZILOG_STATUS_SET)) {\n\t\tdev_err(&ir->rc->dev, \"unexpected IR TX response %02x\\n\",\n\t\t\tbuf[0]);\n\t\tret = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\tbuf[0] = 0x00;\n\tbuf[1] = ZILOG_SEND;\n\n\tret = i2c_master_send(ir->tx_c, buf, 2);\n\tif (ret != 2) {\n\t\tdev_err(&ir->rc->dev, \"i2c_master_send failed with %d\\n\", ret);\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\tdev_dbg(&ir->rc->dev, \"send command sent\\n\");\n\n\t \n\tfor (i = 0; i < 20; ++i) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(msecs_to_jiffies(50));\n\t\tret = i2c_master_send(ir->tx_c, buf, 1);\n\t\tif (ret == 1)\n\t\t\tbreak;\n\t\tdev_dbg(&ir->rc->dev,\n\t\t\t\"NAK expected: i2c_master_send failed with %d (try %d)\\n\",\n\t\t\tret, i + 1);\n\t}\n\n\tif (ret != 1) {\n\t\tdev_err(&ir->rc->dev,\n\t\t\t\"IR TX chip never got ready: last i2c_master_send failed with %d\\n\",\n\t\t\tret);\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\tret = i2c_master_recv(ir->tx_c, buf, 1);\n\tif (ret != 1) {\n\t\tdev_err(&ir->rc->dev, \"i2c_master_recv failed with %d\\n\", ret);\n\t\tret = -EIO;\n\t\tgoto out_unlock;\n\t} else if (buf[0] != ZILOG_STATUS_OK) {\n\t\tdev_err(&ir->rc->dev, \"unexpected IR TX response #2: %02x\\n\",\n\t\t\tbuf[0]);\n\t\tret = -EIO;\n\t\tgoto out_unlock;\n\t}\n\tdev_dbg(&ir->rc->dev, \"transmit complete\\n\");\n\n\t \n\tret = count;\nout_unlock:\n\tmutex_unlock(&ir->lock);\n\n\treturn ret;\n}\n\nstatic int zilog_tx_carrier(struct rc_dev *dev, u32 carrier)\n{\n\tstruct IR_i2c *ir = dev->priv;\n\n\tif (carrier > 500000 || carrier < 20000)\n\t\treturn -EINVAL;\n\n\tir->carrier = carrier;\n\n\treturn 0;\n}\n\nstatic int zilog_tx_duty_cycle(struct rc_dev *dev, u32 duty_cycle)\n{\n\tstruct IR_i2c *ir = dev->priv;\n\n\tir->duty_cycle = duty_cycle;\n\n\treturn 0;\n}\n\nstatic int ir_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tchar *ir_codes = NULL;\n\tconst char *name = NULL;\n\tu64 rc_proto = RC_PROTO_BIT_UNKNOWN;\n\tstruct IR_i2c *ir;\n\tstruct rc_dev *rc = NULL;\n\tstruct i2c_adapter *adap = client->adapter;\n\tunsigned short addr = client->addr;\n\tbool probe_tx = (id->driver_data & FLAG_TX) != 0;\n\tint err;\n\n\tif ((id->driver_data & FLAG_HDPVR) && !enable_hdpvr) {\n\t\tdev_err(&client->dev, \"IR for HDPVR is known to cause problems during recording, use enable_hdpvr modparam to enable\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tir = devm_kzalloc(&client->dev, sizeof(*ir), GFP_KERNEL);\n\tif (!ir)\n\t\treturn -ENOMEM;\n\n\tir->c = client;\n\tir->polling_interval = DEFAULT_POLLING_INTERVAL;\n\ti2c_set_clientdata(client, ir);\n\n\tswitch(addr) {\n\tcase 0x64:\n\t\tname        = \"Pixelview\";\n\t\tir->get_key = get_key_pixelview;\n\t\trc_proto    = RC_PROTO_BIT_OTHER;\n\t\tir_codes    = RC_MAP_EMPTY;\n\t\tbreak;\n\tcase 0x18:\n\tcase 0x1f:\n\tcase 0x1a:\n\t\tname        = \"Hauppauge\";\n\t\tir->get_key = get_key_haup;\n\t\trc_proto    = RC_PROTO_BIT_RC5;\n\t\tir_codes    = RC_MAP_HAUPPAUGE;\n\t\tbreak;\n\tcase 0x30:\n\t\tname        = \"KNC One\";\n\t\tir->get_key = get_key_knc1;\n\t\trc_proto    = RC_PROTO_BIT_OTHER;\n\t\tir_codes    = RC_MAP_EMPTY;\n\t\tbreak;\n\tcase 0x33:\n\t\tname        = \"Geniatech\";\n\t\tir->get_key = get_key_geniatech;\n\t\trc_proto    = RC_PROTO_BIT_RC5;\n\t\tir_codes    = RC_MAP_TOTAL_MEDIA_IN_HAND_02;\n\t\tir->old     = 0xfc;\n\t\tbreak;\n\tcase 0x6b:\n\t\tname        = \"FusionHDTV\";\n\t\tir->get_key = get_key_fusionhdtv;\n\t\trc_proto    = RC_PROTO_BIT_UNKNOWN;\n\t\tir_codes    = RC_MAP_FUSIONHDTV_MCE;\n\t\tbreak;\n\tcase 0x40:\n\t\tname        = \"AVerMedia Cardbus remote\";\n\t\tir->get_key = get_key_avermedia_cardbus;\n\t\trc_proto    = RC_PROTO_BIT_OTHER;\n\t\tir_codes    = RC_MAP_AVERMEDIA_CARDBUS;\n\t\tbreak;\n\tcase 0x41:\n\t\tname        = \"AVerMedia EM78P153\";\n\t\tir->get_key = get_key_avermedia_cardbus;\n\t\trc_proto    = RC_PROTO_BIT_OTHER;\n\t\t \n\t\tir_codes    = RC_MAP_AVERMEDIA_M733A_RM_K6;\n\t\tbreak;\n\tcase 0x71:\n\t\tname        = \"Hauppauge/Zilog Z8\";\n\t\tir->get_key = get_key_haup_xvr;\n\t\trc_proto    = RC_PROTO_BIT_RC5 | RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t\t\tRC_PROTO_BIT_RC6_6A_32;\n\t\tir_codes    = RC_MAP_HAUPPAUGE;\n\t\tir->polling_interval = 125;\n\t\tprobe_tx = true;\n\t\tbreak;\n\t}\n\n\t \n\tif (client->dev.platform_data) {\n\t\tconst struct IR_i2c_init_data *init_data =\n\t\t\t\t\t\tclient->dev.platform_data;\n\n\t\tir_codes = init_data->ir_codes;\n\t\trc = init_data->rc_dev;\n\n\t\tname = init_data->name;\n\t\tif (init_data->type)\n\t\t\trc_proto = init_data->type;\n\n\t\tif (init_data->polling_interval)\n\t\t\tir->polling_interval = init_data->polling_interval;\n\n\t\tswitch (init_data->internal_get_key_func) {\n\t\tcase IR_KBD_GET_KEY_CUSTOM:\n\t\t\t \n\t\t\tir->get_key = init_data->get_key;\n\t\t\tbreak;\n\t\tcase IR_KBD_GET_KEY_PIXELVIEW:\n\t\t\tir->get_key = get_key_pixelview;\n\t\t\tbreak;\n\t\tcase IR_KBD_GET_KEY_HAUP:\n\t\t\tir->get_key = get_key_haup;\n\t\t\tbreak;\n\t\tcase IR_KBD_GET_KEY_KNC1:\n\t\t\tir->get_key = get_key_knc1;\n\t\t\tbreak;\n\t\tcase IR_KBD_GET_KEY_GENIATECH:\n\t\t\tir->get_key = get_key_geniatech;\n\t\t\tbreak;\n\t\tcase IR_KBD_GET_KEY_FUSIONHDTV:\n\t\t\tir->get_key = get_key_fusionhdtv;\n\t\t\tbreak;\n\t\tcase IR_KBD_GET_KEY_HAUP_XVR:\n\t\t\tir->get_key = get_key_haup_xvr;\n\t\t\tbreak;\n\t\tcase IR_KBD_GET_KEY_AVERMEDIA_CARDBUS:\n\t\t\tir->get_key = get_key_avermedia_cardbus;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!rc) {\n\t\t \n\t\trc = rc_allocate_device(RC_DRIVER_SCANCODE);\n\t\tif (!rc)\n\t\t\treturn -ENOMEM;\n\t}\n\tir->rc = rc;\n\n\t \n\tif (!name || !ir->get_key || !rc_proto || !ir_codes) {\n\t\tdev_warn(&client->dev, \"Unsupported device at address 0x%02x\\n\",\n\t\t\t addr);\n\t\terr = -ENODEV;\n\t\tgoto err_out_free;\n\t}\n\n\tir->ir_codes = ir_codes;\n\n\tsnprintf(ir->phys, sizeof(ir->phys), \"%s/%s\", dev_name(&adap->dev),\n\t\t dev_name(&client->dev));\n\n\t \n\trc->input_id.bustype = BUS_I2C;\n\trc->input_phys       = ir->phys;\n\trc->device_name\t     = name;\n\trc->dev.parent       = &client->dev;\n\trc->priv             = ir;\n\trc->open             = ir_open;\n\trc->close            = ir_close;\n\n\t \n\trc->map_name       = ir->ir_codes;\n\trc->allowed_protocols = rc_proto;\n\tif (!rc->driver_name)\n\t\trc->driver_name = KBUILD_MODNAME;\n\n\tmutex_init(&ir->lock);\n\n\tINIT_DELAYED_WORK(&ir->work, ir_work);\n\n\tif (probe_tx) {\n\t\tir->tx_c = i2c_new_dummy_device(client->adapter, 0x70);\n\t\tif (IS_ERR(ir->tx_c)) {\n\t\t\tdev_err(&client->dev, \"failed to setup tx i2c address\");\n\t\t\terr = PTR_ERR(ir->tx_c);\n\t\t\tgoto err_out_free;\n\t\t} else if (!zilog_init(ir)) {\n\t\t\tir->carrier = 38000;\n\t\t\tir->duty_cycle = 40;\n\t\t\trc->tx_ir = zilog_tx;\n\t\t\trc->s_tx_carrier = zilog_tx_carrier;\n\t\t\trc->s_tx_duty_cycle = zilog_tx_duty_cycle;\n\t\t}\n\t}\n\n\terr = rc_register_device(rc);\n\tif (err)\n\t\tgoto err_out_free;\n\n\treturn 0;\n\n err_out_free:\n\tif (!IS_ERR(ir->tx_c))\n\t\ti2c_unregister_device(ir->tx_c);\n\n\t \n\trc_free_device(rc);\n\treturn err;\n}\n\nstatic void ir_remove(struct i2c_client *client)\n{\n\tstruct IR_i2c *ir = i2c_get_clientdata(client);\n\n\tcancel_delayed_work_sync(&ir->work);\n\n\ti2c_unregister_device(ir->tx_c);\n\n\trc_unregister_device(ir->rc);\n}\n\nstatic const struct i2c_device_id ir_kbd_id[] = {\n\t \n\t{ \"ir_video\", 0 },\n\t \n\t{ \"ir_z8f0811_haup\", FLAG_TX },\n\t{ \"ir_z8f0811_hdpvr\", FLAG_TX | FLAG_HDPVR },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ir_kbd_id);\n\nstatic struct i2c_driver ir_kbd_driver = {\n\t.driver = {\n\t\t.name   = \"ir-kbd-i2c\",\n\t},\n\t.probe          = ir_probe,\n\t.remove         = ir_remove,\n\t.id_table       = ir_kbd_id,\n};\n\nmodule_i2c_driver(ir_kbd_driver);\n\n \n\nMODULE_AUTHOR(\"Gerd Knorr, Michal Kochanowicz, Christoph Bartelmus, Ulrich Mueller\");\nMODULE_DESCRIPTION(\"input driver for i2c IR remote controls\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}