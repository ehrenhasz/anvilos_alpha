{
  "module_name": "st-vgxy61.c",
  "hash_id": "5dffa40906bc4c3c37ab1bcd63b81152e08118f9ff6187cab26be674996c4cc8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/st-vgxy61.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/units.h>\n\n#include <asm/unaligned.h>\n\n#include <media/mipi-csi2.h>\n#include <media/v4l2-async.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n#define VGXY61_REG_8BIT(n)\t\t\t\t((1 << 16) | (n))\n#define VGXY61_REG_16BIT(n)\t\t\t\t((2 << 16) | (n))\n#define VGXY61_REG_32BIT(n)\t\t\t\t((4 << 16) | (n))\n#define VGXY61_REG_SIZE_SHIFT\t\t\t\t16\n#define VGXY61_REG_ADDR_MASK\t\t\t\t0xffff\n\n#define VGXY61_REG_MODEL_ID\t\t\t\tVGXY61_REG_16BIT(0x0000)\n#define VG5661_MODEL_ID\t\t\t\t\t0x5661\n#define VG5761_MODEL_ID\t\t\t\t\t0x5761\n#define VGXY61_REG_REVISION\t\t\t\tVGXY61_REG_16BIT(0x0002)\n#define VGXY61_REG_FWPATCH_REVISION\t\t\tVGXY61_REG_16BIT(0x0014)\n#define VGXY61_REG_FWPATCH_START_ADDR\t\t\tVGXY61_REG_8BIT(0x2000)\n#define VGXY61_REG_SYSTEM_FSM\t\t\t\tVGXY61_REG_8BIT(0x0020)\n#define VGXY61_SYSTEM_FSM_SW_STBY\t\t\t0x03\n#define VGXY61_SYSTEM_FSM_STREAMING\t\t\t0x04\n#define VGXY61_REG_NVM\t\t\t\t\tVGXY61_REG_8BIT(0x0023)\n#define VGXY61_NVM_OK\t\t\t\t\t0x04\n#define VGXY61_REG_STBY\t\t\t\t\tVGXY61_REG_8BIT(0x0201)\n#define VGXY61_STBY_NO_REQ\t\t\t\t0\n#define VGXY61_STBY_REQ_TMP_READ\t\t\tBIT(2)\n#define VGXY61_REG_STREAMING\t\t\t\tVGXY61_REG_8BIT(0x0202)\n#define VGXY61_STREAMING_NO_REQ\t\t\t\t0\n#define VGXY61_STREAMING_REQ_STOP\t\t\tBIT(0)\n#define VGXY61_STREAMING_REQ_START\t\t\tBIT(1)\n#define VGXY61_REG_EXT_CLOCK\t\t\t\tVGXY61_REG_32BIT(0x0220)\n#define VGXY61_REG_CLK_PLL_PREDIV\t\t\tVGXY61_REG_8BIT(0x0224)\n#define VGXY61_REG_CLK_SYS_PLL_MULT\t\t\tVGXY61_REG_8BIT(0x0225)\n#define VGXY61_REG_GPIO_0_CTRL\t\t\t\tVGXY61_REG_8BIT(0x0236)\n#define VGXY61_REG_GPIO_1_CTRL\t\t\t\tVGXY61_REG_8BIT(0x0237)\n#define VGXY61_REG_GPIO_2_CTRL\t\t\t\tVGXY61_REG_8BIT(0x0238)\n#define VGXY61_REG_GPIO_3_CTRL\t\t\t\tVGXY61_REG_8BIT(0x0239)\n#define VGXY61_REG_SIGNALS_POLARITY_CTRL\t\tVGXY61_REG_8BIT(0x023b)\n#define VGXY61_REG_LINE_LENGTH\t\t\t\tVGXY61_REG_16BIT(0x0300)\n#define VGXY61_REG_ORIENTATION\t\t\t\tVGXY61_REG_8BIT(0x0302)\n#define VGXY61_REG_VT_CTRL\t\t\t\tVGXY61_REG_8BIT(0x0304)\n#define VGXY61_REG_FORMAT_CTRL\t\t\t\tVGXY61_REG_8BIT(0x0305)\n#define VGXY61_REG_OIF_CTRL\t\t\t\tVGXY61_REG_16BIT(0x0306)\n#define VGXY61_REG_OIF_ROI0_CTRL\t\t\tVGXY61_REG_8BIT(0x030a)\n#define VGXY61_REG_ROI0_START_H\t\t\t\tVGXY61_REG_16BIT(0x0400)\n#define VGXY61_REG_ROI0_START_V\t\t\t\tVGXY61_REG_16BIT(0x0402)\n#define VGXY61_REG_ROI0_END_H\t\t\t\tVGXY61_REG_16BIT(0x0404)\n#define VGXY61_REG_ROI0_END_V\t\t\t\tVGXY61_REG_16BIT(0x0406)\n#define VGXY61_REG_PATGEN_CTRL\t\t\t\tVGXY61_REG_32BIT(0x0440)\n#define VGXY61_PATGEN_LONG_ENABLE\t\t\tBIT(16)\n#define VGXY61_PATGEN_SHORT_ENABLE\t\t\tBIT(0)\n#define VGXY61_PATGEN_LONG_TYPE_SHIFT\t\t\t18\n#define VGXY61_PATGEN_SHORT_TYPE_SHIFT\t\t\t4\n#define VGXY61_REG_FRAME_CONTENT_CTRL\t\t\tVGXY61_REG_8BIT(0x0478)\n#define VGXY61_REG_COARSE_EXPOSURE_LONG\t\t\tVGXY61_REG_16BIT(0x0500)\n#define VGXY61_REG_COARSE_EXPOSURE_SHORT\t\tVGXY61_REG_16BIT(0x0504)\n#define VGXY61_REG_ANALOG_GAIN\t\t\t\tVGXY61_REG_8BIT(0x0508)\n#define VGXY61_REG_DIGITAL_GAIN_LONG\t\t\tVGXY61_REG_16BIT(0x050a)\n#define VGXY61_REG_DIGITAL_GAIN_SHORT\t\t\tVGXY61_REG_16BIT(0x0512)\n#define VGXY61_REG_FRAME_LENGTH\t\t\t\tVGXY61_REG_16BIT(0x051a)\n#define VGXY61_REG_SIGNALS_CTRL\t\t\t\tVGXY61_REG_16BIT(0x0522)\n#define VGXY61_SIGNALS_GPIO_ID_SHIFT\t\t\t4\n#define VGXY61_REG_READOUT_CTRL\t\t\t\tVGXY61_REG_8BIT(0x0530)\n#define VGXY61_REG_HDR_CTRL\t\t\t\tVGXY61_REG_8BIT(0x0532)\n#define VGXY61_REG_PATGEN_LONG_DATA_GR\t\t\tVGXY61_REG_16BIT(0x092c)\n#define VGXY61_REG_PATGEN_LONG_DATA_R\t\t\tVGXY61_REG_16BIT(0x092e)\n#define VGXY61_REG_PATGEN_LONG_DATA_B\t\t\tVGXY61_REG_16BIT(0x0930)\n#define VGXY61_REG_PATGEN_LONG_DATA_GB\t\t\tVGXY61_REG_16BIT(0x0932)\n#define VGXY61_REG_PATGEN_SHORT_DATA_GR\t\t\tVGXY61_REG_16BIT(0x0950)\n#define VGXY61_REG_PATGEN_SHORT_DATA_R\t\t\tVGXY61_REG_16BIT(0x0952)\n#define VGXY61_REG_PATGEN_SHORT_DATA_B\t\t\tVGXY61_REG_16BIT(0x0954)\n#define VGXY61_REG_PATGEN_SHORT_DATA_GB\t\t\tVGXY61_REG_16BIT(0x0956)\n#define VGXY61_REG_BYPASS_CTRL\t\t\t\tVGXY61_REG_8BIT(0x0a60)\n\n#define VGX661_WIDTH\t\t\t\t\t1464\n#define VGX661_HEIGHT\t\t\t\t\t1104\n#define VGX761_WIDTH\t\t\t\t\t1944\n#define VGX761_HEIGHT\t\t\t\t\t1204\n#define VGX661_DEFAULT_MODE\t\t\t\t1\n#define VGX761_DEFAULT_MODE\t\t\t\t1\n#define VGX661_SHORT_ROT_TERM\t\t\t\t93\n#define VGX761_SHORT_ROT_TERM\t\t\t\t90\n#define VGXY61_EXPOS_ROT_TERM\t\t\t\t66\n#define VGXY61_WRITE_MULTIPLE_CHUNK_MAX\t\t\t16\n#define VGXY61_NB_GPIOS\t\t\t\t\t4\n#define VGXY61_NB_POLARITIES\t\t\t\t5\n#define VGXY61_FRAME_LENGTH_DEF\t\t\t\t1313\n#define VGXY61_MIN_FRAME_LENGTH\t\t\t\t1288\n#define VGXY61_MIN_EXPOSURE\t\t\t\t10\n#define VGXY61_HDR_LINEAR_RATIO\t\t\t\t10\n#define VGXY61_TIMEOUT_MS\t\t\t\t500\n#define VGXY61_MEDIA_BUS_FMT_DEF\t\t\tMEDIA_BUS_FMT_Y8_1X8\n\n#define VGXY61_FWPATCH_REVISION_MAJOR\t\t\t2\n#define VGXY61_FWPATCH_REVISION_MINOR\t\t\t0\n#define VGXY61_FWPATCH_REVISION_MICRO\t\t\t5\n\nstatic const u8 patch_array[] = {\n\t0xbf, 0x00, 0x05, 0x20, 0x06, 0x01, 0xe0, 0xe0, 0x04, 0x80, 0xe6, 0x45,\n\t0xed, 0x6f, 0xfe, 0xff, 0x14, 0x80, 0x1f, 0x84, 0x10, 0x42, 0x05, 0x7c,\n\t0x01, 0xc4, 0x1e, 0x80, 0xb6, 0x42, 0x00, 0xe0, 0x1e, 0x82, 0x1e, 0xc0,\n\t0x93, 0xdd, 0xc3, 0xc1, 0x0c, 0x04, 0x00, 0xfa, 0x86, 0x0d, 0x70, 0xe1,\n\t0x04, 0x98, 0x15, 0x00, 0x28, 0xe0, 0x14, 0x02, 0x08, 0xfc, 0x15, 0x40,\n\t0x28, 0xe0, 0x98, 0x58, 0xe0, 0xef, 0x04, 0x98, 0x0e, 0x04, 0x00, 0xf0,\n\t0x15, 0x00, 0x28, 0xe0, 0x19, 0xc8, 0x15, 0x40, 0x28, 0xe0, 0xc6, 0x41,\n\t0xfc, 0xe0, 0x14, 0x80, 0x1f, 0x84, 0x14, 0x02, 0xa0, 0xfc, 0x1e, 0x80,\n\t0x14, 0x80, 0x14, 0x02, 0x80, 0xfb, 0x14, 0x02, 0xe0, 0xfc, 0x1e, 0x80,\n\t0x14, 0xc0, 0x1f, 0x84, 0x14, 0x02, 0xa4, 0xfc, 0x1e, 0xc0, 0x14, 0xc0,\n\t0x14, 0x02, 0x80, 0xfb, 0x14, 0x02, 0xe4, 0xfc, 0x1e, 0xc0, 0x0c, 0x0c,\n\t0x00, 0xf2, 0x93, 0xdd, 0x86, 0x00, 0xf8, 0xe0, 0x04, 0x80, 0xc6, 0x03,\n\t0x70, 0xe1, 0x0e, 0x84, 0x93, 0xdd, 0xc3, 0xc1, 0x0c, 0x04, 0x00, 0xfa,\n\t0x6b, 0x80, 0x06, 0x40, 0x6c, 0xe1, 0x04, 0x80, 0x09, 0x00, 0xe0, 0xe0,\n\t0x0b, 0xa1, 0x95, 0x84, 0x05, 0x0c, 0x1c, 0xe0, 0x86, 0x02, 0xf9, 0x60,\n\t0xe0, 0xcf, 0x78, 0x6e, 0x80, 0xef, 0x25, 0x0c, 0x18, 0xe0, 0x05, 0x4c,\n\t0x1c, 0xe0, 0x86, 0x02, 0xf9, 0x60, 0xe0, 0xcf, 0x0b, 0x84, 0xd8, 0x6d,\n\t0x80, 0xef, 0x05, 0x4c, 0x18, 0xe0, 0x04, 0xd8, 0x0b, 0xa5, 0x95, 0x84,\n\t0x05, 0x0c, 0x2c, 0xe0, 0x06, 0x02, 0x01, 0x60, 0xe0, 0xce, 0x18, 0x6d,\n\t0x80, 0xef, 0x25, 0x0c, 0x30, 0xe0, 0x05, 0x4c, 0x2c, 0xe0, 0x06, 0x02,\n\t0x01, 0x60, 0xe0, 0xce, 0x0b, 0x84, 0x78, 0x6c, 0x80, 0xef, 0x05, 0x4c,\n\t0x30, 0xe0, 0x0c, 0x0c, 0x00, 0xf2, 0x93, 0xdd, 0x46, 0x01, 0x70, 0xe1,\n\t0x08, 0x80, 0x0b, 0xa1, 0x08, 0x5c, 0x00, 0xda, 0x06, 0x01, 0x68, 0xe1,\n\t0x04, 0x80, 0x4a, 0x40, 0x84, 0xe0, 0x08, 0x5c, 0x00, 0x9a, 0x06, 0x01,\n\t0xe0, 0xe0, 0x04, 0x80, 0x15, 0x00, 0x60, 0xe0, 0x19, 0xc4, 0x15, 0x40,\n\t0x60, 0xe0, 0x15, 0x00, 0x78, 0xe0, 0x19, 0xc4, 0x15, 0x40, 0x78, 0xe0,\n\t0x93, 0xdd, 0xc3, 0xc1, 0x46, 0x01, 0x70, 0xe1, 0x08, 0x80, 0x0b, 0xa1,\n\t0x08, 0x5c, 0x00, 0xda, 0x06, 0x01, 0x68, 0xe1, 0x04, 0x80, 0x4a, 0x40,\n\t0x84, 0xe0, 0x08, 0x5c, 0x00, 0x9a, 0x06, 0x01, 0xe0, 0xe0, 0x14, 0x80,\n\t0x25, 0x02, 0x54, 0xe0, 0x29, 0xc4, 0x25, 0x42, 0x54, 0xe0, 0x24, 0x80,\n\t0x35, 0x04, 0x6c, 0xe0, 0x39, 0xc4, 0x35, 0x44, 0x6c, 0xe0, 0x25, 0x02,\n\t0x64, 0xe0, 0x29, 0xc4, 0x25, 0x42, 0x64, 0xe0, 0x04, 0x80, 0x15, 0x00,\n\t0x7c, 0xe0, 0x19, 0xc4, 0x15, 0x40, 0x7c, 0xe0, 0x93, 0xdd, 0xc3, 0xc1,\n\t0x4c, 0x04, 0x7c, 0xfa, 0x86, 0x40, 0x98, 0xe0, 0x14, 0x80, 0x1b, 0xa1,\n\t0x06, 0x00, 0x00, 0xc0, 0x08, 0x42, 0x38, 0xdc, 0x08, 0x64, 0xa0, 0xef,\n\t0x86, 0x42, 0x3c, 0xe0, 0x68, 0x49, 0x80, 0xef, 0x6b, 0x80, 0x78, 0x53,\n\t0xc8, 0xef, 0xc6, 0x54, 0x6c, 0xe1, 0x7b, 0x80, 0xb5, 0x14, 0x0c, 0xf8,\n\t0x05, 0x14, 0x14, 0xf8, 0x1a, 0xac, 0x8a, 0x80, 0x0b, 0x90, 0x38, 0x55,\n\t0x80, 0xef, 0x1a, 0xae, 0x17, 0xc2, 0x03, 0x82, 0x88, 0x65, 0x80, 0xef,\n\t0x1b, 0x80, 0x0b, 0x8e, 0x68, 0x65, 0x80, 0xef, 0x9b, 0x80, 0x0b, 0x8c,\n\t0x08, 0x65, 0x80, 0xef, 0x6b, 0x80, 0x0b, 0x92, 0x1b, 0x8c, 0x98, 0x64,\n\t0x80, 0xef, 0x1a, 0xec, 0x9b, 0x80, 0x0b, 0x90, 0x95, 0x54, 0x10, 0xe0,\n\t0xa8, 0x53, 0x80, 0xef, 0x1a, 0xee, 0x17, 0xc2, 0x03, 0x82, 0xf8, 0x63,\n\t0x80, 0xef, 0x1b, 0x80, 0x0b, 0x8e, 0xd8, 0x63, 0x80, 0xef, 0x1b, 0x8c,\n\t0x68, 0x63, 0x80, 0xef, 0x6b, 0x80, 0x0b, 0x92, 0x65, 0x54, 0x14, 0xe0,\n\t0x08, 0x65, 0x84, 0xef, 0x68, 0x63, 0x80, 0xef, 0x7b, 0x80, 0x0b, 0x8c,\n\t0xa8, 0x64, 0x84, 0xef, 0x08, 0x63, 0x80, 0xef, 0x14, 0xe8, 0x46, 0x44,\n\t0x94, 0xe1, 0x24, 0x88, 0x4a, 0x4e, 0x04, 0xe0, 0x14, 0xea, 0x1a, 0x04,\n\t0x08, 0xe0, 0x0a, 0x40, 0x84, 0xed, 0x0c, 0x04, 0x00, 0xe2, 0x4a, 0x40,\n\t0x04, 0xe0, 0x19, 0x16, 0xc0, 0xe0, 0x0a, 0x40, 0x84, 0xed, 0x21, 0x54,\n\t0x60, 0xe0, 0x0c, 0x04, 0x00, 0xe2, 0x1b, 0xa5, 0x0e, 0xea, 0x01, 0x89,\n\t0x21, 0x54, 0x64, 0xe0, 0x7e, 0xe8, 0x65, 0x82, 0x1b, 0xa7, 0x26, 0x00,\n\t0x00, 0x80, 0xa5, 0x82, 0x1b, 0xa9, 0x65, 0x82, 0x1b, 0xa3, 0x01, 0x85,\n\t0x16, 0x00, 0x00, 0xc0, 0x01, 0x54, 0x04, 0xf8, 0x06, 0xaa, 0x01, 0x83,\n\t0x06, 0xa8, 0x65, 0x81, 0x06, 0xa8, 0x01, 0x54, 0x04, 0xf8, 0x01, 0x83,\n\t0x06, 0xaa, 0x09, 0x14, 0x18, 0xf8, 0x0b, 0xa1, 0x05, 0x84, 0xc6, 0x42,\n\t0xd4, 0xe0, 0x14, 0x84, 0x01, 0x83, 0x01, 0x54, 0x60, 0xe0, 0x01, 0x54,\n\t0x64, 0xe0, 0x0b, 0x02, 0x90, 0xe0, 0x10, 0x02, 0x90, 0xe5, 0x01, 0x54,\n\t0x88, 0xe0, 0xb5, 0x81, 0xc6, 0x40, 0xd4, 0xe0, 0x14, 0x80, 0x0b, 0x02,\n\t0xe0, 0xe4, 0x10, 0x02, 0x31, 0x66, 0x02, 0xc0, 0x01, 0x54, 0x88, 0xe0,\n\t0x1a, 0x84, 0x29, 0x14, 0x10, 0xe0, 0x1c, 0xaa, 0x2b, 0xa1, 0xf5, 0x82,\n\t0x25, 0x14, 0x10, 0xf8, 0x2b, 0x04, 0xa8, 0xe0, 0x20, 0x44, 0x0d, 0x70,\n\t0x03, 0xc0, 0x2b, 0xa1, 0x04, 0x00, 0x80, 0x9a, 0x02, 0x40, 0x84, 0x90,\n\t0x03, 0x54, 0x04, 0x80, 0x4c, 0x0c, 0x7c, 0xf2, 0x93, 0xdd, 0x00, 0x00,\n\t0x02, 0xa9, 0x00, 0x00, 0x64, 0x4a, 0x40, 0x00, 0x08, 0x2d, 0x58, 0xe0,\n\t0xa8, 0x98, 0x40, 0x00, 0x28, 0x07, 0x34, 0xe0, 0x05, 0xb9, 0x00, 0x00,\n\t0x28, 0x00, 0x41, 0x05, 0x88, 0x00, 0x41, 0x3c, 0x98, 0x00, 0x41, 0x52,\n\t0x04, 0x01, 0x41, 0x79, 0x3c, 0x01, 0x41, 0x6a, 0x3d, 0xfe, 0x00, 0x00,\n};\n\nstatic const char * const vgxy61_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Solid\",\n\t\"Colorbar\",\n\t\"Gradbar\",\n\t\"Hgrey\",\n\t\"Vgrey\",\n\t\"Dgrey\",\n\t\"PN28\",\n};\n\nstatic const char * const vgxy61_hdr_mode_menu[] = {\n\t\"HDR linearize\",\n\t\"HDR substraction\",\n\t\"No HDR\",\n};\n\nstatic const char * const vgxy61_supply_name[] = {\n\t\"VCORE\",\n\t\"VDDIO\",\n\t\"VANA\",\n};\n\nstatic const s64 link_freq[] = {\n\t \n\t402000000ULL\n};\n\nenum vgxy61_bin_mode {\n\tVGXY61_BIN_MODE_NORMAL,\n\tVGXY61_BIN_MODE_DIGITAL_X2,\n\tVGXY61_BIN_MODE_DIGITAL_X4,\n};\n\nenum vgxy61_hdr_mode {\n\tVGXY61_HDR_LINEAR,\n\tVGXY61_HDR_SUB,\n\tVGXY61_NO_HDR,\n};\n\nenum vgxy61_strobe_mode {\n\tVGXY61_STROBE_DISABLED,\n\tVGXY61_STROBE_LONG,\n\tVGXY61_STROBE_ENABLED,\n};\n\nstruct vgxy61_mode_info {\n\tu32 width;\n\tu32 height;\n\tenum vgxy61_bin_mode bin_mode;\n\tstruct v4l2_rect crop;\n};\n\nstruct vgxy61_fmt_desc {\n\tu32 code;\n\tu8 bpp;\n\tu8 data_type;\n};\n\nstatic const struct vgxy61_fmt_desc vgxy61_supported_codes[] = {\n\t{\n\t\t.code = MEDIA_BUS_FMT_Y8_1X8,\n\t\t.bpp = 8,\n\t\t.data_type = MIPI_CSI2_DT_RAW8,\n\t},\n\t{\n\t\t.code = MEDIA_BUS_FMT_Y10_1X10,\n\t\t.bpp = 10,\n\t\t.data_type = MIPI_CSI2_DT_RAW10,\n\t},\n\t{\n\t\t.code = MEDIA_BUS_FMT_Y12_1X12,\n\t\t.bpp = 12,\n\t\t.data_type = MIPI_CSI2_DT_RAW12,\n\t},\n\t{\n\t\t.code = MEDIA_BUS_FMT_Y14_1X14,\n\t\t.bpp = 14,\n\t\t.data_type = MIPI_CSI2_DT_RAW14,\n\t},\n\t{\n\t\t.code = MEDIA_BUS_FMT_Y16_1X16,\n\t\t.bpp = 16,\n\t\t.data_type = MIPI_CSI2_DT_RAW16,\n\t},\n};\n\nstatic const struct vgxy61_mode_info vgx661_mode_data[] = {\n\t{\n\t\t.width = VGX661_WIDTH,\n\t\t.height = VGX661_HEIGHT,\n\t\t.bin_mode = VGXY61_BIN_MODE_NORMAL,\n\t\t.crop = {\n\t\t\t.left = 0,\n\t\t\t.top = 0,\n\t\t\t.width = VGX661_WIDTH,\n\t\t\t.height = VGX661_HEIGHT,\n\t\t},\n\t},\n\t{\n\t\t.width = 1280,\n\t\t.height = 720,\n\t\t.bin_mode = VGXY61_BIN_MODE_NORMAL,\n\t\t.crop = {\n\t\t\t.left = 92,\n\t\t\t.top = 192,\n\t\t\t.width = 1280,\n\t\t\t.height = 720,\n\t\t},\n\t},\n\t{\n\t\t.width = 640,\n\t\t.height = 480,\n\t\t.bin_mode = VGXY61_BIN_MODE_DIGITAL_X2,\n\t\t.crop = {\n\t\t\t.left = 92,\n\t\t\t.top = 72,\n\t\t\t.width = 1280,\n\t\t\t.height = 960,\n\t\t},\n\t},\n\t{\n\t\t.width = 320,\n\t\t.height = 240,\n\t\t.bin_mode = VGXY61_BIN_MODE_DIGITAL_X4,\n\t\t.crop = {\n\t\t\t.left = 92,\n\t\t\t.top = 72,\n\t\t\t.width = 1280,\n\t\t\t.height = 960,\n\t\t},\n\t},\n};\n\nstatic const struct vgxy61_mode_info vgx761_mode_data[] = {\n\t{\n\t\t.width = VGX761_WIDTH,\n\t\t.height = VGX761_HEIGHT,\n\t\t.bin_mode = VGXY61_BIN_MODE_NORMAL,\n\t\t.crop = {\n\t\t\t.left = 0,\n\t\t\t.top = 0,\n\t\t\t.width = VGX761_WIDTH,\n\t\t\t.height = VGX761_HEIGHT,\n\t\t},\n\t},\n\t{\n\t\t.width = 1920,\n\t\t.height = 1080,\n\t\t.bin_mode = VGXY61_BIN_MODE_NORMAL,\n\t\t.crop = {\n\t\t\t.left = 12,\n\t\t\t.top = 62,\n\t\t\t.width = 1920,\n\t\t\t.height = 1080,\n\t\t},\n\t},\n\t{\n\t\t.width = 1280,\n\t\t.height = 720,\n\t\t.bin_mode = VGXY61_BIN_MODE_NORMAL,\n\t\t.crop = {\n\t\t\t.left = 332,\n\t\t\t.top = 242,\n\t\t\t.width = 1280,\n\t\t\t.height = 720,\n\t\t},\n\t},\n\t{\n\t\t.width = 640,\n\t\t.height = 480,\n\t\t.bin_mode = VGXY61_BIN_MODE_DIGITAL_X2,\n\t\t.crop = {\n\t\t\t.left = 332,\n\t\t\t.top = 122,\n\t\t\t.width = 1280,\n\t\t\t.height = 960,\n\t\t},\n\t},\n\t{\n\t\t.width = 320,\n\t\t.height = 240,\n\t\t.bin_mode = VGXY61_BIN_MODE_DIGITAL_X4,\n\t\t.crop = {\n\t\t\t.left = 332,\n\t\t\t.top = 122,\n\t\t\t.width = 1280,\n\t\t\t.height = 960,\n\t\t},\n\t},\n};\n\nstruct vgxy61_dev {\n\tstruct i2c_client *i2c_client;\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pad;\n\tstruct regulator_bulk_data supplies[ARRAY_SIZE(vgxy61_supply_name)];\n\tstruct gpio_desc *reset_gpio;\n\tstruct clk *xclk;\n\tu32 clk_freq;\n\tu16 id;\n\tu16 sensor_width;\n\tu16 sensor_height;\n\tu16 oif_ctrl;\n\tunsigned int nb_of_lane;\n\tu32 data_rate_in_mbps;\n\tu32 pclk;\n\tu16 line_length;\n\tu16 rot_term;\n\tbool gpios_polarity;\n\t \n\tstruct mutex lock;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tstruct v4l2_ctrl *pixel_rate_ctrl;\n\tstruct v4l2_ctrl *expo_ctrl;\n\tstruct v4l2_ctrl *vblank_ctrl;\n\tstruct v4l2_ctrl *vflip_ctrl;\n\tstruct v4l2_ctrl *hflip_ctrl;\n\tbool streaming;\n\tstruct v4l2_mbus_framefmt fmt;\n\tconst struct vgxy61_mode_info *sensor_modes;\n\tunsigned int sensor_modes_nb;\n\tconst struct vgxy61_mode_info *default_mode;\n\tconst struct vgxy61_mode_info *current_mode;\n\tbool hflip;\n\tbool vflip;\n\tenum vgxy61_hdr_mode hdr;\n\tu16 expo_long;\n\tu16 expo_short;\n\tu16 expo_max;\n\tu16 expo_min;\n\tu16 vblank;\n\tu16 vblank_min;\n\tu16 frame_length;\n\tu16 digital_gain;\n\tu8 analog_gain;\n\tenum vgxy61_strobe_mode strobe_mode;\n\tu32 pattern;\n};\n\nstatic u8 get_bpp_by_code(__u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vgxy61_supported_codes); i++) {\n\t\tif (vgxy61_supported_codes[i].code == code)\n\t\t\treturn vgxy61_supported_codes[i].bpp;\n\t}\n\t \n\tWARN(1, \"Unsupported code %d. default to 8 bpp\", code);\n\treturn 8;\n}\n\nstatic u8 get_data_type_by_code(__u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vgxy61_supported_codes); i++) {\n\t\tif (vgxy61_supported_codes[i].code == code)\n\t\t\treturn vgxy61_supported_codes[i].data_type;\n\t}\n\t \n\tWARN(1, \"Unsupported code %d. default to MIPI_CSI2_DT_RAW8 data type\",\n\t     code);\n\treturn MIPI_CSI2_DT_RAW8;\n}\n\nstatic void compute_pll_parameters_by_freq(u32 freq, u8 *prediv, u8 *mult)\n{\n\tconst unsigned int predivs[] = {1, 2, 4};\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(predivs); i++) {\n\t\t*prediv = predivs[i];\n\t\tif (freq / *prediv < 12 * HZ_PER_MHZ)\n\t\t\tbreak;\n\t}\n\tWARN_ON(i == ARRAY_SIZE(predivs));\n\n\t \n\t*mult = ((804 * HZ_PER_MHZ) * (*prediv) + freq / 2) / freq;\n}\n\nstatic s32 get_pixel_rate(struct vgxy61_dev *sensor)\n{\n\treturn div64_u64((u64)sensor->data_rate_in_mbps * sensor->nb_of_lane,\n\t\t\t get_bpp_by_code(sensor->fmt.code));\n}\n\nstatic inline struct vgxy61_dev *to_vgxy61_dev(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct vgxy61_dev, sd);\n}\n\nstatic inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct vgxy61_dev,\n\t\t\t     ctrl_handler)->sd;\n}\n\nstatic unsigned int get_chunk_size(struct vgxy61_dev *sensor)\n{\n\tstruct i2c_adapter *adapter = sensor->i2c_client->adapter;\n\tint max_write_len = VGXY61_WRITE_MULTIPLE_CHUNK_MAX;\n\n\tif (adapter->quirks && adapter->quirks->max_write_len)\n\t\tmax_write_len = adapter->quirks->max_write_len - 2;\n\n\tmax_write_len = min(max_write_len, VGXY61_WRITE_MULTIPLE_CHUNK_MAX);\n\n\treturn max(max_write_len, 1);\n}\n\nstatic int vgxy61_read_multiple(struct vgxy61_dev *sensor, u32 reg,\n\t\t\t\tunsigned int len)\n{\n\tstruct i2c_client *client = sensor->i2c_client;\n\tstruct i2c_msg msg[2];\n\tu8 buf[2];\n\tu8 val[sizeof(u32)] = {0};\n\tint ret;\n\n\tif (len > sizeof(u32))\n\t\treturn -EINVAL;\n\tbuf[0] = reg >> 8;\n\tbuf[1] = reg & 0xff;\n\n\tmsg[0].addr = client->addr;\n\tmsg[0].flags = client->flags;\n\tmsg[0].buf = buf;\n\tmsg[0].len = sizeof(buf);\n\n\tmsg[1].addr = client->addr;\n\tmsg[1].flags = client->flags | I2C_M_RD;\n\tmsg[1].buf = val;\n\tmsg[1].len = len;\n\n\tret = i2c_transfer(client->adapter, msg, 2);\n\tif (ret < 0) {\n\t\tdev_dbg(&client->dev, \"%s: %x i2c_transfer, reg: %x => %d\\n\",\n\t\t\t__func__, client->addr, reg, ret);\n\t\treturn ret;\n\t}\n\n\treturn get_unaligned_le32(val);\n}\n\nstatic inline int vgxy61_read_reg(struct vgxy61_dev *sensor, u32 reg)\n{\n\treturn vgxy61_read_multiple(sensor, reg & VGXY61_REG_ADDR_MASK,\n\t\t\t\t     (reg >> VGXY61_REG_SIZE_SHIFT) & 7);\n}\n\nstatic int vgxy61_write_multiple(struct vgxy61_dev *sensor, u32 reg,\n\t\t\t\t const u8 *data, unsigned int len, int *err)\n{\n\tstruct i2c_client *client = sensor->i2c_client;\n\tstruct i2c_msg msg;\n\tu8 buf[VGXY61_WRITE_MULTIPLE_CHUNK_MAX + 2];\n\tunsigned int i;\n\tint ret;\n\n\tif (err && *err)\n\t\treturn *err;\n\n\tif (len > VGXY61_WRITE_MULTIPLE_CHUNK_MAX)\n\t\treturn -EINVAL;\n\tbuf[0] = reg >> 8;\n\tbuf[1] = reg & 0xff;\n\tfor (i = 0; i < len; i++)\n\t\tbuf[i + 2] = data[i];\n\n\tmsg.addr = client->addr;\n\tmsg.flags = client->flags;\n\tmsg.buf = buf;\n\tmsg.len = len + 2;\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret < 0) {\n\t\tdev_dbg(&client->dev, \"%s: i2c_transfer, reg: %x => %d\\n\",\n\t\t\t__func__, reg, ret);\n\t\tif (err)\n\t\t\t*err = ret;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int vgxy61_write_array(struct vgxy61_dev *sensor, u32 reg,\n\t\t\t      unsigned int nb, const u8 *array)\n{\n\tconst unsigned int chunk_size = get_chunk_size(sensor);\n\tint ret;\n\tunsigned int sz;\n\n\twhile (nb) {\n\t\tsz = min(nb, chunk_size);\n\t\tret = vgxy61_write_multiple(sensor, reg, array, sz, NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnb -= sz;\n\t\treg += sz;\n\t\tarray += sz;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int vgxy61_write_reg(struct vgxy61_dev *sensor, u32 reg, u32 val,\n\t\t\t\t   int *err)\n{\n\treturn vgxy61_write_multiple(sensor, reg & VGXY61_REG_ADDR_MASK,\n\t\t\t\t     (u8 *)&val,\n\t\t\t\t     (reg >> VGXY61_REG_SIZE_SHIFT) & 7, err);\n}\n\nstatic int vgxy61_poll_reg(struct vgxy61_dev *sensor, u32 reg, u8 poll_val,\n\t\t\t   unsigned int timeout_ms)\n{\n\tconst unsigned int loop_delay_ms = 10;\n\tint ret;\n\n\treturn read_poll_timeout(vgxy61_read_reg, ret,\n\t\t\t\t ((ret < 0) || (ret == poll_val)),\n\t\t\t\t loop_delay_ms * 1000, timeout_ms * 1000,\n\t\t\t\t false, sensor, reg);\n}\n\nstatic int vgxy61_wait_state(struct vgxy61_dev *sensor, int state,\n\t\t\t     unsigned int timeout_ms)\n{\n\treturn vgxy61_poll_reg(sensor, VGXY61_REG_SYSTEM_FSM, state,\n\t\t\t       timeout_ms);\n}\n\nstatic int vgxy61_check_bw(struct vgxy61_dev *sensor)\n{\n\t \n\tconst unsigned int mipi_margin = 1056;\n\tunsigned int binning_scale = sensor->current_mode->crop.height /\n\t\t\t\t     sensor->current_mode->height;\n\tu8 bpp = get_bpp_by_code(sensor->fmt.code);\n\tunsigned int max_bit_per_line;\n\tunsigned int bit_per_line;\n\tu64 line_rate;\n\n\tline_rate = sensor->nb_of_lane * (u64)sensor->data_rate_in_mbps *\n\t\t    sensor->line_length;\n\tmax_bit_per_line = div64_u64(line_rate, sensor->pclk) - mipi_margin;\n\tbit_per_line = (bpp * sensor->current_mode->width) / binning_scale;\n\n\treturn bit_per_line > max_bit_per_line ? -EINVAL : 0;\n}\n\nstatic int vgxy61_apply_exposure(struct vgxy61_dev *sensor)\n{\n\tint ret = 0;\n\n\t  \n\tvgxy61_write_reg(sensor, VGXY61_REG_COARSE_EXPOSURE_SHORT, 0, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_COARSE_EXPOSURE_LONG,\n\t\t\t sensor->expo_long, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_COARSE_EXPOSURE_SHORT,\n\t\t\t sensor->expo_short, &ret);\n\n\treturn ret;\n}\n\nstatic int vgxy61_get_regulators(struct vgxy61_dev *sensor)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vgxy61_supply_name); i++)\n\t\tsensor->supplies[i].supply = vgxy61_supply_name[i];\n\n\treturn devm_regulator_bulk_get(&sensor->i2c_client->dev,\n\t\t\t\t       ARRAY_SIZE(vgxy61_supply_name),\n\t\t\t\t       sensor->supplies);\n}\n\nstatic int vgxy61_apply_reset(struct vgxy61_dev *sensor)\n{\n\tgpiod_set_value_cansleep(sensor->reset_gpio, 0);\n\tusleep_range(5000, 10000);\n\tgpiod_set_value_cansleep(sensor->reset_gpio, 1);\n\tusleep_range(5000, 10000);\n\tgpiod_set_value_cansleep(sensor->reset_gpio, 0);\n\tusleep_range(40000, 100000);\n\treturn vgxy61_wait_state(sensor, VGXY61_SYSTEM_FSM_SW_STBY,\n\t\t\t\t VGXY61_TIMEOUT_MS);\n}\n\nstatic void vgxy61_fill_framefmt(struct vgxy61_dev *sensor,\n\t\t\t\t const struct vgxy61_mode_info *mode,\n\t\t\t\t struct v4l2_mbus_framefmt *fmt, u32 code)\n{\n\tfmt->code = code;\n\tfmt->width = mode->width;\n\tfmt->height = mode->height;\n\tfmt->colorspace = V4L2_COLORSPACE_RAW;\n\tfmt->field = V4L2_FIELD_NONE;\n\tfmt->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tfmt->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tfmt->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n}\n\nstatic int vgxy61_try_fmt_internal(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_mbus_framefmt *fmt,\n\t\t\t\t   const struct vgxy61_mode_info **new_mode)\n{\n\tstruct vgxy61_dev *sensor = to_vgxy61_dev(sd);\n\tconst struct vgxy61_mode_info *mode = sensor->sensor_modes;\n\tunsigned int index;\n\n\tfor (index = 0; index < ARRAY_SIZE(vgxy61_supported_codes); index++) {\n\t\tif (vgxy61_supported_codes[index].code == fmt->code)\n\t\t\tbreak;\n\t}\n\tif (index == ARRAY_SIZE(vgxy61_supported_codes))\n\t\tindex = 0;\n\n\tmode = v4l2_find_nearest_size(sensor->sensor_modes,\n\t\t\t\t      sensor->sensor_modes_nb, width, height,\n\t\t\t\t      fmt->width, fmt->height);\n\tif (new_mode)\n\t\t*new_mode = mode;\n\n\tvgxy61_fill_framefmt(sensor, mode, fmt,\n\t\t\t     vgxy61_supported_codes[index].code);\n\n\treturn 0;\n}\n\nstatic int vgxy61_get_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct vgxy61_dev *sensor = to_vgxy61_dev(sd);\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = sensor->current_mode->crop;\n\t\treturn 0;\n\tcase V4L2_SEL_TGT_NATIVE_SIZE:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.top = 0;\n\t\tsel->r.left = 0;\n\t\tsel->r.width = sensor->sensor_width;\n\t\tsel->r.height = sensor->sensor_height;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int vgxy61_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index >= ARRAY_SIZE(vgxy61_supported_codes))\n\t\treturn -EINVAL;\n\n\tcode->code = vgxy61_supported_codes[code->index].code;\n\n\treturn 0;\n}\n\nstatic int vgxy61_get_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct vgxy61_dev *sensor = to_vgxy61_dev(sd);\n\tstruct v4l2_mbus_framefmt *fmt;\n\n\tmutex_lock(&sensor->lock);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\tfmt = v4l2_subdev_get_try_format(&sensor->sd, sd_state,\n\t\t\t\t\t\t format->pad);\n\telse\n\t\tfmt = &sensor->fmt;\n\n\tformat->format = *fmt;\n\n\tmutex_unlock(&sensor->lock);\n\n\treturn 0;\n}\n\nstatic u16 vgxy61_get_vblank_min(struct vgxy61_dev *sensor,\n\t\t\t\t enum vgxy61_hdr_mode hdr)\n{\n\tu16 min_vblank =  VGXY61_MIN_FRAME_LENGTH -\n\t\t\t  sensor->current_mode->crop.height;\n\t \n\tu16 min_vblank_hdr =  VGXY61_MIN_EXPOSURE + sensor->rot_term + 1;\n\n\tif (hdr != VGXY61_NO_HDR)\n\t\treturn max(min_vblank, min_vblank_hdr);\n\treturn min_vblank;\n}\n\nstatic int vgxy61_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct vgxy61_dev *sensor = to_vgxy61_dev(sd);\n\n\tif (fse->index >= sensor->sensor_modes_nb)\n\t\treturn -EINVAL;\n\n\tfse->min_width = sensor->sensor_modes[fse->index].width;\n\tfse->max_width = fse->min_width;\n\tfse->min_height = sensor->sensor_modes[fse->index].height;\n\tfse->max_height = fse->min_height;\n\n\treturn 0;\n}\n\nstatic int vgxy61_update_analog_gain(struct vgxy61_dev *sensor, u32 target)\n{\n\tsensor->analog_gain = target;\n\n\tif (sensor->streaming)\n\t\treturn vgxy61_write_reg(sensor, VGXY61_REG_ANALOG_GAIN, target,\n\t\t\t\t\tNULL);\n\treturn 0;\n}\n\nstatic int vgxy61_apply_digital_gain(struct vgxy61_dev *sensor,\n\t\t\t\t     u32 digital_gain)\n{\n\tint ret = 0;\n\n\t \n\tvgxy61_write_reg(sensor, VGXY61_REG_DIGITAL_GAIN_LONG, digital_gain,\n\t\t\t &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_DIGITAL_GAIN_SHORT, digital_gain,\n\t\t\t &ret);\n\n\treturn ret;\n}\n\nstatic int vgxy61_update_digital_gain(struct vgxy61_dev *sensor, u32 target)\n{\n\tsensor->digital_gain = target;\n\n\tif (sensor->streaming)\n\t\treturn vgxy61_apply_digital_gain(sensor, sensor->digital_gain);\n\treturn 0;\n}\n\nstatic int vgxy61_apply_patgen(struct vgxy61_dev *sensor, u32 index)\n{\n\tstatic const u8 index2val[] = {\n\t\t0x0, 0x1, 0x2, 0x3, 0x10, 0x11, 0x12, 0x13\n\t};\n\tu32 pattern = index2val[index];\n\tu32 reg = (pattern << VGXY61_PATGEN_LONG_TYPE_SHIFT) |\n\t      (pattern << VGXY61_PATGEN_SHORT_TYPE_SHIFT);\n\n\tif (pattern)\n\t\treg |= VGXY61_PATGEN_LONG_ENABLE | VGXY61_PATGEN_SHORT_ENABLE;\n\treturn vgxy61_write_reg(sensor, VGXY61_REG_PATGEN_CTRL, reg, NULL);\n}\n\nstatic int vgxy61_update_patgen(struct vgxy61_dev *sensor, u32 pattern)\n{\n\tsensor->pattern = pattern;\n\n\tif (sensor->streaming)\n\t\treturn vgxy61_apply_patgen(sensor, sensor->pattern);\n\treturn 0;\n}\n\nstatic int vgxy61_apply_gpiox_strobe_mode(struct vgxy61_dev *sensor,\n\t\t\t\t\t  enum vgxy61_strobe_mode mode,\n\t\t\t\t\t  unsigned int idx)\n{\n\tstatic const u8 index2val[] = {0x0, 0x1, 0x3};\n\tint reg;\n\n\treg = vgxy61_read_reg(sensor, VGXY61_REG_SIGNALS_CTRL);\n\tif (reg < 0)\n\t\treturn reg;\n\treg &= ~(0xf << (idx * VGXY61_SIGNALS_GPIO_ID_SHIFT));\n\treg |= index2val[mode] << (idx * VGXY61_SIGNALS_GPIO_ID_SHIFT);\n\n\treturn vgxy61_write_reg(sensor, VGXY61_REG_SIGNALS_CTRL, reg, NULL);\n}\n\nstatic int vgxy61_update_gpios_strobe_mode(struct vgxy61_dev *sensor,\n\t\t\t\t\t   enum vgxy61_hdr_mode hdr)\n{\n\tunsigned int i;\n\tint ret;\n\n\tswitch (hdr) {\n\tcase VGXY61_HDR_LINEAR:\n\t\tsensor->strobe_mode = VGXY61_STROBE_ENABLED;\n\t\tbreak;\n\tcase VGXY61_HDR_SUB:\n\tcase VGXY61_NO_HDR:\n\t\tsensor->strobe_mode = VGXY61_STROBE_LONG;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ON(true);\n\t\tbreak;\n\t}\n\n\tif (!sensor->streaming)\n\t\treturn 0;\n\n\tfor (i = 0; i < VGXY61_NB_GPIOS; i++) {\n\t\tret = vgxy61_apply_gpiox_strobe_mode(sensor,\n\t\t\t\t\t\t     sensor->strobe_mode,\n\t\t\t\t\t\t     i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int vgxy61_update_gpios_strobe_polarity(struct vgxy61_dev *sensor,\n\t\t\t\t\t       bool polarity)\n{\n\tint ret = 0;\n\n\tif (sensor->streaming)\n\t\treturn -EBUSY;\n\n\tvgxy61_write_reg(sensor, VGXY61_REG_GPIO_0_CTRL, polarity << 1, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_GPIO_1_CTRL, polarity << 1, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_GPIO_2_CTRL, polarity << 1, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_GPIO_3_CTRL, polarity << 1, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_SIGNALS_POLARITY_CTRL, polarity,\n\t\t\t &ret);\n\n\treturn ret;\n}\n\nstatic u32 vgxy61_get_expo_long_max(struct vgxy61_dev *sensor,\n\t\t\t\t    unsigned int short_expo_ratio)\n{\n\tu32 first_rot_max_expo, second_rot_max_expo, third_rot_max_expo;\n\n\t \n\t \n\tfirst_rot_max_expo =\n\t\t((sensor->frame_length - sensor->current_mode->crop.height -\n\t\tsensor->rot_term) * short_expo_ratio) - 1;\n\n\t \n\tsecond_rot_max_expo =\n\t\t(((sensor->frame_length - VGXY61_EXPOS_ROT_TERM) *\n\t\tshort_expo_ratio) / (short_expo_ratio + 1)) - 1;\n\n\t \n\tthird_rot_max_expo = (sensor->frame_length / 71) * short_expo_ratio;\n\n\t \n\treturn min(min(first_rot_max_expo, second_rot_max_expo),\n\t\t   third_rot_max_expo);\n}\n\nstatic int vgxy61_update_exposure(struct vgxy61_dev *sensor, u16 new_expo_long,\n\t\t\t\t  enum vgxy61_hdr_mode hdr)\n{\n\tstruct i2c_client *client = sensor->i2c_client;\n\tu16 new_expo_short = 0;\n\tu16 expo_short_max = 0;\n\tu16 expo_long_min = VGXY61_MIN_EXPOSURE;\n\tu16 expo_long_max = 0;\n\n\t \n\tswitch (hdr) {\n\tcase VGXY61_HDR_LINEAR:\n\t\t \n\t\texpo_long_min = VGXY61_MIN_EXPOSURE * VGXY61_HDR_LINEAR_RATIO;\n\t\tnew_expo_long = max(expo_long_min, new_expo_long);\n\n\t\texpo_long_max =\n\t\t\tvgxy61_get_expo_long_max(sensor,\n\t\t\t\t\t\t VGXY61_HDR_LINEAR_RATIO);\n\t\texpo_short_max = (expo_long_max +\n\t\t\t\t (VGXY61_HDR_LINEAR_RATIO / 2)) /\n\t\t\t\t VGXY61_HDR_LINEAR_RATIO;\n\t\tnew_expo_short = (new_expo_long +\n\t\t\t\t (VGXY61_HDR_LINEAR_RATIO / 2)) /\n\t\t\t\t VGXY61_HDR_LINEAR_RATIO;\n\t\tbreak;\n\tcase VGXY61_HDR_SUB:\n\t\tnew_expo_long = max(expo_long_min, new_expo_long);\n\n\t\texpo_long_max = vgxy61_get_expo_long_max(sensor, 1);\n\t\t \n\t\texpo_short_max = expo_long_max;\n\t\tnew_expo_short = new_expo_long;\n\t\tbreak;\n\tcase VGXY61_NO_HDR:\n\t\tnew_expo_long = max(expo_long_min, new_expo_long);\n\n\t\t \n\t\texpo_long_max = sensor->frame_length - VGXY61_EXPOS_ROT_TERM;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ON(true);\n\t\tbreak;\n\t}\n\n\t \n\tWARN_ON(expo_long_min > expo_long_max);\n\n\tif (new_expo_long > expo_long_max) {\n\t\tdev_warn(&client->dev, \"Exposure %d too high, clamping to %d\\n\",\n\t\t\t new_expo_long, expo_long_max);\n\t\tnew_expo_long = expo_long_max;\n\t\tnew_expo_short = expo_short_max;\n\t}\n\n\tsensor->expo_long = new_expo_long;\n\tsensor->expo_short = new_expo_short;\n\tsensor->expo_max = expo_long_max;\n\tsensor->expo_min = expo_long_min;\n\n\tif (sensor->streaming)\n\t\treturn vgxy61_apply_exposure(sensor);\n\treturn 0;\n}\n\nstatic int vgxy61_apply_framelength(struct vgxy61_dev *sensor)\n{\n\treturn vgxy61_write_reg(sensor, VGXY61_REG_FRAME_LENGTH,\n\t\t\t\tsensor->frame_length, NULL);\n}\n\nstatic int vgxy61_update_vblank(struct vgxy61_dev *sensor, u16 vblank,\n\t\t\t\tenum vgxy61_hdr_mode hdr)\n{\n\tint ret;\n\n\tsensor->vblank_min = vgxy61_get_vblank_min(sensor, hdr);\n\tsensor->vblank = max(sensor->vblank_min, vblank);\n\tsensor->frame_length = sensor->current_mode->crop.height +\n\t\t\t       sensor->vblank;\n\n\t \n\tret = vgxy61_update_exposure(sensor, sensor->expo_long, hdr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sensor->streaming)\n\t\treturn vgxy61_apply_framelength(sensor);\n\treturn 0;\n}\n\nstatic int vgxy61_apply_hdr(struct vgxy61_dev *sensor,\n\t\t\t    enum vgxy61_hdr_mode index)\n{\n\tstatic const u8 index2val[] = {0x1, 0x4, 0xa};\n\n\treturn vgxy61_write_reg(sensor, VGXY61_REG_HDR_CTRL, index2val[index],\n\t\t\t\tNULL);\n}\n\nstatic int vgxy61_update_hdr(struct vgxy61_dev *sensor,\n\t\t\t     enum vgxy61_hdr_mode index)\n{\n\tint ret;\n\n\t \n\tret = vgxy61_update_vblank(sensor, sensor->vblank, index);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = vgxy61_update_gpios_strobe_mode(sensor, index);\n\tif (ret)\n\t\treturn ret;\n\n\tsensor->hdr = index;\n\n\tif (sensor->streaming)\n\t\treturn vgxy61_apply_hdr(sensor, sensor->hdr);\n\treturn 0;\n}\n\nstatic int vgxy61_apply_settings(struct vgxy61_dev *sensor)\n{\n\tint ret;\n\tunsigned int i;\n\n\tret = vgxy61_apply_hdr(sensor, sensor->hdr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vgxy61_apply_framelength(sensor);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vgxy61_apply_exposure(sensor);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vgxy61_write_reg(sensor, VGXY61_REG_ANALOG_GAIN,\n\t\t\t       sensor->analog_gain, NULL);\n\tif (ret)\n\t\treturn ret;\n\tret = vgxy61_apply_digital_gain(sensor, sensor->digital_gain);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vgxy61_write_reg(sensor, VGXY61_REG_ORIENTATION,\n\t\t\t       sensor->hflip | (sensor->vflip << 1), NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vgxy61_apply_patgen(sensor, sensor->pattern);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < VGXY61_NB_GPIOS; i++) {\n\t\tret = vgxy61_apply_gpiox_strobe_mode(sensor,\n\t\t\t\t\t\t     sensor->strobe_mode, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int vgxy61_stream_enable(struct vgxy61_dev *sensor)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);\n\tconst struct v4l2_rect *crop = &sensor->current_mode->crop;\n\tint ret = 0;\n\n\tret = vgxy61_check_bw(sensor);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pm_runtime_get_sync(&client->dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_autosuspend(&client->dev);\n\t\treturn ret;\n\t}\n\n\t \n\tret = 0;\n\n\tvgxy61_write_reg(sensor, VGXY61_REG_FORMAT_CTRL,\n\t\t\t get_bpp_by_code(sensor->fmt.code), &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_OIF_ROI0_CTRL,\n\t\t\t get_data_type_by_code(sensor->fmt.code), &ret);\n\n\tvgxy61_write_reg(sensor, VGXY61_REG_READOUT_CTRL,\n\t\t\t sensor->current_mode->bin_mode, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_ROI0_START_H, crop->left, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_ROI0_END_H,\n\t\t\t crop->left + crop->width - 1, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_ROI0_START_V, crop->top, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_ROI0_END_V,\n\t\t\t crop->top + crop->height - 1, &ret);\n\tif (ret)\n\t\tgoto err_rpm_put;\n\n\tret = vgxy61_apply_settings(sensor);\n\tif (ret)\n\t\tgoto err_rpm_put;\n\n\tret = vgxy61_write_reg(sensor, VGXY61_REG_STREAMING,\n\t\t\t       VGXY61_STREAMING_REQ_START, NULL);\n\tif (ret)\n\t\tgoto err_rpm_put;\n\n\tret = vgxy61_poll_reg(sensor, VGXY61_REG_STREAMING,\n\t\t\t      VGXY61_STREAMING_NO_REQ, VGXY61_TIMEOUT_MS);\n\tif (ret)\n\t\tgoto err_rpm_put;\n\n\tret = vgxy61_wait_state(sensor, VGXY61_SYSTEM_FSM_STREAMING,\n\t\t\t\tVGXY61_TIMEOUT_MS);\n\tif (ret)\n\t\tgoto err_rpm_put;\n\n\t \n\t__v4l2_ctrl_grab(sensor->vflip_ctrl, true);\n\t__v4l2_ctrl_grab(sensor->hflip_ctrl, true);\n\n\treturn 0;\n\nerr_rpm_put:\n\tpm_runtime_put(&client->dev);\n\treturn ret;\n}\n\nstatic int vgxy61_stream_disable(struct vgxy61_dev *sensor)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);\n\tint ret;\n\n\tret = vgxy61_write_reg(sensor, VGXY61_REG_STREAMING,\n\t\t\t       VGXY61_STREAMING_REQ_STOP, NULL);\n\tif (ret)\n\t\tgoto err_str_dis;\n\n\tret = vgxy61_poll_reg(sensor, VGXY61_REG_STREAMING,\n\t\t\t      VGXY61_STREAMING_NO_REQ, 2000);\n\tif (ret)\n\t\tgoto err_str_dis;\n\n\tret = vgxy61_wait_state(sensor, VGXY61_SYSTEM_FSM_SW_STBY,\n\t\t\t\tVGXY61_TIMEOUT_MS);\n\tif (ret)\n\t\tgoto err_str_dis;\n\n\t__v4l2_ctrl_grab(sensor->vflip_ctrl, false);\n\t__v4l2_ctrl_grab(sensor->hflip_ctrl, false);\n\nerr_str_dis:\n\tif (ret)\n\t\tWARN(1, \"Can't disable stream\");\n\tpm_runtime_put(&client->dev);\n\n\treturn ret;\n}\n\nstatic int vgxy61_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct vgxy61_dev *sensor = to_vgxy61_dev(sd);\n\tint ret = 0;\n\n\tmutex_lock(&sensor->lock);\n\n\tret = enable ? vgxy61_stream_enable(sensor) :\n\t      vgxy61_stream_disable(sensor);\n\tif (!ret)\n\t\tsensor->streaming = enable;\n\n\tmutex_unlock(&sensor->lock);\n\n\treturn ret;\n}\n\nstatic int vgxy61_set_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct vgxy61_dev *sensor = to_vgxy61_dev(sd);\n\tconst struct vgxy61_mode_info *new_mode;\n\tstruct v4l2_mbus_framefmt *fmt;\n\tint ret;\n\n\tmutex_lock(&sensor->lock);\n\n\tif (sensor->streaming) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = vgxy61_try_fmt_internal(sd, &format->format, &new_mode);\n\tif (ret)\n\t\tgoto out;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tfmt = v4l2_subdev_get_try_format(sd, sd_state, 0);\n\t\t*fmt = format->format;\n\t} else if (sensor->current_mode != new_mode ||\n\t\t   sensor->fmt.code != format->format.code) {\n\t\tfmt = &sensor->fmt;\n\t\t*fmt = format->format;\n\n\t\tsensor->current_mode = new_mode;\n\n\t\t \n\t\tret = vgxy61_update_vblank(sensor,\n\t\t\t\t\t   VGXY61_FRAME_LENGTH_DEF -\n\t\t\t\t\t   new_mode->crop.height,\n\t\t\t\t\t   sensor->hdr);\n\n\t\t \n\t\t__v4l2_ctrl_s_ctrl_int64(sensor->pixel_rate_ctrl,\n\t\t\t\t\t get_pixel_rate(sensor));\n\t\t__v4l2_ctrl_modify_range(sensor->vblank_ctrl,\n\t\t\t\t\t sensor->vblank_min,\n\t\t\t\t\t 0xffff - new_mode->crop.height,\n\t\t\t\t\t 1, sensor->vblank);\n\t\t__v4l2_ctrl_s_ctrl(sensor->vblank_ctrl, sensor->vblank);\n\t\t__v4l2_ctrl_modify_range(sensor->expo_ctrl, sensor->expo_min,\n\t\t\t\t\t sensor->expo_max, 1,\n\t\t\t\t\t sensor->expo_long);\n\t}\n\nout:\n\tmutex_unlock(&sensor->lock);\n\n\treturn ret;\n}\n\nstatic int vgxy61_init_cfg(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state)\n{\n\tstruct vgxy61_dev *sensor = to_vgxy61_dev(sd);\n\tstruct v4l2_subdev_format fmt = { 0 };\n\n\tvgxy61_fill_framefmt(sensor, sensor->current_mode, &fmt.format,\n\t\t\t     VGXY61_MEDIA_BUS_FMT_DEF);\n\n\treturn vgxy61_set_fmt(sd, sd_state, &fmt);\n}\n\nstatic int vgxy61_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = ctrl_to_sd(ctrl);\n\tstruct vgxy61_dev *sensor = to_vgxy61_dev(sd);\n\tconst struct vgxy61_mode_info *cur_mode = sensor->current_mode;\n\tint ret;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE:\n\t\tret = vgxy61_update_exposure(sensor, ctrl->val, sensor->hdr);\n\t\tctrl->val = sensor->expo_long;\n\t\tbreak;\n\tcase V4L2_CID_ANALOGUE_GAIN:\n\t\tret = vgxy61_update_analog_gain(sensor, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_DIGITAL_GAIN:\n\t\tret = vgxy61_update_digital_gain(sensor, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\tcase V4L2_CID_HFLIP:\n\t\tif (sensor->streaming) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t\tif (ctrl->id == V4L2_CID_VFLIP)\n\t\t\tsensor->vflip = ctrl->val;\n\t\tif (ctrl->id == V4L2_CID_HFLIP)\n\t\t\tsensor->hflip = ctrl->val;\n\t\tret = 0;\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tret = vgxy61_update_patgen(sensor, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HDR_SENSOR_MODE:\n\t\tret = vgxy61_update_hdr(sensor, ctrl->val);\n\t\t \n\t\t__v4l2_ctrl_modify_range(sensor->vblank_ctrl,\n\t\t\t\t\t sensor->vblank_min,\n\t\t\t\t\t 0xffff - cur_mode->crop.height,\n\t\t\t\t\t 1, sensor->vblank);\n\t\t__v4l2_ctrl_modify_range(sensor->expo_ctrl, sensor->expo_min,\n\t\t\t\t\t sensor->expo_max, 1,\n\t\t\t\t\t sensor->expo_long);\n\t\tbreak;\n\tcase V4L2_CID_VBLANK:\n\t\tret = vgxy61_update_vblank(sensor, ctrl->val, sensor->hdr);\n\t\t \n\t\t__v4l2_ctrl_modify_range(sensor->expo_ctrl, sensor->expo_min,\n\t\t\t\t\t sensor->expo_max, 1,\n\t\t\t\t\t sensor->expo_long);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops vgxy61_ctrl_ops = {\n\t.s_ctrl = vgxy61_s_ctrl,\n};\n\nstatic int vgxy61_init_controls(struct vgxy61_dev *sensor)\n{\n\tconst struct v4l2_ctrl_ops *ops = &vgxy61_ctrl_ops;\n\tstruct v4l2_ctrl_handler *hdl = &sensor->ctrl_handler;\n\tconst struct vgxy61_mode_info *cur_mode = sensor->current_mode;\n\tstruct v4l2_ctrl *ctrl;\n\tint ret;\n\n\tv4l2_ctrl_handler_init(hdl, 16);\n\t \n\thdl->lock = &sensor->lock;\n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_ANALOGUE_GAIN, 0, 0x1c, 1,\n\t\t\t  sensor->analog_gain);\n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_DIGITAL_GAIN, 0, 0xfff, 1,\n\t\t\t  sensor->digital_gain);\n\tv4l2_ctrl_new_std_menu_items(hdl, ops, V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(vgxy61_test_pattern_menu) - 1,\n\t\t\t\t     0, 0, vgxy61_test_pattern_menu);\n\tctrl = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HBLANK, 0,\n\t\t\t\t sensor->line_length, 1,\n\t\t\t\t sensor->line_length - cur_mode->width);\n\tif (ctrl)\n\t\tctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\tctrl = v4l2_ctrl_new_int_menu(hdl, ops, V4L2_CID_LINK_FREQ,\n\t\t\t\t      ARRAY_SIZE(link_freq) - 1, 0, link_freq);\n\tif (ctrl)\n\t\tctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\tv4l2_ctrl_new_std_menu_items(hdl, ops, V4L2_CID_HDR_SENSOR_MODE,\n\t\t\t\t     ARRAY_SIZE(vgxy61_hdr_mode_menu) - 1, 0,\n\t\t\t\t     VGXY61_NO_HDR, vgxy61_hdr_mode_menu);\n\n\t \n\tsensor->pixel_rate_ctrl = v4l2_ctrl_new_std(hdl, ops,\n\t\t\t\t\t\t    V4L2_CID_PIXEL_RATE, 1,\n\t\t\t\t\t\t    INT_MAX, 1,\n\t\t\t\t\t\t    get_pixel_rate(sensor));\n\tif (sensor->pixel_rate_ctrl)\n\t\tsensor->pixel_rate_ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\tsensor->expo_ctrl = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_EXPOSURE,\n\t\t\t\t\t      sensor->expo_min,\n\t\t\t\t\t      sensor->expo_max, 1,\n\t\t\t\t\t      sensor->expo_long);\n\tsensor->vblank_ctrl = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VBLANK,\n\t\t\t\t\t\tsensor->vblank_min,\n\t\t\t\t\t\t0xffff - cur_mode->crop.height,\n\t\t\t\t\t\t1, sensor->vblank);\n\tsensor->vflip_ctrl = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VFLIP,\n\t\t\t\t\t       0, 1, 1, sensor->vflip);\n\tsensor->hflip_ctrl = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HFLIP,\n\t\t\t\t\t       0, 1, 1, sensor->hflip);\n\n\tif (hdl->error) {\n\t\tret = hdl->error;\n\t\tgoto free_ctrls;\n\t}\n\n\tsensor->sd.ctrl_handler = hdl;\n\treturn 0;\n\nfree_ctrls:\n\tv4l2_ctrl_handler_free(hdl);\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_video_ops vgxy61_video_ops = {\n\t.s_stream = vgxy61_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops vgxy61_pad_ops = {\n\t.init_cfg = vgxy61_init_cfg,\n\t.enum_mbus_code = vgxy61_enum_mbus_code,\n\t.get_fmt = vgxy61_get_fmt,\n\t.set_fmt = vgxy61_set_fmt,\n\t.get_selection = vgxy61_get_selection,\n\t.enum_frame_size = vgxy61_enum_frame_size,\n};\n\nstatic const struct v4l2_subdev_ops vgxy61_subdev_ops = {\n\t.video = &vgxy61_video_ops,\n\t.pad = &vgxy61_pad_ops,\n};\n\nstatic const struct media_entity_operations vgxy61_subdev_entity_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic int vgxy61_tx_from_ep(struct vgxy61_dev *sensor,\n\t\t\t     struct fwnode_handle *handle)\n{\n\tstruct v4l2_fwnode_endpoint ep = { .bus_type = V4L2_MBUS_CSI2_DPHY };\n\tstruct i2c_client *client = sensor->i2c_client;\n\tu32 log2phy[VGXY61_NB_POLARITIES] = {~0, ~0, ~0, ~0, ~0};\n\tu32 phy2log[VGXY61_NB_POLARITIES] = {~0, ~0, ~0, ~0, ~0};\n\tint polarities[VGXY61_NB_POLARITIES] = {0, 0, 0, 0, 0};\n\tint l_nb;\n\tunsigned int p, l, i;\n\tint ret;\n\n\tret = v4l2_fwnode_endpoint_alloc_parse(handle, &ep);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tl_nb = ep.bus.mipi_csi2.num_data_lanes;\n\tif (l_nb != 1 && l_nb != 2 && l_nb != 4) {\n\t\tdev_err(&client->dev, \"invalid data lane number %d\\n\", l_nb);\n\t\tgoto error_ep;\n\t}\n\n\t \n\tlog2phy[0] = ep.bus.mipi_csi2.clock_lane;\n\tphy2log[log2phy[0]] = 0;\n\tfor (l = 1; l < l_nb + 1; l++) {\n\t\tlog2phy[l] = ep.bus.mipi_csi2.data_lanes[l - 1];\n\t\tphy2log[log2phy[l]] = l;\n\t}\n\t \n\tfor (p = 0; p < VGXY61_NB_POLARITIES; p++) {\n\t\tif (phy2log[p] != ~0)\n\t\t\tcontinue;\n\t\tphy2log[p] = l;\n\t\tlog2phy[l] = p;\n\t\tl++;\n\t}\n\tfor (l = 0; l < l_nb + 1; l++)\n\t\tpolarities[l] = ep.bus.mipi_csi2.lane_polarities[l];\n\n\tif (log2phy[0] != 0) {\n\t\tdev_err(&client->dev, \"clk lane must be map to physical lane 0\\n\");\n\t\tgoto error_ep;\n\t}\n\tsensor->oif_ctrl = (polarities[4] << 15) + ((phy2log[4] - 1) << 13) +\n\t\t\t   (polarities[3] << 12) + ((phy2log[3] - 1) << 10) +\n\t\t\t   (polarities[2] <<  9) + ((phy2log[2] - 1) <<  7) +\n\t\t\t   (polarities[1] <<  6) + ((phy2log[1] - 1) <<  4) +\n\t\t\t   (polarities[0] <<  3) +\n\t\t\t   l_nb;\n\tsensor->nb_of_lane = l_nb;\n\n\tdev_dbg(&client->dev, \"tx uses %d lanes\", l_nb);\n\tfor (i = 0; i < VGXY61_NB_POLARITIES; i++) {\n\t\tdev_dbg(&client->dev, \"log2phy[%d] = %d\\n\", i, log2phy[i]);\n\t\tdev_dbg(&client->dev, \"phy2log[%d] = %d\\n\", i, phy2log[i]);\n\t\tdev_dbg(&client->dev, \"polarity[%d] = %d\\n\", i, polarities[i]);\n\t}\n\tdev_dbg(&client->dev, \"oif_ctrl = 0x%04x\\n\", sensor->oif_ctrl);\n\n\tv4l2_fwnode_endpoint_free(&ep);\n\n\treturn 0;\n\nerror_ep:\n\tv4l2_fwnode_endpoint_free(&ep);\n\n\treturn -EINVAL;\n}\n\nstatic int vgxy61_configure(struct vgxy61_dev *sensor)\n{\n\tu32 sensor_freq;\n\tu8 prediv, mult;\n\tint line_length;\n\tint ret = 0;\n\n\tcompute_pll_parameters_by_freq(sensor->clk_freq, &prediv, &mult);\n\tsensor_freq = (mult * sensor->clk_freq) / prediv;\n\t \n\tsensor->data_rate_in_mbps = sensor_freq;\n\t \n\tsensor->pclk = sensor_freq / 5;\n\n\tline_length = vgxy61_read_reg(sensor, VGXY61_REG_LINE_LENGTH);\n\tif (line_length < 0)\n\t\treturn line_length;\n\tsensor->line_length = line_length;\n\tvgxy61_write_reg(sensor, VGXY61_REG_EXT_CLOCK, sensor->clk_freq, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_CLK_PLL_PREDIV, prediv, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_CLK_SYS_PLL_MULT, mult, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_OIF_CTRL, sensor->oif_ctrl, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_FRAME_CONTENT_CTRL, 0, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_BYPASS_CTRL, 4, &ret);\n\tif (ret)\n\t\treturn ret;\n\tvgxy61_update_gpios_strobe_polarity(sensor, sensor->gpios_polarity);\n\t \n\tvgxy61_write_reg(sensor, VGXY61_REG_PATGEN_LONG_DATA_GR, 0x800, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_PATGEN_LONG_DATA_R, 0x800, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_PATGEN_LONG_DATA_B, 0x800, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_PATGEN_LONG_DATA_GB, 0x800, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_PATGEN_SHORT_DATA_GR, 0x800, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_PATGEN_SHORT_DATA_R, 0x800, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_PATGEN_SHORT_DATA_B, 0x800, &ret);\n\tvgxy61_write_reg(sensor, VGXY61_REG_PATGEN_SHORT_DATA_GB, 0x800, &ret);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int vgxy61_patch(struct vgxy61_dev *sensor)\n{\n\tstruct i2c_client *client = sensor->i2c_client;\n\tint patch, ret;\n\n\tret = vgxy61_write_array(sensor, VGXY61_REG_FWPATCH_START_ADDR,\n\t\t\t\t sizeof(patch_array), patch_array);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vgxy61_write_reg(sensor, VGXY61_REG_STBY, 0x10, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vgxy61_poll_reg(sensor, VGXY61_REG_STBY, 0, VGXY61_TIMEOUT_MS);\n\tif (ret)\n\t\treturn ret;\n\n\tpatch = vgxy61_read_reg(sensor, VGXY61_REG_FWPATCH_REVISION);\n\tif (patch < 0)\n\t\treturn patch;\n\n\tif (patch != (VGXY61_FWPATCH_REVISION_MAJOR << 12) +\n\t\t     (VGXY61_FWPATCH_REVISION_MINOR << 8) +\n\t\t     VGXY61_FWPATCH_REVISION_MICRO) {\n\t\tdev_err(&client->dev, \"bad patch version expected %d.%d.%d got %d.%d.%d\\n\",\n\t\t\tVGXY61_FWPATCH_REVISION_MAJOR,\n\t\t\tVGXY61_FWPATCH_REVISION_MINOR,\n\t\t\tVGXY61_FWPATCH_REVISION_MICRO,\n\t\t\tpatch >> 12, (patch >> 8) & 0x0f, patch & 0xff);\n\t\treturn -ENODEV;\n\t}\n\tdev_dbg(&client->dev, \"patch %d.%d.%d applied\\n\",\n\t\tpatch >> 12, (patch >> 8) & 0x0f, patch & 0xff);\n\n\treturn 0;\n}\n\nstatic int vgxy61_detect_cut_version(struct vgxy61_dev *sensor)\n{\n\tstruct i2c_client *client = sensor->i2c_client;\n\tint device_rev;\n\n\tdevice_rev = vgxy61_read_reg(sensor, VGXY61_REG_REVISION);\n\tif (device_rev < 0)\n\t\treturn device_rev;\n\n\tswitch (device_rev >> 8) {\n\tcase 0xA:\n\t\tdev_dbg(&client->dev, \"Cut1 detected\\n\");\n\t\tdev_err(&client->dev, \"Cut1 not supported by this driver\\n\");\n\t\treturn -ENODEV;\n\tcase 0xB:\n\t\tdev_dbg(&client->dev, \"Cut2 detected\\n\");\n\t\treturn 0;\n\tcase 0xC:\n\t\tdev_dbg(&client->dev, \"Cut3 detected\\n\");\n\t\treturn 0;\n\tdefault:\n\t\tdev_err(&client->dev, \"Unable to detect cut version\\n\");\n\t\treturn -ENODEV;\n\t}\n}\n\nstatic int vgxy61_detect(struct vgxy61_dev *sensor)\n{\n\tstruct i2c_client *client = sensor->i2c_client;\n\tint id = 0;\n\tint ret, st;\n\n\tid = vgxy61_read_reg(sensor, VGXY61_REG_MODEL_ID);\n\tif (id < 0)\n\t\treturn id;\n\tif (id != VG5661_MODEL_ID && id != VG5761_MODEL_ID) {\n\t\tdev_warn(&client->dev, \"Unsupported sensor id %x\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\tdev_dbg(&client->dev, \"detected sensor id = 0x%04x\\n\", id);\n\tsensor->id = id;\n\n\tret = vgxy61_wait_state(sensor, VGXY61_SYSTEM_FSM_SW_STBY,\n\t\t\t\tVGXY61_TIMEOUT_MS);\n\tif (ret)\n\t\treturn ret;\n\n\tst = vgxy61_read_reg(sensor, VGXY61_REG_NVM);\n\tif (st < 0)\n\t\treturn st;\n\tif (st != VGXY61_NVM_OK)\n\t\tdev_warn(&client->dev, \"Bad nvm state got %d\\n\", st);\n\n\tret = vgxy61_detect_cut_version(sensor);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int vgxy61_power_on(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct vgxy61_dev *sensor = to_vgxy61_dev(sd);\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(vgxy61_supply_name),\n\t\t\t\t    sensor->supplies);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to enable regulators %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(sensor->xclk);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to enable clock %d\\n\", ret);\n\t\tgoto disable_bulk;\n\t}\n\n\tif (sensor->reset_gpio) {\n\t\tret = vgxy61_apply_reset(sensor);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"sensor reset failed %d\\n\", ret);\n\t\t\tgoto disable_clock;\n\t\t}\n\t}\n\n\tret = vgxy61_detect(sensor);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"sensor detect failed %d\\n\", ret);\n\t\tgoto disable_clock;\n\t}\n\n\tret = vgxy61_patch(sensor);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"sensor patch failed %d\\n\", ret);\n\t\tgoto disable_clock;\n\t}\n\n\tret = vgxy61_configure(sensor);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"sensor configuration failed %d\\n\", ret);\n\t\tgoto disable_clock;\n\t}\n\n\treturn 0;\n\ndisable_clock:\n\tclk_disable_unprepare(sensor->xclk);\ndisable_bulk:\n\tregulator_bulk_disable(ARRAY_SIZE(vgxy61_supply_name),\n\t\t\t       sensor->supplies);\n\n\treturn ret;\n}\n\nstatic int vgxy61_power_off(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct vgxy61_dev *sensor = to_vgxy61_dev(sd);\n\n\tclk_disable_unprepare(sensor->xclk);\n\tregulator_bulk_disable(ARRAY_SIZE(vgxy61_supply_name),\n\t\t\t       sensor->supplies);\n\treturn 0;\n}\n\nstatic void vgxy61_fill_sensor_param(struct vgxy61_dev *sensor)\n{\n\tif (sensor->id == VG5761_MODEL_ID) {\n\t\tsensor->sensor_width = VGX761_WIDTH;\n\t\tsensor->sensor_height = VGX761_HEIGHT;\n\t\tsensor->sensor_modes = vgx761_mode_data;\n\t\tsensor->sensor_modes_nb = ARRAY_SIZE(vgx761_mode_data);\n\t\tsensor->default_mode = &vgx761_mode_data[VGX761_DEFAULT_MODE];\n\t\tsensor->rot_term = VGX761_SHORT_ROT_TERM;\n\t} else if (sensor->id == VG5661_MODEL_ID) {\n\t\tsensor->sensor_width = VGX661_WIDTH;\n\t\tsensor->sensor_height = VGX661_HEIGHT;\n\t\tsensor->sensor_modes = vgx661_mode_data;\n\t\tsensor->sensor_modes_nb = ARRAY_SIZE(vgx661_mode_data);\n\t\tsensor->default_mode = &vgx661_mode_data[VGX661_DEFAULT_MODE];\n\t\tsensor->rot_term = VGX661_SHORT_ROT_TERM;\n\t} else {\n\t\t \n\t\tWARN_ON(true);\n\t}\n\tsensor->current_mode = sensor->default_mode;\n}\n\nstatic int vgxy61_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct fwnode_handle *handle;\n\tstruct vgxy61_dev *sensor;\n\tint ret;\n\n\tsensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);\n\tif (!sensor)\n\t\treturn -ENOMEM;\n\n\tsensor->i2c_client = client;\n\tsensor->streaming = false;\n\tsensor->hdr = VGXY61_NO_HDR;\n\tsensor->expo_long = 200;\n\tsensor->expo_short = 0;\n\tsensor->hflip = false;\n\tsensor->vflip = false;\n\tsensor->analog_gain = 0;\n\tsensor->digital_gain = 256;\n\n\thandle = fwnode_graph_get_endpoint_by_id(dev_fwnode(dev), 0, 0, 0);\n\tif (!handle) {\n\t\tdev_err(dev, \"handle node not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = vgxy61_tx_from_ep(sensor, handle);\n\tfwnode_handle_put(handle);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to parse handle %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsensor->xclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(sensor->xclk)) {\n\t\tdev_err(dev, \"failed to get xclk\\n\");\n\t\treturn PTR_ERR(sensor->xclk);\n\t}\n\tsensor->clk_freq = clk_get_rate(sensor->xclk);\n\tif (sensor->clk_freq < 6 * HZ_PER_MHZ ||\n\t    sensor->clk_freq > 27 * HZ_PER_MHZ) {\n\t\tdev_err(dev, \"Only 6Mhz-27Mhz clock range supported. provide %lu MHz\\n\",\n\t\t\tsensor->clk_freq / HZ_PER_MHZ);\n\t\treturn -EINVAL;\n\t}\n\tsensor->gpios_polarity =\n\t\tdevice_property_read_bool(dev, \"st,strobe-gpios-polarity\");\n\n\tv4l2_i2c_subdev_init(&sensor->sd, client, &vgxy61_subdev_ops);\n\tsensor->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsensor->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tsensor->sd.entity.ops = &vgxy61_subdev_entity_ops;\n\tsensor->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\n\tsensor->reset_gpio = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t     GPIOD_OUT_HIGH);\n\n\tret = vgxy61_get_regulators(sensor);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to get regulators %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = vgxy61_power_on(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tvgxy61_fill_sensor_param(sensor);\n\tvgxy61_fill_framefmt(sensor, sensor->current_mode, &sensor->fmt,\n\t\t\t     VGXY61_MEDIA_BUS_FMT_DEF);\n\n\tmutex_init(&sensor->lock);\n\n\tret = vgxy61_update_hdr(sensor, sensor->hdr);\n\tif (ret)\n\t\tgoto error_power_off;\n\n\tret = vgxy61_init_controls(sensor);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"controls initialization failed %d\\n\",\n\t\t\tret);\n\t\tgoto error_power_off;\n\t}\n\n\tret = media_entity_pads_init(&sensor->sd.entity, 1, &sensor->pad);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"pads init failed %d\\n\", ret);\n\t\tgoto error_handler_free;\n\t}\n\n\t \n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_idle(dev);\n\n\tret = v4l2_async_register_subdev(&sensor->sd);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"async subdev register failed %d\\n\", ret);\n\t\tgoto error_pm_runtime;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(&client->dev, 1000);\n\tpm_runtime_use_autosuspend(&client->dev);\n\n\tdev_dbg(&client->dev, \"vgxy61 probe successfully\\n\");\n\n\treturn 0;\n\nerror_pm_runtime:\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\tmedia_entity_cleanup(&sensor->sd.entity);\nerror_handler_free:\n\tv4l2_ctrl_handler_free(sensor->sd.ctrl_handler);\nerror_power_off:\n\tmutex_destroy(&sensor->lock);\n\tvgxy61_power_off(dev);\n\n\treturn ret;\n}\n\nstatic void vgxy61_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct vgxy61_dev *sensor = to_vgxy61_dev(sd);\n\n\tv4l2_async_unregister_subdev(&sensor->sd);\n\tmutex_destroy(&sensor->lock);\n\tmedia_entity_cleanup(&sensor->sd.entity);\n\n\tpm_runtime_disable(&client->dev);\n\tif (!pm_runtime_status_suspended(&client->dev))\n\t\tvgxy61_power_off(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n}\n\nstatic const struct of_device_id vgxy61_dt_ids[] = {\n\t{ .compatible = \"st,st-vgxy61\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, vgxy61_dt_ids);\n\nstatic const struct dev_pm_ops vgxy61_pm_ops = {\n\tSET_RUNTIME_PM_OPS(vgxy61_power_off, vgxy61_power_on, NULL)\n};\n\nstatic struct i2c_driver vgxy61_i2c_driver = {\n\t.driver = {\n\t\t.name  = \"st-vgxy61\",\n\t\t.of_match_table = vgxy61_dt_ids,\n\t\t.pm = &vgxy61_pm_ops,\n\t},\n\t.probe = vgxy61_probe,\n\t.remove = vgxy61_remove,\n};\n\nmodule_i2c_driver(vgxy61_i2c_driver);\n\nMODULE_AUTHOR(\"Benjamin Mugnier <benjamin.mugnier@foss.st.com>\");\nMODULE_AUTHOR(\"Mickael Guene <mickael.guene@st.com>\");\nMODULE_AUTHOR(\"Sylvain Petinot <sylvain.petinot@foss.st.com>\");\nMODULE_DESCRIPTION(\"VGXY61 camera subdev driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}