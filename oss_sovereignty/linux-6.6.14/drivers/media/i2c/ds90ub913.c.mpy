{
  "module_name": "ds90ub913.c",
  "hash_id": "de3019accf2f68eeb77e2faa08c3c3fe8bd6e93c4d991d67273a5cd6ba06f261",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ds90ub913.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/fwnode.h>\n#include <linux/gpio/driver.h>\n#include <linux/i2c-atr.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n\n#include <media/i2c/ds90ub9xx.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-mediabus.h>\n#include <media/v4l2-subdev.h>\n\n#define UB913_PAD_SINK\t\t\t0\n#define UB913_PAD_SOURCE\t\t1\n\n \n#define UB913_NUM_GPIOS\t\t\t2\n\n#define UB913_REG_RESET_CTL\t\t\t0x01\n#define UB913_REG_RESET_CTL_DIGITAL_RESET_1\tBIT(1)\n#define UB913_REG_RESET_CTL_DIGITAL_RESET_0\tBIT(0)\n\n#define UB913_REG_GENERAL_CFG\t\t\t0x03\n#define UB913_REG_GENERAL_CFG_CRC_ERR_RESET\tBIT(5)\n#define UB913_REG_GENERAL_CFG_PCLK_RISING\tBIT(0)\n\n#define UB913_REG_MODE_SEL\t\t\t0x05\n#define UB913_REG_MODE_SEL_MODE_OVERRIDE\tBIT(5)\n#define UB913_REG_MODE_SEL_MODE_UP_TO_DATE\tBIT(4)\n#define UB913_REG_MODE_SEL_MODE_MASK\t\tGENMASK(3, 0)\n\n#define UB913_REG_CRC_ERRORS_LSB\t\t0x0a\n#define UB913_REG_CRC_ERRORS_MSB\t\t0x0b\n\n#define UB913_REG_GENERAL_STATUS\t\t0x0c\n\n#define UB913_REG_GPIO_CFG(n)\t\t\t(0x0d + (n))\n#define UB913_REG_GPIO_CFG_ENABLE(n)\t\tBIT(0 + (n) * 4)\n#define UB913_REG_GPIO_CFG_DIR_INPUT(n)\t\tBIT(1 + (n) * 4)\n#define UB913_REG_GPIO_CFG_REMOTE_EN(n)\t\tBIT(2 + (n) * 4)\n#define UB913_REG_GPIO_CFG_OUT_VAL(n)\t\tBIT(3 + (n) * 4)\n#define UB913_REG_GPIO_CFG_MASK(n)\t\t(0xf << ((n) * 4))\n\n#define UB913_REG_SCL_HIGH_TIME\t\t\t0x11\n#define UB913_REG_SCL_LOW_TIME\t\t\t0x12\n\n#define UB913_REG_PLL_OVR\t\t\t0x35\n\nstruct ub913_data {\n\tstruct i2c_client\t*client;\n\tstruct regmap\t\t*regmap;\n\tstruct clk\t\t*clkin;\n\n\tstruct gpio_chip\tgpio_chip;\n\n\tstruct v4l2_subdev\tsd;\n\tstruct media_pad\tpads[2];\n\n\tstruct v4l2_async_notifier\tnotifier;\n\n\tstruct v4l2_subdev\t*source_sd;\n\tu16\t\t\tsource_sd_pad;\n\n\tu64\t\t\tenabled_source_streams;\n\n\tstruct clk_hw\t\t*clkout_clk_hw;\n\n\tstruct ds90ub9xx_platform_data *plat_data;\n\n\tbool\t\t\tpclk_polarity_rising;\n};\n\nstatic inline struct ub913_data *sd_to_ub913(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct ub913_data, sd);\n}\n\nstruct ub913_format_info {\n\tu32 incode;\n\tu32 outcode;\n};\n\nstatic const struct ub913_format_info ub913_formats[] = {\n\t \n\t{ .incode = MEDIA_BUS_FMT_YUYV8_2X8, .outcode = MEDIA_BUS_FMT_YUYV8_1X16 },\n\t{ .incode = MEDIA_BUS_FMT_UYVY8_2X8, .outcode = MEDIA_BUS_FMT_UYVY8_1X16 },\n\t{ .incode = MEDIA_BUS_FMT_VYUY8_2X8, .outcode = MEDIA_BUS_FMT_VYUY8_1X16 },\n\t{ .incode = MEDIA_BUS_FMT_YVYU8_2X8, .outcode = MEDIA_BUS_FMT_YVYU8_1X16 },\n};\n\nstatic const struct ub913_format_info *ub913_find_format(u32 incode)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ub913_formats); i++) {\n\t\tif (ub913_formats[i].incode == incode)\n\t\t\treturn &ub913_formats[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic int ub913_read(const struct ub913_data *priv, u8 reg, u8 *val)\n{\n\tunsigned int v;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, reg, &v);\n\tif (ret < 0) {\n\t\tdev_err(&priv->client->dev,\n\t\t\t\"Cannot read register 0x%02x: %d!\\n\", reg, ret);\n\t\treturn ret;\n\t}\n\n\t*val = v;\n\treturn 0;\n}\n\nstatic int ub913_write(const struct ub913_data *priv, u8 reg, u8 val)\n{\n\tint ret;\n\n\tret = regmap_write(priv->regmap, reg, val);\n\tif (ret < 0)\n\t\tdev_err(&priv->client->dev,\n\t\t\t\"Cannot write register 0x%02x: %d!\\n\", reg, ret);\n\n\treturn ret;\n}\n\n \nstatic int ub913_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)\n{\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int ub913_gpio_direction_out(struct gpio_chip *gc, unsigned int offset,\n\t\t\t\t    int value)\n{\n\tstruct ub913_data *priv = gpiochip_get_data(gc);\n\tunsigned int reg_idx = offset / 2;\n\tunsigned int field_idx = offset % 2;\n\n\treturn regmap_update_bits(priv->regmap, UB913_REG_GPIO_CFG(reg_idx),\n\t\t\t\t  UB913_REG_GPIO_CFG_MASK(field_idx),\n\t\t\t\t  UB913_REG_GPIO_CFG_ENABLE(field_idx) |\n\t\t\t\t\t  (value ? UB913_REG_GPIO_CFG_OUT_VAL(field_idx) :\n\t\t\t\t\t\t   0));\n}\n\nstatic void ub913_gpio_set(struct gpio_chip *gc, unsigned int offset, int value)\n{\n\tub913_gpio_direction_out(gc, offset, value);\n}\n\nstatic int ub913_gpio_of_xlate(struct gpio_chip *gc,\n\t\t\t       const struct of_phandle_args *gpiospec,\n\t\t\t       u32 *flags)\n{\n\tif (flags)\n\t\t*flags = gpiospec->args[1];\n\n\treturn gpiospec->args[0];\n}\n\nstatic int ub913_gpiochip_probe(struct ub913_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tstruct gpio_chip *gc = &priv->gpio_chip;\n\tint ret;\n\n\t \n\tub913_write(priv, UB913_REG_GPIO_CFG(0), 0);\n\n\tgc->label = dev_name(dev);\n\tgc->parent = dev;\n\tgc->owner = THIS_MODULE;\n\tgc->base = -1;\n\tgc->can_sleep = true;\n\tgc->ngpio = UB913_NUM_GPIOS;\n\tgc->get_direction = ub913_gpio_get_direction;\n\tgc->direction_output = ub913_gpio_direction_out;\n\tgc->set = ub913_gpio_set;\n\tgc->of_xlate = ub913_gpio_of_xlate;\n\tgc->of_gpio_n_cells = 2;\n\n\tret = gpiochip_add_data(gc, priv);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to add GPIOs: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ub913_gpiochip_remove(struct ub913_data *priv)\n{\n\tgpiochip_remove(&priv->gpio_chip);\n}\n\nstatic const struct regmap_config ub913_regmap_config = {\n\t.name = \"ds90ub913\",\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.reg_format_endian = REGMAP_ENDIAN_DEFAULT,\n\t.val_format_endian = REGMAP_ENDIAN_DEFAULT,\n};\n\n \n\nstatic int ub913_enable_streams(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *state, u32 pad,\n\t\t\t\tu64 streams_mask)\n{\n\tstruct ub913_data *priv = sd_to_ub913(sd);\n\tu64 sink_streams;\n\tint ret;\n\n\tsink_streams = v4l2_subdev_state_xlate_streams(state, UB913_PAD_SOURCE,\n\t\t\t\t\t\t       UB913_PAD_SINK,\n\t\t\t\t\t\t       &streams_mask);\n\n\tret = v4l2_subdev_enable_streams(priv->source_sd, priv->source_sd_pad,\n\t\t\t\t\t sink_streams);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->enabled_source_streams |= streams_mask;\n\n\treturn 0;\n}\n\nstatic int ub913_disable_streams(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *state, u32 pad,\n\t\t\t\t u64 streams_mask)\n{\n\tstruct ub913_data *priv = sd_to_ub913(sd);\n\tu64 sink_streams;\n\tint ret;\n\n\tsink_streams = v4l2_subdev_state_xlate_streams(state, UB913_PAD_SOURCE,\n\t\t\t\t\t\t       UB913_PAD_SINK,\n\t\t\t\t\t\t       &streams_mask);\n\n\tret = v4l2_subdev_disable_streams(priv->source_sd, priv->source_sd_pad,\n\t\t\t\t\t  sink_streams);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->enabled_source_streams &= ~streams_mask;\n\n\treturn 0;\n}\n\nstatic int _ub913_set_routing(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *state,\n\t\t\t      struct v4l2_subdev_krouting *routing)\n{\n\tstatic const struct v4l2_mbus_framefmt in_format = {\n\t\t.width = 640,\n\t\t.height = 480,\n\t\t.code = MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t.field = V4L2_FIELD_NONE,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.ycbcr_enc = V4L2_YCBCR_ENC_601,\n\t\t.quantization = V4L2_QUANTIZATION_LIM_RANGE,\n\t\t.xfer_func = V4L2_XFER_FUNC_SRGB,\n\t};\n\tstatic const struct v4l2_mbus_framefmt out_format = {\n\t\t.width = 640,\n\t\t.height = 480,\n\t\t.code = MEDIA_BUS_FMT_UYVY8_1X16,\n\t\t.field = V4L2_FIELD_NONE,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.ycbcr_enc = V4L2_YCBCR_ENC_601,\n\t\t.quantization = V4L2_QUANTIZATION_LIM_RANGE,\n\t\t.xfer_func = V4L2_XFER_FUNC_SRGB,\n\t};\n\tstruct v4l2_subdev_stream_configs *stream_configs;\n\tunsigned int i;\n\tint ret;\n\n\t \n\n\tif (routing->num_routes > V4L2_FRAME_DESC_ENTRY_MAX)\n\t\treturn -EINVAL;\n\n\tret = v4l2_subdev_routing_validate(sd, routing,\n\t\t\t\t\t   V4L2_SUBDEV_ROUTING_ONLY_1_TO_1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = v4l2_subdev_set_routing(sd, state, routing);\n\tif (ret)\n\t\treturn ret;\n\n\tstream_configs = &state->stream_configs;\n\n\tfor (i = 0; i < stream_configs->num_configs; i++) {\n\t\tif (stream_configs->configs[i].pad == UB913_PAD_SINK)\n\t\t\tstream_configs->configs[i].fmt = in_format;\n\t\telse\n\t\t\tstream_configs->configs[i].fmt = out_format;\n\t}\n\n\treturn 0;\n}\n\nstatic int ub913_set_routing(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *state,\n\t\t\t     enum v4l2_subdev_format_whence which,\n\t\t\t     struct v4l2_subdev_krouting *routing)\n{\n\tstruct ub913_data *priv = sd_to_ub913(sd);\n\n\tif (which == V4L2_SUBDEV_FORMAT_ACTIVE && priv->enabled_source_streams)\n\t\treturn -EBUSY;\n\n\treturn _ub913_set_routing(sd, state, routing);\n}\n\nstatic int ub913_get_frame_desc(struct v4l2_subdev *sd, unsigned int pad,\n\t\t\t\tstruct v4l2_mbus_frame_desc *fd)\n{\n\tstruct ub913_data *priv = sd_to_ub913(sd);\n\tconst struct v4l2_subdev_krouting *routing;\n\tstruct v4l2_mbus_frame_desc source_fd;\n\tstruct v4l2_subdev_route *route;\n\tstruct v4l2_subdev_state *state;\n\tint ret;\n\n\tif (pad != UB913_PAD_SOURCE)\n\t\treturn -EINVAL;\n\n\tret = v4l2_subdev_call(priv->source_sd, pad, get_frame_desc,\n\t\t\t       priv->source_sd_pad, &source_fd);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(fd, 0, sizeof(*fd));\n\n\tfd->type = V4L2_MBUS_FRAME_DESC_TYPE_PARALLEL;\n\n\tstate = v4l2_subdev_lock_and_get_active_state(sd);\n\n\trouting = &state->routing;\n\n\tfor_each_active_route(routing, route) {\n\t\tunsigned int i;\n\n\t\tif (route->source_pad != pad)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < source_fd.num_entries; i++) {\n\t\t\tif (source_fd.entry[i].stream == route->sink_stream)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == source_fd.num_entries) {\n\t\t\tdev_err(&priv->client->dev,\n\t\t\t\t\"Failed to find stream from source frame desc\\n\");\n\t\t\tret = -EPIPE;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tfd->entry[fd->num_entries].stream = route->source_stream;\n\t\tfd->entry[fd->num_entries].flags = source_fd.entry[i].flags;\n\t\tfd->entry[fd->num_entries].length = source_fd.entry[i].length;\n\t\tfd->entry[fd->num_entries].pixelcode =\n\t\t\tsource_fd.entry[i].pixelcode;\n\n\t\tfd->num_entries++;\n\t}\n\nout_unlock:\n\tv4l2_subdev_unlock_state(state);\n\n\treturn ret;\n}\n\nstatic int ub913_set_fmt(struct v4l2_subdev *sd,\n\t\t\t struct v4l2_subdev_state *state,\n\t\t\t struct v4l2_subdev_format *format)\n{\n\tstruct ub913_data *priv = sd_to_ub913(sd);\n\tstruct v4l2_mbus_framefmt *fmt;\n\tconst struct ub913_format_info *finfo;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE &&\n\t    priv->enabled_source_streams)\n\t\treturn -EBUSY;\n\n\t \n\tif (format->pad == UB913_PAD_SOURCE)\n\t\treturn v4l2_subdev_get_fmt(sd, state, format);\n\n\tfinfo = ub913_find_format(format->format.code);\n\tif (!finfo) {\n\t\tfinfo = &ub913_formats[0];\n\t\tformat->format.code = finfo->incode;\n\t}\n\n\t \n\tfmt = v4l2_subdev_state_get_stream_format(state, format->pad,\n\t\t\t\t\t\t  format->stream);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\t*fmt = format->format;\n\n\t \n\tfmt = v4l2_subdev_state_get_opposite_stream_format(state, format->pad,\n\t\t\t\t\t\t\t   format->stream);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tformat->format.code = finfo->outcode;\n\n\t*fmt = format->format;\n\n\treturn 0;\n}\n\nstatic int ub913_init_cfg(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *state)\n{\n\tstruct v4l2_subdev_route routes[] = {\n\t\t{\n\t\t\t.sink_pad = UB913_PAD_SINK,\n\t\t\t.sink_stream = 0,\n\t\t\t.source_pad = UB913_PAD_SOURCE,\n\t\t\t.source_stream = 0,\n\t\t\t.flags = V4L2_SUBDEV_ROUTE_FL_ACTIVE,\n\t\t},\n\t};\n\n\tstruct v4l2_subdev_krouting routing = {\n\t\t.num_routes = ARRAY_SIZE(routes),\n\t\t.routes = routes,\n\t};\n\n\treturn _ub913_set_routing(sd, state, &routing);\n}\n\nstatic int ub913_log_status(struct v4l2_subdev *sd)\n{\n\tstruct ub913_data *priv = sd_to_ub913(sd);\n\tstruct device *dev = &priv->client->dev;\n\tu8 v = 0, v1 = 0, v2 = 0;\n\n\tub913_read(priv, UB913_REG_MODE_SEL, &v);\n\tdev_info(dev, \"MODE_SEL %#02x\\n\", v);\n\n\tub913_read(priv, UB913_REG_CRC_ERRORS_LSB, &v1);\n\tub913_read(priv, UB913_REG_CRC_ERRORS_MSB, &v2);\n\tdev_info(dev, \"CRC errors %u\\n\", v1 | (v2 << 8));\n\n\t \n\tub913_read(priv, UB913_REG_GENERAL_CFG, &v);\n\tub913_write(priv, UB913_REG_GENERAL_CFG,\n\t\t    v | UB913_REG_GENERAL_CFG_CRC_ERR_RESET);\n\tub913_write(priv, UB913_REG_GENERAL_CFG, v);\n\n\tub913_read(priv, UB913_REG_GENERAL_STATUS, &v);\n\tdev_info(dev, \"GENERAL_STATUS %#02x\\n\", v);\n\n\tub913_read(priv, UB913_REG_PLL_OVR, &v);\n\tdev_info(dev, \"PLL_OVR %#02x\\n\", v);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops ub913_subdev_core_ops = {\n\t.log_status = ub913_log_status,\n};\n\nstatic const struct v4l2_subdev_pad_ops ub913_pad_ops = {\n\t.enable_streams = ub913_enable_streams,\n\t.disable_streams = ub913_disable_streams,\n\t.set_routing = ub913_set_routing,\n\t.get_frame_desc = ub913_get_frame_desc,\n\t.get_fmt = v4l2_subdev_get_fmt,\n\t.set_fmt = ub913_set_fmt,\n\t.init_cfg = ub913_init_cfg,\n};\n\nstatic const struct v4l2_subdev_ops ub913_subdev_ops = {\n\t.core = &ub913_subdev_core_ops,\n\t.pad = &ub913_pad_ops,\n};\n\nstatic const struct media_entity_operations ub913_entity_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic int ub913_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t      struct v4l2_subdev *source_subdev,\n\t\t\t      struct v4l2_async_connection *asd)\n{\n\tstruct ub913_data *priv = sd_to_ub913(notifier->sd);\n\tstruct device *dev = &priv->client->dev;\n\tint ret;\n\n\tret = media_entity_get_fwnode_pad(&source_subdev->entity,\n\t\t\t\t\t  source_subdev->fwnode,\n\t\t\t\t\t  MEDIA_PAD_FL_SOURCE);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to find pad for %s\\n\",\n\t\t\tsource_subdev->name);\n\t\treturn ret;\n\t}\n\n\tpriv->source_sd = source_subdev;\n\tpriv->source_sd_pad = ret;\n\n\tret = media_create_pad_link(&source_subdev->entity, priv->source_sd_pad,\n\t\t\t\t    &priv->sd.entity, UB913_PAD_SINK,\n\t\t\t\t    MEDIA_LNK_FL_ENABLED |\n\t\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to link %s:%u -> %s:0\\n\",\n\t\t\tsource_subdev->name, priv->source_sd_pad,\n\t\t\tpriv->sd.name);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_async_notifier_operations ub913_notify_ops = {\n\t.bound = ub913_notify_bound,\n};\n\nstatic int ub913_v4l2_notifier_register(struct ub913_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tstruct v4l2_async_connection *asd;\n\tstruct fwnode_handle *ep_fwnode;\n\tint ret;\n\n\tep_fwnode = fwnode_graph_get_endpoint_by_id(dev_fwnode(dev),\n\t\t\t\t\t\t    UB913_PAD_SINK, 0, 0);\n\tif (!ep_fwnode) {\n\t\tdev_err(dev, \"No graph endpoint\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tv4l2_async_subdev_nf_init(&priv->notifier, &priv->sd);\n\n\tasd = v4l2_async_nf_add_fwnode_remote(&priv->notifier, ep_fwnode,\n\t\t\t\t\t      struct v4l2_async_connection);\n\n\tfwnode_handle_put(ep_fwnode);\n\n\tif (IS_ERR(asd)) {\n\t\tdev_err(dev, \"Failed to add subdev: %ld\", PTR_ERR(asd));\n\t\tv4l2_async_nf_cleanup(&priv->notifier);\n\t\treturn PTR_ERR(asd);\n\t}\n\n\tpriv->notifier.ops = &ub913_notify_ops;\n\n\tret = v4l2_async_nf_register(&priv->notifier);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register subdev_notifier\");\n\t\tv4l2_async_nf_cleanup(&priv->notifier);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ub913_v4l2_nf_unregister(struct ub913_data *priv)\n{\n\tv4l2_async_nf_unregister(&priv->notifier);\n\tv4l2_async_nf_cleanup(&priv->notifier);\n}\n\nstatic int ub913_register_clkout(struct ub913_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tconst char *name;\n\tint ret;\n\n\tname = kasprintf(GFP_KERNEL, \"ds90ub913.%s.clk_out\", dev_name(dev));\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tpriv->clkout_clk_hw = devm_clk_hw_register_fixed_factor(dev, name,\n\t\t__clk_get_name(priv->clkin), 0, 1, 2);\n\n\tkfree(name);\n\n\tif (IS_ERR(priv->clkout_clk_hw))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->clkout_clk_hw),\n\t\t\t\t     \"Cannot register clkout hw\\n\");\n\n\tret = devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get,\n\t\t\t\t\t  priv->clkout_clk_hw);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Cannot add OF clock provider\\n\");\n\n\treturn 0;\n}\n\nstatic int ub913_i2c_master_init(struct ub913_data *priv)\n{\n\t \n\tu32 scl_high = 600 + 300;  \n\tu32 scl_low = 1300 + 300;  \n\tunsigned long ref;\n\tint ret;\n\n\tref = clk_get_rate(priv->clkin) / 2;\n\n\tscl_high = div64_u64((u64)scl_high * ref, 1000000000);\n\tscl_low = div64_u64((u64)scl_low * ref, 1000000000);\n\n\tret = ub913_write(priv, UB913_REG_SCL_HIGH_TIME, scl_high);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ub913_write(priv, UB913_REG_SCL_LOW_TIME, scl_low);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ub913_add_i2c_adapter(struct ub913_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tstruct fwnode_handle *i2c_handle;\n\tint ret;\n\n\ti2c_handle = device_get_named_child_node(dev, \"i2c\");\n\tif (!i2c_handle)\n\t\treturn 0;\n\n\tret = i2c_atr_add_adapter(priv->plat_data->atr, priv->plat_data->port,\n\t\t\t\t  dev, i2c_handle);\n\n\tfwnode_handle_put(i2c_handle);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ub913_parse_dt(struct ub913_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tstruct v4l2_fwnode_endpoint vep = {\n\t\t.bus_type = V4L2_MBUS_PARALLEL,\n\t};\n\tstruct fwnode_handle *ep_fwnode;\n\tint ret;\n\n\tep_fwnode = fwnode_graph_get_endpoint_by_id(dev_fwnode(dev),\n\t\t\t\t\t\t    UB913_PAD_SINK, 0, 0);\n\tif (!ep_fwnode)\n\t\treturn dev_err_probe(dev, -ENOENT, \"No sink endpoint\\n\");\n\n\tret = v4l2_fwnode_endpoint_parse(ep_fwnode, &vep);\n\n\tfwnode_handle_put(ep_fwnode);\n\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"failed to parse sink endpoint data\\n\");\n\n\tif (vep.bus.parallel.flags & V4L2_MBUS_PCLK_SAMPLE_RISING)\n\t\tpriv->pclk_polarity_rising = true;\n\telse if (vep.bus.parallel.flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\n\t\tpriv->pclk_polarity_rising = false;\n\telse\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"bad value for 'pclk-sample'\\n\");\n\n\treturn 0;\n}\n\nstatic int ub913_hw_init(struct ub913_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tbool mode_override;\n\tu8 mode;\n\tint ret;\n\tu8 v;\n\n\tret = ub913_read(priv, UB913_REG_MODE_SEL, &v);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(v & UB913_REG_MODE_SEL_MODE_UP_TO_DATE))\n\t\treturn dev_err_probe(dev, -ENODEV,\n\t\t\t\t     \"Mode value not stabilized\\n\");\n\n\tmode_override = v & UB913_REG_MODE_SEL_MODE_OVERRIDE;\n\tmode = v & UB913_REG_MODE_SEL_MODE_MASK;\n\n\tdev_dbg(dev, \"mode from %s: %#x\\n\",\n\t\tmode_override ? \"reg\" : \"deserializer\", mode);\n\n\tret = ub913_i2c_master_init(priv);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"i2c master init failed\\n\");\n\n\tub913_read(priv, UB913_REG_GENERAL_CFG, &v);\n\tv &= ~UB913_REG_GENERAL_CFG_PCLK_RISING;\n\tv |= priv->pclk_polarity_rising ? UB913_REG_GENERAL_CFG_PCLK_RISING : 0;\n\tub913_write(priv, UB913_REG_GENERAL_CFG, v);\n\n\treturn 0;\n}\n\nstatic int ub913_subdev_init(struct ub913_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tint ret;\n\n\tv4l2_i2c_subdev_init(&priv->sd, priv->client, &ub913_subdev_ops);\n\tpriv->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_STREAMS;\n\tpriv->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tpriv->sd.entity.ops = &ub913_entity_ops;\n\n\tpriv->pads[0].flags = MEDIA_PAD_FL_SINK;\n\tpriv->pads[1].flags = MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&priv->sd.entity, 2, priv->pads);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to init pads\\n\");\n\n\tret = v4l2_subdev_init_finalize(&priv->sd);\n\tif (ret)\n\t\tgoto err_entity_cleanup;\n\n\tret = ub913_v4l2_notifier_register(priv);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret,\n\t\t\t      \"v4l2 subdev notifier register failed\\n\");\n\t\tgoto err_subdev_cleanup;\n\t}\n\n\tret = v4l2_async_register_subdev(&priv->sd);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"v4l2_async_register_subdev error\\n\");\n\t\tgoto err_unreg_notif;\n\t}\n\n\treturn 0;\n\nerr_unreg_notif:\n\tub913_v4l2_nf_unregister(priv);\nerr_subdev_cleanup:\n\tv4l2_subdev_cleanup(&priv->sd);\nerr_entity_cleanup:\n\tmedia_entity_cleanup(&priv->sd.entity);\n\n\treturn ret;\n}\n\nstatic void ub913_subdev_uninit(struct ub913_data *priv)\n{\n\tv4l2_async_unregister_subdev(&priv->sd);\n\tub913_v4l2_nf_unregister(priv);\n\tv4l2_subdev_cleanup(&priv->sd);\n\tfwnode_handle_put(priv->sd.fwnode);\n\tmedia_entity_cleanup(&priv->sd.entity);\n}\n\nstatic int ub913_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct ub913_data *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->client = client;\n\n\tpriv->plat_data = dev_get_platdata(&client->dev);\n\tif (!priv->plat_data)\n\t\treturn dev_err_probe(dev, -ENODEV, \"Platform data missing\\n\");\n\n\tpriv->regmap = devm_regmap_init_i2c(client, &ub913_regmap_config);\n\tif (IS_ERR(priv->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->regmap),\n\t\t\t\t     \"Failed to init regmap\\n\");\n\n\t \n\tpriv->clkin = devm_clk_get(dev, \"clkin\");\n\tif (IS_ERR(priv->clkin))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->clkin),\n\t\t\t\t     \"Cannot get CLKIN\\n\");\n\n\tret = ub913_parse_dt(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ub913_hw_init(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ub913_gpiochip_probe(priv);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to init gpiochip\\n\");\n\n\tret = ub913_register_clkout(priv);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"Failed to register clkout\\n\");\n\t\tgoto err_gpiochip_remove;\n\t}\n\n\tret = ub913_subdev_init(priv);\n\tif (ret)\n\t\tgoto err_gpiochip_remove;\n\n\tret = ub913_add_i2c_adapter(priv);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"failed to add remote i2c adapter\\n\");\n\t\tgoto err_subdev_uninit;\n\t}\n\n\treturn 0;\n\nerr_subdev_uninit:\n\tub913_subdev_uninit(priv);\nerr_gpiochip_remove:\n\tub913_gpiochip_remove(priv);\n\n\treturn ret;\n}\n\nstatic void ub913_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ub913_data *priv = sd_to_ub913(sd);\n\n\ti2c_atr_del_adapter(priv->plat_data->atr, priv->plat_data->port);\n\n\tub913_subdev_uninit(priv);\n\n\tub913_gpiochip_remove(priv);\n}\n\nstatic const struct i2c_device_id ub913_id[] = { { \"ds90ub913a-q1\", 0 }, {} };\nMODULE_DEVICE_TABLE(i2c, ub913_id);\n\nstatic const struct of_device_id ub913_dt_ids[] = {\n\t{ .compatible = \"ti,ds90ub913a-q1\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ub913_dt_ids);\n\nstatic struct i2c_driver ds90ub913_driver = {\n\t.probe\t\t= ub913_probe,\n\t.remove\t\t= ub913_remove,\n\t.id_table\t= ub913_id,\n\t.driver = {\n\t\t.name\t= \"ds90ub913a\",\n\t\t.of_match_table = ub913_dt_ids,\n\t},\n};\nmodule_i2c_driver(ds90ub913_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Texas Instruments DS90UB913 FPD-Link III Serializer Driver\");\nMODULE_AUTHOR(\"Luca Ceresoli <luca@lucaceresoli.net>\");\nMODULE_AUTHOR(\"Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>\");\nMODULE_IMPORT_NS(I2C_ATR);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}