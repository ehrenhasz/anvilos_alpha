{
  "module_name": "ds90ub960.c",
  "hash_id": "4bcec0e49113dd0b37b897ee1af98d98aac044c6c96635c54ffb9b103c3bc717",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ds90ub960.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/fwnode.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c-atr.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n#include <media/i2c/ds90ub9xx.h>\n#include <media/mipi-csi2.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n#define MHZ(v) ((u32)((v) * 1000000U))\n\n#define UB960_POLL_TIME_MS\t500\n\n#define UB960_MAX_RX_NPORTS\t4\n#define UB960_MAX_TX_NPORTS\t2\n#define UB960_MAX_NPORTS\t(UB960_MAX_RX_NPORTS + UB960_MAX_TX_NPORTS)\n\n#define UB960_MAX_PORT_ALIASES\t8\n\n#define UB960_NUM_BC_GPIOS\t\t4\n\n \n\n#define UB960_SR_I2C_DEV_ID\t\t\t0x00\n#define UB960_SR_RESET\t\t\t\t0x01\n#define UB960_SR_RESET_DIGITAL_RESET1\t\tBIT(1)\n#define UB960_SR_RESET_DIGITAL_RESET0\t\tBIT(0)\n#define UB960_SR_RESET_GPIO_LOCK_RELEASE\tBIT(5)\n\n#define UB960_SR_GEN_CONFIG\t\t\t0x02\n#define UB960_SR_REV_MASK\t\t\t0x03\n#define UB960_SR_DEVICE_STS\t\t\t0x04\n#define UB960_SR_PAR_ERR_THOLD_HI\t\t0x05\n#define UB960_SR_PAR_ERR_THOLD_LO\t\t0x06\n#define UB960_SR_BCC_WDOG_CTL\t\t\t0x07\n#define UB960_SR_I2C_CTL1\t\t\t0x08\n#define UB960_SR_I2C_CTL2\t\t\t0x09\n#define UB960_SR_SCL_HIGH_TIME\t\t\t0x0a\n#define UB960_SR_SCL_LOW_TIME\t\t\t0x0b\n#define UB960_SR_RX_PORT_CTL\t\t\t0x0c\n#define UB960_SR_IO_CTL\t\t\t\t0x0d\n#define UB960_SR_GPIO_PIN_STS\t\t\t0x0e\n#define UB960_SR_GPIO_INPUT_CTL\t\t\t0x0f\n#define UB960_SR_GPIO_PIN_CTL(n)\t\t(0x10 + (n))  \n#define UB960_SR_GPIO_PIN_CTL_GPIO_OUT_SEL\t\t5\n#define UB960_SR_GPIO_PIN_CTL_GPIO_OUT_SRC_SHIFT\t2\n#define UB960_SR_GPIO_PIN_CTL_GPIO_OUT_EN\t\tBIT(0)\n\n#define UB960_SR_FS_CTL\t\t\t\t0x18\n#define UB960_SR_FS_HIGH_TIME_1\t\t\t0x19\n#define UB960_SR_FS_HIGH_TIME_0\t\t\t0x1a\n#define UB960_SR_FS_LOW_TIME_1\t\t\t0x1b\n#define UB960_SR_FS_LOW_TIME_0\t\t\t0x1c\n#define UB960_SR_MAX_FRM_HI\t\t\t0x1d\n#define UB960_SR_MAX_FRM_LO\t\t\t0x1e\n#define UB960_SR_CSI_PLL_CTL\t\t\t0x1f\n\n#define UB960_SR_FWD_CTL1\t\t\t0x20\n#define UB960_SR_FWD_CTL1_PORT_DIS(n)\t\tBIT((n) + 4)\n\n#define UB960_SR_FWD_CTL2\t\t\t0x21\n#define UB960_SR_FWD_STS\t\t\t0x22\n\n#define UB960_SR_INTERRUPT_CTL\t\t\t0x23\n#define UB960_SR_INTERRUPT_CTL_INT_EN\t\tBIT(7)\n#define UB960_SR_INTERRUPT_CTL_IE_CSI_TX0\tBIT(4)\n#define UB960_SR_INTERRUPT_CTL_IE_RX(n)\t\tBIT((n))  \n\n#define UB960_SR_INTERRUPT_STS\t\t\t0x24\n#define UB960_SR_INTERRUPT_STS_INT\t\tBIT(7)\n#define UB960_SR_INTERRUPT_STS_IS_CSI_TX(n)\tBIT(4 + (n))  \n#define UB960_SR_INTERRUPT_STS_IS_RX(n)\t\tBIT((n))  \n\n#define UB960_SR_TS_CONFIG\t\t\t0x25\n#define UB960_SR_TS_CONTROL\t\t\t0x26\n#define UB960_SR_TS_LINE_HI\t\t\t0x27\n#define UB960_SR_TS_LINE_LO\t\t\t0x28\n#define UB960_SR_TS_STATUS\t\t\t0x29\n#define UB960_SR_TIMESTAMP_P0_HI\t\t0x2a\n#define UB960_SR_TIMESTAMP_P0_LO\t\t0x2b\n#define UB960_SR_TIMESTAMP_P1_HI\t\t0x2c\n#define UB960_SR_TIMESTAMP_P1_LO\t\t0x2d\n\n#define UB960_SR_CSI_PORT_SEL\t\t\t0x32\n\n#define UB960_TR_CSI_CTL\t\t\t0x33\n#define UB960_TR_CSI_CTL_CSI_CAL_EN\t\tBIT(6)\n#define UB960_TR_CSI_CTL_CSI_CONTS_CLOCK\tBIT(1)\n#define UB960_TR_CSI_CTL_CSI_ENABLE\t\tBIT(0)\n\n#define UB960_TR_CSI_CTL2\t\t\t0x34\n#define UB960_TR_CSI_STS\t\t\t0x35\n#define UB960_TR_CSI_TX_ICR\t\t\t0x36\n\n#define UB960_TR_CSI_TX_ISR\t\t\t0x37\n#define UB960_TR_CSI_TX_ISR_IS_CSI_SYNC_ERROR\tBIT(3)\n#define UB960_TR_CSI_TX_ISR_IS_CSI_PASS_ERROR\tBIT(1)\n\n#define UB960_TR_CSI_TEST_CTL\t\t\t0x38\n#define UB960_TR_CSI_TEST_PATT_HI\t\t0x39\n#define UB960_TR_CSI_TEST_PATT_LO\t\t0x3a\n\n#define UB960_XR_SFILTER_CFG\t\t\t0x41\n#define UB960_XR_SFILTER_CFG_SFILTER_MAX_SHIFT\t4\n#define UB960_XR_SFILTER_CFG_SFILTER_MIN_SHIFT\t0\n\n#define UB960_XR_AEQ_CTL1\t\t\t0x42\n#define UB960_XR_AEQ_CTL1_AEQ_ERR_CTL_FPD_CLK\tBIT(6)\n#define UB960_XR_AEQ_CTL1_AEQ_ERR_CTL_ENCODING\tBIT(5)\n#define UB960_XR_AEQ_CTL1_AEQ_ERR_CTL_PARITY\tBIT(4)\n#define UB960_XR_AEQ_CTL1_AEQ_ERR_CTL_MASK        \\\n\t(UB960_XR_AEQ_CTL1_AEQ_ERR_CTL_FPD_CLK |  \\\n\t UB960_XR_AEQ_CTL1_AEQ_ERR_CTL_ENCODING | \\\n\t UB960_XR_AEQ_CTL1_AEQ_ERR_CTL_PARITY)\n#define UB960_XR_AEQ_CTL1_AEQ_SFILTER_EN\tBIT(0)\n\n#define UB960_XR_AEQ_ERR_THOLD\t\t\t0x43\n\n#define UB960_RR_BCC_ERR_CTL\t\t\t0x46\n#define UB960_RR_BCC_STATUS\t\t\t0x47\n#define UB960_RR_BCC_STATUS_SEQ_ERROR\t\tBIT(5)\n#define UB960_RR_BCC_STATUS_MASTER_ERR\t\tBIT(4)\n#define UB960_RR_BCC_STATUS_MASTER_TO\t\tBIT(3)\n#define UB960_RR_BCC_STATUS_SLAVE_ERR\t\tBIT(2)\n#define UB960_RR_BCC_STATUS_SLAVE_TO\t\tBIT(1)\n#define UB960_RR_BCC_STATUS_RESP_ERR\t\tBIT(0)\n#define UB960_RR_BCC_STATUS_ERROR_MASK                                    \\\n\t(UB960_RR_BCC_STATUS_SEQ_ERROR | UB960_RR_BCC_STATUS_MASTER_ERR | \\\n\t UB960_RR_BCC_STATUS_MASTER_TO | UB960_RR_BCC_STATUS_SLAVE_ERR |  \\\n\t UB960_RR_BCC_STATUS_SLAVE_TO | UB960_RR_BCC_STATUS_RESP_ERR)\n\n#define UB960_RR_FPD3_CAP\t\t\t0x4a\n#define UB960_RR_RAW_EMBED_DTYPE\t\t0x4b\n#define UB960_RR_RAW_EMBED_DTYPE_LINES_SHIFT\t6\n\n#define UB960_SR_FPD3_PORT_SEL\t\t\t0x4c\n\n#define UB960_RR_RX_PORT_STS1\t\t\t0x4d\n#define UB960_RR_RX_PORT_STS1_BCC_CRC_ERROR\tBIT(5)\n#define UB960_RR_RX_PORT_STS1_LOCK_STS_CHG\tBIT(4)\n#define UB960_RR_RX_PORT_STS1_BCC_SEQ_ERROR\tBIT(3)\n#define UB960_RR_RX_PORT_STS1_PARITY_ERROR\tBIT(2)\n#define UB960_RR_RX_PORT_STS1_PORT_PASS\t\tBIT(1)\n#define UB960_RR_RX_PORT_STS1_LOCK_STS\t\tBIT(0)\n#define UB960_RR_RX_PORT_STS1_ERROR_MASK       \\\n\t(UB960_RR_RX_PORT_STS1_BCC_CRC_ERROR | \\\n\t UB960_RR_RX_PORT_STS1_BCC_SEQ_ERROR | \\\n\t UB960_RR_RX_PORT_STS1_PARITY_ERROR)\n\n#define UB960_RR_RX_PORT_STS2\t\t\t0x4e\n#define UB960_RR_RX_PORT_STS2_LINE_LEN_UNSTABLE\tBIT(7)\n#define UB960_RR_RX_PORT_STS2_LINE_LEN_CHG\tBIT(6)\n#define UB960_RR_RX_PORT_STS2_FPD3_ENCODE_ERROR\tBIT(5)\n#define UB960_RR_RX_PORT_STS2_BUFFER_ERROR\tBIT(4)\n#define UB960_RR_RX_PORT_STS2_CSI_ERROR\t\tBIT(3)\n#define UB960_RR_RX_PORT_STS2_FREQ_STABLE\tBIT(2)\n#define UB960_RR_RX_PORT_STS2_CABLE_FAULT\tBIT(1)\n#define UB960_RR_RX_PORT_STS2_LINE_CNT_CHG\tBIT(0)\n#define UB960_RR_RX_PORT_STS2_ERROR_MASK       \\\n\tUB960_RR_RX_PORT_STS2_BUFFER_ERROR\n\n#define UB960_RR_RX_FREQ_HIGH\t\t\t0x4f\n#define UB960_RR_RX_FREQ_LOW\t\t\t0x50\n#define UB960_RR_SENSOR_STS_0\t\t\t0x51\n#define UB960_RR_SENSOR_STS_1\t\t\t0x52\n#define UB960_RR_SENSOR_STS_2\t\t\t0x53\n#define UB960_RR_SENSOR_STS_3\t\t\t0x54\n#define UB960_RR_RX_PAR_ERR_HI\t\t\t0x55\n#define UB960_RR_RX_PAR_ERR_LO\t\t\t0x56\n#define UB960_RR_BIST_ERR_COUNT\t\t\t0x57\n\n#define UB960_RR_BCC_CONFIG\t\t\t0x58\n#define UB960_RR_BCC_CONFIG_I2C_PASS_THROUGH\tBIT(6)\n#define UB960_RR_BCC_CONFIG_BC_FREQ_SEL_MASK\tGENMASK(2, 0)\n\n#define UB960_RR_DATAPATH_CTL1\t\t\t0x59\n#define UB960_RR_DATAPATH_CTL2\t\t\t0x5a\n#define UB960_RR_SER_ID\t\t\t\t0x5b\n#define UB960_RR_SER_ALIAS_ID\t\t\t0x5c\n\n \n#define UB960_RR_SLAVE_ID(n)\t\t\t(0x5d + (n))\n#define UB960_RR_SLAVE_ALIAS(n)\t\t\t(0x65 + (n))\n\n#define UB960_RR_PORT_CONFIG\t\t\t0x6d\n#define UB960_RR_PORT_CONFIG_FPD3_MODE_MASK\tGENMASK(1, 0)\n\n#define UB960_RR_BC_GPIO_CTL(n)\t\t\t(0x6e + (n))  \n#define UB960_RR_RAW10_ID\t\t\t0x70\n#define UB960_RR_RAW10_ID_VC_SHIFT\t\t6\n#define UB960_RR_RAW10_ID_DT_SHIFT\t\t0\n\n#define UB960_RR_RAW12_ID\t\t\t0x71\n#define UB960_RR_CSI_VC_MAP\t\t\t0x72\n#define UB960_RR_CSI_VC_MAP_SHIFT(x)\t\t((x) * 2)\n\n#define UB960_RR_LINE_COUNT_HI\t\t\t0x73\n#define UB960_RR_LINE_COUNT_LO\t\t\t0x74\n#define UB960_RR_LINE_LEN_1\t\t\t0x75\n#define UB960_RR_LINE_LEN_0\t\t\t0x76\n#define UB960_RR_FREQ_DET_CTL\t\t\t0x77\n#define UB960_RR_MAILBOX_1\t\t\t0x78\n#define UB960_RR_MAILBOX_2\t\t\t0x79\n\n#define UB960_RR_CSI_RX_STS\t\t\t0x7a\n#define UB960_RR_CSI_RX_STS_LENGTH_ERR\t\tBIT(3)\n#define UB960_RR_CSI_RX_STS_CKSUM_ERR\t\tBIT(2)\n#define UB960_RR_CSI_RX_STS_ECC2_ERR\t\tBIT(1)\n#define UB960_RR_CSI_RX_STS_ECC1_ERR\t\tBIT(0)\n#define UB960_RR_CSI_RX_STS_ERROR_MASK                                    \\\n\t(UB960_RR_CSI_RX_STS_LENGTH_ERR | UB960_RR_CSI_RX_STS_CKSUM_ERR | \\\n\t UB960_RR_CSI_RX_STS_ECC2_ERR | UB960_RR_CSI_RX_STS_ECC1_ERR)\n\n#define UB960_RR_CSI_ERR_COUNTER\t\t0x7b\n#define UB960_RR_PORT_CONFIG2\t\t\t0x7c\n#define UB960_RR_PORT_CONFIG2_RAW10_8BIT_CTL_MASK GENMASK(7, 6)\n#define UB960_RR_PORT_CONFIG2_RAW10_8BIT_CTL_SHIFT 6\n\n#define UB960_RR_PORT_CONFIG2_LV_POL_LOW\tBIT(1)\n#define UB960_RR_PORT_CONFIG2_FV_POL_LOW\tBIT(0)\n\n#define UB960_RR_PORT_PASS_CTL\t\t\t0x7d\n#define UB960_RR_SEN_INT_RISE_CTL\t\t0x7e\n#define UB960_RR_SEN_INT_FALL_CTL\t\t0x7f\n\n#define UB960_SR_CSI_FRAME_COUNT_HI(n)\t\t(0x90 + 8 * (n))\n#define UB960_SR_CSI_FRAME_COUNT_LO(n)\t\t(0x91 + 8 * (n))\n#define UB960_SR_CSI_FRAME_ERR_COUNT_HI(n)\t(0x92 + 8 * (n))\n#define UB960_SR_CSI_FRAME_ERR_COUNT_LO(n)\t(0x93 + 8 * (n))\n#define UB960_SR_CSI_LINE_COUNT_HI(n)\t\t(0x94 + 8 * (n))\n#define UB960_SR_CSI_LINE_COUNT_LO(n)\t\t(0x95 + 8 * (n))\n#define UB960_SR_CSI_LINE_ERR_COUNT_HI(n)\t(0x96 + 8 * (n))\n#define UB960_SR_CSI_LINE_ERR_COUNT_LO(n)\t(0x97 + 8 * (n))\n\n#define UB960_XR_REFCLK_FREQ\t\t\t0xa5\t \n\n#define UB960_RR_VC_ID_MAP(x)\t\t\t(0xa0 + (x))  \n\n#define UB960_SR_IND_ACC_CTL\t\t\t0xb0\n#define UB960_SR_IND_ACC_CTL_IA_AUTO_INC\tBIT(1)\n\n#define UB960_SR_IND_ACC_ADDR\t\t\t0xb1\n#define UB960_SR_IND_ACC_DATA\t\t\t0xb2\n#define UB960_SR_BIST_CONTROL\t\t\t0xb3\n#define UB960_SR_MODE_IDX_STS\t\t\t0xb8\n#define UB960_SR_LINK_ERROR_COUNT\t\t0xb9\n#define UB960_SR_FPD3_ENC_CTL\t\t\t0xba\n#define UB960_SR_FV_MIN_TIME\t\t\t0xbc\n#define UB960_SR_GPIO_PD_CTL\t\t\t0xbe\n\n#define UB960_SR_FPD_RATE_CFG\t\t\t0xc2\t \n#define UB960_SR_CSI_PLL_DIV\t\t\t0xc9\t \n\n#define UB960_RR_PORT_DEBUG\t\t\t0xd0\n#define UB960_RR_AEQ_CTL2\t\t\t0xd2\n#define UB960_RR_AEQ_CTL2_SET_AEQ_FLOOR\t\tBIT(2)\n\n#define UB960_RR_AEQ_STATUS\t\t\t0xd3\n#define UB960_RR_AEQ_STATUS_STATUS_2\t\tGENMASK(5, 3)\n#define UB960_RR_AEQ_STATUS_STATUS_1\t\tGENMASK(2, 0)\n\n#define UB960_RR_AEQ_BYPASS\t\t\t0xd4\n#define UB960_RR_AEQ_BYPASS_EQ_STAGE1_VALUE_SHIFT\t5\n#define UB960_RR_AEQ_BYPASS_EQ_STAGE1_VALUE_MASK\tGENMASK(7, 5)\n#define UB960_RR_AEQ_BYPASS_EQ_STAGE2_VALUE_SHIFT\t1\n#define UB960_RR_AEQ_BYPASS_EQ_STAGE2_VALUE_MASK\tGENMASK(3, 1)\n#define UB960_RR_AEQ_BYPASS_ENABLE\t\t\tBIT(0)\n\n#define UB960_RR_AEQ_MIN_MAX\t\t\t0xd5\n#define UB960_RR_AEQ_MIN_MAX_AEQ_MAX_SHIFT\t4\n#define UB960_RR_AEQ_MIN_MAX_AEQ_FLOOR_SHIFT\t0\n\n#define UB960_RR_SFILTER_STS_0\t\t\t0xd6\n#define UB960_RR_SFILTER_STS_1\t\t\t0xd7\n#define UB960_RR_PORT_ICR_HI\t\t\t0xd8\n#define UB960_RR_PORT_ICR_LO\t\t\t0xd9\n#define UB960_RR_PORT_ISR_HI\t\t\t0xda\n#define UB960_RR_PORT_ISR_LO\t\t\t0xdb\n#define UB960_RR_FC_GPIO_STS\t\t\t0xdc\n#define UB960_RR_FC_GPIO_ICR\t\t\t0xdd\n#define UB960_RR_SEN_INT_RISE_STS\t\t0xde\n#define UB960_RR_SEN_INT_FALL_STS\t\t0xdf\n\n#define UB960_RR_CHANNEL_MODE\t\t\t0xe4\t \n\n#define UB960_SR_FPD3_RX_ID(n)\t\t\t(0xf0 + (n))\n#define UB960_SR_FPD3_RX_ID_LEN\t\t\t6\n\n#define UB960_SR_I2C_RX_ID(n)\t\t\t(0xf8 + (n))  \n\n \n#define UB960_IND_TARGET_PAT_GEN\t\t0x00\n#define UB960_IND_TARGET_RX_ANA(n)\t\t(0x01 + (n))\n#define UB960_IND_TARGET_CSI_CSIPLL_REG_1\t0x92\t \n#define UB960_IND_TARGET_CSI_ANA\t\t0x07\n\n \n\n#define UB960_IR_PGEN_CTL\t\t\t0x01\n#define UB960_IR_PGEN_CTL_PGEN_ENABLE\t\tBIT(0)\n\n#define UB960_IR_PGEN_CFG\t\t\t0x02\n#define UB960_IR_PGEN_CSI_DI\t\t\t0x03\n#define UB960_IR_PGEN_LINE_SIZE1\t\t0x04\n#define UB960_IR_PGEN_LINE_SIZE0\t\t0x05\n#define UB960_IR_PGEN_BAR_SIZE1\t\t\t0x06\n#define UB960_IR_PGEN_BAR_SIZE0\t\t\t0x07\n#define UB960_IR_PGEN_ACT_LPF1\t\t\t0x08\n#define UB960_IR_PGEN_ACT_LPF0\t\t\t0x09\n#define UB960_IR_PGEN_TOT_LPF1\t\t\t0x0a\n#define UB960_IR_PGEN_TOT_LPF0\t\t\t0x0b\n#define UB960_IR_PGEN_LINE_PD1\t\t\t0x0c\n#define UB960_IR_PGEN_LINE_PD0\t\t\t0x0d\n#define UB960_IR_PGEN_VBP\t\t\t0x0e\n#define UB960_IR_PGEN_VFP\t\t\t0x0f\n#define UB960_IR_PGEN_COLOR(n)\t\t\t(0x10 + (n))  \n\n#define UB960_IR_RX_ANA_STROBE_SET_CLK\t\t0x08\n#define UB960_IR_RX_ANA_STROBE_SET_CLK_NO_EXTRA_DELAY\tBIT(3)\n#define UB960_IR_RX_ANA_STROBE_SET_CLK_DELAY_MASK\tGENMASK(2, 0)\n\n#define UB960_IR_RX_ANA_STROBE_SET_DATA\t\t0x09\n#define UB960_IR_RX_ANA_STROBE_SET_DATA_NO_EXTRA_DELAY\tBIT(3)\n#define UB960_IR_RX_ANA_STROBE_SET_DATA_DELAY_MASK\tGENMASK(2, 0)\n\n \n\n#define UB960_MIN_AEQ_STROBE_POS -7\n#define UB960_MAX_AEQ_STROBE_POS  7\n\n#define UB960_MANUAL_STROBE_EXTRA_DELAY 6\n\n#define UB960_MIN_MANUAL_STROBE_POS -(7 + UB960_MANUAL_STROBE_EXTRA_DELAY)\n#define UB960_MAX_MANUAL_STROBE_POS  (7 + UB960_MANUAL_STROBE_EXTRA_DELAY)\n#define UB960_NUM_MANUAL_STROBE_POS  (UB960_MAX_MANUAL_STROBE_POS - UB960_MIN_MANUAL_STROBE_POS + 1)\n\n#define UB960_MIN_EQ_LEVEL  0\n#define UB960_MAX_EQ_LEVEL  14\n#define UB960_NUM_EQ_LEVELS (UB960_MAX_EQ_LEVEL - UB960_MIN_EQ_LEVEL + 1)\n\nstruct ub960_hw_data {\n\tconst char *model;\n\tu8 num_rxports;\n\tu8 num_txports;\n\tbool is_ub9702;\n\tbool is_fpdlink4;\n};\n\nenum ub960_rxport_mode {\n\tRXPORT_MODE_RAW10 = 0,\n\tRXPORT_MODE_RAW12_HF = 1,\n\tRXPORT_MODE_RAW12_LF = 2,\n\tRXPORT_MODE_CSI2_SYNC = 3,\n\tRXPORT_MODE_CSI2_NONSYNC = 4,\n\tRXPORT_MODE_LAST = RXPORT_MODE_CSI2_NONSYNC,\n};\n\nenum ub960_rxport_cdr {\n\tRXPORT_CDR_FPD3 = 0,\n\tRXPORT_CDR_FPD4 = 1,\n\tRXPORT_CDR_LAST = RXPORT_CDR_FPD4,\n};\n\nstruct ub960_rxport {\n\tstruct ub960_data      *priv;\n\tu8                      nport;\t \n\n\tstruct {\n\t\tstruct v4l2_subdev *sd;\n\t\tu16 pad;\n\t\tstruct fwnode_handle *ep_fwnode;\n\t} source;\n\n\t \n\tstruct {\n\t\tstruct fwnode_handle *fwnode;\n\t\tstruct i2c_client *client;\n\t\tunsigned short alias;  \n\t\tstruct ds90ub9xx_platform_data pdata;\n\t} ser;\n\n\tenum ub960_rxport_mode  rx_mode;\n\tenum ub960_rxport_cdr\tcdr_mode;\n\n\tu8\t\t\tlv_fv_pol;\t \n\n\tstruct regulator\t*vpoc;\n\n\t \n\tstruct {\n\t\tbool manual_eq;\n\n\t\ts8 strobe_pos;\n\n\t\tunion {\n\t\t\tstruct {\n\t\t\t\tu8 eq_level_min;\n\t\t\t\tu8 eq_level_max;\n\t\t\t} aeq;\n\n\t\t\tstruct {\n\t\t\t\tu8 eq_level;\n\t\t\t} manual;\n\t\t};\n\t} eq;\n\n\tconst struct i2c_client *aliased_clients[UB960_MAX_PORT_ALIASES];\n};\n\nstruct ub960_asd {\n\tstruct v4l2_async_connection base;\n\tstruct ub960_rxport *rxport;\n};\n\nstatic inline struct ub960_asd *to_ub960_asd(struct v4l2_async_connection *asd)\n{\n\treturn container_of(asd, struct ub960_asd, base);\n}\n\nstruct ub960_txport {\n\tstruct ub960_data      *priv;\n\tu8                      nport;\t \n\n\tu32 num_data_lanes;\n\tbool non_continous_clk;\n};\n\nstruct ub960_data {\n\tconst struct ub960_hw_data\t*hw_data;\n\tstruct i2c_client\t*client;  \n\tstruct regmap\t\t*regmap;\n\n\t \n\tstruct mutex\t\treg_lock;\n\n\tstruct clk\t\t*refclk;\n\n\tstruct regulator\t*vddio;\n\n\tstruct gpio_desc\t*pd_gpio;\n\tstruct delayed_work\tpoll_work;\n\tstruct ub960_rxport\t*rxports[UB960_MAX_RX_NPORTS];\n\tstruct ub960_txport\t*txports[UB960_MAX_TX_NPORTS];\n\n\tstruct v4l2_subdev\tsd;\n\tstruct media_pad\tpads[UB960_MAX_NPORTS];\n\n\tstruct v4l2_ctrl_handler   ctrl_handler;\n\tstruct v4l2_async_notifier notifier;\n\n\tu32 tx_data_rate;\t\t \n\ts64 tx_link_freq[1];\n\n\tstruct i2c_atr *atr;\n\n\tstruct {\n\t\tu8 rxport;\n\t\tu8 txport;\n\t\tu8 indirect_target;\n\t} reg_current;\n\n\tbool streaming;\n\n\tu8 stored_fwd_ctl;\n\n\tu64 stream_enable_mask[UB960_MAX_NPORTS];\n\n\t \n\tstruct {\n\t\tbool manual;\n\n\t\ts8 min;\n\t\ts8 max;\n\t} strobe;\n};\n\nstatic inline struct ub960_data *sd_to_ub960(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct ub960_data, sd);\n}\n\nstatic inline bool ub960_pad_is_sink(struct ub960_data *priv, u32 pad)\n{\n\treturn pad < priv->hw_data->num_rxports;\n}\n\nstatic inline bool ub960_pad_is_source(struct ub960_data *priv, u32 pad)\n{\n\treturn pad >= priv->hw_data->num_rxports;\n}\n\nstatic inline unsigned int ub960_pad_to_port(struct ub960_data *priv, u32 pad)\n{\n\tif (ub960_pad_is_sink(priv, pad))\n\t\treturn pad;\n\telse\n\t\treturn pad - priv->hw_data->num_rxports;\n}\n\nstruct ub960_format_info {\n\tu32 code;\n\tu32 bpp;\n\tu8 datatype;\n\tbool meta;\n};\n\nstatic const struct ub960_format_info ub960_formats[] = {\n\t{ .code = MEDIA_BUS_FMT_YUYV8_1X16, .bpp = 16, .datatype = MIPI_CSI2_DT_YUV422_8B, },\n\t{ .code = MEDIA_BUS_FMT_UYVY8_1X16, .bpp = 16, .datatype = MIPI_CSI2_DT_YUV422_8B, },\n\t{ .code = MEDIA_BUS_FMT_VYUY8_1X16, .bpp = 16, .datatype = MIPI_CSI2_DT_YUV422_8B, },\n\t{ .code = MEDIA_BUS_FMT_YVYU8_1X16, .bpp = 16, .datatype = MIPI_CSI2_DT_YUV422_8B, },\n\n\t{ .code = MEDIA_BUS_FMT_SBGGR12_1X12, .bpp = 12, .datatype = MIPI_CSI2_DT_RAW12, },\n\t{ .code = MEDIA_BUS_FMT_SGBRG12_1X12, .bpp = 12, .datatype = MIPI_CSI2_DT_RAW12, },\n\t{ .code = MEDIA_BUS_FMT_SGRBG12_1X12, .bpp = 12, .datatype = MIPI_CSI2_DT_RAW12, },\n\t{ .code = MEDIA_BUS_FMT_SRGGB12_1X12, .bpp = 12, .datatype = MIPI_CSI2_DT_RAW12, },\n};\n\nstatic const struct ub960_format_info *ub960_find_format(u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ub960_formats); i++) {\n\t\tif (ub960_formats[i].code == code)\n\t\t\treturn &ub960_formats[i];\n\t}\n\n\treturn NULL;\n}\n\n \n\nstatic int ub960_read(struct ub960_data *priv, u8 reg, u8 *val)\n{\n\tstruct device *dev = &priv->client->dev;\n\tunsigned int v;\n\tint ret;\n\n\tmutex_lock(&priv->reg_lock);\n\n\tret = regmap_read(priv->regmap, reg, &v);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: cannot read register 0x%02x (%d)!\\n\",\n\t\t\t__func__, reg, ret);\n\t\tgoto out_unlock;\n\t}\n\n\t*val = v;\n\nout_unlock:\n\tmutex_unlock(&priv->reg_lock);\n\n\treturn ret;\n}\n\nstatic int ub960_write(struct ub960_data *priv, u8 reg, u8 val)\n{\n\tstruct device *dev = &priv->client->dev;\n\tint ret;\n\n\tmutex_lock(&priv->reg_lock);\n\n\tret = regmap_write(priv->regmap, reg, val);\n\tif (ret)\n\t\tdev_err(dev, \"%s: cannot write register 0x%02x (%d)!\\n\",\n\t\t\t__func__, reg, ret);\n\n\tmutex_unlock(&priv->reg_lock);\n\n\treturn ret;\n}\n\nstatic int ub960_update_bits(struct ub960_data *priv, u8 reg, u8 mask, u8 val)\n{\n\tstruct device *dev = &priv->client->dev;\n\tint ret;\n\n\tmutex_lock(&priv->reg_lock);\n\n\tret = regmap_update_bits(priv->regmap, reg, mask, val);\n\tif (ret)\n\t\tdev_err(dev, \"%s: cannot update register 0x%02x (%d)!\\n\",\n\t\t\t__func__, reg, ret);\n\n\tmutex_unlock(&priv->reg_lock);\n\n\treturn ret;\n}\n\nstatic int ub960_read16(struct ub960_data *priv, u8 reg, u16 *val)\n{\n\tstruct device *dev = &priv->client->dev;\n\t__be16 __v;\n\tint ret;\n\n\tmutex_lock(&priv->reg_lock);\n\n\tret = regmap_bulk_read(priv->regmap, reg, &__v, sizeof(__v));\n\tif (ret) {\n\t\tdev_err(dev, \"%s: cannot read register 0x%02x (%d)!\\n\",\n\t\t\t__func__, reg, ret);\n\t\tgoto out_unlock;\n\t}\n\n\t*val = be16_to_cpu(__v);\n\nout_unlock:\n\tmutex_unlock(&priv->reg_lock);\n\n\treturn ret;\n}\n\nstatic int ub960_rxport_select(struct ub960_data *priv, u8 nport)\n{\n\tstruct device *dev = &priv->client->dev;\n\tint ret;\n\n\tlockdep_assert_held(&priv->reg_lock);\n\n\tif (priv->reg_current.rxport == nport)\n\t\treturn 0;\n\n\tret = regmap_write(priv->regmap, UB960_SR_FPD3_PORT_SEL,\n\t\t\t   (nport << 4) | BIT(nport));\n\tif (ret) {\n\t\tdev_err(dev, \"%s: cannot select rxport %d (%d)!\\n\", __func__,\n\t\t\tnport, ret);\n\t\treturn ret;\n\t}\n\n\tpriv->reg_current.rxport = nport;\n\n\treturn 0;\n}\n\nstatic int ub960_rxport_read(struct ub960_data *priv, u8 nport, u8 reg, u8 *val)\n{\n\tstruct device *dev = &priv->client->dev;\n\tunsigned int v;\n\tint ret;\n\n\tmutex_lock(&priv->reg_lock);\n\n\tret = ub960_rxport_select(priv, nport);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = regmap_read(priv->regmap, reg, &v);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: cannot read register 0x%02x (%d)!\\n\",\n\t\t\t__func__, reg, ret);\n\t\tgoto out_unlock;\n\t}\n\n\t*val = v;\n\nout_unlock:\n\tmutex_unlock(&priv->reg_lock);\n\n\treturn ret;\n}\n\nstatic int ub960_rxport_write(struct ub960_data *priv, u8 nport, u8 reg, u8 val)\n{\n\tstruct device *dev = &priv->client->dev;\n\tint ret;\n\n\tmutex_lock(&priv->reg_lock);\n\n\tret = ub960_rxport_select(priv, nport);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = regmap_write(priv->regmap, reg, val);\n\tif (ret)\n\t\tdev_err(dev, \"%s: cannot write register 0x%02x (%d)!\\n\",\n\t\t\t__func__, reg, ret);\n\nout_unlock:\n\tmutex_unlock(&priv->reg_lock);\n\n\treturn ret;\n}\n\nstatic int ub960_rxport_update_bits(struct ub960_data *priv, u8 nport, u8 reg,\n\t\t\t\t    u8 mask, u8 val)\n{\n\tstruct device *dev = &priv->client->dev;\n\tint ret;\n\n\tmutex_lock(&priv->reg_lock);\n\n\tret = ub960_rxport_select(priv, nport);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = regmap_update_bits(priv->regmap, reg, mask, val);\n\tif (ret)\n\t\tdev_err(dev, \"%s: cannot update register 0x%02x (%d)!\\n\",\n\t\t\t__func__, reg, ret);\n\nout_unlock:\n\tmutex_unlock(&priv->reg_lock);\n\n\treturn ret;\n}\n\nstatic int ub960_rxport_read16(struct ub960_data *priv, u8 nport, u8 reg,\n\t\t\t       u16 *val)\n{\n\tstruct device *dev = &priv->client->dev;\n\t__be16 __v;\n\tint ret;\n\n\tmutex_lock(&priv->reg_lock);\n\n\tret = ub960_rxport_select(priv, nport);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = regmap_bulk_read(priv->regmap, reg, &__v, sizeof(__v));\n\tif (ret) {\n\t\tdev_err(dev, \"%s: cannot read register 0x%02x (%d)!\\n\",\n\t\t\t__func__, reg, ret);\n\t\tgoto out_unlock;\n\t}\n\n\t*val = be16_to_cpu(__v);\n\nout_unlock:\n\tmutex_unlock(&priv->reg_lock);\n\n\treturn ret;\n}\n\nstatic int ub960_txport_select(struct ub960_data *priv, u8 nport)\n{\n\tstruct device *dev = &priv->client->dev;\n\tint ret;\n\n\tlockdep_assert_held(&priv->reg_lock);\n\n\tif (priv->reg_current.txport == nport)\n\t\treturn 0;\n\n\tret = regmap_write(priv->regmap, UB960_SR_CSI_PORT_SEL,\n\t\t\t   (nport << 4) | BIT(nport));\n\tif (ret) {\n\t\tdev_err(dev, \"%s: cannot select tx port %d (%d)!\\n\", __func__,\n\t\t\tnport, ret);\n\t\treturn ret;\n\t}\n\n\tpriv->reg_current.txport = nport;\n\n\treturn 0;\n}\n\nstatic int ub960_txport_read(struct ub960_data *priv, u8 nport, u8 reg, u8 *val)\n{\n\tstruct device *dev = &priv->client->dev;\n\tunsigned int v;\n\tint ret;\n\n\tmutex_lock(&priv->reg_lock);\n\n\tret = ub960_txport_select(priv, nport);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = regmap_read(priv->regmap, reg, &v);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: cannot read register 0x%02x (%d)!\\n\",\n\t\t\t__func__, reg, ret);\n\t\tgoto out_unlock;\n\t}\n\n\t*val = v;\n\nout_unlock:\n\tmutex_unlock(&priv->reg_lock);\n\n\treturn ret;\n}\n\nstatic int ub960_txport_write(struct ub960_data *priv, u8 nport, u8 reg, u8 val)\n{\n\tstruct device *dev = &priv->client->dev;\n\tint ret;\n\n\tmutex_lock(&priv->reg_lock);\n\n\tret = ub960_txport_select(priv, nport);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = regmap_write(priv->regmap, reg, val);\n\tif (ret)\n\t\tdev_err(dev, \"%s: cannot write register 0x%02x (%d)!\\n\",\n\t\t\t__func__, reg, ret);\n\nout_unlock:\n\tmutex_unlock(&priv->reg_lock);\n\n\treturn ret;\n}\n\nstatic int ub960_txport_update_bits(struct ub960_data *priv, u8 nport, u8 reg,\n\t\t\t\t    u8 mask, u8 val)\n{\n\tstruct device *dev = &priv->client->dev;\n\tint ret;\n\n\tmutex_lock(&priv->reg_lock);\n\n\tret = ub960_txport_select(priv, nport);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = regmap_update_bits(priv->regmap, reg, mask, val);\n\tif (ret)\n\t\tdev_err(dev, \"%s: cannot update register 0x%02x (%d)!\\n\",\n\t\t\t__func__, reg, ret);\n\nout_unlock:\n\tmutex_unlock(&priv->reg_lock);\n\n\treturn ret;\n}\n\nstatic int ub960_select_ind_reg_block(struct ub960_data *priv, u8 block)\n{\n\tstruct device *dev = &priv->client->dev;\n\tint ret;\n\n\tlockdep_assert_held(&priv->reg_lock);\n\n\tif (priv->reg_current.indirect_target == block)\n\t\treturn 0;\n\n\tret = regmap_write(priv->regmap, UB960_SR_IND_ACC_CTL, block << 2);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: cannot select indirect target %u (%d)!\\n\",\n\t\t\t__func__, block, ret);\n\t\treturn ret;\n\t}\n\n\tpriv->reg_current.indirect_target = block;\n\n\treturn 0;\n}\n\nstatic int ub960_read_ind(struct ub960_data *priv, u8 block, u8 reg, u8 *val)\n{\n\tstruct device *dev = &priv->client->dev;\n\tunsigned int v;\n\tint ret;\n\n\tmutex_lock(&priv->reg_lock);\n\n\tret = ub960_select_ind_reg_block(priv, block);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = regmap_write(priv->regmap, UB960_SR_IND_ACC_ADDR, reg);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Write to IND_ACC_ADDR failed when reading %u:%x02x: %d\\n\",\n\t\t\tblock, reg, ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = regmap_read(priv->regmap, UB960_SR_IND_ACC_DATA, &v);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Write to IND_ACC_DATA failed when reading %u:%x02x: %d\\n\",\n\t\t\tblock, reg, ret);\n\t\tgoto out_unlock;\n\t}\n\n\t*val = v;\n\nout_unlock:\n\tmutex_unlock(&priv->reg_lock);\n\n\treturn ret;\n}\n\nstatic int ub960_write_ind(struct ub960_data *priv, u8 block, u8 reg, u8 val)\n{\n\tstruct device *dev = &priv->client->dev;\n\tint ret;\n\n\tmutex_lock(&priv->reg_lock);\n\n\tret = ub960_select_ind_reg_block(priv, block);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = regmap_write(priv->regmap, UB960_SR_IND_ACC_ADDR, reg);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Write to IND_ACC_ADDR failed when writing %u:%x02x: %d\\n\",\n\t\t\tblock, reg, ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = regmap_write(priv->regmap, UB960_SR_IND_ACC_DATA, val);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Write to IND_ACC_DATA failed when writing %u:%x02x: %d\\n\",\n\t\t\tblock, reg, ret);\n\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tmutex_unlock(&priv->reg_lock);\n\n\treturn ret;\n}\n\nstatic int ub960_ind_update_bits(struct ub960_data *priv, u8 block, u8 reg,\n\t\t\t\t u8 mask, u8 val)\n{\n\tstruct device *dev = &priv->client->dev;\n\tint ret;\n\n\tmutex_lock(&priv->reg_lock);\n\n\tret = ub960_select_ind_reg_block(priv, block);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = regmap_write(priv->regmap, UB960_SR_IND_ACC_ADDR, reg);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Write to IND_ACC_ADDR failed when updating %u:%x02x: %d\\n\",\n\t\t\tblock, reg, ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = regmap_update_bits(priv->regmap, UB960_SR_IND_ACC_DATA, mask,\n\t\t\t\t val);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Write to IND_ACC_DATA failed when updating %u:%x02x: %d\\n\",\n\t\t\tblock, reg, ret);\n\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tmutex_unlock(&priv->reg_lock);\n\n\treturn ret;\n}\n\n \n\nstatic int ub960_atr_attach_client(struct i2c_atr *atr, u32 chan_id,\n\t\t\t\t   const struct i2c_client *client, u16 alias)\n{\n\tstruct ub960_data *priv = i2c_atr_get_driver_data(atr);\n\tstruct ub960_rxport *rxport = priv->rxports[chan_id];\n\tstruct device *dev = &priv->client->dev;\n\tunsigned int reg_idx;\n\n\tfor (reg_idx = 0; reg_idx < ARRAY_SIZE(rxport->aliased_clients); reg_idx++) {\n\t\tif (!rxport->aliased_clients[reg_idx])\n\t\t\tbreak;\n\t}\n\n\tif (reg_idx == ARRAY_SIZE(rxport->aliased_clients)) {\n\t\tdev_err(dev, \"rx%u: alias pool exhausted\\n\", rxport->nport);\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\trxport->aliased_clients[reg_idx] = client;\n\n\tub960_rxport_write(priv, chan_id, UB960_RR_SLAVE_ID(reg_idx),\n\t\t\t   client->addr << 1);\n\tub960_rxport_write(priv, chan_id, UB960_RR_SLAVE_ALIAS(reg_idx),\n\t\t\t   alias << 1);\n\n\tdev_dbg(dev, \"rx%u: client 0x%02x assigned alias 0x%02x at slot %u\\n\",\n\t\trxport->nport, client->addr, alias, reg_idx);\n\n\treturn 0;\n}\n\nstatic void ub960_atr_detach_client(struct i2c_atr *atr, u32 chan_id,\n\t\t\t\t    const struct i2c_client *client)\n{\n\tstruct ub960_data *priv = i2c_atr_get_driver_data(atr);\n\tstruct ub960_rxport *rxport = priv->rxports[chan_id];\n\tstruct device *dev = &priv->client->dev;\n\tunsigned int reg_idx;\n\n\tfor (reg_idx = 0; reg_idx < ARRAY_SIZE(rxport->aliased_clients); reg_idx++) {\n\t\tif (rxport->aliased_clients[reg_idx] == client)\n\t\t\tbreak;\n\t}\n\n\tif (reg_idx == ARRAY_SIZE(rxport->aliased_clients)) {\n\t\tdev_err(dev, \"rx%u: client 0x%02x is not mapped!\\n\",\n\t\t\trxport->nport, client->addr);\n\t\treturn;\n\t}\n\n\trxport->aliased_clients[reg_idx] = NULL;\n\n\tub960_rxport_write(priv, chan_id, UB960_RR_SLAVE_ALIAS(reg_idx), 0);\n\n\tdev_dbg(dev, \"rx%u: client 0x%02x released at slot %u\\n\", rxport->nport,\n\t\tclient->addr, reg_idx);\n}\n\nstatic const struct i2c_atr_ops ub960_atr_ops = {\n\t.attach_client = ub960_atr_attach_client,\n\t.detach_client = ub960_atr_detach_client,\n};\n\nstatic int ub960_init_atr(struct ub960_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tstruct i2c_adapter *parent_adap = priv->client->adapter;\n\n\tpriv->atr = i2c_atr_new(parent_adap, dev, &ub960_atr_ops,\n\t\t\t\tpriv->hw_data->num_rxports);\n\tif (IS_ERR(priv->atr))\n\t\treturn PTR_ERR(priv->atr);\n\n\ti2c_atr_set_driver_data(priv->atr, priv);\n\n\treturn 0;\n}\n\nstatic void ub960_uninit_atr(struct ub960_data *priv)\n{\n\ti2c_atr_delete(priv->atr);\n\tpriv->atr = NULL;\n}\n\n \n\nstatic int ub960_parse_dt_txport(struct ub960_data *priv,\n\t\t\t\t struct fwnode_handle *ep_fwnode,\n\t\t\t\t u8 nport)\n{\n\tstruct device *dev = &priv->client->dev;\n\tstruct v4l2_fwnode_endpoint vep = {};\n\tstruct ub960_txport *txport;\n\tint ret;\n\n\ttxport = kzalloc(sizeof(*txport), GFP_KERNEL);\n\tif (!txport)\n\t\treturn -ENOMEM;\n\n\ttxport->priv = priv;\n\ttxport->nport = nport;\n\n\tvep.bus_type = V4L2_MBUS_CSI2_DPHY;\n\tret = v4l2_fwnode_endpoint_alloc_parse(ep_fwnode, &vep);\n\tif (ret) {\n\t\tdev_err(dev, \"tx%u: failed to parse endpoint data\\n\", nport);\n\t\tgoto err_free_txport;\n\t}\n\n\ttxport->non_continous_clk = vep.bus.mipi_csi2.flags &\n\t\t\t\t    V4L2_MBUS_CSI2_NONCONTINUOUS_CLOCK;\n\n\ttxport->num_data_lanes = vep.bus.mipi_csi2.num_data_lanes;\n\n\tif (vep.nr_of_link_frequencies != 1) {\n\t\tret = -EINVAL;\n\t\tgoto err_free_vep;\n\t}\n\n\tpriv->tx_link_freq[0] = vep.link_frequencies[0];\n\tpriv->tx_data_rate = priv->tx_link_freq[0] * 2;\n\n\tif (priv->tx_data_rate != MHZ(1600) &&\n\t    priv->tx_data_rate != MHZ(1200) &&\n\t    priv->tx_data_rate != MHZ(800) &&\n\t    priv->tx_data_rate != MHZ(400)) {\n\t\tdev_err(dev, \"tx%u: invalid 'link-frequencies' value\\n\", nport);\n\t\tret = -EINVAL;\n\t\tgoto err_free_vep;\n\t}\n\n\tv4l2_fwnode_endpoint_free(&vep);\n\n\tpriv->txports[nport] = txport;\n\n\treturn 0;\n\nerr_free_vep:\n\tv4l2_fwnode_endpoint_free(&vep);\nerr_free_txport:\n\tkfree(txport);\n\n\treturn ret;\n}\n\nstatic void ub960_csi_handle_events(struct ub960_data *priv, u8 nport)\n{\n\tstruct device *dev = &priv->client->dev;\n\tu8 csi_tx_isr;\n\tint ret;\n\n\tret = ub960_txport_read(priv, nport, UB960_TR_CSI_TX_ISR, &csi_tx_isr);\n\tif (ret)\n\t\treturn;\n\n\tif (csi_tx_isr & UB960_TR_CSI_TX_ISR_IS_CSI_SYNC_ERROR)\n\t\tdev_warn(dev, \"TX%u: CSI_SYNC_ERROR\\n\", nport);\n\n\tif (csi_tx_isr & UB960_TR_CSI_TX_ISR_IS_CSI_PASS_ERROR)\n\t\tdev_warn(dev, \"TX%u: CSI_PASS_ERROR\\n\", nport);\n}\n\n \n\nstatic int ub960_rxport_enable_vpocs(struct ub960_data *priv)\n{\n\tunsigned int nport;\n\tint ret;\n\n\tfor (nport = 0; nport < priv->hw_data->num_rxports; nport++) {\n\t\tstruct ub960_rxport *rxport = priv->rxports[nport];\n\n\t\tif (!rxport || !rxport->vpoc)\n\t\t\tcontinue;\n\n\t\tret = regulator_enable(rxport->vpoc);\n\t\tif (ret)\n\t\t\tgoto err_disable_vpocs;\n\t}\n\n\treturn 0;\n\nerr_disable_vpocs:\n\twhile (nport--) {\n\t\tstruct ub960_rxport *rxport = priv->rxports[nport];\n\n\t\tif (!rxport || !rxport->vpoc)\n\t\t\tcontinue;\n\n\t\tregulator_disable(rxport->vpoc);\n\t}\n\n\treturn ret;\n}\n\nstatic void ub960_rxport_disable_vpocs(struct ub960_data *priv)\n{\n\tunsigned int nport;\n\n\tfor (nport = 0; nport < priv->hw_data->num_rxports; nport++) {\n\t\tstruct ub960_rxport *rxport = priv->rxports[nport];\n\n\t\tif (!rxport || !rxport->vpoc)\n\t\t\tcontinue;\n\n\t\tregulator_disable(rxport->vpoc);\n\t}\n}\n\nstatic void ub960_rxport_clear_errors(struct ub960_data *priv,\n\t\t\t\t      unsigned int nport)\n{\n\tu8 v;\n\n\tub960_rxport_read(priv, nport, UB960_RR_RX_PORT_STS1, &v);\n\tub960_rxport_read(priv, nport, UB960_RR_RX_PORT_STS2, &v);\n\tub960_rxport_read(priv, nport, UB960_RR_CSI_RX_STS, &v);\n\tub960_rxport_read(priv, nport, UB960_RR_BCC_STATUS, &v);\n\n\tub960_rxport_read(priv, nport, UB960_RR_RX_PAR_ERR_HI, &v);\n\tub960_rxport_read(priv, nport, UB960_RR_RX_PAR_ERR_LO, &v);\n\n\tub960_rxport_read(priv, nport, UB960_RR_CSI_ERR_COUNTER, &v);\n}\n\nstatic void ub960_clear_rx_errors(struct ub960_data *priv)\n{\n\tunsigned int nport;\n\n\tfor (nport = 0; nport < priv->hw_data->num_rxports; nport++)\n\t\tub960_rxport_clear_errors(priv, nport);\n}\n\nstatic int ub960_rxport_get_strobe_pos(struct ub960_data *priv,\n\t\t\t\t       unsigned int nport, s8 *strobe_pos)\n{\n\tu8 v;\n\tu8 clk_delay, data_delay;\n\tint ret;\n\n\tub960_read_ind(priv, UB960_IND_TARGET_RX_ANA(nport),\n\t\t       UB960_IR_RX_ANA_STROBE_SET_CLK, &v);\n\n\tclk_delay = (v & UB960_IR_RX_ANA_STROBE_SET_CLK_NO_EXTRA_DELAY) ?\n\t\t\t    0 : UB960_MANUAL_STROBE_EXTRA_DELAY;\n\n\tub960_read_ind(priv, UB960_IND_TARGET_RX_ANA(nport),\n\t\t       UB960_IR_RX_ANA_STROBE_SET_DATA, &v);\n\n\tdata_delay = (v & UB960_IR_RX_ANA_STROBE_SET_DATA_NO_EXTRA_DELAY) ?\n\t\t\t     0 : UB960_MANUAL_STROBE_EXTRA_DELAY;\n\n\tret = ub960_rxport_read(priv, nport, UB960_RR_SFILTER_STS_0, &v);\n\tif (ret)\n\t\treturn ret;\n\n\tclk_delay += v & UB960_IR_RX_ANA_STROBE_SET_CLK_DELAY_MASK;\n\n\tub960_rxport_read(priv, nport, UB960_RR_SFILTER_STS_1, &v);\n\tif (ret)\n\t\treturn ret;\n\n\tdata_delay += v & UB960_IR_RX_ANA_STROBE_SET_DATA_DELAY_MASK;\n\n\t*strobe_pos = data_delay - clk_delay;\n\n\treturn 0;\n}\n\nstatic void ub960_rxport_set_strobe_pos(struct ub960_data *priv,\n\t\t\t\t\tunsigned int nport, s8 strobe_pos)\n{\n\tu8 clk_delay, data_delay;\n\n\tclk_delay = UB960_IR_RX_ANA_STROBE_SET_CLK_NO_EXTRA_DELAY;\n\tdata_delay = UB960_IR_RX_ANA_STROBE_SET_DATA_NO_EXTRA_DELAY;\n\n\tif (strobe_pos < UB960_MIN_AEQ_STROBE_POS)\n\t\tclk_delay = abs(strobe_pos) - UB960_MANUAL_STROBE_EXTRA_DELAY;\n\telse if (strobe_pos > UB960_MAX_AEQ_STROBE_POS)\n\t\tdata_delay = strobe_pos - UB960_MANUAL_STROBE_EXTRA_DELAY;\n\telse if (strobe_pos < 0)\n\t\tclk_delay = abs(strobe_pos) | UB960_IR_RX_ANA_STROBE_SET_CLK_NO_EXTRA_DELAY;\n\telse if (strobe_pos > 0)\n\t\tdata_delay = strobe_pos | UB960_IR_RX_ANA_STROBE_SET_DATA_NO_EXTRA_DELAY;\n\n\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport),\n\t\t\tUB960_IR_RX_ANA_STROBE_SET_CLK, clk_delay);\n\n\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport),\n\t\t\tUB960_IR_RX_ANA_STROBE_SET_DATA, data_delay);\n}\n\nstatic void ub960_rxport_set_strobe_range(struct ub960_data *priv,\n\t\t\t\t\t  s8 strobe_min, s8 strobe_max)\n{\n\t \n\tstrobe_min -= UB960_MIN_AEQ_STROBE_POS;\n\tstrobe_max -= UB960_MIN_AEQ_STROBE_POS;\n\n\tub960_write(priv, UB960_XR_SFILTER_CFG,\n\t\t    ((u8)strobe_min << UB960_XR_SFILTER_CFG_SFILTER_MIN_SHIFT) |\n\t\t    ((u8)strobe_max << UB960_XR_SFILTER_CFG_SFILTER_MAX_SHIFT));\n}\n\nstatic int ub960_rxport_get_eq_level(struct ub960_data *priv,\n\t\t\t\t     unsigned int nport, u8 *eq_level)\n{\n\tint ret;\n\tu8 v;\n\n\tret = ub960_rxport_read(priv, nport, UB960_RR_AEQ_STATUS, &v);\n\tif (ret)\n\t\treturn ret;\n\n\t*eq_level = (v & UB960_RR_AEQ_STATUS_STATUS_1) +\n\t\t    (v & UB960_RR_AEQ_STATUS_STATUS_2);\n\n\treturn 0;\n}\n\nstatic void ub960_rxport_set_eq_level(struct ub960_data *priv,\n\t\t\t\t      unsigned int nport, u8 eq_level)\n{\n\tu8 eq_stage_1_select_value, eq_stage_2_select_value;\n\tconst unsigned int eq_stage_max = 7;\n\tu8 v;\n\n\tif (eq_level <= eq_stage_max) {\n\t\teq_stage_1_select_value = eq_level;\n\t\teq_stage_2_select_value = 0;\n\t} else {\n\t\teq_stage_1_select_value = eq_stage_max;\n\t\teq_stage_2_select_value = eq_level - eq_stage_max;\n\t}\n\n\tub960_rxport_read(priv, nport, UB960_RR_AEQ_BYPASS, &v);\n\n\tv &= ~(UB960_RR_AEQ_BYPASS_EQ_STAGE1_VALUE_MASK |\n\t       UB960_RR_AEQ_BYPASS_EQ_STAGE2_VALUE_MASK);\n\tv |= eq_stage_1_select_value << UB960_RR_AEQ_BYPASS_EQ_STAGE1_VALUE_SHIFT;\n\tv |= eq_stage_2_select_value << UB960_RR_AEQ_BYPASS_EQ_STAGE2_VALUE_SHIFT;\n\tv |= UB960_RR_AEQ_BYPASS_ENABLE;\n\n\tub960_rxport_write(priv, nport, UB960_RR_AEQ_BYPASS, v);\n}\n\nstatic void ub960_rxport_set_eq_range(struct ub960_data *priv,\n\t\t\t\t      unsigned int nport, u8 eq_min, u8 eq_max)\n{\n\tub960_rxport_write(priv, nport, UB960_RR_AEQ_MIN_MAX,\n\t\t\t   (eq_min << UB960_RR_AEQ_MIN_MAX_AEQ_FLOOR_SHIFT) |\n\t\t\t   (eq_max << UB960_RR_AEQ_MIN_MAX_AEQ_MAX_SHIFT));\n\n\t \n\tub960_rxport_update_bits(priv, nport, UB960_RR_AEQ_CTL2,\n\t\t\t\t UB960_RR_AEQ_CTL2_SET_AEQ_FLOOR,\n\t\t\t\t UB960_RR_AEQ_CTL2_SET_AEQ_FLOOR);\n}\n\nstatic void ub960_rxport_config_eq(struct ub960_data *priv, unsigned int nport)\n{\n\tstruct ub960_rxport *rxport = priv->rxports[nport];\n\n\t \n\n\tif (priv->strobe.manual) {\n\t\t \n\t\tub960_update_bits(priv, UB960_XR_AEQ_CTL1,\n\t\t\t\t  UB960_XR_AEQ_CTL1_AEQ_SFILTER_EN, 0);\n\t} else {\n\t\t \n\t\tub960_write(priv, UB960_XR_AEQ_CTL1,\n\t\t\t    UB960_XR_AEQ_CTL1_AEQ_ERR_CTL_MASK |\n\t\t\t\t    UB960_XR_AEQ_CTL1_AEQ_SFILTER_EN);\n\n\t\t \n\t\tub960_rxport_set_strobe_range(priv, priv->strobe.min,\n\t\t\t\t\t      priv->strobe.max);\n\t}\n\n\t \n\n\tif (priv->strobe.manual)\n\t\tub960_rxport_set_strobe_pos(priv, nport, rxport->eq.strobe_pos);\n\telse\n\t\tub960_rxport_set_strobe_pos(priv, nport, 0);\n\n\tif (rxport->eq.manual_eq) {\n\t\tub960_rxport_set_eq_level(priv, nport,\n\t\t\t\t\t  rxport->eq.manual.eq_level);\n\n\t\t \n\t\tub960_rxport_update_bits(priv, nport, UB960_RR_AEQ_BYPASS,\n\t\t\t\t\t UB960_RR_AEQ_BYPASS_ENABLE,\n\t\t\t\t\t UB960_RR_AEQ_BYPASS_ENABLE);\n\t} else {\n\t\tub960_rxport_set_eq_range(priv, nport,\n\t\t\t\t\t  rxport->eq.aeq.eq_level_min,\n\t\t\t\t\t  rxport->eq.aeq.eq_level_max);\n\n\t\t \n\t\tub960_rxport_update_bits(priv, nport, UB960_RR_AEQ_BYPASS,\n\t\t\t\t\t UB960_RR_AEQ_BYPASS_ENABLE, 0);\n\t}\n}\n\nstatic int ub960_rxport_link_ok(struct ub960_data *priv, unsigned int nport,\n\t\t\t\tbool *ok)\n{\n\tu8 rx_port_sts1, rx_port_sts2;\n\tu16 parity_errors;\n\tu8 csi_rx_sts;\n\tu8 csi_err_cnt;\n\tu8 bcc_sts;\n\tint ret;\n\tbool errors;\n\n\tret = ub960_rxport_read(priv, nport, UB960_RR_RX_PORT_STS1,\n\t\t\t\t&rx_port_sts1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(rx_port_sts1 & UB960_RR_RX_PORT_STS1_LOCK_STS)) {\n\t\t*ok = false;\n\t\treturn 0;\n\t}\n\n\tret = ub960_rxport_read(priv, nport, UB960_RR_RX_PORT_STS2,\n\t\t\t\t&rx_port_sts2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ub960_rxport_read(priv, nport, UB960_RR_CSI_RX_STS, &csi_rx_sts);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ub960_rxport_read(priv, nport, UB960_RR_CSI_ERR_COUNTER,\n\t\t\t\t&csi_err_cnt);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ub960_rxport_read(priv, nport, UB960_RR_BCC_STATUS, &bcc_sts);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ub960_rxport_read16(priv, nport, UB960_RR_RX_PAR_ERR_HI,\n\t\t\t\t  &parity_errors);\n\tif (ret)\n\t\treturn ret;\n\n\terrors = (rx_port_sts1 & UB960_RR_RX_PORT_STS1_ERROR_MASK) ||\n\t\t (rx_port_sts2 & UB960_RR_RX_PORT_STS2_ERROR_MASK) ||\n\t\t (bcc_sts & UB960_RR_BCC_STATUS_ERROR_MASK) ||\n\t\t (csi_rx_sts & UB960_RR_CSI_RX_STS_ERROR_MASK) || csi_err_cnt ||\n\t\t parity_errors;\n\n\t*ok = !errors;\n\n\treturn 0;\n}\n\n \nstatic int ub960_rxport_wait_locks(struct ub960_data *priv,\n\t\t\t\t   unsigned long port_mask,\n\t\t\t\t   unsigned int *lock_mask)\n{\n\tstruct device *dev = &priv->client->dev;\n\tunsigned long timeout;\n\tunsigned int link_ok_mask;\n\tunsigned int missing;\n\tunsigned int loops;\n\tu8 nport;\n\tint ret;\n\n\tif (port_mask == 0) {\n\t\tif (lock_mask)\n\t\t\t*lock_mask = 0;\n\t\treturn 0;\n\t}\n\n\tif (port_mask >= BIT(priv->hw_data->num_rxports))\n\t\treturn -EINVAL;\n\n\ttimeout = jiffies + msecs_to_jiffies(1000);\n\tloops = 0;\n\tlink_ok_mask = 0;\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tmissing = 0;\n\n\t\tfor_each_set_bit(nport, &port_mask,\n\t\t\t\t priv->hw_data->num_rxports) {\n\t\t\tstruct ub960_rxport *rxport = priv->rxports[nport];\n\t\t\tbool ok;\n\n\t\t\tif (!rxport)\n\t\t\t\tcontinue;\n\n\t\t\tret = ub960_rxport_link_ok(priv, nport, &ok);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tif (!ok || !(link_ok_mask & BIT(nport)))\n\t\t\t\tmissing++;\n\n\t\t\tif (ok)\n\t\t\t\tlink_ok_mask |= BIT(nport);\n\t\t\telse\n\t\t\t\tlink_ok_mask &= ~BIT(nport);\n\t\t}\n\n\t\tloops++;\n\n\t\tif (missing == 0)\n\t\t\tbreak;\n\n\t\tmsleep(50);\n\t}\n\n\tif (lock_mask)\n\t\t*lock_mask = link_ok_mask;\n\n\tdev_dbg(dev, \"Wait locks done in %u loops\\n\", loops);\n\tfor_each_set_bit(nport, &port_mask, priv->hw_data->num_rxports) {\n\t\tstruct ub960_rxport *rxport = priv->rxports[nport];\n\t\ts8 strobe_pos, eq_level;\n\t\tu16 v;\n\n\t\tif (!rxport)\n\t\t\tcontinue;\n\n\t\tif (!(link_ok_mask & BIT(nport))) {\n\t\t\tdev_dbg(dev, \"\\trx%u: not locked\\n\", nport);\n\t\t\tcontinue;\n\t\t}\n\n\t\tub960_rxport_read16(priv, nport, UB960_RR_RX_FREQ_HIGH, &v);\n\n\t\tret = ub960_rxport_get_strobe_pos(priv, nport, &strobe_pos);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ub960_rxport_get_eq_level(priv, nport, &eq_level);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdev_dbg(dev, \"\\trx%u: locked, SP: %d, EQ: %u, freq %llu Hz\\n\",\n\t\t\tnport, strobe_pos, eq_level, (v * 1000000ULL) >> 8);\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned long ub960_calc_bc_clk_rate_ub960(struct ub960_data *priv,\n\t\t\t\t\t\t  struct ub960_rxport *rxport)\n{\n\tunsigned int mult;\n\tunsigned int div;\n\n\tswitch (rxport->rx_mode) {\n\tcase RXPORT_MODE_RAW10:\n\tcase RXPORT_MODE_RAW12_HF:\n\tcase RXPORT_MODE_RAW12_LF:\n\t\tmult = 1;\n\t\tdiv = 10;\n\t\tbreak;\n\n\tcase RXPORT_MODE_CSI2_SYNC:\n\t\tmult = 2;\n\t\tdiv = 1;\n\t\tbreak;\n\n\tcase RXPORT_MODE_CSI2_NONSYNC:\n\t\tmult = 2;\n\t\tdiv = 5;\n\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn clk_get_rate(priv->refclk) * mult / div;\n}\n\nstatic unsigned long ub960_calc_bc_clk_rate_ub9702(struct ub960_data *priv,\n\t\t\t\t\t\t   struct ub960_rxport *rxport)\n{\n\tswitch (rxport->rx_mode) {\n\tcase RXPORT_MODE_RAW10:\n\tcase RXPORT_MODE_RAW12_HF:\n\tcase RXPORT_MODE_RAW12_LF:\n\t\treturn 2359400;\n\n\tcase RXPORT_MODE_CSI2_SYNC:\n\t\treturn 47187500;\n\n\tcase RXPORT_MODE_CSI2_NONSYNC:\n\t\treturn 9437500;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int ub960_rxport_add_serializer(struct ub960_data *priv, u8 nport)\n{\n\tstruct ub960_rxport *rxport = priv->rxports[nport];\n\tstruct device *dev = &priv->client->dev;\n\tstruct ds90ub9xx_platform_data *ser_pdata = &rxport->ser.pdata;\n\tstruct i2c_board_info ser_info = {\n\t\t.of_node = to_of_node(rxport->ser.fwnode),\n\t\t.fwnode = rxport->ser.fwnode,\n\t\t.platform_data = ser_pdata,\n\t};\n\n\tser_pdata->port = nport;\n\tser_pdata->atr = priv->atr;\n\tif (priv->hw_data->is_ub9702)\n\t\tser_pdata->bc_rate = ub960_calc_bc_clk_rate_ub9702(priv, rxport);\n\telse\n\t\tser_pdata->bc_rate = ub960_calc_bc_clk_rate_ub960(priv, rxport);\n\n\t \n\tser_info.addr = rxport->ser.alias;\n\trxport->ser.client =\n\t\ti2c_new_client_device(priv->client->adapter, &ser_info);\n\tif (IS_ERR(rxport->ser.client)) {\n\t\tdev_err(dev, \"rx%u: cannot add %s i2c device\", nport,\n\t\t\tser_info.type);\n\t\treturn PTR_ERR(rxport->ser.client);\n\t}\n\n\tdev_dbg(dev, \"rx%u: remote serializer at alias 0x%02x (%u-%04x)\\n\",\n\t\tnport, rxport->ser.client->addr,\n\t\trxport->ser.client->adapter->nr, rxport->ser.client->addr);\n\n\treturn 0;\n}\n\nstatic void ub960_rxport_remove_serializer(struct ub960_data *priv, u8 nport)\n{\n\tstruct ub960_rxport *rxport = priv->rxports[nport];\n\n\ti2c_unregister_device(rxport->ser.client);\n\trxport->ser.client = NULL;\n}\n\n \nstatic int ub960_rxport_add_serializers(struct ub960_data *priv)\n{\n\tunsigned int nport;\n\tint ret;\n\n\tfor (nport = 0; nport < priv->hw_data->num_rxports; nport++) {\n\t\tstruct ub960_rxport *rxport = priv->rxports[nport];\n\n\t\tif (!rxport)\n\t\t\tcontinue;\n\n\t\tret = ub960_rxport_add_serializer(priv, nport);\n\t\tif (ret)\n\t\t\tgoto err_remove_sers;\n\t}\n\n\treturn 0;\n\nerr_remove_sers:\n\twhile (nport--) {\n\t\tstruct ub960_rxport *rxport = priv->rxports[nport];\n\n\t\tif (!rxport)\n\t\t\tcontinue;\n\n\t\tub960_rxport_remove_serializer(priv, nport);\n\t}\n\n\treturn ret;\n}\n\nstatic void ub960_rxport_remove_serializers(struct ub960_data *priv)\n{\n\tunsigned int nport;\n\n\tfor (nport = 0; nport < priv->hw_data->num_rxports; nport++) {\n\t\tstruct ub960_rxport *rxport = priv->rxports[nport];\n\n\t\tif (!rxport)\n\t\t\tcontinue;\n\n\t\tub960_rxport_remove_serializer(priv, nport);\n\t}\n}\n\nstatic void ub960_init_tx_port(struct ub960_data *priv,\n\t\t\t       struct ub960_txport *txport)\n{\n\tunsigned int nport = txport->nport;\n\tu8 csi_ctl = 0;\n\n\t \n\tif (priv->tx_data_rate == MHZ(1600))\n\t\tcsi_ctl |= UB960_TR_CSI_CTL_CSI_CAL_EN;\n\n\tcsi_ctl |= (4 - txport->num_data_lanes) << 4;\n\n\tif (!txport->non_continous_clk)\n\t\tcsi_ctl |= UB960_TR_CSI_CTL_CSI_CONTS_CLOCK;\n\n\tub960_txport_write(priv, nport, UB960_TR_CSI_CTL, csi_ctl);\n}\n\nstatic int ub960_init_tx_ports(struct ub960_data *priv)\n{\n\tunsigned int nport;\n\tu8 speed_select;\n\tu8 pll_div;\n\n\t \n\n\tswitch (priv->tx_data_rate) {\n\tcase MHZ(1600):\n\tdefault:\n\t\tspeed_select = 0;\n\t\tpll_div = 0x10;\n\t\tbreak;\n\tcase MHZ(1200):\n\t\tspeed_select = 1;\n\t\tpll_div = 0x18;\n\t\tbreak;\n\tcase MHZ(800):\n\t\tspeed_select = 2;\n\t\tpll_div = 0x10;\n\t\tbreak;\n\tcase MHZ(400):\n\t\tspeed_select = 3;\n\t\tpll_div = 0x10;\n\t\tbreak;\n\t}\n\n\tub960_write(priv, UB960_SR_CSI_PLL_CTL, speed_select);\n\n\tif (priv->hw_data->is_ub9702) {\n\t\tub960_write(priv, UB960_SR_CSI_PLL_DIV, pll_div);\n\n\t\tswitch (priv->tx_data_rate) {\n\t\tcase MHZ(1600):\n\t\tdefault:\n\t\t\tub960_write_ind(priv, UB960_IND_TARGET_CSI_ANA, 0x92, 0x80);\n\t\t\tub960_write_ind(priv, UB960_IND_TARGET_CSI_ANA, 0x4b, 0x2a);\n\t\t\tbreak;\n\t\tcase MHZ(800):\n\t\t\tub960_write_ind(priv, UB960_IND_TARGET_CSI_ANA, 0x92, 0x90);\n\t\t\tub960_write_ind(priv, UB960_IND_TARGET_CSI_ANA, 0x4f, 0x2a);\n\t\t\tub960_write_ind(priv, UB960_IND_TARGET_CSI_ANA, 0x4b, 0x2a);\n\t\t\tbreak;\n\t\tcase MHZ(400):\n\t\t\tub960_write_ind(priv, UB960_IND_TARGET_CSI_ANA, 0x92, 0xa0);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (nport = 0; nport < priv->hw_data->num_txports; nport++) {\n\t\tstruct ub960_txport *txport = priv->txports[nport];\n\n\t\tif (!txport)\n\t\t\tcontinue;\n\n\t\tub960_init_tx_port(priv, txport);\n\t}\n\n\treturn 0;\n}\n\nstatic void ub960_init_rx_port_ub960(struct ub960_data *priv,\n\t\t\t\t     struct ub960_rxport *rxport)\n{\n\tunsigned int nport = rxport->nport;\n\tu32 bc_freq_val;\n\n\t \n\n\tswitch (rxport->rx_mode) {\n\tcase RXPORT_MODE_RAW10:\n\tcase RXPORT_MODE_RAW12_HF:\n\tcase RXPORT_MODE_RAW12_LF:\n\t\tbc_freq_val = 0;\n\t\tbreak;\n\n\tcase RXPORT_MODE_CSI2_NONSYNC:\n\t\tbc_freq_val = 2;\n\t\tbreak;\n\n\tcase RXPORT_MODE_CSI2_SYNC:\n\t\tbc_freq_val = 6;\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tub960_rxport_update_bits(priv, nport, UB960_RR_BCC_CONFIG,\n\t\t\t\t UB960_RR_BCC_CONFIG_BC_FREQ_SEL_MASK,\n\t\t\t\t bc_freq_val);\n\n\tswitch (rxport->rx_mode) {\n\tcase RXPORT_MODE_RAW10:\n\t\t \n\t\tub960_rxport_update_bits(priv, nport, UB960_RR_PORT_CONFIG,\n\t\t\t\t\t UB960_RR_PORT_CONFIG_FPD3_MODE_MASK,\n\t\t\t\t\t 0x3);\n\n\t\t \n\t\tub960_rxport_update_bits(priv, nport, UB960_RR_PORT_CONFIG2,\n\t\t\tUB960_RR_PORT_CONFIG2_RAW10_8BIT_CTL_MASK,\n\t\t\t0x2 << UB960_RR_PORT_CONFIG2_RAW10_8BIT_CTL_SHIFT);\n\n\t\tbreak;\n\n\tcase RXPORT_MODE_RAW12_HF:\n\tcase RXPORT_MODE_RAW12_LF:\n\t\t \n\t\treturn;\n\n\tcase RXPORT_MODE_CSI2_SYNC:\n\tcase RXPORT_MODE_CSI2_NONSYNC:\n\t\t \n\t\tub960_rxport_update_bits(priv, nport, UB960_RR_PORT_CONFIG, 0x3,\n\t\t\t\t\t 0x0);\n\n\t\tbreak;\n\t}\n\n\t \n\tub960_rxport_update_bits(priv, nport, UB960_RR_PORT_CONFIG2, 0x3,\n\t\t\t\t rxport->lv_fv_pol);\n\n\t \n\tub960_rxport_write(priv, nport, UB960_RR_PORT_ICR_HI, 0x07);\n\tub960_rxport_write(priv, nport, UB960_RR_PORT_ICR_LO, 0x7f);\n\n\t \n\tub960_rxport_update_bits(priv, nport, UB960_RR_BCC_CONFIG,\n\t\t\t\t UB960_RR_BCC_CONFIG_I2C_PASS_THROUGH,\n\t\t\t\t UB960_RR_BCC_CONFIG_I2C_PASS_THROUGH);\n\n\t \n\tub960_rxport_write(priv, nport, UB960_RR_SER_ALIAS_ID,\n\t\t\t   rxport->ser.alias << 1);\n\n\t \n\tub960_rxport_config_eq(priv, nport);\n\n\t \n\tub960_update_bits(priv, UB960_SR_RX_PORT_CTL, BIT(nport), BIT(nport));\n}\n\nstatic void ub960_init_rx_port_ub9702_fpd3(struct ub960_data *priv,\n\t\t\t\t\t   struct ub960_rxport *rxport)\n{\n\tunsigned int nport = rxport->nport;\n\tu8 bc_freq_val;\n\tu8 fpd_func_mode;\n\n\tswitch (rxport->rx_mode) {\n\tcase RXPORT_MODE_RAW10:\n\t\tbc_freq_val = 0;\n\t\tfpd_func_mode = 5;\n\t\tbreak;\n\n\tcase RXPORT_MODE_RAW12_HF:\n\t\tbc_freq_val = 0;\n\t\tfpd_func_mode = 4;\n\t\tbreak;\n\n\tcase RXPORT_MODE_RAW12_LF:\n\t\tbc_freq_val = 0;\n\t\tfpd_func_mode = 6;\n\t\tbreak;\n\n\tcase RXPORT_MODE_CSI2_SYNC:\n\t\tbc_freq_val = 6;\n\t\tfpd_func_mode = 2;\n\t\tbreak;\n\n\tcase RXPORT_MODE_CSI2_NONSYNC:\n\t\tbc_freq_val = 2;\n\t\tfpd_func_mode = 2;\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tub960_rxport_update_bits(priv, nport, UB960_RR_BCC_CONFIG, 0x7,\n\t\t\t\t bc_freq_val);\n\tub960_rxport_write(priv, nport, UB960_RR_CHANNEL_MODE, fpd_func_mode);\n\n\t \n\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0xa8, 0x80);\n\n\t \n\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0x0d, 0x7f);\n\n\t \n\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0x2b, 0x04);\n\n\t \n\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0xa9, 0x23);\n\n\t \n\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0xaa, 0);\n\n\t \n\tub960_ind_update_bits(priv, UB960_IND_TARGET_RX_ANA(nport), 0x1b,\n\t\t\t      BIT(3), BIT(3));\n\n\t \n\tub960_update_bits(priv, UB960_SR_FPD_RATE_CFG, 0x3 << (nport * 2),\n\t\t\t  BIT(nport * 2));\n}\n\nstatic void ub960_init_rx_port_ub9702_fpd4_aeq(struct ub960_data *priv,\n\t\t\t\t\t       struct ub960_rxport *rxport)\n{\n\tunsigned int nport = rxport->nport;\n\tbool first_time_power_up = true;\n\n\tif (first_time_power_up) {\n\t\tu8 v;\n\n\t\t \n\t\tub960_read_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0x2c, &v);\n\n\t\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0x27, v);\n\t\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0x28, v + 1);\n\n\t\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0x2b, 0x00);\n\t}\n\n\t \n\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0x9e, 0x00);\n\n\t \n\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0x90, 0x40);\n\n\t \n\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0x2e, 0x40);\n\n\t \n\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0xf0, 0x00);\n\n\t \n\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0x71, 0x00);\n}\n\nstatic void ub960_init_rx_port_ub9702_fpd4(struct ub960_data *priv,\n\t\t\t\t\t   struct ub960_rxport *rxport)\n{\n\tunsigned int nport = rxport->nport;\n\tu8 bc_freq_val;\n\n\tswitch (rxport->rx_mode) {\n\tcase RXPORT_MODE_RAW10:\n\t\tbc_freq_val = 0;\n\t\tbreak;\n\n\tcase RXPORT_MODE_RAW12_HF:\n\t\tbc_freq_val = 0;\n\t\tbreak;\n\n\tcase RXPORT_MODE_RAW12_LF:\n\t\tbc_freq_val = 0;\n\t\tbreak;\n\n\tcase RXPORT_MODE_CSI2_SYNC:\n\t\tbc_freq_val = 6;\n\t\tbreak;\n\n\tcase RXPORT_MODE_CSI2_NONSYNC:\n\t\tbc_freq_val = 2;\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tub960_rxport_update_bits(priv, nport, UB960_RR_BCC_CONFIG, 0x7,\n\t\t\t\t bc_freq_val);\n\n\t \n\tub960_rxport_write(priv, nport, UB960_RR_CHANNEL_MODE, 0);\n\n\t \n\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0x2b, 0x04);\n\n\t \n\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0x27, 0x0);\n\t \n\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0x28, 0x23);\n\n\t \n\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0x04, 0x00);\n\t \n\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0x1b, 0x00);\n\n\t \n\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0x21, 0x2f);\n\t \n\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0x25, 0xc1);\n\n\t \n\tub960_update_bits(priv, UB960_SR_FPD_RATE_CFG, 0x3 << (nport * 2),\n\t\t\t  0 << (nport * 2));\n\n\tub960_init_rx_port_ub9702_fpd4_aeq(priv, rxport);\n}\n\nstatic void ub960_init_rx_port_ub9702(struct ub960_data *priv,\n\t\t\t\t      struct ub960_rxport *rxport)\n{\n\tunsigned int nport = rxport->nport;\n\n\tif (rxport->cdr_mode == RXPORT_CDR_FPD3)\n\t\tub960_init_rx_port_ub9702_fpd3(priv, rxport);\n\telse  \n\t\tub960_init_rx_port_ub9702_fpd4(priv, rxport);\n\n\tswitch (rxport->rx_mode) {\n\tcase RXPORT_MODE_RAW10:\n\t\t \n\t\tub960_rxport_update_bits(priv, nport, UB960_RR_PORT_CONFIG2,\n\t\t\t\t\t 0x3 << 6, 0x2 << 6);\n\n\t\tbreak;\n\n\tcase RXPORT_MODE_RAW12_HF:\n\tcase RXPORT_MODE_RAW12_LF:\n\t\t \n\t\treturn;\n\n\tcase RXPORT_MODE_CSI2_SYNC:\n\tcase RXPORT_MODE_CSI2_NONSYNC:\n\n\t\tbreak;\n\t}\n\n\t \n\tub960_rxport_update_bits(priv, nport, UB960_RR_PORT_CONFIG2, 0x3,\n\t\t\t\t rxport->lv_fv_pol);\n\n\t \n\tub960_rxport_write(priv, nport, UB960_RR_PORT_ICR_HI, 0x07);\n\tub960_rxport_write(priv, nport, UB960_RR_PORT_ICR_LO, 0x7f);\n\n\t \n\tub960_rxport_update_bits(priv, nport, UB960_RR_BCC_CONFIG,\n\t\t\t\t UB960_RR_BCC_CONFIG_I2C_PASS_THROUGH,\n\t\t\t\t UB960_RR_BCC_CONFIG_I2C_PASS_THROUGH);\n\n\t \n\tub960_rxport_write(priv, nport, UB960_RR_SER_ALIAS_ID,\n\t\t\t   rxport->ser.alias << 1);\n\n\t \n\tub960_update_bits(priv, UB960_SR_RX_PORT_CTL, BIT(nport), BIT(nport));\n\n\tif (rxport->cdr_mode == RXPORT_CDR_FPD4) {\n\t\t \n\t\tub960_write_ind(priv, UB960_IND_TARGET_RX_ANA(nport), 0x25, 0x41);\n\t}\n}\n\nstatic int ub960_init_rx_ports(struct ub960_data *priv)\n{\n\tunsigned int nport;\n\n\tfor (nport = 0; nport < priv->hw_data->num_rxports; nport++) {\n\t\tstruct ub960_rxport *rxport = priv->rxports[nport];\n\n\t\tif (!rxport)\n\t\t\tcontinue;\n\n\t\tif (priv->hw_data->is_ub9702)\n\t\t\tub960_init_rx_port_ub9702(priv, rxport);\n\t\telse\n\t\t\tub960_init_rx_port_ub960(priv, rxport);\n\t}\n\n\treturn 0;\n}\n\nstatic void ub960_rxport_handle_events(struct ub960_data *priv, u8 nport)\n{\n\tstruct device *dev = &priv->client->dev;\n\tu8 rx_port_sts1;\n\tu8 rx_port_sts2;\n\tu8 csi_rx_sts;\n\tu8 bcc_sts;\n\tint ret = 0;\n\n\t \n\tif (!ret)\n\t\tret = ub960_rxport_read(priv, nport, UB960_RR_RX_PORT_STS1,\n\t\t\t\t\t&rx_port_sts1);\n\tif (!ret)\n\t\tret = ub960_rxport_read(priv, nport, UB960_RR_RX_PORT_STS2,\n\t\t\t\t\t&rx_port_sts2);\n\tif (!ret)\n\t\tret = ub960_rxport_read(priv, nport, UB960_RR_CSI_RX_STS,\n\t\t\t\t\t&csi_rx_sts);\n\tif (!ret)\n\t\tret = ub960_rxport_read(priv, nport, UB960_RR_BCC_STATUS,\n\t\t\t\t\t&bcc_sts);\n\n\tif (ret)\n\t\treturn;\n\n\tif (rx_port_sts1 & UB960_RR_RX_PORT_STS1_PARITY_ERROR) {\n\t\tu16 v;\n\n\t\tret = ub960_rxport_read16(priv, nport, UB960_RR_RX_PAR_ERR_HI,\n\t\t\t\t\t  &v);\n\t\tif (!ret)\n\t\t\tdev_err(dev, \"rx%u parity errors: %u\\n\", nport, v);\n\t}\n\n\tif (rx_port_sts1 & UB960_RR_RX_PORT_STS1_BCC_CRC_ERROR)\n\t\tdev_err(dev, \"rx%u BCC CRC error\\n\", nport);\n\n\tif (rx_port_sts1 & UB960_RR_RX_PORT_STS1_BCC_SEQ_ERROR)\n\t\tdev_err(dev, \"rx%u BCC SEQ error\\n\", nport);\n\n\tif (rx_port_sts2 & UB960_RR_RX_PORT_STS2_LINE_LEN_UNSTABLE)\n\t\tdev_err(dev, \"rx%u line length unstable\\n\", nport);\n\n\tif (rx_port_sts2 & UB960_RR_RX_PORT_STS2_FPD3_ENCODE_ERROR)\n\t\tdev_err(dev, \"rx%u FPD3 encode error\\n\", nport);\n\n\tif (rx_port_sts2 & UB960_RR_RX_PORT_STS2_BUFFER_ERROR)\n\t\tdev_err(dev, \"rx%u buffer error\\n\", nport);\n\n\tif (csi_rx_sts)\n\t\tdev_err(dev, \"rx%u CSI error: %#02x\\n\", nport, csi_rx_sts);\n\n\tif (csi_rx_sts & UB960_RR_CSI_RX_STS_ECC1_ERR)\n\t\tdev_err(dev, \"rx%u CSI ECC1 error\\n\", nport);\n\n\tif (csi_rx_sts & UB960_RR_CSI_RX_STS_ECC2_ERR)\n\t\tdev_err(dev, \"rx%u CSI ECC2 error\\n\", nport);\n\n\tif (csi_rx_sts & UB960_RR_CSI_RX_STS_CKSUM_ERR)\n\t\tdev_err(dev, \"rx%u CSI checksum error\\n\", nport);\n\n\tif (csi_rx_sts & UB960_RR_CSI_RX_STS_LENGTH_ERR)\n\t\tdev_err(dev, \"rx%u CSI length error\\n\", nport);\n\n\tif (bcc_sts)\n\t\tdev_err(dev, \"rx%u BCC error: %#02x\\n\", nport, bcc_sts);\n\n\tif (bcc_sts & UB960_RR_BCC_STATUS_RESP_ERR)\n\t\tdev_err(dev, \"rx%u BCC response error\", nport);\n\n\tif (bcc_sts & UB960_RR_BCC_STATUS_SLAVE_TO)\n\t\tdev_err(dev, \"rx%u BCC slave timeout\", nport);\n\n\tif (bcc_sts & UB960_RR_BCC_STATUS_SLAVE_ERR)\n\t\tdev_err(dev, \"rx%u BCC slave error\", nport);\n\n\tif (bcc_sts & UB960_RR_BCC_STATUS_MASTER_TO)\n\t\tdev_err(dev, \"rx%u BCC master timeout\", nport);\n\n\tif (bcc_sts & UB960_RR_BCC_STATUS_MASTER_ERR)\n\t\tdev_err(dev, \"rx%u BCC master error\", nport);\n\n\tif (bcc_sts & UB960_RR_BCC_STATUS_SEQ_ERROR)\n\t\tdev_err(dev, \"rx%u BCC sequence error\", nport);\n\n\tif (rx_port_sts2 & UB960_RR_RX_PORT_STS2_LINE_LEN_CHG) {\n\t\tu16 v;\n\n\t\tret = ub960_rxport_read16(priv, nport, UB960_RR_LINE_LEN_1, &v);\n\t\tif (!ret)\n\t\t\tdev_dbg(dev, \"rx%u line len changed: %u\\n\", nport, v);\n\t}\n\n\tif (rx_port_sts2 & UB960_RR_RX_PORT_STS2_LINE_CNT_CHG) {\n\t\tu16 v;\n\n\t\tret = ub960_rxport_read16(priv, nport, UB960_RR_LINE_COUNT_HI,\n\t\t\t\t\t  &v);\n\t\tif (!ret)\n\t\t\tdev_dbg(dev, \"rx%u line count changed: %u\\n\", nport, v);\n\t}\n\n\tif (rx_port_sts1 & UB960_RR_RX_PORT_STS1_LOCK_STS_CHG) {\n\t\tdev_dbg(dev, \"rx%u: %s, %s, %s, %s\\n\", nport,\n\t\t\t(rx_port_sts1 & UB960_RR_RX_PORT_STS1_LOCK_STS) ?\n\t\t\t\t\"locked\" :\n\t\t\t\t\"unlocked\",\n\t\t\t(rx_port_sts1 & UB960_RR_RX_PORT_STS1_PORT_PASS) ?\n\t\t\t\t\"passed\" :\n\t\t\t\t\"not passed\",\n\t\t\t(rx_port_sts2 & UB960_RR_RX_PORT_STS2_CABLE_FAULT) ?\n\t\t\t\t\"no clock\" :\n\t\t\t\t\"clock ok\",\n\t\t\t(rx_port_sts2 & UB960_RR_RX_PORT_STS2_FREQ_STABLE) ?\n\t\t\t\t\"stable freq\" :\n\t\t\t\t\"unstable freq\");\n\t}\n}\n\n \n\n \nstatic void ub960_get_vc_maps(struct ub960_data *priv,\n\t\t\t      struct v4l2_subdev_state *state, u8 *vc)\n{\n\tu8 cur_vc[UB960_MAX_TX_NPORTS] = {};\n\tstruct v4l2_subdev_route *route;\n\tu8 handled_mask = 0;\n\n\tfor_each_active_route(&state->routing, route) {\n\t\tunsigned int rx, tx;\n\n\t\trx = ub960_pad_to_port(priv, route->sink_pad);\n\t\tif (BIT(rx) & handled_mask)\n\t\t\tcontinue;\n\n\t\ttx = ub960_pad_to_port(priv, route->source_pad);\n\n\t\tvc[rx] = cur_vc[tx]++;\n\t\thandled_mask |= BIT(rx);\n\t}\n}\n\nstatic int ub960_enable_tx_port(struct ub960_data *priv, unsigned int nport)\n{\n\tstruct device *dev = &priv->client->dev;\n\n\tdev_dbg(dev, \"enable TX port %u\\n\", nport);\n\n\treturn ub960_txport_update_bits(priv, nport, UB960_TR_CSI_CTL,\n\t\t\t\t\tUB960_TR_CSI_CTL_CSI_ENABLE,\n\t\t\t\t\tUB960_TR_CSI_CTL_CSI_ENABLE);\n}\n\nstatic void ub960_disable_tx_port(struct ub960_data *priv, unsigned int nport)\n{\n\tstruct device *dev = &priv->client->dev;\n\n\tdev_dbg(dev, \"disable TX port %u\\n\", nport);\n\n\tub960_txport_update_bits(priv, nport, UB960_TR_CSI_CTL,\n\t\t\t\t UB960_TR_CSI_CTL_CSI_ENABLE, 0);\n}\n\nstatic int ub960_enable_rx_port(struct ub960_data *priv, unsigned int nport)\n{\n\tstruct device *dev = &priv->client->dev;\n\n\tdev_dbg(dev, \"enable RX port %u\\n\", nport);\n\n\t \n\treturn ub960_update_bits(priv, UB960_SR_FWD_CTL1,\n\t\t\t\t UB960_SR_FWD_CTL1_PORT_DIS(nport), 0);\n}\n\nstatic void ub960_disable_rx_port(struct ub960_data *priv, unsigned int nport)\n{\n\tstruct device *dev = &priv->client->dev;\n\n\tdev_dbg(dev, \"disable RX port %u\\n\", nport);\n\n\t \n\tub960_update_bits(priv, UB960_SR_FWD_CTL1,\n\t\t\t  UB960_SR_FWD_CTL1_PORT_DIS(nport),\n\t\t\t  UB960_SR_FWD_CTL1_PORT_DIS(nport));\n}\n\n \nstatic int ub960_validate_stream_vcs(struct ub960_data *priv)\n{\n\tunsigned int nport;\n\tunsigned int i;\n\n\tfor (nport = 0; nport < priv->hw_data->num_rxports; nport++) {\n\t\tstruct ub960_rxport *rxport = priv->rxports[nport];\n\t\tstruct v4l2_mbus_frame_desc desc;\n\t\tint ret;\n\t\tu8 vc;\n\n\t\tif (!rxport)\n\t\t\tcontinue;\n\n\t\tret = v4l2_subdev_call(rxport->source.sd, pad, get_frame_desc,\n\t\t\t\t       rxport->source.pad, &desc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (desc.type != V4L2_MBUS_FRAME_DESC_TYPE_CSI2)\n\t\t\tcontinue;\n\n\t\tif (desc.num_entries == 0)\n\t\t\tcontinue;\n\n\t\tvc = desc.entry[0].bus.csi2.vc;\n\n\t\tfor (i = 1; i < desc.num_entries; i++) {\n\t\t\tif (vc == desc.entry[i].bus.csi2.vc)\n\t\t\t\tcontinue;\n\n\t\t\tdev_err(&priv->client->dev,\n\t\t\t\t\"rx%u: source with multiple virtual-channels is not supported\\n\",\n\t\t\t\tnport);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ub960_configure_ports_for_streaming(struct ub960_data *priv,\n\t\t\t\t\t       struct v4l2_subdev_state *state)\n{\n\tu8 fwd_ctl;\n\tstruct {\n\t\tu32 num_streams;\n\t\tu8 pixel_dt;\n\t\tu8 meta_dt;\n\t\tu32 meta_lines;\n\t\tu32 tx_port;\n\t} rx_data[UB960_MAX_RX_NPORTS] = {};\n\tu8 vc_map[UB960_MAX_RX_NPORTS] = {};\n\tstruct v4l2_subdev_route *route;\n\tunsigned int nport;\n\tint ret;\n\n\tret = ub960_validate_stream_vcs(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tub960_get_vc_maps(priv, state, vc_map);\n\n\tfor_each_active_route(&state->routing, route) {\n\t\tstruct ub960_rxport *rxport;\n\t\tstruct ub960_txport *txport;\n\t\tstruct v4l2_mbus_framefmt *fmt;\n\t\tconst struct ub960_format_info *ub960_fmt;\n\t\tunsigned int nport;\n\n\t\tnport = ub960_pad_to_port(priv, route->sink_pad);\n\n\t\trxport = priv->rxports[nport];\n\t\tif (!rxport)\n\t\t\treturn -EINVAL;\n\n\t\ttxport = priv->txports[ub960_pad_to_port(priv, route->source_pad)];\n\t\tif (!txport)\n\t\t\treturn -EINVAL;\n\n\t\trx_data[nport].tx_port = ub960_pad_to_port(priv, route->source_pad);\n\n\t\trx_data[nport].num_streams++;\n\n\t\t \n\t\tif (rxport->rx_mode == RXPORT_MODE_CSI2_SYNC ||\n\t\t    rxport->rx_mode == RXPORT_MODE_CSI2_NONSYNC)\n\t\t\tcontinue;\n\n\t\tif (rx_data[nport].num_streams > 2)\n\t\t\treturn -EPIPE;\n\n\t\tfmt = v4l2_subdev_state_get_stream_format(state,\n\t\t\t\t\t\t\t  route->sink_pad,\n\t\t\t\t\t\t\t  route->sink_stream);\n\t\tif (!fmt)\n\t\t\treturn -EPIPE;\n\n\t\tub960_fmt = ub960_find_format(fmt->code);\n\t\tif (!ub960_fmt)\n\t\t\treturn -EPIPE;\n\n\t\tif (ub960_fmt->meta) {\n\t\t\tif (fmt->height > 3) {\n\t\t\t\tdev_err(&priv->client->dev,\n\t\t\t\t\t\"rx%u: unsupported metadata height %u\\n\",\n\t\t\t\t\tnport, fmt->height);\n\t\t\t\treturn -EPIPE;\n\t\t\t}\n\n\t\t\trx_data[nport].meta_dt = ub960_fmt->datatype;\n\t\t\trx_data[nport].meta_lines = fmt->height;\n\t\t} else {\n\t\t\trx_data[nport].pixel_dt = ub960_fmt->datatype;\n\t\t}\n\t}\n\n\t \n\n\t \n\tfwd_ctl = GENMASK(7, 4);\n\n\tfor (nport = 0; nport < priv->hw_data->num_rxports; nport++) {\n\t\tstruct ub960_rxport *rxport = priv->rxports[nport];\n\t\tu8 vc = vc_map[nport];\n\n\t\tif (rx_data[nport].num_streams == 0)\n\t\t\tcontinue;\n\n\t\tswitch (rxport->rx_mode) {\n\t\tcase RXPORT_MODE_RAW10:\n\t\t\tub960_rxport_write(priv, nport, UB960_RR_RAW10_ID,\n\t\t\t\trx_data[nport].pixel_dt | (vc << UB960_RR_RAW10_ID_VC_SHIFT));\n\n\t\t\tub960_rxport_write(priv, rxport->nport,\n\t\t\t\tUB960_RR_RAW_EMBED_DTYPE,\n\t\t\t\t(rx_data[nport].meta_lines << UB960_RR_RAW_EMBED_DTYPE_LINES_SHIFT) |\n\t\t\t\t\trx_data[nport].meta_dt);\n\n\t\t\tbreak;\n\n\t\tcase RXPORT_MODE_RAW12_HF:\n\t\tcase RXPORT_MODE_RAW12_LF:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase RXPORT_MODE_CSI2_SYNC:\n\t\tcase RXPORT_MODE_CSI2_NONSYNC:\n\t\t\tif (!priv->hw_data->is_ub9702) {\n\t\t\t\t \n\t\t\t\tub960_rxport_write(priv, nport, UB960_RR_CSI_VC_MAP,\n\t\t\t\t\t\t   (vc << UB960_RR_CSI_VC_MAP_SHIFT(3)) |\n\t\t\t\t\t\t   (vc << UB960_RR_CSI_VC_MAP_SHIFT(2)) |\n\t\t\t\t\t\t   (vc << UB960_RR_CSI_VC_MAP_SHIFT(1)) |\n\t\t\t\t\t\t   (vc << UB960_RR_CSI_VC_MAP_SHIFT(0)));\n\t\t\t} else {\n\t\t\t\tunsigned int i;\n\n\t\t\t\t \n\t\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\t\tub960_rxport_write(priv, nport,\n\t\t\t\t\t\t\t   UB960_RR_VC_ID_MAP(i),\n\t\t\t\t\t\t\t   nport);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rx_data[nport].tx_port == 1)\n\t\t\tfwd_ctl |= BIT(nport);  \n\t\telse\n\t\t\tfwd_ctl &= ~BIT(nport);  \n\t}\n\n\tub960_write(priv, UB960_SR_FWD_CTL1, fwd_ctl);\n\n\treturn 0;\n}\n\nstatic void ub960_update_streaming_status(struct ub960_data *priv)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < UB960_MAX_NPORTS; i++) {\n\t\tif (priv->stream_enable_mask[i])\n\t\t\tbreak;\n\t}\n\n\tpriv->streaming = i < UB960_MAX_NPORTS;\n}\n\nstatic int ub960_enable_streams(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *state, u32 source_pad,\n\t\t\t\tu64 source_streams_mask)\n{\n\tstruct ub960_data *priv = sd_to_ub960(sd);\n\tstruct device *dev = &priv->client->dev;\n\tu64 sink_streams[UB960_MAX_RX_NPORTS] = {};\n\tstruct v4l2_subdev_route *route;\n\tunsigned int failed_port;\n\tunsigned int nport;\n\tint ret;\n\n\tif (!priv->streaming) {\n\t\tdev_dbg(dev, \"Prepare for streaming\\n\");\n\t\tret = ub960_configure_ports_for_streaming(priv, state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (!priv->stream_enable_mask[source_pad]) {\n\t\tret = ub960_enable_tx_port(priv,\n\t\t\t\t\t   ub960_pad_to_port(priv, source_pad));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpriv->stream_enable_mask[source_pad] |= source_streams_mask;\n\n\t \n\tfor_each_active_route(&state->routing, route) {\n\t\tif (route->source_pad != source_pad)\n\t\t\tcontinue;\n\n\t\tif (!(source_streams_mask & BIT_ULL(route->source_stream)))\n\t\t\tcontinue;\n\n\t\tnport = ub960_pad_to_port(priv, route->sink_pad);\n\n\t\tsink_streams[nport] |= BIT_ULL(route->sink_stream);\n\t}\n\n\tfor (nport = 0; nport < priv->hw_data->num_rxports; nport++) {\n\t\tif (!sink_streams[nport])\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!priv->stream_enable_mask[nport]) {\n\t\t\tret = ub960_enable_rx_port(priv, nport);\n\t\t\tif (ret) {\n\t\t\t\tfailed_port = nport;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tpriv->stream_enable_mask[nport] |= sink_streams[nport];\n\n\t\tdev_dbg(dev, \"enable RX port %u streams %#llx\\n\", nport,\n\t\t\tsink_streams[nport]);\n\n\t\tret = v4l2_subdev_enable_streams(\n\t\t\tpriv->rxports[nport]->source.sd,\n\t\t\tpriv->rxports[nport]->source.pad,\n\t\t\tsink_streams[nport]);\n\t\tif (ret) {\n\t\t\tpriv->stream_enable_mask[nport] &= ~sink_streams[nport];\n\n\t\t\tif (!priv->stream_enable_mask[nport])\n\t\t\t\tub960_disable_rx_port(priv, nport);\n\n\t\t\tfailed_port = nport;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tpriv->streaming = true;\n\n\treturn 0;\n\nerr:\n\tfor (nport = 0; nport < failed_port; nport++) {\n\t\tif (!sink_streams[nport])\n\t\t\tcontinue;\n\n\t\tdev_dbg(dev, \"disable RX port %u streams %#llx\\n\", nport,\n\t\t\tsink_streams[nport]);\n\n\t\tret = v4l2_subdev_disable_streams(\n\t\t\tpriv->rxports[nport]->source.sd,\n\t\t\tpriv->rxports[nport]->source.pad,\n\t\t\tsink_streams[nport]);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Failed to disable streams: %d\\n\", ret);\n\n\t\tpriv->stream_enable_mask[nport] &= ~sink_streams[nport];\n\n\t\t \n\t\tif (!priv->stream_enable_mask[nport])\n\t\t\tub960_disable_rx_port(priv, nport);\n\t}\n\n\tpriv->stream_enable_mask[source_pad] &= ~source_streams_mask;\n\n\tif (!priv->stream_enable_mask[source_pad])\n\t\tub960_disable_tx_port(priv,\n\t\t\t\t      ub960_pad_to_port(priv, source_pad));\n\n\tub960_update_streaming_status(priv);\n\n\treturn ret;\n}\n\nstatic int ub960_disable_streams(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *state,\n\t\t\t\t u32 source_pad, u64 source_streams_mask)\n{\n\tstruct ub960_data *priv = sd_to_ub960(sd);\n\tstruct device *dev = &priv->client->dev;\n\tu64 sink_streams[UB960_MAX_RX_NPORTS] = {};\n\tstruct v4l2_subdev_route *route;\n\tunsigned int nport;\n\tint ret;\n\n\t \n\tfor_each_active_route(&state->routing, route) {\n\t\tif (route->source_pad != source_pad)\n\t\t\tcontinue;\n\n\t\tif (!(source_streams_mask & BIT_ULL(route->source_stream)))\n\t\t\tcontinue;\n\n\t\tnport = ub960_pad_to_port(priv, route->sink_pad);\n\n\t\tsink_streams[nport] |= BIT_ULL(route->sink_stream);\n\t}\n\n\tfor (nport = 0; nport < priv->hw_data->num_rxports; nport++) {\n\t\tif (!sink_streams[nport])\n\t\t\tcontinue;\n\n\t\tdev_dbg(dev, \"disable RX port %u streams %#llx\\n\", nport,\n\t\t\tsink_streams[nport]);\n\n\t\tret = v4l2_subdev_disable_streams(\n\t\t\tpriv->rxports[nport]->source.sd,\n\t\t\tpriv->rxports[nport]->source.pad,\n\t\t\tsink_streams[nport]);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Failed to disable streams: %d\\n\", ret);\n\n\t\tpriv->stream_enable_mask[nport] &= ~sink_streams[nport];\n\n\t\t \n\t\tif (!priv->stream_enable_mask[nport])\n\t\t\tub960_disable_rx_port(priv, nport);\n\t}\n\n\t \n\n\tpriv->stream_enable_mask[source_pad] &= ~source_streams_mask;\n\n\tif (!priv->stream_enable_mask[source_pad])\n\t\tub960_disable_tx_port(priv,\n\t\t\t\t      ub960_pad_to_port(priv, source_pad));\n\n\tub960_update_streaming_status(priv);\n\n\treturn 0;\n}\n\nstatic int _ub960_set_routing(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *state,\n\t\t\t      struct v4l2_subdev_krouting *routing)\n{\n\tstatic const struct v4l2_mbus_framefmt format = {\n\t\t.width = 640,\n\t\t.height = 480,\n\t\t.code = MEDIA_BUS_FMT_UYVY8_1X16,\n\t\t.field = V4L2_FIELD_NONE,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.ycbcr_enc = V4L2_YCBCR_ENC_601,\n\t\t.quantization = V4L2_QUANTIZATION_LIM_RANGE,\n\t\t.xfer_func = V4L2_XFER_FUNC_SRGB,\n\t};\n\tint ret;\n\n\t \n\n\tif (routing->num_routes > V4L2_FRAME_DESC_ENTRY_MAX)\n\t\treturn -E2BIG;\n\n\tret = v4l2_subdev_routing_validate(sd, routing,\n\t\t\t\t\t   V4L2_SUBDEV_ROUTING_ONLY_1_TO_1 |\n\t\t\t\t\t   V4L2_SUBDEV_ROUTING_NO_SINK_STREAM_MIX);\n\tif (ret)\n\t\treturn ret;\n\n\tret = v4l2_subdev_set_routing_with_fmt(sd, state, routing, &format);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ub960_set_routing(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *state,\n\t\t\t     enum v4l2_subdev_format_whence which,\n\t\t\t     struct v4l2_subdev_krouting *routing)\n{\n\tstruct ub960_data *priv = sd_to_ub960(sd);\n\n\tif (which == V4L2_SUBDEV_FORMAT_ACTIVE && priv->streaming)\n\t\treturn -EBUSY;\n\n\treturn _ub960_set_routing(sd, state, routing);\n}\n\nstatic int ub960_get_frame_desc(struct v4l2_subdev *sd, unsigned int pad,\n\t\t\t\tstruct v4l2_mbus_frame_desc *fd)\n{\n\tstruct ub960_data *priv = sd_to_ub960(sd);\n\tstruct v4l2_subdev_route *route;\n\tstruct v4l2_subdev_state *state;\n\tint ret = 0;\n\tstruct device *dev = &priv->client->dev;\n\tu8 vc_map[UB960_MAX_RX_NPORTS] = {};\n\n\tif (!ub960_pad_is_source(priv, pad))\n\t\treturn -EINVAL;\n\n\tmemset(fd, 0, sizeof(*fd));\n\n\tfd->type = V4L2_MBUS_FRAME_DESC_TYPE_CSI2;\n\n\tstate = v4l2_subdev_lock_and_get_active_state(&priv->sd);\n\n\tub960_get_vc_maps(priv, state, vc_map);\n\n\tfor_each_active_route(&state->routing, route) {\n\t\tstruct v4l2_mbus_frame_desc_entry *source_entry = NULL;\n\t\tstruct v4l2_mbus_frame_desc source_fd;\n\t\tunsigned int nport;\n\t\tunsigned int i;\n\n\t\tif (route->source_pad != pad)\n\t\t\tcontinue;\n\n\t\tnport = ub960_pad_to_port(priv, route->sink_pad);\n\n\t\tret = v4l2_subdev_call(priv->rxports[nport]->source.sd, pad,\n\t\t\t\t       get_frame_desc,\n\t\t\t\t       priv->rxports[nport]->source.pad,\n\t\t\t\t       &source_fd);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to get source frame desc for pad %u\\n\",\n\t\t\t\troute->sink_pad);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tfor (i = 0; i < source_fd.num_entries; i++) {\n\t\t\tif (source_fd.entry[i].stream == route->sink_stream) {\n\t\t\t\tsource_entry = &source_fd.entry[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!source_entry) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to find stream from source frame desc\\n\");\n\t\t\tret = -EPIPE;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tfd->entry[fd->num_entries].stream = route->source_stream;\n\t\tfd->entry[fd->num_entries].flags = source_entry->flags;\n\t\tfd->entry[fd->num_entries].length = source_entry->length;\n\t\tfd->entry[fd->num_entries].pixelcode = source_entry->pixelcode;\n\n\t\tfd->entry[fd->num_entries].bus.csi2.vc = vc_map[nport];\n\n\t\tif (source_fd.type == V4L2_MBUS_FRAME_DESC_TYPE_CSI2) {\n\t\t\tfd->entry[fd->num_entries].bus.csi2.dt =\n\t\t\t\tsource_entry->bus.csi2.dt;\n\t\t} else {\n\t\t\tconst struct ub960_format_info *ub960_fmt;\n\t\t\tstruct v4l2_mbus_framefmt *fmt;\n\n\t\t\tfmt = v4l2_subdev_state_get_stream_format(state, pad,\n\t\t\t\t\t\t\t\t  route->source_stream);\n\n\t\t\tif (!fmt) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\n\t\t\tub960_fmt = ub960_find_format(fmt->code);\n\t\t\tif (!ub960_fmt) {\n\t\t\t\tdev_err(dev, \"Unable to find format\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\n\t\t\tfd->entry[fd->num_entries].bus.csi2.dt =\n\t\t\t\tub960_fmt->datatype;\n\t\t}\n\n\t\tfd->num_entries++;\n\t}\n\nout_unlock:\n\tv4l2_subdev_unlock_state(state);\n\n\treturn ret;\n}\n\nstatic int ub960_set_fmt(struct v4l2_subdev *sd,\n\t\t\t struct v4l2_subdev_state *state,\n\t\t\t struct v4l2_subdev_format *format)\n{\n\tstruct ub960_data *priv = sd_to_ub960(sd);\n\tstruct v4l2_mbus_framefmt *fmt;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE && priv->streaming)\n\t\treturn -EBUSY;\n\n\t \n\tif (ub960_pad_is_source(priv, format->pad))\n\t\treturn v4l2_subdev_get_fmt(sd, state, format);\n\n\t \n\tif (!ub960_find_format(format->format.code))\n\t\tformat->format.code = ub960_formats[0].code;\n\n\tfmt = v4l2_subdev_state_get_stream_format(state, format->pad,\n\t\t\t\t\t\t  format->stream);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\t*fmt = format->format;\n\n\tfmt = v4l2_subdev_state_get_opposite_stream_format(state, format->pad,\n\t\t\t\t\t\t\t   format->stream);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\t*fmt = format->format;\n\n\treturn 0;\n}\n\nstatic int ub960_init_cfg(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *state)\n{\n\tstruct ub960_data *priv = sd_to_ub960(sd);\n\n\tstruct v4l2_subdev_route routes[] = {\n\t\t{\n\t\t\t.sink_pad = 0,\n\t\t\t.sink_stream = 0,\n\t\t\t.source_pad = priv->hw_data->num_rxports,\n\t\t\t.source_stream = 0,\n\t\t\t.flags = V4L2_SUBDEV_ROUTE_FL_ACTIVE,\n\t\t},\n\t};\n\n\tstruct v4l2_subdev_krouting routing = {\n\t\t.num_routes = ARRAY_SIZE(routes),\n\t\t.routes = routes,\n\t};\n\n\treturn _ub960_set_routing(sd, state, &routing);\n}\n\nstatic const struct v4l2_subdev_pad_ops ub960_pad_ops = {\n\t.enable_streams = ub960_enable_streams,\n\t.disable_streams = ub960_disable_streams,\n\n\t.set_routing = ub960_set_routing,\n\t.get_frame_desc = ub960_get_frame_desc,\n\n\t.get_fmt = v4l2_subdev_get_fmt,\n\t.set_fmt = ub960_set_fmt,\n\n\t.init_cfg = ub960_init_cfg,\n};\n\nstatic int ub960_log_status(struct v4l2_subdev *sd)\n{\n\tstruct ub960_data *priv = sd_to_ub960(sd);\n\tstruct device *dev = &priv->client->dev;\n\tstruct v4l2_subdev_state *state;\n\tunsigned int nport;\n\tunsigned int i;\n\tu16 v16 = 0;\n\tu8 v = 0;\n\tu8 id[UB960_SR_FPD3_RX_ID_LEN];\n\n\tstate = v4l2_subdev_lock_and_get_active_state(sd);\n\n\tfor (i = 0; i < sizeof(id); i++)\n\t\tub960_read(priv, UB960_SR_FPD3_RX_ID(i), &id[i]);\n\n\tdev_info(dev, \"ID '%.*s'\\n\", (int)sizeof(id), id);\n\n\tfor (nport = 0; nport < priv->hw_data->num_txports; nport++) {\n\t\tstruct ub960_txport *txport = priv->txports[nport];\n\n\t\tdev_info(dev, \"TX %u\\n\", nport);\n\n\t\tif (!txport) {\n\t\t\tdev_info(dev, \"\\tNot initialized\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tub960_txport_read(priv, nport, UB960_TR_CSI_STS, &v);\n\t\tdev_info(dev, \"\\tsync %u, pass %u\\n\", v & (u8)BIT(1),\n\t\t\t v & (u8)BIT(0));\n\n\t\tub960_read16(priv, UB960_SR_CSI_FRAME_COUNT_HI(nport), &v16);\n\t\tdev_info(dev, \"\\tframe counter %u\\n\", v16);\n\n\t\tub960_read16(priv, UB960_SR_CSI_FRAME_ERR_COUNT_HI(nport), &v16);\n\t\tdev_info(dev, \"\\tframe error counter %u\\n\", v16);\n\n\t\tub960_read16(priv, UB960_SR_CSI_LINE_COUNT_HI(nport), &v16);\n\t\tdev_info(dev, \"\\tline counter %u\\n\", v16);\n\n\t\tub960_read16(priv, UB960_SR_CSI_LINE_ERR_COUNT_HI(nport), &v16);\n\t\tdev_info(dev, \"\\tline error counter %u\\n\", v16);\n\t}\n\n\tfor (nport = 0; nport < priv->hw_data->num_rxports; nport++) {\n\t\tstruct ub960_rxport *rxport = priv->rxports[nport];\n\t\tu8 eq_level;\n\t\ts8 strobe_pos;\n\t\tunsigned int i;\n\n\t\tdev_info(dev, \"RX %u\\n\", nport);\n\n\t\tif (!rxport) {\n\t\t\tdev_info(dev, \"\\tNot initialized\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tub960_rxport_read(priv, nport, UB960_RR_RX_PORT_STS1, &v);\n\n\t\tif (v & UB960_RR_RX_PORT_STS1_LOCK_STS)\n\t\t\tdev_info(dev, \"\\tLocked\\n\");\n\t\telse\n\t\t\tdev_info(dev, \"\\tNot locked\\n\");\n\n\t\tdev_info(dev, \"\\trx_port_sts1 %#02x\\n\", v);\n\t\tub960_rxport_read(priv, nport, UB960_RR_RX_PORT_STS2, &v);\n\t\tdev_info(dev, \"\\trx_port_sts2 %#02x\\n\", v);\n\n\t\tub960_rxport_read16(priv, nport, UB960_RR_RX_FREQ_HIGH, &v16);\n\t\tdev_info(dev, \"\\tlink freq %llu Hz\\n\", (v16 * 1000000ULL) >> 8);\n\n\t\tub960_rxport_read16(priv, nport, UB960_RR_RX_PAR_ERR_HI, &v16);\n\t\tdev_info(dev, \"\\tparity errors %u\\n\", v16);\n\n\t\tub960_rxport_read16(priv, nport, UB960_RR_LINE_COUNT_HI, &v16);\n\t\tdev_info(dev, \"\\tlines per frame %u\\n\", v16);\n\n\t\tub960_rxport_read16(priv, nport, UB960_RR_LINE_LEN_1, &v16);\n\t\tdev_info(dev, \"\\tbytes per line %u\\n\", v16);\n\n\t\tub960_rxport_read(priv, nport, UB960_RR_CSI_ERR_COUNTER, &v);\n\t\tdev_info(dev, \"\\tcsi_err_counter %u\\n\", v);\n\n\t\t \n\n\t\tub960_read(priv, UB960_XR_AEQ_CTL1, &v);\n\n\t\tdev_info(dev, \"\\t%s strobe\\n\",\n\t\t\t (v & UB960_XR_AEQ_CTL1_AEQ_SFILTER_EN) ? \"Adaptive\" :\n\t\t\t\t\t\t\t\t  \"Manual\");\n\n\t\tif (v & UB960_XR_AEQ_CTL1_AEQ_SFILTER_EN) {\n\t\t\tub960_read(priv, UB960_XR_SFILTER_CFG, &v);\n\n\t\t\tdev_info(dev, \"\\tStrobe range [%d, %d]\\n\",\n\t\t\t\t ((v >> UB960_XR_SFILTER_CFG_SFILTER_MIN_SHIFT) & 0xf) - 7,\n\t\t\t\t ((v >> UB960_XR_SFILTER_CFG_SFILTER_MAX_SHIFT) & 0xf) - 7);\n\t\t}\n\n\t\tub960_rxport_get_strobe_pos(priv, nport, &strobe_pos);\n\n\t\tdev_info(dev, \"\\tStrobe pos %d\\n\", strobe_pos);\n\n\t\t \n\n\t\tub960_rxport_read(priv, nport, UB960_RR_AEQ_BYPASS, &v);\n\n\t\tdev_info(dev, \"\\t%s EQ\\n\",\n\t\t\t (v & UB960_RR_AEQ_BYPASS_ENABLE) ? \"Manual\" :\n\t\t\t\t\t\t\t    \"Adaptive\");\n\n\t\tif (!(v & UB960_RR_AEQ_BYPASS_ENABLE)) {\n\t\t\tub960_rxport_read(priv, nport, UB960_RR_AEQ_MIN_MAX, &v);\n\n\t\t\tdev_info(dev, \"\\tEQ range [%u, %u]\\n\",\n\t\t\t\t (v >> UB960_RR_AEQ_MIN_MAX_AEQ_FLOOR_SHIFT) & 0xf,\n\t\t\t\t (v >> UB960_RR_AEQ_MIN_MAX_AEQ_MAX_SHIFT) & 0xf);\n\t\t}\n\n\t\tif (ub960_rxport_get_eq_level(priv, nport, &eq_level) == 0)\n\t\t\tdev_info(dev, \"\\tEQ level %u\\n\", eq_level);\n\n\t\t \n\t\tfor (i = 0; i < UB960_NUM_BC_GPIOS; i++) {\n\t\t\tu8 ctl_reg;\n\t\t\tu8 ctl_shift;\n\n\t\t\tctl_reg = UB960_RR_BC_GPIO_CTL(i / 2);\n\t\t\tctl_shift = (i % 2) * 4;\n\n\t\t\tub960_rxport_read(priv, nport, ctl_reg, &v);\n\n\t\t\tdev_info(dev, \"\\tGPIO%u: mode %u\\n\", i,\n\t\t\t\t (v >> ctl_shift) & 0xf);\n\t\t}\n\t}\n\n\tv4l2_subdev_unlock_state(state);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops ub960_subdev_core_ops = {\n\t.log_status = ub960_log_status,\n\t.subscribe_event = v4l2_ctrl_subdev_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n};\n\nstatic const struct v4l2_subdev_ops ub960_subdev_ops = {\n\t.core = &ub960_subdev_core_ops,\n\t.pad = &ub960_pad_ops,\n};\n\nstatic const struct media_entity_operations ub960_entity_ops = {\n\t.get_fwnode_pad = v4l2_subdev_get_fwnode_pad_1_to_1,\n\t.link_validate = v4l2_subdev_link_validate,\n\t.has_pad_interdep = v4l2_subdev_has_pad_interdep,\n};\n\n \n\nstatic irqreturn_t ub960_handle_events(int irq, void *arg)\n{\n\tstruct ub960_data *priv = arg;\n\tunsigned int i;\n\tu8 int_sts;\n\tu8 fwd_sts;\n\tint ret;\n\n\tret = ub960_read(priv, UB960_SR_INTERRUPT_STS, &int_sts);\n\tif (ret || !int_sts)\n\t\treturn IRQ_NONE;\n\n\tdev_dbg(&priv->client->dev, \"INTERRUPT_STS %x\\n\", int_sts);\n\n\tret = ub960_read(priv, UB960_SR_FWD_STS, &fwd_sts);\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\tdev_dbg(&priv->client->dev, \"FWD_STS %#02x\\n\", fwd_sts);\n\n\tfor (i = 0; i < priv->hw_data->num_txports; i++) {\n\t\tif (int_sts & UB960_SR_INTERRUPT_STS_IS_CSI_TX(i))\n\t\t\tub960_csi_handle_events(priv, i);\n\t}\n\n\tfor (i = 0; i < priv->hw_data->num_rxports; i++) {\n\t\tif (!priv->rxports[i])\n\t\t\tcontinue;\n\n\t\tif (int_sts & UB960_SR_INTERRUPT_STS_IS_RX(i))\n\t\t\tub960_rxport_handle_events(priv, i);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ub960_handler_work(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct ub960_data *priv =\n\t\tcontainer_of(dwork, struct ub960_data, poll_work);\n\n\tub960_handle_events(0, priv);\n\n\tschedule_delayed_work(&priv->poll_work,\n\t\t\t      msecs_to_jiffies(UB960_POLL_TIME_MS));\n}\n\nstatic void ub960_txport_free_ports(struct ub960_data *priv)\n{\n\tunsigned int nport;\n\n\tfor (nport = 0; nport < priv->hw_data->num_txports; nport++) {\n\t\tstruct ub960_txport *txport = priv->txports[nport];\n\n\t\tif (!txport)\n\t\t\tcontinue;\n\n\t\tkfree(txport);\n\t\tpriv->txports[nport] = NULL;\n\t}\n}\n\nstatic void ub960_rxport_free_ports(struct ub960_data *priv)\n{\n\tunsigned int nport;\n\n\tfor (nport = 0; nport < priv->hw_data->num_rxports; nport++) {\n\t\tstruct ub960_rxport *rxport = priv->rxports[nport];\n\n\t\tif (!rxport)\n\t\t\tcontinue;\n\n\t\tfwnode_handle_put(rxport->source.ep_fwnode);\n\t\tfwnode_handle_put(rxport->ser.fwnode);\n\n\t\tkfree(rxport);\n\t\tpriv->rxports[nport] = NULL;\n\t}\n}\n\nstatic int\nub960_parse_dt_rxport_link_properties(struct ub960_data *priv,\n\t\t\t\t      struct fwnode_handle *link_fwnode,\n\t\t\t\t      struct ub960_rxport *rxport)\n{\n\tstruct device *dev = &priv->client->dev;\n\tunsigned int nport = rxport->nport;\n\tu32 rx_mode;\n\tu32 cdr_mode;\n\ts32 strobe_pos;\n\tu32 eq_level;\n\tu32 ser_i2c_alias;\n\tint ret;\n\n\tcdr_mode = RXPORT_CDR_FPD3;\n\n\tret = fwnode_property_read_u32(link_fwnode, \"ti,cdr-mode\", &cdr_mode);\n\tif (ret < 0 && ret != -EINVAL) {\n\t\tdev_err(dev, \"rx%u: failed to read '%s': %d\\n\", nport,\n\t\t\t\"ti,cdr-mode\", ret);\n\t\treturn ret;\n\t}\n\n\tif (cdr_mode > RXPORT_CDR_LAST) {\n\t\tdev_err(dev, \"rx%u: bad 'ti,cdr-mode' %u\\n\", nport, cdr_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!priv->hw_data->is_fpdlink4 && cdr_mode == RXPORT_CDR_FPD4) {\n\t\tdev_err(dev, \"rx%u: FPD-Link 4 CDR not supported\\n\", nport);\n\t\treturn -EINVAL;\n\t}\n\n\trxport->cdr_mode = cdr_mode;\n\n\tret = fwnode_property_read_u32(link_fwnode, \"ti,rx-mode\", &rx_mode);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"rx%u: failed to read '%s': %d\\n\", nport,\n\t\t\t\"ti,rx-mode\", ret);\n\t\treturn ret;\n\t}\n\n\tif (rx_mode > RXPORT_MODE_LAST) {\n\t\tdev_err(dev, \"rx%u: bad 'ti,rx-mode' %u\\n\", nport, rx_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (rx_mode) {\n\tcase RXPORT_MODE_RAW12_HF:\n\tcase RXPORT_MODE_RAW12_LF:\n\t\tdev_err(dev, \"rx%u: unsupported 'ti,rx-mode' %u\\n\", nport,\n\t\t\trx_mode);\n\t\treturn -EINVAL;\n\tdefault:\n\t\tbreak;\n\t}\n\n\trxport->rx_mode = rx_mode;\n\n\t \n\n\t \n\trxport->eq.manual_eq = false;\n\trxport->eq.aeq.eq_level_min = UB960_MIN_EQ_LEVEL;\n\trxport->eq.aeq.eq_level_max = UB960_MAX_EQ_LEVEL;\n\n\tret = fwnode_property_read_u32(link_fwnode, \"ti,strobe-pos\",\n\t\t\t\t       &strobe_pos);\n\tif (ret) {\n\t\tif (ret != -EINVAL) {\n\t\t\tdev_err(dev, \"rx%u: failed to read '%s': %d\\n\", nport,\n\t\t\t\t\"ti,strobe-pos\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tif (strobe_pos < UB960_MIN_MANUAL_STROBE_POS ||\n\t\t    strobe_pos > UB960_MAX_MANUAL_STROBE_POS) {\n\t\t\tdev_err(dev, \"rx%u: illegal 'strobe-pos' value: %d\\n\",\n\t\t\t\tnport, strobe_pos);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\trxport->eq.strobe_pos = strobe_pos;\n\t\tif (!priv->strobe.manual)\n\t\t\tdev_warn(dev,\n\t\t\t\t \"rx%u: 'ti,strobe-pos' ignored as 'ti,manual-strobe' not set\\n\",\n\t\t\t\t nport);\n\t}\n\n\tret = fwnode_property_read_u32(link_fwnode, \"ti,eq-level\", &eq_level);\n\tif (ret) {\n\t\tif (ret != -EINVAL) {\n\t\t\tdev_err(dev, \"rx%u: failed to read '%s': %d\\n\", nport,\n\t\t\t\t\"ti,eq-level\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tif (eq_level > UB960_MAX_EQ_LEVEL) {\n\t\t\tdev_err(dev, \"rx%u: illegal 'ti,eq-level' value: %d\\n\",\n\t\t\t\tnport, eq_level);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trxport->eq.manual_eq = true;\n\t\trxport->eq.manual.eq_level = eq_level;\n\t}\n\n\tret = fwnode_property_read_u32(link_fwnode, \"i2c-alias\",\n\t\t\t\t       &ser_i2c_alias);\n\tif (ret) {\n\t\tdev_err(dev, \"rx%u: failed to read '%s': %d\\n\", nport,\n\t\t\t\"i2c-alias\", ret);\n\t\treturn ret;\n\t}\n\trxport->ser.alias = ser_i2c_alias;\n\n\trxport->ser.fwnode = fwnode_get_named_child_node(link_fwnode, \"serializer\");\n\tif (!rxport->ser.fwnode) {\n\t\tdev_err(dev, \"rx%u: missing 'serializer' node\\n\", nport);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ub960_parse_dt_rxport_ep_properties(struct ub960_data *priv,\n\t\t\t\t\t       struct fwnode_handle *ep_fwnode,\n\t\t\t\t\t       struct ub960_rxport *rxport)\n{\n\tstruct device *dev = &priv->client->dev;\n\tstruct v4l2_fwnode_endpoint vep = {};\n\tunsigned int nport = rxport->nport;\n\tbool hsync_hi;\n\tbool vsync_hi;\n\tint ret;\n\n\trxport->source.ep_fwnode = fwnode_graph_get_remote_endpoint(ep_fwnode);\n\tif (!rxport->source.ep_fwnode) {\n\t\tdev_err(dev, \"rx%u: no remote endpoint\\n\", nport);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\n\tswitch (rxport->rx_mode) {\n\tcase RXPORT_MODE_RAW10:\n\tcase RXPORT_MODE_RAW12_HF:\n\tcase RXPORT_MODE_RAW12_LF:\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tvep.bus_type = V4L2_MBUS_PARALLEL;\n\tret = v4l2_fwnode_endpoint_parse(ep_fwnode, &vep);\n\tif (ret) {\n\t\tdev_err(dev, \"rx%u: failed to parse endpoint data\\n\", nport);\n\t\tgoto err_put_source_ep_fwnode;\n\t}\n\n\thsync_hi = !!(vep.bus.parallel.flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH);\n\tvsync_hi = !!(vep.bus.parallel.flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH);\n\n\t \n\trxport->lv_fv_pol = (hsync_hi ? UB960_RR_PORT_CONFIG2_LV_POL_LOW : 0) |\n\t\t\t    (vsync_hi ? UB960_RR_PORT_CONFIG2_FV_POL_LOW : 0);\n\n\treturn 0;\n\nerr_put_source_ep_fwnode:\n\tfwnode_handle_put(rxport->source.ep_fwnode);\n\treturn ret;\n}\n\nstatic int ub960_parse_dt_rxport(struct ub960_data *priv, unsigned int nport,\n\t\t\t\t struct fwnode_handle *link_fwnode,\n\t\t\t\t struct fwnode_handle *ep_fwnode)\n{\n\tstatic const char *vpoc_names[UB960_MAX_RX_NPORTS] = {\n\t\t\"vpoc0\", \"vpoc1\", \"vpoc2\", \"vpoc3\"\n\t};\n\tstruct device *dev = &priv->client->dev;\n\tstruct ub960_rxport *rxport;\n\tint ret;\n\n\trxport = kzalloc(sizeof(*rxport), GFP_KERNEL);\n\tif (!rxport)\n\t\treturn -ENOMEM;\n\n\tpriv->rxports[nport] = rxport;\n\n\trxport->nport = nport;\n\trxport->priv = priv;\n\n\tret = ub960_parse_dt_rxport_link_properties(priv, link_fwnode, rxport);\n\tif (ret)\n\t\tgoto err_free_rxport;\n\n\trxport->vpoc = devm_regulator_get_optional(dev, vpoc_names[nport]);\n\tif (IS_ERR(rxport->vpoc)) {\n\t\tret = PTR_ERR(rxport->vpoc);\n\t\tif (ret == -ENODEV) {\n\t\t\trxport->vpoc = NULL;\n\t\t} else {\n\t\t\tdev_err(dev, \"rx%u: failed to get VPOC supply: %d\\n\",\n\t\t\t\tnport, ret);\n\t\t\tgoto err_put_remote_fwnode;\n\t\t}\n\t}\n\n\tret = ub960_parse_dt_rxport_ep_properties(priv, ep_fwnode, rxport);\n\tif (ret)\n\t\tgoto err_put_remote_fwnode;\n\n\treturn 0;\n\nerr_put_remote_fwnode:\n\tfwnode_handle_put(rxport->ser.fwnode);\nerr_free_rxport:\n\tpriv->rxports[nport] = NULL;\n\tkfree(rxport);\n\treturn ret;\n}\n\nstatic struct fwnode_handle *\nub960_fwnode_get_link_by_regs(struct fwnode_handle *links_fwnode,\n\t\t\t      unsigned int nport)\n{\n\tstruct fwnode_handle *link_fwnode;\n\tint ret;\n\n\tfwnode_for_each_child_node(links_fwnode, link_fwnode) {\n\t\tu32 link_num;\n\n\t\tif (!str_has_prefix(fwnode_get_name(link_fwnode), \"link@\"))\n\t\t\tcontinue;\n\n\t\tret = fwnode_property_read_u32(link_fwnode, \"reg\", &link_num);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(link_fwnode);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (nport == link_num)\n\t\t\treturn link_fwnode;\n\t}\n\n\treturn NULL;\n}\n\nstatic int ub960_parse_dt_rxports(struct ub960_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tstruct fwnode_handle *links_fwnode;\n\tunsigned int nport;\n\tint ret;\n\n\tlinks_fwnode = fwnode_get_named_child_node(dev_fwnode(dev), \"links\");\n\tif (!links_fwnode) {\n\t\tdev_err(dev, \"'links' node missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tpriv->strobe.min = 2;\n\tpriv->strobe.max = 3;\n\n\tpriv->strobe.manual = fwnode_property_read_bool(links_fwnode, \"ti,manual-strobe\");\n\n\tfor (nport = 0; nport < priv->hw_data->num_rxports; nport++) {\n\t\tstruct fwnode_handle *link_fwnode;\n\t\tstruct fwnode_handle *ep_fwnode;\n\n\t\tlink_fwnode = ub960_fwnode_get_link_by_regs(links_fwnode, nport);\n\t\tif (!link_fwnode)\n\t\t\tcontinue;\n\n\t\tep_fwnode = fwnode_graph_get_endpoint_by_id(dev_fwnode(dev),\n\t\t\t\t\t\t\t    nport, 0, 0);\n\t\tif (!ep_fwnode) {\n\t\t\tfwnode_handle_put(link_fwnode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = ub960_parse_dt_rxport(priv, nport, link_fwnode,\n\t\t\t\t\t    ep_fwnode);\n\n\t\tfwnode_handle_put(link_fwnode);\n\t\tfwnode_handle_put(ep_fwnode);\n\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"rx%u: failed to parse RX port\\n\", nport);\n\t\t\tgoto err_put_links;\n\t\t}\n\t}\n\n\tfwnode_handle_put(links_fwnode);\n\n\treturn 0;\n\nerr_put_links:\n\tfwnode_handle_put(links_fwnode);\n\n\treturn ret;\n}\n\nstatic int ub960_parse_dt_txports(struct ub960_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tu32 nport;\n\tint ret;\n\n\tfor (nport = 0; nport < priv->hw_data->num_txports; nport++) {\n\t\tunsigned int port = nport + priv->hw_data->num_rxports;\n\t\tstruct fwnode_handle *ep_fwnode;\n\n\t\tep_fwnode = fwnode_graph_get_endpoint_by_id(dev_fwnode(dev),\n\t\t\t\t\t\t\t    port, 0, 0);\n\t\tif (!ep_fwnode)\n\t\t\tcontinue;\n\n\t\tret = ub960_parse_dt_txport(priv, ep_fwnode, nport);\n\n\t\tfwnode_handle_put(ep_fwnode);\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ub960_parse_dt(struct ub960_data *priv)\n{\n\tint ret;\n\n\tret = ub960_parse_dt_rxports(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ub960_parse_dt_txports(priv);\n\tif (ret)\n\t\tgoto err_free_rxports;\n\n\treturn 0;\n\nerr_free_rxports:\n\tub960_rxport_free_ports(priv);\n\n\treturn ret;\n}\n\nstatic int ub960_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t      struct v4l2_subdev *subdev,\n\t\t\t      struct v4l2_async_connection *asd)\n{\n\tstruct ub960_data *priv = sd_to_ub960(notifier->sd);\n\tstruct ub960_rxport *rxport = to_ub960_asd(asd)->rxport;\n\tstruct device *dev = &priv->client->dev;\n\tu8 nport = rxport->nport;\n\tunsigned int i;\n\tint ret;\n\n\tret = media_entity_get_fwnode_pad(&subdev->entity,\n\t\t\t\t\t  rxport->source.ep_fwnode,\n\t\t\t\t\t  MEDIA_PAD_FL_SOURCE);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to find pad for %s\\n\", subdev->name);\n\t\treturn ret;\n\t}\n\n\trxport->source.sd = subdev;\n\trxport->source.pad = ret;\n\n\tret = media_create_pad_link(&rxport->source.sd->entity,\n\t\t\t\t    rxport->source.pad, &priv->sd.entity, nport,\n\t\t\t\t    MEDIA_LNK_FL_ENABLED |\n\t\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to link %s:%u -> %s:%u\\n\",\n\t\t\trxport->source.sd->name, rxport->source.pad,\n\t\t\tpriv->sd.name, nport);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < priv->hw_data->num_rxports; i++) {\n\t\tif (priv->rxports[i] && !priv->rxports[i]->source.sd) {\n\t\t\tdev_dbg(dev, \"Waiting for more subdevs to be bound\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ub960_notify_unbind(struct v4l2_async_notifier *notifier,\n\t\t\t\tstruct v4l2_subdev *subdev,\n\t\t\t\tstruct v4l2_async_connection *asd)\n{\n\tstruct ub960_rxport *rxport = to_ub960_asd(asd)->rxport;\n\n\trxport->source.sd = NULL;\n}\n\nstatic const struct v4l2_async_notifier_operations ub960_notify_ops = {\n\t.bound = ub960_notify_bound,\n\t.unbind = ub960_notify_unbind,\n};\n\nstatic int ub960_v4l2_notifier_register(struct ub960_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tunsigned int i;\n\tint ret;\n\n\tv4l2_async_subdev_nf_init(&priv->notifier, &priv->sd);\n\n\tfor (i = 0; i < priv->hw_data->num_rxports; i++) {\n\t\tstruct ub960_rxport *rxport = priv->rxports[i];\n\t\tstruct ub960_asd *asd;\n\n\t\tif (!rxport)\n\t\t\tcontinue;\n\n\t\tasd = v4l2_async_nf_add_fwnode(&priv->notifier,\n\t\t\t\t\t       rxport->source.ep_fwnode,\n\t\t\t\t\t       struct ub960_asd);\n\t\tif (IS_ERR(asd)) {\n\t\t\tdev_err(dev, \"Failed to add subdev for source %u: %pe\",\n\t\t\t\ti, asd);\n\t\t\tv4l2_async_nf_cleanup(&priv->notifier);\n\t\t\treturn PTR_ERR(asd);\n\t\t}\n\n\t\tasd->rxport = rxport;\n\t}\n\n\tpriv->notifier.ops = &ub960_notify_ops;\n\n\tret = v4l2_async_nf_register(&priv->notifier);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register subdev_notifier\");\n\t\tv4l2_async_nf_cleanup(&priv->notifier);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ub960_v4l2_notifier_unregister(struct ub960_data *priv)\n{\n\tv4l2_async_nf_unregister(&priv->notifier);\n\tv4l2_async_nf_cleanup(&priv->notifier);\n}\n\nstatic int ub960_create_subdev(struct ub960_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tunsigned int i;\n\tint ret;\n\n\tv4l2_i2c_subdev_init(&priv->sd, priv->client, &ub960_subdev_ops);\n\n\tv4l2_ctrl_handler_init(&priv->ctrl_handler, 1);\n\tpriv->sd.ctrl_handler = &priv->ctrl_handler;\n\n\tv4l2_ctrl_new_int_menu(&priv->ctrl_handler, NULL, V4L2_CID_LINK_FREQ,\n\t\t\t       ARRAY_SIZE(priv->tx_link_freq) - 1, 0,\n\t\t\t       priv->tx_link_freq);\n\n\tif (priv->ctrl_handler.error) {\n\t\tret = priv->ctrl_handler.error;\n\t\tgoto err_free_ctrl;\n\t}\n\n\tpriv->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |\n\t\t\t  V4L2_SUBDEV_FL_HAS_EVENTS | V4L2_SUBDEV_FL_STREAMS;\n\tpriv->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tpriv->sd.entity.ops = &ub960_entity_ops;\n\n\tfor (i = 0; i < priv->hw_data->num_rxports + priv->hw_data->num_txports; i++) {\n\t\tpriv->pads[i].flags = ub960_pad_is_sink(priv, i) ?\n\t\t\t\t\t      MEDIA_PAD_FL_SINK :\n\t\t\t\t\t      MEDIA_PAD_FL_SOURCE;\n\t}\n\n\tret = media_entity_pads_init(&priv->sd.entity,\n\t\t\t\t     priv->hw_data->num_rxports +\n\t\t\t\t\t     priv->hw_data->num_txports,\n\t\t\t\t     priv->pads);\n\tif (ret)\n\t\tgoto err_free_ctrl;\n\n\tpriv->sd.state_lock = priv->sd.ctrl_handler->lock;\n\n\tret = v4l2_subdev_init_finalize(&priv->sd);\n\tif (ret)\n\t\tgoto err_entity_cleanup;\n\n\tret = ub960_v4l2_notifier_register(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"v4l2 subdev notifier register failed: %d\\n\", ret);\n\t\tgoto err_subdev_cleanup;\n\t}\n\n\tret = v4l2_async_register_subdev(&priv->sd);\n\tif (ret) {\n\t\tdev_err(dev, \"v4l2_async_register_subdev error: %d\\n\", ret);\n\t\tgoto err_unreg_notif;\n\t}\n\n\treturn 0;\n\nerr_unreg_notif:\n\tub960_v4l2_notifier_unregister(priv);\nerr_subdev_cleanup:\n\tv4l2_subdev_cleanup(&priv->sd);\nerr_entity_cleanup:\n\tmedia_entity_cleanup(&priv->sd.entity);\nerr_free_ctrl:\n\tv4l2_ctrl_handler_free(&priv->ctrl_handler);\n\n\treturn ret;\n}\n\nstatic void ub960_destroy_subdev(struct ub960_data *priv)\n{\n\tub960_v4l2_notifier_unregister(priv);\n\tv4l2_async_unregister_subdev(&priv->sd);\n\n\tv4l2_subdev_cleanup(&priv->sd);\n\n\tmedia_entity_cleanup(&priv->sd.entity);\n\tv4l2_ctrl_handler_free(&priv->ctrl_handler);\n}\n\nstatic const struct regmap_config ub960_regmap_config = {\n\t.name = \"ds90ub960\",\n\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = 0xff,\n\n\t \n\t.disable_locking = true,\n};\n\nstatic void ub960_reset(struct ub960_data *priv, bool reset_regs)\n{\n\tstruct device *dev = &priv->client->dev;\n\tunsigned int v;\n\tint ret;\n\tu8 bit;\n\n\tbit = reset_regs ? UB960_SR_RESET_DIGITAL_RESET1 :\n\t\t\t   UB960_SR_RESET_DIGITAL_RESET0;\n\n\tub960_write(priv, UB960_SR_RESET, bit);\n\n\tmutex_lock(&priv->reg_lock);\n\n\tret = regmap_read_poll_timeout(priv->regmap, UB960_SR_RESET, v,\n\t\t\t\t       (v & bit) == 0, 2000, 100000);\n\n\tmutex_unlock(&priv->reg_lock);\n\n\tif (ret)\n\t\tdev_err(dev, \"reset failed: %d\\n\", ret);\n}\n\nstatic int ub960_get_hw_resources(struct ub960_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\n\tpriv->regmap = devm_regmap_init_i2c(priv->client, &ub960_regmap_config);\n\tif (IS_ERR(priv->regmap))\n\t\treturn PTR_ERR(priv->regmap);\n\n\tpriv->vddio = devm_regulator_get(dev, \"vddio\");\n\tif (IS_ERR(priv->vddio))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->vddio),\n\t\t\t\t     \"cannot get VDDIO regulator\\n\");\n\n\t \n\tpriv->pd_gpio =\n\t\tdevm_gpiod_get_optional(dev, \"powerdown\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->pd_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->pd_gpio),\n\t\t\t\t     \"Cannot get powerdown GPIO\\n\");\n\n\tpriv->refclk = devm_clk_get(dev, \"refclk\");\n\tif (IS_ERR(priv->refclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->refclk),\n\t\t\t\t     \"Cannot get REFCLK\\n\");\n\n\treturn 0;\n}\n\nstatic int ub960_enable_core_hw(struct ub960_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tu8 rev_mask;\n\tint ret;\n\tu8 dev_sts;\n\tu8 refclk_freq;\n\n\tret = regulator_enable(priv->vddio);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"failed to enable VDDIO regulator\\n\");\n\n\tret = clk_prepare_enable(priv->refclk);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"Failed to enable refclk\\n\");\n\t\tgoto err_disable_vddio;\n\t}\n\n\tif (priv->pd_gpio) {\n\t\tgpiod_set_value_cansleep(priv->pd_gpio, 1);\n\t\t \n\t\tfsleep(2000);\n\t\tgpiod_set_value_cansleep(priv->pd_gpio, 0);\n\t\t \n\t\tfsleep(2000);\n\t}\n\n\tub960_reset(priv, true);\n\n\t \n\tret = ub960_read(priv, UB960_SR_REV_MASK, &rev_mask);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"Cannot read first register, abort\\n\");\n\t\tgoto err_pd_gpio;\n\t}\n\n\tdev_dbg(dev, \"Found %s (rev/mask %#04x)\\n\", priv->hw_data->model,\n\t\trev_mask);\n\n\tret = ub960_read(priv, UB960_SR_DEVICE_STS, &dev_sts);\n\tif (ret)\n\t\tgoto err_pd_gpio;\n\n\tret = ub960_read(priv, UB960_XR_REFCLK_FREQ, &refclk_freq);\n\tif (ret)\n\t\tgoto err_pd_gpio;\n\n\tdev_dbg(dev, \"refclk valid %u freq %u MHz (clk fw freq %lu MHz)\\n\",\n\t\t!!(dev_sts & BIT(4)), refclk_freq,\n\t\tclk_get_rate(priv->refclk) / 1000000);\n\n\t \n\tret = ub960_write(priv, UB960_SR_RX_PORT_CTL, 0);\n\tif (ret)\n\t\tgoto err_pd_gpio;\n\n\t \n\tif (priv->hw_data->is_ub9702) {\n\t\tret = ub960_update_bits(priv, UB960_SR_RESET,\n\t\t\t\t\tUB960_SR_RESET_GPIO_LOCK_RELEASE,\n\t\t\t\t\tUB960_SR_RESET_GPIO_LOCK_RELEASE);\n\t\tif (ret)\n\t\t\tgoto err_pd_gpio;\n\t}\n\n\treturn 0;\n\nerr_pd_gpio:\n\tgpiod_set_value_cansleep(priv->pd_gpio, 1);\n\tclk_disable_unprepare(priv->refclk);\nerr_disable_vddio:\n\tregulator_disable(priv->vddio);\n\n\treturn ret;\n}\n\nstatic void ub960_disable_core_hw(struct ub960_data *priv)\n{\n\tgpiod_set_value_cansleep(priv->pd_gpio, 1);\n\tclk_disable_unprepare(priv->refclk);\n\tregulator_disable(priv->vddio);\n}\n\nstatic int ub960_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct ub960_data *priv;\n\tunsigned int port_lock_mask;\n\tunsigned int port_mask;\n\tunsigned int nport;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->client = client;\n\n\tpriv->hw_data = device_get_match_data(dev);\n\n\tmutex_init(&priv->reg_lock);\n\n\tINIT_DELAYED_WORK(&priv->poll_work, ub960_handler_work);\n\n\t \n\tpriv->reg_current.indirect_target = 0xff;\n\tpriv->reg_current.rxport = 0xff;\n\tpriv->reg_current.txport = 0xff;\n\n\tret = ub960_get_hw_resources(priv);\n\tif (ret)\n\t\tgoto err_mutex_destroy;\n\n\tret = ub960_enable_core_hw(priv);\n\tif (ret)\n\t\tgoto err_mutex_destroy;\n\n\tret = ub960_parse_dt(priv);\n\tif (ret)\n\t\tgoto err_disable_core_hw;\n\n\tret = ub960_init_tx_ports(priv);\n\tif (ret)\n\t\tgoto err_free_ports;\n\n\tret = ub960_rxport_enable_vpocs(priv);\n\tif (ret)\n\t\tgoto err_free_ports;\n\n\tret = ub960_init_rx_ports(priv);\n\tif (ret)\n\t\tgoto err_disable_vpocs;\n\n\tub960_reset(priv, false);\n\n\tport_mask = 0;\n\n\tfor (nport = 0; nport < priv->hw_data->num_rxports; nport++) {\n\t\tstruct ub960_rxport *rxport = priv->rxports[nport];\n\n\t\tif (!rxport)\n\t\t\tcontinue;\n\n\t\tport_mask |= BIT(nport);\n\t}\n\n\tret = ub960_rxport_wait_locks(priv, port_mask, &port_lock_mask);\n\tif (ret)\n\t\tgoto err_disable_vpocs;\n\n\tif (port_mask != port_lock_mask) {\n\t\tret = -EIO;\n\t\tdev_err_probe(dev, ret, \"Failed to lock all RX ports\\n\");\n\t\tgoto err_disable_vpocs;\n\t}\n\n\t \n\tub960_clear_rx_errors(priv);\n\n\tret = ub960_init_atr(priv);\n\tif (ret)\n\t\tgoto err_disable_vpocs;\n\n\tret = ub960_rxport_add_serializers(priv);\n\tif (ret)\n\t\tgoto err_uninit_atr;\n\n\tret = ub960_create_subdev(priv);\n\tif (ret)\n\t\tgoto err_free_sers;\n\n\tif (client->irq)\n\t\tdev_warn(dev, \"irq support not implemented, using polling\\n\");\n\n\tschedule_delayed_work(&priv->poll_work,\n\t\t\t      msecs_to_jiffies(UB960_POLL_TIME_MS));\n\n\treturn 0;\n\nerr_free_sers:\n\tub960_rxport_remove_serializers(priv);\nerr_uninit_atr:\n\tub960_uninit_atr(priv);\nerr_disable_vpocs:\n\tub960_rxport_disable_vpocs(priv);\nerr_free_ports:\n\tub960_rxport_free_ports(priv);\n\tub960_txport_free_ports(priv);\nerr_disable_core_hw:\n\tub960_disable_core_hw(priv);\nerr_mutex_destroy:\n\tmutex_destroy(&priv->reg_lock);\n\treturn ret;\n}\n\nstatic void ub960_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ub960_data *priv = sd_to_ub960(sd);\n\n\tcancel_delayed_work_sync(&priv->poll_work);\n\n\tub960_destroy_subdev(priv);\n\tub960_rxport_remove_serializers(priv);\n\tub960_uninit_atr(priv);\n\tub960_rxport_disable_vpocs(priv);\n\tub960_rxport_free_ports(priv);\n\tub960_txport_free_ports(priv);\n\tub960_disable_core_hw(priv);\n\tmutex_destroy(&priv->reg_lock);\n}\n\nstatic const struct ub960_hw_data ds90ub960_hw = {\n\t.model = \"ub960\",\n\t.num_rxports = 4,\n\t.num_txports = 2,\n};\n\nstatic const struct ub960_hw_data ds90ub9702_hw = {\n\t.model = \"ub9702\",\n\t.num_rxports = 4,\n\t.num_txports = 2,\n\t.is_ub9702 = true,\n\t.is_fpdlink4 = true,\n};\n\nstatic const struct i2c_device_id ub960_id[] = {\n\t{ \"ds90ub960-q1\", (kernel_ulong_t)&ds90ub960_hw },\n\t{ \"ds90ub9702-q1\", (kernel_ulong_t)&ds90ub9702_hw },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ub960_id);\n\nstatic const struct of_device_id ub960_dt_ids[] = {\n\t{ .compatible = \"ti,ds90ub960-q1\", .data = &ds90ub960_hw },\n\t{ .compatible = \"ti,ds90ub9702-q1\", .data = &ds90ub9702_hw },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ub960_dt_ids);\n\nstatic struct i2c_driver ds90ub960_driver = {\n\t.probe\t\t= ub960_probe,\n\t.remove\t\t= ub960_remove,\n\t.id_table\t= ub960_id,\n\t.driver = {\n\t\t.name\t= \"ds90ub960\",\n\t\t.of_match_table = ub960_dt_ids,\n\t},\n};\nmodule_i2c_driver(ds90ub960_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Texas Instruments FPD-Link III/IV Deserializers Driver\");\nMODULE_AUTHOR(\"Luca Ceresoli <luca@lucaceresoli.net>\");\nMODULE_AUTHOR(\"Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>\");\nMODULE_IMPORT_NS(I2C_ATR);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}