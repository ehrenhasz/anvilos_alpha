{
  "module_name": "ds90ub953.c",
  "hash_id": "7c052db0b5db4a5933d0838eac632f2e434e73473e63e92fe38e3d8c2abb7c2c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ds90ub953.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/fwnode.h>\n#include <linux/gpio/driver.h>\n#include <linux/i2c-atr.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/rational.h>\n#include <linux/regmap.h>\n\n#include <media/i2c/ds90ub9xx.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-mediabus.h>\n#include <media/v4l2-subdev.h>\n\n#define UB953_PAD_SINK\t\t\t0\n#define UB953_PAD_SOURCE\t\t1\n\n#define UB953_NUM_GPIOS\t\t\t4\n\n#define UB953_DEFAULT_CLKOUT_RATE\t25000000UL\n\n#define UB953_REG_RESET_CTL\t\t\t0x01\n#define UB953_REG_RESET_CTL_DIGITAL_RESET_1\tBIT(1)\n#define UB953_REG_RESET_CTL_DIGITAL_RESET_0\tBIT(0)\n\n#define UB953_REG_GENERAL_CFG\t\t\t0x02\n#define UB953_REG_GENERAL_CFG_CONT_CLK\t\tBIT(6)\n#define UB953_REG_GENERAL_CFG_CSI_LANE_SEL_SHIFT\t4\n#define UB953_REG_GENERAL_CFG_CSI_LANE_SEL_MASK\tGENMASK(5, 4)\n#define UB953_REG_GENERAL_CFG_CRC_TX_GEN_ENABLE\tBIT(1)\n#define UB953_REG_GENERAL_CFG_I2C_STRAP_MODE\tBIT(0)\n\n#define UB953_REG_MODE_SEL\t\t\t0x03\n#define UB953_REG_MODE_SEL_MODE_DONE\t\tBIT(3)\n#define UB953_REG_MODE_SEL_MODE_OVERRIDE\tBIT(4)\n#define UB953_REG_MODE_SEL_MODE_MASK\t\tGENMASK(2, 0)\n\n#define UB953_REG_CLKOUT_CTRL0\t\t\t0x06\n#define UB953_REG_CLKOUT_CTRL1\t\t\t0x07\n\n#define UB953_REG_SCL_HIGH_TIME\t\t\t0x0b\n#define UB953_REG_SCL_LOW_TIME\t\t\t0x0c\n\n#define UB953_REG_LOCAL_GPIO_DATA\t\t0x0d\n#define UB953_REG_LOCAL_GPIO_DATA_GPIO_RMTEN(n)\t\tBIT(4 + (n))\n#define UB953_REG_LOCAL_GPIO_DATA_GPIO_OUT_SRC(n)\tBIT(0 + (n))\n\n#define UB953_REG_GPIO_INPUT_CTRL\t\t0x0e\n#define UB953_REG_GPIO_INPUT_CTRL_OUT_EN(n)\tBIT(4 + (n))\n#define UB953_REG_GPIO_INPUT_CTRL_INPUT_EN(n)\tBIT(0 + (n))\n\n#define UB953_REG_REV_MASK_ID\t\t\t0x50\n#define UB953_REG_GENERAL_STATUS\t\t0x52\n\n#define UB953_REG_GPIO_PIN_STS\t\t\t0x53\n#define UB953_REG_GPIO_PIN_STS_GPIO_STS(n)\tBIT(0 + (n))\n\n#define UB953_REG_BIST_ERR_CNT\t\t\t0x54\n#define UB953_REG_CRC_ERR_CNT1\t\t\t0x55\n#define UB953_REG_CRC_ERR_CNT2\t\t\t0x56\n\n#define UB953_REG_CSI_ERR_CNT\t\t\t0x5c\n#define UB953_REG_CSI_ERR_STATUS\t\t0x5d\n#define UB953_REG_CSI_ERR_DLANE01\t\t0x5e\n#define UB953_REG_CSI_ERR_DLANE23\t\t0x5f\n#define UB953_REG_CSI_ERR_CLK_LANE\t\t0x60\n#define UB953_REG_CSI_PKT_HDR_VC_ID\t\t0x61\n#define UB953_REG_PKT_HDR_WC_LSB\t\t0x62\n#define UB953_REG_PKT_HDR_WC_MSB\t\t0x63\n#define UB953_REG_CSI_ECC\t\t\t0x64\n\n#define UB953_REG_IND_ACC_CTL\t\t\t0xb0\n#define UB953_REG_IND_ACC_ADDR\t\t\t0xb1\n#define UB953_REG_IND_ACC_DATA\t\t\t0xb2\n\n#define UB953_REG_FPD3_RX_ID(n)\t\t\t(0xf0 + (n))\n#define UB953_REG_FPD3_RX_ID_LEN\t\t6\n\n \n#define UB953_IND_TARGET_PAT_GEN\t\t0x00\n#define UB953_IND_TARGET_FPD3_TX\t\t0x01\n#define UB953_IND_TARGET_DIE_ID\t\t\t0x02\n\n#define UB953_IND_PGEN_CTL\t\t\t0x01\n#define UB953_IND_PGEN_CTL_PGEN_ENABLE\t\tBIT(0)\n#define UB953_IND_PGEN_CFG\t\t\t0x02\n#define UB953_IND_PGEN_CSI_DI\t\t\t0x03\n#define UB953_IND_PGEN_LINE_SIZE1\t\t0x04\n#define UB953_IND_PGEN_LINE_SIZE0\t\t0x05\n#define UB953_IND_PGEN_BAR_SIZE1\t\t0x06\n#define UB953_IND_PGEN_BAR_SIZE0\t\t0x07\n#define UB953_IND_PGEN_ACT_LPF1\t\t\t0x08\n#define UB953_IND_PGEN_ACT_LPF0\t\t\t0x09\n#define UB953_IND_PGEN_TOT_LPF1\t\t\t0x0a\n#define UB953_IND_PGEN_TOT_LPF0\t\t\t0x0b\n#define UB953_IND_PGEN_LINE_PD1\t\t\t0x0c\n#define UB953_IND_PGEN_LINE_PD0\t\t\t0x0d\n#define UB953_IND_PGEN_VBP\t\t\t0x0e\n#define UB953_IND_PGEN_VFP\t\t\t0x0f\n#define UB953_IND_PGEN_COLOR(n)\t\t\t(0x10 + (n))  \n\n \nenum ub953_mode {\n\t \n\tUB953_MODE_SYNC,\n\t \n\tUB953_MODE_NONSYNC_EXT,\n\t \n\tUB953_MODE_NONSYNC_INT,\n\t \n\tUB953_MODE_DVP,\n};\n\nstruct ub953_hw_data {\n\tconst char *model;\n\tbool is_ub971;\n};\n\nstruct ub953_clkout_data {\n\tu32 hs_div;\n\tu32 m;\n\tu32 n;\n\tunsigned long rate;\n};\n\nstruct ub953_data {\n\tconst struct ub953_hw_data\t*hw_data;\n\n\tstruct i2c_client\t*client;\n\tstruct regmap\t\t*regmap;\n\tstruct clk\t\t*clkin;\n\n\tu32\t\t\tnum_data_lanes;\n\tbool\t\t\tnon_continous_clk;\n\n\tstruct gpio_chip\tgpio_chip;\n\n\tstruct v4l2_subdev\tsd;\n\tstruct media_pad\tpads[2];\n\n\tstruct v4l2_async_notifier\tnotifier;\n\n\tstruct v4l2_subdev\t*source_sd;\n\tu16\t\t\tsource_sd_pad;\n\n\tu64\t\t\tenabled_source_streams;\n\n\t \n\tstruct mutex\t\treg_lock;\n\n\tu8\t\t\tcurrent_indirect_target;\n\n\tstruct clk_hw\t\tclkout_clk_hw;\n\n\tenum ub953_mode\t\tmode;\n\n\tconst struct ds90ub9xx_platform_data\t*plat_data;\n};\n\nstatic inline struct ub953_data *sd_to_ub953(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct ub953_data, sd);\n}\n\n \n\nstatic int ub953_read(struct ub953_data *priv, u8 reg, u8 *val)\n{\n\tunsigned int v;\n\tint ret;\n\n\tmutex_lock(&priv->reg_lock);\n\n\tret = regmap_read(priv->regmap, reg, &v);\n\tif (ret) {\n\t\tdev_err(&priv->client->dev, \"Cannot read register 0x%02x: %d\\n\",\n\t\t\treg, ret);\n\t\tgoto out_unlock;\n\t}\n\n\t*val = v;\n\nout_unlock:\n\tmutex_unlock(&priv->reg_lock);\n\n\treturn ret;\n}\n\nstatic int ub953_write(struct ub953_data *priv, u8 reg, u8 val)\n{\n\tint ret;\n\n\tmutex_lock(&priv->reg_lock);\n\n\tret = regmap_write(priv->regmap, reg, val);\n\tif (ret)\n\t\tdev_err(&priv->client->dev,\n\t\t\t\"Cannot write register 0x%02x: %d\\n\", reg, ret);\n\n\tmutex_unlock(&priv->reg_lock);\n\n\treturn ret;\n}\n\nstatic int ub953_select_ind_reg_block(struct ub953_data *priv, u8 block)\n{\n\tstruct device *dev = &priv->client->dev;\n\tint ret;\n\n\tif (priv->current_indirect_target == block)\n\t\treturn 0;\n\n\tret = regmap_write(priv->regmap, UB953_REG_IND_ACC_CTL, block << 2);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: cannot select indirect target %u (%d)\\n\",\n\t\t\t__func__, block, ret);\n\t\treturn ret;\n\t}\n\n\tpriv->current_indirect_target = block;\n\n\treturn 0;\n}\n\n__maybe_unused\nstatic int ub953_read_ind(struct ub953_data *priv, u8 block, u8 reg, u8 *val)\n{\n\tunsigned int v;\n\tint ret;\n\n\tmutex_lock(&priv->reg_lock);\n\n\tret = ub953_select_ind_reg_block(priv, block);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = regmap_write(priv->regmap, UB953_REG_IND_ACC_ADDR, reg);\n\tif (ret) {\n\t\tdev_err(&priv->client->dev,\n\t\t\t\"Write to IND_ACC_ADDR failed when reading %u:%x02x: %d\\n\",\n\t\t\tblock, reg, ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = regmap_read(priv->regmap, UB953_REG_IND_ACC_DATA, &v);\n\tif (ret) {\n\t\tdev_err(&priv->client->dev,\n\t\t\t\"Write to IND_ACC_DATA failed when reading %u:%x02x: %d\\n\",\n\t\t\tblock, reg, ret);\n\t\tgoto out_unlock;\n\t}\n\n\t*val = v;\n\nout_unlock:\n\tmutex_unlock(&priv->reg_lock);\n\n\treturn ret;\n}\n\n__maybe_unused\nstatic int ub953_write_ind(struct ub953_data *priv, u8 block, u8 reg, u8 val)\n{\n\tint ret;\n\n\tmutex_lock(&priv->reg_lock);\n\n\tret = ub953_select_ind_reg_block(priv, block);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = regmap_write(priv->regmap, UB953_REG_IND_ACC_ADDR, reg);\n\tif (ret) {\n\t\tdev_err(&priv->client->dev,\n\t\t\t\"Write to IND_ACC_ADDR failed when writing %u:%x02x: %d\\n\",\n\t\t\tblock, reg, ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = regmap_write(priv->regmap, UB953_REG_IND_ACC_DATA, val);\n\tif (ret) {\n\t\tdev_err(&priv->client->dev,\n\t\t\t\"Write to IND_ACC_DATA failed when writing %u:%x02x\\n: %d\\n\",\n\t\t\tblock, reg, ret);\n\t}\n\nout_unlock:\n\tmutex_unlock(&priv->reg_lock);\n\n\treturn ret;\n}\n\n \nstatic int ub953_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct ub953_data *priv = gpiochip_get_data(gc);\n\tint ret;\n\tu8 v;\n\n\tret = ub953_read(priv, UB953_REG_GPIO_INPUT_CTRL, &v);\n\tif (ret)\n\t\treturn ret;\n\n\tif (v & UB953_REG_GPIO_INPUT_CTRL_INPUT_EN(offset))\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\telse\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int ub953_gpio_direction_in(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct ub953_data *priv = gpiochip_get_data(gc);\n\n\treturn regmap_update_bits(priv->regmap, UB953_REG_GPIO_INPUT_CTRL,\n\t\t\t\t  UB953_REG_GPIO_INPUT_CTRL_INPUT_EN(offset) |\n\t\t\t\t\t  UB953_REG_GPIO_INPUT_CTRL_OUT_EN(offset),\n\t\t\t\t  UB953_REG_GPIO_INPUT_CTRL_INPUT_EN(offset));\n}\n\nstatic int ub953_gpio_direction_out(struct gpio_chip *gc, unsigned int offset,\n\t\t\t\t    int value)\n{\n\tstruct ub953_data *priv = gpiochip_get_data(gc);\n\tint ret;\n\n\tret = regmap_update_bits(priv->regmap, UB953_REG_LOCAL_GPIO_DATA,\n\t\t\t\t UB953_REG_LOCAL_GPIO_DATA_GPIO_OUT_SRC(offset),\n\t\t\t\t value ? UB953_REG_LOCAL_GPIO_DATA_GPIO_OUT_SRC(offset) :\n\t\t\t\t\t 0);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(priv->regmap, UB953_REG_GPIO_INPUT_CTRL,\n\t\t\t\t  UB953_REG_GPIO_INPUT_CTRL_INPUT_EN(offset) |\n\t\t\t\t\t  UB953_REG_GPIO_INPUT_CTRL_OUT_EN(offset),\n\t\t\t\t  UB953_REG_GPIO_INPUT_CTRL_OUT_EN(offset));\n}\n\nstatic int ub953_gpio_get(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct ub953_data *priv = gpiochip_get_data(gc);\n\tint ret;\n\tu8 v;\n\n\tret = ub953_read(priv, UB953_REG_GPIO_PIN_STS, &v);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(v & UB953_REG_GPIO_PIN_STS_GPIO_STS(offset));\n}\n\nstatic void ub953_gpio_set(struct gpio_chip *gc, unsigned int offset, int value)\n{\n\tstruct ub953_data *priv = gpiochip_get_data(gc);\n\n\tregmap_update_bits(priv->regmap, UB953_REG_LOCAL_GPIO_DATA,\n\t\t\t   UB953_REG_LOCAL_GPIO_DATA_GPIO_OUT_SRC(offset),\n\t\t\t   value ? UB953_REG_LOCAL_GPIO_DATA_GPIO_OUT_SRC(offset) :\n\t\t\t\t   0);\n}\n\nstatic int ub953_gpio_of_xlate(struct gpio_chip *gc,\n\t\t\t       const struct of_phandle_args *gpiospec,\n\t\t\t       u32 *flags)\n{\n\tif (flags)\n\t\t*flags = gpiospec->args[1];\n\n\treturn gpiospec->args[0];\n}\n\nstatic int ub953_gpiochip_probe(struct ub953_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tstruct gpio_chip *gc = &priv->gpio_chip;\n\tint ret;\n\n\t \n\tub953_write(priv, UB953_REG_LOCAL_GPIO_DATA, 0);\n\tub953_write(priv, UB953_REG_GPIO_INPUT_CTRL, 0xf);\n\n\tgc->label = dev_name(dev);\n\tgc->parent = dev;\n\tgc->owner = THIS_MODULE;\n\tgc->base = -1;\n\tgc->can_sleep = true;\n\tgc->ngpio = UB953_NUM_GPIOS;\n\tgc->get_direction = ub953_gpio_get_direction;\n\tgc->direction_input = ub953_gpio_direction_in;\n\tgc->direction_output = ub953_gpio_direction_out;\n\tgc->get = ub953_gpio_get;\n\tgc->set = ub953_gpio_set;\n\tgc->of_xlate = ub953_gpio_of_xlate;\n\tgc->of_gpio_n_cells = 2;\n\n\tret = gpiochip_add_data(gc, priv);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to add GPIOs: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ub953_gpiochip_remove(struct ub953_data *priv)\n{\n\tgpiochip_remove(&priv->gpio_chip);\n}\n\n \n\nstatic int _ub953_set_routing(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *state,\n\t\t\t      struct v4l2_subdev_krouting *routing)\n{\n\tstatic const struct v4l2_mbus_framefmt format = {\n\t\t.width = 640,\n\t\t.height = 480,\n\t\t.code = MEDIA_BUS_FMT_UYVY8_1X16,\n\t\t.field = V4L2_FIELD_NONE,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.ycbcr_enc = V4L2_YCBCR_ENC_601,\n\t\t.quantization = V4L2_QUANTIZATION_LIM_RANGE,\n\t\t.xfer_func = V4L2_XFER_FUNC_SRGB,\n\t};\n\tint ret;\n\n\t \n\n\tif (routing->num_routes > V4L2_FRAME_DESC_ENTRY_MAX)\n\t\treturn -EINVAL;\n\n\tret = v4l2_subdev_routing_validate(sd, routing,\n\t\t\t\t\t   V4L2_SUBDEV_ROUTING_ONLY_1_TO_1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = v4l2_subdev_set_routing_with_fmt(sd, state, routing, &format);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ub953_set_routing(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *state,\n\t\t\t     enum v4l2_subdev_format_whence which,\n\t\t\t     struct v4l2_subdev_krouting *routing)\n{\n\tstruct ub953_data *priv = sd_to_ub953(sd);\n\n\tif (which == V4L2_SUBDEV_FORMAT_ACTIVE && priv->enabled_source_streams)\n\t\treturn -EBUSY;\n\n\treturn _ub953_set_routing(sd, state, routing);\n}\n\nstatic int ub953_get_frame_desc(struct v4l2_subdev *sd, unsigned int pad,\n\t\t\t\tstruct v4l2_mbus_frame_desc *fd)\n{\n\tstruct ub953_data *priv = sd_to_ub953(sd);\n\tstruct v4l2_mbus_frame_desc source_fd;\n\tstruct v4l2_subdev_route *route;\n\tstruct v4l2_subdev_state *state;\n\tint ret;\n\n\tif (pad != UB953_PAD_SOURCE)\n\t\treturn -EINVAL;\n\n\tret = v4l2_subdev_call(priv->source_sd, pad, get_frame_desc,\n\t\t\t       priv->source_sd_pad, &source_fd);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(fd, 0, sizeof(*fd));\n\n\tfd->type = V4L2_MBUS_FRAME_DESC_TYPE_CSI2;\n\n\tstate = v4l2_subdev_lock_and_get_active_state(sd);\n\n\tfor_each_active_route(&state->routing, route) {\n\t\tstruct v4l2_mbus_frame_desc_entry *source_entry = NULL;\n\t\tunsigned int i;\n\n\t\tif (route->source_pad != pad)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < source_fd.num_entries; i++) {\n\t\t\tif (source_fd.entry[i].stream == route->sink_stream) {\n\t\t\t\tsource_entry = &source_fd.entry[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!source_entry) {\n\t\t\tdev_err(&priv->client->dev,\n\t\t\t\t\"Failed to find stream from source frame desc\\n\");\n\t\t\tret = -EPIPE;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tfd->entry[fd->num_entries].stream = route->source_stream;\n\t\tfd->entry[fd->num_entries].flags = source_entry->flags;\n\t\tfd->entry[fd->num_entries].length = source_entry->length;\n\t\tfd->entry[fd->num_entries].pixelcode = source_entry->pixelcode;\n\t\tfd->entry[fd->num_entries].bus.csi2.vc =\n\t\t\tsource_entry->bus.csi2.vc;\n\t\tfd->entry[fd->num_entries].bus.csi2.dt =\n\t\t\tsource_entry->bus.csi2.dt;\n\n\t\tfd->num_entries++;\n\t}\n\nout_unlock:\n\tv4l2_subdev_unlock_state(state);\n\n\treturn ret;\n}\n\nstatic int ub953_set_fmt(struct v4l2_subdev *sd,\n\t\t\t struct v4l2_subdev_state *state,\n\t\t\t struct v4l2_subdev_format *format)\n{\n\tstruct ub953_data *priv = sd_to_ub953(sd);\n\tstruct v4l2_mbus_framefmt *fmt;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE &&\n\t    priv->enabled_source_streams)\n\t\treturn -EBUSY;\n\n\t \n\tif (format->pad == UB953_PAD_SOURCE)\n\t\treturn v4l2_subdev_get_fmt(sd, state, format);\n\n\t \n\tfmt = v4l2_subdev_state_get_stream_format(state, format->pad,\n\t\t\t\t\t\t  format->stream);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\t*fmt = format->format;\n\n\t \n\tfmt = v4l2_subdev_state_get_opposite_stream_format(state, format->pad,\n\t\t\t\t\t\t\t   format->stream);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\t*fmt = format->format;\n\n\treturn 0;\n}\n\nstatic int ub953_init_cfg(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *state)\n{\n\tstruct v4l2_subdev_route routes[] = {\n\t\t{\n\t\t\t.sink_pad = UB953_PAD_SINK,\n\t\t\t.sink_stream = 0,\n\t\t\t.source_pad = UB953_PAD_SOURCE,\n\t\t\t.source_stream = 0,\n\t\t\t.flags = V4L2_SUBDEV_ROUTE_FL_ACTIVE,\n\t\t},\n\t};\n\n\tstruct v4l2_subdev_krouting routing = {\n\t\t.num_routes = ARRAY_SIZE(routes),\n\t\t.routes = routes,\n\t};\n\n\treturn _ub953_set_routing(sd, state, &routing);\n}\n\nstatic int ub953_log_status(struct v4l2_subdev *sd)\n{\n\tstruct ub953_data *priv = sd_to_ub953(sd);\n\tstruct device *dev = &priv->client->dev;\n\tu8 v = 0, v1 = 0, v2 = 0;\n\tunsigned int i;\n\tchar id[UB953_REG_FPD3_RX_ID_LEN];\n\tu8 gpio_local_data = 0;\n\tu8 gpio_input_ctrl = 0;\n\tu8 gpio_pin_sts = 0;\n\n\tfor (i = 0; i < sizeof(id); i++)\n\t\tub953_read(priv, UB953_REG_FPD3_RX_ID(i), &id[i]);\n\n\tdev_info(dev, \"ID '%.*s'\\n\", (int)sizeof(id), id);\n\n\tub953_read(priv, UB953_REG_GENERAL_STATUS, &v);\n\tdev_info(dev, \"GENERAL_STATUS %#02x\\n\", v);\n\n\tub953_read(priv, UB953_REG_CRC_ERR_CNT1, &v1);\n\tub953_read(priv, UB953_REG_CRC_ERR_CNT2, &v2);\n\tdev_info(dev, \"CRC error count %u\\n\", v1 | (v2 << 8));\n\n\tub953_read(priv, UB953_REG_CSI_ERR_CNT, &v);\n\tdev_info(dev, \"CSI error count %u\\n\", v);\n\n\tub953_read(priv, UB953_REG_CSI_ERR_STATUS, &v);\n\tdev_info(dev, \"CSI_ERR_STATUS %#02x\\n\", v);\n\n\tub953_read(priv, UB953_REG_CSI_ERR_DLANE01, &v);\n\tdev_info(dev, \"CSI_ERR_DLANE01 %#02x\\n\", v);\n\n\tub953_read(priv, UB953_REG_CSI_ERR_DLANE23, &v);\n\tdev_info(dev, \"CSI_ERR_DLANE23 %#02x\\n\", v);\n\n\tub953_read(priv, UB953_REG_CSI_ERR_CLK_LANE, &v);\n\tdev_info(dev, \"CSI_ERR_CLK_LANE %#02x\\n\", v);\n\n\tub953_read(priv, UB953_REG_CSI_PKT_HDR_VC_ID, &v);\n\tdev_info(dev, \"CSI packet header VC %u ID %u\\n\", v >> 6, v & 0x3f);\n\n\tub953_read(priv, UB953_REG_PKT_HDR_WC_LSB, &v1);\n\tub953_read(priv, UB953_REG_PKT_HDR_WC_MSB, &v2);\n\tdev_info(dev, \"CSI packet header WC %u\\n\", (v2 << 8) | v1);\n\n\tub953_read(priv, UB953_REG_CSI_ECC, &v);\n\tdev_info(dev, \"CSI ECC %#02x\\n\", v);\n\n\tub953_read(priv, UB953_REG_LOCAL_GPIO_DATA, &gpio_local_data);\n\tub953_read(priv, UB953_REG_GPIO_INPUT_CTRL, &gpio_input_ctrl);\n\tub953_read(priv, UB953_REG_GPIO_PIN_STS, &gpio_pin_sts);\n\n\tfor (i = 0; i < UB953_NUM_GPIOS; i++) {\n\t\tdev_info(dev,\n\t\t\t \"GPIO%u: remote: %u is_input: %u is_output: %u val: %u sts: %u\\n\",\n\t\t\t i,\n\t\t\t !!(gpio_local_data & UB953_REG_LOCAL_GPIO_DATA_GPIO_RMTEN(i)),\n\t\t\t !!(gpio_input_ctrl & UB953_REG_GPIO_INPUT_CTRL_INPUT_EN(i)),\n\t\t\t !!(gpio_input_ctrl & UB953_REG_GPIO_INPUT_CTRL_OUT_EN(i)),\n\t\t\t !!(gpio_local_data & UB953_REG_LOCAL_GPIO_DATA_GPIO_OUT_SRC(i)),\n\t\t\t !!(gpio_pin_sts & UB953_REG_GPIO_PIN_STS_GPIO_STS(i)));\n\t}\n\n\treturn 0;\n}\n\nstatic int ub953_enable_streams(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *state, u32 pad,\n\t\t\t\tu64 streams_mask)\n{\n\tstruct ub953_data *priv = sd_to_ub953(sd);\n\tu64 sink_streams;\n\tint ret;\n\n\tsink_streams = v4l2_subdev_state_xlate_streams(state, UB953_PAD_SOURCE,\n\t\t\t\t\t\t       UB953_PAD_SINK,\n\t\t\t\t\t\t       &streams_mask);\n\n\tret = v4l2_subdev_enable_streams(priv->source_sd, priv->source_sd_pad,\n\t\t\t\t\t sink_streams);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->enabled_source_streams |= streams_mask;\n\n\treturn 0;\n}\n\nstatic int ub953_disable_streams(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *state, u32 pad,\n\t\t\t\t u64 streams_mask)\n{\n\tstruct ub953_data *priv = sd_to_ub953(sd);\n\tu64 sink_streams;\n\tint ret;\n\n\tsink_streams = v4l2_subdev_state_xlate_streams(state, UB953_PAD_SOURCE,\n\t\t\t\t\t\t       UB953_PAD_SINK,\n\t\t\t\t\t\t       &streams_mask);\n\n\tret = v4l2_subdev_disable_streams(priv->source_sd, priv->source_sd_pad,\n\t\t\t\t\t  sink_streams);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->enabled_source_streams &= ~streams_mask;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops ub953_pad_ops = {\n\t.enable_streams = ub953_enable_streams,\n\t.disable_streams = ub953_disable_streams,\n\t.set_routing = ub953_set_routing,\n\t.get_frame_desc = ub953_get_frame_desc,\n\t.get_fmt = v4l2_subdev_get_fmt,\n\t.set_fmt = ub953_set_fmt,\n\t.init_cfg = ub953_init_cfg,\n};\n\nstatic const struct v4l2_subdev_core_ops ub953_subdev_core_ops = {\n\t.log_status = ub953_log_status,\n\t.subscribe_event = v4l2_ctrl_subdev_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n};\n\nstatic const struct v4l2_subdev_ops ub953_subdev_ops = {\n\t.core = &ub953_subdev_core_ops,\n\t.pad = &ub953_pad_ops,\n};\n\nstatic const struct media_entity_operations ub953_entity_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic int ub953_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t      struct v4l2_subdev *source_subdev,\n\t\t\t      struct v4l2_async_connection *asd)\n{\n\tstruct ub953_data *priv = sd_to_ub953(notifier->sd);\n\tstruct device *dev = &priv->client->dev;\n\tint ret;\n\n\tret = media_entity_get_fwnode_pad(&source_subdev->entity,\n\t\t\t\t\t  source_subdev->fwnode,\n\t\t\t\t\t  MEDIA_PAD_FL_SOURCE);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to find pad for %s\\n\",\n\t\t\tsource_subdev->name);\n\t\treturn ret;\n\t}\n\n\tpriv->source_sd = source_subdev;\n\tpriv->source_sd_pad = ret;\n\n\tret = media_create_pad_link(&source_subdev->entity, priv->source_sd_pad,\n\t\t\t\t    &priv->sd.entity, 0,\n\t\t\t\t    MEDIA_LNK_FL_ENABLED |\n\t\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to link %s:%u -> %s:0\\n\",\n\t\t\tsource_subdev->name, priv->source_sd_pad,\n\t\t\tpriv->sd.name);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_async_notifier_operations ub953_notify_ops = {\n\t.bound = ub953_notify_bound,\n};\n\nstatic int ub953_v4l2_notifier_register(struct ub953_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tstruct v4l2_async_connection *asd;\n\tstruct fwnode_handle *ep_fwnode;\n\tint ret;\n\n\tep_fwnode = fwnode_graph_get_endpoint_by_id(dev_fwnode(dev),\n\t\t\t\t\t\t    UB953_PAD_SINK, 0, 0);\n\tif (!ep_fwnode) {\n\t\tdev_err(dev, \"No graph endpoint\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tv4l2_async_subdev_nf_init(&priv->notifier, &priv->sd);\n\n\tasd = v4l2_async_nf_add_fwnode_remote(&priv->notifier, ep_fwnode,\n\t\t\t\t\t      struct v4l2_async_connection);\n\n\tfwnode_handle_put(ep_fwnode);\n\n\tif (IS_ERR(asd)) {\n\t\tdev_err(dev, \"Failed to add subdev: %ld\", PTR_ERR(asd));\n\t\tv4l2_async_nf_cleanup(&priv->notifier);\n\t\treturn PTR_ERR(asd);\n\t}\n\n\tpriv->notifier.ops = &ub953_notify_ops;\n\n\tret = v4l2_async_nf_register(&priv->notifier);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register subdev_notifier\");\n\t\tv4l2_async_nf_cleanup(&priv->notifier);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ub953_v4l2_notifier_unregister(struct ub953_data *priv)\n{\n\tv4l2_async_nf_unregister(&priv->notifier);\n\tv4l2_async_nf_cleanup(&priv->notifier);\n}\n\n \n\nstatic int ub953_i2c_master_init(struct ub953_data *priv)\n{\n\t \n\tu32 ref = 26250000;\n\tu32 scl_high = 915;  \n\tu32 scl_low = 1641;  \n\tint ret;\n\n\tscl_high = div64_u64((u64)scl_high * ref, 1000000000) - 5;\n\tscl_low = div64_u64((u64)scl_low * ref, 1000000000) - 5;\n\n\tret = ub953_write(priv, UB953_REG_SCL_HIGH_TIME, scl_high);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ub953_write(priv, UB953_REG_SCL_LOW_TIME, scl_low);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic u64 ub953_get_fc_rate(struct ub953_data *priv)\n{\n\tswitch (priv->mode) {\n\tcase UB953_MODE_SYNC:\n\t\tif (priv->hw_data->is_ub971)\n\t\t\treturn priv->plat_data->bc_rate * 160ull;\n\t\telse\n\t\t\treturn priv->plat_data->bc_rate / 2 * 160ull;\n\n\tcase UB953_MODE_NONSYNC_EXT:\n\t\t \n\t\treturn clk_get_rate(priv->clkin) * 80ull;\n\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n}\n\nstatic unsigned long ub953_calc_clkout_ub953(struct ub953_data *priv,\n\t\t\t\t\t     unsigned long target, u64 fc,\n\t\t\t\t\t     u8 *hs_div, u8 *m, u8 *n)\n{\n\t \n\tstatic const unsigned long hs_clk_div = 4;\n\n\tu64 fc_divided;\n\tunsigned long mul, div;\n\tunsigned long res;\n\n\t \n\n\tfc_divided = div_u64(fc, hs_clk_div);\n\n\trational_best_approximation(target, fc_divided, (1 << 5) - 1,\n\t\t\t\t    (1 << 8) - 1, &mul, &div);\n\n\tres = div_u64(fc_divided * mul, div);\n\n\t*hs_div = hs_clk_div;\n\t*m = mul;\n\t*n = div;\n\n\treturn res;\n}\n\nstatic unsigned long ub953_calc_clkout_ub971(struct ub953_data *priv,\n\t\t\t\t\t     unsigned long target, u64 fc,\n\t\t\t\t\t     u8 *m, u8 *n)\n{\n\tu64 fc_divided;\n\tunsigned long mul, div;\n\tunsigned long res;\n\n\t \n\n\tfc_divided = div_u64(fc, 8);\n\n\trational_best_approximation(target, fc_divided, (1 << 5) - 1,\n\t\t\t\t    (1 << 8) - 1, &mul, &div);\n\n\tres = div_u64(fc_divided * mul, div);\n\n\t*m = mul;\n\t*n = div;\n\n\treturn res;\n}\n\nstatic void ub953_calc_clkout_params(struct ub953_data *priv,\n\t\t\t\t     unsigned long target_rate,\n\t\t\t\t     struct ub953_clkout_data *clkout_data)\n{\n\tstruct device *dev = &priv->client->dev;\n\tunsigned long clkout_rate;\n\tu64 fc_rate;\n\n\tfc_rate = ub953_get_fc_rate(priv);\n\n\tif (priv->hw_data->is_ub971) {\n\t\tu8 m, n;\n\n\t\tclkout_rate = ub953_calc_clkout_ub971(priv, target_rate,\n\t\t\t\t\t\t      fc_rate, &m, &n);\n\n\t\tclkout_data->m = m;\n\t\tclkout_data->n = n;\n\n\t\tdev_dbg(dev, \"%s %llu * %u / (8 * %u) = %lu (requested %lu)\",\n\t\t\t__func__, fc_rate, m, n, clkout_rate, target_rate);\n\t} else {\n\t\tu8 hs_div, m, n;\n\n\t\tclkout_rate = ub953_calc_clkout_ub953(priv, target_rate,\n\t\t\t\t\t\t      fc_rate, &hs_div, &m, &n);\n\n\t\tclkout_data->hs_div = hs_div;\n\t\tclkout_data->m = m;\n\t\tclkout_data->n = n;\n\n\t\tdev_dbg(dev, \"%s %llu / %u * %u / %u = %lu (requested %lu)\",\n\t\t\t__func__, fc_rate, hs_div, m, n, clkout_rate,\n\t\t\ttarget_rate);\n\t}\n\n\tclkout_data->rate = clkout_rate;\n}\n\nstatic void ub953_write_clkout_regs(struct ub953_data *priv,\n\t\t\t\t    const struct ub953_clkout_data *clkout_data)\n{\n\tu8 clkout_ctrl0, clkout_ctrl1;\n\n\tif (priv->hw_data->is_ub971)\n\t\tclkout_ctrl0 = clkout_data->m;\n\telse\n\t\tclkout_ctrl0 = (__ffs(clkout_data->hs_div) << 5) |\n\t\t\t       clkout_data->m;\n\n\tclkout_ctrl1 = clkout_data->n;\n\n\tub953_write(priv, UB953_REG_CLKOUT_CTRL0, clkout_ctrl0);\n\tub953_write(priv, UB953_REG_CLKOUT_CTRL1, clkout_ctrl1);\n}\n\nstatic unsigned long ub953_clkout_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct ub953_data *priv = container_of(hw, struct ub953_data, clkout_clk_hw);\n\tstruct device *dev = &priv->client->dev;\n\tu8 ctrl0, ctrl1;\n\tu32 mul, div;\n\tu64 fc_rate;\n\tu32 hs_clk_div;\n\tu64 rate;\n\tint ret;\n\n\tret = ub953_read(priv, UB953_REG_CLKOUT_CTRL0, &ctrl0);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read CLKOUT_CTRL0: %d\\n\", ret);\n\t\treturn 0;\n\t}\n\n\tret = ub953_read(priv, UB953_REG_CLKOUT_CTRL1, &ctrl1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read CLKOUT_CTRL1: %d\\n\", ret);\n\t\treturn 0;\n\t}\n\n\tfc_rate = ub953_get_fc_rate(priv);\n\n\tif (priv->hw_data->is_ub971) {\n\t\tmul = ctrl0 & 0x1f;\n\t\tdiv = ctrl1;\n\n\t\tif (div == 0)\n\t\t\treturn 0;\n\n\t\trate = div_u64(fc_rate * mul, 8 * div);\n\n\t\tdev_dbg(dev, \"clkout: fc rate %llu, mul %u, div %u = %llu\\n\",\n\t\t\tfc_rate, mul, div, rate);\n\t} else {\n\t\tmul = ctrl0 & 0x1f;\n\t\ths_clk_div = 1 << (ctrl0 >> 5);\n\t\tdiv = ctrl1;\n\n\t\tif (div == 0)\n\t\t\treturn 0;\n\n\t\trate = div_u64(div_u64(fc_rate, hs_clk_div) * mul, div);\n\n\t\tdev_dbg(dev,\n\t\t\t\"clkout: fc rate %llu, hs_clk_div %u, mul %u, div %u = %llu\\n\",\n\t\t\tfc_rate, hs_clk_div, mul, div, rate);\n\t}\n\n\treturn rate;\n}\n\nstatic long ub953_clkout_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long *parent_rate)\n{\n\tstruct ub953_data *priv = container_of(hw, struct ub953_data, clkout_clk_hw);\n\tstruct ub953_clkout_data clkout_data;\n\n\tub953_calc_clkout_params(priv, rate, &clkout_data);\n\n\treturn clkout_data.rate;\n}\n\nstatic int ub953_clkout_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t unsigned long parent_rate)\n{\n\tstruct ub953_data *priv = container_of(hw, struct ub953_data, clkout_clk_hw);\n\tstruct ub953_clkout_data clkout_data;\n\n\tub953_calc_clkout_params(priv, rate, &clkout_data);\n\n\tdev_dbg(&priv->client->dev, \"%s %lu (requested %lu)\\n\", __func__,\n\t\tclkout_data.rate, rate);\n\n\tub953_write_clkout_regs(priv, &clkout_data);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops ub953_clkout_ops = {\n\t.recalc_rate\t= ub953_clkout_recalc_rate,\n\t.round_rate\t= ub953_clkout_round_rate,\n\t.set_rate\t= ub953_clkout_set_rate,\n};\n\nstatic int ub953_register_clkout(struct ub953_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tconst struct clk_init_data init = {\n\t\t.name = kasprintf(GFP_KERNEL, \"ds90%s.%s.clk_out\",\n\t\t\t\t  priv->hw_data->model, dev_name(dev)),\n\t\t.ops = &ub953_clkout_ops,\n\t};\n\tstruct ub953_clkout_data clkout_data;\n\tint ret;\n\n\tif (!init.name)\n\t\treturn -ENOMEM;\n\n\t \n\tub953_calc_clkout_params(priv, UB953_DEFAULT_CLKOUT_RATE, &clkout_data);\n\tub953_write_clkout_regs(priv, &clkout_data);\n\n\tpriv->clkout_clk_hw.init = &init;\n\n\tret = devm_clk_hw_register(dev, &priv->clkout_clk_hw);\n\tkfree(init.name);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Cannot register clock HW\\n\");\n\n\tret = devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get,\n\t\t\t\t\t  &priv->clkout_clk_hw);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Cannot add OF clock provider\\n\");\n\n\treturn 0;\n}\n\nstatic int ub953_add_i2c_adapter(struct ub953_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tstruct fwnode_handle *i2c_handle;\n\tint ret;\n\n\ti2c_handle = device_get_named_child_node(dev, \"i2c\");\n\tif (!i2c_handle)\n\t\treturn 0;\n\n\tret = i2c_atr_add_adapter(priv->plat_data->atr, priv->plat_data->port,\n\t\t\t\t  dev, i2c_handle);\n\n\tfwnode_handle_put(i2c_handle);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct regmap_config ub953_regmap_config = {\n\t.name = \"ds90ub953\",\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.reg_format_endian = REGMAP_ENDIAN_DEFAULT,\n\t.val_format_endian = REGMAP_ENDIAN_DEFAULT,\n};\n\nstatic int ub953_parse_dt(struct ub953_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tstruct v4l2_fwnode_endpoint vep = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY,\n\t};\n\tstruct fwnode_handle *ep_fwnode;\n\tunsigned char nlanes;\n\tint ret;\n\n\tep_fwnode = fwnode_graph_get_endpoint_by_id(dev_fwnode(dev),\n\t\t\t\t\t\t    UB953_PAD_SINK, 0, 0);\n\tif (!ep_fwnode)\n\t\treturn dev_err_probe(dev, -ENOENT, \"no endpoint found\\n\");\n\n\tret = v4l2_fwnode_endpoint_parse(ep_fwnode, &vep);\n\n\tfwnode_handle_put(ep_fwnode);\n\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"failed to parse sink endpoint data\\n\");\n\n\tnlanes = vep.bus.mipi_csi2.num_data_lanes;\n\tif (nlanes != 1 && nlanes != 2 && nlanes != 4)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"bad number of data-lanes: %u\\n\", nlanes);\n\n\tpriv->num_data_lanes = nlanes;\n\n\tpriv->non_continous_clk = vep.bus.mipi_csi2.flags &\n\t\t\t\t  V4L2_MBUS_CSI2_NONCONTINUOUS_CLOCK;\n\n\treturn 0;\n}\n\nstatic int ub953_hw_init(struct ub953_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tbool mode_override;\n\tint ret;\n\tu8 v;\n\n\tret = ub953_read(priv, UB953_REG_MODE_SEL, &v);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(v & UB953_REG_MODE_SEL_MODE_DONE))\n\t\treturn dev_err_probe(dev, -EIO, \"Mode value not stabilized\\n\");\n\n\tmode_override = v & UB953_REG_MODE_SEL_MODE_OVERRIDE;\n\n\tswitch (v & UB953_REG_MODE_SEL_MODE_MASK) {\n\tcase 0:\n\t\tpriv->mode = UB953_MODE_SYNC;\n\t\tbreak;\n\tcase 2:\n\t\tpriv->mode = UB953_MODE_NONSYNC_EXT;\n\t\tbreak;\n\tcase 3:\n\t\tpriv->mode = UB953_MODE_NONSYNC_INT;\n\t\tbreak;\n\tcase 5:\n\t\tpriv->mode = UB953_MODE_DVP;\n\t\tbreak;\n\tdefault:\n\t\treturn dev_err_probe(dev, -EIO,\n\t\t\t\t     \"Invalid mode in mode register\\n\");\n\t}\n\n\tdev_dbg(dev, \"mode from %s: %#x\\n\", mode_override ? \"reg\" : \"strap\",\n\t\tpriv->mode);\n\n\tif (priv->mode != UB953_MODE_SYNC &&\n\t    priv->mode != UB953_MODE_NONSYNC_EXT)\n\t\treturn dev_err_probe(dev, -ENODEV,\n\t\t\t\t     \"Unsupported mode selected: %u\\n\",\n\t\t\t\t     priv->mode);\n\n\tif (priv->mode == UB953_MODE_NONSYNC_EXT && !priv->clkin)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"clkin required for non-sync ext mode\\n\");\n\n\tret = ub953_read(priv, UB953_REG_REV_MASK_ID, &v);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to read revision\");\n\n\tdev_info(dev, \"Found %s rev/mask %#04x\\n\", priv->hw_data->model, v);\n\n\tret = ub953_read(priv, UB953_REG_GENERAL_CFG, &v);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(dev, \"i2c strap setting %s V\\n\",\n\t\t(v & UB953_REG_GENERAL_CFG_I2C_STRAP_MODE) ? \"1.8\" : \"3.3\");\n\n\tret = ub953_i2c_master_init(priv);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"i2c init failed\\n\");\n\n\tub953_write(priv, UB953_REG_GENERAL_CFG,\n\t\t    (priv->non_continous_clk ? 0 : UB953_REG_GENERAL_CFG_CONT_CLK) |\n\t\t    ((priv->num_data_lanes - 1) << UB953_REG_GENERAL_CFG_CSI_LANE_SEL_SHIFT) |\n\t\t    UB953_REG_GENERAL_CFG_CRC_TX_GEN_ENABLE);\n\n\treturn 0;\n}\n\nstatic int ub953_subdev_init(struct ub953_data *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tint ret;\n\n\tv4l2_i2c_subdev_init(&priv->sd, priv->client, &ub953_subdev_ops);\n\n\tpriv->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |\n\t\t\t  V4L2_SUBDEV_FL_HAS_EVENTS | V4L2_SUBDEV_FL_STREAMS;\n\tpriv->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tpriv->sd.entity.ops = &ub953_entity_ops;\n\n\tpriv->pads[0].flags = MEDIA_PAD_FL_SINK;\n\tpriv->pads[1].flags = MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&priv->sd.entity, 2, priv->pads);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to init pads\\n\");\n\n\tret = v4l2_subdev_init_finalize(&priv->sd);\n\tif (ret)\n\t\tgoto err_entity_cleanup;\n\n\tret = ub953_v4l2_notifier_register(priv);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret,\n\t\t\t      \"v4l2 subdev notifier register failed\\n\");\n\t\tgoto err_free_state;\n\t}\n\n\tret = v4l2_async_register_subdev(&priv->sd);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"v4l2_async_register_subdev error\\n\");\n\t\tgoto err_unreg_notif;\n\t}\n\n\treturn 0;\n\nerr_unreg_notif:\n\tub953_v4l2_notifier_unregister(priv);\nerr_free_state:\n\tv4l2_subdev_cleanup(&priv->sd);\nerr_entity_cleanup:\n\tmedia_entity_cleanup(&priv->sd.entity);\n\n\treturn ret;\n}\n\nstatic void ub953_subdev_uninit(struct ub953_data *priv)\n{\n\tv4l2_async_unregister_subdev(&priv->sd);\n\tub953_v4l2_notifier_unregister(priv);\n\tv4l2_subdev_cleanup(&priv->sd);\n\tfwnode_handle_put(priv->sd.fwnode);\n\tmedia_entity_cleanup(&priv->sd.entity);\n}\n\nstatic int ub953_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct ub953_data *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->client = client;\n\n\tpriv->hw_data = device_get_match_data(dev);\n\n\tpriv->plat_data = dev_get_platdata(&client->dev);\n\tif (!priv->plat_data)\n\t\treturn dev_err_probe(dev, -ENODEV, \"Platform data missing\\n\");\n\n\tmutex_init(&priv->reg_lock);\n\n\t \n\tpriv->current_indirect_target = 0xff;\n\n\tpriv->regmap = devm_regmap_init_i2c(client, &ub953_regmap_config);\n\tif (IS_ERR(priv->regmap)) {\n\t\tret = PTR_ERR(priv->regmap);\n\t\tdev_err_probe(dev, ret, \"Failed to init regmap\\n\");\n\t\tgoto err_mutex_destroy;\n\t}\n\n\tpriv->clkin = devm_clk_get_optional(dev, \"clkin\");\n\tif (IS_ERR(priv->clkin)) {\n\t\tret = PTR_ERR(priv->clkin);\n\t\tdev_err_probe(dev, ret, \"failed to parse 'clkin'\\n\");\n\t\tgoto err_mutex_destroy;\n\t}\n\n\tret = ub953_parse_dt(priv);\n\tif (ret)\n\t\tgoto err_mutex_destroy;\n\n\tret = ub953_hw_init(priv);\n\tif (ret)\n\t\tgoto err_mutex_destroy;\n\n\tret = ub953_gpiochip_probe(priv);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"Failed to init gpiochip\\n\");\n\t\tgoto err_mutex_destroy;\n\t}\n\n\tret = ub953_register_clkout(priv);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"Failed to register clkout\\n\");\n\t\tgoto err_gpiochip_remove;\n\t}\n\n\tret = ub953_subdev_init(priv);\n\tif (ret)\n\t\tgoto err_gpiochip_remove;\n\n\tret = ub953_add_i2c_adapter(priv);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"failed to add remote i2c adapter\\n\");\n\t\tgoto err_subdev_uninit;\n\t}\n\n\treturn 0;\n\nerr_subdev_uninit:\n\tub953_subdev_uninit(priv);\nerr_gpiochip_remove:\n\tub953_gpiochip_remove(priv);\nerr_mutex_destroy:\n\tmutex_destroy(&priv->reg_lock);\n\n\treturn ret;\n}\n\nstatic void ub953_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ub953_data *priv = sd_to_ub953(sd);\n\n\ti2c_atr_del_adapter(priv->plat_data->atr, priv->plat_data->port);\n\n\tub953_subdev_uninit(priv);\n\n\tub953_gpiochip_remove(priv);\n\tmutex_destroy(&priv->reg_lock);\n}\n\nstatic const struct ub953_hw_data ds90ub953_hw = {\n\t.model = \"ub953\",\n};\n\nstatic const struct ub953_hw_data ds90ub971_hw = {\n\t.model = \"ub971\",\n\t.is_ub971 = true,\n};\n\nstatic const struct i2c_device_id ub953_id[] = {\n\t{ \"ds90ub953-q1\", (kernel_ulong_t)&ds90ub953_hw },\n\t{ \"ds90ub971-q1\", (kernel_ulong_t)&ds90ub971_hw },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ub953_id);\n\nstatic const struct of_device_id ub953_dt_ids[] = {\n\t{ .compatible = \"ti,ds90ub953-q1\", .data = &ds90ub953_hw },\n\t{ .compatible = \"ti,ds90ub971-q1\", .data = &ds90ub971_hw },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ub953_dt_ids);\n\nstatic struct i2c_driver ds90ub953_driver = {\n\t.probe\t\t= ub953_probe,\n\t.remove\t\t= ub953_remove,\n\t.id_table\t= ub953_id,\n\t.driver = {\n\t\t.name\t= \"ds90ub953\",\n\t\t.of_match_table = ub953_dt_ids,\n\t},\n};\nmodule_i2c_driver(ds90ub953_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Texas Instruments FPD-Link III/IV CSI-2 Serializers Driver\");\nMODULE_AUTHOR(\"Luca Ceresoli <luca@lucaceresoli.net>\");\nMODULE_AUTHOR(\"Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>\");\nMODULE_IMPORT_NS(I2C_ATR);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}