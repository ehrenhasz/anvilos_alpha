{
  "module_name": "ov2680.c",
  "hash_id": "66ae086475ddba716c0a9ef9f1b63381c5a22e9ce9a2cad30454bdfa404db934",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ov2680.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#include <media/v4l2-cci.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n#define OV2680_CHIP_ID\t\t\t\t0x2680\n\n#define OV2680_REG_STREAM_CTRL\t\t\tCCI_REG8(0x0100)\n#define OV2680_REG_SOFT_RESET\t\t\tCCI_REG8(0x0103)\n\n#define OV2680_REG_CHIP_ID\t\t\tCCI_REG16(0x300a)\n#define OV2680_REG_SC_CMMN_SUB_ID\t\tCCI_REG8(0x302a)\n#define OV2680_REG_PLL_MULTIPLIER\t\tCCI_REG16(0x3081)\n\n#define OV2680_REG_EXPOSURE_PK\t\t\tCCI_REG24(0x3500)\n#define OV2680_REG_R_MANUAL\t\t\tCCI_REG8(0x3503)\n#define OV2680_REG_GAIN_PK\t\t\tCCI_REG16(0x350a)\n\n#define OV2680_REG_SENSOR_CTRL_0A\t\tCCI_REG8(0x370a)\n\n#define OV2680_REG_HORIZONTAL_START\t\tCCI_REG16(0x3800)\n#define OV2680_REG_VERTICAL_START\t\tCCI_REG16(0x3802)\n#define OV2680_REG_HORIZONTAL_END\t\tCCI_REG16(0x3804)\n#define OV2680_REG_VERTICAL_END\t\t\tCCI_REG16(0x3806)\n#define OV2680_REG_HORIZONTAL_OUTPUT_SIZE\tCCI_REG16(0x3808)\n#define OV2680_REG_VERTICAL_OUTPUT_SIZE\t\tCCI_REG16(0x380a)\n#define OV2680_REG_TIMING_HTS\t\t\tCCI_REG16(0x380c)\n#define OV2680_REG_TIMING_VTS\t\t\tCCI_REG16(0x380e)\n#define OV2680_REG_ISP_X_WIN\t\t\tCCI_REG16(0x3810)\n#define OV2680_REG_ISP_Y_WIN\t\t\tCCI_REG16(0x3812)\n#define OV2680_REG_X_INC\t\t\tCCI_REG8(0x3814)\n#define OV2680_REG_Y_INC\t\t\tCCI_REG8(0x3815)\n#define OV2680_REG_FORMAT1\t\t\tCCI_REG8(0x3820)\n#define OV2680_REG_FORMAT2\t\t\tCCI_REG8(0x3821)\n\n#define OV2680_REG_ISP_CTRL00\t\t\tCCI_REG8(0x5080)\n\n#define OV2680_REG_X_WIN\t\t\tCCI_REG16(0x5704)\n#define OV2680_REG_Y_WIN\t\t\tCCI_REG16(0x5706)\n\n#define OV2680_FRAME_RATE\t\t\t30\n\n#define OV2680_NATIVE_WIDTH\t\t\t1616\n#define OV2680_NATIVE_HEIGHT\t\t\t1216\n#define OV2680_NATIVE_START_LEFT\t\t0\n#define OV2680_NATIVE_START_TOP\t\t\t0\n#define OV2680_ACTIVE_WIDTH\t\t\t1600\n#define OV2680_ACTIVE_HEIGHT\t\t\t1200\n#define OV2680_ACTIVE_START_LEFT\t\t8\n#define OV2680_ACTIVE_START_TOP\t\t\t8\n#define OV2680_MIN_CROP_WIDTH\t\t\t2\n#define OV2680_MIN_CROP_HEIGHT\t\t\t2\n\n \n#define OV2680_PLL_PREDIV0\t\t\t2\n\n \n#define OV2680_PLL_PREDIV\t\t\t2\n\n \n#define OV2680_PIXELS_PER_LINE\t\t\t1704\n#define OV2680_LINES_PER_FRAME\t\t\t1294\n\n \n#define OV2680_END_MARGIN\t\t\t16\n\n \n#define OV2680_INTEGRATION_TIME_MARGIN\t\t8\n\n#define OV2680_DEFAULT_WIDTH\t\t\t800\n#define OV2680_DEFAULT_HEIGHT\t\t\t600\n\n \n#define OV2680_FRAME_SIZES\t\t\t2\n\nstatic const char * const ov2680_supply_name[] = {\n\t\"DOVDD\",\n\t\"DVDD\",\n\t\"AVDD\",\n};\n\n#define OV2680_NUM_SUPPLIES ARRAY_SIZE(ov2680_supply_name)\n\nenum {\n\tOV2680_19_2_MHZ,\n\tOV2680_24_MHZ,\n};\n\nstatic const unsigned long ov2680_xvclk_freqs[] = {\n\t[OV2680_19_2_MHZ] = 19200000,\n\t[OV2680_24_MHZ] = 24000000,\n};\n\nstatic const u8 ov2680_pll_multipliers[] = {\n\t[OV2680_19_2_MHZ] = 69,\n\t[OV2680_24_MHZ] = 55,\n};\n\nstruct ov2680_ctrls {\n\tstruct v4l2_ctrl_handler handler;\n\tstruct v4l2_ctrl *exposure;\n\tstruct v4l2_ctrl *gain;\n\tstruct v4l2_ctrl *hflip;\n\tstruct v4l2_ctrl *vflip;\n\tstruct v4l2_ctrl *test_pattern;\n\tstruct v4l2_ctrl *link_freq;\n\tstruct v4l2_ctrl *pixel_rate;\n};\n\nstruct ov2680_mode {\n\tstruct v4l2_rect\t\tcrop;\n\tstruct v4l2_mbus_framefmt\tfmt;\n\tstruct v4l2_fract\t\tframe_interval;\n\tbool\t\t\t\tbinning;\n\tu16\t\t\t\th_start;\n\tu16\t\t\t\tv_start;\n\tu16\t\t\t\th_end;\n\tu16\t\t\t\tv_end;\n\tu16\t\t\t\th_output_size;\n\tu16\t\t\t\tv_output_size;\n\tu16\t\t\t\thts;\n\tu16\t\t\t\tvts;\n};\n\nstruct ov2680_dev {\n\tstruct device\t\t\t*dev;\n\tstruct regmap\t\t\t*regmap;\n\tstruct v4l2_subdev\t\tsd;\n\n\tstruct media_pad\t\tpad;\n\tstruct clk\t\t\t*xvclk;\n\tu32\t\t\t\txvclk_freq;\n\tu8\t\t\t\tpll_mult;\n\ts64\t\t\t\tlink_freq[1];\n\tu64\t\t\t\tpixel_rate;\n\tstruct regulator_bulk_data\tsupplies[OV2680_NUM_SUPPLIES];\n\n\tstruct gpio_desc\t\t*pwdn_gpio;\n\tstruct mutex\t\t\tlock;  \n\n\tbool\t\t\t\tis_streaming;\n\n\tstruct ov2680_ctrls\t\tctrls;\n\tstruct ov2680_mode\t\tmode;\n};\n\nstatic const struct v4l2_rect ov2680_default_crop = {\n\t.left = OV2680_ACTIVE_START_LEFT,\n\t.top = OV2680_ACTIVE_START_TOP,\n\t.width = OV2680_ACTIVE_WIDTH,\n\t.height = OV2680_ACTIVE_HEIGHT,\n};\n\nstatic const char * const test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Color Bars\",\n\t\"Random Data\",\n\t\"Square\",\n\t\"Black Image\",\n};\n\nstatic const int ov2680_hv_flip_bayer_order[] = {\n\tMEDIA_BUS_FMT_SBGGR10_1X10,\n\tMEDIA_BUS_FMT_SGRBG10_1X10,\n\tMEDIA_BUS_FMT_SGBRG10_1X10,\n\tMEDIA_BUS_FMT_SRGGB10_1X10,\n};\n\nstatic const struct reg_sequence ov2680_global_setting[] = {\n\t \n\t{0x3016, 0x1c},\n\n\t \n\t{0x3503, 0x03},\n\n\t \n\t{0x3603, 0x39},  \n\t{0x3604, 0x24},  \n\t{0x3621, 0x37},  \n\n\t \n\t{0x3701, 0x64},  \n\t{0x3705, 0x3c},  \n\t{0x370c, 0x50},  \n\t{0x370d, 0xc0},  \n\t{0x3718, 0x88},  \n\n\t \n\t{0x3781, 0x80},  \n\t{0x3784, 0x0c},  \n\t{0x3789, 0x60},  \n\n\t \n\t{0x4000, 0x81},\n\n\t \n\t{0x4008, 0x00},\n\t{0x4009, 0x03},\n\n\t \n\t{0x4602, 0x02},\n\n\t \n\t{0x481f, 0x36},\n\n\t \n\t{0x4825, 0x36},\n\n\t \n\t{0x5002, 0x30},\n\n\t \n\t{0x5708, 0x01},\n\n\t \n\t{0x5780, 0x3e},\n\n\t \n\t{0x5788, 0x02},\n\n\t \n\t{0x578e, 0x08},\n\n\t \n\t{0x578f, 0x0c},\n\n\t \n\t{0x5792, 0x00},\n};\n\nstatic struct ov2680_dev *to_ov2680_dev(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct ov2680_dev, sd);\n}\n\nstatic inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct ov2680_dev,\n\t\t\t     ctrls.handler)->sd;\n}\n\nstatic void ov2680_power_up(struct ov2680_dev *sensor)\n{\n\tif (!sensor->pwdn_gpio)\n\t\treturn;\n\n\tgpiod_set_value(sensor->pwdn_gpio, 0);\n\tusleep_range(5000, 10000);\n}\n\nstatic void ov2680_power_down(struct ov2680_dev *sensor)\n{\n\tif (!sensor->pwdn_gpio)\n\t\treturn;\n\n\tgpiod_set_value(sensor->pwdn_gpio, 1);\n\tusleep_range(5000, 10000);\n}\n\nstatic void ov2680_set_bayer_order(struct ov2680_dev *sensor,\n\t\t\t\t   struct v4l2_mbus_framefmt *fmt)\n{\n\tint hv_flip = 0;\n\n\tif (sensor->ctrls.vflip && sensor->ctrls.vflip->val)\n\t\thv_flip += 1;\n\n\tif (sensor->ctrls.hflip && sensor->ctrls.hflip->val)\n\t\thv_flip += 2;\n\n\tfmt->code = ov2680_hv_flip_bayer_order[hv_flip];\n}\n\nstatic struct v4l2_mbus_framefmt *\n__ov2680_get_pad_format(struct ov2680_dev *sensor,\n\t\t\tstruct v4l2_subdev_state *state,\n\t\t\tunsigned int pad,\n\t\t\tenum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&sensor->sd, state, pad);\n\n\treturn &sensor->mode.fmt;\n}\n\nstatic struct v4l2_rect *\n__ov2680_get_pad_crop(struct ov2680_dev *sensor,\n\t\t      struct v4l2_subdev_state *state,\n\t\t      unsigned int pad,\n\t\t      enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_crop(&sensor->sd, state, pad);\n\n\treturn &sensor->mode.crop;\n}\n\nstatic void ov2680_fill_format(struct ov2680_dev *sensor,\n\t\t\t       struct v4l2_mbus_framefmt *fmt,\n\t\t\t       unsigned int width, unsigned int height)\n{\n\tmemset(fmt, 0, sizeof(*fmt));\n\tfmt->width = width;\n\tfmt->height = height;\n\tfmt->field = V4L2_FIELD_NONE;\n\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n\tov2680_set_bayer_order(sensor, fmt);\n}\n\nstatic void ov2680_calc_mode(struct ov2680_dev *sensor)\n{\n\tint width = sensor->mode.fmt.width;\n\tint height = sensor->mode.fmt.height;\n\tint orig_width = width;\n\tint orig_height = height;\n\n\tif (width  <= (sensor->mode.crop.width / 2) &&\n\t    height <= (sensor->mode.crop.height / 2)) {\n\t\tsensor->mode.binning = true;\n\t\twidth *= 2;\n\t\theight *= 2;\n\t} else {\n\t\tsensor->mode.binning = false;\n\t}\n\n\tsensor->mode.h_start = (sensor->mode.crop.left +\n\t\t\t\t(sensor->mode.crop.width - width) / 2) & ~1;\n\tsensor->mode.v_start = (sensor->mode.crop.top +\n\t\t\t\t(sensor->mode.crop.height - height) / 2) & ~1;\n\tsensor->mode.h_end =\n\t\tmin(sensor->mode.h_start + width + OV2680_END_MARGIN - 1,\n\t\t    OV2680_NATIVE_WIDTH - 1);\n\tsensor->mode.v_end =\n\t\tmin(sensor->mode.v_start + height + OV2680_END_MARGIN - 1,\n\t\t    OV2680_NATIVE_HEIGHT - 1);\n\tsensor->mode.h_output_size = orig_width;\n\tsensor->mode.v_output_size = orig_height;\n\tsensor->mode.hts = OV2680_PIXELS_PER_LINE;\n\tsensor->mode.vts = OV2680_LINES_PER_FRAME;\n}\n\nstatic int ov2680_set_mode(struct ov2680_dev *sensor)\n{\n\tu8 sensor_ctrl_0a, inc, fmt1, fmt2;\n\tint ret = 0;\n\n\tif (sensor->mode.binning) {\n\t\tsensor_ctrl_0a = 0x23;\n\t\tinc = 0x31;\n\t\tfmt1 = 0xc2;\n\t\tfmt2 = 0x01;\n\t} else {\n\t\tsensor_ctrl_0a = 0x21;\n\t\tinc = 0x11;\n\t\tfmt1 = 0xc0;\n\t\tfmt2 = 0x00;\n\t}\n\n\tcci_write(sensor->regmap, OV2680_REG_SENSOR_CTRL_0A,\n\t\t  sensor_ctrl_0a, &ret);\n\tcci_write(sensor->regmap, OV2680_REG_HORIZONTAL_START,\n\t\t  sensor->mode.h_start, &ret);\n\tcci_write(sensor->regmap, OV2680_REG_VERTICAL_START,\n\t\t  sensor->mode.v_start, &ret);\n\tcci_write(sensor->regmap, OV2680_REG_HORIZONTAL_END,\n\t\t  sensor->mode.h_end, &ret);\n\tcci_write(sensor->regmap, OV2680_REG_VERTICAL_END,\n\t\t  sensor->mode.v_end, &ret);\n\tcci_write(sensor->regmap, OV2680_REG_HORIZONTAL_OUTPUT_SIZE,\n\t\t  sensor->mode.h_output_size, &ret);\n\tcci_write(sensor->regmap, OV2680_REG_VERTICAL_OUTPUT_SIZE,\n\t\t  sensor->mode.v_output_size, &ret);\n\tcci_write(sensor->regmap, OV2680_REG_TIMING_HTS,\n\t\t  sensor->mode.hts, &ret);\n\tcci_write(sensor->regmap, OV2680_REG_TIMING_VTS,\n\t\t  sensor->mode.vts, &ret);\n\tcci_write(sensor->regmap, OV2680_REG_ISP_X_WIN, 0, &ret);\n\tcci_write(sensor->regmap, OV2680_REG_ISP_Y_WIN, 0, &ret);\n\tcci_write(sensor->regmap, OV2680_REG_X_INC, inc, &ret);\n\tcci_write(sensor->regmap, OV2680_REG_Y_INC, inc, &ret);\n\tcci_write(sensor->regmap, OV2680_REG_X_WIN,\n\t\t  sensor->mode.h_output_size, &ret);\n\tcci_write(sensor->regmap, OV2680_REG_Y_WIN,\n\t\t  sensor->mode.v_output_size, &ret);\n\tcci_write(sensor->regmap, OV2680_REG_FORMAT1, fmt1, &ret);\n\tcci_write(sensor->regmap, OV2680_REG_FORMAT2, fmt2, &ret);\n\n\treturn ret;\n}\n\nstatic int ov2680_set_vflip(struct ov2680_dev *sensor, s32 val)\n{\n\tint ret;\n\n\tif (sensor->is_streaming)\n\t\treturn -EBUSY;\n\n\tret = cci_update_bits(sensor->regmap, OV2680_REG_FORMAT1,\n\t\t\t      BIT(2), val ? BIT(2) : 0, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tov2680_set_bayer_order(sensor, &sensor->mode.fmt);\n\treturn 0;\n}\n\nstatic int ov2680_set_hflip(struct ov2680_dev *sensor, s32 val)\n{\n\tint ret;\n\n\tif (sensor->is_streaming)\n\t\treturn -EBUSY;\n\n\tret = cci_update_bits(sensor->regmap, OV2680_REG_FORMAT2,\n\t\t\t      BIT(2), val ? BIT(2) : 0, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tov2680_set_bayer_order(sensor, &sensor->mode.fmt);\n\treturn 0;\n}\n\nstatic int ov2680_test_pattern_set(struct ov2680_dev *sensor, int value)\n{\n\tint ret = 0;\n\n\tif (!value)\n\t\treturn cci_update_bits(sensor->regmap, OV2680_REG_ISP_CTRL00,\n\t\t\t\t       BIT(7), 0, NULL);\n\n\tcci_update_bits(sensor->regmap, OV2680_REG_ISP_CTRL00,\n\t\t\t0x03, value - 1, &ret);\n\tcci_update_bits(sensor->regmap, OV2680_REG_ISP_CTRL00,\n\t\t\tBIT(7), BIT(7), &ret);\n\n\treturn ret;\n}\n\nstatic int ov2680_gain_set(struct ov2680_dev *sensor, u32 gain)\n{\n\treturn cci_write(sensor->regmap, OV2680_REG_GAIN_PK, gain, NULL);\n}\n\nstatic int ov2680_exposure_set(struct ov2680_dev *sensor, u32 exp)\n{\n\treturn cci_write(sensor->regmap, OV2680_REG_EXPOSURE_PK, exp << 4,\n\t\t\t NULL);\n}\n\nstatic int ov2680_stream_enable(struct ov2680_dev *sensor)\n{\n\tint ret;\n\n\tret = cci_write(sensor->regmap, OV2680_REG_PLL_MULTIPLIER,\n\t\t\tsensor->pll_mult, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_multi_reg_write(sensor->regmap,\n\t\t\t\t     ov2680_global_setting,\n\t\t\t\t     ARRAY_SIZE(ov2680_global_setting));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov2680_set_mode(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = __v4l2_ctrl_handler_setup(&sensor->ctrls.handler);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn cci_write(sensor->regmap, OV2680_REG_STREAM_CTRL, 1, NULL);\n}\n\nstatic int ov2680_stream_disable(struct ov2680_dev *sensor)\n{\n\treturn cci_write(sensor->regmap, OV2680_REG_STREAM_CTRL, 0, NULL);\n}\n\nstatic int ov2680_power_off(struct ov2680_dev *sensor)\n{\n\tclk_disable_unprepare(sensor->xvclk);\n\tov2680_power_down(sensor);\n\tregulator_bulk_disable(OV2680_NUM_SUPPLIES, sensor->supplies);\n\treturn 0;\n}\n\nstatic int ov2680_power_on(struct ov2680_dev *sensor)\n{\n\tint ret;\n\n\tret = regulator_bulk_enable(OV2680_NUM_SUPPLIES, sensor->supplies);\n\tif (ret < 0) {\n\t\tdev_err(sensor->dev, \"failed to enable regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!sensor->pwdn_gpio) {\n\t\tret = cci_write(sensor->regmap, OV2680_REG_SOFT_RESET, 0x01,\n\t\t\t\tNULL);\n\t\tif (ret != 0) {\n\t\t\tdev_err(sensor->dev, \"sensor soft reset failed\\n\");\n\t\t\tgoto err_disable_regulators;\n\t\t}\n\t\tusleep_range(1000, 2000);\n\t} else {\n\t\tov2680_power_down(sensor);\n\t\tov2680_power_up(sensor);\n\t}\n\n\tret = clk_prepare_enable(sensor->xvclk);\n\tif (ret < 0)\n\t\tgoto err_disable_regulators;\n\n\treturn 0;\n\nerr_disable_regulators:\n\tregulator_bulk_disable(OV2680_NUM_SUPPLIES, sensor->supplies);\n\treturn ret;\n}\n\nstatic int ov2680_s_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_subdev_frame_interval *fi)\n{\n\tstruct ov2680_dev *sensor = to_ov2680_dev(sd);\n\n\tmutex_lock(&sensor->lock);\n\tfi->interval = sensor->mode.frame_interval;\n\tmutex_unlock(&sensor->lock);\n\n\treturn 0;\n}\n\nstatic int ov2680_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct ov2680_dev *sensor = to_ov2680_dev(sd);\n\tint ret = 0;\n\n\tmutex_lock(&sensor->lock);\n\n\tif (sensor->is_streaming == !!enable)\n\t\tgoto unlock;\n\n\tif (enable) {\n\t\tret = pm_runtime_resume_and_get(sensor->sd.dev);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\n\t\tret = ov2680_stream_enable(sensor);\n\t\tif (ret < 0) {\n\t\t\tpm_runtime_put(sensor->sd.dev);\n\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\tret = ov2680_stream_disable(sensor);\n\t\tpm_runtime_put(sensor->sd.dev);\n\t}\n\n\tsensor->is_streaming = !!enable;\n\nunlock:\n\tmutex_unlock(&sensor->lock);\n\n\treturn ret;\n}\n\nstatic int ov2680_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct ov2680_dev *sensor = to_ov2680_dev(sd);\n\n\tif (code->index != 0)\n\t\treturn -EINVAL;\n\n\tcode->code = sensor->mode.fmt.code;\n\n\treturn 0;\n}\n\nstatic int ov2680_get_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct ov2680_dev *sensor = to_ov2680_dev(sd);\n\tstruct v4l2_mbus_framefmt *fmt;\n\n\tfmt = __ov2680_get_pad_format(sensor, sd_state, format->pad,\n\t\t\t\t      format->which);\n\n\tmutex_lock(&sensor->lock);\n\tformat->format = *fmt;\n\tmutex_unlock(&sensor->lock);\n\n\treturn 0;\n}\n\nstatic int ov2680_set_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct ov2680_dev *sensor = to_ov2680_dev(sd);\n\tstruct v4l2_mbus_framefmt *try_fmt;\n\tconst struct v4l2_rect *crop;\n\tunsigned int width, height;\n\tint ret = 0;\n\n\tcrop = __ov2680_get_pad_crop(sensor, sd_state, format->pad,\n\t\t\t\t     format->which);\n\n\t \n\twidth = clamp_val(ALIGN(format->format.width, 2),\n\t\t\t  OV2680_MIN_CROP_WIDTH, crop->width);\n\theight = clamp_val(ALIGN(format->format.height, 2),\n\t\t\t   OV2680_MIN_CROP_HEIGHT, crop->height);\n\n\tov2680_fill_format(sensor, &format->format, width, height);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\ttry_fmt = v4l2_subdev_get_try_format(sd, sd_state, 0);\n\t\t*try_fmt = format->format;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&sensor->lock);\n\n\tif (sensor->is_streaming) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tsensor->mode.fmt = format->format;\n\tov2680_calc_mode(sensor);\n\nunlock:\n\tmutex_unlock(&sensor->lock);\n\n\treturn ret;\n}\n\nstatic int ov2680_get_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct ov2680_dev *sensor = to_ov2680_dev(sd);\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tmutex_lock(&sensor->lock);\n\t\tsel->r = *__ov2680_get_pad_crop(sensor, state, sel->pad,\n\t\t\t\t\t\tsel->which);\n\t\tmutex_unlock(&sensor->lock);\n\t\tbreak;\n\tcase V4L2_SEL_TGT_NATIVE_SIZE:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.top = 0;\n\t\tsel->r.left = 0;\n\t\tsel->r.width = OV2680_NATIVE_WIDTH;\n\t\tsel->r.height = OV2680_NATIVE_HEIGHT;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tsel->r = ov2680_default_crop;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov2680_set_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct ov2680_dev *sensor = to_ov2680_dev(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct v4l2_rect *crop;\n\tstruct v4l2_rect rect;\n\n\tif (sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\t \n\trect.left = clamp_val(ALIGN(sel->r.left, 2),\n\t\t\t      OV2680_NATIVE_START_LEFT, OV2680_NATIVE_WIDTH);\n\trect.top = clamp_val(ALIGN(sel->r.top, 2),\n\t\t\t     OV2680_NATIVE_START_TOP, OV2680_NATIVE_HEIGHT);\n\trect.width = clamp_val(ALIGN(sel->r.width, 2),\n\t\t\t       OV2680_MIN_CROP_WIDTH, OV2680_NATIVE_WIDTH);\n\trect.height = clamp_val(ALIGN(sel->r.height, 2),\n\t\t\t\tOV2680_MIN_CROP_HEIGHT, OV2680_NATIVE_HEIGHT);\n\n\t \n\trect.width = min_t(unsigned int, rect.width,\n\t\t\t   OV2680_NATIVE_WIDTH - rect.left);\n\trect.height = min_t(unsigned int, rect.height,\n\t\t\t    OV2680_NATIVE_HEIGHT - rect.top);\n\n\tcrop = __ov2680_get_pad_crop(sensor, state, sel->pad, sel->which);\n\n\tmutex_lock(&sensor->lock);\n\tif (rect.width != crop->width || rect.height != crop->height) {\n\t\t \n\t\tformat = __ov2680_get_pad_format(sensor, state, sel->pad,\n\t\t\t\t\t\t sel->which);\n\t\tformat->width = rect.width;\n\t\tformat->height = rect.height;\n\t}\n\n\t*crop = rect;\n\tmutex_unlock(&sensor->lock);\n\n\tsel->r = rect;\n\n\treturn 0;\n}\n\nstatic int ov2680_init_cfg(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state)\n{\n\tstruct ov2680_dev *sensor = to_ov2680_dev(sd);\n\n\tsd_state->pads[0].try_crop = ov2680_default_crop;\n\n\tov2680_fill_format(sensor, &sd_state->pads[0].try_fmt,\n\t\t\t   OV2680_DEFAULT_WIDTH, OV2680_DEFAULT_HEIGHT);\n\treturn 0;\n}\n\nstatic int ov2680_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct ov2680_dev *sensor = to_ov2680_dev(sd);\n\tstruct v4l2_rect *crop;\n\n\tif (fse->index >= OV2680_FRAME_SIZES)\n\t\treturn -EINVAL;\n\n\tcrop = __ov2680_get_pad_crop(sensor, sd_state, fse->pad, fse->which);\n\tif (!crop)\n\t\treturn -EINVAL;\n\n\tfse->min_width = crop->width / (fse->index + 1);\n\tfse->min_height = crop->height / (fse->index + 1);\n\tfse->max_width = fse->min_width;\n\tfse->max_height = fse->min_height;\n\n\treturn 0;\n}\n\nstatic bool ov2680_valid_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_subdev_frame_interval_enum *fie)\n{\n\tstruct v4l2_subdev_frame_size_enum fse = {\n\t\t.pad = fie->pad,\n\t\t.which = fie->which,\n\t};\n\tint i;\n\n\tfor (i = 0; i < OV2680_FRAME_SIZES; i++) {\n\t\tfse.index = i;\n\n\t\tif (ov2680_enum_frame_size(sd, sd_state, &fse))\n\t\t\treturn false;\n\n\t\tif (fie->width == fse.min_width &&\n\t\t    fie->height == fse.min_height)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int ov2680_enum_frame_interval(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_frame_interval_enum *fie)\n{\n\tstruct ov2680_dev *sensor = to_ov2680_dev(sd);\n\n\t \n\tif (fie->index || !ov2680_valid_frame_size(sd, sd_state, fie))\n\t\treturn -EINVAL;\n\n\tfie->interval = sensor->mode.frame_interval;\n\n\treturn 0;\n}\n\nstatic int ov2680_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = ctrl_to_sd(ctrl);\n\tstruct ov2680_dev *sensor = to_ov2680_dev(sd);\n\tint ret;\n\n\t \n\tif (!pm_runtime_get_if_in_use(sensor->sd.dev)) {\n\t\tov2680_set_bayer_order(sensor, &sensor->mode.fmt);\n\t\treturn 0;\n\t}\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_ANALOGUE_GAIN:\n\t\tret = ov2680_gain_set(sensor, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE:\n\t\tret = ov2680_exposure_set(sensor, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tret = ov2680_set_vflip(sensor, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tret = ov2680_set_hflip(sensor, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tret = ov2680_test_pattern_set(sensor, ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tpm_runtime_put(sensor->sd.dev);\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops ov2680_ctrl_ops = {\n\t.s_ctrl = ov2680_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_video_ops ov2680_video_ops = {\n\t.g_frame_interval\t= ov2680_s_g_frame_interval,\n\t.s_frame_interval\t= ov2680_s_g_frame_interval,\n\t.s_stream\t\t= ov2680_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops ov2680_pad_ops = {\n\t.init_cfg\t\t= ov2680_init_cfg,\n\t.enum_mbus_code\t\t= ov2680_enum_mbus_code,\n\t.enum_frame_size\t= ov2680_enum_frame_size,\n\t.enum_frame_interval\t= ov2680_enum_frame_interval,\n\t.get_fmt\t\t= ov2680_get_fmt,\n\t.set_fmt\t\t= ov2680_set_fmt,\n\t.get_selection\t\t= ov2680_get_selection,\n\t.set_selection\t\t= ov2680_set_selection,\n};\n\nstatic const struct v4l2_subdev_ops ov2680_subdev_ops = {\n\t.video\t= &ov2680_video_ops,\n\t.pad\t= &ov2680_pad_ops,\n};\n\nstatic int ov2680_mode_init(struct ov2680_dev *sensor)\n{\n\t \n\tsensor->mode.crop = ov2680_default_crop;\n\tov2680_fill_format(sensor, &sensor->mode.fmt,\n\t\t\t   OV2680_DEFAULT_WIDTH, OV2680_DEFAULT_HEIGHT);\n\tov2680_calc_mode(sensor);\n\n\tsensor->mode.frame_interval.denominator = OV2680_FRAME_RATE;\n\tsensor->mode.frame_interval.numerator = 1;\n\n\treturn 0;\n}\n\nstatic int ov2680_v4l2_register(struct ov2680_dev *sensor)\n{\n\tstruct i2c_client *client = to_i2c_client(sensor->dev);\n\tconst struct v4l2_ctrl_ops *ops = &ov2680_ctrl_ops;\n\tstruct ov2680_ctrls *ctrls = &sensor->ctrls;\n\tstruct v4l2_ctrl_handler *hdl = &ctrls->handler;\n\tint exp_max = OV2680_LINES_PER_FRAME - OV2680_INTEGRATION_TIME_MARGIN;\n\tint ret = 0;\n\n\tv4l2_i2c_subdev_init(&sensor->sd, client, &ov2680_subdev_ops);\n\n\tsensor->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsensor->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tsensor->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\n\tret = media_entity_pads_init(&sensor->sd.entity, 1, &sensor->pad);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv4l2_ctrl_handler_init(hdl, 5);\n\n\thdl->lock = &sensor->lock;\n\n\tctrls->vflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VFLIP, 0, 1, 1, 0);\n\tctrls->hflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HFLIP, 0, 1, 1, 0);\n\n\tctrls->test_pattern = v4l2_ctrl_new_std_menu_items(hdl,\n\t\t\t\t\t&ov2680_ctrl_ops, V4L2_CID_TEST_PATTERN,\n\t\t\t\t\tARRAY_SIZE(test_pattern_menu) - 1,\n\t\t\t\t\t0, 0, test_pattern_menu);\n\n\tctrls->exposure = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_EXPOSURE,\n\t\t\t\t\t    0, exp_max, 1, exp_max);\n\n\tctrls->gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_ANALOGUE_GAIN,\n\t\t\t\t\t0, 1023, 1, 250);\n\n\tctrls->link_freq = v4l2_ctrl_new_int_menu(hdl, NULL, V4L2_CID_LINK_FREQ,\n\t\t\t\t\t\t  0, 0, sensor->link_freq);\n\tctrls->pixel_rate = v4l2_ctrl_new_std(hdl, NULL, V4L2_CID_PIXEL_RATE,\n\t\t\t\t\t      0, sensor->pixel_rate,\n\t\t\t\t\t      1, sensor->pixel_rate);\n\n\tif (hdl->error) {\n\t\tret = hdl->error;\n\t\tgoto cleanup_entity;\n\t}\n\n\tctrls->vflip->flags |= V4L2_CTRL_FLAG_MODIFY_LAYOUT;\n\tctrls->hflip->flags |= V4L2_CTRL_FLAG_MODIFY_LAYOUT;\n\tctrls->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tsensor->sd.ctrl_handler = hdl;\n\n\tret = v4l2_async_register_subdev(&sensor->sd);\n\tif (ret < 0)\n\t\tgoto cleanup_entity;\n\n\treturn 0;\n\ncleanup_entity:\n\tmedia_entity_cleanup(&sensor->sd.entity);\n\tv4l2_ctrl_handler_free(hdl);\n\n\treturn ret;\n}\n\nstatic int ov2680_get_regulators(struct ov2680_dev *sensor)\n{\n\tint i;\n\n\tfor (i = 0; i < OV2680_NUM_SUPPLIES; i++)\n\t\tsensor->supplies[i].supply = ov2680_supply_name[i];\n\n\treturn devm_regulator_bulk_get(sensor->dev,\n\t\t\t\t       OV2680_NUM_SUPPLIES, sensor->supplies);\n}\n\nstatic int ov2680_check_id(struct ov2680_dev *sensor)\n{\n\tu64 chip_id, rev;\n\tint ret = 0;\n\n\tcci_read(sensor->regmap, OV2680_REG_CHIP_ID, &chip_id, &ret);\n\tcci_read(sensor->regmap, OV2680_REG_SC_CMMN_SUB_ID, &rev, &ret);\n\tif (ret < 0) {\n\t\tdev_err(sensor->dev, \"failed to read chip id\\n\");\n\t\treturn ret;\n\t}\n\n\tif (chip_id != OV2680_CHIP_ID) {\n\t\tdev_err(sensor->dev, \"chip id: 0x%04llx does not match expected 0x%04x\\n\",\n\t\t\tchip_id, OV2680_CHIP_ID);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(sensor->dev, \"sensor_revision id = 0x%llx, rev= %lld\\n\",\n\t\t chip_id, rev & 0x0f);\n\n\treturn 0;\n}\n\nstatic int ov2680_parse_dt(struct ov2680_dev *sensor)\n{\n\tstruct v4l2_fwnode_endpoint bus_cfg = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY,\n\t};\n\tstruct device *dev = sensor->dev;\n\tstruct fwnode_handle *ep_fwnode;\n\tstruct gpio_desc *gpio;\n\tunsigned int rate = 0;\n\tint i, ret;\n\n\t \n\tep_fwnode = fwnode_graph_get_next_endpoint(dev_fwnode(dev), NULL);\n\tif (!ep_fwnode)\n\t\treturn dev_err_probe(dev, -EPROBE_DEFER,\n\t\t\t\t     \"waiting for fwnode graph endpoint\\n\");\n\n\tret = v4l2_fwnode_endpoint_alloc_parse(ep_fwnode, &bus_cfg);\n\tfwnode_handle_put(ep_fwnode);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tgpio = devm_gpiod_get_optional(dev, \"powerdown\", GPIOD_OUT_HIGH);\n\tif (!gpio)\n\t\tgpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\n\tret = PTR_ERR_OR_ZERO(gpio);\n\tif (ret < 0) {\n\t\tdev_dbg(dev, \"error while getting reset gpio: %d\\n\", ret);\n\t\tgoto out_free_bus_cfg;\n\t}\n\n\tsensor->pwdn_gpio = gpio;\n\n\tsensor->xvclk = devm_clk_get_optional(dev, \"xvclk\");\n\tif (IS_ERR(sensor->xvclk)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(sensor->xvclk),\n\t\t\t\t    \"xvclk clock missing or invalid\\n\");\n\t\tgoto out_free_bus_cfg;\n\t}\n\n\t \n\tret = fwnode_property_read_u32(dev_fwnode(dev), \"clock-frequency\",\n\t\t\t\t       &rate);\n\tif (ret && !sensor->xvclk) {\n\t\tdev_err_probe(dev, ret, \"invalid clock config\\n\");\n\t\tgoto out_free_bus_cfg;\n\t}\n\n\tif (!ret && sensor->xvclk) {\n\t\tret = clk_set_rate(sensor->xvclk, rate);\n\t\tif (ret) {\n\t\t\tdev_err_probe(dev, ret, \"failed to set clock rate\\n\");\n\t\t\tgoto out_free_bus_cfg;\n\t\t}\n\t}\n\n\tsensor->xvclk_freq = rate ?: clk_get_rate(sensor->xvclk);\n\n\tfor (i = 0; i < ARRAY_SIZE(ov2680_xvclk_freqs); i++) {\n\t\tif (sensor->xvclk_freq == ov2680_xvclk_freqs[i])\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(ov2680_xvclk_freqs)) {\n\t\tret = dev_err_probe(dev, -EINVAL,\n\t\t\t\t    \"unsupported xvclk frequency %d Hz\\n\",\n\t\t\t\t    sensor->xvclk_freq);\n\t\tgoto out_free_bus_cfg;\n\t}\n\n\tsensor->pll_mult = ov2680_pll_multipliers[i];\n\n\tsensor->link_freq[0] = sensor->xvclk_freq / OV2680_PLL_PREDIV0 /\n\t\t\t       OV2680_PLL_PREDIV * sensor->pll_mult;\n\n\t \n\tsensor->pixel_rate = sensor->link_freq[0] * 2;\n\tdo_div(sensor->pixel_rate, 10);\n\n\t \n\tif (bus_cfg.bus.mipi_csi2.num_data_lanes != 1) {\n\t\tret = dev_err_probe(dev, -EINVAL,\n\t\t\t\t    \"only a 1-lane CSI2 config is supported\");\n\t\tgoto out_free_bus_cfg;\n\t}\n\n\tfor (i = 0; i < bus_cfg.nr_of_link_frequencies; i++)\n\t\tif (bus_cfg.link_frequencies[i] == sensor->link_freq[0])\n\t\t\tbreak;\n\n\tif (bus_cfg.nr_of_link_frequencies == 0 ||\n\t    bus_cfg.nr_of_link_frequencies == i) {\n\t\tret = dev_err_probe(dev, -EINVAL,\n\t\t\t\t    \"supported link freq %lld not found\\n\",\n\t\t\t\t    sensor->link_freq[0]);\n\t\tgoto out_free_bus_cfg;\n\t}\n\nout_free_bus_cfg:\n\tv4l2_fwnode_endpoint_free(&bus_cfg);\n\treturn ret;\n}\n\nstatic int ov2680_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct ov2680_dev *sensor;\n\tint ret;\n\n\tsensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);\n\tif (!sensor)\n\t\treturn -ENOMEM;\n\n\tsensor->dev = &client->dev;\n\n\tsensor->regmap = devm_cci_regmap_init_i2c(client, 16);\n\tif (IS_ERR(sensor->regmap))\n\t\treturn PTR_ERR(sensor->regmap);\n\n\tret = ov2680_parse_dt(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov2680_mode_init(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov2680_get_regulators(sensor);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get regulators\\n\");\n\t\treturn ret;\n\t}\n\n\tmutex_init(&sensor->lock);\n\n\t \n\tret = ov2680_power_on(sensor);\n\tif (ret < 0)\n\t\tgoto lock_destroy;\n\n\tret = ov2680_check_id(sensor);\n\tif (ret < 0)\n\t\tgoto err_powerdown;\n\n\tpm_runtime_set_active(&client->dev);\n\tpm_runtime_get_noresume(&client->dev);\n\tpm_runtime_enable(&client->dev);\n\n\tret = ov2680_v4l2_register(sensor);\n\tif (ret < 0)\n\t\tgoto err_pm_runtime;\n\n\tpm_runtime_set_autosuspend_delay(&client->dev, 1000);\n\tpm_runtime_use_autosuspend(&client->dev);\n\tpm_runtime_put_autosuspend(&client->dev);\n\n\treturn 0;\n\nerr_pm_runtime:\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_put_noidle(&client->dev);\nerr_powerdown:\n\tov2680_power_off(sensor);\nlock_destroy:\n\tdev_err(dev, \"ov2680 init fail: %d\\n\", ret);\n\tmutex_destroy(&sensor->lock);\n\n\treturn ret;\n}\n\nstatic void ov2680_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov2680_dev *sensor = to_ov2680_dev(sd);\n\n\tv4l2_async_unregister_subdev(&sensor->sd);\n\tmutex_destroy(&sensor->lock);\n\tmedia_entity_cleanup(&sensor->sd.entity);\n\tv4l2_ctrl_handler_free(&sensor->ctrls.handler);\n\n\t \n\tpm_runtime_disable(&client->dev);\n\tif (!pm_runtime_status_suspended(&client->dev))\n\t\tov2680_power_off(sensor);\n\tpm_runtime_set_suspended(&client->dev);\n}\n\nstatic int ov2680_suspend(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct ov2680_dev *sensor = to_ov2680_dev(sd);\n\n\tif (sensor->is_streaming)\n\t\tov2680_stream_disable(sensor);\n\n\treturn ov2680_power_off(sensor);\n}\n\nstatic int ov2680_resume(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct ov2680_dev *sensor = to_ov2680_dev(sd);\n\tint ret;\n\n\tret = ov2680_power_on(sensor);\n\tif (ret < 0)\n\t\tgoto stream_disable;\n\n\tif (sensor->is_streaming) {\n\t\tret = ov2680_stream_enable(sensor);\n\t\tif (ret < 0)\n\t\t\tgoto stream_disable;\n\t}\n\n\treturn 0;\n\nstream_disable:\n\tov2680_stream_disable(sensor);\n\tsensor->is_streaming = false;\n\n\treturn ret;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(ov2680_pm_ops, ov2680_suspend, ov2680_resume,\n\t\t\t\t NULL);\n\nstatic const struct of_device_id ov2680_dt_ids[] = {\n\t{ .compatible = \"ovti,ov2680\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ov2680_dt_ids);\n\nstatic const struct acpi_device_id ov2680_acpi_ids[] = {\n\t{ \"OVTI2680\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(acpi, ov2680_acpi_ids);\n\nstatic struct i2c_driver ov2680_i2c_driver = {\n\t.driver = {\n\t\t.name  = \"ov2680\",\n\t\t.pm = pm_sleep_ptr(&ov2680_pm_ops),\n\t\t.of_match_table\t= ov2680_dt_ids,\n\t\t.acpi_match_table = ov2680_acpi_ids,\n\t},\n\t.probe\t\t= ov2680_probe,\n\t.remove\t\t= ov2680_remove,\n};\nmodule_i2c_driver(ov2680_i2c_driver);\n\nMODULE_AUTHOR(\"Rui Miguel Silva <rui.silva@linaro.org>\");\nMODULE_DESCRIPTION(\"OV2680 CMOS Image Sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}