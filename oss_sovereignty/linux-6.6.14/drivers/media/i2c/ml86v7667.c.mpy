{
  "module_name": "ml86v7667.c",
  "hash_id": "347945e56701b09eab66ee8ea943909997a5cb2c05f5839ec480e930fb4b8681",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ml86v7667.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-subdev.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n\n#define DRV_NAME \"ml86v7667\"\n\n \n#define MRA_REG\t\t\t0x00  \n#define MRC_REG\t\t\t0x02  \n#define LUMC_REG\t\t0x0C  \n#define CLC_REG\t\t\t0x10  \n#define SSEPL_REG\t\t0x11  \n#define CHRCA_REG\t\t0x12  \n#define ACCC_REG\t\t0x14  \n#define ACCRC_REG\t\t0x15  \n#define HUE_REG\t\t\t0x16  \n#define ADC2_REG\t\t0x1F  \n#define PLLR1_REG\t\t0x20  \n#define STATUS_REG\t\t0x2C  \n\n \n#define MRA_OUTPUT_MODE_MASK\t(3 << 6)\n#define MRA_ITUR_BT601\t\t(1 << 6)\n#define MRA_ITUR_BT656\t\t(0 << 6)\n#define MRA_INPUT_MODE_MASK\t(7 << 3)\n#define MRA_PAL_BT601\t\t(4 << 3)\n#define MRA_NTSC_BT601\t\t(0 << 3)\n#define MRA_REGISTER_MODE\t(1 << 0)\n\n \n#define MRC_AUTOSELECT\t\t(1 << 7)\n\n \n#define LUMC_ONOFF_SHIFT\t7\n#define LUMC_ONOFF_MASK\t\t(1 << 7)\n\n \n#define CLC_CONTRAST_ONOFF\t(1 << 7)\n#define CLC_CONTRAST_MASK\t0x0F\n\n \n#define SSEPL_LUMINANCE_ONOFF\t(1 << 7)\n#define SSEPL_LUMINANCE_MASK\t0x7F\n\n \n#define CHRCA_MODE_SHIFT\t6\n#define CHRCA_MODE_MASK\t\t(1 << 6)\n\n \n#define ACCC_CHROMA_CR_SHIFT\t3\n#define ACCC_CHROMA_CR_MASK\t(7 << 3)\n#define ACCC_CHROMA_CB_SHIFT\t0\n#define ACCC_CHROMA_CB_MASK\t(7 << 0)\n\n \n#define ACCRC_CHROMA_MASK\t0xfc\n#define ACCRC_CHROMA_SHIFT\t2\n\n \n#define ADC2_CLAMP_VOLTAGE_MASK\t(7 << 1)\n#define ADC2_CLAMP_VOLTAGE(n)\t((n & 7) << 1)\n\n \n#define PLLR1_FIXED_CLOCK\t(1 << 7)\n\n \n#define STATUS_HLOCK_DETECT\t(1 << 3)\n#define STATUS_NTSCPAL\t\t(1 << 2)\n\nstruct ml86v7667_priv {\n\tstruct v4l2_subdev\t\tsd;\n\tstruct v4l2_ctrl_handler\thdl;\n\tv4l2_std_id\t\t\tstd;\n};\n\nstatic inline struct ml86v7667_priv *to_ml86v7667(struct v4l2_subdev *subdev)\n{\n\treturn container_of(subdev, struct ml86v7667_priv, sd);\n}\n\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct ml86v7667_priv, hdl)->sd;\n}\n\nstatic int ml86v7667_mask_set(struct i2c_client *client, const u8 reg,\n\t\t\t      const u8 mask, const u8 data)\n{\n\tint val = i2c_smbus_read_byte_data(client, reg);\n\tif (val < 0)\n\t\treturn val;\n\n\tval = (val & ~mask) | (data & mask);\n\treturn i2c_smbus_write_byte_data(client, reg, val);\n}\n\nstatic int ml86v7667_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret = -EINVAL;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tret = ml86v7667_mask_set(client, SSEPL_REG,\n\t\t\t\t\t SSEPL_LUMINANCE_MASK, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tret = ml86v7667_mask_set(client, CLC_REG,\n\t\t\t\t\t CLC_CONTRAST_MASK, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CHROMA_GAIN:\n\t\tret = ml86v7667_mask_set(client, ACCRC_REG, ACCRC_CHROMA_MASK,\n\t\t\t\t\t ctrl->val << ACCRC_CHROMA_SHIFT);\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\tret = ml86v7667_mask_set(client, HUE_REG, ~0, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_RED_BALANCE:\n\t\tret = ml86v7667_mask_set(client, ACCC_REG,\n\t\t\t\t\t ACCC_CHROMA_CR_MASK,\n\t\t\t\t\t ctrl->val << ACCC_CHROMA_CR_SHIFT);\n\t\tbreak;\n\tcase V4L2_CID_BLUE_BALANCE:\n\t\tret = ml86v7667_mask_set(client, ACCC_REG,\n\t\t\t\t\t ACCC_CHROMA_CB_MASK,\n\t\t\t\t\t ctrl->val << ACCC_CHROMA_CB_SHIFT);\n\t\tbreak;\n\tcase V4L2_CID_SHARPNESS:\n\t\tret = ml86v7667_mask_set(client, LUMC_REG,\n\t\t\t\t\t LUMC_ONOFF_MASK,\n\t\t\t\t\t ctrl->val << LUMC_ONOFF_SHIFT);\n\t\tbreak;\n\tcase V4L2_CID_COLOR_KILLER:\n\t\tret = ml86v7667_mask_set(client, CHRCA_REG,\n\t\t\t\t\t CHRCA_MODE_MASK,\n\t\t\t\t\t ctrl->val << CHRCA_MODE_SHIFT);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int ml86v7667_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint status;\n\n\tstatus = i2c_smbus_read_byte_data(client, STATUS_REG);\n\tif (status < 0)\n\t\treturn status;\n\n\tif (status & STATUS_HLOCK_DETECT)\n\t\t*std &= status & STATUS_NTSCPAL ? V4L2_STD_625_50 : V4L2_STD_525_60;\n\telse\n\t\t*std = V4L2_STD_UNKNOWN;\n\n\treturn 0;\n}\n\nstatic int ml86v7667_g_input_status(struct v4l2_subdev *sd, u32 *status)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint status_reg;\n\n\tstatus_reg = i2c_smbus_read_byte_data(client, STATUS_REG);\n\tif (status_reg < 0)\n\t\treturn status_reg;\n\n\t*status = status_reg & STATUS_HLOCK_DETECT ? 0 : V4L2_IN_ST_NO_SIGNAL;\n\n\treturn 0;\n}\n\nstatic int ml86v7667_enum_mbus_code(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index > 0)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_YUYV8_2X8;\n\n\treturn 0;\n}\n\nstatic int ml86v7667_fill_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct ml86v7667_priv *priv = to_ml86v7667(sd);\n\tstruct v4l2_mbus_framefmt *fmt = &format->format;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tfmt->code = MEDIA_BUS_FMT_YUYV8_2X8;\n\tfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\t \n\tfmt->field = V4L2_FIELD_INTERLACED_TB;\n\tfmt->width = 720;\n\tfmt->height = priv->std & V4L2_STD_525_60 ? 480 : 576;\n\n\treturn 0;\n}\n\nstatic int ml86v7667_get_mbus_config(struct v4l2_subdev *sd,\n\t\t\t\t     unsigned int pad,\n\t\t\t\t     struct v4l2_mbus_config *cfg)\n{\n\tcfg->type = V4L2_MBUS_BT656;\n\tcfg->bus.parallel.flags = V4L2_MBUS_MASTER |\n\t\t\t\t  V4L2_MBUS_PCLK_SAMPLE_RISING |\n\t\t\t\t  V4L2_MBUS_DATA_ACTIVE_HIGH;\n\n\treturn 0;\n}\n\nstatic int ml86v7667_g_std(struct v4l2_subdev *sd, v4l2_std_id *std)\n{\n\tstruct ml86v7667_priv *priv = to_ml86v7667(sd);\n\n\t*std = priv->std;\n\n\treturn 0;\n}\n\nstatic int ml86v7667_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct ml86v7667_priv *priv = to_ml86v7667(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(&priv->sd);\n\tint ret;\n\tu8 mode;\n\n\t \n\tmode = std & V4L2_STD_525_60 ? MRA_NTSC_BT601 : MRA_PAL_BT601;\n\tret = ml86v7667_mask_set(client, MRA_REG, MRA_INPUT_MODE_MASK, mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpriv->std = std;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int ml86v7667_g_register(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_dbg_register *reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, (u8)reg->reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treg->val = ret;\n\treg->size = sizeof(u8);\n\n\treturn 0;\n}\n\nstatic int ml86v7667_s_register(struct v4l2_subdev *sd,\n\t\t\t\tconst struct v4l2_dbg_register *reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn i2c_smbus_write_byte_data(client, (u8)reg->reg, (u8)reg->val);\n}\n#endif\n\nstatic const struct v4l2_ctrl_ops ml86v7667_ctrl_ops = {\n\t.s_ctrl = ml86v7667_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_video_ops ml86v7667_subdev_video_ops = {\n\t.g_std = ml86v7667_g_std,\n\t.s_std = ml86v7667_s_std,\n\t.querystd = ml86v7667_querystd,\n\t.g_input_status = ml86v7667_g_input_status,\n};\n\nstatic const struct v4l2_subdev_pad_ops ml86v7667_subdev_pad_ops = {\n\t.enum_mbus_code = ml86v7667_enum_mbus_code,\n\t.get_fmt = ml86v7667_fill_fmt,\n\t.set_fmt = ml86v7667_fill_fmt,\n\t.get_mbus_config = ml86v7667_get_mbus_config,\n};\n\nstatic const struct v4l2_subdev_core_ops ml86v7667_subdev_core_ops = {\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = ml86v7667_g_register,\n\t.s_register = ml86v7667_s_register,\n#endif\n};\n\nstatic const struct v4l2_subdev_ops ml86v7667_subdev_ops = {\n\t.core = &ml86v7667_subdev_core_ops,\n\t.video = &ml86v7667_subdev_video_ops,\n\t.pad = &ml86v7667_subdev_pad_ops,\n};\n\nstatic int ml86v7667_init(struct ml86v7667_priv *priv)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&priv->sd);\n\tint val;\n\tint ret;\n\n\t \n\tret = ml86v7667_mask_set(client, MRA_REG,\n\t\t\t\t MRA_OUTPUT_MODE_MASK | MRA_REGISTER_MODE,\n\t\t\t\t MRA_ITUR_BT656 | MRA_REGISTER_MODE);\n\n\t \n\tret |= ml86v7667_mask_set(client, PLLR1_REG, PLLR1_FIXED_CLOCK,\n\t\t\t\t  PLLR1_FIXED_CLOCK);\n\n\t \n\tret |= ml86v7667_mask_set(client, ADC2_REG, ADC2_CLAMP_VOLTAGE_MASK,\n\t\t\t\t  ADC2_CLAMP_VOLTAGE(7));\n\n\t \n\tret |= ml86v7667_mask_set(client, SSEPL_REG, SSEPL_LUMINANCE_ONOFF,\n\t\t\t\t  SSEPL_LUMINANCE_ONOFF);\n\n\t \n\tret |= ml86v7667_mask_set(client, CLC_REG, CLC_CONTRAST_ONOFF, 0);\n\n\t \n\tval = i2c_smbus_read_byte_data(client, STATUS_REG);\n\tif (val < 0)\n\t\treturn val;\n\n\tpriv->std = val & STATUS_NTSCPAL ? V4L2_STD_625_50 : V4L2_STD_525_60;\n\tret |= ml86v7667_mask_set(client, MRC_REG, MRC_AUTOSELECT, 0);\n\n\tval = priv->std & V4L2_STD_525_60 ? MRA_NTSC_BT601 : MRA_PAL_BT601;\n\tret |= ml86v7667_mask_set(client, MRA_REG, MRA_INPUT_MODE_MASK, val);\n\n\treturn ret;\n}\n\nstatic int ml86v7667_probe(struct i2c_client *client)\n{\n\tstruct ml86v7667_priv *priv;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tpriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tv4l2_i2c_subdev_init(&priv->sd, client, &ml86v7667_subdev_ops);\n\n\tv4l2_ctrl_handler_init(&priv->hdl, 8);\n\tv4l2_ctrl_new_std(&priv->hdl, &ml86v7667_ctrl_ops,\n\t\t\t  V4L2_CID_BRIGHTNESS, -64, 63, 1, 0);\n\tv4l2_ctrl_new_std(&priv->hdl, &ml86v7667_ctrl_ops,\n\t\t\t  V4L2_CID_CONTRAST, -8, 7, 1, 0);\n\tv4l2_ctrl_new_std(&priv->hdl, &ml86v7667_ctrl_ops,\n\t\t\t  V4L2_CID_CHROMA_GAIN, -32, 31, 1, 0);\n\tv4l2_ctrl_new_std(&priv->hdl, &ml86v7667_ctrl_ops,\n\t\t\t  V4L2_CID_HUE, -128, 127, 1, 0);\n\tv4l2_ctrl_new_std(&priv->hdl, &ml86v7667_ctrl_ops,\n\t\t\t  V4L2_CID_RED_BALANCE, -4, 3, 1, 0);\n\tv4l2_ctrl_new_std(&priv->hdl, &ml86v7667_ctrl_ops,\n\t\t\t  V4L2_CID_BLUE_BALANCE, -4, 3, 1, 0);\n\tv4l2_ctrl_new_std(&priv->hdl, &ml86v7667_ctrl_ops,\n\t\t\t  V4L2_CID_SHARPNESS, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(&priv->hdl, &ml86v7667_ctrl_ops,\n\t\t\t  V4L2_CID_COLOR_KILLER, 0, 1, 1, 0);\n\tpriv->sd.ctrl_handler = &priv->hdl;\n\n\tret = priv->hdl.error;\n\tif (ret)\n\t\tgoto cleanup;\n\n\tv4l2_ctrl_handler_setup(&priv->hdl);\n\n\tret = ml86v7667_init(priv);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tv4l_info(client, \"chip found @ 0x%02x (%s)\\n\",\n\t\t client->addr, client->adapter->name);\n\treturn 0;\n\ncleanup:\n\tv4l2_ctrl_handler_free(&priv->hdl);\n\tv4l2_device_unregister_subdev(&priv->sd);\n\tv4l_err(client, \"failed to probe @ 0x%02x (%s)\\n\",\n\t\tclient->addr, client->adapter->name);\n\treturn ret;\n}\n\nstatic void ml86v7667_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ml86v7667_priv *priv = to_ml86v7667(sd);\n\n\tv4l2_ctrl_handler_free(&priv->hdl);\n\tv4l2_device_unregister_subdev(&priv->sd);\n}\n\nstatic const struct i2c_device_id ml86v7667_id[] = {\n\t{DRV_NAME, 0},\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, ml86v7667_id);\n\nstatic struct i2c_driver ml86v7667_i2c_driver = {\n\t.driver = {\n\t\t.name\t= DRV_NAME,\n\t},\n\t.probe\t\t= ml86v7667_probe,\n\t.remove\t\t= ml86v7667_remove,\n\t.id_table\t= ml86v7667_id,\n};\n\nmodule_i2c_driver(ml86v7667_i2c_driver);\n\nMODULE_DESCRIPTION(\"OKI Semiconductor ML86V7667 video decoder driver\");\nMODULE_AUTHOR(\"Vladimir Barinov\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}