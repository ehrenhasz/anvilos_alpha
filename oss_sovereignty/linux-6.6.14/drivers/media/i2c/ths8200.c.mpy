{
  "module_name": "ths8200.c",
  "hash_id": "e5f23b4dd1467e194ea0631aba5a96fb3fe2f078311af8dffd15ad58df09ee58",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ths8200.c",
  "human_readable_source": " \n\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/v4l2-dv-timings.h>\n\n#include <media/v4l2-dv-timings.h>\n#include <media/v4l2-async.h>\n#include <media/v4l2-device.h>\n\n#include \"ths8200_regs.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"debug level (0-2)\");\n\nMODULE_DESCRIPTION(\"Texas Instruments THS8200 video encoder driver\");\nMODULE_AUTHOR(\"Mats Randgaard <mats.randgaard@cisco.com>\");\nMODULE_AUTHOR(\"Martin Bugge <martin.bugge@cisco.com>\");\nMODULE_LICENSE(\"GPL v2\");\n\nstruct ths8200_state {\n\tstruct v4l2_subdev sd;\n\tuint8_t chip_version;\n\t \n\tbool power_on;\n\tstruct v4l2_dv_timings dv_timings;\n};\n\nstatic const struct v4l2_dv_timings_cap ths8200_timings_cap = {\n\t.type = V4L2_DV_BT_656_1120,\n\t \n\t.reserved = { 0 },\n\tV4L2_INIT_BT_TIMINGS(640, 1920, 350, 1080, 25000000, 148500000,\n\t\tV4L2_DV_BT_STD_CEA861, V4L2_DV_BT_CAP_PROGRESSIVE)\n};\n\nstatic inline struct ths8200_state *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct ths8200_state, sd);\n}\n\nstatic inline unsigned htotal(const struct v4l2_bt_timings *t)\n{\n\treturn V4L2_DV_BT_FRAME_WIDTH(t);\n}\n\nstatic inline unsigned vtotal(const struct v4l2_bt_timings *t)\n{\n\treturn V4L2_DV_BT_FRAME_HEIGHT(t);\n}\n\nstatic int ths8200_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\nstatic int ths8200_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = i2c_smbus_write_byte_data(client, reg, val);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t}\n\tv4l2_err(sd, \"I2C Write Problem\\n\");\n\treturn ret;\n}\n\n \nstatic inline void\nths8200_write_and_or(struct v4l2_subdev *sd, u8 reg,\n\t\t     uint8_t clr_mask, uint8_t val_mask)\n{\n\tths8200_write(sd, reg, (ths8200_read(sd, reg) & clr_mask) | val_mask);\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\nstatic int ths8200_g_register(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_dbg_register *reg)\n{\n\treg->val = ths8200_read(sd, reg->reg & 0xff);\n\treg->size = 1;\n\n\treturn 0;\n}\n\nstatic int ths8200_s_register(struct v4l2_subdev *sd,\n\t\t\t      const struct v4l2_dbg_register *reg)\n{\n\tths8200_write(sd, reg->reg & 0xff, reg->val & 0xff);\n\n\treturn 0;\n}\n#endif\n\nstatic int ths8200_log_status(struct v4l2_subdev *sd)\n{\n\tstruct ths8200_state *state = to_state(sd);\n\tuint8_t reg_03 = ths8200_read(sd, THS8200_CHIP_CTL);\n\n\tv4l2_info(sd, \"----- Chip status -----\\n\");\n\tv4l2_info(sd, \"version: %u\\n\", state->chip_version);\n\tv4l2_info(sd, \"power: %s\\n\", (reg_03 & 0x0c) ? \"off\" : \"on\");\n\tv4l2_info(sd, \"reset: %s\\n\", (reg_03 & 0x01) ? \"off\" : \"on\");\n\tv4l2_info(sd, \"test pattern: %s\\n\",\n\t\t  (reg_03 & 0x20) ? \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"format: %ux%u\\n\",\n\t\t  ths8200_read(sd, THS8200_DTG2_PIXEL_CNT_MSB) * 256 +\n\t\t  ths8200_read(sd, THS8200_DTG2_PIXEL_CNT_LSB),\n\t\t  (ths8200_read(sd, THS8200_DTG2_LINE_CNT_MSB) & 0x07) * 256 +\n\t\t  ths8200_read(sd, THS8200_DTG2_LINE_CNT_LSB));\n\tv4l2_print_dv_timings(sd->name, \"Configured format:\",\n\t\t\t      &state->dv_timings, true);\n\treturn 0;\n}\n\n \nstatic int ths8200_s_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct ths8200_state *state = to_state(sd);\n\n\tv4l2_dbg(1, debug, sd, \"%s: power %s\\n\", __func__, on ? \"on\" : \"off\");\n\n\tstate->power_on = on;\n\n\t \n\tths8200_write_and_or(sd, THS8200_CHIP_CTL, 0xf2, (on ? 0x00 : 0x0c));\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops ths8200_core_ops = {\n\t.log_status = ths8200_log_status,\n\t.s_power = ths8200_s_power,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = ths8200_g_register,\n\t.s_register = ths8200_s_register,\n#endif\n};\n\n \n\nstatic int ths8200_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct ths8200_state *state = to_state(sd);\n\n\tif (enable && !state->power_on)\n\t\tths8200_s_power(sd, true);\n\n\tths8200_write_and_or(sd, THS8200_CHIP_CTL, 0xfe,\n\t\t\t     (enable ? 0x01 : 0x00));\n\n\tv4l2_dbg(1, debug, sd, \"%s: %sable\\n\",\n\t\t __func__, (enable ? \"en\" : \"dis\"));\n\n\treturn 0;\n}\n\nstatic void ths8200_core_init(struct v4l2_subdev *sd)\n{\n\t \n\tths8200_write_and_or(sd, THS8200_CHIP_CTL, 0x3f, 0xc0);\n\n\t \n\t \n\tths8200_write(sd, THS8200_DATA_CNTL, 0x70);\n\n\t \n\tths8200_write(sd, THS8200_DTG1_MODE, 0x87);\n\n\t \n\n\t \n\tths8200_write(sd, THS8200_DTG1_Y_SYNC_MSB, 0x00);\n\tths8200_write(sd, THS8200_DTG1_CBCR_SYNC_MSB, 0x00);\n}\n\nstatic void ths8200_setup(struct v4l2_subdev *sd, struct v4l2_bt_timings *bt)\n{\n\tuint8_t polarity = 0;\n\tuint16_t line_start_active_video = (bt->vsync + bt->vbackporch);\n\tuint16_t line_start_front_porch  = (vtotal(bt) - bt->vfrontporch);\n\n\t \n\t \n\tths8200_s_stream(sd, false);\n\n\t \n\tths8200_write(sd, THS8200_DTG1_SPEC_A, bt->hsync);\n\tths8200_write(sd, THS8200_DTG1_SPEC_B, bt->hfrontporch);\n\n\t \n\tif (!bt->interlaced)\n\t\tths8200_write(sd, THS8200_DTG1_SPEC_C, 0x00);\n\n\t \n\tths8200_write(sd, THS8200_DTG1_SPEC_D_LSB,\n\t\t      (bt->hbackporch + bt->hsync) & 0xff);\n\t \n\tths8200_write(sd, THS8200_DTG1_SPEC_E_LSB, 0x00);\n\t \n\tths8200_write(sd, THS8200_DTG1_SPEC_DEH_MSB,\n\t\t      ((bt->hbackporch + bt->hsync) & 0x100) >> 1);\n\n\t \n\tths8200_write(sd, THS8200_DTG1_SPEC_K_LSB, (bt->hfrontporch) & 0xff);\n\tths8200_write(sd, THS8200_DTG1_SPEC_K_MSB,\n\t\t      ((bt->hfrontporch) & 0x700) >> 8);\n\n\t \n\tths8200_write(sd, THS8200_DTG1_SPEC_G_LSB, (htotal(bt)/2) & 0xff);\n\tths8200_write(sd, THS8200_DTG1_SPEC_G_MSB,\n\t\t      ((htotal(bt)/2) >> 8) & 0x0f);\n\n\t \n\tths8200_write(sd, THS8200_DTG1_TOT_PIXELS_MSB, htotal(bt) >> 8);\n\tths8200_write(sd, THS8200_DTG1_TOT_PIXELS_LSB, htotal(bt) & 0xff);\n\n\t \n\t \n\tths8200_write(sd, THS8200_DTG1_FRAME_FIELD_SZ_MSB,\n\t\t      ((vtotal(bt) >> 4) & 0xf0) + 0x7);\n\tths8200_write(sd, THS8200_DTG1_FRAME_SZ_LSB, vtotal(bt) & 0xff);\n\n\t \n\tif (!bt->interlaced)\n\t\tths8200_write(sd, THS8200_DTG1_FIELD_SZ_LSB, 0xff);\n\n\t \n\t \n\tths8200_write_and_or(sd, THS8200_DTG2_BP1_2_MSB, 0x88,\n\t\t\t     ((line_start_active_video >> 4) & 0x70) +\n\t\t\t     ((line_start_front_porch >> 8) & 0x07));\n\tths8200_write(sd, THS8200_DTG2_BP3_4_MSB, ((vtotal(bt)) >> 4) & 0x70);\n\tths8200_write(sd, THS8200_DTG2_BP1_LSB, line_start_active_video & 0xff);\n\tths8200_write(sd, THS8200_DTG2_BP2_LSB, line_start_front_porch & 0xff);\n\tths8200_write(sd, THS8200_DTG2_BP3_LSB, (vtotal(bt)) & 0xff);\n\n\t \n\tths8200_write(sd, THS8200_DTG2_LINETYPE1, 0x90);\n\tths8200_write(sd, THS8200_DTG2_LINETYPE2, 0x90);\n\n\t \n\tths8200_write(sd, THS8200_DTG2_HLENGTH_LSB, bt->hsync & 0xff);\n\tths8200_write_and_or(sd, THS8200_DTG2_HLENGTH_LSB_HDLY_MSB, 0x3f,\n\t\t\t     (bt->hsync >> 2) & 0xc0);\n\n\t \n\tths8200_write_and_or(sd, THS8200_DTG2_HLENGTH_LSB_HDLY_MSB, 0xe0,\n\t\t\t     (htotal(bt) >> 8) & 0x1f);\n\tths8200_write(sd, THS8200_DTG2_HLENGTH_HDLY_LSB, htotal(bt));\n\n\t \n\tths8200_write(sd, THS8200_DTG2_VLENGTH1_LSB, (bt->vsync + 1) & 0xff);\n\tths8200_write_and_or(sd, THS8200_DTG2_VLENGTH1_MSB_VDLY1_MSB, 0x3f,\n\t\t\t     ((bt->vsync + 1) >> 2) & 0xc0);\n\n\t \n\tths8200_write_and_or(sd, THS8200_DTG2_VLENGTH1_MSB_VDLY1_MSB, 0xf8,\n\t\t\t     ((vtotal(bt) + 1) >> 8) & 0x7);\n\tths8200_write(sd, THS8200_DTG2_VDLY1_LSB, vtotal(bt) + 1);\n\n\t \n\tths8200_write(sd, THS8200_DTG2_VLENGTH2_LSB, 0x00);\n\tths8200_write(sd, THS8200_DTG2_VLENGTH2_MSB_VDLY2_MSB, 0x07);\n\tths8200_write(sd, THS8200_DTG2_VDLY2_LSB, 0xff);\n\n\t \n\t \n\tths8200_write(sd, THS8200_DTG2_HS_IN_DLY_MSB, 0);\n\tths8200_write(sd, THS8200_DTG2_HS_IN_DLY_LSB, 0);\n\tths8200_write(sd, THS8200_DTG2_VS_IN_DLY_MSB, 0);\n\tths8200_write(sd, THS8200_DTG2_VS_IN_DLY_LSB, 0);\n\n\t \n\tif (bt->polarities & V4L2_DV_HSYNC_POS_POL) {\n\t\tpolarity |= 0x01;  \n\t\tpolarity |= 0x08;  \n\t}\n\tif (bt->polarities & V4L2_DV_VSYNC_POS_POL) {\n\t\tpolarity |= 0x02;  \n\t\tpolarity |= 0x10;  \n\t}\n\n\t \n\t \n\tths8200_write(sd, THS8200_DTG2_CNTL, 0x44 | polarity);\n\n\t \n\tths8200_s_stream(sd, true);\n\n\tv4l2_dbg(1, debug, sd, \"%s: frame %dx%d, polarity %d\\n\"\n\t\t \"horizontal: front porch %d, back porch %d, sync %d\\n\"\n\t\t \"vertical: sync %d\\n\", __func__, htotal(bt), vtotal(bt),\n\t\t polarity, bt->hfrontporch, bt->hbackporch,\n\t\t bt->hsync, bt->vsync);\n}\n\nstatic int ths8200_s_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_dv_timings *timings)\n{\n\tstruct ths8200_state *state = to_state(sd);\n\n\tv4l2_dbg(1, debug, sd, \"%s:\\n\", __func__);\n\n\tif (!v4l2_valid_dv_timings(timings, &ths8200_timings_cap,\n\t\t\t\tNULL, NULL))\n\t\treturn -EINVAL;\n\n\tif (!v4l2_find_dv_timings_cap(timings, &ths8200_timings_cap, 10,\n\t\t\t\tNULL, NULL)) {\n\t\tv4l2_dbg(1, debug, sd, \"Unsupported format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttimings->bt.flags &= ~V4L2_DV_FL_REDUCED_FPS;\n\n\t \n\tstate->dv_timings = *timings;\n\n\tths8200_setup(sd, &timings->bt);\n\n\treturn 0;\n}\n\nstatic int ths8200_g_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_dv_timings *timings)\n{\n\tstruct ths8200_state *state = to_state(sd);\n\n\tv4l2_dbg(1, debug, sd, \"%s:\\n\", __func__);\n\n\t*timings = state->dv_timings;\n\n\treturn 0;\n}\n\nstatic int ths8200_enum_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_enum_dv_timings *timings)\n{\n\tif (timings->pad != 0)\n\t\treturn -EINVAL;\n\n\treturn v4l2_enum_dv_timings_cap(timings, &ths8200_timings_cap,\n\t\t\tNULL, NULL);\n}\n\nstatic int ths8200_dv_timings_cap(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_dv_timings_cap *cap)\n{\n\tif (cap->pad != 0)\n\t\treturn -EINVAL;\n\n\t*cap = ths8200_timings_cap;\n\treturn 0;\n}\n\n \nstatic const struct v4l2_subdev_video_ops ths8200_video_ops = {\n\t.s_stream = ths8200_s_stream,\n\t.s_dv_timings = ths8200_s_dv_timings,\n\t.g_dv_timings = ths8200_g_dv_timings,\n};\n\nstatic const struct v4l2_subdev_pad_ops ths8200_pad_ops = {\n\t.enum_dv_timings = ths8200_enum_dv_timings,\n\t.dv_timings_cap = ths8200_dv_timings_cap,\n};\n\n \nstatic const struct v4l2_subdev_ops ths8200_ops = {\n\t.core  = &ths8200_core_ops,\n\t.video = &ths8200_video_ops,\n\t.pad = &ths8200_pad_ops,\n};\n\nstatic int ths8200_probe(struct i2c_client *client)\n{\n\tstruct ths8200_state *state;\n\tstruct v4l2_subdev *sd;\n\tint error;\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tstate = devm_kzalloc(&client->dev, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tsd = &state->sd;\n\tv4l2_i2c_subdev_init(sd, client, &ths8200_ops);\n\n\tstate->chip_version = ths8200_read(sd, THS8200_VERSION);\n\tv4l2_dbg(1, debug, sd, \"chip version 0x%x\\n\", state->chip_version);\n\n\tths8200_core_init(sd);\n\n\terror = v4l2_async_register_subdev(&state->sd);\n\tif (error)\n\t\treturn error;\n\n\tv4l2_info(sd, \"%s found @ 0x%x (%s)\\n\", client->name,\n\t\t  client->addr << 1, client->adapter->name);\n\n\treturn 0;\n}\n\nstatic void ths8200_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ths8200_state *decoder = to_state(sd);\n\n\tv4l2_dbg(1, debug, sd, \"%s removed @ 0x%x (%s)\\n\", client->name,\n\t\t client->addr << 1, client->adapter->name);\n\n\tths8200_s_power(sd, false);\n\tv4l2_async_unregister_subdev(&decoder->sd);\n}\n\nstatic const struct i2c_device_id ths8200_id[] = {\n\t{ \"ths8200\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, ths8200_id);\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id ths8200_of_match[] = {\n\t{ .compatible = \"ti,ths8200\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ths8200_of_match);\n#endif\n\nstatic struct i2c_driver ths8200_driver = {\n\t.driver = {\n\t\t.name = \"ths8200\",\n\t\t.of_match_table = of_match_ptr(ths8200_of_match),\n\t},\n\t.probe = ths8200_probe,\n\t.remove = ths8200_remove,\n\t.id_table = ths8200_id,\n};\n\nmodule_i2c_driver(ths8200_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}