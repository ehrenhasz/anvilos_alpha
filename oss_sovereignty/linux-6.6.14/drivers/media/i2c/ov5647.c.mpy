{
  "module_name": "ov5647.c",
  "hash_id": "940c7bcc136605a0da95311336f90fac177d4e942987604a2aad5cae7b8fc1a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ov5647.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-image-sizes.h>\n#include <media/v4l2-mediabus.h>\n\n \n#define PWDN_ACTIVE_DELAY_MS\t20\n\n#define MIPI_CTRL00_CLOCK_LANE_GATE\t\tBIT(5)\n#define MIPI_CTRL00_LINE_SYNC_ENABLE\t\tBIT(4)\n#define MIPI_CTRL00_BUS_IDLE\t\t\tBIT(2)\n#define MIPI_CTRL00_CLOCK_LANE_DISABLE\t\tBIT(0)\n\n#define OV5647_SW_STANDBY\t\t0x0100\n#define OV5647_SW_RESET\t\t\t0x0103\n#define OV5647_REG_CHIPID_H\t\t0x300a\n#define OV5647_REG_CHIPID_L\t\t0x300b\n#define OV5640_REG_PAD_OUT\t\t0x300d\n#define OV5647_REG_EXP_HI\t\t0x3500\n#define OV5647_REG_EXP_MID\t\t0x3501\n#define OV5647_REG_EXP_LO\t\t0x3502\n#define OV5647_REG_AEC_AGC\t\t0x3503\n#define OV5647_REG_GAIN_HI\t\t0x350a\n#define OV5647_REG_GAIN_LO\t\t0x350b\n#define OV5647_REG_VTS_HI\t\t0x380e\n#define OV5647_REG_VTS_LO\t\t0x380f\n#define OV5647_REG_FRAME_OFF_NUMBER\t0x4202\n#define OV5647_REG_MIPI_CTRL00\t\t0x4800\n#define OV5647_REG_MIPI_CTRL14\t\t0x4814\n#define OV5647_REG_AWB\t\t\t0x5001\n#define OV5647_REG_ISPCTRL3D\t\t0x503d\n\n#define REG_TERM 0xfffe\n#define VAL_TERM 0xfe\n#define REG_DLY  0xffff\n\n \n#define OV5647_NATIVE_WIDTH\t\t2624U\n#define OV5647_NATIVE_HEIGHT\t\t1956U\n\n#define OV5647_PIXEL_ARRAY_LEFT\t\t16U\n#define OV5647_PIXEL_ARRAY_TOP\t\t16U\n#define OV5647_PIXEL_ARRAY_WIDTH\t2592U\n#define OV5647_PIXEL_ARRAY_HEIGHT\t1944U\n\n#define OV5647_VBLANK_MIN\t\t4\n#define OV5647_VTS_MAX\t\t\t32767\n\n#define OV5647_EXPOSURE_MIN\t\t4\n#define OV5647_EXPOSURE_STEP\t\t1\n#define OV5647_EXPOSURE_DEFAULT\t\t1000\n#define OV5647_EXPOSURE_MAX\t\t65535\n\nstruct regval_list {\n\tu16 addr;\n\tu8 data;\n};\n\nstruct ov5647_mode {\n\tstruct v4l2_mbus_framefmt\tformat;\n\tstruct v4l2_rect\t\tcrop;\n\tu64\t\t\t\tpixel_rate;\n\tint\t\t\t\thts;\n\tint\t\t\t\tvts;\n\tconst struct regval_list\t*reg_list;\n\tunsigned int\t\t\tnum_regs;\n};\n\nstruct ov5647 {\n\tstruct v4l2_subdev\t\tsd;\n\tstruct media_pad\t\tpad;\n\tstruct mutex\t\t\tlock;\n\tstruct clk\t\t\t*xclk;\n\tstruct gpio_desc\t\t*pwdn;\n\tbool\t\t\t\tclock_ncont;\n\tstruct v4l2_ctrl_handler\tctrls;\n\tconst struct ov5647_mode\t*mode;\n\tstruct v4l2_ctrl\t\t*pixel_rate;\n\tstruct v4l2_ctrl\t\t*hblank;\n\tstruct v4l2_ctrl\t\t*vblank;\n\tstruct v4l2_ctrl\t\t*exposure;\n\tbool\t\t\t\tstreaming;\n};\n\nstatic inline struct ov5647 *to_sensor(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct ov5647, sd);\n}\n\nstatic const char * const ov5647_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Color Bars\",\n\t\"Color Squares\",\n\t\"Random Data\",\n};\n\nstatic const u8 ov5647_test_pattern_val[] = {\n\t0x00,\t \n\t0x80,\t \n\t0x82,\t \n\t0x81,\t \n};\n\nstatic const struct regval_list sensor_oe_disable_regs[] = {\n\t{0x3000, 0x00},\n\t{0x3001, 0x00},\n\t{0x3002, 0x00},\n};\n\nstatic const struct regval_list sensor_oe_enable_regs[] = {\n\t{0x3000, 0x0f},\n\t{0x3001, 0xff},\n\t{0x3002, 0xe4},\n};\n\nstatic struct regval_list ov5647_2592x1944_10bpp[] = {\n\t{0x0100, 0x00},\n\t{0x0103, 0x01},\n\t{0x3034, 0x1a},\n\t{0x3035, 0x21},\n\t{0x3036, 0x69},\n\t{0x303c, 0x11},\n\t{0x3106, 0xf5},\n\t{0x3821, 0x06},\n\t{0x3820, 0x00},\n\t{0x3827, 0xec},\n\t{0x370c, 0x03},\n\t{0x3612, 0x5b},\n\t{0x3618, 0x04},\n\t{0x5000, 0x06},\n\t{0x5002, 0x41},\n\t{0x5003, 0x08},\n\t{0x5a00, 0x08},\n\t{0x3000, 0x00},\n\t{0x3001, 0x00},\n\t{0x3002, 0x00},\n\t{0x3016, 0x08},\n\t{0x3017, 0xe0},\n\t{0x3018, 0x44},\n\t{0x301c, 0xf8},\n\t{0x301d, 0xf0},\n\t{0x3a18, 0x00},\n\t{0x3a19, 0xf8},\n\t{0x3c01, 0x80},\n\t{0x3b07, 0x0c},\n\t{0x380c, 0x0b},\n\t{0x380d, 0x1c},\n\t{0x3814, 0x11},\n\t{0x3815, 0x11},\n\t{0x3708, 0x64},\n\t{0x3709, 0x12},\n\t{0x3808, 0x0a},\n\t{0x3809, 0x20},\n\t{0x380a, 0x07},\n\t{0x380b, 0x98},\n\t{0x3800, 0x00},\n\t{0x3801, 0x00},\n\t{0x3802, 0x00},\n\t{0x3803, 0x00},\n\t{0x3804, 0x0a},\n\t{0x3805, 0x3f},\n\t{0x3806, 0x07},\n\t{0x3807, 0xa3},\n\t{0x3811, 0x10},\n\t{0x3813, 0x06},\n\t{0x3630, 0x2e},\n\t{0x3632, 0xe2},\n\t{0x3633, 0x23},\n\t{0x3634, 0x44},\n\t{0x3636, 0x06},\n\t{0x3620, 0x64},\n\t{0x3621, 0xe0},\n\t{0x3600, 0x37},\n\t{0x3704, 0xa0},\n\t{0x3703, 0x5a},\n\t{0x3715, 0x78},\n\t{0x3717, 0x01},\n\t{0x3731, 0x02},\n\t{0x370b, 0x60},\n\t{0x3705, 0x1a},\n\t{0x3f05, 0x02},\n\t{0x3f06, 0x10},\n\t{0x3f01, 0x0a},\n\t{0x3a08, 0x01},\n\t{0x3a09, 0x28},\n\t{0x3a0a, 0x00},\n\t{0x3a0b, 0xf6},\n\t{0x3a0d, 0x08},\n\t{0x3a0e, 0x06},\n\t{0x3a0f, 0x58},\n\t{0x3a10, 0x50},\n\t{0x3a1b, 0x58},\n\t{0x3a1e, 0x50},\n\t{0x3a11, 0x60},\n\t{0x3a1f, 0x28},\n\t{0x4001, 0x02},\n\t{0x4004, 0x04},\n\t{0x4000, 0x09},\n\t{0x4837, 0x19},\n\t{0x4800, 0x24},\n\t{0x3503, 0x03},\n\t{0x0100, 0x01},\n};\n\nstatic struct regval_list ov5647_1080p30_10bpp[] = {\n\t{0x0100, 0x00},\n\t{0x0103, 0x01},\n\t{0x3034, 0x1a},\n\t{0x3035, 0x21},\n\t{0x3036, 0x62},\n\t{0x303c, 0x11},\n\t{0x3106, 0xf5},\n\t{0x3821, 0x06},\n\t{0x3820, 0x00},\n\t{0x3827, 0xec},\n\t{0x370c, 0x03},\n\t{0x3612, 0x5b},\n\t{0x3618, 0x04},\n\t{0x5000, 0x06},\n\t{0x5002, 0x41},\n\t{0x5003, 0x08},\n\t{0x5a00, 0x08},\n\t{0x3000, 0x00},\n\t{0x3001, 0x00},\n\t{0x3002, 0x00},\n\t{0x3016, 0x08},\n\t{0x3017, 0xe0},\n\t{0x3018, 0x44},\n\t{0x301c, 0xf8},\n\t{0x301d, 0xf0},\n\t{0x3a18, 0x00},\n\t{0x3a19, 0xf8},\n\t{0x3c01, 0x80},\n\t{0x3b07, 0x0c},\n\t{0x380c, 0x09},\n\t{0x380d, 0x70},\n\t{0x3814, 0x11},\n\t{0x3815, 0x11},\n\t{0x3708, 0x64},\n\t{0x3709, 0x12},\n\t{0x3808, 0x07},\n\t{0x3809, 0x80},\n\t{0x380a, 0x04},\n\t{0x380b, 0x38},\n\t{0x3800, 0x01},\n\t{0x3801, 0x5c},\n\t{0x3802, 0x01},\n\t{0x3803, 0xb2},\n\t{0x3804, 0x08},\n\t{0x3805, 0xe3},\n\t{0x3806, 0x05},\n\t{0x3807, 0xf1},\n\t{0x3811, 0x04},\n\t{0x3813, 0x02},\n\t{0x3630, 0x2e},\n\t{0x3632, 0xe2},\n\t{0x3633, 0x23},\n\t{0x3634, 0x44},\n\t{0x3636, 0x06},\n\t{0x3620, 0x64},\n\t{0x3621, 0xe0},\n\t{0x3600, 0x37},\n\t{0x3704, 0xa0},\n\t{0x3703, 0x5a},\n\t{0x3715, 0x78},\n\t{0x3717, 0x01},\n\t{0x3731, 0x02},\n\t{0x370b, 0x60},\n\t{0x3705, 0x1a},\n\t{0x3f05, 0x02},\n\t{0x3f06, 0x10},\n\t{0x3f01, 0x0a},\n\t{0x3a08, 0x01},\n\t{0x3a09, 0x4b},\n\t{0x3a0a, 0x01},\n\t{0x3a0b, 0x13},\n\t{0x3a0d, 0x04},\n\t{0x3a0e, 0x03},\n\t{0x3a0f, 0x58},\n\t{0x3a10, 0x50},\n\t{0x3a1b, 0x58},\n\t{0x3a1e, 0x50},\n\t{0x3a11, 0x60},\n\t{0x3a1f, 0x28},\n\t{0x4001, 0x02},\n\t{0x4004, 0x04},\n\t{0x4000, 0x09},\n\t{0x4837, 0x19},\n\t{0x4800, 0x34},\n\t{0x3503, 0x03},\n\t{0x0100, 0x01},\n};\n\nstatic struct regval_list ov5647_2x2binned_10bpp[] = {\n\t{0x0100, 0x00},\n\t{0x0103, 0x01},\n\t{0x3034, 0x1a},\n\t{0x3035, 0x21},\n\t{0x3036, 0x62},\n\t{0x303c, 0x11},\n\t{0x3106, 0xf5},\n\t{0x3827, 0xec},\n\t{0x370c, 0x03},\n\t{0x3612, 0x59},\n\t{0x3618, 0x00},\n\t{0x5000, 0x06},\n\t{0x5002, 0x41},\n\t{0x5003, 0x08},\n\t{0x5a00, 0x08},\n\t{0x3000, 0x00},\n\t{0x3001, 0x00},\n\t{0x3002, 0x00},\n\t{0x3016, 0x08},\n\t{0x3017, 0xe0},\n\t{0x3018, 0x44},\n\t{0x301c, 0xf8},\n\t{0x301d, 0xf0},\n\t{0x3a18, 0x00},\n\t{0x3a19, 0xf8},\n\t{0x3c01, 0x80},\n\t{0x3b07, 0x0c},\n\t{0x3800, 0x00},\n\t{0x3801, 0x00},\n\t{0x3802, 0x00},\n\t{0x3803, 0x00},\n\t{0x3804, 0x0a},\n\t{0x3805, 0x3f},\n\t{0x3806, 0x07},\n\t{0x3807, 0xa3},\n\t{0x3808, 0x05},\n\t{0x3809, 0x10},\n\t{0x380a, 0x03},\n\t{0x380b, 0xcc},\n\t{0x380c, 0x07},\n\t{0x380d, 0x68},\n\t{0x3811, 0x0c},\n\t{0x3813, 0x06},\n\t{0x3814, 0x31},\n\t{0x3815, 0x31},\n\t{0x3630, 0x2e},\n\t{0x3632, 0xe2},\n\t{0x3633, 0x23},\n\t{0x3634, 0x44},\n\t{0x3636, 0x06},\n\t{0x3620, 0x64},\n\t{0x3621, 0xe0},\n\t{0x3600, 0x37},\n\t{0x3704, 0xa0},\n\t{0x3703, 0x5a},\n\t{0x3715, 0x78},\n\t{0x3717, 0x01},\n\t{0x3731, 0x02},\n\t{0x370b, 0x60},\n\t{0x3705, 0x1a},\n\t{0x3f05, 0x02},\n\t{0x3f06, 0x10},\n\t{0x3f01, 0x0a},\n\t{0x3a08, 0x01},\n\t{0x3a09, 0x28},\n\t{0x3a0a, 0x00},\n\t{0x3a0b, 0xf6},\n\t{0x3a0d, 0x08},\n\t{0x3a0e, 0x06},\n\t{0x3a0f, 0x58},\n\t{0x3a10, 0x50},\n\t{0x3a1b, 0x58},\n\t{0x3a1e, 0x50},\n\t{0x3a11, 0x60},\n\t{0x3a1f, 0x28},\n\t{0x4001, 0x02},\n\t{0x4004, 0x04},\n\t{0x4000, 0x09},\n\t{0x4837, 0x16},\n\t{0x4800, 0x24},\n\t{0x3503, 0x03},\n\t{0x3820, 0x41},\n\t{0x3821, 0x07},\n\t{0x350a, 0x00},\n\t{0x350b, 0x10},\n\t{0x3500, 0x00},\n\t{0x3501, 0x1a},\n\t{0x3502, 0xf0},\n\t{0x3212, 0xa0},\n\t{0x0100, 0x01},\n};\n\nstatic struct regval_list ov5647_640x480_10bpp[] = {\n\t{0x0100, 0x00},\n\t{0x0103, 0x01},\n\t{0x3035, 0x11},\n\t{0x3036, 0x46},\n\t{0x303c, 0x11},\n\t{0x3821, 0x07},\n\t{0x3820, 0x41},\n\t{0x370c, 0x03},\n\t{0x3612, 0x59},\n\t{0x3618, 0x00},\n\t{0x5000, 0x06},\n\t{0x5003, 0x08},\n\t{0x5a00, 0x08},\n\t{0x3000, 0xff},\n\t{0x3001, 0xff},\n\t{0x3002, 0xff},\n\t{0x301d, 0xf0},\n\t{0x3a18, 0x00},\n\t{0x3a19, 0xf8},\n\t{0x3c01, 0x80},\n\t{0x3b07, 0x0c},\n\t{0x380c, 0x07},\n\t{0x380d, 0x3c},\n\t{0x3814, 0x35},\n\t{0x3815, 0x35},\n\t{0x3708, 0x64},\n\t{0x3709, 0x52},\n\t{0x3808, 0x02},\n\t{0x3809, 0x80},\n\t{0x380a, 0x01},\n\t{0x380b, 0xe0},\n\t{0x3800, 0x00},\n\t{0x3801, 0x10},\n\t{0x3802, 0x00},\n\t{0x3803, 0x00},\n\t{0x3804, 0x0a},\n\t{0x3805, 0x2f},\n\t{0x3806, 0x07},\n\t{0x3807, 0x9f},\n\t{0x3630, 0x2e},\n\t{0x3632, 0xe2},\n\t{0x3633, 0x23},\n\t{0x3634, 0x44},\n\t{0x3620, 0x64},\n\t{0x3621, 0xe0},\n\t{0x3600, 0x37},\n\t{0x3704, 0xa0},\n\t{0x3703, 0x5a},\n\t{0x3715, 0x78},\n\t{0x3717, 0x01},\n\t{0x3731, 0x02},\n\t{0x370b, 0x60},\n\t{0x3705, 0x1a},\n\t{0x3f05, 0x02},\n\t{0x3f06, 0x10},\n\t{0x3f01, 0x0a},\n\t{0x3a08, 0x01},\n\t{0x3a09, 0x2e},\n\t{0x3a0a, 0x00},\n\t{0x3a0b, 0xfb},\n\t{0x3a0d, 0x02},\n\t{0x3a0e, 0x01},\n\t{0x3a0f, 0x58},\n\t{0x3a10, 0x50},\n\t{0x3a1b, 0x58},\n\t{0x3a1e, 0x50},\n\t{0x3a11, 0x60},\n\t{0x3a1f, 0x28},\n\t{0x4001, 0x02},\n\t{0x4004, 0x02},\n\t{0x4000, 0x09},\n\t{0x3000, 0x00},\n\t{0x3001, 0x00},\n\t{0x3002, 0x00},\n\t{0x3017, 0xe0},\n\t{0x301c, 0xfc},\n\t{0x3636, 0x06},\n\t{0x3016, 0x08},\n\t{0x3827, 0xec},\n\t{0x3018, 0x44},\n\t{0x3035, 0x21},\n\t{0x3106, 0xf5},\n\t{0x3034, 0x1a},\n\t{0x301c, 0xf8},\n\t{0x4800, 0x34},\n\t{0x3503, 0x03},\n\t{0x0100, 0x01},\n};\n\nstatic const struct ov5647_mode ov5647_modes[] = {\n\t \n\t{\n\t\t.format = {\n\t\t\t.code\t\t= MEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t\t.field\t\t= V4L2_FIELD_NONE,\n\t\t\t.width\t\t= 2592,\n\t\t\t.height\t\t= 1944\n\t\t},\n\t\t.crop = {\n\t\t\t.left\t\t= OV5647_PIXEL_ARRAY_LEFT,\n\t\t\t.top\t\t= OV5647_PIXEL_ARRAY_TOP,\n\t\t\t.width\t\t= 2592,\n\t\t\t.height\t\t= 1944\n\t\t},\n\t\t.pixel_rate\t= 87500000,\n\t\t.hts\t\t= 2844,\n\t\t.vts\t\t= 0x7b0,\n\t\t.reg_list\t= ov5647_2592x1944_10bpp,\n\t\t.num_regs\t= ARRAY_SIZE(ov5647_2592x1944_10bpp)\n\t},\n\t \n\t{\n\t\t.format = {\n\t\t\t.code\t\t= MEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t\t.field\t\t= V4L2_FIELD_NONE,\n\t\t\t.width\t\t= 1920,\n\t\t\t.height\t\t= 1080\n\t\t},\n\t\t.crop = {\n\t\t\t.left\t\t= 348 + OV5647_PIXEL_ARRAY_LEFT,\n\t\t\t.top\t\t= 434 + OV5647_PIXEL_ARRAY_TOP,\n\t\t\t.width\t\t= 1928,\n\t\t\t.height\t\t= 1080,\n\t\t},\n\t\t.pixel_rate\t= 81666700,\n\t\t.hts\t\t= 2416,\n\t\t.vts\t\t= 0x450,\n\t\t.reg_list\t= ov5647_1080p30_10bpp,\n\t\t.num_regs\t= ARRAY_SIZE(ov5647_1080p30_10bpp)\n\t},\n\t \n\t{\n\t\t.format = {\n\t\t\t.code\t\t= MEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t\t.field\t\t= V4L2_FIELD_NONE,\n\t\t\t.width\t\t= 1296,\n\t\t\t.height\t\t= 972\n\t\t},\n\t\t.crop = {\n\t\t\t.left\t\t= OV5647_PIXEL_ARRAY_LEFT,\n\t\t\t.top\t\t= OV5647_PIXEL_ARRAY_TOP,\n\t\t\t.width\t\t= 2592,\n\t\t\t.height\t\t= 1944,\n\t\t},\n\t\t.pixel_rate\t= 81666700,\n\t\t.hts\t\t= 1896,\n\t\t.vts\t\t= 0x59b,\n\t\t.reg_list\t= ov5647_2x2binned_10bpp,\n\t\t.num_regs\t= ARRAY_SIZE(ov5647_2x2binned_10bpp)\n\t},\n\t \n\t{\n\t\t.format = {\n\t\t\t.code\t\t= MEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t\t.field\t\t= V4L2_FIELD_NONE,\n\t\t\t.width\t\t= 640,\n\t\t\t.height\t\t= 480\n\t\t},\n\t\t.crop = {\n\t\t\t.left\t\t= 16 + OV5647_PIXEL_ARRAY_LEFT,\n\t\t\t.top\t\t= OV5647_PIXEL_ARRAY_TOP,\n\t\t\t.width\t\t= 2560,\n\t\t\t.height\t\t= 1920,\n\t\t},\n\t\t.pixel_rate\t= 55000000,\n\t\t.hts\t\t= 1852,\n\t\t.vts\t\t= 0x1f8,\n\t\t.reg_list\t= ov5647_640x480_10bpp,\n\t\t.num_regs\t= ARRAY_SIZE(ov5647_640x480_10bpp)\n\t},\n};\n\n \n#define OV5647_DEFAULT_MODE\t(&ov5647_modes[3])\n#define OV5647_DEFAULT_FORMAT\t(ov5647_modes[3].format)\n\nstatic int ov5647_write16(struct v4l2_subdev *sd, u16 reg, u16 val)\n{\n\tunsigned char data[4] = { reg >> 8, reg & 0xff, val >> 8, val & 0xff};\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tret = i2c_master_send(client, data, 4);\n\tif (ret < 0) {\n\t\tdev_dbg(&client->dev, \"%s: i2c write error, reg: %x\\n\",\n\t\t\t__func__, reg);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov5647_write(struct v4l2_subdev *sd, u16 reg, u8 val)\n{\n\tunsigned char data[3] = { reg >> 8, reg & 0xff, val};\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tret = i2c_master_send(client, data, 3);\n\tif (ret < 0) {\n\t\tdev_dbg(&client->dev, \"%s: i2c write error, reg: %x\\n\",\n\t\t\t\t__func__, reg);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov5647_read(struct v4l2_subdev *sd, u16 reg, u8 *val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tu8 buf[2] = { reg >> 8, reg & 0xff };\n\tstruct i2c_msg msg[2];\n\tint ret;\n\n\tmsg[0].addr = client->addr;\n\tmsg[0].flags = client->flags;\n\tmsg[0].buf = buf;\n\tmsg[0].len = sizeof(buf);\n\n\tmsg[1].addr = client->addr;\n\tmsg[1].flags = client->flags | I2C_M_RD;\n\tmsg[1].buf = buf;\n\tmsg[1].len = 1;\n\n\tret = i2c_transfer(client->adapter, msg, 2);\n\tif (ret != 2) {\n\t\tdev_err(&client->dev, \"%s: i2c read error, reg: %x = %d\\n\",\n\t\t\t__func__, reg, ret);\n\t\treturn ret >= 0 ? -EINVAL : ret;\n\t}\n\n\t*val = buf[0];\n\n\treturn 0;\n}\n\nstatic int ov5647_write_array(struct v4l2_subdev *sd,\n\t\t\t      const struct regval_list *regs, int array_size)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < array_size; i++) {\n\t\tret = ov5647_write(sd, regs[i].addr, regs[i].data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov5647_set_virtual_channel(struct v4l2_subdev *sd, int channel)\n{\n\tu8 channel_id;\n\tint ret;\n\n\tret = ov5647_read(sd, OV5647_REG_MIPI_CTRL14, &channel_id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tchannel_id &= ~(3 << 6);\n\n\treturn ov5647_write(sd, OV5647_REG_MIPI_CTRL14,\n\t\t\t    channel_id | (channel << 6));\n}\n\nstatic int ov5647_set_mode(struct v4l2_subdev *sd)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov5647 *sensor = to_sensor(sd);\n\tu8 resetval, rdval;\n\tint ret;\n\n\tret = ov5647_read(sd, OV5647_SW_STANDBY, &rdval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov5647_write_array(sd, sensor->mode->reg_list,\n\t\t\t\t sensor->mode->num_regs);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"write sensor default regs error\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ov5647_set_virtual_channel(sd, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov5647_read(sd, OV5647_SW_STANDBY, &resetval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!(resetval & 0x01)) {\n\t\tdev_err(&client->dev, \"Device was in SW standby\");\n\t\tret = ov5647_write(sd, OV5647_SW_STANDBY, 0x01);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov5647_stream_on(struct v4l2_subdev *sd)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov5647 *sensor = to_sensor(sd);\n\tu8 val = MIPI_CTRL00_BUS_IDLE;\n\tint ret;\n\n\tret = ov5647_set_mode(sd);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to program sensor mode: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret =  __v4l2_ctrl_handler_setup(sd->ctrl_handler);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sensor->clock_ncont)\n\t\tval |= MIPI_CTRL00_CLOCK_LANE_GATE |\n\t\t       MIPI_CTRL00_LINE_SYNC_ENABLE;\n\n\tret = ov5647_write(sd, OV5647_REG_MIPI_CTRL00, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov5647_write(sd, OV5647_REG_FRAME_OFF_NUMBER, 0x00);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ov5647_write(sd, OV5640_REG_PAD_OUT, 0x00);\n}\n\nstatic int ov5647_stream_off(struct v4l2_subdev *sd)\n{\n\tint ret;\n\n\tret = ov5647_write(sd, OV5647_REG_MIPI_CTRL00,\n\t\t\t   MIPI_CTRL00_CLOCK_LANE_GATE | MIPI_CTRL00_BUS_IDLE |\n\t\t\t   MIPI_CTRL00_CLOCK_LANE_DISABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov5647_write(sd, OV5647_REG_FRAME_OFF_NUMBER, 0x0f);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ov5647_write(sd, OV5640_REG_PAD_OUT, 0x01);\n}\n\nstatic int ov5647_power_on(struct device *dev)\n{\n\tstruct ov5647 *sensor = dev_get_drvdata(dev);\n\tint ret;\n\n\tdev_dbg(dev, \"OV5647 power on\\n\");\n\n\tif (sensor->pwdn) {\n\t\tgpiod_set_value_cansleep(sensor->pwdn, 0);\n\t\tmsleep(PWDN_ACTIVE_DELAY_MS);\n\t}\n\n\tret = clk_prepare_enable(sensor->xclk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"clk prepare enable failed\\n\");\n\t\tgoto error_pwdn;\n\t}\n\n\tret = ov5647_write_array(&sensor->sd, sensor_oe_enable_regs,\n\t\t\t\t ARRAY_SIZE(sensor_oe_enable_regs));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"write sensor_oe_enable_regs error\\n\");\n\t\tgoto error_clk_disable;\n\t}\n\n\t \n\tret = ov5647_stream_off(&sensor->sd);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"camera not available, check power\\n\");\n\t\tgoto error_clk_disable;\n\t}\n\n\treturn 0;\n\nerror_clk_disable:\n\tclk_disable_unprepare(sensor->xclk);\nerror_pwdn:\n\tgpiod_set_value_cansleep(sensor->pwdn, 1);\n\n\treturn ret;\n}\n\nstatic int ov5647_power_off(struct device *dev)\n{\n\tstruct ov5647 *sensor = dev_get_drvdata(dev);\n\tu8 rdval;\n\tint ret;\n\n\tdev_dbg(dev, \"OV5647 power off\\n\");\n\n\tret = ov5647_write_array(&sensor->sd, sensor_oe_disable_regs,\n\t\t\t\t ARRAY_SIZE(sensor_oe_disable_regs));\n\tif (ret < 0)\n\t\tdev_dbg(dev, \"disable oe failed\\n\");\n\n\t \n\tret = ov5647_read(&sensor->sd, OV5647_SW_STANDBY, &rdval);\n\tif (ret < 0)\n\t\tdev_dbg(dev, \"software standby failed\\n\");\n\n\trdval &= ~0x01;\n\tret = ov5647_write(&sensor->sd, OV5647_SW_STANDBY, rdval);\n\tif (ret < 0)\n\t\tdev_dbg(dev, \"software standby failed\\n\");\n\n\tclk_disable_unprepare(sensor->xclk);\n\tgpiod_set_value_cansleep(sensor->pwdn, 1);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int ov5647_sensor_get_register(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_dbg_register *reg)\n{\n\tint ret;\n\tu8 val;\n\n\tret = ov5647_read(sd, reg->reg & 0xff, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treg->val = val;\n\treg->size = 1;\n\n\treturn 0;\n}\n\nstatic int ov5647_sensor_set_register(struct v4l2_subdev *sd,\n\t\t\t\t      const struct v4l2_dbg_register *reg)\n{\n\treturn ov5647_write(sd, reg->reg & 0xff, reg->val & 0xff);\n}\n#endif\n\n \nstatic const struct v4l2_subdev_core_ops ov5647_subdev_core_ops = {\n\t.subscribe_event\t= v4l2_ctrl_subdev_subscribe_event,\n\t.unsubscribe_event\t= v4l2_event_subdev_unsubscribe,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register\t\t= ov5647_sensor_get_register,\n\t.s_register\t\t= ov5647_sensor_set_register,\n#endif\n};\n\nstatic const struct v4l2_rect *\n__ov5647_get_pad_crop(struct ov5647 *ov5647,\n\t\t      struct v4l2_subdev_state *sd_state,\n\t\t      unsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\treturn v4l2_subdev_get_try_crop(&ov5647->sd, sd_state, pad);\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &ov5647->mode->crop;\n\t}\n\n\treturn NULL;\n}\n\nstatic int ov5647_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov5647 *sensor = to_sensor(sd);\n\tint ret;\n\n\tmutex_lock(&sensor->lock);\n\tif (sensor->streaming == enable) {\n\t\tmutex_unlock(&sensor->lock);\n\t\treturn 0;\n\t}\n\n\tif (enable) {\n\t\tret = pm_runtime_resume_and_get(&client->dev);\n\t\tif (ret < 0)\n\t\t\tgoto error_unlock;\n\n\t\tret = ov5647_stream_on(sd);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"stream start failed: %d\\n\", ret);\n\t\t\tgoto error_pm;\n\t\t}\n\t} else {\n\t\tret = ov5647_stream_off(sd);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"stream stop failed: %d\\n\", ret);\n\t\t\tgoto error_pm;\n\t\t}\n\t\tpm_runtime_put(&client->dev);\n\t}\n\n\tsensor->streaming = enable;\n\tmutex_unlock(&sensor->lock);\n\n\treturn 0;\n\nerror_pm:\n\tpm_runtime_put(&client->dev);\nerror_unlock:\n\tmutex_unlock(&sensor->lock);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_video_ops ov5647_subdev_video_ops = {\n\t.s_stream =\t\tov5647_s_stream,\n};\n\nstatic int ov5647_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index > 0)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_SBGGR10_1X10;\n\n\treturn 0;\n}\n\nstatic int ov5647_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tconst struct v4l2_mbus_framefmt *fmt;\n\n\tif (fse->code != MEDIA_BUS_FMT_SBGGR10_1X10 ||\n\t    fse->index >= ARRAY_SIZE(ov5647_modes))\n\t\treturn -EINVAL;\n\n\tfmt = &ov5647_modes[fse->index].format;\n\tfse->min_width = fmt->width;\n\tfse->max_width = fmt->width;\n\tfse->min_height = fmt->height;\n\tfse->max_height = fmt->height;\n\n\treturn 0;\n}\n\nstatic int ov5647_get_pad_fmt(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *fmt = &format->format;\n\tconst struct v4l2_mbus_framefmt *sensor_format;\n\tstruct ov5647 *sensor = to_sensor(sd);\n\n\tmutex_lock(&sensor->lock);\n\tswitch (format->which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\tsensor_format = v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t\t\t   format->pad);\n\t\tbreak;\n\tdefault:\n\t\tsensor_format = &sensor->mode->format;\n\t\tbreak;\n\t}\n\n\t*fmt = *sensor_format;\n\tmutex_unlock(&sensor->lock);\n\n\treturn 0;\n}\n\nstatic int ov5647_set_pad_fmt(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *fmt = &format->format;\n\tstruct ov5647 *sensor = to_sensor(sd);\n\tconst struct ov5647_mode *mode;\n\n\tmode = v4l2_find_nearest_size(ov5647_modes, ARRAY_SIZE(ov5647_modes),\n\t\t\t\t      format.width, format.height,\n\t\t\t\t      fmt->width, fmt->height);\n\n\t \n\tmutex_lock(&sensor->lock);\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\t*v4l2_subdev_get_try_format(sd, sd_state, format->pad) = mode->format;\n\t} else {\n\t\tint exposure_max, exposure_def;\n\t\tint hblank, vblank;\n\n\t\tsensor->mode = mode;\n\t\t__v4l2_ctrl_modify_range(sensor->pixel_rate, mode->pixel_rate,\n\t\t\t\t\t mode->pixel_rate, 1, mode->pixel_rate);\n\n\t\thblank = mode->hts - mode->format.width;\n\t\t__v4l2_ctrl_modify_range(sensor->hblank, hblank, hblank, 1,\n\t\t\t\t\t hblank);\n\n\t\tvblank = mode->vts - mode->format.height;\n\t\t__v4l2_ctrl_modify_range(sensor->vblank, OV5647_VBLANK_MIN,\n\t\t\t\t\t OV5647_VTS_MAX - mode->format.height,\n\t\t\t\t\t 1, vblank);\n\t\t__v4l2_ctrl_s_ctrl(sensor->vblank, vblank);\n\n\t\texposure_max = mode->vts - 4;\n\t\texposure_def = min(exposure_max, OV5647_EXPOSURE_DEFAULT);\n\t\t__v4l2_ctrl_modify_range(sensor->exposure,\n\t\t\t\t\t sensor->exposure->minimum,\n\t\t\t\t\t exposure_max, sensor->exposure->step,\n\t\t\t\t\t exposure_def);\n\t}\n\t*fmt = mode->format;\n\tmutex_unlock(&sensor->lock);\n\n\treturn 0;\n}\n\nstatic int ov5647_get_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP: {\n\t\tstruct ov5647 *sensor = to_sensor(sd);\n\n\t\tmutex_lock(&sensor->lock);\n\t\tsel->r = *__ov5647_get_pad_crop(sensor, sd_state, sel->pad,\n\t\t\t\t\t\tsel->which);\n\t\tmutex_unlock(&sensor->lock);\n\n\t\treturn 0;\n\t}\n\n\tcase V4L2_SEL_TGT_NATIVE_SIZE:\n\t\tsel->r.top = 0;\n\t\tsel->r.left = 0;\n\t\tsel->r.width = OV5647_NATIVE_WIDTH;\n\t\tsel->r.height = OV5647_NATIVE_HEIGHT;\n\n\t\treturn 0;\n\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.top = OV5647_PIXEL_ARRAY_TOP;\n\t\tsel->r.left = OV5647_PIXEL_ARRAY_LEFT;\n\t\tsel->r.width = OV5647_PIXEL_ARRAY_WIDTH;\n\t\tsel->r.height = OV5647_PIXEL_ARRAY_HEIGHT;\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct v4l2_subdev_pad_ops ov5647_subdev_pad_ops = {\n\t.enum_mbus_code\t\t= ov5647_enum_mbus_code,\n\t.enum_frame_size\t= ov5647_enum_frame_size,\n\t.set_fmt\t\t= ov5647_set_pad_fmt,\n\t.get_fmt\t\t= ov5647_get_pad_fmt,\n\t.get_selection\t\t= ov5647_get_selection,\n};\n\nstatic const struct v4l2_subdev_ops ov5647_subdev_ops = {\n\t.core\t\t= &ov5647_subdev_core_ops,\n\t.video\t\t= &ov5647_subdev_video_ops,\n\t.pad\t\t= &ov5647_subdev_pad_ops,\n};\n\nstatic int ov5647_detect(struct v4l2_subdev *sd)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tu8 read;\n\tint ret;\n\n\tret = ov5647_write(sd, OV5647_SW_RESET, 0x01);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov5647_read(sd, OV5647_REG_CHIPID_H, &read);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (read != 0x56) {\n\t\tdev_err(&client->dev, \"ID High expected 0x56 got %x\", read);\n\t\treturn -ENODEV;\n\t}\n\n\tret = ov5647_read(sd, OV5647_REG_CHIPID_L, &read);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (read != 0x47) {\n\t\tdev_err(&client->dev, \"ID Low expected 0x47 got %x\", read);\n\t\treturn -ENODEV;\n\t}\n\n\treturn ov5647_write(sd, OV5647_SW_RESET, 0x00);\n}\n\nstatic int ov5647_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_mbus_framefmt *format =\n\t\t\t\tv4l2_subdev_get_try_format(sd, fh->state, 0);\n\tstruct v4l2_rect *crop = v4l2_subdev_get_try_crop(sd, fh->state, 0);\n\n\tcrop->left = OV5647_PIXEL_ARRAY_LEFT;\n\tcrop->top = OV5647_PIXEL_ARRAY_TOP;\n\tcrop->width = OV5647_PIXEL_ARRAY_WIDTH;\n\tcrop->height = OV5647_PIXEL_ARRAY_HEIGHT;\n\n\t*format = OV5647_DEFAULT_FORMAT;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_internal_ops ov5647_subdev_internal_ops = {\n\t.open = ov5647_open,\n};\n\nstatic int ov5647_s_auto_white_balance(struct v4l2_subdev *sd, u32 val)\n{\n\treturn ov5647_write(sd, OV5647_REG_AWB, val ? 1 : 0);\n}\n\nstatic int ov5647_s_autogain(struct v4l2_subdev *sd, u32 val)\n{\n\tint ret;\n\tu8 reg;\n\n\t \n\tret = ov5647_read(sd, OV5647_REG_AEC_AGC, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov5647_write(sd, OV5647_REG_AEC_AGC, val ? reg & ~BIT(1)\n\t\t\t\t\t\t\t: reg | BIT(1));\n}\n\nstatic int ov5647_s_exposure_auto(struct v4l2_subdev *sd, u32 val)\n{\n\tint ret;\n\tu8 reg;\n\n\t \n\tret = ov5647_read(sd, OV5647_REG_AEC_AGC, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov5647_write(sd, OV5647_REG_AEC_AGC,\n\t\t\t    val == V4L2_EXPOSURE_MANUAL ? reg | BIT(0)\n\t\t\t\t\t\t\t: reg & ~BIT(0));\n}\n\nstatic int ov5647_s_analogue_gain(struct v4l2_subdev *sd, u32 val)\n{\n\tint ret;\n\n\t \n\tret = ov5647_write(sd, OV5647_REG_GAIN_HI, (val >> 8) & 3);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov5647_write(sd, OV5647_REG_GAIN_LO, val & 0xff);\n}\n\nstatic int ov5647_s_exposure(struct v4l2_subdev *sd, u32 val)\n{\n\tint ret;\n\n\t \n\tret = ov5647_write(sd, OV5647_REG_EXP_HI, (val >> 12) & 0xf);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5647_write(sd, OV5647_REG_EXP_MID, (val >> 4) & 0xff);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov5647_write(sd, OV5647_REG_EXP_LO, (val & 0xf) << 4);\n}\n\nstatic int ov5647_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ov5647 *sensor = container_of(ctrl->handler,\n\t\t\t\t\t    struct ov5647, ctrls);\n\tstruct v4l2_subdev *sd = &sensor->sd;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret = 0;\n\n\n\t \n\n\tif (ctrl->id == V4L2_CID_VBLANK) {\n\t\tint exposure_max, exposure_def;\n\n\t\t \n\t\texposure_max = sensor->mode->format.height + ctrl->val - 4;\n\t\texposure_def = min(exposure_max, OV5647_EXPOSURE_DEFAULT);\n\t\t__v4l2_ctrl_modify_range(sensor->exposure,\n\t\t\t\t\t sensor->exposure->minimum,\n\t\t\t\t\t exposure_max, sensor->exposure->step,\n\t\t\t\t\t exposure_def);\n\t}\n\n\t \n\tif (pm_runtime_get_if_in_use(&client->dev) == 0)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\tret = ov5647_s_auto_white_balance(sd, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\tret = ov5647_s_autogain(sd, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tret = ov5647_s_exposure_auto(sd, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_ANALOGUE_GAIN:\n\t\tret =  ov5647_s_analogue_gain(sd, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE:\n\t\tret = ov5647_s_exposure(sd, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_VBLANK:\n\t\tret = ov5647_write16(sd, OV5647_REG_VTS_HI,\n\t\t\t\t     sensor->mode->format.height + ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tret = ov5647_write(sd, OV5647_REG_ISPCTRL3D,\n\t\t\t\t   ov5647_test_pattern_val[ctrl->val]);\n\t\tbreak;\n\n\t \n\tcase V4L2_CID_PIXEL_RATE:\n\tcase V4L2_CID_HBLANK:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tdev_info(&client->dev,\n\t\t\t \"Control (id:0x%x, val:0x%x) not supported\\n\",\n\t\t\t ctrl->id, ctrl->val);\n\t\treturn -EINVAL;\n\t}\n\n\tpm_runtime_put(&client->dev);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops ov5647_ctrl_ops = {\n\t.s_ctrl = ov5647_s_ctrl,\n};\n\nstatic int ov5647_init_controls(struct ov5647 *sensor)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);\n\tint hblank, exposure_max, exposure_def;\n\n\tv4l2_ctrl_handler_init(&sensor->ctrls, 9);\n\n\tv4l2_ctrl_new_std(&sensor->ctrls, &ov5647_ctrl_ops,\n\t\t\t  V4L2_CID_AUTOGAIN, 0, 1, 1, 0);\n\n\tv4l2_ctrl_new_std(&sensor->ctrls, &ov5647_ctrl_ops,\n\t\t\t  V4L2_CID_AUTO_WHITE_BALANCE, 0, 1, 1, 0);\n\n\tv4l2_ctrl_new_std_menu(&sensor->ctrls, &ov5647_ctrl_ops,\n\t\t\t       V4L2_CID_EXPOSURE_AUTO, V4L2_EXPOSURE_MANUAL,\n\t\t\t       0, V4L2_EXPOSURE_MANUAL);\n\n\texposure_max = sensor->mode->vts - 4;\n\texposure_def = min(exposure_max, OV5647_EXPOSURE_DEFAULT);\n\tsensor->exposure = v4l2_ctrl_new_std(&sensor->ctrls, &ov5647_ctrl_ops,\n\t\t\t\t\t     V4L2_CID_EXPOSURE,\n\t\t\t\t\t     OV5647_EXPOSURE_MIN,\n\t\t\t\t\t     exposure_max, OV5647_EXPOSURE_STEP,\n\t\t\t\t\t     exposure_def);\n\n\t \n\tv4l2_ctrl_new_std(&sensor->ctrls, &ov5647_ctrl_ops,\n\t\t\t  V4L2_CID_ANALOGUE_GAIN, 16, 1023, 1, 32);\n\n\t \n\tsensor->pixel_rate = v4l2_ctrl_new_std(&sensor->ctrls, &ov5647_ctrl_ops,\n\t\t\t\t\t       V4L2_CID_PIXEL_RATE,\n\t\t\t\t\t       sensor->mode->pixel_rate,\n\t\t\t\t\t       sensor->mode->pixel_rate, 1,\n\t\t\t\t\t       sensor->mode->pixel_rate);\n\n\t \n\thblank = sensor->mode->hts - sensor->mode->format.width;\n\tsensor->hblank = v4l2_ctrl_new_std(&sensor->ctrls, &ov5647_ctrl_ops,\n\t\t\t\t\t   V4L2_CID_HBLANK, hblank, hblank, 1,\n\t\t\t\t\t   hblank);\n\n\tsensor->vblank = v4l2_ctrl_new_std(&sensor->ctrls, &ov5647_ctrl_ops,\n\t\t\t\t\t   V4L2_CID_VBLANK, OV5647_VBLANK_MIN,\n\t\t\t\t\t   OV5647_VTS_MAX -\n\t\t\t\t\t   sensor->mode->format.height, 1,\n\t\t\t\t\t   sensor->mode->vts -\n\t\t\t\t\t   sensor->mode->format.height);\n\n\tv4l2_ctrl_new_std_menu_items(&sensor->ctrls, &ov5647_ctrl_ops,\n\t\t\t\t     V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(ov5647_test_pattern_menu) - 1,\n\t\t\t\t     0, 0, ov5647_test_pattern_menu);\n\n\tif (sensor->ctrls.error)\n\t\tgoto handler_free;\n\n\tsensor->pixel_rate->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\tsensor->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\tsensor->sd.ctrl_handler = &sensor->ctrls;\n\n\treturn 0;\n\nhandler_free:\n\tdev_err(&client->dev, \"%s Controls initialization failed (%d)\\n\",\n\t\t__func__, sensor->ctrls.error);\n\tv4l2_ctrl_handler_free(&sensor->ctrls);\n\n\treturn sensor->ctrls.error;\n}\n\nstatic int ov5647_parse_dt(struct ov5647 *sensor, struct device_node *np)\n{\n\tstruct v4l2_fwnode_endpoint bus_cfg = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY,\n\t};\n\tstruct device_node *ep;\n\tint ret;\n\n\tep = of_graph_get_next_endpoint(np, NULL);\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(ep), &bus_cfg);\n\tif (ret)\n\t\tgoto out;\n\n\tsensor->clock_ncont = bus_cfg.bus.mipi_csi2.flags &\n\t\t\t      V4L2_MBUS_CSI2_NONCONTINUOUS_CLOCK;\n\nout:\n\tof_node_put(ep);\n\n\treturn ret;\n}\n\nstatic int ov5647_probe(struct i2c_client *client)\n{\n\tstruct device_node *np = client->dev.of_node;\n\tstruct device *dev = &client->dev;\n\tstruct ov5647 *sensor;\n\tstruct v4l2_subdev *sd;\n\tu32 xclk_freq;\n\tint ret;\n\n\tsensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);\n\tif (!sensor)\n\t\treturn -ENOMEM;\n\n\tif (IS_ENABLED(CONFIG_OF) && np) {\n\t\tret = ov5647_parse_dt(sensor, np);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"DT parsing error: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tsensor->xclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(sensor->xclk)) {\n\t\tdev_err(dev, \"could not get xclk\");\n\t\treturn PTR_ERR(sensor->xclk);\n\t}\n\n\txclk_freq = clk_get_rate(sensor->xclk);\n\tif (xclk_freq != 25000000) {\n\t\tdev_err(dev, \"Unsupported clock frequency: %u\\n\", xclk_freq);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsensor->pwdn = devm_gpiod_get_optional(dev, \"pwdn\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(sensor->pwdn)) {\n\t\tdev_err(dev, \"Failed to get 'pwdn' gpio\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_init(&sensor->lock);\n\n\tsensor->mode = OV5647_DEFAULT_MODE;\n\n\tret = ov5647_init_controls(sensor);\n\tif (ret)\n\t\tgoto mutex_destroy;\n\n\tsd = &sensor->sd;\n\tv4l2_i2c_subdev_init(sd, client, &ov5647_subdev_ops);\n\tsd->internal_ops = &ov5647_subdev_internal_ops;\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;\n\n\tsensor->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tsd->entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tret = media_entity_pads_init(&sd->entity, 1, &sensor->pad);\n\tif (ret < 0)\n\t\tgoto ctrl_handler_free;\n\n\tret = ov5647_power_on(dev);\n\tif (ret)\n\t\tgoto entity_cleanup;\n\n\tret = ov5647_detect(sd);\n\tif (ret < 0)\n\t\tgoto power_off;\n\n\tret = v4l2_async_register_subdev(sd);\n\tif (ret < 0)\n\t\tgoto power_off;\n\n\t \n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_idle(dev);\n\n\tdev_dbg(dev, \"OmniVision OV5647 camera driver probed\\n\");\n\n\treturn 0;\n\npower_off:\n\tov5647_power_off(dev);\nentity_cleanup:\n\tmedia_entity_cleanup(&sd->entity);\nctrl_handler_free:\n\tv4l2_ctrl_handler_free(&sensor->ctrls);\nmutex_destroy:\n\tmutex_destroy(&sensor->lock);\n\n\treturn ret;\n}\n\nstatic void ov5647_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov5647 *sensor = to_sensor(sd);\n\n\tv4l2_async_unregister_subdev(&sensor->sd);\n\tmedia_entity_cleanup(&sensor->sd.entity);\n\tv4l2_ctrl_handler_free(&sensor->ctrls);\n\tv4l2_device_unregister_subdev(sd);\n\tpm_runtime_disable(&client->dev);\n\tmutex_destroy(&sensor->lock);\n}\n\nstatic const struct dev_pm_ops ov5647_pm_ops = {\n\tSET_RUNTIME_PM_OPS(ov5647_power_off, ov5647_power_on, NULL)\n};\n\nstatic const struct i2c_device_id ov5647_id[] = {\n\t{ \"ov5647\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, ov5647_id);\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id ov5647_of_match[] = {\n\t{ .compatible = \"ovti,ov5647\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ov5647_of_match);\n#endif\n\nstatic struct i2c_driver ov5647_driver = {\n\t.driver = {\n\t\t.of_match_table = of_match_ptr(ov5647_of_match),\n\t\t.name\t= \"ov5647\",\n\t\t.pm\t= &ov5647_pm_ops,\n\t},\n\t.probe\t\t= ov5647_probe,\n\t.remove\t\t= ov5647_remove,\n\t.id_table\t= ov5647_id,\n};\n\nmodule_i2c_driver(ov5647_driver);\n\nMODULE_AUTHOR(\"Ramiro Oliveira <roliveir@synopsys.com>\");\nMODULE_DESCRIPTION(\"A low-level driver for OmniVision ov5647 sensors\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}