{
  "module_name": "ov7740.c",
  "hash_id": "8db348909a2c1b1c2d3e7aeea8dc039827ade06036ed2b02188eff2c28909046",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ov7740.c",
  "human_readable_source": "\n\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-image-sizes.h>\n#include <media/v4l2-subdev.h>\n\n#define REG_OUTSIZE_LSB 0x34\n\n \n#define REG_GAIN\t0x00\t \n#define REG_BGAIN\t0x01\t \n#define REG_RGAIN\t0x02\t \n#define REG_GGAIN\t0x03\t \n#define REG_REG04\t0x04\t \n#define REG_BAVG\t0x05\t \n#define REG_GAVG\t0x06\t \n#define REG_RAVG\t0x07\t \n\n#define REG_REG0C\t0x0C\t \n#define REG0C_IMG_FLIP\t\t0x80\n#define REG0C_IMG_MIRROR\t0x40\n\n#define REG_REG0E\t0x0E\t \n#define REG_HAEC\t0x0F\t \n#define REG_AEC\t\t0x10\t \n\n#define REG_CLK\t\t0x11\t \n#define REG_REG55\t0x55\t \n\n#define REG_REG12\t0x12\n\n#define REG_REG13\t0x13\t \n#define REG13_AEC_EN\t0x01\n#define REG13_AGC_EN\t0x04\n\n#define REG_REG14\t0x14\n#define REG_CTRL15\t0x15\n#define REG15_GAIN_MSB\t0x03\n\n#define REG_REG16\t0x16\n\n#define REG_MIDH\t0x1C\t \n#define REG_MIDL\t0x1D\t \n#define REG_PIDH\t0x0A\t \n#define REG_PIDL\t0x0B\t \n\n#define REG_84\t\t0x84\t \n#define REG_REG38\t0x38\t \n\n#define REG_AHSTART\t0x17\t \n#define REG_AHSIZE\t0x18\n#define REG_AVSTART\t0x19\t \n#define REG_AVSIZE\t0x1A\n#define REG_PSHFT\t0x1b\t \n\n#define REG_HOUTSIZE\t0x31\n#define REG_VOUTSIZE\t0x32\n#define REG_HVSIZEOFF\t0x33\n#define REG_REG34\t0x34\t \n\n#define REG_ISP_CTRL00\t0x80\n#define ISPCTRL00_AWB_EN\t0x10\n#define ISPCTRL00_AWB_GAIN_EN\t0x04\n\n#define\tREG_YGAIN\t0xE2\t \n\n#define\tREG_YBRIGHT\t  0xE3\n#define\tREG_SGNSET\t  0xE4\n#define\tSGNSET_YBRIGHT_MASK\t  0x08\n\n#define REG_USAT\t0xDD\n#define REG_VSAT\t0xDE\n\n\nstruct ov7740 {\n\tstruct v4l2_subdev subdev;\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tstruct media_pad pad;\n#endif\n\tstruct v4l2_mbus_framefmt format;\n\tconst struct ov7740_pixfmt *fmt;   \n\tconst struct ov7740_framesize *frmsize;\n\tstruct regmap *regmap;\n\tstruct clk *xvclk;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tstruct {\n\t\t \n\t\tstruct v4l2_ctrl *auto_gain;\n\t\tstruct v4l2_ctrl *gain;\n\t};\n\tstruct {\n\t\tstruct v4l2_ctrl *auto_wb;\n\t\tstruct v4l2_ctrl *blue_balance;\n\t\tstruct v4l2_ctrl *red_balance;\n\t};\n\tstruct {\n\t\tstruct v4l2_ctrl *hflip;\n\t\tstruct v4l2_ctrl *vflip;\n\t};\n\tstruct {\n\t\t \n\t\tstruct v4l2_ctrl *auto_exposure;\n\t\tstruct v4l2_ctrl *exposure;\n\t};\n\tstruct {\n\t\t \n\t\tstruct v4l2_ctrl *saturation;\n\t\tstruct v4l2_ctrl *hue;\n\t};\n\tstruct v4l2_ctrl *brightness;\n\tstruct v4l2_ctrl *contrast;\n\n\tstruct mutex mutex;\t \n\tbool streaming;\t\t \n\n\tstruct gpio_desc *resetb_gpio;\n\tstruct gpio_desc *pwdn_gpio;\n};\n\nstruct ov7740_pixfmt {\n\tu32 mbus_code;\n\tenum v4l2_colorspace colorspace;\n\tconst struct reg_sequence *regs;\n\tu32 reg_num;\n};\n\nstruct ov7740_framesize {\n\tu16 width;\n\tu16 height;\n\tconst struct reg_sequence *regs;\n\tu32 reg_num;\n};\n\nstatic const struct reg_sequence ov7740_vga[] = {\n\t{0x55, 0x40},\n\t{0x11, 0x02},\n\n\t{0xd5, 0x10},\n\t{0x0c, 0x12},\n\t{0x0d, 0x34},\n\t{0x17, 0x25},\n\t{0x18, 0xa0},\n\t{0x19, 0x03},\n\t{0x1a, 0xf0},\n\t{0x1b, 0x89},\n\t{0x22, 0x03},\n\t{0x29, 0x18},\n\t{0x2b, 0xf8},\n\t{0x2c, 0x01},\n\t{REG_HOUTSIZE, 0xa0},\n\t{REG_VOUTSIZE, 0xf0},\n\t{0x33, 0xc4},\n\t{REG_OUTSIZE_LSB, 0x0},\n\t{0x35, 0x05},\n\t{0x04, 0x60},\n\t{0x27, 0x80},\n\t{0x3d, 0x0f},\n\t{0x3e, 0x80},\n\t{0x3f, 0x40},\n\t{0x40, 0x7f},\n\t{0x41, 0x6a},\n\t{0x42, 0x29},\n\t{0x44, 0x22},\n\t{0x45, 0x41},\n\t{0x47, 0x02},\n\t{0x49, 0x64},\n\t{0x4a, 0xa1},\n\t{0x4b, 0x40},\n\t{0x4c, 0x1a},\n\t{0x4d, 0x50},\n\t{0x4e, 0x13},\n\t{0x64, 0x00},\n\t{0x67, 0x88},\n\t{0x68, 0x1a},\n\n\t{0x14, 0x28},\n\t{0x24, 0x3c},\n\t{0x25, 0x30},\n\t{0x26, 0x72},\n\t{0x50, 0x97},\n\t{0x51, 0x1f},\n\t{0x52, 0x00},\n\t{0x53, 0x00},\n\t{0x20, 0x00},\n\t{0x21, 0xcf},\n\t{0x50, 0x4b},\n\t{0x38, 0x14},\n\t{0xe9, 0x00},\n\t{0x56, 0x55},\n\t{0x57, 0xff},\n\t{0x58, 0xff},\n\t{0x59, 0xff},\n\t{0x5f, 0x04},\n\t{0xec, 0x00},\n\t{0x13, 0xff},\n\n\t{0x81, 0x3f},\n\t{0x82, 0x32},\n\t{0x38, 0x11},\n\t{0x84, 0x70},\n\t{0x85, 0x00},\n\t{0x86, 0x03},\n\t{0x87, 0x01},\n\t{0x88, 0x05},\n\t{0x89, 0x30},\n\t{0x8d, 0x30},\n\t{0x8f, 0x85},\n\t{0x93, 0x30},\n\t{0x95, 0x85},\n\t{0x99, 0x30},\n\t{0x9b, 0x85},\n\n\t{0x9c, 0x08},\n\t{0x9d, 0x12},\n\t{0x9e, 0x23},\n\t{0x9f, 0x45},\n\t{0xa0, 0x55},\n\t{0xa1, 0x64},\n\t{0xa2, 0x72},\n\t{0xa3, 0x7f},\n\t{0xa4, 0x8b},\n\t{0xa5, 0x95},\n\t{0xa6, 0xa7},\n\t{0xa7, 0xb5},\n\t{0xa8, 0xcb},\n\t{0xa9, 0xdd},\n\t{0xaa, 0xec},\n\t{0xab, 0x1a},\n\n\t{0xce, 0x78},\n\t{0xcf, 0x6e},\n\t{0xd0, 0x0a},\n\t{0xd1, 0x0c},\n\t{0xd2, 0x84},\n\t{0xd3, 0x90},\n\t{0xd4, 0x1e},\n\n\t{0x5a, 0x24},\n\t{0x5b, 0x1f},\n\t{0x5c, 0x88},\n\t{0x5d, 0x60},\n\n\t{0xac, 0x6e},\n\t{0xbe, 0xff},\n\t{0xbf, 0x00},\n\n\t{0x0f, 0x1d},\n\t{0x0f, 0x1f},\n};\n\nstatic const struct ov7740_framesize ov7740_framesizes[] = {\n\t{\n\t\t.width\t\t= VGA_WIDTH,\n\t\t.height\t\t= VGA_HEIGHT,\n\t\t.regs\t\t= ov7740_vga,\n\t\t.reg_num\t= ARRAY_SIZE(ov7740_vga),\n\t},\n};\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int ov7740_get_register(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_dbg_register *reg)\n{\n\tstruct ov7740 *ov7740 = container_of(sd, struct ov7740, subdev);\n\tstruct regmap *regmap = ov7740->regmap;\n\tunsigned int val = 0;\n\tint ret;\n\n\tret = regmap_read(regmap, reg->reg & 0xff, &val);\n\treg->val = val;\n\treg->size = 1;\n\n\treturn ret;\n}\n\nstatic int ov7740_set_register(struct v4l2_subdev *sd,\n\t\t\t       const struct v4l2_dbg_register *reg)\n{\n\tstruct ov7740 *ov7740 = container_of(sd, struct ov7740, subdev);\n\tstruct regmap *regmap = ov7740->regmap;\n\n\tregmap_write(regmap, reg->reg & 0xff, reg->val & 0xff);\n\n\treturn 0;\n}\n#endif\n\nstatic int ov7740_set_power(struct ov7740 *ov7740, int on)\n{\n\tint ret;\n\n\tif (on) {\n\t\tret = clk_prepare_enable(ov7740->xvclk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (ov7740->pwdn_gpio)\n\t\t\tgpiod_direction_output(ov7740->pwdn_gpio, 0);\n\n\t\tif (ov7740->resetb_gpio) {\n\t\t\tgpiod_set_value(ov7740->resetb_gpio, 1);\n\t\t\tusleep_range(500, 1000);\n\t\t\tgpiod_set_value(ov7740->resetb_gpio, 0);\n\t\t\tusleep_range(3000, 5000);\n\t\t}\n\t} else {\n\t\tclk_disable_unprepare(ov7740->xvclk);\n\n\t\tif (ov7740->pwdn_gpio)\n\t\t\tgpiod_direction_output(ov7740->pwdn_gpio, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops ov7740_subdev_core_ops = {\n\t.log_status = v4l2_ctrl_subdev_log_status,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = ov7740_get_register,\n\t.s_register = ov7740_set_register,\n#endif\n\t.subscribe_event = v4l2_ctrl_subdev_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n};\n\nstatic int ov7740_set_white_balance(struct ov7740 *ov7740, int awb)\n{\n\tstruct regmap *regmap = ov7740->regmap;\n\tunsigned int value;\n\tint ret;\n\n\tret = regmap_read(regmap, REG_ISP_CTRL00, &value);\n\tif (!ret) {\n\t\tif (awb)\n\t\t\tvalue |= (ISPCTRL00_AWB_EN | ISPCTRL00_AWB_GAIN_EN);\n\t\telse\n\t\t\tvalue &= ~(ISPCTRL00_AWB_EN | ISPCTRL00_AWB_GAIN_EN);\n\t\tret = regmap_write(regmap, REG_ISP_CTRL00, value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!awb) {\n\t\tret = regmap_write(regmap, REG_BGAIN,\n\t\t\t\t   ov7740->blue_balance->val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(regmap, REG_RGAIN, ov7740->red_balance->val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov7740_set_saturation(struct regmap *regmap, int value)\n{\n\tint ret;\n\n\tret = regmap_write(regmap, REG_USAT, (unsigned char)value);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(regmap, REG_VSAT, (unsigned char)value);\n}\n\nstatic int ov7740_set_gain(struct regmap *regmap, int value)\n{\n\tint ret;\n\n\tret = regmap_write(regmap, REG_GAIN, value & 0xff);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(regmap, REG_CTRL15,\n\t\t\t\t REG15_GAIN_MSB, (value >> 8) & 0x3);\n\tif (!ret)\n\t\tret = regmap_update_bits(regmap, REG_REG13, REG13_AGC_EN, 0);\n\n\treturn ret;\n}\n\nstatic int ov7740_set_autogain(struct regmap *regmap, int value)\n{\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_read(regmap, REG_REG13, &reg);\n\tif (ret)\n\t\treturn ret;\n\tif (value)\n\t\treg |= REG13_AGC_EN;\n\telse\n\t\treg &= ~REG13_AGC_EN;\n\treturn regmap_write(regmap, REG_REG13, reg);\n}\n\nstatic int ov7740_set_brightness(struct regmap *regmap, int value)\n{\n\t \n\tregmap_update_bits(regmap, REG_REG13, REG13_AEC_EN, 0);\n\tregmap_update_bits(regmap, REG_REG13, REG13_AGC_EN, 0);\n\n\tif (value >= 0) {\n\t\tregmap_write(regmap, REG_YBRIGHT, (unsigned char)value);\n\t\tregmap_update_bits(regmap, REG_SGNSET, SGNSET_YBRIGHT_MASK, 0);\n\t} else{\n\t\tregmap_write(regmap, REG_YBRIGHT, (unsigned char)(-value));\n\t\tregmap_update_bits(regmap, REG_SGNSET, SGNSET_YBRIGHT_MASK, 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int ov7740_set_contrast(struct regmap *regmap, int value)\n{\n\treturn regmap_write(regmap, REG_YGAIN, (unsigned char)value);\n}\n\nstatic int ov7740_get_gain(struct ov7740 *ov7740, struct v4l2_ctrl *ctrl)\n{\n\tstruct regmap *regmap = ov7740->regmap;\n\tunsigned int value0, value1;\n\tint ret;\n\n\tif (!ctrl->val)\n\t\treturn 0;\n\n\tret = regmap_read(regmap, REG_GAIN, &value0);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_read(regmap, REG_CTRL15, &value1);\n\tif (ret)\n\t\treturn ret;\n\n\tov7740->gain->val = (value1 << 8) | (value0 & 0xff);\n\n\treturn 0;\n}\n\nstatic int ov7740_get_exp(struct ov7740 *ov7740, struct v4l2_ctrl *ctrl)\n{\n\tstruct regmap *regmap = ov7740->regmap;\n\tunsigned int value0, value1;\n\tint ret;\n\n\tif (ctrl->val == V4L2_EXPOSURE_MANUAL)\n\t\treturn 0;\n\n\tret = regmap_read(regmap, REG_AEC, &value0);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_read(regmap, REG_HAEC, &value1);\n\tif (ret)\n\t\treturn ret;\n\n\tov7740->exposure->val = (value1 << 8) | (value0 & 0xff);\n\n\treturn 0;\n}\n\nstatic int ov7740_set_exp(struct regmap *regmap, int value)\n{\n\tint ret;\n\n\t \n\tret = regmap_update_bits(regmap, REG_REG13,\n\t\t\t\t REG13_AEC_EN | REG13_AGC_EN, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(regmap, REG_AEC, (unsigned char)value);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(regmap, REG_HAEC, (unsigned char)(value >> 8));\n}\n\nstatic int ov7740_set_autoexp(struct regmap *regmap,\n\t\t\t      enum v4l2_exposure_auto_type value)\n{\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_read(regmap, REG_REG13, &reg);\n\tif (!ret) {\n\t\tif (value == V4L2_EXPOSURE_AUTO)\n\t\t\treg |= (REG13_AEC_EN | REG13_AGC_EN);\n\t\telse\n\t\t\treg &= ~(REG13_AEC_EN | REG13_AGC_EN);\n\t\tret = regmap_write(regmap, REG_REG13, reg);\n\t}\n\n\treturn ret;\n}\n\n\nstatic int ov7740_get_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ov7740 *ov7740 = container_of(ctrl->handler,\n\t\t\t\t\t     struct ov7740, ctrl_handler);\n\tint ret;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTOGAIN:\n\t\tret = ov7740_get_gain(ov7740, ctrl);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tret = ov7740_get_exp(ov7740, ctrl);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int ov7740_set_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ov7740 *ov7740 = container_of(ctrl->handler,\n\t\t\t\t\t     struct ov7740, ctrl_handler);\n\tstruct i2c_client *client = v4l2_get_subdevdata(&ov7740->subdev);\n\tstruct regmap *regmap = ov7740->regmap;\n\tint ret;\n\tu8 val;\n\n\tif (!pm_runtime_get_if_in_use(&client->dev))\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\tret = ov7740_set_white_balance(ov7740, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tret = ov7740_set_saturation(regmap, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tret = ov7740_set_brightness(regmap, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tret = ov7740_set_contrast(regmap, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tval = ctrl->val ? REG0C_IMG_FLIP : 0x00;\n\t\tret = regmap_update_bits(regmap, REG_REG0C,\n\t\t\t\t\t REG0C_IMG_FLIP, val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tval = ctrl->val ? REG0C_IMG_MIRROR : 0x00;\n\t\tret = regmap_update_bits(regmap, REG_REG0C,\n\t\t\t\t\t REG0C_IMG_MIRROR, val);\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\tif (!ctrl->val)\n\t\t\tret = ov7740_set_gain(regmap, ov7740->gain->val);\n\t\telse\n\t\t\tret = ov7740_set_autogain(regmap, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tif (ctrl->val == V4L2_EXPOSURE_MANUAL)\n\t\t\tret = ov7740_set_exp(regmap, ov7740->exposure->val);\n\t\telse\n\t\t\tret = ov7740_set_autoexp(regmap, ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tpm_runtime_put(&client->dev);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops ov7740_ctrl_ops = {\n\t.g_volatile_ctrl = ov7740_get_volatile_ctrl,\n\t.s_ctrl = ov7740_set_ctrl,\n};\n\nstatic int ov7740_start_streaming(struct ov7740 *ov7740)\n{\n\tint ret;\n\n\tif (ov7740->fmt) {\n\t\tret = regmap_multi_reg_write(ov7740->regmap,\n\t\t\t\t\t     ov7740->fmt->regs,\n\t\t\t\t\t     ov7740->fmt->reg_num);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ov7740->frmsize) {\n\t\tret = regmap_multi_reg_write(ov7740->regmap,\n\t\t\t\t\t     ov7740->frmsize->regs,\n\t\t\t\t\t     ov7740->frmsize->reg_num);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn __v4l2_ctrl_handler_setup(ov7740->subdev.ctrl_handler);\n}\n\nstatic int ov7740_set_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct ov7740 *ov7740 = container_of(sd, struct ov7740, subdev);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret = 0;\n\n\tmutex_lock(&ov7740->mutex);\n\tif (ov7740->streaming == enable) {\n\t\tmutex_unlock(&ov7740->mutex);\n\t\treturn 0;\n\t}\n\n\tif (enable) {\n\t\tret = pm_runtime_resume_and_get(&client->dev);\n\t\tif (ret < 0)\n\t\t\tgoto err_unlock;\n\n\t\tret = ov7740_start_streaming(ov7740);\n\t\tif (ret)\n\t\t\tgoto err_rpm_put;\n\t} else {\n\t\tpm_runtime_put(&client->dev);\n\t}\n\n\tov7740->streaming = enable;\n\n\tmutex_unlock(&ov7740->mutex);\n\treturn ret;\n\nerr_rpm_put:\n\tpm_runtime_put(&client->dev);\nerr_unlock:\n\tmutex_unlock(&ov7740->mutex);\n\treturn ret;\n}\n\nstatic int ov7740_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *ival)\n{\n\tstruct v4l2_fract *tpf = &ival->interval;\n\n\n\ttpf->numerator = 1;\n\ttpf->denominator = 60;\n\n\treturn 0;\n}\n\nstatic int ov7740_s_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *ival)\n{\n\tstruct v4l2_fract *tpf = &ival->interval;\n\n\n\ttpf->numerator = 1;\n\ttpf->denominator = 60;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops ov7740_subdev_video_ops = {\n\t.s_stream = ov7740_set_stream,\n\t.s_frame_interval = ov7740_s_frame_interval,\n\t.g_frame_interval = ov7740_g_frame_interval,\n};\n\nstatic const struct reg_sequence ov7740_format_yuyv[] = {\n\t{0x12, 0x00},\n\t{0x36, 0x3f},\n\t{0x80, 0x7f},\n\t{0x83, 0x01},\n};\n\nstatic const struct reg_sequence ov7740_format_bggr8[] = {\n\t{0x36, 0x2f},\n\t{0x80, 0x01},\n\t{0x83, 0x04},\n};\n\nstatic const struct ov7740_pixfmt ov7740_formats[] = {\n\t{\n\t\t.mbus_code = MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.regs = ov7740_format_yuyv,\n\t\t.reg_num = ARRAY_SIZE(ov7740_format_yuyv),\n\t},\n\t{\n\t\t.mbus_code = MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.regs = ov7740_format_bggr8,\n\t\t.reg_num = ARRAY_SIZE(ov7740_format_bggr8),\n\t}\n};\n#define N_OV7740_FMTS ARRAY_SIZE(ov7740_formats)\n\nstatic int ov7740_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index >= N_OV7740_FMTS)\n\t\treturn -EINVAL;\n\n\tcode->code = ov7740_formats[code->index].mbus_code;\n\n\treturn 0;\n}\n\nstatic int ov7740_enum_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_frame_interval_enum *fie)\n{\n\tif (fie->pad)\n\t\treturn -EINVAL;\n\n\tif (fie->index >= 1)\n\t\treturn -EINVAL;\n\n\tif ((fie->width != VGA_WIDTH) || (fie->height != VGA_HEIGHT))\n\t\treturn -EINVAL;\n\n\tfie->interval.numerator = 1;\n\tfie->interval.denominator = 60;\n\n\treturn 0;\n}\n\nstatic int ov7740_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tif (fse->pad)\n\t\treturn -EINVAL;\n\n\tif (fse->index > 0)\n\t\treturn -EINVAL;\n\n\tfse->min_width = fse->max_width = VGA_WIDTH;\n\tfse->min_height = fse->max_height = VGA_HEIGHT;\n\n\treturn 0;\n}\n\nstatic int ov7740_try_fmt_internal(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_mbus_framefmt *fmt,\n\t\t\t\t   const struct ov7740_pixfmt **ret_fmt,\n\t\t\t\t   const struct ov7740_framesize **ret_frmsize)\n{\n\tstruct ov7740 *ov7740 = container_of(sd, struct ov7740, subdev);\n\tconst struct ov7740_framesize *fsize = &ov7740_framesizes[0];\n\tint index, i;\n\n\tfor (index = 0; index < N_OV7740_FMTS; index++) {\n\t\tif (ov7740_formats[index].mbus_code == fmt->code)\n\t\t\tbreak;\n\t}\n\tif (index >= N_OV7740_FMTS) {\n\t\t \n\t\tindex = 0;\n\t\tfmt->code = ov7740_formats[0].mbus_code;\n\t}\n\tif (ret_fmt != NULL)\n\t\t*ret_fmt = ov7740_formats + index;\n\n\tfor (i = 0; i < ARRAY_SIZE(ov7740_framesizes); i++) {\n\t\tif ((fsize->width >= fmt->width) &&\n\t\t    (fsize->height >= fmt->height)) {\n\t\t\tfmt->width = fsize->width;\n\t\t\tfmt->height = fsize->height;\n\t\t\tbreak;\n\t\t}\n\n\t\tfsize++;\n\t}\n\tif (i >= ARRAY_SIZE(ov7740_framesizes)) {\n\t\tfsize = &ov7740_framesizes[0];\n\t\tfmt->width = fsize->width;\n\t\tfmt->height = fsize->height;\n\t}\n\tif (ret_frmsize != NULL)\n\t\t*ret_frmsize = fsize;\n\n\tfmt->field = V4L2_FIELD_NONE;\n\tfmt->colorspace = ov7740_formats[index].colorspace;\n\n\tov7740->format = *fmt;\n\n\treturn 0;\n}\n\nstatic int ov7740_set_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct ov7740 *ov7740 = container_of(sd, struct ov7740, subdev);\n\tconst struct ov7740_pixfmt *ovfmt;\n\tconst struct ov7740_framesize *fsize;\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\n\tstruct v4l2_mbus_framefmt *mbus_fmt;\n#endif\n\tint ret;\n\n\tmutex_lock(&ov7740->mutex);\n\tif (format->pad) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tret = ov7740_try_fmt_internal(sd, &format->format, NULL, NULL);\n\t\tif (ret)\n\t\t\tgoto error;\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\n\t\tmbus_fmt = v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t\t      format->pad);\n\t\t*mbus_fmt = format->format;\n#endif\n\t\tmutex_unlock(&ov7740->mutex);\n\t\treturn 0;\n\t}\n\n\tret = ov7740_try_fmt_internal(sd, &format->format, &ovfmt, &fsize);\n\tif (ret)\n\t\tgoto error;\n\n\tov7740->fmt = ovfmt;\n\tov7740->frmsize = fsize;\n\n\tmutex_unlock(&ov7740->mutex);\n\treturn 0;\n\nerror:\n\tmutex_unlock(&ov7740->mutex);\n\treturn ret;\n}\n\nstatic int ov7740_get_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct ov7740 *ov7740 = container_of(sd, struct ov7740, subdev);\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\n\tstruct v4l2_mbus_framefmt *mbus_fmt;\n#endif\n\tint ret = 0;\n\n\tmutex_lock(&ov7740->mutex);\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\n\t\tmbus_fmt = v4l2_subdev_get_try_format(sd, sd_state, 0);\n\t\tformat->format = *mbus_fmt;\n\t\tret = 0;\n#else\n\t\tret = -EINVAL;\n#endif\n\t} else {\n\t\tformat->format = ov7740->format;\n\t}\n\tmutex_unlock(&ov7740->mutex);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_pad_ops ov7740_subdev_pad_ops = {\n\t.enum_frame_interval = ov7740_enum_frame_interval,\n\t.enum_frame_size = ov7740_enum_frame_size,\n\t.enum_mbus_code = ov7740_enum_mbus_code,\n\t.get_fmt = ov7740_get_fmt,\n\t.set_fmt = ov7740_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops ov7740_subdev_ops = {\n\t.core\t= &ov7740_subdev_core_ops,\n\t.video\t= &ov7740_subdev_video_ops,\n\t.pad\t= &ov7740_subdev_pad_ops,\n};\n\nstatic void ov7740_get_default_format(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_mbus_framefmt *format)\n{\n\tstruct ov7740 *ov7740 = container_of(sd, struct ov7740, subdev);\n\n\tformat->width = ov7740->frmsize->width;\n\tformat->height = ov7740->frmsize->height;\n\tformat->colorspace = ov7740->fmt->colorspace;\n\tformat->code = ov7740->fmt->mbus_code;\n\tformat->field = V4L2_FIELD_NONE;\n}\n\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\nstatic int ov7740_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct ov7740 *ov7740 = container_of(sd, struct ov7740, subdev);\n\tstruct v4l2_mbus_framefmt *format =\n\t\t\t\tv4l2_subdev_get_try_format(sd, fh->state, 0);\n\n\tmutex_lock(&ov7740->mutex);\n\tov7740_get_default_format(sd, format);\n\tmutex_unlock(&ov7740->mutex);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_internal_ops ov7740_subdev_internal_ops = {\n\t.open = ov7740_open,\n};\n#endif\n\nstatic int ov7740_probe_dt(struct i2c_client *client,\n\t\t\t   struct ov7740 *ov7740)\n{\n\tov7740->resetb_gpio = devm_gpiod_get_optional(&client->dev, \"reset\",\n\t\t\tGPIOD_OUT_HIGH);\n\tif (IS_ERR(ov7740->resetb_gpio)) {\n\t\tdev_info(&client->dev, \"can't get %s GPIO\\n\", \"reset\");\n\t\treturn PTR_ERR(ov7740->resetb_gpio);\n\t}\n\n\tov7740->pwdn_gpio = devm_gpiod_get_optional(&client->dev, \"powerdown\",\n\t\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(ov7740->pwdn_gpio)) {\n\t\tdev_info(&client->dev, \"can't get %s GPIO\\n\", \"powerdown\");\n\t\treturn PTR_ERR(ov7740->pwdn_gpio);\n\t}\n\n\treturn 0;\n}\n\nstatic int ov7740_detect(struct ov7740 *ov7740)\n{\n\tstruct regmap *regmap = ov7740->regmap;\n\tunsigned int midh, midl, pidh, pidl;\n\tint ret;\n\n\tret = regmap_read(regmap, REG_MIDH, &midh);\n\tif (ret)\n\t\treturn ret;\n\tif (midh != 0x7f)\n\t\treturn -ENODEV;\n\n\tret = regmap_read(regmap, REG_MIDL, &midl);\n\tif (ret)\n\t\treturn ret;\n\tif (midl != 0xa2)\n\t\treturn -ENODEV;\n\n\tret = regmap_read(regmap, REG_PIDH, &pidh);\n\tif (ret)\n\t\treturn ret;\n\tif (pidh != 0x77)\n\t\treturn -ENODEV;\n\n\tret = regmap_read(regmap, REG_PIDL, &pidl);\n\tif (ret)\n\t\treturn ret;\n\tif ((pidl != 0x40) && (pidl != 0x41) && (pidl != 0x42))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int ov7740_init_controls(struct ov7740 *ov7740)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&ov7740->subdev);\n\tstruct v4l2_ctrl_handler *ctrl_hdlr = &ov7740->ctrl_handler;\n\tint ret;\n\n\tret = v4l2_ctrl_handler_init(ctrl_hdlr, 12);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tctrl_hdlr->lock = &ov7740->mutex;\n\tov7740->auto_wb = v4l2_ctrl_new_std(ctrl_hdlr, &ov7740_ctrl_ops,\n\t\t\t\t\t  V4L2_CID_AUTO_WHITE_BALANCE,\n\t\t\t\t\t  0, 1, 1, 1);\n\tov7740->blue_balance = v4l2_ctrl_new_std(ctrl_hdlr, &ov7740_ctrl_ops,\n\t\t\t\t\t       V4L2_CID_BLUE_BALANCE,\n\t\t\t\t\t       0, 0xff, 1, 0x80);\n\tov7740->red_balance = v4l2_ctrl_new_std(ctrl_hdlr, &ov7740_ctrl_ops,\n\t\t\t\t\t      V4L2_CID_RED_BALANCE,\n\t\t\t\t\t      0, 0xff, 1, 0x80);\n\n\tov7740->brightness = v4l2_ctrl_new_std(ctrl_hdlr, &ov7740_ctrl_ops,\n\t\t\t\t\t     V4L2_CID_BRIGHTNESS,\n\t\t\t\t\t     -255, 255, 1, 0);\n\tov7740->contrast = v4l2_ctrl_new_std(ctrl_hdlr, &ov7740_ctrl_ops,\n\t\t\t\t\t   V4L2_CID_CONTRAST,\n\t\t\t\t\t   0, 127, 1, 0x20);\n\tov7740->saturation = v4l2_ctrl_new_std(ctrl_hdlr, &ov7740_ctrl_ops,\n\t\t\t  V4L2_CID_SATURATION, 0, 256, 1, 0x80);\n\tov7740->hflip = v4l2_ctrl_new_std(ctrl_hdlr, &ov7740_ctrl_ops,\n\t\t\t\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\tov7740->vflip = v4l2_ctrl_new_std(ctrl_hdlr, &ov7740_ctrl_ops,\n\t\t\t\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\n\tov7740->gain = v4l2_ctrl_new_std(ctrl_hdlr, &ov7740_ctrl_ops,\n\t\t\t\t       V4L2_CID_GAIN, 0, 1023, 1, 500);\n\n\tov7740->auto_gain = v4l2_ctrl_new_std(ctrl_hdlr, &ov7740_ctrl_ops,\n\t\t\t\t\t    V4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\n\tov7740->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &ov7740_ctrl_ops,\n\t\t\t\t\t   V4L2_CID_EXPOSURE, 0, 65535, 1, 500);\n\n\tov7740->auto_exposure = v4l2_ctrl_new_std_menu(ctrl_hdlr,\n\t\t\t\t\t&ov7740_ctrl_ops,\n\t\t\t\t\tV4L2_CID_EXPOSURE_AUTO,\n\t\t\t\t\tV4L2_EXPOSURE_MANUAL, 0,\n\t\t\t\t\tV4L2_EXPOSURE_AUTO);\n\n\tv4l2_ctrl_auto_cluster(3, &ov7740->auto_wb, 0, false);\n\tv4l2_ctrl_auto_cluster(2, &ov7740->auto_gain, 0, true);\n\tv4l2_ctrl_auto_cluster(2, &ov7740->auto_exposure,\n\t\t\t       V4L2_EXPOSURE_MANUAL, true);\n\n\tif (ctrl_hdlr->error) {\n\t\tret = ctrl_hdlr->error;\n\t\tdev_err(&client->dev, \"controls initialisation failed (%d)\\n\",\n\t\t\tret);\n\t\tgoto error;\n\t}\n\n\tret = v4l2_ctrl_handler_setup(ctrl_hdlr);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s control init failed (%d)\\n\",\n\t\t\t__func__, ret);\n\t\tgoto error;\n\t}\n\n\tov7740->subdev.ctrl_handler = ctrl_hdlr;\n\treturn 0;\n\nerror:\n\tv4l2_ctrl_handler_free(ctrl_hdlr);\n\tmutex_destroy(&ov7740->mutex);\n\treturn ret;\n}\n\nstatic void ov7740_free_controls(struct ov7740 *ov7740)\n{\n\tv4l2_ctrl_handler_free(ov7740->subdev.ctrl_handler);\n\tmutex_destroy(&ov7740->mutex);\n}\n\n#define OV7740_MAX_REGISTER     0xff\nstatic const struct regmap_config ov7740_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.max_register\t= OV7740_MAX_REGISTER,\n};\n\nstatic int ov7740_probe(struct i2c_client *client)\n{\n\tstruct ov7740 *ov7740;\n\tstruct v4l2_subdev *sd;\n\tint ret;\n\n\tov7740 = devm_kzalloc(&client->dev, sizeof(*ov7740), GFP_KERNEL);\n\tif (!ov7740)\n\t\treturn -ENOMEM;\n\n\tov7740->xvclk = devm_clk_get(&client->dev, \"xvclk\");\n\tif (IS_ERR(ov7740->xvclk)) {\n\t\tret = PTR_ERR(ov7740->xvclk);\n\t\tdev_err(&client->dev,\n\t\t\t\"OV7740: fail to get xvclk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ov7740_probe_dt(client, ov7740);\n\tif (ret)\n\t\treturn ret;\n\n\tov7740->regmap = devm_regmap_init_sccb(client, &ov7740_regmap_config);\n\tif (IS_ERR(ov7740->regmap)) {\n\t\tret = PTR_ERR(ov7740->regmap);\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tsd = &ov7740->subdev;\n\tv4l2_i2c_subdev_init(sd, client, &ov7740_subdev_ops);\n\n#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API\n\tsd->internal_ops = &ov7740_subdev_internal_ops;\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;\n#endif\n\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tov7740->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tsd->entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tret = media_entity_pads_init(&sd->entity, 1, &ov7740->pad);\n\tif (ret)\n\t\treturn ret;\n#endif\n\n\tret = ov7740_set_power(ov7740, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_set_active(&client->dev);\n\tpm_runtime_enable(&client->dev);\n\n\tret = ov7740_detect(ov7740);\n\tif (ret)\n\t\tgoto error_detect;\n\n\tmutex_init(&ov7740->mutex);\n\n\tret = ov7740_init_controls(ov7740);\n\tif (ret)\n\t\tgoto error_init_controls;\n\n\tv4l_info(client, \"chip found @ 0x%02x (%s)\\n\",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tov7740->fmt = &ov7740_formats[0];\n\tov7740->frmsize = &ov7740_framesizes[0];\n\n\tov7740_get_default_format(sd, &ov7740->format);\n\n\tret = v4l2_async_register_subdev(sd);\n\tif (ret)\n\t\tgoto error_async_register;\n\n\tpm_runtime_idle(&client->dev);\n\n\treturn 0;\n\nerror_async_register:\n\tv4l2_ctrl_handler_free(ov7740->subdev.ctrl_handler);\nerror_init_controls:\n\tov7740_free_controls(ov7740);\nerror_detect:\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\tov7740_set_power(ov7740, 0);\n\tmedia_entity_cleanup(&ov7740->subdev.entity);\n\n\treturn ret;\n}\n\nstatic void ov7740_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov7740 *ov7740 = container_of(sd, struct ov7740, subdev);\n\n\tmutex_destroy(&ov7740->mutex);\n\tv4l2_ctrl_handler_free(ov7740->subdev.ctrl_handler);\n\tmedia_entity_cleanup(&ov7740->subdev.entity);\n\tv4l2_async_unregister_subdev(sd);\n\tov7740_free_controls(ov7740);\n\n\tpm_runtime_get_sync(&client->dev);\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\tpm_runtime_put_noidle(&client->dev);\n\n\tov7740_set_power(ov7740, 0);\n}\n\nstatic int __maybe_unused ov7740_runtime_suspend(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct ov7740 *ov7740 = container_of(sd, struct ov7740, subdev);\n\n\tov7740_set_power(ov7740, 0);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ov7740_runtime_resume(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct ov7740 *ov7740 = container_of(sd, struct ov7740, subdev);\n\n\treturn ov7740_set_power(ov7740, 1);\n}\n\nstatic const struct i2c_device_id ov7740_id[] = {\n\t{ \"ov7740\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, ov7740_id);\n\nstatic const struct dev_pm_ops ov7740_pm_ops = {\n\tSET_RUNTIME_PM_OPS(ov7740_runtime_suspend, ov7740_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id ov7740_of_match[] = {\n\t{.compatible = \"ovti,ov7740\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ov7740_of_match);\n\nstatic struct i2c_driver ov7740_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ov7740\",\n\t\t.pm = &ov7740_pm_ops,\n\t\t.of_match_table = ov7740_of_match,\n\t},\n\t.probe    = ov7740_probe,\n\t.remove   = ov7740_remove,\n\t.id_table = ov7740_id,\n};\nmodule_i2c_driver(ov7740_i2c_driver);\n\nMODULE_DESCRIPTION(\"The V4L2 driver for Omnivision 7740 sensor\");\nMODULE_AUTHOR(\"Songjun Wu <songjun.wu@atmel.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}