{
  "module_name": "adv7183.c",
  "hash_id": "a554901369a5592c0be1d1a40dde244be5119f1baf291af94ea8720da7d90e9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/adv7183.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/videodev2.h>\n\n#include <media/i2c/adv7183.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n\n#include \"adv7183_regs.h\"\n\nstruct adv7183 {\n\tstruct v4l2_subdev sd;\n\tstruct v4l2_ctrl_handler hdl;\n\n\tv4l2_std_id std;  \n\tu32 input;\n\tu32 output;\n\tstruct gpio_desc *reset_pin;\n\tstruct gpio_desc *oe_pin;\n\tstruct v4l2_mbus_framefmt fmt;\n};\n\n \nstatic const unsigned char adv7183_init_regs[] = {\n\tADV7183_IN_CTRL, 0x04,            \n\tADV7183_DIGI_CLAMP_CTRL_1, 0x00,  \n\tADV7183_SHAP_FILT_CTRL, 0x41,     \n\tADV7183_ADC_CTRL, 0x16,           \n\tADV7183_CTI_DNR_CTRL_4, 0x04,     \n\t \n\tADV7183_ADI_CTRL, 0x80,\n\tADV7183_CTI_DNR_CTRL_4, 0x20,\n\t0x52, 0x18,\n\t0x58, 0xED,\n\t0x77, 0xC5,\n\t0x7C, 0x93,\n\t0x7D, 0x00,\n\t0xD0, 0x48,\n\t0xD5, 0xA0,\n\t0xD7, 0xEA,\n\tADV7183_SD_SATURATION_CR, 0x3E,\n\tADV7183_PAL_V_END, 0x3E,\n\tADV7183_PAL_F_TOGGLE, 0x0F,\n\tADV7183_ADI_CTRL, 0x00,\n};\n\nstatic inline struct adv7183 *to_adv7183(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct adv7183, sd);\n}\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct adv7183, hdl)->sd;\n}\n\nstatic inline int adv7183_read(struct v4l2_subdev *sd, unsigned char reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\nstatic inline int adv7183_write(struct v4l2_subdev *sd, unsigned char reg,\n\t\t\t\tunsigned char value)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn i2c_smbus_write_byte_data(client, reg, value);\n}\n\nstatic int adv7183_writeregs(struct v4l2_subdev *sd,\n\t\tconst unsigned char *regs, unsigned int num)\n{\n\tunsigned char reg, data;\n\tunsigned int cnt = 0;\n\n\tif (num & 0x1) {\n\t\tv4l2_err(sd, \"invalid regs array\\n\");\n\t\treturn -1;\n\t}\n\n\twhile (cnt < num) {\n\t\treg = *regs++;\n\t\tdata = *regs++;\n\t\tcnt += 2;\n\n\t\tadv7183_write(sd, reg, data);\n\t}\n\treturn 0;\n}\n\nstatic int adv7183_log_status(struct v4l2_subdev *sd)\n{\n\tstruct adv7183 *decoder = to_adv7183(sd);\n\n\tv4l2_info(sd, \"adv7183: Input control = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_IN_CTRL));\n\tv4l2_info(sd, \"adv7183: Video selection = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_VD_SEL));\n\tv4l2_info(sd, \"adv7183: Output control = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_OUT_CTRL));\n\tv4l2_info(sd, \"adv7183: Extended output control = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_EXT_OUT_CTRL));\n\tv4l2_info(sd, \"adv7183: Autodetect enable = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_AUTO_DET_EN));\n\tv4l2_info(sd, \"adv7183: Contrast = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_CONTRAST));\n\tv4l2_info(sd, \"adv7183: Brightness = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_BRIGHTNESS));\n\tv4l2_info(sd, \"adv7183: Hue = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_HUE));\n\tv4l2_info(sd, \"adv7183: Default value Y = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_DEF_Y));\n\tv4l2_info(sd, \"adv7183: Default value C = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_DEF_C));\n\tv4l2_info(sd, \"adv7183: ADI control = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_ADI_CTRL));\n\tv4l2_info(sd, \"adv7183: Power Management = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_POW_MANAGE));\n\tv4l2_info(sd, \"adv7183: Status 1 2 and 3 = 0x%02x 0x%02x 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_STATUS_1),\n\t\t\tadv7183_read(sd, ADV7183_STATUS_2),\n\t\t\tadv7183_read(sd, ADV7183_STATUS_3));\n\tv4l2_info(sd, \"adv7183: Ident = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_IDENT));\n\tv4l2_info(sd, \"adv7183: Analog clamp control = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_ANAL_CLAMP_CTRL));\n\tv4l2_info(sd, \"adv7183: Digital clamp control 1 = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_DIGI_CLAMP_CTRL_1));\n\tv4l2_info(sd, \"adv7183: Shaping filter control 1 and 2 = 0x%02x 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_SHAP_FILT_CTRL),\n\t\t\tadv7183_read(sd, ADV7183_SHAP_FILT_CTRL_2));\n\tv4l2_info(sd, \"adv7183: Comb filter control = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_COMB_FILT_CTRL));\n\tv4l2_info(sd, \"adv7183: ADI control 2 = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_ADI_CTRL_2));\n\tv4l2_info(sd, \"adv7183: Pixel delay control = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_PIX_DELAY_CTRL));\n\tv4l2_info(sd, \"adv7183: Misc gain control = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_MISC_GAIN_CTRL));\n\tv4l2_info(sd, \"adv7183: AGC mode control = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_AGC_MODE_CTRL));\n\tv4l2_info(sd, \"adv7183: Chroma gain control 1 and 2 = 0x%02x 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_CHRO_GAIN_CTRL_1),\n\t\t\tadv7183_read(sd, ADV7183_CHRO_GAIN_CTRL_2));\n\tv4l2_info(sd, \"adv7183: Luma gain control 1 and 2 = 0x%02x 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_LUMA_GAIN_CTRL_1),\n\t\t\tadv7183_read(sd, ADV7183_LUMA_GAIN_CTRL_2));\n\tv4l2_info(sd, \"adv7183: Vsync field control 1 2 and 3 = 0x%02x 0x%02x 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_VS_FIELD_CTRL_1),\n\t\t\tadv7183_read(sd, ADV7183_VS_FIELD_CTRL_2),\n\t\t\tadv7183_read(sd, ADV7183_VS_FIELD_CTRL_3));\n\tv4l2_info(sd, \"adv7183: Hsync position control 1 2 and 3 = 0x%02x 0x%02x 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_HS_POS_CTRL_1),\n\t\t\tadv7183_read(sd, ADV7183_HS_POS_CTRL_2),\n\t\t\tadv7183_read(sd, ADV7183_HS_POS_CTRL_3));\n\tv4l2_info(sd, \"adv7183: Polarity = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_POLARITY));\n\tv4l2_info(sd, \"adv7183: ADC control = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_ADC_CTRL));\n\tv4l2_info(sd, \"adv7183: SD offset Cb and Cr = 0x%02x 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_SD_OFFSET_CB),\n\t\t\tadv7183_read(sd, ADV7183_SD_OFFSET_CR));\n\tv4l2_info(sd, \"adv7183: SD saturation Cb and Cr = 0x%02x 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_SD_SATURATION_CB),\n\t\t\tadv7183_read(sd, ADV7183_SD_SATURATION_CR));\n\tv4l2_info(sd, \"adv7183: Drive strength = 0x%02x\\n\",\n\t\t\tadv7183_read(sd, ADV7183_DRIVE_STR));\n\tv4l2_ctrl_handler_log_status(&decoder->hdl, sd->name);\n\treturn 0;\n}\n\nstatic int adv7183_g_std(struct v4l2_subdev *sd, v4l2_std_id *std)\n{\n\tstruct adv7183 *decoder = to_adv7183(sd);\n\n\t*std = decoder->std;\n\treturn 0;\n}\n\nstatic int adv7183_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct adv7183 *decoder = to_adv7183(sd);\n\tint reg;\n\n\treg = adv7183_read(sd, ADV7183_IN_CTRL) & 0xF;\n\tif (std == V4L2_STD_PAL_60)\n\t\treg |= 0x60;\n\telse if (std == V4L2_STD_NTSC_443)\n\t\treg |= 0x70;\n\telse if (std == V4L2_STD_PAL_N)\n\t\treg |= 0x90;\n\telse if (std == V4L2_STD_PAL_M)\n\t\treg |= 0xA0;\n\telse if (std == V4L2_STD_PAL_Nc)\n\t\treg |= 0xC0;\n\telse if (std & V4L2_STD_PAL)\n\t\treg |= 0x80;\n\telse if (std & V4L2_STD_NTSC)\n\t\treg |= 0x50;\n\telse if (std & V4L2_STD_SECAM)\n\t\treg |= 0xE0;\n\telse\n\t\treturn -EINVAL;\n\tadv7183_write(sd, ADV7183_IN_CTRL, reg);\n\n\tdecoder->std = std;\n\n\treturn 0;\n}\n\nstatic int adv7183_reset(struct v4l2_subdev *sd, u32 val)\n{\n\tint reg;\n\n\treg = adv7183_read(sd, ADV7183_POW_MANAGE) | 0x80;\n\tadv7183_write(sd, ADV7183_POW_MANAGE, reg);\n\t \n\tusleep_range(5000, 10000);\n\treturn 0;\n}\n\nstatic int adv7183_s_routing(struct v4l2_subdev *sd,\n\t\t\t\tu32 input, u32 output, u32 config)\n{\n\tstruct adv7183 *decoder = to_adv7183(sd);\n\tint reg;\n\n\tif ((input > ADV7183_COMPONENT1) || (output > ADV7183_16BIT_OUT))\n\t\treturn -EINVAL;\n\n\tif (input != decoder->input) {\n\t\tdecoder->input = input;\n\t\treg = adv7183_read(sd, ADV7183_IN_CTRL) & 0xF0;\n\t\tswitch (input) {\n\t\tcase ADV7183_COMPOSITE1:\n\t\t\treg |= 0x1;\n\t\t\tbreak;\n\t\tcase ADV7183_COMPOSITE2:\n\t\t\treg |= 0x2;\n\t\t\tbreak;\n\t\tcase ADV7183_COMPOSITE3:\n\t\t\treg |= 0x3;\n\t\t\tbreak;\n\t\tcase ADV7183_COMPOSITE4:\n\t\t\treg |= 0x4;\n\t\t\tbreak;\n\t\tcase ADV7183_COMPOSITE5:\n\t\t\treg |= 0x5;\n\t\t\tbreak;\n\t\tcase ADV7183_COMPOSITE6:\n\t\t\treg |= 0xB;\n\t\t\tbreak;\n\t\tcase ADV7183_COMPOSITE7:\n\t\t\treg |= 0xC;\n\t\t\tbreak;\n\t\tcase ADV7183_COMPOSITE8:\n\t\t\treg |= 0xD;\n\t\t\tbreak;\n\t\tcase ADV7183_COMPOSITE9:\n\t\t\treg |= 0xE;\n\t\t\tbreak;\n\t\tcase ADV7183_COMPOSITE10:\n\t\t\treg |= 0xF;\n\t\t\tbreak;\n\t\tcase ADV7183_SVIDEO0:\n\t\t\treg |= 0x6;\n\t\t\tbreak;\n\t\tcase ADV7183_SVIDEO1:\n\t\t\treg |= 0x7;\n\t\t\tbreak;\n\t\tcase ADV7183_SVIDEO2:\n\t\t\treg |= 0x8;\n\t\t\tbreak;\n\t\tcase ADV7183_COMPONENT0:\n\t\t\treg |= 0x9;\n\t\t\tbreak;\n\t\tcase ADV7183_COMPONENT1:\n\t\t\treg |= 0xA;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tadv7183_write(sd, ADV7183_IN_CTRL, reg);\n\t}\n\n\tif (output != decoder->output) {\n\t\tdecoder->output = output;\n\t\treg = adv7183_read(sd, ADV7183_OUT_CTRL) & 0xC0;\n\t\tswitch (output) {\n\t\tcase ADV7183_16BIT_OUT:\n\t\t\treg |= 0x9;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treg |= 0xC;\n\t\t\tbreak;\n\t\t}\n\t\tadv7183_write(sd, ADV7183_OUT_CTRL, reg);\n\t}\n\n\treturn 0;\n}\n\nstatic int adv7183_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\tint val = ctrl->val;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tif (val < 0)\n\t\t\tval = 127 - val;\n\t\tadv7183_write(sd, ADV7183_BRIGHTNESS, val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tadv7183_write(sd, ADV7183_CONTRAST, val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tadv7183_write(sd, ADV7183_SD_SATURATION_CB, val >> 8);\n\t\tadv7183_write(sd, ADV7183_SD_SATURATION_CR, (val & 0xFF));\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\tadv7183_write(sd, ADV7183_SD_OFFSET_CB, val >> 8);\n\t\tadv7183_write(sd, ADV7183_SD_OFFSET_CR, (val & 0xFF));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int adv7183_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)\n{\n\tstruct adv7183 *decoder = to_adv7183(sd);\n\tint reg;\n\n\t \n\treg = adv7183_read(sd, ADV7183_IN_CTRL) & 0xF;\n\tadv7183_write(sd, ADV7183_IN_CTRL, reg);\n\n\t \n\tmdelay(10);\n\n\t \n\treg = adv7183_read(sd, ADV7183_STATUS_1);\n\tswitch ((reg >> 0x4) & 0x7) {\n\tcase 0:\n\t\t*std &= V4L2_STD_NTSC;\n\t\tbreak;\n\tcase 1:\n\t\t*std &= V4L2_STD_NTSC_443;\n\t\tbreak;\n\tcase 2:\n\t\t*std &= V4L2_STD_PAL_M;\n\t\tbreak;\n\tcase 3:\n\t\t*std &= V4L2_STD_PAL_60;\n\t\tbreak;\n\tcase 4:\n\t\t*std &= V4L2_STD_PAL;\n\t\tbreak;\n\tcase 5:\n\t\t*std &= V4L2_STD_SECAM;\n\t\tbreak;\n\tcase 6:\n\t\t*std &= V4L2_STD_PAL_Nc;\n\t\tbreak;\n\tcase 7:\n\t\t*std &= V4L2_STD_SECAM;\n\t\tbreak;\n\tdefault:\n\t\t*std = V4L2_STD_UNKNOWN;\n\t\tbreak;\n\t}\n\n\t \n\tadv7183_s_std(sd, decoder->std);\n\treturn 0;\n}\n\nstatic int adv7183_g_input_status(struct v4l2_subdev *sd, u32 *status)\n{\n\tint reg;\n\n\t*status = V4L2_IN_ST_NO_SIGNAL;\n\treg = adv7183_read(sd, ADV7183_STATUS_1);\n\tif (reg < 0)\n\t\treturn reg;\n\tif (reg & 0x1)\n\t\t*status = 0;\n\treturn 0;\n}\n\nstatic int adv7183_enum_mbus_code(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index > 0)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_UYVY8_2X8;\n\treturn 0;\n}\n\nstatic int adv7183_set_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct adv7183 *decoder = to_adv7183(sd);\n\tstruct v4l2_mbus_framefmt *fmt = &format->format;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tfmt->code = MEDIA_BUS_FMT_UYVY8_2X8;\n\tfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tif (decoder->std & V4L2_STD_525_60) {\n\t\tfmt->field = V4L2_FIELD_SEQ_TB;\n\t\tfmt->width = 720;\n\t\tfmt->height = 480;\n\t} else {\n\t\tfmt->field = V4L2_FIELD_SEQ_BT;\n\t\tfmt->width = 720;\n\t\tfmt->height = 576;\n\t}\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\tdecoder->fmt = *fmt;\n\telse\n\t\tsd_state->pads->try_fmt = *fmt;\n\treturn 0;\n}\n\nstatic int adv7183_get_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct adv7183 *decoder = to_adv7183(sd);\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tformat->format = decoder->fmt;\n\treturn 0;\n}\n\nstatic int adv7183_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct adv7183 *decoder = to_adv7183(sd);\n\n\tif (enable)\n\t\tgpiod_set_value(decoder->oe_pin, 1);\n\telse\n\t\tgpiod_set_value(decoder->oe_pin, 0);\n\tudelay(1);\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int adv7183_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\n{\n\treg->val = adv7183_read(sd, reg->reg & 0xff);\n\treg->size = 1;\n\treturn 0;\n}\n\nstatic int adv7183_s_register(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg)\n{\n\tadv7183_write(sd, reg->reg & 0xff, reg->val & 0xff);\n\treturn 0;\n}\n#endif\n\nstatic const struct v4l2_ctrl_ops adv7183_ctrl_ops = {\n\t.s_ctrl = adv7183_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops adv7183_core_ops = {\n\t.log_status = adv7183_log_status,\n\t.reset = adv7183_reset,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = adv7183_g_register,\n\t.s_register = adv7183_s_register,\n#endif\n};\n\nstatic const struct v4l2_subdev_video_ops adv7183_video_ops = {\n\t.g_std = adv7183_g_std,\n\t.s_std = adv7183_s_std,\n\t.s_routing = adv7183_s_routing,\n\t.querystd = adv7183_querystd,\n\t.g_input_status = adv7183_g_input_status,\n\t.s_stream = adv7183_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops adv7183_pad_ops = {\n\t.enum_mbus_code = adv7183_enum_mbus_code,\n\t.get_fmt = adv7183_get_fmt,\n\t.set_fmt = adv7183_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops adv7183_ops = {\n\t.core = &adv7183_core_ops,\n\t.video = &adv7183_video_ops,\n\t.pad = &adv7183_pad_ops,\n};\n\nstatic int adv7183_probe(struct i2c_client *client)\n{\n\tstruct adv7183 *decoder;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_ctrl_handler *hdl;\n\tint ret;\n\tstruct v4l2_subdev_format fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tv4l_info(client, \"chip found @ 0x%02x (%s)\\n\",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tdecoder = devm_kzalloc(&client->dev, sizeof(*decoder), GFP_KERNEL);\n\tif (decoder == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tdecoder->reset_pin = devm_gpiod_get(&client->dev, \"reset\",\n\t\t\t\t\t    GPIOD_OUT_HIGH);\n\tif (IS_ERR(decoder->reset_pin))\n\t\treturn PTR_ERR(decoder->reset_pin);\n\tgpiod_set_consumer_name(decoder->reset_pin, \"ADV7183 Reset\");\n\t \n\tdecoder->oe_pin = devm_gpiod_get(&client->dev, \"oe\",\n\t\t\t\t\t GPIOD_OUT_LOW);\n\tif (IS_ERR(decoder->oe_pin))\n\t\treturn PTR_ERR(decoder->oe_pin);\n\tgpiod_set_consumer_name(decoder->reset_pin, \"ADV7183 Output Enable\");\n\n\tsd = &decoder->sd;\n\tv4l2_i2c_subdev_init(sd, client, &adv7183_ops);\n\n\thdl = &decoder->hdl;\n\tv4l2_ctrl_handler_init(hdl, 4);\n\tv4l2_ctrl_new_std(hdl, &adv7183_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &adv7183_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 0xFF, 1, 0x80);\n\tv4l2_ctrl_new_std(hdl, &adv7183_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 0xFFFF, 1, 0x8080);\n\tv4l2_ctrl_new_std(hdl, &adv7183_ctrl_ops,\n\t\t\tV4L2_CID_HUE, 0, 0xFFFF, 1, 0x8080);\n\t \n\tsd->ctrl_handler = hdl;\n\tif (hdl->error) {\n\t\tret = hdl->error;\n\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\treturn ret;\n\t}\n\n\t \n\tdecoder->std = V4L2_STD_PAL;\n\tdecoder->input = ADV7183_COMPOSITE4;\n\tdecoder->output = ADV7183_8BIT_OUT;\n\n\t \n\t \n\tmdelay(10);\n\t \n\tgpiod_set_value(decoder->reset_pin, 0);\n\t \n\tmdelay(5);\n\n\tadv7183_writeregs(sd, adv7183_init_regs, ARRAY_SIZE(adv7183_init_regs));\n\tadv7183_s_std(sd, decoder->std);\n\tfmt.format.width = 720;\n\tfmt.format.height = 576;\n\tadv7183_set_fmt(sd, NULL, &fmt);\n\n\t \n\tret = v4l2_ctrl_handler_setup(hdl);\n\tif (ret) {\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void adv7183_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\n\tv4l2_device_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(sd->ctrl_handler);\n}\n\nstatic const struct i2c_device_id adv7183_id[] = {\n\t{\"adv7183\", 0},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(i2c, adv7183_id);\n\nstatic struct i2c_driver adv7183_driver = {\n\t.driver = {\n\t\t.name   = \"adv7183\",\n\t},\n\t.probe          = adv7183_probe,\n\t.remove         = adv7183_remove,\n\t.id_table       = adv7183_id,\n};\n\nmodule_i2c_driver(adv7183_driver);\n\nMODULE_DESCRIPTION(\"Analog Devices ADV7183 video decoder driver\");\nMODULE_AUTHOR(\"Scott Jiang <Scott.Jiang.Linux@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}