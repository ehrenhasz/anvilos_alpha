{
  "module_name": "ov5640.c",
  "hash_id": "ebaeea81b7f4fe264a09ab7e3381d0d09052e7cf9b4a685f60d1668c5a34eb8f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ov5640.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <media/v4l2-async.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n \n#define OV5640_XCLK_MIN  6000000\n#define OV5640_XCLK_MAX 54000000\n\n#define OV5640_NATIVE_WIDTH\t\t2624\n#define OV5640_NATIVE_HEIGHT\t\t1964\n#define OV5640_PIXEL_ARRAY_TOP\t\t14\n#define OV5640_PIXEL_ARRAY_LEFT\t\t16\n#define OV5640_PIXEL_ARRAY_WIDTH\t2592\n#define OV5640_PIXEL_ARRAY_HEIGHT\t1944\n\n \n#define OV5640_MIN_VBLANK\t24\n#define OV5640_MAX_VTS\t\t3375\n\n#define OV5640_DEFAULT_SLAVE_ID 0x3c\n\n#define OV5640_LINK_RATE_MAX\t\t490000000U\n\n#define OV5640_REG_SYS_RESET02\t\t0x3002\n#define OV5640_REG_SYS_CLOCK_ENABLE02\t0x3006\n#define OV5640_REG_SYS_CTRL0\t\t0x3008\n#define OV5640_REG_SYS_CTRL0_SW_PWDN\t0x42\n#define OV5640_REG_SYS_CTRL0_SW_PWUP\t0x02\n#define OV5640_REG_SYS_CTRL0_SW_RST\t0x82\n#define OV5640_REG_CHIP_ID\t\t0x300a\n#define OV5640_REG_IO_MIPI_CTRL00\t0x300e\n#define OV5640_REG_PAD_OUTPUT_ENABLE01\t0x3017\n#define OV5640_REG_PAD_OUTPUT_ENABLE02\t0x3018\n#define OV5640_REG_PAD_OUTPUT00\t\t0x3019\n#define OV5640_REG_SYSTEM_CONTROL1\t0x302e\n#define OV5640_REG_SC_PLL_CTRL0\t\t0x3034\n#define OV5640_REG_SC_PLL_CTRL1\t\t0x3035\n#define OV5640_REG_SC_PLL_CTRL2\t\t0x3036\n#define OV5640_REG_SC_PLL_CTRL3\t\t0x3037\n#define OV5640_REG_SLAVE_ID\t\t0x3100\n#define OV5640_REG_SCCB_SYS_CTRL1\t0x3103\n#define OV5640_REG_SYS_ROOT_DIVIDER\t0x3108\n#define OV5640_REG_AWB_R_GAIN\t\t0x3400\n#define OV5640_REG_AWB_G_GAIN\t\t0x3402\n#define OV5640_REG_AWB_B_GAIN\t\t0x3404\n#define OV5640_REG_AWB_MANUAL_CTRL\t0x3406\n#define OV5640_REG_AEC_PK_EXPOSURE_HI\t0x3500\n#define OV5640_REG_AEC_PK_EXPOSURE_MED\t0x3501\n#define OV5640_REG_AEC_PK_EXPOSURE_LO\t0x3502\n#define OV5640_REG_AEC_PK_MANUAL\t0x3503\n#define OV5640_REG_AEC_PK_REAL_GAIN\t0x350a\n#define OV5640_REG_AEC_PK_VTS\t\t0x350c\n#define OV5640_REG_TIMING_HS\t\t0x3800\n#define OV5640_REG_TIMING_VS\t\t0x3802\n#define OV5640_REG_TIMING_HW\t\t0x3804\n#define OV5640_REG_TIMING_VH\t\t0x3806\n#define OV5640_REG_TIMING_DVPHO\t\t0x3808\n#define OV5640_REG_TIMING_DVPVO\t\t0x380a\n#define OV5640_REG_TIMING_HTS\t\t0x380c\n#define OV5640_REG_TIMING_VTS\t\t0x380e\n#define OV5640_REG_TIMING_HOFFS\t\t0x3810\n#define OV5640_REG_TIMING_VOFFS\t\t0x3812\n#define OV5640_REG_TIMING_TC_REG20\t0x3820\n#define OV5640_REG_TIMING_TC_REG21\t0x3821\n#define OV5640_REG_AEC_CTRL00\t\t0x3a00\n#define OV5640_REG_AEC_B50_STEP\t\t0x3a08\n#define OV5640_REG_AEC_B60_STEP\t\t0x3a0a\n#define OV5640_REG_AEC_CTRL0D\t\t0x3a0d\n#define OV5640_REG_AEC_CTRL0E\t\t0x3a0e\n#define OV5640_REG_AEC_CTRL0F\t\t0x3a0f\n#define OV5640_REG_AEC_CTRL10\t\t0x3a10\n#define OV5640_REG_AEC_CTRL11\t\t0x3a11\n#define OV5640_REG_AEC_CTRL1B\t\t0x3a1b\n#define OV5640_REG_AEC_CTRL1E\t\t0x3a1e\n#define OV5640_REG_AEC_CTRL1F\t\t0x3a1f\n#define OV5640_REG_HZ5060_CTRL00\t0x3c00\n#define OV5640_REG_HZ5060_CTRL01\t0x3c01\n#define OV5640_REG_SIGMADELTA_CTRL0C\t0x3c0c\n#define OV5640_REG_FRAME_CTRL01\t\t0x4202\n#define OV5640_REG_FORMAT_CONTROL00\t0x4300\n#define OV5640_REG_VFIFO_HSIZE\t\t0x4602\n#define OV5640_REG_VFIFO_VSIZE\t\t0x4604\n#define OV5640_REG_JPG_MODE_SELECT\t0x4713\n#define OV5640_REG_CCIR656_CTRL00\t0x4730\n#define OV5640_REG_POLARITY_CTRL00\t0x4740\n#define OV5640_REG_MIPI_CTRL00\t\t0x4800\n#define OV5640_REG_DEBUG_MODE\t\t0x4814\n#define OV5640_REG_PCLK_PERIOD\t\t0x4837\n#define OV5640_REG_ISP_FORMAT_MUX_CTRL\t0x501f\n#define OV5640_REG_PRE_ISP_TEST_SET1\t0x503d\n#define OV5640_REG_SDE_CTRL0\t\t0x5580\n#define OV5640_REG_SDE_CTRL1\t\t0x5581\n#define OV5640_REG_SDE_CTRL3\t\t0x5583\n#define OV5640_REG_SDE_CTRL4\t\t0x5584\n#define OV5640_REG_SDE_CTRL5\t\t0x5585\n#define OV5640_REG_AVG_READOUT\t\t0x56a1\n\nenum ov5640_mode_id {\n\tOV5640_MODE_QQVGA_160_120 = 0,\n\tOV5640_MODE_QCIF_176_144,\n\tOV5640_MODE_QVGA_320_240,\n\tOV5640_MODE_VGA_640_480,\n\tOV5640_MODE_NTSC_720_480,\n\tOV5640_MODE_PAL_720_576,\n\tOV5640_MODE_XGA_1024_768,\n\tOV5640_MODE_720P_1280_720,\n\tOV5640_MODE_1080P_1920_1080,\n\tOV5640_MODE_QSXGA_2592_1944,\n\tOV5640_NUM_MODES,\n};\n\nenum ov5640_frame_rate {\n\tOV5640_15_FPS = 0,\n\tOV5640_30_FPS,\n\tOV5640_60_FPS,\n\tOV5640_NUM_FRAMERATES,\n};\n\nenum ov5640_pixel_rate_id {\n\tOV5640_PIXEL_RATE_168M,\n\tOV5640_PIXEL_RATE_148M,\n\tOV5640_PIXEL_RATE_124M,\n\tOV5640_PIXEL_RATE_96M,\n\tOV5640_PIXEL_RATE_48M,\n\tOV5640_NUM_PIXEL_RATES,\n};\n\n \nstatic const u32 ov5640_pixel_rates[] = {\n\t[OV5640_PIXEL_RATE_168M] = 168000000,\n\t[OV5640_PIXEL_RATE_148M] = 148000000,\n\t[OV5640_PIXEL_RATE_124M] = 124000000,\n\t[OV5640_PIXEL_RATE_96M] = 96000000,\n\t[OV5640_PIXEL_RATE_48M] = 48000000,\n};\n\n \nstatic const s64 ov5640_csi2_link_freqs[] = {\n\t992000000, 888000000, 768000000, 744000000, 672000000, 672000000,\n\t592000000, 592000000, 576000000, 576000000, 496000000, 496000000,\n\t384000000, 384000000, 384000000, 336000000, 296000000, 288000000,\n\t248000000, 192000000, 192000000, 192000000, 96000000,\n};\n\n \n#define OV5640_DEFAULT_LINK_FREQ\t13\n\nenum ov5640_format_mux {\n\tOV5640_FMT_MUX_YUV422 = 0,\n\tOV5640_FMT_MUX_RGB,\n\tOV5640_FMT_MUX_DITHER,\n\tOV5640_FMT_MUX_RAW_DPC,\n\tOV5640_FMT_MUX_SNR_RAW,\n\tOV5640_FMT_MUX_RAW_CIP,\n};\n\nstruct ov5640_pixfmt {\n\tu32 code;\n\tu32 colorspace;\n\tu8 bpp;\n\tu8 ctrl00;\n\tenum ov5640_format_mux mux;\n};\n\nstatic const struct ov5640_pixfmt ov5640_dvp_formats[] = {\n\t{\n\t\t \n\t\t.code\t\t= MEDIA_BUS_FMT_JPEG_1X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_JPEG,\n\t\t.bpp\t\t= 16,\n\t\t.ctrl00\t\t= 0x30,\n\t\t.mux\t\t= OV5640_FMT_MUX_YUV422,\n\t}, {\n\t\t \n\t\t.code\t\t= MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.bpp\t\t= 16,\n\t\t.ctrl00\t\t= 0x3f,\n\t\t.mux\t\t= OV5640_FMT_MUX_YUV422,\n\t}, {\n\t\t \n\t\t.code\t\t= MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.bpp\t\t= 16,\n\t\t.ctrl00\t\t= 0x30,\n\t\t.mux\t\t= OV5640_FMT_MUX_YUV422,\n\t}, {\n\t\t \n\t\t.code\t\t= MEDIA_BUS_FMT_RGB565_2X8_LE,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.bpp\t\t= 16,\n\t\t.ctrl00\t\t= 0x6f,\n\t\t.mux\t\t= OV5640_FMT_MUX_RGB,\n\t}, {\n\t\t \n\t\t.code\t\t= MEDIA_BUS_FMT_RGB565_2X8_BE,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.bpp\t\t= 16,\n\t\t.ctrl00\t\t= 0x61,\n\t\t.mux\t\t= OV5640_FMT_MUX_RGB,\n\t}, {\n\t\t \n\t\t.code\t\t= MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.bpp\t\t= 8,\n\t\t.ctrl00\t\t= 0x00,\n\t\t.mux\t\t= OV5640_FMT_MUX_RAW_DPC,\n\t}, {\n\t\t \n\t\t.code\t\t= MEDIA_BUS_FMT_SGBRG8_1X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.bpp\t\t= 8,\n\t\t.ctrl00\t\t= 0x01,\n\t\t.mux\t\t= OV5640_FMT_MUX_RAW_DPC,\n\t}, {\n\t\t \n\t\t.code\t\t= MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.bpp\t\t= 8,\n\t\t.ctrl00\t\t= 0x02,\n\t\t.mux\t\t= OV5640_FMT_MUX_RAW_DPC,\n\t}, {\n\t\t \n\t\t.code\t\t= MEDIA_BUS_FMT_SRGGB8_1X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.bpp\t\t= 8,\n\t\t.ctrl00\t\t= 0x03,\n\t\t.mux\t\t= OV5640_FMT_MUX_RAW_DPC,\n\t},\n\t{   }\n};\n\nstatic const struct ov5640_pixfmt ov5640_csi2_formats[] = {\n\t{\n\t\t \n\t\t.code\t\t= MEDIA_BUS_FMT_JPEG_1X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_JPEG,\n\t\t.bpp\t\t= 16,\n\t\t.ctrl00\t\t= 0x30,\n\t\t.mux\t\t= OV5640_FMT_MUX_YUV422,\n\t}, {\n\t\t \n\t\t.code\t\t= MEDIA_BUS_FMT_UYVY8_1X16,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.bpp\t\t= 16,\n\t\t.ctrl00\t\t= 0x3f,\n\t\t.mux\t\t= OV5640_FMT_MUX_YUV422,\n\t}, {\n\t\t \n\t\t.code\t\t= MEDIA_BUS_FMT_YUYV8_1X16,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.bpp\t\t= 16,\n\t\t.ctrl00\t\t= 0x30,\n\t\t.mux\t\t= OV5640_FMT_MUX_YUV422,\n\t}, {\n\t\t \n\t\t.code\t\t= MEDIA_BUS_FMT_RGB565_1X16,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.bpp\t\t= 16,\n\t\t.ctrl00\t\t= 0x6f,\n\t\t.mux\t\t= OV5640_FMT_MUX_RGB,\n\t}, {\n\t\t \n\t\t.code\t\t= MEDIA_BUS_FMT_BGR888_1X24,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.bpp\t\t= 24,\n\t\t.ctrl00\t\t= 0x23,\n\t\t.mux\t\t= OV5640_FMT_MUX_RGB,\n\t}, {\n\t\t \n\t\t.code\t\t= MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.bpp\t\t= 8,\n\t\t.ctrl00\t\t= 0x00,\n\t\t.mux\t\t= OV5640_FMT_MUX_RAW_DPC,\n\t}, {\n\t\t \n\t\t.code\t\t= MEDIA_BUS_FMT_SGBRG8_1X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.bpp\t\t= 8,\n\t\t.ctrl00\t\t= 0x01,\n\t\t.mux\t\t= OV5640_FMT_MUX_RAW_DPC,\n\t}, {\n\t\t \n\t\t.code\t\t= MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.bpp\t\t= 8,\n\t\t.ctrl00\t\t= 0x02,\n\t\t.mux\t\t= OV5640_FMT_MUX_RAW_DPC,\n\t}, {\n\t\t \n\t\t.code\t\t= MEDIA_BUS_FMT_SRGGB8_1X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.bpp\t\t= 8,\n\t\t.ctrl00\t\t= 0x03,\n\t\t.mux\t\t= OV5640_FMT_MUX_RAW_DPC,\n\t},\n\t{   }\n};\n\n \nstatic unsigned int virtual_channel;\nmodule_param(virtual_channel, uint, 0444);\nMODULE_PARM_DESC(virtual_channel,\n\t\t \"MIPI CSI-2 virtual channel (0..3), default 0\");\n\nstatic const int ov5640_framerates[] = {\n\t[OV5640_15_FPS] = 15,\n\t[OV5640_30_FPS] = 30,\n\t[OV5640_60_FPS] = 60,\n};\n\n \nstatic const char * const ov5640_supply_name[] = {\n\t\"DOVDD\",  \n\t\"AVDD\",   \n\t\"DVDD\",   \n};\n\n#define OV5640_NUM_SUPPLIES ARRAY_SIZE(ov5640_supply_name)\n\n \nenum ov5640_downsize_mode {\n\tSUBSAMPLING,\n\tSCALING,\n};\n\nstruct reg_value {\n\tu16 reg_addr;\n\tu8 val;\n\tu8 mask;\n\tu32 delay_ms;\n};\n\nstruct ov5640_timings {\n\t \n\tstruct v4l2_rect analog_crop;\n\t \n\tstruct v4l2_rect crop;\n\t \n\tu32 htot;\n\t \n\tu32 vblank_def;\n};\n\nstruct ov5640_mode_info {\n\tenum ov5640_mode_id id;\n\tenum ov5640_downsize_mode dn_mode;\n\tenum ov5640_pixel_rate_id pixel_rate;\n\n\tunsigned int width;\n\tunsigned int height;\n\n\tstruct ov5640_timings dvp_timings;\n\tstruct ov5640_timings csi2_timings;\n\n\tconst struct reg_value *reg_data;\n\tu32 reg_data_size;\n\n\t \n\tu32 max_fps;\n\tu32 def_fps;\n};\n\nstruct ov5640_ctrls {\n\tstruct v4l2_ctrl_handler handler;\n\tstruct v4l2_ctrl *pixel_rate;\n\tstruct v4l2_ctrl *link_freq;\n\tstruct v4l2_ctrl *hblank;\n\tstruct v4l2_ctrl *vblank;\n\tstruct {\n\t\tstruct v4l2_ctrl *auto_exp;\n\t\tstruct v4l2_ctrl *exposure;\n\t};\n\tstruct {\n\t\tstruct v4l2_ctrl *auto_wb;\n\t\tstruct v4l2_ctrl *blue_balance;\n\t\tstruct v4l2_ctrl *red_balance;\n\t};\n\tstruct {\n\t\tstruct v4l2_ctrl *auto_gain;\n\t\tstruct v4l2_ctrl *gain;\n\t};\n\tstruct v4l2_ctrl *brightness;\n\tstruct v4l2_ctrl *light_freq;\n\tstruct v4l2_ctrl *saturation;\n\tstruct v4l2_ctrl *contrast;\n\tstruct v4l2_ctrl *hue;\n\tstruct v4l2_ctrl *test_pattern;\n\tstruct v4l2_ctrl *hflip;\n\tstruct v4l2_ctrl *vflip;\n};\n\nstruct ov5640_dev {\n\tstruct i2c_client *i2c_client;\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pad;\n\tstruct v4l2_fwnode_endpoint ep;  \n\tstruct clk *xclk;  \n\tu32 xclk_freq;\n\n\tstruct regulator_bulk_data supplies[OV5640_NUM_SUPPLIES];\n\tstruct gpio_desc *reset_gpio;\n\tstruct gpio_desc *pwdn_gpio;\n\tbool   upside_down;\n\n\t \n\tstruct mutex lock;\n\n\tstruct v4l2_mbus_framefmt fmt;\n\tbool pending_fmt_change;\n\n\tconst struct ov5640_mode_info *current_mode;\n\tconst struct ov5640_mode_info *last_mode;\n\tenum ov5640_frame_rate current_fr;\n\tstruct v4l2_fract frame_interval;\n\ts64 current_link_freq;\n\n\tstruct ov5640_ctrls ctrls;\n\n\tu32 prev_sysclk, prev_hts;\n\tu32 ae_low, ae_high, ae_target;\n\n\tbool pending_mode_change;\n\tbool streaming;\n};\n\nstatic inline struct ov5640_dev *to_ov5640_dev(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct ov5640_dev, sd);\n}\n\nstatic inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct ov5640_dev,\n\t\t\t     ctrls.handler)->sd;\n}\n\nstatic inline bool ov5640_is_csi2(const struct ov5640_dev *sensor)\n{\n\treturn sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY;\n}\n\nstatic inline const struct ov5640_pixfmt *\nov5640_formats(struct ov5640_dev *sensor)\n{\n\treturn ov5640_is_csi2(sensor) ? ov5640_csi2_formats\n\t\t\t\t      : ov5640_dvp_formats;\n}\n\nstatic const struct ov5640_pixfmt *\nov5640_code_to_pixfmt(struct ov5640_dev *sensor, u32 code)\n{\n\tconst struct ov5640_pixfmt *formats = ov5640_formats(sensor);\n\tunsigned int i;\n\n\tfor (i = 0; formats[i].code; ++i) {\n\t\tif (formats[i].code == code)\n\t\t\treturn &formats[i];\n\t}\n\n\treturn &formats[0];\n}\n\nstatic u32 ov5640_code_to_bpp(struct ov5640_dev *sensor, u32 code)\n{\n\tconst struct ov5640_pixfmt *format = ov5640_code_to_pixfmt(sensor,\n\t\t\t\t\t\t\t\t   code);\n\n\treturn format->bpp;\n}\n\n \n \n\nstatic const struct v4l2_mbus_framefmt ov5640_csi2_default_fmt = {\n\t.code = MEDIA_BUS_FMT_UYVY8_1X16,\n\t.width = 640,\n\t.height = 480,\n\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t.ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(V4L2_COLORSPACE_SRGB),\n\t.quantization = V4L2_QUANTIZATION_FULL_RANGE,\n\t.xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(V4L2_COLORSPACE_SRGB),\n\t.field = V4L2_FIELD_NONE,\n};\n\nstatic const struct v4l2_mbus_framefmt ov5640_dvp_default_fmt = {\n\t.code = MEDIA_BUS_FMT_UYVY8_2X8,\n\t.width = 640,\n\t.height = 480,\n\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t.ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(V4L2_COLORSPACE_SRGB),\n\t.quantization = V4L2_QUANTIZATION_FULL_RANGE,\n\t.xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(V4L2_COLORSPACE_SRGB),\n\t.field = V4L2_FIELD_NONE,\n};\n\nstatic const struct reg_value ov5640_init_setting[] = {\n\t{0x3103, 0x11, 0, 0},\n\t{0x3103, 0x03, 0, 0}, {0x3630, 0x36, 0, 0},\n\t{0x3631, 0x0e, 0, 0}, {0x3632, 0xe2, 0, 0}, {0x3633, 0x12, 0, 0},\n\t{0x3621, 0xe0, 0, 0}, {0x3704, 0xa0, 0, 0}, {0x3703, 0x5a, 0, 0},\n\t{0x3715, 0x78, 0, 0}, {0x3717, 0x01, 0, 0}, {0x370b, 0x60, 0, 0},\n\t{0x3705, 0x1a, 0, 0}, {0x3905, 0x02, 0, 0}, {0x3906, 0x10, 0, 0},\n\t{0x3901, 0x0a, 0, 0}, {0x3731, 0x12, 0, 0}, {0x3600, 0x08, 0, 0},\n\t{0x3601, 0x33, 0, 0}, {0x302d, 0x60, 0, 0}, {0x3620, 0x52, 0, 0},\n\t{0x371b, 0x20, 0, 0}, {0x471c, 0x50, 0, 0}, {0x3a13, 0x43, 0, 0},\n\t{0x3a18, 0x00, 0, 0}, {0x3a19, 0xf8, 0, 0}, {0x3635, 0x13, 0, 0},\n\t{0x3636, 0x03, 0, 0}, {0x3634, 0x40, 0, 0}, {0x3622, 0x01, 0, 0},\n\t{0x3c01, 0xa4, 0, 0}, {0x3c04, 0x28, 0, 0}, {0x3c05, 0x98, 0, 0},\n\t{0x3c06, 0x00, 0, 0}, {0x3c07, 0x08, 0, 0}, {0x3c08, 0x00, 0, 0},\n\t{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},\n\t{0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0}, {0x3814, 0x31, 0, 0},\n\t{0x3815, 0x31, 0, 0},\n\t{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x64, 0, 0},\n\t{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},\n\t{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},\n\t{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},\n\t{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},\n\t{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0}, {0x3000, 0x00, 0, 0},\n\t{0x3002, 0x1c, 0, 0}, {0x3004, 0xff, 0, 0}, {0x3006, 0xc3, 0, 0},\n\t{0x302e, 0x08, 0, 0}, {0x4300, 0x3f, 0, 0},\n\t{0x501f, 0x00, 0, 0}, {0x440e, 0x00, 0, 0}, {0x4837, 0x0a, 0, 0},\n\t{0x5000, 0xa7, 0, 0}, {0x5001, 0xa3, 0, 0}, {0x5180, 0xff, 0, 0},\n\t{0x5181, 0xf2, 0, 0}, {0x5182, 0x00, 0, 0}, {0x5183, 0x14, 0, 0},\n\t{0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0}, {0x5186, 0x09, 0, 0},\n\t{0x5187, 0x09, 0, 0}, {0x5188, 0x09, 0, 0}, {0x5189, 0x88, 0, 0},\n\t{0x518a, 0x54, 0, 0}, {0x518b, 0xee, 0, 0}, {0x518c, 0xb2, 0, 0},\n\t{0x518d, 0x50, 0, 0}, {0x518e, 0x34, 0, 0}, {0x518f, 0x6b, 0, 0},\n\t{0x5190, 0x46, 0, 0}, {0x5191, 0xf8, 0, 0}, {0x5192, 0x04, 0, 0},\n\t{0x5193, 0x70, 0, 0}, {0x5194, 0xf0, 0, 0}, {0x5195, 0xf0, 0, 0},\n\t{0x5196, 0x03, 0, 0}, {0x5197, 0x01, 0, 0}, {0x5198, 0x04, 0, 0},\n\t{0x5199, 0x6c, 0, 0}, {0x519a, 0x04, 0, 0}, {0x519b, 0x00, 0, 0},\n\t{0x519c, 0x09, 0, 0}, {0x519d, 0x2b, 0, 0}, {0x519e, 0x38, 0, 0},\n\t{0x5381, 0x1e, 0, 0}, {0x5382, 0x5b, 0, 0}, {0x5383, 0x08, 0, 0},\n\t{0x5384, 0x0a, 0, 0}, {0x5385, 0x7e, 0, 0}, {0x5386, 0x88, 0, 0},\n\t{0x5387, 0x7c, 0, 0}, {0x5388, 0x6c, 0, 0}, {0x5389, 0x10, 0, 0},\n\t{0x538a, 0x01, 0, 0}, {0x538b, 0x98, 0, 0}, {0x5300, 0x08, 0, 0},\n\t{0x5301, 0x30, 0, 0}, {0x5302, 0x10, 0, 0}, {0x5303, 0x00, 0, 0},\n\t{0x5304, 0x08, 0, 0}, {0x5305, 0x30, 0, 0}, {0x5306, 0x08, 0, 0},\n\t{0x5307, 0x16, 0, 0}, {0x5309, 0x08, 0, 0}, {0x530a, 0x30, 0, 0},\n\t{0x530b, 0x04, 0, 0}, {0x530c, 0x06, 0, 0}, {0x5480, 0x01, 0, 0},\n\t{0x5481, 0x08, 0, 0}, {0x5482, 0x14, 0, 0}, {0x5483, 0x28, 0, 0},\n\t{0x5484, 0x51, 0, 0}, {0x5485, 0x65, 0, 0}, {0x5486, 0x71, 0, 0},\n\t{0x5487, 0x7d, 0, 0}, {0x5488, 0x87, 0, 0}, {0x5489, 0x91, 0, 0},\n\t{0x548a, 0x9a, 0, 0}, {0x548b, 0xaa, 0, 0}, {0x548c, 0xb8, 0, 0},\n\t{0x548d, 0xcd, 0, 0}, {0x548e, 0xdd, 0, 0}, {0x548f, 0xea, 0, 0},\n\t{0x5490, 0x1d, 0, 0}, {0x5580, 0x02, 0, 0}, {0x5583, 0x40, 0, 0},\n\t{0x5584, 0x10, 0, 0}, {0x5589, 0x10, 0, 0}, {0x558a, 0x00, 0, 0},\n\t{0x558b, 0xf8, 0, 0}, {0x5800, 0x23, 0, 0}, {0x5801, 0x14, 0, 0},\n\t{0x5802, 0x0f, 0, 0}, {0x5803, 0x0f, 0, 0}, {0x5804, 0x12, 0, 0},\n\t{0x5805, 0x26, 0, 0}, {0x5806, 0x0c, 0, 0}, {0x5807, 0x08, 0, 0},\n\t{0x5808, 0x05, 0, 0}, {0x5809, 0x05, 0, 0}, {0x580a, 0x08, 0, 0},\n\t{0x580b, 0x0d, 0, 0}, {0x580c, 0x08, 0, 0}, {0x580d, 0x03, 0, 0},\n\t{0x580e, 0x00, 0, 0}, {0x580f, 0x00, 0, 0}, {0x5810, 0x03, 0, 0},\n\t{0x5811, 0x09, 0, 0}, {0x5812, 0x07, 0, 0}, {0x5813, 0x03, 0, 0},\n\t{0x5814, 0x00, 0, 0}, {0x5815, 0x01, 0, 0}, {0x5816, 0x03, 0, 0},\n\t{0x5817, 0x08, 0, 0}, {0x5818, 0x0d, 0, 0}, {0x5819, 0x08, 0, 0},\n\t{0x581a, 0x05, 0, 0}, {0x581b, 0x06, 0, 0}, {0x581c, 0x08, 0, 0},\n\t{0x581d, 0x0e, 0, 0}, {0x581e, 0x29, 0, 0}, {0x581f, 0x17, 0, 0},\n\t{0x5820, 0x11, 0, 0}, {0x5821, 0x11, 0, 0}, {0x5822, 0x15, 0, 0},\n\t{0x5823, 0x28, 0, 0}, {0x5824, 0x46, 0, 0}, {0x5825, 0x26, 0, 0},\n\t{0x5826, 0x08, 0, 0}, {0x5827, 0x26, 0, 0}, {0x5828, 0x64, 0, 0},\n\t{0x5829, 0x26, 0, 0}, {0x582a, 0x24, 0, 0}, {0x582b, 0x22, 0, 0},\n\t{0x582c, 0x24, 0, 0}, {0x582d, 0x24, 0, 0}, {0x582e, 0x06, 0, 0},\n\t{0x582f, 0x22, 0, 0}, {0x5830, 0x40, 0, 0}, {0x5831, 0x42, 0, 0},\n\t{0x5832, 0x24, 0, 0}, {0x5833, 0x26, 0, 0}, {0x5834, 0x24, 0, 0},\n\t{0x5835, 0x22, 0, 0}, {0x5836, 0x22, 0, 0}, {0x5837, 0x26, 0, 0},\n\t{0x5838, 0x44, 0, 0}, {0x5839, 0x24, 0, 0}, {0x583a, 0x26, 0, 0},\n\t{0x583b, 0x28, 0, 0}, {0x583c, 0x42, 0, 0}, {0x583d, 0xce, 0, 0},\n\t{0x5025, 0x00, 0, 0}, {0x3a0f, 0x30, 0, 0}, {0x3a10, 0x28, 0, 0},\n\t{0x3a1b, 0x30, 0, 0}, {0x3a1e, 0x26, 0, 0}, {0x3a11, 0x60, 0, 0},\n\t{0x3a1f, 0x14, 0, 0}, {0x3008, 0x02, 0, 0}, {0x3c00, 0x04, 0, 300},\n};\n\nstatic const struct reg_value ov5640_setting_low_res[] = {\n\t{0x3c07, 0x08, 0, 0},\n\t{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},\n\t{0x3814, 0x31, 0, 0},\n\t{0x3815, 0x31, 0, 0},\n\t{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x64, 0, 0},\n\t{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},\n\t{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},\n\t{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},\n\t{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},\n\t{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},\n\t{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},\n\t{0x3824, 0x02, 0, 0}, {0x5001, 0xa3, 0, 0},\n};\n\nstatic const struct reg_value ov5640_setting_720P_1280_720[] = {\n\t{0x3c07, 0x07, 0, 0},\n\t{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},\n\t{0x3814, 0x31, 0, 0},\n\t{0x3815, 0x31, 0, 0},\n\t{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x64, 0, 0},\n\t{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x02, 0, 0},\n\t{0x3a03, 0xe4, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0xbc, 0, 0},\n\t{0x3a0a, 0x01, 0, 0}, {0x3a0b, 0x72, 0, 0}, {0x3a0e, 0x01, 0, 0},\n\t{0x3a0d, 0x02, 0, 0}, {0x3a14, 0x02, 0, 0}, {0x3a15, 0xe4, 0, 0},\n\t{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},\n\t{0x4407, 0x04, 0, 0}, {0x460b, 0x37, 0, 0}, {0x460c, 0x20, 0, 0},\n\t{0x3824, 0x04, 0, 0}, {0x5001, 0x83, 0, 0},\n};\n\nstatic const struct reg_value ov5640_setting_1080P_1920_1080[] = {\n\t{0x3c07, 0x08, 0, 0},\n\t{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},\n\t{0x3814, 0x11, 0, 0},\n\t{0x3815, 0x11, 0, 0},\n\t{0x3618, 0x04, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x21, 0, 0},\n\t{0x3709, 0x12, 0, 0}, {0x370c, 0x00, 0, 0}, {0x3a02, 0x03, 0, 0},\n\t{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},\n\t{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},\n\t{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},\n\t{0x4001, 0x02, 0, 0}, {0x4004, 0x06, 0, 0},\n\t{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},\n\t{0x3824, 0x02, 0, 0}, {0x5001, 0x83, 0, 0},\n\t{0x3c07, 0x07, 0, 0}, {0x3c08, 0x00, 0, 0},\n\t{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},\n\t{0x3612, 0x2b, 0, 0}, {0x3708, 0x64, 0, 0},\n\t{0x3a02, 0x04, 0, 0}, {0x3a03, 0x60, 0, 0}, {0x3a08, 0x01, 0, 0},\n\t{0x3a09, 0x50, 0, 0}, {0x3a0a, 0x01, 0, 0}, {0x3a0b, 0x18, 0, 0},\n\t{0x3a0e, 0x03, 0, 0}, {0x3a0d, 0x04, 0, 0}, {0x3a14, 0x04, 0, 0},\n\t{0x3a15, 0x60, 0, 0}, {0x4407, 0x04, 0, 0},\n\t{0x460b, 0x37, 0, 0}, {0x460c, 0x20, 0, 0}, {0x3824, 0x04, 0, 0},\n\t{0x4005, 0x1a, 0, 0},\n};\n\nstatic const struct reg_value ov5640_setting_QSXGA_2592_1944[] = {\n\t{0x3c07, 0x08, 0, 0},\n\t{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},\n\t{0x3814, 0x11, 0, 0},\n\t{0x3815, 0x11, 0, 0},\n\t{0x3618, 0x04, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x21, 0, 0},\n\t{0x3709, 0x12, 0, 0}, {0x370c, 0x00, 0, 0}, {0x3a02, 0x03, 0, 0},\n\t{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},\n\t{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},\n\t{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},\n\t{0x4001, 0x02, 0, 0}, {0x4004, 0x06, 0, 0},\n\t{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},\n\t{0x3824, 0x02, 0, 0}, {0x5001, 0x83, 0, 70},\n};\n\nstatic const struct ov5640_mode_info ov5640_mode_data[OV5640_NUM_MODES] = {\n\t{\n\t\t \n\t\t.id\t\t= OV5640_MODE_QQVGA_160_120,\n\t\t.dn_mode\t= SUBSAMPLING,\n\t\t.pixel_rate\t= OV5640_PIXEL_RATE_48M,\n\t\t.width\t\t= 160,\n\t\t.height\t\t= 120,\n\t\t.dvp_timings = {\n\t\t\t.analog_crop = {\n\t\t\t\t.left\t= 0,\n\t\t\t\t.top\t= 4,\n\t\t\t\t.width\t= 2624,\n\t\t\t\t.height\t= 1944,\n\t\t\t},\n\t\t\t.crop = {\n\t\t\t\t.left\t= 16,\n\t\t\t\t.top\t= 6,\n\t\t\t\t.width\t= 160,\n\t\t\t\t.height\t= 120,\n\t\t\t},\n\t\t\t.htot\t\t= 1896,\n\t\t\t.vblank_def\t= 864,\n\t\t},\n\t\t.csi2_timings = {\n\t\t\t \n\t\t\t.analog_crop = {\n\t\t\t\t.left\t= OV5640_PIXEL_ARRAY_LEFT,\n\t\t\t\t.top\t= OV5640_PIXEL_ARRAY_TOP,\n\t\t\t\t.width\t= OV5640_PIXEL_ARRAY_WIDTH,\n\t\t\t\t.height\t= OV5640_PIXEL_ARRAY_HEIGHT,\n\t\t\t},\n\t\t\t \n\t\t\t.crop = {\n\t\t\t\t.left\t= 2,\n\t\t\t\t.top\t= 4,\n\t\t\t\t.width\t= 160,\n\t\t\t\t.height\t= 120,\n\t\t\t},\n\t\t\t.htot\t\t= 1600,\n\t\t\t.vblank_def\t= 878,\n\t\t},\n\t\t.reg_data\t= ov5640_setting_low_res,\n\t\t.reg_data_size\t= ARRAY_SIZE(ov5640_setting_low_res),\n\t\t.max_fps\t= OV5640_30_FPS,\n\t\t.def_fps\t= OV5640_30_FPS\n\t}, {\n\t\t \n\t\t.id\t\t= OV5640_MODE_QCIF_176_144,\n\t\t.dn_mode\t= SUBSAMPLING,\n\t\t.pixel_rate\t= OV5640_PIXEL_RATE_48M,\n\t\t.width\t\t= 176,\n\t\t.height\t\t= 144,\n\t\t.dvp_timings = {\n\t\t\t.analog_crop = {\n\t\t\t\t.left\t= 0,\n\t\t\t\t.top\t= 4,\n\t\t\t\t.width\t= 2624,\n\t\t\t\t.height\t= 1944,\n\t\t\t},\n\t\t\t.crop = {\n\t\t\t\t.left\t= 16,\n\t\t\t\t.top\t= 6,\n\t\t\t\t.width\t= 176,\n\t\t\t\t.height\t= 144,\n\t\t\t},\n\t\t\t.htot\t\t= 1896,\n\t\t\t.vblank_def\t= 840,\n\t\t},\n\t\t.csi2_timings = {\n\t\t\t \n\t\t\t.analog_crop = {\n\t\t\t\t.left\t= OV5640_PIXEL_ARRAY_LEFT,\n\t\t\t\t.top\t= OV5640_PIXEL_ARRAY_TOP,\n\t\t\t\t.width\t= OV5640_PIXEL_ARRAY_WIDTH,\n\t\t\t\t.height\t= OV5640_PIXEL_ARRAY_HEIGHT,\n\t\t\t},\n\t\t\t \n\t\t\t.crop = {\n\t\t\t\t.left\t= 2,\n\t\t\t\t.top\t= 4,\n\t\t\t\t.width\t= 176,\n\t\t\t\t.height\t= 144,\n\t\t\t},\n\t\t\t.htot\t\t= 1600,\n\t\t\t.vblank_def\t= 854,\n\t\t},\n\t\t.reg_data\t= ov5640_setting_low_res,\n\t\t.reg_data_size\t= ARRAY_SIZE(ov5640_setting_low_res),\n\t\t.max_fps\t= OV5640_30_FPS,\n\t\t.def_fps\t= OV5640_30_FPS\n\t}, {\n\t\t \n\t\t.id\t\t= OV5640_MODE_QVGA_320_240,\n\t\t.dn_mode\t= SUBSAMPLING,\n\t\t.width\t\t= 320,\n\t\t.height\t\t= 240,\n\t\t.pixel_rate\t= OV5640_PIXEL_RATE_48M,\n\t\t.dvp_timings = {\n\t\t\t.analog_crop = {\n\t\t\t\t.left\t= 0,\n\t\t\t\t.top\t= 4,\n\t\t\t\t.width\t= 2624,\n\t\t\t\t.height\t= 1944,\n\t\t\t},\n\t\t\t.crop = {\n\t\t\t\t.left\t= 16,\n\t\t\t\t.top\t= 6,\n\t\t\t\t.width\t= 320,\n\t\t\t\t.height\t= 240,\n\t\t\t},\n\t\t\t.htot\t\t= 1896,\n\t\t\t.vblank_def\t= 744,\n\t\t},\n\t\t.csi2_timings = {\n\t\t\t \n\t\t\t.analog_crop = {\n\t\t\t\t.left\t= OV5640_PIXEL_ARRAY_LEFT,\n\t\t\t\t.top\t= OV5640_PIXEL_ARRAY_TOP,\n\t\t\t\t.width\t= OV5640_PIXEL_ARRAY_WIDTH,\n\t\t\t\t.height\t= OV5640_PIXEL_ARRAY_HEIGHT,\n\t\t\t},\n\t\t\t \n\t\t\t.crop = {\n\t\t\t\t.left\t= 2,\n\t\t\t\t.top\t= 4,\n\t\t\t\t.width\t= 320,\n\t\t\t\t.height\t= 240,\n\t\t\t},\n\t\t\t.htot\t\t= 1600,\n\t\t\t.vblank_def\t= 760,\n\t\t},\n\t\t.reg_data\t= ov5640_setting_low_res,\n\t\t.reg_data_size\t= ARRAY_SIZE(ov5640_setting_low_res),\n\t\t.max_fps\t= OV5640_30_FPS,\n\t\t.def_fps\t= OV5640_30_FPS\n\t}, {\n\t\t \n\t\t.id\t\t= OV5640_MODE_VGA_640_480,\n\t\t.dn_mode\t= SUBSAMPLING,\n\t\t.pixel_rate\t= OV5640_PIXEL_RATE_48M,\n\t\t.width\t\t= 640,\n\t\t.height\t\t= 480,\n\t\t.dvp_timings = {\n\t\t\t.analog_crop = {\n\t\t\t\t.left\t= 0,\n\t\t\t\t.top\t= 4,\n\t\t\t\t.width\t= 2624,\n\t\t\t\t.height\t= 1944,\n\t\t\t},\n\t\t\t.crop = {\n\t\t\t\t.left\t= 16,\n\t\t\t\t.top\t= 6,\n\t\t\t\t.width\t= 640,\n\t\t\t\t.height\t= 480,\n\t\t\t},\n\t\t\t.htot\t\t= 1896,\n\t\t\t.vblank_def\t= 600,\n\t\t},\n\t\t.csi2_timings = {\n\t\t\t \n\t\t\t.analog_crop = {\n\t\t\t\t.left\t= OV5640_PIXEL_ARRAY_LEFT,\n\t\t\t\t.top\t= OV5640_PIXEL_ARRAY_TOP,\n\t\t\t\t.width\t= OV5640_PIXEL_ARRAY_WIDTH,\n\t\t\t\t.height\t= OV5640_PIXEL_ARRAY_HEIGHT,\n\t\t\t},\n\t\t\t \n\t\t\t.crop = {\n\t\t\t\t.left\t= 2,\n\t\t\t\t.top\t= 4,\n\t\t\t\t.width\t= 640,\n\t\t\t\t.height\t= 480,\n\t\t\t},\n\t\t\t.htot\t\t= 1600,\n\t\t\t.vblank_def\t= 520,\n\t\t},\n\t\t.reg_data\t= ov5640_setting_low_res,\n\t\t.reg_data_size\t= ARRAY_SIZE(ov5640_setting_low_res),\n\t\t.max_fps\t= OV5640_60_FPS,\n\t\t.def_fps\t= OV5640_30_FPS\n\t}, {\n\t\t \n\t\t.id\t\t= OV5640_MODE_NTSC_720_480,\n\t\t.dn_mode\t= SUBSAMPLING,\n\t\t.width\t\t= 720,\n\t\t.height\t\t= 480,\n\t\t.pixel_rate\t= OV5640_PIXEL_RATE_96M,\n\t\t.dvp_timings = {\n\t\t\t.analog_crop = {\n\t\t\t\t.left\t= 0,\n\t\t\t\t.top\t= 4,\n\t\t\t\t.width\t= 2624,\n\t\t\t\t.height\t= 1944,\n\t\t\t},\n\t\t\t.crop = {\n\t\t\t\t.left\t= 56,\n\t\t\t\t.top\t= 60,\n\t\t\t\t.width\t= 720,\n\t\t\t\t.height\t= 480,\n\t\t\t},\n\t\t\t.htot\t\t= 1896,\n\t\t\t.vblank_def\t= 504,\n\t\t},\n\t\t.csi2_timings = {\n\t\t\t \n\t\t\t.analog_crop = {\n\t\t\t\t.left\t= OV5640_PIXEL_ARRAY_LEFT,\n\t\t\t\t.top\t= OV5640_PIXEL_ARRAY_TOP,\n\t\t\t\t.width\t= OV5640_PIXEL_ARRAY_WIDTH,\n\t\t\t\t.height\t= OV5640_PIXEL_ARRAY_HEIGHT,\n\t\t\t},\n\t\t\t.crop = {\n\t\t\t\t.left\t= 56,\n\t\t\t\t.top\t= 60,\n\t\t\t\t.width\t= 720,\n\t\t\t\t.height\t= 480,\n\t\t\t},\n\t\t\t.htot\t\t= 1896,\n\t\t\t.vblank_def\t= 1206,\n\t\t},\n\t\t.reg_data\t= ov5640_setting_low_res,\n\t\t.reg_data_size\t= ARRAY_SIZE(ov5640_setting_low_res),\n\t\t.max_fps\t= OV5640_30_FPS,\n\t\t.def_fps\t= OV5640_30_FPS\n\t}, {\n\t\t \n\t\t.id\t\t= OV5640_MODE_PAL_720_576,\n\t\t.dn_mode\t= SUBSAMPLING,\n\t\t.width\t\t= 720,\n\t\t.height\t\t= 576,\n\t\t.pixel_rate\t= OV5640_PIXEL_RATE_96M,\n\t\t.dvp_timings = {\n\t\t\t.analog_crop = {\n\t\t\t\t.left\t= 0,\n\t\t\t\t.top\t= 4,\n\t\t\t\t.width\t= 2624,\n\t\t\t\t.height\t= 1944,\n\t\t\t},\n\t\t\t.crop = {\n\t\t\t\t.left\t= 56,\n\t\t\t\t.top\t= 6,\n\t\t\t\t.width\t= 720,\n\t\t\t\t.height\t= 576,\n\t\t\t},\n\t\t\t.htot\t\t= 1896,\n\t\t\t.vblank_def\t= 408,\n\t\t},\n\t\t.csi2_timings = {\n\t\t\t \n\t\t\t.analog_crop = {\n\t\t\t\t.left\t= OV5640_PIXEL_ARRAY_LEFT,\n\t\t\t\t.top\t= OV5640_PIXEL_ARRAY_TOP,\n\t\t\t\t.width\t= OV5640_PIXEL_ARRAY_WIDTH,\n\t\t\t\t.height\t= OV5640_PIXEL_ARRAY_HEIGHT,\n\t\t\t},\n\t\t\t.crop = {\n\t\t\t\t.left\t= 56,\n\t\t\t\t.top\t= 6,\n\t\t\t\t.width\t= 720,\n\t\t\t\t.height\t= 576,\n\t\t\t},\n\t\t\t.htot\t\t= 1896,\n\t\t\t.vblank_def\t= 1110,\n\t\t},\n\t\t.reg_data\t= ov5640_setting_low_res,\n\t\t.reg_data_size\t= ARRAY_SIZE(ov5640_setting_low_res),\n\t\t.max_fps\t= OV5640_30_FPS,\n\t\t.def_fps\t= OV5640_30_FPS\n\t}, {\n\t\t \n\t\t.id\t\t= OV5640_MODE_XGA_1024_768,\n\t\t.dn_mode\t= SUBSAMPLING,\n\t\t.pixel_rate\t= OV5640_PIXEL_RATE_96M,\n\t\t.width\t\t= 1024,\n\t\t.height\t\t= 768,\n\t\t.dvp_timings = {\n\t\t\t.analog_crop = {\n\t\t\t\t.left\t= 0,\n\t\t\t\t.top\t= 4,\n\t\t\t\t.width\t= 2624,\n\t\t\t\t.height\t= 1944,\n\t\t\t},\n\t\t\t.crop = {\n\t\t\t\t.left\t= 16,\n\t\t\t\t.top\t= 6,\n\t\t\t\t.width\t= 1024,\n\t\t\t\t.height\t= 768,\n\t\t\t},\n\t\t\t.htot\t\t= 1896,\n\t\t\t.vblank_def\t= 312,\n\t\t},\n\t\t.csi2_timings = {\n\t\t\t.analog_crop = {\n\t\t\t\t.left\t= 0,\n\t\t\t\t.top\t= 4,\n\t\t\t\t.width\t= OV5640_NATIVE_WIDTH,\n\t\t\t\t.height\t= OV5640_PIXEL_ARRAY_HEIGHT,\n\t\t\t},\n\t\t\t.crop = {\n\t\t\t\t.left\t= 16,\n\t\t\t\t.top\t= 6,\n\t\t\t\t.width\t= 1024,\n\t\t\t\t.height\t= 768,\n\t\t\t},\n\t\t\t.htot\t\t= 1896,\n\t\t\t.vblank_def\t= 918,\n\t\t},\n\t\t.reg_data\t= ov5640_setting_low_res,\n\t\t.reg_data_size\t= ARRAY_SIZE(ov5640_setting_low_res),\n\t\t.max_fps\t= OV5640_30_FPS,\n\t\t.def_fps\t= OV5640_30_FPS\n\t}, {\n\t\t \n\t\t.id\t\t= OV5640_MODE_720P_1280_720,\n\t\t.dn_mode\t= SUBSAMPLING,\n\t\t.pixel_rate\t= OV5640_PIXEL_RATE_124M,\n\t\t.width\t\t= 1280,\n\t\t.height\t\t= 720,\n\t\t.dvp_timings = {\n\t\t\t.analog_crop = {\n\t\t\t\t.left\t= 0,\n\t\t\t\t.top\t= 250,\n\t\t\t\t.width\t= 2624,\n\t\t\t\t.height\t= 1456,\n\t\t\t},\n\t\t\t.crop = {\n\t\t\t\t.left\t= 16,\n\t\t\t\t.top\t= 4,\n\t\t\t\t.width\t= 1280,\n\t\t\t\t.height\t= 720,\n\t\t\t},\n\t\t\t.htot\t\t= 1892,\n\t\t\t.vblank_def\t= 20,\n\t\t},\n\t\t.csi2_timings = {\n\t\t\t.analog_crop = {\n\t\t\t\t.left\t= 0,\n\t\t\t\t.top\t= 250,\n\t\t\t\t.width\t= 2624,\n\t\t\t\t.height\t= 1456,\n\t\t\t},\n\t\t\t.crop = {\n\t\t\t\t.left\t= 16,\n\t\t\t\t.top\t= 4,\n\t\t\t\t.width\t= 1280,\n\t\t\t\t.height\t= 720,\n\t\t\t},\n\t\t\t.htot\t\t= 1600,\n\t\t\t.vblank_def\t= 560,\n\t\t},\n\t\t.reg_data\t= ov5640_setting_720P_1280_720,\n\t\t.reg_data_size\t= ARRAY_SIZE(ov5640_setting_720P_1280_720),\n\t\t.max_fps\t= OV5640_30_FPS,\n\t\t.def_fps\t= OV5640_30_FPS\n\t}, {\n\t\t \n\t\t.id\t\t= OV5640_MODE_1080P_1920_1080,\n\t\t.dn_mode\t= SCALING,\n\t\t.pixel_rate\t= OV5640_PIXEL_RATE_148M,\n\t\t.width\t\t= 1920,\n\t\t.height\t\t= 1080,\n\t\t.dvp_timings = {\n\t\t\t.analog_crop = {\n\t\t\t\t.left\t= 336,\n\t\t\t\t.top\t= 434,\n\t\t\t\t.width\t= 1952,\n\t\t\t\t.height\t= 1088,\n\t\t\t},\n\t\t\t.crop = {\n\t\t\t\t.left\t= 16,\n\t\t\t\t.top\t= 4,\n\t\t\t\t.width\t= 1920,\n\t\t\t\t.height\t= 1080,\n\t\t\t},\n\t\t\t.htot\t\t= 2500,\n\t\t\t.vblank_def\t= 40,\n\t\t},\n\t\t.csi2_timings = {\n\t\t\t \n\t\t\t.analog_crop = {\n\t\t\t\t.left\t= 336,\n\t\t\t\t.top\t= 434,\n\t\t\t\t.width\t= 1952,\n\t\t\t\t.height\t= 1088,\n\t\t\t},\n\t\t\t \n\t\t\t.crop = {\n\t\t\t\t.left\t= 16,\n\t\t\t\t.top\t= 4,\n\t\t\t\t.width\t= 1920,\n\t\t\t\t.height\t= 1080,\n\t\t\t},\n\t\t\t.htot\t\t= 2234,\n\t\t\t.vblank_def\t= 24,\n\t\t},\n\t\t.reg_data\t= ov5640_setting_1080P_1920_1080,\n\t\t.reg_data_size\t= ARRAY_SIZE(ov5640_setting_1080P_1920_1080),\n\t\t.max_fps\t= OV5640_30_FPS,\n\t\t.def_fps\t= OV5640_30_FPS\n\t}, {\n\t\t \n\t\t.id\t\t= OV5640_MODE_QSXGA_2592_1944,\n\t\t.dn_mode\t= SCALING,\n\t\t.pixel_rate\t= OV5640_PIXEL_RATE_168M,\n\t\t.width\t\t= OV5640_PIXEL_ARRAY_WIDTH,\n\t\t.height\t\t= OV5640_PIXEL_ARRAY_HEIGHT,\n\t\t.dvp_timings = {\n\t\t\t.analog_crop = {\n\t\t\t\t.left\t= 0,\n\t\t\t\t.top\t= 0,\n\t\t\t\t.width\t= 2624,\n\t\t\t\t.height\t= 1952,\n\t\t\t},\n\t\t\t.crop = {\n\t\t\t\t.left\t= 16,\n\t\t\t\t.top\t= 4,\n\t\t\t\t.width\t= 2592,\n\t\t\t\t.height\t= 1944,\n\t\t\t},\n\t\t\t.htot\t\t= 2844,\n\t\t\t.vblank_def\t= 24,\n\t\t},\n\t\t.csi2_timings = {\n\t\t\t \n\t\t\t.analog_crop = {\n\t\t\t\t.left\t= 0,\n\t\t\t\t.top\t= 0,\n\t\t\t\t.width\t= OV5640_NATIVE_WIDTH,\n\t\t\t\t.height\t= 1952,\n\t\t\t},\n\t\t\t.crop = {\n\t\t\t\t.left\t= 16,\n\t\t\t\t.top\t= 4,\n\t\t\t\t.width\t= 2592,\n\t\t\t\t.height\t= 1944,\n\t\t\t},\n\t\t\t.htot\t\t= 2844,\n\t\t\t.vblank_def\t= 24,\n\t\t},\n\t\t.reg_data\t= ov5640_setting_QSXGA_2592_1944,\n\t\t.reg_data_size\t= ARRAY_SIZE(ov5640_setting_QSXGA_2592_1944),\n\t\t.max_fps\t= OV5640_15_FPS,\n\t\t.def_fps\t= OV5640_15_FPS\n\t},\n};\n\nstatic const struct ov5640_timings *\nov5640_timings(const struct ov5640_dev *sensor,\n\t       const struct ov5640_mode_info *mode)\n{\n\tif (ov5640_is_csi2(sensor))\n\t\treturn &mode->csi2_timings;\n\n\treturn &mode->dvp_timings;\n}\n\nstatic int ov5640_init_slave_id(struct ov5640_dev *sensor)\n{\n\tstruct i2c_client *client = sensor->i2c_client;\n\tstruct i2c_msg msg;\n\tu8 buf[3];\n\tint ret;\n\n\tif (client->addr == OV5640_DEFAULT_SLAVE_ID)\n\t\treturn 0;\n\n\tbuf[0] = OV5640_REG_SLAVE_ID >> 8;\n\tbuf[1] = OV5640_REG_SLAVE_ID & 0xff;\n\tbuf[2] = client->addr << 1;\n\n\tmsg.addr = OV5640_DEFAULT_SLAVE_ID;\n\tmsg.flags = 0;\n\tmsg.buf = buf;\n\tmsg.len = sizeof(buf);\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"%s: failed with %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov5640_write_reg(struct ov5640_dev *sensor, u16 reg, u8 val)\n{\n\tstruct i2c_client *client = sensor->i2c_client;\n\tstruct i2c_msg msg;\n\tu8 buf[3];\n\tint ret;\n\n\tbuf[0] = reg >> 8;\n\tbuf[1] = reg & 0xff;\n\tbuf[2] = val;\n\n\tmsg.addr = client->addr;\n\tmsg.flags = client->flags;\n\tmsg.buf = buf;\n\tmsg.len = sizeof(buf);\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"%s: error: reg=%x, val=%x\\n\",\n\t\t\t__func__, reg, val);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov5640_read_reg(struct ov5640_dev *sensor, u16 reg, u8 *val)\n{\n\tstruct i2c_client *client = sensor->i2c_client;\n\tstruct i2c_msg msg[2];\n\tu8 buf[2];\n\tint ret;\n\n\tbuf[0] = reg >> 8;\n\tbuf[1] = reg & 0xff;\n\n\tmsg[0].addr = client->addr;\n\tmsg[0].flags = client->flags;\n\tmsg[0].buf = buf;\n\tmsg[0].len = sizeof(buf);\n\n\tmsg[1].addr = client->addr;\n\tmsg[1].flags = client->flags | I2C_M_RD;\n\tmsg[1].buf = buf;\n\tmsg[1].len = 1;\n\n\tret = i2c_transfer(client->adapter, msg, 2);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"%s: error: reg=%x\\n\",\n\t\t\t__func__, reg);\n\t\treturn ret;\n\t}\n\n\t*val = buf[0];\n\treturn 0;\n}\n\nstatic int ov5640_read_reg16(struct ov5640_dev *sensor, u16 reg, u16 *val)\n{\n\tu8 hi, lo;\n\tint ret;\n\n\tret = ov5640_read_reg(sensor, reg, &hi);\n\tif (ret)\n\t\treturn ret;\n\tret = ov5640_read_reg(sensor, reg + 1, &lo);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = ((u16)hi << 8) | (u16)lo;\n\treturn 0;\n}\n\nstatic int ov5640_write_reg16(struct ov5640_dev *sensor, u16 reg, u16 val)\n{\n\tint ret;\n\n\tret = ov5640_write_reg(sensor, reg, val >> 8);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov5640_write_reg(sensor, reg + 1, val & 0xff);\n}\n\nstatic int ov5640_mod_reg(struct ov5640_dev *sensor, u16 reg,\n\t\t\t  u8 mask, u8 val)\n{\n\tu8 readval;\n\tint ret;\n\n\tret = ov5640_read_reg(sensor, reg, &readval);\n\tif (ret)\n\t\treturn ret;\n\n\treadval &= ~mask;\n\tval &= mask;\n\tval |= readval;\n\n\treturn ov5640_write_reg(sensor, reg, val);\n}\n\n \n\n \n#define OV5640_PLL_PREDIV\t3\n\n#define OV5640_PLL_MULT_MIN\t4\n#define OV5640_PLL_MULT_MAX\t252\n\n \n#define OV5640_SYSDIV_MIN\t1\n#define OV5640_SYSDIV_MAX\t16\n\n \n#define OV5640_PLL_ROOT_DIV\t\t\t2\n#define OV5640_PLL_CTRL3_PLL_ROOT_DIV_2\t\tBIT(4)\n\n \n#define OV5640_BIT_DIV\t\t\t\t2\n#define OV5640_PLL_CTRL0_MIPI_MODE_8BIT\t\t0x08\n\n \n#define OV5640_SCLK_ROOT_DIV\t2\n\n \n#define OV5640_SCLK2X_ROOT_DIV (OV5640_SCLK_ROOT_DIV / 2)\n\n \n#define OV5640_PCLK_ROOT_DIV\t\t\t1\n#define OV5640_PLL_SYS_ROOT_DIVIDER_BYPASS\t0x00\n\nstatic unsigned long ov5640_compute_sys_clk(struct ov5640_dev *sensor,\n\t\t\t\t\t    u8 pll_prediv, u8 pll_mult,\n\t\t\t\t\t    u8 sysdiv)\n{\n\tunsigned long sysclk = sensor->xclk_freq / pll_prediv * pll_mult;\n\n\t \n\tif (sysclk / 1000000 > 1000)\n\t\treturn 0;\n\n\treturn sysclk / sysdiv;\n}\n\nstatic unsigned long ov5640_calc_sys_clk(struct ov5640_dev *sensor,\n\t\t\t\t\t unsigned long rate,\n\t\t\t\t\t u8 *pll_prediv, u8 *pll_mult,\n\t\t\t\t\t u8 *sysdiv)\n{\n\tunsigned long best = ~0;\n\tu8 best_sysdiv = 1, best_mult = 1;\n\tu8 _sysdiv, _pll_mult;\n\n\tfor (_sysdiv = OV5640_SYSDIV_MIN;\n\t     _sysdiv <= OV5640_SYSDIV_MAX;\n\t     _sysdiv++) {\n\t\tfor (_pll_mult = OV5640_PLL_MULT_MIN;\n\t\t     _pll_mult <= OV5640_PLL_MULT_MAX;\n\t\t     _pll_mult++) {\n\t\t\tunsigned long _rate;\n\n\t\t\t \n\t\t\tif (_pll_mult > 127 && (_pll_mult % 2))\n\t\t\t\tcontinue;\n\n\t\t\t_rate = ov5640_compute_sys_clk(sensor,\n\t\t\t\t\t\t       OV5640_PLL_PREDIV,\n\t\t\t\t\t\t       _pll_mult, _sysdiv);\n\n\t\t\t \n\t\t\tif (!_rate)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (_rate < rate)\n\t\t\t\tcontinue;\n\n\t\t\tif (abs(rate - _rate) < abs(rate - best)) {\n\t\t\t\tbest = _rate;\n\t\t\t\tbest_sysdiv = _sysdiv;\n\t\t\t\tbest_mult = _pll_mult;\n\t\t\t}\n\n\t\t\tif (_rate == rate)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\t*sysdiv = best_sysdiv;\n\t*pll_prediv = OV5640_PLL_PREDIV;\n\t*pll_mult = best_mult;\n\n\treturn best;\n}\n\n \nstatic int ov5640_set_mipi_pclk(struct ov5640_dev *sensor)\n{\n\tu8 bit_div, mipi_div, pclk_div, sclk_div, sclk2x_div, root_div;\n\tu8 prediv, mult, sysdiv;\n\tunsigned long link_freq;\n\tunsigned long sysclk;\n\tu8 pclk_period;\n\tu32 sample_rate;\n\tu32 num_lanes;\n\tint ret;\n\n\t \n\tlink_freq = sensor->current_link_freq;\n\n\t \n\tif (link_freq > OV5640_LINK_RATE_MAX)\n\t\tmipi_div = 1;\n\telse\n\t\tmipi_div = 2;\n\n\tsysclk = link_freq * mipi_div;\n\tov5640_calc_sys_clk(sensor, sysclk, &prediv, &mult, &sysdiv);\n\n\t \n\troot_div = OV5640_PLL_CTRL3_PLL_ROOT_DIV_2;\n\tbit_div =  OV5640_PLL_CTRL0_MIPI_MODE_8BIT;\n\tpclk_div = ilog2(OV5640_PCLK_ROOT_DIV);\n\n\t \n\tsclk_div = ilog2(OV5640_SCLK_ROOT_DIV);\n\tsclk2x_div = ilog2(OV5640_SCLK2X_ROOT_DIV);\n\n\t \n\tnum_lanes = sensor->ep.bus.mipi_csi2.num_data_lanes;\n\tsample_rate = (link_freq * mipi_div * num_lanes * 2) / 16;\n\tpclk_period = 2000000000UL / sample_rate;\n\n\t \n\tret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL0, 0x0f, bit_div);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL1, 0xff,\n\t\t\t     (sysdiv << 4) | mipi_div);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL2, 0xff, mult);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL3, 0x1f,\n\t\t\t     root_div | prediv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5640_mod_reg(sensor, OV5640_REG_SYS_ROOT_DIVIDER, 0x3f,\n\t\t\t     (pclk_div << 4) | (sclk2x_div << 2) | sclk_div);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov5640_write_reg(sensor, OV5640_REG_PCLK_PERIOD, pclk_period);\n}\n\nstatic u32 ov5640_calc_pixel_rate(struct ov5640_dev *sensor)\n{\n\tconst struct ov5640_mode_info *mode = sensor->current_mode;\n\tconst struct ov5640_timings *timings = &mode->dvp_timings;\n\tu32 rate;\n\n\trate = timings->htot * (timings->crop.height + timings->vblank_def);\n\trate *= ov5640_framerates[sensor->current_fr];\n\n\treturn rate;\n}\n\nstatic unsigned long ov5640_calc_pclk(struct ov5640_dev *sensor,\n\t\t\t\t      unsigned long rate,\n\t\t\t\t      u8 *pll_prediv, u8 *pll_mult, u8 *sysdiv,\n\t\t\t\t      u8 *pll_rdiv, u8 *bit_div, u8 *pclk_div)\n{\n\tunsigned long _rate = rate * OV5640_PLL_ROOT_DIV * OV5640_BIT_DIV *\n\t\t\t\tOV5640_PCLK_ROOT_DIV;\n\n\t_rate = ov5640_calc_sys_clk(sensor, _rate, pll_prediv, pll_mult,\n\t\t\t\t    sysdiv);\n\t*pll_rdiv = OV5640_PLL_ROOT_DIV;\n\t*bit_div = OV5640_BIT_DIV;\n\t*pclk_div = OV5640_PCLK_ROOT_DIV;\n\n\treturn _rate / *pll_rdiv / *bit_div / *pclk_div;\n}\n\nstatic int ov5640_set_dvp_pclk(struct ov5640_dev *sensor)\n{\n\tu8 prediv, mult, sysdiv, pll_rdiv, bit_div, pclk_div;\n\tu32 rate;\n\tint ret;\n\n\trate = ov5640_calc_pixel_rate(sensor);\n\trate *= ov5640_code_to_bpp(sensor, sensor->fmt.code);\n\trate /= sensor->ep.bus.parallel.bus_width;\n\n\tov5640_calc_pclk(sensor, rate, &prediv, &mult, &sysdiv, &pll_rdiv,\n\t\t\t &bit_div, &pclk_div);\n\n\tif (bit_div == 2)\n\t\tbit_div = 8;\n\n\tret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL0,\n\t\t\t     0x0f, bit_div);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL1,\n\t\t\t     0xff, sysdiv << 4);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL2,\n\t\t\t     0xff, mult);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL3,\n\t\t\t     0x1f, prediv | ((pll_rdiv - 1) << 4));\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov5640_mod_reg(sensor, OV5640_REG_SYS_ROOT_DIVIDER, 0x30,\n\t\t\t      (ilog2(pclk_div) << 4));\n}\n\n \nstatic int ov5640_set_jpeg_timings(struct ov5640_dev *sensor,\n\t\t\t\t   const struct ov5640_mode_info *mode)\n{\n\tint ret;\n\n\t \n\tret = ov5640_mod_reg(sensor, OV5640_REG_JPG_MODE_SELECT, 0x7, 0x3);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov5640_write_reg16(sensor, OV5640_REG_VFIFO_HSIZE, mode->width);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ov5640_write_reg16(sensor, OV5640_REG_VFIFO_VSIZE, mode->height);\n}\n\n \nstatic int ov5640_set_timings(struct ov5640_dev *sensor,\n\t\t\t      const struct ov5640_mode_info *mode)\n{\n\tconst struct ov5640_timings *timings;\n\tconst struct v4l2_rect *analog_crop;\n\tconst struct v4l2_rect *crop;\n\tint ret;\n\n\tif (sensor->fmt.code == MEDIA_BUS_FMT_JPEG_1X8) {\n\t\tret = ov5640_set_jpeg_timings(sensor, mode);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\ttimings = ov5640_timings(sensor, mode);\n\tanalog_crop = &timings->analog_crop;\n\tcrop = &timings->crop;\n\n\tret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_HS,\n\t\t\t\t analog_crop->left);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_VS,\n\t\t\t\t analog_crop->top);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_HW,\n\t\t\t\t analog_crop->left + analog_crop->width - 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_VH,\n\t\t\t\t analog_crop->top + analog_crop->height - 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_HOFFS, crop->left);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_VOFFS, crop->top);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_DVPHO, mode->width);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_DVPVO, mode->height);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_HTS, timings->htot);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_VTS,\n\t\t\t\t mode->height + timings->vblank_def);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void ov5640_load_regs(struct ov5640_dev *sensor,\n\t\t\t     const struct reg_value *regs, unsigned int regnum)\n{\n\tunsigned int i;\n\tu32 delay_ms;\n\tu16 reg_addr;\n\tu8 mask, val;\n\tint ret = 0;\n\n\tfor (i = 0; i < regnum; ++i, ++regs) {\n\t\tdelay_ms = regs->delay_ms;\n\t\treg_addr = regs->reg_addr;\n\t\tval = regs->val;\n\t\tmask = regs->mask;\n\n\t\t \n\t\tif (regs->reg_addr == OV5640_REG_SYS_CTRL0 &&\n\t\t    val == OV5640_REG_SYS_CTRL0_SW_PWUP &&\n\t\t    !ov5640_is_csi2(sensor))\n\t\t\tcontinue;\n\n\t\tif (mask)\n\t\t\tret = ov5640_mod_reg(sensor, reg_addr, mask, val);\n\t\telse\n\t\t\tret = ov5640_write_reg(sensor, reg_addr, val);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (delay_ms)\n\t\t\tusleep_range(1000 * delay_ms, 1000 * delay_ms + 100);\n\t}\n}\n\nstatic int ov5640_set_autoexposure(struct ov5640_dev *sensor, bool on)\n{\n\treturn ov5640_mod_reg(sensor, OV5640_REG_AEC_PK_MANUAL,\n\t\t\t      BIT(0), on ? 0 : BIT(0));\n}\n\n \nstatic int ov5640_get_exposure(struct ov5640_dev *sensor)\n{\n\tint exp, ret;\n\tu8 temp;\n\n\tret = ov5640_read_reg(sensor, OV5640_REG_AEC_PK_EXPOSURE_HI, &temp);\n\tif (ret)\n\t\treturn ret;\n\texp = ((int)temp & 0x0f) << 16;\n\tret = ov5640_read_reg(sensor, OV5640_REG_AEC_PK_EXPOSURE_MED, &temp);\n\tif (ret)\n\t\treturn ret;\n\texp |= ((int)temp << 8);\n\tret = ov5640_read_reg(sensor, OV5640_REG_AEC_PK_EXPOSURE_LO, &temp);\n\tif (ret)\n\t\treturn ret;\n\texp |= (int)temp;\n\n\treturn exp >> 4;\n}\n\n \nstatic int ov5640_set_exposure(struct ov5640_dev *sensor, u32 exposure)\n{\n\tint ret;\n\n\texposure <<= 4;\n\n\tret = ov5640_write_reg(sensor,\n\t\t\t       OV5640_REG_AEC_PK_EXPOSURE_LO,\n\t\t\t       exposure & 0xff);\n\tif (ret)\n\t\treturn ret;\n\tret = ov5640_write_reg(sensor,\n\t\t\t       OV5640_REG_AEC_PK_EXPOSURE_MED,\n\t\t\t       (exposure >> 8) & 0xff);\n\tif (ret)\n\t\treturn ret;\n\treturn ov5640_write_reg(sensor,\n\t\t\t\tOV5640_REG_AEC_PK_EXPOSURE_HI,\n\t\t\t\t(exposure >> 16) & 0x0f);\n}\n\nstatic int ov5640_get_gain(struct ov5640_dev *sensor)\n{\n\tu16 gain;\n\tint ret;\n\n\tret = ov5640_read_reg16(sensor, OV5640_REG_AEC_PK_REAL_GAIN, &gain);\n\tif (ret)\n\t\treturn ret;\n\n\treturn gain & 0x3ff;\n}\n\nstatic int ov5640_set_gain(struct ov5640_dev *sensor, int gain)\n{\n\treturn ov5640_write_reg16(sensor, OV5640_REG_AEC_PK_REAL_GAIN,\n\t\t\t\t  (u16)gain & 0x3ff);\n}\n\nstatic int ov5640_set_autogain(struct ov5640_dev *sensor, bool on)\n{\n\treturn ov5640_mod_reg(sensor, OV5640_REG_AEC_PK_MANUAL,\n\t\t\t      BIT(1), on ? 0 : BIT(1));\n}\n\nstatic int ov5640_set_stream_dvp(struct ov5640_dev *sensor, bool on)\n{\n\treturn ov5640_write_reg(sensor, OV5640_REG_SYS_CTRL0, on ?\n\t\t\t\tOV5640_REG_SYS_CTRL0_SW_PWUP :\n\t\t\t\tOV5640_REG_SYS_CTRL0_SW_PWDN);\n}\n\nstatic int ov5640_set_stream_mipi(struct ov5640_dev *sensor, bool on)\n{\n\tint ret;\n\n\t \n\tret = ov5640_write_reg(sensor, OV5640_REG_IO_MIPI_CTRL00,\n\t\t\t       on ? 0x45 : 0x40);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov5640_write_reg(sensor, OV5640_REG_FRAME_CTRL01,\n\t\t\t\ton ? 0x00 : 0x0f);\n}\n\nstatic int ov5640_get_sysclk(struct ov5640_dev *sensor)\n{\n\t  \n\tu32 xvclk = sensor->xclk_freq / 10000;\n\tu32 multiplier, prediv, VCO, sysdiv, pll_rdiv;\n\tu32 sclk_rdiv_map[] = {1, 2, 4, 8};\n\tu32 bit_div2x = 1, sclk_rdiv, sysclk;\n\tu8 temp1, temp2;\n\tint ret;\n\n\tret = ov5640_read_reg(sensor, OV5640_REG_SC_PLL_CTRL0, &temp1);\n\tif (ret)\n\t\treturn ret;\n\ttemp2 = temp1 & 0x0f;\n\tif (temp2 == 8 || temp2 == 10)\n\t\tbit_div2x = temp2 / 2;\n\n\tret = ov5640_read_reg(sensor, OV5640_REG_SC_PLL_CTRL1, &temp1);\n\tif (ret)\n\t\treturn ret;\n\tsysdiv = temp1 >> 4;\n\tif (sysdiv == 0)\n\t\tsysdiv = 16;\n\n\tret = ov5640_read_reg(sensor, OV5640_REG_SC_PLL_CTRL2, &temp1);\n\tif (ret)\n\t\treturn ret;\n\tmultiplier = temp1;\n\n\tret = ov5640_read_reg(sensor, OV5640_REG_SC_PLL_CTRL3, &temp1);\n\tif (ret)\n\t\treturn ret;\n\tprediv = temp1 & 0x0f;\n\tpll_rdiv = ((temp1 >> 4) & 0x01) + 1;\n\n\tret = ov5640_read_reg(sensor, OV5640_REG_SYS_ROOT_DIVIDER, &temp1);\n\tif (ret)\n\t\treturn ret;\n\ttemp2 = temp1 & 0x03;\n\tsclk_rdiv = sclk_rdiv_map[temp2];\n\n\tif (!prediv || !sysdiv || !pll_rdiv || !bit_div2x)\n\t\treturn -EINVAL;\n\n\tVCO = xvclk * multiplier / prediv;\n\n\tsysclk = VCO / sysdiv / pll_rdiv * 2 / bit_div2x / sclk_rdiv;\n\n\treturn sysclk;\n}\n\nstatic int ov5640_set_night_mode(struct ov5640_dev *sensor)\n{\n\t  \n\tu8 mode;\n\tint ret;\n\n\tret = ov5640_read_reg(sensor, OV5640_REG_AEC_CTRL00, &mode);\n\tif (ret)\n\t\treturn ret;\n\tmode &= 0xfb;\n\treturn ov5640_write_reg(sensor, OV5640_REG_AEC_CTRL00, mode);\n}\n\nstatic int ov5640_get_hts(struct ov5640_dev *sensor)\n{\n\t \n\tu16 hts;\n\tint ret;\n\n\tret = ov5640_read_reg16(sensor, OV5640_REG_TIMING_HTS, &hts);\n\tif (ret)\n\t\treturn ret;\n\treturn hts;\n}\n\nstatic int ov5640_get_vts(struct ov5640_dev *sensor)\n{\n\tu16 vts;\n\tint ret;\n\n\tret = ov5640_read_reg16(sensor, OV5640_REG_TIMING_VTS, &vts);\n\tif (ret)\n\t\treturn ret;\n\treturn vts;\n}\n\nstatic int ov5640_set_vts(struct ov5640_dev *sensor, int vts)\n{\n\treturn ov5640_write_reg16(sensor, OV5640_REG_TIMING_VTS, vts);\n}\n\nstatic int ov5640_get_light_freq(struct ov5640_dev *sensor)\n{\n\t \n\tint ret, light_freq = 0;\n\tu8 temp, temp1;\n\n\tret = ov5640_read_reg(sensor, OV5640_REG_HZ5060_CTRL01, &temp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (temp & 0x80) {\n\t\t \n\t\tret = ov5640_read_reg(sensor, OV5640_REG_HZ5060_CTRL00,\n\t\t\t\t      &temp1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (temp1 & 0x04) {\n\t\t\t \n\t\t\tlight_freq = 50;\n\t\t} else {\n\t\t\t \n\t\t\tlight_freq = 60;\n\t\t}\n\t} else {\n\t\t \n\t\tret = ov5640_read_reg(sensor, OV5640_REG_SIGMADELTA_CTRL0C,\n\t\t\t\t      &temp1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (temp1 & 0x01) {\n\t\t\t \n\t\t\tlight_freq = 50;\n\t\t} else {\n\t\t\t \n\t\t}\n\t}\n\n\treturn light_freq;\n}\n\nstatic int ov5640_set_bandingfilter(struct ov5640_dev *sensor)\n{\n\tu32 band_step60, max_band60, band_step50, max_band50, prev_vts;\n\tint ret;\n\n\t \n\tret = ov5640_get_sysclk(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0)\n\t\treturn -EINVAL;\n\tsensor->prev_sysclk = ret;\n\t \n\tret = ov5640_get_hts(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0)\n\t\treturn -EINVAL;\n\tsensor->prev_hts = ret;\n\n\t \n\tret = ov5640_get_vts(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\tprev_vts = ret;\n\n\t \n\t \n\tband_step60 = sensor->prev_sysclk * 100 / sensor->prev_hts * 100 / 120;\n\tret = ov5640_write_reg16(sensor, OV5640_REG_AEC_B60_STEP, band_step60);\n\tif (ret)\n\t\treturn ret;\n\tif (!band_step60)\n\t\treturn -EINVAL;\n\tmax_band60 = (int)((prev_vts - 4) / band_step60);\n\tret = ov5640_write_reg(sensor, OV5640_REG_AEC_CTRL0D, max_band60);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tband_step50 = sensor->prev_sysclk * 100 / sensor->prev_hts;\n\tret = ov5640_write_reg16(sensor, OV5640_REG_AEC_B50_STEP, band_step50);\n\tif (ret)\n\t\treturn ret;\n\tif (!band_step50)\n\t\treturn -EINVAL;\n\tmax_band50 = (int)((prev_vts - 4) / band_step50);\n\treturn ov5640_write_reg(sensor, OV5640_REG_AEC_CTRL0E, max_band50);\n}\n\nstatic int ov5640_set_ae_target(struct ov5640_dev *sensor, int target)\n{\n\t \n\tu32 fast_high, fast_low;\n\tint ret;\n\n\tsensor->ae_low = target * 23 / 25;\t \n\tsensor->ae_high = target * 27 / 25;\t \n\n\tfast_high = sensor->ae_high << 1;\n\tif (fast_high > 255)\n\t\tfast_high = 255;\n\n\tfast_low = sensor->ae_low >> 1;\n\n\tret = ov5640_write_reg(sensor, OV5640_REG_AEC_CTRL0F, sensor->ae_high);\n\tif (ret)\n\t\treturn ret;\n\tret = ov5640_write_reg(sensor, OV5640_REG_AEC_CTRL10, sensor->ae_low);\n\tif (ret)\n\t\treturn ret;\n\tret = ov5640_write_reg(sensor, OV5640_REG_AEC_CTRL1B, sensor->ae_high);\n\tif (ret)\n\t\treturn ret;\n\tret = ov5640_write_reg(sensor, OV5640_REG_AEC_CTRL1E, sensor->ae_low);\n\tif (ret)\n\t\treturn ret;\n\tret = ov5640_write_reg(sensor, OV5640_REG_AEC_CTRL11, fast_high);\n\tif (ret)\n\t\treturn ret;\n\treturn ov5640_write_reg(sensor, OV5640_REG_AEC_CTRL1F, fast_low);\n}\n\nstatic int ov5640_get_binning(struct ov5640_dev *sensor)\n{\n\tu8 temp;\n\tint ret;\n\n\tret = ov5640_read_reg(sensor, OV5640_REG_TIMING_TC_REG21, &temp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn temp & BIT(0);\n}\n\nstatic int ov5640_set_binning(struct ov5640_dev *sensor, bool enable)\n{\n\tint ret;\n\n\t \n\tret = ov5640_mod_reg(sensor, OV5640_REG_TIMING_TC_REG21,\n\t\t\t     BIT(0), enable ? BIT(0) : 0);\n\tif (ret)\n\t\treturn ret;\n\t \n\treturn ov5640_mod_reg(sensor, OV5640_REG_TIMING_TC_REG20,\n\t\t\t      BIT(0), enable ? BIT(0) : 0);\n}\n\nstatic int ov5640_set_virtual_channel(struct ov5640_dev *sensor)\n{\n\tstruct i2c_client *client = sensor->i2c_client;\n\tu8 temp, channel = virtual_channel;\n\tint ret;\n\n\tif (channel > 3) {\n\t\tdev_err(&client->dev,\n\t\t\t\"%s: wrong virtual_channel parameter, expected (0..3), got %d\\n\",\n\t\t\t__func__, channel);\n\t\treturn -EINVAL;\n\t}\n\n\tret = ov5640_read_reg(sensor, OV5640_REG_DEBUG_MODE, &temp);\n\tif (ret)\n\t\treturn ret;\n\ttemp &= ~(3 << 6);\n\ttemp |= (channel << 6);\n\treturn ov5640_write_reg(sensor, OV5640_REG_DEBUG_MODE, temp);\n}\n\nstatic const struct ov5640_mode_info *\nov5640_find_mode(struct ov5640_dev *sensor, int width, int height, bool nearest)\n{\n\tconst struct ov5640_mode_info *mode;\n\n\tmode = v4l2_find_nearest_size(ov5640_mode_data,\n\t\t\t\t      ARRAY_SIZE(ov5640_mode_data),\n\t\t\t\t      width, height, width, height);\n\n\tif (!mode ||\n\t    (!nearest &&\n\t     (mode->width != width || mode->height != height)))\n\t\treturn NULL;\n\n\treturn mode;\n}\n\n \nstatic int ov5640_set_mode_exposure_calc(struct ov5640_dev *sensor,\n\t\t\t\t\t const struct ov5640_mode_info *mode)\n{\n\tu32 prev_shutter, prev_gain16;\n\tu32 cap_shutter, cap_gain16;\n\tu32 cap_sysclk, cap_hts, cap_vts;\n\tu32 light_freq, cap_bandfilt, cap_maxband;\n\tu32 cap_gain16_shutter;\n\tu8 average;\n\tint ret;\n\n\tif (!mode->reg_data)\n\t\treturn -EINVAL;\n\n\t \n\tret = ov5640_get_exposure(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\tprev_shutter = ret;\n\tret = ov5640_get_binning(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret && mode->id != OV5640_MODE_720P_1280_720 &&\n\t    mode->id != OV5640_MODE_1080P_1920_1080)\n\t\tprev_shutter *= 2;\n\n\t \n\tret = ov5640_get_gain(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\tprev_gain16 = ret;\n\n\t \n\tret = ov5640_read_reg(sensor, OV5640_REG_AVG_READOUT, &average);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov5640_set_night_mode(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tov5640_load_regs(sensor, mode->reg_data, mode->reg_data_size);\n\tret = ov5640_set_timings(sensor, mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ov5640_get_vts(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\tcap_vts = ret;\n\tret = ov5640_get_hts(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0)\n\t\treturn -EINVAL;\n\tcap_hts = ret;\n\n\tret = ov5640_get_sysclk(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0)\n\t\treturn -EINVAL;\n\tcap_sysclk = ret;\n\n\t \n\tret = ov5640_get_light_freq(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\tlight_freq = ret;\n\n\tif (light_freq == 60) {\n\t\t \n\t\tcap_bandfilt = cap_sysclk * 100 / cap_hts * 100 / 120;\n\t} else {\n\t\t \n\t\tcap_bandfilt = cap_sysclk * 100 / cap_hts;\n\t}\n\n\tif (!sensor->prev_sysclk) {\n\t\tret = ov5640_get_sysclk(sensor);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 0)\n\t\t\treturn -EINVAL;\n\t\tsensor->prev_sysclk = ret;\n\t}\n\n\tif (!cap_bandfilt)\n\t\treturn -EINVAL;\n\n\tcap_maxband = (int)((cap_vts - 4) / cap_bandfilt);\n\n\t \n\tif (average > sensor->ae_low && average < sensor->ae_high) {\n\t\t \n\t\tcap_gain16_shutter =\n\t\t\tprev_gain16 * prev_shutter *\n\t\t\tcap_sysclk / sensor->prev_sysclk *\n\t\t\tsensor->prev_hts / cap_hts *\n\t\t\tsensor->ae_target / average;\n\t} else {\n\t\tcap_gain16_shutter =\n\t\t\tprev_gain16 * prev_shutter *\n\t\t\tcap_sysclk / sensor->prev_sysclk *\n\t\t\tsensor->prev_hts / cap_hts;\n\t}\n\n\t \n\tif (cap_gain16_shutter < (cap_bandfilt * 16)) {\n\t\t \n\t\tcap_shutter = cap_gain16_shutter / 16;\n\t\tif (cap_shutter < 1)\n\t\t\tcap_shutter = 1;\n\n\t\tcap_gain16 = cap_gain16_shutter / cap_shutter;\n\t\tif (cap_gain16 < 16)\n\t\t\tcap_gain16 = 16;\n\t} else {\n\t\tif (cap_gain16_shutter > (cap_bandfilt * cap_maxband * 16)) {\n\t\t\t \n\t\t\tcap_shutter = cap_bandfilt * cap_maxband;\n\t\t\tif (!cap_shutter)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcap_gain16 = cap_gain16_shutter / cap_shutter;\n\t\t} else {\n\t\t\t \n\t\t\tcap_shutter =\n\t\t\t\t((int)(cap_gain16_shutter / 16 / cap_bandfilt))\n\t\t\t\t* cap_bandfilt;\n\t\t\tif (!cap_shutter)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcap_gain16 = cap_gain16_shutter / cap_shutter;\n\t\t}\n\t}\n\n\t \n\tret = ov5640_set_gain(sensor, cap_gain16);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (cap_shutter > (cap_vts - 4)) {\n\t\tcap_vts = cap_shutter + 4;\n\t\tret = ov5640_set_vts(sensor, cap_vts);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\treturn ov5640_set_exposure(sensor, cap_shutter);\n}\n\n \nstatic int ov5640_set_mode_direct(struct ov5640_dev *sensor,\n\t\t\t\t  const struct ov5640_mode_info *mode)\n{\n\tif (!mode->reg_data)\n\t\treturn -EINVAL;\n\n\t \n\tov5640_load_regs(sensor, mode->reg_data, mode->reg_data_size);\n\treturn ov5640_set_timings(sensor, mode);\n}\n\nstatic int ov5640_set_mode(struct ov5640_dev *sensor)\n{\n\tconst struct ov5640_mode_info *mode = sensor->current_mode;\n\tconst struct ov5640_mode_info *orig_mode = sensor->last_mode;\n\tenum ov5640_downsize_mode dn_mode, orig_dn_mode;\n\tbool auto_gain = sensor->ctrls.auto_gain->val == 1;\n\tbool auto_exp =  sensor->ctrls.auto_exp->val == V4L2_EXPOSURE_AUTO;\n\tint ret;\n\n\tdn_mode = mode->dn_mode;\n\torig_dn_mode = orig_mode->dn_mode;\n\n\t \n\tif (auto_gain) {\n\t\tret = ov5640_set_autogain(sensor, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (auto_exp) {\n\t\tret = ov5640_set_autoexposure(sensor, false);\n\t\tif (ret)\n\t\t\tgoto restore_auto_gain;\n\t}\n\n\tif (ov5640_is_csi2(sensor))\n\t\tret = ov5640_set_mipi_pclk(sensor);\n\telse\n\t\tret = ov5640_set_dvp_pclk(sensor);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tif ((dn_mode == SUBSAMPLING && orig_dn_mode == SCALING) ||\n\t    (dn_mode == SCALING && orig_dn_mode == SUBSAMPLING)) {\n\t\t \n\t\tret = ov5640_set_mode_exposure_calc(sensor, mode);\n\t} else {\n\t\t \n\t\tret = ov5640_set_mode_direct(sensor, mode);\n\t}\n\tif (ret < 0)\n\t\tgoto restore_auto_exp_gain;\n\n\t \n\tif (auto_gain)\n\t\tov5640_set_autogain(sensor, true);\n\tif (auto_exp)\n\t\tov5640_set_autoexposure(sensor, true);\n\n\tret = ov5640_set_binning(sensor, dn_mode != SCALING);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = ov5640_set_ae_target(sensor, sensor->ae_target);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = ov5640_get_light_freq(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = ov5640_set_bandingfilter(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = ov5640_set_virtual_channel(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsensor->pending_mode_change = false;\n\tsensor->last_mode = mode;\n\n\treturn 0;\n\nrestore_auto_exp_gain:\n\tif (auto_exp)\n\t\tov5640_set_autoexposure(sensor, true);\nrestore_auto_gain:\n\tif (auto_gain)\n\t\tov5640_set_autogain(sensor, true);\n\n\treturn ret;\n}\n\nstatic int ov5640_set_framefmt(struct ov5640_dev *sensor,\n\t\t\t       struct v4l2_mbus_framefmt *format);\n\n \nstatic int ov5640_restore_mode(struct ov5640_dev *sensor)\n{\n\tint ret;\n\n\t \n\tov5640_load_regs(sensor, ov5640_init_setting,\n\t\t\t ARRAY_SIZE(ov5640_init_setting));\n\n\tret = ov5640_mod_reg(sensor, OV5640_REG_SYS_ROOT_DIVIDER, 0x3f,\n\t\t\t     (ilog2(OV5640_SCLK2X_ROOT_DIV) << 2) |\n\t\t\t     ilog2(OV5640_SCLK_ROOT_DIV));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov5640_set_mode(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ov5640_set_framefmt(sensor, &sensor->fmt);\n}\n\nstatic void ov5640_power(struct ov5640_dev *sensor, bool enable)\n{\n\tgpiod_set_value_cansleep(sensor->pwdn_gpio, enable ? 0 : 1);\n}\n\n \nstatic void ov5640_powerup_sequence(struct ov5640_dev *sensor)\n{\n\tif (sensor->pwdn_gpio) {\n\t\tgpiod_set_value_cansleep(sensor->reset_gpio, 1);\n\n\t\t \n\t\tov5640_power(sensor, false);\n\t\tusleep_range(5000, 10000);\t \n\t\tov5640_power(sensor, true);\n\t\tusleep_range(1000, 2000);\t \n\n\t\tgpiod_set_value_cansleep(sensor->reset_gpio, 0);\n\t} else {\n\t\t \n\t\tov5640_write_reg(sensor, OV5640_REG_SYS_CTRL0,\n\t\t\t\t OV5640_REG_SYS_CTRL0_SW_RST);\n\t}\n\tusleep_range(20000, 25000);\t \n\n\t \n\tov5640_write_reg(sensor, OV5640_REG_SYS_CTRL0,\n\t\t\t OV5640_REG_SYS_CTRL0_SW_PWDN);\n}\n\nstatic int ov5640_set_power_on(struct ov5640_dev *sensor)\n{\n\tstruct i2c_client *client = sensor->i2c_client;\n\tint ret;\n\n\tret = clk_prepare_enable(sensor->xclk);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s: failed to enable clock\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(OV5640_NUM_SUPPLIES,\n\t\t\t\t    sensor->supplies);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s: failed to enable regulators\\n\",\n\t\t\t__func__);\n\t\tgoto xclk_off;\n\t}\n\n\tov5640_powerup_sequence(sensor);\n\n\tret = ov5640_init_slave_id(sensor);\n\tif (ret)\n\t\tgoto power_off;\n\n\treturn 0;\n\npower_off:\n\tov5640_power(sensor, false);\n\tregulator_bulk_disable(OV5640_NUM_SUPPLIES, sensor->supplies);\nxclk_off:\n\tclk_disable_unprepare(sensor->xclk);\n\treturn ret;\n}\n\nstatic void ov5640_set_power_off(struct ov5640_dev *sensor)\n{\n\tov5640_power(sensor, false);\n\tregulator_bulk_disable(OV5640_NUM_SUPPLIES, sensor->supplies);\n\tclk_disable_unprepare(sensor->xclk);\n}\n\nstatic int ov5640_set_power_mipi(struct ov5640_dev *sensor, bool on)\n{\n\tint ret;\n\n\tif (!on) {\n\t\t \n\t\tov5640_write_reg(sensor, OV5640_REG_IO_MIPI_CTRL00, 0x58);\n\t\tov5640_write_reg(sensor, OV5640_REG_MIPI_CTRL00, 0x04);\n\t\tov5640_write_reg(sensor, OV5640_REG_PAD_OUTPUT00, 0x00);\n\t\treturn 0;\n\t}\n\n\t \n\tret = ov5640_write_reg(sensor, OV5640_REG_IO_MIPI_CTRL00, 0x44);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov5640_write_reg(sensor, OV5640_REG_MIPI_CTRL00, 0x24);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov5640_write_reg(sensor, OV5640_REG_PAD_OUTPUT00, 0x70);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(500, 1000);\n\n\treturn 0;\n}\n\nstatic int ov5640_set_power_dvp(struct ov5640_dev *sensor, bool on)\n{\n\tunsigned int flags = sensor->ep.bus.parallel.flags;\n\tbool bt656 = sensor->ep.bus_type == V4L2_MBUS_BT656;\n\tu8 polarities = 0;\n\tint ret;\n\n\tif (!on) {\n\t\t \n\t\tov5640_write_reg(sensor, OV5640_REG_CCIR656_CTRL00, 0x00);\n\t\tov5640_write_reg(sensor, OV5640_REG_IO_MIPI_CTRL00, 0x58);\n\t\tov5640_write_reg(sensor, OV5640_REG_POLARITY_CTRL00, 0x20);\n\t\tov5640_write_reg(sensor, OV5640_REG_PAD_OUTPUT_ENABLE01, 0x00);\n\t\tov5640_write_reg(sensor, OV5640_REG_PAD_OUTPUT_ENABLE02, 0x00);\n\t\treturn 0;\n\t}\n\n\t \n\n\t \n\tret = ov5640_write_reg(sensor, OV5640_REG_CCIR656_CTRL00,\n\t\t\t       bt656 ? 0x01 : 0x00);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!bt656) {\n\t\tif (flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)\n\t\t\tpolarities |= BIT(1);\n\t\tif (flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\n\t\t\tpolarities |= BIT(0);\n\t}\n\tif (flags & V4L2_MBUS_PCLK_SAMPLE_RISING)\n\t\tpolarities |= BIT(5);\n\n\tret = ov5640_write_reg(sensor, OV5640_REG_POLARITY_CTRL00, polarities);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov5640_write_reg(sensor, OV5640_REG_IO_MIPI_CTRL00, 0x18);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov5640_write_reg(sensor, OV5640_REG_PAD_OUTPUT_ENABLE01,\n\t\t\t       bt656 ? 0x1f : 0x7f);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn ov5640_write_reg(sensor, OV5640_REG_PAD_OUTPUT_ENABLE02, 0xfc);\n}\n\nstatic int ov5640_set_power(struct ov5640_dev *sensor, bool on)\n{\n\tint ret = 0;\n\n\tif (on) {\n\t\tret = ov5640_set_power_on(sensor);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ov5640_restore_mode(sensor);\n\t\tif (ret)\n\t\t\tgoto power_off;\n\t}\n\n\tif (sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY)\n\t\tret = ov5640_set_power_mipi(sensor, on);\n\telse\n\t\tret = ov5640_set_power_dvp(sensor, on);\n\tif (ret)\n\t\tgoto power_off;\n\n\tif (!on)\n\t\tov5640_set_power_off(sensor);\n\n\treturn 0;\n\npower_off:\n\tov5640_set_power_off(sensor);\n\treturn ret;\n}\n\nstatic int ov5640_sensor_suspend(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct ov5640_dev *ov5640 = to_ov5640_dev(sd);\n\n\treturn ov5640_set_power(ov5640, false);\n}\n\nstatic int ov5640_sensor_resume(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct ov5640_dev *ov5640 = to_ov5640_dev(sd);\n\n\treturn ov5640_set_power(ov5640, true);\n}\n\n \n\nstatic int ov5640_try_frame_interval(struct ov5640_dev *sensor,\n\t\t\t\t     struct v4l2_fract *fi,\n\t\t\t\t     const struct ov5640_mode_info *mode_info)\n{\n\tconst struct ov5640_mode_info *mode = mode_info;\n\tenum ov5640_frame_rate rate = OV5640_15_FPS;\n\tint minfps, maxfps, best_fps, fps;\n\tint i;\n\n\tminfps = ov5640_framerates[OV5640_15_FPS];\n\tmaxfps = ov5640_framerates[mode->max_fps];\n\n\tif (fi->numerator == 0) {\n\t\tfi->denominator = maxfps;\n\t\tfi->numerator = 1;\n\t\trate = mode->max_fps;\n\t\tgoto find_mode;\n\t}\n\n\tfps = clamp_val(DIV_ROUND_CLOSEST(fi->denominator, fi->numerator),\n\t\t\tminfps, maxfps);\n\n\tbest_fps = minfps;\n\tfor (i = 0; i < ARRAY_SIZE(ov5640_framerates); i++) {\n\t\tint curr_fps = ov5640_framerates[i];\n\n\t\tif (abs(curr_fps - fps) < abs(best_fps - fps)) {\n\t\t\tbest_fps = curr_fps;\n\t\t\trate = i;\n\t\t}\n\t}\n\n\tfi->numerator = 1;\n\tfi->denominator = best_fps;\n\nfind_mode:\n\tmode = ov5640_find_mode(sensor, mode->width, mode->height, false);\n\treturn mode ? rate : -EINVAL;\n}\n\nstatic int ov5640_get_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct ov5640_dev *sensor = to_ov5640_dev(sd);\n\tstruct v4l2_mbus_framefmt *fmt;\n\n\tif (format->pad != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sensor->lock);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\tfmt = v4l2_subdev_get_try_format(&sensor->sd, sd_state,\n\t\t\t\t\t\t format->pad);\n\telse\n\t\tfmt = &sensor->fmt;\n\n\tformat->format = *fmt;\n\n\tmutex_unlock(&sensor->lock);\n\n\treturn 0;\n}\n\nstatic int ov5640_try_fmt_internal(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_mbus_framefmt *fmt,\n\t\t\t\t   const struct ov5640_mode_info **new_mode)\n{\n\tstruct ov5640_dev *sensor = to_ov5640_dev(sd);\n\tconst struct ov5640_mode_info *mode;\n\tconst struct ov5640_pixfmt *pixfmt;\n\tunsigned int bpp;\n\n\tmode = ov5640_find_mode(sensor, fmt->width, fmt->height, true);\n\tif (!mode)\n\t\treturn -EINVAL;\n\n\tpixfmt = ov5640_code_to_pixfmt(sensor, fmt->code);\n\tbpp = pixfmt->bpp;\n\n\t \n\tif (bpp == 8 && mode->width < 1280)\n\t\tmode = &ov5640_mode_data[OV5640_MODE_720P_1280_720];\n\telse if (bpp == 24 && mode->width > 1024)\n\t\tmode = &ov5640_mode_data[OV5640_MODE_XGA_1024_768];\n\n\tfmt->width = mode->width;\n\tfmt->height = mode->height;\n\n\tif (new_mode)\n\t\t*new_mode = mode;\n\n\tfmt->code = pixfmt->code;\n\tfmt->colorspace = pixfmt->colorspace;\n\tfmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);\n\tfmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\tfmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);\n\n\treturn 0;\n}\n\nstatic void __v4l2_ctrl_vblank_update(struct ov5640_dev *sensor, u32 vblank)\n{\n\tconst struct ov5640_mode_info *mode = sensor->current_mode;\n\n\t__v4l2_ctrl_modify_range(sensor->ctrls.vblank, OV5640_MIN_VBLANK,\n\t\t\t\t OV5640_MAX_VTS - mode->height, 1, vblank);\n\n\t__v4l2_ctrl_s_ctrl(sensor->ctrls.vblank, vblank);\n}\n\nstatic int ov5640_update_pixel_rate(struct ov5640_dev *sensor)\n{\n\tconst struct ov5640_mode_info *mode = sensor->current_mode;\n\tenum ov5640_pixel_rate_id pixel_rate_id = mode->pixel_rate;\n\tstruct v4l2_mbus_framefmt *fmt = &sensor->fmt;\n\tconst struct ov5640_timings *timings = ov5640_timings(sensor, mode);\n\ts32 exposure_val, exposure_max;\n\tunsigned int hblank;\n\tunsigned int i = 0;\n\tu32 pixel_rate;\n\ts64 link_freq;\n\tu32 num_lanes;\n\tu32 vblank;\n\tu32 bpp;\n\n\t \n\tif (!ov5640_is_csi2(sensor)) {\n\t\t__v4l2_ctrl_s_ctrl_int64(sensor->ctrls.pixel_rate,\n\t\t\t\t\t ov5640_calc_pixel_rate(sensor));\n\n\t\t__v4l2_ctrl_vblank_update(sensor, timings->vblank_def);\n\n\t\treturn 0;\n\t}\n\n\t \n\tnum_lanes = sensor->ep.bus.mipi_csi2.num_data_lanes;\n\tbpp = ov5640_code_to_bpp(sensor, fmt->code);\n\tdo {\n\t\tpixel_rate = ov5640_pixel_rates[pixel_rate_id];\n\t\tlink_freq = pixel_rate * bpp / (2 * num_lanes);\n\t} while (link_freq >= 1000000000U &&\n\t\t ++pixel_rate_id < OV5640_NUM_PIXEL_RATES);\n\n\tsensor->current_link_freq = link_freq;\n\n\t \n\tif (link_freq > OV5640_LINK_RATE_MAX) {\n\t\tpixel_rate /= 2;\n\t\tlink_freq /= 2;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(ov5640_csi2_link_freqs); ++i) {\n\t\tif (ov5640_csi2_link_freqs[i] == link_freq)\n\t\t\tbreak;\n\t}\n\tWARN_ON(i == ARRAY_SIZE(ov5640_csi2_link_freqs));\n\n\t__v4l2_ctrl_s_ctrl_int64(sensor->ctrls.pixel_rate, pixel_rate);\n\t__v4l2_ctrl_s_ctrl(sensor->ctrls.link_freq, i);\n\n\thblank = timings->htot - mode->width;\n\t__v4l2_ctrl_modify_range(sensor->ctrls.hblank,\n\t\t\t\t hblank, hblank, 1, hblank);\n\n\tvblank = timings->vblank_def;\n\t__v4l2_ctrl_vblank_update(sensor, vblank);\n\n\texposure_max = timings->crop.height + vblank - 4;\n\texposure_val = clamp_t(s32, sensor->ctrls.exposure->val,\n\t\t\t       sensor->ctrls.exposure->minimum,\n\t\t\t       exposure_max);\n\n\t__v4l2_ctrl_modify_range(sensor->ctrls.exposure,\n\t\t\t\t sensor->ctrls.exposure->minimum,\n\t\t\t\t exposure_max, 1, exposure_val);\n\n\treturn 0;\n}\n\nstatic int ov5640_set_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct ov5640_dev *sensor = to_ov5640_dev(sd);\n\tconst struct ov5640_mode_info *new_mode;\n\tstruct v4l2_mbus_framefmt *mbus_fmt = &format->format;\n\tint ret;\n\n\tif (format->pad != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sensor->lock);\n\n\tif (sensor->streaming) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = ov5640_try_fmt_internal(sd, mbus_fmt, &new_mode);\n\tif (ret)\n\t\tgoto out;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\t*v4l2_subdev_get_try_format(sd, sd_state, 0) = *mbus_fmt;\n\t\tgoto out;\n\t}\n\n\tif (new_mode != sensor->current_mode) {\n\t\tsensor->current_fr = new_mode->def_fps;\n\t\tsensor->current_mode = new_mode;\n\t\tsensor->pending_mode_change = true;\n\t}\n\tif (mbus_fmt->code != sensor->fmt.code)\n\t\tsensor->pending_fmt_change = true;\n\n\t \n\tsensor->fmt = *mbus_fmt;\n\n\tov5640_update_pixel_rate(sensor);\n\nout:\n\tmutex_unlock(&sensor->lock);\n\treturn ret;\n}\n\nstatic int ov5640_get_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct ov5640_dev *sensor = to_ov5640_dev(sd);\n\tconst struct ov5640_mode_info *mode = sensor->current_mode;\n\tconst struct ov5640_timings *timings;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP: {\n\t\tmutex_lock(&sensor->lock);\n\t\ttimings = ov5640_timings(sensor, mode);\n\t\tsel->r = timings->analog_crop;\n\t\tmutex_unlock(&sensor->lock);\n\n\t\treturn 0;\n\t}\n\n\tcase V4L2_SEL_TGT_NATIVE_SIZE:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.top = 0;\n\t\tsel->r.left = 0;\n\t\tsel->r.width = OV5640_NATIVE_WIDTH;\n\t\tsel->r.height = OV5640_NATIVE_HEIGHT;\n\n\t\treturn 0;\n\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tsel->r.top = OV5640_PIXEL_ARRAY_TOP;\n\t\tsel->r.left = OV5640_PIXEL_ARRAY_LEFT;\n\t\tsel->r.width = OV5640_PIXEL_ARRAY_WIDTH;\n\t\tsel->r.height = OV5640_PIXEL_ARRAY_HEIGHT;\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ov5640_set_framefmt(struct ov5640_dev *sensor,\n\t\t\t       struct v4l2_mbus_framefmt *format)\n{\n\tbool is_jpeg = format->code == MEDIA_BUS_FMT_JPEG_1X8;\n\tconst struct ov5640_pixfmt *pixfmt;\n\tint ret = 0;\n\n\tpixfmt = ov5640_code_to_pixfmt(sensor, format->code);\n\n\t \n\tret = ov5640_write_reg(sensor, OV5640_REG_FORMAT_CONTROL00,\n\t\t\t       pixfmt->ctrl00);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov5640_write_reg(sensor, OV5640_REG_ISP_FORMAT_MUX_CTRL,\n\t\t\t       pixfmt->mux);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov5640_mod_reg(sensor, OV5640_REG_TIMING_TC_REG21,\n\t\t\t     BIT(5), is_jpeg ? BIT(5) : 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov5640_mod_reg(sensor, OV5640_REG_SYS_RESET02,\n\t\t\t     BIT(4) | BIT(3) | BIT(2),\n\t\t\t     is_jpeg ? 0 : (BIT(4) | BIT(3) | BIT(2)));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn ov5640_mod_reg(sensor, OV5640_REG_SYS_CLOCK_ENABLE02,\n\t\t\t      BIT(5) | BIT(3),\n\t\t\t      is_jpeg ? (BIT(5) | BIT(3)) : 0);\n}\n\n \n\nstatic int ov5640_set_ctrl_hue(struct ov5640_dev *sensor, int value)\n{\n\tint ret;\n\n\tif (value) {\n\t\tret = ov5640_mod_reg(sensor, OV5640_REG_SDE_CTRL0,\n\t\t\t\t     BIT(0), BIT(0));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = ov5640_write_reg16(sensor, OV5640_REG_SDE_CTRL1, value);\n\t} else {\n\t\tret = ov5640_mod_reg(sensor, OV5640_REG_SDE_CTRL0, BIT(0), 0);\n\t}\n\n\treturn ret;\n}\n\nstatic int ov5640_set_ctrl_contrast(struct ov5640_dev *sensor, int value)\n{\n\tint ret;\n\n\tif (value) {\n\t\tret = ov5640_mod_reg(sensor, OV5640_REG_SDE_CTRL0,\n\t\t\t\t     BIT(2), BIT(2));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = ov5640_write_reg(sensor, OV5640_REG_SDE_CTRL5,\n\t\t\t\t       value & 0xff);\n\t} else {\n\t\tret = ov5640_mod_reg(sensor, OV5640_REG_SDE_CTRL0, BIT(2), 0);\n\t}\n\n\treturn ret;\n}\n\nstatic int ov5640_set_ctrl_saturation(struct ov5640_dev *sensor, int value)\n{\n\tint ret;\n\n\tif (value) {\n\t\tret = ov5640_mod_reg(sensor, OV5640_REG_SDE_CTRL0,\n\t\t\t\t     BIT(1), BIT(1));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = ov5640_write_reg(sensor, OV5640_REG_SDE_CTRL3,\n\t\t\t\t       value & 0xff);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = ov5640_write_reg(sensor, OV5640_REG_SDE_CTRL4,\n\t\t\t\t       value & 0xff);\n\t} else {\n\t\tret = ov5640_mod_reg(sensor, OV5640_REG_SDE_CTRL0, BIT(1), 0);\n\t}\n\n\treturn ret;\n}\n\nstatic int ov5640_set_ctrl_white_balance(struct ov5640_dev *sensor, int awb)\n{\n\tint ret;\n\n\tret = ov5640_mod_reg(sensor, OV5640_REG_AWB_MANUAL_CTRL,\n\t\t\t     BIT(0), awb ? 0 : 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!awb) {\n\t\tu16 red = (u16)sensor->ctrls.red_balance->val;\n\t\tu16 blue = (u16)sensor->ctrls.blue_balance->val;\n\n\t\tret = ov5640_write_reg16(sensor, OV5640_REG_AWB_R_GAIN, red);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = ov5640_write_reg16(sensor, OV5640_REG_AWB_B_GAIN, blue);\n\t}\n\n\treturn ret;\n}\n\nstatic int ov5640_set_ctrl_exposure(struct ov5640_dev *sensor,\n\t\t\t\t    enum v4l2_exposure_auto_type auto_exposure)\n{\n\tstruct ov5640_ctrls *ctrls = &sensor->ctrls;\n\tbool auto_exp = (auto_exposure == V4L2_EXPOSURE_AUTO);\n\tint ret = 0;\n\n\tif (ctrls->auto_exp->is_new) {\n\t\tret = ov5640_set_autoexposure(sensor, auto_exp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!auto_exp && ctrls->exposure->is_new) {\n\t\tu16 max_exp;\n\n\t\tret = ov5640_read_reg16(sensor, OV5640_REG_AEC_PK_VTS,\n\t\t\t\t\t&max_exp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = ov5640_get_vts(sensor);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tmax_exp += ret;\n\t\tret = 0;\n\n\t\tif (ctrls->exposure->val < max_exp)\n\t\t\tret = ov5640_set_exposure(sensor, ctrls->exposure->val);\n\t}\n\n\treturn ret;\n}\n\nstatic int ov5640_set_ctrl_gain(struct ov5640_dev *sensor, bool auto_gain)\n{\n\tstruct ov5640_ctrls *ctrls = &sensor->ctrls;\n\tint ret = 0;\n\n\tif (ctrls->auto_gain->is_new) {\n\t\tret = ov5640_set_autogain(sensor, auto_gain);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!auto_gain && ctrls->gain->is_new)\n\t\tret = ov5640_set_gain(sensor, ctrls->gain->val);\n\n\treturn ret;\n}\n\nstatic const char * const test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Color bars\",\n\t\"Color bars w/ rolling bar\",\n\t\"Color squares\",\n\t\"Color squares w/ rolling bar\",\n};\n\n#define OV5640_TEST_ENABLE\t\tBIT(7)\n#define OV5640_TEST_ROLLING\t\tBIT(6)\t \n#define OV5640_TEST_TRANSPARENT\t\tBIT(5)\n#define OV5640_TEST_SQUARE_BW\t\tBIT(4)\t \n#define OV5640_TEST_BAR_STANDARD\t(0 << 2)\n#define OV5640_TEST_BAR_VERT_CHANGE_1\t(1 << 2)\n#define OV5640_TEST_BAR_HOR_CHANGE\t(2 << 2)\n#define OV5640_TEST_BAR_VERT_CHANGE_2\t(3 << 2)\n#define OV5640_TEST_BAR\t\t\t(0 << 0)\n#define OV5640_TEST_RANDOM\t\t(1 << 0)\n#define OV5640_TEST_SQUARE\t\t(2 << 0)\n#define OV5640_TEST_BLACK\t\t(3 << 0)\n\nstatic const u8 test_pattern_val[] = {\n\t0,\n\tOV5640_TEST_ENABLE | OV5640_TEST_BAR_VERT_CHANGE_1 |\n\t\tOV5640_TEST_BAR,\n\tOV5640_TEST_ENABLE | OV5640_TEST_ROLLING |\n\t\tOV5640_TEST_BAR_VERT_CHANGE_1 | OV5640_TEST_BAR,\n\tOV5640_TEST_ENABLE | OV5640_TEST_SQUARE,\n\tOV5640_TEST_ENABLE | OV5640_TEST_ROLLING | OV5640_TEST_SQUARE,\n};\n\nstatic int ov5640_set_ctrl_test_pattern(struct ov5640_dev *sensor, int value)\n{\n\treturn ov5640_write_reg(sensor, OV5640_REG_PRE_ISP_TEST_SET1,\n\t\t\t\ttest_pattern_val[value]);\n}\n\nstatic int ov5640_set_ctrl_light_freq(struct ov5640_dev *sensor, int value)\n{\n\tint ret;\n\n\tret = ov5640_mod_reg(sensor, OV5640_REG_HZ5060_CTRL01, BIT(7),\n\t\t\t     (value == V4L2_CID_POWER_LINE_FREQUENCY_AUTO) ?\n\t\t\t     0 : BIT(7));\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov5640_mod_reg(sensor, OV5640_REG_HZ5060_CTRL00, BIT(2),\n\t\t\t      (value == V4L2_CID_POWER_LINE_FREQUENCY_50HZ) ?\n\t\t\t      BIT(2) : 0);\n}\n\nstatic int ov5640_set_ctrl_hflip(struct ov5640_dev *sensor, int value)\n{\n\t \n\n\t \n\treturn ov5640_mod_reg(sensor, OV5640_REG_TIMING_TC_REG21,\n\t\t\t      BIT(2) | BIT(1),\n\t\t\t      (!(value ^ sensor->upside_down)) ?\n\t\t\t      (BIT(2) | BIT(1)) : 0);\n}\n\nstatic int ov5640_set_ctrl_vflip(struct ov5640_dev *sensor, int value)\n{\n\t \n\n\t \n\treturn ov5640_mod_reg(sensor, OV5640_REG_TIMING_TC_REG20,\n\t\t\t      BIT(2) | BIT(1),\n\t\t\t      (value ^ sensor->upside_down) ?\n\t\t\t      (BIT(2) | BIT(1)) : 0);\n}\n\nstatic int ov5640_set_ctrl_vblank(struct ov5640_dev *sensor, int value)\n{\n\tconst struct ov5640_mode_info *mode = sensor->current_mode;\n\n\t \n\treturn ov5640_write_reg16(sensor, OV5640_REG_TIMING_VTS,\n\t\t\t\t  mode->height + value);\n}\n\nstatic int ov5640_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = ctrl_to_sd(ctrl);\n\tstruct ov5640_dev *sensor = to_ov5640_dev(sd);\n\tint val;\n\n\t \n\n\tif (!pm_runtime_get_if_in_use(&sensor->i2c_client->dev))\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTOGAIN:\n\t\tval = ov5640_get_gain(sensor);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tsensor->ctrls.gain->val = val;\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tval = ov5640_get_exposure(sensor);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tsensor->ctrls.exposure->val = val;\n\t\tbreak;\n\t}\n\n\tpm_runtime_mark_last_busy(&sensor->i2c_client->dev);\n\tpm_runtime_put_autosuspend(&sensor->i2c_client->dev);\n\n\treturn 0;\n}\n\nstatic int ov5640_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = ctrl_to_sd(ctrl);\n\tstruct ov5640_dev *sensor = to_ov5640_dev(sd);\n\tconst struct ov5640_mode_info *mode = sensor->current_mode;\n\tconst struct ov5640_timings *timings;\n\tunsigned int exp_max;\n\tint ret;\n\n\t \n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_VBLANK:\n\t\t \n\t\ttimings = ov5640_timings(sensor, mode);\n\t\texp_max = mode->height + ctrl->val - 4;\n\t\t__v4l2_ctrl_modify_range(sensor->ctrls.exposure,\n\t\t\t\t\t sensor->ctrls.exposure->minimum,\n\t\t\t\t\t exp_max, sensor->ctrls.exposure->step,\n\t\t\t\t\t timings->vblank_def);\n\t\tbreak;\n\t}\n\n\t \n\tif (!pm_runtime_get_if_in_use(&sensor->i2c_client->dev))\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTOGAIN:\n\t\tret = ov5640_set_ctrl_gain(sensor, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tret = ov5640_set_ctrl_exposure(sensor, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\tret = ov5640_set_ctrl_white_balance(sensor, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\tret = ov5640_set_ctrl_hue(sensor, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tret = ov5640_set_ctrl_contrast(sensor, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tret = ov5640_set_ctrl_saturation(sensor, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tret = ov5640_set_ctrl_test_pattern(sensor, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_POWER_LINE_FREQUENCY:\n\t\tret = ov5640_set_ctrl_light_freq(sensor, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tret = ov5640_set_ctrl_hflip(sensor, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tret = ov5640_set_ctrl_vflip(sensor, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_VBLANK:\n\t\tret = ov5640_set_ctrl_vblank(sensor, ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tpm_runtime_mark_last_busy(&sensor->i2c_client->dev);\n\tpm_runtime_put_autosuspend(&sensor->i2c_client->dev);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops ov5640_ctrl_ops = {\n\t.g_volatile_ctrl = ov5640_g_volatile_ctrl,\n\t.s_ctrl = ov5640_s_ctrl,\n};\n\nstatic int ov5640_init_controls(struct ov5640_dev *sensor)\n{\n\tconst struct ov5640_mode_info *mode = sensor->current_mode;\n\tconst struct v4l2_ctrl_ops *ops = &ov5640_ctrl_ops;\n\tstruct ov5640_ctrls *ctrls = &sensor->ctrls;\n\tstruct v4l2_ctrl_handler *hdl = &ctrls->handler;\n\tstruct v4l2_fwnode_device_properties props;\n\tconst struct ov5640_timings *timings;\n\tunsigned int max_vblank;\n\tunsigned int hblank;\n\tint ret;\n\n\tv4l2_ctrl_handler_init(hdl, 32);\n\n\t \n\thdl->lock = &sensor->lock;\n\n\t \n\tctrls->pixel_rate = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_PIXEL_RATE,\n\t\t\t      ov5640_pixel_rates[OV5640_NUM_PIXEL_RATES - 1],\n\t\t\t      ov5640_pixel_rates[0], 1,\n\t\t\t      ov5640_pixel_rates[mode->pixel_rate]);\n\n\tctrls->link_freq = v4l2_ctrl_new_int_menu(hdl, ops,\n\t\t\t\t\tV4L2_CID_LINK_FREQ,\n\t\t\t\t\tARRAY_SIZE(ov5640_csi2_link_freqs) - 1,\n\t\t\t\t\tOV5640_DEFAULT_LINK_FREQ,\n\t\t\t\t\tov5640_csi2_link_freqs);\n\n\ttimings = ov5640_timings(sensor, mode);\n\thblank = timings->htot - mode->width;\n\tctrls->hblank = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HBLANK, hblank,\n\t\t\t\t\t  hblank, 1, hblank);\n\n\tmax_vblank = OV5640_MAX_VTS - mode->height;\n\tctrls->vblank = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VBLANK,\n\t\t\t\t\t  OV5640_MIN_VBLANK, max_vblank,\n\t\t\t\t\t  1, timings->vblank_def);\n\n\t \n\tctrls->auto_wb = v4l2_ctrl_new_std(hdl, ops,\n\t\t\t\t\t   V4L2_CID_AUTO_WHITE_BALANCE,\n\t\t\t\t\t   0, 1, 1, 1);\n\tctrls->blue_balance = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_BLUE_BALANCE,\n\t\t\t\t\t\t0, 4095, 1, 0);\n\tctrls->red_balance = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_RED_BALANCE,\n\t\t\t\t\t       0, 4095, 1, 0);\n\t \n\tctrls->auto_exp = v4l2_ctrl_new_std_menu(hdl, ops,\n\t\t\t\t\t\t V4L2_CID_EXPOSURE_AUTO,\n\t\t\t\t\t\t V4L2_EXPOSURE_MANUAL, 0,\n\t\t\t\t\t\t V4L2_EXPOSURE_AUTO);\n\tctrls->exposure = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_EXPOSURE,\n\t\t\t\t\t    0, 65535, 1, 0);\n\t \n\tctrls->auto_gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_AUTOGAIN,\n\t\t\t\t\t     0, 1, 1, 1);\n\tctrls->gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_ANALOGUE_GAIN,\n\t\t\t\t\t0, 1023, 1, 0);\n\n\tctrls->saturation = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_SATURATION,\n\t\t\t\t\t      0, 255, 1, 64);\n\tctrls->hue = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HUE,\n\t\t\t\t       0, 359, 1, 0);\n\tctrls->contrast = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_CONTRAST,\n\t\t\t\t\t    0, 255, 1, 0);\n\tctrls->test_pattern =\n\t\tv4l2_ctrl_new_std_menu_items(hdl, ops, V4L2_CID_TEST_PATTERN,\n\t\t\t\t\t     ARRAY_SIZE(test_pattern_menu) - 1,\n\t\t\t\t\t     0, 0, test_pattern_menu);\n\tctrls->hflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HFLIP,\n\t\t\t\t\t 0, 1, 1, 0);\n\tctrls->vflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VFLIP,\n\t\t\t\t\t 0, 1, 1, 0);\n\n\tctrls->light_freq =\n\t\tv4l2_ctrl_new_std_menu(hdl, ops,\n\t\t\t\t       V4L2_CID_POWER_LINE_FREQUENCY,\n\t\t\t\t       V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 0,\n\t\t\t\t       V4L2_CID_POWER_LINE_FREQUENCY_50HZ);\n\n\tif (hdl->error) {\n\t\tret = hdl->error;\n\t\tgoto free_ctrls;\n\t}\n\n\tret = v4l2_fwnode_device_parse(&sensor->i2c_client->dev, &props);\n\tif (ret)\n\t\tgoto free_ctrls;\n\n\tif (props.rotation == 180)\n\t\tsensor->upside_down = true;\n\n\tret = v4l2_ctrl_new_fwnode_properties(hdl, ops, &props);\n\tif (ret)\n\t\tgoto free_ctrls;\n\n\tctrls->pixel_rate->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\tctrls->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\tctrls->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\tctrls->gain->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\tctrls->exposure->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\n\tv4l2_ctrl_auto_cluster(3, &ctrls->auto_wb, 0, false);\n\tv4l2_ctrl_auto_cluster(2, &ctrls->auto_gain, 0, true);\n\tv4l2_ctrl_auto_cluster(2, &ctrls->auto_exp, 1, true);\n\n\tsensor->sd.ctrl_handler = hdl;\n\treturn 0;\n\nfree_ctrls:\n\tv4l2_ctrl_handler_free(hdl);\n\treturn ret;\n}\n\nstatic int ov5640_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct ov5640_dev *sensor = to_ov5640_dev(sd);\n\tu32 bpp = ov5640_code_to_bpp(sensor, fse->code);\n\tunsigned int index = fse->index;\n\n\tif (fse->pad != 0)\n\t\treturn -EINVAL;\n\tif (!bpp)\n\t\treturn -EINVAL;\n\n\t \n\tif (bpp == 24 && index >= OV5640_MODE_720P_1280_720)\n\t\treturn -EINVAL;\n\n\t \n\tif (bpp == 8)\n\t\tindex += OV5640_MODE_720P_1280_720;\n\n\tif (index >= OV5640_NUM_MODES)\n\t\treturn -EINVAL;\n\n\tfse->min_width = ov5640_mode_data[index].width;\n\tfse->max_width = fse->min_width;\n\tfse->min_height = ov5640_mode_data[index].height;\n\tfse->max_height = fse->min_height;\n\n\treturn 0;\n}\n\nstatic int ov5640_enum_frame_interval(\n\tstruct v4l2_subdev *sd,\n\tstruct v4l2_subdev_state *sd_state,\n\tstruct v4l2_subdev_frame_interval_enum *fie)\n{\n\tstruct ov5640_dev *sensor = to_ov5640_dev(sd);\n\tconst struct ov5640_mode_info *mode;\n\tstruct v4l2_fract tpf;\n\tint ret;\n\n\tif (fie->pad != 0)\n\t\treturn -EINVAL;\n\tif (fie->index >= OV5640_NUM_FRAMERATES)\n\t\treturn -EINVAL;\n\n\tmode = ov5640_find_mode(sensor, fie->width, fie->height, false);\n\tif (!mode)\n\t\treturn -EINVAL;\n\n\ttpf.numerator = 1;\n\ttpf.denominator = ov5640_framerates[fie->index];\n\n\tret = ov5640_try_frame_interval(sensor, &tpf, mode);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tfie->interval = tpf;\n\treturn 0;\n}\n\nstatic int ov5640_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *fi)\n{\n\tstruct ov5640_dev *sensor = to_ov5640_dev(sd);\n\n\tmutex_lock(&sensor->lock);\n\tfi->interval = sensor->frame_interval;\n\tmutex_unlock(&sensor->lock);\n\n\treturn 0;\n}\n\nstatic int ov5640_s_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *fi)\n{\n\tstruct ov5640_dev *sensor = to_ov5640_dev(sd);\n\tconst struct ov5640_mode_info *mode;\n\tint frame_rate, ret = 0;\n\n\tif (fi->pad != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sensor->lock);\n\n\tif (sensor->streaming) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tmode = sensor->current_mode;\n\n\tframe_rate = ov5640_try_frame_interval(sensor, &fi->interval, mode);\n\tif (frame_rate < 0) {\n\t\t \n\t\tfi->interval = sensor->frame_interval;\n\t\tgoto out;\n\t}\n\n\tmode = ov5640_find_mode(sensor, mode->width, mode->height, true);\n\tif (!mode) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (ov5640_framerates[frame_rate] > ov5640_framerates[mode->max_fps]) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (mode != sensor->current_mode ||\n\t    frame_rate != sensor->current_fr) {\n\t\tsensor->current_fr = frame_rate;\n\t\tsensor->frame_interval = fi->interval;\n\t\tsensor->current_mode = mode;\n\t\tsensor->pending_mode_change = true;\n\n\t\tov5640_update_pixel_rate(sensor);\n\t}\nout:\n\tmutex_unlock(&sensor->lock);\n\treturn ret;\n}\n\nstatic int ov5640_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct ov5640_dev *sensor = to_ov5640_dev(sd);\n\tconst struct ov5640_pixfmt *formats;\n\tunsigned int num_formats;\n\n\tif (ov5640_is_csi2(sensor)) {\n\t\tformats = ov5640_csi2_formats;\n\t\tnum_formats = ARRAY_SIZE(ov5640_csi2_formats) - 1;\n\t} else {\n\t\tformats = ov5640_dvp_formats;\n\t\tnum_formats = ARRAY_SIZE(ov5640_dvp_formats) - 1;\n\t}\n\n\tif (code->index >= num_formats)\n\t\treturn -EINVAL;\n\n\tcode->code = formats[code->index].code;\n\n\treturn 0;\n}\n\nstatic int ov5640_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct ov5640_dev *sensor = to_ov5640_dev(sd);\n\tint ret = 0;\n\n\tif (enable) {\n\t\tret = pm_runtime_resume_and_get(&sensor->i2c_client->dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = v4l2_ctrl_handler_setup(&sensor->ctrls.handler);\n\t\tif (ret) {\n\t\t\tpm_runtime_put(&sensor->i2c_client->dev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmutex_lock(&sensor->lock);\n\n\tif (sensor->streaming == !enable) {\n\t\tif (enable && sensor->pending_mode_change) {\n\t\t\tret = ov5640_set_mode(sensor);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (enable && sensor->pending_fmt_change) {\n\t\t\tret = ov5640_set_framefmt(sensor, &sensor->fmt);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tsensor->pending_fmt_change = false;\n\t\t}\n\n\t\tif (ov5640_is_csi2(sensor))\n\t\t\tret = ov5640_set_stream_mipi(sensor, enable);\n\t\telse\n\t\t\tret = ov5640_set_stream_dvp(sensor, enable);\n\n\t\tif (!ret)\n\t\t\tsensor->streaming = enable;\n\t}\n\nout:\n\tmutex_unlock(&sensor->lock);\n\n\tif (!enable || ret) {\n\t\tpm_runtime_mark_last_busy(&sensor->i2c_client->dev);\n\t\tpm_runtime_put_autosuspend(&sensor->i2c_client->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic int ov5640_init_cfg(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *state)\n{\n\tstruct ov5640_dev *sensor = to_ov5640_dev(sd);\n\tstruct v4l2_mbus_framefmt *fmt =\n\t\t\t\tv4l2_subdev_get_try_format(sd, state, 0);\n\tstruct v4l2_rect *crop = v4l2_subdev_get_try_crop(sd, state, 0);\n\n\t*fmt = ov5640_is_csi2(sensor) ? ov5640_csi2_default_fmt :\n\t\t\t\t\tov5640_dvp_default_fmt;\n\n\tcrop->left = OV5640_PIXEL_ARRAY_LEFT;\n\tcrop->top = OV5640_PIXEL_ARRAY_TOP;\n\tcrop->width = OV5640_PIXEL_ARRAY_WIDTH;\n\tcrop->height = OV5640_PIXEL_ARRAY_HEIGHT;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops ov5640_core_ops = {\n\t.log_status = v4l2_ctrl_subdev_log_status,\n\t.subscribe_event = v4l2_ctrl_subdev_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n};\n\nstatic const struct v4l2_subdev_video_ops ov5640_video_ops = {\n\t.g_frame_interval = ov5640_g_frame_interval,\n\t.s_frame_interval = ov5640_s_frame_interval,\n\t.s_stream = ov5640_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops ov5640_pad_ops = {\n\t.init_cfg = ov5640_init_cfg,\n\t.enum_mbus_code = ov5640_enum_mbus_code,\n\t.get_fmt = ov5640_get_fmt,\n\t.set_fmt = ov5640_set_fmt,\n\t.get_selection = ov5640_get_selection,\n\t.enum_frame_size = ov5640_enum_frame_size,\n\t.enum_frame_interval = ov5640_enum_frame_interval,\n};\n\nstatic const struct v4l2_subdev_ops ov5640_subdev_ops = {\n\t.core = &ov5640_core_ops,\n\t.video = &ov5640_video_ops,\n\t.pad = &ov5640_pad_ops,\n};\n\nstatic int ov5640_get_regulators(struct ov5640_dev *sensor)\n{\n\tint i;\n\n\tfor (i = 0; i < OV5640_NUM_SUPPLIES; i++)\n\t\tsensor->supplies[i].supply = ov5640_supply_name[i];\n\n\treturn devm_regulator_bulk_get(&sensor->i2c_client->dev,\n\t\t\t\t       OV5640_NUM_SUPPLIES,\n\t\t\t\t       sensor->supplies);\n}\n\nstatic int ov5640_check_chip_id(struct ov5640_dev *sensor)\n{\n\tstruct i2c_client *client = sensor->i2c_client;\n\tint ret = 0;\n\tu16 chip_id;\n\n\tret = ov5640_read_reg16(sensor, OV5640_REG_CHIP_ID, &chip_id);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"%s: failed to read chip identifier\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tif (chip_id != 0x5640) {\n\t\tdev_err(&client->dev, \"%s: wrong chip identifier, expected 0x5640, got 0x%x\\n\",\n\t\t\t__func__, chip_id);\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov5640_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct fwnode_handle *endpoint;\n\tstruct ov5640_dev *sensor;\n\tint ret;\n\n\tsensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);\n\tif (!sensor)\n\t\treturn -ENOMEM;\n\n\tsensor->i2c_client = client;\n\n\t \n\tsensor->frame_interval.numerator = 1;\n\tsensor->frame_interval.denominator = ov5640_framerates[OV5640_30_FPS];\n\tsensor->current_fr = OV5640_30_FPS;\n\tsensor->current_mode =\n\t\t&ov5640_mode_data[OV5640_MODE_VGA_640_480];\n\tsensor->last_mode = sensor->current_mode;\n\tsensor->current_link_freq =\n\t\tov5640_csi2_link_freqs[OV5640_DEFAULT_LINK_FREQ];\n\n\tsensor->ae_target = 52;\n\n\tendpoint = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev),\n\t\t\t\t\t\t  NULL);\n\tif (!endpoint) {\n\t\tdev_err(dev, \"endpoint node not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = v4l2_fwnode_endpoint_parse(endpoint, &sensor->ep);\n\tfwnode_handle_put(endpoint);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not parse endpoint\\n\");\n\t\treturn ret;\n\t}\n\n\tif (sensor->ep.bus_type != V4L2_MBUS_PARALLEL &&\n\t    sensor->ep.bus_type != V4L2_MBUS_CSI2_DPHY &&\n\t    sensor->ep.bus_type != V4L2_MBUS_BT656) {\n\t\tdev_err(dev, \"Unsupported bus type %d\\n\", sensor->ep.bus_type);\n\t\treturn -EINVAL;\n\t}\n\n\tsensor->fmt = ov5640_is_csi2(sensor) ? ov5640_csi2_default_fmt :\n\t\t\t\t\t       ov5640_dvp_default_fmt;\n\n\t \n\tsensor->xclk = devm_clk_get(dev, \"xclk\");\n\tif (IS_ERR(sensor->xclk)) {\n\t\tdev_err(dev, \"failed to get xclk\\n\");\n\t\treturn PTR_ERR(sensor->xclk);\n\t}\n\n\tsensor->xclk_freq = clk_get_rate(sensor->xclk);\n\tif (sensor->xclk_freq < OV5640_XCLK_MIN ||\n\t    sensor->xclk_freq > OV5640_XCLK_MAX) {\n\t\tdev_err(dev, \"xclk frequency out of range: %d Hz\\n\",\n\t\t\tsensor->xclk_freq);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsensor->pwdn_gpio = devm_gpiod_get_optional(dev, \"powerdown\",\n\t\t\t\t\t\t    GPIOD_OUT_HIGH);\n\tif (IS_ERR(sensor->pwdn_gpio))\n\t\treturn PTR_ERR(sensor->pwdn_gpio);\n\n\t \n\tsensor->reset_gpio = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t     GPIOD_OUT_HIGH);\n\tif (IS_ERR(sensor->reset_gpio))\n\t\treturn PTR_ERR(sensor->reset_gpio);\n\n\tv4l2_i2c_subdev_init(&sensor->sd, client, &ov5640_subdev_ops);\n\n\tsensor->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |\n\t\t\t    V4L2_SUBDEV_FL_HAS_EVENTS;\n\tsensor->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tsensor->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tret = media_entity_pads_init(&sensor->sd.entity, 1, &sensor->pad);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5640_get_regulators(sensor);\n\tif (ret)\n\t\tgoto entity_cleanup;\n\n\tmutex_init(&sensor->lock);\n\n\tret = ov5640_init_controls(sensor);\n\tif (ret)\n\t\tgoto entity_cleanup;\n\n\tret = ov5640_sensor_resume(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to power on\\n\");\n\t\tgoto free_ctrls;\n\t}\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_enable(dev);\n\n\tret = ov5640_check_chip_id(sensor);\n\tif (ret)\n\t\tgoto err_pm_runtime;\n\n\tret = v4l2_async_register_subdev_sensor(&sensor->sd);\n\tif (ret)\n\t\tgoto err_pm_runtime;\n\n\tpm_runtime_set_autosuspend_delay(dev, 1000);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n\nerr_pm_runtime:\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_disable(dev);\n\tov5640_sensor_suspend(dev);\nfree_ctrls:\n\tv4l2_ctrl_handler_free(&sensor->ctrls.handler);\nentity_cleanup:\n\tmedia_entity_cleanup(&sensor->sd.entity);\n\tmutex_destroy(&sensor->lock);\n\treturn ret;\n}\n\nstatic void ov5640_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov5640_dev *sensor = to_ov5640_dev(sd);\n\tstruct device *dev = &client->dev;\n\n\tpm_runtime_disable(dev);\n\tif (!pm_runtime_status_suspended(dev))\n\t\tov5640_sensor_suspend(dev);\n\tpm_runtime_set_suspended(dev);\n\n\tv4l2_async_unregister_subdev(&sensor->sd);\n\tmedia_entity_cleanup(&sensor->sd.entity);\n\tv4l2_ctrl_handler_free(&sensor->ctrls.handler);\n\tmutex_destroy(&sensor->lock);\n}\n\nstatic const struct dev_pm_ops ov5640_pm_ops = {\n\tSET_RUNTIME_PM_OPS(ov5640_sensor_suspend, ov5640_sensor_resume, NULL)\n};\n\nstatic const struct i2c_device_id ov5640_id[] = {\n\t{\"ov5640\", 0},\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, ov5640_id);\n\nstatic const struct of_device_id ov5640_dt_ids[] = {\n\t{ .compatible = \"ovti,ov5640\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ov5640_dt_ids);\n\nstatic struct i2c_driver ov5640_i2c_driver = {\n\t.driver = {\n\t\t.name  = \"ov5640\",\n\t\t.of_match_table\t= ov5640_dt_ids,\n\t\t.pm = &ov5640_pm_ops,\n\t},\n\t.id_table = ov5640_id,\n\t.probe    = ov5640_probe,\n\t.remove   = ov5640_remove,\n};\n\nmodule_i2c_driver(ov5640_i2c_driver);\n\nMODULE_DESCRIPTION(\"OV5640 MIPI Camera Subdev Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}