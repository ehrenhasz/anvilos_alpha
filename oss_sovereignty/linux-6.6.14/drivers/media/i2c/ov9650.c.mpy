{
  "module_name": "ov9650.c",
  "hash_id": "c8ecccaa3fe44199207b7d4189844128dfddf2dd3451d64b40f122ab4d8d3369",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ov9650.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/media.h>\n#include <linux/module.h>\n#include <linux/ratelimit.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/videodev2.h>\n\n#include <media/media-entity.h>\n#include <media/v4l2-async.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-image-sizes.h>\n#include <media/v4l2-subdev.h>\n#include <media/v4l2-mediabus.h>\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Debug level (0-2)\");\n\n#define DRIVER_NAME \"OV9650\"\n\n \n#define REG_GAIN\t\t0x00\t \n#define REG_BLUE\t\t0x01\t \n#define REG_RED\t\t\t0x02\t \n#define REG_VREF\t\t0x03\t \n#define  VREF_GAIN_MASK\t\t0xc0\t \n#define REG_COM1\t\t0x04\n#define  COM1_CCIR656\t\t0x40\n#define REG_B_AVE\t\t0x05\n#define REG_GB_AVE\t\t0x06\n#define REG_GR_AVE\t\t0x07\n#define REG_R_AVE\t\t0x08\n#define REG_COM2\t\t0x09\n#define REG_PID\t\t\t0x0a\t \n#define REG_VER\t\t\t0x0b\t \n#define REG_COM3\t\t0x0c\n#define  COM3_SWAP\t\t0x40\n#define  COM3_VARIOPIXEL1\t0x04\n#define REG_COM4\t\t0x0d\t \n#define  COM4_VARIOPIXEL2\t0x80\n#define REG_COM5\t\t0x0e\t \n#define  COM5_SLAVE_MODE\t0x10\n#define  COM5_SYSTEMCLOCK48MHZ\t0x80\n#define REG_COM6\t\t0x0f\t \n#define REG_AECH\t\t0x10\t \n#define REG_CLKRC\t\t0x11\t \n#define  CLK_EXT\t\t0x40\t \n#define  CLK_SCALE\t\t0x3f\t \n#define REG_COM7\t\t0x12\t \n#define  COM7_RESET\t\t0x80\n#define  COM7_FMT_MASK\t\t0x38\n#define  COM7_FMT_VGA\t\t0x40\n#define\t COM7_FMT_CIF\t\t0x20\n#define  COM7_FMT_QVGA\t\t0x10\n#define  COM7_FMT_QCIF\t\t0x08\n#define\t COM7_RGB\t\t0x04\n#define\t COM7_YUV\t\t0x00\n#define\t COM7_BAYER\t\t0x01\n#define\t COM7_PBAYER\t\t0x05\n#define REG_COM8\t\t0x13\t \n#define  COM8_FASTAEC\t\t0x80\t \n#define  COM8_AECSTEP\t\t0x40\t \n#define  COM8_BFILT\t\t0x20\t \n#define  COM8_AGC\t\t0x04\t \n#define  COM8_AWB\t\t0x02\t \n#define  COM8_AEC\t\t0x01\t \n#define REG_COM9\t\t0x14\t \n#define  COM9_GAIN_CEIL_MASK\t0x70\t \n#define REG_COM10\t\t0x15\t \n#define  COM10_HSYNC\t\t0x40\t \n#define  COM10_PCLK_HB\t\t0x20\t \n#define  COM10_HREF_REV\t\t0x08\t \n#define  COM10_VS_LEAD\t\t0x04\t \n#define  COM10_VS_NEG\t\t0x02\t \n#define  COM10_HS_NEG\t\t0x01\t \n#define REG_HSTART\t\t0x17\t \n#define REG_HSTOP\t\t0x18\t \n#define REG_VSTART\t\t0x19\t \n#define REG_VSTOP\t\t0x1a\t \n#define REG_PSHFT\t\t0x1b\t \n#define REG_MIDH\t\t0x1c\t \n#define REG_MIDL\t\t0x1d\t \n#define REG_MVFP\t\t0x1e\t \n#define  MVFP_MIRROR\t\t0x20\t \n#define  MVFP_FLIP\t\t0x10\t \n#define REG_BOS\t\t\t0x20\t \n#define REG_GBOS\t\t0x21\t \n#define REG_GROS\t\t0x22\t \n#define REG_ROS\t\t\t0x23\t \n#define REG_AEW\t\t\t0x24\t \n#define REG_AEB\t\t\t0x25\t \n#define REG_VPT\t\t\t0x26\t \n#define REG_BBIAS\t\t0x27\t \n#define REG_GBBIAS\t\t0x28\t \n#define REG_GRCOM\t\t0x29\t \n#define REG_EXHCH\t\t0x2a\t \n#define REG_EXHCL\t\t0x2b\t \n#define REG_RBIAS\t\t0x2c\t \n#define REG_ADVFL\t\t0x2d\t \n#define REG_ADVFH\t\t0x2e\t \n#define REG_YAVE\t\t0x2f\t \n#define REG_HSYST\t\t0x30\t \n#define REG_HSYEN\t\t0x31\t \n#define REG_HREF\t\t0x32\t \n#define REG_CHLF\t\t0x33\t \n#define REG_ADC\t\t\t0x37\t \n#define REG_ACOM\t\t0x38\t \n#define REG_OFON\t\t0x39\t \n#define  OFON_PWRDN\t\t0x08\t \n#define REG_TSLB\t\t0x3a\t \n#define  TSLB_YUYV_MASK\t\t0x0c\t \n#define REG_COM11\t\t0x3b\t \n#define  COM11_NIGHT\t\t0x80\t \n#define  COM11_NMFR\t\t0x60\t \n#define  COM11_BANDING\t\t0x01\t \n#define  COM11_AEC_REF_MASK\t0x18\t \n#define REG_COM12\t\t0x3c\t \n#define  COM12_HREF\t\t0x80\t \n#define REG_COM13\t\t0x3d\t \n#define  COM13_GAMMA\t\t0x80\t \n#define\t COM13_UVSAT\t\t0x40\t \n#define  COM13_UVSWAP\t\t0x01\t \n#define REG_COM14\t\t0x3e\t \n#define  COM14_EDGE_EN\t\t0x02\n#define  COM14_EEF_X2\t\t0x01\n#define REG_EDGE\t\t0x3f\t \n#define  EDGE_FACTOR_MASK\t0x0f\n#define REG_COM15\t\t0x40\t \n#define  COM15_R10F0\t\t0x00\t \n#define\t COM15_R01FE\t\t0x80\t \n#define  COM15_R00FF\t\t0xc0\t \n#define  COM15_RGB565\t\t0x10\t \n#define  COM15_RGB555\t\t0x30\t \n#define  COM15_SWAPRB\t\t0x04\t \n#define REG_COM16\t\t0x41\t \n#define REG_COM17\t\t0x42\t \n \n#define\tREG_MTX(__n)\t\t(0x4f + (__n) - 1)\n#define REG_MTXS\t\t0x58\n \n#define REG_LCC(__n)\t\t(0x62 + (__n) - 1)\n#define  LCC5_LCC_ENABLE\t0x01\t \n#define  LCC5_LCC_COLOR\t\t0x04\n#define REG_MANU\t\t0x67\t \n#define REG_MANV\t\t0x68\t \n#define REG_HV\t\t\t0x69\t \n#define REG_MBD\t\t\t0x6a\t \n#define REG_DBLV\t\t0x6b\t \n#define REG_GSP\t\t\t0x6c\t \n#define  GSP_LEN\t\t15\n#define REG_GST\t\t\t0x7c\t \n#define  GST_LEN\t\t15\n#define REG_COM21\t\t0x8b\n#define REG_COM22\t\t0x8c\t \n#define  COM22_WHTPCOR\t\t0x02\t \n#define  COM22_WHTPCOROPT\t0x01\t \n#define  COM22_DENOISE\t\t0x10\t \n#define REG_COM23\t\t0x8d\t \n#define  COM23_TEST_MODE\t0x10\n#define REG_DBLC1\t\t0x8f\t \n#define REG_DBLC_B\t\t0x90\t \n#define REG_DBLC_R\t\t0x91\t \n#define REG_DM_LNL\t\t0x92\t \n#define REG_DM_LNH\t\t0x93\t \n#define REG_LCCFB\t\t0x9d\t \n#define REG_LCCFR\t\t0x9e\t \n#define REG_DBLC_GB\t\t0x9f\t \n#define REG_DBLC_GR\t\t0xa0\t \n#define REG_AECHM\t\t0xa1\t \n#define REG_BD50ST\t\t0xa2\t \n#define REG_BD60ST\t\t0xa3\t \n#define REG_NULL\t\t0xff\t \n\n#define DEF_CLKRC\t\t0x80\n\n#define OV965X_ID(_msb, _lsb)\t((_msb) << 8 | (_lsb))\n#define OV9650_ID\t\t0x9650\n#define OV9652_ID\t\t0x9652\n\nstruct ov965x_ctrls {\n\tstruct v4l2_ctrl_handler handler;\n\tstruct {\n\t\tstruct v4l2_ctrl *auto_exp;\n\t\tstruct v4l2_ctrl *exposure;\n\t};\n\tstruct {\n\t\tstruct v4l2_ctrl *auto_wb;\n\t\tstruct v4l2_ctrl *blue_balance;\n\t\tstruct v4l2_ctrl *red_balance;\n\t};\n\tstruct {\n\t\tstruct v4l2_ctrl *hflip;\n\t\tstruct v4l2_ctrl *vflip;\n\t};\n\tstruct {\n\t\tstruct v4l2_ctrl *auto_gain;\n\t\tstruct v4l2_ctrl *gain;\n\t};\n\tstruct v4l2_ctrl *brightness;\n\tstruct v4l2_ctrl *saturation;\n\tstruct v4l2_ctrl *sharpness;\n\tstruct v4l2_ctrl *light_freq;\n\tu8 update;\n};\n\nstruct ov965x_framesize {\n\tu16 width;\n\tu16 height;\n\tu16 max_exp_lines;\n\tconst u8 *regs;\n};\n\nstruct ov965x_interval {\n\tstruct v4l2_fract interval;\n\t \n\tstruct v4l2_frmsize_discrete size;\n\tu8 clkrc_div;\n};\n\nenum gpio_id {\n\tGPIO_PWDN,\n\tGPIO_RST,\n\tNUM_GPIOS,\n};\n\nstruct ov965x {\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pad;\n\tenum v4l2_mbus_type bus_type;\n\tstruct gpio_desc *gpios[NUM_GPIOS];\n\t \n\tunsigned long mclk_frequency;\n\tstruct clk *clk;\n\n\t \n\tstruct mutex lock;\n\n\tstruct regmap *regmap;\n\n\t \n\tunsigned int exp_row_interval;\n\n\tunsigned short id;\n\tconst struct ov965x_framesize *frame_size;\n\t \n\tu8 tslb_reg;\n\tstruct v4l2_mbus_framefmt format;\n\n\tstruct ov965x_ctrls ctrls;\n\t \n\tconst struct ov965x_interval *fiv;\n\n\tint streaming;\n\tint power;\n\n\tu8 apply_frame_fmt;\n};\n\nstruct i2c_rv {\n\tu8 addr;\n\tu8 value;\n};\n\nstatic const struct i2c_rv ov965x_init_regs[] = {\n\t{ REG_COM2, 0x10 },\t \n\t{ REG_COM5, 0x00 },\t \n\t{ REG_COM2, 0x01 },\t \n\t{ REG_COM10, 0x00 },\t \n\t{ REG_EDGE, 0xa6 },\t \n\t{ REG_COM16, 0x02 },\t \n\t{ REG_COM17, 0x08 },\t \n\t{ 0x16, 0x06 },\n\t{ REG_CHLF, 0xc0 },\t \n\t{ 0x34, 0xbf },\n\t{ 0xa8, 0x80 },\n\t{ 0x96, 0x04 },\n\t{ 0x8e, 0x00 },\n\t{ REG_COM12, 0x77 },\t \n\t{ 0x8b, 0x06 },\n\t{ 0x35, 0x91 },\n\t{ 0x94, 0x88 },\n\t{ 0x95, 0x88 },\n\t{ REG_COM15, 0xc1 },\t \n\t{ REG_GRCOM, 0x2f },\t \n\t{ REG_COM6, 0x43 },\t \n\t{ REG_COM8, 0xe5 },\t \n\t{ REG_COM13, 0x90 },\t \n\t{ REG_HV, 0x80 },\t \n\t{ 0x5c, 0x96 },\t\t \n\t{ 0x5d, 0x96 },\n\t{ 0x5e, 0x10 },\n\t{ 0x59, 0xeb },\n\t{ 0x5a, 0x9c },\n\t{ 0x5b, 0x55 },\n\t{ 0x43, 0xf0 },\n\t{ 0x44, 0x10 },\n\t{ 0x45, 0x55 },\n\t{ 0x46, 0x86 },\n\t{ 0x47, 0x64 },\n\t{ 0x48, 0x86 },\n\t{ 0x5f, 0xe0 },\n\t{ 0x60, 0x8c },\n\t{ 0x61, 0x20 },\n\t{ 0xa5, 0xd9 },\n\t{ 0xa4, 0x74 },\t\t \n\t{ REG_COM23, 0x02 },\t \n\t{ REG_COM8, 0xe7 },\t \n\t{ REG_COM22, 0x23 },\t \n\t{ 0xa9, 0xb8 },\n\t{ 0xaa, 0x92 },\n\t{ 0xab, 0x0a },\n\t{ REG_DBLC1, 0xdf },\t \n\t{ REG_DBLC_B, 0x00 },\t \n\t{ REG_DBLC_R, 0x00 },\t \n\t{ REG_DBLC_GB, 0x00 },\t \n\t{ REG_DBLC_GR, 0x00 },\n\t{ REG_COM9, 0x3a },\t \n\t{ REG_NULL, 0 }\n};\n\n#define NUM_FMT_REGS 14\n \nstatic const u8 frame_size_reg_addr[NUM_FMT_REGS] = {\n\t0x12, 0x0c, 0x0d, 0x17, 0x18, 0x32, 0x19, 0x1a, 0x03,\n\t0x2a, 0x2b, 0x37, 0x38, 0x39,\n};\n\nstatic const u8 ov965x_sxga_regs[NUM_FMT_REGS] = {\n\t0x00, 0x00, 0x00, 0x1e, 0xbe, 0xbf, 0x01, 0x81, 0x12,\n\t0x10, 0x34, 0x81, 0x93, 0x51,\n};\n\nstatic const u8 ov965x_vga_regs[NUM_FMT_REGS] = {\n\t0x40, 0x04, 0x80, 0x26, 0xc6, 0xed, 0x01, 0x3d, 0x00,\n\t0x10, 0x40, 0x91, 0x12, 0x43,\n};\n\n \nstatic const u8 ov965x_qvga_regs[NUM_FMT_REGS] = {\n\t0x10, 0x04, 0x80, 0x25, 0xc5, 0xbf, 0x00, 0x80, 0x12,\n\t0x10, 0x40, 0x91, 0x12, 0x43,\n};\n\nstatic const struct ov965x_framesize ov965x_framesizes[] = {\n\t{\n\t\t.width\t\t= SXGA_WIDTH,\n\t\t.height\t\t= SXGA_HEIGHT,\n\t\t.regs\t\t= ov965x_sxga_regs,\n\t\t.max_exp_lines\t= 1048,\n\t}, {\n\t\t.width\t\t= VGA_WIDTH,\n\t\t.height\t\t= VGA_HEIGHT,\n\t\t.regs\t\t= ov965x_vga_regs,\n\t\t.max_exp_lines\t= 498,\n\t}, {\n\t\t.width\t\t= QVGA_WIDTH,\n\t\t.height\t\t= QVGA_HEIGHT,\n\t\t.regs\t\t= ov965x_qvga_regs,\n\t\t.max_exp_lines\t= 248,\n\t},\n};\n\nstruct ov965x_pixfmt {\n\tu32 code;\n\tu32 colorspace;\n\t \n\tu8 tslb_reg;\n};\n\nstatic const struct ov965x_pixfmt ov965x_formats[] = {\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_JPEG, 0x00},\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, V4L2_COLORSPACE_JPEG, 0x04},\n\t{ MEDIA_BUS_FMT_UYVY8_2X8, V4L2_COLORSPACE_JPEG, 0x0c},\n\t{ MEDIA_BUS_FMT_VYUY8_2X8, V4L2_COLORSPACE_JPEG, 0x08},\n};\n\n \nstatic struct ov965x_interval ov965x_intervals[] = {\n\t{{ 100, 625 }, { SXGA_WIDTH, SXGA_HEIGHT }, 0 },   \n\t{{ 10,  125 }, { VGA_WIDTH, VGA_HEIGHT },   1 },   \n\t{{ 10,  125 }, { QVGA_WIDTH, QVGA_HEIGHT }, 3 },   \n\t{{ 1,   25  }, { VGA_WIDTH, VGA_HEIGHT },   0 },   \n\t{{ 1,   25  }, { QVGA_WIDTH, QVGA_HEIGHT }, 1 },   \n};\n\nstatic inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct ov965x, ctrls.handler)->sd;\n}\n\nstatic inline struct ov965x *to_ov965x(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct ov965x, sd);\n}\n\nstatic int ov965x_read(struct ov965x *ov965x, u8 addr, u8 *val)\n{\n\tint ret;\n\tunsigned int buf;\n\n\tret = regmap_read(ov965x->regmap, addr, &buf);\n\tif (!ret)\n\t\t*val = buf;\n\telse\n\t\t*val = -1;\n\n\tv4l2_dbg(2, debug, &ov965x->sd, \"%s: 0x%02x @ 0x%02x. (%d)\\n\",\n\t\t __func__, *val, addr, ret);\n\n\treturn ret;\n}\n\nstatic int ov965x_write(struct ov965x *ov965x, u8 addr, u8 val)\n{\n\tint ret;\n\n\tret = regmap_write(ov965x->regmap, addr, val);\n\n\tv4l2_dbg(2, debug, &ov965x->sd, \"%s: 0x%02x @ 0x%02X (%d)\\n\",\n\t\t __func__, val, addr, ret);\n\n\treturn ret;\n}\n\nstatic int ov965x_write_array(struct ov965x *ov965x,\n\t\t\t      const struct i2c_rv *regs)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; ret == 0 && regs[i].addr != REG_NULL; i++)\n\t\tret = ov965x_write(ov965x, regs[i].addr, regs[i].value);\n\n\treturn ret;\n}\n\nstatic int ov965x_set_default_gamma_curve(struct ov965x *ov965x)\n{\n\tstatic const u8 gamma_curve[] = {\n\t\t \n\t\t0x40, 0x30, 0x4b, 0x60, 0x70, 0x70, 0x70, 0x70,\n\t\t0x60, 0x60, 0x50, 0x48, 0x3a, 0x2e, 0x28, 0x22,\n\t\t0x04, 0x07, 0x10, 0x28,\t0x36, 0x44, 0x52, 0x60,\n\t\t0x6c, 0x78, 0x8c, 0x9e, 0xbb, 0xd2, 0xe6\n\t};\n\tu8 addr = REG_GSP;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(gamma_curve); i++) {\n\t\tint ret = ov965x_write(ov965x, addr, gamma_curve[i]);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\taddr++;\n\t}\n\n\treturn 0;\n};\n\nstatic int ov965x_set_color_matrix(struct ov965x *ov965x)\n{\n\tstatic const u8 mtx[] = {\n\t\t \n\t\t0x3a, 0x3d, 0x03, 0x12, 0x26, 0x38, 0x40, 0x40, 0x40, 0x0d\n\t};\n\tu8 addr = REG_MTX(1);\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mtx); i++) {\n\t\tint ret = ov965x_write(ov965x, addr, mtx[i]);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\taddr++;\n\t}\n\n\treturn 0;\n}\n\nstatic int __ov965x_set_power(struct ov965x *ov965x, int on)\n{\n\tif (on) {\n\t\tint ret = clk_prepare_enable(ov965x->clk);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tgpiod_set_value_cansleep(ov965x->gpios[GPIO_PWDN], 0);\n\t\tgpiod_set_value_cansleep(ov965x->gpios[GPIO_RST], 0);\n\t\tmsleep(25);\n\t} else {\n\t\tgpiod_set_value_cansleep(ov965x->gpios[GPIO_RST], 1);\n\t\tgpiod_set_value_cansleep(ov965x->gpios[GPIO_PWDN], 1);\n\n\t\tclk_disable_unprepare(ov965x->clk);\n\t}\n\n\tov965x->streaming = 0;\n\n\treturn 0;\n}\n\nstatic int ov965x_s_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct ov965x *ov965x = to_ov965x(sd);\n\tint ret = 0;\n\n\tv4l2_dbg(1, debug, sd, \"%s: on: %d\\n\", __func__, on);\n\n\tmutex_lock(&ov965x->lock);\n\tif (ov965x->power == !on) {\n\t\tret = __ov965x_set_power(ov965x, on);\n\t\tif (!ret && on) {\n\t\t\tret = ov965x_write_array(ov965x,\n\t\t\t\t\t\t ov965x_init_regs);\n\t\t\tov965x->apply_frame_fmt = 1;\n\t\t\tov965x->ctrls.update = 1;\n\t\t}\n\t}\n\tif (!ret)\n\t\tov965x->power += on ? 1 : -1;\n\n\tWARN_ON(ov965x->power < 0);\n\tmutex_unlock(&ov965x->lock);\n\treturn ret;\n}\n\n \n\nstatic void ov965x_update_exposure_ctrl(struct ov965x *ov965x)\n{\n\tstruct v4l2_ctrl *ctrl = ov965x->ctrls.exposure;\n\tunsigned long fint, trow;\n\tint min, max, def;\n\tu8 clkrc;\n\n\tmutex_lock(&ov965x->lock);\n\tif (WARN_ON(!ctrl || !ov965x->frame_size)) {\n\t\tmutex_unlock(&ov965x->lock);\n\t\treturn;\n\t}\n\tclkrc = DEF_CLKRC + ov965x->fiv->clkrc_div;\n\t \n\tfint = ov965x->mclk_frequency * ((clkrc >> 7) + 1) /\n\t\t\t\t((2 * ((clkrc & 0x3f) + 1)));\n\t \n\ttrow = (2 * 1520 * 1000000UL) / fint;\n\tmax = ov965x->frame_size->max_exp_lines * trow;\n\tov965x->exp_row_interval = trow;\n\tmutex_unlock(&ov965x->lock);\n\n\tv4l2_dbg(1, debug, &ov965x->sd, \"clkrc: %#x, fi: %lu, tr: %lu, %d\\n\",\n\t\t clkrc, fint, trow, max);\n\n\t \n\tmin = (trow + 100) / 100;\n\tmax = (max - 100) / 100;\n\tdef = min + (max - min) / 2;\n\n\tif (v4l2_ctrl_modify_range(ctrl, min, max, 1, def))\n\t\tv4l2_err(&ov965x->sd, \"Exposure ctrl range update failed\\n\");\n}\n\nstatic int ov965x_set_banding_filter(struct ov965x *ov965x, int value)\n{\n\tunsigned long mbd, light_freq;\n\tint ret;\n\tu8 reg;\n\n\tret = ov965x_read(ov965x, REG_COM8, &reg);\n\tif (!ret) {\n\t\tif (value == V4L2_CID_POWER_LINE_FREQUENCY_DISABLED)\n\t\t\treg &= ~COM8_BFILT;\n\t\telse\n\t\t\treg |= COM8_BFILT;\n\t\tret = ov965x_write(ov965x, REG_COM8, reg);\n\t}\n\tif (value == V4L2_CID_POWER_LINE_FREQUENCY_DISABLED)\n\t\treturn 0;\n\tif (WARN_ON(!ov965x->fiv))\n\t\treturn -EINVAL;\n\t \n\tif (value == V4L2_CID_POWER_LINE_FREQUENCY_50HZ)\n\t\tlight_freq = 50;\n\telse\n\t\tlight_freq = 60;\n\tmbd = (1000UL * ov965x->fiv->interval.denominator *\n\t       ov965x->frame_size->max_exp_lines) /\n\t       ov965x->fiv->interval.numerator;\n\tmbd = ((mbd / (light_freq * 2)) + 500) / 1000UL;\n\n\treturn ov965x_write(ov965x, REG_MBD, mbd);\n}\n\nstatic int ov965x_set_white_balance(struct ov965x *ov965x, int awb)\n{\n\tint ret;\n\tu8 reg;\n\n\tret = ov965x_read(ov965x, REG_COM8, &reg);\n\tif (!ret) {\n\t\treg = awb ? reg | REG_COM8 : reg & ~REG_COM8;\n\t\tret = ov965x_write(ov965x, REG_COM8, reg);\n\t}\n\tif (!ret && !awb) {\n\t\tret = ov965x_write(ov965x, REG_BLUE,\n\t\t\t\t   ov965x->ctrls.blue_balance->val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = ov965x_write(ov965x, REG_RED,\n\t\t\t\t   ov965x->ctrls.red_balance->val);\n\t}\n\treturn ret;\n}\n\n#define NUM_BR_LEVELS\t7\n#define NUM_BR_REGS\t3\n\nstatic int ov965x_set_brightness(struct ov965x *ov965x, int val)\n{\n\tstatic const u8 regs[NUM_BR_LEVELS + 1][NUM_BR_REGS] = {\n\t\t{ REG_AEW, REG_AEB, REG_VPT },\n\t\t{ 0x1c, 0x12, 0x50 },  \n\t\t{ 0x3d, 0x30, 0x71 },  \n\t\t{ 0x50, 0x44, 0x92 },  \n\t\t{ 0x70, 0x64, 0xc3 },  \n\t\t{ 0x90, 0x84, 0xd4 },  \n\t\t{ 0xc4, 0xbf, 0xf9 },  \n\t\t{ 0xd8, 0xd0, 0xfa },  \n\t};\n\tint i, ret = 0;\n\n\tval += (NUM_BR_LEVELS / 2 + 1);\n\tif (val > NUM_BR_LEVELS)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < NUM_BR_REGS && !ret; i++)\n\t\tret = ov965x_write(ov965x, regs[0][i],\n\t\t\t\t   regs[val][i]);\n\treturn ret;\n}\n\nstatic int ov965x_set_gain(struct ov965x *ov965x, int auto_gain)\n{\n\tstruct ov965x_ctrls *ctrls = &ov965x->ctrls;\n\tint ret = 0;\n\tu8 reg;\n\t \n\tif (ctrls->auto_gain->is_new) {\n\t\tret = ov965x_read(ov965x, REG_COM8, &reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ctrls->auto_gain->val)\n\t\t\treg |= COM8_AGC;\n\t\telse\n\t\t\treg &= ~COM8_AGC;\n\t\tret = ov965x_write(ov965x, REG_COM8, reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (ctrls->gain->is_new && !auto_gain) {\n\t\tunsigned int gain = ctrls->gain->val;\n\t\tunsigned int rgain;\n\t\tint m;\n\t\t \n\t\tfor (m = 6; m >= 0; m--)\n\t\t\tif (gain >= (1 << m) * 16)\n\t\t\t\tbreak;\n\n\t\t \n\t\tif (m < 0)\n\t\t\treturn -EINVAL;\n\n\t\trgain = (gain - ((1 << m) * 16)) / (1 << m);\n\t\trgain |= (((1 << m) - 1) << 4);\n\n\t\tret = ov965x_write(ov965x, REG_GAIN, rgain & 0xff);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = ov965x_read(ov965x, REG_VREF, &reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treg &= ~VREF_GAIN_MASK;\n\t\treg |= (((rgain >> 8) & 0x3) << 6);\n\t\tret = ov965x_write(ov965x, REG_VREF, reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\tctrls->gain->val = (1 << m) * (16 + (rgain & 0xf));\n\t}\n\n\treturn ret;\n}\n\nstatic int ov965x_set_sharpness(struct ov965x *ov965x, unsigned int value)\n{\n\tu8 com14, edge;\n\tint ret;\n\n\tret = ov965x_read(ov965x, REG_COM14, &com14);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = ov965x_read(ov965x, REG_EDGE, &edge);\n\tif (ret < 0)\n\t\treturn ret;\n\tcom14 = value ? com14 | COM14_EDGE_EN : com14 & ~COM14_EDGE_EN;\n\tvalue--;\n\tif (value > 0x0f) {\n\t\tcom14 |= COM14_EEF_X2;\n\t\tvalue >>= 1;\n\t} else {\n\t\tcom14 &= ~COM14_EEF_X2;\n\t}\n\tret = ov965x_write(ov965x, REG_COM14, com14);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tedge &= ~EDGE_FACTOR_MASK;\n\tedge |= ((u8)value & 0x0f);\n\n\treturn ov965x_write(ov965x, REG_EDGE, edge);\n}\n\nstatic int ov965x_set_exposure(struct ov965x *ov965x, int exp)\n{\n\tstruct ov965x_ctrls *ctrls = &ov965x->ctrls;\n\tbool auto_exposure = (exp == V4L2_EXPOSURE_AUTO);\n\tint ret;\n\tu8 reg;\n\n\tif (ctrls->auto_exp->is_new) {\n\t\tret = ov965x_read(ov965x, REG_COM8, &reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (auto_exposure)\n\t\t\treg |= (COM8_AEC | COM8_AGC);\n\t\telse\n\t\t\treg &= ~(COM8_AEC | COM8_AGC);\n\t\tret = ov965x_write(ov965x, REG_COM8, reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (!auto_exposure && ctrls->exposure->is_new) {\n\t\tunsigned int exposure = (ctrls->exposure->val * 100)\n\t\t\t\t\t / ov965x->exp_row_interval;\n\t\t \n\t\tret = ov965x_write(ov965x, REG_COM1, exposure & 0x3);\n\t\tif (!ret)\n\t\t\tret = ov965x_write(ov965x, REG_AECH,\n\t\t\t\t\t   (exposure >> 2) & 0xff);\n\t\tif (!ret)\n\t\t\tret = ov965x_write(ov965x, REG_AECHM,\n\t\t\t\t\t   (exposure >> 10) & 0x3f);\n\t\t \n\t\tctrls->exposure->val = ((exposure * ov965x->exp_row_interval)\n\t\t\t\t\t\t\t+ 50) / 100;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tv4l2_ctrl_activate(ov965x->ctrls.brightness, !exp);\n\treturn 0;\n}\n\nstatic int ov965x_set_flip(struct ov965x *ov965x)\n{\n\tu8 mvfp = 0;\n\n\tif (ov965x->ctrls.hflip->val)\n\t\tmvfp |= MVFP_MIRROR;\n\n\tif (ov965x->ctrls.vflip->val)\n\t\tmvfp |= MVFP_FLIP;\n\n\treturn ov965x_write(ov965x, REG_MVFP, mvfp);\n}\n\n#define NUM_SAT_LEVELS\t5\n#define NUM_SAT_REGS\t6\n\nstatic int ov965x_set_saturation(struct ov965x *ov965x, int val)\n{\n\tstatic const u8 regs[NUM_SAT_LEVELS][NUM_SAT_REGS] = {\n\t\t \n\t\t{ 0x1d, 0x1f, 0x02, 0x09, 0x13, 0x1c },  \n\t\t{ 0x2e, 0x31, 0x02, 0x0e, 0x1e, 0x2d },  \n\t\t{ 0x3a, 0x3d, 0x03, 0x12, 0x26, 0x38 },  \n\t\t{ 0x46, 0x49, 0x04, 0x16, 0x2e, 0x43 },  \n\t\t{ 0x57, 0x5c, 0x05, 0x1b, 0x39, 0x54 },  \n\t};\n\tu8 addr = REG_MTX(1);\n\tint i, ret = 0;\n\n\tval += (NUM_SAT_LEVELS / 2);\n\tif (val >= NUM_SAT_LEVELS)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < NUM_SAT_REGS && !ret; i++)\n\t\tret = ov965x_write(ov965x, addr + i, regs[val][i]);\n\n\treturn ret;\n}\n\nstatic int ov965x_set_test_pattern(struct ov965x *ov965x, int value)\n{\n\tint ret;\n\tu8 reg;\n\n\tret = ov965x_read(ov965x, REG_COM23, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\treg = value ? reg | COM23_TEST_MODE : reg & ~COM23_TEST_MODE;\n\treturn ov965x_write(ov965x, REG_COM23, reg);\n}\n\nstatic int __g_volatile_ctrl(struct ov965x *ov965x, struct v4l2_ctrl *ctrl)\n{\n\tunsigned int exposure, gain, m;\n\tu8 reg0, reg1, reg2;\n\tint ret;\n\n\tif (!ov965x->power)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTOGAIN:\n\t\tif (!ctrl->val)\n\t\t\treturn 0;\n\t\tret = ov965x_read(ov965x, REG_GAIN, &reg0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = ov965x_read(ov965x, REG_VREF, &reg1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgain = ((reg1 >> 6) << 8) | reg0;\n\t\tm = 0x01 << fls(gain >> 4);\n\t\tov965x->ctrls.gain->val = m * (16 + (gain & 0xf));\n\t\tbreak;\n\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tif (ctrl->val == V4L2_EXPOSURE_MANUAL)\n\t\t\treturn 0;\n\t\tret = ov965x_read(ov965x, REG_COM1, &reg0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = ov965x_read(ov965x, REG_AECH, &reg1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = ov965x_read(ov965x, REG_AECHM, &reg2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\texposure = ((reg2 & 0x3f) << 10) | (reg1 << 2) |\n\t\t\t\t\t\t(reg0 & 0x3);\n\t\tov965x->ctrls.exposure->val = ((exposure *\n\t\t\t\tov965x->exp_row_interval) + 50) / 100;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov965x_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = ctrl_to_sd(ctrl);\n\tstruct ov965x *ov965x = to_ov965x(sd);\n\tint ret;\n\n\tv4l2_dbg(1, debug, sd, \"g_ctrl: %s\\n\", ctrl->name);\n\n\tmutex_lock(&ov965x->lock);\n\tret = __g_volatile_ctrl(ov965x, ctrl);\n\tmutex_unlock(&ov965x->lock);\n\treturn ret;\n}\n\nstatic int ov965x_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = ctrl_to_sd(ctrl);\n\tstruct ov965x *ov965x = to_ov965x(sd);\n\tint ret = -EINVAL;\n\n\tv4l2_dbg(1, debug, sd, \"s_ctrl: %s, value: %d. power: %d\\n\",\n\t\t ctrl->name, ctrl->val, ov965x->power);\n\n\tmutex_lock(&ov965x->lock);\n\t \n\tif (ov965x->power == 0) {\n\t\tmutex_unlock(&ov965x->lock);\n\t\treturn 0;\n\t}\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\tret = ov965x_set_white_balance(ov965x, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tret = ov965x_set_brightness(ov965x, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tret = ov965x_set_exposure(ov965x, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_AUTOGAIN:\n\t\tret = ov965x_set_gain(ov965x, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_HFLIP:\n\t\tret = ov965x_set_flip(ov965x);\n\t\tbreak;\n\n\tcase V4L2_CID_POWER_LINE_FREQUENCY:\n\t\tret = ov965x_set_banding_filter(ov965x, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_SATURATION:\n\t\tret = ov965x_set_saturation(ov965x, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_SHARPNESS:\n\t\tret = ov965x_set_sharpness(ov965x, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tret = ov965x_set_test_pattern(ov965x, ctrl->val);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&ov965x->lock);\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops ov965x_ctrl_ops = {\n\t.g_volatile_ctrl = ov965x_g_volatile_ctrl,\n\t.s_ctrl\t= ov965x_s_ctrl,\n};\n\nstatic const char * const test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Color bars\",\n};\n\nstatic int ov965x_initialize_controls(struct ov965x *ov965x)\n{\n\tconst struct v4l2_ctrl_ops *ops = &ov965x_ctrl_ops;\n\tstruct ov965x_ctrls *ctrls = &ov965x->ctrls;\n\tstruct v4l2_ctrl_handler *hdl = &ctrls->handler;\n\tint ret;\n\n\tret = v4l2_ctrl_handler_init(hdl, 16);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tctrls->auto_wb = v4l2_ctrl_new_std(hdl, ops,\n\t\t\t\t\t   V4L2_CID_AUTO_WHITE_BALANCE,\n\t\t\t\t\t   0, 1, 1, 1);\n\tctrls->blue_balance = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_BLUE_BALANCE,\n\t\t\t\t\t\t0, 0xff, 1, 0x80);\n\tctrls->red_balance = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_RED_BALANCE,\n\t\t\t\t\t       0, 0xff, 1, 0x80);\n\t \n\tctrls->auto_exp =\n\t\tv4l2_ctrl_new_std_menu(hdl, ops,\n\t\t\t\t       V4L2_CID_EXPOSURE_AUTO,\n\t\t\t\t       V4L2_EXPOSURE_MANUAL, 0,\n\t\t\t\t       V4L2_EXPOSURE_AUTO);\n\t \n\tctrls->exposure = v4l2_ctrl_new_std(hdl, ops,\n\t\t\t\t\t    V4L2_CID_EXPOSURE_ABSOLUTE,\n\t\t\t\t\t    2, 1500, 1, 500);\n\t \n\tctrls->auto_gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_AUTOGAIN,\n\t\t\t\t\t     0, 1, 1, 1);\n\tctrls->gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_GAIN,\n\t\t\t\t\t16, 64 * (16 + 15), 1, 64 * 16);\n\n\tctrls->saturation = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_SATURATION,\n\t\t\t\t\t      -2, 2, 1, 0);\n\tctrls->brightness = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_BRIGHTNESS,\n\t\t\t\t\t      -3, 3, 1, 0);\n\tctrls->sharpness = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_SHARPNESS,\n\t\t\t\t\t     0, 32, 1, 6);\n\n\tctrls->hflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HFLIP, 0, 1, 1, 0);\n\tctrls->vflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VFLIP, 0, 1, 1, 0);\n\n\tctrls->light_freq =\n\t\tv4l2_ctrl_new_std_menu(hdl, ops,\n\t\t\t\t       V4L2_CID_POWER_LINE_FREQUENCY,\n\t\t\t\t       V4L2_CID_POWER_LINE_FREQUENCY_60HZ, ~0x7,\n\t\t\t\t       V4L2_CID_POWER_LINE_FREQUENCY_50HZ);\n\n\tv4l2_ctrl_new_std_menu_items(hdl, ops, V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(test_pattern_menu) - 1, 0, 0,\n\t\t\t\t     test_pattern_menu);\n\tif (hdl->error) {\n\t\tret = hdl->error;\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\treturn ret;\n\t}\n\n\tctrls->gain->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\tctrls->exposure->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\n\tv4l2_ctrl_auto_cluster(3, &ctrls->auto_wb, 0, false);\n\tv4l2_ctrl_auto_cluster(2, &ctrls->auto_gain, 0, true);\n\tv4l2_ctrl_auto_cluster(2, &ctrls->auto_exp, 1, true);\n\tv4l2_ctrl_cluster(2, &ctrls->hflip);\n\n\tov965x->sd.ctrl_handler = hdl;\n\treturn 0;\n}\n\n \nstatic void ov965x_get_default_format(struct v4l2_mbus_framefmt *mf)\n{\n\tmf->width = ov965x_framesizes[0].width;\n\tmf->height = ov965x_framesizes[0].height;\n\tmf->colorspace = ov965x_formats[0].colorspace;\n\tmf->code = ov965x_formats[0].code;\n\tmf->field = V4L2_FIELD_NONE;\n}\n\nstatic int ov965x_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index >= ARRAY_SIZE(ov965x_formats))\n\t\treturn -EINVAL;\n\n\tcode->code = ov965x_formats[code->index].code;\n\treturn 0;\n}\n\nstatic int ov965x_enum_frame_sizes(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_frame_size_enum *fse)\n{\n\tint i = ARRAY_SIZE(ov965x_formats);\n\n\tif (fse->index >= ARRAY_SIZE(ov965x_framesizes))\n\t\treturn -EINVAL;\n\n\twhile (--i)\n\t\tif (fse->code == ov965x_formats[i].code)\n\t\t\tbreak;\n\n\tfse->code = ov965x_formats[i].code;\n\n\tfse->min_width  = ov965x_framesizes[fse->index].width;\n\tfse->max_width  = fse->min_width;\n\tfse->max_height = ov965x_framesizes[fse->index].height;\n\tfse->min_height = fse->max_height;\n\n\treturn 0;\n}\n\nstatic int ov965x_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *fi)\n{\n\tstruct ov965x *ov965x = to_ov965x(sd);\n\n\tmutex_lock(&ov965x->lock);\n\tfi->interval = ov965x->fiv->interval;\n\tmutex_unlock(&ov965x->lock);\n\n\treturn 0;\n}\n\nstatic int __ov965x_set_frame_interval(struct ov965x *ov965x,\n\t\t\t\t       struct v4l2_subdev_frame_interval *fi)\n{\n\tstruct v4l2_mbus_framefmt *mbus_fmt = &ov965x->format;\n\tconst struct ov965x_interval *fiv = &ov965x_intervals[0];\n\tu64 req_int, err, min_err = ~0ULL;\n\tunsigned int i;\n\n\tif (fi->interval.denominator == 0)\n\t\treturn -EINVAL;\n\n\treq_int = (u64)fi->interval.numerator * 10000;\n\tdo_div(req_int, fi->interval.denominator);\n\n\tfor (i = 0; i < ARRAY_SIZE(ov965x_intervals); i++) {\n\t\tconst struct ov965x_interval *iv = &ov965x_intervals[i];\n\n\t\tif (mbus_fmt->width != iv->size.width ||\n\t\t    mbus_fmt->height != iv->size.height)\n\t\t\tcontinue;\n\t\terr = abs((u64)(iv->interval.numerator * 10000) /\n\t\t\t    iv->interval.denominator - req_int);\n\t\tif (err < min_err) {\n\t\t\tfiv = iv;\n\t\t\tmin_err = err;\n\t\t}\n\t}\n\tov965x->fiv = fiv;\n\n\tv4l2_dbg(1, debug, &ov965x->sd, \"Changed frame interval to %u us\\n\",\n\t\t fiv->interval.numerator * 1000000 / fiv->interval.denominator);\n\n\treturn 0;\n}\n\nstatic int ov965x_s_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *fi)\n{\n\tstruct ov965x *ov965x = to_ov965x(sd);\n\tint ret;\n\n\tv4l2_dbg(1, debug, sd, \"Setting %d/%d frame interval\\n\",\n\t\t fi->interval.numerator, fi->interval.denominator);\n\n\tmutex_lock(&ov965x->lock);\n\tret = __ov965x_set_frame_interval(ov965x, fi);\n\tov965x->apply_frame_fmt = 1;\n\tmutex_unlock(&ov965x->lock);\n\treturn ret;\n}\n\nstatic int ov965x_get_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *fmt)\n{\n\tstruct ov965x *ov965x = to_ov965x(sd);\n\tstruct v4l2_mbus_framefmt *mf;\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tmf = v4l2_subdev_get_try_format(sd, sd_state, 0);\n\t\tfmt->format = *mf;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&ov965x->lock);\n\tfmt->format = ov965x->format;\n\tmutex_unlock(&ov965x->lock);\n\n\treturn 0;\n}\n\nstatic void __ov965x_try_frame_size(struct v4l2_mbus_framefmt *mf,\n\t\t\t\t    const struct ov965x_framesize **size)\n{\n\tconst struct ov965x_framesize *fsize = &ov965x_framesizes[0],\n\t\t*match = NULL;\n\tint i = ARRAY_SIZE(ov965x_framesizes);\n\tunsigned int min_err = UINT_MAX;\n\n\twhile (i--) {\n\t\tint err = abs(fsize->width - mf->width)\n\t\t\t\t+ abs(fsize->height - mf->height);\n\t\tif (err < min_err) {\n\t\t\tmin_err = err;\n\t\t\tmatch = fsize;\n\t\t}\n\t\tfsize++;\n\t}\n\tif (!match)\n\t\tmatch = &ov965x_framesizes[0];\n\tmf->width  = match->width;\n\tmf->height = match->height;\n\tif (size)\n\t\t*size = match;\n}\n\nstatic int ov965x_set_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *fmt)\n{\n\tunsigned int index = ARRAY_SIZE(ov965x_formats);\n\tstruct v4l2_mbus_framefmt *mf = &fmt->format;\n\tstruct ov965x *ov965x = to_ov965x(sd);\n\tconst struct ov965x_framesize *size = NULL;\n\tint ret = 0;\n\n\t__ov965x_try_frame_size(mf, &size);\n\n\twhile (--index)\n\t\tif (ov965x_formats[index].code == mf->code)\n\t\t\tbreak;\n\n\tmf->colorspace\t= V4L2_COLORSPACE_JPEG;\n\tmf->code\t= ov965x_formats[index].code;\n\tmf->field\t= V4L2_FIELD_NONE;\n\n\tmutex_lock(&ov965x->lock);\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tif (sd_state) {\n\t\t\tmf = v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t\t\tfmt->pad);\n\t\t\t*mf = fmt->format;\n\t\t}\n\t} else {\n\t\tif (ov965x->streaming) {\n\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\tov965x->frame_size = size;\n\t\t\tov965x->format = fmt->format;\n\t\t\tov965x->tslb_reg = ov965x_formats[index].tslb_reg;\n\t\t\tov965x->apply_frame_fmt = 1;\n\t\t}\n\t}\n\n\tif (!ret && fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\tstruct v4l2_subdev_frame_interval fiv = {\n\t\t\t.interval = { 0, 1 }\n\t\t};\n\t\t \n\t\t__ov965x_set_frame_interval(ov965x, &fiv);\n\t}\n\tmutex_unlock(&ov965x->lock);\n\n\tif (!ret)\n\t\tov965x_update_exposure_ctrl(ov965x);\n\n\treturn ret;\n}\n\nstatic int ov965x_set_frame_size(struct ov965x *ov965x)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; ret == 0 && i < NUM_FMT_REGS; i++)\n\t\tret = ov965x_write(ov965x, frame_size_reg_addr[i],\n\t\t\t\t   ov965x->frame_size->regs[i]);\n\treturn ret;\n}\n\nstatic int __ov965x_set_params(struct ov965x *ov965x)\n{\n\tstruct ov965x_ctrls *ctrls = &ov965x->ctrls;\n\tint ret = 0;\n\tu8 reg;\n\n\tif (ov965x->apply_frame_fmt) {\n\t\treg = DEF_CLKRC + ov965x->fiv->clkrc_div;\n\t\tret = ov965x_write(ov965x, REG_CLKRC, reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = ov965x_set_frame_size(ov965x);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = ov965x_read(ov965x, REG_TSLB, &reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treg &= ~TSLB_YUYV_MASK;\n\t\treg |= ov965x->tslb_reg;\n\t\tret = ov965x_write(ov965x, REG_TSLB, reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tret = ov965x_set_default_gamma_curve(ov965x);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = ov965x_set_color_matrix(ov965x);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tret = ov965x_read(ov965x, REG_COM11, &reg);\n\tif (!ret)\n\t\treg |= COM11_BANDING;\n\tret = ov965x_write(ov965x, REG_COM11, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\treturn ov965x_set_banding_filter(ov965x, ctrls->light_freq->val);\n}\n\nstatic int ov965x_s_stream(struct v4l2_subdev *sd, int on)\n{\n\tstruct ov965x *ov965x = to_ov965x(sd);\n\tstruct ov965x_ctrls *ctrls = &ov965x->ctrls;\n\tint ret = 0;\n\n\tv4l2_dbg(1, debug, sd, \"%s: on: %d\\n\", __func__, on);\n\n\tmutex_lock(&ov965x->lock);\n\tif (ov965x->streaming == !on) {\n\t\tif (on)\n\t\t\tret = __ov965x_set_params(ov965x);\n\n\t\tif (!ret && ctrls->update) {\n\t\t\t \n\t\t\tmutex_unlock(&ov965x->lock);\n\t\t\tret = v4l2_ctrl_handler_setup(&ctrls->handler);\n\n\t\t\tmutex_lock(&ov965x->lock);\n\t\t\tif (!ret)\n\t\t\t\tctrls->update = 0;\n\t\t}\n\t\tif (!ret)\n\t\t\tret = ov965x_write(ov965x, REG_COM2,\n\t\t\t\t\t   on ? 0x01 : 0x11);\n\t}\n\tif (!ret)\n\t\tov965x->streaming += on ? 1 : -1;\n\n\tWARN_ON(ov965x->streaming < 0);\n\tmutex_unlock(&ov965x->lock);\n\n\treturn ret;\n}\n\n \nstatic int ov965x_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_mbus_framefmt *mf =\n\t\tv4l2_subdev_get_try_format(sd, fh->state, 0);\n\n\tov965x_get_default_format(mf);\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops ov965x_pad_ops = {\n\t.enum_mbus_code = ov965x_enum_mbus_code,\n\t.enum_frame_size = ov965x_enum_frame_sizes,\n\t.get_fmt = ov965x_get_fmt,\n\t.set_fmt = ov965x_set_fmt,\n};\n\nstatic const struct v4l2_subdev_video_ops ov965x_video_ops = {\n\t.s_stream = ov965x_s_stream,\n\t.g_frame_interval = ov965x_g_frame_interval,\n\t.s_frame_interval = ov965x_s_frame_interval,\n\n};\n\nstatic const struct v4l2_subdev_internal_ops ov965x_sd_internal_ops = {\n\t.open = ov965x_open,\n};\n\nstatic const struct v4l2_subdev_core_ops ov965x_core_ops = {\n\t.s_power = ov965x_s_power,\n\t.log_status = v4l2_ctrl_subdev_log_status,\n\t.subscribe_event = v4l2_ctrl_subdev_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n};\n\nstatic const struct v4l2_subdev_ops ov965x_subdev_ops = {\n\t.core = &ov965x_core_ops,\n\t.pad = &ov965x_pad_ops,\n\t.video = &ov965x_video_ops,\n};\n\nstatic int ov965x_configure_gpios(struct ov965x *ov965x)\n{\n\tstruct device *dev = regmap_get_device(ov965x->regmap);\n\n\tov965x->gpios[GPIO_PWDN] = devm_gpiod_get_optional(dev, \"powerdown\",\n\t\t\t\t\t\t\tGPIOD_OUT_HIGH);\n\tif (IS_ERR(ov965x->gpios[GPIO_PWDN])) {\n\t\tdev_info(dev, \"can't get %s GPIO\\n\", \"powerdown\");\n\t\treturn PTR_ERR(ov965x->gpios[GPIO_PWDN]);\n\t}\n\n\tov965x->gpios[GPIO_RST] = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t\tGPIOD_OUT_HIGH);\n\tif (IS_ERR(ov965x->gpios[GPIO_RST])) {\n\t\tdev_info(dev, \"can't get %s GPIO\\n\", \"reset\");\n\t\treturn PTR_ERR(ov965x->gpios[GPIO_RST]);\n\t}\n\n\treturn 0;\n}\n\nstatic int ov965x_detect_sensor(struct v4l2_subdev *sd)\n{\n\tstruct ov965x *ov965x = to_ov965x(sd);\n\tu8 pid, ver;\n\tint ret;\n\n\tmutex_lock(&ov965x->lock);\n\tret = __ov965x_set_power(ov965x, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tmsleep(25);\n\n\t \n\tret = ov965x_read(ov965x, REG_PID, &pid);\n\tif (!ret)\n\t\tret = ov965x_read(ov965x, REG_VER, &ver);\n\n\t__ov965x_set_power(ov965x, 0);\n\n\tif (!ret) {\n\t\tov965x->id = OV965X_ID(pid, ver);\n\t\tif (ov965x->id == OV9650_ID || ov965x->id == OV9652_ID) {\n\t\t\tv4l2_info(sd, \"Found OV%04X sensor\\n\", ov965x->id);\n\t\t} else {\n\t\t\tv4l2_err(sd, \"Sensor detection failed (%04X)\\n\",\n\t\t\t\t ov965x->id);\n\t\t\tret = -ENODEV;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&ov965x->lock);\n\n\treturn ret;\n}\n\nstatic int ov965x_probe(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd;\n\tstruct ov965x *ov965x;\n\tint ret;\n\tstatic const struct regmap_config ov965x_regmap_config = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = 0xab,\n\t};\n\n\tov965x = devm_kzalloc(&client->dev, sizeof(*ov965x), GFP_KERNEL);\n\tif (!ov965x)\n\t\treturn -ENOMEM;\n\n\tov965x->regmap = devm_regmap_init_sccb(client, &ov965x_regmap_config);\n\tif (IS_ERR(ov965x->regmap)) {\n\t\tdev_err(&client->dev, \"Failed to allocate register map\\n\");\n\t\treturn PTR_ERR(ov965x->regmap);\n\t}\n\n\tif (dev_fwnode(&client->dev)) {\n\t\tov965x->clk = devm_clk_get(&client->dev, NULL);\n\t\tif (IS_ERR(ov965x->clk))\n\t\t\treturn PTR_ERR(ov965x->clk);\n\t\tov965x->mclk_frequency = clk_get_rate(ov965x->clk);\n\n\t\tret = ov965x_configure_gpios(ov965x);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tdev_err(&client->dev,\n\t\t\t\"No device properties specified\\n\");\n\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_init(&ov965x->lock);\n\n\tsd = &ov965x->sd;\n\tv4l2_i2c_subdev_init(sd, client, &ov965x_subdev_ops);\n\tstrscpy(sd->name, DRIVER_NAME, sizeof(sd->name));\n\n\tsd->internal_ops = &ov965x_sd_internal_ops;\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |\n\t\t     V4L2_SUBDEV_FL_HAS_EVENTS;\n\n\tov965x->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tsd->entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tret = media_entity_pads_init(&sd->entity, 1, &ov965x->pad);\n\tif (ret < 0)\n\t\tgoto err_mutex;\n\n\tret = ov965x_initialize_controls(ov965x);\n\tif (ret < 0)\n\t\tgoto err_me;\n\n\tov965x_get_default_format(&ov965x->format);\n\tov965x->frame_size = &ov965x_framesizes[0];\n\tov965x->fiv = &ov965x_intervals[0];\n\n\tret = ov965x_detect_sensor(sd);\n\tif (ret < 0)\n\t\tgoto err_ctrls;\n\n\t \n\tov965x_update_exposure_ctrl(ov965x);\n\n\tret = v4l2_async_register_subdev(sd);\n\tif (ret < 0)\n\t\tgoto err_ctrls;\n\n\treturn 0;\nerr_ctrls:\n\tv4l2_ctrl_handler_free(sd->ctrl_handler);\nerr_me:\n\tmedia_entity_cleanup(&sd->entity);\nerr_mutex:\n\tmutex_destroy(&ov965x->lock);\n\treturn ret;\n}\n\nstatic void ov965x_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov965x *ov965x = to_ov965x(sd);\n\n\tv4l2_async_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(sd->ctrl_handler);\n\tmedia_entity_cleanup(&sd->entity);\n\tmutex_destroy(&ov965x->lock);\n}\n\nstatic const struct i2c_device_id ov965x_id[] = {\n\t{ \"OV9650\", 0 },\n\t{ \"OV9652\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, ov965x_id);\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id ov965x_of_match[] = {\n\t{ .compatible = \"ovti,ov9650\", },\n\t{ .compatible = \"ovti,ov9652\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ov965x_of_match);\n#endif\n\nstatic struct i2c_driver ov965x_i2c_driver = {\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table = of_match_ptr(ov965x_of_match),\n\t},\n\t.probe\t\t= ov965x_probe,\n\t.remove\t\t= ov965x_remove,\n\t.id_table\t= ov965x_id,\n};\n\nmodule_i2c_driver(ov965x_i2c_driver);\n\nMODULE_AUTHOR(\"Sylwester Nawrocki <sylvester.nawrocki@gmail.com>\");\nMODULE_DESCRIPTION(\"OV9650/OV9652 CMOS Image Sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}