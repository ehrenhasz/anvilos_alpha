{
  "module_name": "bt819.c",
  "hash_id": "425ee141a6808f1ea0313b384d10ed0ec1410f254e6fbff80755bb89f9e6d438",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/bt819.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/ioctl.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/videodev2.h>\n#include <linux/slab.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n#include <media/i2c/bt819.h>\n\nMODULE_DESCRIPTION(\"Brooktree-819 video decoder driver\");\nMODULE_AUTHOR(\"Mike Bernson & Dave Perks\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int debug;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"Debug level (0-1)\");\n\n\n \n\nstruct bt819 {\n\tstruct v4l2_subdev sd;\n\tstruct v4l2_ctrl_handler hdl;\n\tunsigned char reg[32];\n\n\tv4l2_std_id norm;\n\tint input;\n\tint enable;\n};\n\nstatic inline struct bt819 *to_bt819(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct bt819, sd);\n}\n\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct bt819, hdl)->sd;\n}\n\nstruct timing {\n\tint hactive;\n\tint hdelay;\n\tint vactive;\n\tint vdelay;\n\tint hscale;\n\tint vscale;\n};\n\n \nstatic struct timing timing_data[] = {\n\t{864 - 24, 20, 625 - 2, 1, 0x0504, 0x0000},\n\t{858 - 24, 20, 525 - 2, 1, 0x00f8, 0x0000},\n};\n\n \n\nstatic inline int bt819_write(struct bt819 *decoder, u8 reg, u8 value)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&decoder->sd);\n\n\tdecoder->reg[reg] = value;\n\treturn i2c_smbus_write_byte_data(client, reg, value);\n}\n\nstatic inline int bt819_setbit(struct bt819 *decoder, u8 reg, u8 bit, u8 value)\n{\n\treturn bt819_write(decoder, reg,\n\t\t(decoder->reg[reg] & ~(1 << bit)) | (value ? (1 << bit) : 0));\n}\n\nstatic int bt819_write_block(struct bt819 *decoder, const u8 *data, unsigned int len)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&decoder->sd);\n\tint ret = -1;\n\tu8 reg;\n\n\t \n\tif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\t \n\t\tu8 block_data[32];\n\t\tint block_len;\n\n\t\twhile (len >= 2) {\n\t\t\tblock_len = 0;\n\t\t\tblock_data[block_len++] = reg = data[0];\n\t\t\tdo {\n\t\t\t\tblock_data[block_len++] =\n\t\t\t\t    decoder->reg[reg++] = data[1];\n\t\t\t\tlen -= 2;\n\t\t\t\tdata += 2;\n\t\t\t} while (len >= 2 && data[0] == reg && block_len < 32);\n\t\t\tret = i2c_master_send(client, block_data, block_len);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\twhile (len >= 2) {\n\t\t\treg = *data++;\n\t\t\tret = bt819_write(decoder, reg, *data++);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tlen -= 2;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic inline int bt819_read(struct bt819 *decoder, u8 reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&decoder->sd);\n\n\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\nstatic int bt819_init(struct v4l2_subdev *sd)\n{\n\tstatic unsigned char init[] = {\n\t\t       \n\t\t0x01, 0x59,\t \n\t\t0x02, 0x00,\t \n\t\t0x03, 0x12,\t \n\t\t0x04, 0x16,\t \n\t\t0x05, 0xe0,\t \n\t\t0x06, 0x80,\t \n\t\t0x07, 0xd0,\t \n\t\t0x08, 0x00,\t \n\t\t0x09, 0xf8,\t \n\t\t0x0a, 0x00,\t \n\t\t0x0b, 0x30,\t \n\t\t0x0c, 0xd8,\t \n\t\t0x0d, 0xfe,\t \n\t\t0x0e, 0xb4,\t \n\t\t0x0f, 0x00,\t \n\t\t0x12, 0x04,\t \n\t\t0x13, 0x20,\t \n\t\t0x14, 0x00,\t \n\t\t0x16, 0x07,\t \n\t\t0x18, 0x68,\t \n\t\t0x19, 0x5d,\t \n\t\t0x1a, 0x80,\t \n\t};\n\n\tstruct bt819 *decoder = to_bt819(sd);\n\tstruct timing *timing = &timing_data[(decoder->norm & V4L2_STD_525_60) ? 1 : 0];\n\n\tinit[0x03 * 2 - 1] =\n\t    (((timing->vdelay >> 8) & 0x03) << 6) |\n\t    (((timing->vactive >> 8) & 0x03) << 4) |\n\t    (((timing->hdelay >> 8) & 0x03) << 2) |\n\t    ((timing->hactive >> 8) & 0x03);\n\tinit[0x04 * 2 - 1] = timing->vdelay & 0xff;\n\tinit[0x05 * 2 - 1] = timing->vactive & 0xff;\n\tinit[0x06 * 2 - 1] = timing->hdelay & 0xff;\n\tinit[0x07 * 2 - 1] = timing->hactive & 0xff;\n\tinit[0x08 * 2 - 1] = timing->hscale >> 8;\n\tinit[0x09 * 2 - 1] = timing->hscale & 0xff;\n\t \n\tinit[0x15 * 2 - 1] = (decoder->norm & V4L2_STD_625_50) ? 115 : 93;\t \n\t \n\tbt819_write(decoder, 0x1f, 0x00);\n\tmdelay(1);\n\n\t \n\treturn bt819_write_block(decoder, init, sizeof(init));\n}\n\n \n\nstatic int bt819_status(struct v4l2_subdev *sd, u32 *pstatus, v4l2_std_id *pstd)\n{\n\tstruct bt819 *decoder = to_bt819(sd);\n\tint status = bt819_read(decoder, 0x00);\n\tint res = V4L2_IN_ST_NO_SIGNAL;\n\tv4l2_std_id std = pstd ? *pstd : V4L2_STD_ALL;\n\n\tif ((status & 0x80))\n\t\tres = 0;\n\telse\n\t\tstd = V4L2_STD_UNKNOWN;\n\n\tif ((status & 0x10))\n\t\tstd &= V4L2_STD_PAL;\n\telse\n\t\tstd &= V4L2_STD_NTSC;\n\tif (pstd)\n\t\t*pstd = std;\n\tif (pstatus)\n\t\t*pstatus = res;\n\n\tv4l2_dbg(1, debug, sd, \"get status %x\\n\", status);\n\treturn 0;\n}\n\nstatic int bt819_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)\n{\n\treturn bt819_status(sd, NULL, std);\n}\n\nstatic int bt819_g_input_status(struct v4l2_subdev *sd, u32 *status)\n{\n\treturn bt819_status(sd, status, NULL);\n}\n\nstatic int bt819_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct bt819 *decoder = to_bt819(sd);\n\tstruct timing *timing = NULL;\n\n\tv4l2_dbg(1, debug, sd, \"set norm %llx\\n\", (unsigned long long)std);\n\n\tif (sd->v4l2_dev == NULL || sd->v4l2_dev->notify == NULL)\n\t\tv4l2_err(sd, \"no notify found!\\n\");\n\n\tif (std & V4L2_STD_NTSC) {\n\t\tv4l2_subdev_notify(sd, BT819_FIFO_RESET_LOW, NULL);\n\t\tbt819_setbit(decoder, 0x01, 0, 1);\n\t\tbt819_setbit(decoder, 0x01, 1, 0);\n\t\tbt819_setbit(decoder, 0x01, 5, 0);\n\t\tbt819_write(decoder, 0x18, 0x68);\n\t\tbt819_write(decoder, 0x19, 0x5d);\n\t\t \n\t\ttiming = &timing_data[1];\n\t} else if (std & V4L2_STD_PAL) {\n\t\tv4l2_subdev_notify(sd, BT819_FIFO_RESET_LOW, NULL);\n\t\tbt819_setbit(decoder, 0x01, 0, 1);\n\t\tbt819_setbit(decoder, 0x01, 1, 1);\n\t\tbt819_setbit(decoder, 0x01, 5, 1);\n\t\tbt819_write(decoder, 0x18, 0x7f);\n\t\tbt819_write(decoder, 0x19, 0x72);\n\t\t \n\t\ttiming = &timing_data[0];\n\t} else {\n\t\tv4l2_dbg(1, debug, sd, \"unsupported norm %llx\\n\",\n\t\t\t\t(unsigned long long)std);\n\t\treturn -EINVAL;\n\t}\n\tbt819_write(decoder, 0x03,\n\t\t\t(((timing->vdelay >> 8) & 0x03) << 6) |\n\t\t\t(((timing->vactive >> 8) & 0x03) << 4) |\n\t\t\t(((timing->hdelay >> 8) & 0x03) << 2) |\n\t\t\t((timing->hactive >> 8) & 0x03));\n\tbt819_write(decoder, 0x04, timing->vdelay & 0xff);\n\tbt819_write(decoder, 0x05, timing->vactive & 0xff);\n\tbt819_write(decoder, 0x06, timing->hdelay & 0xff);\n\tbt819_write(decoder, 0x07, timing->hactive & 0xff);\n\tbt819_write(decoder, 0x08, (timing->hscale >> 8) & 0xff);\n\tbt819_write(decoder, 0x09, timing->hscale & 0xff);\n\tdecoder->norm = std;\n\tv4l2_subdev_notify(sd, BT819_FIFO_RESET_HIGH, NULL);\n\treturn 0;\n}\n\nstatic int bt819_s_routing(struct v4l2_subdev *sd,\n\t\t\t   u32 input, u32 output, u32 config)\n{\n\tstruct bt819 *decoder = to_bt819(sd);\n\n\tv4l2_dbg(1, debug, sd, \"set input %x\\n\", input);\n\n\tif (input > 7)\n\t\treturn -EINVAL;\n\n\tif (sd->v4l2_dev == NULL || sd->v4l2_dev->notify == NULL)\n\t\tv4l2_err(sd, \"no notify found!\\n\");\n\n\tif (decoder->input != input) {\n\t\tv4l2_subdev_notify(sd, BT819_FIFO_RESET_LOW, NULL);\n\t\tdecoder->input = input;\n\t\t \n\t\tif (decoder->input == 0) {\n\t\t\tbt819_setbit(decoder, 0x0b, 6, 0);\n\t\t\tbt819_setbit(decoder, 0x1a, 1, 1);\n\t\t} else {\n\t\t\tbt819_setbit(decoder, 0x0b, 6, 1);\n\t\t\tbt819_setbit(decoder, 0x1a, 1, 0);\n\t\t}\n\t\tv4l2_subdev_notify(sd, BT819_FIFO_RESET_HIGH, NULL);\n\t}\n\treturn 0;\n}\n\nstatic int bt819_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct bt819 *decoder = to_bt819(sd);\n\n\tv4l2_dbg(1, debug, sd, \"enable output %x\\n\", enable);\n\n\tif (decoder->enable != enable) {\n\t\tdecoder->enable = enable;\n\t\tbt819_setbit(decoder, 0x16, 7, !enable);\n\t}\n\treturn 0;\n}\n\nstatic int bt819_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\tstruct bt819 *decoder = to_bt819(sd);\n\tint temp;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tbt819_write(decoder, 0x0a, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_CONTRAST:\n\t\tbt819_write(decoder, 0x0c, ctrl->val & 0xff);\n\t\tbt819_setbit(decoder, 0x0b, 2, ((ctrl->val >> 8) & 0x01));\n\t\tbreak;\n\n\tcase V4L2_CID_SATURATION:\n\t\tbt819_write(decoder, 0x0d, (ctrl->val >> 7) & 0xff);\n\t\tbt819_setbit(decoder, 0x0b, 1, ((ctrl->val >> 15) & 0x01));\n\n\t\t \n\t\ttemp = (ctrl->val * 180) / 254;\n\t\tbt819_write(decoder, 0x0e, (temp >> 7) & 0xff);\n\t\tbt819_setbit(decoder, 0x0b, 0, (temp >> 15) & 0x01);\n\t\tbreak;\n\n\tcase V4L2_CID_HUE:\n\t\tbt819_write(decoder, 0x0f, ctrl->val);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_ctrl_ops bt819_ctrl_ops = {\n\t.s_ctrl = bt819_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_video_ops bt819_video_ops = {\n\t.s_std = bt819_s_std,\n\t.s_routing = bt819_s_routing,\n\t.s_stream = bt819_s_stream,\n\t.querystd = bt819_querystd,\n\t.g_input_status = bt819_g_input_status,\n};\n\nstatic const struct v4l2_subdev_ops bt819_ops = {\n\t.video = &bt819_video_ops,\n};\n\n \n\nstatic int bt819_probe(struct i2c_client *client)\n{\n\tint i, ver;\n\tstruct bt819 *decoder;\n\tstruct v4l2_subdev *sd;\n\tconst char *name;\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tdecoder = devm_kzalloc(&client->dev, sizeof(*decoder), GFP_KERNEL);\n\tif (decoder == NULL)\n\t\treturn -ENOMEM;\n\tsd = &decoder->sd;\n\tv4l2_i2c_subdev_init(sd, client, &bt819_ops);\n\n\tver = bt819_read(decoder, 0x17);\n\tswitch (ver & 0xf0) {\n\tcase 0x70:\n\t\tname = \"bt819a\";\n\t\tbreak;\n\tcase 0x60:\n\t\tname = \"bt817a\";\n\t\tbreak;\n\tcase 0x20:\n\t\tname = \"bt815a\";\n\t\tbreak;\n\tdefault:\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t\"unknown chip version 0x%02x\\n\", ver);\n\t\treturn -ENODEV;\n\t}\n\n\tv4l_info(client, \"%s found @ 0x%x (%s)\\n\", name,\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tdecoder->norm = V4L2_STD_NTSC;\n\tdecoder->input = 0;\n\tdecoder->enable = 1;\n\n\ti = bt819_init(sd);\n\tif (i < 0)\n\t\tv4l2_dbg(1, debug, sd, \"init status %d\\n\", i);\n\n\tv4l2_ctrl_handler_init(&decoder->hdl, 4);\n\tv4l2_ctrl_new_std(&decoder->hdl, &bt819_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\n\tv4l2_ctrl_new_std(&decoder->hdl, &bt819_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 511, 1, 0xd8);\n\tv4l2_ctrl_new_std(&decoder->hdl, &bt819_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 511, 1, 0xfe);\n\tv4l2_ctrl_new_std(&decoder->hdl, &bt819_ctrl_ops,\n\t\t\tV4L2_CID_HUE, -128, 127, 1, 0);\n\tsd->ctrl_handler = &decoder->hdl;\n\tif (decoder->hdl.error) {\n\t\tint err = decoder->hdl.error;\n\n\t\tv4l2_ctrl_handler_free(&decoder->hdl);\n\t\treturn err;\n\t}\n\tv4l2_ctrl_handler_setup(&decoder->hdl);\n\treturn 0;\n}\n\nstatic void bt819_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct bt819 *decoder = to_bt819(sd);\n\n\tv4l2_device_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(&decoder->hdl);\n}\n\n \n\nstatic const struct i2c_device_id bt819_id[] = {\n\t{ \"bt819a\", 0 },\n\t{ \"bt817a\", 0 },\n\t{ \"bt815a\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, bt819_id);\n\nstatic struct i2c_driver bt819_driver = {\n\t.driver = {\n\t\t.name\t= \"bt819\",\n\t},\n\t.probe\t\t= bt819_probe,\n\t.remove\t\t= bt819_remove,\n\t.id_table\t= bt819_id,\n};\n\nmodule_i2c_driver(bt819_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}