{
  "module_name": "et8ek8_driver.c",
  "hash_id": "a23babfd294f79628b6f5634abcc8d5a336ee59b7462a3defe9ebe89999b0aca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/et8ek8/et8ek8_driver.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/v4l2-mediabus.h>\n\n#include <media/media-entity.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-subdev.h>\n\n#include \"et8ek8_reg.h\"\n\n#define ET8EK8_NAME\t\t\"et8ek8\"\n#define ET8EK8_PRIV_MEM_SIZE\t128\n#define ET8EK8_MAX_MSG\t\t8\n\nstruct et8ek8_sensor {\n\tstruct v4l2_subdev subdev;\n\tstruct media_pad pad;\n\tstruct v4l2_mbus_framefmt format;\n\tstruct gpio_desc *reset;\n\tstruct regulator *vana;\n\tstruct clk *ext_clk;\n\tu32 xclk_freq;\n\n\tu16 version;\n\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tstruct v4l2_ctrl *exposure;\n\tstruct v4l2_ctrl *pixel_rate;\n\tstruct et8ek8_reglist *current_reglist;\n\n\tu8 priv_mem[ET8EK8_PRIV_MEM_SIZE];\n\n\tstruct mutex power_lock;\n\tint power_count;\n};\n\n#define to_et8ek8_sensor(sd)\tcontainer_of(sd, struct et8ek8_sensor, subdev)\n\nenum et8ek8_versions {\n\tET8EK8_REV_1 = 0x0001,\n\tET8EK8_REV_2,\n};\n\n \nstatic struct et8ek8_gain {\n\tu16 analog;\n\tu16 digital;\n} const et8ek8_gain_table[] = {\n\t{ 32,    0},   \n\t{ 34,    0},\n\t{ 37,    0},\n\t{ 39,    0},\n\t{ 42,    0},\n\t{ 45,    0},\n\t{ 49,    0},\n\t{ 52,    0},\n\t{ 56,    0},\n\t{ 60,    0},\n\t{ 64,    0},   \n\t{ 69,    0},\n\t{ 74,    0},\n\t{ 79,    0},\n\t{ 84,    0},\n\t{ 91,    0},\n\t{ 97,    0},\n\t{104,    0},\n\t{111,    0},\n\t{119,    0},\n\t{128,    0},   \n\t{137,    0},\n\t{147,    0},\n\t{158,    0},\n\t{169,    0},\n\t{181,    0},\n\t{194,    0},\n\t{208,    0},\n\t{223,    0},\n\t{239,    0},\n\t{256,    0},   \n\t{256,   73},\n\t{256,  152},\n\t{256,  236},\n\t{256,  327},\n\t{256,  424},\n\t{256,  528},\n\t{256,  639},\n\t{256,  758},\n\t{256,  886},\n\t{256, 1023},   \n};\n\n \n#define REG_REVISION_NUMBER_L\t0x1200\n#define REG_REVISION_NUMBER_H\t0x1201\n\n#define PRIV_MEM_START_REG\t0x0008\n#define PRIV_MEM_WIN_SIZE\t8\n\n#define ET8EK8_I2C_DELAY\t3\t \n\n#define USE_CRC\t\t\t1\n\n \nstatic int et8ek8_i2c_read_reg(struct i2c_client *client, u16 data_length,\n\t\t\t       u16 reg, u32 *val)\n{\n\tint r;\n\tstruct i2c_msg msg;\n\tunsigned char data[4];\n\n\tif (!client->adapter)\n\t\treturn -ENODEV;\n\tif (data_length != ET8EK8_REG_8BIT && data_length != ET8EK8_REG_16BIT)\n\t\treturn -EINVAL;\n\n\tmsg.addr = client->addr;\n\tmsg.flags = 0;\n\tmsg.len = 2;\n\tmsg.buf = data;\n\n\t \n\tdata[0] = (u8) (reg >> 8);\n\tdata[1] = (u8) (reg & 0xff);\n\tr = i2c_transfer(client->adapter, &msg, 1);\n\tif (r < 0)\n\t\tgoto err;\n\n\tmsg.len = data_length;\n\tmsg.flags = I2C_M_RD;\n\tr = i2c_transfer(client->adapter, &msg, 1);\n\tif (r < 0)\n\t\tgoto err;\n\n\t*val = 0;\n\t \n\tif (data_length == ET8EK8_REG_8BIT)\n\t\t*val = data[0];\n\telse\n\t\t*val = (data[1] << 8) + data[0];\n\n\treturn 0;\n\nerr:\n\tdev_err(&client->dev, \"read from offset 0x%x error %d\\n\", reg, r);\n\n\treturn r;\n}\n\nstatic void et8ek8_i2c_create_msg(struct i2c_client *client, u16 len, u16 reg,\n\t\t\t\t  u32 val, struct i2c_msg *msg,\n\t\t\t\t  unsigned char *buf)\n{\n\tmsg->addr = client->addr;\n\tmsg->flags = 0;  \n\tmsg->len = 2 + len;\n\tmsg->buf = buf;\n\n\t \n\tbuf[0] = (u8) (reg >> 8);\n\tbuf[1] = (u8) (reg & 0xff);\n\n\tswitch (len) {\n\tcase ET8EK8_REG_8BIT:\n\t\tbuf[2] = (u8) (val) & 0xff;\n\t\tbreak;\n\tcase ET8EK8_REG_16BIT:\n\t\tbuf[2] = (u8) (val) & 0xff;\n\t\tbuf[3] = (u8) (val >> 8) & 0xff;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, ET8EK8_NAME \": %s: invalid message length.\\n\",\n\t\t\t  __func__);\n\t}\n}\n\n \nstatic int et8ek8_i2c_buffered_write_regs(struct i2c_client *client,\n\t\t\t\t\t  const struct et8ek8_reg *wnext,\n\t\t\t\t\t  int cnt)\n{\n\tstruct i2c_msg msg[ET8EK8_MAX_MSG];\n\tunsigned char data[ET8EK8_MAX_MSG][6];\n\tint wcnt = 0;\n\tu16 reg, data_length;\n\tu32 val;\n\tint rval;\n\n\t \n\twhile (wcnt < cnt) {\n\t\tdata_length = wnext->type;\n\t\treg = wnext->reg;\n\t\tval = wnext->val;\n\t\twnext++;\n\n\t\tet8ek8_i2c_create_msg(client, data_length, reg,\n\t\t\t\t    val, &msg[wcnt], &data[wcnt][0]);\n\n\t\t \n\t\twcnt++;\n\n\t\tif (wcnt < ET8EK8_MAX_MSG)\n\t\t\tcontinue;\n\n\t\trval = i2c_transfer(client->adapter, msg, wcnt);\n\t\tif (rval < 0)\n\t\t\treturn rval;\n\n\t\tcnt -= wcnt;\n\t\twcnt = 0;\n\t}\n\n\trval = i2c_transfer(client->adapter, msg, wcnt);\n\n\treturn rval < 0 ? rval : 0;\n}\n\n \nstatic int et8ek8_i2c_write_regs(struct i2c_client *client,\n\t\t\t\t const struct et8ek8_reg *regs)\n{\n\tint r, cnt = 0;\n\tconst struct et8ek8_reg *next;\n\n\tif (!client->adapter)\n\t\treturn -ENODEV;\n\n\tif (!regs)\n\t\treturn -EINVAL;\n\n\t \n\tnext = regs;\n\n\tdo {\n\t\t \n\t\twhile (next->type != ET8EK8_REG_TERM &&\n\t\t       next->type != ET8EK8_REG_DELAY) {\n\t\t\t \n\t\t\tif (WARN(next->type != ET8EK8_REG_8BIT &&\n\t\t\t\t next->type != ET8EK8_REG_16BIT,\n\t\t\t\t \"Invalid type = %d\", next->type)) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t \n\t\t\tcnt++;\n\t\t\tnext++;\n\t\t}\n\n\t\t \n\t\tr = et8ek8_i2c_buffered_write_regs(client, regs, cnt);\n\n\t\t \n\t\tif (r < 0) {\n\t\t\tdev_err(&client->dev, \"i2c transfer error!\\n\");\n\t\t\treturn r;\n\t\t}\n\n\t\t \n\t\tif (next->type == ET8EK8_REG_DELAY) {\n\t\t\tmsleep(next->val);\n\t\t\t \n\t\t\tnext++;\n\t\t\tregs = next;\n\t\t\tcnt = 0;\n\t\t}\n\t} while (next->type != ET8EK8_REG_TERM);\n\n\treturn 0;\n}\n\n \nstatic int et8ek8_i2c_write_reg(struct i2c_client *client, u16 data_length,\n\t\t\t\tu16 reg, u32 val)\n{\n\tint r;\n\tstruct i2c_msg msg;\n\tunsigned char data[6];\n\n\tif (!client->adapter)\n\t\treturn -ENODEV;\n\tif (data_length != ET8EK8_REG_8BIT && data_length != ET8EK8_REG_16BIT)\n\t\treturn -EINVAL;\n\n\tet8ek8_i2c_create_msg(client, data_length, reg, val, &msg, data);\n\n\tr = i2c_transfer(client->adapter, &msg, 1);\n\tif (r < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"wrote 0x%x to offset 0x%x error %d\\n\", val, reg, r);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic struct et8ek8_reglist *et8ek8_reglist_find_type(\n\t\tstruct et8ek8_meta_reglist *meta,\n\t\tu16 type)\n{\n\tstruct et8ek8_reglist **next = &meta->reglist[0].ptr;\n\n\twhile (*next) {\n\t\tif ((*next)->type == type)\n\t\t\treturn *next;\n\n\t\tnext++;\n\t}\n\n\treturn NULL;\n}\n\nstatic int et8ek8_i2c_reglist_find_write(struct i2c_client *client,\n\t\t\t\t\t struct et8ek8_meta_reglist *meta,\n\t\t\t\t\t u16 type)\n{\n\tstruct et8ek8_reglist *reglist;\n\n\treglist = et8ek8_reglist_find_type(meta, type);\n\tif (!reglist)\n\t\treturn -EINVAL;\n\n\treturn et8ek8_i2c_write_regs(client, reglist->regs);\n}\n\nstatic struct et8ek8_reglist **et8ek8_reglist_first(\n\t\tstruct et8ek8_meta_reglist *meta)\n{\n\treturn &meta->reglist[0].ptr;\n}\n\nstatic void et8ek8_reglist_to_mbus(const struct et8ek8_reglist *reglist,\n\t\t\t\t   struct v4l2_mbus_framefmt *fmt)\n{\n\tfmt->width = reglist->mode.window_width;\n\tfmt->height = reglist->mode.window_height;\n\tfmt->code = reglist->mode.bus_format;\n}\n\nstatic struct et8ek8_reglist *et8ek8_reglist_find_mode_fmt(\n\t\tstruct et8ek8_meta_reglist *meta,\n\t\tstruct v4l2_mbus_framefmt *fmt)\n{\n\tstruct et8ek8_reglist **list = et8ek8_reglist_first(meta);\n\tstruct et8ek8_reglist *best_match = NULL;\n\tstruct et8ek8_reglist *best_other = NULL;\n\tstruct v4l2_mbus_framefmt format;\n\tunsigned int max_dist_match = (unsigned int)-1;\n\tunsigned int max_dist_other = (unsigned int)-1;\n\n\t \n\tfor (; *list; list++) {\n\t\tunsigned int dist;\n\n\t\tif ((*list)->type != ET8EK8_REGLIST_MODE)\n\t\t\tcontinue;\n\n\t\tet8ek8_reglist_to_mbus(*list, &format);\n\n\t\tdist = min(fmt->width, format.width)\n\t\t     * min(fmt->height, format.height);\n\t\tdist = format.width * format.height\n\t\t     + fmt->width * fmt->height - 2 * dist;\n\n\n\t\tif (fmt->code == format.code) {\n\t\t\tif (dist < max_dist_match || !best_match) {\n\t\t\t\tbest_match = *list;\n\t\t\t\tmax_dist_match = dist;\n\t\t\t}\n\t\t} else {\n\t\t\tif (dist < max_dist_other || !best_other) {\n\t\t\t\tbest_other = *list;\n\t\t\t\tmax_dist_other = dist;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn best_match ? best_match : best_other;\n}\n\n#define TIMEPERFRAME_AVG_FPS(t)\t\t\t\t\t\t\\\n\t(((t).denominator + ((t).numerator >> 1)) / (t).numerator)\n\nstatic struct et8ek8_reglist *et8ek8_reglist_find_mode_ival(\n\t\tstruct et8ek8_meta_reglist *meta,\n\t\tstruct et8ek8_reglist *current_reglist,\n\t\tstruct v4l2_fract *timeperframe)\n{\n\tint fps = TIMEPERFRAME_AVG_FPS(*timeperframe);\n\tstruct et8ek8_reglist **list = et8ek8_reglist_first(meta);\n\tstruct et8ek8_mode *current_mode = &current_reglist->mode;\n\n\tfor (; *list; list++) {\n\t\tstruct et8ek8_mode *mode = &(*list)->mode;\n\n\t\tif ((*list)->type != ET8EK8_REGLIST_MODE)\n\t\t\tcontinue;\n\n\t\tif (mode->window_width != current_mode->window_width ||\n\t\t    mode->window_height != current_mode->window_height)\n\t\t\tcontinue;\n\n\t\tif (TIMEPERFRAME_AVG_FPS(mode->timeperframe) == fps)\n\t\t\treturn *list;\n\t}\n\n\treturn NULL;\n}\n\nstatic int et8ek8_reglist_cmp(const void *a, const void *b)\n{\n\tconst struct et8ek8_reglist **list1 = (const struct et8ek8_reglist **)a,\n\t\t**list2 = (const struct et8ek8_reglist **)b;\n\n\t \n\tif ((*list1)->type == ET8EK8_REGLIST_MODE &&\n\t    (*list2)->type != ET8EK8_REGLIST_MODE)\n\t\treturn -1;\n\tif ((*list1)->type != ET8EK8_REGLIST_MODE &&\n\t    (*list2)->type == ET8EK8_REGLIST_MODE)\n\t\treturn 1;\n\n\t \n\tif ((*list1)->mode.window_width > (*list2)->mode.window_width)\n\t\treturn -1;\n\tif ((*list1)->mode.window_width < (*list2)->mode.window_width)\n\t\treturn 1;\n\n\tif ((*list1)->mode.window_height > (*list2)->mode.window_height)\n\t\treturn -1;\n\tif ((*list1)->mode.window_height < (*list2)->mode.window_height)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int et8ek8_reglist_import(struct i2c_client *client,\n\t\t\t\t struct et8ek8_meta_reglist *meta)\n{\n\tint nlists = 0, i;\n\n\tdev_info(&client->dev, \"meta_reglist version %s\\n\", meta->version);\n\n\twhile (meta->reglist[nlists].ptr)\n\t\tnlists++;\n\n\tif (!nlists)\n\t\treturn -EINVAL;\n\n\tsort(&meta->reglist[0].ptr, nlists, sizeof(meta->reglist[0].ptr),\n\t     et8ek8_reglist_cmp, NULL);\n\n\ti = nlists;\n\tnlists = 0;\n\n\twhile (i--) {\n\t\tstruct et8ek8_reglist *list;\n\n\t\tlist = meta->reglist[nlists].ptr;\n\n\t\tdev_dbg(&client->dev,\n\t\t       \"%s: type %d\\tw %d\\th %d\\tfmt %x\\tival %d/%d\\tptr %p\\n\",\n\t\t       __func__,\n\t\t       list->type,\n\t\t       list->mode.window_width, list->mode.window_height,\n\t\t       list->mode.bus_format,\n\t\t       list->mode.timeperframe.numerator,\n\t\t       list->mode.timeperframe.denominator,\n\t\t       (void *)meta->reglist[nlists].ptr);\n\n\t\tnlists++;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int et8ek8_set_gain(struct et8ek8_sensor *sensor, s32 gain)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->subdev);\n\tstruct et8ek8_gain new;\n\tint r;\n\n\tnew = et8ek8_gain_table[gain];\n\n\t \n\tr = et8ek8_i2c_write_reg(client, ET8EK8_REG_8BIT,\n\t\t\t\t0x124a, new.analog >> 8);\n\tif (r)\n\t\treturn r;\n\tr = et8ek8_i2c_write_reg(client, ET8EK8_REG_8BIT,\n\t\t\t\t0x1249, new.analog & 0xff);\n\tif (r)\n\t\treturn r;\n\n\tr = et8ek8_i2c_write_reg(client, ET8EK8_REG_8BIT,\n\t\t\t\t0x124d, new.digital >> 8);\n\tif (r)\n\t\treturn r;\n\tr = et8ek8_i2c_write_reg(client, ET8EK8_REG_8BIT,\n\t\t\t\t0x124c, new.digital & 0xff);\n\n\treturn r;\n}\n\nstatic int et8ek8_set_test_pattern(struct et8ek8_sensor *sensor, s32 mode)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->subdev);\n\tint cbh_mode, cbv_mode, tp_mode, din_sw, r1420, rval;\n\n\t \n\tcbh_mode = 0;\n\tcbv_mode = 0;\n\ttp_mode  = 0;\n\tdin_sw   = 0x00;\n\tr1420    = 0xF0;\n\n\tif (mode) {\n\t\t \n\t\tif (mode < 5) {\n\t\t\tcbh_mode = 1;\n\t\t\tcbv_mode = 1;\n\t\t\ttp_mode  = mode + 3;\n\t\t} else {\n\t\t\tcbh_mode = 0;\n\t\t\tcbv_mode = 0;\n\t\t\ttp_mode  = mode - 4 + 3;\n\t\t}\n\n\t\tdin_sw   = 0x01;\n\t\tr1420    = 0xE0;\n\t}\n\n\trval = et8ek8_i2c_write_reg(client, ET8EK8_REG_8BIT, 0x111B,\n\t\t\t\t    tp_mode << 4);\n\tif (rval)\n\t\treturn rval;\n\n\trval = et8ek8_i2c_write_reg(client, ET8EK8_REG_8BIT, 0x1121,\n\t\t\t\t    cbh_mode << 7);\n\tif (rval)\n\t\treturn rval;\n\n\trval = et8ek8_i2c_write_reg(client, ET8EK8_REG_8BIT, 0x1124,\n\t\t\t\t    cbv_mode << 7);\n\tif (rval)\n\t\treturn rval;\n\n\trval = et8ek8_i2c_write_reg(client, ET8EK8_REG_8BIT, 0x112C, din_sw);\n\tif (rval)\n\t\treturn rval;\n\n\treturn et8ek8_i2c_write_reg(client, ET8EK8_REG_8BIT, 0x1420, r1420);\n}\n\n \n\nstatic int et8ek8_set_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct et8ek8_sensor *sensor =\n\t\tcontainer_of(ctrl->handler, struct et8ek8_sensor, ctrl_handler);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_GAIN:\n\t\treturn et8ek8_set_gain(sensor, ctrl->val);\n\n\tcase V4L2_CID_EXPOSURE:\n\t{\n\t\tstruct i2c_client *client =\n\t\t\tv4l2_get_subdevdata(&sensor->subdev);\n\n\t\treturn et8ek8_i2c_write_reg(client, ET8EK8_REG_16BIT, 0x1243,\n\t\t\t\t\t    ctrl->val);\n\t}\n\n\tcase V4L2_CID_TEST_PATTERN:\n\t\treturn et8ek8_set_test_pattern(sensor, ctrl->val);\n\n\tcase V4L2_CID_PIXEL_RATE:\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct v4l2_ctrl_ops et8ek8_ctrl_ops = {\n\t.s_ctrl = et8ek8_set_ctrl,\n};\n\nstatic const char * const et8ek8_test_pattern_menu[] = {\n\t\"Normal\",\n\t\"Vertical colorbar\",\n\t\"Horizontal colorbar\",\n\t\"Scale\",\n\t\"Ramp\",\n\t\"Small vertical colorbar\",\n\t\"Small horizontal colorbar\",\n\t\"Small scale\",\n\t\"Small ramp\",\n};\n\nstatic int et8ek8_init_controls(struct et8ek8_sensor *sensor)\n{\n\ts32 max_rows;\n\n\tv4l2_ctrl_handler_init(&sensor->ctrl_handler, 4);\n\n\t \n\tv4l2_ctrl_new_std(&sensor->ctrl_handler, &et8ek8_ctrl_ops,\n\t\t\t  V4L2_CID_GAIN, 0, ARRAY_SIZE(et8ek8_gain_table) - 1,\n\t\t\t  1, 0);\n\n\tmax_rows = sensor->current_reglist->mode.max_exp;\n\t{\n\t\tu32 min = 1, max = max_rows;\n\n\t\tsensor->exposure =\n\t\t\tv4l2_ctrl_new_std(&sensor->ctrl_handler,\n\t\t\t\t\t  &et8ek8_ctrl_ops, V4L2_CID_EXPOSURE,\n\t\t\t\t\t  min, max, min, max);\n\t}\n\n\t \n\tsensor->pixel_rate =\n\t\tv4l2_ctrl_new_std(&sensor->ctrl_handler, &et8ek8_ctrl_ops,\n\t\tV4L2_CID_PIXEL_RATE, 1, INT_MAX, 1, 1);\n\n\t \n\tv4l2_ctrl_new_std_menu_items(&sensor->ctrl_handler,\n\t\t\t\t     &et8ek8_ctrl_ops, V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(et8ek8_test_pattern_menu) - 1,\n\t\t\t\t     0, 0, et8ek8_test_pattern_menu);\n\n\tif (sensor->ctrl_handler.error)\n\t\treturn sensor->ctrl_handler.error;\n\n\tsensor->subdev.ctrl_handler = &sensor->ctrl_handler;\n\n\treturn 0;\n}\n\nstatic void et8ek8_update_controls(struct et8ek8_sensor *sensor)\n{\n\tstruct v4l2_ctrl *ctrl;\n\tstruct et8ek8_mode *mode = &sensor->current_reglist->mode;\n\n\tu32 min, max, pixel_rate;\n\tstatic const int S = 8;\n\n\tctrl = sensor->exposure;\n\n\tmin = 1;\n\tmax = mode->max_exp;\n\n\t \n\tpixel_rate = ((mode->pixel_clock + (1 << S) - 1) >> S) + mode->width;\n\tpixel_rate = mode->window_width * (pixel_rate - 1) / mode->width;\n\n\t__v4l2_ctrl_modify_range(ctrl, min, max, min, max);\n\t__v4l2_ctrl_s_ctrl_int64(sensor->pixel_rate, pixel_rate << S);\n}\n\nstatic int et8ek8_configure(struct et8ek8_sensor *sensor)\n{\n\tstruct v4l2_subdev *subdev = &sensor->subdev;\n\tstruct i2c_client *client = v4l2_get_subdevdata(subdev);\n\tint rval;\n\n\trval = et8ek8_i2c_write_regs(client, sensor->current_reglist->regs);\n\tif (rval)\n\t\tgoto fail;\n\n\t \n\trval = v4l2_ctrl_handler_setup(&sensor->ctrl_handler);\n\tif (rval)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\tdev_err(&client->dev, \"sensor configuration failed\\n\");\n\n\treturn rval;\n}\n\nstatic int et8ek8_stream_on(struct et8ek8_sensor *sensor)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->subdev);\n\n\treturn et8ek8_i2c_write_reg(client, ET8EK8_REG_8BIT, 0x1252, 0xb0);\n}\n\nstatic int et8ek8_stream_off(struct et8ek8_sensor *sensor)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&sensor->subdev);\n\n\treturn et8ek8_i2c_write_reg(client, ET8EK8_REG_8BIT, 0x1252, 0x30);\n}\n\nstatic int et8ek8_s_stream(struct v4l2_subdev *subdev, int streaming)\n{\n\tstruct et8ek8_sensor *sensor = to_et8ek8_sensor(subdev);\n\tint ret;\n\n\tif (!streaming)\n\t\treturn et8ek8_stream_off(sensor);\n\n\tret = et8ek8_configure(sensor);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn et8ek8_stream_on(sensor);\n}\n\n \n\nstatic int et8ek8_power_off(struct et8ek8_sensor *sensor)\n{\n\tgpiod_set_value(sensor->reset, 0);\n\tudelay(1);\n\n\tclk_disable_unprepare(sensor->ext_clk);\n\n\treturn regulator_disable(sensor->vana);\n}\n\nstatic int et8ek8_power_on(struct et8ek8_sensor *sensor)\n{\n\tstruct v4l2_subdev *subdev = &sensor->subdev;\n\tstruct i2c_client *client = v4l2_get_subdevdata(subdev);\n\tunsigned int xclk_freq;\n\tint val, rval;\n\n\trval = regulator_enable(sensor->vana);\n\tif (rval) {\n\t\tdev_err(&client->dev, \"failed to enable vana regulator\\n\");\n\t\treturn rval;\n\t}\n\n\tif (sensor->current_reglist)\n\t\txclk_freq = sensor->current_reglist->mode.ext_clock;\n\telse\n\t\txclk_freq = sensor->xclk_freq;\n\n\trval = clk_set_rate(sensor->ext_clk, xclk_freq);\n\tif (rval < 0) {\n\t\tdev_err(&client->dev, \"unable to set extclk clock freq to %u\\n\",\n\t\t\txclk_freq);\n\t\tgoto out;\n\t}\n\trval = clk_prepare_enable(sensor->ext_clk);\n\tif (rval < 0) {\n\t\tdev_err(&client->dev, \"failed to enable extclk\\n\");\n\t\tgoto out;\n\t}\n\n\tif (rval)\n\t\tgoto out;\n\n\tudelay(10);  \n\n\tgpiod_set_value(sensor->reset, 1);\n\n\tmsleep(5000 * 1000 / xclk_freq + 1);  \n\n\trval = et8ek8_i2c_reglist_find_write(client, &meta_reglist,\n\t\t\t\t\t     ET8EK8_REGLIST_POWERON);\n\tif (rval)\n\t\tgoto out;\n\n#ifdef USE_CRC\n\trval = et8ek8_i2c_read_reg(client, ET8EK8_REG_8BIT, 0x1263, &val);\n\tif (rval)\n\t\tgoto out;\n#if USE_CRC  \n\tval |= BIT(4);\n#else\n\tval &= ~BIT(4);\n#endif\n\trval = et8ek8_i2c_write_reg(client, ET8EK8_REG_8BIT, 0x1263, val);\n\tif (rval)\n\t\tgoto out;\n#endif\n\nout:\n\tif (rval)\n\t\tet8ek8_power_off(sensor);\n\n\treturn rval;\n}\n\n \n#define MAX_FMTS 4\nstatic int et8ek8_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct et8ek8_reglist **list =\n\t\t\tet8ek8_reglist_first(&meta_reglist);\n\tu32 pixelformat[MAX_FMTS];\n\tint npixelformat = 0;\n\n\tif (code->index >= MAX_FMTS)\n\t\treturn -EINVAL;\n\n\tfor (; *list; list++) {\n\t\tstruct et8ek8_mode *mode = &(*list)->mode;\n\t\tint i;\n\n\t\tif ((*list)->type != ET8EK8_REGLIST_MODE)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < npixelformat; i++) {\n\t\t\tif (pixelformat[i] == mode->bus_format)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i != npixelformat)\n\t\t\tcontinue;\n\n\t\tif (code->index == npixelformat) {\n\t\t\tcode->code = mode->bus_format;\n\t\t\treturn 0;\n\t\t}\n\n\t\tpixelformat[npixelformat] = mode->bus_format;\n\t\tnpixelformat++;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int et8ek8_enum_frame_size(struct v4l2_subdev *subdev,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct et8ek8_reglist **list =\n\t\t\tet8ek8_reglist_first(&meta_reglist);\n\tstruct v4l2_mbus_framefmt format;\n\tint cmp_width = INT_MAX;\n\tint cmp_height = INT_MAX;\n\tint index = fse->index;\n\n\tfor (; *list; list++) {\n\t\tif ((*list)->type != ET8EK8_REGLIST_MODE)\n\t\t\tcontinue;\n\n\t\tet8ek8_reglist_to_mbus(*list, &format);\n\t\tif (fse->code != format.code)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (format.width == cmp_width && format.height == cmp_height)\n\t\t\tcontinue;\n\n\t\tcmp_width = format.width;\n\t\tcmp_height = format.height;\n\n\t\tif (index-- == 0) {\n\t\t\tfse->min_width = format.width;\n\t\t\tfse->min_height = format.height;\n\t\t\tfse->max_width = format.width;\n\t\t\tfse->max_height = format.height;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int et8ek8_enum_frame_ival(struct v4l2_subdev *subdev,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_interval_enum *fie)\n{\n\tstruct et8ek8_reglist **list =\n\t\t\tet8ek8_reglist_first(&meta_reglist);\n\tstruct v4l2_mbus_framefmt format;\n\tint index = fie->index;\n\n\tfor (; *list; list++) {\n\t\tstruct et8ek8_mode *mode = &(*list)->mode;\n\n\t\tif ((*list)->type != ET8EK8_REGLIST_MODE)\n\t\t\tcontinue;\n\n\t\tet8ek8_reglist_to_mbus(*list, &format);\n\t\tif (fie->code != format.code)\n\t\t\tcontinue;\n\n\t\tif (fie->width != format.width || fie->height != format.height)\n\t\t\tcontinue;\n\n\t\tif (index-- == 0) {\n\t\t\tfie->interval = mode->timeperframe;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic struct v4l2_mbus_framefmt *\n__et8ek8_get_pad_format(struct et8ek8_sensor *sensor,\n\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\tunsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\treturn v4l2_subdev_get_try_format(&sensor->subdev, sd_state,\n\t\t\t\t\t\t  pad);\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &sensor->format;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic int et8ek8_get_pad_format(struct v4l2_subdev *subdev,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_format *fmt)\n{\n\tstruct et8ek8_sensor *sensor = to_et8ek8_sensor(subdev);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __et8ek8_get_pad_format(sensor, sd_state, fmt->pad,\n\t\t\t\t\t fmt->which);\n\tif (!format)\n\t\treturn -EINVAL;\n\n\tfmt->format = *format;\n\n\treturn 0;\n}\n\nstatic int et8ek8_set_pad_format(struct v4l2_subdev *subdev,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_format *fmt)\n{\n\tstruct et8ek8_sensor *sensor = to_et8ek8_sensor(subdev);\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct et8ek8_reglist *reglist;\n\n\tformat = __et8ek8_get_pad_format(sensor, sd_state, fmt->pad,\n\t\t\t\t\t fmt->which);\n\tif (!format)\n\t\treturn -EINVAL;\n\n\treglist = et8ek8_reglist_find_mode_fmt(&meta_reglist, &fmt->format);\n\tet8ek8_reglist_to_mbus(reglist, &fmt->format);\n\t*format = fmt->format;\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\tsensor->current_reglist = reglist;\n\t\tet8ek8_update_controls(sensor);\n\t}\n\n\treturn 0;\n}\n\nstatic int et8ek8_get_frame_interval(struct v4l2_subdev *subdev,\n\t\t\t\t     struct v4l2_subdev_frame_interval *fi)\n{\n\tstruct et8ek8_sensor *sensor = to_et8ek8_sensor(subdev);\n\n\tmemset(fi, 0, sizeof(*fi));\n\tfi->interval = sensor->current_reglist->mode.timeperframe;\n\n\treturn 0;\n}\n\nstatic int et8ek8_set_frame_interval(struct v4l2_subdev *subdev,\n\t\t\t\t     struct v4l2_subdev_frame_interval *fi)\n{\n\tstruct et8ek8_sensor *sensor = to_et8ek8_sensor(subdev);\n\tstruct et8ek8_reglist *reglist;\n\n\treglist = et8ek8_reglist_find_mode_ival(&meta_reglist,\n\t\t\t\t\t\tsensor->current_reglist,\n\t\t\t\t\t\t&fi->interval);\n\n\tif (!reglist)\n\t\treturn -EINVAL;\n\n\tif (sensor->current_reglist->mode.ext_clock != reglist->mode.ext_clock)\n\t\treturn -EINVAL;\n\n\tsensor->current_reglist = reglist;\n\tet8ek8_update_controls(sensor);\n\n\treturn 0;\n}\n\nstatic int et8ek8_g_priv_mem(struct v4l2_subdev *subdev)\n{\n\tstruct et8ek8_sensor *sensor = to_et8ek8_sensor(subdev);\n\tstruct i2c_client *client = v4l2_get_subdevdata(subdev);\n\tunsigned int length = ET8EK8_PRIV_MEM_SIZE;\n\tunsigned int offset = 0;\n\tu8 *ptr  = sensor->priv_mem;\n\tint rval = 0;\n\n\t \n\tdo {\n\t\tu8 buffer[PRIV_MEM_WIN_SIZE];\n\t\tstruct i2c_msg msg;\n\t\tint bytes, i;\n\t\tint ofs;\n\n\t\t \n\t\trval = et8ek8_i2c_write_reg(client, ET8EK8_REG_8BIT, 0x0001,\n\t\t\t\t\t    0xe0 | (offset >> 3));\n\t\tif (rval < 0)\n\t\t\treturn rval;\n\n\t\t \n\t\tfor (i = 0; i < 1000; ++i) {\n\t\t\tu32 status;\n\n\t\t\trval = et8ek8_i2c_read_reg(client, ET8EK8_REG_8BIT,\n\t\t\t\t\t\t   0x0003, &status);\n\t\t\tif (rval < 0)\n\t\t\t\treturn rval;\n\t\t\tif (!(status & 0x08))\n\t\t\t\tbreak;\n\t\t\tusleep_range(1000, 2000);\n\t\t}\n\n\t\tif (i == 1000)\n\t\t\treturn -EIO;\n\n\t\t \n\t\tofs = offset & 0x07;\t \n\t\tbytes = length + ofs > 8 ? 8-ofs : length;\n\t\tmsg.addr = client->addr;\n\t\tmsg.flags = 0;\n\t\tmsg.len = 2;\n\t\tmsg.buf = buffer;\n\t\tofs += PRIV_MEM_START_REG;\n\t\tbuffer[0] = (u8)(ofs >> 8);\n\t\tbuffer[1] = (u8)(ofs & 0xFF);\n\n\t\trval = i2c_transfer(client->adapter, &msg, 1);\n\t\tif (rval < 0)\n\t\t\treturn rval;\n\n\t\tmdelay(ET8EK8_I2C_DELAY);\n\t\tmsg.addr = client->addr;\n\t\tmsg.len = bytes;\n\t\tmsg.flags = I2C_M_RD;\n\t\tmsg.buf = buffer;\n\t\tmemset(buffer, 0, sizeof(buffer));\n\n\t\trval = i2c_transfer(client->adapter, &msg, 1);\n\t\tif (rval < 0)\n\t\t\treturn rval;\n\n\t\trval = 0;\n\t\tmemcpy(ptr, buffer, bytes);\n\n\t\tlength -= bytes;\n\t\toffset += bytes;\n\t\tptr += bytes;\n\t} while (length > 0);\n\n\treturn rval;\n}\n\nstatic int et8ek8_dev_init(struct v4l2_subdev *subdev)\n{\n\tstruct et8ek8_sensor *sensor = to_et8ek8_sensor(subdev);\n\tstruct i2c_client *client = v4l2_get_subdevdata(subdev);\n\tint rval, rev_l, rev_h;\n\n\trval = et8ek8_power_on(sensor);\n\tif (rval) {\n\t\tdev_err(&client->dev, \"could not power on\\n\");\n\t\treturn rval;\n\t}\n\n\trval = et8ek8_i2c_read_reg(client, ET8EK8_REG_8BIT,\n\t\t\t\t   REG_REVISION_NUMBER_L, &rev_l);\n\tif (!rval)\n\t\trval = et8ek8_i2c_read_reg(client, ET8EK8_REG_8BIT,\n\t\t\t\t\t   REG_REVISION_NUMBER_H, &rev_h);\n\tif (rval) {\n\t\tdev_err(&client->dev, \"no et8ek8 sensor detected\\n\");\n\t\tgoto out_poweroff;\n\t}\n\n\tsensor->version = (rev_h << 8) + rev_l;\n\tif (sensor->version != ET8EK8_REV_1 && sensor->version != ET8EK8_REV_2)\n\t\tdev_info(&client->dev,\n\t\t\t \"unknown version 0x%x detected, continuing anyway\\n\",\n\t\t\t sensor->version);\n\n\trval = et8ek8_reglist_import(client, &meta_reglist);\n\tif (rval) {\n\t\tdev_err(&client->dev,\n\t\t\t\"invalid register list %s, import failed\\n\",\n\t\t\tET8EK8_NAME);\n\t\tgoto out_poweroff;\n\t}\n\n\tsensor->current_reglist = et8ek8_reglist_find_type(&meta_reglist,\n\t\t\t\t\t\t\t   ET8EK8_REGLIST_MODE);\n\tif (!sensor->current_reglist) {\n\t\tdev_err(&client->dev,\n\t\t\t\"invalid register list %s, no mode found\\n\",\n\t\t\tET8EK8_NAME);\n\t\trval = -ENODEV;\n\t\tgoto out_poweroff;\n\t}\n\n\tet8ek8_reglist_to_mbus(sensor->current_reglist, &sensor->format);\n\n\trval = et8ek8_i2c_reglist_find_write(client, &meta_reglist,\n\t\t\t\t\t     ET8EK8_REGLIST_POWERON);\n\tif (rval) {\n\t\tdev_err(&client->dev,\n\t\t\t\"invalid register list %s, no POWERON mode found\\n\",\n\t\t\tET8EK8_NAME);\n\t\tgoto out_poweroff;\n\t}\n\trval = et8ek8_stream_on(sensor);  \n\tif (rval)\n\t\tgoto out_poweroff;\n\trval = et8ek8_g_priv_mem(subdev);\n\tif (rval)\n\t\tdev_warn(&client->dev,\n\t\t\t\"can not read OTP (EEPROM) memory from sensor\\n\");\n\trval = et8ek8_stream_off(sensor);\n\tif (rval)\n\t\tgoto out_poweroff;\n\n\trval = et8ek8_power_off(sensor);\n\tif (rval)\n\t\tgoto out_poweroff;\n\n\treturn 0;\n\nout_poweroff:\n\tet8ek8_power_off(sensor);\n\n\treturn rval;\n}\n\n \nstatic ssize_t\npriv_mem_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct v4l2_subdev *subdev = dev_get_drvdata(dev);\n\tstruct et8ek8_sensor *sensor = to_et8ek8_sensor(subdev);\n\n#if PAGE_SIZE < ET8EK8_PRIV_MEM_SIZE\n#error PAGE_SIZE too small!\n#endif\n\n\tmemcpy(buf, sensor->priv_mem, ET8EK8_PRIV_MEM_SIZE);\n\n\treturn ET8EK8_PRIV_MEM_SIZE;\n}\nstatic DEVICE_ATTR_RO(priv_mem);\n\n \n\nstatic int\net8ek8_registered(struct v4l2_subdev *subdev)\n{\n\tstruct et8ek8_sensor *sensor = to_et8ek8_sensor(subdev);\n\tstruct i2c_client *client = v4l2_get_subdevdata(subdev);\n\tint rval;\n\n\tdev_dbg(&client->dev, \"registered!\");\n\n\trval = device_create_file(&client->dev, &dev_attr_priv_mem);\n\tif (rval) {\n\t\tdev_err(&client->dev, \"could not register sysfs entry\\n\");\n\t\treturn rval;\n\t}\n\n\trval = et8ek8_dev_init(subdev);\n\tif (rval)\n\t\tgoto err_file;\n\n\trval = et8ek8_init_controls(sensor);\n\tif (rval) {\n\t\tdev_err(&client->dev, \"controls initialization failed\\n\");\n\t\tgoto err_file;\n\t}\n\n\t__et8ek8_get_pad_format(sensor, NULL, 0, V4L2_SUBDEV_FORMAT_ACTIVE);\n\n\treturn 0;\n\nerr_file:\n\tdevice_remove_file(&client->dev, &dev_attr_priv_mem);\n\n\treturn rval;\n}\n\nstatic int __et8ek8_set_power(struct et8ek8_sensor *sensor, bool on)\n{\n\treturn on ? et8ek8_power_on(sensor) : et8ek8_power_off(sensor);\n}\n\nstatic int et8ek8_set_power(struct v4l2_subdev *subdev, int on)\n{\n\tstruct et8ek8_sensor *sensor = to_et8ek8_sensor(subdev);\n\tint ret = 0;\n\n\tmutex_lock(&sensor->power_lock);\n\n\t \n\tif (sensor->power_count == !on) {\n\t\tret = __et8ek8_set_power(sensor, !!on);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\t \n\tsensor->power_count += on ? 1 : -1;\n\tWARN_ON(sensor->power_count < 0);\n\ndone:\n\tmutex_unlock(&sensor->power_lock);\n\n\treturn ret;\n}\n\nstatic int et8ek8_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct et8ek8_sensor *sensor = to_et8ek8_sensor(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct et8ek8_reglist *reglist;\n\n\treglist = et8ek8_reglist_find_type(&meta_reglist, ET8EK8_REGLIST_MODE);\n\tformat = __et8ek8_get_pad_format(sensor, fh->state, 0,\n\t\t\t\t\t V4L2_SUBDEV_FORMAT_TRY);\n\tet8ek8_reglist_to_mbus(reglist, format);\n\n\treturn et8ek8_set_power(sd, true);\n}\n\nstatic int et8ek8_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\treturn et8ek8_set_power(sd, false);\n}\n\nstatic const struct v4l2_subdev_video_ops et8ek8_video_ops = {\n\t.s_stream = et8ek8_s_stream,\n\t.g_frame_interval = et8ek8_get_frame_interval,\n\t.s_frame_interval = et8ek8_set_frame_interval,\n};\n\nstatic const struct v4l2_subdev_core_ops et8ek8_core_ops = {\n\t.s_power = et8ek8_set_power,\n};\n\nstatic const struct v4l2_subdev_pad_ops et8ek8_pad_ops = {\n\t.enum_mbus_code = et8ek8_enum_mbus_code,\n\t.enum_frame_size = et8ek8_enum_frame_size,\n\t.enum_frame_interval = et8ek8_enum_frame_ival,\n\t.get_fmt = et8ek8_get_pad_format,\n\t.set_fmt = et8ek8_set_pad_format,\n};\n\nstatic const struct v4l2_subdev_ops et8ek8_ops = {\n\t.core = &et8ek8_core_ops,\n\t.video = &et8ek8_video_ops,\n\t.pad = &et8ek8_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops et8ek8_internal_ops = {\n\t.registered = et8ek8_registered,\n\t.open = et8ek8_open,\n\t.close = et8ek8_close,\n};\n\n \nstatic int __maybe_unused et8ek8_suspend(struct device *dev)\n{\n\tstruct v4l2_subdev *subdev = dev_get_drvdata(dev);\n\tstruct et8ek8_sensor *sensor = to_et8ek8_sensor(subdev);\n\n\tif (!sensor->power_count)\n\t\treturn 0;\n\n\treturn __et8ek8_set_power(sensor, false);\n}\n\nstatic int __maybe_unused et8ek8_resume(struct device *dev)\n{\n\tstruct v4l2_subdev *subdev = dev_get_drvdata(dev);\n\tstruct et8ek8_sensor *sensor = to_et8ek8_sensor(subdev);\n\n\tif (!sensor->power_count)\n\t\treturn 0;\n\n\treturn __et8ek8_set_power(sensor, true);\n}\n\nstatic int et8ek8_probe(struct i2c_client *client)\n{\n\tstruct et8ek8_sensor *sensor;\n\tstruct device *dev = &client->dev;\n\tint ret;\n\n\tsensor = devm_kzalloc(&client->dev, sizeof(*sensor), GFP_KERNEL);\n\tif (!sensor)\n\t\treturn -ENOMEM;\n\n\tsensor->reset = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(sensor->reset)) {\n\t\tdev_dbg(&client->dev, \"could not request reset gpio\\n\");\n\t\treturn PTR_ERR(sensor->reset);\n\t}\n\n\tsensor->vana = devm_regulator_get(dev, \"vana\");\n\tif (IS_ERR(sensor->vana)) {\n\t\tdev_err(&client->dev, \"could not get regulator for vana\\n\");\n\t\treturn PTR_ERR(sensor->vana);\n\t}\n\n\tsensor->ext_clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(sensor->ext_clk)) {\n\t\tdev_err(&client->dev, \"could not get clock\\n\");\n\t\treturn PTR_ERR(sensor->ext_clk);\n\t}\n\n\tret = of_property_read_u32(dev->of_node, \"clock-frequency\",\n\t\t\t\t   &sensor->xclk_freq);\n\tif (ret) {\n\t\tdev_warn(dev, \"can't get clock-frequency\\n\");\n\t\treturn ret;\n\t}\n\n\tmutex_init(&sensor->power_lock);\n\n\tv4l2_i2c_subdev_init(&sensor->subdev, client, &et8ek8_ops);\n\tsensor->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsensor->subdev.internal_ops = &et8ek8_internal_ops;\n\n\tsensor->subdev.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tsensor->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tret = media_entity_pads_init(&sensor->subdev.entity, 1, &sensor->pad);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"media entity init failed!\\n\");\n\t\tgoto err_mutex;\n\t}\n\n\tret = v4l2_async_register_subdev_sensor(&sensor->subdev);\n\tif (ret < 0)\n\t\tgoto err_entity;\n\n\tdev_dbg(dev, \"initialized!\\n\");\n\n\treturn 0;\n\nerr_entity:\n\tmedia_entity_cleanup(&sensor->subdev.entity);\nerr_mutex:\n\tmutex_destroy(&sensor->power_lock);\n\treturn ret;\n}\n\nstatic void __exit et8ek8_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct et8ek8_sensor *sensor = to_et8ek8_sensor(subdev);\n\n\tif (sensor->power_count) {\n\t\tWARN_ON(1);\n\t\tet8ek8_power_off(sensor);\n\t\tsensor->power_count = 0;\n\t}\n\n\tv4l2_device_unregister_subdev(&sensor->subdev);\n\tdevice_remove_file(&client->dev, &dev_attr_priv_mem);\n\tv4l2_ctrl_handler_free(&sensor->ctrl_handler);\n\tv4l2_async_unregister_subdev(&sensor->subdev);\n\tmedia_entity_cleanup(&sensor->subdev.entity);\n\tmutex_destroy(&sensor->power_lock);\n}\n\nstatic const struct of_device_id et8ek8_of_table[] = {\n\t{ .compatible = \"toshiba,et8ek8\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, et8ek8_of_table);\n\nstatic const struct i2c_device_id et8ek8_id_table[] = {\n\t{ ET8EK8_NAME, 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, et8ek8_id_table);\n\nstatic const struct dev_pm_ops et8ek8_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(et8ek8_suspend, et8ek8_resume)\n};\n\nstatic struct i2c_driver et8ek8_i2c_driver = {\n\t.driver\t\t= {\n\t\t.name\t= ET8EK8_NAME,\n\t\t.pm\t= &et8ek8_pm_ops,\n\t\t.of_match_table\t= et8ek8_of_table,\n\t},\n\t.probe\t\t= et8ek8_probe,\n\t.remove\t\t= __exit_p(et8ek8_remove),\n\t.id_table\t= et8ek8_id_table,\n};\n\nmodule_i2c_driver(et8ek8_i2c_driver);\n\nMODULE_AUTHOR(\"Sakari Ailus <sakari.ailus@iki.fi>, Pavel Machek <pavel@ucw.cz\");\nMODULE_DESCRIPTION(\"Toshiba ET8EK8 camera sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}