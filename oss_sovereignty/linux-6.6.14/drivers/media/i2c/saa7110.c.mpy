{
  "module_name": "saa7110.c",
  "hash_id": "d6fee546bd3b044bc4e45d7f23bc832effb219d815c84b68d51e70c3fb599b98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/saa7110.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/uaccess.h>\n#include <linux/i2c.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n\nMODULE_DESCRIPTION(\"Philips SAA7110 video decoder driver\");\nMODULE_AUTHOR(\"Pauline Middelink\");\nMODULE_LICENSE(\"GPL\");\n\n\nstatic int debug;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"Debug level (0-1)\");\n\n#define SAA7110_MAX_INPUT\t9\t \n#define SAA7110_MAX_OUTPUT\t1\t \n\n#define SAA7110_NR_REG\t\t0x35\n\nstruct saa7110 {\n\tstruct v4l2_subdev sd;\n\tstruct v4l2_ctrl_handler hdl;\n\tu8 reg[SAA7110_NR_REG];\n\n\tv4l2_std_id norm;\n\tint input;\n\tint enable;\n\n\twait_queue_head_t wq;\n};\n\nstatic inline struct saa7110 *to_saa7110(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct saa7110, sd);\n}\n\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct saa7110, hdl)->sd;\n}\n\n \n \n \n\nstatic int saa7110_write(struct v4l2_subdev *sd, u8 reg, u8 value)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct saa7110 *decoder = to_saa7110(sd);\n\n\tdecoder->reg[reg] = value;\n\treturn i2c_smbus_write_byte_data(client, reg, value);\n}\n\nstatic int saa7110_write_block(struct v4l2_subdev *sd, const u8 *data, unsigned int len)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct saa7110 *decoder = to_saa7110(sd);\n\tint ret = -1;\n\tu8 reg = *data;\t\t \n\n\t \n\tif (reg + (len - 1) > SAA7110_NR_REG)\n\t\treturn ret;\n\n\t \n\tif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tret = i2c_master_send(client, data, len);\n\n\t\t \n\t\tmemcpy(decoder->reg + reg, data + 1, len - 1);\n\t} else {\n\t\tfor (++data, --len; len; len--) {\n\t\t\tret = saa7110_write(sd, reg++, *data++);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic inline int saa7110_read(struct v4l2_subdev *sd)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn i2c_smbus_read_byte(client);\n}\n\n \n \n \n\n#define FRESP_06H_COMPST 0x03\t \n#define FRESP_06H_SVIDEO 0x83\t \n\n\nstatic int saa7110_selmux(struct v4l2_subdev *sd, int chan)\n{\n\tstatic const unsigned char modes[9][8] = {\n\t\t \n\t\t{FRESP_06H_COMPST, 0xD9, 0x17, 0x40, 0x03,\n\t\t\t      0x44, 0x75, 0x16},\n\t\t \n\t\t{FRESP_06H_COMPST, 0xD8, 0x17, 0x40, 0x03,\n\t\t\t      0x44, 0x75, 0x16},\n\t\t \n\t\t{FRESP_06H_COMPST, 0xBA, 0x07, 0x91, 0x03,\n\t\t\t      0x60, 0xB5, 0x05},\n\t\t \n\t\t{FRESP_06H_COMPST, 0xB8, 0x07, 0x91, 0x03,\n\t\t\t      0x60, 0xB5, 0x05},\n\t\t \n\t\t{FRESP_06H_COMPST, 0x7C, 0x07, 0xD2, 0x83,\n\t\t\t      0x60, 0xB5, 0x03},\n\t\t \n\t\t{FRESP_06H_COMPST, 0x78, 0x07, 0xD2, 0x83,\n\t\t\t      0x60, 0xB5, 0x03},\n\t\t \n\t\t{FRESP_06H_SVIDEO, 0x59, 0x17, 0x42, 0xA3,\n\t\t\t      0x44, 0x75, 0x12},\n\t\t \n\t\t{FRESP_06H_SVIDEO, 0x9A, 0x17, 0xB1, 0x13,\n\t\t\t      0x60, 0xB5, 0x14},\n\t\t \n\t\t{FRESP_06H_SVIDEO, 0x3C, 0x27, 0xC1, 0x23,\n\t\t\t      0x44, 0x75, 0x21}\n\t};\n\tstruct saa7110 *decoder = to_saa7110(sd);\n\tconst unsigned char *ptr = modes[chan];\n\n\tsaa7110_write(sd, 0x06, ptr[0]);\t \n\tsaa7110_write(sd, 0x20, ptr[1]);\t \n\tsaa7110_write(sd, 0x21, ptr[2]);\t \n\tsaa7110_write(sd, 0x22, ptr[3]);\t \n\tsaa7110_write(sd, 0x2C, ptr[4]);\t \n\tsaa7110_write(sd, 0x30, ptr[5]);\t \n\tsaa7110_write(sd, 0x31, ptr[6]);\t \n\tsaa7110_write(sd, 0x21, ptr[7]);\t \n\tdecoder->input = chan;\n\n\treturn 0;\n}\n\nstatic const unsigned char initseq[1 + SAA7110_NR_REG] = {\n\t0, 0x4C, 0x3C, 0x0D, 0xEF, 0xBD, 0xF2, 0x03, 0x00,\n\t  0xF8, 0xF8, 0x60, 0x60, 0x00, 0x86, 0x18, 0x90,\n\t  0x00, 0x59, 0x40, 0x46, 0x42, 0x1A, 0xFF, 0xDA,\n\t  0xF2, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t  0xD9, 0x16, 0x40, 0x41, 0x80, 0x41, 0x80, 0x4F,\n\t  0xFE, 0x01, 0xCF, 0x0F, 0x03, 0x01, 0x03, 0x0C,\n\t  0x44, 0x71, 0x02, 0x8C, 0x02\n};\n\nstatic v4l2_std_id determine_norm(struct v4l2_subdev *sd)\n{\n\tDEFINE_WAIT(wait);\n\tstruct saa7110 *decoder = to_saa7110(sd);\n\tint status;\n\n\t \n\tsaa7110_write_block(sd, initseq, sizeof(initseq));\n\tsaa7110_selmux(sd, decoder->input);\n\tprepare_to_wait(&decoder->wq, &wait, TASK_UNINTERRUPTIBLE);\n\tschedule_timeout(msecs_to_jiffies(250));\n\tfinish_wait(&decoder->wq, &wait);\n\tstatus = saa7110_read(sd);\n\tif (status & 0x40) {\n\t\tv4l2_dbg(1, debug, sd, \"status=0x%02x (no signal)\\n\", status);\n\t\treturn V4L2_STD_UNKNOWN;\n\t}\n\tif ((status & 3) == 0) {\n\t\tsaa7110_write(sd, 0x06, 0x83);\n\t\tif (status & 0x20) {\n\t\t\tv4l2_dbg(1, debug, sd, \"status=0x%02x (NTSC/no color)\\n\", status);\n\t\t\t \n\t\t\treturn V4L2_STD_NTSC;\n\t\t}\n\t\tv4l2_dbg(1, debug, sd, \"status=0x%02x (PAL/no color)\\n\", status);\n\t\t \n\t\treturn V4L2_STD_PAL;\n\t}\n\t \n\tif (status & 0x20) {\t \n\t\tv4l2_dbg(1, debug, sd, \"status=0x%02x (NTSC)\\n\", status);\n\t\tsaa7110_write(sd, 0x0D, 0x86);\n\t\tsaa7110_write(sd, 0x0F, 0x50);\n\t\tsaa7110_write(sd, 0x11, 0x2C);\n\t\t \n\t\treturn V4L2_STD_NTSC;\n\t}\n\n\t \n\tsaa7110_write(sd, 0x0D, 0x86);\n\tsaa7110_write(sd, 0x0F, 0x10);\n\tsaa7110_write(sd, 0x11, 0x59);\n\t \n\n\tprepare_to_wait(&decoder->wq, &wait, TASK_UNINTERRUPTIBLE);\n\tschedule_timeout(msecs_to_jiffies(250));\n\tfinish_wait(&decoder->wq, &wait);\n\n\tstatus = saa7110_read(sd);\n\tif ((status & 0x03) == 0x01) {\n\t\tv4l2_dbg(1, debug, sd, \"status=0x%02x (SECAM)\\n\", status);\n\t\tsaa7110_write(sd, 0x0D, 0x87);\n\t\treturn V4L2_STD_SECAM;\n\t}\n\tv4l2_dbg(1, debug, sd, \"status=0x%02x (PAL)\\n\", status);\n\treturn V4L2_STD_PAL;\n}\n\nstatic int saa7110_g_input_status(struct v4l2_subdev *sd, u32 *pstatus)\n{\n\tstruct saa7110 *decoder = to_saa7110(sd);\n\tint res = V4L2_IN_ST_NO_SIGNAL;\n\tint status = saa7110_read(sd);\n\n\tv4l2_dbg(1, debug, sd, \"status=0x%02x norm=%llx\\n\",\n\t\t       status, (unsigned long long)decoder->norm);\n\tif (!(status & 0x40))\n\t\tres = 0;\n\tif (!(status & 0x03))\n\t\tres |= V4L2_IN_ST_NO_COLOR;\n\n\t*pstatus = res;\n\treturn 0;\n}\n\nstatic int saa7110_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)\n{\n\t*std &= determine_norm(sd);\n\treturn 0;\n}\n\nstatic int saa7110_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct saa7110 *decoder = to_saa7110(sd);\n\n\tif (decoder->norm != std) {\n\t\tdecoder->norm = std;\n\t\t \n\t\tif (std & V4L2_STD_NTSC) {\n\t\t\tsaa7110_write(sd, 0x0D, 0x86);\n\t\t\tsaa7110_write(sd, 0x0F, 0x50);\n\t\t\tsaa7110_write(sd, 0x11, 0x2C);\n\t\t\t \n\t\t\tv4l2_dbg(1, debug, sd, \"switched to NTSC\\n\");\n\t\t} else if (std & V4L2_STD_PAL) {\n\t\t\tsaa7110_write(sd, 0x0D, 0x86);\n\t\t\tsaa7110_write(sd, 0x0F, 0x10);\n\t\t\tsaa7110_write(sd, 0x11, 0x59);\n\t\t\t \n\t\t\tv4l2_dbg(1, debug, sd, \"switched to PAL\\n\");\n\t\t} else if (std & V4L2_STD_SECAM) {\n\t\t\tsaa7110_write(sd, 0x0D, 0x87);\n\t\t\tsaa7110_write(sd, 0x0F, 0x10);\n\t\t\tsaa7110_write(sd, 0x11, 0x59);\n\t\t\t \n\t\t\tv4l2_dbg(1, debug, sd, \"switched to SECAM\\n\");\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int saa7110_s_routing(struct v4l2_subdev *sd,\n\t\t\t     u32 input, u32 output, u32 config)\n{\n\tstruct saa7110 *decoder = to_saa7110(sd);\n\n\tif (input >= SAA7110_MAX_INPUT) {\n\t\tv4l2_dbg(1, debug, sd, \"input=%d not available\\n\", input);\n\t\treturn -EINVAL;\n\t}\n\tif (decoder->input != input) {\n\t\tsaa7110_selmux(sd, input);\n\t\tv4l2_dbg(1, debug, sd, \"switched to input=%d\\n\", input);\n\t}\n\treturn 0;\n}\n\nstatic int saa7110_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct saa7110 *decoder = to_saa7110(sd);\n\n\tif (decoder->enable != enable) {\n\t\tdecoder->enable = enable;\n\t\tsaa7110_write(sd, 0x0E, enable ? 0x18 : 0x80);\n\t\tv4l2_dbg(1, debug, sd, \"YUV %s\\n\", enable ? \"on\" : \"off\");\n\t}\n\treturn 0;\n}\n\nstatic int saa7110_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsaa7110_write(sd, 0x19, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tsaa7110_write(sd, 0x13, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tsaa7110_write(sd, 0x12, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\tsaa7110_write(sd, 0x07, ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_ctrl_ops saa7110_ctrl_ops = {\n\t.s_ctrl = saa7110_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_video_ops saa7110_video_ops = {\n\t.s_std = saa7110_s_std,\n\t.s_routing = saa7110_s_routing,\n\t.s_stream = saa7110_s_stream,\n\t.querystd = saa7110_querystd,\n\t.g_input_status = saa7110_g_input_status,\n};\n\nstatic const struct v4l2_subdev_ops saa7110_ops = {\n\t.video = &saa7110_video_ops,\n};\n\n \n\nstatic int saa7110_probe(struct i2c_client *client)\n{\n\tstruct saa7110 *decoder;\n\tstruct v4l2_subdev *sd;\n\tint rv;\n\n\t \n\tif (!i2c_check_functionality(client->adapter,\n\t\tI2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tv4l_info(client, \"chip found @ 0x%x (%s)\\n\",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tdecoder = devm_kzalloc(&client->dev, sizeof(*decoder), GFP_KERNEL);\n\tif (!decoder)\n\t\treturn -ENOMEM;\n\tsd = &decoder->sd;\n\tv4l2_i2c_subdev_init(sd, client, &saa7110_ops);\n\tdecoder->norm = V4L2_STD_PAL;\n\tdecoder->input = 0;\n\tdecoder->enable = 1;\n\tv4l2_ctrl_handler_init(&decoder->hdl, 2);\n\tv4l2_ctrl_new_std(&decoder->hdl, &saa7110_ctrl_ops,\n\t\tV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(&decoder->hdl, &saa7110_ctrl_ops,\n\t\tV4L2_CID_CONTRAST, 0, 127, 1, 64);\n\tv4l2_ctrl_new_std(&decoder->hdl, &saa7110_ctrl_ops,\n\t\tV4L2_CID_SATURATION, 0, 127, 1, 64);\n\tv4l2_ctrl_new_std(&decoder->hdl, &saa7110_ctrl_ops,\n\t\tV4L2_CID_HUE, -128, 127, 1, 0);\n\tsd->ctrl_handler = &decoder->hdl;\n\tif (decoder->hdl.error) {\n\t\tint err = decoder->hdl.error;\n\n\t\tv4l2_ctrl_handler_free(&decoder->hdl);\n\t\treturn err;\n\t}\n\tv4l2_ctrl_handler_setup(&decoder->hdl);\n\n\tinit_waitqueue_head(&decoder->wq);\n\n\trv = saa7110_write_block(sd, initseq, sizeof(initseq));\n\tif (rv < 0) {\n\t\tv4l2_dbg(1, debug, sd, \"init status %d\\n\", rv);\n\t} else {\n\t\tint ver, status;\n\t\tsaa7110_write(sd, 0x21, 0x10);\n\t\tsaa7110_write(sd, 0x0e, 0x18);\n\t\tsaa7110_write(sd, 0x0D, 0x04);\n\t\tver = saa7110_read(sd);\n\t\tsaa7110_write(sd, 0x0D, 0x06);\n\t\t \n\t\tstatus = saa7110_read(sd);\n\t\tv4l2_dbg(1, debug, sd, \"version %x, status=0x%02x\\n\",\n\t\t\t       ver, status);\n\t\tsaa7110_write(sd, 0x0D, 0x86);\n\t\tsaa7110_write(sd, 0x0F, 0x10);\n\t\tsaa7110_write(sd, 0x11, 0x59);\n\t\t \n\t}\n\n\t \n\t \n\t \n\n\treturn 0;\n}\n\nstatic void saa7110_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct saa7110 *decoder = to_saa7110(sd);\n\n\tv4l2_device_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(&decoder->hdl);\n}\n\n \n\nstatic const struct i2c_device_id saa7110_id[] = {\n\t{ \"saa7110\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, saa7110_id);\n\nstatic struct i2c_driver saa7110_driver = {\n\t.driver = {\n\t\t.name\t= \"saa7110\",\n\t},\n\t.probe\t\t= saa7110_probe,\n\t.remove\t\t= saa7110_remove,\n\t.id_table\t= saa7110_id,\n};\n\nmodule_i2c_driver(saa7110_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}