{
  "module_name": "aptina-pll.c",
  "hash_id": "117faa7175ecf33b10eee0e4e7141a82488ff75f9c8926b2ad0ba463231d8f3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/aptina-pll.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/gcd.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include \"aptina-pll.h\"\n\nint aptina_pll_calculate(struct device *dev,\n\t\t\t const struct aptina_pll_limits *limits,\n\t\t\t struct aptina_pll *pll)\n{\n\tunsigned int mf_min;\n\tunsigned int mf_max;\n\tunsigned int p1_min;\n\tunsigned int p1_max;\n\tunsigned int p1;\n\tunsigned int div;\n\n\tdev_dbg(dev, \"PLL: ext clock %u pix clock %u\\n\",\n\t\tpll->ext_clock, pll->pix_clock);\n\n\tif (pll->ext_clock < limits->ext_clock_min ||\n\t    pll->ext_clock > limits->ext_clock_max) {\n\t\tdev_err(dev, \"pll: invalid external clock frequency.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pll->pix_clock == 0 || pll->pix_clock > limits->pix_clock_max) {\n\t\tdev_err(dev, \"pll: invalid pixel clock frequency.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdiv = gcd(pll->pix_clock, pll->ext_clock);\n\tpll->m = pll->pix_clock / div;\n\tdiv = pll->ext_clock / div;\n\n\t \n\tmf_min = DIV_ROUND_UP(limits->m_min, pll->m);\n\tmf_min = max(mf_min, limits->out_clock_min /\n\t\t     (pll->ext_clock / limits->n_min * pll->m));\n\tmf_min = max(mf_min, limits->n_min * limits->p1_min / div);\n\tmf_max = limits->m_max / pll->m;\n\tmf_max = min(mf_max, limits->out_clock_max /\n\t\t    (pll->ext_clock / limits->n_max * pll->m));\n\tmf_max = min(mf_max, DIV_ROUND_UP(limits->n_max * limits->p1_max, div));\n\n\tdev_dbg(dev, \"pll: mf min %u max %u\\n\", mf_min, mf_max);\n\tif (mf_min > mf_max) {\n\t\tdev_err(dev, \"pll: no valid combined N*P1 divisor.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (limits->p1_min == 0) {\n\t\tdev_err(dev, \"pll: P1 minimum value must be >0.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tp1_min = max(limits->p1_min, DIV_ROUND_UP(limits->out_clock_min * div,\n\t\t     pll->ext_clock * pll->m));\n\tp1_max = min(limits->p1_max, limits->out_clock_max * div /\n\t\t     (pll->ext_clock * pll->m));\n\n\tfor (p1 = p1_max & ~1; p1 >= p1_min; p1 -= 2) {\n\t\tunsigned int mf_inc = p1 / gcd(div, p1);\n\t\tunsigned int mf_high;\n\t\tunsigned int mf_low;\n\n\t\tmf_low = roundup(max(mf_min, DIV_ROUND_UP(pll->ext_clock * p1,\n\t\t\t\t\tlimits->int_clock_max * div)), mf_inc);\n\t\tmf_high = min(mf_max, pll->ext_clock * p1 /\n\t\t\t      (limits->int_clock_min * div));\n\n\t\tif (mf_low > mf_high)\n\t\t\tcontinue;\n\n\t\tpll->n = div * mf_low / p1;\n\t\tpll->m *= mf_low;\n\t\tpll->p1 = p1;\n\t\tdev_dbg(dev, \"PLL: N %u M %u P1 %u\\n\", pll->n, pll->m, pll->p1);\n\t\treturn 0;\n\t}\n\n\tdev_err(dev, \"pll: no valid N and P1 divisors found.\\n\");\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(aptina_pll_calculate);\n\nMODULE_DESCRIPTION(\"Aptina PLL Helpers\");\nMODULE_AUTHOR(\"Laurent Pinchart <laurent.pinchart@ideasonboard.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}