{
  "module_name": "saa7127.c",
  "hash_id": "5fb30ab0fcb7331465c0702a899d474a1c27415251d916ff15fb56650d75ef75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/saa7127.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n#include <media/i2c/saa7127.h>\n\nstatic int debug;\nstatic int test_image;\n\nMODULE_DESCRIPTION(\"Philips SAA7127/9 video encoder driver\");\nMODULE_AUTHOR(\"Kevin Thayer, Chris Kennedy, Hans Verkuil\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(debug, int, 0644);\nmodule_param(test_image, int, 0644);\nMODULE_PARM_DESC(debug, \"debug level (0-2)\");\nMODULE_PARM_DESC(test_image, \"test_image (0-1)\");\n\n\n \n\n#define SAA7127_REG_STATUS                           0x00\n#define SAA7127_REG_WIDESCREEN_CONFIG                0x26\n#define SAA7127_REG_WIDESCREEN_ENABLE                0x27\n#define SAA7127_REG_BURST_START                      0x28\n#define SAA7127_REG_BURST_END                        0x29\n#define SAA7127_REG_COPYGEN_0                        0x2a\n#define SAA7127_REG_COPYGEN_1                        0x2b\n#define SAA7127_REG_COPYGEN_2                        0x2c\n#define SAA7127_REG_OUTPUT_PORT_CONTROL              0x2d\n#define SAA7127_REG_GAIN_LUMINANCE_RGB               0x38\n#define SAA7127_REG_GAIN_COLORDIFF_RGB               0x39\n#define SAA7127_REG_INPUT_PORT_CONTROL_1             0x3a\n#define SAA7129_REG_FADE_KEY_COL2\t\t     0x4f\n#define SAA7127_REG_CHROMA_PHASE                     0x5a\n#define SAA7127_REG_GAINU                            0x5b\n#define SAA7127_REG_GAINV                            0x5c\n#define SAA7127_REG_BLACK_LEVEL                      0x5d\n#define SAA7127_REG_BLANKING_LEVEL                   0x5e\n#define SAA7127_REG_VBI_BLANKING                     0x5f\n#define SAA7127_REG_DAC_CONTROL                      0x61\n#define SAA7127_REG_BURST_AMP                        0x62\n#define SAA7127_REG_SUBC3                            0x63\n#define SAA7127_REG_SUBC2                            0x64\n#define SAA7127_REG_SUBC1                            0x65\n#define SAA7127_REG_SUBC0                            0x66\n#define SAA7127_REG_LINE_21_ODD_0                    0x67\n#define SAA7127_REG_LINE_21_ODD_1                    0x68\n#define SAA7127_REG_LINE_21_EVEN_0                   0x69\n#define SAA7127_REG_LINE_21_EVEN_1                   0x6a\n#define SAA7127_REG_RCV_PORT_CONTROL                 0x6b\n#define SAA7127_REG_VTRIG                            0x6c\n#define SAA7127_REG_HTRIG_HI                         0x6d\n#define SAA7127_REG_MULTI                            0x6e\n#define SAA7127_REG_CLOSED_CAPTION                   0x6f\n#define SAA7127_REG_RCV2_OUTPUT_START                0x70\n#define SAA7127_REG_RCV2_OUTPUT_END                  0x71\n#define SAA7127_REG_RCV2_OUTPUT_MSBS                 0x72\n#define SAA7127_REG_TTX_REQUEST_H_START              0x73\n#define SAA7127_REG_TTX_REQUEST_H_DELAY_LENGTH       0x74\n#define SAA7127_REG_CSYNC_ADVANCE_VSYNC_SHIFT        0x75\n#define SAA7127_REG_TTX_ODD_REQ_VERT_START           0x76\n#define SAA7127_REG_TTX_ODD_REQ_VERT_END             0x77\n#define SAA7127_REG_TTX_EVEN_REQ_VERT_START          0x78\n#define SAA7127_REG_TTX_EVEN_REQ_VERT_END            0x79\n#define SAA7127_REG_FIRST_ACTIVE                     0x7a\n#define SAA7127_REG_LAST_ACTIVE                      0x7b\n#define SAA7127_REG_MSB_VERTICAL                     0x7c\n#define SAA7127_REG_DISABLE_TTX_LINE_LO_0            0x7e\n#define SAA7127_REG_DISABLE_TTX_LINE_LO_1            0x7f\n\n \n\nstruct i2c_reg_value {\n\tunsigned char reg;\n\tunsigned char value;\n};\n\nstatic const struct i2c_reg_value saa7129_init_config_extra[] = {\n\t{ SAA7127_REG_OUTPUT_PORT_CONTROL,\t\t0x38 },\n\t{ SAA7127_REG_VTRIG,\t\t\t\t0xfa },\n\t{ 0, 0 }\n};\n\nstatic const struct i2c_reg_value saa7127_init_config_common[] = {\n\t{ SAA7127_REG_WIDESCREEN_CONFIG,\t\t0x0d },\n\t{ SAA7127_REG_WIDESCREEN_ENABLE,\t\t0x00 },\n\t{ SAA7127_REG_COPYGEN_0,\t\t\t0x77 },\n\t{ SAA7127_REG_COPYGEN_1,\t\t\t0x41 },\n\t{ SAA7127_REG_COPYGEN_2,\t\t\t0x00 },\t \n\t{ SAA7127_REG_OUTPUT_PORT_CONTROL,\t\t0xbf },\n\t{ SAA7127_REG_GAIN_LUMINANCE_RGB,\t\t0x00 },\n\t{ SAA7127_REG_GAIN_COLORDIFF_RGB,\t\t0x00 },\n\t{ SAA7127_REG_INPUT_PORT_CONTROL_1,\t\t0x80 },\t \n\t{ SAA7127_REG_LINE_21_ODD_0,\t\t\t0x77 },\n\t{ SAA7127_REG_LINE_21_ODD_1,\t\t\t0x41 },\n\t{ SAA7127_REG_LINE_21_EVEN_0,\t\t\t0x88 },\n\t{ SAA7127_REG_LINE_21_EVEN_1,\t\t\t0x41 },\n\t{ SAA7127_REG_RCV_PORT_CONTROL,\t\t\t0x12 },\n\t{ SAA7127_REG_VTRIG,\t\t\t\t0xf9 },\n\t{ SAA7127_REG_HTRIG_HI,\t\t\t\t0x00 },\n\t{ SAA7127_REG_RCV2_OUTPUT_START,\t\t0x41 },\n\t{ SAA7127_REG_RCV2_OUTPUT_END,\t\t\t0xc3 },\n\t{ SAA7127_REG_RCV2_OUTPUT_MSBS,\t\t\t0x00 },\n\t{ SAA7127_REG_TTX_REQUEST_H_START,\t\t0x3e },\n\t{ SAA7127_REG_TTX_REQUEST_H_DELAY_LENGTH,\t0xb8 },\n\t{ SAA7127_REG_CSYNC_ADVANCE_VSYNC_SHIFT,\t0x03 },\n\t{ SAA7127_REG_TTX_ODD_REQ_VERT_START,\t\t0x15 },\n\t{ SAA7127_REG_TTX_ODD_REQ_VERT_END,\t\t0x16 },\n\t{ SAA7127_REG_TTX_EVEN_REQ_VERT_START,\t\t0x15 },\n\t{ SAA7127_REG_TTX_EVEN_REQ_VERT_END,\t\t0x16 },\n\t{ SAA7127_REG_FIRST_ACTIVE,\t\t\t0x1a },\n\t{ SAA7127_REG_LAST_ACTIVE,\t\t\t0x01 },\n\t{ SAA7127_REG_MSB_VERTICAL,\t\t\t0xc0 },\n\t{ SAA7127_REG_DISABLE_TTX_LINE_LO_0,\t\t0x00 },\n\t{ SAA7127_REG_DISABLE_TTX_LINE_LO_1,\t\t0x00 },\n\t{ 0, 0 }\n};\n\n#define SAA7127_60HZ_DAC_CONTROL 0x15\nstatic const struct i2c_reg_value saa7127_init_config_60hz[] = {\n\t{ SAA7127_REG_BURST_START,\t\t\t0x19 },\n\t \n\t{ SAA7127_REG_BURST_END,\t\t\t0x1d },\n\t{ SAA7127_REG_CHROMA_PHASE,\t\t\t0xa3 },\n\t{ SAA7127_REG_GAINU,\t\t\t\t0x98 },\n\t{ SAA7127_REG_GAINV,\t\t\t\t0xd3 },\n\t{ SAA7127_REG_BLACK_LEVEL,\t\t\t0x39 },\n\t{ SAA7127_REG_BLANKING_LEVEL,\t\t\t0x2e },\n\t{ SAA7127_REG_VBI_BLANKING,\t\t\t0x2e },\n\t{ SAA7127_REG_DAC_CONTROL,\t\t\t0x15 },\n\t{ SAA7127_REG_BURST_AMP,\t\t\t0x4d },\n\t{ SAA7127_REG_SUBC3,\t\t\t\t0x1f },\n\t{ SAA7127_REG_SUBC2,\t\t\t\t0x7c },\n\t{ SAA7127_REG_SUBC1,\t\t\t\t0xf0 },\n\t{ SAA7127_REG_SUBC0,\t\t\t\t0x21 },\n\t{ SAA7127_REG_MULTI,\t\t\t\t0x90 },\n\t{ SAA7127_REG_CLOSED_CAPTION,\t\t\t0x11 },\n\t{ 0, 0 }\n};\n\n#define SAA7127_50HZ_PAL_DAC_CONTROL 0x02\nstatic struct i2c_reg_value saa7127_init_config_50hz_pal[] = {\n\t{ SAA7127_REG_BURST_START,\t\t\t0x21 },\n\t \n\t{ SAA7127_REG_BURST_END,\t\t\t0x1d },\n\t{ SAA7127_REG_CHROMA_PHASE,\t\t\t0x3f },\n\t{ SAA7127_REG_GAINU,\t\t\t\t0x7d },\n\t{ SAA7127_REG_GAINV,\t\t\t\t0xaf },\n\t{ SAA7127_REG_BLACK_LEVEL,\t\t\t0x33 },\n\t{ SAA7127_REG_BLANKING_LEVEL,\t\t\t0x35 },\n\t{ SAA7127_REG_VBI_BLANKING,\t\t\t0x35 },\n\t{ SAA7127_REG_DAC_CONTROL,\t\t\t0x02 },\n\t{ SAA7127_REG_BURST_AMP,\t\t\t0x2f },\n\t{ SAA7127_REG_SUBC3,\t\t\t\t0xcb },\n\t{ SAA7127_REG_SUBC2,\t\t\t\t0x8a },\n\t{ SAA7127_REG_SUBC1,\t\t\t\t0x09 },\n\t{ SAA7127_REG_SUBC0,\t\t\t\t0x2a },\n\t{ SAA7127_REG_MULTI,\t\t\t\t0xa0 },\n\t{ SAA7127_REG_CLOSED_CAPTION,\t\t\t0x00 },\n\t{ 0, 0 }\n};\n\n#define SAA7127_50HZ_SECAM_DAC_CONTROL 0x08\nstatic struct i2c_reg_value saa7127_init_config_50hz_secam[] = {\n\t{ SAA7127_REG_BURST_START,\t\t\t0x21 },\n\t \n\t{ SAA7127_REG_BURST_END,\t\t\t0x1d },\n\t{ SAA7127_REG_CHROMA_PHASE,\t\t\t0x3f },\n\t{ SAA7127_REG_GAINU,\t\t\t\t0x6a },\n\t{ SAA7127_REG_GAINV,\t\t\t\t0x81 },\n\t{ SAA7127_REG_BLACK_LEVEL,\t\t\t0x33 },\n\t{ SAA7127_REG_BLANKING_LEVEL,\t\t\t0x35 },\n\t{ SAA7127_REG_VBI_BLANKING,\t\t\t0x35 },\n\t{ SAA7127_REG_DAC_CONTROL,\t\t\t0x08 },\n\t{ SAA7127_REG_BURST_AMP,\t\t\t0x2f },\n\t{ SAA7127_REG_SUBC3,\t\t\t\t0xb2 },\n\t{ SAA7127_REG_SUBC2,\t\t\t\t0x3b },\n\t{ SAA7127_REG_SUBC1,\t\t\t\t0xa3 },\n\t{ SAA7127_REG_SUBC0,\t\t\t\t0x28 },\n\t{ SAA7127_REG_MULTI,\t\t\t\t0x90 },\n\t{ SAA7127_REG_CLOSED_CAPTION,\t\t\t0x00 },\n\t{ 0, 0 }\n};\n\n \n\nenum saa712x_model {\n\tSAA7127,\n\tSAA7129,\n};\n\nstruct saa7127_state {\n\tstruct v4l2_subdev sd;\n\tv4l2_std_id std;\n\tenum saa712x_model ident;\n\tenum saa7127_input_type input_type;\n\tenum saa7127_output_type output_type;\n\tint video_enable;\n\tint wss_enable;\n\tu16 wss_mode;\n\tint cc_enable;\n\tu16 cc_data;\n\tint xds_enable;\n\tu16 xds_data;\n\tint vps_enable;\n\tu8 vps_data[5];\n\tu8 reg_2d;\n\tu8 reg_3a;\n\tu8 reg_3a_cb;    \n\tu8 reg_61;\n};\n\nstatic inline struct saa7127_state *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct saa7127_state, sd);\n}\n\nstatic const char * const output_strs[] =\n{\n\t\"S-Video + Composite\",\n\t\"Composite\",\n\t\"S-Video\",\n\t\"RGB\",\n\t\"YUV C\",\n\t\"YUV V\"\n};\n\nstatic const char * const wss_strs[] = {\n\t\"invalid\",\n\t\"letterbox 14:9 center\",\n\t\"letterbox 14:9 top\",\n\t\"invalid\",\n\t\"letterbox 16:9 top\",\n\t\"invalid\",\n\t\"invalid\",\n\t\"16:9 full format anamorphic\",\n\t\"4:3 full format\",\n\t\"invalid\",\n\t\"invalid\",\n\t\"letterbox 16:9 center\",\n\t\"invalid\",\n\t\"letterbox >16:9 center\",\n\t\"14:9 full format center\",\n\t\"invalid\",\n};\n\n \n\nstatic int saa7127_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\n \n\nstatic int saa7127_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (i2c_smbus_write_byte_data(client, reg, val) == 0)\n\t\t\treturn 0;\n\t}\n\tv4l2_err(sd, \"I2C Write Problem\\n\");\n\treturn -1;\n}\n\n \n\nstatic int saa7127_write_inittab(struct v4l2_subdev *sd,\n\t\t\t\t const struct i2c_reg_value *regs)\n{\n\twhile (regs->reg != 0) {\n\t\tsaa7127_write(sd, regs->reg, regs->value);\n\t\tregs++;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int saa7127_set_vps(struct v4l2_subdev *sd, const struct v4l2_sliced_vbi_data *data)\n{\n\tstruct saa7127_state *state = to_state(sd);\n\tint enable = (data->line != 0);\n\n\tif (enable && (data->field != 0 || data->line != 16))\n\t\treturn -EINVAL;\n\tif (state->vps_enable != enable) {\n\t\tv4l2_dbg(1, debug, sd, \"Turn VPS Signal %s\\n\", enable ? \"on\" : \"off\");\n\t\tsaa7127_write(sd, 0x54, enable << 7);\n\t\tstate->vps_enable = enable;\n\t}\n\tif (!enable)\n\t\treturn 0;\n\n\tstate->vps_data[0] = data->data[2];\n\tstate->vps_data[1] = data->data[8];\n\tstate->vps_data[2] = data->data[9];\n\tstate->vps_data[3] = data->data[10];\n\tstate->vps_data[4] = data->data[11];\n\tv4l2_dbg(1, debug, sd, \"Set VPS data %*ph\\n\", 5, state->vps_data);\n\tsaa7127_write(sd, 0x55, state->vps_data[0]);\n\tsaa7127_write(sd, 0x56, state->vps_data[1]);\n\tsaa7127_write(sd, 0x57, state->vps_data[2]);\n\tsaa7127_write(sd, 0x58, state->vps_data[3]);\n\tsaa7127_write(sd, 0x59, state->vps_data[4]);\n\treturn 0;\n}\n\n \n\nstatic int saa7127_set_cc(struct v4l2_subdev *sd, const struct v4l2_sliced_vbi_data *data)\n{\n\tstruct saa7127_state *state = to_state(sd);\n\tu16 cc = data->data[1] << 8 | data->data[0];\n\tint enable = (data->line != 0);\n\n\tif (enable && (data->field != 0 || data->line != 21))\n\t\treturn -EINVAL;\n\tif (state->cc_enable != enable) {\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t\"Turn CC %s\\n\", enable ? \"on\" : \"off\");\n\t\tsaa7127_write(sd, SAA7127_REG_CLOSED_CAPTION,\n\t\t\t(state->xds_enable << 7) | (enable << 6) | 0x11);\n\t\tstate->cc_enable = enable;\n\t}\n\tif (!enable)\n\t\treturn 0;\n\n\tv4l2_dbg(2, debug, sd, \"CC data: %04x\\n\", cc);\n\tsaa7127_write(sd, SAA7127_REG_LINE_21_ODD_0, cc & 0xff);\n\tsaa7127_write(sd, SAA7127_REG_LINE_21_ODD_1, cc >> 8);\n\tstate->cc_data = cc;\n\treturn 0;\n}\n\n \n\nstatic int saa7127_set_xds(struct v4l2_subdev *sd, const struct v4l2_sliced_vbi_data *data)\n{\n\tstruct saa7127_state *state = to_state(sd);\n\tu16 xds = data->data[1] << 8 | data->data[0];\n\tint enable = (data->line != 0);\n\n\tif (enable && (data->field != 1 || data->line != 21))\n\t\treturn -EINVAL;\n\tif (state->xds_enable != enable) {\n\t\tv4l2_dbg(1, debug, sd, \"Turn XDS %s\\n\", enable ? \"on\" : \"off\");\n\t\tsaa7127_write(sd, SAA7127_REG_CLOSED_CAPTION,\n\t\t\t\t(enable << 7) | (state->cc_enable << 6) | 0x11);\n\t\tstate->xds_enable = enable;\n\t}\n\tif (!enable)\n\t\treturn 0;\n\n\tv4l2_dbg(2, debug, sd, \"XDS data: %04x\\n\", xds);\n\tsaa7127_write(sd, SAA7127_REG_LINE_21_EVEN_0, xds & 0xff);\n\tsaa7127_write(sd, SAA7127_REG_LINE_21_EVEN_1, xds >> 8);\n\tstate->xds_data = xds;\n\treturn 0;\n}\n\n \n\nstatic int saa7127_set_wss(struct v4l2_subdev *sd, const struct v4l2_sliced_vbi_data *data)\n{\n\tstruct saa7127_state *state = to_state(sd);\n\tint enable = (data->line != 0);\n\n\tif (enable && (data->field != 0 || data->line != 23))\n\t\treturn -EINVAL;\n\tif (state->wss_enable != enable) {\n\t\tv4l2_dbg(1, debug, sd, \"Turn WSS %s\\n\", enable ? \"on\" : \"off\");\n\t\tsaa7127_write(sd, 0x27, enable << 7);\n\t\tstate->wss_enable = enable;\n\t}\n\tif (!enable)\n\t\treturn 0;\n\n\tsaa7127_write(sd, 0x26, data->data[0]);\n\tsaa7127_write(sd, 0x27, 0x80 | (data->data[1] & 0x3f));\n\tv4l2_dbg(1, debug, sd,\n\t\t\"WSS mode: %s\\n\", wss_strs[data->data[0] & 0xf]);\n\tstate->wss_mode = (data->data[1] & 0x3f) << 8 | data->data[0];\n\treturn 0;\n}\n\n \n\nstatic int saa7127_set_video_enable(struct v4l2_subdev *sd, int enable)\n{\n\tstruct saa7127_state *state = to_state(sd);\n\n\tif (enable) {\n\t\tv4l2_dbg(1, debug, sd, \"Enable Video Output\\n\");\n\t\tsaa7127_write(sd, 0x2d, state->reg_2d);\n\t\tsaa7127_write(sd, 0x61, state->reg_61);\n\t} else {\n\t\tv4l2_dbg(1, debug, sd, \"Disable Video Output\\n\");\n\t\tsaa7127_write(sd, 0x2d, (state->reg_2d & 0xf0));\n\t\tsaa7127_write(sd, 0x61, (state->reg_61 | 0xc0));\n\t}\n\tstate->video_enable = enable;\n\treturn 0;\n}\n\n \n\nstatic int saa7127_set_std(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct saa7127_state *state = to_state(sd);\n\tconst struct i2c_reg_value *inittab;\n\n\tif (std & V4L2_STD_525_60) {\n\t\tv4l2_dbg(1, debug, sd, \"Selecting 60 Hz video Standard\\n\");\n\t\tinittab = saa7127_init_config_60hz;\n\t\tstate->reg_61 = SAA7127_60HZ_DAC_CONTROL;\n\n\t} else if (state->ident == SAA7129 &&\n\t\t   (std & V4L2_STD_SECAM) &&\n\t\t   !(std & (V4L2_STD_625_50 & ~V4L2_STD_SECAM))) {\n\n\t\t \n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t \"Selecting 50 Hz SECAM video Standard\\n\");\n\t\tinittab = saa7127_init_config_50hz_secam;\n\t\tstate->reg_61 = SAA7127_50HZ_SECAM_DAC_CONTROL;\n\n\t} else {\n\t\tv4l2_dbg(1, debug, sd, \"Selecting 50 Hz PAL video Standard\\n\");\n\t\tinittab = saa7127_init_config_50hz_pal;\n\t\tstate->reg_61 = SAA7127_50HZ_PAL_DAC_CONTROL;\n\t}\n\n\t \n\tsaa7127_write_inittab(sd, inittab);\n\tstate->std = std;\n\treturn 0;\n}\n\n \n\nstatic int saa7127_set_output_type(struct v4l2_subdev *sd, int output)\n{\n\tstruct saa7127_state *state = to_state(sd);\n\n\tswitch (output) {\n\tcase SAA7127_OUTPUT_TYPE_RGB:\n\t\tstate->reg_2d = 0x0f;\t \n\t\tstate->reg_3a = 0x13;\t \n\t\tbreak;\n\n\tcase SAA7127_OUTPUT_TYPE_COMPOSITE:\n\t\tif (state->ident == SAA7129)\n\t\t\tstate->reg_2d = 0x20;\t \n\t\telse\n\t\t\tstate->reg_2d = 0x08;\t \n\t\tstate->reg_3a = 0x13;\t \n\t\tbreak;\n\n\tcase SAA7127_OUTPUT_TYPE_SVIDEO:\n\t\tif (state->ident == SAA7129)\n\t\t\tstate->reg_2d = 0x18;\t \n\t\telse\n\t\t\tstate->reg_2d = 0xff;    \n\t\tstate->reg_3a = 0x13;\t \n\t\tbreak;\n\n\tcase SAA7127_OUTPUT_TYPE_YUV_V:\n\t\tstate->reg_2d = 0x4f;\t \n\t\tstate->reg_3a = 0x0b;\t \n\t\tbreak;\n\n\tcase SAA7127_OUTPUT_TYPE_YUV_C:\n\t\tstate->reg_2d = 0x0f;\t \n\t\tstate->reg_3a = 0x0b;\t \n\t\tbreak;\n\n\tcase SAA7127_OUTPUT_TYPE_BOTH:\n\t\tif (state->ident == SAA7129)\n\t\t\tstate->reg_2d = 0x38;\n\t\telse\n\t\t\tstate->reg_2d = 0xbf;\n\t\tstate->reg_3a = 0x13;\t \n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tv4l2_dbg(1, debug, sd,\n\t\t\"Selecting %s output type\\n\", output_strs[output]);\n\n\t \n\tsaa7127_write(sd, 0x2d, state->reg_2d);\n\tsaa7127_write(sd, 0x3a, state->reg_3a | state->reg_3a_cb);\n\tstate->output_type = output;\n\treturn 0;\n}\n\n \n\nstatic int saa7127_set_input_type(struct v4l2_subdev *sd, int input)\n{\n\tstruct saa7127_state *state = to_state(sd);\n\n\tswitch (input) {\n\tcase SAA7127_INPUT_TYPE_NORMAL:\t \n\t\tv4l2_dbg(1, debug, sd, \"Selecting Normal Encoder Input\\n\");\n\t\tstate->reg_3a_cb = 0;\n\t\tbreak;\n\n\tcase SAA7127_INPUT_TYPE_TEST_IMAGE:\t \n\t\tv4l2_dbg(1, debug, sd, \"Selecting Color Bar generator\\n\");\n\t\tstate->reg_3a_cb = 0x80;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tsaa7127_write(sd, 0x3a, state->reg_3a | state->reg_3a_cb);\n\tstate->input_type = input;\n\treturn 0;\n}\n\n \n\nstatic int saa7127_s_std_output(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct saa7127_state *state = to_state(sd);\n\n\tif (state->std == std)\n\t\treturn 0;\n\treturn saa7127_set_std(sd, std);\n}\n\nstatic int saa7127_s_routing(struct v4l2_subdev *sd,\n\t\t\t     u32 input, u32 output, u32 config)\n{\n\tstruct saa7127_state *state = to_state(sd);\n\tint rc = 0;\n\n\tif (state->input_type != input)\n\t\trc = saa7127_set_input_type(sd, input);\n\tif (rc == 0 && state->output_type != output)\n\t\trc = saa7127_set_output_type(sd, output);\n\treturn rc;\n}\n\nstatic int saa7127_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct saa7127_state *state = to_state(sd);\n\n\tif (state->video_enable == enable)\n\t\treturn 0;\n\treturn saa7127_set_video_enable(sd, enable);\n}\n\nstatic int saa7127_g_sliced_fmt(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_format *fmt)\n{\n\tstruct saa7127_state *state = to_state(sd);\n\n\tmemset(fmt->service_lines, 0, sizeof(fmt->service_lines));\n\tif (state->vps_enable)\n\t\tfmt->service_lines[0][16] = V4L2_SLICED_VPS;\n\tif (state->wss_enable)\n\t\tfmt->service_lines[0][23] = V4L2_SLICED_WSS_625;\n\tif (state->cc_enable) {\n\t\tfmt->service_lines[0][21] = V4L2_SLICED_CAPTION_525;\n\t\tfmt->service_lines[1][21] = V4L2_SLICED_CAPTION_525;\n\t}\n\tfmt->service_set =\n\t\t(state->vps_enable ? V4L2_SLICED_VPS : 0) |\n\t\t(state->wss_enable ? V4L2_SLICED_WSS_625 : 0) |\n\t\t(state->cc_enable ? V4L2_SLICED_CAPTION_525 : 0);\n\treturn 0;\n}\n\nstatic int saa7127_s_vbi_data(struct v4l2_subdev *sd, const struct v4l2_sliced_vbi_data *data)\n{\n\tswitch (data->id) {\n\tcase V4L2_SLICED_WSS_625:\n\t\treturn saa7127_set_wss(sd, data);\n\tcase V4L2_SLICED_VPS:\n\t\treturn saa7127_set_vps(sd, data);\n\tcase V4L2_SLICED_CAPTION_525:\n\t\tif (data->field == 0)\n\t\t\treturn saa7127_set_cc(sd, data);\n\t\treturn saa7127_set_xds(sd, data);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int saa7127_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\n{\n\treg->val = saa7127_read(sd, reg->reg & 0xff);\n\treg->size = 1;\n\treturn 0;\n}\n\nstatic int saa7127_s_register(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg)\n{\n\tsaa7127_write(sd, reg->reg & 0xff, reg->val & 0xff);\n\treturn 0;\n}\n#endif\n\nstatic int saa7127_log_status(struct v4l2_subdev *sd)\n{\n\tstruct saa7127_state *state = to_state(sd);\n\n\tv4l2_info(sd, \"Standard: %s\\n\", (state->std & V4L2_STD_525_60) ? \"60 Hz\" : \"50 Hz\");\n\tv4l2_info(sd, \"Input:    %s\\n\", state->input_type ?  \"color bars\" : \"normal\");\n\tv4l2_info(sd, \"Output:   %s\\n\", state->video_enable ?\n\t\t\toutput_strs[state->output_type] : \"disabled\");\n\tv4l2_info(sd, \"WSS:      %s\\n\", state->wss_enable ?\n\t\t\twss_strs[state->wss_mode] : \"disabled\");\n\tv4l2_info(sd, \"VPS:      %s\\n\", state->vps_enable ? \"enabled\" : \"disabled\");\n\tv4l2_info(sd, \"CC:       %s\\n\", state->cc_enable ? \"enabled\" : \"disabled\");\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_subdev_core_ops saa7127_core_ops = {\n\t.log_status = saa7127_log_status,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = saa7127_g_register,\n\t.s_register = saa7127_s_register,\n#endif\n};\n\nstatic const struct v4l2_subdev_video_ops saa7127_video_ops = {\n\t.s_std_output = saa7127_s_std_output,\n\t.s_routing = saa7127_s_routing,\n\t.s_stream = saa7127_s_stream,\n};\n\nstatic const struct v4l2_subdev_vbi_ops saa7127_vbi_ops = {\n\t.s_vbi_data = saa7127_s_vbi_data,\n\t.g_sliced_fmt = saa7127_g_sliced_fmt,\n};\n\nstatic const struct v4l2_subdev_ops saa7127_ops = {\n\t.core = &saa7127_core_ops,\n\t.video = &saa7127_video_ops,\n\t.vbi = &saa7127_vbi_ops,\n};\n\n \n\nstatic int saa7127_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct saa7127_state *state;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_sliced_vbi_data vbi = { 0, 0, 0, 0 };   \n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tv4l_dbg(1, debug, client, \"detecting saa7127 client on address 0x%x\\n\",\n\t\t\tclient->addr << 1);\n\n\tstate = devm_kzalloc(&client->dev, sizeof(*state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\n\tsd = &state->sd;\n\tv4l2_i2c_subdev_init(sd, client, &saa7127_ops);\n\n\t \n\tif ((saa7127_read(sd, 0) & 0xe4) != 0 ||\n\t\t\t(saa7127_read(sd, 0x29) & 0x3f) != 0x1d) {\n\t\tv4l2_dbg(1, debug, sd, \"saa7127 not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (id->driver_data) {\t \n\t\tstate->ident = id->driver_data;\n\t} else {\t\t \n\t\tint read_result;\n\n\t\t \n\t\tread_result = saa7127_read(sd, SAA7129_REG_FADE_KEY_COL2);\n\t\tsaa7127_write(sd, SAA7129_REG_FADE_KEY_COL2, 0xaa);\n\t\tif (saa7127_read(sd, SAA7129_REG_FADE_KEY_COL2) == 0xaa) {\n\t\t\tsaa7127_write(sd, SAA7129_REG_FADE_KEY_COL2,\n\t\t\t\t\tread_result);\n\t\t\tstate->ident = SAA7129;\n\t\t\tstrscpy(client->name, \"saa7129\", I2C_NAME_SIZE);\n\t\t} else {\n\t\t\tstate->ident = SAA7127;\n\t\t\tstrscpy(client->name, \"saa7127\", I2C_NAME_SIZE);\n\t\t}\n\t}\n\n\tv4l2_info(sd, \"%s found @ 0x%x (%s)\\n\", client->name,\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tv4l2_dbg(1, debug, sd, \"Configuring encoder\\n\");\n\tsaa7127_write_inittab(sd, saa7127_init_config_common);\n\tsaa7127_set_std(sd, V4L2_STD_NTSC);\n\tsaa7127_set_output_type(sd, SAA7127_OUTPUT_TYPE_BOTH);\n\tsaa7127_set_vps(sd, &vbi);\n\tsaa7127_set_wss(sd, &vbi);\n\tsaa7127_set_cc(sd, &vbi);\n\tsaa7127_set_xds(sd, &vbi);\n\tif (test_image == 1)\n\t\t \n\t\t \n\t\tsaa7127_set_input_type(sd, SAA7127_INPUT_TYPE_TEST_IMAGE);\n\telse\n\t\tsaa7127_set_input_type(sd, SAA7127_INPUT_TYPE_NORMAL);\n\tsaa7127_set_video_enable(sd, 1);\n\n\tif (state->ident == SAA7129)\n\t\tsaa7127_write_inittab(sd, saa7129_init_config_extra);\n\treturn 0;\n}\n\n \n\nstatic void saa7127_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\n\tv4l2_device_unregister_subdev(sd);\n\t \n\tsaa7127_set_video_enable(sd, 0);\n}\n\n \n\nstatic const struct i2c_device_id saa7127_id[] = {\n\t{ \"saa7127_auto\", 0 },\t \n\t{ \"saa7126\", SAA7127 },\n\t{ \"saa7127\", SAA7127 },\n\t{ \"saa7128\", SAA7129 },\n\t{ \"saa7129\", SAA7129 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, saa7127_id);\n\nstatic struct i2c_driver saa7127_driver = {\n\t.driver = {\n\t\t.name\t= \"saa7127\",\n\t},\n\t.probe\t\t= saa7127_probe,\n\t.remove\t\t= saa7127_remove,\n\t.id_table\t= saa7127_id,\n};\n\nmodule_i2c_driver(saa7127_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}