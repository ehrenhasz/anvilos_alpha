{
  "module_name": "tlv320aic23b.c",
  "hash_id": "756300e7e4bfc43a66eaf36c24efa51a0e856fa1a008b913193fdc67e7c02b83",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/tlv320aic23b.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/ioctl.h>\n#include <linux/uaccess.h>\n#include <linux/i2c.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n\nMODULE_DESCRIPTION(\"tlv320aic23b driver\");\nMODULE_AUTHOR(\"Scott Alfter, Ulf Eklund, Hans Verkuil\");\nMODULE_LICENSE(\"GPL\");\n\n\n \n\nstruct tlv320aic23b_state {\n\tstruct v4l2_subdev sd;\n\tstruct v4l2_ctrl_handler hdl;\n};\n\nstatic inline struct tlv320aic23b_state *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct tlv320aic23b_state, sd);\n}\n\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct tlv320aic23b_state, hdl)->sd;\n}\n\nstatic int tlv320aic23b_write(struct v4l2_subdev *sd, int reg, u16 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint i;\n\n\tif ((reg < 0 || reg > 9) && (reg != 15)) {\n\t\tv4l2_err(sd, \"Invalid register R%d\\n\", reg);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t\tif (i2c_smbus_write_byte_data(client,\n\t\t\t\t(reg << 1) | (val >> 8), val & 0xff) == 0)\n\t\t\treturn 0;\n\tv4l2_err(sd, \"I2C: cannot write %03x to register R%d\\n\", val, reg);\n\treturn -1;\n}\n\nstatic int tlv320aic23b_s_clock_freq(struct v4l2_subdev *sd, u32 freq)\n{\n\tswitch (freq) {\n\tcase 32000:  \n\t\ttlv320aic23b_write(sd, 8, 0x018);\n\t\tbreak;\n\tcase 44100:  \n\t\ttlv320aic23b_write(sd, 8, 0x022);\n\t\tbreak;\n\tcase 48000:  \n\t\ttlv320aic23b_write(sd, 8, 0x000);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int tlv320aic23b_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\ttlv320aic23b_write(sd, 0, 0x180);  \n\t\t \n\t\tif (!ctrl->val)\n\t\t\ttlv320aic23b_write(sd, 0, 0x119);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int tlv320aic23b_log_status(struct v4l2_subdev *sd)\n{\n\tstruct tlv320aic23b_state *state = to_state(sd);\n\n\tv4l2_ctrl_handler_log_status(&state->hdl, sd->name);\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_ctrl_ops tlv320aic23b_ctrl_ops = {\n\t.s_ctrl = tlv320aic23b_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops tlv320aic23b_core_ops = {\n\t.log_status = tlv320aic23b_log_status,\n};\n\nstatic const struct v4l2_subdev_audio_ops tlv320aic23b_audio_ops = {\n\t.s_clock_freq = tlv320aic23b_s_clock_freq,\n};\n\nstatic const struct v4l2_subdev_ops tlv320aic23b_ops = {\n\t.core = &tlv320aic23b_core_ops,\n\t.audio = &tlv320aic23b_audio_ops,\n};\n\n \n\n \n\n \n\nstatic int tlv320aic23b_probe(struct i2c_client *client)\n{\n\tstruct tlv320aic23b_state *state;\n\tstruct v4l2_subdev *sd;\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tv4l_info(client, \"chip found @ 0x%x (%s)\\n\",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tstate = devm_kzalloc(&client->dev, sizeof(*state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\tsd = &state->sd;\n\tv4l2_i2c_subdev_init(sd, client, &tlv320aic23b_ops);\n\n\t \n\n\t \n\ttlv320aic23b_write(sd, 15, 0x000);\n\t \n\ttlv320aic23b_write(sd, 6, 0x00A);\n\t \n\ttlv320aic23b_write(sd, 7, 0x049);\n\t \n\ttlv320aic23b_write(sd, 0, 0x119);\n\t \n\ttlv320aic23b_write(sd, 8, 0x000);\n\t \n\ttlv320aic23b_write(sd, 9, 0x001);\n\n\tv4l2_ctrl_handler_init(&state->hdl, 1);\n\tv4l2_ctrl_new_std(&state->hdl, &tlv320aic23b_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_MUTE, 0, 1, 1, 0);\n\tsd->ctrl_handler = &state->hdl;\n\tif (state->hdl.error) {\n\t\tint err = state->hdl.error;\n\n\t\tv4l2_ctrl_handler_free(&state->hdl);\n\t\treturn err;\n\t}\n\tv4l2_ctrl_handler_setup(&state->hdl);\n\treturn 0;\n}\n\nstatic void tlv320aic23b_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct tlv320aic23b_state *state = to_state(sd);\n\n\tv4l2_device_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(&state->hdl);\n}\n\n \n\nstatic const struct i2c_device_id tlv320aic23b_id[] = {\n\t{ \"tlv320aic23b\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tlv320aic23b_id);\n\nstatic struct i2c_driver tlv320aic23b_driver = {\n\t.driver = {\n\t\t.name\t= \"tlv320aic23b\",\n\t},\n\t.probe\t\t= tlv320aic23b_probe,\n\t.remove\t\t= tlv320aic23b_remove,\n\t.id_table\t= tlv320aic23b_id,\n};\n\nmodule_i2c_driver(tlv320aic23b_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}