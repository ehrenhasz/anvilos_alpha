{
  "module_name": "ov5693.c",
  "hash_id": "f557cfd737b3ab8b6db0d7843cc4d4f23fce5a5b6fbb107d2d89b99dbada2039",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ov5693.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include <media/v4l2-cci.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n\n \n#define OV5693_SW_RESET_REG\t\t\tCCI_REG8(0x0103)\n#define OV5693_SW_STREAM_REG\t\t\tCCI_REG8(0x0100)\n#define OV5693_START_STREAMING\t\t\t0x01\n#define OV5693_STOP_STREAMING\t\t\t0x00\n#define OV5693_SW_RESET\t\t\t\t0x01\n\n#define OV5693_REG_CHIP_ID\t\t\tCCI_REG16(0x300a)\n \n#define OV5693_CHIP_ID\t\t\t\t0x5690\n\n \n#define OV5693_EXPOSURE_CTRL_REG\t\tCCI_REG24(0x3500)\n#define OV5693_EXPOSURE_CTRL_MASK\t\tGENMASK(19, 4)\n#define OV5693_INTEGRATION_TIME_MARGIN\t\t8\n#define OV5693_EXPOSURE_MIN\t\t\t1\n#define OV5693_EXPOSURE_STEP\t\t\t1\n\n \n#define OV5693_GAIN_CTRL_REG\t\t\tCCI_REG16(0x350a)\n#define OV5693_GAIN_CTRL_MASK\t\t\tGENMASK(10, 4)\n#define OV5693_GAIN_MIN\t\t\t\t1\n#define OV5693_GAIN_MAX\t\t\t\t127\n#define OV5693_GAIN_DEF\t\t\t\t8\n#define OV5693_GAIN_STEP\t\t\t1\n\n \n#define OV5693_MWB_RED_GAIN_REG\t\t\tCCI_REG16(0x3400)\n#define OV5693_MWB_GREEN_GAIN_REG\t\tCCI_REG16(0x3402)\n#define OV5693_MWB_BLUE_GAIN_REG\t\tCCI_REG16(0x3404)\n#define OV5693_MWB_GAIN_MASK\t\t\tGENMASK(11, 0)\n#define OV5693_MWB_GAIN_MAX\t\t\t0x0fff\n#define OV5693_DIGITAL_GAIN_MIN\t\t\t1\n#define OV5693_DIGITAL_GAIN_MAX\t\t\t4095\n#define OV5693_DIGITAL_GAIN_DEF\t\t\t1024\n#define OV5693_DIGITAL_GAIN_STEP\t\t1\n\n \n#define OV5693_CROP_START_X_REG\t\t\tCCI_REG16(0x3800)\n#define OV5693_CROP_START_Y_REG\t\t\tCCI_REG16(0x3802)\n#define OV5693_CROP_END_X_REG\t\t\tCCI_REG16(0x3804)\n#define OV5693_CROP_END_Y_REG\t\t\tCCI_REG16(0x3806)\n#define OV5693_OUTPUT_SIZE_X_REG\t\tCCI_REG16(0x3808)\n#define OV5693_OUTPUT_SIZE_Y_REG\t\tCCI_REG16(0x380a)\n\n#define OV5693_TIMING_HTS_REG\t\t\tCCI_REG16(0x380c)\n#define OV5693_FIXED_PPL\t\t\t2688U\n#define OV5693_TIMING_VTS_REG\t\t\tCCI_REG16(0x380e)\n#define OV5693_TIMING_MAX_VTS\t\t\t0xffff\n#define OV5693_TIMING_MIN_VTS\t\t\t0x04\n\n#define OV5693_OFFSET_START_X_REG\t\tCCI_REG16(0x3810)\n#define OV5693_OFFSET_START_Y_REG\t\tCCI_REG16(0x3812)\n\n#define OV5693_SUB_INC_X_REG\t\t\tCCI_REG8(0x3814)\n#define OV5693_SUB_INC_Y_REG\t\t\tCCI_REG8(0x3815)\n\n#define OV5693_FORMAT1_REG\t\t\tCCI_REG8(0x3820)\n#define OV5693_FORMAT1_FLIP_VERT_ISP_EN\t\tBIT(6)\n#define OV5693_FORMAT1_FLIP_VERT_SENSOR_EN\tBIT(1)\n#define OV5693_FORMAT1_VBIN_EN\t\t\tBIT(0)\n#define OV5693_FORMAT2_REG\t\t\tCCI_REG8(0x3821)\n#define OV5693_FORMAT2_HDR_EN\t\t\tBIT(7)\n#define OV5693_FORMAT2_FLIP_HORZ_ISP_EN\t\tBIT(2)\n#define OV5693_FORMAT2_FLIP_HORZ_SENSOR_EN\tBIT(1)\n#define OV5693_FORMAT2_HBIN_EN\t\t\tBIT(0)\n\n#define OV5693_ISP_CTRL2_REG\t\t\tCCI_REG8(0x5002)\n#define OV5693_ISP_SCALE_ENABLE\t\t\tBIT(7)\n\n \n#define OV5693_NATIVE_WIDTH\t\t\t2624\n#define OV5693_NATIVE_HEIGHT\t\t\t1956\n#define OV5693_NATIVE_START_LEFT\t\t0\n#define OV5693_NATIVE_START_TOP\t\t\t0\n#define OV5693_ACTIVE_WIDTH\t\t\t2592\n#define OV5693_ACTIVE_HEIGHT\t\t\t1944\n#define OV5693_ACTIVE_START_LEFT\t\t16\n#define OV5693_ACTIVE_START_TOP\t\t\t6\n#define OV5693_MIN_CROP_WIDTH\t\t\t2\n#define OV5693_MIN_CROP_HEIGHT\t\t\t2\n\n \n#define OV5693_TEST_PATTERN_REG\t\t\tCCI_REG8(0x5e00)\n#define OV5693_TEST_PATTERN_ENABLE\t\tBIT(7)\n#define OV5693_TEST_PATTERN_ROLLING\t\tBIT(6)\n#define OV5693_TEST_PATTERN_RANDOM\t\t0x01\n#define OV5693_TEST_PATTERN_BARS\t\t0x00\n\n \n#define OV5693_XVCLK_FREQ\t\t\t19200000\n#define OV5693_LINK_FREQ_419_2MHZ\t\t419200000\n#define OV5693_PIXEL_RATE\t\t\t167680000\n\n#define to_ov5693_sensor(x) container_of(x, struct ov5693_device, sd)\n\nstatic const char * const ov5693_supply_names[] = {\n\t\"avdd\",\t\t \n\t\"dovdd\",\t \n\t\"dvdd\",\t\t \n};\n\n#define OV5693_NUM_SUPPLIES\tARRAY_SIZE(ov5693_supply_names)\n\nstruct ov5693_device {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\n\t \n\tstruct mutex lock;\n\n\tstruct gpio_desc *reset;\n\tstruct gpio_desc *powerdown;\n\tstruct gpio_desc *privacy_led;\n\tstruct regulator_bulk_data supplies[OV5693_NUM_SUPPLIES];\n\tstruct clk *xvclk;\n\n\tstruct ov5693_mode {\n\t\tstruct v4l2_rect crop;\n\t\tstruct v4l2_mbus_framefmt format;\n\t\tbool binning_x;\n\t\tbool binning_y;\n\t\tunsigned int inc_x_odd;\n\t\tunsigned int inc_y_odd;\n\t\tunsigned int vts;\n\t} mode;\n\tbool streaming;\n\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pad;\n\n\tstruct ov5693_v4l2_ctrls {\n\t\tstruct v4l2_ctrl_handler handler;\n\t\tstruct v4l2_ctrl *link_freq;\n\t\tstruct v4l2_ctrl *pixel_rate;\n\t\tstruct v4l2_ctrl *exposure;\n\t\tstruct v4l2_ctrl *analogue_gain;\n\t\tstruct v4l2_ctrl *digital_gain;\n\t\tstruct v4l2_ctrl *hflip;\n\t\tstruct v4l2_ctrl *vflip;\n\t\tstruct v4l2_ctrl *hblank;\n\t\tstruct v4l2_ctrl *vblank;\n\t\tstruct v4l2_ctrl *test_pattern;\n\t} ctrls;\n};\n\nstatic const struct cci_reg_sequence ov5693_global_regs[] = {\n\t{CCI_REG8(0x3016), 0xf0},\n\t{CCI_REG8(0x3017), 0xf0},\n\t{CCI_REG8(0x3018), 0xf0},\n\t{CCI_REG8(0x3022), 0x01},\n\t{CCI_REG8(0x3028), 0x44},\n\t{CCI_REG8(0x3098), 0x02},\n\t{CCI_REG8(0x3099), 0x19},\n\t{CCI_REG8(0x309a), 0x02},\n\t{CCI_REG8(0x309b), 0x01},\n\t{CCI_REG8(0x309c), 0x00},\n\t{CCI_REG8(0x30a0), 0xd2},\n\t{CCI_REG8(0x30a2), 0x01},\n\t{CCI_REG8(0x30b2), 0x00},\n\t{CCI_REG8(0x30b3), 0x83},\n\t{CCI_REG8(0x30b4), 0x03},\n\t{CCI_REG8(0x30b5), 0x04},\n\t{CCI_REG8(0x30b6), 0x01},\n\t{CCI_REG8(0x3080), 0x01},\n\t{CCI_REG8(0x3104), 0x21},\n\t{CCI_REG8(0x3106), 0x00},\n\t{CCI_REG8(0x3406), 0x01},\n\t{CCI_REG8(0x3503), 0x07},\n\t{CCI_REG8(0x350b), 0x40},\n\t{CCI_REG8(0x3601), 0x0a},\n\t{CCI_REG8(0x3602), 0x38},\n\t{CCI_REG8(0x3612), 0x80},\n\t{CCI_REG8(0x3620), 0x54},\n\t{CCI_REG8(0x3621), 0xc7},\n\t{CCI_REG8(0x3622), 0x0f},\n\t{CCI_REG8(0x3625), 0x10},\n\t{CCI_REG8(0x3630), 0x55},\n\t{CCI_REG8(0x3631), 0xf4},\n\t{CCI_REG8(0x3632), 0x00},\n\t{CCI_REG8(0x3633), 0x34},\n\t{CCI_REG8(0x3634), 0x02},\n\t{CCI_REG8(0x364d), 0x0d},\n\t{CCI_REG8(0x364f), 0xdd},\n\t{CCI_REG8(0x3660), 0x04},\n\t{CCI_REG8(0x3662), 0x10},\n\t{CCI_REG8(0x3663), 0xf1},\n\t{CCI_REG8(0x3665), 0x00},\n\t{CCI_REG8(0x3666), 0x20},\n\t{CCI_REG8(0x3667), 0x00},\n\t{CCI_REG8(0x366a), 0x80},\n\t{CCI_REG8(0x3680), 0xe0},\n\t{CCI_REG8(0x3681), 0x00},\n\t{CCI_REG8(0x3700), 0x42},\n\t{CCI_REG8(0x3701), 0x14},\n\t{CCI_REG8(0x3702), 0xa0},\n\t{CCI_REG8(0x3703), 0xd8},\n\t{CCI_REG8(0x3704), 0x78},\n\t{CCI_REG8(0x3705), 0x02},\n\t{CCI_REG8(0x370a), 0x00},\n\t{CCI_REG8(0x370b), 0x20},\n\t{CCI_REG8(0x370c), 0x0c},\n\t{CCI_REG8(0x370d), 0x11},\n\t{CCI_REG8(0x370e), 0x00},\n\t{CCI_REG8(0x370f), 0x40},\n\t{CCI_REG8(0x3710), 0x00},\n\t{CCI_REG8(0x371a), 0x1c},\n\t{CCI_REG8(0x371b), 0x05},\n\t{CCI_REG8(0x371c), 0x01},\n\t{CCI_REG8(0x371e), 0xa1},\n\t{CCI_REG8(0x371f), 0x0c},\n\t{CCI_REG8(0x3721), 0x00},\n\t{CCI_REG8(0x3724), 0x10},\n\t{CCI_REG8(0x3726), 0x00},\n\t{CCI_REG8(0x372a), 0x01},\n\t{CCI_REG8(0x3730), 0x10},\n\t{CCI_REG8(0x3738), 0x22},\n\t{CCI_REG8(0x3739), 0xe5},\n\t{CCI_REG8(0x373a), 0x50},\n\t{CCI_REG8(0x373b), 0x02},\n\t{CCI_REG8(0x373c), 0x41},\n\t{CCI_REG8(0x373f), 0x02},\n\t{CCI_REG8(0x3740), 0x42},\n\t{CCI_REG8(0x3741), 0x02},\n\t{CCI_REG8(0x3742), 0x18},\n\t{CCI_REG8(0x3743), 0x01},\n\t{CCI_REG8(0x3744), 0x02},\n\t{CCI_REG8(0x3747), 0x10},\n\t{CCI_REG8(0x374c), 0x04},\n\t{CCI_REG8(0x3751), 0xf0},\n\t{CCI_REG8(0x3752), 0x00},\n\t{CCI_REG8(0x3753), 0x00},\n\t{CCI_REG8(0x3754), 0xc0},\n\t{CCI_REG8(0x3755), 0x00},\n\t{CCI_REG8(0x3756), 0x1a},\n\t{CCI_REG8(0x3758), 0x00},\n\t{CCI_REG8(0x3759), 0x0f},\n\t{CCI_REG8(0x376b), 0x44},\n\t{CCI_REG8(0x375c), 0x04},\n\t{CCI_REG8(0x3774), 0x10},\n\t{CCI_REG8(0x3776), 0x00},\n\t{CCI_REG8(0x377f), 0x08},\n\t{CCI_REG8(0x3780), 0x22},\n\t{CCI_REG8(0x3781), 0x0c},\n\t{CCI_REG8(0x3784), 0x2c},\n\t{CCI_REG8(0x3785), 0x1e},\n\t{CCI_REG8(0x378f), 0xf5},\n\t{CCI_REG8(0x3791), 0xb0},\n\t{CCI_REG8(0x3795), 0x00},\n\t{CCI_REG8(0x3796), 0x64},\n\t{CCI_REG8(0x3797), 0x11},\n\t{CCI_REG8(0x3798), 0x30},\n\t{CCI_REG8(0x3799), 0x41},\n\t{CCI_REG8(0x379a), 0x07},\n\t{CCI_REG8(0x379b), 0xb0},\n\t{CCI_REG8(0x379c), 0x0c},\n\t{CCI_REG8(0x3a04), 0x06},\n\t{CCI_REG8(0x3a05), 0x14},\n\t{CCI_REG8(0x3e07), 0x20},\n\t{CCI_REG8(0x4000), 0x08},\n\t{CCI_REG8(0x4001), 0x04},\n\t{CCI_REG8(0x4004), 0x08},\n\t{CCI_REG8(0x4006), 0x20},\n\t{CCI_REG8(0x4008), 0x24},\n\t{CCI_REG8(0x4009), 0x10},\n\t{CCI_REG8(0x4058), 0x00},\n\t{CCI_REG8(0x4101), 0xb2},\n\t{CCI_REG8(0x4307), 0x31},\n\t{CCI_REG8(0x4511), 0x05},\n\t{CCI_REG8(0x4512), 0x01},\n\t{CCI_REG8(0x481f), 0x30},\n\t{CCI_REG8(0x4826), 0x2c},\n\t{CCI_REG8(0x4d02), 0xfd},\n\t{CCI_REG8(0x4d03), 0xf5},\n\t{CCI_REG8(0x4d04), 0x0c},\n\t{CCI_REG8(0x4d05), 0xcc},\n\t{CCI_REG8(0x4837), 0x0a},\n\t{CCI_REG8(0x5003), 0x20},\n\t{CCI_REG8(0x5013), 0x00},\n\t{CCI_REG8(0x5842), 0x01},\n\t{CCI_REG8(0x5843), 0x2b},\n\t{CCI_REG8(0x5844), 0x01},\n\t{CCI_REG8(0x5845), 0x92},\n\t{CCI_REG8(0x5846), 0x01},\n\t{CCI_REG8(0x5847), 0x8f},\n\t{CCI_REG8(0x5848), 0x01},\n\t{CCI_REG8(0x5849), 0x0c},\n\t{CCI_REG8(0x5e10), 0x0c},\n\t{CCI_REG8(0x3820), 0x00},\n\t{CCI_REG8(0x3821), 0x1e},\n\t{CCI_REG8(0x5041), 0x14}\n};\n\nstatic const struct v4l2_rect ov5693_default_crop = {\n\t.left = OV5693_ACTIVE_START_LEFT,\n\t.top = OV5693_ACTIVE_START_TOP,\n\t.width = OV5693_ACTIVE_WIDTH,\n\t.height = OV5693_ACTIVE_HEIGHT,\n};\n\nstatic const struct v4l2_mbus_framefmt ov5693_default_fmt = {\n\t.width = OV5693_ACTIVE_WIDTH,\n\t.height = OV5693_ACTIVE_HEIGHT,\n\t.code = MEDIA_BUS_FMT_SBGGR10_1X10,\n};\n\nstatic const s64 link_freq_menu_items[] = {\n\tOV5693_LINK_FREQ_419_2MHZ\n};\n\nstatic const char * const ov5693_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Random Data\",\n\t\"Colour Bars\",\n\t\"Colour Bars with Rolling Bar\"\n};\n\nstatic const u8 ov5693_test_pattern_bits[] = {\n\t0,\n\tOV5693_TEST_PATTERN_ENABLE | OV5693_TEST_PATTERN_RANDOM,\n\tOV5693_TEST_PATTERN_ENABLE | OV5693_TEST_PATTERN_BARS,\n\tOV5693_TEST_PATTERN_ENABLE | OV5693_TEST_PATTERN_BARS |\n\tOV5693_TEST_PATTERN_ROLLING,\n};\n\n \n\nstatic int ov5693_flip_vert_configure(struct ov5693_device *ov5693,\n\t\t\t\t      bool enable)\n{\n\tu8 bits = OV5693_FORMAT1_FLIP_VERT_ISP_EN |\n\t\t  OV5693_FORMAT1_FLIP_VERT_SENSOR_EN;\n\tint ret;\n\n\tret = cci_update_bits(ov5693->regmap, OV5693_FORMAT1_REG, bits,\n\t\t\t      enable ? bits : 0, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ov5693_flip_horz_configure(struct ov5693_device *ov5693,\n\t\t\t\t      bool enable)\n{\n\tu8 bits = OV5693_FORMAT2_FLIP_HORZ_ISP_EN |\n\t\t  OV5693_FORMAT2_FLIP_HORZ_SENSOR_EN;\n\tint ret;\n\n\tret = cci_update_bits(ov5693->regmap, OV5693_FORMAT2_REG, bits,\n\t\t\t      enable ? bits : 0, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ov5693_get_exposure(struct ov5693_device *ov5693, s32 *value)\n{\n\tu64 exposure;\n\tint ret;\n\n\tret = cci_read(ov5693->regmap, OV5693_EXPOSURE_CTRL_REG, &exposure,\n\t\t       NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*value = exposure >> 4;\n\n\treturn 0;\n}\n\nstatic int ov5693_exposure_configure(struct ov5693_device *ov5693,\n\t\t\t\t     u32 exposure)\n{\n\tint ret = 0;\n\n\texposure = (exposure << 4) & OV5693_EXPOSURE_CTRL_MASK;\n\n\tcci_write(ov5693->regmap, OV5693_EXPOSURE_CTRL_REG, exposure, &ret);\n\n\treturn ret;\n}\n\nstatic int ov5693_get_gain(struct ov5693_device *ov5693, u32 *gain)\n{\n\tu64 value;\n\tint ret;\n\n\tret = cci_read(ov5693->regmap, OV5693_GAIN_CTRL_REG, &value, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*gain = value >> 4;\n\n\treturn ret;\n}\n\nstatic int ov5693_digital_gain_configure(struct ov5693_device *ov5693,\n\t\t\t\t\t u32 gain)\n{\n\tint ret = 0;\n\n\tgain &= OV5693_MWB_GAIN_MASK;\n\n\tcci_write(ov5693->regmap, OV5693_MWB_RED_GAIN_REG, gain, &ret);\n\tcci_write(ov5693->regmap, OV5693_MWB_GREEN_GAIN_REG, gain, &ret);\n\tcci_write(ov5693->regmap, OV5693_MWB_BLUE_GAIN_REG, gain, &ret);\n\n\treturn ret;\n}\n\nstatic int ov5693_analog_gain_configure(struct ov5693_device *ov5693, u32 gain)\n{\n\tint ret = 0;\n\n\tgain = (gain << 4) & OV5693_GAIN_CTRL_MASK;\n\n\tcci_write(ov5693->regmap, OV5693_GAIN_CTRL_REG, gain, &ret);\n\n\treturn ret;\n}\n\nstatic int ov5693_vts_configure(struct ov5693_device *ov5693, u32 vblank)\n{\n\tu16 vts = ov5693->mode.format.height + vblank;\n\tint ret = 0;\n\n\tcci_write(ov5693->regmap, OV5693_TIMING_VTS_REG, vts, &ret);\n\n\treturn ret;\n}\n\nstatic int ov5693_test_pattern_configure(struct ov5693_device *ov5693, u32 idx)\n{\n\tint ret = 0;\n\n\tcci_write(ov5693->regmap, OV5693_TEST_PATTERN_REG,\n\t\t  ov5693_test_pattern_bits[idx], &ret);\n\n\treturn ret;\n}\n\nstatic int ov5693_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ov5693_device *ov5693 =\n\t    container_of(ctrl->handler, struct ov5693_device, ctrls.handler);\n\tint ret = 0;\n\n\t \n\tif (ctrl->id == V4L2_CID_VBLANK) {\n\t\tint exposure_max;\n\n\t\texposure_max = ov5693->mode.format.height + ctrl->val -\n\t\t\t       OV5693_INTEGRATION_TIME_MARGIN;\n\t\t__v4l2_ctrl_modify_range(ov5693->ctrls.exposure,\n\t\t\t\t\t ov5693->ctrls.exposure->minimum,\n\t\t\t\t\t exposure_max,\n\t\t\t\t\t ov5693->ctrls.exposure->step,\n\t\t\t\t\t min(ov5693->ctrls.exposure->val,\n\t\t\t\t\t     exposure_max));\n\t}\n\n\t \n\tif (!pm_runtime_get_if_in_use(ov5693->dev))\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE:\n\t\tret = ov5693_exposure_configure(ov5693, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_ANALOGUE_GAIN:\n\t\tret = ov5693_analog_gain_configure(ov5693, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_DIGITAL_GAIN:\n\t\tret = ov5693_digital_gain_configure(ov5693, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tret = ov5693_flip_horz_configure(ov5693, !!ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tret = ov5693_flip_vert_configure(ov5693, !!ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_VBLANK:\n\t\tret = ov5693_vts_configure(ov5693, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tret = ov5693_test_pattern_configure(ov5693, ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tpm_runtime_put(ov5693->dev);\n\n\treturn ret;\n}\n\nstatic int ov5693_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ov5693_device *ov5693 = container_of(ctrl->handler,\n\t\t\t\t\t\t    struct ov5693_device,\n\t\t\t\t\t\t    ctrls.handler);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE_ABSOLUTE:\n\t\treturn ov5693_get_exposure(ov5693, &ctrl->val);\n\tcase V4L2_CID_AUTOGAIN:\n\t\treturn ov5693_get_gain(ov5693, &ctrl->val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct v4l2_ctrl_ops ov5693_ctrl_ops = {\n\t.s_ctrl = ov5693_s_ctrl,\n\t.g_volatile_ctrl = ov5693_g_volatile_ctrl\n};\n\n \n\nstatic int ov5693_mode_configure(struct ov5693_device *ov5693)\n{\n\tconst struct ov5693_mode *mode = &ov5693->mode;\n\tint ret = 0;\n\n\t \n\tcci_write(ov5693->regmap, OV5693_CROP_START_X_REG, mode->crop.left,\n\t\t  &ret);\n\n\t \n\tcci_write(ov5693->regmap, OV5693_OFFSET_START_X_REG, 0, &ret);\n\n\t \n\tcci_write(ov5693->regmap, OV5693_OUTPUT_SIZE_X_REG, mode->format.width,\n\t\t  &ret);\n\n\t \n\tcci_write(ov5693->regmap, OV5693_CROP_END_X_REG,\n\t\t  mode->crop.left + mode->crop.width, &ret);\n\n\t \n\tcci_write(ov5693->regmap, OV5693_TIMING_HTS_REG, OV5693_FIXED_PPL,\n\t\t  &ret);\n\n\t \n\tcci_write(ov5693->regmap, OV5693_CROP_START_Y_REG, mode->crop.top,\n\t\t  &ret);\n\n\t \n\tcci_write(ov5693->regmap, OV5693_OFFSET_START_Y_REG, 0, &ret);\n\n\t \n\tcci_write(ov5693->regmap, OV5693_OUTPUT_SIZE_Y_REG, mode->format.height,\n\t\t  &ret);\n\n\t \n\tcci_write(ov5693->regmap, OV5693_CROP_END_Y_REG,\n\t\t  mode->crop.top + mode->crop.height, &ret);\n\n\t \n\tcci_write(ov5693->regmap, OV5693_SUB_INC_X_REG,\n\t\t  ((mode->inc_x_odd << 4) & 0xf0) | 0x01, &ret);\n\t \n\tcci_write(ov5693->regmap, OV5693_SUB_INC_Y_REG,\n\t\t  ((mode->inc_y_odd << 4) & 0xf0) | 0x01, &ret);\n\n\t \n\tcci_update_bits(ov5693->regmap, OV5693_FORMAT1_REG,\n\t\t\tOV5693_FORMAT1_VBIN_EN,\n\t\t\tmode->binning_y ? OV5693_FORMAT1_VBIN_EN : 0, &ret);\n\n\tcci_update_bits(ov5693->regmap, OV5693_FORMAT2_REG,\n\t\t\tOV5693_FORMAT2_HBIN_EN,\n\t\t\tmode->binning_x ? OV5693_FORMAT2_HBIN_EN : 0, &ret);\n\n\treturn ret;\n}\n\nstatic int ov5693_enable_streaming(struct ov5693_device *ov5693, bool enable)\n{\n\tint ret = 0;\n\n\tcci_write(ov5693->regmap, OV5693_SW_STREAM_REG,\n\t\t  enable ? OV5693_START_STREAMING : OV5693_STOP_STREAMING,\n\t\t  &ret);\n\n\treturn ret;\n}\n\nstatic int ov5693_sw_reset(struct ov5693_device *ov5693)\n{\n\tint ret = 0;\n\n\tcci_write(ov5693->regmap, OV5693_SW_RESET_REG, OV5693_SW_RESET, &ret);\n\n\treturn ret;\n}\n\nstatic int ov5693_sensor_init(struct ov5693_device *ov5693)\n{\n\tint ret;\n\n\tret = ov5693_sw_reset(ov5693);\n\tif (ret)\n\t\treturn dev_err_probe(ov5693->dev, ret,\n\t\t\t\t     \"software reset error\\n\");\n\n\tret = cci_multi_reg_write(ov5693->regmap, ov5693_global_regs,\n\t\t\t\t  ARRAY_SIZE(ov5693_global_regs), NULL);\n\tif (ret)\n\t\treturn dev_err_probe(ov5693->dev, ret,\n\t\t\t\t     \"global settings error\\n\");\n\n\tret = ov5693_mode_configure(ov5693);\n\tif (ret)\n\t\treturn dev_err_probe(ov5693->dev, ret,\n\t\t\t\t     \"mode configure error\\n\");\n\n\tret = ov5693_enable_streaming(ov5693, false);\n\tif (ret)\n\t\tdev_err(ov5693->dev, \"stop streaming error\\n\");\n\n\treturn ret;\n}\n\nstatic void ov5693_sensor_powerdown(struct ov5693_device *ov5693)\n{\n\tgpiod_set_value_cansleep(ov5693->privacy_led, 0);\n\tgpiod_set_value_cansleep(ov5693->reset, 1);\n\tgpiod_set_value_cansleep(ov5693->powerdown, 1);\n\n\tregulator_bulk_disable(OV5693_NUM_SUPPLIES, ov5693->supplies);\n\n\tclk_disable_unprepare(ov5693->xvclk);\n}\n\nstatic int ov5693_sensor_powerup(struct ov5693_device *ov5693)\n{\n\tint ret;\n\n\tgpiod_set_value_cansleep(ov5693->reset, 1);\n\tgpiod_set_value_cansleep(ov5693->powerdown, 1);\n\n\tret = clk_prepare_enable(ov5693->xvclk);\n\tif (ret) {\n\t\tdev_err(ov5693->dev, \"Failed to enable clk\\n\");\n\t\tgoto fail_power;\n\t}\n\n\tret = regulator_bulk_enable(OV5693_NUM_SUPPLIES, ov5693->supplies);\n\tif (ret) {\n\t\tdev_err(ov5693->dev, \"Failed to enable regulators\\n\");\n\t\tgoto fail_power;\n\t}\n\n\tgpiod_set_value_cansleep(ov5693->powerdown, 0);\n\tgpiod_set_value_cansleep(ov5693->reset, 0);\n\tgpiod_set_value_cansleep(ov5693->privacy_led, 1);\n\n\tusleep_range(5000, 7500);\n\n\treturn 0;\n\nfail_power:\n\tov5693_sensor_powerdown(ov5693);\n\treturn ret;\n}\n\nstatic int __maybe_unused ov5693_sensor_suspend(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct ov5693_device *ov5693 = to_ov5693_sensor(sd);\n\n\tov5693_sensor_powerdown(ov5693);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ov5693_sensor_resume(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct ov5693_device *ov5693 = to_ov5693_sensor(sd);\n\tint ret;\n\n\tmutex_lock(&ov5693->lock);\n\n\tret = ov5693_sensor_powerup(ov5693);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = ov5693_sensor_init(ov5693);\n\tif (ret) {\n\t\tdev_err(dev, \"ov5693 sensor init failure\\n\");\n\t\tgoto err_power;\n\t}\n\n\tgoto out_unlock;\n\nerr_power:\n\tov5693_sensor_powerdown(ov5693);\nout_unlock:\n\tmutex_unlock(&ov5693->lock);\n\treturn ret;\n}\n\nstatic int ov5693_detect(struct ov5693_device *ov5693)\n{\n\tint ret;\n\tu64 id;\n\n\tret = cci_read(ov5693->regmap, OV5693_REG_CHIP_ID, &id, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (id != OV5693_CHIP_ID)\n\t\treturn dev_err_probe(ov5693->dev, -ENODEV,\n\t\t\t\t     \"sensor ID mismatch. Got 0x%04llx\\n\", id);\n\n\treturn 0;\n}\n\n \n\nstatic unsigned int __ov5693_calc_vts(u32 height)\n{\n\t \n\n\tunsigned int tgt_fps;\n\n\ttgt_fps = rounddown(OV5693_PIXEL_RATE / OV5693_FIXED_PPL / height, 30);\n\n\treturn ALIGN_DOWN(OV5693_PIXEL_RATE / OV5693_FIXED_PPL / tgt_fps, 2);\n}\n\nstatic struct v4l2_mbus_framefmt *\n__ov5693_get_pad_format(struct ov5693_device *ov5693,\n\t\t\tstruct v4l2_subdev_state *state,\n\t\t\tunsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\treturn v4l2_subdev_get_try_format(&ov5693->sd, state, pad);\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &ov5693->mode.format;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic struct v4l2_rect *\n__ov5693_get_pad_crop(struct ov5693_device *ov5693,\n\t\t      struct v4l2_subdev_state *state,\n\t\t      unsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\treturn v4l2_subdev_get_try_crop(&ov5693->sd, state, pad);\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &ov5693->mode.crop;\n\t}\n\n\treturn NULL;\n}\n\nstatic int ov5693_get_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct ov5693_device *ov5693 = to_ov5693_sensor(sd);\n\n\tformat->format = ov5693->mode.format;\n\n\treturn 0;\n}\n\nstatic int ov5693_set_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct ov5693_device *ov5693 = to_ov5693_sensor(sd);\n\tconst struct v4l2_rect *crop;\n\tstruct v4l2_mbus_framefmt *fmt;\n\tunsigned int hratio, vratio;\n\tunsigned int width, height;\n\tunsigned int hblank;\n\tint exposure_max;\n\n\tcrop = __ov5693_get_pad_crop(ov5693, state, format->pad, format->which);\n\n\t \n\twidth = clamp_t(unsigned int, ALIGN(format->format.width, 2),\n\t\t\tOV5693_MIN_CROP_WIDTH, crop->width);\n\theight = clamp_t(unsigned int, ALIGN(format->format.height, 2),\n\t\t\t OV5693_MIN_CROP_HEIGHT, crop->height);\n\n\t \n\thratio = clamp_t(unsigned int,\n\t\t\t DIV_ROUND_CLOSEST(crop->width, width), 1, 2);\n\tvratio = clamp_t(unsigned int,\n\t\t\t DIV_ROUND_CLOSEST(crop->height, height), 1, 2);\n\n\tfmt = __ov5693_get_pad_format(ov5693, state, format->pad,\n\t\t\t\t      format->which);\n\n\tfmt->width = crop->width / hratio;\n\tfmt->height = crop->height / vratio;\n\tfmt->code = MEDIA_BUS_FMT_SBGGR10_1X10;\n\n\tformat->format = *fmt;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn 0;\n\n\tmutex_lock(&ov5693->lock);\n\n\tov5693->mode.binning_x = hratio > 1;\n\tov5693->mode.inc_x_odd = hratio > 1 ? 3 : 1;\n\tov5693->mode.binning_y = vratio > 1;\n\tov5693->mode.inc_y_odd = vratio > 1 ? 3 : 1;\n\n\tov5693->mode.vts = __ov5693_calc_vts(fmt->height);\n\n\t__v4l2_ctrl_modify_range(ov5693->ctrls.vblank,\n\t\t\t\t OV5693_TIMING_MIN_VTS,\n\t\t\t\t OV5693_TIMING_MAX_VTS - fmt->height,\n\t\t\t\t 1, ov5693->mode.vts - fmt->height);\n\t__v4l2_ctrl_s_ctrl(ov5693->ctrls.vblank,\n\t\t\t   ov5693->mode.vts - fmt->height);\n\n\thblank = OV5693_FIXED_PPL - fmt->width;\n\t__v4l2_ctrl_modify_range(ov5693->ctrls.hblank, hblank, hblank, 1,\n\t\t\t\t hblank);\n\n\texposure_max = ov5693->mode.vts - OV5693_INTEGRATION_TIME_MARGIN;\n\t__v4l2_ctrl_modify_range(ov5693->ctrls.exposure,\n\t\t\t\t ov5693->ctrls.exposure->minimum, exposure_max,\n\t\t\t\t ov5693->ctrls.exposure->step,\n\t\t\t\t min(ov5693->ctrls.exposure->val,\n\t\t\t\t     exposure_max));\n\n\tmutex_unlock(&ov5693->lock);\n\treturn 0;\n}\n\nstatic int ov5693_get_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct ov5693_device *ov5693 = to_ov5693_sensor(sd);\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tmutex_lock(&ov5693->lock);\n\t\tsel->r = *__ov5693_get_pad_crop(ov5693, state, sel->pad,\n\t\t\t\t\t\tsel->which);\n\t\tmutex_unlock(&ov5693->lock);\n\t\tbreak;\n\tcase V4L2_SEL_TGT_NATIVE_SIZE:\n\t\tsel->r.top = 0;\n\t\tsel->r.left = 0;\n\t\tsel->r.width = OV5693_NATIVE_WIDTH;\n\t\tsel->r.height = OV5693_NATIVE_HEIGHT;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tsel->r.top = OV5693_ACTIVE_START_TOP;\n\t\tsel->r.left = OV5693_ACTIVE_START_LEFT;\n\t\tsel->r.width = OV5693_ACTIVE_WIDTH;\n\t\tsel->r.height = OV5693_ACTIVE_HEIGHT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov5693_set_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct ov5693_device *ov5693 = to_ov5693_sensor(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct v4l2_rect *__crop;\n\tstruct v4l2_rect rect;\n\n\tif (sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\t \n\trect.left = clamp(ALIGN(sel->r.left, 2), OV5693_NATIVE_START_LEFT,\n\t\t\t  OV5693_NATIVE_WIDTH);\n\trect.top = clamp(ALIGN(sel->r.top, 2), OV5693_NATIVE_START_TOP,\n\t\t\t OV5693_NATIVE_HEIGHT);\n\trect.width = clamp_t(unsigned int, ALIGN(sel->r.width, 2),\n\t\t\t     OV5693_MIN_CROP_WIDTH, OV5693_NATIVE_WIDTH);\n\trect.height = clamp_t(unsigned int, ALIGN(sel->r.height, 2),\n\t\t\t      OV5693_MIN_CROP_HEIGHT, OV5693_NATIVE_HEIGHT);\n\n\t \n\trect.width = min_t(unsigned int, rect.width,\n\t\t\t   OV5693_NATIVE_WIDTH - rect.left);\n\trect.height = min_t(unsigned int, rect.height,\n\t\t\t    OV5693_NATIVE_HEIGHT - rect.top);\n\n\t__crop = __ov5693_get_pad_crop(ov5693, state, sel->pad, sel->which);\n\n\tif (rect.width != __crop->width || rect.height != __crop->height) {\n\t\t \n\t\tformat = __ov5693_get_pad_format(ov5693, state, sel->pad,\n\t\t\t\t\t\t sel->which);\n\t\tformat->width = rect.width;\n\t\tformat->height = rect.height;\n\t}\n\n\t*__crop = rect;\n\tsel->r = rect;\n\n\treturn 0;\n}\n\nstatic int ov5693_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct ov5693_device *ov5693 = to_ov5693_sensor(sd);\n\tint ret;\n\n\tif (enable) {\n\t\tret = pm_runtime_get_sync(ov5693->dev);\n\t\tif (ret < 0)\n\t\t\tgoto err_power_down;\n\n\t\tmutex_lock(&ov5693->lock);\n\t\tret = __v4l2_ctrl_handler_setup(&ov5693->ctrls.handler);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&ov5693->lock);\n\t\t\tgoto err_power_down;\n\t\t}\n\n\t\tret = ov5693_enable_streaming(ov5693, true);\n\t\tmutex_unlock(&ov5693->lock);\n\t} else {\n\t\tmutex_lock(&ov5693->lock);\n\t\tret = ov5693_enable_streaming(ov5693, false);\n\t\tmutex_unlock(&ov5693->lock);\n\t}\n\tif (ret)\n\t\tgoto err_power_down;\n\n\tov5693->streaming = !!enable;\n\n\tif (!enable)\n\t\tpm_runtime_put(ov5693->dev);\n\n\treturn 0;\nerr_power_down:\n\tpm_runtime_put_noidle(ov5693->dev);\n\treturn ret;\n}\n\nstatic int ov5693_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *interval)\n{\n\tstruct ov5693_device *ov5693 = to_ov5693_sensor(sd);\n\tunsigned int framesize = OV5693_FIXED_PPL * (ov5693->mode.format.height +\n\t\t\t\t ov5693->ctrls.vblank->val);\n\tunsigned int fps = DIV_ROUND_CLOSEST(OV5693_PIXEL_RATE, framesize);\n\n\tinterval->interval.numerator = 1;\n\tinterval->interval.denominator = fps;\n\n\treturn 0;\n}\n\nstatic int ov5693_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\t \n\tif (code->index > 0)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_SBGGR10_1X10;\n\treturn 0;\n}\n\nstatic int ov5693_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct ov5693_device *ov5693 = to_ov5693_sensor(sd);\n\tstruct v4l2_rect *__crop;\n\n\tif (fse->index > 1 || fse->code != MEDIA_BUS_FMT_SBGGR10_1X10)\n\t\treturn -EINVAL;\n\n\t__crop = __ov5693_get_pad_crop(ov5693, state, fse->pad, fse->which);\n\tif (!__crop)\n\t\treturn -EINVAL;\n\n\tfse->min_width = __crop->width / (fse->index + 1);\n\tfse->min_height = __crop->height / (fse->index + 1);\n\tfse->max_width = fse->min_width;\n\tfse->max_height = fse->min_height;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops ov5693_video_ops = {\n\t.s_stream = ov5693_s_stream,\n\t.g_frame_interval = ov5693_g_frame_interval,\n};\n\nstatic const struct v4l2_subdev_pad_ops ov5693_pad_ops = {\n\t.enum_mbus_code = ov5693_enum_mbus_code,\n\t.enum_frame_size = ov5693_enum_frame_size,\n\t.get_fmt = ov5693_get_fmt,\n\t.set_fmt = ov5693_set_fmt,\n\t.get_selection = ov5693_get_selection,\n\t.set_selection = ov5693_set_selection,\n};\n\nstatic const struct v4l2_subdev_ops ov5693_ops = {\n\t.video = &ov5693_video_ops,\n\t.pad = &ov5693_pad_ops,\n};\n\n \n\nstatic int ov5693_init_controls(struct ov5693_device *ov5693)\n{\n\tconst struct v4l2_ctrl_ops *ops = &ov5693_ctrl_ops;\n\tstruct ov5693_v4l2_ctrls *ctrls = &ov5693->ctrls;\n\tstruct v4l2_fwnode_device_properties props;\n\tint vblank_max, vblank_def;\n\tint exposure_max;\n\tint hblank;\n\tint ret;\n\n\tret = v4l2_ctrl_handler_init(&ctrls->handler, 12);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tctrls->link_freq = v4l2_ctrl_new_int_menu(&ctrls->handler,\n\t\t\t\t\t\t  NULL, V4L2_CID_LINK_FREQ,\n\t\t\t\t\t\t  0, 0, link_freq_menu_items);\n\tif (ctrls->link_freq)\n\t\tctrls->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\t \n\tctrls->pixel_rate = v4l2_ctrl_new_std(&ctrls->handler, NULL,\n\t\t\t\t\t      V4L2_CID_PIXEL_RATE, 0,\n\t\t\t\t\t      OV5693_PIXEL_RATE, 1,\n\t\t\t\t\t      OV5693_PIXEL_RATE);\n\n\t \n\texposure_max = ov5693->mode.vts - OV5693_INTEGRATION_TIME_MARGIN;\n\tctrls->exposure = v4l2_ctrl_new_std(&ctrls->handler, ops,\n\t\t\t\t\t    V4L2_CID_EXPOSURE,\n\t\t\t\t\t    OV5693_EXPOSURE_MIN, exposure_max,\n\t\t\t\t\t    OV5693_EXPOSURE_STEP, exposure_max);\n\n\t \n\tctrls->analogue_gain = v4l2_ctrl_new_std(&ctrls->handler,\n\t\t\t\t\t\t ops, V4L2_CID_ANALOGUE_GAIN,\n\t\t\t\t\t\t OV5693_GAIN_MIN,\n\t\t\t\t\t\t OV5693_GAIN_MAX,\n\t\t\t\t\t\t OV5693_GAIN_STEP,\n\t\t\t\t\t\t OV5693_GAIN_DEF);\n\n\tctrls->digital_gain = v4l2_ctrl_new_std(&ctrls->handler, ops,\n\t\t\t\t\t\tV4L2_CID_DIGITAL_GAIN,\n\t\t\t\t\t\tOV5693_DIGITAL_GAIN_MIN,\n\t\t\t\t\t\tOV5693_DIGITAL_GAIN_MAX,\n\t\t\t\t\t\tOV5693_DIGITAL_GAIN_STEP,\n\t\t\t\t\t\tOV5693_DIGITAL_GAIN_DEF);\n\n\t \n\tctrls->hflip = v4l2_ctrl_new_std(&ctrls->handler, ops,\n\t\t\t\t\t V4L2_CID_HFLIP, 0, 1, 1, 0);\n\n\tctrls->vflip = v4l2_ctrl_new_std(&ctrls->handler, ops,\n\t\t\t\t\t V4L2_CID_VFLIP, 0, 1, 1, 0);\n\n\thblank = OV5693_FIXED_PPL - ov5693->mode.format.width;\n\tctrls->hblank = v4l2_ctrl_new_std(&ctrls->handler, ops,\n\t\t\t\t\t  V4L2_CID_HBLANK, hblank,\n\t\t\t\t\t  hblank, 1, hblank);\n\n\tif (ctrls->hblank)\n\t\tctrls->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tvblank_max = OV5693_TIMING_MAX_VTS - ov5693->mode.format.height;\n\tvblank_def = ov5693->mode.vts - ov5693->mode.format.height;\n\tctrls->vblank = v4l2_ctrl_new_std(&ctrls->handler, ops,\n\t\t\t\t\t  V4L2_CID_VBLANK,\n\t\t\t\t\t  OV5693_TIMING_MIN_VTS,\n\t\t\t\t\t  vblank_max, 1, vblank_def);\n\n\tctrls->test_pattern = v4l2_ctrl_new_std_menu_items(\n\t\t\t\t\t&ctrls->handler, ops,\n\t\t\t\t\tV4L2_CID_TEST_PATTERN,\n\t\t\t\t\tARRAY_SIZE(ov5693_test_pattern_menu) - 1,\n\t\t\t\t\t0, 0, ov5693_test_pattern_menu);\n\n\tif (ctrls->handler.error) {\n\t\tdev_err(ov5693->dev, \"Error initialising v4l2 ctrls\\n\");\n\t\tret = ctrls->handler.error;\n\t\tgoto err_free_handler;\n\t}\n\n\t \n\tret = v4l2_fwnode_device_parse(ov5693->dev, &props);\n\tif (ret)\n\t\tgoto err_free_handler;\n\n\tret = v4l2_ctrl_new_fwnode_properties(&ctrls->handler, ops,\n\t\t\t\t\t      &props);\n\tif (ret)\n\t\tgoto err_free_handler;\n\n\t \n\tctrls->handler.lock = &ov5693->lock;\n\tov5693->sd.ctrl_handler = &ctrls->handler;\n\n\treturn 0;\n\nerr_free_handler:\n\tv4l2_ctrl_handler_free(&ctrls->handler);\n\treturn ret;\n}\n\nstatic int ov5693_configure_gpios(struct ov5693_device *ov5693)\n{\n\tov5693->reset = devm_gpiod_get_optional(ov5693->dev, \"reset\",\n\t\t\t\t\t\tGPIOD_OUT_HIGH);\n\tif (IS_ERR(ov5693->reset)) {\n\t\tdev_err(ov5693->dev, \"Error fetching reset GPIO\\n\");\n\t\treturn PTR_ERR(ov5693->reset);\n\t}\n\n\tov5693->powerdown = devm_gpiod_get_optional(ov5693->dev, \"powerdown\",\n\t\t\t\t\t\t    GPIOD_OUT_HIGH);\n\tif (IS_ERR(ov5693->powerdown)) {\n\t\tdev_err(ov5693->dev, \"Error fetching powerdown GPIO\\n\");\n\t\treturn PTR_ERR(ov5693->powerdown);\n\t}\n\n\tov5693->privacy_led = devm_gpiod_get_optional(ov5693->dev, \"privacy-led\",\n\t\t\t\t\t\t      GPIOD_OUT_LOW);\n\tif (IS_ERR(ov5693->privacy_led)) {\n\t\tdev_err(ov5693->dev, \"Error fetching privacy-led GPIO\\n\");\n\t\treturn PTR_ERR(ov5693->privacy_led);\n\t}\n\n\treturn 0;\n}\n\nstatic int ov5693_get_regulators(struct ov5693_device *ov5693)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < OV5693_NUM_SUPPLIES; i++)\n\t\tov5693->supplies[i].supply = ov5693_supply_names[i];\n\n\treturn devm_regulator_bulk_get(ov5693->dev, OV5693_NUM_SUPPLIES,\n\t\t\t\t       ov5693->supplies);\n}\n\nstatic int ov5693_check_hwcfg(struct ov5693_device *ov5693)\n{\n\tstruct fwnode_handle *fwnode = dev_fwnode(ov5693->dev);\n\tstruct v4l2_fwnode_endpoint bus_cfg = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY,\n\t};\n\tstruct fwnode_handle *endpoint;\n\tunsigned int i;\n\tint ret;\n\n\tendpoint = fwnode_graph_get_next_endpoint(fwnode, NULL);\n\tif (!endpoint)\n\t\treturn -EPROBE_DEFER;  \n\n\tret = v4l2_fwnode_endpoint_alloc_parse(endpoint, &bus_cfg);\n\tfwnode_handle_put(endpoint);\n\tif (ret)\n\t\treturn ret;\n\n\tif (bus_cfg.bus.mipi_csi2.num_data_lanes != 2) {\n\t\tdev_err(ov5693->dev, \"only a 2-lane CSI2 config is supported\");\n\t\tret = -EINVAL;\n\t\tgoto out_free_bus_cfg;\n\t}\n\n\tif (!bus_cfg.nr_of_link_frequencies) {\n\t\tdev_err(ov5693->dev, \"no link frequencies defined\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_free_bus_cfg;\n\t}\n\n\tfor (i = 0; i < bus_cfg.nr_of_link_frequencies; i++)\n\t\tif (bus_cfg.link_frequencies[i] == OV5693_LINK_FREQ_419_2MHZ)\n\t\t\tbreak;\n\n\tif (i == bus_cfg.nr_of_link_frequencies) {\n\t\tdev_err(ov5693->dev, \"supported link freq %ull not found\\n\",\n\t\t\tOV5693_LINK_FREQ_419_2MHZ);\n\t\tret = -EINVAL;\n\t\tgoto out_free_bus_cfg;\n\t}\n\nout_free_bus_cfg:\n\tv4l2_fwnode_endpoint_free(&bus_cfg);\n\n\treturn ret;\n}\n\nstatic int ov5693_probe(struct i2c_client *client)\n{\n\tstruct ov5693_device *ov5693;\n\tu32 xvclk_rate;\n\tint ret = 0;\n\n\tov5693 = devm_kzalloc(&client->dev, sizeof(*ov5693), GFP_KERNEL);\n\tif (!ov5693)\n\t\treturn -ENOMEM;\n\n\tov5693->dev = &client->dev;\n\n\tov5693->regmap = devm_cci_regmap_init_i2c(client, 16);\n\tif (IS_ERR(ov5693->regmap))\n\t\treturn PTR_ERR(ov5693->regmap);\n\n\tret = ov5693_check_hwcfg(ov5693);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&ov5693->lock);\n\n\tv4l2_i2c_subdev_init(&ov5693->sd, client, &ov5693_ops);\n\n\tov5693->xvclk = devm_clk_get_optional(&client->dev, \"xvclk\");\n\tif (IS_ERR(ov5693->xvclk))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(ov5693->xvclk),\n\t\t\t\t     \"failed to get xvclk: %ld\\n\",\n\t\t\t\t     PTR_ERR(ov5693->xvclk));\n\n\tif (ov5693->xvclk) {\n\t\txvclk_rate = clk_get_rate(ov5693->xvclk);\n\t} else {\n\t\tret = fwnode_property_read_u32(dev_fwnode(&client->dev),\n\t\t\t\t     \"clock-frequency\",\n\t\t\t\t     &xvclk_rate);\n\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"can't get clock frequency\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (xvclk_rate != OV5693_XVCLK_FREQ)\n\t\tdev_warn(&client->dev, \"Found clk freq %u, expected %u\\n\",\n\t\t\t xvclk_rate, OV5693_XVCLK_FREQ);\n\n\tret = ov5693_configure_gpios(ov5693);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5693_get_regulators(ov5693);\n\tif (ret)\n\t\treturn dev_err_probe(&client->dev, ret,\n\t\t\t\t     \"Error fetching regulators\\n\");\n\n\tov5693->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tov5693->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tov5693->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\n\tov5693->mode.crop = ov5693_default_crop;\n\tov5693->mode.format = ov5693_default_fmt;\n\tov5693->mode.vts = __ov5693_calc_vts(ov5693->mode.format.height);\n\n\tret = ov5693_init_controls(ov5693);\n\tif (ret)\n\t\treturn ret;\n\n\tret = media_entity_pads_init(&ov5693->sd.entity, 1, &ov5693->pad);\n\tif (ret)\n\t\tgoto err_ctrl_handler_free;\n\n\t \n\n\tret = ov5693_sensor_powerup(ov5693);\n\tif (ret)\n\t\tgoto err_media_entity_cleanup;\n\n\tret = ov5693_detect(ov5693);\n\tif (ret)\n\t\tgoto err_powerdown;\n\n\tpm_runtime_set_active(&client->dev);\n\tpm_runtime_get_noresume(&client->dev);\n\tpm_runtime_enable(&client->dev);\n\n\tret = v4l2_async_register_subdev_sensor(&ov5693->sd);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to register V4L2 subdev: %d\",\n\t\t\tret);\n\t\tgoto err_pm_runtime;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(&client->dev, 1000);\n\tpm_runtime_use_autosuspend(&client->dev);\n\tpm_runtime_put_autosuspend(&client->dev);\n\n\treturn ret;\n\nerr_pm_runtime:\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_put_noidle(&client->dev);\nerr_powerdown:\n\tov5693_sensor_powerdown(ov5693);\nerr_media_entity_cleanup:\n\tmedia_entity_cleanup(&ov5693->sd.entity);\nerr_ctrl_handler_free:\n\tv4l2_ctrl_handler_free(&ov5693->ctrls.handler);\n\n\treturn ret;\n}\n\nstatic void ov5693_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov5693_device *ov5693 = to_ov5693_sensor(sd);\n\n\tv4l2_async_unregister_subdev(sd);\n\tmedia_entity_cleanup(&ov5693->sd.entity);\n\tv4l2_ctrl_handler_free(&ov5693->ctrls.handler);\n\tmutex_destroy(&ov5693->lock);\n\n\t \n\tpm_runtime_disable(&client->dev);\n\tif (!pm_runtime_status_suspended(&client->dev))\n\t\tov5693_sensor_powerdown(ov5693);\n\tpm_runtime_set_suspended(&client->dev);\n}\n\nstatic const struct dev_pm_ops ov5693_pm_ops = {\n\tSET_RUNTIME_PM_OPS(ov5693_sensor_suspend, ov5693_sensor_resume, NULL)\n};\n\nstatic const struct acpi_device_id ov5693_acpi_match[] = {\n\t{\"INT33BE\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, ov5693_acpi_match);\n\nstatic const struct of_device_id ov5693_of_match[] = {\n\t{ .compatible = \"ovti,ov5693\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ov5693_of_match);\n\nstatic struct i2c_driver ov5693_driver = {\n\t.driver = {\n\t\t.name = \"ov5693\",\n\t\t.acpi_match_table = ov5693_acpi_match,\n\t\t.of_match_table = ov5693_of_match,\n\t\t.pm = &ov5693_pm_ops,\n\t},\n\t.probe = ov5693_probe,\n\t.remove = ov5693_remove,\n};\nmodule_i2c_driver(ov5693_driver);\n\nMODULE_DESCRIPTION(\"A low-level driver for OmniVision 5693 sensors\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}