{
  "module_name": "adp1653.c",
  "hash_id": "36cb4e851332f2cd1298963180104af71a6be65514a9ee655a3eddaf95dec107",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/adp1653.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/gpio/consumer.h>\n#include <media/i2c/adp1653.h>\n#include <media/v4l2-device.h>\n\n#define TIMEOUT_MAX\t\t820000\n#define TIMEOUT_STEP\t\t54600\n#define TIMEOUT_MIN\t\t(TIMEOUT_MAX - ADP1653_REG_CONFIG_TMR_SET_MAX \\\n\t\t\t\t * TIMEOUT_STEP)\n#define TIMEOUT_US_TO_CODE(t)\t((TIMEOUT_MAX + (TIMEOUT_STEP / 2) - (t)) \\\n\t\t\t\t / TIMEOUT_STEP)\n#define TIMEOUT_CODE_TO_US(c)\t(TIMEOUT_MAX - (c) * TIMEOUT_STEP)\n\n \nstatic int adp1653_update_hw(struct adp1653_flash *flash)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&flash->subdev);\n\tu8 out_sel;\n\tu8 config = 0;\n\tint rval;\n\n\tout_sel = ADP1653_INDICATOR_INTENSITY_uA_TO_REG(\n\t\tflash->indicator_intensity->val)\n\t\t<< ADP1653_REG_OUT_SEL_ILED_SHIFT;\n\n\tswitch (flash->led_mode->val) {\n\tcase V4L2_FLASH_LED_MODE_NONE:\n\t\tbreak;\n\tcase V4L2_FLASH_LED_MODE_FLASH:\n\t\t \n\t\tconfig = ADP1653_REG_CONFIG_TMR_CFG;\n\t\tconfig |= TIMEOUT_US_TO_CODE(flash->flash_timeout->val)\n\t\t\t  << ADP1653_REG_CONFIG_TMR_SET_SHIFT;\n\t\tbreak;\n\tcase V4L2_FLASH_LED_MODE_TORCH:\n\t\t \n\t\tout_sel |= ADP1653_FLASH_INTENSITY_mA_TO_REG(\n\t\t\tflash->torch_intensity->val)\n\t\t\t<< ADP1653_REG_OUT_SEL_HPLED_SHIFT;\n\t\tbreak;\n\t}\n\n\trval = i2c_smbus_write_byte_data(client, ADP1653_REG_OUT_SEL, out_sel);\n\tif (rval < 0)\n\t\treturn rval;\n\n\trval = i2c_smbus_write_byte_data(client, ADP1653_REG_CONFIG, config);\n\tif (rval < 0)\n\t\treturn rval;\n\n\treturn 0;\n}\n\nstatic int adp1653_get_fault(struct adp1653_flash *flash)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&flash->subdev);\n\tint fault;\n\tint rval;\n\n\tfault = i2c_smbus_read_byte_data(client, ADP1653_REG_FAULT);\n\tif (fault < 0)\n\t\treturn fault;\n\n\tflash->fault |= fault;\n\n\tif (!flash->fault)\n\t\treturn 0;\n\n\t \n\trval = i2c_smbus_write_byte_data(client, ADP1653_REG_OUT_SEL, 0);\n\tif (rval < 0)\n\t\treturn rval;\n\n\tflash->led_mode->val = V4L2_FLASH_LED_MODE_NONE;\n\n\trval = adp1653_update_hw(flash);\n\tif (rval)\n\t\treturn rval;\n\n\treturn flash->fault;\n}\n\nstatic int adp1653_strobe(struct adp1653_flash *flash, int enable)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&flash->subdev);\n\tu8 out_sel = ADP1653_INDICATOR_INTENSITY_uA_TO_REG(\n\t\tflash->indicator_intensity->val)\n\t\t<< ADP1653_REG_OUT_SEL_ILED_SHIFT;\n\tint rval;\n\n\tif (flash->led_mode->val != V4L2_FLASH_LED_MODE_FLASH)\n\t\treturn -EBUSY;\n\n\tif (!enable)\n\t\treturn i2c_smbus_write_byte_data(client, ADP1653_REG_OUT_SEL,\n\t\t\t\t\t\t out_sel);\n\n\tout_sel |= ADP1653_FLASH_INTENSITY_mA_TO_REG(\n\t\tflash->flash_intensity->val)\n\t\t<< ADP1653_REG_OUT_SEL_HPLED_SHIFT;\n\trval = i2c_smbus_write_byte_data(client, ADP1653_REG_OUT_SEL, out_sel);\n\tif (rval)\n\t\treturn rval;\n\n\t \n\trval = i2c_smbus_write_byte_data(client, ADP1653_REG_SW_STROBE,\n\t\tADP1653_REG_SW_STROBE_SW_STROBE);\n\tif (rval)\n\t\treturn rval;\n\treturn i2c_smbus_write_byte_data(client, ADP1653_REG_SW_STROBE, 0);\n}\n\n \n\nstatic int adp1653_get_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct adp1653_flash *flash =\n\t\tcontainer_of(ctrl->handler, struct adp1653_flash, ctrls);\n\tint rval;\n\n\trval = adp1653_get_fault(flash);\n\tif (rval)\n\t\treturn rval;\n\n\tctrl->cur.val = 0;\n\n\tif (flash->fault & ADP1653_REG_FAULT_FLT_SCP)\n\t\tctrl->cur.val |= V4L2_FLASH_FAULT_SHORT_CIRCUIT;\n\tif (flash->fault & ADP1653_REG_FAULT_FLT_OT)\n\t\tctrl->cur.val |= V4L2_FLASH_FAULT_OVER_TEMPERATURE;\n\tif (flash->fault & ADP1653_REG_FAULT_FLT_TMR)\n\t\tctrl->cur.val |= V4L2_FLASH_FAULT_TIMEOUT;\n\tif (flash->fault & ADP1653_REG_FAULT_FLT_OV)\n\t\tctrl->cur.val |= V4L2_FLASH_FAULT_OVER_VOLTAGE;\n\n\tflash->fault = 0;\n\n\treturn 0;\n}\n\nstatic int adp1653_set_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct adp1653_flash *flash =\n\t\tcontainer_of(ctrl->handler, struct adp1653_flash, ctrls);\n\tint rval;\n\n\trval = adp1653_get_fault(flash);\n\tif (rval)\n\t\treturn rval;\n\tif ((rval & (ADP1653_REG_FAULT_FLT_SCP |\n\t\t     ADP1653_REG_FAULT_FLT_OT |\n\t\t     ADP1653_REG_FAULT_FLT_OV)) &&\n\t    (ctrl->id == V4L2_CID_FLASH_STROBE ||\n\t     ctrl->id == V4L2_CID_FLASH_TORCH_INTENSITY ||\n\t     ctrl->id == V4L2_CID_FLASH_LED_MODE))\n\t\treturn -EBUSY;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_FLASH_STROBE:\n\t\treturn adp1653_strobe(flash, 1);\n\tcase V4L2_CID_FLASH_STROBE_STOP:\n\t\treturn adp1653_strobe(flash, 0);\n\t}\n\n\treturn adp1653_update_hw(flash);\n}\n\nstatic const struct v4l2_ctrl_ops adp1653_ctrl_ops = {\n\t.g_volatile_ctrl = adp1653_get_ctrl,\n\t.s_ctrl = adp1653_set_ctrl,\n};\n\nstatic int adp1653_init_controls(struct adp1653_flash *flash)\n{\n\tstruct v4l2_ctrl *fault;\n\n\tv4l2_ctrl_handler_init(&flash->ctrls, 9);\n\n\tflash->led_mode =\n\t\tv4l2_ctrl_new_std_menu(&flash->ctrls, &adp1653_ctrl_ops,\n\t\t\t\t       V4L2_CID_FLASH_LED_MODE,\n\t\t\t\t       V4L2_FLASH_LED_MODE_TORCH, ~0x7, 0);\n\tv4l2_ctrl_new_std_menu(&flash->ctrls, &adp1653_ctrl_ops,\n\t\t\t       V4L2_CID_FLASH_STROBE_SOURCE,\n\t\t\t       V4L2_FLASH_STROBE_SOURCE_SOFTWARE, ~0x1, 0);\n\tv4l2_ctrl_new_std(&flash->ctrls, &adp1653_ctrl_ops,\n\t\t\t  V4L2_CID_FLASH_STROBE, 0, 0, 0, 0);\n\tv4l2_ctrl_new_std(&flash->ctrls, &adp1653_ctrl_ops,\n\t\t\t  V4L2_CID_FLASH_STROBE_STOP, 0, 0, 0, 0);\n\tflash->flash_timeout =\n\t\tv4l2_ctrl_new_std(&flash->ctrls, &adp1653_ctrl_ops,\n\t\t\t\t  V4L2_CID_FLASH_TIMEOUT, TIMEOUT_MIN,\n\t\t\t\t  flash->platform_data->max_flash_timeout,\n\t\t\t\t  TIMEOUT_STEP,\n\t\t\t\t  flash->platform_data->max_flash_timeout);\n\tflash->flash_intensity =\n\t\tv4l2_ctrl_new_std(&flash->ctrls, &adp1653_ctrl_ops,\n\t\t\t\t  V4L2_CID_FLASH_INTENSITY,\n\t\t\t\t  ADP1653_FLASH_INTENSITY_MIN,\n\t\t\t\t  flash->platform_data->max_flash_intensity,\n\t\t\t\t  1, flash->platform_data->max_flash_intensity);\n\tflash->torch_intensity =\n\t\tv4l2_ctrl_new_std(&flash->ctrls, &adp1653_ctrl_ops,\n\t\t\t\t  V4L2_CID_FLASH_TORCH_INTENSITY,\n\t\t\t\t  ADP1653_TORCH_INTENSITY_MIN,\n\t\t\t\t  flash->platform_data->max_torch_intensity,\n\t\t\t\t  ADP1653_FLASH_INTENSITY_STEP,\n\t\t\t\t  flash->platform_data->max_torch_intensity);\n\tflash->indicator_intensity =\n\t\tv4l2_ctrl_new_std(&flash->ctrls, &adp1653_ctrl_ops,\n\t\t\t\t  V4L2_CID_FLASH_INDICATOR_INTENSITY,\n\t\t\t\t  ADP1653_INDICATOR_INTENSITY_MIN,\n\t\t\t\t  flash->platform_data->max_indicator_intensity,\n\t\t\t\t  ADP1653_INDICATOR_INTENSITY_STEP,\n\t\t\t\t  ADP1653_INDICATOR_INTENSITY_MIN);\n\tfault = v4l2_ctrl_new_std(&flash->ctrls, &adp1653_ctrl_ops,\n\t\t\t\t  V4L2_CID_FLASH_FAULT, 0,\n\t\t\t\t  V4L2_FLASH_FAULT_OVER_VOLTAGE\n\t\t\t\t  | V4L2_FLASH_FAULT_OVER_TEMPERATURE\n\t\t\t\t  | V4L2_FLASH_FAULT_SHORT_CIRCUIT, 0, 0);\n\n\tif (flash->ctrls.error)\n\t\treturn flash->ctrls.error;\n\n\tfault->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\n\tflash->subdev.ctrl_handler = &flash->ctrls;\n\treturn 0;\n}\n\n \n\nstatic int\nadp1653_init_device(struct adp1653_flash *flash)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&flash->subdev);\n\tint rval;\n\n\t \n\trval = i2c_smbus_write_byte_data(client, ADP1653_REG_OUT_SEL, 0);\n\tif (rval < 0) {\n\t\tdev_err(&client->dev, \"failed writing fault register\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmutex_lock(flash->ctrls.lock);\n\t \n\tflash->fault = 0;\n\trval = adp1653_get_fault(flash);\n\tmutex_unlock(flash->ctrls.lock);\n\tif (rval > 0) {\n\t\tdev_err(&client->dev, \"faults detected: 0x%1.1x\\n\", rval);\n\t\treturn -EIO;\n\t}\n\n\tmutex_lock(flash->ctrls.lock);\n\trval = adp1653_update_hw(flash);\n\tmutex_unlock(flash->ctrls.lock);\n\tif (rval) {\n\t\tdev_err(&client->dev,\n\t\t\t\"adp1653_update_hw failed at %s\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int\n__adp1653_set_power(struct adp1653_flash *flash, int on)\n{\n\tint ret;\n\n\tif (flash->platform_data->power) {\n\t\tret = flash->platform_data->power(&flash->subdev, on);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tgpiod_set_value(flash->platform_data->enable_gpio, on);\n\t\tif (on)\n\t\t\t \n\t\t\tudelay(20);\n\t}\n\n\tif (!on)\n\t\treturn 0;\n\n\tret = adp1653_init_device(flash);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\tif (flash->platform_data->power)\n\t\tflash->platform_data->power(&flash->subdev, 0);\n\telse\n\t\tgpiod_set_value(flash->platform_data->enable_gpio, 0);\n\n\treturn ret;\n}\n\nstatic int\nadp1653_set_power(struct v4l2_subdev *subdev, int on)\n{\n\tstruct adp1653_flash *flash = to_adp1653_flash(subdev);\n\tint ret = 0;\n\n\tmutex_lock(&flash->power_lock);\n\n\t \n\tif (flash->power_count == !on) {\n\t\tret = __adp1653_set_power(flash, !!on);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\t \n\tflash->power_count += on ? 1 : -1;\n\tWARN_ON(flash->power_count < 0);\n\ndone:\n\tmutex_unlock(&flash->power_lock);\n\treturn ret;\n}\n\nstatic int adp1653_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\treturn adp1653_set_power(sd, 1);\n}\n\nstatic int adp1653_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\treturn adp1653_set_power(sd, 0);\n}\n\nstatic const struct v4l2_subdev_core_ops adp1653_core_ops = {\n\t.s_power = adp1653_set_power,\n};\n\nstatic const struct v4l2_subdev_ops adp1653_ops = {\n\t.core = &adp1653_core_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops adp1653_internal_ops = {\n\t.open = adp1653_open,\n\t.close = adp1653_close,\n};\n\n \n#ifdef CONFIG_PM\n\nstatic int adp1653_suspend(struct device *dev)\n{\n\tstruct v4l2_subdev *subdev = dev_get_drvdata(dev);\n\tstruct adp1653_flash *flash = to_adp1653_flash(subdev);\n\n\tif (!flash->power_count)\n\t\treturn 0;\n\n\treturn __adp1653_set_power(flash, 0);\n}\n\nstatic int adp1653_resume(struct device *dev)\n{\n\tstruct v4l2_subdev *subdev = dev_get_drvdata(dev);\n\tstruct adp1653_flash *flash = to_adp1653_flash(subdev);\n\n\tif (!flash->power_count)\n\t\treturn 0;\n\n\treturn __adp1653_set_power(flash, 1);\n}\n\n#else\n\n#define adp1653_suspend\tNULL\n#define adp1653_resume\tNULL\n\n#endif  \n\nstatic int adp1653_of_init(struct i2c_client *client,\n\t\t\t   struct adp1653_flash *flash,\n\t\t\t   struct device_node *node)\n{\n\tstruct adp1653_platform_data *pd;\n\tstruct device_node *child;\n\n\tpd = devm_kzalloc(&client->dev, sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn -ENOMEM;\n\tflash->platform_data = pd;\n\n\tchild = of_get_child_by_name(node, \"flash\");\n\tif (!child)\n\t\treturn -EINVAL;\n\n\tif (of_property_read_u32(child, \"flash-timeout-us\",\n\t\t\t\t &pd->max_flash_timeout))\n\t\tgoto err;\n\n\tif (of_property_read_u32(child, \"flash-max-microamp\",\n\t\t\t\t &pd->max_flash_intensity))\n\t\tgoto err;\n\n\tpd->max_flash_intensity /= 1000;\n\n\tif (of_property_read_u32(child, \"led-max-microamp\",\n\t\t\t\t &pd->max_torch_intensity))\n\t\tgoto err;\n\n\tpd->max_torch_intensity /= 1000;\n\tof_node_put(child);\n\n\tchild = of_get_child_by_name(node, \"indicator\");\n\tif (!child)\n\t\treturn -EINVAL;\n\n\tif (of_property_read_u32(child, \"led-max-microamp\",\n\t\t\t\t &pd->max_indicator_intensity))\n\t\tgoto err;\n\n\tof_node_put(child);\n\n\tpd->enable_gpio = devm_gpiod_get(&client->dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(pd->enable_gpio)) {\n\t\tdev_err(&client->dev, \"Error getting GPIO\\n\");\n\t\treturn PTR_ERR(pd->enable_gpio);\n\t}\n\n\treturn 0;\nerr:\n\tdev_err(&client->dev, \"Required property not found\\n\");\n\tof_node_put(child);\n\treturn -EINVAL;\n}\n\n\nstatic int adp1653_probe(struct i2c_client *client)\n{\n\tstruct adp1653_flash *flash;\n\tint ret;\n\n\tflash = devm_kzalloc(&client->dev, sizeof(*flash), GFP_KERNEL);\n\tif (flash == NULL)\n\t\treturn -ENOMEM;\n\n\tif (client->dev.of_node) {\n\t\tret = adp1653_of_init(client, flash, client->dev.of_node);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tif (!client->dev.platform_data) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Neither DT not platform data provided\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tflash->platform_data = client->dev.platform_data;\n\t}\n\n\tmutex_init(&flash->power_lock);\n\n\tv4l2_i2c_subdev_init(&flash->subdev, client, &adp1653_ops);\n\tflash->subdev.internal_ops = &adp1653_internal_ops;\n\tflash->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tret = adp1653_init_controls(flash);\n\tif (ret)\n\t\tgoto free_and_quit;\n\n\tret = media_entity_pads_init(&flash->subdev.entity, 0, NULL);\n\tif (ret < 0)\n\t\tgoto free_and_quit;\n\n\tflash->subdev.entity.function = MEDIA_ENT_F_FLASH;\n\n\treturn 0;\n\nfree_and_quit:\n\tdev_err(&client->dev, \"adp1653: failed to register device\\n\");\n\tv4l2_ctrl_handler_free(&flash->ctrls);\n\treturn ret;\n}\n\nstatic void adp1653_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct adp1653_flash *flash = to_adp1653_flash(subdev);\n\n\tv4l2_device_unregister_subdev(&flash->subdev);\n\tv4l2_ctrl_handler_free(&flash->ctrls);\n\tmedia_entity_cleanup(&flash->subdev.entity);\n}\n\nstatic const struct i2c_device_id adp1653_id_table[] = {\n\t{ ADP1653_NAME, 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adp1653_id_table);\n\nstatic const struct dev_pm_ops adp1653_pm_ops = {\n\t.suspend\t= adp1653_suspend,\n\t.resume\t\t= adp1653_resume,\n};\n\nstatic struct i2c_driver adp1653_i2c_driver = {\n\t.driver\t\t= {\n\t\t.name\t= ADP1653_NAME,\n\t\t.pm\t= &adp1653_pm_ops,\n\t},\n\t.probe\t\t= adp1653_probe,\n\t.remove\t\t= adp1653_remove,\n\t.id_table\t= adp1653_id_table,\n};\n\nmodule_i2c_driver(adp1653_i2c_driver);\n\nMODULE_AUTHOR(\"Sakari Ailus <sakari.ailus@nokia.com>\");\nMODULE_DESCRIPTION(\"Analog Devices ADP1653 LED flash driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}