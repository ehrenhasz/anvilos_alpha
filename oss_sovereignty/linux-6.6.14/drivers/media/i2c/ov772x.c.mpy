{
  "module_name": "ov772x.c",
  "hash_id": "2d52bdca50251c204148027319cf7c163e24dbed4012af09352c76f3e3269df5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ov772x.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/v4l2-mediabus.h>\n#include <linux/videodev2.h>\n\n#include <media/i2c/ov772x.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-image-sizes.h>\n#include <media/v4l2-subdev.h>\n\n \n#define GAIN        0x00  \n#define BLUE        0x01  \n#define RED         0x02  \n#define GREEN       0x03  \n#define COM1        0x04  \n#define BAVG        0x05  \n#define GAVG        0x06  \n#define RAVG        0x07  \n#define AECH        0x08  \n#define COM2        0x09  \n#define PID         0x0A  \n#define VER         0x0B  \n#define COM3        0x0C  \n#define COM4        0x0D  \n#define COM5        0x0E  \n#define COM6        0x0F  \n#define AEC         0x10  \n#define CLKRC       0x11  \n#define COM7        0x12  \n#define COM8        0x13  \n#define COM9        0x14  \n#define COM10       0x15  \n#define REG16       0x16  \n#define HSTART      0x17  \n#define HSIZE       0x18  \n#define VSTART      0x19  \n#define VSIZE       0x1A  \n#define PSHFT       0x1B  \n#define MIDH        0x1C  \n#define MIDL        0x1D  \n#define LAEC        0x1F  \n#define COM11       0x20  \n#define BDBASE      0x22  \n#define DBSTEP      0x23  \n#define AEW         0x24  \n#define AEB         0x25  \n#define VPT         0x26  \n#define REG28       0x28  \n#define HOUTSIZE    0x29  \n#define EXHCH       0x2A  \n#define EXHCL       0x2B  \n#define VOUTSIZE    0x2C  \n#define ADVFL       0x2D  \n#define ADVFH       0x2E  \n#define YAVE        0x2F  \n#define LUMHTH      0x30  \n#define LUMLTH      0x31  \n#define HREF        0x32  \n#define DM_LNL      0x33  \n#define DM_LNH      0x34  \n#define ADOFF_B     0x35  \n#define ADOFF_R     0x36  \n#define ADOFF_GB    0x37  \n#define ADOFF_GR    0x38  \n#define OFF_B       0x39  \n#define OFF_R       0x3A  \n#define OFF_GB      0x3B  \n#define OFF_GR      0x3C  \n#define COM12       0x3D  \n#define COM13       0x3E  \n#define COM14       0x3F  \n#define COM15       0x40  \n#define COM16       0x41  \n#define TGT_B       0x42  \n#define TGT_R       0x43  \n#define TGT_GB      0x44  \n#define TGT_GR      0x45  \n \n#define LCC0        0x46  \n#define LCC1        0x47  \n#define LCC2        0x48  \n#define LCC3        0x49  \n#define LCC4        0x4A  \n#define LCC5        0x4B  \n#define LCC6        0x4C  \n \n#define LC_CTR      0x46  \n#define LC_XC       0x47  \n#define LC_YC       0x48  \n#define LC_COEF     0x49  \n#define LC_RADI     0x4A  \n#define LC_COEFB    0x4B  \n#define LC_COEFR    0x4C  \n\n#define FIXGAIN     0x4D  \n#define AREF0       0x4E  \n#define AREF1       0x4F  \n#define AREF2       0x50  \n#define AREF3       0x51  \n#define AREF4       0x52  \n#define AREF5       0x53  \n#define AREF6       0x54  \n#define AREF7       0x55  \n#define UFIX        0x60  \n#define VFIX        0x61  \n#define AWBB_BLK    0x62  \n#define AWB_CTRL0   0x63  \n#define DSP_CTRL1   0x64  \n#define DSP_CTRL2   0x65  \n#define DSP_CTRL3   0x66  \n#define DSP_CTRL4   0x67  \n#define AWB_BIAS    0x68  \n#define AWB_CTRL1   0x69  \n#define AWB_CTRL2   0x6A  \n#define AWB_CTRL3   0x6B  \n#define AWB_CTRL4   0x6C  \n#define AWB_CTRL5   0x6D  \n#define AWB_CTRL6   0x6E  \n#define AWB_CTRL7   0x6F  \n#define AWB_CTRL8   0x70  \n#define AWB_CTRL9   0x71  \n#define AWB_CTRL10  0x72  \n#define AWB_CTRL11  0x73  \n#define AWB_CTRL12  0x74  \n#define AWB_CTRL13  0x75  \n#define AWB_CTRL14  0x76  \n#define AWB_CTRL15  0x77  \n#define AWB_CTRL16  0x78  \n#define AWB_CTRL17  0x79  \n#define AWB_CTRL18  0x7A  \n#define AWB_CTRL19  0x7B  \n#define AWB_CTRL20  0x7C  \n#define AWB_CTRL21  0x7D  \n#define GAM1        0x7E  \n#define GAM2        0x7F  \n#define GAM3        0x80  \n#define GAM4        0x81  \n#define GAM5        0x82  \n#define GAM6        0x83  \n#define GAM7        0x84  \n#define GAM8        0x85  \n#define GAM9        0x86  \n#define GAM10       0x87  \n#define GAM11       0x88  \n#define GAM12       0x89  \n#define GAM13       0x8A  \n#define GAM14       0x8B  \n#define GAM15       0x8C  \n#define SLOP        0x8D  \n#define DNSTH       0x8E  \n#define EDGE_STRNGT 0x8F  \n#define EDGE_TRSHLD 0x90  \n#define DNSOFF      0x91  \n#define EDGE_UPPER  0x92  \n#define EDGE_LOWER  0x93  \n#define MTX1        0x94  \n#define MTX2        0x95  \n#define MTX3        0x96  \n#define MTX4        0x97  \n#define MTX5        0x98  \n#define MTX6        0x99  \n#define MTX_CTRL    0x9A  \n#define BRIGHT      0x9B  \n#define CNTRST      0x9C  \n#define CNTRST_CTRL 0x9D  \n#define UVAD_J0     0x9E  \n#define UVAD_J1     0x9F  \n#define SCAL0       0xA0  \n#define SCAL1       0xA1  \n#define SCAL2       0xA2  \n#define FIFODLYM    0xA3  \n#define FIFODLYA    0xA4  \n#define SDE         0xA6  \n#define USAT        0xA7  \n#define VSAT        0xA8  \n \n#define HUE0        0xA9  \n#define HUE1        0xAA  \n \n#define HUECOS      0xA9  \n#define HUESIN      0xAA  \n\n#define SIGN        0xAB  \n#define DSPAUTO     0xAC  \n\n \n\n \n#define SOFT_SLEEP_MODE 0x10\t \n\t\t\t\t \n#define OCAP_1x         0x00\t \n#define OCAP_2x         0x01\t \n#define OCAP_3x         0x02\t \n#define OCAP_4x         0x03\t \n\n \n#define SWAP_MASK       (SWAP_RGB | SWAP_YUV | SWAP_ML)\n#define IMG_MASK        (VFLIP_IMG | HFLIP_IMG | SCOLOR_TEST)\n\n#define VFLIP_IMG       0x80\t \n#define HFLIP_IMG       0x40\t \n#define SWAP_RGB        0x20\t \n#define SWAP_YUV        0x10\t \n#define SWAP_ML         0x08\t \n\t\t\t\t \n#define NOTRI_CLOCK     0x04\t \n\t\t\t\t \n\t\t\t\t \n#define NOTRI_DATA      0x02\t \n\t\t\t\t \n#define SCOLOR_TEST     0x01\t \n\n \n\t\t\t\t \n#define PLL_BYPASS      0x00\t \n#define PLL_4x          0x40\t \n#define PLL_6x          0x80\t \n#define PLL_8x          0xc0\t \n\t\t\t\t \n#define AEC_FULL        0x00\t \n#define AEC_1p2         0x10\t \n#define AEC_1p4         0x20\t \n#define AEC_2p3         0x30\t \n#define COM4_RESERVED   0x01\t \n\n \n#define AFR_ON_OFF      0x80\t \n#define AFR_SPPED       0x40\t \n\t\t\t\t \n#define AFR_NO_RATE     0x00\t \n#define AFR_1p2         0x10\t \n#define AFR_1p4         0x20\t \n#define AFR_1p8         0x30\t \n\t\t\t\t \n#define AF_2x           0x00\t \n#define AF_4x           0x04\t \n#define AF_8x           0x08\t \n#define AF_16x          0x0c\t \n\t\t\t\t \n#define AEC_NO_LIMIT    0x01\t \n\t\t\t\t \n \n\t\t\t\t \n#define CLKRC_RESERVED  0x80\t \n#define CLKRC_DIV(n)    ((n) - 1)\n\n \n\t\t\t\t \n#define SCCB_RESET      0x80\t \n\t\t\t\t \n\t\t\t\t \n#define SLCT_MASK       0x40\t \n#define SLCT_VGA        0x00\t \n#define SLCT_QVGA       0x40\t \n#define ITU656_ON_OFF   0x20\t \n#define SENSOR_RAW\t0x10\t \n\t\t\t\t \n#define FMT_MASK        0x0c\t \n#define FMT_GBR422      0x00\t \n#define FMT_RGB565      0x04\t \n#define FMT_RGB555      0x08\t \n#define FMT_RGB444      0x0c\t \n\t\t\t\t \n#define OFMT_MASK       0x03     \n#define OFMT_YUV        0x00\t \n#define OFMT_P_BRAW     0x01\t \n#define OFMT_RGB        0x02\t \n#define OFMT_BRAW       0x03\t \n\n \n#define FAST_ALGO       0x80\t \n\t\t\t\t \n#define UNLMT_STEP      0x40\t \n\t\t\t\t \n#define BNDF_ON_OFF     0x20\t \n#define AEC_BND         0x10\t \n#define AEC_ON_OFF      0x08\t \n#define AGC_ON          0x04\t \n#define AWB_ON          0x02\t \n#define AEC_ON          0x01\t \n\n \n#define BASE_AECAGC     0x80\t \n\t\t\t\t \n#define GAIN_2x         0x00\t \n#define GAIN_4x         0x10\t \n#define GAIN_8x         0x20\t \n#define GAIN_16x        0x30\t \n#define GAIN_32x        0x40\t \n#define GAIN_64x        0x50\t \n#define GAIN_128x       0x60\t \n#define DROP_VSYNC      0x04\t \n#define DROP_HREF       0x02\t \n\n \n#define SGLF_ON_OFF     0x02\t \n#define SGLF_TRIG       0x01\t \n\n \n#define HREF_VSTART_SHIFT\t6\t \n#define HREF_HSTART_SHIFT\t4\t \n#define HREF_VSIZE_SHIFT\t2\t \n#define HREF_HSIZE_SHIFT\t0\t \n\n \n#define EXHCH_VSIZE_SHIFT\t2\t \n#define EXHCH_HSIZE_SHIFT\t0\t \n\n \n#define FIFO_ON         0x80\t \n#define UV_ON_OFF       0x40\t \n#define YUV444_2_422    0x20\t \n#define CLR_MTRX_ON_OFF 0x10\t \n#define INTPLT_ON_OFF   0x08\t \n#define GMM_ON_OFF      0x04\t \n#define AUTO_BLK_ON_OFF 0x02\t \n#define AUTO_WHT_ON_OFF 0x01\t \n\n \n#define UV_MASK         0x80\t \n#define UV_ON           0x80\t \n#define UV_OFF          0x00\t \n#define CBAR_MASK       0x20\t \n#define CBAR_ON         0x20\t \n#define CBAR_OFF        0x00\t \n\n \n#define DSP_OFMT_YUV\t0x00\n#define DSP_OFMT_RGB\t0x00\n#define DSP_OFMT_RAW8\t0x02\n#define DSP_OFMT_RAW10\t0x03\n\n \n#define AWB_ACTRL       0x80  \n#define DENOISE_ACTRL   0x40  \n#define EDGE_ACTRL      0x20  \n#define UV_ACTRL        0x10  \n#define SCAL0_ACTRL     0x08  \n#define SCAL1_2_ACTRL   0x04  \n\n#define OV772X_MAX_WIDTH\tVGA_WIDTH\n#define OV772X_MAX_HEIGHT\tVGA_HEIGHT\n\n \n#define OV7720  0x7720\n#define OV7725  0x7721\n#define VERSION(pid, ver) ((pid << 8) | (ver & 0xFF))\n\n \nstatic struct {\n\tunsigned int mult;\n\tu8 com4;\n} ov772x_pll[] = {\n\t{ 1, PLL_BYPASS, },\n\t{ 4, PLL_4x, },\n\t{ 6, PLL_6x, },\n\t{ 8, PLL_8x, },\n};\n\n \n\nstruct ov772x_color_format {\n\tu32 code;\n\tenum v4l2_colorspace colorspace;\n\tu8 dsp3;\n\tu8 dsp4;\n\tu8 com3;\n\tu8 com7;\n};\n\nstruct ov772x_win_size {\n\tchar                     *name;\n\tunsigned char             com7_bit;\n\tunsigned int\t\t  sizeimage;\n\tstruct v4l2_rect\t  rect;\n};\n\nstruct ov772x_priv {\n\tstruct v4l2_subdev                subdev;\n\tstruct v4l2_ctrl_handler\t  hdl;\n\tstruct clk\t\t\t *clk;\n\tstruct regmap\t\t\t *regmap;\n\tstruct ov772x_camera_info        *info;\n\tstruct gpio_desc\t\t *pwdn_gpio;\n\tstruct gpio_desc\t\t *rstb_gpio;\n\tconst struct ov772x_color_format *cfmt;\n\tconst struct ov772x_win_size     *win;\n\tstruct v4l2_ctrl\t\t *vflip_ctrl;\n\tstruct v4l2_ctrl\t\t *hflip_ctrl;\n\tunsigned int\t\t\t  test_pattern;\n\t \n\tstruct v4l2_ctrl\t\t *band_filter_ctrl;\n\tunsigned int\t\t\t  fps;\n\t \n\tstruct mutex\t\t\t  lock;\n\tint\t\t\t\t  power_count;\n\tint\t\t\t\t  streaming;\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tstruct media_pad pad;\n#endif\n\tenum v4l2_mbus_type\t\t  bus_type;\n};\n\n \nstatic const struct ov772x_color_format ov772x_cfmts[] = {\n\t{\n\t\t.code\t\t= MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.dsp3\t\t= 0x0,\n\t\t.dsp4\t\t= DSP_OFMT_YUV,\n\t\t.com3\t\t= SWAP_YUV,\n\t\t.com7\t\t= OFMT_YUV,\n\t},\n\t{\n\t\t.code\t\t= MEDIA_BUS_FMT_YVYU8_2X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.dsp3\t\t= UV_ON,\n\t\t.dsp4\t\t= DSP_OFMT_YUV,\n\t\t.com3\t\t= SWAP_YUV,\n\t\t.com7\t\t= OFMT_YUV,\n\t},\n\t{\n\t\t.code\t\t= MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.dsp3\t\t= 0x0,\n\t\t.dsp4\t\t= DSP_OFMT_YUV,\n\t\t.com3\t\t= 0x0,\n\t\t.com7\t\t= OFMT_YUV,\n\t},\n\t{\n\t\t.code\t\t= MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.dsp3\t\t= 0x0,\n\t\t.dsp4\t\t= DSP_OFMT_YUV,\n\t\t.com3\t\t= SWAP_RGB,\n\t\t.com7\t\t= FMT_RGB555 | OFMT_RGB,\n\t},\n\t{\n\t\t.code\t\t= MEDIA_BUS_FMT_RGB555_2X8_PADHI_BE,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.dsp3\t\t= 0x0,\n\t\t.dsp4\t\t= DSP_OFMT_YUV,\n\t\t.com3\t\t= 0x0,\n\t\t.com7\t\t= FMT_RGB555 | OFMT_RGB,\n\t},\n\t{\n\t\t.code\t\t= MEDIA_BUS_FMT_RGB565_2X8_LE,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.dsp3\t\t= 0x0,\n\t\t.dsp4\t\t= DSP_OFMT_YUV,\n\t\t.com3\t\t= SWAP_RGB,\n\t\t.com7\t\t= FMT_RGB565 | OFMT_RGB,\n\t},\n\t{\n\t\t.code\t\t= MEDIA_BUS_FMT_RGB565_2X8_BE,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.dsp3\t\t= 0x0,\n\t\t.dsp4\t\t= DSP_OFMT_YUV,\n\t\t.com3\t\t= 0x0,\n\t\t.com7\t\t= FMT_RGB565 | OFMT_RGB,\n\t},\n\t{\n\t\t \n\t\t.code\t\t= MEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.dsp3\t\t= 0x0,\n\t\t.dsp4\t\t= DSP_OFMT_RAW10,\n\t\t.com3\t\t= 0x0,\n\t\t.com7\t\t= SENSOR_RAW | OFMT_BRAW,\n\t},\n};\n\n \n\nstatic const struct ov772x_win_size ov772x_win_sizes[] = {\n\t{\n\t\t.name\t\t= \"VGA\",\n\t\t.com7_bit\t= SLCT_VGA,\n\t\t.sizeimage\t= 510 * 748,\n\t\t.rect = {\n\t\t\t.left\t= 140,\n\t\t\t.top\t= 14,\n\t\t\t.width\t= VGA_WIDTH,\n\t\t\t.height\t= VGA_HEIGHT,\n\t\t},\n\t}, {\n\t\t.name\t\t= \"QVGA\",\n\t\t.com7_bit\t= SLCT_QVGA,\n\t\t.sizeimage\t= 278 * 576,\n\t\t.rect = {\n\t\t\t.left\t= 252,\n\t\t\t.top\t= 6,\n\t\t\t.width\t= QVGA_WIDTH,\n\t\t\t.height\t= QVGA_HEIGHT,\n\t\t},\n\t},\n};\n\nstatic const char * const ov772x_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Vertical Color Bar Type 1\",\n};\n\n \nstatic const unsigned int ov772x_frame_intervals[] = { 5, 10, 15, 20, 30, 60 };\n\n \n\nstatic struct ov772x_priv *to_ov772x(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct ov772x_priv, subdev);\n}\n\nstatic int ov772x_reset(struct ov772x_priv *priv)\n{\n\tint ret;\n\n\tret = regmap_write(priv->regmap, COM7, SCCB_RESET);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(1000, 5000);\n\n\treturn regmap_update_bits(priv->regmap, COM2, SOFT_SLEEP_MODE,\n\t\t\t\t  SOFT_SLEEP_MODE);\n}\n\n \n\nstatic int ov772x_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ov772x_priv *priv = to_ov772x(sd);\n\tint ret = 0;\n\n\tmutex_lock(&priv->lock);\n\n\tif (priv->streaming == enable)\n\t\tgoto done;\n\n\tif (priv->bus_type == V4L2_MBUS_BT656) {\n\t\tret = regmap_update_bits(priv->regmap, COM7, ITU656_ON_OFF,\n\t\t\t\t\t enable ?\n\t\t\t\t\t ITU656_ON_OFF : ~ITU656_ON_OFF);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\n\tret = regmap_update_bits(priv->regmap, COM2, SOFT_SLEEP_MODE,\n\t\t\t\t enable ? 0 : SOFT_SLEEP_MODE);\n\tif (ret)\n\t\tgoto done;\n\n\tif (enable) {\n\t\tdev_dbg(&client->dev, \"format %d, win %s\\n\",\n\t\t\tpriv->cfmt->code, priv->win->name);\n\t}\n\tpriv->streaming = enable;\n\ndone:\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic unsigned int ov772x_select_fps(struct ov772x_priv *priv,\n\t\t\t\t      struct v4l2_fract *tpf)\n{\n\tunsigned int fps = tpf->numerator ?\n\t\t\t   tpf->denominator / tpf->numerator :\n\t\t\t   tpf->denominator;\n\tunsigned int best_diff;\n\tunsigned int diff;\n\tunsigned int idx;\n\tunsigned int i;\n\n\t \n\tbest_diff = ~0L;\n\tfor (i = 0, idx = 0; i < ARRAY_SIZE(ov772x_frame_intervals); i++) {\n\t\tdiff = abs(fps - ov772x_frame_intervals[i]);\n\t\tif (diff < best_diff) {\n\t\t\tidx = i;\n\t\t\tbest_diff = diff;\n\t\t}\n\t}\n\n\treturn ov772x_frame_intervals[idx];\n}\n\nstatic int ov772x_set_frame_rate(struct ov772x_priv *priv,\n\t\t\t\t unsigned int fps,\n\t\t\t\t const struct ov772x_color_format *cfmt,\n\t\t\t\t const struct ov772x_win_size *win)\n{\n\tunsigned long fin = clk_get_rate(priv->clk);\n\tunsigned int best_diff;\n\tunsigned int fsize;\n\tunsigned int pclk;\n\tunsigned int diff;\n\tunsigned int i;\n\tu8 clkrc = 0;\n\tu8 com4 = 0;\n\tint ret;\n\n\t \n\tswitch (cfmt->com7 & OFMT_MASK) {\n\tcase OFMT_BRAW:\n\t\tfsize = win->sizeimage;\n\t\tbreak;\n\tcase OFMT_RGB:\n\tcase OFMT_YUV:\n\tdefault:\n\t\tfsize = win->sizeimage * 2;\n\t\tbreak;\n\t}\n\n\tpclk = fps * fsize;\n\n\t \n\tbest_diff = ~0L;\n\tfor (i = 0; i < ARRAY_SIZE(ov772x_pll); i++) {\n\t\tunsigned int pll_mult = ov772x_pll[i].mult;\n\t\tunsigned int pll_out = pll_mult * fin;\n\t\tunsigned int t_pclk;\n\t\tunsigned int div;\n\n\t\tif (pll_out < pclk)\n\t\t\tcontinue;\n\n\t\tdiv = DIV_ROUND_CLOSEST(pll_out, pclk);\n\t\tt_pclk = DIV_ROUND_CLOSEST(fin * pll_mult, div);\n\t\tdiff = abs(pclk - t_pclk);\n\t\tif (diff < best_diff) {\n\t\t\tbest_diff = diff;\n\t\t\tclkrc = CLKRC_DIV(div);\n\t\t\tcom4 = ov772x_pll[i].com4;\n\t\t}\n\t}\n\n\tret = regmap_write(priv->regmap, COM4, com4 | COM4_RESERVED);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(priv->regmap, CLKRC, clkrc | CLKRC_RESERVED);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ov772x_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *ival)\n{\n\tstruct ov772x_priv *priv = to_ov772x(sd);\n\tstruct v4l2_fract *tpf = &ival->interval;\n\n\ttpf->numerator = 1;\n\ttpf->denominator = priv->fps;\n\n\treturn 0;\n}\n\nstatic int ov772x_s_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *ival)\n{\n\tstruct ov772x_priv *priv = to_ov772x(sd);\n\tstruct v4l2_fract *tpf = &ival->interval;\n\tunsigned int fps;\n\tint ret = 0;\n\n\tmutex_lock(&priv->lock);\n\n\tif (priv->streaming) {\n\t\tret = -EBUSY;\n\t\tgoto error;\n\t}\n\n\tfps = ov772x_select_fps(priv, tpf);\n\n\t \n\tif (priv->power_count > 0) {\n\t\tret = ov772x_set_frame_rate(priv, fps, priv->cfmt, priv->win);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\ttpf->numerator = 1;\n\ttpf->denominator = fps;\n\tpriv->fps = fps;\n\nerror:\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int ov772x_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ov772x_priv *priv = container_of(ctrl->handler,\n\t\t\t\t\t\tstruct ov772x_priv, hdl);\n\tstruct regmap *regmap = priv->regmap;\n\tint ret = 0;\n\tu8 val;\n\n\t \n\n\t \n\tif (priv->power_count == 0)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_VFLIP:\n\t\tval = ctrl->val ? VFLIP_IMG : 0x00;\n\t\tif (priv->info && (priv->info->flags & OV772X_FLAG_VFLIP))\n\t\t\tval ^= VFLIP_IMG;\n\t\treturn regmap_update_bits(regmap, COM3, VFLIP_IMG, val);\n\tcase V4L2_CID_HFLIP:\n\t\tval = ctrl->val ? HFLIP_IMG : 0x00;\n\t\tif (priv->info && (priv->info->flags & OV772X_FLAG_HFLIP))\n\t\t\tval ^= HFLIP_IMG;\n\t\treturn regmap_update_bits(regmap, COM3, HFLIP_IMG, val);\n\tcase V4L2_CID_BAND_STOP_FILTER:\n\t\tif (!ctrl->val) {\n\t\t\t \n\t\t\tret = regmap_update_bits(regmap, BDBASE, 0xff, 0xff);\n\t\t\tif (!ret)\n\t\t\t\tret = regmap_update_bits(regmap, COM8,\n\t\t\t\t\t\t\t BNDF_ON_OFF, 0);\n\t\t} else {\n\t\t\t \n\t\t\tval = 256 - ctrl->val;\n\t\t\tret = regmap_update_bits(regmap, COM8,\n\t\t\t\t\t\t BNDF_ON_OFF, BNDF_ON_OFF);\n\t\t\tif (!ret)\n\t\t\t\tret = regmap_update_bits(regmap, BDBASE,\n\t\t\t\t\t\t\t 0xff, val);\n\t\t}\n\n\t\treturn ret;\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tpriv->test_pattern = ctrl->val;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int ov772x_g_register(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_dbg_register *reg)\n{\n\tstruct ov772x_priv *priv = to_ov772x(sd);\n\tint ret;\n\tunsigned int val;\n\n\treg->size = 1;\n\tif (reg->reg > 0xff)\n\t\treturn -EINVAL;\n\n\tret = regmap_read(priv->regmap, reg->reg, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treg->val = (__u64)val;\n\n\treturn 0;\n}\n\nstatic int ov772x_s_register(struct v4l2_subdev *sd,\n\t\t\t     const struct v4l2_dbg_register *reg)\n{\n\tstruct ov772x_priv *priv = to_ov772x(sd);\n\n\tif (reg->reg > 0xff ||\n\t    reg->val > 0xff)\n\t\treturn -EINVAL;\n\n\treturn regmap_write(priv->regmap, reg->reg, reg->val);\n}\n#endif\n\nstatic int ov772x_power_on(struct ov772x_priv *priv)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&priv->subdev);\n\tint ret;\n\n\tif (priv->clk) {\n\t\tret = clk_prepare_enable(priv->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (priv->pwdn_gpio) {\n\t\tgpiod_set_value(priv->pwdn_gpio, 1);\n\t\tusleep_range(500, 1000);\n\t}\n\n\t \n\tpriv->rstb_gpio = gpiod_get_optional(&client->dev, \"reset\",\n\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->rstb_gpio)) {\n\t\tdev_info(&client->dev, \"Unable to get GPIO \\\"reset\\\"\");\n\t\tclk_disable_unprepare(priv->clk);\n\t\treturn PTR_ERR(priv->rstb_gpio);\n\t}\n\n\tif (priv->rstb_gpio) {\n\t\tgpiod_set_value(priv->rstb_gpio, 1);\n\t\tusleep_range(500, 1000);\n\t\tgpiod_set_value(priv->rstb_gpio, 0);\n\t\tusleep_range(500, 1000);\n\n\t\tgpiod_put(priv->rstb_gpio);\n\t}\n\n\treturn 0;\n}\n\nstatic int ov772x_power_off(struct ov772x_priv *priv)\n{\n\tclk_disable_unprepare(priv->clk);\n\n\tif (priv->pwdn_gpio) {\n\t\tgpiod_set_value(priv->pwdn_gpio, 0);\n\t\tusleep_range(500, 1000);\n\t}\n\n\treturn 0;\n}\n\nstatic int ov772x_set_params(struct ov772x_priv *priv,\n\t\t\t     const struct ov772x_color_format *cfmt,\n\t\t\t     const struct ov772x_win_size *win);\n\nstatic int ov772x_s_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct ov772x_priv *priv = to_ov772x(sd);\n\tint ret = 0;\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tif (priv->power_count == !on) {\n\t\tif (on) {\n\t\t\tret = ov772x_power_on(priv);\n\t\t\t \n\t\t\tif (!ret)\n\t\t\t\tret = ov772x_set_params(priv, priv->cfmt,\n\t\t\t\t\t\t\tpriv->win);\n\t\t} else {\n\t\t\tret = ov772x_power_off(priv);\n\t\t}\n\t}\n\n\tif (!ret) {\n\t\t \n\t\tpriv->power_count += on ? 1 : -1;\n\t\tWARN(priv->power_count < 0, \"Unbalanced power count\\n\");\n\t\tWARN(priv->power_count > 1, \"Duplicated s_power call\\n\");\n\t}\n\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic const struct ov772x_win_size *ov772x_select_win(u32 width, u32 height)\n{\n\tconst struct ov772x_win_size *win = &ov772x_win_sizes[0];\n\tu32 best_diff = UINT_MAX;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ov772x_win_sizes); ++i) {\n\t\tu32 diff = abs(width - ov772x_win_sizes[i].rect.width)\n\t\t\t + abs(height - ov772x_win_sizes[i].rect.height);\n\t\tif (diff < best_diff) {\n\t\t\tbest_diff = diff;\n\t\t\twin = &ov772x_win_sizes[i];\n\t\t}\n\t}\n\n\treturn win;\n}\n\nstatic void ov772x_select_params(const struct v4l2_mbus_framefmt *mf,\n\t\t\t\t const struct ov772x_color_format **cfmt,\n\t\t\t\t const struct ov772x_win_size **win)\n{\n\tunsigned int i;\n\n\t \n\t*cfmt = &ov772x_cfmts[0];\n\n\tfor (i = 0; i < ARRAY_SIZE(ov772x_cfmts); i++) {\n\t\tif (mf->code == ov772x_cfmts[i].code) {\n\t\t\t*cfmt = &ov772x_cfmts[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\t*win = ov772x_select_win(mf->width, mf->height);\n}\n\nstatic int ov772x_edgectrl(struct ov772x_priv *priv)\n{\n\tstruct regmap *regmap = priv->regmap;\n\tint ret;\n\n\tif (!priv->info)\n\t\treturn 0;\n\n\tif (priv->info->edgectrl.strength & OV772X_MANUAL_EDGE_CTRL) {\n\t\t \n\n\t\tret = regmap_update_bits(regmap, DSPAUTO, EDGE_ACTRL, 0x00);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(regmap, EDGE_TRSHLD,\n\t\t\t\t\t OV772X_EDGE_THRESHOLD_MASK,\n\t\t\t\t\t priv->info->edgectrl.threshold);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(regmap, EDGE_STRNGT,\n\t\t\t\t\t OV772X_EDGE_STRENGTH_MASK,\n\t\t\t\t\t priv->info->edgectrl.strength);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t} else if (priv->info->edgectrl.upper > priv->info->edgectrl.lower) {\n\t\t \n\t\tret = regmap_update_bits(regmap, EDGE_UPPER,\n\t\t\t\t\t OV772X_EDGE_UPPER_MASK,\n\t\t\t\t\t priv->info->edgectrl.upper);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(regmap, EDGE_LOWER,\n\t\t\t\t\t OV772X_EDGE_LOWER_MASK,\n\t\t\t\t\t priv->info->edgectrl.lower);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov772x_set_params(struct ov772x_priv *priv,\n\t\t\t     const struct ov772x_color_format *cfmt,\n\t\t\t     const struct ov772x_win_size *win)\n{\n\tint ret;\n\tu8  val;\n\n\t \n\tov772x_reset(priv);\n\n\t \n\tret = ov772x_edgectrl(priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(priv->regmap, HSTART, win->rect.left >> 2);\n\tif (ret < 0)\n\t\tgoto ov772x_set_fmt_error;\n\tret = regmap_write(priv->regmap, HSIZE, win->rect.width >> 2);\n\tif (ret < 0)\n\t\tgoto ov772x_set_fmt_error;\n\tret = regmap_write(priv->regmap, VSTART, win->rect.top >> 1);\n\tif (ret < 0)\n\t\tgoto ov772x_set_fmt_error;\n\tret = regmap_write(priv->regmap, VSIZE, win->rect.height >> 1);\n\tif (ret < 0)\n\t\tgoto ov772x_set_fmt_error;\n\tret = regmap_write(priv->regmap, HOUTSIZE, win->rect.width >> 2);\n\tif (ret < 0)\n\t\tgoto ov772x_set_fmt_error;\n\tret = regmap_write(priv->regmap, VOUTSIZE, win->rect.height >> 1);\n\tif (ret < 0)\n\t\tgoto ov772x_set_fmt_error;\n\tret = regmap_write(priv->regmap, HREF,\n\t\t\t   ((win->rect.top & 1) << HREF_VSTART_SHIFT) |\n\t\t\t   ((win->rect.left & 3) << HREF_HSTART_SHIFT) |\n\t\t\t   ((win->rect.height & 1) << HREF_VSIZE_SHIFT) |\n\t\t\t   ((win->rect.width & 3) << HREF_HSIZE_SHIFT));\n\tif (ret < 0)\n\t\tgoto ov772x_set_fmt_error;\n\tret = regmap_write(priv->regmap, EXHCH,\n\t\t\t   ((win->rect.height & 1) << EXHCH_VSIZE_SHIFT) |\n\t\t\t   ((win->rect.width & 3) << EXHCH_HSIZE_SHIFT));\n\tif (ret < 0)\n\t\tgoto ov772x_set_fmt_error;\n\n\t \n\tval = cfmt->dsp3;\n\tif (val) {\n\t\tret = regmap_update_bits(priv->regmap, DSP_CTRL3, UV_MASK, val);\n\t\tif (ret < 0)\n\t\t\tgoto ov772x_set_fmt_error;\n\t}\n\n\t \n\tif (cfmt->dsp4) {\n\t\tret = regmap_write(priv->regmap, DSP_CTRL4, cfmt->dsp4);\n\t\tif (ret < 0)\n\t\t\tgoto ov772x_set_fmt_error;\n\t}\n\n\t \n\tval = cfmt->com3;\n\tif (priv->info && (priv->info->flags & OV772X_FLAG_VFLIP))\n\t\tval |= VFLIP_IMG;\n\tif (priv->info && (priv->info->flags & OV772X_FLAG_HFLIP))\n\t\tval |= HFLIP_IMG;\n\tif (priv->vflip_ctrl->val)\n\t\tval ^= VFLIP_IMG;\n\tif (priv->hflip_ctrl->val)\n\t\tval ^= HFLIP_IMG;\n\tif (priv->test_pattern)\n\t\tval |= SCOLOR_TEST;\n\n\tret = regmap_update_bits(priv->regmap, COM3, SWAP_MASK | IMG_MASK, val);\n\tif (ret < 0)\n\t\tgoto ov772x_set_fmt_error;\n\n\t \n\tret = regmap_write(priv->regmap, COM7, win->com7_bit | cfmt->com7);\n\tif (ret < 0)\n\t\tgoto ov772x_set_fmt_error;\n\n\t \n\tret = ov772x_set_frame_rate(priv, priv->fps, cfmt, win);\n\tif (ret < 0)\n\t\tgoto ov772x_set_fmt_error;\n\n\t \n\tif (priv->band_filter_ctrl->val) {\n\t\tunsigned short band_filter = priv->band_filter_ctrl->val;\n\n\t\tret = regmap_update_bits(priv->regmap, COM8,\n\t\t\t\t\t BNDF_ON_OFF, BNDF_ON_OFF);\n\t\tif (!ret)\n\t\t\tret = regmap_update_bits(priv->regmap, BDBASE,\n\t\t\t\t\t\t 0xff, 256 - band_filter);\n\t\tif (ret < 0)\n\t\t\tgoto ov772x_set_fmt_error;\n\t}\n\n\treturn ret;\n\nov772x_set_fmt_error:\n\n\tov772x_reset(priv);\n\n\treturn ret;\n}\n\nstatic int ov772x_get_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct ov772x_priv *priv = to_ov772x(sd);\n\n\tif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn -EINVAL;\n\n\tsel->r.left = 0;\n\tsel->r.top = 0;\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r.width = priv->win->rect.width;\n\t\tsel->r.height = priv->win->rect.height;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ov772x_get_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tstruct ov772x_priv *priv = to_ov772x(sd);\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tmf->width\t= priv->win->rect.width;\n\tmf->height\t= priv->win->rect.height;\n\tmf->code\t= priv->cfmt->code;\n\tmf->colorspace\t= priv->cfmt->colorspace;\n\tmf->field\t= V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\nstatic int ov772x_set_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct ov772x_priv *priv = to_ov772x(sd);\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tconst struct ov772x_color_format *cfmt;\n\tconst struct ov772x_win_size *win;\n\tint ret = 0;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tov772x_select_params(mf, &cfmt, &win);\n\n\tmf->code = cfmt->code;\n\tmf->width = win->rect.width;\n\tmf->height = win->rect.height;\n\tmf->field = V4L2_FIELD_NONE;\n\tmf->colorspace = cfmt->colorspace;\n\tmf->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tmf->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tmf->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tsd_state->pads->try_fmt = *mf;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&priv->lock);\n\n\tif (priv->streaming) {\n\t\tret = -EBUSY;\n\t\tgoto error;\n\t}\n\n\t \n\tif (priv->power_count > 0) {\n\t\tret = ov772x_set_params(priv, cfmt, win);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\tpriv->win = win;\n\tpriv->cfmt = cfmt;\n\nerror:\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int ov772x_video_probe(struct ov772x_priv *priv)\n{\n\tstruct i2c_client  *client = v4l2_get_subdevdata(&priv->subdev);\n\tint\t\t    pid, ver, midh, midl;\n\tconst char         *devname;\n\tint\t\t    ret;\n\n\tret = ov772x_power_on(priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_read(priv->regmap, PID, &pid);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = regmap_read(priv->regmap, VER, &ver);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (VERSION(pid, ver)) {\n\tcase OV7720:\n\t\tdevname     = \"ov7720\";\n\t\tbreak;\n\tcase OV7725:\n\t\tdevname     = \"ov7725\";\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev,\n\t\t\t\"Product ID error %x:%x\\n\", pid, ver);\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tret = regmap_read(priv->regmap, MIDH, &midh);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = regmap_read(priv->regmap, MIDL, &midl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(&client->dev,\n\t\t \"%s Product ID %0x:%0x Manufacturer ID %x:%x\\n\",\n\t\t devname, pid, ver, midh, midl);\n\n\tret = v4l2_ctrl_handler_setup(&priv->hdl);\n\ndone:\n\tov772x_power_off(priv);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops ov772x_ctrl_ops = {\n\t.s_ctrl = ov772x_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops ov772x_subdev_core_ops = {\n\t.log_status = v4l2_ctrl_subdev_log_status,\n\t.subscribe_event = v4l2_ctrl_subdev_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register\t= ov772x_g_register,\n\t.s_register\t= ov772x_s_register,\n#endif\n\t.s_power\t= ov772x_s_power,\n};\n\nstatic int ov772x_enum_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t\t      struct v4l2_subdev_frame_interval_enum *fie)\n{\n\tif (fie->pad || fie->index >= ARRAY_SIZE(ov772x_frame_intervals))\n\t\treturn -EINVAL;\n\n\tif (fie->width != VGA_WIDTH && fie->width != QVGA_WIDTH)\n\t\treturn -EINVAL;\n\tif (fie->height != VGA_HEIGHT && fie->height != QVGA_HEIGHT)\n\t\treturn -EINVAL;\n\n\tfie->interval.numerator = 1;\n\tfie->interval.denominator = ov772x_frame_intervals[fie->index];\n\n\treturn 0;\n}\n\nstatic int ov772x_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index >= ARRAY_SIZE(ov772x_cfmts))\n\t\treturn -EINVAL;\n\n\tcode->code = ov772x_cfmts[code->index].code;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops ov772x_subdev_video_ops = {\n\t.s_stream\t\t= ov772x_s_stream,\n\t.s_frame_interval\t= ov772x_s_frame_interval,\n\t.g_frame_interval\t= ov772x_g_frame_interval,\n};\n\nstatic const struct v4l2_subdev_pad_ops ov772x_subdev_pad_ops = {\n\t.enum_frame_interval\t= ov772x_enum_frame_interval,\n\t.enum_mbus_code\t\t= ov772x_enum_mbus_code,\n\t.get_selection\t\t= ov772x_get_selection,\n\t.get_fmt\t\t= ov772x_get_fmt,\n\t.set_fmt\t\t= ov772x_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops ov772x_subdev_ops = {\n\t.core\t= &ov772x_subdev_core_ops,\n\t.video\t= &ov772x_subdev_video_ops,\n\t.pad\t= &ov772x_subdev_pad_ops,\n};\n\nstatic int ov772x_parse_dt(struct i2c_client *client,\n\t\t\t   struct ov772x_priv *priv)\n{\n\tstruct v4l2_fwnode_endpoint bus_cfg = {\n\t\t.bus_type = V4L2_MBUS_PARALLEL\n\t};\n\tstruct fwnode_handle *ep;\n\tint ret;\n\n\tep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);\n\tif (!ep) {\n\t\tdev_err(&client->dev, \"Endpoint node not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = v4l2_fwnode_endpoint_alloc_parse(ep, &bus_cfg);\n\tif (ret) {\n\t\tbus_cfg = (struct v4l2_fwnode_endpoint)\n\t\t\t  { .bus_type = V4L2_MBUS_BT656 };\n\t\tret = v4l2_fwnode_endpoint_alloc_parse(ep, &bus_cfg);\n\t\tif (ret)\n\t\t\tgoto error_fwnode_put;\n\t}\n\n\tpriv->bus_type = bus_cfg.bus_type;\n\tv4l2_fwnode_endpoint_free(&bus_cfg);\n\nerror_fwnode_put:\n\tfwnode_handle_put(ep);\n\n\treturn ret;\n}\n\n \n\nstatic int ov772x_probe(struct i2c_client *client)\n{\n\tstruct ov772x_priv\t*priv;\n\tint\t\t\tret;\n\tstatic const struct regmap_config ov772x_regmap_config = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = DSPAUTO,\n\t};\n\n\tif (!client->dev.of_node && !client->dev.platform_data) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Missing ov772x platform data for non-DT device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->regmap = devm_regmap_init_sccb(client, &ov772x_regmap_config);\n\tif (IS_ERR(priv->regmap)) {\n\t\tdev_err(&client->dev, \"Failed to allocate register map\\n\");\n\t\treturn PTR_ERR(priv->regmap);\n\t}\n\n\tpriv->info = client->dev.platform_data;\n\tmutex_init(&priv->lock);\n\n\tv4l2_i2c_subdev_init(&priv->subdev, client, &ov772x_subdev_ops);\n\tpriv->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |\n\t\t\t      V4L2_SUBDEV_FL_HAS_EVENTS;\n\tv4l2_ctrl_handler_init(&priv->hdl, 3);\n\t \n\tpriv->hdl.lock = &priv->lock;\n\tpriv->vflip_ctrl = v4l2_ctrl_new_std(&priv->hdl, &ov772x_ctrl_ops,\n\t\t\t\t\t     V4L2_CID_VFLIP, 0, 1, 1, 0);\n\tpriv->hflip_ctrl = v4l2_ctrl_new_std(&priv->hdl, &ov772x_ctrl_ops,\n\t\t\t\t\t     V4L2_CID_HFLIP, 0, 1, 1, 0);\n\tpriv->band_filter_ctrl = v4l2_ctrl_new_std(&priv->hdl, &ov772x_ctrl_ops,\n\t\t\t\t\t\t   V4L2_CID_BAND_STOP_FILTER,\n\t\t\t\t\t\t   0, 256, 1, 0);\n\tv4l2_ctrl_new_std_menu_items(&priv->hdl, &ov772x_ctrl_ops,\n\t\t\t\t     V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(ov772x_test_pattern_menu) - 1,\n\t\t\t\t     0, 0, ov772x_test_pattern_menu);\n\tpriv->subdev.ctrl_handler = &priv->hdl;\n\tif (priv->hdl.error) {\n\t\tret = priv->hdl.error;\n\t\tgoto error_ctrl_free;\n\t}\n\n\tpriv->clk = clk_get(&client->dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(&client->dev, \"Unable to get xclk clock\\n\");\n\t\tret = PTR_ERR(priv->clk);\n\t\tgoto error_ctrl_free;\n\t}\n\n\tpriv->pwdn_gpio = gpiod_get_optional(&client->dev, \"powerdown\",\n\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->pwdn_gpio)) {\n\t\tdev_info(&client->dev, \"Unable to get GPIO \\\"powerdown\\\"\");\n\t\tret = PTR_ERR(priv->pwdn_gpio);\n\t\tgoto error_clk_put;\n\t}\n\n\tret = ov772x_parse_dt(client, priv);\n\tif (ret)\n\t\tgoto error_clk_put;\n\n\tret = ov772x_video_probe(priv);\n\tif (ret < 0)\n\t\tgoto error_gpio_put;\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tpriv->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tpriv->subdev.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tret = media_entity_pads_init(&priv->subdev.entity, 1, &priv->pad);\n\tif (ret < 0)\n\t\tgoto error_gpio_put;\n#endif\n\n\tpriv->cfmt = &ov772x_cfmts[0];\n\tpriv->win = &ov772x_win_sizes[0];\n\tpriv->fps = 15;\n\n\tret = v4l2_async_register_subdev(&priv->subdev);\n\tif (ret)\n\t\tgoto error_entity_cleanup;\n\n\treturn 0;\n\nerror_entity_cleanup:\n\tmedia_entity_cleanup(&priv->subdev.entity);\nerror_gpio_put:\n\tif (priv->pwdn_gpio)\n\t\tgpiod_put(priv->pwdn_gpio);\nerror_clk_put:\n\tclk_put(priv->clk);\nerror_ctrl_free:\n\tv4l2_ctrl_handler_free(&priv->hdl);\n\tmutex_destroy(&priv->lock);\n\n\treturn ret;\n}\n\nstatic void ov772x_remove(struct i2c_client *client)\n{\n\tstruct ov772x_priv *priv = to_ov772x(i2c_get_clientdata(client));\n\n\tmedia_entity_cleanup(&priv->subdev.entity);\n\tclk_put(priv->clk);\n\tif (priv->pwdn_gpio)\n\t\tgpiod_put(priv->pwdn_gpio);\n\tv4l2_async_unregister_subdev(&priv->subdev);\n\tv4l2_ctrl_handler_free(&priv->hdl);\n\tmutex_destroy(&priv->lock);\n}\n\nstatic const struct i2c_device_id ov772x_id[] = {\n\t{ \"ov772x\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ov772x_id);\n\nstatic const struct of_device_id ov772x_of_match[] = {\n\t{ .compatible = \"ovti,ov7725\", },\n\t{ .compatible = \"ovti,ov7720\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ov772x_of_match);\n\nstatic struct i2c_driver ov772x_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ov772x\",\n\t\t.of_match_table = ov772x_of_match,\n\t},\n\t.probe    = ov772x_probe,\n\t.remove   = ov772x_remove,\n\t.id_table = ov772x_id,\n};\n\nmodule_i2c_driver(ov772x_i2c_driver);\n\nMODULE_DESCRIPTION(\"V4L2 driver for OV772x image sensor\");\nMODULE_AUTHOR(\"Kuninori Morimoto\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}