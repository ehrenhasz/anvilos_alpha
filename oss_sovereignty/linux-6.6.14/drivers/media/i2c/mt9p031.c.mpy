{
  "module_name": "mt9p031.c",
  "hash_id": "ef530be3b64368f48c1571441775c83333118df27eaf0e7a1c77e3f927785d45",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/mt9p031.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/pm.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n\n#include <media/i2c/mt9p031.h>\n#include <media/v4l2-async.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n#include \"aptina-pll.h\"\n\n#define MT9P031_PIXEL_ARRAY_WIDTH\t\t\t2752\n#define MT9P031_PIXEL_ARRAY_HEIGHT\t\t\t2004\n\n#define MT9P031_CHIP_VERSION\t\t\t\t0x00\n#define\t\tMT9P031_CHIP_VERSION_VALUE\t\t0x1801\n#define MT9P031_ROW_START\t\t\t\t0x01\n#define\t\tMT9P031_ROW_START_MIN\t\t\t0\n#define\t\tMT9P031_ROW_START_MAX\t\t\t2004\n#define\t\tMT9P031_ROW_START_DEF\t\t\t54\n#define MT9P031_COLUMN_START\t\t\t\t0x02\n#define\t\tMT9P031_COLUMN_START_MIN\t\t0\n#define\t\tMT9P031_COLUMN_START_MAX\t\t2750\n#define\t\tMT9P031_COLUMN_START_DEF\t\t16\n#define MT9P031_WINDOW_HEIGHT\t\t\t\t0x03\n#define\t\tMT9P031_WINDOW_HEIGHT_MIN\t\t2\n#define\t\tMT9P031_WINDOW_HEIGHT_MAX\t\t2006\n#define\t\tMT9P031_WINDOW_HEIGHT_DEF\t\t1944\n#define MT9P031_WINDOW_WIDTH\t\t\t\t0x04\n#define\t\tMT9P031_WINDOW_WIDTH_MIN\t\t2\n#define\t\tMT9P031_WINDOW_WIDTH_MAX\t\t2752\n#define\t\tMT9P031_WINDOW_WIDTH_DEF\t\t2592\n#define MT9P031_HORIZONTAL_BLANK\t\t\t0x05\n#define\t\tMT9P031_HORIZONTAL_BLANK_MIN\t\t0\n#define\t\tMT9P031_HORIZONTAL_BLANK_MAX\t\t4095\n#define MT9P031_VERTICAL_BLANK\t\t\t\t0x06\n#define\t\tMT9P031_VERTICAL_BLANK_MIN\t\t1\n#define\t\tMT9P031_VERTICAL_BLANK_MAX\t\t4096\n#define\t\tMT9P031_VERTICAL_BLANK_DEF\t\t26\n#define MT9P031_OUTPUT_CONTROL\t\t\t\t0x07\n#define\t\tMT9P031_OUTPUT_CONTROL_CEN\t\t2\n#define\t\tMT9P031_OUTPUT_CONTROL_SYN\t\t1\n#define\t\tMT9P031_OUTPUT_CONTROL_DEF\t\t0x1f82\n#define MT9P031_SHUTTER_WIDTH_UPPER\t\t\t0x08\n#define MT9P031_SHUTTER_WIDTH_LOWER\t\t\t0x09\n#define\t\tMT9P031_SHUTTER_WIDTH_MIN\t\t1\n#define\t\tMT9P031_SHUTTER_WIDTH_MAX\t\t1048575\n#define\t\tMT9P031_SHUTTER_WIDTH_DEF\t\t1943\n#define\tMT9P031_PLL_CONTROL\t\t\t\t0x10\n#define\t\tMT9P031_PLL_CONTROL_PWROFF\t\t0x0050\n#define\t\tMT9P031_PLL_CONTROL_PWRON\t\t0x0051\n#define\t\tMT9P031_PLL_CONTROL_USEPLL\t\t0x0052\n#define\tMT9P031_PLL_CONFIG_1\t\t\t\t0x11\n#define\tMT9P031_PLL_CONFIG_2\t\t\t\t0x12\n#define MT9P031_PIXEL_CLOCK_CONTROL\t\t\t0x0a\n#define\t\tMT9P031_PIXEL_CLOCK_INVERT\t\tBIT(15)\n#define\t\tMT9P031_PIXEL_CLOCK_SHIFT(n)\t\t((n) << 8)\n#define\t\tMT9P031_PIXEL_CLOCK_DIVIDE(n)\t\t((n) << 0)\n#define MT9P031_RESTART\t\t\t\t\t0x0b\n#define\t\tMT9P031_FRAME_PAUSE_RESTART\t\tBIT(1)\n#define\t\tMT9P031_FRAME_RESTART\t\t\tBIT(0)\n#define MT9P031_SHUTTER_DELAY\t\t\t\t0x0c\n#define MT9P031_RST\t\t\t\t\t0x0d\n#define\t\tMT9P031_RST_ENABLE\t\t\tBIT(0)\n#define MT9P031_READ_MODE_1\t\t\t\t0x1e\n#define MT9P031_READ_MODE_2\t\t\t\t0x20\n#define\t\tMT9P031_READ_MODE_2_ROW_MIR\t\tBIT(15)\n#define\t\tMT9P031_READ_MODE_2_COL_MIR\t\tBIT(14)\n#define\t\tMT9P031_READ_MODE_2_ROW_BLC\t\tBIT(6)\n#define MT9P031_ROW_ADDRESS_MODE\t\t\t0x22\n#define MT9P031_COLUMN_ADDRESS_MODE\t\t\t0x23\n#define MT9P031_GLOBAL_GAIN\t\t\t\t0x35\n#define\t\tMT9P031_GLOBAL_GAIN_MIN\t\t\t8\n#define\t\tMT9P031_GLOBAL_GAIN_MAX\t\t\t1024\n#define\t\tMT9P031_GLOBAL_GAIN_DEF\t\t\t8\n#define\t\tMT9P031_GLOBAL_GAIN_MULT\t\tBIT(6)\n#define MT9P031_ROW_BLACK_TARGET\t\t\t0x49\n#define MT9P031_ROW_BLACK_DEF_OFFSET\t\t\t0x4b\n#define MT9P031_GREEN1_OFFSET\t\t\t\t0x60\n#define MT9P031_GREEN2_OFFSET\t\t\t\t0x61\n#define MT9P031_BLACK_LEVEL_CALIBRATION\t\t\t0x62\n#define\t\tMT9P031_BLC_MANUAL_BLC\t\t\tBIT(0)\n#define MT9P031_RED_OFFSET\t\t\t\t0x63\n#define MT9P031_BLUE_OFFSET\t\t\t\t0x64\n#define MT9P031_TEST_PATTERN\t\t\t\t0xa0\n#define\t\tMT9P031_TEST_PATTERN_SHIFT\t\t3\n#define\t\tMT9P031_TEST_PATTERN_ENABLE\t\tBIT(0)\n#define MT9P031_TEST_PATTERN_GREEN\t\t\t0xa1\n#define MT9P031_TEST_PATTERN_RED\t\t\t0xa2\n#define MT9P031_TEST_PATTERN_BLUE\t\t\t0xa3\n\nenum mt9p031_model {\n\tMT9P031_MODEL_COLOR,\n\tMT9P031_MODEL_MONOCHROME,\n};\n\nstruct mt9p031 {\n\tstruct v4l2_subdev subdev;\n\tstruct media_pad pad;\n\tstruct v4l2_rect crop;   \n\tstruct v4l2_mbus_framefmt format;\n\tstruct mt9p031_platform_data *pdata;\n\tstruct mutex power_lock;  \n\tint power_count;\n\n\tstruct clk *clk;\n\tstruct regulator_bulk_data regulators[3];\n\n\tenum mt9p031_model model;\n\tstruct aptina_pll pll;\n\tunsigned int clk_div;\n\tbool use_pll;\n\tstruct gpio_desc *reset;\n\n\tstruct v4l2_ctrl_handler ctrls;\n\tstruct v4l2_ctrl *blc_auto;\n\tstruct v4l2_ctrl *blc_offset;\n\n\t \n\tu16 output_control;\n\tu16 mode2;\n};\n\nstatic struct mt9p031 *to_mt9p031(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct mt9p031, subdev);\n}\n\nstatic int mt9p031_read(struct i2c_client *client, u8 reg)\n{\n\treturn i2c_smbus_read_word_swapped(client, reg);\n}\n\nstatic int mt9p031_write(struct i2c_client *client, u8 reg, u16 data)\n{\n\treturn i2c_smbus_write_word_swapped(client, reg, data);\n}\n\nstatic int mt9p031_set_output_control(struct mt9p031 *mt9p031, u16 clear,\n\t\t\t\t      u16 set)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9p031->subdev);\n\tu16 value = (mt9p031->output_control & ~clear) | set;\n\tint ret;\n\n\tret = mt9p031_write(client, MT9P031_OUTPUT_CONTROL, value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmt9p031->output_control = value;\n\treturn 0;\n}\n\nstatic int mt9p031_set_mode2(struct mt9p031 *mt9p031, u16 clear, u16 set)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9p031->subdev);\n\tu16 value = (mt9p031->mode2 & ~clear) | set;\n\tint ret;\n\n\tret = mt9p031_write(client, MT9P031_READ_MODE_2, value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmt9p031->mode2 = value;\n\treturn 0;\n}\n\nstatic int mt9p031_reset(struct mt9p031 *mt9p031)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9p031->subdev);\n\tint ret;\n\n\t \n\tret = mt9p031_write(client, MT9P031_RST, MT9P031_RST_ENABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = mt9p031_write(client, MT9P031_RST, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mt9p031_write(client, MT9P031_PIXEL_CLOCK_CONTROL,\n\t\t\t    MT9P031_PIXEL_CLOCK_DIVIDE(mt9p031->clk_div));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn mt9p031_set_output_control(mt9p031, MT9P031_OUTPUT_CONTROL_CEN,\n\t\t\t\t\t  0);\n}\n\nstatic int mt9p031_clk_setup(struct mt9p031 *mt9p031)\n{\n\tstatic const struct aptina_pll_limits limits = {\n\t\t.ext_clock_min = 6000000,\n\t\t.ext_clock_max = 27000000,\n\t\t.int_clock_min = 2000000,\n\t\t.int_clock_max = 13500000,\n\t\t.out_clock_min = 180000000,\n\t\t.out_clock_max = 360000000,\n\t\t.pix_clock_max = 96000000,\n\t\t.n_min = 1,\n\t\t.n_max = 64,\n\t\t.m_min = 16,\n\t\t.m_max = 255,\n\t\t.p1_min = 1,\n\t\t.p1_max = 128,\n\t};\n\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9p031->subdev);\n\tstruct mt9p031_platform_data *pdata = mt9p031->pdata;\n\tunsigned long ext_freq;\n\tint ret;\n\n\tmt9p031->clk = devm_clk_get(&client->dev, NULL);\n\tif (IS_ERR(mt9p031->clk))\n\t\treturn PTR_ERR(mt9p031->clk);\n\n\tret = clk_set_rate(mt9p031->clk, pdata->ext_freq);\n\tif (ret < 0)\n\t\treturn ret;\n\n\text_freq = clk_get_rate(mt9p031->clk);\n\n\t \n\tif (ext_freq > limits.ext_clock_max) {\n\t\tunsigned int div;\n\n\t\tdiv = DIV_ROUND_UP(ext_freq, pdata->target_freq);\n\t\tdiv = roundup_pow_of_two(div) / 2;\n\n\t\tmt9p031->clk_div = min_t(unsigned int, div, 64);\n\t\tmt9p031->use_pll = false;\n\n\t\treturn 0;\n\t}\n\n\tmt9p031->pll.ext_clock = ext_freq;\n\tmt9p031->pll.pix_clock = pdata->target_freq;\n\tmt9p031->use_pll = true;\n\n\treturn aptina_pll_calculate(&client->dev, &limits, &mt9p031->pll);\n}\n\nstatic int mt9p031_pll_enable(struct mt9p031 *mt9p031)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9p031->subdev);\n\tint ret;\n\n\tif (!mt9p031->use_pll)\n\t\treturn 0;\n\n\tret = mt9p031_write(client, MT9P031_PLL_CONTROL,\n\t\t\t    MT9P031_PLL_CONTROL_PWRON);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mt9p031_write(client, MT9P031_PLL_CONFIG_1,\n\t\t\t    (mt9p031->pll.m << 8) | (mt9p031->pll.n - 1));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mt9p031_write(client, MT9P031_PLL_CONFIG_2, mt9p031->pll.p1 - 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(1000, 2000);\n\tret = mt9p031_write(client, MT9P031_PLL_CONTROL,\n\t\t\t    MT9P031_PLL_CONTROL_PWRON |\n\t\t\t    MT9P031_PLL_CONTROL_USEPLL);\n\treturn ret;\n}\n\nstatic inline int mt9p031_pll_disable(struct mt9p031 *mt9p031)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9p031->subdev);\n\n\tif (!mt9p031->use_pll)\n\t\treturn 0;\n\n\treturn mt9p031_write(client, MT9P031_PLL_CONTROL,\n\t\t\t     MT9P031_PLL_CONTROL_PWROFF);\n}\n\nstatic int mt9p031_power_on(struct mt9p031 *mt9p031)\n{\n\tunsigned long rate, delay;\n\tint ret;\n\n\t \n\tif (mt9p031->reset) {\n\t\tgpiod_set_value(mt9p031->reset, 1);\n\t\tusleep_range(1000, 2000);\n\t}\n\n\t \n\tret = regulator_bulk_enable(ARRAY_SIZE(mt9p031->regulators),\n\t\t\t\t   mt9p031->regulators);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (mt9p031->clk) {\n\t\tret = clk_prepare_enable(mt9p031->clk);\n\t\tif (ret) {\n\t\t\tregulator_bulk_disable(ARRAY_SIZE(mt9p031->regulators),\n\t\t\t\t\t       mt9p031->regulators);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (mt9p031->reset) {\n\t\tgpiod_set_value(mt9p031->reset, 0);\n\t\t \n\t\trate = clk_get_rate(mt9p031->clk);\n\t\tif (!rate)\n\t\t\trate = 6000000;\t \n\t\tdelay = DIV_ROUND_UP(850000 * 1000, rate);\n\t\tmsleep(delay);\n\t}\n\n\treturn 0;\n}\n\nstatic void mt9p031_power_off(struct mt9p031 *mt9p031)\n{\n\tif (mt9p031->reset) {\n\t\tgpiod_set_value(mt9p031->reset, 1);\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tregulator_bulk_disable(ARRAY_SIZE(mt9p031->regulators),\n\t\t\t       mt9p031->regulators);\n\n\tclk_disable_unprepare(mt9p031->clk);\n}\n\nstatic int __mt9p031_set_power(struct mt9p031 *mt9p031, bool on)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9p031->subdev);\n\tint ret;\n\n\tif (!on) {\n\t\tmt9p031_power_off(mt9p031);\n\t\treturn 0;\n\t}\n\n\tret = mt9p031_power_on(mt9p031);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mt9p031_reset(mt9p031);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to reset the camera\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (mt9p031->pdata && mt9p031->pdata->pixclk_pol) {\n\t\tret = mt9p031_write(client, MT9P031_PIXEL_CLOCK_CONTROL,\n\t\t\t\tMT9P031_PIXEL_CLOCK_INVERT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn v4l2_ctrl_handler_setup(&mt9p031->ctrls);\n}\n\n \n\nstatic int mt9p031_set_params(struct mt9p031 *mt9p031)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9p031->subdev);\n\tstruct v4l2_mbus_framefmt *format = &mt9p031->format;\n\tconst struct v4l2_rect *crop = &mt9p031->crop;\n\tunsigned int hblank;\n\tunsigned int vblank;\n\tunsigned int xskip;\n\tunsigned int yskip;\n\tunsigned int xbin;\n\tunsigned int ybin;\n\tint ret;\n\n\t \n\tret = mt9p031_write(client, MT9P031_COLUMN_START, crop->left);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = mt9p031_write(client, MT9P031_ROW_START, crop->top);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = mt9p031_write(client, MT9P031_WINDOW_WIDTH, crop->width - 1);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = mt9p031_write(client, MT9P031_WINDOW_HEIGHT, crop->height - 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\txskip = DIV_ROUND_CLOSEST(crop->width, format->width);\n\tyskip = DIV_ROUND_CLOSEST(crop->height, format->height);\n\txbin = 1 << (ffs(xskip) - 1);\n\tybin = 1 << (ffs(yskip) - 1);\n\n\tret = mt9p031_write(client, MT9P031_COLUMN_ADDRESS_MODE,\n\t\t\t    ((xbin - 1) << 4) | (xskip - 1));\n\tif (ret < 0)\n\t\treturn ret;\n\tret = mt9p031_write(client, MT9P031_ROW_ADDRESS_MODE,\n\t\t\t    ((ybin - 1) << 4) | (yskip - 1));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\thblank = 346 * ybin + 64 + (80 >> min_t(unsigned int, xbin, 3));\n\tvblank = MT9P031_VERTICAL_BLANK_DEF;\n\n\tret = mt9p031_write(client, MT9P031_HORIZONTAL_BLANK, hblank - 1);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = mt9p031_write(client, MT9P031_VERTICAL_BLANK, vblank - 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic int mt9p031_s_stream(struct v4l2_subdev *subdev, int enable)\n{\n\tstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\n\tstruct i2c_client *client = v4l2_get_subdevdata(subdev);\n\tint val;\n\tint ret;\n\n\tif (!enable) {\n\t\t \n\t\tval = MT9P031_FRAME_PAUSE_RESTART;\n\t\tret = mt9p031_write(client, MT9P031_RESTART, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tval |= MT9P031_FRAME_RESTART;\n\t\tret = mt9p031_write(client, MT9P031_RESTART, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = mt9p031_set_output_control(mt9p031,\n\t\t\t\t\t\t MT9P031_OUTPUT_CONTROL_CEN, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn mt9p031_pll_disable(mt9p031);\n\t}\n\n\tret = mt9p031_set_params(mt9p031);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = mt9p031_set_output_control(mt9p031, 0,\n\t\t\t\t\t MT9P031_OUTPUT_CONTROL_CEN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tval = MT9P031_FRAME_RESTART;\n\tret = mt9p031_write(client, MT9P031_RESTART, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn mt9p031_pll_enable(mt9p031);\n}\n\nstatic int mt9p031_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\n\n\tif (code->pad || code->index)\n\t\treturn -EINVAL;\n\n\tcode->code = mt9p031->format.code;\n\treturn 0;\n}\n\nstatic int mt9p031_enum_frame_size(struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\n\n\tif (fse->index >= 8 || fse->code != mt9p031->format.code)\n\t\treturn -EINVAL;\n\n\tfse->min_width = MT9P031_WINDOW_WIDTH_DEF\n\t\t       / min_t(unsigned int, 7, fse->index + 1);\n\tfse->max_width = fse->min_width;\n\tfse->min_height = MT9P031_WINDOW_HEIGHT_DEF / (fse->index + 1);\n\tfse->max_height = fse->min_height;\n\n\treturn 0;\n}\n\nstatic struct v4l2_mbus_framefmt *\n__mt9p031_get_pad_format(struct mt9p031 *mt9p031,\n\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t unsigned int pad, u32 which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\treturn v4l2_subdev_get_try_format(&mt9p031->subdev, sd_state,\n\t\t\t\t\t\t  pad);\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &mt9p031->format;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic struct v4l2_rect *\n__mt9p031_get_pad_crop(struct mt9p031 *mt9p031,\n\t\t       struct v4l2_subdev_state *sd_state,\n\t\t       unsigned int pad, u32 which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\treturn v4l2_subdev_get_try_crop(&mt9p031->subdev, sd_state,\n\t\t\t\t\t\tpad);\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &mt9p031->crop;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic int mt9p031_get_format(struct v4l2_subdev *subdev,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *fmt)\n{\n\tstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\n\n\tfmt->format = *__mt9p031_get_pad_format(mt9p031, sd_state, fmt->pad,\n\t\t\t\t\t\tfmt->which);\n\treturn 0;\n}\n\nstatic int mt9p031_set_format(struct v4l2_subdev *subdev,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *format)\n{\n\tstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\n\tstruct v4l2_mbus_framefmt *__format;\n\tstruct v4l2_rect *__crop;\n\tunsigned int width;\n\tunsigned int height;\n\tunsigned int hratio;\n\tunsigned int vratio;\n\n\t__crop = __mt9p031_get_pad_crop(mt9p031, sd_state, format->pad,\n\t\t\t\t\tformat->which);\n\n\t \n\twidth = clamp_t(unsigned int, ALIGN(format->format.width, 2),\n\t\t\tmax_t(unsigned int, __crop->width / 7,\n\t\t\t      MT9P031_WINDOW_WIDTH_MIN),\n\t\t\t__crop->width);\n\theight = clamp_t(unsigned int, ALIGN(format->format.height, 2),\n\t\t\t max_t(unsigned int, __crop->height / 8,\n\t\t\t       MT9P031_WINDOW_HEIGHT_MIN),\n\t\t\t __crop->height);\n\n\thratio = DIV_ROUND_CLOSEST(__crop->width, width);\n\tvratio = DIV_ROUND_CLOSEST(__crop->height, height);\n\n\t__format = __mt9p031_get_pad_format(mt9p031, sd_state, format->pad,\n\t\t\t\t\t    format->which);\n\t__format->width = __crop->width / hratio;\n\t__format->height = __crop->height / vratio;\n\n\tformat->format = *__format;\n\n\treturn 0;\n}\n\nstatic int mt9p031_get_selection(struct v4l2_subdev *subdev,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_selection *sel)\n{\n\tstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.left = MT9P031_COLUMN_START_MIN;\n\t\tsel->r.top = MT9P031_ROW_START_MIN;\n\t\tsel->r.width = MT9P031_WINDOW_WIDTH_MAX;\n\t\tsel->r.height = MT9P031_WINDOW_HEIGHT_MAX;\n\t\treturn 0;\n\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = *__mt9p031_get_pad_crop(mt9p031, sd_state,\n\t\t\t\t\t\t sel->pad, sel->which);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mt9p031_set_selection(struct v4l2_subdev *subdev,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_selection *sel)\n{\n\tstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\n\tstruct v4l2_mbus_framefmt *__format;\n\tstruct v4l2_rect *__crop;\n\tstruct v4l2_rect rect;\n\n\tif (sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\t \n\trect.left = clamp(ALIGN(sel->r.left, 2), MT9P031_COLUMN_START_MIN,\n\t\t\t  MT9P031_COLUMN_START_MAX);\n\trect.top = clamp(ALIGN(sel->r.top, 2), MT9P031_ROW_START_MIN,\n\t\t\t MT9P031_ROW_START_MAX);\n\trect.width = clamp_t(unsigned int, ALIGN(sel->r.width, 2),\n\t\t\t     MT9P031_WINDOW_WIDTH_MIN,\n\t\t\t     MT9P031_WINDOW_WIDTH_MAX);\n\trect.height = clamp_t(unsigned int, ALIGN(sel->r.height, 2),\n\t\t\t      MT9P031_WINDOW_HEIGHT_MIN,\n\t\t\t      MT9P031_WINDOW_HEIGHT_MAX);\n\n\trect.width = min_t(unsigned int, rect.width,\n\t\t\t   MT9P031_PIXEL_ARRAY_WIDTH - rect.left);\n\trect.height = min_t(unsigned int, rect.height,\n\t\t\t    MT9P031_PIXEL_ARRAY_HEIGHT - rect.top);\n\n\t__crop = __mt9p031_get_pad_crop(mt9p031, sd_state, sel->pad,\n\t\t\t\t\tsel->which);\n\n\tif (rect.width != __crop->width || rect.height != __crop->height) {\n\t\t \n\t\t__format = __mt9p031_get_pad_format(mt9p031, sd_state,\n\t\t\t\t\t\t    sel->pad,\n\t\t\t\t\t\t    sel->which);\n\t\t__format->width = rect.width;\n\t\t__format->height = rect.height;\n\t}\n\n\t*__crop = rect;\n\tsel->r = rect;\n\n\treturn 0;\n}\n\nstatic int mt9p031_init_cfg(struct v4l2_subdev *subdev,\n\t\t\t    struct v4l2_subdev_state *sd_state)\n{\n\tstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct v4l2_rect *crop;\n\tconst int which = sd_state == NULL ? V4L2_SUBDEV_FORMAT_ACTIVE :\n\t\t\t\t\t     V4L2_SUBDEV_FORMAT_TRY;\n\n\tcrop = __mt9p031_get_pad_crop(mt9p031, sd_state, 0, which);\n\tcrop->left = MT9P031_COLUMN_START_DEF;\n\tcrop->top = MT9P031_ROW_START_DEF;\n\tcrop->width = MT9P031_WINDOW_WIDTH_DEF;\n\tcrop->height = MT9P031_WINDOW_HEIGHT_DEF;\n\n\tformat = __mt9p031_get_pad_format(mt9p031, sd_state, 0, which);\n\n\tif (mt9p031->model == MT9P031_MODEL_MONOCHROME)\n\t\tformat->code = MEDIA_BUS_FMT_Y12_1X12;\n\telse\n\t\tformat->code = MEDIA_BUS_FMT_SGRBG12_1X12;\n\n\tformat->width = MT9P031_WINDOW_WIDTH_DEF;\n\tformat->height = MT9P031_WINDOW_HEIGHT_DEF;\n\tformat->field = V4L2_FIELD_NONE;\n\tformat->colorspace = V4L2_COLORSPACE_SRGB;\n\n\treturn 0;\n}\n\n \n\n#define V4L2_CID_BLC_AUTO\t\t(V4L2_CID_USER_BASE | 0x1002)\n#define V4L2_CID_BLC_TARGET_LEVEL\t(V4L2_CID_USER_BASE | 0x1003)\n#define V4L2_CID_BLC_ANALOG_OFFSET\t(V4L2_CID_USER_BASE | 0x1004)\n#define V4L2_CID_BLC_DIGITAL_OFFSET\t(V4L2_CID_USER_BASE | 0x1005)\n\nstatic int mt9p031_restore_blc(struct mt9p031 *mt9p031)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9p031->subdev);\n\tint ret;\n\n\tif (mt9p031->blc_auto->cur.val != 0) {\n\t\tret = mt9p031_set_mode2(mt9p031, 0,\n\t\t\t\t\tMT9P031_READ_MODE_2_ROW_BLC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (mt9p031->blc_offset->cur.val != 0) {\n\t\tret = mt9p031_write(client, MT9P031_ROW_BLACK_TARGET,\n\t\t\t\t    mt9p031->blc_offset->cur.val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mt9p031_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct mt9p031 *mt9p031 =\n\t\t\tcontainer_of(ctrl->handler, struct mt9p031, ctrls);\n\tstruct i2c_client *client = v4l2_get_subdevdata(&mt9p031->subdev);\n\tu16 data;\n\tint ret;\n\n\tif (ctrl->flags & V4L2_CTRL_FLAG_INACTIVE)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE:\n\t\tret = mt9p031_write(client, MT9P031_SHUTTER_WIDTH_UPPER,\n\t\t\t\t    (ctrl->val >> 16) & 0xffff);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn mt9p031_write(client, MT9P031_SHUTTER_WIDTH_LOWER,\n\t\t\t\t     ctrl->val & 0xffff);\n\n\tcase V4L2_CID_GAIN:\n\t\t \n\t\tif (ctrl->val <= 32) {\n\t\t\tdata = ctrl->val;\n\t\t} else if (ctrl->val <= 64) {\n\t\t\tctrl->val &= ~1;\n\t\t\tdata = (1 << 6) | (ctrl->val >> 1);\n\t\t} else {\n\t\t\tctrl->val &= ~7;\n\t\t\tdata = ((ctrl->val - 64) << 5) | (1 << 6) | 32;\n\t\t}\n\n\t\treturn mt9p031_write(client, MT9P031_GLOBAL_GAIN, data);\n\n\tcase V4L2_CID_HFLIP:\n\t\tif (ctrl->val)\n\t\t\treturn mt9p031_set_mode2(mt9p031,\n\t\t\t\t\t0, MT9P031_READ_MODE_2_COL_MIR);\n\t\telse\n\t\t\treturn mt9p031_set_mode2(mt9p031,\n\t\t\t\t\tMT9P031_READ_MODE_2_COL_MIR, 0);\n\n\tcase V4L2_CID_VFLIP:\n\t\tif (ctrl->val)\n\t\t\treturn mt9p031_set_mode2(mt9p031,\n\t\t\t\t\t0, MT9P031_READ_MODE_2_ROW_MIR);\n\t\telse\n\t\t\treturn mt9p031_set_mode2(mt9p031,\n\t\t\t\t\tMT9P031_READ_MODE_2_ROW_MIR, 0);\n\n\tcase V4L2_CID_TEST_PATTERN:\n\t\t \n\t\tv4l2_ctrl_activate(mt9p031->blc_auto, ctrl->val == 0);\n\t\tv4l2_ctrl_activate(mt9p031->blc_offset, ctrl->val == 0);\n\n\t\tif (!ctrl->val) {\n\t\t\t \n\t\t\tret = mt9p031_restore_blc(mt9p031);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\treturn mt9p031_write(client, MT9P031_TEST_PATTERN, 0);\n\t\t}\n\n\t\tret = mt9p031_write(client, MT9P031_TEST_PATTERN_GREEN, 0x05a0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = mt9p031_write(client, MT9P031_TEST_PATTERN_RED, 0x0a50);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = mt9p031_write(client, MT9P031_TEST_PATTERN_BLUE, 0x0aa0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = mt9p031_set_mode2(mt9p031, MT9P031_READ_MODE_2_ROW_BLC,\n\t\t\t\t\t0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = mt9p031_write(client, MT9P031_ROW_BLACK_DEF_OFFSET, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn mt9p031_write(client, MT9P031_TEST_PATTERN,\n\t\t\t\t((ctrl->val - 1) << MT9P031_TEST_PATTERN_SHIFT)\n\t\t\t\t| MT9P031_TEST_PATTERN_ENABLE);\n\n\tcase V4L2_CID_BLC_AUTO:\n\t\tret = mt9p031_set_mode2(mt9p031,\n\t\t\t\tctrl->val ? 0 : MT9P031_READ_MODE_2_ROW_BLC,\n\t\t\t\tctrl->val ? MT9P031_READ_MODE_2_ROW_BLC : 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn mt9p031_write(client, MT9P031_BLACK_LEVEL_CALIBRATION,\n\t\t\t\t     ctrl->val ? 0 : MT9P031_BLC_MANUAL_BLC);\n\n\tcase V4L2_CID_BLC_TARGET_LEVEL:\n\t\treturn mt9p031_write(client, MT9P031_ROW_BLACK_TARGET,\n\t\t\t\t     ctrl->val);\n\n\tcase V4L2_CID_BLC_ANALOG_OFFSET:\n\t\tdata = ctrl->val & ((1 << 9) - 1);\n\n\t\tret = mt9p031_write(client, MT9P031_GREEN1_OFFSET, data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = mt9p031_write(client, MT9P031_GREEN2_OFFSET, data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = mt9p031_write(client, MT9P031_RED_OFFSET, data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn mt9p031_write(client, MT9P031_BLUE_OFFSET, data);\n\n\tcase V4L2_CID_BLC_DIGITAL_OFFSET:\n\t\treturn mt9p031_write(client, MT9P031_ROW_BLACK_DEF_OFFSET,\n\t\t\t\t     ctrl->val & ((1 << 12) - 1));\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops mt9p031_ctrl_ops = {\n\t.s_ctrl = mt9p031_s_ctrl,\n};\n\nstatic const char * const mt9p031_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Color Field\",\n\t\"Horizontal Gradient\",\n\t\"Vertical Gradient\",\n\t\"Diagonal Gradient\",\n\t\"Classic Test Pattern\",\n\t\"Walking 1s\",\n\t\"Monochrome Horizontal Bars\",\n\t\"Monochrome Vertical Bars\",\n\t\"Vertical Color Bars\",\n};\n\nstatic const struct v4l2_ctrl_config mt9p031_ctrls[] = {\n\t{\n\t\t.ops\t\t= &mt9p031_ctrl_ops,\n\t\t.id\t\t= V4L2_CID_BLC_AUTO,\n\t\t.type\t\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.name\t\t= \"BLC, Auto\",\n\t\t.min\t\t= 0,\n\t\t.max\t\t= 1,\n\t\t.step\t\t= 1,\n\t\t.def\t\t= 1,\n\t\t.flags\t\t= 0,\n\t}, {\n\t\t.ops\t\t= &mt9p031_ctrl_ops,\n\t\t.id\t\t= V4L2_CID_BLC_TARGET_LEVEL,\n\t\t.type\t\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.name\t\t= \"BLC Target Level\",\n\t\t.min\t\t= 0,\n\t\t.max\t\t= 4095,\n\t\t.step\t\t= 1,\n\t\t.def\t\t= 168,\n\t\t.flags\t\t= 0,\n\t}, {\n\t\t.ops\t\t= &mt9p031_ctrl_ops,\n\t\t.id\t\t= V4L2_CID_BLC_ANALOG_OFFSET,\n\t\t.type\t\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.name\t\t= \"BLC Analog Offset\",\n\t\t.min\t\t= -255,\n\t\t.max\t\t= 255,\n\t\t.step\t\t= 1,\n\t\t.def\t\t= 32,\n\t\t.flags\t\t= 0,\n\t}, {\n\t\t.ops\t\t= &mt9p031_ctrl_ops,\n\t\t.id\t\t= V4L2_CID_BLC_DIGITAL_OFFSET,\n\t\t.type\t\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.name\t\t= \"BLC Digital Offset\",\n\t\t.min\t\t= -2048,\n\t\t.max\t\t= 2047,\n\t\t.step\t\t= 1,\n\t\t.def\t\t= 40,\n\t\t.flags\t\t= 0,\n\t}\n};\n\n \n\nstatic int mt9p031_set_power(struct v4l2_subdev *subdev, int on)\n{\n\tstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\n\tint ret = 0;\n\n\tmutex_lock(&mt9p031->power_lock);\n\n\t \n\tif (mt9p031->power_count == !on) {\n\t\tret = __mt9p031_set_power(mt9p031, !!on);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tmt9p031->power_count += on ? 1 : -1;\n\tWARN_ON(mt9p031->power_count < 0);\n\nout:\n\tmutex_unlock(&mt9p031->power_lock);\n\treturn ret;\n}\n\n \n\nstatic int mt9p031_registered(struct v4l2_subdev *subdev)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(subdev);\n\tstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\n\ts32 data;\n\tint ret;\n\n\tret = mt9p031_power_on(mt9p031);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"MT9P031 power up failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tdata = mt9p031_read(client, MT9P031_CHIP_VERSION);\n\tmt9p031_power_off(mt9p031);\n\n\tif (data != MT9P031_CHIP_VERSION_VALUE) {\n\t\tdev_err(&client->dev, \"MT9P031 not detected, wrong version \"\n\t\t\t\"0x%04x\\n\", data);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(&client->dev, \"MT9P031 detected at address 0x%02x\\n\",\n\t\t client->addr);\n\n\treturn 0;\n}\n\nstatic int mt9p031_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)\n{\n\treturn mt9p031_set_power(subdev, 1);\n}\n\nstatic int mt9p031_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)\n{\n\treturn mt9p031_set_power(subdev, 0);\n}\n\nstatic const struct v4l2_subdev_core_ops mt9p031_subdev_core_ops = {\n\t.s_power        = mt9p031_set_power,\n};\n\nstatic const struct v4l2_subdev_video_ops mt9p031_subdev_video_ops = {\n\t.s_stream       = mt9p031_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops mt9p031_subdev_pad_ops = {\n\t.init_cfg = mt9p031_init_cfg,\n\t.enum_mbus_code = mt9p031_enum_mbus_code,\n\t.enum_frame_size = mt9p031_enum_frame_size,\n\t.get_fmt = mt9p031_get_format,\n\t.set_fmt = mt9p031_set_format,\n\t.get_selection = mt9p031_get_selection,\n\t.set_selection = mt9p031_set_selection,\n};\n\nstatic const struct v4l2_subdev_ops mt9p031_subdev_ops = {\n\t.core   = &mt9p031_subdev_core_ops,\n\t.video  = &mt9p031_subdev_video_ops,\n\t.pad    = &mt9p031_subdev_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops mt9p031_subdev_internal_ops = {\n\t.registered = mt9p031_registered,\n\t.open = mt9p031_open,\n\t.close = mt9p031_close,\n};\n\n \n\nstatic struct mt9p031_platform_data *\nmt9p031_get_pdata(struct i2c_client *client)\n{\n\tstruct mt9p031_platform_data *pdata = NULL;\n\tstruct device_node *np;\n\tstruct v4l2_fwnode_endpoint endpoint = {\n\t\t.bus_type = V4L2_MBUS_PARALLEL\n\t};\n\n\tif (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)\n\t\treturn client->dev.platform_data;\n\n\tnp = of_graph_get_next_endpoint(client->dev.of_node, NULL);\n\tif (!np)\n\t\treturn NULL;\n\n\tif (v4l2_fwnode_endpoint_parse(of_fwnode_handle(np), &endpoint) < 0)\n\t\tgoto done;\n\n\tpdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\tgoto done;\n\n\tof_property_read_u32(np, \"input-clock-frequency\", &pdata->ext_freq);\n\tof_property_read_u32(np, \"pixel-clock-frequency\", &pdata->target_freq);\n\n\tpdata->pixclk_pol = !!(endpoint.bus.parallel.flags &\n\t\t\t       V4L2_MBUS_PCLK_SAMPLE_RISING);\n\ndone:\n\tof_node_put(np);\n\treturn pdata;\n}\n\nstatic int mt9p031_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *did = i2c_client_get_device_id(client);\n\tstruct mt9p031_platform_data *pdata = mt9p031_get_pdata(client);\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct mt9p031 *mt9p031;\n\tunsigned int i;\n\tint ret;\n\n\tif (pdata == NULL) {\n\t\tdev_err(&client->dev, \"No platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA)) {\n\t\tdev_warn(&client->dev,\n\t\t\t\"I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmt9p031 = devm_kzalloc(&client->dev, sizeof(*mt9p031), GFP_KERNEL);\n\tif (mt9p031 == NULL)\n\t\treturn -ENOMEM;\n\n\tmt9p031->pdata = pdata;\n\tmt9p031->output_control\t= MT9P031_OUTPUT_CONTROL_DEF;\n\tmt9p031->mode2 = MT9P031_READ_MODE_2_ROW_BLC;\n\tmt9p031->model = did->driver_data;\n\n\tmt9p031->regulators[0].supply = \"vdd\";\n\tmt9p031->regulators[1].supply = \"vdd_io\";\n\tmt9p031->regulators[2].supply = \"vaa\";\n\n\tret = devm_regulator_bulk_get(&client->dev, 3, mt9p031->regulators);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Unable to get regulators\\n\");\n\t\treturn ret;\n\t}\n\n\tmutex_init(&mt9p031->power_lock);\n\n\tv4l2_ctrl_handler_init(&mt9p031->ctrls, ARRAY_SIZE(mt9p031_ctrls) + 6);\n\n\tv4l2_ctrl_new_std(&mt9p031->ctrls, &mt9p031_ctrl_ops,\n\t\t\t  V4L2_CID_EXPOSURE, MT9P031_SHUTTER_WIDTH_MIN,\n\t\t\t  MT9P031_SHUTTER_WIDTH_MAX, 1,\n\t\t\t  MT9P031_SHUTTER_WIDTH_DEF);\n\tv4l2_ctrl_new_std(&mt9p031->ctrls, &mt9p031_ctrl_ops,\n\t\t\t  V4L2_CID_GAIN, MT9P031_GLOBAL_GAIN_MIN,\n\t\t\t  MT9P031_GLOBAL_GAIN_MAX, 1, MT9P031_GLOBAL_GAIN_DEF);\n\tv4l2_ctrl_new_std(&mt9p031->ctrls, &mt9p031_ctrl_ops,\n\t\t\t  V4L2_CID_HFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(&mt9p031->ctrls, &mt9p031_ctrl_ops,\n\t\t\t  V4L2_CID_VFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(&mt9p031->ctrls, &mt9p031_ctrl_ops,\n\t\t\t  V4L2_CID_PIXEL_RATE, pdata->target_freq,\n\t\t\t  pdata->target_freq, 1, pdata->target_freq);\n\tv4l2_ctrl_new_std_menu_items(&mt9p031->ctrls, &mt9p031_ctrl_ops,\n\t\t\t  V4L2_CID_TEST_PATTERN,\n\t\t\t  ARRAY_SIZE(mt9p031_test_pattern_menu) - 1, 0,\n\t\t\t  0, mt9p031_test_pattern_menu);\n\n\tfor (i = 0; i < ARRAY_SIZE(mt9p031_ctrls); ++i)\n\t\tv4l2_ctrl_new_custom(&mt9p031->ctrls, &mt9p031_ctrls[i], NULL);\n\n\tmt9p031->subdev.ctrl_handler = &mt9p031->ctrls;\n\n\tif (mt9p031->ctrls.error) {\n\t\tprintk(KERN_INFO \"%s: control initialization error %d\\n\",\n\t\t       __func__, mt9p031->ctrls.error);\n\t\tret = mt9p031->ctrls.error;\n\t\tgoto done;\n\t}\n\n\tmt9p031->blc_auto = v4l2_ctrl_find(&mt9p031->ctrls, V4L2_CID_BLC_AUTO);\n\tmt9p031->blc_offset = v4l2_ctrl_find(&mt9p031->ctrls,\n\t\t\t\t\t     V4L2_CID_BLC_DIGITAL_OFFSET);\n\n\tv4l2_i2c_subdev_init(&mt9p031->subdev, client, &mt9p031_subdev_ops);\n\tmt9p031->subdev.internal_ops = &mt9p031_subdev_internal_ops;\n\n\tmt9p031->subdev.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tmt9p031->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tret = media_entity_pads_init(&mt9p031->subdev.entity, 1, &mt9p031->pad);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tmt9p031->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tret = mt9p031_init_cfg(&mt9p031->subdev, NULL);\n\tif (ret)\n\t\tgoto done;\n\n\tmt9p031->reset = devm_gpiod_get_optional(&client->dev, \"reset\",\n\t\t\t\t\t\t GPIOD_OUT_HIGH);\n\n\tret = mt9p031_clk_setup(mt9p031);\n\tif (ret)\n\t\tgoto done;\n\n\tret = v4l2_async_register_subdev(&mt9p031->subdev);\n\ndone:\n\tif (ret < 0) {\n\t\tv4l2_ctrl_handler_free(&mt9p031->ctrls);\n\t\tmedia_entity_cleanup(&mt9p031->subdev.entity);\n\t\tmutex_destroy(&mt9p031->power_lock);\n\t}\n\n\treturn ret;\n}\n\nstatic void mt9p031_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct mt9p031 *mt9p031 = to_mt9p031(subdev);\n\n\tv4l2_ctrl_handler_free(&mt9p031->ctrls);\n\tv4l2_async_unregister_subdev(subdev);\n\tmedia_entity_cleanup(&subdev->entity);\n\tmutex_destroy(&mt9p031->power_lock);\n}\n\nstatic const struct i2c_device_id mt9p031_id[] = {\n\t{ \"mt9p006\", MT9P031_MODEL_COLOR },\n\t{ \"mt9p031\", MT9P031_MODEL_COLOR },\n\t{ \"mt9p031m\", MT9P031_MODEL_MONOCHROME },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, mt9p031_id);\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id mt9p031_of_match[] = {\n\t{ .compatible = \"aptina,mt9p006\", },\n\t{ .compatible = \"aptina,mt9p031\", },\n\t{ .compatible = \"aptina,mt9p031m\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, mt9p031_of_match);\n#endif\n\nstatic struct i2c_driver mt9p031_i2c_driver = {\n\t.driver = {\n\t\t.of_match_table = of_match_ptr(mt9p031_of_match),\n\t\t.name = \"mt9p031\",\n\t},\n\t.probe          = mt9p031_probe,\n\t.remove         = mt9p031_remove,\n\t.id_table       = mt9p031_id,\n};\n\nmodule_i2c_driver(mt9p031_i2c_driver);\n\nMODULE_DESCRIPTION(\"Aptina MT9P031 Camera driver\");\nMODULE_AUTHOR(\"Bastian Hecht <hechtb@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}