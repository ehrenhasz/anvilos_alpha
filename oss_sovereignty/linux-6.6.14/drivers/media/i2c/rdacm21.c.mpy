{
  "module_name": "rdacm21.c",
  "hash_id": "0fa01f25c3a5dd2daa5011c26e8a64f61137aba03de5f0cce7f05f0c132eaa39",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/rdacm21.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/fwnode.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-async.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-subdev.h>\n#include \"max9271.h\"\n\n#define MAX9271_RESET_CYCLES\t\t10\n\n#define OV490_I2C_ADDRESS\t\t0x24\n\n#define OV490_PAGE_HIGH_REG\t\t0xfffd\n#define OV490_PAGE_LOW_REG\t\t0xfffe\n\n \n#define OV490_SCCB_SLAVE_WRITE\t\t0x00\n#define OV490_SCCB_SLAVE_READ\t\t0x01\n#define OV490_SCCB_SLAVE0_DIR\t\t0x80195000\n#define OV490_SCCB_SLAVE0_ADDR_HIGH\t0x80195001\n#define OV490_SCCB_SLAVE0_ADDR_LOW\t0x80195002\n\n#define OV490_DVP_CTRL3\t\t\t0x80286009\n\n#define OV490_ODS_CTRL_FRAME_OUTPUT_EN\t0x0c\n#define OV490_ODS_CTRL\t\t\t0x8029d000\n\n#define OV490_HOST_CMD\t\t\t0x808000c0\n#define OV490_HOST_CMD_TRIGGER\t\t0xc1\n\n#define OV490_ID_VAL\t\t\t0x0490\n#define OV490_ID(_p, _v)\t\t((((_p) & 0xff) << 8) | ((_v) & 0xff))\n#define OV490_PID\t\t\t0x8080300a\n#define OV490_VER\t\t\t0x8080300b\n#define OV490_PID_TIMEOUT\t\t20\n#define OV490_OUTPUT_EN_TIMEOUT\t\t300\n\n#define OV490_GPIO0\t\t\tBIT(0)\n#define OV490_SPWDN0\t\t\tBIT(0)\n#define OV490_GPIO_SEL0\t\t\t0x80800050\n#define OV490_GPIO_SEL1\t\t\t0x80800051\n#define OV490_GPIO_DIRECTION0\t\t0x80800054\n#define OV490_GPIO_DIRECTION1\t\t0x80800055\n#define OV490_GPIO_OUTPUT_VALUE0\t0x80800058\n#define OV490_GPIO_OUTPUT_VALUE1\t0x80800059\n\n#define OV490_ISP_HSIZE_LOW\t\t0x80820060\n#define OV490_ISP_HSIZE_HIGH\t\t0x80820061\n#define OV490_ISP_VSIZE_LOW\t\t0x80820062\n#define OV490_ISP_VSIZE_HIGH\t\t0x80820063\n\n#define OV10640_PID_TIMEOUT\t\t20\n#define OV10640_ID_HIGH\t\t\t0xa6\n#define OV10640_CHIP_ID\t\t\t0x300a\n#define OV10640_PIXEL_RATE\t\t55000000\n\nstruct rdacm21_device {\n\tstruct device\t\t\t*dev;\n\tstruct max9271_device\t\tserializer;\n\tstruct i2c_client\t\t*isp;\n\tstruct v4l2_subdev\t\tsd;\n\tstruct media_pad\t\tpad;\n\tstruct v4l2_mbus_framefmt\tfmt;\n\tstruct v4l2_ctrl_handler\tctrls;\n\tu32\t\t\t\taddrs[2];\n\tu16\t\t\t\tlast_page;\n};\n\nstatic inline struct rdacm21_device *sd_to_rdacm21(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct rdacm21_device, sd);\n}\n\nstatic const struct ov490_reg {\n\tu16 reg;\n\tu8 val;\n} ov490_regs_wizard[] = {\n\t{0xfffd, 0x80},\n\t{0xfffe, 0x82},\n\t{0x0071, 0x11},\n\t{0x0075, 0x11},\n\t{0xfffe, 0x29},\n\t{0x6010, 0x01},\n\t \n\t{0xe000, 0x14},\n\t{0xfffe, 0x28},\n\t{0x6000, 0x04},\n\t{0x6004, 0x00},\n\t \n\t{0x6008, 0x00},\n\t{0xfffe, 0x80},\n\t{0x0091, 0x00},\n\t \n\t{0x00bb, 0x1d},\n\t \n\t{0xfffe, 0x85},\n\t{0x0008, 0x00},\n\t{0x0009, 0x01},\n\t \n\t{0x000A, 0x05},\n\t{0x000B, 0x00},\n\t \n\t{0x0030, 0x02},\n\t{0x0031, 0x00},\n\t{0x0032, 0x00},\n\t{0x0033, 0x00},\n\t \n\t{0x0038, 0x02},\n\t{0x0039, 0x00},\n\t{0x003A, 0x00},\n\t{0x003B, 0x00},\n\t \n\t{0x0070, 0x2C},\n\t{0x0071, 0x01},\n\t{0x0072, 0x00},\n\t{0x0073, 0x00},\n\t \n\t{0x0074, 0x64},\n\t{0x0075, 0x00},\n\t{0x0076, 0x00},\n\t{0x0077, 0x00},\n\t{0x0000, 0x14},\n\t{0x0001, 0x00},\n\t{0x0002, 0x00},\n\t{0x0003, 0x00},\n\t \n\t{0x0004, 0x32},\n\t{0x0005, 0x00},\n\t{0x0006, 0x00},\n\t{0x0007, 0x00},\n\t{0xfffe, 0x80},\n\t \n\t{0x0081, 0x00},\n\t \n\t{0xfffe, 0x19},\n\t{0x5000, 0x00},\n\t{0x5001, 0x30},\n\t{0x5002, 0x8c},\n\t{0x5003, 0xb2},\n\t{0xfffe, 0x80},\n\t{0x00c0, 0xc1},\n\t \n\t{0xfffe, 0x19},\n\t{0x5000, 0x01},\n\t{0x5001, 0x00},\n\t{0xfffe, 0x80},\n\t{0x00c0, 0xdc},\n};\n\nstatic int ov490_read(struct rdacm21_device *dev, u16 reg, u8 *val)\n{\n\tu8 buf[2] = { reg >> 8, reg };\n\tint ret;\n\n\tret = i2c_master_send(dev->isp, buf, 2);\n\tif (ret == 2)\n\t\tret = i2c_master_recv(dev->isp, val, 1);\n\n\tif (ret < 0) {\n\t\tdev_dbg(dev->dev, \"%s: register 0x%04x read failed (%d)\\n\",\n\t\t\t__func__, reg, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov490_write(struct rdacm21_device *dev, u16 reg, u8 val)\n{\n\tu8 buf[3] = { reg >> 8, reg, val };\n\tint ret;\n\n\tret = i2c_master_send(dev->isp, buf, 3);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev, \"%s: register 0x%04x write failed (%d)\\n\",\n\t\t\t__func__, reg, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov490_set_page(struct rdacm21_device *dev, u16 page)\n{\n\tu8 page_high = page >> 8;\n\tu8 page_low = page;\n\tint ret;\n\n\tif (page == dev->last_page)\n\t\treturn 0;\n\n\tif (page_high != (dev->last_page >> 8)) {\n\t\tret = ov490_write(dev, OV490_PAGE_HIGH_REG, page_high);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (page_low != (u8)dev->last_page) {\n\t\tret = ov490_write(dev, OV490_PAGE_LOW_REG, page_low);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdev->last_page = page;\n\tusleep_range(100, 150);\n\n\treturn 0;\n}\n\nstatic int ov490_read_reg(struct rdacm21_device *dev, u32 reg, u8 *val)\n{\n\tint ret;\n\n\tret = ov490_set_page(dev, reg >> 16);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov490_read(dev, (u16)reg, val);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(dev->dev, \"%s: 0x%08x = 0x%02x\\n\", __func__, reg, *val);\n\n\treturn 0;\n}\n\nstatic int ov490_write_reg(struct rdacm21_device *dev, u32 reg, u8 val)\n{\n\tint ret;\n\n\tret = ov490_set_page(dev, reg >> 16);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov490_write(dev, (u16)reg, val);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(dev->dev, \"%s: 0x%08x = 0x%02x\\n\", __func__, reg, val);\n\n\treturn 0;\n}\n\nstatic int rdacm21_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct rdacm21_device *dev = sd_to_rdacm21(sd);\n\n\t \n\treturn max9271_set_serial_link(&dev->serializer, enable);\n}\n\nstatic int rdacm21_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index > 0)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_YUYV8_1X16;\n\n\treturn 0;\n}\n\nstatic int rdacm21_get_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tstruct rdacm21_device *dev = sd_to_rdacm21(sd);\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tmf->width\t\t= dev->fmt.width;\n\tmf->height\t\t= dev->fmt.height;\n\tmf->code\t\t= MEDIA_BUS_FMT_YUYV8_1X16;\n\tmf->colorspace\t\t= V4L2_COLORSPACE_SRGB;\n\tmf->field\t\t= V4L2_FIELD_NONE;\n\tmf->ycbcr_enc\t\t= V4L2_YCBCR_ENC_601;\n\tmf->quantization\t= V4L2_QUANTIZATION_FULL_RANGE;\n\tmf->xfer_func\t\t= V4L2_XFER_FUNC_NONE;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops rdacm21_video_ops = {\n\t.s_stream\t= rdacm21_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops rdacm21_subdev_pad_ops = {\n\t.enum_mbus_code = rdacm21_enum_mbus_code,\n\t.get_fmt\t= rdacm21_get_fmt,\n\t.set_fmt\t= rdacm21_get_fmt,\n};\n\nstatic const struct v4l2_subdev_ops rdacm21_subdev_ops = {\n\t.video\t\t= &rdacm21_video_ops,\n\t.pad\t\t= &rdacm21_subdev_pad_ops,\n};\n\nstatic void ov10640_power_up(struct rdacm21_device *dev)\n{\n\t \n\tov490_write_reg(dev, OV490_GPIO_SEL0, OV490_GPIO0);\n\tov490_write_reg(dev, OV490_GPIO_SEL1, OV490_SPWDN0);\n\tov490_write_reg(dev, OV490_GPIO_DIRECTION0, OV490_GPIO0);\n\tov490_write_reg(dev, OV490_GPIO_DIRECTION1, OV490_SPWDN0);\n\n\t \n\tov490_write_reg(dev, OV490_GPIO_OUTPUT_VALUE1, OV490_SPWDN0);\n\tusleep_range(1500, 3000);\n\n\tov490_write_reg(dev, OV490_GPIO_OUTPUT_VALUE0, 0x00);\n\tusleep_range(1500, 3000);\n\tov490_write_reg(dev, OV490_GPIO_OUTPUT_VALUE0, OV490_GPIO0);\n\tusleep_range(3000, 5000);\n}\n\nstatic int ov10640_check_id(struct rdacm21_device *dev)\n{\n\tunsigned int i;\n\tu8 val = 0;\n\n\t \n\tfor (i = 0; i < OV10640_PID_TIMEOUT; ++i) {\n\t\tov490_write_reg(dev, OV490_SCCB_SLAVE0_DIR,\n\t\t\t\tOV490_SCCB_SLAVE_READ);\n\t\tov490_write_reg(dev, OV490_SCCB_SLAVE0_ADDR_HIGH,\n\t\t\t\tOV10640_CHIP_ID >> 8);\n\t\tov490_write_reg(dev, OV490_SCCB_SLAVE0_ADDR_LOW,\n\t\t\t\tOV10640_CHIP_ID & 0xff);\n\n\t\t \n\t\tov490_write_reg(dev, OV490_HOST_CMD, OV490_HOST_CMD_TRIGGER);\n\t\tusleep_range(1000, 1500);\n\n\t\tov490_read_reg(dev, OV490_SCCB_SLAVE0_DIR, &val);\n\t\tif (val == OV10640_ID_HIGH)\n\t\t\tbreak;\n\t\tusleep_range(1000, 1500);\n\t}\n\tif (i == OV10640_PID_TIMEOUT) {\n\t\tdev_err(dev->dev, \"OV10640 ID mismatch: (0x%02x)\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(dev->dev, \"OV10640 ID = 0x%2x\\n\", val);\n\n\treturn 0;\n}\n\nstatic int ov490_initialize(struct rdacm21_device *dev)\n{\n\tu8 pid, ver, val;\n\tunsigned int i;\n\tint ret;\n\n\tov10640_power_up(dev);\n\n\t \n\tfor (i = 0; i < OV490_PID_TIMEOUT; ++i) {\n\t\tret = ov490_read_reg(dev, OV490_PID, &pid);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\tif (i == OV490_PID_TIMEOUT) {\n\t\tdev_err(dev->dev, \"OV490 PID read failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ov490_read_reg(dev, OV490_VER, &ver);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (OV490_ID(pid, ver) != OV490_ID_VAL) {\n\t\tdev_err(dev->dev, \"OV490 ID mismatch (0x%04x)\\n\",\n\t\t\tOV490_ID(pid, ver));\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tfor (i = 0; i < OV490_OUTPUT_EN_TIMEOUT; ++i) {\n\t\tov490_read_reg(dev, OV490_ODS_CTRL, &val);\n\t\tif (val == OV490_ODS_CTRL_FRAME_OUTPUT_EN)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\tif (i == OV490_OUTPUT_EN_TIMEOUT) {\n\t\tdev_err(dev->dev, \"Timeout waiting for firmware boot\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = ov10640_check_id(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ov490_regs_wizard); ++i) {\n\t\tret = ov490_write(dev, ov490_regs_wizard[i].reg,\n\t\t\t\t  ov490_regs_wizard[i].val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"%s: register %u (0x%04x) write failed (%d)\\n\",\n\t\t\t\t__func__, i, ov490_regs_wizard[i].reg, ret);\n\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tusleep_range(100, 150);\n\t}\n\n\t \n\tov490_read_reg(dev, OV490_ISP_HSIZE_HIGH, &val);\n\tdev->fmt.width = (val & 0xf) << 8;\n\tov490_read_reg(dev, OV490_ISP_HSIZE_LOW, &val);\n\tdev->fmt.width |= (val & 0xff);\n\n\tov490_read_reg(dev, OV490_ISP_VSIZE_HIGH, &val);\n\tdev->fmt.height = (val & 0xf) << 8;\n\tov490_read_reg(dev, OV490_ISP_VSIZE_LOW, &val);\n\tdev->fmt.height |= val & 0xff;\n\n\t \n\tov490_write_reg(dev, OV490_DVP_CTRL3, 0x10);\n\n\tdev_info(dev->dev, \"Identified RDACM21 camera module\\n\");\n\n\treturn 0;\n}\n\nstatic int rdacm21_initialize(struct rdacm21_device *dev)\n{\n\tint ret;\n\n\tmax9271_wake_up(&dev->serializer);\n\n\t \n\tret = max9271_set_serial_link(&dev->serializer, false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = max9271_configure_i2c(&dev->serializer,\n\t\t\t\t    MAX9271_I2CSLVSH_469NS_234NS |\n\t\t\t\t    MAX9271_I2CSLVTO_1024US |\n\t\t\t\t    MAX9271_I2CMSTBT_105KBPS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = max9271_verify_id(&dev->serializer);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = max9271_enable_gpios(&dev->serializer, MAX9271_GPIO1OUT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = max9271_clear_gpios(&dev->serializer, MAX9271_GPIO1OUT);\n\tif (ret)\n\t\treturn ret;\n\tusleep_range(250, 500);\n\n\tret = max9271_configure_gmsl_link(&dev->serializer);\n\tif (ret)\n\t\treturn ret;\n\n\tret = max9271_set_address(&dev->serializer, dev->addrs[0]);\n\tif (ret)\n\t\treturn ret;\n\tdev->serializer.client->addr = dev->addrs[0];\n\n\tret = max9271_set_translation(&dev->serializer, dev->addrs[1],\n\t\t\t\t      OV490_I2C_ADDRESS);\n\tif (ret)\n\t\treturn ret;\n\tdev->isp->addr = dev->addrs[1];\n\n\t \n\tret = max9271_set_gpios(&dev->serializer, MAX9271_GPIO1OUT);\n\tif (ret)\n\t\treturn ret;\n\tusleep_range(3000, 5000);\n\n\tret = ov490_initialize(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn max9271_set_high_threshold(&dev->serializer, true);\n}\n\nstatic int rdacm21_probe(struct i2c_client *client)\n{\n\tstruct rdacm21_device *dev;\n\tint ret;\n\n\tdev = devm_kzalloc(&client->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->dev = &client->dev;\n\tdev->serializer.client = client;\n\n\tret = of_property_read_u32_array(client->dev.of_node, \"reg\",\n\t\t\t\t\t dev->addrs, 2);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev, \"Invalid DT reg property: %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdev->isp = i2c_new_dummy_device(client->adapter, OV490_I2C_ADDRESS);\n\tif (IS_ERR(dev->isp))\n\t\treturn PTR_ERR(dev->isp);\n\n\tret = rdacm21_initialize(dev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tv4l2_i2c_subdev_init(&dev->sd, client, &rdacm21_subdev_ops);\n\tdev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tv4l2_ctrl_handler_init(&dev->ctrls, 1);\n\tv4l2_ctrl_new_std(&dev->ctrls, NULL, V4L2_CID_PIXEL_RATE,\n\t\t\t  OV10640_PIXEL_RATE, OV10640_PIXEL_RATE, 1,\n\t\t\t  OV10640_PIXEL_RATE);\n\tdev->sd.ctrl_handler = &dev->ctrls;\n\n\tret = dev->ctrls.error;\n\tif (ret)\n\t\tgoto error_free_ctrls;\n\n\tdev->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tdev->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tret = media_entity_pads_init(&dev->sd.entity, 1, &dev->pad);\n\tif (ret < 0)\n\t\tgoto error_free_ctrls;\n\n\tret = v4l2_async_register_subdev(&dev->sd);\n\tif (ret)\n\t\tgoto error_free_ctrls;\n\n\treturn 0;\n\nerror_free_ctrls:\n\tv4l2_ctrl_handler_free(&dev->ctrls);\nerror:\n\ti2c_unregister_device(dev->isp);\n\n\treturn ret;\n}\n\nstatic void rdacm21_remove(struct i2c_client *client)\n{\n\tstruct rdacm21_device *dev = sd_to_rdacm21(i2c_get_clientdata(client));\n\n\tv4l2_async_unregister_subdev(&dev->sd);\n\tv4l2_ctrl_handler_free(&dev->ctrls);\n\ti2c_unregister_device(dev->isp);\n}\n\nstatic const struct of_device_id rdacm21_of_ids[] = {\n\t{ .compatible = \"imi,rdacm21\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rdacm21_of_ids);\n\nstatic struct i2c_driver rdacm21_i2c_driver = {\n\t.driver\t= {\n\t\t.name\t= \"rdacm21\",\n\t\t.of_match_table = rdacm21_of_ids,\n\t},\n\t.probe\t\t= rdacm21_probe,\n\t.remove\t\t= rdacm21_remove,\n};\n\nmodule_i2c_driver(rdacm21_i2c_driver);\n\nMODULE_DESCRIPTION(\"GMSL Camera driver for RDACM21\");\nMODULE_AUTHOR(\"Jacopo Mondi\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}