{
  "module_name": "mt9m001.c",
  "hash_id": "a3a1db7f91ff1891a53ec44ad602862983cd4f23c5950e24fb31fdac395cc369",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/mt9m001.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-subdev.h>\n\n \n\n \n#define MT9M001_CHIP_VERSION\t\t0x00\n#define MT9M001_ROW_START\t\t0x01\n#define MT9M001_COLUMN_START\t\t0x02\n#define MT9M001_WINDOW_HEIGHT\t\t0x03\n#define MT9M001_WINDOW_WIDTH\t\t0x04\n#define MT9M001_HORIZONTAL_BLANKING\t0x05\n#define MT9M001_VERTICAL_BLANKING\t0x06\n#define MT9M001_OUTPUT_CONTROL\t\t0x07\n#define MT9M001_SHUTTER_WIDTH\t\t0x09\n#define MT9M001_FRAME_RESTART\t\t0x0b\n#define MT9M001_SHUTTER_DELAY\t\t0x0c\n#define MT9M001_RESET\t\t\t0x0d\n#define MT9M001_READ_OPTIONS1\t\t0x1e\n#define MT9M001_READ_OPTIONS2\t\t0x20\n#define MT9M001_GLOBAL_GAIN\t\t0x35\n#define MT9M001_CHIP_ENABLE\t\t0xF1\n\n#define MT9M001_MAX_WIDTH\t\t1280\n#define MT9M001_MAX_HEIGHT\t\t1024\n#define MT9M001_MIN_WIDTH\t\t48\n#define MT9M001_MIN_HEIGHT\t\t32\n#define MT9M001_COLUMN_SKIP\t\t20\n#define MT9M001_ROW_SKIP\t\t12\n#define MT9M001_DEFAULT_HBLANK\t\t9\n#define MT9M001_DEFAULT_VBLANK\t\t25\n\n \nstruct mt9m001_datafmt {\n\tu32\tcode;\n\tenum v4l2_colorspace\t\tcolorspace;\n};\n\n \nstatic const struct mt9m001_datafmt *mt9m001_find_datafmt(\n\tu32 code, const struct mt9m001_datafmt *fmt,\n\tint n)\n{\n\tint i;\n\tfor (i = 0; i < n; i++)\n\t\tif (fmt[i].code == code)\n\t\t\treturn fmt + i;\n\n\treturn NULL;\n}\n\nstatic const struct mt9m001_datafmt mt9m001_colour_fmts[] = {\n\t \n\t{MEDIA_BUS_FMT_SBGGR10_1X10, V4L2_COLORSPACE_SRGB},\n\t{MEDIA_BUS_FMT_SBGGR8_1X8, V4L2_COLORSPACE_SRGB},\n};\n\nstatic const struct mt9m001_datafmt mt9m001_monochrome_fmts[] = {\n\t \n\t{MEDIA_BUS_FMT_Y10_1X10, V4L2_COLORSPACE_JPEG},\n\t{MEDIA_BUS_FMT_Y8_1X8, V4L2_COLORSPACE_JPEG},\n};\n\nstruct mt9m001 {\n\tstruct v4l2_subdev subdev;\n\tstruct v4l2_ctrl_handler hdl;\n\tstruct {\n\t\t \n\t\tstruct v4l2_ctrl *autoexposure;\n\t\tstruct v4l2_ctrl *exposure;\n\t};\n\tbool streaming;\n\tstruct mutex mutex;\n\tstruct v4l2_rect rect;\t \n\tstruct clk *clk;\n\tstruct gpio_desc *standby_gpio;\n\tstruct gpio_desc *reset_gpio;\n\tconst struct mt9m001_datafmt *fmt;\n\tconst struct mt9m001_datafmt *fmts;\n\tint num_fmts;\n\tunsigned int total_h;\n\tunsigned short y_skip_top;\t \n\tstruct media_pad pad;\n};\n\nstatic struct mt9m001 *to_mt9m001(const struct i2c_client *client)\n{\n\treturn container_of(i2c_get_clientdata(client), struct mt9m001, subdev);\n}\n\nstatic int reg_read(struct i2c_client *client, const u8 reg)\n{\n\treturn i2c_smbus_read_word_swapped(client, reg);\n}\n\nstatic int reg_write(struct i2c_client *client, const u8 reg,\n\t\t     const u16 data)\n{\n\treturn i2c_smbus_write_word_swapped(client, reg, data);\n}\n\nstatic int reg_set(struct i2c_client *client, const u8 reg,\n\t\t   const u16 data)\n{\n\tint ret;\n\n\tret = reg_read(client, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn reg_write(client, reg, ret | data);\n}\n\nstatic int reg_clear(struct i2c_client *client, const u8 reg,\n\t\t     const u16 data)\n{\n\tint ret;\n\n\tret = reg_read(client, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn reg_write(client, reg, ret & ~data);\n}\n\nstruct mt9m001_reg {\n\tu8 reg;\n\tu16 data;\n};\n\nstatic int multi_reg_write(struct i2c_client *client,\n\t\t\t   const struct mt9m001_reg *regs, int num)\n{\n\tint i;\n\n\tfor (i = 0; i < num; i++) {\n\t\tint ret = reg_write(client, regs[i].reg, regs[i].data);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mt9m001_init(struct i2c_client *client)\n{\n\tstatic const struct mt9m001_reg init_regs[] = {\n\t\t \n\t\t{ MT9M001_RESET, 1 },\n\t\t{ MT9M001_RESET, 0 },\n\t\t \n\t\t{ MT9M001_OUTPUT_CONTROL, 0 }\n\t};\n\n\tdev_dbg(&client->dev, \"%s\\n\", __func__);\n\n\treturn multi_reg_write(client, init_regs, ARRAY_SIZE(init_regs));\n}\n\nstatic int mt9m001_apply_selection(struct v4l2_subdev *sd)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9m001 *mt9m001 = to_mt9m001(client);\n\tconst struct mt9m001_reg regs[] = {\n\t\t \n\t\t{ MT9M001_HORIZONTAL_BLANKING, MT9M001_DEFAULT_HBLANK },\n\t\t{ MT9M001_VERTICAL_BLANKING, MT9M001_DEFAULT_VBLANK },\n\t\t \n\t\t{ MT9M001_COLUMN_START, mt9m001->rect.left },\n\t\t{ MT9M001_ROW_START, mt9m001->rect.top },\n\t\t{ MT9M001_WINDOW_WIDTH, mt9m001->rect.width - 1 },\n\t\t{ MT9M001_WINDOW_HEIGHT,\n\t\t\tmt9m001->rect.height + mt9m001->y_skip_top - 1 },\n\t};\n\n\treturn multi_reg_write(client, regs, ARRAY_SIZE(regs));\n}\n\nstatic int mt9m001_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9m001 *mt9m001 = to_mt9m001(client);\n\tint ret = 0;\n\n\tmutex_lock(&mt9m001->mutex);\n\n\tif (mt9m001->streaming == enable)\n\t\tgoto done;\n\n\tif (enable) {\n\t\tret = pm_runtime_resume_and_get(&client->dev);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\n\t\tret = mt9m001_apply_selection(sd);\n\t\tif (ret)\n\t\t\tgoto put_unlock;\n\n\t\tret = __v4l2_ctrl_handler_setup(&mt9m001->hdl);\n\t\tif (ret)\n\t\t\tgoto put_unlock;\n\n\t\t \n\t\tret = reg_write(client, MT9M001_OUTPUT_CONTROL, 2);\n\t\tif (ret < 0)\n\t\t\tgoto put_unlock;\n\t} else {\n\t\t \n\t\treg_write(client, MT9M001_OUTPUT_CONTROL, 0);\n\t\tpm_runtime_put(&client->dev);\n\t}\n\n\tmt9m001->streaming = enable;\ndone:\n\tmutex_unlock(&mt9m001->mutex);\n\n\treturn 0;\n\nput_unlock:\n\tpm_runtime_put(&client->dev);\nunlock:\n\tmutex_unlock(&mt9m001->mutex);\n\n\treturn ret;\n}\n\nstatic int mt9m001_set_selection(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9m001 *mt9m001 = to_mt9m001(client);\n\tstruct v4l2_rect rect = sel->r;\n\n\tif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||\n\t    sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\tif (mt9m001->fmts == mt9m001_colour_fmts)\n\t\t \n\t\trect.height = ALIGN(rect.height, 2);\n\n\t \n\trect.width = ALIGN(rect.width, 2);\n\trect.left = ALIGN(rect.left, 2);\n\n\trect.width = clamp_t(u32, rect.width, MT9M001_MIN_WIDTH,\n\t\t\tMT9M001_MAX_WIDTH);\n\trect.left = clamp_t(u32, rect.left, MT9M001_COLUMN_SKIP,\n\t\t\tMT9M001_COLUMN_SKIP + MT9M001_MAX_WIDTH - rect.width);\n\n\trect.height = clamp_t(u32, rect.height, MT9M001_MIN_HEIGHT,\n\t\t\tMT9M001_MAX_HEIGHT);\n\trect.top = clamp_t(u32, rect.top, MT9M001_ROW_SKIP,\n\t\t\tMT9M001_ROW_SKIP + MT9M001_MAX_HEIGHT - rect.height);\n\n\tmt9m001->total_h = rect.height + mt9m001->y_skip_top +\n\t\t\t   MT9M001_DEFAULT_VBLANK;\n\n\tmt9m001->rect = rect;\n\n\treturn 0;\n}\n\nstatic int mt9m001_get_selection(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9m001 *mt9m001 = to_mt9m001(client);\n\n\tif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.left = MT9M001_COLUMN_SKIP;\n\t\tsel->r.top = MT9M001_ROW_SKIP;\n\t\tsel->r.width = MT9M001_MAX_WIDTH;\n\t\tsel->r.height = MT9M001_MAX_HEIGHT;\n\t\treturn 0;\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = mt9m001->rect;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mt9m001_get_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9m001 *mt9m001 = to_mt9m001(client);\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tmf = v4l2_subdev_get_try_format(sd, sd_state, 0);\n\t\tformat->format = *mf;\n\t\treturn 0;\n\t}\n\n\tmf->width\t= mt9m001->rect.width;\n\tmf->height\t= mt9m001->rect.height;\n\tmf->code\t= mt9m001->fmt->code;\n\tmf->colorspace\t= mt9m001->fmt->colorspace;\n\tmf->field\t= V4L2_FIELD_NONE;\n\tmf->ycbcr_enc\t= V4L2_YCBCR_ENC_DEFAULT;\n\tmf->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tmf->xfer_func\t= V4L2_XFER_FUNC_DEFAULT;\n\n\treturn 0;\n}\n\nstatic int mt9m001_s_fmt(struct v4l2_subdev *sd,\n\t\t\t const struct mt9m001_datafmt *fmt,\n\t\t\t struct v4l2_mbus_framefmt *mf)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9m001 *mt9m001 = to_mt9m001(client);\n\tstruct v4l2_subdev_selection sel = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.target = V4L2_SEL_TGT_CROP,\n\t\t.r.left = mt9m001->rect.left,\n\t\t.r.top = mt9m001->rect.top,\n\t\t.r.width = mf->width,\n\t\t.r.height = mf->height,\n\t};\n\tint ret;\n\n\t \n\tret = mt9m001_set_selection(sd, NULL, &sel);\n\tif (!ret) {\n\t\tmf->width\t= mt9m001->rect.width;\n\t\tmf->height\t= mt9m001->rect.height;\n\t\tmt9m001->fmt\t= fmt;\n\t\tmf->colorspace\t= fmt->colorspace;\n\t}\n\n\treturn ret;\n}\n\nstatic int mt9m001_set_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9m001 *mt9m001 = to_mt9m001(client);\n\tconst struct mt9m001_datafmt *fmt;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tv4l_bound_align_image(&mf->width, MT9M001_MIN_WIDTH,\n\t\tMT9M001_MAX_WIDTH, 1,\n\t\t&mf->height, MT9M001_MIN_HEIGHT + mt9m001->y_skip_top,\n\t\tMT9M001_MAX_HEIGHT + mt9m001->y_skip_top, 0, 0);\n\n\tif (mt9m001->fmts == mt9m001_colour_fmts)\n\t\tmf->height = ALIGN(mf->height - 1, 2);\n\n\tfmt = mt9m001_find_datafmt(mf->code, mt9m001->fmts,\n\t\t\t\t   mt9m001->num_fmts);\n\tif (!fmt) {\n\t\tfmt = mt9m001->fmt;\n\t\tmf->code = fmt->code;\n\t}\n\n\tmf->colorspace\t= fmt->colorspace;\n\tmf->field\t= V4L2_FIELD_NONE;\n\tmf->ycbcr_enc\t= V4L2_YCBCR_ENC_DEFAULT;\n\tmf->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tmf->xfer_func\t= V4L2_XFER_FUNC_DEFAULT;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn mt9m001_s_fmt(sd, fmt, mf);\n\tsd_state->pads->try_fmt = *mf;\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int mt9m001_g_register(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_dbg_register *reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tif (reg->reg > 0xff)\n\t\treturn -EINVAL;\n\n\treg->size = 2;\n\treg->val = reg_read(client, reg->reg);\n\n\tif (reg->val > 0xffff)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int mt9m001_s_register(struct v4l2_subdev *sd,\n\t\t\t      const struct v4l2_dbg_register *reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tif (reg->reg > 0xff)\n\t\treturn -EINVAL;\n\n\tif (reg_write(client, reg->reg, reg->val) < 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n#endif\n\nstatic int mt9m001_power_on(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct mt9m001 *mt9m001 = to_mt9m001(client);\n\tint ret;\n\n\tret = clk_prepare_enable(mt9m001->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mt9m001->standby_gpio) {\n\t\tgpiod_set_value_cansleep(mt9m001->standby_gpio, 0);\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tif (mt9m001->reset_gpio) {\n\t\tgpiod_set_value_cansleep(mt9m001->reset_gpio, 1);\n\t\tusleep_range(1000, 2000);\n\t\tgpiod_set_value_cansleep(mt9m001->reset_gpio, 0);\n\t\tusleep_range(1000, 2000);\n\t}\n\n\treturn 0;\n}\n\nstatic int mt9m001_power_off(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct mt9m001 *mt9m001 = to_mt9m001(client);\n\n\tgpiod_set_value_cansleep(mt9m001->standby_gpio, 1);\n\tclk_disable_unprepare(mt9m001->clk);\n\n\treturn 0;\n}\n\nstatic int mt9m001_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct mt9m001 *mt9m001 = container_of(ctrl->handler,\n\t\t\t\t\t       struct mt9m001, hdl);\n\ts32 min, max;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tmin = mt9m001->exposure->minimum;\n\t\tmax = mt9m001->exposure->maximum;\n\t\tmt9m001->exposure->val =\n\t\t\t(524 + (mt9m001->total_h - 1) * (max - min)) / 1048 + min;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int mt9m001_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct mt9m001 *mt9m001 = container_of(ctrl->handler,\n\t\t\t\t\t       struct mt9m001, hdl);\n\tstruct v4l2_subdev *sd = &mt9m001->subdev;\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct v4l2_ctrl *exp = mt9m001->exposure;\n\tint data;\n\tint ret;\n\n\tif (!pm_runtime_get_if_in_use(&client->dev))\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_VFLIP:\n\t\tif (ctrl->val)\n\t\t\tret = reg_set(client, MT9M001_READ_OPTIONS2, 0x8000);\n\t\telse\n\t\t\tret = reg_clear(client, MT9M001_READ_OPTIONS2, 0x8000);\n\t\tbreak;\n\n\tcase V4L2_CID_GAIN:\n\t\t \n\t\tif (ctrl->val <= ctrl->default_value) {\n\t\t\t \n\t\t\tunsigned long range = ctrl->default_value - ctrl->minimum;\n\t\t\tdata = ((ctrl->val - (s32)ctrl->minimum) * 8 + range / 2) / range;\n\n\t\t\tdev_dbg(&client->dev, \"Setting gain %d\\n\", data);\n\t\t\tret = reg_write(client, MT9M001_GLOBAL_GAIN, data);\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tunsigned long range = ctrl->maximum - ctrl->default_value - 1;\n\t\t\tunsigned long gain = ((ctrl->val - (s32)ctrl->default_value - 1) *\n\t\t\t\t\t       111 + range / 2) / range + 9;\n\n\t\t\tif (gain <= 32)\n\t\t\t\tdata = gain;\n\t\t\telse if (gain <= 64)\n\t\t\t\tdata = ((gain - 32) * 16 + 16) / 32 + 80;\n\t\t\telse\n\t\t\t\tdata = ((gain - 64) * 7 + 28) / 56 + 96;\n\n\t\t\tdev_dbg(&client->dev, \"Setting gain from %d to %d\\n\",\n\t\t\t\t reg_read(client, MT9M001_GLOBAL_GAIN), data);\n\t\t\tret = reg_write(client, MT9M001_GLOBAL_GAIN, data);\n\t\t}\n\t\tbreak;\n\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tif (ctrl->val == V4L2_EXPOSURE_MANUAL) {\n\t\t\tunsigned long range = exp->maximum - exp->minimum;\n\t\t\tunsigned long shutter = ((exp->val - (s32)exp->minimum) * 1048 +\n\t\t\t\t\t\t range / 2) / range + 1;\n\n\t\t\tdev_dbg(&client->dev,\n\t\t\t\t\"Setting shutter width from %d to %lu\\n\",\n\t\t\t\treg_read(client, MT9M001_SHUTTER_WIDTH), shutter);\n\t\t\tret = reg_write(client, MT9M001_SHUTTER_WIDTH, shutter);\n\t\t} else {\n\t\t\tmt9m001->total_h = mt9m001->rect.height +\n\t\t\t\tmt9m001->y_skip_top + MT9M001_DEFAULT_VBLANK;\n\t\t\tret = reg_write(client, MT9M001_SHUTTER_WIDTH,\n\t\t\t\t\tmt9m001->total_h);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tpm_runtime_put(&client->dev);\n\n\treturn ret;\n}\n\n \nstatic int mt9m001_video_probe(struct i2c_client *client)\n{\n\tstruct mt9m001 *mt9m001 = to_mt9m001(client);\n\ts32 data;\n\tint ret;\n\n\t \n\tdata = reg_write(client, MT9M001_CHIP_ENABLE, 1);\n\tdev_dbg(&client->dev, \"write: %d\\n\", data);\n\n\t \n\tdata = reg_read(client, MT9M001_CHIP_VERSION);\n\n\t \n\tswitch (data) {\n\tcase 0x8411:\n\tcase 0x8421:\n\t\tmt9m001->fmts = mt9m001_colour_fmts;\n\t\tmt9m001->num_fmts = ARRAY_SIZE(mt9m001_colour_fmts);\n\t\tbreak;\n\tcase 0x8431:\n\t\tmt9m001->fmts = mt9m001_monochrome_fmts;\n\t\tmt9m001->num_fmts = ARRAY_SIZE(mt9m001_monochrome_fmts);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev,\n\t\t\t\"No MT9M001 chip detected, register read %x\\n\", data);\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tmt9m001->fmt = &mt9m001->fmts[0];\n\n\tdev_info(&client->dev, \"Detected a MT9M001 chip ID %x (%s)\\n\", data,\n\t\t data == 0x8431 ? \"C12STM\" : \"C12ST\");\n\n\tret = mt9m001_init(client);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to initialise the camera\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tret = v4l2_ctrl_handler_setup(&mt9m001->hdl);\n\ndone:\n\treturn ret;\n}\n\nstatic int mt9m001_g_skip_top_lines(struct v4l2_subdev *sd, u32 *lines)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9m001 *mt9m001 = to_mt9m001(client);\n\n\t*lines = mt9m001->y_skip_top;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops mt9m001_ctrl_ops = {\n\t.g_volatile_ctrl = mt9m001_g_volatile_ctrl,\n\t.s_ctrl = mt9m001_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops mt9m001_subdev_core_ops = {\n\t.log_status = v4l2_ctrl_subdev_log_status,\n\t.subscribe_event = v4l2_ctrl_subdev_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register\t= mt9m001_g_register,\n\t.s_register\t= mt9m001_s_register,\n#endif\n};\n\nstatic int mt9m001_init_cfg(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9m001 *mt9m001 = to_mt9m001(client);\n\tstruct v4l2_mbus_framefmt *try_fmt =\n\t\tv4l2_subdev_get_try_format(sd, sd_state, 0);\n\n\ttry_fmt->width\t\t= MT9M001_MAX_WIDTH;\n\ttry_fmt->height\t\t= MT9M001_MAX_HEIGHT;\n\ttry_fmt->code\t\t= mt9m001->fmts[0].code;\n\ttry_fmt->colorspace\t= mt9m001->fmts[0].colorspace;\n\ttry_fmt->field\t\t= V4L2_FIELD_NONE;\n\ttry_fmt->ycbcr_enc\t= V4L2_YCBCR_ENC_DEFAULT;\n\ttry_fmt->quantization\t= V4L2_QUANTIZATION_DEFAULT;\n\ttry_fmt->xfer_func\t= V4L2_XFER_FUNC_DEFAULT;\n\n\treturn 0;\n}\n\nstatic int mt9m001_enum_mbus_code(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct mt9m001 *mt9m001 = to_mt9m001(client);\n\n\tif (code->pad || code->index >= mt9m001->num_fmts)\n\t\treturn -EINVAL;\n\n\tcode->code = mt9m001->fmts[code->index].code;\n\treturn 0;\n}\n\nstatic int mt9m001_get_mbus_config(struct v4l2_subdev *sd,\n\t\t\t\t   unsigned int pad,\n\t\t\t\t   struct v4l2_mbus_config *cfg)\n{\n\t \n\tcfg->type = V4L2_MBUS_PARALLEL;\n\tcfg->bus.parallel.flags = V4L2_MBUS_PCLK_SAMPLE_FALLING |\n\t\t\t\t  V4L2_MBUS_HSYNC_ACTIVE_HIGH |\n\t\t\t\t  V4L2_MBUS_VSYNC_ACTIVE_HIGH |\n\t\t\t\t  V4L2_MBUS_DATA_ACTIVE_HIGH |\n\t\t\t\t  V4L2_MBUS_MASTER;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops mt9m001_subdev_video_ops = {\n\t.s_stream\t= mt9m001_s_stream,\n};\n\nstatic const struct v4l2_subdev_sensor_ops mt9m001_subdev_sensor_ops = {\n\t.g_skip_top_lines\t= mt9m001_g_skip_top_lines,\n};\n\nstatic const struct v4l2_subdev_pad_ops mt9m001_subdev_pad_ops = {\n\t.init_cfg\t= mt9m001_init_cfg,\n\t.enum_mbus_code = mt9m001_enum_mbus_code,\n\t.get_selection\t= mt9m001_get_selection,\n\t.set_selection\t= mt9m001_set_selection,\n\t.get_fmt\t= mt9m001_get_fmt,\n\t.set_fmt\t= mt9m001_set_fmt,\n\t.get_mbus_config = mt9m001_get_mbus_config,\n};\n\nstatic const struct v4l2_subdev_ops mt9m001_subdev_ops = {\n\t.core\t= &mt9m001_subdev_core_ops,\n\t.video\t= &mt9m001_subdev_video_ops,\n\t.sensor\t= &mt9m001_subdev_sensor_ops,\n\t.pad\t= &mt9m001_subdev_pad_ops,\n};\n\nstatic int mt9m001_probe(struct i2c_client *client)\n{\n\tstruct mt9m001 *mt9m001;\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint ret;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA)) {\n\t\tdev_warn(&adapter->dev,\n\t\t\t \"I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmt9m001 = devm_kzalloc(&client->dev, sizeof(*mt9m001), GFP_KERNEL);\n\tif (!mt9m001)\n\t\treturn -ENOMEM;\n\n\tmt9m001->clk = devm_clk_get(&client->dev, NULL);\n\tif (IS_ERR(mt9m001->clk))\n\t\treturn PTR_ERR(mt9m001->clk);\n\n\tmt9m001->standby_gpio = devm_gpiod_get_optional(&client->dev, \"standby\",\n\t\t\t\t\t\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(mt9m001->standby_gpio))\n\t\treturn PTR_ERR(mt9m001->standby_gpio);\n\n\tmt9m001->reset_gpio = devm_gpiod_get_optional(&client->dev, \"reset\",\n\t\t\t\t\t\t      GPIOD_OUT_LOW);\n\tif (IS_ERR(mt9m001->reset_gpio))\n\t\treturn PTR_ERR(mt9m001->reset_gpio);\n\n\tv4l2_i2c_subdev_init(&mt9m001->subdev, client, &mt9m001_subdev_ops);\n\tmt9m001->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |\n\t\t\t\t V4L2_SUBDEV_FL_HAS_EVENTS;\n\tv4l2_ctrl_handler_init(&mt9m001->hdl, 4);\n\tv4l2_ctrl_new_std(&mt9m001->hdl, &mt9m001_ctrl_ops,\n\t\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(&mt9m001->hdl, &mt9m001_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, 0, 127, 1, 64);\n\tmt9m001->exposure = v4l2_ctrl_new_std(&mt9m001->hdl, &mt9m001_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE, 1, 255, 1, 255);\n\t \n\tmt9m001->autoexposure = v4l2_ctrl_new_std_menu(&mt9m001->hdl,\n\t\t\t&mt9m001_ctrl_ops, V4L2_CID_EXPOSURE_AUTO, 1, 0,\n\t\t\tV4L2_EXPOSURE_AUTO);\n\tmt9m001->subdev.ctrl_handler = &mt9m001->hdl;\n\tif (mt9m001->hdl.error)\n\t\treturn mt9m001->hdl.error;\n\n\tv4l2_ctrl_auto_cluster(2, &mt9m001->autoexposure,\n\t\t\t\t\tV4L2_EXPOSURE_MANUAL, true);\n\n\tmutex_init(&mt9m001->mutex);\n\tmt9m001->hdl.lock = &mt9m001->mutex;\n\n\t \n\tmt9m001->y_skip_top\t= 0;\n\tmt9m001->rect.left\t= MT9M001_COLUMN_SKIP;\n\tmt9m001->rect.top\t= MT9M001_ROW_SKIP;\n\tmt9m001->rect.width\t= MT9M001_MAX_WIDTH;\n\tmt9m001->rect.height\t= MT9M001_MAX_HEIGHT;\n\n\tret = mt9m001_power_on(&client->dev);\n\tif (ret)\n\t\tgoto error_hdl_free;\n\n\tpm_runtime_set_active(&client->dev);\n\tpm_runtime_enable(&client->dev);\n\n\tret = mt9m001_video_probe(client);\n\tif (ret)\n\t\tgoto error_power_off;\n\n\tmt9m001->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tmt9m001->subdev.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tret = media_entity_pads_init(&mt9m001->subdev.entity, 1, &mt9m001->pad);\n\tif (ret)\n\t\tgoto error_power_off;\n\n\tret = v4l2_async_register_subdev(&mt9m001->subdev);\n\tif (ret)\n\t\tgoto error_entity_cleanup;\n\n\tpm_runtime_idle(&client->dev);\n\n\treturn 0;\n\nerror_entity_cleanup:\n\tmedia_entity_cleanup(&mt9m001->subdev.entity);\nerror_power_off:\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\tmt9m001_power_off(&client->dev);\n\nerror_hdl_free:\n\tv4l2_ctrl_handler_free(&mt9m001->hdl);\n\tmutex_destroy(&mt9m001->mutex);\n\n\treturn ret;\n}\n\nstatic void mt9m001_remove(struct i2c_client *client)\n{\n\tstruct mt9m001 *mt9m001 = to_mt9m001(client);\n\n\t \n\tpm_runtime_get_sync(&client->dev);\n\n\tv4l2_async_unregister_subdev(&mt9m001->subdev);\n\tmedia_entity_cleanup(&mt9m001->subdev.entity);\n\n\tpm_runtime_disable(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\tpm_runtime_put_noidle(&client->dev);\n\tmt9m001_power_off(&client->dev);\n\n\tv4l2_ctrl_handler_free(&mt9m001->hdl);\n\tmutex_destroy(&mt9m001->mutex);\n}\n\nstatic const struct i2c_device_id mt9m001_id[] = {\n\t{ \"mt9m001\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, mt9m001_id);\n\nstatic const struct dev_pm_ops mt9m001_pm_ops = {\n\tSET_RUNTIME_PM_OPS(mt9m001_power_off, mt9m001_power_on, NULL)\n};\n\nstatic const struct of_device_id mt9m001_of_match[] = {\n\t{ .compatible = \"onnn,mt9m001\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, mt9m001_of_match);\n\nstatic struct i2c_driver mt9m001_i2c_driver = {\n\t.driver = {\n\t\t.name = \"mt9m001\",\n\t\t.pm = &mt9m001_pm_ops,\n\t\t.of_match_table = mt9m001_of_match,\n\t},\n\t.probe\t\t= mt9m001_probe,\n\t.remove\t\t= mt9m001_remove,\n\t.id_table\t= mt9m001_id,\n};\n\nmodule_i2c_driver(mt9m001_i2c_driver);\n\nMODULE_DESCRIPTION(\"Micron MT9M001 Camera driver\");\nMODULE_AUTHOR(\"Guennadi Liakhovetski <kernel@pengutronix.de>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}