{
  "module_name": "ov5645.c",
  "hash_id": "1eef4ef3aa175b3c5d7220405ed077a533e503fb7a45fe13d6b3e3371de7b89e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ov5645.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n#define OV5645_SYSTEM_CTRL0\t\t0x3008\n#define\t\tOV5645_SYSTEM_CTRL0_START\t0x02\n#define\t\tOV5645_SYSTEM_CTRL0_STOP\t0x42\n#define OV5645_CHIP_ID_HIGH\t\t0x300a\n#define\t\tOV5645_CHIP_ID_HIGH_BYTE\t0x56\n#define OV5645_CHIP_ID_LOW\t\t0x300b\n#define\t\tOV5645_CHIP_ID_LOW_BYTE\t\t0x45\n#define OV5645_IO_MIPI_CTRL00\t\t0x300e\n#define OV5645_PAD_OUTPUT00\t\t0x3019\n#define OV5645_AWB_MANUAL_CONTROL\t0x3406\n#define\t\tOV5645_AWB_MANUAL_ENABLE\tBIT(0)\n#define OV5645_AEC_PK_MANUAL\t\t0x3503\n#define\t\tOV5645_AEC_MANUAL_ENABLE\tBIT(0)\n#define\t\tOV5645_AGC_MANUAL_ENABLE\tBIT(1)\n#define OV5645_TIMING_TC_REG20\t\t0x3820\n#define\t\tOV5645_SENSOR_VFLIP\t\tBIT(1)\n#define\t\tOV5645_ISP_VFLIP\t\tBIT(2)\n#define OV5645_TIMING_TC_REG21\t\t0x3821\n#define\t\tOV5645_SENSOR_MIRROR\t\tBIT(1)\n#define OV5645_MIPI_CTRL00\t\t0x4800\n#define OV5645_PRE_ISP_TEST_SETTING_1\t0x503d\n#define\t\tOV5645_TEST_PATTERN_MASK\t0x3\n#define\t\tOV5645_SET_TEST_PATTERN(x)\t((x) & OV5645_TEST_PATTERN_MASK)\n#define\t\tOV5645_TEST_PATTERN_ENABLE\tBIT(7)\n#define OV5645_SDE_SAT_U\t\t0x5583\n#define OV5645_SDE_SAT_V\t\t0x5584\n\n \nstatic const char * const ov5645_supply_name[] = {\n\t\"vdddo\",  \n\t\"vdda\",   \n\t\"vddd\",   \n};\n\n#define OV5645_NUM_SUPPLIES ARRAY_SIZE(ov5645_supply_name)\n\nstruct reg_value {\n\tu16 reg;\n\tu8 val;\n};\n\nstruct ov5645_mode_info {\n\tu32 width;\n\tu32 height;\n\tconst struct reg_value *data;\n\tu32 data_size;\n\tu32 pixel_clock;\n\tu32 link_freq;\n};\n\nstruct ov5645 {\n\tstruct i2c_client *i2c_client;\n\tstruct device *dev;\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pad;\n\tstruct v4l2_fwnode_endpoint ep;\n\tstruct v4l2_mbus_framefmt fmt;\n\tstruct v4l2_rect crop;\n\tstruct clk *xclk;\n\n\tstruct regulator_bulk_data supplies[OV5645_NUM_SUPPLIES];\n\n\tconst struct ov5645_mode_info *current_mode;\n\n\tstruct v4l2_ctrl_handler ctrls;\n\tstruct v4l2_ctrl *pixel_clock;\n\tstruct v4l2_ctrl *link_freq;\n\n\t \n\tu8 aec_pk_manual;\n\tu8 timing_tc_reg20;\n\tu8 timing_tc_reg21;\n\n\tstruct mutex power_lock;  \n\n\tstruct gpio_desc *enable_gpio;\n\tstruct gpio_desc *rst_gpio;\n};\n\nstatic inline struct ov5645 *to_ov5645(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct ov5645, sd);\n}\n\nstatic const struct reg_value ov5645_global_init_setting[] = {\n\t{ 0x3103, 0x11 },\n\t{ 0x3008, 0x82 },\n\t{ 0x3008, 0x42 },\n\t{ 0x3103, 0x03 },\n\t{ 0x3503, 0x07 },\n\t{ 0x3002, 0x1c },\n\t{ 0x3006, 0xc3 },\n\t{ 0x3017, 0x00 },\n\t{ 0x3018, 0x00 },\n\t{ 0x302e, 0x0b },\n\t{ 0x3037, 0x13 },\n\t{ 0x3108, 0x01 },\n\t{ 0x3611, 0x06 },\n\t{ 0x3500, 0x00 },\n\t{ 0x3501, 0x01 },\n\t{ 0x3502, 0x00 },\n\t{ 0x350a, 0x00 },\n\t{ 0x350b, 0x3f },\n\t{ 0x3620, 0x33 },\n\t{ 0x3621, 0xe0 },\n\t{ 0x3622, 0x01 },\n\t{ 0x3630, 0x2e },\n\t{ 0x3631, 0x00 },\n\t{ 0x3632, 0x32 },\n\t{ 0x3633, 0x52 },\n\t{ 0x3634, 0x70 },\n\t{ 0x3635, 0x13 },\n\t{ 0x3636, 0x03 },\n\t{ 0x3703, 0x5a },\n\t{ 0x3704, 0xa0 },\n\t{ 0x3705, 0x1a },\n\t{ 0x3709, 0x12 },\n\t{ 0x370b, 0x61 },\n\t{ 0x370f, 0x10 },\n\t{ 0x3715, 0x78 },\n\t{ 0x3717, 0x01 },\n\t{ 0x371b, 0x20 },\n\t{ 0x3731, 0x12 },\n\t{ 0x3901, 0x0a },\n\t{ 0x3905, 0x02 },\n\t{ 0x3906, 0x10 },\n\t{ 0x3719, 0x86 },\n\t{ 0x3810, 0x00 },\n\t{ 0x3811, 0x10 },\n\t{ 0x3812, 0x00 },\n\t{ 0x3821, 0x01 },\n\t{ 0x3824, 0x01 },\n\t{ 0x3826, 0x03 },\n\t{ 0x3828, 0x08 },\n\t{ 0x3a19, 0xf8 },\n\t{ 0x3c01, 0x34 },\n\t{ 0x3c04, 0x28 },\n\t{ 0x3c05, 0x98 },\n\t{ 0x3c07, 0x07 },\n\t{ 0x3c09, 0xc2 },\n\t{ 0x3c0a, 0x9c },\n\t{ 0x3c0b, 0x40 },\n\t{ 0x3c01, 0x34 },\n\t{ 0x4001, 0x02 },\n\t{ 0x4514, 0x00 },\n\t{ 0x4520, 0xb0 },\n\t{ 0x460b, 0x37 },\n\t{ 0x460c, 0x20 },\n\t{ 0x4818, 0x01 },\n\t{ 0x481d, 0xf0 },\n\t{ 0x481f, 0x50 },\n\t{ 0x4823, 0x70 },\n\t{ 0x4831, 0x14 },\n\t{ 0x5000, 0xa7 },\n\t{ 0x5001, 0x83 },\n\t{ 0x501d, 0x00 },\n\t{ 0x501f, 0x00 },\n\t{ 0x503d, 0x00 },\n\t{ 0x505c, 0x30 },\n\t{ 0x5181, 0x59 },\n\t{ 0x5183, 0x00 },\n\t{ 0x5191, 0xf0 },\n\t{ 0x5192, 0x03 },\n\t{ 0x5684, 0x10 },\n\t{ 0x5685, 0xa0 },\n\t{ 0x5686, 0x0c },\n\t{ 0x5687, 0x78 },\n\t{ 0x5a00, 0x08 },\n\t{ 0x5a21, 0x00 },\n\t{ 0x5a24, 0x00 },\n\t{ 0x3008, 0x02 },\n\t{ 0x3503, 0x00 },\n\t{ 0x5180, 0xff },\n\t{ 0x5181, 0xf2 },\n\t{ 0x5182, 0x00 },\n\t{ 0x5183, 0x14 },\n\t{ 0x5184, 0x25 },\n\t{ 0x5185, 0x24 },\n\t{ 0x5186, 0x09 },\n\t{ 0x5187, 0x09 },\n\t{ 0x5188, 0x0a },\n\t{ 0x5189, 0x75 },\n\t{ 0x518a, 0x52 },\n\t{ 0x518b, 0xea },\n\t{ 0x518c, 0xa8 },\n\t{ 0x518d, 0x42 },\n\t{ 0x518e, 0x38 },\n\t{ 0x518f, 0x56 },\n\t{ 0x5190, 0x42 },\n\t{ 0x5191, 0xf8 },\n\t{ 0x5192, 0x04 },\n\t{ 0x5193, 0x70 },\n\t{ 0x5194, 0xf0 },\n\t{ 0x5195, 0xf0 },\n\t{ 0x5196, 0x03 },\n\t{ 0x5197, 0x01 },\n\t{ 0x5198, 0x04 },\n\t{ 0x5199, 0x12 },\n\t{ 0x519a, 0x04 },\n\t{ 0x519b, 0x00 },\n\t{ 0x519c, 0x06 },\n\t{ 0x519d, 0x82 },\n\t{ 0x519e, 0x38 },\n\t{ 0x5381, 0x1e },\n\t{ 0x5382, 0x5b },\n\t{ 0x5383, 0x08 },\n\t{ 0x5384, 0x0a },\n\t{ 0x5385, 0x7e },\n\t{ 0x5386, 0x88 },\n\t{ 0x5387, 0x7c },\n\t{ 0x5388, 0x6c },\n\t{ 0x5389, 0x10 },\n\t{ 0x538a, 0x01 },\n\t{ 0x538b, 0x98 },\n\t{ 0x5300, 0x08 },\n\t{ 0x5301, 0x30 },\n\t{ 0x5302, 0x10 },\n\t{ 0x5303, 0x00 },\n\t{ 0x5304, 0x08 },\n\t{ 0x5305, 0x30 },\n\t{ 0x5306, 0x08 },\n\t{ 0x5307, 0x16 },\n\t{ 0x5309, 0x08 },\n\t{ 0x530a, 0x30 },\n\t{ 0x530b, 0x04 },\n\t{ 0x530c, 0x06 },\n\t{ 0x5480, 0x01 },\n\t{ 0x5481, 0x08 },\n\t{ 0x5482, 0x14 },\n\t{ 0x5483, 0x28 },\n\t{ 0x5484, 0x51 },\n\t{ 0x5485, 0x65 },\n\t{ 0x5486, 0x71 },\n\t{ 0x5487, 0x7d },\n\t{ 0x5488, 0x87 },\n\t{ 0x5489, 0x91 },\n\t{ 0x548a, 0x9a },\n\t{ 0x548b, 0xaa },\n\t{ 0x548c, 0xb8 },\n\t{ 0x548d, 0xcd },\n\t{ 0x548e, 0xdd },\n\t{ 0x548f, 0xea },\n\t{ 0x5490, 0x1d },\n\t{ 0x5580, 0x02 },\n\t{ 0x5583, 0x40 },\n\t{ 0x5584, 0x10 },\n\t{ 0x5589, 0x10 },\n\t{ 0x558a, 0x00 },\n\t{ 0x558b, 0xf8 },\n\t{ 0x5800, 0x3f },\n\t{ 0x5801, 0x16 },\n\t{ 0x5802, 0x0e },\n\t{ 0x5803, 0x0d },\n\t{ 0x5804, 0x17 },\n\t{ 0x5805, 0x3f },\n\t{ 0x5806, 0x0b },\n\t{ 0x5807, 0x06 },\n\t{ 0x5808, 0x04 },\n\t{ 0x5809, 0x04 },\n\t{ 0x580a, 0x06 },\n\t{ 0x580b, 0x0b },\n\t{ 0x580c, 0x09 },\n\t{ 0x580d, 0x03 },\n\t{ 0x580e, 0x00 },\n\t{ 0x580f, 0x00 },\n\t{ 0x5810, 0x03 },\n\t{ 0x5811, 0x08 },\n\t{ 0x5812, 0x0a },\n\t{ 0x5813, 0x03 },\n\t{ 0x5814, 0x00 },\n\t{ 0x5815, 0x00 },\n\t{ 0x5816, 0x04 },\n\t{ 0x5817, 0x09 },\n\t{ 0x5818, 0x0f },\n\t{ 0x5819, 0x08 },\n\t{ 0x581a, 0x06 },\n\t{ 0x581b, 0x06 },\n\t{ 0x581c, 0x08 },\n\t{ 0x581d, 0x0c },\n\t{ 0x581e, 0x3f },\n\t{ 0x581f, 0x1e },\n\t{ 0x5820, 0x12 },\n\t{ 0x5821, 0x13 },\n\t{ 0x5822, 0x21 },\n\t{ 0x5823, 0x3f },\n\t{ 0x5824, 0x68 },\n\t{ 0x5825, 0x28 },\n\t{ 0x5826, 0x2c },\n\t{ 0x5827, 0x28 },\n\t{ 0x5828, 0x08 },\n\t{ 0x5829, 0x48 },\n\t{ 0x582a, 0x64 },\n\t{ 0x582b, 0x62 },\n\t{ 0x582c, 0x64 },\n\t{ 0x582d, 0x28 },\n\t{ 0x582e, 0x46 },\n\t{ 0x582f, 0x62 },\n\t{ 0x5830, 0x60 },\n\t{ 0x5831, 0x62 },\n\t{ 0x5832, 0x26 },\n\t{ 0x5833, 0x48 },\n\t{ 0x5834, 0x66 },\n\t{ 0x5835, 0x44 },\n\t{ 0x5836, 0x64 },\n\t{ 0x5837, 0x28 },\n\t{ 0x5838, 0x66 },\n\t{ 0x5839, 0x48 },\n\t{ 0x583a, 0x2c },\n\t{ 0x583b, 0x28 },\n\t{ 0x583c, 0x26 },\n\t{ 0x583d, 0xae },\n\t{ 0x5025, 0x00 },\n\t{ 0x3a0f, 0x30 },\n\t{ 0x3a10, 0x28 },\n\t{ 0x3a1b, 0x30 },\n\t{ 0x3a1e, 0x26 },\n\t{ 0x3a11, 0x60 },\n\t{ 0x3a1f, 0x14 },\n\t{ 0x0601, 0x02 },\n\t{ 0x3008, 0x42 },\n\t{ 0x3008, 0x02 },\n\t{ OV5645_IO_MIPI_CTRL00, 0x40 },\n\t{ OV5645_MIPI_CTRL00, 0x24 },\n\t{ OV5645_PAD_OUTPUT00, 0x70 }\n};\n\nstatic const struct reg_value ov5645_setting_sxga[] = {\n\t{ 0x3612, 0xa9 },\n\t{ 0x3614, 0x50 },\n\t{ 0x3618, 0x00 },\n\t{ 0x3034, 0x18 },\n\t{ 0x3035, 0x21 },\n\t{ 0x3036, 0x70 },\n\t{ 0x3600, 0x09 },\n\t{ 0x3601, 0x43 },\n\t{ 0x3708, 0x66 },\n\t{ 0x370c, 0xc3 },\n\t{ 0x3800, 0x00 },\n\t{ 0x3801, 0x00 },\n\t{ 0x3802, 0x00 },\n\t{ 0x3803, 0x06 },\n\t{ 0x3804, 0x0a },\n\t{ 0x3805, 0x3f },\n\t{ 0x3806, 0x07 },\n\t{ 0x3807, 0x9d },\n\t{ 0x3808, 0x05 },\n\t{ 0x3809, 0x00 },\n\t{ 0x380a, 0x03 },\n\t{ 0x380b, 0xc0 },\n\t{ 0x380c, 0x07 },\n\t{ 0x380d, 0x68 },\n\t{ 0x380e, 0x03 },\n\t{ 0x380f, 0xd8 },\n\t{ 0x3813, 0x06 },\n\t{ 0x3814, 0x31 },\n\t{ 0x3815, 0x31 },\n\t{ 0x3820, 0x47 },\n\t{ 0x3a02, 0x03 },\n\t{ 0x3a03, 0xd8 },\n\t{ 0x3a08, 0x01 },\n\t{ 0x3a09, 0xf8 },\n\t{ 0x3a0a, 0x01 },\n\t{ 0x3a0b, 0xa4 },\n\t{ 0x3a0e, 0x02 },\n\t{ 0x3a0d, 0x02 },\n\t{ 0x3a14, 0x03 },\n\t{ 0x3a15, 0xd8 },\n\t{ 0x3a18, 0x00 },\n\t{ 0x4004, 0x02 },\n\t{ 0x4005, 0x18 },\n\t{ 0x4300, 0x32 },\n\t{ 0x4202, 0x00 }\n};\n\nstatic const struct reg_value ov5645_setting_1080p[] = {\n\t{ 0x3612, 0xab },\n\t{ 0x3614, 0x50 },\n\t{ 0x3618, 0x04 },\n\t{ 0x3034, 0x18 },\n\t{ 0x3035, 0x11 },\n\t{ 0x3036, 0x54 },\n\t{ 0x3600, 0x08 },\n\t{ 0x3601, 0x33 },\n\t{ 0x3708, 0x63 },\n\t{ 0x370c, 0xc0 },\n\t{ 0x3800, 0x01 },\n\t{ 0x3801, 0x50 },\n\t{ 0x3802, 0x01 },\n\t{ 0x3803, 0xb2 },\n\t{ 0x3804, 0x08 },\n\t{ 0x3805, 0xef },\n\t{ 0x3806, 0x05 },\n\t{ 0x3807, 0xf1 },\n\t{ 0x3808, 0x07 },\n\t{ 0x3809, 0x80 },\n\t{ 0x380a, 0x04 },\n\t{ 0x380b, 0x38 },\n\t{ 0x380c, 0x09 },\n\t{ 0x380d, 0xc4 },\n\t{ 0x380e, 0x04 },\n\t{ 0x380f, 0x60 },\n\t{ 0x3813, 0x04 },\n\t{ 0x3814, 0x11 },\n\t{ 0x3815, 0x11 },\n\t{ 0x3820, 0x47 },\n\t{ 0x4514, 0x88 },\n\t{ 0x3a02, 0x04 },\n\t{ 0x3a03, 0x60 },\n\t{ 0x3a08, 0x01 },\n\t{ 0x3a09, 0x50 },\n\t{ 0x3a0a, 0x01 },\n\t{ 0x3a0b, 0x18 },\n\t{ 0x3a0e, 0x03 },\n\t{ 0x3a0d, 0x04 },\n\t{ 0x3a14, 0x04 },\n\t{ 0x3a15, 0x60 },\n\t{ 0x3a18, 0x00 },\n\t{ 0x4004, 0x06 },\n\t{ 0x4005, 0x18 },\n\t{ 0x4300, 0x32 },\n\t{ 0x4202, 0x00 },\n\t{ 0x4837, 0x0b }\n};\n\nstatic const struct reg_value ov5645_setting_full[] = {\n\t{ 0x3612, 0xab },\n\t{ 0x3614, 0x50 },\n\t{ 0x3618, 0x04 },\n\t{ 0x3034, 0x18 },\n\t{ 0x3035, 0x11 },\n\t{ 0x3036, 0x54 },\n\t{ 0x3600, 0x08 },\n\t{ 0x3601, 0x33 },\n\t{ 0x3708, 0x63 },\n\t{ 0x370c, 0xc0 },\n\t{ 0x3800, 0x00 },\n\t{ 0x3801, 0x00 },\n\t{ 0x3802, 0x00 },\n\t{ 0x3803, 0x00 },\n\t{ 0x3804, 0x0a },\n\t{ 0x3805, 0x3f },\n\t{ 0x3806, 0x07 },\n\t{ 0x3807, 0x9f },\n\t{ 0x3808, 0x0a },\n\t{ 0x3809, 0x20 },\n\t{ 0x380a, 0x07 },\n\t{ 0x380b, 0x98 },\n\t{ 0x380c, 0x0b },\n\t{ 0x380d, 0x1c },\n\t{ 0x380e, 0x07 },\n\t{ 0x380f, 0xb0 },\n\t{ 0x3813, 0x06 },\n\t{ 0x3814, 0x11 },\n\t{ 0x3815, 0x11 },\n\t{ 0x3820, 0x47 },\n\t{ 0x4514, 0x88 },\n\t{ 0x3a02, 0x07 },\n\t{ 0x3a03, 0xb0 },\n\t{ 0x3a08, 0x01 },\n\t{ 0x3a09, 0x27 },\n\t{ 0x3a0a, 0x00 },\n\t{ 0x3a0b, 0xf6 },\n\t{ 0x3a0e, 0x06 },\n\t{ 0x3a0d, 0x08 },\n\t{ 0x3a14, 0x07 },\n\t{ 0x3a15, 0xb0 },\n\t{ 0x3a18, 0x01 },\n\t{ 0x4004, 0x06 },\n\t{ 0x4005, 0x18 },\n\t{ 0x4300, 0x32 },\n\t{ 0x4837, 0x0b },\n\t{ 0x4202, 0x00 }\n};\n\nstatic const s64 link_freq[] = {\n\t224000000,\n\t336000000\n};\n\nstatic const struct ov5645_mode_info ov5645_mode_info_data[] = {\n\t{\n\t\t.width = 1280,\n\t\t.height = 960,\n\t\t.data = ov5645_setting_sxga,\n\t\t.data_size = ARRAY_SIZE(ov5645_setting_sxga),\n\t\t.pixel_clock = 112000000,\n\t\t.link_freq = 0  \n\t},\n\t{\n\t\t.width = 1920,\n\t\t.height = 1080,\n\t\t.data = ov5645_setting_1080p,\n\t\t.data_size = ARRAY_SIZE(ov5645_setting_1080p),\n\t\t.pixel_clock = 168000000,\n\t\t.link_freq = 1  \n\t},\n\t{\n\t\t.width = 2592,\n\t\t.height = 1944,\n\t\t.data = ov5645_setting_full,\n\t\t.data_size = ARRAY_SIZE(ov5645_setting_full),\n\t\t.pixel_clock = 168000000,\n\t\t.link_freq = 1  \n\t},\n};\n\nstatic int ov5645_write_reg(struct ov5645 *ov5645, u16 reg, u8 val)\n{\n\tu8 regbuf[3];\n\tint ret;\n\n\tregbuf[0] = reg >> 8;\n\tregbuf[1] = reg & 0xff;\n\tregbuf[2] = val;\n\n\tret = i2c_master_send(ov5645->i2c_client, regbuf, 3);\n\tif (ret < 0) {\n\t\tdev_err(ov5645->dev, \"%s: write reg error %d: reg=%x, val=%x\\n\",\n\t\t\t__func__, ret, reg, val);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov5645_read_reg(struct ov5645 *ov5645, u16 reg, u8 *val)\n{\n\tu8 regbuf[2];\n\tint ret;\n\n\tregbuf[0] = reg >> 8;\n\tregbuf[1] = reg & 0xff;\n\n\tret = i2c_master_send(ov5645->i2c_client, regbuf, 2);\n\tif (ret < 0) {\n\t\tdev_err(ov5645->dev, \"%s: write reg error %d: reg=%x\\n\",\n\t\t\t__func__, ret, reg);\n\t\treturn ret;\n\t}\n\n\tret = i2c_master_recv(ov5645->i2c_client, val, 1);\n\tif (ret < 0) {\n\t\tdev_err(ov5645->dev, \"%s: read reg error %d: reg=%x\\n\",\n\t\t\t__func__, ret, reg);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov5645_set_aec_mode(struct ov5645 *ov5645, u32 mode)\n{\n\tu8 val = ov5645->aec_pk_manual;\n\tint ret;\n\n\tif (mode == V4L2_EXPOSURE_AUTO)\n\t\tval &= ~OV5645_AEC_MANUAL_ENABLE;\n\telse  \n\t\tval |= OV5645_AEC_MANUAL_ENABLE;\n\n\tret = ov5645_write_reg(ov5645, OV5645_AEC_PK_MANUAL, val);\n\tif (!ret)\n\t\tov5645->aec_pk_manual = val;\n\n\treturn ret;\n}\n\nstatic int ov5645_set_agc_mode(struct ov5645 *ov5645, u32 enable)\n{\n\tu8 val = ov5645->aec_pk_manual;\n\tint ret;\n\n\tif (enable)\n\t\tval &= ~OV5645_AGC_MANUAL_ENABLE;\n\telse\n\t\tval |= OV5645_AGC_MANUAL_ENABLE;\n\n\tret = ov5645_write_reg(ov5645, OV5645_AEC_PK_MANUAL, val);\n\tif (!ret)\n\t\tov5645->aec_pk_manual = val;\n\n\treturn ret;\n}\n\nstatic int ov5645_set_register_array(struct ov5645 *ov5645,\n\t\t\t\t     const struct reg_value *settings,\n\t\t\t\t     unsigned int num_settings)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < num_settings; ++i, ++settings) {\n\t\tret = ov5645_write_reg(ov5645, settings->reg, settings->val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov5645_set_power_off(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct ov5645 *ov5645 = to_ov5645(sd);\n\n\tov5645_write_reg(ov5645, OV5645_IO_MIPI_CTRL00, 0x58);\n\tgpiod_set_value_cansleep(ov5645->rst_gpio, 1);\n\tgpiod_set_value_cansleep(ov5645->enable_gpio, 0);\n\tclk_disable_unprepare(ov5645->xclk);\n\tregulator_bulk_disable(OV5645_NUM_SUPPLIES, ov5645->supplies);\n\n\treturn 0;\n}\n\nstatic int ov5645_set_power_on(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct ov5645 *ov5645 = to_ov5645(sd);\n\tint ret;\n\n\tret = regulator_bulk_enable(OV5645_NUM_SUPPLIES, ov5645->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(ov5645->xclk);\n\tif (ret < 0) {\n\t\tdev_err(ov5645->dev, \"clk prepare enable failed\\n\");\n\t\tregulator_bulk_disable(OV5645_NUM_SUPPLIES, ov5645->supplies);\n\t\treturn ret;\n\t}\n\n\tusleep_range(5000, 15000);\n\tgpiod_set_value_cansleep(ov5645->enable_gpio, 1);\n\n\tusleep_range(1000, 2000);\n\tgpiod_set_value_cansleep(ov5645->rst_gpio, 0);\n\n\tmsleep(20);\n\n\tret = ov5645_set_register_array(ov5645, ov5645_global_init_setting,\n\t\t\t\t\tARRAY_SIZE(ov5645_global_init_setting));\n\tif (ret < 0) {\n\t\tdev_err(ov5645->dev, \"could not set init registers\\n\");\n\t\tgoto exit;\n\t}\n\n\tusleep_range(500, 1000);\n\n\treturn 0;\n\nexit:\n\tov5645_set_power_off(dev);\n\treturn ret;\n}\n\nstatic int ov5645_set_saturation(struct ov5645 *ov5645, s32 value)\n{\n\tu32 reg_value = (value * 0x10) + 0x40;\n\tint ret;\n\n\tret = ov5645_write_reg(ov5645, OV5645_SDE_SAT_U, reg_value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ov5645_write_reg(ov5645, OV5645_SDE_SAT_V, reg_value);\n}\n\nstatic int ov5645_set_hflip(struct ov5645 *ov5645, s32 value)\n{\n\tu8 val = ov5645->timing_tc_reg21;\n\tint ret;\n\n\tif (value == 0)\n\t\tval &= ~(OV5645_SENSOR_MIRROR);\n\telse\n\t\tval |= (OV5645_SENSOR_MIRROR);\n\n\tret = ov5645_write_reg(ov5645, OV5645_TIMING_TC_REG21, val);\n\tif (!ret)\n\t\tov5645->timing_tc_reg21 = val;\n\n\treturn ret;\n}\n\nstatic int ov5645_set_vflip(struct ov5645 *ov5645, s32 value)\n{\n\tu8 val = ov5645->timing_tc_reg20;\n\tint ret;\n\n\tif (value == 0)\n\t\tval |= (OV5645_SENSOR_VFLIP | OV5645_ISP_VFLIP);\n\telse\n\t\tval &= ~(OV5645_SENSOR_VFLIP | OV5645_ISP_VFLIP);\n\n\tret = ov5645_write_reg(ov5645, OV5645_TIMING_TC_REG20, val);\n\tif (!ret)\n\t\tov5645->timing_tc_reg20 = val;\n\n\treturn ret;\n}\n\nstatic int ov5645_set_test_pattern(struct ov5645 *ov5645, s32 value)\n{\n\tu8 val = 0;\n\n\tif (value) {\n\t\tval = OV5645_SET_TEST_PATTERN(value - 1);\n\t\tval |= OV5645_TEST_PATTERN_ENABLE;\n\t}\n\n\treturn ov5645_write_reg(ov5645, OV5645_PRE_ISP_TEST_SETTING_1, val);\n}\n\nstatic const char * const ov5645_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Vertical Color Bars\",\n\t\"Pseudo-Random Data\",\n\t\"Color Square\",\n\t\"Black Image\",\n};\n\nstatic int ov5645_set_awb(struct ov5645 *ov5645, s32 enable_auto)\n{\n\tu8 val = 0;\n\n\tif (!enable_auto)\n\t\tval = OV5645_AWB_MANUAL_ENABLE;\n\n\treturn ov5645_write_reg(ov5645, OV5645_AWB_MANUAL_CONTROL, val);\n}\n\nstatic int ov5645_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ov5645 *ov5645 = container_of(ctrl->handler,\n\t\t\t\t\t     struct ov5645, ctrls);\n\tint ret;\n\n\tmutex_lock(&ov5645->power_lock);\n\tif (!pm_runtime_get_if_in_use(ov5645->dev)) {\n\t\tmutex_unlock(&ov5645->power_lock);\n\t\treturn 0;\n\t}\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_SATURATION:\n\t\tret = ov5645_set_saturation(ov5645, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\tret = ov5645_set_awb(ov5645, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\tret = ov5645_set_agc_mode(ov5645, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tret = ov5645_set_aec_mode(ov5645, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tret = ov5645_set_test_pattern(ov5645, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tret = ov5645_set_hflip(ov5645, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tret = ov5645_set_vflip(ov5645, ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tpm_runtime_mark_last_busy(ov5645->dev);\n\tpm_runtime_put_autosuspend(ov5645->dev);\n\tmutex_unlock(&ov5645->power_lock);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops ov5645_ctrl_ops = {\n\t.s_ctrl = ov5645_s_ctrl,\n};\n\nstatic int ov5645_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index > 0)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_UYVY8_1X16;\n\n\treturn 0;\n}\n\nstatic int ov5645_enum_frame_size(struct v4l2_subdev *subdev,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tif (fse->code != MEDIA_BUS_FMT_UYVY8_1X16)\n\t\treturn -EINVAL;\n\n\tif (fse->index >= ARRAY_SIZE(ov5645_mode_info_data))\n\t\treturn -EINVAL;\n\n\tfse->min_width = ov5645_mode_info_data[fse->index].width;\n\tfse->max_width = ov5645_mode_info_data[fse->index].width;\n\tfse->min_height = ov5645_mode_info_data[fse->index].height;\n\tfse->max_height = ov5645_mode_info_data[fse->index].height;\n\n\treturn 0;\n}\n\nstatic struct v4l2_mbus_framefmt *\n__ov5645_get_pad_format(struct ov5645 *ov5645,\n\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\tunsigned int pad,\n\t\t\tenum v4l2_subdev_format_whence which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\treturn v4l2_subdev_get_try_format(&ov5645->sd, sd_state, pad);\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &ov5645->fmt;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic int ov5645_get_format(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_format *format)\n{\n\tstruct ov5645 *ov5645 = to_ov5645(sd);\n\n\tformat->format = *__ov5645_get_pad_format(ov5645, sd_state,\n\t\t\t\t\t\t  format->pad,\n\t\t\t\t\t\t  format->which);\n\treturn 0;\n}\n\nstatic struct v4l2_rect *\n__ov5645_get_pad_crop(struct ov5645 *ov5645,\n\t\t      struct v4l2_subdev_state *sd_state,\n\t\t      unsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\treturn v4l2_subdev_get_try_crop(&ov5645->sd, sd_state, pad);\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &ov5645->crop;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic int ov5645_set_format(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_format *format)\n{\n\tstruct ov5645 *ov5645 = to_ov5645(sd);\n\tstruct v4l2_mbus_framefmt *__format;\n\tstruct v4l2_rect *__crop;\n\tconst struct ov5645_mode_info *new_mode;\n\tint ret;\n\n\t__crop = __ov5645_get_pad_crop(ov5645, sd_state, format->pad,\n\t\t\t\t       format->which);\n\n\tnew_mode = v4l2_find_nearest_size(ov5645_mode_info_data,\n\t\t\t       ARRAY_SIZE(ov5645_mode_info_data),\n\t\t\t       width, height,\n\t\t\t       format->format.width, format->format.height);\n\n\t__crop->width = new_mode->width;\n\t__crop->height = new_mode->height;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\tret = v4l2_ctrl_s_ctrl_int64(ov5645->pixel_clock,\n\t\t\t\t\t     new_mode->pixel_clock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = v4l2_ctrl_s_ctrl(ov5645->link_freq,\n\t\t\t\t       new_mode->link_freq);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tov5645->current_mode = new_mode;\n\t}\n\n\t__format = __ov5645_get_pad_format(ov5645, sd_state, format->pad,\n\t\t\t\t\t   format->which);\n\t__format->width = __crop->width;\n\t__format->height = __crop->height;\n\t__format->code = MEDIA_BUS_FMT_UYVY8_1X16;\n\t__format->field = V4L2_FIELD_NONE;\n\t__format->colorspace = V4L2_COLORSPACE_SRGB;\n\n\tformat->format = *__format;\n\n\treturn 0;\n}\n\nstatic int ov5645_entity_init_cfg(struct v4l2_subdev *subdev,\n\t\t\t\t  struct v4l2_subdev_state *sd_state)\n{\n\tstruct v4l2_subdev_format fmt = { 0 };\n\n\tfmt.which = sd_state ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\n\tfmt.format.width = 1920;\n\tfmt.format.height = 1080;\n\n\tov5645_set_format(subdev, sd_state, &fmt);\n\n\treturn 0;\n}\n\nstatic int ov5645_get_selection(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_selection *sel)\n{\n\tstruct ov5645 *ov5645 = to_ov5645(sd);\n\n\tif (sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\tsel->r = *__ov5645_get_pad_crop(ov5645, sd_state, sel->pad,\n\t\t\t\t\tsel->which);\n\treturn 0;\n}\n\nstatic int ov5645_s_stream(struct v4l2_subdev *subdev, int enable)\n{\n\tstruct ov5645 *ov5645 = to_ov5645(subdev);\n\tint ret;\n\n\tif (enable) {\n\t\tret = pm_runtime_resume_and_get(ov5645->dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = ov5645_set_register_array(ov5645,\n\t\t\t\t\tov5645->current_mode->data,\n\t\t\t\t\tov5645->current_mode->data_size);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ov5645->dev, \"could not set mode %dx%d\\n\",\n\t\t\t\tov5645->current_mode->width,\n\t\t\t\tov5645->current_mode->height);\n\t\t\tgoto err_rpm_put;\n\t\t}\n\t\tret = v4l2_ctrl_handler_setup(&ov5645->ctrls);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ov5645->dev, \"could not sync v4l2 controls\\n\");\n\t\t\tgoto err_rpm_put;\n\t\t}\n\n\t\tret = ov5645_write_reg(ov5645, OV5645_IO_MIPI_CTRL00, 0x45);\n\t\tif (ret < 0)\n\t\t\tgoto err_rpm_put;\n\n\t\tret = ov5645_write_reg(ov5645, OV5645_SYSTEM_CTRL0,\n\t\t\t\t       OV5645_SYSTEM_CTRL0_START);\n\t\tif (ret < 0)\n\t\t\tgoto err_rpm_put;\n\t} else {\n\t\tret = ov5645_write_reg(ov5645, OV5645_IO_MIPI_CTRL00, 0x40);\n\t\tif (ret < 0)\n\t\t\tgoto stream_off_rpm_put;\n\n\t\tret = ov5645_write_reg(ov5645, OV5645_SYSTEM_CTRL0,\n\t\t\t\t       OV5645_SYSTEM_CTRL0_STOP);\n\n\t\tgoto stream_off_rpm_put;\n\t}\n\n\treturn 0;\n\nerr_rpm_put:\n\tpm_runtime_put_sync(ov5645->dev);\n\treturn ret;\n\nstream_off_rpm_put:\n\tpm_runtime_mark_last_busy(ov5645->dev);\n\tpm_runtime_put_autosuspend(ov5645->dev);\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_video_ops ov5645_video_ops = {\n\t.s_stream = ov5645_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops ov5645_subdev_pad_ops = {\n\t.init_cfg = ov5645_entity_init_cfg,\n\t.enum_mbus_code = ov5645_enum_mbus_code,\n\t.enum_frame_size = ov5645_enum_frame_size,\n\t.get_fmt = ov5645_get_format,\n\t.set_fmt = ov5645_set_format,\n\t.get_selection = ov5645_get_selection,\n};\n\nstatic const struct v4l2_subdev_ops ov5645_subdev_ops = {\n\t.video = &ov5645_video_ops,\n\t.pad = &ov5645_subdev_pad_ops,\n};\n\nstatic int ov5645_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device_node *endpoint;\n\tstruct ov5645 *ov5645;\n\tu8 chip_id_high, chip_id_low;\n\tunsigned int i;\n\tu32 xclk_freq;\n\tint ret;\n\n\tov5645 = devm_kzalloc(dev, sizeof(struct ov5645), GFP_KERNEL);\n\tif (!ov5645)\n\t\treturn -ENOMEM;\n\n\tov5645->i2c_client = client;\n\tov5645->dev = dev;\n\n\tendpoint = of_graph_get_next_endpoint(dev->of_node, NULL);\n\tif (!endpoint) {\n\t\tdev_err(dev, \"endpoint node not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(endpoint),\n\t\t\t\t\t &ov5645->ep);\n\n\tof_node_put(endpoint);\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"parsing endpoint node failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (ov5645->ep.bus_type != V4L2_MBUS_CSI2_DPHY) {\n\t\tdev_err(dev, \"invalid bus type, must be CSI2\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tov5645->xclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(ov5645->xclk)) {\n\t\tdev_err(dev, \"could not get xclk\");\n\t\treturn PTR_ERR(ov5645->xclk);\n\t}\n\n\tret = of_property_read_u32(dev->of_node, \"clock-frequency\", &xclk_freq);\n\tif (ret) {\n\t\tdev_err(dev, \"could not get xclk frequency\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (xclk_freq < 23760000 || xclk_freq > 24240000) {\n\t\tdev_err(dev, \"external clock frequency %u is not supported\\n\",\n\t\t\txclk_freq);\n\t\treturn -EINVAL;\n\t}\n\n\tret = clk_set_rate(ov5645->xclk, xclk_freq);\n\tif (ret) {\n\t\tdev_err(dev, \"could not set xclk frequency\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < OV5645_NUM_SUPPLIES; i++)\n\t\tov5645->supplies[i].supply = ov5645_supply_name[i];\n\n\tret = devm_regulator_bulk_get(dev, OV5645_NUM_SUPPLIES,\n\t\t\t\t      ov5645->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tov5645->enable_gpio = devm_gpiod_get(dev, \"enable\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ov5645->enable_gpio)) {\n\t\tdev_err(dev, \"cannot get enable gpio\\n\");\n\t\treturn PTR_ERR(ov5645->enable_gpio);\n\t}\n\n\tov5645->rst_gpio = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ov5645->rst_gpio)) {\n\t\tdev_err(dev, \"cannot get reset gpio\\n\");\n\t\treturn PTR_ERR(ov5645->rst_gpio);\n\t}\n\n\tmutex_init(&ov5645->power_lock);\n\n\tv4l2_ctrl_handler_init(&ov5645->ctrls, 9);\n\tv4l2_ctrl_new_std(&ov5645->ctrls, &ov5645_ctrl_ops,\n\t\t\t  V4L2_CID_SATURATION, -4, 4, 1, 0);\n\tv4l2_ctrl_new_std(&ov5645->ctrls, &ov5645_ctrl_ops,\n\t\t\t  V4L2_CID_HFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(&ov5645->ctrls, &ov5645_ctrl_ops,\n\t\t\t  V4L2_CID_VFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(&ov5645->ctrls, &ov5645_ctrl_ops,\n\t\t\t  V4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\tv4l2_ctrl_new_std(&ov5645->ctrls, &ov5645_ctrl_ops,\n\t\t\t  V4L2_CID_AUTO_WHITE_BALANCE, 0, 1, 1, 1);\n\tv4l2_ctrl_new_std_menu(&ov5645->ctrls, &ov5645_ctrl_ops,\n\t\t\t       V4L2_CID_EXPOSURE_AUTO, V4L2_EXPOSURE_MANUAL,\n\t\t\t       0, V4L2_EXPOSURE_AUTO);\n\tv4l2_ctrl_new_std_menu_items(&ov5645->ctrls, &ov5645_ctrl_ops,\n\t\t\t\t     V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(ov5645_test_pattern_menu) - 1,\n\t\t\t\t     0, 0, ov5645_test_pattern_menu);\n\tov5645->pixel_clock = v4l2_ctrl_new_std(&ov5645->ctrls,\n\t\t\t\t\t\t&ov5645_ctrl_ops,\n\t\t\t\t\t\tV4L2_CID_PIXEL_RATE,\n\t\t\t\t\t\t1, INT_MAX, 1, 1);\n\tov5645->link_freq = v4l2_ctrl_new_int_menu(&ov5645->ctrls,\n\t\t\t\t\t\t   &ov5645_ctrl_ops,\n\t\t\t\t\t\t   V4L2_CID_LINK_FREQ,\n\t\t\t\t\t\t   ARRAY_SIZE(link_freq) - 1,\n\t\t\t\t\t\t   0, link_freq);\n\tif (ov5645->link_freq)\n\t\tov5645->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tov5645->sd.ctrl_handler = &ov5645->ctrls;\n\n\tif (ov5645->ctrls.error) {\n\t\tdev_err(dev, \"%s: control initialization error %d\\n\",\n\t\t       __func__, ov5645->ctrls.error);\n\t\tret = ov5645->ctrls.error;\n\t\tgoto free_ctrl;\n\t}\n\n\tv4l2_i2c_subdev_init(&ov5645->sd, client, &ov5645_subdev_ops);\n\tov5645->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tov5645->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tov5645->sd.dev = &client->dev;\n\tov5645->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\n\tret = media_entity_pads_init(&ov5645->sd.entity, 1, &ov5645->pad);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not register media entity\\n\");\n\t\tgoto free_ctrl;\n\t}\n\n\tret = ov5645_set_power_on(dev);\n\tif (ret)\n\t\tgoto free_entity;\n\n\tret = ov5645_read_reg(ov5645, OV5645_CHIP_ID_HIGH, &chip_id_high);\n\tif (ret < 0 || chip_id_high != OV5645_CHIP_ID_HIGH_BYTE) {\n\t\tdev_err(dev, \"could not read ID high\\n\");\n\t\tret = -ENODEV;\n\t\tgoto power_down;\n\t}\n\tret = ov5645_read_reg(ov5645, OV5645_CHIP_ID_LOW, &chip_id_low);\n\tif (ret < 0 || chip_id_low != OV5645_CHIP_ID_LOW_BYTE) {\n\t\tdev_err(dev, \"could not read ID low\\n\");\n\t\tret = -ENODEV;\n\t\tgoto power_down;\n\t}\n\n\tdev_info(dev, \"OV5645 detected at address 0x%02x\\n\", client->addr);\n\n\tret = ov5645_read_reg(ov5645, OV5645_AEC_PK_MANUAL,\n\t\t\t      &ov5645->aec_pk_manual);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not read AEC/AGC mode\\n\");\n\t\tret = -ENODEV;\n\t\tgoto power_down;\n\t}\n\n\tret = ov5645_read_reg(ov5645, OV5645_TIMING_TC_REG20,\n\t\t\t      &ov5645->timing_tc_reg20);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not read vflip value\\n\");\n\t\tret = -ENODEV;\n\t\tgoto power_down;\n\t}\n\n\tret = ov5645_read_reg(ov5645, OV5645_TIMING_TC_REG21,\n\t\t\t      &ov5645->timing_tc_reg21);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not read hflip value\\n\");\n\t\tret = -ENODEV;\n\t\tgoto power_down;\n\t}\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_enable(dev);\n\n\tov5645_entity_init_cfg(&ov5645->sd, NULL);\n\n\tret = v4l2_async_register_subdev(&ov5645->sd);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not register v4l2 device\\n\");\n\t\tgoto err_pm_runtime;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(dev, 1000);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n\nerr_pm_runtime:\n\tpm_runtime_disable(dev);\n\tpm_runtime_put_noidle(dev);\npower_down:\n\tov5645_set_power_off(dev);\nfree_entity:\n\tmedia_entity_cleanup(&ov5645->sd.entity);\nfree_ctrl:\n\tv4l2_ctrl_handler_free(&ov5645->ctrls);\n\tmutex_destroy(&ov5645->power_lock);\n\n\treturn ret;\n}\n\nstatic void ov5645_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov5645 *ov5645 = to_ov5645(sd);\n\n\tv4l2_async_unregister_subdev(&ov5645->sd);\n\tmedia_entity_cleanup(&ov5645->sd.entity);\n\tv4l2_ctrl_handler_free(&ov5645->ctrls);\n\tpm_runtime_disable(ov5645->dev);\n\tif (!pm_runtime_status_suspended(ov5645->dev))\n\t\tov5645_set_power_off(ov5645->dev);\n\tpm_runtime_set_suspended(ov5645->dev);\n\tmutex_destroy(&ov5645->power_lock);\n}\n\nstatic const struct i2c_device_id ov5645_id[] = {\n\t{ \"ov5645\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ov5645_id);\n\nstatic const struct of_device_id ov5645_of_match[] = {\n\t{ .compatible = \"ovti,ov5645\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ov5645_of_match);\n\nstatic const struct dev_pm_ops ov5645_pm_ops = {\n\tSET_RUNTIME_PM_OPS(ov5645_set_power_off, ov5645_set_power_on, NULL)\n};\n\nstatic struct i2c_driver ov5645_i2c_driver = {\n\t.driver = {\n\t\t.of_match_table = ov5645_of_match,\n\t\t.name  = \"ov5645\",\n\t\t.pm = &ov5645_pm_ops,\n\t},\n\t.probe = ov5645_probe,\n\t.remove = ov5645_remove,\n\t.id_table = ov5645_id,\n};\n\nmodule_i2c_driver(ov5645_i2c_driver);\n\nMODULE_DESCRIPTION(\"Omnivision OV5645 Camera Driver\");\nMODULE_AUTHOR(\"Todor Tomov <todor.tomov@linaro.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}