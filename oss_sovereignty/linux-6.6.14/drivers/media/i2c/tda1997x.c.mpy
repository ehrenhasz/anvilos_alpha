{
  "module_name": "tda1997x.c",
  "hash_id": "de2b0590c062cd56bfbdf5183102cb7e2618487c099bf71a4b8f71c03d35fbba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/tda1997x.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/hdmi.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/types.h>\n#include <linux/v4l2-dv-timings.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-dv-timings.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fwnode.h>\n#include <media/i2c/tda1997x.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include <dt-bindings/media/tda1997x.h>\n\n#include \"tda1997x_regs.h\"\n\n#define TDA1997X_MBUS_CODES\t5\n\n \nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"debug level (0-2)\");\n\n \nstatic const char * const audtype_names[] = {\n\t\"PCM\",\t\t\t \n\t\"HBR\",\t\t\t \n\t\"OBA\",\t\t\t \n\t\"DST\"\t\t\t \n};\n\n \nenum audfmt_types {\n\tAUDFMT_TYPE_DISABLED = 0,\n\tAUDFMT_TYPE_I2S,\n\tAUDFMT_TYPE_SPDIF,\n};\nstatic const char * const audfmt_names[] = {\n\t\"Disabled\",\n\t\"I2S\",\n\t\"SPDIF\",\n};\n\n \nstatic const char * const hdmi_colorspace_names[] = {\n\t\"RGB\", \"YUV422\", \"YUV444\", \"YUV420\", \"\", \"\", \"\", \"\",\n};\nstatic const char * const hdmi_colorimetry_names[] = {\n\t\"\", \"ITU601\", \"ITU709\", \"Extended\",\n};\nstatic const char * const v4l2_quantization_names[] = {\n\t\"Default\",\n\t\"Full Range (0-255)\",\n\t\"Limited Range (16-235)\",\n};\n\n \nstatic const char * const vidfmt_names[] = {\n\t\"RGB444/YUV444\",\t \n\t\"YUV422 semi-planar\",\t \n\t\"YUV422 CCIR656\",\t \n\t\"Invalid\",\n};\n\n \nstruct color_matrix_coefs {\n\tconst char *name;\n\t \n\ts16 offint1;\n\ts16 offint2;\n\ts16 offint3;\n\t \n\ts16 p11coef;\n\ts16 p12coef;\n\ts16 p13coef;\n\ts16 p21coef;\n\ts16 p22coef;\n\ts16 p23coef;\n\ts16 p31coef;\n\ts16 p32coef;\n\ts16 p33coef;\n\t \n\ts16 offout1;\n\ts16 offout2;\n\ts16 offout3;\n};\n\nenum {\n\tITU709_RGBFULL,\n\tITU601_RGBFULL,\n\tRGBLIMITED_RGBFULL,\n\tRGBLIMITED_ITU601,\n\tRGBLIMITED_ITU709,\n\tRGBFULL_ITU601,\n\tRGBFULL_ITU709,\n};\n\n \nstatic const struct color_matrix_coefs conv_matrix[] = {\n\t{\n\t\t\"YUV709 -> RGB full\",\n\t\t -256, -2048,  -2048,\n\t\t 4769, -2183,   -873,\n\t\t 4769,  7343,      0,\n\t\t 4769,     0,   8652,\n\t\t    0,     0,      0,\n\t},\n\t{\n\t\t\"YUV601 -> RGB full\",\n\t\t -256, -2048,  -2048,\n\t\t 4769, -3330,  -1602,\n\t\t 4769,  6538,      0,\n\t\t 4769,     0,   8264,\n\t\t  256,   256,    256,\n\t},\n\t{\n\t\t\"RGB limited -> RGB full\",\n\t\t -256,  -256,   -256,\n\t\t    0,  4769,      0,\n\t\t    0,     0,   4769,\n\t\t 4769,     0,      0,\n\t\t    0,     0,      0,\n\t},\n\t{\n\t\t\"RGB limited -> ITU601\",\n\t\t -256,  -256,   -256,\n\t\t 2404,  1225,    467,\n\t\t-1754,  2095,   -341,\n\t\t-1388,  -707,   2095,\n\t\t  256,  2048,   2048,\n\t},\n\t{\n\t\t\"RGB limited -> ITU709\",\n\t\t -256,  -256,   -256,\n\t\t 2918,   867,    295,\n\t\t-1894,  2087,   -190,\n\t\t-1607,  -477,   2087,\n\t\t  256,  2048,   2048,\n\t},\n\t{\n\t\t\"RGB full -> ITU601\",\n\t\t    0,     0,      0,\n\t\t 2065,  1052,    401,\n\t\t-1506,  1799,   -293,\n\t\t-1192,  -607,   1799,\n\t\t  256,  2048,   2048,\n\t},\n\t{\n\t\t\"RGB full -> ITU709\",\n\t\t    0,     0,      0,\n\t\t 2506,   745,    253,\n\t\t-1627,  1792,   -163,\n\t\t-1380,  -410,   1792,\n\t\t  256,  2048,   2048,\n\t},\n};\n\nstatic const struct v4l2_dv_timings_cap tda1997x_dv_timings_cap = {\n\t.type = V4L2_DV_BT_656_1120,\n\t \n\t.reserved = { 0 },\n\n\tV4L2_INIT_BT_TIMINGS(\n\t\t640, 1920,\t\t\t \n\t\t350, 1200,\t\t\t \n\t\t13000000, 165000000,\t\t \n\t\t \n\t\tV4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_DMT |\n\t\t\tV4L2_DV_BT_STD_GTF | V4L2_DV_BT_STD_CVT,\n\t\t \n\t\tV4L2_DV_BT_CAP_INTERLACED | V4L2_DV_BT_CAP_PROGRESSIVE |\n\t\t\tV4L2_DV_BT_CAP_REDUCED_BLANKING |\n\t\t\tV4L2_DV_BT_CAP_CUSTOM\n\t)\n};\n\n \nstatic const char * const tda1997x_supply_name[] = {\n\t\"DOVDD\",  \n\t\"DVDD\",   \n\t\"AVDD\",   \n};\n\n#define TDA1997X_NUM_SUPPLIES ARRAY_SIZE(tda1997x_supply_name)\n\nenum tda1997x_type {\n\tTDA19971,\n\tTDA19973,\n};\n\nenum tda1997x_hdmi_pads {\n\tTDA1997X_PAD_SOURCE,\n\tTDA1997X_NUM_PADS,\n};\n\nstruct tda1997x_chip_info {\n\tenum tda1997x_type type;\n\tconst char *name;\n};\n\nstruct tda1997x_state {\n\tconst struct tda1997x_chip_info *info;\n\tstruct tda1997x_platform_data pdata;\n\tstruct i2c_client *client;\n\tstruct i2c_client *client_cec;\n\tstruct v4l2_subdev sd;\n\tstruct regulator_bulk_data supplies[TDA1997X_NUM_SUPPLIES];\n\tstruct media_pad pads[TDA1997X_NUM_PADS];\n\tstruct mutex lock;\n\tstruct mutex page_lock;\n\tchar page;\n\n\t \n\tint chip_revision;\n\tchar port_30bit;\n\tchar output_2p5;\n\tchar tmdsb_clk;\n\tchar tmdsb_soc;\n\n\t \n\tchar hdmi_status;\n\tchar mptrw_in_progress;\n\tchar activity_status;\n\tchar input_detect[2];\n\n\t \n\tstruct hdmi_avi_infoframe avi_infoframe;\n\tstruct v4l2_hdmi_colorimetry colorimetry;\n\tu32 rgb_quantization_range;\n\tstruct v4l2_dv_timings timings;\n\tint fps;\n\tconst struct color_matrix_coefs *conv;\n\tu32 mbus_codes[TDA1997X_MBUS_CODES];\t \n\tu32 mbus_code;\t\t \n\tu8 vid_fmt;\n\n\t \n\tstruct v4l2_ctrl_handler hdl;\n\tstruct v4l2_ctrl *detect_tx_5v_ctrl;\n\tstruct v4l2_ctrl *rgb_quantization_range_ctrl;\n\n\t \n\tu8  audio_ch_alloc;\n\tint audio_samplerate;\n\tint audio_channels;\n\tint audio_samplesize;\n\tint audio_type;\n\tstruct mutex audio_lock;\n\tstruct snd_pcm_substream *audio_stream;\n\n\t \n\tstruct {\n\t\tu8 edid[256];\n\t\tu32 present;\n\t\tunsigned int blocks;\n\t} edid;\n\tstruct delayed_work delayed_work_enable_hpd;\n};\n\nstatic const struct v4l2_event tda1997x_ev_fmt = {\n\t.type = V4L2_EVENT_SOURCE_CHANGE,\n\t.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,\n};\n\nstatic const struct tda1997x_chip_info tda1997x_chip_info[] = {\n\t[TDA19971] = {\n\t\t.type = TDA19971,\n\t\t.name = \"tda19971\",\n\t},\n\t[TDA19973] = {\n\t\t.type = TDA19973,\n\t\t.name = \"tda19973\",\n\t},\n};\n\nstatic inline struct tda1997x_state *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct tda1997x_state, sd);\n}\n\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct tda1997x_state, hdl)->sd;\n}\n\nstatic int tda1997x_cec_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\tint val;\n\n\tval = i2c_smbus_read_byte_data(state->client_cec, reg);\n\tif (val < 0) {\n\t\tv4l_err(state->client, \"read reg error: reg=%2x\\n\", reg);\n\t\tval = -1;\n\t}\n\n\treturn val;\n}\n\nstatic int tda1997x_cec_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\tint ret = 0;\n\n\tret = i2c_smbus_write_byte_data(state->client_cec, reg, val);\n\tif (ret < 0) {\n\t\tv4l_err(state->client, \"write reg error:reg=%2x,val=%2x\\n\",\n\t\t\treg, val);\n\t\tret = -1;\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic int tda1997x_setpage(struct v4l2_subdev *sd, u8 page)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\tint ret;\n\n\tif (state->page != page) {\n\t\tret = i2c_smbus_write_byte_data(state->client,\n\t\t\tREG_CURPAGE_00H, page);\n\t\tif (ret < 0) {\n\t\t\tv4l_err(state->client,\n\t\t\t\t\"write reg error:reg=%2x,val=%2x\\n\",\n\t\t\t\tREG_CURPAGE_00H, page);\n\t\t\treturn ret;\n\t\t}\n\t\tstate->page = page;\n\t}\n\treturn 0;\n}\n\nstatic inline int io_read(struct v4l2_subdev *sd, u16 reg)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\tint val;\n\n\tmutex_lock(&state->page_lock);\n\tif (tda1997x_setpage(sd, reg >> 8)) {\n\t\tval = -1;\n\t\tgoto out;\n\t}\n\n\tval = i2c_smbus_read_byte_data(state->client, reg&0xff);\n\tif (val < 0) {\n\t\tv4l_err(state->client, \"read reg error: reg=%2x\\n\", reg & 0xff);\n\t\tval = -1;\n\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&state->page_lock);\n\treturn val;\n}\n\nstatic inline long io_read16(struct v4l2_subdev *sd, u16 reg)\n{\n\tint val;\n\tlong lval = 0;\n\n\tval = io_read(sd, reg);\n\tif (val < 0)\n\t\treturn val;\n\tlval |= (val << 8);\n\tval = io_read(sd, reg + 1);\n\tif (val < 0)\n\t\treturn val;\n\tlval |= val;\n\n\treturn lval;\n}\n\nstatic inline long io_read24(struct v4l2_subdev *sd, u16 reg)\n{\n\tint val;\n\tlong lval = 0;\n\n\tval = io_read(sd, reg);\n\tif (val < 0)\n\t\treturn val;\n\tlval |= (val << 16);\n\tval = io_read(sd, reg + 1);\n\tif (val < 0)\n\t\treturn val;\n\tlval |= (val << 8);\n\tval = io_read(sd, reg + 2);\n\tif (val < 0)\n\t\treturn val;\n\tlval |= val;\n\n\treturn lval;\n}\n\nstatic unsigned int io_readn(struct v4l2_subdev *sd, u16 reg, u8 len, u8 *data)\n{\n\tint i;\n\tint sz = 0;\n\tint val;\n\n\tfor (i = 0; i < len; i++) {\n\t\tval = io_read(sd, reg + i);\n\t\tif (val < 0)\n\t\t\tbreak;\n\t\tdata[i] = val;\n\t\tsz++;\n\t}\n\n\treturn sz;\n}\n\nstatic int io_write(struct v4l2_subdev *sd, u16 reg, u8 val)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\ts32 ret = 0;\n\n\tmutex_lock(&state->page_lock);\n\tif (tda1997x_setpage(sd, reg >> 8)) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tret = i2c_smbus_write_byte_data(state->client, reg & 0xff, val);\n\tif (ret < 0) {\n\t\tv4l_err(state->client, \"write reg error:reg=%2x,val=%2x\\n\",\n\t\t\treg&0xff, val);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&state->page_lock);\n\treturn ret;\n}\n\nstatic int io_write16(struct v4l2_subdev *sd, u16 reg, u16 val)\n{\n\tint ret;\n\n\tret = io_write(sd, reg, (val >> 8) & 0xff);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = io_write(sd, reg + 1, val & 0xff);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic int io_write24(struct v4l2_subdev *sd, u16 reg, u32 val)\n{\n\tint ret;\n\n\tret = io_write(sd, reg, (val >> 16) & 0xff);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = io_write(sd, reg + 1, (val >> 8) & 0xff);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = io_write(sd, reg + 2, val & 0xff);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\n \n\nenum hpd_mode {\n\tHPD_LOW_BP,\t \n\tHPD_LOW_OTHER,\t \n\tHPD_HIGH_BP,\t \n\tHPD_HIGH_OTHER,\n\tHPD_PULSE,\t \n};\n\n \nstatic int tda1997x_manual_hpd(struct v4l2_subdev *sd, enum hpd_mode mode)\n{\n\tu8 hpd_auto, hpd_pwr, hpd_man;\n\n\thpd_auto = io_read(sd, REG_HPD_AUTO_CTRL);\n\thpd_pwr = io_read(sd, REG_HPD_POWER);\n\thpd_man = io_read(sd, REG_HPD_MAN_CTRL);\n\n\t \n\thpd_man &= (HPD_MAN_CTRL_HPD_PULSE |\n\t\t    HPD_MAN_CTRL_5VEN |\n\t\t    HPD_MAN_CTRL_HPD_B |\n\t\t    HPD_MAN_CTRL_HPD_A);\n\n\tswitch (mode) {\n\t \n\tcase HPD_LOW_BP:\n\t\t \n\t\thpd_pwr &= ~HPD_POWER_BP_MASK;\n\t\t \n\t\thpd_man &= ~(HPD_MAN_CTRL_HPD_A | HPD_MAN_CTRL_HPD_B);\n\t\tio_write(sd, REG_HPD_POWER, hpd_pwr);\n\t\tio_write(sd, REG_HPD_MAN_CTRL, hpd_man);\n\t\tbreak;\n\t \n\tcase HPD_HIGH_BP:\n\t\t \n\t\thpd_pwr &= ~HPD_POWER_BP_MASK;\n\t\thpd_pwr |= 1 << HPD_POWER_BP_SHIFT;\n\t\tio_write(sd, REG_HPD_POWER, hpd_pwr);\n\t\tbreak;\n\t \n\tcase HPD_LOW_OTHER:\n\t\t \n\t\thpd_man &= ~(HPD_MAN_CTRL_HPD_A | HPD_MAN_CTRL_HPD_B);\n\t\t \n\t\thpd_auto &= ~HPD_AUTO_HP_OTHER;\n\t\tio_write(sd, REG_HPD_AUTO_CTRL, hpd_auto);\n\t\tio_write(sd, REG_HPD_MAN_CTRL, hpd_man);\n\t\tbreak;\n\t \n\tcase HPD_HIGH_OTHER:\n\t\thpd_auto |= HPD_AUTO_HP_OTHER;\n\t\tio_write(sd, REG_HPD_AUTO_CTRL, hpd_auto);\n\t\tbreak;\n\t \n\tcase HPD_PULSE:\n\t\t \n\t\thpd_man &= ~(HPD_MAN_CTRL_HPD_A | HPD_MAN_CTRL_HPD_B);\n\t\tio_write(sd, REG_HPD_MAN_CTRL, hpd_man);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void tda1997x_delayed_work_enable_hpd(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct tda1997x_state *state = container_of(dwork,\n\t\t\t\t\t\t    struct tda1997x_state,\n\t\t\t\t\t\t    delayed_work_enable_hpd);\n\tstruct v4l2_subdev *sd = &state->sd;\n\n\tv4l2_dbg(2, debug, sd, \"%s\\n\", __func__);\n\n\t \n\ttda1997x_manual_hpd(sd, HPD_HIGH_OTHER);\n\ttda1997x_manual_hpd(sd, HPD_HIGH_BP);\n\n\tstate->edid.present = 1;\n}\n\nstatic void tda1997x_disable_edid(struct v4l2_subdev *sd)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\n\tv4l2_dbg(1, debug, sd, \"%s\\n\", __func__);\n\tcancel_delayed_work_sync(&state->delayed_work_enable_hpd);\n\n\t \n\ttda1997x_manual_hpd(sd, HPD_LOW_BP);\n}\n\nstatic void tda1997x_enable_edid(struct v4l2_subdev *sd)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\n\tv4l2_dbg(1, debug, sd, \"%s\\n\", __func__);\n\n\t \n\tschedule_delayed_work(&state->delayed_work_enable_hpd, HZ / 10);\n}\n\n \n\n \nstatic int\ntda1997x_setup_format(struct tda1997x_state *state, u32 code)\n{\n\tv4l_dbg(1, debug, state->client, \"%s code=0x%x\\n\", __func__, code);\n\tswitch (code) {\n\tcase MEDIA_BUS_FMT_RGB121212_1X36:\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\tcase MEDIA_BUS_FMT_YUV12_1X36:\n\tcase MEDIA_BUS_FMT_YUV8_1X24:\n\t\tstate->vid_fmt = OF_FMT_444;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_UYVY12_1X24:\n\tcase MEDIA_BUS_FMT_UYVY10_1X20:\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\t\tstate->vid_fmt = OF_FMT_422_SMPT;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_UYVY12_2X12:\n\tcase MEDIA_BUS_FMT_UYVY10_2X10:\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\t\tstate->vid_fmt = OF_FMT_422_CCIR;\n\t\tbreak;\n\tdefault:\n\t\tv4l_err(state->client, \"incompatible format (0x%x)\\n\", code);\n\t\treturn -EINVAL;\n\t}\n\tv4l_dbg(1, debug, state->client, \"%s code=0x%x fmt=%s\\n\", __func__,\n\t\tcode, vidfmt_names[state->vid_fmt]);\n\tstate->mbus_code = code;\n\n\treturn 0;\n}\n\n \nstatic void\ntda1997x_configure_csc(struct v4l2_subdev *sd)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\tstruct hdmi_avi_infoframe *avi = &state->avi_infoframe;\n\tstruct v4l2_hdmi_colorimetry *c = &state->colorimetry;\n\t \n\tstruct blanking_codes {\n\t\ts16 code_gy;\n\t\ts16 code_bu;\n\t\ts16 code_rv;\n\t};\n\tstatic const struct blanking_codes rgb_blanking = { 64, 64, 64 };\n\tstatic const struct blanking_codes yuv_blanking = { 64, 512, 512 };\n\tconst struct blanking_codes *blanking_codes = NULL;\n\tu8 reg;\n\n\tv4l_dbg(1, debug, state->client, \"input:%s quant:%s output:%s\\n\",\n\t\thdmi_colorspace_names[avi->colorspace],\n\t\tv4l2_quantization_names[c->quantization],\n\t\tvidfmt_names[state->vid_fmt]);\n\tstate->conv = NULL;\n\tswitch (state->vid_fmt) {\n\t \n\tcase OF_FMT_444:\n\t\tblanking_codes = &rgb_blanking;\n\t\tif (c->colorspace == V4L2_COLORSPACE_SRGB) {\n\t\t\tif (c->quantization == V4L2_QUANTIZATION_LIM_RANGE)\n\t\t\t\tstate->conv = &conv_matrix[RGBLIMITED_RGBFULL];\n\t\t} else {\n\t\t\tif (c->colorspace == V4L2_COLORSPACE_REC709)\n\t\t\t\tstate->conv = &conv_matrix[ITU709_RGBFULL];\n\t\t\telse if (c->colorspace == V4L2_COLORSPACE_SMPTE170M)\n\t\t\t\tstate->conv = &conv_matrix[ITU601_RGBFULL];\n\t\t}\n\t\tbreak;\n\n\t \n\tcase OF_FMT_422_SMPT:  \n\tcase OF_FMT_422_CCIR:  \n\t\tblanking_codes = &yuv_blanking;\n\t\tif ((c->colorspace == V4L2_COLORSPACE_SRGB) &&\n\t\t    (c->quantization == V4L2_QUANTIZATION_FULL_RANGE)) {\n\t\t\tif (state->timings.bt.height <= 576)\n\t\t\t\tstate->conv = &conv_matrix[RGBFULL_ITU601];\n\t\t\telse\n\t\t\t\tstate->conv = &conv_matrix[RGBFULL_ITU709];\n\t\t} else if ((c->colorspace == V4L2_COLORSPACE_SRGB) &&\n\t\t\t   (c->quantization == V4L2_QUANTIZATION_LIM_RANGE)) {\n\t\t\tif (state->timings.bt.height <= 576)\n\t\t\t\tstate->conv = &conv_matrix[RGBLIMITED_ITU601];\n\t\t\telse\n\t\t\t\tstate->conv = &conv_matrix[RGBLIMITED_ITU709];\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (state->conv) {\n\t\tv4l_dbg(1, debug, state->client, \"%s\\n\",\n\t\t\tstate->conv->name);\n\t\t \n\t\treg = io_read(sd, REG_VDP_CTRL);\n\t\treg &= ~VDP_CTRL_MATRIX_BP;\n\t\tio_write(sd, REG_VDP_CTRL, reg);\n\t\t \n\t\tio_write16(sd, REG_VDP_MATRIX + 0, state->conv->offint1);\n\t\tio_write16(sd, REG_VDP_MATRIX + 2, state->conv->offint2);\n\t\tio_write16(sd, REG_VDP_MATRIX + 4, state->conv->offint3);\n\t\t \n\t\tio_write16(sd, REG_VDP_MATRIX + 6, state->conv->p11coef);\n\t\tio_write16(sd, REG_VDP_MATRIX + 8, state->conv->p12coef);\n\t\tio_write16(sd, REG_VDP_MATRIX + 10, state->conv->p13coef);\n\t\tio_write16(sd, REG_VDP_MATRIX + 12, state->conv->p21coef);\n\t\tio_write16(sd, REG_VDP_MATRIX + 14, state->conv->p22coef);\n\t\tio_write16(sd, REG_VDP_MATRIX + 16, state->conv->p23coef);\n\t\tio_write16(sd, REG_VDP_MATRIX + 18, state->conv->p31coef);\n\t\tio_write16(sd, REG_VDP_MATRIX + 20, state->conv->p32coef);\n\t\tio_write16(sd, REG_VDP_MATRIX + 22, state->conv->p33coef);\n\t\t \n\t\tio_write16(sd, REG_VDP_MATRIX + 24, state->conv->offout1);\n\t\tio_write16(sd, REG_VDP_MATRIX + 26, state->conv->offout2);\n\t\tio_write16(sd, REG_VDP_MATRIX + 28, state->conv->offout3);\n\t} else {\n\t\t \n\t\treg = io_read(sd, REG_VDP_CTRL);\n\t\treg |= VDP_CTRL_MATRIX_BP;\n\t\tio_write(sd, REG_VDP_CTRL, reg);\n\t}\n\n\t \n\tif (blanking_codes) {\n\t\tio_write16(sd, REG_BLK_GY, blanking_codes->code_gy);\n\t\tio_write16(sd, REG_BLK_BU, blanking_codes->code_bu);\n\t\tio_write16(sd, REG_BLK_RV, blanking_codes->code_rv);\n\t}\n}\n\n \nstatic void\ntda1997x_configure_vhref(struct v4l2_subdev *sd)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\tconst struct v4l2_bt_timings *bt = &state->timings.bt;\n\tint width, lines;\n\tu16 href_start, href_end;\n\tu16 vref_f1_start, vref_f2_start;\n\tu8 vref_f1_width, vref_f2_width;\n\tu8 field_polarity;\n\tu16 fieldref_f1_start, fieldref_f2_start;\n\tu8 reg;\n\n\thref_start = bt->hbackporch + bt->hsync + 1;\n\thref_end = href_start + bt->width;\n\tvref_f1_start = bt->height + bt->vbackporch + bt->vsync +\n\t\t\tbt->il_vbackporch + bt->il_vsync +\n\t\t\tbt->il_vfrontporch;\n\tvref_f1_width = bt->vbackporch + bt->vsync + bt->vfrontporch;\n\tvref_f2_start = 0;\n\tvref_f2_width = 0;\n\tfieldref_f1_start = 0;\n\tfieldref_f2_start = 0;\n\tif (bt->interlaced) {\n\t\tvref_f2_start = (bt->height / 2) +\n\t\t\t\t(bt->il_vbackporch + bt->il_vsync - 1);\n\t\tvref_f2_width = bt->il_vbackporch + bt->il_vsync +\n\t\t\t\tbt->il_vfrontporch;\n\t\tfieldref_f2_start = vref_f2_start + bt->il_vfrontporch +\n\t\t\t\t    fieldref_f1_start;\n\t}\n\tfield_polarity = 0;\n\n\twidth = V4L2_DV_BT_FRAME_WIDTH(bt);\n\tlines = V4L2_DV_BT_FRAME_HEIGHT(bt);\n\n\t \n\tio_write16(sd, REG_FDW_S, 0x2ef);  \n\tio_write16(sd, REG_FDW_E, 0x141);  \n\n\t \n\tif (state->chip_revision == 0)\n\t\tio_write16(sd, REG_PXCNT_PR, 4);\n\telse\n\t\tio_write16(sd, REG_PXCNT_PR, 1);\n\tio_write16(sd, REG_PXCNT_NPIX, width & MASK_VHREF);\n\tio_write16(sd, REG_LCNT_PR, 1);\n\tio_write16(sd, REG_LCNT_NLIN, lines & MASK_VHREF);\n\n\t \n\treg = VHREF_STD_DET_OFF << VHREF_STD_DET_SHIFT;\n\tio_write(sd, REG_VHREF_CTRL, reg);\n\n\t \n\t \n\tio_write16(sd, REG_HREF_S, href_start & MASK_VHREF);\n\tio_write16(sd, REG_HREF_E, href_end & MASK_VHREF);\n\t \n\tio_write16(sd, REG_VREF_F1_S, vref_f1_start & MASK_VHREF);\n\tio_write(sd, REG_VREF_F1_WIDTH, vref_f1_width);\n\t \n\tio_write16(sd, REG_VREF_F2_S, vref_f2_start & MASK_VHREF);\n\tio_write(sd, REG_VREF_F2_WIDTH, vref_f2_width);\n\n\t \n\treg = fieldref_f1_start & MASK_VHREF;\n\treg |= field_polarity << 8;\n\tio_write16(sd, REG_FREF_F1_S, reg);\n\treg = fieldref_f2_start & MASK_VHREF;\n\tio_write16(sd, REG_FREF_F2_S, reg);\n}\n\n \nstatic int\ntda1997x_configure_vidout(struct tda1997x_state *state)\n{\n\tstruct v4l2_subdev *sd = &state->sd;\n\tstruct tda1997x_platform_data *pdata = &state->pdata;\n\tu8 prefilter;\n\tu8 reg;\n\n\t \n\treg = (state->vid_fmt == OF_FMT_422_CCIR) ?\n\t       PCLK_SEL_X2 : PCLK_SEL_X1;\n\treg |= pdata->vidout_delay_pclk << PCLK_DELAY_SHIFT;\n\treg |= pdata->vidout_inv_pclk << PCLK_INV_SHIFT;\n\tio_write(sd, REG_PCLK, reg);\n\n\t \n\tprefilter = 0;  \n\t \n\tif ((state->vid_fmt == OF_FMT_422_SMPT) ||\n\t    (state->vid_fmt == OF_FMT_422_CCIR)) {\n\t\t \n\t\tprefilter = FILTERS_CTRL_2_7TAP << FILTERS_CTRL_BU_SHIFT |\n\t\t\t    FILTERS_CTRL_2_7TAP << FILTERS_CTRL_RV_SHIFT;\n\t}\n\tio_write(sd, REG_FILTERS_CTRL, prefilter);\n\n\t \n\treg = state->vid_fmt & OF_FMT_MASK;\n\tif (state->vid_fmt == OF_FMT_422_CCIR)\n\t\treg |= (OF_BLK | OF_TRC);\n\treg |= OF_VP_ENABLE;\n\tio_write(sd, REG_OF, reg);\n\n\t \n\treg = io_read(sd, REG_VDP_CTRL);\n\t \n\tif (!prefilter)\n\t\treg |= VDP_CTRL_PREFILTER_BP;\n\telse\n\t\treg &= ~VDP_CTRL_PREFILTER_BP;\n\t \n\tif (state->vid_fmt == OF_FMT_444)\n\t\treg |= VDP_CTRL_FORMATTER_BP;\n\t \n\telse\n\t\treg &= ~(VDP_CTRL_FORMATTER_BP | VDP_CTRL_COMPDEL_BP);\n\t \n\tif ((pdata->vidout_delay_vs < 4) || (pdata->vidout_delay_hs < 4))\n\t\treg &= ~VDP_CTRL_COMPDEL_BP;\n\tio_write(sd, REG_VDP_CTRL, reg);\n\n\t \n\treg = pdata->vidout_delay_de << DE_FREF_DELAY_SHIFT |\n\t      pdata->vidout_inv_de << DE_FREF_INV_SHIFT |\n\t      pdata->vidout_sel_de << DE_FREF_SEL_SHIFT;\n\tio_write(sd, REG_DE_FREF, reg);\n\n\t \n\tif (state->vid_fmt != OF_FMT_422_CCIR) {\n\t\treg = pdata->vidout_delay_hs << HS_HREF_DELAY_SHIFT |\n\t\t      pdata->vidout_inv_hs << HS_HREF_INV_SHIFT |\n\t\t      pdata->vidout_sel_hs << HS_HREF_SEL_SHIFT;\n\t} else\n\t\treg = HS_HREF_SEL_NONE << HS_HREF_SEL_SHIFT;\n\tio_write(sd, REG_HS_HREF, reg);\n\n\t \n\tif (state->vid_fmt != OF_FMT_422_CCIR) {\n\t\treg = pdata->vidout_delay_vs << VS_VREF_DELAY_SHIFT |\n\t\t      pdata->vidout_inv_vs << VS_VREF_INV_SHIFT |\n\t\t      pdata->vidout_sel_vs << VS_VREF_SEL_SHIFT;\n\t} else\n\t\treg = VS_VREF_SEL_NONE << VS_VREF_SEL_SHIFT;\n\tio_write(sd, REG_VS_VREF, reg);\n\n\treturn 0;\n}\n\n \nstatic int\ntda1997x_configure_audout(struct v4l2_subdev *sd, u8 channel_assignment)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\tstruct tda1997x_platform_data *pdata = &state->pdata;\n\tbool sp_used_by_fifo = true;\n\tu8 reg;\n\n\tif (!pdata->audout_format)\n\t\treturn 0;\n\n\t \n\tio_write(sd, REG_AUDIO_PATH, channel_assignment);\n\n\t \n\treg = 0;\n\tswitch (pdata->audout_format) {\n\tcase AUDFMT_TYPE_I2S:\n\t\treg |= AUDCFG_BUS_I2S << AUDCFG_BUS_SHIFT;\n\t\tbreak;\n\tcase AUDFMT_TYPE_SPDIF:\n\t\treg |= AUDCFG_BUS_SPDIF << AUDCFG_BUS_SHIFT;\n\t\tbreak;\n\t}\n\tswitch (state->audio_type) {\n\tcase AUDCFG_TYPE_PCM:\n\t\treg |= AUDCFG_TYPE_PCM << AUDCFG_TYPE_SHIFT;\n\t\tbreak;\n\tcase AUDCFG_TYPE_OBA:\n\t\treg |= AUDCFG_TYPE_OBA << AUDCFG_TYPE_SHIFT;\n\t\tbreak;\n\tcase AUDCFG_TYPE_DST:\n\t\treg |= AUDCFG_TYPE_DST << AUDCFG_TYPE_SHIFT;\n\t\tsp_used_by_fifo = false;\n\t\tbreak;\n\tcase AUDCFG_TYPE_HBR:\n\t\treg |= AUDCFG_TYPE_HBR << AUDCFG_TYPE_SHIFT;\n\t\tif (pdata->audout_layout == 1) {\n\t\t\t \n\t\t\treg |= AUDCFG_HBR_DEMUX << AUDCFG_HBR_SHIFT;\n\t\t\tif (pdata->audout_format == AUDFMT_TYPE_SPDIF)\n\t\t\t\tsp_used_by_fifo = false;\n\t\t} else {\n\t\t\t \n\t\t\treg |= AUDCFG_HBR_STRAIGHT << AUDCFG_HBR_SHIFT;\n\t\t}\n\t\tbreak;\n\t}\n\tif (pdata->audout_width == 32)\n\t\treg |= AUDCFG_I2SW_32 << AUDCFG_I2SW_SHIFT;\n\telse\n\t\treg |= AUDCFG_I2SW_16 << AUDCFG_I2SW_SHIFT;\n\n\t \n\tif (pdata->audio_auto_mute)\n\t\treg |= AUDCFG_AUTO_MUTE_EN;\n\t \n\tif (pdata->audout_invert_clk)\n\t\treg |= AUDCFG_CLK_INVERT;\n\tio_write(sd, REG_AUDCFG, reg);\n\n\t \n\treg = (pdata->audout_layout) ? AUDIO_LAYOUT_LAYOUT1 : 0;\n\tif (!pdata->audout_layoutauto)\n\t\treg |= AUDIO_LAYOUT_MANUAL;\n\tif (sp_used_by_fifo)\n\t\treg |= AUDIO_LAYOUT_SP_FLAG;\n\tio_write(sd, REG_AUDIO_LAYOUT, reg);\n\n\t \n\tio_write(sd, REG_FIFO_LATENCY_VAL, 0x80);\n\n\t \n\tif (sp_used_by_fifo) {\n\t\treg = AUDIO_OUT_ENABLE_AP0;\n\t\tif (channel_assignment >= 0x01)\n\t\t\treg |= AUDIO_OUT_ENABLE_AP1;\n\t\tif (channel_assignment >= 0x04)\n\t\t\treg |= AUDIO_OUT_ENABLE_AP2;\n\t\tif (channel_assignment >= 0x0c)\n\t\t\treg |= AUDIO_OUT_ENABLE_AP3;\n\t\t \n\t\tif ((channel_assignment == 0x04)\n\t\t || (channel_assignment == 0x08)\n\t\t || (channel_assignment == 0x0c)\n\t\t || (channel_assignment == 0x10)\n\t\t || (channel_assignment == 0x14)\n\t\t || (channel_assignment == 0x18)\n\t\t || (channel_assignment == 0x1c))\n\t\t\treg &= ~AUDIO_OUT_ENABLE_AP1;\n\t\t \n\t\tif ((channel_assignment >= 0x14)\n\t\t && (channel_assignment <= 0x17))\n\t\t\treg &= ~AUDIO_OUT_ENABLE_AP2;\n\t} else {\n\t\treg = AUDIO_OUT_ENABLE_AP3 |\n\t\t      AUDIO_OUT_ENABLE_AP2 |\n\t\t      AUDIO_OUT_ENABLE_AP1 |\n\t\t      AUDIO_OUT_ENABLE_AP0;\n\t}\n\tif (pdata->audout_format == AUDFMT_TYPE_I2S)\n\t\treg |= (AUDIO_OUT_ENABLE_ACLK | AUDIO_OUT_ENABLE_WS);\n\tio_write(sd, REG_AUDIO_OUT_ENABLE, reg);\n\n\t \n\tio_write(sd, REG_TEST_MODE, 0x00);\n\n\treturn 0;\n}\n\n \nstatic int\ntda1997x_hdmi_info_reset(struct v4l2_subdev *sd, u8 info_rst, bool reset_sus)\n{\n\tu8 reg;\n\n\t \n\treg = io_read(sd, REG_HDMI_INFO_RST);\n\tio_write(sd, REG_HDMI_INFO_RST, info_rst);\n\n\t \n\tif (reg & RESET_IF) {\n\t\treg = io_read(sd, REG_INT_FLG_CLR_MODE);\n\t\tio_write(sd, REG_INT_FLG_CLR_MODE, reg);\n\t}\n\n\t \n\treg = io_read(sd, REG_RATE_CTRL);\n\treg &= ~RATE_REFTIM_ENABLE;\n\tif (!reset_sus)\n\t\treg |= RATE_REFTIM_ENABLE;\n\treg = io_write(sd, REG_RATE_CTRL, reg);\n\n\treturn 0;\n}\n\nstatic void\ntda1997x_power_mode(struct tda1997x_state *state, bool enable)\n{\n\tstruct v4l2_subdev *sd = &state->sd;\n\tu8 reg;\n\n\tif (enable) {\n\t\t \n\t\tio_write(sd, REG_PON_OVR_EN, PON_DIS);\n\t\t \n\t\tio_write(sd, REG_CFG1, PON_EN);\n\t\t \n\t\tio_write(sd, REG_DEEP_PLL7_BYP, PON_DIS);\n\t\t \n\t\treg = io_read(sd, REG_OF);\n\t\treg &= ~OF_VP_ENABLE;\n\t\tio_write(sd, REG_OF, reg);\n\t} else {\n\t\t \n\t\t \n\t\treg = io_read(sd, REG_OF);\n\t\treg |= OF_VP_ENABLE;\n\t\tio_write(sd, REG_OF, reg);\n\t\t \n\t\tio_write(sd, REG_DEEP_PLL7_BYP, PON_EN);\n\t\t \n\t\tio_write(sd, REG_CFG1, PON_DIS);\n\t\t \n\t\tio_write(sd, REG_PON_OVR_EN, PON_EN);\n\t}\n}\n\nstatic bool\ntda1997x_detect_tx_5v(struct v4l2_subdev *sd)\n{\n\tu8 reg = io_read(sd, REG_DETECT_5V);\n\n\treturn ((reg & DETECT_5V_SEL) ? 1 : 0);\n}\n\nstatic bool\ntda1997x_detect_tx_hpd(struct v4l2_subdev *sd)\n{\n\tu8 reg = io_read(sd, REG_DETECT_5V);\n\n\treturn ((reg & DETECT_HPD) ? 1 : 0);\n}\n\nstatic int\ntda1997x_detect_std(struct tda1997x_state *state,\n\t\t    struct v4l2_dv_timings *timings)\n{\n\tstruct v4l2_subdev *sd = &state->sd;\n\n\t \n\tu32 vper, vsync_pos;\n\tu16 hper, hsync_pos, hsper, interlaced;\n\tu16 htot, hact, hfront, hsync, hback;\n\tu16 vtot, vact, vfront1, vfront2, vsync, vback1, vback2;\n\n\tif (!state->input_detect[0] && !state->input_detect[1])\n\t\treturn -ENOLINK;\n\n\tvper = io_read24(sd, REG_V_PER);\n\thper = io_read16(sd, REG_H_PER);\n\thsper = io_read16(sd, REG_HS_WIDTH);\n\tvsync_pos = vper & MASK_VPER_SYNC_POS;\n\thsync_pos = hper & MASK_HPER_SYNC_POS;\n\tinterlaced = hsper & MASK_HSWIDTH_INTERLACED;\n\tvper &= MASK_VPER;\n\thper &= MASK_HPER;\n\thsper &= MASK_HSWIDTH;\n\tv4l2_dbg(1, debug, sd, \"Signal Timings: %u/%u/%u\\n\", vper, hper, hsper);\n\n\thtot = io_read16(sd, REG_FMT_H_TOT);\n\thact = io_read16(sd, REG_FMT_H_ACT);\n\thfront = io_read16(sd, REG_FMT_H_FRONT);\n\thsync = io_read16(sd, REG_FMT_H_SYNC);\n\thback = io_read16(sd, REG_FMT_H_BACK);\n\n\tvtot = io_read16(sd, REG_FMT_V_TOT);\n\tvact = io_read16(sd, REG_FMT_V_ACT);\n\tvfront1 = io_read(sd, REG_FMT_V_FRONT_F1);\n\tvfront2 = io_read(sd, REG_FMT_V_FRONT_F2);\n\tvsync = io_read(sd, REG_FMT_V_SYNC);\n\tvback1 = io_read(sd, REG_FMT_V_BACK_F1);\n\tvback2 = io_read(sd, REG_FMT_V_BACK_F2);\n\n\tv4l2_dbg(1, debug, sd, \"Geometry: H %u %u %u %u %u Sync%c  V %u %u %u %u %u %u %u Sync%c\\n\",\n\t\t htot, hact, hfront, hsync, hback, hsync_pos ? '+' : '-',\n\t\t vtot, vact, vfront1, vfront2, vsync, vback1, vback2, vsync_pos ? '+' : '-');\n\n\tif (!timings)\n\t\treturn 0;\n\n\ttimings->type = V4L2_DV_BT_656_1120;\n\ttimings->bt.width = hact;\n\ttimings->bt.hfrontporch = hfront;\n\ttimings->bt.hsync = hsync;\n\ttimings->bt.hbackporch = hback;\n\ttimings->bt.height = vact;\n\ttimings->bt.vfrontporch = vfront1;\n\ttimings->bt.vsync = vsync;\n\ttimings->bt.vbackporch = vback1;\n\ttimings->bt.interlaced = interlaced ? V4L2_DV_INTERLACED : V4L2_DV_PROGRESSIVE;\n\ttimings->bt.polarities = vsync_pos ? V4L2_DV_VSYNC_POS_POL : 0;\n\ttimings->bt.polarities |= hsync_pos ? V4L2_DV_HSYNC_POS_POL : 0;\n\n\ttimings->bt.pixelclock = (u64)htot * vtot * 27000000;\n\tif (interlaced) {\n\t\ttimings->bt.il_vfrontporch = vfront2;\n\t\ttimings->bt.il_vsync = timings->bt.vsync;\n\t\ttimings->bt.il_vbackporch = vback2;\n\t\tdo_div(timings->bt.pixelclock, vper * 2  );\n\t} else {\n\t\ttimings->bt.il_vfrontporch = 0;\n\t\ttimings->bt.il_vsync = 0;\n\t\ttimings->bt.il_vbackporch = 0;\n\t\tdo_div(timings->bt.pixelclock, vper);\n\t}\n\tv4l2_find_dv_timings_cap(timings, &tda1997x_dv_timings_cap,\n\t\t\t\t (u32)timings->bt.pixelclock / 500, NULL, NULL);\n\tv4l2_print_dv_timings(sd->name, \"Detected format: \", timings, false);\n\treturn 0;\n}\n\n \nstatic void tda1997x_reset_n1(struct tda1997x_state *state)\n{\n\tstruct v4l2_subdev *sd = &state->sd;\n\tu8 reg;\n\n\t \n\tio_write(sd, REG_CLK_CFG, CLK_CFG_SEL_ACLK_EN | CLK_CFG_SEL_ACLK);\n\tio_write(sd, REG_PON_OVR_EN, PON_EN);\n\tio_write(sd, REG_PON_CBIAS, PON_EN);\n\tio_write(sd, REG_PON_PLL, PON_EN);\n\n\treg = io_read(sd, REG_MODE_REC_CFG1);\n\treg &= ~0x06;\n\treg |= 0x02;\n\tio_write(sd, REG_MODE_REC_CFG1, reg);\n\tio_write(sd, REG_CLK_CFG, CLK_CFG_DIS);\n\tio_write(sd, REG_PON_OVR_EN, PON_DIS);\n\treg = io_read(sd, REG_MODE_REC_CFG1);\n\treg &= ~0x06;\n\tio_write(sd, REG_MODE_REC_CFG1, reg);\n}\n\n \nstatic u8\ntda1997x_read_activity_status_regs(struct v4l2_subdev *sd)\n{\n\tu8 reg, status = 0;\n\n\t \n\treg = io_read(sd, REG_CLK_A_STATUS);\n\t \n\tif ((reg & MASK_CLK_STABLE) && !(reg & MASK_CLK_ACTIVE))\n\t\treg &= ~MASK_CLK_STABLE;\n\tstatus |= ((reg & MASK_CLK_STABLE) >> 2);\n\n\t \n\treg = io_read(sd, REG_CLK_B_STATUS);\n\t \n\tif ((reg & MASK_CLK_STABLE) && !(reg & MASK_CLK_ACTIVE))\n\t\treg &= ~MASK_CLK_STABLE;\n\tstatus |= ((reg & MASK_CLK_STABLE) >> 1);\n\n\t \n\treg = io_read(sd, REG_SUS_STATUS);\n\n\t \n\tif ((reg & MASK_SUS_STATUS) == LAST_STATE_REACHED)\n\t\tstatus |= MASK_SUS_STATE;\n\telse\n\t\tstatus &= ~MASK_SUS_STATE;\n\n\treturn status;\n}\n\nstatic void\nset_rgb_quantization_range(struct tda1997x_state *state)\n{\n\tstruct v4l2_hdmi_colorimetry *c = &state->colorimetry;\n\n\tstate->colorimetry = v4l2_hdmi_rx_colorimetry(&state->avi_infoframe,\n\t\t\t\t\t\t      NULL,\n\t\t\t\t\t\t      state->timings.bt.height);\n\t \n\tif (c->ycbcr_enc == V4L2_YCBCR_ENC_DEFAULT) {\n\t\tswitch (state->rgb_quantization_range) {\n\t\tcase V4L2_DV_RGB_RANGE_LIMITED:\n\t\t\tc->quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\t\t\tbreak;\n\t\tcase V4L2_DV_RGB_RANGE_FULL:\n\t\t\tc->quantization = V4L2_QUANTIZATION_LIM_RANGE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tv4l_dbg(1, debug, state->client,\n\t\t\"colorspace=%d/%d colorimetry=%d range=%s content=%d\\n\",\n\t\tstate->avi_infoframe.colorspace, c->colorspace,\n\t\tstate->avi_infoframe.colorimetry,\n\t\tv4l2_quantization_names[c->quantization],\n\t\tstate->avi_infoframe.content_type);\n}\n\n \nstatic unsigned int\ntda1997x_parse_infoframe(struct tda1997x_state *state, u16 addr)\n{\n\tstruct v4l2_subdev *sd = &state->sd;\n\tunion hdmi_infoframe frame;\n\tu8 buffer[40] = { 0 };\n\tu8 reg;\n\tint len, err;\n\n\t \n\tlen = io_readn(sd, addr, sizeof(buffer), buffer);\n\terr = hdmi_infoframe_unpack(&frame, buffer, len);\n\tif (err) {\n\t\tv4l_err(state->client,\n\t\t\t\"failed parsing %d byte infoframe: 0x%04x/0x%02x\\n\",\n\t\t\tlen, addr, buffer[0]);\n\t\treturn err;\n\t}\n\thdmi_infoframe_log(KERN_INFO, &state->client->dev, &frame);\n\tswitch (frame.any.type) {\n\t \n\tcase HDMI_INFOFRAME_TYPE_AUDIO:\n\t\t \n\t\tswitch (frame.audio.sample_frequency) {\n\t\tcase HDMI_AUDIO_SAMPLE_FREQUENCY_32000:\n\t\t\tstate->audio_samplerate = 32000;\n\t\t\tbreak;\n\t\tcase HDMI_AUDIO_SAMPLE_FREQUENCY_44100:\n\t\t\tstate->audio_samplerate = 44100;\n\t\t\tbreak;\n\t\tcase HDMI_AUDIO_SAMPLE_FREQUENCY_48000:\n\t\t\tstate->audio_samplerate = 48000;\n\t\t\tbreak;\n\t\tcase HDMI_AUDIO_SAMPLE_FREQUENCY_88200:\n\t\t\tstate->audio_samplerate = 88200;\n\t\t\tbreak;\n\t\tcase HDMI_AUDIO_SAMPLE_FREQUENCY_96000:\n\t\t\tstate->audio_samplerate = 96000;\n\t\t\tbreak;\n\t\tcase HDMI_AUDIO_SAMPLE_FREQUENCY_176400:\n\t\t\tstate->audio_samplerate = 176400;\n\t\t\tbreak;\n\t\tcase HDMI_AUDIO_SAMPLE_FREQUENCY_192000:\n\t\t\tstate->audio_samplerate = 192000;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase HDMI_AUDIO_SAMPLE_FREQUENCY_STREAM:\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tswitch (frame.audio.sample_size) {\n\t\tcase HDMI_AUDIO_SAMPLE_SIZE_16:\n\t\t\tstate->audio_samplesize = 16;\n\t\t\tbreak;\n\t\tcase HDMI_AUDIO_SAMPLE_SIZE_20:\n\t\t\tstate->audio_samplesize = 20;\n\t\t\tbreak;\n\t\tcase HDMI_AUDIO_SAMPLE_SIZE_24:\n\t\t\tstate->audio_samplesize = 24;\n\t\t\tbreak;\n\t\tcase HDMI_AUDIO_SAMPLE_SIZE_STREAM:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tstate->audio_channels = frame.audio.channels;\n\t\tif (frame.audio.channel_allocation &&\n\t\t    frame.audio.channel_allocation != state->audio_ch_alloc) {\n\t\t\t \n\t\t\tstate->audio_ch_alloc = frame.audio.channel_allocation;\n\t\t\ttda1997x_configure_audout(sd, state->audio_ch_alloc);\n\t\t\t \n\t\t\ttda1997x_hdmi_info_reset(sd, RESET_AUDIO, false);\n\t\t}\n\t\tbreak;\n\n\t \n\tcase HDMI_INFOFRAME_TYPE_AVI:\n\t\tstate->avi_infoframe = frame.avi;\n\t\tset_rgb_quantization_range(state);\n\n\t\t \n\t\treg = io_read(sd, REG_PIX_REPEAT);\n\t\treg &= ~PIX_REPEAT_MASK_UP_SEL;\n\t\tif (frame.avi.colorspace == HDMI_COLORSPACE_YUV422)\n\t\t\treg |= (PIX_REPEAT_CHROMA << PIX_REPEAT_SHIFT);\n\t\tio_write(sd, REG_PIX_REPEAT, reg);\n\n\t\t \n\t\treg = io_read(sd, REG_PIX_REPEAT);\n\t\treg &= ~PIX_REPEAT_MASK_REP;\n\t\treg |= frame.avi.pixel_repeat;\n\t\tio_write(sd, REG_PIX_REPEAT, reg);\n\n\t\t \n\t\ttda1997x_configure_csc(sd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void tda1997x_irq_sus(struct tda1997x_state *state, u8 *flags)\n{\n\tstruct v4l2_subdev *sd = &state->sd;\n\tu8 reg, source;\n\n\tsource = io_read(sd, REG_INT_FLG_CLR_SUS);\n\tio_write(sd, REG_INT_FLG_CLR_SUS, source);\n\n\tif (source & MASK_MPT) {\n\t\t \n\t\tif (state->mptrw_in_progress)\n\t\t\tstate->mptrw_in_progress = 0;\n\t}\n\n\tif (source & MASK_SUS_END) {\n\t\t \n\t\treg = io_read(sd, REG_HDMI_INFO_RST);\n\t\treg |= MASK_SR_FIFO_FIFO_CTRL;\n\t\tio_write(sd, REG_HDMI_INFO_RST, reg);\n\t\treg &= ~MASK_SR_FIFO_FIFO_CTRL;\n\t\tio_write(sd, REG_HDMI_INFO_RST, reg);\n\n\t\t \n\t\tstate->hdmi_status = 0;\n\t}\n\n\t \n\treg = io_read(sd, REG_SUS_STATUS);\n\tif (((reg & MASK_SUS_STATUS) != LAST_STATE_REACHED)\n\t   || (source & MASK_MPT)) {\n\t\tsource &= ~MASK_FMT;\n\t}\n\n\tif (source & (MASK_FMT | MASK_SUS_END)) {\n\t\treg = io_read(sd, REG_SUS_STATUS);\n\t\tif ((reg & MASK_SUS_STATUS) != LAST_STATE_REACHED) {\n\t\t\tv4l_err(state->client, \"BAD SUS STATUS\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (debug)\n\t\t\ttda1997x_detect_std(state, NULL);\n\t\t \n\t\tv4l2_subdev_notify_event(&state->sd, &tda1997x_ev_fmt);\n\t}\n}\n\nstatic void tda1997x_irq_ddc(struct tda1997x_state *state, u8 *flags)\n{\n\tstruct v4l2_subdev *sd = &state->sd;\n\tu8 source;\n\n\tsource = io_read(sd, REG_INT_FLG_CLR_DDC);\n\tio_write(sd, REG_INT_FLG_CLR_DDC, source);\n\tif (source & MASK_EDID_MTP) {\n\t\t \n\t\tif (state->mptrw_in_progress)\n\t\t\tstate->mptrw_in_progress = 0;\n\t}\n\n\t \n\tif (source & MASK_DET_5V) {\n\t\tv4l2_ctrl_s_ctrl(state->detect_tx_5v_ctrl,\n\t\t\t\t tda1997x_detect_tx_5v(sd));\n\t}\n}\n\nstatic void tda1997x_irq_rate(struct tda1997x_state *state, u8 *flags)\n{\n\tstruct v4l2_subdev *sd = &state->sd;\n\tu8 reg, source;\n\n\tu8 irq_status;\n\n\tsource = io_read(sd, REG_INT_FLG_CLR_RATE);\n\tio_write(sd, REG_INT_FLG_CLR_RATE, source);\n\n\t \n\tirq_status = tda1997x_read_activity_status_regs(sd);\n\n\t \n\treg = source;\n\twhile (reg != 0) {\n\t\tirq_status = tda1997x_read_activity_status_regs(sd);\n\t\treg = io_read(sd, REG_INT_FLG_CLR_RATE);\n\t\tio_write(sd, REG_INT_FLG_CLR_RATE, reg);\n\t\tsource |= reg;\n\t}\n\n\t \n\tif (source & (MASK_RATE_A_ST | MASK_RATE_B_ST)) {\n\t\tint input = (source & MASK_RATE_A_ST)?0:1;\n\t\tu8 mask = 1<<input;\n\n\t\t \n\t\tif ((irq_status & mask) != (state->activity_status & mask)) {\n\t\t\t \n\t\t\tif ((irq_status & mask) == 0) {\n\t\t\t\tv4l_info(state->client,\n\t\t\t\t\t \"HDMI-%c: Digital Activity Lost\\n\",\n\t\t\t\t\t input+'A');\n\n\t\t\t\t \n\t\t\t\treg = io_read(sd, REG_PIX_REPEAT);\n\t\t\t\treg &= ~PIX_REPEAT_MASK_UP_SEL;\n\t\t\t\treg &= ~PIX_REPEAT_MASK_REP;\n\t\t\t\tio_write(sd, REG_PIX_REPEAT, reg);\n\n\t\t\t\tif (state->chip_revision == 0)\n\t\t\t\t\ttda1997x_reset_n1(state);\n\n\t\t\t\tstate->input_detect[input] = 0;\n\t\t\t\tv4l2_subdev_notify_event(sd, &tda1997x_ev_fmt);\n\t\t\t}\n\n\t\t\t \n\t\t\telse {\n\t\t\t\tv4l_info(state->client,\n\t\t\t\t\t \"HDMI-%c: Digital Activity Detected\\n\",\n\t\t\t\t\t input+'A');\n\t\t\t\tstate->input_detect[input] = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tstate->activity_status = (irq_status & mask);\n\t\t}\n\t}\n}\n\nstatic void tda1997x_irq_info(struct tda1997x_state *state, u8 *flags)\n{\n\tstruct v4l2_subdev *sd = &state->sd;\n\tu8 source;\n\n\tsource = io_read(sd, REG_INT_FLG_CLR_INFO);\n\tio_write(sd, REG_INT_FLG_CLR_INFO, source);\n\n\t \n\tif (source & MASK_AUD_IF) {\n\t\ttda1997x_parse_infoframe(state, AUD_IF);\n\t\tsource &= ~MASK_AUD_IF;\n\t}\n\n\t \n\tif (source & MASK_SPD_IF) {\n\t\ttda1997x_parse_infoframe(state, SPD_IF);\n\t\tsource &= ~MASK_SPD_IF;\n\t}\n\n\t \n\tif (source & MASK_AVI_IF) {\n\t\ttda1997x_parse_infoframe(state, AVI_IF);\n\t\tsource &= ~MASK_AVI_IF;\n\t}\n}\n\nstatic void tda1997x_irq_audio(struct tda1997x_state *state, u8 *flags)\n{\n\tstruct v4l2_subdev *sd = &state->sd;\n\tu8 reg, source;\n\n\tsource = io_read(sd, REG_INT_FLG_CLR_AUDIO);\n\tio_write(sd, REG_INT_FLG_CLR_AUDIO, source);\n\n\t \n\tif (source & MASK_ERROR_FIFO_PT ||\n\t    source & MASK_MUTE_FLG) {\n\t\t \n\t\treg = io_read(sd, REG_SUS_STATUS);\n\t\tif ((reg & MASK_SUS_STATUS) == LAST_STATE_REACHED) {\n\t\t\treg = io_read(sd, REG_HDMI_INFO_RST);\n\t\t\treg |= MASK_SR_FIFO_FIFO_CTRL;\n\t\t\tio_write(sd, REG_HDMI_INFO_RST, reg);\n\t\t\treg &= ~MASK_SR_FIFO_FIFO_CTRL;\n\t\t\tio_write(sd, REG_HDMI_INFO_RST, reg);\n\t\t\t \n\t\t\tsource &= ~(MASK_CH_STATE);\n\t\t}\n\t}\n\tif (source & MASK_AUDIO_FREQ_FLG) {\n\t\tstatic const int freq[] = {\n\t\t\t0, 32000, 44100, 48000, 88200, 96000, 176400, 192000\n\t\t};\n\n\t\treg = io_read(sd, REG_AUDIO_FREQ);\n\t\tstate->audio_samplerate = freq[reg & 7];\n\t\tv4l_info(state->client, \"Audio Frequency Change: %dHz\\n\",\n\t\t\t state->audio_samplerate);\n\t}\n\tif (source & MASK_AUDIO_FLG) {\n\t\treg = io_read(sd, REG_AUDIO_FLAGS);\n\t\tif (reg & BIT(AUDCFG_TYPE_DST))\n\t\t\tstate->audio_type = AUDCFG_TYPE_DST;\n\t\tif (reg & BIT(AUDCFG_TYPE_OBA))\n\t\t\tstate->audio_type = AUDCFG_TYPE_OBA;\n\t\tif (reg & BIT(AUDCFG_TYPE_HBR))\n\t\t\tstate->audio_type = AUDCFG_TYPE_HBR;\n\t\tif (reg & BIT(AUDCFG_TYPE_PCM))\n\t\t\tstate->audio_type = AUDCFG_TYPE_PCM;\n\t\tv4l_info(state->client, \"Audio Type: %s\\n\",\n\t\t\t audtype_names[state->audio_type]);\n\t}\n}\n\nstatic void tda1997x_irq_hdcp(struct tda1997x_state *state, u8 *flags)\n{\n\tstruct v4l2_subdev *sd = &state->sd;\n\tu8 reg, source;\n\n\tsource = io_read(sd, REG_INT_FLG_CLR_HDCP);\n\tio_write(sd, REG_INT_FLG_CLR_HDCP, source);\n\n\t \n\tif (source & MASK_HDCP_MTP)\n\t\tstate->mptrw_in_progress = 0;\n\tif (source & MASK_STATE_C5) {\n\t\t \n\t\treg = io_read(sd, REG_INT_MASK_TOP);\n\t\treg &= ~(INTERRUPT_AUDIO | INTERRUPT_INFO);\n\t\tio_write(sd, REG_INT_MASK_TOP, reg);\n\t\t*flags &= (INTERRUPT_AUDIO | INTERRUPT_INFO);\n\t}\n}\n\nstatic irqreturn_t tda1997x_isr_thread(int irq, void *d)\n{\n\tstruct tda1997x_state *state = d;\n\tstruct v4l2_subdev *sd = &state->sd;\n\tu8 flags;\n\n\tmutex_lock(&state->lock);\n\tdo {\n\t\t \n\t\tflags = io_read(sd, REG_INT_FLG_CLR_TOP);\n\t\tif (flags == 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (flags & INTERRUPT_SUS)\n\t\t\ttda1997x_irq_sus(state, &flags);\n\t\t \n\t\telse if (flags & INTERRUPT_DDC)\n\t\t\ttda1997x_irq_ddc(state, &flags);\n\t\t \n\t\telse if (flags & INTERRUPT_RATE)\n\t\t\ttda1997x_irq_rate(state, &flags);\n\t\t \n\t\telse if (flags & INTERRUPT_INFO)\n\t\t\ttda1997x_irq_info(state, &flags);\n\t\t \n\t\telse if (flags & INTERRUPT_AUDIO)\n\t\t\ttda1997x_irq_audio(state, &flags);\n\t\t \n\t\tif (flags & INTERRUPT_HDCP)\n\t\t\ttda1997x_irq_hdcp(state, &flags);\n\t} while (flags != 0);\n\tmutex_unlock(&state->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int\ntda1997x_g_input_status(struct v4l2_subdev *sd, u32 *status)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\tu32 vper;\n\tu16 hper;\n\tu16 hsper;\n\n\tmutex_lock(&state->lock);\n\tvper = io_read24(sd, REG_V_PER) & MASK_VPER;\n\thper = io_read16(sd, REG_H_PER) & MASK_HPER;\n\thsper = io_read16(sd, REG_HS_WIDTH) & MASK_HSWIDTH;\n\t \n\tv4l2_dbg(1, debug, sd, \"inputs:%d/%d timings:%d/%d/%d\\n\",\n\t\t state->input_detect[0], state->input_detect[1],\n\t\t vper, hper, hsper);\n\tif (!state->input_detect[0] && !state->input_detect[1])\n\t\t*status = V4L2_IN_ST_NO_SIGNAL;\n\telse if (!vper || !hper || !hsper)\n\t\t*status = V4L2_IN_ST_NO_SYNC;\n\telse\n\t\t*status = 0;\n\tmutex_unlock(&state->lock);\n\n\treturn 0;\n};\n\nstatic int tda1997x_s_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_dv_timings *timings)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\n\tv4l_dbg(1, debug, state->client, \"%s\\n\", __func__);\n\n\tif (v4l2_match_dv_timings(&state->timings, timings, 0, false))\n\t\treturn 0;  \n\n\tif (!v4l2_valid_dv_timings(timings, &tda1997x_dv_timings_cap,\n\t\t\t\t   NULL, NULL))\n\t\treturn -ERANGE;\n\n\tmutex_lock(&state->lock);\n\tstate->timings = *timings;\n\t \n\ttda1997x_configure_vhref(sd);\n\t \n\ttda1997x_configure_csc(sd);\n\tmutex_unlock(&state->lock);\n\n\treturn 0;\n}\n\nstatic int tda1997x_g_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_dv_timings *timings)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\n\tv4l_dbg(1, debug, state->client, \"%s\\n\", __func__);\n\tmutex_lock(&state->lock);\n\t*timings = state->timings;\n\tmutex_unlock(&state->lock);\n\n\treturn 0;\n}\n\nstatic int tda1997x_query_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_dv_timings *timings)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\tint ret;\n\n\tv4l_dbg(1, debug, state->client, \"%s\\n\", __func__);\n\tmemset(timings, 0, sizeof(struct v4l2_dv_timings));\n\tmutex_lock(&state->lock);\n\tret = tda1997x_detect_std(state, timings);\n\tmutex_unlock(&state->lock);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_video_ops tda1997x_video_ops = {\n\t.g_input_status = tda1997x_g_input_status,\n\t.s_dv_timings = tda1997x_s_dv_timings,\n\t.g_dv_timings = tda1997x_g_dv_timings,\n\t.query_dv_timings = tda1997x_query_dv_timings,\n};\n\n\n \n\nstatic int tda1997x_init_cfg(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *sd_state)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\tstruct v4l2_mbus_framefmt *mf;\n\n\tmf = v4l2_subdev_get_try_format(sd, sd_state, 0);\n\tmf->code = state->mbus_codes[0];\n\n\treturn 0;\n}\n\nstatic int tda1997x_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\n\tv4l_dbg(1, debug, state->client, \"%s %d\\n\", __func__, code->index);\n\tif (code->index >= ARRAY_SIZE(state->mbus_codes))\n\t\treturn -EINVAL;\n\n\tif (!state->mbus_codes[code->index])\n\t\treturn -EINVAL;\n\n\tcode->code = state->mbus_codes[code->index];\n\n\treturn 0;\n}\n\nstatic void tda1997x_fill_format(struct tda1997x_state *state,\n\t\t\t\t struct v4l2_mbus_framefmt *format)\n{\n\tconst struct v4l2_bt_timings *bt;\n\n\tmemset(format, 0, sizeof(*format));\n\tbt = &state->timings.bt;\n\tformat->width = bt->width;\n\tformat->height = bt->height;\n\tformat->colorspace = state->colorimetry.colorspace;\n\tformat->field = (bt->interlaced) ?\n\t\tV4L2_FIELD_SEQ_TB : V4L2_FIELD_NONE;\n}\n\nstatic int tda1997x_get_format(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_format *format)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\n\tv4l_dbg(1, debug, state->client, \"%s pad=%d which=%d\\n\",\n\t\t__func__, format->pad, format->which);\n\n\ttda1997x_fill_format(state, &format->format);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tstruct v4l2_mbus_framefmt *fmt;\n\n\t\tfmt = v4l2_subdev_get_try_format(sd, sd_state, format->pad);\n\t\tformat->format.code = fmt->code;\n\t} else\n\t\tformat->format.code = state->mbus_code;\n\n\treturn 0;\n}\n\nstatic int tda1997x_set_format(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_format *format)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\tu32 code = 0;\n\tint i;\n\n\tv4l_dbg(1, debug, state->client, \"%s pad=%d which=%d fmt=0x%x\\n\",\n\t\t__func__, format->pad, format->which, format->format.code);\n\n\tfor (i = 0; i < ARRAY_SIZE(state->mbus_codes); i++) {\n\t\tif (format->format.code == state->mbus_codes[i]) {\n\t\t\tcode = state->mbus_codes[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!code)\n\t\tcode = state->mbus_codes[0];\n\n\ttda1997x_fill_format(state, &format->format);\n\tformat->format.code = code;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tstruct v4l2_mbus_framefmt *fmt;\n\n\t\tfmt = v4l2_subdev_get_try_format(sd, sd_state, format->pad);\n\t\t*fmt = format->format;\n\t} else {\n\t\tint ret = tda1997x_setup_format(state, format->format.code);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\ttda1997x_configure_csc(sd);\n\t\ttda1997x_configure_vidout(state);\n\t}\n\n\treturn 0;\n}\n\nstatic int tda1997x_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\n\tv4l_dbg(1, debug, state->client, \"%s pad=%d\\n\", __func__, edid->pad);\n\tmemset(edid->reserved, 0, sizeof(edid->reserved));\n\n\tif (edid->start_block == 0 && edid->blocks == 0) {\n\t\tedid->blocks = state->edid.blocks;\n\t\treturn 0;\n\t}\n\n\tif (!state->edid.present)\n\t\treturn -ENODATA;\n\n\tif (edid->start_block >= state->edid.blocks)\n\t\treturn -EINVAL;\n\n\tif (edid->start_block + edid->blocks > state->edid.blocks)\n\t\tedid->blocks = state->edid.blocks - edid->start_block;\n\n\tmemcpy(edid->edid, state->edid.edid + edid->start_block * 128,\n\t       edid->blocks * 128);\n\n\treturn 0;\n}\n\nstatic int tda1997x_set_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\tint i;\n\n\tv4l_dbg(1, debug, state->client, \"%s pad=%d\\n\", __func__, edid->pad);\n\tmemset(edid->reserved, 0, sizeof(edid->reserved));\n\n\tif (edid->start_block != 0)\n\t\treturn -EINVAL;\n\n\tif (edid->blocks == 0) {\n\t\tstate->edid.blocks = 0;\n\t\tstate->edid.present = 0;\n\t\ttda1997x_disable_edid(sd);\n\t\treturn 0;\n\t}\n\n\tif (edid->blocks > 2) {\n\t\tedid->blocks = 2;\n\t\treturn -E2BIG;\n\t}\n\n\ttda1997x_disable_edid(sd);\n\n\t \n\tfor (i = 0; i < 128; i++)\n\t\tio_write(sd, REG_EDID_IN_BYTE0 + i, edid->edid[i]);\n\n\t \n\tfor (i = 0; i < 128; i++)\n\t\tio_write(sd, REG_EDID_IN_BYTE128 + i, edid->edid[i+128]);\n\n\t \n\tmemcpy(state->edid.edid, edid->edid, 256);\n\tstate->edid.blocks = edid->blocks;\n\n\ttda1997x_enable_edid(sd);\n\n\treturn 0;\n}\n\nstatic int tda1997x_get_dv_timings_cap(struct v4l2_subdev *sd,\n\t\t\t\t       struct v4l2_dv_timings_cap *cap)\n{\n\t*cap = tda1997x_dv_timings_cap;\n\treturn 0;\n}\n\nstatic int tda1997x_enum_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_enum_dv_timings *timings)\n{\n\treturn v4l2_enum_dv_timings_cap(timings, &tda1997x_dv_timings_cap,\n\t\t\t\t\tNULL, NULL);\n}\n\nstatic const struct v4l2_subdev_pad_ops tda1997x_pad_ops = {\n\t.init_cfg = tda1997x_init_cfg,\n\t.enum_mbus_code = tda1997x_enum_mbus_code,\n\t.get_fmt = tda1997x_get_format,\n\t.set_fmt = tda1997x_set_format,\n\t.get_edid = tda1997x_get_edid,\n\t.set_edid = tda1997x_set_edid,\n\t.dv_timings_cap = tda1997x_get_dv_timings_cap,\n\t.enum_dv_timings = tda1997x_enum_dv_timings,\n};\n\n \n\nstatic int tda1997x_log_infoframe(struct v4l2_subdev *sd, int addr)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\tunion hdmi_infoframe frame;\n\tu8 buffer[40] = { 0 };\n\tint len, err;\n\n\t \n\tlen = io_readn(sd, addr, sizeof(buffer), buffer);\n\tv4l2_dbg(1, debug, sd, \"infoframe: addr=%d len=%d\\n\", addr, len);\n\terr = hdmi_infoframe_unpack(&frame, buffer, len);\n\tif (err) {\n\t\tv4l_err(state->client,\n\t\t\t\"failed parsing %d byte infoframe: 0x%04x/0x%02x\\n\",\n\t\t\tlen, addr, buffer[0]);\n\t\treturn err;\n\t}\n\thdmi_infoframe_log(KERN_INFO, &state->client->dev, &frame);\n\n\treturn 0;\n}\n\nstatic int tda1997x_log_status(struct v4l2_subdev *sd)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\tstruct v4l2_dv_timings timings;\n\tstruct hdmi_avi_infoframe *avi = &state->avi_infoframe;\n\n\tv4l2_info(sd, \"-----Chip status-----\\n\");\n\tv4l2_info(sd, \"Chip: %s N%d\\n\", state->info->name,\n\t\t  state->chip_revision + 1);\n\tv4l2_info(sd, \"EDID Enabled: %s\\n\", state->edid.present ? \"yes\" : \"no\");\n\n\tv4l2_info(sd, \"-----Signal status-----\\n\");\n\tv4l2_info(sd, \"Cable detected (+5V power): %s\\n\",\n\t\t  tda1997x_detect_tx_5v(sd) ? \"yes\" : \"no\");\n\tv4l2_info(sd, \"HPD detected: %s\\n\",\n\t\t  tda1997x_detect_tx_hpd(sd) ? \"yes\" : \"no\");\n\n\tv4l2_info(sd, \"-----Video Timings-----\\n\");\n\tswitch (tda1997x_detect_std(state, &timings)) {\n\tcase -ENOLINK:\n\t\tv4l2_info(sd, \"No video detected\\n\");\n\t\tbreak;\n\tcase -ERANGE:\n\t\tv4l2_info(sd, \"Invalid signal detected\\n\");\n\t\tbreak;\n\t}\n\tv4l2_print_dv_timings(sd->name, \"Configured format: \",\n\t\t\t      &state->timings, true);\n\n\tv4l2_info(sd, \"-----Color space-----\\n\");\n\tv4l2_info(sd, \"Input color space: %s %s %s\",\n\t\t  hdmi_colorspace_names[avi->colorspace],\n\t\t  (avi->colorspace == HDMI_COLORSPACE_RGB) ? \"\" :\n\t\t\thdmi_colorimetry_names[avi->colorimetry],\n\t\t  v4l2_quantization_names[state->colorimetry.quantization]);\n\tv4l2_info(sd, \"Output color space: %s\",\n\t\t  vidfmt_names[state->vid_fmt]);\n\tv4l2_info(sd, \"Color space conversion: %s\", state->conv ?\n\t\t  state->conv->name : \"None\");\n\n\tv4l2_info(sd, \"-----Audio-----\\n\");\n\tif (state->audio_channels) {\n\t\tv4l2_info(sd, \"audio: %dch %dHz\\n\", state->audio_channels,\n\t\t\t  state->audio_samplerate);\n\t} else {\n\t\tv4l2_info(sd, \"audio: none\\n\");\n\t}\n\n\tv4l2_info(sd, \"-----Infoframes-----\\n\");\n\ttda1997x_log_infoframe(sd, AUD_IF);\n\ttda1997x_log_infoframe(sd, SPD_IF);\n\ttda1997x_log_infoframe(sd, AVI_IF);\n\n\treturn 0;\n}\n\nstatic int tda1997x_subscribe_event(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_fh *fh,\n\t\t\t\t    struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\treturn v4l2_src_change_event_subdev_subscribe(sd, fh, sub);\n\tcase V4L2_EVENT_CTRL:\n\t\treturn v4l2_ctrl_subdev_subscribe_event(sd, fh, sub);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct v4l2_subdev_core_ops tda1997x_core_ops = {\n\t.log_status = tda1997x_log_status,\n\t.subscribe_event = tda1997x_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n};\n\n \n\nstatic const struct v4l2_subdev_ops tda1997x_subdev_ops = {\n\t.core = &tda1997x_core_ops,\n\t.video = &tda1997x_video_ops,\n\t.pad = &tda1997x_pad_ops,\n};\n\n \n\nstatic int tda1997x_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\tstruct tda1997x_state *state = to_state(sd);\n\n\tswitch (ctrl->id) {\n\t \n\tcase V4L2_CID_DV_RX_RGB_RANGE:\n\t\tstate->rgb_quantization_range = ctrl->val;\n\t\tset_rgb_quantization_range(state);\n\t\ttda1997x_configure_csc(sd);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n};\n\nstatic int tda1997x_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\tstruct tda1997x_state *state = to_state(sd);\n\n\tif (ctrl->id == V4L2_CID_DV_RX_IT_CONTENT_TYPE) {\n\t\tctrl->val = state->avi_infoframe.content_type;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n};\n\nstatic const struct v4l2_ctrl_ops tda1997x_ctrl_ops = {\n\t.s_ctrl = tda1997x_s_ctrl,\n\t.g_volatile_ctrl = tda1997x_g_volatile_ctrl,\n};\n\nstatic int tda1997x_core_init(struct v4l2_subdev *sd)\n{\n\tstruct tda1997x_state *state = to_state(sd);\n\tstruct tda1997x_platform_data *pdata = &state->pdata;\n\tu8 reg;\n\tint i;\n\n\t \n\tio_write(sd, REG_HPD_AUTO_CTRL, HPD_AUTO_HPD_UNSEL);\n\tif (state->chip_revision == 0) {\n\t\tio_write(sd, REG_MAN_SUS_HDMI_SEL, MAN_DIS_HDCP | MAN_RST_HDCP);\n\t\tio_write(sd, REG_CGU_DBG_SEL, 1 << CGU_DBG_CLK_SEL_SHIFT);\n\t}\n\n\t \n\tio_write(sd, REG_SUS_SET_RGB2, 0x06);\n\tio_write(sd, REG_SUS_SET_RGB3, 0x06);\n\n\t \n\tio_write(sd, REG_RT_MAN_CTRL, RT_MAN_CTRL_RT |\n\t\t RT_MAN_CTRL_RT_B | RT_MAN_CTRL_RT_A);\n\n\t \n\ttda1997x_cec_write(sd, REG_PWR_CONTROL & 0xff, 0x04);\n\t \n\ttda1997x_cec_write(sd, REG_OSC_DIVIDER & 0xff, 0x03);\n\ttda1997x_cec_write(sd, REG_EN_OSC_PERIOD_LSB & 0xff, 0xa0);\n\tio_write(sd, REG_TIMER_D, 0x54);\n\t \n\treg = tda1997x_cec_read(sd, REG_CONTROL & 0xff);\n\treg |= 0x20;\n\ttda1997x_cec_write(sd, REG_CONTROL & 0xff, reg);\n\tmdelay(50);\n\n\t \n\treg = io_read(sd, REG_VERSION);\n\t \n\treg = io_read(sd, REG_CMTP_REG10);\n\n\t \n\tio_write(sd, REG_INT_MASK_TOP,\n\t\t INTERRUPT_HDCP | INTERRUPT_AUDIO | INTERRUPT_INFO |\n\t\t INTERRUPT_RATE | INTERRUPT_SUS);\n\t \n\tio_write(sd, REG_INT_MASK_SUS, MASK_MPT | MASK_FMT | MASK_SUS_END);\n\t \n\tio_write(sd, REG_INT_MASK_RATE, MASK_RATE_B_ST | MASK_RATE_A_ST);\n\t \n\tio_write(sd, REG_INT_MASK_INFO,\n\t\t MASK_AUD_IF | MASK_SPD_IF | MASK_AVI_IF);\n\t \n\tio_write(sd, REG_INT_MASK_AUDIO,\n\t\t MASK_AUDIO_FREQ_FLG | MASK_AUDIO_FLG | MASK_MUTE_FLG |\n\t\t MASK_ERROR_FIFO_PT);\n\t \n\tio_write(sd, REG_INT_MASK_HDCP, MASK_STATE_C5);\n\t \n\tio_write(sd, REG_INT_MASK_DDC, MASK_DET_5V);\n\t \n\tio_write(sd, REG_INT_MASK_AFE, 0);\n\tio_write(sd, REG_INT_MASK_MODE, 0);\n\n\t \n\tio_write(sd, REG_INT_FLG_CLR_TOP, 0xff);\n\tio_write(sd, REG_INT_FLG_CLR_SUS, 0xff);\n\tio_write(sd, REG_INT_FLG_CLR_DDC, 0xff);\n\tio_write(sd, REG_INT_FLG_CLR_RATE, 0xff);\n\tio_write(sd, REG_INT_FLG_CLR_MODE, 0xff);\n\tio_write(sd, REG_INT_FLG_CLR_INFO, 0xff);\n\tio_write(sd, REG_INT_FLG_CLR_AUDIO, 0xff);\n\tio_write(sd, REG_INT_FLG_CLR_HDCP, 0xff);\n\tio_write(sd, REG_INT_FLG_CLR_AFE, 0xff);\n\n\t \n\tif (state->chip_revision == 0)\n\t\tio_write(sd, REG_CGU_DBG_SEL, 1 << CGU_DBG_CLK_SEL_SHIFT);\n\tio_write24(sd, REG_CLK_MIN_RATE, CLK_MIN_RATE);\n\tio_write24(sd, REG_CLK_MAX_RATE, CLK_MAX_RATE);\n\tif (state->chip_revision == 0)\n\t\tio_write(sd, REG_WDL_CFG, WDL_CFG_VAL);\n\t \n\tio_write(sd, REG_DEEP_COLOR_CTRL, DC_FILTER_VAL);\n\t \n\tio_write(sd, REG_SVC_MODE, 0x00);\n\t \n\tio_write(sd, REG_INFO_CTRL, 0xff);\n\t \n\tio_write(sd, REG_INFO_EXCEED, 3);\n\n\tif (state->chip_revision == 0)\n\t\ttda1997x_reset_n1(state);\n\n\t \n\ttda1997x_hdmi_info_reset(sd, NACK_HDCP, true);\n\n\t \n\ttda1997x_manual_hpd(sd, HPD_LOW_BP);\n\n\t \n\tio_write(sd, REG_HDCP_BCAPS, HDCP_HDMI | HDCP_FAST_REAUTH);\n\n\t \n\treg = HDMI_CTRL_MUTE_AUTO << HDMI_CTRL_MUTE_SHIFT;\n\treg |= HDMI_CTRL_HDCP_AUTO << HDMI_CTRL_HDCP_SHIFT;\n\tio_write(sd, REG_HDMI_CTRL, reg);\n\n\t \n\ttda1997x_hdmi_info_reset(sd, 0, true);\n\n\t \n\treg = io_read(sd, REG_VDP_CTRL);\n\treg |= VDP_CTRL_MATRIX_BP;\n\tio_write(sd, REG_VDP_CTRL, reg);\n\n\t \n\ttda1997x_configure_vidout(state);\n\n\t \n\tfor (i = 0; i < 9; i++) {\n\t\tv4l_dbg(1, debug, state->client, \"vidout_cfg[%d]=0x%02x\\n\", i,\n\t\t\tpdata->vidout_port_cfg[i]);\n\t\tio_write(sd, REG_VP35_32_CTRL + i, pdata->vidout_port_cfg[i]);\n\t}\n\n\t \n\ttda1997x_configure_audout(sd, 0);\n\n\t \n\tswitch (pdata->audout_mclk_fs) {\n\tcase 512:\n\t\treg = AUDIO_CLOCK_SEL_512FS;\n\t\tbreak;\n\tcase 256:\n\t\treg = AUDIO_CLOCK_SEL_256FS;\n\t\tbreak;\n\tcase 128:\n\t\treg = AUDIO_CLOCK_SEL_128FS;\n\t\tbreak;\n\tcase 64:\n\t\treg = AUDIO_CLOCK_SEL_64FS;\n\t\tbreak;\n\tcase 32:\n\t\treg = AUDIO_CLOCK_SEL_32FS;\n\t\tbreak;\n\tdefault:\n\t\treg = AUDIO_CLOCK_SEL_16FS;\n\t\tbreak;\n\t}\n\tio_write(sd, REG_AUDIO_CLOCK, reg);\n\n\t \n\ttda1997x_hdmi_info_reset(sd, RESET_AI, false);\n\t \n\ttda1997x_hdmi_info_reset(sd, RESET_IF, false);\n\t \n\ttda1997x_hdmi_info_reset(sd, RESET_AUDIO, false);\n\t \n\ttda1997x_hdmi_info_reset(sd, RESET_GAMUT, false);\n\n\t \n\tstate->hdmi_status = io_read(sd, REG_HDMI_FLAGS);\n\n\tio_write(sd, REG_EDID_ENABLE, EDID_ENABLE_A_EN | EDID_ENABLE_B_EN);\n\treturn 0;\n}\n\nstatic int tda1997x_set_power(struct tda1997x_state *state, bool on)\n{\n\tint ret = 0;\n\n\tif (on) {\n\t\tret = regulator_bulk_enable(TDA1997X_NUM_SUPPLIES,\n\t\t\t\t\t     state->supplies);\n\t\tmsleep(300);\n\t} else {\n\t\tret = regulator_bulk_disable(TDA1997X_NUM_SUPPLIES,\n\t\t\t\t\t     state->supplies);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id tda1997x_i2c_id[] = {\n\t{\"tda19971\", (kernel_ulong_t)&tda1997x_chip_info[TDA19971]},\n\t{\"tda19973\", (kernel_ulong_t)&tda1997x_chip_info[TDA19973]},\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, tda1997x_i2c_id);\n\nstatic const struct of_device_id tda1997x_of_id[] __maybe_unused = {\n\t{ .compatible = \"nxp,tda19971\", .data = &tda1997x_chip_info[TDA19971] },\n\t{ .compatible = \"nxp,tda19973\", .data = &tda1997x_chip_info[TDA19973] },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tda1997x_of_id);\n\nstatic int tda1997x_parse_dt(struct tda1997x_state *state)\n{\n\tstruct tda1997x_platform_data *pdata = &state->pdata;\n\tstruct v4l2_fwnode_endpoint bus_cfg = { .bus_type = 0 };\n\tstruct device_node *ep;\n\tstruct device_node *np;\n\tunsigned int flags;\n\tconst char *str;\n\tint ret;\n\tu32 v;\n\n\t \n\tpdata->vidout_sel_hs = HS_HREF_SEL_HREF_VHREF;\n\tpdata->vidout_sel_vs = VS_VREF_SEL_VREF_HDMI;\n\tpdata->vidout_sel_de = DE_FREF_SEL_DE_VHREF;\n\n\tnp = state->client->dev.of_node;\n\tep = of_graph_get_next_endpoint(np, NULL);\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(ep), &bus_cfg);\n\tif (ret) {\n\t\tof_node_put(ep);\n\t\treturn ret;\n\t}\n\tof_node_put(ep);\n\tpdata->vidout_bus_type = bus_cfg.bus_type;\n\n\t \n\tflags = bus_cfg.bus.parallel.flags;\n\tif (flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\n\t\tpdata->vidout_inv_hs = 1;\n\tif (flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\n\t\tpdata->vidout_inv_vs = 1;\n\tif (flags & V4L2_MBUS_DATA_ACTIVE_LOW)\n\t\tpdata->vidout_inv_de = 1;\n\tpdata->vidout_bus_width = bus_cfg.bus.parallel.bus_width;\n\n\t \n\tret = of_property_count_u32_elems(np, \"nxp,vidout-portcfg\");\n\tif (ret > 0) {\n\t\tu32 reg, val, i;\n\n\t\tfor (i = 0; i < ret / 2 && i < 9; i++) {\n\t\t\tof_property_read_u32_index(np, \"nxp,vidout-portcfg\",\n\t\t\t\t\t\t   i * 2, &reg);\n\t\t\tof_property_read_u32_index(np, \"nxp,vidout-portcfg\",\n\t\t\t\t\t\t   i * 2 + 1, &val);\n\t\t\tif (reg < 9)\n\t\t\t\tpdata->vidout_port_cfg[reg] = val;\n\t\t}\n\t} else {\n\t\tv4l_err(state->client, \"nxp,vidout-portcfg missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpdata->audout_layoutauto = true;\n\n\tpdata->audout_format = AUDFMT_TYPE_DISABLED;\n\tif (!of_property_read_string(np, \"nxp,audout-format\", &str)) {\n\t\tif (strcmp(str, \"i2s\") == 0)\n\t\t\tpdata->audout_format = AUDFMT_TYPE_I2S;\n\t\telse if (strcmp(str, \"spdif\") == 0)\n\t\t\tpdata->audout_format = AUDFMT_TYPE_SPDIF;\n\t\telse {\n\t\t\tv4l_err(state->client, \"nxp,audout-format invalid\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!of_property_read_u32(np, \"nxp,audout-layout\", &v)) {\n\t\t\tswitch (v) {\n\t\t\tcase 0:\n\t\t\tcase 1:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tv4l_err(state->client,\n\t\t\t\t\t\"nxp,audout-layout invalid\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tpdata->audout_layout = v;\n\t\t}\n\t\tif (!of_property_read_u32(np, \"nxp,audout-width\", &v)) {\n\t\t\tswitch (v) {\n\t\t\tcase 16:\n\t\t\tcase 32:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tv4l_err(state->client,\n\t\t\t\t\t\"nxp,audout-width invalid\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tpdata->audout_width = v;\n\t\t}\n\t\tif (!of_property_read_u32(np, \"nxp,audout-mclk-fs\", &v)) {\n\t\t\tswitch (v) {\n\t\t\tcase 512:\n\t\t\tcase 256:\n\t\t\tcase 128:\n\t\t\tcase 64:\n\t\t\tcase 32:\n\t\t\tcase 16:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tv4l_err(state->client,\n\t\t\t\t\t\"nxp,audout-mclk-fs invalid\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tpdata->audout_mclk_fs = v;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tda1997x_get_regulators(struct tda1997x_state *state)\n{\n\tint i;\n\n\tfor (i = 0; i < TDA1997X_NUM_SUPPLIES; i++)\n\t\tstate->supplies[i].supply = tda1997x_supply_name[i];\n\n\treturn devm_regulator_bulk_get(&state->client->dev,\n\t\t\t\t       TDA1997X_NUM_SUPPLIES,\n\t\t\t\t       state->supplies);\n}\n\nstatic int tda1997x_identify_module(struct tda1997x_state *state)\n{\n\tstruct v4l2_subdev *sd = &state->sd;\n\tenum tda1997x_type type;\n\tu8 reg;\n\n\t \n\treg = io_read(sd, REG_CMTP_REG10);\n\tstate->tmdsb_clk = (reg >> 6) & 0x01;  \n\tstate->tmdsb_soc = (reg >> 5) & 0x01;  \n\tstate->port_30bit = (reg >> 2) & 0x03;  \n\tstate->output_2p5 = (reg >> 1) & 0x01;  \n\tswitch ((reg >> 4) & 0x03) {\n\tcase 0x00:\n\t\ttype = TDA19971;\n\t\tbreak;\n\tcase 0x02:\n\tcase 0x03:\n\t\ttype = TDA19973;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&state->client->dev, \"unsupported chip ID\\n\");\n\t\treturn -EIO;\n\t}\n\tif (state->info->type != type) {\n\t\tdev_err(&state->client->dev, \"chip id mismatch\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tstate->chip_revision = io_read(sd, REG_CMTP_REG11);\n\n\treturn 0;\n}\n\nstatic const struct media_entity_operations tda1997x_media_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\n\n \n\n \nstatic int tda1997x_pcm_startup(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct v4l2_subdev *sd = snd_soc_dai_get_drvdata(dai);\n\tstruct tda1997x_state *state = to_state(sd);\n\tstruct snd_soc_component *component = dai->component;\n\tstruct snd_pcm_runtime *rtd = substream->runtime;\n\tint rate, err;\n\n\trate = state->audio_samplerate;\n\terr = snd_pcm_hw_constraint_minmax(rtd, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t   rate, rate);\n\tif (err < 0) {\n\t\tdev_err(component->dev, \"failed to constrain samplerate to %dHz\\n\",\n\t\t\trate);\n\t\treturn err;\n\t}\n\tdev_info(component->dev, \"set samplerate constraint to %dHz\\n\", rate);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops tda1997x_dai_ops = {\n\t.startup = tda1997x_pcm_startup,\n};\n\nstatic struct snd_soc_dai_driver tda1997x_audio_dai = {\n\t.name = \"tda1997x\",\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 8,\n\t\t.rates = SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\n\t\t\t SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 |\n\t\t\t SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 |\n\t\t\t SNDRV_PCM_RATE_192000,\n\t},\n\t.ops = &tda1997x_dai_ops,\n};\n\nstatic int tda1997x_codec_probe(struct snd_soc_component *component)\n{\n\treturn 0;\n}\n\nstatic void tda1997x_codec_remove(struct snd_soc_component *component)\n{\n}\n\nstatic struct snd_soc_component_driver tda1997x_codec_driver = {\n\t.probe\t\t\t= tda1997x_codec_probe,\n\t.remove\t\t\t= tda1997x_codec_remove,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int tda1997x_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct tda1997x_state *state;\n\tstruct tda1997x_platform_data *pdata;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct v4l2_ctrl *ctrl;\n\tstatic const struct v4l2_dv_timings cea1920x1080 =\n\t\tV4L2_DV_BT_CEA_1920X1080P60;\n\tu32 *mbus_codes;\n\tint i, ret;\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tstate = kzalloc(sizeof(struct tda1997x_state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->client = client;\n\tpdata = &state->pdata;\n\tif (IS_ENABLED(CONFIG_OF) && client->dev.of_node) {\n\t\tconst struct of_device_id *oid;\n\n\t\toid = of_match_node(tda1997x_of_id, client->dev.of_node);\n\t\tstate->info = oid->data;\n\n\t\tret = tda1997x_parse_dt(state);\n\t\tif (ret < 0) {\n\t\t\tv4l_err(client, \"DT parsing error\\n\");\n\t\t\tgoto err_free_state;\n\t\t}\n\t} else if (client->dev.platform_data) {\n\t\tstruct tda1997x_platform_data *pdata =\n\t\t\tclient->dev.platform_data;\n\t\tstate->info =\n\t\t\t(const struct tda1997x_chip_info *)id->driver_data;\n\t\tstate->pdata = *pdata;\n\t} else {\n\t\tv4l_err(client, \"No platform data\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_free_state;\n\t}\n\n\tret = tda1997x_get_regulators(state);\n\tif (ret)\n\t\tgoto err_free_state;\n\n\tret = tda1997x_set_power(state, 1);\n\tif (ret)\n\t\tgoto err_free_state;\n\n\tmutex_init(&state->page_lock);\n\tmutex_init(&state->lock);\n\tstate->page = 0xff;\n\n\tINIT_DELAYED_WORK(&state->delayed_work_enable_hpd,\n\t\t\t  tda1997x_delayed_work_enable_hpd);\n\n\t \n\tret = tda1997x_identify_module(state);\n\tif (ret)\n\t\tgoto err_free_mutex;\n\n\t \n\tsd = &state->sd;\n\tv4l2_i2c_subdev_init(sd, client, &tda1997x_subdev_ops);\n\tsnprintf(sd->name, sizeof(sd->name), \"%s %d-%04x\",\n\t\t id->name, i2c_adapter_id(client->adapter),\n\t\t client->addr);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;\n\tsd->entity.function = MEDIA_ENT_F_DV_DECODER;\n\tsd->entity.ops = &tda1997x_media_ops;\n\n\t \n\ti = 0;\n\tmbus_codes = state->mbus_codes;\n\tswitch (state->info->type) {\n\tcase TDA19973:\n\t\tswitch (pdata->vidout_bus_type) {\n\t\tcase V4L2_MBUS_PARALLEL:\n\t\t\tswitch (pdata->vidout_bus_width) {\n\t\t\tcase 36:\n\t\t\t\tmbus_codes[i++] = MEDIA_BUS_FMT_RGB121212_1X36;\n\t\t\t\tmbus_codes[i++] = MEDIA_BUS_FMT_YUV12_1X36;\n\t\t\t\tfallthrough;\n\t\t\tcase 24:\n\t\t\t\tmbus_codes[i++] = MEDIA_BUS_FMT_UYVY12_1X24;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase V4L2_MBUS_BT656:\n\t\t\tswitch (pdata->vidout_bus_width) {\n\t\t\tcase 36:\n\t\t\tcase 24:\n\t\t\tcase 12:\n\t\t\t\tmbus_codes[i++] = MEDIA_BUS_FMT_UYVY12_2X12;\n\t\t\t\tmbus_codes[i++] = MEDIA_BUS_FMT_UYVY10_2X10;\n\t\t\t\tmbus_codes[i++] = MEDIA_BUS_FMT_UYVY8_2X8;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TDA19971:\n\t\tswitch (pdata->vidout_bus_type) {\n\t\tcase V4L2_MBUS_PARALLEL:\n\t\t\tswitch (pdata->vidout_bus_width) {\n\t\t\tcase 24:\n\t\t\t\tmbus_codes[i++] = MEDIA_BUS_FMT_RGB888_1X24;\n\t\t\t\tmbus_codes[i++] = MEDIA_BUS_FMT_YUV8_1X24;\n\t\t\t\tmbus_codes[i++] = MEDIA_BUS_FMT_UYVY12_1X24;\n\t\t\t\tfallthrough;\n\t\t\tcase 20:\n\t\t\t\tmbus_codes[i++] = MEDIA_BUS_FMT_UYVY10_1X20;\n\t\t\t\tfallthrough;\n\t\t\tcase 16:\n\t\t\t\tmbus_codes[i++] = MEDIA_BUS_FMT_UYVY8_1X16;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase V4L2_MBUS_BT656:\n\t\t\tswitch (pdata->vidout_bus_width) {\n\t\t\tcase 24:\n\t\t\tcase 20:\n\t\t\tcase 16:\n\t\t\tcase 12:\n\t\t\t\tmbus_codes[i++] = MEDIA_BUS_FMT_UYVY12_2X12;\n\t\t\t\tfallthrough;\n\t\t\tcase 10:\n\t\t\t\tmbus_codes[i++] = MEDIA_BUS_FMT_UYVY10_2X10;\n\t\t\t\tfallthrough;\n\t\t\tcase 8:\n\t\t\t\tmbus_codes[i++] = MEDIA_BUS_FMT_UYVY8_2X8;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tif (WARN_ON(i > ARRAY_SIZE(state->mbus_codes))) {\n\t\tret = -EINVAL;\n\t\tgoto err_free_mutex;\n\t}\n\n\t \n\ttda1997x_setup_format(state, state->mbus_codes[0]);\n\tstate->timings = cea1920x1080;\n\n\t \n\tstate->colorimetry.colorspace = V4L2_COLORSPACE_SRGB;\n\tstate->colorimetry.quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\n\t \n\tio_write(sd, REG_MAN_SUS_HDMI_SEL, MAN_RST_HDCP | MAN_DIS_HDCP);\n\n\t \n\tif (state->chip_revision != 0) {\n\t\tio_write(sd, REG_MAN_SUS_HDMI_SEL, 0x00);\n\t\tio_write(sd, REG_VDP_CTRL, 0x1f);\n\t}\n\n\tv4l_info(client, \"NXP %s N%d detected\\n\", state->info->name,\n\t\t state->chip_revision + 1);\n\tv4l_info(client, \"video: %dbit %s %d formats available\\n\",\n\t\tpdata->vidout_bus_width,\n\t\t(pdata->vidout_bus_type == V4L2_MBUS_PARALLEL) ?\n\t\t\t\"parallel\" : \"BT656\",\n\t\ti);\n\tif (pdata->audout_format) {\n\t\tv4l_info(client, \"audio: %dch %s layout%d sysclk=%d*fs\\n\",\n\t\t\t pdata->audout_layout ? 2 : 8,\n\t\t\t audfmt_names[pdata->audout_format],\n\t\t\t pdata->audout_layout,\n\t\t\t pdata->audout_mclk_fs);\n\t}\n\n\tret = 0x34 + ((io_read(sd, REG_SLAVE_ADDR)>>4) & 0x03);\n\tstate->client_cec = devm_i2c_new_dummy_device(&client->dev,\n\t\t\t\t\t\t      client->adapter, ret);\n\tif (IS_ERR(state->client_cec)) {\n\t\tret = PTR_ERR(state->client_cec);\n\t\tgoto err_free_mutex;\n\t}\n\n\tv4l_info(client, \"CEC slave address 0x%02x\\n\", ret);\n\n\tret = tda1997x_core_init(sd);\n\tif (ret)\n\t\tgoto err_free_mutex;\n\n\t \n\thdl = &state->hdl;\n\tv4l2_ctrl_handler_init(hdl, 3);\n\tctrl = v4l2_ctrl_new_std_menu(hdl, &tda1997x_ctrl_ops,\n\t\t\tV4L2_CID_DV_RX_IT_CONTENT_TYPE,\n\t\t\tV4L2_DV_IT_CONTENT_TYPE_NO_ITC, 0,\n\t\t\tV4L2_DV_IT_CONTENT_TYPE_NO_ITC);\n\tif (ctrl)\n\t\tctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\t \n\tstate->detect_tx_5v_ctrl = v4l2_ctrl_new_std(hdl, NULL,\n\t\t\tV4L2_CID_DV_RX_POWER_PRESENT, 0, 1, 0, 0);\n\tstate->rgb_quantization_range_ctrl = v4l2_ctrl_new_std_menu(hdl,\n\t\t\t&tda1997x_ctrl_ops,\n\t\t\tV4L2_CID_DV_RX_RGB_RANGE, V4L2_DV_RGB_RANGE_FULL, 0,\n\t\t\tV4L2_DV_RGB_RANGE_AUTO);\n\tstate->sd.ctrl_handler = hdl;\n\tif (hdl->error) {\n\t\tret = hdl->error;\n\t\tgoto err_free_handler;\n\t}\n\tv4l2_ctrl_handler_setup(hdl);\n\n\t \n\tstate->pads[TDA1997X_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\tret = media_entity_pads_init(&sd->entity, TDA1997X_NUM_PADS,\n\t\tstate->pads);\n\tif (ret) {\n\t\tv4l_err(client, \"failed entity_init: %d\", ret);\n\t\tgoto err_free_handler;\n\t}\n\n\tret = v4l2_async_register_subdev(sd);\n\tif (ret)\n\t\tgoto err_free_media;\n\n\t \n\tif (pdata->audout_format) {\n\t\tu64 formats;\n\n\t\tif (pdata->audout_width == 32)\n\t\t\tformats = SNDRV_PCM_FMTBIT_S32_LE;\n\t\telse\n\t\t\tformats = SNDRV_PCM_FMTBIT_S16_LE;\n\t\ttda1997x_audio_dai.capture.formats = formats;\n\t\tret = devm_snd_soc_register_component(&state->client->dev,\n\t\t\t\t\t     &tda1997x_codec_driver,\n\t\t\t\t\t     &tda1997x_audio_dai, 1);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"register audio codec failed\\n\");\n\t\t\tgoto err_free_media;\n\t\t}\n\t\tv4l_info(state->client, \"registered audio codec\\n\");\n\t}\n\n\t \n\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\tNULL, tda1997x_isr_thread,\n\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\tKBUILD_MODNAME, state);\n\tif (ret) {\n\t\tv4l_err(client, \"irq%d reg failed: %d\\n\", client->irq, ret);\n\t\tgoto err_free_media;\n\t}\n\n\treturn 0;\n\nerr_free_media:\n\tmedia_entity_cleanup(&sd->entity);\nerr_free_handler:\n\tv4l2_ctrl_handler_free(&state->hdl);\nerr_free_mutex:\n\tcancel_delayed_work(&state->delayed_work_enable_hpd);\n\tmutex_destroy(&state->page_lock);\n\tmutex_destroy(&state->lock);\n\ttda1997x_set_power(state, 0);\nerr_free_state:\n\tkfree(state);\n\tdev_err(&client->dev, \"%s failed: %d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nstatic void tda1997x_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct tda1997x_state *state = to_state(sd);\n\tstruct tda1997x_platform_data *pdata = &state->pdata;\n\n\tif (pdata->audout_format) {\n\t\tmutex_destroy(&state->audio_lock);\n\t}\n\n\tdisable_irq(state->client->irq);\n\ttda1997x_power_mode(state, 0);\n\n\tv4l2_async_unregister_subdev(sd);\n\tmedia_entity_cleanup(&sd->entity);\n\tv4l2_ctrl_handler_free(&state->hdl);\n\tregulator_bulk_disable(TDA1997X_NUM_SUPPLIES, state->supplies);\n\tcancel_delayed_work_sync(&state->delayed_work_enable_hpd);\n\tmutex_destroy(&state->page_lock);\n\tmutex_destroy(&state->lock);\n\n\tkfree(state);\n}\n\nstatic struct i2c_driver tda1997x_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tda1997x\",\n\t\t.of_match_table = of_match_ptr(tda1997x_of_id),\n\t},\n\t.probe = tda1997x_probe,\n\t.remove = tda1997x_remove,\n\t.id_table = tda1997x_i2c_id,\n};\n\nmodule_i2c_driver(tda1997x_i2c_driver);\n\nMODULE_AUTHOR(\"Tim Harvey <tharvey@gateworks.com>\");\nMODULE_DESCRIPTION(\"TDA1997X HDMI Receiver driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}