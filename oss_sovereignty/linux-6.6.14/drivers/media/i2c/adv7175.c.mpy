{
  "module_name": "adv7175.c",
  "hash_id": "ae8039d8ef736f844a5e00e710eaeceb406b7d58b18bdd6e9f61d6794a0246f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/adv7175.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/ioctl.h>\n#include <linux/uaccess.h>\n#include <linux/i2c.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n\nMODULE_DESCRIPTION(\"Analog Devices ADV7175 video encoder driver\");\nMODULE_AUTHOR(\"Dave Perks\");\nMODULE_LICENSE(\"GPL\");\n\n#define   I2C_ADV7175        0xd4\n#define   I2C_ADV7176        0x54\n\n\nstatic int debug;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"Debug level (0-1)\");\n\n \n\nstruct adv7175 {\n\tstruct v4l2_subdev sd;\n\tv4l2_std_id norm;\n\tint input;\n};\n\nstatic inline struct adv7175 *to_adv7175(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct adv7175, sd);\n}\n\nstatic char *inputs[] = { \"pass_through\", \"play_back\", \"color_bar\" };\n\nstatic u32 adv7175_codes[] = {\n\tMEDIA_BUS_FMT_UYVY8_2X8,\n\tMEDIA_BUS_FMT_UYVY8_1X16,\n};\n\n \n\nstatic inline int adv7175_write(struct v4l2_subdev *sd, u8 reg, u8 value)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn i2c_smbus_write_byte_data(client, reg, value);\n}\n\nstatic inline int adv7175_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\nstatic int adv7175_write_block(struct v4l2_subdev *sd,\n\t\t     const u8 *data, unsigned int len)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint ret = -1;\n\tu8 reg;\n\n\t \n\tif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\t \n\t\tu8 block_data[32];\n\t\tint block_len;\n\n\t\twhile (len >= 2) {\n\t\t\tblock_len = 0;\n\t\t\tblock_data[block_len++] = reg = data[0];\n\t\t\tdo {\n\t\t\t\tblock_data[block_len++] = data[1];\n\t\t\t\treg++;\n\t\t\t\tlen -= 2;\n\t\t\t\tdata += 2;\n\t\t\t} while (len >= 2 && data[0] == reg && block_len < 32);\n\t\t\tret = i2c_master_send(client, block_data, block_len);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\twhile (len >= 2) {\n\t\t\treg = *data++;\n\t\t\tret = adv7175_write(sd, reg, *data++);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tlen -= 2;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void set_subcarrier_freq(struct v4l2_subdev *sd, int pass_through)\n{\n\t \n\tif (pass_through)\n\t\tadv7175_write(sd, 0x02, 0x00);\n\telse\n\t\tadv7175_write(sd, 0x02, 0x55);\n\n\tadv7175_write(sd, 0x03, 0x55);\n\tadv7175_write(sd, 0x04, 0x55);\n\tadv7175_write(sd, 0x05, 0x25);\n}\n\n \n \n\n#define MR050       0x11\t \n#define MR060       0x14\t \n\n \n\n#define TR0MODE     0x46\n#define TR0RST\t    0x80\n\n#define TR1CAPT\t    0x80\n#define TR1PLAY\t    0x00\n\nstatic const unsigned char init_common[] = {\n\n\t0x00, MR050,\t\t \n\t0x01, 0x00,\t\t \n\t0x02, 0x0c,\t\t \n\t0x03, 0x8c,\t\t \n\t0x04, 0x79,\t\t \n\t0x05, 0x26,\t\t \n\t0x06, 0x40,\t\t \n\n\t0x07, TR0MODE,\t\t \n\t0x08, 0x21,\t\t \n\t0x09, 0x00,\t\t \n\t0x0a, 0x00,\t\t \n\t0x0b, 0x00,\t\t \n\t0x0c, TR1CAPT,\t\t \n\t0x0d, 0x4f,\t\t \n\t0x0e, 0x00,\t\t \n\t0x0f, 0x00,\t\t \n\t0x10, 0x00,\t\t \n\t0x11, 0x00,\t\t \n};\n\nstatic const unsigned char init_pal[] = {\n\t0x00, MR050,\t\t \n\t0x01, 0x00,\t\t \n\t0x02, 0x0c,\t\t \n\t0x03, 0x8c,\t\t \n\t0x04, 0x79,\t\t \n\t0x05, 0x26,\t\t \n\t0x06, 0x40,\t\t \n};\n\nstatic const unsigned char init_ntsc[] = {\n\t0x00, MR060,\t\t \n\t0x01, 0x00,\t\t \n\t0x02, 0x55,\t\t \n\t0x03, 0x55,\t\t \n\t0x04, 0x55,\t\t \n\t0x05, 0x25,\t\t \n\t0x06, 0x1a,\t\t \n};\n\nstatic int adv7175_init(struct v4l2_subdev *sd, u32 val)\n{\n\t \n\tadv7175_write_block(sd, init_common, sizeof(init_common));\n\tadv7175_write(sd, 0x07, TR0MODE | TR0RST);\n\tadv7175_write(sd, 0x07, TR0MODE);\n\treturn 0;\n}\n\nstatic int adv7175_s_std_output(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct adv7175 *encoder = to_adv7175(sd);\n\n\tif (std & V4L2_STD_NTSC) {\n\t\tadv7175_write_block(sd, init_ntsc, sizeof(init_ntsc));\n\t\tif (encoder->input == 0)\n\t\t\tadv7175_write(sd, 0x0d, 0x4f);\t \n\t\tadv7175_write(sd, 0x07, TR0MODE | TR0RST);\n\t\tadv7175_write(sd, 0x07, TR0MODE);\n\t} else if (std & V4L2_STD_PAL) {\n\t\tadv7175_write_block(sd, init_pal, sizeof(init_pal));\n\t\tif (encoder->input == 0)\n\t\t\tadv7175_write(sd, 0x0d, 0x4f);\t \n\t\tadv7175_write(sd, 0x07, TR0MODE | TR0RST);\n\t\tadv7175_write(sd, 0x07, TR0MODE);\n\t} else if (std & V4L2_STD_SECAM) {\n\t\t \n\t\tadv7175_write_block(sd, init_pal, sizeof(init_pal));\n\t\tif (encoder->input == 0)\n\t\t\tadv7175_write(sd, 0x0d, 0x49);\t \n\t\tadv7175_write(sd, 0x07, TR0MODE | TR0RST);\n\t\tadv7175_write(sd, 0x07, TR0MODE);\n\t} else {\n\t\tv4l2_dbg(1, debug, sd, \"illegal norm: %llx\\n\",\n\t\t\t\t(unsigned long long)std);\n\t\treturn -EINVAL;\n\t}\n\tv4l2_dbg(1, debug, sd, \"switched to %llx\\n\", (unsigned long long)std);\n\tencoder->norm = std;\n\treturn 0;\n}\n\nstatic int adv7175_s_routing(struct v4l2_subdev *sd,\n\t\t\t     u32 input, u32 output, u32 config)\n{\n\tstruct adv7175 *encoder = to_adv7175(sd);\n\n\t \n\n\tswitch (input) {\n\tcase 0:\n\t\tadv7175_write(sd, 0x01, 0x00);\n\n\t\tif (encoder->norm & V4L2_STD_NTSC)\n\t\t\tset_subcarrier_freq(sd, 1);\n\n\t\tadv7175_write(sd, 0x0c, TR1CAPT);\t \n\t\tif (encoder->norm & V4L2_STD_SECAM)\n\t\t\tadv7175_write(sd, 0x0d, 0x49);\t \n\t\telse\n\t\t\tadv7175_write(sd, 0x0d, 0x4f);\t \n\t\tadv7175_write(sd, 0x07, TR0MODE | TR0RST);\n\t\tadv7175_write(sd, 0x07, TR0MODE);\n\t\t \n\t\tbreak;\n\n\tcase 1:\n\t\tadv7175_write(sd, 0x01, 0x00);\n\n\t\tif (encoder->norm & V4L2_STD_NTSC)\n\t\t\tset_subcarrier_freq(sd, 0);\n\n\t\tadv7175_write(sd, 0x0c, TR1PLAY);\t \n\t\tadv7175_write(sd, 0x0d, 0x49);\n\t\tadv7175_write(sd, 0x07, TR0MODE | TR0RST);\n\t\tadv7175_write(sd, 0x07, TR0MODE);\n\t\t \n\t\tbreak;\n\n\tcase 2:\n\t\tadv7175_write(sd, 0x01, 0x80);\n\n\t\tif (encoder->norm & V4L2_STD_NTSC)\n\t\t\tset_subcarrier_freq(sd, 0);\n\n\t\tadv7175_write(sd, 0x0d, 0x49);\n\t\tadv7175_write(sd, 0x07, TR0MODE | TR0RST);\n\t\tadv7175_write(sd, 0x07, TR0MODE);\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tv4l2_dbg(1, debug, sd, \"illegal input: %d\\n\", input);\n\t\treturn -EINVAL;\n\t}\n\tv4l2_dbg(1, debug, sd, \"switched to %s\\n\", inputs[input]);\n\tencoder->input = input;\n\treturn 0;\n}\n\nstatic int adv7175_enum_mbus_code(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index >= ARRAY_SIZE(adv7175_codes))\n\t\treturn -EINVAL;\n\n\tcode->code = adv7175_codes[code->index];\n\treturn 0;\n}\n\nstatic int adv7175_get_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tu8 val = adv7175_read(sd, 0x7);\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tif ((val & 0x40) == (1 << 6))\n\t\tmf->code = MEDIA_BUS_FMT_UYVY8_1X16;\n\telse\n\t\tmf->code = MEDIA_BUS_FMT_UYVY8_2X8;\n\n\tmf->colorspace  = V4L2_COLORSPACE_SMPTE170M;\n\tmf->width       = 0;\n\tmf->height      = 0;\n\tmf->field       = V4L2_FIELD_ANY;\n\n\treturn 0;\n}\n\nstatic int adv7175_set_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tu8 val = adv7175_read(sd, 0x7);\n\tint ret = 0;\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tswitch (mf->code) {\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\t\tval &= ~0x40;\n\t\tbreak;\n\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\t\tval |= 0x40;\n\t\tbreak;\n\n\tdefault:\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t\"illegal v4l2_mbus_framefmt code: %d\\n\", mf->code);\n\t\treturn -EINVAL;\n\t}\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\tret = adv7175_write(sd, 0x7, val);\n\n\treturn ret;\n}\n\nstatic int adv7175_s_power(struct v4l2_subdev *sd, int on)\n{\n\tif (on)\n\t\tadv7175_write(sd, 0x01, 0x00);\n\telse\n\t\tadv7175_write(sd, 0x01, 0x78);\n\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_subdev_core_ops adv7175_core_ops = {\n\t.init = adv7175_init,\n\t.s_power = adv7175_s_power,\n};\n\nstatic const struct v4l2_subdev_video_ops adv7175_video_ops = {\n\t.s_std_output = adv7175_s_std_output,\n\t.s_routing = adv7175_s_routing,\n};\n\nstatic const struct v4l2_subdev_pad_ops adv7175_pad_ops = {\n\t.enum_mbus_code = adv7175_enum_mbus_code,\n\t.get_fmt = adv7175_get_fmt,\n\t.set_fmt = adv7175_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops adv7175_ops = {\n\t.core = &adv7175_core_ops,\n\t.video = &adv7175_video_ops,\n\t.pad = &adv7175_pad_ops,\n};\n\n \n\nstatic int adv7175_probe(struct i2c_client *client)\n{\n\tint i;\n\tstruct adv7175 *encoder;\n\tstruct v4l2_subdev *sd;\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tv4l_info(client, \"chip found @ 0x%x (%s)\\n\",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tencoder = devm_kzalloc(&client->dev, sizeof(*encoder), GFP_KERNEL);\n\tif (encoder == NULL)\n\t\treturn -ENOMEM;\n\tsd = &encoder->sd;\n\tv4l2_i2c_subdev_init(sd, client, &adv7175_ops);\n\tencoder->norm = V4L2_STD_NTSC;\n\tencoder->input = 0;\n\n\ti = adv7175_write_block(sd, init_common, sizeof(init_common));\n\tif (i >= 0) {\n\t\ti = adv7175_write(sd, 0x07, TR0MODE | TR0RST);\n\t\ti = adv7175_write(sd, 0x07, TR0MODE);\n\t\ti = adv7175_read(sd, 0x12);\n\t\tv4l2_dbg(1, debug, sd, \"revision %d\\n\", i & 1);\n\t}\n\tif (i < 0)\n\t\tv4l2_dbg(1, debug, sd, \"init error 0x%x\\n\", i);\n\treturn 0;\n}\n\nstatic void adv7175_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\n\tv4l2_device_unregister_subdev(sd);\n}\n\n \n\nstatic const struct i2c_device_id adv7175_id[] = {\n\t{ \"adv7175\", 0 },\n\t{ \"adv7176\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adv7175_id);\n\nstatic struct i2c_driver adv7175_driver = {\n\t.driver = {\n\t\t.name\t= \"adv7175\",\n\t},\n\t.probe\t\t= adv7175_probe,\n\t.remove\t\t= adv7175_remove,\n\t.id_table\t= adv7175_id,\n};\n\nmodule_i2c_driver(adv7175_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}