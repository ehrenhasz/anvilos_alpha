{
  "module_name": "tvaudio.c",
  "hash_id": "8209dcb3a882f14cbc4869c0b7c2736de538900e586c2d6dd2f6abccaf2265b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/tvaudio.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n\n#include <media/i2c/tvaudio.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n\n \n \n\nstatic int debug;\t \nmodule_param(debug, int, 0644);\n\nMODULE_DESCRIPTION(\"device driver for various i2c TV sound decoder / audiomux chips\");\nMODULE_AUTHOR(\"Eric Sandeen, Steve VanDeBogart, Greg Alexander, Gerd Knorr\");\nMODULE_LICENSE(\"GPL\");\n\n#define UNSET    (-1U)\n\n \n \n\n#define MAXREGS 256\n\nstruct CHIPSTATE;\ntypedef int  (*getvalue)(int);\ntypedef int  (*checkit)(struct CHIPSTATE*);\ntypedef int  (*initialize)(struct CHIPSTATE*);\ntypedef int  (*getrxsubchans)(struct CHIPSTATE *);\ntypedef void (*setaudmode)(struct CHIPSTATE*, int mode);\n\n \ntypedef struct AUDIOCMD {\n\tint             count;              \n\tunsigned char   bytes[MAXREGS+1];   \n} audiocmd;\n\n \nstruct CHIPDESC {\n\tchar       *name;              \n\tint        addr_lo, addr_hi;   \n\tint        registers;          \n\n\tint        *insmodopt;\n\tcheckit    checkit;\n\tinitialize initialize;\n\tint        flags;\n#define CHIP_HAS_VOLUME      1\n#define CHIP_HAS_BASSTREBLE  2\n#define CHIP_HAS_INPUTSEL    4\n#define CHIP_NEED_CHECKMODE  8\n\n\t \n\taudiocmd   init;\n\n\t \n\tint    leftreg, rightreg, treblereg, bassreg;\n\n\t \n\tint    volinit, trebleinit, bassinit;\n\n\t \n\tgetvalue volfunc, treblefunc, bassfunc;\n\n\t \n\tgetrxsubchans\tgetrxsubchans;\n\tsetaudmode\tsetaudmode;\n\n\t \n\tint  inputreg;\n\tint  inputmap[4];\n\tint  inputmute;\n\tint  inputmask;\n};\n\n \nstruct CHIPSTATE {\n\tstruct v4l2_subdev sd;\n\tstruct v4l2_ctrl_handler hdl;\n\tstruct {\n\t\t \n\t\tstruct v4l2_ctrl *volume;\n\t\tstruct v4l2_ctrl *balance;\n\t};\n\n\t \n\tstruct CHIPDESC *desc;\n\n\t \n\taudiocmd   shadow;\n\n\t \n\tu16 muted;\n\tint prevmode;\n\tint radio;\n\tint input;\n\n\t \n\tstruct task_struct   *thread;\n\tstruct timer_list    wt;\n\tint\t\t     audmode;\n};\n\nstatic inline struct CHIPSTATE *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct CHIPSTATE, sd);\n}\n\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler, struct CHIPSTATE, hdl)->sd;\n}\n\n\n \n \n\nstatic int chip_write(struct CHIPSTATE *chip, int subaddr, int val)\n{\n\tstruct v4l2_subdev *sd = &chip->sd;\n\tstruct i2c_client *c = v4l2_get_subdevdata(sd);\n\tunsigned char buffer[2];\n\tint rc;\n\n\tif (subaddr < 0) {\n\t\tv4l2_dbg(1, debug, sd, \"chip_write: 0x%x\\n\", val);\n\t\tchip->shadow.bytes[1] = val;\n\t\tbuffer[0] = val;\n\t\trc = i2c_master_send(c, buffer, 1);\n\t\tif (rc != 1) {\n\t\t\tv4l2_warn(sd, \"I/O error (write 0x%x)\\n\", val);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\tif (subaddr + 1 >= ARRAY_SIZE(chip->shadow.bytes)) {\n\t\t\tv4l2_info(sd,\n\t\t\t\t\"Tried to access a non-existent register: %d\\n\",\n\t\t\t\tsubaddr);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tv4l2_dbg(1, debug, sd, \"chip_write: reg%d=0x%x\\n\",\n\t\t\tsubaddr, val);\n\t\tchip->shadow.bytes[subaddr+1] = val;\n\t\tbuffer[0] = subaddr;\n\t\tbuffer[1] = val;\n\t\trc = i2c_master_send(c, buffer, 2);\n\t\tif (rc != 2) {\n\t\t\tv4l2_warn(sd, \"I/O error (write reg%d=0x%x)\\n\",\n\t\t\t\tsubaddr, val);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int chip_write_masked(struct CHIPSTATE *chip,\n\t\t\t     int subaddr, int val, int mask)\n{\n\tstruct v4l2_subdev *sd = &chip->sd;\n\n\tif (mask != 0) {\n\t\tif (subaddr < 0) {\n\t\t\tval = (chip->shadow.bytes[1] & ~mask) | (val & mask);\n\t\t} else {\n\t\t\tif (subaddr + 1 >= ARRAY_SIZE(chip->shadow.bytes)) {\n\t\t\t\tv4l2_info(sd,\n\t\t\t\t\t\"Tried to access a non-existent register: %d\\n\",\n\t\t\t\t\tsubaddr);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tval = (chip->shadow.bytes[subaddr+1] & ~mask) | (val & mask);\n\t\t}\n\t}\n\treturn chip_write(chip, subaddr, val);\n}\n\nstatic int chip_read(struct CHIPSTATE *chip)\n{\n\tstruct v4l2_subdev *sd = &chip->sd;\n\tstruct i2c_client *c = v4l2_get_subdevdata(sd);\n\tunsigned char buffer;\n\tint rc;\n\n\trc = i2c_master_recv(c, &buffer, 1);\n\tif (rc != 1) {\n\t\tv4l2_warn(sd, \"I/O error (read)\\n\");\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treturn -EIO;\n\t}\n\tv4l2_dbg(1, debug, sd, \"chip_read: 0x%x\\n\", buffer);\n\treturn buffer;\n}\n\nstatic int chip_read2(struct CHIPSTATE *chip, int subaddr)\n{\n\tstruct v4l2_subdev *sd = &chip->sd;\n\tstruct i2c_client *c = v4l2_get_subdevdata(sd);\n\tint rc;\n\tunsigned char write[1];\n\tunsigned char read[1];\n\tstruct i2c_msg msgs[2] = {\n\t\t{\n\t\t\t.addr = c->addr,\n\t\t\t.len = 1,\n\t\t\t.buf = write\n\t\t},\n\t\t{\n\t\t\t.addr = c->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 1,\n\t\t\t.buf = read\n\t\t}\n\t};\n\n\twrite[0] = subaddr;\n\n\trc = i2c_transfer(c->adapter, msgs, 2);\n\tif (rc != 2) {\n\t\tv4l2_warn(sd, \"I/O error (read2)\\n\");\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treturn -EIO;\n\t}\n\tv4l2_dbg(1, debug, sd, \"chip_read2: reg%d=0x%x\\n\",\n\t\tsubaddr, read[0]);\n\treturn read[0];\n}\n\nstatic int chip_cmd(struct CHIPSTATE *chip, char *name, audiocmd *cmd)\n{\n\tstruct v4l2_subdev *sd = &chip->sd;\n\tstruct i2c_client *c = v4l2_get_subdevdata(sd);\n\tint i, rc;\n\n\tif (0 == cmd->count)\n\t\treturn 0;\n\n\tif (cmd->count + cmd->bytes[0] - 1 >= ARRAY_SIZE(chip->shadow.bytes)) {\n\t\tv4l2_info(sd,\n\t\t\t \"Tried to access a non-existent register range: %d to %d\\n\",\n\t\t\t cmd->bytes[0] + 1, cmd->bytes[0] + cmd->count - 1);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\t \n\tv4l2_dbg(1, debug, sd, \"chip_cmd(%s): reg=%d, data:\",\n\t\tname, cmd->bytes[0]);\n\tfor (i = 1; i < cmd->count; i++) {\n\t\tif (debug)\n\t\t\tprintk(KERN_CONT \" 0x%x\", cmd->bytes[i]);\n\t\tchip->shadow.bytes[i+cmd->bytes[0]] = cmd->bytes[i];\n\t}\n\tif (debug)\n\t\tprintk(KERN_CONT \"\\n\");\n\n\t \n\trc = i2c_master_send(c, cmd->bytes, cmd->count);\n\tif (rc != cmd->count) {\n\t\tv4l2_warn(sd, \"I/O error (%s)\\n\", name);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \n \n\nstatic void chip_thread_wake(struct timer_list *t)\n{\n\tstruct CHIPSTATE *chip = from_timer(chip, t, wt);\n\twake_up_process(chip->thread);\n}\n\nstatic int chip_thread(void *data)\n{\n\tstruct CHIPSTATE *chip = data;\n\tstruct CHIPDESC  *desc = chip->desc;\n\tstruct v4l2_subdev *sd = &chip->sd;\n\tint mode, selected;\n\n\tv4l2_dbg(1, debug, sd, \"thread started\\n\");\n\tset_freezable();\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (!kthread_should_stop())\n\t\t\tschedule();\n\t\tset_current_state(TASK_RUNNING);\n\t\ttry_to_freeze();\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t\tv4l2_dbg(1, debug, sd, \"thread wakeup\\n\");\n\n\t\t \n\t\tif (chip->radio)\n\t\t\tcontinue;\n\n\t\t \n\t\tmode = desc->getrxsubchans(chip);\n\t\tif (mode == chip->prevmode)\n\t\t\tcontinue;\n\n\t\t \n\t\tv4l2_dbg(1, debug, sd, \"thread checkmode\\n\");\n\n\t\tchip->prevmode = mode;\n\n\t\tselected = V4L2_TUNER_MODE_MONO;\n\t\tswitch (chip->audmode) {\n\t\tcase V4L2_TUNER_MODE_MONO:\n\t\t\tif (mode & V4L2_TUNER_SUB_LANG1)\n\t\t\t\tselected = V4L2_TUNER_MODE_LANG1;\n\t\t\tbreak;\n\t\tcase V4L2_TUNER_MODE_STEREO:\n\t\tcase V4L2_TUNER_MODE_LANG1:\n\t\t\tif (mode & V4L2_TUNER_SUB_LANG1)\n\t\t\t\tselected = V4L2_TUNER_MODE_LANG1;\n\t\t\telse if (mode & V4L2_TUNER_SUB_STEREO)\n\t\t\t\tselected = V4L2_TUNER_MODE_STEREO;\n\t\t\tbreak;\n\t\tcase V4L2_TUNER_MODE_LANG2:\n\t\t\tif (mode & V4L2_TUNER_SUB_LANG2)\n\t\t\t\tselected = V4L2_TUNER_MODE_LANG2;\n\t\t\telse if (mode & V4L2_TUNER_SUB_STEREO)\n\t\t\t\tselected = V4L2_TUNER_MODE_STEREO;\n\t\t\tbreak;\n\t\tcase V4L2_TUNER_MODE_LANG1_LANG2:\n\t\t\tif (mode & V4L2_TUNER_SUB_LANG2)\n\t\t\t\tselected = V4L2_TUNER_MODE_LANG1_LANG2;\n\t\t\telse if (mode & V4L2_TUNER_SUB_STEREO)\n\t\t\t\tselected = V4L2_TUNER_MODE_STEREO;\n\t\t}\n\t\tdesc->setaudmode(chip, selected);\n\n\t\t \n\t\tmod_timer(&chip->wt, jiffies+msecs_to_jiffies(2000));\n\t}\n\n\tv4l2_dbg(1, debug, sd, \"thread exiting\\n\");\n\treturn 0;\n}\n\n \n \n\n#define TDA9840_SW         0x00\n#define TDA9840_LVADJ      0x02\n#define TDA9840_STADJ      0x03\n#define TDA9840_TEST       0x04\n\n#define TDA9840_MONO       0x10\n#define TDA9840_STEREO     0x2a\n#define TDA9840_DUALA      0x12\n#define TDA9840_DUALB      0x1e\n#define TDA9840_DUALAB     0x1a\n#define TDA9840_DUALBA     0x16\n#define TDA9840_EXTERNAL   0x7a\n\n#define TDA9840_DS_DUAL    0x20  \n#define TDA9840_ST_STEREO  0x40  \n#define TDA9840_PONRES     0x80  \n\n#define TDA9840_TEST_INT1SN 0x1  \n#define TDA9840_TEST_INTFU 0x02  \n\nstatic int tda9840_getrxsubchans(struct CHIPSTATE *chip)\n{\n\tstruct v4l2_subdev *sd = &chip->sd;\n\tint val, mode;\n\n\tmode = V4L2_TUNER_SUB_MONO;\n\n\tval = chip_read(chip);\n\tif (val < 0)\n\t\treturn mode;\n\n\tif (val & TDA9840_DS_DUAL)\n\t\tmode |= V4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;\n\tif (val & TDA9840_ST_STEREO)\n\t\tmode = V4L2_TUNER_SUB_STEREO;\n\n\tv4l2_dbg(1, debug, sd,\n\t\t\"tda9840_getrxsubchans(): raw chip read: %d, return: %d\\n\",\n\t\tval, mode);\n\treturn mode;\n}\n\nstatic void tda9840_setaudmode(struct CHIPSTATE *chip, int mode)\n{\n\tint update = 1;\n\tint t = chip->shadow.bytes[TDA9840_SW + 1] & ~0x7e;\n\n\tswitch (mode) {\n\tcase V4L2_TUNER_MODE_MONO:\n\t\tt |= TDA9840_MONO;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_STEREO:\n\t\tt |= TDA9840_STEREO;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_LANG1:\n\t\tt |= TDA9840_DUALA;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_LANG2:\n\t\tt |= TDA9840_DUALB;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_LANG1_LANG2:\n\t\tt |= TDA9840_DUALAB;\n\t\tbreak;\n\tdefault:\n\t\tupdate = 0;\n\t}\n\n\tif (update)\n\t\tchip_write(chip, TDA9840_SW, t);\n}\n\nstatic int tda9840_checkit(struct CHIPSTATE *chip)\n{\n\tint rc;\n\n\trc = chip_read(chip);\n\tif (rc < 0)\n\t\treturn 0;\n\n\n\t \n\treturn ((rc & 0x1f) == 0) ? 1 : 0;\n}\n\n \n \n\n \n#define TDA9855_VR\t0x00  \n#define TDA9855_VL\t0x01  \n#define TDA9855_BA\t0x02  \n#define TDA9855_TR\t0x03  \n#define TDA9855_SW\t0x04  \n\n \n#define TDA9850_C4\t0x04  \n\n \n#define TDA985x_C5\t0x05  \n#define TDA985x_C6\t0x06  \n#define TDA985x_C7\t0x07  \n#define TDA985x_A1\t0x08  \n#define TDA985x_A2\t0x09  \n#define TDA985x_A3\t0x0a  \n\n \n \n \n \n\n\n \n \n\n\n \n \n\n \n \n \n \n\n \n \n\n\n \n \n#define TDA9855_MUTE\t1<<7  \n#define TDA9855_AVL\t1<<6  \n#define TDA9855_LOUD\t1<<5  \n#define TDA9855_SUR\t1<<3  \n\t\t\t      \n#define TDA9855_EXT\t1<<2  \n#define TDA9855_INT\t0     \n\n \n \n\n\n \n \n#define TDA985x_SAP\t3<<6  \n#define TDA985x_MONOSAP\t2<<6  \n#define TDA985x_STEREO\t1<<6  \n#define TDA985x_MONO\t0     \n#define TDA985x_LMU\t1<<3  \n\n \n#define TDA9855_TZCM\t1<<5  \n#define TDA9855_VZCM\t1<<4  \n#define TDA9855_LINEAR\t0     \n#define TDA9855_PSEUDO\t1     \n#define TDA9855_SPAT_30\t2     \n#define TDA9855_SPAT_50\t3     \n#define TDA9855_E_MONO\t7     \n\n \n \n \n\n \n \n \n#define TDA985x_STP\t1<<5  \n#define TDA985x_SAPP\t1<<6  \n#define TDA985x_STS\t1<<7  \n\n \n \n \n#define TDA985x_ADJ\t1<<7  \n\nstatic int tda9855_volume(int val) { return val/0x2e8+0x27; }\nstatic int tda9855_bass(int val)   { return val/0xccc+0x06; }\nstatic int tda9855_treble(int val) { return (val/0x1c71+0x3)<<1; }\n\nstatic int  tda985x_getrxsubchans(struct CHIPSTATE *chip)\n{\n\tint mode, val;\n\n\t \n\t \n\tmode = V4L2_TUNER_SUB_MONO;\n\tval = chip_read(chip);\n\tif (val < 0)\n\t\treturn mode;\n\n\tif (val & TDA985x_STP)\n\t\tmode = V4L2_TUNER_SUB_STEREO;\n\tif (val & TDA985x_SAPP)\n\t\tmode |= V4L2_TUNER_SUB_SAP;\n\treturn mode;\n}\n\nstatic void tda985x_setaudmode(struct CHIPSTATE *chip, int mode)\n{\n\tint update = 1;\n\tint c6 = chip->shadow.bytes[TDA985x_C6+1] & 0x3f;\n\n\tswitch (mode) {\n\tcase V4L2_TUNER_MODE_MONO:\n\t\tc6 |= TDA985x_MONO;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_STEREO:\n\tcase V4L2_TUNER_MODE_LANG1:\n\t\tc6 |= TDA985x_STEREO;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_SAP:\n\t\tc6 |= TDA985x_SAP;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_LANG1_LANG2:\n\t\tc6 |= TDA985x_MONOSAP;\n\t\tbreak;\n\tdefault:\n\t\tupdate = 0;\n\t}\n\tif (update)\n\t\tchip_write(chip,TDA985x_C6,c6);\n}\n\n\n \n \n\n \n\n#define TDA9873_SW\t0x00  \n#define TDA9873_AD\t0x01  \n#define TDA9873_PT\t0x02  \n\n \n#define TDA9873_INP_MASK    3\n#define TDA9873_INTERNAL    0\n#define TDA9873_EXT_STEREO  2\n#define TDA9873_EXT_MONO    1\n\n \n\n#define TDA9873_TR_MASK     (7 << 2)\n#define TDA9873_TR_MONO     4\n#define TDA9873_TR_STEREO   1 << 4\n#define TDA9873_TR_REVERSE  ((1 << 3) | (1 << 2))\n#define TDA9873_TR_DUALA    1 << 2\n#define TDA9873_TR_DUALB    1 << 3\n#define TDA9873_TR_DUALAB   0\n\n \n\n#define TDA9873_GAIN_NORMAL 1 << 5\n#define TDA9873_MUTE        1 << 6\n#define TDA9873_AUTOMUTE    1 << 7\n\n \n\n \n\n#define\tTDA9873_STEREO_ADJ\t0x06  \n\n \n#define TDA9873_BG\t\t0\n#define TDA9873_M       1\n#define TDA9873_DK1     2\n#define TDA9873_DK2     3\n#define TDA9873_DK3     4\n#define TDA9873_I       5\n\n \n#define TDA9873_IDR_NORM 0\n#define TDA9873_IDR_FAST 1 << 7\n\n\n \n\n \n\n#define TDA9873_PORTS    3\n\n \n#define TDA9873_TST_PORT 1 << 2\n\n \n#define TDA9873_MOUT_MONO   0\n#define TDA9873_MOUT_FMONO  0\n#define TDA9873_MOUT_DUALA  0\n#define TDA9873_MOUT_DUALB  1 << 3\n#define TDA9873_MOUT_ST     1 << 4\n#define TDA9873_MOUT_EXTM   ((1 << 4) | (1 << 3))\n#define TDA9873_MOUT_EXTL   1 << 5\n#define TDA9873_MOUT_EXTR   ((1 << 5) | (1 << 3))\n#define TDA9873_MOUT_EXTLR  ((1 << 5) | (1 << 4))\n#define TDA9873_MOUT_MUTE   ((1 << 5) | (1 << 4) | (1 << 3))\n\n \n#define TDA9873_PONR        0  \n#define TDA9873_STEREO      2  \n#define TDA9873_DUAL        4  \n\nstatic int tda9873_getrxsubchans(struct CHIPSTATE *chip)\n{\n\tstruct v4l2_subdev *sd = &chip->sd;\n\tint val,mode;\n\n\tmode = V4L2_TUNER_SUB_MONO;\n\n\tval = chip_read(chip);\n\tif (val < 0)\n\t\treturn mode;\n\n\tif (val & TDA9873_STEREO)\n\t\tmode = V4L2_TUNER_SUB_STEREO;\n\tif (val & TDA9873_DUAL)\n\t\tmode |= V4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;\n\tv4l2_dbg(1, debug, sd,\n\t\t\"tda9873_getrxsubchans(): raw chip read: %d, return: %d\\n\",\n\t\tval, mode);\n\treturn mode;\n}\n\nstatic void tda9873_setaudmode(struct CHIPSTATE *chip, int mode)\n{\n\tstruct v4l2_subdev *sd = &chip->sd;\n\tint sw_data  = chip->shadow.bytes[TDA9873_SW+1] & ~ TDA9873_TR_MASK;\n\t \n\n\tif ((sw_data & TDA9873_INP_MASK) != TDA9873_INTERNAL) {\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t \"tda9873_setaudmode(): external input\\n\");\n\t\treturn;\n\t}\n\n\tv4l2_dbg(1, debug, sd,\n\t\t \"tda9873_setaudmode(): chip->shadow.bytes[%d] = %d\\n\",\n\t\t TDA9873_SW+1, chip->shadow.bytes[TDA9873_SW+1]);\n\tv4l2_dbg(1, debug, sd, \"tda9873_setaudmode(): sw_data  = %d\\n\",\n\t\t sw_data);\n\n\tswitch (mode) {\n\tcase V4L2_TUNER_MODE_MONO:\n\t\tsw_data |= TDA9873_TR_MONO;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_STEREO:\n\t\tsw_data |= TDA9873_TR_STEREO;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_LANG1:\n\t\tsw_data |= TDA9873_TR_DUALA;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_LANG2:\n\t\tsw_data |= TDA9873_TR_DUALB;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_LANG1_LANG2:\n\t\tsw_data |= TDA9873_TR_DUALAB;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tchip_write(chip, TDA9873_SW, sw_data);\n\tv4l2_dbg(1, debug, sd,\n\t\t\"tda9873_setaudmode(): req. mode %d; chip_write: %d\\n\",\n\t\tmode, sw_data);\n}\n\nstatic int tda9873_checkit(struct CHIPSTATE *chip)\n{\n\tint rc;\n\n\trc = chip_read2(chip, 254);\n\tif (rc < 0)\n\t\treturn 0;\n\treturn (rc & ~0x1f) == 0x80;\n}\n\n\n \n \n \n\n \n#define TDA9874A_AGCGR\t\t0x00\t \n#define TDA9874A_GCONR\t\t0x01\t \n#define TDA9874A_MSR\t\t0x02\t \n#define TDA9874A_C1FRA\t\t0x03\t \n#define TDA9874A_C1FRB\t\t0x04\t \n#define TDA9874A_C1FRC\t\t0x05\t \n#define TDA9874A_C2FRA\t\t0x06\t \n#define TDA9874A_C2FRB\t\t0x07\t \n#define TDA9874A_C2FRC\t\t0x08\t \n#define TDA9874A_DCR\t\t0x09\t \n#define TDA9874A_FMER\t\t0x0a\t \n#define TDA9874A_FMMR\t\t0x0b\t \n#define TDA9874A_C1OLAR\t\t0x0c\t \n#define TDA9874A_C2OLAR\t\t0x0d\t \n#define TDA9874A_NCONR\t\t0x0e\t \n#define TDA9874A_NOLAR\t\t0x0f\t \n#define TDA9874A_NLELR\t\t0x10\t \n#define TDA9874A_NUELR\t\t0x11\t \n#define TDA9874A_AMCONR\t\t0x12\t \n#define TDA9874A_SDACOSR\t0x13\t \n#define TDA9874A_AOSR\t\t0x14\t \n#define TDA9874A_DAICONR\t0x15\t \n#define TDA9874A_I2SOSR\t\t0x16\t \n#define TDA9874A_I2SOLAR\t0x17\t \n#define TDA9874A_MDACOSR\t0x18\t \n#define TDA9874A_ESP\t\t0xFF\t \n\n \n#define TDA9874A_DSR\t\t0x00\t \n#define TDA9874A_NSR\t\t0x01\t \n#define TDA9874A_NECR\t\t0x02\t \n#define TDA9874A_DR1\t\t0x03\t \n#define TDA9874A_DR2\t\t0x04\t \n#define TDA9874A_LLRA\t\t0x05\t \n#define TDA9874A_LLRB\t\t0x06\t \n#define TDA9874A_SIFLR\t\t0x07\t \n#define TDA9874A_TR2\t\t252\t \n#define TDA9874A_TR1\t\t253\t \n#define TDA9874A_DIC\t\t254\t \n#define TDA9874A_SIC\t\t255\t \n\n\nstatic int tda9874a_mode = 1;\t\t \nstatic int tda9874a_GCONR = 0xc0;\t \nstatic int tda9874a_NCONR = 0x01;\t \nstatic int tda9874a_ESP = 0x07;\t\t \nstatic int tda9874a_dic = -1;\t\t \n\n \nstatic unsigned int tda9874a_SIF   = UNSET;\nstatic unsigned int tda9874a_AMSEL = UNSET;\nstatic unsigned int tda9874a_STD   = UNSET;\nmodule_param(tda9874a_SIF, int, 0444);\nmodule_param(tda9874a_AMSEL, int, 0444);\nmodule_param(tda9874a_STD, int, 0444);\n\n \nstatic struct tda9874a_MODES {\n\tchar *name;\n\taudiocmd cmd;\n} tda9874a_modelist[9] = {\n  {\t\"A2, B/G\",  \n\t{ 9, { TDA9874A_C1FRA, 0x72,0x95,0x55, 0x77,0xA0,0x00, 0x00,0x00 }} },\n  {\t\"A2, M (Korea)\",\n\t{ 9, { TDA9874A_C1FRA, 0x5D,0xC0,0x00, 0x62,0x6A,0xAA, 0x20,0x22 }} },\n  {\t\"A2, D/K (1)\",\n\t{ 9, { TDA9874A_C1FRA, 0x87,0x6A,0xAA, 0x82,0x60,0x00, 0x00,0x00 }} },\n  {\t\"A2, D/K (2)\",\n\t{ 9, { TDA9874A_C1FRA, 0x87,0x6A,0xAA, 0x8C,0x75,0x55, 0x00,0x00 }} },\n  {\t\"A2, D/K (3)\",\n\t{ 9, { TDA9874A_C1FRA, 0x87,0x6A,0xAA, 0x77,0xA0,0x00, 0x00,0x00 }} },\n  {\t\"NICAM, I\",\n\t{ 9, { TDA9874A_C1FRA, 0x7D,0x00,0x00, 0x88,0x8A,0xAA, 0x08,0x33 }} },\n  {\t\"NICAM, B/G\",\n\t{ 9, { TDA9874A_C1FRA, 0x72,0x95,0x55, 0x79,0xEA,0xAA, 0x08,0x33 }} },\n  {\t\"NICAM, D/K\",\n\t{ 9, { TDA9874A_C1FRA, 0x87,0x6A,0xAA, 0x79,0xEA,0xAA, 0x08,0x33 }} },\n  {\t\"NICAM, L\",\n\t{ 9, { TDA9874A_C1FRA, 0x87,0x6A,0xAA, 0x79,0xEA,0xAA, 0x09,0x33 }} }\n};\n\nstatic int tda9874a_setup(struct CHIPSTATE *chip)\n{\n\tstruct v4l2_subdev *sd = &chip->sd;\n\n\tchip_write(chip, TDA9874A_AGCGR, 0x00);  \n\tchip_write(chip, TDA9874A_GCONR, tda9874a_GCONR);\n\tchip_write(chip, TDA9874A_MSR, (tda9874a_mode) ? 0x03:0x02);\n\tif(tda9874a_dic == 0x11) {\n\t\tchip_write(chip, TDA9874A_FMMR, 0x80);\n\t} else {  \n\t\tchip_cmd(chip,\"tda9874_modelist\",&tda9874a_modelist[tda9874a_STD].cmd);\n\t\tchip_write(chip, TDA9874A_FMMR, 0x00);\n\t}\n\tchip_write(chip, TDA9874A_C1OLAR, 0x00);  \n\tchip_write(chip, TDA9874A_C2OLAR, 0x00);  \n\tchip_write(chip, TDA9874A_NCONR, tda9874a_NCONR);\n\tchip_write(chip, TDA9874A_NOLAR, 0x00);  \n\t \n\t \n\t \n\tchip_write(chip, TDA9874A_NLELR, 0x14);  \n\tchip_write(chip, TDA9874A_NUELR, 0x50);  \n\n\tif(tda9874a_dic == 0x11) {\n\t\tchip_write(chip, TDA9874A_AMCONR, 0xf9);\n\t\tchip_write(chip, TDA9874A_SDACOSR, (tda9874a_mode) ? 0x81:0x80);\n\t\tchip_write(chip, TDA9874A_AOSR, 0x80);\n\t\tchip_write(chip, TDA9874A_MDACOSR, (tda9874a_mode) ? 0x82:0x80);\n\t\tchip_write(chip, TDA9874A_ESP, tda9874a_ESP);\n\t} else {  \n\t\tchip_write(chip, TDA9874A_AMCONR, 0xfb);\n\t\tchip_write(chip, TDA9874A_SDACOSR, (tda9874a_mode) ? 0x81:0x80);\n\t\tchip_write(chip, TDA9874A_AOSR, 0x00);  \n\t}\n\tv4l2_dbg(1, debug, sd, \"tda9874a_setup(): %s [0x%02X].\\n\",\n\t\ttda9874a_modelist[tda9874a_STD].name,tda9874a_STD);\n\treturn 1;\n}\n\nstatic int tda9874a_getrxsubchans(struct CHIPSTATE *chip)\n{\n\tstruct v4l2_subdev *sd = &chip->sd;\n\tint dsr,nsr,mode;\n\tint necr;  \n\n\tmode = V4L2_TUNER_SUB_MONO;\n\n\tdsr = chip_read2(chip, TDA9874A_DSR);\n\tif (dsr < 0)\n\t\treturn mode;\n\tnsr = chip_read2(chip, TDA9874A_NSR);\n\tif (nsr < 0)\n\t\treturn mode;\n\tnecr = chip_read2(chip, TDA9874A_NECR);\n\tif (necr < 0)\n\t\treturn mode;\n\n\t \n\tchip->shadow.bytes[MAXREGS-2] = dsr;\n\tchip->shadow.bytes[MAXREGS-1] = nsr;\n\n\tif(tda9874a_mode) {\n\t\t \n\t\tif(nsr & 0x02)  \n\t\t\tmode = V4L2_TUNER_SUB_STEREO;\n\t\tif(nsr & 0x01)  \n\t\t\tmode |= V4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;\n\t} else {\n\t\tif(dsr & 0x02)  \n\t\t\tmode = V4L2_TUNER_SUB_STEREO;\n\t\tif(dsr & 0x04)  \n\t\t\tmode |= V4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;\n\t}\n\n\tv4l2_dbg(1, debug, sd,\n\t\t \"tda9874a_getrxsubchans(): DSR=0x%X, NSR=0x%X, NECR=0x%X, return: %d.\\n\",\n\t\t dsr, nsr, necr, mode);\n\treturn mode;\n}\n\nstatic void tda9874a_setaudmode(struct CHIPSTATE *chip, int mode)\n{\n\tstruct v4l2_subdev *sd = &chip->sd;\n\n\t \n\t \n\tif (tda9874a_mode) {\n\t\tif(chip->shadow.bytes[MAXREGS-2] & 0x20)  \n\t\t\ttda9874a_NCONR &= 0xfe;  \n\t\telse\n\t\t\ttda9874a_NCONR |= 0x01;  \n\t\tchip_write(chip, TDA9874A_NCONR, tda9874a_NCONR);\n\t}\n\n\t \n\tif(tda9874a_dic == 0x11) {\n\t\tint aosr = 0x80;\n\t\tint mdacosr = (tda9874a_mode) ? 0x82:0x80;\n\n\t\tswitch(mode) {\n\t\tcase V4L2_TUNER_MODE_MONO:\n\t\tcase V4L2_TUNER_MODE_STEREO:\n\t\t\tbreak;\n\t\tcase V4L2_TUNER_MODE_LANG1:\n\t\t\taosr = 0x80;  \n\t\t\tmdacosr = (tda9874a_mode) ? 0x82:0x80;\n\t\t\tbreak;\n\t\tcase V4L2_TUNER_MODE_LANG2:\n\t\t\taosr = 0xa0;  \n\t\t\tmdacosr = (tda9874a_mode) ? 0x83:0x81;\n\t\t\tbreak;\n\t\tcase V4L2_TUNER_MODE_LANG1_LANG2:\n\t\t\taosr = 0x00;  \n\t\t\tmdacosr = (tda9874a_mode) ? 0x82:0x80;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tchip_write(chip, TDA9874A_AOSR, aosr);\n\t\tchip_write(chip, TDA9874A_MDACOSR, mdacosr);\n\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t\"tda9874a_setaudmode(): req. mode %d; AOSR=0x%X, MDACOSR=0x%X.\\n\",\n\t\t\tmode, aosr, mdacosr);\n\n\t} else {  \n\t\tint fmmr,aosr;\n\n\t\tswitch(mode) {\n\t\tcase V4L2_TUNER_MODE_MONO:\n\t\t\tfmmr = 0x00;  \n\t\t\taosr = 0x10;  \n\t\t\tbreak;\n\t\tcase V4L2_TUNER_MODE_STEREO:\n\t\t\tif(tda9874a_mode) {\n\t\t\t\tfmmr = 0x00;\n\t\t\t\taosr = 0x00;  \n\t\t\t} else {\n\t\t\t\tfmmr = (tda9874a_ESP == 1) ? 0x05 : 0x04;  \n\t\t\t\taosr = 0x00;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase V4L2_TUNER_MODE_LANG1:\n\t\t\tfmmr = 0x02;  \n\t\t\taosr = 0x10;  \n\t\t\tbreak;\n\t\tcase V4L2_TUNER_MODE_LANG2:\n\t\t\tfmmr = 0x02;  \n\t\t\taosr = 0x20;  \n\t\t\tbreak;\n\t\tcase V4L2_TUNER_MODE_LANG1_LANG2:\n\t\t\tfmmr = 0x02;  \n\t\t\taosr = 0x00;  \n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tchip_write(chip, TDA9874A_FMMR, fmmr);\n\t\tchip_write(chip, TDA9874A_AOSR, aosr);\n\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t\"tda9874a_setaudmode(): req. mode %d; FMMR=0x%X, AOSR=0x%X.\\n\",\n\t\t\tmode, fmmr, aosr);\n\t}\n}\n\nstatic int tda9874a_checkit(struct CHIPSTATE *chip)\n{\n\tstruct v4l2_subdev *sd = &chip->sd;\n\tint dic,sic;\t \n\n\tdic = chip_read2(chip, TDA9874A_DIC);\n\tif (dic < 0)\n\t\treturn 0;\n\tsic = chip_read2(chip, TDA9874A_SIC);\n\tif (sic < 0)\n\t\treturn 0;\n\n\tv4l2_dbg(1, debug, sd, \"tda9874a_checkit(): DIC=0x%X, SIC=0x%X.\\n\", dic, sic);\n\n\tif((dic == 0x11)||(dic == 0x07)) {\n\t\tv4l2_info(sd, \"found tda9874%s.\\n\", (dic == 0x11) ? \"a\" : \"h\");\n\t\ttda9874a_dic = dic;\t \n\t\treturn 1;\n\t}\n\treturn 0;\t \n}\n\nstatic int tda9874a_initialize(struct CHIPSTATE *chip)\n{\n\tif (tda9874a_SIF > 2)\n\t\ttda9874a_SIF = 1;\n\tif (tda9874a_STD >= ARRAY_SIZE(tda9874a_modelist))\n\t\ttda9874a_STD = 0;\n\tif(tda9874a_AMSEL > 1)\n\t\ttda9874a_AMSEL = 0;\n\n\tif(tda9874a_SIF == 1)\n\t\ttda9874a_GCONR = 0xc0;\t \n\telse\n\t\ttda9874a_GCONR = 0xc1;\t \n\n\ttda9874a_ESP = tda9874a_STD;\n\ttda9874a_mode = (tda9874a_STD < 5) ? 0 : 1;\n\n\tif(tda9874a_AMSEL == 0)\n\t\ttda9874a_NCONR = 0x01;  \n\telse\n\t\ttda9874a_NCONR = 0x05;  \n\n\ttda9874a_setup(chip);\n\treturn 0;\n}\n\n \n \n \n\n \n#define TDA9875_MUT         0x12   \n#define TDA9875_CFG         0x01   \n#define TDA9875_DACOS       0x13   \n#define TDA9875_LOSR        0x16   \n\n#define TDA9875_CH1V        0x0c   \n#define TDA9875_CH2V        0x0d   \n#define TDA9875_SC1         0x14   \n#define TDA9875_SC2         0x15   \n\n#define TDA9875_ADCIS       0x17   \n#define TDA9875_AER         0x19   \n#define TDA9875_MCS         0x18   \n#define TDA9875_MVL         0x1a   \n#define TDA9875_MVR         0x1b   \n#define TDA9875_MBA         0x1d   \n#define TDA9875_MTR         0x1e   \n#define TDA9875_ACS         0x1f   \n#define TDA9875_AVL         0x20   \n#define TDA9875_AVR         0x21   \n#define TDA9875_ABA         0x22   \n#define TDA9875_ATR         0x23   \n\n#define TDA9875_MSR         0x02   \n#define TDA9875_C1MSB       0x03   \n#define TDA9875_C1MIB       0x04   \n#define TDA9875_C1LSB       0x05   \n#define TDA9875_C2MSB       0x06   \n#define TDA9875_C2MIB       0x07   \n#define TDA9875_C2LSB       0x08   \n#define TDA9875_DCR         0x09   \n#define TDA9875_DEEM        0x0a   \n#define TDA9875_FMAT        0x0b   \n\n \n#define TDA9875_MUTE_ON\t    0xff  \n#define TDA9875_MUTE_OFF    0xcc  \n\nstatic int tda9875_initialize(struct CHIPSTATE *chip)\n{\n\tchip_write(chip, TDA9875_CFG, 0xd0);  \n\tchip_write(chip, TDA9875_MSR, 0x03);     \n\tchip_write(chip, TDA9875_C1MSB, 0x00);   \n\tchip_write(chip, TDA9875_C1MIB, 0x00);   \n\tchip_write(chip, TDA9875_C1LSB, 0x00);   \n\tchip_write(chip, TDA9875_C2MSB, 0x00);   \n\tchip_write(chip, TDA9875_C2MIB, 0x00);   \n\tchip_write(chip, TDA9875_C2LSB, 0x00);   \n\tchip_write(chip, TDA9875_DCR, 0x00);     \n\tchip_write(chip, TDA9875_DEEM, 0x44);    \n\tchip_write(chip, TDA9875_FMAT, 0x00);    \n\tchip_write(chip, TDA9875_SC1, 0x00);     \n\tchip_write(chip, TDA9875_SC2, 0x01);     \n\n\tchip_write(chip, TDA9875_CH1V, 0x10);   \n\tchip_write(chip, TDA9875_CH2V, 0x10);   \n\tchip_write(chip, TDA9875_DACOS, 0x02);  \n\tchip_write(chip, TDA9875_ADCIS, 0x6f);  \n\tchip_write(chip, TDA9875_LOSR, 0x00);   \n\tchip_write(chip, TDA9875_AER, 0x00);    \n\tchip_write(chip, TDA9875_MCS, 0x44);    \n\tchip_write(chip, TDA9875_MVL, 0x03);    \n\tchip_write(chip, TDA9875_MVR, 0x03);    \n\tchip_write(chip, TDA9875_MBA, 0x00);    \n\tchip_write(chip, TDA9875_MTR, 0x00);    \n\tchip_write(chip, TDA9875_ACS, 0x44);    \n\tchip_write(chip, TDA9875_AVL, 0x00);    \n\tchip_write(chip, TDA9875_AVR, 0x00);    \n\tchip_write(chip, TDA9875_ABA, 0x00);    \n\tchip_write(chip, TDA9875_ATR, 0x00);    \n\n\tchip_write(chip, TDA9875_MUT, 0xcc);    \n\treturn 0;\n}\n\nstatic int tda9875_volume(int val) { return (unsigned char)(val / 602 - 84); }\nstatic int tda9875_bass(int val) { return (unsigned char)(max(-12, val / 2115 - 15)); }\nstatic int tda9875_treble(int val) { return (unsigned char)(val / 2622 - 12); }\n\n \n\n\n \n\nstatic int tda9875_checkit(struct CHIPSTATE *chip)\n{\n\tstruct v4l2_subdev *sd = &chip->sd;\n\tint dic, rev;\n\n\tdic = chip_read2(chip, 254);\n\tif (dic < 0)\n\t\treturn 0;\n\trev = chip_read2(chip, 255);\n\tif (rev < 0)\n\t\treturn 0;\n\n\tif (dic == 0 || dic == 2) {  \n\t\tv4l2_info(sd, \"found tda9875%s rev. %d.\\n\",\n\t\t\tdic == 0 ? \"\" : \"A\", rev);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \n \n\n#define TEA6300_VL         0x00   \n#define TEA6300_VR         0x01   \n#define TEA6300_BA         0x02   \n#define TEA6300_TR         0x03   \n#define TEA6300_FA         0x04   \n#define TEA6300_S          0x05   \n\t\t\t\t  \n#define TEA6300_S_SA       0x01   \n#define TEA6300_S_SB       0x02   \n#define TEA6300_S_SC       0x04   \n#define TEA6300_S_GMU      0x80   \n\n#define TEA6320_V          0x00   \n#define TEA6320_FFR        0x01   \n#define TEA6320_FFL        0x02   \n#define TEA6320_FRR        0x03   \n#define TEA6320_FRL        0x04   \n#define TEA6320_BA         0x05   \n#define TEA6320_TR         0x06   \n#define TEA6320_S          0x07   \n\t\t\t\t  \n#define TEA6320_S_SA       0x07   \n#define TEA6320_S_SB       0x06   \n#define TEA6320_S_SC       0x05   \n#define TEA6320_S_SD       0x04   \n#define TEA6320_S_GMU      0x80   \n\n#define TEA6420_S_SA       0x00   \n#define TEA6420_S_SB       0x01   \n#define TEA6420_S_SC       0x02   \n#define TEA6420_S_SD       0x03   \n#define TEA6420_S_SE       0x04   \n#define TEA6420_S_GMU      0x05   \n\nstatic int tea6300_shift10(int val) { return val >> 10; }\nstatic int tea6300_shift12(int val) { return val >> 12; }\n\n \n \nstatic int tea6320_volume(int val) { return (val / (65535/(63-12)) + 12) & 0x3f; }\nstatic int tea6320_shift11(int val) { return val >> 11; }\nstatic int tea6320_initialize(struct CHIPSTATE * chip)\n{\n\tchip_write(chip, TEA6320_FFR, 0x3f);\n\tchip_write(chip, TEA6320_FFL, 0x3f);\n\tchip_write(chip, TEA6320_FRR, 0x3f);\n\tchip_write(chip, TEA6320_FRL, 0x3f);\n\n\treturn 0;\n}\n\n\n \n \n\n#define TDA8425_VL         0x00   \n#define TDA8425_VR         0x01   \n#define TDA8425_BA         0x02   \n#define TDA8425_TR         0x03   \n#define TDA8425_S1         0x08   \n\t\t\t\t  \n#define TDA8425_S1_OFF     0xEE   \n#define TDA8425_S1_CH1     0xCE   \n#define TDA8425_S1_CH2     0xCF   \n#define TDA8425_S1_MU      0x20   \n#define TDA8425_S1_STEREO  0x18   \n#define TDA8425_S1_STEREO_SPATIAL 0x18  \n#define TDA8425_S1_STEREO_LINEAR  0x08  \n#define TDA8425_S1_STEREO_PSEUDO  0x10  \n#define TDA8425_S1_STEREO_MONO    0x00  \n#define TDA8425_S1_ML      0x06         \n#define TDA8425_S1_ML_SOUND_A 0x02      \n#define TDA8425_S1_ML_SOUND_B 0x04      \n#define TDA8425_S1_ML_STEREO  0x06      \n#define TDA8425_S1_IS      0x01         \n\n\nstatic int tda8425_shift10(int val) { return (val >> 10) | 0xc0; }\nstatic int tda8425_shift12(int val) { return (val >> 12) | 0xf0; }\n\nstatic void tda8425_setaudmode(struct CHIPSTATE *chip, int mode)\n{\n\tint s1 = chip->shadow.bytes[TDA8425_S1+1] & 0xe1;\n\n\tswitch (mode) {\n\tcase V4L2_TUNER_MODE_LANG1:\n\t\ts1 |= TDA8425_S1_ML_SOUND_A;\n\t\ts1 |= TDA8425_S1_STEREO_PSEUDO;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_LANG2:\n\t\ts1 |= TDA8425_S1_ML_SOUND_B;\n\t\ts1 |= TDA8425_S1_STEREO_PSEUDO;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_LANG1_LANG2:\n\t\ts1 |= TDA8425_S1_ML_STEREO;\n\t\ts1 |= TDA8425_S1_STEREO_LINEAR;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_MONO:\n\t\ts1 |= TDA8425_S1_ML_STEREO;\n\t\ts1 |= TDA8425_S1_STEREO_MONO;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_STEREO:\n\t\ts1 |= TDA8425_S1_ML_STEREO;\n\t\ts1 |= TDA8425_S1_STEREO_SPATIAL;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tchip_write(chip,TDA8425_S1,s1);\n}\n\n\n \n \n\n \n#define PIC16C54_REG_KEY_CODE     0x01\t        \n#define PIC16C54_REG_MISC         0x02\n\n \n#define PIC16C54_MISC_RESET_REMOTE_CTL 0x01  \n\t\t\t\t\t     \n#define PIC16C54_MISC_MTS_MAIN         0x02  \n#define PIC16C54_MISC_MTS_SAP          0x04  \n#define PIC16C54_MISC_MTS_BOTH         0x08  \n#define PIC16C54_MISC_SND_MUTE         0x10  \n#define PIC16C54_MISC_SND_NOTMUTE      0x20  \n#define PIC16C54_MISC_SWITCH_TUNER     0x40  \n#define PIC16C54_MISC_SWITCH_LINE      0x80  \n\n \n \n\n \n#define TA8874Z_LED_STE\t0x80\n#define TA8874Z_LED_BIL\t0x40\n#define TA8874Z_LED_EXT\t0x20\n#define TA8874Z_MONO_SET\t0x10\n#define TA8874Z_MUTE\t0x08\n#define TA8874Z_F_MONO\t0x04\n#define TA8874Z_MODE_SUB\t0x02\n#define TA8874Z_MODE_MAIN\t0x01\n\n \n   \n#define TA8874Z_SEPARATION\t0x3f\n#define TA8874Z_SEPARATION_DEFAULT\t0x10\n\n \n#define TA8874Z_B1\t0x80\n#define TA8874Z_B0\t0x40\n#define TA8874Z_CHAG_FLAG\t0x20\n\n \nstatic int ta8874z_getrxsubchans(struct CHIPSTATE *chip)\n{\n\tint val, mode;\n\n\tmode = V4L2_TUNER_SUB_MONO;\n\n\tval = chip_read(chip);\n\tif (val < 0)\n\t\treturn mode;\n\n\tif (val & TA8874Z_B1){\n\t\tmode |= V4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;\n\t}else if (!(val & TA8874Z_B0)){\n\t\tmode = V4L2_TUNER_SUB_STEREO;\n\t}\n\t \n\treturn mode;\n}\n\nstatic audiocmd ta8874z_stereo = { 2, {0, TA8874Z_SEPARATION_DEFAULT}};\nstatic audiocmd ta8874z_mono = {2, { TA8874Z_MONO_SET, TA8874Z_SEPARATION_DEFAULT}};\nstatic audiocmd ta8874z_main = {2, { 0, TA8874Z_SEPARATION_DEFAULT}};\nstatic audiocmd ta8874z_sub = {2, { TA8874Z_MODE_SUB, TA8874Z_SEPARATION_DEFAULT}};\nstatic audiocmd ta8874z_both = {2, { TA8874Z_MODE_MAIN | TA8874Z_MODE_SUB, TA8874Z_SEPARATION_DEFAULT}};\n\nstatic void ta8874z_setaudmode(struct CHIPSTATE *chip, int mode)\n{\n\tstruct v4l2_subdev *sd = &chip->sd;\n\tint update = 1;\n\taudiocmd *t = NULL;\n\n\tv4l2_dbg(1, debug, sd, \"ta8874z_setaudmode(): mode: 0x%02x\\n\", mode);\n\n\tswitch(mode){\n\tcase V4L2_TUNER_MODE_MONO:\n\t\tt = &ta8874z_mono;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_STEREO:\n\t\tt = &ta8874z_stereo;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_LANG1:\n\t\tt = &ta8874z_main;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_LANG2:\n\t\tt = &ta8874z_sub;\n\t\tbreak;\n\tcase V4L2_TUNER_MODE_LANG1_LANG2:\n\t\tt = &ta8874z_both;\n\t\tbreak;\n\tdefault:\n\t\tupdate = 0;\n\t}\n\n\tif(update)\n\t\tchip_cmd(chip, \"TA8874Z\", t);\n}\n\nstatic int ta8874z_checkit(struct CHIPSTATE *chip)\n{\n\tint rc;\n\n\trc = chip_read(chip);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn ((rc & 0x1f) == 0x1f) ? 1 : 0;\n}\n\n \n \n\n \nstatic int tda8425  = 1;\nstatic int tda9840  = 1;\nstatic int tda9850  = 1;\nstatic int tda9855  = 1;\nstatic int tda9873  = 1;\nstatic int tda9874a = 1;\nstatic int tda9875  = 1;\nstatic int tea6300;\t \nstatic int tea6320;\t \nstatic int tea6420  = 1;\nstatic int pic16c54 = 1;\nstatic int ta8874z;\t \n\nmodule_param(tda8425, int, 0444);\nmodule_param(tda9840, int, 0444);\nmodule_param(tda9850, int, 0444);\nmodule_param(tda9855, int, 0444);\nmodule_param(tda9873, int, 0444);\nmodule_param(tda9874a, int, 0444);\nmodule_param(tda9875, int, 0444);\nmodule_param(tea6300, int, 0444);\nmodule_param(tea6320, int, 0444);\nmodule_param(tea6420, int, 0444);\nmodule_param(pic16c54, int, 0444);\nmodule_param(ta8874z, int, 0444);\n\nstatic struct CHIPDESC chiplist[] = {\n\t{\n\t\t.name       = \"tda9840\",\n\t\t.insmodopt  = &tda9840,\n\t\t.addr_lo    = I2C_ADDR_TDA9840 >> 1,\n\t\t.addr_hi    = I2C_ADDR_TDA9840 >> 1,\n\t\t.registers  = 5,\n\t\t.flags      = CHIP_NEED_CHECKMODE,\n\n\t\t \n\t\t.checkit    = tda9840_checkit,\n\t\t.getrxsubchans = tda9840_getrxsubchans,\n\t\t.setaudmode = tda9840_setaudmode,\n\n\t\t.init       = { 2, { TDA9840_TEST, TDA9840_TEST_INT1SN\n\t\t\t\t } }\n\t},\n\t{\n\t\t.name       = \"tda9873h\",\n\t\t.insmodopt  = &tda9873,\n\t\t.addr_lo    = I2C_ADDR_TDA985x_L >> 1,\n\t\t.addr_hi    = I2C_ADDR_TDA985x_H >> 1,\n\t\t.registers  = 3,\n\t\t.flags      = CHIP_HAS_INPUTSEL | CHIP_NEED_CHECKMODE,\n\n\t\t \n\t\t.checkit    = tda9873_checkit,\n\t\t.getrxsubchans = tda9873_getrxsubchans,\n\t\t.setaudmode = tda9873_setaudmode,\n\n\t\t.init       = { 4, { TDA9873_SW, 0xa4, 0x06, 0x03 } },\n\t\t.inputreg   = TDA9873_SW,\n\t\t.inputmute  = TDA9873_MUTE | TDA9873_AUTOMUTE,\n\t\t.inputmap   = {0xa0, 0xa2, 0xa0, 0xa0},\n\t\t.inputmask  = TDA9873_INP_MASK|TDA9873_MUTE|TDA9873_AUTOMUTE,\n\n\t},\n\t{\n\t\t.name       = \"tda9874h/a\",\n\t\t.insmodopt  = &tda9874a,\n\t\t.addr_lo    = I2C_ADDR_TDA9874 >> 1,\n\t\t.addr_hi    = I2C_ADDR_TDA9874 >> 1,\n\t\t.flags      = CHIP_NEED_CHECKMODE,\n\n\t\t \n\t\t.initialize = tda9874a_initialize,\n\t\t.checkit    = tda9874a_checkit,\n\t\t.getrxsubchans = tda9874a_getrxsubchans,\n\t\t.setaudmode = tda9874a_setaudmode,\n\t},\n\t{\n\t\t.name       = \"tda9875\",\n\t\t.insmodopt  = &tda9875,\n\t\t.addr_lo    = I2C_ADDR_TDA9875 >> 1,\n\t\t.addr_hi    = I2C_ADDR_TDA9875 >> 1,\n\t\t.flags      = CHIP_HAS_VOLUME | CHIP_HAS_BASSTREBLE,\n\n\t\t \n\t\t.initialize = tda9875_initialize,\n\t\t.checkit    = tda9875_checkit,\n\t\t.volfunc    = tda9875_volume,\n\t\t.bassfunc   = tda9875_bass,\n\t\t.treblefunc = tda9875_treble,\n\t\t.leftreg    = TDA9875_MVL,\n\t\t.rightreg   = TDA9875_MVR,\n\t\t.bassreg    = TDA9875_MBA,\n\t\t.treblereg  = TDA9875_MTR,\n\t\t.volinit    = 58880,\n\t},\n\t{\n\t\t.name       = \"tda9850\",\n\t\t.insmodopt  = &tda9850,\n\t\t.addr_lo    = I2C_ADDR_TDA985x_L >> 1,\n\t\t.addr_hi    = I2C_ADDR_TDA985x_H >> 1,\n\t\t.registers  = 11,\n\n\t\t.getrxsubchans = tda985x_getrxsubchans,\n\t\t.setaudmode = tda985x_setaudmode,\n\n\t\t.init       = { 8, { TDA9850_C4, 0x08, 0x08, TDA985x_STEREO, 0x07, 0x10, 0x10, 0x03 } }\n\t},\n\t{\n\t\t.name       = \"tda9855\",\n\t\t.insmodopt  = &tda9855,\n\t\t.addr_lo    = I2C_ADDR_TDA985x_L >> 1,\n\t\t.addr_hi    = I2C_ADDR_TDA985x_H >> 1,\n\t\t.registers  = 11,\n\t\t.flags      = CHIP_HAS_VOLUME | CHIP_HAS_BASSTREBLE,\n\n\t\t.leftreg    = TDA9855_VL,\n\t\t.rightreg   = TDA9855_VR,\n\t\t.bassreg    = TDA9855_BA,\n\t\t.treblereg  = TDA9855_TR,\n\n\t\t \n\t\t.volfunc    = tda9855_volume,\n\t\t.bassfunc   = tda9855_bass,\n\t\t.treblefunc = tda9855_treble,\n\t\t.getrxsubchans = tda985x_getrxsubchans,\n\t\t.setaudmode = tda985x_setaudmode,\n\n\t\t.init       = { 12, { 0, 0x6f, 0x6f, 0x0e, 0x07<<1, 0x8<<2,\n\t\t\t\t    TDA9855_MUTE | TDA9855_AVL | TDA9855_LOUD | TDA9855_INT,\n\t\t\t\t    TDA985x_STEREO | TDA9855_LINEAR | TDA9855_TZCM | TDA9855_VZCM,\n\t\t\t\t    0x07, 0x10, 0x10, 0x03 }}\n\t},\n\t{\n\t\t.name       = \"tea6300\",\n\t\t.insmodopt  = &tea6300,\n\t\t.addr_lo    = I2C_ADDR_TEA6300 >> 1,\n\t\t.addr_hi    = I2C_ADDR_TEA6300 >> 1,\n\t\t.registers  = 6,\n\t\t.flags      = CHIP_HAS_VOLUME | CHIP_HAS_BASSTREBLE | CHIP_HAS_INPUTSEL,\n\n\t\t.leftreg    = TEA6300_VR,\n\t\t.rightreg   = TEA6300_VL,\n\t\t.bassreg    = TEA6300_BA,\n\t\t.treblereg  = TEA6300_TR,\n\n\t\t \n\t\t.volfunc    = tea6300_shift10,\n\t\t.bassfunc   = tea6300_shift12,\n\t\t.treblefunc = tea6300_shift12,\n\n\t\t.inputreg   = TEA6300_S,\n\t\t.inputmap   = { TEA6300_S_SA, TEA6300_S_SB, TEA6300_S_SC },\n\t\t.inputmute  = TEA6300_S_GMU,\n\t},\n\t{\n\t\t.name       = \"tea6320\",\n\t\t.insmodopt  = &tea6320,\n\t\t.addr_lo    = I2C_ADDR_TEA6300 >> 1,\n\t\t.addr_hi    = I2C_ADDR_TEA6300 >> 1,\n\t\t.registers  = 8,\n\t\t.flags      = CHIP_HAS_VOLUME | CHIP_HAS_BASSTREBLE | CHIP_HAS_INPUTSEL,\n\n\t\t.leftreg    = TEA6320_V,\n\t\t.rightreg   = TEA6320_V,\n\t\t.bassreg    = TEA6320_BA,\n\t\t.treblereg  = TEA6320_TR,\n\n\t\t \n\t\t.initialize = tea6320_initialize,\n\t\t.volfunc    = tea6320_volume,\n\t\t.bassfunc   = tea6320_shift11,\n\t\t.treblefunc = tea6320_shift11,\n\n\t\t.inputreg   = TEA6320_S,\n\t\t.inputmap   = { TEA6320_S_SA, TEA6420_S_SB, TEA6300_S_SC, TEA6320_S_SD },\n\t\t.inputmute  = TEA6300_S_GMU,\n\t},\n\t{\n\t\t.name       = \"tea6420\",\n\t\t.insmodopt  = &tea6420,\n\t\t.addr_lo    = I2C_ADDR_TEA6420 >> 1,\n\t\t.addr_hi    = I2C_ADDR_TEA6420 >> 1,\n\t\t.registers  = 1,\n\t\t.flags      = CHIP_HAS_INPUTSEL,\n\n\t\t.inputreg   = -1,\n\t\t.inputmap   = { TEA6420_S_SA, TEA6420_S_SB, TEA6420_S_SC },\n\t\t.inputmute  = TEA6420_S_GMU,\n\t\t.inputmask  = 0x07,\n\t},\n\t{\n\t\t.name       = \"tda8425\",\n\t\t.insmodopt  = &tda8425,\n\t\t.addr_lo    = I2C_ADDR_TDA8425 >> 1,\n\t\t.addr_hi    = I2C_ADDR_TDA8425 >> 1,\n\t\t.registers  = 9,\n\t\t.flags      = CHIP_HAS_VOLUME | CHIP_HAS_BASSTREBLE | CHIP_HAS_INPUTSEL,\n\n\t\t.leftreg    = TDA8425_VL,\n\t\t.rightreg   = TDA8425_VR,\n\t\t.bassreg    = TDA8425_BA,\n\t\t.treblereg  = TDA8425_TR,\n\n\t\t \n\t\t.volfunc    = tda8425_shift10,\n\t\t.bassfunc   = tda8425_shift12,\n\t\t.treblefunc = tda8425_shift12,\n\t\t.setaudmode = tda8425_setaudmode,\n\n\t\t.inputreg   = TDA8425_S1,\n\t\t.inputmap   = { TDA8425_S1_CH1, TDA8425_S1_CH1, TDA8425_S1_CH1 },\n\t\t.inputmute  = TDA8425_S1_OFF,\n\n\t},\n\t{\n\t\t.name       = \"pic16c54 (PV951)\",\n\t\t.insmodopt  = &pic16c54,\n\t\t.addr_lo    = I2C_ADDR_PIC16C54 >> 1,\n\t\t.addr_hi    = I2C_ADDR_PIC16C54>> 1,\n\t\t.registers  = 2,\n\t\t.flags      = CHIP_HAS_INPUTSEL,\n\n\t\t.inputreg   = PIC16C54_REG_MISC,\n\t\t.inputmap   = {PIC16C54_MISC_SND_NOTMUTE|PIC16C54_MISC_SWITCH_TUNER,\n\t\t\t     PIC16C54_MISC_SND_NOTMUTE|PIC16C54_MISC_SWITCH_LINE,\n\t\t\t     PIC16C54_MISC_SND_NOTMUTE|PIC16C54_MISC_SWITCH_LINE,\n\t\t\t     PIC16C54_MISC_SND_MUTE},\n\t\t.inputmute  = PIC16C54_MISC_SND_MUTE,\n\t},\n\t{\n\t\t.name       = \"ta8874z\",\n\t\t.checkit    = ta8874z_checkit,\n\t\t.insmodopt  = &ta8874z,\n\t\t.addr_lo    = I2C_ADDR_TDA9840 >> 1,\n\t\t.addr_hi    = I2C_ADDR_TDA9840 >> 1,\n\t\t.registers  = 2,\n\n\t\t \n\t\t.getrxsubchans = ta8874z_getrxsubchans,\n\t\t.setaudmode = ta8874z_setaudmode,\n\n\t\t.init       = {2, { TA8874Z_MONO_SET, TA8874Z_SEPARATION_DEFAULT}},\n\t},\n\t{ .name = NULL }  \n};\n\n\n \n\nstatic int tvaudio_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_sd(ctrl);\n\tstruct CHIPSTATE *chip = to_state(sd);\n\tstruct CHIPDESC *desc = chip->desc;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\tchip->muted = ctrl->val;\n\t\tif (chip->muted)\n\t\t\tchip_write_masked(chip,desc->inputreg,desc->inputmute,desc->inputmask);\n\t\telse\n\t\t\tchip_write_masked(chip,desc->inputreg,\n\t\t\t\t\tdesc->inputmap[chip->input],desc->inputmask);\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_VOLUME: {\n\t\tu32 volume, balance;\n\t\tu32 left, right;\n\n\t\tvolume = chip->volume->val;\n\t\tbalance = chip->balance->val;\n\t\tleft = (min(65536U - balance, 32768U) * volume) / 32768U;\n\t\tright = (min(balance, 32768U) * volume) / 32768U;\n\n\t\tchip_write(chip, desc->leftreg, desc->volfunc(left));\n\t\tchip_write(chip, desc->rightreg, desc->volfunc(right));\n\t\treturn 0;\n\t}\n\tcase V4L2_CID_AUDIO_BASS:\n\t\tchip_write(chip, desc->bassreg, desc->bassfunc(ctrl->val));\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_TREBLE:\n\t\tchip_write(chip, desc->treblereg, desc->treblefunc(ctrl->val));\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n\n \n \n\nstatic int tvaudio_s_radio(struct v4l2_subdev *sd)\n{\n\tstruct CHIPSTATE *chip = to_state(sd);\n\n\tchip->radio = 1;\n\t \n\treturn 0;\n}\n\nstatic int tvaudio_s_routing(struct v4l2_subdev *sd,\n\t\t\t     u32 input, u32 output, u32 config)\n{\n\tstruct CHIPSTATE *chip = to_state(sd);\n\tstruct CHIPDESC *desc = chip->desc;\n\n\tif (!(desc->flags & CHIP_HAS_INPUTSEL))\n\t\treturn 0;\n\tif (input >= 4)\n\t\treturn -EINVAL;\n\t \n\tchip->input = input;\n\tif (chip->muted)\n\t\treturn 0;\n\tchip_write_masked(chip, desc->inputreg,\n\t\t\tdesc->inputmap[chip->input], desc->inputmask);\n\treturn 0;\n}\n\nstatic int tvaudio_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *vt)\n{\n\tstruct CHIPSTATE *chip = to_state(sd);\n\tstruct CHIPDESC *desc = chip->desc;\n\n\tif (!desc->setaudmode)\n\t\treturn 0;\n\tif (chip->radio)\n\t\treturn 0;\n\n\tswitch (vt->audmode) {\n\tcase V4L2_TUNER_MODE_MONO:\n\tcase V4L2_TUNER_MODE_STEREO:\n\tcase V4L2_TUNER_MODE_LANG1:\n\tcase V4L2_TUNER_MODE_LANG2:\n\tcase V4L2_TUNER_MODE_LANG1_LANG2:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tchip->audmode = vt->audmode;\n\n\tif (chip->thread)\n\t\twake_up_process(chip->thread);\n\telse\n\t\tdesc->setaudmode(chip, vt->audmode);\n\n\treturn 0;\n}\n\nstatic int tvaudio_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\n{\n\tstruct CHIPSTATE *chip = to_state(sd);\n\tstruct CHIPDESC *desc = chip->desc;\n\n\tif (!desc->getrxsubchans)\n\t\treturn 0;\n\tif (chip->radio)\n\t\treturn 0;\n\n\tvt->audmode = chip->audmode;\n\tvt->rxsubchans = desc->getrxsubchans(chip);\n\tvt->capability |= V4L2_TUNER_CAP_STEREO |\n\t\tV4L2_TUNER_CAP_LANG1 | V4L2_TUNER_CAP_LANG2;\n\n\treturn 0;\n}\n\nstatic int tvaudio_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct CHIPSTATE *chip = to_state(sd);\n\n\tchip->radio = 0;\n\treturn 0;\n}\n\nstatic int tvaudio_s_frequency(struct v4l2_subdev *sd, const struct v4l2_frequency *freq)\n{\n\tstruct CHIPSTATE *chip = to_state(sd);\n\tstruct CHIPDESC *desc = chip->desc;\n\n\t \n\tif (chip->thread) {\n\t\tdesc->setaudmode(chip, V4L2_TUNER_MODE_MONO);\n\t\tchip->prevmode = -1;  \n\t\tmod_timer(&chip->wt, jiffies+msecs_to_jiffies(2000));\n\t}\n\treturn 0;\n}\n\nstatic int tvaudio_log_status(struct v4l2_subdev *sd)\n{\n\tstruct CHIPSTATE *chip = to_state(sd);\n\tstruct CHIPDESC *desc = chip->desc;\n\n\tv4l2_info(sd, \"Chip: %s\\n\", desc->name);\n\tv4l2_ctrl_handler_log_status(&chip->hdl, sd->name);\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_ctrl_ops tvaudio_ctrl_ops = {\n\t.s_ctrl = tvaudio_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops tvaudio_core_ops = {\n\t.log_status = tvaudio_log_status,\n};\n\nstatic const struct v4l2_subdev_tuner_ops tvaudio_tuner_ops = {\n\t.s_radio = tvaudio_s_radio,\n\t.s_frequency = tvaudio_s_frequency,\n\t.s_tuner = tvaudio_s_tuner,\n\t.g_tuner = tvaudio_g_tuner,\n};\n\nstatic const struct v4l2_subdev_audio_ops tvaudio_audio_ops = {\n\t.s_routing = tvaudio_s_routing,\n};\n\nstatic const struct v4l2_subdev_video_ops tvaudio_video_ops = {\n\t.s_std = tvaudio_s_std,\n};\n\nstatic const struct v4l2_subdev_ops tvaudio_ops = {\n\t.core = &tvaudio_core_ops,\n\t.tuner = &tvaudio_tuner_ops,\n\t.audio = &tvaudio_audio_ops,\n\t.video = &tvaudio_video_ops,\n};\n\n \n\n\n \n\nstatic int tvaudio_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct CHIPSTATE *chip;\n\tstruct CHIPDESC  *desc;\n\tstruct v4l2_subdev *sd;\n\n\tif (debug) {\n\t\tprintk(KERN_INFO \"tvaudio: TV audio decoder + audio/video mux driver\\n\");\n\t\tprintk(KERN_INFO \"tvaudio: known chips: \");\n\t\tfor (desc = chiplist; desc->name != NULL; desc++)\n\t\t\tprintk(KERN_CONT \"%s%s\",\n\t\t\t       (desc == chiplist) ? \"\" : \", \", desc->name);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\tsd = &chip->sd;\n\tv4l2_i2c_subdev_init(sd, client, &tvaudio_ops);\n\n\t \n\tv4l2_dbg(1, debug, sd, \"chip found @ 0x%x\\n\", client->addr<<1);\n\tfor (desc = chiplist; desc->name != NULL; desc++) {\n\t\tif (0 == *(desc->insmodopt))\n\t\t\tcontinue;\n\t\tif (client->addr < desc->addr_lo ||\n\t\t    client->addr > desc->addr_hi)\n\t\t\tcontinue;\n\t\tif (desc->checkit && !desc->checkit(chip))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (desc->name == NULL) {\n\t\tv4l2_dbg(1, debug, sd, \"no matching chip description found\\n\");\n\t\treturn -EIO;\n\t}\n\tv4l2_info(sd, \"%s found @ 0x%x (%s)\\n\", desc->name, client->addr<<1, client->adapter->name);\n\tif (desc->flags) {\n\t\tv4l2_dbg(1, debug, sd, \"matches:%s%s%s.\\n\",\n\t\t\t(desc->flags & CHIP_HAS_VOLUME)     ? \" volume\"      : \"\",\n\t\t\t(desc->flags & CHIP_HAS_BASSTREBLE) ? \" bass/treble\" : \"\",\n\t\t\t(desc->flags & CHIP_HAS_INPUTSEL)   ? \" audiomux\"    : \"\");\n\t}\n\n\t \n\tif (!id)\n\t\tstrscpy(client->name, desc->name, I2C_NAME_SIZE);\n\tchip->desc = desc;\n\tchip->shadow.count = desc->registers+1;\n\tchip->prevmode = -1;\n\tchip->audmode = V4L2_TUNER_MODE_LANG1;\n\n\t \n\tif (desc->initialize != NULL)\n\t\tdesc->initialize(chip);\n\telse\n\t\tchip_cmd(chip, \"init\", &desc->init);\n\n\tv4l2_ctrl_handler_init(&chip->hdl, 5);\n\tif (desc->flags & CHIP_HAS_INPUTSEL)\n\t\tv4l2_ctrl_new_std(&chip->hdl, &tvaudio_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_MUTE, 0, 1, 1, 0);\n\tif (desc->flags & CHIP_HAS_VOLUME) {\n\t\tif (!desc->volfunc) {\n\t\t\t \n\t\t\tv4l2_info(sd, \"volume callback undefined!\\n\");\n\t\t\tdesc->flags &= ~CHIP_HAS_VOLUME;\n\t\t} else {\n\t\t\tchip->volume = v4l2_ctrl_new_std(&chip->hdl,\n\t\t\t\t&tvaudio_ctrl_ops, V4L2_CID_AUDIO_VOLUME,\n\t\t\t\t0, 65535, 65535 / 100,\n\t\t\t\tdesc->volinit ? desc->volinit : 65535);\n\t\t\tchip->balance = v4l2_ctrl_new_std(&chip->hdl,\n\t\t\t\t&tvaudio_ctrl_ops, V4L2_CID_AUDIO_BALANCE,\n\t\t\t\t0, 65535, 65535 / 100, 32768);\n\t\t\tv4l2_ctrl_cluster(2, &chip->volume);\n\t\t}\n\t}\n\tif (desc->flags & CHIP_HAS_BASSTREBLE) {\n\t\tif (!desc->bassfunc || !desc->treblefunc) {\n\t\t\t \n\t\t\tv4l2_info(sd, \"bass/treble callbacks undefined!\\n\");\n\t\t\tdesc->flags &= ~CHIP_HAS_BASSTREBLE;\n\t\t} else {\n\t\t\tv4l2_ctrl_new_std(&chip->hdl,\n\t\t\t\t&tvaudio_ctrl_ops, V4L2_CID_AUDIO_BASS,\n\t\t\t\t0, 65535, 65535 / 100,\n\t\t\t\tdesc->bassinit ? desc->bassinit : 32768);\n\t\t\tv4l2_ctrl_new_std(&chip->hdl,\n\t\t\t\t&tvaudio_ctrl_ops, V4L2_CID_AUDIO_TREBLE,\n\t\t\t\t0, 65535, 65535 / 100,\n\t\t\t\tdesc->trebleinit ? desc->trebleinit : 32768);\n\t\t}\n\t}\n\n\tsd->ctrl_handler = &chip->hdl;\n\tif (chip->hdl.error) {\n\t\tint err = chip->hdl.error;\n\n\t\tv4l2_ctrl_handler_free(&chip->hdl);\n\t\treturn err;\n\t}\n\t \n\tv4l2_ctrl_handler_setup(&chip->hdl);\n\n\tchip->thread = NULL;\n\ttimer_setup(&chip->wt, chip_thread_wake, 0);\n\tif (desc->flags & CHIP_NEED_CHECKMODE) {\n\t\tif (!desc->getrxsubchans || !desc->setaudmode) {\n\t\t\t \n\t\t\tv4l2_info(sd, \"set/get mode callbacks undefined!\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tchip->thread = kthread_run(chip_thread, chip, \"%s\",\n\t\t\t\t\t   client->name);\n\t\tif (IS_ERR(chip->thread)) {\n\t\t\tv4l2_warn(sd, \"failed to create kthread\\n\");\n\t\t\tchip->thread = NULL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void tvaudio_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct CHIPSTATE *chip = to_state(sd);\n\n\tdel_timer_sync(&chip->wt);\n\tif (chip->thread) {\n\t\t \n\t\tkthread_stop(chip->thread);\n\t\tchip->thread = NULL;\n\t}\n\n\tv4l2_device_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(&chip->hdl);\n}\n\n \nstatic const struct i2c_device_id tvaudio_id[] = {\n\t{ \"tvaudio\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tvaudio_id);\n\nstatic struct i2c_driver tvaudio_driver = {\n\t.driver = {\n\t\t.name\t= \"tvaudio\",\n\t},\n\t.probe\t\t= tvaudio_probe,\n\t.remove\t\t= tvaudio_remove,\n\t.id_table\t= tvaudio_id,\n};\n\nmodule_i2c_driver(tvaudio_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}