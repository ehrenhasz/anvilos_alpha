{
  "module_name": "ks0127.c",
  "hash_id": "b470df0fdb3d60c467f72c4360b1b24917053d8985d9c71a78df3e0961129409",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ks0127.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/i2c.h>\n#include <linux/videodev2.h>\n#include <linux/slab.h>\n#include <media/v4l2-device.h>\n#include \"ks0127.h\"\n\nMODULE_DESCRIPTION(\"KS0127 video decoder driver\");\nMODULE_AUTHOR(\"Ryan Drake\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define I2C_KS0127_ADDON   0xD8\n#define I2C_KS0127_ONBOARD 0xDA\n\n\n \n#define KS_STAT     0x00\n#define KS_CMDA     0x01\n#define KS_CMDB     0x02\n#define KS_CMDC     0x03\n#define KS_CMDD     0x04\n#define KS_HAVB     0x05\n#define KS_HAVE     0x06\n#define KS_HS1B     0x07\n#define KS_HS1E     0x08\n#define KS_HS2B     0x09\n#define KS_HS2E     0x0a\n#define KS_AGC      0x0b\n#define KS_HXTRA    0x0c\n#define KS_CDEM     0x0d\n#define KS_PORTAB   0x0e\n#define KS_LUMA     0x0f\n#define KS_CON      0x10\n#define KS_BRT      0x11\n#define KS_CHROMA   0x12\n#define KS_CHROMB   0x13\n#define KS_DEMOD    0x14\n#define KS_SAT      0x15\n#define KS_HUE      0x16\n#define KS_VERTIA   0x17\n#define KS_VERTIB   0x18\n#define KS_VERTIC   0x19\n#define KS_HSCLL    0x1a\n#define KS_HSCLH    0x1b\n#define KS_VSCLL    0x1c\n#define KS_VSCLH    0x1d\n#define KS_OFMTA    0x1e\n#define KS_OFMTB    0x1f\n#define KS_VBICTL   0x20\n#define KS_CCDAT2   0x21\n#define KS_CCDAT1   0x22\n#define KS_VBIL30   0x23\n#define KS_VBIL74   0x24\n#define KS_VBIL118  0x25\n#define KS_VBIL1512 0x26\n#define KS_TTFRAM   0x27\n#define KS_TESTA    0x28\n#define KS_UVOFFH   0x29\n#define KS_UVOFFL   0x2a\n#define KS_UGAIN    0x2b\n#define KS_VGAIN    0x2c\n#define KS_VAVB     0x2d\n#define KS_VAVE     0x2e\n#define KS_CTRACK   0x2f\n#define KS_POLCTL   0x30\n#define KS_REFCOD   0x31\n#define KS_INVALY   0x32\n#define KS_INVALU   0x33\n#define KS_INVALV   0x34\n#define KS_UNUSEY   0x35\n#define KS_UNUSEU   0x36\n#define KS_UNUSEV   0x37\n#define KS_USRSAV   0x38\n#define KS_USREAV   0x39\n#define KS_SHS1A    0x3a\n#define KS_SHS1B    0x3b\n#define KS_SHS1C    0x3c\n#define KS_CMDE     0x3d\n#define KS_VSDEL    0x3e\n#define KS_CMDF     0x3f\n#define KS_GAMMA0   0x40\n#define KS_GAMMA1   0x41\n#define KS_GAMMA2   0x42\n#define KS_GAMMA3   0x43\n#define KS_GAMMA4   0x44\n#define KS_GAMMA5   0x45\n#define KS_GAMMA6   0x46\n#define KS_GAMMA7   0x47\n#define KS_GAMMA8   0x48\n#define KS_GAMMA9   0x49\n#define KS_GAMMA10  0x4a\n#define KS_GAMMA11  0x4b\n#define KS_GAMMA12  0x4c\n#define KS_GAMMA13  0x4d\n#define KS_GAMMA14  0x4e\n#define KS_GAMMA15  0x4f\n#define KS_GAMMA16  0x50\n#define KS_GAMMA17  0x51\n#define KS_GAMMA18  0x52\n#define KS_GAMMA19  0x53\n#define KS_GAMMA20  0x54\n#define KS_GAMMA21  0x55\n#define KS_GAMMA22  0x56\n#define KS_GAMMA23  0x57\n#define KS_GAMMA24  0x58\n#define KS_GAMMA25  0x59\n#define KS_GAMMA26  0x5a\n#define KS_GAMMA27  0x5b\n#define KS_GAMMA28  0x5c\n#define KS_GAMMA29  0x5d\n#define KS_GAMMA30  0x5e\n#define KS_GAMMA31  0x5f\n#define KS_GAMMAD0  0x60\n#define KS_GAMMAD1  0x61\n#define KS_GAMMAD2  0x62\n#define KS_GAMMAD3  0x63\n#define KS_GAMMAD4  0x64\n#define KS_GAMMAD5  0x65\n#define KS_GAMMAD6  0x66\n#define KS_GAMMAD7  0x67\n#define KS_GAMMAD8  0x68\n#define KS_GAMMAD9  0x69\n#define KS_GAMMAD10 0x6a\n#define KS_GAMMAD11 0x6b\n#define KS_GAMMAD12 0x6c\n#define KS_GAMMAD13 0x6d\n#define KS_GAMMAD14 0x6e\n#define KS_GAMMAD15 0x6f\n#define KS_GAMMAD16 0x70\n#define KS_GAMMAD17 0x71\n#define KS_GAMMAD18 0x72\n#define KS_GAMMAD19 0x73\n#define KS_GAMMAD20 0x74\n#define KS_GAMMAD21 0x75\n#define KS_GAMMAD22 0x76\n#define KS_GAMMAD23 0x77\n#define KS_GAMMAD24 0x78\n#define KS_GAMMAD25 0x79\n#define KS_GAMMAD26 0x7a\n#define KS_GAMMAD27 0x7b\n#define KS_GAMMAD28 0x7c\n#define KS_GAMMAD29 0x7d\n#define KS_GAMMAD30 0x7e\n#define KS_GAMMAD31 0x7f\n\n\n \n\nstruct adjust {\n\tint\tcontrast;\n\tint\tbright;\n\tint\thue;\n\tint\tugain;\n\tint\tvgain;\n};\n\nstruct ks0127 {\n\tstruct v4l2_subdev sd;\n\tv4l2_std_id\tnorm;\n\tu8\t\tregs[256];\n};\n\nstatic inline struct ks0127 *to_ks0127(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct ks0127, sd);\n}\n\n\nstatic int debug;  \n\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"Debug output\");\n\nstatic u8 reg_defaults[64];\n\nstatic void init_reg_defaults(void)\n{\n\tstatic int initialized;\n\tu8 *table = reg_defaults;\n\n\tif (initialized)\n\t\treturn;\n\tinitialized = 1;\n\n\ttable[KS_CMDA]     = 0x2c;   \n\ttable[KS_CMDB]     = 0x12;   \n\ttable[KS_CMDC]     = 0x00;   \n\t \n\ttable[KS_CMDD]     = 0x01;\n\ttable[KS_HAVB]     = 0x00;   \n\ttable[KS_HAVE]     = 0x00;   \n\ttable[KS_HS1B]     = 0x10;   \n\ttable[KS_HS1E]     = 0x00;   \n\ttable[KS_HS2B]     = 0x00;   \n\ttable[KS_HS2E]     = 0x00;   \n\ttable[KS_AGC]      = 0x53;   \n\ttable[KS_HXTRA]    = 0x00;   \n\ttable[KS_CDEM]     = 0x00;   \n\ttable[KS_PORTAB]   = 0x0f;   \n\ttable[KS_LUMA]     = 0x01;   \n\ttable[KS_CON]      = 0x00;   \n\ttable[KS_BRT]      = 0x00;   \n\ttable[KS_CHROMA]   = 0x2a;   \n\ttable[KS_CHROMB]   = 0x90;   \n\ttable[KS_DEMOD]    = 0x00;   \n\ttable[KS_SAT]      = 0x00;   \n\ttable[KS_HUE]      = 0x00;   \n\ttable[KS_VERTIA]   = 0x00;   \n\t \n\ttable[KS_VERTIB]   = 0x12;\n\ttable[KS_VERTIC]   = 0x0b;   \n\ttable[KS_HSCLL]    = 0x00;   \n\ttable[KS_HSCLH]    = 0x00;   \n\ttable[KS_VSCLL]    = 0x00;   \n\ttable[KS_VSCLH]    = 0x00;   \n\t \n\ttable[KS_OFMTA]    = 0x30;\n\ttable[KS_OFMTB]    = 0x00;   \n\t \n\ttable[KS_VBICTL]   = 0x5d;\n\ttable[KS_CCDAT2]   = 0x00;   \n\ttable[KS_CCDAT1]   = 0x00;   \n\ttable[KS_VBIL30]   = 0xa8;   \n\ttable[KS_VBIL74]   = 0xaa;   \n\ttable[KS_VBIL118]  = 0x2a;   \n\ttable[KS_VBIL1512] = 0x00;   \n\ttable[KS_TTFRAM]   = 0x00;   \n\ttable[KS_TESTA]    = 0x00;   \n\ttable[KS_UVOFFH]   = 0x00;   \n\ttable[KS_UVOFFL]   = 0x00;   \n\ttable[KS_UGAIN]    = 0x00;   \n\ttable[KS_VGAIN]    = 0x00;   \n\ttable[KS_VAVB]     = 0x07;   \n\ttable[KS_VAVE]     = 0x00;   \n\ttable[KS_CTRACK]   = 0x00;   \n\ttable[KS_POLCTL]   = 0x41;   \n\ttable[KS_REFCOD]   = 0x80;   \n\ttable[KS_INVALY]   = 0x10;   \n\ttable[KS_INVALU]   = 0x80;   \n\ttable[KS_INVALV]   = 0x80;   \n\ttable[KS_UNUSEY]   = 0x10;   \n\ttable[KS_UNUSEU]   = 0x80;   \n\ttable[KS_UNUSEV]   = 0x80;   \n\ttable[KS_USRSAV]   = 0x00;   \n\ttable[KS_USREAV]   = 0x00;   \n\ttable[KS_SHS1A]    = 0x00;   \n\t \n\ttable[KS_SHS1B]    = 0x80;\n\ttable[KS_SHS1C]    = 0x00;   \n\ttable[KS_CMDE]     = 0x00;   \n\ttable[KS_VSDEL]    = 0x00;   \n\t \n\t \n\ttable[KS_CMDF]     = 0x02;\n}\n\n\n \n\n\nstatic u8 ks0127_read(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tchar val = 0;\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.len = sizeof(reg),\n\t\t\t.buf = &reg\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD | I2C_M_NO_RD_ACK,\n\t\t\t.len = sizeof(val),\n\t\t\t.buf = &val\n\t\t}\n\t};\n\tint ret;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret != ARRAY_SIZE(msgs))\n\t\tv4l2_dbg(1, debug, sd, \"read error\\n\");\n\n\treturn val;\n}\n\n\nstatic void ks0127_write(struct v4l2_subdev *sd, u8 reg, u8 val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tstruct ks0127 *ks = to_ks0127(sd);\n\tchar msg[] = { reg, val };\n\n\tif (i2c_master_send(client, msg, sizeof(msg)) != sizeof(msg))\n\t\tv4l2_dbg(1, debug, sd, \"write error\\n\");\n\n\tks->regs[reg] = val;\n}\n\n\n \nstatic void ks0127_and_or(struct v4l2_subdev *sd, u8 reg, u8 and_v, u8 or_v)\n{\n\tstruct ks0127 *ks = to_ks0127(sd);\n\n\tu8 val = ks->regs[reg];\n\tval = (val & and_v) | or_v;\n\tks0127_write(sd, reg, val);\n}\n\n\n\n \nstatic void ks0127_init(struct v4l2_subdev *sd)\n{\n\tu8 *table = reg_defaults;\n\tint i;\n\n\tv4l2_dbg(1, debug, sd, \"reset\\n\");\n\tmsleep(1);\n\n\t \n\t \n\n\tfor (i = 1; i < 33; i++)\n\t\tks0127_write(sd, i, table[i]);\n\n\tfor (i = 35; i < 40; i++)\n\t\tks0127_write(sd, i, table[i]);\n\n\tfor (i = 41; i < 56; i++)\n\t\tks0127_write(sd, i, table[i]);\n\n\tfor (i = 58; i < 64; i++)\n\t\tks0127_write(sd, i, table[i]);\n\n\n\tif ((ks0127_read(sd, KS_STAT) & 0x80) == 0) {\n\t\tv4l2_dbg(1, debug, sd, \"ks0122s found\\n\");\n\t\treturn;\n\t}\n\n\tswitch (ks0127_read(sd, KS_CMDE) & 0x0f) {\n\tcase 0:\n\t\tv4l2_dbg(1, debug, sd, \"ks0127 found\\n\");\n\t\tbreak;\n\n\tcase 9:\n\t\tv4l2_dbg(1, debug, sd, \"ks0127B Revision A found\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tv4l2_dbg(1, debug, sd, \"unknown revision\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic int ks0127_s_routing(struct v4l2_subdev *sd,\n\t\t\t    u32 input, u32 output, u32 config)\n{\n\tstruct ks0127 *ks = to_ks0127(sd);\n\n\tswitch (input) {\n\tcase KS_INPUT_COMPOSITE_1:\n\tcase KS_INPUT_COMPOSITE_2:\n\tcase KS_INPUT_COMPOSITE_3:\n\tcase KS_INPUT_COMPOSITE_4:\n\tcase KS_INPUT_COMPOSITE_5:\n\tcase KS_INPUT_COMPOSITE_6:\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t\"s_routing %d: Composite\\n\", input);\n\t\t \n\t\tks0127_and_or(sd, KS_CMDA,   0xfc, 0x00);\n\t\t \n\t\tks0127_and_or(sd, KS_CMDA,   ~0x40, 0x00);\n\t\t \n\t\tks0127_and_or(sd, KS_CMDB,   0xb0, input);\n\t\t \n\t\tks0127_and_or(sd, KS_CMDC,   0x70, 0x0a);\n\t\t \n\t\tks0127_and_or(sd, KS_CMDD,   0x03, 0x00);\n\t\t \n\t\tks0127_and_or(sd, KS_CTRACK, 0xcf, 0x00);\n\t\t \n\t\tks0127_and_or(sd, KS_LUMA,   0x00,\n\t\t\t       (reg_defaults[KS_LUMA])|0x0c);\n\t\t \n\t\tks0127_and_or(sd, KS_VERTIA, 0x08, 0x81);\n\t\t \n\t\tks0127_and_or(sd, KS_VERTIC, 0x0f, 0x90);\n\n\t\t \n\t\tks0127_and_or(sd, KS_CHROMB, 0x0f, 0x90);\n\n\t\tks0127_write(sd, KS_UGAIN, reg_defaults[KS_UGAIN]);\n\t\tks0127_write(sd, KS_VGAIN, reg_defaults[KS_VGAIN]);\n\t\tks0127_write(sd, KS_UVOFFH, reg_defaults[KS_UVOFFH]);\n\t\tks0127_write(sd, KS_UVOFFL, reg_defaults[KS_UVOFFL]);\n\t\tbreak;\n\n\tcase KS_INPUT_SVIDEO_1:\n\tcase KS_INPUT_SVIDEO_2:\n\tcase KS_INPUT_SVIDEO_3:\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t\"s_routing %d: S-Video\\n\", input);\n\t\t \n\t\tks0127_and_or(sd, KS_CMDA,   0xfc, 0x00);\n\t\t \n\t\tks0127_and_or(sd, KS_CMDA,   ~0x40, 0x00);\n\t\t \n\t\tks0127_and_or(sd, KS_CMDB,   0xb0, input);\n\t\t \n\t\tks0127_and_or(sd, KS_CMDC,   0x70, 0x0a);\n\t\t \n\t\tks0127_and_or(sd, KS_CMDD,   0x03, 0x00);\n\t\t \n\t\tks0127_and_or(sd, KS_CTRACK, 0xcf, 0x00);\n\t\tks0127_and_or(sd, KS_LUMA, 0x00,\n\t\t\t       reg_defaults[KS_LUMA]);\n\t\t \n\t\tks0127_and_or(sd, KS_VERTIA, 0x08,\n\t\t\t       (reg_defaults[KS_VERTIA]&0xf0)|0x01);\n\t\tks0127_and_or(sd, KS_VERTIC, 0x0f,\n\t\t\t       reg_defaults[KS_VERTIC]&0xf0);\n\n\t\tks0127_and_or(sd, KS_CHROMB, 0x0f,\n\t\t\t       reg_defaults[KS_CHROMB]&0xf0);\n\n\t\tks0127_write(sd, KS_UGAIN, reg_defaults[KS_UGAIN]);\n\t\tks0127_write(sd, KS_VGAIN, reg_defaults[KS_VGAIN]);\n\t\tks0127_write(sd, KS_UVOFFH, reg_defaults[KS_UVOFFH]);\n\t\tks0127_write(sd, KS_UVOFFL, reg_defaults[KS_UVOFFL]);\n\t\tbreak;\n\n\tcase KS_INPUT_YUV656:\n\t\tv4l2_dbg(1, debug, sd, \"s_routing 15: YUV656\\n\");\n\t\tif (ks->norm & V4L2_STD_525_60)\n\t\t\t \n\t\t\tks0127_and_or(sd, KS_CMDA,   0xfc, 0x03);\n\t\telse\n\t\t\t \n\t\t\tks0127_and_or(sd, KS_CMDA,   0xfc, 0x02);\n\n\t\tks0127_and_or(sd, KS_CMDA,   0xff, 0x40);  \n\t\t \n\t\tks0127_and_or(sd, KS_CMDB,   0xb0, (input | 0x40));\n\t\t \n\t\t \n\t\tks0127_and_or(sd, KS_CMDC,   0x70, 0x87);\n\t\t \n\t\tks0127_and_or(sd, KS_CMDD,   0x03, 0x08);\n\t\t \n\t\tks0127_and_or(sd, KS_CTRACK, 0xcf, 0x30);\n\t\t \n\t\tks0127_and_or(sd, KS_LUMA,   0x00, 0x71);\n\t\tks0127_and_or(sd, KS_VERTIC, 0x0f,\n\t\t\t       reg_defaults[KS_VERTIC]&0xf0);\n\n\t\t \n\t\tks0127_and_or(sd, KS_VERTIA, 0x08, 0x81);\n\n\t\tks0127_and_or(sd, KS_CHROMB, 0x0f,\n\t\t\t       reg_defaults[KS_CHROMB]&0xf0);\n\n\t\tks0127_and_or(sd, KS_CON, 0x00, 0x00);\n\t\tks0127_and_or(sd, KS_BRT, 0x00, 32);\t \n\t\t\t \n\t\tks0127_and_or(sd, KS_SAT, 0x00, 0xe8);\n\t\tks0127_and_or(sd, KS_HUE, 0x00, 0);\n\n\t\tks0127_and_or(sd, KS_UGAIN, 0x00, 238);\n\t\tks0127_and_or(sd, KS_VGAIN, 0x00, 0x00);\n\n\t\t \n\t\tks0127_and_or(sd, KS_UVOFFH, 0x00, 0x4f);\n\t\tks0127_and_or(sd, KS_UVOFFL, 0x00, 0x00);\n\t\tbreak;\n\n\tdefault:\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t\"s_routing: Unknown input %d\\n\", input);\n\t\tbreak;\n\t}\n\n\t \n\t \n\tks0127_write(sd, KS_DEMOD, reg_defaults[KS_DEMOD]);\n\treturn 0;\n}\n\nstatic int ks0127_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct ks0127 *ks = to_ks0127(sd);\n\n\t \n\tks0127_and_or(sd, KS_DEMOD, 0xf0, 0x00);\n\n\tks->norm = std;\n\tif (std & V4L2_STD_NTSC) {\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t\"s_std: NTSC_M\\n\");\n\t\tks0127_and_or(sd, KS_CHROMA, 0x9f, 0x20);\n\t} else if (std & V4L2_STD_PAL_N) {\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t\"s_std: NTSC_N (fixme)\\n\");\n\t\tks0127_and_or(sd, KS_CHROMA, 0x9f, 0x40);\n\t} else if (std & V4L2_STD_PAL) {\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t\"s_std: PAL_N\\n\");\n\t\tks0127_and_or(sd, KS_CHROMA, 0x9f, 0x20);\n\t} else if (std & V4L2_STD_PAL_M) {\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t\"s_std: PAL_M (fixme)\\n\");\n\t\tks0127_and_or(sd, KS_CHROMA, 0x9f, 0x40);\n\t} else if (std & V4L2_STD_SECAM) {\n\t\tv4l2_dbg(1, debug, sd,\n\t\t\t\"s_std: SECAM\\n\");\n\n\t\t \n\t\tks0127_and_or(sd, KS_CHROMA, 0xdf, 0x20);\n\t\tks0127_and_or(sd, KS_DEMOD, 0xf0, 0x00);\n\t\tschedule_timeout_interruptible(HZ/10+1);\n\n\t\t \n\t\tif (!(ks0127_read(sd, KS_DEMOD) & 0x40))\n\t\t\t \n\t\t\tks0127_and_or(sd, KS_DEMOD, 0xf0, 0x0f);\n\t} else {\n\t\tv4l2_dbg(1, debug, sd, \"s_std: Unknown norm %llx\\n\",\n\t\t\t       (unsigned long long)std);\n\t}\n\treturn 0;\n}\n\nstatic int ks0127_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tv4l2_dbg(1, debug, sd, \"s_stream(%d)\\n\", enable);\n\tif (enable) {\n\t\t \n\t\tks0127_and_or(sd, KS_OFMTA, 0xcf, 0x30);\n\t\t \n\t\tks0127_and_or(sd, KS_CDEM, 0x7f, 0x00);\n\t} else {\n\t\t \n\t\tks0127_and_or(sd, KS_OFMTA, 0xcf, 0x00);\n\t\t \n\t\tks0127_and_or(sd, KS_CDEM, 0x7f, 0x80);\n\t}\n\treturn 0;\n}\n\nstatic int ks0127_status(struct v4l2_subdev *sd, u32 *pstatus, v4l2_std_id *pstd)\n{\n\tint stat = V4L2_IN_ST_NO_SIGNAL;\n\tu8 status;\n\tv4l2_std_id std = pstd ? *pstd : V4L2_STD_ALL;\n\n\tstatus = ks0127_read(sd, KS_STAT);\n\tif (!(status & 0x20))\t\t  \n\t\tstat = 0;\n\tif (!(status & 0x01)) {\t\t       \n\t\tstat |= V4L2_IN_ST_NO_COLOR;\n\t\tstd = V4L2_STD_UNKNOWN;\n\t} else {\n\t\tif ((status & 0x08))\t\t    \n\t\t\tstd &= V4L2_STD_PAL;\n\t\telse\n\t\t\tstd &= V4L2_STD_NTSC;\n\t}\n\tif ((status & 0x10))\t\t    \n\t\tstd &= V4L2_STD_525_60;\n\telse\n\t\tstd &= V4L2_STD_625_50;\n\tif (pstd)\n\t\t*pstd = std;\n\tif (pstatus)\n\t\t*pstatus = stat;\n\treturn 0;\n}\n\nstatic int ks0127_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)\n{\n\tv4l2_dbg(1, debug, sd, \"querystd\\n\");\n\treturn ks0127_status(sd, NULL, std);\n}\n\nstatic int ks0127_g_input_status(struct v4l2_subdev *sd, u32 *status)\n{\n\tv4l2_dbg(1, debug, sd, \"g_input_status\\n\");\n\treturn ks0127_status(sd, status, NULL);\n}\n\n \n\nstatic const struct v4l2_subdev_video_ops ks0127_video_ops = {\n\t.s_std = ks0127_s_std,\n\t.s_routing = ks0127_s_routing,\n\t.s_stream = ks0127_s_stream,\n\t.querystd = ks0127_querystd,\n\t.g_input_status = ks0127_g_input_status,\n};\n\nstatic const struct v4l2_subdev_ops ks0127_ops = {\n\t.video = &ks0127_video_ops,\n};\n\n \n\n\nstatic int ks0127_probe(struct i2c_client *client)\n{\n\tstruct ks0127 *ks;\n\tstruct v4l2_subdev *sd;\n\n\tv4l_info(client, \"%s chip found @ 0x%x (%s)\\n\",\n\t\tclient->addr == (I2C_KS0127_ADDON >> 1) ? \"addon\" : \"on-board\",\n\t\tclient->addr << 1, client->adapter->name);\n\n\tks = devm_kzalloc(&client->dev, sizeof(*ks), GFP_KERNEL);\n\tif (ks == NULL)\n\t\treturn -ENOMEM;\n\tsd = &ks->sd;\n\tv4l2_i2c_subdev_init(sd, client, &ks0127_ops);\n\n\t \n\tinit_reg_defaults();\n\tks0127_write(sd, KS_CMDA, 0x2c);\n\tmdelay(10);\n\n\t \n\tks0127_init(sd);\n\treturn 0;\n}\n\nstatic void ks0127_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\n\tv4l2_device_unregister_subdev(sd);\n\tks0127_write(sd, KS_OFMTA, 0x20);  \n\tks0127_write(sd, KS_CMDA, 0x2c | 0x80);  \n}\n\nstatic const struct i2c_device_id ks0127_id[] = {\n\t{ \"ks0127\", 0 },\n\t{ \"ks0127b\", 0 },\n\t{ \"ks0122s\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ks0127_id);\n\nstatic struct i2c_driver ks0127_driver = {\n\t.driver = {\n\t\t.name\t= \"ks0127\",\n\t},\n\t.probe\t\t= ks0127_probe,\n\t.remove\t\t= ks0127_remove,\n\t.id_table\t= ks0127_id,\n};\n\nmodule_i2c_driver(ks0127_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}