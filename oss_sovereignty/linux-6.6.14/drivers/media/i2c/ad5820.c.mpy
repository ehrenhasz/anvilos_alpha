{
  "module_name": "ad5820.c",
  "hash_id": "531245a8955c39cf4fe32fe1cb48fe36117b83329a5ae6dab39a87e0f6a8c5ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ad5820.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/gpio/consumer.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-subdev.h>\n\n \n#define AD5820_POWER_DOWN\t\t(1 << 15)\n#define AD5820_DAC_SHIFT\t\t4\n#define AD5820_RAMP_MODE_LINEAR\t\t(0 << 3)\n#define AD5820_RAMP_MODE_64_16\t\t(1 << 3)\n\n#define CODE_TO_RAMP_US(s)\t((s) == 0 ? 0 : (1 << ((s) - 1)) * 50)\n#define RAMP_US_TO_CODE(c)\tfls(((c) + ((c)>>1)) / 50)\n\n#define to_ad5820_device(sd)\tcontainer_of(sd, struct ad5820_device, subdev)\n\nstruct ad5820_device {\n\tstruct v4l2_subdev subdev;\n\tstruct ad5820_platform_data *platform_data;\n\tstruct regulator *vana;\n\n\tstruct v4l2_ctrl_handler ctrls;\n\tu32 focus_absolute;\n\tu32 focus_ramp_time;\n\tu32 focus_ramp_mode;\n\n\tstruct gpio_desc *enable_gpio;\n\n\tstruct mutex power_lock;\n\tint power_count;\n\n\tbool standby;\n};\n\nstatic int ad5820_write(struct ad5820_device *coil, u16 data)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&coil->subdev);\n\tstruct i2c_msg msg;\n\t__be16 be_data;\n\tint r;\n\n\tif (!client->adapter)\n\t\treturn -ENODEV;\n\n\tbe_data = cpu_to_be16(data);\n\tmsg.addr  = client->addr;\n\tmsg.flags = 0;\n\tmsg.len   = 2;\n\tmsg.buf   = (u8 *)&be_data;\n\n\tr = i2c_transfer(client->adapter, &msg, 1);\n\tif (r < 0) {\n\t\tdev_err(&client->dev, \"write failed, error %d\\n\", r);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ad5820_update_hw(struct ad5820_device *coil)\n{\n\tu16 status;\n\n\tstatus = RAMP_US_TO_CODE(coil->focus_ramp_time);\n\tstatus |= coil->focus_ramp_mode\n\t\t? AD5820_RAMP_MODE_64_16 : AD5820_RAMP_MODE_LINEAR;\n\tstatus |= coil->focus_absolute << AD5820_DAC_SHIFT;\n\n\tif (coil->standby)\n\t\tstatus |= AD5820_POWER_DOWN;\n\n\treturn ad5820_write(coil, status);\n}\n\n \nstatic int ad5820_power_off(struct ad5820_device *coil, bool standby)\n{\n\tint ret = 0, ret2;\n\n\t \n\tif (standby) {\n\t\tcoil->standby = true;\n\t\tret = ad5820_update_hw(coil);\n\t}\n\n\tgpiod_set_value_cansleep(coil->enable_gpio, 0);\n\n\tret2 = regulator_disable(coil->vana);\n\tif (ret)\n\t\treturn ret;\n\treturn ret2;\n}\n\nstatic int ad5820_power_on(struct ad5820_device *coil, bool restore)\n{\n\tint ret;\n\n\tret = regulator_enable(coil->vana);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgpiod_set_value_cansleep(coil->enable_gpio, 1);\n\n\tif (restore) {\n\t\t \n\t\tcoil->standby = false;\n\t\tret = ad5820_update_hw(coil);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\treturn 0;\n\nfail:\n\tgpiod_set_value_cansleep(coil->enable_gpio, 0);\n\tcoil->standby = true;\n\tregulator_disable(coil->vana);\n\n\treturn ret;\n}\n\n \nstatic int ad5820_set_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ad5820_device *coil =\n\t\tcontainer_of(ctrl->handler, struct ad5820_device, ctrls);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_FOCUS_ABSOLUTE:\n\t\tcoil->focus_absolute = ctrl->val;\n\t\treturn ad5820_update_hw(coil);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops ad5820_ctrl_ops = {\n\t.s_ctrl = ad5820_set_ctrl,\n};\n\n\nstatic int ad5820_init_controls(struct ad5820_device *coil)\n{\n\tv4l2_ctrl_handler_init(&coil->ctrls, 1);\n\n\t \n\tv4l2_ctrl_new_std(&coil->ctrls, &ad5820_ctrl_ops,\n\t\t\t  V4L2_CID_FOCUS_ABSOLUTE, 0, 1023, 1, 0);\n\n\tif (coil->ctrls.error)\n\t\treturn coil->ctrls.error;\n\n\tcoil->focus_absolute = 0;\n\tcoil->focus_ramp_time = 0;\n\tcoil->focus_ramp_mode = 0;\n\n\tcoil->subdev.ctrl_handler = &coil->ctrls;\n\n\treturn 0;\n}\n\n \nstatic int ad5820_registered(struct v4l2_subdev *subdev)\n{\n\tstruct ad5820_device *coil = to_ad5820_device(subdev);\n\n\treturn ad5820_init_controls(coil);\n}\n\nstatic int\nad5820_set_power(struct v4l2_subdev *subdev, int on)\n{\n\tstruct ad5820_device *coil = to_ad5820_device(subdev);\n\tint ret = 0;\n\n\tmutex_lock(&coil->power_lock);\n\n\t \n\tif (coil->power_count == !on) {\n\t\tret = on ? ad5820_power_on(coil, true) :\n\t\t\tad5820_power_off(coil, true);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\t \n\tcoil->power_count += on ? 1 : -1;\n\tWARN_ON(coil->power_count < 0);\n\ndone:\n\tmutex_unlock(&coil->power_lock);\n\treturn ret;\n}\n\nstatic int ad5820_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\treturn ad5820_set_power(sd, 1);\n}\n\nstatic int ad5820_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\treturn ad5820_set_power(sd, 0);\n}\n\nstatic const struct v4l2_subdev_core_ops ad5820_core_ops = {\n\t.s_power = ad5820_set_power,\n};\n\nstatic const struct v4l2_subdev_ops ad5820_ops = {\n\t.core = &ad5820_core_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops ad5820_internal_ops = {\n\t.registered = ad5820_registered,\n\t.open = ad5820_open,\n\t.close = ad5820_close,\n};\n\n \nstatic int __maybe_unused ad5820_suspend(struct device *dev)\n{\n\tstruct v4l2_subdev *subdev = dev_get_drvdata(dev);\n\tstruct ad5820_device *coil = to_ad5820_device(subdev);\n\n\tif (!coil->power_count)\n\t\treturn 0;\n\n\treturn ad5820_power_off(coil, false);\n}\n\nstatic int __maybe_unused ad5820_resume(struct device *dev)\n{\n\tstruct v4l2_subdev *subdev = dev_get_drvdata(dev);\n\tstruct ad5820_device *coil = to_ad5820_device(subdev);\n\n\tif (!coil->power_count)\n\t\treturn 0;\n\n\treturn ad5820_power_on(coil, true);\n}\n\nstatic int ad5820_probe(struct i2c_client *client)\n{\n\tstruct ad5820_device *coil;\n\tint ret;\n\n\tcoil = devm_kzalloc(&client->dev, sizeof(*coil), GFP_KERNEL);\n\tif (!coil)\n\t\treturn -ENOMEM;\n\n\tcoil->vana = devm_regulator_get(&client->dev, \"VANA\");\n\tif (IS_ERR(coil->vana))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(coil->vana),\n\t\t\t\t     \"could not get regulator for vana\\n\");\n\n\tcoil->enable_gpio = devm_gpiod_get_optional(&client->dev, \"enable\",\n\t\t\t\t\t\t    GPIOD_OUT_LOW);\n\tif (IS_ERR(coil->enable_gpio))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(coil->enable_gpio),\n\t\t\t\t     \"could not get enable gpio\\n\");\n\n\tmutex_init(&coil->power_lock);\n\n\tv4l2_i2c_subdev_init(&coil->subdev, client, &ad5820_ops);\n\tcoil->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tcoil->subdev.internal_ops = &ad5820_internal_ops;\n\tcoil->subdev.entity.function = MEDIA_ENT_F_LENS;\n\tstrscpy(coil->subdev.name, \"ad5820 focus\", sizeof(coil->subdev.name));\n\n\tret = media_entity_pads_init(&coil->subdev.entity, 0, NULL);\n\tif (ret < 0)\n\t\tgoto clean_mutex;\n\n\tret = v4l2_async_register_subdev(&coil->subdev);\n\tif (ret < 0)\n\t\tgoto clean_entity;\n\n\treturn ret;\n\nclean_entity:\n\tmedia_entity_cleanup(&coil->subdev.entity);\nclean_mutex:\n\tmutex_destroy(&coil->power_lock);\n\treturn ret;\n}\n\nstatic void ad5820_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct ad5820_device *coil = to_ad5820_device(subdev);\n\n\tv4l2_async_unregister_subdev(&coil->subdev);\n\tv4l2_ctrl_handler_free(&coil->ctrls);\n\tmedia_entity_cleanup(&coil->subdev.entity);\n\tmutex_destroy(&coil->power_lock);\n}\n\nstatic const struct i2c_device_id ad5820_id_table[] = {\n\t{ \"ad5820\", 0 },\n\t{ \"ad5821\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ad5820_id_table);\n\nstatic const struct of_device_id ad5820_of_table[] = {\n\t{ .compatible = \"adi,ad5820\" },\n\t{ .compatible = \"adi,ad5821\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ad5820_of_table);\n\nstatic SIMPLE_DEV_PM_OPS(ad5820_pm, ad5820_suspend, ad5820_resume);\n\nstatic struct i2c_driver ad5820_i2c_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"ad5820\",\n\t\t.pm\t= &ad5820_pm,\n\t\t.of_match_table = ad5820_of_table,\n\t},\n\t.probe\t\t= ad5820_probe,\n\t.remove\t\t= ad5820_remove,\n\t.id_table\t= ad5820_id_table,\n};\n\nmodule_i2c_driver(ad5820_i2c_driver);\n\nMODULE_AUTHOR(\"Tuukka Toivonen\");\nMODULE_DESCRIPTION(\"AD5820 camera lens driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}