{
  "module_name": "mt9v111.c",
  "hash_id": "f7f6fdca768ea19de7720b34e58cd1d56e61ec5cad62fa810008d47f925cf552",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/mt9v111.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <linux/v4l2-mediabus.h>\n#include <linux/module.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-image-sizes.h>\n#include <media/v4l2-subdev.h>\n\n \n\n#define MT9V111_CHIP_ID_HIGH\t\t\t\t0x82\n#define MT9V111_CHIP_ID_LOW\t\t\t\t0x3a\n\n#define MT9V111_R01_ADDR_SPACE\t\t\t\t0x01\n#define MT9V111_R01_IFP\t\t\t\t\t0x01\n#define MT9V111_R01_CORE\t\t\t\t0x04\n\n#define MT9V111_IFP_R06_OPMODE_CTRL\t\t\t0x06\n#define\t\tMT9V111_IFP_R06_OPMODE_CTRL_AWB_EN\tBIT(1)\n#define\t\tMT9V111_IFP_R06_OPMODE_CTRL_AE_EN\tBIT(14)\n#define MT9V111_IFP_R07_IFP_RESET\t\t\t0x07\n#define\t\tMT9V111_IFP_R07_IFP_RESET_MASK\t\tBIT(0)\n#define MT9V111_IFP_R08_OUTFMT_CTRL\t\t\t0x08\n#define\t\tMT9V111_IFP_R08_OUTFMT_CTRL_FLICKER\tBIT(11)\n#define\t\tMT9V111_IFP_R08_OUTFMT_CTRL_PCLK\tBIT(5)\n#define MT9V111_IFP_R3A_OUTFMT_CTRL2\t\t\t0x3a\n#define\t\tMT9V111_IFP_R3A_OUTFMT_CTRL2_SWAP_CBCR\tBIT(0)\n#define\t\tMT9V111_IFP_R3A_OUTFMT_CTRL2_SWAP_YC\tBIT(1)\n#define\t\tMT9V111_IFP_R3A_OUTFMT_CTRL2_SWAP_MASK\tGENMASK(2, 0)\n#define MT9V111_IFP_RA5_HPAN\t\t\t\t0xa5\n#define MT9V111_IFP_RA6_HZOOM\t\t\t\t0xa6\n#define MT9V111_IFP_RA7_HOUT\t\t\t\t0xa7\n#define MT9V111_IFP_RA8_VPAN\t\t\t\t0xa8\n#define MT9V111_IFP_RA9_VZOOM\t\t\t\t0xa9\n#define MT9V111_IFP_RAA_VOUT\t\t\t\t0xaa\n#define MT9V111_IFP_DECIMATION_MASK\t\t\tGENMASK(9, 0)\n#define MT9V111_IFP_DECIMATION_FREEZE\t\t\tBIT(15)\n\n#define MT9V111_CORE_R03_WIN_HEIGHT\t\t\t0x03\n#define\t\tMT9V111_CORE_R03_WIN_V_OFFS\t\t2\n#define MT9V111_CORE_R04_WIN_WIDTH\t\t\t0x04\n#define\t\tMT9V111_CORE_R04_WIN_H_OFFS\t\t114\n#define MT9V111_CORE_R05_HBLANK\t\t\t\t0x05\n#define\t\tMT9V111_CORE_R05_MIN_HBLANK\t\t0x09\n#define\t\tMT9V111_CORE_R05_MAX_HBLANK\t\tGENMASK(9, 0)\n#define\t\tMT9V111_CORE_R05_DEF_HBLANK\t\t0x26\n#define MT9V111_CORE_R06_VBLANK\t\t\t\t0x06\n#define\t\tMT9V111_CORE_R06_MIN_VBLANK\t\t0x03\n#define\t\tMT9V111_CORE_R06_MAX_VBLANK\t\tGENMASK(11, 0)\n#define\t\tMT9V111_CORE_R06_DEF_VBLANK\t\t0x04\n#define MT9V111_CORE_R07_OUT_CTRL\t\t\t0x07\n#define\t\tMT9V111_CORE_R07_OUT_CTRL_SAMPLE\tBIT(4)\n#define MT9V111_CORE_R09_PIXEL_INT\t\t\t0x09\n#define\t\tMT9V111_CORE_R09_PIXEL_INT_MASK\t\tGENMASK(11, 0)\n#define MT9V111_CORE_R0D_CORE_RESET\t\t\t0x0d\n#define\t\tMT9V111_CORE_R0D_CORE_RESET_MASK\tBIT(0)\n#define MT9V111_CORE_RFF_CHIP_VER\t\t\t0xff\n\n#define MT9V111_PIXEL_ARRAY_WIDTH\t\t\t640\n#define MT9V111_PIXEL_ARRAY_HEIGHT\t\t\t480\n\n#define MT9V111_MAX_CLKIN\t\t\t\t27000000\n\n \nstatic const struct v4l2_mbus_framefmt mt9v111_def_fmt = {\n\t.width\t\t= 640,\n\t.height\t\t= 480,\n\t.code\t\t= MEDIA_BUS_FMT_UYVY8_2X8,\n\t.field\t\t= V4L2_FIELD_NONE,\n\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t.ycbcr_enc\t= V4L2_YCBCR_ENC_601,\n\t.quantization\t= V4L2_QUANTIZATION_LIM_RANGE,\n\t.xfer_func\t= V4L2_XFER_FUNC_SRGB,\n};\n\nstruct mt9v111_dev {\n\tstruct device *dev;\n\tstruct i2c_client *client;\n\n\tu8 addr_space;\n\n\tstruct v4l2_subdev sd;\n#if IS_ENABLED(CONFIG_MEDIA_CONTROLLER)\n\tstruct media_pad pad;\n#endif\n\n\tstruct v4l2_ctrl *auto_awb;\n\tstruct v4l2_ctrl *auto_exp;\n\tstruct v4l2_ctrl *hblank;\n\tstruct v4l2_ctrl *vblank;\n\tstruct v4l2_ctrl_handler ctrls;\n\n\t \n\tstruct v4l2_mbus_framefmt fmt;\n\tunsigned int fps;\n\n\t \n\tstruct mutex pwr_mutex;\n\tint pwr_count;\n\n\t \n\tstruct mutex stream_mutex;\n\tbool streaming;\n\n\t \n\tbool pending;\n\n\t \n\tstruct clk *clk;\n\tu32 sysclk;\n\n\tstruct gpio_desc *oe;\n\tstruct gpio_desc *standby;\n\tstruct gpio_desc *reset;\n};\n\n#define sd_to_mt9v111(__sd) container_of((__sd), struct mt9v111_dev, sd)\n\n \nstatic struct mt9v111_mbus_fmt {\n\tu32\tcode;\n} mt9v111_formats[] = {\n\t{\n\t\t.code\t= MEDIA_BUS_FMT_UYVY8_2X8,\n\t},\n\t{\n\t\t.code\t= MEDIA_BUS_FMT_YUYV8_2X8,\n\t},\n\t{\n\t\t.code\t= MEDIA_BUS_FMT_VYUY8_2X8,\n\t},\n\t{\n\t\t.code\t= MEDIA_BUS_FMT_YVYU8_2X8,\n\t},\n};\n\nstatic u32 mt9v111_frame_intervals[] = {5, 10, 15, 20, 30};\n\n \nstatic struct v4l2_rect mt9v111_frame_sizes[] = {\n\t{\n\t\t.width\t= 640,\n\t\t.height\t= 480,\n\t},\n\t{\n\t\t.width\t= 352,\n\t\t.height\t= 288\n\t},\n\t{\n\t\t.width\t= 320,\n\t\t.height\t= 240,\n\t},\n\t{\n\t\t.width\t= 176,\n\t\t.height\t= 144,\n\t},\n\t{\n\t\t.width\t= 160,\n\t\t.height\t= 120,\n\t},\n};\n\n \n\nstatic int __mt9v111_read(struct i2c_client *c, u8 reg, u16 *val)\n{\n\tstruct i2c_msg msg[2];\n\t__be16 buf;\n\tint ret;\n\n\tmsg[0].addr = c->addr;\n\tmsg[0].flags = 0;\n\tmsg[0].len = 1;\n\tmsg[0].buf = &reg;\n\n\tmsg[1].addr = c->addr;\n\tmsg[1].flags = I2C_M_RD;\n\tmsg[1].len = 2;\n\tmsg[1].buf = (char *)&buf;\n\n\tret = i2c_transfer(c->adapter, msg, 2);\n\tif (ret < 0) {\n\t\tdev_err(&c->dev, \"i2c read transfer error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*val = be16_to_cpu(buf);\n\n\tdev_dbg(&c->dev, \"%s: %x=%x\\n\", __func__, reg, *val);\n\n\treturn 0;\n}\n\nstatic int __mt9v111_write(struct i2c_client *c, u8 reg, u16 val)\n{\n\tstruct i2c_msg msg;\n\tu8 buf[3] = { 0 };\n\tint ret;\n\n\tbuf[0] = reg;\n\tbuf[1] = val >> 8;\n\tbuf[2] = val & 0xff;\n\n\tmsg.addr = c->addr;\n\tmsg.flags = 0;\n\tmsg.len = 3;\n\tmsg.buf = (char *)buf;\n\n\tdev_dbg(&c->dev, \"%s: %x = %x%x\\n\", __func__, reg, buf[1], buf[2]);\n\n\tret = i2c_transfer(c->adapter, &msg, 1);\n\tif (ret < 0) {\n\t\tdev_err(&c->dev, \"i2c write transfer error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int __mt9v111_addr_space_select(struct i2c_client *c, u16 addr_space)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(c);\n\tstruct mt9v111_dev *mt9v111 = sd_to_mt9v111(sd);\n\tu16 val;\n\tint ret;\n\n\tif (mt9v111->addr_space == addr_space)\n\t\treturn 0;\n\n\tret = __mt9v111_write(c, MT9V111_R01_ADDR_SPACE, addr_space);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = __mt9v111_read(c, MT9V111_R01_ADDR_SPACE, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != addr_space)\n\t\treturn -EINVAL;\n\n\tmt9v111->addr_space = addr_space;\n\n\treturn 0;\n}\n\nstatic int mt9v111_read(struct i2c_client *c, u8 addr_space, u8 reg, u16 *val)\n{\n\tint ret;\n\n\t \n\tret = __mt9v111_addr_space_select(c, addr_space);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __mt9v111_read(c, reg, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int mt9v111_write(struct i2c_client *c, u8 addr_space, u8 reg, u16 val)\n{\n\tint ret;\n\n\t \n\tret = __mt9v111_addr_space_select(c, addr_space);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __mt9v111_write(c, reg, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int mt9v111_update(struct i2c_client *c, u8 addr_space, u8 reg,\n\t\t\t  u16 mask, u16 val)\n{\n\tu16 current_val;\n\tint ret;\n\n\t \n\tret = __mt9v111_addr_space_select(c, addr_space);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = __mt9v111_read(c, reg, &current_val);\n\tif (ret)\n\t\treturn ret;\n\n\tcurrent_val &= ~mask;\n\tcurrent_val |= (val & mask);\n\tret = __mt9v111_write(c, reg, current_val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \n\nstatic int __mt9v111_power_on(struct v4l2_subdev *sd)\n{\n\tstruct mt9v111_dev *mt9v111 = sd_to_mt9v111(sd);\n\tint ret;\n\n\tret = clk_prepare_enable(mt9v111->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tclk_set_rate(mt9v111->clk, mt9v111->sysclk);\n\n\tgpiod_set_value(mt9v111->standby, 0);\n\tusleep_range(500, 1000);\n\n\tgpiod_set_value(mt9v111->oe, 1);\n\tusleep_range(500, 1000);\n\n\treturn 0;\n}\n\nstatic int __mt9v111_power_off(struct v4l2_subdev *sd)\n{\n\tstruct mt9v111_dev *mt9v111 = sd_to_mt9v111(sd);\n\n\tgpiod_set_value(mt9v111->oe, 0);\n\tusleep_range(500, 1000);\n\n\tgpiod_set_value(mt9v111->standby, 1);\n\tusleep_range(500, 1000);\n\n\tclk_disable_unprepare(mt9v111->clk);\n\n\treturn 0;\n}\n\nstatic int __mt9v111_hw_reset(struct mt9v111_dev *mt9v111)\n{\n\tif (!mt9v111->reset)\n\t\treturn -EINVAL;\n\n\tgpiod_set_value(mt9v111->reset, 1);\n\tusleep_range(500, 1000);\n\n\tgpiod_set_value(mt9v111->reset, 0);\n\tusleep_range(500, 1000);\n\n\treturn 0;\n}\n\nstatic int __mt9v111_sw_reset(struct mt9v111_dev *mt9v111)\n{\n\tstruct i2c_client *c = mt9v111->client;\n\tint ret;\n\n\t \n\n\tret = mt9v111_update(c, MT9V111_R01_CORE,\n\t\t\t     MT9V111_CORE_R0D_CORE_RESET,\n\t\t\t     MT9V111_CORE_R0D_CORE_RESET_MASK, 1);\n\tif (ret)\n\t\treturn ret;\n\tusleep_range(500, 1000);\n\n\tret = mt9v111_update(c, MT9V111_R01_CORE,\n\t\t\t     MT9V111_CORE_R0D_CORE_RESET,\n\t\t\t     MT9V111_CORE_R0D_CORE_RESET_MASK, 0);\n\tif (ret)\n\t\treturn ret;\n\tusleep_range(500, 1000);\n\n\tret = mt9v111_update(c, MT9V111_R01_IFP,\n\t\t\t     MT9V111_IFP_R07_IFP_RESET,\n\t\t\t     MT9V111_IFP_R07_IFP_RESET_MASK, 1);\n\tif (ret)\n\t\treturn ret;\n\tusleep_range(500, 1000);\n\n\tret = mt9v111_update(c, MT9V111_R01_IFP,\n\t\t\t     MT9V111_IFP_R07_IFP_RESET,\n\t\t\t     MT9V111_IFP_R07_IFP_RESET_MASK, 0);\n\tif (ret)\n\t\treturn ret;\n\tusleep_range(500, 1000);\n\n\treturn 0;\n}\n\nstatic int mt9v111_calc_frame_rate(struct mt9v111_dev *mt9v111,\n\t\t\t\t   struct v4l2_fract *tpf)\n{\n\tunsigned int fps = tpf->numerator ?\n\t\t\t   tpf->denominator / tpf->numerator :\n\t\t\t   tpf->denominator;\n\tunsigned int best_diff;\n\tunsigned int frm_cols;\n\tunsigned int row_pclk;\n\tunsigned int best_fps;\n\tunsigned int pclk;\n\tunsigned int diff;\n\tunsigned int idx;\n\tunsigned int hb;\n\tunsigned int vb;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tbest_diff = ~0L;\n\tfor (i = 0, idx = 0; i < ARRAY_SIZE(mt9v111_frame_intervals); i++) {\n\t\tdiff = abs(fps - mt9v111_frame_intervals[i]);\n\t\tif (diff < best_diff) {\n\t\t\tidx = i;\n\t\t\tbest_diff = diff;\n\t\t}\n\t}\n\tfps = mt9v111_frame_intervals[idx];\n\n\t \n\tbest_fps = vb = hb = 0;\n\tpclk = DIV_ROUND_CLOSEST(mt9v111->sysclk, 2);\n\trow_pclk = MT9V111_PIXEL_ARRAY_WIDTH + 7 + MT9V111_CORE_R04_WIN_H_OFFS;\n\tfrm_cols = MT9V111_PIXEL_ARRAY_HEIGHT + 7 + MT9V111_CORE_R03_WIN_V_OFFS;\n\n\tbest_diff = ~0L;\n\tfor (vb = MT9V111_CORE_R06_MIN_VBLANK;\n\t     vb < MT9V111_CORE_R06_MAX_VBLANK; vb++) {\n\t\tfor (hb = MT9V111_CORE_R05_MIN_HBLANK;\n\t\t     hb < MT9V111_CORE_R05_MAX_HBLANK; hb += 10) {\n\t\t\tunsigned int t_frame = (row_pclk + hb) *\n\t\t\t\t\t       (frm_cols + vb);\n\t\t\tunsigned int t_fps = DIV_ROUND_CLOSEST(pclk, t_frame);\n\n\t\t\tdiff = abs(fps - t_fps);\n\t\t\tif (diff < best_diff) {\n\t\t\t\tbest_diff = diff;\n\t\t\t\tbest_fps = t_fps;\n\n\t\t\t\tif (diff == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (diff == 0)\n\t\t\tbreak;\n\t}\n\n\tret = v4l2_ctrl_s_ctrl_int64(mt9v111->hblank, hb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = v4l2_ctrl_s_ctrl_int64(mt9v111->vblank, vb);\n\tif (ret)\n\t\treturn ret;\n\n\ttpf->numerator = 1;\n\ttpf->denominator = best_fps;\n\n\treturn 0;\n}\n\nstatic int mt9v111_hw_config(struct mt9v111_dev *mt9v111)\n{\n\tstruct i2c_client *c = mt9v111->client;\n\tunsigned int ret;\n\tu16 outfmtctrl2;\n\n\t \n\tret = __mt9v111_hw_reset(mt9v111);\n\tif (ret == -EINVAL)\n\t\tret = __mt9v111_sw_reset(mt9v111);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mt9v111->sysclk < DIV_ROUND_CLOSEST(MT9V111_MAX_CLKIN, 2) ?\n\t\t\t\tmt9v111_update(c, MT9V111_R01_CORE,\n\t\t\t\t\tMT9V111_CORE_R07_OUT_CTRL,\n\t\t\t\t\tMT9V111_CORE_R07_OUT_CTRL_SAMPLE, 1) :\n\t\t\t\tmt9v111_update(c, MT9V111_R01_CORE,\n\t\t\t\t\tMT9V111_CORE_R07_OUT_CTRL,\n\t\t\t\t\tMT9V111_CORE_R07_OUT_CTRL_SAMPLE, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tswitch (mt9v111->fmt.code) {\n\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\t\t\toutfmtctrl2 = MT9V111_IFP_R3A_OUTFMT_CTRL2_SWAP_YC;\n\t\t\tbreak;\n\tcase MEDIA_BUS_FMT_VYUY8_2X8:\n\t\t\toutfmtctrl2 = MT9V111_IFP_R3A_OUTFMT_CTRL2_SWAP_CBCR;\n\t\t\tbreak;\n\tcase MEDIA_BUS_FMT_YVYU8_2X8:\n\t\t\toutfmtctrl2 = MT9V111_IFP_R3A_OUTFMT_CTRL2_SWAP_YC |\n\t\t\t\t      MT9V111_IFP_R3A_OUTFMT_CTRL2_SWAP_CBCR;\n\t\t\tbreak;\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\tdefault:\n\t\t\toutfmtctrl2 = 0;\n\t\t\tbreak;\n\t}\n\n\tret = mt9v111_update(c, MT9V111_R01_IFP, MT9V111_IFP_R3A_OUTFMT_CTRL2,\n\t\t\t     MT9V111_IFP_R3A_OUTFMT_CTRL2_SWAP_MASK,\n\t\t\t     outfmtctrl2);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mt9v111_write(c, MT9V111_R01_IFP, MT9V111_IFP_RA5_HPAN,\n\t\t\t    MT9V111_IFP_DECIMATION_FREEZE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt9v111_write(c, MT9V111_R01_IFP, MT9V111_IFP_RA8_VPAN,\n\t\t\t    MT9V111_IFP_DECIMATION_FREEZE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt9v111_write(c, MT9V111_R01_IFP, MT9V111_IFP_RA6_HZOOM,\n\t\t\t    MT9V111_IFP_DECIMATION_FREEZE |\n\t\t\t    MT9V111_PIXEL_ARRAY_WIDTH);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt9v111_write(c, MT9V111_R01_IFP, MT9V111_IFP_RA9_VZOOM,\n\t\t\t    MT9V111_IFP_DECIMATION_FREEZE |\n\t\t\t    MT9V111_PIXEL_ARRAY_HEIGHT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt9v111_write(c, MT9V111_R01_IFP, MT9V111_IFP_RA7_HOUT,\n\t\t\t    MT9V111_IFP_DECIMATION_FREEZE |\n\t\t\t    mt9v111->fmt.width);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt9v111_write(c, MT9V111_R01_IFP, MT9V111_IFP_RAA_VOUT,\n\t\t\t    mt9v111->fmt.height);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = v4l2_ctrl_handler_setup(&mt9v111->ctrls);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn mt9v111_write(c, MT9V111_R01_CORE, MT9V111_CORE_R09_PIXEL_INT,\n\t\t\t     MT9V111_PIXEL_ARRAY_HEIGHT);\n}\n\n \n\nstatic int mt9v111_s_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct mt9v111_dev *mt9v111 = sd_to_mt9v111(sd);\n\tint pwr_count;\n\tint ret = 0;\n\n\tmutex_lock(&mt9v111->pwr_mutex);\n\n\t \n\tpwr_count = mt9v111->pwr_count;\n\tpwr_count += on ? 1 : -1;\n\tif (pwr_count == !!on) {\n\t\tret = on ? __mt9v111_power_on(sd) :\n\t\t\t   __mt9v111_power_off(sd);\n\t\tif (!ret)\n\t\t\t \n\t\t\tmt9v111->pwr_count = pwr_count;\n\n\t\tmutex_unlock(&mt9v111->pwr_mutex);\n\n\t\treturn ret;\n\t}\n\n\t \n\tWARN_ON(pwr_count < 0 || pwr_count > 1);\n\tmt9v111->pwr_count = pwr_count;\n\n\tmutex_unlock(&mt9v111->pwr_mutex);\n\n\treturn ret;\n}\n\nstatic int mt9v111_s_stream(struct v4l2_subdev *subdev, int enable)\n{\n\tstruct mt9v111_dev *mt9v111 = sd_to_mt9v111(subdev);\n\tint ret;\n\n\tmutex_lock(&mt9v111->stream_mutex);\n\n\tif (mt9v111->streaming == enable) {\n\t\tmutex_unlock(&mt9v111->stream_mutex);\n\t\treturn 0;\n\t}\n\n\tret = mt9v111_s_power(subdev, enable);\n\tif (ret)\n\t\tgoto error_unlock;\n\n\tif (enable && mt9v111->pending) {\n\t\tret = mt9v111_hw_config(mt9v111);\n\t\tif (ret)\n\t\t\tgoto error_unlock;\n\n\t\t \n\n\t\tmt9v111->pending = false;\n\t}\n\n\tmt9v111->streaming = enable ? true : false;\n\tmutex_unlock(&mt9v111->stream_mutex);\n\n\treturn 0;\n\nerror_unlock:\n\tmutex_unlock(&mt9v111->stream_mutex);\n\n\treturn ret;\n}\n\nstatic int mt9v111_s_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_frame_interval *ival)\n{\n\tstruct mt9v111_dev *mt9v111 = sd_to_mt9v111(sd);\n\tstruct v4l2_fract *tpf = &ival->interval;\n\tunsigned int fps = tpf->numerator ?\n\t\t\t   tpf->denominator / tpf->numerator :\n\t\t\t   tpf->denominator;\n\tunsigned int max_fps;\n\n\tif (!tpf->numerator)\n\t\ttpf->numerator = 1;\n\n\tmutex_lock(&mt9v111->stream_mutex);\n\n\tif (mt9v111->streaming) {\n\t\tmutex_unlock(&mt9v111->stream_mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tif (mt9v111->fps == fps) {\n\t\tmutex_unlock(&mt9v111->stream_mutex);\n\t\treturn 0;\n\t}\n\n\t \n\tif (mt9v111->fmt.width < QVGA_WIDTH &&\n\t    mt9v111->fmt.height < QVGA_HEIGHT)\n\t\tmax_fps = 90;\n\telse if (mt9v111->fmt.width < CIF_WIDTH &&\n\t\t mt9v111->fmt.height < CIF_HEIGHT)\n\t\tmax_fps = 60;\n\telse\n\t\tmax_fps = mt9v111->sysclk <\n\t\t\t\tDIV_ROUND_CLOSEST(MT9V111_MAX_CLKIN, 2) ? 15 :\n\t\t\t\t\t\t\t\t\t  30;\n\n\tif (fps > max_fps) {\n\t\tmutex_unlock(&mt9v111->stream_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tmt9v111_calc_frame_rate(mt9v111, tpf);\n\n\tmt9v111->fps = fps;\n\tmt9v111->pending = true;\n\n\tmutex_unlock(&mt9v111->stream_mutex);\n\n\treturn 0;\n}\n\nstatic int mt9v111_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_frame_interval *ival)\n{\n\tstruct mt9v111_dev *mt9v111 = sd_to_mt9v111(sd);\n\tstruct v4l2_fract *tpf = &ival->interval;\n\n\tmutex_lock(&mt9v111->stream_mutex);\n\n\ttpf->numerator = 1;\n\ttpf->denominator = mt9v111->fps;\n\n\tmutex_unlock(&mt9v111->stream_mutex);\n\n\treturn 0;\n}\n\nstatic struct v4l2_mbus_framefmt *__mt9v111_get_pad_format(\n\t\t\t\t\tstruct mt9v111_dev *mt9v111,\n\t\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\t\tunsigned int pad,\n\t\t\t\t\tenum v4l2_subdev_format_whence which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n#if IS_ENABLED(CONFIG_VIDEO_V4L2_SUBDEV_API)\n\t\treturn v4l2_subdev_get_try_format(&mt9v111->sd, sd_state, pad);\n#else\n\t\treturn &sd_state->pads->try_fmt;\n#endif\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &mt9v111->fmt;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic int mt9v111_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index > ARRAY_SIZE(mt9v111_formats) - 1)\n\t\treturn -EINVAL;\n\n\tcode->code = mt9v111_formats[code->index].code;\n\n\treturn 0;\n}\n\nstatic int mt9v111_enum_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_frame_interval_enum *fie)\n{\n\tunsigned int i;\n\n\tif (fie->pad || fie->index >= ARRAY_SIZE(mt9v111_frame_intervals))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(mt9v111_frame_sizes); i++)\n\t\tif (fie->width == mt9v111_frame_sizes[i].width &&\n\t\t    fie->height == mt9v111_frame_sizes[i].height)\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(mt9v111_frame_sizes))\n\t\treturn -EINVAL;\n\n\tfie->interval.numerator = 1;\n\tfie->interval.denominator = mt9v111_frame_intervals[fie->index];\n\n\treturn 0;\n}\n\nstatic int mt9v111_enum_frame_size(struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_frame_size_enum *fse)\n{\n\tif (fse->pad || fse->index >= ARRAY_SIZE(mt9v111_frame_sizes))\n\t\treturn -EINVAL;\n\n\tfse->min_width = mt9v111_frame_sizes[fse->index].width;\n\tfse->max_width = mt9v111_frame_sizes[fse->index].width;\n\tfse->min_height = mt9v111_frame_sizes[fse->index].height;\n\tfse->max_height = mt9v111_frame_sizes[fse->index].height;\n\n\treturn 0;\n}\n\nstatic int mt9v111_get_format(struct v4l2_subdev *subdev,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *format)\n{\n\tstruct mt9v111_dev *mt9v111 = sd_to_mt9v111(subdev);\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mt9v111->stream_mutex);\n\tformat->format = *__mt9v111_get_pad_format(mt9v111, sd_state,\n\t\t\t\t\t\t   format->pad,\n\t\t\t\t\t\t   format->which);\n\tmutex_unlock(&mt9v111->stream_mutex);\n\n\treturn 0;\n}\n\nstatic int mt9v111_set_format(struct v4l2_subdev *subdev,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *format)\n{\n\tstruct mt9v111_dev *mt9v111 = sd_to_mt9v111(subdev);\n\tstruct v4l2_mbus_framefmt new_fmt;\n\tstruct v4l2_mbus_framefmt *__fmt;\n\tunsigned int best_fit = ~0L;\n\tunsigned int idx = 0;\n\tunsigned int i;\n\n\tmutex_lock(&mt9v111->stream_mutex);\n\tif (mt9v111->streaming) {\n\t\tmutex_unlock(&mt9v111->stream_mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tif (format->pad) {\n\t\tmutex_unlock(&mt9v111->stream_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mt9v111_formats); i++) {\n\t\tif (format->format.code == mt9v111_formats[i].code) {\n\t\t\tnew_fmt.code = mt9v111_formats[i].code;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == ARRAY_SIZE(mt9v111_formats))\n\t\tnew_fmt.code = mt9v111_formats[0].code;\n\n\tfor (i = 0; i < ARRAY_SIZE(mt9v111_frame_sizes); i++) {\n\t\tunsigned int fit = abs(mt9v111_frame_sizes[i].width -\n\t\t\t\t       format->format.width) +\n\t\t\t\t   abs(mt9v111_frame_sizes[i].height -\n\t\t\t\t       format->format.height);\n\t\tif (fit < best_fit) {\n\t\t\tbest_fit = fit;\n\t\t\tidx = i;\n\n\t\t\tif (fit == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tnew_fmt.width = mt9v111_frame_sizes[idx].width;\n\tnew_fmt.height = mt9v111_frame_sizes[idx].height;\n\n\t \n\t__fmt = __mt9v111_get_pad_format(mt9v111, sd_state, format->pad,\n\t\t\t\t\t format->which);\n\n\t \n\tif (__fmt->code == new_fmt.code &&\n\t    __fmt->width == new_fmt.width &&\n\t    __fmt->height == new_fmt.height)\n\t\tgoto done;\n\n\t \n\t__fmt->code = new_fmt.code;\n\t__fmt->width = new_fmt.width;\n\t__fmt->height = new_fmt.height;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\tmt9v111->pending = true;\n\n\tdev_dbg(mt9v111->dev, \"%s: mbus_code: %x - (%ux%u)\\n\",\n\t\t__func__, __fmt->code, __fmt->width, __fmt->height);\n\ndone:\n\tformat->format = *__fmt;\n\n\tmutex_unlock(&mt9v111->stream_mutex);\n\n\treturn 0;\n}\n\nstatic int mt9v111_init_cfg(struct v4l2_subdev *subdev,\n\t\t\t    struct v4l2_subdev_state *sd_state)\n{\n\tsd_state->pads->try_fmt = mt9v111_def_fmt;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops mt9v111_core_ops = {\n\t.s_power\t\t= mt9v111_s_power,\n};\n\nstatic const struct v4l2_subdev_video_ops mt9v111_video_ops = {\n\t.s_stream\t\t= mt9v111_s_stream,\n\t.s_frame_interval\t= mt9v111_s_frame_interval,\n\t.g_frame_interval\t= mt9v111_g_frame_interval,\n};\n\nstatic const struct v4l2_subdev_pad_ops mt9v111_pad_ops = {\n\t.init_cfg\t\t= mt9v111_init_cfg,\n\t.enum_mbus_code\t\t= mt9v111_enum_mbus_code,\n\t.enum_frame_size\t= mt9v111_enum_frame_size,\n\t.enum_frame_interval\t= mt9v111_enum_frame_interval,\n\t.get_fmt\t\t= mt9v111_get_format,\n\t.set_fmt\t\t= mt9v111_set_format,\n};\n\nstatic const struct v4l2_subdev_ops mt9v111_ops = {\n\t.core\t= &mt9v111_core_ops,\n\t.video\t= &mt9v111_video_ops,\n\t.pad\t= &mt9v111_pad_ops,\n};\n\n#if IS_ENABLED(CONFIG_MEDIA_CONTROLLER)\nstatic const struct media_entity_operations mt9v111_subdev_entity_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n#endif\n\n \nstatic int mt9v111_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct mt9v111_dev *mt9v111 = container_of(ctrl->handler,\n\t\t\t\t\t\t   struct mt9v111_dev,\n\t\t\t\t\t\t   ctrls);\n\tint ret;\n\n\tmutex_lock(&mt9v111->pwr_mutex);\n\t \n\tif (!mt9v111->pwr_count) {\n\t\tmt9v111->pending = true;\n\t\tmutex_unlock(&mt9v111->pwr_mutex);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&mt9v111->pwr_mutex);\n\n\t \n\tif (mt9v111->auto_exp->is_new || mt9v111->auto_awb->is_new) {\n\t\tif (mt9v111->auto_exp->val == V4L2_EXPOSURE_MANUAL &&\n\t\t    mt9v111->auto_awb->val == V4L2_WHITE_BALANCE_MANUAL)\n\t\t\tret = mt9v111_update(mt9v111->client, MT9V111_R01_IFP,\n\t\t\t\t\t     MT9V111_IFP_R08_OUTFMT_CTRL,\n\t\t\t\t\t     MT9V111_IFP_R08_OUTFMT_CTRL_FLICKER,\n\t\t\t\t\t     0);\n\t\telse\n\t\t\tret = mt9v111_update(mt9v111->client, MT9V111_R01_IFP,\n\t\t\t\t\t     MT9V111_IFP_R08_OUTFMT_CTRL,\n\t\t\t\t\t     MT9V111_IFP_R08_OUTFMT_CTRL_FLICKER,\n\t\t\t\t\t     1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = -EINVAL;\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\tret = mt9v111_update(mt9v111->client, MT9V111_R01_IFP,\n\t\t\t\t     MT9V111_IFP_R06_OPMODE_CTRL,\n\t\t\t\t     MT9V111_IFP_R06_OPMODE_CTRL_AWB_EN,\n\t\t\t\t     ctrl->val == V4L2_WHITE_BALANCE_AUTO ?\n\t\t\t\t     MT9V111_IFP_R06_OPMODE_CTRL_AWB_EN : 0);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tret = mt9v111_update(mt9v111->client, MT9V111_R01_IFP,\n\t\t\t\t     MT9V111_IFP_R06_OPMODE_CTRL,\n\t\t\t\t     MT9V111_IFP_R06_OPMODE_CTRL_AE_EN,\n\t\t\t\t     ctrl->val == V4L2_EXPOSURE_AUTO ?\n\t\t\t\t     MT9V111_IFP_R06_OPMODE_CTRL_AE_EN : 0);\n\t\tbreak;\n\tcase V4L2_CID_HBLANK:\n\t\tret = mt9v111_update(mt9v111->client, MT9V111_R01_CORE,\n\t\t\t\t     MT9V111_CORE_R05_HBLANK,\n\t\t\t\t     MT9V111_CORE_R05_MAX_HBLANK,\n\t\t\t\t     mt9v111->hblank->val);\n\t\tbreak;\n\tcase V4L2_CID_VBLANK:\n\t\tret = mt9v111_update(mt9v111->client, MT9V111_R01_CORE,\n\t\t\t\t     MT9V111_CORE_R06_VBLANK,\n\t\t\t\t     MT9V111_CORE_R06_MAX_VBLANK,\n\t\t\t\t     mt9v111->vblank->val);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops mt9v111_ctrl_ops = {\n\t.s_ctrl = mt9v111_s_ctrl,\n};\n\nstatic int mt9v111_chip_probe(struct mt9v111_dev *mt9v111)\n{\n\tint ret;\n\tu16 val;\n\n\tret = __mt9v111_power_on(&mt9v111->sd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt9v111_read(mt9v111->client, MT9V111_R01_CORE,\n\t\t\t   MT9V111_CORE_RFF_CHIP_VER, &val);\n\tif (ret)\n\t\tgoto power_off;\n\n\tif ((val >> 8) != MT9V111_CHIP_ID_HIGH &&\n\t    (val & 0xff) != MT9V111_CHIP_ID_LOW) {\n\t\tdev_err(mt9v111->dev,\n\t\t\t\"Unable to identify MT9V111 chip: 0x%2x%2x\\n\",\n\t\t\tval >> 8, val & 0xff);\n\t\tret = -EIO;\n\t\tgoto power_off;\n\t}\n\n\tdev_dbg(mt9v111->dev, \"Chip identified: 0x%2x%2x\\n\",\n\t\tval >> 8, val & 0xff);\n\npower_off:\n\t__mt9v111_power_off(&mt9v111->sd);\n\n\treturn ret;\n}\n\nstatic int mt9v111_probe(struct i2c_client *client)\n{\n\tstruct mt9v111_dev *mt9v111;\n\tstruct v4l2_fract tpf;\n\tint ret;\n\n\tmt9v111 = devm_kzalloc(&client->dev, sizeof(*mt9v111), GFP_KERNEL);\n\tif (!mt9v111)\n\t\treturn -ENOMEM;\n\n\tmt9v111->dev = &client->dev;\n\tmt9v111->client = client;\n\n\tmt9v111->clk = devm_clk_get(&client->dev, NULL);\n\tif (IS_ERR(mt9v111->clk))\n\t\treturn PTR_ERR(mt9v111->clk);\n\n\tmt9v111->sysclk = clk_get_rate(mt9v111->clk);\n\tif (mt9v111->sysclk > MT9V111_MAX_CLKIN)\n\t\treturn -EINVAL;\n\n\tmt9v111->oe = devm_gpiod_get_optional(&client->dev, \"enable\",\n\t\t\t\t\t      GPIOD_OUT_LOW);\n\tif (IS_ERR(mt9v111->oe)) {\n\t\tdev_err(&client->dev, \"Unable to get GPIO \\\"enable\\\": %ld\\n\",\n\t\t\tPTR_ERR(mt9v111->oe));\n\t\treturn PTR_ERR(mt9v111->oe);\n\t}\n\n\tmt9v111->standby = devm_gpiod_get_optional(&client->dev, \"standby\",\n\t\t\t\t\t\t   GPIOD_OUT_HIGH);\n\tif (IS_ERR(mt9v111->standby)) {\n\t\tdev_err(&client->dev, \"Unable to get GPIO \\\"standby\\\": %ld\\n\",\n\t\t\tPTR_ERR(mt9v111->standby));\n\t\treturn PTR_ERR(mt9v111->standby);\n\t}\n\n\tmt9v111->reset = devm_gpiod_get_optional(&client->dev, \"reset\",\n\t\t\t\t\t\t GPIOD_OUT_LOW);\n\tif (IS_ERR(mt9v111->reset)) {\n\t\tdev_err(&client->dev, \"Unable to get GPIO \\\"reset\\\": %ld\\n\",\n\t\t\tPTR_ERR(mt9v111->reset));\n\t\treturn PTR_ERR(mt9v111->reset);\n\t}\n\n\tmutex_init(&mt9v111->pwr_mutex);\n\tmutex_init(&mt9v111->stream_mutex);\n\n\tv4l2_ctrl_handler_init(&mt9v111->ctrls, 5);\n\n\tmt9v111->auto_awb = v4l2_ctrl_new_std(&mt9v111->ctrls,\n\t\t\t\t\t      &mt9v111_ctrl_ops,\n\t\t\t\t\t      V4L2_CID_AUTO_WHITE_BALANCE,\n\t\t\t\t\t      0, 1, 1,\n\t\t\t\t\t      V4L2_WHITE_BALANCE_AUTO);\n\tmt9v111->auto_exp = v4l2_ctrl_new_std_menu(&mt9v111->ctrls,\n\t\t\t\t\t\t   &mt9v111_ctrl_ops,\n\t\t\t\t\t\t   V4L2_CID_EXPOSURE_AUTO,\n\t\t\t\t\t\t   V4L2_EXPOSURE_MANUAL,\n\t\t\t\t\t\t   0, V4L2_EXPOSURE_AUTO);\n\tmt9v111->hblank = v4l2_ctrl_new_std(&mt9v111->ctrls, &mt9v111_ctrl_ops,\n\t\t\t\t\t    V4L2_CID_HBLANK,\n\t\t\t\t\t    MT9V111_CORE_R05_MIN_HBLANK,\n\t\t\t\t\t    MT9V111_CORE_R05_MAX_HBLANK, 1,\n\t\t\t\t\t    MT9V111_CORE_R05_DEF_HBLANK);\n\tmt9v111->vblank = v4l2_ctrl_new_std(&mt9v111->ctrls, &mt9v111_ctrl_ops,\n\t\t\t\t\t    V4L2_CID_VBLANK,\n\t\t\t\t\t    MT9V111_CORE_R06_MIN_VBLANK,\n\t\t\t\t\t    MT9V111_CORE_R06_MAX_VBLANK, 1,\n\t\t\t\t\t    MT9V111_CORE_R06_DEF_VBLANK);\n\n\t \n\tv4l2_ctrl_new_std(&mt9v111->ctrls, &mt9v111_ctrl_ops,\n\t\t\t  V4L2_CID_PIXEL_RATE, 0,\n\t\t\t  DIV_ROUND_CLOSEST(mt9v111->sysclk, 2), 1,\n\t\t\t  DIV_ROUND_CLOSEST(mt9v111->sysclk, 2));\n\n\tif (mt9v111->ctrls.error) {\n\t\tret = mt9v111->ctrls.error;\n\t\tgoto error_free_ctrls;\n\t}\n\tmt9v111->sd.ctrl_handler = &mt9v111->ctrls;\n\n\t \n\tmt9v111->fmt\t= mt9v111_def_fmt;\n\n\t \n\tmt9v111->fps\t\t= 15;\n\ttpf.numerator\t\t= 1;\n\ttpf.denominator\t\t= mt9v111->fps;\n\tmt9v111_calc_frame_rate(mt9v111, &tpf);\n\n\tmt9v111->pwr_count\t= 0;\n\tmt9v111->addr_space\t= MT9V111_R01_IFP;\n\tmt9v111->pending\t= true;\n\n\tv4l2_i2c_subdev_init(&mt9v111->sd, client, &mt9v111_ops);\n\n#if IS_ENABLED(CONFIG_MEDIA_CONTROLLER)\n\tmt9v111->sd.flags\t|= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tmt9v111->sd.entity.ops\t= &mt9v111_subdev_entity_ops;\n\tmt9v111->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\n\tmt9v111->pad.flags\t= MEDIA_PAD_FL_SOURCE;\n\tret = media_entity_pads_init(&mt9v111->sd.entity, 1, &mt9v111->pad);\n\tif (ret)\n\t\tgoto error_free_entity;\n#endif\n\n\tret = mt9v111_chip_probe(mt9v111);\n\tif (ret)\n\t\tgoto error_free_entity;\n\n\tret = v4l2_async_register_subdev(&mt9v111->sd);\n\tif (ret)\n\t\tgoto error_free_entity;\n\n\treturn 0;\n\nerror_free_entity:\n#if IS_ENABLED(CONFIG_MEDIA_CONTROLLER)\n\tmedia_entity_cleanup(&mt9v111->sd.entity);\n#endif\n\nerror_free_ctrls:\n\tv4l2_ctrl_handler_free(&mt9v111->ctrls);\n\n\tmutex_destroy(&mt9v111->pwr_mutex);\n\tmutex_destroy(&mt9v111->stream_mutex);\n\n\treturn ret;\n}\n\nstatic void mt9v111_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct mt9v111_dev *mt9v111 = sd_to_mt9v111(sd);\n\n\tv4l2_async_unregister_subdev(sd);\n\n#if IS_ENABLED(CONFIG_MEDIA_CONTROLLER)\n\tmedia_entity_cleanup(&sd->entity);\n#endif\n\n\tv4l2_ctrl_handler_free(&mt9v111->ctrls);\n\n\tmutex_destroy(&mt9v111->pwr_mutex);\n\tmutex_destroy(&mt9v111->stream_mutex);\n}\n\nstatic const struct of_device_id mt9v111_of_match[] = {\n\t{ .compatible = \"aptina,mt9v111\", },\n\t{   },\n};\n\nstatic struct i2c_driver mt9v111_driver = {\n\t.driver = {\n\t\t.name = \"mt9v111\",\n\t\t.of_match_table = mt9v111_of_match,\n\t},\n\t.probe\t\t= mt9v111_probe,\n\t.remove\t\t= mt9v111_remove,\n};\n\nmodule_i2c_driver(mt9v111_driver);\n\nMODULE_DESCRIPTION(\"V4L2 sensor driver for Aptina MT9V111\");\nMODULE_AUTHOR(\"Jacopo Mondi <jacopo@jmondi.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}