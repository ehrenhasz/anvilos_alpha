{
  "module_name": "max9286.c",
  "hash_id": "cf2d74e9c1cb1437612263d539580e58a3959165f73d9a298fed202a1da68a28",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/max9286.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/fwnode.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/driver.h>\n#include <linux/gpio/machine.h>\n#include <linux/i2c.h>\n#include <linux/i2c-mux.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of_graph.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-async.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n \n#define MAX9286_MSTLINKSEL_AUTO\t\t(7 << 5)\n#define MAX9286_MSTLINKSEL(n)\t\t((n) << 5)\n#define MAX9286_EN_VS_GEN\t\tBIT(4)\n#define MAX9286_LINKEN(n)\t\t(1 << (n))\n \n#define MAX9286_FSYNCMODE_ECU\t\t(3 << 6)\n#define MAX9286_FSYNCMODE_EXT\t\t(2 << 6)\n#define MAX9286_FSYNCMODE_INT_OUT\t(1 << 6)\n#define MAX9286_FSYNCMODE_INT_HIZ\t(0 << 6)\n#define MAX9286_GPIEN\t\t\tBIT(5)\n#define MAX9286_ENLMO_RSTFSYNC\t\tBIT(2)\n#define MAX9286_FSYNCMETH_AUTO\t\t(2 << 0)\n#define MAX9286_FSYNCMETH_SEMI_AUTO\t(1 << 0)\n#define MAX9286_FSYNCMETH_MANUAL\t(0 << 0)\n#define MAX9286_REG_FSYNC_PERIOD_L\t0x06\n#define MAX9286_REG_FSYNC_PERIOD_M\t0x07\n#define MAX9286_REG_FSYNC_PERIOD_H\t0x08\n \n#define MAX9286_FWDCCEN(n)\t\t(1 << ((n) + 4))\n#define MAX9286_REVCCEN(n)\t\t(1 << (n))\n \n#define MAX9286_HVEN\t\t\tBIT(7)\n#define MAX9286_EDC_6BIT_HAMMING\t(2 << 5)\n#define MAX9286_EDC_6BIT_CRC\t\t(1 << 5)\n#define MAX9286_EDC_1BIT_PARITY\t\t(0 << 5)\n#define MAX9286_DESEL\t\t\tBIT(4)\n#define MAX9286_INVVS\t\t\tBIT(3)\n#define MAX9286_INVHS\t\t\tBIT(2)\n#define MAX9286_HVSRC_D0\t\t(2 << 0)\n#define MAX9286_HVSRC_D14\t\t(1 << 0)\n#define MAX9286_HVSRC_D18\t\t(0 << 0)\n \n#define MAX9286_0X0F_RESERVED\t\tBIT(3)\n \n#define MAX9286_CSILANECNT(n)\t\t(((n) - 1) << 6)\n#define MAX9286_CSIDBL\t\t\tBIT(5)\n#define MAX9286_DBL\t\t\tBIT(4)\n#define MAX9286_DATATYPE_USER_8BIT\t(11 << 0)\n#define MAX9286_DATATYPE_USER_YUV_12BIT\t(10 << 0)\n#define MAX9286_DATATYPE_USER_24BIT\t(9 << 0)\n#define MAX9286_DATATYPE_RAW14\t\t(8 << 0)\n#define MAX9286_DATATYPE_RAW12\t\t(7 << 0)\n#define MAX9286_DATATYPE_RAW10\t\t(6 << 0)\n#define MAX9286_DATATYPE_RAW8\t\t(5 << 0)\n#define MAX9286_DATATYPE_YUV422_10BIT\t(4 << 0)\n#define MAX9286_DATATYPE_YUV422_8BIT\t(3 << 0)\n#define MAX9286_DATATYPE_RGB555\t\t(2 << 0)\n#define MAX9286_DATATYPE_RGB565\t\t(1 << 0)\n#define MAX9286_DATATYPE_RGB888\t\t(0 << 0)\n \n#define MAX9286_CSI_IMAGE_TYP\t\tBIT(7)\n#define MAX9286_VC(n)\t\t\t((n) << 5)\n#define MAX9286_VCTYPE\t\t\tBIT(4)\n#define MAX9286_CSIOUTEN\t\tBIT(3)\n#define MAX9286_SWP_ENDIAN\t\tBIT(2)\n#define MAX9286_EN_CCBSYB_CLK_STR\tBIT(1)\n#define MAX9286_EN_GPI_CCBSYB\t\tBIT(0)\n \n#define MAX9286_SWITCHIN(n)\t\t(1 << ((n) + 4))\n#define MAX9286_ENEQ(n)\t\t\t(1 << (n))\n \n#define MAX9286_HIGHIMM(n)\t\tBIT((n) + 4)\n#define MAX9286_I2CSEL\t\t\tBIT(2)\n#define MAX9286_HIBW\t\t\tBIT(1)\n#define MAX9286_BWS\t\t\tBIT(0)\n \n#define MAX9286_LOCKED\t\t\tBIT(7)\n \n#define MAX9286_FSYNC_LOCKED\t\tBIT(6)\n \n#define MAX9286_I2CLOCACK\t\tBIT(7)\n#define MAX9286_I2CSLVSH_1046NS_469NS\t(3 << 5)\n#define MAX9286_I2CSLVSH_938NS_352NS\t(2 << 5)\n#define MAX9286_I2CSLVSH_469NS_234NS\t(1 << 5)\n#define MAX9286_I2CSLVSH_352NS_117NS\t(0 << 5)\n#define MAX9286_I2CMSTBT_837KBPS\t(7 << 2)\n#define MAX9286_I2CMSTBT_533KBPS\t(6 << 2)\n#define MAX9286_I2CMSTBT_339KBPS\t(5 << 2)\n#define MAX9286_I2CMSTBT_173KBPS\t(4 << 2)\n#define MAX9286_I2CMSTBT_105KBPS\t(3 << 2)\n#define MAX9286_I2CMSTBT_84KBPS\t\t(2 << 2)\n#define MAX9286_I2CMSTBT_28KBPS\t\t(1 << 2)\n#define MAX9286_I2CMSTBT_8KBPS\t\t(0 << 2)\n#define MAX9286_I2CSLVTO_NONE\t\t(3 << 0)\n#define MAX9286_I2CSLVTO_1024US\t\t(2 << 0)\n#define MAX9286_I2CSLVTO_256US\t\t(1 << 0)\n#define MAX9286_I2CSLVTO_64US\t\t(0 << 0)\n \n#define MAX9286_REV_TRF(n)\t\t((n) << 4)\n#define MAX9286_REV_AMP(n)\t\t((((n) - 30) / 10) << 1)  \n#define MAX9286_REV_AMP_X\t\tBIT(0)\n#define MAX9286_REV_AMP_HIGH\t\t170\n \n#define MAX9286_EN_REV_CFG\t\tBIT(6)\n#define MAX9286_REV_FLEN(n)\t\t((n) - 20)\n \n#define MAX9286_VIDEO_DETECT_MASK\t0x0f\n \n#define MAX9286_LFLTBMONMASKED\t\tBIT(7)\n#define MAX9286_LOCKMONMASKED\t\tBIT(6)\n#define MAX9286_AUTOCOMBACKEN\t\tBIT(5)\n#define MAX9286_AUTOMASKEN\t\tBIT(4)\n#define MAX9286_MASKLINK(n)\t\t((n) << 0)\n\n \n#define MAX9286_NUM_GMSL\t\t4\n#define MAX9286_N_SINKS\t\t\t4\n#define MAX9286_N_PADS\t\t\t5\n#define MAX9286_SRC_PAD\t\t\t4\n\nstruct max9286_format_info {\n\tu32 code;\n\tu8 datatype;\n};\n\nstruct max9286_i2c_speed {\n\tu32 rate;\n\tu8 mstbt;\n};\n\nstruct max9286_source {\n\tstruct v4l2_subdev *sd;\n\tstruct fwnode_handle *fwnode;\n\tstruct regulator *regulator;\n};\n\nstruct max9286_asd {\n\tstruct v4l2_async_connection base;\n\tstruct max9286_source *source;\n};\n\nstatic inline struct max9286_asd *\nto_max9286_asd(struct v4l2_async_connection *asd)\n{\n\treturn container_of(asd, struct max9286_asd, base);\n}\n\nstruct max9286_priv {\n\tstruct i2c_client *client;\n\tstruct gpio_desc *gpiod_pwdn;\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pads[MAX9286_N_PADS];\n\tstruct regulator *regulator;\n\n\tstruct gpio_chip gpio;\n\tu8 gpio_state;\n\n\tstruct i2c_mux_core *mux;\n\tunsigned int mux_channel;\n\tbool mux_open;\n\n\t \n\tu32 init_rev_chan_mv;\n\tu32 rev_chan_mv;\n\tu8 i2c_mstbt;\n\tu32 bus_width;\n\n\tbool use_gpio_poc;\n\tu32 gpio_poc[2];\n\n\tstruct v4l2_ctrl_handler ctrls;\n\tstruct v4l2_ctrl *pixelrate_ctrl;\n\tunsigned int pixelrate;\n\n\tstruct v4l2_mbus_framefmt fmt[MAX9286_N_SINKS];\n\tstruct v4l2_fract interval;\n\n\t \n\tstruct mutex mutex;\n\n\tunsigned int nsources;\n\tunsigned int source_mask;\n\tunsigned int route_mask;\n\tunsigned int bound_sources;\n\tunsigned int csi2_data_lanes;\n\tstruct max9286_source sources[MAX9286_NUM_GMSL];\n\tstruct v4l2_async_notifier notifier;\n};\n\nstatic struct max9286_source *next_source(struct max9286_priv *priv,\n\t\t\t\t\t  struct max9286_source *source)\n{\n\tif (!source)\n\t\tsource = &priv->sources[0];\n\telse\n\t\tsource++;\n\n\tfor (; source < &priv->sources[MAX9286_NUM_GMSL]; source++) {\n\t\tif (source->fwnode)\n\t\t\treturn source;\n\t}\n\n\treturn NULL;\n}\n\n#define for_each_source(priv, source) \\\n\tfor ((source) = NULL; ((source) = next_source((priv), (source))); )\n\n#define to_index(priv, source) ((source) - &(priv)->sources[0])\n\nstatic inline struct max9286_priv *sd_to_max9286(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct max9286_priv, sd);\n}\n\nstatic const struct max9286_format_info max9286_formats[] = {\n\t{\n\t\t.code = MEDIA_BUS_FMT_UYVY8_1X16,\n\t\t.datatype = MAX9286_DATATYPE_YUV422_8BIT,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_VYUY8_1X16,\n\t\t.datatype = MAX9286_DATATYPE_YUV422_8BIT,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_YUYV8_1X16,\n\t\t.datatype = MAX9286_DATATYPE_YUV422_8BIT,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_YVYU8_1X16,\n\t\t.datatype = MAX9286_DATATYPE_YUV422_8BIT,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SBGGR12_1X12,\n\t\t.datatype = MAX9286_DATATYPE_RAW12,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGBRG12_1X12,\n\t\t.datatype = MAX9286_DATATYPE_RAW12,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGRBG12_1X12,\n\t\t.datatype = MAX9286_DATATYPE_RAW12,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SRGGB12_1X12,\n\t\t.datatype = MAX9286_DATATYPE_RAW12,\n\t},\n};\n\nstatic const struct max9286_i2c_speed max9286_i2c_speeds[] = {\n\t{ .rate =   8470, .mstbt = MAX9286_I2CMSTBT_8KBPS },\n\t{ .rate =  28300, .mstbt = MAX9286_I2CMSTBT_28KBPS },\n\t{ .rate =  84700, .mstbt = MAX9286_I2CMSTBT_84KBPS },\n\t{ .rate = 105000, .mstbt = MAX9286_I2CMSTBT_105KBPS },\n\t{ .rate = 173000, .mstbt = MAX9286_I2CMSTBT_173KBPS },\n\t{ .rate = 339000, .mstbt = MAX9286_I2CMSTBT_339KBPS },\n\t{ .rate = 533000, .mstbt = MAX9286_I2CMSTBT_533KBPS },\n\t{ .rate = 837000, .mstbt = MAX9286_I2CMSTBT_837KBPS },\n};\n\n \n\nstatic int max9286_read(struct max9286_priv *priv, u8 reg)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(priv->client, reg);\n\tif (ret < 0)\n\t\tdev_err(&priv->client->dev,\n\t\t\t\"%s: register 0x%02x read failed (%d)\\n\",\n\t\t\t__func__, reg, ret);\n\n\treturn ret;\n}\n\nstatic int max9286_write(struct max9286_priv *priv, u8 reg, u8 val)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(priv->client, reg, val);\n\tif (ret < 0)\n\t\tdev_err(&priv->client->dev,\n\t\t\t\"%s: register 0x%02x write failed (%d)\\n\",\n\t\t\t__func__, reg, ret);\n\n\treturn ret;\n}\n\n \n\nstatic void max9286_i2c_mux_configure(struct max9286_priv *priv, u8 conf)\n{\n\tmax9286_write(priv, 0x0a, conf);\n\n\t \n\tusleep_range(3000, 5000);\n}\n\nstatic void max9286_i2c_mux_open(struct max9286_priv *priv)\n{\n\t \n\tmax9286_i2c_mux_configure(priv, 0xff);\n\n\tpriv->mux_open = true;\n}\n\nstatic void max9286_i2c_mux_close(struct max9286_priv *priv)\n{\n\t \n\tmax9286_i2c_mux_configure(priv, 0x00);\n\n\tpriv->mux_open = false;\n\tpriv->mux_channel = -1;\n}\n\nstatic int max9286_i2c_mux_select(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct max9286_priv *priv = i2c_mux_priv(muxc);\n\n\t \n\tif (priv->mux_open)\n\t\treturn 0;\n\n\tif (priv->mux_channel == chan)\n\t\treturn 0;\n\n\tpriv->mux_channel = chan;\n\n\tmax9286_i2c_mux_configure(priv, MAX9286_FWDCCEN(chan) |\n\t\t\t\t\tMAX9286_REVCCEN(chan));\n\n\treturn 0;\n}\n\nstatic int max9286_i2c_mux_init(struct max9286_priv *priv)\n{\n\tstruct max9286_source *source;\n\tint ret;\n\n\tif (!i2c_check_functionality(priv->client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_WRITE_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tpriv->mux = i2c_mux_alloc(priv->client->adapter, &priv->client->dev,\n\t\t\t\t  priv->nsources, 0, I2C_MUX_LOCKED,\n\t\t\t\t  max9286_i2c_mux_select, NULL);\n\tif (!priv->mux)\n\t\treturn -ENOMEM;\n\n\tpriv->mux->priv = priv;\n\n\tfor_each_source(priv, source) {\n\t\tunsigned int index = to_index(priv, source);\n\n\t\tret = i2c_mux_add_adapter(priv->mux, 0, index, 0);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\ti2c_mux_del_adapters(priv->mux);\n\treturn ret;\n}\n\nstatic void max9286_configure_i2c(struct max9286_priv *priv, bool localack)\n{\n\tu8 config = MAX9286_I2CSLVSH_469NS_234NS | MAX9286_I2CSLVTO_1024US |\n\t\t    priv->i2c_mstbt;\n\n\tif (localack)\n\t\tconfig |= MAX9286_I2CLOCACK;\n\n\tmax9286_write(priv, 0x34, config);\n\tusleep_range(3000, 5000);\n}\n\nstatic void max9286_reverse_channel_setup(struct max9286_priv *priv,\n\t\t\t\t\t  unsigned int chan_amplitude)\n{\n\tu8 chan_config;\n\n\tif (priv->rev_chan_mv == chan_amplitude)\n\t\treturn;\n\n\tpriv->rev_chan_mv = chan_amplitude;\n\n\t \n\tchan_config = MAX9286_REV_TRF(1);\n\n\t \n\tmax9286_write(priv, 0x3f, MAX9286_EN_REV_CFG | MAX9286_REV_FLEN(35));\n\n\tif (chan_amplitude > 100) {\n\t\t \n\t\tchan_amplitude = max(30U, chan_amplitude - 100);\n\t\tchan_config |= MAX9286_REV_AMP_X;\n\t}\n\tmax9286_write(priv, 0x3b, chan_config | MAX9286_REV_AMP(chan_amplitude));\n\tusleep_range(2000, 2500);\n}\n\n \nstatic int max9286_check_video_links(struct max9286_priv *priv)\n{\n\tunsigned int i;\n\tint ret;\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tret = max9286_read(priv, 0x49);\n\t\tif (ret < 0)\n\t\t\treturn -EIO;\n\n\t\tif ((ret & MAX9286_VIDEO_DETECT_MASK) == priv->source_mask)\n\t\t\tbreak;\n\n\t\tusleep_range(350, 500);\n\t}\n\n\tif (i == 10) {\n\t\tdev_err(&priv->client->dev,\n\t\t\t\"Unable to detect video links: 0x%02x\\n\", ret);\n\t\treturn -EIO;\n\t}\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tret = max9286_read(priv, 0x27);\n\t\tif (ret < 0)\n\t\t\treturn -EIO;\n\n\t\tif (ret & MAX9286_LOCKED)\n\t\t\tbreak;\n\n\t\tusleep_range(350, 450);\n\t}\n\n\tif (i == 10) {\n\t\tdev_err(&priv->client->dev, \"Not all enabled links locked\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int max9286_check_config_link(struct max9286_priv *priv,\n\t\t\t\t     unsigned int source_mask)\n{\n\tunsigned int conflink_mask = (source_mask & 0x0f) << 4;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tret = max9286_read(priv, 0x49);\n\t\tif (ret < 0)\n\t\t\treturn -EIO;\n\n\t\tret &= 0xf0;\n\t\tif (ret == conflink_mask)\n\t\t\tbreak;\n\n\t\tusleep_range(350, 500);\n\t}\n\n\tif (ret != conflink_mask) {\n\t\tdev_err(&priv->client->dev,\n\t\t\t\"Unable to detect configuration links: 0x%02x expected 0x%02x\\n\",\n\t\t\tret, conflink_mask);\n\t\treturn -EIO;\n\t}\n\n\tdev_info(&priv->client->dev,\n\t\t \"Successfully detected configuration links after %u loops: 0x%02x\\n\",\n\t\t i, conflink_mask);\n\n\treturn 0;\n}\n\nstatic void max9286_set_video_format(struct max9286_priv *priv,\n\t\t\t\t     const struct v4l2_mbus_framefmt *format)\n{\n\tconst struct max9286_format_info *info = NULL;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(max9286_formats); ++i) {\n\t\tif (max9286_formats[i].code == format->code) {\n\t\t\tinfo = &max9286_formats[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN_ON(!info))\n\t\treturn;\n\n\t \n\tmax9286_write(priv, 0x15, MAX9286_VCTYPE | MAX9286_EN_CCBSYB_CLK_STR |\n\t\t      MAX9286_EN_GPI_CCBSYB);\n\n\t \n\tmax9286_write(priv, 0x12, MAX9286_CSIDBL | MAX9286_DBL |\n\t\t      MAX9286_CSILANECNT(priv->csi2_data_lanes) |\n\t\t      info->datatype);\n\n\t \n\tmax9286_write(priv, 0x0c, MAX9286_HVEN | MAX9286_DESEL |\n\t\t      MAX9286_INVVS | MAX9286_HVSRC_D14);\n}\n\nstatic void max9286_set_fsync_period(struct max9286_priv *priv)\n{\n\tu32 fsync;\n\n\tif (!priv->interval.numerator || !priv->interval.denominator) {\n\t\t \n\t\tmax9286_write(priv, 0x01, MAX9286_FSYNCMODE_INT_HIZ |\n\t\t\t      MAX9286_FSYNCMETH_AUTO);\n\t\treturn;\n\t}\n\n\t \n\tfsync = div_u64((u64)priv->pixelrate * priv->interval.numerator,\n\t\t\tpriv->interval.denominator);\n\n\tdev_dbg(&priv->client->dev, \"fsync period %u (pclk %u)\\n\", fsync,\n\t\tpriv->pixelrate);\n\n\tmax9286_write(priv, 0x01, MAX9286_FSYNCMODE_INT_OUT |\n\t\t      MAX9286_FSYNCMETH_MANUAL);\n\n\tmax9286_write(priv, 0x06, (fsync >> 0) & 0xff);\n\tmax9286_write(priv, 0x07, (fsync >> 8) & 0xff);\n\tmax9286_write(priv, 0x08, (fsync >> 16) & 0xff);\n}\n\n \n\nstatic int max9286_set_pixelrate(struct max9286_priv *priv)\n{\n\tstruct max9286_source *source = NULL;\n\tu64 pixelrate = 0;\n\n\tfor_each_source(priv, source) {\n\t\tstruct v4l2_ctrl *ctrl;\n\t\tu64 source_rate = 0;\n\n\t\t \n\t\tctrl = v4l2_ctrl_find(source->sd->ctrl_handler,\n\t\t\t\t      V4L2_CID_PIXEL_RATE);\n\t\tif (!ctrl) {\n\t\t\tpixelrate = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tsource_rate = v4l2_ctrl_g_ctrl_int64(ctrl);\n\t\tif (!pixelrate) {\n\t\t\tpixelrate = source_rate;\n\t\t} else if (pixelrate != source_rate) {\n\t\t\tdev_err(&priv->client->dev,\n\t\t\t\t\"Unable to calculate pixel rate\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!pixelrate) {\n\t\tdev_err(&priv->client->dev,\n\t\t\t\"No pixel rate control available in sources\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->pixelrate = pixelrate;\n\n\t \n\treturn v4l2_ctrl_s_ctrl_int64(priv->pixelrate_ctrl,\n\t\t\t\t      pixelrate * priv->nsources);\n}\n\nstatic int max9286_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\tstruct v4l2_subdev *subdev,\n\t\t\t\tstruct v4l2_async_connection *asd)\n{\n\tstruct max9286_priv *priv = sd_to_max9286(notifier->sd);\n\tstruct max9286_source *source = to_max9286_asd(asd)->source;\n\tunsigned int index = to_index(priv, source);\n\tunsigned int src_pad;\n\tint ret;\n\n\tret = media_entity_get_fwnode_pad(&subdev->entity,\n\t\t\t\t\t  source->fwnode,\n\t\t\t\t\t  MEDIA_PAD_FL_SOURCE);\n\tif (ret < 0) {\n\t\tdev_err(&priv->client->dev,\n\t\t\t\"Failed to find pad for %s\\n\", subdev->name);\n\t\treturn ret;\n\t}\n\n\tpriv->bound_sources |= BIT(index);\n\tsource->sd = subdev;\n\tsrc_pad = ret;\n\n\tret = media_create_pad_link(&source->sd->entity, src_pad,\n\t\t\t\t    &priv->sd.entity, index,\n\t\t\t\t    MEDIA_LNK_FL_ENABLED |\n\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE);\n\tif (ret) {\n\t\tdev_err(&priv->client->dev,\n\t\t\t\"Unable to link %s:%u -> %s:%u\\n\",\n\t\t\tsource->sd->name, src_pad, priv->sd.name, index);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(&priv->client->dev, \"Bound %s pad: %u on index %u\\n\",\n\t\tsubdev->name, src_pad, index);\n\n\t \n\tif (priv->bound_sources != priv->source_mask)\n\t\treturn 0;\n\n\t \n\tmax9286_reverse_channel_setup(priv, MAX9286_REV_AMP_HIGH);\n\tmax9286_check_config_link(priv, priv->source_mask);\n\tmax9286_configure_i2c(priv, false);\n\n\treturn max9286_set_pixelrate(priv);\n}\n\nstatic void max9286_notify_unbind(struct v4l2_async_notifier *notifier,\n\t\t\t\t  struct v4l2_subdev *subdev,\n\t\t\t\t  struct v4l2_async_connection *asd)\n{\n\tstruct max9286_priv *priv = sd_to_max9286(notifier->sd);\n\tstruct max9286_source *source = to_max9286_asd(asd)->source;\n\tunsigned int index = to_index(priv, source);\n\n\tsource->sd = NULL;\n\tpriv->bound_sources &= ~BIT(index);\n}\n\nstatic const struct v4l2_async_notifier_operations max9286_notify_ops = {\n\t.bound = max9286_notify_bound,\n\t.unbind = max9286_notify_unbind,\n};\n\nstatic int max9286_v4l2_notifier_register(struct max9286_priv *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tstruct max9286_source *source = NULL;\n\tint ret;\n\n\tif (!priv->nsources)\n\t\treturn 0;\n\n\tv4l2_async_subdev_nf_init(&priv->notifier, &priv->sd);\n\n\tfor_each_source(priv, source) {\n\t\tunsigned int i = to_index(priv, source);\n\t\tstruct max9286_asd *mas;\n\n\t\tmas = v4l2_async_nf_add_fwnode(&priv->notifier, source->fwnode,\n\t\t\t\t\t       struct max9286_asd);\n\t\tif (IS_ERR(mas)) {\n\t\t\tdev_err(dev, \"Failed to add subdev for source %u: %ld\",\n\t\t\t\ti, PTR_ERR(mas));\n\t\t\tv4l2_async_nf_cleanup(&priv->notifier);\n\t\t\treturn PTR_ERR(mas);\n\t\t}\n\n\t\tmas->source = source;\n\t}\n\n\tpriv->notifier.ops = &max9286_notify_ops;\n\n\tret = v4l2_async_nf_register(&priv->notifier);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register subdev_notifier\");\n\t\tv4l2_async_nf_cleanup(&priv->notifier);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void max9286_v4l2_notifier_unregister(struct max9286_priv *priv)\n{\n\tif (!priv->nsources)\n\t\treturn;\n\n\tv4l2_async_nf_unregister(&priv->notifier);\n\tv4l2_async_nf_cleanup(&priv->notifier);\n}\n\nstatic int max9286_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct max9286_priv *priv = sd_to_max9286(sd);\n\tstruct max9286_source *source;\n\tunsigned int i;\n\tbool sync = false;\n\tint ret;\n\n\tif (enable) {\n\t\tconst struct v4l2_mbus_framefmt *format;\n\n\t\t \n\t\tformat = &priv->fmt[__ffs(priv->bound_sources)];\n\n\t\tmax9286_set_video_format(priv, format);\n\t\tmax9286_set_fsync_period(priv);\n\n\t\t \n\t\tmax9286_i2c_mux_open(priv);\n\n\t\t \n\t\tfor_each_source(priv, source) {\n\t\t\tret = v4l2_subdev_call(source->sd, video, s_stream, 1);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = max9286_check_video_links(priv);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tfor (i = 0; i < 40; i++) {\n\t\t\tif (max9286_read(priv, 0x31) & MAX9286_FSYNC_LOCKED) {\n\t\t\t\tsync = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tusleep_range(9000, 11000);\n\t\t}\n\n\t\tif (!sync) {\n\t\t\tdev_err(&priv->client->dev,\n\t\t\t\t\"Failed to get frame synchronization\\n\");\n\t\t\treturn -EXDEV;  \n\t\t}\n\n\t\t \n\t\tmax9286_write(priv, 0x15, MAX9286_CSI_IMAGE_TYP | MAX9286_VCTYPE |\n\t\t\t      MAX9286_CSIOUTEN | MAX9286_EN_CCBSYB_CLK_STR |\n\t\t\t      MAX9286_EN_GPI_CCBSYB);\n\t} else {\n\t\tmax9286_write(priv, 0x15, MAX9286_VCTYPE |\n\t\t\t      MAX9286_EN_CCBSYB_CLK_STR |\n\t\t\t      MAX9286_EN_GPI_CCBSYB);\n\n\t\t \n\t\tfor_each_source(priv, source)\n\t\t\tv4l2_subdev_call(source->sd, video, s_stream, 0);\n\n\t\tmax9286_i2c_mux_close(priv);\n\t}\n\n\treturn 0;\n}\n\nstatic int max9286_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_frame_interval *interval)\n{\n\tstruct max9286_priv *priv = sd_to_max9286(sd);\n\n\tif (interval->pad != MAX9286_SRC_PAD)\n\t\treturn -EINVAL;\n\n\tinterval->interval = priv->interval;\n\n\treturn 0;\n}\n\nstatic int max9286_s_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_frame_interval *interval)\n{\n\tstruct max9286_priv *priv = sd_to_max9286(sd);\n\n\tif (interval->pad != MAX9286_SRC_PAD)\n\t\treturn -EINVAL;\n\n\tpriv->interval = interval->interval;\n\n\treturn 0;\n}\n\nstatic int max9286_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index > 0)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_UYVY8_1X16;\n\n\treturn 0;\n}\n\nstatic struct v4l2_mbus_framefmt *\nmax9286_get_pad_format(struct max9286_priv *priv,\n\t\t       struct v4l2_subdev_state *sd_state,\n\t\t       unsigned int pad, u32 which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\treturn v4l2_subdev_get_try_format(&priv->sd, sd_state, pad);\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &priv->fmt[pad];\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic int max9286_set_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *format)\n{\n\tstruct max9286_priv *priv = sd_to_max9286(sd);\n\tstruct v4l2_mbus_framefmt *cfg_fmt;\n\tunsigned int i;\n\n\tif (format->pad == MAX9286_SRC_PAD)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(max9286_formats); ++i) {\n\t\tif (max9286_formats[i].code == format->format.code)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(max9286_formats))\n\t\tformat->format.code = max9286_formats[0].code;\n\n\tcfg_fmt = max9286_get_pad_format(priv, sd_state, format->pad,\n\t\t\t\t\t format->which);\n\tif (!cfg_fmt)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->mutex);\n\t*cfg_fmt = format->format;\n\tmutex_unlock(&priv->mutex);\n\n\treturn 0;\n}\n\nstatic int max9286_get_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *format)\n{\n\tstruct max9286_priv *priv = sd_to_max9286(sd);\n\tstruct v4l2_mbus_framefmt *cfg_fmt;\n\tunsigned int pad = format->pad;\n\n\t \n\tif (pad == MAX9286_SRC_PAD)\n\t\tpad = __ffs(priv->bound_sources);\n\n\tcfg_fmt = max9286_get_pad_format(priv, sd_state, pad, format->which);\n\tif (!cfg_fmt)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->mutex);\n\tformat->format = *cfg_fmt;\n\tmutex_unlock(&priv->mutex);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops max9286_video_ops = {\n\t.s_stream\t= max9286_s_stream,\n\t.g_frame_interval = max9286_g_frame_interval,\n\t.s_frame_interval = max9286_s_frame_interval,\n};\n\nstatic const struct v4l2_subdev_pad_ops max9286_pad_ops = {\n\t.enum_mbus_code = max9286_enum_mbus_code,\n\t.get_fmt\t= max9286_get_fmt,\n\t.set_fmt\t= max9286_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops max9286_subdev_ops = {\n\t.video\t\t= &max9286_video_ops,\n\t.pad\t\t= &max9286_pad_ops,\n};\n\nstatic const struct v4l2_mbus_framefmt max9286_default_format = {\n\t.width\t\t= 1280,\n\t.height\t\t= 800,\n\t.code\t\t= MEDIA_BUS_FMT_UYVY8_1X16,\n\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t.field\t\t= V4L2_FIELD_NONE,\n\t.ycbcr_enc\t= V4L2_YCBCR_ENC_DEFAULT,\n\t.quantization\t= V4L2_QUANTIZATION_DEFAULT,\n\t.xfer_func\t= V4L2_XFER_FUNC_DEFAULT,\n};\n\nstatic void max9286_init_format(struct v4l2_mbus_framefmt *fmt)\n{\n\t*fmt = max9286_default_format;\n}\n\nstatic int max9286_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_mbus_framefmt *format;\n\tunsigned int i;\n\n\tfor (i = 0; i < MAX9286_N_SINKS; i++) {\n\t\tformat = v4l2_subdev_get_try_format(subdev, fh->state, i);\n\t\tmax9286_init_format(format);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_internal_ops max9286_subdev_internal_ops = {\n\t.open = max9286_open,\n};\n\nstatic const struct media_entity_operations max9286_media_ops = {\n\t.link_validate = v4l2_subdev_link_validate\n};\n\nstatic int max9286_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_PIXEL_RATE:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct v4l2_ctrl_ops max9286_ctrl_ops = {\n\t.s_ctrl = max9286_s_ctrl,\n};\n\nstatic int max9286_v4l2_register(struct max9286_priv *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tint ret;\n\tint i;\n\n\t \n\tret = max9286_v4l2_notifier_register(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to register V4L2 async notifiers\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\n\tfor (i = 0; i < MAX9286_N_SINKS; i++)\n\t\tmax9286_init_format(&priv->fmt[i]);\n\n\tv4l2_i2c_subdev_init(&priv->sd, priv->client, &max9286_subdev_ops);\n\tpriv->sd.internal_ops = &max9286_subdev_internal_ops;\n\tpriv->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tv4l2_ctrl_handler_init(&priv->ctrls, 1);\n\tpriv->pixelrate_ctrl = v4l2_ctrl_new_std(&priv->ctrls,\n\t\t\t\t\t\t &max9286_ctrl_ops,\n\t\t\t\t\t\t V4L2_CID_PIXEL_RATE,\n\t\t\t\t\t\t 1, INT_MAX, 1, 50000000);\n\n\tpriv->sd.ctrl_handler = &priv->ctrls;\n\tret = priv->ctrls.error;\n\tif (ret)\n\t\tgoto err_async;\n\n\tpriv->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tpriv->sd.entity.ops = &max9286_media_ops;\n\n\tpriv->pads[MAX9286_SRC_PAD].flags = MEDIA_PAD_FL_SOURCE;\n\tfor (i = 0; i < MAX9286_SRC_PAD; i++)\n\t\tpriv->pads[i].flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&priv->sd.entity, MAX9286_N_PADS,\n\t\t\t\t     priv->pads);\n\tif (ret)\n\t\tgoto err_async;\n\n\tret = v4l2_async_register_subdev(&priv->sd);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Unable to register subdevice\\n\");\n\t\tgoto err_async;\n\t}\n\n\treturn 0;\n\nerr_async:\n\tv4l2_ctrl_handler_free(&priv->ctrls);\n\tmax9286_v4l2_notifier_unregister(priv);\n\n\treturn ret;\n}\n\nstatic void max9286_v4l2_unregister(struct max9286_priv *priv)\n{\n\tv4l2_ctrl_handler_free(&priv->ctrls);\n\tv4l2_async_unregister_subdev(&priv->sd);\n\tmax9286_v4l2_notifier_unregister(priv);\n}\n\n \n\nstatic int max9286_setup(struct max9286_priv *priv)\n{\n\t \n\tstatic const u8 link_order[] = {\n\t\t(3 << 6) | (2 << 4) | (1 << 2) | (0 << 0),  \n\t\t(3 << 6) | (2 << 4) | (1 << 2) | (0 << 0),  \n\t\t(3 << 6) | (2 << 4) | (0 << 2) | (1 << 0),  \n\t\t(3 << 6) | (2 << 4) | (1 << 2) | (0 << 0),  \n\t\t(3 << 6) | (0 << 4) | (2 << 2) | (1 << 0),  \n\t\t(3 << 6) | (1 << 4) | (2 << 2) | (0 << 0),  \n\t\t(3 << 6) | (1 << 4) | (0 << 2) | (2 << 0),  \n\t\t(3 << 6) | (1 << 4) | (1 << 2) | (0 << 0),  \n\t\t(0 << 6) | (3 << 4) | (2 << 2) | (1 << 0),  \n\t\t(1 << 6) | (3 << 4) | (2 << 2) | (0 << 0),  \n\t\t(1 << 6) | (3 << 4) | (0 << 2) | (2 << 0),  \n\t\t(2 << 6) | (3 << 4) | (1 << 2) | (0 << 0),  \n\t\t(1 << 6) | (0 << 4) | (3 << 2) | (2 << 0),  \n\t\t(2 << 6) | (1 << 4) | (3 << 2) | (0 << 0),  \n\t\t(2 << 6) | (1 << 4) | (0 << 2) | (3 << 0),  \n\t\t(3 << 6) | (2 << 4) | (1 << 2) | (0 << 0),  \n\t};\n\tint cfg;\n\n\t \n\tmax9286_configure_i2c(priv, true);\n\tmax9286_reverse_channel_setup(priv, priv->init_rev_chan_mv);\n\n\t \n\tmax9286_write(priv, 0x00, MAX9286_MSTLINKSEL_AUTO | priv->route_mask);\n\tmax9286_write(priv, 0x0b, link_order[priv->route_mask]);\n\tmax9286_write(priv, 0x69, (0xf & ~priv->route_mask));\n\n\tmax9286_set_video_format(priv, &max9286_default_format);\n\tmax9286_set_fsync_period(priv);\n\n\tcfg = max9286_read(priv, 0x1c);\n\tif (cfg < 0)\n\t\treturn cfg;\n\n\tdev_dbg(&priv->client->dev, \"power-up config: %s immunity, %u-bit bus\\n\",\n\t\tcfg & MAX9286_HIGHIMM(0) ? \"high\" : \"legacy\",\n\t\tcfg & MAX9286_BWS ? 32 : cfg & MAX9286_HIBW ? 27 : 24);\n\n\tif (priv->bus_width) {\n\t\tcfg &= ~(MAX9286_HIBW | MAX9286_BWS);\n\n\t\tif (priv->bus_width == 27)\n\t\t\tcfg |= MAX9286_HIBW;\n\t\telse if (priv->bus_width == 32)\n\t\t\tcfg |= MAX9286_BWS;\n\n\t\tmax9286_write(priv, 0x1c, cfg);\n\t}\n\n\t \n\tmax9286_write(priv, 0x63, 0);\n\tmax9286_write(priv, 0x64, 0);\n\n\t \n\tusleep_range(2000, 5000);\n\n\treturn 0;\n}\n\nstatic int max9286_gpio_set(struct max9286_priv *priv, unsigned int offset,\n\t\t\t    int value)\n{\n\tif (value)\n\t\tpriv->gpio_state |= BIT(offset);\n\telse\n\t\tpriv->gpio_state &= ~BIT(offset);\n\n\treturn max9286_write(priv, 0x0f,\n\t\t\t     MAX9286_0X0F_RESERVED | priv->gpio_state);\n}\n\nstatic void max9286_gpiochip_set(struct gpio_chip *chip,\n\t\t\t\t unsigned int offset, int value)\n{\n\tstruct max9286_priv *priv = gpiochip_get_data(chip);\n\n\tmax9286_gpio_set(priv, offset, value);\n}\n\nstatic int max9286_gpiochip_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct max9286_priv *priv = gpiochip_get_data(chip);\n\n\treturn priv->gpio_state & BIT(offset);\n}\n\nstatic int max9286_register_gpio(struct max9286_priv *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tstruct gpio_chip *gpio = &priv->gpio;\n\tint ret;\n\n\t \n\tgpio->label = dev_name(dev);\n\tgpio->parent = dev;\n\tgpio->owner = THIS_MODULE;\n\tgpio->ngpio = 2;\n\tgpio->base = -1;\n\tgpio->set = max9286_gpiochip_set;\n\tgpio->get = max9286_gpiochip_get;\n\tgpio->can_sleep = true;\n\n\tret = devm_gpiochip_add_data(dev, gpio, priv);\n\tif (ret)\n\t\tdev_err(dev, \"Unable to create gpio_chip\\n\");\n\n\treturn ret;\n}\n\nstatic int max9286_parse_gpios(struct max9286_priv *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tint ret;\n\n\t \n\tret = of_property_read_u32_array(dev->of_node, \"maxim,gpio-poc\",\n\t\t\t\t\t priv->gpio_poc, 2);\n\tif (ret == -EINVAL) {\n\t\t \n\t\treturn max9286_register_gpio(priv);\n\t}\n\n\t \n\tif (ret || priv->gpio_poc[0] > 1 ||\n\t    (priv->gpio_poc[1] != GPIO_ACTIVE_HIGH &&\n\t     priv->gpio_poc[1] != GPIO_ACTIVE_LOW)) {\n\t\tdev_err(dev, \"Invalid 'gpio-poc' property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->use_gpio_poc = true;\n\treturn 0;\n}\n\nstatic int max9286_poc_power_on(struct max9286_priv *priv)\n{\n\tstruct max9286_source *source;\n\tunsigned int enabled = 0;\n\tint ret;\n\n\t \n\tif (priv->regulator)\n\t\treturn regulator_enable(priv->regulator);\n\n\tif (priv->use_gpio_poc)\n\t\treturn max9286_gpio_set(priv, priv->gpio_poc[0],\n\t\t\t\t\t!priv->gpio_poc[1]);\n\n\t \n\tfor_each_source(priv, source) {\n\t\tret = regulator_enable(source->regulator);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tenabled |= BIT(to_index(priv, source));\n\t}\n\n\treturn 0;\n\nerror:\n\tfor_each_source(priv, source) {\n\t\tif (enabled & BIT(to_index(priv, source)))\n\t\t\tregulator_disable(source->regulator);\n\t}\n\n\treturn ret;\n}\n\nstatic int max9286_poc_power_off(struct max9286_priv *priv)\n{\n\tstruct max9286_source *source;\n\tint ret = 0;\n\n\tif (priv->regulator)\n\t\treturn regulator_disable(priv->regulator);\n\n\tif (priv->use_gpio_poc)\n\t\treturn max9286_gpio_set(priv, priv->gpio_poc[0],\n\t\t\t\t\tpriv->gpio_poc[1]);\n\n\tfor_each_source(priv, source) {\n\t\tint err;\n\n\t\terr = regulator_disable(source->regulator);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\n\treturn ret;\n}\n\nstatic int max9286_poc_enable(struct max9286_priv *priv, bool enable)\n{\n\tint ret;\n\n\tif (enable)\n\t\tret = max9286_poc_power_on(priv);\n\telse\n\t\tret = max9286_poc_power_off(priv);\n\n\tif (ret < 0)\n\t\tdev_err(&priv->client->dev, \"Unable to turn power %s\\n\",\n\t\t\tenable ? \"on\" : \"off\");\n\n\treturn ret;\n}\n\nstatic int max9286_init(struct max9286_priv *priv)\n{\n\tstruct i2c_client *client = priv->client;\n\tint ret;\n\n\tret = max9286_poc_enable(priv, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = max9286_setup(priv);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Unable to setup max9286\\n\");\n\t\tgoto err_poc_disable;\n\t}\n\n\t \n\tret = max9286_v4l2_register(priv);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to register with V4L2\\n\");\n\t\tgoto err_poc_disable;\n\t}\n\n\tret = max9286_i2c_mux_init(priv);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Unable to initialize I2C multiplexer\\n\");\n\t\tgoto err_v4l2_register;\n\t}\n\n\t \n\tmax9286_i2c_mux_close(priv);\n\n\treturn 0;\n\nerr_v4l2_register:\n\tmax9286_v4l2_unregister(priv);\nerr_poc_disable:\n\tmax9286_poc_enable(priv, false);\n\n\treturn ret;\n}\n\nstatic void max9286_cleanup_dt(struct max9286_priv *priv)\n{\n\tstruct max9286_source *source;\n\n\tfor_each_source(priv, source) {\n\t\tfwnode_handle_put(source->fwnode);\n\t\tsource->fwnode = NULL;\n\t}\n}\n\nstatic int max9286_parse_dt(struct max9286_priv *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tstruct device_node *i2c_mux;\n\tstruct device_node *node = NULL;\n\tunsigned int i2c_mux_mask = 0;\n\tu32 reverse_channel_microvolt;\n\tu32 i2c_clk_freq = 105000;\n\tunsigned int i;\n\n\t \n\tof_node_get(dev->of_node);\n\ti2c_mux = of_find_node_by_name(dev->of_node, \"i2c-mux\");\n\tif (!i2c_mux) {\n\t\tdev_err(dev, \"Failed to find i2c-mux node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor_each_child_of_node(i2c_mux, node) {\n\t\tu32 id = 0;\n\n\t\tof_property_read_u32(node, \"reg\", &id);\n\t\tif (id >= MAX9286_NUM_GMSL)\n\t\t\tcontinue;\n\n\t\tif (!of_device_is_available(node)) {\n\t\t\tdev_dbg(dev, \"Skipping disabled I2C bus port %u\\n\", id);\n\t\t\tcontinue;\n\t\t}\n\n\t\ti2c_mux_mask |= BIT(id);\n\t}\n\tof_node_put(i2c_mux);\n\n\t \n\tfor_each_endpoint_of_node(dev->of_node, node) {\n\t\tstruct max9286_source *source;\n\t\tstruct of_endpoint ep;\n\n\t\tof_graph_parse_endpoint(node, &ep);\n\t\tdev_dbg(dev, \"Endpoint %pOF on port %d\",\n\t\t\tep.local_node, ep.port);\n\n\t\tif (ep.port > MAX9286_NUM_GMSL) {\n\t\t\tdev_err(dev, \"Invalid endpoint %s on port %d\",\n\t\t\t\tof_node_full_name(ep.local_node), ep.port);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (ep.port == MAX9286_SRC_PAD) {\n\t\t\tstruct v4l2_fwnode_endpoint vep = {\n\t\t\t\t.bus_type = V4L2_MBUS_CSI2_DPHY\n\t\t\t};\n\t\t\tint ret;\n\n\t\t\tret = v4l2_fwnode_endpoint_parse(\n\t\t\t\t\tof_fwnode_handle(node), &vep);\n\t\t\tif (ret) {\n\t\t\t\tof_node_put(node);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tpriv->csi2_data_lanes =\n\t\t\t\tvep.bus.mipi_csi2.num_data_lanes;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!(i2c_mux_mask & BIT(ep.port)))\n\t\t\tcontinue;\n\n\t\tif (priv->sources[ep.port].fwnode) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Multiple port endpoints are not supported: %d\",\n\t\t\t\tep.port);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tsource = &priv->sources[ep.port];\n\t\tsource->fwnode = fwnode_graph_get_remote_endpoint(\n\t\t\t\t\t\tof_fwnode_handle(node));\n\t\tif (!source->fwnode) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Endpoint %pOF has no remote endpoint connection\\n\",\n\t\t\t\tep.local_node);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tpriv->source_mask |= BIT(ep.port);\n\t\tpriv->nsources++;\n\t}\n\n\tof_property_read_u32(dev->of_node, \"maxim,bus-width\", &priv->bus_width);\n\tswitch (priv->bus_width) {\n\tcase 0:\n\t\t \n\tcase 24:\n\tcase 27:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid %s value %u\\n\", \"maxim,bus-width\",\n\t\t\tpriv->bus_width);\n\t\treturn -EINVAL;\n\t}\n\n\tof_property_read_u32(dev->of_node, \"maxim,i2c-remote-bus-hz\",\n\t\t\t     &i2c_clk_freq);\n\tfor (i = 0; i < ARRAY_SIZE(max9286_i2c_speeds); ++i) {\n\t\tconst struct max9286_i2c_speed *speed = &max9286_i2c_speeds[i];\n\n\t\tif (speed->rate == i2c_clk_freq) {\n\t\t\tpriv->i2c_mstbt = speed->mstbt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == ARRAY_SIZE(max9286_i2c_speeds)) {\n\t\tdev_err(dev, \"Invalid %s value %u\\n\", \"maxim,i2c-remote-bus-hz\",\n\t\t\ti2c_clk_freq);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (of_property_read_u32(dev->of_node,\n\t\t\t\t \"maxim,reverse-channel-microvolt\",\n\t\t\t\t &reverse_channel_microvolt))\n\t\tpriv->init_rev_chan_mv = 170;\n\telse\n\t\tpriv->init_rev_chan_mv = reverse_channel_microvolt / 1000U;\n\n\tpriv->route_mask = priv->source_mask;\n\n\treturn 0;\n}\n\nstatic int max9286_get_poc_supplies(struct max9286_priv *priv)\n{\n\tstruct device *dev = &priv->client->dev;\n\tstruct max9286_source *source;\n\tint ret;\n\n\t \n\tpriv->regulator = devm_regulator_get_optional(dev, \"poc\");\n\tif (!IS_ERR(priv->regulator))\n\t\treturn 0;\n\n\tif (PTR_ERR(priv->regulator) != -ENODEV)\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->regulator),\n\t\t\t\t     \"Unable to get PoC regulator\\n\");\n\n\t \n\tdev_dbg(dev,\n\t\t\"No global PoC regulator, looking for per-port regulators\\n\");\n\tpriv->regulator = NULL;\n\n\tfor_each_source(priv, source) {\n\t\tunsigned int index = to_index(priv, source);\n\t\tchar name[10];\n\n\t\tsnprintf(name, sizeof(name), \"port%u-poc\", index);\n\t\tsource->regulator = devm_regulator_get(dev, name);\n\t\tif (IS_ERR(source->regulator)) {\n\t\t\tret = PTR_ERR(source->regulator);\n\t\t\tdev_err_probe(dev, ret,\n\t\t\t\t      \"Unable to get port %u PoC regulator\\n\",\n\t\t\t\t      index);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int max9286_probe(struct i2c_client *client)\n{\n\tstruct max9286_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->mutex);\n\n\tpriv->client = client;\n\n\t \n\tpriv->gpio_state = BIT(0) | BIT(1);\n\n\tret = max9286_parse_dt(priv);\n\tif (ret)\n\t\tgoto err_cleanup_dt;\n\n\tpriv->gpiod_pwdn = devm_gpiod_get_optional(&client->dev, \"enable\",\n\t\t\t\t\t\t   GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->gpiod_pwdn)) {\n\t\tret = PTR_ERR(priv->gpiod_pwdn);\n\t\tgoto err_cleanup_dt;\n\t}\n\n\tgpiod_set_consumer_name(priv->gpiod_pwdn, \"max9286-pwdn\");\n\tgpiod_set_value_cansleep(priv->gpiod_pwdn, 1);\n\n\t \n\tif (priv->gpiod_pwdn)\n\t\tusleep_range(4000, 5000);\n\n\t \n\tmax9286_i2c_mux_close(priv);\n\n\t \n\tmax9286_configure_i2c(priv, false);\n\n\tret = max9286_parse_gpios(priv);\n\tif (ret)\n\t\tgoto err_powerdown;\n\n\tif (!priv->use_gpio_poc) {\n\t\tret = max9286_get_poc_supplies(priv);\n\t\tif (ret)\n\t\t\tgoto err_cleanup_dt;\n\t}\n\n\tret = max9286_init(priv);\n\tif (ret < 0)\n\t\tgoto err_cleanup_dt;\n\n\treturn 0;\n\nerr_powerdown:\n\tgpiod_set_value_cansleep(priv->gpiod_pwdn, 0);\nerr_cleanup_dt:\n\tmax9286_cleanup_dt(priv);\n\n\treturn ret;\n}\n\nstatic void max9286_remove(struct i2c_client *client)\n{\n\tstruct max9286_priv *priv = sd_to_max9286(i2c_get_clientdata(client));\n\n\ti2c_mux_del_adapters(priv->mux);\n\n\tmax9286_v4l2_unregister(priv);\n\n\tmax9286_poc_enable(priv, false);\n\n\tgpiod_set_value_cansleep(priv->gpiod_pwdn, 0);\n\n\tmax9286_cleanup_dt(priv);\n}\n\nstatic const struct of_device_id max9286_dt_ids[] = {\n\t{ .compatible = \"maxim,max9286\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, max9286_dt_ids);\n\nstatic struct i2c_driver max9286_i2c_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"max9286\",\n\t\t.of_match_table\t= max9286_dt_ids,\n\t},\n\t.probe\t\t= max9286_probe,\n\t.remove\t\t= max9286_remove,\n};\n\nmodule_i2c_driver(max9286_i2c_driver);\n\nMODULE_DESCRIPTION(\"Maxim MAX9286 GMSL Deserializer Driver\");\nMODULE_AUTHOR(\"Jacopo Mondi, Kieran Bingham, Laurent Pinchart, Niklas S\u00f6derlund, Vladimir Barinov\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}