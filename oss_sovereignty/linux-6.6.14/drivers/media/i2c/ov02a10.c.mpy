{
  "module_name": "ov02a10.c",
  "hash_id": "40566d5cd4eca70c995239240020161d097bf1d9bf512eaff966d7846f584c92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ov02a10.c",
  "human_readable_source": "\n\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/units.h>\n#include <media/media-entity.h>\n#include <media/v4l2-async.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n#define OV02A10_ID\t\t\t\t\t0x2509\n#define OV02A10_ID_MASK\t\t\t\t\tGENMASK(15, 0)\n\n#define OV02A10_REG_CHIP_ID\t\t\t\t0x02\n\n \n \n#define REG_MIRROR_FLIP_CONTROL\t\t\t\t0x3f\n\n \n#define REG_MIRROR_FLIP_ENABLE\t\t\t\t0x03\n\n \n#define TX_SPEED_AREA_SEL\t\t\t\t0xa1\n#define OV02A10_MIPI_TX_SPEED_DEFAULT\t\t\t0x04\n\n#define REG_PAGE_SWITCH\t\t\t\t\t0xfd\n#define REG_GLOBAL_EFFECTIVE\t\t\t\t0x01\n#define REG_ENABLE\t\t\t\t\tBIT(0)\n\n#define REG_SC_CTRL_MODE\t\t\t\t0xac\n#define SC_CTRL_MODE_STANDBY\t\t\t\t0x00\n#define SC_CTRL_MODE_STREAMING\t\t\t\t0x01\n\n \n#define OV02A10_EXP_SHIFT\t\t\t\t8\n#define OV02A10_REG_EXPOSURE_H\t\t\t\t0x03\n#define OV02A10_REG_EXPOSURE_L\t\t\t\t0x04\n#define\tOV02A10_EXPOSURE_MIN\t\t\t\t4\n#define OV02A10_EXPOSURE_MAX_MARGIN\t\t\t4\n#define\tOV02A10_EXPOSURE_STEP\t\t\t\t1\n\n \n#define OV02A10_VTS_SHIFT\t\t\t\t8\n#define OV02A10_REG_VTS_H\t\t\t\t0x05\n#define OV02A10_REG_VTS_L\t\t\t\t0x06\n#define OV02A10_VTS_MAX\t\t\t\t\t0x209f\n#define OV02A10_BASE_LINES\t\t\t\t1224\n\n \n#define OV02A10_REG_GAIN\t\t\t\t0x24\n#define OV02A10_GAIN_MIN\t\t\t\t0x10\n#define OV02A10_GAIN_MAX\t\t\t\t0xf8\n#define OV02A10_GAIN_STEP\t\t\t\t0x01\n#define OV02A10_GAIN_DEFAULT\t\t\t\t0x40\n\n \n#define OV02A10_REG_TEST_PATTERN\t\t\t0xb6\n\n#define OV02A10_LINK_FREQ_390MHZ\t\t\t(390 * HZ_PER_MHZ)\n#define OV02A10_ECLK_FREQ\t\t\t\t(24 * HZ_PER_MHZ)\n\n \n#define OV02A10_DATA_LANES\t\t\t\t1\n\n \n#define OV02A10_BITS_PER_SAMPLE\t\t\t\t10\n\nstatic const char * const ov02a10_supply_names[] = {\n\t\"dovdd\",\t \n\t\"avdd\",\t\t \n\t\"dvdd\",\t\t \n};\n\nstruct ov02a10_reg {\n\tu8 addr;\n\tu8 val;\n};\n\nstruct ov02a10_reg_list {\n\tu32 num_of_regs;\n\tconst struct ov02a10_reg *regs;\n};\n\nstruct ov02a10_mode {\n\tu32 width;\n\tu32 height;\n\tu32 exp_def;\n\tu32 hts_def;\n\tu32 vts_def;\n\tconst struct ov02a10_reg_list reg_list;\n};\n\nstruct ov02a10 {\n\tu32 eclk_freq;\n\t \n\tu32 mipi_clock_voltage;\n\n\tstruct clk *eclk;\n\tstruct gpio_desc *pd_gpio;\n\tstruct gpio_desc *rst_gpio;\n\tstruct regulator_bulk_data supplies[ARRAY_SIZE(ov02a10_supply_names)];\n\n\tbool streaming;\n\tbool upside_down;\n\n\t \n\tstruct mutex mutex;\n\tstruct v4l2_subdev subdev;\n\tstruct media_pad pad;\n\tstruct v4l2_mbus_framefmt fmt;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tstruct v4l2_ctrl *exposure;\n\n\tconst struct ov02a10_mode *cur_mode;\n};\n\nstatic inline struct ov02a10 *to_ov02a10(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct ov02a10, subdev);\n}\n\n \nstatic const struct ov02a10_reg ov02a10_1600x1200_regs[] = {\n\t{0xfd, 0x01},\n\t{0xac, 0x00},\n\t{0xfd, 0x00},\n\t{0x2f, 0x29},\n\t{0x34, 0x00},\n\t{0x35, 0x21},\n\t{0x30, 0x15},\n\t{0x33, 0x01},\n\t{0xfd, 0x01},\n\t{0x44, 0x00},\n\t{0x2a, 0x4c},\n\t{0x2b, 0x1e},\n\t{0x2c, 0x60},\n\t{0x25, 0x11},\n\t{0x03, 0x01},\n\t{0x04, 0xae},\n\t{0x09, 0x00},\n\t{0x0a, 0x02},\n\t{0x06, 0xa6},\n\t{0x31, 0x00},\n\t{0x24, 0x40},\n\t{0x01, 0x01},\n\t{0xfb, 0x73},\n\t{0xfd, 0x01},\n\t{0x16, 0x04},\n\t{0x1c, 0x09},\n\t{0x21, 0x42},\n\t{0x12, 0x04},\n\t{0x13, 0x10},\n\t{0x11, 0x40},\n\t{0x33, 0x81},\n\t{0xd0, 0x00},\n\t{0xd1, 0x01},\n\t{0xd2, 0x00},\n\t{0x50, 0x10},\n\t{0x51, 0x23},\n\t{0x52, 0x20},\n\t{0x53, 0x10},\n\t{0x54, 0x02},\n\t{0x55, 0x20},\n\t{0x56, 0x02},\n\t{0x58, 0x48},\n\t{0x5d, 0x15},\n\t{0x5e, 0x05},\n\t{0x66, 0x66},\n\t{0x68, 0x68},\n\t{0x6b, 0x00},\n\t{0x6c, 0x00},\n\t{0x6f, 0x40},\n\t{0x70, 0x40},\n\t{0x71, 0x0a},\n\t{0x72, 0xf0},\n\t{0x73, 0x10},\n\t{0x75, 0x80},\n\t{0x76, 0x10},\n\t{0x84, 0x00},\n\t{0x85, 0x10},\n\t{0x86, 0x10},\n\t{0x87, 0x00},\n\t{0x8a, 0x22},\n\t{0x8b, 0x22},\n\t{0x19, 0xf1},\n\t{0x29, 0x01},\n\t{0xfd, 0x01},\n\t{0x9d, 0x16},\n\t{0xa0, 0x29},\n\t{0xa1, 0x04},\n\t{0xad, 0x62},\n\t{0xae, 0x00},\n\t{0xaf, 0x85},\n\t{0xb1, 0x01},\n\t{0x8e, 0x06},\n\t{0x8f, 0x40},\n\t{0x90, 0x04},\n\t{0x91, 0xb0},\n\t{0x45, 0x01},\n\t{0x46, 0x00},\n\t{0x47, 0x6c},\n\t{0x48, 0x03},\n\t{0x49, 0x8b},\n\t{0x4a, 0x00},\n\t{0x4b, 0x07},\n\t{0x4c, 0x04},\n\t{0x4d, 0xb7},\n\t{0xf0, 0x40},\n\t{0xf1, 0x40},\n\t{0xf2, 0x40},\n\t{0xf3, 0x40},\n\t{0x3f, 0x00},\n\t{0xfd, 0x01},\n\t{0x05, 0x00},\n\t{0x06, 0xa6},\n\t{0xfd, 0x01},\n};\n\nstatic const char * const ov02a10_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Eight Vertical Colour Bars\",\n};\n\nstatic const s64 link_freq_menu_items[] = {\n\tOV02A10_LINK_FREQ_390MHZ,\n};\n\nstatic u64 to_pixel_rate(u32 f_index)\n{\n\tu64 pixel_rate = link_freq_menu_items[f_index] * 2 * OV02A10_DATA_LANES;\n\n\tdo_div(pixel_rate, OV02A10_BITS_PER_SAMPLE);\n\n\treturn pixel_rate;\n}\n\nstatic const struct ov02a10_mode supported_modes[] = {\n\t{\n\t\t.width = 1600,\n\t\t.height = 1200,\n\t\t.exp_def = 0x01ae,\n\t\t.hts_def = 0x03a6,\n\t\t.vts_def = 0x056e,\n\t\t.reg_list = {\n\t\t\t.num_of_regs = ARRAY_SIZE(ov02a10_1600x1200_regs),\n\t\t\t.regs = ov02a10_1600x1200_regs,\n\t\t},\n\t},\n};\n\nstatic int ov02a10_write_array(struct ov02a10 *ov02a10,\n\t\t\t       const struct ov02a10_reg_list *r_list)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&ov02a10->subdev);\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < r_list->num_of_regs; i++) {\n\t\tret = i2c_smbus_write_byte_data(client, r_list->regs[i].addr,\n\t\t\t\t\t\tr_list->regs[i].val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ov02a10_fill_fmt(const struct ov02a10_mode *mode,\n\t\t\t     struct v4l2_mbus_framefmt *fmt)\n{\n\tfmt->width = mode->width;\n\tfmt->height = mode->height;\n\tfmt->field = V4L2_FIELD_NONE;\n}\n\nstatic int ov02a10_set_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct ov02a10 *ov02a10 = to_ov02a10(sd);\n\tstruct v4l2_mbus_framefmt *mbus_fmt = &fmt->format;\n\tstruct v4l2_mbus_framefmt *frame_fmt;\n\tint ret = 0;\n\n\tmutex_lock(&ov02a10->mutex);\n\n\tif (ov02a10->streaming && fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tmbus_fmt->code = ov02a10->fmt.code;\n\tov02a10_fill_fmt(ov02a10->cur_mode, mbus_fmt);\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\tframe_fmt = v4l2_subdev_get_try_format(sd, sd_state, 0);\n\telse\n\t\tframe_fmt = &ov02a10->fmt;\n\n\t*frame_fmt = *mbus_fmt;\n\nout_unlock:\n\tmutex_unlock(&ov02a10->mutex);\n\treturn ret;\n}\n\nstatic int ov02a10_get_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct ov02a10 *ov02a10 = to_ov02a10(sd);\n\tstruct v4l2_mbus_framefmt *mbus_fmt = &fmt->format;\n\n\tmutex_lock(&ov02a10->mutex);\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tfmt->format = *v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t\t\t  fmt->pad);\n\t} else {\n\t\tfmt->format = ov02a10->fmt;\n\t\tmbus_fmt->code = ov02a10->fmt.code;\n\t\tov02a10_fill_fmt(ov02a10->cur_mode, mbus_fmt);\n\t}\n\n\tmutex_unlock(&ov02a10->mutex);\n\n\treturn 0;\n}\n\nstatic int ov02a10_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct ov02a10 *ov02a10 = to_ov02a10(sd);\n\n\tif (code->index != 0)\n\t\treturn -EINVAL;\n\n\tcode->code = ov02a10->fmt.code;\n\n\treturn 0;\n}\n\nstatic int ov02a10_enum_frame_sizes(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_subdev_frame_size_enum *fse)\n{\n\tif (fse->index >= ARRAY_SIZE(supported_modes))\n\t\treturn -EINVAL;\n\n\tfse->min_width  = supported_modes[fse->index].width;\n\tfse->max_width  = supported_modes[fse->index].width;\n\tfse->max_height = supported_modes[fse->index].height;\n\tfse->min_height = supported_modes[fse->index].height;\n\n\treturn 0;\n}\n\nstatic int ov02a10_check_sensor_id(struct ov02a10 *ov02a10)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&ov02a10->subdev);\n\tu16 chip_id;\n\tint ret;\n\n\t \n\tret = i2c_smbus_read_word_swapped(client, OV02A10_REG_CHIP_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tchip_id = le16_to_cpu((__force __le16)ret);\n\n\tif ((chip_id & OV02A10_ID_MASK) != OV02A10_ID) {\n\t\tdev_err(&client->dev, \"unexpected sensor id(0x%04x)\\n\", chip_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov02a10_power_on(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov02a10 *ov02a10 = to_ov02a10(sd);\n\tint ret;\n\n\tgpiod_set_value_cansleep(ov02a10->rst_gpio, 1);\n\tgpiod_set_value_cansleep(ov02a10->pd_gpio, 1);\n\n\tret = clk_prepare_enable(ov02a10->eclk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable eclk\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(ov02a10_supply_names),\n\t\t\t\t    ov02a10->supplies);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable regulators\\n\");\n\t\tgoto disable_clk;\n\t}\n\tusleep_range(5000, 6000);\n\n\tgpiod_set_value_cansleep(ov02a10->pd_gpio, 0);\n\tusleep_range(5000, 6000);\n\n\tgpiod_set_value_cansleep(ov02a10->rst_gpio, 0);\n\tusleep_range(5000, 6000);\n\n\tret = ov02a10_check_sensor_id(ov02a10);\n\tif (ret)\n\t\tgoto disable_regulator;\n\n\treturn 0;\n\ndisable_regulator:\n\tregulator_bulk_disable(ARRAY_SIZE(ov02a10_supply_names),\n\t\t\t       ov02a10->supplies);\ndisable_clk:\n\tclk_disable_unprepare(ov02a10->eclk);\n\n\treturn ret;\n}\n\nstatic int ov02a10_power_off(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov02a10 *ov02a10 = to_ov02a10(sd);\n\n\tgpiod_set_value_cansleep(ov02a10->rst_gpio, 1);\n\tclk_disable_unprepare(ov02a10->eclk);\n\tgpiod_set_value_cansleep(ov02a10->pd_gpio, 1);\n\tregulator_bulk_disable(ARRAY_SIZE(ov02a10_supply_names),\n\t\t\t       ov02a10->supplies);\n\n\treturn 0;\n}\n\nstatic int __ov02a10_start_stream(struct ov02a10 *ov02a10)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&ov02a10->subdev);\n\tconst struct ov02a10_reg_list *reg_list;\n\tint ret;\n\n\t \n\treg_list = &ov02a10->cur_mode->reg_list;\n\tret = ov02a10_write_array(ov02a10, reg_list);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = __v4l2_ctrl_handler_setup(ov02a10->subdev.ctrl_handler);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ov02a10->upside_down) {\n\t\tret = i2c_smbus_write_byte_data(client, REG_MIRROR_FLIP_CONTROL,\n\t\t\t\t\t\tREG_MIRROR_FLIP_ENABLE);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"failed to set orientation\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tret = i2c_smbus_write_byte_data(client, REG_GLOBAL_EFFECTIVE,\n\t\t\t\t\t\tREG_ENABLE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (ov02a10->mipi_clock_voltage != OV02A10_MIPI_TX_SPEED_DEFAULT) {\n\t\tret = i2c_smbus_write_byte_data(client, TX_SPEED_AREA_SEL,\n\t\t\t\t\t\tov02a10->mipi_clock_voltage);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\treturn i2c_smbus_write_byte_data(client, REG_SC_CTRL_MODE,\n\t\t\t\t\t SC_CTRL_MODE_STREAMING);\n}\n\nstatic int __ov02a10_stop_stream(struct ov02a10 *ov02a10)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&ov02a10->subdev);\n\n\treturn i2c_smbus_write_byte_data(client, REG_SC_CTRL_MODE,\n\t\t\t\t\t SC_CTRL_MODE_STANDBY);\n}\n\nstatic int ov02a10_entity_init_cfg(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state)\n{\n\tstruct v4l2_subdev_format fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_TRY,\n\t\t.format = {\n\t\t\t.width = 1600,\n\t\t\t.height = 1200,\n\t\t}\n\t};\n\n\tov02a10_set_fmt(sd, sd_state, &fmt);\n\n\treturn 0;\n}\n\nstatic int ov02a10_s_stream(struct v4l2_subdev *sd, int on)\n{\n\tstruct ov02a10 *ov02a10 = to_ov02a10(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(&ov02a10->subdev);\n\tint ret;\n\n\tmutex_lock(&ov02a10->mutex);\n\n\tif (ov02a10->streaming == on) {\n\t\tret = 0;\n\t\tgoto unlock_and_return;\n\t}\n\n\tif (on) {\n\t\tret = pm_runtime_resume_and_get(&client->dev);\n\t\tif (ret < 0)\n\t\t\tgoto unlock_and_return;\n\n\t\tret = __ov02a10_start_stream(ov02a10);\n\t\tif (ret) {\n\t\t\t__ov02a10_stop_stream(ov02a10);\n\t\t\tov02a10->streaming = !on;\n\t\t\tgoto err_rpm_put;\n\t\t}\n\t} else {\n\t\t__ov02a10_stop_stream(ov02a10);\n\t\tpm_runtime_put(&client->dev);\n\t}\n\n\tov02a10->streaming = on;\n\tmutex_unlock(&ov02a10->mutex);\n\n\treturn 0;\n\nerr_rpm_put:\n\tpm_runtime_put(&client->dev);\nunlock_and_return:\n\tmutex_unlock(&ov02a10->mutex);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops ov02a10_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(ov02a10_power_off, ov02a10_power_on, NULL)\n};\n\nstatic int ov02a10_set_exposure(struct ov02a10 *ov02a10, int val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&ov02a10->subdev);\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, REG_PAGE_SWITCH, REG_ENABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(client, OV02A10_REG_EXPOSURE_H,\n\t\t\t\t\tval >> OV02A10_EXP_SHIFT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(client, OV02A10_REG_EXPOSURE_L, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn i2c_smbus_write_byte_data(client, REG_GLOBAL_EFFECTIVE,\n\t\t\t\t\t REG_ENABLE);\n}\n\nstatic int ov02a10_set_gain(struct ov02a10 *ov02a10, int val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&ov02a10->subdev);\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, REG_PAGE_SWITCH, REG_ENABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(client, OV02A10_REG_GAIN, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn i2c_smbus_write_byte_data(client, REG_GLOBAL_EFFECTIVE,\n\t\t\t\t\t REG_ENABLE);\n}\n\nstatic int ov02a10_set_vblank(struct ov02a10 *ov02a10, int val)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&ov02a10->subdev);\n\tu32 vts = val + ov02a10->cur_mode->height - OV02A10_BASE_LINES;\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, REG_PAGE_SWITCH, REG_ENABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(client, OV02A10_REG_VTS_H,\n\t\t\t\t\tvts >> OV02A10_VTS_SHIFT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(client, OV02A10_REG_VTS_L, vts);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn i2c_smbus_write_byte_data(client, REG_GLOBAL_EFFECTIVE,\n\t\t\t\t\t REG_ENABLE);\n}\n\nstatic int ov02a10_set_test_pattern(struct ov02a10 *ov02a10, int pattern)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&ov02a10->subdev);\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, REG_PAGE_SWITCH, REG_ENABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(client, OV02A10_REG_TEST_PATTERN,\n\t\t\t\t\tpattern);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_byte_data(client, REG_GLOBAL_EFFECTIVE,\n\t\t\t\t\tREG_ENABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn i2c_smbus_write_byte_data(client, REG_SC_CTRL_MODE,\n\t\t\t\t\t SC_CTRL_MODE_STREAMING);\n}\n\nstatic int ov02a10_set_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ov02a10 *ov02a10 = container_of(ctrl->handler,\n\t\t\t\t\t       struct ov02a10, ctrl_handler);\n\tstruct i2c_client *client = v4l2_get_subdevdata(&ov02a10->subdev);\n\ts64 max_expo;\n\tint ret;\n\n\t \n\tif (ctrl->id == V4L2_CID_VBLANK) {\n\t\t \n\t\tmax_expo = ov02a10->cur_mode->height + ctrl->val -\n\t\t\t   OV02A10_EXPOSURE_MAX_MARGIN;\n\t\t__v4l2_ctrl_modify_range(ov02a10->exposure,\n\t\t\t\t\t ov02a10->exposure->minimum, max_expo,\n\t\t\t\t\t ov02a10->exposure->step,\n\t\t\t\t\t ov02a10->exposure->default_value);\n\t}\n\n\t \n\tif (!pm_runtime_get_if_in_use(&client->dev))\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE:\n\t\tret = ov02a10_set_exposure(ov02a10, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_ANALOGUE_GAIN:\n\t\tret = ov02a10_set_gain(ov02a10, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_VBLANK:\n\t\tret = ov02a10_set_vblank(ov02a10, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tret = ov02a10_set_test_pattern(ov02a10, ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tpm_runtime_put(&client->dev);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_video_ops ov02a10_video_ops = {\n\t.s_stream = ov02a10_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops ov02a10_pad_ops = {\n\t.init_cfg = ov02a10_entity_init_cfg,\n\t.enum_mbus_code = ov02a10_enum_mbus_code,\n\t.enum_frame_size = ov02a10_enum_frame_sizes,\n\t.get_fmt = ov02a10_get_fmt,\n\t.set_fmt = ov02a10_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops ov02a10_subdev_ops = {\n\t.video\t= &ov02a10_video_ops,\n\t.pad\t= &ov02a10_pad_ops,\n};\n\nstatic const struct media_entity_operations ov02a10_subdev_entity_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic const struct v4l2_ctrl_ops ov02a10_ctrl_ops = {\n\t.s_ctrl = ov02a10_set_ctrl,\n};\n\nstatic int ov02a10_initialize_controls(struct ov02a10 *ov02a10)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&ov02a10->subdev);\n\tconst struct ov02a10_mode *mode;\n\tstruct v4l2_ctrl_handler *handler;\n\tstruct v4l2_ctrl *ctrl;\n\ts64 exposure_max;\n\ts64 vblank_def;\n\ts64 pixel_rate;\n\ts64 h_blank;\n\tint ret;\n\n\thandler = &ov02a10->ctrl_handler;\n\tmode = ov02a10->cur_mode;\n\tret = v4l2_ctrl_handler_init(handler, 7);\n\tif (ret)\n\t\treturn ret;\n\n\thandler->lock = &ov02a10->mutex;\n\n\tctrl = v4l2_ctrl_new_int_menu(handler, NULL, V4L2_CID_LINK_FREQ, 0, 0,\n\t\t\t\t      link_freq_menu_items);\n\tif (ctrl)\n\t\tctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tpixel_rate = to_pixel_rate(0);\n\tv4l2_ctrl_new_std(handler, NULL, V4L2_CID_PIXEL_RATE, 0, pixel_rate, 1,\n\t\t\t  pixel_rate);\n\n\th_blank = mode->hts_def - mode->width;\n\tv4l2_ctrl_new_std(handler, NULL, V4L2_CID_HBLANK, h_blank, h_blank, 1,\n\t\t\t  h_blank);\n\n\tvblank_def = mode->vts_def - mode->height;\n\tv4l2_ctrl_new_std(handler, &ov02a10_ctrl_ops, V4L2_CID_VBLANK,\n\t\t\t  vblank_def, OV02A10_VTS_MAX - mode->height, 1,\n\t\t\t  vblank_def);\n\n\texposure_max = mode->vts_def - 4;\n\tov02a10->exposure = v4l2_ctrl_new_std(handler, &ov02a10_ctrl_ops,\n\t\t\t\t\t      V4L2_CID_EXPOSURE,\n\t\t\t\t\t      OV02A10_EXPOSURE_MIN,\n\t\t\t\t\t      exposure_max,\n\t\t\t\t\t      OV02A10_EXPOSURE_STEP,\n\t\t\t\t\t      mode->exp_def);\n\n\tv4l2_ctrl_new_std(handler, &ov02a10_ctrl_ops,\n\t\t\t  V4L2_CID_ANALOGUE_GAIN, OV02A10_GAIN_MIN,\n\t\t\t  OV02A10_GAIN_MAX, OV02A10_GAIN_STEP,\n\t\t\t  OV02A10_GAIN_DEFAULT);\n\n\tv4l2_ctrl_new_std_menu_items(handler, &ov02a10_ctrl_ops,\n\t\t\t\t     V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(ov02a10_test_pattern_menu) - 1,\n\t\t\t\t     0, 0, ov02a10_test_pattern_menu);\n\n\tif (handler->error) {\n\t\tret = handler->error;\n\t\tdev_err(&client->dev, \"failed to init controls(%d)\\n\", ret);\n\t\tgoto err_free_handler;\n\t}\n\n\tov02a10->subdev.ctrl_handler = handler;\n\n\treturn 0;\n\nerr_free_handler:\n\tv4l2_ctrl_handler_free(handler);\n\n\treturn ret;\n}\n\nstatic int ov02a10_check_hwcfg(struct device *dev, struct ov02a10 *ov02a10)\n{\n\tstruct fwnode_handle *ep;\n\tstruct fwnode_handle *fwnode = dev_fwnode(dev);\n\tstruct v4l2_fwnode_endpoint bus_cfg = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY,\n\t};\n\tunsigned int i, j;\n\tu32 clk_volt;\n\tint ret;\n\n\tif (!fwnode)\n\t\treturn -EINVAL;\n\n\tep = fwnode_graph_get_next_endpoint(fwnode, NULL);\n\tif (!ep)\n\t\treturn -ENXIO;\n\n\tret = v4l2_fwnode_endpoint_alloc_parse(ep, &bus_cfg);\n\tfwnode_handle_put(ep);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = fwnode_property_read_u32(ep, \"ovti,mipi-clock-voltage\",\n\t\t\t\t       &clk_volt);\n\n\tif (!ret)\n\t\tov02a10->mipi_clock_voltage = clk_volt;\n\n\tfor (i = 0; i < ARRAY_SIZE(link_freq_menu_items); i++) {\n\t\tfor (j = 0; j < bus_cfg.nr_of_link_frequencies; j++) {\n\t\t\tif (link_freq_menu_items[i] ==\n\t\t\t\tbus_cfg.link_frequencies[j])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j == bus_cfg.nr_of_link_frequencies) {\n\t\t\tdev_err(dev, \"no link frequency %lld supported\\n\",\n\t\t\t\tlink_freq_menu_items[i]);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tv4l2_fwnode_endpoint_free(&bus_cfg);\n\n\treturn ret;\n}\n\nstatic int ov02a10_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct ov02a10 *ov02a10;\n\tunsigned int i;\n\tunsigned int rotation;\n\tint ret;\n\n\tov02a10 = devm_kzalloc(dev, sizeof(*ov02a10), GFP_KERNEL);\n\tif (!ov02a10)\n\t\treturn -ENOMEM;\n\n\tret = ov02a10_check_hwcfg(dev, ov02a10);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"failed to check HW configuration\\n\");\n\n\tv4l2_i2c_subdev_init(&ov02a10->subdev, client, &ov02a10_subdev_ops);\n\n\tov02a10->mipi_clock_voltage = OV02A10_MIPI_TX_SPEED_DEFAULT;\n\tov02a10->fmt.code = MEDIA_BUS_FMT_SBGGR10_1X10;\n\n\t \n\trotation = 0;\n\tdevice_property_read_u32(dev, \"rotation\", &rotation);\n\tif (rotation == 180) {\n\t\tov02a10->upside_down = true;\n\t\tov02a10->fmt.code = MEDIA_BUS_FMT_SRGGB10_1X10;\n\t}\n\n\tov02a10->eclk = devm_clk_get(dev, \"eclk\");\n\tif (IS_ERR(ov02a10->eclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(ov02a10->eclk),\n\t\t\t\t     \"failed to get eclk\\n\");\n\n\tret = device_property_read_u32(dev, \"clock-frequency\",\n\t\t\t\t       &ov02a10->eclk_freq);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"failed to get eclk frequency\\n\");\n\n\tret = clk_set_rate(ov02a10->eclk, ov02a10->eclk_freq);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"failed to set eclk frequency (24MHz)\\n\");\n\n\tif (clk_get_rate(ov02a10->eclk) != OV02A10_ECLK_FREQ)\n\t\tdev_warn(dev, \"eclk mismatched, mode is based on 24MHz\\n\");\n\n\tov02a10->pd_gpio = devm_gpiod_get(dev, \"powerdown\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ov02a10->pd_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(ov02a10->pd_gpio),\n\t\t\t\t     \"failed to get powerdown-gpios\\n\");\n\n\tov02a10->rst_gpio = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ov02a10->rst_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(ov02a10->rst_gpio),\n\t\t\t\t     \"failed to get reset-gpios\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(ov02a10_supply_names); i++)\n\t\tov02a10->supplies[i].supply = ov02a10_supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ov02a10_supply_names),\n\t\t\t\t      ov02a10->supplies);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to get regulators\\n\");\n\n\tmutex_init(&ov02a10->mutex);\n\n\t \n\tov02a10->cur_mode = &supported_modes[0];\n\n\tret = ov02a10_initialize_controls(ov02a10);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"failed to initialize controls\\n\");\n\t\tgoto err_destroy_mutex;\n\t}\n\n\t \n\tov02a10->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tov02a10->subdev.entity.ops = &ov02a10_subdev_entity_ops;\n\tov02a10->subdev.entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tov02a10->pad.flags = MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&ov02a10->subdev.entity, 1, &ov02a10->pad);\n\tif (ret < 0) {\n\t\tdev_err_probe(dev, ret, \"failed to initialize entity pads\\n\");\n\t\tgoto err_free_handler;\n\t}\n\n\tpm_runtime_enable(dev);\n\tif (!pm_runtime_enabled(dev)) {\n\t\tret = ov02a10_power_on(dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err_probe(dev, ret, \"failed to power on\\n\");\n\t\t\tgoto err_clean_entity;\n\t\t}\n\t}\n\n\tret = v4l2_async_register_subdev(&ov02a10->subdev);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"failed to register V4L2 subdev\\n\");\n\t\tgoto err_power_off;\n\t}\n\n\treturn 0;\n\nerr_power_off:\n\tif (pm_runtime_enabled(dev))\n\t\tpm_runtime_disable(dev);\n\telse\n\t\tov02a10_power_off(dev);\nerr_clean_entity:\n\tmedia_entity_cleanup(&ov02a10->subdev.entity);\nerr_free_handler:\n\tv4l2_ctrl_handler_free(ov02a10->subdev.ctrl_handler);\nerr_destroy_mutex:\n\tmutex_destroy(&ov02a10->mutex);\n\n\treturn ret;\n}\n\nstatic void ov02a10_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct ov02a10 *ov02a10 = to_ov02a10(sd);\n\n\tv4l2_async_unregister_subdev(sd);\n\tmedia_entity_cleanup(&sd->entity);\n\tv4l2_ctrl_handler_free(sd->ctrl_handler);\n\tpm_runtime_disable(&client->dev);\n\tif (!pm_runtime_status_suspended(&client->dev))\n\t\tov02a10_power_off(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\tmutex_destroy(&ov02a10->mutex);\n}\n\nstatic const struct of_device_id ov02a10_of_match[] = {\n\t{ .compatible = \"ovti,ov02a10\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ov02a10_of_match);\n\nstatic struct i2c_driver ov02a10_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ov02a10\",\n\t\t.pm = &ov02a10_pm_ops,\n\t\t.of_match_table = ov02a10_of_match,\n\t},\n\t.probe\t\t= ov02a10_probe,\n\t.remove\t\t= ov02a10_remove,\n};\nmodule_i2c_driver(ov02a10_i2c_driver);\n\nMODULE_AUTHOR(\"Dongchun Zhu <dongchun.zhu@mediatek.com>\");\nMODULE_DESCRIPTION(\"OmniVision OV02A10 sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}