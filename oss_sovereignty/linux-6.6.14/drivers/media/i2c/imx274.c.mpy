{
  "module_name": "imx274.c",
  "hash_id": "c549138541d9cd2a8a94323bf1948a82c5361e952a11dd94842ae792d0103c37",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/imx274.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/v4l2-mediabus.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n \n#define IMX274_DEFAULT_FRAME_LENGTH\t\t(4550)\n#define IMX274_MAX_FRAME_LENGTH\t\t\t(0x000fffff)\n\n \n#define IMX274_PIXCLK_CONST1\t\t\t(72000000)\n#define IMX274_PIXCLK_CONST2\t\t\t(1000000)\n\n \n#define IMX274_GAIN_SHIFT\t\t\t(8)\n#define IMX274_GAIN_SHIFT_MASK\t\t\t((1 << IMX274_GAIN_SHIFT) - 1)\n\n \n#define IMX274_GAIN_REG_MAX\t\t\t(1957)\n#define IMX274_MIN_GAIN\t\t\t\t(0x01 << IMX274_GAIN_SHIFT)\n#define IMX274_MAX_ANALOG_GAIN\t\t\t((2048 << IMX274_GAIN_SHIFT)\\\n\t\t\t\t\t/ (2048 - IMX274_GAIN_REG_MAX))\n#define IMX274_MAX_DIGITAL_GAIN\t\t\t(8)\n#define IMX274_DEF_GAIN\t\t\t\t(20 << IMX274_GAIN_SHIFT)\n#define IMX274_GAIN_CONST\t\t\t(2048)  \n\n \n#define IMX274_MIN_EXPOSURE_TIME\t\t(4 * 260 / 72)\n\n#define IMX274_MAX_WIDTH\t\t\t(3840)\n#define IMX274_MAX_HEIGHT\t\t\t(2160)\n#define IMX274_MAX_FRAME_RATE\t\t\t(120)\n#define IMX274_MIN_FRAME_RATE\t\t\t(5)\n#define IMX274_DEF_FRAME_RATE\t\t\t(60)\n\n \n#define IMX274_SHR_LIMIT_CONST\t\t\t(4)\n\n \n#define IMX274_RESET_DELAY1\t\t\t(2000)\n#define IMX274_RESET_DELAY2\t\t\t(2200)\n\n \n#define IMX274_SHIFT_8_BITS\t\t\t(8)\n#define IMX274_SHIFT_16_BITS\t\t\t(16)\n#define IMX274_MASK_LSB_2_BITS\t\t\t(0x03)\n#define IMX274_MASK_LSB_3_BITS\t\t\t(0x07)\n#define IMX274_MASK_LSB_4_BITS\t\t\t(0x0f)\n#define IMX274_MASK_LSB_8_BITS\t\t\t(0x00ff)\n\n#define DRIVER_NAME \"IMX274\"\n\n \n#define IMX274_SHR_REG_MSB\t\t\t0x300D  \n#define IMX274_SHR_REG_LSB\t\t\t0x300C  \n#define IMX274_SVR_REG_MSB\t\t\t0x300F  \n#define IMX274_SVR_REG_LSB\t\t\t0x300E  \n#define IMX274_HTRIM_EN_REG\t\t\t0x3037\n#define IMX274_HTRIM_START_REG_LSB\t\t0x3038\n#define IMX274_HTRIM_START_REG_MSB\t\t0x3039\n#define IMX274_HTRIM_END_REG_LSB\t\t0x303A\n#define IMX274_HTRIM_END_REG_MSB\t\t0x303B\n#define IMX274_VWIDCUTEN_REG\t\t\t0x30DD\n#define IMX274_VWIDCUT_REG_LSB\t\t\t0x30DE\n#define IMX274_VWIDCUT_REG_MSB\t\t\t0x30DF\n#define IMX274_VWINPOS_REG_LSB\t\t\t0x30E0\n#define IMX274_VWINPOS_REG_MSB\t\t\t0x30E1\n#define IMX274_WRITE_VSIZE_REG_LSB\t\t0x3130\n#define IMX274_WRITE_VSIZE_REG_MSB\t\t0x3131\n#define IMX274_Y_OUT_SIZE_REG_LSB\t\t0x3132\n#define IMX274_Y_OUT_SIZE_REG_MSB\t\t0x3133\n#define IMX274_VMAX_REG_1\t\t\t0x30FA  \n#define IMX274_VMAX_REG_2\t\t\t0x30F9  \n#define IMX274_VMAX_REG_3\t\t\t0x30F8  \n#define IMX274_HMAX_REG_MSB\t\t\t0x30F7  \n#define IMX274_HMAX_REG_LSB\t\t\t0x30F6  \n#define IMX274_ANALOG_GAIN_ADDR_LSB\t\t0x300A  \n#define IMX274_ANALOG_GAIN_ADDR_MSB\t\t0x300B  \n#define IMX274_DIGITAL_GAIN_REG\t\t\t0x3012  \n#define IMX274_VFLIP_REG\t\t\t0x301A  \n#define IMX274_TEST_PATTERN_REG\t\t\t0x303D  \n#define IMX274_STANDBY_REG\t\t\t0x3000  \n\n#define IMX274_TABLE_WAIT_MS\t\t\t0\n#define IMX274_TABLE_END\t\t\t1\n\n \nstatic const char * const imx274_supply_names[] = {\n\t\"vddl\",   \n\t\"vdig\",   \n\t\"vana\",   \n};\n\n#define IMX274_NUM_SUPPLIES ARRAY_SIZE(imx274_supply_names)\n\n \nstruct reg_8 {\n\tu16 addr;\n\tu8 val;\n};\n\nstatic const struct regmap_config imx274_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\n \nstruct imx274_mode {\n\tconst struct reg_8 *init_regs;\n\tu8 wbin_ratio;\n\tu8 hbin_ratio;\n\tint min_frame_len;\n\tint min_SHR;\n\tint max_fps;\n\tint nocpiop;\n};\n\n \nenum {\n\tTEST_PATTERN_DISABLED = 0,\n\tTEST_PATTERN_ALL_000H,\n\tTEST_PATTERN_ALL_FFFH,\n\tTEST_PATTERN_ALL_555H,\n\tTEST_PATTERN_ALL_AAAH,\n\tTEST_PATTERN_VSP_5AH,  \n\tTEST_PATTERN_VSP_A5H,  \n\tTEST_PATTERN_VSP_05H,  \n\tTEST_PATTERN_VSP_50H,  \n\tTEST_PATTERN_VSP_0FH,  \n\tTEST_PATTERN_VSP_F0H,  \n\tTEST_PATTERN_H_COLOR_BARS,\n\tTEST_PATTERN_V_COLOR_BARS,\n};\n\nstatic const char * const tp_qmenu[] = {\n\t\"Disabled\",\n\t\"All 000h Pattern\",\n\t\"All FFFh Pattern\",\n\t\"All 555h Pattern\",\n\t\"All AAAh Pattern\",\n\t\"Vertical Stripe (555h / AAAh)\",\n\t\"Vertical Stripe (AAAh / 555h)\",\n\t\"Vertical Stripe (000h / 555h)\",\n\t\"Vertical Stripe (555h / 000h)\",\n\t\"Vertical Stripe (000h / FFFh)\",\n\t\"Vertical Stripe (FFFh / 000h)\",\n\t\"Vertical Color Bars\",\n\t\"Horizontal Color Bars\",\n};\n\n \nstatic const struct reg_8 imx274_mode1_3840x2160_raw10[] = {\n\t{0x3004, 0x01},\n\t{0x3005, 0x01},\n\t{0x3006, 0x00},\n\t{0x3007, 0xa2},\n\n\t{0x3018, 0xA2},  \n\n\t{0x306B, 0x05},\n\t{0x30E2, 0x01},\n\n\t{0x30EE, 0x01},\n\t{0x3342, 0x0A},\n\t{0x3343, 0x00},\n\t{0x3344, 0x16},\n\t{0x3345, 0x00},\n\t{0x33A6, 0x01},\n\t{0x3528, 0x0E},\n\t{0x3554, 0x1F},\n\t{0x3555, 0x01},\n\t{0x3556, 0x01},\n\t{0x3557, 0x01},\n\t{0x3558, 0x01},\n\t{0x3559, 0x00},\n\t{0x355A, 0x00},\n\t{0x35BA, 0x0E},\n\t{0x366A, 0x1B},\n\t{0x366B, 0x1A},\n\t{0x366C, 0x19},\n\t{0x366D, 0x17},\n\t{0x3A41, 0x08},\n\n\t{IMX274_TABLE_END, 0x00}\n};\n\n \nstatic const struct reg_8 imx274_mode3_1920x1080_raw10[] = {\n\t{0x3004, 0x02},\n\t{0x3005, 0x21},\n\t{0x3006, 0x00},\n\t{0x3007, 0xb1},\n\n\t{0x3018, 0xA2},  \n\n\t{0x306B, 0x05},\n\t{0x30E2, 0x02},\n\n\t{0x30EE, 0x01},\n\t{0x3342, 0x0A},\n\t{0x3343, 0x00},\n\t{0x3344, 0x1A},\n\t{0x3345, 0x00},\n\t{0x33A6, 0x01},\n\t{0x3528, 0x0E},\n\t{0x3554, 0x00},\n\t{0x3555, 0x01},\n\t{0x3556, 0x01},\n\t{0x3557, 0x01},\n\t{0x3558, 0x01},\n\t{0x3559, 0x00},\n\t{0x355A, 0x00},\n\t{0x35BA, 0x0E},\n\t{0x366A, 0x1B},\n\t{0x366B, 0x1A},\n\t{0x366C, 0x19},\n\t{0x366D, 0x17},\n\t{0x3A41, 0x08},\n\n\t{IMX274_TABLE_END, 0x00}\n};\n\n \nstatic const struct reg_8 imx274_mode5_1280x720_raw10[] = {\n\t{0x3004, 0x03},\n\t{0x3005, 0x31},\n\t{0x3006, 0x00},\n\t{0x3007, 0xa9},\n\n\t{0x3018, 0xA2},  \n\n\t{0x306B, 0x05},\n\t{0x30E2, 0x03},\n\n\t{0x30EE, 0x01},\n\t{0x3342, 0x0A},\n\t{0x3343, 0x00},\n\t{0x3344, 0x1B},\n\t{0x3345, 0x00},\n\t{0x33A6, 0x01},\n\t{0x3528, 0x0E},\n\t{0x3554, 0x00},\n\t{0x3555, 0x01},\n\t{0x3556, 0x01},\n\t{0x3557, 0x01},\n\t{0x3558, 0x01},\n\t{0x3559, 0x00},\n\t{0x355A, 0x00},\n\t{0x35BA, 0x0E},\n\t{0x366A, 0x1B},\n\t{0x366B, 0x19},\n\t{0x366C, 0x17},\n\t{0x366D, 0x17},\n\t{0x3A41, 0x04},\n\n\t{IMX274_TABLE_END, 0x00}\n};\n\n \nstatic const struct reg_8 imx274_mode6_1280x540_raw10[] = {\n\t{0x3004, 0x04},  \n\t{0x3005, 0x31},\n\t{0x3006, 0x00},\n\t{0x3007, 0x02},  \n\n\t{0x3018, 0xA2},  \n\n\t{0x306B, 0x05},\n\t{0x30E2, 0x04},  \n\n\t{0x30EE, 0x01},\n\t{0x3342, 0x0A},\n\t{0x3343, 0x00},\n\t{0x3344, 0x16},\n\t{0x3345, 0x00},\n\t{0x33A6, 0x01},\n\t{0x3528, 0x0E},\n\t{0x3554, 0x1F},\n\t{0x3555, 0x01},\n\t{0x3556, 0x01},\n\t{0x3557, 0x01},\n\t{0x3558, 0x01},\n\t{0x3559, 0x00},\n\t{0x355A, 0x00},\n\t{0x35BA, 0x0E},\n\t{0x366A, 0x1B},\n\t{0x366B, 0x1A},\n\t{0x366C, 0x19},\n\t{0x366D, 0x17},\n\t{0x3A41, 0x04},\n\n\t{IMX274_TABLE_END, 0x00}\n};\n\n \nstatic const struct reg_8 imx274_start_1[] = {\n\t{IMX274_STANDBY_REG, 0x12},\n\n\t \n\t{0x3120, 0xF0},\n\t{0x3121, 0x00},\n\t{0x3122, 0x02},\n\t{0x3129, 0x9C},\n\t{0x312A, 0x02},\n\t{0x312D, 0x02},\n\n\t{0x310B, 0x00},\n\n\t \n\t{0x304C, 0x00},  \n\t{0x304D, 0x03},\n\t{0x331C, 0x1A},\n\t{0x331D, 0x00},\n\t{0x3502, 0x02},\n\t{0x3529, 0x0E},\n\t{0x352A, 0x0E},\n\t{0x352B, 0x0E},\n\t{0x3538, 0x0E},\n\t{0x3539, 0x0E},\n\t{0x3553, 0x00},\n\t{0x357D, 0x05},\n\t{0x357F, 0x05},\n\t{0x3581, 0x04},\n\t{0x3583, 0x76},\n\t{0x3587, 0x01},\n\t{0x35BB, 0x0E},\n\t{0x35BC, 0x0E},\n\t{0x35BD, 0x0E},\n\t{0x35BE, 0x0E},\n\t{0x35BF, 0x0E},\n\t{0x366E, 0x00},\n\t{0x366F, 0x00},\n\t{0x3670, 0x00},\n\t{0x3671, 0x00},\n\n\t \n\t{0x3304, 0x32},  \n\t{0x3305, 0x00},\n\t{0x3306, 0x32},\n\t{0x3307, 0x00},\n\t{0x3590, 0x32},\n\t{0x3591, 0x00},\n\t{0x3686, 0x32},\n\t{0x3687, 0x00},\n\n\t{IMX274_TABLE_END, 0x00}\n};\n\n \nstatic const struct reg_8 imx274_start_2[] = {\n\t{IMX274_STANDBY_REG, 0x00},\n\t{0x303E, 0x02},  \n\t{IMX274_TABLE_END, 0x00}\n};\n\n \nstatic const struct reg_8 imx274_start_3[] = {\n\t{0x30F4, 0x00},\n\t{0x3018, 0xA2},  \n\t{IMX274_TABLE_END, 0x00}\n};\n\n \nstatic const struct reg_8 imx274_stop[] = {\n\t{IMX274_STANDBY_REG, 0x01},\n\t{IMX274_TABLE_END, 0x00}\n};\n\n \nstatic const struct reg_8 imx274_tp_disabled[] = {\n\t{0x303C, 0x00},\n\t{0x377F, 0x00},\n\t{0x3781, 0x00},\n\t{0x370B, 0x00},\n\t{IMX274_TABLE_END, 0x00}\n};\n\n \nstatic const struct reg_8 imx274_tp_regs[] = {\n\t{0x303C, 0x11},\n\t{0x370E, 0x01},\n\t{0x377F, 0x01},\n\t{0x3781, 0x01},\n\t{0x370B, 0x11},\n\t{IMX274_TABLE_END, 0x00}\n};\n\n \nstatic const struct imx274_mode imx274_modes[] = {\n\t{\n\t\t \n\t\t.wbin_ratio = 1,  \n\t\t.hbin_ratio = 1,  \n\t\t.init_regs = imx274_mode1_3840x2160_raw10,\n\t\t.min_frame_len = 4550,\n\t\t.min_SHR = 12,\n\t\t.max_fps = 60,\n\t\t.nocpiop = 112,\n\t},\n\t{\n\t\t \n\t\t.wbin_ratio = 2,  \n\t\t.hbin_ratio = 2,  \n\t\t.init_regs = imx274_mode3_1920x1080_raw10,\n\t\t.min_frame_len = 2310,\n\t\t.min_SHR = 8,\n\t\t.max_fps = 120,\n\t\t.nocpiop = 112,\n\t},\n\t{\n\t\t \n\t\t.wbin_ratio = 3,  \n\t\t.hbin_ratio = 3,  \n\t\t.init_regs = imx274_mode5_1280x720_raw10,\n\t\t.min_frame_len = 2310,\n\t\t.min_SHR = 8,\n\t\t.max_fps = 120,\n\t\t.nocpiop = 112,\n\t},\n\t{\n\t\t \n\t\t.wbin_ratio = 3,  \n\t\t.hbin_ratio = 4,  \n\t\t.init_regs = imx274_mode6_1280x540_raw10,\n\t\t.min_frame_len = 2310,\n\t\t.min_SHR = 4,\n\t\t.max_fps = 120,\n\t\t.nocpiop = 112,\n\t},\n};\n\n \nstruct imx274_ctrls {\n\tstruct v4l2_ctrl_handler handler;\n\tstruct v4l2_ctrl *exposure;\n\tstruct v4l2_ctrl *gain;\n\tstruct v4l2_ctrl *vflip;\n\tstruct v4l2_ctrl *test_pattern;\n};\n\n \nstruct stimx274 {\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pad;\n\tstruct i2c_client *client;\n\tstruct imx274_ctrls ctrls;\n\tstruct v4l2_rect crop;\n\tstruct v4l2_mbus_framefmt format;\n\tstruct v4l2_fract frame_interval;\n\tstruct regmap *regmap;\n\tstruct gpio_desc *reset_gpio;\n\tstruct regulator_bulk_data supplies[IMX274_NUM_SUPPLIES];\n\tstruct clk *inck;\n\tstruct mutex lock;  \n\tconst struct imx274_mode *mode;\n};\n\n#define IMX274_ROUND(dim, step, flags)\t\t\t\\\n\t((flags) & V4L2_SEL_FLAG_GE\t\t\t\\\n\t ? roundup((dim), (step))\t\t\t\\\n\t : ((flags) & V4L2_SEL_FLAG_LE\t\t\t\\\n\t    ? rounddown((dim), (step))\t\t\t\\\n\t    : rounddown((dim) + (step) / 2, (step))))\n\n \nstatic int imx274_set_gain(struct stimx274 *priv, struct v4l2_ctrl *ctrl);\nstatic int imx274_set_exposure(struct stimx274 *priv, int val);\nstatic int imx274_set_vflip(struct stimx274 *priv, int val);\nstatic int imx274_set_test_pattern(struct stimx274 *priv, int val);\nstatic int imx274_set_frame_interval(struct stimx274 *priv,\n\t\t\t\t     struct v4l2_fract frame_interval);\n\nstatic inline void msleep_range(unsigned int delay_base)\n{\n\tusleep_range(delay_base * 1000, delay_base * 1000 + 500);\n}\n\n \nstatic inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)\n{\n\treturn &container_of(ctrl->handler,\n\t\t\t     struct stimx274, ctrls.handler)->sd;\n}\n\nstatic inline struct stimx274 *to_imx274(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct stimx274, sd);\n}\n\n \nstatic int imx274_write_table(struct stimx274 *priv, const struct reg_8 table[])\n{\n\tstruct regmap *regmap = priv->regmap;\n\tint err = 0;\n\tconst struct reg_8 *next;\n\tu8 val;\n\n\tint range_start = -1;\n\tint range_count = 0;\n\tu8 range_vals[16];\n\tint max_range_vals = ARRAY_SIZE(range_vals);\n\n\tfor (next = table;; next++) {\n\t\tif ((next->addr != range_start + range_count) ||\n\t\t    (next->addr == IMX274_TABLE_END) ||\n\t\t    (next->addr == IMX274_TABLE_WAIT_MS) ||\n\t\t    (range_count == max_range_vals)) {\n\t\t\tif (range_count == 1)\n\t\t\t\terr = regmap_write(regmap,\n\t\t\t\t\t\t   range_start, range_vals[0]);\n\t\t\telse if (range_count > 1)\n\t\t\t\terr = regmap_bulk_write(regmap, range_start,\n\t\t\t\t\t\t\t&range_vals[0],\n\t\t\t\t\t\t\trange_count);\n\t\t\telse\n\t\t\t\terr = 0;\n\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\trange_start = -1;\n\t\t\trange_count = 0;\n\n\t\t\t \n\t\t\tif (next->addr == IMX274_TABLE_END)\n\t\t\t\tbreak;\n\n\t\t\tif (next->addr == IMX274_TABLE_WAIT_MS) {\n\t\t\t\tmsleep_range(next->val);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tval = next->val;\n\n\t\tif (range_start == -1)\n\t\t\trange_start = next->addr;\n\n\t\trange_vals[range_count++] = val;\n\t}\n\treturn 0;\n}\n\nstatic inline int imx274_write_reg(struct stimx274 *priv, u16 addr, u8 val)\n{\n\tint err;\n\n\terr = regmap_write(priv->regmap, addr, val);\n\tif (err)\n\t\tdev_err(&priv->client->dev,\n\t\t\t\"%s : i2c write failed, %x = %x\\n\", __func__,\n\t\t\taddr, val);\n\telse\n\t\tdev_dbg(&priv->client->dev,\n\t\t\t\"%s : addr 0x%x, val=0x%x\\n\", __func__,\n\t\t\taddr, val);\n\treturn err;\n}\n\n \nstatic int imx274_read_mbreg(struct stimx274 *priv, u16 addr, u32 *val,\n\t\t\t     size_t nbytes)\n{\n\t__le32 val_le = 0;\n\tint err;\n\n\terr = regmap_bulk_read(priv->regmap, addr, &val_le, nbytes);\n\tif (err) {\n\t\tdev_err(&priv->client->dev,\n\t\t\t\"%s : i2c bulk read failed, %x (%zu bytes)\\n\",\n\t\t\t__func__, addr, nbytes);\n\t} else {\n\t\t*val = le32_to_cpu(val_le);\n\t\tdev_dbg(&priv->client->dev,\n\t\t\t\"%s : addr 0x%x, val=0x%x (%zu bytes)\\n\",\n\t\t\t__func__, addr, *val, nbytes);\n\t}\n\n\treturn err;\n}\n\n \nstatic int imx274_write_mbreg(struct stimx274 *priv, u16 addr, u32 val,\n\t\t\t      size_t nbytes)\n{\n\t__le32 val_le = cpu_to_le32(val);\n\tint err;\n\n\terr = regmap_bulk_write(priv->regmap, addr, &val_le, nbytes);\n\tif (err)\n\t\tdev_err(&priv->client->dev,\n\t\t\t\"%s : i2c bulk write failed, %x = %x (%zu bytes)\\n\",\n\t\t\t__func__, addr, val, nbytes);\n\telse\n\t\tdev_dbg(&priv->client->dev,\n\t\t\t\"%s : addr 0x%x, val=0x%x (%zu bytes)\\n\",\n\t\t\t__func__, addr, val, nbytes);\n\treturn err;\n}\n\n \nstatic int imx274_mode_regs(struct stimx274 *priv)\n{\n\tint err = 0;\n\n\terr = imx274_write_table(priv, imx274_start_1);\n\tif (err)\n\t\treturn err;\n\n\terr = imx274_write_table(priv, priv->mode->init_regs);\n\n\treturn err;\n}\n\n \nstatic int imx274_start_stream(struct stimx274 *priv)\n{\n\tint err = 0;\n\n\terr = __v4l2_ctrl_handler_setup(&priv->ctrls.handler);\n\tif (err) {\n\t\tdev_err(&priv->client->dev, \"Error %d setup controls\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tmsleep_range(11);\n\terr = imx274_write_table(priv, imx274_start_2);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmsleep_range(8);\n\terr = imx274_write_table(priv, imx274_start_3);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \nstatic void imx274_reset(struct stimx274 *priv, int rst)\n{\n\tgpiod_set_value_cansleep(priv->reset_gpio, 0);\n\tusleep_range(IMX274_RESET_DELAY1, IMX274_RESET_DELAY2);\n\tgpiod_set_value_cansleep(priv->reset_gpio, !!rst);\n\tusleep_range(IMX274_RESET_DELAY1, IMX274_RESET_DELAY2);\n}\n\nstatic int imx274_power_on(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct stimx274 *imx274 = to_imx274(sd);\n\tint ret;\n\n\t \n\timx274_reset(imx274, 0);\n\n\tret = clk_prepare_enable(imx274->inck);\n\tif (ret) {\n\t\tdev_err(&imx274->client->dev,\n\t\t\t\"Failed to enable input clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(IMX274_NUM_SUPPLIES, imx274->supplies);\n\tif (ret) {\n\t\tdev_err(&imx274->client->dev,\n\t\t\t\"Failed to enable regulators: %d\\n\", ret);\n\t\tgoto fail_reg;\n\t}\n\n\tudelay(2);\n\timx274_reset(imx274, 1);\n\n\treturn 0;\n\nfail_reg:\n\tclk_disable_unprepare(imx274->inck);\n\treturn ret;\n}\n\nstatic int imx274_power_off(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct stimx274 *imx274 = to_imx274(sd);\n\n\timx274_reset(imx274, 0);\n\n\tregulator_bulk_disable(IMX274_NUM_SUPPLIES, imx274->supplies);\n\n\tclk_disable_unprepare(imx274->inck);\n\n\treturn 0;\n}\n\nstatic int imx274_regulators_get(struct device *dev, struct stimx274 *imx274)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < IMX274_NUM_SUPPLIES; i++)\n\t\timx274->supplies[i].supply = imx274_supply_names[i];\n\n\treturn devm_regulator_bulk_get(dev, IMX274_NUM_SUPPLIES,\n\t\t\t\t\timx274->supplies);\n}\n\n \nstatic int imx274_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = ctrl_to_sd(ctrl);\n\tstruct stimx274 *imx274 = to_imx274(sd);\n\tint ret = -EINVAL;\n\n\tif (!pm_runtime_get_if_in_use(&imx274->client->dev))\n\t\treturn 0;\n\n\tdev_dbg(&imx274->client->dev,\n\t\t\"%s : s_ctrl: %s, value: %d\\n\", __func__,\n\t\tctrl->name, ctrl->val);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE:\n\t\tdev_dbg(&imx274->client->dev,\n\t\t\t\"%s : set V4L2_CID_EXPOSURE\\n\", __func__);\n\t\tret = imx274_set_exposure(imx274, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_GAIN:\n\t\tdev_dbg(&imx274->client->dev,\n\t\t\t\"%s : set V4L2_CID_GAIN\\n\", __func__);\n\t\tret = imx274_set_gain(imx274, ctrl);\n\t\tbreak;\n\n\tcase V4L2_CID_VFLIP:\n\t\tdev_dbg(&imx274->client->dev,\n\t\t\t\"%s : set V4L2_CID_VFLIP\\n\", __func__);\n\t\tret = imx274_set_vflip(imx274, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tdev_dbg(&imx274->client->dev,\n\t\t\t\"%s : set V4L2_CID_TEST_PATTERN\\n\", __func__);\n\t\tret = imx274_set_test_pattern(imx274, ctrl->val);\n\t\tbreak;\n\t}\n\n\tpm_runtime_put(&imx274->client->dev);\n\n\treturn ret;\n}\n\nstatic int imx274_binning_goodness(struct stimx274 *imx274,\n\t\t\t\t   int w, int ask_w,\n\t\t\t\t   int h, int ask_h, u32 flags)\n{\n\tstruct device *dev = &imx274->client->dev;\n\tconst int goodness = 100000;\n\tint val = 0;\n\n\tif (flags & V4L2_SEL_FLAG_GE) {\n\t\tif (w < ask_w)\n\t\t\tval -= goodness;\n\t\tif (h < ask_h)\n\t\t\tval -= goodness;\n\t}\n\n\tif (flags & V4L2_SEL_FLAG_LE) {\n\t\tif (w > ask_w)\n\t\t\tval -= goodness;\n\t\tif (h > ask_h)\n\t\t\tval -= goodness;\n\t}\n\n\tval -= abs(w - ask_w);\n\tval -= abs(h - ask_h);\n\n\tdev_dbg(dev, \"%s: ask %dx%d, size %dx%d, goodness %d\\n\",\n\t\t__func__, ask_w, ask_h, w, h, val);\n\n\treturn val;\n}\n\n \nstatic int __imx274_change_compose(struct stimx274 *imx274,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   u32 which,\n\t\t\t\t   u32 *width,\n\t\t\t\t   u32 *height,\n\t\t\t\t   u32 flags)\n{\n\tstruct device *dev = &imx274->client->dev;\n\tconst struct v4l2_rect *cur_crop;\n\tstruct v4l2_mbus_framefmt *tgt_fmt;\n\tunsigned int i;\n\tconst struct imx274_mode *best_mode = &imx274_modes[0];\n\tint best_goodness = INT_MIN;\n\n\tif (which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tcur_crop = &sd_state->pads->try_crop;\n\t\ttgt_fmt = &sd_state->pads->try_fmt;\n\t} else {\n\t\tcur_crop = &imx274->crop;\n\t\ttgt_fmt = &imx274->format;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(imx274_modes); i++) {\n\t\tu8 wratio = imx274_modes[i].wbin_ratio;\n\t\tu8 hratio = imx274_modes[i].hbin_ratio;\n\n\t\tint goodness = imx274_binning_goodness(\n\t\t\timx274,\n\t\t\tcur_crop->width / wratio, *width,\n\t\t\tcur_crop->height / hratio, *height,\n\t\t\tflags);\n\n\t\tif (goodness >= best_goodness) {\n\t\t\tbest_goodness = goodness;\n\t\t\tbest_mode = &imx274_modes[i];\n\t\t}\n\t}\n\n\t*width = cur_crop->width / best_mode->wbin_ratio;\n\t*height = cur_crop->height / best_mode->hbin_ratio;\n\n\tif (which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\timx274->mode = best_mode;\n\n\tdev_dbg(dev, \"%s: selected %ux%u binning\\n\",\n\t\t__func__, best_mode->wbin_ratio, best_mode->hbin_ratio);\n\n\ttgt_fmt->width = *width;\n\ttgt_fmt->height = *height;\n\ttgt_fmt->field = V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\n \nstatic int imx274_get_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *fmt)\n{\n\tstruct stimx274 *imx274 = to_imx274(sd);\n\n\tmutex_lock(&imx274->lock);\n\tfmt->format = imx274->format;\n\tmutex_unlock(&imx274->lock);\n\treturn 0;\n}\n\n \nstatic int imx274_set_fmt(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *fmt = &format->format;\n\tstruct stimx274 *imx274 = to_imx274(sd);\n\tint err = 0;\n\n\tmutex_lock(&imx274->lock);\n\n\terr = __imx274_change_compose(imx274, sd_state, format->which,\n\t\t\t\t      &fmt->width, &fmt->height, 0);\n\n\tif (err)\n\t\tgoto out;\n\n\t \n\tfmt->field = V4L2_FIELD_NONE;\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\tsd_state->pads->try_fmt = *fmt;\n\telse\n\t\timx274->format = *fmt;\n\nout:\n\tmutex_unlock(&imx274->lock);\n\n\treturn err;\n}\n\nstatic int imx274_get_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct stimx274 *imx274 = to_imx274(sd);\n\tconst struct v4l2_rect *src_crop;\n\tconst struct v4l2_mbus_framefmt *src_fmt;\n\tint ret = 0;\n\n\tif (sel->pad != 0)\n\t\treturn -EINVAL;\n\n\tif (sel->target == V4L2_SEL_TGT_CROP_BOUNDS) {\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = IMX274_MAX_WIDTH;\n\t\tsel->r.height = IMX274_MAX_HEIGHT;\n\t\treturn 0;\n\t}\n\n\tif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tsrc_crop = &sd_state->pads->try_crop;\n\t\tsrc_fmt = &sd_state->pads->try_fmt;\n\t} else {\n\t\tsrc_crop = &imx274->crop;\n\t\tsrc_fmt = &imx274->format;\n\t}\n\n\tmutex_lock(&imx274->lock);\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = *src_crop;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\tsel->r.top = 0;\n\t\tsel->r.left = 0;\n\t\tsel->r.width = src_crop->width;\n\t\tsel->r.height = src_crop->height;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tsel->r.top = 0;\n\t\tsel->r.left = 0;\n\t\tsel->r.width = src_fmt->width;\n\t\tsel->r.height = src_fmt->height;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&imx274->lock);\n\n\treturn ret;\n}\n\nstatic int imx274_set_selection_crop(struct stimx274 *imx274,\n\t\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t\t     struct v4l2_subdev_selection *sel)\n{\n\tstruct v4l2_rect *tgt_crop;\n\tstruct v4l2_rect new_crop;\n\tbool size_changed;\n\n\t \n\tconst u32 h_step = 24;\n\n\tnew_crop.width = min_t(u32,\n\t\t\t       IMX274_ROUND(sel->r.width, h_step, sel->flags),\n\t\t\t       IMX274_MAX_WIDTH);\n\n\t \n\tif (new_crop.width < 144)\n\t\tnew_crop.width = 144;\n\n\tnew_crop.left = min_t(u32,\n\t\t\t      IMX274_ROUND(sel->r.left, h_step, 0),\n\t\t\t      IMX274_MAX_WIDTH - new_crop.width);\n\n\tnew_crop.height = min_t(u32,\n\t\t\t\tIMX274_ROUND(sel->r.height, 2, sel->flags),\n\t\t\t\tIMX274_MAX_HEIGHT);\n\n\tnew_crop.top = min_t(u32, IMX274_ROUND(sel->r.top, 2, 0),\n\t\t\t     IMX274_MAX_HEIGHT - new_crop.height);\n\n\tsel->r = new_crop;\n\n\tif (sel->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\ttgt_crop = &sd_state->pads->try_crop;\n\telse\n\t\ttgt_crop = &imx274->crop;\n\n\tmutex_lock(&imx274->lock);\n\n\tsize_changed = (new_crop.width != tgt_crop->width ||\n\t\t\tnew_crop.height != tgt_crop->height);\n\n\t \n\t*tgt_crop = new_crop;\n\n\t \n\tif (size_changed)\n\t\t__imx274_change_compose(imx274, sd_state, sel->which,\n\t\t\t\t\t&new_crop.width, &new_crop.height,\n\t\t\t\t\tsel->flags);\n\n\tmutex_unlock(&imx274->lock);\n\n\treturn 0;\n}\n\nstatic int imx274_set_selection(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_selection *sel)\n{\n\tstruct stimx274 *imx274 = to_imx274(sd);\n\n\tif (sel->pad != 0)\n\t\treturn -EINVAL;\n\n\tif (sel->target == V4L2_SEL_TGT_CROP)\n\t\treturn imx274_set_selection_crop(imx274, sd_state, sel);\n\n\tif (sel->target == V4L2_SEL_TGT_COMPOSE) {\n\t\tint err;\n\n\t\tmutex_lock(&imx274->lock);\n\t\terr =  __imx274_change_compose(imx274, sd_state, sel->which,\n\t\t\t\t\t       &sel->r.width, &sel->r.height,\n\t\t\t\t\t       sel->flags);\n\t\tmutex_unlock(&imx274->lock);\n\n\t\t \n\t\tif (!err) {\n\t\t\tsel->r.top = 0;\n\t\t\tsel->r.left = 0;\n\t\t}\n\n\t\treturn err;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int imx274_apply_trimming(struct stimx274 *imx274)\n{\n\tu32 h_start;\n\tu32 h_end;\n\tu32 hmax;\n\tu32 v_cut;\n\ts32 v_pos;\n\tu32 write_v_size;\n\tu32 y_out_size;\n\tint err;\n\n\th_start = imx274->crop.left + 12;\n\th_end = h_start + imx274->crop.width;\n\n\t \n\t \n\t \n\thmax = max_t(u32, 260, (imx274->crop.width) / 16 + 23);\n\n\t \n\tv_pos = imx274->ctrls.vflip->cur.val ?\n\t\t(-imx274->crop.top / 2) : (imx274->crop.top / 2);\n\tv_cut = (IMX274_MAX_HEIGHT - imx274->crop.height) / 2;\n\twrite_v_size = imx274->crop.height + 22;\n\ty_out_size   = imx274->crop.height;\n\n\terr = imx274_write_mbreg(imx274, IMX274_HMAX_REG_LSB, hmax, 2);\n\tif (!err)\n\t\terr = imx274_write_mbreg(imx274, IMX274_HTRIM_EN_REG, 1, 1);\n\tif (!err)\n\t\terr = imx274_write_mbreg(imx274, IMX274_HTRIM_START_REG_LSB,\n\t\t\t\t\t h_start, 2);\n\tif (!err)\n\t\terr = imx274_write_mbreg(imx274, IMX274_HTRIM_END_REG_LSB,\n\t\t\t\t\t h_end, 2);\n\tif (!err)\n\t\terr = imx274_write_mbreg(imx274, IMX274_VWIDCUTEN_REG, 1, 1);\n\tif (!err)\n\t\terr = imx274_write_mbreg(imx274, IMX274_VWIDCUT_REG_LSB,\n\t\t\t\t\t v_cut, 2);\n\tif (!err)\n\t\terr = imx274_write_mbreg(imx274, IMX274_VWINPOS_REG_LSB,\n\t\t\t\t\t v_pos, 2);\n\tif (!err)\n\t\terr = imx274_write_mbreg(imx274, IMX274_WRITE_VSIZE_REG_LSB,\n\t\t\t\t\t write_v_size, 2);\n\tif (!err)\n\t\terr = imx274_write_mbreg(imx274, IMX274_Y_OUT_SIZE_REG_LSB,\n\t\t\t\t\t y_out_size, 2);\n\n\treturn err;\n}\n\n \nstatic int imx274_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *fi)\n{\n\tstruct stimx274 *imx274 = to_imx274(sd);\n\n\tfi->interval = imx274->frame_interval;\n\tdev_dbg(&imx274->client->dev, \"%s frame rate = %d / %d\\n\",\n\t\t__func__, imx274->frame_interval.numerator,\n\t\timx274->frame_interval.denominator);\n\n\treturn 0;\n}\n\n \nstatic int imx274_s_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_frame_interval *fi)\n{\n\tstruct stimx274 *imx274 = to_imx274(sd);\n\tstruct v4l2_ctrl *ctrl = imx274->ctrls.exposure;\n\tint min, max, def;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(&imx274->client->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&imx274->lock);\n\tret = imx274_set_frame_interval(imx274, fi->interval);\n\n\tif (!ret) {\n\t\tfi->interval = imx274->frame_interval;\n\n\t\t \n\t\tmin = IMX274_MIN_EXPOSURE_TIME;\n\t\tmax = fi->interval.numerator * 1000000\n\t\t\t/ fi->interval.denominator;\n\t\tdef = max;\n\t\tret = __v4l2_ctrl_modify_range(ctrl, min, max, 1, def);\n\t\tif (ret) {\n\t\t\tdev_err(&imx274->client->dev,\n\t\t\t\t\"Exposure ctrl range update failed\\n\");\n\t\t\tgoto unlock;\n\t\t}\n\n\t\t \n\t\timx274_set_exposure(imx274, ctrl->val);\n\n\t\tdev_dbg(&imx274->client->dev, \"set frame interval to %uus\\n\",\n\t\t\tfi->interval.numerator * 1000000\n\t\t\t/ fi->interval.denominator);\n\t}\n\nunlock:\n\tmutex_unlock(&imx274->lock);\n\tpm_runtime_put(&imx274->client->dev);\n\n\treturn ret;\n}\n\n \nstatic void imx274_load_default(struct stimx274 *priv)\n{\n\t \n\tpriv->frame_interval.numerator = 1;\n\tpriv->frame_interval.denominator = IMX274_DEF_FRAME_RATE;\n\tpriv->ctrls.exposure->val = 1000000 / IMX274_DEF_FRAME_RATE;\n\tpriv->ctrls.gain->val = IMX274_DEF_GAIN;\n\tpriv->ctrls.vflip->val = 0;\n\tpriv->ctrls.test_pattern->val = TEST_PATTERN_DISABLED;\n}\n\n \nstatic int imx274_s_stream(struct v4l2_subdev *sd, int on)\n{\n\tstruct stimx274 *imx274 = to_imx274(sd);\n\tint ret = 0;\n\n\tdev_dbg(&imx274->client->dev, \"%s : %s, mode index = %td\\n\", __func__,\n\t\ton ? \"Stream Start\" : \"Stream Stop\",\n\t\timx274->mode - &imx274_modes[0]);\n\n\tmutex_lock(&imx274->lock);\n\n\tif (on) {\n\t\tret = pm_runtime_resume_and_get(&imx274->client->dev);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&imx274->lock);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = imx274_mode_regs(imx274);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tret = imx274_apply_trimming(imx274);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\t \n\t\tret = imx274_set_frame_interval(imx274,\n\t\t\t\t\t\timx274->frame_interval);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\t \n\t\tret = imx274_start_stream(imx274);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t} else {\n\t\t \n\t\tret = imx274_write_table(imx274, imx274_stop);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tpm_runtime_put(&imx274->client->dev);\n\t}\n\n\tmutex_unlock(&imx274->lock);\n\tdev_dbg(&imx274->client->dev, \"%s : Done\\n\", __func__);\n\treturn 0;\n\nfail:\n\tpm_runtime_put(&imx274->client->dev);\n\tmutex_unlock(&imx274->lock);\n\tdev_err(&imx274->client->dev, \"s_stream failed\\n\");\n\treturn ret;\n}\n\n \nstatic int imx274_get_frame_length(struct stimx274 *priv, u32 *val)\n{\n\tint err;\n\tu32 svr;\n\tu32 vmax;\n\n\terr = imx274_read_mbreg(priv, IMX274_SVR_REG_LSB, &svr, 2);\n\tif (err)\n\t\tgoto fail;\n\n\terr = imx274_read_mbreg(priv, IMX274_VMAX_REG_3, &vmax, 3);\n\tif (err)\n\t\tgoto fail;\n\n\t*val = vmax * (svr + 1);\n\n\treturn 0;\n\nfail:\n\tdev_err(&priv->client->dev, \"%s error = %d\\n\", __func__, err);\n\treturn err;\n}\n\nstatic int imx274_clamp_coarse_time(struct stimx274 *priv, u32 *val,\n\t\t\t\t    u32 *frame_length)\n{\n\tint err;\n\n\terr = imx274_get_frame_length(priv, frame_length);\n\tif (err)\n\t\treturn err;\n\n\tif (*frame_length < priv->mode->min_frame_len)\n\t\t*frame_length =  priv->mode->min_frame_len;\n\n\t*val = *frame_length - *val;  \n\tif (*val > *frame_length - IMX274_SHR_LIMIT_CONST)\n\t\t*val = *frame_length - IMX274_SHR_LIMIT_CONST;\n\telse if (*val < priv->mode->min_SHR)\n\t\t*val = priv->mode->min_SHR;\n\n\treturn 0;\n}\n\n \nstatic int imx274_set_digital_gain(struct stimx274 *priv, u32 dgain)\n{\n\tu8 reg_val;\n\n\treg_val = ffs(dgain);\n\n\tif (reg_val)\n\t\treg_val--;\n\n\treg_val = clamp(reg_val, (u8)0, (u8)3);\n\n\treturn imx274_write_reg(priv, IMX274_DIGITAL_GAIN_REG,\n\t\t\t\treg_val & IMX274_MASK_LSB_4_BITS);\n}\n\n \nstatic int imx274_set_gain(struct stimx274 *priv, struct v4l2_ctrl *ctrl)\n{\n\tint err;\n\tu32 gain, analog_gain, digital_gain, gain_reg;\n\n\tgain = (u32)(ctrl->val);\n\n\tdev_dbg(&priv->client->dev,\n\t\t\"%s : input gain = %d.%d\\n\", __func__,\n\t\tgain >> IMX274_GAIN_SHIFT,\n\t\t((gain & IMX274_GAIN_SHIFT_MASK) * 100) >> IMX274_GAIN_SHIFT);\n\n\tif (gain > IMX274_MAX_DIGITAL_GAIN * IMX274_MAX_ANALOG_GAIN)\n\t\tgain = IMX274_MAX_DIGITAL_GAIN * IMX274_MAX_ANALOG_GAIN;\n\telse if (gain < IMX274_MIN_GAIN)\n\t\tgain = IMX274_MIN_GAIN;\n\n\tif (gain <= IMX274_MAX_ANALOG_GAIN)\n\t\tdigital_gain = 1;\n\telse if (gain <= IMX274_MAX_ANALOG_GAIN * 2)\n\t\tdigital_gain = 2;\n\telse if (gain <= IMX274_MAX_ANALOG_GAIN * 4)\n\t\tdigital_gain = 4;\n\telse\n\t\tdigital_gain = IMX274_MAX_DIGITAL_GAIN;\n\n\tanalog_gain = gain / digital_gain;\n\n\tdev_dbg(&priv->client->dev,\n\t\t\"%s : digital gain = %d, analog gain = %d.%d\\n\",\n\t\t__func__, digital_gain, analog_gain >> IMX274_GAIN_SHIFT,\n\t\t((analog_gain & IMX274_GAIN_SHIFT_MASK) * 100)\n\t\t>> IMX274_GAIN_SHIFT);\n\n\terr = imx274_set_digital_gain(priv, digital_gain);\n\tif (err)\n\t\tgoto fail;\n\n\t \n\tgain_reg = (u32)IMX274_GAIN_CONST -\n\t\t(IMX274_GAIN_CONST << IMX274_GAIN_SHIFT) / analog_gain;\n\tif (gain_reg > IMX274_GAIN_REG_MAX)\n\t\tgain_reg = IMX274_GAIN_REG_MAX;\n\n\terr = imx274_write_mbreg(priv, IMX274_ANALOG_GAIN_ADDR_LSB, gain_reg,\n\t\t\t\t 2);\n\tif (err)\n\t\tgoto fail;\n\n\tif (IMX274_GAIN_CONST - gain_reg == 0) {\n\t\terr = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\t \n\tctrl->val = (IMX274_GAIN_CONST << IMX274_GAIN_SHIFT)\n\t\t\t/ (IMX274_GAIN_CONST - gain_reg) * digital_gain;\n\n\tdev_dbg(&priv->client->dev,\n\t\t\"%s : GAIN control success, gain_reg = %d, new gain = %d\\n\",\n\t\t__func__, gain_reg, ctrl->val);\n\n\treturn 0;\n\nfail:\n\tdev_err(&priv->client->dev, \"%s error = %d\\n\", __func__, err);\n\treturn err;\n}\n\n \nstatic int imx274_set_coarse_time(struct stimx274 *priv, u32 *val)\n{\n\tint err;\n\tu32 coarse_time, frame_length;\n\n\tcoarse_time = *val;\n\n\t \n\terr = imx274_clamp_coarse_time(priv, &coarse_time, &frame_length);\n\tif (err)\n\t\tgoto fail;\n\n\terr = imx274_write_mbreg(priv, IMX274_SHR_REG_LSB, coarse_time, 2);\n\tif (err)\n\t\tgoto fail;\n\n\t*val = frame_length - coarse_time;\n\treturn 0;\n\nfail:\n\tdev_err(&priv->client->dev, \"%s error = %d\\n\", __func__, err);\n\treturn err;\n}\n\n \nstatic int imx274_set_exposure(struct stimx274 *priv, int val)\n{\n\tint err;\n\tu32 hmax;\n\tu32 coarse_time;  \n\n\tdev_dbg(&priv->client->dev,\n\t\t\"%s : EXPOSURE control input = %d\\n\", __func__, val);\n\n\t \n\n\terr = imx274_read_mbreg(priv, IMX274_HMAX_REG_LSB, &hmax, 2);\n\tif (err)\n\t\tgoto fail;\n\n\tif (hmax == 0) {\n\t\terr = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tcoarse_time = (IMX274_PIXCLK_CONST1 / IMX274_PIXCLK_CONST2 * val\n\t\t\t- priv->mode->nocpiop) / hmax;\n\n\t \n\n\t \n\terr = imx274_set_coarse_time(priv, &coarse_time);\n\tif (err)\n\t\tgoto fail;\n\n\tpriv->ctrls.exposure->val =\n\t\t\t(coarse_time * hmax + priv->mode->nocpiop)\n\t\t\t/ (IMX274_PIXCLK_CONST1 / IMX274_PIXCLK_CONST2);\n\n\tdev_dbg(&priv->client->dev,\n\t\t\"%s : EXPOSURE control success\\n\", __func__);\n\treturn 0;\n\nfail:\n\tdev_err(&priv->client->dev, \"%s error = %d\\n\", __func__, err);\n\n\treturn err;\n}\n\n \nstatic int imx274_set_vflip(struct stimx274 *priv, int val)\n{\n\tint err;\n\n\terr = imx274_write_reg(priv, IMX274_VFLIP_REG, val);\n\tif (err) {\n\t\tdev_err(&priv->client->dev, \"VFLIP control error\\n\");\n\t\treturn err;\n\t}\n\n\tdev_dbg(&priv->client->dev,\n\t\t\"%s : VFLIP control success\\n\", __func__);\n\n\treturn 0;\n}\n\n \nstatic int imx274_set_test_pattern(struct stimx274 *priv, int val)\n{\n\tint err = 0;\n\n\tif (val == TEST_PATTERN_DISABLED) {\n\t\terr = imx274_write_table(priv, imx274_tp_disabled);\n\t} else if (val <= TEST_PATTERN_V_COLOR_BARS) {\n\t\terr = imx274_write_reg(priv, IMX274_TEST_PATTERN_REG, val - 1);\n\t\tif (!err)\n\t\t\terr = imx274_write_table(priv, imx274_tp_regs);\n\t} else {\n\t\terr = -EINVAL;\n\t}\n\n\tif (!err)\n\t\tdev_dbg(&priv->client->dev,\n\t\t\t\"%s : TEST PATTERN control success\\n\", __func__);\n\telse\n\t\tdev_err(&priv->client->dev, \"%s error = %d\\n\", __func__, err);\n\n\treturn err;\n}\n\n \nstatic int imx274_set_frame_length(struct stimx274 *priv, u32 val)\n{\n\tint err;\n\tu32 frame_length;\n\n\tdev_dbg(&priv->client->dev, \"%s : input length = %d\\n\",\n\t\t__func__, val);\n\n\tframe_length = (u32)val;\n\n\terr = imx274_write_mbreg(priv, IMX274_VMAX_REG_3, frame_length, 3);\n\tif (err)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\tdev_err(&priv->client->dev, \"%s error = %d\\n\", __func__, err);\n\treturn err;\n}\n\n \nstatic int imx274_set_frame_interval(struct stimx274 *priv,\n\t\t\t\t     struct v4l2_fract frame_interval)\n{\n\tint err;\n\tu32 frame_length, req_frame_rate;\n\tu32 svr;\n\tu32 hmax;\n\n\tdev_dbg(&priv->client->dev, \"%s: input frame interval = %d / %d\",\n\t\t__func__, frame_interval.numerator,\n\t\tframe_interval.denominator);\n\n\tif (frame_interval.numerator == 0 || frame_interval.denominator == 0) {\n\t\tframe_interval.denominator = IMX274_DEF_FRAME_RATE;\n\t\tframe_interval.numerator = 1;\n\t}\n\n\treq_frame_rate = (u32)(frame_interval.denominator\n\t\t\t\t/ frame_interval.numerator);\n\n\t \n\tif (req_frame_rate > priv->mode->max_fps) {\n\t\tframe_interval.numerator = 1;\n\t\tframe_interval.denominator = priv->mode->max_fps;\n\t} else if (req_frame_rate < IMX274_MIN_FRAME_RATE) {\n\t\tframe_interval.numerator = 1;\n\t\tframe_interval.denominator = IMX274_MIN_FRAME_RATE;\n\t}\n\n\t \n\n\terr = imx274_read_mbreg(priv, IMX274_SVR_REG_LSB, &svr, 2);\n\tif (err)\n\t\tgoto fail;\n\n\tdev_dbg(&priv->client->dev,\n\t\t\"%s : register SVR = %d\\n\", __func__, svr);\n\n\terr = imx274_read_mbreg(priv, IMX274_HMAX_REG_LSB, &hmax, 2);\n\tif (err)\n\t\tgoto fail;\n\n\tdev_dbg(&priv->client->dev,\n\t\t\"%s : register HMAX = %d\\n\", __func__, hmax);\n\n\tif (hmax == 0 || frame_interval.denominator == 0) {\n\t\terr = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tframe_length = IMX274_PIXCLK_CONST1 / (svr + 1) / hmax\n\t\t\t\t\t* frame_interval.numerator\n\t\t\t\t\t/ frame_interval.denominator;\n\n\terr = imx274_set_frame_length(priv, frame_length);\n\tif (err)\n\t\tgoto fail;\n\n\tpriv->frame_interval = frame_interval;\n\treturn 0;\n\nfail:\n\tdev_err(&priv->client->dev, \"%s error = %d\\n\", __func__, err);\n\treturn err;\n}\n\nstatic int imx274_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index > 0)\n\t\treturn -EINVAL;\n\n\t \n\tcode->code = MEDIA_BUS_FMT_SRGGB10_1X10;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops imx274_pad_ops = {\n\t.enum_mbus_code = imx274_enum_mbus_code,\n\t.get_fmt = imx274_get_fmt,\n\t.set_fmt = imx274_set_fmt,\n\t.get_selection = imx274_get_selection,\n\t.set_selection = imx274_set_selection,\n};\n\nstatic const struct v4l2_subdev_video_ops imx274_video_ops = {\n\t.g_frame_interval = imx274_g_frame_interval,\n\t.s_frame_interval = imx274_s_frame_interval,\n\t.s_stream = imx274_s_stream,\n};\n\nstatic const struct v4l2_subdev_ops imx274_subdev_ops = {\n\t.pad = &imx274_pad_ops,\n\t.video = &imx274_video_ops,\n};\n\nstatic const struct v4l2_ctrl_ops imx274_ctrl_ops = {\n\t.s_ctrl\t= imx274_s_ctrl,\n};\n\nstatic const struct of_device_id imx274_of_id_table[] = {\n\t{ .compatible = \"sony,imx274\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, imx274_of_id_table);\n\nstatic const struct i2c_device_id imx274_id[] = {\n\t{ \"IMX274\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, imx274_id);\n\nstatic int imx274_fwnode_parse(struct device *dev)\n{\n\tstruct fwnode_handle *endpoint;\n\t \n\tstruct v4l2_fwnode_endpoint ep = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY\n\t};\n\tint ret;\n\n\tendpoint = fwnode_graph_get_next_endpoint(dev_fwnode(dev), NULL);\n\tif (!endpoint) {\n\t\tdev_err(dev, \"Endpoint node not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = v4l2_fwnode_endpoint_parse(endpoint, &ep);\n\tfwnode_handle_put(endpoint);\n\tif (ret == -ENXIO) {\n\t\tdev_err(dev, \"Unsupported bus type, should be CSI2\\n\");\n\t\treturn ret;\n\t} else if (ret) {\n\t\tdev_err(dev, \"Parsing endpoint node failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (ep.bus.mipi_csi2.num_data_lanes != 4) {\n\t\tdev_err(dev, \"Invalid data lanes: %d\\n\",\n\t\t\tep.bus.mipi_csi2.num_data_lanes);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int imx274_probe(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd;\n\tstruct stimx274 *imx274;\n\tstruct device *dev = &client->dev;\n\tint ret;\n\n\t \n\timx274 = devm_kzalloc(dev, sizeof(*imx274), GFP_KERNEL);\n\tif (!imx274)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&imx274->lock);\n\n\tret = imx274_fwnode_parse(dev);\n\tif (ret)\n\t\treturn ret;\n\n\timx274->inck = devm_clk_get_optional(dev, \"inck\");\n\tif (IS_ERR(imx274->inck))\n\t\treturn PTR_ERR(imx274->inck);\n\n\tret = imx274_regulators_get(dev, imx274);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get power regulators, err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\timx274->mode = &imx274_modes[0];\n\timx274->crop.width = IMX274_MAX_WIDTH;\n\timx274->crop.height = IMX274_MAX_HEIGHT;\n\timx274->format.width = imx274->crop.width / imx274->mode->wbin_ratio;\n\timx274->format.height = imx274->crop.height / imx274->mode->hbin_ratio;\n\timx274->format.field = V4L2_FIELD_NONE;\n\timx274->format.code = MEDIA_BUS_FMT_SRGGB10_1X10;\n\timx274->format.colorspace = V4L2_COLORSPACE_SRGB;\n\timx274->frame_interval.numerator = 1;\n\timx274->frame_interval.denominator = IMX274_DEF_FRAME_RATE;\n\n\t \n\timx274->regmap = devm_regmap_init_i2c(client, &imx274_regmap_config);\n\tif (IS_ERR(imx274->regmap)) {\n\t\tdev_err(dev,\n\t\t\t\"regmap init failed: %ld\\n\", PTR_ERR(imx274->regmap));\n\t\tret = -ENODEV;\n\t\tgoto err_regmap;\n\t}\n\n\t \n\timx274->client = client;\n\tsd = &imx274->sd;\n\tv4l2_i2c_subdev_init(sd, client, &imx274_subdev_ops);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;\n\n\t \n\timx274->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tsd->entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\tret = media_entity_pads_init(&sd->entity, 1, &imx274->pad);\n\tif (ret < 0) {\n\t\tdev_err(dev,\n\t\t\t\"%s : media entity init Failed %d\\n\", __func__, ret);\n\t\tgoto err_regmap;\n\t}\n\n\t \n\timx274->reset_gpio = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t     GPIOD_OUT_HIGH);\n\tif (IS_ERR(imx274->reset_gpio)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(imx274->reset_gpio),\n\t\t\t\t    \"Reset GPIO not setup in DT\\n\");\n\t\tgoto err_me;\n\t}\n\n\t \n\tret = imx274_power_on(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s : imx274 power on failed\\n\", __func__);\n\t\tgoto err_me;\n\t}\n\n\t \n\tret = v4l2_ctrl_handler_init(&imx274->ctrls.handler, 4);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s : ctrl handler init Failed\\n\", __func__);\n\t\tgoto err_power_off;\n\t}\n\n\timx274->ctrls.handler.lock = &imx274->lock;\n\n\t \n\timx274->ctrls.test_pattern = v4l2_ctrl_new_std_menu_items(\n\t\t&imx274->ctrls.handler, &imx274_ctrl_ops,\n\t\tV4L2_CID_TEST_PATTERN,\n\t\tARRAY_SIZE(tp_qmenu) - 1, 0, 0, tp_qmenu);\n\n\timx274->ctrls.gain = v4l2_ctrl_new_std(\n\t\t&imx274->ctrls.handler,\n\t\t&imx274_ctrl_ops,\n\t\tV4L2_CID_GAIN, IMX274_MIN_GAIN,\n\t\tIMX274_MAX_DIGITAL_GAIN * IMX274_MAX_ANALOG_GAIN, 1,\n\t\tIMX274_DEF_GAIN);\n\n\timx274->ctrls.exposure = v4l2_ctrl_new_std(\n\t\t&imx274->ctrls.handler,\n\t\t&imx274_ctrl_ops,\n\t\tV4L2_CID_EXPOSURE, IMX274_MIN_EXPOSURE_TIME,\n\t\t1000000 / IMX274_DEF_FRAME_RATE, 1,\n\t\tIMX274_MIN_EXPOSURE_TIME);\n\n\timx274->ctrls.vflip = v4l2_ctrl_new_std(\n\t\t&imx274->ctrls.handler,\n\t\t&imx274_ctrl_ops,\n\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\n\timx274->sd.ctrl_handler = &imx274->ctrls.handler;\n\tif (imx274->ctrls.handler.error) {\n\t\tret = imx274->ctrls.handler.error;\n\t\tgoto err_ctrls;\n\t}\n\n\t \n\timx274_load_default(imx274);\n\n\t \n\tret = v4l2_async_register_subdev(sd);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s : v4l2_async_register_subdev failed %d\\n\",\n\t\t\t__func__, ret);\n\t\tgoto err_ctrls;\n\t}\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_idle(dev);\n\n\tdev_info(dev, \"imx274 : imx274 probe success !\\n\");\n\treturn 0;\n\nerr_ctrls:\n\tv4l2_ctrl_handler_free(&imx274->ctrls.handler);\nerr_power_off:\n\timx274_power_off(dev);\nerr_me:\n\tmedia_entity_cleanup(&sd->entity);\nerr_regmap:\n\tmutex_destroy(&imx274->lock);\n\treturn ret;\n}\n\nstatic void imx274_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct stimx274 *imx274 = to_imx274(sd);\n\n\tpm_runtime_disable(&client->dev);\n\tif (!pm_runtime_status_suspended(&client->dev))\n\t\timx274_power_off(&client->dev);\n\tpm_runtime_set_suspended(&client->dev);\n\n\tv4l2_async_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(&imx274->ctrls.handler);\n\n\tmedia_entity_cleanup(&sd->entity);\n\tmutex_destroy(&imx274->lock);\n}\n\nstatic const struct dev_pm_ops imx274_pm_ops = {\n\tSET_RUNTIME_PM_OPS(imx274_power_off, imx274_power_on, NULL)\n};\n\nstatic struct i2c_driver imx274_i2c_driver = {\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t\t.pm = &imx274_pm_ops,\n\t\t.of_match_table\t= imx274_of_id_table,\n\t},\n\t.probe\t\t= imx274_probe,\n\t.remove\t\t= imx274_remove,\n\t.id_table\t= imx274_id,\n};\n\nmodule_i2c_driver(imx274_i2c_driver);\n\nMODULE_AUTHOR(\"Leon Luo <leonl@leopardimaging.com>\");\nMODULE_DESCRIPTION(\"IMX274 CMOS Image Sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}