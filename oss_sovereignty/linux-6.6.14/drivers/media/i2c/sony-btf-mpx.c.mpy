{
  "module_name": "sony-btf-mpx.c",
  "hash_id": "605ba11eea1dccc09fcfe2503d7daf1cc007ea0ceaa9c8d2647e44792340a737",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/sony-btf-mpx.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/videodev2.h>\n#include <media/tuner.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-device.h>\n#include <linux/slab.h>\n\nMODULE_DESCRIPTION(\"sony-btf-mpx driver\");\nMODULE_LICENSE(\"GPL v2\");\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"debug level 0=off(default) 1=on\");\n\n \n\n \n\n\nstatic int force_mpx_mode = -1;\nmodule_param(force_mpx_mode, int, 0644);\n\nstruct sony_btf_mpx {\n\tstruct v4l2_subdev sd;\n\tint mpxmode;\n\tu32 audmode;\n};\n\nstatic inline struct sony_btf_mpx *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct sony_btf_mpx, sd);\n}\n\nstatic int mpx_write(struct i2c_client *client, int dev, int addr, int val)\n{\n\tu8 buffer[5];\n\tstruct i2c_msg msg;\n\n\tbuffer[0] = dev;\n\tbuffer[1] = addr >> 8;\n\tbuffer[2] = addr & 0xff;\n\tbuffer[3] = val >> 8;\n\tbuffer[4] = val & 0xff;\n\tmsg.addr = client->addr;\n\tmsg.flags = 0;\n\tmsg.len = 5;\n\tmsg.buf = buffer;\n\ti2c_transfer(client->adapter, &msg, 1);\n\treturn 0;\n}\n\n \n\nstatic const struct {\n\tenum { AUD_MONO, AUD_A2, AUD_NICAM, AUD_NICAM_L } audio_mode;\n\tu16 modus;\n\tu16 source;\n\tu16 acb;\n\tu16 fm_prescale;\n\tu16 nicam_prescale;\n\tu16 scart_prescale;\n\tu16 system;\n\tu16 volume;\n} mpx_audio_modes[] = {\n\t \t{ AUD_MONO,\t0x1003, 0x0020, 0x0100, 0x2603,\n\t\t\t\t\t0x5000, 0x0000, 0x0001, 0x7500 },\n\t \t{ AUD_MONO,\t0x1003, 0x0020, 0x0100, 0x2603,\n\t\t\t\t\t0x5000, 0x0000, 0x0003, 0x7500 },\n\t \t{ AUD_A2,\t0x1003, 0x0020, 0x0100, 0x2601,\n\t\t\t\t\t0x5000, 0x0000, 0x0003, 0x7500 },\n\t  { AUD_NICAM,\t0x1003, 0x0120, 0x0100, 0x2603,\n\t\t\t\t\t0x5000, 0x0000, 0x0008, 0x7500 },\n\t \t{ AUD_MONO,\t0x1003, 0x0020, 0x0100, 0x2603,\n\t\t\t\t\t0x7900, 0x0000, 0x000A, 0x7500 },\n\t \t{ AUD_NICAM,\t0x1003, 0x0120, 0x0100, 0x2603,\n\t\t\t\t\t0x7900, 0x0000, 0x000A, 0x7500 },\n\t \t{ AUD_MONO,\t0x1003, 0x0020, 0x0100, 0x2603,\n\t\t\t\t\t0x5000, 0x0000, 0x0004, 0x7500 },\n\t \t{ AUD_A2,\t0x1003, 0x0020, 0x0100, 0x2601,\n\t\t\t\t\t0x5000, 0x0000, 0x0004, 0x7500 },\n\t \t{ AUD_A2,\t0x1003, 0x0020, 0x0100, 0x2601,\n\t\t\t\t\t0x5000, 0x0000, 0x0005, 0x7500 },\n\t \t{ AUD_A2,\t0x1003, 0x0020, 0x0100, 0x2601,\n\t\t\t\t\t0x5000, 0x0000, 0x0007, 0x7500 },\n\t \t{ AUD_NICAM,\t0x1003, 0x0120, 0x0100, 0x2603,\n\t\t\t\t\t0x5000, 0x0000, 0x000B, 0x7500 },\n\t \t{ AUD_MONO,\t0x0003, 0x0200, 0x0100, 0x7C03,\n\t\t\t\t\t0x5000, 0x2200, 0x0009, 0x7500 },\n\t { AUD_NICAM_L,\t0x0003, 0x0120, 0x0100, 0x7C03,\n\t\t\t\t\t0x5000, 0x0000, 0x0009, 0x7500 },\n};\n\n#define MPX_NUM_MODES\tARRAY_SIZE(mpx_audio_modes)\n\nstatic int mpx_setup(struct sony_btf_mpx *t)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&t->sd);\n\tu16 source = 0;\n\tu8 buffer[3];\n\tstruct i2c_msg msg;\n\tint mode = t->mpxmode;\n\n\t \n\tbuffer[0] = 0x00;\n\tbuffer[1] = 0x80;\n\tbuffer[2] = 0x00;\n\tmsg.addr = client->addr;\n\tmsg.flags = 0;\n\tmsg.len = 3;\n\tmsg.buf = buffer;\n\ti2c_transfer(client->adapter, &msg, 1);\n\tbuffer[1] = 0x00;\n\ti2c_transfer(client->adapter, &msg, 1);\n\n\tif (t->audmode != V4L2_TUNER_MODE_MONO)\n\t\tmode++;\n\n\tif (mpx_audio_modes[mode].audio_mode != AUD_MONO) {\n\t\tswitch (t->audmode) {\n\t\tcase V4L2_TUNER_MODE_MONO:\n\t\t\tswitch (mpx_audio_modes[mode].audio_mode) {\n\t\t\tcase AUD_A2:\n\t\t\t\tsource = mpx_audio_modes[mode].source;\n\t\t\t\tbreak;\n\t\t\tcase AUD_NICAM:\n\t\t\t\tsource = 0x0000;\n\t\t\t\tbreak;\n\t\t\tcase AUD_NICAM_L:\n\t\t\t\tsource = 0x0200;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase V4L2_TUNER_MODE_STEREO:\n\t\t\tsource = mpx_audio_modes[mode].source;\n\t\t\tbreak;\n\t\tcase V4L2_TUNER_MODE_LANG1:\n\t\t\tsource = 0x0300;\n\t\t\tbreak;\n\t\tcase V4L2_TUNER_MODE_LANG2:\n\t\t\tsource = 0x0400;\n\t\t\tbreak;\n\t\t}\n\t\tsource |= mpx_audio_modes[mode].source & 0x00ff;\n\t} else\n\t\tsource = mpx_audio_modes[mode].source;\n\n\tmpx_write(client, 0x10, 0x0030, mpx_audio_modes[mode].modus);\n\tmpx_write(client, 0x12, 0x0008, source);\n\tmpx_write(client, 0x12, 0x0013, mpx_audio_modes[mode].acb);\n\tmpx_write(client, 0x12, 0x000e,\n\t\t\tmpx_audio_modes[mode].fm_prescale);\n\tmpx_write(client, 0x12, 0x0010,\n\t\t\tmpx_audio_modes[mode].nicam_prescale);\n\tmpx_write(client, 0x12, 0x000d,\n\t\t\tmpx_audio_modes[mode].scart_prescale);\n\tmpx_write(client, 0x10, 0x0020, mpx_audio_modes[mode].system);\n\tmpx_write(client, 0x12, 0x0000, mpx_audio_modes[mode].volume);\n\tif (mpx_audio_modes[mode].audio_mode == AUD_A2)\n\t\tmpx_write(client, 0x10, 0x0022,\n\t\t\tt->audmode == V4L2_TUNER_MODE_MONO ? 0x07f0 : 0x0190);\n\n#ifdef MPX_DEBUG\n\t{\n\t\tu8 buf1[3], buf2[2];\n\t\tstruct i2c_msg msgs[2];\n\n\t\tv4l2_info(client,\n\t\t\t\"MPX registers: %04x %04x %04x %04x %04x %04x %04x %04x\\n\",\n\t\t\tmpx_audio_modes[mode].modus,\n\t\t\tsource,\n\t\t\tmpx_audio_modes[mode].acb,\n\t\t\tmpx_audio_modes[mode].fm_prescale,\n\t\t\tmpx_audio_modes[mode].nicam_prescale,\n\t\t\tmpx_audio_modes[mode].scart_prescale,\n\t\t\tmpx_audio_modes[mode].system,\n\t\t\tmpx_audio_modes[mode].volume);\n\t\tbuf1[0] = 0x11;\n\t\tbuf1[1] = 0x00;\n\t\tbuf1[2] = 0x7e;\n\t\tmsgs[0].addr = client->addr;\n\t\tmsgs[0].flags = 0;\n\t\tmsgs[0].len = 3;\n\t\tmsgs[0].buf = buf1;\n\t\tmsgs[1].addr = client->addr;\n\t\tmsgs[1].flags = I2C_M_RD;\n\t\tmsgs[1].len = 2;\n\t\tmsgs[1].buf = buf2;\n\t\ti2c_transfer(client->adapter, msgs, 2);\n\t\tv4l2_info(client, \"MPX system: %02x%02x\\n\",\n\t\t\t\tbuf2[0], buf2[1]);\n\t\tbuf1[0] = 0x11;\n\t\tbuf1[1] = 0x02;\n\t\tbuf1[2] = 0x00;\n\t\ti2c_transfer(client->adapter, msgs, 2);\n\t\tv4l2_info(client, \"MPX status: %02x%02x\\n\",\n\t\t\t\tbuf2[0], buf2[1]);\n\t}\n#endif\n\treturn 0;\n}\n\n\nstatic int sony_btf_mpx_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct sony_btf_mpx *t = to_state(sd);\n\tint default_mpx_mode = 0;\n\n\tif (std & V4L2_STD_PAL_BG)\n\t\tdefault_mpx_mode = 1;\n\telse if (std & V4L2_STD_PAL_I)\n\t\tdefault_mpx_mode = 4;\n\telse if (std & V4L2_STD_PAL_DK)\n\t\tdefault_mpx_mode = 6;\n\telse if (std & V4L2_STD_SECAM_L)\n\t\tdefault_mpx_mode = 11;\n\n\tif (default_mpx_mode != t->mpxmode) {\n\t\tt->mpxmode = default_mpx_mode;\n\t\tmpx_setup(t);\n\t}\n\treturn 0;\n}\n\nstatic int sony_btf_mpx_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\n{\n\tstruct sony_btf_mpx *t = to_state(sd);\n\n\tvt->capability = V4L2_TUNER_CAP_NORM |\n\t\tV4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_LANG1 |\n\t\tV4L2_TUNER_CAP_LANG2;\n\tvt->rxsubchans = V4L2_TUNER_SUB_MONO |\n\t\tV4L2_TUNER_SUB_STEREO | V4L2_TUNER_SUB_LANG1 |\n\t\tV4L2_TUNER_SUB_LANG2;\n\tvt->audmode = t->audmode;\n\treturn 0;\n}\n\nstatic int sony_btf_mpx_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *vt)\n{\n\tstruct sony_btf_mpx *t = to_state(sd);\n\n\tif (vt->type != V4L2_TUNER_ANALOG_TV)\n\t\treturn -EINVAL;\n\n\tif (vt->audmode != t->audmode) {\n\t\tt->audmode = vt->audmode;\n\t\tmpx_setup(t);\n\t}\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_subdev_tuner_ops sony_btf_mpx_tuner_ops = {\n\t.s_tuner = sony_btf_mpx_s_tuner,\n\t.g_tuner = sony_btf_mpx_g_tuner,\n};\n\nstatic const struct v4l2_subdev_video_ops sony_btf_mpx_video_ops = {\n\t.s_std = sony_btf_mpx_s_std,\n};\n\nstatic const struct v4l2_subdev_ops sony_btf_mpx_ops = {\n\t.tuner = &sony_btf_mpx_tuner_ops,\n\t.video = &sony_btf_mpx_video_ops,\n};\n\n \n\nstatic int sony_btf_mpx_probe(struct i2c_client *client)\n{\n\tstruct sony_btf_mpx *t;\n\tstruct v4l2_subdev *sd;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_I2C_BLOCK))\n\t\treturn -ENODEV;\n\n\tv4l_info(client, \"chip found @ 0x%x (%s)\\n\",\n\t\t\tclient->addr << 1, client->adapter->name);\n\n\tt = devm_kzalloc(&client->dev, sizeof(*t), GFP_KERNEL);\n\tif (t == NULL)\n\t\treturn -ENOMEM;\n\n\tsd = &t->sd;\n\tv4l2_i2c_subdev_init(sd, client, &sony_btf_mpx_ops);\n\n\t \n\tt->mpxmode = 0;\n\tt->audmode = V4L2_TUNER_MODE_STEREO;\n\n\treturn 0;\n}\n\nstatic void sony_btf_mpx_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\n\tv4l2_device_unregister_subdev(sd);\n}\n\n \n\nstatic const struct i2c_device_id sony_btf_mpx_id[] = {\n\t{ \"sony-btf-mpx\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, sony_btf_mpx_id);\n\nstatic struct i2c_driver sony_btf_mpx_driver = {\n\t.driver = {\n\t\t.name\t= \"sony-btf-mpx\",\n\t},\n\t.probe = sony_btf_mpx_probe,\n\t.remove = sony_btf_mpx_remove,\n\t.id_table = sony_btf_mpx_id,\n};\nmodule_i2c_driver(sony_btf_mpx_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}