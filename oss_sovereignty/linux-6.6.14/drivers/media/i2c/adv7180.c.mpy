{
  "module_name": "adv7180.c",
  "hash_id": "a82498d96e6d8313c470bc8c01f42c69328c3de5c8b37cb8e8144920d75d204c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/adv7180.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/gpio/consumer.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n\n#define ADV7180_STD_AD_PAL_BG_NTSC_J_SECAM\t\t0x0\n#define ADV7180_STD_AD_PAL_BG_NTSC_J_SECAM_PED\t\t0x1\n#define ADV7180_STD_AD_PAL_N_NTSC_J_SECAM\t\t0x2\n#define ADV7180_STD_AD_PAL_N_NTSC_M_SECAM\t\t0x3\n#define ADV7180_STD_NTSC_J\t\t\t\t0x4\n#define ADV7180_STD_NTSC_M\t\t\t\t0x5\n#define ADV7180_STD_PAL60\t\t\t\t0x6\n#define ADV7180_STD_NTSC_443\t\t\t\t0x7\n#define ADV7180_STD_PAL_BG\t\t\t\t0x8\n#define ADV7180_STD_PAL_N\t\t\t\t0x9\n#define ADV7180_STD_PAL_M\t\t\t\t0xa\n#define ADV7180_STD_PAL_M_PED\t\t\t\t0xb\n#define ADV7180_STD_PAL_COMB_N\t\t\t\t0xc\n#define ADV7180_STD_PAL_COMB_N_PED\t\t\t0xd\n#define ADV7180_STD_PAL_SECAM\t\t\t\t0xe\n#define ADV7180_STD_PAL_SECAM_PED\t\t\t0xf\n\n#define ADV7180_REG_INPUT_CONTROL\t\t\t0x0000\n#define ADV7180_INPUT_CONTROL_INSEL_MASK\t\t0x0f\n\n#define ADV7182_REG_INPUT_VIDSEL\t\t\t0x0002\n#define ADV7182_REG_INPUT_RESERVED\t\t\tBIT(2)\n\n#define ADV7180_REG_OUTPUT_CONTROL\t\t\t0x0003\n#define ADV7180_REG_EXTENDED_OUTPUT_CONTROL\t\t0x0004\n#define ADV7180_EXTENDED_OUTPUT_CONTROL_NTSCDIS\t\t0xC5\n\n#define ADV7180_REG_AUTODETECT_ENABLE\t\t\t0x0007\n#define ADV7180_AUTODETECT_DEFAULT\t\t\t0x7f\n \n#define ADV7180_REG_CON\t\t0x0008\t \n#define ADV7180_CON_MIN\t\t0\n#define ADV7180_CON_DEF\t\t128\n#define ADV7180_CON_MAX\t\t255\n \n#define ADV7180_REG_BRI\t\t0x000a\t \n#define ADV7180_BRI_MIN\t\t-128\n#define ADV7180_BRI_DEF\t\t0\n#define ADV7180_BRI_MAX\t\t127\n \n#define ADV7180_REG_HUE\t\t0x000b\t \n#define ADV7180_HUE_MIN\t\t-127\n#define ADV7180_HUE_DEF\t\t0\n#define ADV7180_HUE_MAX\t\t128\n\n#define ADV7180_REG_DEF_VALUE_Y\t0x000c\n#define ADV7180_DEF_VAL_EN\t\t0x1\n#define ADV7180_DEF_VAL_AUTO_EN\t0x2\n#define ADV7180_REG_CTRL\t\t0x000e\n#define ADV7180_CTRL_IRQ_SPACE\t\t0x20\n\n#define ADV7180_REG_PWR_MAN\t\t0x0f\n#define ADV7180_PWR_MAN_ON\t\t0x04\n#define ADV7180_PWR_MAN_OFF\t\t0x24\n#define ADV7180_PWR_MAN_RES\t\t0x80\n\n#define ADV7180_REG_STATUS1\t\t0x0010\n#define ADV7180_STATUS1_IN_LOCK\t\t0x01\n#define ADV7180_STATUS1_AUTOD_MASK\t0x70\n#define ADV7180_STATUS1_AUTOD_NTSM_M_J\t0x00\n#define ADV7180_STATUS1_AUTOD_NTSC_4_43 0x10\n#define ADV7180_STATUS1_AUTOD_PAL_M\t0x20\n#define ADV7180_STATUS1_AUTOD_PAL_60\t0x30\n#define ADV7180_STATUS1_AUTOD_PAL_B_G\t0x40\n#define ADV7180_STATUS1_AUTOD_SECAM\t0x50\n#define ADV7180_STATUS1_AUTOD_PAL_COMB\t0x60\n#define ADV7180_STATUS1_AUTOD_SECAM_525\t0x70\n\n#define ADV7180_REG_IDENT 0x0011\n#define ADV7180_ID_7180 0x18\n\n#define ADV7180_REG_STATUS3\t\t0x0013\n#define ADV7180_REG_ANALOG_CLAMP_CTL\t0x0014\n#define ADV7180_REG_SHAP_FILTER_CTL_1\t0x0017\n#define ADV7180_REG_CTRL_2\t\t0x001d\n#define ADV7180_REG_VSYNC_FIELD_CTL_1\t0x0031\n#define ADV7180_VSYNC_FIELD_CTL_1_NEWAV 0x12\n#define ADV7180_REG_MANUAL_WIN_CTL_1\t0x003d\n#define ADV7180_REG_MANUAL_WIN_CTL_2\t0x003e\n#define ADV7180_REG_MANUAL_WIN_CTL_3\t0x003f\n#define ADV7180_REG_LOCK_CNT\t\t0x0051\n#define ADV7180_REG_CVBS_TRIM\t\t0x0052\n#define ADV7180_REG_CLAMP_ADJ\t\t0x005a\n#define ADV7180_REG_RES_CIR\t\t0x005f\n#define ADV7180_REG_DIFF_MODE\t\t0x0060\n\n#define ADV7180_REG_ICONF1\t\t0x2040\n#define ADV7180_ICONF1_ACTIVE_LOW\t0x01\n#define ADV7180_ICONF1_PSYNC_ONLY\t0x10\n#define ADV7180_ICONF1_ACTIVE_TO_CLR\t0xC0\n \n#define ADV7180_REG_SD_SAT_CB\t0x00e3\t \n#define ADV7180_REG_SD_SAT_CR\t0x00e4\t \n#define ADV7180_SAT_MIN\t\t0\n#define ADV7180_SAT_DEF\t\t128\n#define ADV7180_SAT_MAX\t\t255\n\n#define ADV7180_IRQ1_LOCK\t0x01\n#define ADV7180_IRQ1_UNLOCK\t0x02\n#define ADV7180_REG_ISR1\t0x2042\n#define ADV7180_REG_ICR1\t0x2043\n#define ADV7180_REG_IMR1\t0x2044\n#define ADV7180_REG_IMR2\t0x2048\n#define ADV7180_IRQ3_AD_CHANGE\t0x08\n#define ADV7180_REG_ISR3\t0x204A\n#define ADV7180_REG_ICR3\t0x204B\n#define ADV7180_REG_IMR3\t0x204C\n#define ADV7180_REG_IMR4\t0x2050\n\n#define ADV7180_REG_NTSC_V_BIT_END\t0x00E6\n#define ADV7180_NTSC_V_BIT_END_MANUAL_NVEND\t0x4F\n\n#define ADV7180_REG_VPP_SLAVE_ADDR\t0xFD\n#define ADV7180_REG_CSI_SLAVE_ADDR\t0xFE\n\n#define ADV7180_REG_ACE_CTRL1\t\t0x4080\n#define ADV7180_REG_ACE_CTRL5\t\t0x4084\n#define ADV7180_REG_FLCONTROL\t\t0x40e0\n#define ADV7180_FLCONTROL_FL_ENABLE 0x1\n\n#define ADV7180_REG_RST_CLAMP\t0x809c\n#define ADV7180_REG_AGC_ADJ1\t0x80b6\n#define ADV7180_REG_AGC_ADJ2\t0x80c0\n\n#define ADV7180_CSI_REG_PWRDN\t0x00\n#define ADV7180_CSI_PWRDN\t0x80\n\n#define ADV7180_INPUT_CVBS_AIN1 0x00\n#define ADV7180_INPUT_CVBS_AIN2 0x01\n#define ADV7180_INPUT_CVBS_AIN3 0x02\n#define ADV7180_INPUT_CVBS_AIN4 0x03\n#define ADV7180_INPUT_CVBS_AIN5 0x04\n#define ADV7180_INPUT_CVBS_AIN6 0x05\n#define ADV7180_INPUT_SVIDEO_AIN1_AIN2 0x06\n#define ADV7180_INPUT_SVIDEO_AIN3_AIN4 0x07\n#define ADV7180_INPUT_SVIDEO_AIN5_AIN6 0x08\n#define ADV7180_INPUT_YPRPB_AIN1_AIN2_AIN3 0x09\n#define ADV7180_INPUT_YPRPB_AIN4_AIN5_AIN6 0x0a\n\n#define ADV7182_INPUT_CVBS_AIN1 0x00\n#define ADV7182_INPUT_CVBS_AIN2 0x01\n#define ADV7182_INPUT_CVBS_AIN3 0x02\n#define ADV7182_INPUT_CVBS_AIN4 0x03\n#define ADV7182_INPUT_CVBS_AIN5 0x04\n#define ADV7182_INPUT_CVBS_AIN6 0x05\n#define ADV7182_INPUT_CVBS_AIN7 0x06\n#define ADV7182_INPUT_CVBS_AIN8 0x07\n#define ADV7182_INPUT_SVIDEO_AIN1_AIN2 0x08\n#define ADV7182_INPUT_SVIDEO_AIN3_AIN4 0x09\n#define ADV7182_INPUT_SVIDEO_AIN5_AIN6 0x0a\n#define ADV7182_INPUT_SVIDEO_AIN7_AIN8 0x0b\n#define ADV7182_INPUT_YPRPB_AIN1_AIN2_AIN3 0x0c\n#define ADV7182_INPUT_YPRPB_AIN4_AIN5_AIN6 0x0d\n#define ADV7182_INPUT_DIFF_CVBS_AIN1_AIN2 0x0e\n#define ADV7182_INPUT_DIFF_CVBS_AIN3_AIN4 0x0f\n#define ADV7182_INPUT_DIFF_CVBS_AIN5_AIN6 0x10\n#define ADV7182_INPUT_DIFF_CVBS_AIN7_AIN8 0x11\n\n#define ADV7180_DEFAULT_CSI_I2C_ADDR 0x44\n#define ADV7180_DEFAULT_VPP_I2C_ADDR 0x42\n\n#define V4L2_CID_ADV_FAST_SWITCH\t(V4L2_CID_USER_ADV7180_BASE + 0x00)\n\n \n#define ADV7180_NUM_OF_SKIP_FRAMES       2\n\nstruct adv7180_state;\n\n#define ADV7180_FLAG_RESET_POWERED\tBIT(0)\n#define ADV7180_FLAG_V2\t\t\tBIT(1)\n#define ADV7180_FLAG_MIPI_CSI2\t\tBIT(2)\n#define ADV7180_FLAG_I2P\t\tBIT(3)\n\nstruct adv7180_chip_info {\n\tunsigned int flags;\n\tunsigned int valid_input_mask;\n\tint (*set_std)(struct adv7180_state *st, unsigned int std);\n\tint (*select_input)(struct adv7180_state *st, unsigned int input);\n\tint (*init)(struct adv7180_state *state);\n};\n\nstruct adv7180_state {\n\tstruct v4l2_ctrl_handler ctrl_hdl;\n\tstruct v4l2_subdev\tsd;\n\tstruct media_pad\tpad;\n\tstruct mutex\t\tmutex;  \n\tint\t\t\tirq;\n\tstruct gpio_desc\t*pwdn_gpio;\n\tstruct gpio_desc\t*rst_gpio;\n\tv4l2_std_id\t\tcurr_norm;\n\tbool\t\t\tpowered;\n\tbool\t\t\tstreaming;\n\tu8\t\t\tinput;\n\n\tstruct i2c_client\t*client;\n\tunsigned int\t\tregister_page;\n\tstruct i2c_client\t*csi_client;\n\tstruct i2c_client\t*vpp_client;\n\tconst struct adv7180_chip_info *chip_info;\n\tenum v4l2_field\t\tfield;\n\tbool\t\t\tforce_bt656_4;\n};\n#define to_adv7180_sd(_ctrl) (&container_of(_ctrl->handler,\t\t\\\n\t\t\t\t\t    struct adv7180_state,\t\\\n\t\t\t\t\t    ctrl_hdl)->sd)\n\nstatic int adv7180_select_page(struct adv7180_state *state, unsigned int page)\n{\n\tif (state->register_page != page) {\n\t\ti2c_smbus_write_byte_data(state->client, ADV7180_REG_CTRL,\n\t\t\tpage);\n\t\tstate->register_page = page;\n\t}\n\n\treturn 0;\n}\n\nstatic int adv7180_write(struct adv7180_state *state, unsigned int reg,\n\tunsigned int value)\n{\n\tlockdep_assert_held(&state->mutex);\n\tadv7180_select_page(state, reg >> 8);\n\treturn i2c_smbus_write_byte_data(state->client, reg & 0xff, value);\n}\n\nstatic int adv7180_read(struct adv7180_state *state, unsigned int reg)\n{\n\tlockdep_assert_held(&state->mutex);\n\tadv7180_select_page(state, reg >> 8);\n\treturn i2c_smbus_read_byte_data(state->client, reg & 0xff);\n}\n\nstatic int adv7180_csi_write(struct adv7180_state *state, unsigned int reg,\n\tunsigned int value)\n{\n\treturn i2c_smbus_write_byte_data(state->csi_client, reg, value);\n}\n\nstatic int adv7180_set_video_standard(struct adv7180_state *state,\n\tunsigned int std)\n{\n\treturn state->chip_info->set_std(state, std);\n}\n\nstatic int adv7180_vpp_write(struct adv7180_state *state, unsigned int reg,\n\tunsigned int value)\n{\n\treturn i2c_smbus_write_byte_data(state->vpp_client, reg, value);\n}\n\nstatic v4l2_std_id adv7180_std_to_v4l2(u8 status1)\n{\n\t \n\tif (!(status1 & ADV7180_STATUS1_IN_LOCK))\n\t\treturn V4L2_STD_UNKNOWN;\n\n\tswitch (status1 & ADV7180_STATUS1_AUTOD_MASK) {\n\tcase ADV7180_STATUS1_AUTOD_NTSM_M_J:\n\t\treturn V4L2_STD_NTSC;\n\tcase ADV7180_STATUS1_AUTOD_NTSC_4_43:\n\t\treturn V4L2_STD_NTSC_443;\n\tcase ADV7180_STATUS1_AUTOD_PAL_M:\n\t\treturn V4L2_STD_PAL_M;\n\tcase ADV7180_STATUS1_AUTOD_PAL_60:\n\t\treturn V4L2_STD_PAL_60;\n\tcase ADV7180_STATUS1_AUTOD_PAL_B_G:\n\t\treturn V4L2_STD_PAL;\n\tcase ADV7180_STATUS1_AUTOD_SECAM:\n\t\treturn V4L2_STD_SECAM;\n\tcase ADV7180_STATUS1_AUTOD_PAL_COMB:\n\t\treturn V4L2_STD_PAL_Nc | V4L2_STD_PAL_N;\n\tcase ADV7180_STATUS1_AUTOD_SECAM_525:\n\t\treturn V4L2_STD_SECAM;\n\tdefault:\n\t\treturn V4L2_STD_UNKNOWN;\n\t}\n}\n\nstatic int v4l2_std_to_adv7180(v4l2_std_id std)\n{\n\tif (std == V4L2_STD_PAL_60)\n\t\treturn ADV7180_STD_PAL60;\n\tif (std == V4L2_STD_NTSC_443)\n\t\treturn ADV7180_STD_NTSC_443;\n\tif (std == V4L2_STD_PAL_N)\n\t\treturn ADV7180_STD_PAL_N;\n\tif (std == V4L2_STD_PAL_M)\n\t\treturn ADV7180_STD_PAL_M;\n\tif (std == V4L2_STD_PAL_Nc)\n\t\treturn ADV7180_STD_PAL_COMB_N;\n\n\tif (std & V4L2_STD_PAL)\n\t\treturn ADV7180_STD_PAL_BG;\n\tif (std & V4L2_STD_NTSC)\n\t\treturn ADV7180_STD_NTSC_M;\n\tif (std & V4L2_STD_SECAM)\n\t\treturn ADV7180_STD_PAL_SECAM;\n\n\treturn -EINVAL;\n}\n\nstatic u32 adv7180_status_to_v4l2(u8 status1)\n{\n\tif (!(status1 & ADV7180_STATUS1_IN_LOCK))\n\t\treturn V4L2_IN_ST_NO_SIGNAL;\n\n\treturn 0;\n}\n\nstatic int __adv7180_status(struct adv7180_state *state, u32 *status,\n\t\t\t    v4l2_std_id *std)\n{\n\tint status1 = adv7180_read(state, ADV7180_REG_STATUS1);\n\n\tif (status1 < 0)\n\t\treturn status1;\n\n\tif (status)\n\t\t*status = adv7180_status_to_v4l2(status1);\n\tif (std)\n\t\t*std = adv7180_std_to_v4l2(status1);\n\n\treturn 0;\n}\n\nstatic inline struct adv7180_state *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct adv7180_state, sd);\n}\n\nstatic int adv7180_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)\n{\n\tstruct adv7180_state *state = to_state(sd);\n\tint err = mutex_lock_interruptible(&state->mutex);\n\tif (err)\n\t\treturn err;\n\n\tif (state->streaming) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\terr = adv7180_set_video_standard(state,\n\t\t\tADV7180_STD_AD_PAL_BG_NTSC_J_SECAM);\n\tif (err)\n\t\tgoto unlock;\n\n\tmsleep(100);\n\t__adv7180_status(state, NULL, std);\n\n\terr = v4l2_std_to_adv7180(state->curr_norm);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\terr = adv7180_set_video_standard(state, err);\n\nunlock:\n\tmutex_unlock(&state->mutex);\n\treturn err;\n}\n\nstatic int adv7180_s_routing(struct v4l2_subdev *sd, u32 input,\n\t\t\t     u32 output, u32 config)\n{\n\tstruct adv7180_state *state = to_state(sd);\n\tint ret = mutex_lock_interruptible(&state->mutex);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (input > 31 || !(BIT(input) & state->chip_info->valid_input_mask)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = state->chip_info->select_input(state, input);\n\n\tif (ret == 0)\n\t\tstate->input = input;\nout:\n\tmutex_unlock(&state->mutex);\n\treturn ret;\n}\n\nstatic int adv7180_g_input_status(struct v4l2_subdev *sd, u32 *status)\n{\n\tstruct adv7180_state *state = to_state(sd);\n\tint ret = mutex_lock_interruptible(&state->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __adv7180_status(state, status, NULL);\n\tmutex_unlock(&state->mutex);\n\treturn ret;\n}\n\nstatic int adv7180_program_std(struct adv7180_state *state)\n{\n\tint ret;\n\n\tret = v4l2_std_to_adv7180(state->curr_norm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = adv7180_set_video_standard(state, ret);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic int adv7180_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct adv7180_state *state = to_state(sd);\n\tint ret = mutex_lock_interruptible(&state->mutex);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = v4l2_std_to_adv7180(std);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tstate->curr_norm = std;\n\n\tret = adv7180_program_std(state);\nout:\n\tmutex_unlock(&state->mutex);\n\treturn ret;\n}\n\nstatic int adv7180_g_std(struct v4l2_subdev *sd, v4l2_std_id *norm)\n{\n\tstruct adv7180_state *state = to_state(sd);\n\n\t*norm = state->curr_norm;\n\n\treturn 0;\n}\n\nstatic int adv7180_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_frame_interval *fi)\n{\n\tstruct adv7180_state *state = to_state(sd);\n\n\tif (state->curr_norm & V4L2_STD_525_60) {\n\t\tfi->interval.numerator = 1001;\n\t\tfi->interval.denominator = 30000;\n\t} else {\n\t\tfi->interval.numerator = 1;\n\t\tfi->interval.denominator = 25;\n\t}\n\n\treturn 0;\n}\n\nstatic void adv7180_set_power_pin(struct adv7180_state *state, bool on)\n{\n\tif (!state->pwdn_gpio)\n\t\treturn;\n\n\tif (on) {\n\t\tgpiod_set_value_cansleep(state->pwdn_gpio, 0);\n\t\tusleep_range(5000, 10000);\n\t} else {\n\t\tgpiod_set_value_cansleep(state->pwdn_gpio, 1);\n\t}\n}\n\nstatic void adv7180_set_reset_pin(struct adv7180_state *state, bool on)\n{\n\tif (!state->rst_gpio)\n\t\treturn;\n\n\tif (on) {\n\t\tgpiod_set_value_cansleep(state->rst_gpio, 1);\n\t} else {\n\t\tgpiod_set_value_cansleep(state->rst_gpio, 0);\n\t\tusleep_range(5000, 10000);\n\t}\n}\n\nstatic int adv7180_set_power(struct adv7180_state *state, bool on)\n{\n\tu8 val;\n\tint ret;\n\n\tif (on)\n\t\tval = ADV7180_PWR_MAN_ON;\n\telse\n\t\tval = ADV7180_PWR_MAN_OFF;\n\n\tret = adv7180_write(state, ADV7180_REG_PWR_MAN, val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (state->chip_info->flags & ADV7180_FLAG_MIPI_CSI2) {\n\t\tif (on) {\n\t\t\tadv7180_csi_write(state, 0xDE, 0x02);\n\t\t\tadv7180_csi_write(state, 0xD2, 0xF7);\n\t\t\tadv7180_csi_write(state, 0xD8, 0x65);\n\t\t\tadv7180_csi_write(state, 0xE0, 0x09);\n\t\t\tadv7180_csi_write(state, 0x2C, 0x00);\n\t\t\tif (state->field == V4L2_FIELD_NONE)\n\t\t\t\tadv7180_csi_write(state, 0x1D, 0x80);\n\t\t\tadv7180_csi_write(state, 0x00, 0x00);\n\t\t} else {\n\t\t\tadv7180_csi_write(state, 0x00, 0x80);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int adv7180_s_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct adv7180_state *state = to_state(sd);\n\tint ret;\n\n\tret = mutex_lock_interruptible(&state->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adv7180_set_power(state, on);\n\tif (ret == 0)\n\t\tstate->powered = on;\n\n\tmutex_unlock(&state->mutex);\n\treturn ret;\n}\n\nstatic const char * const test_pattern_menu[] = {\n\t\"Single color\",\n\t\"Color bars\",\n\t\"Luma ramp\",\n\t\"Boundary box\",\n\t\"Disable\",\n};\n\nstatic int adv7180_test_pattern(struct adv7180_state *state, int value)\n{\n\tunsigned int reg = 0;\n\n\t \n\tif (value < 3)\n\t\treg = value;\n\tif (value == 3)\n\t\treg = 5;\n\n\tadv7180_write(state, ADV7180_REG_ANALOG_CLAMP_CTL, reg);\n\n\tif (value == ARRAY_SIZE(test_pattern_menu) - 1) {\n\t\treg = adv7180_read(state, ADV7180_REG_DEF_VALUE_Y);\n\t\treg &= ~ADV7180_DEF_VAL_EN;\n\t\tadv7180_write(state, ADV7180_REG_DEF_VALUE_Y, reg);\n\t\treturn 0;\n\t}\n\n\treg = adv7180_read(state, ADV7180_REG_DEF_VALUE_Y);\n\treg |= ADV7180_DEF_VAL_EN | ADV7180_DEF_VAL_AUTO_EN;\n\tadv7180_write(state, ADV7180_REG_DEF_VALUE_Y, reg);\n\n\treturn 0;\n}\n\nstatic int adv7180_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *sd = to_adv7180_sd(ctrl);\n\tstruct adv7180_state *state = to_state(sd);\n\tint ret = mutex_lock_interruptible(&state->mutex);\n\tint val;\n\n\tif (ret)\n\t\treturn ret;\n\tval = ctrl->val;\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tret = adv7180_write(state, ADV7180_REG_BRI, val);\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\t \n\t\tret = adv7180_write(state, ADV7180_REG_HUE, -val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tret = adv7180_write(state, ADV7180_REG_CON, val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\t \n\t\tret = adv7180_write(state, ADV7180_REG_SD_SAT_CB, val);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tret = adv7180_write(state, ADV7180_REG_SD_SAT_CR, val);\n\t\tbreak;\n\tcase V4L2_CID_ADV_FAST_SWITCH:\n\t\tif (ctrl->val) {\n\t\t\t \n\t\t\tadv7180_write(state, 0x80d9, 0x44);\n\t\t\tadv7180_write(state, ADV7180_REG_FLCONTROL,\n\t\t\t\tADV7180_FLCONTROL_FL_ENABLE);\n\t\t} else {\n\t\t\t \n\t\t\tadv7180_write(state, 0x80d9, 0xc4);\n\t\t\tadv7180_write(state, ADV7180_REG_FLCONTROL, 0x00);\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tret = adv7180_test_pattern(state, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&state->mutex);\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops adv7180_ctrl_ops = {\n\t.s_ctrl = adv7180_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config adv7180_ctrl_fast_switch = {\n\t.ops = &adv7180_ctrl_ops,\n\t.id = V4L2_CID_ADV_FAST_SWITCH,\n\t.name = \"Fast Switching\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.min = 0,\n\t.max = 1,\n\t.step = 1,\n};\n\nstatic int adv7180_init_controls(struct adv7180_state *state)\n{\n\tv4l2_ctrl_handler_init(&state->ctrl_hdl, 4);\n\n\tv4l2_ctrl_new_std(&state->ctrl_hdl, &adv7180_ctrl_ops,\n\t\t\t  V4L2_CID_BRIGHTNESS, ADV7180_BRI_MIN,\n\t\t\t  ADV7180_BRI_MAX, 1, ADV7180_BRI_DEF);\n\tv4l2_ctrl_new_std(&state->ctrl_hdl, &adv7180_ctrl_ops,\n\t\t\t  V4L2_CID_CONTRAST, ADV7180_CON_MIN,\n\t\t\t  ADV7180_CON_MAX, 1, ADV7180_CON_DEF);\n\tv4l2_ctrl_new_std(&state->ctrl_hdl, &adv7180_ctrl_ops,\n\t\t\t  V4L2_CID_SATURATION, ADV7180_SAT_MIN,\n\t\t\t  ADV7180_SAT_MAX, 1, ADV7180_SAT_DEF);\n\tv4l2_ctrl_new_std(&state->ctrl_hdl, &adv7180_ctrl_ops,\n\t\t\t  V4L2_CID_HUE, ADV7180_HUE_MIN,\n\t\t\t  ADV7180_HUE_MAX, 1, ADV7180_HUE_DEF);\n\tv4l2_ctrl_new_custom(&state->ctrl_hdl, &adv7180_ctrl_fast_switch, NULL);\n\n\tv4l2_ctrl_new_std_menu_items(&state->ctrl_hdl, &adv7180_ctrl_ops,\n\t\t\t\t      V4L2_CID_TEST_PATTERN,\n\t\t\t\t      ARRAY_SIZE(test_pattern_menu) - 1,\n\t\t\t\t      0, ARRAY_SIZE(test_pattern_menu) - 1,\n\t\t\t\t      test_pattern_menu);\n\n\tstate->sd.ctrl_handler = &state->ctrl_hdl;\n\tif (state->ctrl_hdl.error) {\n\t\tint err = state->ctrl_hdl.error;\n\n\t\tv4l2_ctrl_handler_free(&state->ctrl_hdl);\n\t\treturn err;\n\t}\n\tv4l2_ctrl_handler_setup(&state->ctrl_hdl);\n\n\treturn 0;\n}\nstatic void adv7180_exit_controls(struct adv7180_state *state)\n{\n\tv4l2_ctrl_handler_free(&state->ctrl_hdl);\n}\n\nstatic int adv7180_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index != 0)\n\t\treturn -EINVAL;\n\n\tcode->code = MEDIA_BUS_FMT_UYVY8_2X8;\n\n\treturn 0;\n}\n\nstatic int adv7180_mbus_fmt(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_mbus_framefmt *fmt)\n{\n\tstruct adv7180_state *state = to_state(sd);\n\n\tfmt->code = MEDIA_BUS_FMT_UYVY8_2X8;\n\tfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tfmt->width = 720;\n\tfmt->height = state->curr_norm & V4L2_STD_525_60 ? 480 : 576;\n\n\tif (state->field == V4L2_FIELD_ALTERNATE)\n\t\tfmt->height /= 2;\n\n\treturn 0;\n}\n\nstatic int adv7180_set_field_mode(struct adv7180_state *state)\n{\n\tif (!(state->chip_info->flags & ADV7180_FLAG_I2P))\n\t\treturn 0;\n\n\tif (state->field == V4L2_FIELD_NONE) {\n\t\tif (state->chip_info->flags & ADV7180_FLAG_MIPI_CSI2) {\n\t\t\tadv7180_csi_write(state, 0x01, 0x20);\n\t\t\tadv7180_csi_write(state, 0x02, 0x28);\n\t\t\tadv7180_csi_write(state, 0x03, 0x38);\n\t\t\tadv7180_csi_write(state, 0x04, 0x30);\n\t\t\tadv7180_csi_write(state, 0x05, 0x30);\n\t\t\tadv7180_csi_write(state, 0x06, 0x80);\n\t\t\tadv7180_csi_write(state, 0x07, 0x70);\n\t\t\tadv7180_csi_write(state, 0x08, 0x50);\n\t\t}\n\t\tadv7180_vpp_write(state, 0xa3, 0x00);\n\t\tadv7180_vpp_write(state, 0x5b, 0x00);\n\t\tadv7180_vpp_write(state, 0x55, 0x80);\n\t} else {\n\t\tif (state->chip_info->flags & ADV7180_FLAG_MIPI_CSI2) {\n\t\t\tadv7180_csi_write(state, 0x01, 0x18);\n\t\t\tadv7180_csi_write(state, 0x02, 0x18);\n\t\t\tadv7180_csi_write(state, 0x03, 0x30);\n\t\t\tadv7180_csi_write(state, 0x04, 0x20);\n\t\t\tadv7180_csi_write(state, 0x05, 0x28);\n\t\t\tadv7180_csi_write(state, 0x06, 0x40);\n\t\t\tadv7180_csi_write(state, 0x07, 0x58);\n\t\t\tadv7180_csi_write(state, 0x08, 0x30);\n\t\t}\n\t\tadv7180_vpp_write(state, 0xa3, 0x70);\n\t\tadv7180_vpp_write(state, 0x5b, 0x80);\n\t\tadv7180_vpp_write(state, 0x55, 0x00);\n\t}\n\n\treturn 0;\n}\n\nstatic int adv7180_get_pad_format(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct adv7180_state *state = to_state(sd);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tformat->format = *v4l2_subdev_get_try_format(sd, sd_state, 0);\n\t} else {\n\t\tadv7180_mbus_fmt(sd, &format->format);\n\t\tformat->format.field = state->field;\n\t}\n\n\treturn 0;\n}\n\nstatic int adv7180_set_pad_format(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct adv7180_state *state = to_state(sd);\n\tstruct v4l2_mbus_framefmt *framefmt;\n\tint ret;\n\n\tswitch (format->format.field) {\n\tcase V4L2_FIELD_NONE:\n\t\tif (state->chip_info->flags & ADV7180_FLAG_I2P)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tformat->format.field = V4L2_FIELD_ALTERNATE;\n\t\tbreak;\n\t}\n\n\tret = adv7180_mbus_fmt(sd,  &format->format);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\tif (state->field != format->format.field) {\n\t\t\tstate->field = format->format.field;\n\t\t\tadv7180_set_power(state, false);\n\t\t\tadv7180_set_field_mode(state);\n\t\t\tadv7180_set_power(state, true);\n\t\t}\n\t} else {\n\t\tframefmt = v4l2_subdev_get_try_format(sd, sd_state, 0);\n\t\t*framefmt = format->format;\n\t}\n\n\treturn ret;\n}\n\nstatic int adv7180_init_cfg(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state)\n{\n\tstruct v4l2_subdev_format fmt = {\n\t\t.which = sd_state ? V4L2_SUBDEV_FORMAT_TRY\n\t\t: V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\n\treturn adv7180_set_pad_format(sd, sd_state, &fmt);\n}\n\nstatic int adv7180_get_mbus_config(struct v4l2_subdev *sd,\n\t\t\t\t   unsigned int pad,\n\t\t\t\t   struct v4l2_mbus_config *cfg)\n{\n\tstruct adv7180_state *state = to_state(sd);\n\n\tif (state->chip_info->flags & ADV7180_FLAG_MIPI_CSI2) {\n\t\tcfg->type = V4L2_MBUS_CSI2_DPHY;\n\t\tcfg->bus.mipi_csi2.num_data_lanes = 1;\n\t\tcfg->bus.mipi_csi2.flags = 0;\n\t} else {\n\t\t \n\t\tcfg->bus.parallel.flags = V4L2_MBUS_MASTER |\n\t\t\t\t\t  V4L2_MBUS_PCLK_SAMPLE_RISING |\n\t\t\t\t\t  V4L2_MBUS_DATA_ACTIVE_HIGH;\n\t\tcfg->type = V4L2_MBUS_BT656;\n\t}\n\n\treturn 0;\n}\n\nstatic int adv7180_get_skip_frames(struct v4l2_subdev *sd, u32 *frames)\n{\n\t*frames = ADV7180_NUM_OF_SKIP_FRAMES;\n\n\treturn 0;\n}\n\nstatic int adv7180_g_pixelaspect(struct v4l2_subdev *sd, struct v4l2_fract *aspect)\n{\n\tstruct adv7180_state *state = to_state(sd);\n\n\tif (state->curr_norm & V4L2_STD_525_60) {\n\t\taspect->numerator = 11;\n\t\taspect->denominator = 10;\n\t} else {\n\t\taspect->numerator = 54;\n\t\taspect->denominator = 59;\n\t}\n\n\treturn 0;\n}\n\nstatic int adv7180_g_tvnorms(struct v4l2_subdev *sd, v4l2_std_id *norm)\n{\n\t*norm = V4L2_STD_ALL;\n\treturn 0;\n}\n\nstatic int adv7180_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct adv7180_state *state = to_state(sd);\n\tint ret;\n\n\t \n\tif (!enable) {\n\t\tstate->streaming = enable;\n\t\treturn 0;\n\t}\n\n\t \n\tret = mutex_lock_interruptible(&state->mutex);\n\tif (ret)\n\t\treturn ret;\n\tstate->streaming = enable;\n\tmutex_unlock(&state->mutex);\n\treturn 0;\n}\n\nstatic int adv7180_subscribe_event(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_fh *fh,\n\t\t\t\t   struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\treturn v4l2_src_change_event_subdev_subscribe(sd, fh, sub);\n\tcase V4L2_EVENT_CTRL:\n\t\treturn v4l2_ctrl_subdev_subscribe_event(sd, fh, sub);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct v4l2_subdev_video_ops adv7180_video_ops = {\n\t.s_std = adv7180_s_std,\n\t.g_std = adv7180_g_std,\n\t.g_frame_interval = adv7180_g_frame_interval,\n\t.querystd = adv7180_querystd,\n\t.g_input_status = adv7180_g_input_status,\n\t.s_routing = adv7180_s_routing,\n\t.g_pixelaspect = adv7180_g_pixelaspect,\n\t.g_tvnorms = adv7180_g_tvnorms,\n\t.s_stream = adv7180_s_stream,\n};\n\nstatic const struct v4l2_subdev_core_ops adv7180_core_ops = {\n\t.s_power = adv7180_s_power,\n\t.subscribe_event = adv7180_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n};\n\nstatic const struct v4l2_subdev_pad_ops adv7180_pad_ops = {\n\t.init_cfg = adv7180_init_cfg,\n\t.enum_mbus_code = adv7180_enum_mbus_code,\n\t.set_fmt = adv7180_set_pad_format,\n\t.get_fmt = adv7180_get_pad_format,\n\t.get_mbus_config = adv7180_get_mbus_config,\n};\n\nstatic const struct v4l2_subdev_sensor_ops adv7180_sensor_ops = {\n\t.g_skip_frames = adv7180_get_skip_frames,\n};\n\nstatic const struct v4l2_subdev_ops adv7180_ops = {\n\t.core = &adv7180_core_ops,\n\t.video = &adv7180_video_ops,\n\t.pad = &adv7180_pad_ops,\n\t.sensor = &adv7180_sensor_ops,\n};\n\nstatic irqreturn_t adv7180_irq(int irq, void *devid)\n{\n\tstruct adv7180_state *state = devid;\n\tu8 isr3;\n\n\tmutex_lock(&state->mutex);\n\tisr3 = adv7180_read(state, ADV7180_REG_ISR3);\n\t \n\tadv7180_write(state, ADV7180_REG_ICR3, isr3);\n\n\tif (isr3 & ADV7180_IRQ3_AD_CHANGE) {\n\t\tstatic const struct v4l2_event src_ch = {\n\t\t\t.type = V4L2_EVENT_SOURCE_CHANGE,\n\t\t\t.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,\n\t\t};\n\n\t\tv4l2_subdev_notify_event(&state->sd, &src_ch);\n\t}\n\tmutex_unlock(&state->mutex);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int adv7180_init(struct adv7180_state *state)\n{\n\tint ret;\n\n\t \n\tret = adv7180_write(state, ADV7180_REG_EXTENDED_OUTPUT_CONTROL,\n\t\t\tADV7180_EXTENDED_OUTPUT_CONTROL_NTSCDIS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn adv7180_write(state, ADV7180_REG_NTSC_V_BIT_END,\n\t\t\t\t\tADV7180_NTSC_V_BIT_END_MANUAL_NVEND);\n}\n\nstatic int adv7180_set_std(struct adv7180_state *state, unsigned int std)\n{\n\treturn adv7180_write(state, ADV7180_REG_INPUT_CONTROL,\n\t\t(std << 4) | state->input);\n}\n\nstatic int adv7180_select_input(struct adv7180_state *state, unsigned int input)\n{\n\tint ret;\n\n\tret = adv7180_read(state, ADV7180_REG_INPUT_CONTROL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret &= ~ADV7180_INPUT_CONTROL_INSEL_MASK;\n\tret |= input;\n\treturn adv7180_write(state, ADV7180_REG_INPUT_CONTROL, ret);\n}\n\nstatic int adv7182_init(struct adv7180_state *state)\n{\n\tif (state->chip_info->flags & ADV7180_FLAG_MIPI_CSI2)\n\t\tadv7180_write(state, ADV7180_REG_CSI_SLAVE_ADDR,\n\t\t\tADV7180_DEFAULT_CSI_I2C_ADDR << 1);\n\n\tif (state->chip_info->flags & ADV7180_FLAG_I2P)\n\t\tadv7180_write(state, ADV7180_REG_VPP_SLAVE_ADDR,\n\t\t\tADV7180_DEFAULT_VPP_I2C_ADDR << 1);\n\n\tif (state->chip_info->flags & ADV7180_FLAG_V2) {\n\t\t \n\t\tadv7180_write(state, 0x0080, 0x51);\n\t\tadv7180_write(state, 0x0081, 0x51);\n\t\tadv7180_write(state, 0x0082, 0x68);\n\t}\n\n\t \n\tif (state->chip_info->flags & ADV7180_FLAG_MIPI_CSI2) {\n\t\tadv7180_write(state, ADV7180_REG_OUTPUT_CONTROL, 0x4e);\n\t\tadv7180_write(state, ADV7180_REG_EXTENDED_OUTPUT_CONTROL, 0x57);\n\t\tadv7180_write(state, ADV7180_REG_CTRL_2, 0xc0);\n\t} else {\n\t\tif (state->chip_info->flags & ADV7180_FLAG_V2) {\n\t\t\tif (state->force_bt656_4) {\n\t\t\t\t \n\t\t\t\tadv7180_write(state,\n\t\t\t\t\t      ADV7180_REG_EXTENDED_OUTPUT_CONTROL,\n\t\t\t\t\t      ADV7180_EXTENDED_OUTPUT_CONTROL_NTSCDIS);\n\t\t\t\t \n\t\t\t\tadv7180_write(state,\n\t\t\t\t\t      ADV7180_REG_VSYNC_FIELD_CTL_1,\n\t\t\t\t\t      ADV7180_VSYNC_FIELD_CTL_1_NEWAV);\n\t\t\t\t \n\t\t\t\tadv7180_write(state,\n\t\t\t\t\t      ADV7180_REG_NTSC_V_BIT_END,\n\t\t\t\t\t      ADV7180_NTSC_V_BIT_END_MANUAL_NVEND);\n\t\t\t} else {\n\t\t\t\tadv7180_write(state,\n\t\t\t\t\t      ADV7180_REG_EXTENDED_OUTPUT_CONTROL,\n\t\t\t\t\t      0x17);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tadv7180_write(state,\n\t\t\t\t      ADV7180_REG_EXTENDED_OUTPUT_CONTROL,\n\t\t\t\t      0x07);\n\t\tadv7180_write(state, ADV7180_REG_OUTPUT_CONTROL, 0x0c);\n\t\tadv7180_write(state, ADV7180_REG_CTRL_2, 0x40);\n\t}\n\n\tadv7180_write(state, 0x0013, 0x00);\n\n\treturn 0;\n}\n\nstatic int adv7182_set_std(struct adv7180_state *state, unsigned int std)\n{\n\t \n\treturn adv7180_write(state, ADV7182_REG_INPUT_VIDSEL,\n\t\t\t     (std << 4) | ADV7182_REG_INPUT_RESERVED);\n}\n\nenum adv7182_input_type {\n\tADV7182_INPUT_TYPE_CVBS,\n\tADV7182_INPUT_TYPE_DIFF_CVBS,\n\tADV7182_INPUT_TYPE_SVIDEO,\n\tADV7182_INPUT_TYPE_YPBPR,\n};\n\nstatic enum adv7182_input_type adv7182_get_input_type(unsigned int input)\n{\n\tswitch (input) {\n\tcase ADV7182_INPUT_CVBS_AIN1:\n\tcase ADV7182_INPUT_CVBS_AIN2:\n\tcase ADV7182_INPUT_CVBS_AIN3:\n\tcase ADV7182_INPUT_CVBS_AIN4:\n\tcase ADV7182_INPUT_CVBS_AIN5:\n\tcase ADV7182_INPUT_CVBS_AIN6:\n\tcase ADV7182_INPUT_CVBS_AIN7:\n\tcase ADV7182_INPUT_CVBS_AIN8:\n\t\treturn ADV7182_INPUT_TYPE_CVBS;\n\tcase ADV7182_INPUT_SVIDEO_AIN1_AIN2:\n\tcase ADV7182_INPUT_SVIDEO_AIN3_AIN4:\n\tcase ADV7182_INPUT_SVIDEO_AIN5_AIN6:\n\tcase ADV7182_INPUT_SVIDEO_AIN7_AIN8:\n\t\treturn ADV7182_INPUT_TYPE_SVIDEO;\n\tcase ADV7182_INPUT_YPRPB_AIN1_AIN2_AIN3:\n\tcase ADV7182_INPUT_YPRPB_AIN4_AIN5_AIN6:\n\t\treturn ADV7182_INPUT_TYPE_YPBPR;\n\tcase ADV7182_INPUT_DIFF_CVBS_AIN1_AIN2:\n\tcase ADV7182_INPUT_DIFF_CVBS_AIN3_AIN4:\n\tcase ADV7182_INPUT_DIFF_CVBS_AIN5_AIN6:\n\tcase ADV7182_INPUT_DIFF_CVBS_AIN7_AIN8:\n\t\treturn ADV7182_INPUT_TYPE_DIFF_CVBS;\n\tdefault:  \n\t\treturn 0;\n\t}\n}\n\n \nstatic unsigned int adv7182_lbias_settings[][3] = {\n\t[ADV7182_INPUT_TYPE_CVBS] = { 0xCB, 0x4E, 0x80 },\n\t[ADV7182_INPUT_TYPE_DIFF_CVBS] = { 0xC0, 0x4E, 0x80 },\n\t[ADV7182_INPUT_TYPE_SVIDEO] = { 0x0B, 0xCE, 0x80 },\n\t[ADV7182_INPUT_TYPE_YPBPR] = { 0x0B, 0x4E, 0xC0 },\n};\n\nstatic unsigned int adv7280_lbias_settings[][3] = {\n\t[ADV7182_INPUT_TYPE_CVBS] = { 0xCD, 0x4E, 0x80 },\n\t[ADV7182_INPUT_TYPE_DIFF_CVBS] = { 0xC0, 0x4E, 0x80 },\n\t[ADV7182_INPUT_TYPE_SVIDEO] = { 0x0B, 0xCE, 0x80 },\n\t[ADV7182_INPUT_TYPE_YPBPR] = { 0x0B, 0x4E, 0xC0 },\n};\n\nstatic int adv7182_select_input(struct adv7180_state *state, unsigned int input)\n{\n\tenum adv7182_input_type input_type;\n\tunsigned int *lbias;\n\tunsigned int i;\n\tint ret;\n\n\tret = adv7180_write(state, ADV7180_REG_INPUT_CONTROL, input);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tadv7180_write(state, ADV7180_REG_RST_CLAMP, 0x00);\n\tadv7180_write(state, ADV7180_REG_RST_CLAMP, 0xff);\n\n\tinput_type = adv7182_get_input_type(input);\n\n\tswitch (input_type) {\n\tcase ADV7182_INPUT_TYPE_CVBS:\n\tcase ADV7182_INPUT_TYPE_DIFF_CVBS:\n\t\t \n\t\tadv7180_write(state, ADV7180_REG_SHAP_FILTER_CTL_1, 0x41);\n\t\tbreak;\n\tdefault:\n\t\tadv7180_write(state, ADV7180_REG_SHAP_FILTER_CTL_1, 0x01);\n\t\tbreak;\n\t}\n\n\tif (state->chip_info->flags & ADV7180_FLAG_V2)\n\t\tlbias = adv7280_lbias_settings[input_type];\n\telse\n\t\tlbias = adv7182_lbias_settings[input_type];\n\n\tfor (i = 0; i < ARRAY_SIZE(adv7182_lbias_settings[0]); i++)\n\t\tadv7180_write(state, ADV7180_REG_CVBS_TRIM + i, lbias[i]);\n\n\tif (input_type == ADV7182_INPUT_TYPE_DIFF_CVBS) {\n\t\t \n\t\tadv7180_write(state, ADV7180_REG_RES_CIR, 0xa8);\n\t\tadv7180_write(state, ADV7180_REG_CLAMP_ADJ, 0x90);\n\t\tadv7180_write(state, ADV7180_REG_DIFF_MODE, 0xb0);\n\t\tadv7180_write(state, ADV7180_REG_AGC_ADJ1, 0x08);\n\t\tadv7180_write(state, ADV7180_REG_AGC_ADJ2, 0xa0);\n\t} else {\n\t\tadv7180_write(state, ADV7180_REG_RES_CIR, 0xf0);\n\t\tadv7180_write(state, ADV7180_REG_CLAMP_ADJ, 0xd0);\n\t\tadv7180_write(state, ADV7180_REG_DIFF_MODE, 0x10);\n\t\tadv7180_write(state, ADV7180_REG_AGC_ADJ1, 0x9c);\n\t\tadv7180_write(state, ADV7180_REG_AGC_ADJ2, 0x00);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct adv7180_chip_info adv7180_info = {\n\t.flags = ADV7180_FLAG_RESET_POWERED,\n\t \n\t.valid_input_mask = BIT(ADV7180_INPUT_CVBS_AIN1) |\n\t\tBIT(ADV7180_INPUT_CVBS_AIN2) |\n\t\tBIT(ADV7180_INPUT_CVBS_AIN3) |\n\t\tBIT(ADV7180_INPUT_CVBS_AIN4) |\n\t\tBIT(ADV7180_INPUT_CVBS_AIN5) |\n\t\tBIT(ADV7180_INPUT_CVBS_AIN6) |\n\t\tBIT(ADV7180_INPUT_SVIDEO_AIN1_AIN2) |\n\t\tBIT(ADV7180_INPUT_SVIDEO_AIN3_AIN4) |\n\t\tBIT(ADV7180_INPUT_SVIDEO_AIN5_AIN6) |\n\t\tBIT(ADV7180_INPUT_YPRPB_AIN1_AIN2_AIN3) |\n\t\tBIT(ADV7180_INPUT_YPRPB_AIN4_AIN5_AIN6),\n\t.init = adv7180_init,\n\t.set_std = adv7180_set_std,\n\t.select_input = adv7180_select_input,\n};\n\nstatic const struct adv7180_chip_info adv7182_info = {\n\t.valid_input_mask = BIT(ADV7182_INPUT_CVBS_AIN1) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN2) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN3) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN4) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN1_AIN2) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN3_AIN4) |\n\t\tBIT(ADV7182_INPUT_YPRPB_AIN1_AIN2_AIN3) |\n\t\tBIT(ADV7182_INPUT_DIFF_CVBS_AIN1_AIN2) |\n\t\tBIT(ADV7182_INPUT_DIFF_CVBS_AIN3_AIN4),\n\t.init = adv7182_init,\n\t.set_std = adv7182_set_std,\n\t.select_input = adv7182_select_input,\n};\n\nstatic const struct adv7180_chip_info adv7280_info = {\n\t.flags = ADV7180_FLAG_V2 | ADV7180_FLAG_I2P,\n\t.valid_input_mask = BIT(ADV7182_INPUT_CVBS_AIN1) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN2) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN3) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN4) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN1_AIN2) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN3_AIN4) |\n\t\tBIT(ADV7182_INPUT_YPRPB_AIN1_AIN2_AIN3),\n\t.init = adv7182_init,\n\t.set_std = adv7182_set_std,\n\t.select_input = adv7182_select_input,\n};\n\nstatic const struct adv7180_chip_info adv7280_m_info = {\n\t.flags = ADV7180_FLAG_V2 | ADV7180_FLAG_MIPI_CSI2 | ADV7180_FLAG_I2P,\n\t.valid_input_mask = BIT(ADV7182_INPUT_CVBS_AIN1) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN2) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN3) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN4) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN5) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN6) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN7) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN8) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN1_AIN2) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN3_AIN4) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN5_AIN6) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN7_AIN8) |\n\t\tBIT(ADV7182_INPUT_YPRPB_AIN1_AIN2_AIN3) |\n\t\tBIT(ADV7182_INPUT_YPRPB_AIN4_AIN5_AIN6),\n\t.init = adv7182_init,\n\t.set_std = adv7182_set_std,\n\t.select_input = adv7182_select_input,\n};\n\nstatic const struct adv7180_chip_info adv7281_info = {\n\t.flags = ADV7180_FLAG_V2 | ADV7180_FLAG_MIPI_CSI2,\n\t.valid_input_mask = BIT(ADV7182_INPUT_CVBS_AIN1) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN2) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN7) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN8) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN1_AIN2) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN7_AIN8) |\n\t\tBIT(ADV7182_INPUT_DIFF_CVBS_AIN1_AIN2) |\n\t\tBIT(ADV7182_INPUT_DIFF_CVBS_AIN7_AIN8),\n\t.init = adv7182_init,\n\t.set_std = adv7182_set_std,\n\t.select_input = adv7182_select_input,\n};\n\nstatic const struct adv7180_chip_info adv7281_m_info = {\n\t.flags = ADV7180_FLAG_V2 | ADV7180_FLAG_MIPI_CSI2,\n\t.valid_input_mask = BIT(ADV7182_INPUT_CVBS_AIN1) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN2) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN3) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN4) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN7) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN8) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN1_AIN2) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN3_AIN4) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN7_AIN8) |\n\t\tBIT(ADV7182_INPUT_YPRPB_AIN1_AIN2_AIN3) |\n\t\tBIT(ADV7182_INPUT_DIFF_CVBS_AIN1_AIN2) |\n\t\tBIT(ADV7182_INPUT_DIFF_CVBS_AIN3_AIN4) |\n\t\tBIT(ADV7182_INPUT_DIFF_CVBS_AIN7_AIN8),\n\t.init = adv7182_init,\n\t.set_std = adv7182_set_std,\n\t.select_input = adv7182_select_input,\n};\n\nstatic const struct adv7180_chip_info adv7281_ma_info = {\n\t.flags = ADV7180_FLAG_V2 | ADV7180_FLAG_MIPI_CSI2,\n\t.valid_input_mask = BIT(ADV7182_INPUT_CVBS_AIN1) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN2) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN3) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN4) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN5) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN6) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN7) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN8) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN1_AIN2) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN3_AIN4) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN5_AIN6) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN7_AIN8) |\n\t\tBIT(ADV7182_INPUT_YPRPB_AIN1_AIN2_AIN3) |\n\t\tBIT(ADV7182_INPUT_YPRPB_AIN4_AIN5_AIN6) |\n\t\tBIT(ADV7182_INPUT_DIFF_CVBS_AIN1_AIN2) |\n\t\tBIT(ADV7182_INPUT_DIFF_CVBS_AIN3_AIN4) |\n\t\tBIT(ADV7182_INPUT_DIFF_CVBS_AIN5_AIN6) |\n\t\tBIT(ADV7182_INPUT_DIFF_CVBS_AIN7_AIN8),\n\t.init = adv7182_init,\n\t.set_std = adv7182_set_std,\n\t.select_input = adv7182_select_input,\n};\n\nstatic const struct adv7180_chip_info adv7282_info = {\n\t.flags = ADV7180_FLAG_V2 | ADV7180_FLAG_I2P,\n\t.valid_input_mask = BIT(ADV7182_INPUT_CVBS_AIN1) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN2) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN7) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN8) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN1_AIN2) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN7_AIN8) |\n\t\tBIT(ADV7182_INPUT_DIFF_CVBS_AIN1_AIN2) |\n\t\tBIT(ADV7182_INPUT_DIFF_CVBS_AIN7_AIN8),\n\t.init = adv7182_init,\n\t.set_std = adv7182_set_std,\n\t.select_input = adv7182_select_input,\n};\n\nstatic const struct adv7180_chip_info adv7282_m_info = {\n\t.flags = ADV7180_FLAG_V2 | ADV7180_FLAG_MIPI_CSI2 | ADV7180_FLAG_I2P,\n\t.valid_input_mask = BIT(ADV7182_INPUT_CVBS_AIN1) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN2) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN3) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN4) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN7) |\n\t\tBIT(ADV7182_INPUT_CVBS_AIN8) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN1_AIN2) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN3_AIN4) |\n\t\tBIT(ADV7182_INPUT_SVIDEO_AIN7_AIN8) |\n\t\tBIT(ADV7182_INPUT_DIFF_CVBS_AIN1_AIN2) |\n\t\tBIT(ADV7182_INPUT_DIFF_CVBS_AIN3_AIN4) |\n\t\tBIT(ADV7182_INPUT_DIFF_CVBS_AIN7_AIN8),\n\t.init = adv7182_init,\n\t.set_std = adv7182_set_std,\n\t.select_input = adv7182_select_input,\n};\n\nstatic int init_device(struct adv7180_state *state)\n{\n\tint ret;\n\n\tmutex_lock(&state->mutex);\n\n\tadv7180_set_power_pin(state, true);\n\tadv7180_set_reset_pin(state, false);\n\n\tadv7180_write(state, ADV7180_REG_PWR_MAN, ADV7180_PWR_MAN_RES);\n\tusleep_range(5000, 10000);\n\n\tret = state->chip_info->init(state);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = adv7180_program_std(state);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tadv7180_set_field_mode(state);\n\n\t \n\tif (state->irq > 0) {\n\t\t \n\t\tret = adv7180_write(state, ADV7180_REG_ICONF1,\n\t\t\t\t\t\tADV7180_ICONF1_ACTIVE_LOW |\n\t\t\t\t\t\tADV7180_ICONF1_PSYNC_ONLY);\n\t\tif (ret < 0)\n\t\t\tgoto out_unlock;\n\n\t\tret = adv7180_write(state, ADV7180_REG_IMR1, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out_unlock;\n\n\t\tret = adv7180_write(state, ADV7180_REG_IMR2, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out_unlock;\n\n\t\t \n\t\tret = adv7180_write(state, ADV7180_REG_IMR3,\n\t\t\t\t\t\tADV7180_IRQ3_AD_CHANGE);\n\t\tif (ret < 0)\n\t\t\tgoto out_unlock;\n\n\t\tret = adv7180_write(state, ADV7180_REG_IMR4, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tmutex_unlock(&state->mutex);\n\n\treturn ret;\n}\n\nstatic int adv7180_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct device_node *np = client->dev.of_node;\n\tstruct adv7180_state *state;\n\tstruct v4l2_subdev *sd;\n\tint ret;\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tstate = devm_kzalloc(&client->dev, sizeof(*state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\n\tstate->client = client;\n\tstate->field = V4L2_FIELD_ALTERNATE;\n\tstate->chip_info = (struct adv7180_chip_info *)id->driver_data;\n\n\tstate->pwdn_gpio = devm_gpiod_get_optional(&client->dev, \"powerdown\",\n\t\t\t\t\t\t   GPIOD_OUT_HIGH);\n\tif (IS_ERR(state->pwdn_gpio)) {\n\t\tret = PTR_ERR(state->pwdn_gpio);\n\t\tv4l_err(client, \"request for power pin failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tstate->rst_gpio = devm_gpiod_get_optional(&client->dev, \"reset\",\n\t\t\t\t\t\t  GPIOD_OUT_HIGH);\n\tif (IS_ERR(state->rst_gpio)) {\n\t\tret = PTR_ERR(state->rst_gpio);\n\t\tv4l_err(client, \"request for reset pin failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (of_property_read_bool(np, \"adv,force-bt656-4\"))\n\t\tstate->force_bt656_4 = true;\n\n\tif (state->chip_info->flags & ADV7180_FLAG_MIPI_CSI2) {\n\t\tstate->csi_client = i2c_new_dummy_device(client->adapter,\n\t\t\t\tADV7180_DEFAULT_CSI_I2C_ADDR);\n\t\tif (IS_ERR(state->csi_client))\n\t\t\treturn PTR_ERR(state->csi_client);\n\t}\n\n\tif (state->chip_info->flags & ADV7180_FLAG_I2P) {\n\t\tstate->vpp_client = i2c_new_dummy_device(client->adapter,\n\t\t\t\tADV7180_DEFAULT_VPP_I2C_ADDR);\n\t\tif (IS_ERR(state->vpp_client)) {\n\t\t\tret = PTR_ERR(state->vpp_client);\n\t\t\tgoto err_unregister_csi_client;\n\t\t}\n\t}\n\n\tstate->irq = client->irq;\n\tmutex_init(&state->mutex);\n\tstate->curr_norm = V4L2_STD_NTSC;\n\tif (state->chip_info->flags & ADV7180_FLAG_RESET_POWERED)\n\t\tstate->powered = true;\n\telse\n\t\tstate->powered = false;\n\tstate->input = 0;\n\tsd = &state->sd;\n\tv4l2_i2c_subdev_init(sd, client, &adv7180_ops);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;\n\n\tret = adv7180_init_controls(state);\n\tif (ret)\n\t\tgoto err_unregister_vpp_client;\n\n\tstate->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tsd->entity.function = MEDIA_ENT_F_ATV_DECODER;\n\tret = media_entity_pads_init(&sd->entity, 1, &state->pad);\n\tif (ret)\n\t\tgoto err_free_ctrl;\n\n\tret = init_device(state);\n\tif (ret)\n\t\tgoto err_media_entity_cleanup;\n\n\tif (state->irq) {\n\t\tret = request_threaded_irq(client->irq, NULL, adv7180_irq,\n\t\t\t\t\t   IRQF_ONESHOT | IRQF_TRIGGER_FALLING,\n\t\t\t\t\t   KBUILD_MODNAME, state);\n\t\tif (ret)\n\t\t\tgoto err_media_entity_cleanup;\n\t}\n\n\tret = v4l2_async_register_subdev(sd);\n\tif (ret)\n\t\tgoto err_free_irq;\n\n\tmutex_lock(&state->mutex);\n\tret = adv7180_read(state, ADV7180_REG_IDENT);\n\tmutex_unlock(&state->mutex);\n\tif (ret < 0)\n\t\tgoto err_v4l2_async_unregister;\n\n\tv4l_info(client, \"chip id 0x%x found @ 0x%02x (%s)\\n\",\n\t\t ret, client->addr, client->adapter->name);\n\n\treturn 0;\n\nerr_v4l2_async_unregister:\n\tv4l2_async_unregister_subdev(sd);\nerr_free_irq:\n\tif (state->irq > 0)\n\t\tfree_irq(client->irq, state);\nerr_media_entity_cleanup:\n\tmedia_entity_cleanup(&sd->entity);\nerr_free_ctrl:\n\tadv7180_exit_controls(state);\nerr_unregister_vpp_client:\n\ti2c_unregister_device(state->vpp_client);\nerr_unregister_csi_client:\n\ti2c_unregister_device(state->csi_client);\n\tmutex_destroy(&state->mutex);\n\treturn ret;\n}\n\nstatic void adv7180_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct adv7180_state *state = to_state(sd);\n\n\tv4l2_async_unregister_subdev(sd);\n\n\tif (state->irq > 0)\n\t\tfree_irq(client->irq, state);\n\n\tmedia_entity_cleanup(&sd->entity);\n\tadv7180_exit_controls(state);\n\n\ti2c_unregister_device(state->vpp_client);\n\ti2c_unregister_device(state->csi_client);\n\n\tadv7180_set_reset_pin(state, true);\n\tadv7180_set_power_pin(state, false);\n\n\tmutex_destroy(&state->mutex);\n}\n\nstatic const struct i2c_device_id adv7180_id[] = {\n\t{ \"adv7180\", (kernel_ulong_t)&adv7180_info },\n\t{ \"adv7180cp\", (kernel_ulong_t)&adv7180_info },\n\t{ \"adv7180st\", (kernel_ulong_t)&adv7180_info },\n\t{ \"adv7182\", (kernel_ulong_t)&adv7182_info },\n\t{ \"adv7280\", (kernel_ulong_t)&adv7280_info },\n\t{ \"adv7280-m\", (kernel_ulong_t)&adv7280_m_info },\n\t{ \"adv7281\", (kernel_ulong_t)&adv7281_info },\n\t{ \"adv7281-m\", (kernel_ulong_t)&adv7281_m_info },\n\t{ \"adv7281-ma\", (kernel_ulong_t)&adv7281_ma_info },\n\t{ \"adv7282\", (kernel_ulong_t)&adv7282_info },\n\t{ \"adv7282-m\", (kernel_ulong_t)&adv7282_m_info },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, adv7180_id);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int adv7180_suspend(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct adv7180_state *state = to_state(sd);\n\n\treturn adv7180_set_power(state, false);\n}\n\nstatic int adv7180_resume(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct adv7180_state *state = to_state(sd);\n\tint ret;\n\n\tret = init_device(state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = adv7180_set_power(state, state->powered);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(adv7180_pm_ops, adv7180_suspend, adv7180_resume);\n#define ADV7180_PM_OPS (&adv7180_pm_ops)\n\n#else\n#define ADV7180_PM_OPS NULL\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id adv7180_of_id[] = {\n\t{ .compatible = \"adi,adv7180\", },\n\t{ .compatible = \"adi,adv7180cp\", },\n\t{ .compatible = \"adi,adv7180st\", },\n\t{ .compatible = \"adi,adv7182\", },\n\t{ .compatible = \"adi,adv7280\", },\n\t{ .compatible = \"adi,adv7280-m\", },\n\t{ .compatible = \"adi,adv7281\", },\n\t{ .compatible = \"adi,adv7281-m\", },\n\t{ .compatible = \"adi,adv7281-ma\", },\n\t{ .compatible = \"adi,adv7282\", },\n\t{ .compatible = \"adi,adv7282-m\", },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, adv7180_of_id);\n#endif\n\nstatic struct i2c_driver adv7180_driver = {\n\t.driver = {\n\t\t   .name = KBUILD_MODNAME,\n\t\t   .pm = ADV7180_PM_OPS,\n\t\t   .of_match_table = of_match_ptr(adv7180_of_id),\n\t\t   },\n\t.probe = adv7180_probe,\n\t.remove = adv7180_remove,\n\t.id_table = adv7180_id,\n};\n\nmodule_i2c_driver(adv7180_driver);\n\nMODULE_DESCRIPTION(\"Analog Devices ADV7180 video decoder driver\");\nMODULE_AUTHOR(\"Mocean Laboratories\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}