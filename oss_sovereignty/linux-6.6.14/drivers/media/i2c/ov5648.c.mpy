{
  "module_name": "ov5648.c",
  "hash_id": "33ab6b0e7bb0eae912a1bc4027038f615bee87fda497d58d2eefe2210e2868c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/i2c/ov5648.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-image-sizes.h>\n#include <media/v4l2-mediabus.h>\n\n \n\n#define OV5648_XVCLK_RATE\t\t\t24000000\n\n \n\n \n\n#define OV5648_SW_STANDBY_REG\t\t\t0x100\n#define OV5648_SW_STANDBY_STREAM_ON\t\tBIT(0)\n\n#define OV5648_SW_RESET_REG\t\t\t0x103\n#define OV5648_SW_RESET_RESET\t\t\tBIT(0)\n\n#define OV5648_PAD_OEN0_REG\t\t\t0x3000\n#define OV5648_PAD_OEN1_REG\t\t\t0x3001\n#define OV5648_PAD_OEN2_REG\t\t\t0x3002\n#define OV5648_PAD_OUT0_REG\t\t\t0x3008\n#define OV5648_PAD_OUT1_REG\t\t\t0x3009\n\n#define OV5648_CHIP_ID_H_REG\t\t\t0x300a\n#define OV5648_CHIP_ID_H_VALUE\t\t\t0x56\n#define OV5648_CHIP_ID_L_REG\t\t\t0x300b\n#define OV5648_CHIP_ID_L_VALUE\t\t\t0x48\n\n#define OV5648_PAD_OUT2_REG\t\t\t0x300d\n#define OV5648_PAD_SEL0_REG\t\t\t0x300e\n#define OV5648_PAD_SEL1_REG\t\t\t0x300f\n#define OV5648_PAD_SEL2_REG\t\t\t0x3010\n#define OV5648_PAD_PK_REG\t\t\t0x3011\n#define OV5648_PAD_PK_PD_DATO_EN\t\tBIT(7)\n#define OV5648_PAD_PK_DRIVE_STRENGTH_1X\t\t(0 << 5)\n#define OV5648_PAD_PK_DRIVE_STRENGTH_2X\t\t(2 << 5)\n#define OV5648_PAD_PK_FREX_N\t\t\tBIT(1)\n\n#define OV5648_A_PWC_PK_O0_REG\t\t\t0x3013\n#define OV5648_A_PWC_PK_O0_BP_REGULATOR_N\tBIT(3)\n#define OV5648_A_PWC_PK_O1_REG\t\t\t0x3014\n\n#define OV5648_MIPI_PHY0_REG\t\t\t0x3016\n#define OV5648_MIPI_PHY1_REG\t\t\t0x3017\n#define OV5648_MIPI_SC_CTRL0_REG\t\t0x3018\n#define OV5648_MIPI_SC_CTRL0_MIPI_LANES(v)\t(((v) << 5) & GENMASK(7, 5))\n#define OV5648_MIPI_SC_CTRL0_PHY_HS_TX_PD\tBIT(4)\n#define OV5648_MIPI_SC_CTRL0_PHY_LP_RX_PD\tBIT(3)\n#define OV5648_MIPI_SC_CTRL0_MIPI_EN\t\tBIT(2)\n#define OV5648_MIPI_SC_CTRL0_MIPI_SUSP\t\tBIT(1)\n#define OV5648_MIPI_SC_CTRL0_LANE_DIS_OP\tBIT(0)\n#define OV5648_MIPI_SC_CTRL1_REG\t\t0x3019\n#define OV5648_MISC_CTRL0_REG\t\t\t0x3021\n#define OV5648_MIPI_SC_CTRL2_REG\t\t0x3022\n#define OV5648_SUB_ID_REG\t\t\t0x302a\n\n#define OV5648_PLL_CTRL0_REG\t\t\t0x3034\n#define OV5648_PLL_CTRL0_PLL_CHARGE_PUMP(v)\t(((v) << 4) & GENMASK(6, 4))\n#define OV5648_PLL_CTRL0_BITS(v)\t\t((v) & GENMASK(3, 0))\n#define OV5648_PLL_CTRL1_REG\t\t\t0x3035\n#define OV5648_PLL_CTRL1_SYS_DIV(v)\t\t(((v) << 4) & GENMASK(7, 4))\n#define OV5648_PLL_CTRL1_MIPI_DIV(v)\t\t((v) & GENMASK(3, 0))\n#define OV5648_PLL_MUL_REG\t\t\t0x3036\n#define OV5648_PLL_MUL(v)\t\t\t((v) & GENMASK(7, 0))\n#define OV5648_PLL_DIV_REG\t\t\t0x3037\n#define OV5648_PLL_DIV_ROOT_DIV(v)\t\t((((v) - 1) << 4) & BIT(4))\n#define OV5648_PLL_DIV_PLL_PRE_DIV(v)\t\t((v) & GENMASK(3, 0))\n#define OV5648_PLL_DEBUG_REG\t\t\t0x3038\n#define OV5648_PLL_BYPASS_REG\t\t\t0x3039\n\n#define OV5648_PLLS_BYPASS_REG\t\t\t0x303a\n#define OV5648_PLLS_MUL_REG\t\t\t0x303b\n#define OV5648_PLLS_MUL(v)\t\t\t((v) & GENMASK(4, 0))\n#define OV5648_PLLS_CTRL_REG\t\t\t0x303c\n#define OV5648_PLLS_CTRL_PLL_CHARGE_PUMP(v)\t(((v) << 4) & GENMASK(6, 4))\n#define OV5648_PLLS_CTRL_SYS_DIV(v)\t\t((v) & GENMASK(3, 0))\n#define OV5648_PLLS_DIV_REG\t\t\t0x303d\n#define OV5648_PLLS_DIV_PLLS_PRE_DIV(v)\t\t(((v) << 4) & GENMASK(5, 4))\n#define OV5648_PLLS_DIV_PLLS_DIV_R(v)\t\t((((v) - 1) << 2) & BIT(2))\n#define OV5648_PLLS_DIV_PLLS_SEL_DIV(v)\t\t((v) & GENMASK(1, 0))\n\n#define OV5648_SRB_CTRL_REG\t\t\t0x3106\n#define OV5648_SRB_CTRL_SCLK_DIV(v)\t\t(((v) << 2) & GENMASK(3, 2))\n#define OV5648_SRB_CTRL_RESET_ARBITER_EN\tBIT(1)\n#define OV5648_SRB_CTRL_SCLK_ARBITER_EN\t\tBIT(0)\n\n \n\n#define OV5648_GROUP_ADR0_REG\t\t\t0x3200\n#define OV5648_GROUP_ADR1_REG\t\t\t0x3201\n#define OV5648_GROUP_ADR2_REG\t\t\t0x3202\n#define OV5648_GROUP_ADR3_REG\t\t\t0x3203\n#define OV5648_GROUP_LEN0_REG\t\t\t0x3204\n#define OV5648_GROUP_LEN1_REG\t\t\t0x3205\n#define OV5648_GROUP_LEN2_REG\t\t\t0x3206\n#define OV5648_GROUP_LEN3_REG\t\t\t0x3207\n#define OV5648_GROUP_ACCESS_REG\t\t\t0x3208\n\n \n\n#define OV5648_EXPOSURE_CTRL_HH_REG\t\t0x3500\n#define OV5648_EXPOSURE_CTRL_HH(v)\t\t(((v) & GENMASK(19, 16)) >> 16)\n#define OV5648_EXPOSURE_CTRL_HH_VALUE(v)\t(((v) << 16) & GENMASK(19, 16))\n#define OV5648_EXPOSURE_CTRL_H_REG\t\t0x3501\n#define OV5648_EXPOSURE_CTRL_H(v)\t\t(((v) & GENMASK(15, 8)) >> 8)\n#define OV5648_EXPOSURE_CTRL_H_VALUE(v)\t\t(((v) << 8) & GENMASK(15, 8))\n#define OV5648_EXPOSURE_CTRL_L_REG\t\t0x3502\n#define OV5648_EXPOSURE_CTRL_L(v)\t\t((v) & GENMASK(7, 0))\n#define OV5648_EXPOSURE_CTRL_L_VALUE(v)\t\t((v) & GENMASK(7, 0))\n#define OV5648_MANUAL_CTRL_REG\t\t\t0x3503\n#define OV5648_MANUAL_CTRL_FRAME_DELAY(v)\t(((v) << 4) & GENMASK(5, 4))\n#define OV5648_MANUAL_CTRL_AGC_MANUAL_EN\tBIT(1)\n#define OV5648_MANUAL_CTRL_AEC_MANUAL_EN\tBIT(0)\n#define OV5648_GAIN_CTRL_H_REG\t\t\t0x350a\n#define OV5648_GAIN_CTRL_H(v)\t\t\t(((v) & GENMASK(9, 8)) >> 8)\n#define OV5648_GAIN_CTRL_H_VALUE(v)\t\t(((v) << 8) & GENMASK(9, 8))\n#define OV5648_GAIN_CTRL_L_REG\t\t\t0x350b\n#define OV5648_GAIN_CTRL_L(v)\t\t\t((v) & GENMASK(7, 0))\n#define OV5648_GAIN_CTRL_L_VALUE(v)\t\t((v) & GENMASK(7, 0))\n\n#define OV5648_ANALOG_CTRL0_REG_BASE\t\t0x3600\n#define OV5648_ANALOG_CTRL1_REG_BASE\t\t0x3700\n\n#define OV5648_AEC_CTRL0_REG\t\t\t0x3a00\n#define OV5648_AEC_CTRL0_DEBUG\t\t\tBIT(6)\n#define OV5648_AEC_CTRL0_DEBAND_EN\t\tBIT(5)\n#define OV5648_AEC_CTRL0_DEBAND_LOW_LIMIT_EN\tBIT(4)\n#define OV5648_AEC_CTRL0_START_SEL_EN\t\tBIT(3)\n#define OV5648_AEC_CTRL0_NIGHT_MODE_EN\t\tBIT(2)\n#define OV5648_AEC_CTRL0_FREEZE_EN\t\tBIT(0)\n#define OV5648_EXPOSURE_MIN_REG\t\t\t0x3a01\n#define OV5648_EXPOSURE_MAX_60_H_REG\t\t0x3a02\n#define OV5648_EXPOSURE_MAX_60_L_REG\t\t0x3a03\n#define OV5648_AEC_CTRL5_REG\t\t\t0x3a05\n#define OV5648_AEC_CTRL6_REG\t\t\t0x3a06\n#define OV5648_AEC_CTRL7_REG\t\t\t0x3a07\n#define OV5648_BANDING_STEP_50_H_REG\t\t0x3a08\n#define OV5648_BANDING_STEP_50_L_REG\t\t0x3a09\n#define OV5648_BANDING_STEP_60_H_REG\t\t0x3a0a\n#define OV5648_BANDING_STEP_60_L_REG\t\t0x3a0b\n#define OV5648_AEC_CTRLC_REG\t\t\t0x3a0c\n#define OV5648_BANDING_MAX_60_REG\t\t0x3a0d\n#define OV5648_BANDING_MAX_50_REG\t\t0x3a0e\n#define OV5648_WPT_REG\t\t\t\t0x3a0f\n#define OV5648_BPT_REG\t\t\t\t0x3a10\n#define OV5648_VPT_HIGH_REG\t\t\t0x3a11\n#define OV5648_AVG_MANUAL_REG\t\t\t0x3a12\n#define OV5648_PRE_GAIN_REG\t\t\t0x3a13\n#define OV5648_EXPOSURE_MAX_50_H_REG\t\t0x3a14\n#define OV5648_EXPOSURE_MAX_50_L_REG\t\t0x3a15\n#define OV5648_GAIN_BASE_NIGHT_REG\t\t0x3a17\n#define OV5648_AEC_GAIN_CEILING_H_REG\t\t0x3a18\n#define OV5648_AEC_GAIN_CEILING_L_REG\t\t0x3a19\n#define OV5648_DIFF_MAX_REG\t\t\t0x3a1a\n#define OV5648_WPT2_REG\t\t\t\t0x3a1b\n#define OV5648_LED_ADD_ROW_H_REG\t\t0x3a1c\n#define OV5648_LED_ADD_ROW_L_REG\t\t0x3a1d\n#define OV5648_BPT2_REG\t\t\t\t0x3a1e\n#define OV5648_VPT_LOW_REG\t\t\t0x3a1f\n#define OV5648_AEC_CTRL20_REG\t\t\t0x3a20\n#define OV5648_AEC_CTRL21_REG\t\t\t0x3a21\n\n#define OV5648_AVG_START_X_H_REG\t\t0x5680\n#define OV5648_AVG_START_X_L_REG\t\t0x5681\n#define OV5648_AVG_START_Y_H_REG\t\t0x5682\n#define OV5648_AVG_START_Y_L_REG\t\t0x5683\n#define OV5648_AVG_WINDOW_X_H_REG\t\t0x5684\n#define OV5648_AVG_WINDOW_X_L_REG\t\t0x5685\n#define OV5648_AVG_WINDOW_Y_H_REG\t\t0x5686\n#define OV5648_AVG_WINDOW_Y_L_REG\t\t0x5687\n#define OV5648_AVG_WEIGHT00_REG\t\t\t0x5688\n#define OV5648_AVG_WEIGHT01_REG\t\t\t0x5689\n#define OV5648_AVG_WEIGHT02_REG\t\t\t0x568a\n#define OV5648_AVG_WEIGHT03_REG\t\t\t0x568b\n#define OV5648_AVG_WEIGHT04_REG\t\t\t0x568c\n#define OV5648_AVG_WEIGHT05_REG\t\t\t0x568d\n#define OV5648_AVG_WEIGHT06_REG\t\t\t0x568e\n#define OV5648_AVG_WEIGHT07_REG\t\t\t0x568f\n#define OV5648_AVG_CTRL10_REG\t\t\t0x5690\n#define OV5648_AVG_WEIGHT_SUM_REG\t\t0x5691\n#define OV5648_AVG_READOUT_REG\t\t\t0x5693\n\n#define OV5648_DIG_CTRL0_REG\t\t\t0x5a00\n#define OV5648_DIG_COMP_MAN_H_REG\t\t0x5a02\n#define OV5648_DIG_COMP_MAN_L_REG\t\t0x5a03\n\n#define OV5648_GAINC_MAN_H_REG\t\t\t0x5a20\n#define OV5648_GAINC_MAN_L_REG\t\t\t0x5a21\n#define OV5648_GAINC_DGC_MAN_H_REG\t\t0x5a22\n#define OV5648_GAINC_DGC_MAN_L_REG\t\t0x5a23\n#define OV5648_GAINC_CTRL0_REG\t\t\t0x5a24\n\n#define OV5648_GAINF_ANA_NUM_REG\t\t0x5a40\n#define OV5648_GAINF_DIG_GAIN_REG\t\t0x5a41\n\n \n\n#define OV5648_CROP_START_X_H_REG\t\t0x3800\n#define OV5648_CROP_START_X_H(v)\t\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV5648_CROP_START_X_L_REG\t\t0x3801\n#define OV5648_CROP_START_X_L(v)\t\t((v) & GENMASK(7, 0))\n#define OV5648_CROP_START_Y_H_REG\t\t0x3802\n#define OV5648_CROP_START_Y_H(v)\t\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV5648_CROP_START_Y_L_REG\t\t0x3803\n#define OV5648_CROP_START_Y_L(v)\t\t((v) & GENMASK(7, 0))\n#define OV5648_CROP_END_X_H_REG\t\t\t0x3804\n#define OV5648_CROP_END_X_H(v)\t\t\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV5648_CROP_END_X_L_REG\t\t\t0x3805\n#define OV5648_CROP_END_X_L(v)\t\t\t((v) & GENMASK(7, 0))\n#define OV5648_CROP_END_Y_H_REG\t\t\t0x3806\n#define OV5648_CROP_END_Y_H(v)\t\t\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV5648_CROP_END_Y_L_REG\t\t\t0x3807\n#define OV5648_CROP_END_Y_L(v)\t\t\t((v) & GENMASK(7, 0))\n#define OV5648_OUTPUT_SIZE_X_H_REG\t\t0x3808\n#define OV5648_OUTPUT_SIZE_X_H(v)\t\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV5648_OUTPUT_SIZE_X_L_REG\t\t0x3809\n#define OV5648_OUTPUT_SIZE_X_L(v)\t\t((v) & GENMASK(7, 0))\n#define OV5648_OUTPUT_SIZE_Y_H_REG\t\t0x380a\n#define OV5648_OUTPUT_SIZE_Y_H(v)\t\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV5648_OUTPUT_SIZE_Y_L_REG\t\t0x380b\n#define OV5648_OUTPUT_SIZE_Y_L(v)\t\t((v) & GENMASK(7, 0))\n#define OV5648_HTS_H_REG\t\t\t0x380c\n#define OV5648_HTS_H(v)\t\t\t\t(((v) & GENMASK(12, 8)) >> 8)\n#define OV5648_HTS_L_REG\t\t\t0x380d\n#define OV5648_HTS_L(v)\t\t\t\t((v) & GENMASK(7, 0))\n#define OV5648_VTS_H_REG\t\t\t0x380e\n#define OV5648_VTS_H(v)\t\t\t\t(((v) & GENMASK(15, 8)) >> 8)\n#define OV5648_VTS_L_REG\t\t\t0x380f\n#define OV5648_VTS_L(v)\t\t\t\t((v) & GENMASK(7, 0))\n#define OV5648_OFFSET_X_H_REG\t\t\t0x3810\n#define OV5648_OFFSET_X_H(v)\t\t\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV5648_OFFSET_X_L_REG\t\t\t0x3811\n#define OV5648_OFFSET_X_L(v)\t\t\t((v) & GENMASK(7, 0))\n#define OV5648_OFFSET_Y_H_REG\t\t\t0x3812\n#define OV5648_OFFSET_Y_H(v)\t\t\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV5648_OFFSET_Y_L_REG\t\t\t0x3813\n#define OV5648_OFFSET_Y_L(v)\t\t\t((v) & GENMASK(7, 0))\n#define OV5648_SUB_INC_X_REG\t\t\t0x3814\n#define OV5648_SUB_INC_X_ODD(v)\t\t\t(((v) << 4) & GENMASK(7, 4))\n#define OV5648_SUB_INC_X_EVEN(v)\t\t((v) & GENMASK(3, 0))\n#define OV5648_SUB_INC_Y_REG\t\t\t0x3815\n#define OV5648_SUB_INC_Y_ODD(v)\t\t\t(((v) << 4) & GENMASK(7, 4))\n#define OV5648_SUB_INC_Y_EVEN(v)\t\t((v) & GENMASK(3, 0))\n#define OV5648_HSYNCST_H_REG\t\t\t0x3816\n#define OV5648_HSYNCST_H(v)\t\t\t(((v) >> 8) & 0xf)\n#define OV5648_HSYNCST_L_REG\t\t\t0x3817\n#define OV5648_HSYNCST_L(v)\t\t\t((v) & GENMASK(7, 0))\n#define OV5648_HSYNCW_H_REG\t\t\t0x3818\n#define OV5648_HSYNCW_H(v)\t\t\t(((v) >> 8) & 0xf)\n#define OV5648_HSYNCW_L_REG\t\t\t0x3819\n#define OV5648_HSYNCW_L(v)\t\t\t((v) & GENMASK(7, 0))\n\n#define OV5648_TC20_REG\t\t\t\t0x3820\n#define OV5648_TC20_DEBUG\t\t\tBIT(6)\n#define OV5648_TC20_FLIP_VERT_ISP_EN\t\tBIT(2)\n#define OV5648_TC20_FLIP_VERT_SENSOR_EN\t\tBIT(1)\n#define OV5648_TC20_BINNING_VERT_EN\t\tBIT(0)\n#define OV5648_TC21_REG\t\t\t\t0x3821\n#define OV5648_TC21_FLIP_HORZ_ISP_EN\t\tBIT(2)\n#define OV5648_TC21_FLIP_HORZ_SENSOR_EN\t\tBIT(1)\n#define OV5648_TC21_BINNING_HORZ_EN\t\tBIT(0)\n\n \n\n#define OV5648_STROBE_REG\t\t\t0x3b00\n#define OV5648_FREX_EXP_HH_REG\t\t\t0x3b01\n#define OV5648_SHUTTER_DLY_H_REG\t\t0x3b02\n#define OV5648_SHUTTER_DLY_L_REG\t\t0x3b03\n#define OV5648_FREX_EXP_H_REG\t\t\t0x3b04\n#define OV5648_FREX_EXP_L_REG\t\t\t0x3b05\n#define OV5648_FREX_CTRL_REG\t\t\t0x3b06\n#define OV5648_FREX_MODE_SEL_REG\t\t0x3b07\n#define OV5648_FREX_MODE_SEL_FREX_SA1\t\tBIT(4)\n#define OV5648_FREX_MODE_SEL_FX1_FM_EN\t\tBIT(3)\n#define OV5648_FREX_MODE_SEL_FREX_INV\t\tBIT(2)\n#define OV5648_FREX_MODE_SEL_MODE1\t\t0x0\n#define OV5648_FREX_MODE_SEL_MODE2\t\t0x1\n#define OV5648_FREX_MODE_SEL_ROLLING\t\t0x2\n#define OV5648_FREX_EXP_REQ_REG\t\t\t0x3b08\n#define OV5648_FREX_SHUTTER_DLY_REG\t\t0x3b09\n#define OV5648_FREX_RST_LEN_REG\t\t\t0x3b0a\n#define OV5648_STROBE_WIDTH_HH_REG\t\t0x3b0b\n#define OV5648_STROBE_WIDTH_H_REG\t\t0x3b0c\n\n \n\n#define OV5648_OTP_DATA_REG_BASE\t\t0x3d00\n#define OV5648_OTP_PROGRAM_CTRL_REG\t\t0x3d80\n#define OV5648_OTP_LOAD_CTRL_REG\t\t0x3d81\n\n \n\n#define OV5648_PSRAM_CTRL1_REG\t\t\t0x3f01\n#define OV5648_PSRAM_CTRLF_REG\t\t\t0x3f0f\n\n \n\n#define OV5648_BLC_CTRL0_REG\t\t\t0x4000\n#define OV5648_BLC_CTRL1_REG\t\t\t0x4001\n#define OV5648_BLC_CTRL1_START_LINE(v)\t\t((v) & GENMASK(5, 0))\n#define OV5648_BLC_CTRL2_REG\t\t\t0x4002\n#define OV5648_BLC_CTRL2_AUTO_EN\t\tBIT(6)\n#define OV5648_BLC_CTRL2_RESET_FRAME_NUM(v)\t((v) & GENMASK(5, 0))\n#define OV5648_BLC_CTRL3_REG\t\t\t0x4003\n#define OV5648_BLC_LINE_NUM_REG\t\t\t0x4004\n#define OV5648_BLC_LINE_NUM(v)\t\t\t((v) & GENMASK(7, 0))\n#define OV5648_BLC_CTRL5_REG\t\t\t0x4005\n#define OV5648_BLC_CTRL5_UPDATE_EN\t\tBIT(1)\n#define OV5648_BLC_LEVEL_REG\t\t\t0x4009\n\n \n\n#define OV5648_FRAME_CTRL_REG\t\t\t0x4200\n#define OV5648_FRAME_ON_NUM_REG\t\t\t0x4201\n#define OV5648_FRAME_OFF_NUM_REG\t\t0x4202\n\n \n\n#define OV5648_MIPI_CTRL0_REG\t\t\t0x4800\n#define OV5648_MIPI_CTRL0_CLK_LANE_AUTOGATE\tBIT(5)\n#define OV5648_MIPI_CTRL0_LANE_SYNC_EN\t\tBIT(4)\n#define OV5648_MIPI_CTRL0_LANE_SELECT_LANE1\t0\n#define OV5648_MIPI_CTRL0_LANE_SELECT_LANE2\tBIT(3)\n#define OV5648_MIPI_CTRL0_IDLE_LP00\t\t0\n#define OV5648_MIPI_CTRL0_IDLE_LP11\t\tBIT(2)\n\n#define OV5648_MIPI_CTRL1_REG\t\t\t0x4801\n#define OV5648_MIPI_CTRL2_REG\t\t\t0x4802\n#define OV5648_MIPI_CTRL3_REG\t\t\t0x4803\n#define OV5648_MIPI_CTRL4_REG\t\t\t0x4804\n#define OV5648_MIPI_CTRL5_REG\t\t\t0x4805\n#define OV5648_MIPI_MAX_FRAME_COUNT_H_REG\t0x4810\n#define OV5648_MIPI_MAX_FRAME_COUNT_L_REG\t0x4811\n#define OV5648_MIPI_CTRL14_REG\t\t\t0x4814\n#define OV5648_MIPI_DT_SPKT_REG\t\t\t0x4815\n#define OV5648_MIPI_HS_ZERO_MIN_H_REG\t\t0x4818\n#define OV5648_MIPI_HS_ZERO_MIN_L_REG\t\t0x4819\n#define OV5648_MIPI_HS_TRAIN_MIN_H_REG\t\t0x481a\n#define OV5648_MIPI_HS_TRAIN_MIN_L_REG\t\t0x481b\n#define OV5648_MIPI_CLK_ZERO_MIN_H_REG\t\t0x481c\n#define OV5648_MIPI_CLK_ZERO_MIN_L_REG\t\t0x481d\n#define OV5648_MIPI_CLK_PREPARE_MIN_H_REG\t0x481e\n#define OV5648_MIPI_CLK_PREPARE_MIN_L_REG\t0x481f\n#define OV5648_MIPI_CLK_POST_MIN_H_REG\t\t0x4820\n#define OV5648_MIPI_CLK_POST_MIN_L_REG\t\t0x4821\n#define OV5648_MIPI_CLK_TRAIL_MIN_H_REG\t\t0x4822\n#define OV5648_MIPI_CLK_TRAIL_MIN_L_REG\t\t0x4823\n#define OV5648_MIPI_LPX_P_MIN_H_REG\t\t0x4824\n#define OV5648_MIPI_LPX_P_MIN_L_REG\t\t0x4825\n#define OV5648_MIPI_HS_PREPARE_MIN_H_REG\t0x4826\n#define OV5648_MIPI_HS_PREPARE_MIN_L_REG\t0x4827\n#define OV5648_MIPI_HS_EXIT_MIN_H_REG\t\t0x4828\n#define OV5648_MIPI_HS_EXIT_MIN_L_REG\t\t0x4829\n#define OV5648_MIPI_HS_ZERO_MIN_UI_REG\t\t0x482a\n#define OV5648_MIPI_HS_TRAIL_MIN_UI_REG\t\t0x482b\n#define OV5648_MIPI_CLK_ZERO_MIN_UI_REG\t\t0x482c\n#define OV5648_MIPI_CLK_PREPARE_MIN_UI_REG\t0x482d\n#define OV5648_MIPI_CLK_POST_MIN_UI_REG\t\t0x482e\n#define OV5648_MIPI_CLK_TRAIL_MIN_UI_REG\t0x482f\n#define OV5648_MIPI_LPX_P_MIN_UI_REG\t\t0x4830\n#define OV5648_MIPI_HS_PREPARE_MIN_UI_REG\t0x4831\n#define OV5648_MIPI_HS_EXIT_MIN_UI_REG\t\t0x4832\n#define OV5648_MIPI_REG_MIN_H_REG\t\t0x4833\n#define OV5648_MIPI_REG_MIN_L_REG\t\t0x4834\n#define OV5648_MIPI_REG_MAX_H_REG\t\t0x4835\n#define OV5648_MIPI_REG_MAX_L_REG\t\t0x4836\n#define OV5648_MIPI_PCLK_PERIOD_REG\t\t0x4837\n#define OV5648_MIPI_WKUP_DLY_REG\t\t0x4838\n#define OV5648_MIPI_LP_GPIO_REG\t\t\t0x483b\n#define OV5648_MIPI_SNR_PCLK_DIV_REG\t\t0x4843\n\n \n\n#define OV5648_ISP_CTRL0_REG\t\t\t0x5000\n#define OV5648_ISP_CTRL0_BLACK_CORRECT_EN\tBIT(2)\n#define OV5648_ISP_CTRL0_WHITE_CORRECT_EN\tBIT(1)\n#define OV5648_ISP_CTRL1_REG\t\t\t0x5001\n#define OV5648_ISP_CTRL1_AWB_EN\t\t\tBIT(0)\n#define OV5648_ISP_CTRL2_REG\t\t\t0x5002\n#define OV5648_ISP_CTRL2_WIN_EN\t\t\tBIT(6)\n#define OV5648_ISP_CTRL2_OTP_EN\t\t\tBIT(1)\n#define OV5648_ISP_CTRL2_AWB_GAIN_EN\t\tBIT(0)\n#define OV5648_ISP_CTRL3_REG\t\t\t0x5003\n#define OV5648_ISP_CTRL3_BUF_EN\t\t\tBIT(3)\n#define OV5648_ISP_CTRL3_BIN_MAN_SET\t\tBIT(2)\n#define OV5648_ISP_CTRL3_BIN_AUTO_EN\t\tBIT(1)\n#define OV5648_ISP_CTRL4_REG\t\t\t0x5004\n#define OV5648_ISP_CTRL5_REG\t\t\t0x5005\n#define OV5648_ISP_CTRL6_REG\t\t\t0x5006\n#define OV5648_ISP_CTRL7_REG\t\t\t0x5007\n#define OV5648_ISP_MAN_OFFSET_X_H_REG\t\t0x5008\n#define OV5648_ISP_MAN_OFFSET_X_L_REG\t\t0x5009\n#define OV5648_ISP_MAN_OFFSET_Y_H_REG\t\t0x500a\n#define OV5648_ISP_MAN_OFFSET_Y_L_REG\t\t0x500b\n#define OV5648_ISP_MAN_WIN_OFFSET_X_H_REG\t0x500c\n#define OV5648_ISP_MAN_WIN_OFFSET_X_L_REG\t0x500d\n#define OV5648_ISP_MAN_WIN_OFFSET_Y_H_REG\t0x500e\n#define OV5648_ISP_MAN_WIN_OFFSET_Y_L_REG\t0x500f\n#define OV5648_ISP_MAN_WIN_OUTPUT_X_H_REG\t0x5010\n#define OV5648_ISP_MAN_WIN_OUTPUT_X_L_REG\t0x5011\n#define OV5648_ISP_MAN_WIN_OUTPUT_Y_H_REG\t0x5012\n#define OV5648_ISP_MAN_WIN_OUTPUT_Y_L_REG\t0x5013\n#define OV5648_ISP_MAN_INPUT_X_H_REG\t\t0x5014\n#define OV5648_ISP_MAN_INPUT_X_L_REG\t\t0x5015\n#define OV5648_ISP_MAN_INPUT_Y_H_REG\t\t0x5016\n#define OV5648_ISP_MAN_INPUT_Y_L_REG\t\t0x5017\n#define OV5648_ISP_CTRL18_REG\t\t\t0x5018\n#define OV5648_ISP_CTRL19_REG\t\t\t0x5019\n#define OV5648_ISP_CTRL1A_REG\t\t\t0x501a\n#define OV5648_ISP_CTRL1D_REG\t\t\t0x501d\n#define OV5648_ISP_CTRL1F_REG\t\t\t0x501f\n#define OV5648_ISP_CTRL1F_OUTPUT_EN\t\t3\n#define OV5648_ISP_CTRL25_REG\t\t\t0x5025\n\n#define OV5648_ISP_CTRL3D_REG\t\t\t0x503d\n#define OV5648_ISP_CTRL3D_PATTERN_EN\t\tBIT(7)\n#define OV5648_ISP_CTRL3D_ROLLING_BAR_EN\tBIT(6)\n#define OV5648_ISP_CTRL3D_TRANSPARENT_MODE\tBIT(5)\n#define OV5648_ISP_CTRL3D_SQUARES_BW_MODE\tBIT(4)\n#define OV5648_ISP_CTRL3D_PATTERN_COLOR_BARS\t0\n#define OV5648_ISP_CTRL3D_PATTERN_RANDOM_DATA\t1\n#define OV5648_ISP_CTRL3D_PATTERN_COLOR_SQUARES\t2\n#define OV5648_ISP_CTRL3D_PATTERN_INPUT\t\t3\n\n#define OV5648_ISP_CTRL3E_REG\t\t\t0x503e\n#define OV5648_ISP_CTRL4B_REG\t\t\t0x504b\n#define OV5648_ISP_CTRL4B_POST_BIN_H_EN\t\tBIT(5)\n#define OV5648_ISP_CTRL4B_POST_BIN_V_EN\t\tBIT(4)\n#define OV5648_ISP_CTRL4C_REG\t\t\t0x504c\n#define OV5648_ISP_CTRL57_REG\t\t\t0x5057\n#define OV5648_ISP_CTRL58_REG\t\t\t0x5058\n#define OV5648_ISP_CTRL59_REG\t\t\t0x5059\n\n#define OV5648_ISP_WINDOW_START_X_H_REG\t\t0x5980\n#define OV5648_ISP_WINDOW_START_X_L_REG\t\t0x5981\n#define OV5648_ISP_WINDOW_START_Y_H_REG\t\t0x5982\n#define OV5648_ISP_WINDOW_START_Y_L_REG\t\t0x5983\n#define OV5648_ISP_WINDOW_WIN_X_H_REG\t\t0x5984\n#define OV5648_ISP_WINDOW_WIN_X_L_REG\t\t0x5985\n#define OV5648_ISP_WINDOW_WIN_Y_H_REG\t\t0x5986\n#define OV5648_ISP_WINDOW_WIN_Y_L_REG\t\t0x5987\n#define OV5648_ISP_WINDOW_MAN_REG\t\t0x5988\n\n \n\n#define OV5648_AWB_CTRL_REG\t\t\t0x5180\n#define OV5648_AWB_CTRL_FAST_AWB\t\tBIT(6)\n#define OV5648_AWB_CTRL_GAIN_FREEZE_EN\t\tBIT(5)\n#define OV5648_AWB_CTRL_SUM_FREEZE_EN\t\tBIT(4)\n#define OV5648_AWB_CTRL_GAIN_MANUAL_EN\t\tBIT(3)\n\n#define OV5648_AWB_DELTA_REG\t\t\t0x5181\n#define OV5648_AWB_STABLE_RANGE_REG\t\t0x5182\n#define OV5648_AWB_STABLE_RANGE_WIDE_REG\t0x5183\n#define OV5648_HSIZE_MAN_REG\t\t\t0x5185\n\n#define OV5648_GAIN_RED_MAN_H_REG\t\t0x5186\n#define OV5648_GAIN_RED_MAN_H(v)\t\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV5648_GAIN_RED_MAN_L_REG\t\t0x5187\n#define OV5648_GAIN_RED_MAN_L(v)\t\t((v) & GENMASK(7, 0))\n#define OV5648_GAIN_GREEN_MAN_H_REG\t\t0x5188\n#define OV5648_GAIN_GREEN_MAN_H(v)\t\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV5648_GAIN_GREEN_MAN_L_REG\t\t0x5189\n#define OV5648_GAIN_GREEN_MAN_L(v)\t\t((v) & GENMASK(7, 0))\n#define OV5648_GAIN_BLUE_MAN_H_REG\t\t0x518a\n#define OV5648_GAIN_BLUE_MAN_H(v)\t\t(((v) & GENMASK(11, 8)) >> 8)\n#define OV5648_GAIN_BLUE_MAN_L_REG\t\t0x518b\n#define OV5648_GAIN_BLUE_MAN_L(v)\t\t((v) & GENMASK(7, 0))\n#define OV5648_GAIN_RED_LIMIT_REG\t\t0x518c\n#define OV5648_GAIN_GREEN_LIMIT_REG\t\t0x518d\n#define OV5648_GAIN_BLUE_LIMIT_REG\t\t0x518e\n#define OV5648_AWB_FRAME_COUNT_REG\t\t0x518f\n#define OV5648_AWB_BASE_MAN_REG\t\t\t0x51df\n\n \n\n#define ov5648_subdev_sensor(s) \\\n\tcontainer_of(s, struct ov5648_sensor, subdev)\n\n#define ov5648_ctrl_subdev(c) \\\n\t(&container_of((c)->handler, struct ov5648_sensor, \\\n\t\t       ctrls.handler)->subdev)\n\n \n\nstruct ov5648_register_value {\n\tu16 address;\n\tu8 value;\n\tunsigned int delay_ms;\n};\n\n \n\nstruct ov5648_pll1_config {\n\tunsigned int pll_pre_div;\n\tunsigned int pll_mul;\n\tunsigned int sys_div;\n\tunsigned int root_div;\n\tunsigned int sclk_div;\n\tunsigned int mipi_div;\n};\n\n \n\nstruct ov5648_pll2_config {\n\tunsigned int plls_pre_div;\n\tunsigned int plls_div_r;\n\tunsigned int plls_mul;\n\tunsigned int sys_div;\n\tunsigned int sel_div;\n};\n\n \n\nstruct ov5648_mode {\n\tunsigned int crop_start_x;\n\tunsigned int offset_x;\n\tunsigned int output_size_x;\n\tunsigned int crop_end_x;\n\tunsigned int hts;\n\n\tunsigned int crop_start_y;\n\tunsigned int offset_y;\n\tunsigned int output_size_y;\n\tunsigned int crop_end_y;\n\tunsigned int vts;\n\n\tbool binning_x;\n\tbool binning_y;\n\n\tunsigned int inc_x_odd;\n\tunsigned int inc_x_even;\n\tunsigned int inc_y_odd;\n\tunsigned int inc_y_even;\n\n\t \n\tstruct v4l2_fract frame_interval[2];\n\n\t \n\tconst struct ov5648_pll1_config *pll1_config[2];\n\tconst struct ov5648_pll2_config *pll2_config;\n\n\tconst struct ov5648_register_value *register_values;\n\tunsigned int register_values_count;\n};\n\nstruct ov5648_state {\n\tconst struct ov5648_mode *mode;\n\tu32 mbus_code;\n\n\tbool streaming;\n};\n\nstruct ov5648_ctrls {\n\tstruct v4l2_ctrl *exposure_auto;\n\tstruct v4l2_ctrl *exposure;\n\n\tstruct v4l2_ctrl *gain_auto;\n\tstruct v4l2_ctrl *gain;\n\n\tstruct v4l2_ctrl *white_balance_auto;\n\tstruct v4l2_ctrl *red_balance;\n\tstruct v4l2_ctrl *blue_balance;\n\n\tstruct v4l2_ctrl *link_freq;\n\tstruct v4l2_ctrl *pixel_rate;\n\n\tstruct v4l2_ctrl_handler handler;\n};\n\nstruct ov5648_sensor {\n\tstruct device *dev;\n\tstruct i2c_client *i2c_client;\n\tstruct gpio_desc *reset;\n\tstruct gpio_desc *powerdown;\n\tstruct regulator *avdd;\n\tstruct regulator *dvdd;\n\tstruct regulator *dovdd;\n\tstruct clk *xvclk;\n\n\tstruct v4l2_fwnode_endpoint endpoint;\n\tstruct v4l2_subdev subdev;\n\tstruct media_pad pad;\n\n\tstruct mutex mutex;\n\n\tstruct ov5648_state state;\n\tstruct ov5648_ctrls ctrls;\n};\n\n \n\n \nstatic const struct ov5648_pll1_config ov5648_pll1_config_native_8_bits = {\n\t.pll_pre_div\t= 3,\n\t.pll_mul\t= 84,\n\t.sys_div\t= 2,\n\t.root_div\t= 1,\n\t.sclk_div\t= 1,\n\t.mipi_div\t= 1,\n};\n\n \nstatic const struct ov5648_pll1_config ov5648_pll1_config_native_10_bits = {\n\t.pll_pre_div\t= 3,\n\t.pll_mul\t= 105,\n\t.sys_div\t= 2,\n\t.root_div\t= 1,\n\t.sclk_div\t= 1,\n\t.mipi_div\t= 1,\n};\n\n \nstatic const struct ov5648_pll2_config ov5648_pll2_config_native = {\n\t.plls_pre_div\t= 3,\n\t.plls_div_r\t= 1,\n\t.plls_mul\t= 25,\n\t.sys_div\t= 1,\n\t.sel_div\t= 1,\n};\n\nstatic const struct ov5648_mode ov5648_modes[] = {\n\t \n\t{\n\t\t \n\t\t.crop_start_x\t= 16,\n\t\t.offset_x\t= 0,\n\t\t.output_size_x\t= 2592,\n\t\t.crop_end_x\t= 2607,\n\t\t.hts\t\t= 2816,\n\n\t\t \n\t\t.crop_start_y\t= 6,\n\t\t.offset_y\t= 0,\n\t\t.output_size_y\t= 1944,\n\t\t.crop_end_y\t= 1949,\n\t\t.vts\t\t= 1984,\n\n\t\t \n\t\t.inc_x_odd\t= 1,\n\t\t.inc_x_even\t= 1,\n\t\t.inc_y_odd\t= 1,\n\t\t.inc_y_even\t= 1,\n\n\t\t \n\t\t.frame_interval\t= {\n\t\t\t{ 1,\t15 },\n\t\t\t{ 1,\t15 },\n\t\t},\n\n\t\t \n\t\t.pll1_config\t= {\n\t\t\t&ov5648_pll1_config_native_8_bits,\n\t\t\t&ov5648_pll1_config_native_10_bits,\n\t\t},\n\t\t.pll2_config\t= &ov5648_pll2_config_native,\n\t},\n\t \n\t{\n\t\t \n\t\t.crop_start_x\t= 512,\n\t\t.offset_x\t= 0,\n\t\t.output_size_x\t= 1600,\n\t\t.crop_end_x\t= 2111,\n\t\t.hts\t\t= 2816,\n\n\t\t \n\t\t.crop_start_y\t= 378,\n\t\t.offset_y\t= 0,\n\t\t.output_size_y\t= 1200,\n\t\t.crop_end_y\t= 1577,\n\t\t.vts\t\t= 1984,\n\n\t\t \n\t\t.inc_x_odd\t= 1,\n\t\t.inc_x_even\t= 1,\n\t\t.inc_y_odd\t= 1,\n\t\t.inc_y_even\t= 1,\n\n\t\t \n\t\t.frame_interval\t= {\n\t\t\t{ 1,\t15 },\n\t\t\t{ 1,\t15 },\n\t\t},\n\n\t\t \n\t\t.pll1_config\t= {\n\t\t\t&ov5648_pll1_config_native_8_bits,\n\t\t\t&ov5648_pll1_config_native_10_bits,\n\t\t},\n\t\t.pll2_config\t= &ov5648_pll2_config_native,\n\t},\n\t \n\t{\n\t\t \n\t\t.crop_start_x\t= 352,\n\t\t.offset_x\t= 0,\n\t\t.output_size_x\t= 1920,\n\t\t.crop_end_x\t= 2271,\n\t\t.hts\t\t= 2816,\n\n\t\t \n\t\t.crop_start_y\t= 438,\n\t\t.offset_y\t= 0,\n\t\t.output_size_y\t= 1080,\n\t\t.crop_end_y\t= 1517,\n\t\t.vts\t\t= 1984,\n\n\t\t \n\t\t.inc_x_odd\t= 1,\n\t\t.inc_x_even\t= 1,\n\t\t.inc_y_odd\t= 1,\n\t\t.inc_y_even\t= 1,\n\n\t\t \n\t\t.frame_interval\t= {\n\t\t\t{ 1,\t15 },\n\t\t\t{ 1,\t15 },\n\t\t},\n\n\t\t \n\t\t.pll1_config\t= {\n\t\t\t&ov5648_pll1_config_native_8_bits,\n\t\t\t&ov5648_pll1_config_native_10_bits,\n\t\t},\n\t\t.pll2_config\t= &ov5648_pll2_config_native,\n\t},\n\t \n\t{\n\t\t \n\t\t.crop_start_x\t= 16,\n\t\t.offset_x\t= 8,\n\t\t.output_size_x\t= 1280,\n\t\t.crop_end_x\t= 2607,\n\t\t.hts\t\t= 1912,\n\n\t\t \n\t\t.crop_start_y\t= 6,\n\t\t.offset_y\t= 6,\n\t\t.output_size_y\t= 960,\n\t\t.crop_end_y\t= 1949,\n\t\t.vts\t\t= 1496,\n\n\t\t \n\t\t.binning_x\t= true,\n\n\t\t \n\t\t.inc_x_odd\t= 3,\n\t\t.inc_x_even\t= 1,\n\t\t.inc_y_odd\t= 3,\n\t\t.inc_y_even\t= 1,\n\n\t\t \n\t\t.frame_interval\t= {\n\t\t\t{ 1,\t30 },\n\t\t\t{ 1,\t30 },\n\t\t},\n\n\t\t \n\t\t.pll1_config\t= {\n\t\t\t&ov5648_pll1_config_native_8_bits,\n\t\t\t&ov5648_pll1_config_native_10_bits,\n\t\t},\n\t\t.pll2_config\t= &ov5648_pll2_config_native,\n\t},\n\t \n\t{\n\t\t \n\t\t.crop_start_x\t= 16,\n\t\t.offset_x\t= 8,\n\t\t.output_size_x\t= 1280,\n\t\t.crop_end_x\t= 2607,\n\t\t.hts\t\t= 1912,\n\n\t\t \n\t\t.crop_start_y\t= 254,\n\t\t.offset_y\t= 2,\n\t\t.output_size_y\t= 720,\n\t\t.crop_end_y\t= 1701,\n\t\t.vts\t\t= 1496,\n\n\t\t \n\t\t.binning_x\t= true,\n\n\t\t \n\t\t.inc_x_odd\t= 3,\n\t\t.inc_x_even\t= 1,\n\t\t.inc_y_odd\t= 3,\n\t\t.inc_y_even\t= 1,\n\n\t\t \n\t\t.frame_interval\t= {\n\t\t\t{ 1,\t30 },\n\t\t\t{ 1,\t30 },\n\t\t},\n\n\t\t \n\t\t.pll1_config\t= {\n\t\t\t&ov5648_pll1_config_native_8_bits,\n\t\t\t&ov5648_pll1_config_native_10_bits,\n\t\t},\n\t\t.pll2_config\t= &ov5648_pll2_config_native,\n\t},\n\t \n\t{\n\t\t \n\t\t.crop_start_x\t= 0,\n\t\t.offset_x\t= 8,\n\t\t.output_size_x\t= 640,\n\t\t.crop_end_x\t= 2623,\n\t\t.hts\t\t= 1896,\n\n\t\t \n\t\t.crop_start_y\t= 0,\n\t\t.offset_y\t= 2,\n\t\t.output_size_y\t= 480,\n\t\t.crop_end_y\t= 1953,\n\t\t.vts\t\t= 984,\n\n\t\t \n\t\t.binning_x\t= true,\n\n\t\t \n\t\t.inc_x_odd\t= 7,\n\t\t.inc_x_even\t= 1,\n\t\t.inc_y_odd\t= 7,\n\t\t.inc_y_even\t= 1,\n\n\t\t \n\t\t.frame_interval\t= {\n\t\t\t{ 1,\t30 },\n\t\t\t{ 1,\t30 },\n\t\t},\n\n\t\t \n\t\t.pll1_config\t= {\n\t\t\t&ov5648_pll1_config_native_8_bits,\n\t\t\t&ov5648_pll1_config_native_10_bits,\n\t\t},\n\t\t.pll2_config\t= &ov5648_pll2_config_native,\n\t},\n};\n\nstatic const u32 ov5648_mbus_codes[] = {\n\tMEDIA_BUS_FMT_SBGGR8_1X8,\n\tMEDIA_BUS_FMT_SBGGR10_1X10,\n};\n\nstatic const struct ov5648_register_value ov5648_init_sequence[] = {\n\t \n\t{ OV5648_PSRAM_CTRL1_REG, 0x0d },\n\t{ OV5648_PSRAM_CTRLF_REG, 0xf5 },\n};\n\nstatic const s64 ov5648_link_freq_menu[] = {\n\t210000000,\n\t168000000,\n};\n\nstatic const char *const ov5648_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Random data\",\n\t\"Color bars\",\n\t\"Color bars with rolling bar\",\n\t\"Color squares\",\n\t\"Color squares with rolling bar\"\n};\n\nstatic const u8 ov5648_test_pattern_bits[] = {\n\t0,\n\tOV5648_ISP_CTRL3D_PATTERN_EN | OV5648_ISP_CTRL3D_PATTERN_RANDOM_DATA,\n\tOV5648_ISP_CTRL3D_PATTERN_EN | OV5648_ISP_CTRL3D_PATTERN_COLOR_BARS,\n\tOV5648_ISP_CTRL3D_PATTERN_EN | OV5648_ISP_CTRL3D_ROLLING_BAR_EN |\n\tOV5648_ISP_CTRL3D_PATTERN_COLOR_BARS,\n\tOV5648_ISP_CTRL3D_PATTERN_EN | OV5648_ISP_CTRL3D_PATTERN_COLOR_SQUARES,\n\tOV5648_ISP_CTRL3D_PATTERN_EN | OV5648_ISP_CTRL3D_ROLLING_BAR_EN |\n\tOV5648_ISP_CTRL3D_PATTERN_COLOR_SQUARES,\n};\n\n \n\nstatic int ov5648_read(struct ov5648_sensor *sensor, u16 address, u8 *value)\n{\n\tunsigned char data[2] = { address >> 8, address & 0xff };\n\tstruct i2c_client *client = sensor->i2c_client;\n\tint ret;\n\n\tret = i2c_master_send(client, data, sizeof(data));\n\tif (ret < 0) {\n\t\tdev_dbg(&client->dev, \"i2c send error at address %#04x\\n\",\n\t\t\taddress);\n\t\treturn ret;\n\t}\n\n\tret = i2c_master_recv(client, value, 1);\n\tif (ret < 0) {\n\t\tdev_dbg(&client->dev, \"i2c recv error at address %#04x\\n\",\n\t\t\taddress);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov5648_write(struct ov5648_sensor *sensor, u16 address, u8 value)\n{\n\tunsigned char data[3] = { address >> 8, address & 0xff, value };\n\tstruct i2c_client *client = sensor->i2c_client;\n\tint ret;\n\n\tret = i2c_master_send(client, data, sizeof(data));\n\tif (ret < 0) {\n\t\tdev_dbg(&client->dev, \"i2c send error at address %#04x\\n\",\n\t\t\taddress);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov5648_write_sequence(struct ov5648_sensor *sensor,\n\t\t\t\t const struct ov5648_register_value *sequence,\n\t\t\t\t unsigned int sequence_count)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < sequence_count; i++) {\n\t\tret = ov5648_write(sensor, sequence[i].address,\n\t\t\t\t   sequence[i].value);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (sequence[i].delay_ms)\n\t\t\tmsleep(sequence[i].delay_ms);\n\t}\n\n\treturn ret;\n}\n\nstatic int ov5648_update_bits(struct ov5648_sensor *sensor, u16 address,\n\t\t\t      u8 mask, u8 bits)\n{\n\tu8 value = 0;\n\tint ret;\n\n\tret = ov5648_read(sensor, address, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tvalue &= ~mask;\n\tvalue |= bits;\n\n\tret = ov5648_write(sensor, address, value);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \n\nstatic int ov5648_sw_reset(struct ov5648_sensor *sensor)\n{\n\treturn ov5648_write(sensor, OV5648_SW_RESET_REG, OV5648_SW_RESET_RESET);\n}\n\nstatic int ov5648_sw_standby(struct ov5648_sensor *sensor, int standby)\n{\n\tu8 value = 0;\n\n\tif (!standby)\n\t\tvalue = OV5648_SW_STANDBY_STREAM_ON;\n\n\treturn ov5648_write(sensor, OV5648_SW_STANDBY_REG, value);\n}\n\nstatic int ov5648_chip_id_check(struct ov5648_sensor *sensor)\n{\n\tu16 regs[] = { OV5648_CHIP_ID_H_REG, OV5648_CHIP_ID_L_REG };\n\tu8 values[] = { OV5648_CHIP_ID_H_VALUE, OV5648_CHIP_ID_L_VALUE };\n\tunsigned int i;\n\tu8 value;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(regs); i++) {\n\t\tret = ov5648_read(sensor, regs[i], &value);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (value != values[i]) {\n\t\t\tdev_err(sensor->dev,\n\t\t\t\t\"chip id value mismatch: %#x instead of %#x\\n\",\n\t\t\t\tvalue, values[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ov5648_avdd_internal_power(struct ov5648_sensor *sensor, int on)\n{\n\treturn ov5648_write(sensor, OV5648_A_PWC_PK_O0_REG,\n\t\t\t    on ? 0 : OV5648_A_PWC_PK_O0_BP_REGULATOR_N);\n}\n\nstatic int ov5648_pad_configure(struct ov5648_sensor *sensor)\n{\n\tint ret;\n\n\t \n\n\tret = ov5648_write(sensor, OV5648_PAD_OEN1_REG, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_PAD_OEN2_REG, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\treturn ov5648_write(sensor, OV5648_PAD_PK_REG,\n\t\t\t    OV5648_PAD_PK_DRIVE_STRENGTH_1X |\n\t\t\t    OV5648_PAD_PK_FREX_N);\n}\n\nstatic int ov5648_mipi_configure(struct ov5648_sensor *sensor)\n{\n\tstruct v4l2_mbus_config_mipi_csi2 *bus_mipi_csi2 =\n\t\t&sensor->endpoint.bus.mipi_csi2;\n\tunsigned int lanes_count = bus_mipi_csi2->num_data_lanes;\n\tint ret;\n\n\tret = ov5648_write(sensor, OV5648_MIPI_CTRL0_REG,\n\t\t\t   OV5648_MIPI_CTRL0_CLK_LANE_AUTOGATE |\n\t\t\t   OV5648_MIPI_CTRL0_LANE_SELECT_LANE1 |\n\t\t\t   OV5648_MIPI_CTRL0_IDLE_LP11);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov5648_write(sensor, OV5648_MIPI_SC_CTRL0_REG,\n\t\t\t    OV5648_MIPI_SC_CTRL0_MIPI_LANES(lanes_count) |\n\t\t\t    OV5648_MIPI_SC_CTRL0_PHY_LP_RX_PD |\n\t\t\t    OV5648_MIPI_SC_CTRL0_MIPI_EN);\n}\n\nstatic int ov5648_black_level_configure(struct ov5648_sensor *sensor)\n{\n\tint ret;\n\n\t \n\n\tret = ov5648_write(sensor, OV5648_BLC_CTRL1_REG,\n\t\t\t   OV5648_BLC_CTRL1_START_LINE(2));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_BLC_CTRL2_REG,\n\t\t\t   OV5648_BLC_CTRL2_AUTO_EN |\n\t\t\t   OV5648_BLC_CTRL2_RESET_FRAME_NUM(5));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_BLC_LINE_NUM_REG,\n\t\t\t   OV5648_BLC_LINE_NUM(4));\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov5648_update_bits(sensor, OV5648_BLC_CTRL5_REG,\n\t\t\t\t  OV5648_BLC_CTRL5_UPDATE_EN,\n\t\t\t\t  OV5648_BLC_CTRL5_UPDATE_EN);\n}\n\nstatic int ov5648_isp_configure(struct ov5648_sensor *sensor)\n{\n\tu8 bits;\n\tint ret;\n\n\t \n\tbits = OV5648_ISP_CTRL0_BLACK_CORRECT_EN |\n\t       OV5648_ISP_CTRL0_WHITE_CORRECT_EN;\n\n\tret = ov5648_update_bits(sensor, OV5648_ISP_CTRL0_REG, bits, bits);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov5648_write(sensor, OV5648_ISP_CTRL1_REG,\n\t\t\t   OV5648_ISP_CTRL1_AWB_EN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov5648_write(sensor, OV5648_ISP_CTRL2_REG,\n\t\t\t   OV5648_ISP_CTRL2_WIN_EN |\n\t\t\t   OV5648_ISP_CTRL2_AWB_GAIN_EN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov5648_write(sensor, OV5648_ISP_CTRL3_REG,\n\t\t\t   OV5648_ISP_CTRL3_BUF_EN |\n\t\t\t   OV5648_ISP_CTRL3_BIN_AUTO_EN);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_ISP_CTRL4_REG, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_ISP_CTRL1F_REG,\n\t\t\t   OV5648_ISP_CTRL1F_OUTPUT_EN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov5648_write(sensor, OV5648_ISP_CTRL4B_REG,\n\t\t\t   OV5648_ISP_CTRL4B_POST_BIN_H_EN |\n\t\t\t   OV5648_ISP_CTRL4B_POST_BIN_V_EN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ov5648_write(sensor, OV5648_AEC_CTRL0_REG,\n\t\t\t   OV5648_AEC_CTRL0_DEBUG |\n\t\t\t   OV5648_AEC_CTRL0_START_SEL_EN);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov5648_write(sensor, OV5648_MANUAL_CTRL_REG,\n\t\t\t    OV5648_MANUAL_CTRL_FRAME_DELAY(1));\n}\n\nstatic unsigned long ov5648_mode_pll1_rate(struct ov5648_sensor *sensor,\n\t\t\t\t\t   const struct ov5648_pll1_config *config)\n{\n\tunsigned long xvclk_rate;\n\tunsigned long pll1_rate;\n\n\txvclk_rate = clk_get_rate(sensor->xvclk);\n\tpll1_rate = xvclk_rate * config->pll_mul;\n\n\tswitch (config->pll_pre_div) {\n\tcase 5:\n\t\tpll1_rate *= 3;\n\t\tpll1_rate /= 2;\n\t\tbreak;\n\tcase 7:\n\t\tpll1_rate *= 5;\n\t\tpll1_rate /= 2;\n\t\tbreak;\n\tdefault:\n\t\tpll1_rate /= config->pll_pre_div;\n\t\tbreak;\n\t}\n\n\treturn pll1_rate;\n}\n\nstatic int ov5648_mode_pll1_configure(struct ov5648_sensor *sensor,\n\t\t\t\t      const struct ov5648_mode *mode,\n\t\t\t\t      u32 mbus_code)\n{\n\tconst struct ov5648_pll1_config *config;\n\tu8 value;\n\tint ret;\n\n\tvalue = OV5648_PLL_CTRL0_PLL_CHARGE_PUMP(1);\n\n\tswitch (mbus_code) {\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\t\tconfig = mode->pll1_config[0];\n\t\tvalue |= OV5648_PLL_CTRL0_BITS(8);\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR10_1X10:\n\t\tconfig = mode->pll1_config[1];\n\t\tvalue |= OV5648_PLL_CTRL0_BITS(10);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = ov5648_write(sensor, OV5648_PLL_CTRL0_REG, value);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_PLL_DIV_REG,\n\t\t\t   OV5648_PLL_DIV_ROOT_DIV(config->root_div) |\n\t\t\t   OV5648_PLL_DIV_PLL_PRE_DIV(config->pll_pre_div));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_PLL_MUL_REG,\n\t\t\t   OV5648_PLL_MUL(config->pll_mul));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_PLL_CTRL1_REG,\n\t\t\t   OV5648_PLL_CTRL1_SYS_DIV(config->sys_div) |\n\t\t\t   OV5648_PLL_CTRL1_MIPI_DIV(config->mipi_div));\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov5648_write(sensor, OV5648_SRB_CTRL_REG,\n\t\t\t    OV5648_SRB_CTRL_SCLK_DIV(config->sclk_div) |\n\t\t\t    OV5648_SRB_CTRL_SCLK_ARBITER_EN);\n}\n\nstatic int ov5648_mode_pll2_configure(struct ov5648_sensor *sensor,\n\t\t\t\t      const struct ov5648_mode *mode)\n{\n\tconst struct ov5648_pll2_config *config = mode->pll2_config;\n\tint ret;\n\n\tret = ov5648_write(sensor, OV5648_PLLS_DIV_REG,\n\t\t\t   OV5648_PLLS_DIV_PLLS_PRE_DIV(config->plls_pre_div) |\n\t\t\t   OV5648_PLLS_DIV_PLLS_DIV_R(config->plls_div_r) |\n\t\t\t   OV5648_PLLS_DIV_PLLS_SEL_DIV(config->sel_div));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_PLLS_MUL_REG,\n\t\t\t   OV5648_PLLS_MUL(config->plls_mul));\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov5648_write(sensor, OV5648_PLLS_CTRL_REG,\n\t\t\t    OV5648_PLLS_CTRL_PLL_CHARGE_PUMP(1) |\n\t\t\t    OV5648_PLLS_CTRL_SYS_DIV(config->sys_div));\n}\n\nstatic int ov5648_mode_configure(struct ov5648_sensor *sensor,\n\t\t\t\t const struct ov5648_mode *mode, u32 mbus_code)\n{\n\tint ret;\n\n\t \n\n\tret = ov5648_write(sensor, OV5648_CROP_START_X_H_REG,\n\t\t\t   OV5648_CROP_START_X_H(mode->crop_start_x));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_CROP_START_X_L_REG,\n\t\t\t   OV5648_CROP_START_X_L(mode->crop_start_x));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov5648_write(sensor, OV5648_OFFSET_X_H_REG,\n\t\t\t   OV5648_OFFSET_X_H(mode->offset_x));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_OFFSET_X_L_REG,\n\t\t\t   OV5648_OFFSET_X_L(mode->offset_x));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov5648_write(sensor, OV5648_OUTPUT_SIZE_X_H_REG,\n\t\t\t   OV5648_OUTPUT_SIZE_X_H(mode->output_size_x));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_OUTPUT_SIZE_X_L_REG,\n\t\t\t   OV5648_OUTPUT_SIZE_X_L(mode->output_size_x));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov5648_write(sensor, OV5648_CROP_END_X_H_REG,\n\t\t\t   OV5648_CROP_END_X_H(mode->crop_end_x));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_CROP_END_X_L_REG,\n\t\t\t   OV5648_CROP_END_X_L(mode->crop_end_x));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov5648_write(sensor, OV5648_HTS_H_REG, OV5648_HTS_H(mode->hts));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_HTS_L_REG, OV5648_HTS_L(mode->hts));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov5648_write(sensor, OV5648_CROP_START_Y_H_REG,\n\t\t\t   OV5648_CROP_START_Y_H(mode->crop_start_y));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_CROP_START_Y_L_REG,\n\t\t\t   OV5648_CROP_START_Y_L(mode->crop_start_y));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov5648_write(sensor, OV5648_OFFSET_Y_H_REG,\n\t\t\t   OV5648_OFFSET_Y_H(mode->offset_y));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_OFFSET_Y_L_REG,\n\t\t\t   OV5648_OFFSET_Y_L(mode->offset_y));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov5648_write(sensor, OV5648_OUTPUT_SIZE_Y_H_REG,\n\t\t\t   OV5648_OUTPUT_SIZE_Y_H(mode->output_size_y));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_OUTPUT_SIZE_Y_L_REG,\n\t\t\t   OV5648_OUTPUT_SIZE_Y_L(mode->output_size_y));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov5648_write(sensor, OV5648_CROP_END_Y_H_REG,\n\t\t\t   OV5648_CROP_END_Y_H(mode->crop_end_y));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_CROP_END_Y_L_REG,\n\t\t\t   OV5648_CROP_END_Y_L(mode->crop_end_y));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov5648_write(sensor, OV5648_VTS_H_REG, OV5648_VTS_H(mode->vts));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_VTS_L_REG, OV5648_VTS_L(mode->vts));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\t \n\tret = ov5648_update_bits(sensor, OV5648_TC20_REG,\n\t\t\t\t OV5648_TC20_DEBUG |\n\t\t\t\t OV5648_TC20_BINNING_VERT_EN,\n\t\t\t\t mode->binning_y ? OV5648_TC20_BINNING_VERT_EN :\n\t\t\t\t 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_update_bits(sensor, OV5648_TC21_REG,\n\t\t\t\t OV5648_TC21_BINNING_HORZ_EN,\n\t\t\t\t mode->binning_x ? OV5648_TC21_BINNING_HORZ_EN :\n\t\t\t\t 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_SUB_INC_X_REG,\n\t\t\t   OV5648_SUB_INC_X_ODD(mode->inc_x_odd) |\n\t\t\t   OV5648_SUB_INC_X_EVEN(mode->inc_x_even));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_SUB_INC_Y_REG,\n\t\t\t   OV5648_SUB_INC_Y_ODD(mode->inc_y_odd) |\n\t\t\t   OV5648_SUB_INC_Y_EVEN(mode->inc_y_even));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = ov5648_mode_pll1_configure(sensor, mode, mbus_code);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_mode_pll2_configure(sensor, mode);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tif (mode->register_values) {\n\t\tret = ov5648_write_sequence(sensor, mode->register_values,\n\t\t\t\t\t    mode->register_values_count);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned long ov5648_mode_mipi_clk_rate(struct ov5648_sensor *sensor,\n\t\t\t\t\t       const struct ov5648_mode *mode,\n\t\t\t\t\t       u32 mbus_code)\n{\n\tconst struct ov5648_pll1_config *config;\n\tunsigned long pll1_rate;\n\n\tswitch (mbus_code) {\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\t\tconfig = mode->pll1_config[0];\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR10_1X10:\n\t\tconfig = mode->pll1_config[1];\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tpll1_rate = ov5648_mode_pll1_rate(sensor, config);\n\n\treturn pll1_rate / config->sys_div / config->mipi_div / 2;\n}\n\n \n\nstatic int ov5648_exposure_auto_configure(struct ov5648_sensor *sensor,\n\t\t\t\t\t  bool enable)\n{\n\treturn ov5648_update_bits(sensor, OV5648_MANUAL_CTRL_REG,\n\t\t\t\t  OV5648_MANUAL_CTRL_AEC_MANUAL_EN,\n\t\t\t\t  enable ? 0 : OV5648_MANUAL_CTRL_AEC_MANUAL_EN);\n}\n\nstatic int ov5648_exposure_configure(struct ov5648_sensor *sensor, u32 exposure)\n{\n\tstruct ov5648_ctrls *ctrls = &sensor->ctrls;\n\tint ret;\n\n\tif (ctrls->exposure_auto->val != V4L2_EXPOSURE_MANUAL)\n\t\treturn -EINVAL;\n\n\tret = ov5648_write(sensor, OV5648_EXPOSURE_CTRL_HH_REG,\n\t\t\t   OV5648_EXPOSURE_CTRL_HH(exposure));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_EXPOSURE_CTRL_H_REG,\n\t\t\t   OV5648_EXPOSURE_CTRL_H(exposure));\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov5648_write(sensor, OV5648_EXPOSURE_CTRL_L_REG,\n\t\t\t    OV5648_EXPOSURE_CTRL_L(exposure));\n}\n\nstatic int ov5648_exposure_value(struct ov5648_sensor *sensor,\n\t\t\t\t u32 *exposure)\n{\n\tu8 exposure_hh = 0, exposure_h = 0, exposure_l = 0;\n\tint ret;\n\n\tret = ov5648_read(sensor, OV5648_EXPOSURE_CTRL_HH_REG, &exposure_hh);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_read(sensor, OV5648_EXPOSURE_CTRL_H_REG, &exposure_h);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_read(sensor, OV5648_EXPOSURE_CTRL_L_REG, &exposure_l);\n\tif (ret)\n\t\treturn ret;\n\n\t*exposure = OV5648_EXPOSURE_CTRL_HH_VALUE((u32)exposure_hh) |\n\t\t    OV5648_EXPOSURE_CTRL_H_VALUE((u32)exposure_h) |\n\t\t    OV5648_EXPOSURE_CTRL_L_VALUE((u32)exposure_l);\n\n\treturn 0;\n}\n\n \n\nstatic int ov5648_gain_auto_configure(struct ov5648_sensor *sensor, bool enable)\n{\n\treturn ov5648_update_bits(sensor, OV5648_MANUAL_CTRL_REG,\n\t\t\t\t  OV5648_MANUAL_CTRL_AGC_MANUAL_EN,\n\t\t\t\t  enable ? 0 : OV5648_MANUAL_CTRL_AGC_MANUAL_EN);\n}\n\nstatic int ov5648_gain_configure(struct ov5648_sensor *sensor, u32 gain)\n{\n\tstruct ov5648_ctrls *ctrls = &sensor->ctrls;\n\tint ret;\n\n\tif (ctrls->gain_auto->val)\n\t\treturn -EINVAL;\n\n\tret = ov5648_write(sensor, OV5648_GAIN_CTRL_H_REG,\n\t\t\t   OV5648_GAIN_CTRL_H(gain));\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov5648_write(sensor, OV5648_GAIN_CTRL_L_REG,\n\t\t\t    OV5648_GAIN_CTRL_L(gain));\n}\n\nstatic int ov5648_gain_value(struct ov5648_sensor *sensor, u32 *gain)\n{\n\tu8 gain_h = 0, gain_l = 0;\n\tint ret;\n\n\tret = ov5648_read(sensor, OV5648_GAIN_CTRL_H_REG, &gain_h);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_read(sensor, OV5648_GAIN_CTRL_L_REG, &gain_l);\n\tif (ret)\n\t\treturn ret;\n\n\t*gain = OV5648_GAIN_CTRL_H_VALUE((u32)gain_h) |\n\t\tOV5648_GAIN_CTRL_L_VALUE((u32)gain_l);\n\n\treturn 0;\n}\n\n \n\nstatic int ov5648_white_balance_auto_configure(struct ov5648_sensor *sensor,\n\t\t\t\t\t       bool enable)\n{\n\treturn ov5648_write(sensor, OV5648_AWB_CTRL_REG,\n\t\t\t    enable ? 0 : OV5648_AWB_CTRL_GAIN_MANUAL_EN);\n}\n\nstatic int ov5648_white_balance_configure(struct ov5648_sensor *sensor,\n\t\t\t\t\t  u32 red_balance, u32 blue_balance)\n{\n\tstruct ov5648_ctrls *ctrls = &sensor->ctrls;\n\tint ret;\n\n\tif (ctrls->white_balance_auto->val)\n\t\treturn -EINVAL;\n\n\tret = ov5648_write(sensor, OV5648_GAIN_RED_MAN_H_REG,\n\t\t\t   OV5648_GAIN_RED_MAN_H(red_balance));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_GAIN_RED_MAN_L_REG,\n\t\t\t   OV5648_GAIN_RED_MAN_L(red_balance));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ov5648_write(sensor, OV5648_GAIN_BLUE_MAN_H_REG,\n\t\t\t   OV5648_GAIN_BLUE_MAN_H(blue_balance));\n\tif (ret)\n\t\treturn ret;\n\n\treturn ov5648_write(sensor, OV5648_GAIN_BLUE_MAN_L_REG,\n\t\t\t    OV5648_GAIN_BLUE_MAN_L(blue_balance));\n}\n\n \n\nstatic int ov5648_flip_vert_configure(struct ov5648_sensor *sensor, bool enable)\n{\n\tu8 bits = OV5648_TC20_FLIP_VERT_ISP_EN |\n\t\t  OV5648_TC20_FLIP_VERT_SENSOR_EN;\n\n\treturn ov5648_update_bits(sensor, OV5648_TC20_REG, bits,\n\t\t\t\t  enable ? bits : 0);\n}\n\nstatic int ov5648_flip_horz_configure(struct ov5648_sensor *sensor, bool enable)\n{\n\tu8 bits = OV5648_TC21_FLIP_HORZ_ISP_EN |\n\t\t  OV5648_TC21_FLIP_HORZ_SENSOR_EN;\n\n\treturn ov5648_update_bits(sensor, OV5648_TC21_REG, bits,\n\t\t\t\t  enable ? bits : 0);\n}\n\n \n\nstatic int ov5648_test_pattern_configure(struct ov5648_sensor *sensor,\n\t\t\t\t\t unsigned int index)\n{\n\tif (index >= ARRAY_SIZE(ov5648_test_pattern_bits))\n\t\treturn -EINVAL;\n\n\treturn ov5648_write(sensor, OV5648_ISP_CTRL3D_REG,\n\t\t\t    ov5648_test_pattern_bits[index]);\n}\n\n \n\nstatic int ov5648_state_mipi_configure(struct ov5648_sensor *sensor,\n\t\t\t\t       const struct ov5648_mode *mode,\n\t\t\t\t       u32 mbus_code)\n{\n\tstruct ov5648_ctrls *ctrls = &sensor->ctrls;\n\tstruct v4l2_mbus_config_mipi_csi2 *bus_mipi_csi2 =\n\t\t&sensor->endpoint.bus.mipi_csi2;\n\tunsigned long mipi_clk_rate;\n\tunsigned int bits_per_sample;\n\tunsigned int lanes_count;\n\tunsigned int i, j;\n\ts64 mipi_pixel_rate;\n\n\tmipi_clk_rate = ov5648_mode_mipi_clk_rate(sensor, mode, mbus_code);\n\tif (!mipi_clk_rate)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(ov5648_link_freq_menu); i++) {\n\t\ts64 freq = ov5648_link_freq_menu[i];\n\n\t\tif (freq == mipi_clk_rate)\n\t\t\tbreak;\n\t}\n\n\tfor (j = 0; j < sensor->endpoint.nr_of_link_frequencies; j++) {\n\t\tu64 freq = sensor->endpoint.link_frequencies[j];\n\n\t\tif (freq == mipi_clk_rate)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(ov5648_link_freq_menu)) {\n\t\tdev_err(sensor->dev,\n\t\t\t\"failed to find %lu clk rate in link freq\\n\",\n\t\t\tmipi_clk_rate);\n\t} else if (j == sensor->endpoint.nr_of_link_frequencies) {\n\t\tdev_err(sensor->dev,\n\t\t\t\"failed to find %lu clk rate in endpoint link-frequencies\\n\",\n\t\t\tmipi_clk_rate);\n\t} else {\n\t\t__v4l2_ctrl_s_ctrl(ctrls->link_freq, i);\n\t}\n\n\tswitch (mbus_code) {\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\t\tbits_per_sample = 8;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR10_1X10:\n\t\tbits_per_sample = 10;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tlanes_count = bus_mipi_csi2->num_data_lanes;\n\tmipi_pixel_rate = mipi_clk_rate * 2 * lanes_count / bits_per_sample;\n\n\t__v4l2_ctrl_s_ctrl_int64(ctrls->pixel_rate, mipi_pixel_rate);\n\n\treturn 0;\n}\n\nstatic int ov5648_state_configure(struct ov5648_sensor *sensor,\n\t\t\t\t  const struct ov5648_mode *mode,\n\t\t\t\t  u32 mbus_code)\n{\n\tint ret;\n\n\tif (sensor->state.streaming)\n\t\treturn -EBUSY;\n\n\t \n\tif (pm_runtime_enabled(sensor->dev) &&\n\t    !pm_runtime_suspended(sensor->dev)) {\n\t\tret = ov5648_mode_configure(sensor, mode, mbus_code);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = ov5648_state_mipi_configure(sensor, mode, mbus_code);\n\tif (ret)\n\t\treturn ret;\n\n\tsensor->state.mode = mode;\n\tsensor->state.mbus_code = mbus_code;\n\n\treturn 0;\n}\n\nstatic int ov5648_state_init(struct ov5648_sensor *sensor)\n{\n\tint ret;\n\n\tmutex_lock(&sensor->mutex);\n\tret = ov5648_state_configure(sensor, &ov5648_modes[0],\n\t\t\t\t     ov5648_mbus_codes[0]);\n\tmutex_unlock(&sensor->mutex);\n\n\treturn ret;\n}\n\n \n\nstatic int ov5648_sensor_init(struct ov5648_sensor *sensor)\n{\n\tint ret;\n\n\tret = ov5648_sw_reset(sensor);\n\tif (ret) {\n\t\tdev_err(sensor->dev, \"failed to perform sw reset\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ov5648_sw_standby(sensor, 1);\n\tif (ret) {\n\t\tdev_err(sensor->dev, \"failed to set sensor standby\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ov5648_chip_id_check(sensor);\n\tif (ret) {\n\t\tdev_err(sensor->dev, \"failed to check sensor chip id\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ov5648_avdd_internal_power(sensor, !sensor->avdd);\n\tif (ret) {\n\t\tdev_err(sensor->dev, \"failed to set internal avdd power\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ov5648_write_sequence(sensor, ov5648_init_sequence,\n\t\t\t\t    ARRAY_SIZE(ov5648_init_sequence));\n\tif (ret) {\n\t\tdev_err(sensor->dev, \"failed to write init sequence\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ov5648_pad_configure(sensor);\n\tif (ret) {\n\t\tdev_err(sensor->dev, \"failed to configure pad\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ov5648_mipi_configure(sensor);\n\tif (ret) {\n\t\tdev_err(sensor->dev, \"failed to configure MIPI\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ov5648_isp_configure(sensor);\n\tif (ret) {\n\t\tdev_err(sensor->dev, \"failed to configure ISP\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ov5648_black_level_configure(sensor);\n\tif (ret) {\n\t\tdev_err(sensor->dev, \"failed to configure black level\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = ov5648_state_configure(sensor, sensor->state.mode,\n\t\t\t\t     sensor->state.mbus_code);\n\tif (ret) {\n\t\tdev_err(sensor->dev, \"failed to configure state\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov5648_sensor_power(struct ov5648_sensor *sensor, bool on)\n{\n\t \n\tint ret = 0;\n\n\t \n\n\t \n\tif (on) {\n\t\tgpiod_set_value_cansleep(sensor->reset, 1);\n\t\tgpiod_set_value_cansleep(sensor->powerdown, 1);\n\n\t\tret = regulator_enable(sensor->dovdd);\n\t\tif (ret) {\n\t\t\tdev_err(sensor->dev,\n\t\t\t\t\"failed to enable DOVDD regulator\\n\");\n\t\t\tgoto disable;\n\t\t}\n\n\t\tif (sensor->avdd) {\n\t\t\tret = regulator_enable(sensor->avdd);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(sensor->dev,\n\t\t\t\t\t\"failed to enable AVDD regulator\\n\");\n\t\t\t\tgoto disable;\n\t\t\t}\n\t\t}\n\n\t\tret = regulator_enable(sensor->dvdd);\n\t\tif (ret) {\n\t\t\tdev_err(sensor->dev,\n\t\t\t\t\"failed to enable DVDD regulator\\n\");\n\t\t\tgoto disable;\n\t\t}\n\n\t\t \n\t\tusleep_range(5000, 10000);\n\n\t\tret = clk_prepare_enable(sensor->xvclk);\n\t\tif (ret) {\n\t\t\tdev_err(sensor->dev, \"failed to enable XVCLK clock\\n\");\n\t\t\tgoto disable;\n\t\t}\n\n\t\tgpiod_set_value_cansleep(sensor->reset, 0);\n\t\tgpiod_set_value_cansleep(sensor->powerdown, 0);\n\n\t\tusleep_range(20000, 25000);\n\t} else {\ndisable:\n\t\tgpiod_set_value_cansleep(sensor->powerdown, 1);\n\t\tgpiod_set_value_cansleep(sensor->reset, 1);\n\n\t\tclk_disable_unprepare(sensor->xvclk);\n\n\t\tregulator_disable(sensor->dvdd);\n\n\t\tif (sensor->avdd)\n\t\t\tregulator_disable(sensor->avdd);\n\n\t\tregulator_disable(sensor->dovdd);\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic int ov5648_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *subdev = ov5648_ctrl_subdev(ctrl);\n\tstruct ov5648_sensor *sensor = ov5648_subdev_sensor(subdev);\n\tstruct ov5648_ctrls *ctrls = &sensor->ctrls;\n\tint ret;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tret = ov5648_exposure_value(sensor, &ctrls->exposure->val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\tret = ov5648_gain_value(sensor, &ctrls->gain->val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ov5648_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_subdev *subdev = ov5648_ctrl_subdev(ctrl);\n\tstruct ov5648_sensor *sensor = ov5648_subdev_sensor(subdev);\n\tstruct ov5648_ctrls *ctrls = &sensor->ctrls;\n\tunsigned int index;\n\tbool enable;\n\tint ret;\n\n\t \n\tif (pm_runtime_suspended(sensor->dev))\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tenable = ctrl->val == V4L2_EXPOSURE_AUTO;\n\n\t\tret = ov5648_exposure_auto_configure(sensor, enable);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!enable && ctrls->exposure->is_new) {\n\t\t\tret = ov5648_exposure_configure(sensor,\n\t\t\t\t\t\t\tctrls->exposure->val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\tenable = !!ctrl->val;\n\n\t\tret = ov5648_gain_auto_configure(sensor, enable);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!enable) {\n\t\t\tret = ov5648_gain_configure(sensor, ctrls->gain->val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\tenable = !!ctrl->val;\n\n\t\tret = ov5648_white_balance_auto_configure(sensor, enable);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!enable) {\n\t\t\tret = ov5648_white_balance_configure(sensor,\n\t\t\t\t\t\t\t     ctrls->red_balance->val,\n\t\t\t\t\t\t\t     ctrls->blue_balance->val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tenable = !!ctrl->val;\n\t\treturn ov5648_flip_horz_configure(sensor, enable);\n\tcase V4L2_CID_VFLIP:\n\t\tenable = !!ctrl->val;\n\t\treturn ov5648_flip_vert_configure(sensor, enable);\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tindex = (unsigned int)ctrl->val;\n\t\treturn ov5648_test_pattern_configure(sensor, index);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops ov5648_ctrl_ops = {\n\t.g_volatile_ctrl\t= ov5648_g_volatile_ctrl,\n\t.s_ctrl\t\t\t= ov5648_s_ctrl,\n};\n\nstatic int ov5648_ctrls_init(struct ov5648_sensor *sensor)\n{\n\tstruct ov5648_ctrls *ctrls = &sensor->ctrls;\n\tstruct v4l2_ctrl_handler *handler = &ctrls->handler;\n\tconst struct v4l2_ctrl_ops *ops = &ov5648_ctrl_ops;\n\tint ret;\n\n\tv4l2_ctrl_handler_init(handler, 32);\n\n\t \n\thandler->lock = &sensor->mutex;\n\n\t \n\n\tctrls->exposure_auto = v4l2_ctrl_new_std_menu(handler, ops,\n\t\t\t\t\t\t      V4L2_CID_EXPOSURE_AUTO,\n\t\t\t\t\t\t      V4L2_EXPOSURE_MANUAL, 0,\n\t\t\t\t\t\t      V4L2_EXPOSURE_AUTO);\n\n\tctrls->exposure = v4l2_ctrl_new_std(handler, ops, V4L2_CID_EXPOSURE,\n\t\t\t\t\t    16, 1048575, 16, 512);\n\n\tv4l2_ctrl_auto_cluster(2, &ctrls->exposure_auto, 1, true);\n\n\t \n\n\tctrls->gain_auto =\n\t\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\n\tctrls->gain = v4l2_ctrl_new_std(handler, ops, V4L2_CID_GAIN, 16, 1023,\n\t\t\t\t\t16, 16);\n\n\tv4l2_ctrl_auto_cluster(2, &ctrls->gain_auto, 0, true);\n\n\t \n\n\tctrls->white_balance_auto =\n\t\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_AUTO_WHITE_BALANCE, 0,\n\t\t\t\t  1, 1, 1);\n\n\tctrls->red_balance = v4l2_ctrl_new_std(handler, ops,\n\t\t\t\t\t       V4L2_CID_RED_BALANCE, 0, 4095,\n\t\t\t\t\t       1, 1024);\n\n\tctrls->blue_balance = v4l2_ctrl_new_std(handler, ops,\n\t\t\t\t\t\tV4L2_CID_BLUE_BALANCE, 0, 4095,\n\t\t\t\t\t\t1, 1024);\n\n\tv4l2_ctrl_auto_cluster(3, &ctrls->white_balance_auto, 0, false);\n\n\t \n\n\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_HFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_VFLIP, 0, 1, 1, 0);\n\n\t \n\n\tv4l2_ctrl_new_std_menu_items(handler, ops, V4L2_CID_TEST_PATTERN,\n\t\t\t\t     ARRAY_SIZE(ov5648_test_pattern_menu) - 1,\n\t\t\t\t     0, 0, ov5648_test_pattern_menu);\n\n\t \n\n\tctrls->link_freq =\n\t\tv4l2_ctrl_new_int_menu(handler, NULL, V4L2_CID_LINK_FREQ,\n\t\t\t\t       ARRAY_SIZE(ov5648_link_freq_menu) - 1,\n\t\t\t\t       0, ov5648_link_freq_menu);\n\n\tctrls->pixel_rate =\n\t\tv4l2_ctrl_new_std(handler, NULL, V4L2_CID_PIXEL_RATE, 1,\n\t\t\t\t  INT_MAX, 1, 1);\n\n\tif (handler->error) {\n\t\tret = handler->error;\n\t\tgoto error_ctrls;\n\t}\n\n\tctrls->exposure->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\tctrls->gain->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\n\tctrls->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\tctrls->pixel_rate->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tsensor->subdev.ctrl_handler = handler;\n\n\treturn 0;\n\nerror_ctrls:\n\tv4l2_ctrl_handler_free(handler);\n\n\treturn ret;\n}\n\n \n\nstatic int ov5648_s_stream(struct v4l2_subdev *subdev, int enable)\n{\n\tstruct ov5648_sensor *sensor = ov5648_subdev_sensor(subdev);\n\tstruct ov5648_state *state = &sensor->state;\n\tint ret;\n\n\tif (enable) {\n\t\tret = pm_runtime_resume_and_get(sensor->dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&sensor->mutex);\n\tret = ov5648_sw_standby(sensor, !enable);\n\tmutex_unlock(&sensor->mutex);\n\n\tif (ret)\n\t\treturn ret;\n\n\tstate->streaming = !!enable;\n\n\tif (!enable)\n\t\tpm_runtime_put(sensor->dev);\n\n\treturn 0;\n}\n\nstatic int ov5648_g_frame_interval(struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_subdev_frame_interval *interval)\n{\n\tstruct ov5648_sensor *sensor = ov5648_subdev_sensor(subdev);\n\tconst struct ov5648_mode *mode;\n\tint ret = 0;\n\n\tmutex_lock(&sensor->mutex);\n\n\tmode = sensor->state.mode;\n\n\tswitch (sensor->state.mbus_code) {\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\t\tinterval->interval = mode->frame_interval[0];\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR10_1X10:\n\t\tinterval->interval = mode->frame_interval[1];\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&sensor->mutex);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_video_ops ov5648_subdev_video_ops = {\n\t.s_stream\t\t= ov5648_s_stream,\n\t.g_frame_interval\t= ov5648_g_frame_interval,\n\t.s_frame_interval\t= ov5648_g_frame_interval,\n};\n\n \n\nstatic int ov5648_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code_enum)\n{\n\tif (code_enum->index >= ARRAY_SIZE(ov5648_mbus_codes))\n\t\treturn -EINVAL;\n\n\tcode_enum->code = ov5648_mbus_codes[code_enum->index];\n\n\treturn 0;\n}\n\nstatic void ov5648_mbus_format_fill(struct v4l2_mbus_framefmt *mbus_format,\n\t\t\t\t    u32 mbus_code,\n\t\t\t\t    const struct ov5648_mode *mode)\n{\n\tmbus_format->width = mode->output_size_x;\n\tmbus_format->height = mode->output_size_y;\n\tmbus_format->code = mbus_code;\n\n\tmbus_format->field = V4L2_FIELD_NONE;\n\tmbus_format->colorspace = V4L2_COLORSPACE_RAW;\n\tmbus_format->ycbcr_enc =\n\t\tV4L2_MAP_YCBCR_ENC_DEFAULT(mbus_format->colorspace);\n\tmbus_format->quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\tmbus_format->xfer_func =\n\t\tV4L2_MAP_XFER_FUNC_DEFAULT(mbus_format->colorspace);\n}\n\nstatic int ov5648_get_fmt(struct v4l2_subdev *subdev,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct ov5648_sensor *sensor = ov5648_subdev_sensor(subdev);\n\tstruct v4l2_mbus_framefmt *mbus_format = &format->format;\n\n\tmutex_lock(&sensor->mutex);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\t*mbus_format = *v4l2_subdev_get_try_format(subdev, sd_state,\n\t\t\t\t\t\t\t   format->pad);\n\telse\n\t\tov5648_mbus_format_fill(mbus_format, sensor->state.mbus_code,\n\t\t\t\t\tsensor->state.mode);\n\n\tmutex_unlock(&sensor->mutex);\n\n\treturn 0;\n}\n\nstatic int ov5648_set_fmt(struct v4l2_subdev *subdev,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct ov5648_sensor *sensor = ov5648_subdev_sensor(subdev);\n\tstruct v4l2_mbus_framefmt *mbus_format = &format->format;\n\tconst struct ov5648_mode *mode;\n\tu32 mbus_code = 0;\n\tunsigned int index;\n\tint ret = 0;\n\n\tmutex_lock(&sensor->mutex);\n\n\tif (sensor->state.streaming) {\n\t\tret = -EBUSY;\n\t\tgoto complete;\n\t}\n\n\t \n\tfor (index = 0; index < ARRAY_SIZE(ov5648_mbus_codes); index++) {\n\t\tif (ov5648_mbus_codes[index] == mbus_format->code) {\n\t\t\tmbus_code = mbus_format->code;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!mbus_code)\n\t\tmbus_code = ov5648_mbus_codes[0];\n\n\t \n\tmode = v4l2_find_nearest_size(ov5648_modes, ARRAY_SIZE(ov5648_modes),\n\t\t\t\t      output_size_x, output_size_y,\n\t\t\t\t      mbus_format->width, mbus_format->height);\n\tif (!mode) {\n\t\tret = -EINVAL;\n\t\tgoto complete;\n\t}\n\n\tov5648_mbus_format_fill(mbus_format, mbus_code, mode);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\t*v4l2_subdev_get_try_format(subdev, sd_state, format->pad) =\n\t\t\t*mbus_format;\n\telse if (sensor->state.mode != mode ||\n\t\t sensor->state.mbus_code != mbus_code)\n\t\tret = ov5648_state_configure(sensor, mode, mbus_code);\n\ncomplete:\n\tmutex_unlock(&sensor->mutex);\n\n\treturn ret;\n}\n\nstatic int ov5648_enum_frame_size(struct v4l2_subdev *subdev,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *size_enum)\n{\n\tconst struct ov5648_mode *mode;\n\n\tif (size_enum->index >= ARRAY_SIZE(ov5648_modes))\n\t\treturn -EINVAL;\n\n\tmode = &ov5648_modes[size_enum->index];\n\n\tsize_enum->min_width = size_enum->max_width = mode->output_size_x;\n\tsize_enum->min_height = size_enum->max_height = mode->output_size_y;\n\n\treturn 0;\n}\n\nstatic int ov5648_enum_frame_interval(struct v4l2_subdev *subdev,\n\t\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t\t      struct v4l2_subdev_frame_interval_enum *interval_enum)\n{\n\tconst struct ov5648_mode *mode = NULL;\n\tunsigned int mode_index;\n\tunsigned int interval_index;\n\n\tif (interval_enum->index > 0)\n\t\treturn -EINVAL;\n\n\t \n\tfor (mode_index = 0, interval_index = 0;\n\t     mode_index < ARRAY_SIZE(ov5648_modes); mode_index++) {\n\t\tmode = &ov5648_modes[mode_index];\n\n\t\tif (mode->output_size_x == interval_enum->width &&\n\t\t    mode->output_size_y == interval_enum->height) {\n\t\t\tif (interval_index == interval_enum->index)\n\t\t\t\tbreak;\n\n\t\t\tinterval_index++;\n\t\t}\n\t}\n\n\tif (mode_index == ARRAY_SIZE(ov5648_modes))\n\t\treturn -EINVAL;\n\n\tswitch (interval_enum->code) {\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\t\tinterval_enum->interval = mode->frame_interval[0];\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR10_1X10:\n\t\tinterval_enum->interval = mode->frame_interval[1];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops ov5648_subdev_pad_ops = {\n\t.enum_mbus_code\t\t= ov5648_enum_mbus_code,\n\t.get_fmt\t\t= ov5648_get_fmt,\n\t.set_fmt\t\t= ov5648_set_fmt,\n\t.enum_frame_size\t= ov5648_enum_frame_size,\n\t.enum_frame_interval\t= ov5648_enum_frame_interval,\n};\n\nstatic const struct v4l2_subdev_ops ov5648_subdev_ops = {\n\t.video\t\t= &ov5648_subdev_video_ops,\n\t.pad\t\t= &ov5648_subdev_pad_ops,\n};\n\nstatic int ov5648_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct ov5648_sensor *sensor = ov5648_subdev_sensor(subdev);\n\tstruct ov5648_state *state = &sensor->state;\n\tint ret = 0;\n\n\tmutex_lock(&sensor->mutex);\n\n\tif (state->streaming) {\n\t\tret = ov5648_sw_standby(sensor, true);\n\t\tif (ret)\n\t\t\tgoto complete;\n\t}\n\n\tret = ov5648_sensor_power(sensor, false);\n\tif (ret)\n\t\tov5648_sw_standby(sensor, false);\n\ncomplete:\n\tmutex_unlock(&sensor->mutex);\n\n\treturn ret;\n}\n\nstatic int ov5648_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct ov5648_sensor *sensor = ov5648_subdev_sensor(subdev);\n\tstruct ov5648_state *state = &sensor->state;\n\tint ret = 0;\n\n\tmutex_lock(&sensor->mutex);\n\n\tret = ov5648_sensor_power(sensor, true);\n\tif (ret)\n\t\tgoto complete;\n\n\tret = ov5648_sensor_init(sensor);\n\tif (ret)\n\t\tgoto error_power;\n\n\tret = __v4l2_ctrl_handler_setup(&sensor->ctrls.handler);\n\tif (ret)\n\t\tgoto error_power;\n\n\tif (state->streaming) {\n\t\tret = ov5648_sw_standby(sensor, false);\n\t\tif (ret)\n\t\t\tgoto error_power;\n\t}\n\n\tgoto complete;\n\nerror_power:\n\tov5648_sensor_power(sensor, false);\n\ncomplete:\n\tmutex_unlock(&sensor->mutex);\n\n\treturn ret;\n}\n\nstatic int ov5648_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct fwnode_handle *handle;\n\tstruct ov5648_sensor *sensor;\n\tstruct v4l2_subdev *subdev;\n\tstruct media_pad *pad;\n\tunsigned long rate;\n\tint ret;\n\n\tsensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);\n\tif (!sensor)\n\t\treturn -ENOMEM;\n\n\tsensor->dev = dev;\n\tsensor->i2c_client = client;\n\n\t \n\n\thandle = fwnode_graph_get_next_endpoint(dev_fwnode(dev), NULL);\n\tif (!handle) {\n\t\tdev_err(dev, \"unable to find endpoint node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsensor->endpoint.bus_type = V4L2_MBUS_CSI2_DPHY;\n\n\tret = v4l2_fwnode_endpoint_alloc_parse(handle, &sensor->endpoint);\n\tfwnode_handle_put(handle);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to parse endpoint node\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\n\tsensor->powerdown = devm_gpiod_get_optional(dev, \"powerdown\",\n\t\t\t\t\t\t    GPIOD_OUT_HIGH);\n\tif (IS_ERR(sensor->powerdown)) {\n\t\tret = PTR_ERR(sensor->powerdown);\n\t\tgoto error_endpoint;\n\t}\n\n\tsensor->reset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(sensor->reset)) {\n\t\tret = PTR_ERR(sensor->reset);\n\t\tgoto error_endpoint;\n\t}\n\n\t \n\n\t \n\tsensor->dvdd = devm_regulator_get(dev, \"dvdd\");\n\tif (IS_ERR(sensor->dvdd)) {\n\t\tdev_err(dev, \"cannot get DVDD (digital core) regulator\\n\");\n\t\tret = PTR_ERR(sensor->dvdd);\n\t\tgoto error_endpoint;\n\t}\n\n\t \n\tsensor->dovdd = devm_regulator_get(dev, \"dovdd\");\n\tif (IS_ERR(sensor->dovdd)) {\n\t\tdev_err(dev, \"cannot get DOVDD (digital I/O) regulator\\n\");\n\t\tret = PTR_ERR(sensor->dovdd);\n\t\tgoto error_endpoint;\n\t}\n\n\t \n\tsensor->avdd = devm_regulator_get_optional(dev, \"avdd\");\n\tif (IS_ERR(sensor->avdd)) {\n\t\tdev_info(dev, \"no AVDD regulator provided, using internal\\n\");\n\t\tsensor->avdd = NULL;\n\t}\n\n\t \n\n\tsensor->xvclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(sensor->xvclk)) {\n\t\tdev_err(dev, \"failed to get external clock\\n\");\n\t\tret = PTR_ERR(sensor->xvclk);\n\t\tgoto error_endpoint;\n\t}\n\n\trate = clk_get_rate(sensor->xvclk);\n\tif (rate != OV5648_XVCLK_RATE) {\n\t\tdev_err(dev, \"clock rate %lu Hz is unsupported\\n\", rate);\n\t\tret = -EINVAL;\n\t\tgoto error_endpoint;\n\t}\n\n\t \n\n\tsubdev = &sensor->subdev;\n\tv4l2_i2c_subdev_init(subdev, client, &ov5648_subdev_ops);\n\n\tsubdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsubdev->entity.function = MEDIA_ENT_F_CAM_SENSOR;\n\n\tpad = &sensor->pad;\n\tpad->flags = MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&subdev->entity, 1, pad);\n\tif (ret)\n\t\tgoto error_entity;\n\n\t \n\n\tmutex_init(&sensor->mutex);\n\n\t \n\n\tret = ov5648_ctrls_init(sensor);\n\tif (ret)\n\t\tgoto error_mutex;\n\n\tret = ov5648_state_init(sensor);\n\tif (ret)\n\t\tgoto error_ctrls;\n\n\t \n\n\tpm_runtime_enable(sensor->dev);\n\tpm_runtime_set_suspended(sensor->dev);\n\n\t \n\n\tret = v4l2_async_register_subdev_sensor(subdev);\n\tif (ret)\n\t\tgoto error_pm;\n\n\treturn 0;\n\nerror_pm:\n\tpm_runtime_disable(sensor->dev);\n\nerror_ctrls:\n\tv4l2_ctrl_handler_free(&sensor->ctrls.handler);\n\nerror_mutex:\n\tmutex_destroy(&sensor->mutex);\n\nerror_entity:\n\tmedia_entity_cleanup(&sensor->subdev.entity);\n\nerror_endpoint:\n\tv4l2_fwnode_endpoint_free(&sensor->endpoint);\n\n\treturn ret;\n}\n\nstatic void ov5648_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\n\tstruct ov5648_sensor *sensor = ov5648_subdev_sensor(subdev);\n\n\tv4l2_async_unregister_subdev(subdev);\n\tpm_runtime_disable(sensor->dev);\n\tv4l2_ctrl_handler_free(&sensor->ctrls.handler);\n\tmutex_destroy(&sensor->mutex);\n\tmedia_entity_cleanup(&subdev->entity);\n\tv4l2_fwnode_endpoint_free(&sensor->endpoint);\n}\n\nstatic const struct dev_pm_ops ov5648_pm_ops = {\n\tSET_RUNTIME_PM_OPS(ov5648_suspend, ov5648_resume, NULL)\n};\n\nstatic const struct of_device_id ov5648_of_match[] = {\n\t{ .compatible = \"ovti,ov5648\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ov5648_of_match);\n\nstatic struct i2c_driver ov5648_driver = {\n\t.driver = {\n\t\t.name = \"ov5648\",\n\t\t.of_match_table = ov5648_of_match,\n\t\t.pm = &ov5648_pm_ops,\n\t},\n\t.probe = ov5648_probe,\n\t.remove = ov5648_remove,\n};\n\nmodule_i2c_driver(ov5648_driver);\n\nMODULE_AUTHOR(\"Paul Kocialkowski <paul.kocialkowski@bootlin.com>\");\nMODULE_DESCRIPTION(\"V4L2 driver for the OmniVision OV5648 image sensor\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}