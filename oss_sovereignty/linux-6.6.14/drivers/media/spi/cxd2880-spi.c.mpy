{
  "module_name": "cxd2880-spi.c",
  "hash_id": "557a23e02c3ceee74876065b9569e1c1976dd27097c00b0fab32f72bba4d7c54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/spi/cxd2880-spi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": %s: \" fmt, __func__\n\n#include <linux/spi/spi.h>\n#include <linux/regulator/consumer.h>\n#include <linux/ktime.h>\n\n#include <media/dvb_demux.h>\n#include <media/dmxdev.h>\n#include <media/dvb_frontend.h>\n#include \"cxd2880.h\"\n\n#define CXD2880_MAX_FILTER_SIZE 32\n#define BURST_WRITE_MAX 128\n#define MAX_TRANS_PKT 300\n\nstruct cxd2880_ts_buf_info {\n\tu8 read_ready:1;\n\tu8 almost_full:1;\n\tu8 almost_empty:1;\n\tu8 overflow:1;\n\tu8 underflow:1;\n\tu16 pkt_num;\n};\n\nstruct cxd2880_pid_config {\n\tu8 is_enable;\n\tu16 pid;\n};\n\nstruct cxd2880_pid_filter_config {\n\tu8 is_negative;\n\tstruct cxd2880_pid_config pid_config[CXD2880_MAX_FILTER_SIZE];\n};\n\nstruct cxd2880_dvb_spi {\n\tstruct dvb_frontend dvb_fe;\n\tstruct dvb_adapter adapter;\n\tstruct dvb_demux demux;\n\tstruct dmxdev dmxdev;\n\tstruct dmx_frontend dmx_fe;\n\tstruct task_struct *cxd2880_ts_read_thread;\n\tstruct spi_device *spi;\n\tstruct mutex spi_mutex;  \n\tint feed_count;\n\tint all_pid_feed_count;\n\tstruct regulator *vcc_supply;\n\tu8 *ts_buf;\n\tstruct cxd2880_pid_filter_config filter_config;\n};\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic int cxd2880_write_spi(struct spi_device *spi, u8 *data, u32 size)\n{\n\tstruct spi_message msg;\n\tstruct spi_transfer tx = {};\n\n\tif (!spi || !data) {\n\t\tpr_err(\"invalid arg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttx.tx_buf = data;\n\ttx.len = size;\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&tx, &msg);\n\n\treturn spi_sync(spi, &msg);\n}\n\nstatic int cxd2880_write_reg(struct spi_device *spi,\n\t\t\t     u8 sub_address, const u8 *data, u32 size)\n{\n\tu8 send_data[BURST_WRITE_MAX + 4];\n\tconst u8 *write_data_top = NULL;\n\tint ret = 0;\n\n\tif (!spi || !data) {\n\t\tpr_err(\"invalid arg\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (size > BURST_WRITE_MAX || size > U8_MAX) {\n\t\tpr_err(\"data size > WRITE_MAX\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sub_address + size > 0x100) {\n\t\tpr_err(\"out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsend_data[0] = 0x0e;\n\twrite_data_top = data;\n\n\tsend_data[1] = sub_address;\n\tsend_data[2] = (u8)size;\n\n\tmemcpy(&send_data[3], write_data_top, send_data[2]);\n\n\tret = cxd2880_write_spi(spi, send_data, send_data[2] + 3);\n\tif (ret)\n\t\tpr_err(\"write spi failed %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int cxd2880_spi_read_ts(struct spi_device *spi,\n\t\t\t       u8 *read_data,\n\t\t\t       u32 packet_num)\n{\n\tint ret;\n\tu8 data[3];\n\tstruct spi_message message;\n\tstruct spi_transfer transfer[2] = {};\n\n\tif (!spi || !read_data || !packet_num) {\n\t\tpr_err(\"invalid arg\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (packet_num > 0xffff) {\n\t\tpr_err(\"packet num > 0xffff\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata[0] = 0x10;\n\tdata[1] = packet_num >> 8;\n\tdata[2] = packet_num;\n\n\tspi_message_init(&message);\n\n\ttransfer[0].len = 3;\n\ttransfer[0].tx_buf = data;\n\tspi_message_add_tail(&transfer[0], &message);\n\ttransfer[1].len = packet_num * 188;\n\ttransfer[1].rx_buf = read_data;\n\tspi_message_add_tail(&transfer[1], &message);\n\n\tret = spi_sync(spi, &message);\n\tif (ret)\n\t\tpr_err(\"spi_sync failed\\n\");\n\n\treturn ret;\n}\n\nstatic int cxd2880_spi_read_ts_buffer_info(struct spi_device *spi,\n\t\t\t\t\t   struct cxd2880_ts_buf_info *info)\n{\n\tu8 send_data = 0x20;\n\tu8 recv_data[2];\n\tint ret;\n\n\tif (!spi || !info) {\n\t\tpr_err(\"invalid arg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = spi_write_then_read(spi, &send_data, 1,\n\t\t\t\t  recv_data, sizeof(recv_data));\n\tif (ret)\n\t\tpr_err(\"spi_write_then_read failed\\n\");\n\n\tinfo->read_ready = (recv_data[0] & 0x80) ? 1 : 0;\n\tinfo->almost_full = (recv_data[0] & 0x40) ? 1 : 0;\n\tinfo->almost_empty = (recv_data[0] & 0x20) ? 1 : 0;\n\tinfo->overflow = (recv_data[0] & 0x10) ? 1 : 0;\n\tinfo->underflow = (recv_data[0] & 0x08) ? 1 : 0;\n\tinfo->pkt_num = ((recv_data[0] & 0x07) << 8) | recv_data[1];\n\n\treturn ret;\n}\n\nstatic int cxd2880_spi_clear_ts_buffer(struct spi_device *spi)\n{\n\tu8 data = 0x03;\n\tint ret;\n\n\tret = cxd2880_write_spi(spi, &data, 1);\n\n\tif (ret)\n\t\tpr_err(\"write spi failed\\n\");\n\n\treturn ret;\n}\n\nstatic int cxd2880_set_pid_filter(struct spi_device *spi,\n\t\t\t\t  struct cxd2880_pid_filter_config *cfg)\n{\n\tu8 data[65];\n\tint i;\n\tu16 pid = 0;\n\tint ret;\n\n\tif (!spi) {\n\t\tpr_err(\"invalid arg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata[0] = 0x00;\n\tret = cxd2880_write_reg(spi, 0x00, &data[0], 1);\n\tif (ret)\n\t\treturn ret;\n\tif (!cfg) {\n\t\tdata[0] = 0x02;\n\t\tret = cxd2880_write_reg(spi, 0x50, &data[0], 1);\n\t} else {\n\t\tdata[0] = cfg->is_negative ? 0x01 : 0x00;\n\n\t\tfor (i = 0; i < CXD2880_MAX_FILTER_SIZE; i++) {\n\t\t\tpid = cfg->pid_config[i].pid;\n\t\t\tif (cfg->pid_config[i].is_enable) {\n\t\t\t\tdata[1 + (i * 2)] = (pid >> 8) | 0x20;\n\t\t\t\tdata[2 + (i * 2)] = pid & 0xff;\n\t\t\t} else {\n\t\t\t\tdata[1 + (i * 2)] = 0x00;\n\t\t\t\tdata[2 + (i * 2)] = 0x00;\n\t\t\t}\n\t\t}\n\t\tret = cxd2880_write_reg(spi, 0x50, data, 65);\n\t}\n\n\treturn ret;\n}\n\nstatic int cxd2880_update_pid_filter(struct cxd2880_dvb_spi *dvb_spi,\n\t\t\t\t     struct cxd2880_pid_filter_config *cfg,\n\t\t\t\t     bool is_all_pid_filter)\n{\n\tint ret;\n\n\tif (!dvb_spi || !cfg) {\n\t\tpr_err(\"invalid arg.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&dvb_spi->spi_mutex);\n\tif (is_all_pid_filter) {\n\t\tstruct cxd2880_pid_filter_config tmpcfg;\n\n\t\tmemset(&tmpcfg, 0, sizeof(tmpcfg));\n\t\ttmpcfg.is_negative = 1;\n\t\ttmpcfg.pid_config[0].is_enable = 1;\n\t\ttmpcfg.pid_config[0].pid = 0x1fff;\n\n\t\tret = cxd2880_set_pid_filter(dvb_spi->spi, &tmpcfg);\n\t} else {\n\t\tret = cxd2880_set_pid_filter(dvb_spi->spi, cfg);\n\t}\n\tmutex_unlock(&dvb_spi->spi_mutex);\n\n\tif (ret)\n\t\tpr_err(\"set_pid_filter failed\\n\");\n\n\treturn ret;\n}\n\nstatic int cxd2880_ts_read(void *arg)\n{\n\tstruct cxd2880_dvb_spi *dvb_spi = NULL;\n\tstruct cxd2880_ts_buf_info info;\n\tktime_t start;\n\tu32 i;\n\tint ret;\n\n\tdvb_spi = arg;\n\tif (!dvb_spi) {\n\t\tpr_err(\"invalid arg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = cxd2880_spi_clear_ts_buffer(dvb_spi->spi);\n\tif (ret) {\n\t\tpr_err(\"set_clear_ts_buffer failed\\n\");\n\t\treturn ret;\n\t}\n\n\tstart = ktime_get();\n\twhile (!kthread_should_stop()) {\n\t\tret = cxd2880_spi_read_ts_buffer_info(dvb_spi->spi,\n\t\t\t\t\t\t      &info);\n\t\tif (ret) {\n\t\t\tpr_err(\"spi_read_ts_buffer_info error\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (info.pkt_num > MAX_TRANS_PKT) {\n\t\t\tfor (i = 0; i < info.pkt_num / MAX_TRANS_PKT; i++) {\n\t\t\t\tcxd2880_spi_read_ts(dvb_spi->spi,\n\t\t\t\t\t\t    dvb_spi->ts_buf,\n\t\t\t\t\t\t    MAX_TRANS_PKT);\n\t\t\t\tdvb_dmx_swfilter(&dvb_spi->demux,\n\t\t\t\t\t\t dvb_spi->ts_buf,\n\t\t\t\t\t\t MAX_TRANS_PKT * 188);\n\t\t\t}\n\t\t\tstart = ktime_get();\n\t\t} else if ((info.pkt_num > 0) &&\n\t\t\t   (ktime_to_ms(ktime_sub(ktime_get(), start)) >= 500)) {\n\t\t\tcxd2880_spi_read_ts(dvb_spi->spi,\n\t\t\t\t\t    dvb_spi->ts_buf,\n\t\t\t\t\t    info.pkt_num);\n\t\t\tdvb_dmx_swfilter(&dvb_spi->demux,\n\t\t\t\t\t dvb_spi->ts_buf,\n\t\t\t\t\t info.pkt_num * 188);\n\t\t\tstart = ktime_get();\n\t\t} else {\n\t\t\tusleep_range(10000, 11000);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cxd2880_start_feed(struct dvb_demux_feed *feed)\n{\n\tint ret = 0;\n\tint i = 0;\n\tstruct dvb_demux *demux = NULL;\n\tstruct cxd2880_dvb_spi *dvb_spi = NULL;\n\n\tif (!feed) {\n\t\tpr_err(\"invalid arg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdemux = feed->demux;\n\tif (!demux) {\n\t\tpr_err(\"feed->demux is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdvb_spi = demux->priv;\n\n\tif (dvb_spi->feed_count == CXD2880_MAX_FILTER_SIZE) {\n\t\tpr_err(\"Exceeded maximum PID count (32).\");\n\t\tpr_err(\"Selected PID cannot be enabled.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (feed->pid == 0x2000) {\n\t\tif (dvb_spi->all_pid_feed_count == 0) {\n\t\t\tret = cxd2880_update_pid_filter(dvb_spi,\n\t\t\t\t\t\t\t&dvb_spi->filter_config,\n\t\t\t\t\t\t\ttrue);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"update pid filter failed\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tdvb_spi->all_pid_feed_count++;\n\n\t\tpr_debug(\"all PID feed (count = %d)\\n\",\n\t\t\t dvb_spi->all_pid_feed_count);\n\t} else {\n\t\tstruct cxd2880_pid_filter_config cfgtmp;\n\n\t\tcfgtmp = dvb_spi->filter_config;\n\n\t\tfor (i = 0; i < CXD2880_MAX_FILTER_SIZE; i++) {\n\t\t\tif (cfgtmp.pid_config[i].is_enable == 0) {\n\t\t\t\tcfgtmp.pid_config[i].is_enable = 1;\n\t\t\t\tcfgtmp.pid_config[i].pid = feed->pid;\n\t\t\t\tpr_debug(\"store PID %d to #%d\\n\",\n\t\t\t\t\t feed->pid, i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == CXD2880_MAX_FILTER_SIZE) {\n\t\t\tpr_err(\"PID filter is full.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!dvb_spi->all_pid_feed_count)\n\t\t\tret = cxd2880_update_pid_filter(dvb_spi,\n\t\t\t\t\t\t\t&cfgtmp,\n\t\t\t\t\t\t\tfalse);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdvb_spi->filter_config = cfgtmp;\n\t}\n\n\tif (dvb_spi->feed_count == 0) {\n\t\tdvb_spi->ts_buf =\n\t\t\tkmalloc(MAX_TRANS_PKT * 188,\n\t\t\t\tGFP_KERNEL | GFP_DMA);\n\t\tif (!dvb_spi->ts_buf) {\n\t\t\tpr_err(\"ts buffer allocate failed\\n\");\n\t\t\tmemset(&dvb_spi->filter_config, 0,\n\t\t\t       sizeof(dvb_spi->filter_config));\n\t\t\tdvb_spi->all_pid_feed_count = 0;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdvb_spi->cxd2880_ts_read_thread = kthread_run(cxd2880_ts_read,\n\t\t\t\t\t\t\t      dvb_spi,\n\t\t\t\t\t\t\t      \"cxd2880_ts_read\");\n\t\tif (IS_ERR(dvb_spi->cxd2880_ts_read_thread)) {\n\t\t\tpr_err(\"kthread_run failed\\n\");\n\t\t\tkfree(dvb_spi->ts_buf);\n\t\t\tdvb_spi->ts_buf = NULL;\n\t\t\tmemset(&dvb_spi->filter_config, 0,\n\t\t\t       sizeof(dvb_spi->filter_config));\n\t\t\tdvb_spi->all_pid_feed_count = 0;\n\t\t\treturn PTR_ERR(dvb_spi->cxd2880_ts_read_thread);\n\t\t}\n\t}\n\n\tdvb_spi->feed_count++;\n\n\tpr_debug(\"start feed (count %d)\\n\", dvb_spi->feed_count);\n\treturn 0;\n}\n\nstatic int cxd2880_stop_feed(struct dvb_demux_feed *feed)\n{\n\tint i = 0;\n\tint ret;\n\tstruct dvb_demux *demux = NULL;\n\tstruct cxd2880_dvb_spi *dvb_spi = NULL;\n\n\tif (!feed) {\n\t\tpr_err(\"invalid arg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdemux = feed->demux;\n\tif (!demux) {\n\t\tpr_err(\"feed->demux is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdvb_spi = demux->priv;\n\n\tif (!dvb_spi->feed_count) {\n\t\tpr_err(\"no feed is started\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (feed->pid == 0x2000) {\n\t\t \n\t\tif (dvb_spi->all_pid_feed_count <= 0) {\n\t\t\tpr_err(\"PID %d not found\\n\", feed->pid);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdvb_spi->all_pid_feed_count--;\n\t} else {\n\t\tstruct cxd2880_pid_filter_config cfgtmp;\n\n\t\tcfgtmp = dvb_spi->filter_config;\n\n\t\tfor (i = 0; i < CXD2880_MAX_FILTER_SIZE; i++) {\n\t\t\tif (feed->pid == cfgtmp.pid_config[i].pid &&\n\t\t\t    cfgtmp.pid_config[i].is_enable != 0) {\n\t\t\t\tcfgtmp.pid_config[i].is_enable = 0;\n\t\t\t\tcfgtmp.pid_config[i].pid = 0;\n\t\t\t\tpr_debug(\"removed PID %d from #%d\\n\",\n\t\t\t\t\t feed->pid, i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdvb_spi->filter_config = cfgtmp;\n\n\t\tif (i == CXD2880_MAX_FILTER_SIZE) {\n\t\t\tpr_err(\"PID %d not found\\n\", feed->pid);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = cxd2880_update_pid_filter(dvb_spi,\n\t\t\t\t\t&dvb_spi->filter_config,\n\t\t\t\t\tdvb_spi->all_pid_feed_count > 0);\n\tdvb_spi->feed_count--;\n\n\tif (dvb_spi->feed_count == 0) {\n\t\tint ret_stop = 0;\n\n\t\tret_stop = kthread_stop(dvb_spi->cxd2880_ts_read_thread);\n\t\tif (ret_stop) {\n\t\t\tpr_err(\"kthread_stop failed. (%d)\\n\", ret_stop);\n\t\t\tret = ret_stop;\n\t\t}\n\t\tkfree(dvb_spi->ts_buf);\n\t\tdvb_spi->ts_buf = NULL;\n\t}\n\n\tpr_debug(\"stop feed ok.(count %d)\\n\", dvb_spi->feed_count);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id cxd2880_spi_of_match[] = {\n\t{ .compatible = \"sony,cxd2880\" },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, cxd2880_spi_of_match);\n\nstatic int\ncxd2880_spi_probe(struct spi_device *spi)\n{\n\tint ret;\n\tstruct cxd2880_dvb_spi *dvb_spi = NULL;\n\tstruct cxd2880_config config;\n\n\tif (!spi) {\n\t\tpr_err(\"invalid arg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdvb_spi = kzalloc(sizeof(struct cxd2880_dvb_spi), GFP_KERNEL);\n\tif (!dvb_spi)\n\t\treturn -ENOMEM;\n\n\tdvb_spi->vcc_supply = devm_regulator_get_optional(&spi->dev, \"vcc\");\n\tif (IS_ERR(dvb_spi->vcc_supply)) {\n\t\tif (PTR_ERR(dvb_spi->vcc_supply) == -EPROBE_DEFER) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto fail_regulator;\n\t\t}\n\t\tdvb_spi->vcc_supply = NULL;\n\t} else {\n\t\tret = regulator_enable(dvb_spi->vcc_supply);\n\t\tif (ret)\n\t\t\tgoto fail_regulator;\n\t}\n\n\tdvb_spi->spi = spi;\n\tmutex_init(&dvb_spi->spi_mutex);\n\tspi_set_drvdata(spi, dvb_spi);\n\tconfig.spi = spi;\n\tconfig.spi_mutex = &dvb_spi->spi_mutex;\n\n\tret = dvb_register_adapter(&dvb_spi->adapter,\n\t\t\t\t   \"CXD2880\",\n\t\t\t\t   THIS_MODULE,\n\t\t\t\t   &spi->dev,\n\t\t\t\t   adapter_nr);\n\tif (ret < 0) {\n\t\tpr_err(\"dvb_register_adapter() failed\\n\");\n\t\tgoto fail_adapter;\n\t}\n\n\tif (!dvb_attach(cxd2880_attach, &dvb_spi->dvb_fe, &config)) {\n\t\tpr_err(\"cxd2880_attach failed\\n\");\n\t\tret = -ENODEV;\n\t\tgoto fail_attach;\n\t}\n\n\tret = dvb_register_frontend(&dvb_spi->adapter,\n\t\t\t\t    &dvb_spi->dvb_fe);\n\tif (ret < 0) {\n\t\tpr_err(\"dvb_register_frontend() failed\\n\");\n\t\tgoto fail_frontend;\n\t}\n\n\tdvb_spi->demux.dmx.capabilities = DMX_TS_FILTERING;\n\tdvb_spi->demux.priv = dvb_spi;\n\tdvb_spi->demux.filternum = CXD2880_MAX_FILTER_SIZE;\n\tdvb_spi->demux.feednum = CXD2880_MAX_FILTER_SIZE;\n\tdvb_spi->demux.start_feed = cxd2880_start_feed;\n\tdvb_spi->demux.stop_feed = cxd2880_stop_feed;\n\n\tret = dvb_dmx_init(&dvb_spi->demux);\n\tif (ret < 0) {\n\t\tpr_err(\"dvb_dmx_init() failed\\n\");\n\t\tgoto fail_dmx;\n\t}\n\n\tdvb_spi->dmxdev.filternum = CXD2880_MAX_FILTER_SIZE;\n\tdvb_spi->dmxdev.demux = &dvb_spi->demux.dmx;\n\tdvb_spi->dmxdev.capabilities = 0;\n\tret = dvb_dmxdev_init(&dvb_spi->dmxdev,\n\t\t\t      &dvb_spi->adapter);\n\tif (ret < 0) {\n\t\tpr_err(\"dvb_dmxdev_init() failed\\n\");\n\t\tgoto fail_dmxdev;\n\t}\n\n\tdvb_spi->dmx_fe.source = DMX_FRONTEND_0;\n\tret = dvb_spi->demux.dmx.add_frontend(&dvb_spi->demux.dmx,\n\t\t\t\t\t      &dvb_spi->dmx_fe);\n\tif (ret < 0) {\n\t\tpr_err(\"add_frontend() failed\\n\");\n\t\tgoto fail_dmx_fe;\n\t}\n\n\tret = dvb_spi->demux.dmx.connect_frontend(&dvb_spi->demux.dmx,\n\t\t\t\t\t\t  &dvb_spi->dmx_fe);\n\tif (ret < 0) {\n\t\tpr_err(\"connect_frontend() failed\\n\");\n\t\tgoto fail_fe_conn;\n\t}\n\n\tpr_info(\"Sony CXD2880 has successfully attached.\\n\");\n\n\treturn 0;\n\nfail_fe_conn:\n\tdvb_spi->demux.dmx.remove_frontend(&dvb_spi->demux.dmx,\n\t\t\t\t\t   &dvb_spi->dmx_fe);\nfail_dmx_fe:\n\tdvb_dmxdev_release(&dvb_spi->dmxdev);\nfail_dmxdev:\n\tdvb_dmx_release(&dvb_spi->demux);\nfail_dmx:\n\tdvb_unregister_frontend(&dvb_spi->dvb_fe);\nfail_frontend:\n\tdvb_frontend_detach(&dvb_spi->dvb_fe);\nfail_attach:\n\tdvb_unregister_adapter(&dvb_spi->adapter);\nfail_adapter:\n\tif (dvb_spi->vcc_supply)\n\t\tregulator_disable(dvb_spi->vcc_supply);\nfail_regulator:\n\tkfree(dvb_spi);\n\treturn ret;\n}\n\nstatic void\ncxd2880_spi_remove(struct spi_device *spi)\n{\n\tstruct cxd2880_dvb_spi *dvb_spi = spi_get_drvdata(spi);\n\n\tdvb_spi->demux.dmx.remove_frontend(&dvb_spi->demux.dmx,\n\t\t\t\t\t   &dvb_spi->dmx_fe);\n\tdvb_dmxdev_release(&dvb_spi->dmxdev);\n\tdvb_dmx_release(&dvb_spi->demux);\n\tdvb_unregister_frontend(&dvb_spi->dvb_fe);\n\tdvb_frontend_detach(&dvb_spi->dvb_fe);\n\tdvb_unregister_adapter(&dvb_spi->adapter);\n\n\tif (dvb_spi->vcc_supply)\n\t\tregulator_disable(dvb_spi->vcc_supply);\n\n\tkfree(dvb_spi);\n\tpr_info(\"cxd2880_spi remove ok.\\n\");\n}\n\nstatic const struct spi_device_id cxd2880_spi_id[] = {\n\t{ \"cxd2880\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(spi, cxd2880_spi_id);\n\nstatic struct spi_driver cxd2880_spi_driver = {\n\t.driver\t= {\n\t\t.name\t= \"cxd2880\",\n\t\t.of_match_table = cxd2880_spi_of_match,\n\t},\n\t.id_table = cxd2880_spi_id,\n\t.probe    = cxd2880_spi_probe,\n\t.remove   = cxd2880_spi_remove,\n};\nmodule_spi_driver(cxd2880_spi_driver);\n\nMODULE_DESCRIPTION(\"Sony CXD2880 DVB-T2/T tuner + demod driver SPI adapter\");\nMODULE_AUTHOR(\"Sony Semiconductor Solutions Corporation\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}