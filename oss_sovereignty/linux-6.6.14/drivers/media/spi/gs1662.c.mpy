{
  "module_name": "gs1662.c",
  "hash_id": "7d91b86dede5c366b18b7612e97e0f307d0942429ad19dc0b911abc92718c7c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/spi/gs1662.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/spi/spi.h>\n#include <linux/platform_device.h>\n#include <linux/ctype.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/module.h>\n\n#include <linux/videodev2.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-subdev.h>\n#include <media/v4l2-dv-timings.h>\n#include <linux/v4l2-dv-timings.h>\n\n#define REG_STATUS\t\t\t0x04\n#define REG_FORCE_FMT\t\t\t0x06\n#define REG_LINES_PER_FRAME\t\t0x12\n#define REG_WORDS_PER_LINE\t\t0x13\n#define REG_WORDS_PER_ACT_LINE\t\t0x14\n#define REG_ACT_LINES_PER_FRAME\t0x15\n\n#define MASK_H_LOCK\t\t\t0x001\n#define MASK_V_LOCK\t\t\t0x002\n#define MASK_STD_LOCK\t\t\t0x004\n#define MASK_FORCE_STD\t\t\t0x020\n#define MASK_STD_STATUS\t\t0x3E0\n\n#define GS_WIDTH_MIN\t\t\t720\n#define GS_WIDTH_MAX\t\t\t2048\n#define GS_HEIGHT_MIN\t\t\t487\n#define GS_HEIGHT_MAX\t\t\t1080\n#define GS_PIXELCLOCK_MIN\t\t10519200\n#define GS_PIXELCLOCK_MAX\t\t74250000\n\nstruct gs {\n\tstruct spi_device *pdev;\n\tstruct v4l2_subdev sd;\n\tstruct v4l2_dv_timings current_timings;\n\tint enabled;\n};\n\nstruct gs_reg_fmt {\n\tu16 reg_value;\n\tstruct v4l2_dv_timings format;\n};\n\nstruct gs_reg_fmt_custom {\n\tu16 reg_value;\n\t__u32 width;\n\t__u32 height;\n\t__u64 pixelclock;\n\t__u32 interlaced;\n};\n\nstatic const struct spi_device_id gs_id[] = {\n\t{ \"gs1662\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, gs_id);\n\nstatic const struct v4l2_dv_timings fmt_cap[] = {\n\tV4L2_DV_BT_SDI_720X487I60,\n\tV4L2_DV_BT_CEA_720X576P50,\n\tV4L2_DV_BT_CEA_1280X720P24,\n\tV4L2_DV_BT_CEA_1280X720P25,\n\tV4L2_DV_BT_CEA_1280X720P30,\n\tV4L2_DV_BT_CEA_1280X720P50,\n\tV4L2_DV_BT_CEA_1280X720P60,\n\tV4L2_DV_BT_CEA_1920X1080P24,\n\tV4L2_DV_BT_CEA_1920X1080P25,\n\tV4L2_DV_BT_CEA_1920X1080P30,\n\tV4L2_DV_BT_CEA_1920X1080I50,\n\tV4L2_DV_BT_CEA_1920X1080I60,\n};\n\nstatic const struct gs_reg_fmt reg_fmt[] = {\n\t{ 0x00, V4L2_DV_BT_CEA_1280X720P60 },\n\t{ 0x01, V4L2_DV_BT_CEA_1280X720P60 },\n\t{ 0x02, V4L2_DV_BT_CEA_1280X720P30 },\n\t{ 0x03, V4L2_DV_BT_CEA_1280X720P30 },\n\t{ 0x04, V4L2_DV_BT_CEA_1280X720P50 },\n\t{ 0x05, V4L2_DV_BT_CEA_1280X720P50 },\n\t{ 0x06, V4L2_DV_BT_CEA_1280X720P25 },\n\t{ 0x07, V4L2_DV_BT_CEA_1280X720P25 },\n\t{ 0x08, V4L2_DV_BT_CEA_1280X720P24 },\n\t{ 0x09, V4L2_DV_BT_CEA_1280X720P24 },\n\t{ 0x0A, V4L2_DV_BT_CEA_1920X1080I60 },\n\t{ 0x0B, V4L2_DV_BT_CEA_1920X1080P30 },\n\n\t \n\t{ 0x14, V4L2_DV_BT_CEA_1920X1080I50 },\n\t{ 0x0C, V4L2_DV_BT_CEA_1920X1080I50 },\n\t{ 0x0D, V4L2_DV_BT_CEA_1920X1080P25 },\n\t{ 0x0E, V4L2_DV_BT_CEA_1920X1080P25 },\n\t{ 0x10, V4L2_DV_BT_CEA_1920X1080P24 },\n\t{ 0x12, V4L2_DV_BT_CEA_1920X1080P24 },\n\t{ 0x16, V4L2_DV_BT_SDI_720X487I60 },\n\t{ 0x19, V4L2_DV_BT_SDI_720X487I60 },\n\t{ 0x18, V4L2_DV_BT_CEA_720X576P50 },\n\t{ 0x1A, V4L2_DV_BT_CEA_720X576P50 },\n\n\t \n#if 0\n\t{ 0x0F, V4L2_DV_BT_XXX_1920X1080I25 },  \n\t{ 0x11, V4L2_DV_BT_XXX_1920X1080I24 },  \n\t{ 0x13, V4L2_DV_BT_XXX_1920X1080I25 },  \n\t{ 0x15, V4L2_DV_BT_XXX_1920X1035I60 },  \n\t{ 0x17, V4L2_DV_BT_SDI_720X507I60 },  \n\t{ 0x1B, V4L2_DV_BT_SDI_720X507I60 },  \n\t{ 0x1C, V4L2_DV_BT_XXX_2048X1080P25 },  \n#endif\n};\n\nstatic const struct v4l2_dv_timings_cap gs_timings_cap = {\n\t.type = V4L2_DV_BT_656_1120,\n\t \n\t.reserved = { 0 },\n\tV4L2_INIT_BT_TIMINGS(GS_WIDTH_MIN, GS_WIDTH_MAX, GS_HEIGHT_MIN,\n\t\t\t     GS_HEIGHT_MAX, GS_PIXELCLOCK_MIN,\n\t\t\t     GS_PIXELCLOCK_MAX,\n\t\t\t     V4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_SDI,\n\t\t\t     V4L2_DV_BT_CAP_PROGRESSIVE\n\t\t\t     | V4L2_DV_BT_CAP_INTERLACED)\n};\n\nstatic int gs_read_register(struct spi_device *spi, u16 addr, u16 *value)\n{\n\tint ret;\n\tu16 buf_addr = (0x8000 | (0x0FFF & addr));\n\tu16 buf_value = 0;\n\tstruct spi_message msg;\n\tstruct spi_transfer tx[] = {\n\t\t{\n\t\t\t.tx_buf = &buf_addr,\n\t\t\t.len = 2,\n\t\t\t.delay = {\n\t\t\t\t.value = 1,\n\t\t\t\t.unit = SPI_DELAY_UNIT_USECS\n\t\t\t},\n\t\t}, {\n\t\t\t.rx_buf = &buf_value,\n\t\t\t.len = 2,\n\t\t\t.delay = {\n\t\t\t\t.value = 1,\n\t\t\t\t.unit = SPI_DELAY_UNIT_USECS\n\t\t\t},\n\t\t},\n\t};\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&tx[0], &msg);\n\tspi_message_add_tail(&tx[1], &msg);\n\tret = spi_sync(spi, &msg);\n\n\t*value = buf_value;\n\n\treturn ret;\n}\n\nstatic int gs_write_register(struct spi_device *spi, u16 addr, u16 value)\n{\n\tint ret;\n\tu16 buf_addr = addr;\n\tu16 buf_value = value;\n\tstruct spi_message msg;\n\tstruct spi_transfer tx[] = {\n\t\t{\n\t\t\t.tx_buf = &buf_addr,\n\t\t\t.len = 2,\n\t\t\t.delay = {\n\t\t\t\t.value = 1,\n\t\t\t\t.unit = SPI_DELAY_UNIT_USECS\n\t\t\t},\n\t\t}, {\n\t\t\t.tx_buf = &buf_value,\n\t\t\t.len = 2,\n\t\t\t.delay = {\n\t\t\t\t.value = 1,\n\t\t\t\t.unit = SPI_DELAY_UNIT_USECS\n\t\t\t},\n\t\t},\n\t};\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&tx[0], &msg);\n\tspi_message_add_tail(&tx[1], &msg);\n\tret = spi_sync(spi, &msg);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int gs_g_register(struct v4l2_subdev *sd,\n\t\t  struct v4l2_dbg_register *reg)\n{\n\tstruct spi_device *spi = v4l2_get_subdevdata(sd);\n\tu16 val;\n\tint ret;\n\n\tret = gs_read_register(spi, reg->reg & 0xFFFF, &val);\n\treg->val = val;\n\treg->size = 2;\n\treturn ret;\n}\n\nstatic int gs_s_register(struct v4l2_subdev *sd,\n\t\t  const struct v4l2_dbg_register *reg)\n{\n\tstruct spi_device *spi = v4l2_get_subdevdata(sd);\n\n\treturn gs_write_register(spi, reg->reg & 0xFFFF, reg->val & 0xFFFF);\n}\n#endif\n\nstatic int gs_status_format(u16 status, struct v4l2_dv_timings *timings)\n{\n\tint std = (status & MASK_STD_STATUS) >> 5;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reg_fmt); i++) {\n\t\tif (reg_fmt[i].reg_value == std) {\n\t\t\t*timings = reg_fmt[i].format;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ERANGE;\n}\n\nstatic u16 get_register_timings(struct v4l2_dv_timings *timings)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reg_fmt); i++) {\n\t\tif (v4l2_match_dv_timings(timings, &reg_fmt[i].format, 0,\n\t\t\t\t\t  false))\n\t\t\treturn reg_fmt[i].reg_value | MASK_FORCE_STD;\n\t}\n\n\treturn 0x0;\n}\n\nstatic inline struct gs *to_gs(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct gs, sd);\n}\n\nstatic int gs_s_dv_timings(struct v4l2_subdev *sd,\n\t\t    struct v4l2_dv_timings *timings)\n{\n\tstruct gs *gs = to_gs(sd);\n\tint reg_value;\n\n\treg_value = get_register_timings(timings);\n\tif (reg_value == 0x0)\n\t\treturn -EINVAL;\n\n\tgs->current_timings = *timings;\n\treturn 0;\n}\n\nstatic int gs_g_dv_timings(struct v4l2_subdev *sd,\n\t\t    struct v4l2_dv_timings *timings)\n{\n\tstruct gs *gs = to_gs(sd);\n\n\t*timings = gs->current_timings;\n\treturn 0;\n}\n\nstatic int gs_query_dv_timings(struct v4l2_subdev *sd,\n\t\t\tstruct v4l2_dv_timings *timings)\n{\n\tstruct gs *gs = to_gs(sd);\n\tstruct v4l2_dv_timings fmt;\n\tu16 reg_value, i;\n\tint ret;\n\n\tif (gs->enabled)\n\t\treturn -EBUSY;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tgs_read_register(gs->pdev, REG_LINES_PER_FRAME + i, &reg_value);\n\t\tif (reg_value)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (i >= 4)\n\t\treturn -ENOLINK;\n\n\tgs_read_register(gs->pdev, REG_STATUS, &reg_value);\n\tif (!(reg_value & MASK_H_LOCK) || !(reg_value & MASK_V_LOCK))\n\t\treturn -ENOLCK;\n\tif (!(reg_value & MASK_STD_LOCK))\n\t\treturn -ERANGE;\n\n\tret = gs_status_format(reg_value, &fmt);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*timings = fmt;\n\treturn 0;\n}\n\nstatic int gs_enum_dv_timings(struct v4l2_subdev *sd,\n\t\t       struct v4l2_enum_dv_timings *timings)\n{\n\tif (timings->index >= ARRAY_SIZE(fmt_cap))\n\t\treturn -EINVAL;\n\n\tif (timings->pad != 0)\n\t\treturn -EINVAL;\n\n\ttimings->timings = fmt_cap[timings->index];\n\treturn 0;\n}\n\nstatic int gs_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct gs *gs = to_gs(sd);\n\tint reg_value;\n\n\tif (gs->enabled == enable)\n\t\treturn 0;\n\n\tgs->enabled = enable;\n\n\tif (enable) {\n\t\t \n\t\treg_value = get_register_timings(&gs->current_timings);\n\t\treturn gs_write_register(gs->pdev, REG_FORCE_FMT, reg_value);\n\t}\n\n\t \n\treturn gs_write_register(gs->pdev, REG_FORCE_FMT, 0x0);\n}\n\nstatic int gs_g_input_status(struct v4l2_subdev *sd, u32 *status)\n{\n\tstruct gs *gs = to_gs(sd);\n\tu16 reg_value, i;\n\tint ret;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tret = gs_read_register(gs->pdev,\n\t\t\t\t       REG_LINES_PER_FRAME + i, &reg_value);\n\t\tif (reg_value)\n\t\t\tbreak;\n\t\tif (ret) {\n\t\t\t*status = V4L2_IN_ST_NO_POWER;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (i >= 4)\n\t\t*status |= V4L2_IN_ST_NO_SIGNAL;\n\n\tret = gs_read_register(gs->pdev, REG_STATUS, &reg_value);\n\tif (!(reg_value & MASK_H_LOCK))\n\t\t*status |=  V4L2_IN_ST_NO_H_LOCK;\n\tif (!(reg_value & MASK_V_LOCK))\n\t\t*status |=  V4L2_IN_ST_NO_V_LOCK;\n\tif (!(reg_value & MASK_STD_LOCK))\n\t\t*status |=  V4L2_IN_ST_NO_STD_LOCK;\n\n\treturn ret;\n}\n\nstatic int gs_dv_timings_cap(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_dv_timings_cap *cap)\n{\n\tif (cap->pad != 0)\n\t\treturn -EINVAL;\n\n\t*cap = gs_timings_cap;\n\treturn 0;\n}\n\n \nstatic const struct v4l2_subdev_core_ops gs_core_ops = {\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = gs_g_register,\n\t.s_register = gs_s_register,\n#endif\n};\n\nstatic const struct v4l2_subdev_video_ops gs_video_ops = {\n\t.s_dv_timings = gs_s_dv_timings,\n\t.g_dv_timings = gs_g_dv_timings,\n\t.s_stream = gs_s_stream,\n\t.g_input_status = gs_g_input_status,\n\t.query_dv_timings = gs_query_dv_timings,\n};\n\nstatic const struct v4l2_subdev_pad_ops gs_pad_ops = {\n\t.enum_dv_timings = gs_enum_dv_timings,\n\t.dv_timings_cap = gs_dv_timings_cap,\n};\n\n \nstatic const struct v4l2_subdev_ops gs_ops = {\n\t.core = &gs_core_ops,\n\t.video = &gs_video_ops,\n\t.pad = &gs_pad_ops,\n};\n\nstatic int gs_probe(struct spi_device *spi)\n{\n\tint ret;\n\tstruct gs *gs;\n\tstruct v4l2_subdev *sd;\n\n\tgs = devm_kzalloc(&spi->dev, sizeof(struct gs), GFP_KERNEL);\n\tif (!gs)\n\t\treturn -ENOMEM;\n\n\tgs->pdev = spi;\n\tsd = &gs->sd;\n\n\tspi->mode = SPI_MODE_0;\n\tspi->irq = -1;\n\tspi->max_speed_hz = 10000000;\n\tspi->bits_per_word = 16;\n\tret = spi_setup(spi);\n\tv4l2_spi_subdev_init(sd, spi, &gs_ops);\n\n\tgs->current_timings = reg_fmt[0].format;\n\tgs->enabled = 0;\n\n\t \n\tgs_write_register(spi, 0x0, 0x300);\n\n\treturn ret;\n}\n\nstatic void gs_remove(struct spi_device *spi)\n{\n\tstruct v4l2_subdev *sd = spi_get_drvdata(spi);\n\n\tv4l2_device_unregister_subdev(sd);\n}\n\nstatic struct spi_driver gs_driver = {\n\t.driver = {\n\t\t.name\t\t= \"gs1662\",\n\t},\n\n\t.probe\t\t= gs_probe,\n\t.remove\t\t= gs_remove,\n\t.id_table\t= gs_id,\n};\n\nmodule_spi_driver(gs_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Charles-Antoine Couret <charles-antoine.couret@nexvision.fr>\");\nMODULE_DESCRIPTION(\"Gennum GS1662 HD/SD-SDI Serializer driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}