{
  "module_name": "v4l2-jpeg.c",
  "hash_id": "76153ffc68367d1673f8f9714f6eda0d1b54594c037ca70e4811e22dc3dcf556",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/v4l2-jpeg.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <media/v4l2-jpeg.h>\n\nMODULE_DESCRIPTION(\"V4L2 JPEG header parser helpers\");\nMODULE_AUTHOR(\"Philipp Zabel <kernel@pengutronix.de>\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define SOF0\t0xffc0\t \n#define SOF1\t0xffc1\n#define SOF2\t0xffc2\n#define SOF3\t0xffc3\n#define SOF5\t0xffc5\n#define SOF7\t0xffc7\n#define JPG\t0xffc8\t \n#define SOF9\t0xffc9\n#define SOF11\t0xffcb\n#define SOF13\t0xffcd\n#define SOF15\t0xffcf\n#define DHT\t0xffc4\t \n#define DAC\t0xffcc\t \n#define RST0\t0xffd0\t \n#define RST7\t0xffd7\n#define SOI\t0xffd8\t \n#define EOI\t0xffd9\t \n#define SOS\t0xffda\t \n#define DQT\t0xffdb\t \n#define DNL\t0xffdc\t \n#define DRI\t0xffdd\t \n#define DHP\t0xffde\t \n#define EXP\t0xffdf\t \n#define APP0\t0xffe0\t \n#define APP14\t0xffee\t \n#define APP15\t0xffef\n#define JPG0\t0xfff0\t \n#define JPG13\t0xfffd\n#define COM\t0xfffe\t \n#define TEM\t0xff01\t \n\n \nstruct jpeg_stream {\n\tu8 *curr;\n\tu8 *end;\n};\n\n \nstatic int jpeg_get_byte(struct jpeg_stream *stream)\n{\n\tif (stream->curr >= stream->end)\n\t\treturn -EINVAL;\n\n\treturn *stream->curr++;\n}\n\n \nstatic int jpeg_get_word_be(struct jpeg_stream *stream)\n{\n\tu16 word;\n\n\tif (stream->curr + sizeof(__be16) > stream->end)\n\t\treturn -EINVAL;\n\n\tword = get_unaligned_be16(stream->curr);\n\tstream->curr += sizeof(__be16);\n\n\treturn word;\n}\n\nstatic int jpeg_skip(struct jpeg_stream *stream, size_t len)\n{\n\tif (stream->curr + len > stream->end)\n\t\treturn -EINVAL;\n\n\tstream->curr += len;\n\n\treturn 0;\n}\n\nstatic int jpeg_next_marker(struct jpeg_stream *stream)\n{\n\tint byte;\n\tu16 marker = 0;\n\n\twhile ((byte = jpeg_get_byte(stream)) >= 0) {\n\t\tmarker = (marker << 8) | byte;\n\t\t \n\t\tif (marker == TEM || (marker > 0xffbf && marker < 0xffff))\n\t\t\treturn marker;\n\t}\n\n\treturn byte;\n}\n\n \nstatic int jpeg_reference_segment(struct jpeg_stream *stream,\n\t\t\t\t  struct v4l2_jpeg_reference *segment)\n{\n\tu16 len;\n\n\tif (stream->curr + sizeof(__be16) > stream->end)\n\t\treturn -EINVAL;\n\n\tlen = get_unaligned_be16(stream->curr);\n\tif (stream->curr + len > stream->end)\n\t\treturn -EINVAL;\n\n\tsegment->start = stream->curr;\n\tsegment->length = len;\n\n\treturn 0;\n}\n\nstatic int v4l2_jpeg_decode_subsampling(u8 nf, u8 h_v)\n{\n\tif (nf == 1)\n\t\treturn V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY;\n\n\t \n\tif (nf == 4 && h_v != 0x11)\n\t\treturn -EINVAL;\n\n\tswitch (h_v) {\n\tcase 0x11:\n\t\treturn V4L2_JPEG_CHROMA_SUBSAMPLING_444;\n\tcase 0x21:\n\t\treturn V4L2_JPEG_CHROMA_SUBSAMPLING_422;\n\tcase 0x22:\n\t\treturn V4L2_JPEG_CHROMA_SUBSAMPLING_420;\n\tcase 0x41:\n\t\treturn V4L2_JPEG_CHROMA_SUBSAMPLING_411;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int jpeg_parse_frame_header(struct jpeg_stream *stream, u16 sof_marker,\n\t\t\t\t   struct v4l2_jpeg_frame_header *frame_header)\n{\n\tint len = jpeg_get_word_be(stream);\n\n\tif (len < 0)\n\t\treturn len;\n\t \n\tif (len < 8 + 3)\n\t\treturn -EINVAL;\n\n\tif (frame_header) {\n\t\t \n\t\tint p, y, x, nf;\n\t\tint i;\n\n\t\tp = jpeg_get_byte(stream);\n\t\tif (p < 0)\n\t\t\treturn p;\n\t\t \n\t\tif (p != 8 && (p != 12 || sof_marker != SOF1))\n\t\t\treturn -EINVAL;\n\n\t\ty = jpeg_get_word_be(stream);\n\t\tif (y < 0)\n\t\t\treturn y;\n\t\tif (y == 0)\n\t\t\treturn -EINVAL;\n\n\t\tx = jpeg_get_word_be(stream);\n\t\tif (x < 0)\n\t\t\treturn x;\n\t\tif (x == 0)\n\t\t\treturn -EINVAL;\n\n\t\tnf = jpeg_get_byte(stream);\n\t\tif (nf < 0)\n\t\t\treturn nf;\n\t\t \n\t\tif (nf < 1 || nf > V4L2_JPEG_MAX_COMPONENTS)\n\t\t\treturn -EINVAL;\n\t\tif (len != 8 + 3 * nf)\n\t\t\treturn -EINVAL;\n\n\t\tframe_header->precision = p;\n\t\tframe_header->height = y;\n\t\tframe_header->width = x;\n\t\tframe_header->num_components = nf;\n\n\t\tfor (i = 0; i < nf; i++) {\n\t\t\tstruct v4l2_jpeg_frame_component_spec *component;\n\t\t\tint c, h_v, tq;\n\n\t\t\tc = jpeg_get_byte(stream);\n\t\t\tif (c < 0)\n\t\t\t\treturn c;\n\n\t\t\th_v = jpeg_get_byte(stream);\n\t\t\tif (h_v < 0)\n\t\t\t\treturn h_v;\n\t\t\tif (i == 0) {\n\t\t\t\tint subs;\n\n\t\t\t\tsubs = v4l2_jpeg_decode_subsampling(nf, h_v);\n\t\t\t\tif (subs < 0)\n\t\t\t\t\treturn subs;\n\t\t\t\tframe_header->subsampling = subs;\n\t\t\t} else if (h_v != 0x11) {\n\t\t\t\t \n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\ttq = jpeg_get_byte(stream);\n\t\t\tif (tq < 0)\n\t\t\t\treturn tq;\n\n\t\t\tcomponent = &frame_header->component[i];\n\t\t\tcomponent->component_identifier = c;\n\t\t\tcomponent->horizontal_sampling_factor =\n\t\t\t\t(h_v >> 4) & 0xf;\n\t\t\tcomponent->vertical_sampling_factor = h_v & 0xf;\n\t\t\tcomponent->quantization_table_selector = tq;\n\t\t}\n\t} else {\n\t\treturn jpeg_skip(stream, len - 2);\n\t}\n\n\treturn 0;\n}\n\nstatic int jpeg_parse_scan_header(struct jpeg_stream *stream,\n\t\t\t\t  struct v4l2_jpeg_scan_header *scan_header)\n{\n\tsize_t skip;\n\tint len = jpeg_get_word_be(stream);\n\n\tif (len < 0)\n\t\treturn len;\n\t \n\tif (len < 6 + 2)\n\t\treturn -EINVAL;\n\n\tif (scan_header) {\n\t\tint ns;\n\t\tint i;\n\n\t\tns = jpeg_get_byte(stream);\n\t\tif (ns < 0)\n\t\t\treturn ns;\n\t\tif (ns < 1 || ns > 4 || len != 6 + 2 * ns)\n\t\t\treturn -EINVAL;\n\n\t\tscan_header->num_components = ns;\n\n\t\tfor (i = 0; i < ns; i++) {\n\t\t\tstruct v4l2_jpeg_scan_component_spec *component;\n\t\t\tint cs, td_ta;\n\n\t\t\tcs = jpeg_get_byte(stream);\n\t\t\tif (cs < 0)\n\t\t\t\treturn cs;\n\n\t\t\ttd_ta = jpeg_get_byte(stream);\n\t\t\tif (td_ta < 0)\n\t\t\t\treturn td_ta;\n\n\t\t\tcomponent = &scan_header->component[i];\n\t\t\tcomponent->component_selector = cs;\n\t\t\tcomponent->dc_entropy_coding_table_selector =\n\t\t\t\t(td_ta >> 4) & 0xf;\n\t\t\tcomponent->ac_entropy_coding_table_selector =\n\t\t\t\ttd_ta & 0xf;\n\t\t}\n\n\t\tskip = 3;  \n\t} else {\n\t\tskip = len - 2;\n\t}\n\n\treturn jpeg_skip(stream, skip);\n}\n\n \nstatic int jpeg_parse_quantization_tables(struct jpeg_stream *stream,\n\t\t\t\t\t  u8 precision,\n\t\t\t\t\t  struct v4l2_jpeg_reference *tables)\n{\n\tint len = jpeg_get_word_be(stream);\n\n\tif (len < 0)\n\t\treturn len;\n\t \n\tif (len < 2 + 65)\n\t\treturn -EINVAL;\n\n\tlen -= 2;\n\twhile (len >= 65) {\n\t\tu8 pq, tq, *qk;\n\t\tint ret;\n\t\tint pq_tq = jpeg_get_byte(stream);\n\n\t\tif (pq_tq < 0)\n\t\t\treturn pq_tq;\n\n\t\t \n\t\tpq = (pq_tq >> 4) & 0xf;\n\t\t \n\t\tif (pq != 0 && (pq != 1 || precision != 12))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\ttq = pq_tq & 0xf;\n\t\tif (tq > 3)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tqk = stream->curr;\n\t\tret = jpeg_skip(stream, pq ? 128 : 64);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (tables) {\n\t\t\ttables[tq].start = qk;\n\t\t\ttables[tq].length = pq ? 128 : 64;\n\t\t}\n\n\t\tlen -= pq ? 129 : 65;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int jpeg_parse_huffman_tables(struct jpeg_stream *stream,\n\t\t\t\t     struct v4l2_jpeg_reference *tables)\n{\n\tint mt;\n\tint len = jpeg_get_word_be(stream);\n\n\tif (len < 0)\n\t\treturn len;\n\t \n\tif (len < 2 + 17)\n\t\treturn -EINVAL;\n\n\tfor (len -= 2; len >= 17; len -= 17 + mt) {\n\t\tu8 tc, th, *table;\n\t\tint tc_th = jpeg_get_byte(stream);\n\t\tint i, ret;\n\n\t\tif (tc_th < 0)\n\t\t\treturn tc_th;\n\n\t\t \n\t\ttc = (tc_th >> 4) & 0xf;\n\t\tif (tc > 1)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tth = tc_th & 0xf;\n\t\t \n\t\tif (th > 1)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\ttable = stream->curr;\n\t\tmt = 0;\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tint li;\n\n\t\t\tli = jpeg_get_byte(stream);\n\t\t\tif (li < 0)\n\t\t\t\treturn li;\n\n\t\t\tmt += li;\n\t\t}\n\t\t \n\t\tret = jpeg_skip(stream, mt);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (tables) {\n\t\t\ttables[(tc << 1) | th].start = table;\n\t\t\ttables[(tc << 1) | th].length = stream->curr - table;\n\t\t}\n\t}\n\n\treturn jpeg_skip(stream, len - 2);\n}\n\n \nstatic int jpeg_parse_restart_interval(struct jpeg_stream *stream,\n\t\t\t\t       u16 *restart_interval)\n{\n\tint len = jpeg_get_word_be(stream);\n\tint ri;\n\n\tif (len < 0)\n\t\treturn len;\n\tif (len != 4)\n\t\treturn -EINVAL;\n\n\tri = jpeg_get_word_be(stream);\n\tif (ri < 0)\n\t\treturn ri;\n\n\t*restart_interval = ri;\n\n\treturn 0;\n}\n\nstatic int jpeg_skip_segment(struct jpeg_stream *stream)\n{\n\tint len = jpeg_get_word_be(stream);\n\n\tif (len < 0)\n\t\treturn len;\n\tif (len < 2)\n\t\treturn -EINVAL;\n\n\treturn jpeg_skip(stream, len - 2);\n}\n\n \nstatic int jpeg_parse_app14_data(struct jpeg_stream *stream,\n\t\t\t\t enum v4l2_jpeg_app14_tf *tf)\n{\n\tint ret;\n\tint lp;\n\tint skip;\n\n\tlp = jpeg_get_word_be(stream);\n\tif (lp < 0)\n\t\treturn lp;\n\n\t \n\tif (stream->curr + 6 > stream->end ||\n\t    strncmp(stream->curr, \"Adobe\\0\", 6))\n\t\treturn jpeg_skip(stream, lp - 2);\n\n\t \n\tret = jpeg_skip(stream, 11);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = jpeg_get_byte(stream);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*tf = ret;\n\n\t \n\tskip = lp - 2 - 11 - 1;\n\treturn jpeg_skip(stream, skip);\n}\n\n \nint v4l2_jpeg_parse_header(void *buf, size_t len, struct v4l2_jpeg_header *out)\n{\n\tstruct jpeg_stream stream;\n\tint marker;\n\tint ret = 0;\n\n\tstream.curr = buf;\n\tstream.end = stream.curr + len;\n\n\tout->num_dht = 0;\n\tout->num_dqt = 0;\n\n\t \n\tif (jpeg_get_word_be(&stream) != SOI)\n\t\treturn -EINVAL;\n\n\t \n\tout->app14_tf = V4L2_JPEG_APP14_TF_UNKNOWN;\n\n\t \n\twhile ((marker = jpeg_next_marker(&stream)) >= 0) {\n\t\tswitch (marker) {\n\t\t \n\t\tcase SOF0 ... SOF1:\n\t\t\tret = jpeg_reference_segment(&stream, &out->sof);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tret = jpeg_parse_frame_header(&stream, marker,\n\t\t\t\t\t\t      &out->frame);\n\t\t\tbreak;\n\t\t \n\t\tcase SOF2 ... SOF3:\n\t\t \n\t\tcase SOF5 ... SOF7:\n\t\t \n\t\tcase SOF9 ... SOF11:\n\t\tcase SOF13 ... SOF15:\n\t\tcase DAC:\n\t\tcase TEM:\n\t\t\treturn -EINVAL;\n\n\t\tcase DHT:\n\t\t\tret = jpeg_reference_segment(&stream,\n\t\t\t\t\t&out->dht[out->num_dht++ % 4]);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!out->huffman_tables) {\n\t\t\t\tret = jpeg_skip_segment(&stream);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = jpeg_parse_huffman_tables(&stream,\n\t\t\t\t\t\t\tout->huffman_tables);\n\t\t\tbreak;\n\t\tcase DQT:\n\t\t\tret = jpeg_reference_segment(&stream,\n\t\t\t\t\t&out->dqt[out->num_dqt++ % 4]);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!out->quantization_tables) {\n\t\t\t\tret = jpeg_skip_segment(&stream);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = jpeg_parse_quantization_tables(&stream,\n\t\t\t\t\tout->frame.precision,\n\t\t\t\t\tout->quantization_tables);\n\t\t\tbreak;\n\t\tcase DRI:\n\t\t\tret = jpeg_parse_restart_interval(&stream,\n\t\t\t\t\t\t\t&out->restart_interval);\n\t\t\tbreak;\n\t\tcase APP14:\n\t\t\tret = jpeg_parse_app14_data(&stream,\n\t\t\t\t\t\t    &out->app14_tf);\n\t\t\tbreak;\n\t\tcase SOS:\n\t\t\tret = jpeg_reference_segment(&stream, &out->sos);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tret = jpeg_parse_scan_header(&stream, out->scan);\n\t\t\t \n\t\t\tout->ecs_offset = stream.curr - (u8 *)buf;\n\t\t\treturn ret;\n\n\t\t \n\t\tcase RST0 ... RST7:  \n\t\tcase SOI:  \n\t\tcase EOI:  \n\t\t\tbreak;\n\n\t\t \n\t\tdefault:\n\t\t\tret = jpeg_skip_segment(&stream);\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn marker;\n}\nEXPORT_SYMBOL_GPL(v4l2_jpeg_parse_header);\n\n \nint v4l2_jpeg_parse_frame_header(void *buf, size_t len,\n\t\t\t\t struct v4l2_jpeg_frame_header *frame_header)\n{\n\tstruct jpeg_stream stream;\n\n\tstream.curr = buf;\n\tstream.end = stream.curr + len;\n\treturn jpeg_parse_frame_header(&stream, SOF0, frame_header);\n}\nEXPORT_SYMBOL_GPL(v4l2_jpeg_parse_frame_header);\n\n \nint v4l2_jpeg_parse_scan_header(void *buf, size_t len,\n\t\t\t\tstruct v4l2_jpeg_scan_header *scan_header)\n{\n\tstruct jpeg_stream stream;\n\n\tstream.curr = buf;\n\tstream.end = stream.curr + len;\n\treturn jpeg_parse_scan_header(&stream, scan_header);\n}\nEXPORT_SYMBOL_GPL(v4l2_jpeg_parse_scan_header);\n\n \nint v4l2_jpeg_parse_quantization_tables(void *buf, size_t len, u8 precision,\n\t\t\t\t\tstruct v4l2_jpeg_reference *q_tables)\n{\n\tstruct jpeg_stream stream;\n\n\tstream.curr = buf;\n\tstream.end = stream.curr + len;\n\treturn jpeg_parse_quantization_tables(&stream, precision, q_tables);\n}\nEXPORT_SYMBOL_GPL(v4l2_jpeg_parse_quantization_tables);\n\n \nint v4l2_jpeg_parse_huffman_tables(void *buf, size_t len,\n\t\t\t\t   struct v4l2_jpeg_reference *huffman_tables)\n{\n\tstruct jpeg_stream stream;\n\n\tstream.curr = buf;\n\tstream.end = stream.curr + len;\n\treturn jpeg_parse_huffman_tables(&stream, huffman_tables);\n}\nEXPORT_SYMBOL_GPL(v4l2_jpeg_parse_huffman_tables);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}