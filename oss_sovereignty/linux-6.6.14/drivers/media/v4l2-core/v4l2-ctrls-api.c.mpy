{
  "module_name": "v4l2-ctrls-api.c",
  "hash_id": "3564e809e2c08d1fbfed876aca959c65b63331308a90d62786c80faa2f1c14ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/v4l2-ctrls-api.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"v4l2-ctrls: \" fmt\n\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n\n#include \"v4l2-ctrls-priv.h\"\n\n \nstruct v4l2_ctrl_helper {\n\t \n\tstruct v4l2_ctrl_ref *mref;\n\t \n\tstruct v4l2_ctrl_ref *ref;\n\t \n\tu32 next;\n};\n\n \n\n \nstatic int ptr_to_user(struct v4l2_ext_control *c,\n\t\t       struct v4l2_ctrl *ctrl,\n\t\t       union v4l2_ctrl_ptr ptr)\n{\n\tu32 len;\n\n\tif (ctrl->is_ptr && !ctrl->is_string)\n\t\treturn copy_to_user(c->ptr, ptr.p_const, c->size) ?\n\t\t       -EFAULT : 0;\n\n\tswitch (ctrl->type) {\n\tcase V4L2_CTRL_TYPE_STRING:\n\t\tlen = strlen(ptr.p_char);\n\t\tif (c->size < len + 1) {\n\t\t\tc->size = ctrl->elem_size;\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\treturn copy_to_user(c->string, ptr.p_char, len + 1) ?\n\t\t       -EFAULT : 0;\n\tcase V4L2_CTRL_TYPE_INTEGER64:\n\t\tc->value64 = *ptr.p_s64;\n\t\tbreak;\n\tdefault:\n\t\tc->value = *ptr.p_s32;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int cur_to_user(struct v4l2_ext_control *c, struct v4l2_ctrl *ctrl)\n{\n\treturn ptr_to_user(c, ctrl, ctrl->p_cur);\n}\n\n \nstatic int new_to_user(struct v4l2_ext_control *c,\n\t\t       struct v4l2_ctrl *ctrl)\n{\n\treturn ptr_to_user(c, ctrl, ctrl->p_new);\n}\n\n \nstatic int req_to_user(struct v4l2_ext_control *c,\n\t\t       struct v4l2_ctrl_ref *ref)\n{\n\treturn ptr_to_user(c, ref->ctrl, ref->p_req);\n}\n\n \nstatic int def_to_user(struct v4l2_ext_control *c, struct v4l2_ctrl *ctrl)\n{\n\tctrl->type_ops->init(ctrl, 0, ctrl->p_new);\n\n\treturn ptr_to_user(c, ctrl, ctrl->p_new);\n}\n\n \nstatic int user_to_new(struct v4l2_ext_control *c, struct v4l2_ctrl *ctrl)\n{\n\tint ret;\n\tu32 size;\n\n\tctrl->is_new = 0;\n\tif (ctrl->is_dyn_array &&\n\t    c->size > ctrl->p_array_alloc_elems * ctrl->elem_size) {\n\t\tvoid *old = ctrl->p_array;\n\t\tvoid *tmp = kvzalloc(2 * c->size, GFP_KERNEL);\n\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(tmp, ctrl->p_new.p, ctrl->elems * ctrl->elem_size);\n\t\tmemcpy(tmp + c->size, ctrl->p_cur.p, ctrl->elems * ctrl->elem_size);\n\t\tctrl->p_new.p = tmp;\n\t\tctrl->p_cur.p = tmp + c->size;\n\t\tctrl->p_array = tmp;\n\t\tctrl->p_array_alloc_elems = c->size / ctrl->elem_size;\n\t\tkvfree(old);\n\t}\n\n\tif (ctrl->is_ptr && !ctrl->is_string) {\n\t\tunsigned int elems = c->size / ctrl->elem_size;\n\n\t\tif (copy_from_user(ctrl->p_new.p, c->ptr, c->size))\n\t\t\treturn -EFAULT;\n\t\tctrl->is_new = 1;\n\t\tif (ctrl->is_dyn_array)\n\t\t\tctrl->new_elems = elems;\n\t\telse if (ctrl->is_array)\n\t\t\tctrl->type_ops->init(ctrl, elems, ctrl->p_new);\n\t\treturn 0;\n\t}\n\n\tswitch (ctrl->type) {\n\tcase V4L2_CTRL_TYPE_INTEGER64:\n\t\t*ctrl->p_new.p_s64 = c->value64;\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_STRING:\n\t\tsize = c->size;\n\t\tif (size == 0)\n\t\t\treturn -ERANGE;\n\t\tif (size > ctrl->maximum + 1)\n\t\t\tsize = ctrl->maximum + 1;\n\t\tret = copy_from_user(ctrl->p_new.p_char, c->string, size) ? -EFAULT : 0;\n\t\tif (!ret) {\n\t\t\tchar last = ctrl->p_new.p_char[size - 1];\n\n\t\t\tctrl->p_new.p_char[size - 1] = 0;\n\t\t\t \n\t\t\tif (strlen(ctrl->p_new.p_char) == ctrl->maximum && last)\n\t\t\t\treturn -ERANGE;\n\t\t\tctrl->is_new = 1;\n\t\t}\n\t\treturn ret;\n\tdefault:\n\t\t*ctrl->p_new.p_s32 = c->value;\n\t\tbreak;\n\t}\n\tctrl->is_new = 1;\n\treturn 0;\n}\n\n \n\n \n\n \nstatic int prepare_ext_ctrls(struct v4l2_ctrl_handler *hdl,\n\t\t\t     struct v4l2_ext_controls *cs,\n\t\t\t     struct v4l2_ctrl_helper *helpers,\n\t\t\t     struct video_device *vdev,\n\t\t\t     bool get)\n{\n\tstruct v4l2_ctrl_helper *h;\n\tbool have_clusters = false;\n\tu32 i;\n\n\tfor (i = 0, h = helpers; i < cs->count; i++, h++) {\n\t\tstruct v4l2_ext_control *c = &cs->controls[i];\n\t\tstruct v4l2_ctrl_ref *ref;\n\t\tstruct v4l2_ctrl *ctrl;\n\t\tu32 id = c->id & V4L2_CTRL_ID_MASK;\n\n\t\tcs->error_idx = i;\n\n\t\tif (cs->which &&\n\t\t    cs->which != V4L2_CTRL_WHICH_DEF_VAL &&\n\t\t    cs->which != V4L2_CTRL_WHICH_REQUEST_VAL &&\n\t\t    V4L2_CTRL_ID2WHICH(id) != cs->which) {\n\t\t\tdprintk(vdev,\n\t\t\t\t\"invalid which 0x%x or control id 0x%x\\n\",\n\t\t\t\tcs->which, id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (id >= V4L2_CID_PRIVATE_BASE) {\n\t\t\tdprintk(vdev,\n\t\t\t\t\"old-style private controls not allowed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tref = find_ref_lock(hdl, id);\n\t\tif (!ref) {\n\t\t\tdprintk(vdev, \"cannot find control id 0x%x\\n\", id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\th->ref = ref;\n\t\tctrl = ref->ctrl;\n\t\tif (ctrl->flags & V4L2_CTRL_FLAG_DISABLED) {\n\t\t\tdprintk(vdev, \"control id 0x%x is disabled\\n\", id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (ctrl->cluster[0]->ncontrols > 1)\n\t\t\thave_clusters = true;\n\t\tif (ctrl->cluster[0] != ctrl)\n\t\t\tref = find_ref_lock(hdl, ctrl->cluster[0]->id);\n\t\tif (ctrl->is_dyn_array) {\n\t\t\tunsigned int max_size = ctrl->dims[0] * ctrl->elem_size;\n\t\t\tunsigned int tot_size = ctrl->elem_size;\n\n\t\t\tif (cs->which == V4L2_CTRL_WHICH_REQUEST_VAL)\n\t\t\t\ttot_size *= ref->p_req_elems;\n\t\t\telse\n\t\t\t\ttot_size *= ctrl->elems;\n\n\t\t\tc->size = ctrl->elem_size * (c->size / ctrl->elem_size);\n\t\t\tif (get) {\n\t\t\t\tif (c->size < tot_size) {\n\t\t\t\t\tc->size = tot_size;\n\t\t\t\t\treturn -ENOSPC;\n\t\t\t\t}\n\t\t\t\tc->size = tot_size;\n\t\t\t} else {\n\t\t\t\tif (c->size > max_size) {\n\t\t\t\t\tc->size = max_size;\n\t\t\t\t\treturn -ENOSPC;\n\t\t\t\t}\n\t\t\t\tif (!c->size)\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else if (ctrl->is_ptr && !ctrl->is_string) {\n\t\t\tunsigned int tot_size = ctrl->elems * ctrl->elem_size;\n\n\t\t\tif (c->size < tot_size) {\n\t\t\t\t \n\t\t\t\tif (get) {\n\t\t\t\t\tc->size = tot_size;\n\t\t\t\t\treturn -ENOSPC;\n\t\t\t\t}\n\t\t\t\tdprintk(vdev,\n\t\t\t\t\t\"pointer control id 0x%x size too small, %d bytes but %d bytes needed\\n\",\n\t\t\t\t\tid, c->size, tot_size);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tc->size = tot_size;\n\t\t}\n\t\t \n\t\th->mref = ref;\n\t\t \n\t\th->next = 0;\n\t}\n\n\t \n\tif (!have_clusters)\n\t\treturn 0;\n\n\t \n\n\t \n\tmutex_lock(hdl->lock);\n\n\t \n\tfor (i = 0; i < cs->count; i++)\n\t\thelpers[i].mref->helper = NULL;\n\tfor (i = 0, h = helpers; i < cs->count; i++, h++) {\n\t\tstruct v4l2_ctrl_ref *mref = h->mref;\n\n\t\t \n\t\tif (mref->helper) {\n\t\t\t \n\t\t\tmref->helper->next = i;\n\t\t\t \n\t\t\th->mref = NULL;\n\t\t}\n\t\t \n\t\tmref->helper = h;\n\t}\n\tmutex_unlock(hdl->lock);\n\treturn 0;\n}\n\n \nstatic int class_check(struct v4l2_ctrl_handler *hdl, u32 which)\n{\n\tif (which == 0 || which == V4L2_CTRL_WHICH_DEF_VAL ||\n\t    which == V4L2_CTRL_WHICH_REQUEST_VAL)\n\t\treturn 0;\n\treturn find_ref_lock(hdl, which | 1) ? 0 : -EINVAL;\n}\n\n \nint v4l2_g_ext_ctrls_common(struct v4l2_ctrl_handler *hdl,\n\t\t\t    struct v4l2_ext_controls *cs,\n\t\t\t    struct video_device *vdev)\n{\n\tstruct v4l2_ctrl_helper helper[4];\n\tstruct v4l2_ctrl_helper *helpers = helper;\n\tint ret;\n\tint i, j;\n\tbool is_default, is_request;\n\n\tis_default = (cs->which == V4L2_CTRL_WHICH_DEF_VAL);\n\tis_request = (cs->which == V4L2_CTRL_WHICH_REQUEST_VAL);\n\n\tcs->error_idx = cs->count;\n\tcs->which = V4L2_CTRL_ID2WHICH(cs->which);\n\n\tif (!hdl)\n\t\treturn -EINVAL;\n\n\tif (cs->count == 0)\n\t\treturn class_check(hdl, cs->which);\n\n\tif (cs->count > ARRAY_SIZE(helper)) {\n\t\thelpers = kvmalloc_array(cs->count, sizeof(helper[0]),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!helpers)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tret = prepare_ext_ctrls(hdl, cs, helpers, vdev, true);\n\tcs->error_idx = cs->count;\n\n\tfor (i = 0; !ret && i < cs->count; i++)\n\t\tif (helpers[i].ref->ctrl->flags & V4L2_CTRL_FLAG_WRITE_ONLY)\n\t\t\tret = -EACCES;\n\n\tfor (i = 0; !ret && i < cs->count; i++) {\n\t\tstruct v4l2_ctrl *master;\n\t\tbool is_volatile = false;\n\t\tu32 idx = i;\n\n\t\tif (!helpers[i].mref)\n\t\t\tcontinue;\n\n\t\tmaster = helpers[i].mref->ctrl;\n\t\tcs->error_idx = i;\n\n\t\tv4l2_ctrl_lock(master);\n\n\t\t \n\t\tif (!is_default && !is_request &&\n\t\t    ((master->flags & V4L2_CTRL_FLAG_VOLATILE) ||\n\t\t    (master->has_volatiles && !is_cur_manual(master)))) {\n\t\t\tfor (j = 0; j < master->ncontrols; j++)\n\t\t\t\tcur_to_new(master->cluster[j]);\n\t\t\tret = call_op(master, g_volatile_ctrl);\n\t\t\tis_volatile = true;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tv4l2_ctrl_unlock(master);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tdo {\n\t\t\tstruct v4l2_ctrl_ref *ref = helpers[idx].ref;\n\n\t\t\tif (is_default)\n\t\t\t\tret = def_to_user(cs->controls + idx, ref->ctrl);\n\t\t\telse if (is_request && ref->p_req_array_enomem)\n\t\t\t\tret = -ENOMEM;\n\t\t\telse if (is_request && ref->p_req_valid)\n\t\t\t\tret = req_to_user(cs->controls + idx, ref);\n\t\t\telse if (is_volatile)\n\t\t\t\tret = new_to_user(cs->controls + idx, ref->ctrl);\n\t\t\telse\n\t\t\t\tret = cur_to_user(cs->controls + idx, ref->ctrl);\n\t\t\tidx = helpers[idx].next;\n\t\t} while (!ret && idx);\n\n\t\tv4l2_ctrl_unlock(master);\n\t}\n\n\tif (cs->count > ARRAY_SIZE(helper))\n\t\tkvfree(helpers);\n\treturn ret;\n}\n\nint v4l2_g_ext_ctrls(struct v4l2_ctrl_handler *hdl, struct video_device *vdev,\n\t\t     struct media_device *mdev, struct v4l2_ext_controls *cs)\n{\n\tif (cs->which == V4L2_CTRL_WHICH_REQUEST_VAL)\n\t\treturn v4l2_g_ext_ctrls_request(hdl, vdev, mdev, cs);\n\n\treturn v4l2_g_ext_ctrls_common(hdl, cs, vdev);\n}\nEXPORT_SYMBOL(v4l2_g_ext_ctrls);\n\n \nstatic int validate_new(const struct v4l2_ctrl *ctrl, union v4l2_ctrl_ptr p_new)\n{\n\treturn ctrl->type_ops->validate(ctrl, p_new);\n}\n\n \nstatic int validate_ctrls(struct v4l2_ext_controls *cs,\n\t\t\t  struct v4l2_ctrl_helper *helpers,\n\t\t\t  struct video_device *vdev,\n\t\t\t  bool set)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\tcs->error_idx = cs->count;\n\tfor (i = 0; i < cs->count; i++) {\n\t\tstruct v4l2_ctrl *ctrl = helpers[i].ref->ctrl;\n\t\tunion v4l2_ctrl_ptr p_new;\n\n\t\tcs->error_idx = i;\n\n\t\tif (ctrl->flags & V4L2_CTRL_FLAG_READ_ONLY) {\n\t\t\tdprintk(vdev,\n\t\t\t\t\"control id 0x%x is read-only\\n\",\n\t\t\t\tctrl->id);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t \n\t\tif (set && (ctrl->flags & V4L2_CTRL_FLAG_GRABBED)) {\n\t\t\tdprintk(vdev,\n\t\t\t\t\"control id 0x%x is grabbed, cannot set\\n\",\n\t\t\t\tctrl->id);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t \n\t\tif (ctrl->is_ptr)\n\t\t\tcontinue;\n\t\tif (ctrl->type == V4L2_CTRL_TYPE_INTEGER64)\n\t\t\tp_new.p_s64 = &cs->controls[i].value64;\n\t\telse\n\t\t\tp_new.p_s32 = &cs->controls[i].value;\n\t\tret = validate_new(ctrl, p_new);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nint try_set_ext_ctrls_common(struct v4l2_fh *fh,\n\t\t\t     struct v4l2_ctrl_handler *hdl,\n\t\t\t     struct v4l2_ext_controls *cs,\n\t\t\t     struct video_device *vdev, bool set)\n{\n\tstruct v4l2_ctrl_helper helper[4];\n\tstruct v4l2_ctrl_helper *helpers = helper;\n\tunsigned int i, j;\n\tint ret;\n\n\tcs->error_idx = cs->count;\n\n\t \n\tif (cs->which == V4L2_CTRL_WHICH_DEF_VAL) {\n\t\tdprintk(vdev, \"%s: cannot change default value\\n\",\n\t\t\tvideo_device_node_name(vdev));\n\t\treturn -EINVAL;\n\t}\n\n\tcs->which = V4L2_CTRL_ID2WHICH(cs->which);\n\n\tif (!hdl) {\n\t\tdprintk(vdev, \"%s: invalid null control handler\\n\",\n\t\t\tvideo_device_node_name(vdev));\n\t\treturn -EINVAL;\n\t}\n\n\tif (cs->count == 0)\n\t\treturn class_check(hdl, cs->which);\n\n\tif (cs->count > ARRAY_SIZE(helper)) {\n\t\thelpers = kvmalloc_array(cs->count, sizeof(helper[0]),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!helpers)\n\t\t\treturn -ENOMEM;\n\t}\n\tret = prepare_ext_ctrls(hdl, cs, helpers, vdev, false);\n\tif (!ret)\n\t\tret = validate_ctrls(cs, helpers, vdev, set);\n\tif (ret && set)\n\t\tcs->error_idx = cs->count;\n\tfor (i = 0; !ret && i < cs->count; i++) {\n\t\tstruct v4l2_ctrl *master;\n\t\tu32 idx = i;\n\n\t\tif (!helpers[i].mref)\n\t\t\tcontinue;\n\n\t\tcs->error_idx = i;\n\t\tmaster = helpers[i].mref->ctrl;\n\t\tv4l2_ctrl_lock(master);\n\n\t\t \n\t\tfor (j = 0; j < master->ncontrols; j++)\n\t\t\tif (master->cluster[j])\n\t\t\t\tmaster->cluster[j]->is_new = 0;\n\n\t\t \n\t\tif (master->is_auto && master->has_volatiles &&\n\t\t    !is_cur_manual(master)) {\n\t\t\t \n\t\t\ts32 new_auto_val = master->manual_mode_value + 1;\n\t\t\tu32 tmp_idx = idx;\n\n\t\t\tdo {\n\t\t\t\t \n\t\t\t\tif (helpers[tmp_idx].ref->ctrl == master)\n\t\t\t\t\tnew_auto_val = cs->controls[tmp_idx].value;\n\t\t\t\ttmp_idx = helpers[tmp_idx].next;\n\t\t\t} while (tmp_idx);\n\t\t\t \n\t\t\tif (new_auto_val == master->manual_mode_value)\n\t\t\t\tupdate_from_auto_cluster(master);\n\t\t}\n\n\t\t \n\t\tdo {\n\t\t\tstruct v4l2_ctrl *ctrl = helpers[idx].ref->ctrl;\n\n\t\t\tret = user_to_new(cs->controls + idx, ctrl);\n\t\t\tif (!ret && ctrl->is_ptr) {\n\t\t\t\tret = validate_new(ctrl, ctrl->p_new);\n\t\t\t\tif (ret)\n\t\t\t\t\tdprintk(vdev,\n\t\t\t\t\t\t\"failed to validate control %s (%d)\\n\",\n\t\t\t\t\t\tv4l2_ctrl_get_name(ctrl->id), ret);\n\t\t\t}\n\t\t\tidx = helpers[idx].next;\n\t\t} while (!ret && idx);\n\n\t\tif (!ret)\n\t\t\tret = try_or_set_cluster(fh, master,\n\t\t\t\t\t\t !hdl->req_obj.req && set, 0);\n\t\tif (!ret && hdl->req_obj.req && set) {\n\t\t\tfor (j = 0; j < master->ncontrols; j++) {\n\t\t\t\tstruct v4l2_ctrl_ref *ref =\n\t\t\t\t\tfind_ref(hdl, master->cluster[j]->id);\n\n\t\t\t\tnew_to_req(ref);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!ret) {\n\t\t\tidx = i;\n\t\t\tdo {\n\t\t\t\tret = new_to_user(cs->controls + idx,\n\t\t\t\t\t\t  helpers[idx].ref->ctrl);\n\t\t\t\tidx = helpers[idx].next;\n\t\t\t} while (!ret && idx);\n\t\t}\n\t\tv4l2_ctrl_unlock(master);\n\t}\n\n\tif (cs->count > ARRAY_SIZE(helper))\n\t\tkvfree(helpers);\n\treturn ret;\n}\n\nstatic int try_set_ext_ctrls(struct v4l2_fh *fh,\n\t\t\t     struct v4l2_ctrl_handler *hdl,\n\t\t\t     struct video_device *vdev,\n\t\t\t     struct media_device *mdev,\n\t\t\t     struct v4l2_ext_controls *cs, bool set)\n{\n\tint ret;\n\n\tif (cs->which == V4L2_CTRL_WHICH_REQUEST_VAL)\n\t\treturn try_set_ext_ctrls_request(fh, hdl, vdev, mdev, cs, set);\n\n\tret = try_set_ext_ctrls_common(fh, hdl, cs, vdev, set);\n\tif (ret)\n\t\tdprintk(vdev,\n\t\t\t\"%s: try_set_ext_ctrls_common failed (%d)\\n\",\n\t\t\tvideo_device_node_name(vdev), ret);\n\n\treturn ret;\n}\n\nint v4l2_try_ext_ctrls(struct v4l2_ctrl_handler *hdl,\n\t\t       struct video_device *vdev,\n\t\t       struct media_device *mdev,\n\t\t       struct v4l2_ext_controls *cs)\n{\n\treturn try_set_ext_ctrls(NULL, hdl, vdev, mdev, cs, false);\n}\nEXPORT_SYMBOL(v4l2_try_ext_ctrls);\n\nint v4l2_s_ext_ctrls(struct v4l2_fh *fh,\n\t\t     struct v4l2_ctrl_handler *hdl,\n\t\t     struct video_device *vdev,\n\t\t     struct media_device *mdev,\n\t\t     struct v4l2_ext_controls *cs)\n{\n\treturn try_set_ext_ctrls(fh, hdl, vdev, mdev, cs, true);\n}\nEXPORT_SYMBOL(v4l2_s_ext_ctrls);\n\n \n\n \nstatic int get_ctrl(struct v4l2_ctrl *ctrl, struct v4l2_ext_control *c)\n{\n\tstruct v4l2_ctrl *master = ctrl->cluster[0];\n\tint ret = 0;\n\tint i;\n\n\t \n\tif (!ctrl->is_int && ctrl->type != V4L2_CTRL_TYPE_INTEGER64)\n\t\treturn -EINVAL;\n\n\tif (ctrl->flags & V4L2_CTRL_FLAG_WRITE_ONLY)\n\t\treturn -EACCES;\n\n\tv4l2_ctrl_lock(master);\n\t \n\tif (ctrl->flags & V4L2_CTRL_FLAG_VOLATILE) {\n\t\tfor (i = 0; i < master->ncontrols; i++)\n\t\t\tcur_to_new(master->cluster[i]);\n\t\tret = call_op(master, g_volatile_ctrl);\n\t\tnew_to_user(c, ctrl);\n\t} else {\n\t\tcur_to_user(c, ctrl);\n\t}\n\tv4l2_ctrl_unlock(master);\n\treturn ret;\n}\n\nint v4l2_g_ctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_control *control)\n{\n\tstruct v4l2_ctrl *ctrl = v4l2_ctrl_find(hdl, control->id);\n\tstruct v4l2_ext_control c;\n\tint ret;\n\n\tif (!ctrl || !ctrl->is_int)\n\t\treturn -EINVAL;\n\tret = get_ctrl(ctrl, &c);\n\tcontrol->value = c.value;\n\treturn ret;\n}\nEXPORT_SYMBOL(v4l2_g_ctrl);\n\n \nstatic int set_ctrl(struct v4l2_fh *fh, struct v4l2_ctrl *ctrl, u32 ch_flags)\n{\n\tstruct v4l2_ctrl *master = ctrl->cluster[0];\n\tint ret;\n\tint i;\n\n\t \n\tfor (i = 0; i < master->ncontrols; i++)\n\t\tif (master->cluster[i])\n\t\t\tmaster->cluster[i]->is_new = 0;\n\n\tret = validate_new(ctrl, ctrl->p_new);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (master->is_auto && master->has_volatiles && ctrl == master &&\n\t    !is_cur_manual(master) && ctrl->val == master->manual_mode_value)\n\t\tupdate_from_auto_cluster(master);\n\n\tctrl->is_new = 1;\n\treturn try_or_set_cluster(fh, master, true, ch_flags);\n}\n\n \nstatic int set_ctrl_lock(struct v4l2_fh *fh, struct v4l2_ctrl *ctrl,\n\t\t\t struct v4l2_ext_control *c)\n{\n\tint ret;\n\n\tv4l2_ctrl_lock(ctrl);\n\tuser_to_new(c, ctrl);\n\tret = set_ctrl(fh, ctrl, 0);\n\tif (!ret)\n\t\tcur_to_user(c, ctrl);\n\tv4l2_ctrl_unlock(ctrl);\n\treturn ret;\n}\n\nint v4l2_s_ctrl(struct v4l2_fh *fh, struct v4l2_ctrl_handler *hdl,\n\t\tstruct v4l2_control *control)\n{\n\tstruct v4l2_ctrl *ctrl = v4l2_ctrl_find(hdl, control->id);\n\tstruct v4l2_ext_control c = { control->id };\n\tint ret;\n\n\tif (!ctrl || !ctrl->is_int)\n\t\treturn -EINVAL;\n\n\tif (ctrl->flags & V4L2_CTRL_FLAG_READ_ONLY)\n\t\treturn -EACCES;\n\n\tc.value = control->value;\n\tret = set_ctrl_lock(fh, ctrl, &c);\n\tcontrol->value = c.value;\n\treturn ret;\n}\nEXPORT_SYMBOL(v4l2_s_ctrl);\n\n \n\ns32 v4l2_ctrl_g_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_ext_control c;\n\n\t \n\tif (WARN_ON(!ctrl->is_int))\n\t\treturn 0;\n\tc.value = 0;\n\tget_ctrl(ctrl, &c);\n\treturn c.value;\n}\nEXPORT_SYMBOL(v4l2_ctrl_g_ctrl);\n\ns64 v4l2_ctrl_g_ctrl_int64(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_ext_control c;\n\n\t \n\tif (WARN_ON(ctrl->is_ptr || ctrl->type != V4L2_CTRL_TYPE_INTEGER64))\n\t\treturn 0;\n\tc.value64 = 0;\n\tget_ctrl(ctrl, &c);\n\treturn c.value64;\n}\nEXPORT_SYMBOL(v4l2_ctrl_g_ctrl_int64);\n\nint __v4l2_ctrl_s_ctrl(struct v4l2_ctrl *ctrl, s32 val)\n{\n\tlockdep_assert_held(ctrl->handler->lock);\n\n\t \n\tif (WARN_ON(!ctrl->is_int))\n\t\treturn -EINVAL;\n\tctrl->val = val;\n\treturn set_ctrl(NULL, ctrl, 0);\n}\nEXPORT_SYMBOL(__v4l2_ctrl_s_ctrl);\n\nint __v4l2_ctrl_s_ctrl_int64(struct v4l2_ctrl *ctrl, s64 val)\n{\n\tlockdep_assert_held(ctrl->handler->lock);\n\n\t \n\tif (WARN_ON(ctrl->is_ptr || ctrl->type != V4L2_CTRL_TYPE_INTEGER64))\n\t\treturn -EINVAL;\n\t*ctrl->p_new.p_s64 = val;\n\treturn set_ctrl(NULL, ctrl, 0);\n}\nEXPORT_SYMBOL(__v4l2_ctrl_s_ctrl_int64);\n\nint __v4l2_ctrl_s_ctrl_string(struct v4l2_ctrl *ctrl, const char *s)\n{\n\tlockdep_assert_held(ctrl->handler->lock);\n\n\t \n\tif (WARN_ON(ctrl->type != V4L2_CTRL_TYPE_STRING))\n\t\treturn -EINVAL;\n\tstrscpy(ctrl->p_new.p_char, s, ctrl->maximum + 1);\n\treturn set_ctrl(NULL, ctrl, 0);\n}\nEXPORT_SYMBOL(__v4l2_ctrl_s_ctrl_string);\n\nint __v4l2_ctrl_s_ctrl_compound(struct v4l2_ctrl *ctrl,\n\t\t\t\tenum v4l2_ctrl_type type, const void *p)\n{\n\tlockdep_assert_held(ctrl->handler->lock);\n\n\t \n\tif (WARN_ON(ctrl->type != type))\n\t\treturn -EINVAL;\n\t \n\tif (WARN_ON(ctrl->is_dyn_array))\n\t\treturn -EINVAL;\n\tmemcpy(ctrl->p_new.p, p, ctrl->elems * ctrl->elem_size);\n\treturn set_ctrl(NULL, ctrl, 0);\n}\nEXPORT_SYMBOL(__v4l2_ctrl_s_ctrl_compound);\n\n \nint __v4l2_ctrl_modify_range(struct v4l2_ctrl *ctrl,\n\t\t\t     s64 min, s64 max, u64 step, s64 def)\n{\n\tbool value_changed;\n\tbool range_changed = false;\n\tint ret;\n\n\tlockdep_assert_held(ctrl->handler->lock);\n\n\tswitch (ctrl->type) {\n\tcase V4L2_CTRL_TYPE_INTEGER:\n\tcase V4L2_CTRL_TYPE_INTEGER64:\n\tcase V4L2_CTRL_TYPE_BOOLEAN:\n\tcase V4L2_CTRL_TYPE_MENU:\n\tcase V4L2_CTRL_TYPE_INTEGER_MENU:\n\tcase V4L2_CTRL_TYPE_BITMASK:\n\tcase V4L2_CTRL_TYPE_U8:\n\tcase V4L2_CTRL_TYPE_U16:\n\tcase V4L2_CTRL_TYPE_U32:\n\t\tif (ctrl->is_array)\n\t\t\treturn -EINVAL;\n\t\tret = check_range(ctrl->type, min, max, step, def);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (ctrl->minimum != min || ctrl->maximum != max ||\n\t    ctrl->step != step || ctrl->default_value != def) {\n\t\trange_changed = true;\n\t\tctrl->minimum = min;\n\t\tctrl->maximum = max;\n\t\tctrl->step = step;\n\t\tctrl->default_value = def;\n\t}\n\tcur_to_new(ctrl);\n\tif (validate_new(ctrl, ctrl->p_new)) {\n\t\tif (ctrl->type == V4L2_CTRL_TYPE_INTEGER64)\n\t\t\t*ctrl->p_new.p_s64 = def;\n\t\telse\n\t\t\t*ctrl->p_new.p_s32 = def;\n\t}\n\n\tif (ctrl->type == V4L2_CTRL_TYPE_INTEGER64)\n\t\tvalue_changed = *ctrl->p_new.p_s64 != *ctrl->p_cur.p_s64;\n\telse\n\t\tvalue_changed = *ctrl->p_new.p_s32 != *ctrl->p_cur.p_s32;\n\tif (value_changed)\n\t\tret = set_ctrl(NULL, ctrl, V4L2_EVENT_CTRL_CH_RANGE);\n\telse if (range_changed)\n\t\tsend_event(NULL, ctrl, V4L2_EVENT_CTRL_CH_RANGE);\n\treturn ret;\n}\nEXPORT_SYMBOL(__v4l2_ctrl_modify_range);\n\nint __v4l2_ctrl_modify_dimensions(struct v4l2_ctrl *ctrl,\n\t\t\t\t  u32 dims[V4L2_CTRL_MAX_DIMS])\n{\n\tunsigned int elems = 1;\n\tunsigned int i;\n\tvoid *p_array;\n\n\tlockdep_assert_held(ctrl->handler->lock);\n\n\tif (!ctrl->is_array || ctrl->is_dyn_array)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ctrl->nr_of_dims; i++)\n\t\telems *= dims[i];\n\tif (elems == 0)\n\t\treturn -EINVAL;\n\tp_array = kvzalloc(2 * elems * ctrl->elem_size, GFP_KERNEL);\n\tif (!p_array)\n\t\treturn -ENOMEM;\n\tkvfree(ctrl->p_array);\n\tctrl->p_array_alloc_elems = elems;\n\tctrl->elems = elems;\n\tctrl->new_elems = elems;\n\tctrl->p_array = p_array;\n\tctrl->p_new.p = p_array;\n\tctrl->p_cur.p = p_array + elems * ctrl->elem_size;\n\tfor (i = 0; i < ctrl->nr_of_dims; i++)\n\t\tctrl->dims[i] = dims[i];\n\tctrl->type_ops->init(ctrl, 0, ctrl->p_cur);\n\tcur_to_new(ctrl);\n\tsend_event(NULL, ctrl, V4L2_EVENT_CTRL_CH_VALUE |\n\t\t\t       V4L2_EVENT_CTRL_CH_DIMENSIONS);\n\treturn 0;\n}\nEXPORT_SYMBOL(__v4l2_ctrl_modify_dimensions);\n\n \nint v4l2_query_ext_ctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_query_ext_ctrl *qc)\n{\n\tconst unsigned int next_flags = V4L2_CTRL_FLAG_NEXT_CTRL | V4L2_CTRL_FLAG_NEXT_COMPOUND;\n\tu32 id = qc->id & V4L2_CTRL_ID_MASK;\n\tstruct v4l2_ctrl_ref *ref;\n\tstruct v4l2_ctrl *ctrl;\n\n\tif (!hdl)\n\t\treturn -EINVAL;\n\n\tmutex_lock(hdl->lock);\n\n\t \n\tref = find_ref(hdl, id);\n\n\tif ((qc->id & next_flags) && !list_empty(&hdl->ctrl_refs)) {\n\t\tbool is_compound;\n\t\t \n\t\tunsigned int mask = 1;\n\t\tbool match = false;\n\n\t\tif ((qc->id & next_flags) == V4L2_CTRL_FLAG_NEXT_COMPOUND) {\n\t\t\t \n\t\t\tmatch = true;\n\t\t} else if ((qc->id & next_flags) == next_flags) {\n\t\t\t \n\t\t\tmask = 0;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tif (id >= node2id(hdl->ctrl_refs.prev)) {\n\t\t\tref = NULL;  \n\t\t} else if (ref) {\n\t\t\t \n\t\t\tlist_for_each_entry_continue(ref, &hdl->ctrl_refs, node) {\n\t\t\t\tis_compound = ref->ctrl->is_array ||\n\t\t\t\t\tref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;\n\t\t\t\tif (id < ref->ctrl->id &&\n\t\t\t\t    (is_compound & mask) == match)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (&ref->node == &hdl->ctrl_refs)\n\t\t\t\tref = NULL;\n\t\t} else {\n\t\t\t \n\t\t\tlist_for_each_entry(ref, &hdl->ctrl_refs, node) {\n\t\t\t\tis_compound = ref->ctrl->is_array ||\n\t\t\t\t\tref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;\n\t\t\t\tif (id < ref->ctrl->id &&\n\t\t\t\t    (is_compound & mask) == match)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (&ref->node == &hdl->ctrl_refs)\n\t\t\t\tref = NULL;\n\t\t}\n\t}\n\tmutex_unlock(hdl->lock);\n\n\tif (!ref)\n\t\treturn -EINVAL;\n\n\tctrl = ref->ctrl;\n\tmemset(qc, 0, sizeof(*qc));\n\tif (id >= V4L2_CID_PRIVATE_BASE)\n\t\tqc->id = id;\n\telse\n\t\tqc->id = ctrl->id;\n\tstrscpy(qc->name, ctrl->name, sizeof(qc->name));\n\tqc->flags = user_flags(ctrl);\n\tqc->type = ctrl->type;\n\tqc->elem_size = ctrl->elem_size;\n\tqc->elems = ctrl->elems;\n\tqc->nr_of_dims = ctrl->nr_of_dims;\n\tmemcpy(qc->dims, ctrl->dims, qc->nr_of_dims * sizeof(qc->dims[0]));\n\tqc->minimum = ctrl->minimum;\n\tqc->maximum = ctrl->maximum;\n\tqc->default_value = ctrl->default_value;\n\tif (ctrl->type == V4L2_CTRL_TYPE_MENU ||\n\t    ctrl->type == V4L2_CTRL_TYPE_INTEGER_MENU)\n\t\tqc->step = 1;\n\telse\n\t\tqc->step = ctrl->step;\n\treturn 0;\n}\nEXPORT_SYMBOL(v4l2_query_ext_ctrl);\n\n \nint v4l2_queryctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_queryctrl *qc)\n{\n\tstruct v4l2_query_ext_ctrl qec = { qc->id };\n\tint rc;\n\n\trc = v4l2_query_ext_ctrl(hdl, &qec);\n\tif (rc)\n\t\treturn rc;\n\n\tqc->id = qec.id;\n\tqc->type = qec.type;\n\tqc->flags = qec.flags;\n\tstrscpy(qc->name, qec.name, sizeof(qc->name));\n\tswitch (qc->type) {\n\tcase V4L2_CTRL_TYPE_INTEGER:\n\tcase V4L2_CTRL_TYPE_BOOLEAN:\n\tcase V4L2_CTRL_TYPE_MENU:\n\tcase V4L2_CTRL_TYPE_INTEGER_MENU:\n\tcase V4L2_CTRL_TYPE_STRING:\n\tcase V4L2_CTRL_TYPE_BITMASK:\n\t\tqc->minimum = qec.minimum;\n\t\tqc->maximum = qec.maximum;\n\t\tqc->step = qec.step;\n\t\tqc->default_value = qec.default_value;\n\t\tbreak;\n\tdefault:\n\t\tqc->minimum = 0;\n\t\tqc->maximum = 0;\n\t\tqc->step = 0;\n\t\tqc->default_value = 0;\n\t\tbreak;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(v4l2_queryctrl);\n\n \nint v4l2_querymenu(struct v4l2_ctrl_handler *hdl, struct v4l2_querymenu *qm)\n{\n\tstruct v4l2_ctrl *ctrl;\n\tu32 i = qm->index;\n\n\tctrl = v4l2_ctrl_find(hdl, qm->id);\n\tif (!ctrl)\n\t\treturn -EINVAL;\n\n\tqm->reserved = 0;\n\t \n\tswitch (ctrl->type) {\n\tcase V4L2_CTRL_TYPE_MENU:\n\t\tif (!ctrl->qmenu)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_INTEGER_MENU:\n\t\tif (!ctrl->qmenu_int)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (i < ctrl->minimum || i > ctrl->maximum)\n\t\treturn -EINVAL;\n\n\t \n\tif (ctrl->menu_skip_mask & (1ULL << i))\n\t\treturn -EINVAL;\n\t \n\tif (ctrl->type == V4L2_CTRL_TYPE_MENU) {\n\t\tif (!ctrl->qmenu[i] || ctrl->qmenu[i][0] == '\\0')\n\t\t\treturn -EINVAL;\n\t\tstrscpy(qm->name, ctrl->qmenu[i], sizeof(qm->name));\n\t} else {\n\t\tqm->value = ctrl->qmenu_int[i];\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(v4l2_querymenu);\n\n \n\nint v4l2_ctrl_log_status(struct file *file, void *fh)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_fh *vfh = file->private_data;\n\n\tif (test_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) && vfd->v4l2_dev)\n\t\tv4l2_ctrl_handler_log_status(vfh->ctrl_handler,\n\t\t\t\t\t     vfd->v4l2_dev->name);\n\treturn 0;\n}\nEXPORT_SYMBOL(v4l2_ctrl_log_status);\n\nint v4l2_ctrl_subdev_log_status(struct v4l2_subdev *sd)\n{\n\tv4l2_ctrl_handler_log_status(sd->ctrl_handler, sd->name);\n\treturn 0;\n}\nEXPORT_SYMBOL(v4l2_ctrl_subdev_log_status);\n\n \n\nstatic int v4l2_ctrl_add_event(struct v4l2_subscribed_event *sev,\n\t\t\t       unsigned int elems)\n{\n\tstruct v4l2_ctrl *ctrl = v4l2_ctrl_find(sev->fh->ctrl_handler, sev->id);\n\n\tif (!ctrl)\n\t\treturn -EINVAL;\n\n\tv4l2_ctrl_lock(ctrl);\n\tlist_add_tail(&sev->node, &ctrl->ev_subs);\n\tif (ctrl->type != V4L2_CTRL_TYPE_CTRL_CLASS &&\n\t    (sev->flags & V4L2_EVENT_SUB_FL_SEND_INITIAL))\n\t\tsend_initial_event(sev->fh, ctrl);\n\tv4l2_ctrl_unlock(ctrl);\n\treturn 0;\n}\n\nstatic void v4l2_ctrl_del_event(struct v4l2_subscribed_event *sev)\n{\n\tstruct v4l2_ctrl *ctrl = v4l2_ctrl_find(sev->fh->ctrl_handler, sev->id);\n\n\tif (!ctrl)\n\t\treturn;\n\n\tv4l2_ctrl_lock(ctrl);\n\tlist_del(&sev->node);\n\tv4l2_ctrl_unlock(ctrl);\n}\n\nvoid v4l2_ctrl_replace(struct v4l2_event *old, const struct v4l2_event *new)\n{\n\tu32 old_changes = old->u.ctrl.changes;\n\n\told->u.ctrl = new->u.ctrl;\n\told->u.ctrl.changes |= old_changes;\n}\nEXPORT_SYMBOL(v4l2_ctrl_replace);\n\nvoid v4l2_ctrl_merge(const struct v4l2_event *old, struct v4l2_event *new)\n{\n\tnew->u.ctrl.changes |= old->u.ctrl.changes;\n}\nEXPORT_SYMBOL(v4l2_ctrl_merge);\n\nconst struct v4l2_subscribed_event_ops v4l2_ctrl_sub_ev_ops = {\n\t.add = v4l2_ctrl_add_event,\n\t.del = v4l2_ctrl_del_event,\n\t.replace = v4l2_ctrl_replace,\n\t.merge = v4l2_ctrl_merge,\n};\nEXPORT_SYMBOL(v4l2_ctrl_sub_ev_ops);\n\nint v4l2_ctrl_subscribe_event(struct v4l2_fh *fh,\n\t\t\t      const struct v4l2_event_subscription *sub)\n{\n\tif (sub->type == V4L2_EVENT_CTRL)\n\t\treturn v4l2_event_subscribe(fh, sub, 0, &v4l2_ctrl_sub_ev_ops);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(v4l2_ctrl_subscribe_event);\n\nint v4l2_ctrl_subdev_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,\n\t\t\t\t     struct v4l2_event_subscription *sub)\n{\n\tif (!sd->ctrl_handler)\n\t\treturn -EINVAL;\n\treturn v4l2_ctrl_subscribe_event(fh, sub);\n}\nEXPORT_SYMBOL(v4l2_ctrl_subdev_subscribe_event);\n\n \n__poll_t v4l2_ctrl_poll(struct file *file, struct poll_table_struct *wait)\n{\n\tstruct v4l2_fh *fh = file->private_data;\n\n\tpoll_wait(file, &fh->wait, wait);\n\tif (v4l2_event_pending(fh))\n\t\treturn EPOLLPRI;\n\treturn 0;\n}\nEXPORT_SYMBOL(v4l2_ctrl_poll);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}