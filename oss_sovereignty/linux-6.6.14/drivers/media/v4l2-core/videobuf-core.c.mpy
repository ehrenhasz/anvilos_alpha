{
  "module_name": "videobuf-core.c",
  "hash_id": "d49c3349dcdf0b7ae0bc7957cf33a852de003ce796b8f1a15e46523989562f1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/videobuf-core.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n\n#include <media/videobuf-core.h>\n#include <media/v4l2-common.h>\n\n#define MAGIC_BUFFER 0x20070728\n#define MAGIC_CHECK(is, should)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (unlikely((is) != (should))) {\t\t\t\\\n\t\t\tprintk(KERN_ERR\t\t\t\t\t\\\n\t\t\t\t\"magic mismatch: %x (expected %x)\\n\",\t\\\n\t\t\t\t\tis, should);\t\t\t\\\n\t\t\tBUG();\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic int debug;\nmodule_param(debug, int, 0644);\n\nMODULE_DESCRIPTION(\"helper module to manage video4linux buffers\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab <mchehab@kernel.org>\");\nMODULE_LICENSE(\"GPL\");\n\n#define dprintk(level, fmt, arg...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (debug >= level)\t\t\t\t\t\\\n\t\t\tprintk(KERN_DEBUG \"vbuf: \" fmt, ## arg);\t\\\n\t} while (0)\n\n \n\n#define CALL(q, f, arg...)\t\t\t\t\t\t\\\n\t((q->int_ops->f) ? q->int_ops->f(arg) : 0)\n#define CALLPTR(q, f, arg...)\t\t\t\t\t\t\\\n\t((q->int_ops->f) ? q->int_ops->f(arg) : NULL)\n\nstruct videobuf_buffer *videobuf_alloc_vb(struct videobuf_queue *q)\n{\n\tstruct videobuf_buffer *vb;\n\n\tBUG_ON(q->msize < sizeof(*vb));\n\n\tif (!q->int_ops || !q->int_ops->alloc_vb) {\n\t\tprintk(KERN_ERR \"No specific ops defined!\\n\");\n\t\tBUG();\n\t}\n\n\tvb = q->int_ops->alloc_vb(q->msize);\n\tif (NULL != vb) {\n\t\tinit_waitqueue_head(&vb->done);\n\t\tvb->magic = MAGIC_BUFFER;\n\t}\n\n\treturn vb;\n}\nEXPORT_SYMBOL_GPL(videobuf_alloc_vb);\n\nstatic int state_neither_active_nor_queued(struct videobuf_queue *q,\n\t\t\t\t\t   struct videobuf_buffer *vb)\n{\n\tunsigned long flags;\n\tbool rc;\n\n\tspin_lock_irqsave(q->irqlock, flags);\n\trc = vb->state != VIDEOBUF_ACTIVE && vb->state != VIDEOBUF_QUEUED;\n\tspin_unlock_irqrestore(q->irqlock, flags);\n\treturn rc;\n};\n\nint videobuf_waiton(struct videobuf_queue *q, struct videobuf_buffer *vb,\n\t\tint non_blocking, int intr)\n{\n\tbool is_ext_locked;\n\tint ret = 0;\n\n\tMAGIC_CHECK(vb->magic, MAGIC_BUFFER);\n\n\tif (non_blocking) {\n\t\tif (state_neither_active_nor_queued(q, vb))\n\t\t\treturn 0;\n\t\treturn -EAGAIN;\n\t}\n\n\tis_ext_locked = q->ext_lock && mutex_is_locked(q->ext_lock);\n\n\t \n\tif (is_ext_locked)\n\t\tmutex_unlock(q->ext_lock);\n\tif (intr)\n\t\tret = wait_event_interruptible(vb->done,\n\t\t\t\t\tstate_neither_active_nor_queued(q, vb));\n\telse\n\t\twait_event(vb->done, state_neither_active_nor_queued(q, vb));\n\t \n\tif (is_ext_locked)\n\t\tmutex_lock(q->ext_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(videobuf_waiton);\n\nint videobuf_iolock(struct videobuf_queue *q, struct videobuf_buffer *vb,\n\t\t    struct v4l2_framebuffer *fbuf)\n{\n\tMAGIC_CHECK(vb->magic, MAGIC_BUFFER);\n\tMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\n\n\treturn CALL(q, iolock, q, vb, fbuf);\n}\nEXPORT_SYMBOL_GPL(videobuf_iolock);\n\nvoid *videobuf_queue_to_vaddr(struct videobuf_queue *q,\n\t\t\t      struct videobuf_buffer *buf)\n{\n\tif (q->int_ops->vaddr)\n\t\treturn q->int_ops->vaddr(buf);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(videobuf_queue_to_vaddr);\n\n \n\n\nvoid videobuf_queue_core_init(struct videobuf_queue *q,\n\t\t\t const struct videobuf_queue_ops *ops,\n\t\t\t struct device *dev,\n\t\t\t spinlock_t *irqlock,\n\t\t\t enum v4l2_buf_type type,\n\t\t\t enum v4l2_field field,\n\t\t\t unsigned int msize,\n\t\t\t void *priv,\n\t\t\t struct videobuf_qtype_ops *int_ops,\n\t\t\t struct mutex *ext_lock)\n{\n\tBUG_ON(!q);\n\tmemset(q, 0, sizeof(*q));\n\tq->irqlock   = irqlock;\n\tq->ext_lock  = ext_lock;\n\tq->dev       = dev;\n\tq->type      = type;\n\tq->field     = field;\n\tq->msize     = msize;\n\tq->ops       = ops;\n\tq->priv_data = priv;\n\tq->int_ops   = int_ops;\n\n\t \n\tBUG_ON(!q->ops->buf_setup);\n\tBUG_ON(!q->ops->buf_prepare);\n\tBUG_ON(!q->ops->buf_queue);\n\tBUG_ON(!q->ops->buf_release);\n\n\t \n\tBUG_ON(!irqlock);\n\n\t \n\tBUG_ON(!q->int_ops);\n\n\tmutex_init(&q->vb_lock);\n\tinit_waitqueue_head(&q->wait);\n\tINIT_LIST_HEAD(&q->stream);\n}\nEXPORT_SYMBOL_GPL(videobuf_queue_core_init);\n\n \nint videobuf_queue_is_busy(struct videobuf_queue *q)\n{\n\tint i;\n\n\tMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\n\n\tif (q->streaming) {\n\t\tdprintk(1, \"busy: streaming active\\n\");\n\t\treturn 1;\n\t}\n\tif (q->reading) {\n\t\tdprintk(1, \"busy: pending read #1\\n\");\n\t\treturn 1;\n\t}\n\tif (q->read_buf) {\n\t\tdprintk(1, \"busy: pending read #2\\n\");\n\t\treturn 1;\n\t}\n\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\tif (NULL == q->bufs[i])\n\t\t\tcontinue;\n\t\tif (q->bufs[i]->map) {\n\t\t\tdprintk(1, \"busy: buffer #%d mapped\\n\", i);\n\t\t\treturn 1;\n\t\t}\n\t\tif (q->bufs[i]->state == VIDEOBUF_QUEUED) {\n\t\t\tdprintk(1, \"busy: buffer #%d queued\\n\", i);\n\t\t\treturn 1;\n\t\t}\n\t\tif (q->bufs[i]->state == VIDEOBUF_ACTIVE) {\n\t\t\tdprintk(1, \"busy: buffer #%d active\\n\", i);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(videobuf_queue_is_busy);\n\n \n \nstatic int __videobuf_free(struct videobuf_queue *q)\n{\n\tint i;\n\n\tdprintk(1, \"%s\\n\", __func__);\n\tif (!q)\n\t\treturn 0;\n\n\tif (q->streaming || q->reading) {\n\t\tdprintk(1, \"Cannot free buffers when streaming or reading\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\n\n\tfor (i = 0; i < VIDEO_MAX_FRAME; i++)\n\t\tif (q->bufs[i] && q->bufs[i]->map) {\n\t\t\tdprintk(1, \"Cannot free mmapped buffers\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\n\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\tif (NULL == q->bufs[i])\n\t\t\tcontinue;\n\t\tq->ops->buf_release(q, q->bufs[i]);\n\t\tkfree(q->bufs[i]);\n\t\tq->bufs[i] = NULL;\n\t}\n\n\treturn 0;\n}\n\n \nvoid videobuf_queue_cancel(struct videobuf_queue *q)\n{\n\tunsigned long flags = 0;\n\tint i;\n\n\tq->streaming = 0;\n\tq->reading  = 0;\n\twake_up_interruptible_sync(&q->wait);\n\n\t \n\tspin_lock_irqsave(q->irqlock, flags);\n\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\tif (NULL == q->bufs[i])\n\t\t\tcontinue;\n\t\tif (q->bufs[i]->state == VIDEOBUF_QUEUED) {\n\t\t\tlist_del(&q->bufs[i]->queue);\n\t\t\tq->bufs[i]->state = VIDEOBUF_ERROR;\n\t\t\twake_up_all(&q->bufs[i]->done);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(q->irqlock, flags);\n\n\t \n\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\tif (NULL == q->bufs[i])\n\t\t\tcontinue;\n\t\tq->ops->buf_release(q, q->bufs[i]);\n\t}\n\tINIT_LIST_HEAD(&q->stream);\n}\nEXPORT_SYMBOL_GPL(videobuf_queue_cancel);\n\n \n\n \nenum v4l2_field videobuf_next_field(struct videobuf_queue *q)\n{\n\tenum v4l2_field field = q->field;\n\n\tBUG_ON(V4L2_FIELD_ANY == field);\n\n\tif (V4L2_FIELD_ALTERNATE == field) {\n\t\tif (V4L2_FIELD_TOP == q->last) {\n\t\t\tfield   = V4L2_FIELD_BOTTOM;\n\t\t\tq->last = V4L2_FIELD_BOTTOM;\n\t\t} else {\n\t\t\tfield   = V4L2_FIELD_TOP;\n\t\t\tq->last = V4L2_FIELD_TOP;\n\t\t}\n\t}\n\treturn field;\n}\nEXPORT_SYMBOL_GPL(videobuf_next_field);\n\n \nstatic void videobuf_status(struct videobuf_queue *q, struct v4l2_buffer *b,\n\t\t\t    struct videobuf_buffer *vb, enum v4l2_buf_type type)\n{\n\tMAGIC_CHECK(vb->magic, MAGIC_BUFFER);\n\tMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\n\n\tb->index    = vb->i;\n\tb->type     = type;\n\n\tb->memory   = vb->memory;\n\tswitch (b->memory) {\n\tcase V4L2_MEMORY_MMAP:\n\t\tb->m.offset  = vb->boff;\n\t\tb->length    = vb->bsize;\n\t\tbreak;\n\tcase V4L2_MEMORY_USERPTR:\n\t\tb->m.userptr = vb->baddr;\n\t\tb->length    = vb->bsize;\n\t\tbreak;\n\tcase V4L2_MEMORY_OVERLAY:\n\t\tb->m.offset  = vb->boff;\n\t\tbreak;\n\tcase V4L2_MEMORY_DMABUF:\n\t\t \n\t\tbreak;\n\t}\n\n\tb->flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tif (vb->map)\n\t\tb->flags |= V4L2_BUF_FLAG_MAPPED;\n\n\tswitch (vb->state) {\n\tcase VIDEOBUF_PREPARED:\n\tcase VIDEOBUF_QUEUED:\n\tcase VIDEOBUF_ACTIVE:\n\t\tb->flags |= V4L2_BUF_FLAG_QUEUED;\n\t\tbreak;\n\tcase VIDEOBUF_ERROR:\n\t\tb->flags |= V4L2_BUF_FLAG_ERROR;\n\t\tfallthrough;\n\tcase VIDEOBUF_DONE:\n\t\tb->flags |= V4L2_BUF_FLAG_DONE;\n\t\tbreak;\n\tcase VIDEOBUF_NEEDS_INIT:\n\tcase VIDEOBUF_IDLE:\n\t\t \n\t\tbreak;\n\t}\n\n\tb->field     = vb->field;\n\tv4l2_buffer_set_timestamp(b, vb->ts);\n\tb->bytesused = vb->size;\n\tb->sequence  = vb->field_count >> 1;\n}\n\nint videobuf_mmap_free(struct videobuf_queue *q)\n{\n\tint ret;\n\tvideobuf_queue_lock(q);\n\tret = __videobuf_free(q);\n\tvideobuf_queue_unlock(q);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(videobuf_mmap_free);\n\n \nint __videobuf_mmap_setup(struct videobuf_queue *q,\n\t\t\tunsigned int bcount, unsigned int bsize,\n\t\t\tenum v4l2_memory memory)\n{\n\tunsigned int i;\n\tint err;\n\n\tMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\n\n\terr = __videobuf_free(q);\n\tif (0 != err)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i < bcount; i++) {\n\t\tq->bufs[i] = videobuf_alloc_vb(q);\n\n\t\tif (NULL == q->bufs[i])\n\t\t\tbreak;\n\n\t\tq->bufs[i]->i      = i;\n\t\tq->bufs[i]->memory = memory;\n\t\tq->bufs[i]->bsize  = bsize;\n\t\tswitch (memory) {\n\t\tcase V4L2_MEMORY_MMAP:\n\t\t\tq->bufs[i]->boff = PAGE_ALIGN(bsize) * i;\n\t\t\tbreak;\n\t\tcase V4L2_MEMORY_USERPTR:\n\t\tcase V4L2_MEMORY_OVERLAY:\n\t\tcase V4L2_MEMORY_DMABUF:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!i)\n\t\treturn -ENOMEM;\n\n\tdprintk(1, \"mmap setup: %d buffers, %d bytes each\\n\", i, bsize);\n\n\treturn i;\n}\nEXPORT_SYMBOL_GPL(__videobuf_mmap_setup);\n\nint videobuf_mmap_setup(struct videobuf_queue *q,\n\t\t\tunsigned int bcount, unsigned int bsize,\n\t\t\tenum v4l2_memory memory)\n{\n\tint ret;\n\tvideobuf_queue_lock(q);\n\tret = __videobuf_mmap_setup(q, bcount, bsize, memory);\n\tvideobuf_queue_unlock(q);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(videobuf_mmap_setup);\n\nint videobuf_reqbufs(struct videobuf_queue *q,\n\t\t struct v4l2_requestbuffers *req)\n{\n\tunsigned int size, count;\n\tint retval;\n\n\tif (req->memory != V4L2_MEMORY_MMAP     &&\n\t    req->memory != V4L2_MEMORY_USERPTR  &&\n\t    req->memory != V4L2_MEMORY_OVERLAY) {\n\t\tdprintk(1, \"reqbufs: memory type invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvideobuf_queue_lock(q);\n\tif (req->type != q->type) {\n\t\tdprintk(1, \"reqbufs: queue type invalid\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (q->streaming) {\n\t\tdprintk(1, \"reqbufs: streaming already exists\\n\");\n\t\tretval = -EBUSY;\n\t\tgoto done;\n\t}\n\tif (!list_empty(&q->stream)) {\n\t\tdprintk(1, \"reqbufs: stream running\\n\");\n\t\tretval = -EBUSY;\n\t\tgoto done;\n\t}\n\n\tif (req->count == 0) {\n\t\tdprintk(1, \"reqbufs: count invalid (%d)\\n\", req->count);\n\t\tretval = __videobuf_free(q);\n\t\tgoto done;\n\t}\n\n\tcount = req->count;\n\tif (count > VIDEO_MAX_FRAME)\n\t\tcount = VIDEO_MAX_FRAME;\n\tsize = 0;\n\tq->ops->buf_setup(q, &count, &size);\n\tdprintk(1, \"reqbufs: bufs=%d, size=0x%x [%u pages total]\\n\",\n\t\tcount, size,\n\t\t(unsigned int)((count * PAGE_ALIGN(size)) >> PAGE_SHIFT));\n\n\tretval = __videobuf_mmap_setup(q, count, size, req->memory);\n\tif (retval < 0) {\n\t\tdprintk(1, \"reqbufs: mmap setup returned %d\\n\", retval);\n\t\tgoto done;\n\t}\n\n\treq->count = retval;\n\tretval = 0;\n\n done:\n\tvideobuf_queue_unlock(q);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(videobuf_reqbufs);\n\nint videobuf_querybuf(struct videobuf_queue *q, struct v4l2_buffer *b)\n{\n\tint ret = -EINVAL;\n\n\tvideobuf_queue_lock(q);\n\tif (unlikely(b->type != q->type)) {\n\t\tdprintk(1, \"querybuf: Wrong type.\\n\");\n\t\tgoto done;\n\t}\n\tif (unlikely(b->index >= VIDEO_MAX_FRAME)) {\n\t\tdprintk(1, \"querybuf: index out of range.\\n\");\n\t\tgoto done;\n\t}\n\tif (unlikely(NULL == q->bufs[b->index])) {\n\t\tdprintk(1, \"querybuf: buffer is null.\\n\");\n\t\tgoto done;\n\t}\n\n\tvideobuf_status(q, b, q->bufs[b->index], q->type);\n\n\tret = 0;\ndone:\n\tvideobuf_queue_unlock(q);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(videobuf_querybuf);\n\nint videobuf_qbuf(struct videobuf_queue *q, struct v4l2_buffer *b)\n{\n\tstruct videobuf_buffer *buf;\n\tenum v4l2_field field;\n\tunsigned long flags = 0;\n\tint retval;\n\n\tMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\n\n\tif (b->memory == V4L2_MEMORY_MMAP)\n\t\tmmap_read_lock(current->mm);\n\n\tvideobuf_queue_lock(q);\n\tretval = -EBUSY;\n\tif (q->reading) {\n\t\tdprintk(1, \"qbuf: Reading running...\\n\");\n\t\tgoto done;\n\t}\n\tretval = -EINVAL;\n\tif (b->type != q->type) {\n\t\tdprintk(1, \"qbuf: Wrong type.\\n\");\n\t\tgoto done;\n\t}\n\tif (b->index >= VIDEO_MAX_FRAME) {\n\t\tdprintk(1, \"qbuf: index out of range.\\n\");\n\t\tgoto done;\n\t}\n\tbuf = q->bufs[b->index];\n\tif (NULL == buf) {\n\t\tdprintk(1, \"qbuf: buffer is null.\\n\");\n\t\tgoto done;\n\t}\n\tMAGIC_CHECK(buf->magic, MAGIC_BUFFER);\n\tif (buf->memory != b->memory) {\n\t\tdprintk(1, \"qbuf: memory type is wrong.\\n\");\n\t\tgoto done;\n\t}\n\tif (buf->state != VIDEOBUF_NEEDS_INIT && buf->state != VIDEOBUF_IDLE) {\n\t\tdprintk(1, \"qbuf: buffer is already queued or active.\\n\");\n\t\tgoto done;\n\t}\n\n\tswitch (b->memory) {\n\tcase V4L2_MEMORY_MMAP:\n\t\tif (0 == buf->baddr) {\n\t\t\tdprintk(1, \"qbuf: mmap requested but buffer addr is zero!\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT\n\t\t    || q->type == V4L2_BUF_TYPE_VBI_OUTPUT\n\t\t    || q->type == V4L2_BUF_TYPE_SLICED_VBI_OUTPUT\n\t\t    || q->type == V4L2_BUF_TYPE_SDR_OUTPUT) {\n\t\t\tbuf->size = b->bytesused;\n\t\t\tbuf->field = b->field;\n\t\t\tbuf->ts = v4l2_buffer_get_timestamp(b);\n\t\t}\n\t\tbreak;\n\tcase V4L2_MEMORY_USERPTR:\n\t\tif (b->length < buf->bsize) {\n\t\t\tdprintk(1, \"qbuf: buffer length is not enough\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (VIDEOBUF_NEEDS_INIT != buf->state &&\n\t\t    buf->baddr != b->m.userptr)\n\t\t\tq->ops->buf_release(q, buf);\n\t\tbuf->baddr = b->m.userptr;\n\t\tbreak;\n\tcase V4L2_MEMORY_OVERLAY:\n\t\tbuf->boff = b->m.offset;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(1, \"qbuf: wrong memory type\\n\");\n\t\tgoto done;\n\t}\n\n\tdprintk(1, \"qbuf: requesting next field\\n\");\n\tfield = videobuf_next_field(q);\n\tretval = q->ops->buf_prepare(q, buf, field);\n\tif (0 != retval) {\n\t\tdprintk(1, \"qbuf: buffer_prepare returned %d\\n\", retval);\n\t\tgoto done;\n\t}\n\n\tlist_add_tail(&buf->stream, &q->stream);\n\tif (q->streaming) {\n\t\tspin_lock_irqsave(q->irqlock, flags);\n\t\tq->ops->buf_queue(q, buf);\n\t\tspin_unlock_irqrestore(q->irqlock, flags);\n\t}\n\tdprintk(1, \"qbuf: succeeded\\n\");\n\tretval = 0;\n\twake_up_interruptible_sync(&q->wait);\n\ndone:\n\tvideobuf_queue_unlock(q);\n\n\tif (b->memory == V4L2_MEMORY_MMAP)\n\t\tmmap_read_unlock(current->mm);\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(videobuf_qbuf);\n\n \nstatic int stream_next_buffer_check_queue(struct videobuf_queue *q, int noblock)\n{\n\tint retval;\n\nchecks:\n\tif (!q->streaming) {\n\t\tdprintk(1, \"next_buffer: Not streaming\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (list_empty(&q->stream)) {\n\t\tif (noblock) {\n\t\t\tretval = -EAGAIN;\n\t\t\tdprintk(2, \"next_buffer: no buffers to dequeue\\n\");\n\t\t\tgoto done;\n\t\t} else {\n\t\t\tdprintk(2, \"next_buffer: waiting on buffer\\n\");\n\n\t\t\t \n\t\t\tvideobuf_queue_unlock(q);\n\n\t\t\t \n\t\t\tretval = wait_event_interruptible(q->wait,\n\t\t\t\t!list_empty(&q->stream) || !q->streaming);\n\t\t\tvideobuf_queue_lock(q);\n\n\t\t\tif (retval)\n\t\t\t\tgoto done;\n\n\t\t\tgoto checks;\n\t\t}\n\t}\n\n\tretval = 0;\n\ndone:\n\treturn retval;\n}\n\n \nstatic int stream_next_buffer(struct videobuf_queue *q,\n\t\t\tstruct videobuf_buffer **vb, int nonblocking)\n{\n\tint retval;\n\tstruct videobuf_buffer *buf = NULL;\n\n\tretval = stream_next_buffer_check_queue(q, nonblocking);\n\tif (retval)\n\t\tgoto done;\n\n\tbuf = list_entry(q->stream.next, struct videobuf_buffer, stream);\n\tretval = videobuf_waiton(q, buf, nonblocking, 1);\n\tif (retval < 0)\n\t\tgoto done;\n\n\t*vb = buf;\ndone:\n\treturn retval;\n}\n\nint videobuf_dqbuf(struct videobuf_queue *q,\n\t\t   struct v4l2_buffer *b, int nonblocking)\n{\n\tstruct videobuf_buffer *buf = NULL;\n\tint retval;\n\n\tMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\n\n\tmemset(b, 0, sizeof(*b));\n\tvideobuf_queue_lock(q);\n\n\tretval = stream_next_buffer(q, &buf, nonblocking);\n\tif (retval < 0) {\n\t\tdprintk(1, \"dqbuf: next_buffer error: %i\\n\", retval);\n\t\tgoto done;\n\t}\n\n\tswitch (buf->state) {\n\tcase VIDEOBUF_ERROR:\n\t\tdprintk(1, \"dqbuf: state is error\\n\");\n\t\tbreak;\n\tcase VIDEOBUF_DONE:\n\t\tdprintk(1, \"dqbuf: state is done\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdprintk(1, \"dqbuf: state invalid\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto done;\n\t}\n\tCALL(q, sync, q, buf);\n\tvideobuf_status(q, b, buf, q->type);\n\tlist_del(&buf->stream);\n\tbuf->state = VIDEOBUF_IDLE;\n\tb->flags &= ~V4L2_BUF_FLAG_DONE;\ndone:\n\tvideobuf_queue_unlock(q);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(videobuf_dqbuf);\n\nint videobuf_streamon(struct videobuf_queue *q)\n{\n\tstruct videobuf_buffer *buf;\n\tunsigned long flags = 0;\n\tint retval;\n\n\tvideobuf_queue_lock(q);\n\tretval = -EBUSY;\n\tif (q->reading)\n\t\tgoto done;\n\tretval = 0;\n\tif (q->streaming)\n\t\tgoto done;\n\tq->streaming = 1;\n\tspin_lock_irqsave(q->irqlock, flags);\n\tlist_for_each_entry(buf, &q->stream, stream)\n\t\tif (buf->state == VIDEOBUF_PREPARED)\n\t\t\tq->ops->buf_queue(q, buf);\n\tspin_unlock_irqrestore(q->irqlock, flags);\n\n\twake_up_interruptible_sync(&q->wait);\ndone:\n\tvideobuf_queue_unlock(q);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(videobuf_streamon);\n\n \nstatic int __videobuf_streamoff(struct videobuf_queue *q)\n{\n\tif (!q->streaming)\n\t\treturn -EINVAL;\n\n\tvideobuf_queue_cancel(q);\n\n\treturn 0;\n}\n\nint videobuf_streamoff(struct videobuf_queue *q)\n{\n\tint retval;\n\n\tvideobuf_queue_lock(q);\n\tretval = __videobuf_streamoff(q);\n\tvideobuf_queue_unlock(q);\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(videobuf_streamoff);\n\n \nstatic ssize_t videobuf_read_zerocopy(struct videobuf_queue *q,\n\t\t\t\t      char __user *data,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tenum v4l2_field field;\n\tunsigned long flags = 0;\n\tint retval;\n\n\tMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\n\n\t \n\tq->read_buf = videobuf_alloc_vb(q);\n\tif (NULL == q->read_buf)\n\t\treturn -ENOMEM;\n\n\tq->read_buf->memory = V4L2_MEMORY_USERPTR;\n\tq->read_buf->baddr  = (unsigned long)data;\n\tq->read_buf->bsize  = count;\n\n\tfield = videobuf_next_field(q);\n\tretval = q->ops->buf_prepare(q, q->read_buf, field);\n\tif (0 != retval)\n\t\tgoto done;\n\n\t \n\tspin_lock_irqsave(q->irqlock, flags);\n\tq->ops->buf_queue(q, q->read_buf);\n\tspin_unlock_irqrestore(q->irqlock, flags);\n\tretval = videobuf_waiton(q, q->read_buf, 0, 0);\n\tif (0 == retval) {\n\t\tCALL(q, sync, q, q->read_buf);\n\t\tif (VIDEOBUF_ERROR == q->read_buf->state)\n\t\t\tretval = -EIO;\n\t\telse\n\t\t\tretval = q->read_buf->size;\n\t}\n\ndone:\n\t \n\tq->ops->buf_release(q, q->read_buf);\n\tkfree(q->read_buf);\n\tq->read_buf = NULL;\n\treturn retval;\n}\n\nstatic int __videobuf_copy_to_user(struct videobuf_queue *q,\n\t\t\t\t   struct videobuf_buffer *buf,\n\t\t\t\t   char __user *data, size_t count,\n\t\t\t\t   int nonblocking)\n{\n\tvoid *vaddr = CALLPTR(q, vaddr, buf);\n\n\t \n\tif (count > buf->size - q->read_off)\n\t\tcount = buf->size - q->read_off;\n\n\tif (copy_to_user(data, vaddr + q->read_off, count))\n\t\treturn -EFAULT;\n\n\treturn count;\n}\n\nstatic int __videobuf_copy_stream(struct videobuf_queue *q,\n\t\t\t\t  struct videobuf_buffer *buf,\n\t\t\t\t  char __user *data, size_t count, size_t pos,\n\t\t\t\t  int vbihack, int nonblocking)\n{\n\tunsigned int *fc = CALLPTR(q, vaddr, buf);\n\n\tif (vbihack) {\n\t\t \n\t\tfc += (buf->size >> 2) - 1;\n\t\t*fc = buf->field_count >> 1;\n\t\tdprintk(1, \"vbihack: %d\\n\", *fc);\n\t}\n\n\t \n\tcount = __videobuf_copy_to_user(q, buf, data, count, nonblocking);\n\n\tif ((count == -EFAULT) && (pos == 0))\n\t\treturn -EFAULT;\n\n\treturn count;\n}\n\nssize_t videobuf_read_one(struct videobuf_queue *q,\n\t\t\t  char __user *data, size_t count, loff_t *ppos,\n\t\t\t  int nonblocking)\n{\n\tenum v4l2_field field;\n\tunsigned long flags = 0;\n\tunsigned size = 0, nbufs = 1;\n\tint retval;\n\n\tMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\n\n\tvideobuf_queue_lock(q);\n\n\tq->ops->buf_setup(q, &nbufs, &size);\n\n\tif (NULL == q->read_buf  &&\n\t    count >= size        &&\n\t    !nonblocking) {\n\t\tretval = videobuf_read_zerocopy(q, data, count, ppos);\n\t\tif (retval >= 0  ||  retval == -EIO)\n\t\t\t \n\t\t\tgoto done;\n\t\t \n\t}\n\n\tif (NULL == q->read_buf) {\n\t\t \n\t\tretval = -ENOMEM;\n\t\tq->read_buf = videobuf_alloc_vb(q);\n\n\t\tdprintk(1, \"video alloc=0x%p\\n\", q->read_buf);\n\t\tif (NULL == q->read_buf)\n\t\t\tgoto done;\n\t\tq->read_buf->memory = V4L2_MEMORY_USERPTR;\n\t\tq->read_buf->bsize = count;  \n\t\tfield = videobuf_next_field(q);\n\t\tretval = q->ops->buf_prepare(q, q->read_buf, field);\n\n\t\tif (0 != retval) {\n\t\t\tkfree(q->read_buf);\n\t\t\tq->read_buf = NULL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tspin_lock_irqsave(q->irqlock, flags);\n\t\tq->ops->buf_queue(q, q->read_buf);\n\t\tspin_unlock_irqrestore(q->irqlock, flags);\n\n\t\tq->read_off = 0;\n\t}\n\n\t \n\tretval = videobuf_waiton(q, q->read_buf, nonblocking, 1);\n\tif (0 != retval)\n\t\tgoto done;\n\n\tCALL(q, sync, q, q->read_buf);\n\n\tif (VIDEOBUF_ERROR == q->read_buf->state) {\n\t\t \n\t\tq->ops->buf_release(q, q->read_buf);\n\t\tkfree(q->read_buf);\n\t\tq->read_buf = NULL;\n\t\tretval = -EIO;\n\t\tgoto done;\n\t}\n\n\t \n\tretval = __videobuf_copy_to_user(q, q->read_buf, data, count, nonblocking);\n\tif (retval < 0)\n\t\tgoto done;\n\n\tq->read_off += retval;\n\tif (q->read_off == q->read_buf->size) {\n\t\t \n\t\tq->ops->buf_release(q, q->read_buf);\n\t\tkfree(q->read_buf);\n\t\tq->read_buf = NULL;\n\t}\n\ndone:\n\tvideobuf_queue_unlock(q);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(videobuf_read_one);\n\n \nstatic int __videobuf_read_start(struct videobuf_queue *q)\n{\n\tenum v4l2_field field;\n\tunsigned long flags = 0;\n\tunsigned int count = 0, size = 0;\n\tint err, i;\n\n\tq->ops->buf_setup(q, &count, &size);\n\tif (count < 2)\n\t\tcount = 2;\n\tif (count > VIDEO_MAX_FRAME)\n\t\tcount = VIDEO_MAX_FRAME;\n\tsize = PAGE_ALIGN(size);\n\n\terr = __videobuf_mmap_setup(q, count, size, V4L2_MEMORY_USERPTR);\n\tif (err < 0)\n\t\treturn err;\n\n\tcount = err;\n\n\tfor (i = 0; i < count; i++) {\n\t\tfield = videobuf_next_field(q);\n\t\terr = q->ops->buf_prepare(q, q->bufs[i], field);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlist_add_tail(&q->bufs[i]->stream, &q->stream);\n\t}\n\tspin_lock_irqsave(q->irqlock, flags);\n\tfor (i = 0; i < count; i++)\n\t\tq->ops->buf_queue(q, q->bufs[i]);\n\tspin_unlock_irqrestore(q->irqlock, flags);\n\tq->reading = 1;\n\treturn 0;\n}\n\nstatic void __videobuf_read_stop(struct videobuf_queue *q)\n{\n\tint i;\n\n\tvideobuf_queue_cancel(q);\n\t__videobuf_free(q);\n\tINIT_LIST_HEAD(&q->stream);\n\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\tif (NULL == q->bufs[i])\n\t\t\tcontinue;\n\t\tkfree(q->bufs[i]);\n\t\tq->bufs[i] = NULL;\n\t}\n\tq->read_buf = NULL;\n}\n\nint videobuf_read_start(struct videobuf_queue *q)\n{\n\tint rc;\n\n\tvideobuf_queue_lock(q);\n\trc = __videobuf_read_start(q);\n\tvideobuf_queue_unlock(q);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(videobuf_read_start);\n\nvoid videobuf_read_stop(struct videobuf_queue *q)\n{\n\tvideobuf_queue_lock(q);\n\t__videobuf_read_stop(q);\n\tvideobuf_queue_unlock(q);\n}\nEXPORT_SYMBOL_GPL(videobuf_read_stop);\n\nvoid videobuf_stop(struct videobuf_queue *q)\n{\n\tvideobuf_queue_lock(q);\n\n\tif (q->streaming)\n\t\t__videobuf_streamoff(q);\n\n\tif (q->reading)\n\t\t__videobuf_read_stop(q);\n\n\tvideobuf_queue_unlock(q);\n}\nEXPORT_SYMBOL_GPL(videobuf_stop);\n\nssize_t videobuf_read_stream(struct videobuf_queue *q,\n\t\t\t     char __user *data, size_t count, loff_t *ppos,\n\t\t\t     int vbihack, int nonblocking)\n{\n\tint rc, retval;\n\tunsigned long flags = 0;\n\n\tMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\n\n\tdprintk(2, \"%s\\n\", __func__);\n\tvideobuf_queue_lock(q);\n\tretval = -EBUSY;\n\tif (q->streaming)\n\t\tgoto done;\n\tif (!q->reading) {\n\t\tretval = __videobuf_read_start(q);\n\t\tif (retval < 0)\n\t\t\tgoto done;\n\t}\n\n\tretval = 0;\n\twhile (count > 0) {\n\t\t \n\t\tif (NULL == q->read_buf) {\n\t\t\tq->read_buf = list_entry(q->stream.next,\n\t\t\t\t\t\t struct videobuf_buffer,\n\t\t\t\t\t\t stream);\n\t\t\tlist_del(&q->read_buf->stream);\n\t\t\tq->read_off = 0;\n\t\t}\n\t\trc = videobuf_waiton(q, q->read_buf, nonblocking, 1);\n\t\tif (rc < 0) {\n\t\t\tif (0 == retval)\n\t\t\t\tretval = rc;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (q->read_buf->state == VIDEOBUF_DONE) {\n\t\t\trc = __videobuf_copy_stream(q, q->read_buf, data + retval, count,\n\t\t\t\t\tretval, vbihack, nonblocking);\n\t\t\tif (rc < 0) {\n\t\t\t\tretval = rc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretval      += rc;\n\t\t\tcount       -= rc;\n\t\t\tq->read_off += rc;\n\t\t} else {\n\t\t\t \n\t\t\tq->read_off = q->read_buf->size;\n\t\t\tif (0 == retval)\n\t\t\t\tretval = -EIO;\n\t\t}\n\n\t\t \n\t\tif (q->read_off == q->read_buf->size) {\n\t\t\tlist_add_tail(&q->read_buf->stream,\n\t\t\t\t      &q->stream);\n\t\t\tspin_lock_irqsave(q->irqlock, flags);\n\t\t\tq->ops->buf_queue(q, q->read_buf);\n\t\t\tspin_unlock_irqrestore(q->irqlock, flags);\n\t\t\tq->read_buf = NULL;\n\t\t}\n\t\tif (retval < 0)\n\t\t\tbreak;\n\t}\n\ndone:\n\tvideobuf_queue_unlock(q);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(videobuf_read_stream);\n\n__poll_t videobuf_poll_stream(struct file *file,\n\t\t\t      struct videobuf_queue *q,\n\t\t\t      poll_table *wait)\n{\n\t__poll_t req_events = poll_requested_events(wait);\n\tstruct videobuf_buffer *buf = NULL;\n\t__poll_t rc = 0;\n\n\tvideobuf_queue_lock(q);\n\tif (q->streaming) {\n\t\tif (!list_empty(&q->stream))\n\t\t\tbuf = list_entry(q->stream.next,\n\t\t\t\t\t struct videobuf_buffer, stream);\n\t} else if (req_events & (EPOLLIN | EPOLLRDNORM)) {\n\t\tif (!q->reading)\n\t\t\t__videobuf_read_start(q);\n\t\tif (!q->reading) {\n\t\t\trc = EPOLLERR;\n\t\t} else if (NULL == q->read_buf) {\n\t\t\tq->read_buf = list_entry(q->stream.next,\n\t\t\t\t\t\t struct videobuf_buffer,\n\t\t\t\t\t\t stream);\n\t\t\tlist_del(&q->read_buf->stream);\n\t\t\tq->read_off = 0;\n\t\t}\n\t\tbuf = q->read_buf;\n\t}\n\tif (buf)\n\t\tpoll_wait(file, &buf->done, wait);\n\telse\n\t\trc = EPOLLERR;\n\n\tif (0 == rc) {\n\t\tif (buf->state == VIDEOBUF_DONE ||\n\t\t    buf->state == VIDEOBUF_ERROR) {\n\t\t\tswitch (q->type) {\n\t\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\t\tcase V4L2_BUF_TYPE_VBI_OUTPUT:\n\t\t\tcase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\n\t\t\tcase V4L2_BUF_TYPE_SDR_OUTPUT:\n\t\t\t\trc = EPOLLOUT | EPOLLWRNORM;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\trc = EPOLLIN | EPOLLRDNORM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvideobuf_queue_unlock(q);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(videobuf_poll_stream);\n\nint videobuf_mmap_mapper(struct videobuf_queue *q, struct vm_area_struct *vma)\n{\n\tint rc = -EINVAL;\n\tint i;\n\n\tMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\n\n\tif (!(vma->vm_flags & VM_WRITE) || !(vma->vm_flags & VM_SHARED)) {\n\t\tdprintk(1, \"mmap appl bug: PROT_WRITE and MAP_SHARED are required\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvideobuf_queue_lock(q);\n\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\tstruct videobuf_buffer *buf = q->bufs[i];\n\n\t\tif (buf && buf->memory == V4L2_MEMORY_MMAP &&\n\t\t\t\tbuf->boff == (vma->vm_pgoff << PAGE_SHIFT)) {\n\t\t\trc = CALL(q, mmap_mapper, q, buf, vma);\n\t\t\tbreak;\n\t\t}\n\t}\n\tvideobuf_queue_unlock(q);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(videobuf_mmap_mapper);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}