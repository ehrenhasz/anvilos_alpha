{
  "module_name": "v4l2-ctrls-request.c",
  "hash_id": "a5d6150e7bb7c998ed431e9f5aeef1bc298d4ec59b0fce7b8b28d9d58914c841",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/v4l2-ctrls-request.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"v4l2-ctrls: \" fmt\n\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-ioctl.h>\n\n#include \"v4l2-ctrls-priv.h\"\n\n \nvoid v4l2_ctrl_handler_init_request(struct v4l2_ctrl_handler *hdl)\n{\n\tINIT_LIST_HEAD(&hdl->requests);\n\tINIT_LIST_HEAD(&hdl->requests_queued);\n\thdl->request_is_queued = false;\n\tmedia_request_object_init(&hdl->req_obj);\n}\n\n \nvoid v4l2_ctrl_handler_free_request(struct v4l2_ctrl_handler *hdl)\n{\n\tstruct v4l2_ctrl_handler *req, *next_req;\n\n\t \n\tif (hdl->req_obj.ops || list_empty(&hdl->requests))\n\t\treturn;\n\n\t \n\tlist_for_each_entry_safe(req, next_req, &hdl->requests, requests) {\n\t\tmedia_request_object_unbind(&req->req_obj);\n\t\tmedia_request_object_put(&req->req_obj);\n\t}\n}\n\nstatic int v4l2_ctrl_request_clone(struct v4l2_ctrl_handler *hdl,\n\t\t\t\t   const struct v4l2_ctrl_handler *from)\n{\n\tstruct v4l2_ctrl_ref *ref;\n\tint err = 0;\n\n\tif (WARN_ON(!hdl || hdl == from))\n\t\treturn -EINVAL;\n\n\tif (hdl->error)\n\t\treturn hdl->error;\n\n\tWARN_ON(hdl->lock != &hdl->_lock);\n\n\tmutex_lock(from->lock);\n\tlist_for_each_entry(ref, &from->ctrl_refs, node) {\n\t\tstruct v4l2_ctrl *ctrl = ref->ctrl;\n\t\tstruct v4l2_ctrl_ref *new_ref;\n\n\t\t \n\t\tif (ref->from_other_dev)\n\t\t\tcontinue;\n\t\terr = handler_new_ref(hdl, ctrl, &new_ref, false, true);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(from->lock);\n\treturn err;\n}\n\nstatic void v4l2_ctrl_request_queue(struct media_request_object *obj)\n{\n\tstruct v4l2_ctrl_handler *hdl =\n\t\tcontainer_of(obj, struct v4l2_ctrl_handler, req_obj);\n\tstruct v4l2_ctrl_handler *main_hdl = obj->priv;\n\n\tmutex_lock(main_hdl->lock);\n\tlist_add_tail(&hdl->requests_queued, &main_hdl->requests_queued);\n\thdl->request_is_queued = true;\n\tmutex_unlock(main_hdl->lock);\n}\n\nstatic void v4l2_ctrl_request_unbind(struct media_request_object *obj)\n{\n\tstruct v4l2_ctrl_handler *hdl =\n\t\tcontainer_of(obj, struct v4l2_ctrl_handler, req_obj);\n\tstruct v4l2_ctrl_handler *main_hdl = obj->priv;\n\n\tmutex_lock(main_hdl->lock);\n\tlist_del_init(&hdl->requests);\n\tif (hdl->request_is_queued) {\n\t\tlist_del_init(&hdl->requests_queued);\n\t\thdl->request_is_queued = false;\n\t}\n\tmutex_unlock(main_hdl->lock);\n}\n\nstatic void v4l2_ctrl_request_release(struct media_request_object *obj)\n{\n\tstruct v4l2_ctrl_handler *hdl =\n\t\tcontainer_of(obj, struct v4l2_ctrl_handler, req_obj);\n\n\tv4l2_ctrl_handler_free(hdl);\n\tkfree(hdl);\n}\n\nstatic const struct media_request_object_ops req_ops = {\n\t.queue = v4l2_ctrl_request_queue,\n\t.unbind = v4l2_ctrl_request_unbind,\n\t.release = v4l2_ctrl_request_release,\n};\n\nstruct v4l2_ctrl_handler *v4l2_ctrl_request_hdl_find(struct media_request *req,\n\t\t\t\t\t\t     struct v4l2_ctrl_handler *parent)\n{\n\tstruct media_request_object *obj;\n\n\tif (WARN_ON(req->state != MEDIA_REQUEST_STATE_VALIDATING &&\n\t\t    req->state != MEDIA_REQUEST_STATE_QUEUED))\n\t\treturn NULL;\n\n\tobj = media_request_object_find(req, &req_ops, parent);\n\tif (obj)\n\t\treturn container_of(obj, struct v4l2_ctrl_handler, req_obj);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(v4l2_ctrl_request_hdl_find);\n\nstruct v4l2_ctrl *\nv4l2_ctrl_request_hdl_ctrl_find(struct v4l2_ctrl_handler *hdl, u32 id)\n{\n\tstruct v4l2_ctrl_ref *ref = find_ref_lock(hdl, id);\n\n\treturn (ref && ref->p_req_valid) ? ref->ctrl : NULL;\n}\nEXPORT_SYMBOL_GPL(v4l2_ctrl_request_hdl_ctrl_find);\n\nstatic int v4l2_ctrl_request_bind(struct media_request *req,\n\t\t\t\t  struct v4l2_ctrl_handler *hdl,\n\t\t\t\t  struct v4l2_ctrl_handler *from)\n{\n\tint ret;\n\n\tret = v4l2_ctrl_request_clone(hdl, from);\n\n\tif (!ret) {\n\t\tret = media_request_object_bind(req, &req_ops,\n\t\t\t\t\t\tfrom, false, &hdl->req_obj);\n\t\tif (!ret) {\n\t\t\tmutex_lock(from->lock);\n\t\t\tlist_add_tail(&hdl->requests, &from->requests);\n\t\t\tmutex_unlock(from->lock);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic struct media_request_object *\nv4l2_ctrls_find_req_obj(struct v4l2_ctrl_handler *hdl,\n\t\t\tstruct media_request *req, bool set)\n{\n\tstruct media_request_object *obj;\n\tstruct v4l2_ctrl_handler *new_hdl;\n\tint ret;\n\n\tif (IS_ERR(req))\n\t\treturn ERR_CAST(req);\n\n\tif (set && WARN_ON(req->state != MEDIA_REQUEST_STATE_UPDATING))\n\t\treturn ERR_PTR(-EBUSY);\n\n\tobj = media_request_object_find(req, &req_ops, hdl);\n\tif (obj)\n\t\treturn obj;\n\t \n\tif (!set)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew_hdl = kzalloc(sizeof(*new_hdl), GFP_KERNEL);\n\tif (!new_hdl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tobj = &new_hdl->req_obj;\n\tret = v4l2_ctrl_handler_init(new_hdl, (hdl->nr_of_buckets - 1) * 8);\n\tif (!ret)\n\t\tret = v4l2_ctrl_request_bind(req, new_hdl, hdl);\n\tif (ret) {\n\t\tv4l2_ctrl_handler_free(new_hdl);\n\t\tkfree(new_hdl);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tmedia_request_object_get(obj);\n\treturn obj;\n}\n\nint v4l2_g_ext_ctrls_request(struct v4l2_ctrl_handler *hdl, struct video_device *vdev,\n\t\t\t     struct media_device *mdev, struct v4l2_ext_controls *cs)\n{\n\tstruct media_request_object *obj = NULL;\n\tstruct media_request *req = NULL;\n\tint ret;\n\n\tif (!mdev || cs->request_fd < 0)\n\t\treturn -EINVAL;\n\n\treq = media_request_get_by_fd(mdev, cs->request_fd);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tif (req->state != MEDIA_REQUEST_STATE_COMPLETE) {\n\t\tmedia_request_put(req);\n\t\treturn -EACCES;\n\t}\n\n\tret = media_request_lock_for_access(req);\n\tif (ret) {\n\t\tmedia_request_put(req);\n\t\treturn ret;\n\t}\n\n\tobj = v4l2_ctrls_find_req_obj(hdl, req, false);\n\tif (IS_ERR(obj)) {\n\t\tmedia_request_unlock_for_access(req);\n\t\tmedia_request_put(req);\n\t\treturn PTR_ERR(obj);\n\t}\n\n\thdl = container_of(obj, struct v4l2_ctrl_handler,\n\t\t\t   req_obj);\n\tret = v4l2_g_ext_ctrls_common(hdl, cs, vdev);\n\n\tmedia_request_unlock_for_access(req);\n\tmedia_request_object_put(obj);\n\tmedia_request_put(req);\n\treturn ret;\n}\n\nint try_set_ext_ctrls_request(struct v4l2_fh *fh,\n\t\t\t      struct v4l2_ctrl_handler *hdl,\n\t\t\t      struct video_device *vdev,\n\t\t\t      struct media_device *mdev,\n\t\t\t      struct v4l2_ext_controls *cs, bool set)\n{\n\tstruct media_request_object *obj = NULL;\n\tstruct media_request *req = NULL;\n\tint ret;\n\n\tif (!mdev) {\n\t\tdprintk(vdev, \"%s: missing media device\\n\",\n\t\t\tvideo_device_node_name(vdev));\n\t\treturn -EINVAL;\n\t}\n\n\tif (cs->request_fd < 0) {\n\t\tdprintk(vdev, \"%s: invalid request fd %d\\n\",\n\t\t\tvideo_device_node_name(vdev), cs->request_fd);\n\t\treturn -EINVAL;\n\t}\n\n\treq = media_request_get_by_fd(mdev, cs->request_fd);\n\tif (IS_ERR(req)) {\n\t\tdprintk(vdev, \"%s: cannot find request fd %d\\n\",\n\t\t\tvideo_device_node_name(vdev), cs->request_fd);\n\t\treturn PTR_ERR(req);\n\t}\n\n\tret = media_request_lock_for_update(req);\n\tif (ret) {\n\t\tdprintk(vdev, \"%s: cannot lock request fd %d\\n\",\n\t\t\tvideo_device_node_name(vdev), cs->request_fd);\n\t\tmedia_request_put(req);\n\t\treturn ret;\n\t}\n\n\tobj = v4l2_ctrls_find_req_obj(hdl, req, set);\n\tif (IS_ERR(obj)) {\n\t\tdprintk(vdev,\n\t\t\t\"%s: cannot find request object for request fd %d\\n\",\n\t\t\tvideo_device_node_name(vdev),\n\t\t\tcs->request_fd);\n\t\tmedia_request_unlock_for_update(req);\n\t\tmedia_request_put(req);\n\t\treturn PTR_ERR(obj);\n\t}\n\n\thdl = container_of(obj, struct v4l2_ctrl_handler,\n\t\t\t   req_obj);\n\tret = try_set_ext_ctrls_common(fh, hdl, cs, vdev, set);\n\tif (ret)\n\t\tdprintk(vdev,\n\t\t\t\"%s: try_set_ext_ctrls_common failed (%d)\\n\",\n\t\t\tvideo_device_node_name(vdev), ret);\n\n\tmedia_request_unlock_for_update(req);\n\tmedia_request_object_put(obj);\n\tmedia_request_put(req);\n\n\treturn ret;\n}\n\nvoid v4l2_ctrl_request_complete(struct media_request *req,\n\t\t\t\tstruct v4l2_ctrl_handler *main_hdl)\n{\n\tstruct media_request_object *obj;\n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct v4l2_ctrl_ref *ref;\n\n\tif (!req || !main_hdl)\n\t\treturn;\n\n\t \n\tobj = media_request_object_find(req, &req_ops, main_hdl);\n\tif (!obj) {\n\t\tint ret;\n\n\t\t \n\t\thdl = kzalloc(sizeof(*hdl), GFP_KERNEL);\n\t\tif (!hdl)\n\t\t\treturn;\n\n\t\tret = v4l2_ctrl_handler_init(hdl, (main_hdl->nr_of_buckets - 1) * 8);\n\t\tif (!ret)\n\t\t\tret = v4l2_ctrl_request_bind(req, hdl, main_hdl);\n\t\tif (ret) {\n\t\t\tv4l2_ctrl_handler_free(hdl);\n\t\t\tkfree(hdl);\n\t\t\treturn;\n\t\t}\n\t\thdl->request_is_queued = true;\n\t\tobj = media_request_object_find(req, &req_ops, main_hdl);\n\t}\n\thdl = container_of(obj, struct v4l2_ctrl_handler, req_obj);\n\n\tlist_for_each_entry(ref, &hdl->ctrl_refs, node) {\n\t\tstruct v4l2_ctrl *ctrl = ref->ctrl;\n\t\tstruct v4l2_ctrl *master = ctrl->cluster[0];\n\t\tunsigned int i;\n\n\t\tif (ctrl->flags & V4L2_CTRL_FLAG_VOLATILE) {\n\t\t\tv4l2_ctrl_lock(master);\n\t\t\t \n\t\t\tfor (i = 0; i < master->ncontrols; i++)\n\t\t\t\tcur_to_new(master->cluster[i]);\n\t\t\tcall_op(master, g_volatile_ctrl);\n\t\t\tnew_to_req(ref);\n\t\t\tv4l2_ctrl_unlock(master);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ref->p_req_valid)\n\t\t\tcontinue;\n\n\t\t \n\t\tv4l2_ctrl_lock(ctrl);\n\t\tcur_to_req(ref);\n\t\tv4l2_ctrl_unlock(ctrl);\n\t}\n\n\tmutex_lock(main_hdl->lock);\n\tWARN_ON(!hdl->request_is_queued);\n\tlist_del_init(&hdl->requests_queued);\n\thdl->request_is_queued = false;\n\tmutex_unlock(main_hdl->lock);\n\tmedia_request_object_complete(obj);\n\tmedia_request_object_put(obj);\n}\nEXPORT_SYMBOL(v4l2_ctrl_request_complete);\n\nint v4l2_ctrl_request_setup(struct media_request *req,\n\t\t\t    struct v4l2_ctrl_handler *main_hdl)\n{\n\tstruct media_request_object *obj;\n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct v4l2_ctrl_ref *ref;\n\tint ret = 0;\n\n\tif (!req || !main_hdl)\n\t\treturn 0;\n\n\tif (WARN_ON(req->state != MEDIA_REQUEST_STATE_QUEUED))\n\t\treturn -EBUSY;\n\n\t \n\tobj = media_request_object_find(req, &req_ops, main_hdl);\n\tif (!obj)\n\t\treturn 0;\n\tif (obj->completed) {\n\t\tmedia_request_object_put(obj);\n\t\treturn -EBUSY;\n\t}\n\thdl = container_of(obj, struct v4l2_ctrl_handler, req_obj);\n\n\tlist_for_each_entry(ref, &hdl->ctrl_refs, node)\n\t\tref->req_done = false;\n\n\tlist_for_each_entry(ref, &hdl->ctrl_refs, node) {\n\t\tstruct v4l2_ctrl *ctrl = ref->ctrl;\n\t\tstruct v4l2_ctrl *master = ctrl->cluster[0];\n\t\tbool have_new_data = false;\n\t\tint i;\n\n\t\t \n\t\tif (ref->req_done || (ctrl->flags & V4L2_CTRL_FLAG_READ_ONLY))\n\t\t\tcontinue;\n\n\t\tv4l2_ctrl_lock(master);\n\t\tfor (i = 0; i < master->ncontrols; i++) {\n\t\t\tif (master->cluster[i]) {\n\t\t\t\tstruct v4l2_ctrl_ref *r =\n\t\t\t\t\tfind_ref(hdl, master->cluster[i]->id);\n\n\t\t\t\tif (r->p_req_valid) {\n\t\t\t\t\thave_new_data = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!have_new_data) {\n\t\t\tv4l2_ctrl_unlock(master);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < master->ncontrols; i++) {\n\t\t\tif (master->cluster[i]) {\n\t\t\t\tstruct v4l2_ctrl_ref *r =\n\t\t\t\t\tfind_ref(hdl, master->cluster[i]->id);\n\n\t\t\t\tret = req_to_new(r);\n\t\t\t\tif (ret) {\n\t\t\t\t\tv4l2_ctrl_unlock(master);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tmaster->cluster[i]->is_new = 1;\n\t\t\t\tr->req_done = true;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (master->is_auto && master->has_volatiles &&\n\t\t    !is_cur_manual(master)) {\n\t\t\ts32 new_auto_val = *master->p_new.p_s32;\n\n\t\t\t \n\t\t\tif (new_auto_val == master->manual_mode_value)\n\t\t\t\tupdate_from_auto_cluster(master);\n\t\t}\n\n\t\tret = try_or_set_cluster(NULL, master, true, 0);\n\t\tv4l2_ctrl_unlock(master);\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\nerror:\n\tmedia_request_object_put(obj);\n\treturn ret;\n}\nEXPORT_SYMBOL(v4l2_ctrl_request_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}