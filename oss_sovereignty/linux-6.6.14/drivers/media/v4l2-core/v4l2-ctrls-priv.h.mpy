{
  "module_name": "v4l2-ctrls-priv.h",
  "hash_id": "cdbd162e92001550b310d65da36906da726373eda4e6a230e08636f4b4210f6b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/v4l2-ctrls-priv.h",
  "human_readable_source": " \n \n\n#ifndef _V4L2_CTRLS_PRIV_H_\n#define _V4L2_CTRLS_PRIV_H_\n\n#define dprintk(vdev, fmt, arg...) do {\t\t\t\t\t\\\n\tif (!WARN_ON(!(vdev)) && ((vdev)->dev_debug & V4L2_DEV_DEBUG_CTRL)) \\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: %s: \" fmt),\t\t\\\n\t\t       __func__, video_device_node_name(vdev), ##arg);\t\\\n} while (0)\n\n#define has_op(master, op) \\\n\t((master)->ops && (master)->ops->op)\n#define call_op(master, op) \\\n\t(has_op(master, op) ? (master)->ops->op(master) : 0)\n\nstatic inline u32 node2id(struct list_head *node)\n{\n\treturn list_entry(node, struct v4l2_ctrl_ref, node)->ctrl->id;\n}\n\n \nstatic inline bool is_cur_manual(const struct v4l2_ctrl *master)\n{\n\treturn master->is_auto && master->cur.val == master->manual_mode_value;\n}\n\n \nstatic inline bool is_new_manual(const struct v4l2_ctrl *master)\n{\n\treturn master->is_auto && master->val == master->manual_mode_value;\n}\n\nstatic inline u32 user_flags(const struct v4l2_ctrl *ctrl)\n{\n\tu32 flags = ctrl->flags;\n\n\tif (ctrl->is_ptr)\n\t\tflags |= V4L2_CTRL_FLAG_HAS_PAYLOAD;\n\n\treturn flags;\n}\n\n \nvoid cur_to_new(struct v4l2_ctrl *ctrl);\nvoid cur_to_req(struct v4l2_ctrl_ref *ref);\nvoid new_to_cur(struct v4l2_fh *fh, struct v4l2_ctrl *ctrl, u32 ch_flags);\nvoid new_to_req(struct v4l2_ctrl_ref *ref);\nint req_to_new(struct v4l2_ctrl_ref *ref);\nvoid send_initial_event(struct v4l2_fh *fh, struct v4l2_ctrl *ctrl);\nvoid send_event(struct v4l2_fh *fh, struct v4l2_ctrl *ctrl, u32 changes);\nint handler_new_ref(struct v4l2_ctrl_handler *hdl,\n\t\t    struct v4l2_ctrl *ctrl,\n\t\t    struct v4l2_ctrl_ref **ctrl_ref,\n\t\t    bool from_other_dev, bool allocate_req);\nstruct v4l2_ctrl_ref *find_ref(struct v4l2_ctrl_handler *hdl, u32 id);\nstruct v4l2_ctrl_ref *find_ref_lock(struct v4l2_ctrl_handler *hdl, u32 id);\nint check_range(enum v4l2_ctrl_type type,\n\t\ts64 min, s64 max, u64 step, s64 def);\nvoid update_from_auto_cluster(struct v4l2_ctrl *master);\nint try_or_set_cluster(struct v4l2_fh *fh, struct v4l2_ctrl *master,\n\t\t       bool set, u32 ch_flags);\n\n \nint v4l2_g_ext_ctrls_common(struct v4l2_ctrl_handler *hdl,\n\t\t\t    struct v4l2_ext_controls *cs,\n\t\t\t    struct video_device *vdev);\nint try_set_ext_ctrls_common(struct v4l2_fh *fh,\n\t\t\t     struct v4l2_ctrl_handler *hdl,\n\t\t\t     struct v4l2_ext_controls *cs,\n\t\t\t     struct video_device *vdev, bool set);\n\n \nvoid v4l2_ctrl_handler_init_request(struct v4l2_ctrl_handler *hdl);\nvoid v4l2_ctrl_handler_free_request(struct v4l2_ctrl_handler *hdl);\nint v4l2_g_ext_ctrls_request(struct v4l2_ctrl_handler *hdl, struct video_device *vdev,\n\t\t\t     struct media_device *mdev, struct v4l2_ext_controls *cs);\nint try_set_ext_ctrls_request(struct v4l2_fh *fh,\n\t\t\t      struct v4l2_ctrl_handler *hdl,\n\t\t\t      struct video_device *vdev,\n\t\t\t      struct media_device *mdev,\n\t\t\t      struct v4l2_ext_controls *cs, bool set);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}