{
  "module_name": "tuner-core.c",
  "hash_id": "94faf0e8c2304f98679c28072987c59cc8a3e5370df6a74c989a97707a7afd03",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/tuner-core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/i2c.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/videodev2.h>\n#include <media/tuner.h>\n#include <media/tuner-types.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include \"mt20xx.h\"\n#include \"tda8290.h\"\n#include \"tea5761.h\"\n#include \"tea5767.h\"\n#include \"xc2028.h\"\n#include \"tuner-simple.h\"\n#include \"tda9887.h\"\n#include \"xc5000.h\"\n#include \"tda18271.h\"\n#include \"xc4000.h\"\n\n#define UNSET (-1U)\n\n \n\n \nstatic unsigned int addr;\nstatic unsigned int no_autodetect;\nstatic unsigned int show_i2c;\n\nmodule_param(addr, int, 0444);\nmodule_param(no_autodetect, int, 0444);\nmodule_param(show_i2c, int, 0444);\n\n \nstatic int tuner_debug;\nstatic unsigned int tv_range[2] = { 44, 958 };\nstatic unsigned int radio_range[2] = { 65, 108 };\nstatic char pal[] = \"--\";\nstatic char secam[] = \"--\";\nstatic char ntsc[] = \"-\";\n\nmodule_param_named(debug, tuner_debug, int, 0644);\nmodule_param_array(tv_range, int, NULL, 0644);\nmodule_param_array(radio_range, int, NULL, 0644);\nmodule_param_string(pal, pal, sizeof(pal), 0644);\nmodule_param_string(secam, secam, sizeof(secam), 0644);\nmodule_param_string(ntsc, ntsc, sizeof(ntsc), 0644);\n\n \n\nstatic LIST_HEAD(tuner_list);\nstatic const struct v4l2_subdev_ops tuner_ops;\n\n \n\n#undef pr_fmt\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": %d-%04x: \" fmt,\t\t\\\n\ti2c_adapter_id(t->i2c->adapter), t->i2c->addr\n\n\n#define dprintk(fmt, arg...) do {\t\t\t\t\t\\\n\tif (tuner_debug)\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt), __func__, ##arg);\t\\\n} while (0)\n\n \n\n \nenum tuner_pad_index {\n\tTUNER_PAD_RF_INPUT,\n\tTUNER_PAD_OUTPUT,\n\tTUNER_PAD_AUD_OUT,\n\tTUNER_NUM_PADS\n};\n\n \nenum if_vid_dec_pad_index {\n\tIF_VID_DEC_PAD_IF_INPUT,\n\tIF_VID_DEC_PAD_OUT,\n\tIF_VID_DEC_PAD_NUM_PADS\n};\n\nstruct tuner {\n\t \n\tstruct dvb_frontend fe;\n\tstruct i2c_client   *i2c;\n\tstruct v4l2_subdev  sd;\n\tstruct list_head    list;\n\n\t \n\tv4l2_std_id         std;\n\tunsigned int        tv_freq;\n\tunsigned int        radio_freq;\n\tunsigned int        audmode;\n\n\tenum v4l2_tuner_type mode;\n\tunsigned int        mode_mask;  \n\n\tbool                standby;\t \n\n\tunsigned int        type;  \n\tvoid                *config;\n\tconst char          *name;\n\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tstruct media_pad\tpad[TUNER_NUM_PADS];\n#endif\n};\n\n \n\nstatic void set_tv_freq(struct i2c_client *c, unsigned int freq);\nstatic void set_radio_freq(struct i2c_client *c, unsigned int freq);\n\n \n\n \n#ifdef CONFIG_MEDIA_ATTACH\n#define tuner_symbol_probe(FUNCTION, ARGS...) ({ \\\n\tint __r = -EINVAL; \\\n\ttypeof(&FUNCTION) __a = symbol_request(FUNCTION); \\\n\tif (__a) { \\\n\t\t__r = (int) __a(ARGS); \\\n\t\tsymbol_put(FUNCTION); \\\n\t} else { \\\n\t\tprintk(KERN_ERR \"TUNER: Unable to find \" \\\n\t\t\t\t\"symbol \"#FUNCTION\"()\\n\"); \\\n\t} \\\n\t__r; \\\n})\n\nstatic void tuner_detach(struct dvb_frontend *fe)\n{\n\tif (fe->ops.tuner_ops.release) {\n\t\tfe->ops.tuner_ops.release(fe);\n\t\tsymbol_put_addr(fe->ops.tuner_ops.release);\n\t}\n\tif (fe->ops.analog_ops.release) {\n\t\tfe->ops.analog_ops.release(fe);\n\t\tsymbol_put_addr(fe->ops.analog_ops.release);\n\t}\n}\n#else\n#define tuner_symbol_probe(FUNCTION, ARGS...) ({ \\\n\tFUNCTION(ARGS); \\\n})\n\nstatic void tuner_detach(struct dvb_frontend *fe)\n{\n\tif (fe->ops.tuner_ops.release)\n\t\tfe->ops.tuner_ops.release(fe);\n\tif (fe->ops.analog_ops.release)\n\t\tfe->ops.analog_ops.release(fe);\n}\n#endif\n\n\nstatic inline struct tuner *to_tuner(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct tuner, sd);\n}\n\n \n\nstatic void fe_set_params(struct dvb_frontend *fe,\n\t\t\t  struct analog_parameters *params)\n{\n\tstruct dvb_tuner_ops *fe_tuner_ops = &fe->ops.tuner_ops;\n\tstruct tuner *t = fe->analog_demod_priv;\n\n\tif (NULL == fe_tuner_ops->set_analog_params) {\n\t\tpr_warn(\"Tuner frontend module has no way to set freq\\n\");\n\t\treturn;\n\t}\n\tfe_tuner_ops->set_analog_params(fe, params);\n}\n\nstatic void fe_standby(struct dvb_frontend *fe)\n{\n\tstruct dvb_tuner_ops *fe_tuner_ops = &fe->ops.tuner_ops;\n\n\tif (fe_tuner_ops->sleep)\n\t\tfe_tuner_ops->sleep(fe);\n}\n\nstatic int fe_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct dvb_tuner_ops *fe_tuner_ops = &fe->ops.tuner_ops;\n\tstruct tuner *t = fe->analog_demod_priv;\n\n\tif (fe_tuner_ops->set_config)\n\t\treturn fe_tuner_ops->set_config(fe, priv_cfg);\n\n\tpr_warn(\"Tuner frontend module has no way to set config\\n\");\n\n\treturn 0;\n}\n\nstatic void tuner_status(struct dvb_frontend *fe);\n\nstatic const struct analog_demod_ops tuner_analog_ops = {\n\t.set_params     = fe_set_params,\n\t.standby        = fe_standby,\n\t.set_config     = fe_set_config,\n\t.tuner_status   = tuner_status\n};\n\n \n\n \nstatic void set_type(struct i2c_client *c, unsigned int type,\n\t\t     unsigned int new_mode_mask, void *new_config,\n\t\t     int (*tuner_callback) (void *dev, int component, int cmd, int arg))\n{\n\tstruct tuner *t = to_tuner(i2c_get_clientdata(c));\n\tstruct dvb_tuner_ops *fe_tuner_ops = &t->fe.ops.tuner_ops;\n\tstruct analog_demod_ops *analog_ops = &t->fe.ops.analog_ops;\n\tunsigned char buffer[4];\n\tint tune_now = 1;\n\n\tif (type == UNSET || type == TUNER_ABSENT) {\n\t\tdprintk(\"tuner 0x%02x: Tuner type absent\\n\", c->addr);\n\t\treturn;\n\t}\n\n\tt->type = type;\n\tt->config = new_config;\n\tif (tuner_callback != NULL) {\n\t\tdprintk(\"defining GPIO callback\\n\");\n\t\tt->fe.callback = tuner_callback;\n\t}\n\n\t \n\ttuner_detach(&t->fe);\n\tt->fe.analog_demod_priv = NULL;\n\n\tswitch (t->type) {\n\tcase TUNER_MT2032:\n\t\tif (!dvb_attach(microtune_attach,\n\t\t\t   &t->fe, t->i2c->adapter, t->i2c->addr))\n\t\t\tgoto attach_failed;\n\t\tbreak;\n\tcase TUNER_PHILIPS_TDA8290:\n\t{\n\t\tif (!dvb_attach(tda829x_attach, &t->fe, t->i2c->adapter,\n\t\t\t\tt->i2c->addr, t->config))\n\t\t\tgoto attach_failed;\n\t\tbreak;\n\t}\n\tcase TUNER_TEA5767:\n\t\tif (!dvb_attach(tea5767_attach, &t->fe,\n\t\t\t\tt->i2c->adapter, t->i2c->addr))\n\t\t\tgoto attach_failed;\n\t\tt->mode_mask = T_RADIO;\n\t\tbreak;\n\tcase TUNER_TEA5761:\n\t\tif (!dvb_attach(tea5761_attach, &t->fe,\n\t\t\t\tt->i2c->adapter, t->i2c->addr))\n\t\t\tgoto attach_failed;\n\t\tt->mode_mask = T_RADIO;\n\t\tbreak;\n\tcase TUNER_PHILIPS_FMD1216ME_MK3:\n\tcase TUNER_PHILIPS_FMD1216MEX_MK3:\n\t\tbuffer[0] = 0x0b;\n\t\tbuffer[1] = 0xdc;\n\t\tbuffer[2] = 0x9c;\n\t\tbuffer[3] = 0x60;\n\t\ti2c_master_send(c, buffer, 4);\n\t\tmdelay(1);\n\t\tbuffer[2] = 0x86;\n\t\tbuffer[3] = 0x54;\n\t\ti2c_master_send(c, buffer, 4);\n\t\tif (!dvb_attach(simple_tuner_attach, &t->fe,\n\t\t\t\tt->i2c->adapter, t->i2c->addr, t->type))\n\t\t\tgoto attach_failed;\n\t\tbreak;\n\tcase TUNER_PHILIPS_TD1316:\n\t\tbuffer[0] = 0x0b;\n\t\tbuffer[1] = 0xdc;\n\t\tbuffer[2] = 0x86;\n\t\tbuffer[3] = 0xa4;\n\t\ti2c_master_send(c, buffer, 4);\n\t\tif (!dvb_attach(simple_tuner_attach, &t->fe,\n\t\t\t\tt->i2c->adapter, t->i2c->addr, t->type))\n\t\t\tgoto attach_failed;\n\t\tbreak;\n\tcase TUNER_XC2028:\n\t{\n\t\tstruct xc2028_config cfg = {\n\t\t\t.i2c_adap  = t->i2c->adapter,\n\t\t\t.i2c_addr  = t->i2c->addr,\n\t\t};\n\t\tif (!dvb_attach(xc2028_attach, &t->fe, &cfg))\n\t\t\tgoto attach_failed;\n\t\ttune_now = 0;\n\t\tbreak;\n\t}\n\tcase TUNER_TDA9887:\n\t\tif (!dvb_attach(tda9887_attach,\n\t\t\t   &t->fe, t->i2c->adapter, t->i2c->addr))\n\t\t\tgoto attach_failed;\n\t\tbreak;\n\tcase TUNER_XC5000:\n\t{\n\t\tstruct xc5000_config xc5000_cfg = {\n\t\t\t.i2c_address = t->i2c->addr,\n\t\t\t \n\t\t\t.if_khz\t  = 0,\n\t\t};\n\n\t\tif (!dvb_attach(xc5000_attach,\n\t\t\t\t&t->fe, t->i2c->adapter, &xc5000_cfg))\n\t\t\tgoto attach_failed;\n\t\ttune_now = 0;\n\t\tbreak;\n\t}\n\tcase TUNER_XC5000C:\n\t{\n\t\tstruct xc5000_config xc5000c_cfg = {\n\t\t\t.i2c_address = t->i2c->addr,\n\t\t\t \n\t\t\t.if_khz\t  = 0,\n\t\t\t.chip_id  = XC5000C,\n\t\t};\n\n\t\tif (!dvb_attach(xc5000_attach,\n\t\t\t\t&t->fe, t->i2c->adapter, &xc5000c_cfg))\n\t\t\tgoto attach_failed;\n\t\ttune_now = 0;\n\t\tbreak;\n\t}\n\tcase TUNER_NXP_TDA18271:\n\t{\n\t\tstruct tda18271_config cfg = {\n\t\t\t.small_i2c = TDA18271_03_BYTE_CHUNK_INIT,\n\t\t};\n\n\t\tif (!dvb_attach(tda18271_attach, &t->fe, t->i2c->addr,\n\t\t\t\tt->i2c->adapter, &cfg))\n\t\t\tgoto attach_failed;\n\t\ttune_now = 0;\n\t\tbreak;\n\t}\n\tcase TUNER_XC4000:\n\t{\n\t\tstruct xc4000_config xc4000_cfg = {\n\t\t\t.i2c_address\t  = t->i2c->addr,\n\t\t\t \n\t\t\t \n\t\t\t.default_pm\t  = 0,\n\t\t\t.dvb_amplitude\t  = 0,\n\t\t\t.set_smoothedcvbs = 0,\n\t\t\t.if_khz\t\t  = 0\n\t\t};\n\t\tif (!dvb_attach(xc4000_attach,\n\t\t\t\t&t->fe, t->i2c->adapter, &xc4000_cfg))\n\t\t\tgoto attach_failed;\n\t\ttune_now = 0;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tif (!dvb_attach(simple_tuner_attach, &t->fe,\n\t\t\t\tt->i2c->adapter, t->i2c->addr, t->type))\n\t\t\tgoto attach_failed;\n\n\t\tbreak;\n\t}\n\n\tif ((NULL == analog_ops->set_params) &&\n\t    (fe_tuner_ops->set_analog_params)) {\n\n\t\tt->name = fe_tuner_ops->info.name;\n\n\t\tt->fe.analog_demod_priv = t;\n\t\tmemcpy(analog_ops, &tuner_analog_ops,\n\t\t       sizeof(struct analog_demod_ops));\n\n\t\tif (fe_tuner_ops->get_rf_strength)\n\t\t\tanalog_ops->has_signal = fe_tuner_ops->get_rf_strength;\n\t\tif (fe_tuner_ops->get_afc)\n\t\t\tanalog_ops->get_afc = fe_tuner_ops->get_afc;\n\n\t} else {\n\t\tt->name = analog_ops->info.name;\n\t}\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tt->sd.entity.name = t->name;\n#endif\n\n\tdprintk(\"type set to %s\\n\", t->name);\n\n\tt->mode_mask = new_mode_mask;\n\n\t \n\tif (tune_now) {\n\t\tif (V4L2_TUNER_RADIO == t->mode)\n\t\t\tset_radio_freq(c, t->radio_freq);\n\t\telse\n\t\t\tset_tv_freq(c, t->tv_freq);\n\t}\n\n\tdprintk(\"%s %s I2C addr 0x%02x with type %d used for 0x%02x\\n\",\n\t\t  c->adapter->name, c->dev.driver->name, c->addr << 1, type,\n\t\t  t->mode_mask);\n\treturn;\n\nattach_failed:\n\tdprintk(\"Tuner attach for type = %d failed.\\n\", t->type);\n\tt->type = TUNER_ABSENT;\n\n\treturn;\n}\n\n \nstatic int tuner_s_type_addr(struct v4l2_subdev *sd,\n\t\t\t     struct tuner_setup *tun_setup)\n{\n\tstruct tuner *t = to_tuner(sd);\n\tstruct i2c_client *c = v4l2_get_subdevdata(sd);\n\n\tdprintk(\"Calling set_type_addr for type=%d, addr=0x%02x, mode=0x%02x, config=%p\\n\",\n\t\t\ttun_setup->type,\n\t\t\ttun_setup->addr,\n\t\t\ttun_setup->mode_mask,\n\t\t\ttun_setup->config);\n\n\tif ((t->type == UNSET && ((tun_setup->addr == ADDR_UNSET) &&\n\t    (t->mode_mask & tun_setup->mode_mask))) ||\n\t    (tun_setup->addr == c->addr)) {\n\t\tset_type(c, tun_setup->type, tun_setup->mode_mask,\n\t\t\t tun_setup->config, tun_setup->tuner_callback);\n\t} else\n\t\tdprintk(\"set addr discarded for type %i, mask %x. Asked to change tuner at addr 0x%02x, with mask %x\\n\",\n\t\t\t  t->type, t->mode_mask,\n\t\t\t  tun_setup->addr, tun_setup->mode_mask);\n\n\treturn 0;\n}\n\n \nstatic int tuner_s_config(struct v4l2_subdev *sd,\n\t\t\t  const struct v4l2_priv_tun_config *cfg)\n{\n\tstruct tuner *t = to_tuner(sd);\n\tstruct analog_demod_ops *analog_ops = &t->fe.ops.analog_ops;\n\n\tif (t->type != cfg->tuner)\n\t\treturn 0;\n\n\tif (analog_ops->set_config) {\n\t\tanalog_ops->set_config(&t->fe, cfg->priv);\n\t\treturn 0;\n\t}\n\n\tdprintk(\"Tuner frontend module has no way to set config\\n\");\n\treturn 0;\n}\n\n \nstatic void tuner_lookup(struct i2c_adapter *adap,\n\t\tstruct tuner **radio, struct tuner **tv)\n{\n\tstruct tuner *pos;\n\n\t*radio = NULL;\n\t*tv = NULL;\n\n\tlist_for_each_entry(pos, &tuner_list, list) {\n\t\tint mode_mask;\n\n\t\tif (pos->i2c->adapter != adap ||\n\t\t    strcmp(pos->i2c->dev.driver->name, \"tuner\"))\n\t\t\tcontinue;\n\n\t\tmode_mask = pos->mode_mask;\n\t\tif (*radio == NULL && mode_mask == T_RADIO)\n\t\t\t*radio = pos;\n\t\t \n\t\telse if (*tv == NULL && pos->type != TUNER_TDA9887 &&\n\t\t\t (pos->mode_mask & T_ANALOG_TV))\n\t\t\t*tv = pos;\n\t}\n}\n\n \nstatic int tuner_probe(struct i2c_client *client)\n{\n\tstruct tuner *t;\n\tstruct tuner *radio;\n\tstruct tuner *tv;\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tint ret;\n#endif\n\n\tt = kzalloc(sizeof(struct tuner), GFP_KERNEL);\n\tif (NULL == t)\n\t\treturn -ENOMEM;\n\tv4l2_i2c_subdev_init(&t->sd, client, &tuner_ops);\n\tt->i2c = client;\n\tt->name = \"(tuner unset)\";\n\tt->type = UNSET;\n\tt->audmode = V4L2_TUNER_MODE_STEREO;\n\tt->standby = true;\n\tt->radio_freq = 87.5 * 16000;\t \n\tt->tv_freq = 400 * 16;  \n\n\tif (show_i2c) {\n\t\tunsigned char buffer[16];\n\t\tint rc;\n\n\t\tmemset(buffer, 0, sizeof(buffer));\n\t\trc = i2c_master_recv(client, buffer, sizeof(buffer));\n\t\tif (rc >= 0)\n\t\t\tpr_info(\"I2C RECV = %*ph\\n\", rc, buffer);\n\t}\n\n\t \n\tif (!no_autodetect) {\n\t\tswitch (client->addr) {\n\t\tcase 0x10:\n\t\t\tif (tuner_symbol_probe(tea5761_autodetection,\n\t\t\t\t\t       t->i2c->adapter,\n\t\t\t\t\t       t->i2c->addr) >= 0) {\n\t\t\t\tt->type = TUNER_TEA5761;\n\t\t\t\tt->mode_mask = T_RADIO;\n\t\t\t\ttuner_lookup(t->i2c->adapter, &radio, &tv);\n\t\t\t\tif (tv)\n\t\t\t\t\ttv->mode_mask &= ~T_RADIO;\n\n\t\t\t\tgoto register_client;\n\t\t\t}\n\t\t\tkfree(t);\n\t\t\treturn -ENODEV;\n\t\tcase 0x42:\n\t\tcase 0x43:\n\t\tcase 0x4a:\n\t\tcase 0x4b:\n\t\t\t \n\t\t\tif (tuner_symbol_probe(tda829x_probe, t->i2c->adapter,\n\t\t\t\t\t       t->i2c->addr) >= 0) {\n\t\t\t\tdprintk(\"tda829x detected\\n\");\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tt->type = TUNER_TDA9887;\n\t\t\t\tt->mode_mask = T_RADIO | T_ANALOG_TV;\n\t\t\t\tgoto register_client;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x60:\n\t\t\tif (tuner_symbol_probe(tea5767_autodetection,\n\t\t\t\t\t       t->i2c->adapter, t->i2c->addr)\n\t\t\t\t\t>= 0) {\n\t\t\t\tt->type = TUNER_TEA5767;\n\t\t\t\tt->mode_mask = T_RADIO;\n\t\t\t\t \n\t\t\t\ttuner_lookup(t->i2c->adapter, &radio, &tv);\n\t\t\t\tif (tv)\n\t\t\t\t\ttv->mode_mask &= ~T_RADIO;\n\n\t\t\t\tgoto register_client;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\ttuner_lookup(t->i2c->adapter, &radio, &tv);\n\tif (tv == NULL) {\n\t\tt->mode_mask = T_ANALOG_TV;\n\t\tif (radio == NULL)\n\t\t\tt->mode_mask |= T_RADIO;\n\t\tdprintk(\"Setting mode_mask to 0x%02x\\n\", t->mode_mask);\n\t}\n\n\t \nregister_client:\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tt->sd.entity.name = t->name;\n\t \n\tif (t->type == TUNER_TDA9887) {\n\t\tt->pad[IF_VID_DEC_PAD_IF_INPUT].flags = MEDIA_PAD_FL_SINK;\n\t\tt->pad[IF_VID_DEC_PAD_IF_INPUT].sig_type = PAD_SIGNAL_ANALOG;\n\t\tt->pad[IF_VID_DEC_PAD_OUT].flags = MEDIA_PAD_FL_SOURCE;\n\t\tt->pad[IF_VID_DEC_PAD_OUT].sig_type = PAD_SIGNAL_ANALOG;\n\t\tret = media_entity_pads_init(&t->sd.entity,\n\t\t\t\t\t     IF_VID_DEC_PAD_NUM_PADS,\n\t\t\t\t\t     &t->pad[0]);\n\t\tt->sd.entity.function = MEDIA_ENT_F_IF_VID_DECODER;\n\t} else {\n\t\tt->pad[TUNER_PAD_RF_INPUT].flags = MEDIA_PAD_FL_SINK;\n\t\tt->pad[TUNER_PAD_RF_INPUT].sig_type = PAD_SIGNAL_ANALOG;\n\t\tt->pad[TUNER_PAD_OUTPUT].flags = MEDIA_PAD_FL_SOURCE;\n\t\tt->pad[TUNER_PAD_OUTPUT].sig_type = PAD_SIGNAL_ANALOG;\n\t\tt->pad[TUNER_PAD_AUD_OUT].flags = MEDIA_PAD_FL_SOURCE;\n\t\tt->pad[TUNER_PAD_AUD_OUT].sig_type = PAD_SIGNAL_AUDIO;\n\t\tret = media_entity_pads_init(&t->sd.entity, TUNER_NUM_PADS,\n\t\t\t\t\t     &t->pad[0]);\n\t\tt->sd.entity.function = MEDIA_ENT_F_TUNER;\n\t}\n\n\tif (ret < 0) {\n\t\tpr_err(\"failed to initialize media entity!\\n\");\n\t\tkfree(t);\n\t\treturn ret;\n\t}\n#endif\n\t \n\tif (t->mode_mask & T_ANALOG_TV)\n\t\tt->mode = V4L2_TUNER_ANALOG_TV;\n\telse\n\t\tt->mode = V4L2_TUNER_RADIO;\n\tset_type(client, t->type, t->mode_mask, t->config, t->fe.callback);\n\tlist_add_tail(&t->list, &tuner_list);\n\n\tpr_info(\"Tuner %d found with type(s)%s%s.\\n\",\n\t\t   t->type,\n\t\t   t->mode_mask & T_RADIO ? \" Radio\" : \"\",\n\t\t   t->mode_mask & T_ANALOG_TV ? \" TV\" : \"\");\n\treturn 0;\n}\n\n \n\nstatic void tuner_remove(struct i2c_client *client)\n{\n\tstruct tuner *t = to_tuner(i2c_get_clientdata(client));\n\n\tv4l2_device_unregister_subdev(&t->sd);\n\ttuner_detach(&t->fe);\n\tt->fe.analog_demod_priv = NULL;\n\n\tlist_del(&t->list);\n\tkfree(t);\n}\n\n \n\n \nstatic inline int check_mode(struct tuner *t, enum v4l2_tuner_type mode)\n{\n\tint t_mode;\n\tif (mode == V4L2_TUNER_RADIO)\n\t\tt_mode = T_RADIO;\n\telse\n\t\tt_mode = T_ANALOG_TV;\n\n\tif ((t_mode & t->mode_mask) == 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int set_mode(struct tuner *t, enum v4l2_tuner_type mode)\n{\n\tstruct analog_demod_ops *analog_ops = &t->fe.ops.analog_ops;\n\n\tif (mode != t->mode) {\n\t\tif (check_mode(t, mode) == -EINVAL) {\n\t\t\tdprintk(\"Tuner doesn't support mode %d. Putting tuner to sleep\\n\",\n\t\t\t\t  mode);\n\t\t\tt->standby = true;\n\t\t\tif (analog_ops->standby)\n\t\t\t\tanalog_ops->standby(&t->fe);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tt->mode = mode;\n\t\tdprintk(\"Changing to mode %d\\n\", mode);\n\t}\n\treturn 0;\n}\n\n \nstatic void set_freq(struct tuner *t, unsigned int freq)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(&t->sd);\n\n\tif (t->mode == V4L2_TUNER_RADIO) {\n\t\tif (!freq)\n\t\t\tfreq = t->radio_freq;\n\t\tset_radio_freq(client, freq);\n\t} else {\n\t\tif (!freq)\n\t\t\tfreq = t->tv_freq;\n\t\tset_tv_freq(client, freq);\n\t}\n}\n\n \n\n \nstatic void set_tv_freq(struct i2c_client *c, unsigned int freq)\n{\n\tstruct tuner *t = to_tuner(i2c_get_clientdata(c));\n\tstruct analog_demod_ops *analog_ops = &t->fe.ops.analog_ops;\n\n\tstruct analog_parameters params = {\n\t\t.mode      = t->mode,\n\t\t.audmode   = t->audmode,\n\t\t.std       = t->std\n\t};\n\n\tif (t->type == UNSET) {\n\t\tpr_warn(\"tuner type not set\\n\");\n\t\treturn;\n\t}\n\tif (NULL == analog_ops->set_params) {\n\t\tpr_warn(\"Tuner has no way to set tv freq\\n\");\n\t\treturn;\n\t}\n\tif (freq < tv_range[0] * 16 || freq > tv_range[1] * 16) {\n\t\tdprintk(\"TV freq (%d.%02d) out of range (%d-%d)\\n\",\n\t\t\t   freq / 16, freq % 16 * 100 / 16, tv_range[0],\n\t\t\t   tv_range[1]);\n\t\t \n\t\tif (freq < tv_range[0] * 16)\n\t\t\tfreq = tv_range[0] * 16;\n\t\telse\n\t\t\tfreq = tv_range[1] * 16;\n\t}\n\tparams.frequency = freq;\n\tdprintk(\"tv freq set to %d.%02d\\n\",\n\t\t\tfreq / 16, freq % 16 * 100 / 16);\n\tt->tv_freq = freq;\n\tt->standby = false;\n\n\tanalog_ops->set_params(&t->fe, &params);\n}\n\n \nstatic v4l2_std_id tuner_fixup_std(struct tuner *t, v4l2_std_id std)\n{\n\tif (pal[0] != '-' && (std & V4L2_STD_PAL) == V4L2_STD_PAL) {\n\t\tswitch (pal[0]) {\n\t\tcase '6':\n\t\t\treturn V4L2_STD_PAL_60;\n\t\tcase 'b':\n\t\tcase 'B':\n\t\tcase 'g':\n\t\tcase 'G':\n\t\t\treturn V4L2_STD_PAL_BG;\n\t\tcase 'i':\n\t\tcase 'I':\n\t\t\treturn V4L2_STD_PAL_I;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\tcase 'k':\n\t\tcase 'K':\n\t\t\treturn V4L2_STD_PAL_DK;\n\t\tcase 'M':\n\t\tcase 'm':\n\t\t\treturn V4L2_STD_PAL_M;\n\t\tcase 'N':\n\t\tcase 'n':\n\t\t\tif (pal[1] == 'c' || pal[1] == 'C')\n\t\t\t\treturn V4L2_STD_PAL_Nc;\n\t\t\treturn V4L2_STD_PAL_N;\n\t\tdefault:\n\t\t\tpr_warn(\"pal= argument not recognised\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (secam[0] != '-' && (std & V4L2_STD_SECAM) == V4L2_STD_SECAM) {\n\t\tswitch (secam[0]) {\n\t\tcase 'b':\n\t\tcase 'B':\n\t\tcase 'g':\n\t\tcase 'G':\n\t\tcase 'h':\n\t\tcase 'H':\n\t\t\treturn V4L2_STD_SECAM_B |\n\t\t\t       V4L2_STD_SECAM_G |\n\t\t\t       V4L2_STD_SECAM_H;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\tcase 'k':\n\t\tcase 'K':\n\t\t\treturn V4L2_STD_SECAM_DK;\n\t\tcase 'l':\n\t\tcase 'L':\n\t\t\tif ((secam[1] == 'C') || (secam[1] == 'c'))\n\t\t\t\treturn V4L2_STD_SECAM_LC;\n\t\t\treturn V4L2_STD_SECAM_L;\n\t\tdefault:\n\t\t\tpr_warn(\"secam= argument not recognised\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ntsc[0] != '-' && (std & V4L2_STD_NTSC) == V4L2_STD_NTSC) {\n\t\tswitch (ntsc[0]) {\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\treturn V4L2_STD_NTSC_M;\n\t\tcase 'j':\n\t\tcase 'J':\n\t\t\treturn V4L2_STD_NTSC_M_JP;\n\t\tcase 'k':\n\t\tcase 'K':\n\t\t\treturn V4L2_STD_NTSC_M_KR;\n\t\tdefault:\n\t\t\tpr_info(\"ntsc= argument not recognised\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn std;\n}\n\n \n\n \nstatic void set_radio_freq(struct i2c_client *c, unsigned int freq)\n{\n\tstruct tuner *t = to_tuner(i2c_get_clientdata(c));\n\tstruct analog_demod_ops *analog_ops = &t->fe.ops.analog_ops;\n\n\tstruct analog_parameters params = {\n\t\t.mode      = t->mode,\n\t\t.audmode   = t->audmode,\n\t\t.std       = t->std\n\t};\n\n\tif (t->type == UNSET) {\n\t\tpr_warn(\"tuner type not set\\n\");\n\t\treturn;\n\t}\n\tif (NULL == analog_ops->set_params) {\n\t\tpr_warn(\"tuner has no way to set radio frequency\\n\");\n\t\treturn;\n\t}\n\tif (freq < radio_range[0] * 16000 || freq > radio_range[1] * 16000) {\n\t\tdprintk(\"radio freq (%d.%02d) out of range (%d-%d)\\n\",\n\t\t\t   freq / 16000, freq % 16000 * 100 / 16000,\n\t\t\t   radio_range[0], radio_range[1]);\n\t\t \n\t\tif (freq < radio_range[0] * 16000)\n\t\t\tfreq = radio_range[0] * 16000;\n\t\telse\n\t\t\tfreq = radio_range[1] * 16000;\n\t}\n\tparams.frequency = freq;\n\tdprintk(\"radio freq set to %d.%02d\\n\",\n\t\t\tfreq / 16000, freq % 16000 * 100 / 16000);\n\tt->radio_freq = freq;\n\tt->standby = false;\n\n\tanalog_ops->set_params(&t->fe, &params);\n\t \n\tt->audmode = params.audmode;\n}\n\n \n\n \nstatic void tuner_status(struct dvb_frontend *fe)\n{\n\tstruct tuner *t = fe->analog_demod_priv;\n\tunsigned long freq, freq_fraction;\n\tstruct dvb_tuner_ops *fe_tuner_ops = &fe->ops.tuner_ops;\n\tstruct analog_demod_ops *analog_ops = &fe->ops.analog_ops;\n\tconst char *p;\n\n\tswitch (t->mode) {\n\tcase V4L2_TUNER_RADIO:\n\t\tp = \"radio\";\n\t\tbreak;\n\tcase V4L2_TUNER_DIGITAL_TV:  \n\t\tp = \"digital TV\";\n\t\tbreak;\n\tcase V4L2_TUNER_ANALOG_TV:\n\tdefault:\n\t\tp = \"analog TV\";\n\t\tbreak;\n\t}\n\tif (t->mode == V4L2_TUNER_RADIO) {\n\t\tfreq = t->radio_freq / 16000;\n\t\tfreq_fraction = (t->radio_freq % 16000) * 100 / 16000;\n\t} else {\n\t\tfreq = t->tv_freq / 16;\n\t\tfreq_fraction = (t->tv_freq % 16) * 100 / 16;\n\t}\n\tpr_info(\"Tuner mode:      %s%s\\n\", p,\n\t\t   t->standby ? \" on standby mode\" : \"\");\n\tpr_info(\"Frequency:       %lu.%02lu MHz\\n\", freq, freq_fraction);\n\tpr_info(\"Standard:        0x%08lx\\n\", (unsigned long)t->std);\n\tif (t->mode != V4L2_TUNER_RADIO)\n\t\treturn;\n\tif (fe_tuner_ops->get_status) {\n\t\tu32 tuner_status = 0;\n\n\t\tfe_tuner_ops->get_status(&t->fe, &tuner_status);\n\t\tif (tuner_status & TUNER_STATUS_LOCKED)\n\t\t\tpr_info(\"Tuner is locked.\\n\");\n\t\tif (tuner_status & TUNER_STATUS_STEREO)\n\t\t\tpr_info(\"Stereo:          yes\\n\");\n\t}\n\tif (analog_ops->has_signal) {\n\t\tu16 signal;\n\n\t\tif (!analog_ops->has_signal(fe, &signal))\n\t\t\tpr_info(\"Signal strength: %hu\\n\", signal);\n\t}\n}\n\n \n\nstatic int tuner_s_radio(struct v4l2_subdev *sd)\n{\n\tstruct tuner *t = to_tuner(sd);\n\n\tif (set_mode(t, V4L2_TUNER_RADIO) == 0)\n\t\tset_freq(t, 0);\n\treturn 0;\n}\n\n \n\n \nstatic int tuner_standby(struct v4l2_subdev *sd)\n{\n\tstruct tuner *t = to_tuner(sd);\n\tstruct analog_demod_ops *analog_ops = &t->fe.ops.analog_ops;\n\n\tdprintk(\"Putting tuner to sleep\\n\");\n\tt->standby = true;\n\tif (analog_ops->standby)\n\t\tanalog_ops->standby(&t->fe);\n\treturn 0;\n}\n\nstatic int tuner_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct tuner *t = to_tuner(sd);\n\n\tif (set_mode(t, V4L2_TUNER_ANALOG_TV))\n\t\treturn 0;\n\n\tt->std = tuner_fixup_std(t, std);\n\tif (t->std != std)\n\t\tdprintk(\"Fixup standard %llx to %llx\\n\", std, t->std);\n\tset_freq(t, 0);\n\treturn 0;\n}\n\nstatic int tuner_s_frequency(struct v4l2_subdev *sd, const struct v4l2_frequency *f)\n{\n\tstruct tuner *t = to_tuner(sd);\n\n\tif (set_mode(t, f->type) == 0)\n\t\tset_freq(t, f->frequency);\n\treturn 0;\n}\n\n \nstatic int tuner_g_frequency(struct v4l2_subdev *sd, struct v4l2_frequency *f)\n{\n\tstruct tuner *t = to_tuner(sd);\n\tstruct dvb_tuner_ops *fe_tuner_ops = &t->fe.ops.tuner_ops;\n\n\tif (check_mode(t, f->type) == -EINVAL)\n\t\treturn 0;\n\tif (f->type == t->mode && fe_tuner_ops->get_frequency && !t->standby) {\n\t\tu32 abs_freq;\n\n\t\tfe_tuner_ops->get_frequency(&t->fe, &abs_freq);\n\t\tf->frequency = (V4L2_TUNER_RADIO == t->mode) ?\n\t\t\tDIV_ROUND_CLOSEST(abs_freq * 2, 125) :\n\t\t\tDIV_ROUND_CLOSEST(abs_freq, 62500);\n\t} else {\n\t\tf->frequency = (V4L2_TUNER_RADIO == f->type) ?\n\t\t\tt->radio_freq : t->tv_freq;\n\t}\n\treturn 0;\n}\n\n \nstatic int tuner_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\n{\n\tstruct tuner *t = to_tuner(sd);\n\tstruct analog_demod_ops *analog_ops = &t->fe.ops.analog_ops;\n\tstruct dvb_tuner_ops *fe_tuner_ops = &t->fe.ops.tuner_ops;\n\n\tif (check_mode(t, vt->type) == -EINVAL)\n\t\treturn 0;\n\tif (vt->type == t->mode && analog_ops->get_afc)\n\t\tanalog_ops->get_afc(&t->fe, &vt->afc);\n\tif (vt->type == t->mode && analog_ops->has_signal) {\n\t\tu16 signal = (u16)vt->signal;\n\n\t\tif (!analog_ops->has_signal(&t->fe, &signal))\n\t\t\tvt->signal = signal;\n\t}\n\tif (vt->type != V4L2_TUNER_RADIO) {\n\t\tvt->capability |= V4L2_TUNER_CAP_NORM;\n\t\tvt->rangelow = tv_range[0] * 16;\n\t\tvt->rangehigh = tv_range[1] * 16;\n\t\treturn 0;\n\t}\n\n\t \n\tif (vt->type == t->mode) {\n\t\tvt->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;\n\t\tif (fe_tuner_ops->get_status) {\n\t\t\tu32 tuner_status = 0;\n\n\t\t\tfe_tuner_ops->get_status(&t->fe, &tuner_status);\n\t\t\tvt->rxsubchans =\n\t\t\t\t(tuner_status & TUNER_STATUS_STEREO) ?\n\t\t\t\tV4L2_TUNER_SUB_STEREO :\n\t\t\t\tV4L2_TUNER_SUB_MONO;\n\t\t}\n\t\tvt->audmode = t->audmode;\n\t}\n\tvt->capability |= V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO;\n\tvt->rangelow = radio_range[0] * 16000;\n\tvt->rangehigh = radio_range[1] * 16000;\n\n\treturn 0;\n}\n\n \nstatic int tuner_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *vt)\n{\n\tstruct tuner *t = to_tuner(sd);\n\n\tif (set_mode(t, vt->type))\n\t\treturn 0;\n\n\tif (t->mode == V4L2_TUNER_RADIO) {\n\t\tt->audmode = vt->audmode;\n\t\t \n\t\tif (t->audmode != V4L2_TUNER_MODE_MONO &&\n\t\t    t->audmode != V4L2_TUNER_MODE_STEREO)\n\t\t\tt->audmode = V4L2_TUNER_MODE_STEREO;\n\t}\n\tset_freq(t, 0);\n\n\treturn 0;\n}\n\nstatic int tuner_log_status(struct v4l2_subdev *sd)\n{\n\tstruct tuner *t = to_tuner(sd);\n\tstruct analog_demod_ops *analog_ops = &t->fe.ops.analog_ops;\n\n\tif (analog_ops->tuner_status)\n\t\tanalog_ops->tuner_status(&t->fe);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int tuner_suspend(struct device *dev)\n{\n\tstruct i2c_client *c = to_i2c_client(dev);\n\tstruct tuner *t = to_tuner(i2c_get_clientdata(c));\n\tstruct analog_demod_ops *analog_ops = &t->fe.ops.analog_ops;\n\n\tdprintk(\"suspend\\n\");\n\n\tif (t->fe.ops.tuner_ops.suspend)\n\t\tt->fe.ops.tuner_ops.suspend(&t->fe);\n\telse if (!t->standby && analog_ops->standby)\n\t\tanalog_ops->standby(&t->fe);\n\n\treturn 0;\n}\n\nstatic int tuner_resume(struct device *dev)\n{\n\tstruct i2c_client *c = to_i2c_client(dev);\n\tstruct tuner *t = to_tuner(i2c_get_clientdata(c));\n\n\tdprintk(\"resume\\n\");\n\n\tif (t->fe.ops.tuner_ops.resume)\n\t\tt->fe.ops.tuner_ops.resume(&t->fe);\n\telse if (!t->standby)\n\t\tif (set_mode(t, t->mode) == 0)\n\t\t\tset_freq(t, 0);\n\n\treturn 0;\n}\n#endif\n\nstatic int tuner_command(struct i2c_client *client, unsigned cmd, void *arg)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\n\t \n\tswitch (cmd) {\n\tcase TUNER_SET_CONFIG:\n\t\treturn tuner_s_config(sd, arg);\n\t}\n\treturn -ENOIOCTLCMD;\n}\n\n \n\nstatic const struct v4l2_subdev_core_ops tuner_core_ops = {\n\t.log_status = tuner_log_status,\n};\n\nstatic const struct v4l2_subdev_tuner_ops tuner_tuner_ops = {\n\t.standby = tuner_standby,\n\t.s_radio = tuner_s_radio,\n\t.g_tuner = tuner_g_tuner,\n\t.s_tuner = tuner_s_tuner,\n\t.s_frequency = tuner_s_frequency,\n\t.g_frequency = tuner_g_frequency,\n\t.s_type_addr = tuner_s_type_addr,\n\t.s_config = tuner_s_config,\n};\n\nstatic const struct v4l2_subdev_video_ops tuner_video_ops = {\n\t.s_std = tuner_s_std,\n};\n\nstatic const struct v4l2_subdev_ops tuner_ops = {\n\t.core = &tuner_core_ops,\n\t.tuner = &tuner_tuner_ops,\n\t.video = &tuner_video_ops,\n};\n\n \n\nstatic const struct dev_pm_ops tuner_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(tuner_suspend, tuner_resume)\n};\n\nstatic const struct i2c_device_id tuner_id[] = {\n\t{ \"tuner\", },  \n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tuner_id);\n\nstatic struct i2c_driver tuner_driver = {\n\t.driver = {\n\t\t.name\t= \"tuner\",\n\t\t.pm\t= &tuner_pm_ops,\n\t},\n\t.probe\t\t= tuner_probe,\n\t.remove\t\t= tuner_remove,\n\t.command\t= tuner_command,\n\t.id_table\t= tuner_id,\n};\n\nmodule_i2c_driver(tuner_driver);\n\nMODULE_DESCRIPTION(\"device driver for various TV and TV+FM radio tuners\");\nMODULE_AUTHOR(\"Ralph Metzler, Gerd Knorr, Gunther Mayer\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}