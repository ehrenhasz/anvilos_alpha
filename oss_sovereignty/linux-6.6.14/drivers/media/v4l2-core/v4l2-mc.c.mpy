{
  "module_name": "v4l2-mc.c",
  "hash_id": "ce4b96ecfa60d326aa815afbe16fd651e8395a165e491afda02caaa51734577c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/v4l2-mc.c",
  "human_readable_source": "\n\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/usb.h>\n#include <media/media-device.h>\n#include <media/media-entity.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-mc.h>\n#include <media/v4l2-subdev.h>\n#include <media/videobuf2-core.h>\n\nint v4l2_mc_create_media_graph(struct media_device *mdev)\n\n{\n\tstruct media_entity *entity;\n\tstruct media_entity *if_vid = NULL, *if_aud = NULL;\n\tstruct media_entity *tuner = NULL, *decoder = NULL;\n\tstruct media_entity *io_v4l = NULL, *io_vbi = NULL, *io_swradio = NULL;\n\tbool is_webcam = false;\n\tu32 flags;\n\tint ret, pad_sink, pad_source;\n\n\tif (!mdev)\n\t\treturn 0;\n\n\tmedia_device_for_each_entity(entity, mdev) {\n\t\tswitch (entity->function) {\n\t\tcase MEDIA_ENT_F_IF_VID_DECODER:\n\t\t\tif_vid = entity;\n\t\t\tbreak;\n\t\tcase MEDIA_ENT_F_IF_AUD_DECODER:\n\t\t\tif_aud = entity;\n\t\t\tbreak;\n\t\tcase MEDIA_ENT_F_TUNER:\n\t\t\ttuner = entity;\n\t\t\tbreak;\n\t\tcase MEDIA_ENT_F_ATV_DECODER:\n\t\t\tdecoder = entity;\n\t\t\tbreak;\n\t\tcase MEDIA_ENT_F_IO_V4L:\n\t\t\tio_v4l = entity;\n\t\t\tbreak;\n\t\tcase MEDIA_ENT_F_IO_VBI:\n\t\t\tio_vbi = entity;\n\t\t\tbreak;\n\t\tcase MEDIA_ENT_F_IO_SWRADIO:\n\t\t\tio_swradio = entity;\n\t\t\tbreak;\n\t\tcase MEDIA_ENT_F_CAM_SENSOR:\n\t\t\tis_webcam = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!io_v4l && !io_vbi && !io_swradio) {\n\t\tdev_warn(mdev->dev, \"Didn't find any I/O entity\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (is_webcam) {\n\t\tif (!io_v4l) {\n\t\t\tdev_warn(mdev->dev, \"Didn't find a MEDIA_ENT_F_IO_V4L\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmedia_device_for_each_entity(entity, mdev) {\n\t\t\tif (entity->function != MEDIA_ENT_F_CAM_SENSOR)\n\t\t\t\tcontinue;\n\t\t\tret = media_create_pad_link(entity, 0,\n\t\t\t\t\t\t    io_v4l, 0,\n\t\t\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\t\t\tif (ret) {\n\t\t\t\tdev_warn(mdev->dev, \"Failed to create a sensor link\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tif (!decoder)\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (!decoder) {\n\t\tdev_warn(mdev->dev, \"Decoder not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (tuner) {\n\t\tif (if_vid) {\n\t\t\tpad_source = media_get_pad_index(tuner,\n\t\t\t\t\t\t\t MEDIA_PAD_FL_SOURCE,\n\t\t\t\t\t\t\t PAD_SIGNAL_ANALOG);\n\t\t\tpad_sink = media_get_pad_index(if_vid,\n\t\t\t\t\t\t       MEDIA_PAD_FL_SINK,\n\t\t\t\t\t\t       PAD_SIGNAL_ANALOG);\n\t\t\tif (pad_source < 0 || pad_sink < 0) {\n\t\t\t\tdev_warn(mdev->dev, \"Couldn't get tuner and/or PLL pad(s): (%d, %d)\\n\",\n\t\t\t\t\t pad_source, pad_sink);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tret = media_create_pad_link(tuner, pad_source,\n\t\t\t\t\t\t    if_vid, pad_sink,\n\t\t\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\t\t\tif (ret) {\n\t\t\t\tdev_warn(mdev->dev, \"Couldn't create tuner->PLL link)\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tpad_source = media_get_pad_index(if_vid,\n\t\t\t\t\t\t\t MEDIA_PAD_FL_SOURCE,\n\t\t\t\t\t\t\t PAD_SIGNAL_ANALOG);\n\t\t\tpad_sink = media_get_pad_index(decoder,\n\t\t\t\t\t\t       MEDIA_PAD_FL_SINK,\n\t\t\t\t\t\t       PAD_SIGNAL_ANALOG);\n\t\t\tif (pad_source < 0 || pad_sink < 0) {\n\t\t\t\tdev_warn(mdev->dev, \"get decoder and/or PLL pad(s): (%d, %d)\\n\",\n\t\t\t\t\t pad_source, pad_sink);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tret = media_create_pad_link(if_vid, pad_source,\n\t\t\t\t\t\t    decoder, pad_sink,\n\t\t\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\t\t\tif (ret) {\n\t\t\t\tdev_warn(mdev->dev, \"couldn't link PLL to decoder\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tpad_source = media_get_pad_index(tuner,\n\t\t\t\t\t\t\t MEDIA_PAD_FL_SOURCE,\n\t\t\t\t\t\t\t PAD_SIGNAL_ANALOG);\n\t\t\tpad_sink = media_get_pad_index(decoder,\n\t\t\t\t\t\t       MEDIA_PAD_FL_SINK,\n\t\t\t\t\t\t       PAD_SIGNAL_ANALOG);\n\t\t\tif (pad_source < 0 || pad_sink < 0) {\n\t\t\t\tdev_warn(mdev->dev, \"couldn't get tuner and/or decoder pad(s): (%d, %d)\\n\",\n\t\t\t\t\t pad_source, pad_sink);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tret = media_create_pad_link(tuner, pad_source,\n\t\t\t\t\t\t    decoder, pad_sink,\n\t\t\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (if_aud) {\n\t\t\tpad_source = media_get_pad_index(tuner,\n\t\t\t\t\t\t\t MEDIA_PAD_FL_SOURCE,\n\t\t\t\t\t\t\t PAD_SIGNAL_AUDIO);\n\t\t\tpad_sink = media_get_pad_index(if_aud,\n\t\t\t\t\t\t       MEDIA_PAD_FL_SINK,\n\t\t\t\t\t\t       PAD_SIGNAL_AUDIO);\n\t\t\tif (pad_source < 0 || pad_sink < 0) {\n\t\t\t\tdev_warn(mdev->dev, \"couldn't get tuner and/or decoder pad(s) for audio: (%d, %d)\\n\",\n\t\t\t\t\t pad_source, pad_sink);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tret = media_create_pad_link(tuner, pad_source,\n\t\t\t\t\t\t    if_aud, pad_sink,\n\t\t\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\t\t\tif (ret) {\n\t\t\t\tdev_warn(mdev->dev, \"couldn't link tuner->audio PLL\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tif_aud = tuner;\n\t\t}\n\n\t}\n\n\t \n\tif (io_v4l) {\n\t\tpad_source = media_get_pad_index(decoder, MEDIA_PAD_FL_SOURCE,\n\t\t\t\t\t\t PAD_SIGNAL_DV);\n\t\tif (pad_source < 0) {\n\t\t\tdev_warn(mdev->dev, \"couldn't get decoder output pad for V4L I/O\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = media_create_pad_link(decoder, pad_source,\n\t\t\t\t\t    io_v4l, 0,\n\t\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\t\tif (ret) {\n\t\t\tdev_warn(mdev->dev, \"couldn't link decoder output to V4L I/O\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (io_swradio) {\n\t\tpad_source = media_get_pad_index(decoder, MEDIA_PAD_FL_SOURCE,\n\t\t\t\t\t\t PAD_SIGNAL_DV);\n\t\tif (pad_source < 0) {\n\t\t\tdev_warn(mdev->dev, \"couldn't get decoder output pad for SDR\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = media_create_pad_link(decoder, pad_source,\n\t\t\t\t\t    io_swradio, 0,\n\t\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\t\tif (ret) {\n\t\t\tdev_warn(mdev->dev, \"couldn't link decoder output to SDR\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (io_vbi) {\n\t\tpad_source = media_get_pad_index(decoder, MEDIA_PAD_FL_SOURCE,\n\t\t\t\t\t\t PAD_SIGNAL_DV);\n\t\tif (pad_source < 0) {\n\t\t\tdev_warn(mdev->dev, \"couldn't get decoder output pad for VBI\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = media_create_pad_link(decoder, pad_source,\n\t\t\t\t\t    io_vbi, 0,\n\t\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\t\tif (ret) {\n\t\t\tdev_warn(mdev->dev, \"couldn't link decoder output to VBI\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tflags = MEDIA_LNK_FL_ENABLED;\n\tmedia_device_for_each_entity(entity, mdev) {\n\t\tswitch (entity->function) {\n\t\tcase MEDIA_ENT_F_CONN_RF:\n\t\t\tif (!tuner)\n\t\t\t\tcontinue;\n\t\t\tpad_sink = media_get_pad_index(tuner, MEDIA_PAD_FL_SINK,\n\t\t\t\t\t\t       PAD_SIGNAL_ANALOG);\n\t\t\tif (pad_sink < 0) {\n\t\t\t\tdev_warn(mdev->dev, \"couldn't get tuner analog pad sink\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tret = media_create_pad_link(entity, 0, tuner,\n\t\t\t\t\t\t    pad_sink,\n\t\t\t\t\t\t    flags);\n\t\t\tbreak;\n\t\tcase MEDIA_ENT_F_CONN_SVIDEO:\n\t\tcase MEDIA_ENT_F_CONN_COMPOSITE:\n\t\t\tpad_sink = media_get_pad_index(decoder,\n\t\t\t\t\t\t       MEDIA_PAD_FL_SINK,\n\t\t\t\t\t\t       PAD_SIGNAL_ANALOG);\n\t\t\tif (pad_sink < 0) {\n\t\t\t\tdev_warn(mdev->dev, \"couldn't get decoder analog pad sink\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tret = media_create_pad_link(entity, 0, decoder,\n\t\t\t\t\t\t    pad_sink,\n\t\t\t\t\t\t    flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tflags = 0;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(v4l2_mc_create_media_graph);\n\nint v4l_enable_media_source(struct video_device *vdev)\n{\n\tstruct media_device *mdev = vdev->entity.graph_obj.mdev;\n\tint ret = 0, err;\n\n\tif (!mdev)\n\t\treturn 0;\n\n\tmutex_lock(&mdev->graph_mutex);\n\tif (!mdev->enable_source)\n\t\tgoto end;\n\terr = mdev->enable_source(&vdev->entity, &vdev->pipe);\n\tif (err)\n\t\tret = -EBUSY;\nend:\n\tmutex_unlock(&mdev->graph_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(v4l_enable_media_source);\n\nvoid v4l_disable_media_source(struct video_device *vdev)\n{\n\tstruct media_device *mdev = vdev->entity.graph_obj.mdev;\n\n\tif (mdev) {\n\t\tmutex_lock(&mdev->graph_mutex);\n\t\tif (mdev->disable_source)\n\t\t\tmdev->disable_source(&vdev->entity);\n\t\tmutex_unlock(&mdev->graph_mutex);\n\t}\n}\nEXPORT_SYMBOL_GPL(v4l_disable_media_source);\n\nint v4l_vb2q_enable_media_source(struct vb2_queue *q)\n{\n\tstruct v4l2_fh *fh = q->owner;\n\n\tif (fh && fh->vdev)\n\t\treturn v4l_enable_media_source(fh->vdev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(v4l_vb2q_enable_media_source);\n\nint v4l2_create_fwnode_links_to_pad(struct v4l2_subdev *src_sd,\n\t\t\t\t    struct media_pad *sink, u32 flags)\n{\n\tstruct fwnode_handle *endpoint;\n\n\tif (!(sink->flags & MEDIA_PAD_FL_SINK))\n\t\treturn -EINVAL;\n\n\tfwnode_graph_for_each_endpoint(dev_fwnode(src_sd->dev), endpoint) {\n\t\tstruct fwnode_handle *remote_ep;\n\t\tint src_idx, sink_idx, ret;\n\t\tstruct media_pad *src;\n\n\t\tsrc_idx = media_entity_get_fwnode_pad(&src_sd->entity,\n\t\t\t\t\t\t      endpoint,\n\t\t\t\t\t\t      MEDIA_PAD_FL_SOURCE);\n\t\tif (src_idx < 0)\n\t\t\tcontinue;\n\n\t\tremote_ep = fwnode_graph_get_remote_endpoint(endpoint);\n\t\tif (!remote_ep)\n\t\t\tcontinue;\n\n\t\t \n\t\tsink_idx = media_entity_get_fwnode_pad(sink->entity,\n\t\t\t\t\t\t       remote_ep,\n\t\t\t\t\t\t       MEDIA_PAD_FL_SINK);\n\t\tfwnode_handle_put(remote_ep);\n\n\t\tif (sink_idx < 0 || sink_idx != sink->index)\n\t\t\tcontinue;\n\n\t\t \n\n\t\tsrc = &src_sd->entity.pads[src_idx];\n\n\t\t \n\t\tif (media_entity_find_link(src, sink))\n\t\t\tcontinue;\n\n\t\tdev_dbg(src_sd->dev, \"creating link %s:%d -> %s:%d\\n\",\n\t\t\tsrc_sd->entity.name, src_idx,\n\t\t\tsink->entity->name, sink_idx);\n\n\t\tret = media_create_pad_link(&src_sd->entity, src_idx,\n\t\t\t\t\t    sink->entity, sink_idx, flags);\n\t\tif (ret) {\n\t\t\tdev_err(src_sd->dev,\n\t\t\t\t\"link %s:%d -> %s:%d failed with %d\\n\",\n\t\t\t\tsrc_sd->entity.name, src_idx,\n\t\t\t\tsink->entity->name, sink_idx, ret);\n\n\t\t\tfwnode_handle_put(endpoint);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(v4l2_create_fwnode_links_to_pad);\n\nint v4l2_create_fwnode_links(struct v4l2_subdev *src_sd,\n\t\t\t     struct v4l2_subdev *sink_sd)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < sink_sd->entity.num_pads; i++) {\n\t\tstruct media_pad *pad = &sink_sd->entity.pads[i];\n\t\tint ret;\n\n\t\tif (!(pad->flags & MEDIA_PAD_FL_SINK))\n\t\t\tcontinue;\n\n\t\tret = v4l2_create_fwnode_links_to_pad(src_sd, pad, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(v4l2_create_fwnode_links);\n\n \n\n \nstatic int pipeline_pm_use_count(struct media_entity *entity,\n\tstruct media_graph *graph)\n{\n\tint use = 0;\n\n\tmedia_graph_walk_start(graph, entity);\n\n\twhile ((entity = media_graph_walk_next(graph))) {\n\t\tif (is_media_entity_v4l2_video_device(entity))\n\t\t\tuse += entity->use_count;\n\t}\n\n\treturn use;\n}\n\n \nstatic int pipeline_pm_power_one(struct media_entity *entity, int change)\n{\n\tstruct v4l2_subdev *subdev;\n\tint ret;\n\n\tsubdev = is_media_entity_v4l2_subdev(entity)\n\t       ? media_entity_to_v4l2_subdev(entity) : NULL;\n\n\tif (entity->use_count == 0 && change > 0 && subdev != NULL) {\n\t\tret = v4l2_subdev_call(subdev, core, s_power, 1);\n\t\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\t\treturn ret;\n\t}\n\n\tentity->use_count += change;\n\tWARN_ON(entity->use_count < 0);\n\n\tif (entity->use_count == 0 && change < 0 && subdev != NULL)\n\t\tv4l2_subdev_call(subdev, core, s_power, 0);\n\n\treturn 0;\n}\n\n \nstatic int pipeline_pm_power(struct media_entity *entity, int change,\n\tstruct media_graph *graph)\n{\n\tstruct media_entity *first = entity;\n\tint ret = 0;\n\n\tif (!change)\n\t\treturn 0;\n\n\tmedia_graph_walk_start(graph, entity);\n\n\twhile (!ret && (entity = media_graph_walk_next(graph)))\n\t\tif (is_media_entity_v4l2_subdev(entity))\n\t\t\tret = pipeline_pm_power_one(entity, change);\n\n\tif (!ret)\n\t\treturn ret;\n\n\tmedia_graph_walk_start(graph, first);\n\n\twhile ((first = media_graph_walk_next(graph))\n\t       && first != entity)\n\t\tif (is_media_entity_v4l2_subdev(first))\n\t\t\tpipeline_pm_power_one(first, -change);\n\n\treturn ret;\n}\n\nstatic int v4l2_pipeline_pm_use(struct media_entity *entity, unsigned int use)\n{\n\tstruct media_device *mdev = entity->graph_obj.mdev;\n\tint change = use ? 1 : -1;\n\tint ret;\n\n\tmutex_lock(&mdev->graph_mutex);\n\n\t \n\tentity->use_count += change;\n\tWARN_ON(entity->use_count < 0);\n\n\t \n\tret = pipeline_pm_power(entity, change, &mdev->pm_count_walk);\n\tif (ret < 0)\n\t\tentity->use_count -= change;\n\n\tmutex_unlock(&mdev->graph_mutex);\n\n\treturn ret;\n}\n\nint v4l2_pipeline_pm_get(struct media_entity *entity)\n{\n\treturn v4l2_pipeline_pm_use(entity, 1);\n}\nEXPORT_SYMBOL_GPL(v4l2_pipeline_pm_get);\n\nvoid v4l2_pipeline_pm_put(struct media_entity *entity)\n{\n\t \n\tWARN_ON(v4l2_pipeline_pm_use(entity, 0));\n}\nEXPORT_SYMBOL_GPL(v4l2_pipeline_pm_put);\n\nint v4l2_pipeline_link_notify(struct media_link *link, u32 flags,\n\t\t\t      unsigned int notification)\n{\n\tstruct media_graph *graph = &link->graph_obj.mdev->pm_count_walk;\n\tstruct media_entity *source = link->source->entity;\n\tstruct media_entity *sink = link->sink->entity;\n\tint source_use;\n\tint sink_use;\n\tint ret = 0;\n\n\tsource_use = pipeline_pm_use_count(source, graph);\n\tsink_use = pipeline_pm_use_count(sink, graph);\n\n\tif (notification == MEDIA_DEV_NOTIFY_POST_LINK_CH &&\n\t    !(flags & MEDIA_LNK_FL_ENABLED)) {\n\t\t \n\t\tpipeline_pm_power(source, -sink_use, graph);\n\t\tpipeline_pm_power(sink, -source_use, graph);\n\t\treturn 0;\n\t}\n\n\tif (notification == MEDIA_DEV_NOTIFY_PRE_LINK_CH &&\n\t\t(flags & MEDIA_LNK_FL_ENABLED)) {\n\n\t\tret = pipeline_pm_power(source, sink_use, graph);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = pipeline_pm_power(sink, source_use, graph);\n\t\tif (ret < 0)\n\t\t\tpipeline_pm_power(source, -sink_use, graph);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(v4l2_pipeline_link_notify);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}