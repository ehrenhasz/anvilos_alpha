{
  "module_name": "v4l2-cci.c",
  "hash_id": "dc6dc59fd0b6570331eadf933219065d92f9029cb65aad59ef86acb7226a33d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/v4l2-cci.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/dev_printk.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n\n#include <asm/unaligned.h>\n\n#include <media/v4l2-cci.h>\n\nint cci_read(struct regmap *map, u32 reg, u64 *val, int *err)\n{\n\tunsigned int len;\n\tu8 buf[8];\n\tint ret;\n\n\tif (err && *err)\n\t\treturn *err;\n\n\tlen = FIELD_GET(CCI_REG_WIDTH_MASK, reg);\n\treg = FIELD_GET(CCI_REG_ADDR_MASK, reg);\n\n\tret = regmap_bulk_read(map, reg, buf, len);\n\tif (ret) {\n\t\tdev_err(regmap_get_device(map), \"Error reading reg 0x%4x: %d\\n\",\n\t\t\treg, ret);\n\t\tgoto out;\n\t}\n\n\tswitch (len) {\n\tcase 1:\n\t\t*val = buf[0];\n\t\tbreak;\n\tcase 2:\n\t\t*val = get_unaligned_be16(buf);\n\t\tbreak;\n\tcase 3:\n\t\t*val = get_unaligned_be24(buf);\n\t\tbreak;\n\tcase 4:\n\t\t*val = get_unaligned_be32(buf);\n\t\tbreak;\n\tcase 8:\n\t\t*val = get_unaligned_be64(buf);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(regmap_get_device(map), \"Error invalid reg-width %u for reg 0x%04x\\n\",\n\t\t\tlen, reg);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nout:\n\tif (ret && err)\n\t\t*err = ret;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cci_read);\n\nint cci_write(struct regmap *map, u32 reg, u64 val, int *err)\n{\n\tunsigned int len;\n\tu8 buf[8];\n\tint ret;\n\n\tif (err && *err)\n\t\treturn *err;\n\n\tlen = FIELD_GET(CCI_REG_WIDTH_MASK, reg);\n\treg = FIELD_GET(CCI_REG_ADDR_MASK, reg);\n\n\tswitch (len) {\n\tcase 1:\n\t\tbuf[0] = val;\n\t\tbreak;\n\tcase 2:\n\t\tput_unaligned_be16(val, buf);\n\t\tbreak;\n\tcase 3:\n\t\tput_unaligned_be24(val, buf);\n\t\tbreak;\n\tcase 4:\n\t\tput_unaligned_be32(val, buf);\n\t\tbreak;\n\tcase 8:\n\t\tput_unaligned_be64(val, buf);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(regmap_get_device(map), \"Error invalid reg-width %u for reg 0x%04x\\n\",\n\t\t\tlen, reg);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = regmap_bulk_write(map, reg, buf, len);\n\tif (ret)\n\t\tdev_err(regmap_get_device(map), \"Error writing reg 0x%4x: %d\\n\",\n\t\t\treg, ret);\n\nout:\n\tif (ret && err)\n\t\t*err = ret;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cci_write);\n\nint cci_update_bits(struct regmap *map, u32 reg, u64 mask, u64 val, int *err)\n{\n\tu64 readval;\n\tint ret;\n\n\tret = cci_read(map, reg, &readval, err);\n\tif (ret)\n\t\treturn ret;\n\n\tval = (readval & ~mask) | (val & mask);\n\n\treturn cci_write(map, reg, val, err);\n}\nEXPORT_SYMBOL_GPL(cci_update_bits);\n\nint cci_multi_reg_write(struct regmap *map, const struct cci_reg_sequence *regs,\n\t\t\tunsigned int num_regs, int *err)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < num_regs; i++) {\n\t\tret = cci_write(map, regs[i].reg, regs[i].val, err);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cci_multi_reg_write);\n\n#if IS_ENABLED(CONFIG_V4L2_CCI_I2C)\nstruct regmap *devm_cci_regmap_init_i2c(struct i2c_client *client,\n\t\t\t\t\tint reg_addr_bits)\n{\n\tstruct regmap_config config = {\n\t\t.reg_bits = reg_addr_bits,\n\t\t.val_bits = 8,\n\t\t.reg_format_endian = REGMAP_ENDIAN_BIG,\n\t\t.disable_locking = true,\n\t};\n\n\treturn devm_regmap_init_i2c(client, &config);\n}\nEXPORT_SYMBOL_GPL(devm_cci_regmap_init_i2c);\n#endif\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Hans de Goede <hansg@kernel.org>\");\nMODULE_DESCRIPTION(\"MIPI Camera Control Interface (CCI) support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}