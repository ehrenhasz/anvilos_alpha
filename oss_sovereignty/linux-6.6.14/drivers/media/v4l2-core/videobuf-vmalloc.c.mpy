{
  "module_name": "videobuf-vmalloc.c",
  "hash_id": "42dd4b880e44c894edf3d5db3bc73f7e55894c7c77f626137288b47bb66f5f71",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/videobuf-vmalloc.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pgtable.h>\n\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <asm/page.h>\n\n#include <media/videobuf-vmalloc.h>\n\n#define MAGIC_DMABUF   0x17760309\n#define MAGIC_VMAL_MEM 0x18221223\n\n#define MAGIC_CHECK(is, should)\t\t\t\t\t\t\\\n\tif (unlikely((is) != (should))) {\t\t\t\t\\\n\t\tprintk(KERN_ERR \"magic mismatch: %x (expected %x)\\n\",\t\\\n\t\t\t\tis, should);\t\t\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\n\nstatic int debug;\nmodule_param(debug, int, 0644);\n\nMODULE_DESCRIPTION(\"helper module to manage video4linux vmalloc buffers\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab <mchehab@kernel.org>\");\nMODULE_LICENSE(\"GPL\");\n\n#define dprintk(level, fmt, arg...)\t\t\t\t\t\\\n\tif (debug >= level)\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"vbuf-vmalloc: \" fmt , ## arg)\n\n\n \n\nstatic void videobuf_vm_open(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\n\tdprintk(2, \"vm_open %p [count=%u,vma=%08lx-%08lx]\\n\", map,\n\t\tmap->count, vma->vm_start, vma->vm_end);\n\n\tmap->count++;\n}\n\nstatic void videobuf_vm_close(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tstruct videobuf_queue *q = map->q;\n\tint i;\n\n\tdprintk(2, \"vm_close %p [count=%u,vma=%08lx-%08lx]\\n\", map,\n\t\tmap->count, vma->vm_start, vma->vm_end);\n\n\tmap->count--;\n\tif (0 == map->count) {\n\t\tstruct videobuf_vmalloc_memory *mem;\n\n\t\tdprintk(1, \"munmap %p q=%p\\n\", map, q);\n\t\tvideobuf_queue_lock(q);\n\n\t\t \n\t\tif (q->streaming)\n\t\t\tvideobuf_queue_cancel(q);\n\n\t\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\t\tif (NULL == q->bufs[i])\n\t\t\t\tcontinue;\n\n\t\t\tif (q->bufs[i]->map != map)\n\t\t\t\tcontinue;\n\n\t\t\tmem = q->bufs[i]->priv;\n\t\t\tif (mem) {\n\t\t\t\t \n\n\t\t\t\tMAGIC_CHECK(mem->magic, MAGIC_VMAL_MEM);\n\n\t\t\t\t \n\t\t\t\tdprintk(1, \"%s: buf[%d] freeing (%p)\\n\",\n\t\t\t\t\t__func__, i, mem->vaddr);\n\n\t\t\t\tvfree(mem->vaddr);\n\t\t\t\tmem->vaddr = NULL;\n\t\t\t}\n\n\t\t\tq->bufs[i]->map   = NULL;\n\t\t\tq->bufs[i]->baddr = 0;\n\t\t}\n\n\t\tkfree(map);\n\n\t\tvideobuf_queue_unlock(q);\n\t}\n\n\treturn;\n}\n\nstatic const struct vm_operations_struct videobuf_vm_ops = {\n\t.open     = videobuf_vm_open,\n\t.close    = videobuf_vm_close,\n};\n\n \n\n \n\nstatic struct videobuf_buffer *__videobuf_alloc_vb(size_t size)\n{\n\tstruct videobuf_vmalloc_memory *mem;\n\tstruct videobuf_buffer *vb;\n\n\tvb = kzalloc(size + sizeof(*mem), GFP_KERNEL);\n\tif (!vb)\n\t\treturn vb;\n\n\tmem = vb->priv = ((char *)vb) + size;\n\tmem->magic = MAGIC_VMAL_MEM;\n\n\tdprintk(1, \"%s: allocated at %p(%ld+%ld) & %p(%ld)\\n\",\n\t\t__func__, vb, (long)sizeof(*vb), (long)size - sizeof(*vb),\n\t\tmem, (long)sizeof(*mem));\n\n\treturn vb;\n}\n\nstatic int __videobuf_iolock(struct videobuf_queue *q,\n\t\t\t     struct videobuf_buffer *vb,\n\t\t\t     struct v4l2_framebuffer *fbuf)\n{\n\tstruct videobuf_vmalloc_memory *mem = vb->priv;\n\tint pages;\n\n\tBUG_ON(!mem);\n\n\tMAGIC_CHECK(mem->magic, MAGIC_VMAL_MEM);\n\n\tswitch (vb->memory) {\n\tcase V4L2_MEMORY_MMAP:\n\t\tdprintk(1, \"%s memory method MMAP\\n\", __func__);\n\n\t\t \n\t\tif (!mem->vaddr) {\n\t\t\tprintk(KERN_ERR \"memory is not allocated/mmapped.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase V4L2_MEMORY_USERPTR:\n\t\tpages = PAGE_ALIGN(vb->size);\n\n\t\tdprintk(1, \"%s memory method USERPTR\\n\", __func__);\n\n\t\tif (vb->baddr) {\n\t\t\tprintk(KERN_ERR \"USERPTR is currently not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\n\t\tmem->vaddr = vmalloc_user(pages);\n\t\tif (!mem->vaddr) {\n\t\t\tprintk(KERN_ERR \"vmalloc (%d pages) failed\\n\", pages);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdprintk(1, \"vmalloc is at addr %p (%d pages)\\n\",\n\t\t\tmem->vaddr, pages);\n\t\tbreak;\n\tcase V4L2_MEMORY_OVERLAY:\n\tdefault:\n\t\tdprintk(1, \"%s memory method OVERLAY/unknown\\n\", __func__);\n\n\t\t \n\t\tprintk(KERN_ERR \"Memory method currently unsupported.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __videobuf_mmap_mapper(struct videobuf_queue *q,\n\t\t\t\t  struct videobuf_buffer *buf,\n\t\t\t\t  struct vm_area_struct *vma)\n{\n\tstruct videobuf_vmalloc_memory *mem;\n\tstruct videobuf_mapping *map;\n\tint retval, pages;\n\n\tdprintk(1, \"%s\\n\", __func__);\n\n\t \n\tmap = kzalloc(sizeof(struct videobuf_mapping), GFP_KERNEL);\n\tif (NULL == map)\n\t\treturn -ENOMEM;\n\n\tbuf->map = map;\n\tmap->q     = q;\n\n\tbuf->baddr = vma->vm_start;\n\n\tmem = buf->priv;\n\tBUG_ON(!mem);\n\tMAGIC_CHECK(mem->magic, MAGIC_VMAL_MEM);\n\n\tpages = PAGE_ALIGN(vma->vm_end - vma->vm_start);\n\tmem->vaddr = vmalloc_user(pages);\n\tif (!mem->vaddr) {\n\t\tprintk(KERN_ERR \"vmalloc (%d pages) failed\\n\", pages);\n\t\tgoto error;\n\t}\n\tdprintk(1, \"vmalloc is at addr %p (%d pages)\\n\", mem->vaddr, pages);\n\n\t \n\tretval = remap_vmalloc_range(vma, mem->vaddr, 0);\n\tif (retval < 0) {\n\t\tprintk(KERN_ERR \"mmap: remap failed with error %d. \", retval);\n\t\tvfree(mem->vaddr);\n\t\tgoto error;\n\t}\n\n\tvma->vm_ops          = &videobuf_vm_ops;\n\tvm_flags_set(vma, VM_DONTEXPAND | VM_DONTDUMP);\n\tvma->vm_private_data = map;\n\n\tdprintk(1, \"mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\\n\",\n\t\tmap, q, vma->vm_start, vma->vm_end,\n\t\t(long int)buf->bsize,\n\t\tvma->vm_pgoff, buf->i);\n\n\tvideobuf_vm_open(vma);\n\n\treturn 0;\n\nerror:\n\tmem = NULL;\n\tkfree(map);\n\treturn -ENOMEM;\n}\n\nstatic struct videobuf_qtype_ops qops = {\n\t.magic        = MAGIC_QTYPE_OPS,\n\n\t.alloc_vb     = __videobuf_alloc_vb,\n\t.iolock       = __videobuf_iolock,\n\t.mmap_mapper  = __videobuf_mmap_mapper,\n\t.vaddr        = videobuf_to_vmalloc,\n};\n\nvoid videobuf_queue_vmalloc_init(struct videobuf_queue *q,\n\t\t\t const struct videobuf_queue_ops *ops,\n\t\t\t struct device *dev,\n\t\t\t spinlock_t *irqlock,\n\t\t\t enum v4l2_buf_type type,\n\t\t\t enum v4l2_field field,\n\t\t\t unsigned int msize,\n\t\t\t void *priv,\n\t\t\t struct mutex *ext_lock)\n{\n\tvideobuf_queue_core_init(q, ops, dev, irqlock, type, field, msize,\n\t\t\t\t priv, &qops, ext_lock);\n}\nEXPORT_SYMBOL_GPL(videobuf_queue_vmalloc_init);\n\nvoid *videobuf_to_vmalloc(struct videobuf_buffer *buf)\n{\n\tstruct videobuf_vmalloc_memory *mem = buf->priv;\n\tBUG_ON(!mem);\n\tMAGIC_CHECK(mem->magic, MAGIC_VMAL_MEM);\n\n\treturn mem->vaddr;\n}\nEXPORT_SYMBOL_GPL(videobuf_to_vmalloc);\n\nvoid videobuf_vmalloc_free(struct videobuf_buffer *buf)\n{\n\tstruct videobuf_vmalloc_memory *mem = buf->priv;\n\n\t \n\tif ((buf->memory != V4L2_MEMORY_USERPTR) || buf->baddr)\n\t\treturn;\n\n\tif (!mem)\n\t\treturn;\n\n\tMAGIC_CHECK(mem->magic, MAGIC_VMAL_MEM);\n\n\tvfree(mem->vaddr);\n\tmem->vaddr = NULL;\n\n\treturn;\n}\nEXPORT_SYMBOL_GPL(videobuf_vmalloc_free);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}