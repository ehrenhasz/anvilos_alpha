{
  "module_name": "v4l2-dev.c",
  "hash_id": "a6583a88ad10eaf15877ffa8c4497212045dec5ad7c96c5d9a62931d6711a966",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/v4l2-dev.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n\n#define VIDEO_NUM_DEVICES\t256\n#define VIDEO_NAME              \"video4linux\"\n\n#define dprintk(fmt, arg...) do {\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt),\t\t\t\\\n\t\t       __func__, ##arg);\t\t\t\t\\\n} while (0)\n\n \n\nstatic ssize_t index_show(struct device *cd,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct video_device *vdev = to_video_device(cd);\n\n\treturn sprintf(buf, \"%i\\n\", vdev->index);\n}\nstatic DEVICE_ATTR_RO(index);\n\nstatic ssize_t dev_debug_show(struct device *cd,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct video_device *vdev = to_video_device(cd);\n\n\treturn sprintf(buf, \"%i\\n\", vdev->dev_debug);\n}\n\nstatic ssize_t dev_debug_store(struct device *cd, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t len)\n{\n\tstruct video_device *vdev = to_video_device(cd);\n\tint res = 0;\n\tu16 value;\n\n\tres = kstrtou16(buf, 0, &value);\n\tif (res)\n\t\treturn res;\n\n\tvdev->dev_debug = value;\n\treturn len;\n}\nstatic DEVICE_ATTR_RW(dev_debug);\n\nstatic ssize_t name_show(struct device *cd,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct video_device *vdev = to_video_device(cd);\n\n\treturn sprintf(buf, \"%.*s\\n\", (int)sizeof(vdev->name), vdev->name);\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic struct attribute *video_device_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_dev_debug.attr,\n\t&dev_attr_index.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(video_device);\n\n \nstatic struct video_device *video_devices[VIDEO_NUM_DEVICES];\nstatic DEFINE_MUTEX(videodev_lock);\nstatic DECLARE_BITMAP(devnode_nums[VFL_TYPE_MAX], VIDEO_NUM_DEVICES);\n\n \n\n \n\n#ifdef CONFIG_VIDEO_FIXED_MINOR_RANGES\n \nstatic inline unsigned long *devnode_bits(enum vfl_devnode_type vfl_type)\n{\n\t \n\tint idx = (vfl_type > VFL_TYPE_RADIO) ? VFL_TYPE_MAX - 1 : vfl_type;\n\n\treturn devnode_nums[idx];\n}\n#else\n \nstatic inline unsigned long *devnode_bits(enum vfl_devnode_type vfl_type)\n{\n\treturn devnode_nums[vfl_type];\n}\n#endif\n\n \nstatic inline void devnode_set(struct video_device *vdev)\n{\n\tset_bit(vdev->num, devnode_bits(vdev->vfl_type));\n}\n\n \nstatic inline void devnode_clear(struct video_device *vdev)\n{\n\tclear_bit(vdev->num, devnode_bits(vdev->vfl_type));\n}\n\n \nstatic inline int devnode_find(struct video_device *vdev, int from, int to)\n{\n\treturn find_next_zero_bit(devnode_bits(vdev->vfl_type), to, from);\n}\n\nstruct video_device *video_device_alloc(void)\n{\n\treturn kzalloc(sizeof(struct video_device), GFP_KERNEL);\n}\nEXPORT_SYMBOL(video_device_alloc);\n\nvoid video_device_release(struct video_device *vdev)\n{\n\tkfree(vdev);\n}\nEXPORT_SYMBOL(video_device_release);\n\nvoid video_device_release_empty(struct video_device *vdev)\n{\n\t \n\t \n}\nEXPORT_SYMBOL(video_device_release_empty);\n\nstatic inline void video_get(struct video_device *vdev)\n{\n\tget_device(&vdev->dev);\n}\n\nstatic inline void video_put(struct video_device *vdev)\n{\n\tput_device(&vdev->dev);\n}\n\n \nstatic void v4l2_device_release(struct device *cd)\n{\n\tstruct video_device *vdev = to_video_device(cd);\n\tstruct v4l2_device *v4l2_dev = vdev->v4l2_dev;\n\n\tmutex_lock(&videodev_lock);\n\tif (WARN_ON(video_devices[vdev->minor] != vdev)) {\n\t\t \n\t\tmutex_unlock(&videodev_lock);\n\t\treturn;\n\t}\n\n\t \n\tvideo_devices[vdev->minor] = NULL;\n\n\t \n\tcdev_del(vdev->cdev);\n\t \n\tvdev->cdev = NULL;\n\n\t \n\tdevnode_clear(vdev);\n\n\tmutex_unlock(&videodev_lock);\n\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tif (v4l2_dev->mdev && vdev->vfl_dir != VFL_DIR_M2M) {\n\t\t \n\t\tmedia_devnode_remove(vdev->intf_devnode);\n\t\tif (vdev->entity.function != MEDIA_ENT_F_UNKNOWN)\n\t\t\tmedia_device_unregister_entity(&vdev->entity);\n\t}\n#endif\n\n\t \n\tif (v4l2_dev->release == NULL)\n\t\tv4l2_dev = NULL;\n\n\t \n\tvdev->release(vdev);\n\n\t \n\tif (v4l2_dev)\n\t\tv4l2_device_put(v4l2_dev);\n}\n\nstatic struct class video_class = {\n\t.name = VIDEO_NAME,\n\t.dev_groups = video_device_groups,\n};\n\nstruct video_device *video_devdata(struct file *file)\n{\n\treturn video_devices[iminor(file_inode(file))];\n}\nEXPORT_SYMBOL(video_devdata);\n\n\n \n\nstatic inline bool prio_is_valid(enum v4l2_priority prio)\n{\n\treturn prio == V4L2_PRIORITY_BACKGROUND ||\n\t       prio == V4L2_PRIORITY_INTERACTIVE ||\n\t       prio == V4L2_PRIORITY_RECORD;\n}\n\nvoid v4l2_prio_init(struct v4l2_prio_state *global)\n{\n\tmemset(global, 0, sizeof(*global));\n}\nEXPORT_SYMBOL(v4l2_prio_init);\n\nint v4l2_prio_change(struct v4l2_prio_state *global, enum v4l2_priority *local,\n\t\t     enum v4l2_priority new)\n{\n\tif (!prio_is_valid(new))\n\t\treturn -EINVAL;\n\tif (*local == new)\n\t\treturn 0;\n\n\tatomic_inc(&global->prios[new]);\n\tif (prio_is_valid(*local))\n\t\tatomic_dec(&global->prios[*local]);\n\t*local = new;\n\treturn 0;\n}\nEXPORT_SYMBOL(v4l2_prio_change);\n\nvoid v4l2_prio_open(struct v4l2_prio_state *global, enum v4l2_priority *local)\n{\n\tv4l2_prio_change(global, local, V4L2_PRIORITY_DEFAULT);\n}\nEXPORT_SYMBOL(v4l2_prio_open);\n\nvoid v4l2_prio_close(struct v4l2_prio_state *global, enum v4l2_priority local)\n{\n\tif (prio_is_valid(local))\n\t\tatomic_dec(&global->prios[local]);\n}\nEXPORT_SYMBOL(v4l2_prio_close);\n\nenum v4l2_priority v4l2_prio_max(struct v4l2_prio_state *global)\n{\n\tif (atomic_read(&global->prios[V4L2_PRIORITY_RECORD]) > 0)\n\t\treturn V4L2_PRIORITY_RECORD;\n\tif (atomic_read(&global->prios[V4L2_PRIORITY_INTERACTIVE]) > 0)\n\t\treturn V4L2_PRIORITY_INTERACTIVE;\n\tif (atomic_read(&global->prios[V4L2_PRIORITY_BACKGROUND]) > 0)\n\t\treturn V4L2_PRIORITY_BACKGROUND;\n\treturn V4L2_PRIORITY_UNSET;\n}\nEXPORT_SYMBOL(v4l2_prio_max);\n\nint v4l2_prio_check(struct v4l2_prio_state *global, enum v4l2_priority local)\n{\n\treturn (local < v4l2_prio_max(global)) ? -EBUSY : 0;\n}\nEXPORT_SYMBOL(v4l2_prio_check);\n\n\nstatic ssize_t v4l2_read(struct file *filp, char __user *buf,\n\t\tsize_t sz, loff_t *off)\n{\n\tstruct video_device *vdev = video_devdata(filp);\n\tint ret = -ENODEV;\n\n\tif (!vdev->fops->read)\n\t\treturn -EINVAL;\n\tif (video_is_registered(vdev))\n\t\tret = vdev->fops->read(filp, buf, sz, off);\n\tif ((vdev->dev_debug & V4L2_DEV_DEBUG_FOP) &&\n\t    (vdev->dev_debug & V4L2_DEV_DEBUG_STREAMING))\n\t\tdprintk(\"%s: read: %zd (%d)\\n\",\n\t\t\tvideo_device_node_name(vdev), sz, ret);\n\treturn ret;\n}\n\nstatic ssize_t v4l2_write(struct file *filp, const char __user *buf,\n\t\tsize_t sz, loff_t *off)\n{\n\tstruct video_device *vdev = video_devdata(filp);\n\tint ret = -ENODEV;\n\n\tif (!vdev->fops->write)\n\t\treturn -EINVAL;\n\tif (video_is_registered(vdev))\n\t\tret = vdev->fops->write(filp, buf, sz, off);\n\tif ((vdev->dev_debug & V4L2_DEV_DEBUG_FOP) &&\n\t    (vdev->dev_debug & V4L2_DEV_DEBUG_STREAMING))\n\t\tdprintk(\"%s: write: %zd (%d)\\n\",\n\t\t\tvideo_device_node_name(vdev), sz, ret);\n\treturn ret;\n}\n\nstatic __poll_t v4l2_poll(struct file *filp, struct poll_table_struct *poll)\n{\n\tstruct video_device *vdev = video_devdata(filp);\n\t__poll_t res = EPOLLERR | EPOLLHUP | EPOLLPRI;\n\n\tif (video_is_registered(vdev)) {\n\t\tif (!vdev->fops->poll)\n\t\t\tres = DEFAULT_POLLMASK;\n\t\telse\n\t\t\tres = vdev->fops->poll(filp, poll);\n\t}\n\tif (vdev->dev_debug & V4L2_DEV_DEBUG_POLL)\n\t\tdprintk(\"%s: poll: %08x %08x\\n\",\n\t\t\tvideo_device_node_name(vdev), res,\n\t\t\tpoll_requested_events(poll));\n\treturn res;\n}\n\nstatic long v4l2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct video_device *vdev = video_devdata(filp);\n\tint ret = -ENODEV;\n\n\tif (vdev->fops->unlocked_ioctl) {\n\t\tif (video_is_registered(vdev))\n\t\t\tret = vdev->fops->unlocked_ioctl(filp, cmd, arg);\n\t} else\n\t\tret = -ENOTTY;\n\n\treturn ret;\n}\n\n#ifdef CONFIG_MMU\n#define v4l2_get_unmapped_area NULL\n#else\nstatic unsigned long v4l2_get_unmapped_area(struct file *filp,\n\t\tunsigned long addr, unsigned long len, unsigned long pgoff,\n\t\tunsigned long flags)\n{\n\tstruct video_device *vdev = video_devdata(filp);\n\tint ret;\n\n\tif (!vdev->fops->get_unmapped_area)\n\t\treturn -ENOSYS;\n\tif (!video_is_registered(vdev))\n\t\treturn -ENODEV;\n\tret = vdev->fops->get_unmapped_area(filp, addr, len, pgoff, flags);\n\tif (vdev->dev_debug & V4L2_DEV_DEBUG_FOP)\n\t\tdprintk(\"%s: get_unmapped_area (%d)\\n\",\n\t\t\tvideo_device_node_name(vdev), ret);\n\treturn ret;\n}\n#endif\n\nstatic int v4l2_mmap(struct file *filp, struct vm_area_struct *vm)\n{\n\tstruct video_device *vdev = video_devdata(filp);\n\tint ret = -ENODEV;\n\n\tif (!vdev->fops->mmap)\n\t\treturn -ENODEV;\n\tif (video_is_registered(vdev))\n\t\tret = vdev->fops->mmap(filp, vm);\n\tif (vdev->dev_debug & V4L2_DEV_DEBUG_FOP)\n\t\tdprintk(\"%s: mmap (%d)\\n\",\n\t\t\tvideo_device_node_name(vdev), ret);\n\treturn ret;\n}\n\n \nstatic int v4l2_open(struct inode *inode, struct file *filp)\n{\n\tstruct video_device *vdev;\n\tint ret = 0;\n\n\t \n\tmutex_lock(&videodev_lock);\n\tvdev = video_devdata(filp);\n\t \n\tif (vdev == NULL || !video_is_registered(vdev)) {\n\t\tmutex_unlock(&videodev_lock);\n\t\treturn -ENODEV;\n\t}\n\t \n\tvideo_get(vdev);\n\tmutex_unlock(&videodev_lock);\n\tif (vdev->fops->open) {\n\t\tif (video_is_registered(vdev))\n\t\t\tret = vdev->fops->open(filp);\n\t\telse\n\t\t\tret = -ENODEV;\n\t}\n\n\tif (vdev->dev_debug & V4L2_DEV_DEBUG_FOP)\n\t\tdprintk(\"%s: open (%d)\\n\",\n\t\t\tvideo_device_node_name(vdev), ret);\n\t \n\tif (ret)\n\t\tvideo_put(vdev);\n\treturn ret;\n}\n\n \nstatic int v4l2_release(struct inode *inode, struct file *filp)\n{\n\tstruct video_device *vdev = video_devdata(filp);\n\tint ret = 0;\n\n\t \n\tif (vdev->fops->release) {\n\t\tif (v4l2_device_supports_requests(vdev->v4l2_dev)) {\n\t\t\tmutex_lock(&vdev->v4l2_dev->mdev->req_queue_mutex);\n\t\t\tret = vdev->fops->release(filp);\n\t\t\tmutex_unlock(&vdev->v4l2_dev->mdev->req_queue_mutex);\n\t\t} else {\n\t\t\tret = vdev->fops->release(filp);\n\t\t}\n\t}\n\n\tif (vdev->dev_debug & V4L2_DEV_DEBUG_FOP)\n\t\tdprintk(\"%s: release\\n\",\n\t\t\tvideo_device_node_name(vdev));\n\n\t \n\tvideo_put(vdev);\n\treturn ret;\n}\n\nstatic const struct file_operations v4l2_fops = {\n\t.owner = THIS_MODULE,\n\t.read = v4l2_read,\n\t.write = v4l2_write,\n\t.open = v4l2_open,\n\t.get_unmapped_area = v4l2_get_unmapped_area,\n\t.mmap = v4l2_mmap,\n\t.unlocked_ioctl = v4l2_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = v4l2_compat_ioctl32,\n#endif\n\t.release = v4l2_release,\n\t.poll = v4l2_poll,\n\t.llseek = no_llseek,\n};\n\n \nstatic int get_index(struct video_device *vdev)\n{\n\t \n\tstatic DECLARE_BITMAP(used, VIDEO_NUM_DEVICES);\n\tint i;\n\n\tbitmap_zero(used, VIDEO_NUM_DEVICES);\n\n\tfor (i = 0; i < VIDEO_NUM_DEVICES; i++) {\n\t\tif (video_devices[i] != NULL &&\n\t\t    video_devices[i]->v4l2_dev == vdev->v4l2_dev) {\n\t\t\t__set_bit(video_devices[i]->index, used);\n\t\t}\n\t}\n\n\treturn find_first_zero_bit(used, VIDEO_NUM_DEVICES);\n}\n\n#define SET_VALID_IOCTL(ops, cmd, op) \\\n\tdo { if ((ops)->op) __set_bit(_IOC_NR(cmd), valid_ioctls); } while (0)\n\n \nstatic void determine_valid_ioctls(struct video_device *vdev)\n{\n\tconst u32 vid_caps = V4L2_CAP_VIDEO_CAPTURE |\n\t\t\t     V4L2_CAP_VIDEO_CAPTURE_MPLANE |\n\t\t\t     V4L2_CAP_VIDEO_OUTPUT |\n\t\t\t     V4L2_CAP_VIDEO_OUTPUT_MPLANE |\n\t\t\t     V4L2_CAP_VIDEO_M2M | V4L2_CAP_VIDEO_M2M_MPLANE;\n\tconst u32 meta_caps = V4L2_CAP_META_CAPTURE |\n\t\t\t      V4L2_CAP_META_OUTPUT;\n\tDECLARE_BITMAP(valid_ioctls, BASE_VIDIOC_PRIVATE);\n\tconst struct v4l2_ioctl_ops *ops = vdev->ioctl_ops;\n\tbool is_vid = vdev->vfl_type == VFL_TYPE_VIDEO &&\n\t\t      (vdev->device_caps & vid_caps);\n\tbool is_vbi = vdev->vfl_type == VFL_TYPE_VBI;\n\tbool is_radio = vdev->vfl_type == VFL_TYPE_RADIO;\n\tbool is_sdr = vdev->vfl_type == VFL_TYPE_SDR;\n\tbool is_tch = vdev->vfl_type == VFL_TYPE_TOUCH;\n\tbool is_meta = vdev->vfl_type == VFL_TYPE_VIDEO &&\n\t\t       (vdev->device_caps & meta_caps);\n\tbool is_rx = vdev->vfl_dir != VFL_DIR_TX;\n\tbool is_tx = vdev->vfl_dir != VFL_DIR_RX;\n\tbool is_io_mc = vdev->device_caps & V4L2_CAP_IO_MC;\n\tbool has_streaming = vdev->device_caps & V4L2_CAP_STREAMING;\n\n\tbitmap_zero(valid_ioctls, BASE_VIDIOC_PRIVATE);\n\n\t \n\n\tSET_VALID_IOCTL(ops, VIDIOC_QUERYCAP, vidioc_querycap);\n\t__set_bit(_IOC_NR(VIDIOC_G_PRIORITY), valid_ioctls);\n\t__set_bit(_IOC_NR(VIDIOC_S_PRIORITY), valid_ioctls);\n\n\t \n\tif (vdev->ctrl_handler || ops->vidioc_queryctrl)\n\t\t__set_bit(_IOC_NR(VIDIOC_QUERYCTRL), valid_ioctls);\n\tif (vdev->ctrl_handler || ops->vidioc_query_ext_ctrl)\n\t\t__set_bit(_IOC_NR(VIDIOC_QUERY_EXT_CTRL), valid_ioctls);\n\tif (vdev->ctrl_handler || ops->vidioc_g_ctrl || ops->vidioc_g_ext_ctrls)\n\t\t__set_bit(_IOC_NR(VIDIOC_G_CTRL), valid_ioctls);\n\tif (vdev->ctrl_handler || ops->vidioc_s_ctrl || ops->vidioc_s_ext_ctrls)\n\t\t__set_bit(_IOC_NR(VIDIOC_S_CTRL), valid_ioctls);\n\tif (vdev->ctrl_handler || ops->vidioc_g_ext_ctrls)\n\t\t__set_bit(_IOC_NR(VIDIOC_G_EXT_CTRLS), valid_ioctls);\n\tif (vdev->ctrl_handler || ops->vidioc_s_ext_ctrls)\n\t\t__set_bit(_IOC_NR(VIDIOC_S_EXT_CTRLS), valid_ioctls);\n\tif (vdev->ctrl_handler || ops->vidioc_try_ext_ctrls)\n\t\t__set_bit(_IOC_NR(VIDIOC_TRY_EXT_CTRLS), valid_ioctls);\n\tif (vdev->ctrl_handler || ops->vidioc_querymenu)\n\t\t__set_bit(_IOC_NR(VIDIOC_QUERYMENU), valid_ioctls);\n\tif (!is_tch) {\n\t\tSET_VALID_IOCTL(ops, VIDIOC_G_FREQUENCY, vidioc_g_frequency);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_S_FREQUENCY, vidioc_s_frequency);\n\t}\n\tSET_VALID_IOCTL(ops, VIDIOC_LOG_STATUS, vidioc_log_status);\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t__set_bit(_IOC_NR(VIDIOC_DBG_G_CHIP_INFO), valid_ioctls);\n\t__set_bit(_IOC_NR(VIDIOC_DBG_G_REGISTER), valid_ioctls);\n\t__set_bit(_IOC_NR(VIDIOC_DBG_S_REGISTER), valid_ioctls);\n#endif\n\t \n\tSET_VALID_IOCTL(ops, VIDIOC_DQEVENT, vidioc_subscribe_event);\n\tSET_VALID_IOCTL(ops, VIDIOC_SUBSCRIBE_EVENT, vidioc_subscribe_event);\n\tSET_VALID_IOCTL(ops, VIDIOC_UNSUBSCRIBE_EVENT, vidioc_unsubscribe_event);\n\tif (ops->vidioc_enum_freq_bands || ops->vidioc_g_tuner || ops->vidioc_g_modulator)\n\t\t__set_bit(_IOC_NR(VIDIOC_ENUM_FREQ_BANDS), valid_ioctls);\n\n\tif (is_vid) {\n\t\t \n\t\tif ((is_rx && (ops->vidioc_enum_fmt_vid_cap ||\n\t\t\t       ops->vidioc_enum_fmt_vid_overlay)) ||\n\t\t    (is_tx && ops->vidioc_enum_fmt_vid_out))\n\t\t\t__set_bit(_IOC_NR(VIDIOC_ENUM_FMT), valid_ioctls);\n\t\tif ((is_rx && (ops->vidioc_g_fmt_vid_cap ||\n\t\t\t       ops->vidioc_g_fmt_vid_cap_mplane ||\n\t\t\t       ops->vidioc_g_fmt_vid_overlay)) ||\n\t\t    (is_tx && (ops->vidioc_g_fmt_vid_out ||\n\t\t\t       ops->vidioc_g_fmt_vid_out_mplane ||\n\t\t\t       ops->vidioc_g_fmt_vid_out_overlay)))\n\t\t\t__set_bit(_IOC_NR(VIDIOC_G_FMT), valid_ioctls);\n\t\tif ((is_rx && (ops->vidioc_s_fmt_vid_cap ||\n\t\t\t       ops->vidioc_s_fmt_vid_cap_mplane ||\n\t\t\t       ops->vidioc_s_fmt_vid_overlay)) ||\n\t\t    (is_tx && (ops->vidioc_s_fmt_vid_out ||\n\t\t\t       ops->vidioc_s_fmt_vid_out_mplane ||\n\t\t\t       ops->vidioc_s_fmt_vid_out_overlay)))\n\t\t\t__set_bit(_IOC_NR(VIDIOC_S_FMT), valid_ioctls);\n\t\tif ((is_rx && (ops->vidioc_try_fmt_vid_cap ||\n\t\t\t       ops->vidioc_try_fmt_vid_cap_mplane ||\n\t\t\t       ops->vidioc_try_fmt_vid_overlay)) ||\n\t\t    (is_tx && (ops->vidioc_try_fmt_vid_out ||\n\t\t\t       ops->vidioc_try_fmt_vid_out_mplane ||\n\t\t\t       ops->vidioc_try_fmt_vid_out_overlay)))\n\t\t\t__set_bit(_IOC_NR(VIDIOC_TRY_FMT), valid_ioctls);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_OVERLAY, vidioc_overlay);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_G_FBUF, vidioc_g_fbuf);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_S_FBUF, vidioc_s_fbuf);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_G_JPEGCOMP, vidioc_g_jpegcomp);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_S_JPEGCOMP, vidioc_s_jpegcomp);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_G_ENC_INDEX, vidioc_g_enc_index);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_ENCODER_CMD, vidioc_encoder_cmd);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_TRY_ENCODER_CMD, vidioc_try_encoder_cmd);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_DECODER_CMD, vidioc_decoder_cmd);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_TRY_DECODER_CMD, vidioc_try_decoder_cmd);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_ENUM_FRAMESIZES, vidioc_enum_framesizes);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_ENUM_FRAMEINTERVALS, vidioc_enum_frameintervals);\n\t\tif (ops->vidioc_g_selection) {\n\t\t\t__set_bit(_IOC_NR(VIDIOC_G_CROP), valid_ioctls);\n\t\t\t__set_bit(_IOC_NR(VIDIOC_CROPCAP), valid_ioctls);\n\t\t}\n\t\tif (ops->vidioc_s_selection)\n\t\t\t__set_bit(_IOC_NR(VIDIOC_S_CROP), valid_ioctls);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_G_SELECTION, vidioc_g_selection);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_S_SELECTION, vidioc_s_selection);\n\t}\n\tif (is_meta && is_rx) {\n\t\t \n\t\tSET_VALID_IOCTL(ops, VIDIOC_ENUM_FMT, vidioc_enum_fmt_meta_cap);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_G_FMT, vidioc_g_fmt_meta_cap);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_S_FMT, vidioc_s_fmt_meta_cap);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_TRY_FMT, vidioc_try_fmt_meta_cap);\n\t} else if (is_meta && is_tx) {\n\t\t \n\t\tSET_VALID_IOCTL(ops, VIDIOC_ENUM_FMT, vidioc_enum_fmt_meta_out);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_G_FMT, vidioc_g_fmt_meta_out);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_S_FMT, vidioc_s_fmt_meta_out);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_TRY_FMT, vidioc_try_fmt_meta_out);\n\t}\n\tif (is_vbi) {\n\t\t \n\t\tif ((is_rx && (ops->vidioc_g_fmt_vbi_cap ||\n\t\t\t       ops->vidioc_g_fmt_sliced_vbi_cap)) ||\n\t\t    (is_tx && (ops->vidioc_g_fmt_vbi_out ||\n\t\t\t       ops->vidioc_g_fmt_sliced_vbi_out)))\n\t\t\t__set_bit(_IOC_NR(VIDIOC_G_FMT), valid_ioctls);\n\t\tif ((is_rx && (ops->vidioc_s_fmt_vbi_cap ||\n\t\t\t       ops->vidioc_s_fmt_sliced_vbi_cap)) ||\n\t\t    (is_tx && (ops->vidioc_s_fmt_vbi_out ||\n\t\t\t       ops->vidioc_s_fmt_sliced_vbi_out)))\n\t\t\t__set_bit(_IOC_NR(VIDIOC_S_FMT), valid_ioctls);\n\t\tif ((is_rx && (ops->vidioc_try_fmt_vbi_cap ||\n\t\t\t       ops->vidioc_try_fmt_sliced_vbi_cap)) ||\n\t\t    (is_tx && (ops->vidioc_try_fmt_vbi_out ||\n\t\t\t       ops->vidioc_try_fmt_sliced_vbi_out)))\n\t\t\t__set_bit(_IOC_NR(VIDIOC_TRY_FMT), valid_ioctls);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_G_SLICED_VBI_CAP, vidioc_g_sliced_vbi_cap);\n\t} else if (is_tch) {\n\t\t \n\t\tSET_VALID_IOCTL(ops, VIDIOC_ENUM_FMT, vidioc_enum_fmt_vid_cap);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_G_FMT, vidioc_g_fmt_vid_cap);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_S_FMT, vidioc_s_fmt_vid_cap);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_TRY_FMT, vidioc_try_fmt_vid_cap);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_ENUM_FRAMESIZES, vidioc_enum_framesizes);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_ENUM_FRAMEINTERVALS, vidioc_enum_frameintervals);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_ENUMINPUT, vidioc_enum_input);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_G_INPUT, vidioc_g_input);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_S_INPUT, vidioc_s_input);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_G_PARM, vidioc_g_parm);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_S_PARM, vidioc_s_parm);\n\t} else if (is_sdr && is_rx) {\n\t\t \n\t\tSET_VALID_IOCTL(ops, VIDIOC_ENUM_FMT, vidioc_enum_fmt_sdr_cap);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_G_FMT, vidioc_g_fmt_sdr_cap);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_S_FMT, vidioc_s_fmt_sdr_cap);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_TRY_FMT, vidioc_try_fmt_sdr_cap);\n\t} else if (is_sdr && is_tx) {\n\t\t \n\t\tSET_VALID_IOCTL(ops, VIDIOC_ENUM_FMT, vidioc_enum_fmt_sdr_out);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_G_FMT, vidioc_g_fmt_sdr_out);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_S_FMT, vidioc_s_fmt_sdr_out);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_TRY_FMT, vidioc_try_fmt_sdr_out);\n\t}\n\n\tif (has_streaming) {\n\t\t \n\t\tSET_VALID_IOCTL(ops, VIDIOC_REQBUFS, vidioc_reqbufs);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_QUERYBUF, vidioc_querybuf);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_QBUF, vidioc_qbuf);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_EXPBUF, vidioc_expbuf);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_DQBUF, vidioc_dqbuf);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_CREATE_BUFS, vidioc_create_bufs);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_PREPARE_BUF, vidioc_prepare_buf);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_STREAMON, vidioc_streamon);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_STREAMOFF, vidioc_streamoff);\n\t}\n\n\tif (is_vid || is_vbi || is_meta) {\n\t\t \n\t\tif (ops->vidioc_s_std)\n\t\t\t__set_bit(_IOC_NR(VIDIOC_ENUMSTD), valid_ioctls);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_S_STD, vidioc_s_std);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_G_STD, vidioc_g_std);\n\t\tif (is_rx) {\n\t\t\tSET_VALID_IOCTL(ops, VIDIOC_QUERYSTD, vidioc_querystd);\n\t\t\tif (is_io_mc) {\n\t\t\t\t__set_bit(_IOC_NR(VIDIOC_ENUMINPUT), valid_ioctls);\n\t\t\t\t__set_bit(_IOC_NR(VIDIOC_G_INPUT), valid_ioctls);\n\t\t\t\t__set_bit(_IOC_NR(VIDIOC_S_INPUT), valid_ioctls);\n\t\t\t} else {\n\t\t\t\tSET_VALID_IOCTL(ops, VIDIOC_ENUMINPUT, vidioc_enum_input);\n\t\t\t\tSET_VALID_IOCTL(ops, VIDIOC_G_INPUT, vidioc_g_input);\n\t\t\t\tSET_VALID_IOCTL(ops, VIDIOC_S_INPUT, vidioc_s_input);\n\t\t\t}\n\t\t\tSET_VALID_IOCTL(ops, VIDIOC_ENUMAUDIO, vidioc_enumaudio);\n\t\t\tSET_VALID_IOCTL(ops, VIDIOC_G_AUDIO, vidioc_g_audio);\n\t\t\tSET_VALID_IOCTL(ops, VIDIOC_S_AUDIO, vidioc_s_audio);\n\t\t\tSET_VALID_IOCTL(ops, VIDIOC_QUERY_DV_TIMINGS, vidioc_query_dv_timings);\n\t\t\tSET_VALID_IOCTL(ops, VIDIOC_S_EDID, vidioc_s_edid);\n\t\t}\n\t\tif (is_tx) {\n\t\t\tif (is_io_mc) {\n\t\t\t\t__set_bit(_IOC_NR(VIDIOC_ENUMOUTPUT), valid_ioctls);\n\t\t\t\t__set_bit(_IOC_NR(VIDIOC_G_OUTPUT), valid_ioctls);\n\t\t\t\t__set_bit(_IOC_NR(VIDIOC_S_OUTPUT), valid_ioctls);\n\t\t\t} else {\n\t\t\t\tSET_VALID_IOCTL(ops, VIDIOC_ENUMOUTPUT, vidioc_enum_output);\n\t\t\t\tSET_VALID_IOCTL(ops, VIDIOC_G_OUTPUT, vidioc_g_output);\n\t\t\t\tSET_VALID_IOCTL(ops, VIDIOC_S_OUTPUT, vidioc_s_output);\n\t\t\t}\n\t\t\tSET_VALID_IOCTL(ops, VIDIOC_ENUMAUDOUT, vidioc_enumaudout);\n\t\t\tSET_VALID_IOCTL(ops, VIDIOC_G_AUDOUT, vidioc_g_audout);\n\t\t\tSET_VALID_IOCTL(ops, VIDIOC_S_AUDOUT, vidioc_s_audout);\n\t\t}\n\t\tif (ops->vidioc_g_parm || ops->vidioc_g_std)\n\t\t\t__set_bit(_IOC_NR(VIDIOC_G_PARM), valid_ioctls);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_S_PARM, vidioc_s_parm);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_S_DV_TIMINGS, vidioc_s_dv_timings);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_G_DV_TIMINGS, vidioc_g_dv_timings);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_ENUM_DV_TIMINGS, vidioc_enum_dv_timings);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_DV_TIMINGS_CAP, vidioc_dv_timings_cap);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_G_EDID, vidioc_g_edid);\n\t}\n\tif (is_tx && (is_radio || is_sdr)) {\n\t\t \n\t\tSET_VALID_IOCTL(ops, VIDIOC_G_MODULATOR, vidioc_g_modulator);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_S_MODULATOR, vidioc_s_modulator);\n\t}\n\tif (is_rx && !is_tch) {\n\t\t \n\t\tSET_VALID_IOCTL(ops, VIDIOC_G_TUNER, vidioc_g_tuner);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_S_TUNER, vidioc_s_tuner);\n\t\tSET_VALID_IOCTL(ops, VIDIOC_S_HW_FREQ_SEEK, vidioc_s_hw_freq_seek);\n\t}\n\n\tbitmap_andnot(vdev->valid_ioctls, valid_ioctls, vdev->valid_ioctls,\n\t\t\tBASE_VIDIOC_PRIVATE);\n}\n\nstatic int video_register_media_controller(struct video_device *vdev)\n{\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tu32 intf_type;\n\tint ret;\n\n\t \n\tif (!vdev->v4l2_dev->mdev || vdev->vfl_dir == VFL_DIR_M2M)\n\t\treturn 0;\n\n\tvdev->entity.obj_type = MEDIA_ENTITY_TYPE_VIDEO_DEVICE;\n\tvdev->entity.function = MEDIA_ENT_F_UNKNOWN;\n\n\tswitch (vdev->vfl_type) {\n\tcase VFL_TYPE_VIDEO:\n\t\tintf_type = MEDIA_INTF_T_V4L_VIDEO;\n\t\tvdev->entity.function = MEDIA_ENT_F_IO_V4L;\n\t\tbreak;\n\tcase VFL_TYPE_VBI:\n\t\tintf_type = MEDIA_INTF_T_V4L_VBI;\n\t\tvdev->entity.function = MEDIA_ENT_F_IO_VBI;\n\t\tbreak;\n\tcase VFL_TYPE_SDR:\n\t\tintf_type = MEDIA_INTF_T_V4L_SWRADIO;\n\t\tvdev->entity.function = MEDIA_ENT_F_IO_SWRADIO;\n\t\tbreak;\n\tcase VFL_TYPE_TOUCH:\n\t\tintf_type = MEDIA_INTF_T_V4L_TOUCH;\n\t\tvdev->entity.function = MEDIA_ENT_F_IO_V4L;\n\t\tbreak;\n\tcase VFL_TYPE_RADIO:\n\t\tintf_type = MEDIA_INTF_T_V4L_RADIO;\n\t\t \n\t\tbreak;\n\tcase VFL_TYPE_SUBDEV:\n\t\tintf_type = MEDIA_INTF_T_V4L_SUBDEV;\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (vdev->entity.function != MEDIA_ENT_F_UNKNOWN) {\n\t\tvdev->entity.name = vdev->name;\n\n\t\t \n\t\tvdev->entity.info.dev.major = VIDEO_MAJOR;\n\t\tvdev->entity.info.dev.minor = vdev->minor;\n\n\t\tret = media_device_register_entity(vdev->v4l2_dev->mdev,\n\t\t\t\t\t\t   &vdev->entity);\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"%s: media_device_register_entity failed\\n\",\n\t\t\t\t__func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tvdev->intf_devnode = media_devnode_create(vdev->v4l2_dev->mdev,\n\t\t\t\t\t\t  intf_type,\n\t\t\t\t\t\t  0, VIDEO_MAJOR,\n\t\t\t\t\t\t  vdev->minor);\n\tif (!vdev->intf_devnode) {\n\t\tmedia_device_unregister_entity(&vdev->entity);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (vdev->entity.function != MEDIA_ENT_F_UNKNOWN) {\n\t\tstruct media_link *link;\n\n\t\tlink = media_create_intf_link(&vdev->entity,\n\t\t\t\t\t      &vdev->intf_devnode->intf,\n\t\t\t\t\t      MEDIA_LNK_FL_ENABLED |\n\t\t\t\t\t      MEDIA_LNK_FL_IMMUTABLE);\n\t\tif (!link) {\n\t\t\tmedia_devnode_remove(vdev->intf_devnode);\n\t\t\tmedia_device_unregister_entity(&vdev->entity);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\n#endif\n\treturn 0;\n}\n\nint __video_register_device(struct video_device *vdev,\n\t\t\t    enum vfl_devnode_type type,\n\t\t\t    int nr, int warn_if_nr_in_use,\n\t\t\t    struct module *owner)\n{\n\tint i = 0;\n\tint ret;\n\tint minor_offset = 0;\n\tint minor_cnt = VIDEO_NUM_DEVICES;\n\tconst char *name_base;\n\n\t \n\tvdev->minor = -1;\n\n\t \n\tif (WARN_ON(!vdev->release))\n\t\treturn -EINVAL;\n\t \n\tif (WARN_ON(!vdev->v4l2_dev))\n\t\treturn -EINVAL;\n\t \n\tif (WARN_ON(type != VFL_TYPE_SUBDEV && !vdev->device_caps))\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock_init(&vdev->fh_lock);\n\tINIT_LIST_HEAD(&vdev->fh_list);\n\n\t \n\tswitch (type) {\n\tcase VFL_TYPE_VIDEO:\n\t\tname_base = \"video\";\n\t\tbreak;\n\tcase VFL_TYPE_VBI:\n\t\tname_base = \"vbi\";\n\t\tbreak;\n\tcase VFL_TYPE_RADIO:\n\t\tname_base = \"radio\";\n\t\tbreak;\n\tcase VFL_TYPE_SUBDEV:\n\t\tname_base = \"v4l-subdev\";\n\t\tbreak;\n\tcase VFL_TYPE_SDR:\n\t\t \n\t\tname_base = \"swradio\";\n\t\tbreak;\n\tcase VFL_TYPE_TOUCH:\n\t\tname_base = \"v4l-touch\";\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s called with unknown type: %d\\n\",\n\t\t       __func__, type);\n\t\treturn -EINVAL;\n\t}\n\n\tvdev->vfl_type = type;\n\tvdev->cdev = NULL;\n\tif (vdev->dev_parent == NULL)\n\t\tvdev->dev_parent = vdev->v4l2_dev->dev;\n\tif (vdev->ctrl_handler == NULL)\n\t\tvdev->ctrl_handler = vdev->v4l2_dev->ctrl_handler;\n\t \n\tif (vdev->prio == NULL)\n\t\tvdev->prio = &vdev->v4l2_dev->prio;\n\n\t \n#ifdef CONFIG_VIDEO_FIXED_MINOR_RANGES\n\t \n\tswitch (type) {\n\tcase VFL_TYPE_VIDEO:\n\t\tminor_offset = 0;\n\t\tminor_cnt = 64;\n\t\tbreak;\n\tcase VFL_TYPE_RADIO:\n\t\tminor_offset = 64;\n\t\tminor_cnt = 64;\n\t\tbreak;\n\tcase VFL_TYPE_VBI:\n\t\tminor_offset = 224;\n\t\tminor_cnt = 32;\n\t\tbreak;\n\tdefault:\n\t\tminor_offset = 128;\n\t\tminor_cnt = 64;\n\t\tbreak;\n\t}\n#endif\n\n\t \n\tmutex_lock(&videodev_lock);\n\tnr = devnode_find(vdev, nr == -1 ? 0 : nr, minor_cnt);\n\tif (nr == minor_cnt)\n\t\tnr = devnode_find(vdev, 0, minor_cnt);\n\tif (nr == minor_cnt) {\n\t\tpr_err(\"could not get a free device node number\\n\");\n\t\tmutex_unlock(&videodev_lock);\n\t\treturn -ENFILE;\n\t}\n#ifdef CONFIG_VIDEO_FIXED_MINOR_RANGES\n\t \n\ti = nr;\n#else\n\t \n\tfor (i = 0; i < VIDEO_NUM_DEVICES; i++)\n\t\tif (video_devices[i] == NULL)\n\t\t\tbreak;\n\tif (i == VIDEO_NUM_DEVICES) {\n\t\tmutex_unlock(&videodev_lock);\n\t\tpr_err(\"could not get a free minor\\n\");\n\t\treturn -ENFILE;\n\t}\n#endif\n\tvdev->minor = i + minor_offset;\n\tvdev->num = nr;\n\n\t \n\tif (WARN_ON(video_devices[vdev->minor])) {\n\t\tmutex_unlock(&videodev_lock);\n\t\tpr_err(\"video_device not empty!\\n\");\n\t\treturn -ENFILE;\n\t}\n\tdevnode_set(vdev);\n\tvdev->index = get_index(vdev);\n\tvideo_devices[vdev->minor] = vdev;\n\tmutex_unlock(&videodev_lock);\n\n\tif (vdev->ioctl_ops)\n\t\tdetermine_valid_ioctls(vdev);\n\n\t \n\tvdev->cdev = cdev_alloc();\n\tif (vdev->cdev == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\tvdev->cdev->ops = &v4l2_fops;\n\tvdev->cdev->owner = owner;\n\tret = cdev_add(vdev->cdev, MKDEV(VIDEO_MAJOR, vdev->minor), 1);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: cdev_add failed\\n\", __func__);\n\t\tkfree(vdev->cdev);\n\t\tvdev->cdev = NULL;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tvdev->dev.class = &video_class;\n\tvdev->dev.devt = MKDEV(VIDEO_MAJOR, vdev->minor);\n\tvdev->dev.parent = vdev->dev_parent;\n\tdev_set_name(&vdev->dev, \"%s%d\", name_base, vdev->num);\n\tret = device_register(&vdev->dev);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: device_register failed\\n\", __func__);\n\t\tgoto cleanup;\n\t}\n\t \n\tvdev->dev.release = v4l2_device_release;\n\n\tif (nr != -1 && nr != vdev->num && warn_if_nr_in_use)\n\t\tpr_warn(\"%s: requested %s%d, got %s\\n\", __func__,\n\t\t\tname_base, nr, video_device_node_name(vdev));\n\n\t \n\tv4l2_device_get(vdev->v4l2_dev);\n\n\t \n\tret = video_register_media_controller(vdev);\n\n\t \n\tset_bit(V4L2_FL_REGISTERED, &vdev->flags);\n\n\treturn 0;\n\ncleanup:\n\tmutex_lock(&videodev_lock);\n\tif (vdev->cdev)\n\t\tcdev_del(vdev->cdev);\n\tvideo_devices[vdev->minor] = NULL;\n\tdevnode_clear(vdev);\n\tmutex_unlock(&videodev_lock);\n\t \n\tvdev->minor = -1;\n\treturn ret;\n}\nEXPORT_SYMBOL(__video_register_device);\n\n \nvoid video_unregister_device(struct video_device *vdev)\n{\n\t \n\tif (!vdev || !video_is_registered(vdev))\n\t\treturn;\n\n\tmutex_lock(&videodev_lock);\n\t \n\tclear_bit(V4L2_FL_REGISTERED, &vdev->flags);\n\tmutex_unlock(&videodev_lock);\n\tif (test_bit(V4L2_FL_USES_V4L2_FH, &vdev->flags))\n\t\tv4l2_event_wake_all(vdev);\n\tdevice_unregister(&vdev->dev);\n}\nEXPORT_SYMBOL(video_unregister_device);\n\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\n__must_check int video_device_pipeline_start(struct video_device *vdev,\n\t\t\t\t\t     struct media_pipeline *pipe)\n{\n\tstruct media_entity *entity = &vdev->entity;\n\n\tif (entity->num_pads != 1)\n\t\treturn -ENODEV;\n\n\treturn media_pipeline_start(&entity->pads[0], pipe);\n}\nEXPORT_SYMBOL_GPL(video_device_pipeline_start);\n\n__must_check int __video_device_pipeline_start(struct video_device *vdev,\n\t\t\t\t\t       struct media_pipeline *pipe)\n{\n\tstruct media_entity *entity = &vdev->entity;\n\n\tif (entity->num_pads != 1)\n\t\treturn -ENODEV;\n\n\treturn __media_pipeline_start(&entity->pads[0], pipe);\n}\nEXPORT_SYMBOL_GPL(__video_device_pipeline_start);\n\nvoid video_device_pipeline_stop(struct video_device *vdev)\n{\n\tstruct media_entity *entity = &vdev->entity;\n\n\tif (WARN_ON(entity->num_pads != 1))\n\t\treturn;\n\n\treturn media_pipeline_stop(&entity->pads[0]);\n}\nEXPORT_SYMBOL_GPL(video_device_pipeline_stop);\n\nvoid __video_device_pipeline_stop(struct video_device *vdev)\n{\n\tstruct media_entity *entity = &vdev->entity;\n\n\tif (WARN_ON(entity->num_pads != 1))\n\t\treturn;\n\n\treturn __media_pipeline_stop(&entity->pads[0]);\n}\nEXPORT_SYMBOL_GPL(__video_device_pipeline_stop);\n\n__must_check int video_device_pipeline_alloc_start(struct video_device *vdev)\n{\n\tstruct media_entity *entity = &vdev->entity;\n\n\tif (entity->num_pads != 1)\n\t\treturn -ENODEV;\n\n\treturn media_pipeline_alloc_start(&entity->pads[0]);\n}\nEXPORT_SYMBOL_GPL(video_device_pipeline_alloc_start);\n\nstruct media_pipeline *video_device_pipeline(struct video_device *vdev)\n{\n\tstruct media_entity *entity = &vdev->entity;\n\n\tif (WARN_ON(entity->num_pads != 1))\n\t\treturn NULL;\n\n\treturn media_pad_pipeline(&entity->pads[0]);\n}\nEXPORT_SYMBOL_GPL(video_device_pipeline);\n\n#endif  \n\n \nstatic int __init videodev_init(void)\n{\n\tdev_t dev = MKDEV(VIDEO_MAJOR, 0);\n\tint ret;\n\n\tpr_info(\"Linux video capture interface: v2.00\\n\");\n\tret = register_chrdev_region(dev, VIDEO_NUM_DEVICES, VIDEO_NAME);\n\tif (ret < 0) {\n\t\tpr_warn(\"videodev: unable to get major %d\\n\",\n\t\t\t\tVIDEO_MAJOR);\n\t\treturn ret;\n\t}\n\n\tret = class_register(&video_class);\n\tif (ret < 0) {\n\t\tunregister_chrdev_region(dev, VIDEO_NUM_DEVICES);\n\t\tpr_warn(\"video_dev: class_register failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit videodev_exit(void)\n{\n\tdev_t dev = MKDEV(VIDEO_MAJOR, 0);\n\n\tclass_unregister(&video_class);\n\tunregister_chrdev_region(dev, VIDEO_NUM_DEVICES);\n}\n\nsubsys_initcall(videodev_init);\nmodule_exit(videodev_exit)\n\nMODULE_AUTHOR(\"Alan Cox, Mauro Carvalho Chehab <mchehab@kernel.org>, Bill Dirks, Justin Schoeman, Gerd Knorr\");\nMODULE_DESCRIPTION(\"Video4Linux2 core driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_CHARDEV_MAJOR(VIDEO_MAJOR);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}