{
  "module_name": "videobuf-dma-sg.c",
  "hash_id": "5ff358dee505a5b5a3fbed19a162839e6ef8b2e2590f102f74753b455e2bf76b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/videobuf-dma-sg.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/sched/mm.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pgtable.h>\n\n#include <linux/dma-mapping.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/scatterlist.h>\n#include <asm/page.h>\n\n#include <media/videobuf-dma-sg.h>\n\n#define MAGIC_DMABUF 0x19721112\n#define MAGIC_SG_MEM 0x17890714\n\n#define MAGIC_CHECK(is, should)\t\t\t\t\t\t\\\n\tif (unlikely((is) != (should))) {\t\t\t\t\\\n\t\tprintk(KERN_ERR \"magic mismatch: %x (expected %x)\\n\",\t\\\n\t\t\t\tis, should);\t\t\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\n\nstatic int debug;\nmodule_param(debug, int, 0644);\n\nMODULE_DESCRIPTION(\"helper module to manage video4linux dma sg buffers\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab <mchehab@kernel.org>\");\nMODULE_LICENSE(\"GPL\");\n\n#define dprintk(level, fmt, arg...)\t\t\t\t\t\\\n\tif (debug >= level)\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"vbuf-sg: \" fmt , ## arg)\n\n \n\n \nstatic struct scatterlist *videobuf_vmalloc_to_sg(unsigned char *virt,\n\t\t\t\t\t\t  int nr_pages)\n{\n\tstruct scatterlist *sglist;\n\tstruct page *pg;\n\tint i;\n\n\tsglist = vzalloc(array_size(nr_pages, sizeof(*sglist)));\n\tif (NULL == sglist)\n\t\treturn NULL;\n\tsg_init_table(sglist, nr_pages);\n\tfor (i = 0; i < nr_pages; i++, virt += PAGE_SIZE) {\n\t\tpg = vmalloc_to_page(virt);\n\t\tif (NULL == pg)\n\t\t\tgoto err;\n\t\tBUG_ON(PageHighMem(pg));\n\t\tsg_set_page(&sglist[i], pg, PAGE_SIZE, 0);\n\t}\n\treturn sglist;\n\nerr:\n\tvfree(sglist);\n\treturn NULL;\n}\n\n \nstatic struct scatterlist *videobuf_pages_to_sg(struct page **pages,\n\t\t\t\t\tint nr_pages, int offset, size_t size)\n{\n\tstruct scatterlist *sglist;\n\tint i;\n\n\tif (NULL == pages[0])\n\t\treturn NULL;\n\tsglist = vmalloc(array_size(nr_pages, sizeof(*sglist)));\n\tif (NULL == sglist)\n\t\treturn NULL;\n\tsg_init_table(sglist, nr_pages);\n\n\tif (PageHighMem(pages[0]))\n\t\t \n\t\tgoto highmem;\n\tsg_set_page(&sglist[0], pages[0],\n\t\t\tmin_t(size_t, PAGE_SIZE - offset, size), offset);\n\tsize -= min_t(size_t, PAGE_SIZE - offset, size);\n\tfor (i = 1; i < nr_pages; i++) {\n\t\tif (NULL == pages[i])\n\t\t\tgoto nopage;\n\t\tif (PageHighMem(pages[i]))\n\t\t\tgoto highmem;\n\t\tsg_set_page(&sglist[i], pages[i], min_t(size_t, PAGE_SIZE, size), 0);\n\t\tsize -= min_t(size_t, PAGE_SIZE, size);\n\t}\n\treturn sglist;\n\nnopage:\n\tdprintk(2, \"sgl: oops - no page\\n\");\n\tvfree(sglist);\n\treturn NULL;\n\nhighmem:\n\tdprintk(2, \"sgl: oops - highmem page\\n\");\n\tvfree(sglist);\n\treturn NULL;\n}\n\n \n\nstruct videobuf_dmabuf *videobuf_to_dma(struct videobuf_buffer *buf)\n{\n\tstruct videobuf_dma_sg_memory *mem = buf->priv;\n\tBUG_ON(!mem);\n\n\tMAGIC_CHECK(mem->magic, MAGIC_SG_MEM);\n\n\treturn &mem->dma;\n}\nEXPORT_SYMBOL_GPL(videobuf_to_dma);\n\nstatic void videobuf_dma_init(struct videobuf_dmabuf *dma)\n{\n\tmemset(dma, 0, sizeof(*dma));\n\tdma->magic = MAGIC_DMABUF;\n}\n\nstatic int videobuf_dma_init_user_locked(struct videobuf_dmabuf *dma,\n\t\t\tint direction, unsigned long data, unsigned long size)\n{\n\tunsigned int gup_flags = FOLL_LONGTERM;\n\tunsigned long first, last;\n\tint err;\n\n\tdma->direction = direction;\n\tswitch (dma->direction) {\n\tcase DMA_FROM_DEVICE:\n\t\tgup_flags |= FOLL_WRITE;\n\t\tbreak;\n\tcase DMA_TO_DEVICE:\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tfirst = (data          & PAGE_MASK) >> PAGE_SHIFT;\n\tlast  = ((data+size-1) & PAGE_MASK) >> PAGE_SHIFT;\n\tdma->offset = data & ~PAGE_MASK;\n\tdma->size = size;\n\tdma->nr_pages = last-first+1;\n\tdma->pages = kmalloc_array(dma->nr_pages, sizeof(struct page *),\n\t\t\t\t   GFP_KERNEL);\n\tif (NULL == dma->pages)\n\t\treturn -ENOMEM;\n\n\tdprintk(1, \"init user [0x%lx+0x%lx => %lu pages]\\n\",\n\t\tdata, size, dma->nr_pages);\n\n\terr = pin_user_pages(data & PAGE_MASK, dma->nr_pages, gup_flags,\n\t\t\t     dma->pages);\n\n\tif (err != dma->nr_pages) {\n\t\tdma->nr_pages = (err >= 0) ? err : 0;\n\t\tdprintk(1, \"pin_user_pages: err=%d [%lu]\\n\", err,\n\t\t\tdma->nr_pages);\n\t\treturn err < 0 ? err : -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int videobuf_dma_init_user(struct videobuf_dmabuf *dma, int direction,\n\t\t\t   unsigned long data, unsigned long size)\n{\n\tint ret;\n\n\tmmap_read_lock(current->mm);\n\tret = videobuf_dma_init_user_locked(dma, direction, data, size);\n\tmmap_read_unlock(current->mm);\n\n\treturn ret;\n}\n\nstatic int videobuf_dma_init_kernel(struct videobuf_dmabuf *dma, int direction,\n\t\t\t\t    unsigned long nr_pages)\n{\n\tint i;\n\n\tdprintk(1, \"init kernel [%lu pages]\\n\", nr_pages);\n\n\tdma->direction = direction;\n\tdma->vaddr_pages = kcalloc(nr_pages, sizeof(*dma->vaddr_pages),\n\t\t\t\t   GFP_KERNEL);\n\tif (!dma->vaddr_pages)\n\t\treturn -ENOMEM;\n\n\tdma->dma_addr = kcalloc(nr_pages, sizeof(*dma->dma_addr), GFP_KERNEL);\n\tif (!dma->dma_addr) {\n\t\tkfree(dma->vaddr_pages);\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tvoid *addr;\n\n\t\taddr = dma_alloc_coherent(dma->dev, PAGE_SIZE,\n\t\t\t\t\t  &(dma->dma_addr[i]), GFP_KERNEL);\n\t\tif (addr == NULL)\n\t\t\tgoto out_free_pages;\n\n\t\tdma->vaddr_pages[i] = virt_to_page(addr);\n\t}\n\tdma->vaddr = vmap(dma->vaddr_pages, nr_pages, VM_MAP | VM_IOREMAP,\n\t\t\t  PAGE_KERNEL);\n\tif (NULL == dma->vaddr) {\n\t\tdprintk(1, \"vmalloc_32(%lu pages) failed\\n\", nr_pages);\n\t\tgoto out_free_pages;\n\t}\n\n\tdprintk(1, \"vmalloc is at addr %p, size=%lu\\n\",\n\t\tdma->vaddr, nr_pages << PAGE_SHIFT);\n\n\tmemset(dma->vaddr, 0, nr_pages << PAGE_SHIFT);\n\tdma->nr_pages = nr_pages;\n\n\treturn 0;\nout_free_pages:\n\twhile (i > 0) {\n\t\tvoid *addr;\n\n\t\ti--;\n\t\taddr = page_address(dma->vaddr_pages[i]);\n\t\tdma_free_coherent(dma->dev, PAGE_SIZE, addr, dma->dma_addr[i]);\n\t}\n\tkfree(dma->dma_addr);\n\tdma->dma_addr = NULL;\n\tkfree(dma->vaddr_pages);\n\tdma->vaddr_pages = NULL;\n\n\treturn -ENOMEM;\n\n}\n\nstatic int videobuf_dma_init_overlay(struct videobuf_dmabuf *dma, int direction,\n\t\t\t      dma_addr_t addr, unsigned long nr_pages)\n{\n\tdprintk(1, \"init overlay [%lu pages @ bus 0x%lx]\\n\",\n\t\tnr_pages, (unsigned long)addr);\n\tdma->direction = direction;\n\n\tif (0 == addr)\n\t\treturn -EINVAL;\n\n\tdma->bus_addr = addr;\n\tdma->nr_pages = nr_pages;\n\n\treturn 0;\n}\n\nstatic int videobuf_dma_map(struct device *dev, struct videobuf_dmabuf *dma)\n{\n\tMAGIC_CHECK(dma->magic, MAGIC_DMABUF);\n\tBUG_ON(0 == dma->nr_pages);\n\n\tif (dma->pages) {\n\t\tdma->sglist = videobuf_pages_to_sg(dma->pages, dma->nr_pages,\n\t\t\t\t\t\t   dma->offset, dma->size);\n\t}\n\tif (dma->vaddr) {\n\t\tdma->sglist = videobuf_vmalloc_to_sg(dma->vaddr,\n\t\t\t\t\t\t     dma->nr_pages);\n\t}\n\tif (dma->bus_addr) {\n\t\tdma->sglist = vmalloc(sizeof(*dma->sglist));\n\t\tif (NULL != dma->sglist) {\n\t\t\tdma->sglen = 1;\n\t\t\tsg_dma_address(&dma->sglist[0])\t= dma->bus_addr\n\t\t\t\t\t\t\t& PAGE_MASK;\n\t\t\tdma->sglist[0].offset = dma->bus_addr & ~PAGE_MASK;\n\t\t\tsg_dma_len(&dma->sglist[0]) = dma->nr_pages * PAGE_SIZE;\n\t\t}\n\t}\n\tif (NULL == dma->sglist) {\n\t\tdprintk(1, \"scatterlist is NULL\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (!dma->bus_addr) {\n\t\tdma->sglen = dma_map_sg(dev, dma->sglist,\n\t\t\t\t\tdma->nr_pages, dma->direction);\n\t\tif (0 == dma->sglen) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: videobuf_map_sg failed\\n\", __func__);\n\t\t\tvfree(dma->sglist);\n\t\t\tdma->sglist = NULL;\n\t\t\tdma->sglen = 0;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint videobuf_dma_unmap(struct device *dev, struct videobuf_dmabuf *dma)\n{\n\tMAGIC_CHECK(dma->magic, MAGIC_DMABUF);\n\n\tif (!dma->sglen)\n\t\treturn 0;\n\n\tdma_unmap_sg(dev, dma->sglist, dma->nr_pages, dma->direction);\n\n\tvfree(dma->sglist);\n\tdma->sglist = NULL;\n\tdma->sglen = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(videobuf_dma_unmap);\n\nint videobuf_dma_free(struct videobuf_dmabuf *dma)\n{\n\tint i;\n\tMAGIC_CHECK(dma->magic, MAGIC_DMABUF);\n\tBUG_ON(dma->sglen);\n\n\tif (dma->pages) {\n\t\tunpin_user_pages_dirty_lock(dma->pages, dma->nr_pages,\n\t\t\t\t\t    dma->direction == DMA_FROM_DEVICE);\n\t\tkfree(dma->pages);\n\t\tdma->pages = NULL;\n\t}\n\n\tif (dma->dma_addr) {\n\t\tfor (i = 0; i < dma->nr_pages; i++) {\n\t\t\tvoid *addr;\n\n\t\t\taddr = page_address(dma->vaddr_pages[i]);\n\t\t\tdma_free_coherent(dma->dev, PAGE_SIZE, addr,\n\t\t\t\t\t  dma->dma_addr[i]);\n\t\t}\n\t\tkfree(dma->dma_addr);\n\t\tdma->dma_addr = NULL;\n\t\tkfree(dma->vaddr_pages);\n\t\tdma->vaddr_pages = NULL;\n\t\tvunmap(dma->vaddr);\n\t\tdma->vaddr = NULL;\n\t}\n\n\tif (dma->bus_addr)\n\t\tdma->bus_addr = 0;\n\tdma->direction = DMA_NONE;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(videobuf_dma_free);\n\n \n\nstatic void videobuf_vm_open(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\n\tdprintk(2, \"vm_open %p [count=%d,vma=%08lx-%08lx]\\n\", map,\n\t\tmap->count, vma->vm_start, vma->vm_end);\n\n\tmap->count++;\n}\n\nstatic void videobuf_vm_close(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tstruct videobuf_queue *q = map->q;\n\tstruct videobuf_dma_sg_memory *mem;\n\tint i;\n\n\tdprintk(2, \"vm_close %p [count=%d,vma=%08lx-%08lx]\\n\", map,\n\t\tmap->count, vma->vm_start, vma->vm_end);\n\n\tmap->count--;\n\tif (0 == map->count) {\n\t\tdprintk(1, \"munmap %p q=%p\\n\", map, q);\n\t\tvideobuf_queue_lock(q);\n\t\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\t\tif (NULL == q->bufs[i])\n\t\t\t\tcontinue;\n\t\t\tmem = q->bufs[i]->priv;\n\t\t\tif (!mem)\n\t\t\t\tcontinue;\n\n\t\t\tMAGIC_CHECK(mem->magic, MAGIC_SG_MEM);\n\n\t\t\tif (q->bufs[i]->map != map)\n\t\t\t\tcontinue;\n\t\t\tq->bufs[i]->map   = NULL;\n\t\t\tq->bufs[i]->baddr = 0;\n\t\t\tq->ops->buf_release(q, q->bufs[i]);\n\t\t}\n\t\tvideobuf_queue_unlock(q);\n\t\tkfree(map);\n\t}\n}\n\n \nstatic vm_fault_t videobuf_vm_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page;\n\n\tdprintk(3, \"fault: fault @ %08lx [vma %08lx-%08lx]\\n\",\n\t\tvmf->address, vma->vm_start, vma->vm_end);\n\n\tpage = alloc_page(GFP_USER | __GFP_DMA32);\n\tif (!page)\n\t\treturn VM_FAULT_OOM;\n\tclear_user_highpage(page, vmf->address);\n\tvmf->page = page;\n\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct videobuf_vm_ops = {\n\t.open\t= videobuf_vm_open,\n\t.close\t= videobuf_vm_close,\n\t.fault\t= videobuf_vm_fault,\n};\n\n \n\n \n\nstatic struct videobuf_buffer *__videobuf_alloc_vb(size_t size)\n{\n\tstruct videobuf_dma_sg_memory *mem;\n\tstruct videobuf_buffer *vb;\n\n\tvb = kzalloc(size + sizeof(*mem), GFP_KERNEL);\n\tif (!vb)\n\t\treturn vb;\n\n\tmem = vb->priv = ((char *)vb) + size;\n\tmem->magic = MAGIC_SG_MEM;\n\n\tvideobuf_dma_init(&mem->dma);\n\n\tdprintk(1, \"%s: allocated at %p(%ld+%ld) & %p(%ld)\\n\",\n\t\t__func__, vb, (long)sizeof(*vb), (long)size - sizeof(*vb),\n\t\tmem, (long)sizeof(*mem));\n\n\treturn vb;\n}\n\nstatic void *__videobuf_to_vaddr(struct videobuf_buffer *buf)\n{\n\tstruct videobuf_dma_sg_memory *mem = buf->priv;\n\tBUG_ON(!mem);\n\n\tMAGIC_CHECK(mem->magic, MAGIC_SG_MEM);\n\n\treturn mem->dma.vaddr;\n}\n\nstatic int __videobuf_iolock(struct videobuf_queue *q,\n\t\t\t     struct videobuf_buffer *vb,\n\t\t\t     struct v4l2_framebuffer *fbuf)\n{\n\tstruct videobuf_dma_sg_memory *mem = vb->priv;\n\tunsigned long pages;\n\tdma_addr_t bus;\n\tint err;\n\n\tBUG_ON(!mem);\n\n\tMAGIC_CHECK(mem->magic, MAGIC_SG_MEM);\n\n\tif (!mem->dma.dev)\n\t\tmem->dma.dev = q->dev;\n\telse\n\t\tWARN_ON(mem->dma.dev != q->dev);\n\n\tswitch (vb->memory) {\n\tcase V4L2_MEMORY_MMAP:\n\tcase V4L2_MEMORY_USERPTR:\n\t\tif (0 == vb->baddr) {\n\t\t\t \n\t\t\tpages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;\n\t\t\terr = videobuf_dma_init_kernel(&mem->dma,\n\t\t\t\t\t\t       DMA_FROM_DEVICE,\n\t\t\t\t\t\t       pages);\n\t\t\tif (0 != err)\n\t\t\t\treturn err;\n\t\t} else if (vb->memory == V4L2_MEMORY_USERPTR) {\n\t\t\t \n\t\t\terr = videobuf_dma_init_user(&mem->dma,\n\t\t\t\t\t\t     DMA_FROM_DEVICE,\n\t\t\t\t\t\t     vb->baddr, vb->bsize);\n\t\t\tif (0 != err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\t \n\n\t\t\terr = videobuf_dma_init_user_locked(&mem->dma,\n\t\t\t\t\t\t      DMA_FROM_DEVICE,\n\t\t\t\t\t\t      vb->baddr, vb->bsize);\n\t\t\tif (0 != err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tcase V4L2_MEMORY_OVERLAY:\n\t\tif (NULL == fbuf)\n\t\t\treturn -EINVAL;\n\t\t \n\t\t \n\t\tbus   = (dma_addr_t)(unsigned long)fbuf->base + vb->boff;\n\t\tpages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;\n\t\terr = videobuf_dma_init_overlay(&mem->dma, DMA_FROM_DEVICE,\n\t\t\t\t\t\tbus, pages);\n\t\tif (0 != err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\terr = videobuf_dma_map(q->dev, &mem->dma);\n\tif (0 != err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int __videobuf_sync(struct videobuf_queue *q,\n\t\t\t   struct videobuf_buffer *buf)\n{\n\tstruct videobuf_dma_sg_memory *mem = buf->priv;\n\tBUG_ON(!mem || !mem->dma.sglen);\n\n\tMAGIC_CHECK(mem->magic, MAGIC_SG_MEM);\n\tMAGIC_CHECK(mem->dma.magic, MAGIC_DMABUF);\n\n\tdma_sync_sg_for_cpu(q->dev, mem->dma.sglist,\n\t\t\t    mem->dma.nr_pages, mem->dma.direction);\n\n\treturn 0;\n}\n\nstatic int __videobuf_mmap_mapper(struct videobuf_queue *q,\n\t\t\t\t  struct videobuf_buffer *buf,\n\t\t\t\t  struct vm_area_struct *vma)\n{\n\tstruct videobuf_dma_sg_memory *mem = buf->priv;\n\tstruct videobuf_mapping *map;\n\tunsigned int first, last, size = 0, i;\n\tint retval;\n\n\tretval = -EINVAL;\n\n\tBUG_ON(!mem);\n\tMAGIC_CHECK(mem->magic, MAGIC_SG_MEM);\n\n\t \n\tfor (first = 0; first < VIDEO_MAX_FRAME; first++) {\n\t\tif (buf == q->bufs[first]) {\n\t\t\tsize = PAGE_ALIGN(q->bufs[first]->bsize);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!size) {\n\t\tdprintk(1, \"mmap app bug: offset invalid [offset=0x%lx]\\n\",\n\t\t\t\t(vma->vm_pgoff << PAGE_SHIFT));\n\t\tgoto done;\n\t}\n\n\tlast = first;\n\n\t \n\tretval = -ENOMEM;\n\tmap = kmalloc(sizeof(struct videobuf_mapping), GFP_KERNEL);\n\tif (NULL == map)\n\t\tgoto done;\n\n\tsize = 0;\n\tfor (i = first; i <= last; i++) {\n\t\tif (NULL == q->bufs[i])\n\t\t\tcontinue;\n\t\tq->bufs[i]->map   = map;\n\t\tq->bufs[i]->baddr = vma->vm_start + size;\n\t\tsize += PAGE_ALIGN(q->bufs[i]->bsize);\n\t}\n\n\tmap->count    = 1;\n\tmap->q        = q;\n\tvma->vm_ops   = &videobuf_vm_ops;\n\t \n\tvm_flags_mod(vma, VM_DONTEXPAND | VM_DONTDUMP, VM_IO);\n\tvma->vm_private_data = map;\n\tdprintk(1, \"mmap %p: q=%p %08lx-%08lx pgoff %08lx bufs %d-%d\\n\",\n\t\tmap, q, vma->vm_start, vma->vm_end, vma->vm_pgoff, first, last);\n\tretval = 0;\n\ndone:\n\treturn retval;\n}\n\nstatic struct videobuf_qtype_ops sg_ops = {\n\t.magic        = MAGIC_QTYPE_OPS,\n\n\t.alloc_vb     = __videobuf_alloc_vb,\n\t.iolock       = __videobuf_iolock,\n\t.sync         = __videobuf_sync,\n\t.mmap_mapper  = __videobuf_mmap_mapper,\n\t.vaddr        = __videobuf_to_vaddr,\n};\n\nvoid *videobuf_sg_alloc(size_t size)\n{\n\tstruct videobuf_queue q;\n\n\t \n\tq.int_ops = &sg_ops;\n\n\tq.msize = size;\n\n\treturn videobuf_alloc_vb(&q);\n}\nEXPORT_SYMBOL_GPL(videobuf_sg_alloc);\n\nvoid videobuf_queue_sg_init(struct videobuf_queue *q,\n\t\t\t const struct videobuf_queue_ops *ops,\n\t\t\t struct device *dev,\n\t\t\t spinlock_t *irqlock,\n\t\t\t enum v4l2_buf_type type,\n\t\t\t enum v4l2_field field,\n\t\t\t unsigned int msize,\n\t\t\t void *priv,\n\t\t\t struct mutex *ext_lock)\n{\n\tvideobuf_queue_core_init(q, ops, dev, irqlock, type, field, msize,\n\t\t\t\t priv, &sg_ops, ext_lock);\n}\nEXPORT_SYMBOL_GPL(videobuf_queue_sg_init);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}