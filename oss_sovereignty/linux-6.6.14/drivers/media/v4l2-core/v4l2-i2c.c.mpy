{
  "module_name": "v4l2-i2c.c",
  "hash_id": "650b106f033ea95446557fbf1896e7beae35681957a2abdbdb6a6f71af8c132a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/v4l2-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-device.h>\n\nvoid v4l2_i2c_subdev_unregister(struct v4l2_subdev *sd)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\t \n\tif (client && !client->dev.of_node && !client->dev.fwnode)\n\t\ti2c_unregister_device(client);\n}\n\nvoid v4l2_i2c_subdev_set_name(struct v4l2_subdev *sd,\n\t\t\t      struct i2c_client *client,\n\t\t\t      const char *devname, const char *postfix)\n{\n\tif (!devname)\n\t\tdevname = client->dev.driver->name;\n\tif (!postfix)\n\t\tpostfix = \"\";\n\n\tsnprintf(sd->name, sizeof(sd->name), \"%s%s %d-%04x\", devname, postfix,\n\t\t i2c_adapter_id(client->adapter), client->addr);\n}\nEXPORT_SYMBOL_GPL(v4l2_i2c_subdev_set_name);\n\nvoid v4l2_i2c_subdev_init(struct v4l2_subdev *sd, struct i2c_client *client,\n\t\t\t  const struct v4l2_subdev_ops *ops)\n{\n\tv4l2_subdev_init(sd, ops);\n\tsd->flags |= V4L2_SUBDEV_FL_IS_I2C;\n\t \n\tsd->owner = client->dev.driver->owner;\n\tsd->dev = &client->dev;\n\t \n\tv4l2_set_subdevdata(sd, client);\n\ti2c_set_clientdata(client, sd);\n\tv4l2_i2c_subdev_set_name(sd, client, NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(v4l2_i2c_subdev_init);\n\n \nstruct v4l2_subdev\n*v4l2_i2c_new_subdev_board(struct v4l2_device *v4l2_dev,\n\t\t\t   struct i2c_adapter *adapter,\n\t\t\t   struct i2c_board_info *info,\n\t\t\t   const unsigned short *probe_addrs)\n{\n\tstruct v4l2_subdev *sd = NULL;\n\tstruct i2c_client *client;\n\n\tif (!v4l2_dev)\n\t\treturn NULL;\n\n\trequest_module(I2C_MODULE_PREFIX \"%s\", info->type);\n\n\t \n\tif (info->addr == 0 && probe_addrs)\n\t\tclient = i2c_new_scanned_device(adapter, info, probe_addrs,\n\t\t\t\t\t\tNULL);\n\telse\n\t\tclient = i2c_new_client_device(adapter, info);\n\n\t \n\tif (!i2c_client_has_driver(client))\n\t\tgoto error;\n\n\t \n\tif (!try_module_get(client->dev.driver->owner))\n\t\tgoto error;\n\tsd = i2c_get_clientdata(client);\n\n\t \n\tif (v4l2_device_register_subdev(v4l2_dev, sd))\n\t\tsd = NULL;\n\t \n\tmodule_put(client->dev.driver->owner);\n\nerror:\n\t \n\tif (!IS_ERR(client) && !sd)\n\t\ti2c_unregister_device(client);\n\treturn sd;\n}\nEXPORT_SYMBOL_GPL(v4l2_i2c_new_subdev_board);\n\nstruct v4l2_subdev *v4l2_i2c_new_subdev(struct v4l2_device *v4l2_dev,\n\t\t\t\t\tstruct i2c_adapter *adapter,\n\t\t\t\t\tconst char *client_type,\n\t\t\t\t\tu8 addr,\n\t\t\t\t\tconst unsigned short *probe_addrs)\n{\n\tstruct i2c_board_info info;\n\n\t \n\tmemset(&info, 0, sizeof(info));\n\tstrscpy(info.type, client_type, sizeof(info.type));\n\tinfo.addr = addr;\n\n\treturn v4l2_i2c_new_subdev_board(v4l2_dev, adapter, &info,\n\t\t\t\t\t probe_addrs);\n}\nEXPORT_SYMBOL_GPL(v4l2_i2c_new_subdev);\n\n \nunsigned short v4l2_i2c_subdev_addr(struct v4l2_subdev *sd)\n{\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\treturn client ? client->addr : I2C_CLIENT_END;\n}\nEXPORT_SYMBOL_GPL(v4l2_i2c_subdev_addr);\n\n \nconst unsigned short *v4l2_i2c_tuner_addrs(enum v4l2_i2c_tuner_type type)\n{\n\tstatic const unsigned short radio_addrs[] = {\n#if IS_ENABLED(CONFIG_MEDIA_TUNER_TEA5761)\n\t\t0x10,\n#endif\n\t\t0x60,\n\t\tI2C_CLIENT_END\n\t};\n\tstatic const unsigned short demod_addrs[] = {\n\t\t0x42, 0x43, 0x4a, 0x4b,\n\t\tI2C_CLIENT_END\n\t};\n\tstatic const unsigned short tv_addrs[] = {\n\t\t0x42, 0x43, 0x4a, 0x4b,\t\t \n\t\t0x60, 0x61, 0x62, 0x63, 0x64,\n\t\tI2C_CLIENT_END\n\t};\n\n\tswitch (type) {\n\tcase ADDRS_RADIO:\n\t\treturn radio_addrs;\n\tcase ADDRS_DEMOD:\n\t\treturn demod_addrs;\n\tcase ADDRS_TV:\n\t\treturn tv_addrs;\n\tcase ADDRS_TV_WITH_DEMOD:\n\t\treturn tv_addrs + 4;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(v4l2_i2c_tuner_addrs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}