{
  "module_name": "v4l2-common.c",
  "hash_id": "be2539975af32b54c5e843becf828128ce9589f71b141855d60fd981f161e526",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/v4l2-common.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/uaccess.h>\n#include <asm/io.h>\n#include <asm/div64.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n\n#include <linux/videodev2.h>\n\n \n\n \n\n \n\n \nint v4l2_ctrl_query_fill(struct v4l2_queryctrl *qctrl, s32 _min, s32 _max, s32 _step, s32 _def)\n{\n\tconst char *name;\n\ts64 min = _min;\n\ts64 max = _max;\n\tu64 step = _step;\n\ts64 def = _def;\n\n\tv4l2_ctrl_fill(qctrl->id, &name, &qctrl->type,\n\t\t       &min, &max, &step, &def, &qctrl->flags);\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tqctrl->minimum = min;\n\tqctrl->maximum = max;\n\tqctrl->step = step;\n\tqctrl->default_value = def;\n\tqctrl->reserved[0] = qctrl->reserved[1] = 0;\n\tstrscpy(qctrl->name, name, sizeof(qctrl->name));\n\treturn 0;\n}\nEXPORT_SYMBOL(v4l2_ctrl_query_fill);\n\n \nstatic unsigned int clamp_align(unsigned int x, unsigned int min,\n\t\t\t\tunsigned int max, unsigned int align)\n{\n\t \n\tunsigned int mask = ~((1 << align) - 1);\n\n\t \n\tx = clamp(x, (min + ~mask) & mask, max & mask);\n\n\t \n\tif (align)\n\t\tx = (x + (1 << (align - 1))) & mask;\n\n\treturn x;\n}\n\nstatic unsigned int clamp_roundup(unsigned int x, unsigned int min,\n\t\t\t\t   unsigned int max, unsigned int alignment)\n{\n\tx = clamp(x, min, max);\n\tif (alignment)\n\t\tx = round_up(x, alignment);\n\n\treturn x;\n}\n\nvoid v4l_bound_align_image(u32 *w, unsigned int wmin, unsigned int wmax,\n\t\t\t   unsigned int walign,\n\t\t\t   u32 *h, unsigned int hmin, unsigned int hmax,\n\t\t\t   unsigned int halign, unsigned int salign)\n{\n\t*w = clamp_align(*w, wmin, wmax, walign);\n\t*h = clamp_align(*h, hmin, hmax, halign);\n\n\t \n\tif (!salign)\n\t\treturn;\n\n\t \n\twalign = __ffs(*w);\n\thalign = __ffs(*h);\n\t \n\tif (walign + halign < salign) {\n\t\t \n\t\tunsigned int wmaxa = __fls(wmax ^ (wmin - 1));\n\t\t \n\t\tunsigned int hmaxa = __fls(hmax ^ (hmin - 1));\n\n\t\t \n\t\tdo {\n\t\t\tif (halign >= hmaxa ||\n\t\t\t    (walign <= halign && walign < wmaxa)) {\n\t\t\t\t*w = clamp_align(*w, wmin, wmax, walign + 1);\n\t\t\t\twalign = __ffs(*w);\n\t\t\t} else {\n\t\t\t\t*h = clamp_align(*h, hmin, hmax, halign + 1);\n\t\t\t\thalign = __ffs(*h);\n\t\t\t}\n\t\t} while (halign + walign < salign);\n\t}\n}\nEXPORT_SYMBOL_GPL(v4l_bound_align_image);\n\nconst void *\n__v4l2_find_nearest_size(const void *array, size_t array_size,\n\t\t\t size_t entry_size, size_t width_offset,\n\t\t\t size_t height_offset, s32 width, s32 height)\n{\n\tu32 error, min_error = U32_MAX;\n\tconst void *best = NULL;\n\tunsigned int i;\n\n\tif (!array)\n\t\treturn NULL;\n\n\tfor (i = 0; i < array_size; i++, array += entry_size) {\n\t\tconst u32 *entry_width = array + width_offset;\n\t\tconst u32 *entry_height = array + height_offset;\n\n\t\terror = abs(*entry_width - width) + abs(*entry_height - height);\n\t\tif (error > min_error)\n\t\t\tcontinue;\n\n\t\tmin_error = error;\n\t\tbest = array;\n\t\tif (!error)\n\t\t\tbreak;\n\t}\n\n\treturn best;\n}\nEXPORT_SYMBOL_GPL(__v4l2_find_nearest_size);\n\nint v4l2_g_parm_cap(struct video_device *vdev,\n\t\t    struct v4l2_subdev *sd, struct v4l2_streamparm *a)\n{\n\tstruct v4l2_subdev_frame_interval ival = { 0 };\n\tint ret;\n\n\tif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\n\t    a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\treturn -EINVAL;\n\n\tif (vdev->device_caps & V4L2_CAP_READWRITE)\n\t\ta->parm.capture.readbuffers = 2;\n\tif (v4l2_subdev_has_op(sd, video, g_frame_interval))\n\t\ta->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\n\tret = v4l2_subdev_call(sd, video, g_frame_interval, &ival);\n\tif (!ret)\n\t\ta->parm.capture.timeperframe = ival.interval;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(v4l2_g_parm_cap);\n\nint v4l2_s_parm_cap(struct video_device *vdev,\n\t\t    struct v4l2_subdev *sd, struct v4l2_streamparm *a)\n{\n\tstruct v4l2_subdev_frame_interval ival = {\n\t\t.interval = a->parm.capture.timeperframe\n\t};\n\tint ret;\n\n\tif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\n\t    a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\treturn -EINVAL;\n\n\tmemset(&a->parm, 0, sizeof(a->parm));\n\tif (vdev->device_caps & V4L2_CAP_READWRITE)\n\t\ta->parm.capture.readbuffers = 2;\n\telse\n\t\ta->parm.capture.readbuffers = 0;\n\n\tif (v4l2_subdev_has_op(sd, video, g_frame_interval))\n\t\ta->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\n\tret = v4l2_subdev_call(sd, video, s_frame_interval, &ival);\n\tif (!ret)\n\t\ta->parm.capture.timeperframe = ival.interval;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(v4l2_s_parm_cap);\n\nconst struct v4l2_format_info *v4l2_format_info(u32 format)\n{\n\tstatic const struct v4l2_format_info formats[] = {\n\t\t \n\t\t{ .format = V4L2_PIX_FMT_BGR24,   .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 3, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_RGB24,   .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 3, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_HSV24,   .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 3, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_BGR32,   .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_XBGR32,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_BGRX32,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_RGB32,   .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_XRGB32,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_RGBX32,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_HSV32,   .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_ARGB32,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_RGBA32,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_ABGR32,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_BGRA32,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_RGB565,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_RGB555,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_BGR666,  .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_BGR48_12, .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 6, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_ABGR64_12, .pixel_enc = V4L2_PIXEL_ENC_RGB, .mem_planes = 1, .comp_planes = 1, .bpp = { 8, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\n\t\t \n\t\t{ .format = V4L2_PIX_FMT_YUYV,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_YVYU,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_UYVY,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_VYUY,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_Y212,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 1, .bpp = { 4, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_YUV48_12, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 1, .bpp = { 6, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_MT2110T, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 2, .comp_planes = 2, .bpp = { 5, 10, 0, 0 }, .bpp_div = { 4, 4, 1, 1 }, .hdiv = 2, .vdiv = 2,\n\t\t  .block_w = { 16, 8, 0, 0 }, .block_h = { 32, 16, 0, 0 }},\n\t\t{ .format = V4L2_PIX_FMT_MT2110R, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 2, .comp_planes = 2, .bpp = { 5, 10, 0, 0 }, .bpp_div = { 4, 4, 1, 1 }, .hdiv = 2, .vdiv = 2,\n\t\t  .block_w = { 16, 8, 0, 0 }, .block_h = { 32, 16, 0, 0 }},\n\n\t\t \n\t\t{ .format = V4L2_PIX_FMT_NV12,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 2 },\n\t\t{ .format = V4L2_PIX_FMT_NV21,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 2 },\n\t\t{ .format = V4L2_PIX_FMT_NV16,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_NV61,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_NV24,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_NV42,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_P010,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 2, .bpp = { 2, 2, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_P012,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 2, .bpp = { 2, 4, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 2 },\n\n\t\t{ .format = V4L2_PIX_FMT_YUV410,  .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 4, .vdiv = 4 },\n\t\t{ .format = V4L2_PIX_FMT_YVU410,  .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 4, .vdiv = 4 },\n\t\t{ .format = V4L2_PIX_FMT_YUV411P, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 4, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_YUV420,  .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 2 },\n\t\t{ .format = V4L2_PIX_FMT_YVU420,  .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 2 },\n\t\t{ .format = V4L2_PIX_FMT_YUV422P, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_GREY,    .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\n\t\t \n\t\t{ .format = V4L2_PIX_FMT_NV12_4L4, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 2 },\n\t\t{ .format = V4L2_PIX_FMT_NV15_4L4, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 2, .bpp = { 5, 10, 0, 0 }, .bpp_div = { 4, 4, 1, 1 }, .hdiv = 2, .vdiv = 2,\n\t\t  .block_w = { 4, 2, 0, 0 }, .block_h = { 1, 1, 0, 0 }},\n\t\t{ .format = V4L2_PIX_FMT_P010_4L4, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 1, .comp_planes = 2, .bpp = { 2, 4, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 2 },\n\n\t\t \n\t\t{ .format = V4L2_PIX_FMT_YUV420M, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 2 },\n\t\t{ .format = V4L2_PIX_FMT_YVU420M, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 2 },\n\t\t{ .format = V4L2_PIX_FMT_YUV422M, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_YVU422M, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_YUV444M, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_YVU444M, .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 3, .comp_planes = 3, .bpp = { 1, 1, 1, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\n\t\t{ .format = V4L2_PIX_FMT_NV12M,   .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 2, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 2 },\n\t\t{ .format = V4L2_PIX_FMT_NV21M,   .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 2, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 2 },\n\t\t{ .format = V4L2_PIX_FMT_NV16M,   .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 2, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_NV61M,   .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 2, .comp_planes = 2, .bpp = { 1, 2, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_P012M,   .pixel_enc = V4L2_PIXEL_ENC_YUV, .mem_planes = 2, .comp_planes = 2, .bpp = { 2, 4, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 2, .vdiv = 2 },\n\n\t\t \n\t\t{ .format = V4L2_PIX_FMT_SBGGR8,\t.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_SGBRG8,\t.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_SGRBG8,\t.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_SRGGB8,\t.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_SBGGR10,\t.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_SGBRG10,\t.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_SGRBG10,\t.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_SRGGB10,\t.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_SBGGR10ALAW8,\t.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_SGBRG10ALAW8,\t.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_SGRBG10ALAW8,\t.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_SRGGB10ALAW8,\t.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_SBGGR10DPCM8,\t.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_SGBRG10DPCM8,\t.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_SGRBG10DPCM8,\t.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_SRGGB10DPCM8,\t.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 1, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_SBGGR12,\t.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_SGBRG12,\t.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_SGRBG12,\t.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t\t{ .format = V4L2_PIX_FMT_SRGGB12,\t.pixel_enc = V4L2_PIXEL_ENC_BAYER, .mem_planes = 1, .comp_planes = 1, .bpp = { 2, 0, 0, 0 }, .bpp_div = { 1, 1, 1, 1 }, .hdiv = 1, .vdiv = 1 },\n\t};\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(formats); ++i)\n\t\tif (formats[i].format == format)\n\t\t\treturn &formats[i];\n\treturn NULL;\n}\nEXPORT_SYMBOL(v4l2_format_info);\n\nstatic inline unsigned int v4l2_format_block_width(const struct v4l2_format_info *info, int plane)\n{\n\tif (!info->block_w[plane])\n\t\treturn 1;\n\treturn info->block_w[plane];\n}\n\nstatic inline unsigned int v4l2_format_block_height(const struct v4l2_format_info *info, int plane)\n{\n\tif (!info->block_h[plane])\n\t\treturn 1;\n\treturn info->block_h[plane];\n}\n\nvoid v4l2_apply_frmsize_constraints(u32 *width, u32 *height,\n\t\t\t\t    const struct v4l2_frmsize_stepwise *frmsize)\n{\n\tif (!frmsize)\n\t\treturn;\n\n\t \n\t*width = clamp_roundup(*width, frmsize->min_width, frmsize->max_width,\n\t\t\t       frmsize->step_width);\n\t*height = clamp_roundup(*height, frmsize->min_height, frmsize->max_height,\n\t\t\t\tfrmsize->step_height);\n}\nEXPORT_SYMBOL_GPL(v4l2_apply_frmsize_constraints);\n\nint v4l2_fill_pixfmt_mp(struct v4l2_pix_format_mplane *pixfmt,\n\t\t\tu32 pixelformat, u32 width, u32 height)\n{\n\tconst struct v4l2_format_info *info;\n\tstruct v4l2_plane_pix_format *plane;\n\tint i;\n\n\tinfo = v4l2_format_info(pixelformat);\n\tif (!info)\n\t\treturn -EINVAL;\n\n\tpixfmt->width = width;\n\tpixfmt->height = height;\n\tpixfmt->pixelformat = pixelformat;\n\tpixfmt->num_planes = info->mem_planes;\n\n\tif (info->mem_planes == 1) {\n\t\tplane = &pixfmt->plane_fmt[0];\n\t\tplane->bytesperline = ALIGN(width, v4l2_format_block_width(info, 0)) * info->bpp[0] / info->bpp_div[0];\n\t\tplane->sizeimage = 0;\n\n\t\tfor (i = 0; i < info->comp_planes; i++) {\n\t\t\tunsigned int hdiv = (i == 0) ? 1 : info->hdiv;\n\t\t\tunsigned int vdiv = (i == 0) ? 1 : info->vdiv;\n\t\t\tunsigned int aligned_width;\n\t\t\tunsigned int aligned_height;\n\n\t\t\taligned_width = ALIGN(width, v4l2_format_block_width(info, i));\n\t\t\taligned_height = ALIGN(height, v4l2_format_block_height(info, i));\n\n\t\t\tplane->sizeimage += info->bpp[i] *\n\t\t\t\tDIV_ROUND_UP(aligned_width, hdiv) *\n\t\t\t\tDIV_ROUND_UP(aligned_height, vdiv) / info->bpp_div[i];\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < info->comp_planes; i++) {\n\t\t\tunsigned int hdiv = (i == 0) ? 1 : info->hdiv;\n\t\t\tunsigned int vdiv = (i == 0) ? 1 : info->vdiv;\n\t\t\tunsigned int aligned_width;\n\t\t\tunsigned int aligned_height;\n\n\t\t\taligned_width = ALIGN(width, v4l2_format_block_width(info, i));\n\t\t\taligned_height = ALIGN(height, v4l2_format_block_height(info, i));\n\n\t\t\tplane = &pixfmt->plane_fmt[i];\n\t\t\tplane->bytesperline =\n\t\t\t\tinfo->bpp[i] * DIV_ROUND_UP(aligned_width, hdiv) / info->bpp_div[i];\n\t\t\tplane->sizeimage =\n\t\t\t\tplane->bytesperline * DIV_ROUND_UP(aligned_height, vdiv);\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(v4l2_fill_pixfmt_mp);\n\nint v4l2_fill_pixfmt(struct v4l2_pix_format *pixfmt, u32 pixelformat,\n\t\t     u32 width, u32 height)\n{\n\tconst struct v4l2_format_info *info;\n\tint i;\n\n\tinfo = v4l2_format_info(pixelformat);\n\tif (!info)\n\t\treturn -EINVAL;\n\n\t \n\tif (info->mem_planes > 1)\n\t\treturn -EINVAL;\n\n\tpixfmt->width = width;\n\tpixfmt->height = height;\n\tpixfmt->pixelformat = pixelformat;\n\tpixfmt->bytesperline = ALIGN(width, v4l2_format_block_width(info, 0)) * info->bpp[0] / info->bpp_div[0];\n\tpixfmt->sizeimage = 0;\n\n\tfor (i = 0; i < info->comp_planes; i++) {\n\t\tunsigned int hdiv = (i == 0) ? 1 : info->hdiv;\n\t\tunsigned int vdiv = (i == 0) ? 1 : info->vdiv;\n\t\tunsigned int aligned_width;\n\t\tunsigned int aligned_height;\n\n\t\taligned_width = ALIGN(width, v4l2_format_block_width(info, i));\n\t\taligned_height = ALIGN(height, v4l2_format_block_height(info, i));\n\n\t\tpixfmt->sizeimage += info->bpp[i] *\n\t\t\tDIV_ROUND_UP(aligned_width, hdiv) *\n\t\t\tDIV_ROUND_UP(aligned_height, vdiv) / info->bpp_div[i];\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(v4l2_fill_pixfmt);\n\ns64 v4l2_get_link_freq(struct v4l2_ctrl_handler *handler, unsigned int mul,\n\t\t       unsigned int div)\n{\n\tstruct v4l2_ctrl *ctrl;\n\ts64 freq;\n\n\tctrl = v4l2_ctrl_find(handler, V4L2_CID_LINK_FREQ);\n\tif (ctrl) {\n\t\tstruct v4l2_querymenu qm = { .id = V4L2_CID_LINK_FREQ };\n\t\tint ret;\n\n\t\tqm.index = v4l2_ctrl_g_ctrl(ctrl);\n\n\t\tret = v4l2_querymenu(handler, &qm);\n\t\tif (ret)\n\t\t\treturn -ENOENT;\n\n\t\tfreq = qm.value;\n\t} else {\n\t\tif (!mul || !div)\n\t\t\treturn -ENOENT;\n\n\t\tctrl = v4l2_ctrl_find(handler, V4L2_CID_PIXEL_RATE);\n\t\tif (!ctrl)\n\t\t\treturn -ENOENT;\n\n\t\tfreq = div_u64(v4l2_ctrl_g_ctrl_int64(ctrl) * mul, div);\n\n\t\tpr_warn(\"%s: Link frequency estimated using pixel rate: result might be inaccurate\\n\",\n\t\t\t__func__);\n\t\tpr_warn(\"%s: Consider implementing support for V4L2_CID_LINK_FREQ in the transmitter driver\\n\",\n\t\t\t__func__);\n\t}\n\n\treturn freq > 0 ? freq : -EINVAL;\n}\nEXPORT_SYMBOL_GPL(v4l2_get_link_freq);\n\n \nvoid v4l2_simplify_fraction(u32 *numerator, u32 *denominator,\n\t\tunsigned int n_terms, unsigned int threshold)\n{\n\tu32 *an;\n\tu32 x, y, r;\n\tunsigned int i, n;\n\n\tan = kmalloc_array(n_terms, sizeof(*an), GFP_KERNEL);\n\tif (an == NULL)\n\t\treturn;\n\n\t \n\tx = *numerator;\n\ty = *denominator;\n\n\tfor (n = 0; n < n_terms && y != 0; ++n) {\n\t\tan[n] = x / y;\n\t\tif (an[n] >= threshold) {\n\t\t\tif (n < 2)\n\t\t\t\tn++;\n\t\t\tbreak;\n\t\t}\n\n\t\tr = x - an[n] * y;\n\t\tx = y;\n\t\ty = r;\n\t}\n\n\t \n\tx = 0;\n\ty = 1;\n\n\tfor (i = n; i > 0; --i) {\n\t\tr = y;\n\t\ty = an[i-1] * y + x;\n\t\tx = r;\n\t}\n\n\t*numerator = y;\n\t*denominator = x;\n\tkfree(an);\n}\nEXPORT_SYMBOL_GPL(v4l2_simplify_fraction);\n\n \nu32 v4l2_fraction_to_interval(u32 numerator, u32 denominator)\n{\n\tu32 multiplier;\n\n\t \n\tif (denominator == 0 ||\n\t    numerator/denominator >= ((u32)-1)/10000000)\n\t\treturn (u32)-1;\n\n\t \n\tmultiplier = 10000000;\n\twhile (numerator > ((u32)-1)/multiplier) {\n\t\tmultiplier /= 2;\n\t\tdenominator /= 2;\n\t}\n\n\treturn denominator ? numerator * multiplier / denominator : 0;\n}\nEXPORT_SYMBOL_GPL(v4l2_fraction_to_interval);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}