{
  "module_name": "v4l2-async.c",
  "hash_id": "b95711aaaf7b7580ae20d48e7af80286ea1146aabf353a874d58d4ce004b0bf1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/v4l2-async.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include <media/v4l2-async.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n#include \"v4l2-subdev-priv.h\"\n\nstatic int v4l2_async_nf_call_bound(struct v4l2_async_notifier *n,\n\t\t\t\t    struct v4l2_subdev *subdev,\n\t\t\t\t    struct v4l2_async_connection *asc)\n{\n\tif (!n->ops || !n->ops->bound)\n\t\treturn 0;\n\n\treturn n->ops->bound(n, subdev, asc);\n}\n\nstatic void v4l2_async_nf_call_unbind(struct v4l2_async_notifier *n,\n\t\t\t\t      struct v4l2_subdev *subdev,\n\t\t\t\t      struct v4l2_async_connection *asc)\n{\n\tif (!n->ops || !n->ops->unbind)\n\t\treturn;\n\n\tn->ops->unbind(n, subdev, asc);\n}\n\nstatic int v4l2_async_nf_call_complete(struct v4l2_async_notifier *n)\n{\n\tif (!n->ops || !n->ops->complete)\n\t\treturn 0;\n\n\treturn n->ops->complete(n);\n}\n\nstatic void v4l2_async_nf_call_destroy(struct v4l2_async_notifier *n,\n\t\t\t\t       struct v4l2_async_connection *asc)\n{\n\tif (!n->ops || !n->ops->destroy)\n\t\treturn;\n\n\tn->ops->destroy(asc);\n}\n\nstatic bool match_i2c(struct v4l2_async_notifier *notifier,\n\t\t      struct v4l2_subdev *sd,\n\t\t      struct v4l2_async_match_desc *match)\n{\n#if IS_ENABLED(CONFIG_I2C)\n\tstruct i2c_client *client = i2c_verify_client(sd->dev);\n\n\treturn client &&\n\t\tmatch->i2c.adapter_id == client->adapter->nr &&\n\t\tmatch->i2c.address == client->addr;\n#else\n\treturn false;\n#endif\n}\n\nstatic struct device *notifier_dev(struct v4l2_async_notifier *notifier)\n{\n\tif (notifier->sd)\n\t\treturn notifier->sd->dev;\n\n\tif (notifier->v4l2_dev)\n\t\treturn notifier->v4l2_dev->dev;\n\n\treturn NULL;\n}\n\nstatic bool\nmatch_fwnode_one(struct v4l2_async_notifier *notifier,\n\t\t struct v4l2_subdev *sd, struct fwnode_handle *sd_fwnode,\n\t\t struct v4l2_async_match_desc *match)\n{\n\tstruct fwnode_handle *asd_dev_fwnode;\n\tbool ret;\n\n\tdev_dbg(notifier_dev(notifier),\n\t\t\"v4l2-async: fwnode match: need %pfw, trying %pfw\\n\",\n\t\tsd_fwnode, match->fwnode);\n\n\tif (sd_fwnode == match->fwnode) {\n\t\tdev_dbg(notifier_dev(notifier),\n\t\t\t\"v4l2-async: direct match found\\n\");\n\t\treturn true;\n\t}\n\n\tif (!fwnode_graph_is_endpoint(match->fwnode)) {\n\t\tdev_dbg(notifier_dev(notifier),\n\t\t\t\"v4l2-async: direct match not found\\n\");\n\t\treturn false;\n\t}\n\n\tasd_dev_fwnode = fwnode_graph_get_port_parent(match->fwnode);\n\n\tret = sd_fwnode == asd_dev_fwnode;\n\n\tfwnode_handle_put(asd_dev_fwnode);\n\n\tdev_dbg(notifier_dev(notifier),\n\t\t\"v4l2-async: device--endpoint match %sfound\\n\",\n\t\tret ? \"\" : \"not \");\n\n\treturn ret;\n}\n\nstatic bool match_fwnode(struct v4l2_async_notifier *notifier,\n\t\t\t struct v4l2_subdev *sd,\n\t\t\t struct v4l2_async_match_desc *match)\n{\n\tdev_dbg(notifier_dev(notifier),\n\t\t\"v4l2-async: matching for notifier %pfw, sd fwnode %pfw\\n\",\n\t\tdev_fwnode(notifier_dev(notifier)), sd->fwnode);\n\n\tif (!list_empty(&sd->async_subdev_endpoint_list)) {\n\t\tstruct v4l2_async_subdev_endpoint *ase;\n\n\t\tdev_dbg(sd->dev,\n\t\t\t\"v4l2-async: endpoint fwnode list available, looking for %pfw\\n\",\n\t\t\tmatch->fwnode);\n\n\t\tlist_for_each_entry(ase, &sd->async_subdev_endpoint_list,\n\t\t\t\t    async_subdev_endpoint_entry) {\n\t\t\tbool matched = ase->endpoint == match->fwnode;\n\n\t\t\tdev_dbg(sd->dev,\n\t\t\t\t\"v4l2-async: endpoint-endpoint match %sfound with %pfw\\n\",\n\t\t\t\tmatched ? \"\" : \"not \", ase->endpoint);\n\n\t\t\tif (matched)\n\t\t\t\treturn true;\n\t\t}\n\n\t\tdev_dbg(sd->dev, \"async: no endpoint matched\\n\");\n\n\t\treturn false;\n\t}\n\n\tif (match_fwnode_one(notifier, sd, sd->fwnode, match))\n\t\treturn true;\n\n\t \n\tif (IS_ERR_OR_NULL(sd->fwnode->secondary))\n\t\treturn false;\n\n\tdev_dbg(notifier_dev(notifier),\n\t\t\"v4l2-async: trying secondary fwnode match\\n\");\n\n\treturn match_fwnode_one(notifier, sd, sd->fwnode->secondary, match);\n}\n\nstatic LIST_HEAD(subdev_list);\nstatic LIST_HEAD(notifier_list);\nstatic DEFINE_MUTEX(list_lock);\n\nstatic struct v4l2_async_connection *\nv4l2_async_find_match(struct v4l2_async_notifier *notifier,\n\t\t      struct v4l2_subdev *sd)\n{\n\tbool (*match)(struct v4l2_async_notifier *notifier,\n\t\t      struct v4l2_subdev *sd,\n\t\t      struct v4l2_async_match_desc *match);\n\tstruct v4l2_async_connection *asc;\n\n\tlist_for_each_entry(asc, &notifier->waiting_list, asc_entry) {\n\t\t \n\t\tswitch (asc->match.type) {\n\t\tcase V4L2_ASYNC_MATCH_TYPE_I2C:\n\t\t\tmatch = match_i2c;\n\t\t\tbreak;\n\t\tcase V4L2_ASYNC_MATCH_TYPE_FWNODE:\n\t\t\tmatch = match_fwnode;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tWARN_ON(true);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tif (match(notifier, sd, &asc->match))\n\t\t\treturn asc;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic bool v4l2_async_match_equal(struct v4l2_async_match_desc *match1,\n\t\t\t\t   struct v4l2_async_match_desc *match2)\n{\n\tif (match1->type != match2->type)\n\t\treturn false;\n\n\tswitch (match1->type) {\n\tcase V4L2_ASYNC_MATCH_TYPE_I2C:\n\t\treturn match1->i2c.adapter_id == match2->i2c.adapter_id &&\n\t\t\tmatch1->i2c.address == match2->i2c.address;\n\tcase V4L2_ASYNC_MATCH_TYPE_FWNODE:\n\t\treturn match1->fwnode == match2->fwnode;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\n \nstatic struct v4l2_async_notifier *\nv4l2_async_find_subdev_notifier(struct v4l2_subdev *sd)\n{\n\tstruct v4l2_async_notifier *n;\n\n\tlist_for_each_entry(n, &notifier_list, notifier_entry)\n\t\tif (n->sd == sd)\n\t\t\treturn n;\n\n\treturn NULL;\n}\n\n \nstatic struct v4l2_device *\nv4l2_async_nf_find_v4l2_dev(struct v4l2_async_notifier *notifier)\n{\n\twhile (notifier->parent)\n\t\tnotifier = notifier->parent;\n\n\treturn notifier->v4l2_dev;\n}\n\n \nstatic bool\nv4l2_async_nf_can_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct v4l2_async_connection *asc;\n\n\tif (!list_empty(&notifier->waiting_list))\n\t\treturn false;\n\n\tlist_for_each_entry(asc, &notifier->done_list, asc_entry) {\n\t\tstruct v4l2_async_notifier *subdev_notifier =\n\t\t\tv4l2_async_find_subdev_notifier(asc->sd);\n\n\t\tif (subdev_notifier &&\n\t\t    !v4l2_async_nf_can_complete(subdev_notifier))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic int\nv4l2_async_nf_try_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct v4l2_async_notifier *__notifier = notifier;\n\n\t \n\tif (!list_empty(&notifier->waiting_list))\n\t\treturn 0;\n\n\tif (notifier->sd)\n\t\tdev_dbg(notifier_dev(notifier),\n\t\t\t\"v4l2-async: trying to complete\\n\");\n\n\t \n\twhile (notifier->parent)\n\t\tnotifier = notifier->parent;\n\n\t \n\tif (!notifier->v4l2_dev) {\n\t\tdev_dbg(notifier_dev(__notifier),\n\t\t\t\"v4l2-async: V4L2 device not available\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (!v4l2_async_nf_can_complete(notifier))\n\t\treturn 0;\n\n\tdev_dbg(notifier_dev(__notifier), \"v4l2-async: complete\\n\");\n\n\treturn v4l2_async_nf_call_complete(notifier);\n}\n\nstatic int\nv4l2_async_nf_try_all_subdevs(struct v4l2_async_notifier *notifier);\n\nstatic int v4l2_async_create_ancillary_links(struct v4l2_async_notifier *n,\n\t\t\t\t\t     struct v4l2_subdev *sd)\n{\n\tstruct media_link *link = NULL;\n\n#if IS_ENABLED(CONFIG_MEDIA_CONTROLLER)\n\n\tif (sd->entity.function != MEDIA_ENT_F_LENS &&\n\t    sd->entity.function != MEDIA_ENT_F_FLASH)\n\t\treturn 0;\n\n\tlink = media_create_ancillary_link(&n->sd->entity, &sd->entity);\n\n#endif\n\n\treturn IS_ERR(link) ? PTR_ERR(link) : 0;\n}\n\nstatic int v4l2_async_match_notify(struct v4l2_async_notifier *notifier,\n\t\t\t\t   struct v4l2_device *v4l2_dev,\n\t\t\t\t   struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_async_connection *asc)\n{\n\tstruct v4l2_async_notifier *subdev_notifier;\n\tbool registered = false;\n\tint ret;\n\n\tif (list_empty(&sd->asc_list)) {\n\t\tret = v4l2_device_register_subdev(v4l2_dev, sd);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tregistered = true;\n\t}\n\n\tret = v4l2_async_nf_call_bound(notifier, sd, asc);\n\tif (ret < 0) {\n\t\tif (asc->match.type == V4L2_ASYNC_MATCH_TYPE_FWNODE)\n\t\t\tdev_dbg(notifier_dev(notifier),\n\t\t\t\t\"failed binding %pfw (%d)\\n\",\n\t\t\t\tasc->match.fwnode, ret);\n\t\tgoto err_unregister_subdev;\n\t}\n\n\tif (registered) {\n\t\t \n\t\tret = v4l2_async_create_ancillary_links(notifier, sd);\n\t\tif (ret) {\n\t\t\tif (asc->match.type == V4L2_ASYNC_MATCH_TYPE_FWNODE)\n\t\t\t\tdev_dbg(notifier_dev(notifier),\n\t\t\t\t\t\"failed creating links for %pfw (%d)\\n\",\n\t\t\t\t\tasc->match.fwnode, ret);\n\t\t\tgoto err_call_unbind;\n\t\t}\n\t}\n\n\tlist_add(&asc->asc_subdev_entry, &sd->asc_list);\n\tasc->sd = sd;\n\n\t \n\tlist_move(&asc->asc_entry, &notifier->done_list);\n\n\tdev_dbg(notifier_dev(notifier), \"v4l2-async: %s bound (ret %d)\\n\",\n\t\tdev_name(sd->dev), ret);\n\n\t \n\tsubdev_notifier = v4l2_async_find_subdev_notifier(sd);\n\tif (!subdev_notifier || subdev_notifier->parent)\n\t\treturn 0;\n\n\t \n\tsubdev_notifier->parent = notifier;\n\n\treturn v4l2_async_nf_try_all_subdevs(subdev_notifier);\n\nerr_call_unbind:\n\tv4l2_async_nf_call_unbind(notifier, sd, asc);\n\tlist_del(&asc->asc_subdev_entry);\n\nerr_unregister_subdev:\n\tif (registered)\n\t\tv4l2_device_unregister_subdev(sd);\n\n\treturn ret;\n}\n\n \nstatic int\nv4l2_async_nf_try_all_subdevs(struct v4l2_async_notifier *notifier)\n{\n\tstruct v4l2_device *v4l2_dev =\n\t\tv4l2_async_nf_find_v4l2_dev(notifier);\n\tstruct v4l2_subdev *sd;\n\n\tif (!v4l2_dev)\n\t\treturn 0;\n\n\tdev_dbg(notifier_dev(notifier), \"v4l2-async: trying all sub-devices\\n\");\n\nagain:\n\tlist_for_each_entry(sd, &subdev_list, async_list) {\n\t\tstruct v4l2_async_connection *asc;\n\t\tint ret;\n\n\t\tasc = v4l2_async_find_match(notifier, sd);\n\t\tif (!asc)\n\t\t\tcontinue;\n\n\t\tdev_dbg(notifier_dev(notifier),\n\t\t\t\"v4l2-async: match found, subdev %s\\n\", sd->name);\n\n\t\tret = v4l2_async_match_notify(notifier, v4l2_dev, sd, asc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tgoto again;\n\t}\n\n\treturn 0;\n}\n\nstatic void v4l2_async_unbind_subdev_one(struct v4l2_async_notifier *notifier,\n\t\t\t\t\t struct v4l2_async_connection *asc)\n{\n\tlist_move_tail(&asc->asc_entry, &notifier->waiting_list);\n\tif (list_is_singular(&asc->asc_subdev_entry)) {\n\t\tv4l2_async_nf_call_unbind(notifier, asc->sd, asc);\n\t\tv4l2_device_unregister_subdev(asc->sd);\n\t\tasc->sd = NULL;\n\t}\n\tlist_del(&asc->asc_subdev_entry);\n}\n\n \nstatic void\nv4l2_async_nf_unbind_all_subdevs(struct v4l2_async_notifier *notifier)\n{\n\tstruct v4l2_async_connection *asc, *asc_tmp;\n\n\tlist_for_each_entry_safe(asc, asc_tmp, &notifier->done_list,\n\t\t\t\t asc_entry) {\n\t\tstruct v4l2_async_notifier *subdev_notifier =\n\t\t\tv4l2_async_find_subdev_notifier(asc->sd);\n\n\t\tif (subdev_notifier)\n\t\t\tv4l2_async_nf_unbind_all_subdevs(subdev_notifier);\n\n\t\tv4l2_async_unbind_subdev_one(notifier, asc);\n\t}\n\n\tnotifier->parent = NULL;\n}\n\n \nstatic bool\nv4l2_async_nf_has_async_match_entry(struct v4l2_async_notifier *notifier,\n\t\t\t\t    struct v4l2_async_match_desc *match)\n{\n\tstruct v4l2_async_connection *asc;\n\n\tlist_for_each_entry(asc, &notifier->waiting_list, asc_entry)\n\t\tif (v4l2_async_match_equal(&asc->match, match))\n\t\t\treturn true;\n\n\tlist_for_each_entry(asc, &notifier->done_list, asc_entry)\n\t\tif (v4l2_async_match_equal(&asc->match, match))\n\t\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic bool\nv4l2_async_nf_has_async_match(struct v4l2_async_notifier *notifier,\n\t\t\t      struct v4l2_async_match_desc *match)\n{\n\tstruct list_head *heads[] = {\n\t\t&notifier->waiting_list,\n\t\t&notifier->done_list,\n\t};\n\tunsigned int i;\n\n\tlockdep_assert_held(&list_lock);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(heads); i++) {\n\t\tstruct v4l2_async_connection *asc;\n\n\t\tlist_for_each_entry(asc, heads[i], asc_entry) {\n\t\t\tif (&asc->match == match)\n\t\t\t\tcontinue;\n\t\t\tif (v4l2_async_match_equal(&asc->match, match))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(notifier, &notifier_list, notifier_entry)\n\t\tif (v4l2_async_nf_has_async_match_entry(notifier, match))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int v4l2_async_nf_match_valid(struct v4l2_async_notifier *notifier,\n\t\t\t\t     struct v4l2_async_match_desc *match)\n{\n\tstruct device *dev = notifier_dev(notifier);\n\n\tswitch (match->type) {\n\tcase V4L2_ASYNC_MATCH_TYPE_I2C:\n\tcase V4L2_ASYNC_MATCH_TYPE_FWNODE:\n\t\tif (v4l2_async_nf_has_async_match(notifier, match)) {\n\t\t\tdev_dbg(dev, \"v4l2-async: match descriptor already listed in a notifier\\n\");\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"v4l2-async: Invalid match type %u on %p\\n\",\n\t\t\tmatch->type, match);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid v4l2_async_nf_init(struct v4l2_async_notifier *notifier,\n\t\t\tstruct v4l2_device *v4l2_dev)\n{\n\tINIT_LIST_HEAD(&notifier->waiting_list);\n\tINIT_LIST_HEAD(&notifier->done_list);\n\tnotifier->v4l2_dev = v4l2_dev;\n}\nEXPORT_SYMBOL(v4l2_async_nf_init);\n\nvoid v4l2_async_subdev_nf_init(struct v4l2_async_notifier *notifier,\n\t\t\t       struct v4l2_subdev *sd)\n{\n\tINIT_LIST_HEAD(&notifier->waiting_list);\n\tINIT_LIST_HEAD(&notifier->done_list);\n\tnotifier->sd = sd;\n}\nEXPORT_SYMBOL_GPL(v4l2_async_subdev_nf_init);\n\nstatic int __v4l2_async_nf_register(struct v4l2_async_notifier *notifier)\n{\n\tstruct v4l2_async_connection *asc;\n\tint ret;\n\n\tmutex_lock(&list_lock);\n\n\tlist_for_each_entry(asc, &notifier->waiting_list, asc_entry) {\n\t\tret = v4l2_async_nf_match_valid(notifier, &asc->match);\n\t\tif (ret)\n\t\t\tgoto err_unlock;\n\t}\n\n\tret = v4l2_async_nf_try_all_subdevs(notifier);\n\tif (ret < 0)\n\t\tgoto err_unbind;\n\n\tret = v4l2_async_nf_try_complete(notifier);\n\tif (ret < 0)\n\t\tgoto err_unbind;\n\n\t \n\tlist_add(&notifier->notifier_entry, &notifier_list);\n\n\tmutex_unlock(&list_lock);\n\n\treturn 0;\n\nerr_unbind:\n\t \n\tv4l2_async_nf_unbind_all_subdevs(notifier);\n\nerr_unlock:\n\tmutex_unlock(&list_lock);\n\n\treturn ret;\n}\n\nint v4l2_async_nf_register(struct v4l2_async_notifier *notifier)\n{\n\tint ret;\n\n\tif (WARN_ON(!notifier->v4l2_dev == !notifier->sd))\n\t\treturn -EINVAL;\n\n\tret = __v4l2_async_nf_register(notifier);\n\tif (ret)\n\t\tnotifier->v4l2_dev = NULL;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(v4l2_async_nf_register);\n\nstatic void\n__v4l2_async_nf_unregister(struct v4l2_async_notifier *notifier)\n{\n\tif (!notifier || (!notifier->v4l2_dev && !notifier->sd))\n\t\treturn;\n\n\tv4l2_async_nf_unbind_all_subdevs(notifier);\n\n\tlist_del(&notifier->notifier_entry);\n}\n\nvoid v4l2_async_nf_unregister(struct v4l2_async_notifier *notifier)\n{\n\tmutex_lock(&list_lock);\n\n\t__v4l2_async_nf_unregister(notifier);\n\n\tmutex_unlock(&list_lock);\n}\nEXPORT_SYMBOL(v4l2_async_nf_unregister);\n\nstatic void __v4l2_async_nf_cleanup(struct v4l2_async_notifier *notifier)\n{\n\tstruct v4l2_async_connection *asc, *tmp;\n\n\tif (!notifier || !notifier->waiting_list.next)\n\t\treturn;\n\n\tWARN_ON(!list_empty(&notifier->done_list));\n\n\tlist_for_each_entry_safe(asc, tmp, &notifier->waiting_list, asc_entry) {\n\t\tlist_del(&asc->asc_entry);\n\t\tv4l2_async_nf_call_destroy(notifier, asc);\n\n\t\tif (asc->match.type == V4L2_ASYNC_MATCH_TYPE_FWNODE)\n\t\t\tfwnode_handle_put(asc->match.fwnode);\n\n\t\tkfree(asc);\n\t}\n\n\tnotifier->sd = NULL;\n\tnotifier->v4l2_dev = NULL;\n}\n\nvoid v4l2_async_nf_cleanup(struct v4l2_async_notifier *notifier)\n{\n\tmutex_lock(&list_lock);\n\n\t__v4l2_async_nf_cleanup(notifier);\n\n\tmutex_unlock(&list_lock);\n}\nEXPORT_SYMBOL_GPL(v4l2_async_nf_cleanup);\n\nstatic void __v4l2_async_nf_add_connection(struct v4l2_async_notifier *notifier,\n\t\t\t\t\t   struct v4l2_async_connection *asc)\n{\n\tmutex_lock(&list_lock);\n\n\tlist_add_tail(&asc->asc_entry, &notifier->waiting_list);\n\n\tmutex_unlock(&list_lock);\n}\n\nstruct v4l2_async_connection *\n__v4l2_async_nf_add_fwnode(struct v4l2_async_notifier *notifier,\n\t\t\t   struct fwnode_handle *fwnode,\n\t\t\t   unsigned int asc_struct_size)\n{\n\tstruct v4l2_async_connection *asc;\n\n\tasc = kzalloc(asc_struct_size, GFP_KERNEL);\n\tif (!asc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tasc->notifier = notifier;\n\tasc->match.type = V4L2_ASYNC_MATCH_TYPE_FWNODE;\n\tasc->match.fwnode = fwnode_handle_get(fwnode);\n\n\t__v4l2_async_nf_add_connection(notifier, asc);\n\n\treturn asc;\n}\nEXPORT_SYMBOL_GPL(__v4l2_async_nf_add_fwnode);\n\nstruct v4l2_async_connection *\n__v4l2_async_nf_add_fwnode_remote(struct v4l2_async_notifier *notif,\n\t\t\t\t  struct fwnode_handle *endpoint,\n\t\t\t\t  unsigned int asc_struct_size)\n{\n\tstruct v4l2_async_connection *asc;\n\tstruct fwnode_handle *remote;\n\n\tremote = fwnode_graph_get_remote_endpoint(endpoint);\n\tif (!remote)\n\t\treturn ERR_PTR(-ENOTCONN);\n\n\tasc = __v4l2_async_nf_add_fwnode(notif, remote, asc_struct_size);\n\t \n\tfwnode_handle_put(remote);\n\treturn asc;\n}\nEXPORT_SYMBOL_GPL(__v4l2_async_nf_add_fwnode_remote);\n\nstruct v4l2_async_connection *\n__v4l2_async_nf_add_i2c(struct v4l2_async_notifier *notifier, int adapter_id,\n\t\t\tunsigned short address, unsigned int asc_struct_size)\n{\n\tstruct v4l2_async_connection *asc;\n\n\tasc = kzalloc(asc_struct_size, GFP_KERNEL);\n\tif (!asc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tasc->notifier = notifier;\n\tasc->match.type = V4L2_ASYNC_MATCH_TYPE_I2C;\n\tasc->match.i2c.adapter_id = adapter_id;\n\tasc->match.i2c.address = address;\n\n\t__v4l2_async_nf_add_connection(notifier, asc);\n\n\treturn asc;\n}\nEXPORT_SYMBOL_GPL(__v4l2_async_nf_add_i2c);\n\nint v4l2_async_subdev_endpoint_add(struct v4l2_subdev *sd,\n\t\t\t\t   struct fwnode_handle *fwnode)\n{\n\tstruct v4l2_async_subdev_endpoint *ase;\n\n\tase = kmalloc(sizeof(*ase), GFP_KERNEL);\n\tif (!ase)\n\t\treturn -ENOMEM;\n\n\tase->endpoint = fwnode;\n\tlist_add(&ase->async_subdev_endpoint_entry,\n\t\t &sd->async_subdev_endpoint_list);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(v4l2_async_subdev_endpoint_add);\n\nstruct v4l2_async_connection *\nv4l2_async_connection_unique(struct v4l2_subdev *sd)\n{\n\tif (!list_is_singular(&sd->asc_list))\n\t\treturn NULL;\n\n\treturn list_first_entry(&sd->asc_list,\n\t\t\t\tstruct v4l2_async_connection, asc_subdev_entry);\n}\nEXPORT_SYMBOL_GPL(v4l2_async_connection_unique);\n\nint v4l2_async_register_subdev(struct v4l2_subdev *sd)\n{\n\tstruct v4l2_async_notifier *subdev_notifier;\n\tstruct v4l2_async_notifier *notifier;\n\tstruct v4l2_async_connection *asc;\n\tint ret;\n\n\tINIT_LIST_HEAD(&sd->asc_list);\n\n\t \n\tif (!sd->fwnode && sd->dev) {\n\t\tsd->fwnode = dev_fwnode(sd->dev);\n\t} else if (fwnode_graph_is_endpoint(sd->fwnode)) {\n\t\tdev_warn(sd->dev, \"sub-device fwnode is an endpoint!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&list_lock);\n\n\tlist_for_each_entry(notifier, &notifier_list, notifier_entry) {\n\t\tstruct v4l2_device *v4l2_dev =\n\t\t\tv4l2_async_nf_find_v4l2_dev(notifier);\n\n\t\tif (!v4l2_dev)\n\t\t\tcontinue;\n\n\t\twhile ((asc = v4l2_async_find_match(notifier, sd))) {\n\t\t\tret = v4l2_async_match_notify(notifier, v4l2_dev, sd,\n\t\t\t\t\t\t      asc);\n\t\t\tif (ret)\n\t\t\t\tgoto err_unbind;\n\n\t\t\tret = v4l2_async_nf_try_complete(notifier);\n\t\t\tif (ret)\n\t\t\t\tgoto err_unbind;\n\t\t}\n\t}\n\n\t \n\tlist_add(&sd->async_list, &subdev_list);\n\n\tmutex_unlock(&list_lock);\n\n\treturn 0;\n\nerr_unbind:\n\t \n\tsubdev_notifier = v4l2_async_find_subdev_notifier(sd);\n\tif (subdev_notifier)\n\t\tv4l2_async_nf_unbind_all_subdevs(subdev_notifier);\n\n\tif (asc)\n\t\tv4l2_async_unbind_subdev_one(notifier, asc);\n\n\tmutex_unlock(&list_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(v4l2_async_register_subdev);\n\nvoid v4l2_async_unregister_subdev(struct v4l2_subdev *sd)\n{\n\tstruct v4l2_async_connection *asc, *asc_tmp;\n\n\tif (!sd->async_list.next)\n\t\treturn;\n\n\tv4l2_subdev_put_privacy_led(sd);\n\n\tmutex_lock(&list_lock);\n\n\t__v4l2_async_nf_unregister(sd->subdev_notifier);\n\t__v4l2_async_nf_cleanup(sd->subdev_notifier);\n\tkfree(sd->subdev_notifier);\n\tsd->subdev_notifier = NULL;\n\n\tif (sd->asc_list.next) {\n\t\tlist_for_each_entry_safe(asc, asc_tmp, &sd->asc_list,\n\t\t\t\t\t asc_subdev_entry) {\n\t\t\tlist_move(&asc->asc_entry,\n\t\t\t\t  &asc->notifier->waiting_list);\n\n\t\t\tv4l2_async_unbind_subdev_one(asc->notifier, asc);\n\t\t}\n\t}\n\n\tlist_del(&sd->async_list);\n\tsd->async_list.next = NULL;\n\n\tmutex_unlock(&list_lock);\n}\nEXPORT_SYMBOL(v4l2_async_unregister_subdev);\n\nstatic void print_waiting_match(struct seq_file *s,\n\t\t\t\tstruct v4l2_async_match_desc *match)\n{\n\tswitch (match->type) {\n\tcase V4L2_ASYNC_MATCH_TYPE_I2C:\n\t\tseq_printf(s, \" [i2c] dev=%d-%04x\\n\", match->i2c.adapter_id,\n\t\t\t   match->i2c.address);\n\t\tbreak;\n\tcase V4L2_ASYNC_MATCH_TYPE_FWNODE: {\n\t\tstruct fwnode_handle *devnode, *fwnode = match->fwnode;\n\n\t\tdevnode = fwnode_graph_is_endpoint(fwnode) ?\n\t\t\t  fwnode_graph_get_port_parent(fwnode) :\n\t\t\t  fwnode_handle_get(fwnode);\n\n\t\tseq_printf(s, \" [fwnode] dev=%s, node=%pfw\\n\",\n\t\t\t   devnode->dev ? dev_name(devnode->dev) : \"nil\",\n\t\t\t   fwnode);\n\n\t\tfwnode_handle_put(devnode);\n\t\tbreak;\n\t}\n\t}\n}\n\nstatic const char *\nv4l2_async_nf_name(struct v4l2_async_notifier *notifier)\n{\n\tif (notifier->v4l2_dev)\n\t\treturn notifier->v4l2_dev->name;\n\telse if (notifier->sd)\n\t\treturn notifier->sd->name;\n\telse\n\t\treturn \"nil\";\n}\n\nstatic int pending_subdevs_show(struct seq_file *s, void *data)\n{\n\tstruct v4l2_async_notifier *notif;\n\tstruct v4l2_async_connection *asc;\n\n\tmutex_lock(&list_lock);\n\n\tlist_for_each_entry(notif, &notifier_list, notifier_entry) {\n\t\tseq_printf(s, \"%s:\\n\", v4l2_async_nf_name(notif));\n\t\tlist_for_each_entry(asc, &notif->waiting_list, asc_entry)\n\t\t\tprint_waiting_match(s, &asc->match);\n\t}\n\n\tmutex_unlock(&list_lock);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(pending_subdevs);\n\nstatic struct dentry *v4l2_async_debugfs_dir;\n\nstatic int __init v4l2_async_init(void)\n{\n\tv4l2_async_debugfs_dir = debugfs_create_dir(\"v4l2-async\", NULL);\n\tdebugfs_create_file(\"pending_async_subdevices\", 0444,\n\t\t\t    v4l2_async_debugfs_dir, NULL,\n\t\t\t    &pending_subdevs_fops);\n\n\treturn 0;\n}\n\nstatic void __exit v4l2_async_exit(void)\n{\n\tdebugfs_remove_recursive(v4l2_async_debugfs_dir);\n}\n\nsubsys_initcall(v4l2_async_init);\nmodule_exit(v4l2_async_exit);\n\nMODULE_AUTHOR(\"Guennadi Liakhovetski <g.liakhovetski@gmx.de>\");\nMODULE_AUTHOR(\"Sakari Ailus <sakari.ailus@linux.intel.com>\");\nMODULE_AUTHOR(\"Ezequiel Garcia <ezequiel@collabora.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}