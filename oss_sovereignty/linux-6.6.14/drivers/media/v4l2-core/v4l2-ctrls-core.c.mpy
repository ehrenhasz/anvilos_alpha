{
  "module_name": "v4l2-ctrls-core.c",
  "hash_id": "f6d6458428c969a1ec1d60957709bbbb894372cbd486d8f1bdc3a54f4f9498fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/v4l2-ctrls-core.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fwnode.h>\n\n#include \"v4l2-ctrls-priv.h\"\n\nstatic const union v4l2_ctrl_ptr ptr_null;\n\nstatic void fill_event(struct v4l2_event *ev, struct v4l2_ctrl *ctrl,\n\t\t       u32 changes)\n{\n\tmemset(ev, 0, sizeof(*ev));\n\tev->type = V4L2_EVENT_CTRL;\n\tev->id = ctrl->id;\n\tev->u.ctrl.changes = changes;\n\tev->u.ctrl.type = ctrl->type;\n\tev->u.ctrl.flags = user_flags(ctrl);\n\tif (ctrl->is_ptr)\n\t\tev->u.ctrl.value64 = 0;\n\telse\n\t\tev->u.ctrl.value64 = *ctrl->p_cur.p_s64;\n\tev->u.ctrl.minimum = ctrl->minimum;\n\tev->u.ctrl.maximum = ctrl->maximum;\n\tif (ctrl->type == V4L2_CTRL_TYPE_MENU\n\t    || ctrl->type == V4L2_CTRL_TYPE_INTEGER_MENU)\n\t\tev->u.ctrl.step = 1;\n\telse\n\t\tev->u.ctrl.step = ctrl->step;\n\tev->u.ctrl.default_value = ctrl->default_value;\n}\n\nvoid send_initial_event(struct v4l2_fh *fh, struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_event ev;\n\tu32 changes = V4L2_EVENT_CTRL_CH_FLAGS;\n\n\tif (!(ctrl->flags & V4L2_CTRL_FLAG_WRITE_ONLY))\n\t\tchanges |= V4L2_EVENT_CTRL_CH_VALUE;\n\tfill_event(&ev, ctrl, changes);\n\tv4l2_event_queue_fh(fh, &ev);\n}\n\nvoid send_event(struct v4l2_fh *fh, struct v4l2_ctrl *ctrl, u32 changes)\n{\n\tstruct v4l2_event ev;\n\tstruct v4l2_subscribed_event *sev;\n\n\tif (list_empty(&ctrl->ev_subs))\n\t\treturn;\n\tfill_event(&ev, ctrl, changes);\n\n\tlist_for_each_entry(sev, &ctrl->ev_subs, node)\n\t\tif (sev->fh != fh ||\n\t\t    (sev->flags & V4L2_EVENT_SUB_FL_ALLOW_FEEDBACK))\n\t\t\tv4l2_event_queue_fh(sev->fh, &ev);\n}\n\nbool v4l2_ctrl_type_op_equal(const struct v4l2_ctrl *ctrl,\n\t\t\t     union v4l2_ctrl_ptr ptr1, union v4l2_ctrl_ptr ptr2)\n{\n\tunsigned int i;\n\n\tswitch (ctrl->type) {\n\tcase V4L2_CTRL_TYPE_BUTTON:\n\t\treturn false;\n\tcase V4L2_CTRL_TYPE_STRING:\n\t\tfor (i = 0; i < ctrl->elems; i++) {\n\t\t\tunsigned int idx = i * ctrl->elem_size;\n\n\t\t\t \n\t\t\tif (strcmp(ptr1.p_char + idx, ptr2.p_char + idx))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\tdefault:\n\t\treturn !memcmp(ptr1.p_const, ptr2.p_const,\n\t\t\t       ctrl->elems * ctrl->elem_size);\n\t}\n}\nEXPORT_SYMBOL(v4l2_ctrl_type_op_equal);\n\n \nstatic const u8 mpeg2_intra_quant_matrix[64] = {\n\t8,  16, 16, 19, 16, 19, 22, 22,\n\t22, 22, 22, 22, 26, 24, 26, 27,\n\t27, 27, 26, 26, 26, 26, 27, 27,\n\t27, 29, 29, 29, 34, 34, 34, 29,\n\t29, 29, 27, 27, 29, 29, 32, 32,\n\t34, 34, 37, 38, 37, 35, 35, 34,\n\t35, 38, 38, 40, 40, 40, 48, 48,\n\t46, 46, 56, 56, 58, 69, 69, 83\n};\n\nstatic void std_init_compound(const struct v4l2_ctrl *ctrl, u32 idx,\n\t\t\t      union v4l2_ctrl_ptr ptr)\n{\n\tstruct v4l2_ctrl_mpeg2_sequence *p_mpeg2_sequence;\n\tstruct v4l2_ctrl_mpeg2_picture *p_mpeg2_picture;\n\tstruct v4l2_ctrl_mpeg2_quantisation *p_mpeg2_quant;\n\tstruct v4l2_ctrl_vp8_frame *p_vp8_frame;\n\tstruct v4l2_ctrl_vp9_frame *p_vp9_frame;\n\tstruct v4l2_ctrl_fwht_params *p_fwht_params;\n\tstruct v4l2_ctrl_h264_scaling_matrix *p_h264_scaling_matrix;\n\tstruct v4l2_ctrl_av1_sequence *p_av1_sequence;\n\tvoid *p = ptr.p + idx * ctrl->elem_size;\n\n\tif (ctrl->p_def.p_const)\n\t\tmemcpy(p, ctrl->p_def.p_const, ctrl->elem_size);\n\telse\n\t\tmemset(p, 0, ctrl->elem_size);\n\n\tswitch ((u32)ctrl->type) {\n\tcase V4L2_CTRL_TYPE_MPEG2_SEQUENCE:\n\t\tp_mpeg2_sequence = p;\n\n\t\t \n\t\tp_mpeg2_sequence->chroma_format = 1;\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_MPEG2_PICTURE:\n\t\tp_mpeg2_picture = p;\n\n\t\t \n\t\tp_mpeg2_picture->picture_structure = V4L2_MPEG2_PIC_TOP_FIELD;\n\t\tp_mpeg2_picture->picture_coding_type =\n\t\t\t\t\tV4L2_MPEG2_PIC_CODING_TYPE_I;\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_MPEG2_QUANTISATION:\n\t\tp_mpeg2_quant = p;\n\n\t\tmemcpy(p_mpeg2_quant->intra_quantiser_matrix,\n\t\t       mpeg2_intra_quant_matrix,\n\t\t       ARRAY_SIZE(mpeg2_intra_quant_matrix));\n\t\t \n\t\tmemset(p_mpeg2_quant->non_intra_quantiser_matrix, 16,\n\t\t       sizeof(p_mpeg2_quant->non_intra_quantiser_matrix));\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_VP8_FRAME:\n\t\tp_vp8_frame = p;\n\t\tp_vp8_frame->num_dct_parts = 1;\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_VP9_FRAME:\n\t\tp_vp9_frame = p;\n\t\tp_vp9_frame->profile = 0;\n\t\tp_vp9_frame->bit_depth = 8;\n\t\tp_vp9_frame->flags |= V4L2_VP9_FRAME_FLAG_X_SUBSAMPLING |\n\t\t\tV4L2_VP9_FRAME_FLAG_Y_SUBSAMPLING;\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_AV1_SEQUENCE:\n\t\tp_av1_sequence = p;\n\t\tp_av1_sequence->bit_depth = 8;\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_FWHT_PARAMS:\n\t\tp_fwht_params = p;\n\t\tp_fwht_params->version = V4L2_FWHT_VERSION;\n\t\tp_fwht_params->width = 1280;\n\t\tp_fwht_params->height = 720;\n\t\tp_fwht_params->flags = V4L2_FWHT_FL_PIXENC_YUV |\n\t\t\t(2 << V4L2_FWHT_FL_COMPONENTS_NUM_OFFSET);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_H264_SCALING_MATRIX:\n\t\tp_h264_scaling_matrix = p;\n\t\t \n\t\tmemset(p_h264_scaling_matrix, 16, sizeof(*p_h264_scaling_matrix));\n\t\tbreak;\n\t}\n}\n\nvoid v4l2_ctrl_type_op_init(const struct v4l2_ctrl *ctrl, u32 from_idx,\n\t\t\t    union v4l2_ctrl_ptr ptr)\n{\n\tunsigned int i;\n\tu32 tot_elems = ctrl->elems;\n\tu32 elems = tot_elems - from_idx;\n\n\tif (from_idx >= tot_elems)\n\t\treturn;\n\n\tswitch (ctrl->type) {\n\tcase V4L2_CTRL_TYPE_STRING:\n\t\tfor (i = from_idx; i < tot_elems; i++) {\n\t\t\tunsigned int offset = i * ctrl->elem_size;\n\n\t\t\tmemset(ptr.p_char + offset, ' ', ctrl->minimum);\n\t\t\tptr.p_char[offset + ctrl->minimum] = '\\0';\n\t\t}\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_INTEGER64:\n\t\tif (ctrl->default_value) {\n\t\t\tfor (i = from_idx; i < tot_elems; i++)\n\t\t\t\tptr.p_s64[i] = ctrl->default_value;\n\t\t} else {\n\t\t\tmemset(ptr.p_s64 + from_idx, 0, elems * sizeof(s64));\n\t\t}\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_INTEGER:\n\tcase V4L2_CTRL_TYPE_INTEGER_MENU:\n\tcase V4L2_CTRL_TYPE_MENU:\n\tcase V4L2_CTRL_TYPE_BITMASK:\n\tcase V4L2_CTRL_TYPE_BOOLEAN:\n\t\tif (ctrl->default_value) {\n\t\t\tfor (i = from_idx; i < tot_elems; i++)\n\t\t\t\tptr.p_s32[i] = ctrl->default_value;\n\t\t} else {\n\t\t\tmemset(ptr.p_s32 + from_idx, 0, elems * sizeof(s32));\n\t\t}\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_BUTTON:\n\tcase V4L2_CTRL_TYPE_CTRL_CLASS:\n\t\tmemset(ptr.p_s32 + from_idx, 0, elems * sizeof(s32));\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_U8:\n\t\tmemset(ptr.p_u8 + from_idx, ctrl->default_value, elems);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_U16:\n\t\tif (ctrl->default_value) {\n\t\t\tfor (i = from_idx; i < tot_elems; i++)\n\t\t\t\tptr.p_u16[i] = ctrl->default_value;\n\t\t} else {\n\t\t\tmemset(ptr.p_u16 + from_idx, 0, elems * sizeof(u16));\n\t\t}\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_U32:\n\t\tif (ctrl->default_value) {\n\t\t\tfor (i = from_idx; i < tot_elems; i++)\n\t\t\t\tptr.p_u32[i] = ctrl->default_value;\n\t\t} else {\n\t\t\tmemset(ptr.p_u32 + from_idx, 0, elems * sizeof(u32));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfor (i = from_idx; i < tot_elems; i++)\n\t\t\tstd_init_compound(ctrl, i, ptr);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(v4l2_ctrl_type_op_init);\n\nvoid v4l2_ctrl_type_op_log(const struct v4l2_ctrl *ctrl)\n{\n\tunion v4l2_ctrl_ptr ptr = ctrl->p_cur;\n\n\tif (ctrl->is_array) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ctrl->nr_of_dims; i++)\n\t\t\tpr_cont(\"[%u]\", ctrl->dims[i]);\n\t\tpr_cont(\" \");\n\t}\n\n\tswitch (ctrl->type) {\n\tcase V4L2_CTRL_TYPE_INTEGER:\n\t\tpr_cont(\"%d\", *ptr.p_s32);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_BOOLEAN:\n\t\tpr_cont(\"%s\", *ptr.p_s32 ? \"true\" : \"false\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_MENU:\n\t\tpr_cont(\"%s\", ctrl->qmenu[*ptr.p_s32]);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_INTEGER_MENU:\n\t\tpr_cont(\"%lld\", ctrl->qmenu_int[*ptr.p_s32]);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_BITMASK:\n\t\tpr_cont(\"0x%08x\", *ptr.p_s32);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_INTEGER64:\n\t\tpr_cont(\"%lld\", *ptr.p_s64);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_STRING:\n\t\tpr_cont(\"%s\", ptr.p_char);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_U8:\n\t\tpr_cont(\"%u\", (unsigned)*ptr.p_u8);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_U16:\n\t\tpr_cont(\"%u\", (unsigned)*ptr.p_u16);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_U32:\n\t\tpr_cont(\"%u\", (unsigned)*ptr.p_u32);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_H264_SPS:\n\t\tpr_cont(\"H264_SPS\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_H264_PPS:\n\t\tpr_cont(\"H264_PPS\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_H264_SCALING_MATRIX:\n\t\tpr_cont(\"H264_SCALING_MATRIX\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_H264_SLICE_PARAMS:\n\t\tpr_cont(\"H264_SLICE_PARAMS\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_H264_DECODE_PARAMS:\n\t\tpr_cont(\"H264_DECODE_PARAMS\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_H264_PRED_WEIGHTS:\n\t\tpr_cont(\"H264_PRED_WEIGHTS\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_FWHT_PARAMS:\n\t\tpr_cont(\"FWHT_PARAMS\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_VP8_FRAME:\n\t\tpr_cont(\"VP8_FRAME\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_HDR10_CLL_INFO:\n\t\tpr_cont(\"HDR10_CLL_INFO\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_HDR10_MASTERING_DISPLAY:\n\t\tpr_cont(\"HDR10_MASTERING_DISPLAY\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_MPEG2_QUANTISATION:\n\t\tpr_cont(\"MPEG2_QUANTISATION\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_MPEG2_SEQUENCE:\n\t\tpr_cont(\"MPEG2_SEQUENCE\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_MPEG2_PICTURE:\n\t\tpr_cont(\"MPEG2_PICTURE\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_VP9_COMPRESSED_HDR:\n\t\tpr_cont(\"VP9_COMPRESSED_HDR\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_VP9_FRAME:\n\t\tpr_cont(\"VP9_FRAME\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_HEVC_SPS:\n\t\tpr_cont(\"HEVC_SPS\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_HEVC_PPS:\n\t\tpr_cont(\"HEVC_PPS\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_HEVC_SLICE_PARAMS:\n\t\tpr_cont(\"HEVC_SLICE_PARAMS\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_HEVC_SCALING_MATRIX:\n\t\tpr_cont(\"HEVC_SCALING_MATRIX\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_HEVC_DECODE_PARAMS:\n\t\tpr_cont(\"HEVC_DECODE_PARAMS\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_AV1_SEQUENCE:\n\t\tpr_cont(\"AV1_SEQUENCE\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_AV1_TILE_GROUP_ENTRY:\n\t\tpr_cont(\"AV1_TILE_GROUP_ENTRY\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_AV1_FRAME:\n\t\tpr_cont(\"AV1_FRAME\");\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_AV1_FILM_GRAIN:\n\t\tpr_cont(\"AV1_FILM_GRAIN\");\n\t\tbreak;\n\n\tdefault:\n\t\tpr_cont(\"unknown type %d\", ctrl->type);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(v4l2_ctrl_type_op_log);\n\n \n#define ROUND_TO_RANGE(val, offset_type, ctrl)\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\toffset_type offset;\t\t\t\t\t\\\n\tif ((ctrl)->maximum >= 0 &&\t\t\t\t\\\n\t    val >= (ctrl)->maximum - (s32)((ctrl)->step / 2))\t\\\n\t\tval = (ctrl)->maximum;\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\\\n\t\tval += (s32)((ctrl)->step / 2);\t\t\t\\\n\tval = clamp_t(typeof(val), val,\t\t\t\t\\\n\t\t      (ctrl)->minimum, (ctrl)->maximum);\t\\\n\toffset = (val) - (ctrl)->minimum;\t\t\t\\\n\toffset = (ctrl)->step * (offset / (u32)(ctrl)->step);\t\\\n\tval = (ctrl)->minimum + offset;\t\t\t\t\\\n\t0;\t\t\t\t\t\t\t\\\n})\n\n \n\n#define zero_padding(s) \\\n\tmemset(&(s).padding, 0, sizeof((s).padding))\n#define zero_reserved(s) \\\n\tmemset(&(s).reserved, 0, sizeof((s).reserved))\n\nstatic int\nvalidate_vp9_lf_params(struct v4l2_vp9_loop_filter *lf)\n{\n\tunsigned int i;\n\n\tif (lf->flags & ~(V4L2_VP9_LOOP_FILTER_FLAG_DELTA_ENABLED |\n\t\t\t  V4L2_VP9_LOOP_FILTER_FLAG_DELTA_UPDATE))\n\t\treturn -EINVAL;\n\n\t \n\tif (lf->level > GENMASK(5, 0))\n\t\treturn -EINVAL;\n\n\tif (lf->sharpness > GENMASK(2, 0))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(lf->ref_deltas); i++)\n\t\tif (lf->ref_deltas[i] < -63 || lf->ref_deltas[i] > 63)\n\t\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(lf->mode_deltas); i++)\n\t\tif (lf->mode_deltas[i] < -63 || lf->mode_deltas[i] > 63)\n\t\t\treturn -EINVAL;\n\n\tzero_reserved(*lf);\n\treturn 0;\n}\n\nstatic int\nvalidate_vp9_quant_params(struct v4l2_vp9_quantization *quant)\n{\n\tif (quant->delta_q_y_dc < -15 || quant->delta_q_y_dc > 15 ||\n\t    quant->delta_q_uv_dc < -15 || quant->delta_q_uv_dc > 15 ||\n\t    quant->delta_q_uv_ac < -15 || quant->delta_q_uv_ac > 15)\n\t\treturn -EINVAL;\n\n\tzero_reserved(*quant);\n\treturn 0;\n}\n\nstatic int\nvalidate_vp9_seg_params(struct v4l2_vp9_segmentation *seg)\n{\n\tunsigned int i, j;\n\n\tif (seg->flags & ~(V4L2_VP9_SEGMENTATION_FLAG_ENABLED |\n\t\t\t   V4L2_VP9_SEGMENTATION_FLAG_UPDATE_MAP |\n\t\t\t   V4L2_VP9_SEGMENTATION_FLAG_TEMPORAL_UPDATE |\n\t\t\t   V4L2_VP9_SEGMENTATION_FLAG_UPDATE_DATA |\n\t\t\t   V4L2_VP9_SEGMENTATION_FLAG_ABS_OR_DELTA_UPDATE))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(seg->feature_enabled); i++) {\n\t\tif (seg->feature_enabled[i] &\n\t\t    ~V4L2_VP9_SEGMENT_FEATURE_ENABLED_MASK)\n\t\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(seg->feature_data); i++) {\n\t\tstatic const int range[] = { 255, 63, 3, 0 };\n\n\t\tfor (j = 0; j < ARRAY_SIZE(seg->feature_data[j]); j++) {\n\t\t\tif (seg->feature_data[i][j] < -range[j] ||\n\t\t\t    seg->feature_data[i][j] > range[j])\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tzero_reserved(*seg);\n\treturn 0;\n}\n\nstatic int\nvalidate_vp9_compressed_hdr(struct v4l2_ctrl_vp9_compressed_hdr *hdr)\n{\n\tif (hdr->tx_mode > V4L2_VP9_TX_MODE_SELECT)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nvalidate_vp9_frame(struct v4l2_ctrl_vp9_frame *frame)\n{\n\tint ret;\n\n\t \n\tif (frame->flags & ~(V4L2_VP9_FRAME_FLAG_KEY_FRAME |\n\t\t  V4L2_VP9_FRAME_FLAG_SHOW_FRAME |\n\t\t  V4L2_VP9_FRAME_FLAG_ERROR_RESILIENT |\n\t\t  V4L2_VP9_FRAME_FLAG_INTRA_ONLY |\n\t\t  V4L2_VP9_FRAME_FLAG_ALLOW_HIGH_PREC_MV |\n\t\t  V4L2_VP9_FRAME_FLAG_REFRESH_FRAME_CTX |\n\t\t  V4L2_VP9_FRAME_FLAG_PARALLEL_DEC_MODE |\n\t\t  V4L2_VP9_FRAME_FLAG_X_SUBSAMPLING |\n\t\t  V4L2_VP9_FRAME_FLAG_Y_SUBSAMPLING |\n\t\t  V4L2_VP9_FRAME_FLAG_COLOR_RANGE_FULL_SWING))\n\t\treturn -EINVAL;\n\n\tif (frame->flags & V4L2_VP9_FRAME_FLAG_ERROR_RESILIENT &&\n\t    frame->flags & V4L2_VP9_FRAME_FLAG_REFRESH_FRAME_CTX)\n\t\treturn -EINVAL;\n\n\tif (frame->profile > V4L2_VP9_PROFILE_MAX)\n\t\treturn -EINVAL;\n\n\tif (frame->reset_frame_context > V4L2_VP9_RESET_FRAME_CTX_ALL)\n\t\treturn -EINVAL;\n\n\tif (frame->frame_context_idx >= V4L2_VP9_NUM_FRAME_CTX)\n\t\treturn -EINVAL;\n\n\t \n\tif ((frame->profile < 2 && frame->bit_depth != 8) ||\n\t    (frame->profile >= 2 &&\n\t     (frame->bit_depth != 10 && frame->bit_depth != 12)))\n\t\treturn -EINVAL;\n\n\t \n\tif ((frame->profile == 0 || frame->profile == 2) &&\n\t    (!(frame->flags & V4L2_VP9_FRAME_FLAG_X_SUBSAMPLING) ||\n\t     !(frame->flags & V4L2_VP9_FRAME_FLAG_Y_SUBSAMPLING)))\n\t\treturn -EINVAL;\n\n\t \n\tif ((frame->profile == 1 || frame->profile == 3) &&\n\t    ((frame->flags & V4L2_VP9_FRAME_FLAG_X_SUBSAMPLING) &&\n\t     (frame->flags & V4L2_VP9_FRAME_FLAG_Y_SUBSAMPLING)))\n\t\treturn -EINVAL;\n\n\tif (frame->interpolation_filter > V4L2_VP9_INTERP_FILTER_SWITCHABLE)\n\t\treturn -EINVAL;\n\n\t \n\tif (frame->tile_cols_log2 > 6)\n\t\treturn -EINVAL;\n\n\tif (frame->reference_mode > V4L2_VP9_REFERENCE_MODE_SELECT)\n\t\treturn -EINVAL;\n\n\tret = validate_vp9_lf_params(&frame->lf);\n\tif (ret)\n\t\treturn ret;\n\n\tret = validate_vp9_quant_params(&frame->quant);\n\tif (ret)\n\t\treturn ret;\n\n\tret = validate_vp9_seg_params(&frame->seg);\n\tif (ret)\n\t\treturn ret;\n\n\tzero_reserved(*frame);\n\treturn 0;\n}\n\nstatic int validate_av1_quantization(struct v4l2_av1_quantization *q)\n{\n\tif (q->flags > GENMASK(2, 0))\n\t\treturn -EINVAL;\n\n\tif (q->delta_q_y_dc < -64 || q->delta_q_y_dc > 63 ||\n\t    q->delta_q_u_dc < -64 || q->delta_q_u_dc > 63 ||\n\t    q->delta_q_v_dc < -64 || q->delta_q_v_dc > 63 ||\n\t    q->delta_q_u_ac < -64 || q->delta_q_u_ac > 63 ||\n\t    q->delta_q_v_ac < -64 || q->delta_q_v_ac > 63 ||\n\t    q->delta_q_res > GENMASK(1, 0))\n\t\treturn -EINVAL;\n\n\tif (q->qm_y > GENMASK(3, 0) ||\n\t    q->qm_u > GENMASK(3, 0) ||\n\t    q->qm_v > GENMASK(3, 0))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int validate_av1_segmentation(struct v4l2_av1_segmentation *s)\n{\n\tu32 i;\n\tu32 j;\n\n\tif (s->flags > GENMASK(4, 0))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(s->feature_data); i++) {\n\t\tstatic const int segmentation_feature_signed[] = { 1, 1, 1, 1, 1, 0, 0, 0 };\n\t\tstatic const int segmentation_feature_max[] = { 255, 63, 63, 63, 63, 7, 0, 0};\n\n\t\tfor (j = 0; j < ARRAY_SIZE(s->feature_data[j]); j++) {\n\t\t\ts32 limit = segmentation_feature_max[j];\n\n\t\t\tif (segmentation_feature_signed[j]) {\n\t\t\t\tif (s->feature_data[i][j] < -limit ||\n\t\t\t\t    s->feature_data[i][j] > limit)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t} else {\n\t\t\t\tif (s->feature_data[i][j] < 0 || s->feature_data[i][j] > limit)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int validate_av1_loop_filter(struct v4l2_av1_loop_filter *lf)\n{\n\tu32 i;\n\n\tif (lf->flags > GENMASK(3, 0))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(lf->level); i++) {\n\t\tif (lf->level[i] > GENMASK(5, 0))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (lf->sharpness > GENMASK(2, 0))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(lf->ref_deltas); i++) {\n\t\tif (lf->ref_deltas[i] < -64 || lf->ref_deltas[i] > 63)\n\t\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(lf->mode_deltas); i++) {\n\t\tif (lf->mode_deltas[i] < -64 || lf->mode_deltas[i] > 63)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int validate_av1_cdef(struct v4l2_av1_cdef *cdef)\n{\n\tu32 i;\n\n\tif (cdef->damping_minus_3 > GENMASK(1, 0) ||\n\t    cdef->bits > GENMASK(1, 0))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 1 << cdef->bits; i++) {\n\t\tif (cdef->y_pri_strength[i] > GENMASK(3, 0) ||\n\t\t    cdef->y_sec_strength[i] > 4 ||\n\t\t    cdef->uv_pri_strength[i] > GENMASK(3, 0) ||\n\t\t    cdef->uv_sec_strength[i] > 4)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int validate_av1_loop_restauration(struct v4l2_av1_loop_restoration *lr)\n{\n\tif (lr->lr_unit_shift > 3 || lr->lr_uv_shift > 1)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int validate_av1_film_grain(struct v4l2_ctrl_av1_film_grain *fg)\n{\n\tu32 i;\n\n\tif (fg->flags > GENMASK(4, 0))\n\t\treturn -EINVAL;\n\n\tif (fg->film_grain_params_ref_idx > GENMASK(2, 0) ||\n\t    fg->num_y_points > 14 ||\n\t    fg->num_cb_points > 10 ||\n\t    fg->num_cr_points > GENMASK(3, 0) ||\n\t    fg->grain_scaling_minus_8 > GENMASK(1, 0) ||\n\t    fg->ar_coeff_lag > GENMASK(1, 0) ||\n\t    fg->ar_coeff_shift_minus_6 > GENMASK(1, 0) ||\n\t    fg->grain_scale_shift > GENMASK(1, 0))\n\t\treturn -EINVAL;\n\n\tif (!(fg->flags & V4L2_AV1_FILM_GRAIN_FLAG_APPLY_GRAIN))\n\t\treturn 0;\n\n\tfor (i = 1; i < fg->num_y_points; i++)\n\t\tif (fg->point_y_value[i] <= fg->point_y_value[i - 1])\n\t\t\treturn -EINVAL;\n\n\tfor (i = 1; i < fg->num_cb_points; i++)\n\t\tif (fg->point_cb_value[i] <= fg->point_cb_value[i - 1])\n\t\t\treturn -EINVAL;\n\n\tfor (i = 1; i < fg->num_cr_points; i++)\n\t\tif (fg->point_cr_value[i] <= fg->point_cr_value[i - 1])\n\t\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int validate_av1_frame(struct v4l2_ctrl_av1_frame *f)\n{\n\tint ret = 0;\n\n\tret = validate_av1_quantization(&f->quantization);\n\tif (ret)\n\t\treturn ret;\n\tret = validate_av1_segmentation(&f->segmentation);\n\tif (ret)\n\t\treturn ret;\n\tret = validate_av1_loop_filter(&f->loop_filter);\n\tif (ret)\n\t\treturn ret;\n\tret = validate_av1_cdef(&f->cdef);\n\tif (ret)\n\t\treturn ret;\n\tret = validate_av1_loop_restauration(&f->loop_restoration);\n\tif (ret)\n\t\treturn ret;\n\n\tif (f->flags &\n\t~(V4L2_AV1_FRAME_FLAG_SHOW_FRAME |\n\t  V4L2_AV1_FRAME_FLAG_SHOWABLE_FRAME |\n\t  V4L2_AV1_FRAME_FLAG_ERROR_RESILIENT_MODE |\n\t  V4L2_AV1_FRAME_FLAG_DISABLE_CDF_UPDATE |\n\t  V4L2_AV1_FRAME_FLAG_ALLOW_SCREEN_CONTENT_TOOLS |\n\t  V4L2_AV1_FRAME_FLAG_FORCE_INTEGER_MV |\n\t  V4L2_AV1_FRAME_FLAG_ALLOW_INTRABC |\n\t  V4L2_AV1_FRAME_FLAG_USE_SUPERRES |\n\t  V4L2_AV1_FRAME_FLAG_ALLOW_HIGH_PRECISION_MV |\n\t  V4L2_AV1_FRAME_FLAG_IS_MOTION_MODE_SWITCHABLE |\n\t  V4L2_AV1_FRAME_FLAG_USE_REF_FRAME_MVS |\n\t  V4L2_AV1_FRAME_FLAG_DISABLE_FRAME_END_UPDATE_CDF |\n\t  V4L2_AV1_FRAME_FLAG_ALLOW_WARPED_MOTION |\n\t  V4L2_AV1_FRAME_FLAG_REFERENCE_SELECT |\n\t  V4L2_AV1_FRAME_FLAG_REDUCED_TX_SET |\n\t  V4L2_AV1_FRAME_FLAG_SKIP_MODE_ALLOWED |\n\t  V4L2_AV1_FRAME_FLAG_SKIP_MODE_PRESENT |\n\t  V4L2_AV1_FRAME_FLAG_FRAME_SIZE_OVERRIDE |\n\t  V4L2_AV1_FRAME_FLAG_BUFFER_REMOVAL_TIME_PRESENT |\n\t  V4L2_AV1_FRAME_FLAG_FRAME_REFS_SHORT_SIGNALING))\n\t\treturn -EINVAL;\n\n\tif (f->superres_denom > GENMASK(2, 0) + 9)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int validate_av1_sequence(struct v4l2_ctrl_av1_sequence *s)\n{\n\tif (s->flags &\n\t~(V4L2_AV1_SEQUENCE_FLAG_STILL_PICTURE |\n\t V4L2_AV1_SEQUENCE_FLAG_USE_128X128_SUPERBLOCK |\n\t V4L2_AV1_SEQUENCE_FLAG_ENABLE_FILTER_INTRA |\n\t V4L2_AV1_SEQUENCE_FLAG_ENABLE_INTRA_EDGE_FILTER |\n\t V4L2_AV1_SEQUENCE_FLAG_ENABLE_INTERINTRA_COMPOUND |\n\t V4L2_AV1_SEQUENCE_FLAG_ENABLE_MASKED_COMPOUND |\n\t V4L2_AV1_SEQUENCE_FLAG_ENABLE_WARPED_MOTION |\n\t V4L2_AV1_SEQUENCE_FLAG_ENABLE_DUAL_FILTER |\n\t V4L2_AV1_SEQUENCE_FLAG_ENABLE_ORDER_HINT |\n\t V4L2_AV1_SEQUENCE_FLAG_ENABLE_JNT_COMP |\n\t V4L2_AV1_SEQUENCE_FLAG_ENABLE_REF_FRAME_MVS |\n\t V4L2_AV1_SEQUENCE_FLAG_ENABLE_SUPERRES |\n\t V4L2_AV1_SEQUENCE_FLAG_ENABLE_CDEF |\n\t V4L2_AV1_SEQUENCE_FLAG_ENABLE_RESTORATION |\n\t V4L2_AV1_SEQUENCE_FLAG_MONO_CHROME |\n\t V4L2_AV1_SEQUENCE_FLAG_COLOR_RANGE |\n\t V4L2_AV1_SEQUENCE_FLAG_SUBSAMPLING_X |\n\t V4L2_AV1_SEQUENCE_FLAG_SUBSAMPLING_Y |\n\t V4L2_AV1_SEQUENCE_FLAG_FILM_GRAIN_PARAMS_PRESENT |\n\t V4L2_AV1_SEQUENCE_FLAG_SEPARATE_UV_DELTA_Q))\n\t\treturn -EINVAL;\n\n\tif (s->seq_profile == 1 && s->flags & V4L2_AV1_SEQUENCE_FLAG_MONO_CHROME)\n\t\treturn -EINVAL;\n\n\t \n\tif (s->seq_profile > 2)\n\t\treturn -EINVAL;\n\n\t \n\treturn 0;\n}\n\n \nstatic int std_validate_compound(const struct v4l2_ctrl *ctrl, u32 idx,\n\t\t\t\t union v4l2_ctrl_ptr ptr)\n{\n\tstruct v4l2_ctrl_mpeg2_sequence *p_mpeg2_sequence;\n\tstruct v4l2_ctrl_mpeg2_picture *p_mpeg2_picture;\n\tstruct v4l2_ctrl_vp8_frame *p_vp8_frame;\n\tstruct v4l2_ctrl_fwht_params *p_fwht_params;\n\tstruct v4l2_ctrl_h264_sps *p_h264_sps;\n\tstruct v4l2_ctrl_h264_pps *p_h264_pps;\n\tstruct v4l2_ctrl_h264_pred_weights *p_h264_pred_weights;\n\tstruct v4l2_ctrl_h264_slice_params *p_h264_slice_params;\n\tstruct v4l2_ctrl_h264_decode_params *p_h264_dec_params;\n\tstruct v4l2_ctrl_hevc_sps *p_hevc_sps;\n\tstruct v4l2_ctrl_hevc_pps *p_hevc_pps;\n\tstruct v4l2_ctrl_hdr10_mastering_display *p_hdr10_mastering;\n\tstruct v4l2_ctrl_hevc_decode_params *p_hevc_decode_params;\n\tstruct v4l2_area *area;\n\tvoid *p = ptr.p + idx * ctrl->elem_size;\n\tunsigned int i;\n\n\tswitch ((u32)ctrl->type) {\n\tcase V4L2_CTRL_TYPE_MPEG2_SEQUENCE:\n\t\tp_mpeg2_sequence = p;\n\n\t\tswitch (p_mpeg2_sequence->chroma_format) {\n\t\tcase 1:  \n\t\tcase 2:  \n\t\tcase 3:  \n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_MPEG2_PICTURE:\n\t\tp_mpeg2_picture = p;\n\n\t\tswitch (p_mpeg2_picture->intra_dc_precision) {\n\t\tcase 0:  \n\t\tcase 1:  \n\t\tcase 2:  \n\t\tcase 3:  \n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (p_mpeg2_picture->picture_structure) {\n\t\tcase V4L2_MPEG2_PIC_TOP_FIELD:\n\t\tcase V4L2_MPEG2_PIC_BOTTOM_FIELD:\n\t\tcase V4L2_MPEG2_PIC_FRAME:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (p_mpeg2_picture->picture_coding_type) {\n\t\tcase V4L2_MPEG2_PIC_CODING_TYPE_I:\n\t\tcase V4L2_MPEG2_PIC_CODING_TYPE_P:\n\t\tcase V4L2_MPEG2_PIC_CODING_TYPE_B:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tzero_reserved(*p_mpeg2_picture);\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_MPEG2_QUANTISATION:\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_FWHT_PARAMS:\n\t\tp_fwht_params = p;\n\t\tif (p_fwht_params->version < V4L2_FWHT_VERSION)\n\t\t\treturn -EINVAL;\n\t\tif (!p_fwht_params->width || !p_fwht_params->height)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_H264_SPS:\n\t\tp_h264_sps = p;\n\n\t\t \n\t\tif (p_h264_sps->pic_order_cnt_type != 0) {\n\t\t\tp_h264_sps->log2_max_pic_order_cnt_lsb_minus4 = 0;\n\t\t} else if (p_h264_sps->pic_order_cnt_type != 1) {\n\t\t\tp_h264_sps->num_ref_frames_in_pic_order_cnt_cycle = 0;\n\t\t\tp_h264_sps->offset_for_non_ref_pic = 0;\n\t\t\tp_h264_sps->offset_for_top_to_bottom_field = 0;\n\t\t\tmemset(&p_h264_sps->offset_for_ref_frame, 0,\n\t\t\t       sizeof(p_h264_sps->offset_for_ref_frame));\n\t\t}\n\n\t\tif (!V4L2_H264_SPS_HAS_CHROMA_FORMAT(p_h264_sps)) {\n\t\t\tp_h264_sps->chroma_format_idc = 1;\n\t\t\tp_h264_sps->bit_depth_luma_minus8 = 0;\n\t\t\tp_h264_sps->bit_depth_chroma_minus8 = 0;\n\n\t\t\tp_h264_sps->flags &=\n\t\t\t\t~V4L2_H264_SPS_FLAG_QPPRIME_Y_ZERO_TRANSFORM_BYPASS;\n\n\t\t\tif (p_h264_sps->chroma_format_idc < 3)\n\t\t\t\tp_h264_sps->flags &=\n\t\t\t\t\t~V4L2_H264_SPS_FLAG_SEPARATE_COLOUR_PLANE;\n\t\t}\n\n\t\tif (p_h264_sps->flags & V4L2_H264_SPS_FLAG_FRAME_MBS_ONLY)\n\t\t\tp_h264_sps->flags &=\n\t\t\t\t~V4L2_H264_SPS_FLAG_MB_ADAPTIVE_FRAME_FIELD;\n\n\t\t \n\t\tif (p_h264_sps->profile_idc < 122 &&\n\t\t    p_h264_sps->chroma_format_idc > 1)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (p_h264_sps->profile_idc < 244 &&\n\t\t    p_h264_sps->chroma_format_idc > 2)\n\t\t\treturn -EINVAL;\n\t\tif (p_h264_sps->chroma_format_idc > 3)\n\t\t\treturn -EINVAL;\n\n\t\tif (p_h264_sps->bit_depth_luma_minus8 > 6)\n\t\t\treturn -EINVAL;\n\t\tif (p_h264_sps->bit_depth_chroma_minus8 > 6)\n\t\t\treturn -EINVAL;\n\t\tif (p_h264_sps->log2_max_frame_num_minus4 > 12)\n\t\t\treturn -EINVAL;\n\t\tif (p_h264_sps->pic_order_cnt_type > 2)\n\t\t\treturn -EINVAL;\n\t\tif (p_h264_sps->log2_max_pic_order_cnt_lsb_minus4 > 12)\n\t\t\treturn -EINVAL;\n\t\tif (p_h264_sps->max_num_ref_frames > V4L2_H264_REF_LIST_LEN)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_H264_PPS:\n\t\tp_h264_pps = p;\n\n\t\tif (p_h264_pps->num_slice_groups_minus1 > 7)\n\t\t\treturn -EINVAL;\n\t\tif (p_h264_pps->num_ref_idx_l0_default_active_minus1 >\n\t\t    (V4L2_H264_REF_LIST_LEN - 1))\n\t\t\treturn -EINVAL;\n\t\tif (p_h264_pps->num_ref_idx_l1_default_active_minus1 >\n\t\t    (V4L2_H264_REF_LIST_LEN - 1))\n\t\t\treturn -EINVAL;\n\t\tif (p_h264_pps->weighted_bipred_idc > 2)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (p_h264_pps->pic_init_qp_minus26 < -62 ||\n\t\t    p_h264_pps->pic_init_qp_minus26 > 25)\n\t\t\treturn -EINVAL;\n\t\tif (p_h264_pps->pic_init_qs_minus26 < -26 ||\n\t\t    p_h264_pps->pic_init_qs_minus26 > 25)\n\t\t\treturn -EINVAL;\n\t\tif (p_h264_pps->chroma_qp_index_offset < -12 ||\n\t\t    p_h264_pps->chroma_qp_index_offset > 12)\n\t\t\treturn -EINVAL;\n\t\tif (p_h264_pps->second_chroma_qp_index_offset < -12 ||\n\t\t    p_h264_pps->second_chroma_qp_index_offset > 12)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_H264_SCALING_MATRIX:\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_H264_PRED_WEIGHTS:\n\t\tp_h264_pred_weights = p;\n\n\t\tif (p_h264_pred_weights->luma_log2_weight_denom > 7)\n\t\t\treturn -EINVAL;\n\t\tif (p_h264_pred_weights->chroma_log2_weight_denom > 7)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_H264_SLICE_PARAMS:\n\t\tp_h264_slice_params = p;\n\n\t\tif (p_h264_slice_params->slice_type != V4L2_H264_SLICE_TYPE_B)\n\t\t\tp_h264_slice_params->flags &=\n\t\t\t\t~V4L2_H264_SLICE_FLAG_DIRECT_SPATIAL_MV_PRED;\n\n\t\tif (p_h264_slice_params->colour_plane_id > 2)\n\t\t\treturn -EINVAL;\n\t\tif (p_h264_slice_params->cabac_init_idc > 2)\n\t\t\treturn -EINVAL;\n\t\tif (p_h264_slice_params->disable_deblocking_filter_idc > 2)\n\t\t\treturn -EINVAL;\n\t\tif (p_h264_slice_params->slice_alpha_c0_offset_div2 < -6 ||\n\t\t    p_h264_slice_params->slice_alpha_c0_offset_div2 > 6)\n\t\t\treturn -EINVAL;\n\t\tif (p_h264_slice_params->slice_beta_offset_div2 < -6 ||\n\t\t    p_h264_slice_params->slice_beta_offset_div2 > 6)\n\t\t\treturn -EINVAL;\n\n\t\tif (p_h264_slice_params->slice_type == V4L2_H264_SLICE_TYPE_I ||\n\t\t    p_h264_slice_params->slice_type == V4L2_H264_SLICE_TYPE_SI)\n\t\t\tp_h264_slice_params->num_ref_idx_l0_active_minus1 = 0;\n\t\tif (p_h264_slice_params->slice_type != V4L2_H264_SLICE_TYPE_B)\n\t\t\tp_h264_slice_params->num_ref_idx_l1_active_minus1 = 0;\n\n\t\tif (p_h264_slice_params->num_ref_idx_l0_active_minus1 >\n\t\t    (V4L2_H264_REF_LIST_LEN - 1))\n\t\t\treturn -EINVAL;\n\t\tif (p_h264_slice_params->num_ref_idx_l1_active_minus1 >\n\t\t    (V4L2_H264_REF_LIST_LEN - 1))\n\t\t\treturn -EINVAL;\n\t\tzero_reserved(*p_h264_slice_params);\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_H264_DECODE_PARAMS:\n\t\tp_h264_dec_params = p;\n\n\t\tif (p_h264_dec_params->nal_ref_idc > 3)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < V4L2_H264_NUM_DPB_ENTRIES; i++) {\n\t\t\tstruct v4l2_h264_dpb_entry *dpb_entry =\n\t\t\t\t&p_h264_dec_params->dpb[i];\n\n\t\t\tzero_reserved(*dpb_entry);\n\t\t}\n\t\tzero_reserved(*p_h264_dec_params);\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_VP8_FRAME:\n\t\tp_vp8_frame = p;\n\n\t\tswitch (p_vp8_frame->num_dct_parts) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 4:\n\t\tcase 8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tzero_padding(p_vp8_frame->segment);\n\t\tzero_padding(p_vp8_frame->lf);\n\t\tzero_padding(p_vp8_frame->quant);\n\t\tzero_padding(p_vp8_frame->entropy);\n\t\tzero_padding(p_vp8_frame->coder_state);\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_HEVC_SPS:\n\t\tp_hevc_sps = p;\n\n\t\tif (!(p_hevc_sps->flags & V4L2_HEVC_SPS_FLAG_PCM_ENABLED)) {\n\t\t\tp_hevc_sps->pcm_sample_bit_depth_luma_minus1 = 0;\n\t\t\tp_hevc_sps->pcm_sample_bit_depth_chroma_minus1 = 0;\n\t\t\tp_hevc_sps->log2_min_pcm_luma_coding_block_size_minus3 = 0;\n\t\t\tp_hevc_sps->log2_diff_max_min_pcm_luma_coding_block_size = 0;\n\t\t}\n\n\t\tif (!(p_hevc_sps->flags &\n\t\t      V4L2_HEVC_SPS_FLAG_LONG_TERM_REF_PICS_PRESENT))\n\t\t\tp_hevc_sps->num_long_term_ref_pics_sps = 0;\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_HEVC_PPS:\n\t\tp_hevc_pps = p;\n\n\t\tif (!(p_hevc_pps->flags &\n\t\t      V4L2_HEVC_PPS_FLAG_CU_QP_DELTA_ENABLED))\n\t\t\tp_hevc_pps->diff_cu_qp_delta_depth = 0;\n\n\t\tif (!(p_hevc_pps->flags & V4L2_HEVC_PPS_FLAG_TILES_ENABLED)) {\n\t\t\tp_hevc_pps->num_tile_columns_minus1 = 0;\n\t\t\tp_hevc_pps->num_tile_rows_minus1 = 0;\n\t\t\tmemset(&p_hevc_pps->column_width_minus1, 0,\n\t\t\t       sizeof(p_hevc_pps->column_width_minus1));\n\t\t\tmemset(&p_hevc_pps->row_height_minus1, 0,\n\t\t\t       sizeof(p_hevc_pps->row_height_minus1));\n\n\t\t\tp_hevc_pps->flags &=\n\t\t\t\t~V4L2_HEVC_PPS_FLAG_LOOP_FILTER_ACROSS_TILES_ENABLED;\n\t\t}\n\n\t\tif (p_hevc_pps->flags &\n\t\t    V4L2_HEVC_PPS_FLAG_PPS_DISABLE_DEBLOCKING_FILTER) {\n\t\t\tp_hevc_pps->pps_beta_offset_div2 = 0;\n\t\t\tp_hevc_pps->pps_tc_offset_div2 = 0;\n\t\t}\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_HEVC_DECODE_PARAMS:\n\t\tp_hevc_decode_params = p;\n\n\t\tif (p_hevc_decode_params->num_active_dpb_entries >\n\t\t    V4L2_HEVC_DPB_ENTRIES_NUM_MAX)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_HEVC_SLICE_PARAMS:\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_HDR10_CLL_INFO:\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_HDR10_MASTERING_DISPLAY:\n\t\tp_hdr10_mastering = p;\n\n\t\tfor (i = 0; i < 3; ++i) {\n\t\t\tif (p_hdr10_mastering->display_primaries_x[i] <\n\t\t\t\tV4L2_HDR10_MASTERING_PRIMARIES_X_LOW ||\n\t\t\t    p_hdr10_mastering->display_primaries_x[i] >\n\t\t\t\tV4L2_HDR10_MASTERING_PRIMARIES_X_HIGH ||\n\t\t\t    p_hdr10_mastering->display_primaries_y[i] <\n\t\t\t\tV4L2_HDR10_MASTERING_PRIMARIES_Y_LOW ||\n\t\t\t    p_hdr10_mastering->display_primaries_y[i] >\n\t\t\t\tV4L2_HDR10_MASTERING_PRIMARIES_Y_HIGH)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (p_hdr10_mastering->white_point_x <\n\t\t\tV4L2_HDR10_MASTERING_WHITE_POINT_X_LOW ||\n\t\t    p_hdr10_mastering->white_point_x >\n\t\t\tV4L2_HDR10_MASTERING_WHITE_POINT_X_HIGH ||\n\t\t    p_hdr10_mastering->white_point_y <\n\t\t\tV4L2_HDR10_MASTERING_WHITE_POINT_Y_LOW ||\n\t\t    p_hdr10_mastering->white_point_y >\n\t\t\tV4L2_HDR10_MASTERING_WHITE_POINT_Y_HIGH)\n\t\t\treturn -EINVAL;\n\n\t\tif (p_hdr10_mastering->max_display_mastering_luminance <\n\t\t\tV4L2_HDR10_MASTERING_MAX_LUMA_LOW ||\n\t\t    p_hdr10_mastering->max_display_mastering_luminance >\n\t\t\tV4L2_HDR10_MASTERING_MAX_LUMA_HIGH ||\n\t\t    p_hdr10_mastering->min_display_mastering_luminance <\n\t\t\tV4L2_HDR10_MASTERING_MIN_LUMA_LOW ||\n\t\t    p_hdr10_mastering->min_display_mastering_luminance >\n\t\t\tV4L2_HDR10_MASTERING_MIN_LUMA_HIGH)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (p_hdr10_mastering->max_display_mastering_luminance ==\n\t\t\tV4L2_HDR10_MASTERING_MAX_LUMA_LOW &&\n\t\t    p_hdr10_mastering->min_display_mastering_luminance ==\n\t\t\tV4L2_HDR10_MASTERING_MIN_LUMA_HIGH)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_HEVC_SCALING_MATRIX:\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_VP9_COMPRESSED_HDR:\n\t\treturn validate_vp9_compressed_hdr(p);\n\n\tcase V4L2_CTRL_TYPE_VP9_FRAME:\n\t\treturn validate_vp9_frame(p);\n\tcase V4L2_CTRL_TYPE_AV1_FRAME:\n\t\treturn validate_av1_frame(p);\n\tcase V4L2_CTRL_TYPE_AV1_SEQUENCE:\n\t\treturn validate_av1_sequence(p);\n\tcase V4L2_CTRL_TYPE_AV1_TILE_GROUP_ENTRY:\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_AV1_FILM_GRAIN:\n\t\treturn validate_av1_film_grain(p);\n\n\tcase V4L2_CTRL_TYPE_AREA:\n\t\tarea = p;\n\t\tif (!area->width || !area->height)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int std_validate_elem(const struct v4l2_ctrl *ctrl, u32 idx,\n\t\t\t     union v4l2_ctrl_ptr ptr)\n{\n\tsize_t len;\n\tu64 offset;\n\ts64 val;\n\n\tswitch ((u32)ctrl->type) {\n\tcase V4L2_CTRL_TYPE_INTEGER:\n\t\treturn ROUND_TO_RANGE(ptr.p_s32[idx], u32, ctrl);\n\tcase V4L2_CTRL_TYPE_INTEGER64:\n\t\t \n\t\tval = ptr.p_s64[idx];\n\t\tif (ctrl->maximum >= 0 && val >= ctrl->maximum - (s64)(ctrl->step / 2))\n\t\t\tval = ctrl->maximum;\n\t\telse\n\t\t\tval += (s64)(ctrl->step / 2);\n\t\tval = clamp_t(s64, val, ctrl->minimum, ctrl->maximum);\n\t\toffset = val - ctrl->minimum;\n\t\tdo_div(offset, ctrl->step);\n\t\tptr.p_s64[idx] = ctrl->minimum + offset * ctrl->step;\n\t\treturn 0;\n\tcase V4L2_CTRL_TYPE_U8:\n\t\treturn ROUND_TO_RANGE(ptr.p_u8[idx], u8, ctrl);\n\tcase V4L2_CTRL_TYPE_U16:\n\t\treturn ROUND_TO_RANGE(ptr.p_u16[idx], u16, ctrl);\n\tcase V4L2_CTRL_TYPE_U32:\n\t\treturn ROUND_TO_RANGE(ptr.p_u32[idx], u32, ctrl);\n\n\tcase V4L2_CTRL_TYPE_BOOLEAN:\n\t\tptr.p_s32[idx] = !!ptr.p_s32[idx];\n\t\treturn 0;\n\n\tcase V4L2_CTRL_TYPE_MENU:\n\tcase V4L2_CTRL_TYPE_INTEGER_MENU:\n\t\tif (ptr.p_s32[idx] < ctrl->minimum || ptr.p_s32[idx] > ctrl->maximum)\n\t\t\treturn -ERANGE;\n\t\tif (ptr.p_s32[idx] < BITS_PER_LONG_LONG &&\n\t\t    (ctrl->menu_skip_mask & BIT_ULL(ptr.p_s32[idx])))\n\t\t\treturn -EINVAL;\n\t\tif (ctrl->type == V4L2_CTRL_TYPE_MENU &&\n\t\t    ctrl->qmenu[ptr.p_s32[idx]][0] == '\\0')\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\n\tcase V4L2_CTRL_TYPE_BITMASK:\n\t\tptr.p_s32[idx] &= ctrl->maximum;\n\t\treturn 0;\n\n\tcase V4L2_CTRL_TYPE_BUTTON:\n\tcase V4L2_CTRL_TYPE_CTRL_CLASS:\n\t\tptr.p_s32[idx] = 0;\n\t\treturn 0;\n\n\tcase V4L2_CTRL_TYPE_STRING:\n\t\tidx *= ctrl->elem_size;\n\t\tlen = strlen(ptr.p_char + idx);\n\t\tif (len < ctrl->minimum)\n\t\t\treturn -ERANGE;\n\t\tif ((len - (u32)ctrl->minimum) % (u32)ctrl->step)\n\t\t\treturn -ERANGE;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn std_validate_compound(ctrl, idx, ptr);\n\t}\n}\n\nint v4l2_ctrl_type_op_validate(const struct v4l2_ctrl *ctrl,\n\t\t\t       union v4l2_ctrl_ptr ptr)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\tswitch ((u32)ctrl->type) {\n\tcase V4L2_CTRL_TYPE_U8:\n\t\tif (ctrl->maximum == 0xff && ctrl->minimum == 0 && ctrl->step == 1)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_U16:\n\t\tif (ctrl->maximum == 0xffff && ctrl->minimum == 0 && ctrl->step == 1)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_U32:\n\t\tif (ctrl->maximum == 0xffffffff && ctrl->minimum == 0 && ctrl->step == 1)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_BUTTON:\n\tcase V4L2_CTRL_TYPE_CTRL_CLASS:\n\t\tmemset(ptr.p_s32, 0, ctrl->new_elems * sizeof(s32));\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; !ret && i < ctrl->new_elems; i++)\n\t\tret = std_validate_elem(ctrl, i, ptr);\n\treturn ret;\n}\nEXPORT_SYMBOL(v4l2_ctrl_type_op_validate);\n\nstatic const struct v4l2_ctrl_type_ops std_type_ops = {\n\t.equal = v4l2_ctrl_type_op_equal,\n\t.init = v4l2_ctrl_type_op_init,\n\t.log = v4l2_ctrl_type_op_log,\n\t.validate = v4l2_ctrl_type_op_validate,\n};\n\nvoid v4l2_ctrl_notify(struct v4l2_ctrl *ctrl, v4l2_ctrl_notify_fnc notify, void *priv)\n{\n\tif (!ctrl)\n\t\treturn;\n\tif (!notify) {\n\t\tctrl->call_notify = 0;\n\t\treturn;\n\t}\n\tif (WARN_ON(ctrl->handler->notify && ctrl->handler->notify != notify))\n\t\treturn;\n\tctrl->handler->notify = notify;\n\tctrl->handler->notify_priv = priv;\n\tctrl->call_notify = 1;\n}\nEXPORT_SYMBOL(v4l2_ctrl_notify);\n\n \nstatic void ptr_to_ptr(struct v4l2_ctrl *ctrl,\n\t\t       union v4l2_ctrl_ptr from, union v4l2_ctrl_ptr to,\n\t\t       unsigned int elems)\n{\n\tif (ctrl == NULL)\n\t\treturn;\n\tmemcpy(to.p, from.p_const, elems * ctrl->elem_size);\n}\n\n \nvoid new_to_cur(struct v4l2_fh *fh, struct v4l2_ctrl *ctrl, u32 ch_flags)\n{\n\tbool changed;\n\n\tif (ctrl == NULL)\n\t\treturn;\n\n\t \n\tchanged = ctrl->has_changed;\n\tif (changed) {\n\t\tif (ctrl->is_dyn_array)\n\t\t\tctrl->elems = ctrl->new_elems;\n\t\tptr_to_ptr(ctrl, ctrl->p_new, ctrl->p_cur, ctrl->elems);\n\t}\n\n\tif (ch_flags & V4L2_EVENT_CTRL_CH_FLAGS) {\n\t\t \n\t\tctrl->flags &=\n\t\t\t~(V4L2_CTRL_FLAG_INACTIVE | V4L2_CTRL_FLAG_VOLATILE);\n\t\tif (!is_cur_manual(ctrl->cluster[0])) {\n\t\t\tctrl->flags |= V4L2_CTRL_FLAG_INACTIVE;\n\t\t\tif (ctrl->cluster[0]->has_volatiles)\n\t\t\t\tctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\t\t}\n\t\tfh = NULL;\n\t}\n\tif (changed || ch_flags) {\n\t\t \n\t\tif (!ctrl->is_new)\n\t\t\tfh = NULL;\n\t\tsend_event(fh, ctrl,\n\t\t\t(changed ? V4L2_EVENT_CTRL_CH_VALUE : 0) | ch_flags);\n\t\tif (ctrl->call_notify && changed && ctrl->handler->notify)\n\t\t\tctrl->handler->notify(ctrl, ctrl->handler->notify_priv);\n\t}\n}\n\n \nvoid cur_to_new(struct v4l2_ctrl *ctrl)\n{\n\tif (ctrl == NULL)\n\t\treturn;\n\tif (ctrl->is_dyn_array)\n\t\tctrl->new_elems = ctrl->elems;\n\tptr_to_ptr(ctrl, ctrl->p_cur, ctrl->p_new, ctrl->new_elems);\n}\n\nstatic bool req_alloc_array(struct v4l2_ctrl_ref *ref, u32 elems)\n{\n\tvoid *tmp;\n\n\tif (elems == ref->p_req_array_alloc_elems)\n\t\treturn true;\n\tif (ref->ctrl->is_dyn_array &&\n\t    elems < ref->p_req_array_alloc_elems)\n\t\treturn true;\n\n\ttmp = kvmalloc(elems * ref->ctrl->elem_size, GFP_KERNEL);\n\n\tif (!tmp) {\n\t\tref->p_req_array_enomem = true;\n\t\treturn false;\n\t}\n\tref->p_req_array_enomem = false;\n\tkvfree(ref->p_req.p);\n\tref->p_req.p = tmp;\n\tref->p_req_array_alloc_elems = elems;\n\treturn true;\n}\n\n \nvoid new_to_req(struct v4l2_ctrl_ref *ref)\n{\n\tstruct v4l2_ctrl *ctrl;\n\n\tif (!ref)\n\t\treturn;\n\n\tctrl = ref->ctrl;\n\tif (ctrl->is_array && !req_alloc_array(ref, ctrl->new_elems))\n\t\treturn;\n\n\tref->p_req_elems = ctrl->new_elems;\n\tptr_to_ptr(ctrl, ctrl->p_new, ref->p_req, ref->p_req_elems);\n\tref->p_req_valid = true;\n}\n\n \nvoid cur_to_req(struct v4l2_ctrl_ref *ref)\n{\n\tstruct v4l2_ctrl *ctrl;\n\n\tif (!ref)\n\t\treturn;\n\n\tctrl = ref->ctrl;\n\tif (ctrl->is_array && !req_alloc_array(ref, ctrl->elems))\n\t\treturn;\n\n\tref->p_req_elems = ctrl->elems;\n\tptr_to_ptr(ctrl, ctrl->p_cur, ref->p_req, ctrl->elems);\n\tref->p_req_valid = true;\n}\n\n \nint req_to_new(struct v4l2_ctrl_ref *ref)\n{\n\tstruct v4l2_ctrl *ctrl;\n\n\tif (!ref)\n\t\treturn 0;\n\n\tctrl = ref->ctrl;\n\n\t \n\tif (!ref->p_req_valid) {\n\t\tif (ctrl->is_dyn_array)\n\t\t\tctrl->new_elems = ctrl->elems;\n\t\tptr_to_ptr(ctrl, ctrl->p_cur, ctrl->p_new, ctrl->new_elems);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!ctrl->is_array) {\n\t\tptr_to_ptr(ctrl, ref->p_req, ctrl->p_new, ctrl->new_elems);\n\t\treturn 0;\n\t}\n\n\t \n\tif (WARN_ON(!ref->p_req_array_alloc_elems))\n\t\treturn -ENOMEM;\n\n\tif (!ctrl->is_dyn_array &&\n\t    ref->p_req_elems != ctrl->p_array_alloc_elems)\n\t\treturn -ENOMEM;\n\n\t \n\tif (ref->p_req_elems > ctrl->p_array_alloc_elems) {\n\t\tunsigned int sz = ref->p_req_elems * ctrl->elem_size;\n\t\tvoid *old = ctrl->p_array;\n\t\tvoid *tmp = kvzalloc(2 * sz, GFP_KERNEL);\n\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(tmp, ctrl->p_new.p, ctrl->elems * ctrl->elem_size);\n\t\tmemcpy(tmp + sz, ctrl->p_cur.p, ctrl->elems * ctrl->elem_size);\n\t\tctrl->p_new.p = tmp;\n\t\tctrl->p_cur.p = tmp + sz;\n\t\tctrl->p_array = tmp;\n\t\tctrl->p_array_alloc_elems = ref->p_req_elems;\n\t\tkvfree(old);\n\t}\n\n\tctrl->new_elems = ref->p_req_elems;\n\tptr_to_ptr(ctrl, ref->p_req, ctrl->p_new, ctrl->new_elems);\n\treturn 0;\n}\n\n \nint check_range(enum v4l2_ctrl_type type,\n\t\ts64 min, s64 max, u64 step, s64 def)\n{\n\tswitch (type) {\n\tcase V4L2_CTRL_TYPE_BOOLEAN:\n\t\tif (step != 1 || max > 1 || min < 0)\n\t\t\treturn -ERANGE;\n\t\tfallthrough;\n\tcase V4L2_CTRL_TYPE_U8:\n\tcase V4L2_CTRL_TYPE_U16:\n\tcase V4L2_CTRL_TYPE_U32:\n\tcase V4L2_CTRL_TYPE_INTEGER:\n\tcase V4L2_CTRL_TYPE_INTEGER64:\n\t\tif (step == 0 || min > max || def < min || def > max)\n\t\t\treturn -ERANGE;\n\t\treturn 0;\n\tcase V4L2_CTRL_TYPE_BITMASK:\n\t\tif (step || min || !max || (def & ~max))\n\t\t\treturn -ERANGE;\n\t\treturn 0;\n\tcase V4L2_CTRL_TYPE_MENU:\n\tcase V4L2_CTRL_TYPE_INTEGER_MENU:\n\t\tif (min > max || def < min || def > max)\n\t\t\treturn -ERANGE;\n\t\t \n\t\tif (step && ((1 << def) & step))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\tcase V4L2_CTRL_TYPE_STRING:\n\t\tif (min > max || min < 0 || step < 1 || def)\n\t\t\treturn -ERANGE;\n\t\treturn 0;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic inline int handler_set_err(struct v4l2_ctrl_handler *hdl, int err)\n{\n\tif (hdl->error == 0)\n\t\thdl->error = err;\n\treturn err;\n}\n\n \nint v4l2_ctrl_handler_init_class(struct v4l2_ctrl_handler *hdl,\n\t\t\t\t unsigned nr_of_controls_hint,\n\t\t\t\t struct lock_class_key *key, const char *name)\n{\n\tmutex_init(&hdl->_lock);\n\thdl->lock = &hdl->_lock;\n\tlockdep_set_class_and_name(hdl->lock, key, name);\n\tINIT_LIST_HEAD(&hdl->ctrls);\n\tINIT_LIST_HEAD(&hdl->ctrl_refs);\n\thdl->nr_of_buckets = 1 + nr_of_controls_hint / 8;\n\thdl->buckets = kvcalloc(hdl->nr_of_buckets, sizeof(hdl->buckets[0]),\n\t\t\t\tGFP_KERNEL);\n\thdl->error = hdl->buckets ? 0 : -ENOMEM;\n\tv4l2_ctrl_handler_init_request(hdl);\n\treturn hdl->error;\n}\nEXPORT_SYMBOL(v4l2_ctrl_handler_init_class);\n\n \nvoid v4l2_ctrl_handler_free(struct v4l2_ctrl_handler *hdl)\n{\n\tstruct v4l2_ctrl_ref *ref, *next_ref;\n\tstruct v4l2_ctrl *ctrl, *next_ctrl;\n\tstruct v4l2_subscribed_event *sev, *next_sev;\n\n\tif (hdl == NULL || hdl->buckets == NULL)\n\t\treturn;\n\n\tv4l2_ctrl_handler_free_request(hdl);\n\n\tmutex_lock(hdl->lock);\n\t \n\tlist_for_each_entry_safe(ref, next_ref, &hdl->ctrl_refs, node) {\n\t\tlist_del(&ref->node);\n\t\tif (ref->p_req_array_alloc_elems)\n\t\t\tkvfree(ref->p_req.p);\n\t\tkfree(ref);\n\t}\n\t \n\tlist_for_each_entry_safe(ctrl, next_ctrl, &hdl->ctrls, node) {\n\t\tlist_del(&ctrl->node);\n\t\tlist_for_each_entry_safe(sev, next_sev, &ctrl->ev_subs, node)\n\t\t\tlist_del(&sev->node);\n\t\tkvfree(ctrl->p_array);\n\t\tkvfree(ctrl);\n\t}\n\tkvfree(hdl->buckets);\n\thdl->buckets = NULL;\n\thdl->cached = NULL;\n\thdl->error = 0;\n\tmutex_unlock(hdl->lock);\n\tmutex_destroy(&hdl->_lock);\n}\nEXPORT_SYMBOL(v4l2_ctrl_handler_free);\n\n \nstatic struct v4l2_ctrl_ref *find_private_ref(\n\t\tstruct v4l2_ctrl_handler *hdl, u32 id)\n{\n\tstruct v4l2_ctrl_ref *ref;\n\n\tid -= V4L2_CID_PRIVATE_BASE;\n\tlist_for_each_entry(ref, &hdl->ctrl_refs, node) {\n\t\t \n\t\tif (V4L2_CTRL_ID2WHICH(ref->ctrl->id) == V4L2_CTRL_CLASS_USER &&\n\t\t    V4L2_CTRL_DRIVER_PRIV(ref->ctrl->id)) {\n\t\t\tif (!ref->ctrl->is_int)\n\t\t\t\tcontinue;\n\t\t\tif (id == 0)\n\t\t\t\treturn ref;\n\t\t\tid--;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstruct v4l2_ctrl_ref *find_ref(struct v4l2_ctrl_handler *hdl, u32 id)\n{\n\tstruct v4l2_ctrl_ref *ref;\n\tint bucket;\n\n\tid &= V4L2_CTRL_ID_MASK;\n\n\t \n\tif (id >= V4L2_CID_PRIVATE_BASE)\n\t\treturn find_private_ref(hdl, id);\n\tbucket = id % hdl->nr_of_buckets;\n\n\t \n\tif (hdl->cached && hdl->cached->ctrl->id == id)\n\t\treturn hdl->cached;\n\n\t \n\tref = hdl->buckets ? hdl->buckets[bucket] : NULL;\n\twhile (ref && ref->ctrl->id != id)\n\t\tref = ref->next;\n\n\tif (ref)\n\t\thdl->cached = ref;  \n\treturn ref;\n}\n\n \nstruct v4l2_ctrl_ref *find_ref_lock(struct v4l2_ctrl_handler *hdl, u32 id)\n{\n\tstruct v4l2_ctrl_ref *ref = NULL;\n\n\tif (hdl) {\n\t\tmutex_lock(hdl->lock);\n\t\tref = find_ref(hdl, id);\n\t\tmutex_unlock(hdl->lock);\n\t}\n\treturn ref;\n}\n\n \nstruct v4l2_ctrl *v4l2_ctrl_find(struct v4l2_ctrl_handler *hdl, u32 id)\n{\n\tstruct v4l2_ctrl_ref *ref = find_ref_lock(hdl, id);\n\n\treturn ref ? ref->ctrl : NULL;\n}\nEXPORT_SYMBOL(v4l2_ctrl_find);\n\n \nint handler_new_ref(struct v4l2_ctrl_handler *hdl,\n\t\t    struct v4l2_ctrl *ctrl,\n\t\t    struct v4l2_ctrl_ref **ctrl_ref,\n\t\t    bool from_other_dev, bool allocate_req)\n{\n\tstruct v4l2_ctrl_ref *ref;\n\tstruct v4l2_ctrl_ref *new_ref;\n\tu32 id = ctrl->id;\n\tu32 class_ctrl = V4L2_CTRL_ID2WHICH(id) | 1;\n\tint bucket = id % hdl->nr_of_buckets;\t \n\tunsigned int size_extra_req = 0;\n\n\tif (ctrl_ref)\n\t\t*ctrl_ref = NULL;\n\n\t \n\tif (ctrl->type < V4L2_CTRL_COMPOUND_TYPES &&\n\t    id != class_ctrl && find_ref_lock(hdl, class_ctrl) == NULL)\n\t\tif (!v4l2_ctrl_new_std(hdl, NULL, class_ctrl, 0, 0, 0, 0))\n\t\t\treturn hdl->error;\n\n\tif (hdl->error)\n\t\treturn hdl->error;\n\n\tif (allocate_req && !ctrl->is_array)\n\t\tsize_extra_req = ctrl->elems * ctrl->elem_size;\n\tnew_ref = kzalloc(sizeof(*new_ref) + size_extra_req, GFP_KERNEL);\n\tif (!new_ref)\n\t\treturn handler_set_err(hdl, -ENOMEM);\n\tnew_ref->ctrl = ctrl;\n\tnew_ref->from_other_dev = from_other_dev;\n\tif (size_extra_req)\n\t\tnew_ref->p_req.p = &new_ref[1];\n\n\tINIT_LIST_HEAD(&new_ref->node);\n\n\tmutex_lock(hdl->lock);\n\n\t \n\tif (list_empty(&hdl->ctrl_refs) || id > node2id(hdl->ctrl_refs.prev)) {\n\t\tlist_add_tail(&new_ref->node, &hdl->ctrl_refs);\n\t\tgoto insert_in_hash;\n\t}\n\n\t \n\tlist_for_each_entry(ref, &hdl->ctrl_refs, node) {\n\t\tif (ref->ctrl->id < id)\n\t\t\tcontinue;\n\t\t \n\t\tif (ref->ctrl->id == id) {\n\t\t\tkfree(new_ref);\n\t\t\tgoto unlock;\n\t\t}\n\t\tlist_add(&new_ref->node, ref->node.prev);\n\t\tbreak;\n\t}\n\ninsert_in_hash:\n\t \n\tnew_ref->next = hdl->buckets[bucket];\n\thdl->buckets[bucket] = new_ref;\n\tif (ctrl_ref)\n\t\t*ctrl_ref = new_ref;\n\tif (ctrl->handler == hdl) {\n\t\t \n\t\tctrl->cluster = &new_ref->ctrl;\n\t\tctrl->ncontrols = 1;\n\t}\n\nunlock:\n\tmutex_unlock(hdl->lock);\n\treturn 0;\n}\n\n \nstatic struct v4l2_ctrl *v4l2_ctrl_new(struct v4l2_ctrl_handler *hdl,\n\t\t\tconst struct v4l2_ctrl_ops *ops,\n\t\t\tconst struct v4l2_ctrl_type_ops *type_ops,\n\t\t\tu32 id, const char *name, enum v4l2_ctrl_type type,\n\t\t\ts64 min, s64 max, u64 step, s64 def,\n\t\t\tconst u32 dims[V4L2_CTRL_MAX_DIMS], u32 elem_size,\n\t\t\tu32 flags, const char * const *qmenu,\n\t\t\tconst s64 *qmenu_int, const union v4l2_ctrl_ptr p_def,\n\t\t\tvoid *priv)\n{\n\tstruct v4l2_ctrl *ctrl;\n\tunsigned sz_extra;\n\tunsigned nr_of_dims = 0;\n\tunsigned elems = 1;\n\tbool is_array;\n\tunsigned tot_ctrl_size;\n\tvoid *data;\n\tint err;\n\n\tif (hdl->error)\n\t\treturn NULL;\n\n\twhile (dims && dims[nr_of_dims]) {\n\t\telems *= dims[nr_of_dims];\n\t\tnr_of_dims++;\n\t\tif (nr_of_dims == V4L2_CTRL_MAX_DIMS)\n\t\t\tbreak;\n\t}\n\tis_array = nr_of_dims > 0;\n\n\t \n\tswitch ((u32)type) {\n\tcase V4L2_CTRL_TYPE_INTEGER64:\n\t\telem_size = sizeof(s64);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_STRING:\n\t\telem_size = max + 1;\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_U8:\n\t\telem_size = sizeof(u8);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_U16:\n\t\telem_size = sizeof(u16);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_U32:\n\t\telem_size = sizeof(u32);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_MPEG2_SEQUENCE:\n\t\telem_size = sizeof(struct v4l2_ctrl_mpeg2_sequence);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_MPEG2_PICTURE:\n\t\telem_size = sizeof(struct v4l2_ctrl_mpeg2_picture);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_MPEG2_QUANTISATION:\n\t\telem_size = sizeof(struct v4l2_ctrl_mpeg2_quantisation);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_FWHT_PARAMS:\n\t\telem_size = sizeof(struct v4l2_ctrl_fwht_params);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_H264_SPS:\n\t\telem_size = sizeof(struct v4l2_ctrl_h264_sps);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_H264_PPS:\n\t\telem_size = sizeof(struct v4l2_ctrl_h264_pps);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_H264_SCALING_MATRIX:\n\t\telem_size = sizeof(struct v4l2_ctrl_h264_scaling_matrix);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_H264_SLICE_PARAMS:\n\t\telem_size = sizeof(struct v4l2_ctrl_h264_slice_params);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_H264_DECODE_PARAMS:\n\t\telem_size = sizeof(struct v4l2_ctrl_h264_decode_params);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_H264_PRED_WEIGHTS:\n\t\telem_size = sizeof(struct v4l2_ctrl_h264_pred_weights);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_VP8_FRAME:\n\t\telem_size = sizeof(struct v4l2_ctrl_vp8_frame);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_HEVC_SPS:\n\t\telem_size = sizeof(struct v4l2_ctrl_hevc_sps);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_HEVC_PPS:\n\t\telem_size = sizeof(struct v4l2_ctrl_hevc_pps);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_HEVC_SLICE_PARAMS:\n\t\telem_size = sizeof(struct v4l2_ctrl_hevc_slice_params);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_HEVC_SCALING_MATRIX:\n\t\telem_size = sizeof(struct v4l2_ctrl_hevc_scaling_matrix);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_HEVC_DECODE_PARAMS:\n\t\telem_size = sizeof(struct v4l2_ctrl_hevc_decode_params);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_HDR10_CLL_INFO:\n\t\telem_size = sizeof(struct v4l2_ctrl_hdr10_cll_info);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_HDR10_MASTERING_DISPLAY:\n\t\telem_size = sizeof(struct v4l2_ctrl_hdr10_mastering_display);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_VP9_COMPRESSED_HDR:\n\t\telem_size = sizeof(struct v4l2_ctrl_vp9_compressed_hdr);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_VP9_FRAME:\n\t\telem_size = sizeof(struct v4l2_ctrl_vp9_frame);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_AV1_SEQUENCE:\n\t\telem_size = sizeof(struct v4l2_ctrl_av1_sequence);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_AV1_TILE_GROUP_ENTRY:\n\t\telem_size = sizeof(struct v4l2_ctrl_av1_tile_group_entry);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_AV1_FRAME:\n\t\telem_size = sizeof(struct v4l2_ctrl_av1_frame);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_AV1_FILM_GRAIN:\n\t\telem_size = sizeof(struct v4l2_ctrl_av1_film_grain);\n\t\tbreak;\n\tcase V4L2_CTRL_TYPE_AREA:\n\t\telem_size = sizeof(struct v4l2_area);\n\t\tbreak;\n\tdefault:\n\t\tif (type < V4L2_CTRL_COMPOUND_TYPES)\n\t\t\telem_size = sizeof(s32);\n\t\tbreak;\n\t}\n\n\t \n\tif (id == 0 || name == NULL || !elem_size ||\n\t    id >= V4L2_CID_PRIVATE_BASE ||\n\t    (type == V4L2_CTRL_TYPE_MENU && qmenu == NULL) ||\n\t    (type == V4L2_CTRL_TYPE_INTEGER_MENU && qmenu_int == NULL)) {\n\t\thandler_set_err(hdl, -ERANGE);\n\t\treturn NULL;\n\t}\n\terr = check_range(type, min, max, step, def);\n\tif (err) {\n\t\thandler_set_err(hdl, err);\n\t\treturn NULL;\n\t}\n\tif (is_array &&\n\t    (type == V4L2_CTRL_TYPE_BUTTON ||\n\t     type == V4L2_CTRL_TYPE_CTRL_CLASS)) {\n\t\thandler_set_err(hdl, -EINVAL);\n\t\treturn NULL;\n\t}\n\tif (flags & V4L2_CTRL_FLAG_DYNAMIC_ARRAY) {\n\t\t \n\t\tif (nr_of_dims != 1) {\n\t\t\thandler_set_err(hdl, -EINVAL);\n\t\t\treturn NULL;\n\t\t}\n\t\t \n\t\telems = 1;\n\t}\n\n\ttot_ctrl_size = elem_size * elems;\n\tsz_extra = 0;\n\tif (type == V4L2_CTRL_TYPE_BUTTON)\n\t\tflags |= V4L2_CTRL_FLAG_WRITE_ONLY |\n\t\t\tV4L2_CTRL_FLAG_EXECUTE_ON_WRITE;\n\telse if (type == V4L2_CTRL_TYPE_CTRL_CLASS)\n\t\tflags |= V4L2_CTRL_FLAG_READ_ONLY;\n\telse if (!is_array &&\n\t\t (type == V4L2_CTRL_TYPE_INTEGER64 ||\n\t\t  type == V4L2_CTRL_TYPE_STRING ||\n\t\t  type >= V4L2_CTRL_COMPOUND_TYPES))\n\t\tsz_extra += 2 * tot_ctrl_size;\n\n\tif (type >= V4L2_CTRL_COMPOUND_TYPES && p_def.p_const)\n\t\tsz_extra += elem_size;\n\n\tctrl = kvzalloc(sizeof(*ctrl) + sz_extra, GFP_KERNEL);\n\tif (ctrl == NULL) {\n\t\thandler_set_err(hdl, -ENOMEM);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&ctrl->node);\n\tINIT_LIST_HEAD(&ctrl->ev_subs);\n\tctrl->handler = hdl;\n\tctrl->ops = ops;\n\tctrl->type_ops = type_ops ? type_ops : &std_type_ops;\n\tctrl->id = id;\n\tctrl->name = name;\n\tctrl->type = type;\n\tctrl->flags = flags;\n\tctrl->minimum = min;\n\tctrl->maximum = max;\n\tctrl->step = step;\n\tctrl->default_value = def;\n\tctrl->is_string = !is_array && type == V4L2_CTRL_TYPE_STRING;\n\tctrl->is_ptr = is_array || type >= V4L2_CTRL_COMPOUND_TYPES || ctrl->is_string;\n\tctrl->is_int = !ctrl->is_ptr && type != V4L2_CTRL_TYPE_INTEGER64;\n\tctrl->is_array = is_array;\n\tctrl->is_dyn_array = !!(flags & V4L2_CTRL_FLAG_DYNAMIC_ARRAY);\n\tctrl->elems = elems;\n\tctrl->new_elems = elems;\n\tctrl->nr_of_dims = nr_of_dims;\n\tif (nr_of_dims)\n\t\tmemcpy(ctrl->dims, dims, nr_of_dims * sizeof(dims[0]));\n\tctrl->elem_size = elem_size;\n\tif (type == V4L2_CTRL_TYPE_MENU)\n\t\tctrl->qmenu = qmenu;\n\telse if (type == V4L2_CTRL_TYPE_INTEGER_MENU)\n\t\tctrl->qmenu_int = qmenu_int;\n\tctrl->priv = priv;\n\tctrl->cur.val = ctrl->val = def;\n\tdata = &ctrl[1];\n\n\tif (ctrl->is_array) {\n\t\tctrl->p_array_alloc_elems = elems;\n\t\tctrl->p_array = kvzalloc(2 * elems * elem_size, GFP_KERNEL);\n\t\tif (!ctrl->p_array) {\n\t\t\tkvfree(ctrl);\n\t\t\treturn NULL;\n\t\t}\n\t\tdata = ctrl->p_array;\n\t}\n\n\tif (!ctrl->is_int) {\n\t\tctrl->p_new.p = data;\n\t\tctrl->p_cur.p = data + tot_ctrl_size;\n\t} else {\n\t\tctrl->p_new.p = &ctrl->val;\n\t\tctrl->p_cur.p = &ctrl->cur.val;\n\t}\n\n\tif (type >= V4L2_CTRL_COMPOUND_TYPES && p_def.p_const) {\n\t\tif (ctrl->is_array)\n\t\t\tctrl->p_def.p = &ctrl[1];\n\t\telse\n\t\t\tctrl->p_def.p = ctrl->p_cur.p + tot_ctrl_size;\n\t\tmemcpy(ctrl->p_def.p, p_def.p_const, elem_size);\n\t}\n\n\tctrl->type_ops->init(ctrl, 0, ctrl->p_cur);\n\tcur_to_new(ctrl);\n\n\tif (handler_new_ref(hdl, ctrl, NULL, false, false)) {\n\t\tkvfree(ctrl->p_array);\n\t\tkvfree(ctrl);\n\t\treturn NULL;\n\t}\n\tmutex_lock(hdl->lock);\n\tlist_add_tail(&ctrl->node, &hdl->ctrls);\n\tmutex_unlock(hdl->lock);\n\treturn ctrl;\n}\n\nstruct v4l2_ctrl *v4l2_ctrl_new_custom(struct v4l2_ctrl_handler *hdl,\n\t\t\tconst struct v4l2_ctrl_config *cfg, void *priv)\n{\n\tbool is_menu;\n\tstruct v4l2_ctrl *ctrl;\n\tconst char *name = cfg->name;\n\tconst char * const *qmenu = cfg->qmenu;\n\tconst s64 *qmenu_int = cfg->qmenu_int;\n\tenum v4l2_ctrl_type type = cfg->type;\n\tu32 flags = cfg->flags;\n\ts64 min = cfg->min;\n\ts64 max = cfg->max;\n\tu64 step = cfg->step;\n\ts64 def = cfg->def;\n\n\tif (name == NULL)\n\t\tv4l2_ctrl_fill(cfg->id, &name, &type, &min, &max, &step,\n\t\t\t\t\t\t\t\t&def, &flags);\n\n\tis_menu = (type == V4L2_CTRL_TYPE_MENU ||\n\t\t   type == V4L2_CTRL_TYPE_INTEGER_MENU);\n\tif (is_menu)\n\t\tWARN_ON(step);\n\telse\n\t\tWARN_ON(cfg->menu_skip_mask);\n\tif (type == V4L2_CTRL_TYPE_MENU && !qmenu) {\n\t\tqmenu = v4l2_ctrl_get_menu(cfg->id);\n\t} else if (type == V4L2_CTRL_TYPE_INTEGER_MENU && !qmenu_int) {\n\t\thandler_set_err(hdl, -EINVAL);\n\t\treturn NULL;\n\t}\n\n\tctrl = v4l2_ctrl_new(hdl, cfg->ops, cfg->type_ops, cfg->id, name,\n\t\t\ttype, min, max,\n\t\t\tis_menu ? cfg->menu_skip_mask : step, def,\n\t\t\tcfg->dims, cfg->elem_size,\n\t\t\tflags, qmenu, qmenu_int, cfg->p_def, priv);\n\tif (ctrl)\n\t\tctrl->is_private = cfg->is_private;\n\treturn ctrl;\n}\nEXPORT_SYMBOL(v4l2_ctrl_new_custom);\n\n \nstruct v4l2_ctrl *v4l2_ctrl_new_std(struct v4l2_ctrl_handler *hdl,\n\t\t\tconst struct v4l2_ctrl_ops *ops,\n\t\t\tu32 id, s64 min, s64 max, u64 step, s64 def)\n{\n\tconst char *name;\n\tenum v4l2_ctrl_type type;\n\tu32 flags;\n\n\tv4l2_ctrl_fill(id, &name, &type, &min, &max, &step, &def, &flags);\n\tif (type == V4L2_CTRL_TYPE_MENU ||\n\t    type == V4L2_CTRL_TYPE_INTEGER_MENU ||\n\t    type >= V4L2_CTRL_COMPOUND_TYPES) {\n\t\thandler_set_err(hdl, -EINVAL);\n\t\treturn NULL;\n\t}\n\treturn v4l2_ctrl_new(hdl, ops, NULL, id, name, type,\n\t\t\t     min, max, step, def, NULL, 0,\n\t\t\t     flags, NULL, NULL, ptr_null, NULL);\n}\nEXPORT_SYMBOL(v4l2_ctrl_new_std);\n\n \nstruct v4l2_ctrl *v4l2_ctrl_new_std_menu(struct v4l2_ctrl_handler *hdl,\n\t\t\tconst struct v4l2_ctrl_ops *ops,\n\t\t\tu32 id, u8 _max, u64 mask, u8 _def)\n{\n\tconst char * const *qmenu = NULL;\n\tconst s64 *qmenu_int = NULL;\n\tunsigned int qmenu_int_len = 0;\n\tconst char *name;\n\tenum v4l2_ctrl_type type;\n\ts64 min;\n\ts64 max = _max;\n\ts64 def = _def;\n\tu64 step;\n\tu32 flags;\n\n\tv4l2_ctrl_fill(id, &name, &type, &min, &max, &step, &def, &flags);\n\n\tif (type == V4L2_CTRL_TYPE_MENU)\n\t\tqmenu = v4l2_ctrl_get_menu(id);\n\telse if (type == V4L2_CTRL_TYPE_INTEGER_MENU)\n\t\tqmenu_int = v4l2_ctrl_get_int_menu(id, &qmenu_int_len);\n\n\tif ((!qmenu && !qmenu_int) || (qmenu_int && max >= qmenu_int_len)) {\n\t\thandler_set_err(hdl, -EINVAL);\n\t\treturn NULL;\n\t}\n\treturn v4l2_ctrl_new(hdl, ops, NULL, id, name, type,\n\t\t\t     0, max, mask, def, NULL, 0,\n\t\t\t     flags, qmenu, qmenu_int, ptr_null, NULL);\n}\nEXPORT_SYMBOL(v4l2_ctrl_new_std_menu);\n\n \nstruct v4l2_ctrl *v4l2_ctrl_new_std_menu_items(struct v4l2_ctrl_handler *hdl,\n\t\t\tconst struct v4l2_ctrl_ops *ops, u32 id, u8 _max,\n\t\t\tu64 mask, u8 _def, const char * const *qmenu)\n{\n\tenum v4l2_ctrl_type type;\n\tconst char *name;\n\tu32 flags;\n\tu64 step;\n\ts64 min;\n\ts64 max = _max;\n\ts64 def = _def;\n\n\t \n\tif (v4l2_ctrl_get_menu(id)) {\n\t\thandler_set_err(hdl, -EINVAL);\n\t\treturn NULL;\n\t}\n\n\tv4l2_ctrl_fill(id, &name, &type, &min, &max, &step, &def, &flags);\n\tif (type != V4L2_CTRL_TYPE_MENU || qmenu == NULL) {\n\t\thandler_set_err(hdl, -EINVAL);\n\t\treturn NULL;\n\t}\n\treturn v4l2_ctrl_new(hdl, ops, NULL, id, name, type,\n\t\t\t     0, max, mask, def, NULL, 0,\n\t\t\t     flags, qmenu, NULL, ptr_null, NULL);\n\n}\nEXPORT_SYMBOL(v4l2_ctrl_new_std_menu_items);\n\n \nstruct v4l2_ctrl *v4l2_ctrl_new_std_compound(struct v4l2_ctrl_handler *hdl,\n\t\t\t\tconst struct v4l2_ctrl_ops *ops, u32 id,\n\t\t\t\tconst union v4l2_ctrl_ptr p_def)\n{\n\tconst char *name;\n\tenum v4l2_ctrl_type type;\n\tu32 flags;\n\ts64 min, max, step, def;\n\n\tv4l2_ctrl_fill(id, &name, &type, &min, &max, &step, &def, &flags);\n\tif (type < V4L2_CTRL_COMPOUND_TYPES) {\n\t\thandler_set_err(hdl, -EINVAL);\n\t\treturn NULL;\n\t}\n\treturn v4l2_ctrl_new(hdl, ops, NULL, id, name, type,\n\t\t\t     min, max, step, def, NULL, 0,\n\t\t\t     flags, NULL, NULL, p_def, NULL);\n}\nEXPORT_SYMBOL(v4l2_ctrl_new_std_compound);\n\n \nstruct v4l2_ctrl *v4l2_ctrl_new_int_menu(struct v4l2_ctrl_handler *hdl,\n\t\t\tconst struct v4l2_ctrl_ops *ops,\n\t\t\tu32 id, u8 _max, u8 _def, const s64 *qmenu_int)\n{\n\tconst char *name;\n\tenum v4l2_ctrl_type type;\n\ts64 min;\n\tu64 step;\n\ts64 max = _max;\n\ts64 def = _def;\n\tu32 flags;\n\n\tv4l2_ctrl_fill(id, &name, &type, &min, &max, &step, &def, &flags);\n\tif (type != V4L2_CTRL_TYPE_INTEGER_MENU) {\n\t\thandler_set_err(hdl, -EINVAL);\n\t\treturn NULL;\n\t}\n\treturn v4l2_ctrl_new(hdl, ops, NULL, id, name, type,\n\t\t\t     0, max, 0, def, NULL, 0,\n\t\t\t     flags, NULL, qmenu_int, ptr_null, NULL);\n}\nEXPORT_SYMBOL(v4l2_ctrl_new_int_menu);\n\n \nint v4l2_ctrl_add_handler(struct v4l2_ctrl_handler *hdl,\n\t\t\t  struct v4l2_ctrl_handler *add,\n\t\t\t  bool (*filter)(const struct v4l2_ctrl *ctrl),\n\t\t\t  bool from_other_dev)\n{\n\tstruct v4l2_ctrl_ref *ref;\n\tint ret = 0;\n\n\t \n\tif (!hdl || !add || hdl == add)\n\t\treturn 0;\n\tif (hdl->error)\n\t\treturn hdl->error;\n\tmutex_lock(add->lock);\n\tlist_for_each_entry(ref, &add->ctrl_refs, node) {\n\t\tstruct v4l2_ctrl *ctrl = ref->ctrl;\n\n\t\t \n\t\tif (ctrl->is_private)\n\t\t\tcontinue;\n\t\t \n\t\tif (ctrl->type == V4L2_CTRL_TYPE_CTRL_CLASS)\n\t\t\tcontinue;\n\t\t \n\t\tif (filter && !filter(ctrl))\n\t\t\tcontinue;\n\t\tret = handler_new_ref(hdl, ctrl, NULL, from_other_dev, false);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(add->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(v4l2_ctrl_add_handler);\n\nbool v4l2_ctrl_radio_filter(const struct v4l2_ctrl *ctrl)\n{\n\tif (V4L2_CTRL_ID2WHICH(ctrl->id) == V4L2_CTRL_CLASS_FM_TX)\n\t\treturn true;\n\tif (V4L2_CTRL_ID2WHICH(ctrl->id) == V4L2_CTRL_CLASS_FM_RX)\n\t\treturn true;\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\tcase V4L2_CID_AUDIO_VOLUME:\n\tcase V4L2_CID_AUDIO_BALANCE:\n\tcase V4L2_CID_AUDIO_BASS:\n\tcase V4L2_CID_AUDIO_TREBLE:\n\tcase V4L2_CID_AUDIO_LOUDNESS:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL(v4l2_ctrl_radio_filter);\n\n \nvoid v4l2_ctrl_cluster(unsigned ncontrols, struct v4l2_ctrl **controls)\n{\n\tbool has_volatiles = false;\n\tint i;\n\n\t \n\tif (WARN_ON(ncontrols == 0 || controls[0] == NULL))\n\t\treturn;\n\n\tfor (i = 0; i < ncontrols; i++) {\n\t\tif (controls[i]) {\n\t\t\tcontrols[i]->cluster = controls;\n\t\t\tcontrols[i]->ncontrols = ncontrols;\n\t\t\tif (controls[i]->flags & V4L2_CTRL_FLAG_VOLATILE)\n\t\t\t\thas_volatiles = true;\n\t\t}\n\t}\n\tcontrols[0]->has_volatiles = has_volatiles;\n}\nEXPORT_SYMBOL(v4l2_ctrl_cluster);\n\nvoid v4l2_ctrl_auto_cluster(unsigned ncontrols, struct v4l2_ctrl **controls,\n\t\t\t    u8 manual_val, bool set_volatile)\n{\n\tstruct v4l2_ctrl *master = controls[0];\n\tu32 flag = 0;\n\tint i;\n\n\tv4l2_ctrl_cluster(ncontrols, controls);\n\tWARN_ON(ncontrols <= 1);\n\tWARN_ON(manual_val < master->minimum || manual_val > master->maximum);\n\tWARN_ON(set_volatile && !has_op(master, g_volatile_ctrl));\n\tmaster->is_auto = true;\n\tmaster->has_volatiles = set_volatile;\n\tmaster->manual_mode_value = manual_val;\n\tmaster->flags |= V4L2_CTRL_FLAG_UPDATE;\n\n\tif (!is_cur_manual(master))\n\t\tflag = V4L2_CTRL_FLAG_INACTIVE |\n\t\t\t(set_volatile ? V4L2_CTRL_FLAG_VOLATILE : 0);\n\n\tfor (i = 1; i < ncontrols; i++)\n\t\tif (controls[i])\n\t\t\tcontrols[i]->flags |= flag;\n}\nEXPORT_SYMBOL(v4l2_ctrl_auto_cluster);\n\n \nvoid update_from_auto_cluster(struct v4l2_ctrl *master)\n{\n\tint i;\n\n\tfor (i = 1; i < master->ncontrols; i++)\n\t\tcur_to_new(master->cluster[i]);\n\tif (!call_op(master, g_volatile_ctrl))\n\t\tfor (i = 1; i < master->ncontrols; i++)\n\t\t\tif (master->cluster[i])\n\t\t\t\tmaster->cluster[i]->is_new = 1;\n}\n\n \nstatic int cluster_changed(struct v4l2_ctrl *master)\n{\n\tbool changed = false;\n\tint i;\n\n\tfor (i = 0; i < master->ncontrols; i++) {\n\t\tstruct v4l2_ctrl *ctrl = master->cluster[i];\n\t\tbool ctrl_changed = false;\n\n\t\tif (!ctrl)\n\t\t\tcontinue;\n\n\t\tif (ctrl->flags & V4L2_CTRL_FLAG_EXECUTE_ON_WRITE) {\n\t\t\tchanged = true;\n\t\t\tctrl_changed = true;\n\t\t}\n\n\t\t \n\t\tif (ctrl->flags & V4L2_CTRL_FLAG_VOLATILE) {\n\t\t\tctrl->has_changed = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ctrl->elems != ctrl->new_elems)\n\t\t\tctrl_changed = true;\n\t\tif (!ctrl_changed)\n\t\t\tctrl_changed = !ctrl->type_ops->equal(ctrl,\n\t\t\t\tctrl->p_cur, ctrl->p_new);\n\t\tctrl->has_changed = ctrl_changed;\n\t\tchanged |= ctrl->has_changed;\n\t}\n\treturn changed;\n}\n\n \nint try_or_set_cluster(struct v4l2_fh *fh, struct v4l2_ctrl *master,\n\t\t       bool set, u32 ch_flags)\n{\n\tbool update_flag;\n\tint ret;\n\tint i;\n\n\t \n\tfor (i = 0; i < master->ncontrols; i++) {\n\t\tstruct v4l2_ctrl *ctrl = master->cluster[i];\n\n\t\tif (!ctrl)\n\t\t\tcontinue;\n\n\t\tif (!ctrl->is_new) {\n\t\t\tcur_to_new(ctrl);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (set && (ctrl->flags & V4L2_CTRL_FLAG_GRABBED))\n\t\t\treturn -EBUSY;\n\t}\n\n\tret = call_op(master, try_ctrl);\n\n\t \n\tif (ret || !set || !cluster_changed(master))\n\t\treturn ret;\n\tret = call_op(master, s_ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tupdate_flag = is_cur_manual(master) != is_new_manual(master);\n\n\tfor (i = 0; i < master->ncontrols; i++) {\n\t\t \n\t\tif (i && update_flag && is_new_manual(master) &&\n\t\t    master->has_volatiles && master->cluster[i])\n\t\t\tmaster->cluster[i]->has_changed = true;\n\n\t\tnew_to_cur(fh, master->cluster[i], ch_flags |\n\t\t\t((update_flag && i > 0) ? V4L2_EVENT_CTRL_CH_FLAGS : 0));\n\t}\n\treturn 0;\n}\n\n \nvoid v4l2_ctrl_activate(struct v4l2_ctrl *ctrl, bool active)\n{\n\t \n\tbool inactive = !active;\n\tbool old;\n\n\tif (ctrl == NULL)\n\t\treturn;\n\n\tif (inactive)\n\t\t \n\t\told = test_and_set_bit(4, &ctrl->flags);\n\telse\n\t\t \n\t\told = test_and_clear_bit(4, &ctrl->flags);\n\tif (old != inactive)\n\t\tsend_event(NULL, ctrl, V4L2_EVENT_CTRL_CH_FLAGS);\n}\nEXPORT_SYMBOL(v4l2_ctrl_activate);\n\nvoid __v4l2_ctrl_grab(struct v4l2_ctrl *ctrl, bool grabbed)\n{\n\tbool old;\n\n\tif (ctrl == NULL)\n\t\treturn;\n\n\tlockdep_assert_held(ctrl->handler->lock);\n\n\tif (grabbed)\n\t\t \n\t\told = test_and_set_bit(1, &ctrl->flags);\n\telse\n\t\t \n\t\told = test_and_clear_bit(1, &ctrl->flags);\n\tif (old != grabbed)\n\t\tsend_event(NULL, ctrl, V4L2_EVENT_CTRL_CH_FLAGS);\n}\nEXPORT_SYMBOL(__v4l2_ctrl_grab);\n\n \nint __v4l2_ctrl_handler_setup(struct v4l2_ctrl_handler *hdl)\n{\n\tstruct v4l2_ctrl *ctrl;\n\tint ret = 0;\n\n\tif (hdl == NULL)\n\t\treturn 0;\n\n\tlockdep_assert_held(hdl->lock);\n\n\tlist_for_each_entry(ctrl, &hdl->ctrls, node)\n\t\tctrl->done = false;\n\n\tlist_for_each_entry(ctrl, &hdl->ctrls, node) {\n\t\tstruct v4l2_ctrl *master = ctrl->cluster[0];\n\t\tint i;\n\n\t\t \n\t\t \n\t\tif (ctrl->done || ctrl->type == V4L2_CTRL_TYPE_BUTTON ||\n\t\t    (ctrl->flags & V4L2_CTRL_FLAG_READ_ONLY))\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < master->ncontrols; i++) {\n\t\t\tif (master->cluster[i]) {\n\t\t\t\tcur_to_new(master->cluster[i]);\n\t\t\t\tmaster->cluster[i]->is_new = 1;\n\t\t\t\tmaster->cluster[i]->done = true;\n\t\t\t}\n\t\t}\n\t\tret = call_op(master, s_ctrl);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__v4l2_ctrl_handler_setup);\n\nint v4l2_ctrl_handler_setup(struct v4l2_ctrl_handler *hdl)\n{\n\tint ret;\n\n\tif (hdl == NULL)\n\t\treturn 0;\n\n\tmutex_lock(hdl->lock);\n\tret = __v4l2_ctrl_handler_setup(hdl);\n\tmutex_unlock(hdl->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(v4l2_ctrl_handler_setup);\n\n \nstatic void log_ctrl(const struct v4l2_ctrl *ctrl,\n\t\t     const char *prefix, const char *colon)\n{\n\tif (ctrl->flags & (V4L2_CTRL_FLAG_DISABLED | V4L2_CTRL_FLAG_WRITE_ONLY))\n\t\treturn;\n\tif (ctrl->type == V4L2_CTRL_TYPE_CTRL_CLASS)\n\t\treturn;\n\n\tpr_info(\"%s%s%s: \", prefix, colon, ctrl->name);\n\n\tctrl->type_ops->log(ctrl);\n\n\tif (ctrl->flags & (V4L2_CTRL_FLAG_INACTIVE |\n\t\t\t   V4L2_CTRL_FLAG_GRABBED |\n\t\t\t   V4L2_CTRL_FLAG_VOLATILE)) {\n\t\tif (ctrl->flags & V4L2_CTRL_FLAG_INACTIVE)\n\t\t\tpr_cont(\" inactive\");\n\t\tif (ctrl->flags & V4L2_CTRL_FLAG_GRABBED)\n\t\t\tpr_cont(\" grabbed\");\n\t\tif (ctrl->flags & V4L2_CTRL_FLAG_VOLATILE)\n\t\t\tpr_cont(\" volatile\");\n\t}\n\tpr_cont(\"\\n\");\n}\n\n \nvoid v4l2_ctrl_handler_log_status(struct v4l2_ctrl_handler *hdl,\n\t\t\t\t  const char *prefix)\n{\n\tstruct v4l2_ctrl *ctrl;\n\tconst char *colon = \"\";\n\tint len;\n\n\tif (!hdl)\n\t\treturn;\n\tif (!prefix)\n\t\tprefix = \"\";\n\tlen = strlen(prefix);\n\tif (len && prefix[len - 1] != ' ')\n\t\tcolon = \": \";\n\tmutex_lock(hdl->lock);\n\tlist_for_each_entry(ctrl, &hdl->ctrls, node)\n\t\tif (!(ctrl->flags & V4L2_CTRL_FLAG_DISABLED))\n\t\t\tlog_ctrl(ctrl, prefix, colon);\n\tmutex_unlock(hdl->lock);\n}\nEXPORT_SYMBOL(v4l2_ctrl_handler_log_status);\n\nint v4l2_ctrl_new_fwnode_properties(struct v4l2_ctrl_handler *hdl,\n\t\t\t\t    const struct v4l2_ctrl_ops *ctrl_ops,\n\t\t\t\t    const struct v4l2_fwnode_device_properties *p)\n{\n\tif (p->orientation != V4L2_FWNODE_PROPERTY_UNSET) {\n\t\tu32 orientation_ctrl;\n\n\t\tswitch (p->orientation) {\n\t\tcase V4L2_FWNODE_ORIENTATION_FRONT:\n\t\t\torientation_ctrl = V4L2_CAMERA_ORIENTATION_FRONT;\n\t\t\tbreak;\n\t\tcase V4L2_FWNODE_ORIENTATION_BACK:\n\t\t\torientation_ctrl = V4L2_CAMERA_ORIENTATION_BACK;\n\t\t\tbreak;\n\t\tcase V4L2_FWNODE_ORIENTATION_EXTERNAL:\n\t\t\torientation_ctrl = V4L2_CAMERA_ORIENTATION_EXTERNAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!v4l2_ctrl_new_std_menu(hdl, ctrl_ops,\n\t\t\t\t\t    V4L2_CID_CAMERA_ORIENTATION,\n\t\t\t\t\t    V4L2_CAMERA_ORIENTATION_EXTERNAL, 0,\n\t\t\t\t\t    orientation_ctrl))\n\t\t\treturn hdl->error;\n\t}\n\n\tif (p->rotation != V4L2_FWNODE_PROPERTY_UNSET) {\n\t\tif (!v4l2_ctrl_new_std(hdl, ctrl_ops,\n\t\t\t\t       V4L2_CID_CAMERA_SENSOR_ROTATION,\n\t\t\t\t       p->rotation, p->rotation, 1,\n\t\t\t\t       p->rotation))\n\t\t\treturn hdl->error;\n\t}\n\n\treturn hdl->error;\n}\nEXPORT_SYMBOL(v4l2_ctrl_new_fwnode_properties);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}