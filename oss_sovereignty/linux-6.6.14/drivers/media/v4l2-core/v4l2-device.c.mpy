{
  "module_name": "v4l2-device.c",
  "hash_id": "d43bb6f214bdec031dbdcfdca0c8c954503dda39779d3d7f14f371478e635f97",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/v4l2-device.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/ioctl.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n\nint v4l2_device_register(struct device *dev, struct v4l2_device *v4l2_dev)\n{\n\tif (v4l2_dev == NULL)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&v4l2_dev->subdevs);\n\tspin_lock_init(&v4l2_dev->lock);\n\tv4l2_prio_init(&v4l2_dev->prio);\n\tkref_init(&v4l2_dev->ref);\n\tget_device(dev);\n\tv4l2_dev->dev = dev;\n\tif (dev == NULL) {\n\t\t \n\t\tif (WARN_ON(!v4l2_dev->name[0]))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t \n\tif (!v4l2_dev->name[0])\n\t\tsnprintf(v4l2_dev->name, sizeof(v4l2_dev->name), \"%s %s\",\n\t\t\tdev->driver->name, dev_name(dev));\n\tif (!dev_get_drvdata(dev))\n\t\tdev_set_drvdata(dev, v4l2_dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(v4l2_device_register);\n\nstatic void v4l2_device_release(struct kref *ref)\n{\n\tstruct v4l2_device *v4l2_dev =\n\t\tcontainer_of(ref, struct v4l2_device, ref);\n\n\tif (v4l2_dev->release)\n\t\tv4l2_dev->release(v4l2_dev);\n}\n\nint v4l2_device_put(struct v4l2_device *v4l2_dev)\n{\n\treturn kref_put(&v4l2_dev->ref, v4l2_device_release);\n}\nEXPORT_SYMBOL_GPL(v4l2_device_put);\n\nint v4l2_device_set_name(struct v4l2_device *v4l2_dev, const char *basename,\n\t\t\t\t\t\tatomic_t *instance)\n{\n\tint num = atomic_inc_return(instance) - 1;\n\tint len = strlen(basename);\n\n\tif (basename[len - 1] >= '0' && basename[len - 1] <= '9')\n\t\tsnprintf(v4l2_dev->name, sizeof(v4l2_dev->name),\n\t\t\t\t\"%s-%d\", basename, num);\n\telse\n\t\tsnprintf(v4l2_dev->name, sizeof(v4l2_dev->name),\n\t\t\t\t\"%s%d\", basename, num);\n\treturn num;\n}\nEXPORT_SYMBOL_GPL(v4l2_device_set_name);\n\nvoid v4l2_device_disconnect(struct v4l2_device *v4l2_dev)\n{\n\tif (v4l2_dev->dev == NULL)\n\t\treturn;\n\n\tif (dev_get_drvdata(v4l2_dev->dev) == v4l2_dev)\n\t\tdev_set_drvdata(v4l2_dev->dev, NULL);\n\tput_device(v4l2_dev->dev);\n\tv4l2_dev->dev = NULL;\n}\nEXPORT_SYMBOL_GPL(v4l2_device_disconnect);\n\nvoid v4l2_device_unregister(struct v4l2_device *v4l2_dev)\n{\n\tstruct v4l2_subdev *sd, *next;\n\n\t \n\tif (v4l2_dev == NULL || !v4l2_dev->name[0])\n\t\treturn;\n\tv4l2_device_disconnect(v4l2_dev);\n\n\t \n\tlist_for_each_entry_safe(sd, next, &v4l2_dev->subdevs, list) {\n\t\tv4l2_device_unregister_subdev(sd);\n\t\tif (sd->flags & V4L2_SUBDEV_FL_IS_I2C)\n\t\t\tv4l2_i2c_subdev_unregister(sd);\n\t\telse if (sd->flags & V4L2_SUBDEV_FL_IS_SPI)\n\t\t\tv4l2_spi_subdev_unregister(sd);\n\t}\n\t \n\tv4l2_dev->name[0] = '\\0';\n}\nEXPORT_SYMBOL_GPL(v4l2_device_unregister);\n\nint v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,\n\t\t\t\tstruct v4l2_subdev *sd)\n{\n\tint err;\n\n\t \n\tif (!v4l2_dev || !sd || sd->v4l2_dev || !sd->name[0])\n\t\treturn -EINVAL;\n\n\t \n\tsd->owner_v4l2_dev = v4l2_dev->dev && v4l2_dev->dev->driver &&\n\t\tsd->owner == v4l2_dev->dev->driver->owner;\n\n\tif (!sd->owner_v4l2_dev && !try_module_get(sd->owner))\n\t\treturn -ENODEV;\n\n\tsd->v4l2_dev = v4l2_dev;\n\t \n\terr = v4l2_ctrl_add_handler(v4l2_dev->ctrl_handler, sd->ctrl_handler,\n\t\t\t\t    NULL, true);\n\tif (err)\n\t\tgoto error_module;\n\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\t \n\tif (v4l2_dev->mdev) {\n\t\terr = media_device_register_entity(v4l2_dev->mdev, &sd->entity);\n\t\tif (err < 0)\n\t\t\tgoto error_module;\n\t}\n#endif\n\n\tif (sd->internal_ops && sd->internal_ops->registered) {\n\t\terr = sd->internal_ops->registered(sd);\n\t\tif (err)\n\t\t\tgoto error_unregister;\n\t}\n\n\tspin_lock(&v4l2_dev->lock);\n\tlist_add_tail(&sd->list, &v4l2_dev->subdevs);\n\tspin_unlock(&v4l2_dev->lock);\n\n\treturn 0;\n\nerror_unregister:\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tmedia_device_unregister_entity(&sd->entity);\n#endif\nerror_module:\n\tif (!sd->owner_v4l2_dev)\n\t\tmodule_put(sd->owner);\n\tsd->v4l2_dev = NULL;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(v4l2_device_register_subdev);\n\nstatic void v4l2_subdev_release(struct v4l2_subdev *sd)\n{\n\tstruct module *owner = !sd->owner_v4l2_dev ? sd->owner : NULL;\n\n\tif (sd->internal_ops && sd->internal_ops->release)\n\t\tsd->internal_ops->release(sd);\n\tsd->devnode = NULL;\n\tmodule_put(owner);\n}\n\nstatic void v4l2_device_release_subdev_node(struct video_device *vdev)\n{\n\tv4l2_subdev_release(video_get_drvdata(vdev));\n\tkfree(vdev);\n}\n\nint __v4l2_device_register_subdev_nodes(struct v4l2_device *v4l2_dev,\n\t\t\t\t\tbool read_only)\n{\n\tstruct video_device *vdev;\n\tstruct v4l2_subdev *sd;\n\tint err;\n\n\t \n\tlist_for_each_entry(sd, &v4l2_dev->subdevs, list) {\n\t\tif (!(sd->flags & V4L2_SUBDEV_FL_HAS_DEVNODE))\n\t\t\tcontinue;\n\n\t\tif (sd->devnode)\n\t\t\tcontinue;\n\n\t\tvdev = kzalloc(sizeof(*vdev), GFP_KERNEL);\n\t\tif (!vdev) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto clean_up;\n\t\t}\n\n\t\tvideo_set_drvdata(vdev, sd);\n\t\tstrscpy(vdev->name, sd->name, sizeof(vdev->name));\n\t\tvdev->dev_parent = sd->dev;\n\t\tvdev->v4l2_dev = v4l2_dev;\n\t\tvdev->fops = &v4l2_subdev_fops;\n\t\tvdev->release = v4l2_device_release_subdev_node;\n\t\tvdev->ctrl_handler = sd->ctrl_handler;\n\t\tif (read_only)\n\t\t\tset_bit(V4L2_FL_SUBDEV_RO_DEVNODE, &vdev->flags);\n\t\tsd->devnode = vdev;\n\t\terr = __video_register_device(vdev, VFL_TYPE_SUBDEV, -1, 1,\n\t\t\t\t\t      sd->owner);\n\t\tif (err < 0) {\n\t\t\tsd->devnode = NULL;\n\t\t\tkfree(vdev);\n\t\t\tgoto clean_up;\n\t\t}\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\t\tsd->entity.info.dev.major = VIDEO_MAJOR;\n\t\tsd->entity.info.dev.minor = vdev->minor;\n\n\t\t \n\t\tif (vdev->v4l2_dev->mdev) {\n\t\t\tstruct media_link *link;\n\n\t\t\tlink = media_create_intf_link(&sd->entity,\n\t\t\t\t\t\t      &vdev->intf_devnode->intf,\n\t\t\t\t\t\t      MEDIA_LNK_FL_ENABLED |\n\t\t\t\t\t\t      MEDIA_LNK_FL_IMMUTABLE);\n\t\t\tif (!link) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto clean_up;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\treturn 0;\n\nclean_up:\n\tlist_for_each_entry(sd, &v4l2_dev->subdevs, list) {\n\t\tif (!sd->devnode)\n\t\t\tbreak;\n\t\tvideo_unregister_device(sd->devnode);\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(__v4l2_device_register_subdev_nodes);\n\nvoid v4l2_device_unregister_subdev(struct v4l2_subdev *sd)\n{\n\tstruct v4l2_device *v4l2_dev;\n\n\t \n\tif (sd == NULL || sd->v4l2_dev == NULL)\n\t\treturn;\n\n\tv4l2_dev = sd->v4l2_dev;\n\n\tspin_lock(&v4l2_dev->lock);\n\tlist_del(&sd->list);\n\tspin_unlock(&v4l2_dev->lock);\n\n\tif (sd->internal_ops && sd->internal_ops->unregistered)\n\t\tsd->internal_ops->unregistered(sd);\n\tsd->v4l2_dev = NULL;\n\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tif (v4l2_dev->mdev) {\n\t\t \n\t\tmedia_device_unregister_entity(&sd->entity);\n\t}\n#endif\n\tif (sd->devnode)\n\t\tvideo_unregister_device(sd->devnode);\n\telse\n\t\tv4l2_subdev_release(sd);\n}\nEXPORT_SYMBOL_GPL(v4l2_device_unregister_subdev);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}