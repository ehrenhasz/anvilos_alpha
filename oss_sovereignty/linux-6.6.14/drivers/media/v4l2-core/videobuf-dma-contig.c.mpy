{
  "module_name": "videobuf-dma-contig.c",
  "hash_id": "cacf1fffcfe9efba57fab145cff9f36e85c449791ea1cceb3e5efadeed182142",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/videobuf-dma-contig.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/dma-mapping.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <media/videobuf-dma-contig.h>\n\nstruct videobuf_dma_contig_memory {\n\tu32 magic;\n\tvoid *vaddr;\n\tdma_addr_t dma_handle;\n\tunsigned long size;\n};\n\n#define MAGIC_DC_MEM 0x0733ac61\n#define MAGIC_CHECK(is, should)\t\t\t\t\t\t    \\\n\tif (unlikely((is) != (should)))\t{\t\t\t\t    \\\n\t\tpr_err(\"magic mismatch: %x expected %x\\n\", (is), (should)); \\\n\t\tBUG();\t\t\t\t\t\t\t    \\\n\t}\n\nstatic int __videobuf_dc_alloc(struct device *dev,\n\t\t\t       struct videobuf_dma_contig_memory *mem,\n\t\t\t       unsigned long size)\n{\n\tmem->size = size;\n\tmem->vaddr = dma_alloc_coherent(dev, mem->size, &mem->dma_handle,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!mem->vaddr) {\n\t\tdev_err(dev, \"memory alloc size %ld failed\\n\", mem->size);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev_dbg(dev, \"dma mapped data is at %p (%ld)\\n\", mem->vaddr, mem->size);\n\n\treturn 0;\n}\n\nstatic void __videobuf_dc_free(struct device *dev,\n\t\t\t       struct videobuf_dma_contig_memory *mem)\n{\n\tdma_free_coherent(dev, mem->size, mem->vaddr, mem->dma_handle);\n\n\tmem->vaddr = NULL;\n}\n\nstatic void videobuf_vm_open(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\n\tdev_dbg(map->q->dev, \"vm_open %p [count=%u,vma=%08lx-%08lx]\\n\",\n\t\tmap, map->count, vma->vm_start, vma->vm_end);\n\n\tmap->count++;\n}\n\nstatic void videobuf_vm_close(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tstruct videobuf_queue *q = map->q;\n\tint i;\n\n\tdev_dbg(q->dev, \"vm_close %p [count=%u,vma=%08lx-%08lx]\\n\",\n\t\tmap, map->count, vma->vm_start, vma->vm_end);\n\n\tmap->count--;\n\tif (0 == map->count) {\n\t\tstruct videobuf_dma_contig_memory *mem;\n\n\t\tdev_dbg(q->dev, \"munmap %p q=%p\\n\", map, q);\n\t\tvideobuf_queue_lock(q);\n\n\t\t \n\t\tif (q->streaming)\n\t\t\tvideobuf_queue_cancel(q);\n\n\t\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\t\tif (NULL == q->bufs[i])\n\t\t\t\tcontinue;\n\n\t\t\tif (q->bufs[i]->map != map)\n\t\t\t\tcontinue;\n\n\t\t\tmem = q->bufs[i]->priv;\n\t\t\tif (mem) {\n\t\t\t\t \n\n\t\t\t\tMAGIC_CHECK(mem->magic, MAGIC_DC_MEM);\n\n\t\t\t\t \n\t\t\t\tdev_dbg(q->dev, \"buf[%d] freeing %p\\n\",\n\t\t\t\t\ti, mem->vaddr);\n\n\t\t\t\t__videobuf_dc_free(q->dev, mem);\n\t\t\t\tmem->vaddr = NULL;\n\t\t\t}\n\n\t\t\tq->bufs[i]->map = NULL;\n\t\t\tq->bufs[i]->baddr = 0;\n\t\t}\n\n\t\tkfree(map);\n\n\t\tvideobuf_queue_unlock(q);\n\t}\n}\n\nstatic const struct vm_operations_struct videobuf_vm_ops = {\n\t.open\t= videobuf_vm_open,\n\t.close\t= videobuf_vm_close,\n};\n\n \nstatic void videobuf_dma_contig_user_put(struct videobuf_dma_contig_memory *mem)\n{\n\tmem->dma_handle = 0;\n\tmem->size = 0;\n}\n\n \nstatic int videobuf_dma_contig_user_get(struct videobuf_dma_contig_memory *mem,\n\t\t\t\t\tstruct videobuf_buffer *vb)\n{\n\tunsigned long untagged_baddr = untagged_addr(vb->baddr);\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long prev_pfn, this_pfn;\n\tunsigned long pages_done, user_address;\n\tunsigned int offset;\n\tint ret;\n\n\toffset = untagged_baddr & ~PAGE_MASK;\n\tmem->size = PAGE_ALIGN(vb->size + offset);\n\tret = -EINVAL;\n\n\tmmap_read_lock(mm);\n\n\tvma = find_vma(mm, untagged_baddr);\n\tif (!vma)\n\t\tgoto out_up;\n\n\tif ((untagged_baddr + mem->size) > vma->vm_end)\n\t\tgoto out_up;\n\n\tpages_done = 0;\n\tprev_pfn = 0;  \n\tuser_address = untagged_baddr;\n\n\twhile (pages_done < (mem->size >> PAGE_SHIFT)) {\n\t\tret = follow_pfn(vma, user_address, &this_pfn);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (pages_done == 0)\n\t\t\tmem->dma_handle = (this_pfn << PAGE_SHIFT) + offset;\n\t\telse if (this_pfn != (prev_pfn + 1))\n\t\t\tret = -EFAULT;\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tprev_pfn = this_pfn;\n\t\tuser_address += PAGE_SIZE;\n\t\tpages_done++;\n\t}\n\nout_up:\n\tmmap_read_unlock(current->mm);\n\n\treturn ret;\n}\n\nstatic struct videobuf_buffer *__videobuf_alloc(size_t size)\n{\n\tstruct videobuf_dma_contig_memory *mem;\n\tstruct videobuf_buffer *vb;\n\n\tvb = kzalloc(size + sizeof(*mem), GFP_KERNEL);\n\tif (vb) {\n\t\tvb->priv = ((char *)vb) + size;\n\t\tmem = vb->priv;\n\t\tmem->magic = MAGIC_DC_MEM;\n\t}\n\n\treturn vb;\n}\n\nstatic void *__videobuf_to_vaddr(struct videobuf_buffer *buf)\n{\n\tstruct videobuf_dma_contig_memory *mem = buf->priv;\n\n\tBUG_ON(!mem);\n\tMAGIC_CHECK(mem->magic, MAGIC_DC_MEM);\n\n\treturn mem->vaddr;\n}\n\nstatic int __videobuf_iolock(struct videobuf_queue *q,\n\t\t\t     struct videobuf_buffer *vb,\n\t\t\t     struct v4l2_framebuffer *fbuf)\n{\n\tstruct videobuf_dma_contig_memory *mem = vb->priv;\n\n\tBUG_ON(!mem);\n\tMAGIC_CHECK(mem->magic, MAGIC_DC_MEM);\n\n\tswitch (vb->memory) {\n\tcase V4L2_MEMORY_MMAP:\n\t\tdev_dbg(q->dev, \"%s memory method MMAP\\n\", __func__);\n\n\t\t \n\t\tif (!mem->vaddr) {\n\t\t\tdev_err(q->dev, \"memory is not allocated/mmapped.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase V4L2_MEMORY_USERPTR:\n\t\tdev_dbg(q->dev, \"%s memory method USERPTR\\n\", __func__);\n\n\t\t \n\t\tif (vb->baddr)\n\t\t\treturn videobuf_dma_contig_user_get(mem, vb);\n\n\t\t \n\t\tif (__videobuf_dc_alloc(q->dev, mem, PAGE_ALIGN(vb->size)))\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase V4L2_MEMORY_OVERLAY:\n\tdefault:\n\t\tdev_dbg(q->dev, \"%s memory method OVERLAY/unknown\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __videobuf_mmap_mapper(struct videobuf_queue *q,\n\t\t\t\t  struct videobuf_buffer *buf,\n\t\t\t\t  struct vm_area_struct *vma)\n{\n\tstruct videobuf_dma_contig_memory *mem;\n\tstruct videobuf_mapping *map;\n\tint retval;\n\n\tdev_dbg(q->dev, \"%s\\n\", __func__);\n\n\t \n\tmap = kzalloc(sizeof(struct videobuf_mapping), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tbuf->map = map;\n\tmap->q = q;\n\n\tbuf->baddr = vma->vm_start;\n\n\tmem = buf->priv;\n\tBUG_ON(!mem);\n\tMAGIC_CHECK(mem->magic, MAGIC_DC_MEM);\n\n\tif (__videobuf_dc_alloc(q->dev, mem, PAGE_ALIGN(buf->bsize)))\n\t\tgoto error;\n\n\t \n\tvma->vm_pgoff = 0;\n\tretval = dma_mmap_coherent(q->dev, vma, mem->vaddr, mem->dma_handle,\n\t\t\t\t   mem->size);\n\tif (retval) {\n\t\tdev_err(q->dev, \"mmap: remap failed with error %d. \",\n\t\t\tretval);\n\t\tdma_free_coherent(q->dev, mem->size,\n\t\t\t\t  mem->vaddr, mem->dma_handle);\n\t\tgoto error;\n\t}\n\n\tvma->vm_ops = &videobuf_vm_ops;\n\tvm_flags_set(vma, VM_DONTEXPAND);\n\tvma->vm_private_data = map;\n\n\tdev_dbg(q->dev, \"mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\\n\",\n\t\tmap, q, vma->vm_start, vma->vm_end,\n\t\t(long int)buf->bsize, vma->vm_pgoff, buf->i);\n\n\tvideobuf_vm_open(vma);\n\n\treturn 0;\n\nerror:\n\tkfree(map);\n\treturn -ENOMEM;\n}\n\nstatic struct videobuf_qtype_ops qops = {\n\t.magic\t\t= MAGIC_QTYPE_OPS,\n\t.alloc_vb\t= __videobuf_alloc,\n\t.iolock\t\t= __videobuf_iolock,\n\t.mmap_mapper\t= __videobuf_mmap_mapper,\n\t.vaddr\t\t= __videobuf_to_vaddr,\n};\n\nvoid videobuf_queue_dma_contig_init(struct videobuf_queue *q,\n\t\t\t\t    const struct videobuf_queue_ops *ops,\n\t\t\t\t    struct device *dev,\n\t\t\t\t    spinlock_t *irqlock,\n\t\t\t\t    enum v4l2_buf_type type,\n\t\t\t\t    enum v4l2_field field,\n\t\t\t\t    unsigned int msize,\n\t\t\t\t    void *priv,\n\t\t\t\t    struct mutex *ext_lock)\n{\n\tvideobuf_queue_core_init(q, ops, dev, irqlock, type, field, msize,\n\t\t\t\t priv, &qops, ext_lock);\n}\nEXPORT_SYMBOL_GPL(videobuf_queue_dma_contig_init);\n\ndma_addr_t videobuf_to_dma_contig(struct videobuf_buffer *buf)\n{\n\tstruct videobuf_dma_contig_memory *mem = buf->priv;\n\n\tBUG_ON(!mem);\n\tMAGIC_CHECK(mem->magic, MAGIC_DC_MEM);\n\n\treturn mem->dma_handle;\n}\nEXPORT_SYMBOL_GPL(videobuf_to_dma_contig);\n\nvoid videobuf_dma_contig_free(struct videobuf_queue *q,\n\t\t\t      struct videobuf_buffer *buf)\n{\n\tstruct videobuf_dma_contig_memory *mem = buf->priv;\n\n\t \n\tif (buf->memory != V4L2_MEMORY_USERPTR)\n\t\treturn;\n\n\tif (!mem)\n\t\treturn;\n\n\tMAGIC_CHECK(mem->magic, MAGIC_DC_MEM);\n\n\t \n\tif (buf->baddr) {\n\t\tvideobuf_dma_contig_user_put(mem);\n\t\treturn;\n\t}\n\n\t \n\tif (mem->vaddr) {\n\t\t__videobuf_dc_free(q->dev, mem);\n\t\tmem->vaddr = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(videobuf_dma_contig_free);\n\nMODULE_DESCRIPTION(\"helper module to manage video4linux dma contig buffers\");\nMODULE_AUTHOR(\"Magnus Damm\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}