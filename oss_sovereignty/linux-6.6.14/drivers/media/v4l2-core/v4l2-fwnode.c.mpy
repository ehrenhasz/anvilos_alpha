{
  "module_name": "v4l2-fwnode.c",
  "hash_id": "33623697098e1711fe16075a001b8e974bd4106ec5c962da8cd3ab094dad3c4a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/v4l2-fwnode.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\n#include <media/v4l2-async.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n#include \"v4l2-subdev-priv.h\"\n\nstatic const struct v4l2_fwnode_bus_conv {\n\tenum v4l2_fwnode_bus_type fwnode_bus_type;\n\tenum v4l2_mbus_type mbus_type;\n\tconst char *name;\n} buses[] = {\n\t{\n\t\tV4L2_FWNODE_BUS_TYPE_GUESS,\n\t\tV4L2_MBUS_UNKNOWN,\n\t\t\"not specified\",\n\t}, {\n\t\tV4L2_FWNODE_BUS_TYPE_CSI2_CPHY,\n\t\tV4L2_MBUS_CSI2_CPHY,\n\t\t\"MIPI CSI-2 C-PHY\",\n\t}, {\n\t\tV4L2_FWNODE_BUS_TYPE_CSI1,\n\t\tV4L2_MBUS_CSI1,\n\t\t\"MIPI CSI-1\",\n\t}, {\n\t\tV4L2_FWNODE_BUS_TYPE_CCP2,\n\t\tV4L2_MBUS_CCP2,\n\t\t\"compact camera port 2\",\n\t}, {\n\t\tV4L2_FWNODE_BUS_TYPE_CSI2_DPHY,\n\t\tV4L2_MBUS_CSI2_DPHY,\n\t\t\"MIPI CSI-2 D-PHY\",\n\t}, {\n\t\tV4L2_FWNODE_BUS_TYPE_PARALLEL,\n\t\tV4L2_MBUS_PARALLEL,\n\t\t\"parallel\",\n\t}, {\n\t\tV4L2_FWNODE_BUS_TYPE_BT656,\n\t\tV4L2_MBUS_BT656,\n\t\t\"Bt.656\",\n\t}, {\n\t\tV4L2_FWNODE_BUS_TYPE_DPI,\n\t\tV4L2_MBUS_DPI,\n\t\t\"DPI\",\n\t}\n};\n\nstatic const struct v4l2_fwnode_bus_conv *\nget_v4l2_fwnode_bus_conv_by_fwnode_bus(enum v4l2_fwnode_bus_type type)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(buses); i++)\n\t\tif (buses[i].fwnode_bus_type == type)\n\t\t\treturn &buses[i];\n\n\treturn NULL;\n}\n\nstatic enum v4l2_mbus_type\nv4l2_fwnode_bus_type_to_mbus(enum v4l2_fwnode_bus_type type)\n{\n\tconst struct v4l2_fwnode_bus_conv *conv =\n\t\tget_v4l2_fwnode_bus_conv_by_fwnode_bus(type);\n\n\treturn conv ? conv->mbus_type : V4L2_MBUS_INVALID;\n}\n\nstatic const char *\nv4l2_fwnode_bus_type_to_string(enum v4l2_fwnode_bus_type type)\n{\n\tconst struct v4l2_fwnode_bus_conv *conv =\n\t\tget_v4l2_fwnode_bus_conv_by_fwnode_bus(type);\n\n\treturn conv ? conv->name : \"not found\";\n}\n\nstatic const struct v4l2_fwnode_bus_conv *\nget_v4l2_fwnode_bus_conv_by_mbus(enum v4l2_mbus_type type)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(buses); i++)\n\t\tif (buses[i].mbus_type == type)\n\t\t\treturn &buses[i];\n\n\treturn NULL;\n}\n\nstatic const char *\nv4l2_fwnode_mbus_type_to_string(enum v4l2_mbus_type type)\n{\n\tconst struct v4l2_fwnode_bus_conv *conv =\n\t\tget_v4l2_fwnode_bus_conv_by_mbus(type);\n\n\treturn conv ? conv->name : \"not found\";\n}\n\nstatic int v4l2_fwnode_endpoint_parse_csi2_bus(struct fwnode_handle *fwnode,\n\t\t\t\t\t       struct v4l2_fwnode_endpoint *vep,\n\t\t\t\t\t       enum v4l2_mbus_type bus_type)\n{\n\tstruct v4l2_mbus_config_mipi_csi2 *bus = &vep->bus.mipi_csi2;\n\tbool have_clk_lane = false, have_data_lanes = false,\n\t\thave_lane_polarities = false;\n\tunsigned int flags = 0, lanes_used = 0;\n\tu32 array[1 + V4L2_MBUS_CSI2_MAX_DATA_LANES];\n\tu32 clock_lane = 0;\n\tunsigned int num_data_lanes = 0;\n\tbool use_default_lane_mapping = false;\n\tunsigned int i;\n\tu32 v;\n\tint rval;\n\n\tif (bus_type == V4L2_MBUS_CSI2_DPHY ||\n\t    bus_type == V4L2_MBUS_CSI2_CPHY) {\n\t\tuse_default_lane_mapping = true;\n\n\t\tnum_data_lanes = min_t(u32, bus->num_data_lanes,\n\t\t\t\t       V4L2_MBUS_CSI2_MAX_DATA_LANES);\n\n\t\tclock_lane = bus->clock_lane;\n\t\tif (clock_lane)\n\t\t\tuse_default_lane_mapping = false;\n\n\t\tfor (i = 0; i < num_data_lanes; i++) {\n\t\t\tarray[i] = bus->data_lanes[i];\n\t\t\tif (array[i])\n\t\t\t\tuse_default_lane_mapping = false;\n\t\t}\n\n\t\tif (use_default_lane_mapping)\n\t\t\tpr_debug(\"no lane mapping given, using defaults\\n\");\n\t}\n\n\trval = fwnode_property_count_u32(fwnode, \"data-lanes\");\n\tif (rval > 0) {\n\t\tnum_data_lanes =\n\t\t\tmin_t(int, V4L2_MBUS_CSI2_MAX_DATA_LANES, rval);\n\n\t\tfwnode_property_read_u32_array(fwnode, \"data-lanes\", array,\n\t\t\t\t\t       num_data_lanes);\n\n\t\thave_data_lanes = true;\n\t\tif (use_default_lane_mapping) {\n\t\t\tpr_debug(\"data-lanes property exists; disabling default mapping\\n\");\n\t\t\tuse_default_lane_mapping = false;\n\t\t}\n\t}\n\n\tfor (i = 0; i < num_data_lanes; i++) {\n\t\tif (lanes_used & BIT(array[i])) {\n\t\t\tif (have_data_lanes || !use_default_lane_mapping)\n\t\t\t\tpr_warn(\"duplicated lane %u in data-lanes, using defaults\\n\",\n\t\t\t\t\tarray[i]);\n\t\t\tuse_default_lane_mapping = true;\n\t\t}\n\t\tlanes_used |= BIT(array[i]);\n\n\t\tif (have_data_lanes)\n\t\t\tpr_debug(\"lane %u position %u\\n\", i, array[i]);\n\t}\n\n\trval = fwnode_property_count_u32(fwnode, \"lane-polarities\");\n\tif (rval > 0) {\n\t\tif (rval != 1 + num_data_lanes  ) {\n\t\t\tpr_warn(\"invalid number of lane-polarities entries (need %u, got %u)\\n\",\n\t\t\t\t1 + num_data_lanes, rval);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\thave_lane_polarities = true;\n\t}\n\n\tif (!fwnode_property_read_u32(fwnode, \"clock-lanes\", &v)) {\n\t\tclock_lane = v;\n\t\tpr_debug(\"clock lane position %u\\n\", v);\n\t\thave_clk_lane = true;\n\t}\n\n\tif (have_clk_lane && lanes_used & BIT(clock_lane) &&\n\t    !use_default_lane_mapping) {\n\t\tpr_warn(\"duplicated lane %u in clock-lanes, using defaults\\n\",\n\t\t\tv);\n\t\tuse_default_lane_mapping = true;\n\t}\n\n\tif (fwnode_property_present(fwnode, \"clock-noncontinuous\")) {\n\t\tflags |= V4L2_MBUS_CSI2_NONCONTINUOUS_CLOCK;\n\t\tpr_debug(\"non-continuous clock\\n\");\n\t}\n\n\tif (bus_type == V4L2_MBUS_CSI2_DPHY ||\n\t    bus_type == V4L2_MBUS_CSI2_CPHY ||\n\t    lanes_used || have_clk_lane || flags) {\n\t\t \n\t\tunsigned int dfl_data_lane_index =\n\t\t\tbus_type == V4L2_MBUS_CSI2_DPHY;\n\n\t\tbus->flags = flags;\n\t\tif (bus_type == V4L2_MBUS_UNKNOWN)\n\t\t\tvep->bus_type = V4L2_MBUS_CSI2_DPHY;\n\t\tbus->num_data_lanes = num_data_lanes;\n\n\t\tif (use_default_lane_mapping) {\n\t\t\tbus->clock_lane = 0;\n\t\t\tfor (i = 0; i < num_data_lanes; i++)\n\t\t\t\tbus->data_lanes[i] = dfl_data_lane_index + i;\n\t\t} else {\n\t\t\tbus->clock_lane = clock_lane;\n\t\t\tfor (i = 0; i < num_data_lanes; i++)\n\t\t\t\tbus->data_lanes[i] = array[i];\n\t\t}\n\n\t\tif (have_lane_polarities) {\n\t\t\tfwnode_property_read_u32_array(fwnode,\n\t\t\t\t\t\t       \"lane-polarities\", array,\n\t\t\t\t\t\t       1 + num_data_lanes);\n\n\t\t\tfor (i = 0; i < 1 + num_data_lanes; i++) {\n\t\t\t\tbus->lane_polarities[i] = array[i];\n\t\t\t\tpr_debug(\"lane %u polarity %sinverted\",\n\t\t\t\t\t i, array[i] ? \"\" : \"not \");\n\t\t\t}\n\t\t} else {\n\t\t\tpr_debug(\"no lane polarities defined, assuming not inverted\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#define PARALLEL_MBUS_FLAGS (V4L2_MBUS_HSYNC_ACTIVE_HIGH |\t\\\n\t\t\t     V4L2_MBUS_HSYNC_ACTIVE_LOW |\t\\\n\t\t\t     V4L2_MBUS_VSYNC_ACTIVE_HIGH |\t\\\n\t\t\t     V4L2_MBUS_VSYNC_ACTIVE_LOW |\t\\\n\t\t\t     V4L2_MBUS_FIELD_EVEN_HIGH |\t\\\n\t\t\t     V4L2_MBUS_FIELD_EVEN_LOW)\n\nstatic void\nv4l2_fwnode_endpoint_parse_parallel_bus(struct fwnode_handle *fwnode,\n\t\t\t\t\tstruct v4l2_fwnode_endpoint *vep,\n\t\t\t\t\tenum v4l2_mbus_type bus_type)\n{\n\tstruct v4l2_mbus_config_parallel *bus = &vep->bus.parallel;\n\tunsigned int flags = 0;\n\tu32 v;\n\n\tif (bus_type == V4L2_MBUS_PARALLEL || bus_type == V4L2_MBUS_BT656)\n\t\tflags = bus->flags;\n\n\tif (!fwnode_property_read_u32(fwnode, \"hsync-active\", &v)) {\n\t\tflags &= ~(V4L2_MBUS_HSYNC_ACTIVE_HIGH |\n\t\t\t   V4L2_MBUS_HSYNC_ACTIVE_LOW);\n\t\tflags |= v ? V4L2_MBUS_HSYNC_ACTIVE_HIGH :\n\t\t\tV4L2_MBUS_HSYNC_ACTIVE_LOW;\n\t\tpr_debug(\"hsync-active %s\\n\", v ? \"high\" : \"low\");\n\t}\n\n\tif (!fwnode_property_read_u32(fwnode, \"vsync-active\", &v)) {\n\t\tflags &= ~(V4L2_MBUS_VSYNC_ACTIVE_HIGH |\n\t\t\t   V4L2_MBUS_VSYNC_ACTIVE_LOW);\n\t\tflags |= v ? V4L2_MBUS_VSYNC_ACTIVE_HIGH :\n\t\t\tV4L2_MBUS_VSYNC_ACTIVE_LOW;\n\t\tpr_debug(\"vsync-active %s\\n\", v ? \"high\" : \"low\");\n\t}\n\n\tif (!fwnode_property_read_u32(fwnode, \"field-even-active\", &v)) {\n\t\tflags &= ~(V4L2_MBUS_FIELD_EVEN_HIGH |\n\t\t\t   V4L2_MBUS_FIELD_EVEN_LOW);\n\t\tflags |= v ? V4L2_MBUS_FIELD_EVEN_HIGH :\n\t\t\tV4L2_MBUS_FIELD_EVEN_LOW;\n\t\tpr_debug(\"field-even-active %s\\n\", v ? \"high\" : \"low\");\n\t}\n\n\tif (!fwnode_property_read_u32(fwnode, \"pclk-sample\", &v)) {\n\t\tflags &= ~(V4L2_MBUS_PCLK_SAMPLE_RISING |\n\t\t\t   V4L2_MBUS_PCLK_SAMPLE_FALLING |\n\t\t\t   V4L2_MBUS_PCLK_SAMPLE_DUALEDGE);\n\t\tswitch (v) {\n\t\tcase 0:\n\t\t\tflags |= V4L2_MBUS_PCLK_SAMPLE_FALLING;\n\t\t\tpr_debug(\"pclk-sample low\\n\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tflags |= V4L2_MBUS_PCLK_SAMPLE_RISING;\n\t\t\tpr_debug(\"pclk-sample high\\n\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tflags |= V4L2_MBUS_PCLK_SAMPLE_DUALEDGE;\n\t\t\tpr_debug(\"pclk-sample dual edge\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"invalid argument for pclk-sample\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!fwnode_property_read_u32(fwnode, \"data-active\", &v)) {\n\t\tflags &= ~(V4L2_MBUS_DATA_ACTIVE_HIGH |\n\t\t\t   V4L2_MBUS_DATA_ACTIVE_LOW);\n\t\tflags |= v ? V4L2_MBUS_DATA_ACTIVE_HIGH :\n\t\t\tV4L2_MBUS_DATA_ACTIVE_LOW;\n\t\tpr_debug(\"data-active %s\\n\", v ? \"high\" : \"low\");\n\t}\n\n\tif (fwnode_property_present(fwnode, \"slave-mode\")) {\n\t\tpr_debug(\"slave mode\\n\");\n\t\tflags &= ~V4L2_MBUS_MASTER;\n\t\tflags |= V4L2_MBUS_SLAVE;\n\t} else {\n\t\tflags &= ~V4L2_MBUS_SLAVE;\n\t\tflags |= V4L2_MBUS_MASTER;\n\t}\n\n\tif (!fwnode_property_read_u32(fwnode, \"bus-width\", &v)) {\n\t\tbus->bus_width = v;\n\t\tpr_debug(\"bus-width %u\\n\", v);\n\t}\n\n\tif (!fwnode_property_read_u32(fwnode, \"data-shift\", &v)) {\n\t\tbus->data_shift = v;\n\t\tpr_debug(\"data-shift %u\\n\", v);\n\t}\n\n\tif (!fwnode_property_read_u32(fwnode, \"sync-on-green-active\", &v)) {\n\t\tflags &= ~(V4L2_MBUS_VIDEO_SOG_ACTIVE_HIGH |\n\t\t\t   V4L2_MBUS_VIDEO_SOG_ACTIVE_LOW);\n\t\tflags |= v ? V4L2_MBUS_VIDEO_SOG_ACTIVE_HIGH :\n\t\t\tV4L2_MBUS_VIDEO_SOG_ACTIVE_LOW;\n\t\tpr_debug(\"sync-on-green-active %s\\n\", v ? \"high\" : \"low\");\n\t}\n\n\tif (!fwnode_property_read_u32(fwnode, \"data-enable-active\", &v)) {\n\t\tflags &= ~(V4L2_MBUS_DATA_ENABLE_HIGH |\n\t\t\t   V4L2_MBUS_DATA_ENABLE_LOW);\n\t\tflags |= v ? V4L2_MBUS_DATA_ENABLE_HIGH :\n\t\t\tV4L2_MBUS_DATA_ENABLE_LOW;\n\t\tpr_debug(\"data-enable-active %s\\n\", v ? \"high\" : \"low\");\n\t}\n\n\tswitch (bus_type) {\n\tdefault:\n\t\tbus->flags = flags;\n\t\tif (flags & PARALLEL_MBUS_FLAGS)\n\t\t\tvep->bus_type = V4L2_MBUS_PARALLEL;\n\t\telse\n\t\t\tvep->bus_type = V4L2_MBUS_BT656;\n\t\tbreak;\n\tcase V4L2_MBUS_PARALLEL:\n\t\tvep->bus_type = V4L2_MBUS_PARALLEL;\n\t\tbus->flags = flags;\n\t\tbreak;\n\tcase V4L2_MBUS_BT656:\n\t\tvep->bus_type = V4L2_MBUS_BT656;\n\t\tbus->flags = flags & ~PARALLEL_MBUS_FLAGS;\n\t\tbreak;\n\t}\n}\n\nstatic void\nv4l2_fwnode_endpoint_parse_csi1_bus(struct fwnode_handle *fwnode,\n\t\t\t\t    struct v4l2_fwnode_endpoint *vep,\n\t\t\t\t    enum v4l2_mbus_type bus_type)\n{\n\tstruct v4l2_mbus_config_mipi_csi1 *bus = &vep->bus.mipi_csi1;\n\tu32 v;\n\n\tif (!fwnode_property_read_u32(fwnode, \"clock-inv\", &v)) {\n\t\tbus->clock_inv = v;\n\t\tpr_debug(\"clock-inv %u\\n\", v);\n\t}\n\n\tif (!fwnode_property_read_u32(fwnode, \"strobe\", &v)) {\n\t\tbus->strobe = v;\n\t\tpr_debug(\"strobe %u\\n\", v);\n\t}\n\n\tif (!fwnode_property_read_u32(fwnode, \"data-lanes\", &v)) {\n\t\tbus->data_lane = v;\n\t\tpr_debug(\"data-lanes %u\\n\", v);\n\t}\n\n\tif (!fwnode_property_read_u32(fwnode, \"clock-lanes\", &v)) {\n\t\tbus->clock_lane = v;\n\t\tpr_debug(\"clock-lanes %u\\n\", v);\n\t}\n\n\tif (bus_type == V4L2_MBUS_CCP2)\n\t\tvep->bus_type = V4L2_MBUS_CCP2;\n\telse\n\t\tvep->bus_type = V4L2_MBUS_CSI1;\n}\n\nstatic int __v4l2_fwnode_endpoint_parse(struct fwnode_handle *fwnode,\n\t\t\t\t\tstruct v4l2_fwnode_endpoint *vep)\n{\n\tu32 bus_type = V4L2_FWNODE_BUS_TYPE_GUESS;\n\tenum v4l2_mbus_type mbus_type;\n\tint rval;\n\n\tpr_debug(\"===== begin parsing endpoint %pfw\\n\", fwnode);\n\n\tfwnode_property_read_u32(fwnode, \"bus-type\", &bus_type);\n\tpr_debug(\"fwnode video bus type %s (%u), mbus type %s (%u)\\n\",\n\t\t v4l2_fwnode_bus_type_to_string(bus_type), bus_type,\n\t\t v4l2_fwnode_mbus_type_to_string(vep->bus_type),\n\t\t vep->bus_type);\n\tmbus_type = v4l2_fwnode_bus_type_to_mbus(bus_type);\n\tif (mbus_type == V4L2_MBUS_INVALID) {\n\t\tpr_debug(\"unsupported bus type %u\\n\", bus_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (vep->bus_type != V4L2_MBUS_UNKNOWN) {\n\t\tif (mbus_type != V4L2_MBUS_UNKNOWN &&\n\t\t    vep->bus_type != mbus_type) {\n\t\t\tpr_debug(\"expecting bus type %s\\n\",\n\t\t\t\t v4l2_fwnode_mbus_type_to_string(vep->bus_type));\n\t\t\treturn -ENXIO;\n\t\t}\n\t} else {\n\t\tvep->bus_type = mbus_type;\n\t}\n\n\tswitch (vep->bus_type) {\n\tcase V4L2_MBUS_UNKNOWN:\n\t\trval = v4l2_fwnode_endpoint_parse_csi2_bus(fwnode, vep,\n\t\t\t\t\t\t\t   V4L2_MBUS_UNKNOWN);\n\t\tif (rval)\n\t\t\treturn rval;\n\n\t\tif (vep->bus_type == V4L2_MBUS_UNKNOWN)\n\t\t\tv4l2_fwnode_endpoint_parse_parallel_bus(fwnode, vep,\n\t\t\t\t\t\t\t\tV4L2_MBUS_UNKNOWN);\n\n\t\tpr_debug(\"assuming media bus type %s (%u)\\n\",\n\t\t\t v4l2_fwnode_mbus_type_to_string(vep->bus_type),\n\t\t\t vep->bus_type);\n\n\t\tbreak;\n\tcase V4L2_MBUS_CCP2:\n\tcase V4L2_MBUS_CSI1:\n\t\tv4l2_fwnode_endpoint_parse_csi1_bus(fwnode, vep, vep->bus_type);\n\n\t\tbreak;\n\tcase V4L2_MBUS_CSI2_DPHY:\n\tcase V4L2_MBUS_CSI2_CPHY:\n\t\trval = v4l2_fwnode_endpoint_parse_csi2_bus(fwnode, vep,\n\t\t\t\t\t\t\t   vep->bus_type);\n\t\tif (rval)\n\t\t\treturn rval;\n\n\t\tbreak;\n\tcase V4L2_MBUS_PARALLEL:\n\tcase V4L2_MBUS_BT656:\n\t\tv4l2_fwnode_endpoint_parse_parallel_bus(fwnode, vep,\n\t\t\t\t\t\t\tvep->bus_type);\n\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"unsupported bus type %u\\n\", mbus_type);\n\t\treturn -EINVAL;\n\t}\n\n\tfwnode_graph_parse_endpoint(fwnode, &vep->base);\n\n\treturn 0;\n}\n\nint v4l2_fwnode_endpoint_parse(struct fwnode_handle *fwnode,\n\t\t\t       struct v4l2_fwnode_endpoint *vep)\n{\n\tint ret;\n\n\tret = __v4l2_fwnode_endpoint_parse(fwnode, vep);\n\n\tpr_debug(\"===== end parsing endpoint %pfw\\n\", fwnode);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(v4l2_fwnode_endpoint_parse);\n\nvoid v4l2_fwnode_endpoint_free(struct v4l2_fwnode_endpoint *vep)\n{\n\tif (IS_ERR_OR_NULL(vep))\n\t\treturn;\n\n\tkfree(vep->link_frequencies);\n\tvep->link_frequencies = NULL;\n}\nEXPORT_SYMBOL_GPL(v4l2_fwnode_endpoint_free);\n\nint v4l2_fwnode_endpoint_alloc_parse(struct fwnode_handle *fwnode,\n\t\t\t\t     struct v4l2_fwnode_endpoint *vep)\n{\n\tint rval;\n\n\trval = __v4l2_fwnode_endpoint_parse(fwnode, vep);\n\tif (rval < 0)\n\t\treturn rval;\n\n\trval = fwnode_property_count_u64(fwnode, \"link-frequencies\");\n\tif (rval > 0) {\n\t\tunsigned int i;\n\n\t\tvep->link_frequencies =\n\t\t\tkmalloc_array(rval, sizeof(*vep->link_frequencies),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!vep->link_frequencies)\n\t\t\treturn -ENOMEM;\n\n\t\tvep->nr_of_link_frequencies = rval;\n\n\t\trval = fwnode_property_read_u64_array(fwnode,\n\t\t\t\t\t\t      \"link-frequencies\",\n\t\t\t\t\t\t      vep->link_frequencies,\n\t\t\t\t\t\t      vep->nr_of_link_frequencies);\n\t\tif (rval < 0) {\n\t\t\tv4l2_fwnode_endpoint_free(vep);\n\t\t\treturn rval;\n\t\t}\n\n\t\tfor (i = 0; i < vep->nr_of_link_frequencies; i++)\n\t\t\tpr_debug(\"link-frequencies %u value %llu\\n\", i,\n\t\t\t\t vep->link_frequencies[i]);\n\t}\n\n\tpr_debug(\"===== end parsing endpoint %pfw\\n\", fwnode);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(v4l2_fwnode_endpoint_alloc_parse);\n\nint v4l2_fwnode_parse_link(struct fwnode_handle *fwnode,\n\t\t\t   struct v4l2_fwnode_link *link)\n{\n\tstruct fwnode_endpoint fwep;\n\n\tmemset(link, 0, sizeof(*link));\n\n\tfwnode_graph_parse_endpoint(fwnode, &fwep);\n\tlink->local_id = fwep.id;\n\tlink->local_port = fwep.port;\n\tlink->local_node = fwnode_graph_get_port_parent(fwnode);\n\tif (!link->local_node)\n\t\treturn -ENOLINK;\n\n\tfwnode = fwnode_graph_get_remote_endpoint(fwnode);\n\tif (!fwnode)\n\t\tgoto err_put_local_node;\n\n\tfwnode_graph_parse_endpoint(fwnode, &fwep);\n\tlink->remote_id = fwep.id;\n\tlink->remote_port = fwep.port;\n\tlink->remote_node = fwnode_graph_get_port_parent(fwnode);\n\tif (!link->remote_node)\n\t\tgoto err_put_remote_endpoint;\n\n\treturn 0;\n\nerr_put_remote_endpoint:\n\tfwnode_handle_put(fwnode);\n\nerr_put_local_node:\n\tfwnode_handle_put(link->local_node);\n\n\treturn -ENOLINK;\n}\nEXPORT_SYMBOL_GPL(v4l2_fwnode_parse_link);\n\nvoid v4l2_fwnode_put_link(struct v4l2_fwnode_link *link)\n{\n\tfwnode_handle_put(link->local_node);\n\tfwnode_handle_put(link->remote_node);\n}\nEXPORT_SYMBOL_GPL(v4l2_fwnode_put_link);\n\nstatic const struct v4l2_fwnode_connector_conv {\n\tenum v4l2_connector_type type;\n\tconst char *compatible;\n} connectors[] = {\n\t{\n\t\t.type = V4L2_CONN_COMPOSITE,\n\t\t.compatible = \"composite-video-connector\",\n\t}, {\n\t\t.type = V4L2_CONN_SVIDEO,\n\t\t.compatible = \"svideo-connector\",\n\t},\n};\n\nstatic enum v4l2_connector_type\nv4l2_fwnode_string_to_connector_type(const char *con_str)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(connectors); i++)\n\t\tif (!strcmp(con_str, connectors[i].compatible))\n\t\t\treturn connectors[i].type;\n\n\treturn V4L2_CONN_UNKNOWN;\n}\n\nstatic void\nv4l2_fwnode_connector_parse_analog(struct fwnode_handle *fwnode,\n\t\t\t\t   struct v4l2_fwnode_connector *vc)\n{\n\tu32 stds;\n\tint ret;\n\n\tret = fwnode_property_read_u32(fwnode, \"sdtv-standards\", &stds);\n\n\t \n\tvc->connector.analog.sdtv_stds = ret ? V4L2_STD_ALL : stds;\n}\n\nvoid v4l2_fwnode_connector_free(struct v4l2_fwnode_connector *connector)\n{\n\tstruct v4l2_connector_link *link, *tmp;\n\n\tif (IS_ERR_OR_NULL(connector) || connector->type == V4L2_CONN_UNKNOWN)\n\t\treturn;\n\n\tlist_for_each_entry_safe(link, tmp, &connector->links, head) {\n\t\tv4l2_fwnode_put_link(&link->fwnode_link);\n\t\tlist_del(&link->head);\n\t\tkfree(link);\n\t}\n\n\tkfree(connector->label);\n\tconnector->label = NULL;\n\tconnector->type = V4L2_CONN_UNKNOWN;\n}\nEXPORT_SYMBOL_GPL(v4l2_fwnode_connector_free);\n\nstatic enum v4l2_connector_type\nv4l2_fwnode_get_connector_type(struct fwnode_handle *fwnode)\n{\n\tconst char *type_name;\n\tint err;\n\n\tif (!fwnode)\n\t\treturn V4L2_CONN_UNKNOWN;\n\n\t \n\terr = fwnode_property_read_string(fwnode, \"compatible\", &type_name);\n\tif (err)\n\t\treturn V4L2_CONN_UNKNOWN;\n\n\treturn v4l2_fwnode_string_to_connector_type(type_name);\n}\n\nint v4l2_fwnode_connector_parse(struct fwnode_handle *fwnode,\n\t\t\t\tstruct v4l2_fwnode_connector *connector)\n{\n\tstruct fwnode_handle *connector_node;\n\tenum v4l2_connector_type connector_type;\n\tconst char *label;\n\tint err;\n\n\tif (!fwnode)\n\t\treturn -EINVAL;\n\n\tmemset(connector, 0, sizeof(*connector));\n\n\tINIT_LIST_HEAD(&connector->links);\n\n\tconnector_node = fwnode_graph_get_port_parent(fwnode);\n\tconnector_type = v4l2_fwnode_get_connector_type(connector_node);\n\tif (connector_type == V4L2_CONN_UNKNOWN) {\n\t\tfwnode_handle_put(connector_node);\n\t\tconnector_node = fwnode_graph_get_remote_port_parent(fwnode);\n\t\tconnector_type = v4l2_fwnode_get_connector_type(connector_node);\n\t}\n\n\tif (connector_type == V4L2_CONN_UNKNOWN) {\n\t\tpr_err(\"Unknown connector type\\n\");\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tconnector->type = connector_type;\n\tconnector->name = fwnode_get_name(connector_node);\n\terr = fwnode_property_read_string(connector_node, \"label\", &label);\n\tconnector->label = err ? NULL : kstrdup_const(label, GFP_KERNEL);\n\n\t \n\tswitch (connector->type) {\n\tcase V4L2_CONN_COMPOSITE:\n\tcase V4L2_CONN_SVIDEO:\n\t\tv4l2_fwnode_connector_parse_analog(connector_node, connector);\n\t\tbreak;\n\t \n\tcase V4L2_CONN_UNKNOWN:\n\t\tbreak;\n\t}\n\nout:\n\tfwnode_handle_put(connector_node);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(v4l2_fwnode_connector_parse);\n\nint v4l2_fwnode_connector_add_link(struct fwnode_handle *fwnode,\n\t\t\t\t   struct v4l2_fwnode_connector *connector)\n{\n\tstruct fwnode_handle *connector_ep;\n\tstruct v4l2_connector_link *link;\n\tint err;\n\n\tif (!fwnode || !connector || connector->type == V4L2_CONN_UNKNOWN)\n\t\treturn -EINVAL;\n\n\tconnector_ep = fwnode_graph_get_remote_endpoint(fwnode);\n\tif (!connector_ep)\n\t\treturn -ENOTCONN;\n\n\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\terr = v4l2_fwnode_parse_link(connector_ep, &link->fwnode_link);\n\tif (err)\n\t\tgoto err;\n\n\tfwnode_handle_put(connector_ep);\n\n\tlist_add(&link->head, &connector->links);\n\tconnector->nr_of_links++;\n\n\treturn 0;\n\nerr:\n\tkfree(link);\n\tfwnode_handle_put(connector_ep);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(v4l2_fwnode_connector_add_link);\n\nint v4l2_fwnode_device_parse(struct device *dev,\n\t\t\t     struct v4l2_fwnode_device_properties *props)\n{\n\tstruct fwnode_handle *fwnode = dev_fwnode(dev);\n\tu32 val;\n\tint ret;\n\n\tmemset(props, 0, sizeof(*props));\n\n\tprops->orientation = V4L2_FWNODE_PROPERTY_UNSET;\n\tret = fwnode_property_read_u32(fwnode, \"orientation\", &val);\n\tif (!ret) {\n\t\tswitch (val) {\n\t\tcase V4L2_FWNODE_ORIENTATION_FRONT:\n\t\tcase V4L2_FWNODE_ORIENTATION_BACK:\n\t\tcase V4L2_FWNODE_ORIENTATION_EXTERNAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(dev, \"Unsupported device orientation: %u\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tprops->orientation = val;\n\t\tdev_dbg(dev, \"device orientation: %u\\n\", val);\n\t}\n\n\tprops->rotation = V4L2_FWNODE_PROPERTY_UNSET;\n\tret = fwnode_property_read_u32(fwnode, \"rotation\", &val);\n\tif (!ret) {\n\t\tif (val >= 360) {\n\t\t\tdev_warn(dev, \"Unsupported device rotation: %u\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tprops->rotation = val;\n\t\tdev_dbg(dev, \"device rotation: %u\\n\", val);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(v4l2_fwnode_device_parse);\n\n \nstatic int v4l2_fwnode_reference_parse(struct device *dev,\n\t\t\t\t       struct v4l2_async_notifier *notifier,\n\t\t\t\t       const char *prop)\n{\n\tstruct fwnode_reference_args args;\n\tunsigned int index;\n\tint ret;\n\n\tfor (index = 0;\n\t     !(ret = fwnode_property_get_reference_args(dev_fwnode(dev), prop,\n\t\t\t\t\t\t\tNULL, 0, index, &args));\n\t     index++) {\n\t\tstruct v4l2_async_connection *asd;\n\n\t\tasd = v4l2_async_nf_add_fwnode(notifier, args.fwnode,\n\t\t\t\t\t       struct v4l2_async_connection);\n\t\tfwnode_handle_put(args.fwnode);\n\t\tif (IS_ERR(asd)) {\n\t\t\t \n\t\t\tif (PTR_ERR(asd) == -EEXIST)\n\t\t\t\tcontinue;\n\n\t\t\treturn PTR_ERR(asd);\n\t\t}\n\t}\n\n\t \n\tif (ret != -ENOENT)\n\t\treturn ret;\n\n\t \n\treturn index ? 0 : -ENOENT;\n}\n\n \nstatic struct fwnode_handle *\nv4l2_fwnode_reference_get_int_prop(struct fwnode_handle *fwnode,\n\t\t\t\t   const char *prop,\n\t\t\t\t   unsigned int index,\n\t\t\t\t   const char * const *props,\n\t\t\t\t   unsigned int nprops)\n{\n\tstruct fwnode_reference_args fwnode_args;\n\tu64 *args = fwnode_args.args;\n\tstruct fwnode_handle *child;\n\tint ret;\n\n\t \n\tret = fwnode_property_get_reference_args(fwnode, prop, NULL, nprops,\n\t\t\t\t\t\t index, &fwnode_args);\n\tif (ret)\n\t\treturn ERR_PTR(ret == -ENODATA ? -ENOENT : ret);\n\n\t \n\tfwnode = fwnode_args.fwnode;\n\twhile (nprops--) {\n\t\tu32 val;\n\n\t\t \n\t\tfwnode_for_each_child_node(fwnode, child) {\n\t\t\tif (fwnode_property_read_u32(child, *props, &val))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (val == *args)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfwnode_handle_put(fwnode);\n\n\t\t \n\t\tif (!child) {\n\t\t\tfwnode = ERR_PTR(-ENOENT);\n\t\t\tbreak;\n\t\t}\n\n\t\tprops++;\n\t\targs++;\n\t\tfwnode = child;\n\t}\n\n\treturn fwnode;\n}\n\nstruct v4l2_fwnode_int_props {\n\tconst char *name;\n\tconst char * const *props;\n\tunsigned int nprops;\n};\n\n \nstatic int\nv4l2_fwnode_reference_parse_int_props(struct device *dev,\n\t\t\t\t      struct v4l2_async_notifier *notifier,\n\t\t\t\t      const struct v4l2_fwnode_int_props *p)\n{\n\tstruct fwnode_handle *fwnode;\n\tunsigned int index;\n\tint ret;\n\tconst char *prop = p->name;\n\tconst char * const *props = p->props;\n\tunsigned int nprops = p->nprops;\n\n\tindex = 0;\n\tdo {\n\t\tfwnode = v4l2_fwnode_reference_get_int_prop(dev_fwnode(dev),\n\t\t\t\t\t\t\t    prop, index,\n\t\t\t\t\t\t\t    props, nprops);\n\t\tif (IS_ERR(fwnode)) {\n\t\t\t \n\t\t\tif (PTR_ERR(fwnode) != -ENOENT &&\n\t\t\t    PTR_ERR(fwnode) != -ENODATA)\n\t\t\t\treturn PTR_ERR(fwnode);\n\t\t\tbreak;\n\t\t}\n\t\tfwnode_handle_put(fwnode);\n\t\tindex++;\n\t} while (1);\n\n\tfor (index = 0;\n\t     !IS_ERR((fwnode = v4l2_fwnode_reference_get_int_prop(dev_fwnode(dev),\n\t\t\t\t\t\t\t\t  prop, index,\n\t\t\t\t\t\t\t\t  props,\n\t\t\t\t\t\t\t\t  nprops)));\n\t     index++) {\n\t\tstruct v4l2_async_connection *asd;\n\n\t\tasd = v4l2_async_nf_add_fwnode(notifier, fwnode,\n\t\t\t\t\t       struct v4l2_async_connection);\n\t\tfwnode_handle_put(fwnode);\n\t\tif (IS_ERR(asd)) {\n\t\t\tret = PTR_ERR(asd);\n\t\t\t \n\t\t\tif (ret == -EEXIST)\n\t\t\t\tcontinue;\n\n\t\t\treturn PTR_ERR(asd);\n\t\t}\n\t}\n\n\treturn !fwnode || PTR_ERR(fwnode) == -ENOENT ? 0 : PTR_ERR(fwnode);\n}\n\n \nstatic int\nv4l2_async_nf_parse_fwnode_sensor(struct device *dev,\n\t\t\t\t  struct v4l2_async_notifier *notifier)\n{\n\tstatic const char * const led_props[] = { \"led\" };\n\tstatic const struct v4l2_fwnode_int_props props[] = {\n\t\t{ \"flash-leds\", led_props, ARRAY_SIZE(led_props) },\n\t\t{ \"lens-focus\", NULL, 0 },\n\t};\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(props); i++) {\n\t\tint ret;\n\n\t\tif (props[i].props && is_acpi_node(dev_fwnode(dev)))\n\t\t\tret = v4l2_fwnode_reference_parse_int_props(dev,\n\t\t\t\t\t\t\t\t    notifier,\n\t\t\t\t\t\t\t\t    &props[i]);\n\t\telse\n\t\t\tret = v4l2_fwnode_reference_parse(dev, notifier,\n\t\t\t\t\t\t\t  props[i].name);\n\t\tif (ret && ret != -ENOENT) {\n\t\t\tdev_warn(dev, \"parsing property \\\"%s\\\" failed (%d)\\n\",\n\t\t\t\t props[i].name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint v4l2_async_register_subdev_sensor(struct v4l2_subdev *sd)\n{\n\tstruct v4l2_async_notifier *notifier;\n\tint ret;\n\n\tif (WARN_ON(!sd->dev))\n\t\treturn -ENODEV;\n\n\tnotifier = kzalloc(sizeof(*notifier), GFP_KERNEL);\n\tif (!notifier)\n\t\treturn -ENOMEM;\n\n\tv4l2_async_subdev_nf_init(notifier, sd);\n\n\tret = v4l2_subdev_get_privacy_led(sd);\n\tif (ret < 0)\n\t\tgoto out_cleanup;\n\n\tret = v4l2_async_nf_parse_fwnode_sensor(sd->dev, notifier);\n\tif (ret < 0)\n\t\tgoto out_cleanup;\n\n\tret = v4l2_async_nf_register(notifier);\n\tif (ret < 0)\n\t\tgoto out_cleanup;\n\n\tret = v4l2_async_register_subdev(sd);\n\tif (ret < 0)\n\t\tgoto out_unregister;\n\n\tsd->subdev_notifier = notifier;\n\n\treturn 0;\n\nout_unregister:\n\tv4l2_async_nf_unregister(notifier);\n\nout_cleanup:\n\tv4l2_subdev_put_privacy_led(sd);\n\tv4l2_async_nf_cleanup(notifier);\n\tkfree(notifier);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(v4l2_async_register_subdev_sensor);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Sakari Ailus <sakari.ailus@linux.intel.com>\");\nMODULE_AUTHOR(\"Sylwester Nawrocki <s.nawrocki@samsung.com>\");\nMODULE_AUTHOR(\"Guennadi Liakhovetski <g.liakhovetski@gmx.de>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}