{
  "module_name": "v4l2-compat-ioctl32.c",
  "hash_id": "f20e2fe78eac6b9421547cf988020088ed63b78c78033b4f3b0663fbf2d60b20",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/v4l2-compat-ioctl32.c",
  "human_readable_source": "\n \n\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/videodev2.h>\n#include <linux/v4l2-subdev.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-ioctl.h>\n\n \n\nstruct v4l2_window32 {\n\tstruct v4l2_rect        w;\n\t__u32\t\t\tfield;\t \n\t__u32\t\t\tchromakey;\n\tcompat_caddr_t\t\tclips;  \n\t__u32\t\t\tclipcount;  \n\tcompat_caddr_t\t\tbitmap;  \n\t__u8                    global_alpha;\n};\n\nstatic int get_v4l2_window32(struct v4l2_window *p64,\n\t\t\t     struct v4l2_window32 __user *p32)\n{\n\tstruct v4l2_window32 w32;\n\n\tif (copy_from_user(&w32, p32, sizeof(w32)))\n\t\treturn -EFAULT;\n\n\t*p64 = (struct v4l2_window) {\n\t\t.w\t\t= w32.w,\n\t\t.field\t\t= w32.field,\n\t\t.chromakey\t= w32.chromakey,\n\t\t.clips\t\t= NULL,\n\t\t.clipcount\t= 0,\n\t\t.bitmap\t\t= NULL,\n\t\t.global_alpha\t= w32.global_alpha,\n\t};\n\n\treturn 0;\n}\n\nstatic int put_v4l2_window32(struct v4l2_window *p64,\n\t\t\t     struct v4l2_window32 __user *p32)\n{\n\tstruct v4l2_window32 w32;\n\n\tmemset(&w32, 0, sizeof(w32));\n\tw32 = (struct v4l2_window32) {\n\t\t.w\t\t= p64->w,\n\t\t.field\t\t= p64->field,\n\t\t.chromakey\t= p64->chromakey,\n\t\t.clips\t\t= 0,\n\t\t.clipcount\t= 0,\n\t\t.bitmap\t\t= 0,\n\t\t.global_alpha\t= p64->global_alpha,\n\t};\n\n\tif (copy_to_user(p32, &w32, sizeof(w32)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstruct v4l2_format32 {\n\t__u32\ttype;\t \n\tunion {\n\t\tstruct v4l2_pix_format\tpix;\n\t\tstruct v4l2_pix_format_mplane\tpix_mp;\n\t\tstruct v4l2_window32\twin;\n\t\tstruct v4l2_vbi_format\tvbi;\n\t\tstruct v4l2_sliced_vbi_format\tsliced;\n\t\tstruct v4l2_sdr_format\tsdr;\n\t\tstruct v4l2_meta_format\tmeta;\n\t\t__u8\traw_data[200];         \n\t} fmt;\n};\n\n \nstruct v4l2_create_buffers32 {\n\t__u32\t\t\tindex;\n\t__u32\t\t\tcount;\n\t__u32\t\t\tmemory;\t \n\tstruct v4l2_format32\tformat;\n\t__u32\t\t\tcapabilities;\n\t__u32\t\t\tflags;\n\t__u32\t\t\treserved[6];\n};\n\nstatic int get_v4l2_format32(struct v4l2_format *p64,\n\t\t\t     struct v4l2_format32 __user *p32)\n{\n\tif (get_user(p64->type, &p32->type))\n\t\treturn -EFAULT;\n\n\tswitch (p64->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\treturn copy_from_user(&p64->fmt.pix, &p32->fmt.pix,\n\t\t\t\t      sizeof(p64->fmt.pix)) ? -EFAULT : 0;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\treturn copy_from_user(&p64->fmt.pix_mp, &p32->fmt.pix_mp,\n\t\t\t\t      sizeof(p64->fmt.pix_mp)) ? -EFAULT : 0;\n\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\n\t\treturn get_v4l2_window32(&p64->fmt.win, &p32->fmt.win);\n\tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n\tcase V4L2_BUF_TYPE_VBI_OUTPUT:\n\t\treturn copy_from_user(&p64->fmt.vbi, &p32->fmt.vbi,\n\t\t\t\t      sizeof(p64->fmt.vbi)) ? -EFAULT : 0;\n\tcase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\n\tcase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\n\t\treturn copy_from_user(&p64->fmt.sliced, &p32->fmt.sliced,\n\t\t\t\t      sizeof(p64->fmt.sliced)) ? -EFAULT : 0;\n\tcase V4L2_BUF_TYPE_SDR_CAPTURE:\n\tcase V4L2_BUF_TYPE_SDR_OUTPUT:\n\t\treturn copy_from_user(&p64->fmt.sdr, &p32->fmt.sdr,\n\t\t\t\t      sizeof(p64->fmt.sdr)) ? -EFAULT : 0;\n\tcase V4L2_BUF_TYPE_META_CAPTURE:\n\tcase V4L2_BUF_TYPE_META_OUTPUT:\n\t\treturn copy_from_user(&p64->fmt.meta, &p32->fmt.meta,\n\t\t\t\t      sizeof(p64->fmt.meta)) ? -EFAULT : 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int get_v4l2_create32(struct v4l2_create_buffers *p64,\n\t\t\t     struct v4l2_create_buffers32 __user *p32)\n{\n\tif (copy_from_user(p64, p32,\n\t\t\t   offsetof(struct v4l2_create_buffers32, format)))\n\t\treturn -EFAULT;\n\tif (copy_from_user(&p64->flags, &p32->flags, sizeof(p32->flags)))\n\t\treturn -EFAULT;\n\treturn get_v4l2_format32(&p64->format, &p32->format);\n}\n\nstatic int put_v4l2_format32(struct v4l2_format *p64,\n\t\t\t     struct v4l2_format32 __user *p32)\n{\n\tswitch (p64->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\treturn copy_to_user(&p32->fmt.pix, &p64->fmt.pix,\n\t\t\t\t    sizeof(p64->fmt.pix)) ? -EFAULT : 0;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\treturn copy_to_user(&p32->fmt.pix_mp, &p64->fmt.pix_mp,\n\t\t\t\t    sizeof(p64->fmt.pix_mp)) ? -EFAULT : 0;\n\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\n\t\treturn put_v4l2_window32(&p64->fmt.win, &p32->fmt.win);\n\tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n\tcase V4L2_BUF_TYPE_VBI_OUTPUT:\n\t\treturn copy_to_user(&p32->fmt.vbi, &p64->fmt.vbi,\n\t\t\t\t    sizeof(p64->fmt.vbi)) ? -EFAULT : 0;\n\tcase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\n\tcase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\n\t\treturn copy_to_user(&p32->fmt.sliced, &p64->fmt.sliced,\n\t\t\t\t    sizeof(p64->fmt.sliced)) ? -EFAULT : 0;\n\tcase V4L2_BUF_TYPE_SDR_CAPTURE:\n\tcase V4L2_BUF_TYPE_SDR_OUTPUT:\n\t\treturn copy_to_user(&p32->fmt.sdr, &p64->fmt.sdr,\n\t\t\t\t    sizeof(p64->fmt.sdr)) ? -EFAULT : 0;\n\tcase V4L2_BUF_TYPE_META_CAPTURE:\n\tcase V4L2_BUF_TYPE_META_OUTPUT:\n\t\treturn copy_to_user(&p32->fmt.meta, &p64->fmt.meta,\n\t\t\t\t    sizeof(p64->fmt.meta)) ? -EFAULT : 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int put_v4l2_create32(struct v4l2_create_buffers *p64,\n\t\t\t     struct v4l2_create_buffers32 __user *p32)\n{\n\tif (copy_to_user(p32, p64,\n\t\t\t offsetof(struct v4l2_create_buffers32, format)) ||\n\t    put_user(p64->capabilities, &p32->capabilities) ||\n\t    put_user(p64->flags, &p32->flags) ||\n\t    copy_to_user(p32->reserved, p64->reserved, sizeof(p64->reserved)))\n\t\treturn -EFAULT;\n\treturn put_v4l2_format32(&p64->format, &p32->format);\n}\n\nstruct v4l2_standard32 {\n\t__u32\t\t     index;\n\tcompat_u64\t     id;\n\t__u8\t\t     name[24];\n\tstruct v4l2_fract    frameperiod;  \n\t__u32\t\t     framelines;\n\t__u32\t\t     reserved[4];\n};\n\nstatic int get_v4l2_standard32(struct v4l2_standard *p64,\n\t\t\t       struct v4l2_standard32 __user *p32)\n{\n\t \n\treturn get_user(p64->index, &p32->index);\n}\n\nstatic int put_v4l2_standard32(struct v4l2_standard *p64,\n\t\t\t       struct v4l2_standard32 __user *p32)\n{\n\tif (put_user(p64->index, &p32->index) ||\n\t    put_user(p64->id, &p32->id) ||\n\t    copy_to_user(p32->name, p64->name, sizeof(p32->name)) ||\n\t    copy_to_user(&p32->frameperiod, &p64->frameperiod,\n\t\t\t sizeof(p32->frameperiod)) ||\n\t    put_user(p64->framelines, &p32->framelines) ||\n\t    copy_to_user(p32->reserved, p64->reserved, sizeof(p32->reserved)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstruct v4l2_plane32 {\n\t__u32\t\t\tbytesused;\n\t__u32\t\t\tlength;\n\tunion {\n\t\t__u32\t\tmem_offset;\n\t\tcompat_long_t\tuserptr;\n\t\t__s32\t\tfd;\n\t} m;\n\t__u32\t\t\tdata_offset;\n\t__u32\t\t\treserved[11];\n};\n\n \nstruct v4l2_buffer32 {\n\t__u32\t\t\tindex;\n\t__u32\t\t\ttype;\t \n\t__u32\t\t\tbytesused;\n\t__u32\t\t\tflags;\n\t__u32\t\t\tfield;\t \n\tstruct {\n\t\tcompat_s64\ttv_sec;\n\t\tcompat_s64\ttv_usec;\n\t}\t\t\ttimestamp;\n\tstruct v4l2_timecode\ttimecode;\n\t__u32\t\t\tsequence;\n\n\t \n\t__u32\t\t\tmemory;\t \n\tunion {\n\t\t__u32           offset;\n\t\tcompat_long_t   userptr;\n\t\tcompat_caddr_t  planes;\n\t\t__s32\t\tfd;\n\t} m;\n\t__u32\t\t\tlength;\n\t__u32\t\t\treserved2;\n\t__s32\t\t\trequest_fd;\n};\n\n#ifdef CONFIG_COMPAT_32BIT_TIME\nstruct v4l2_buffer32_time32 {\n\t__u32\t\t\tindex;\n\t__u32\t\t\ttype;\t \n\t__u32\t\t\tbytesused;\n\t__u32\t\t\tflags;\n\t__u32\t\t\tfield;\t \n\tstruct old_timeval32\ttimestamp;\n\tstruct v4l2_timecode\ttimecode;\n\t__u32\t\t\tsequence;\n\n\t \n\t__u32\t\t\tmemory;\t \n\tunion {\n\t\t__u32           offset;\n\t\tcompat_long_t   userptr;\n\t\tcompat_caddr_t  planes;\n\t\t__s32\t\tfd;\n\t} m;\n\t__u32\t\t\tlength;\n\t__u32\t\t\treserved2;\n\t__s32\t\t\trequest_fd;\n};\n#endif\n\nstatic int get_v4l2_plane32(struct v4l2_plane *p64,\n\t\t\t    struct v4l2_plane32 __user *p32,\n\t\t\t    enum v4l2_memory memory)\n{\n\tstruct v4l2_plane32 plane32;\n\ttypeof(p64->m) m = {};\n\n\tif (copy_from_user(&plane32, p32, sizeof(plane32)))\n\t\treturn -EFAULT;\n\n\tswitch (memory) {\n\tcase V4L2_MEMORY_MMAP:\n\tcase V4L2_MEMORY_OVERLAY:\n\t\tm.mem_offset = plane32.m.mem_offset;\n\t\tbreak;\n\tcase V4L2_MEMORY_USERPTR:\n\t\tm.userptr = (unsigned long)compat_ptr(plane32.m.userptr);\n\t\tbreak;\n\tcase V4L2_MEMORY_DMABUF:\n\t\tm.fd = plane32.m.fd;\n\t\tbreak;\n\t}\n\n\tmemset(p64, 0, sizeof(*p64));\n\t*p64 = (struct v4l2_plane) {\n\t\t.bytesused\t= plane32.bytesused,\n\t\t.length\t\t= plane32.length,\n\t\t.m\t\t= m,\n\t\t.data_offset\t= plane32.data_offset,\n\t};\n\n\treturn 0;\n}\n\nstatic int put_v4l2_plane32(struct v4l2_plane *p64,\n\t\t\t    struct v4l2_plane32 __user *p32,\n\t\t\t    enum v4l2_memory memory)\n{\n\tstruct v4l2_plane32 plane32;\n\n\tmemset(&plane32, 0, sizeof(plane32));\n\tplane32 = (struct v4l2_plane32) {\n\t\t.bytesused\t= p64->bytesused,\n\t\t.length\t\t= p64->length,\n\t\t.data_offset\t= p64->data_offset,\n\t};\n\n\tswitch (memory) {\n\tcase V4L2_MEMORY_MMAP:\n\tcase V4L2_MEMORY_OVERLAY:\n\t\tplane32.m.mem_offset = p64->m.mem_offset;\n\t\tbreak;\n\tcase V4L2_MEMORY_USERPTR:\n\t\tplane32.m.userptr = (uintptr_t)(p64->m.userptr);\n\t\tbreak;\n\tcase V4L2_MEMORY_DMABUF:\n\t\tplane32.m.fd = p64->m.fd;\n\t\tbreak;\n\t}\n\n\tif (copy_to_user(p32, &plane32, sizeof(plane32)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int get_v4l2_buffer32(struct v4l2_buffer *vb,\n\t\t\t     struct v4l2_buffer32 __user *arg)\n{\n\tstruct v4l2_buffer32 vb32;\n\n\tif (copy_from_user(&vb32, arg, sizeof(vb32)))\n\t\treturn -EFAULT;\n\n\tmemset(vb, 0, sizeof(*vb));\n\t*vb = (struct v4l2_buffer) {\n\t\t.index\t\t= vb32.index,\n\t\t.type\t\t= vb32.type,\n\t\t.bytesused\t= vb32.bytesused,\n\t\t.flags\t\t= vb32.flags,\n\t\t.field\t\t= vb32.field,\n\t\t.timestamp.tv_sec\t= vb32.timestamp.tv_sec,\n\t\t.timestamp.tv_usec\t= vb32.timestamp.tv_usec,\n\t\t.timecode\t= vb32.timecode,\n\t\t.sequence\t= vb32.sequence,\n\t\t.memory\t\t= vb32.memory,\n\t\t.m.offset\t= vb32.m.offset,\n\t\t.length\t\t= vb32.length,\n\t\t.request_fd\t= vb32.request_fd,\n\t};\n\n\tswitch (vb->memory) {\n\tcase V4L2_MEMORY_MMAP:\n\tcase V4L2_MEMORY_OVERLAY:\n\t\tvb->m.offset = vb32.m.offset;\n\t\tbreak;\n\tcase V4L2_MEMORY_USERPTR:\n\t\tvb->m.userptr = (unsigned long)compat_ptr(vb32.m.userptr);\n\t\tbreak;\n\tcase V4L2_MEMORY_DMABUF:\n\t\tvb->m.fd = vb32.m.fd;\n\t\tbreak;\n\t}\n\n\tif (V4L2_TYPE_IS_MULTIPLANAR(vb->type))\n\t\tvb->m.planes = (void __force *)\n\t\t\t\tcompat_ptr(vb32.m.planes);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_COMPAT_32BIT_TIME\nstatic int get_v4l2_buffer32_time32(struct v4l2_buffer *vb,\n\t\t\t\t    struct v4l2_buffer32_time32 __user *arg)\n{\n\tstruct v4l2_buffer32_time32 vb32;\n\n\tif (copy_from_user(&vb32, arg, sizeof(vb32)))\n\t\treturn -EFAULT;\n\n\t*vb = (struct v4l2_buffer) {\n\t\t.index\t\t= vb32.index,\n\t\t.type\t\t= vb32.type,\n\t\t.bytesused\t= vb32.bytesused,\n\t\t.flags\t\t= vb32.flags,\n\t\t.field\t\t= vb32.field,\n\t\t.timestamp.tv_sec\t= vb32.timestamp.tv_sec,\n\t\t.timestamp.tv_usec\t= vb32.timestamp.tv_usec,\n\t\t.timecode\t= vb32.timecode,\n\t\t.sequence\t= vb32.sequence,\n\t\t.memory\t\t= vb32.memory,\n\t\t.m.offset\t= vb32.m.offset,\n\t\t.length\t\t= vb32.length,\n\t\t.request_fd\t= vb32.request_fd,\n\t};\n\tswitch (vb->memory) {\n\tcase V4L2_MEMORY_MMAP:\n\tcase V4L2_MEMORY_OVERLAY:\n\t\tvb->m.offset = vb32.m.offset;\n\t\tbreak;\n\tcase V4L2_MEMORY_USERPTR:\n\t\tvb->m.userptr = (unsigned long)compat_ptr(vb32.m.userptr);\n\t\tbreak;\n\tcase V4L2_MEMORY_DMABUF:\n\t\tvb->m.fd = vb32.m.fd;\n\t\tbreak;\n\t}\n\n\tif (V4L2_TYPE_IS_MULTIPLANAR(vb->type))\n\t\tvb->m.planes = (void __force *)\n\t\t\t\tcompat_ptr(vb32.m.planes);\n\n\treturn 0;\n}\n#endif\n\nstatic int put_v4l2_buffer32(struct v4l2_buffer *vb,\n\t\t\t     struct v4l2_buffer32 __user *arg)\n{\n\tstruct v4l2_buffer32 vb32;\n\n\tmemset(&vb32, 0, sizeof(vb32));\n\tvb32 = (struct v4l2_buffer32) {\n\t\t.index\t\t= vb->index,\n\t\t.type\t\t= vb->type,\n\t\t.bytesused\t= vb->bytesused,\n\t\t.flags\t\t= vb->flags,\n\t\t.field\t\t= vb->field,\n\t\t.timestamp.tv_sec\t= vb->timestamp.tv_sec,\n\t\t.timestamp.tv_usec\t= vb->timestamp.tv_usec,\n\t\t.timecode\t= vb->timecode,\n\t\t.sequence\t= vb->sequence,\n\t\t.memory\t\t= vb->memory,\n\t\t.m.offset\t= vb->m.offset,\n\t\t.length\t\t= vb->length,\n\t\t.request_fd\t= vb->request_fd,\n\t};\n\n\tswitch (vb->memory) {\n\tcase V4L2_MEMORY_MMAP:\n\tcase V4L2_MEMORY_OVERLAY:\n\t\tvb32.m.offset = vb->m.offset;\n\t\tbreak;\n\tcase V4L2_MEMORY_USERPTR:\n\t\tvb32.m.userptr = (uintptr_t)(vb->m.userptr);\n\t\tbreak;\n\tcase V4L2_MEMORY_DMABUF:\n\t\tvb32.m.fd = vb->m.fd;\n\t\tbreak;\n\t}\n\n\tif (V4L2_TYPE_IS_MULTIPLANAR(vb->type))\n\t\tvb32.m.planes = (uintptr_t)vb->m.planes;\n\n\tif (copy_to_user(arg, &vb32, sizeof(vb32)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_COMPAT_32BIT_TIME\nstatic int put_v4l2_buffer32_time32(struct v4l2_buffer *vb,\n\t\t\t\t    struct v4l2_buffer32_time32 __user *arg)\n{\n\tstruct v4l2_buffer32_time32 vb32;\n\n\tmemset(&vb32, 0, sizeof(vb32));\n\tvb32 = (struct v4l2_buffer32_time32) {\n\t\t.index\t\t= vb->index,\n\t\t.type\t\t= vb->type,\n\t\t.bytesused\t= vb->bytesused,\n\t\t.flags\t\t= vb->flags,\n\t\t.field\t\t= vb->field,\n\t\t.timestamp.tv_sec\t= vb->timestamp.tv_sec,\n\t\t.timestamp.tv_usec\t= vb->timestamp.tv_usec,\n\t\t.timecode\t= vb->timecode,\n\t\t.sequence\t= vb->sequence,\n\t\t.memory\t\t= vb->memory,\n\t\t.m.offset\t= vb->m.offset,\n\t\t.length\t\t= vb->length,\n\t\t.request_fd\t= vb->request_fd,\n\t};\n\tswitch (vb->memory) {\n\tcase V4L2_MEMORY_MMAP:\n\tcase V4L2_MEMORY_OVERLAY:\n\t\tvb32.m.offset = vb->m.offset;\n\t\tbreak;\n\tcase V4L2_MEMORY_USERPTR:\n\t\tvb32.m.userptr = (uintptr_t)(vb->m.userptr);\n\t\tbreak;\n\tcase V4L2_MEMORY_DMABUF:\n\t\tvb32.m.fd = vb->m.fd;\n\t\tbreak;\n\t}\n\n\tif (V4L2_TYPE_IS_MULTIPLANAR(vb->type))\n\t\tvb32.m.planes = (uintptr_t)vb->m.planes;\n\n\tif (copy_to_user(arg, &vb32, sizeof(vb32)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n#endif\n\nstruct v4l2_framebuffer32 {\n\t__u32\t\t\tcapability;\n\t__u32\t\t\tflags;\n\tcompat_caddr_t\t\tbase;\n\tstruct {\n\t\t__u32\t\twidth;\n\t\t__u32\t\theight;\n\t\t__u32\t\tpixelformat;\n\t\t__u32\t\tfield;\n\t\t__u32\t\tbytesperline;\n\t\t__u32\t\tsizeimage;\n\t\t__u32\t\tcolorspace;\n\t\t__u32\t\tpriv;\n\t} fmt;\n};\n\nstatic int get_v4l2_framebuffer32(struct v4l2_framebuffer *p64,\n\t\t\t\t  struct v4l2_framebuffer32 __user *p32)\n{\n\tif (get_user(p64->capability, &p32->capability) ||\n\t    get_user(p64->flags, &p32->flags) ||\n\t    copy_from_user(&p64->fmt, &p32->fmt, sizeof(p64->fmt)))\n\t\treturn -EFAULT;\n\tp64->base = NULL;\n\n\treturn 0;\n}\n\nstatic int put_v4l2_framebuffer32(struct v4l2_framebuffer *p64,\n\t\t\t\t  struct v4l2_framebuffer32 __user *p32)\n{\n\tif (put_user((uintptr_t)p64->base, &p32->base) ||\n\t    put_user(p64->capability, &p32->capability) ||\n\t    put_user(p64->flags, &p32->flags) ||\n\t    copy_to_user(&p32->fmt, &p64->fmt, sizeof(p64->fmt)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstruct v4l2_input32 {\n\t__u32\t     index;\t\t \n\t__u8\t     name[32];\t\t \n\t__u32\t     type;\t\t \n\t__u32\t     audioset;\t\t \n\t__u32        tuner;              \n\tcompat_u64   std;\n\t__u32\t     status;\n\t__u32\t     capabilities;\n\t__u32\t     reserved[3];\n};\n\n \nstatic inline int get_v4l2_input32(struct v4l2_input *p64,\n\t\t\t\t   struct v4l2_input32 __user *p32)\n{\n\tif (copy_from_user(p64, p32, sizeof(*p32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic inline int put_v4l2_input32(struct v4l2_input *p64,\n\t\t\t\t   struct v4l2_input32 __user *p32)\n{\n\tif (copy_to_user(p32, p64, sizeof(*p32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstruct v4l2_ext_controls32 {\n\t__u32 which;\n\t__u32 count;\n\t__u32 error_idx;\n\t__s32 request_fd;\n\t__u32 reserved[1];\n\tcompat_caddr_t controls;  \n};\n\nstruct v4l2_ext_control32 {\n\t__u32 id;\n\t__u32 size;\n\t__u32 reserved2[1];\n\tunion {\n\t\t__s32 value;\n\t\t__s64 value64;\n\t\tcompat_caddr_t string;  \n\t};\n} __attribute__ ((packed));\n\n \nstatic inline bool ctrl_is_pointer(struct file *file, u32 id)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct v4l2_fh *fh = NULL;\n\tstruct v4l2_ctrl_handler *hdl = NULL;\n\tstruct v4l2_query_ext_ctrl qec = { id };\n\tconst struct v4l2_ioctl_ops *ops = vdev->ioctl_ops;\n\n\tif (test_bit(V4L2_FL_USES_V4L2_FH, &vdev->flags))\n\t\tfh = file->private_data;\n\n\tif (fh && fh->ctrl_handler)\n\t\thdl = fh->ctrl_handler;\n\telse if (vdev->ctrl_handler)\n\t\thdl = vdev->ctrl_handler;\n\n\tif (hdl) {\n\t\tstruct v4l2_ctrl *ctrl = v4l2_ctrl_find(hdl, id);\n\n\t\treturn ctrl && ctrl->is_ptr;\n\t}\n\n\tif (!ops || !ops->vidioc_query_ext_ctrl)\n\t\treturn false;\n\n\treturn !ops->vidioc_query_ext_ctrl(file, fh, &qec) &&\n\t\t(qec.flags & V4L2_CTRL_FLAG_HAS_PAYLOAD);\n}\n\nstatic int get_v4l2_ext_controls32(struct v4l2_ext_controls *p64,\n\t\t\t\t   struct v4l2_ext_controls32 __user *p32)\n{\n\tstruct v4l2_ext_controls32 ec32;\n\n\tif (copy_from_user(&ec32, p32, sizeof(ec32)))\n\t\treturn -EFAULT;\n\n\t*p64 = (struct v4l2_ext_controls) {\n\t\t.which\t\t= ec32.which,\n\t\t.count\t\t= ec32.count,\n\t\t.error_idx\t= ec32.error_idx,\n\t\t.request_fd\t= ec32.request_fd,\n\t\t.reserved[0]\t= ec32.reserved[0],\n\t\t.controls\t= (void __force *)compat_ptr(ec32.controls),\n\t};\n\n\treturn 0;\n}\n\nstatic int put_v4l2_ext_controls32(struct v4l2_ext_controls *p64,\n\t\t\t\t   struct v4l2_ext_controls32 __user *p32)\n{\n\tstruct v4l2_ext_controls32 ec32;\n\n\tmemset(&ec32, 0, sizeof(ec32));\n\tec32 = (struct v4l2_ext_controls32) {\n\t\t.which\t\t= p64->which,\n\t\t.count\t\t= p64->count,\n\t\t.error_idx\t= p64->error_idx,\n\t\t.request_fd\t= p64->request_fd,\n\t\t.reserved[0]\t= p64->reserved[0],\n\t\t.controls\t= (uintptr_t)p64->controls,\n\t};\n\n\tif (copy_to_user(p32, &ec32, sizeof(ec32)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_X86_64\n \nstruct v4l2_event32 {\n\t__u32\t\t\t\ttype;\n\tunion {\n\t\tcompat_s64\t\tvalue64;\n\t\t__u8\t\t\tdata[64];\n\t} u;\n\t__u32\t\t\t\tpending;\n\t__u32\t\t\t\tsequence;\n\tstruct {\n\t\tcompat_s64\t\ttv_sec;\n\t\tcompat_s64\t\ttv_nsec;\n\t} timestamp;\n\t__u32\t\t\t\tid;\n\t__u32\t\t\t\treserved[8];\n};\n\nstatic int put_v4l2_event32(struct v4l2_event *p64,\n\t\t\t    struct v4l2_event32 __user *p32)\n{\n\tif (put_user(p64->type, &p32->type) ||\n\t    copy_to_user(&p32->u, &p64->u, sizeof(p64->u)) ||\n\t    put_user(p64->pending, &p32->pending) ||\n\t    put_user(p64->sequence, &p32->sequence) ||\n\t    put_user(p64->timestamp.tv_sec, &p32->timestamp.tv_sec) ||\n\t    put_user(p64->timestamp.tv_nsec, &p32->timestamp.tv_nsec) ||\n\t    put_user(p64->id, &p32->id) ||\n\t    copy_to_user(p32->reserved, p64->reserved, sizeof(p32->reserved)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n#endif\n\n#ifdef CONFIG_COMPAT_32BIT_TIME\nstruct v4l2_event32_time32 {\n\t__u32\t\t\t\ttype;\n\tunion {\n\t\tcompat_s64\t\tvalue64;\n\t\t__u8\t\t\tdata[64];\n\t} u;\n\t__u32\t\t\t\tpending;\n\t__u32\t\t\t\tsequence;\n\tstruct old_timespec32\t\ttimestamp;\n\t__u32\t\t\t\tid;\n\t__u32\t\t\t\treserved[8];\n};\n\nstatic int put_v4l2_event32_time32(struct v4l2_event *p64,\n\t\t\t\t   struct v4l2_event32_time32 __user *p32)\n{\n\tif (put_user(p64->type, &p32->type) ||\n\t    copy_to_user(&p32->u, &p64->u, sizeof(p64->u)) ||\n\t    put_user(p64->pending, &p32->pending) ||\n\t    put_user(p64->sequence, &p32->sequence) ||\n\t    put_user(p64->timestamp.tv_sec, &p32->timestamp.tv_sec) ||\n\t    put_user(p64->timestamp.tv_nsec, &p32->timestamp.tv_nsec) ||\n\t    put_user(p64->id, &p32->id) ||\n\t    copy_to_user(p32->reserved, p64->reserved, sizeof(p32->reserved)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n#endif\n\nstruct v4l2_edid32 {\n\t__u32 pad;\n\t__u32 start_block;\n\t__u32 blocks;\n\t__u32 reserved[5];\n\tcompat_caddr_t edid;\n};\n\nstatic int get_v4l2_edid32(struct v4l2_edid *p64,\n\t\t\t   struct v4l2_edid32 __user *p32)\n{\n\tcompat_uptr_t edid;\n\n\tif (copy_from_user(p64, p32, offsetof(struct v4l2_edid32, edid)) ||\n\t    get_user(edid, &p32->edid))\n\t\treturn -EFAULT;\n\n\tp64->edid = (void __force *)compat_ptr(edid);\n\treturn 0;\n}\n\nstatic int put_v4l2_edid32(struct v4l2_edid *p64,\n\t\t\t   struct v4l2_edid32 __user *p32)\n{\n\tif (copy_to_user(p32, p64, offsetof(struct v4l2_edid32, edid)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \n\n#define VIDIOC_G_FMT32\t\t_IOWR('V',  4, struct v4l2_format32)\n#define VIDIOC_S_FMT32\t\t_IOWR('V',  5, struct v4l2_format32)\n#define VIDIOC_QUERYBUF32\t_IOWR('V',  9, struct v4l2_buffer32)\n#define VIDIOC_G_FBUF32\t\t_IOR ('V', 10, struct v4l2_framebuffer32)\n#define VIDIOC_S_FBUF32\t\t_IOW ('V', 11, struct v4l2_framebuffer32)\n#define VIDIOC_QBUF32\t\t_IOWR('V', 15, struct v4l2_buffer32)\n#define VIDIOC_DQBUF32\t\t_IOWR('V', 17, struct v4l2_buffer32)\n#define VIDIOC_ENUMSTD32\t_IOWR('V', 25, struct v4l2_standard32)\n#define VIDIOC_ENUMINPUT32\t_IOWR('V', 26, struct v4l2_input32)\n#define VIDIOC_G_EDID32\t\t_IOWR('V', 40, struct v4l2_edid32)\n#define VIDIOC_S_EDID32\t\t_IOWR('V', 41, struct v4l2_edid32)\n#define VIDIOC_TRY_FMT32\t_IOWR('V', 64, struct v4l2_format32)\n#define VIDIOC_G_EXT_CTRLS32    _IOWR('V', 71, struct v4l2_ext_controls32)\n#define VIDIOC_S_EXT_CTRLS32    _IOWR('V', 72, struct v4l2_ext_controls32)\n#define VIDIOC_TRY_EXT_CTRLS32  _IOWR('V', 73, struct v4l2_ext_controls32)\n#define\tVIDIOC_DQEVENT32\t_IOR ('V', 89, struct v4l2_event32)\n#define VIDIOC_CREATE_BUFS32\t_IOWR('V', 92, struct v4l2_create_buffers32)\n#define VIDIOC_PREPARE_BUF32\t_IOWR('V', 93, struct v4l2_buffer32)\n\n#ifdef CONFIG_COMPAT_32BIT_TIME\n#define VIDIOC_QUERYBUF32_TIME32\t_IOWR('V',  9, struct v4l2_buffer32_time32)\n#define VIDIOC_QBUF32_TIME32\t\t_IOWR('V', 15, struct v4l2_buffer32_time32)\n#define VIDIOC_DQBUF32_TIME32\t\t_IOWR('V', 17, struct v4l2_buffer32_time32)\n#define\tVIDIOC_DQEVENT32_TIME32\t\t_IOR ('V', 89, struct v4l2_event32_time32)\n#define VIDIOC_PREPARE_BUF32_TIME32\t_IOWR('V', 93, struct v4l2_buffer32_time32)\n#endif\n\nunsigned int v4l2_compat_translate_cmd(unsigned int cmd)\n{\n\tswitch (cmd) {\n\tcase VIDIOC_G_FMT32:\n\t\treturn VIDIOC_G_FMT;\n\tcase VIDIOC_S_FMT32:\n\t\treturn VIDIOC_S_FMT;\n\tcase VIDIOC_TRY_FMT32:\n\t\treturn VIDIOC_TRY_FMT;\n\tcase VIDIOC_G_FBUF32:\n\t\treturn VIDIOC_G_FBUF;\n\tcase VIDIOC_S_FBUF32:\n\t\treturn VIDIOC_S_FBUF;\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase VIDIOC_QUERYBUF32_TIME32:\n\t\treturn VIDIOC_QUERYBUF;\n\tcase VIDIOC_QBUF32_TIME32:\n\t\treturn VIDIOC_QBUF;\n\tcase VIDIOC_DQBUF32_TIME32:\n\t\treturn VIDIOC_DQBUF;\n\tcase VIDIOC_PREPARE_BUF32_TIME32:\n\t\treturn VIDIOC_PREPARE_BUF;\n#endif\n\tcase VIDIOC_QUERYBUF32:\n\t\treturn VIDIOC_QUERYBUF;\n\tcase VIDIOC_QBUF32:\n\t\treturn VIDIOC_QBUF;\n\tcase VIDIOC_DQBUF32:\n\t\treturn VIDIOC_DQBUF;\n\tcase VIDIOC_CREATE_BUFS32:\n\t\treturn VIDIOC_CREATE_BUFS;\n\tcase VIDIOC_G_EXT_CTRLS32:\n\t\treturn VIDIOC_G_EXT_CTRLS;\n\tcase VIDIOC_S_EXT_CTRLS32:\n\t\treturn VIDIOC_S_EXT_CTRLS;\n\tcase VIDIOC_TRY_EXT_CTRLS32:\n\t\treturn VIDIOC_TRY_EXT_CTRLS;\n\tcase VIDIOC_PREPARE_BUF32:\n\t\treturn VIDIOC_PREPARE_BUF;\n\tcase VIDIOC_ENUMSTD32:\n\t\treturn VIDIOC_ENUMSTD;\n\tcase VIDIOC_ENUMINPUT32:\n\t\treturn VIDIOC_ENUMINPUT;\n\tcase VIDIOC_G_EDID32:\n\t\treturn VIDIOC_G_EDID;\n\tcase VIDIOC_S_EDID32:\n\t\treturn VIDIOC_S_EDID;\n#ifdef CONFIG_X86_64\n\tcase VIDIOC_DQEVENT32:\n\t\treturn VIDIOC_DQEVENT;\n#endif\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase VIDIOC_DQEVENT32_TIME32:\n\t\treturn VIDIOC_DQEVENT;\n#endif\n\t}\n\treturn cmd;\n}\n\nint v4l2_compat_get_user(void __user *arg, void *parg, unsigned int cmd)\n{\n\tswitch (cmd) {\n\tcase VIDIOC_G_FMT32:\n\tcase VIDIOC_S_FMT32:\n\tcase VIDIOC_TRY_FMT32:\n\t\treturn get_v4l2_format32(parg, arg);\n\n\tcase VIDIOC_S_FBUF32:\n\t\treturn get_v4l2_framebuffer32(parg, arg);\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase VIDIOC_QUERYBUF32_TIME32:\n\tcase VIDIOC_QBUF32_TIME32:\n\tcase VIDIOC_DQBUF32_TIME32:\n\tcase VIDIOC_PREPARE_BUF32_TIME32:\n\t\treturn get_v4l2_buffer32_time32(parg, arg);\n#endif\n\tcase VIDIOC_QUERYBUF32:\n\tcase VIDIOC_QBUF32:\n\tcase VIDIOC_DQBUF32:\n\tcase VIDIOC_PREPARE_BUF32:\n\t\treturn get_v4l2_buffer32(parg, arg);\n\n\tcase VIDIOC_G_EXT_CTRLS32:\n\tcase VIDIOC_S_EXT_CTRLS32:\n\tcase VIDIOC_TRY_EXT_CTRLS32:\n\t\treturn get_v4l2_ext_controls32(parg, arg);\n\n\tcase VIDIOC_CREATE_BUFS32:\n\t\treturn get_v4l2_create32(parg, arg);\n\n\tcase VIDIOC_ENUMSTD32:\n\t\treturn get_v4l2_standard32(parg, arg);\n\n\tcase VIDIOC_ENUMINPUT32:\n\t\treturn get_v4l2_input32(parg, arg);\n\n\tcase VIDIOC_G_EDID32:\n\tcase VIDIOC_S_EDID32:\n\t\treturn get_v4l2_edid32(parg, arg);\n\t}\n\treturn 0;\n}\n\nint v4l2_compat_put_user(void __user *arg, void *parg, unsigned int cmd)\n{\n\tswitch (cmd) {\n\tcase VIDIOC_G_FMT32:\n\tcase VIDIOC_S_FMT32:\n\tcase VIDIOC_TRY_FMT32:\n\t\treturn put_v4l2_format32(parg, arg);\n\n\tcase VIDIOC_G_FBUF32:\n\t\treturn put_v4l2_framebuffer32(parg, arg);\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase VIDIOC_QUERYBUF32_TIME32:\n\tcase VIDIOC_QBUF32_TIME32:\n\tcase VIDIOC_DQBUF32_TIME32:\n\tcase VIDIOC_PREPARE_BUF32_TIME32:\n\t\treturn put_v4l2_buffer32_time32(parg, arg);\n#endif\n\tcase VIDIOC_QUERYBUF32:\n\tcase VIDIOC_QBUF32:\n\tcase VIDIOC_DQBUF32:\n\tcase VIDIOC_PREPARE_BUF32:\n\t\treturn put_v4l2_buffer32(parg, arg);\n\n\tcase VIDIOC_G_EXT_CTRLS32:\n\tcase VIDIOC_S_EXT_CTRLS32:\n\tcase VIDIOC_TRY_EXT_CTRLS32:\n\t\treturn put_v4l2_ext_controls32(parg, arg);\n\n\tcase VIDIOC_CREATE_BUFS32:\n\t\treturn put_v4l2_create32(parg, arg);\n\n\tcase VIDIOC_ENUMSTD32:\n\t\treturn put_v4l2_standard32(parg, arg);\n\n\tcase VIDIOC_ENUMINPUT32:\n\t\treturn put_v4l2_input32(parg, arg);\n\n\tcase VIDIOC_G_EDID32:\n\tcase VIDIOC_S_EDID32:\n\t\treturn put_v4l2_edid32(parg, arg);\n#ifdef CONFIG_X86_64\n\tcase VIDIOC_DQEVENT32:\n\t\treturn put_v4l2_event32(parg, arg);\n#endif\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase VIDIOC_DQEVENT32_TIME32:\n\t\treturn put_v4l2_event32_time32(parg, arg);\n#endif\n\t}\n\treturn 0;\n}\n\nint v4l2_compat_get_array_args(struct file *file, void *mbuf,\n\t\t\t       void __user *user_ptr, size_t array_size,\n\t\t\t       unsigned int cmd, void *arg)\n{\n\tint err = 0;\n\n\tmemset(mbuf, 0, array_size);\n\n\tswitch (cmd) {\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase VIDIOC_QUERYBUF32_TIME32:\n\tcase VIDIOC_QBUF32_TIME32:\n\tcase VIDIOC_DQBUF32_TIME32:\n\tcase VIDIOC_PREPARE_BUF32_TIME32:\n#endif\n\tcase VIDIOC_QUERYBUF32:\n\tcase VIDIOC_QBUF32:\n\tcase VIDIOC_DQBUF32:\n\tcase VIDIOC_PREPARE_BUF32: {\n\t\tstruct v4l2_buffer *b64 = arg;\n\t\tstruct v4l2_plane *p64 = mbuf;\n\t\tstruct v4l2_plane32 __user *p32 = user_ptr;\n\n\t\tif (V4L2_TYPE_IS_MULTIPLANAR(b64->type)) {\n\t\t\tu32 num_planes = b64->length;\n\n\t\t\tif (num_planes == 0)\n\t\t\t\treturn 0;\n\n\t\t\twhile (num_planes--) {\n\t\t\t\terr = get_v4l2_plane32(p64, p32, b64->memory);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\t++p64;\n\t\t\t\t++p32;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_EXT_CTRLS32:\n\tcase VIDIOC_S_EXT_CTRLS32:\n\tcase VIDIOC_TRY_EXT_CTRLS32: {\n\t\tstruct v4l2_ext_controls *ecs64 = arg;\n\t\tstruct v4l2_ext_control *ec64 = mbuf;\n\t\tstruct v4l2_ext_control32 __user *ec32 = user_ptr;\n\t\tint n;\n\n\t\tfor (n = 0; n < ecs64->count; n++) {\n\t\t\tif (copy_from_user(ec64, ec32, sizeof(*ec32)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (ctrl_is_pointer(file, ec64->id)) {\n\t\t\t\tcompat_uptr_t p;\n\n\t\t\t\tif (get_user(p, &ec32->string))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tec64->string = compat_ptr(p);\n\t\t\t}\n\t\t\tec32++;\n\t\t\tec64++;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tif (copy_from_user(mbuf, user_ptr, array_size))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint v4l2_compat_put_array_args(struct file *file, void __user *user_ptr,\n\t\t\t       void *mbuf, size_t array_size,\n\t\t\t       unsigned int cmd, void *arg)\n{\n\tint err = 0;\n\n\tswitch (cmd) {\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase VIDIOC_QUERYBUF32_TIME32:\n\tcase VIDIOC_QBUF32_TIME32:\n\tcase VIDIOC_DQBUF32_TIME32:\n\tcase VIDIOC_PREPARE_BUF32_TIME32:\n#endif\n\tcase VIDIOC_QUERYBUF32:\n\tcase VIDIOC_QBUF32:\n\tcase VIDIOC_DQBUF32:\n\tcase VIDIOC_PREPARE_BUF32: {\n\t\tstruct v4l2_buffer *b64 = arg;\n\t\tstruct v4l2_plane *p64 = mbuf;\n\t\tstruct v4l2_plane32 __user *p32 = user_ptr;\n\n\t\tif (V4L2_TYPE_IS_MULTIPLANAR(b64->type)) {\n\t\t\tu32 num_planes = b64->length;\n\n\t\t\tif (num_planes == 0)\n\t\t\t\treturn 0;\n\n\t\t\twhile (num_planes--) {\n\t\t\t\terr = put_v4l2_plane32(p64, p32, b64->memory);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\t++p64;\n\t\t\t\t++p32;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_EXT_CTRLS32:\n\tcase VIDIOC_S_EXT_CTRLS32:\n\tcase VIDIOC_TRY_EXT_CTRLS32: {\n\t\tstruct v4l2_ext_controls *ecs64 = arg;\n\t\tstruct v4l2_ext_control *ec64 = mbuf;\n\t\tstruct v4l2_ext_control32 __user *ec32 = user_ptr;\n\t\tint n;\n\n\t\tfor (n = 0; n < ecs64->count; n++) {\n\t\t\tunsigned int size = sizeof(*ec32);\n\t\t\t \n\t\t\tif (ctrl_is_pointer(file, ec64->id))\n\t\t\t\tsize -= sizeof(ec32->value64);\n\n\t\t\tif (copy_to_user(ec32, ec64, size))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tec32++;\n\t\t\tec64++;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tif (copy_to_user(user_ptr, mbuf, array_size))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nlong v4l2_compat_ioctl32(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tlong ret = -ENOIOCTLCMD;\n\n\tif (!file->f_op->unlocked_ioctl)\n\t\treturn ret;\n\n\tif (!video_is_registered(vdev))\n\t\treturn -ENODEV;\n\n\tif (_IOC_TYPE(cmd) == 'V' && _IOC_NR(cmd) < BASE_VIDIOC_PRIVATE)\n\t\tret = file->f_op->unlocked_ioctl(file, cmd,\n\t\t\t\t\t(unsigned long)compat_ptr(arg));\n\telse if (vdev->fops->compat_ioctl32)\n\t\tret = vdev->fops->compat_ioctl32(file, cmd, arg);\n\n\tif (ret == -ENOIOCTLCMD)\n\t\tpr_debug(\"compat_ioctl32: unknown ioctl '%c', dir=%d, #%d (0x%08x)\\n\",\n\t\t\t _IOC_TYPE(cmd), _IOC_DIR(cmd), _IOC_NR(cmd), cmd);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(v4l2_compat_ioctl32);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}