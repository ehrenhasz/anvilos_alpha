{
  "module_name": "v4l2-subdev.c",
  "hash_id": "d3954ec1b85a95eca9ac0d1ab593320651a69ae69a3562b8fcfce9a4fc408212",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/v4l2-subdev.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/ioctl.h>\n#include <linux/leds.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/overflow.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/version.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-ioctl.h>\n\n#if defined(CONFIG_VIDEO_V4L2_SUBDEV_API)\n \n\nstatic bool v4l2_subdev_enable_streams_api;\n#endif\n\n \n#define V4L2_SUBDEV_MAX_STREAM_ID 63\n\n#include \"v4l2-subdev-priv.h\"\n\n#if defined(CONFIG_VIDEO_V4L2_SUBDEV_API)\nstatic int subdev_fh_init(struct v4l2_subdev_fh *fh, struct v4l2_subdev *sd)\n{\n\tstruct v4l2_subdev_state *state;\n\tstatic struct lock_class_key key;\n\n\tstate = __v4l2_subdev_state_alloc(sd, \"fh->state->lock\", &key);\n\tif (IS_ERR(state))\n\t\treturn PTR_ERR(state);\n\n\tfh->state = state;\n\n\treturn 0;\n}\n\nstatic void subdev_fh_free(struct v4l2_subdev_fh *fh)\n{\n\t__v4l2_subdev_state_free(fh->state);\n\tfh->state = NULL;\n}\n\nstatic int subdev_open(struct file *file)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct v4l2_subdev *sd = vdev_to_v4l2_subdev(vdev);\n\tstruct v4l2_subdev_fh *subdev_fh;\n\tint ret;\n\n\tsubdev_fh = kzalloc(sizeof(*subdev_fh), GFP_KERNEL);\n\tif (subdev_fh == NULL)\n\t\treturn -ENOMEM;\n\n\tret = subdev_fh_init(subdev_fh, sd);\n\tif (ret) {\n\t\tkfree(subdev_fh);\n\t\treturn ret;\n\t}\n\n\tv4l2_fh_init(&subdev_fh->vfh, vdev);\n\tv4l2_fh_add(&subdev_fh->vfh);\n\tfile->private_data = &subdev_fh->vfh;\n\n\tif (sd->v4l2_dev->mdev && sd->entity.graph_obj.mdev->dev) {\n\t\tstruct module *owner;\n\n\t\towner = sd->entity.graph_obj.mdev->dev->driver->owner;\n\t\tif (!try_module_get(owner)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto err;\n\t\t}\n\t\tsubdev_fh->owner = owner;\n\t}\n\n\tif (sd->internal_ops && sd->internal_ops->open) {\n\t\tret = sd->internal_ops->open(sd, subdev_fh);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tmodule_put(subdev_fh->owner);\n\tv4l2_fh_del(&subdev_fh->vfh);\n\tv4l2_fh_exit(&subdev_fh->vfh);\n\tsubdev_fh_free(subdev_fh);\n\tkfree(subdev_fh);\n\n\treturn ret;\n}\n\nstatic int subdev_close(struct file *file)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct v4l2_subdev *sd = vdev_to_v4l2_subdev(vdev);\n\tstruct v4l2_fh *vfh = file->private_data;\n\tstruct v4l2_subdev_fh *subdev_fh = to_v4l2_subdev_fh(vfh);\n\n\tif (sd->internal_ops && sd->internal_ops->close)\n\t\tsd->internal_ops->close(sd, subdev_fh);\n\tmodule_put(subdev_fh->owner);\n\tv4l2_fh_del(vfh);\n\tv4l2_fh_exit(vfh);\n\tsubdev_fh_free(subdev_fh);\n\tkfree(subdev_fh);\n\tfile->private_data = NULL;\n\n\treturn 0;\n}\n#else  \nstatic int subdev_open(struct file *file)\n{\n\treturn -ENODEV;\n}\n\nstatic int subdev_close(struct file *file)\n{\n\treturn -ENODEV;\n}\n#endif  \n\nstatic inline int check_which(u32 which)\n{\n\tif (which != V4L2_SUBDEV_FORMAT_TRY &&\n\t    which != V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic inline int check_pad(struct v4l2_subdev *sd, u32 pad)\n{\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tif (sd->entity.num_pads) {\n\t\tif (pad >= sd->entity.num_pads)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n#endif\n\t \n\tif (pad > 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int check_state(struct v4l2_subdev *sd, struct v4l2_subdev_state *state,\n\t\t       u32 which, u32 pad, u32 stream)\n{\n\tif (sd->flags & V4L2_SUBDEV_FL_STREAMS) {\n#if defined(CONFIG_VIDEO_V4L2_SUBDEV_API)\n\t\tif (!v4l2_subdev_state_get_stream_format(state, pad, stream))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n#else\n\t\treturn -EINVAL;\n#endif\n\t}\n\n\tif (stream != 0)\n\t\treturn -EINVAL;\n\n\tif (which == V4L2_SUBDEV_FORMAT_TRY && (!state || !state->pads))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic inline int check_format(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *state,\n\t\t\t       struct v4l2_subdev_format *format)\n{\n\tif (!format)\n\t\treturn -EINVAL;\n\n\treturn check_which(format->which) ? : check_pad(sd, format->pad) ? :\n\t       check_state(sd, state, format->which, format->pad, format->stream);\n}\n\nstatic int call_get_fmt(struct v4l2_subdev *sd,\n\t\t\tstruct v4l2_subdev_state *state,\n\t\t\tstruct v4l2_subdev_format *format)\n{\n\treturn check_format(sd, state, format) ? :\n\t       sd->ops->pad->get_fmt(sd, state, format);\n}\n\nstatic int call_set_fmt(struct v4l2_subdev *sd,\n\t\t\tstruct v4l2_subdev_state *state,\n\t\t\tstruct v4l2_subdev_format *format)\n{\n\treturn check_format(sd, state, format) ? :\n\t       sd->ops->pad->set_fmt(sd, state, format);\n}\n\nstatic int call_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *state,\n\t\t\t       struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (!code)\n\t\treturn -EINVAL;\n\n\treturn check_which(code->which) ? : check_pad(sd, code->pad) ? :\n\t       check_state(sd, state, code->which, code->pad, code->stream) ? :\n\t       sd->ops->pad->enum_mbus_code(sd, state, code);\n}\n\nstatic int call_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *state,\n\t\t\t\tstruct v4l2_subdev_frame_size_enum *fse)\n{\n\tif (!fse)\n\t\treturn -EINVAL;\n\n\treturn check_which(fse->which) ? : check_pad(sd, fse->pad) ? :\n\t       check_state(sd, state, fse->which, fse->pad, fse->stream) ? :\n\t       sd->ops->pad->enum_frame_size(sd, state, fse);\n}\n\nstatic inline int check_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t       struct v4l2_subdev_frame_interval *fi)\n{\n\tif (!fi)\n\t\treturn -EINVAL;\n\n\treturn check_pad(sd, fi->pad);\n}\n\nstatic int call_g_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_frame_interval *fi)\n{\n\treturn check_frame_interval(sd, fi) ? :\n\t       sd->ops->video->g_frame_interval(sd, fi);\n}\n\nstatic int call_s_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_frame_interval *fi)\n{\n\treturn check_frame_interval(sd, fi) ? :\n\t       sd->ops->video->s_frame_interval(sd, fi);\n}\n\nstatic int call_enum_frame_interval(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *state,\n\t\t\t\t    struct v4l2_subdev_frame_interval_enum *fie)\n{\n\tif (!fie)\n\t\treturn -EINVAL;\n\n\treturn check_which(fie->which) ? : check_pad(sd, fie->pad) ? :\n\t       check_state(sd, state, fie->which, fie->pad, fie->stream) ? :\n\t       sd->ops->pad->enum_frame_interval(sd, state, fie);\n}\n\nstatic inline int check_selection(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *state,\n\t\t\t\t  struct v4l2_subdev_selection *sel)\n{\n\tif (!sel)\n\t\treturn -EINVAL;\n\n\treturn check_which(sel->which) ? : check_pad(sd, sel->pad) ? :\n\t       check_state(sd, state, sel->which, sel->pad, sel->stream);\n}\n\nstatic int call_get_selection(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *state,\n\t\t\t      struct v4l2_subdev_selection *sel)\n{\n\treturn check_selection(sd, state, sel) ? :\n\t       sd->ops->pad->get_selection(sd, state, sel);\n}\n\nstatic int call_set_selection(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *state,\n\t\t\t      struct v4l2_subdev_selection *sel)\n{\n\treturn check_selection(sd, state, sel) ? :\n\t       sd->ops->pad->set_selection(sd, state, sel);\n}\n\nstatic inline int check_edid(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_edid *edid)\n{\n\tif (!edid)\n\t\treturn -EINVAL;\n\n\tif (edid->blocks && edid->edid == NULL)\n\t\treturn -EINVAL;\n\n\treturn check_pad(sd, edid->pad);\n}\n\nstatic int call_get_edid(struct v4l2_subdev *sd, struct v4l2_subdev_edid *edid)\n{\n\treturn check_edid(sd, edid) ? : sd->ops->pad->get_edid(sd, edid);\n}\n\nstatic int call_set_edid(struct v4l2_subdev *sd, struct v4l2_subdev_edid *edid)\n{\n\treturn check_edid(sd, edid) ? : sd->ops->pad->set_edid(sd, edid);\n}\n\nstatic int call_dv_timings_cap(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_dv_timings_cap *cap)\n{\n\tif (!cap)\n\t\treturn -EINVAL;\n\n\treturn check_pad(sd, cap->pad) ? :\n\t       sd->ops->pad->dv_timings_cap(sd, cap);\n}\n\nstatic int call_enum_dv_timings(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_enum_dv_timings *dvt)\n{\n\tif (!dvt)\n\t\treturn -EINVAL;\n\n\treturn check_pad(sd, dvt->pad) ? :\n\t       sd->ops->pad->enum_dv_timings(sd, dvt);\n}\n\nstatic int call_get_mbus_config(struct v4l2_subdev *sd, unsigned int pad,\n\t\t\t\tstruct v4l2_mbus_config *config)\n{\n\treturn check_pad(sd, pad) ? :\n\t       sd->ops->pad->get_mbus_config(sd, pad, config);\n}\n\nstatic int call_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tint ret;\n\n#if IS_REACHABLE(CONFIG_LEDS_CLASS)\n\tif (!IS_ERR_OR_NULL(sd->privacy_led)) {\n\t\tif (enable)\n\t\t\tled_set_brightness(sd->privacy_led,\n\t\t\t\t\t   sd->privacy_led->max_brightness);\n\t\telse\n\t\t\tled_set_brightness(sd->privacy_led, 0);\n\t}\n#endif\n\tret = sd->ops->video->s_stream(sd, enable);\n\n\tif (!enable && ret < 0) {\n\t\tdev_warn(sd->dev, \"disabling streaming failed (%d)\\n\", ret);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n \n#define DEFINE_STATE_WRAPPER(f, arg_type)                                  \\\n\tstatic int call_##f##_state(struct v4l2_subdev *sd,                \\\n\t\t\t\t    struct v4l2_subdev_state *_state,      \\\n\t\t\t\t    arg_type *arg)                         \\\n\t{                                                                  \\\n\t\tstruct v4l2_subdev_state *state = _state;                  \\\n\t\tint ret;                                                   \\\n\t\tif (!_state)                                               \\\n\t\t\tstate = v4l2_subdev_lock_and_get_active_state(sd); \\\n\t\tret = call_##f(sd, state, arg);                            \\\n\t\tif (!_state && state)                                      \\\n\t\t\tv4l2_subdev_unlock_state(state);                   \\\n\t\treturn ret;                                                \\\n\t}\n\n#else  \n\n#define DEFINE_STATE_WRAPPER(f, arg_type)                            \\\n\tstatic int call_##f##_state(struct v4l2_subdev *sd,          \\\n\t\t\t\t    struct v4l2_subdev_state *state, \\\n\t\t\t\t    arg_type *arg)                   \\\n\t{                                                            \\\n\t\treturn call_##f(sd, state, arg);                     \\\n\t}\n\n#endif  \n\nDEFINE_STATE_WRAPPER(get_fmt, struct v4l2_subdev_format);\nDEFINE_STATE_WRAPPER(set_fmt, struct v4l2_subdev_format);\nDEFINE_STATE_WRAPPER(enum_mbus_code, struct v4l2_subdev_mbus_code_enum);\nDEFINE_STATE_WRAPPER(enum_frame_size, struct v4l2_subdev_frame_size_enum);\nDEFINE_STATE_WRAPPER(enum_frame_interval, struct v4l2_subdev_frame_interval_enum);\nDEFINE_STATE_WRAPPER(get_selection, struct v4l2_subdev_selection);\nDEFINE_STATE_WRAPPER(set_selection, struct v4l2_subdev_selection);\n\nstatic const struct v4l2_subdev_pad_ops v4l2_subdev_call_pad_wrappers = {\n\t.get_fmt\t\t= call_get_fmt_state,\n\t.set_fmt\t\t= call_set_fmt_state,\n\t.enum_mbus_code\t\t= call_enum_mbus_code_state,\n\t.enum_frame_size\t= call_enum_frame_size_state,\n\t.enum_frame_interval\t= call_enum_frame_interval_state,\n\t.get_selection\t\t= call_get_selection_state,\n\t.set_selection\t\t= call_set_selection_state,\n\t.get_edid\t\t= call_get_edid,\n\t.set_edid\t\t= call_set_edid,\n\t.dv_timings_cap\t\t= call_dv_timings_cap,\n\t.enum_dv_timings\t= call_enum_dv_timings,\n\t.get_mbus_config\t= call_get_mbus_config,\n};\n\nstatic const struct v4l2_subdev_video_ops v4l2_subdev_call_video_wrappers = {\n\t.g_frame_interval\t= call_g_frame_interval,\n\t.s_frame_interval\t= call_s_frame_interval,\n\t.s_stream\t\t= call_s_stream,\n};\n\nconst struct v4l2_subdev_ops v4l2_subdev_call_wrappers = {\n\t.pad\t= &v4l2_subdev_call_pad_wrappers,\n\t.video\t= &v4l2_subdev_call_video_wrappers,\n};\nEXPORT_SYMBOL(v4l2_subdev_call_wrappers);\n\n#if defined(CONFIG_VIDEO_V4L2_SUBDEV_API)\n\nstatic struct v4l2_subdev_state *\nsubdev_ioctl_get_state(struct v4l2_subdev *sd, struct v4l2_subdev_fh *subdev_fh,\n\t\t       unsigned int cmd, void *arg)\n{\n\tu32 which;\n\n\tswitch (cmd) {\n\tdefault:\n\t\treturn NULL;\n\tcase VIDIOC_SUBDEV_G_FMT:\n\tcase VIDIOC_SUBDEV_S_FMT:\n\t\twhich = ((struct v4l2_subdev_format *)arg)->which;\n\t\tbreak;\n\tcase VIDIOC_SUBDEV_G_CROP:\n\tcase VIDIOC_SUBDEV_S_CROP:\n\t\twhich = ((struct v4l2_subdev_crop *)arg)->which;\n\t\tbreak;\n\tcase VIDIOC_SUBDEV_ENUM_MBUS_CODE:\n\t\twhich = ((struct v4l2_subdev_mbus_code_enum *)arg)->which;\n\t\tbreak;\n\tcase VIDIOC_SUBDEV_ENUM_FRAME_SIZE:\n\t\twhich = ((struct v4l2_subdev_frame_size_enum *)arg)->which;\n\t\tbreak;\n\tcase VIDIOC_SUBDEV_ENUM_FRAME_INTERVAL:\n\t\twhich = ((struct v4l2_subdev_frame_interval_enum *)arg)->which;\n\t\tbreak;\n\tcase VIDIOC_SUBDEV_G_SELECTION:\n\tcase VIDIOC_SUBDEV_S_SELECTION:\n\t\twhich = ((struct v4l2_subdev_selection *)arg)->which;\n\t\tbreak;\n\tcase VIDIOC_SUBDEV_G_ROUTING:\n\tcase VIDIOC_SUBDEV_S_ROUTING:\n\t\twhich = ((struct v4l2_subdev_routing *)arg)->which;\n\t\tbreak;\n\t}\n\n\treturn which == V4L2_SUBDEV_FORMAT_TRY ?\n\t\t\t     subdev_fh->state :\n\t\t\t     v4l2_subdev_get_unlocked_active_state(sd);\n}\n\nstatic long subdev_do_ioctl(struct file *file, unsigned int cmd, void *arg,\n\t\t\t    struct v4l2_subdev_state *state)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct v4l2_subdev *sd = vdev_to_v4l2_subdev(vdev);\n\tstruct v4l2_fh *vfh = file->private_data;\n\tstruct v4l2_subdev_fh *subdev_fh = to_v4l2_subdev_fh(vfh);\n\tbool ro_subdev = test_bit(V4L2_FL_SUBDEV_RO_DEVNODE, &vdev->flags);\n\tbool streams_subdev = sd->flags & V4L2_SUBDEV_FL_STREAMS;\n\tbool client_supports_streams = subdev_fh->client_caps &\n\t\t\t\t       V4L2_SUBDEV_CLIENT_CAP_STREAMS;\n\tint rval;\n\n\t \n\tif (!v4l2_subdev_enable_streams_api)\n\t\tstreams_subdev = false;\n\n\tswitch (cmd) {\n\tcase VIDIOC_SUBDEV_QUERYCAP: {\n\t\tstruct v4l2_subdev_capability *cap = arg;\n\n\t\tmemset(cap->reserved, 0, sizeof(cap->reserved));\n\t\tcap->version = LINUX_VERSION_CODE;\n\t\tcap->capabilities =\n\t\t\t(ro_subdev ? V4L2_SUBDEV_CAP_RO_SUBDEV : 0) |\n\t\t\t(streams_subdev ? V4L2_SUBDEV_CAP_STREAMS : 0);\n\n\t\treturn 0;\n\t}\n\n\tcase VIDIOC_QUERYCTRL:\n\t\t \n\t\tif (!vfh->ctrl_handler)\n\t\t\treturn -ENOTTY;\n\t\treturn v4l2_queryctrl(vfh->ctrl_handler, arg);\n\n\tcase VIDIOC_QUERY_EXT_CTRL:\n\t\tif (!vfh->ctrl_handler)\n\t\t\treturn -ENOTTY;\n\t\treturn v4l2_query_ext_ctrl(vfh->ctrl_handler, arg);\n\n\tcase VIDIOC_QUERYMENU:\n\t\tif (!vfh->ctrl_handler)\n\t\t\treturn -ENOTTY;\n\t\treturn v4l2_querymenu(vfh->ctrl_handler, arg);\n\n\tcase VIDIOC_G_CTRL:\n\t\tif (!vfh->ctrl_handler)\n\t\t\treturn -ENOTTY;\n\t\treturn v4l2_g_ctrl(vfh->ctrl_handler, arg);\n\n\tcase VIDIOC_S_CTRL:\n\t\tif (!vfh->ctrl_handler)\n\t\t\treturn -ENOTTY;\n\t\treturn v4l2_s_ctrl(vfh, vfh->ctrl_handler, arg);\n\n\tcase VIDIOC_G_EXT_CTRLS:\n\t\tif (!vfh->ctrl_handler)\n\t\t\treturn -ENOTTY;\n\t\treturn v4l2_g_ext_ctrls(vfh->ctrl_handler,\n\t\t\t\t\tvdev, sd->v4l2_dev->mdev, arg);\n\n\tcase VIDIOC_S_EXT_CTRLS:\n\t\tif (!vfh->ctrl_handler)\n\t\t\treturn -ENOTTY;\n\t\treturn v4l2_s_ext_ctrls(vfh, vfh->ctrl_handler,\n\t\t\t\t\tvdev, sd->v4l2_dev->mdev, arg);\n\n\tcase VIDIOC_TRY_EXT_CTRLS:\n\t\tif (!vfh->ctrl_handler)\n\t\t\treturn -ENOTTY;\n\t\treturn v4l2_try_ext_ctrls(vfh->ctrl_handler,\n\t\t\t\t\t  vdev, sd->v4l2_dev->mdev, arg);\n\n\tcase VIDIOC_DQEVENT:\n\t\tif (!(sd->flags & V4L2_SUBDEV_FL_HAS_EVENTS))\n\t\t\treturn -ENOIOCTLCMD;\n\n\t\treturn v4l2_event_dequeue(vfh, arg, file->f_flags & O_NONBLOCK);\n\n\tcase VIDIOC_SUBSCRIBE_EVENT:\n\t\treturn v4l2_subdev_call(sd, core, subscribe_event, vfh, arg);\n\n\tcase VIDIOC_UNSUBSCRIBE_EVENT:\n\t\treturn v4l2_subdev_call(sd, core, unsubscribe_event, vfh, arg);\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\tcase VIDIOC_DBG_G_REGISTER:\n\t{\n\t\tstruct v4l2_dbg_register *p = arg;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn v4l2_subdev_call(sd, core, g_register, p);\n\t}\n\tcase VIDIOC_DBG_S_REGISTER:\n\t{\n\t\tstruct v4l2_dbg_register *p = arg;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn v4l2_subdev_call(sd, core, s_register, p);\n\t}\n\tcase VIDIOC_DBG_G_CHIP_INFO:\n\t{\n\t\tstruct v4l2_dbg_chip_info *p = arg;\n\n\t\tif (p->match.type != V4L2_CHIP_MATCH_SUBDEV || p->match.addr)\n\t\t\treturn -EINVAL;\n\t\tif (sd->ops->core && sd->ops->core->s_register)\n\t\t\tp->flags |= V4L2_CHIP_FL_WRITABLE;\n\t\tif (sd->ops->core && sd->ops->core->g_register)\n\t\t\tp->flags |= V4L2_CHIP_FL_READABLE;\n\t\tstrscpy(p->name, sd->name, sizeof(p->name));\n\t\treturn 0;\n\t}\n#endif\n\n\tcase VIDIOC_LOG_STATUS: {\n\t\tint ret;\n\n\t\tpr_info(\"%s: =================  START STATUS  =================\\n\",\n\t\t\tsd->name);\n\t\tret = v4l2_subdev_call(sd, core, log_status);\n\t\tpr_info(\"%s: ==================  END STATUS  ==================\\n\",\n\t\t\tsd->name);\n\t\treturn ret;\n\t}\n\n\tcase VIDIOC_SUBDEV_G_FMT: {\n\t\tstruct v4l2_subdev_format *format = arg;\n\n\t\tif (!client_supports_streams)\n\t\t\tformat->stream = 0;\n\n\t\tmemset(format->reserved, 0, sizeof(format->reserved));\n\t\tmemset(format->format.reserved, 0, sizeof(format->format.reserved));\n\t\treturn v4l2_subdev_call(sd, pad, get_fmt, state, format);\n\t}\n\n\tcase VIDIOC_SUBDEV_S_FMT: {\n\t\tstruct v4l2_subdev_format *format = arg;\n\n\t\tif (format->which != V4L2_SUBDEV_FORMAT_TRY && ro_subdev)\n\t\t\treturn -EPERM;\n\n\t\tif (!client_supports_streams)\n\t\t\tformat->stream = 0;\n\n\t\tmemset(format->reserved, 0, sizeof(format->reserved));\n\t\tmemset(format->format.reserved, 0, sizeof(format->format.reserved));\n\t\treturn v4l2_subdev_call(sd, pad, set_fmt, state, format);\n\t}\n\n\tcase VIDIOC_SUBDEV_G_CROP: {\n\t\tstruct v4l2_subdev_crop *crop = arg;\n\t\tstruct v4l2_subdev_selection sel;\n\n\t\tif (!client_supports_streams)\n\t\t\tcrop->stream = 0;\n\n\t\tmemset(crop->reserved, 0, sizeof(crop->reserved));\n\t\tmemset(&sel, 0, sizeof(sel));\n\t\tsel.which = crop->which;\n\t\tsel.pad = crop->pad;\n\t\tsel.target = V4L2_SEL_TGT_CROP;\n\n\t\trval = v4l2_subdev_call(\n\t\t\tsd, pad, get_selection, state, &sel);\n\n\t\tcrop->rect = sel.r;\n\n\t\treturn rval;\n\t}\n\n\tcase VIDIOC_SUBDEV_S_CROP: {\n\t\tstruct v4l2_subdev_crop *crop = arg;\n\t\tstruct v4l2_subdev_selection sel;\n\n\t\tif (crop->which != V4L2_SUBDEV_FORMAT_TRY && ro_subdev)\n\t\t\treturn -EPERM;\n\n\t\tif (!client_supports_streams)\n\t\t\tcrop->stream = 0;\n\n\t\tmemset(crop->reserved, 0, sizeof(crop->reserved));\n\t\tmemset(&sel, 0, sizeof(sel));\n\t\tsel.which = crop->which;\n\t\tsel.pad = crop->pad;\n\t\tsel.target = V4L2_SEL_TGT_CROP;\n\t\tsel.r = crop->rect;\n\n\t\trval = v4l2_subdev_call(\n\t\t\tsd, pad, set_selection, state, &sel);\n\n\t\tcrop->rect = sel.r;\n\n\t\treturn rval;\n\t}\n\n\tcase VIDIOC_SUBDEV_ENUM_MBUS_CODE: {\n\t\tstruct v4l2_subdev_mbus_code_enum *code = arg;\n\n\t\tif (!client_supports_streams)\n\t\t\tcode->stream = 0;\n\n\t\tmemset(code->reserved, 0, sizeof(code->reserved));\n\t\treturn v4l2_subdev_call(sd, pad, enum_mbus_code, state,\n\t\t\t\t\tcode);\n\t}\n\n\tcase VIDIOC_SUBDEV_ENUM_FRAME_SIZE: {\n\t\tstruct v4l2_subdev_frame_size_enum *fse = arg;\n\n\t\tif (!client_supports_streams)\n\t\t\tfse->stream = 0;\n\n\t\tmemset(fse->reserved, 0, sizeof(fse->reserved));\n\t\treturn v4l2_subdev_call(sd, pad, enum_frame_size, state,\n\t\t\t\t\tfse);\n\t}\n\n\tcase VIDIOC_SUBDEV_G_FRAME_INTERVAL: {\n\t\tstruct v4l2_subdev_frame_interval *fi = arg;\n\n\t\tif (!client_supports_streams)\n\t\t\tfi->stream = 0;\n\n\t\tmemset(fi->reserved, 0, sizeof(fi->reserved));\n\t\treturn v4l2_subdev_call(sd, video, g_frame_interval, arg);\n\t}\n\n\tcase VIDIOC_SUBDEV_S_FRAME_INTERVAL: {\n\t\tstruct v4l2_subdev_frame_interval *fi = arg;\n\n\t\tif (ro_subdev)\n\t\t\treturn -EPERM;\n\n\t\tif (!client_supports_streams)\n\t\t\tfi->stream = 0;\n\n\t\tmemset(fi->reserved, 0, sizeof(fi->reserved));\n\t\treturn v4l2_subdev_call(sd, video, s_frame_interval, arg);\n\t}\n\n\tcase VIDIOC_SUBDEV_ENUM_FRAME_INTERVAL: {\n\t\tstruct v4l2_subdev_frame_interval_enum *fie = arg;\n\n\t\tif (!client_supports_streams)\n\t\t\tfie->stream = 0;\n\n\t\tmemset(fie->reserved, 0, sizeof(fie->reserved));\n\t\treturn v4l2_subdev_call(sd, pad, enum_frame_interval, state,\n\t\t\t\t\tfie);\n\t}\n\n\tcase VIDIOC_SUBDEV_G_SELECTION: {\n\t\tstruct v4l2_subdev_selection *sel = arg;\n\n\t\tif (!client_supports_streams)\n\t\t\tsel->stream = 0;\n\n\t\tmemset(sel->reserved, 0, sizeof(sel->reserved));\n\t\treturn v4l2_subdev_call(\n\t\t\tsd, pad, get_selection, state, sel);\n\t}\n\n\tcase VIDIOC_SUBDEV_S_SELECTION: {\n\t\tstruct v4l2_subdev_selection *sel = arg;\n\n\t\tif (sel->which != V4L2_SUBDEV_FORMAT_TRY && ro_subdev)\n\t\t\treturn -EPERM;\n\n\t\tif (!client_supports_streams)\n\t\t\tsel->stream = 0;\n\n\t\tmemset(sel->reserved, 0, sizeof(sel->reserved));\n\t\treturn v4l2_subdev_call(\n\t\t\tsd, pad, set_selection, state, sel);\n\t}\n\n\tcase VIDIOC_G_EDID: {\n\t\tstruct v4l2_subdev_edid *edid = arg;\n\n\t\treturn v4l2_subdev_call(sd, pad, get_edid, edid);\n\t}\n\n\tcase VIDIOC_S_EDID: {\n\t\tstruct v4l2_subdev_edid *edid = arg;\n\n\t\treturn v4l2_subdev_call(sd, pad, set_edid, edid);\n\t}\n\n\tcase VIDIOC_SUBDEV_DV_TIMINGS_CAP: {\n\t\tstruct v4l2_dv_timings_cap *cap = arg;\n\n\t\treturn v4l2_subdev_call(sd, pad, dv_timings_cap, cap);\n\t}\n\n\tcase VIDIOC_SUBDEV_ENUM_DV_TIMINGS: {\n\t\tstruct v4l2_enum_dv_timings *dvt = arg;\n\n\t\treturn v4l2_subdev_call(sd, pad, enum_dv_timings, dvt);\n\t}\n\n\tcase VIDIOC_SUBDEV_QUERY_DV_TIMINGS:\n\t\treturn v4l2_subdev_call(sd, video, query_dv_timings, arg);\n\n\tcase VIDIOC_SUBDEV_G_DV_TIMINGS:\n\t\treturn v4l2_subdev_call(sd, video, g_dv_timings, arg);\n\n\tcase VIDIOC_SUBDEV_S_DV_TIMINGS:\n\t\tif (ro_subdev)\n\t\t\treturn -EPERM;\n\n\t\treturn v4l2_subdev_call(sd, video, s_dv_timings, arg);\n\n\tcase VIDIOC_SUBDEV_G_STD:\n\t\treturn v4l2_subdev_call(sd, video, g_std, arg);\n\n\tcase VIDIOC_SUBDEV_S_STD: {\n\t\tv4l2_std_id *std = arg;\n\n\t\tif (ro_subdev)\n\t\t\treturn -EPERM;\n\n\t\treturn v4l2_subdev_call(sd, video, s_std, *std);\n\t}\n\n\tcase VIDIOC_SUBDEV_ENUMSTD: {\n\t\tstruct v4l2_standard *p = arg;\n\t\tv4l2_std_id id;\n\n\t\tif (v4l2_subdev_call(sd, video, g_tvnorms, &id))\n\t\t\treturn -EINVAL;\n\n\t\treturn v4l_video_std_enumstd(p, id);\n\t}\n\n\tcase VIDIOC_SUBDEV_QUERYSTD:\n\t\treturn v4l2_subdev_call(sd, video, querystd, arg);\n\n\tcase VIDIOC_SUBDEV_G_ROUTING: {\n\t\tstruct v4l2_subdev_routing *routing = arg;\n\t\tstruct v4l2_subdev_krouting *krouting;\n\n\t\tif (!v4l2_subdev_enable_streams_api)\n\t\t\treturn -ENOIOCTLCMD;\n\n\t\tif (!(sd->flags & V4L2_SUBDEV_FL_STREAMS))\n\t\t\treturn -ENOIOCTLCMD;\n\n\t\tmemset(routing->reserved, 0, sizeof(routing->reserved));\n\n\t\tkrouting = &state->routing;\n\n\t\tif (routing->num_routes < krouting->num_routes) {\n\t\t\trouting->num_routes = krouting->num_routes;\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tmemcpy((struct v4l2_subdev_route *)(uintptr_t)routing->routes,\n\t\t       krouting->routes,\n\t\t       krouting->num_routes * sizeof(*krouting->routes));\n\t\trouting->num_routes = krouting->num_routes;\n\n\t\treturn 0;\n\t}\n\n\tcase VIDIOC_SUBDEV_S_ROUTING: {\n\t\tstruct v4l2_subdev_routing *routing = arg;\n\t\tstruct v4l2_subdev_route *routes =\n\t\t\t(struct v4l2_subdev_route *)(uintptr_t)routing->routes;\n\t\tstruct v4l2_subdev_krouting krouting = {};\n\t\tunsigned int i;\n\n\t\tif (!v4l2_subdev_enable_streams_api)\n\t\t\treturn -ENOIOCTLCMD;\n\n\t\tif (!(sd->flags & V4L2_SUBDEV_FL_STREAMS))\n\t\t\treturn -ENOIOCTLCMD;\n\n\t\tif (routing->which != V4L2_SUBDEV_FORMAT_TRY && ro_subdev)\n\t\t\treturn -EPERM;\n\n\t\tmemset(routing->reserved, 0, sizeof(routing->reserved));\n\n\t\tfor (i = 0; i < routing->num_routes; ++i) {\n\t\t\tconst struct v4l2_subdev_route *route = &routes[i];\n\t\t\tconst struct media_pad *pads = sd->entity.pads;\n\n\t\t\tif (route->sink_stream > V4L2_SUBDEV_MAX_STREAM_ID ||\n\t\t\t    route->source_stream > V4L2_SUBDEV_MAX_STREAM_ID)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (route->sink_pad >= sd->entity.num_pads)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (!(pads[route->sink_pad].flags &\n\t\t\t      MEDIA_PAD_FL_SINK))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (route->source_pad >= sd->entity.num_pads)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (!(pads[route->source_pad].flags &\n\t\t\t      MEDIA_PAD_FL_SOURCE))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tkrouting.num_routes = routing->num_routes;\n\t\tkrouting.routes = routes;\n\n\t\treturn v4l2_subdev_call(sd, pad, set_routing, state,\n\t\t\t\t\trouting->which, &krouting);\n\t}\n\n\tcase VIDIOC_SUBDEV_G_CLIENT_CAP: {\n\t\tstruct v4l2_subdev_client_capability *client_cap = arg;\n\n\t\tclient_cap->capabilities = subdev_fh->client_caps;\n\n\t\treturn 0;\n\t}\n\n\tcase VIDIOC_SUBDEV_S_CLIENT_CAP: {\n\t\tstruct v4l2_subdev_client_capability *client_cap = arg;\n\n\t\t \n\t\tif (!v4l2_subdev_enable_streams_api)\n\t\t\tclient_cap->capabilities &= ~V4L2_SUBDEV_CLIENT_CAP_STREAMS;\n\n\t\t \n\t\tclient_cap->capabilities &= V4L2_SUBDEV_CLIENT_CAP_STREAMS;\n\n\t\tsubdev_fh->client_caps = client_cap->capabilities;\n\n\t\treturn 0;\n\t}\n\n\tdefault:\n\t\treturn v4l2_subdev_call(sd, core, ioctl, cmd, arg);\n\t}\n\n\treturn 0;\n}\n\nstatic long subdev_do_ioctl_lock(struct file *file, unsigned int cmd, void *arg)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct mutex *lock = vdev->lock;\n\tlong ret = -ENODEV;\n\n\tif (lock && mutex_lock_interruptible(lock))\n\t\treturn -ERESTARTSYS;\n\n\tif (video_is_registered(vdev)) {\n\t\tstruct v4l2_subdev *sd = vdev_to_v4l2_subdev(vdev);\n\t\tstruct v4l2_fh *vfh = file->private_data;\n\t\tstruct v4l2_subdev_fh *subdev_fh = to_v4l2_subdev_fh(vfh);\n\t\tstruct v4l2_subdev_state *state;\n\n\t\tstate = subdev_ioctl_get_state(sd, subdev_fh, cmd, arg);\n\n\t\tif (state)\n\t\t\tv4l2_subdev_lock_state(state);\n\n\t\tret = subdev_do_ioctl(file, cmd, arg, state);\n\n\t\tif (state)\n\t\t\tv4l2_subdev_unlock_state(state);\n\t}\n\n\tif (lock)\n\t\tmutex_unlock(lock);\n\treturn ret;\n}\n\nstatic long subdev_ioctl(struct file *file, unsigned int cmd,\n\tunsigned long arg)\n{\n\treturn video_usercopy(file, cmd, arg, subdev_do_ioctl_lock);\n}\n\n#ifdef CONFIG_COMPAT\nstatic long subdev_compat_ioctl32(struct file *file, unsigned int cmd,\n\tunsigned long arg)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct v4l2_subdev *sd = vdev_to_v4l2_subdev(vdev);\n\n\treturn v4l2_subdev_call(sd, core, compat_ioctl32, cmd, arg);\n}\n#endif\n\n#else  \nstatic long subdev_ioctl(struct file *file, unsigned int cmd,\n\t\t\t unsigned long arg)\n{\n\treturn -ENODEV;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long subdev_compat_ioctl32(struct file *file, unsigned int cmd,\n\t\t\t\t  unsigned long arg)\n{\n\treturn -ENODEV;\n}\n#endif\n#endif  \n\nstatic __poll_t subdev_poll(struct file *file, poll_table *wait)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct v4l2_subdev *sd = vdev_to_v4l2_subdev(vdev);\n\tstruct v4l2_fh *fh = file->private_data;\n\n\tif (!(sd->flags & V4L2_SUBDEV_FL_HAS_EVENTS))\n\t\treturn EPOLLERR;\n\n\tpoll_wait(file, &fh->wait, wait);\n\n\tif (v4l2_event_pending(fh))\n\t\treturn EPOLLPRI;\n\n\treturn 0;\n}\n\nconst struct v4l2_file_operations v4l2_subdev_fops = {\n\t.owner = THIS_MODULE,\n\t.open = subdev_open,\n\t.unlocked_ioctl = subdev_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl32 = subdev_compat_ioctl32,\n#endif\n\t.release = subdev_close,\n\t.poll = subdev_poll,\n};\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\nint v4l2_subdev_get_fwnode_pad_1_to_1(struct media_entity *entity,\n\t\t\t\t      struct fwnode_endpoint *endpoint)\n{\n\tstruct fwnode_handle *fwnode;\n\tstruct v4l2_subdev *sd;\n\n\tif (!is_media_entity_v4l2_subdev(entity))\n\t\treturn -EINVAL;\n\n\tsd = media_entity_to_v4l2_subdev(entity);\n\n\tfwnode = fwnode_graph_get_port_parent(endpoint->local_fwnode);\n\tfwnode_handle_put(fwnode);\n\n\tif (device_match_fwnode(sd->dev, fwnode))\n\t\treturn endpoint->port;\n\n\treturn -ENXIO;\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_get_fwnode_pad_1_to_1);\n\nint v4l2_subdev_link_validate_default(struct v4l2_subdev *sd,\n\t\t\t\t      struct media_link *link,\n\t\t\t\t      struct v4l2_subdev_format *source_fmt,\n\t\t\t\t      struct v4l2_subdev_format *sink_fmt)\n{\n\tbool pass = true;\n\n\t \n\tif (source_fmt->format.width != sink_fmt->format.width) {\n\t\tdev_dbg(sd->entity.graph_obj.mdev->dev,\n\t\t\t\"%s: width does not match (source %u, sink %u)\\n\",\n\t\t\t__func__,\n\t\t\tsource_fmt->format.width, sink_fmt->format.width);\n\t\tpass = false;\n\t}\n\n\tif (source_fmt->format.height != sink_fmt->format.height) {\n\t\tdev_dbg(sd->entity.graph_obj.mdev->dev,\n\t\t\t\"%s: height does not match (source %u, sink %u)\\n\",\n\t\t\t__func__,\n\t\t\tsource_fmt->format.height, sink_fmt->format.height);\n\t\tpass = false;\n\t}\n\n\tif (source_fmt->format.code != sink_fmt->format.code) {\n\t\tdev_dbg(sd->entity.graph_obj.mdev->dev,\n\t\t\t\"%s: media bus code does not match (source 0x%8.8x, sink 0x%8.8x)\\n\",\n\t\t\t__func__,\n\t\t\tsource_fmt->format.code, sink_fmt->format.code);\n\t\tpass = false;\n\t}\n\n\t \n\tif (source_fmt->format.field != sink_fmt->format.field &&\n\t    sink_fmt->format.field != V4L2_FIELD_NONE) {\n\t\tdev_dbg(sd->entity.graph_obj.mdev->dev,\n\t\t\t\"%s: field does not match (source %u, sink %u)\\n\",\n\t\t\t__func__,\n\t\t\tsource_fmt->format.field, sink_fmt->format.field);\n\t\tpass = false;\n\t}\n\n\tif (pass)\n\t\treturn 0;\n\n\tdev_dbg(sd->entity.graph_obj.mdev->dev,\n\t\t\"%s: link was \\\"%s\\\":%u -> \\\"%s\\\":%u\\n\", __func__,\n\t\tlink->source->entity->name, link->source->index,\n\t\tlink->sink->entity->name, link->sink->index);\n\n\treturn -EPIPE;\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_link_validate_default);\n\nstatic int\nv4l2_subdev_link_validate_get_format(struct media_pad *pad, u32 stream,\n\t\t\t\t     struct v4l2_subdev_format *fmt,\n\t\t\t\t     bool states_locked)\n{\n\tstruct v4l2_subdev_state *state;\n\tstruct v4l2_subdev *sd;\n\tint ret;\n\n\tif (!is_media_entity_v4l2_subdev(pad->entity)) {\n\t\tWARN(pad->entity->function != MEDIA_ENT_F_IO_V4L,\n\t\t     \"Driver bug! Wrong media entity type 0x%08x, entity %s\\n\",\n\t\t     pad->entity->function, pad->entity->name);\n\n\t\treturn -EINVAL;\n\t}\n\n\tsd = media_entity_to_v4l2_subdev(pad->entity);\n\n\tfmt->which = V4L2_SUBDEV_FORMAT_ACTIVE;\n\tfmt->pad = pad->index;\n\tfmt->stream = stream;\n\n\tif (states_locked)\n\t\tstate = v4l2_subdev_get_locked_active_state(sd);\n\telse\n\t\tstate = v4l2_subdev_lock_and_get_active_state(sd);\n\n\tret = v4l2_subdev_call(sd, pad, get_fmt, state, fmt);\n\n\tif (!states_locked && state)\n\t\tv4l2_subdev_unlock_state(state);\n\n\treturn ret;\n}\n\n#if defined(CONFIG_VIDEO_V4L2_SUBDEV_API)\n\nstatic void __v4l2_link_validate_get_streams(struct media_pad *pad,\n\t\t\t\t\t     u64 *streams_mask,\n\t\t\t\t\t     bool states_locked)\n{\n\tstruct v4l2_subdev_route *route;\n\tstruct v4l2_subdev_state *state;\n\tstruct v4l2_subdev *subdev;\n\n\tsubdev = media_entity_to_v4l2_subdev(pad->entity);\n\n\t*streams_mask = 0;\n\n\tif (states_locked)\n\t\tstate = v4l2_subdev_get_locked_active_state(subdev);\n\telse\n\t\tstate = v4l2_subdev_lock_and_get_active_state(subdev);\n\n\tif (WARN_ON(!state))\n\t\treturn;\n\n\tfor_each_active_route(&state->routing, route) {\n\t\tu32 route_pad;\n\t\tu32 route_stream;\n\n\t\tif (pad->flags & MEDIA_PAD_FL_SOURCE) {\n\t\t\troute_pad = route->source_pad;\n\t\t\troute_stream = route->source_stream;\n\t\t} else {\n\t\t\troute_pad = route->sink_pad;\n\t\t\troute_stream = route->sink_stream;\n\t\t}\n\n\t\tif (route_pad != pad->index)\n\t\t\tcontinue;\n\n\t\t*streams_mask |= BIT_ULL(route_stream);\n\t}\n\n\tif (!states_locked)\n\t\tv4l2_subdev_unlock_state(state);\n}\n\n#endif  \n\nstatic void v4l2_link_validate_get_streams(struct media_pad *pad,\n\t\t\t\t\t   u64 *streams_mask,\n\t\t\t\t\t   bool states_locked)\n{\n\tstruct v4l2_subdev *subdev = media_entity_to_v4l2_subdev(pad->entity);\n\n\tif (!(subdev->flags & V4L2_SUBDEV_FL_STREAMS)) {\n\t\t \n\t\t*streams_mask = BIT_ULL(0);\n\t\treturn;\n\t}\n\n#if defined(CONFIG_VIDEO_V4L2_SUBDEV_API)\n\t__v4l2_link_validate_get_streams(pad, streams_mask, states_locked);\n#else\n\t \n\t*streams_mask = 0;\n#endif\n}\n\nstatic int v4l2_subdev_link_validate_locked(struct media_link *link, bool states_locked)\n{\n\tstruct v4l2_subdev *sink_subdev =\n\t\tmedia_entity_to_v4l2_subdev(link->sink->entity);\n\tstruct device *dev = sink_subdev->entity.graph_obj.mdev->dev;\n\tu64 source_streams_mask;\n\tu64 sink_streams_mask;\n\tu64 dangling_sink_streams;\n\tu32 stream;\n\tint ret;\n\n\tdev_dbg(dev, \"validating link \\\"%s\\\":%u -> \\\"%s\\\":%u\\n\",\n\t\tlink->source->entity->name, link->source->index,\n\t\tlink->sink->entity->name, link->sink->index);\n\n\tv4l2_link_validate_get_streams(link->source, &source_streams_mask, states_locked);\n\tv4l2_link_validate_get_streams(link->sink, &sink_streams_mask, states_locked);\n\n\t \n\tdangling_sink_streams = (source_streams_mask ^ sink_streams_mask) &\n\t\t\t\tsink_streams_mask;\n\tif (dangling_sink_streams) {\n\t\tdev_err(dev, \"Dangling sink streams: mask %#llx\\n\",\n\t\t\tdangling_sink_streams);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tfor (stream = 0; stream < sizeof(sink_streams_mask) * 8; ++stream) {\n\t\tstruct v4l2_subdev_format sink_fmt, source_fmt;\n\n\t\tif (!(sink_streams_mask & BIT_ULL(stream)))\n\t\t\tcontinue;\n\n\t\tdev_dbg(dev, \"validating stream \\\"%s\\\":%u:%u -> \\\"%s\\\":%u:%u\\n\",\n\t\t\tlink->source->entity->name, link->source->index, stream,\n\t\t\tlink->sink->entity->name, link->sink->index, stream);\n\n\t\tret = v4l2_subdev_link_validate_get_format(link->source, stream,\n\t\t\t\t\t\t\t   &source_fmt, states_locked);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"Failed to get format for \\\"%s\\\":%u:%u (but that's ok)\\n\",\n\t\t\t\tlink->source->entity->name, link->source->index,\n\t\t\t\tstream);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = v4l2_subdev_link_validate_get_format(link->sink, stream,\n\t\t\t\t\t\t\t   &sink_fmt, states_locked);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"Failed to get format for \\\"%s\\\":%u:%u (but that's ok)\\n\",\n\t\t\t\tlink->sink->entity->name, link->sink->index,\n\t\t\t\tstream);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tret = v4l2_subdev_call(sink_subdev, pad, link_validate, link,\n\t\t\t\t       &source_fmt, &sink_fmt);\n\t\tif (!ret)\n\t\t\tcontinue;\n\n\t\tif (ret != -ENOIOCTLCMD)\n\t\t\treturn ret;\n\n\t\tret = v4l2_subdev_link_validate_default(sink_subdev, link,\n\t\t\t\t\t\t\t&source_fmt, &sink_fmt);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint v4l2_subdev_link_validate(struct media_link *link)\n{\n\tstruct v4l2_subdev *source_sd, *sink_sd;\n\tstruct v4l2_subdev_state *source_state, *sink_state;\n\tbool states_locked;\n\tint ret;\n\n\tif (!is_media_entity_v4l2_subdev(link->sink->entity) ||\n\t    !is_media_entity_v4l2_subdev(link->source->entity)) {\n\t\tpr_warn_once(\"%s of link '%s':%u->'%s':%u is not a V4L2 sub-device, driver bug!\\n\",\n\t\t\t     !is_media_entity_v4l2_subdev(link->sink->entity) ?\n\t\t\t     \"sink\" : \"source\",\n\t\t\t     link->source->entity->name, link->source->index,\n\t\t\t     link->sink->entity->name, link->sink->index);\n\t\treturn 0;\n\t}\n\n\tsink_sd = media_entity_to_v4l2_subdev(link->sink->entity);\n\tsource_sd = media_entity_to_v4l2_subdev(link->source->entity);\n\n\tsink_state = v4l2_subdev_get_unlocked_active_state(sink_sd);\n\tsource_state = v4l2_subdev_get_unlocked_active_state(source_sd);\n\n\tstates_locked = sink_state && source_state;\n\n\tif (states_locked) {\n\t\tv4l2_subdev_lock_state(sink_state);\n\t\tv4l2_subdev_lock_state(source_state);\n\t}\n\n\tret = v4l2_subdev_link_validate_locked(link, states_locked);\n\n\tif (states_locked) {\n\t\tv4l2_subdev_unlock_state(sink_state);\n\t\tv4l2_subdev_unlock_state(source_state);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_link_validate);\n\nbool v4l2_subdev_has_pad_interdep(struct media_entity *entity,\n\t\t\t\t  unsigned int pad0, unsigned int pad1)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct v4l2_subdev_krouting *routing;\n\tstruct v4l2_subdev_state *state;\n\tunsigned int i;\n\n\tstate = v4l2_subdev_lock_and_get_active_state(sd);\n\n\trouting = &state->routing;\n\n\tfor (i = 0; i < routing->num_routes; ++i) {\n\t\tstruct v4l2_subdev_route *route = &routing->routes[i];\n\n\t\tif (!(route->flags & V4L2_SUBDEV_ROUTE_FL_ACTIVE))\n\t\t\tcontinue;\n\n\t\tif ((route->sink_pad == pad0 && route->source_pad == pad1) ||\n\t\t    (route->source_pad == pad0 && route->sink_pad == pad1)) {\n\t\t\tv4l2_subdev_unlock_state(state);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tv4l2_subdev_unlock_state(state);\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_has_pad_interdep);\n\nstruct v4l2_subdev_state *\n__v4l2_subdev_state_alloc(struct v4l2_subdev *sd, const char *lock_name,\n\t\t\t  struct lock_class_key *lock_key)\n{\n\tstruct v4l2_subdev_state *state;\n\tint ret;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t__mutex_init(&state->_lock, lock_name, lock_key);\n\tif (sd->state_lock)\n\t\tstate->lock = sd->state_lock;\n\telse\n\t\tstate->lock = &state->_lock;\n\n\t \n\tif (!(sd->flags & V4L2_SUBDEV_FL_STREAMS) && sd->entity.num_pads) {\n\t\tstate->pads = kvcalloc(sd->entity.num_pads,\n\t\t\t\t       sizeof(*state->pads), GFP_KERNEL);\n\t\tif (!state->pads) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\tv4l2_subdev_lock_state(state);\n\tret = v4l2_subdev_call(sd, pad, init_cfg, state);\n\tv4l2_subdev_unlock_state(state);\n\n\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\tgoto err;\n\n\treturn state;\n\nerr:\n\tif (state && state->pads)\n\t\tkvfree(state->pads);\n\n\tkfree(state);\n\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(__v4l2_subdev_state_alloc);\n\nvoid __v4l2_subdev_state_free(struct v4l2_subdev_state *state)\n{\n\tif (!state)\n\t\treturn;\n\n\tmutex_destroy(&state->_lock);\n\n\tkfree(state->routing.routes);\n\tkvfree(state->stream_configs.configs);\n\tkvfree(state->pads);\n\tkfree(state);\n}\nEXPORT_SYMBOL_GPL(__v4l2_subdev_state_free);\n\nint __v4l2_subdev_init_finalize(struct v4l2_subdev *sd, const char *name,\n\t\t\t\tstruct lock_class_key *key)\n{\n\tstruct v4l2_subdev_state *state;\n\n\tstate = __v4l2_subdev_state_alloc(sd, name, key);\n\tif (IS_ERR(state))\n\t\treturn PTR_ERR(state);\n\n\tsd->active_state = state;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__v4l2_subdev_init_finalize);\n\nvoid v4l2_subdev_cleanup(struct v4l2_subdev *sd)\n{\n\tstruct v4l2_async_subdev_endpoint *ase, *ase_tmp;\n\n\t__v4l2_subdev_state_free(sd->active_state);\n\tsd->active_state = NULL;\n\n\tif (list_empty(&sd->async_subdev_endpoint_list))\n\t\treturn;\n\n\tlist_for_each_entry_safe(ase, ase_tmp, &sd->async_subdev_endpoint_list,\n\t\t\t\t async_subdev_endpoint_entry) {\n\t\tlist_del(&ase->async_subdev_endpoint_entry);\n\n\t\tkfree(ase);\n\t}\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_cleanup);\n\n#if defined(CONFIG_VIDEO_V4L2_SUBDEV_API)\n\nstatic int\nv4l2_subdev_init_stream_configs(struct v4l2_subdev_stream_configs *stream_configs,\n\t\t\t\tconst struct v4l2_subdev_krouting *routing)\n{\n\tstruct v4l2_subdev_stream_configs new_configs = { 0 };\n\tstruct v4l2_subdev_route *route;\n\tu32 idx;\n\n\t \n\tfor_each_active_route(routing, route) {\n\t\t \n\t\tnew_configs.num_configs += 2;\n\t}\n\n\tif (new_configs.num_configs) {\n\t\tnew_configs.configs = kvcalloc(new_configs.num_configs,\n\t\t\t\t\t       sizeof(*new_configs.configs),\n\t\t\t\t\t       GFP_KERNEL);\n\n\t\tif (!new_configs.configs)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tidx = 0;\n\n\tfor_each_active_route(routing, route) {\n\t\tnew_configs.configs[idx].pad = route->sink_pad;\n\t\tnew_configs.configs[idx].stream = route->sink_stream;\n\n\t\tidx++;\n\n\t\tnew_configs.configs[idx].pad = route->source_pad;\n\t\tnew_configs.configs[idx].stream = route->source_stream;\n\n\t\tidx++;\n\t}\n\n\tkvfree(stream_configs->configs);\n\t*stream_configs = new_configs;\n\n\treturn 0;\n}\n\nint v4l2_subdev_get_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_state *state,\n\t\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *fmt;\n\n\tif (sd->flags & V4L2_SUBDEV_FL_STREAMS)\n\t\tfmt = v4l2_subdev_state_get_stream_format(state, format->pad,\n\t\t\t\t\t\t\t  format->stream);\n\telse if (format->pad < sd->entity.num_pads && format->stream == 0)\n\t\tfmt = v4l2_subdev_get_pad_format(sd, state, format->pad);\n\telse\n\t\tfmt = NULL;\n\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tformat->format = *fmt;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_get_fmt);\n\nint v4l2_subdev_set_routing(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *state,\n\t\t\t    const struct v4l2_subdev_krouting *routing)\n{\n\tstruct v4l2_subdev_krouting *dst = &state->routing;\n\tconst struct v4l2_subdev_krouting *src = routing;\n\tstruct v4l2_subdev_krouting new_routing = { 0 };\n\tsize_t bytes;\n\tint r;\n\n\tif (unlikely(check_mul_overflow((size_t)src->num_routes,\n\t\t\t\t\tsizeof(*src->routes), &bytes)))\n\t\treturn -EOVERFLOW;\n\n\tlockdep_assert_held(state->lock);\n\n\tif (src->num_routes > 0) {\n\t\tnew_routing.routes = kmemdup(src->routes, bytes, GFP_KERNEL);\n\t\tif (!new_routing.routes)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tnew_routing.num_routes = src->num_routes;\n\n\tr = v4l2_subdev_init_stream_configs(&state->stream_configs,\n\t\t\t\t\t    &new_routing);\n\tif (r) {\n\t\tkfree(new_routing.routes);\n\t\treturn r;\n\t}\n\n\tkfree(dst->routes);\n\t*dst = new_routing;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_set_routing);\n\nstruct v4l2_subdev_route *\n__v4l2_subdev_next_active_route(const struct v4l2_subdev_krouting *routing,\n\t\t\t\tstruct v4l2_subdev_route *route)\n{\n\tif (route)\n\t\t++route;\n\telse\n\t\troute = &routing->routes[0];\n\n\tfor (; route < routing->routes + routing->num_routes; ++route) {\n\t\tif (!(route->flags & V4L2_SUBDEV_ROUTE_FL_ACTIVE))\n\t\t\tcontinue;\n\n\t\treturn route;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(__v4l2_subdev_next_active_route);\n\nint v4l2_subdev_set_routing_with_fmt(struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_subdev_state *state,\n\t\t\t\t     const struct v4l2_subdev_krouting *routing,\n\t\t\t\t     const struct v4l2_mbus_framefmt *fmt)\n{\n\tstruct v4l2_subdev_stream_configs *stream_configs;\n\tunsigned int i;\n\tint ret;\n\n\tret = v4l2_subdev_set_routing(sd, state, routing);\n\tif (ret)\n\t\treturn ret;\n\n\tstream_configs = &state->stream_configs;\n\n\tfor (i = 0; i < stream_configs->num_configs; ++i)\n\t\tstream_configs->configs[i].fmt = *fmt;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_set_routing_with_fmt);\n\nstruct v4l2_mbus_framefmt *\nv4l2_subdev_state_get_stream_format(struct v4l2_subdev_state *state,\n\t\t\t\t    unsigned int pad, u32 stream)\n{\n\tstruct v4l2_subdev_stream_configs *stream_configs;\n\tunsigned int i;\n\n\tlockdep_assert_held(state->lock);\n\n\tstream_configs = &state->stream_configs;\n\n\tfor (i = 0; i < stream_configs->num_configs; ++i) {\n\t\tif (stream_configs->configs[i].pad == pad &&\n\t\t    stream_configs->configs[i].stream == stream)\n\t\t\treturn &stream_configs->configs[i].fmt;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_state_get_stream_format);\n\nstruct v4l2_rect *\nv4l2_subdev_state_get_stream_crop(struct v4l2_subdev_state *state,\n\t\t\t\t  unsigned int pad, u32 stream)\n{\n\tstruct v4l2_subdev_stream_configs *stream_configs;\n\tunsigned int i;\n\n\tlockdep_assert_held(state->lock);\n\n\tstream_configs = &state->stream_configs;\n\n\tfor (i = 0; i < stream_configs->num_configs; ++i) {\n\t\tif (stream_configs->configs[i].pad == pad &&\n\t\t    stream_configs->configs[i].stream == stream)\n\t\t\treturn &stream_configs->configs[i].crop;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_state_get_stream_crop);\n\nstruct v4l2_rect *\nv4l2_subdev_state_get_stream_compose(struct v4l2_subdev_state *state,\n\t\t\t\t     unsigned int pad, u32 stream)\n{\n\tstruct v4l2_subdev_stream_configs *stream_configs;\n\tunsigned int i;\n\n\tlockdep_assert_held(state->lock);\n\n\tstream_configs = &state->stream_configs;\n\n\tfor (i = 0; i < stream_configs->num_configs; ++i) {\n\t\tif (stream_configs->configs[i].pad == pad &&\n\t\t    stream_configs->configs[i].stream == stream)\n\t\t\treturn &stream_configs->configs[i].compose;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_state_get_stream_compose);\n\nint v4l2_subdev_routing_find_opposite_end(const struct v4l2_subdev_krouting *routing,\n\t\t\t\t\t  u32 pad, u32 stream, u32 *other_pad,\n\t\t\t\t\t  u32 *other_stream)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < routing->num_routes; ++i) {\n\t\tstruct v4l2_subdev_route *route = &routing->routes[i];\n\n\t\tif (route->source_pad == pad &&\n\t\t    route->source_stream == stream) {\n\t\t\tif (other_pad)\n\t\t\t\t*other_pad = route->sink_pad;\n\t\t\tif (other_stream)\n\t\t\t\t*other_stream = route->sink_stream;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (route->sink_pad == pad && route->sink_stream == stream) {\n\t\t\tif (other_pad)\n\t\t\t\t*other_pad = route->source_pad;\n\t\t\tif (other_stream)\n\t\t\t\t*other_stream = route->source_stream;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_routing_find_opposite_end);\n\nstruct v4l2_mbus_framefmt *\nv4l2_subdev_state_get_opposite_stream_format(struct v4l2_subdev_state *state,\n\t\t\t\t\t     u32 pad, u32 stream)\n{\n\tu32 other_pad, other_stream;\n\tint ret;\n\n\tret = v4l2_subdev_routing_find_opposite_end(&state->routing,\n\t\t\t\t\t\t    pad, stream,\n\t\t\t\t\t\t    &other_pad, &other_stream);\n\tif (ret)\n\t\treturn NULL;\n\n\treturn v4l2_subdev_state_get_stream_format(state, other_pad,\n\t\t\t\t\t\t   other_stream);\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_state_get_opposite_stream_format);\n\nu64 v4l2_subdev_state_xlate_streams(const struct v4l2_subdev_state *state,\n\t\t\t\t    u32 pad0, u32 pad1, u64 *streams)\n{\n\tconst struct v4l2_subdev_krouting *routing = &state->routing;\n\tstruct v4l2_subdev_route *route;\n\tu64 streams0 = 0;\n\tu64 streams1 = 0;\n\n\tfor_each_active_route(routing, route) {\n\t\tif (route->sink_pad == pad0 && route->source_pad == pad1 &&\n\t\t    (*streams & BIT_ULL(route->sink_stream))) {\n\t\t\tstreams0 |= BIT_ULL(route->sink_stream);\n\t\t\tstreams1 |= BIT_ULL(route->source_stream);\n\t\t}\n\t\tif (route->source_pad == pad0 && route->sink_pad == pad1 &&\n\t\t    (*streams & BIT_ULL(route->source_stream))) {\n\t\t\tstreams0 |= BIT_ULL(route->source_stream);\n\t\t\tstreams1 |= BIT_ULL(route->sink_stream);\n\t\t}\n\t}\n\n\t*streams = streams0;\n\treturn streams1;\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_state_xlate_streams);\n\nint v4l2_subdev_routing_validate(struct v4l2_subdev *sd,\n\t\t\t\t const struct v4l2_subdev_krouting *routing,\n\t\t\t\t enum v4l2_subdev_routing_restriction disallow)\n{\n\tu32 *remote_pads = NULL;\n\tunsigned int i, j;\n\tint ret = -EINVAL;\n\n\tif (disallow & (V4L2_SUBDEV_ROUTING_NO_STREAM_MIX |\n\t\t\tV4L2_SUBDEV_ROUTING_NO_MULTIPLEXING)) {\n\t\tremote_pads = kcalloc(sd->entity.num_pads, sizeof(*remote_pads),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!remote_pads)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < sd->entity.num_pads; ++i)\n\t\t\tremote_pads[i] = U32_MAX;\n\t}\n\n\tfor (i = 0; i < routing->num_routes; ++i) {\n\t\tconst struct v4l2_subdev_route *route = &routing->routes[i];\n\n\t\t \n\t\tif (route->sink_pad >= sd->entity.num_pads ||\n\t\t    !(sd->entity.pads[route->sink_pad].flags & MEDIA_PAD_FL_SINK)) {\n\t\t\tdev_dbg(sd->dev, \"route %u sink (%u) is not a sink pad\\n\",\n\t\t\t\ti, route->sink_pad);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (route->source_pad >= sd->entity.num_pads ||\n\t\t    !(sd->entity.pads[route->source_pad].flags & MEDIA_PAD_FL_SOURCE)) {\n\t\t\tdev_dbg(sd->dev, \"route %u source (%u) is not a source pad\\n\",\n\t\t\t\ti, route->source_pad);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (disallow & V4L2_SUBDEV_ROUTING_NO_SINK_STREAM_MIX) {\n\t\t\tif (remote_pads[route->sink_pad] != U32_MAX &&\n\t\t\t    remote_pads[route->sink_pad] != route->source_pad) {\n\t\t\t\tdev_dbg(sd->dev,\n\t\t\t\t\t\"route %u attempts to mix %s streams\\n\",\n\t\t\t\t\ti, \"sink\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (disallow & V4L2_SUBDEV_ROUTING_NO_SOURCE_STREAM_MIX) {\n\t\t\tif (remote_pads[route->source_pad] != U32_MAX &&\n\t\t\t    remote_pads[route->source_pad] != route->sink_pad) {\n\t\t\t\tdev_dbg(sd->dev,\n\t\t\t\t\t\"route %u attempts to mix %s streams\\n\",\n\t\t\t\t\ti, \"source\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (disallow & V4L2_SUBDEV_ROUTING_NO_SINK_MULTIPLEXING) {\n\t\t\tif (remote_pads[route->sink_pad] != U32_MAX) {\n\t\t\t\tdev_dbg(sd->dev,\n\t\t\t\t\t\"route %u attempts to multiplex on %s pad %u\\n\",\n\t\t\t\t\ti, \"sink\", route->sink_pad);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (disallow & V4L2_SUBDEV_ROUTING_NO_SOURCE_MULTIPLEXING) {\n\t\t\tif (remote_pads[route->source_pad] != U32_MAX) {\n\t\t\t\tdev_dbg(sd->dev,\n\t\t\t\t\t\"route %u attempts to multiplex on %s pad %u\\n\",\n\t\t\t\t\ti, \"source\", route->source_pad);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (remote_pads) {\n\t\t\tremote_pads[route->sink_pad] = route->source_pad;\n\t\t\tremote_pads[route->source_pad] = route->sink_pad;\n\t\t}\n\n\t\tfor (j = i + 1; j < routing->num_routes; ++j) {\n\t\t\tconst struct v4l2_subdev_route *r = &routing->routes[j];\n\n\t\t\t \n\t\t\tif ((disallow & V4L2_SUBDEV_ROUTING_NO_1_TO_N) &&\n\t\t\t    route->sink_pad == r->sink_pad &&\n\t\t\t    route->sink_stream == r->sink_stream) {\n\t\t\t\tdev_dbg(sd->dev,\n\t\t\t\t\t\"routes %u and %u originate from same sink (%u/%u)\\n\",\n\t\t\t\t\ti, j, route->sink_pad,\n\t\t\t\t\troute->sink_stream);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((disallow & V4L2_SUBDEV_ROUTING_NO_N_TO_1) &&\n\t\t\t    route->source_pad == r->source_pad &&\n\t\t\t    route->source_stream == r->source_stream) {\n\t\t\t\tdev_dbg(sd->dev,\n\t\t\t\t\t\"routes %u and %u end at same source (%u/%u)\\n\",\n\t\t\t\t\ti, j, route->source_pad,\n\t\t\t\t\troute->source_stream);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = 0;\n\nout:\n\tkfree(remote_pads);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_routing_validate);\n\nstatic int v4l2_subdev_enable_streams_fallback(struct v4l2_subdev *sd, u32 pad,\n\t\t\t\t\t       u64 streams_mask)\n{\n\tstruct device *dev = sd->entity.graph_obj.mdev->dev;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tif (!(sd->entity.pads[pad].flags & MEDIA_PAD_FL_SOURCE))\n\t\treturn -EOPNOTSUPP;\n\n\tfor (i = 0; i < sd->entity.num_pads; ++i) {\n\t\tif (i != pad && sd->entity.pads[i].flags & MEDIA_PAD_FL_SOURCE)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (sd->enabled_streams & streams_mask) {\n\t\tdev_dbg(dev, \"set of streams %#llx already enabled on %s:%u\\n\",\n\t\t\tstreams_mask, sd->entity.name, pad);\n\t\treturn -EALREADY;\n\t}\n\n\t \n\tif (!sd->enabled_streams) {\n\t\tret = v4l2_subdev_call(sd, video, s_stream, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tsd->enabled_streams |= streams_mask;\n\n\treturn 0;\n}\n\nint v4l2_subdev_enable_streams(struct v4l2_subdev *sd, u32 pad,\n\t\t\t       u64 streams_mask)\n{\n\tstruct device *dev = sd->entity.graph_obj.mdev->dev;\n\tstruct v4l2_subdev_state *state;\n\tu64 found_streams = 0;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tif (pad >= sd->entity.num_pads)\n\t\treturn -EINVAL;\n\n\tif (!streams_mask)\n\t\treturn 0;\n\n\t \n\tif (!sd->ops->pad || !sd->ops->pad->enable_streams)\n\t\treturn v4l2_subdev_enable_streams_fallback(sd, pad,\n\t\t\t\t\t\t\t   streams_mask);\n\n\tstate = v4l2_subdev_lock_and_get_active_state(sd);\n\n\t \n\tfor (i = 0; i < state->stream_configs.num_configs; ++i) {\n\t\tstruct v4l2_subdev_stream_config *cfg =\n\t\t\t&state->stream_configs.configs[i];\n\n\t\tif (cfg->pad != pad || !(streams_mask & BIT_ULL(cfg->stream)))\n\t\t\tcontinue;\n\n\t\tfound_streams |= BIT_ULL(cfg->stream);\n\n\t\tif (cfg->enabled) {\n\t\t\tdev_dbg(dev, \"stream %u already enabled on %s:%u\\n\",\n\t\t\t\tcfg->stream, sd->entity.name, pad);\n\t\t\tret = -EALREADY;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (found_streams != streams_mask) {\n\t\tdev_dbg(dev, \"streams 0x%llx not found on %s:%u\\n\",\n\t\t\tstreams_mask & ~found_streams, sd->entity.name, pad);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tdev_dbg(dev, \"enable streams %u:%#llx\\n\", pad, streams_mask);\n\n\t \n\tret = v4l2_subdev_call(sd, pad, enable_streams, state, pad,\n\t\t\t       streams_mask);\n\tif (ret) {\n\t\tdev_dbg(dev, \"enable streams %u:%#llx failed: %d\\n\", pad,\n\t\t\tstreams_mask, ret);\n\t\tgoto done;\n\t}\n\n\t \n\tfor (i = 0; i < state->stream_configs.num_configs; ++i) {\n\t\tstruct v4l2_subdev_stream_config *cfg =\n\t\t\t&state->stream_configs.configs[i];\n\n\t\tif (cfg->pad == pad && (streams_mask & BIT_ULL(cfg->stream)))\n\t\t\tcfg->enabled = true;\n\t}\n\ndone:\n\tv4l2_subdev_unlock_state(state);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_enable_streams);\n\nstatic int v4l2_subdev_disable_streams_fallback(struct v4l2_subdev *sd, u32 pad,\n\t\t\t\t\t\tu64 streams_mask)\n{\n\tstruct device *dev = sd->entity.graph_obj.mdev->dev;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tif (!(sd->entity.pads[pad].flags & MEDIA_PAD_FL_SOURCE))\n\t\treturn -EOPNOTSUPP;\n\n\tfor (i = 0; i < sd->entity.num_pads; ++i) {\n\t\tif (i != pad && sd->entity.pads[i].flags & MEDIA_PAD_FL_SOURCE)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((sd->enabled_streams & streams_mask) != streams_mask) {\n\t\tdev_dbg(dev, \"set of streams %#llx already disabled on %s:%u\\n\",\n\t\t\tstreams_mask, sd->entity.name, pad);\n\t\treturn -EALREADY;\n\t}\n\n\t \n\tif (!(sd->enabled_streams & ~streams_mask)) {\n\t\tret = v4l2_subdev_call(sd, video, s_stream, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tsd->enabled_streams &= ~streams_mask;\n\n\treturn 0;\n}\n\nint v4l2_subdev_disable_streams(struct v4l2_subdev *sd, u32 pad,\n\t\t\t\tu64 streams_mask)\n{\n\tstruct device *dev = sd->entity.graph_obj.mdev->dev;\n\tstruct v4l2_subdev_state *state;\n\tu64 found_streams = 0;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tif (pad >= sd->entity.num_pads)\n\t\treturn -EINVAL;\n\n\tif (!streams_mask)\n\t\treturn 0;\n\n\t \n\tif (!sd->ops->pad || !sd->ops->pad->disable_streams)\n\t\treturn v4l2_subdev_disable_streams_fallback(sd, pad,\n\t\t\t\t\t\t\t    streams_mask);\n\n\tstate = v4l2_subdev_lock_and_get_active_state(sd);\n\n\t \n\tfor (i = 0; i < state->stream_configs.num_configs; ++i) {\n\t\tstruct v4l2_subdev_stream_config *cfg =\n\t\t\t&state->stream_configs.configs[i];\n\n\t\tif (cfg->pad != pad || !(streams_mask & BIT_ULL(cfg->stream)))\n\t\t\tcontinue;\n\n\t\tfound_streams |= BIT_ULL(cfg->stream);\n\n\t\tif (!cfg->enabled) {\n\t\t\tdev_dbg(dev, \"stream %u already disabled on %s:%u\\n\",\n\t\t\t\tcfg->stream, sd->entity.name, pad);\n\t\t\tret = -EALREADY;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (found_streams != streams_mask) {\n\t\tdev_dbg(dev, \"streams 0x%llx not found on %s:%u\\n\",\n\t\t\tstreams_mask & ~found_streams, sd->entity.name, pad);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tdev_dbg(dev, \"disable streams %u:%#llx\\n\", pad, streams_mask);\n\n\t \n\tret = v4l2_subdev_call(sd, pad, disable_streams, state, pad,\n\t\t\t       streams_mask);\n\tif (ret) {\n\t\tdev_dbg(dev, \"disable streams %u:%#llx failed: %d\\n\", pad,\n\t\t\tstreams_mask, ret);\n\t\tgoto done;\n\t}\n\n\t \n\tfor (i = 0; i < state->stream_configs.num_configs; ++i) {\n\t\tstruct v4l2_subdev_stream_config *cfg =\n\t\t\t&state->stream_configs.configs[i];\n\n\t\tif (cfg->pad == pad && (streams_mask & BIT_ULL(cfg->stream)))\n\t\t\tcfg->enabled = false;\n\t}\n\ndone:\n\tv4l2_subdev_unlock_state(state);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_disable_streams);\n\nint v4l2_subdev_s_stream_helper(struct v4l2_subdev *sd, int enable)\n{\n\tstruct v4l2_subdev_state *state;\n\tstruct v4l2_subdev_route *route;\n\tstruct media_pad *pad;\n\tu64 source_mask = 0;\n\tint pad_index = -1;\n\n\t \n\tmedia_entity_for_each_pad(&sd->entity, pad) {\n\t\tif (pad->flags & MEDIA_PAD_FL_SOURCE) {\n\t\t\tpad_index = pad->index;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN_ON(pad_index == -1))\n\t\treturn -EINVAL;\n\n\t \n\tstate = v4l2_subdev_lock_and_get_active_state(sd);\n\n\tfor_each_active_route(&state->routing, route)\n\t\tsource_mask |= BIT_ULL(route->source_stream);\n\n\tv4l2_subdev_unlock_state(state);\n\n\tif (enable)\n\t\treturn v4l2_subdev_enable_streams(sd, pad_index, source_mask);\n\telse\n\t\treturn v4l2_subdev_disable_streams(sd, pad_index, source_mask);\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_s_stream_helper);\n\n#endif  \n\n#endif  \n\nvoid v4l2_subdev_init(struct v4l2_subdev *sd, const struct v4l2_subdev_ops *ops)\n{\n\tINIT_LIST_HEAD(&sd->list);\n\tBUG_ON(!ops);\n\tsd->ops = ops;\n\tsd->v4l2_dev = NULL;\n\tsd->flags = 0;\n\tsd->name[0] = '\\0';\n\tsd->grp_id = 0;\n\tsd->dev_priv = NULL;\n\tsd->host_priv = NULL;\n\tsd->privacy_led = NULL;\n\tINIT_LIST_HEAD(&sd->async_subdev_endpoint_list);\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tsd->entity.name = sd->name;\n\tsd->entity.obj_type = MEDIA_ENTITY_TYPE_V4L2_SUBDEV;\n\tsd->entity.function = MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN;\n#endif\n}\nEXPORT_SYMBOL(v4l2_subdev_init);\n\nvoid v4l2_subdev_notify_event(struct v4l2_subdev *sd,\n\t\t\t      const struct v4l2_event *ev)\n{\n\tv4l2_event_queue(sd->devnode, ev);\n\tv4l2_subdev_notify(sd, V4L2_DEVICE_NOTIFY_EVENT, (void *)ev);\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_notify_event);\n\nint v4l2_subdev_get_privacy_led(struct v4l2_subdev *sd)\n{\n#if IS_REACHABLE(CONFIG_LEDS_CLASS)\n\tsd->privacy_led = led_get(sd->dev, \"privacy-led\");\n\tif (IS_ERR(sd->privacy_led) && PTR_ERR(sd->privacy_led) != -ENOENT)\n\t\treturn dev_err_probe(sd->dev, PTR_ERR(sd->privacy_led),\n\t\t\t\t     \"getting privacy LED\\n\");\n\n\tif (!IS_ERR_OR_NULL(sd->privacy_led)) {\n\t\tmutex_lock(&sd->privacy_led->led_access);\n\t\tled_sysfs_disable(sd->privacy_led);\n\t\tled_trigger_remove(sd->privacy_led);\n\t\tled_set_brightness(sd->privacy_led, 0);\n\t\tmutex_unlock(&sd->privacy_led->led_access);\n\t}\n#endif\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_get_privacy_led);\n\nvoid v4l2_subdev_put_privacy_led(struct v4l2_subdev *sd)\n{\n#if IS_REACHABLE(CONFIG_LEDS_CLASS)\n\tif (!IS_ERR_OR_NULL(sd->privacy_led)) {\n\t\tmutex_lock(&sd->privacy_led->led_access);\n\t\tled_sysfs_enable(sd->privacy_led);\n\t\tmutex_unlock(&sd->privacy_led->led_access);\n\t\tled_put(sd->privacy_led);\n\t}\n#endif\n}\nEXPORT_SYMBOL_GPL(v4l2_subdev_put_privacy_led);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}