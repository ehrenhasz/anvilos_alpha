{
  "module_name": "v4l2-ioctl.c",
  "hash_id": "47a979c1cdad89ea67f3022dbcff6438fc4a35bc6b59326e6f81d4af6fbbcfcb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/v4l2-core/v4l2-ioctl.c",
  "human_readable_source": "\n \n\n#include <linux/compat.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n\n#include <linux/v4l2-subdev.h>\n#include <linux/videodev2.h>\n\n#include <media/media-device.h>  \n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-device.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/v4l2-mc.h>\n#include <media/v4l2-mem2mem.h>\n\n#include <trace/events/v4l2.h>\n\n#define is_valid_ioctl(vfd, cmd) test_bit(_IOC_NR(cmd), (vfd)->valid_ioctls)\n\nstruct std_descr {\n\tv4l2_std_id std;\n\tconst char *descr;\n};\n\nstatic const struct std_descr standards[] = {\n\t{ V4L2_STD_NTSC,\t\"NTSC\"      },\n\t{ V4L2_STD_NTSC_M,\t\"NTSC-M\"    },\n\t{ V4L2_STD_NTSC_M_JP,\t\"NTSC-M-JP\" },\n\t{ V4L2_STD_NTSC_M_KR,\t\"NTSC-M-KR\" },\n\t{ V4L2_STD_NTSC_443,\t\"NTSC-443\"  },\n\t{ V4L2_STD_PAL,\t\t\"PAL\"       },\n\t{ V4L2_STD_PAL_BG,\t\"PAL-BG\"    },\n\t{ V4L2_STD_PAL_B,\t\"PAL-B\"     },\n\t{ V4L2_STD_PAL_B1,\t\"PAL-B1\"    },\n\t{ V4L2_STD_PAL_G,\t\"PAL-G\"     },\n\t{ V4L2_STD_PAL_H,\t\"PAL-H\"     },\n\t{ V4L2_STD_PAL_I,\t\"PAL-I\"     },\n\t{ V4L2_STD_PAL_DK,\t\"PAL-DK\"    },\n\t{ V4L2_STD_PAL_D,\t\"PAL-D\"     },\n\t{ V4L2_STD_PAL_D1,\t\"PAL-D1\"    },\n\t{ V4L2_STD_PAL_K,\t\"PAL-K\"     },\n\t{ V4L2_STD_PAL_M,\t\"PAL-M\"     },\n\t{ V4L2_STD_PAL_N,\t\"PAL-N\"     },\n\t{ V4L2_STD_PAL_Nc,\t\"PAL-Nc\"    },\n\t{ V4L2_STD_PAL_60,\t\"PAL-60\"    },\n\t{ V4L2_STD_SECAM,\t\"SECAM\"     },\n\t{ V4L2_STD_SECAM_B,\t\"SECAM-B\"   },\n\t{ V4L2_STD_SECAM_G,\t\"SECAM-G\"   },\n\t{ V4L2_STD_SECAM_H,\t\"SECAM-H\"   },\n\t{ V4L2_STD_SECAM_DK,\t\"SECAM-DK\"  },\n\t{ V4L2_STD_SECAM_D,\t\"SECAM-D\"   },\n\t{ V4L2_STD_SECAM_K,\t\"SECAM-K\"   },\n\t{ V4L2_STD_SECAM_K1,\t\"SECAM-K1\"  },\n\t{ V4L2_STD_SECAM_L,\t\"SECAM-L\"   },\n\t{ V4L2_STD_SECAM_LC,\t\"SECAM-Lc\"  },\n\t{ 0,\t\t\t\"Unknown\"   }\n};\n\n \nconst char *v4l2_norm_to_name(v4l2_std_id id)\n{\n\tu32 myid = id;\n\tint i;\n\n\t \n\tBUG_ON(myid != id);\n\n\tfor (i = 0; standards[i].std; i++)\n\t\tif (myid == standards[i].std)\n\t\t\tbreak;\n\treturn standards[i].descr;\n}\nEXPORT_SYMBOL(v4l2_norm_to_name);\n\n \nvoid v4l2_video_std_frame_period(int id, struct v4l2_fract *frameperiod)\n{\n\tif (id & V4L2_STD_525_60) {\n\t\tframeperiod->numerator = 1001;\n\t\tframeperiod->denominator = 30000;\n\t} else {\n\t\tframeperiod->numerator = 1;\n\t\tframeperiod->denominator = 25;\n\t}\n}\nEXPORT_SYMBOL(v4l2_video_std_frame_period);\n\n \nint v4l2_video_std_construct(struct v4l2_standard *vs,\n\t\t\t     int id, const char *name)\n{\n\tvs->id = id;\n\tv4l2_video_std_frame_period(id, &vs->frameperiod);\n\tvs->framelines = (id & V4L2_STD_525_60) ? 525 : 625;\n\tstrscpy(vs->name, name, sizeof(vs->name));\n\treturn 0;\n}\nEXPORT_SYMBOL(v4l2_video_std_construct);\n\n \nint v4l_video_std_enumstd(struct v4l2_standard *vs, v4l2_std_id id)\n{\n\tv4l2_std_id curr_id = 0;\n\tunsigned int index = vs->index, i, j = 0;\n\tconst char *descr = \"\";\n\n\t \n\tif (id == 0)\n\t\treturn -ENODATA;\n\n\t \n\tfor (i = 0; i <= index && id; i++) {\n\t\t \n\t\twhile ((id & standards[j].std) != standards[j].std)\n\t\t\tj++;\n\t\tcurr_id = standards[j].std;\n\t\tdescr = standards[j].descr;\n\t\tj++;\n\t\tif (curr_id == 0)\n\t\t\tbreak;\n\t\tif (curr_id != V4L2_STD_PAL &&\n\t\t\t\tcurr_id != V4L2_STD_SECAM &&\n\t\t\t\tcurr_id != V4L2_STD_NTSC)\n\t\t\tid &= ~curr_id;\n\t}\n\tif (i <= index)\n\t\treturn -EINVAL;\n\n\tv4l2_video_std_construct(vs, curr_id, descr);\n\treturn 0;\n}\n\n \n \n\nconst char *v4l2_field_names[] = {\n\t[V4L2_FIELD_ANY]        = \"any\",\n\t[V4L2_FIELD_NONE]       = \"none\",\n\t[V4L2_FIELD_TOP]        = \"top\",\n\t[V4L2_FIELD_BOTTOM]     = \"bottom\",\n\t[V4L2_FIELD_INTERLACED] = \"interlaced\",\n\t[V4L2_FIELD_SEQ_TB]     = \"seq-tb\",\n\t[V4L2_FIELD_SEQ_BT]     = \"seq-bt\",\n\t[V4L2_FIELD_ALTERNATE]  = \"alternate\",\n\t[V4L2_FIELD_INTERLACED_TB] = \"interlaced-tb\",\n\t[V4L2_FIELD_INTERLACED_BT] = \"interlaced-bt\",\n};\nEXPORT_SYMBOL(v4l2_field_names);\n\nconst char *v4l2_type_names[] = {\n\t[0]\t\t\t\t   = \"0\",\n\t[V4L2_BUF_TYPE_VIDEO_CAPTURE]      = \"vid-cap\",\n\t[V4L2_BUF_TYPE_VIDEO_OVERLAY]      = \"vid-overlay\",\n\t[V4L2_BUF_TYPE_VIDEO_OUTPUT]       = \"vid-out\",\n\t[V4L2_BUF_TYPE_VBI_CAPTURE]        = \"vbi-cap\",\n\t[V4L2_BUF_TYPE_VBI_OUTPUT]         = \"vbi-out\",\n\t[V4L2_BUF_TYPE_SLICED_VBI_CAPTURE] = \"sliced-vbi-cap\",\n\t[V4L2_BUF_TYPE_SLICED_VBI_OUTPUT]  = \"sliced-vbi-out\",\n\t[V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY] = \"vid-out-overlay\",\n\t[V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE] = \"vid-cap-mplane\",\n\t[V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE] = \"vid-out-mplane\",\n\t[V4L2_BUF_TYPE_SDR_CAPTURE]        = \"sdr-cap\",\n\t[V4L2_BUF_TYPE_SDR_OUTPUT]         = \"sdr-out\",\n\t[V4L2_BUF_TYPE_META_CAPTURE]       = \"meta-cap\",\n\t[V4L2_BUF_TYPE_META_OUTPUT]\t   = \"meta-out\",\n};\nEXPORT_SYMBOL(v4l2_type_names);\n\nstatic const char *v4l2_memory_names[] = {\n\t[V4L2_MEMORY_MMAP]    = \"mmap\",\n\t[V4L2_MEMORY_USERPTR] = \"userptr\",\n\t[V4L2_MEMORY_OVERLAY] = \"overlay\",\n\t[V4L2_MEMORY_DMABUF] = \"dmabuf\",\n};\n\n#define prt_names(a, arr) (((unsigned)(a)) < ARRAY_SIZE(arr) ? arr[a] : \"unknown\")\n\n \n \n\nstatic void v4l_print_querycap(const void *arg, bool write_only)\n{\n\tconst struct v4l2_capability *p = arg;\n\n\tpr_cont(\"driver=%.*s, card=%.*s, bus=%.*s, version=0x%08x, capabilities=0x%08x, device_caps=0x%08x\\n\",\n\t\t(int)sizeof(p->driver), p->driver,\n\t\t(int)sizeof(p->card), p->card,\n\t\t(int)sizeof(p->bus_info), p->bus_info,\n\t\tp->version, p->capabilities, p->device_caps);\n}\n\nstatic void v4l_print_enuminput(const void *arg, bool write_only)\n{\n\tconst struct v4l2_input *p = arg;\n\n\tpr_cont(\"index=%u, name=%.*s, type=%u, audioset=0x%x, tuner=%u, std=0x%08Lx, status=0x%x, capabilities=0x%x\\n\",\n\t\tp->index, (int)sizeof(p->name), p->name, p->type, p->audioset,\n\t\tp->tuner, (unsigned long long)p->std, p->status,\n\t\tp->capabilities);\n}\n\nstatic void v4l_print_enumoutput(const void *arg, bool write_only)\n{\n\tconst struct v4l2_output *p = arg;\n\n\tpr_cont(\"index=%u, name=%.*s, type=%u, audioset=0x%x, modulator=%u, std=0x%08Lx, capabilities=0x%x\\n\",\n\t\tp->index, (int)sizeof(p->name), p->name, p->type, p->audioset,\n\t\tp->modulator, (unsigned long long)p->std, p->capabilities);\n}\n\nstatic void v4l_print_audio(const void *arg, bool write_only)\n{\n\tconst struct v4l2_audio *p = arg;\n\n\tif (write_only)\n\t\tpr_cont(\"index=%u, mode=0x%x\\n\", p->index, p->mode);\n\telse\n\t\tpr_cont(\"index=%u, name=%.*s, capability=0x%x, mode=0x%x\\n\",\n\t\t\tp->index, (int)sizeof(p->name), p->name,\n\t\t\tp->capability, p->mode);\n}\n\nstatic void v4l_print_audioout(const void *arg, bool write_only)\n{\n\tconst struct v4l2_audioout *p = arg;\n\n\tif (write_only)\n\t\tpr_cont(\"index=%u\\n\", p->index);\n\telse\n\t\tpr_cont(\"index=%u, name=%.*s, capability=0x%x, mode=0x%x\\n\",\n\t\t\tp->index, (int)sizeof(p->name), p->name,\n\t\t\tp->capability, p->mode);\n}\n\nstatic void v4l_print_fmtdesc(const void *arg, bool write_only)\n{\n\tconst struct v4l2_fmtdesc *p = arg;\n\n\tpr_cont(\"index=%u, type=%s, flags=0x%x, pixelformat=%p4cc, mbus_code=0x%04x, description='%.*s'\\n\",\n\t\tp->index, prt_names(p->type, v4l2_type_names),\n\t\tp->flags, &p->pixelformat, p->mbus_code,\n\t\t(int)sizeof(p->description), p->description);\n}\n\nstatic void v4l_print_format(const void *arg, bool write_only)\n{\n\tconst struct v4l2_format *p = arg;\n\tconst struct v4l2_pix_format *pix;\n\tconst struct v4l2_pix_format_mplane *mp;\n\tconst struct v4l2_vbi_format *vbi;\n\tconst struct v4l2_sliced_vbi_format *sliced;\n\tconst struct v4l2_window *win;\n\tconst struct v4l2_meta_format *meta;\n\tu32 pixelformat;\n\tu32 planes;\n\tunsigned i;\n\n\tpr_cont(\"type=%s\", prt_names(p->type, v4l2_type_names));\n\tswitch (p->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tpix = &p->fmt.pix;\n\t\tpr_cont(\", width=%u, height=%u, pixelformat=%p4cc, field=%s, bytesperline=%u, sizeimage=%u, colorspace=%d, flags=0x%x, ycbcr_enc=%u, quantization=%u, xfer_func=%u\\n\",\n\t\t\tpix->width, pix->height, &pix->pixelformat,\n\t\t\tprt_names(pix->field, v4l2_field_names),\n\t\t\tpix->bytesperline, pix->sizeimage,\n\t\t\tpix->colorspace, pix->flags, pix->ycbcr_enc,\n\t\t\tpix->quantization, pix->xfer_func);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\tmp = &p->fmt.pix_mp;\n\t\tpixelformat = mp->pixelformat;\n\t\tpr_cont(\", width=%u, height=%u, format=%p4cc, field=%s, colorspace=%d, num_planes=%u, flags=0x%x, ycbcr_enc=%u, quantization=%u, xfer_func=%u\\n\",\n\t\t\tmp->width, mp->height, &pixelformat,\n\t\t\tprt_names(mp->field, v4l2_field_names),\n\t\t\tmp->colorspace, mp->num_planes, mp->flags,\n\t\t\tmp->ycbcr_enc, mp->quantization, mp->xfer_func);\n\t\tplanes = min_t(u32, mp->num_planes, VIDEO_MAX_PLANES);\n\t\tfor (i = 0; i < planes; i++)\n\t\t\tprintk(KERN_DEBUG \"plane %u: bytesperline=%u sizeimage=%u\\n\", i,\n\t\t\t\t\tmp->plane_fmt[i].bytesperline,\n\t\t\t\t\tmp->plane_fmt[i].sizeimage);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\n\t\twin = &p->fmt.win;\n\t\tpr_cont(\", wxh=%dx%d, x,y=%d,%d, field=%s, chromakey=0x%08x, global_alpha=0x%02x\\n\",\n\t\t\twin->w.width, win->w.height, win->w.left, win->w.top,\n\t\t\tprt_names(win->field, v4l2_field_names),\n\t\t\twin->chromakey, win->global_alpha);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n\tcase V4L2_BUF_TYPE_VBI_OUTPUT:\n\t\tvbi = &p->fmt.vbi;\n\t\tpr_cont(\", sampling_rate=%u, offset=%u, samples_per_line=%u, sample_format=%p4cc, start=%u,%u, count=%u,%u\\n\",\n\t\t\tvbi->sampling_rate, vbi->offset,\n\t\t\tvbi->samples_per_line, &vbi->sample_format,\n\t\t\tvbi->start[0], vbi->start[1],\n\t\t\tvbi->count[0], vbi->count[1]);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\n\tcase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\n\t\tsliced = &p->fmt.sliced;\n\t\tpr_cont(\", service_set=0x%08x, io_size=%d\\n\",\n\t\t\t\tsliced->service_set, sliced->io_size);\n\t\tfor (i = 0; i < 24; i++)\n\t\t\tprintk(KERN_DEBUG \"line[%02u]=0x%04x, 0x%04x\\n\", i,\n\t\t\t\tsliced->service_lines[0][i],\n\t\t\t\tsliced->service_lines[1][i]);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_SDR_CAPTURE:\n\tcase V4L2_BUF_TYPE_SDR_OUTPUT:\n\t\tpixelformat = p->fmt.sdr.pixelformat;\n\t\tpr_cont(\", pixelformat=%p4cc\\n\", &pixelformat);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_META_CAPTURE:\n\tcase V4L2_BUF_TYPE_META_OUTPUT:\n\t\tmeta = &p->fmt.meta;\n\t\tpixelformat = meta->dataformat;\n\t\tpr_cont(\", dataformat=%p4cc, buffersize=%u\\n\",\n\t\t\t&pixelformat, meta->buffersize);\n\t\tbreak;\n\t}\n}\n\nstatic void v4l_print_framebuffer(const void *arg, bool write_only)\n{\n\tconst struct v4l2_framebuffer *p = arg;\n\n\tpr_cont(\"capability=0x%x, flags=0x%x, base=0x%p, width=%u, height=%u, pixelformat=%p4cc, bytesperline=%u, sizeimage=%u, colorspace=%d\\n\",\n\t\tp->capability, p->flags, p->base, p->fmt.width, p->fmt.height,\n\t\t&p->fmt.pixelformat, p->fmt.bytesperline, p->fmt.sizeimage,\n\t\tp->fmt.colorspace);\n}\n\nstatic void v4l_print_buftype(const void *arg, bool write_only)\n{\n\tpr_cont(\"type=%s\\n\", prt_names(*(u32 *)arg, v4l2_type_names));\n}\n\nstatic void v4l_print_modulator(const void *arg, bool write_only)\n{\n\tconst struct v4l2_modulator *p = arg;\n\n\tif (write_only)\n\t\tpr_cont(\"index=%u, txsubchans=0x%x\\n\", p->index, p->txsubchans);\n\telse\n\t\tpr_cont(\"index=%u, name=%.*s, capability=0x%x, rangelow=%u, rangehigh=%u, txsubchans=0x%x\\n\",\n\t\t\tp->index, (int)sizeof(p->name), p->name, p->capability,\n\t\t\tp->rangelow, p->rangehigh, p->txsubchans);\n}\n\nstatic void v4l_print_tuner(const void *arg, bool write_only)\n{\n\tconst struct v4l2_tuner *p = arg;\n\n\tif (write_only)\n\t\tpr_cont(\"index=%u, audmode=%u\\n\", p->index, p->audmode);\n\telse\n\t\tpr_cont(\"index=%u, name=%.*s, type=%u, capability=0x%x, rangelow=%u, rangehigh=%u, signal=%u, afc=%d, rxsubchans=0x%x, audmode=%u\\n\",\n\t\t\tp->index, (int)sizeof(p->name), p->name, p->type,\n\t\t\tp->capability, p->rangelow,\n\t\t\tp->rangehigh, p->signal, p->afc,\n\t\t\tp->rxsubchans, p->audmode);\n}\n\nstatic void v4l_print_frequency(const void *arg, bool write_only)\n{\n\tconst struct v4l2_frequency *p = arg;\n\n\tpr_cont(\"tuner=%u, type=%u, frequency=%u\\n\",\n\t\t\t\tp->tuner, p->type, p->frequency);\n}\n\nstatic void v4l_print_standard(const void *arg, bool write_only)\n{\n\tconst struct v4l2_standard *p = arg;\n\n\tpr_cont(\"index=%u, id=0x%Lx, name=%.*s, fps=%u/%u, framelines=%u\\n\",\n\t\tp->index,\n\t\t(unsigned long long)p->id, (int)sizeof(p->name), p->name,\n\t\tp->frameperiod.numerator,\n\t\tp->frameperiod.denominator,\n\t\tp->framelines);\n}\n\nstatic void v4l_print_std(const void *arg, bool write_only)\n{\n\tpr_cont(\"std=0x%08Lx\\n\", *(const long long unsigned *)arg);\n}\n\nstatic void v4l_print_hw_freq_seek(const void *arg, bool write_only)\n{\n\tconst struct v4l2_hw_freq_seek *p = arg;\n\n\tpr_cont(\"tuner=%u, type=%u, seek_upward=%u, wrap_around=%u, spacing=%u, rangelow=%u, rangehigh=%u\\n\",\n\t\tp->tuner, p->type, p->seek_upward, p->wrap_around, p->spacing,\n\t\tp->rangelow, p->rangehigh);\n}\n\nstatic void v4l_print_requestbuffers(const void *arg, bool write_only)\n{\n\tconst struct v4l2_requestbuffers *p = arg;\n\n\tpr_cont(\"count=%d, type=%s, memory=%s\\n\",\n\t\tp->count,\n\t\tprt_names(p->type, v4l2_type_names),\n\t\tprt_names(p->memory, v4l2_memory_names));\n}\n\nstatic void v4l_print_buffer(const void *arg, bool write_only)\n{\n\tconst struct v4l2_buffer *p = arg;\n\tconst struct v4l2_timecode *tc = &p->timecode;\n\tconst struct v4l2_plane *plane;\n\tint i;\n\n\tpr_cont(\"%02d:%02d:%02d.%06ld index=%d, type=%s, request_fd=%d, flags=0x%08x, field=%s, sequence=%d, memory=%s\",\n\t\t\t(int)p->timestamp.tv_sec / 3600,\n\t\t\t((int)p->timestamp.tv_sec / 60) % 60,\n\t\t\t((int)p->timestamp.tv_sec % 60),\n\t\t\t(long)p->timestamp.tv_usec,\n\t\t\tp->index,\n\t\t\tprt_names(p->type, v4l2_type_names), p->request_fd,\n\t\t\tp->flags, prt_names(p->field, v4l2_field_names),\n\t\t\tp->sequence, prt_names(p->memory, v4l2_memory_names));\n\n\tif (V4L2_TYPE_IS_MULTIPLANAR(p->type) && p->m.planes) {\n\t\tpr_cont(\"\\n\");\n\t\tfor (i = 0; i < p->length; ++i) {\n\t\t\tplane = &p->m.planes[i];\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"plane %d: bytesused=%d, data_offset=0x%08x, offset/userptr=0x%lx, length=%d\\n\",\n\t\t\t\ti, plane->bytesused, plane->data_offset,\n\t\t\t\tplane->m.userptr, plane->length);\n\t\t}\n\t} else {\n\t\tpr_cont(\", bytesused=%d, offset/userptr=0x%lx, length=%d\\n\",\n\t\t\tp->bytesused, p->m.userptr, p->length);\n\t}\n\n\tprintk(KERN_DEBUG \"timecode=%02d:%02d:%02d type=%d, flags=0x%08x, frames=%d, userbits=0x%08x\\n\",\n\t\t\ttc->hours, tc->minutes, tc->seconds,\n\t\t\ttc->type, tc->flags, tc->frames, *(__u32 *)tc->userbits);\n}\n\nstatic void v4l_print_exportbuffer(const void *arg, bool write_only)\n{\n\tconst struct v4l2_exportbuffer *p = arg;\n\n\tpr_cont(\"fd=%d, type=%s, index=%u, plane=%u, flags=0x%08x\\n\",\n\t\tp->fd, prt_names(p->type, v4l2_type_names),\n\t\tp->index, p->plane, p->flags);\n}\n\nstatic void v4l_print_create_buffers(const void *arg, bool write_only)\n{\n\tconst struct v4l2_create_buffers *p = arg;\n\n\tpr_cont(\"index=%d, count=%d, memory=%s, capabilities=0x%08x, \",\n\t\tp->index, p->count, prt_names(p->memory, v4l2_memory_names),\n\t\tp->capabilities);\n\tv4l_print_format(&p->format, write_only);\n}\n\nstatic void v4l_print_streamparm(const void *arg, bool write_only)\n{\n\tconst struct v4l2_streamparm *p = arg;\n\n\tpr_cont(\"type=%s\", prt_names(p->type, v4l2_type_names));\n\n\tif (p->type == V4L2_BUF_TYPE_VIDEO_CAPTURE ||\n\t    p->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tconst struct v4l2_captureparm *c = &p->parm.capture;\n\n\t\tpr_cont(\", capability=0x%x, capturemode=0x%x, timeperframe=%d/%d, extendedmode=%d, readbuffers=%d\\n\",\n\t\t\tc->capability, c->capturemode,\n\t\t\tc->timeperframe.numerator, c->timeperframe.denominator,\n\t\t\tc->extendedmode, c->readbuffers);\n\t} else if (p->type == V4L2_BUF_TYPE_VIDEO_OUTPUT ||\n\t\t   p->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tconst struct v4l2_outputparm *c = &p->parm.output;\n\n\t\tpr_cont(\", capability=0x%x, outputmode=0x%x, timeperframe=%d/%d, extendedmode=%d, writebuffers=%d\\n\",\n\t\t\tc->capability, c->outputmode,\n\t\t\tc->timeperframe.numerator, c->timeperframe.denominator,\n\t\t\tc->extendedmode, c->writebuffers);\n\t} else {\n\t\tpr_cont(\"\\n\");\n\t}\n}\n\nstatic void v4l_print_queryctrl(const void *arg, bool write_only)\n{\n\tconst struct v4l2_queryctrl *p = arg;\n\n\tpr_cont(\"id=0x%x, type=%d, name=%.*s, min/max=%d/%d, step=%d, default=%d, flags=0x%08x\\n\",\n\t\t\tp->id, p->type, (int)sizeof(p->name), p->name,\n\t\t\tp->minimum, p->maximum,\n\t\t\tp->step, p->default_value, p->flags);\n}\n\nstatic void v4l_print_query_ext_ctrl(const void *arg, bool write_only)\n{\n\tconst struct v4l2_query_ext_ctrl *p = arg;\n\n\tpr_cont(\"id=0x%x, type=%d, name=%.*s, min/max=%lld/%lld, step=%lld, default=%lld, flags=0x%08x, elem_size=%u, elems=%u, nr_of_dims=%u, dims=%u,%u,%u,%u\\n\",\n\t\t\tp->id, p->type, (int)sizeof(p->name), p->name,\n\t\t\tp->minimum, p->maximum,\n\t\t\tp->step, p->default_value, p->flags,\n\t\t\tp->elem_size, p->elems, p->nr_of_dims,\n\t\t\tp->dims[0], p->dims[1], p->dims[2], p->dims[3]);\n}\n\nstatic void v4l_print_querymenu(const void *arg, bool write_only)\n{\n\tconst struct v4l2_querymenu *p = arg;\n\n\tpr_cont(\"id=0x%x, index=%d\\n\", p->id, p->index);\n}\n\nstatic void v4l_print_control(const void *arg, bool write_only)\n{\n\tconst struct v4l2_control *p = arg;\n\tconst char *name = v4l2_ctrl_get_name(p->id);\n\n\tif (name)\n\t\tpr_cont(\"name=%s, \", name);\n\tpr_cont(\"id=0x%x, value=%d\\n\", p->id, p->value);\n}\n\nstatic void v4l_print_ext_controls(const void *arg, bool write_only)\n{\n\tconst struct v4l2_ext_controls *p = arg;\n\tint i;\n\n\tpr_cont(\"which=0x%x, count=%d, error_idx=%d, request_fd=%d\",\n\t\t\tp->which, p->count, p->error_idx, p->request_fd);\n\tfor (i = 0; i < p->count; i++) {\n\t\tunsigned int id = p->controls[i].id;\n\t\tconst char *name = v4l2_ctrl_get_name(id);\n\n\t\tif (name)\n\t\t\tpr_cont(\", name=%s\", name);\n\t\tif (!p->controls[i].size)\n\t\t\tpr_cont(\", id/val=0x%x/0x%x\", id, p->controls[i].value);\n\t\telse\n\t\t\tpr_cont(\", id/size=0x%x/%u\", id, p->controls[i].size);\n\t}\n\tpr_cont(\"\\n\");\n}\n\nstatic void v4l_print_cropcap(const void *arg, bool write_only)\n{\n\tconst struct v4l2_cropcap *p = arg;\n\n\tpr_cont(\"type=%s, bounds wxh=%dx%d, x,y=%d,%d, defrect wxh=%dx%d, x,y=%d,%d, pixelaspect %d/%d\\n\",\n\t\tprt_names(p->type, v4l2_type_names),\n\t\tp->bounds.width, p->bounds.height,\n\t\tp->bounds.left, p->bounds.top,\n\t\tp->defrect.width, p->defrect.height,\n\t\tp->defrect.left, p->defrect.top,\n\t\tp->pixelaspect.numerator, p->pixelaspect.denominator);\n}\n\nstatic void v4l_print_crop(const void *arg, bool write_only)\n{\n\tconst struct v4l2_crop *p = arg;\n\n\tpr_cont(\"type=%s, wxh=%dx%d, x,y=%d,%d\\n\",\n\t\tprt_names(p->type, v4l2_type_names),\n\t\tp->c.width, p->c.height,\n\t\tp->c.left, p->c.top);\n}\n\nstatic void v4l_print_selection(const void *arg, bool write_only)\n{\n\tconst struct v4l2_selection *p = arg;\n\n\tpr_cont(\"type=%s, target=%d, flags=0x%x, wxh=%dx%d, x,y=%d,%d\\n\",\n\t\tprt_names(p->type, v4l2_type_names),\n\t\tp->target, p->flags,\n\t\tp->r.width, p->r.height, p->r.left, p->r.top);\n}\n\nstatic void v4l_print_jpegcompression(const void *arg, bool write_only)\n{\n\tconst struct v4l2_jpegcompression *p = arg;\n\n\tpr_cont(\"quality=%d, APPn=%d, APP_len=%d, COM_len=%d, jpeg_markers=0x%x\\n\",\n\t\tp->quality, p->APPn, p->APP_len,\n\t\tp->COM_len, p->jpeg_markers);\n}\n\nstatic void v4l_print_enc_idx(const void *arg, bool write_only)\n{\n\tconst struct v4l2_enc_idx *p = arg;\n\n\tpr_cont(\"entries=%d, entries_cap=%d\\n\",\n\t\t\tp->entries, p->entries_cap);\n}\n\nstatic void v4l_print_encoder_cmd(const void *arg, bool write_only)\n{\n\tconst struct v4l2_encoder_cmd *p = arg;\n\n\tpr_cont(\"cmd=%d, flags=0x%x\\n\",\n\t\t\tp->cmd, p->flags);\n}\n\nstatic void v4l_print_decoder_cmd(const void *arg, bool write_only)\n{\n\tconst struct v4l2_decoder_cmd *p = arg;\n\n\tpr_cont(\"cmd=%d, flags=0x%x\\n\", p->cmd, p->flags);\n\n\tif (p->cmd == V4L2_DEC_CMD_START)\n\t\tpr_info(\"speed=%d, format=%u\\n\",\n\t\t\t\tp->start.speed, p->start.format);\n\telse if (p->cmd == V4L2_DEC_CMD_STOP)\n\t\tpr_info(\"pts=%llu\\n\", p->stop.pts);\n}\n\nstatic void v4l_print_dbg_chip_info(const void *arg, bool write_only)\n{\n\tconst struct v4l2_dbg_chip_info *p = arg;\n\n\tpr_cont(\"type=%u, \", p->match.type);\n\tif (p->match.type == V4L2_CHIP_MATCH_I2C_DRIVER)\n\t\tpr_cont(\"name=%.*s, \",\n\t\t\t\t(int)sizeof(p->match.name), p->match.name);\n\telse\n\t\tpr_cont(\"addr=%u, \", p->match.addr);\n\tpr_cont(\"name=%.*s\\n\", (int)sizeof(p->name), p->name);\n}\n\nstatic void v4l_print_dbg_register(const void *arg, bool write_only)\n{\n\tconst struct v4l2_dbg_register *p = arg;\n\n\tpr_cont(\"type=%u, \", p->match.type);\n\tif (p->match.type == V4L2_CHIP_MATCH_I2C_DRIVER)\n\t\tpr_cont(\"name=%.*s, \",\n\t\t\t\t(int)sizeof(p->match.name), p->match.name);\n\telse\n\t\tpr_cont(\"addr=%u, \", p->match.addr);\n\tpr_cont(\"reg=0x%llx, val=0x%llx\\n\",\n\t\t\tp->reg, p->val);\n}\n\nstatic void v4l_print_dv_timings(const void *arg, bool write_only)\n{\n\tconst struct v4l2_dv_timings *p = arg;\n\n\tswitch (p->type) {\n\tcase V4L2_DV_BT_656_1120:\n\t\tpr_cont(\"type=bt-656/1120, interlaced=%u, pixelclock=%llu, width=%u, height=%u, polarities=0x%x, hfrontporch=%u, hsync=%u, hbackporch=%u, vfrontporch=%u, vsync=%u, vbackporch=%u, il_vfrontporch=%u, il_vsync=%u, il_vbackporch=%u, standards=0x%x, flags=0x%x\\n\",\n\t\t\t\tp->bt.interlaced, p->bt.pixelclock,\n\t\t\t\tp->bt.width, p->bt.height,\n\t\t\t\tp->bt.polarities, p->bt.hfrontporch,\n\t\t\t\tp->bt.hsync, p->bt.hbackporch,\n\t\t\t\tp->bt.vfrontporch, p->bt.vsync,\n\t\t\t\tp->bt.vbackporch, p->bt.il_vfrontporch,\n\t\t\t\tp->bt.il_vsync, p->bt.il_vbackporch,\n\t\t\t\tp->bt.standards, p->bt.flags);\n\t\tbreak;\n\tdefault:\n\t\tpr_cont(\"type=%d\\n\", p->type);\n\t\tbreak;\n\t}\n}\n\nstatic void v4l_print_enum_dv_timings(const void *arg, bool write_only)\n{\n\tconst struct v4l2_enum_dv_timings *p = arg;\n\n\tpr_cont(\"index=%u, \", p->index);\n\tv4l_print_dv_timings(&p->timings, write_only);\n}\n\nstatic void v4l_print_dv_timings_cap(const void *arg, bool write_only)\n{\n\tconst struct v4l2_dv_timings_cap *p = arg;\n\n\tswitch (p->type) {\n\tcase V4L2_DV_BT_656_1120:\n\t\tpr_cont(\"type=bt-656/1120, width=%u-%u, height=%u-%u, pixelclock=%llu-%llu, standards=0x%x, capabilities=0x%x\\n\",\n\t\t\tp->bt.min_width, p->bt.max_width,\n\t\t\tp->bt.min_height, p->bt.max_height,\n\t\t\tp->bt.min_pixelclock, p->bt.max_pixelclock,\n\t\t\tp->bt.standards, p->bt.capabilities);\n\t\tbreak;\n\tdefault:\n\t\tpr_cont(\"type=%u\\n\", p->type);\n\t\tbreak;\n\t}\n}\n\nstatic void v4l_print_frmsizeenum(const void *arg, bool write_only)\n{\n\tconst struct v4l2_frmsizeenum *p = arg;\n\n\tpr_cont(\"index=%u, pixelformat=%p4cc, type=%u\",\n\t\tp->index, &p->pixel_format, p->type);\n\tswitch (p->type) {\n\tcase V4L2_FRMSIZE_TYPE_DISCRETE:\n\t\tpr_cont(\", wxh=%ux%u\\n\",\n\t\t\tp->discrete.width, p->discrete.height);\n\t\tbreak;\n\tcase V4L2_FRMSIZE_TYPE_STEPWISE:\n\t\tpr_cont(\", min=%ux%u, max=%ux%u, step=%ux%u\\n\",\n\t\t\t\tp->stepwise.min_width,\n\t\t\t\tp->stepwise.min_height,\n\t\t\t\tp->stepwise.max_width,\n\t\t\t\tp->stepwise.max_height,\n\t\t\t\tp->stepwise.step_width,\n\t\t\t\tp->stepwise.step_height);\n\t\tbreak;\n\tcase V4L2_FRMSIZE_TYPE_CONTINUOUS:\n\tdefault:\n\t\tpr_cont(\"\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void v4l_print_frmivalenum(const void *arg, bool write_only)\n{\n\tconst struct v4l2_frmivalenum *p = arg;\n\n\tpr_cont(\"index=%u, pixelformat=%p4cc, wxh=%ux%u, type=%u\",\n\t\tp->index, &p->pixel_format, p->width, p->height, p->type);\n\tswitch (p->type) {\n\tcase V4L2_FRMIVAL_TYPE_DISCRETE:\n\t\tpr_cont(\", fps=%d/%d\\n\",\n\t\t\t\tp->discrete.numerator,\n\t\t\t\tp->discrete.denominator);\n\t\tbreak;\n\tcase V4L2_FRMIVAL_TYPE_STEPWISE:\n\t\tpr_cont(\", min=%d/%d, max=%d/%d, step=%d/%d\\n\",\n\t\t\t\tp->stepwise.min.numerator,\n\t\t\t\tp->stepwise.min.denominator,\n\t\t\t\tp->stepwise.max.numerator,\n\t\t\t\tp->stepwise.max.denominator,\n\t\t\t\tp->stepwise.step.numerator,\n\t\t\t\tp->stepwise.step.denominator);\n\t\tbreak;\n\tcase V4L2_FRMIVAL_TYPE_CONTINUOUS:\n\tdefault:\n\t\tpr_cont(\"\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void v4l_print_event(const void *arg, bool write_only)\n{\n\tconst struct v4l2_event *p = arg;\n\tconst struct v4l2_event_ctrl *c;\n\n\tpr_cont(\"type=0x%x, pending=%u, sequence=%u, id=%u, timestamp=%llu.%9.9llu\\n\",\n\t\t\tp->type, p->pending, p->sequence, p->id,\n\t\t\tp->timestamp.tv_sec, p->timestamp.tv_nsec);\n\tswitch (p->type) {\n\tcase V4L2_EVENT_VSYNC:\n\t\tprintk(KERN_DEBUG \"field=%s\\n\",\n\t\t\tprt_names(p->u.vsync.field, v4l2_field_names));\n\t\tbreak;\n\tcase V4L2_EVENT_CTRL:\n\t\tc = &p->u.ctrl;\n\t\tprintk(KERN_DEBUG \"changes=0x%x, type=%u, \",\n\t\t\tc->changes, c->type);\n\t\tif (c->type == V4L2_CTRL_TYPE_INTEGER64)\n\t\t\tpr_cont(\"value64=%lld, \", c->value64);\n\t\telse\n\t\t\tpr_cont(\"value=%d, \", c->value);\n\t\tpr_cont(\"flags=0x%x, minimum=%d, maximum=%d, step=%d, default_value=%d\\n\",\n\t\t\tc->flags, c->minimum, c->maximum,\n\t\t\tc->step, c->default_value);\n\t\tbreak;\n\tcase V4L2_EVENT_FRAME_SYNC:\n\t\tpr_cont(\"frame_sequence=%u\\n\",\n\t\t\tp->u.frame_sync.frame_sequence);\n\t\tbreak;\n\t}\n}\n\nstatic void v4l_print_event_subscription(const void *arg, bool write_only)\n{\n\tconst struct v4l2_event_subscription *p = arg;\n\n\tpr_cont(\"type=0x%x, id=0x%x, flags=0x%x\\n\",\n\t\t\tp->type, p->id, p->flags);\n}\n\nstatic void v4l_print_sliced_vbi_cap(const void *arg, bool write_only)\n{\n\tconst struct v4l2_sliced_vbi_cap *p = arg;\n\tint i;\n\n\tpr_cont(\"type=%s, service_set=0x%08x\\n\",\n\t\t\tprt_names(p->type, v4l2_type_names), p->service_set);\n\tfor (i = 0; i < 24; i++)\n\t\tprintk(KERN_DEBUG \"line[%02u]=0x%04x, 0x%04x\\n\", i,\n\t\t\t\tp->service_lines[0][i],\n\t\t\t\tp->service_lines[1][i]);\n}\n\nstatic void v4l_print_freq_band(const void *arg, bool write_only)\n{\n\tconst struct v4l2_frequency_band *p = arg;\n\n\tpr_cont(\"tuner=%u, type=%u, index=%u, capability=0x%x, rangelow=%u, rangehigh=%u, modulation=0x%x\\n\",\n\t\t\tp->tuner, p->type, p->index,\n\t\t\tp->capability, p->rangelow,\n\t\t\tp->rangehigh, p->modulation);\n}\n\nstatic void v4l_print_edid(const void *arg, bool write_only)\n{\n\tconst struct v4l2_edid *p = arg;\n\n\tpr_cont(\"pad=%u, start_block=%u, blocks=%u\\n\",\n\t\tp->pad, p->start_block, p->blocks);\n}\n\nstatic void v4l_print_u32(const void *arg, bool write_only)\n{\n\tpr_cont(\"value=%u\\n\", *(const u32 *)arg);\n}\n\nstatic void v4l_print_newline(const void *arg, bool write_only)\n{\n\tpr_cont(\"\\n\");\n}\n\nstatic void v4l_print_default(const void *arg, bool write_only)\n{\n\tpr_cont(\"driver-specific ioctl\\n\");\n}\n\nstatic bool check_ext_ctrls(struct v4l2_ext_controls *c, unsigned long ioctl)\n{\n\t__u32 i;\n\n\t \n\tc->reserved[0] = 0;\n\tfor (i = 0; i < c->count; i++)\n\t\tc->controls[i].reserved2[0] = 0;\n\n\tswitch (c->which) {\n\tcase V4L2_CID_PRIVATE_BASE:\n\t\t \n\t\tif (ioctl == VIDIOC_G_CTRL || ioctl == VIDIOC_S_CTRL)\n\t\t\treturn false;\n\t\tbreak;\n\tcase V4L2_CTRL_WHICH_DEF_VAL:\n\t\t \n\t\tif (ioctl == VIDIOC_S_EXT_CTRLS ||\n\t\t    ioctl == VIDIOC_TRY_EXT_CTRLS) {\n\t\t\tc->error_idx = c->count;\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\tcase V4L2_CTRL_WHICH_CUR_VAL:\n\t\treturn true;\n\tcase V4L2_CTRL_WHICH_REQUEST_VAL:\n\t\tc->error_idx = c->count;\n\t\treturn false;\n\t}\n\n\t \n\tfor (i = 0; i < c->count; i++) {\n\t\tif (V4L2_CTRL_ID2WHICH(c->controls[i].id) != c->which) {\n\t\t\tc->error_idx = ioctl == VIDIOC_TRY_EXT_CTRLS ? i :\n\t\t\t\t\t\t\t\t      c->count;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int check_fmt(struct file *file, enum v4l2_buf_type type)\n{\n\tconst u32 vid_caps = V4L2_CAP_VIDEO_CAPTURE |\n\t\t\t     V4L2_CAP_VIDEO_CAPTURE_MPLANE |\n\t\t\t     V4L2_CAP_VIDEO_OUTPUT |\n\t\t\t     V4L2_CAP_VIDEO_OUTPUT_MPLANE |\n\t\t\t     V4L2_CAP_VIDEO_M2M | V4L2_CAP_VIDEO_M2M_MPLANE;\n\tconst u32 meta_caps = V4L2_CAP_META_CAPTURE |\n\t\t\t      V4L2_CAP_META_OUTPUT;\n\tstruct video_device *vfd = video_devdata(file);\n\tconst struct v4l2_ioctl_ops *ops = vfd->ioctl_ops;\n\tbool is_vid = vfd->vfl_type == VFL_TYPE_VIDEO &&\n\t\t      (vfd->device_caps & vid_caps);\n\tbool is_vbi = vfd->vfl_type == VFL_TYPE_VBI;\n\tbool is_sdr = vfd->vfl_type == VFL_TYPE_SDR;\n\tbool is_tch = vfd->vfl_type == VFL_TYPE_TOUCH;\n\tbool is_meta = vfd->vfl_type == VFL_TYPE_VIDEO &&\n\t\t       (vfd->device_caps & meta_caps);\n\tbool is_rx = vfd->vfl_dir != VFL_DIR_TX;\n\tbool is_tx = vfd->vfl_dir != VFL_DIR_RX;\n\n\tif (ops == NULL)\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tif ((is_vid || is_tch) && is_rx &&\n\t\t    (ops->vidioc_g_fmt_vid_cap || ops->vidioc_g_fmt_vid_cap_mplane))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\tif ((is_vid || is_tch) && is_rx && ops->vidioc_g_fmt_vid_cap_mplane)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\t\tif (is_vid && is_rx && ops->vidioc_g_fmt_vid_overlay)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif (is_vid && is_tx &&\n\t\t    (ops->vidioc_g_fmt_vid_out || ops->vidioc_g_fmt_vid_out_mplane))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\tif (is_vid && is_tx && ops->vidioc_g_fmt_vid_out_mplane)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\n\t\tif (is_vid && is_tx && ops->vidioc_g_fmt_vid_out_overlay)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n\t\tif (is_vbi && is_rx && ops->vidioc_g_fmt_vbi_cap)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VBI_OUTPUT:\n\t\tif (is_vbi && is_tx && ops->vidioc_g_fmt_vbi_out)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\n\t\tif (is_vbi && is_rx && ops->vidioc_g_fmt_sliced_vbi_cap)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\n\t\tif (is_vbi && is_tx && ops->vidioc_g_fmt_sliced_vbi_out)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_SDR_CAPTURE:\n\t\tif (is_sdr && is_rx && ops->vidioc_g_fmt_sdr_cap)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_SDR_OUTPUT:\n\t\tif (is_sdr && is_tx && ops->vidioc_g_fmt_sdr_out)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_META_CAPTURE:\n\t\tif (is_meta && is_rx && ops->vidioc_g_fmt_meta_cap)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_META_OUTPUT:\n\t\tif (is_meta && is_tx && ops->vidioc_g_fmt_meta_out)\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic void v4l_sanitize_colorspace(u32 pixelformat, u32 *colorspace,\n\t\t\t\t    u32 *encoding, u32 *quantization,\n\t\t\t\t    u32 *xfer_func)\n{\n\tbool is_hsv = pixelformat == V4L2_PIX_FMT_HSV24 ||\n\t\t      pixelformat == V4L2_PIX_FMT_HSV32;\n\n\tif (!v4l2_is_colorspace_valid(*colorspace)) {\n\t\t*colorspace = V4L2_COLORSPACE_DEFAULT;\n\t\t*encoding = V4L2_YCBCR_ENC_DEFAULT;\n\t\t*quantization = V4L2_QUANTIZATION_DEFAULT;\n\t\t*xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\t}\n\n\tif ((!is_hsv && !v4l2_is_ycbcr_enc_valid(*encoding)) ||\n\t    (is_hsv && !v4l2_is_hsv_enc_valid(*encoding)))\n\t\t*encoding = V4L2_YCBCR_ENC_DEFAULT;\n\n\tif (!v4l2_is_quant_valid(*quantization))\n\t\t*quantization = V4L2_QUANTIZATION_DEFAULT;\n\n\tif (!v4l2_is_xfer_func_valid(*xfer_func))\n\t\t*xfer_func = V4L2_XFER_FUNC_DEFAULT;\n}\n\nstatic void v4l_sanitize_format(struct v4l2_format *fmt)\n{\n\tunsigned int offset;\n\n\t \n\tif (fmt->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE ||\n\t    fmt->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tfmt->fmt.pix_mp.num_planes = min_t(u32, fmt->fmt.pix_mp.num_planes,\n\t\t\t\t\t       VIDEO_MAX_PLANES);\n\n\t \n\tif (fmt->type == V4L2_BUF_TYPE_VIDEO_CAPTURE ||\n\t    fmt->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\tif (fmt->fmt.pix.priv != V4L2_PIX_FMT_PRIV_MAGIC) {\n\t\t\tfmt->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\n\n\t\t\toffset = offsetof(struct v4l2_pix_format, priv)\n\t\t\t       + sizeof(fmt->fmt.pix.priv);\n\t\t\tmemset(((void *)&fmt->fmt.pix) + offset, 0,\n\t\t\t       sizeof(fmt->fmt.pix) - offset);\n\t\t}\n\t}\n\n\t \n\tif (fmt->type == V4L2_BUF_TYPE_VIDEO_CAPTURE ||\n\t    fmt->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\tv4l_sanitize_colorspace(fmt->fmt.pix.pixelformat,\n\t\t\t\t\t&fmt->fmt.pix.colorspace,\n\t\t\t\t\t&fmt->fmt.pix.ycbcr_enc,\n\t\t\t\t\t&fmt->fmt.pix.quantization,\n\t\t\t\t\t&fmt->fmt.pix.xfer_func);\n\t} else if (fmt->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE ||\n\t\t   fmt->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tu32 ycbcr_enc = fmt->fmt.pix_mp.ycbcr_enc;\n\t\tu32 quantization = fmt->fmt.pix_mp.quantization;\n\t\tu32 xfer_func = fmt->fmt.pix_mp.xfer_func;\n\n\t\tv4l_sanitize_colorspace(fmt->fmt.pix_mp.pixelformat,\n\t\t\t\t\t&fmt->fmt.pix_mp.colorspace, &ycbcr_enc,\n\t\t\t\t\t&quantization, &xfer_func);\n\n\t\tfmt->fmt.pix_mp.ycbcr_enc = ycbcr_enc;\n\t\tfmt->fmt.pix_mp.quantization = quantization;\n\t\tfmt->fmt.pix_mp.xfer_func = xfer_func;\n\t}\n}\n\nstatic int v4l_querycap(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct v4l2_capability *cap = (struct v4l2_capability *)arg;\n\tstruct video_device *vfd = video_devdata(file);\n\tint ret;\n\n\tcap->version = LINUX_VERSION_CODE;\n\tcap->device_caps = vfd->device_caps;\n\tcap->capabilities = vfd->device_caps | V4L2_CAP_DEVICE_CAPS;\n\n\tmedia_set_bus_info(cap->bus_info, sizeof(cap->bus_info),\n\t\t\t   vfd->dev_parent);\n\n\tret = ops->vidioc_querycap(file, fh, cap);\n\n\t \n\tWARN_ON(cap->device_caps != vfd->device_caps);\n\t \n\tWARN_ON((cap->capabilities &\n\t\t (vfd->device_caps | V4L2_CAP_DEVICE_CAPS)) !=\n\t\t(vfd->device_caps | V4L2_CAP_DEVICE_CAPS));\n\tcap->capabilities |= V4L2_CAP_EXT_PIX_FORMAT;\n\tcap->device_caps |= V4L2_CAP_EXT_PIX_FORMAT;\n\n\treturn ret;\n}\n\nstatic int v4l_g_input(const struct v4l2_ioctl_ops *ops,\n\t\t       struct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\n\tif (vfd->device_caps & V4L2_CAP_IO_MC) {\n\t\t*(int *)arg = 0;\n\t\treturn 0;\n\t}\n\n\treturn ops->vidioc_g_input(file, fh, arg);\n}\n\nstatic int v4l_g_output(const struct v4l2_ioctl_ops *ops,\n\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\n\tif (vfd->device_caps & V4L2_CAP_IO_MC) {\n\t\t*(int *)arg = 0;\n\t\treturn 0;\n\t}\n\n\treturn ops->vidioc_g_output(file, fh, arg);\n}\n\nstatic int v4l_s_input(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tint ret;\n\n\tret = v4l_enable_media_source(vfd);\n\tif (ret)\n\t\treturn ret;\n\n\tif (vfd->device_caps & V4L2_CAP_IO_MC)\n\t\treturn  *(int *)arg ? -EINVAL : 0;\n\n\treturn ops->vidioc_s_input(file, fh, *(unsigned int *)arg);\n}\n\nstatic int v4l_s_output(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\n\tif (vfd->device_caps & V4L2_CAP_IO_MC)\n\t\treturn  *(int *)arg ? -EINVAL : 0;\n\n\treturn ops->vidioc_s_output(file, fh, *(unsigned int *)arg);\n}\n\nstatic int v4l_g_priority(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd;\n\tu32 *p = arg;\n\n\tvfd = video_devdata(file);\n\t*p = v4l2_prio_max(vfd->prio);\n\treturn 0;\n}\n\nstatic int v4l_s_priority(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd;\n\tstruct v4l2_fh *vfh;\n\tu32 *p = arg;\n\n\tvfd = video_devdata(file);\n\tif (!test_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags))\n\t\treturn -ENOTTY;\n\tvfh = file->private_data;\n\treturn v4l2_prio_change(vfd->prio, &vfh->prio, *p);\n}\n\nstatic int v4l_enuminput(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_input *p = arg;\n\n\t \n\tif (is_valid_ioctl(vfd, VIDIOC_S_STD))\n\t\tp->capabilities |= V4L2_IN_CAP_STD;\n\n\tif (vfd->device_caps & V4L2_CAP_IO_MC) {\n\t\tif (p->index)\n\t\t\treturn -EINVAL;\n\t\tstrscpy(p->name, vfd->name, sizeof(p->name));\n\t\tp->type = V4L2_INPUT_TYPE_CAMERA;\n\t\treturn 0;\n\t}\n\n\treturn ops->vidioc_enum_input(file, fh, p);\n}\n\nstatic int v4l_enumoutput(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_output *p = arg;\n\n\t \n\tif (is_valid_ioctl(vfd, VIDIOC_S_STD))\n\t\tp->capabilities |= V4L2_OUT_CAP_STD;\n\n\tif (vfd->device_caps & V4L2_CAP_IO_MC) {\n\t\tif (p->index)\n\t\t\treturn -EINVAL;\n\t\tstrscpy(p->name, vfd->name, sizeof(p->name));\n\t\tp->type = V4L2_OUTPUT_TYPE_ANALOG;\n\t\treturn 0;\n\t}\n\n\treturn ops->vidioc_enum_output(file, fh, p);\n}\n\nstatic void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)\n{\n\tconst unsigned sz = sizeof(fmt->description);\n\tconst char *descr = NULL;\n\tu32 flags = 0;\n\n\t \n\tswitch (fmt->pixelformat) {\n\t \n\tcase V4L2_PIX_FMT_RGB332:\tdescr = \"8-bit RGB 3-3-2\"; break;\n\tcase V4L2_PIX_FMT_RGB444:\tdescr = \"16-bit A/XRGB 4-4-4-4\"; break;\n\tcase V4L2_PIX_FMT_ARGB444:\tdescr = \"16-bit ARGB 4-4-4-4\"; break;\n\tcase V4L2_PIX_FMT_XRGB444:\tdescr = \"16-bit XRGB 4-4-4-4\"; break;\n\tcase V4L2_PIX_FMT_RGBA444:\tdescr = \"16-bit RGBA 4-4-4-4\"; break;\n\tcase V4L2_PIX_FMT_RGBX444:\tdescr = \"16-bit RGBX 4-4-4-4\"; break;\n\tcase V4L2_PIX_FMT_ABGR444:\tdescr = \"16-bit ABGR 4-4-4-4\"; break;\n\tcase V4L2_PIX_FMT_XBGR444:\tdescr = \"16-bit XBGR 4-4-4-4\"; break;\n\tcase V4L2_PIX_FMT_BGRA444:\tdescr = \"16-bit BGRA 4-4-4-4\"; break;\n\tcase V4L2_PIX_FMT_BGRX444:\tdescr = \"16-bit BGRX 4-4-4-4\"; break;\n\tcase V4L2_PIX_FMT_RGB555:\tdescr = \"16-bit A/XRGB 1-5-5-5\"; break;\n\tcase V4L2_PIX_FMT_ARGB555:\tdescr = \"16-bit ARGB 1-5-5-5\"; break;\n\tcase V4L2_PIX_FMT_XRGB555:\tdescr = \"16-bit XRGB 1-5-5-5\"; break;\n\tcase V4L2_PIX_FMT_ABGR555:\tdescr = \"16-bit ABGR 1-5-5-5\"; break;\n\tcase V4L2_PIX_FMT_XBGR555:\tdescr = \"16-bit XBGR 1-5-5-5\"; break;\n\tcase V4L2_PIX_FMT_RGBA555:\tdescr = \"16-bit RGBA 5-5-5-1\"; break;\n\tcase V4L2_PIX_FMT_RGBX555:\tdescr = \"16-bit RGBX 5-5-5-1\"; break;\n\tcase V4L2_PIX_FMT_BGRA555:\tdescr = \"16-bit BGRA 5-5-5-1\"; break;\n\tcase V4L2_PIX_FMT_BGRX555:\tdescr = \"16-bit BGRX 5-5-5-1\"; break;\n\tcase V4L2_PIX_FMT_RGB565:\tdescr = \"16-bit RGB 5-6-5\"; break;\n\tcase V4L2_PIX_FMT_RGB555X:\tdescr = \"16-bit A/XRGB 1-5-5-5 BE\"; break;\n\tcase V4L2_PIX_FMT_ARGB555X:\tdescr = \"16-bit ARGB 1-5-5-5 BE\"; break;\n\tcase V4L2_PIX_FMT_XRGB555X:\tdescr = \"16-bit XRGB 1-5-5-5 BE\"; break;\n\tcase V4L2_PIX_FMT_RGB565X:\tdescr = \"16-bit RGB 5-6-5 BE\"; break;\n\tcase V4L2_PIX_FMT_BGR666:\tdescr = \"18-bit BGRX 6-6-6-14\"; break;\n\tcase V4L2_PIX_FMT_BGR24:\tdescr = \"24-bit BGR 8-8-8\"; break;\n\tcase V4L2_PIX_FMT_RGB24:\tdescr = \"24-bit RGB 8-8-8\"; break;\n\tcase V4L2_PIX_FMT_BGR32:\tdescr = \"32-bit BGRA/X 8-8-8-8\"; break;\n\tcase V4L2_PIX_FMT_ABGR32:\tdescr = \"32-bit BGRA 8-8-8-8\"; break;\n\tcase V4L2_PIX_FMT_XBGR32:\tdescr = \"32-bit BGRX 8-8-8-8\"; break;\n\tcase V4L2_PIX_FMT_RGB32:\tdescr = \"32-bit A/XRGB 8-8-8-8\"; break;\n\tcase V4L2_PIX_FMT_ARGB32:\tdescr = \"32-bit ARGB 8-8-8-8\"; break;\n\tcase V4L2_PIX_FMT_XRGB32:\tdescr = \"32-bit XRGB 8-8-8-8\"; break;\n\tcase V4L2_PIX_FMT_BGRA32:\tdescr = \"32-bit ABGR 8-8-8-8\"; break;\n\tcase V4L2_PIX_FMT_BGRX32:\tdescr = \"32-bit XBGR 8-8-8-8\"; break;\n\tcase V4L2_PIX_FMT_RGBA32:\tdescr = \"32-bit RGBA 8-8-8-8\"; break;\n\tcase V4L2_PIX_FMT_RGBX32:\tdescr = \"32-bit RGBX 8-8-8-8\"; break;\n\tcase V4L2_PIX_FMT_RGBX1010102:\tdescr = \"32-bit RGBX 10-10-10-2\"; break;\n\tcase V4L2_PIX_FMT_RGBA1010102:\tdescr = \"32-bit RGBA 10-10-10-2\"; break;\n\tcase V4L2_PIX_FMT_ARGB2101010:\tdescr = \"32-bit ARGB 2-10-10-10\"; break;\n\tcase V4L2_PIX_FMT_BGR48_12:\tdescr = \"12-bit Depth BGR\"; break;\n\tcase V4L2_PIX_FMT_ABGR64_12:\tdescr = \"12-bit Depth BGRA\"; break;\n\tcase V4L2_PIX_FMT_GREY:\t\tdescr = \"8-bit Greyscale\"; break;\n\tcase V4L2_PIX_FMT_Y4:\t\tdescr = \"4-bit Greyscale\"; break;\n\tcase V4L2_PIX_FMT_Y6:\t\tdescr = \"6-bit Greyscale\"; break;\n\tcase V4L2_PIX_FMT_Y10:\t\tdescr = \"10-bit Greyscale\"; break;\n\tcase V4L2_PIX_FMT_Y12:\t\tdescr = \"12-bit Greyscale\"; break;\n\tcase V4L2_PIX_FMT_Y012:\t\tdescr = \"12-bit Greyscale (bits 15-4)\"; break;\n\tcase V4L2_PIX_FMT_Y14:\t\tdescr = \"14-bit Greyscale\"; break;\n\tcase V4L2_PIX_FMT_Y16:\t\tdescr = \"16-bit Greyscale\"; break;\n\tcase V4L2_PIX_FMT_Y16_BE:\tdescr = \"16-bit Greyscale BE\"; break;\n\tcase V4L2_PIX_FMT_Y10BPACK:\tdescr = \"10-bit Greyscale (Packed)\"; break;\n\tcase V4L2_PIX_FMT_Y10P:\t\tdescr = \"10-bit Greyscale (MIPI Packed)\"; break;\n\tcase V4L2_PIX_FMT_IPU3_Y10:\tdescr = \"10-bit greyscale (IPU3 Packed)\"; break;\n\tcase V4L2_PIX_FMT_Y8I:\t\tdescr = \"Interleaved 8-bit Greyscale\"; break;\n\tcase V4L2_PIX_FMT_Y12I:\t\tdescr = \"Interleaved 12-bit Greyscale\"; break;\n\tcase V4L2_PIX_FMT_Z16:\t\tdescr = \"16-bit Depth\"; break;\n\tcase V4L2_PIX_FMT_INZI:\t\tdescr = \"Planar 10:16 Greyscale Depth\"; break;\n\tcase V4L2_PIX_FMT_CNF4:\t\tdescr = \"4-bit Depth Confidence (Packed)\"; break;\n\tcase V4L2_PIX_FMT_PAL8:\t\tdescr = \"8-bit Palette\"; break;\n\tcase V4L2_PIX_FMT_UV8:\t\tdescr = \"8-bit Chrominance UV 4-4\"; break;\n\tcase V4L2_PIX_FMT_YVU410:\tdescr = \"Planar YVU 4:1:0\"; break;\n\tcase V4L2_PIX_FMT_YVU420:\tdescr = \"Planar YVU 4:2:0\"; break;\n\tcase V4L2_PIX_FMT_YUYV:\t\tdescr = \"YUYV 4:2:2\"; break;\n\tcase V4L2_PIX_FMT_YYUV:\t\tdescr = \"YYUV 4:2:2\"; break;\n\tcase V4L2_PIX_FMT_YVYU:\t\tdescr = \"YVYU 4:2:2\"; break;\n\tcase V4L2_PIX_FMT_UYVY:\t\tdescr = \"UYVY 4:2:2\"; break;\n\tcase V4L2_PIX_FMT_VYUY:\t\tdescr = \"VYUY 4:2:2\"; break;\n\tcase V4L2_PIX_FMT_YUV422P:\tdescr = \"Planar YUV 4:2:2\"; break;\n\tcase V4L2_PIX_FMT_YUV411P:\tdescr = \"Planar YUV 4:1:1\"; break;\n\tcase V4L2_PIX_FMT_Y41P:\t\tdescr = \"YUV 4:1:1 (Packed)\"; break;\n\tcase V4L2_PIX_FMT_YUV444:\tdescr = \"16-bit A/XYUV 4-4-4-4\"; break;\n\tcase V4L2_PIX_FMT_YUV555:\tdescr = \"16-bit A/XYUV 1-5-5-5\"; break;\n\tcase V4L2_PIX_FMT_YUV565:\tdescr = \"16-bit YUV 5-6-5\"; break;\n\tcase V4L2_PIX_FMT_YUV24:\tdescr = \"24-bit YUV 4:4:4 8-8-8\"; break;\n\tcase V4L2_PIX_FMT_YUV32:\tdescr = \"32-bit A/XYUV 8-8-8-8\"; break;\n\tcase V4L2_PIX_FMT_AYUV32:\tdescr = \"32-bit AYUV 8-8-8-8\"; break;\n\tcase V4L2_PIX_FMT_XYUV32:\tdescr = \"32-bit XYUV 8-8-8-8\"; break;\n\tcase V4L2_PIX_FMT_VUYA32:\tdescr = \"32-bit VUYA 8-8-8-8\"; break;\n\tcase V4L2_PIX_FMT_VUYX32:\tdescr = \"32-bit VUYX 8-8-8-8\"; break;\n\tcase V4L2_PIX_FMT_YUVA32:\tdescr = \"32-bit YUVA 8-8-8-8\"; break;\n\tcase V4L2_PIX_FMT_YUVX32:\tdescr = \"32-bit YUVX 8-8-8-8\"; break;\n\tcase V4L2_PIX_FMT_YUV410:\tdescr = \"Planar YUV 4:1:0\"; break;\n\tcase V4L2_PIX_FMT_YUV420:\tdescr = \"Planar YUV 4:2:0\"; break;\n\tcase V4L2_PIX_FMT_HI240:\tdescr = \"8-bit Dithered RGB (BTTV)\"; break;\n\tcase V4L2_PIX_FMT_M420:\t\tdescr = \"YUV 4:2:0 (M420)\"; break;\n\tcase V4L2_PIX_FMT_YUV48_12:\tdescr = \"12-bit YUV 4:4:4 Packed\"; break;\n\tcase V4L2_PIX_FMT_NV12:\t\tdescr = \"Y/UV 4:2:0\"; break;\n\tcase V4L2_PIX_FMT_NV21:\t\tdescr = \"Y/VU 4:2:0\"; break;\n\tcase V4L2_PIX_FMT_NV16:\t\tdescr = \"Y/UV 4:2:2\"; break;\n\tcase V4L2_PIX_FMT_NV61:\t\tdescr = \"Y/VU 4:2:2\"; break;\n\tcase V4L2_PIX_FMT_NV24:\t\tdescr = \"Y/UV 4:4:4\"; break;\n\tcase V4L2_PIX_FMT_NV42:\t\tdescr = \"Y/VU 4:4:4\"; break;\n\tcase V4L2_PIX_FMT_P010:\t\tdescr = \"10-bit Y/UV 4:2:0\"; break;\n\tcase V4L2_PIX_FMT_P012:\t\tdescr = \"12-bit Y/UV 4:2:0\"; break;\n\tcase V4L2_PIX_FMT_NV12_4L4:\tdescr = \"Y/UV 4:2:0 (4x4 Linear)\"; break;\n\tcase V4L2_PIX_FMT_NV12_16L16:\tdescr = \"Y/UV 4:2:0 (16x16 Linear)\"; break;\n\tcase V4L2_PIX_FMT_NV12_32L32:   descr = \"Y/UV 4:2:0 (32x32 Linear)\"; break;\n\tcase V4L2_PIX_FMT_NV15_4L4:\tdescr = \"10-bit Y/UV 4:2:0 (4x4 Linear)\"; break;\n\tcase V4L2_PIX_FMT_P010_4L4:\tdescr = \"10-bit Y/UV 4:2:0 (4x4 Linear)\"; break;\n\tcase V4L2_PIX_FMT_NV12M:\tdescr = \"Y/UV 4:2:0 (N-C)\"; break;\n\tcase V4L2_PIX_FMT_NV21M:\tdescr = \"Y/VU 4:2:0 (N-C)\"; break;\n\tcase V4L2_PIX_FMT_NV16M:\tdescr = \"Y/UV 4:2:2 (N-C)\"; break;\n\tcase V4L2_PIX_FMT_NV61M:\tdescr = \"Y/VU 4:2:2 (N-C)\"; break;\n\tcase V4L2_PIX_FMT_NV12MT:\tdescr = \"Y/UV 4:2:0 (64x32 MB, N-C)\"; break;\n\tcase V4L2_PIX_FMT_NV12MT_16X16:\tdescr = \"Y/UV 4:2:0 (16x16 MB, N-C)\"; break;\n\tcase V4L2_PIX_FMT_P012M:\tdescr = \"12-bit Y/UV 4:2:0 (N-C)\"; break;\n\tcase V4L2_PIX_FMT_YUV420M:\tdescr = \"Planar YUV 4:2:0 (N-C)\"; break;\n\tcase V4L2_PIX_FMT_YVU420M:\tdescr = \"Planar YVU 4:2:0 (N-C)\"; break;\n\tcase V4L2_PIX_FMT_YUV422M:\tdescr = \"Planar YUV 4:2:2 (N-C)\"; break;\n\tcase V4L2_PIX_FMT_YVU422M:\tdescr = \"Planar YVU 4:2:2 (N-C)\"; break;\n\tcase V4L2_PIX_FMT_YUV444M:\tdescr = \"Planar YUV 4:4:4 (N-C)\"; break;\n\tcase V4L2_PIX_FMT_YVU444M:\tdescr = \"Planar YVU 4:4:4 (N-C)\"; break;\n\tcase V4L2_PIX_FMT_SBGGR8:\tdescr = \"8-bit Bayer BGBG/GRGR\"; break;\n\tcase V4L2_PIX_FMT_SGBRG8:\tdescr = \"8-bit Bayer GBGB/RGRG\"; break;\n\tcase V4L2_PIX_FMT_SGRBG8:\tdescr = \"8-bit Bayer GRGR/BGBG\"; break;\n\tcase V4L2_PIX_FMT_SRGGB8:\tdescr = \"8-bit Bayer RGRG/GBGB\"; break;\n\tcase V4L2_PIX_FMT_SBGGR10:\tdescr = \"10-bit Bayer BGBG/GRGR\"; break;\n\tcase V4L2_PIX_FMT_SGBRG10:\tdescr = \"10-bit Bayer GBGB/RGRG\"; break;\n\tcase V4L2_PIX_FMT_SGRBG10:\tdescr = \"10-bit Bayer GRGR/BGBG\"; break;\n\tcase V4L2_PIX_FMT_SRGGB10:\tdescr = \"10-bit Bayer RGRG/GBGB\"; break;\n\tcase V4L2_PIX_FMT_SBGGR10P:\tdescr = \"10-bit Bayer BGBG/GRGR Packed\"; break;\n\tcase V4L2_PIX_FMT_SGBRG10P:\tdescr = \"10-bit Bayer GBGB/RGRG Packed\"; break;\n\tcase V4L2_PIX_FMT_SGRBG10P:\tdescr = \"10-bit Bayer GRGR/BGBG Packed\"; break;\n\tcase V4L2_PIX_FMT_SRGGB10P:\tdescr = \"10-bit Bayer RGRG/GBGB Packed\"; break;\n\tcase V4L2_PIX_FMT_IPU3_SBGGR10: descr = \"10-bit bayer BGGR IPU3 Packed\"; break;\n\tcase V4L2_PIX_FMT_IPU3_SGBRG10: descr = \"10-bit bayer GBRG IPU3 Packed\"; break;\n\tcase V4L2_PIX_FMT_IPU3_SGRBG10: descr = \"10-bit bayer GRBG IPU3 Packed\"; break;\n\tcase V4L2_PIX_FMT_IPU3_SRGGB10: descr = \"10-bit bayer RGGB IPU3 Packed\"; break;\n\tcase V4L2_PIX_FMT_SBGGR10ALAW8:\tdescr = \"8-bit Bayer BGBG/GRGR (A-law)\"; break;\n\tcase V4L2_PIX_FMT_SGBRG10ALAW8:\tdescr = \"8-bit Bayer GBGB/RGRG (A-law)\"; break;\n\tcase V4L2_PIX_FMT_SGRBG10ALAW8:\tdescr = \"8-bit Bayer GRGR/BGBG (A-law)\"; break;\n\tcase V4L2_PIX_FMT_SRGGB10ALAW8:\tdescr = \"8-bit Bayer RGRG/GBGB (A-law)\"; break;\n\tcase V4L2_PIX_FMT_SBGGR10DPCM8:\tdescr = \"8-bit Bayer BGBG/GRGR (DPCM)\"; break;\n\tcase V4L2_PIX_FMT_SGBRG10DPCM8:\tdescr = \"8-bit Bayer GBGB/RGRG (DPCM)\"; break;\n\tcase V4L2_PIX_FMT_SGRBG10DPCM8:\tdescr = \"8-bit Bayer GRGR/BGBG (DPCM)\"; break;\n\tcase V4L2_PIX_FMT_SRGGB10DPCM8:\tdescr = \"8-bit Bayer RGRG/GBGB (DPCM)\"; break;\n\tcase V4L2_PIX_FMT_SBGGR12:\tdescr = \"12-bit Bayer BGBG/GRGR\"; break;\n\tcase V4L2_PIX_FMT_SGBRG12:\tdescr = \"12-bit Bayer GBGB/RGRG\"; break;\n\tcase V4L2_PIX_FMT_SGRBG12:\tdescr = \"12-bit Bayer GRGR/BGBG\"; break;\n\tcase V4L2_PIX_FMT_SRGGB12:\tdescr = \"12-bit Bayer RGRG/GBGB\"; break;\n\tcase V4L2_PIX_FMT_SBGGR12P:\tdescr = \"12-bit Bayer BGBG/GRGR Packed\"; break;\n\tcase V4L2_PIX_FMT_SGBRG12P:\tdescr = \"12-bit Bayer GBGB/RGRG Packed\"; break;\n\tcase V4L2_PIX_FMT_SGRBG12P:\tdescr = \"12-bit Bayer GRGR/BGBG Packed\"; break;\n\tcase V4L2_PIX_FMT_SRGGB12P:\tdescr = \"12-bit Bayer RGRG/GBGB Packed\"; break;\n\tcase V4L2_PIX_FMT_SBGGR14:\tdescr = \"14-bit Bayer BGBG/GRGR\"; break;\n\tcase V4L2_PIX_FMT_SGBRG14:\tdescr = \"14-bit Bayer GBGB/RGRG\"; break;\n\tcase V4L2_PIX_FMT_SGRBG14:\tdescr = \"14-bit Bayer GRGR/BGBG\"; break;\n\tcase V4L2_PIX_FMT_SRGGB14:\tdescr = \"14-bit Bayer RGRG/GBGB\"; break;\n\tcase V4L2_PIX_FMT_SBGGR14P:\tdescr = \"14-bit Bayer BGBG/GRGR Packed\"; break;\n\tcase V4L2_PIX_FMT_SGBRG14P:\tdescr = \"14-bit Bayer GBGB/RGRG Packed\"; break;\n\tcase V4L2_PIX_FMT_SGRBG14P:\tdescr = \"14-bit Bayer GRGR/BGBG Packed\"; break;\n\tcase V4L2_PIX_FMT_SRGGB14P:\tdescr = \"14-bit Bayer RGRG/GBGB Packed\"; break;\n\tcase V4L2_PIX_FMT_SBGGR16:\tdescr = \"16-bit Bayer BGBG/GRGR\"; break;\n\tcase V4L2_PIX_FMT_SGBRG16:\tdescr = \"16-bit Bayer GBGB/RGRG\"; break;\n\tcase V4L2_PIX_FMT_SGRBG16:\tdescr = \"16-bit Bayer GRGR/BGBG\"; break;\n\tcase V4L2_PIX_FMT_SRGGB16:\tdescr = \"16-bit Bayer RGRG/GBGB\"; break;\n\tcase V4L2_PIX_FMT_SN9C20X_I420:\tdescr = \"GSPCA SN9C20X I420\"; break;\n\tcase V4L2_PIX_FMT_SPCA501:\tdescr = \"GSPCA SPCA501\"; break;\n\tcase V4L2_PIX_FMT_SPCA505:\tdescr = \"GSPCA SPCA505\"; break;\n\tcase V4L2_PIX_FMT_SPCA508:\tdescr = \"GSPCA SPCA508\"; break;\n\tcase V4L2_PIX_FMT_STV0680:\tdescr = \"GSPCA STV0680\"; break;\n\tcase V4L2_PIX_FMT_TM6000:\tdescr = \"A/V + VBI Mux Packet\"; break;\n\tcase V4L2_PIX_FMT_CIT_YYVYUY:\tdescr = \"GSPCA CIT YYVYUY\"; break;\n\tcase V4L2_PIX_FMT_KONICA420:\tdescr = \"GSPCA KONICA420\"; break;\n\tcase V4L2_PIX_FMT_MM21:\t\tdescr = \"Mediatek 8-bit Block Format\"; break;\n\tcase V4L2_PIX_FMT_HSV24:\tdescr = \"24-bit HSV 8-8-8\"; break;\n\tcase V4L2_PIX_FMT_HSV32:\tdescr = \"32-bit XHSV 8-8-8-8\"; break;\n\tcase V4L2_SDR_FMT_CU8:\t\tdescr = \"Complex U8\"; break;\n\tcase V4L2_SDR_FMT_CU16LE:\tdescr = \"Complex U16LE\"; break;\n\tcase V4L2_SDR_FMT_CS8:\t\tdescr = \"Complex S8\"; break;\n\tcase V4L2_SDR_FMT_CS14LE:\tdescr = \"Complex S14LE\"; break;\n\tcase V4L2_SDR_FMT_RU12LE:\tdescr = \"Real U12LE\"; break;\n\tcase V4L2_SDR_FMT_PCU16BE:\tdescr = \"Planar Complex U16BE\"; break;\n\tcase V4L2_SDR_FMT_PCU18BE:\tdescr = \"Planar Complex U18BE\"; break;\n\tcase V4L2_SDR_FMT_PCU20BE:\tdescr = \"Planar Complex U20BE\"; break;\n\tcase V4L2_TCH_FMT_DELTA_TD16:\tdescr = \"16-bit Signed Deltas\"; break;\n\tcase V4L2_TCH_FMT_DELTA_TD08:\tdescr = \"8-bit Signed Deltas\"; break;\n\tcase V4L2_TCH_FMT_TU16:\t\tdescr = \"16-bit Unsigned Touch Data\"; break;\n\tcase V4L2_TCH_FMT_TU08:\t\tdescr = \"8-bit Unsigned Touch Data\"; break;\n\tcase V4L2_META_FMT_VSP1_HGO:\tdescr = \"R-Car VSP1 1-D Histogram\"; break;\n\tcase V4L2_META_FMT_VSP1_HGT:\tdescr = \"R-Car VSP1 2-D Histogram\"; break;\n\tcase V4L2_META_FMT_UVC:\t\tdescr = \"UVC Payload Header Metadata\"; break;\n\tcase V4L2_META_FMT_D4XX:\tdescr = \"Intel D4xx UVC Metadata\"; break;\n\tcase V4L2_META_FMT_VIVID:       descr = \"Vivid Metadata\"; break;\n\tcase V4L2_META_FMT_RK_ISP1_PARAMS:\tdescr = \"Rockchip ISP1 3A Parameters\"; break;\n\tcase V4L2_META_FMT_RK_ISP1_STAT_3A:\tdescr = \"Rockchip ISP1 3A Statistics\"; break;\n\tcase V4L2_PIX_FMT_NV12_8L128:\tdescr = \"NV12 (8x128 Linear)\"; break;\n\tcase V4L2_PIX_FMT_NV12M_8L128:\tdescr = \"NV12M (8x128 Linear)\"; break;\n\tcase V4L2_PIX_FMT_NV12_10BE_8L128:\tdescr = \"10-bit NV12 (8x128 Linear, BE)\"; break;\n\tcase V4L2_PIX_FMT_NV12M_10BE_8L128:\tdescr = \"10-bit NV12M (8x128 Linear, BE)\"; break;\n\tcase V4L2_PIX_FMT_Y210:\t\tdescr = \"10-bit YUYV Packed\"; break;\n\tcase V4L2_PIX_FMT_Y212:\t\tdescr = \"12-bit YUYV Packed\"; break;\n\tcase V4L2_PIX_FMT_Y216:\t\tdescr = \"16-bit YUYV Packed\"; break;\n\n\tdefault:\n\t\t \n\t\tflags = V4L2_FMT_FLAG_COMPRESSED;\n\t\tswitch (fmt->pixelformat) {\n\t\t \n\t\tcase V4L2_PIX_FMT_MJPEG:\tdescr = \"Motion-JPEG\"; break;\n\t\tcase V4L2_PIX_FMT_JPEG:\t\tdescr = \"JFIF JPEG\"; break;\n\t\tcase V4L2_PIX_FMT_DV:\t\tdescr = \"1394\"; break;\n\t\tcase V4L2_PIX_FMT_MPEG:\t\tdescr = \"MPEG-1/2/4\"; break;\n\t\tcase V4L2_PIX_FMT_H264:\t\tdescr = \"H.264\"; break;\n\t\tcase V4L2_PIX_FMT_H264_NO_SC:\tdescr = \"H.264 (No Start Codes)\"; break;\n\t\tcase V4L2_PIX_FMT_H264_MVC:\tdescr = \"H.264 MVC\"; break;\n\t\tcase V4L2_PIX_FMT_H264_SLICE:\tdescr = \"H.264 Parsed Slice Data\"; break;\n\t\tcase V4L2_PIX_FMT_H263:\t\tdescr = \"H.263\"; break;\n\t\tcase V4L2_PIX_FMT_MPEG1:\tdescr = \"MPEG-1 ES\"; break;\n\t\tcase V4L2_PIX_FMT_MPEG2:\tdescr = \"MPEG-2 ES\"; break;\n\t\tcase V4L2_PIX_FMT_MPEG2_SLICE:\tdescr = \"MPEG-2 Parsed Slice Data\"; break;\n\t\tcase V4L2_PIX_FMT_MPEG4:\tdescr = \"MPEG-4 Part 2 ES\"; break;\n\t\tcase V4L2_PIX_FMT_XVID:\t\tdescr = \"Xvid\"; break;\n\t\tcase V4L2_PIX_FMT_VC1_ANNEX_G:\tdescr = \"VC-1 (SMPTE 412M Annex G)\"; break;\n\t\tcase V4L2_PIX_FMT_VC1_ANNEX_L:\tdescr = \"VC-1 (SMPTE 412M Annex L)\"; break;\n\t\tcase V4L2_PIX_FMT_VP8:\t\tdescr = \"VP8\"; break;\n\t\tcase V4L2_PIX_FMT_VP8_FRAME:    descr = \"VP8 Frame\"; break;\n\t\tcase V4L2_PIX_FMT_VP9:\t\tdescr = \"VP9\"; break;\n\t\tcase V4L2_PIX_FMT_VP9_FRAME:    descr = \"VP9 Frame\"; break;\n\t\tcase V4L2_PIX_FMT_HEVC:\t\tdescr = \"HEVC\"; break;  \n\t\tcase V4L2_PIX_FMT_HEVC_SLICE:\tdescr = \"HEVC Parsed Slice Data\"; break;\n\t\tcase V4L2_PIX_FMT_FWHT:\t\tdescr = \"FWHT\"; break;  \n\t\tcase V4L2_PIX_FMT_FWHT_STATELESS:\tdescr = \"FWHT Stateless\"; break;  \n\t\tcase V4L2_PIX_FMT_SPK:\t\tdescr = \"Sorenson Spark\"; break;\n\t\tcase V4L2_PIX_FMT_RV30:\t\tdescr = \"RealVideo 8\"; break;\n\t\tcase V4L2_PIX_FMT_RV40:\t\tdescr = \"RealVideo 9 & 10\"; break;\n\t\tcase V4L2_PIX_FMT_CPIA1:\tdescr = \"GSPCA CPiA YUV\"; break;\n\t\tcase V4L2_PIX_FMT_WNVA:\t\tdescr = \"WNVA\"; break;\n\t\tcase V4L2_PIX_FMT_SN9C10X:\tdescr = \"GSPCA SN9C10X\"; break;\n\t\tcase V4L2_PIX_FMT_PWC1:\t\tdescr = \"Raw Philips Webcam Type (Old)\"; break;\n\t\tcase V4L2_PIX_FMT_PWC2:\t\tdescr = \"Raw Philips Webcam Type (New)\"; break;\n\t\tcase V4L2_PIX_FMT_ET61X251:\tdescr = \"GSPCA ET61X251\"; break;\n\t\tcase V4L2_PIX_FMT_SPCA561:\tdescr = \"GSPCA SPCA561\"; break;\n\t\tcase V4L2_PIX_FMT_PAC207:\tdescr = \"GSPCA PAC207\"; break;\n\t\tcase V4L2_PIX_FMT_MR97310A:\tdescr = \"GSPCA MR97310A\"; break;\n\t\tcase V4L2_PIX_FMT_JL2005BCD:\tdescr = \"GSPCA JL2005BCD\"; break;\n\t\tcase V4L2_PIX_FMT_SN9C2028:\tdescr = \"GSPCA SN9C2028\"; break;\n\t\tcase V4L2_PIX_FMT_SQ905C:\tdescr = \"GSPCA SQ905C\"; break;\n\t\tcase V4L2_PIX_FMT_PJPG:\t\tdescr = \"GSPCA PJPG\"; break;\n\t\tcase V4L2_PIX_FMT_OV511:\tdescr = \"GSPCA OV511\"; break;\n\t\tcase V4L2_PIX_FMT_OV518:\tdescr = \"GSPCA OV518\"; break;\n\t\tcase V4L2_PIX_FMT_JPGL:\t\tdescr = \"JPEG Lite\"; break;\n\t\tcase V4L2_PIX_FMT_SE401:\tdescr = \"GSPCA SE401\"; break;\n\t\tcase V4L2_PIX_FMT_S5C_UYVY_JPG:\tdescr = \"S5C73MX interleaved UYVY/JPEG\"; break;\n\t\tcase V4L2_PIX_FMT_MT21C:\tdescr = \"Mediatek Compressed Format\"; break;\n\t\tcase V4L2_PIX_FMT_QC08C:\tdescr = \"QCOM Compressed 8-bit Format\"; break;\n\t\tcase V4L2_PIX_FMT_QC10C:\tdescr = \"QCOM Compressed 10-bit Format\"; break;\n\t\tcase V4L2_PIX_FMT_AJPG:\t\tdescr = \"Aspeed JPEG\"; break;\n\t\tcase V4L2_PIX_FMT_AV1_FRAME:\tdescr = \"AV1 Frame\"; break;\n\t\tcase V4L2_PIX_FMT_MT2110T:\tdescr = \"Mediatek 10bit Tile Mode\"; break;\n\t\tcase V4L2_PIX_FMT_MT2110R:\tdescr = \"Mediatek 10bit Raster Mode\"; break;\n\t\tdefault:\n\t\t\tif (fmt->description[0])\n\t\t\t\treturn;\n\t\t\tWARN(1, \"Unknown pixelformat 0x%08x\\n\", fmt->pixelformat);\n\t\t\tflags = 0;\n\t\t\tsnprintf(fmt->description, sz, \"%p4cc\",\n\t\t\t\t &fmt->pixelformat);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (descr)\n\t\tWARN_ON(strscpy(fmt->description, descr, sz) < 0);\n\tfmt->flags |= flags;\n}\n\nstatic int v4l_enum_fmt(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct v4l2_fmtdesc *p = arg;\n\tint ret = check_fmt(file, p->type);\n\tu32 mbus_code;\n\tu32 cap_mask;\n\n\tif (ret)\n\t\treturn ret;\n\tret = -EINVAL;\n\n\tif (!(vdev->device_caps & V4L2_CAP_IO_MC))\n\t\tp->mbus_code = 0;\n\n\tmbus_code = p->mbus_code;\n\tmemset_after(p, 0, type);\n\tp->mbus_code = mbus_code;\n\n\tswitch (p->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\tcap_mask = V4L2_CAP_VIDEO_CAPTURE_MPLANE |\n\t\t\t   V4L2_CAP_VIDEO_M2M_MPLANE;\n\t\tif (!!(vdev->device_caps & cap_mask) !=\n\t\t    (p->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE))\n\t\t\tbreak;\n\n\t\tif (unlikely(!ops->vidioc_enum_fmt_vid_cap))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_vid_cap(file, fh, arg);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\t\tif (unlikely(!ops->vidioc_enum_fmt_vid_overlay))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_vid_overlay(file, fh, arg);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\tcap_mask = V4L2_CAP_VIDEO_OUTPUT_MPLANE |\n\t\t\t   V4L2_CAP_VIDEO_M2M_MPLANE;\n\t\tif (!!(vdev->device_caps & cap_mask) !=\n\t\t    (p->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE))\n\t\t\tbreak;\n\n\t\tif (unlikely(!ops->vidioc_enum_fmt_vid_out))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_vid_out(file, fh, arg);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_SDR_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_enum_fmt_sdr_cap))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_sdr_cap(file, fh, arg);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_SDR_OUTPUT:\n\t\tif (unlikely(!ops->vidioc_enum_fmt_sdr_out))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_sdr_out(file, fh, arg);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_META_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_enum_fmt_meta_cap))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_meta_cap(file, fh, arg);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_META_OUTPUT:\n\t\tif (unlikely(!ops->vidioc_enum_fmt_meta_out))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_meta_out(file, fh, arg);\n\t\tbreak;\n\t}\n\tif (ret == 0)\n\t\tv4l_fill_fmtdesc(p);\n\treturn ret;\n}\n\nstatic void v4l_pix_format_touch(struct v4l2_pix_format *p)\n{\n\t \n\n\tp->field = V4L2_FIELD_NONE;\n\tp->colorspace = V4L2_COLORSPACE_RAW;\n\tp->flags = 0;\n\tp->ycbcr_enc = 0;\n\tp->quantization = 0;\n\tp->xfer_func = 0;\n}\n\nstatic int v4l_g_fmt(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct v4l2_format *p = arg;\n\tstruct video_device *vfd = video_devdata(file);\n\tint ret = check_fmt(file, p->type);\n\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&p->fmt, 0, sizeof(p->fmt));\n\n\tswitch (p->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_g_fmt_vid_cap))\n\t\t\tbreak;\n\t\tp->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\n\t\tret = ops->vidioc_g_fmt_vid_cap(file, fh, arg);\n\t\t \n\t\tp->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\n\t\tif (vfd->vfl_type == VFL_TYPE_TOUCH)\n\t\t\tv4l_pix_format_touch(&p->fmt.pix);\n\t\treturn ret;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\treturn ops->vidioc_g_fmt_vid_cap_mplane(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\t\treturn ops->vidioc_g_fmt_vid_overlay(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n\t\treturn ops->vidioc_g_fmt_vbi_cap(file, fh, arg);\n\tcase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\n\t\treturn ops->vidioc_g_fmt_sliced_vbi_cap(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif (unlikely(!ops->vidioc_g_fmt_vid_out))\n\t\t\tbreak;\n\t\tp->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\n\t\tret = ops->vidioc_g_fmt_vid_out(file, fh, arg);\n\t\t \n\t\tp->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\n\t\treturn ret;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\treturn ops->vidioc_g_fmt_vid_out_mplane(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\n\t\treturn ops->vidioc_g_fmt_vid_out_overlay(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VBI_OUTPUT:\n\t\treturn ops->vidioc_g_fmt_vbi_out(file, fh, arg);\n\tcase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\n\t\treturn ops->vidioc_g_fmt_sliced_vbi_out(file, fh, arg);\n\tcase V4L2_BUF_TYPE_SDR_CAPTURE:\n\t\treturn ops->vidioc_g_fmt_sdr_cap(file, fh, arg);\n\tcase V4L2_BUF_TYPE_SDR_OUTPUT:\n\t\treturn ops->vidioc_g_fmt_sdr_out(file, fh, arg);\n\tcase V4L2_BUF_TYPE_META_CAPTURE:\n\t\treturn ops->vidioc_g_fmt_meta_cap(file, fh, arg);\n\tcase V4L2_BUF_TYPE_META_OUTPUT:\n\t\treturn ops->vidioc_g_fmt_meta_out(file, fh, arg);\n\t}\n\treturn -EINVAL;\n}\n\nstatic int v4l_s_fmt(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct v4l2_format *p = arg;\n\tstruct video_device *vfd = video_devdata(file);\n\tint ret = check_fmt(file, p->type);\n\tunsigned int i;\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = v4l_enable_media_source(vfd);\n\tif (ret)\n\t\treturn ret;\n\tv4l_sanitize_format(p);\n\n\tswitch (p->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_s_fmt_vid_cap))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.pix);\n\t\tret = ops->vidioc_s_fmt_vid_cap(file, fh, arg);\n\t\t \n\t\tp->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\n\t\tif (vfd->vfl_type == VFL_TYPE_TOUCH)\n\t\t\tv4l_pix_format_touch(&p->fmt.pix);\n\t\treturn ret;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\tif (unlikely(!ops->vidioc_s_fmt_vid_cap_mplane))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.pix_mp.xfer_func);\n\t\tfor (i = 0; i < p->fmt.pix_mp.num_planes; i++)\n\t\t\tmemset_after(&p->fmt.pix_mp.plane_fmt[i],\n\t\t\t\t     0, bytesperline);\n\t\treturn ops->vidioc_s_fmt_vid_cap_mplane(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\t\tif (unlikely(!ops->vidioc_s_fmt_vid_overlay))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.win);\n\t\tp->fmt.win.clips = NULL;\n\t\tp->fmt.win.clipcount = 0;\n\t\tp->fmt.win.bitmap = NULL;\n\t\treturn ops->vidioc_s_fmt_vid_overlay(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_s_fmt_vbi_cap))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.vbi.flags);\n\t\treturn ops->vidioc_s_fmt_vbi_cap(file, fh, arg);\n\tcase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_s_fmt_sliced_vbi_cap))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.sliced.io_size);\n\t\treturn ops->vidioc_s_fmt_sliced_vbi_cap(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif (unlikely(!ops->vidioc_s_fmt_vid_out))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.pix);\n\t\tret = ops->vidioc_s_fmt_vid_out(file, fh, arg);\n\t\t \n\t\tp->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\n\t\treturn ret;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\tif (unlikely(!ops->vidioc_s_fmt_vid_out_mplane))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.pix_mp.xfer_func);\n\t\tfor (i = 0; i < p->fmt.pix_mp.num_planes; i++)\n\t\t\tmemset_after(&p->fmt.pix_mp.plane_fmt[i],\n\t\t\t\t     0, bytesperline);\n\t\treturn ops->vidioc_s_fmt_vid_out_mplane(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\n\t\tif (unlikely(!ops->vidioc_s_fmt_vid_out_overlay))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.win);\n\t\tp->fmt.win.clips = NULL;\n\t\tp->fmt.win.clipcount = 0;\n\t\tp->fmt.win.bitmap = NULL;\n\t\treturn ops->vidioc_s_fmt_vid_out_overlay(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VBI_OUTPUT:\n\t\tif (unlikely(!ops->vidioc_s_fmt_vbi_out))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.vbi.flags);\n\t\treturn ops->vidioc_s_fmt_vbi_out(file, fh, arg);\n\tcase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\n\t\tif (unlikely(!ops->vidioc_s_fmt_sliced_vbi_out))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.sliced.io_size);\n\t\treturn ops->vidioc_s_fmt_sliced_vbi_out(file, fh, arg);\n\tcase V4L2_BUF_TYPE_SDR_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_s_fmt_sdr_cap))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.sdr.buffersize);\n\t\treturn ops->vidioc_s_fmt_sdr_cap(file, fh, arg);\n\tcase V4L2_BUF_TYPE_SDR_OUTPUT:\n\t\tif (unlikely(!ops->vidioc_s_fmt_sdr_out))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.sdr.buffersize);\n\t\treturn ops->vidioc_s_fmt_sdr_out(file, fh, arg);\n\tcase V4L2_BUF_TYPE_META_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_s_fmt_meta_cap))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.meta);\n\t\treturn ops->vidioc_s_fmt_meta_cap(file, fh, arg);\n\tcase V4L2_BUF_TYPE_META_OUTPUT:\n\t\tif (unlikely(!ops->vidioc_s_fmt_meta_out))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.meta);\n\t\treturn ops->vidioc_s_fmt_meta_out(file, fh, arg);\n\t}\n\treturn -EINVAL;\n}\n\nstatic int v4l_try_fmt(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct v4l2_format *p = arg;\n\tstruct video_device *vfd = video_devdata(file);\n\tint ret = check_fmt(file, p->type);\n\tunsigned int i;\n\n\tif (ret)\n\t\treturn ret;\n\n\tv4l_sanitize_format(p);\n\n\tswitch (p->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_try_fmt_vid_cap))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.pix);\n\t\tret = ops->vidioc_try_fmt_vid_cap(file, fh, arg);\n\t\t \n\t\tp->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\n\t\tif (vfd->vfl_type == VFL_TYPE_TOUCH)\n\t\t\tv4l_pix_format_touch(&p->fmt.pix);\n\t\treturn ret;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\tif (unlikely(!ops->vidioc_try_fmt_vid_cap_mplane))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.pix_mp.xfer_func);\n\t\tfor (i = 0; i < p->fmt.pix_mp.num_planes; i++)\n\t\t\tmemset_after(&p->fmt.pix_mp.plane_fmt[i],\n\t\t\t\t     0, bytesperline);\n\t\treturn ops->vidioc_try_fmt_vid_cap_mplane(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\t\tif (unlikely(!ops->vidioc_try_fmt_vid_overlay))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.win);\n\t\tp->fmt.win.clips = NULL;\n\t\tp->fmt.win.clipcount = 0;\n\t\tp->fmt.win.bitmap = NULL;\n\t\treturn ops->vidioc_try_fmt_vid_overlay(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_try_fmt_vbi_cap))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.vbi.flags);\n\t\treturn ops->vidioc_try_fmt_vbi_cap(file, fh, arg);\n\tcase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_try_fmt_sliced_vbi_cap))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.sliced.io_size);\n\t\treturn ops->vidioc_try_fmt_sliced_vbi_cap(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif (unlikely(!ops->vidioc_try_fmt_vid_out))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.pix);\n\t\tret = ops->vidioc_try_fmt_vid_out(file, fh, arg);\n\t\t \n\t\tp->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\n\t\treturn ret;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\tif (unlikely(!ops->vidioc_try_fmt_vid_out_mplane))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.pix_mp.xfer_func);\n\t\tfor (i = 0; i < p->fmt.pix_mp.num_planes; i++)\n\t\t\tmemset_after(&p->fmt.pix_mp.plane_fmt[i],\n\t\t\t\t     0, bytesperline);\n\t\treturn ops->vidioc_try_fmt_vid_out_mplane(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\n\t\tif (unlikely(!ops->vidioc_try_fmt_vid_out_overlay))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.win);\n\t\tp->fmt.win.clips = NULL;\n\t\tp->fmt.win.clipcount = 0;\n\t\tp->fmt.win.bitmap = NULL;\n\t\treturn ops->vidioc_try_fmt_vid_out_overlay(file, fh, arg);\n\tcase V4L2_BUF_TYPE_VBI_OUTPUT:\n\t\tif (unlikely(!ops->vidioc_try_fmt_vbi_out))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.vbi.flags);\n\t\treturn ops->vidioc_try_fmt_vbi_out(file, fh, arg);\n\tcase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\n\t\tif (unlikely(!ops->vidioc_try_fmt_sliced_vbi_out))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.sliced.io_size);\n\t\treturn ops->vidioc_try_fmt_sliced_vbi_out(file, fh, arg);\n\tcase V4L2_BUF_TYPE_SDR_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_try_fmt_sdr_cap))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.sdr.buffersize);\n\t\treturn ops->vidioc_try_fmt_sdr_cap(file, fh, arg);\n\tcase V4L2_BUF_TYPE_SDR_OUTPUT:\n\t\tif (unlikely(!ops->vidioc_try_fmt_sdr_out))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.sdr.buffersize);\n\t\treturn ops->vidioc_try_fmt_sdr_out(file, fh, arg);\n\tcase V4L2_BUF_TYPE_META_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_try_fmt_meta_cap))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.meta);\n\t\treturn ops->vidioc_try_fmt_meta_cap(file, fh, arg);\n\tcase V4L2_BUF_TYPE_META_OUTPUT:\n\t\tif (unlikely(!ops->vidioc_try_fmt_meta_out))\n\t\t\tbreak;\n\t\tmemset_after(p, 0, fmt.meta);\n\t\treturn ops->vidioc_try_fmt_meta_out(file, fh, arg);\n\t}\n\treturn -EINVAL;\n}\n\nstatic int v4l_streamon(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\treturn ops->vidioc_streamon(file, fh, *(unsigned int *)arg);\n}\n\nstatic int v4l_streamoff(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\treturn ops->vidioc_streamoff(file, fh, *(unsigned int *)arg);\n}\n\nstatic int v4l_g_tuner(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_tuner *p = arg;\n\tint err;\n\n\tp->type = (vfd->vfl_type == VFL_TYPE_RADIO) ?\n\t\t\tV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\n\terr = ops->vidioc_g_tuner(file, fh, p);\n\tif (!err)\n\t\tp->capability |= V4L2_TUNER_CAP_FREQ_BANDS;\n\treturn err;\n}\n\nstatic int v4l_s_tuner(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_tuner *p = arg;\n\tint ret;\n\n\tret = v4l_enable_media_source(vfd);\n\tif (ret)\n\t\treturn ret;\n\tp->type = (vfd->vfl_type == VFL_TYPE_RADIO) ?\n\t\t\tV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\n\treturn ops->vidioc_s_tuner(file, fh, p);\n}\n\nstatic int v4l_g_modulator(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_modulator *p = arg;\n\tint err;\n\n\tif (vfd->vfl_type == VFL_TYPE_RADIO)\n\t\tp->type = V4L2_TUNER_RADIO;\n\n\terr = ops->vidioc_g_modulator(file, fh, p);\n\tif (!err)\n\t\tp->capability |= V4L2_TUNER_CAP_FREQ_BANDS;\n\treturn err;\n}\n\nstatic int v4l_s_modulator(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_modulator *p = arg;\n\n\tif (vfd->vfl_type == VFL_TYPE_RADIO)\n\t\tp->type = V4L2_TUNER_RADIO;\n\n\treturn ops->vidioc_s_modulator(file, fh, p);\n}\n\nstatic int v4l_g_frequency(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_frequency *p = arg;\n\n\tif (vfd->vfl_type == VFL_TYPE_SDR)\n\t\tp->type = V4L2_TUNER_SDR;\n\telse\n\t\tp->type = (vfd->vfl_type == VFL_TYPE_RADIO) ?\n\t\t\t\tV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\n\treturn ops->vidioc_g_frequency(file, fh, p);\n}\n\nstatic int v4l_s_frequency(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tconst struct v4l2_frequency *p = arg;\n\tenum v4l2_tuner_type type;\n\tint ret;\n\n\tret = v4l_enable_media_source(vfd);\n\tif (ret)\n\t\treturn ret;\n\tif (vfd->vfl_type == VFL_TYPE_SDR) {\n\t\tif (p->type != V4L2_TUNER_SDR && p->type != V4L2_TUNER_RF)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\ttype = (vfd->vfl_type == VFL_TYPE_RADIO) ?\n\t\t\t\tV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\n\t\tif (type != p->type)\n\t\t\treturn -EINVAL;\n\t}\n\treturn ops->vidioc_s_frequency(file, fh, p);\n}\n\nstatic int v4l_enumstd(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_standard *p = arg;\n\n\treturn v4l_video_std_enumstd(p, vfd->tvnorms);\n}\n\nstatic int v4l_s_std(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tv4l2_std_id id = *(v4l2_std_id *)arg, norm;\n\tint ret;\n\n\tret = v4l_enable_media_source(vfd);\n\tif (ret)\n\t\treturn ret;\n\tnorm = id & vfd->tvnorms;\n\tif (vfd->tvnorms && !norm)\t \n\t\treturn -EINVAL;\n\n\t \n\treturn ops->vidioc_s_std(file, fh, norm);\n}\n\nstatic int v4l_querystd(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tv4l2_std_id *p = arg;\n\tint ret;\n\n\tret = v4l_enable_media_source(vfd);\n\tif (ret)\n\t\treturn ret;\n\t \n\t*p = vfd->tvnorms;\n\treturn ops->vidioc_querystd(file, fh, arg);\n}\n\nstatic int v4l_s_hw_freq_seek(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_hw_freq_seek *p = arg;\n\tenum v4l2_tuner_type type;\n\tint ret;\n\n\tret = v4l_enable_media_source(vfd);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (vfd->vfl_type == VFL_TYPE_SDR)\n\t\treturn -EINVAL;\n\n\ttype = (vfd->vfl_type == VFL_TYPE_RADIO) ?\n\t\tV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\n\tif (p->type != type)\n\t\treturn -EINVAL;\n\treturn ops->vidioc_s_hw_freq_seek(file, fh, p);\n}\n\nstatic int v4l_s_fbuf(const struct v4l2_ioctl_ops *ops,\n\t\t      struct file *file, void *fh, void *arg)\n{\n\tstruct v4l2_framebuffer *p = arg;\n\n\tp->base = NULL;\n\treturn ops->vidioc_s_fbuf(file, fh, p);\n}\n\nstatic int v4l_overlay(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\treturn ops->vidioc_overlay(file, fh, *(unsigned int *)arg);\n}\n\nstatic int v4l_reqbufs(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct v4l2_requestbuffers *p = arg;\n\tint ret = check_fmt(file, p->type);\n\n\tif (ret)\n\t\treturn ret;\n\n\tmemset_after(p, 0, flags);\n\n\treturn ops->vidioc_reqbufs(file, fh, p);\n}\n\nstatic int v4l_querybuf(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct v4l2_buffer *p = arg;\n\tint ret = check_fmt(file, p->type);\n\n\treturn ret ? ret : ops->vidioc_querybuf(file, fh, p);\n}\n\nstatic int v4l_qbuf(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct v4l2_buffer *p = arg;\n\tint ret = check_fmt(file, p->type);\n\n\treturn ret ? ret : ops->vidioc_qbuf(file, fh, p);\n}\n\nstatic int v4l_dqbuf(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct v4l2_buffer *p = arg;\n\tint ret = check_fmt(file, p->type);\n\n\treturn ret ? ret : ops->vidioc_dqbuf(file, fh, p);\n}\n\nstatic int v4l_create_bufs(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct v4l2_create_buffers *create = arg;\n\tint ret = check_fmt(file, create->format.type);\n\n\tif (ret)\n\t\treturn ret;\n\n\tmemset_after(create, 0, flags);\n\n\tv4l_sanitize_format(&create->format);\n\n\tret = ops->vidioc_create_bufs(file, fh, create);\n\n\tif (create->format.type == V4L2_BUF_TYPE_VIDEO_CAPTURE ||\n\t    create->format.type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\tcreate->format.fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\n\n\treturn ret;\n}\n\nstatic int v4l_prepare_buf(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct v4l2_buffer *b = arg;\n\tint ret = check_fmt(file, b->type);\n\n\treturn ret ? ret : ops->vidioc_prepare_buf(file, fh, b);\n}\n\nstatic int v4l_g_parm(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_streamparm *p = arg;\n\tv4l2_std_id std;\n\tint ret = check_fmt(file, p->type);\n\n\tif (ret)\n\t\treturn ret;\n\tif (ops->vidioc_g_parm)\n\t\treturn ops->vidioc_g_parm(file, fh, p);\n\tif (p->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\n\t    p->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\treturn -EINVAL;\n\tif (vfd->device_caps & V4L2_CAP_READWRITE)\n\t\tp->parm.capture.readbuffers = 2;\n\tret = ops->vidioc_g_std(file, fh, &std);\n\tif (ret == 0)\n\t\tv4l2_video_std_frame_period(std, &p->parm.capture.timeperframe);\n\treturn ret;\n}\n\nstatic int v4l_s_parm(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct v4l2_streamparm *p = arg;\n\tint ret = check_fmt(file, p->type);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (V4L2_TYPE_IS_OUTPUT(p->type)) {\n\t\tmemset(p->parm.output.reserved, 0,\n\t\t       sizeof(p->parm.output.reserved));\n\t\tp->parm.output.extendedmode = 0;\n\t\tp->parm.output.outputmode &= V4L2_MODE_HIGHQUALITY;\n\t} else {\n\t\tmemset(p->parm.capture.reserved, 0,\n\t\t       sizeof(p->parm.capture.reserved));\n\t\tp->parm.capture.extendedmode = 0;\n\t\tp->parm.capture.capturemode &= V4L2_MODE_HIGHQUALITY;\n\t}\n\treturn ops->vidioc_s_parm(file, fh, p);\n}\n\nstatic int v4l_queryctrl(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_queryctrl *p = arg;\n\tstruct v4l2_fh *vfh =\n\t\ttest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\n\n\tif (vfh && vfh->ctrl_handler)\n\t\treturn v4l2_queryctrl(vfh->ctrl_handler, p);\n\tif (vfd->ctrl_handler)\n\t\treturn v4l2_queryctrl(vfd->ctrl_handler, p);\n\tif (ops->vidioc_queryctrl)\n\t\treturn ops->vidioc_queryctrl(file, fh, p);\n\treturn -ENOTTY;\n}\n\nstatic int v4l_query_ext_ctrl(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_query_ext_ctrl *p = arg;\n\tstruct v4l2_fh *vfh =\n\t\ttest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\n\n\tif (vfh && vfh->ctrl_handler)\n\t\treturn v4l2_query_ext_ctrl(vfh->ctrl_handler, p);\n\tif (vfd->ctrl_handler)\n\t\treturn v4l2_query_ext_ctrl(vfd->ctrl_handler, p);\n\tif (ops->vidioc_query_ext_ctrl)\n\t\treturn ops->vidioc_query_ext_ctrl(file, fh, p);\n\treturn -ENOTTY;\n}\n\nstatic int v4l_querymenu(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_querymenu *p = arg;\n\tstruct v4l2_fh *vfh =\n\t\ttest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\n\n\tif (vfh && vfh->ctrl_handler)\n\t\treturn v4l2_querymenu(vfh->ctrl_handler, p);\n\tif (vfd->ctrl_handler)\n\t\treturn v4l2_querymenu(vfd->ctrl_handler, p);\n\tif (ops->vidioc_querymenu)\n\t\treturn ops->vidioc_querymenu(file, fh, p);\n\treturn -ENOTTY;\n}\n\nstatic int v4l_g_ctrl(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_control *p = arg;\n\tstruct v4l2_fh *vfh =\n\t\ttest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\n\tstruct v4l2_ext_controls ctrls;\n\tstruct v4l2_ext_control ctrl;\n\n\tif (vfh && vfh->ctrl_handler)\n\t\treturn v4l2_g_ctrl(vfh->ctrl_handler, p);\n\tif (vfd->ctrl_handler)\n\t\treturn v4l2_g_ctrl(vfd->ctrl_handler, p);\n\tif (ops->vidioc_g_ctrl)\n\t\treturn ops->vidioc_g_ctrl(file, fh, p);\n\tif (ops->vidioc_g_ext_ctrls == NULL)\n\t\treturn -ENOTTY;\n\n\tctrls.which = V4L2_CTRL_ID2WHICH(p->id);\n\tctrls.count = 1;\n\tctrls.controls = &ctrl;\n\tctrl.id = p->id;\n\tctrl.value = p->value;\n\tif (check_ext_ctrls(&ctrls, VIDIOC_G_CTRL)) {\n\t\tint ret = ops->vidioc_g_ext_ctrls(file, fh, &ctrls);\n\n\t\tif (ret == 0)\n\t\t\tp->value = ctrl.value;\n\t\treturn ret;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int v4l_s_ctrl(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_control *p = arg;\n\tstruct v4l2_fh *vfh =\n\t\ttest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\n\tstruct v4l2_ext_controls ctrls;\n\tstruct v4l2_ext_control ctrl;\n\tint ret;\n\n\tif (vfh && vfh->ctrl_handler)\n\t\treturn v4l2_s_ctrl(vfh, vfh->ctrl_handler, p);\n\tif (vfd->ctrl_handler)\n\t\treturn v4l2_s_ctrl(NULL, vfd->ctrl_handler, p);\n\tif (ops->vidioc_s_ctrl)\n\t\treturn ops->vidioc_s_ctrl(file, fh, p);\n\tif (ops->vidioc_s_ext_ctrls == NULL)\n\t\treturn -ENOTTY;\n\n\tctrls.which = V4L2_CTRL_ID2WHICH(p->id);\n\tctrls.count = 1;\n\tctrls.controls = &ctrl;\n\tctrl.id = p->id;\n\tctrl.value = p->value;\n\tif (!check_ext_ctrls(&ctrls, VIDIOC_S_CTRL))\n\t\treturn -EINVAL;\n\tret = ops->vidioc_s_ext_ctrls(file, fh, &ctrls);\n\tp->value = ctrl.value;\n\treturn ret;\n}\n\nstatic int v4l_g_ext_ctrls(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_ext_controls *p = arg;\n\tstruct v4l2_fh *vfh =\n\t\ttest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\n\n\tp->error_idx = p->count;\n\tif (vfh && vfh->ctrl_handler)\n\t\treturn v4l2_g_ext_ctrls(vfh->ctrl_handler,\n\t\t\t\t\tvfd, vfd->v4l2_dev->mdev, p);\n\tif (vfd->ctrl_handler)\n\t\treturn v4l2_g_ext_ctrls(vfd->ctrl_handler,\n\t\t\t\t\tvfd, vfd->v4l2_dev->mdev, p);\n\tif (ops->vidioc_g_ext_ctrls == NULL)\n\t\treturn -ENOTTY;\n\treturn check_ext_ctrls(p, VIDIOC_G_EXT_CTRLS) ?\n\t\t\t\tops->vidioc_g_ext_ctrls(file, fh, p) : -EINVAL;\n}\n\nstatic int v4l_s_ext_ctrls(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_ext_controls *p = arg;\n\tstruct v4l2_fh *vfh =\n\t\ttest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\n\n\tp->error_idx = p->count;\n\tif (vfh && vfh->ctrl_handler)\n\t\treturn v4l2_s_ext_ctrls(vfh, vfh->ctrl_handler,\n\t\t\t\t\tvfd, vfd->v4l2_dev->mdev, p);\n\tif (vfd->ctrl_handler)\n\t\treturn v4l2_s_ext_ctrls(NULL, vfd->ctrl_handler,\n\t\t\t\t\tvfd, vfd->v4l2_dev->mdev, p);\n\tif (ops->vidioc_s_ext_ctrls == NULL)\n\t\treturn -ENOTTY;\n\treturn check_ext_ctrls(p, VIDIOC_S_EXT_CTRLS) ?\n\t\t\t\tops->vidioc_s_ext_ctrls(file, fh, p) : -EINVAL;\n}\n\nstatic int v4l_try_ext_ctrls(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_ext_controls *p = arg;\n\tstruct v4l2_fh *vfh =\n\t\ttest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\n\n\tp->error_idx = p->count;\n\tif (vfh && vfh->ctrl_handler)\n\t\treturn v4l2_try_ext_ctrls(vfh->ctrl_handler,\n\t\t\t\t\t  vfd, vfd->v4l2_dev->mdev, p);\n\tif (vfd->ctrl_handler)\n\t\treturn v4l2_try_ext_ctrls(vfd->ctrl_handler,\n\t\t\t\t\t  vfd, vfd->v4l2_dev->mdev, p);\n\tif (ops->vidioc_try_ext_ctrls == NULL)\n\t\treturn -ENOTTY;\n\treturn check_ext_ctrls(p, VIDIOC_TRY_EXT_CTRLS) ?\n\t\t\tops->vidioc_try_ext_ctrls(file, fh, p) : -EINVAL;\n}\n\n \nstatic int v4l_g_selection(const struct v4l2_ioctl_ops *ops,\n\t\t\t   struct file *file, void *fh, void *arg)\n{\n\tstruct v4l2_selection *p = arg;\n\tu32 old_type = p->type;\n\tint ret;\n\n\tif (p->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\tp->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\telse if (p->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tp->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tret = ops->vidioc_g_selection(file, fh, p);\n\tp->type = old_type;\n\treturn ret;\n}\n\nstatic int v4l_s_selection(const struct v4l2_ioctl_ops *ops,\n\t\t\t   struct file *file, void *fh, void *arg)\n{\n\tstruct v4l2_selection *p = arg;\n\tu32 old_type = p->type;\n\tint ret;\n\n\tif (p->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\tp->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\telse if (p->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tp->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tret = ops->vidioc_s_selection(file, fh, p);\n\tp->type = old_type;\n\treturn ret;\n}\n\nstatic int v4l_g_crop(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_crop *p = arg;\n\tstruct v4l2_selection s = {\n\t\t.type = p->type,\n\t};\n\tint ret;\n\n\t \n\n\t \n\tif (V4L2_TYPE_IS_OUTPUT(p->type))\n\t\ts.target = V4L2_SEL_TGT_COMPOSE;\n\telse\n\t\ts.target = V4L2_SEL_TGT_CROP;\n\n\tif (test_bit(V4L2_FL_QUIRK_INVERTED_CROP, &vfd->flags))\n\t\ts.target = s.target == V4L2_SEL_TGT_COMPOSE ?\n\t\t\tV4L2_SEL_TGT_CROP : V4L2_SEL_TGT_COMPOSE;\n\n\tret = v4l_g_selection(ops, file, fh, &s);\n\n\t \n\tif (!ret)\n\t\tp->c = s.r;\n\treturn ret;\n}\n\nstatic int v4l_s_crop(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_crop *p = arg;\n\tstruct v4l2_selection s = {\n\t\t.type = p->type,\n\t\t.r = p->c,\n\t};\n\n\t \n\n\t \n\tif (V4L2_TYPE_IS_OUTPUT(p->type))\n\t\ts.target = V4L2_SEL_TGT_COMPOSE;\n\telse\n\t\ts.target = V4L2_SEL_TGT_CROP;\n\n\tif (test_bit(V4L2_FL_QUIRK_INVERTED_CROP, &vfd->flags))\n\t\ts.target = s.target == V4L2_SEL_TGT_COMPOSE ?\n\t\t\tV4L2_SEL_TGT_CROP : V4L2_SEL_TGT_COMPOSE;\n\n\treturn v4l_s_selection(ops, file, fh, &s);\n}\n\nstatic int v4l_cropcap(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_cropcap *p = arg;\n\tstruct v4l2_selection s = { .type = p->type };\n\tint ret = 0;\n\n\t \n\tp->pixelaspect.numerator = 1;\n\tp->pixelaspect.denominator = 1;\n\n\tif (s.type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\ts.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\telse if (s.type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\ts.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\n\t \n\tif (WARN_ON(!ops->vidioc_g_selection))\n\t\treturn -ENOTTY;\n\n\tif (ops->vidioc_g_pixelaspect)\n\t\tret = ops->vidioc_g_pixelaspect(file, fh, s.type,\n\t\t\t\t\t\t&p->pixelaspect);\n\n\t \n\tif (ret && ret != -ENOTTY && ret != -ENOIOCTLCMD)\n\t\treturn ret;\n\n\t \n\n\t \n\tif (V4L2_TYPE_IS_OUTPUT(p->type))\n\t\ts.target = V4L2_SEL_TGT_COMPOSE_BOUNDS;\n\telse\n\t\ts.target = V4L2_SEL_TGT_CROP_BOUNDS;\n\n\tif (test_bit(V4L2_FL_QUIRK_INVERTED_CROP, &vfd->flags))\n\t\ts.target = s.target == V4L2_SEL_TGT_COMPOSE_BOUNDS ?\n\t\t\tV4L2_SEL_TGT_CROP_BOUNDS : V4L2_SEL_TGT_COMPOSE_BOUNDS;\n\n\tret = v4l_g_selection(ops, file, fh, &s);\n\tif (ret)\n\t\treturn ret;\n\tp->bounds = s.r;\n\n\t \n\tif (s.target == V4L2_SEL_TGT_COMPOSE_BOUNDS)\n\t\ts.target = V4L2_SEL_TGT_COMPOSE_DEFAULT;\n\telse\n\t\ts.target = V4L2_SEL_TGT_CROP_DEFAULT;\n\n\tret = v4l_g_selection(ops, file, fh, &s);\n\tif (ret)\n\t\treturn ret;\n\tp->defrect = s.r;\n\n\treturn 0;\n}\n\nstatic int v4l_log_status(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tint ret;\n\n\tif (vfd->v4l2_dev)\n\t\tpr_info(\"%s: =================  START STATUS  =================\\n\",\n\t\t\tvfd->v4l2_dev->name);\n\tret = ops->vidioc_log_status(file, fh);\n\tif (vfd->v4l2_dev)\n\t\tpr_info(\"%s: ==================  END STATUS  ==================\\n\",\n\t\t\tvfd->v4l2_dev->name);\n\treturn ret;\n}\n\nstatic int v4l_dbg_g_register(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\tstruct v4l2_dbg_register *p = arg;\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_subdev *sd;\n\tint idx = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (p->match.type == V4L2_CHIP_MATCH_SUBDEV) {\n\t\tif (vfd->v4l2_dev == NULL)\n\t\t\treturn -EINVAL;\n\t\tv4l2_device_for_each_subdev(sd, vfd->v4l2_dev)\n\t\t\tif (p->match.addr == idx++)\n\t\t\t\treturn v4l2_subdev_call(sd, core, g_register, p);\n\t\treturn -EINVAL;\n\t}\n\tif (ops->vidioc_g_register && p->match.type == V4L2_CHIP_MATCH_BRIDGE &&\n\t    (ops->vidioc_g_chip_info || p->match.addr == 0))\n\t\treturn ops->vidioc_g_register(file, fh, p);\n\treturn -EINVAL;\n#else\n\treturn -ENOTTY;\n#endif\n}\n\nstatic int v4l_dbg_s_register(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\tconst struct v4l2_dbg_register *p = arg;\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_subdev *sd;\n\tint idx = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (p->match.type == V4L2_CHIP_MATCH_SUBDEV) {\n\t\tif (vfd->v4l2_dev == NULL)\n\t\t\treturn -EINVAL;\n\t\tv4l2_device_for_each_subdev(sd, vfd->v4l2_dev)\n\t\t\tif (p->match.addr == idx++)\n\t\t\t\treturn v4l2_subdev_call(sd, core, s_register, p);\n\t\treturn -EINVAL;\n\t}\n\tif (ops->vidioc_s_register && p->match.type == V4L2_CHIP_MATCH_BRIDGE &&\n\t    (ops->vidioc_g_chip_info || p->match.addr == 0))\n\t\treturn ops->vidioc_s_register(file, fh, p);\n\treturn -EINVAL;\n#else\n\treturn -ENOTTY;\n#endif\n}\n\nstatic int v4l_dbg_g_chip_info(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_dbg_chip_info *p = arg;\n\tstruct v4l2_subdev *sd;\n\tint idx = 0;\n\n\tswitch (p->match.type) {\n\tcase V4L2_CHIP_MATCH_BRIDGE:\n\t\tif (ops->vidioc_s_register)\n\t\t\tp->flags |= V4L2_CHIP_FL_WRITABLE;\n\t\tif (ops->vidioc_g_register)\n\t\t\tp->flags |= V4L2_CHIP_FL_READABLE;\n\t\tstrscpy(p->name, vfd->v4l2_dev->name, sizeof(p->name));\n\t\tif (ops->vidioc_g_chip_info)\n\t\t\treturn ops->vidioc_g_chip_info(file, fh, arg);\n\t\tif (p->match.addr)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\n\tcase V4L2_CHIP_MATCH_SUBDEV:\n\t\tif (vfd->v4l2_dev == NULL)\n\t\t\tbreak;\n\t\tv4l2_device_for_each_subdev(sd, vfd->v4l2_dev) {\n\t\t\tif (p->match.addr != idx++)\n\t\t\t\tcontinue;\n\t\t\tif (sd->ops->core && sd->ops->core->s_register)\n\t\t\t\tp->flags |= V4L2_CHIP_FL_WRITABLE;\n\t\t\tif (sd->ops->core && sd->ops->core->g_register)\n\t\t\t\tp->flags |= V4L2_CHIP_FL_READABLE;\n\t\t\tstrscpy(p->name, sd->name, sizeof(p->name));\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n#else\n\treturn -ENOTTY;\n#endif\n}\n\nstatic int v4l_dqevent(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\treturn v4l2_event_dequeue(fh, arg, file->f_flags & O_NONBLOCK);\n}\n\nstatic int v4l_subscribe_event(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\treturn ops->vidioc_subscribe_event(fh, arg);\n}\n\nstatic int v4l_unsubscribe_event(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\treturn ops->vidioc_unsubscribe_event(fh, arg);\n}\n\nstatic int v4l_g_sliced_vbi_cap(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct v4l2_sliced_vbi_cap *p = arg;\n\tint ret = check_fmt(file, p->type);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmemset(p, 0, offsetof(struct v4l2_sliced_vbi_cap, type));\n\n\treturn ops->vidioc_g_sliced_vbi_cap(file, fh, p);\n}\n\nstatic int v4l_enum_freq_bands(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct v4l2_frequency_band *p = arg;\n\tenum v4l2_tuner_type type;\n\tint err;\n\n\tif (vfd->vfl_type == VFL_TYPE_SDR) {\n\t\tif (p->type != V4L2_TUNER_SDR && p->type != V4L2_TUNER_RF)\n\t\t\treturn -EINVAL;\n\t\ttype = p->type;\n\t} else {\n\t\ttype = (vfd->vfl_type == VFL_TYPE_RADIO) ?\n\t\t\t\tV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\n\t\tif (type != p->type)\n\t\t\treturn -EINVAL;\n\t}\n\tif (ops->vidioc_enum_freq_bands) {\n\t\terr = ops->vidioc_enum_freq_bands(file, fh, p);\n\t\tif (err != -ENOTTY)\n\t\t\treturn err;\n\t}\n\tif (is_valid_ioctl(vfd, VIDIOC_G_TUNER)) {\n\t\tstruct v4l2_tuner t = {\n\t\t\t.index = p->tuner,\n\t\t\t.type = type,\n\t\t};\n\n\t\tif (p->index)\n\t\t\treturn -EINVAL;\n\t\terr = ops->vidioc_g_tuner(file, fh, &t);\n\t\tif (err)\n\t\t\treturn err;\n\t\tp->capability = t.capability | V4L2_TUNER_CAP_FREQ_BANDS;\n\t\tp->rangelow = t.rangelow;\n\t\tp->rangehigh = t.rangehigh;\n\t\tp->modulation = (type == V4L2_TUNER_RADIO) ?\n\t\t\tV4L2_BAND_MODULATION_FM : V4L2_BAND_MODULATION_VSB;\n\t\treturn 0;\n\t}\n\tif (is_valid_ioctl(vfd, VIDIOC_G_MODULATOR)) {\n\t\tstruct v4l2_modulator m = {\n\t\t\t.index = p->tuner,\n\t\t};\n\n\t\tif (type != V4L2_TUNER_RADIO)\n\t\t\treturn -EINVAL;\n\t\tif (p->index)\n\t\t\treturn -EINVAL;\n\t\terr = ops->vidioc_g_modulator(file, fh, &m);\n\t\tif (err)\n\t\t\treturn err;\n\t\tp->capability = m.capability | V4L2_TUNER_CAP_FREQ_BANDS;\n\t\tp->rangelow = m.rangelow;\n\t\tp->rangehigh = m.rangehigh;\n\t\tp->modulation = (type == V4L2_TUNER_RADIO) ?\n\t\t\tV4L2_BAND_MODULATION_FM : V4L2_BAND_MODULATION_VSB;\n\t\treturn 0;\n\t}\n\treturn -ENOTTY;\n}\n\nstruct v4l2_ioctl_info {\n\tunsigned int ioctl;\n\tu32 flags;\n\tconst char * const name;\n\tint (*func)(const struct v4l2_ioctl_ops *ops, struct file *file,\n\t\t    void *fh, void *p);\n\tvoid (*debug)(const void *arg, bool write_only);\n};\n\n \n#define INFO_FL_PRIO\t\t(1 << 0)\n \n#define INFO_FL_CTRL\t\t(1 << 1)\n \n#define INFO_FL_QUEUE\t\t(1 << 2)\n \n#define INFO_FL_ALWAYS_COPY\t(1 << 3)\n \n#define INFO_FL_CLEAR(v4l2_struct, field)\t\t\t\\\n\t((offsetof(struct v4l2_struct, field) +\t\t\t\\\n\t  sizeof_field(struct v4l2_struct, field)) << 16)\n#define INFO_FL_CLEAR_MASK\t(_IOC_SIZEMASK << 16)\n\n#define DEFINE_V4L_STUB_FUNC(_vidioc)\t\t\t\t\\\n\tstatic int v4l_stub_ ## _vidioc(\t\t\t\\\n\t\t\tconst struct v4l2_ioctl_ops *ops,\t\\\n\t\t\tstruct file *file, void *fh, void *p)\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\treturn ops->vidioc_ ## _vidioc(file, fh, p);\t\\\n\t}\n\n#define IOCTL_INFO(_ioctl, _func, _debug, _flags)\t\t\\\n\t[_IOC_NR(_ioctl)] = {\t\t\t\t\t\\\n\t\t.ioctl = _ioctl,\t\t\t\t\\\n\t\t.flags = _flags,\t\t\t\t\\\n\t\t.name = #_ioctl,\t\t\t\t\\\n\t\t.func = _func,\t\t\t\t\t\\\n\t\t.debug = _debug,\t\t\t\t\\\n\t}\n\nDEFINE_V4L_STUB_FUNC(g_fbuf)\nDEFINE_V4L_STUB_FUNC(expbuf)\nDEFINE_V4L_STUB_FUNC(g_std)\nDEFINE_V4L_STUB_FUNC(g_audio)\nDEFINE_V4L_STUB_FUNC(s_audio)\nDEFINE_V4L_STUB_FUNC(g_edid)\nDEFINE_V4L_STUB_FUNC(s_edid)\nDEFINE_V4L_STUB_FUNC(g_audout)\nDEFINE_V4L_STUB_FUNC(s_audout)\nDEFINE_V4L_STUB_FUNC(g_jpegcomp)\nDEFINE_V4L_STUB_FUNC(s_jpegcomp)\nDEFINE_V4L_STUB_FUNC(enumaudio)\nDEFINE_V4L_STUB_FUNC(enumaudout)\nDEFINE_V4L_STUB_FUNC(enum_framesizes)\nDEFINE_V4L_STUB_FUNC(enum_frameintervals)\nDEFINE_V4L_STUB_FUNC(g_enc_index)\nDEFINE_V4L_STUB_FUNC(encoder_cmd)\nDEFINE_V4L_STUB_FUNC(try_encoder_cmd)\nDEFINE_V4L_STUB_FUNC(decoder_cmd)\nDEFINE_V4L_STUB_FUNC(try_decoder_cmd)\nDEFINE_V4L_STUB_FUNC(s_dv_timings)\nDEFINE_V4L_STUB_FUNC(g_dv_timings)\nDEFINE_V4L_STUB_FUNC(enum_dv_timings)\nDEFINE_V4L_STUB_FUNC(query_dv_timings)\nDEFINE_V4L_STUB_FUNC(dv_timings_cap)\n\nstatic const struct v4l2_ioctl_info v4l2_ioctls[] = {\n\tIOCTL_INFO(VIDIOC_QUERYCAP, v4l_querycap, v4l_print_querycap, 0),\n\tIOCTL_INFO(VIDIOC_ENUM_FMT, v4l_enum_fmt, v4l_print_fmtdesc, 0),\n\tIOCTL_INFO(VIDIOC_G_FMT, v4l_g_fmt, v4l_print_format, 0),\n\tIOCTL_INFO(VIDIOC_S_FMT, v4l_s_fmt, v4l_print_format, INFO_FL_PRIO),\n\tIOCTL_INFO(VIDIOC_REQBUFS, v4l_reqbufs, v4l_print_requestbuffers, INFO_FL_PRIO | INFO_FL_QUEUE),\n\tIOCTL_INFO(VIDIOC_QUERYBUF, v4l_querybuf, v4l_print_buffer, INFO_FL_QUEUE | INFO_FL_CLEAR(v4l2_buffer, length)),\n\tIOCTL_INFO(VIDIOC_G_FBUF, v4l_stub_g_fbuf, v4l_print_framebuffer, 0),\n\tIOCTL_INFO(VIDIOC_S_FBUF, v4l_s_fbuf, v4l_print_framebuffer, INFO_FL_PRIO),\n\tIOCTL_INFO(VIDIOC_OVERLAY, v4l_overlay, v4l_print_u32, INFO_FL_PRIO),\n\tIOCTL_INFO(VIDIOC_QBUF, v4l_qbuf, v4l_print_buffer, INFO_FL_QUEUE),\n\tIOCTL_INFO(VIDIOC_EXPBUF, v4l_stub_expbuf, v4l_print_exportbuffer, INFO_FL_QUEUE | INFO_FL_CLEAR(v4l2_exportbuffer, flags)),\n\tIOCTL_INFO(VIDIOC_DQBUF, v4l_dqbuf, v4l_print_buffer, INFO_FL_QUEUE),\n\tIOCTL_INFO(VIDIOC_STREAMON, v4l_streamon, v4l_print_buftype, INFO_FL_PRIO | INFO_FL_QUEUE),\n\tIOCTL_INFO(VIDIOC_STREAMOFF, v4l_streamoff, v4l_print_buftype, INFO_FL_PRIO | INFO_FL_QUEUE),\n\tIOCTL_INFO(VIDIOC_G_PARM, v4l_g_parm, v4l_print_streamparm, INFO_FL_CLEAR(v4l2_streamparm, type)),\n\tIOCTL_INFO(VIDIOC_S_PARM, v4l_s_parm, v4l_print_streamparm, INFO_FL_PRIO),\n\tIOCTL_INFO(VIDIOC_G_STD, v4l_stub_g_std, v4l_print_std, 0),\n\tIOCTL_INFO(VIDIOC_S_STD, v4l_s_std, v4l_print_std, INFO_FL_PRIO),\n\tIOCTL_INFO(VIDIOC_ENUMSTD, v4l_enumstd, v4l_print_standard, INFO_FL_CLEAR(v4l2_standard, index)),\n\tIOCTL_INFO(VIDIOC_ENUMINPUT, v4l_enuminput, v4l_print_enuminput, INFO_FL_CLEAR(v4l2_input, index)),\n\tIOCTL_INFO(VIDIOC_G_CTRL, v4l_g_ctrl, v4l_print_control, INFO_FL_CTRL | INFO_FL_CLEAR(v4l2_control, id)),\n\tIOCTL_INFO(VIDIOC_S_CTRL, v4l_s_ctrl, v4l_print_control, INFO_FL_PRIO | INFO_FL_CTRL),\n\tIOCTL_INFO(VIDIOC_G_TUNER, v4l_g_tuner, v4l_print_tuner, INFO_FL_CLEAR(v4l2_tuner, index)),\n\tIOCTL_INFO(VIDIOC_S_TUNER, v4l_s_tuner, v4l_print_tuner, INFO_FL_PRIO),\n\tIOCTL_INFO(VIDIOC_G_AUDIO, v4l_stub_g_audio, v4l_print_audio, 0),\n\tIOCTL_INFO(VIDIOC_S_AUDIO, v4l_stub_s_audio, v4l_print_audio, INFO_FL_PRIO),\n\tIOCTL_INFO(VIDIOC_QUERYCTRL, v4l_queryctrl, v4l_print_queryctrl, INFO_FL_CTRL | INFO_FL_CLEAR(v4l2_queryctrl, id)),\n\tIOCTL_INFO(VIDIOC_QUERYMENU, v4l_querymenu, v4l_print_querymenu, INFO_FL_CTRL | INFO_FL_CLEAR(v4l2_querymenu, index)),\n\tIOCTL_INFO(VIDIOC_G_INPUT, v4l_g_input, v4l_print_u32, 0),\n\tIOCTL_INFO(VIDIOC_S_INPUT, v4l_s_input, v4l_print_u32, INFO_FL_PRIO),\n\tIOCTL_INFO(VIDIOC_G_EDID, v4l_stub_g_edid, v4l_print_edid, INFO_FL_ALWAYS_COPY),\n\tIOCTL_INFO(VIDIOC_S_EDID, v4l_stub_s_edid, v4l_print_edid, INFO_FL_PRIO | INFO_FL_ALWAYS_COPY),\n\tIOCTL_INFO(VIDIOC_G_OUTPUT, v4l_g_output, v4l_print_u32, 0),\n\tIOCTL_INFO(VIDIOC_S_OUTPUT, v4l_s_output, v4l_print_u32, INFO_FL_PRIO),\n\tIOCTL_INFO(VIDIOC_ENUMOUTPUT, v4l_enumoutput, v4l_print_enumoutput, INFO_FL_CLEAR(v4l2_output, index)),\n\tIOCTL_INFO(VIDIOC_G_AUDOUT, v4l_stub_g_audout, v4l_print_audioout, 0),\n\tIOCTL_INFO(VIDIOC_S_AUDOUT, v4l_stub_s_audout, v4l_print_audioout, INFO_FL_PRIO),\n\tIOCTL_INFO(VIDIOC_G_MODULATOR, v4l_g_modulator, v4l_print_modulator, INFO_FL_CLEAR(v4l2_modulator, index)),\n\tIOCTL_INFO(VIDIOC_S_MODULATOR, v4l_s_modulator, v4l_print_modulator, INFO_FL_PRIO),\n\tIOCTL_INFO(VIDIOC_G_FREQUENCY, v4l_g_frequency, v4l_print_frequency, INFO_FL_CLEAR(v4l2_frequency, tuner)),\n\tIOCTL_INFO(VIDIOC_S_FREQUENCY, v4l_s_frequency, v4l_print_frequency, INFO_FL_PRIO),\n\tIOCTL_INFO(VIDIOC_CROPCAP, v4l_cropcap, v4l_print_cropcap, INFO_FL_CLEAR(v4l2_cropcap, type)),\n\tIOCTL_INFO(VIDIOC_G_CROP, v4l_g_crop, v4l_print_crop, INFO_FL_CLEAR(v4l2_crop, type)),\n\tIOCTL_INFO(VIDIOC_S_CROP, v4l_s_crop, v4l_print_crop, INFO_FL_PRIO),\n\tIOCTL_INFO(VIDIOC_G_SELECTION, v4l_g_selection, v4l_print_selection, INFO_FL_CLEAR(v4l2_selection, r)),\n\tIOCTL_INFO(VIDIOC_S_SELECTION, v4l_s_selection, v4l_print_selection, INFO_FL_PRIO | INFO_FL_CLEAR(v4l2_selection, r)),\n\tIOCTL_INFO(VIDIOC_G_JPEGCOMP, v4l_stub_g_jpegcomp, v4l_print_jpegcompression, 0),\n\tIOCTL_INFO(VIDIOC_S_JPEGCOMP, v4l_stub_s_jpegcomp, v4l_print_jpegcompression, INFO_FL_PRIO),\n\tIOCTL_INFO(VIDIOC_QUERYSTD, v4l_querystd, v4l_print_std, 0),\n\tIOCTL_INFO(VIDIOC_TRY_FMT, v4l_try_fmt, v4l_print_format, 0),\n\tIOCTL_INFO(VIDIOC_ENUMAUDIO, v4l_stub_enumaudio, v4l_print_audio, INFO_FL_CLEAR(v4l2_audio, index)),\n\tIOCTL_INFO(VIDIOC_ENUMAUDOUT, v4l_stub_enumaudout, v4l_print_audioout, INFO_FL_CLEAR(v4l2_audioout, index)),\n\tIOCTL_INFO(VIDIOC_G_PRIORITY, v4l_g_priority, v4l_print_u32, 0),\n\tIOCTL_INFO(VIDIOC_S_PRIORITY, v4l_s_priority, v4l_print_u32, INFO_FL_PRIO),\n\tIOCTL_INFO(VIDIOC_G_SLICED_VBI_CAP, v4l_g_sliced_vbi_cap, v4l_print_sliced_vbi_cap, INFO_FL_CLEAR(v4l2_sliced_vbi_cap, type)),\n\tIOCTL_INFO(VIDIOC_LOG_STATUS, v4l_log_status, v4l_print_newline, 0),\n\tIOCTL_INFO(VIDIOC_G_EXT_CTRLS, v4l_g_ext_ctrls, v4l_print_ext_controls, INFO_FL_CTRL | INFO_FL_ALWAYS_COPY),\n\tIOCTL_INFO(VIDIOC_S_EXT_CTRLS, v4l_s_ext_ctrls, v4l_print_ext_controls, INFO_FL_PRIO | INFO_FL_CTRL | INFO_FL_ALWAYS_COPY),\n\tIOCTL_INFO(VIDIOC_TRY_EXT_CTRLS, v4l_try_ext_ctrls, v4l_print_ext_controls, INFO_FL_CTRL | INFO_FL_ALWAYS_COPY),\n\tIOCTL_INFO(VIDIOC_ENUM_FRAMESIZES, v4l_stub_enum_framesizes, v4l_print_frmsizeenum, INFO_FL_CLEAR(v4l2_frmsizeenum, pixel_format)),\n\tIOCTL_INFO(VIDIOC_ENUM_FRAMEINTERVALS, v4l_stub_enum_frameintervals, v4l_print_frmivalenum, INFO_FL_CLEAR(v4l2_frmivalenum, height)),\n\tIOCTL_INFO(VIDIOC_G_ENC_INDEX, v4l_stub_g_enc_index, v4l_print_enc_idx, 0),\n\tIOCTL_INFO(VIDIOC_ENCODER_CMD, v4l_stub_encoder_cmd, v4l_print_encoder_cmd, INFO_FL_PRIO | INFO_FL_CLEAR(v4l2_encoder_cmd, flags)),\n\tIOCTL_INFO(VIDIOC_TRY_ENCODER_CMD, v4l_stub_try_encoder_cmd, v4l_print_encoder_cmd, INFO_FL_CLEAR(v4l2_encoder_cmd, flags)),\n\tIOCTL_INFO(VIDIOC_DECODER_CMD, v4l_stub_decoder_cmd, v4l_print_decoder_cmd, INFO_FL_PRIO),\n\tIOCTL_INFO(VIDIOC_TRY_DECODER_CMD, v4l_stub_try_decoder_cmd, v4l_print_decoder_cmd, 0),\n\tIOCTL_INFO(VIDIOC_DBG_S_REGISTER, v4l_dbg_s_register, v4l_print_dbg_register, 0),\n\tIOCTL_INFO(VIDIOC_DBG_G_REGISTER, v4l_dbg_g_register, v4l_print_dbg_register, 0),\n\tIOCTL_INFO(VIDIOC_S_HW_FREQ_SEEK, v4l_s_hw_freq_seek, v4l_print_hw_freq_seek, INFO_FL_PRIO),\n\tIOCTL_INFO(VIDIOC_S_DV_TIMINGS, v4l_stub_s_dv_timings, v4l_print_dv_timings, INFO_FL_PRIO | INFO_FL_CLEAR(v4l2_dv_timings, bt.flags)),\n\tIOCTL_INFO(VIDIOC_G_DV_TIMINGS, v4l_stub_g_dv_timings, v4l_print_dv_timings, 0),\n\tIOCTL_INFO(VIDIOC_DQEVENT, v4l_dqevent, v4l_print_event, 0),\n\tIOCTL_INFO(VIDIOC_SUBSCRIBE_EVENT, v4l_subscribe_event, v4l_print_event_subscription, 0),\n\tIOCTL_INFO(VIDIOC_UNSUBSCRIBE_EVENT, v4l_unsubscribe_event, v4l_print_event_subscription, 0),\n\tIOCTL_INFO(VIDIOC_CREATE_BUFS, v4l_create_bufs, v4l_print_create_buffers, INFO_FL_PRIO | INFO_FL_QUEUE),\n\tIOCTL_INFO(VIDIOC_PREPARE_BUF, v4l_prepare_buf, v4l_print_buffer, INFO_FL_QUEUE),\n\tIOCTL_INFO(VIDIOC_ENUM_DV_TIMINGS, v4l_stub_enum_dv_timings, v4l_print_enum_dv_timings, INFO_FL_CLEAR(v4l2_enum_dv_timings, pad)),\n\tIOCTL_INFO(VIDIOC_QUERY_DV_TIMINGS, v4l_stub_query_dv_timings, v4l_print_dv_timings, INFO_FL_ALWAYS_COPY),\n\tIOCTL_INFO(VIDIOC_DV_TIMINGS_CAP, v4l_stub_dv_timings_cap, v4l_print_dv_timings_cap, INFO_FL_CLEAR(v4l2_dv_timings_cap, pad)),\n\tIOCTL_INFO(VIDIOC_ENUM_FREQ_BANDS, v4l_enum_freq_bands, v4l_print_freq_band, 0),\n\tIOCTL_INFO(VIDIOC_DBG_G_CHIP_INFO, v4l_dbg_g_chip_info, v4l_print_dbg_chip_info, INFO_FL_CLEAR(v4l2_dbg_chip_info, match)),\n\tIOCTL_INFO(VIDIOC_QUERY_EXT_CTRL, v4l_query_ext_ctrl, v4l_print_query_ext_ctrl, INFO_FL_CTRL | INFO_FL_CLEAR(v4l2_query_ext_ctrl, id)),\n};\n#define V4L2_IOCTLS ARRAY_SIZE(v4l2_ioctls)\n\nstatic bool v4l2_is_known_ioctl(unsigned int cmd)\n{\n\tif (_IOC_NR(cmd) >= V4L2_IOCTLS)\n\t\treturn false;\n\treturn v4l2_ioctls[_IOC_NR(cmd)].ioctl == cmd;\n}\n\nstatic struct mutex *v4l2_ioctl_get_lock(struct video_device *vdev,\n\t\t\t\t\t struct v4l2_fh *vfh, unsigned int cmd,\n\t\t\t\t\t void *arg)\n{\n\tif (_IOC_NR(cmd) >= V4L2_IOCTLS)\n\t\treturn vdev->lock;\n\tif (vfh && vfh->m2m_ctx &&\n\t    (v4l2_ioctls[_IOC_NR(cmd)].flags & INFO_FL_QUEUE)) {\n\t\tif (vfh->m2m_ctx->q_lock)\n\t\t\treturn vfh->m2m_ctx->q_lock;\n\t}\n\tif (vdev->queue && vdev->queue->lock &&\n\t\t\t(v4l2_ioctls[_IOC_NR(cmd)].flags & INFO_FL_QUEUE))\n\t\treturn vdev->queue->lock;\n\treturn vdev->lock;\n}\n\n \nvoid v4l_printk_ioctl(const char *prefix, unsigned int cmd)\n{\n\tconst char *dir, *type;\n\n\tif (prefix)\n\t\tprintk(KERN_DEBUG \"%s: \", prefix);\n\n\tswitch (_IOC_TYPE(cmd)) {\n\tcase 'd':\n\t\ttype = \"v4l2_int\";\n\t\tbreak;\n\tcase 'V':\n\t\tif (_IOC_NR(cmd) >= V4L2_IOCTLS) {\n\t\t\ttype = \"v4l2\";\n\t\t\tbreak;\n\t\t}\n\t\tpr_cont(\"%s\", v4l2_ioctls[_IOC_NR(cmd)].name);\n\t\treturn;\n\tdefault:\n\t\ttype = \"unknown\";\n\t\tbreak;\n\t}\n\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_NONE:              dir = \"--\"; break;\n\tcase _IOC_READ:              dir = \"r-\"; break;\n\tcase _IOC_WRITE:             dir = \"-w\"; break;\n\tcase _IOC_READ | _IOC_WRITE: dir = \"rw\"; break;\n\tdefault:                     dir = \"*ERR*\"; break;\n\t}\n\tpr_cont(\"%s ioctl '%c', dir=%s, #%d (0x%08x)\",\n\t\ttype, _IOC_TYPE(cmd), dir, _IOC_NR(cmd), cmd);\n}\nEXPORT_SYMBOL(v4l_printk_ioctl);\n\nstatic long __video_do_ioctl(struct file *file,\n\t\tunsigned int cmd, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct mutex *req_queue_lock = NULL;\n\tstruct mutex *lock;  \n\tconst struct v4l2_ioctl_ops *ops = vfd->ioctl_ops;\n\tbool write_only = false;\n\tstruct v4l2_ioctl_info default_info;\n\tconst struct v4l2_ioctl_info *info;\n\tvoid *fh = file->private_data;\n\tstruct v4l2_fh *vfh = NULL;\n\tint dev_debug = vfd->dev_debug;\n\tlong ret = -ENOTTY;\n\n\tif (ops == NULL) {\n\t\tpr_warn(\"%s: has no ioctl_ops.\\n\",\n\t\t\t\tvideo_device_node_name(vfd));\n\t\treturn ret;\n\t}\n\n\tif (test_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags))\n\t\tvfh = file->private_data;\n\n\t \n\tif (v4l2_device_supports_requests(vfd->v4l2_dev) &&\n\t    (cmd == VIDIOC_STREAMON || cmd == VIDIOC_STREAMOFF)) {\n\t\treq_queue_lock = &vfd->v4l2_dev->mdev->req_queue_mutex;\n\n\t\tif (mutex_lock_interruptible(req_queue_lock))\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\tlock = v4l2_ioctl_get_lock(vfd, vfh, cmd, arg);\n\n\tif (lock && mutex_lock_interruptible(lock)) {\n\t\tif (req_queue_lock)\n\t\t\tmutex_unlock(req_queue_lock);\n\t\treturn -ERESTARTSYS;\n\t}\n\n\tif (!video_is_registered(vfd)) {\n\t\tret = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\tif (v4l2_is_known_ioctl(cmd)) {\n\t\tinfo = &v4l2_ioctls[_IOC_NR(cmd)];\n\n\t\tif (!test_bit(_IOC_NR(cmd), vfd->valid_ioctls) &&\n\t\t    !((info->flags & INFO_FL_CTRL) && vfh && vfh->ctrl_handler))\n\t\t\tgoto done;\n\n\t\tif (vfh && (info->flags & INFO_FL_PRIO)) {\n\t\t\tret = v4l2_prio_check(vfd->prio, vfh->prio);\n\t\t\tif (ret)\n\t\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\tdefault_info.ioctl = cmd;\n\t\tdefault_info.flags = 0;\n\t\tdefault_info.debug = v4l_print_default;\n\t\tinfo = &default_info;\n\t}\n\n\twrite_only = _IOC_DIR(cmd) == _IOC_WRITE;\n\tif (info != &default_info) {\n\t\tret = info->func(ops, file, fh, arg);\n\t} else if (!ops->vidioc_default) {\n\t\tret = -ENOTTY;\n\t} else {\n\t\tret = ops->vidioc_default(file, fh,\n\t\t\tvfh ? v4l2_prio_check(vfd->prio, vfh->prio) >= 0 : 0,\n\t\t\tcmd, arg);\n\t}\n\ndone:\n\tif (dev_debug & (V4L2_DEV_DEBUG_IOCTL | V4L2_DEV_DEBUG_IOCTL_ARG)) {\n\t\tif (!(dev_debug & V4L2_DEV_DEBUG_STREAMING) &&\n\t\t    (cmd == VIDIOC_QBUF || cmd == VIDIOC_DQBUF))\n\t\t\tgoto unlock;\n\n\t\tv4l_printk_ioctl(video_device_node_name(vfd), cmd);\n\t\tif (ret < 0)\n\t\t\tpr_cont(\": error %ld\", ret);\n\t\tif (!(dev_debug & V4L2_DEV_DEBUG_IOCTL_ARG))\n\t\t\tpr_cont(\"\\n\");\n\t\telse if (_IOC_DIR(cmd) == _IOC_NONE)\n\t\t\tinfo->debug(arg, write_only);\n\t\telse {\n\t\t\tpr_cont(\": \");\n\t\t\tinfo->debug(arg, write_only);\n\t\t}\n\t}\n\nunlock:\n\tif (lock)\n\t\tmutex_unlock(lock);\n\tif (req_queue_lock)\n\t\tmutex_unlock(req_queue_lock);\n\treturn ret;\n}\n\nstatic int check_array_args(unsigned int cmd, void *parg, size_t *array_size,\n\t\t\t    void __user **user_ptr, void ***kernel_ptr)\n{\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase VIDIOC_PREPARE_BUF:\n\tcase VIDIOC_QUERYBUF:\n\tcase VIDIOC_QBUF:\n\tcase VIDIOC_DQBUF: {\n\t\tstruct v4l2_buffer *buf = parg;\n\n\t\tif (V4L2_TYPE_IS_MULTIPLANAR(buf->type) && buf->length > 0) {\n\t\t\tif (buf->length > VIDEO_MAX_PLANES) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*user_ptr = (void __user *)buf->m.planes;\n\t\t\t*kernel_ptr = (void **)&buf->m.planes;\n\t\t\t*array_size = sizeof(struct v4l2_plane) * buf->length;\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase VIDIOC_G_EDID:\n\tcase VIDIOC_S_EDID: {\n\t\tstruct v4l2_edid *edid = parg;\n\n\t\tif (edid->blocks) {\n\t\t\tif (edid->blocks > 256) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*user_ptr = (void __user *)edid->edid;\n\t\t\t*kernel_ptr = (void **)&edid->edid;\n\t\t\t*array_size = edid->blocks * 128;\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase VIDIOC_S_EXT_CTRLS:\n\tcase VIDIOC_G_EXT_CTRLS:\n\tcase VIDIOC_TRY_EXT_CTRLS: {\n\t\tstruct v4l2_ext_controls *ctrls = parg;\n\n\t\tif (ctrls->count != 0) {\n\t\t\tif (ctrls->count > V4L2_CID_MAX_CTRLS) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*user_ptr = (void __user *)ctrls->controls;\n\t\t\t*kernel_ptr = (void **)&ctrls->controls;\n\t\t\t*array_size = sizeof(struct v4l2_ext_control)\n\t\t\t\t    * ctrls->count;\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase VIDIOC_SUBDEV_G_ROUTING:\n\tcase VIDIOC_SUBDEV_S_ROUTING: {\n\t\tstruct v4l2_subdev_routing *routing = parg;\n\n\t\tif (routing->num_routes > 256)\n\t\t\treturn -E2BIG;\n\n\t\t*user_ptr = u64_to_user_ptr(routing->routes);\n\t\t*kernel_ptr = (void **)&routing->routes;\n\t\t*array_size = sizeof(struct v4l2_subdev_route)\n\t\t\t    * routing->num_routes;\n\t\tret = 1;\n\t\tbreak;\n\t}\n\t}\n\n\treturn ret;\n}\n\nstatic unsigned int video_translate_cmd(unsigned int cmd)\n{\n#if !defined(CONFIG_64BIT) && defined(CONFIG_COMPAT_32BIT_TIME)\n\tswitch (cmd) {\n\tcase VIDIOC_DQEVENT_TIME32:\n\t\treturn VIDIOC_DQEVENT;\n\tcase VIDIOC_QUERYBUF_TIME32:\n\t\treturn VIDIOC_QUERYBUF;\n\tcase VIDIOC_QBUF_TIME32:\n\t\treturn VIDIOC_QBUF;\n\tcase VIDIOC_DQBUF_TIME32:\n\t\treturn VIDIOC_DQBUF;\n\tcase VIDIOC_PREPARE_BUF_TIME32:\n\t\treturn VIDIOC_PREPARE_BUF;\n\t}\n#endif\n\tif (in_compat_syscall())\n\t\treturn v4l2_compat_translate_cmd(cmd);\n\n\treturn cmd;\n}\n\nstatic int video_get_user(void __user *arg, void *parg,\n\t\t\t  unsigned int real_cmd, unsigned int cmd,\n\t\t\t  bool *always_copy)\n{\n\tunsigned int n = _IOC_SIZE(real_cmd);\n\tint err = 0;\n\n\tif (!(_IOC_DIR(cmd) & _IOC_WRITE)) {\n\t\t \n\t\tmemset(parg, 0, n);\n\t\treturn 0;\n\t}\n\n\t \n\tif (v4l2_is_known_ioctl(real_cmd)) {\n\t\tu32 flags = v4l2_ioctls[_IOC_NR(real_cmd)].flags;\n\n\t\tif (flags & INFO_FL_CLEAR_MASK)\n\t\t\tn = (flags & INFO_FL_CLEAR_MASK) >> 16;\n\t\t*always_copy = flags & INFO_FL_ALWAYS_COPY;\n\t}\n\n\tif (cmd == real_cmd) {\n\t\tif (copy_from_user(parg, (void __user *)arg, n))\n\t\t\terr = -EFAULT;\n\t} else if (in_compat_syscall()) {\n\t\tmemset(parg, 0, n);\n\t\terr = v4l2_compat_get_user(arg, parg, cmd);\n\t} else {\n\t\tmemset(parg, 0, n);\n#if !defined(CONFIG_64BIT) && defined(CONFIG_COMPAT_32BIT_TIME)\n\t\tswitch (cmd) {\n\t\tcase VIDIOC_QUERYBUF_TIME32:\n\t\tcase VIDIOC_QBUF_TIME32:\n\t\tcase VIDIOC_DQBUF_TIME32:\n\t\tcase VIDIOC_PREPARE_BUF_TIME32: {\n\t\t\tstruct v4l2_buffer_time32 vb32;\n\t\t\tstruct v4l2_buffer *vb = parg;\n\n\t\t\tif (copy_from_user(&vb32, arg, sizeof(vb32)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\t*vb = (struct v4l2_buffer) {\n\t\t\t\t.index\t\t= vb32.index,\n\t\t\t\t.type\t\t= vb32.type,\n\t\t\t\t.bytesused\t= vb32.bytesused,\n\t\t\t\t.flags\t\t= vb32.flags,\n\t\t\t\t.field\t\t= vb32.field,\n\t\t\t\t.timestamp.tv_sec\t= vb32.timestamp.tv_sec,\n\t\t\t\t.timestamp.tv_usec\t= vb32.timestamp.tv_usec,\n\t\t\t\t.timecode\t= vb32.timecode,\n\t\t\t\t.sequence\t= vb32.sequence,\n\t\t\t\t.memory\t\t= vb32.memory,\n\t\t\t\t.m.userptr\t= vb32.m.userptr,\n\t\t\t\t.length\t\t= vb32.length,\n\t\t\t\t.request_fd\t= vb32.request_fd,\n\t\t\t};\n\t\t\tbreak;\n\t\t}\n\t\t}\n#endif\n\t}\n\n\t \n\tif (!err && n < _IOC_SIZE(real_cmd))\n\t\tmemset((u8 *)parg + n, 0, _IOC_SIZE(real_cmd) - n);\n\treturn err;\n}\n\nstatic int video_put_user(void __user *arg, void *parg,\n\t\t\t  unsigned int real_cmd, unsigned int cmd)\n{\n\tif (!(_IOC_DIR(cmd) & _IOC_READ))\n\t\treturn 0;\n\n\tif (cmd == real_cmd) {\n\t\t \n\t\tif (copy_to_user(arg, parg, _IOC_SIZE(cmd)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tif (in_compat_syscall())\n\t\treturn v4l2_compat_put_user(arg, parg, cmd);\n\n#if !defined(CONFIG_64BIT) && defined(CONFIG_COMPAT_32BIT_TIME)\n\tswitch (cmd) {\n\tcase VIDIOC_DQEVENT_TIME32: {\n\t\tstruct v4l2_event *ev = parg;\n\t\tstruct v4l2_event_time32 ev32;\n\n\t\tmemset(&ev32, 0, sizeof(ev32));\n\n\t\tev32.type\t= ev->type;\n\t\tev32.pending\t= ev->pending;\n\t\tev32.sequence\t= ev->sequence;\n\t\tev32.timestamp.tv_sec\t= ev->timestamp.tv_sec;\n\t\tev32.timestamp.tv_nsec\t= ev->timestamp.tv_nsec;\n\t\tev32.id\t\t= ev->id;\n\n\t\tmemcpy(&ev32.u, &ev->u, sizeof(ev->u));\n\t\tmemcpy(&ev32.reserved, &ev->reserved, sizeof(ev->reserved));\n\n\t\tif (copy_to_user(arg, &ev32, sizeof(ev32)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase VIDIOC_QUERYBUF_TIME32:\n\tcase VIDIOC_QBUF_TIME32:\n\tcase VIDIOC_DQBUF_TIME32:\n\tcase VIDIOC_PREPARE_BUF_TIME32: {\n\t\tstruct v4l2_buffer *vb = parg;\n\t\tstruct v4l2_buffer_time32 vb32;\n\n\t\tmemset(&vb32, 0, sizeof(vb32));\n\n\t\tvb32.index\t= vb->index;\n\t\tvb32.type\t= vb->type;\n\t\tvb32.bytesused\t= vb->bytesused;\n\t\tvb32.flags\t= vb->flags;\n\t\tvb32.field\t= vb->field;\n\t\tvb32.timestamp.tv_sec\t= vb->timestamp.tv_sec;\n\t\tvb32.timestamp.tv_usec\t= vb->timestamp.tv_usec;\n\t\tvb32.timecode\t= vb->timecode;\n\t\tvb32.sequence\t= vb->sequence;\n\t\tvb32.memory\t= vb->memory;\n\t\tvb32.m.userptr\t= vb->m.userptr;\n\t\tvb32.length\t= vb->length;\n\t\tvb32.request_fd\t= vb->request_fd;\n\n\t\tif (copy_to_user(arg, &vb32, sizeof(vb32)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\t}\n#endif\n\n\treturn 0;\n}\n\nlong\nvideo_usercopy(struct file *file, unsigned int orig_cmd, unsigned long arg,\n\t       v4l2_kioctl func)\n{\n\tchar\tsbuf[128];\n\tvoid    *mbuf = NULL, *array_buf = NULL;\n\tvoid\t*parg = (void *)arg;\n\tlong\terr  = -EINVAL;\n\tbool\thas_array_args;\n\tbool\talways_copy = false;\n\tsize_t  array_size = 0;\n\tvoid __user *user_ptr = NULL;\n\tvoid\t**kernel_ptr = NULL;\n\tunsigned int cmd = video_translate_cmd(orig_cmd);\n\tconst size_t ioc_size = _IOC_SIZE(cmd);\n\n\t \n\tif (_IOC_DIR(cmd) != _IOC_NONE) {\n\t\tif (ioc_size <= sizeof(sbuf)) {\n\t\t\tparg = sbuf;\n\t\t} else {\n\t\t\t \n\t\t\tmbuf = kmalloc(ioc_size, GFP_KERNEL);\n\t\t\tif (NULL == mbuf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tparg = mbuf;\n\t\t}\n\n\t\terr = video_get_user((void __user *)arg, parg, cmd,\n\t\t\t\t     orig_cmd, &always_copy);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr);\n\tif (err < 0)\n\t\tgoto out;\n\thas_array_args = err;\n\n\tif (has_array_args) {\n\t\tarray_buf = kvmalloc(array_size, GFP_KERNEL);\n\t\terr = -ENOMEM;\n\t\tif (array_buf == NULL)\n\t\t\tgoto out;\n\t\tif (in_compat_syscall())\n\t\t\terr = v4l2_compat_get_array_args(file, array_buf,\n\t\t\t\t\t\t\t user_ptr, array_size,\n\t\t\t\t\t\t\t orig_cmd, parg);\n\t\telse\n\t\t\terr = copy_from_user(array_buf, user_ptr, array_size) ?\n\t\t\t\t\t\t\t\t-EFAULT : 0;\n\t\tif (err)\n\t\t\tgoto out;\n\t\t*kernel_ptr = array_buf;\n\t}\n\n\t \n\terr = func(file, cmd, parg);\n\tif (err == -ENOTTY || err == -ENOIOCTLCMD) {\n\t\terr = -ENOTTY;\n\t\tgoto out;\n\t}\n\n\tif (err == 0) {\n\t\tif (cmd == VIDIOC_DQBUF)\n\t\t\ttrace_v4l2_dqbuf(video_devdata(file)->minor, parg);\n\t\telse if (cmd == VIDIOC_QBUF)\n\t\t\ttrace_v4l2_qbuf(video_devdata(file)->minor, parg);\n\t}\n\n\t \n\tif (err < 0 && !always_copy && cmd != VIDIOC_SUBDEV_G_ROUTING)\n\t\tgoto out;\n\n\tif (has_array_args) {\n\t\t*kernel_ptr = (void __force *)user_ptr;\n\t\tif (in_compat_syscall()) {\n\t\t\tint put_err;\n\n\t\t\tput_err = v4l2_compat_put_array_args(file, user_ptr,\n\t\t\t\t\t\t\t     array_buf,\n\t\t\t\t\t\t\t     array_size,\n\t\t\t\t\t\t\t     orig_cmd, parg);\n\t\t\tif (put_err)\n\t\t\t\terr = put_err;\n\t\t} else if (copy_to_user(user_ptr, array_buf, array_size)) {\n\t\t\terr = -EFAULT;\n\t\t}\n\t}\n\n\tif (video_put_user((void __user *)arg, parg, cmd, orig_cmd))\n\t\terr = -EFAULT;\nout:\n\tkvfree(array_buf);\n\tkfree(mbuf);\n\treturn err;\n}\n\nlong video_ioctl2(struct file *file,\n\t       unsigned int cmd, unsigned long arg)\n{\n\treturn video_usercopy(file, cmd, arg, __video_do_ioctl);\n}\nEXPORT_SYMBOL(video_ioctl2);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}