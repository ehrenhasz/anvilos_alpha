{
  "module_name": "mt2060.c",
  "hash_id": "47ba8f350633ec5a7fb1ad558e54083104b0ee4461b5eef3f7d9934436de9153",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/mt2060.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/dvb/frontend.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n\n#include \"mt2060.h\"\n#include \"mt2060_priv.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off debugging (default:off).\");\n\n#define dprintk(args...) do { if (debug) {printk(KERN_DEBUG \"MT2060: \" args); printk(\"\\n\"); }} while (0)\n\n\nstatic int mt2060_readreg(struct mt2060_priv *priv, u8 reg, u8 *val)\n{\n\tstruct i2c_msg msg[2] = {\n\t\t{ .addr = priv->cfg->i2c_address, .flags = 0, .len = 1 },\n\t\t{ .addr = priv->cfg->i2c_address, .flags = I2C_M_RD, .len = 1 },\n\t};\n\tint rc = 0;\n\tu8 *b;\n\n\tb = kmalloc(2, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\n\tb[0] = reg;\n\tb[1] = 0;\n\n\tmsg[0].buf = b;\n\tmsg[1].buf = b + 1;\n\n\tif (i2c_transfer(priv->i2c, msg, 2) != 2) {\n\t\tprintk(KERN_WARNING \"mt2060 I2C read failed\\n\");\n\t\trc = -EREMOTEIO;\n\t}\n\t*val = b[1];\n\tkfree(b);\n\n\treturn rc;\n}\n\n\nstatic int mt2060_writereg(struct mt2060_priv *priv, u8 reg, u8 val)\n{\n\tstruct i2c_msg msg = {\n\t\t.addr = priv->cfg->i2c_address, .flags = 0, .len = 2\n\t};\n\tu8 *buf;\n\tint rc = 0;\n\n\tbuf = kmalloc(2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = reg;\n\tbuf[1] = val;\n\n\tmsg.buf = buf;\n\n\tif (i2c_transfer(priv->i2c, &msg, 1) != 1) {\n\t\tprintk(KERN_WARNING \"mt2060 I2C write failed\\n\");\n\t\trc = -EREMOTEIO;\n\t}\n\tkfree(buf);\n\treturn rc;\n}\n\n\nstatic int mt2060_writeregs(struct mt2060_priv *priv,u8 *buf, u8 len)\n{\n\tint rem, val_len;\n\tu8 *xfer_buf;\n\tint rc = 0;\n\tstruct i2c_msg msg = {\n\t\t.addr = priv->cfg->i2c_address, .flags = 0\n\t};\n\n\txfer_buf = kmalloc(16, GFP_KERNEL);\n\tif (!xfer_buf)\n\t\treturn -ENOMEM;\n\n\tmsg.buf = xfer_buf;\n\n\tfor (rem = len - 1; rem > 0; rem -= priv->i2c_max_regs) {\n\t\tval_len = min_t(int, rem, priv->i2c_max_regs);\n\t\tmsg.len = 1 + val_len;\n\t\txfer_buf[0] = buf[0] + len - 1 - rem;\n\t\tmemcpy(&xfer_buf[1], &buf[1 + len - 1 - rem], val_len);\n\n\t\tif (i2c_transfer(priv->i2c, &msg, 1) != 1) {\n\t\t\tprintk(KERN_WARNING \"mt2060 I2C write failed (len=%i)\\n\", val_len);\n\t\t\trc = -EREMOTEIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(xfer_buf);\n\treturn rc;\n}\n\n\n\nstatic u8 mt2060_config1[] = {\n\tREG_LO1C1,\n\t0x3F,\t0x74,\t0x00,\t0x08,\t0x93\n};\n\n\nstatic u8 mt2060_config2[] = {\n\tREG_MISC_CTRL,\n\t0x20,\t0x1E,\t0x30,\t0xff,\t0x80,\t0xff,\t0x00,\t0x2c,\t0x42\n};\n\n\n\n#ifdef  MT2060_SPURCHECK\n \nstatic int mt2060_spurcalc(u32 lo1,u32 lo2,u32 if2)\n{\n\tint I,J;\n\tint dia,diamin,diff;\n\tdiamin=1000000;\n\tfor (I = 1; I < 10; I++) {\n\t\tJ = ((2*I*lo1)/lo2+1)/2;\n\t\tdiff = I*(int)lo1-J*(int)lo2;\n\t\tif (diff < 0) diff=-diff;\n\t\tdia = (diff-(int)if2);\n\t\tif (dia < 0) dia=-dia;\n\t\tif (diamin > dia) diamin=dia;\n\t}\n\treturn diamin;\n}\n\n#define BANDWIDTH 4000 \n\n \nstatic int mt2060_spurcheck(u32 lo1,u32 lo2,u32 if2)\n{\n\tu32 Spur,Sp1,Sp2;\n\tint I,J;\n\tI=0;\n\tJ=1000;\n\n\tSpur=mt2060_spurcalc(lo1,lo2,if2);\n\tif (Spur < BANDWIDTH) {\n\t\t \n\t\tdprintk(\"Spurs before : f_lo1: %d  f_lo2: %d  (kHz)\",\n\t\t\t(int)lo1,(int)lo2);\n\t\tI=1000;\n\t\tSp1 = mt2060_spurcalc(lo1+I,lo2+I,if2);\n\t\tSp2 = mt2060_spurcalc(lo1-I,lo2-I,if2);\n\n\t\tif (Sp1 < Sp2) {\n\t\t\tJ=-J; I=-I; Spur=Sp2;\n\t\t} else\n\t\t\tSpur=Sp1;\n\n\t\twhile (Spur < BANDWIDTH) {\n\t\t\tI += J;\n\t\t\tSpur = mt2060_spurcalc(lo1+I,lo2+I,if2);\n\t\t}\n\t\tdprintk(\"Spurs after  : f_lo1: %d  f_lo2: %d  (kHz)\",\n\t\t\t(int)(lo1+I),(int)(lo2+I));\n\t}\n\treturn I;\n}\n#endif\n\n#define IF2  36150       \n#define FREF 16000       \n\nstatic int mt2060_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct mt2060_priv *priv;\n\tint i=0;\n\tu32 freq;\n\tu8  lnaband;\n\tu32 f_lo1,f_lo2;\n\tu32 div1,num1,div2,num2;\n\tu8  b[8];\n\tu32 if1;\n\n\tpriv = fe->tuner_priv;\n\n\tif1 = priv->if1_freq;\n\tb[0] = REG_LO1B1;\n\tb[1] = 0xFF;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\tmt2060_writeregs(priv,b,2);\n\n\tfreq = c->frequency / 1000;  \n\n\tf_lo1 = freq + if1 * 1000;\n\tf_lo1 = (f_lo1 / 250) * 250;\n\tf_lo2 = f_lo1 - freq - IF2;\n\t\n\tf_lo2 = ((f_lo2 + 25) / 50) * 50;\n\tpriv->frequency =  (f_lo1 - f_lo2 - IF2) * 1000;\n\n#ifdef MT2060_SPURCHECK\n\t\n\tnum1   = mt2060_spurcheck(f_lo1,f_lo2,IF2);\n\tf_lo1 += num1;\n\tf_lo2 += num1;\n#endif\n\t\n\tnum1 = f_lo1 / (FREF / 64);\n\tdiv1 = num1 / 64;\n\tnum1 &= 0x3f;\n\n\t\n\tnum2 = f_lo2 * 64 / (FREF / 128);\n\tdiv2 = num2 / 8192;\n\tnum2 &= 0x1fff;\n\n\tif (freq <=  95000) lnaband = 0xB0; else\n\tif (freq <= 180000) lnaband = 0xA0; else\n\tif (freq <= 260000) lnaband = 0x90; else\n\tif (freq <= 335000) lnaband = 0x80; else\n\tif (freq <= 425000) lnaband = 0x70; else\n\tif (freq <= 480000) lnaband = 0x60; else\n\tif (freq <= 570000) lnaband = 0x50; else\n\tif (freq <= 645000) lnaband = 0x40; else\n\tif (freq <= 730000) lnaband = 0x30; else\n\tif (freq <= 810000) lnaband = 0x20; else lnaband = 0x10;\n\n\tb[0] = REG_LO1C1;\n\tb[1] = lnaband | ((num1 >>2) & 0x0F);\n\tb[2] = div1;\n\tb[3] = (num2 & 0x0F)  | ((num1 & 3) << 4);\n\tb[4] = num2 >> 4;\n\tb[5] = ((num2 >>12) & 1) | (div2 << 1);\n\n\tdprintk(\"IF1: %dMHz\",(int)if1);\n\tdprintk(\"PLL freq=%dkHz  f_lo1=%dkHz  f_lo2=%dkHz\",(int)freq,(int)f_lo1,(int)f_lo2);\n\tdprintk(\"PLL div1=%d  num1=%d  div2=%d  num2=%d\",(int)div1,(int)num1,(int)div2,(int)num2);\n\tdprintk(\"PLL [1..5]: %2x %2x %2x %2x %2x\",(int)b[1],(int)b[2],(int)b[3],(int)b[4],(int)b[5]);\n\n\tmt2060_writeregs(priv,b,6);\n\n\t\n\ti = 0;\n\tdo {\n\t\tmt2060_readreg(priv,REG_LO_STATUS,b);\n\t\tif ((b[0] & 0x88)==0x88)\n\t\t\tbreak;\n\t\tmsleep(4);\n\t\ti++;\n\t} while (i<10);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\treturn 0;\n}\n\nstatic void mt2060_calibrate(struct mt2060_priv *priv)\n{\n\tu8 b = 0;\n\tint i = 0;\n\n\tif (mt2060_writeregs(priv,mt2060_config1,sizeof(mt2060_config1)))\n\t\treturn;\n\tif (mt2060_writeregs(priv,mt2060_config2,sizeof(mt2060_config2)))\n\t\treturn;\n\n\t \n\tmt2060_writereg(priv, REG_VGAG, (priv->cfg->clock_out << 6) | 0x30);\n\n\tdo {\n\t\tb |= (1 << 6); \n\t\tmt2060_writereg(priv, REG_LO2C1,b);\n\t\tmsleep(20);\n\n\t\tif (i == 0) {\n\t\t\tb |= (1 << 7); \n\t\t\tmt2060_writereg(priv, REG_LO2C1,b);\n\t\t\tb &= ~(1 << 7); \n\t\t\tmsleep(20);\n\t\t}\n\n\t\tb &= ~(1 << 6); \n\t\tmt2060_writereg(priv, REG_LO2C1,b);\n\n\t\tmsleep(20);\n\t\ti++;\n\t} while (i < 9);\n\n\ti = 0;\n\twhile (i++ < 10 && mt2060_readreg(priv, REG_MISC_STAT, &b) == 0 && (b & (1 << 6)) == 0)\n\t\tmsleep(20);\n\n\tif (i <= 10) {\n\t\tmt2060_readreg(priv, REG_FM_FREQ, &priv->fmfreq); \n\t\tdprintk(\"calibration was successful: %d\", (int)priv->fmfreq);\n\t} else\n\t\tdprintk(\"FMCAL timed out\");\n}\n\nstatic int mt2060_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct mt2060_priv *priv = fe->tuner_priv;\n\t*frequency = priv->frequency;\n\treturn 0;\n}\n\nstatic int mt2060_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\t*frequency = IF2 * 1000;\n\treturn 0;\n}\n\nstatic int mt2060_init(struct dvb_frontend *fe)\n{\n\tstruct mt2060_priv *priv = fe->tuner_priv;\n\tint ret;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\tif (priv->sleep) {\n\t\tret = mt2060_writereg(priv, REG_MISC_CTRL, 0x20);\n\t\tif (ret)\n\t\t\tgoto err_i2c_gate_ctrl;\n\t}\n\n\tret = mt2060_writereg(priv, REG_VGAG,\n\t\t\t      (priv->cfg->clock_out << 6) | 0x33);\n\nerr_i2c_gate_ctrl:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\treturn ret;\n}\n\nstatic int mt2060_sleep(struct dvb_frontend *fe)\n{\n\tstruct mt2060_priv *priv = fe->tuner_priv;\n\tint ret;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\tret = mt2060_writereg(priv, REG_VGAG,\n\t\t\t      (priv->cfg->clock_out << 6) | 0x30);\n\tif (ret)\n\t\tgoto err_i2c_gate_ctrl;\n\n\tif (priv->sleep)\n\t\tret = mt2060_writereg(priv, REG_MISC_CTRL, 0xe8);\n\nerr_i2c_gate_ctrl:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\treturn ret;\n}\n\nstatic void mt2060_release(struct dvb_frontend *fe)\n{\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic const struct dvb_tuner_ops mt2060_tuner_ops = {\n\t.info = {\n\t\t.name              = \"Microtune MT2060\",\n\t\t.frequency_min_hz  =  48 * MHz,\n\t\t.frequency_max_hz  = 860 * MHz,\n\t\t.frequency_step_hz =  50 * kHz,\n\t},\n\n\t.release       = mt2060_release,\n\n\t.init          = mt2060_init,\n\t.sleep         = mt2060_sleep,\n\n\t.set_params    = mt2060_set_params,\n\t.get_frequency = mt2060_get_frequency,\n\t.get_if_frequency = mt2060_get_if_frequency,\n};\n\n \nstruct dvb_frontend * mt2060_attach(struct dvb_frontend *fe, struct i2c_adapter *i2c, struct mt2060_config *cfg, u16 if1)\n{\n\tstruct mt2060_priv *priv = NULL;\n\tu8 id = 0;\n\n\tpriv = kzalloc(sizeof(struct mt2060_priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn NULL;\n\n\tpriv->cfg      = cfg;\n\tpriv->i2c      = i2c;\n\tpriv->if1_freq = if1;\n\tpriv->i2c_max_regs = ~0;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\tif (mt2060_readreg(priv,REG_PART_REV,&id) != 0) {\n\t\tkfree(priv);\n\t\treturn NULL;\n\t}\n\n\tif (id != PART_REV) {\n\t\tkfree(priv);\n\t\treturn NULL;\n\t}\n\tprintk(KERN_INFO \"MT2060: successfully identified (IF1 = %d)\\n\", if1);\n\tmemcpy(&fe->ops.tuner_ops, &mt2060_tuner_ops, sizeof(struct dvb_tuner_ops));\n\n\tfe->tuner_priv = priv;\n\n\tmt2060_calibrate(priv);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(mt2060_attach);\n\nstatic int mt2060_probe(struct i2c_client *client)\n{\n\tstruct mt2060_platform_data *pdata = client->dev.platform_data;\n\tstruct dvb_frontend *fe;\n\tstruct mt2060_priv *dev;\n\tint ret;\n\tu8 chip_id;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tif (!pdata) {\n\t\tdev_err(&client->dev, \"Cannot proceed without platform data\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdev = devm_kzalloc(&client->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tfe = pdata->dvb_frontend;\n\tdev->config.i2c_address = client->addr;\n\tdev->config.clock_out = pdata->clock_out;\n\tdev->cfg = &dev->config;\n\tdev->i2c = client->adapter;\n\tdev->if1_freq = pdata->if1 ? pdata->if1 : 1220;\n\tdev->client = client;\n\tdev->i2c_max_regs = pdata->i2c_write_max ? pdata->i2c_write_max - 1 : ~0;\n\tdev->sleep = true;\n\n\tret = mt2060_readreg(dev, REG_PART_REV, &chip_id);\n\tif (ret) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tdev_dbg(&client->dev, \"chip id=%02x\\n\", chip_id);\n\n\tif (chip_id != PART_REV) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t \n\tret = mt2060_writereg(dev, REG_MISC_CTRL, 0x20);\n\tif (ret)\n\t\tgoto err;\n\tmt2060_calibrate(dev);\n\tret = mt2060_writereg(dev, REG_MISC_CTRL, 0xe8);\n\tif (ret)\n\t\tgoto err;\n\n\tdev_info(&client->dev, \"Microtune MT2060 successfully identified\\n\");\n\tmemcpy(&fe->ops.tuner_ops, &mt2060_tuner_ops, sizeof(fe->ops.tuner_ops));\n\tfe->ops.tuner_ops.release = NULL;\n\tfe->tuner_priv = dev;\n\ti2c_set_clientdata(client, dev);\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void mt2060_remove(struct i2c_client *client)\n{\n\tdev_dbg(&client->dev, \"\\n\");\n}\n\nstatic const struct i2c_device_id mt2060_id_table[] = {\n\t{\"mt2060\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, mt2060_id_table);\n\nstatic struct i2c_driver mt2060_driver = {\n\t.driver = {\n\t\t.name = \"mt2060\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= mt2060_probe,\n\t.remove\t\t= mt2060_remove,\n\t.id_table\t= mt2060_id_table,\n};\n\nmodule_i2c_driver(mt2060_driver);\n\nMODULE_AUTHOR(\"Olivier DANET\");\nMODULE_DESCRIPTION(\"Microtune MT2060 silicon tuner driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}