{
  "module_name": "qt1010.c",
  "hash_id": "f0780851c005ddf745b1481eb494096eeee4964f330986f3d0235ec8c928f540",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/qt1010.c",
  "human_readable_source": "\n \n#include \"qt1010.h\"\n#include \"qt1010_priv.h\"\n\n \nstatic int qt1010_readreg(struct qt1010_priv *priv, u8 reg, u8 *val)\n{\n\tstruct i2c_msg msg[2] = {\n\t\t{ .addr = priv->cfg->i2c_address,\n\t\t  .flags = 0, .buf = &reg, .len = 1 },\n\t\t{ .addr = priv->cfg->i2c_address,\n\t\t  .flags = I2C_M_RD, .buf = val, .len = 1 },\n\t};\n\n\tif (i2c_transfer(priv->i2c, msg, 2) != 2) {\n\t\tdev_warn(&priv->i2c->dev, \"%s: i2c rd failed reg=%02x\\n\",\n\t\t\t\tKBUILD_MODNAME, reg);\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\n \nstatic int qt1010_writereg(struct qt1010_priv *priv, u8 reg, u8 val)\n{\n\tu8 buf[2] = { reg, val };\n\tstruct i2c_msg msg = { .addr = priv->cfg->i2c_address,\n\t\t\t       .flags = 0, .buf = buf, .len = 2 };\n\n\tif (i2c_transfer(priv->i2c, &msg, 1) != 1) {\n\t\tdev_warn(&priv->i2c->dev, \"%s: i2c wr failed reg=%02x\\n\",\n\t\t\t\tKBUILD_MODNAME, reg);\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic int qt1010_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct qt1010_priv *priv;\n\tint err;\n\tu32 freq, div, mod1, mod2;\n\tu8 i, tmpval, reg05;\n\tqt1010_i2c_oper_t rd[48] = {\n\t\t{ QT1010_WR, 0x01, 0x80 },\n\t\t{ QT1010_WR, 0x02, 0x3f },\n\t\t{ QT1010_WR, 0x05, 0xff },  \n\t\t{ QT1010_WR, 0x06, 0x44 },\n\t\t{ QT1010_WR, 0x07, 0xff },  \n\t\t{ QT1010_WR, 0x08, 0x08 },\n\t\t{ QT1010_WR, 0x09, 0xff },  \n\t\t{ QT1010_WR, 0x0a, 0xff },  \n\t\t{ QT1010_WR, 0x0b, 0xff },  \n\t\t{ QT1010_WR, 0x0c, 0xe1 },\n\t\t{ QT1010_WR, 0x1a, 0xff },  \n\t\t{ QT1010_WR, 0x1b, 0x00 },\n\t\t{ QT1010_WR, 0x1c, 0x89 },\n\t\t{ QT1010_WR, 0x11, 0xff },  \n\t\t{ QT1010_WR, 0x12, 0xff },  \n\t\t{ QT1010_WR, 0x22, 0xff },  \n\t\t{ QT1010_WR, 0x1e, 0x00 },\n\t\t{ QT1010_WR, 0x1e, 0xd0 },\n\t\t{ QT1010_RD, 0x22, 0xff },  \n\t\t{ QT1010_WR, 0x1e, 0x00 },\n\t\t{ QT1010_RD, 0x05, 0xff },  \n\t\t{ QT1010_RD, 0x22, 0xff },  \n\t\t{ QT1010_WR, 0x23, 0xd0 },\n\t\t{ QT1010_WR, 0x1e, 0x00 },\n\t\t{ QT1010_WR, 0x1e, 0xe0 },\n\t\t{ QT1010_RD, 0x23, 0xff },  \n\t\t{ QT1010_RD, 0x23, 0xff },  \n\t\t{ QT1010_WR, 0x1e, 0x00 },\n\t\t{ QT1010_WR, 0x24, 0xd0 },\n\t\t{ QT1010_WR, 0x1e, 0x00 },\n\t\t{ QT1010_WR, 0x1e, 0xf0 },\n\t\t{ QT1010_RD, 0x24, 0xff },  \n\t\t{ QT1010_WR, 0x1e, 0x00 },\n\t\t{ QT1010_WR, 0x14, 0x7f },\n\t\t{ QT1010_WR, 0x15, 0x7f },\n\t\t{ QT1010_WR, 0x05, 0xff },  \n\t\t{ QT1010_WR, 0x06, 0x00 },\n\t\t{ QT1010_WR, 0x15, 0x1f },\n\t\t{ QT1010_WR, 0x16, 0xff },\n\t\t{ QT1010_WR, 0x18, 0xff },\n\t\t{ QT1010_WR, 0x1f, 0xff },  \n\t\t{ QT1010_WR, 0x20, 0xff },  \n\t\t{ QT1010_WR, 0x21, 0x53 },\n\t\t{ QT1010_WR, 0x25, 0xff },  \n\t\t{ QT1010_WR, 0x26, 0x15 },\n\t\t{ QT1010_WR, 0x00, 0xff },  \n\t\t{ QT1010_WR, 0x02, 0x00 },\n\t\t{ QT1010_WR, 0x01, 0x00 }\n\t};\n\n#define FREQ1 32000000  \n#define FREQ2  4000000  \n\n\tpriv = fe->tuner_priv;\n\tfreq = c->frequency;\n\tdiv = (freq + QT1010_OFFSET) / QT1010_STEP;\n\tfreq = (div * QT1010_STEP) - QT1010_OFFSET;\n\tmod1 = (freq + QT1010_OFFSET) % FREQ1;\n\tmod2 = (freq + QT1010_OFFSET) % FREQ2;\n\tpriv->frequency = freq;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\t \n\tif      (freq < 290000000) reg05 = 0x14;  \n\telse if (freq < 610000000) reg05 = 0x34;  \n\telse if (freq < 802000000) reg05 = 0x54;  \n\telse                       reg05 = 0x74;\n\n\t \n\trd[2].val = reg05;\n\n\t \n\trd[4].val = (freq + QT1010_OFFSET) / FREQ1;\n\n\t \n\tif (mod1 < 8000000) rd[6].val = 0x1d;\n\telse                rd[6].val = 0x1c;\n\n\t \n\tif      (mod1 < 1*FREQ2) rd[7].val = 0x09;  \n\telse if (mod1 < 2*FREQ2) rd[7].val = 0x08;  \n\telse if (mod1 < 3*FREQ2) rd[7].val = 0x0f;  \n\telse if (mod1 < 4*FREQ2) rd[7].val = 0x0e;  \n\telse if (mod1 < 5*FREQ2) rd[7].val = 0x0d;  \n\telse if (mod1 < 6*FREQ2) rd[7].val = 0x0c;  \n\telse if (mod1 < 7*FREQ2) rd[7].val = 0x0b;  \n\telse                     rd[7].val = 0x0a;  \n\n\t \n\tif (mod2 < 2000000) rd[8].val = 0x45;\n\telse                rd[8].val = 0x44;\n\n\t \n\ttmpval = 0x78;  \n\trd[10].val = tmpval-((mod2/QT1010_STEP)*0x08);\n\n\t \n\trd[13].val = 0xfd;  \n\n\t \n\trd[14].val = 0x91;  \n\n\t \n\tif      (freq < 450000000) rd[15].val = 0xd0;  \n\telse if (freq < 482000000) rd[15].val = 0xd1;  \n\telse if (freq < 514000000) rd[15].val = 0xd4;  \n\telse if (freq < 546000000) rd[15].val = 0xd7;  \n\telse if (freq < 610000000) rd[15].val = 0xda;  \n\telse                       rd[15].val = 0xd0;\n\n\t \n\trd[35].val = (reg05 & 0xf0);\n\n\t \n\tif      (mod1 <  8000000) tmpval = 0x00;\n\telse if (mod1 < 12000000) tmpval = 0x01;\n\telse if (mod1 < 16000000) tmpval = 0x02;\n\telse if (mod1 < 24000000) tmpval = 0x03;\n\telse if (mod1 < 28000000) tmpval = 0x04;\n\telse                      tmpval = 0x05;\n\trd[40].val = (priv->reg1f_init_val + 0x0e + tmpval);\n\n\t \n\tif      (mod1 <  8000000) tmpval = 0x00;\n\telse if (mod1 < 12000000) tmpval = 0x01;\n\telse if (mod1 < 20000000) tmpval = 0x02;\n\telse if (mod1 < 24000000) tmpval = 0x03;\n\telse if (mod1 < 28000000) tmpval = 0x04;\n\telse                      tmpval = 0x05;\n\trd[41].val = (priv->reg20_init_val + 0x0d + tmpval);\n\n\t \n\trd[43].val = priv->reg25_init_val;\n\n\t \n\trd[45].val = 0x92;  \n\n\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s: freq:%u 05:%02x 07:%02x 09:%02x 0a:%02x 0b:%02x \" \\\n\t\t\t\"1a:%02x 11:%02x 12:%02x 22:%02x 05:%02x 1f:%02x \" \\\n\t\t\t\"20:%02x 25:%02x 00:%02x\\n\", __func__, \\\n\t\t\tfreq, rd[2].val, rd[4].val, rd[6].val, rd[7].val, \\\n\t\t\trd[8].val, rd[10].val, rd[13].val, rd[14].val, \\\n\t\t\trd[15].val, rd[35].val, rd[40].val, rd[41].val, \\\n\t\t\trd[43].val, rd[45].val);\n\n\tfor (i = 0; i < ARRAY_SIZE(rd); i++) {\n\t\tif (rd[i].oper == QT1010_WR) {\n\t\t\terr = qt1010_writereg(priv, rd[i].reg, rd[i].val);\n\t\t} else {  \n\t\t\terr = qt1010_readreg(priv, rd[i].reg, &tmpval);\n\t\t}\n\t\tif (err) return err;\n\t}\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\treturn 0;\n}\n\nstatic int qt1010_init_meas1(struct qt1010_priv *priv,\n\t\t\t     u8 oper, u8 reg, u8 reg_init_val, u8 *retval)\n{\n\tu8 i, val1, val2;\n\tint err;\n\n\tqt1010_i2c_oper_t i2c_data[] = {\n\t\t{ QT1010_WR, reg, reg_init_val },\n\t\t{ QT1010_WR, 0x1e, 0x00 },\n\t\t{ QT1010_WR, 0x1e, oper },\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(i2c_data); i++) {\n\t\terr = qt1010_writereg(priv, i2c_data[i].reg,\n\t\t\t\t      i2c_data[i].val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = qt1010_readreg(priv, reg, &val2);\n\tif (err)\n\t\treturn err;\n\tdo {\n\t\tval1 = val2;\n\t\terr = qt1010_readreg(priv, reg, &val2);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tdev_dbg(&priv->i2c->dev, \"%s: compare reg:%02x %02x %02x\\n\",\n\t\t\t\t__func__, reg, val1, val2);\n\t} while (val1 != val2);\n\t*retval = val1;\n\n\treturn qt1010_writereg(priv, 0x1e, 0x00);\n}\n\nstatic int qt1010_init_meas2(struct qt1010_priv *priv,\n\t\t\t    u8 reg_init_val, u8 *retval)\n{\n\tu8 i, val = 0xff;\n\tint err;\n\tqt1010_i2c_oper_t i2c_data[] = {\n\t\t{ QT1010_WR, 0x07, reg_init_val },\n\t\t{ QT1010_WR, 0x22, 0xd0 },\n\t\t{ QT1010_WR, 0x1e, 0x00 },\n\t\t{ QT1010_WR, 0x1e, 0xd0 },\n\t\t{ QT1010_RD, 0x22, 0xff },\n\t\t{ QT1010_WR, 0x1e, 0x00 },\n\t\t{ QT1010_WR, 0x22, 0xff }\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(i2c_data); i++) {\n\t\tif (i2c_data[i].oper == QT1010_WR) {\n\t\t\terr = qt1010_writereg(priv, i2c_data[i].reg,\n\t\t\t\t\t      i2c_data[i].val);\n\t\t} else {\n\t\t\terr = qt1010_readreg(priv, i2c_data[i].reg, &val);\n\t\t}\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t*retval = val;\n\treturn 0;\n}\n\nstatic int qt1010_init(struct dvb_frontend *fe)\n{\n\tstruct qt1010_priv *priv = fe->tuner_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint err = 0;\n\tu8 i, tmpval, *valptr = NULL;\n\n\tstatic const qt1010_i2c_oper_t i2c_data[] = {\n\t\t{ QT1010_WR, 0x01, 0x80 },\n\t\t{ QT1010_WR, 0x0d, 0x84 },\n\t\t{ QT1010_WR, 0x0e, 0xb7 },\n\t\t{ QT1010_WR, 0x2a, 0x23 },\n\t\t{ QT1010_WR, 0x2c, 0xdc },\n\t\t{ QT1010_M1, 0x25, 0x40 },  \n\t\t{ QT1010_M1, 0x81, 0xff },  \n\t\t{ QT1010_WR, 0x2b, 0x70 },\n\t\t{ QT1010_WR, 0x2a, 0x23 },\n\t\t{ QT1010_M1, 0x26, 0x08 },\n\t\t{ QT1010_M1, 0x82, 0xff },\n\t\t{ QT1010_WR, 0x05, 0x14 },\n\t\t{ QT1010_WR, 0x06, 0x44 },\n\t\t{ QT1010_WR, 0x07, 0x28 },\n\t\t{ QT1010_WR, 0x08, 0x0b },\n\t\t{ QT1010_WR, 0x11, 0xfd },\n\t\t{ QT1010_M1, 0x22, 0x0d },\n\t\t{ QT1010_M1, 0xd0, 0xff },\n\t\t{ QT1010_WR, 0x06, 0x40 },\n\t\t{ QT1010_WR, 0x16, 0xf0 },\n\t\t{ QT1010_WR, 0x02, 0x38 },\n\t\t{ QT1010_WR, 0x03, 0x18 },\n\t\t{ QT1010_WR, 0x20, 0xe0 },\n\t\t{ QT1010_M1, 0x1f, 0x20 },  \n\t\t{ QT1010_M1, 0x84, 0xff },  \n\t\t{ QT1010_RD, 0x20, 0x20 },  \n\t\t{ QT1010_WR, 0x03, 0x19 },\n\t\t{ QT1010_WR, 0x02, 0x3f },\n\t\t{ QT1010_WR, 0x21, 0x53 },\n\t\t{ QT1010_RD, 0x21, 0xff },\n\t\t{ QT1010_WR, 0x11, 0xfd },\n\t\t{ QT1010_WR, 0x05, 0x34 },\n\t\t{ QT1010_WR, 0x06, 0x44 },\n\t\t{ QT1010_WR, 0x08, 0x08 }\n\t};\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\tfor (i = 0; i < ARRAY_SIZE(i2c_data); i++) {\n\t\tswitch (i2c_data[i].oper) {\n\t\tcase QT1010_WR:\n\t\t\terr = qt1010_writereg(priv, i2c_data[i].reg,\n\t\t\t\t\t      i2c_data[i].val);\n\t\t\tbreak;\n\t\tcase QT1010_RD:\n\t\t\tif (i2c_data[i].val == 0x20)\n\t\t\t\tvalptr = &priv->reg20_init_val;\n\t\t\telse\n\t\t\t\tvalptr = &tmpval;\n\t\t\terr = qt1010_readreg(priv, i2c_data[i].reg, valptr);\n\t\t\tbreak;\n\t\tcase QT1010_M1:\n\t\t\tif (i2c_data[i].val == 0x25)\n\t\t\t\tvalptr = &priv->reg25_init_val;\n\t\t\telse if (i2c_data[i].val == 0x1f)\n\t\t\t\tvalptr = &priv->reg1f_init_val;\n\t\t\telse\n\t\t\t\tvalptr = &tmpval;\n\n\t\t\tif (i >= ARRAY_SIZE(i2c_data) - 1)\n\t\t\t\terr = -EIO;\n\t\t\telse\n\t\t\t\terr = qt1010_init_meas1(priv, i2c_data[i + 1].reg,\n\t\t\t\t\t\t\ti2c_data[i].reg,\n\t\t\t\t\t\t\ti2c_data[i].val, valptr);\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0x31; i < 0x3a; i++)  \n\t\tif ((err = qt1010_init_meas2(priv, i, &tmpval)))\n\t\t\treturn err;\n\n\tif (!c->frequency)\n\t\tc->frequency = 545000000;  \n\t\t\t\t       \n\treturn qt1010_set_params(fe);\n}\n\nstatic void qt1010_release(struct dvb_frontend *fe)\n{\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic int qt1010_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct qt1010_priv *priv = fe->tuner_priv;\n\t*frequency = priv->frequency;\n\treturn 0;\n}\n\nstatic int qt1010_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\t*frequency = 36125000;\n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops qt1010_tuner_ops = {\n\t.info = {\n\t\t.name              = \"Quantek QT1010\",\n\t\t.frequency_min_hz  = QT1010_MIN_FREQ,\n\t\t.frequency_max_hz  = QT1010_MAX_FREQ,\n\t\t.frequency_step_hz = QT1010_STEP,\n\t},\n\n\t.release       = qt1010_release,\n\t.init          = qt1010_init,\n\t \n\n\t.set_params    = qt1010_set_params,\n\t.get_frequency = qt1010_get_frequency,\n\t.get_if_frequency = qt1010_get_if_frequency,\n};\n\nstruct dvb_frontend * qt1010_attach(struct dvb_frontend *fe,\n\t\t\t\t    struct i2c_adapter *i2c,\n\t\t\t\t    struct qt1010_config *cfg)\n{\n\tstruct qt1010_priv *priv = NULL;\n\tu8 id;\n\n\tpriv = kzalloc(sizeof(struct qt1010_priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn NULL;\n\n\tpriv->cfg = cfg;\n\tpriv->i2c = i2c;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\n\t \n\tif (qt1010_readreg(priv, 0x29, &id) != 0 || (id != 0x39)) {\n\t\tkfree(priv);\n\t\treturn NULL;\n\t}\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\tdev_info(&priv->i2c->dev,\n\t\t\t\"%s: Quantek QT1010 successfully identified\\n\",\n\t\t\tKBUILD_MODNAME);\n\n\tmemcpy(&fe->ops.tuner_ops, &qt1010_tuner_ops,\n\t       sizeof(struct dvb_tuner_ops));\n\n\tfe->tuner_priv = priv;\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(qt1010_attach);\n\nMODULE_DESCRIPTION(\"Quantek QT1010 silicon tuner driver\");\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_AUTHOR(\"Aapo Tahkola <aet@rasterburn.org>\");\nMODULE_VERSION(\"0.1\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}