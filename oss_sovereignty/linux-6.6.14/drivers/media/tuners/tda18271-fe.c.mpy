{
  "module_name": "tda18271-fe.c",
  "hash_id": "f237319d47908f958e575c35186c07e9060968fbd9fd1a2aeb0596665e9a858c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/tda18271-fe.c",
  "human_readable_source": "\n \n\n#include \"tda18271-priv.h\"\n#include \"tda8290.h\"\n\n#include <linux/delay.h>\n#include <linux/videodev2.h>\n\nint tda18271_debug;\nmodule_param_named(debug, tda18271_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debug level (info=1, map=2, reg=4, adv=8, cal=16 (or-able))\");\n\nstatic int tda18271_cal_on_startup = -1;\nmodule_param_named(cal, tda18271_cal_on_startup, int, 0644);\nMODULE_PARM_DESC(cal, \"perform RF tracking filter calibration on startup\");\n\nstatic DEFINE_MUTEX(tda18271_list_mutex);\nstatic LIST_HEAD(hybrid_tuner_instance_list);\n\n \n\nstatic int tda18271_toggle_output(struct dvb_frontend *fe, int standby)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\n\tint ret = tda18271_set_standby_mode(fe, standby ? 1 : 0,\n\t\t\tpriv->output_opt & TDA18271_OUTPUT_LT_OFF ? 1 : 0,\n\t\t\tpriv->output_opt & TDA18271_OUTPUT_XT_OFF ? 1 : 0);\n\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\ttda_dbg(\"%s mode: xtal oscillator %s, slave tuner loop through %s\\n\",\n\t\tstandby ? \"standby\" : \"active\",\n\t\tpriv->output_opt & TDA18271_OUTPUT_XT_OFF ? \"off\" : \"on\",\n\t\tpriv->output_opt & TDA18271_OUTPUT_LT_OFF ? \"off\" : \"on\");\nfail:\n\treturn ret;\n}\n\n \n\nstatic inline int charge_pump_source(struct dvb_frontend *fe, int force)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\treturn tda18271_charge_pump_source(fe,\n\t\t\t\t\t   (priv->role == TDA18271_SLAVE) ?\n\t\t\t\t\t   TDA18271_CAL_PLL :\n\t\t\t\t\t   TDA18271_MAIN_PLL, force);\n}\n\nstatic inline void tda18271_set_if_notch(struct dvb_frontend *fe)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\n\tswitch (priv->mode) {\n\tcase TDA18271_ANALOG:\n\t\tregs[R_MPD]  &= ~0x80;  \n\t\tbreak;\n\tcase TDA18271_DIGITAL:\n\t\tregs[R_MPD]  |= 0x80;  \n\t\tbreak;\n\t}\n}\n\nstatic int tda18271_channel_configuration(struct dvb_frontend *fe,\n\t\t\t\t\t  struct tda18271_std_map_item *map,\n\t\t\t\t\t  u32 freq, u32 bw)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tint ret;\n\tu32 N;\n\n\t \n\n\t \n\tregs[R_EP3]  &= ~0x1f;  \n\tregs[R_EP3]  |= (map->agc_mode << 3) | map->std;\n\n\tif (priv->id == TDA18271HDC2) {\n\t\t \n\t\tregs[R_EP3] &= ~0x04;\n\t}\n\n\t \n\tregs[R_EP4]  &= ~0x03;\n\n\t \n\tregs[R_EP4]  &= ~0x1c;  \n\tregs[R_EP4]  |= (map->if_lvl << 2);\n\n\t \n\tregs[R_EP4]  &= ~0x80;\n\tregs[R_EP4]  |= map->fm_rfn << 7;\n\n\t \n\tregs[R_EB22]  = 0x00;\n\tregs[R_EB22] |= map->rfagc_top;\n\tret = tda18271_write_regs(fe, R_EB22, 1);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\t \n\n\t \n\tregs[R_EP1]  |= 0x40;\n\n\t \n\tregs[R_TM]   &= ~0x10;\n\n\t \n\n\ttda18271_calc_ir_measure(fe, &freq);\n\n\ttda18271_calc_bp_filter(fe, &freq);\n\n\ttda18271_calc_rf_band(fe, &freq);\n\n\ttda18271_calc_gain_taper(fe, &freq);\n\n\t \n\n\t \n\n\tswitch (priv->role) {\n\tcase TDA18271_MASTER:\n\t\tregs[R_EB1]  |= 0x04;  \n\t\tbreak;\n\tcase TDA18271_SLAVE:\n\t\tregs[R_EB1]  &= ~0x04;  \n\t\tbreak;\n\t}\n\n\t \n\tregs[R_EB1]  &= ~0x02;\n\n\t \n\tregs[R_EB1]  &= ~0x01;\n\n\tret = tda18271_write_regs(fe, R_EB1, 1);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\t \n\n\tN = map->if_freq * 1000 + freq;\n\n\tswitch (priv->role) {\n\tcase TDA18271_MASTER:\n\t\ttda18271_calc_main_pll(fe, N);\n\t\ttda18271_set_if_notch(fe);\n\t\ttda18271_write_regs(fe, R_MPD, 4);\n\t\tbreak;\n\tcase TDA18271_SLAVE:\n\t\ttda18271_calc_cal_pll(fe, N);\n\t\ttda18271_write_regs(fe, R_CPD, 4);\n\n\t\tregs[R_MPD] = regs[R_CPD] & 0x7f;\n\t\ttda18271_set_if_notch(fe);\n\t\ttda18271_write_regs(fe, R_MPD, 1);\n\t\tbreak;\n\t}\n\n\tret = tda18271_write_regs(fe, R_TM, 7);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\t \n\tcharge_pump_source(fe, 1);\n\n\tmsleep(1);\n\n\t \n\tcharge_pump_source(fe, 0);\n\n\tmsleep(20);\n\n\tif (priv->id == TDA18271HDC2) {\n\t\t \n\t\tif (map->fm_rfn)\n\t\t\tregs[R_EP3] &= ~0x04;\n\t\telse\n\t\t\tregs[R_EP3] |= 0x04;\n\t\tret = tda18271_write_regs(fe, R_EP3, 1);\n\t}\nfail:\n\treturn ret;\n}\n\nstatic int tda18271_read_thermometer(struct dvb_frontend *fe)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tint tm;\n\n\t \n\tregs[R_TM]   |= 0x10;\n\ttda18271_write_regs(fe, R_TM, 1);\n\n\t \n\ttda18271_read_regs(fe);\n\n\tif ((((regs[R_TM] & 0x0f) == 0x00) && ((regs[R_TM] & 0x20) == 0x20)) ||\n\t    (((regs[R_TM] & 0x0f) == 0x08) && ((regs[R_TM] & 0x20) == 0x00))) {\n\n\t\tif ((regs[R_TM] & 0x20) == 0x20)\n\t\t\tregs[R_TM] &= ~0x20;\n\t\telse\n\t\t\tregs[R_TM] |= 0x20;\n\n\t\ttda18271_write_regs(fe, R_TM, 1);\n\n\t\tmsleep(10);  \n\n\t\t \n\t\ttda18271_read_regs(fe);\n\t}\n\n\ttm = tda18271_lookup_thermometer(fe);\n\n\t \n\tregs[R_TM]   &= ~0x10;\n\ttda18271_write_regs(fe, R_TM, 1);\n\n\t \n\tregs[R_EP4]  &= ~0x03;\n\ttda18271_write_regs(fe, R_EP4, 1);\n\n\treturn tm;\n}\n\n \n\nstatic int tda18271c2_rf_tracking_filters_correction(struct dvb_frontend *fe,\n\t\t\t\t\t\t     u32 freq)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tstruct tda18271_rf_tracking_filter_cal *map = priv->rf_cal_state;\n\tunsigned char *regs = priv->tda18271_regs;\n\tint i, ret;\n\tu8 tm_current, dc_over_dt, rf_tab;\n\ts32 rfcal_comp, approx;\n\n\t \n\tret = tda18271_set_standby_mode(fe, 0, 0, 0);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\t \n\ttm_current = tda18271_read_thermometer(fe);\n\n\t \n\n\ttda18271_calc_rf_cal(fe, &freq);\n\trf_tab = regs[R_EB14];\n\n\ti = tda18271_lookup_rf_band(fe, &freq, NULL);\n\tif (tda_fail(i))\n\t\treturn i;\n\n\tif ((0 == map[i].rf3) || (freq / 1000 < map[i].rf2)) {\n\t\tapprox = map[i].rf_a1 * (s32)(freq / 1000 - map[i].rf1) +\n\t\t\tmap[i].rf_b1 + rf_tab;\n\t} else {\n\t\tapprox = map[i].rf_a2 * (s32)(freq / 1000 - map[i].rf2) +\n\t\t\tmap[i].rf_b2 + rf_tab;\n\t}\n\n\tif (approx < 0)\n\t\tapprox = 0;\n\tif (approx > 255)\n\t\tapprox = 255;\n\n\ttda18271_lookup_map(fe, RF_CAL_DC_OVER_DT, &freq, &dc_over_dt);\n\n\t \n\trfcal_comp = dc_over_dt * (s32)(tm_current - priv->tm_rfcal) / 1000;\n\n\tregs[R_EB14] = (unsigned char)(approx + rfcal_comp);\n\tret = tda18271_write_regs(fe, R_EB14, 1);\nfail:\n\treturn ret;\n}\n\nstatic int tda18271_por(struct dvb_frontend *fe)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tint ret;\n\n\t \n\tregs[R_EB12] &= ~0x20;\n\tret = tda18271_write_regs(fe, R_EB12, 1);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\tregs[R_EB18] &= ~0x80;  \n\tregs[R_EB18] &= ~0x03;  \n\tret = tda18271_write_regs(fe, R_EB18, 1);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\tregs[R_EB21] |= 0x03;  \n\n\t \n\tret = tda18271_set_standby_mode(fe, 1, 0, 0);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\t \n\tregs[R_EB23] &= ~0x04;  \n\tregs[R_EB23] &= ~0x02;  \n\tret = tda18271_write_regs(fe, R_EB21, 3);\nfail:\n\treturn ret;\n}\n\nstatic int tda18271_calibrate_rf(struct dvb_frontend *fe, u32 freq)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tu32 N;\n\n\t \n\tregs[R_EP4]  &= ~0x03;\n\ttda18271_write_regs(fe, R_EP4, 1);\n\n\t \n\tregs[R_EP3]  |= 0x40;  \n\n\tregs[R_EB18] |= 0x03;  \n\ttda18271_write_regs(fe, R_EB18, 1);\n\n\t \n\n\ttda18271_calc_bp_filter(fe, &freq);\n\ttda18271_calc_gain_taper(fe, &freq);\n\ttda18271_calc_rf_band(fe, &freq);\n\ttda18271_calc_km(fe, &freq);\n\n\ttda18271_write_regs(fe, R_EP1, 3);\n\ttda18271_write_regs(fe, R_EB13, 1);\n\n\t \n\ttda18271_charge_pump_source(fe, TDA18271_MAIN_PLL, 1);\n\n\t \n\ttda18271_charge_pump_source(fe, TDA18271_CAL_PLL, 1);\n\n\t \n\tregs[R_EB14] = 0x00;\n\ttda18271_write_regs(fe, R_EB14, 1);\n\n\t \n\tregs[R_EB20] &= ~0x20;\n\ttda18271_write_regs(fe, R_EB20, 1);\n\n\t \n\tregs[R_EP4]  |= 0x03;\n\ttda18271_write_regs(fe, R_EP4, 2);\n\n\t \n\n\t \n\tN = freq;\n\n\ttda18271_calc_cal_pll(fe, N);\n\ttda18271_write_regs(fe, R_CPD, 4);\n\n\t \n\tN += 1000000;\n\n\ttda18271_calc_main_pll(fe, N);\n\ttda18271_write_regs(fe, R_MPD, 4);\n\n\tmsleep(5);\n\n\ttda18271_write_regs(fe, R_EP2, 1);\n\ttda18271_write_regs(fe, R_EP1, 1);\n\ttda18271_write_regs(fe, R_EP2, 1);\n\ttda18271_write_regs(fe, R_EP1, 1);\n\n\t \n\n\t \n\ttda18271_charge_pump_source(fe, TDA18271_MAIN_PLL, 0);\n\n\t \n\ttda18271_charge_pump_source(fe, TDA18271_CAL_PLL, 0);\n\n\tmsleep(10);  \n\n\t \n\tregs[R_EB20]  |= 0x20;\n\ttda18271_write_regs(fe, R_EB20, 1);\n\n\tmsleep(60);  \n\n\t \n\n\t \n\tregs[R_EP4]  &= ~0x03;\n\n\t \n\tregs[R_EP3]  &= ~0x40;  \n\n\tregs[R_EB18] &= ~0x03;  \n\ttda18271_write_regs(fe, R_EB18, 1);\n\n\ttda18271_write_regs(fe, R_EP3, 2);\n\n\t \n\ttda18271_write_regs(fe, R_EP1, 1);\n\n\t \n\ttda18271_read_extended(fe);\n\n\treturn regs[R_EB14];\n}\n\nstatic int tda18271_powerscan(struct dvb_frontend *fe,\n\t\t\t      u32 *freq_in, u32 *freq_out)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tint sgn, bcal, count, wait, ret;\n\tu8 cid_target;\n\tu16 count_limit;\n\tu32 freq;\n\n\tfreq = *freq_in;\n\n\ttda18271_calc_rf_band(fe, &freq);\n\ttda18271_calc_rf_cal(fe, &freq);\n\ttda18271_calc_gain_taper(fe, &freq);\n\ttda18271_lookup_cid_target(fe, &freq, &cid_target, &count_limit);\n\n\ttda18271_write_regs(fe, R_EP2, 1);\n\ttda18271_write_regs(fe, R_EB14, 1);\n\n\t \n\tfreq += 1000000;\n\n\ttda18271_calc_main_pll(fe, freq);\n\ttda18271_write_regs(fe, R_MPD, 4);\n\n\tmsleep(5);  \n\n\t \n\tregs[R_EP4]  &= ~0x03;\n\tregs[R_EP4]  |= 0x01;\n\ttda18271_write_regs(fe, R_EP4, 1);\n\n\t \n\ttda18271_write_regs(fe, R_EP2, 1);\n\n\t \n\tret = tda18271_read_extended(fe);\n\tif (tda_fail(ret))\n\t\treturn ret;\n\n\t \n\tsgn = 1;\n\t*freq_out = *freq_in;\n\tbcal = 0;\n\tcount = 0;\n\twait = false;\n\n\twhile ((regs[R_EB10] & 0x3f) < cid_target) {\n\t\t \n\t\tfreq = *freq_in + (sgn * count) + 1000000;\n\n\t\ttda18271_calc_main_pll(fe, freq);\n\t\ttda18271_write_regs(fe, R_MPD, 4);\n\n\t\tif (wait) {\n\t\t\tmsleep(5);  \n\t\t\twait = false;\n\t\t} else\n\t\t\tudelay(100);  \n\n\t\t \n\t\ttda18271_write_regs(fe, R_EP2, 1);\n\n\t\t \n\t\tret = tda18271_read_extended(fe);\n\t\tif (tda_fail(ret))\n\t\t\treturn ret;\n\n\t\tcount += 200;\n\n\t\tif (count <= count_limit)\n\t\t\tcontinue;\n\n\t\tif (sgn <= 0)\n\t\t\tbreak;\n\n\t\tsgn = -1 * sgn;\n\t\tcount = 200;\n\t\twait = true;\n\t}\n\n\tif ((regs[R_EB10] & 0x3f) >= cid_target) {\n\t\tbcal = 1;\n\t\t*freq_out = freq - 1000000;\n\t} else\n\t\tbcal = 0;\n\n\ttda_cal(\"bcal = %d, freq_in = %d, freq_out = %d (freq = %d)\\n\",\n\t\tbcal, *freq_in, *freq_out, freq);\n\n\treturn bcal;\n}\n\nstatic int tda18271_powerscan_init(struct dvb_frontend *fe)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tint ret;\n\n\t \n\tregs[R_EP3]  &= ~0x1f;  \n\tregs[R_EP3]  |= 0x12;\n\n\t \n\tregs[R_EP4]  &= ~0x03;\n\n\t \n\tregs[R_EP4]  &= ~0x1c;  \n\n\tret = tda18271_write_regs(fe, R_EP3, 2);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\tregs[R_EB18] &= ~0x03;  \n\tret = tda18271_write_regs(fe, R_EB18, 1);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\tregs[R_EB21] &= ~0x03;  \n\n\t \n\tregs[R_EB23] |= 0x04;  \n\tregs[R_EB23] |= 0x02;  \n\n\tret = tda18271_write_regs(fe, R_EB21, 3);\nfail:\n\treturn ret;\n}\n\nstatic int tda18271_rf_tracking_filters_init(struct dvb_frontend *fe, u32 freq)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tstruct tda18271_rf_tracking_filter_cal *map = priv->rf_cal_state;\n\tunsigned char *regs = priv->tda18271_regs;\n\tint bcal, rf, i;\n\ts32 divisor, dividend;\n#define RF1 0\n#define RF2 1\n#define RF3 2\n\tu32 rf_default[3];\n\tu32 rf_freq[3];\n\ts32 prog_cal[3];\n\ts32 prog_tab[3];\n\n\ti = tda18271_lookup_rf_band(fe, &freq, NULL);\n\n\tif (tda_fail(i))\n\t\treturn i;\n\n\trf_default[RF1] = 1000 * map[i].rf1_def;\n\trf_default[RF2] = 1000 * map[i].rf2_def;\n\trf_default[RF3] = 1000 * map[i].rf3_def;\n\n\tfor (rf = RF1; rf <= RF3; rf++) {\n\t\tif (0 == rf_default[rf])\n\t\t\treturn 0;\n\t\ttda_cal(\"freq = %d, rf = %d\\n\", freq, rf);\n\n\t\t \n\t\tbcal = tda18271_powerscan(fe, &rf_default[rf], &rf_freq[rf]);\n\t\tif (tda_fail(bcal))\n\t\t\treturn bcal;\n\n\t\ttda18271_calc_rf_cal(fe, &rf_freq[rf]);\n\t\tprog_tab[rf] = (s32)regs[R_EB14];\n\n\t\tif (1 == bcal)\n\t\t\tprog_cal[rf] =\n\t\t\t\t(s32)tda18271_calibrate_rf(fe, rf_freq[rf]);\n\t\telse\n\t\t\tprog_cal[rf] = prog_tab[rf];\n\n\t\tswitch (rf) {\n\t\tcase RF1:\n\t\t\tmap[i].rf_a1 = 0;\n\t\t\tmap[i].rf_b1 = (prog_cal[RF1] - prog_tab[RF1]);\n\t\t\tmap[i].rf1   = rf_freq[RF1] / 1000;\n\t\t\tbreak;\n\t\tcase RF2:\n\t\t\tdividend = (prog_cal[RF2] - prog_tab[RF2] -\n\t\t\t\t    prog_cal[RF1] + prog_tab[RF1]);\n\t\t\tdivisor = (s32)(rf_freq[RF2] - rf_freq[RF1]) / 1000;\n\t\t\tmap[i].rf_a1 = (dividend / divisor);\n\t\t\tmap[i].rf2   = rf_freq[RF2] / 1000;\n\t\t\tbreak;\n\t\tcase RF3:\n\t\t\tdividend = (prog_cal[RF3] - prog_tab[RF3] -\n\t\t\t\t    prog_cal[RF2] + prog_tab[RF2]);\n\t\t\tdivisor = (s32)(rf_freq[RF3] - rf_freq[RF2]) / 1000;\n\t\t\tmap[i].rf_a2 = (dividend / divisor);\n\t\t\tmap[i].rf_b2 = (prog_cal[RF2] - prog_tab[RF2]);\n\t\t\tmap[i].rf3   = rf_freq[RF3] / 1000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tda18271_calc_rf_filter_curve(struct dvb_frontend *fe)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned int i;\n\tint ret;\n\n\ttda_info(\"performing RF tracking filter calibration\\n\");\n\n\t \n\tmsleep(200);\n\n\tret = tda18271_powerscan_init(fe);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\t \n\tfor (i = 0; priv->rf_cal_state[i].rfmax != 0; i++) {\n\t\tret =\n\t\ttda18271_rf_tracking_filters_init(fe, 1000 *\n\t\t\t\t\t\t  priv->rf_cal_state[i].rfmax);\n\t\tif (tda_fail(ret))\n\t\t\tgoto fail;\n\t}\n\n\tpriv->tm_rfcal = tda18271_read_thermometer(fe);\nfail:\n\treturn ret;\n}\n\n \n\nstatic int tda18271c2_rf_cal_init(struct dvb_frontend *fe)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tint ret;\n\n\t \n\tif ((regs[R_EP1] & 0x10) == 0)\n\t\tpriv->cal_initialized = false;\n\n\tif (priv->cal_initialized)\n\t\treturn 0;\n\n\tret = tda18271_calc_rf_filter_curve(fe);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\tret = tda18271_por(fe);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\ttda_info(\"RF tracking filter calibration complete\\n\");\n\n\tpriv->cal_initialized = true;\n\tgoto end;\nfail:\n\ttda_info(\"RF tracking filter calibration failed!\\n\");\nend:\n\treturn ret;\n}\n\nstatic int tda18271c1_rf_tracking_filter_calibration(struct dvb_frontend *fe,\n\t\t\t\t\t\t     u32 freq, u32 bw)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tint ret;\n\tu32 N = 0;\n\n\t \n\ttda18271_calc_bp_filter(fe, &freq);\n\ttda18271_write_regs(fe, R_EP1, 1);\n\n\tregs[R_EB4]  &= 0x07;\n\tregs[R_EB4]  |= 0x60;\n\ttda18271_write_regs(fe, R_EB4, 1);\n\n\tregs[R_EB7]   = 0x60;\n\ttda18271_write_regs(fe, R_EB7, 1);\n\n\tregs[R_EB14]  = 0x00;\n\ttda18271_write_regs(fe, R_EB14, 1);\n\n\tregs[R_EB20]  = 0xcc;\n\ttda18271_write_regs(fe, R_EB20, 1);\n\n\t \n\tregs[R_EP4]  |= 0x03;\n\n\t \n\n\tswitch (priv->mode) {\n\tcase TDA18271_ANALOG:\n\t\tN = freq - 1250000;\n\t\tbreak;\n\tcase TDA18271_DIGITAL:\n\t\tN = freq + bw / 2;\n\t\tbreak;\n\t}\n\n\ttda18271_calc_cal_pll(fe, N);\n\n\t \n\n\tswitch (priv->mode) {\n\tcase TDA18271_ANALOG:\n\t\tN = freq - 250000;\n\t\tbreak;\n\tcase TDA18271_DIGITAL:\n\t\tN = freq + bw / 2 + 1000000;\n\t\tbreak;\n\t}\n\n\ttda18271_calc_main_pll(fe, N);\n\n\tret = tda18271_write_regs(fe, R_EP3, 11);\n\tif (tda_fail(ret))\n\t\treturn ret;\n\n\tmsleep(5);  \n\n\t \n\ttda18271_calc_km(fe, &freq);\n\ttda18271_write_regs(fe, R_EB13, 1);\n\n\t \n\ttda18271_calc_rf_band(fe, &freq);\n\n\t \n\ttda18271_calc_gain_taper(fe, &freq);\n\n\ttda18271_write_regs(fe, R_EP2, 1);\n\ttda18271_write_regs(fe, R_EP1, 1);\n\ttda18271_write_regs(fe, R_EP2, 1);\n\ttda18271_write_regs(fe, R_EP1, 1);\n\n\tregs[R_EB4]  &= 0x07;\n\tregs[R_EB4]  |= 0x40;\n\ttda18271_write_regs(fe, R_EB4, 1);\n\n\tregs[R_EB7]   = 0x40;\n\ttda18271_write_regs(fe, R_EB7, 1);\n\tmsleep(10);  \n\n\tregs[R_EB20]  = 0xec;\n\ttda18271_write_regs(fe, R_EB20, 1);\n\tmsleep(60);  \n\n\tregs[R_EP4]  &= ~0x03;  \n\ttda18271_write_regs(fe, R_EP4, 1);\n\n\ttda18271_write_regs(fe, R_EP1, 1);\n\n\t \n\tif (0 == tda18271_calc_rf_cal(fe, &freq))\n\t\ttda18271_write_regs(fe, R_EB14, 1);\n\n\treturn 0;\n}\n\n \n\nstatic int tda18271_ir_cal_init(struct dvb_frontend *fe)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tint ret;\n\n\tret = tda18271_read_regs(fe);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\t \n\tif ((regs[R_EP1] & 0x08) == 0)\n\t\tret = tda18271_init_regs(fe);\nfail:\n\treturn ret;\n}\n\nstatic int tda18271_init(struct dvb_frontend *fe)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tret = tda18271_set_standby_mode(fe, 0, 0, 0);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\t \n\tret = tda18271_ir_cal_init(fe);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\tif (priv->id == TDA18271HDC2)\n\t\ttda18271c2_rf_cal_init(fe);\nfail:\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int tda18271_sleep(struct dvb_frontend *fe)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tret = tda18271_toggle_output(fe, 1);\n\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\n \n\nstatic int tda18271_agc(struct dvb_frontend *fe)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tint ret = 0;\n\n\tswitch (priv->config) {\n\tcase TDA8290_LNA_OFF:\n\t\t \n\t\tif (tda18271_debug & DBG_ADV)\n\t\t\ttda_dbg(\"no agc configuration provided\\n\");\n\t\tbreak;\n\tcase TDA8290_LNA_ON_BRIDGE:\n\t\t \n\t\ttda_dbg(\"invoking callback\\n\");\n\t\tif (fe->callback)\n\t\t\tret = fe->callback(priv->i2c_props.adap->algo_data,\n\t\t\t\t\t   DVB_FRONTEND_COMPONENT_TUNER,\n\t\t\t\t\t   TDA18271_CALLBACK_CMD_AGC_ENABLE,\n\t\t\t\t\t   priv->mode);\n\t\tbreak;\n\tcase TDA8290_LNA_GP0_HIGH_ON:\n\tcase TDA8290_LNA_GP0_HIGH_OFF:\n\tdefault:\n\t\t \n\t\ttda_err(\"unsupported configuration: %d\\n\", priv->config);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int tda18271_tune(struct dvb_frontend *fe,\n\t\t\t struct tda18271_std_map_item *map, u32 freq, u32 bw)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tint ret;\n\n\ttda_dbg(\"freq = %d, ifc = %d, bw = %d, agc_mode = %d, std = %d\\n\",\n\t\tfreq, map->if_freq, bw, map->agc_mode, map->std);\n\n\tret = tda18271_agc(fe);\n\tif (tda_fail(ret))\n\t\ttda_warn(\"failed to configure agc\\n\");\n\n\tret = tda18271_init(fe);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\tmutex_lock(&priv->lock);\n\n\tswitch (priv->id) {\n\tcase TDA18271HDC1:\n\t\ttda18271c1_rf_tracking_filter_calibration(fe, freq, bw);\n\t\tbreak;\n\tcase TDA18271HDC2:\n\t\ttda18271c2_rf_tracking_filters_correction(fe, freq);\n\t\tbreak;\n\t}\n\tret = tda18271_channel_configuration(fe, map, freq, bw);\n\n\tmutex_unlock(&priv->lock);\nfail:\n\treturn ret;\n}\n\n \n\nstatic int tda18271_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 delsys = c->delivery_system;\n\tu32 bw = c->bandwidth_hz;\n\tu32 freq = c->frequency;\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tstruct tda18271_std_map *std_map = &priv->std;\n\tstruct tda18271_std_map_item *map;\n\tint ret;\n\n\tpriv->mode = TDA18271_DIGITAL;\n\n\tswitch (delsys) {\n\tcase SYS_ATSC:\n\t\tmap = &std_map->atsc_6;\n\t\tbw = 6000000;\n\t\tbreak;\n\tcase SYS_ISDBT:\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tif (bw <= 6000000) {\n\t\t\tmap = &std_map->dvbt_6;\n\t\t} else if (bw <= 7000000) {\n\t\t\tmap = &std_map->dvbt_7;\n\t\t} else {\n\t\t\tmap = &std_map->dvbt_8;\n\t\t}\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_B:\n\t\tbw = 6000000;\n\t\tfallthrough;\n\tcase SYS_DVBC_ANNEX_A:\n\tcase SYS_DVBC_ANNEX_C:\n\t\tif (bw <= 6000000) {\n\t\t\tmap = &std_map->qam_6;\n\t\t} else if (bw <= 7000000) {\n\t\t\tmap = &std_map->qam_7;\n\t\t} else {\n\t\t\tmap = &std_map->qam_8;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\ttda_warn(\"modulation type not supported!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (fe->ops.analog_ops.standby)\n\t\tfe->ops.analog_ops.standby(fe);\n\n\tret = tda18271_tune(fe, map, freq, bw);\n\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\tpriv->if_freq   = map->if_freq;\n\tpriv->frequency = freq;\n\tpriv->bandwidth = bw;\nfail:\n\treturn ret;\n}\n\nstatic int tda18271_set_analog_params(struct dvb_frontend *fe,\n\t\t\t\t      struct analog_parameters *params)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tstruct tda18271_std_map *std_map = &priv->std;\n\tstruct tda18271_std_map_item *map;\n\tchar *mode;\n\tint ret;\n\tu32 freq = params->frequency * 125 *\n\t\t((params->mode == V4L2_TUNER_RADIO) ? 1 : 1000) / 2;\n\n\tpriv->mode = TDA18271_ANALOG;\n\n\tif (params->mode == V4L2_TUNER_RADIO) {\n\t\tmap = &std_map->fm_radio;\n\t\tmode = \"fm\";\n\t} else if (params->std & V4L2_STD_MN) {\n\t\tmap = &std_map->atv_mn;\n\t\tmode = \"MN\";\n\t} else if (params->std & V4L2_STD_B) {\n\t\tmap = &std_map->atv_b;\n\t\tmode = \"B\";\n\t} else if (params->std & V4L2_STD_GH) {\n\t\tmap = &std_map->atv_gh;\n\t\tmode = \"GH\";\n\t} else if (params->std & V4L2_STD_PAL_I) {\n\t\tmap = &std_map->atv_i;\n\t\tmode = \"I\";\n\t} else if (params->std & V4L2_STD_DK) {\n\t\tmap = &std_map->atv_dk;\n\t\tmode = \"DK\";\n\t} else if (params->std & V4L2_STD_SECAM_L) {\n\t\tmap = &std_map->atv_l;\n\t\tmode = \"L\";\n\t} else if (params->std & V4L2_STD_SECAM_LC) {\n\t\tmap = &std_map->atv_lc;\n\t\tmode = \"L'\";\n\t} else {\n\t\tmap = &std_map->atv_i;\n\t\tmode = \"xx\";\n\t}\n\n\ttda_dbg(\"setting tda18271 to system %s\\n\", mode);\n\n\tret = tda18271_tune(fe, map, freq, 0);\n\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\tpriv->if_freq   = map->if_freq;\n\tpriv->frequency = freq;\n\tpriv->bandwidth = 0;\nfail:\n\treturn ret;\n}\n\nstatic void tda18271_release(struct dvb_frontend *fe)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\n\tmutex_lock(&tda18271_list_mutex);\n\n\tif (priv)\n\t\thybrid_tuner_release_state(priv);\n\n\tmutex_unlock(&tda18271_list_mutex);\n\n\tfe->tuner_priv = NULL;\n}\n\nstatic int tda18271_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\t*frequency = priv->frequency;\n\treturn 0;\n}\n\nstatic int tda18271_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\t*bandwidth = priv->bandwidth;\n\treturn 0;\n}\n\nstatic int tda18271_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\t*frequency = (u32)priv->if_freq * 1000;\n\treturn 0;\n}\n\n \n\n#define tda18271_update_std(std_cfg, name) do {\t\t\t\t\\\n\tif (map->std_cfg.if_freq +\t\t\t\t\t\\\n\t\tmap->std_cfg.agc_mode + map->std_cfg.std +\t\t\\\n\t\tmap->std_cfg.if_lvl + map->std_cfg.rfagc_top > 0) {\t\\\n\t\ttda_dbg(\"Using custom std config for %s\\n\", name);\t\\\n\t\tmemcpy(&std->std_cfg, &map->std_cfg,\t\t\t\\\n\t\t\tsizeof(struct tda18271_std_map_item));\t\t\\\n\t} } while (0)\n\n#define tda18271_dump_std_item(std_cfg, name) do {\t\t\t\\\n\ttda_dbg(\"(%s) if_freq = %d, agc_mode = %d, std = %d, \"\t\t\\\n\t\t\"if_lvl = %d, rfagc_top = 0x%02x\\n\",\t\t\t\\\n\t\tname, std->std_cfg.if_freq,\t\t\t\t\\\n\t\tstd->std_cfg.agc_mode, std->std_cfg.std,\t\t\\\n\t\tstd->std_cfg.if_lvl, std->std_cfg.rfagc_top);\t\t\\\n\t} while (0)\n\nstatic int tda18271_dump_std_map(struct dvb_frontend *fe)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tstruct tda18271_std_map *std = &priv->std;\n\n\ttda_dbg(\"========== STANDARD MAP SETTINGS ==========\\n\");\n\ttda18271_dump_std_item(fm_radio, \"  fm  \");\n\ttda18271_dump_std_item(atv_b,  \"atv b \");\n\ttda18271_dump_std_item(atv_dk, \"atv dk\");\n\ttda18271_dump_std_item(atv_gh, \"atv gh\");\n\ttda18271_dump_std_item(atv_i,  \"atv i \");\n\ttda18271_dump_std_item(atv_l,  \"atv l \");\n\ttda18271_dump_std_item(atv_lc, \"atv l'\");\n\ttda18271_dump_std_item(atv_mn, \"atv mn\");\n\ttda18271_dump_std_item(atsc_6, \"atsc 6\");\n\ttda18271_dump_std_item(dvbt_6, \"dvbt 6\");\n\ttda18271_dump_std_item(dvbt_7, \"dvbt 7\");\n\ttda18271_dump_std_item(dvbt_8, \"dvbt 8\");\n\ttda18271_dump_std_item(qam_6,  \"qam 6 \");\n\ttda18271_dump_std_item(qam_7,  \"qam 7 \");\n\ttda18271_dump_std_item(qam_8,  \"qam 8 \");\n\n\treturn 0;\n}\n\nstatic int tda18271_update_std_map(struct dvb_frontend *fe,\n\t\t\t\t   struct tda18271_std_map *map)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tstruct tda18271_std_map *std = &priv->std;\n\n\tif (!map)\n\t\treturn -EINVAL;\n\n\ttda18271_update_std(fm_radio, \"fm\");\n\ttda18271_update_std(atv_b,  \"atv b\");\n\ttda18271_update_std(atv_dk, \"atv dk\");\n\ttda18271_update_std(atv_gh, \"atv gh\");\n\ttda18271_update_std(atv_i,  \"atv i\");\n\ttda18271_update_std(atv_l,  \"atv l\");\n\ttda18271_update_std(atv_lc, \"atv l'\");\n\ttda18271_update_std(atv_mn, \"atv mn\");\n\ttda18271_update_std(atsc_6, \"atsc 6\");\n\ttda18271_update_std(dvbt_6, \"dvbt 6\");\n\ttda18271_update_std(dvbt_7, \"dvbt 7\");\n\ttda18271_update_std(dvbt_8, \"dvbt 8\");\n\ttda18271_update_std(qam_6,  \"qam 6\");\n\ttda18271_update_std(qam_7,  \"qam 7\");\n\ttda18271_update_std(qam_8,  \"qam 8\");\n\n\treturn 0;\n}\n\nstatic int tda18271_get_id(struct dvb_frontend *fe)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tchar *name;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\tret = tda18271_read_regs(fe);\n\tmutex_unlock(&priv->lock);\n\n\tif (ret) {\n\t\ttda_info(\"Error reading device ID @ %d-%04x, bailing out.\\n\",\n\t\t\t i2c_adapter_id(priv->i2c_props.adap),\n\t\t\t priv->i2c_props.addr);\n\t\treturn -EIO;\n\t}\n\n\tswitch (regs[R_ID] & 0x7f) {\n\tcase 3:\n\t\tname = \"TDA18271HD/C1\";\n\t\tpriv->id = TDA18271HDC1;\n\t\tbreak;\n\tcase 4:\n\t\tname = \"TDA18271HD/C2\";\n\t\tpriv->id = TDA18271HDC2;\n\t\tbreak;\n\tdefault:\n\t\ttda_info(\"Unknown device (%i) detected @ %d-%04x, device not supported.\\n\",\n\t\t\t regs[R_ID], i2c_adapter_id(priv->i2c_props.adap),\n\t\t\t priv->i2c_props.addr);\n\t\treturn -EINVAL;\n\t}\n\n\ttda_info(\"%s detected @ %d-%04x\\n\", name,\n\t\t i2c_adapter_id(priv->i2c_props.adap), priv->i2c_props.addr);\n\n\treturn 0;\n}\n\nstatic int tda18271_setup_configuration(struct dvb_frontend *fe,\n\t\t\t\t\tstruct tda18271_config *cfg)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\n\tpriv->gate = (cfg) ? cfg->gate : TDA18271_GATE_AUTO;\n\tpriv->role = (cfg) ? cfg->role : TDA18271_MASTER;\n\tpriv->config = (cfg) ? cfg->config : 0;\n\tpriv->small_i2c = (cfg) ?\n\t\tcfg->small_i2c : TDA18271_39_BYTE_CHUNK_INIT;\n\tpriv->output_opt = (cfg) ?\n\t\tcfg->output_opt : TDA18271_OUTPUT_LT_XT_ON;\n\n\treturn 0;\n}\n\nstatic inline int tda18271_need_cal_on_startup(struct tda18271_config *cfg)\n{\n\t \n\treturn ((tda18271_cal_on_startup == -1) ?\n\t\t \n\t\t((cfg) && (cfg->rf_cal_on_startup)) :\n\t\t \n\t\t(tda18271_cal_on_startup)) ? 1 : 0;\n}\n\nstatic int tda18271_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct tda18271_config *cfg = (struct tda18271_config *) priv_cfg;\n\n\ttda18271_setup_configuration(fe, cfg);\n\n\tif (tda18271_need_cal_on_startup(cfg))\n\t\ttda18271_init(fe);\n\n\t \n\tif ((cfg) && (cfg->std_map))\n\t\ttda18271_update_std_map(fe, cfg->std_map);\n\n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops tda18271_tuner_ops = {\n\t.info = {\n\t\t.name = \"NXP TDA18271HD\",\n\t\t.frequency_min_hz  =  45 * MHz,\n\t\t.frequency_max_hz  = 864 * MHz,\n\t\t.frequency_step_hz = 62500\n\t},\n\t.init              = tda18271_init,\n\t.sleep             = tda18271_sleep,\n\t.set_params        = tda18271_set_params,\n\t.set_analog_params = tda18271_set_analog_params,\n\t.release           = tda18271_release,\n\t.set_config        = tda18271_set_config,\n\t.get_frequency     = tda18271_get_frequency,\n\t.get_bandwidth     = tda18271_get_bandwidth,\n\t.get_if_frequency  = tda18271_get_if_frequency,\n};\n\nstruct dvb_frontend *tda18271_attach(struct dvb_frontend *fe, u8 addr,\n\t\t\t\t     struct i2c_adapter *i2c,\n\t\t\t\t     struct tda18271_config *cfg)\n{\n\tstruct tda18271_priv *priv = NULL;\n\tint instance, ret;\n\n\tmutex_lock(&tda18271_list_mutex);\n\n\tinstance = hybrid_tuner_request_state(struct tda18271_priv, priv,\n\t\t\t\t\t      hybrid_tuner_instance_list,\n\t\t\t\t\t      i2c, addr, \"tda18271\");\n\tswitch (instance) {\n\tcase 0:\n\t\tgoto fail;\n\tcase 1:\n\t\t \n\t\tfe->tuner_priv = priv;\n\n\t\ttda18271_setup_configuration(fe, cfg);\n\n\t\tpriv->cal_initialized = false;\n\t\tmutex_init(&priv->lock);\n\n\t\tret = tda18271_get_id(fe);\n\t\tif (tda_fail(ret))\n\t\t\tgoto fail;\n\n\t\tret = tda18271_assign_map_layout(fe);\n\t\tif (tda_fail(ret))\n\t\t\tgoto fail;\n\n\t\t \n\t\tif ((cfg->delay_cal) && (!tda18271_need_cal_on_startup(cfg)))\n\t\t\tbreak;\n\n\t\tmutex_lock(&priv->lock);\n\t\ttda18271_init_regs(fe);\n\n\t\tif ((tda18271_need_cal_on_startup(cfg)) &&\n\t\t    (priv->id == TDA18271HDC2))\n\t\t\ttda18271c2_rf_cal_init(fe);\n\n\t\t \n\t\tret = tda18271_toggle_output(fe, 1);\n\t\ttda_fail(ret);\n\n\t\tmutex_unlock(&priv->lock);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tfe->tuner_priv = priv;\n\n\t\t \n\t\tif (cfg) {\n\t\t\tif (cfg->gate != TDA18271_GATE_ANALOG)\n\t\t\t\tpriv->gate = cfg->gate;\n\t\t\tif (cfg->role)\n\t\t\t\tpriv->role = cfg->role;\n\t\t\tif (cfg->config)\n\t\t\t\tpriv->config = cfg->config;\n\t\t\tif (cfg->small_i2c)\n\t\t\t\tpriv->small_i2c = cfg->small_i2c;\n\t\t\tif (cfg->output_opt)\n\t\t\t\tpriv->output_opt = cfg->output_opt;\n\t\t\tif (cfg->std_map)\n\t\t\t\ttda18271_update_std_map(fe, cfg->std_map);\n\t\t}\n\t\tif (tda18271_need_cal_on_startup(cfg))\n\t\t\ttda18271_init(fe);\n\t\tbreak;\n\t}\n\n\t \n\tif ((cfg) && (cfg->std_map))\n\t\ttda18271_update_std_map(fe, cfg->std_map);\n\n\tmutex_unlock(&tda18271_list_mutex);\n\n\tmemcpy(&fe->ops.tuner_ops, &tda18271_tuner_ops,\n\t       sizeof(struct dvb_tuner_ops));\n\n\tif (tda18271_debug & (DBG_MAP | DBG_ADV))\n\t\ttda18271_dump_std_map(fe);\n\n\treturn fe;\nfail:\n\tmutex_unlock(&tda18271_list_mutex);\n\n\ttda18271_release(fe);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(tda18271_attach);\nMODULE_DESCRIPTION(\"NXP TDA18271HD analog / digital tuner driver\");\nMODULE_AUTHOR(\"Michael Krufky <mkrufky@linuxtv.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.4\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}