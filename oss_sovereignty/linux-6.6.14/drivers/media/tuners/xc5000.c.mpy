{
  "module_name": "xc5000.c",
  "hash_id": "18d9a981e510e54c2c051ec0c07196fa65c9bb3ca247c457c7553357f6aa27d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/xc5000.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/videodev2.h>\n#include <linux/delay.h>\n#include <linux/workqueue.h>\n#include <linux/dvb/frontend.h>\n#include <linux/i2c.h>\n\n#include <media/dvb_frontend.h>\n\n#include \"xc5000.h\"\n#include \"tuner-i2c.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off debugging (default:off).\");\n\nstatic int no_poweroff;\nmodule_param(no_poweroff, int, 0644);\nMODULE_PARM_DESC(no_poweroff, \"0 (default) powers device off when not used.\\n\"\n\t\"\\t\\t1 keep device energized and with tuner ready all the times.\\n\"\n\t\"\\t\\tFaster, but consumes more power and keeps the device hotter\");\n\nstatic DEFINE_MUTEX(xc5000_list_mutex);\nstatic LIST_HEAD(hybrid_tuner_instance_list);\n\n#define dprintk(level, fmt, arg...) if (debug >= level) \\\n\tprintk(KERN_INFO \"%s: \" fmt, \"xc5000\", ## arg)\n\nstruct xc5000_priv {\n\tstruct tuner_i2c_props i2c_props;\n\tstruct list_head hybrid_tuner_instance_list;\n\n\tu32 if_khz;\n\tu16 xtal_khz;\n\tu32 freq_hz, freq_offset;\n\tu32 bandwidth;\n\tu8  video_standard;\n\tunsigned int mode;\n\tu8  rf_mode;\n\tu8  radio_input;\n\tu16  output_amp;\n\n\tint chip_id;\n\tu16 pll_register_no;\n\tu8 init_status_supported;\n\tu8 fw_checksum_supported;\n\n\tstruct dvb_frontend *fe;\n\tstruct delayed_work timer_sleep;\n\n\tconst struct firmware   *firmware;\n};\n\n \n#define MAX_TV_STANDARD\t\t\t24\n#define XC_MAX_I2C_WRITE_LENGTH\t\t64\n\n \n#define XC5000_SLEEP_TIME\t\t5000  \n\n \n#define XC_RF_MODE_AIR\t\t\t0\n#define XC_RF_MODE_CABLE\t\t1\n\n \n#define XC_PRODUCT_ID_FW_NOT_LOADED\t0x2000\n#define XC_PRODUCT_ID_FW_LOADED\t0x1388\n\n \n#define XREG_INIT         0x00\n#define XREG_VIDEO_MODE   0x01\n#define XREG_AUDIO_MODE   0x02\n#define XREG_RF_FREQ      0x03\n#define XREG_D_CODE       0x04\n#define XREG_IF_OUT       0x05\n#define XREG_SEEK_MODE    0x07\n#define XREG_POWER_DOWN   0x0A  \n \n#define XREG_OUTPUT_AMP   0x0B\n#define XREG_SIGNALSOURCE 0x0D  \n#define XREG_SMOOTHEDCVBS 0x0E\n#define XREG_XTALFREQ     0x0F\n#define XREG_FINERFREQ    0x10\n#define XREG_DDIMODE      0x11\n\n#define XREG_ADC_ENV      0x00\n#define XREG_QUALITY      0x01\n#define XREG_FRAME_LINES  0x02\n#define XREG_HSYNC_FREQ   0x03\n#define XREG_LOCK         0x04\n#define XREG_FREQ_ERROR   0x05\n#define XREG_SNR          0x06\n#define XREG_VERSION      0x07\n#define XREG_PRODUCT_ID   0x08\n#define XREG_BUSY         0x09\n#define XREG_BUILD        0x0D\n#define XREG_TOTALGAIN    0x0F\n#define XREG_FW_CHECKSUM  0x12\n#define XREG_INIT_STATUS  0x13\n\n \nstruct XC_TV_STANDARD {\n\tchar *name;\n\tu16 audio_mode;\n\tu16 video_mode;\n};\n\n \n#define MN_NTSC_PAL_BTSC\t0\n#define MN_NTSC_PAL_A2\t\t1\n#define MN_NTSC_PAL_EIAJ\t2\n#define MN_NTSC_PAL_MONO\t3\n#define BG_PAL_A2\t\t4\n#define BG_PAL_NICAM\t\t5\n#define BG_PAL_MONO\t\t6\n#define I_PAL_NICAM\t\t7\n#define I_PAL_NICAM_MONO\t8\n#define DK_PAL_A2\t\t9\n#define DK_PAL_NICAM\t\t10\n#define DK_PAL_MONO\t\t11\n#define DK_SECAM_A2DK1\t\t12\n#define DK_SECAM_A2LDK3\t\t13\n#define DK_SECAM_A2MONO\t\t14\n#define L_SECAM_NICAM\t\t15\n#define LC_SECAM_NICAM\t\t16\n#define DTV6\t\t\t17\n#define DTV8\t\t\t18\n#define DTV7_8\t\t\t19\n#define DTV7\t\t\t20\n#define FM_RADIO_INPUT2\t\t21\n#define FM_RADIO_INPUT1\t\t22\n#define FM_RADIO_INPUT1_MONO\t23\n\nstatic struct XC_TV_STANDARD xc5000_standard[MAX_TV_STANDARD] = {\n\t{\"M/N-NTSC/PAL-BTSC\", 0x0400, 0x8020},\n\t{\"M/N-NTSC/PAL-A2\",   0x0600, 0x8020},\n\t{\"M/N-NTSC/PAL-EIAJ\", 0x0440, 0x8020},\n\t{\"M/N-NTSC/PAL-Mono\", 0x0478, 0x8020},\n\t{\"B/G-PAL-A2\",        0x0A00, 0x8049},\n\t{\"B/G-PAL-NICAM\",     0x0C04, 0x8049},\n\t{\"B/G-PAL-MONO\",      0x0878, 0x8059},\n\t{\"I-PAL-NICAM\",       0x1080, 0x8009},\n\t{\"I-PAL-NICAM-MONO\",  0x0E78, 0x8009},\n\t{\"D/K-PAL-A2\",        0x1600, 0x8009},\n\t{\"D/K-PAL-NICAM\",     0x0E80, 0x8009},\n\t{\"D/K-PAL-MONO\",      0x1478, 0x8009},\n\t{\"D/K-SECAM-A2 DK1\",  0x1200, 0x8009},\n\t{\"D/K-SECAM-A2 L/DK3\", 0x0E00, 0x8009},\n\t{\"D/K-SECAM-A2 MONO\", 0x1478, 0x8009},\n\t{\"L-SECAM-NICAM\",     0x8E82, 0x0009},\n\t{\"L'-SECAM-NICAM\",    0x8E82, 0x4009},\n\t{\"DTV6\",              0x00C0, 0x8002},\n\t{\"DTV8\",              0x00C0, 0x800B},\n\t{\"DTV7/8\",            0x00C0, 0x801B},\n\t{\"DTV7\",              0x00C0, 0x8007},\n\t{\"FM Radio-INPUT2\",   0x9802, 0x9002},\n\t{\"FM Radio-INPUT1\",   0x0208, 0x9002},\n\t{\"FM Radio-INPUT1_MONO\", 0x0278, 0x9002}\n};\n\n\nstruct xc5000_fw_cfg {\n\tchar *name;\n\tu16 size;\n\tu16 pll_reg;\n\tu8 init_status_supported;\n\tu8 fw_checksum_supported;\n};\n\n#define XC5000A_FIRMWARE \"dvb-fe-xc5000-1.6.114.fw\"\nstatic const struct xc5000_fw_cfg xc5000a_1_6_114 = {\n\t.name = XC5000A_FIRMWARE,\n\t.size = 12401,\n\t.pll_reg = 0x806c,\n};\n\n#define XC5000C_FIRMWARE \"dvb-fe-xc5000c-4.1.30.7.fw\"\nstatic const struct xc5000_fw_cfg xc5000c_41_024_5 = {\n\t.name = XC5000C_FIRMWARE,\n\t.size = 16497,\n\t.pll_reg = 0x13,\n\t.init_status_supported = 1,\n\t.fw_checksum_supported = 1,\n};\n\nstatic inline const struct xc5000_fw_cfg *xc5000_assign_firmware(int chip_id)\n{\n\tswitch (chip_id) {\n\tdefault:\n\tcase XC5000A:\n\t\treturn &xc5000a_1_6_114;\n\tcase XC5000C:\n\t\treturn &xc5000c_41_024_5;\n\t}\n}\n\nstatic int xc_load_fw_and_init_tuner(struct dvb_frontend *fe, int force);\nstatic int xc5000_is_firmware_loaded(struct dvb_frontend *fe);\nstatic int xc5000_readreg(struct xc5000_priv *priv, u16 reg, u16 *val);\nstatic int xc5000_tuner_reset(struct dvb_frontend *fe);\n\nstatic int xc_send_i2c_data(struct xc5000_priv *priv, u8 *buf, int len)\n{\n\tstruct i2c_msg msg = { .addr = priv->i2c_props.addr,\n\t\t\t       .flags = 0, .buf = buf, .len = len };\n\n\tif (i2c_transfer(priv->i2c_props.adap, &msg, 1) != 1) {\n\t\tprintk(KERN_ERR \"xc5000: I2C write failed (len=%i)\\n\", len);\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\n#if 0\n \nstatic int xc_read_i2c_data(struct xc5000_priv *priv, u8 *buf, int len)\n{\n\tstruct i2c_msg msg = { .addr = priv->i2c_props.addr,\n\t\t.flags = I2C_M_RD, .buf = buf, .len = len };\n\n\tif (i2c_transfer(priv->i2c_props.adap, &msg, 1) != 1) {\n\t\tprintk(KERN_ERR \"xc5000 I2C read failed (len=%i)\\n\", len);\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n#endif\n\nstatic int xc5000_readreg(struct xc5000_priv *priv, u16 reg, u16 *val)\n{\n\tu8 buf[2] = { reg >> 8, reg & 0xff };\n\tu8 bval[2] = { 0, 0 };\n\tstruct i2c_msg msg[2] = {\n\t\t{ .addr = priv->i2c_props.addr,\n\t\t\t.flags = 0, .buf = &buf[0], .len = 2 },\n\t\t{ .addr = priv->i2c_props.addr,\n\t\t\t.flags = I2C_M_RD, .buf = &bval[0], .len = 2 },\n\t};\n\n\tif (i2c_transfer(priv->i2c_props.adap, msg, 2) != 2) {\n\t\tprintk(KERN_WARNING \"xc5000: I2C read failed\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\t*val = (bval[0] << 8) | bval[1];\n\treturn 0;\n}\n\nstatic int xc5000_tuner_reset(struct dvb_frontend *fe)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\tint ret;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tif (fe->callback) {\n\t\tret = fe->callback(((fe->dvb) && (fe->dvb->priv)) ?\n\t\t\t\t\t   fe->dvb->priv :\n\t\t\t\t\t   priv->i2c_props.adap->algo_data,\n\t\t\t\t\t   DVB_FRONTEND_COMPONENT_TUNER,\n\t\t\t\t\t   XC5000_TUNER_RESET, 0);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR \"xc5000: reset failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tprintk(KERN_ERR \"xc5000: no tuner reset callback function, fatal\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int xc_write_reg(struct xc5000_priv *priv, u16 reg_addr, u16 i2c_data)\n{\n\tu8 buf[4];\n\tint watch_dog_timer = 100;\n\tint result;\n\n\tbuf[0] = (reg_addr >> 8) & 0xFF;\n\tbuf[1] = reg_addr & 0xFF;\n\tbuf[2] = (i2c_data >> 8) & 0xFF;\n\tbuf[3] = i2c_data & 0xFF;\n\tresult = xc_send_i2c_data(priv, buf, 4);\n\tif (result == 0) {\n\t\t \n\t\twhile ((watch_dog_timer > 0) && (result == 0)) {\n\t\t\tresult = xc5000_readreg(priv, XREG_BUSY, (u16 *)buf);\n\t\t\tif (result == 0) {\n\t\t\t\tif ((buf[0] == 0) && (buf[1] == 0)) {\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tmsleep(5);  \n\t\t\t\t\twatch_dog_timer--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (watch_dog_timer <= 0)\n\t\tresult = -EREMOTEIO;\n\n\treturn result;\n}\n\nstatic int xc_load_i2c_sequence(struct dvb_frontend *fe, const u8 *i2c_sequence)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\n\tint i, nbytes_to_send, result;\n\tunsigned int len, pos, index;\n\tu8 buf[XC_MAX_I2C_WRITE_LENGTH];\n\n\tindex = 0;\n\twhile ((i2c_sequence[index] != 0xFF) ||\n\t\t(i2c_sequence[index + 1] != 0xFF)) {\n\t\tlen = i2c_sequence[index] * 256 + i2c_sequence[index+1];\n\t\tif (len == 0x0000) {\n\t\t\t \n\t\t\tresult = xc5000_tuner_reset(fe);\n\t\t\tindex += 2;\n\t\t\tif (result != 0)\n\t\t\t\treturn result;\n\t\t} else if (len & 0x8000) {\n\t\t\t \n\t\t\tmsleep(len & 0x7FFF);\n\t\t\tindex += 2;\n\t\t} else {\n\t\t\t \n\t\t\tindex += 2;\n\t\t\tbuf[0] = i2c_sequence[index];\n\t\t\tbuf[1] = i2c_sequence[index + 1];\n\t\t\tpos = 2;\n\t\t\twhile (pos < len) {\n\t\t\t\tif ((len - pos) > XC_MAX_I2C_WRITE_LENGTH - 2)\n\t\t\t\t\tnbytes_to_send =\n\t\t\t\t\t\tXC_MAX_I2C_WRITE_LENGTH;\n\t\t\t\telse\n\t\t\t\t\tnbytes_to_send = (len - pos + 2);\n\t\t\t\tfor (i = 2; i < nbytes_to_send; i++) {\n\t\t\t\t\tbuf[i] = i2c_sequence[index + pos +\n\t\t\t\t\t\ti - 2];\n\t\t\t\t}\n\t\t\t\tresult = xc_send_i2c_data(priv, buf,\n\t\t\t\t\tnbytes_to_send);\n\n\t\t\t\tif (result != 0)\n\t\t\t\t\treturn result;\n\n\t\t\t\tpos += nbytes_to_send - 2;\n\t\t\t}\n\t\t\tindex += len;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int xc_initialize(struct xc5000_priv *priv)\n{\n\tdprintk(1, \"%s()\\n\", __func__);\n\treturn xc_write_reg(priv, XREG_INIT, 0);\n}\n\nstatic int xc_set_tv_standard(struct xc5000_priv *priv,\n\tu16 video_mode, u16 audio_mode, u8 radio_mode)\n{\n\tint ret;\n\tdprintk(1, \"%s(0x%04x,0x%04x)\\n\", __func__, video_mode, audio_mode);\n\tif (radio_mode) {\n\t\tdprintk(1, \"%s() Standard = %s\\n\",\n\t\t\t__func__,\n\t\t\txc5000_standard[radio_mode].name);\n\t} else {\n\t\tdprintk(1, \"%s() Standard = %s\\n\",\n\t\t\t__func__,\n\t\t\txc5000_standard[priv->video_standard].name);\n\t}\n\n\tret = xc_write_reg(priv, XREG_VIDEO_MODE, video_mode);\n\tif (ret == 0)\n\t\tret = xc_write_reg(priv, XREG_AUDIO_MODE, audio_mode);\n\n\treturn ret;\n}\n\nstatic int xc_set_signal_source(struct xc5000_priv *priv, u16 rf_mode)\n{\n\tdprintk(1, \"%s(%d) Source = %s\\n\", __func__, rf_mode,\n\t\trf_mode == XC_RF_MODE_AIR ? \"ANTENNA\" : \"CABLE\");\n\n\tif ((rf_mode != XC_RF_MODE_AIR) && (rf_mode != XC_RF_MODE_CABLE)) {\n\t\trf_mode = XC_RF_MODE_CABLE;\n\t\tprintk(KERN_ERR\n\t\t\t\"%s(), Invalid mode, defaulting to CABLE\",\n\t\t\t__func__);\n\t}\n\treturn xc_write_reg(priv, XREG_SIGNALSOURCE, rf_mode);\n}\n\nstatic const struct dvb_tuner_ops xc5000_tuner_ops;\n\nstatic int xc_set_rf_frequency(struct xc5000_priv *priv, u32 freq_hz)\n{\n\tu16 freq_code;\n\n\tdprintk(1, \"%s(%u)\\n\", __func__, freq_hz);\n\n\tif ((freq_hz > xc5000_tuner_ops.info.frequency_max_hz) ||\n\t\t(freq_hz < xc5000_tuner_ops.info.frequency_min_hz))\n\t\treturn -EINVAL;\n\n\tfreq_code = (u16)(freq_hz / 15625);\n\n\t \n\treturn xc_write_reg(priv, XREG_FINERFREQ, freq_code);\n}\n\n\nstatic int xc_set_IF_frequency(struct xc5000_priv *priv, u32 freq_khz)\n{\n\tu32 freq_code = (freq_khz * 1024)/1000;\n\tdprintk(1, \"%s(freq_khz = %d) freq_code = 0x%x\\n\",\n\t\t__func__, freq_khz, freq_code);\n\n\treturn xc_write_reg(priv, XREG_IF_OUT, freq_code);\n}\n\n\nstatic int xc_get_adc_envelope(struct xc5000_priv *priv, u16 *adc_envelope)\n{\n\treturn xc5000_readreg(priv, XREG_ADC_ENV, adc_envelope);\n}\n\nstatic int xc_get_frequency_error(struct xc5000_priv *priv, u32 *freq_error_hz)\n{\n\tint result;\n\tu16 reg_data;\n\tu32 tmp;\n\n\tresult = xc5000_readreg(priv, XREG_FREQ_ERROR, &reg_data);\n\tif (result != 0)\n\t\treturn result;\n\n\ttmp = (u32)reg_data;\n\t(*freq_error_hz) = (tmp * 15625) / 1000;\n\treturn result;\n}\n\nstatic int xc_get_lock_status(struct xc5000_priv *priv, u16 *lock_status)\n{\n\treturn xc5000_readreg(priv, XREG_LOCK, lock_status);\n}\n\nstatic int xc_get_version(struct xc5000_priv *priv,\n\tu8 *hw_majorversion, u8 *hw_minorversion,\n\tu8 *fw_majorversion, u8 *fw_minorversion)\n{\n\tu16 data;\n\tint result;\n\n\tresult = xc5000_readreg(priv, XREG_VERSION, &data);\n\tif (result != 0)\n\t\treturn result;\n\n\t(*hw_majorversion) = (data >> 12) & 0x0F;\n\t(*hw_minorversion) = (data >>  8) & 0x0F;\n\t(*fw_majorversion) = (data >>  4) & 0x0F;\n\t(*fw_minorversion) = data & 0x0F;\n\n\treturn 0;\n}\n\nstatic int xc_get_buildversion(struct xc5000_priv *priv, u16 *buildrev)\n{\n\treturn xc5000_readreg(priv, XREG_BUILD, buildrev);\n}\n\nstatic int xc_get_hsync_freq(struct xc5000_priv *priv, u32 *hsync_freq_hz)\n{\n\tu16 reg_data;\n\tint result;\n\n\tresult = xc5000_readreg(priv, XREG_HSYNC_FREQ, &reg_data);\n\tif (result != 0)\n\t\treturn result;\n\n\t(*hsync_freq_hz) = ((reg_data & 0x0fff) * 763)/100;\n\treturn result;\n}\n\nstatic int xc_get_frame_lines(struct xc5000_priv *priv, u16 *frame_lines)\n{\n\treturn xc5000_readreg(priv, XREG_FRAME_LINES, frame_lines);\n}\n\nstatic int xc_get_quality(struct xc5000_priv *priv, u16 *quality)\n{\n\treturn xc5000_readreg(priv, XREG_QUALITY, quality);\n}\n\nstatic int xc_get_analogsnr(struct xc5000_priv *priv, u16 *snr)\n{\n\treturn xc5000_readreg(priv, XREG_SNR, snr);\n}\n\nstatic int xc_get_totalgain(struct xc5000_priv *priv, u16 *totalgain)\n{\n\treturn xc5000_readreg(priv, XREG_TOTALGAIN, totalgain);\n}\n\n#define XC_TUNE_ANALOG  0\n#define XC_TUNE_DIGITAL 1\nstatic int xc_tune_channel(struct xc5000_priv *priv, u32 freq_hz, int mode)\n{\n\tdprintk(1, \"%s(%u)\\n\", __func__, freq_hz);\n\n\tif (xc_set_rf_frequency(priv, freq_hz) != 0)\n\t\treturn -EREMOTEIO;\n\n\treturn 0;\n}\n\nstatic int xc_set_xtal(struct dvb_frontend *fe)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\tint ret = 0;\n\n\tswitch (priv->chip_id) {\n\tdefault:\n\tcase XC5000A:\n\t\t \n\t\tbreak;\n\tcase XC5000C:\n\t\tswitch (priv->xtal_khz) {\n\t\tdefault:\n\t\tcase 32000:\n\t\t\t \n\t\t\tbreak;\n\t\tcase 31875:\n\t\t\t \n\t\t\tret = xc_write_reg(priv, 0x000f, 0x8081);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int xc5000_fwupload(struct dvb_frontend *fe,\n\t\t\t   const struct xc5000_fw_cfg *desired_fw,\n\t\t\t   const struct firmware *fw)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\tint ret;\n\n\t \n\tdprintk(1, \"waiting for firmware upload (%s)...\\n\",\n\t\tdesired_fw->name);\n\n\tpriv->pll_register_no = desired_fw->pll_reg;\n\tpriv->init_status_supported = desired_fw->init_status_supported;\n\tpriv->fw_checksum_supported = desired_fw->fw_checksum_supported;\n\n\n\tdprintk(1, \"firmware uploading...\\n\");\n\tret = xc_load_i2c_sequence(fe,  fw->data);\n\tif (!ret) {\n\t\tret = xc_set_xtal(fe);\n\t\tdprintk(1, \"Firmware upload complete...\\n\");\n\t} else\n\t\tprintk(KERN_ERR \"xc5000: firmware upload failed...\\n\");\n\n\treturn ret;\n}\n\nstatic void xc_debug_dump(struct xc5000_priv *priv)\n{\n\tu16 adc_envelope;\n\tu32 freq_error_hz = 0;\n\tu16 lock_status;\n\tu32 hsync_freq_hz = 0;\n\tu16 frame_lines;\n\tu16 quality;\n\tu16 snr;\n\tu16 totalgain;\n\tu8 hw_majorversion = 0, hw_minorversion = 0;\n\tu8 fw_majorversion = 0, fw_minorversion = 0;\n\tu16 fw_buildversion = 0;\n\tu16 regval;\n\n\t \n\tmsleep(100);\n\n\txc_get_adc_envelope(priv,  &adc_envelope);\n\tdprintk(1, \"*** ADC envelope (0-1023) = %d\\n\", adc_envelope);\n\n\txc_get_frequency_error(priv, &freq_error_hz);\n\tdprintk(1, \"*** Frequency error = %d Hz\\n\", freq_error_hz);\n\n\txc_get_lock_status(priv,  &lock_status);\n\tdprintk(1, \"*** Lock status (0-Wait, 1-Locked, 2-No-signal) = %d\\n\",\n\t\tlock_status);\n\n\txc_get_version(priv,  &hw_majorversion, &hw_minorversion,\n\t\t&fw_majorversion, &fw_minorversion);\n\txc_get_buildversion(priv,  &fw_buildversion);\n\tdprintk(1, \"*** HW: V%d.%d, FW: V %d.%d.%d\\n\",\n\t\thw_majorversion, hw_minorversion,\n\t\tfw_majorversion, fw_minorversion, fw_buildversion);\n\n\txc_get_hsync_freq(priv,  &hsync_freq_hz);\n\tdprintk(1, \"*** Horizontal sync frequency = %d Hz\\n\", hsync_freq_hz);\n\n\txc_get_frame_lines(priv,  &frame_lines);\n\tdprintk(1, \"*** Frame lines = %d\\n\", frame_lines);\n\n\txc_get_quality(priv,  &quality);\n\tdprintk(1, \"*** Quality (0:<8dB, 7:>56dB) = %d\\n\", quality & 0x07);\n\n\txc_get_analogsnr(priv,  &snr);\n\tdprintk(1, \"*** Unweighted analog SNR = %d dB\\n\", snr & 0x3f);\n\n\txc_get_totalgain(priv,  &totalgain);\n\tdprintk(1, \"*** Total gain = %d.%d dB\\n\", totalgain / 256,\n\t\t(totalgain % 256) * 100 / 256);\n\n\tif (priv->pll_register_no) {\n\t\tif (!xc5000_readreg(priv, priv->pll_register_no, &regval))\n\t\t\tdprintk(1, \"*** PLL lock status = 0x%04x\\n\", regval);\n\t}\n}\n\nstatic int xc5000_tune_digital(struct dvb_frontend *fe)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\tint ret;\n\tu32 bw = fe->dtv_property_cache.bandwidth_hz;\n\n\tret = xc_set_signal_source(priv, priv->rf_mode);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR\n\t\t\t\"xc5000: xc_set_signal_source(%d) failed\\n\",\n\t\t\tpriv->rf_mode);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tret = xc_set_tv_standard(priv,\n\t\txc5000_standard[priv->video_standard].video_mode,\n\t\txc5000_standard[priv->video_standard].audio_mode, 0);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"xc5000: xc_set_tv_standard failed\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\tret = xc_set_IF_frequency(priv, priv->if_khz);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"xc5000: xc_Set_IF_frequency(%d) failed\\n\",\n\t\t       priv->if_khz);\n\t\treturn -EIO;\n\t}\n\n\tdprintk(1, \"%s() setting OUTPUT_AMP to 0x%x\\n\",\n\t\t__func__, priv->output_amp);\n\txc_write_reg(priv, XREG_OUTPUT_AMP, priv->output_amp);\n\n\txc_tune_channel(priv, priv->freq_hz, XC_TUNE_DIGITAL);\n\n\tif (debug)\n\t\txc_debug_dump(priv);\n\n\tpriv->bandwidth = bw;\n\n\treturn 0;\n}\n\nstatic int xc5000_set_digital_params(struct dvb_frontend *fe)\n{\n\tint b;\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\tu32 bw = fe->dtv_property_cache.bandwidth_hz;\n\tu32 freq = fe->dtv_property_cache.frequency;\n\tu32 delsys  = fe->dtv_property_cache.delivery_system;\n\n\tif (xc_load_fw_and_init_tuner(fe, 0) != 0) {\n\t\tdprintk(1, \"Unable to load firmware and init tuner\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdprintk(1, \"%s() frequency=%d (Hz)\\n\", __func__, freq);\n\n\tswitch (delsys) {\n\tcase SYS_ATSC:\n\t\tdprintk(1, \"%s() VSB modulation\\n\", __func__);\n\t\tpriv->rf_mode = XC_RF_MODE_AIR;\n\t\tpriv->freq_offset = 1750000;\n\t\tpriv->video_standard = DTV6;\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_B:\n\t\tdprintk(1, \"%s() QAM modulation\\n\", __func__);\n\t\tpriv->rf_mode = XC_RF_MODE_CABLE;\n\t\tpriv->freq_offset = 1750000;\n\t\tpriv->video_standard = DTV6;\n\t\tbreak;\n\tcase SYS_ISDBT:\n\t\t \n\t\tif (!bw)\n\t\t\tbw = 6000000;\n\t\t \n\t\tfallthrough;\n\tcase SYS_DMBTH:\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tdprintk(1, \"%s() OFDM\\n\", __func__);\n\t\tswitch (bw) {\n\t\tcase 6000000:\n\t\t\tpriv->video_standard = DTV6;\n\t\t\tpriv->freq_offset = 1750000;\n\t\t\tbreak;\n\t\tcase 7000000:\n\t\t\tpriv->video_standard = DTV7;\n\t\t\tpriv->freq_offset = 2250000;\n\t\t\tbreak;\n\t\tcase 8000000:\n\t\t\tpriv->video_standard = DTV8;\n\t\t\tpriv->freq_offset = 2750000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"xc5000 bandwidth not set!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpriv->rf_mode = XC_RF_MODE_AIR;\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\tcase SYS_DVBC_ANNEX_C:\n\t\tdprintk(1, \"%s() QAM modulation\\n\", __func__);\n\t\tpriv->rf_mode = XC_RF_MODE_CABLE;\n\t\tif (bw <= 6000000) {\n\t\t\tpriv->video_standard = DTV6;\n\t\t\tpriv->freq_offset = 1750000;\n\t\t\tb = 6;\n\t\t} else if (bw <= 7000000) {\n\t\t\tpriv->video_standard = DTV7;\n\t\t\tpriv->freq_offset = 2250000;\n\t\t\tb = 7;\n\t\t} else {\n\t\t\tpriv->video_standard = DTV7_8;\n\t\t\tpriv->freq_offset = 2750000;\n\t\t\tb = 8;\n\t\t}\n\t\tdprintk(1, \"%s() Bandwidth %dMHz (%d)\\n\", __func__,\n\t\t\tb, bw);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"xc5000: delivery system is not supported!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->freq_hz = freq - priv->freq_offset;\n\tpriv->mode = V4L2_TUNER_DIGITAL_TV;\n\n\tdprintk(1, \"%s() frequency=%d (compensated to %d)\\n\",\n\t\t__func__, freq, priv->freq_hz);\n\n\treturn xc5000_tune_digital(fe);\n}\n\nstatic int xc5000_is_firmware_loaded(struct dvb_frontend *fe)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\tint ret;\n\tu16 id;\n\n\tret = xc5000_readreg(priv, XREG_PRODUCT_ID, &id);\n\tif (!ret) {\n\t\tif (id == XC_PRODUCT_ID_FW_NOT_LOADED)\n\t\t\tret = -ENOENT;\n\t\telse\n\t\t\tret = 0;\n\t\tdprintk(1, \"%s() returns id = 0x%x\\n\", __func__, id);\n\t} else {\n\t\tdprintk(1, \"%s() returns error %d\\n\", __func__, ret);\n\t}\n\n\treturn ret;\n}\n\nstatic void xc5000_config_tv(struct dvb_frontend *fe,\n\t\t\t     struct analog_parameters *params)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\n\tdprintk(1, \"%s() frequency=%d (in units of 62.5khz)\\n\",\n\t\t__func__, params->frequency);\n\n\t \n\tpriv->rf_mode = params->mode;\n\tif (params->mode > XC_RF_MODE_CABLE)\n\t\tpriv->rf_mode = XC_RF_MODE_CABLE;\n\n\t \n\tpriv->freq_hz = params->frequency * 62500;\n\n\t \n\tif (params->std & V4L2_STD_MN) {\n\t\t \n\t\tpriv->video_standard = MN_NTSC_PAL_BTSC;\n\t\treturn;\n\t}\n\n\tif (params->std & V4L2_STD_PAL_BG) {\n\t\t \n\t\tpriv->video_standard = BG_PAL_NICAM;\n\t\treturn;\n\t}\n\n\tif (params->std & V4L2_STD_PAL_I) {\n\t\t \n\t\tpriv->video_standard = I_PAL_NICAM;\n\t\treturn;\n\t}\n\n\tif (params->std & V4L2_STD_PAL_DK) {\n\t\t \n\t\tpriv->video_standard = DK_PAL_NICAM;\n\t\treturn;\n\t}\n\n\tif (params->std & V4L2_STD_SECAM_DK) {\n\t\t \n\t\tpriv->video_standard = DK_SECAM_A2DK1;\n\t\treturn;\n\t}\n\n\tif (params->std & V4L2_STD_SECAM_L) {\n\t\tpriv->video_standard = L_SECAM_NICAM;\n\t\treturn;\n\t}\n\n\tif (params->std & V4L2_STD_SECAM_LC) {\n\t\tpriv->video_standard = LC_SECAM_NICAM;\n\t\treturn;\n\t}\n}\n\nstatic int xc5000_set_tv_freq(struct dvb_frontend *fe)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\tu16 pll_lock_status;\n\tint ret;\n\ntune_channel:\n\tret = xc_set_signal_source(priv, priv->rf_mode);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR\n\t\t\t\"xc5000: xc_set_signal_source(%d) failed\\n\",\n\t\t\tpriv->rf_mode);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tret = xc_set_tv_standard(priv,\n\t\txc5000_standard[priv->video_standard].video_mode,\n\t\txc5000_standard[priv->video_standard].audio_mode, 0);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"xc5000: xc_set_tv_standard failed\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\txc_write_reg(priv, XREG_OUTPUT_AMP, 0x09);\n\n\txc_tune_channel(priv, priv->freq_hz, XC_TUNE_ANALOG);\n\n\tif (debug)\n\t\txc_debug_dump(priv);\n\n\tif (priv->pll_register_no != 0) {\n\t\tmsleep(20);\n\t\tret = xc5000_readreg(priv, priv->pll_register_no,\n\t\t\t\t     &pll_lock_status);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (pll_lock_status > 63) {\n\t\t\t \n\t\t\tdprintk(1, \"xc5000: PLL not locked (0x%x).  Reloading...\\n\",\n\t\t\t\tpll_lock_status);\n\t\t\tif (xc_load_fw_and_init_tuner(fe, 1) != 0) {\n\t\t\t\tprintk(KERN_ERR \"xc5000: Unable to reload fw\\n\");\n\t\t\t\treturn -EREMOTEIO;\n\t\t\t}\n\t\t\tgoto tune_channel;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int xc5000_config_radio(struct dvb_frontend *fe,\n\t\t\t       struct analog_parameters *params)\n\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\n\tdprintk(1, \"%s() frequency=%d (in units of khz)\\n\",\n\t\t__func__, params->frequency);\n\n\tif (priv->radio_input == XC5000_RADIO_NOT_CONFIGURED) {\n\t\tdprintk(1, \"%s() radio input not configured\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->freq_hz = params->frequency * 125 / 2;\n\tpriv->rf_mode = XC_RF_MODE_AIR;\n\n\treturn 0;\n}\n\nstatic int xc5000_set_radio_freq(struct dvb_frontend *fe)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\tint ret;\n\tu8 radio_input;\n\n\tif (priv->radio_input == XC5000_RADIO_FM1)\n\t\tradio_input = FM_RADIO_INPUT1;\n\telse if  (priv->radio_input == XC5000_RADIO_FM2)\n\t\tradio_input = FM_RADIO_INPUT2;\n\telse if  (priv->radio_input == XC5000_RADIO_FM1_MONO)\n\t\tradio_input = FM_RADIO_INPUT1_MONO;\n\telse {\n\t\tdprintk(1, \"%s() unknown radio input %d\\n\", __func__,\n\t\t\tpriv->radio_input);\n\t\treturn -EINVAL;\n\t}\n\n\tret = xc_set_tv_standard(priv, xc5000_standard[radio_input].video_mode,\n\t\t\t       xc5000_standard[radio_input].audio_mode, radio_input);\n\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"xc5000: xc_set_tv_standard failed\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\tret = xc_set_signal_source(priv, priv->rf_mode);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR\n\t\t\t\"xc5000: xc_set_signal_source(%d) failed\\n\",\n\t\t\tpriv->rf_mode);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tif ((priv->radio_input == XC5000_RADIO_FM1) ||\n\t\t\t\t(priv->radio_input == XC5000_RADIO_FM2))\n\t\txc_write_reg(priv, XREG_OUTPUT_AMP, 0x09);\n\telse if  (priv->radio_input == XC5000_RADIO_FM1_MONO)\n\t\txc_write_reg(priv, XREG_OUTPUT_AMP, 0x06);\n\n\txc_tune_channel(priv, priv->freq_hz, XC_TUNE_ANALOG);\n\n\treturn 0;\n}\n\nstatic int xc5000_set_params(struct dvb_frontend *fe)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\n\tif (xc_load_fw_and_init_tuner(fe, 0) != 0) {\n\t\tdprintk(1, \"Unable to load firmware and init tuner\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (priv->mode) {\n\tcase V4L2_TUNER_RADIO:\n\t\treturn xc5000_set_radio_freq(fe);\n\tcase V4L2_TUNER_ANALOG_TV:\n\t\treturn xc5000_set_tv_freq(fe);\n\tcase V4L2_TUNER_DIGITAL_TV:\n\t\treturn xc5000_tune_digital(fe);\n\t}\n\n\treturn 0;\n}\n\nstatic int xc5000_set_analog_params(struct dvb_frontend *fe,\n\t\t\t     struct analog_parameters *params)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\tint ret;\n\n\tif (priv->i2c_props.adap == NULL)\n\t\treturn -EINVAL;\n\n\tswitch (params->mode) {\n\tcase V4L2_TUNER_RADIO:\n\t\tret = xc5000_config_radio(fe, params);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase V4L2_TUNER_ANALOG_TV:\n\t\txc5000_config_tv(fe, params);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tpriv->mode = params->mode;\n\n\treturn xc5000_set_params(fe);\n}\n\nstatic int xc5000_get_frequency(struct dvb_frontend *fe, u32 *freq)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\tdprintk(1, \"%s()\\n\", __func__);\n\t*freq = priv->freq_hz + priv->freq_offset;\n\treturn 0;\n}\n\nstatic int xc5000_get_if_frequency(struct dvb_frontend *fe, u32 *freq)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\tdprintk(1, \"%s()\\n\", __func__);\n\t*freq = priv->if_khz * 1000;\n\treturn 0;\n}\n\nstatic int xc5000_get_bandwidth(struct dvb_frontend *fe, u32 *bw)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t*bw = priv->bandwidth;\n\treturn 0;\n}\n\nstatic int xc5000_get_status(struct dvb_frontend *fe, u32 *status)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\tu16 lock_status = 0;\n\n\txc_get_lock_status(priv, &lock_status);\n\n\tdprintk(1, \"%s() lock_status = 0x%08x\\n\", __func__, lock_status);\n\n\t*status = lock_status;\n\n\treturn 0;\n}\n\nstatic int xc_load_fw_and_init_tuner(struct dvb_frontend *fe, int force)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\tconst struct xc5000_fw_cfg *desired_fw = xc5000_assign_firmware(priv->chip_id);\n\tconst struct firmware *fw;\n\tint ret, i;\n\tu16 pll_lock_status;\n\tu16 fw_ck;\n\n\tcancel_delayed_work(&priv->timer_sleep);\n\n\tif (!force && xc5000_is_firmware_loaded(fe) == 0)\n\t\treturn 0;\n\n\tif (!priv->firmware) {\n\t\tret = request_firmware(&fw, desired_fw->name,\n\t\t\t\t\tpriv->i2c_props.adap->dev.parent);\n\t\tif (ret) {\n\t\t\tpr_err(\"xc5000: Upload failed. rc %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdprintk(1, \"firmware read %zu bytes.\\n\", fw->size);\n\n\t\tif (fw->size != desired_fw->size) {\n\t\t\tpr_err(\"xc5000: Firmware file with incorrect size\\n\");\n\t\t\trelease_firmware(fw);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpriv->firmware = fw;\n\t} else\n\t\tfw = priv->firmware;\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\tif (i)\n\t\t\tprintk(KERN_CONT \" - retrying to upload firmware.\\n\");\n\n\t\tret = xc5000_fwupload(fe, desired_fw, fw);\n\t\tif (ret != 0)\n\t\t\tgoto err;\n\n\t\tmsleep(20);\n\n\t\tif (priv->fw_checksum_supported) {\n\t\t\tif (xc5000_readreg(priv, XREG_FW_CHECKSUM, &fw_ck)) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"xc5000: FW checksum reading failed.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!fw_ck) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"xc5000: FW checksum failed = 0x%04x.\",\n\t\t\t\t       fw_ck);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tret = xc_initialize(priv);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR \"xc5000: Can't request self-calibration.\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmsleep(100);\n\n\t\tif (priv->init_status_supported) {\n\t\t\tif (xc5000_readreg(priv, XREG_INIT_STATUS, &fw_ck)) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"xc5000: FW failed reading init status.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!fw_ck) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"xc5000: FW init status failed = 0x%04x.\",\n\t\t\t\t       fw_ck);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (priv->pll_register_no) {\n\t\t\tret = xc5000_readreg(priv, priv->pll_register_no,\n\t\t\t\t\t     &pll_lock_status);\n\t\t\tif (ret)\n\t\t\t\tcontinue;\n\t\t\tif (pll_lock_status > 63) {\n\t\t\t\t \n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"xc5000: PLL not running after fwload.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tret = xc_write_reg(priv, XREG_SIGNALSOURCE, XC_RF_MODE_CABLE);\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tprintk(KERN_ERR \"xc5000: can't set to cable mode.\");\n\t}\n\nerr:\n\tif (!ret)\n\t\tprintk(KERN_INFO \"xc5000: Firmware %s loaded and running.\\n\",\n\t\t       desired_fw->name);\n\telse\n\t\tprintk(KERN_CONT \" - too many retries. Giving up\\n\");\n\n\treturn ret;\n}\n\nstatic void xc5000_do_timer_sleep(struct work_struct *timer_sleep)\n{\n\tstruct xc5000_priv *priv =container_of(timer_sleep, struct xc5000_priv,\n\t\t\t\t\t       timer_sleep.work);\n\tstruct dvb_frontend *fe = priv->fe;\n\tint ret;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t \n\tret = xc5000_tuner_reset(fe);\n\tif (ret != 0)\n\t\tprintk(KERN_ERR\n\t\t\t\"xc5000: %s() unable to shutdown tuner\\n\",\n\t\t\t__func__);\n}\n\nstatic int xc5000_sleep(struct dvb_frontend *fe)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t \n\tif (no_poweroff)\n\t\treturn 0;\n\n\tschedule_delayed_work(&priv->timer_sleep,\n\t\t\t      msecs_to_jiffies(XC5000_SLEEP_TIME));\n\n\treturn 0;\n}\n\nstatic int xc5000_suspend(struct dvb_frontend *fe)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\tint ret;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tcancel_delayed_work(&priv->timer_sleep);\n\n\tret = xc5000_tuner_reset(fe);\n\tif (ret != 0)\n\t\tprintk(KERN_ERR\n\t\t\t\"xc5000: %s() unable to shutdown tuner\\n\",\n\t\t\t__func__);\n\n\treturn 0;\n}\n\nstatic int xc5000_resume(struct dvb_frontend *fe)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t \n\tif (!priv->firmware)\n\t\treturn 0;\n\n\treturn xc5000_set_params(fe);\n}\n\nstatic int xc5000_init(struct dvb_frontend *fe)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tif (xc_load_fw_and_init_tuner(fe, 0) != 0) {\n\t\tprintk(KERN_ERR \"xc5000: Unable to initialise tuner\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\tif (debug)\n\t\txc_debug_dump(priv);\n\n\treturn 0;\n}\n\nstatic void xc5000_release(struct dvb_frontend *fe)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tmutex_lock(&xc5000_list_mutex);\n\n\tif (priv) {\n\t\tcancel_delayed_work(&priv->timer_sleep);\n\t\tif (priv->firmware) {\n\t\t\trelease_firmware(priv->firmware);\n\t\t\tpriv->firmware = NULL;\n\t\t}\n\t\thybrid_tuner_release_state(priv);\n\t}\n\n\tmutex_unlock(&xc5000_list_mutex);\n\n\tfe->tuner_priv = NULL;\n}\n\nstatic int xc5000_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct xc5000_priv *priv = fe->tuner_priv;\n\tstruct xc5000_config *p = priv_cfg;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tif (p->if_khz)\n\t\tpriv->if_khz = p->if_khz;\n\n\tif (p->radio_input)\n\t\tpriv->radio_input = p->radio_input;\n\n\tif (p->output_amp)\n\t\tpriv->output_amp = p->output_amp;\n\n\treturn 0;\n}\n\n\nstatic const struct dvb_tuner_ops xc5000_tuner_ops = {\n\t.info = {\n\t\t.name              = \"Xceive XC5000\",\n\t\t.frequency_min_hz  =    1 * MHz,\n\t\t.frequency_max_hz  = 1023 * MHz,\n\t\t.frequency_step_hz =   50 * kHz,\n\t},\n\n\t.release\t   = xc5000_release,\n\t.init\t\t   = xc5000_init,\n\t.sleep\t\t   = xc5000_sleep,\n\t.suspend\t   = xc5000_suspend,\n\t.resume\t\t   = xc5000_resume,\n\n\t.set_config\t   = xc5000_set_config,\n\t.set_params\t   = xc5000_set_digital_params,\n\t.set_analog_params = xc5000_set_analog_params,\n\t.get_frequency\t   = xc5000_get_frequency,\n\t.get_if_frequency  = xc5000_get_if_frequency,\n\t.get_bandwidth\t   = xc5000_get_bandwidth,\n\t.get_status\t   = xc5000_get_status\n};\n\nstruct dvb_frontend *xc5000_attach(struct dvb_frontend *fe,\n\t\t\t\t   struct i2c_adapter *i2c,\n\t\t\t\t   const struct xc5000_config *cfg)\n{\n\tstruct xc5000_priv *priv = NULL;\n\tint instance;\n\tu16 id = 0;\n\n\tdprintk(1, \"%s(%d-%04x)\\n\", __func__,\n\t\ti2c ? i2c_adapter_id(i2c) : -1,\n\t\tcfg ? cfg->i2c_address : -1);\n\n\tmutex_lock(&xc5000_list_mutex);\n\n\tinstance = hybrid_tuner_request_state(struct xc5000_priv, priv,\n\t\t\t\t\t      hybrid_tuner_instance_list,\n\t\t\t\t\t      i2c, cfg->i2c_address, \"xc5000\");\n\tswitch (instance) {\n\tcase 0:\n\t\tgoto fail;\n\tcase 1:\n\t\t \n\t\tpriv->bandwidth = 6000000;\n\t\tfe->tuner_priv = priv;\n\t\tpriv->fe = fe;\n\t\tINIT_DELAYED_WORK(&priv->timer_sleep, xc5000_do_timer_sleep);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tfe->tuner_priv = priv;\n\t\tbreak;\n\t}\n\n\tif (priv->if_khz == 0) {\n\t\t \n\t\tpriv->if_khz = cfg->if_khz;\n\t}\n\n\tif (priv->xtal_khz == 0)\n\t\tpriv->xtal_khz = cfg->xtal_khz;\n\n\tif (priv->radio_input == 0)\n\t\tpriv->radio_input = cfg->radio_input;\n\n\t \n\tif ((priv->chip_id == 0) || (cfg->chip_id))\n\t\t \n\t\tpriv->chip_id = (cfg->chip_id) ? cfg->chip_id : 0;\n\n\t \n\tif ((priv->output_amp == 0) || (cfg->output_amp))\n\t\t \n\t\tpriv->output_amp = (cfg->output_amp) ? cfg->output_amp : 0x8a;\n\n\t \n\tif (xc5000_readreg(priv, XREG_PRODUCT_ID, &id) != 0)\n\t\tgoto fail;\n\n\tswitch (id) {\n\tcase XC_PRODUCT_ID_FW_LOADED:\n\t\tprintk(KERN_INFO\n\t\t\t\"xc5000: Successfully identified at address 0x%02x\\n\",\n\t\t\tcfg->i2c_address);\n\t\tprintk(KERN_INFO\n\t\t\t\"xc5000: Firmware has been loaded previously\\n\");\n\t\tbreak;\n\tcase XC_PRODUCT_ID_FW_NOT_LOADED:\n\t\tprintk(KERN_INFO\n\t\t\t\"xc5000: Successfully identified at address 0x%02x\\n\",\n\t\t\tcfg->i2c_address);\n\t\tprintk(KERN_INFO\n\t\t\t\"xc5000: Firmware has not been loaded previously\\n\");\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR\n\t\t\t\"xc5000: Device not found at addr 0x%02x (0x%x)\\n\",\n\t\t\tcfg->i2c_address, id);\n\t\tgoto fail;\n\t}\n\n\tmutex_unlock(&xc5000_list_mutex);\n\n\tmemcpy(&fe->ops.tuner_ops, &xc5000_tuner_ops,\n\t\tsizeof(struct dvb_tuner_ops));\n\n\treturn fe;\nfail:\n\tmutex_unlock(&xc5000_list_mutex);\n\n\txc5000_release(fe);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(xc5000_attach);\n\nMODULE_AUTHOR(\"Steven Toth\");\nMODULE_DESCRIPTION(\"Xceive xc5000 silicon tuner driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(XC5000A_FIRMWARE);\nMODULE_FIRMWARE(XC5000C_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}