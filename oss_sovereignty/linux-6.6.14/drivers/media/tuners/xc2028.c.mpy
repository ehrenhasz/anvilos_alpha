{
  "module_name": "xc2028.c",
  "hash_id": "939ff4c0671c89435f8b694d25ae1b54c43c17ce2cd1b63ba89369d2debcfc04",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/xc2028.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/i2c.h>\n#include <asm/div64.h>\n#include <linux/firmware.h>\n#include <linux/videodev2.h>\n#include <linux/delay.h>\n#include <media/tuner.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n#include \"tuner-i2c.h\"\n#include \"xc2028.h\"\n#include \"xc2028-types.h\"\n\n#include <linux/dvb/frontend.h>\n#include <media/dvb_frontend.h>\n\n \n#define MAX_XFER_SIZE  80\n\n \n#define XREG_INIT         0x00\n#define XREG_RF_FREQ      0x02\n#define XREG_POWER_DOWN   0x08\n\n \n#define XREG_FREQ_ERROR   0x01\n#define XREG_LOCK         0x02\n#define XREG_VERSION      0x04\n#define XREG_PRODUCT_ID   0x08\n#define XREG_HSYNC_FREQ   0x10\n#define XREG_FRAME_LINES  0x20\n#define XREG_SNR          0x40\n\n#define XREG_ADC_ENV      0x0100\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable verbose debug messages\");\n\nstatic int no_poweroff;\nmodule_param(no_poweroff, int, 0644);\nMODULE_PARM_DESC(no_poweroff, \"0 (default) powers device off when not used.\\n\"\n\t\"1 keep device energized and with tuner ready all the times.\\n\"\n\t\"  Faster, but consumes more power and keeps the device hotter\\n\");\n\nstatic char audio_std[8];\nmodule_param_string(audio_std, audio_std, sizeof(audio_std), 0);\nMODULE_PARM_DESC(audio_std,\n\t\"Audio standard. XC3028 audio decoder explicitly needs to know what audio\\n\"\n\t\"standard is needed for some video standards with audio A2 or NICAM.\\n\"\n\t\"The valid values are:\\n\"\n\t\"A2\\n\"\n\t\"A2/A\\n\"\n\t\"A2/B\\n\"\n\t\"NICAM\\n\"\n\t\"NICAM/A\\n\"\n\t\"NICAM/B\\n\");\n\nstatic char firmware_name[30];\nmodule_param_string(firmware_name, firmware_name, sizeof(firmware_name), 0);\nMODULE_PARM_DESC(firmware_name,\n\t\t \"Firmware file name. Allows overriding the default firmware name\\n\");\n\nstatic LIST_HEAD(hybrid_tuner_instance_list);\nstatic DEFINE_MUTEX(xc2028_list_mutex);\n\n \nstruct firmware_description {\n\tunsigned int  type;\n\tv4l2_std_id   id;\n\t__u16         int_freq;\n\tunsigned char *ptr;\n\tunsigned int  size;\n};\n\nstruct firmware_properties {\n\tunsigned int\ttype;\n\tv4l2_std_id\tid;\n\tv4l2_std_id\tstd_req;\n\t__u16\t\tint_freq;\n\tunsigned int\tscode_table;\n\tint\t\tscode_nr;\n};\n\nenum xc2028_state {\n\tXC2028_NO_FIRMWARE = 0,\n\tXC2028_WAITING_FIRMWARE,\n\tXC2028_ACTIVE,\n\tXC2028_SLEEP,\n\tXC2028_NODEV,\n};\n\nstruct xc2028_data {\n\tstruct list_head        hybrid_tuner_instance_list;\n\tstruct tuner_i2c_props  i2c_props;\n\t__u32\t\t\tfrequency;\n\n\tenum xc2028_state\tstate;\n\tconst char\t\t*fname;\n\n\tstruct firmware_description *firm;\n\tint\t\t\tfirm_size;\n\t__u16\t\t\tfirm_version;\n\n\t__u16\t\t\thwmodel;\n\t__u16\t\t\thwvers;\n\n\tstruct xc2028_ctrl\tctrl;\n\n\tstruct firmware_properties cur_fw;\n\n\tstruct mutex lock;\n};\n\n#define i2c_send(priv, buf, size) ({\t\t\t\t\t\\\n\tint _rc;\t\t\t\t\t\t\t\\\n\t_rc = tuner_i2c_xfer_send(&priv->i2c_props, buf, size);\t\t\\\n\tif (size != _rc)\t\t\t\t\t\t\\\n\t\ttuner_info(\"i2c output error: rc = %d (should be %d)\\n\",\\\n\t\t\t   _rc, (int)size);\t\t\t\t\\\n\tif (priv->ctrl.msleep)\t\t\t\t\t\t\\\n\t\tmsleep(priv->ctrl.msleep);\t\t\t\t\\\n\t_rc;\t\t\t\t\t\t\t\t\\\n})\n\n#define i2c_send_recv(priv, obuf, osize, ibuf, isize) ({\t\t\\\n\tint _rc;\t\t\t\t\t\t\t\\\n\t_rc = tuner_i2c_xfer_send_recv(&priv->i2c_props, obuf, osize,\t\\\n\t\t\t\t       ibuf, isize);\t\t\t\\\n\tif (isize != _rc)\t\t\t\t\t\t\\\n\t\ttuner_err(\"i2c input error: rc = %d (should be %d)\\n\",\t\\\n\t\t\t   _rc, (int)isize);\t\t\t\t\\\n\tif (priv->ctrl.msleep)\t\t\t\t\t\t\\\n\t\tmsleep(priv->ctrl.msleep);\t\t\t\t\\\n\t_rc;\t\t\t\t\t\t\t\t\\\n})\n\n#define send_seq(priv, data...)\t({\t\t\t\t\t\\\n\tstatic u8 _val[] = data;\t\t\t\t\t\\\n\tint _rc;\t\t\t\t\t\t\t\\\n\tif (sizeof(_val) !=\t\t\t\t\t\t\\\n\t\t\t(_rc = tuner_i2c_xfer_send(&priv->i2c_props,\t\\\n\t\t\t\t\t\t_val, sizeof(_val)))) {\t\\\n\t\ttuner_err(\"Error on line %d: %d\\n\", __LINE__, _rc);\t\\\n\t} else if (priv->ctrl.msleep)\t\t\t\t\t\\\n\t\tmsleep(priv->ctrl.msleep);\t\t\t\t\\\n\t_rc;\t\t\t\t\t\t\t\t\\\n})\n\nstatic int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)\n{\n\tunsigned char buf[2];\n\tunsigned char ibuf[2];\n\n\ttuner_dbg(\"%s %04x called\\n\", __func__, reg);\n\n\tbuf[0] = reg >> 8;\n\tbuf[1] = (unsigned char) reg;\n\n\tif (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)\n\t\treturn -EIO;\n\n\t*val = (ibuf[1]) | (ibuf[0] << 8);\n\treturn 0;\n}\n\n#define dump_firm_type(t)\tdump_firm_type_and_int_freq(t, 0)\nstatic void dump_firm_type_and_int_freq(unsigned int type, u16 int_freq)\n{\n\tif (type & BASE)\n\t\tprintk(KERN_CONT \"BASE \");\n\tif (type & INIT1)\n\t\tprintk(KERN_CONT \"INIT1 \");\n\tif (type & F8MHZ)\n\t\tprintk(KERN_CONT \"F8MHZ \");\n\tif (type & MTS)\n\t\tprintk(KERN_CONT \"MTS \");\n\tif (type & D2620)\n\t\tprintk(KERN_CONT \"D2620 \");\n\tif (type & D2633)\n\t\tprintk(KERN_CONT \"D2633 \");\n\tif (type & DTV6)\n\t\tprintk(KERN_CONT \"DTV6 \");\n\tif (type & QAM)\n\t\tprintk(KERN_CONT \"QAM \");\n\tif (type & DTV7)\n\t\tprintk(KERN_CONT \"DTV7 \");\n\tif (type & DTV78)\n\t\tprintk(KERN_CONT \"DTV78 \");\n\tif (type & DTV8)\n\t\tprintk(KERN_CONT \"DTV8 \");\n\tif (type & FM)\n\t\tprintk(KERN_CONT \"FM \");\n\tif (type & INPUT1)\n\t\tprintk(KERN_CONT \"INPUT1 \");\n\tif (type & LCD)\n\t\tprintk(KERN_CONT \"LCD \");\n\tif (type & NOGD)\n\t\tprintk(KERN_CONT \"NOGD \");\n\tif (type & MONO)\n\t\tprintk(KERN_CONT \"MONO \");\n\tif (type & ATSC)\n\t\tprintk(KERN_CONT \"ATSC \");\n\tif (type & IF)\n\t\tprintk(KERN_CONT \"IF \");\n\tif (type & LG60)\n\t\tprintk(KERN_CONT \"LG60 \");\n\tif (type & ATI638)\n\t\tprintk(KERN_CONT \"ATI638 \");\n\tif (type & OREN538)\n\t\tprintk(KERN_CONT \"OREN538 \");\n\tif (type & OREN36)\n\t\tprintk(KERN_CONT \"OREN36 \");\n\tif (type & TOYOTA388)\n\t\tprintk(KERN_CONT \"TOYOTA388 \");\n\tif (type & TOYOTA794)\n\t\tprintk(KERN_CONT \"TOYOTA794 \");\n\tif (type & DIBCOM52)\n\t\tprintk(KERN_CONT \"DIBCOM52 \");\n\tif (type & ZARLINK456)\n\t\tprintk(KERN_CONT \"ZARLINK456 \");\n\tif (type & CHINA)\n\t\tprintk(KERN_CONT \"CHINA \");\n\tif (type & F6MHZ)\n\t\tprintk(KERN_CONT \"F6MHZ \");\n\tif (type & INPUT2)\n\t\tprintk(KERN_CONT \"INPUT2 \");\n\tif (type & SCODE)\n\t\tprintk(KERN_CONT \"SCODE \");\n\tif (type & HAS_IF)\n\t\tprintk(KERN_CONT \"HAS_IF_%d \", int_freq);\n}\n\nstatic  v4l2_std_id parse_audio_std_option(void)\n{\n\tif (strcasecmp(audio_std, \"A2\") == 0)\n\t\treturn V4L2_STD_A2;\n\tif (strcasecmp(audio_std, \"A2/A\") == 0)\n\t\treturn V4L2_STD_A2_A;\n\tif (strcasecmp(audio_std, \"A2/B\") == 0)\n\t\treturn V4L2_STD_A2_B;\n\tif (strcasecmp(audio_std, \"NICAM\") == 0)\n\t\treturn V4L2_STD_NICAM;\n\tif (strcasecmp(audio_std, \"NICAM/A\") == 0)\n\t\treturn V4L2_STD_NICAM_A;\n\tif (strcasecmp(audio_std, \"NICAM/B\") == 0)\n\t\treturn V4L2_STD_NICAM_B;\n\n\treturn 0;\n}\n\nstatic int check_device_status(struct xc2028_data *priv)\n{\n\tswitch (priv->state) {\n\tcase XC2028_NO_FIRMWARE:\n\tcase XC2028_WAITING_FIRMWARE:\n\t\treturn -EAGAIN;\n\tcase XC2028_ACTIVE:\n\t\treturn 1;\n\tcase XC2028_SLEEP:\n\t\treturn 0;\n\tcase XC2028_NODEV:\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic void free_firmware(struct xc2028_data *priv)\n{\n\tint i;\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\t \n\tif (priv->fname != firmware_name)\n\t\tkfree(priv->fname);\n\tpriv->fname = NULL;\n\n\tpriv->state = XC2028_NO_FIRMWARE;\n\tmemset(&priv->cur_fw, 0, sizeof(priv->cur_fw));\n\n\tif (!priv->firm)\n\t\treturn;\n\n\tfor (i = 0; i < priv->firm_size; i++)\n\t\tkfree(priv->firm[i].ptr);\n\n\tkfree(priv->firm);\n\n\tpriv->firm = NULL;\n\tpriv->firm_size = 0;\n}\n\nstatic int load_all_firmwares(struct dvb_frontend *fe,\n\t\t\t      const struct firmware *fw)\n{\n\tstruct xc2028_data    *priv = fe->tuner_priv;\n\tconst unsigned char   *p, *endp;\n\tint                   rc = 0;\n\tint\t\t      n, n_array;\n\tchar\t\t      name[33];\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tp = fw->data;\n\tendp = p + fw->size;\n\n\tif (fw->size < sizeof(name) - 1 + 2 + 2) {\n\t\ttuner_err(\"Error: firmware file %s has invalid size!\\n\",\n\t\t\t  priv->fname);\n\t\tgoto corrupt;\n\t}\n\n\tmemcpy(name, p, sizeof(name) - 1);\n\tname[sizeof(name) - 1] = 0;\n\tp += sizeof(name) - 1;\n\n\tpriv->firm_version = get_unaligned_le16(p);\n\tp += 2;\n\n\tn_array = get_unaligned_le16(p);\n\tp += 2;\n\n\ttuner_info(\"Loading %d firmware images from %s, type: %s, ver %d.%d\\n\",\n\t\t   n_array, priv->fname, name,\n\t\t   priv->firm_version >> 8, priv->firm_version & 0xff);\n\n\tpriv->firm = kcalloc(n_array, sizeof(*priv->firm), GFP_KERNEL);\n\tif (priv->firm == NULL) {\n\t\ttuner_err(\"Not enough memory to load firmware file.\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\tpriv->firm_size = n_array;\n\n\tn = -1;\n\twhile (p < endp) {\n\t\t__u32 type, size;\n\t\tv4l2_std_id id;\n\t\t__u16 int_freq = 0;\n\n\t\tn++;\n\t\tif (n >= n_array) {\n\t\t\ttuner_err(\"More firmware images in file than were expected!\\n\");\n\t\t\tgoto corrupt;\n\t\t}\n\n\t\t \n\t\tif (endp - p < sizeof(type) + sizeof(id) + sizeof(size))\n\t\t\tgoto header;\n\n\t\ttype = get_unaligned_le32(p);\n\t\tp += sizeof(type);\n\n\t\tid = get_unaligned_le64(p);\n\t\tp += sizeof(id);\n\n\t\tif (type & HAS_IF) {\n\t\t\tint_freq = get_unaligned_le16(p);\n\t\t\tp += sizeof(int_freq);\n\t\t\tif (endp - p < sizeof(size))\n\t\t\t\tgoto header;\n\t\t}\n\n\t\tsize = get_unaligned_le32(p);\n\t\tp += sizeof(size);\n\n\t\tif (!size || size > endp - p) {\n\t\t\ttuner_err(\"Firmware type \");\n\t\t\tdump_firm_type(type);\n\t\t\tprintk(KERN_CONT\n\t\t\t       \"(%x), id %llx is corrupted (size=%zd, expected %d)\\n\",\n\t\t\t       type, (unsigned long long)id, (endp - p), size);\n\t\t\tgoto corrupt;\n\t\t}\n\n\t\tpriv->firm[n].ptr = kmemdup(p, size, GFP_KERNEL);\n\t\tif (priv->firm[n].ptr == NULL) {\n\t\t\ttuner_err(\"Not enough memory to load firmware file.\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\ttuner_dbg(\"Reading firmware type \");\n\t\tif (debug) {\n\t\t\tdump_firm_type_and_int_freq(type, int_freq);\n\t\t\tprintk(KERN_CONT \"(%x), id %llx, size=%d.\\n\",\n\t\t\t       type, (unsigned long long)id, size);\n\t\t}\n\n\t\tpriv->firm[n].type = type;\n\t\tpriv->firm[n].id   = id;\n\t\tpriv->firm[n].size = size;\n\t\tpriv->firm[n].int_freq = int_freq;\n\n\t\tp += size;\n\t}\n\n\tif (n + 1 != priv->firm_size) {\n\t\ttuner_err(\"Firmware file is incomplete!\\n\");\n\t\tgoto corrupt;\n\t}\n\n\tgoto done;\n\nheader:\n\ttuner_err(\"Firmware header is incomplete!\\n\");\ncorrupt:\n\trc = -EINVAL;\n\ttuner_err(\"Error: firmware file is corrupted!\\n\");\n\nerr:\n\ttuner_info(\"Releasing partially loaded firmware file.\\n\");\n\tfree_firmware(priv);\n\ndone:\n\tif (rc == 0)\n\t\ttuner_dbg(\"Firmware files loaded.\\n\");\n\telse\n\t\tpriv->state = XC2028_NODEV;\n\n\treturn rc;\n}\n\nstatic int seek_firmware(struct dvb_frontend *fe, unsigned int type,\n\t\t\t v4l2_std_id *id)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint                 i, best_i = -1, best_nr_matches = 0;\n\tunsigned int        type_mask = 0;\n\n\ttuner_dbg(\"%s called, want type=\", __func__);\n\tif (debug) {\n\t\tdump_firm_type(type);\n\t\tprintk(KERN_CONT \"(%x), id %016llx.\\n\",\n\t\t       type, (unsigned long long)*id);\n\t}\n\n\tif (!priv->firm) {\n\t\ttuner_err(\"Error! firmware not loaded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (((type & ~SCODE) == 0) && (*id == 0))\n\t\t*id = V4L2_STD_PAL;\n\n\tif (type & BASE)\n\t\ttype_mask = BASE_TYPES;\n\telse if (type & SCODE) {\n\t\ttype &= SCODE_TYPES;\n\t\ttype_mask = SCODE_TYPES & ~HAS_IF;\n\t} else if (type & DTV_TYPES)\n\t\ttype_mask = DTV_TYPES;\n\telse if (type & STD_SPECIFIC_TYPES)\n\t\ttype_mask = STD_SPECIFIC_TYPES;\n\n\ttype &= type_mask;\n\n\tif (!(type & SCODE))\n\t\ttype_mask = ~0;\n\n\t \n\tfor (i = 0; i < priv->firm_size; i++) {\n\t\tif ((type == (priv->firm[i].type & type_mask)) &&\n\t\t    (*id == priv->firm[i].id))\n\t\t\tgoto found;\n\t}\n\n\t \n\tfor (i = 0; i < priv->firm_size; i++) {\n\t\tv4l2_std_id match_mask;\n\t\tint nr_matches;\n\n\t\tif (type != (priv->firm[i].type & type_mask))\n\t\t\tcontinue;\n\n\t\tmatch_mask = *id & priv->firm[i].id;\n\t\tif (!match_mask)\n\t\t\tcontinue;\n\n\t\tif ((*id & match_mask) == *id)\n\t\t\tgoto found;  \n\n\t\tnr_matches = hweight64(match_mask);\n\t\tif (nr_matches > best_nr_matches) {\n\t\t\tbest_nr_matches = nr_matches;\n\t\t\tbest_i = i;\n\t\t}\n\t}\n\n\tif (best_nr_matches > 0) {\n\t\ttuner_dbg(\"Selecting best matching firmware (%d bits) for type=\",\n\t\t\t  best_nr_matches);\n\t\tdump_firm_type(type);\n\t\tprintk(KERN_CONT\n\t\t       \"(%x), id %016llx:\\n\", type, (unsigned long long)*id);\n\t\ti = best_i;\n\t\tgoto found;\n\t}\n\n\t \n\n\ti = -ENOENT;\n\tgoto ret;\n\nfound:\n\t*id = priv->firm[i].id;\n\nret:\n\ttuner_dbg(\"%s firmware for type=\", (i < 0) ? \"Can't find\" : \"Found\");\n\tif (debug) {\n\t\tdump_firm_type(type);\n\t\tprintk(KERN_CONT \"(%x), id %016llx.\\n\",\n\t\t       type, (unsigned long long)*id);\n\t}\n\treturn i;\n}\n\nstatic inline int do_tuner_callback(struct dvb_frontend *fe, int cmd, int arg)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\n\t \n\n\treturn (!fe->callback) ? -EINVAL :\n\t\tfe->callback(((fe->dvb) && (fe->dvb->priv)) ?\n\t\t\t\tfe->dvb->priv : priv->i2c_props.adap->algo_data,\n\t\t\t     DVB_FRONTEND_COMPONENT_TUNER, cmd, arg);\n}\n\nstatic int load_firmware(struct dvb_frontend *fe, unsigned int type,\n\t\t\t v4l2_std_id *id)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint                pos, rc;\n\tunsigned char      *p, *endp, buf[MAX_XFER_SIZE];\n\n\tif (priv->ctrl.max_len > sizeof(buf))\n\t\tpriv->ctrl.max_len = sizeof(buf);\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tpos = seek_firmware(fe, type, id);\n\tif (pos < 0)\n\t\treturn pos;\n\n\ttuner_info(\"Loading firmware for type=\");\n\tdump_firm_type(priv->firm[pos].type);\n\tprintk(KERN_CONT \"(%x), id %016llx.\\n\",\n\t       priv->firm[pos].type, (unsigned long long)*id);\n\n\tp = priv->firm[pos].ptr;\n\tendp = p + priv->firm[pos].size;\n\n\twhile (p < endp) {\n\t\t__u16 size;\n\n\t\t \n\t\tif (p + sizeof(size) > endp) {\n\t\t\ttuner_err(\"Firmware chunk size is wrong\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsize = le16_to_cpu(*(__le16 *) p);\n\t\tp += sizeof(size);\n\n\t\tif (size == 0xffff)\n\t\t\treturn 0;\n\n\t\tif (!size) {\n\t\t\t \n\t\t\trc = do_tuner_callback(fe, XC2028_TUNER_RESET, 0);\n\t\t\tif (rc < 0) {\n\t\t\t\ttuner_err(\"Error at RESET code %d\\n\",\n\t\t\t\t\t   (*p) & 0x7f);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (size >= 0xff00) {\n\t\t\tswitch (size) {\n\t\t\tcase 0xff00:\n\t\t\t\trc = do_tuner_callback(fe, XC2028_RESET_CLK, 0);\n\t\t\t\tif (rc < 0) {\n\t\t\t\t\ttuner_err(\"Error at RESET code %d\\n\",\n\t\t\t\t\t\t  (*p) & 0x7f);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttuner_info(\"Invalid RESET code %d\\n\",\n\t\t\t\t\t   size & 0x7f);\n\t\t\t\treturn -EINVAL;\n\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (size & 0x8000) {\n\t\t\tmsleep(size & 0x7fff);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((size + p > endp)) {\n\t\t\ttuner_err(\"missing bytes: need %d, have %zd\\n\",\n\t\t\t\t   size, (endp - p));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbuf[0] = *p;\n\t\tp++;\n\t\tsize--;\n\n\t\t \n\t\twhile (size > 0) {\n\t\t\tint len = (size < priv->ctrl.max_len - 1) ?\n\t\t\t\t   size : priv->ctrl.max_len - 1;\n\n\t\t\tmemcpy(buf + 1, p, len);\n\n\t\t\trc = i2c_send(priv, buf, len + 1);\n\t\t\tif (rc < 0) {\n\t\t\t\ttuner_err(\"%d returned from send\\n\", rc);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tp += len;\n\t\t\tsize -= len;\n\t\t}\n\n\t\t \n\t\trc = do_tuner_callback(fe, XC2028_I2C_FLUSH, 0);\n\t\tif ((rc < 0) && (rc != -EINVAL)) {\n\t\t\ttuner_err(\"error executing flush: %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int load_scode(struct dvb_frontend *fe, unsigned int type,\n\t\t\t v4l2_std_id *id, __u16 int_freq, int scode)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint                pos, rc;\n\tunsigned char\t   *p;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tif (!int_freq) {\n\t\tpos = seek_firmware(fe, type, id);\n\t\tif (pos < 0)\n\t\t\treturn pos;\n\t} else {\n\t\tfor (pos = 0; pos < priv->firm_size; pos++) {\n\t\t\tif ((priv->firm[pos].int_freq == int_freq) &&\n\t\t\t    (priv->firm[pos].type & HAS_IF))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pos == priv->firm_size)\n\t\t\treturn -ENOENT;\n\t}\n\n\tp = priv->firm[pos].ptr;\n\n\tif (priv->firm[pos].type & HAS_IF) {\n\t\tif (priv->firm[pos].size != 12 * 16 || scode >= 16)\n\t\t\treturn -EINVAL;\n\t\tp += 12 * scode;\n\t} else {\n\t\t \n\t\tif (priv->firm[pos].size != 14 * 16 || scode >= 16 ||\n\t\t    le16_to_cpu(*(__le16 *)(p + 14 * scode)) != 12)\n\t\t\treturn -EINVAL;\n\t\tp += 14 * scode + 2;\n\t}\n\n\ttuner_info(\"Loading SCODE for type=\");\n\tdump_firm_type_and_int_freq(priv->firm[pos].type,\n\t\t\t\t    priv->firm[pos].int_freq);\n\tprintk(KERN_CONT \"(%x), id %016llx.\\n\", priv->firm[pos].type,\n\t       (unsigned long long)*id);\n\n\tif (priv->firm_version < 0x0202)\n\t\trc = send_seq(priv, {0x20, 0x00, 0x00, 0x00});\n\telse\n\t\trc = send_seq(priv, {0xa0, 0x00, 0x00, 0x00});\n\tif (rc < 0)\n\t\treturn -EIO;\n\n\trc = i2c_send(priv, p, 12);\n\tif (rc < 0)\n\t\treturn -EIO;\n\n\trc = send_seq(priv, {0x00, 0x8c});\n\tif (rc < 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int xc2028_sleep(struct dvb_frontend *fe);\n\nstatic int check_firmware(struct dvb_frontend *fe, unsigned int type,\n\t\t\t  v4l2_std_id std, __u16 int_freq)\n{\n\tstruct xc2028_data         *priv = fe->tuner_priv;\n\tstruct firmware_properties new_fw;\n\tint\t\t\t   rc, retry_count = 0;\n\tu16\t\t\t   version, hwmodel;\n\tv4l2_std_id\t\t   std0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (priv->ctrl.mts && !(type & FM))\n\t\ttype |= MTS;\n\nretry:\n\tnew_fw.type = type;\n\tnew_fw.id = std;\n\tnew_fw.std_req = std;\n\tnew_fw.scode_table = SCODE | priv->ctrl.scode_table;\n\tnew_fw.scode_nr = 0;\n\tnew_fw.int_freq = int_freq;\n\n\ttuner_dbg(\"checking firmware, user requested type=\");\n\tif (debug) {\n\t\tdump_firm_type(new_fw.type);\n\t\tprintk(KERN_CONT \"(%x), id %016llx, \", new_fw.type,\n\t\t       (unsigned long long)new_fw.std_req);\n\t\tif (!int_freq) {\n\t\t\tprintk(KERN_CONT \"scode_tbl \");\n\t\t\tdump_firm_type(priv->ctrl.scode_table);\n\t\t\tprintk(KERN_CONT \"(%x), \", priv->ctrl.scode_table);\n\t\t} else\n\t\t\tprintk(KERN_CONT \"int_freq %d, \", new_fw.int_freq);\n\t\tprintk(KERN_CONT \"scode_nr %d\\n\", new_fw.scode_nr);\n\t}\n\n\t \n\tif ((priv->state == XC2028_ACTIVE) &&\n\t    (((BASE | new_fw.type) & BASE_TYPES) ==\n\t    (priv->cur_fw.type & BASE_TYPES))) {\n\t\ttuner_dbg(\"BASE firmware not changed.\\n\");\n\t\tgoto skip_base;\n\t}\n\n\t \n\tmemset(&priv->cur_fw, 0, sizeof(priv->cur_fw));\n\n\t \n\trc = do_tuner_callback(fe, XC2028_TUNER_RESET, 0);\n\tif (rc < 0)\n\t\tgoto fail;\n\n\t \n\tstd0 = 0;\n\trc = load_firmware(fe, BASE | new_fw.type, &std0);\n\tif (rc < 0) {\n\t\ttuner_err(\"Error %d while loading base firmware\\n\",\n\t\t\t  rc);\n\t\tgoto fail;\n\t}\n\n\t \n\ttuner_dbg(\"Load init1 firmware, if exists\\n\");\n\n\trc = load_firmware(fe, BASE | INIT1 | new_fw.type, &std0);\n\tif (rc == -ENOENT)\n\t\trc = load_firmware(fe, (BASE | INIT1 | new_fw.type) & ~F8MHZ,\n\t\t\t\t   &std0);\n\tif (rc < 0 && rc != -ENOENT) {\n\t\ttuner_err(\"Error %d while loading init1 firmware\\n\",\n\t\t\t  rc);\n\t\tgoto fail;\n\t}\n\nskip_base:\n\t \n\tif (priv->cur_fw.type == (BASE | new_fw.type) &&\n\t    priv->cur_fw.std_req == std) {\n\t\ttuner_dbg(\"Std-specific firmware already loaded.\\n\");\n\t\tgoto skip_std_specific;\n\t}\n\n\t \n\tpriv->cur_fw.scode_table = 0;\n\n\trc = load_firmware(fe, new_fw.type, &new_fw.id);\n\tif (rc == -ENOENT)\n\t\trc = load_firmware(fe, new_fw.type & ~F8MHZ, &new_fw.id);\n\n\tif (rc < 0)\n\t\tgoto fail;\n\nskip_std_specific:\n\tif (priv->cur_fw.scode_table == new_fw.scode_table &&\n\t    priv->cur_fw.scode_nr == new_fw.scode_nr) {\n\t\ttuner_dbg(\"SCODE firmware already loaded.\\n\");\n\t\tgoto check_device;\n\t}\n\n\tif (new_fw.type & FM)\n\t\tgoto check_device;\n\n\t \n\ttuner_dbg(\"Trying to load scode %d\\n\", new_fw.scode_nr);\n\n\trc = load_scode(fe, new_fw.type | new_fw.scode_table, &new_fw.id,\n\t\t\tnew_fw.int_freq, new_fw.scode_nr);\n\ncheck_device:\n\tif (xc2028_get_reg(priv, 0x0004, &version) < 0 ||\n\t    xc2028_get_reg(priv, 0x0008, &hwmodel) < 0) {\n\t\ttuner_err(\"Unable to read tuner registers.\\n\");\n\t\tgoto fail;\n\t}\n\n\ttuner_dbg(\"Device is Xceive %d version %d.%d, firmware version %d.%d\\n\",\n\t\t  hwmodel, (version & 0xf000) >> 12, (version & 0xf00) >> 8,\n\t\t  (version & 0xf0) >> 4, version & 0xf);\n\n\n\tif (priv->ctrl.read_not_reliable)\n\t\tgoto read_not_reliable;\n\n\t \n\tif (priv->firm_version != ((version & 0xf0) << 4 | (version & 0x0f))) {\n\t\tif (!priv->ctrl.read_not_reliable) {\n\t\t\ttuner_err(\"Incorrect readback of firmware version.\\n\");\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\ttuner_err(\"Returned an incorrect version. However, read is not reliable enough. Ignoring it.\\n\");\n\t\t\thwmodel = 3028;\n\t\t}\n\t}\n\n\t \n\tif (priv->hwmodel == 0 && (hwmodel == 2028 || hwmodel == 3028)) {\n\t\tpriv->hwmodel = hwmodel;\n\t\tpriv->hwvers  = version & 0xff00;\n\t} else if (priv->hwmodel == 0 || priv->hwmodel != hwmodel ||\n\t\t   priv->hwvers != (version & 0xff00)) {\n\t\ttuner_err(\"Read invalid device hardware information - tuner hung?\\n\");\n\t\tgoto fail;\n\t}\n\nread_not_reliable:\n\tpriv->cur_fw = new_fw;\n\n\t \n\tpriv->cur_fw.type |= BASE;\n\tpriv->state = XC2028_ACTIVE;\n\n\treturn 0;\n\nfail:\n\tfree_firmware(priv);\n\n\tif (retry_count < 8) {\n\t\tmsleep(50);\n\t\tretry_count++;\n\t\ttuner_dbg(\"Retrying firmware load\\n\");\n\t\tgoto retry;\n\t}\n\n\t \n\txc2028_sleep(fe);\n\n\tif (rc == -ENOENT)\n\t\trc = -EINVAL;\n\treturn rc;\n}\n\nstatic int xc2028_signal(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tu16                 frq_lock, signal = 0;\n\tint                 rc, i;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (!rc) {\n\t\t*strength = 0;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\trc = xc2028_get_reg(priv, XREG_LOCK, &frq_lock);\n\t\tif (rc < 0)\n\t\t\tgoto ret;\n\n\t\tif (frq_lock)\n\t\t\tbreak;\n\t\tmsleep(6);\n\t}\n\n\t \n\tif (frq_lock == 2)\n\t\tgoto ret;\n\n\t \n\trc = xc2028_get_reg(priv, XREG_SNR, &signal);\n\tif (rc < 0)\n\t\tgoto ret;\n\n\t \n\n\tsignal = ((1 << 12) - 1) | ((signal & 0x07) << 12);\n\nret:\n\tmutex_unlock(&priv->lock);\n\n\t*strength = signal;\n\n\ttuner_dbg(\"signal strength is %d\\n\", signal);\n\n\treturn rc;\n}\n\nstatic int xc2028_get_afc(struct dvb_frontend *fe, s32 *afc)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint i, rc;\n\tu16 frq_lock = 0;\n\ts16 afc_reg = 0;\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (!rc) {\n\t\t*afc = 0;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\trc = xc2028_get_reg(priv, XREG_LOCK, &frq_lock);\n\t\tif (rc < 0)\n\t\t\tgoto ret;\n\n\t\tif (frq_lock)\n\t\t\tbreak;\n\t\tmsleep(6);\n\t}\n\n\t \n\tif (frq_lock == 2)\n\t\tgoto ret;\n\n\t \n\trc = xc2028_get_reg(priv, XREG_FREQ_ERROR, &afc_reg);\n\tif (rc < 0)\n\t\tgoto ret;\n\n\t*afc = afc_reg * 15625;  \n\n\ttuner_dbg(\"AFC is %d Hz\\n\", *afc);\n\nret:\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}\n\n#define DIV 15625\n\nstatic int generic_set_freq(struct dvb_frontend *fe, u32 freq  ,\n\t\t\t    enum v4l2_tuner_type new_type,\n\t\t\t    unsigned int type,\n\t\t\t    v4l2_std_id std,\n\t\t\t    u16 int_freq)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint\t\t   rc = -EINVAL;\n\tunsigned char\t   buf[4];\n\tu32\t\t   div, offset = 0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tmutex_lock(&priv->lock);\n\n\ttuner_dbg(\"should set frequency %d kHz\\n\", freq / 1000);\n\n\tif (check_firmware(fe, type, std, int_freq) < 0)\n\t\tgoto ret;\n\n\t \n\tswitch (new_type) {\n\tcase V4L2_TUNER_ANALOG_TV:\n\t\trc = send_seq(priv, {0x00, 0x00});\n\n\t\t \n\t\tbreak;\n\tcase V4L2_TUNER_RADIO:\n\t\t \n\t\tbreak;\n\tcase V4L2_TUNER_DIGITAL_TV:\n\t\t \n\n\t\t \n\n\t\t \n\n\t\tif (priv->cur_fw.type & DTV6)\n\t\t\toffset = 1750000;\n\t\telse\t \n\t\t\toffset = 2750000;\n\n\t\t \n\n\t\t \n\n#if 0\n\t\t \n\n\t\tif (priv->firm_version < 0x0302) {\n\t\t\tif (priv->cur_fw.type & DTV7)\n\t\t\t\toffset += 500000;\n\t\t} else {\n\t\t\tif (priv->cur_fw.type & DTV7)\n\t\t\t\toffset -= 300000;\n\t\t\telse if (type != ATSC)  \n\t\t\t\toffset += 200000;\n\t\t}\n#endif\n\t\tbreak;\n\tdefault:\n\t\ttuner_err(\"Unsupported tuner type %d.\\n\", new_type);\n\t\tbreak;\n\t}\n\n\tdiv = (freq - offset + DIV / 2) / DIV;\n\n\t \n\tif (priv->firm_version < 0x0202)\n\t\trc = send_seq(priv, {0x00, XREG_RF_FREQ, 0x00, 0x00});\n\telse\n\t\trc = send_seq(priv, {0x80, XREG_RF_FREQ, 0x00, 0x00});\n\tif (rc < 0)\n\t\tgoto ret;\n\n\t \n\tif (priv->ctrl.msleep)\n\t\tmsleep(priv->ctrl.msleep);\n\tdo_tuner_callback(fe, XC2028_RESET_CLK, 1);\n\n\tmsleep(10);\n\n\tbuf[0] = 0xff & (div >> 24);\n\tbuf[1] = 0xff & (div >> 16);\n\tbuf[2] = 0xff & (div >> 8);\n\tbuf[3] = 0xff & (div);\n\n\trc = i2c_send(priv, buf, sizeof(buf));\n\tif (rc < 0)\n\t\tgoto ret;\n\tmsleep(100);\n\n\tpriv->frequency = freq;\n\n\ttuner_dbg(\"divisor= %*ph (freq=%d.%03d)\\n\", 4, buf,\n\t       freq / 1000000, (freq % 1000000) / 1000);\n\n\trc = 0;\n\nret:\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}\n\nstatic int xc2028_set_analog_freq(struct dvb_frontend *fe,\n\t\t\t      struct analog_parameters *p)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tunsigned int       type=0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tif (p->mode == V4L2_TUNER_RADIO) {\n\t\ttype |= FM;\n\t\tif (priv->ctrl.input1)\n\t\t\ttype |= INPUT1;\n\t\treturn generic_set_freq(fe, (625l * p->frequency) / 10,\n\t\t\t\tV4L2_TUNER_RADIO, type, 0, 0);\n\t}\n\n\t \n\tif (!p->std)\n\t\tp->std = V4L2_STD_MN;\n\n\t \n\tif (!(p->std & V4L2_STD_MN))\n\t\ttype |= F8MHZ;\n\n\t \n\tp->std |= parse_audio_std_option();\n\n\treturn generic_set_freq(fe, 62500l * p->frequency,\n\t\t\t\tV4L2_TUNER_ANALOG_TV, type, p->std, 0);\n}\n\nstatic int xc2028_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 delsys = c->delivery_system;\n\tu32 bw = c->bandwidth_hz;\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint rc;\n\tunsigned int       type = 0;\n\tu16                demod = 0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tswitch (delsys) {\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\t \n\t\tif (bw <= 6000000)\n\t\t\ttype |= QAM;\n\n\t\tswitch (priv->ctrl.type) {\n\t\tcase XC2028_D2633:\n\t\t\ttype |= D2633;\n\t\t\tbreak;\n\t\tcase XC2028_D2620:\n\t\t\ttype |= D2620;\n\t\t\tbreak;\n\t\tcase XC2028_AUTO:\n\t\tdefault:\n\t\t\t \n\t\t\tif (priv->ctrl.demod == XC3028_FE_ZARLINK456)\n\t\t\t\ttype |= D2633;\n\t\t\telse\n\t\t\t\ttype |= D2620;\n\t\t}\n\t\tbreak;\n\tcase SYS_ATSC:\n\t\t \n\t\ttype |= ATSC | D2633;\n\t\tbreak;\n\t \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (bw <= 6000000) {\n\t\ttype |= DTV6;\n\t\tpriv->ctrl.vhfbw7 = 0;\n\t\tpriv->ctrl.uhfbw8 = 0;\n\t} else if (bw <= 7000000) {\n\t\tif (c->frequency < 470000000)\n\t\t\tpriv->ctrl.vhfbw7 = 1;\n\t\telse\n\t\t\tpriv->ctrl.uhfbw8 = 0;\n\t\ttype |= (priv->ctrl.vhfbw7 && priv->ctrl.uhfbw8) ? DTV78 : DTV7;\n\t\ttype |= F8MHZ;\n\t} else {\n\t\tif (c->frequency < 470000000)\n\t\t\tpriv->ctrl.vhfbw7 = 0;\n\t\telse\n\t\t\tpriv->ctrl.uhfbw8 = 1;\n\t\ttype |= (priv->ctrl.vhfbw7 && priv->ctrl.uhfbw8) ? DTV78 : DTV8;\n\t\ttype |= F8MHZ;\n\t}\n\n\t \n\tif (priv->ctrl.demod) {\n\t\tdemod = priv->ctrl.demod;\n\n\t\t \n\t\tif (type == ATSC || priv->firm_version < 0x0302)\n\t\t\tdemod += 200;\n\t\t \n\t}\n\n\treturn generic_set_freq(fe, c->frequency,\n\t\t\t\tV4L2_TUNER_DIGITAL_TV, type, 0, demod);\n}\n\nstatic int xc2028_sleep(struct dvb_frontend *fe)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint rc;\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (!rc)\n\t\treturn 0;\n\n\t \n\tif (no_poweroff || priv->ctrl.disable_power_mgmt)\n\t\treturn 0;\n\n\ttuner_dbg(\"Putting xc2028/3028 into poweroff mode.\\n\");\n\tif (debug > 1) {\n\t\ttuner_dbg(\"Printing sleep stack trace:\\n\");\n\t\tdump_stack();\n\t}\n\n\tmutex_lock(&priv->lock);\n\n\tif (priv->firm_version < 0x0202)\n\t\trc = send_seq(priv, {0x00, XREG_POWER_DOWN, 0x00, 0x00});\n\telse\n\t\trc = send_seq(priv, {0x80, XREG_POWER_DOWN, 0x00, 0x00});\n\n\tif (rc >= 0)\n\t\tpriv->state = XC2028_SLEEP;\n\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}\n\nstatic void xc2028_dvb_release(struct dvb_frontend *fe)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tmutex_lock(&xc2028_list_mutex);\n\n\t \n\tif (hybrid_tuner_report_instance_count(priv) == 1)\n\t\tfree_firmware(priv);\n\n\tif (priv)\n\t\thybrid_tuner_release_state(priv);\n\n\tmutex_unlock(&xc2028_list_mutex);\n\n\tfe->tuner_priv = NULL;\n}\n\nstatic int xc2028_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint rc;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*frequency = priv->frequency;\n\n\treturn 0;\n}\n\nstatic void load_firmware_cb(const struct firmware *fw,\n\t\t\t     void *context)\n{\n\tstruct dvb_frontend *fe = context;\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint rc;\n\n\ttuner_dbg(\"request_firmware_nowait(): %s\\n\", fw ? \"OK\" : \"error\");\n\tif (!fw) {\n\t\ttuner_err(\"Could not load firmware %s.\\n\", priv->fname);\n\t\tpriv->state = XC2028_NODEV;\n\t\treturn;\n\t}\n\n\trc = load_all_firmwares(fe, fw);\n\n\trelease_firmware(fw);\n\n\tif (rc < 0)\n\t\treturn;\n\tpriv->state = XC2028_ACTIVE;\n}\n\nstatic int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tstruct xc2028_ctrl *p    = priv_cfg;\n\tint                 rc   = 0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tmemcpy(&priv->ctrl, p, sizeof(priv->ctrl));\n\n\t \n\tif (!firmware_name[0] && p->fname &&\n\t    priv->fname && strcmp(p->fname, priv->fname))\n\t\tfree_firmware(priv);\n\n\tif (priv->ctrl.max_len < 9)\n\t\tpriv->ctrl.max_len = 13;\n\n\tif (priv->state == XC2028_NO_FIRMWARE) {\n\t\tif (!firmware_name[0])\n\t\t\tpriv->fname = kstrdup(p->fname, GFP_KERNEL);\n\t\telse\n\t\t\tpriv->fname = firmware_name;\n\n\t\tif (!priv->fname) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\trc = request_firmware_nowait(THIS_MODULE, 1,\n\t\t\t\t\t     priv->fname,\n\t\t\t\t\t     priv->i2c_props.adap->dev.parent,\n\t\t\t\t\t     GFP_KERNEL,\n\t\t\t\t\t     fe, load_firmware_cb);\n\t\tif (rc < 0) {\n\t\t\ttuner_err(\"Failed to request firmware %s\\n\",\n\t\t\t\t  priv->fname);\n\t\t\tpriv->state = XC2028_NODEV;\n\t\t} else\n\t\t\tpriv->state = XC2028_WAITING_FIRMWARE;\n\t}\nunlock:\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}\n\nstatic const struct dvb_tuner_ops xc2028_dvb_tuner_ops = {\n\t.info = {\n\t\t .name = \"Xceive XC3028\",\n\t\t .frequency_min_hz  =  42 * MHz,\n\t\t .frequency_max_hz  = 864 * MHz,\n\t\t .frequency_step_hz =  50 * kHz,\n\t\t },\n\n\t.set_config\t   = xc2028_set_config,\n\t.set_analog_params = xc2028_set_analog_freq,\n\t.release           = xc2028_dvb_release,\n\t.get_frequency     = xc2028_get_frequency,\n\t.get_rf_strength   = xc2028_signal,\n\t.get_afc           = xc2028_get_afc,\n\t.set_params        = xc2028_set_params,\n\t.sleep             = xc2028_sleep,\n};\n\nstruct dvb_frontend *xc2028_attach(struct dvb_frontend *fe,\n\t\t\t\t   struct xc2028_config *cfg)\n{\n\tstruct xc2028_data *priv;\n\tint instance;\n\n\tif (debug)\n\t\tprintk(KERN_DEBUG \"xc2028: Xcv2028/3028 init called!\\n\");\n\n\tif (NULL == cfg)\n\t\treturn NULL;\n\n\tif (!fe) {\n\t\tprintk(KERN_ERR \"xc2028: No frontend!\\n\");\n\t\treturn NULL;\n\t}\n\n\tmutex_lock(&xc2028_list_mutex);\n\n\tinstance = hybrid_tuner_request_state(struct xc2028_data, priv,\n\t\t\t\t\t      hybrid_tuner_instance_list,\n\t\t\t\t\t      cfg->i2c_adap, cfg->i2c_addr,\n\t\t\t\t\t      \"xc2028\");\n\tswitch (instance) {\n\tcase 0:\n\t\t \n\t\tgoto fail;\n\tcase 1:\n\t\t \n\t\tpriv->ctrl.max_len = 13;\n\n\t\tmutex_init(&priv->lock);\n\n\t\tfe->tuner_priv = priv;\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tfe->tuner_priv = priv;\n\t\tbreak;\n\t}\n\n\tmemcpy(&fe->ops.tuner_ops, &xc2028_dvb_tuner_ops,\n\t       sizeof(xc2028_dvb_tuner_ops));\n\n\ttuner_info(\"type set to %s\\n\", \"XCeive xc2028/xc3028 tuner\");\n\n\tif (cfg->ctrl)\n\t\txc2028_set_config(fe, cfg->ctrl);\n\n\tmutex_unlock(&xc2028_list_mutex);\n\n\treturn fe;\nfail:\n\tmutex_unlock(&xc2028_list_mutex);\n\n\txc2028_dvb_release(fe);\n\treturn NULL;\n}\n\nEXPORT_SYMBOL_GPL(xc2028_attach);\n\nMODULE_DESCRIPTION(\"Xceive xc2028/xc3028 tuner driver\");\nMODULE_AUTHOR(\"Michel Ludwig <michel.ludwig@gmail.com>\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab <mchehab@kernel.org>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_FIRMWARE(XC2028_DEFAULT_FIRMWARE);\nMODULE_FIRMWARE(XC3028L_DEFAULT_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}