{
  "module_name": "tda18271-common.c",
  "hash_id": "dfbe94263ad25dd75929c3a0b7d2a9e28243dbb836b397c3126df5474a6c010b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/tda18271-common.c",
  "human_readable_source": "\n \n\n#include \"tda18271-priv.h\"\n\nstatic int tda18271_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tenum tda18271_i2c_gate gate;\n\tint ret = 0;\n\n\tswitch (priv->gate) {\n\tcase TDA18271_GATE_DIGITAL:\n\tcase TDA18271_GATE_ANALOG:\n\t\tgate = priv->gate;\n\t\tbreak;\n\tcase TDA18271_GATE_AUTO:\n\tdefault:\n\t\tswitch (priv->mode) {\n\t\tcase TDA18271_DIGITAL:\n\t\t\tgate = TDA18271_GATE_DIGITAL;\n\t\t\tbreak;\n\t\tcase TDA18271_ANALOG:\n\t\tdefault:\n\t\t\tgate = TDA18271_GATE_ANALOG;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (gate) {\n\tcase TDA18271_GATE_ANALOG:\n\t\tif (fe->ops.analog_ops.i2c_gate_ctrl)\n\t\t\tret = fe->ops.analog_ops.i2c_gate_ctrl(fe, enable);\n\t\tbreak;\n\tcase TDA18271_GATE_DIGITAL:\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tret = fe->ops.i2c_gate_ctrl(fe, enable);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n};\n\n \n\nstatic void tda18271_dump_regs(struct dvb_frontend *fe, int extended)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\n\ttda_reg(\"=== TDA18271 REG DUMP ===\\n\");\n\ttda_reg(\"ID_BYTE            = 0x%02x\\n\", 0xff & regs[R_ID]);\n\ttda_reg(\"THERMO_BYTE        = 0x%02x\\n\", 0xff & regs[R_TM]);\n\ttda_reg(\"POWER_LEVEL_BYTE   = 0x%02x\\n\", 0xff & regs[R_PL]);\n\ttda_reg(\"EASY_PROG_BYTE_1   = 0x%02x\\n\", 0xff & regs[R_EP1]);\n\ttda_reg(\"EASY_PROG_BYTE_2   = 0x%02x\\n\", 0xff & regs[R_EP2]);\n\ttda_reg(\"EASY_PROG_BYTE_3   = 0x%02x\\n\", 0xff & regs[R_EP3]);\n\ttda_reg(\"EASY_PROG_BYTE_4   = 0x%02x\\n\", 0xff & regs[R_EP4]);\n\ttda_reg(\"EASY_PROG_BYTE_5   = 0x%02x\\n\", 0xff & regs[R_EP5]);\n\ttda_reg(\"CAL_POST_DIV_BYTE  = 0x%02x\\n\", 0xff & regs[R_CPD]);\n\ttda_reg(\"CAL_DIV_BYTE_1     = 0x%02x\\n\", 0xff & regs[R_CD1]);\n\ttda_reg(\"CAL_DIV_BYTE_2     = 0x%02x\\n\", 0xff & regs[R_CD2]);\n\ttda_reg(\"CAL_DIV_BYTE_3     = 0x%02x\\n\", 0xff & regs[R_CD3]);\n\ttda_reg(\"MAIN_POST_DIV_BYTE = 0x%02x\\n\", 0xff & regs[R_MPD]);\n\ttda_reg(\"MAIN_DIV_BYTE_1    = 0x%02x\\n\", 0xff & regs[R_MD1]);\n\ttda_reg(\"MAIN_DIV_BYTE_2    = 0x%02x\\n\", 0xff & regs[R_MD2]);\n\ttda_reg(\"MAIN_DIV_BYTE_3    = 0x%02x\\n\", 0xff & regs[R_MD3]);\n\n\t \n\tif (!(tda18271_debug & DBG_ADV))\n\t\treturn;\n\n\t \n\n\ttda_reg(\"EXTENDED_BYTE_1    = 0x%02x\\n\", 0xff & regs[R_EB1]);\n\ttda_reg(\"EXTENDED_BYTE_2    = 0x%02x\\n\", 0xff & regs[R_EB2]);\n\ttda_reg(\"EXTENDED_BYTE_3    = 0x%02x\\n\", 0xff & regs[R_EB3]);\n\ttda_reg(\"EXTENDED_BYTE_4    = 0x%02x\\n\", 0xff & regs[R_EB4]);\n\ttda_reg(\"EXTENDED_BYTE_5    = 0x%02x\\n\", 0xff & regs[R_EB5]);\n\ttda_reg(\"EXTENDED_BYTE_6    = 0x%02x\\n\", 0xff & regs[R_EB6]);\n\ttda_reg(\"EXTENDED_BYTE_7    = 0x%02x\\n\", 0xff & regs[R_EB7]);\n\ttda_reg(\"EXTENDED_BYTE_8    = 0x%02x\\n\", 0xff & regs[R_EB8]);\n\ttda_reg(\"EXTENDED_BYTE_9  W = 0x%02x\\n\", 0xff & regs[R_EB9]);\n\ttda_reg(\"EXTENDED_BYTE_10   = 0x%02x\\n\", 0xff & regs[R_EB10]);\n\ttda_reg(\"EXTENDED_BYTE_11   = 0x%02x\\n\", 0xff & regs[R_EB11]);\n\ttda_reg(\"EXTENDED_BYTE_12   = 0x%02x\\n\", 0xff & regs[R_EB12]);\n\ttda_reg(\"EXTENDED_BYTE_13   = 0x%02x\\n\", 0xff & regs[R_EB13]);\n\ttda_reg(\"EXTENDED_BYTE_14   = 0x%02x\\n\", 0xff & regs[R_EB14]);\n\ttda_reg(\"EXTENDED_BYTE_15   = 0x%02x\\n\", 0xff & regs[R_EB15]);\n\ttda_reg(\"EXTENDED_BYTE_16 W = 0x%02x\\n\", 0xff & regs[R_EB16]);\n\ttda_reg(\"EXTENDED_BYTE_17 W = 0x%02x\\n\", 0xff & regs[R_EB17]);\n\ttda_reg(\"EXTENDED_BYTE_18   = 0x%02x\\n\", 0xff & regs[R_EB18]);\n\ttda_reg(\"EXTENDED_BYTE_19 W = 0x%02x\\n\", 0xff & regs[R_EB19]);\n\ttda_reg(\"EXTENDED_BYTE_20 W = 0x%02x\\n\", 0xff & regs[R_EB20]);\n\ttda_reg(\"EXTENDED_BYTE_21   = 0x%02x\\n\", 0xff & regs[R_EB21]);\n\ttda_reg(\"EXTENDED_BYTE_22   = 0x%02x\\n\", 0xff & regs[R_EB22]);\n\ttda_reg(\"EXTENDED_BYTE_23   = 0x%02x\\n\", 0xff & regs[R_EB23]);\n}\n\nint tda18271_read_regs(struct dvb_frontend *fe)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tunsigned char buf = 0x00;\n\tint ret;\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = priv->i2c_props.addr, .flags = 0,\n\t\t  .buf = &buf, .len = 1 },\n\t\t{ .addr = priv->i2c_props.addr, .flags = I2C_M_RD,\n\t\t  .buf = regs, .len = 16 }\n\t};\n\n\ttda18271_i2c_gate_ctrl(fe, 1);\n\n\t \n\tret = i2c_transfer(priv->i2c_props.adap, msg, 2);\n\n\ttda18271_i2c_gate_ctrl(fe, 0);\n\n\tif (ret != 2)\n\t\ttda_err(\"ERROR: i2c_transfer returned: %d\\n\", ret);\n\n\tif (tda18271_debug & DBG_REG)\n\t\ttda18271_dump_regs(fe, 0);\n\n\treturn (ret == 2 ? 0 : ret);\n}\n\nint tda18271_read_extended(struct dvb_frontend *fe)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tunsigned char regdump[TDA18271_NUM_REGS];\n\tunsigned char buf = 0x00;\n\tint ret, i;\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = priv->i2c_props.addr, .flags = 0,\n\t\t  .buf = &buf, .len = 1 },\n\t\t{ .addr = priv->i2c_props.addr, .flags = I2C_M_RD,\n\t\t  .buf = regdump, .len = TDA18271_NUM_REGS }\n\t};\n\n\ttda18271_i2c_gate_ctrl(fe, 1);\n\n\t \n\tret = i2c_transfer(priv->i2c_props.adap, msg, 2);\n\n\ttda18271_i2c_gate_ctrl(fe, 0);\n\n\tif (ret != 2)\n\t\ttda_err(\"ERROR: i2c_transfer returned: %d\\n\", ret);\n\n\tfor (i = 0; i < TDA18271_NUM_REGS; i++) {\n\t\t \n\t\tif ((i != R_EB9)  &&\n\t\t    (i != R_EB16) &&\n\t\t    (i != R_EB17) &&\n\t\t    (i != R_EB19) &&\n\t\t    (i != R_EB20))\n\t\t\tregs[i] = regdump[i];\n\t}\n\n\tif (tda18271_debug & DBG_REG)\n\t\ttda18271_dump_regs(fe, 1);\n\n\treturn (ret == 2 ? 0 : ret);\n}\n\nstatic int __tda18271_write_regs(struct dvb_frontend *fe, int idx, int len,\n\t\t\tbool lock_i2c)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tunsigned char buf[TDA18271_NUM_REGS + 1];\n\tstruct i2c_msg msg = { .addr = priv->i2c_props.addr, .flags = 0,\n\t\t\t       .buf = buf };\n\tint i, ret = 1, max;\n\n\tBUG_ON((len == 0) || (idx + len > sizeof(buf)));\n\n\tswitch (priv->small_i2c) {\n\tcase TDA18271_03_BYTE_CHUNK_INIT:\n\t\tmax = 3;\n\t\tbreak;\n\tcase TDA18271_08_BYTE_CHUNK_INIT:\n\t\tmax = 8;\n\t\tbreak;\n\tcase TDA18271_16_BYTE_CHUNK_INIT:\n\t\tmax = 16;\n\t\tbreak;\n\tcase TDA18271_39_BYTE_CHUNK_INIT:\n\tdefault:\n\t\tmax = 39;\n\t}\n\n\n\t \n\tif (lock_i2c) {\n\t\ttda18271_i2c_gate_ctrl(fe, 1);\n\t\ti2c_lock_bus(priv->i2c_props.adap, I2C_LOCK_SEGMENT);\n\t}\n\twhile (len) {\n\t\tif (max > len)\n\t\t\tmax = len;\n\n\t\tbuf[0] = idx;\n\t\tfor (i = 1; i <= max; i++)\n\t\t\tbuf[i] = regs[idx - 1 + i];\n\n\t\tmsg.len = max + 1;\n\n\t\t \n\t\tret = __i2c_transfer(priv->i2c_props.adap, &msg, 1);\n\t\tif (ret != 1)\n\t\t\tbreak;\n\n\t\tidx += max;\n\t\tlen -= max;\n\t}\n\tif (lock_i2c) {\n\t\ti2c_unlock_bus(priv->i2c_props.adap, I2C_LOCK_SEGMENT);\n\t\ttda18271_i2c_gate_ctrl(fe, 0);\n\t}\n\n\tif (ret != 1)\n\t\ttda_err(\"ERROR: idx = 0x%x, len = %d, i2c_transfer returned: %d\\n\",\n\t\t\tidx, max, ret);\n\n\treturn (ret == 1 ? 0 : ret);\n}\n\nint tda18271_write_regs(struct dvb_frontend *fe, int idx, int len)\n{\n\treturn __tda18271_write_regs(fe, idx, len, true);\n}\n\n \n\nstatic int __tda18271_charge_pump_source(struct dvb_frontend *fe,\n\t\t\t\t\t enum tda18271_pll pll, int force,\n\t\t\t\t\t bool lock_i2c)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\n\tint r_cp = (pll == TDA18271_CAL_PLL) ? R_EB7 : R_EB4;\n\n\tregs[r_cp] &= ~0x20;\n\tregs[r_cp] |= ((force & 1) << 5);\n\n\treturn __tda18271_write_regs(fe, r_cp, 1, lock_i2c);\n}\n\nint tda18271_charge_pump_source(struct dvb_frontend *fe,\n\t\t\t\tenum tda18271_pll pll, int force)\n{\n\treturn __tda18271_charge_pump_source(fe, pll, force, true);\n}\n\n\nint tda18271_init_regs(struct dvb_frontend *fe)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\n\ttda_dbg(\"initializing registers for device @ %d-%04x\\n\",\n\t\ti2c_adapter_id(priv->i2c_props.adap),\n\t\tpriv->i2c_props.addr);\n\n\t \n\ttda18271_i2c_gate_ctrl(fe, 1);\n\ti2c_lock_bus(priv->i2c_props.adap, I2C_LOCK_SEGMENT);\n\n\t \n\tswitch (priv->id) {\n\tcase TDA18271HDC1:\n\t\tregs[R_ID]   = 0x83;\n\t\tbreak;\n\tcase TDA18271HDC2:\n\t\tregs[R_ID]   = 0x84;\n\t\tbreak;\n\t}\n\n\tregs[R_TM]   = 0x08;\n\tregs[R_PL]   = 0x80;\n\tregs[R_EP1]  = 0xc6;\n\tregs[R_EP2]  = 0xdf;\n\tregs[R_EP3]  = 0x16;\n\tregs[R_EP4]  = 0x60;\n\tregs[R_EP5]  = 0x80;\n\tregs[R_CPD]  = 0x80;\n\tregs[R_CD1]  = 0x00;\n\tregs[R_CD2]  = 0x00;\n\tregs[R_CD3]  = 0x00;\n\tregs[R_MPD]  = 0x00;\n\tregs[R_MD1]  = 0x00;\n\tregs[R_MD2]  = 0x00;\n\tregs[R_MD3]  = 0x00;\n\n\tswitch (priv->id) {\n\tcase TDA18271HDC1:\n\t\tregs[R_EB1]  = 0xff;\n\t\tbreak;\n\tcase TDA18271HDC2:\n\t\tregs[R_EB1]  = 0xfc;\n\t\tbreak;\n\t}\n\n\tregs[R_EB2]  = 0x01;\n\tregs[R_EB3]  = 0x84;\n\tregs[R_EB4]  = 0x41;\n\tregs[R_EB5]  = 0x01;\n\tregs[R_EB6]  = 0x84;\n\tregs[R_EB7]  = 0x40;\n\tregs[R_EB8]  = 0x07;\n\tregs[R_EB9]  = 0x00;\n\tregs[R_EB10] = 0x00;\n\tregs[R_EB11] = 0x96;\n\n\tswitch (priv->id) {\n\tcase TDA18271HDC1:\n\t\tregs[R_EB12] = 0x0f;\n\t\tbreak;\n\tcase TDA18271HDC2:\n\t\tregs[R_EB12] = 0x33;\n\t\tbreak;\n\t}\n\n\tregs[R_EB13] = 0xc1;\n\tregs[R_EB14] = 0x00;\n\tregs[R_EB15] = 0x8f;\n\tregs[R_EB16] = 0x00;\n\tregs[R_EB17] = 0x00;\n\n\tswitch (priv->id) {\n\tcase TDA18271HDC1:\n\t\tregs[R_EB18] = 0x00;\n\t\tbreak;\n\tcase TDA18271HDC2:\n\t\tregs[R_EB18] = 0x8c;\n\t\tbreak;\n\t}\n\n\tregs[R_EB19] = 0x00;\n\tregs[R_EB20] = 0x20;\n\n\tswitch (priv->id) {\n\tcase TDA18271HDC1:\n\t\tregs[R_EB21] = 0x33;\n\t\tbreak;\n\tcase TDA18271HDC2:\n\t\tregs[R_EB21] = 0xb3;\n\t\tbreak;\n\t}\n\n\tregs[R_EB22] = 0x48;\n\tregs[R_EB23] = 0xb0;\n\n\t__tda18271_write_regs(fe, 0x00, TDA18271_NUM_REGS, false);\n\n\t \n\tregs[R_EB17] = 0x00;\n\t__tda18271_write_regs(fe, R_EB17, 1, false);\n\tregs[R_EB17] = 0x03;\n\t__tda18271_write_regs(fe, R_EB17, 1, false);\n\tregs[R_EB17] = 0x43;\n\t__tda18271_write_regs(fe, R_EB17, 1, false);\n\tregs[R_EB17] = 0x4c;\n\t__tda18271_write_regs(fe, R_EB17, 1, false);\n\n\t \n\tif ((priv->id) == TDA18271HDC1) {\n\t\tregs[R_EB20] = 0xa0;\n\t\t__tda18271_write_regs(fe, R_EB20, 1, false);\n\t\tregs[R_EB20] = 0xa7;\n\t\t__tda18271_write_regs(fe, R_EB20, 1, false);\n\t\tregs[R_EB20] = 0xe7;\n\t\t__tda18271_write_regs(fe, R_EB20, 1, false);\n\t\tregs[R_EB20] = 0xec;\n\t\t__tda18271_write_regs(fe, R_EB20, 1, false);\n\t}\n\n\t \n\n\t \n\tregs[R_EP3] = 0x1f;\n\tregs[R_EP4] = 0x66;\n\tregs[R_EP5] = 0x81;\n\tregs[R_CPD] = 0xcc;\n\tregs[R_CD1] = 0x6c;\n\tregs[R_CD2] = 0x00;\n\tregs[R_CD3] = 0x00;\n\tregs[R_MPD] = 0xcd;\n\tregs[R_MD1] = 0x77;\n\tregs[R_MD2] = 0x08;\n\tregs[R_MD3] = 0x00;\n\n\t__tda18271_write_regs(fe, R_EP3, 11, false);\n\n\tif ((priv->id) == TDA18271HDC2) {\n\t\t \n\t\t__tda18271_charge_pump_source(fe, TDA18271_MAIN_PLL, 1, false);\n\t\tmsleep(1);\n\n\t\t \n\t\t__tda18271_charge_pump_source(fe, TDA18271_MAIN_PLL, 0, false);\n\t}\n\n\tmsleep(5);  \n\n\t \n\t__tda18271_write_regs(fe, R_EP1, 1, false);\n\tmsleep(5);  \n\n\tregs[R_EP5] = 0x85;\n\tregs[R_CPD] = 0xcb;\n\tregs[R_CD1] = 0x66;\n\tregs[R_CD2] = 0x70;\n\n\t__tda18271_write_regs(fe, R_EP3, 7, false);\n\tmsleep(5);  \n\n\t \n\t__tda18271_write_regs(fe, R_EP2, 1, false);\n\tmsleep(30);  \n\n\t \n\tregs[R_EP5] = 0x82;\n\tregs[R_CPD] = 0xa8;\n\tregs[R_CD2] = 0x00;\n\tregs[R_MPD] = 0xa9;\n\tregs[R_MD1] = 0x73;\n\tregs[R_MD2] = 0x1a;\n\n\t__tda18271_write_regs(fe, R_EP3, 11, false);\n\tmsleep(5);  \n\n\t \n\t__tda18271_write_regs(fe, R_EP1, 1, false);\n\tmsleep(5);  \n\n\tregs[R_EP5] = 0x86;\n\tregs[R_CPD] = 0xa8;\n\tregs[R_CD1] = 0x66;\n\tregs[R_CD2] = 0xa0;\n\n\t__tda18271_write_regs(fe, R_EP3, 7, false);\n\tmsleep(5);  \n\n\t \n\t__tda18271_write_regs(fe, R_EP2, 1, false);\n\tmsleep(30);  \n\n\t \n\tregs[R_EP5] = 0x83;\n\tregs[R_CPD] = 0x98;\n\tregs[R_CD1] = 0x65;\n\tregs[R_CD2] = 0x00;\n\tregs[R_MPD] = 0x99;\n\tregs[R_MD1] = 0x71;\n\tregs[R_MD2] = 0xcd;\n\n\t__tda18271_write_regs(fe, R_EP3, 11, false);\n\tmsleep(5);  \n\n\t \n\t__tda18271_write_regs(fe, R_EP1, 1, false);\n\tmsleep(5);  \n\n\tregs[R_EP5] = 0x87;\n\tregs[R_CD1] = 0x65;\n\tregs[R_CD2] = 0x50;\n\n\t__tda18271_write_regs(fe, R_EP3, 7, false);\n\tmsleep(5);  \n\n\t \n\t__tda18271_write_regs(fe, R_EP2, 1, false);\n\tmsleep(30);  \n\n\t \n\tregs[R_EP4] = 0x64;\n\t__tda18271_write_regs(fe, R_EP4, 1, false);\n\n\t \n\t__tda18271_write_regs(fe, R_EP1, 1, false);\n\n\ti2c_unlock_bus(priv->i2c_props.adap, I2C_LOCK_SEGMENT);\n\ttda18271_i2c_gate_ctrl(fe, 0);\n\n\treturn 0;\n}\n\n \n\n \n\nint tda18271_set_standby_mode(struct dvb_frontend *fe,\n\t\t\t      int sm, int sm_lt, int sm_xt)\n{\n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\n\tif (tda18271_debug & DBG_ADV)\n\t\ttda_dbg(\"sm = %d, sm_lt = %d, sm_xt = %d\\n\", sm, sm_lt, sm_xt);\n\n\tregs[R_EP3]  &= ~0xe0;  \n\tregs[R_EP3]  |= (sm    ? (1 << 7) : 0) |\n\t\t\t(sm_lt ? (1 << 6) : 0) |\n\t\t\t(sm_xt ? (1 << 5) : 0);\n\n\treturn tda18271_write_regs(fe, R_EP3, 1);\n}\n\n \n\nint tda18271_calc_main_pll(struct dvb_frontend *fe, u32 freq)\n{\n\t \n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tu8 d, pd;\n\tu32 div;\n\n\tint ret = tda18271_lookup_pll_map(fe, MAIN_PLL, &freq, &pd, &d);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\tregs[R_MPD]   = (0x7f & pd);\n\n\tdiv =  ((d * (freq / 1000)) << 7) / 125;\n\n\tregs[R_MD1]   = 0x7f & (div >> 16);\n\tregs[R_MD2]   = 0xff & (div >> 8);\n\tregs[R_MD3]   = 0xff & div;\nfail:\n\treturn ret;\n}\n\nint tda18271_calc_cal_pll(struct dvb_frontend *fe, u32 freq)\n{\n\t \n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tu8 d, pd;\n\tu32 div;\n\n\tint ret = tda18271_lookup_pll_map(fe, CAL_PLL, &freq, &pd, &d);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\tregs[R_CPD]   = pd;\n\n\tdiv =  ((d * (freq / 1000)) << 7) / 125;\n\n\tregs[R_CD1]   = 0x7f & (div >> 16);\n\tregs[R_CD2]   = 0xff & (div >> 8);\n\tregs[R_CD3]   = 0xff & div;\nfail:\n\treturn ret;\n}\n\n \n\nint tda18271_calc_bp_filter(struct dvb_frontend *fe, u32 *freq)\n{\n\t \n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tu8 val;\n\n\tint ret = tda18271_lookup_map(fe, BP_FILTER, freq, &val);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\tregs[R_EP1]  &= ~0x07;  \n\tregs[R_EP1]  |= (0x07 & val);\nfail:\n\treturn ret;\n}\n\nint tda18271_calc_km(struct dvb_frontend *fe, u32 *freq)\n{\n\t \n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tu8 val;\n\n\tint ret = tda18271_lookup_map(fe, RF_CAL_KMCO, freq, &val);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\tregs[R_EB13] &= ~0x7c;  \n\tregs[R_EB13] |= (0x7c & val);\nfail:\n\treturn ret;\n}\n\nint tda18271_calc_rf_band(struct dvb_frontend *fe, u32 *freq)\n{\n\t \n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tu8 val;\n\n\tint ret = tda18271_lookup_map(fe, RF_BAND, freq, &val);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\tregs[R_EP2]  &= ~0xe0;  \n\tregs[R_EP2]  |= (0xe0 & (val << 5));\nfail:\n\treturn ret;\n}\n\nint tda18271_calc_gain_taper(struct dvb_frontend *fe, u32 *freq)\n{\n\t \n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tu8 val;\n\n\tint ret = tda18271_lookup_map(fe, GAIN_TAPER, freq, &val);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\tregs[R_EP2]  &= ~0x1f;  \n\tregs[R_EP2]  |= (0x1f & val);\nfail:\n\treturn ret;\n}\n\nint tda18271_calc_ir_measure(struct dvb_frontend *fe, u32 *freq)\n{\n\t \n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tu8 val;\n\n\tint ret = tda18271_lookup_map(fe, IR_MEASURE, freq, &val);\n\tif (tda_fail(ret))\n\t\tgoto fail;\n\n\tregs[R_EP5] &= ~0x07;\n\tregs[R_EP5] |= (0x07 & val);\nfail:\n\treturn ret;\n}\n\nint tda18271_calc_rf_cal(struct dvb_frontend *fe, u32 *freq)\n{\n\t \n\tstruct tda18271_priv *priv = fe->tuner_priv;\n\tunsigned char *regs = priv->tda18271_regs;\n\tu8 val;\n\n\tint ret = tda18271_lookup_map(fe, RF_CAL, freq, &val);\n\t \n\tif (ret < 0)\n\t\tgoto fail;\n\n\tregs[R_EB14] = val;\nfail:\n\treturn ret;\n}\n\nvoid _tda_printk(struct tda18271_priv *state, const char *level,\n\t\t const char *func, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (state)\n\t\tprintk(\"%s%s: [%d-%04x|%c] %pV\",\n\t\t       level, func, i2c_adapter_id(state->i2c_props.adap),\n\t\t       state->i2c_props.addr,\n\t\t       (state->role == TDA18271_MASTER) ? 'M' : 'S',\n\t\t       &vaf);\n\telse\n\t\tprintk(\"%s%s: %pV\", level, func, &vaf);\n\n\tva_end(args);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}