{
  "module_name": "tuner-simple.c",
  "hash_id": "0d245239c67db176cc39cddc4c9c330599ccaed3442a25397841e97ee070c0ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/tuner-simple.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/videodev2.h>\n#include <media/tuner.h>\n#include <media/v4l2-common.h>\n#include <media/tuner-types.h>\n#include \"tuner-i2c.h\"\n#include \"tuner-simple.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable verbose debug messages\");\n\n#define TUNER_SIMPLE_MAX 64\nstatic unsigned int simple_devcount;\n\nstatic int offset;\nmodule_param(offset, int, 0664);\nMODULE_PARM_DESC(offset, \"Allows to specify an offset for tuner\");\n\nstatic unsigned int atv_input[TUNER_SIMPLE_MAX] = \\\n\t\t\t{ [0 ... (TUNER_SIMPLE_MAX-1)] = 0 };\nstatic unsigned int dtv_input[TUNER_SIMPLE_MAX] = \\\n\t\t\t{ [0 ... (TUNER_SIMPLE_MAX-1)] = 0 };\nmodule_param_array(atv_input, int, NULL, 0644);\nmodule_param_array(dtv_input, int, NULL, 0644);\nMODULE_PARM_DESC(atv_input, \"specify atv rf input, 0 for autoselect\");\nMODULE_PARM_DESC(dtv_input, \"specify dtv rf input, 0 for autoselect\");\n\n \n\n \n#define TEMIC_SET_PAL_I         0x05\n#define TEMIC_SET_PAL_DK        0x09\n#define TEMIC_SET_PAL_L         0x0a  \n#define TEMIC_SET_PAL_L2        0x0b  \n#define TEMIC_SET_PAL_BG        0x0c\n\n \n#define PHILIPS_SET_PAL_I\t0x01  \n#define PHILIPS_SET_PAL_BGDK\t0x09\n#define PHILIPS_SET_PAL_L2\t0x0a\n#define PHILIPS_SET_PAL_L\t0x0b\n\n \n#define PHILIPS_MF_SET_STD_BG\t0x01  \n#define PHILIPS_MF_SET_STD_L\t0x03  \n#define PHILIPS_MF_SET_STD_LC\t0x02  \n\n \n\n#define TUNER_RATIO_MASK        0x06  \n#define TUNER_RATIO_SELECT_50   0x00\n#define TUNER_RATIO_SELECT_32   0x02\n#define TUNER_RATIO_SELECT_166  0x04\n#define TUNER_RATIO_SELECT_62   0x06\n\n#define TUNER_CHARGE_PUMP       0x40   \n\n \n\n#define TUNER_POR\t  0x80\n#define TUNER_FL          0x40\n#define TUNER_MODE        0x38\n#define TUNER_AFC         0x07\n#define TUNER_SIGNAL      0x07\n#define TUNER_STEREO      0x10\n\n#define TUNER_PLL_LOCKED   0x40\n#define TUNER_STEREO_MK3   0x04\n\nstatic DEFINE_MUTEX(tuner_simple_list_mutex);\nstatic LIST_HEAD(hybrid_tuner_instance_list);\n\nstruct tuner_simple_priv {\n\tunsigned int nr;\n\tu16 last_div;\n\n\tstruct tuner_i2c_props i2c_props;\n\tstruct list_head hybrid_tuner_instance_list;\n\n\tunsigned int type;\n\tstruct tunertype *tun;\n\n\tu32 frequency;\n\tu32 bandwidth;\n\tbool radio_mode;\n};\n\n \n\nstatic int tuner_read_status(struct dvb_frontend *fe)\n{\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\tunsigned char byte;\n\n\tif (1 != tuner_i2c_xfer_recv(&priv->i2c_props, &byte, 1))\n\t\treturn 0;\n\n\treturn byte;\n}\n\nstatic inline int tuner_signal(const int status)\n{\n\treturn (status & TUNER_SIGNAL) << 13;\n}\n\nstatic inline int tuner_stereo(const int type, const int status)\n{\n\tswitch (type) {\n\tcase TUNER_PHILIPS_FM1216ME_MK3:\n\tcase TUNER_PHILIPS_FM1236_MK3:\n\tcase TUNER_PHILIPS_FM1256_IH3:\n\tcase TUNER_LG_NTSC_TAPE:\n\tcase TUNER_TCL_MF02GIP_5N:\n\t\treturn ((status & TUNER_SIGNAL) == TUNER_STEREO_MK3);\n\tcase TUNER_PHILIPS_FM1216MK5:\n\t\treturn status | TUNER_STEREO;\n\tdefault:\n\t\treturn status & TUNER_STEREO;\n\t}\n}\n\nstatic inline int tuner_islocked(const int status)\n{\n\treturn (status & TUNER_FL);\n}\n\nstatic inline int tuner_afcstatus(const int status)\n{\n\treturn (status & TUNER_AFC) - 2;\n}\n\n\nstatic int simple_get_status(struct dvb_frontend *fe, u32 *status)\n{\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\tint tuner_status;\n\n\tif (priv->i2c_props.adap == NULL)\n\t\treturn -EINVAL;\n\n\ttuner_status = tuner_read_status(fe);\n\n\t*status = 0;\n\n\tif (tuner_islocked(tuner_status))\n\t\t*status = TUNER_STATUS_LOCKED;\n\tif (tuner_stereo(priv->type, tuner_status))\n\t\t*status |= TUNER_STATUS_STEREO;\n\n\ttuner_dbg(\"AFC Status: %d\\n\", tuner_afcstatus(tuner_status));\n\n\treturn 0;\n}\n\nstatic int simple_get_rf_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\tint signal;\n\n\tif (priv->i2c_props.adap == NULL || !priv->radio_mode)\n\t\treturn -EINVAL;\n\n\tsignal = tuner_signal(tuner_read_status(fe));\n\n\t*strength = signal;\n\n\ttuner_dbg(\"Signal strength: %d\\n\", signal);\n\n\treturn 0;\n}\n\n \n\nstatic inline char *tuner_param_name(enum param_type type)\n{\n\tchar *name;\n\n\tswitch (type) {\n\tcase TUNER_PARAM_TYPE_RADIO:\n\t\tname = \"radio\";\n\t\tbreak;\n\tcase TUNER_PARAM_TYPE_PAL:\n\t\tname = \"pal\";\n\t\tbreak;\n\tcase TUNER_PARAM_TYPE_SECAM:\n\t\tname = \"secam\";\n\t\tbreak;\n\tcase TUNER_PARAM_TYPE_NTSC:\n\t\tname = \"ntsc\";\n\t\tbreak;\n\tcase TUNER_PARAM_TYPE_DIGITAL:\n\t\tname = \"digital\";\n\t\tbreak;\n\tdefault:\n\t\tname = \"unknown\";\n\t\tbreak;\n\t}\n\treturn name;\n}\n\nstatic struct tuner_params *simple_tuner_params(struct dvb_frontend *fe,\n\t\t\t\t\t\tenum param_type desired_type)\n{\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\tstruct tunertype *tun = priv->tun;\n\tint i;\n\n\tfor (i = 0; i < tun->count; i++)\n\t\tif (desired_type == tun->params[i].type)\n\t\t\tbreak;\n\n\t \n\tif (i == tun->count) {\n\t\ttuner_dbg(\"desired params (%s) undefined for tuner %d\\n\",\n\t\t\t  tuner_param_name(desired_type), priv->type);\n\t\ti = 0;\n\t}\n\n\ttuner_dbg(\"using tuner params #%d (%s)\\n\", i,\n\t\t  tuner_param_name(tun->params[i].type));\n\n\treturn &tun->params[i];\n}\n\nstatic int simple_config_lookup(struct dvb_frontend *fe,\n\t\t\t\tstruct tuner_params *t_params,\n\t\t\t\tunsigned *frequency, u8 *config, u8 *cb)\n{\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\tint i;\n\n\tfor (i = 0; i < t_params->count; i++) {\n\t\tif (*frequency > t_params->ranges[i].limit)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (i == t_params->count) {\n\t\ttuner_dbg(\"frequency out of range (%d > %d)\\n\",\n\t\t\t  *frequency, t_params->ranges[i - 1].limit);\n\t\t*frequency = t_params->ranges[--i].limit;\n\t}\n\t*config = t_params->ranges[i].config;\n\t*cb     = t_params->ranges[i].cb;\n\n\ttuner_dbg(\"freq = %d.%02d (%d), range = %d, config = 0x%02x, cb = 0x%02x\\n\",\n\t\t  *frequency / 16, *frequency % 16 * 100 / 16, *frequency,\n\t\t  i, *config, *cb);\n\n\treturn i;\n}\n\n \n\nstatic void simple_set_rf_input(struct dvb_frontend *fe,\n\t\t\t\tu8 *config, u8 *cb, unsigned int rf)\n{\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\n\tswitch (priv->type) {\n\tcase TUNER_PHILIPS_TUV1236D:\n\t\tswitch (rf) {\n\t\tcase 1:\n\t\t\t*cb |= 0x08;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*cb &= ~0x08;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TUNER_PHILIPS_FCV1236D:\n\t\tswitch (rf) {\n\t\tcase 1:\n\t\t\t*cb |= 0x01;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*cb &= ~0x01;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int simple_std_setup(struct dvb_frontend *fe,\n\t\t\t    struct analog_parameters *params,\n\t\t\t    u8 *config, u8 *cb)\n{\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\tint rc;\n\n\t \n\tswitch (priv->type) {\n\tcase TUNER_PHILIPS_SECAM:  \n\t\t \n\t\t \n\t\t \n\t\t*cb &= ~0x03;\n\t\tif (params->std & V4L2_STD_SECAM_L)\n\t\t\t \n\t\t\t*cb |= PHILIPS_MF_SET_STD_L;\n\t\telse if (params->std & V4L2_STD_SECAM_LC)\n\t\t\t*cb |= PHILIPS_MF_SET_STD_LC;\n\t\telse  \n\t\t\t*cb |= PHILIPS_MF_SET_STD_BG;\n\t\tbreak;\n\n\tcase TUNER_TEMIC_4046FM5:\n\t\t*cb &= ~0x0f;\n\n\t\tif (params->std & V4L2_STD_PAL_BG) {\n\t\t\t*cb |= TEMIC_SET_PAL_BG;\n\n\t\t} else if (params->std & V4L2_STD_PAL_I) {\n\t\t\t*cb |= TEMIC_SET_PAL_I;\n\n\t\t} else if (params->std & V4L2_STD_PAL_DK) {\n\t\t\t*cb |= TEMIC_SET_PAL_DK;\n\n\t\t} else if (params->std & V4L2_STD_SECAM_L) {\n\t\t\t*cb |= TEMIC_SET_PAL_L;\n\n\t\t}\n\t\tbreak;\n\n\tcase TUNER_PHILIPS_FQ1216ME:\n\t\t*cb &= ~0x0f;\n\n\t\tif (params->std & (V4L2_STD_PAL_BG|V4L2_STD_PAL_DK)) {\n\t\t\t*cb |= PHILIPS_SET_PAL_BGDK;\n\n\t\t} else if (params->std & V4L2_STD_PAL_I) {\n\t\t\t*cb |= PHILIPS_SET_PAL_I;\n\n\t\t} else if (params->std & V4L2_STD_SECAM_L) {\n\t\t\t*cb |= PHILIPS_SET_PAL_L;\n\n\t\t}\n\t\tbreak;\n\n\tcase TUNER_PHILIPS_FCV1236D:\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t*cb &= ~0x03;\n\t\tif (!(params->std & V4L2_STD_ATSC))\n\t\t\t*cb |= 2;\n\t\tbreak;\n\n\tcase TUNER_MICROTUNE_4042FI5:\n\t\t \n\t\t*config |= TUNER_CHARGE_PUMP;\n\t\tbreak;\n\n\tcase TUNER_PHILIPS_TUV1236D:\n\t{\n\t\tstruct tuner_i2c_props i2c = priv->i2c_props;\n\t\t \n\t\t \n\t\t \n\t\t \n\t\tu8 buffer[4] = { 0x14, 0x00, 0x17, 0x00};\n\t\t*cb &= ~0x40;\n\t\tif (params->std & V4L2_STD_ATSC) {\n\t\t\t*cb |= 0x40;\n\t\t\tbuffer[1] = 0x04;\n\t\t}\n\t\t \n\t\ti2c.addr = 0x0a;\n\t\trc = tuner_i2c_xfer_send(&i2c, &buffer[0], 2);\n\t\tif (2 != rc)\n\t\t\ttuner_warn(\"i2c i/o error: rc == %d (should be 2)\\n\",\n\t\t\t\t   rc);\n\t\trc = tuner_i2c_xfer_send(&i2c, &buffer[2], 2);\n\t\tif (2 != rc)\n\t\t\ttuner_warn(\"i2c i/o error: rc == %d (should be 2)\\n\",\n\t\t\t\t   rc);\n\t\tbreak;\n\t}\n\t}\n\tif (atv_input[priv->nr])\n\t\tsimple_set_rf_input(fe, config, cb, atv_input[priv->nr]);\n\n\treturn 0;\n}\n\nstatic int simple_set_aux_byte(struct dvb_frontend *fe, u8 config, u8 aux)\n{\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\tint rc;\n\tu8 buffer[2];\n\n\tbuffer[0] = (config & ~0x38) | 0x18;\n\tbuffer[1] = aux;\n\n\ttuner_dbg(\"setting aux byte: 0x%02x 0x%02x\\n\", buffer[0], buffer[1]);\n\n\trc = tuner_i2c_xfer_send(&priv->i2c_props, buffer, 2);\n\tif (2 != rc)\n\t\ttuner_warn(\"i2c i/o error: rc == %d (should be 2)\\n\", rc);\n\n\treturn rc == 2 ? 0 : rc;\n}\n\nstatic int simple_post_tune(struct dvb_frontend *fe, u8 *buffer,\n\t\t\t    u16 div, u8 config, u8 cb)\n{\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\tint rc;\n\n\tswitch (priv->type) {\n\tcase TUNER_LG_TDVS_H06XF:\n\t\tsimple_set_aux_byte(fe, config, 0x20);\n\t\tbreak;\n\tcase TUNER_PHILIPS_FQ1216LME_MK3:\n\t\tsimple_set_aux_byte(fe, config, 0x60);  \n\t\tbreak;\n\tcase TUNER_MICROTUNE_4042FI5:\n\t{\n\t\t \n\t\tunsigned long timeout = jiffies + msecs_to_jiffies(1);\n\t\tu8 status_byte = 0;\n\n\t\t \n\t\tfor (;;) {\n\t\t\tif (time_after(jiffies, timeout))\n\t\t\t\treturn 0;\n\t\t\trc = tuner_i2c_xfer_recv(&priv->i2c_props,\n\t\t\t\t\t\t &status_byte, 1);\n\t\t\tif (1 != rc) {\n\t\t\t\ttuner_warn(\"i2c i/o read error: rc == %d (should be 1)\\n\",\n\t\t\t\t\t   rc);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (status_byte & TUNER_PLL_LOCKED)\n\t\t\t\tbreak;\n\t\t\tudelay(10);\n\t\t}\n\n\t\t \n\t\tconfig &= ~TUNER_CHARGE_PUMP;\n\t\tbuffer[0] = (div>>8) & 0x7f;\n\t\tbuffer[1] = div      & 0xff;\n\t\tbuffer[2] = config;\n\t\tbuffer[3] = cb;\n\t\ttuner_dbg(\"tv 0x%02x 0x%02x 0x%02x 0x%02x\\n\",\n\t\t\t  buffer[0], buffer[1], buffer[2], buffer[3]);\n\n\t\trc = tuner_i2c_xfer_send(&priv->i2c_props, buffer, 4);\n\t\tif (4 != rc)\n\t\t\ttuner_warn(\"i2c i/o error: rc == %d (should be 4)\\n\",\n\t\t\t\t   rc);\n\t\tbreak;\n\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int simple_radio_bandswitch(struct dvb_frontend *fe, u8 *buffer)\n{\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\n\tswitch (priv->type) {\n\tcase TUNER_TENA_9533_DI:\n\tcase TUNER_YMEC_TVF_5533MF:\n\t\ttuner_dbg(\"This tuner doesn't have FM. Most cards have a TEA5767 for FM\\n\");\n\t\treturn -EINVAL;\n\tcase TUNER_PHILIPS_FM1216ME_MK3:\n\tcase TUNER_PHILIPS_FM1236_MK3:\n\tcase TUNER_PHILIPS_FMD1216ME_MK3:\n\tcase TUNER_PHILIPS_FMD1216MEX_MK3:\n\tcase TUNER_LG_NTSC_TAPE:\n\tcase TUNER_PHILIPS_FM1256_IH3:\n\tcase TUNER_TCL_MF02GIP_5N:\n\t\tbuffer[3] = 0x19;\n\t\tbreak;\n\tcase TUNER_PHILIPS_FM1216MK5:\n\t\tbuffer[2] = 0x88;\n\t\tbuffer[3] = 0x09;\n\t\tbreak;\n\tcase TUNER_TNF_5335MF:\n\t\tbuffer[3] = 0x11;\n\t\tbreak;\n\tcase TUNER_LG_PAL_FM:\n\t\tbuffer[3] = 0xa5;\n\t\tbreak;\n\tcase TUNER_THOMSON_DTT761X:\n\t\tbuffer[3] = 0x39;\n\t\tbreak;\n\tcase TUNER_PHILIPS_FQ1216LME_MK3:\n\tcase TUNER_PHILIPS_FQ1236_MK5:\n\t\ttuner_err(\"This tuner doesn't have FM\\n\");\n\t\t \n\t\tbuffer[3] = 0x01;\n\t\tbreak;\n\tcase TUNER_MICROTUNE_4049FM5:\n\tdefault:\n\t\tbuffer[3] = 0xa4;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int simple_set_tv_freq(struct dvb_frontend *fe,\n\t\t\t      struct analog_parameters *params)\n{\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\tu8 config, cb;\n\tu16 div;\n\tu8 buffer[4];\n\tint rc, IFPCoff, i;\n\tenum param_type desired_type;\n\tstruct tuner_params *t_params;\n\n\t \n\n\tif (params->std == V4L2_STD_NTSC_M_JP) {\n\t\tIFPCoff      = 940;\n\t\tdesired_type = TUNER_PARAM_TYPE_NTSC;\n\t} else if ((params->std & V4L2_STD_MN) &&\n\t\t  !(params->std & ~V4L2_STD_MN)) {\n\t\tIFPCoff      = 732;\n\t\tdesired_type = TUNER_PARAM_TYPE_NTSC;\n\t} else if (params->std == V4L2_STD_SECAM_LC) {\n\t\tIFPCoff      = 543;\n\t\tdesired_type = TUNER_PARAM_TYPE_SECAM;\n\t} else {\n\t\tIFPCoff      = 623;\n\t\tdesired_type = TUNER_PARAM_TYPE_PAL;\n\t}\n\n\tt_params = simple_tuner_params(fe, desired_type);\n\n\ti = simple_config_lookup(fe, t_params, &params->frequency,\n\t\t\t\t &config, &cb);\n\n\tdiv = params->frequency + IFPCoff + offset;\n\n\ttuner_dbg(\"Freq= %d.%02d MHz, V_IF=%d.%02d MHz, Offset=%d.%02d MHz, div=%0d\\n\",\n\t\t  params->frequency / 16, params->frequency % 16 * 100 / 16,\n\t\t  IFPCoff / 16, IFPCoff % 16 * 100 / 16,\n\t\t  offset / 16, offset % 16 * 100 / 16, div);\n\n\t \n\tsimple_std_setup(fe, params, &config, &cb);\n\n\tif (t_params->cb_first_if_lower_freq && div < priv->last_div) {\n\t\tbuffer[0] = config;\n\t\tbuffer[1] = cb;\n\t\tbuffer[2] = (div>>8) & 0x7f;\n\t\tbuffer[3] = div      & 0xff;\n\t} else {\n\t\tbuffer[0] = (div>>8) & 0x7f;\n\t\tbuffer[1] = div      & 0xff;\n\t\tbuffer[2] = config;\n\t\tbuffer[3] = cb;\n\t}\n\tpriv->last_div = div;\n\tif (t_params->has_tda9887) {\n\t\tstruct v4l2_priv_tun_config tda9887_cfg;\n\t\tint tda_config = 0;\n\t\tint is_secam_l = (params->std & (V4L2_STD_SECAM_L |\n\t\t\t\t\t\t V4L2_STD_SECAM_LC)) &&\n\t\t\t!(params->std & ~(V4L2_STD_SECAM_L |\n\t\t\t\t\t  V4L2_STD_SECAM_LC));\n\n\t\ttda9887_cfg.tuner = TUNER_TDA9887;\n\t\ttda9887_cfg.priv  = &tda_config;\n\n\t\tif (params->std == V4L2_STD_SECAM_LC) {\n\t\t\tif (t_params->port1_active ^ t_params->port1_invert_for_secam_lc)\n\t\t\t\ttda_config |= TDA9887_PORT1_ACTIVE;\n\t\t\tif (t_params->port2_active ^ t_params->port2_invert_for_secam_lc)\n\t\t\t\ttda_config |= TDA9887_PORT2_ACTIVE;\n\t\t} else {\n\t\t\tif (t_params->port1_active)\n\t\t\t\ttda_config |= TDA9887_PORT1_ACTIVE;\n\t\t\tif (t_params->port2_active)\n\t\t\t\ttda_config |= TDA9887_PORT2_ACTIVE;\n\t\t}\n\t\tif (t_params->intercarrier_mode)\n\t\t\ttda_config |= TDA9887_INTERCARRIER;\n\t\tif (is_secam_l) {\n\t\t\tif (i == 0 && t_params->default_top_secam_low)\n\t\t\t\ttda_config |= TDA9887_TOP(t_params->default_top_secam_low);\n\t\t\telse if (i == 1 && t_params->default_top_secam_mid)\n\t\t\t\ttda_config |= TDA9887_TOP(t_params->default_top_secam_mid);\n\t\t\telse if (t_params->default_top_secam_high)\n\t\t\t\ttda_config |= TDA9887_TOP(t_params->default_top_secam_high);\n\t\t} else {\n\t\t\tif (i == 0 && t_params->default_top_low)\n\t\t\t\ttda_config |= TDA9887_TOP(t_params->default_top_low);\n\t\t\telse if (i == 1 && t_params->default_top_mid)\n\t\t\t\ttda_config |= TDA9887_TOP(t_params->default_top_mid);\n\t\t\telse if (t_params->default_top_high)\n\t\t\t\ttda_config |= TDA9887_TOP(t_params->default_top_high);\n\t\t}\n\t\tif (t_params->default_pll_gating_18)\n\t\t\ttda_config |= TDA9887_GATING_18;\n\t\ti2c_clients_command(priv->i2c_props.adap, TUNER_SET_CONFIG,\n\t\t\t\t    &tda9887_cfg);\n\t}\n\ttuner_dbg(\"tv 0x%02x 0x%02x 0x%02x 0x%02x\\n\",\n\t\t  buffer[0], buffer[1], buffer[2], buffer[3]);\n\n\trc = tuner_i2c_xfer_send(&priv->i2c_props, buffer, 4);\n\tif (4 != rc)\n\t\ttuner_warn(\"i2c i/o error: rc == %d (should be 4)\\n\", rc);\n\n\tsimple_post_tune(fe, &buffer[0], div, config, cb);\n\n\treturn 0;\n}\n\nstatic int simple_set_radio_freq(struct dvb_frontend *fe,\n\t\t\t\t struct analog_parameters *params)\n{\n\tstruct tunertype *tun;\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\tu8 buffer[4];\n\tu16 div;\n\tint rc, j;\n\tstruct tuner_params *t_params;\n\tunsigned int freq = params->frequency;\n\tbool mono = params->audmode == V4L2_TUNER_MODE_MONO;\n\n\ttun = priv->tun;\n\n\tfor (j = tun->count-1; j > 0; j--)\n\t\tif (tun->params[j].type == TUNER_PARAM_TYPE_RADIO)\n\t\t\tbreak;\n\t \n\tt_params = &tun->params[j];\n\n\t \n\tswitch (t_params->radio_if) {\n\tcase 0:  \n\t\tfreq += (unsigned int)(10.7*16000);\n\t\tbreak;\n\tcase 1:  \n\t\tfreq += (unsigned int)(33.3*16000);\n\t\tbreak;\n\tcase 2:  \n\t\tfreq += (unsigned int)(41.3*16000);\n\t\tbreak;\n\tdefault:\n\t\ttuner_warn(\"Unsupported radio_if value %d\\n\",\n\t\t\t   t_params->radio_if);\n\t\treturn 0;\n\t}\n\n\tbuffer[2] = (t_params->ranges[0].config & ~TUNER_RATIO_MASK) |\n\t\t    TUNER_RATIO_SELECT_50;  \n\n\t \n\tif (simple_radio_bandswitch(fe, &buffer[0]))\n\t\treturn 0;\n\n\t \n\tdiv = (freq + 400) / 800;\n\n\tif (t_params->cb_first_if_lower_freq && div < priv->last_div) {\n\t\tbuffer[0] = buffer[2];\n\t\tbuffer[1] = buffer[3];\n\t\tbuffer[2] = (div>>8) & 0x7f;\n\t\tbuffer[3] = div      & 0xff;\n\t} else {\n\t\tbuffer[0] = (div>>8) & 0x7f;\n\t\tbuffer[1] = div      & 0xff;\n\t}\n\n\ttuner_dbg(\"radio 0x%02x 0x%02x 0x%02x 0x%02x\\n\",\n\t       buffer[0], buffer[1], buffer[2], buffer[3]);\n\tpriv->last_div = div;\n\n\tif (t_params->has_tda9887) {\n\t\tint config = 0;\n\t\tstruct v4l2_priv_tun_config tda9887_cfg;\n\n\t\ttda9887_cfg.tuner = TUNER_TDA9887;\n\t\ttda9887_cfg.priv = &config;\n\n\t\tif (t_params->port1_active &&\n\t\t    !t_params->port1_fm_high_sensitivity)\n\t\t\tconfig |= TDA9887_PORT1_ACTIVE;\n\t\tif (t_params->port2_active &&\n\t\t    !t_params->port2_fm_high_sensitivity)\n\t\t\tconfig |= TDA9887_PORT2_ACTIVE;\n\t\tif (t_params->intercarrier_mode)\n\t\t\tconfig |= TDA9887_INTERCARRIER;\n\t\tif (t_params->port1_set_for_fm_mono && mono)\n\t\t\tconfig &= ~TDA9887_PORT1_ACTIVE;\n\t\tif (t_params->fm_gain_normal)\n\t\t\tconfig |= TDA9887_GAIN_NORMAL;\n\t\tif (t_params->radio_if == 2)\n\t\t\tconfig |= TDA9887_RIF_41_3;\n\t\ti2c_clients_command(priv->i2c_props.adap, TUNER_SET_CONFIG,\n\t\t\t\t    &tda9887_cfg);\n\t}\n\trc = tuner_i2c_xfer_send(&priv->i2c_props, buffer, 4);\n\tif (4 != rc)\n\t\ttuner_warn(\"i2c i/o error: rc == %d (should be 4)\\n\", rc);\n\n\t \n\tswitch (priv->type) {\n\tcase TUNER_PHILIPS_FM1216ME_MK3:\n\t\tbuffer[2] = 0x98;\n\t\tbuffer[3] = 0x20;  \n\t\trc = tuner_i2c_xfer_send(&priv->i2c_props, buffer, 4);\n\t\tif (4 != rc)\n\t\t\ttuner_warn(\"i2c i/o error: rc == %d (should be 4)\\n\", rc);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int simple_set_params(struct dvb_frontend *fe,\n\t\t\t     struct analog_parameters *params)\n{\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\tint ret = -EINVAL;\n\n\tif (priv->i2c_props.adap == NULL)\n\t\treturn -EINVAL;\n\n\tswitch (params->mode) {\n\tcase V4L2_TUNER_RADIO:\n\t\tpriv->radio_mode = true;\n\t\tret = simple_set_radio_freq(fe, params);\n\t\tpriv->frequency = params->frequency * 125 / 2;\n\t\tbreak;\n\tcase V4L2_TUNER_ANALOG_TV:\n\tcase V4L2_TUNER_DIGITAL_TV:\n\t\tpriv->radio_mode = false;\n\t\tret = simple_set_tv_freq(fe, params);\n\t\tpriv->frequency = params->frequency * 62500;\n\t\tbreak;\n\t}\n\tpriv->bandwidth = 0;\n\n\treturn ret;\n}\n\nstatic void simple_set_dvb(struct dvb_frontend *fe, u8 *buf,\n\t\t\t   const u32 delsys,\n\t\t\t   const u32 frequency,\n\t\t\t   const u32 bandwidth)\n{\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\n\tswitch (priv->type) {\n\tcase TUNER_PHILIPS_FMD1216ME_MK3:\n\tcase TUNER_PHILIPS_FMD1216MEX_MK3:\n\t\tif (bandwidth == 8000000 &&\n\t\t    frequency >= 158870000)\n\t\t\tbuf[3] |= 0x08;\n\t\tbreak;\n\tcase TUNER_PHILIPS_TD1316:\n\t\t \n\t\tbuf[3] |= (frequency < 161000000) ? 1 :\n\t\t\t  (frequency < 444000000) ? 2 : 4;\n\n\t\t \n\t\tif (bandwidth == 8000000)\n\t\t\tbuf[3] |= 1 << 3;\n\t\tbreak;\n\tcase TUNER_PHILIPS_TUV1236D:\n\tcase TUNER_PHILIPS_FCV1236D:\n\t{\n\t\tunsigned int new_rf;\n\n\t\tif (dtv_input[priv->nr])\n\t\t\tnew_rf = dtv_input[priv->nr];\n\t\telse\n\t\t\tswitch (delsys) {\n\t\t\tcase SYS_DVBC_ANNEX_B:\n\t\t\t\tnew_rf = 1;\n\t\t\t\tbreak;\n\t\t\tcase SYS_ATSC:\n\t\t\tdefault:\n\t\t\t\tnew_rf = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsimple_set_rf_input(fe, &buf[2], &buf[3], new_rf);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic u32 simple_dvb_configure(struct dvb_frontend *fe, u8 *buf,\n\t\t\t\tconst u32 delsys,\n\t\t\t\tconst u32 freq,\n\t\t\t\tconst u32 bw)\n{\n\t \n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\tstruct tunertype *tun = priv->tun;\n\tstruct tuner_params *t_params;\n\tu8 config, cb;\n\tu32 div;\n\tint ret;\n\tu32 frequency = freq / 62500;\n\n\tif (!tun->stepsize) {\n\t\t \n\t\ttuner_err(\"attempt to treat tuner %d (%s) as digital tuner without stepsize defined.\\n\",\n\t\t\t  priv->type, priv->tun->name);\n\t\treturn 0;  \n\t}\n\n\tt_params = simple_tuner_params(fe, TUNER_PARAM_TYPE_DIGITAL);\n\tret = simple_config_lookup(fe, t_params, &frequency, &config, &cb);\n\tif (ret < 0)\n\t\treturn 0;  \n\n\tdiv = ((frequency + t_params->iffreq) * 62500 + offset +\n\t       tun->stepsize/2) / tun->stepsize;\n\n\tbuf[0] = div >> 8;\n\tbuf[1] = div & 0xff;\n\tbuf[2] = config;\n\tbuf[3] = cb;\n\n\tsimple_set_dvb(fe, buf, delsys, freq, bw);\n\n\ttuner_dbg(\"%s: div=%d | buf=0x%02x,0x%02x,0x%02x,0x%02x\\n\",\n\t\t  tun->name, div, buf[0], buf[1], buf[2], buf[3]);\n\n\t \n\treturn (div * tun->stepsize) - t_params->iffreq;\n}\n\nstatic int simple_dvb_calc_regs(struct dvb_frontend *fe,\n\t\t\t\tu8 *buf, int buf_len)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 delsys = c->delivery_system;\n\tu32 bw = c->bandwidth_hz;\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\tu32 frequency;\n\n\tif (buf_len < 5)\n\t\treturn -EINVAL;\n\n\tfrequency = simple_dvb_configure(fe, buf+1, delsys, c->frequency, bw);\n\tif (frequency == 0)\n\t\treturn -EINVAL;\n\n\tbuf[0] = priv->i2c_props.addr;\n\n\tpriv->frequency = frequency;\n\tpriv->bandwidth = c->bandwidth_hz;\n\n\treturn 5;\n}\n\nstatic int simple_dvb_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 delsys = c->delivery_system;\n\tu32 bw = c->bandwidth_hz;\n\tu32 freq = c->frequency;\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\tu32 frequency;\n\tu32 prev_freq, prev_bw;\n\tint ret;\n\tu8 buf[5];\n\n\tif (priv->i2c_props.adap == NULL)\n\t\treturn -EINVAL;\n\n\tprev_freq = priv->frequency;\n\tprev_bw   = priv->bandwidth;\n\n\tfrequency = simple_dvb_configure(fe, buf+1, delsys, freq, bw);\n\tif (frequency == 0)\n\t\treturn -EINVAL;\n\n\tbuf[0] = priv->i2c_props.addr;\n\n\tpriv->frequency = frequency;\n\tpriv->bandwidth = bw;\n\n\t \n\tif (fe->ops.analog_ops.standby)\n\t\tfe->ops.analog_ops.standby(fe);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t \n\tret = tuner_i2c_xfer_send(&priv->i2c_props, buf+1, 4);\n\tif (ret != 4)\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\t \n\tpriv->frequency = prev_freq;\n\tpriv->bandwidth = prev_bw;\n\n\treturn ret;\n}\n\nstatic int simple_init(struct dvb_frontend *fe)\n{\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\n\tif (priv->i2c_props.adap == NULL)\n\t\treturn -EINVAL;\n\n\tif (priv->tun->initdata) {\n\t\tint ret;\n\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t\tret = tuner_i2c_xfer_send(&priv->i2c_props,\n\t\t\t\t\t  priv->tun->initdata + 1,\n\t\t\t\t\t  priv->tun->initdata[0]);\n\t\tif (ret != priv->tun->initdata[0])\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int simple_sleep(struct dvb_frontend *fe)\n{\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\n\tif (priv->i2c_props.adap == NULL)\n\t\treturn -EINVAL;\n\n\tif (priv->tun->sleepdata) {\n\t\tint ret;\n\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t\tret = tuner_i2c_xfer_send(&priv->i2c_props,\n\t\t\t\t\t  priv->tun->sleepdata + 1,\n\t\t\t\t\t  priv->tun->sleepdata[0]);\n\t\tif (ret != priv->tun->sleepdata[0])\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void simple_release(struct dvb_frontend *fe)\n{\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\n\tmutex_lock(&tuner_simple_list_mutex);\n\n\tif (priv)\n\t\thybrid_tuner_release_state(priv);\n\n\tmutex_unlock(&tuner_simple_list_mutex);\n\n\tfe->tuner_priv = NULL;\n}\n\nstatic int simple_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\t*frequency = priv->frequency;\n\treturn 0;\n}\n\nstatic int simple_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\n{\n\tstruct tuner_simple_priv *priv = fe->tuner_priv;\n\t*bandwidth = priv->bandwidth;\n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops simple_tuner_ops = {\n\t.init              = simple_init,\n\t.sleep             = simple_sleep,\n\t.set_analog_params = simple_set_params,\n\t.set_params        = simple_dvb_set_params,\n\t.calc_regs         = simple_dvb_calc_regs,\n\t.release           = simple_release,\n\t.get_frequency     = simple_get_frequency,\n\t.get_bandwidth     = simple_get_bandwidth,\n\t.get_status        = simple_get_status,\n\t.get_rf_strength   = simple_get_rf_strength,\n};\n\nstruct dvb_frontend *simple_tuner_attach(struct dvb_frontend *fe,\n\t\t\t\t\t struct i2c_adapter *i2c_adap,\n\t\t\t\t\t u8 i2c_addr,\n\t\t\t\t\t unsigned int type)\n{\n\tstruct tuner_simple_priv *priv = NULL;\n\tint instance;\n\n\tif (type >= tuner_count) {\n\t\tprintk(KERN_WARNING \"%s: invalid tuner type: %d (max: %d)\\n\",\n\t\t       __func__, type, tuner_count-1);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (i2c_adap != NULL) {\n\t\tu8 b[1];\n\t\tstruct i2c_msg msg = {\n\t\t\t.addr = i2c_addr, .flags = I2C_M_RD,\n\t\t\t.buf = b, .len = 1,\n\t\t};\n\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t\tif (1 != i2c_transfer(i2c_adap, &msg, 1))\n\t\t\tprintk(KERN_WARNING \"tuner-simple %d-%04x: unable to probe %s, proceeding anyway.\",\n\t\t\t       i2c_adapter_id(i2c_adap), i2c_addr,\n\t\t\t       tuners[type].name);\n\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\tmutex_lock(&tuner_simple_list_mutex);\n\n\tinstance = hybrid_tuner_request_state(struct tuner_simple_priv, priv,\n\t\t\t\t\t      hybrid_tuner_instance_list,\n\t\t\t\t\t      i2c_adap, i2c_addr,\n\t\t\t\t\t      \"tuner-simple\");\n\tswitch (instance) {\n\tcase 0:\n\t\tmutex_unlock(&tuner_simple_list_mutex);\n\t\treturn NULL;\n\tcase 1:\n\t\tfe->tuner_priv = priv;\n\n\t\tpriv->type = type;\n\t\tpriv->tun  = &tuners[type];\n\t\tpriv->nr   = simple_devcount++;\n\t\tbreak;\n\tdefault:\n\t\tfe->tuner_priv = priv;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&tuner_simple_list_mutex);\n\n\tmemcpy(&fe->ops.tuner_ops, &simple_tuner_ops,\n\t       sizeof(struct dvb_tuner_ops));\n\n\tif (type != priv->type)\n\t\ttuner_warn(\"couldn't set type to %d. Using %d (%s) instead\\n\",\n\t\t\t    type, priv->type, priv->tun->name);\n\telse\n\t\ttuner_info(\"type set to %d (%s)\\n\",\n\t\t\t   priv->type, priv->tun->name);\n\n\tif ((debug) || ((atv_input[priv->nr] > 0) ||\n\t\t\t(dtv_input[priv->nr] > 0))) {\n\t\tif (0 == atv_input[priv->nr])\n\t\t\ttuner_info(\"tuner %d atv rf input will be autoselected\\n\",\n\t\t\t\t   priv->nr);\n\t\telse\n\t\t\ttuner_info(\"tuner %d atv rf input will be set to input %d (insmod option)\\n\",\n\t\t\t\t   priv->nr, atv_input[priv->nr]);\n\t\tif (0 == dtv_input[priv->nr])\n\t\t\ttuner_info(\"tuner %d dtv rf input will be autoselected\\n\",\n\t\t\t\t   priv->nr);\n\t\telse\n\t\t\ttuner_info(\"tuner %d dtv rf input will be set to input %d (insmod option)\\n\",\n\t\t\t\t   priv->nr, dtv_input[priv->nr]);\n\t}\n\n\tstrscpy(fe->ops.tuner_ops.info.name, priv->tun->name,\n\t\tsizeof(fe->ops.tuner_ops.info.name));\n\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(simple_tuner_attach);\n\nMODULE_DESCRIPTION(\"Simple 4-control-bytes style tuner driver\");\nMODULE_AUTHOR(\"Ralph Metzler, Gerd Knorr, Gunther Mayer\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}