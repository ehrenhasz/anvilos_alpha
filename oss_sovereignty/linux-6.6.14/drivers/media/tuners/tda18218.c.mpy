{
  "module_name": "tda18218.c",
  "hash_id": "7fa824b0cba1c57cddf01e9d58087a990630537620ef44272e61a3e974743675",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/tda18218.c",
  "human_readable_source": "\n \n\n#include \"tda18218_priv.h\"\n\n \n#define MAX_XFER_SIZE  64\n\n \nstatic int tda18218_wr_regs(struct tda18218_priv *priv, u8 reg, u8 *val, u8 len)\n{\n\tint ret = 0, len2, remaining;\n\tu8 buf[MAX_XFER_SIZE];\n\tstruct i2c_msg msg[1] = {\n\t\t{\n\t\t\t.addr = priv->cfg->i2c_address,\n\t\t\t.flags = 0,\n\t\t\t.buf = buf,\n\t\t}\n\t};\n\n\tif (1 + len > sizeof(buf)) {\n\t\tdev_warn(&priv->i2c->dev,\n\t\t\t \"%s: i2c wr reg=%04x: len=%d is too big!\\n\",\n\t\t\t KBUILD_MODNAME, reg, len);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (remaining = len; remaining > 0;\n\t\t\tremaining -= (priv->cfg->i2c_wr_max - 1)) {\n\t\tlen2 = remaining;\n\t\tif (len2 > (priv->cfg->i2c_wr_max - 1))\n\t\t\tlen2 = (priv->cfg->i2c_wr_max - 1);\n\n\t\tmsg[0].len = 1 + len2;\n\t\tbuf[0] = reg + len - remaining;\n\t\tmemcpy(&buf[1], &val[len - remaining], len2);\n\n\t\tret = i2c_transfer(priv->i2c, msg, 1);\n\t\tif (ret != 1)\n\t\t\tbreak;\n\t}\n\n\tif (ret == 1) {\n\t\tret = 0;\n\t} else {\n\t\tdev_warn(&priv->i2c->dev, \"%s: i2c wr failed=%d reg=%02x \" \\\n\t\t\t\t\"len=%d\\n\", KBUILD_MODNAME, ret, reg, len);\n\t\tret = -EREMOTEIO;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int tda18218_rd_regs(struct tda18218_priv *priv, u8 reg, u8 *val, u8 len)\n{\n\tint ret;\n\tu8 buf[MAX_XFER_SIZE];  \n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = priv->cfg->i2c_address,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = \"\\x00\",\n\t\t}, {\n\t\t\t.addr = priv->cfg->i2c_address,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = reg + len,\n\t\t\t.buf = buf,\n\t\t}\n\t};\n\n\tif (reg + len > sizeof(buf)) {\n\t\tdev_warn(&priv->i2c->dev,\n\t\t\t \"%s: i2c wr reg=%04x: len=%d is too big!\\n\",\n\t\t\t KBUILD_MODNAME, reg, len);\n\t\treturn -EINVAL;\n\t}\n\n\tret = i2c_transfer(priv->i2c, msg, 2);\n\tif (ret == 2) {\n\t\tmemcpy(val, &buf[reg], len);\n\t\tret = 0;\n\t} else {\n\t\tdev_warn(&priv->i2c->dev, \"%s: i2c rd failed=%d reg=%02x \" \\\n\t\t\t\t\"len=%d\\n\", KBUILD_MODNAME, ret, reg, len);\n\t\tret = -EREMOTEIO;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int tda18218_wr_reg(struct tda18218_priv *priv, u8 reg, u8 val)\n{\n\treturn tda18218_wr_regs(priv, reg, &val, 1);\n}\n\n \n\nstatic int tda18218_rd_reg(struct tda18218_priv *priv, u8 reg, u8 *val)\n{\n\treturn tda18218_rd_regs(priv, reg, val, 1);\n}\n\nstatic int tda18218_set_params(struct dvb_frontend *fe)\n{\n\tstruct tda18218_priv *priv = fe->tuner_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 bw = c->bandwidth_hz;\n\tint ret;\n\tu8 buf[3], i, BP_Filter, LP_Fc;\n\tu32 LO_Frac;\n\t \n\tu8 agc[][2] = {\n\t\t{ R20_AGC11, 0x60 },\n\t\t{ R23_AGC21, 0x02 },\n\t\t{ R20_AGC11, 0xa0 },\n\t\t{ R23_AGC21, 0x09 },\n\t\t{ R20_AGC11, 0xe0 },\n\t\t{ R23_AGC21, 0x0c },\n\t\t{ R20_AGC11, 0x40 },\n\t\t{ R23_AGC21, 0x01 },\n\t\t{ R20_AGC11, 0x80 },\n\t\t{ R23_AGC21, 0x08 },\n\t\t{ R20_AGC11, 0xc0 },\n\t\t{ R23_AGC21, 0x0b },\n\t\t{ R24_AGC22, 0x1c },\n\t\t{ R24_AGC22, 0x0c },\n\t};\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\t \n\tif (bw <= 6000000) {\n\t\tLP_Fc = 0;\n\t\tpriv->if_frequency = 3000000;\n\t} else if (bw <= 7000000) {\n\t\tLP_Fc = 1;\n\t\tpriv->if_frequency = 3500000;\n\t} else {\n\t\tLP_Fc = 2;\n\t\tpriv->if_frequency = 4000000;\n\t}\n\n\tLO_Frac = c->frequency + priv->if_frequency;\n\n\t \n\tif (LO_Frac < 188000000)\n\t\tBP_Filter = 3;\n\telse if (LO_Frac < 253000000)\n\t\tBP_Filter = 4;\n\telse if (LO_Frac < 343000000)\n\t\tBP_Filter = 5;\n\telse\n\t\tBP_Filter = 6;\n\n\tbuf[0] = (priv->regs[R1A_IF1] & ~7) | BP_Filter;  \n\tbuf[1] = (priv->regs[R1B_IF2] & ~3) | LP_Fc;  \n\tbuf[2] = priv->regs[R1C_AGC2B];\n\tret = tda18218_wr_regs(priv, R1A_IF1, buf, 3);\n\tif (ret)\n\t\tgoto error;\n\n\tbuf[0] = (LO_Frac / 1000) >> 12;  \n\tbuf[1] = (LO_Frac / 1000) >> 4;  \n\tbuf[2] = (LO_Frac / 1000) << 4 |\n\t\t(priv->regs[R0C_MD5] & 0x0f);  \n\tret = tda18218_wr_regs(priv, R0A_MD3, buf, 3);\n\tif (ret)\n\t\tgoto error;\n\n\tbuf[0] = priv->regs[R0F_MD8] | (1 << 6);  \n\tret = tda18218_wr_regs(priv, R0F_MD8, buf, 1);\n\tif (ret)\n\t\tgoto error;\n\n\tbuf[0] = priv->regs[R0F_MD8] & ~(1 << 6);  \n\tret = tda18218_wr_regs(priv, R0F_MD8, buf, 1);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(agc); i++) {\n\t\tret = tda18218_wr_reg(priv, agc[i][0], agc[i][1]);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\nerror:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\tif (ret)\n\t\tdev_dbg(&priv->i2c->dev, \"%s: failed=%d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nstatic int tda18218_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct tda18218_priv *priv = fe->tuner_priv;\n\t*frequency = priv->if_frequency;\n\tdev_dbg(&priv->i2c->dev, \"%s: if_frequency=%d\\n\", __func__, *frequency);\n\treturn 0;\n}\n\nstatic int tda18218_sleep(struct dvb_frontend *fe)\n{\n\tstruct tda18218_priv *priv = fe->tuner_priv;\n\tint ret;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\t \n\tret = tda18218_wr_reg(priv, R17_PD1, priv->regs[R17_PD1] | (1 << 0));\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\tif (ret)\n\t\tdev_dbg(&priv->i2c->dev, \"%s: failed=%d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nstatic int tda18218_init(struct dvb_frontend *fe)\n{\n\tstruct tda18218_priv *priv = fe->tuner_priv;\n\tint ret;\n\n\t \n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\tret = tda18218_wr_regs(priv, R00_ID, priv->regs, TDA18218_NUM_REGS);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\tif (ret)\n\t\tdev_dbg(&priv->i2c->dev, \"%s: failed=%d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nstatic void tda18218_release(struct dvb_frontend *fe)\n{\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic const struct dvb_tuner_ops tda18218_tuner_ops = {\n\t.info = {\n\t\t.name              = \"NXP TDA18218\",\n\n\t\t.frequency_min_hz  = 174 * MHz,\n\t\t.frequency_max_hz  = 864 * MHz,\n\t\t.frequency_step_hz =   1 * kHz,\n\t},\n\n\t.release       = tda18218_release,\n\t.init          = tda18218_init,\n\t.sleep         = tda18218_sleep,\n\n\t.set_params    = tda18218_set_params,\n\n\t.get_if_frequency = tda18218_get_if_frequency,\n};\n\nstruct dvb_frontend *tda18218_attach(struct dvb_frontend *fe,\n\tstruct i2c_adapter *i2c, struct tda18218_config *cfg)\n{\n\tstruct tda18218_priv *priv = NULL;\n\tu8 val;\n\tint ret;\n\t \n\tstatic u8 def_regs[] = {\n\t\t0xc0, 0x88, 0x00, 0x8e, 0x03, 0x00, 0x00, 0xd0, 0x00, 0x40,\n\t\t0x00, 0x00, 0x07, 0xff, 0x84, 0x09, 0x00, 0x13, 0x00, 0x00,\n\t\t0x01, 0x84, 0x09, 0xf0, 0x19, 0x0a, 0x8e, 0x69, 0x98, 0x01,\n\t\t0x00, 0x58, 0x10, 0x40, 0x8c, 0x00, 0x0c, 0x48, 0x85, 0xc9,\n\t\t0xa7, 0x00, 0x00, 0x00, 0x30, 0x81, 0x80, 0x00, 0x39, 0x00,\n\t\t0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf6, 0xf6\n\t};\n\n\tpriv = kzalloc(sizeof(struct tda18218_priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn NULL;\n\n\tpriv->cfg = cfg;\n\tpriv->i2c = i2c;\n\tfe->tuner_priv = priv;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\t \n\tret = tda18218_rd_reg(priv, R00_ID, &val);\n\tif (!ret)\n\t\tdev_dbg(&priv->i2c->dev, \"%s: chip id=%02x\\n\", __func__, val);\n\tif (ret || val != def_regs[R00_ID]) {\n\t\tkfree(priv);\n\t\treturn NULL;\n\t}\n\n\tdev_info(&priv->i2c->dev,\n\t\t\t\"%s: NXP TDA18218HN successfully identified\\n\",\n\t\t\tKBUILD_MODNAME);\n\n\tmemcpy(&fe->ops.tuner_ops, &tda18218_tuner_ops,\n\t\tsizeof(struct dvb_tuner_ops));\n\tmemcpy(priv->regs, def_regs, sizeof(def_regs));\n\n\t \n\tif (priv->cfg->loop_through) {\n\t\tpriv->regs[R17_PD1] = 0xb0;\n\t\tpriv->regs[R18_PD2] = 0x59;\n\t}\n\n\t \n\tret = tda18218_wr_reg(priv, R17_PD1, priv->regs[R17_PD1] | (1 << 0));\n\tif (ret)\n\t\tdev_dbg(&priv->i2c->dev, \"%s: failed=%d\\n\", __func__, ret);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(tda18218_attach);\n\nMODULE_DESCRIPTION(\"NXP TDA18218HN silicon tuner driver\");\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}