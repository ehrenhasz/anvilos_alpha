{
  "module_name": "tda827x.c",
  "hash_id": "a3199d6032d7f7ceb3738e5ca0798df3d1235dd5f3168a5c79a063ffe7c570f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/tda827x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <asm/types.h>\n#include <linux/dvb/frontend.h>\n#include <linux/videodev2.h>\n\n#include \"tda827x.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\n#define dprintk(args...) \\\n\tdo {\t\t\t\t\t    \\\n\t\tif (debug) printk(KERN_DEBUG \"tda827x: \" args); \\\n\t} while (0)\n\nstruct tda827x_priv {\n\tint i2c_addr;\n\tstruct i2c_adapter *i2c_adap;\n\tstruct tda827x_config *cfg;\n\n\tunsigned int sgIF;\n\tunsigned char lpsel;\n\n\tu32 frequency;\n\tu32 bandwidth;\n};\n\nstatic void tda827x_set_std(struct dvb_frontend *fe,\n\t\t\t    struct analog_parameters *params)\n{\n\tstruct tda827x_priv *priv = fe->tuner_priv;\n\tchar *mode;\n\n\tpriv->lpsel = 0;\n\tif (params->std & V4L2_STD_MN) {\n\t\tpriv->sgIF = 92;\n\t\tpriv->lpsel = 1;\n\t\tmode = \"MN\";\n\t} else if (params->std & V4L2_STD_B) {\n\t\tpriv->sgIF = 108;\n\t\tmode = \"B\";\n\t} else if (params->std & V4L2_STD_GH) {\n\t\tpriv->sgIF = 124;\n\t\tmode = \"GH\";\n\t} else if (params->std & V4L2_STD_PAL_I) {\n\t\tpriv->sgIF = 124;\n\t\tmode = \"I\";\n\t} else if (params->std & V4L2_STD_DK) {\n\t\tpriv->sgIF = 124;\n\t\tmode = \"DK\";\n\t} else if (params->std & V4L2_STD_SECAM_L) {\n\t\tpriv->sgIF = 124;\n\t\tmode = \"L\";\n\t} else if (params->std & V4L2_STD_SECAM_LC) {\n\t\tpriv->sgIF = 20;\n\t\tmode = \"LC\";\n\t} else {\n\t\tpriv->sgIF = 124;\n\t\tmode = \"xx\";\n\t}\n\n\tif (params->mode == V4L2_TUNER_RADIO) {\n\t\tpriv->sgIF = 88;  \n\t\tdprintk(\"setting tda827x to radio FM\\n\");\n\t} else\n\t\tdprintk(\"setting tda827x to system %s\\n\", mode);\n}\n\n\n \n\nstruct tda827x_data {\n\tu32 lomax;\n\tu8  spd;\n\tu8  bs;\n\tu8  bp;\n\tu8  cp;\n\tu8  gc3;\n\tu8 div1p5;\n};\n\nstatic const struct tda827x_data tda827x_table[] = {\n\t{ .lomax =  62000000, .spd = 3, .bs = 2, .bp = 0, .cp = 0, .gc3 = 3, .div1p5 = 1},\n\t{ .lomax =  66000000, .spd = 3, .bs = 3, .bp = 0, .cp = 0, .gc3 = 3, .div1p5 = 1},\n\t{ .lomax =  76000000, .spd = 3, .bs = 1, .bp = 0, .cp = 0, .gc3 = 3, .div1p5 = 0},\n\t{ .lomax =  84000000, .spd = 3, .bs = 2, .bp = 0, .cp = 0, .gc3 = 3, .div1p5 = 0},\n\t{ .lomax =  93000000, .spd = 3, .bs = 2, .bp = 0, .cp = 0, .gc3 = 1, .div1p5 = 0},\n\t{ .lomax =  98000000, .spd = 3, .bs = 3, .bp = 0, .cp = 0, .gc3 = 1, .div1p5 = 0},\n\t{ .lomax = 109000000, .spd = 3, .bs = 3, .bp = 1, .cp = 0, .gc3 = 1, .div1p5 = 0},\n\t{ .lomax = 123000000, .spd = 2, .bs = 2, .bp = 1, .cp = 0, .gc3 = 1, .div1p5 = 1},\n\t{ .lomax = 133000000, .spd = 2, .bs = 3, .bp = 1, .cp = 0, .gc3 = 1, .div1p5 = 1},\n\t{ .lomax = 151000000, .spd = 2, .bs = 1, .bp = 1, .cp = 0, .gc3 = 1, .div1p5 = 0},\n\t{ .lomax = 154000000, .spd = 2, .bs = 2, .bp = 1, .cp = 0, .gc3 = 1, .div1p5 = 0},\n\t{ .lomax = 181000000, .spd = 2, .bs = 2, .bp = 1, .cp = 0, .gc3 = 0, .div1p5 = 0},\n\t{ .lomax = 185000000, .spd = 2, .bs = 2, .bp = 2, .cp = 0, .gc3 = 1, .div1p5 = 0},\n\t{ .lomax = 217000000, .spd = 2, .bs = 3, .bp = 2, .cp = 0, .gc3 = 1, .div1p5 = 0},\n\t{ .lomax = 244000000, .spd = 1, .bs = 2, .bp = 2, .cp = 0, .gc3 = 1, .div1p5 = 1},\n\t{ .lomax = 265000000, .spd = 1, .bs = 3, .bp = 2, .cp = 0, .gc3 = 1, .div1p5 = 1},\n\t{ .lomax = 302000000, .spd = 1, .bs = 1, .bp = 2, .cp = 0, .gc3 = 1, .div1p5 = 0},\n\t{ .lomax = 324000000, .spd = 1, .bs = 2, .bp = 2, .cp = 0, .gc3 = 1, .div1p5 = 0},\n\t{ .lomax = 370000000, .spd = 1, .bs = 2, .bp = 3, .cp = 0, .gc3 = 1, .div1p5 = 0},\n\t{ .lomax = 454000000, .spd = 1, .bs = 3, .bp = 3, .cp = 0, .gc3 = 1, .div1p5 = 0},\n\t{ .lomax = 493000000, .spd = 0, .bs = 2, .bp = 3, .cp = 0, .gc3 = 1, .div1p5 = 1},\n\t{ .lomax = 530000000, .spd = 0, .bs = 3, .bp = 3, .cp = 0, .gc3 = 1, .div1p5 = 1},\n\t{ .lomax = 554000000, .spd = 0, .bs = 1, .bp = 3, .cp = 0, .gc3 = 1, .div1p5 = 0},\n\t{ .lomax = 604000000, .spd = 0, .bs = 1, .bp = 4, .cp = 0, .gc3 = 0, .div1p5 = 0},\n\t{ .lomax = 696000000, .spd = 0, .bs = 2, .bp = 4, .cp = 0, .gc3 = 0, .div1p5 = 0},\n\t{ .lomax = 740000000, .spd = 0, .bs = 2, .bp = 4, .cp = 1, .gc3 = 0, .div1p5 = 0},\n\t{ .lomax = 820000000, .spd = 0, .bs = 3, .bp = 4, .cp = 0, .gc3 = 0, .div1p5 = 0},\n\t{ .lomax = 865000000, .spd = 0, .bs = 3, .bp = 4, .cp = 1, .gc3 = 0, .div1p5 = 0},\n\t{ .lomax =         0, .spd = 0, .bs = 0, .bp = 0, .cp = 0, .gc3 = 0, .div1p5 = 0}\n};\n\nstatic int tuner_transfer(struct dvb_frontend *fe,\n\t\t\t  struct i2c_msg *msg,\n\t\t\t  const int size)\n{\n\tint rc;\n\tstruct tda827x_priv *priv = fe->tuner_priv;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\trc = i2c_transfer(priv->i2c_adap, msg, size);\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tif (rc >= 0 && rc != size)\n\t\treturn -EIO;\n\n\treturn rc;\n}\n\nstatic int tda827xo_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct tda827x_priv *priv = fe->tuner_priv;\n\tu8 buf[14];\n\tint rc;\n\n\tstruct i2c_msg msg = { .addr = priv->i2c_addr, .flags = 0,\n\t\t\t       .buf = buf, .len = sizeof(buf) };\n\tint i, tuner_freq, if_freq;\n\tu32 N;\n\n\tdprintk(\"%s:\\n\", __func__);\n\tif (c->bandwidth_hz == 0) {\n\t\tif_freq = 5000000;\n\t} else if (c->bandwidth_hz <= 6000000) {\n\t\tif_freq = 4000000;\n\t} else if (c->bandwidth_hz <= 7000000) {\n\t\tif_freq = 4500000;\n\t} else {\t \n\t\tif_freq = 5000000;\n\t}\n\ttuner_freq = c->frequency;\n\n\ti = 0;\n\twhile (tda827x_table[i].lomax < tuner_freq) {\n\t\tif (tda827x_table[i + 1].lomax == 0)\n\t\t\tbreak;\n\t\ti++;\n\t}\n\n\ttuner_freq += if_freq;\n\n\tN = ((tuner_freq + 125000) / 250000) << (tda827x_table[i].spd + 2);\n\tbuf[0] = 0;\n\tbuf[1] = (N>>8) | 0x40;\n\tbuf[2] = N & 0xff;\n\tbuf[3] = 0;\n\tbuf[4] = 0x52;\n\tbuf[5] = (tda827x_table[i].spd << 6) + (tda827x_table[i].div1p5 << 5) +\n\t\t\t\t(tda827x_table[i].bs << 3) +\n\t\t\t\ttda827x_table[i].bp;\n\tbuf[6] = (tda827x_table[i].gc3 << 4) + 0x8f;\n\tbuf[7] = 0xbf;\n\tbuf[8] = 0x2a;\n\tbuf[9] = 0x05;\n\tbuf[10] = 0xff;\n\tbuf[11] = 0x00;\n\tbuf[12] = 0x00;\n\tbuf[13] = 0x40;\n\n\tmsg.len = 14;\n\trc = tuner_transfer(fe, &msg, 1);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tmsleep(500);\n\t \n\tbuf[0] = 0x30;\n\tbuf[1] = 0x50 + tda827x_table[i].cp;\n\tmsg.len = 2;\n\n\trc = tuner_transfer(fe, &msg, 1);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tpriv->frequency = c->frequency;\n\tpriv->bandwidth = c->bandwidth_hz;\n\n\treturn 0;\n\nerr:\n\tprintk(KERN_ERR \"%s: could not write to tuner at addr: 0x%02x\\n\",\n\t       __func__, priv->i2c_addr << 1);\n\treturn rc;\n}\n\nstatic int tda827xo_sleep(struct dvb_frontend *fe)\n{\n\tstruct tda827x_priv *priv = fe->tuner_priv;\n\tstatic u8 buf[] = { 0x30, 0xd0 };\n\tstruct i2c_msg msg = { .addr = priv->i2c_addr, .flags = 0,\n\t\t\t       .buf = buf, .len = sizeof(buf) };\n\n\tdprintk(\"%s:\\n\", __func__);\n\ttuner_transfer(fe, &msg, 1);\n\n\tif (priv->cfg && priv->cfg->sleep)\n\t\tpriv->cfg->sleep(fe);\n\n\treturn 0;\n}\n\n \n\nstatic int tda827xo_set_analog_params(struct dvb_frontend *fe,\n\t\t\t\t      struct analog_parameters *params)\n{\n\tunsigned char tuner_reg[8];\n\tunsigned char reg2[2];\n\tu32 N;\n\tint i;\n\tstruct tda827x_priv *priv = fe->tuner_priv;\n\tstruct i2c_msg msg = { .addr = priv->i2c_addr, .flags = 0 };\n\tunsigned int freq = params->frequency;\n\n\ttda827x_set_std(fe, params);\n\n\tif (params->mode == V4L2_TUNER_RADIO)\n\t\tfreq = freq / 1000;\n\n\tN = freq + priv->sgIF;\n\n\ti = 0;\n\twhile (tda827x_table[i].lomax < N * 62500) {\n\t\tif (tda827x_table[i + 1].lomax == 0)\n\t\t\tbreak;\n\t\ti++;\n\t}\n\n\tN = N << tda827x_table[i].spd;\n\n\ttuner_reg[0] = 0;\n\ttuner_reg[1] = (unsigned char)(N>>8);\n\ttuner_reg[2] = (unsigned char) N;\n\ttuner_reg[3] = 0x40;\n\ttuner_reg[4] = 0x52 + (priv->lpsel << 5);\n\ttuner_reg[5] = (tda827x_table[i].spd    << 6) +\n\t\t       (tda827x_table[i].div1p5 << 5) +\n\t\t       (tda827x_table[i].bs     << 3) + tda827x_table[i].bp;\n\ttuner_reg[6] = 0x8f + (tda827x_table[i].gc3 << 4);\n\ttuner_reg[7] = 0x8f;\n\n\tmsg.buf = tuner_reg;\n\tmsg.len = 8;\n\ttuner_transfer(fe, &msg, 1);\n\n\tmsg.buf = reg2;\n\tmsg.len = 2;\n\treg2[0] = 0x80;\n\treg2[1] = 0;\n\ttuner_transfer(fe, &msg, 1);\n\n\treg2[0] = 0x60;\n\treg2[1] = 0xbf;\n\ttuner_transfer(fe, &msg, 1);\n\n\treg2[0] = 0x30;\n\treg2[1] = tuner_reg[4] + 0x80;\n\ttuner_transfer(fe, &msg, 1);\n\n\tmsleep(1);\n\treg2[0] = 0x30;\n\treg2[1] = tuner_reg[4] + 4;\n\ttuner_transfer(fe, &msg, 1);\n\n\tmsleep(1);\n\treg2[0] = 0x30;\n\treg2[1] = tuner_reg[4];\n\ttuner_transfer(fe, &msg, 1);\n\n\tmsleep(550);\n\treg2[0] = 0x30;\n\treg2[1] = (tuner_reg[4] & 0xfc) + tda827x_table[i].cp;\n\ttuner_transfer(fe, &msg, 1);\n\n\treg2[0] = 0x60;\n\treg2[1] = 0x3f;\n\ttuner_transfer(fe, &msg, 1);\n\n\treg2[0] = 0x80;\n\treg2[1] = 0x08;    \n\ttuner_transfer(fe, &msg, 1);\n\n\tpriv->frequency = params->frequency;\n\n\treturn 0;\n}\n\nstatic void tda827xo_agcf(struct dvb_frontend *fe)\n{\n\tstruct tda827x_priv *priv = fe->tuner_priv;\n\tunsigned char data[] = { 0x80, 0x0c };\n\tstruct i2c_msg msg = { .addr = priv->i2c_addr, .flags = 0,\n\t\t\t       .buf = data, .len = 2};\n\n\ttuner_transfer(fe, &msg, 1);\n}\n\n \n\nstruct tda827xa_data {\n\tu32 lomax;\n\tu8  svco;\n\tu8  spd;\n\tu8  scr;\n\tu8  sbs;\n\tu8  gc3;\n};\n\nstatic struct tda827xa_data tda827xa_dvbt[] = {\n\t{ .lomax =  56875000, .svco = 3, .spd = 4, .scr = 0, .sbs = 0, .gc3 = 1},\n\t{ .lomax =  67250000, .svco = 0, .spd = 3, .scr = 0, .sbs = 0, .gc3 = 1},\n\t{ .lomax =  81250000, .svco = 1, .spd = 3, .scr = 0, .sbs = 0, .gc3 = 1},\n\t{ .lomax =  97500000, .svco = 2, .spd = 3, .scr = 0, .sbs = 0, .gc3 = 1},\n\t{ .lomax = 113750000, .svco = 3, .spd = 3, .scr = 0, .sbs = 1, .gc3 = 1},\n\t{ .lomax = 134500000, .svco = 0, .spd = 2, .scr = 0, .sbs = 1, .gc3 = 1},\n\t{ .lomax = 154000000, .svco = 1, .spd = 2, .scr = 0, .sbs = 1, .gc3 = 1},\n\t{ .lomax = 162500000, .svco = 1, .spd = 2, .scr = 0, .sbs = 1, .gc3 = 1},\n\t{ .lomax = 183000000, .svco = 2, .spd = 2, .scr = 0, .sbs = 1, .gc3 = 1},\n\t{ .lomax = 195000000, .svco = 2, .spd = 2, .scr = 0, .sbs = 2, .gc3 = 1},\n\t{ .lomax = 227500000, .svco = 3, .spd = 2, .scr = 0, .sbs = 2, .gc3 = 1},\n\t{ .lomax = 269000000, .svco = 0, .spd = 1, .scr = 0, .sbs = 2, .gc3 = 1},\n\t{ .lomax = 290000000, .svco = 1, .spd = 1, .scr = 0, .sbs = 2, .gc3 = 1},\n\t{ .lomax = 325000000, .svco = 1, .spd = 1, .scr = 0, .sbs = 3, .gc3 = 1},\n\t{ .lomax = 390000000, .svco = 2, .spd = 1, .scr = 0, .sbs = 3, .gc3 = 1},\n\t{ .lomax = 455000000, .svco = 3, .spd = 1, .scr = 0, .sbs = 3, .gc3 = 1},\n\t{ .lomax = 520000000, .svco = 0, .spd = 0, .scr = 0, .sbs = 3, .gc3 = 1},\n\t{ .lomax = 538000000, .svco = 0, .spd = 0, .scr = 1, .sbs = 3, .gc3 = 1},\n\t{ .lomax = 550000000, .svco = 1, .spd = 0, .scr = 0, .sbs = 3, .gc3 = 1},\n\t{ .lomax = 620000000, .svco = 1, .spd = 0, .scr = 0, .sbs = 4, .gc3 = 0},\n\t{ .lomax = 650000000, .svco = 1, .spd = 0, .scr = 1, .sbs = 4, .gc3 = 0},\n\t{ .lomax = 700000000, .svco = 2, .spd = 0, .scr = 0, .sbs = 4, .gc3 = 0},\n\t{ .lomax = 780000000, .svco = 2, .spd = 0, .scr = 1, .sbs = 4, .gc3 = 0},\n\t{ .lomax = 820000000, .svco = 3, .spd = 0, .scr = 0, .sbs = 4, .gc3 = 0},\n\t{ .lomax = 870000000, .svco = 3, .spd = 0, .scr = 1, .sbs = 4, .gc3 = 0},\n\t{ .lomax = 911000000, .svco = 3, .spd = 0, .scr = 2, .sbs = 4, .gc3 = 0},\n\t{ .lomax =         0, .svco = 0, .spd = 0, .scr = 0, .sbs = 0, .gc3 = 0}\n};\n\nstatic struct tda827xa_data tda827xa_dvbc[] = {\n\t{ .lomax =  50125000, .svco = 2, .spd = 4, .scr = 2, .sbs = 0, .gc3 = 3},\n\t{ .lomax =  58500000, .svco = 3, .spd = 4, .scr = 2, .sbs = 0, .gc3 = 3},\n\t{ .lomax =  69250000, .svco = 0, .spd = 3, .scr = 2, .sbs = 0, .gc3 = 3},\n\t{ .lomax =  83625000, .svco = 1, .spd = 3, .scr = 2, .sbs = 0, .gc3 = 3},\n\t{ .lomax =  97500000, .svco = 2, .spd = 3, .scr = 2, .sbs = 0, .gc3 = 3},\n\t{ .lomax = 100250000, .svco = 2, .spd = 3, .scr = 2, .sbs = 1, .gc3 = 1},\n\t{ .lomax = 117000000, .svco = 3, .spd = 3, .scr = 2, .sbs = 1, .gc3 = 1},\n\t{ .lomax = 138500000, .svco = 0, .spd = 2, .scr = 2, .sbs = 1, .gc3 = 1},\n\t{ .lomax = 167250000, .svco = 1, .spd = 2, .scr = 2, .sbs = 1, .gc3 = 1},\n\t{ .lomax = 187000000, .svco = 2, .spd = 2, .scr = 2, .sbs = 1, .gc3 = 1},\n\t{ .lomax = 200500000, .svco = 2, .spd = 2, .scr = 2, .sbs = 2, .gc3 = 1},\n\t{ .lomax = 234000000, .svco = 3, .spd = 2, .scr = 2, .sbs = 2, .gc3 = 3},\n\t{ .lomax = 277000000, .svco = 0, .spd = 1, .scr = 2, .sbs = 2, .gc3 = 3},\n\t{ .lomax = 325000000, .svco = 1, .spd = 1, .scr = 2, .sbs = 2, .gc3 = 1},\n\t{ .lomax = 334500000, .svco = 1, .spd = 1, .scr = 2, .sbs = 3, .gc3 = 3},\n\t{ .lomax = 401000000, .svco = 2, .spd = 1, .scr = 2, .sbs = 3, .gc3 = 3},\n\t{ .lomax = 468000000, .svco = 3, .spd = 1, .scr = 2, .sbs = 3, .gc3 = 1},\n\t{ .lomax = 535000000, .svco = 0, .spd = 0, .scr = 1, .sbs = 3, .gc3 = 1},\n\t{ .lomax = 554000000, .svco = 0, .spd = 0, .scr = 2, .sbs = 3, .gc3 = 1},\n\t{ .lomax = 638000000, .svco = 1, .spd = 0, .scr = 1, .sbs = 4, .gc3 = 1},\n\t{ .lomax = 669000000, .svco = 1, .spd = 0, .scr = 2, .sbs = 4, .gc3 = 1},\n\t{ .lomax = 720000000, .svco = 2, .spd = 0, .scr = 1, .sbs = 4, .gc3 = 1},\n\t{ .lomax = 802000000, .svco = 2, .spd = 0, .scr = 2, .sbs = 4, .gc3 = 1},\n\t{ .lomax = 835000000, .svco = 3, .spd = 0, .scr = 1, .sbs = 4, .gc3 = 1},\n\t{ .lomax = 885000000, .svco = 3, .spd = 0, .scr = 1, .sbs = 4, .gc3 = 1},\n\t{ .lomax = 911000000, .svco = 3, .spd = 0, .scr = 2, .sbs = 4, .gc3 = 1},\n\t{ .lomax =         0, .svco = 0, .spd = 0, .scr = 0, .sbs = 0, .gc3 = 0}\n};\n\nstatic struct tda827xa_data tda827xa_analog[] = {\n\t{ .lomax =  56875000, .svco = 3, .spd = 4, .scr = 0, .sbs = 0, .gc3 = 3},\n\t{ .lomax =  67250000, .svco = 0, .spd = 3, .scr = 0, .sbs = 0, .gc3 = 3},\n\t{ .lomax =  81250000, .svco = 1, .spd = 3, .scr = 0, .sbs = 0, .gc3 = 3},\n\t{ .lomax =  97500000, .svco = 2, .spd = 3, .scr = 0, .sbs = 0, .gc3 = 3},\n\t{ .lomax = 113750000, .svco = 3, .spd = 3, .scr = 0, .sbs = 1, .gc3 = 1},\n\t{ .lomax = 134500000, .svco = 0, .spd = 2, .scr = 0, .sbs = 1, .gc3 = 1},\n\t{ .lomax = 154000000, .svco = 1, .spd = 2, .scr = 0, .sbs = 1, .gc3 = 1},\n\t{ .lomax = 162500000, .svco = 1, .spd = 2, .scr = 0, .sbs = 1, .gc3 = 1},\n\t{ .lomax = 183000000, .svco = 2, .spd = 2, .scr = 0, .sbs = 1, .gc3 = 1},\n\t{ .lomax = 195000000, .svco = 2, .spd = 2, .scr = 0, .sbs = 2, .gc3 = 1},\n\t{ .lomax = 227500000, .svco = 3, .spd = 2, .scr = 0, .sbs = 2, .gc3 = 3},\n\t{ .lomax = 269000000, .svco = 0, .spd = 1, .scr = 0, .sbs = 2, .gc3 = 3},\n\t{ .lomax = 325000000, .svco = 1, .spd = 1, .scr = 0, .sbs = 2, .gc3 = 1},\n\t{ .lomax = 390000000, .svco = 2, .spd = 1, .scr = 0, .sbs = 3, .gc3 = 3},\n\t{ .lomax = 455000000, .svco = 3, .spd = 1, .scr = 0, .sbs = 3, .gc3 = 3},\n\t{ .lomax = 520000000, .svco = 0, .spd = 0, .scr = 0, .sbs = 3, .gc3 = 1},\n\t{ .lomax = 538000000, .svco = 0, .spd = 0, .scr = 1, .sbs = 3, .gc3 = 1},\n\t{ .lomax = 554000000, .svco = 1, .spd = 0, .scr = 0, .sbs = 3, .gc3 = 1},\n\t{ .lomax = 620000000, .svco = 1, .spd = 0, .scr = 0, .sbs = 4, .gc3 = 0},\n\t{ .lomax = 650000000, .svco = 1, .spd = 0, .scr = 1, .sbs = 4, .gc3 = 0},\n\t{ .lomax = 700000000, .svco = 2, .spd = 0, .scr = 0, .sbs = 4, .gc3 = 0},\n\t{ .lomax = 780000000, .svco = 2, .spd = 0, .scr = 1, .sbs = 4, .gc3 = 0},\n\t{ .lomax = 820000000, .svco = 3, .spd = 0, .scr = 0, .sbs = 4, .gc3 = 0},\n\t{ .lomax = 870000000, .svco = 3, .spd = 0, .scr = 1, .sbs = 4, .gc3 = 0},\n\t{ .lomax = 911000000, .svco = 3, .spd = 0, .scr = 2, .sbs = 4, .gc3 = 0},\n\t{ .lomax =         0, .svco = 0, .spd = 0, .scr = 0, .sbs = 0, .gc3 = 0}\n};\n\nstatic int tda827xa_sleep(struct dvb_frontend *fe)\n{\n\tstruct tda827x_priv *priv = fe->tuner_priv;\n\tstatic u8 buf[] = { 0x30, 0x90 };\n\tstruct i2c_msg msg = { .addr = priv->i2c_addr, .flags = 0,\n\t\t\t       .buf = buf, .len = sizeof(buf) };\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\ttuner_transfer(fe, &msg, 1);\n\n\tif (priv->cfg && priv->cfg->sleep)\n\t\tpriv->cfg->sleep(fe);\n\n\treturn 0;\n}\n\nstatic void tda827xa_lna_gain(struct dvb_frontend *fe, int high,\n\t\t\t      struct analog_parameters *params)\n{\n\tstruct tda827x_priv *priv = fe->tuner_priv;\n\tunsigned char buf[] = {0x22, 0x01};\n\tint arg;\n\tint gp_func;\n\tstruct i2c_msg msg = { .flags = 0, .buf = buf, .len = sizeof(buf) };\n\n\tif (NULL == priv->cfg) {\n\t\tdprintk(\"tda827x_config not defined, cannot set LNA gain!\\n\");\n\t\treturn;\n\t}\n\tmsg.addr = priv->cfg->switch_addr;\n\tif (priv->cfg->config) {\n\t\tif (high)\n\t\t\tdprintk(\"setting LNA to high gain\\n\");\n\t\telse\n\t\t\tdprintk(\"setting LNA to low gain\\n\");\n\t}\n\tswitch (priv->cfg->config) {\n\tcase TDA8290_LNA_OFF:  \n\t\tbreak;\n\tcase TDA8290_LNA_GP0_HIGH_ON:  \n\tcase TDA8290_LNA_GP0_HIGH_OFF:\n\t\tif (params == NULL) {\n\t\t\tgp_func = 0;\n\t\t\targ  = 0;\n\t\t} else {\n\t\t\t \n\t\t\tgp_func = 1;\n\t\t\tif (params->std & V4L2_STD_MN)\n\t\t\t\targ = 1;\n\t\t\telse\n\t\t\t\targ = 0;\n\t\t}\n\t\tif (fe->callback)\n\t\t\tfe->callback(priv->i2c_adap->algo_data,\n\t\t\t\t     DVB_FRONTEND_COMPONENT_TUNER,\n\t\t\t\t     gp_func, arg);\n\t\tbuf[1] = high ? 0 : 1;\n\t\tif (priv->cfg->config == TDA8290_LNA_GP0_HIGH_OFF)\n\t\t\tbuf[1] = high ? 1 : 0;\n\t\ttuner_transfer(fe, &msg, 1);\n\t\tbreak;\n\tcase TDA8290_LNA_ON_BRIDGE:  \n\t\tif (fe->callback)\n\t\t\tfe->callback(priv->i2c_adap->algo_data,\n\t\t\t\t     DVB_FRONTEND_COMPONENT_TUNER, 0, high);\n\t\tbreak;\n\t}\n}\n\nstatic int tda827xa_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct tda827x_priv *priv = fe->tuner_priv;\n\tstruct tda827xa_data *frequency_map = tda827xa_dvbt;\n\tu8 buf[11];\n\n\tstruct i2c_msg msg = { .addr = priv->i2c_addr, .flags = 0,\n\t\t\t       .buf = buf, .len = sizeof(buf) };\n\n\tint i, tuner_freq, if_freq, rc;\n\tu32 N;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\ttda827xa_lna_gain(fe, 1, NULL);\n\tmsleep(20);\n\n\tif (c->bandwidth_hz == 0) {\n\t\tif_freq = 5000000;\n\t} else if (c->bandwidth_hz <= 6000000) {\n\t\tif_freq = 4000000;\n\t} else if (c->bandwidth_hz <= 7000000) {\n\t\tif_freq = 4500000;\n\t} else {\t \n\t\tif_freq = 5000000;\n\t}\n\ttuner_freq = c->frequency;\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBC_ANNEX_A:\n\tcase SYS_DVBC_ANNEX_C:\n\t\tdprintk(\"%s select tda827xa_dvbc\\n\", __func__);\n\t\tfrequency_map = tda827xa_dvbc;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ti = 0;\n\twhile (frequency_map[i].lomax < tuner_freq) {\n\t\tif (frequency_map[i + 1].lomax == 0)\n\t\t\tbreak;\n\t\ti++;\n\t}\n\n\ttuner_freq += if_freq;\n\n\tN = ((tuner_freq + 31250) / 62500) << frequency_map[i].spd;\n\tbuf[0] = 0;            \n\tbuf[1] = N >> 8;\n\tbuf[2] = N & 0xff;\n\tbuf[3] = 0;\n\tbuf[4] = 0x16;\n\tbuf[5] = (frequency_map[i].spd << 5) + (frequency_map[i].svco << 3) +\n\t\t\tfrequency_map[i].sbs;\n\tbuf[6] = 0x4b + (frequency_map[i].gc3 << 4);\n\tbuf[7] = 0x1c;\n\tbuf[8] = 0x06;\n\tbuf[9] = 0x24;\n\tbuf[10] = 0x00;\n\tmsg.len = 11;\n\trc = tuner_transfer(fe, &msg, 1);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tbuf[0] = 0x90;\n\tbuf[1] = 0xff;\n\tbuf[2] = 0x60;\n\tbuf[3] = 0x00;\n\tbuf[4] = 0x59;  \n\tmsg.len = 5;\n\trc = tuner_transfer(fe, &msg, 1);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tbuf[0] = 0xa0;\n\tbuf[1] = 0x40;\n\tmsg.len = 2;\n\trc = tuner_transfer(fe, &msg, 1);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tmsleep(11);\n\tmsg.flags = I2C_M_RD;\n\trc = tuner_transfer(fe, &msg, 1);\n\tif (rc < 0)\n\t\tgoto err;\n\tmsg.flags = 0;\n\n\tbuf[1] >>= 4;\n\tdprintk(\"tda8275a AGC2 gain is: %d\\n\", buf[1]);\n\tif ((buf[1]) < 2) {\n\t\ttda827xa_lna_gain(fe, 0, NULL);\n\t\tbuf[0] = 0x60;\n\t\tbuf[1] = 0x0c;\n\t\trc = tuner_transfer(fe, &msg, 1);\n\t\tif (rc < 0)\n\t\t\tgoto err;\n\t}\n\n\tbuf[0] = 0xc0;\n\tbuf[1] = 0x99;    \n\trc = tuner_transfer(fe, &msg, 1);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tbuf[0] = 0x60;\n\tbuf[1] = 0x3c;\n\trc = tuner_transfer(fe, &msg, 1);\n\tif (rc < 0)\n\t\tgoto err;\n\n\t \n\tbuf[0] = 0x30;\n\tbuf[1] = 0x10 + frequency_map[i].scr;\n\trc = tuner_transfer(fe, &msg, 1);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tmsleep(163);\n\tbuf[0] = 0xc0;\n\tbuf[1] = 0x39;  \n\trc = tuner_transfer(fe, &msg, 1);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tmsleep(3);\n\t \n\tbuf[0] = 0x50;\n\tbuf[1] = 0x4f + (frequency_map[i].gc3 << 4);\n\trc = tuner_transfer(fe, &msg, 1);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tpriv->frequency = c->frequency;\n\tpriv->bandwidth = c->bandwidth_hz;\n\n\treturn 0;\n\nerr:\n\tprintk(KERN_ERR \"%s: could not write to tuner at addr: 0x%02x\\n\",\n\t       __func__, priv->i2c_addr << 1);\n\treturn rc;\n}\n\n\nstatic int tda827xa_set_analog_params(struct dvb_frontend *fe,\n\t\t\t\t      struct analog_parameters *params)\n{\n\tunsigned char tuner_reg[11];\n\tu32 N;\n\tint i;\n\tstruct tda827x_priv *priv = fe->tuner_priv;\n\tstruct i2c_msg msg = { .addr = priv->i2c_addr, .flags = 0,\n\t\t\t       .buf = tuner_reg, .len = sizeof(tuner_reg) };\n\tunsigned int freq = params->frequency;\n\n\ttda827x_set_std(fe, params);\n\n\ttda827xa_lna_gain(fe, 1, params);\n\tmsleep(10);\n\n\tif (params->mode == V4L2_TUNER_RADIO)\n\t\tfreq = freq / 1000;\n\n\tN = freq + priv->sgIF;\n\n\ti = 0;\n\twhile (tda827xa_analog[i].lomax < N * 62500) {\n\t\tif (tda827xa_analog[i + 1].lomax == 0)\n\t\t\tbreak;\n\t\ti++;\n\t}\n\n\tN = N << tda827xa_analog[i].spd;\n\n\ttuner_reg[0] = 0;\n\ttuner_reg[1] = (unsigned char)(N>>8);\n\ttuner_reg[2] = (unsigned char) N;\n\ttuner_reg[3] = 0;\n\ttuner_reg[4] = 0x16;\n\ttuner_reg[5] = (tda827xa_analog[i].spd << 5) +\n\t\t       (tda827xa_analog[i].svco << 3) +\n\t\t\ttda827xa_analog[i].sbs;\n\ttuner_reg[6] = 0x8b + (tda827xa_analog[i].gc3 << 4);\n\ttuner_reg[7] = 0x1c;\n\ttuner_reg[8] = 4;\n\ttuner_reg[9] = 0x20;\n\ttuner_reg[10] = 0x00;\n\tmsg.len = 11;\n\ttuner_transfer(fe, &msg, 1);\n\n\ttuner_reg[0] = 0x90;\n\ttuner_reg[1] = 0xff;\n\ttuner_reg[2] = 0xe0;\n\ttuner_reg[3] = 0;\n\ttuner_reg[4] = 0x99 + (priv->lpsel << 1);\n\tmsg.len = 5;\n\ttuner_transfer(fe, &msg, 1);\n\n\ttuner_reg[0] = 0xa0;\n\ttuner_reg[1] = 0xc0;\n\tmsg.len = 2;\n\ttuner_transfer(fe, &msg, 1);\n\n\ttuner_reg[0] = 0x30;\n\ttuner_reg[1] = 0x10 + tda827xa_analog[i].scr;\n\ttuner_transfer(fe, &msg, 1);\n\n\tmsg.flags = I2C_M_RD;\n\ttuner_transfer(fe, &msg, 1);\n\tmsg.flags = 0;\n\ttuner_reg[1] >>= 4;\n\tdprintk(\"AGC2 gain is: %d\\n\", tuner_reg[1]);\n\tif (tuner_reg[1] < 1)\n\t\ttda827xa_lna_gain(fe, 0, params);\n\n\tmsleep(100);\n\ttuner_reg[0] = 0x60;\n\ttuner_reg[1] = 0x3c;\n\ttuner_transfer(fe, &msg, 1);\n\n\tmsleep(163);\n\ttuner_reg[0] = 0x50;\n\ttuner_reg[1] = 0x8f + (tda827xa_analog[i].gc3 << 4);\n\ttuner_transfer(fe, &msg, 1);\n\n\ttuner_reg[0] = 0x80;\n\ttuner_reg[1] = 0x28;\n\ttuner_transfer(fe, &msg, 1);\n\n\ttuner_reg[0] = 0xb0;\n\ttuner_reg[1] = 0x01;\n\ttuner_transfer(fe, &msg, 1);\n\n\ttuner_reg[0] = 0xc0;\n\ttuner_reg[1] = 0x19 + (priv->lpsel << 1);\n\ttuner_transfer(fe, &msg, 1);\n\n\tpriv->frequency = params->frequency;\n\n\treturn 0;\n}\n\nstatic void tda827xa_agcf(struct dvb_frontend *fe)\n{\n\tstruct tda827x_priv *priv = fe->tuner_priv;\n\tunsigned char data[] = {0x80, 0x2c};\n\tstruct i2c_msg msg = {.addr = priv->i2c_addr, .flags = 0,\n\t\t\t      .buf = data, .len = 2};\n\ttuner_transfer(fe, &msg, 1);\n}\n\n \n\nstatic void tda827x_release(struct dvb_frontend *fe)\n{\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic int tda827x_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct tda827x_priv *priv = fe->tuner_priv;\n\t*frequency = priv->frequency;\n\treturn 0;\n}\n\nstatic int tda827x_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\n{\n\tstruct tda827x_priv *priv = fe->tuner_priv;\n\t*bandwidth = priv->bandwidth;\n\treturn 0;\n}\n\nstatic int tda827x_init(struct dvb_frontend *fe)\n{\n\tstruct tda827x_priv *priv = fe->tuner_priv;\n\tdprintk(\"%s:\\n\", __func__);\n\tif (priv->cfg && priv->cfg->init)\n\t\tpriv->cfg->init(fe);\n\n\treturn 0;\n}\n\nstatic int tda827x_probe_version(struct dvb_frontend *fe);\n\nstatic int tda827x_initial_init(struct dvb_frontend *fe)\n{\n\tint ret;\n\tret = tda827x_probe_version(fe);\n\tif (ret)\n\t\treturn ret;\n\treturn fe->ops.tuner_ops.init(fe);\n}\n\nstatic int tda827x_initial_sleep(struct dvb_frontend *fe)\n{\n\tint ret;\n\tret = tda827x_probe_version(fe);\n\tif (ret)\n\t\treturn ret;\n\treturn fe->ops.tuner_ops.sleep(fe);\n}\n\nstatic const struct dvb_tuner_ops tda827xo_tuner_ops = {\n\t.info = {\n\t\t.name = \"Philips TDA827X\",\n\t\t.frequency_min_hz  =  55 * MHz,\n\t\t.frequency_max_hz  = 860 * MHz,\n\t\t.frequency_step_hz = 250 * kHz\n\t},\n\t.release = tda827x_release,\n\t.init = tda827x_initial_init,\n\t.sleep = tda827x_initial_sleep,\n\t.set_params = tda827xo_set_params,\n\t.set_analog_params = tda827xo_set_analog_params,\n\t.get_frequency = tda827x_get_frequency,\n\t.get_bandwidth = tda827x_get_bandwidth,\n};\n\nstatic const struct dvb_tuner_ops tda827xa_tuner_ops = {\n\t.info = {\n\t\t.name = \"Philips TDA827XA\",\n\t\t.frequency_min_hz  =  44 * MHz,\n\t\t.frequency_max_hz  = 906 * MHz,\n\t\t.frequency_step_hz = 62500\n\t},\n\t.release = tda827x_release,\n\t.init = tda827x_init,\n\t.sleep = tda827xa_sleep,\n\t.set_params = tda827xa_set_params,\n\t.set_analog_params = tda827xa_set_analog_params,\n\t.get_frequency = tda827x_get_frequency,\n\t.get_bandwidth = tda827x_get_bandwidth,\n};\n\nstatic int tda827x_probe_version(struct dvb_frontend *fe)\n{\n\tu8 data;\n\tint rc;\n\tstruct tda827x_priv *priv = fe->tuner_priv;\n\tstruct i2c_msg msg = { .addr = priv->i2c_addr, .flags = I2C_M_RD,\n\t\t\t       .buf = &data, .len = 1 };\n\n\trc = tuner_transfer(fe, &msg, 1);\n\n\tif (rc < 0) {\n\t\tprintk(\"%s: could not read from tuner at addr: 0x%02x\\n\",\n\t\t       __func__, msg.addr << 1);\n\t\treturn rc;\n\t}\n\tif ((data & 0x3c) == 0) {\n\t\tdprintk(\"tda827x tuner found\\n\");\n\t\tfe->ops.tuner_ops.init  = tda827x_init;\n\t\tfe->ops.tuner_ops.sleep = tda827xo_sleep;\n\t\tif (priv->cfg)\n\t\t\tpriv->cfg->agcf = tda827xo_agcf;\n\t} else {\n\t\tdprintk(\"tda827xa tuner found\\n\");\n\t\tmemcpy(&fe->ops.tuner_ops, &tda827xa_tuner_ops, sizeof(struct dvb_tuner_ops));\n\t\tif (priv->cfg)\n\t\t\tpriv->cfg->agcf = tda827xa_agcf;\n\t}\n\treturn 0;\n}\n\nstruct dvb_frontend *tda827x_attach(struct dvb_frontend *fe, int addr,\n\t\t\t\t    struct i2c_adapter *i2c,\n\t\t\t\t    struct tda827x_config *cfg)\n{\n\tstruct tda827x_priv *priv = NULL;\n\n\tdprintk(\"%s:\\n\", __func__);\n\tpriv = kzalloc(sizeof(struct tda827x_priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn NULL;\n\n\tpriv->i2c_addr = addr;\n\tpriv->i2c_adap = i2c;\n\tpriv->cfg = cfg;\n\tmemcpy(&fe->ops.tuner_ops, &tda827xo_tuner_ops, sizeof(struct dvb_tuner_ops));\n\tfe->tuner_priv = priv;\n\n\tdprintk(\"type set to %s\\n\", fe->ops.tuner_ops.info.name);\n\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(tda827x_attach);\n\nMODULE_DESCRIPTION(\"DVB TDA827x driver\");\nMODULE_AUTHOR(\"Hartmut Hackmann <hartmut.hackmann@t-online.de>\");\nMODULE_AUTHOR(\"Michael Krufky <mkrufky@linuxtv.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}