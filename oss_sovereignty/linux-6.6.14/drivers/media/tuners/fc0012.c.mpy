{
  "module_name": "fc0012.c",
  "hash_id": "4c86d58f3fc2598dd588f210f6fd225c70fbf095c4cd8dd8f929bd49a3a45bad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/fc0012.c",
  "human_readable_source": "\n \n\n#include \"fc0012.h\"\n#include \"fc0012-priv.h\"\n\nstatic int fc0012_writereg(struct fc0012_priv *priv, u8 reg, u8 val)\n{\n\tu8 buf[2] = {reg, val};\n\tstruct i2c_msg msg = {\n\t\t.addr = priv->cfg->i2c_address, .flags = 0, .buf = buf, .len = 2\n\t};\n\n\tif (i2c_transfer(priv->i2c, &msg, 1) != 1) {\n\t\tdev_err(&priv->i2c->dev,\n\t\t\t\"%s: I2C write reg failed, reg: %02x, val: %02x\\n\",\n\t\t\tKBUILD_MODNAME, reg, val);\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic int fc0012_readreg(struct fc0012_priv *priv, u8 reg, u8 *val)\n{\n\tstruct i2c_msg msg[2] = {\n\t\t{ .addr = priv->cfg->i2c_address, .flags = 0,\n\t\t\t.buf = &reg, .len = 1 },\n\t\t{ .addr = priv->cfg->i2c_address, .flags = I2C_M_RD,\n\t\t\t.buf = val, .len = 1 },\n\t};\n\n\tif (i2c_transfer(priv->i2c, msg, 2) != 2) {\n\t\tdev_err(&priv->i2c->dev,\n\t\t\t\"%s: I2C read reg failed, reg: %02x\\n\",\n\t\t\tKBUILD_MODNAME, reg);\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic void fc0012_release(struct dvb_frontend *fe)\n{\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic int fc0012_init(struct dvb_frontend *fe)\n{\n\tstruct fc0012_priv *priv = fe->tuner_priv;\n\tint i, ret = 0;\n\tunsigned char reg[] = {\n\t\t0x00,\t \n\t\t0x05,\t \n\t\t0x10,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x0f,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0xff,\t \n\t\t0x6e,\t \n\t\t0xb8,\t \n\t\t0x82,\t \n\t\t0xfc,\t \n\t\t0x02,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x1f,\t \n\t\t0x08,\t \n\t\t0x00,\t \n\t\t0x04,\t \n\t};\n\n\tswitch (priv->cfg->xtal_freq) {\n\tcase FC_XTAL_27_MHZ:\n\tcase FC_XTAL_28_8_MHZ:\n\t\treg[0x07] |= 0x20;\n\t\tbreak;\n\tcase FC_XTAL_36_MHZ:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (priv->cfg->dual_master)\n\t\treg[0x0c] |= 0x02;\n\n\tif (priv->cfg->loop_through)\n\t\treg[0x09] |= 0x01;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\tfor (i = 1; i < sizeof(reg); i++) {\n\t\tret = fc0012_writereg(priv, i, reg[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\tif (ret)\n\t\tdev_err(&priv->i2c->dev, \"%s: fc0012_writereg failed: %d\\n\",\n\t\t\t\tKBUILD_MODNAME, ret);\n\n\treturn ret;\n}\n\nstatic int fc0012_set_params(struct dvb_frontend *fe)\n{\n\tstruct fc0012_priv *priv = fe->tuner_priv;\n\tint i, ret = 0;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tu32 freq = p->frequency / 1000;\n\tu32 delsys = p->delivery_system;\n\tunsigned char reg[7], am, pm, multi, tmp;\n\tunsigned long f_vco;\n\tunsigned short xtal_freq_khz_2, xin, xdiv;\n\tbool vco_select = false;\n\n\tif (fe->callback) {\n\t\tret = fe->callback(priv->i2c, DVB_FRONTEND_COMPONENT_TUNER,\n\t\t\tFC_FE_CALLBACK_VHF_ENABLE, (freq > 300000 ? 0 : 1));\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\tswitch (priv->cfg->xtal_freq) {\n\tcase FC_XTAL_27_MHZ:\n\t\txtal_freq_khz_2 = 27000 / 2;\n\t\tbreak;\n\tcase FC_XTAL_36_MHZ:\n\t\txtal_freq_khz_2 = 36000 / 2;\n\t\tbreak;\n\tcase FC_XTAL_28_8_MHZ:\n\tdefault:\n\t\txtal_freq_khz_2 = 28800 / 2;\n\t\tbreak;\n\t}\n\n\t \n\tif (freq < 37084) {\t\t \n\t\tmulti = 96;\n\t\treg[5] = 0x82;\n\t\treg[6] = 0x00;\n\t} else if (freq < 55625) {\t \n\t\tmulti = 64;\n\t\treg[5] = 0x82;\n\t\treg[6] = 0x02;\n\t} else if (freq < 74167) {\t \n\t\tmulti = 48;\n\t\treg[5] = 0x42;\n\t\treg[6] = 0x00;\n\t} else if (freq < 111250) {\t \n\t\tmulti = 32;\n\t\treg[5] = 0x42;\n\t\treg[6] = 0x02;\n\t} else if (freq < 148334) {\t \n\t\tmulti = 24;\n\t\treg[5] = 0x22;\n\t\treg[6] = 0x00;\n\t} else if (freq < 222500) {\t \n\t\tmulti = 16;\n\t\treg[5] = 0x22;\n\t\treg[6] = 0x02;\n\t} else if (freq < 296667) {\t \n\t\tmulti = 12;\n\t\treg[5] = 0x12;\n\t\treg[6] = 0x00;\n\t} else if (freq < 445000) {\t \n\t\tmulti = 8;\n\t\treg[5] = 0x12;\n\t\treg[6] = 0x02;\n\t} else if (freq < 593334) {\t \n\t\tmulti = 6;\n\t\treg[5] = 0x0a;\n\t\treg[6] = 0x00;\n\t} else {\n\t\tmulti = 4;\n\t\treg[5] = 0x0a;\n\t\treg[6] = 0x02;\n\t}\n\n\tf_vco = freq * multi;\n\n\tif (f_vco >= 3060000) {\n\t\treg[6] |= 0x08;\n\t\tvco_select = true;\n\t}\n\n\tif (freq >= 45000) {\n\t\t \n\t\txdiv = (unsigned short)(f_vco / xtal_freq_khz_2);\n\t\tif ((f_vco - xdiv * xtal_freq_khz_2) >= (xtal_freq_khz_2 / 2))\n\t\t\txdiv++;\n\n\t\tpm = (unsigned char)(xdiv / 8);\n\t\tam = (unsigned char)(xdiv - (8 * pm));\n\n\t\tif (am < 2) {\n\t\t\treg[1] = am + 8;\n\t\t\treg[2] = pm - 1;\n\t\t} else {\n\t\t\treg[1] = am;\n\t\t\treg[2] = pm;\n\t\t}\n\t} else {\n\t\t \n\t\treg[1] = 0x06;\n\t\treg[2] = 0x11;\n\t}\n\n\t \n\treg[6] |= 0x20;\n\n\t \n\txin = (unsigned short)(f_vco - (f_vco / xtal_freq_khz_2) * xtal_freq_khz_2);\n\txin = (xin << 15) / xtal_freq_khz_2;\n\tif (xin >= 16384)\n\t\txin += 32768;\n\n\treg[3] = xin >> 8;\t \n\treg[4] = xin & 0xff;\n\n\tif (delsys == SYS_DVBT) {\n\t\treg[6] &= 0x3f;\t \n\t\tswitch (p->bandwidth_hz) {\n\t\tcase 6000000:\n\t\t\treg[6] |= 0x80;\n\t\t\tbreak;\n\t\tcase 7000000:\n\t\t\treg[6] |= 0x40;\n\t\t\tbreak;\n\t\tcase 8000000:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdev_err(&priv->i2c->dev, \"%s: modulation type not supported!\\n\",\n\t\t\t\tKBUILD_MODNAME);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treg[5] |= 0x07;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\tfor (i = 1; i <= 6; i++) {\n\t\tret = fc0012_writereg(priv, i, reg[i]);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\t \n\tret = fc0012_writereg(priv, 0x0e, 0x80);\n\tif (!ret)\n\t\tret = fc0012_writereg(priv, 0x0e, 0x00);\n\n\t \n\tif (!ret)\n\t\tret = fc0012_writereg(priv, 0x0e, 0x00);\n\n\tif (!ret) {\n\t\tmsleep(10);\n\t\tret = fc0012_readreg(priv, 0x0e, &tmp);\n\t}\n\tif (ret)\n\t\tgoto exit;\n\n\t \n\ttmp &= 0x3f;\n\n\tif (vco_select) {\n\t\tif (tmp > 0x3c) {\n\t\t\treg[6] &= ~0x08;\n\t\t\tret = fc0012_writereg(priv, 0x06, reg[6]);\n\t\t\tif (!ret)\n\t\t\t\tret = fc0012_writereg(priv, 0x0e, 0x80);\n\t\t\tif (!ret)\n\t\t\t\tret = fc0012_writereg(priv, 0x0e, 0x00);\n\t\t}\n\t} else {\n\t\tif (tmp < 0x02) {\n\t\t\treg[6] |= 0x08;\n\t\t\tret = fc0012_writereg(priv, 0x06, reg[6]);\n\t\t\tif (!ret)\n\t\t\t\tret = fc0012_writereg(priv, 0x0e, 0x80);\n\t\t\tif (!ret)\n\t\t\t\tret = fc0012_writereg(priv, 0x0e, 0x00);\n\t\t}\n\t}\n\n\tpriv->frequency = p->frequency;\n\tpriv->bandwidth = p->bandwidth_hz;\n\nexit:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\tif (ret)\n\t\tdev_warn(&priv->i2c->dev, \"%s: %s failed: %d\\n\",\n\t\t\t\tKBUILD_MODNAME, __func__, ret);\n\treturn ret;\n}\n\nstatic int fc0012_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct fc0012_priv *priv = fe->tuner_priv;\n\t*frequency = priv->frequency;\n\treturn 0;\n}\n\nstatic int fc0012_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\t*frequency = 0;  \n\treturn 0;\n}\n\nstatic int fc0012_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\n{\n\tstruct fc0012_priv *priv = fe->tuner_priv;\n\t*bandwidth = priv->bandwidth;\n\treturn 0;\n}\n\n#define INPUT_ADC_LEVEL\t-8\n\nstatic int fc0012_get_rf_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct fc0012_priv *priv = fe->tuner_priv;\n\tint ret;\n\tunsigned char tmp;\n\tint int_temp, lna_gain, int_lna, tot_agc_gain, power;\n\tstatic const int fc0012_lna_gain_table[] = {\n\t\t \n\t\t-63, -58, -99, -73,\n\t\t-63, -65, -54, -60,\n\t\t \n\t\t 71,  70,  68,  67,\n\t\t 65,  63,  61,  58,\n\t\t \n\t\t197, 191, 188, 186,\n\t\t184, 182, 181, 179,\n\t};\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\tret = fc0012_writereg(priv, 0x12, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc0012_readreg(priv, 0x12, &tmp);\n\tif (ret)\n\t\tgoto err;\n\tint_temp = tmp;\n\n\tret = fc0012_readreg(priv, 0x13, &tmp);\n\tif (ret)\n\t\tgoto err;\n\tlna_gain = tmp & 0x1f;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\tif (lna_gain < ARRAY_SIZE(fc0012_lna_gain_table)) {\n\t\tint_lna = fc0012_lna_gain_table[lna_gain];\n\t\ttot_agc_gain = (abs((int_temp >> 5) - 7) - 2 +\n\t\t\t\t(int_temp & 0x1f)) * 2;\n\t\tpower = INPUT_ADC_LEVEL - tot_agc_gain - int_lna / 10;\n\n\t\tif (power >= 45)\n\t\t\t*strength = 255;\t \n\t\telse if (power < -95)\n\t\t\t*strength = 0;\n\t\telse\n\t\t\t*strength = (power + 95) * 255 / 140;\n\n\t\t*strength |= *strength << 8;\n\t} else {\n\t\tret = -1;\n\t}\n\n\tgoto exit;\n\nerr:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \nexit:\n\tif (ret)\n\t\tdev_warn(&priv->i2c->dev, \"%s: %s failed: %d\\n\",\n\t\t\t\tKBUILD_MODNAME, __func__, ret);\n\treturn ret;\n}\n\nstatic const struct dvb_tuner_ops fc0012_tuner_ops = {\n\t.info = {\n\t\t.name              = \"Fitipower FC0012\",\n\n\t\t.frequency_min_hz  =  37 * MHz,\t \n\t\t.frequency_max_hz  = 862 * MHz,\t \n\t},\n\n\t.release\t= fc0012_release,\n\n\t.init\t\t= fc0012_init,\n\n\t.set_params\t= fc0012_set_params,\n\n\t.get_frequency\t= fc0012_get_frequency,\n\t.get_if_frequency = fc0012_get_if_frequency,\n\t.get_bandwidth\t= fc0012_get_bandwidth,\n\n\t.get_rf_strength = fc0012_get_rf_strength,\n};\n\nstruct dvb_frontend *fc0012_attach(struct dvb_frontend *fe,\n\tstruct i2c_adapter *i2c, const struct fc0012_config *cfg)\n{\n\tstruct fc0012_priv *priv;\n\tint ret;\n\tu8 chip_id;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tpriv = kzalloc(sizeof(struct fc0012_priv), GFP_KERNEL);\n\tif (!priv) {\n\t\tret = -ENOMEM;\n\t\tdev_err(&i2c->dev, \"%s: kzalloc() failed\\n\", KBUILD_MODNAME);\n\t\tgoto err;\n\t}\n\n\tpriv->cfg = cfg;\n\tpriv->i2c = i2c;\n\n\t \n\tret = fc0012_readreg(priv, 0x00, &chip_id);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tdev_dbg(&i2c->dev, \"%s: chip_id=%02x\\n\", __func__, chip_id);\n\n\tswitch (chip_id) {\n\tcase 0xa1:\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tdev_info(&i2c->dev, \"%s: Fitipower FC0012 successfully identified\\n\",\n\t\t\tKBUILD_MODNAME);\n\n\tif (priv->cfg->loop_through) {\n\t\tret = fc0012_writereg(priv, 0x09, 0x6f);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\t \n\tif (priv->cfg->clock_out) {\n\t\tret =  fc0012_writereg(priv, 0x0b, 0x82);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tfe->tuner_priv = priv;\n\tmemcpy(&fe->ops.tuner_ops, &fc0012_tuner_ops,\n\t\tsizeof(struct dvb_tuner_ops));\n\nerr:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tif (ret) {\n\t\tdev_dbg(&i2c->dev, \"%s: failed: %d\\n\", __func__, ret);\n\t\tkfree(priv);\n\t\treturn NULL;\n\t}\n\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(fc0012_attach);\n\nMODULE_DESCRIPTION(\"Fitipower FC0012 silicon tuner driver\");\nMODULE_AUTHOR(\"Hans-Frieder Vogt <hfvogt@gmx.net>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.6\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}