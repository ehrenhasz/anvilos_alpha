{
  "module_name": "mxl5007t.c",
  "hash_id": "6ad1a7964e138ef52eb4345b91a3ca18f0d8026f85c12656417d38292e939fd7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/mxl5007t.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/types.h>\n#include <linux/videodev2.h>\n#include \"tuner-i2c.h\"\n#include \"mxl5007t.h\"\n\nstatic DEFINE_MUTEX(mxl5007t_list_mutex);\nstatic LIST_HEAD(hybrid_tuner_instance_list);\n\nstatic int mxl5007t_debug;\nmodule_param_named(debug, mxl5007t_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debug level\");\n\n \n\n#define mxl_printk(kern, fmt, arg...) \\\n\tprintk(kern \"%s: \" fmt \"\\n\", __func__, ##arg)\n\n#define mxl_err(fmt, arg...) \\\n\tmxl_printk(KERN_ERR, \"%d: \" fmt, __LINE__, ##arg)\n\n#define mxl_warn(fmt, arg...) \\\n\tmxl_printk(KERN_WARNING, fmt, ##arg)\n\n#define mxl_info(fmt, arg...) \\\n\tmxl_printk(KERN_INFO, fmt, ##arg)\n\n#define mxl_debug(fmt, arg...)\t\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\tif (mxl5007t_debug)\t\t\t\t\\\n\t\tmxl_printk(KERN_DEBUG, fmt, ##arg);\t\\\n})\n\n#define mxl_fail(ret)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint __ret;\t\t\t\t\t\t\t\\\n\t__ret = (ret < 0);\t\t\t\t\t\t\\\n\tif (__ret)\t\t\t\t\t\t\t\\\n\t\tmxl_printk(KERN_ERR, \"error %d on line %d\",\t\t\\\n\t\t\t   ret, __LINE__);\t\t\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\\\n})\n\n \n\nenum mxl5007t_mode {\n\tMxL_MODE_ISDBT     =    0,\n\tMxL_MODE_DVBT      =    1,\n\tMxL_MODE_ATSC      =    2,\n\tMxL_MODE_CABLE     = 0x10,\n};\n\nenum mxl5007t_chip_version {\n\tMxL_UNKNOWN_ID     = 0x00,\n\tMxL_5007_V1_F1     = 0x11,\n\tMxL_5007_V1_F2     = 0x12,\n\tMxL_5007_V4        = 0x14,\n\tMxL_5007_V2_100_F1 = 0x21,\n\tMxL_5007_V2_100_F2 = 0x22,\n\tMxL_5007_V2_200_F1 = 0x23,\n\tMxL_5007_V2_200_F2 = 0x24,\n};\n\nstruct reg_pair_t {\n\tu8 reg;\n\tu8 val;\n};\n\n \n\nstatic struct reg_pair_t init_tab[] = {\n\t{ 0x02, 0x06 },\n\t{ 0x03, 0x48 },\n\t{ 0x05, 0x04 },\n\t{ 0x06, 0x10 },\n\t{ 0x2e, 0x15 },  \n\t{ 0x30, 0x10 },  \n\t{ 0x45, 0x58 },  \n\t{ 0x48, 0x19 },  \n\t{ 0x52, 0x03 },  \n\t{ 0x53, 0x44 },  \n\t{ 0x6a, 0x4b },  \n\t{ 0x76, 0x00 },  \n\t{ 0x78, 0x18 },  \n\t{ 0x7a, 0x17 },  \n\t{ 0x85, 0x06 },  \n\t{ 0x01, 0x01 },  \n\t{ 0, 0 }\n};\n\nstatic struct reg_pair_t init_tab_cable[] = {\n\t{ 0x02, 0x06 },\n\t{ 0x03, 0x48 },\n\t{ 0x05, 0x04 },\n\t{ 0x06, 0x10 },\n\t{ 0x09, 0x3f },\n\t{ 0x0a, 0x3f },\n\t{ 0x0b, 0x3f },\n\t{ 0x2e, 0x15 },  \n\t{ 0x30, 0x10 },  \n\t{ 0x45, 0x58 },  \n\t{ 0x48, 0x19 },  \n\t{ 0x52, 0x03 },  \n\t{ 0x53, 0x44 },  \n\t{ 0x6a, 0x4b },  \n\t{ 0x76, 0x00 },  \n\t{ 0x78, 0x18 },  \n\t{ 0x7a, 0x17 },  \n\t{ 0x85, 0x06 },  \n\t{ 0x01, 0x01 },  \n\t{ 0, 0 }\n};\n\n \n\nstatic struct reg_pair_t reg_pair_rftune[] = {\n\t{ 0x0f, 0x00 },  \n\t{ 0x0c, 0x15 },\n\t{ 0x0d, 0x40 },\n\t{ 0x0e, 0x0e },\n\t{ 0x1f, 0x87 },  \n\t{ 0x20, 0x1f },  \n\t{ 0x21, 0x87 },  \n\t{ 0x22, 0x1f },  \n\t{ 0x80, 0x01 },  \n\t{ 0x0f, 0x01 },  \n\t{ 0, 0 }\n};\n\n \n\nstruct mxl5007t_state {\n\tstruct list_head hybrid_tuner_instance_list;\n\tstruct tuner_i2c_props i2c_props;\n\n\tstruct mutex lock;\n\n\tstruct mxl5007t_config *config;\n\n\tenum mxl5007t_chip_version chip_id;\n\n\tstruct reg_pair_t tab_init[ARRAY_SIZE(init_tab)];\n\tstruct reg_pair_t tab_init_cable[ARRAY_SIZE(init_tab_cable)];\n\tstruct reg_pair_t tab_rftune[ARRAY_SIZE(reg_pair_rftune)];\n\n\tenum mxl5007t_if_freq if_freq;\n\n\tu32 frequency;\n\tu32 bandwidth;\n};\n\n \n\n \n\nstatic void set_reg_bits(struct reg_pair_t *reg_pair, u8 reg, u8 mask, u8 val)\n{\n\tunsigned int i = 0;\n\n\twhile (reg_pair[i].reg || reg_pair[i].val) {\n\t\tif (reg_pair[i].reg == reg) {\n\t\t\treg_pair[i].val &= ~mask;\n\t\t\treg_pair[i].val |= val;\n\t\t}\n\t\ti++;\n\n\t}\n}\n\nstatic void copy_reg_bits(struct reg_pair_t *reg_pair1,\n\t\t\t  struct reg_pair_t *reg_pair2)\n{\n\tunsigned int i, j;\n\n\ti = j = 0;\n\n\twhile (reg_pair1[i].reg || reg_pair1[i].val) {\n\t\twhile (reg_pair2[j].reg || reg_pair2[j].val) {\n\t\t\tif (reg_pair1[i].reg != reg_pair2[j].reg) {\n\t\t\t\tj++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treg_pair2[j].val = reg_pair1[i].val;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n}\n\n \n\nstatic void mxl5007t_set_mode_bits(struct mxl5007t_state *state,\n\t\t\t\t   enum mxl5007t_mode mode,\n\t\t\t\t   s32 if_diff_out_level)\n{\n\tswitch (mode) {\n\tcase MxL_MODE_ATSC:\n\t\tset_reg_bits(state->tab_init, 0x06, 0x1f, 0x12);\n\t\tbreak;\n\tcase MxL_MODE_DVBT:\n\t\tset_reg_bits(state->tab_init, 0x06, 0x1f, 0x11);\n\t\tbreak;\n\tcase MxL_MODE_ISDBT:\n\t\tset_reg_bits(state->tab_init, 0x06, 0x1f, 0x10);\n\t\tbreak;\n\tcase MxL_MODE_CABLE:\n\t\tset_reg_bits(state->tab_init_cable, 0x09, 0xff, 0xc1);\n\t\tset_reg_bits(state->tab_init_cable, 0x0a, 0xff,\n\t\t\t     8 - if_diff_out_level);\n\t\tset_reg_bits(state->tab_init_cable, 0x0b, 0xff, 0x17);\n\t\tbreak;\n\tdefault:\n\t\tmxl_fail(-EINVAL);\n\t}\n}\n\nstatic void mxl5007t_set_if_freq_bits(struct mxl5007t_state *state,\n\t\t\t\t      enum mxl5007t_if_freq if_freq,\n\t\t\t\t      int invert_if)\n{\n\tu8 val;\n\n\tswitch (if_freq) {\n\tcase MxL_IF_4_MHZ:\n\t\tval = 0x00;\n\t\tbreak;\n\tcase MxL_IF_4_5_MHZ:\n\t\tval = 0x02;\n\t\tbreak;\n\tcase MxL_IF_4_57_MHZ:\n\t\tval = 0x03;\n\t\tbreak;\n\tcase MxL_IF_5_MHZ:\n\t\tval = 0x04;\n\t\tbreak;\n\tcase MxL_IF_5_38_MHZ:\n\t\tval = 0x05;\n\t\tbreak;\n\tcase MxL_IF_6_MHZ:\n\t\tval = 0x06;\n\t\tbreak;\n\tcase MxL_IF_6_28_MHZ:\n\t\tval = 0x07;\n\t\tbreak;\n\tcase MxL_IF_9_1915_MHZ:\n\t\tval = 0x08;\n\t\tbreak;\n\tcase MxL_IF_35_25_MHZ:\n\t\tval = 0x09;\n\t\tbreak;\n\tcase MxL_IF_36_15_MHZ:\n\t\tval = 0x0a;\n\t\tbreak;\n\tcase MxL_IF_44_MHZ:\n\t\tval = 0x0b;\n\t\tbreak;\n\tdefault:\n\t\tmxl_fail(-EINVAL);\n\t\treturn;\n\t}\n\tset_reg_bits(state->tab_init, 0x02, 0x0f, val);\n\n\t \n\tset_reg_bits(state->tab_init, 0x02, 0x10, invert_if ? 0x10 : 0x00);\n\n\tstate->if_freq = if_freq;\n}\n\nstatic void mxl5007t_set_xtal_freq_bits(struct mxl5007t_state *state,\n\t\t\t\t\tenum mxl5007t_xtal_freq xtal_freq)\n{\n\tswitch (xtal_freq) {\n\tcase MxL_XTAL_16_MHZ:\n\t\t \n\t\tset_reg_bits(state->tab_init, 0x03, 0xf0, 0x00);\n\t\tset_reg_bits(state->tab_init, 0x05, 0x0f, 0x00);\n\t\tbreak;\n\tcase MxL_XTAL_20_MHZ:\n\t\tset_reg_bits(state->tab_init, 0x03, 0xf0, 0x10);\n\t\tset_reg_bits(state->tab_init, 0x05, 0x0f, 0x01);\n\t\tbreak;\n\tcase MxL_XTAL_20_25_MHZ:\n\t\tset_reg_bits(state->tab_init, 0x03, 0xf0, 0x20);\n\t\tset_reg_bits(state->tab_init, 0x05, 0x0f, 0x02);\n\t\tbreak;\n\tcase MxL_XTAL_20_48_MHZ:\n\t\tset_reg_bits(state->tab_init, 0x03, 0xf0, 0x30);\n\t\tset_reg_bits(state->tab_init, 0x05, 0x0f, 0x03);\n\t\tbreak;\n\tcase MxL_XTAL_24_MHZ:\n\t\tset_reg_bits(state->tab_init, 0x03, 0xf0, 0x40);\n\t\tset_reg_bits(state->tab_init, 0x05, 0x0f, 0x04);\n\t\tbreak;\n\tcase MxL_XTAL_25_MHZ:\n\t\tset_reg_bits(state->tab_init, 0x03, 0xf0, 0x50);\n\t\tset_reg_bits(state->tab_init, 0x05, 0x0f, 0x05);\n\t\tbreak;\n\tcase MxL_XTAL_25_14_MHZ:\n\t\tset_reg_bits(state->tab_init, 0x03, 0xf0, 0x60);\n\t\tset_reg_bits(state->tab_init, 0x05, 0x0f, 0x06);\n\t\tbreak;\n\tcase MxL_XTAL_27_MHZ:\n\t\tset_reg_bits(state->tab_init, 0x03, 0xf0, 0x70);\n\t\tset_reg_bits(state->tab_init, 0x05, 0x0f, 0x07);\n\t\tbreak;\n\tcase MxL_XTAL_28_8_MHZ:\n\t\tset_reg_bits(state->tab_init, 0x03, 0xf0, 0x80);\n\t\tset_reg_bits(state->tab_init, 0x05, 0x0f, 0x08);\n\t\tbreak;\n\tcase MxL_XTAL_32_MHZ:\n\t\tset_reg_bits(state->tab_init, 0x03, 0xf0, 0x90);\n\t\tset_reg_bits(state->tab_init, 0x05, 0x0f, 0x09);\n\t\tbreak;\n\tcase MxL_XTAL_40_MHZ:\n\t\tset_reg_bits(state->tab_init, 0x03, 0xf0, 0xa0);\n\t\tset_reg_bits(state->tab_init, 0x05, 0x0f, 0x0a);\n\t\tbreak;\n\tcase MxL_XTAL_44_MHZ:\n\t\tset_reg_bits(state->tab_init, 0x03, 0xf0, 0xb0);\n\t\tset_reg_bits(state->tab_init, 0x05, 0x0f, 0x0b);\n\t\tbreak;\n\tcase MxL_XTAL_48_MHZ:\n\t\tset_reg_bits(state->tab_init, 0x03, 0xf0, 0xc0);\n\t\tset_reg_bits(state->tab_init, 0x05, 0x0f, 0x0c);\n\t\tbreak;\n\tcase MxL_XTAL_49_3811_MHZ:\n\t\tset_reg_bits(state->tab_init, 0x03, 0xf0, 0xd0);\n\t\tset_reg_bits(state->tab_init, 0x05, 0x0f, 0x0d);\n\t\tbreak;\n\tdefault:\n\t\tmxl_fail(-EINVAL);\n\t\treturn;\n\t}\n}\n\nstatic struct reg_pair_t *mxl5007t_calc_init_regs(struct mxl5007t_state *state,\n\t\t\t\t\t\t  enum mxl5007t_mode mode)\n{\n\tstruct mxl5007t_config *cfg = state->config;\n\n\tmemcpy(&state->tab_init, &init_tab, sizeof(init_tab));\n\tmemcpy(&state->tab_init_cable, &init_tab_cable, sizeof(init_tab_cable));\n\n\tmxl5007t_set_mode_bits(state, mode, cfg->if_diff_out_level);\n\tmxl5007t_set_if_freq_bits(state, cfg->if_freq_hz, cfg->invert_if);\n\tmxl5007t_set_xtal_freq_bits(state, cfg->xtal_freq_hz);\n\n\tset_reg_bits(state->tab_init, 0x03, 0x08, cfg->clk_out_enable << 3);\n\tset_reg_bits(state->tab_init, 0x03, 0x07, cfg->clk_out_amp);\n\n\tif (mode >= MxL_MODE_CABLE) {\n\t\tcopy_reg_bits(state->tab_init, state->tab_init_cable);\n\t\treturn state->tab_init_cable;\n\t} else\n\t\treturn state->tab_init;\n}\n\n \n\nenum mxl5007t_bw_mhz {\n\tMxL_BW_6MHz = 6,\n\tMxL_BW_7MHz = 7,\n\tMxL_BW_8MHz = 8,\n};\n\nstatic void mxl5007t_set_bw_bits(struct mxl5007t_state *state,\n\t\t\t\t enum mxl5007t_bw_mhz bw)\n{\n\tu8 val;\n\n\tswitch (bw) {\n\tcase MxL_BW_6MHz:\n\t\tval = 0x15;  \n\t\tbreak;\n\tcase MxL_BW_7MHz:\n\t\tval = 0x2a;\n\t\tbreak;\n\tcase MxL_BW_8MHz:\n\t\tval = 0x3f;\n\t\tbreak;\n\tdefault:\n\t\tmxl_fail(-EINVAL);\n\t\treturn;\n\t}\n\tset_reg_bits(state->tab_rftune, 0x0c, 0x3f, val);\n}\n\nstatic struct\nreg_pair_t *mxl5007t_calc_rf_tune_regs(struct mxl5007t_state *state,\n\t\t\t\t       u32 rf_freq, enum mxl5007t_bw_mhz bw)\n{\n\tu32 dig_rf_freq = 0;\n\tu32 temp;\n\tu32 frac_divider = 1000000;\n\tunsigned int i;\n\n\tmemcpy(&state->tab_rftune, &reg_pair_rftune, sizeof(reg_pair_rftune));\n\n\tmxl5007t_set_bw_bits(state, bw);\n\n\t \n\tdig_rf_freq = rf_freq / MHz;\n\n\ttemp = rf_freq % MHz;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tdig_rf_freq <<= 1;\n\t\tfrac_divider /= 2;\n\t\tif (temp > frac_divider) {\n\t\t\ttemp -= frac_divider;\n\t\t\tdig_rf_freq++;\n\t\t}\n\t}\n\n\t \n\tif (temp > 7812)\n\t\tdig_rf_freq++;\n\n\tset_reg_bits(state->tab_rftune, 0x0d, 0xff, (u8) dig_rf_freq);\n\tset_reg_bits(state->tab_rftune, 0x0e, 0xff, (u8) (dig_rf_freq >> 8));\n\n\tif (rf_freq >= 333000000)\n\t\tset_reg_bits(state->tab_rftune, 0x80, 0x40, 0x40);\n\n\treturn state->tab_rftune;\n}\n\n \n\nstatic int mxl5007t_write_reg(struct mxl5007t_state *state, u8 reg, u8 val)\n{\n\tu8 buf[] = { reg, val };\n\tstruct i2c_msg msg = { .addr = state->i2c_props.addr, .flags = 0,\n\t\t\t       .buf = buf, .len = 2 };\n\tint ret;\n\n\tret = i2c_transfer(state->i2c_props.adap, &msg, 1);\n\tif (ret != 1) {\n\t\tmxl_err(\"failed!\");\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic int mxl5007t_write_regs(struct mxl5007t_state *state,\n\t\t\t       struct reg_pair_t *reg_pair)\n{\n\tunsigned int i = 0;\n\tint ret = 0;\n\n\twhile ((ret == 0) && (reg_pair[i].reg || reg_pair[i].val)) {\n\t\tret = mxl5007t_write_reg(state,\n\t\t\t\t\t reg_pair[i].reg, reg_pair[i].val);\n\t\ti++;\n\t}\n\treturn ret;\n}\n\nstatic int mxl5007t_read_reg(struct mxl5007t_state *state, u8 reg, u8 *val)\n{\n\tu8 buf[2] = { 0xfb, reg };\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = state->i2c_props.addr, .flags = 0,\n\t\t  .buf = buf, .len = 2 },\n\t\t{ .addr = state->i2c_props.addr, .flags = I2C_M_RD,\n\t\t  .buf = val, .len = 1 },\n\t};\n\tint ret;\n\n\tret = i2c_transfer(state->i2c_props.adap, msg, 2);\n\tif (ret != 2) {\n\t\tmxl_err(\"failed!\");\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic int mxl5007t_soft_reset(struct mxl5007t_state *state)\n{\n\tu8 d = 0xff;\n\tstruct i2c_msg msg = {\n\t\t.addr = state->i2c_props.addr, .flags = 0,\n\t\t.buf = &d, .len = 1\n\t};\n\tint ret = i2c_transfer(state->i2c_props.adap, &msg, 1);\n\n\tif (ret != 1) {\n\t\tmxl_err(\"failed!\");\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic int mxl5007t_tuner_init(struct mxl5007t_state *state,\n\t\t\t       enum mxl5007t_mode mode)\n{\n\tstruct reg_pair_t *init_regs;\n\tint ret;\n\n\t \n\tinit_regs = mxl5007t_calc_init_regs(state, mode);\n\n\tret = mxl5007t_write_regs(state, init_regs);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tmdelay(1);\nfail:\n\treturn ret;\n}\n\nstatic int mxl5007t_tuner_rf_tune(struct mxl5007t_state *state, u32 rf_freq_hz,\n\t\t\t\t  enum mxl5007t_bw_mhz bw)\n{\n\tstruct reg_pair_t *rf_tune_regs;\n\tint ret;\n\n\t \n\trf_tune_regs = mxl5007t_calc_rf_tune_regs(state, rf_freq_hz, bw);\n\n\tret = mxl5007t_write_regs(state, rf_tune_regs);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tmsleep(3);\nfail:\n\treturn ret;\n}\n\n \n\nstatic int mxl5007t_synth_lock_status(struct mxl5007t_state *state,\n\t\t\t\t      int *rf_locked, int *ref_locked)\n{\n\tu8 d;\n\tint ret;\n\n\t*rf_locked = 0;\n\t*ref_locked = 0;\n\n\tret = mxl5007t_read_reg(state, 0xd8, &d);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tif ((d & 0x0c) == 0x0c)\n\t\t*rf_locked = 1;\n\n\tif ((d & 0x03) == 0x03)\n\t\t*ref_locked = 1;\nfail:\n\treturn ret;\n}\n\n \n\nstatic int mxl5007t_get_status(struct dvb_frontend *fe, u32 *status)\n{\n\tstruct mxl5007t_state *state = fe->tuner_priv;\n\tint rf_locked, ref_locked, ret;\n\n\t*status = 0;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tret = mxl5007t_synth_lock_status(state, &rf_locked, &ref_locked);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tmxl_debug(\"%s%s\", rf_locked ? \"rf locked \" : \"\",\n\t\t  ref_locked ? \"ref locked\" : \"\");\n\n\tif ((rf_locked) || (ref_locked))\n\t\t*status |= TUNER_STATUS_LOCKED;\nfail:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\treturn ret;\n}\n\n \n\nstatic int mxl5007t_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 delsys = c->delivery_system;\n\tstruct mxl5007t_state *state = fe->tuner_priv;\n\tenum mxl5007t_bw_mhz bw;\n\tenum mxl5007t_mode mode;\n\tint ret;\n\tu32 freq = c->frequency;\n\n\tswitch (delsys) {\n\tcase SYS_ATSC:\n\t\tmode = MxL_MODE_ATSC;\n\t\tbw = MxL_BW_6MHz;\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_B:\n\t\tmode = MxL_MODE_CABLE;\n\t\tbw = MxL_BW_6MHz;\n\t\tbreak;\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tmode = MxL_MODE_DVBT;\n\t\tswitch (c->bandwidth_hz) {\n\t\tcase 6000000:\n\t\t\tbw = MxL_BW_6MHz;\n\t\t\tbreak;\n\t\tcase 7000000:\n\t\t\tbw = MxL_BW_7MHz;\n\t\t\tbreak;\n\t\tcase 8000000:\n\t\t\tbw = MxL_BW_8MHz;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tmxl_err(\"modulation type not supported!\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tmutex_lock(&state->lock);\n\n\tret = mxl5007t_tuner_init(state, mode);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl5007t_tuner_rf_tune(state, freq, bw);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tstate->frequency = freq;\n\tstate->bandwidth = c->bandwidth_hz;\nfail:\n\tmutex_unlock(&state->lock);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\treturn ret;\n}\n\n \n\nstatic int mxl5007t_init(struct dvb_frontend *fe)\n{\n\tstruct mxl5007t_state *state = fe->tuner_priv;\n\tint ret;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t \n\tret = mxl5007t_write_reg(state, 0x01, 0x01);\n\tmxl_fail(ret);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\treturn ret;\n}\n\nstatic int mxl5007t_sleep(struct dvb_frontend *fe)\n{\n\tstruct mxl5007t_state *state = fe->tuner_priv;\n\tint ret;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t \n\tret = mxl5007t_write_reg(state, 0x01, 0x00);\n\tmxl_fail(ret);\n\tret = mxl5007t_write_reg(state, 0x0f, 0x00);\n\tmxl_fail(ret);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\treturn ret;\n}\n\n \n\nstatic int mxl5007t_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct mxl5007t_state *state = fe->tuner_priv;\n\t*frequency = state->frequency;\n\treturn 0;\n}\n\nstatic int mxl5007t_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\n{\n\tstruct mxl5007t_state *state = fe->tuner_priv;\n\t*bandwidth = state->bandwidth;\n\treturn 0;\n}\n\nstatic int mxl5007t_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct mxl5007t_state *state = fe->tuner_priv;\n\n\t*frequency = 0;\n\n\tswitch (state->if_freq) {\n\tcase MxL_IF_4_MHZ:\n\t\t*frequency = 4000000;\n\t\tbreak;\n\tcase MxL_IF_4_5_MHZ:\n\t\t*frequency = 4500000;\n\t\tbreak;\n\tcase MxL_IF_4_57_MHZ:\n\t\t*frequency = 4570000;\n\t\tbreak;\n\tcase MxL_IF_5_MHZ:\n\t\t*frequency = 5000000;\n\t\tbreak;\n\tcase MxL_IF_5_38_MHZ:\n\t\t*frequency = 5380000;\n\t\tbreak;\n\tcase MxL_IF_6_MHZ:\n\t\t*frequency = 6000000;\n\t\tbreak;\n\tcase MxL_IF_6_28_MHZ:\n\t\t*frequency = 6280000;\n\t\tbreak;\n\tcase MxL_IF_9_1915_MHZ:\n\t\t*frequency = 9191500;\n\t\tbreak;\n\tcase MxL_IF_35_25_MHZ:\n\t\t*frequency = 35250000;\n\t\tbreak;\n\tcase MxL_IF_36_15_MHZ:\n\t\t*frequency = 36150000;\n\t\tbreak;\n\tcase MxL_IF_44_MHZ:\n\t\t*frequency = 44000000;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void mxl5007t_release(struct dvb_frontend *fe)\n{\n\tstruct mxl5007t_state *state = fe->tuner_priv;\n\n\tmutex_lock(&mxl5007t_list_mutex);\n\n\tif (state)\n\t\thybrid_tuner_release_state(state);\n\n\tmutex_unlock(&mxl5007t_list_mutex);\n\n\tfe->tuner_priv = NULL;\n}\n\n \n\nstatic const struct dvb_tuner_ops mxl5007t_tuner_ops = {\n\t.info = {\n\t\t.name = \"MaxLinear MxL5007T\",\n\t},\n\t.init              = mxl5007t_init,\n\t.sleep             = mxl5007t_sleep,\n\t.set_params        = mxl5007t_set_params,\n\t.get_status        = mxl5007t_get_status,\n\t.get_frequency     = mxl5007t_get_frequency,\n\t.get_bandwidth     = mxl5007t_get_bandwidth,\n\t.release           = mxl5007t_release,\n\t.get_if_frequency  = mxl5007t_get_if_frequency,\n};\n\nstatic int mxl5007t_get_chip_id(struct mxl5007t_state *state)\n{\n\tchar *name;\n\tint ret;\n\tu8 id;\n\n\tret = mxl5007t_read_reg(state, 0xd9, &id);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tswitch (id) {\n\tcase MxL_5007_V1_F1:\n\t\tname = \"MxL5007.v1.f1\";\n\t\tbreak;\n\tcase MxL_5007_V1_F2:\n\t\tname = \"MxL5007.v1.f2\";\n\t\tbreak;\n\tcase MxL_5007_V2_100_F1:\n\t\tname = \"MxL5007.v2.100.f1\";\n\t\tbreak;\n\tcase MxL_5007_V2_100_F2:\n\t\tname = \"MxL5007.v2.100.f2\";\n\t\tbreak;\n\tcase MxL_5007_V2_200_F1:\n\t\tname = \"MxL5007.v2.200.f1\";\n\t\tbreak;\n\tcase MxL_5007_V2_200_F2:\n\t\tname = \"MxL5007.v2.200.f2\";\n\t\tbreak;\n\tcase MxL_5007_V4:\n\t\tname = \"MxL5007T.v4\";\n\t\tbreak;\n\tdefault:\n\t\tname = \"MxL5007T\";\n\t\tprintk(KERN_WARNING \"%s: unknown rev (%02x)\\n\", __func__, id);\n\t\tid = MxL_UNKNOWN_ID;\n\t}\n\tstate->chip_id = id;\n\tmxl_info(\"%s detected @ %d-%04x\", name,\n\t\t i2c_adapter_id(state->i2c_props.adap),\n\t\t state->i2c_props.addr);\n\treturn 0;\nfail:\n\tmxl_warn(\"unable to identify device @ %d-%04x\",\n\t\t i2c_adapter_id(state->i2c_props.adap),\n\t\t state->i2c_props.addr);\n\n\tstate->chip_id = MxL_UNKNOWN_ID;\n\treturn ret;\n}\n\nstruct dvb_frontend *mxl5007t_attach(struct dvb_frontend *fe,\n\t\t\t\t     struct i2c_adapter *i2c, u8 addr,\n\t\t\t\t     struct mxl5007t_config *cfg)\n{\n\tstruct mxl5007t_state *state = NULL;\n\tint instance, ret;\n\n\tmutex_lock(&mxl5007t_list_mutex);\n\tinstance = hybrid_tuner_request_state(struct mxl5007t_state, state,\n\t\t\t\t\t      hybrid_tuner_instance_list,\n\t\t\t\t\t      i2c, addr, \"mxl5007t\");\n\tswitch (instance) {\n\tcase 0:\n\t\tgoto fail;\n\tcase 1:\n\t\t \n\t\tstate->config = cfg;\n\n\t\tmutex_init(&state->lock);\n\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t\tret = mxl5007t_get_chip_id(state);\n\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\t\t \n\t\tif (mxl_fail(ret))\n\t\t\tgoto fail;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tret = mxl5007t_soft_reset(state);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tret = mxl5007t_write_reg(state, 0x04,\n\t\tstate->config->loop_thru_enable);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tfe->tuner_priv = state;\n\n\tmutex_unlock(&mxl5007t_list_mutex);\n\n\tmemcpy(&fe->ops.tuner_ops, &mxl5007t_tuner_ops,\n\t       sizeof(struct dvb_tuner_ops));\n\n\treturn fe;\nfail:\n\tmutex_unlock(&mxl5007t_list_mutex);\n\n\tmxl5007t_release(fe);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(mxl5007t_attach);\nMODULE_DESCRIPTION(\"MaxLinear MxL5007T Silicon IC tuner driver\");\nMODULE_AUTHOR(\"Michael Krufky <mkrufky@linuxtv.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}