{
  "module_name": "qm1d1b0004.c",
  "hash_id": "537a0393d9e977b1dcbfc7d7c6844bb8375f024042099f03f8aaea81abb37558",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/qm1d1b0004.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <media/dvb_frontend.h>\n#include \"qm1d1b0004.h\"\n\n \n\n#define QM1D1B0004_PSC_MASK (1 << 4)\n\n#define QM1D1B0004_XTL_FREQ 4000\n#define QM1D1B0004_LPF_FALLBACK 30000\n\n#if 0  \nstatic const struct qm1d1b0004_config default_cfg = {\n\t.lpf_freq = QM1D1B0004_CFG_LPF_DFLT,\n\t.half_step = false,\n};\n#endif\n\nstruct qm1d1b0004_state {\n\tstruct qm1d1b0004_config cfg;\n\tstruct i2c_client *i2c;\n};\n\n\nstruct qm1d1b0004_cb_map {\n\tu32 frequency;\n\tu8 cb;\n};\n\nstatic const struct qm1d1b0004_cb_map cb_maps[] = {\n\t{  986000, 0xb2 },\n\t{ 1072000, 0xd2 },\n\t{ 1154000, 0xe2 },\n\t{ 1291000, 0x20 },\n\t{ 1447000, 0x40 },\n\t{ 1615000, 0x60 },\n\t{ 1791000, 0x80 },\n\t{ 1972000, 0xa0 },\n};\n\nstatic u8 lookup_cb(u32 frequency)\n{\n\tint i;\n\tconst struct qm1d1b0004_cb_map *map;\n\n\tfor (i = 0; i < ARRAY_SIZE(cb_maps); i++) {\n\t\tmap = &cb_maps[i];\n\t\tif (frequency < map->frequency)\n\t\t\treturn map->cb;\n\t}\n\treturn 0xc0;\n}\n\nstatic int qm1d1b0004_set_params(struct dvb_frontend *fe)\n{\n\tstruct qm1d1b0004_state *state;\n\tu32 frequency, pll, lpf_freq;\n\tu16 word;\n\tu8 buf[4], cb, lpf;\n\tint ret;\n\n\tstate = fe->tuner_priv;\n\tfrequency = fe->dtv_property_cache.frequency;\n\n\tpll = QM1D1B0004_XTL_FREQ / 4;\n\tif (state->cfg.half_step)\n\t\tpll /= 2;\n\tword = DIV_ROUND_CLOSEST(frequency, pll);\n\tcb = lookup_cb(frequency);\n\tif (cb & QM1D1B0004_PSC_MASK)\n\t\tword = (word << 1 & ~0x1f) | (word & 0x0f);\n\n\t \n\tbuf[0] = 0x40 | word >> 8;\n\tbuf[1] = word;\n\t \n\tbuf[2] = 0xe0 | state->cfg.half_step;\n\tbuf[3] = cb;\n\tret = i2c_master_send(state->i2c, buf, 4);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tbuf[0] = 0xe4 | state->cfg.half_step;\n\tret = i2c_master_send(state->i2c, buf, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\tmsleep(20);\n\n\t \n\tlpf_freq = state->cfg.lpf_freq;\n\tif (lpf_freq == QM1D1B0004_CFG_LPF_DFLT)\n\t\tlpf_freq = fe->dtv_property_cache.symbol_rate / 1000;\n\tif (lpf_freq == 0)\n\t\tlpf_freq = QM1D1B0004_LPF_FALLBACK;\n\tlpf = DIV_ROUND_UP(lpf_freq, 2000) - 2;\n\tbuf[0] = 0xe4 | ((lpf & 0x0c) << 1) | state->cfg.half_step;\n\tbuf[1] = cb | ((lpf & 0x03) << 2);\n\tret = i2c_master_send(state->i2c, buf, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tbuf[0] = 0;\n\tret = i2c_master_recv(state->i2c, buf, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\n\nstatic int qm1d1b0004_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct qm1d1b0004_state *state;\n\n\tstate = fe->tuner_priv;\n\tmemcpy(&state->cfg, priv_cfg, sizeof(state->cfg));\n\treturn 0;\n}\n\n\nstatic int qm1d1b0004_init(struct dvb_frontend *fe)\n{\n\tstruct qm1d1b0004_state *state;\n\tu8 buf[2] = {0xf8, 0x04};\n\n\tstate = fe->tuner_priv;\n\tif (state->cfg.half_step)\n\t\tbuf[0] |= 0x01;\n\n\treturn i2c_master_send(state->i2c, buf, 2);\n}\n\n\nstatic const struct dvb_tuner_ops qm1d1b0004_ops = {\n\t.info = {\n\t\t.name = \"Sharp qm1d1b0004\",\n\n\t\t.frequency_min_hz =  950 * MHz,\n\t\t.frequency_max_hz = 2150 * MHz,\n\t},\n\n\t.init = qm1d1b0004_init,\n\n\t.set_params = qm1d1b0004_set_params,\n\t.set_config = qm1d1b0004_set_config,\n};\n\nstatic int\nqm1d1b0004_probe(struct i2c_client *client)\n{\n\tstruct dvb_frontend *fe;\n\tstruct qm1d1b0004_config *cfg;\n\tstruct qm1d1b0004_state *state;\n\tint ret;\n\n\tcfg = client->dev.platform_data;\n\tfe = cfg->fe;\n\ti2c_set_clientdata(client, fe);\n\n\tfe->tuner_priv = kzalloc(sizeof(struct qm1d1b0004_state), GFP_KERNEL);\n\tif (!fe->tuner_priv) {\n\t\tret = -ENOMEM;\n\t\tgoto err_mem;\n\t}\n\n\tmemcpy(&fe->ops.tuner_ops, &qm1d1b0004_ops, sizeof(fe->ops.tuner_ops));\n\n\tstate = fe->tuner_priv;\n\tstate->i2c = client;\n\tret = qm1d1b0004_set_config(fe, cfg);\n\tif (ret != 0)\n\t\tgoto err_priv;\n\n\tdev_info(&client->dev, \"Sharp QM1D1B0004 attached.\\n\");\n\treturn 0;\n\nerr_priv:\n\tkfree(fe->tuner_priv);\nerr_mem:\n\tfe->tuner_priv = NULL;\n\treturn ret;\n}\n\nstatic void qm1d1b0004_remove(struct i2c_client *client)\n{\n\tstruct dvb_frontend *fe;\n\n\tfe = i2c_get_clientdata(client);\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\n\nstatic const struct i2c_device_id qm1d1b0004_id[] = {\n\t{\"qm1d1b0004\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, qm1d1b0004_id);\n\nstatic struct i2c_driver qm1d1b0004_driver = {\n\t.driver = {\n\t\t.name = \"qm1d1b0004\",\n\t},\n\t.probe    = qm1d1b0004_probe,\n\t.remove   = qm1d1b0004_remove,\n\t.id_table = qm1d1b0004_id,\n};\n\nmodule_i2c_driver(qm1d1b0004_driver);\n\nMODULE_DESCRIPTION(\"Sharp QM1D1B0004\");\nMODULE_AUTHOR(\"Akihiro Tsukada\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}