{
  "module_name": "e4000.c",
  "hash_id": "3c602e7783959bc0d4a2606bf459c7555817b6ce4cbbe3dfa5c28f891e418bff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/e4000.c",
  "human_readable_source": "\n \n\n#include \"e4000_priv.h\"\n\nstatic int e4000_init(struct e4000_dev *dev)\n{\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tret = regmap_write(dev->regmap, 0x00, 0x01);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_write(dev->regmap, 0x06, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x7a, 0x96);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_bulk_write(dev->regmap, 0x7e, \"\\x01\\xfe\", 2);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x82, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x24, 0x05);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_bulk_write(dev->regmap, 0x87, \"\\x20\\x01\", 2);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_bulk_write(dev->regmap, 0x9f, \"\\x7f\\x07\", 2);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_write(dev->regmap, 0x2d, 0x1f);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_bulk_write(dev->regmap, 0x70, \"\\x01\\x01\", 2);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_write(dev->regmap, 0x1a, 0x17);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x1f, 0x1a);\n\tif (ret)\n\t\tgoto err;\n\n\tdev->active = true;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int e4000_sleep(struct e4000_dev *dev)\n{\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tdev->active = false;\n\n\tret = regmap_write(dev->regmap, 0x00, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int e4000_set_params(struct e4000_dev *dev)\n{\n\tstruct i2c_client *client = dev->client;\n\tint ret, i;\n\tunsigned int div_n, k, k_cw, div_out;\n\tu64 f_vco;\n\tu8 buf[5], i_data[4], q_data[4];\n\n\tif (!dev->active) {\n\t\tdev_dbg(&client->dev, \"tuner is sleeping\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tret = regmap_write(dev->regmap, 0x1a, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(e4000_pll_lut); i++) {\n\t\tif (dev->f_frequency <= e4000_pll_lut[i].freq)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(e4000_pll_lut)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t#define F_REF dev->clk\n\tdiv_out = e4000_pll_lut[i].div_out;\n\tf_vco = (u64) dev->f_frequency * div_out;\n\t \n\tdiv_n = div_u64_rem(f_vco, F_REF, &k);\n\tk_cw = div_u64((u64) k * 0x10000, F_REF);\n\n\tdev_dbg(&client->dev,\n\t\t\"frequency=%u bandwidth=%u f_vco=%llu F_REF=%u div_n=%u k=%u k_cw=%04x div_out=%u\\n\",\n\t\tdev->f_frequency, dev->f_bandwidth, f_vco, F_REF, div_n, k,\n\t\tk_cw, div_out);\n\n\tbuf[0] = div_n;\n\tbuf[1] = (k_cw >> 0) & 0xff;\n\tbuf[2] = (k_cw >> 8) & 0xff;\n\tbuf[3] = 0x00;\n\tbuf[4] = e4000_pll_lut[i].div_out_reg;\n\tret = regmap_bulk_write(dev->regmap, 0x09, buf, 5);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(e400_lna_filter_lut); i++) {\n\t\tif (dev->f_frequency <= e400_lna_filter_lut[i].freq)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(e400_lna_filter_lut)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = regmap_write(dev->regmap, 0x10, e400_lna_filter_lut[i].val);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(e4000_if_filter_lut); i++) {\n\t\tif (dev->f_bandwidth <= e4000_if_filter_lut[i].freq)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(e4000_if_filter_lut)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tbuf[0] = e4000_if_filter_lut[i].reg11_val;\n\tbuf[1] = e4000_if_filter_lut[i].reg12_val;\n\n\tret = regmap_bulk_write(dev->regmap, 0x11, buf, 2);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(e4000_band_lut); i++) {\n\t\tif (dev->f_frequency <= e4000_band_lut[i].freq)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(e4000_band_lut)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = regmap_write(dev->regmap, 0x07, e4000_band_lut[i].reg07_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x78, e4000_band_lut[i].reg78_val);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tif (i == 0)\n\t\t\tret = regmap_bulk_write(dev->regmap, 0x15, \"\\x00\\x7e\\x24\", 3);\n\t\telse if (i == 1)\n\t\t\tret = regmap_bulk_write(dev->regmap, 0x15, \"\\x00\\x7f\", 2);\n\t\telse if (i == 2)\n\t\t\tret = regmap_bulk_write(dev->regmap, 0x15, \"\\x01\", 1);\n\t\telse\n\t\t\tret = regmap_bulk_write(dev->regmap, 0x16, \"\\x7e\", 1);\n\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = regmap_write(dev->regmap, 0x29, 0x01);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = regmap_bulk_read(dev->regmap, 0x2a, buf, 3);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\ti_data[i] = (((buf[2] >> 0) & 0x3) << 6) | (buf[0] & 0x3f);\n\t\tq_data[i] = (((buf[2] >> 4) & 0x3) << 6) | (buf[1] & 0x3f);\n\t}\n\n\tswap(q_data[2], q_data[3]);\n\tswap(i_data[2], i_data[3]);\n\n\tret = regmap_bulk_write(dev->regmap, 0x50, q_data, 4);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_bulk_write(dev->regmap, 0x60, i_data, 4);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_write(dev->regmap, 0x1a, 0x17);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\n \n#if IS_ENABLED(CONFIG_VIDEO_DEV)\nstatic const struct v4l2_frequency_band bands[] = {\n\t{\n\t\t.type = V4L2_TUNER_RF,\n\t\t.index = 0,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   =    59000000,\n\t\t.rangehigh  =  1105000000,\n\t},\n\t{\n\t\t.type = V4L2_TUNER_RF,\n\t\t.index = 1,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   =  1249000000,\n\t\t.rangehigh  =  2208000000UL,\n\t},\n};\n\nstatic inline struct e4000_dev *e4000_subdev_to_dev(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct e4000_dev, sd);\n}\n\nstatic int e4000_standby(struct v4l2_subdev *sd)\n{\n\tstruct e4000_dev *dev = e4000_subdev_to_dev(sd);\n\tint ret;\n\n\tret = e4000_sleep(dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn e4000_set_params(dev);\n}\n\nstatic int e4000_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *v)\n{\n\tstruct e4000_dev *dev = e4000_subdev_to_dev(sd);\n\tstruct i2c_client *client = dev->client;\n\n\tdev_dbg(&client->dev, \"index=%d\\n\", v->index);\n\n\tstrscpy(v->name, \"Elonics E4000\", sizeof(v->name));\n\tv->type = V4L2_TUNER_RF;\n\tv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\n\tv->rangelow  = bands[0].rangelow;\n\tv->rangehigh = bands[1].rangehigh;\n\treturn 0;\n}\n\nstatic int e4000_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *v)\n{\n\tstruct e4000_dev *dev = e4000_subdev_to_dev(sd);\n\tstruct i2c_client *client = dev->client;\n\n\tdev_dbg(&client->dev, \"index=%d\\n\", v->index);\n\treturn 0;\n}\n\nstatic int e4000_g_frequency(struct v4l2_subdev *sd, struct v4l2_frequency *f)\n{\n\tstruct e4000_dev *dev = e4000_subdev_to_dev(sd);\n\tstruct i2c_client *client = dev->client;\n\n\tdev_dbg(&client->dev, \"tuner=%d\\n\", f->tuner);\n\tf->frequency = dev->f_frequency;\n\treturn 0;\n}\n\nstatic int e4000_s_frequency(struct v4l2_subdev *sd,\n\t\t\t      const struct v4l2_frequency *f)\n{\n\tstruct e4000_dev *dev = e4000_subdev_to_dev(sd);\n\tstruct i2c_client *client = dev->client;\n\n\tdev_dbg(&client->dev, \"tuner=%d type=%d frequency=%u\\n\",\n\t\tf->tuner, f->type, f->frequency);\n\n\tdev->f_frequency = clamp_t(unsigned int, f->frequency,\n\t\t\t\t   bands[0].rangelow, bands[1].rangehigh);\n\treturn e4000_set_params(dev);\n}\n\nstatic int e4000_enum_freq_bands(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_frequency_band *band)\n{\n\tstruct e4000_dev *dev = e4000_subdev_to_dev(sd);\n\tstruct i2c_client *client = dev->client;\n\n\tdev_dbg(&client->dev, \"tuner=%d type=%d index=%d\\n\",\n\t\tband->tuner, band->type, band->index);\n\n\tif (band->index >= ARRAY_SIZE(bands))\n\t\treturn -EINVAL;\n\n\tband->capability = bands[band->index].capability;\n\tband->rangelow = bands[band->index].rangelow;\n\tband->rangehigh = bands[band->index].rangehigh;\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_tuner_ops e4000_subdev_tuner_ops = {\n\t.standby                  = e4000_standby,\n\t.g_tuner                  = e4000_g_tuner,\n\t.s_tuner                  = e4000_s_tuner,\n\t.g_frequency              = e4000_g_frequency,\n\t.s_frequency              = e4000_s_frequency,\n\t.enum_freq_bands          = e4000_enum_freq_bands,\n};\n\nstatic const struct v4l2_subdev_ops e4000_subdev_ops = {\n\t.tuner                    = &e4000_subdev_tuner_ops,\n};\n\nstatic int e4000_set_lna_gain(struct dvb_frontend *fe)\n{\n\tstruct e4000_dev *dev = fe->tuner_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tu8 u8tmp;\n\n\tdev_dbg(&client->dev, \"lna auto=%d->%d val=%d->%d\\n\",\n\t\tdev->lna_gain_auto->cur.val, dev->lna_gain_auto->val,\n\t\tdev->lna_gain->cur.val, dev->lna_gain->val);\n\n\tif (dev->lna_gain_auto->val && dev->if_gain_auto->cur.val)\n\t\tu8tmp = 0x17;\n\telse if (dev->lna_gain_auto->val)\n\t\tu8tmp = 0x19;\n\telse if (dev->if_gain_auto->cur.val)\n\t\tu8tmp = 0x16;\n\telse\n\t\tu8tmp = 0x10;\n\n\tret = regmap_write(dev->regmap, 0x1a, u8tmp);\n\tif (ret)\n\t\tgoto err;\n\n\tif (dev->lna_gain_auto->val == false) {\n\t\tret = regmap_write(dev->regmap, 0x14, dev->lna_gain->val);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int e4000_set_mixer_gain(struct dvb_frontend *fe)\n{\n\tstruct e4000_dev *dev = fe->tuner_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tu8 u8tmp;\n\n\tdev_dbg(&client->dev, \"mixer auto=%d->%d val=%d->%d\\n\",\n\t\tdev->mixer_gain_auto->cur.val, dev->mixer_gain_auto->val,\n\t\tdev->mixer_gain->cur.val, dev->mixer_gain->val);\n\n\tif (dev->mixer_gain_auto->val)\n\t\tu8tmp = 0x15;\n\telse\n\t\tu8tmp = 0x14;\n\n\tret = regmap_write(dev->regmap, 0x20, u8tmp);\n\tif (ret)\n\t\tgoto err;\n\n\tif (dev->mixer_gain_auto->val == false) {\n\t\tret = regmap_write(dev->regmap, 0x15, dev->mixer_gain->val);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int e4000_set_if_gain(struct dvb_frontend *fe)\n{\n\tstruct e4000_dev *dev = fe->tuner_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tu8 buf[2];\n\tu8 u8tmp;\n\n\tdev_dbg(&client->dev, \"if auto=%d->%d val=%d->%d\\n\",\n\t\tdev->if_gain_auto->cur.val, dev->if_gain_auto->val,\n\t\tdev->if_gain->cur.val, dev->if_gain->val);\n\n\tif (dev->if_gain_auto->val && dev->lna_gain_auto->cur.val)\n\t\tu8tmp = 0x17;\n\telse if (dev->lna_gain_auto->cur.val)\n\t\tu8tmp = 0x19;\n\telse if (dev->if_gain_auto->val)\n\t\tu8tmp = 0x16;\n\telse\n\t\tu8tmp = 0x10;\n\n\tret = regmap_write(dev->regmap, 0x1a, u8tmp);\n\tif (ret)\n\t\tgoto err;\n\n\tif (dev->if_gain_auto->val == false) {\n\t\tbuf[0] = e4000_if_gain_lut[dev->if_gain->val].reg16_val;\n\t\tbuf[1] = e4000_if_gain_lut[dev->if_gain->val].reg17_val;\n\t\tret = regmap_bulk_write(dev->regmap, 0x16, buf, 2);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int e4000_pll_lock(struct dvb_frontend *fe)\n{\n\tstruct e4000_dev *dev = fe->tuner_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tunsigned int uitmp;\n\n\tret = regmap_read(dev->regmap, 0x07, &uitmp);\n\tif (ret)\n\t\tgoto err;\n\n\tdev->pll_lock->val = (uitmp & 0x01);\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int e4000_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct e4000_dev *dev = container_of(ctrl->handler, struct e4000_dev, hdl);\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\n\tif (!dev->active)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase  V4L2_CID_RF_TUNER_PLL_LOCK:\n\t\tret = e4000_pll_lock(dev->fe);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"unknown ctrl: id=%d name=%s\\n\",\n\t\t\tctrl->id, ctrl->name);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int e4000_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct e4000_dev *dev = container_of(ctrl->handler, struct e4000_dev, hdl);\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\n\tif (!dev->active)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_RF_TUNER_BANDWIDTH_AUTO:\n\tcase V4L2_CID_RF_TUNER_BANDWIDTH:\n\t\t \n\t\tdev->f_bandwidth = dev->bandwidth->val;\n\t\tret = e4000_set_params(dev);\n\t\tbreak;\n\tcase  V4L2_CID_RF_TUNER_LNA_GAIN_AUTO:\n\tcase  V4L2_CID_RF_TUNER_LNA_GAIN:\n\t\tret = e4000_set_lna_gain(dev->fe);\n\t\tbreak;\n\tcase  V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO:\n\tcase  V4L2_CID_RF_TUNER_MIXER_GAIN:\n\t\tret = e4000_set_mixer_gain(dev->fe);\n\t\tbreak;\n\tcase  V4L2_CID_RF_TUNER_IF_GAIN_AUTO:\n\tcase  V4L2_CID_RF_TUNER_IF_GAIN:\n\t\tret = e4000_set_if_gain(dev->fe);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"unknown ctrl: id=%d name=%s\\n\",\n\t\t\tctrl->id, ctrl->name);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops e4000_ctrl_ops = {\n\t.g_volatile_ctrl = e4000_g_volatile_ctrl,\n\t.s_ctrl = e4000_s_ctrl,\n};\n#endif\n\n \nstatic int e4000_dvb_set_params(struct dvb_frontend *fe)\n{\n\tstruct e4000_dev *dev = fe->tuner_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tdev->f_frequency = c->frequency;\n\tdev->f_bandwidth = c->bandwidth_hz;\n\treturn e4000_set_params(dev);\n}\n\nstatic int e4000_dvb_init(struct dvb_frontend *fe)\n{\n\treturn e4000_init(fe->tuner_priv);\n}\n\nstatic int e4000_dvb_sleep(struct dvb_frontend *fe)\n{\n\treturn e4000_sleep(fe->tuner_priv);\n}\n\nstatic int e4000_dvb_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\t*frequency = 0;  \n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops e4000_dvb_tuner_ops = {\n\t.info = {\n\t\t.name              = \"Elonics E4000\",\n\t\t.frequency_min_hz  = 174 * MHz,\n\t\t.frequency_max_hz  = 862 * MHz,\n\t},\n\n\t.init = e4000_dvb_init,\n\t.sleep = e4000_dvb_sleep,\n\t.set_params = e4000_dvb_set_params,\n\n\t.get_if_frequency = e4000_dvb_get_if_frequency,\n};\n\nstatic int e4000_probe(struct i2c_client *client)\n{\n\tstruct e4000_dev *dev;\n\tstruct e4000_config *cfg = client->dev.platform_data;\n\tstruct dvb_frontend *fe = cfg->fe;\n\tint ret;\n\tunsigned int uitmp;\n\tstatic const struct regmap_config regmap_config = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t};\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tdev->clk = cfg->clock;\n\tdev->client = client;\n\tdev->fe = cfg->fe;\n\tdev->regmap = devm_regmap_init_i2c(client, &regmap_config);\n\tif (IS_ERR(dev->regmap)) {\n\t\tret = PTR_ERR(dev->regmap);\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tret = regmap_read(dev->regmap, 0x02, &uitmp);\n\tif (ret)\n\t\tgoto err_kfree;\n\n\tdev_dbg(&client->dev, \"chip id=%02x\\n\", uitmp);\n\n\tif (uitmp != 0x40) {\n\t\tret = -ENODEV;\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tret = regmap_write(dev->regmap, 0x00, 0x00);\n\tif (ret)\n\t\tgoto err_kfree;\n\n#if IS_ENABLED(CONFIG_VIDEO_DEV)\n\t \n\tv4l2_ctrl_handler_init(&dev->hdl, 9);\n\tdev->bandwidth_auto = v4l2_ctrl_new_std(&dev->hdl, &e4000_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_BANDWIDTH_AUTO, 0, 1, 1, 1);\n\tdev->bandwidth = v4l2_ctrl_new_std(&dev->hdl, &e4000_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_BANDWIDTH, 4300000, 11000000, 100000, 4300000);\n\tv4l2_ctrl_auto_cluster(2, &dev->bandwidth_auto, 0, false);\n\tdev->lna_gain_auto = v4l2_ctrl_new_std(&dev->hdl, &e4000_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_LNA_GAIN_AUTO, 0, 1, 1, 1);\n\tdev->lna_gain = v4l2_ctrl_new_std(&dev->hdl, &e4000_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_LNA_GAIN, 0, 15, 1, 10);\n\tv4l2_ctrl_auto_cluster(2, &dev->lna_gain_auto, 0, false);\n\tdev->mixer_gain_auto = v4l2_ctrl_new_std(&dev->hdl, &e4000_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_MIXER_GAIN_AUTO, 0, 1, 1, 1);\n\tdev->mixer_gain = v4l2_ctrl_new_std(&dev->hdl, &e4000_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_MIXER_GAIN, 0, 1, 1, 1);\n\tv4l2_ctrl_auto_cluster(2, &dev->mixer_gain_auto, 0, false);\n\tdev->if_gain_auto = v4l2_ctrl_new_std(&dev->hdl, &e4000_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_IF_GAIN_AUTO, 0, 1, 1, 1);\n\tdev->if_gain = v4l2_ctrl_new_std(&dev->hdl, &e4000_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_IF_GAIN, 0, 54, 1, 0);\n\tv4l2_ctrl_auto_cluster(2, &dev->if_gain_auto, 0, false);\n\tdev->pll_lock = v4l2_ctrl_new_std(&dev->hdl, &e4000_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_PLL_LOCK,  0, 1, 1, 0);\n\tif (dev->hdl.error) {\n\t\tret = dev->hdl.error;\n\t\tdev_err(&client->dev, \"Could not initialize controls\\n\");\n\t\tv4l2_ctrl_handler_free(&dev->hdl);\n\t\tgoto err_kfree;\n\t}\n\n\tdev->sd.ctrl_handler = &dev->hdl;\n\tdev->f_frequency = bands[0].rangelow;\n\tdev->f_bandwidth = dev->bandwidth->val;\n\tv4l2_i2c_subdev_init(&dev->sd, client, &e4000_subdev_ops);\n#endif\n\tfe->tuner_priv = dev;\n\tmemcpy(&fe->ops.tuner_ops, &e4000_dvb_tuner_ops,\n\t       sizeof(fe->ops.tuner_ops));\n\tv4l2_set_subdevdata(&dev->sd, client);\n\ti2c_set_clientdata(client, &dev->sd);\n\n\tdev_info(&client->dev, \"Elonics E4000 successfully identified\\n\");\n\treturn 0;\nerr_kfree:\n\tkfree(dev);\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void e4000_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tstruct e4000_dev *dev = container_of(sd, struct e4000_dev, sd);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n#if IS_ENABLED(CONFIG_VIDEO_DEV)\n\tv4l2_ctrl_handler_free(&dev->hdl);\n#endif\n\tkfree(dev);\n}\n\nstatic const struct i2c_device_id e4000_id_table[] = {\n\t{\"e4000\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, e4000_id_table);\n\nstatic struct i2c_driver e4000_driver = {\n\t.driver = {\n\t\t.name\t= \"e4000\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= e4000_probe,\n\t.remove\t\t= e4000_remove,\n\t.id_table\t= e4000_id_table,\n};\n\nmodule_i2c_driver(e4000_driver);\n\nMODULE_DESCRIPTION(\"Elonics E4000 silicon tuner driver\");\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}