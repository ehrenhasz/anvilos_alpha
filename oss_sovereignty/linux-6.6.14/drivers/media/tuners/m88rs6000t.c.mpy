{
  "module_name": "m88rs6000t.c",
  "hash_id": "2ec289641df2f0833495aea05206a0e55defe779e13879b53cce11479541b6cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/m88rs6000t.c",
  "human_readable_source": "\n \n\n#include \"m88rs6000t.h\"\n#include <linux/regmap.h>\n\nstruct m88rs6000t_dev {\n\tstruct m88rs6000t_config cfg;\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tu32 frequency_khz;\n};\n\nstruct m88rs6000t_reg_val {\n\tu8 reg;\n\tu8 val;\n};\n\n \nstatic int m88rs6000t_set_demod_mclk(struct dvb_frontend *fe)\n{\n\tstruct m88rs6000t_dev *dev = fe->tuner_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu8 reg11, reg15, reg16, reg1D, reg1E, reg1F;\n\tu8 N, f0 = 0, f1 = 0, f2 = 0, f3 = 0;\n\tu16 pll_div_fb;\n\tu32 div, ts_mclk;\n\tunsigned int utmp;\n\tint ret;\n\n\t \n\tret = regmap_read(dev->regmap, 0x15, &utmp);\n\tif (ret)\n\t\tgoto err;\n\treg15 = utmp;\n\tif (c->symbol_rate > 45010000) {\n\t\treg11 = 0x0E;\n\t\treg15 |= 0x02;\n\t\treg16 = 115;  \n\t} else {\n\t\treg11 = 0x0A;\n\t\treg15 &= ~0x02;\n\t\treg16 = 96;  \n\t}\n\n\t \n\tif (c->delivery_system == SYS_DVBS)\n\t\tts_mclk = 96000;\n\telse\n\t\tts_mclk = 144000;\n\n\tpll_div_fb = (reg15 & 0x01) << 8;\n\tpll_div_fb += reg16;\n\tpll_div_fb += 32;\n\n\tdiv = 36000 * pll_div_fb;\n\tdiv /= ts_mclk;\n\n\tif (div <= 32) {\n\t\tN = 2;\n\t\tf0 = 0;\n\t\tf1 = div / 2;\n\t\tf2 = div - f1;\n\t\tf3 = 0;\n\t} else if (div <= 48) {\n\t\tN = 3;\n\t\tf0 = div / 3;\n\t\tf1 = (div - f0) / 2;\n\t\tf2 = div - f0 - f1;\n\t\tf3 = 0;\n\t} else if (div <= 64) {\n\t\tN = 4;\n\t\tf0 = div / 4;\n\t\tf1 = (div - f0) / 3;\n\t\tf2 = (div - f0 - f1) / 2;\n\t\tf3 = div - f0 - f1 - f2;\n\t} else {\n\t\tN = 4;\n\t\tf0 = 16;\n\t\tf1 = 16;\n\t\tf2 = 16;\n\t\tf3 = 16;\n\t}\n\n\tif (f0 == 16)\n\t\tf0 = 0;\n\tif (f1 == 16)\n\t\tf1 = 0;\n\tif (f2 == 16)\n\t\tf2 = 0;\n\tif (f3 == 16)\n\t\tf3 = 0;\n\n\tret = regmap_read(dev->regmap, 0x1D, &utmp);\n\tif (ret)\n\t\tgoto err;\n\treg1D = utmp;\n\treg1D &= ~0x03;\n\treg1D |= N - 1;\n\treg1E = ((f3 << 4) + f2) & 0xFF;\n\treg1F = ((f1 << 4) + f0) & 0xFF;\n\n\t \n\tret = regmap_write(dev->regmap, 0x05, 0x40);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x11, 0x08);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x15, reg15);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x16, reg16);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x1D, reg1D);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x1E, reg1E);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x1F, reg1F);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x17, 0xc1);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x17, 0x81);\n\tif (ret)\n\t\tgoto err;\n\tusleep_range(5000, 50000);\n\tret = regmap_write(dev->regmap, 0x05, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x11, reg11);\n\tif (ret)\n\t\tgoto err;\n\tusleep_range(5000, 50000);\nerr:\n\tif (ret)\n\t\tdev_dbg(&dev->client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int m88rs6000t_set_pll_freq(struct m88rs6000t_dev *dev,\n\t\t\tu32 tuner_freq_MHz)\n{\n\tu32 fcry_KHz, ulNDiv1, ulNDiv2, ulNDiv;\n\tu8 refDiv, ucLoDiv1, ucLomod1, ucLoDiv2, ucLomod2, ucLoDiv, ucLomod;\n\tu8 reg27, reg29, reg42, reg42buf;\n\tunsigned int utmp;\n\tint ret;\n\n\tfcry_KHz = 27000;  \n\trefDiv = 27;\n\n\tret = regmap_write(dev->regmap, 0x36, (refDiv - 8));\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x31, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x2c, 0x02);\n\tif (ret)\n\t\tgoto err;\n\n\tif (tuner_freq_MHz >= 1550) {\n\t\tucLoDiv1 = 2;\n\t\tucLomod1 = 0;\n\t\tucLoDiv2 = 2;\n\t\tucLomod2 = 0;\n\t} else if (tuner_freq_MHz >= 1380) {\n\t\tucLoDiv1 = 3;\n\t\tucLomod1 = 16;\n\t\tucLoDiv2 = 2;\n\t\tucLomod2 = 0;\n\t} else if (tuner_freq_MHz >= 1070) {\n\t\tucLoDiv1 = 3;\n\t\tucLomod1 = 16;\n\t\tucLoDiv2 = 3;\n\t\tucLomod2 = 16;\n\t} else if (tuner_freq_MHz >= 1000) {\n\t\tucLoDiv1 = 3;\n\t\tucLomod1 = 16;\n\t\tucLoDiv2 = 4;\n\t\tucLomod2 = 64;\n\t} else if (tuner_freq_MHz >= 775) {\n\t\tucLoDiv1 = 4;\n\t\tucLomod1 = 64;\n\t\tucLoDiv2 = 4;\n\t\tucLomod2 = 64;\n\t} else if (tuner_freq_MHz >= 700) {\n\t\tucLoDiv1 = 6;\n\t\tucLomod1 = 48;\n\t\tucLoDiv2 = 4;\n\t\tucLomod2 = 64;\n\t} else if (tuner_freq_MHz >= 520) {\n\t\tucLoDiv1 = 6;\n\t\tucLomod1 = 48;\n\t\tucLoDiv2 = 6;\n\t\tucLomod2 = 48;\n\t} else {\n\t\tucLoDiv1 = 8;\n\t\tucLomod1 = 96;\n\t\tucLoDiv2 = 8;\n\t\tucLomod2 = 96;\n\t}\n\n\tulNDiv1 = ((tuner_freq_MHz * ucLoDiv1 * 1000) * refDiv\n\t\t\t/ fcry_KHz - 1024) / 2;\n\tulNDiv2 = ((tuner_freq_MHz * ucLoDiv2 * 1000) * refDiv\n\t\t\t/ fcry_KHz - 1024) / 2;\n\n\treg27 = (((ulNDiv1 >> 8) & 0x0F) + ucLomod1) & 0x7F;\n\tret = regmap_write(dev->regmap, 0x27, reg27);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x28, (u8)(ulNDiv1 & 0xFF));\n\tif (ret)\n\t\tgoto err;\n\treg29 = (((ulNDiv2 >> 8) & 0x0F) + ucLomod2) & 0x7f;\n\tret = regmap_write(dev->regmap, 0x29, reg29);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x2a, (u8)(ulNDiv2 & 0xFF));\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x2F, 0xf5);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x30, 0x05);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x08, 0x1f);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x08, 0x3f);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x09, 0x20);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x09, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x3e, 0x11);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x08, 0x2f);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x08, 0x3f);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x09, 0x10);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x09, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tusleep_range(2000, 50000);\n\n\tret = regmap_read(dev->regmap, 0x42, &utmp);\n\tif (ret)\n\t\tgoto err;\n\treg42 = utmp;\n\n\tret = regmap_write(dev->regmap, 0x3e, 0x10);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x08, 0x2f);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x08, 0x3f);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x09, 0x10);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x09, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tusleep_range(2000, 50000);\n\n\tret = regmap_read(dev->regmap, 0x42, &utmp);\n\tif (ret)\n\t\tgoto err;\n\treg42buf = utmp;\n\tif (reg42buf < reg42) {\n\t\tret = regmap_write(dev->regmap, 0x3e, 0x11);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\tusleep_range(5000, 50000);\n\n\tret = regmap_read(dev->regmap, 0x2d, &utmp);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x2d, utmp);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_read(dev->regmap, 0x2e, &utmp);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x2e, utmp);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_read(dev->regmap, 0x27, &utmp);\n\tif (ret)\n\t\tgoto err;\n\treg27 = utmp & 0x70;\n\tret = regmap_read(dev->regmap, 0x83, &utmp);\n\tif (ret)\n\t\tgoto err;\n\tif (reg27 == (utmp & 0x70)) {\n\t\tucLoDiv\t= ucLoDiv1;\n\t\tulNDiv = ulNDiv1;\n\t\tucLomod = ucLomod1 / 16;\n\t} else {\n\t\tucLoDiv\t= ucLoDiv2;\n\t\tulNDiv = ulNDiv2;\n\t\tucLomod = ucLomod2 / 16;\n\t}\n\n\tif ((ucLoDiv == 3) || (ucLoDiv == 6)) {\n\t\trefDiv = 18;\n\t\tret = regmap_write(dev->regmap, 0x36, (refDiv - 8));\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tulNDiv = ((tuner_freq_MHz * ucLoDiv * 1000) * refDiv\n\t\t\t\t/ fcry_KHz - 1024) / 2;\n\t}\n\n\treg27 = (0x80 + ((ucLomod << 4) & 0x70)\n\t\t\t+ ((ulNDiv >> 8) & 0x0F)) & 0xFF;\n\tret = regmap_write(dev->regmap, 0x27, reg27);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x28, (u8)(ulNDiv & 0xFF));\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x29, 0x80);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x31, 0x03);\n\tif (ret)\n\t\tgoto err;\n\n\tif (ucLoDiv == 3)\n\t\tutmp = 0xCE;\n\telse\n\t\tutmp = 0x8A;\n\tret = regmap_write(dev->regmap, 0x3b, utmp);\n\tif (ret)\n\t\tgoto err;\n\n\tdev->frequency_khz = fcry_KHz * (ulNDiv * 2 + 1024) / refDiv / ucLoDiv;\n\n\tdev_dbg(&dev->client->dev,\n\t\t\"actual tune frequency=%d\\n\", dev->frequency_khz);\nerr:\n\tif (ret)\n\t\tdev_dbg(&dev->client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int m88rs6000t_set_bb(struct m88rs6000t_dev *dev,\n\t\tu32 symbol_rate_KSs, s32 lpf_offset_KHz)\n{\n\tu32 f3dB;\n\tu8  reg40;\n\n\tf3dB = symbol_rate_KSs * 9 / 14 + 2000;\n\tf3dB += lpf_offset_KHz;\n\tf3dB = clamp_val(f3dB, 6000U, 43000U);\n\treg40 = f3dB / 1000;\n\treturn regmap_write(dev->regmap, 0x40, reg40);\n}\n\nstatic int m88rs6000t_set_params(struct dvb_frontend *fe)\n{\n\tstruct m88rs6000t_dev *dev = fe->tuner_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret;\n\ts32 lpf_offset_KHz;\n\tu32 realFreq, freq_MHz;\n\n\tdev_dbg(&dev->client->dev,\n\t\t\t\"frequency=%d symbol_rate=%d\\n\",\n\t\t\tc->frequency, c->symbol_rate);\n\n\tif (c->symbol_rate < 5000000)\n\t\tlpf_offset_KHz = 3000;\n\telse\n\t\tlpf_offset_KHz = 0;\n\n\trealFreq = c->frequency + lpf_offset_KHz;\n\t \n\tfreq_MHz = (realFreq + 500) / 1000;\n\tret = m88rs6000t_set_pll_freq(dev, freq_MHz);\n\tif (ret)\n\t\tgoto err;\n\tret = m88rs6000t_set_bb(dev, c->symbol_rate / 1000, lpf_offset_KHz);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x00, 0x01);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x00, 0x00);\n\tif (ret)\n\t\tgoto err;\n\t \n\tret = m88rs6000t_set_demod_mclk(fe);\nerr:\n\tif (ret)\n\t\tdev_dbg(&dev->client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int m88rs6000t_init(struct dvb_frontend *fe)\n{\n\tstruct m88rs6000t_dev *dev = fe->tuner_priv;\n\tint ret;\n\n\tdev_dbg(&dev->client->dev, \"%s:\\n\", __func__);\n\n\tret = regmap_update_bits(dev->regmap, 0x11, 0x08, 0x08);\n\tif (ret)\n\t\tgoto err;\n\tusleep_range(5000, 50000);\n\tret = regmap_update_bits(dev->regmap, 0x10, 0x01, 0x01);\n\tif (ret)\n\t\tgoto err;\n\tusleep_range(10000, 50000);\n\tret = regmap_write(dev->regmap, 0x07, 0x7d);\nerr:\n\tif (ret)\n\t\tdev_dbg(&dev->client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int m88rs6000t_sleep(struct dvb_frontend *fe)\n{\n\tstruct m88rs6000t_dev *dev = fe->tuner_priv;\n\tint ret;\n\n\tdev_dbg(&dev->client->dev, \"%s:\\n\", __func__);\n\n\tret = regmap_write(dev->regmap, 0x07, 0x6d);\n\tif (ret) {\n\t\tdev_dbg(&dev->client->dev, \"failed=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\tusleep_range(5000, 10000);\n\treturn 0;\n}\n\nstatic int m88rs6000t_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct m88rs6000t_dev *dev = fe->tuner_priv;\n\n\tdev_dbg(&dev->client->dev, \"\\n\");\n\n\t*frequency = dev->frequency_khz;\n\treturn 0;\n}\n\nstatic int m88rs6000t_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct m88rs6000t_dev *dev = fe->tuner_priv;\n\n\tdev_dbg(&dev->client->dev, \"\\n\");\n\n\t*frequency = 0;  \n\treturn 0;\n}\n\n\nstatic int m88rs6000t_get_rf_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct m88rs6000t_dev *dev = fe->tuner_priv;\n\tunsigned int val, i;\n\tint ret;\n\tu16 gain;\n\tu32 PGA2_cri_GS = 46, PGA2_crf_GS = 290, TIA_GS = 290;\n\tu32 RF_GC = 1200, IF_GC = 1100, BB_GC = 300;\n\tu32 PGA2_GC = 300, TIA_GC = 300, PGA2_cri = 0, PGA2_crf = 0;\n\tu32 RFG = 0, IFG = 0, BBG = 0, PGA2G = 0, TIAG = 0;\n\tu32 RFGS[13] = {0, 245, 266, 268, 270, 285,\n\t\t\t298, 295, 283, 285, 285, 300, 300};\n\tu32 IFGS[12] = {0, 300, 230, 270, 270, 285,\n\t\t\t295, 285, 290, 295, 295, 310};\n\tu32 BBGS[14] = {0, 286, 275, 290, 294, 300, 290,\n\t\t\t290, 285, 283, 260, 295, 290, 260};\n\n\tret = regmap_read(dev->regmap, 0x5A, &val);\n\tif (ret)\n\t\tgoto err;\n\tRF_GC = val & 0x0f;\n\n\tret = regmap_read(dev->regmap, 0x5F, &val);\n\tif (ret)\n\t\tgoto err;\n\tIF_GC = val & 0x0f;\n\n\tret = regmap_read(dev->regmap, 0x3F, &val);\n\tif (ret)\n\t\tgoto err;\n\tTIA_GC = (val >> 4) & 0x07;\n\n\tret = regmap_read(dev->regmap, 0x77, &val);\n\tif (ret)\n\t\tgoto err;\n\tBB_GC = (val >> 4) & 0x0f;\n\n\tret = regmap_read(dev->regmap, 0x76, &val);\n\tif (ret)\n\t\tgoto err;\n\tPGA2_GC = val & 0x3f;\n\tPGA2_cri = PGA2_GC >> 2;\n\tPGA2_crf = PGA2_GC & 0x03;\n\n\tfor (i = 0; i <= RF_GC && i < ARRAY_SIZE(RFGS); i++)\n\t\tRFG += RFGS[i];\n\n\tif (RF_GC == 0)\n\t\tRFG += 400;\n\tif (RF_GC == 1)\n\t\tRFG += 300;\n\tif (RF_GC == 2)\n\t\tRFG += 200;\n\tif (RF_GC == 3)\n\t\tRFG += 100;\n\n\tfor (i = 0; i <= IF_GC && i < ARRAY_SIZE(IFGS); i++)\n\t\tIFG += IFGS[i];\n\n\tTIAG = TIA_GC * TIA_GS;\n\n\tfor (i = 0; i <= BB_GC && i < ARRAY_SIZE(BBGS); i++)\n\t\tBBG += BBGS[i];\n\n\tPGA2G = PGA2_cri * PGA2_cri_GS + PGA2_crf * PGA2_crf_GS;\n\n\tgain = RFG + IFG - TIAG + BBG + PGA2G;\n\n\t \n\tgain = clamp_val(gain, 1000U, 10500U);\n\t*strength = (10500 - gain) * 0xffff / (10500 - 1000);\nerr:\n\tif (ret)\n\t\tdev_dbg(&dev->client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct dvb_tuner_ops m88rs6000t_tuner_ops = {\n\t.info = {\n\t\t.name             = \"Montage M88RS6000 Internal Tuner\",\n\t\t.frequency_min_hz =  950 * MHz,\n\t\t.frequency_max_hz = 2150 * MHz,\n\t},\n\n\t.init = m88rs6000t_init,\n\t.sleep = m88rs6000t_sleep,\n\t.set_params = m88rs6000t_set_params,\n\t.get_frequency = m88rs6000t_get_frequency,\n\t.get_if_frequency = m88rs6000t_get_if_frequency,\n\t.get_rf_strength = m88rs6000t_get_rf_strength,\n};\n\nstatic int m88rs6000t_probe(struct i2c_client *client)\n{\n\tstruct m88rs6000t_config *cfg = client->dev.platform_data;\n\tstruct dvb_frontend *fe = cfg->fe;\n\tstruct m88rs6000t_dev *dev;\n\tint ret, i;\n\tunsigned int utmp;\n\tstatic const struct regmap_config regmap_config = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t};\n\tstatic const struct m88rs6000t_reg_val reg_vals[] = {\n\t\t{0x10, 0xfb},\n\t\t{0x24, 0x38},\n\t\t{0x11, 0x0a},\n\t\t{0x12, 0x00},\n\t\t{0x2b, 0x1c},\n\t\t{0x44, 0x48},\n\t\t{0x54, 0x24},\n\t\t{0x55, 0x06},\n\t\t{0x59, 0x00},\n\t\t{0x5b, 0x4c},\n\t\t{0x60, 0x8b},\n\t\t{0x61, 0xf4},\n\t\t{0x65, 0x07},\n\t\t{0x6d, 0x6f},\n\t\t{0x6e, 0x31},\n\t\t{0x3c, 0xf3},\n\t\t{0x37, 0x0f},\n\t\t{0x48, 0x28},\n\t\t{0x49, 0xd8},\n\t\t{0x70, 0x66},\n\t\t{0x71, 0xCF},\n\t\t{0x72, 0x81},\n\t\t{0x73, 0xA7},\n\t\t{0x74, 0x4F},\n\t\t{0x75, 0xFC},\n\t};\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tdev_err(&client->dev, \"kzalloc() failed\\n\");\n\t\tgoto err;\n\t}\n\n\tmemcpy(&dev->cfg, cfg, sizeof(struct m88rs6000t_config));\n\tdev->client = client;\n\tdev->regmap = devm_regmap_init_i2c(client, &regmap_config);\n\tif (IS_ERR(dev->regmap)) {\n\t\tret = PTR_ERR(dev->regmap);\n\t\tgoto err;\n\t}\n\n\tret = regmap_update_bits(dev->regmap, 0x11, 0x08, 0x08);\n\tif (ret)\n\t\tgoto err;\n\tusleep_range(5000, 50000);\n\tret = regmap_update_bits(dev->regmap, 0x10, 0x01, 0x01);\n\tif (ret)\n\t\tgoto err;\n\tusleep_range(10000, 50000);\n\tret = regmap_write(dev->regmap, 0x07, 0x7d);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x04, 0x01);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_read(dev->regmap, 0x01, &utmp);\n\tif (ret)\n\t\tgoto err;\n\tdev_info(&dev->client->dev, \"chip_id=%02x\\n\", utmp);\n\tif (utmp != 0x64) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t \n\tret = regmap_write(dev->regmap, 0x05, 0x40);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x11, 0x08);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x15, 0x6c);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x17, 0xc1);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x17, 0x81);\n\tif (ret)\n\t\tgoto err;\n\tusleep_range(10000, 50000);\n\tret = regmap_write(dev->regmap, 0x05, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x11, 0x0a);\n\tif (ret)\n\t\tgoto err;\n\n\tfor (i = 0; i < ARRAY_SIZE(reg_vals); i++) {\n\t\tret = regmap_write(dev->regmap,\n\t\t\t\treg_vals[i].reg, reg_vals[i].val);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tdev_info(&dev->client->dev, \"Montage M88RS6000 internal tuner successfully identified\\n\");\n\n\tfe->tuner_priv = dev;\n\tmemcpy(&fe->ops.tuner_ops, &m88rs6000t_tuner_ops,\n\t\t\tsizeof(struct dvb_tuner_ops));\n\ti2c_set_clientdata(client, dev);\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\tkfree(dev);\n\treturn ret;\n}\n\nstatic void m88rs6000t_remove(struct i2c_client *client)\n{\n\tstruct m88rs6000t_dev *dev = i2c_get_clientdata(client);\n\tstruct dvb_frontend *fe = dev->cfg.fe;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tmemset(&fe->ops.tuner_ops, 0, sizeof(struct dvb_tuner_ops));\n\tfe->tuner_priv = NULL;\n\tkfree(dev);\n}\n\nstatic const struct i2c_device_id m88rs6000t_id[] = {\n\t{\"m88rs6000t\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, m88rs6000t_id);\n\nstatic struct i2c_driver m88rs6000t_driver = {\n\t.driver = {\n\t\t.name\t= \"m88rs6000t\",\n\t},\n\t.probe\t\t= m88rs6000t_probe,\n\t.remove\t\t= m88rs6000t_remove,\n\t.id_table\t= m88rs6000t_id,\n};\n\nmodule_i2c_driver(m88rs6000t_driver);\n\nMODULE_AUTHOR(\"Max nibble <nibble.max@gmail.com>\");\nMODULE_DESCRIPTION(\"Montage M88RS6000 internal tuner driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}