{
  "module_name": "fc2580.c",
  "hash_id": "63fd69d09c79b58c28466524c27a8893fff1a1f67f0e61357624612304499d3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/fc2580.c",
  "human_readable_source": "\n \n\n#include \"fc2580_priv.h\"\n\n \n\n \nstatic int fc2580_wr_reg_ff(struct fc2580_dev *dev, u8 reg, u8 val)\n{\n\tif (val == 0xff)\n\t\treturn 0;\n\telse\n\t\treturn regmap_write(dev->regmap, reg, val);\n}\n\nstatic int fc2580_set_params(struct fc2580_dev *dev)\n{\n\tstruct i2c_client *client = dev->client;\n\tint ret, i;\n\tunsigned int uitmp, div_ref, div_ref_val, div_n, k, k_cw, div_out;\n\tu64 f_vco;\n\tu8 synth_config;\n\tunsigned long timeout;\n\n\tif (!dev->active) {\n\t\tdev_dbg(&client->dev, \"tuner is sleeping\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fc2580_pll_lut); i++) {\n\t\tif (dev->f_frequency <= fc2580_pll_lut[i].freq)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(fc2580_pll_lut)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t#define DIV_PRE_N 2\n\t#define F_REF dev->clk\n\tdiv_out = fc2580_pll_lut[i].div_out;\n\tf_vco = (u64) dev->f_frequency * div_out;\n\tsynth_config = fc2580_pll_lut[i].band;\n\tif (f_vco < 2600000000ULL)\n\t\tsynth_config |= 0x06;\n\telse\n\t\tsynth_config |= 0x0e;\n\n\t \n\t#define DIV_N_MIN 76\n\tif (f_vco >= div_u64((u64) DIV_PRE_N * DIV_N_MIN * F_REF, 1)) {\n\t\tdiv_ref = 1;\n\t\tdiv_ref_val = 0x00;\n\t} else if (f_vco >= div_u64((u64) DIV_PRE_N * DIV_N_MIN * F_REF, 2)) {\n\t\tdiv_ref = 2;\n\t\tdiv_ref_val = 0x10;\n\t} else {\n\t\tdiv_ref = 4;\n\t\tdiv_ref_val = 0x20;\n\t}\n\n\t \n\tuitmp = DIV_PRE_N * F_REF / div_ref;\n\tdiv_n = div_u64_rem(f_vco, uitmp, &k);\n\tk_cw = div_u64((u64) k * 0x100000, uitmp);\n\n\tdev_dbg(&client->dev,\n\t\t\"frequency=%u bandwidth=%u f_vco=%llu F_REF=%u div_ref=%u div_n=%u k=%u div_out=%u k_cw=%0x\\n\",\n\t\tdev->f_frequency, dev->f_bandwidth, f_vco, F_REF, div_ref,\n\t\tdiv_n, k, div_out, k_cw);\n\n\tret = regmap_write(dev->regmap, 0x02, synth_config);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x18, div_ref_val << 0 | k_cw >> 16);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x1a, (k_cw >> 8) & 0xff);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x1b, (k_cw >> 0) & 0xff);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x1c, div_n);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fc2580_freq_regs_lut); i++) {\n\t\tif (dev->f_frequency <= fc2580_freq_regs_lut[i].freq)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(fc2580_freq_regs_lut)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = fc2580_wr_reg_ff(dev, 0x25, fc2580_freq_regs_lut[i].r25_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x27, fc2580_freq_regs_lut[i].r27_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x28, fc2580_freq_regs_lut[i].r28_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x29, fc2580_freq_regs_lut[i].r29_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x2b, fc2580_freq_regs_lut[i].r2b_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x2c, fc2580_freq_regs_lut[i].r2c_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x2d, fc2580_freq_regs_lut[i].r2d_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x30, fc2580_freq_regs_lut[i].r30_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x44, fc2580_freq_regs_lut[i].r44_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x50, fc2580_freq_regs_lut[i].r50_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x53, fc2580_freq_regs_lut[i].r53_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x5f, fc2580_freq_regs_lut[i].r5f_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x61, fc2580_freq_regs_lut[i].r61_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x62, fc2580_freq_regs_lut[i].r62_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x63, fc2580_freq_regs_lut[i].r63_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x67, fc2580_freq_regs_lut[i].r67_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x68, fc2580_freq_regs_lut[i].r68_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x69, fc2580_freq_regs_lut[i].r69_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x6a, fc2580_freq_regs_lut[i].r6a_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x6b, fc2580_freq_regs_lut[i].r6b_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x6c, fc2580_freq_regs_lut[i].r6c_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x6d, fc2580_freq_regs_lut[i].r6d_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x6e, fc2580_freq_regs_lut[i].r6e_val);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc2580_wr_reg_ff(dev, 0x6f, fc2580_freq_regs_lut[i].r6f_val);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fc2580_if_filter_lut); i++) {\n\t\tif (dev->f_bandwidth <= fc2580_if_filter_lut[i].freq)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(fc2580_if_filter_lut)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = regmap_write(dev->regmap, 0x36, fc2580_if_filter_lut[i].r36_val);\n\tif (ret)\n\t\tgoto err;\n\n\tuitmp = (unsigned int) 8058000 - (dev->f_bandwidth * 122 / 100 / 2);\n\tuitmp = div64_u64((u64) dev->clk * uitmp, 1000000000000ULL);\n\tret = regmap_write(dev->regmap, 0x37, uitmp);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x39, fc2580_if_filter_lut[i].r39_val);\n\tif (ret)\n\t\tgoto err;\n\n\ttimeout = jiffies + msecs_to_jiffies(30);\n\tfor (uitmp = ~0xc0; !time_after(jiffies, timeout) && uitmp != 0xc0;) {\n\t\t \n\t\tret = regmap_write(dev->regmap, 0x2e, 0x09);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tret = regmap_read(dev->regmap, 0x2f, &uitmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tuitmp &= 0xc0;\n\n\t\tret = regmap_write(dev->regmap, 0x2e, 0x01);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\tif (uitmp != 0xc0)\n\t\tdev_dbg(&client->dev, \"filter did not lock %02x\\n\", uitmp);\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int fc2580_init(struct fc2580_dev *dev)\n{\n\tstruct i2c_client *client = dev->client;\n\tint ret, i;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(fc2580_init_reg_vals); i++) {\n\t\tret = regmap_write(dev->regmap, fc2580_init_reg_vals[i].reg,\n\t\t\t\tfc2580_init_reg_vals[i].val);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tdev->active = true;\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int fc2580_sleep(struct fc2580_dev *dev)\n{\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tdev->active = false;\n\n\tret = regmap_write(dev->regmap, 0x02, 0x0a);\n\tif (ret)\n\t\tgoto err;\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\n \nstatic int fc2580_dvb_set_params(struct dvb_frontend *fe)\n{\n\tstruct fc2580_dev *dev = fe->tuner_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tdev->f_frequency = c->frequency;\n\tdev->f_bandwidth = c->bandwidth_hz;\n\treturn fc2580_set_params(dev);\n}\n\nstatic int fc2580_dvb_init(struct dvb_frontend *fe)\n{\n\treturn fc2580_init(fe->tuner_priv);\n}\n\nstatic int fc2580_dvb_sleep(struct dvb_frontend *fe)\n{\n\treturn fc2580_sleep(fe->tuner_priv);\n}\n\nstatic int fc2580_dvb_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\t*frequency = 0;  \n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops fc2580_dvb_tuner_ops = {\n\t.info = {\n\t\t.name             = \"FCI FC2580\",\n\t\t.frequency_min_hz = 174 * MHz,\n\t\t.frequency_max_hz = 862 * MHz,\n\t},\n\n\t.init = fc2580_dvb_init,\n\t.sleep = fc2580_dvb_sleep,\n\t.set_params = fc2580_dvb_set_params,\n\n\t.get_if_frequency = fc2580_dvb_get_if_frequency,\n};\n\n \n#if IS_ENABLED(CONFIG_VIDEO_DEV)\nstatic const struct v4l2_frequency_band bands[] = {\n\t{\n\t\t.type = V4L2_TUNER_RF,\n\t\t.index = 0,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   =   130000000,\n\t\t.rangehigh  =  2000000000,\n\t},\n};\n\nstatic inline struct fc2580_dev *fc2580_subdev_to_dev(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct fc2580_dev, subdev);\n}\n\nstatic int fc2580_standby(struct v4l2_subdev *sd)\n{\n\tstruct fc2580_dev *dev = fc2580_subdev_to_dev(sd);\n\tint ret;\n\n\tret = fc2580_sleep(dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn fc2580_set_params(dev);\n}\n\nstatic int fc2580_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *v)\n{\n\tstruct fc2580_dev *dev = fc2580_subdev_to_dev(sd);\n\tstruct i2c_client *client = dev->client;\n\n\tdev_dbg(&client->dev, \"index=%d\\n\", v->index);\n\n\tstrscpy(v->name, \"FCI FC2580\", sizeof(v->name));\n\tv->type = V4L2_TUNER_RF;\n\tv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\n\tv->rangelow  = bands[0].rangelow;\n\tv->rangehigh = bands[0].rangehigh;\n\treturn 0;\n}\n\nstatic int fc2580_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *v)\n{\n\tstruct fc2580_dev *dev = fc2580_subdev_to_dev(sd);\n\tstruct i2c_client *client = dev->client;\n\n\tdev_dbg(&client->dev, \"index=%d\\n\", v->index);\n\treturn 0;\n}\n\nstatic int fc2580_g_frequency(struct v4l2_subdev *sd, struct v4l2_frequency *f)\n{\n\tstruct fc2580_dev *dev = fc2580_subdev_to_dev(sd);\n\tstruct i2c_client *client = dev->client;\n\n\tdev_dbg(&client->dev, \"tuner=%d\\n\", f->tuner);\n\tf->frequency = dev->f_frequency;\n\treturn 0;\n}\n\nstatic int fc2580_s_frequency(struct v4l2_subdev *sd,\n\t\t\t      const struct v4l2_frequency *f)\n{\n\tstruct fc2580_dev *dev = fc2580_subdev_to_dev(sd);\n\tstruct i2c_client *client = dev->client;\n\n\tdev_dbg(&client->dev, \"tuner=%d type=%d frequency=%u\\n\",\n\t\tf->tuner, f->type, f->frequency);\n\n\tdev->f_frequency = clamp_t(unsigned int, f->frequency,\n\t\t\t\t   bands[0].rangelow, bands[0].rangehigh);\n\treturn fc2580_set_params(dev);\n}\n\nstatic int fc2580_enum_freq_bands(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_frequency_band *band)\n{\n\tstruct fc2580_dev *dev = fc2580_subdev_to_dev(sd);\n\tstruct i2c_client *client = dev->client;\n\n\tdev_dbg(&client->dev, \"tuner=%d type=%d index=%d\\n\",\n\t\tband->tuner, band->type, band->index);\n\n\tif (band->index >= ARRAY_SIZE(bands))\n\t\treturn -EINVAL;\n\n\tband->capability = bands[band->index].capability;\n\tband->rangelow = bands[band->index].rangelow;\n\tband->rangehigh = bands[band->index].rangehigh;\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_tuner_ops fc2580_subdev_tuner_ops = {\n\t.standby                  = fc2580_standby,\n\t.g_tuner                  = fc2580_g_tuner,\n\t.s_tuner                  = fc2580_s_tuner,\n\t.g_frequency              = fc2580_g_frequency,\n\t.s_frequency              = fc2580_s_frequency,\n\t.enum_freq_bands          = fc2580_enum_freq_bands,\n};\n\nstatic const struct v4l2_subdev_ops fc2580_subdev_ops = {\n\t.tuner                    = &fc2580_subdev_tuner_ops,\n};\n\nstatic int fc2580_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct fc2580_dev *dev = container_of(ctrl->handler, struct fc2580_dev, hdl);\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"ctrl: id=%d name=%s cur.val=%d val=%d\\n\",\n\t\tctrl->id, ctrl->name, ctrl->cur.val, ctrl->val);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_RF_TUNER_BANDWIDTH_AUTO:\n\tcase V4L2_CID_RF_TUNER_BANDWIDTH:\n\t\t \n\t\tdev->f_bandwidth = dev->bandwidth->val;\n\t\tret = fc2580_set_params(dev);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"unknown ctrl\");\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops fc2580_ctrl_ops = {\n\t.s_ctrl = fc2580_s_ctrl,\n};\n#endif\n\nstatic struct v4l2_subdev *fc2580_get_v4l2_subdev(struct i2c_client *client)\n{\n\tstruct fc2580_dev *dev = i2c_get_clientdata(client);\n\n\tif (dev->subdev.ops)\n\t\treturn &dev->subdev;\n\telse\n\t\treturn NULL;\n}\n\nstatic int fc2580_probe(struct i2c_client *client)\n{\n\tstruct fc2580_dev *dev;\n\tstruct fc2580_platform_data *pdata = client->dev.platform_data;\n\tstruct dvb_frontend *fe = pdata->dvb_frontend;\n\tint ret;\n\tunsigned int uitmp;\n\tstatic const struct regmap_config regmap_config = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t};\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tif (pdata->clk)\n\t\tdev->clk = pdata->clk;\n\telse\n\t\tdev->clk = 16384000;  \n\tdev->client = client;\n\tdev->regmap = devm_regmap_init_i2c(client, &regmap_config);\n\tif (IS_ERR(dev->regmap)) {\n\t\tret = PTR_ERR(dev->regmap);\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tret = regmap_read(dev->regmap, 0x01, &uitmp);\n\tif (ret)\n\t\tgoto err_kfree;\n\n\tdev_dbg(&client->dev, \"chip_id=%02x\\n\", uitmp);\n\n\tswitch (uitmp) {\n\tcase 0x56:\n\tcase 0x5a:\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODEV;\n\t\tgoto err_kfree;\n\t}\n\n#if IS_ENABLED(CONFIG_VIDEO_DEV)\n\t \n\tv4l2_ctrl_handler_init(&dev->hdl, 2);\n\tdev->bandwidth_auto = v4l2_ctrl_new_std(&dev->hdl, &fc2580_ctrl_ops,\n\t\t\t\t\t\tV4L2_CID_RF_TUNER_BANDWIDTH_AUTO,\n\t\t\t\t\t\t0, 1, 1, 1);\n\tdev->bandwidth = v4l2_ctrl_new_std(&dev->hdl, &fc2580_ctrl_ops,\n\t\t\t\t\t   V4L2_CID_RF_TUNER_BANDWIDTH,\n\t\t\t\t\t   3000, 10000000, 1, 3000);\n\tv4l2_ctrl_auto_cluster(2, &dev->bandwidth_auto, 0, false);\n\tif (dev->hdl.error) {\n\t\tret = dev->hdl.error;\n\t\tdev_err(&client->dev, \"Could not initialize controls\\n\");\n\t\tv4l2_ctrl_handler_free(&dev->hdl);\n\t\tgoto err_kfree;\n\t}\n\tdev->subdev.ctrl_handler = &dev->hdl;\n\tdev->f_frequency = bands[0].rangelow;\n\tdev->f_bandwidth = dev->bandwidth->val;\n\tv4l2_i2c_subdev_init(&dev->subdev, client, &fc2580_subdev_ops);\n#endif\n\tfe->tuner_priv = dev;\n\tmemcpy(&fe->ops.tuner_ops, &fc2580_dvb_tuner_ops,\n\t       sizeof(fe->ops.tuner_ops));\n\tpdata->get_v4l2_subdev = fc2580_get_v4l2_subdev;\n\ti2c_set_clientdata(client, dev);\n\n\tdev_info(&client->dev, \"FCI FC2580 successfully identified\\n\");\n\treturn 0;\nerr_kfree:\n\tkfree(dev);\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void fc2580_remove(struct i2c_client *client)\n{\n\tstruct fc2580_dev *dev = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n#if IS_ENABLED(CONFIG_VIDEO_DEV)\n\tv4l2_ctrl_handler_free(&dev->hdl);\n#endif\n\tkfree(dev);\n}\n\nstatic const struct i2c_device_id fc2580_id_table[] = {\n\t{\"fc2580\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, fc2580_id_table);\n\nstatic struct i2c_driver fc2580_driver = {\n\t.driver = {\n\t\t.name\t= \"fc2580\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= fc2580_probe,\n\t.remove\t\t= fc2580_remove,\n\t.id_table\t= fc2580_id_table,\n};\n\nmodule_i2c_driver(fc2580_driver);\n\nMODULE_DESCRIPTION(\"FCI FC2580 silicon tuner driver\");\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}