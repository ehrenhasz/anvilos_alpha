{
  "module_name": "mc44s803.c",
  "hash_id": "f44c0063e8a629e7296b45b3155d414474a0564617ddb3199550d2b45e1c0cff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/mc44s803.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/dvb/frontend.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n\n#include \"mc44s803.h\"\n#include \"mc44s803_priv.h\"\n\n#define mc_printk(level, format, arg...)\t\\\n\tprintk(level \"mc44s803: \" format , ## arg)\n\n \nstatic int mc44s803_writereg(struct mc44s803_priv *priv, u32 val)\n{\n\tu8 buf[3];\n\tstruct i2c_msg msg = {\n\t\t.addr = priv->cfg->i2c_address, .flags = 0, .buf = buf, .len = 3\n\t};\n\n\tbuf[0] = (val & 0xff0000) >> 16;\n\tbuf[1] = (val & 0xff00) >> 8;\n\tbuf[2] = (val & 0xff);\n\n\tif (i2c_transfer(priv->i2c, &msg, 1) != 1) {\n\t\tmc_printk(KERN_WARNING, \"I2C write failed\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\n \nstatic int mc44s803_readreg(struct mc44s803_priv *priv, u8 reg, u32 *val)\n{\n\tu32 wval;\n\tu8 buf[3];\n\tint ret;\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = priv->cfg->i2c_address, .flags = I2C_M_RD,\n\t\t  .buf = buf, .len = 3 },\n\t};\n\n\twval = MC44S803_REG_SM(MC44S803_REG_DATAREG, MC44S803_ADDR) |\n\t       MC44S803_REG_SM(reg, MC44S803_D);\n\n\tret = mc44s803_writereg(priv, wval);\n\tif (ret)\n\t\treturn ret;\n\n\tif (i2c_transfer(priv->i2c, msg, 1) != 1) {\n\t\tmc_printk(KERN_WARNING, \"I2C read failed\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\t*val = (buf[0] << 16) | (buf[1] << 8) | buf[2];\n\n\treturn 0;\n}\n\nstatic void mc44s803_release(struct dvb_frontend *fe)\n{\n\tstruct mc44s803_priv *priv = fe->tuner_priv;\n\n\tfe->tuner_priv = NULL;\n\tkfree(priv);\n}\n\nstatic int mc44s803_init(struct dvb_frontend *fe)\n{\n\tstruct mc44s803_priv *priv = fe->tuner_priv;\n\tu32 val;\n\tint err;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n \n\tval = MC44S803_REG_SM(MC44S803_REG_RESET, MC44S803_ADDR) |\n\t      MC44S803_REG_SM(1, MC44S803_RS);\n\n\terr = mc44s803_writereg(priv, val);\n\tif (err)\n\t\tgoto exit;\n\n\tval = MC44S803_REG_SM(MC44S803_REG_RESET, MC44S803_ADDR);\n\n\terr = mc44s803_writereg(priv, val);\n\tif (err)\n\t\tgoto exit;\n\n \n\n\tval = MC44S803_REG_SM(MC44S803_REG_REFOSC, MC44S803_ADDR) |\n\t      MC44S803_REG_SM(0xC0, MC44S803_REFOSC) |\n\t      MC44S803_REG_SM(1, MC44S803_OSCSEL);\n\n\terr = mc44s803_writereg(priv, val);\n\tif (err)\n\t\tgoto exit;\n\n\tval = MC44S803_REG_SM(MC44S803_REG_POWER, MC44S803_ADDR) |\n\t      MC44S803_REG_SM(0x200, MC44S803_POWER);\n\n\terr = mc44s803_writereg(priv, val);\n\tif (err)\n\t\tgoto exit;\n\n\tmsleep(10);\n\n\tval = MC44S803_REG_SM(MC44S803_REG_REFOSC, MC44S803_ADDR) |\n\t      MC44S803_REG_SM(0x40, MC44S803_REFOSC) |\n\t      MC44S803_REG_SM(1, MC44S803_OSCSEL);\n\n\terr = mc44s803_writereg(priv, val);\n\tif (err)\n\t\tgoto exit;\n\n\tmsleep(20);\n\n \n\n\tval = MC44S803_REG_SM(MC44S803_REG_MIXER, MC44S803_ADDR) |\n\t      MC44S803_REG_SM(1, MC44S803_TRI_STATE) |\n\t      MC44S803_REG_SM(0x7F, MC44S803_MIXER_RES);\n\n\terr = mc44s803_writereg(priv, val);\n\tif (err)\n\t\tgoto exit;\n\n \n\n\tval = MC44S803_REG_SM(MC44S803_REG_CIRCADJ, MC44S803_ADDR) |\n\t      MC44S803_REG_SM(1, MC44S803_G1) |\n\t      MC44S803_REG_SM(1, MC44S803_G3) |\n\t      MC44S803_REG_SM(0x3, MC44S803_CIRCADJ_RES) |\n\t      MC44S803_REG_SM(1, MC44S803_G6) |\n\t      MC44S803_REG_SM(priv->cfg->dig_out, MC44S803_S1) |\n\t      MC44S803_REG_SM(0x3, MC44S803_LP) |\n\t      MC44S803_REG_SM(1, MC44S803_CLRF) |\n\t      MC44S803_REG_SM(1, MC44S803_CLIF);\n\n\terr = mc44s803_writereg(priv, val);\n\tif (err)\n\t\tgoto exit;\n\n\tval = MC44S803_REG_SM(MC44S803_REG_CIRCADJ, MC44S803_ADDR) |\n\t      MC44S803_REG_SM(1, MC44S803_G1) |\n\t      MC44S803_REG_SM(1, MC44S803_G3) |\n\t      MC44S803_REG_SM(0x3, MC44S803_CIRCADJ_RES) |\n\t      MC44S803_REG_SM(1, MC44S803_G6) |\n\t      MC44S803_REG_SM(priv->cfg->dig_out, MC44S803_S1) |\n\t      MC44S803_REG_SM(0x3, MC44S803_LP);\n\n\terr = mc44s803_writereg(priv, val);\n\tif (err)\n\t\tgoto exit;\n\n \n\n\tval = MC44S803_REG_SM(MC44S803_REG_DIGTUNE, MC44S803_ADDR) |\n\t      MC44S803_REG_SM(3, MC44S803_XOD);\n\n\terr = mc44s803_writereg(priv, val);\n\tif (err)\n\t\tgoto exit;\n\n \n\n\tval = MC44S803_REG_SM(MC44S803_REG_LNAAGC, MC44S803_ADDR) |\n\t      MC44S803_REG_SM(1, MC44S803_AT1) |\n\t      MC44S803_REG_SM(1, MC44S803_AT2) |\n\t      MC44S803_REG_SM(1, MC44S803_AGC_AN_DIG) |\n\t      MC44S803_REG_SM(1, MC44S803_AGC_READ_EN) |\n\t      MC44S803_REG_SM(1, MC44S803_LNA0);\n\n\terr = mc44s803_writereg(priv, val);\n\tif (err)\n\t\tgoto exit;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\treturn 0;\n\nexit:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tmc_printk(KERN_WARNING, \"I/O Error\\n\");\n\treturn err;\n}\n\nstatic int mc44s803_set_params(struct dvb_frontend *fe)\n{\n\tstruct mc44s803_priv *priv = fe->tuner_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 r1, r2, n1, n2, lo1, lo2, freq, val;\n\tint err;\n\n\tpriv->frequency = c->frequency;\n\n\tr1 = MC44S803_OSC / 1000000;\n\tr2 = MC44S803_OSC /  100000;\n\n\tn1 = (c->frequency + MC44S803_IF1 + 500000) / 1000000;\n\tfreq = MC44S803_OSC / r1 * n1;\n\tlo1 = ((60 * n1) + (r1 / 2)) / r1;\n\tfreq = freq - c->frequency;\n\n\tn2 = (freq - MC44S803_IF2 + 50000) / 100000;\n\tlo2 = ((60 * n2) + (r2 / 2)) / r2;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tval = MC44S803_REG_SM(MC44S803_REG_REFDIV, MC44S803_ADDR) |\n\t      MC44S803_REG_SM(r1-1, MC44S803_R1) |\n\t      MC44S803_REG_SM(r2-1, MC44S803_R2) |\n\t      MC44S803_REG_SM(1, MC44S803_REFBUF_EN);\n\n\terr = mc44s803_writereg(priv, val);\n\tif (err)\n\t\tgoto exit;\n\n\tval = MC44S803_REG_SM(MC44S803_REG_LO1, MC44S803_ADDR) |\n\t      MC44S803_REG_SM(n1-2, MC44S803_LO1);\n\n\terr = mc44s803_writereg(priv, val);\n\tif (err)\n\t\tgoto exit;\n\n\tval = MC44S803_REG_SM(MC44S803_REG_LO2, MC44S803_ADDR) |\n\t      MC44S803_REG_SM(n2-2, MC44S803_LO2);\n\n\terr = mc44s803_writereg(priv, val);\n\tif (err)\n\t\tgoto exit;\n\n\tval = MC44S803_REG_SM(MC44S803_REG_DIGTUNE, MC44S803_ADDR) |\n\t      MC44S803_REG_SM(1, MC44S803_DA) |\n\t      MC44S803_REG_SM(lo1, MC44S803_LO_REF) |\n\t      MC44S803_REG_SM(1, MC44S803_AT);\n\n\terr = mc44s803_writereg(priv, val);\n\tif (err)\n\t\tgoto exit;\n\n\tval = MC44S803_REG_SM(MC44S803_REG_DIGTUNE, MC44S803_ADDR) |\n\t      MC44S803_REG_SM(2, MC44S803_DA) |\n\t      MC44S803_REG_SM(lo2, MC44S803_LO_REF) |\n\t      MC44S803_REG_SM(1, MC44S803_AT);\n\n\terr = mc44s803_writereg(priv, val);\n\tif (err)\n\t\tgoto exit;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\treturn 0;\n\nexit:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tmc_printk(KERN_WARNING, \"I/O Error\\n\");\n\treturn err;\n}\n\nstatic int mc44s803_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct mc44s803_priv *priv = fe->tuner_priv;\n\t*frequency = priv->frequency;\n\treturn 0;\n}\n\nstatic int mc44s803_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\t*frequency = MC44S803_IF2;  \n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops mc44s803_tuner_ops = {\n\t.info = {\n\t\t.name              = \"Freescale MC44S803\",\n\t\t.frequency_min_hz  =   48 * MHz,\n\t\t.frequency_max_hz  = 1000 * MHz,\n\t\t.frequency_step_hz =  100 * kHz,\n\t},\n\n\t.release       = mc44s803_release,\n\t.init          = mc44s803_init,\n\t.set_params    = mc44s803_set_params,\n\t.get_frequency = mc44s803_get_frequency,\n\t.get_if_frequency = mc44s803_get_if_frequency,\n};\n\n \nstruct dvb_frontend *mc44s803_attach(struct dvb_frontend *fe,\n\t struct i2c_adapter *i2c, struct mc44s803_config *cfg)\n{\n\tstruct mc44s803_priv *priv;\n\tu32 reg;\n\tu8 id;\n\tint ret;\n\n\treg = 0;\n\n\tpriv = kzalloc(sizeof(struct mc44s803_priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn NULL;\n\n\tpriv->cfg = cfg;\n\tpriv->i2c = i2c;\n\tpriv->fe  = fe;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\tret = mc44s803_readreg(priv, MC44S803_REG_ID, &reg);\n\tif (ret)\n\t\tgoto error;\n\n\tid = MC44S803_REG_MS(reg, MC44S803_ID);\n\n\tif (id != 0x14) {\n\t\tmc_printk(KERN_ERR, \"unsupported ID (%x should be 0x14)\\n\",\n\t\t\t  id);\n\t\tgoto error;\n\t}\n\n\tmc_printk(KERN_INFO, \"successfully identified (ID = %x)\\n\", id);\n\tmemcpy(&fe->ops.tuner_ops, &mc44s803_tuner_ops,\n\t       sizeof(struct dvb_tuner_ops));\n\n\tfe->tuner_priv = priv;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\treturn fe;\n\nerror:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\tkfree(priv);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(mc44s803_attach);\n\nMODULE_AUTHOR(\"Jochen Friedrich\");\nMODULE_DESCRIPTION(\"Freescale MC44S803 silicon tuner driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}