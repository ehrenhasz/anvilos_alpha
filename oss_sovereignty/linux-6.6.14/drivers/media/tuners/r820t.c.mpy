{
  "module_name": "r820t.c",
  "hash_id": "2bd75a80382adf638dc96258b5d7895328a6e448b3070e5b58052cea211c028a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/r820t.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/videodev2.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/bitrev.h>\n\n#include \"tuner-i2c.h\"\n#include \"r820t.h\"\n\n \n#define REG_SHADOW_START\t5\n#define NUM_REGS\t\t27\n#define NUM_IMR\t\t\t5\n#define IMR_TRIAL\t\t9\n\n#define VER_NUM  49\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable verbose debug messages\");\n\nstatic int no_imr_cal;\nmodule_param(no_imr_cal, int, 0444);\nMODULE_PARM_DESC(no_imr_cal, \"Disable IMR calibration at module init\");\n\n\n \n\nenum xtal_cap_value {\n\tXTAL_LOW_CAP_30P = 0,\n\tXTAL_LOW_CAP_20P,\n\tXTAL_LOW_CAP_10P,\n\tXTAL_LOW_CAP_0P,\n\tXTAL_HIGH_CAP_0P\n};\n\nstruct r820t_sect_type {\n\tu8\tphase_y;\n\tu8\tgain_x;\n\tu16\tvalue;\n};\n\nstruct r820t_priv {\n\tstruct list_head\t\thybrid_tuner_instance_list;\n\tconst struct r820t_config\t*cfg;\n\tstruct tuner_i2c_props\t\ti2c_props;\n\tstruct mutex\t\t\tlock;\n\n\tu8\t\t\t\tregs[NUM_REGS];\n\tu8\t\t\t\tbuf[NUM_REGS + 1];\n\tenum xtal_cap_value\t\txtal_cap_sel;\n\tu16\t\t\t\tpll;\t \n\tu32\t\t\t\tint_freq;\n\tu8\t\t\t\tfil_cal_code;\n\tbool\t\t\t\timr_done;\n\tbool\t\t\t\thas_lock;\n\tbool\t\t\t\tinit_done;\n\tstruct r820t_sect_type\t\timr_data[NUM_IMR];\n\n\t \n\tu32\t\t\t\tdelsys;\n\tenum v4l2_tuner_type\t\ttype;\n\tv4l2_std_id\t\t\tstd;\n\tu32\t\t\t\tbw;\t \n};\n\nstruct r820t_freq_range {\n\tu32\tfreq;\n\tu8\topen_d;\n\tu8\trf_mux_ploy;\n\tu8\ttf_c;\n\tu8\txtal_cap20p;\n\tu8\txtal_cap10p;\n\tu8\txtal_cap0p;\n\tu8\timr_mem;\t\t \n};\n\n#define VCO_POWER_REF   0x02\n#define DIP_FREQ\t32000000\n\n \n\nstatic LIST_HEAD(hybrid_tuner_instance_list);\nstatic DEFINE_MUTEX(r820t_list_mutex);\n\n \nstatic const u8 r820t_init_array[NUM_REGS] = {\n\t0x83, 0x32, 0x75,\t\t\t \n\t0xc0, 0x40, 0xd6, 0x6c,\t\t\t \n\t0xf5, 0x63, 0x75, 0x68,\t\t\t \n\t0x6c, 0x83, 0x80, 0x00,\t\t\t \n\t0x0f, 0x00, 0xc0, 0x30,\t\t\t \n\t0x48, 0xcc, 0x60, 0x00,\t\t\t \n\t0x54, 0xae, 0x4a, 0xc0\t\t\t \n};\n\n \nstatic const struct r820t_freq_range freq_ranges[] = {\n\t{\n\t\t.freq = 0,\n\t\t.open_d = 0x08,\t\t \n\t\t.rf_mux_ploy = 0x02,\t \n\t\t.tf_c = 0xdf,\t\t \n\t\t.xtal_cap20p = 0x02,\t \n\t\t.xtal_cap10p = 0x01,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 0,\n\t}, {\n\t\t.freq = 50,\t\t \n\t\t.open_d = 0x08,\t\t \n\t\t.rf_mux_ploy = 0x02,\t \n\t\t.tf_c = 0xbe,\t\t \n\t\t.xtal_cap20p = 0x02,\t \n\t\t.xtal_cap10p = 0x01,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 0,\n\t}, {\n\t\t.freq = 55,\t\t \n\t\t.open_d = 0x08,\t\t \n\t\t.rf_mux_ploy = 0x02,\t \n\t\t.tf_c = 0x8b,\t\t \n\t\t.xtal_cap20p = 0x02,\t \n\t\t.xtal_cap10p = 0x01,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 0,\n\t}, {\n\t\t.freq = 60,\t\t \n\t\t.open_d = 0x08,\t\t \n\t\t.rf_mux_ploy = 0x02,\t \n\t\t.tf_c = 0x7b,\t\t \n\t\t.xtal_cap20p = 0x02,\t \n\t\t.xtal_cap10p = 0x01,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 0,\n\t}, {\n\t\t.freq = 65,\t\t \n\t\t.open_d = 0x08,\t\t \n\t\t.rf_mux_ploy = 0x02,\t \n\t\t.tf_c = 0x69,\t\t \n\t\t.xtal_cap20p = 0x02,\t \n\t\t.xtal_cap10p = 0x01,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 0,\n\t}, {\n\t\t.freq = 70,\t\t \n\t\t.open_d = 0x08,\t\t \n\t\t.rf_mux_ploy = 0x02,\t \n\t\t.tf_c = 0x58,\t\t \n\t\t.xtal_cap20p = 0x02,\t \n\t\t.xtal_cap10p = 0x01,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 0,\n\t}, {\n\t\t.freq = 75,\t\t \n\t\t.open_d = 0x00,\t\t \n\t\t.rf_mux_ploy = 0x02,\t \n\t\t.tf_c = 0x44,\t\t \n\t\t.xtal_cap20p = 0x02,\t \n\t\t.xtal_cap10p = 0x01,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 0,\n\t}, {\n\t\t.freq = 80,\t\t \n\t\t.open_d = 0x00,\t\t \n\t\t.rf_mux_ploy = 0x02,\t \n\t\t.tf_c = 0x44,\t\t \n\t\t.xtal_cap20p = 0x02,\t \n\t\t.xtal_cap10p = 0x01,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 0,\n\t}, {\n\t\t.freq = 90,\t\t \n\t\t.open_d = 0x00,\t\t \n\t\t.rf_mux_ploy = 0x02,\t \n\t\t.tf_c = 0x34,\t\t \n\t\t.xtal_cap20p = 0x01,\t \n\t\t.xtal_cap10p = 0x01,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 0,\n\t}, {\n\t\t.freq = 100,\t\t \n\t\t.open_d = 0x00,\t\t \n\t\t.rf_mux_ploy = 0x02,\t \n\t\t.tf_c = 0x34,\t\t \n\t\t.xtal_cap20p = 0x01,\t \n\t\t.xtal_cap10p = 0x01,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 0,\n\t}, {\n\t\t.freq = 110,\t\t \n\t\t.open_d = 0x00,\t\t \n\t\t.rf_mux_ploy = 0x02,\t \n\t\t.tf_c = 0x24,\t\t \n\t\t.xtal_cap20p = 0x01,\t \n\t\t.xtal_cap10p = 0x01,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 1,\n\t}, {\n\t\t.freq = 120,\t\t \n\t\t.open_d = 0x00,\t\t \n\t\t.rf_mux_ploy = 0x02,\t \n\t\t.tf_c = 0x24,\t\t \n\t\t.xtal_cap20p = 0x01,\t \n\t\t.xtal_cap10p = 0x01,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 1,\n\t}, {\n\t\t.freq = 140,\t\t \n\t\t.open_d = 0x00,\t\t \n\t\t.rf_mux_ploy = 0x02,\t \n\t\t.tf_c = 0x14,\t\t \n\t\t.xtal_cap20p = 0x01,\t \n\t\t.xtal_cap10p = 0x01,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 1,\n\t}, {\n\t\t.freq = 180,\t\t \n\t\t.open_d = 0x00,\t\t \n\t\t.rf_mux_ploy = 0x02,\t \n\t\t.tf_c = 0x13,\t\t \n\t\t.xtal_cap20p = 0x00,\t \n\t\t.xtal_cap10p = 0x00,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 1,\n\t}, {\n\t\t.freq = 220,\t\t \n\t\t.open_d = 0x00,\t\t \n\t\t.rf_mux_ploy = 0x02,\t \n\t\t.tf_c = 0x13,\t\t \n\t\t.xtal_cap20p = 0x00,\t \n\t\t.xtal_cap10p = 0x00,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 2,\n\t}, {\n\t\t.freq = 250,\t\t \n\t\t.open_d = 0x00,\t\t \n\t\t.rf_mux_ploy = 0x02,\t \n\t\t.tf_c = 0x11,\t\t \n\t\t.xtal_cap20p = 0x00,\t \n\t\t.xtal_cap10p = 0x00,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 2,\n\t}, {\n\t\t.freq = 280,\t\t \n\t\t.open_d = 0x00,\t\t \n\t\t.rf_mux_ploy = 0x02,\t \n\t\t.tf_c = 0x00,\t\t \n\t\t.xtal_cap20p = 0x00,\t \n\t\t.xtal_cap10p = 0x00,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 2,\n\t}, {\n\t\t.freq = 310,\t\t \n\t\t.open_d = 0x00,\t\t \n\t\t.rf_mux_ploy = 0x41,\t \n\t\t.tf_c = 0x00,\t\t \n\t\t.xtal_cap20p = 0x00,\t \n\t\t.xtal_cap10p = 0x00,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 2,\n\t}, {\n\t\t.freq = 450,\t\t \n\t\t.open_d = 0x00,\t\t \n\t\t.rf_mux_ploy = 0x41,\t \n\t\t.tf_c = 0x00,\t\t \n\t\t.xtal_cap20p = 0x00,\t \n\t\t.xtal_cap10p = 0x00,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 3,\n\t}, {\n\t\t.freq = 588,\t\t \n\t\t.open_d = 0x00,\t\t \n\t\t.rf_mux_ploy = 0x40,\t \n\t\t.tf_c = 0x00,\t\t \n\t\t.xtal_cap20p = 0x00,\t \n\t\t.xtal_cap10p = 0x00,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 3,\n\t}, {\n\t\t.freq = 650,\t\t \n\t\t.open_d = 0x00,\t\t \n\t\t.rf_mux_ploy = 0x40,\t \n\t\t.tf_c = 0x00,\t\t \n\t\t.xtal_cap20p = 0x00,\t \n\t\t.xtal_cap10p = 0x00,\n\t\t.xtal_cap0p = 0x00,\n\t\t.imr_mem = 4,\n\t}\n};\n\nstatic int r820t_xtal_capacitor[][2] = {\n\t{ 0x0b, XTAL_LOW_CAP_30P },\n\t{ 0x02, XTAL_LOW_CAP_20P },\n\t{ 0x01, XTAL_LOW_CAP_10P },\n\t{ 0x00, XTAL_LOW_CAP_0P  },\n\t{ 0x10, XTAL_HIGH_CAP_0P },\n};\n\nstatic const char *r820t_chip_enum_to_str(enum r820t_chip chip)\n{\n\tswitch (chip) {\n\tcase CHIP_R820T:\n\t\treturn \"R820T\";\n\tcase CHIP_R620D:\n\t\treturn \"R620D\";\n\tcase CHIP_R828D:\n\t\treturn \"R828D\";\n\tcase CHIP_R828:\n\t\treturn \"R828\";\n\tcase CHIP_R828S:\n\t\treturn \"R828S\";\n\tcase CHIP_R820C:\n\t\treturn \"R820C\";\n\tdefault:\n\t\treturn \"<unknown>\";\n\t}\n}\n\n \nstatic void shadow_store(struct r820t_priv *priv, u8 reg, const u8 *val,\n\t\t\t int len)\n{\n\tint r = reg - REG_SHADOW_START;\n\n\tif (r < 0) {\n\t\tlen += r;\n\t\tr = 0;\n\t}\n\tif (len <= 0)\n\t\treturn;\n\tif (len > NUM_REGS - r)\n\t\tlen = NUM_REGS - r;\n\n\ttuner_dbg(\"%s: prev  reg=%02x len=%d: %*ph\\n\",\n\t\t  __func__, r + REG_SHADOW_START, len, len, val);\n\n\tmemcpy(&priv->regs[r], val, len);\n}\n\nstatic int r820t_write(struct r820t_priv *priv, u8 reg, const u8 *val,\n\t\t       int len)\n{\n\tint rc, size, pos = 0;\n\n\t \n\tshadow_store(priv, reg, val, len);\n\n\tdo {\n\t\tif (len > priv->cfg->max_i2c_msg_len - 1)\n\t\t\tsize = priv->cfg->max_i2c_msg_len - 1;\n\t\telse\n\t\t\tsize = len;\n\n\t\t \n\t\tpriv->buf[0] = reg;\n\t\tmemcpy(&priv->buf[1], &val[pos], size);\n\n\t\trc = tuner_i2c_xfer_send(&priv->i2c_props, priv->buf, size + 1);\n\t\tif (rc != size + 1) {\n\t\t\ttuner_info(\"%s: i2c wr failed=%d reg=%02x len=%d: %*ph\\n\",\n\t\t\t\t   __func__, rc, reg, size, size, &priv->buf[1]);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t\ttuner_dbg(\"%s: i2c wr reg=%02x len=%d: %*ph\\n\",\n\t\t\t  __func__, reg, size, size, &priv->buf[1]);\n\n\t\treg += size;\n\t\tlen -= size;\n\t\tpos += size;\n\t} while (len > 0);\n\n\treturn 0;\n}\n\nstatic inline int r820t_write_reg(struct r820t_priv *priv, u8 reg, u8 val)\n{\n\tu8 tmp = val;  \n\n\treturn r820t_write(priv, reg, &tmp, 1);\n}\n\nstatic int r820t_read_cache_reg(struct r820t_priv *priv, int reg)\n{\n\treg -= REG_SHADOW_START;\n\n\tif (reg >= 0 && reg < NUM_REGS)\n\t\treturn priv->regs[reg];\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic inline int r820t_write_reg_mask(struct r820t_priv *priv, u8 reg, u8 val,\n\t\t\t\tu8 bit_mask)\n{\n\tu8 tmp = val;\n\tint rc = r820t_read_cache_reg(priv, reg);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\ttmp = (rc & ~bit_mask) | (tmp & bit_mask);\n\n\treturn r820t_write(priv, reg, &tmp, 1);\n}\n\nstatic int r820t_read(struct r820t_priv *priv, u8 reg, u8 *val, int len)\n{\n\tint rc, i;\n\tu8 *p = &priv->buf[1];\n\n\tpriv->buf[0] = reg;\n\n\trc = tuner_i2c_xfer_send_recv(&priv->i2c_props, priv->buf, 1, p, len);\n\tif (rc != len) {\n\t\ttuner_info(\"%s: i2c rd failed=%d reg=%02x len=%d: %*ph\\n\",\n\t\t\t   __func__, rc, reg, len, len, p);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treturn -EREMOTEIO;\n\t}\n\n\t \n\tfor (i = 0; i < len; i++)\n\t\tval[i] = bitrev8(p[i]);\n\n\ttuner_dbg(\"%s: i2c rd reg=%02x len=%d: %*ph\\n\",\n\t\t  __func__, reg, len, len, val);\n\n\treturn 0;\n}\n\n \n\nstatic int r820t_set_mux(struct r820t_priv *priv, u32 freq)\n{\n\tconst struct r820t_freq_range *range;\n\tint i, rc;\n\tu8 val, reg08, reg09;\n\n\t \n\tfreq = freq / 1000000;\n\tfor (i = 0; i < ARRAY_SIZE(freq_ranges) - 1; i++) {\n\t\tif (freq < freq_ranges[i + 1].freq)\n\t\t\tbreak;\n\t}\n\trange = &freq_ranges[i];\n\n\ttuner_dbg(\"set r820t range#%d for frequency %d MHz\\n\", i, freq);\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x17, range->open_d, 0x08);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x1a, range->rf_mux_ploy, 0xc3);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg(priv, 0x1b, range->tf_c);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tswitch (priv->xtal_cap_sel) {\n\tcase XTAL_LOW_CAP_30P:\n\tcase XTAL_LOW_CAP_20P:\n\t\tval = range->xtal_cap20p | 0x08;\n\t\tbreak;\n\tcase XTAL_LOW_CAP_10P:\n\t\tval = range->xtal_cap10p | 0x08;\n\t\tbreak;\n\tcase XTAL_HIGH_CAP_0P:\n\t\tval = range->xtal_cap0p | 0x00;\n\t\tbreak;\n\tdefault:\n\tcase XTAL_LOW_CAP_0P:\n\t\tval = range->xtal_cap0p | 0x08;\n\t\tbreak;\n\t}\n\trc = r820t_write_reg_mask(priv, 0x10, val, 0x0b);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (priv->imr_done) {\n\t\treg08 = priv->imr_data[range->imr_mem].gain_x;\n\t\treg09 = priv->imr_data[range->imr_mem].phase_y;\n\t} else {\n\t\treg08 = 0;\n\t\treg09 = 0;\n\t}\n\trc = r820t_write_reg_mask(priv, 0x08, reg08, 0x3f);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = r820t_write_reg_mask(priv, 0x09, reg09, 0x3f);\n\n\treturn rc;\n}\n\nstatic int r820t_set_pll(struct r820t_priv *priv, enum v4l2_tuner_type type,\n\t\t\t u32 freq)\n{\n\tu32 vco_freq;\n\tint rc, i;\n\tunsigned sleep_time = 10000;\n\tu32 vco_fra;\t\t \n\tu32 vco_min  = 1770000;\n\tu32 vco_max  = vco_min * 2;\n\tu32 pll_ref;\n\tu16 n_sdm = 2;\n\tu16 sdm = 0;\n\tu8 mix_div = 2;\n\tu8 div_buf = 0;\n\tu8 div_num = 0;\n\tu8 refdiv2 = 0;\n\tu8 ni, si, nint, vco_fine_tune, val;\n\tu8 data[5];\n\n\t \n\tfreq = freq / 1000;\n\tpll_ref = priv->cfg->xtal / 1000;\n\n#if 0\n\t \n\tif ((priv->cfg->rafael_chip == CHIP_R620D) ||\n\t   (priv->cfg->rafael_chip == CHIP_R828D) ||\n\t   (priv->cfg->rafael_chip == CHIP_R828)) {\n\t\t \n\t\tif (type != V4L2_TUNER_DIGITAL_TV) {\n\t\t\tpll_ref /= 2;\n\t\t\trefdiv2 = 0x10;\n\t\t\tsleep_time = 20000;\n\t\t}\n\t} else {\n\t\tif (priv->cfg->xtal > 24000000) {\n\t\t\tpll_ref /= 2;\n\t\t\trefdiv2 = 0x10;\n\t\t}\n\t}\n#endif\n\n\trc = r820t_write_reg_mask(priv, 0x10, refdiv2, 0x10);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x1a, 0x00, 0x0c);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x12, 0x80, 0xe0);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\twhile (mix_div <= 64) {\n\t\tif (((freq * mix_div) >= vco_min) &&\n\t\t   ((freq * mix_div) < vco_max)) {\n\t\t\tdiv_buf = mix_div;\n\t\t\twhile (div_buf > 2) {\n\t\t\t\tdiv_buf = div_buf >> 1;\n\t\t\t\tdiv_num++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmix_div = mix_div << 1;\n\t}\n\n\trc = r820t_read(priv, 0x00, data, sizeof(data));\n\tif (rc < 0)\n\t\treturn rc;\n\n\tvco_fine_tune = (data[4] & 0x30) >> 4;\n\n\ttuner_dbg(\"mix_div=%d div_num=%d vco_fine_tune=%d\\n\",\n\t\t\tmix_div, div_num, vco_fine_tune);\n\n\t \n\tif (priv->cfg->rafael_chip != CHIP_R828D) {\n\t\tif (vco_fine_tune > VCO_POWER_REF)\n\t\t\tdiv_num = div_num - 1;\n\t\telse if (vco_fine_tune < VCO_POWER_REF)\n\t\t\tdiv_num = div_num + 1;\n\t}\n\n\trc = r820t_write_reg_mask(priv, 0x10, div_num << 5, 0xe0);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tvco_freq = freq * mix_div;\n\tnint = vco_freq / (2 * pll_ref);\n\tvco_fra = vco_freq - 2 * pll_ref * nint;\n\n\t \n\tif (vco_fra < pll_ref / 64) {\n\t\tvco_fra = 0;\n\t} else if (vco_fra > pll_ref * 127 / 64) {\n\t\tvco_fra = 0;\n\t\tnint++;\n\t} else if ((vco_fra > pll_ref * 127 / 128) && (vco_fra < pll_ref)) {\n\t\tvco_fra = pll_ref * 127 / 128;\n\t} else if ((vco_fra > pll_ref) && (vco_fra < pll_ref * 129 / 128)) {\n\t\tvco_fra = pll_ref * 129 / 128;\n\t}\n\n\tni = (nint - 13) / 4;\n\tsi = nint - 4 * ni - 13;\n\n\trc = r820t_write_reg(priv, 0x14, ni + (si << 6));\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (!vco_fra)\n\t\tval = 0x08;\n\telse\n\t\tval = 0x00;\n\n\trc = r820t_write_reg_mask(priv, 0x12, val, 0x08);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\twhile (vco_fra > 1) {\n\t\tif (vco_fra > (2 * pll_ref / n_sdm)) {\n\t\t\tsdm = sdm + 32768 / (n_sdm / 2);\n\t\t\tvco_fra = vco_fra - 2 * pll_ref / n_sdm;\n\t\t\tif (n_sdm >= 0x8000)\n\t\t\t\tbreak;\n\t\t}\n\t\tn_sdm = n_sdm << 1;\n\t}\n\n\ttuner_dbg(\"freq %d kHz, pll ref %d%s, sdm=0x%04x\\n\",\n\t\t  freq, pll_ref, refdiv2 ? \" / 2\" : \"\", sdm);\n\n\trc = r820t_write_reg(priv, 0x16, sdm >> 8);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_write_reg(priv, 0x15, sdm & 0xff);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tusleep_range(sleep_time, sleep_time + 1000);\n\n\t\t \n\t\trc = r820t_read(priv, 0x00, data, 3);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tif (data[2] & 0x40)\n\t\t\tbreak;\n\n\t\tif (!i) {\n\t\t\t \n\t\t\trc = r820t_write_reg_mask(priv, 0x12, 0x60, 0xe0);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (!(data[2] & 0x40)) {\n\t\tpriv->has_lock = false;\n\t\treturn 0;\n\t}\n\n\tpriv->has_lock = true;\n\ttuner_dbg(\"tuner has lock at frequency %d kHz\\n\", freq);\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x1a, 0x08, 0x08);\n\n\treturn rc;\n}\n\nstatic int r820t_sysfreq_sel(struct r820t_priv *priv, u32 freq,\n\t\t\t     enum v4l2_tuner_type type,\n\t\t\t     v4l2_std_id std,\n\t\t\t     u32 delsys)\n{\n\tint rc;\n\tu8 mixer_top, lna_top, cp_cur, div_buf_cur, lna_vth_l, mixer_vth_l;\n\tu8 air_cable1_in, cable2_in, pre_dect, lna_discharge, filter_cur;\n\n\ttuner_dbg(\"adjusting tuner parameters for the standard\\n\");\n\n\tswitch (delsys) {\n\tcase SYS_DVBT:\n\t\tif ((freq == 506000000) || (freq == 666000000) ||\n\t\t   (freq == 818000000)) {\n\t\t\tmixer_top = 0x14;\t \n\t\t\tlna_top = 0xe5;\t\t \n\t\t\tcp_cur = 0x28;\t\t \n\t\t\tdiv_buf_cur = 0x20;\t \n\t\t} else {\n\t\t\tmixer_top = 0x24;\t \n\t\t\tlna_top = 0xe5;\t\t \n\t\t\tcp_cur = 0x38;\t\t \n\t\t\tdiv_buf_cur = 0x30;\t \n\t\t}\n\t\tlna_vth_l = 0x53;\t\t \n\t\tmixer_vth_l = 0x75;\t\t \n\t\tair_cable1_in = 0x00;\n\t\tcable2_in = 0x00;\n\t\tpre_dect = 0x40;\n\t\tlna_discharge = 14;\n\t\tfilter_cur = 0x40;\t\t \n\t\tbreak;\n\tcase SYS_DVBT2:\n\t\tmixer_top = 0x24;\t \n\t\tlna_top = 0xe5;\t\t \n\t\tlna_vth_l = 0x53;\t \n\t\tmixer_vth_l = 0x75;\t \n\t\tair_cable1_in = 0x00;\n\t\tcable2_in = 0x00;\n\t\tpre_dect = 0x40;\n\t\tlna_discharge = 14;\n\t\tcp_cur = 0x38;\t\t \n\t\tdiv_buf_cur = 0x30;\t \n\t\tfilter_cur = 0x40;\t \n\t\tbreak;\n\tcase SYS_ISDBT:\n\t\tmixer_top = 0x24;\t \n\t\tlna_top = 0xe5;\t\t \n\t\tlna_vth_l = 0x75;\t \n\t\tmixer_vth_l = 0x75;\t \n\t\tair_cable1_in = 0x00;\n\t\tcable2_in = 0x00;\n\t\tpre_dect = 0x40;\n\t\tlna_discharge = 14;\n\t\tcp_cur = 0x38;\t\t \n\t\tdiv_buf_cur = 0x30;\t \n\t\tfilter_cur = 0x40;\t \n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\tmixer_top = 0x24;        \n\t\tlna_top = 0xe5;\n\t\tlna_vth_l = 0x62;\n\t\tmixer_vth_l = 0x75;\n\t\tair_cable1_in = 0x60;\n\t\tcable2_in = 0x00;\n\t\tpre_dect = 0x40;\n\t\tlna_discharge = 14;\n\t\tcp_cur = 0x38;           \n\t\tdiv_buf_cur = 0x30;      \n\t\tfilter_cur = 0x40;       \n\t\tbreak;\n\tdefault:  \n\t\tmixer_top = 0x24;\t \n\t\tlna_top = 0xe5;\t\t \n\t\tlna_vth_l = 0x53;\t \n\t\tmixer_vth_l = 0x75;\t \n\t\tair_cable1_in = 0x00;\n\t\tcable2_in = 0x00;\n\t\tpre_dect = 0x40;\n\t\tlna_discharge = 14;\n\t\tcp_cur = 0x38;\t\t \n\t\tdiv_buf_cur = 0x30;\t \n\t\tfilter_cur = 0x40;\t \n\t\tbreak;\n\t}\n\n\tif (priv->cfg->use_diplexer &&\n\t   ((priv->cfg->rafael_chip == CHIP_R820T) ||\n\t   (priv->cfg->rafael_chip == CHIP_R828S) ||\n\t   (priv->cfg->rafael_chip == CHIP_R820C))) {\n\t\tif (freq > DIP_FREQ)\n\t\t\tair_cable1_in = 0x00;\n\t\telse\n\t\t\tair_cable1_in = 0x60;\n\t\tcable2_in = 0x00;\n\t}\n\n\n\tif (priv->cfg->use_predetect) {\n\t\trc = r820t_write_reg_mask(priv, 0x06, pre_dect, 0x40);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\trc = r820t_write_reg_mask(priv, 0x1d, lna_top, 0xc7);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_write_reg_mask(priv, 0x1c, mixer_top, 0xf8);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_write_reg(priv, 0x0d, lna_vth_l);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_write_reg(priv, 0x0e, mixer_vth_l);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x05, air_cable1_in, 0x60);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_write_reg_mask(priv, 0x06, cable2_in, 0x08);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = r820t_write_reg_mask(priv, 0x11, cp_cur, 0x38);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_write_reg_mask(priv, 0x17, div_buf_cur, 0x30);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_write_reg_mask(priv, 0x0a, filter_cur, 0x60);\n\tif (rc < 0)\n\t\treturn rc;\n\t \n\n\t \n\n\ttuner_dbg(\"adjusting LNA parameters\\n\");\n\tif (type != V4L2_TUNER_ANALOG_TV) {\n\t\t \n\t\trc = r820t_write_reg_mask(priv, 0x1d, 0, 0x38);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = r820t_write_reg_mask(priv, 0x1c, 0, 0x04);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = r820t_write_reg_mask(priv, 0x06, 0, 0x40);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = r820t_write_reg_mask(priv, 0x1a, 0x30, 0x30);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tmsleep(250);\n\n\t\t \n\t\trc = r820t_write_reg_mask(priv, 0x1d, 0x18, 0x38);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = r820t_write_reg_mask(priv, 0x1c, mixer_top, 0x04);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = r820t_write_reg_mask(priv, 0x1e, lna_discharge, 0x1f);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = r820t_write_reg_mask(priv, 0x1a, 0x20, 0x30);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t} else {\n\t\t \n\t\trc = r820t_write_reg_mask(priv, 0x06, 0, 0x40);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = r820t_write_reg_mask(priv, 0x1d, lna_top, 0x38);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = r820t_write_reg_mask(priv, 0x1c, mixer_top, 0x04);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = r820t_write_reg_mask(priv, 0x1e, lna_discharge, 0x1f);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = r820t_write_reg_mask(priv, 0x1a, 0x00, 0x30);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\trc = r820t_write_reg_mask(priv, 0x10, 0x00, 0x04);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int r820t_set_tv_standard(struct r820t_priv *priv,\n\t\t\t\t unsigned bw,\n\t\t\t\t enum v4l2_tuner_type type,\n\t\t\t\t v4l2_std_id std, u32 delsys)\n\n{\n\tint rc, i;\n\tu32 if_khz, filt_cal_lo;\n\tu8 data[5], val;\n\tu8 filt_gain, img_r, filt_q, hp_cor, ext_enable, loop_through;\n\tu8 lt_att, flt_ext_widest, polyfil_cur;\n\tbool need_calibration;\n\n\ttuner_dbg(\"selecting the delivery system\\n\");\n\n\tif (delsys == SYS_ISDBT) {\n\t\tif_khz = 4063;\n\t\tfilt_cal_lo = 59000;\n\t\tfilt_gain = 0x10;\t \n\t\timg_r = 0x00;\t\t \n\t\tfilt_q = 0x10;\t\t \n\t\thp_cor = 0x6a;\t\t \n\t\text_enable = 0x40;\t \n\t\tloop_through = 0x00;\t \n\t\tlt_att = 0x00;\t\t \n\t\tflt_ext_widest = 0x80;\t \n\t\tpolyfil_cur = 0x60;\t \n\t} else if (delsys == SYS_DVBC_ANNEX_A) {\n\t\tif_khz = 5070;\n\t\tfilt_cal_lo = 73500;\n\t\tfilt_gain = 0x10;\t \n\t\timg_r = 0x00;\t\t \n\t\tfilt_q = 0x10;\t\t \n\t\thp_cor = 0x0b;\t\t \n\t\text_enable = 0x40;\t \n\t\tloop_through = 0x00;\t \n\t\tlt_att = 0x00;\t\t \n\t\tflt_ext_widest = 0x00;\t \n\t\tpolyfil_cur = 0x60;\t \n\t} else if (delsys == SYS_DVBC_ANNEX_C) {\n\t\tif_khz = 4063;\n\t\tfilt_cal_lo = 55000;\n\t\tfilt_gain = 0x10;\t \n\t\timg_r = 0x00;\t\t \n\t\tfilt_q = 0x10;\t\t \n\t\thp_cor = 0x6a;\t\t \n\t\text_enable = 0x40;\t \n\t\tloop_through = 0x00;\t \n\t\tlt_att = 0x00;\t\t \n\t\tflt_ext_widest = 0x80;\t \n\t\tpolyfil_cur = 0x60;\t \n\t} else {\n\t\tif (bw <= 6) {\n\t\t\tif_khz = 3570;\n\t\t\tfilt_cal_lo = 56000;\t \n\t\t\tfilt_gain = 0x10;\t \n\t\t\timg_r = 0x00;\t\t \n\t\t\tfilt_q = 0x10;\t\t \n\t\t\thp_cor = 0x6b;\t\t \n\t\t\text_enable = 0x60;\t \n\t\t\tloop_through = 0x00;\t \n\t\t\tlt_att = 0x00;\t\t \n\t\t\tflt_ext_widest = 0x00;\t \n\t\t\tpolyfil_cur = 0x60;\t \n\t\t} else if (bw == 7) {\n#if 0\n\t\t\t \n\n\t\t\tif_khz = 4070;\n\t\t\tfilt_cal_lo = 60000;\n\t\t\tfilt_gain = 0x10;\t \n\t\t\timg_r = 0x00;\t\t \n\t\t\tfilt_q = 0x10;\t\t \n\t\t\thp_cor = 0x2b;\t\t \n\t\t\text_enable = 0x60;\t \n\t\t\tloop_through = 0x00;\t \n\t\t\tlt_att = 0x00;\t\t \n\t\t\tflt_ext_widest = 0x00;\t \n\t\t\tpolyfil_cur = 0x60;\t \n#endif\n\t\t\t \n\t\t\tif_khz = 4570;\n\t\t\tfilt_cal_lo = 63000;\n\t\t\tfilt_gain = 0x10;\t \n\t\t\timg_r = 0x00;\t\t \n\t\t\tfilt_q = 0x10;\t\t \n\t\t\thp_cor = 0x2a;\t\t \n\t\t\text_enable = 0x60;\t \n\t\t\tloop_through = 0x00;\t \n\t\t\tlt_att = 0x00;\t\t \n\t\t\tflt_ext_widest = 0x00;\t \n\t\t\tpolyfil_cur = 0x60;\t \n\t\t} else {\n\t\t\tif_khz = 4570;\n\t\t\tfilt_cal_lo = 68500;\n\t\t\tfilt_gain = 0x10;\t \n\t\t\timg_r = 0x00;\t\t \n\t\t\tfilt_q = 0x10;\t\t \n\t\t\thp_cor = 0x0b;\t\t \n\t\t\text_enable = 0x60;\t \n\t\t\tloop_through = 0x00;\t \n\t\t\tlt_att = 0x00;\t\t \n\t\t\tflt_ext_widest = 0x00;\t \n\t\t\tpolyfil_cur = 0x60;\t \n\t\t}\n\t}\n\n\t \n\tmemcpy(priv->regs, r820t_init_array, sizeof(r820t_init_array));\n\n\t \n\tif (priv->imr_done)\n\t\tval = 1 | priv->xtal_cap_sel << 1;\n\telse\n\t\tval = 0;\n\trc = r820t_write_reg_mask(priv, 0x0c, val, 0x0f);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x13, VER_NUM, 0x3f);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (type != V4L2_TUNER_ANALOG_TV) {\n\t\trc = r820t_write_reg_mask(priv, 0x1d, 0x00, 0x38);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tusleep_range(1000, 2000);\n\t}\n\tpriv->int_freq = if_khz * 1000;\n\n\t \n\tif (type != priv->type)\n\t\tneed_calibration = true;\n\telse if ((type == V4L2_TUNER_ANALOG_TV) && (std != priv->std))\n\t\tneed_calibration = true;\n\telse if ((type == V4L2_TUNER_DIGITAL_TV) &&\n\t\t ((delsys != priv->delsys) || bw != priv->bw))\n\t\tneed_calibration = true;\n\telse\n\t\tneed_calibration = false;\n\n\tif (need_calibration) {\n\t\ttuner_dbg(\"calibrating the tuner\\n\");\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\t \n\t\t\trc = r820t_write_reg_mask(priv, 0x0b, hp_cor, 0x60);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\t \n\t\t\trc = r820t_write_reg_mask(priv, 0x0f, 0x04, 0x04);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\t \n\t\t\trc = r820t_write_reg_mask(priv, 0x10, 0x00, 0x03);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\trc = r820t_set_pll(priv, type, filt_cal_lo * 1000);\n\t\t\tif (rc < 0 || !priv->has_lock)\n\t\t\t\treturn rc;\n\n\t\t\t \n\t\t\trc = r820t_write_reg_mask(priv, 0x0b, 0x10, 0x10);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\tusleep_range(1000, 2000);\n\n\t\t\t \n\t\t\trc = r820t_write_reg_mask(priv, 0x0b, 0x00, 0x10);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\t \n\t\t\trc = r820t_write_reg_mask(priv, 0x0f, 0x00, 0x04);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\t \n\t\t\trc = r820t_read(priv, 0x00, data, sizeof(data));\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\tpriv->fil_cal_code = data[4] & 0x0f;\n\t\t\tif (priv->fil_cal_code && priv->fil_cal_code != 0x0f)\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (priv->fil_cal_code == 0x0f)\n\t\t\tpriv->fil_cal_code = 0;\n\t}\n\n\trc = r820t_write_reg_mask(priv, 0x0a,\n\t\t\t\t  filt_q | priv->fil_cal_code, 0x1f);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x0b, hp_cor, 0xef);\n\tif (rc < 0)\n\t\treturn rc;\n\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x07, img_r, 0x80);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x06, filt_gain, 0x30);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x1e, ext_enable, 0x60);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x05, loop_through, 0x80);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x1f, lt_att, 0x80);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x0f, flt_ext_widest, 0x80);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x19, polyfil_cur, 0x60);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tpriv->delsys = delsys;\n\tpriv->type = type;\n\tpriv->std = std;\n\tpriv->bw = bw;\n\n\treturn 0;\n}\n\nstatic int r820t_read_gain(struct r820t_priv *priv)\n{\n\tu8 data[4];\n\tint rc;\n\n\trc = r820t_read(priv, 0x00, data, sizeof(data));\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn ((data[3] & 0x08) << 1) + ((data[3] & 0xf0) >> 4);\n}\n\n#if 0\n \n\n \n\nstatic const int r820t_lna_gain_steps[]  = {\n\t0, 9, 13, 40, 38, 13, 31, 22, 26, 31, 26, 14, 19, 5, 35, 13\n};\n\nstatic const int r820t_mixer_gain_steps[]  = {\n\t0, 5, 10, 10, 19, 9, 10, 25, 17, 10, 8, 16, 13, 6, 3, -8\n};\n\nstatic int r820t_set_gain_mode(struct r820t_priv *priv,\n\t\t\t       bool set_manual_gain,\n\t\t\t       int gain)\n{\n\tint rc;\n\n\tif (set_manual_gain) {\n\t\tint i, total_gain = 0;\n\t\tuint8_t mix_index = 0, lna_index = 0;\n\t\tu8 data[4];\n\n\t\t \n\t\trc = r820t_write_reg_mask(priv, 0x05, 0x10, 0x10);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t  \n\t\trc = r820t_write_reg_mask(priv, 0x07, 0, 0x10);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\trc = r820t_read(priv, 0x00, data, sizeof(data));\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = r820t_write_reg_mask(priv, 0x0c, 0x08, 0x9f);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tfor (i = 0; i < 15; i++) {\n\t\t\tif (total_gain >= gain)\n\t\t\t\tbreak;\n\n\t\t\ttotal_gain += r820t_lna_gain_steps[++lna_index];\n\n\t\t\tif (total_gain >= gain)\n\t\t\t\tbreak;\n\n\t\t\ttotal_gain += r820t_mixer_gain_steps[++mix_index];\n\t\t}\n\n\t\t \n\t\trc = r820t_write_reg_mask(priv, 0x05, lna_index, 0x0f);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = r820t_write_reg_mask(priv, 0x07, mix_index, 0x0f);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t} else {\n\t\t \n\t\trc = r820t_write_reg_mask(priv, 0x05, 0, 0x10);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = r820t_write_reg_mask(priv, 0x07, 0x10, 0x10);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = r820t_write_reg_mask(priv, 0x0c, 0x0b, 0x9f);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int generic_set_freq(struct dvb_frontend *fe,\n\t\t\t    u32 freq  ,\n\t\t\t    unsigned bw,\n\t\t\t    enum v4l2_tuner_type type,\n\t\t\t    v4l2_std_id std, u32 delsys)\n{\n\tstruct r820t_priv\t\t*priv = fe->tuner_priv;\n\tint\t\t\t\trc;\n\tu32\t\t\t\tlo_freq;\n\n\ttuner_dbg(\"should set frequency to %d kHz, bw %d MHz\\n\",\n\t\t  freq / 1000, bw);\n\n\trc = r820t_set_tv_standard(priv, bw, type, std, delsys);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tif ((type == V4L2_TUNER_ANALOG_TV) && (std == V4L2_STD_SECAM_LC))\n\t\tlo_freq = freq - priv->int_freq;\n\t else\n\t\tlo_freq = freq + priv->int_freq;\n\n\trc = r820t_set_mux(priv, lo_freq);\n\tif (rc < 0)\n\t\tgoto err;\n\n\trc = r820t_set_pll(priv, type, lo_freq);\n\tif (rc < 0 || !priv->has_lock)\n\t\tgoto err;\n\n\trc = r820t_sysfreq_sel(priv, freq, type, std, delsys);\n\tif (rc < 0)\n\t\tgoto err;\n\n\ttuner_dbg(\"%s: PLL locked on frequency %d Hz, gain=%d\\n\",\n\t\t  __func__, freq, r820t_read_gain(priv));\n\nerr:\n\n\tif (rc < 0)\n\t\ttuner_dbg(\"%s: failed=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\n \n\nstatic int r820t_standby(struct r820t_priv *priv)\n{\n\tint rc;\n\n\t \n\tif (!priv->init_done)\n\t\treturn 0;\n\n\trc = r820t_write_reg(priv, 0x06, 0xb1);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_write_reg(priv, 0x05, 0x03);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_write_reg(priv, 0x07, 0x3a);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_write_reg(priv, 0x08, 0x40);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_write_reg(priv, 0x09, 0xc0);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_write_reg(priv, 0x0a, 0x36);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_write_reg(priv, 0x0c, 0x35);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_write_reg(priv, 0x0f, 0x68);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_write_reg(priv, 0x11, 0x03);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_write_reg(priv, 0x17, 0xf4);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_write_reg(priv, 0x19, 0x0c);\n\n\t \n\tpriv->type = -1;\n\n\treturn rc;\n}\n\n \n\nstatic int r820t_xtal_check(struct r820t_priv *priv)\n{\n\tint rc, i;\n\tu8 data[3], val;\n\n\t \n\tmemcpy(priv->regs, r820t_init_array, sizeof(r820t_init_array));\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x10, 0x0b, 0x0b);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x1a, 0x00, 0x0c);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x13, 0x7f, 0x7f);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x13, 0x00, 0x40);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(r820t_xtal_capacitor); i++) {\n\t\trc = r820t_write_reg_mask(priv, 0x10,\n\t\t\t\t\t  r820t_xtal_capacitor[i][0], 0x1b);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tusleep_range(5000, 6000);\n\n\t\trc = r820t_read(priv, 0x00, data, sizeof(data));\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tif (!(data[2] & 0x40))\n\t\t\tcontinue;\n\n\t\tval = data[2] & 0x3f;\n\n\t\tif (priv->cfg->xtal == 16000000 && (val > 29 || val < 23))\n\t\t\tbreak;\n\n\t\tif (val != 0x3f)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(r820t_xtal_capacitor))\n\t\treturn -EINVAL;\n\n\treturn r820t_xtal_capacitor[i][1];\n}\n\nstatic int r820t_imr_prepare(struct r820t_priv *priv)\n{\n\tint rc;\n\n\t \n\tmemcpy(priv->regs, r820t_init_array, sizeof(r820t_init_array));\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x05, 0x20, 0x20);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x07, 0, 0x10);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x0a, 0x0f, 0x0f);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x0b, 0x60, 0x6f);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x0c, 0x0b, 0x9f);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x0f, 0, 0x08);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x18, 0x10, 0x10);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x1c, 0x02, 0x02);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x1e, 0x80, 0x80);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x06, 0x20, 0x20);\n\n\treturn rc;\n}\n\nstatic int r820t_multi_read(struct r820t_priv *priv)\n{\n\tint rc, i;\n\tu16 sum = 0;\n\tu8 data[2], min = 255, max = 0;\n\n\tusleep_range(5000, 6000);\n\n\tfor (i = 0; i < 6; i++) {\n\t\trc = r820t_read(priv, 0x00, data, sizeof(data));\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tsum += data[1];\n\n\t\tif (data[1] < min)\n\t\t\tmin = data[1];\n\n\t\tif (data[1] > max)\n\t\t\tmax = data[1];\n\t}\n\trc = sum - max - min;\n\n\treturn rc;\n}\n\nstatic int r820t_imr_cross(struct r820t_priv *priv,\n\t\t\t   struct r820t_sect_type iq_point[3],\n\t\t\t   u8 *x_direct)\n{\n\tstruct r820t_sect_type cross[5];  \n\tstruct r820t_sect_type tmp;\n\tint i, rc;\n\tu8 reg08, reg09;\n\n\treg08 = r820t_read_cache_reg(priv, 8) & 0xc0;\n\treg09 = r820t_read_cache_reg(priv, 9) & 0xc0;\n\n\ttmp.gain_x = 0;\n\ttmp.phase_y = 0;\n\ttmp.value = 255;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tcross[i].gain_x  = reg08;\n\t\t\tcross[i].phase_y = reg09;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tcross[i].gain_x  = reg08;\t\t \n\t\t\tcross[i].phase_y = reg09 + 1;\t\t \n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcross[i].gain_x  = reg08;\t\t \n\t\t\tcross[i].phase_y = (reg09 | 0x20) + 1;\t \n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcross[i].gain_x  = reg08 + 1;\t\t \n\t\t\tcross[i].phase_y = reg09;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcross[i].gain_x  = (reg08 | 0x20) + 1;\t \n\t\t\tcross[i].phase_y = reg09;\n\t\t}\n\n\t\trc = r820t_write_reg(priv, 0x08, cross[i].gain_x);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\trc = r820t_write_reg(priv, 0x09, cross[i].phase_y);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\trc = r820t_multi_read(priv);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tcross[i].value = rc;\n\n\t\tif (cross[i].value < tmp.value)\n\t\t\ttmp = cross[i];\n\t}\n\n\tif ((tmp.phase_y & 0x1f) == 1) {\t \n\t\t*x_direct = 0;\n\n\t\tiq_point[0] = cross[0];\n\t\tiq_point[1] = cross[1];\n\t\tiq_point[2] = cross[2];\n\t} else {\t\t\t\t \n\t\t*x_direct = 1;\n\n\t\tiq_point[0] = cross[0];\n\t\tiq_point[1] = cross[3];\n\t\tiq_point[2] = cross[4];\n\t}\n\treturn 0;\n}\n\nstatic void r820t_compre_cor(struct r820t_sect_type iq[3])\n{\n\tint i;\n\n\tfor (i = 3; i > 0; i--) {\n\t\tif (iq[0].value > iq[i - 1].value)\n\t\t\tswap(iq[0], iq[i - 1]);\n\t}\n}\n\nstatic int r820t_compre_step(struct r820t_priv *priv,\n\t\t\t     struct r820t_sect_type iq[3], u8 reg)\n{\n\tint rc;\n\tstruct r820t_sect_type tmp;\n\n\t \n\n\t \n\ttmp.phase_y = iq[0].phase_y;\n\ttmp.gain_x  = iq[0].gain_x;\n\n\twhile (((tmp.gain_x & 0x1f) < IMR_TRIAL) &&\n\t      ((tmp.phase_y & 0x1f) < IMR_TRIAL)) {\n\t\tif (reg == 0x08)\n\t\t\ttmp.gain_x++;\n\t\telse\n\t\t\ttmp.phase_y++;\n\n\t\trc = r820t_write_reg(priv, 0x08, tmp.gain_x);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\trc = r820t_write_reg(priv, 0x09, tmp.phase_y);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\trc = r820t_multi_read(priv);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\ttmp.value = rc;\n\n\t\tif (tmp.value <= iq[0].value) {\n\t\t\tiq[0].gain_x  = tmp.gain_x;\n\t\t\tiq[0].phase_y = tmp.phase_y;\n\t\t\tiq[0].value   = tmp.value;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nstatic int r820t_iq_tree(struct r820t_priv *priv,\n\t\t\t struct r820t_sect_type iq[3],\n\t\t\t u8 fix_val, u8 var_val, u8 fix_reg)\n{\n\tint rc, i;\n\tu8 tmp, var_reg;\n\n\t \n\n\tif (fix_reg == 0x08)\n\t\tvar_reg = 0x09;\n\telse\n\t\tvar_reg = 0x08;\n\n\tfor (i = 0; i < 3; i++) {\n\t\trc = r820t_write_reg(priv, fix_reg, fix_val);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\trc = r820t_write_reg(priv, var_reg, var_val);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\trc = r820t_multi_read(priv);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tiq[i].value = rc;\n\n\t\tif (fix_reg == 0x08) {\n\t\t\tiq[i].gain_x  = fix_val;\n\t\t\tiq[i].phase_y = var_val;\n\t\t} else {\n\t\t\tiq[i].phase_y = fix_val;\n\t\t\tiq[i].gain_x  = var_val;\n\t\t}\n\n\t\tif (i == 0) {   \n\t\t\tvar_val++;\n\t\t} else if (i == 1) {  \n\t\t\t  \n\t\t\tif ((var_val & 0x1f) < 0x02) {\n\t\t\t\ttmp = 2 - (var_val & 0x1f);\n\n\t\t\t\t \n\t\t\t\tif (var_val & 0x20) {\n\t\t\t\t\tvar_val &= 0xc0;\n\t\t\t\t\tvar_val |= tmp;\n\t\t\t\t} else {\n\t\t\t\t\tvar_val |= 0x20 | tmp;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar_val -= 2;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int r820t_section(struct r820t_priv *priv,\n\t\t\t struct r820t_sect_type *iq_point)\n{\n\tint rc;\n\tstruct r820t_sect_type compare_iq[3], compare_bet[3];\n\n\t \n\tif (!(iq_point->gain_x & 0x1f))\n\t\tcompare_iq[0].gain_x = ((iq_point->gain_x) & 0xdf) + 1;   \n\telse\n\t\tcompare_iq[0].gain_x  = iq_point->gain_x - 1;   \n\tcompare_iq[0].phase_y = iq_point->phase_y;\n\n\t \n\trc = r820t_iq_tree(priv, compare_iq,  compare_iq[0].gain_x,\n\t\t\tcompare_iq[0].phase_y, 0x08);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tr820t_compre_cor(compare_iq);\n\n\tcompare_bet[0] = compare_iq[0];\n\n\t \n\tcompare_iq[0].gain_x  = iq_point->gain_x;\n\tcompare_iq[0].phase_y = iq_point->phase_y;\n\n\trc = r820t_iq_tree(priv, compare_iq,  compare_iq[0].gain_x,\n\t\t\t   compare_iq[0].phase_y, 0x08);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tr820t_compre_cor(compare_iq);\n\n\tcompare_bet[1] = compare_iq[0];\n\n\t \n\tif ((iq_point->gain_x & 0x1f) == 0x00)\n\t\tcompare_iq[0].gain_x = ((iq_point->gain_x) | 0x20) + 1;   \n\telse\n\t\tcompare_iq[0].gain_x = iq_point->gain_x + 1;\n\tcompare_iq[0].phase_y = iq_point->phase_y;\n\n\trc = r820t_iq_tree(priv, compare_iq,  compare_iq[0].gain_x,\n\t\t\t   compare_iq[0].phase_y, 0x08);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tr820t_compre_cor(compare_iq);\n\n\tcompare_bet[2] = compare_iq[0];\n\n\tr820t_compre_cor(compare_bet);\n\n\t*iq_point = compare_bet[0];\n\n\treturn 0;\n}\n\nstatic int r820t_vga_adjust(struct r820t_priv *priv)\n{\n\tint rc;\n\tu8 vga_count;\n\n\t \n\tfor (vga_count = 12; vga_count < 16; vga_count++) {\n\t\trc = r820t_write_reg_mask(priv, 0x0c, vga_count, 0x0f);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tusleep_range(10000, 11000);\n\n\t\trc = r820t_multi_read(priv);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif (rc > 40 * 4)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int r820t_iq(struct r820t_priv *priv, struct r820t_sect_type *iq_pont)\n{\n\tstruct r820t_sect_type compare_iq[3];\n\tint rc;\n\tu8 x_direction = 0;   \n\tu8 dir_reg, other_reg;\n\n\tr820t_vga_adjust(priv);\n\n\trc = r820t_imr_cross(priv, compare_iq, &x_direction);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (x_direction == 1) {\n\t\tdir_reg   = 0x08;\n\t\tother_reg = 0x09;\n\t} else {\n\t\tdir_reg   = 0x09;\n\t\tother_reg = 0x08;\n\t}\n\n\t \n\tr820t_compre_cor(compare_iq);\n\n\t \n\trc = r820t_compre_step(priv, compare_iq, dir_reg);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_iq_tree(priv, compare_iq,  compare_iq[0].gain_x,\n\t\t\t\tcompare_iq[0].phase_y, dir_reg);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tr820t_compre_cor(compare_iq);\n\n\t \n\trc = r820t_compre_step(priv, compare_iq, other_reg);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_iq_tree(priv, compare_iq,  compare_iq[0].gain_x,\n\t\t\t\tcompare_iq[0].phase_y, other_reg);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tr820t_compre_cor(compare_iq);\n\n\t \n\trc = r820t_section(priv, compare_iq);\n\n\t*iq_pont = compare_iq[0];\n\n\t \n\trc = r820t_write_reg_mask(priv, 0x08, 0, 0x3f);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = r820t_write_reg_mask(priv, 0x09, 0, 0x3f);\n\n\treturn rc;\n}\n\nstatic int r820t_f_imr(struct r820t_priv *priv, struct r820t_sect_type *iq_pont)\n{\n\tint rc;\n\n\tr820t_vga_adjust(priv);\n\n\t \n\trc = r820t_section(priv, iq_pont);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int r820t_imr(struct r820t_priv *priv, unsigned imr_mem, bool im_flag)\n{\n\tstruct r820t_sect_type imr_point;\n\tint rc;\n\tu32 ring_vco, ring_freq, ring_ref;\n\tu8 n_ring, n;\n\tint reg18, reg19, reg1f;\n\n\tif (priv->cfg->xtal > 24000000)\n\t\tring_ref = priv->cfg->xtal / 2000;\n\telse\n\t\tring_ref = priv->cfg->xtal / 1000;\n\n\tn_ring = 15;\n\tfor (n = 0; n < 16; n++) {\n\t\tif ((16 + n) * 8 * ring_ref >= 3100000) {\n\t\t\tn_ring = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treg18 = r820t_read_cache_reg(priv, 0x18);\n\treg19 = r820t_read_cache_reg(priv, 0x19);\n\treg1f = r820t_read_cache_reg(priv, 0x1f);\n\n\treg18 &= 0xf0;       \n\treg18 |= n_ring;\n\n\tring_vco = (16 + n_ring) * 8 * ring_ref;\n\n\treg18 &= 0xdf;    \n\treg19 &= 0xfc;    \n\treg1f &= 0xfc;    \n\n\tswitch (imr_mem) {\n\tcase 0:\n\t\tring_freq = ring_vco / 48;\n\t\treg18 |= 0x20;   \n\t\treg19 |= 0x03;   \n\t\treg1f |= 0x02;   \n\t\tbreak;\n\tcase 1:\n\t\tring_freq = ring_vco / 16;\n\t\treg18 |= 0x00;   \n\t\treg19 |= 0x02;   \n\t\treg1f |= 0x00;   \n\t\tbreak;\n\tcase 2:\n\t\tring_freq = ring_vco / 8;\n\t\treg18 |= 0x00;   \n\t\treg19 |= 0x01;   \n\t\treg1f |= 0x03;   \n\t\tbreak;\n\tcase 3:\n\t\tring_freq = ring_vco / 6;\n\t\treg18 |= 0x20;   \n\t\treg19 |= 0x00;   \n\t\treg1f |= 0x03;   \n\t\tbreak;\n\tcase 4:\n\t\tring_freq = ring_vco / 4;\n\t\treg18 |= 0x00;   \n\t\treg19 |= 0x00;   \n\t\treg1f |= 0x01;   \n\t\tbreak;\n\tdefault:\n\t\tring_freq = ring_vco / 4;\n\t\treg18 |= 0x00;   \n\t\treg19 |= 0x00;   \n\t\treg1f |= 0x01;   \n\t\tbreak;\n\t}\n\n\n\t \n\n\t \n\trc = r820t_write_reg(priv, 0x18, reg18);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg(priv, 0x19, reg19);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_write_reg(priv, 0x1f, reg1f);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = r820t_set_mux(priv, (ring_freq - 5300) * 1000);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = r820t_set_pll(priv, V4L2_TUNER_DIGITAL_TV,\n\t\t\t   (ring_freq - 5300) * 1000);\n\tif (!priv->has_lock)\n\t\trc = -EINVAL;\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (im_flag) {\n\t\trc = r820t_iq(priv, &imr_point);\n\t} else {\n\t\timr_point.gain_x  = priv->imr_data[3].gain_x;\n\t\timr_point.phase_y = priv->imr_data[3].phase_y;\n\t\timr_point.value   = priv->imr_data[3].value;\n\n\t\trc = r820t_f_imr(priv, &imr_point);\n\t}\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tswitch (imr_mem) {\n\tcase 0:\n\t\tpriv->imr_data[0].gain_x  = imr_point.gain_x;\n\t\tpriv->imr_data[0].phase_y = imr_point.phase_y;\n\t\tpriv->imr_data[0].value   = imr_point.value;\n\t\tbreak;\n\tcase 1:\n\t\tpriv->imr_data[1].gain_x  = imr_point.gain_x;\n\t\tpriv->imr_data[1].phase_y = imr_point.phase_y;\n\t\tpriv->imr_data[1].value   = imr_point.value;\n\t\tbreak;\n\tcase 2:\n\t\tpriv->imr_data[2].gain_x  = imr_point.gain_x;\n\t\tpriv->imr_data[2].phase_y = imr_point.phase_y;\n\t\tpriv->imr_data[2].value   = imr_point.value;\n\t\tbreak;\n\tcase 3:\n\t\tpriv->imr_data[3].gain_x  = imr_point.gain_x;\n\t\tpriv->imr_data[3].phase_y = imr_point.phase_y;\n\t\tpriv->imr_data[3].value   = imr_point.value;\n\t\tbreak;\n\tcase 4:\n\t\tpriv->imr_data[4].gain_x  = imr_point.gain_x;\n\t\tpriv->imr_data[4].phase_y = imr_point.phase_y;\n\t\tpriv->imr_data[4].value   = imr_point.value;\n\t\tbreak;\n\tdefault:\n\t\tpriv->imr_data[4].gain_x  = imr_point.gain_x;\n\t\tpriv->imr_data[4].phase_y = imr_point.phase_y;\n\t\tpriv->imr_data[4].value   = imr_point.value;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int r820t_imr_callibrate(struct r820t_priv *priv)\n{\n\tint rc, i;\n\tint xtal_cap = 0;\n\n\tif (priv->init_done)\n\t\treturn 0;\n\n\t \n\tif ((priv->cfg->rafael_chip == CHIP_R820T) ||\n\t    (priv->cfg->rafael_chip == CHIP_R828S) ||\n\t    (priv->cfg->rafael_chip == CHIP_R820C)) {\n\t\tpriv->xtal_cap_sel = XTAL_HIGH_CAP_0P;\n\t} else {\n\t\t \n\t\trc = r820t_write(priv, 0x05,\n\t\t\t\tr820t_init_array, sizeof(r820t_init_array));\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trc = r820t_xtal_check(priv);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tif (!i || rc > xtal_cap)\n\t\t\t\txtal_cap = rc;\n\t\t}\n\t\tpriv->xtal_cap_sel = xtal_cap;\n\t}\n\n\t \n\tif (no_imr_cal) {\n\t\tpriv->init_done = true;\n\n\t\treturn 0;\n\t}\n\n\t \n\trc = r820t_write(priv, 0x05,\n\t\t\t r820t_init_array, sizeof(r820t_init_array));\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = r820t_imr_prepare(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = r820t_imr(priv, 3, true);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_imr(priv, 1, false);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_imr(priv, 0, false);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_imr(priv, 2, false);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = r820t_imr(priv, 4, false);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tpriv->init_done = true;\n\tpriv->imr_done = true;\n\n\treturn 0;\n}\n\n#if 0\n \nstatic int r820t_gpio(struct r820t_priv *priv, bool enable)\n{\n\treturn r820t_write_reg_mask(priv, 0x0f, enable ? 1 : 0, 0x01);\n}\n#endif\n\n \n\nstatic int r820t_init(struct dvb_frontend *fe)\n{\n\tstruct r820t_priv *priv = fe->tuner_priv;\n\tint rc;\n\n\ttuner_dbg(\"%s:\\n\", __func__);\n\n\tmutex_lock(&priv->lock);\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\trc = r820t_imr_callibrate(priv);\n\tif (rc < 0)\n\t\tgoto err;\n\n\t \n\trc = r820t_write(priv, 0x05,\n\t\t\t r820t_init_array, sizeof(r820t_init_array));\n\nerr:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\tmutex_unlock(&priv->lock);\n\n\tif (rc < 0)\n\t\ttuner_dbg(\"%s: failed=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\nstatic int r820t_sleep(struct dvb_frontend *fe)\n{\n\tstruct r820t_priv *priv = fe->tuner_priv;\n\tint rc;\n\n\ttuner_dbg(\"%s:\\n\", __func__);\n\n\tmutex_lock(&priv->lock);\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\trc = r820t_standby(priv);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\tmutex_unlock(&priv->lock);\n\n\ttuner_dbg(\"%s: failed=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\nstatic int r820t_set_analog_freq(struct dvb_frontend *fe,\n\t\t\t\t struct analog_parameters *p)\n{\n\tstruct r820t_priv *priv = fe->tuner_priv;\n\tunsigned bw;\n\tint rc;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\t \n\tif (!p->std)\n\t\tp->std = V4L2_STD_MN;\n\n\tif ((p->std == V4L2_STD_PAL_M) || (p->std == V4L2_STD_NTSC))\n\t\tbw = 6;\n\telse\n\t\tbw = 8;\n\n\tmutex_lock(&priv->lock);\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\trc = generic_set_freq(fe, 62500l * p->frequency, bw,\n\t\t\t      V4L2_TUNER_ANALOG_TV, p->std, SYS_UNDEFINED);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}\n\nstatic int r820t_set_params(struct dvb_frontend *fe)\n{\n\tstruct r820t_priv *priv = fe->tuner_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint rc;\n\tunsigned bw;\n\n\ttuner_dbg(\"%s: delivery_system=%d frequency=%d bandwidth_hz=%d\\n\",\n\t\t__func__, c->delivery_system, c->frequency, c->bandwidth_hz);\n\n\tmutex_lock(&priv->lock);\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tbw = (c->bandwidth_hz + 500000) / 1000000;\n\tif (!bw)\n\t\tbw = 8;\n\n\trc = generic_set_freq(fe, c->frequency, bw,\n\t\t\t      V4L2_TUNER_DIGITAL_TV, 0, c->delivery_system);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\tmutex_unlock(&priv->lock);\n\n\tif (rc)\n\t\ttuner_dbg(\"%s: failed=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\nstatic int r820t_signal(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct r820t_priv *priv = fe->tuner_priv;\n\tint rc = 0;\n\n\tmutex_lock(&priv->lock);\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tif (priv->has_lock) {\n\t\trc = r820t_read_gain(priv);\n\t\tif (rc < 0)\n\t\t\tgoto err;\n\n\t\t \n\t\t*strength = (45 - rc) << 4 | 0xff;\n\t\tif (*strength == 0xff)\n\t\t\t*strength = 0;\n\t} else {\n\t\t*strength = 0;\n\t}\n\nerr:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\tmutex_unlock(&priv->lock);\n\n\ttuner_dbg(\"%s: %s, gain=%d strength=%d\\n\",\n\t\t  __func__,\n\t\t  priv->has_lock ? \"PLL locked\" : \"no signal\",\n\t\t  rc, *strength);\n\n\treturn 0;\n}\n\nstatic int r820t_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct r820t_priv *priv = fe->tuner_priv;\n\n\ttuner_dbg(\"%s:\\n\", __func__);\n\n\t*frequency = priv->int_freq;\n\n\treturn 0;\n}\n\nstatic void r820t_release(struct dvb_frontend *fe)\n{\n\tstruct r820t_priv *priv = fe->tuner_priv;\n\n\ttuner_dbg(\"%s:\\n\", __func__);\n\n\tmutex_lock(&r820t_list_mutex);\n\n\tif (priv)\n\t\thybrid_tuner_release_state(priv);\n\n\tmutex_unlock(&r820t_list_mutex);\n\n\tfe->tuner_priv = NULL;\n}\n\nstatic const struct dvb_tuner_ops r820t_tuner_ops = {\n\t.info = {\n\t\t.name             = \"Rafael Micro R820T\",\n\t\t.frequency_min_hz =   42 * MHz,\n\t\t.frequency_max_hz = 1002 * MHz,\n\t},\n\t.init = r820t_init,\n\t.release = r820t_release,\n\t.sleep = r820t_sleep,\n\t.set_params = r820t_set_params,\n\t.set_analog_params = r820t_set_analog_freq,\n\t.get_if_frequency = r820t_get_if_frequency,\n\t.get_rf_strength = r820t_signal,\n};\n\nstruct dvb_frontend *r820t_attach(struct dvb_frontend *fe,\n\t\t\t\t  struct i2c_adapter *i2c,\n\t\t\t\t  const struct r820t_config *cfg)\n{\n\tstruct r820t_priv *priv;\n\tint rc = -ENODEV;\n\tu8 data[5];\n\tint instance;\n\n\tmutex_lock(&r820t_list_mutex);\n\n\tinstance = hybrid_tuner_request_state(struct r820t_priv, priv,\n\t\t\t\t\t      hybrid_tuner_instance_list,\n\t\t\t\t\t      i2c, cfg->i2c_addr,\n\t\t\t\t\t      \"r820t\");\n\tswitch (instance) {\n\tcase 0:\n\t\t \n\t\tgoto err_no_gate;\n\tcase 1:\n\t\t \n\t\tpriv->cfg = cfg;\n\n\t\tmutex_init(&priv->lock);\n\n\t\tfe->tuner_priv = priv;\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tfe->tuner_priv = priv;\n\t\tbreak;\n\t}\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t \n\trc = r820t_read(priv, 0x00, data, sizeof(data));\n\tif (rc < 0)\n\t\tgoto err;\n\n\trc = r820t_sleep(fe);\n\tif (rc < 0)\n\t\tgoto err;\n\n\ttuner_info(\n\t\t\"Rafael Micro r820t successfully identified, chip type: %s\\n\",\n\t\tr820t_chip_enum_to_str(cfg->rafael_chip));\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tmutex_unlock(&r820t_list_mutex);\n\n\tmemcpy(&fe->ops.tuner_ops, &r820t_tuner_ops,\n\t\t\tsizeof(struct dvb_tuner_ops));\n\n\treturn fe;\nerr:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\nerr_no_gate:\n\tmutex_unlock(&r820t_list_mutex);\n\n\tpr_info(\"%s: failed=%d\\n\", __func__, rc);\n\tr820t_release(fe);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(r820t_attach);\n\nMODULE_DESCRIPTION(\"Rafael Micro r820t silicon tuner driver\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}