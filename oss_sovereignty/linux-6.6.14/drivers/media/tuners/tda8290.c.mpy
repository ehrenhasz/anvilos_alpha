{
  "module_name": "tda8290.c",
  "hash_id": "b7376eac34a3f9d9dee54cbf6aa761d742a4cede42459b3769041c15afed1e49",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/tda8290.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/videodev2.h>\n#include \"tuner-i2c.h\"\n#include \"tda8290.h\"\n#include \"tda827x.h\"\n#include \"tda18271.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable verbose debug messages\");\n\nstatic int deemphasis_50;\nmodule_param(deemphasis_50, int, 0644);\nMODULE_PARM_DESC(deemphasis_50, \"0 - 75us deemphasis; 1 - 50us deemphasis\");\n\n \n\nstruct tda8290_priv {\n\tstruct tuner_i2c_props i2c_props;\n\n\tunsigned char tda8290_easy_mode;\n\n\tunsigned char tda827x_addr;\n\n\tunsigned char ver;\n#define TDA8290   1\n#define TDA8295   2\n#define TDA8275   4\n#define TDA8275A  8\n#define TDA18271 16\n\n\tstruct tda827x_config cfg;\n\tstruct tda18271_std_map *tda18271_std_map;\n};\n\n \n\nstatic int tda8290_i2c_bridge(struct dvb_frontend *fe, int close)\n{\n\tstruct tda8290_priv *priv = fe->analog_demod_priv;\n\n\tstatic unsigned char  enable[2] = { 0x21, 0xC0 };\n\tstatic unsigned char disable[2] = { 0x21, 0x00 };\n\tunsigned char *msg;\n\n\tif (close) {\n\t\tmsg = enable;\n\t\ttuner_i2c_xfer_send(&priv->i2c_props, msg, 2);\n\t\t \n\t\tmsleep(20);\n\t} else {\n\t\tmsg = disable;\n\t\ttuner_i2c_xfer_send(&priv->i2c_props, msg, 2);\n\t}\n\n\treturn 0;\n}\n\nstatic int tda8295_i2c_bridge(struct dvb_frontend *fe, int close)\n{\n\tstruct tda8290_priv *priv = fe->analog_demod_priv;\n\n\tstatic unsigned char  enable[2] = { 0x45, 0xc1 };\n\tstatic unsigned char disable[2] = { 0x46, 0x00 };\n\tstatic unsigned char buf[3] = { 0x45, 0x01, 0x00 };\n\tunsigned char *msg;\n\n\tif (close) {\n\t\tmsg = enable;\n\t\ttuner_i2c_xfer_send(&priv->i2c_props, msg, 2);\n\t\t \n\t\tmsleep(20);\n\t} else {\n\t\tmsg = disable;\n\t\ttuner_i2c_xfer_send_recv(&priv->i2c_props, msg, 1, &msg[1], 1);\n\n\t\tbuf[2] = msg[1];\n\t\tbuf[2] &= ~0x04;\n\t\ttuner_i2c_xfer_send(&priv->i2c_props, buf, 3);\n\t\tmsleep(5);\n\n\t\tmsg[1] |= 0x04;\n\t\ttuner_i2c_xfer_send(&priv->i2c_props, msg, 2);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void set_audio(struct dvb_frontend *fe,\n\t\t      struct analog_parameters *params)\n{\n\tstruct tda8290_priv *priv = fe->analog_demod_priv;\n\tchar* mode;\n\n\tif (params->std & V4L2_STD_MN) {\n\t\tpriv->tda8290_easy_mode = 0x01;\n\t\tmode = \"MN\";\n\t} else if (params->std & V4L2_STD_B) {\n\t\tpriv->tda8290_easy_mode = 0x02;\n\t\tmode = \"B\";\n\t} else if (params->std & V4L2_STD_GH) {\n\t\tpriv->tda8290_easy_mode = 0x04;\n\t\tmode = \"GH\";\n\t} else if (params->std & V4L2_STD_PAL_I) {\n\t\tpriv->tda8290_easy_mode = 0x08;\n\t\tmode = \"I\";\n\t} else if (params->std & V4L2_STD_DK) {\n\t\tpriv->tda8290_easy_mode = 0x10;\n\t\tmode = \"DK\";\n\t} else if (params->std & V4L2_STD_SECAM_L) {\n\t\tpriv->tda8290_easy_mode = 0x20;\n\t\tmode = \"L\";\n\t} else if (params->std & V4L2_STD_SECAM_LC) {\n\t\tpriv->tda8290_easy_mode = 0x40;\n\t\tmode = \"LC\";\n\t} else {\n\t\tpriv->tda8290_easy_mode = 0x10;\n\t\tmode = \"xx\";\n\t}\n\n\tif (params->mode == V4L2_TUNER_RADIO) {\n\t\t \n\t\tpriv->tda8290_easy_mode = (priv->ver & TDA8295) ? 0x80 : 0x01;\n\t\ttuner_dbg(\"setting to radio FM\\n\");\n\t} else {\n\t\ttuner_dbg(\"setting tda829x to system %s\\n\", mode);\n\t}\n}\n\nstatic struct {\n\tunsigned char seq[2];\n} fm_mode[] = {\n\t{ { 0x01, 0x81} },\t \n\t{ { 0x03, 0x48} },\t \n\t{ { 0x04, 0x04} },\t \n\t{ { 0x05, 0x04} },\t \n\t{ { 0x06, 0x10} },\t \n\n\t{ { 0x07, 0x00} },\t \n\t{ { 0x08, 0x00} },\n\t{ { 0x09, 0x80} },\n\t{ { 0x0a, 0xda} },\n\t{ { 0x0b, 0x4b} },\n\t{ { 0x0c, 0x68} },\n\n\t{ { 0x0d, 0x00} },\t \n\t{ { 0x14, 0x00} },\t \n};\n\nstatic void tda8290_set_params(struct dvb_frontend *fe,\n\t\t\t       struct analog_parameters *params)\n{\n\tstruct tda8290_priv *priv = fe->analog_demod_priv;\n\n\tstatic unsigned char soft_reset[]  = { 0x00, 0x00 };\n\tunsigned char easy_mode[]   = { 0x01, priv->tda8290_easy_mode };\n\tstatic unsigned char expert_mode[] = { 0x01, 0x80 };\n\tstatic unsigned char agc_out_on[]  = { 0x02, 0x00 };\n\tstatic unsigned char gainset_off[] = { 0x28, 0x14 };\n\tstatic unsigned char if_agc_spd[]  = { 0x0f, 0x88 };\n\tstatic unsigned char adc_head_6[]  = { 0x05, 0x04 };\n\tstatic unsigned char adc_head_9[]  = { 0x05, 0x02 };\n\tstatic unsigned char adc_head_12[] = { 0x05, 0x01 };\n\tstatic unsigned char pll_bw_nom[]  = { 0x0d, 0x47 };\n\tstatic unsigned char pll_bw_low[]  = { 0x0d, 0x27 };\n\tstatic unsigned char gainset_2[]   = { 0x28, 0x64 };\n\tstatic unsigned char agc_rst_on[]  = { 0x0e, 0x0b };\n\tstatic unsigned char agc_rst_off[] = { 0x0e, 0x09 };\n\tstatic unsigned char if_agc_set[]  = { 0x0f, 0x81 };\n\tstatic unsigned char addr_adc_sat  = 0x1a;\n\tstatic unsigned char addr_agc_stat = 0x1d;\n\tstatic unsigned char addr_pll_stat = 0x1b;\n\tstatic unsigned char adc_sat = 0, agc_stat = 0,\n\t\t      pll_stat;\n\tint i;\n\n\tset_audio(fe, params);\n\n\tif (priv->cfg.config)\n\t\ttuner_dbg(\"tda827xa config is 0x%02x\\n\", priv->cfg.config);\n\ttuner_i2c_xfer_send(&priv->i2c_props, easy_mode, 2);\n\ttuner_i2c_xfer_send(&priv->i2c_props, agc_out_on, 2);\n\ttuner_i2c_xfer_send(&priv->i2c_props, soft_reset, 2);\n\tmsleep(1);\n\n\tif (params->mode == V4L2_TUNER_RADIO) {\n\t\tunsigned char deemphasis[]  = { 0x13, 1 };\n\n\t\t \n\n\t\tif (deemphasis_50)\n\t\t\tdeemphasis[1] = 2;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(fm_mode); i++)\n\t\t\ttuner_i2c_xfer_send(&priv->i2c_props, fm_mode[i].seq, 2);\n\n\t\ttuner_i2c_xfer_send(&priv->i2c_props, deemphasis, 2);\n\t} else {\n\t\texpert_mode[1] = priv->tda8290_easy_mode + 0x80;\n\t\ttuner_i2c_xfer_send(&priv->i2c_props, expert_mode, 2);\n\t\ttuner_i2c_xfer_send(&priv->i2c_props, gainset_off, 2);\n\t\ttuner_i2c_xfer_send(&priv->i2c_props, if_agc_spd, 2);\n\t\tif (priv->tda8290_easy_mode & 0x60)\n\t\t\ttuner_i2c_xfer_send(&priv->i2c_props, adc_head_9, 2);\n\t\telse\n\t\t\ttuner_i2c_xfer_send(&priv->i2c_props, adc_head_6, 2);\n\t\ttuner_i2c_xfer_send(&priv->i2c_props, pll_bw_nom, 2);\n\t}\n\n\n\tif (fe->ops.analog_ops.i2c_gate_ctrl)\n\t\tfe->ops.analog_ops.i2c_gate_ctrl(fe, 1);\n\n\tif (fe->ops.tuner_ops.set_analog_params)\n\t\tfe->ops.tuner_ops.set_analog_params(fe, params);\n\n\tfor (i = 0; i < 3; i++) {\n\t\ttuner_i2c_xfer_send_recv(&priv->i2c_props,\n\t\t\t\t\t &addr_pll_stat, 1, &pll_stat, 1);\n\t\tif (pll_stat & 0x80) {\n\t\t\ttuner_i2c_xfer_send_recv(&priv->i2c_props,\n\t\t\t\t\t\t &addr_adc_sat, 1,\n\t\t\t\t\t\t &adc_sat, 1);\n\t\t\ttuner_i2c_xfer_send_recv(&priv->i2c_props,\n\t\t\t\t\t\t &addr_agc_stat, 1,\n\t\t\t\t\t\t &agc_stat, 1);\n\t\t\ttuner_dbg(\"tda8290 is locked, AGC: %d\\n\", agc_stat);\n\t\t\tbreak;\n\t\t} else {\n\t\t\ttuner_dbg(\"tda8290 not locked, no signal?\\n\");\n\t\t\tmsleep(100);\n\t\t}\n\t}\n\t \n\tif ((agc_stat > 115) || (!(pll_stat & 0x80) && (adc_sat < 20))) {\n\t\ttuner_dbg(\"adjust gain, step 1. Agc: %d, ADC stat: %d, lock: %d\\n\",\n\t\t\t   agc_stat, adc_sat, pll_stat & 0x80);\n\t\ttuner_i2c_xfer_send(&priv->i2c_props, gainset_2, 2);\n\t\tmsleep(100);\n\t\ttuner_i2c_xfer_send_recv(&priv->i2c_props,\n\t\t\t\t\t &addr_agc_stat, 1, &agc_stat, 1);\n\t\ttuner_i2c_xfer_send_recv(&priv->i2c_props,\n\t\t\t\t\t &addr_pll_stat, 1, &pll_stat, 1);\n\t\tif ((agc_stat > 115) || !(pll_stat & 0x80)) {\n\t\t\ttuner_dbg(\"adjust gain, step 2. Agc: %d, lock: %d\\n\",\n\t\t\t\t   agc_stat, pll_stat & 0x80);\n\t\t\tif (priv->cfg.agcf)\n\t\t\t\tpriv->cfg.agcf(fe);\n\t\t\tmsleep(100);\n\t\t\ttuner_i2c_xfer_send_recv(&priv->i2c_props,\n\t\t\t\t\t\t &addr_agc_stat, 1,\n\t\t\t\t\t\t &agc_stat, 1);\n\t\t\ttuner_i2c_xfer_send_recv(&priv->i2c_props,\n\t\t\t\t\t\t &addr_pll_stat, 1,\n\t\t\t\t\t\t &pll_stat, 1);\n\t\t\tif((agc_stat > 115) || !(pll_stat & 0x80)) {\n\t\t\t\ttuner_dbg(\"adjust gain, step 3. Agc: %d\\n\", agc_stat);\n\t\t\t\ttuner_i2c_xfer_send(&priv->i2c_props, adc_head_12, 2);\n\t\t\t\ttuner_i2c_xfer_send(&priv->i2c_props, pll_bw_low, 2);\n\t\t\t\tmsleep(100);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif(priv->tda8290_easy_mode & 0x60) {\n\t\ttuner_i2c_xfer_send_recv(&priv->i2c_props,\n\t\t\t\t\t &addr_adc_sat, 1,\n\t\t\t\t\t &adc_sat, 1);\n\t\ttuner_i2c_xfer_send_recv(&priv->i2c_props,\n\t\t\t\t\t &addr_pll_stat, 1,\n\t\t\t\t\t &pll_stat, 1);\n\t\tif ((adc_sat > 20) || !(pll_stat & 0x80)) {\n\t\t\ttuner_dbg(\"trying to resolve SECAM L deadlock\\n\");\n\t\t\ttuner_i2c_xfer_send(&priv->i2c_props, agc_rst_on, 2);\n\t\t\tmsleep(40);\n\t\t\ttuner_i2c_xfer_send(&priv->i2c_props, agc_rst_off, 2);\n\t\t}\n\t}\n\n\tif (fe->ops.analog_ops.i2c_gate_ctrl)\n\t\tfe->ops.analog_ops.i2c_gate_ctrl(fe, 0);\n\ttuner_i2c_xfer_send(&priv->i2c_props, if_agc_set, 2);\n}\n\n \n\nstatic void tda8295_power(struct dvb_frontend *fe, int enable)\n{\n\tstruct tda8290_priv *priv = fe->analog_demod_priv;\n\tunsigned char buf[] = { 0x30, 0x00 };  \n\n\ttuner_i2c_xfer_send_recv(&priv->i2c_props, &buf[0], 1, &buf[1], 1);\n\n\tif (enable)\n\t\tbuf[1] = 0x01;\n\telse\n\t\tbuf[1] = 0x03;\n\n\ttuner_i2c_xfer_send(&priv->i2c_props, buf, 2);\n}\n\nstatic void tda8295_set_easy_mode(struct dvb_frontend *fe, int enable)\n{\n\tstruct tda8290_priv *priv = fe->analog_demod_priv;\n\tunsigned char buf[] = { 0x01, 0x00 };\n\n\ttuner_i2c_xfer_send_recv(&priv->i2c_props, &buf[0], 1, &buf[1], 1);\n\n\tif (enable)\n\t\tbuf[1] = 0x01;  \n\telse\n\t\tbuf[1] = 0x00;  \n\n\ttuner_i2c_xfer_send(&priv->i2c_props, buf, 2);\n}\n\nstatic void tda8295_set_video_std(struct dvb_frontend *fe)\n{\n\tstruct tda8290_priv *priv = fe->analog_demod_priv;\n\tunsigned char buf[] = { 0x00, priv->tda8290_easy_mode };\n\n\ttuner_i2c_xfer_send(&priv->i2c_props, buf, 2);\n\n\ttda8295_set_easy_mode(fe, 1);\n\tmsleep(20);\n\ttda8295_set_easy_mode(fe, 0);\n}\n\n \n\nstatic void tda8295_agc1_out(struct dvb_frontend *fe, int enable)\n{\n\tstruct tda8290_priv *priv = fe->analog_demod_priv;\n\tunsigned char buf[] = { 0x02, 0x00 };  \n\n\ttuner_i2c_xfer_send_recv(&priv->i2c_props, &buf[0], 1, &buf[1], 1);\n\n\tif (enable)\n\t\tbuf[1] &= ~0x40;\n\telse\n\t\tbuf[1] |= 0x40;\n\n\ttuner_i2c_xfer_send(&priv->i2c_props, buf, 2);\n}\n\nstatic void tda8295_agc2_out(struct dvb_frontend *fe, int enable)\n{\n\tstruct tda8290_priv *priv = fe->analog_demod_priv;\n\tunsigned char set_gpio_cf[]    = { 0x44, 0x00 };\n\tunsigned char set_gpio_val[]   = { 0x46, 0x00 };\n\n\ttuner_i2c_xfer_send_recv(&priv->i2c_props,\n\t\t\t\t &set_gpio_cf[0], 1, &set_gpio_cf[1], 1);\n\ttuner_i2c_xfer_send_recv(&priv->i2c_props,\n\t\t\t\t &set_gpio_val[0], 1, &set_gpio_val[1], 1);\n\n\tset_gpio_cf[1] &= 0xf0;  \n\n\tif (enable) {\n\t\tset_gpio_cf[1]  |= 0x01;  \n\t\tset_gpio_val[1] &= 0xfe;  \n\t}\n\ttuner_i2c_xfer_send(&priv->i2c_props, set_gpio_cf, 2);\n\ttuner_i2c_xfer_send(&priv->i2c_props, set_gpio_val, 2);\n}\n\nstatic int tda8295_has_signal(struct dvb_frontend *fe, u16 *signal)\n{\n\tstruct tda8290_priv *priv = fe->analog_demod_priv;\n\n\tunsigned char hvpll_stat = 0x26;\n\tunsigned char ret;\n\n\ttuner_i2c_xfer_send_recv(&priv->i2c_props, &hvpll_stat, 1, &ret, 1);\n\t*signal = (ret & 0x01) ? 65535 : 0;\n\treturn 0;\n}\n\n \n\nstatic void tda8295_set_params(struct dvb_frontend *fe,\n\t\t\t       struct analog_parameters *params)\n{\n\tstruct tda8290_priv *priv = fe->analog_demod_priv;\n\tu16 signal = 0;\n\tunsigned char blanking_mode[]     = { 0x1d, 0x00 };\n\n\tset_audio(fe, params);\n\n\ttuner_dbg(\"%s: freq = %d\\n\", __func__, params->frequency);\n\n\ttda8295_power(fe, 1);\n\ttda8295_agc1_out(fe, 1);\n\n\ttuner_i2c_xfer_send_recv(&priv->i2c_props,\n\t\t\t\t &blanking_mode[0], 1, &blanking_mode[1], 1);\n\n\ttda8295_set_video_std(fe);\n\n\tblanking_mode[1] = 0x03;\n\ttuner_i2c_xfer_send(&priv->i2c_props, blanking_mode, 2);\n\tmsleep(20);\n\n\tif (fe->ops.analog_ops.i2c_gate_ctrl)\n\t\tfe->ops.analog_ops.i2c_gate_ctrl(fe, 1);\n\n\tif (fe->ops.tuner_ops.set_analog_params)\n\t\tfe->ops.tuner_ops.set_analog_params(fe, params);\n\n\tif (priv->cfg.agcf)\n\t\tpriv->cfg.agcf(fe);\n\n\ttda8295_has_signal(fe, &signal);\n\tif (signal)\n\t\ttuner_dbg(\"tda8295 is locked\\n\");\n\telse\n\t\ttuner_dbg(\"tda8295 not locked, no signal?\\n\");\n\n\tif (fe->ops.analog_ops.i2c_gate_ctrl)\n\t\tfe->ops.analog_ops.i2c_gate_ctrl(fe, 0);\n}\n\n \n\nstatic int tda8290_has_signal(struct dvb_frontend *fe, u16 *signal)\n{\n\tstruct tda8290_priv *priv = fe->analog_demod_priv;\n\n\tunsigned char i2c_get_afc[1] = { 0x1B };\n\tunsigned char afc = 0;\n\n\ttuner_i2c_xfer_send_recv(&priv->i2c_props,\n\t\t\t\t i2c_get_afc, ARRAY_SIZE(i2c_get_afc), &afc, 1);\n\t*signal = (afc & 0x80) ? 65535 : 0;\n\treturn 0;\n}\n\n \n\nstatic void tda8290_standby(struct dvb_frontend *fe)\n{\n\tstruct tda8290_priv *priv = fe->analog_demod_priv;\n\n\tstatic unsigned char cb1[] = { 0x30, 0xD0 };\n\tstatic unsigned char tda8290_standby[] = { 0x00, 0x02 };\n\tstatic unsigned char tda8290_agc_tri[] = { 0x02, 0x20 };\n\tstruct i2c_msg msg = {.addr = priv->tda827x_addr, .flags=0, .buf=cb1, .len = 2};\n\n\tif (fe->ops.analog_ops.i2c_gate_ctrl)\n\t\tfe->ops.analog_ops.i2c_gate_ctrl(fe, 1);\n\tif (priv->ver & TDA8275A)\n\t\tcb1[1] = 0x90;\n\ti2c_transfer(priv->i2c_props.adap, &msg, 1);\n\tif (fe->ops.analog_ops.i2c_gate_ctrl)\n\t\tfe->ops.analog_ops.i2c_gate_ctrl(fe, 0);\n\ttuner_i2c_xfer_send(&priv->i2c_props, tda8290_agc_tri, 2);\n\ttuner_i2c_xfer_send(&priv->i2c_props, tda8290_standby, 2);\n}\n\nstatic void tda8295_standby(struct dvb_frontend *fe)\n{\n\ttda8295_agc1_out(fe, 0);  \n\n\ttda8295_power(fe, 0);\n}\n\nstatic void tda8290_init_if(struct dvb_frontend *fe)\n{\n\tstruct tda8290_priv *priv = fe->analog_demod_priv;\n\n\tstatic unsigned char set_VS[] = { 0x30, 0x6F };\n\tstatic unsigned char set_GP00_CF[] = { 0x20, 0x01 };\n\tstatic unsigned char set_GP01_CF[] = { 0x20, 0x0B };\n\n\tif ((priv->cfg.config == TDA8290_LNA_GP0_HIGH_ON) ||\n\t    (priv->cfg.config == TDA8290_LNA_GP0_HIGH_OFF))\n\t\ttuner_i2c_xfer_send(&priv->i2c_props, set_GP00_CF, 2);\n\telse\n\t\ttuner_i2c_xfer_send(&priv->i2c_props, set_GP01_CF, 2);\n\ttuner_i2c_xfer_send(&priv->i2c_props, set_VS, 2);\n}\n\nstatic void tda8295_init_if(struct dvb_frontend *fe)\n{\n\tstruct tda8290_priv *priv = fe->analog_demod_priv;\n\n\tstatic unsigned char set_adc_ctl[]       = { 0x33, 0x14 };\n\tstatic unsigned char set_adc_ctl2[]      = { 0x34, 0x00 };\n\tstatic unsigned char set_pll_reg6[]      = { 0x3e, 0x63 };\n\tstatic unsigned char set_pll_reg0[]      = { 0x38, 0x23 };\n\tstatic unsigned char set_pll_reg7[]      = { 0x3f, 0x01 };\n\tstatic unsigned char set_pll_reg10[]     = { 0x42, 0x61 };\n\tstatic unsigned char set_gpio_reg0[]     = { 0x44, 0x0b };\n\n\ttda8295_power(fe, 1);\n\n\ttda8295_set_easy_mode(fe, 0);\n\ttda8295_set_video_std(fe);\n\n\ttuner_i2c_xfer_send(&priv->i2c_props, set_adc_ctl, 2);\n\ttuner_i2c_xfer_send(&priv->i2c_props, set_adc_ctl2, 2);\n\ttuner_i2c_xfer_send(&priv->i2c_props, set_pll_reg6, 2);\n\ttuner_i2c_xfer_send(&priv->i2c_props, set_pll_reg0, 2);\n\ttuner_i2c_xfer_send(&priv->i2c_props, set_pll_reg7, 2);\n\ttuner_i2c_xfer_send(&priv->i2c_props, set_pll_reg10, 2);\n\ttuner_i2c_xfer_send(&priv->i2c_props, set_gpio_reg0, 2);\n\n\ttda8295_agc1_out(fe, 0);\n\ttda8295_agc2_out(fe, 0);\n}\n\nstatic void tda8290_init_tuner(struct dvb_frontend *fe)\n{\n\tstruct tda8290_priv *priv = fe->analog_demod_priv;\n\tstatic unsigned char tda8275_init[]  =\n\t\t{ 0x00, 0x00, 0x00, 0x40, 0xdC, 0x04, 0xAf,\n\t\t  0x3F, 0x2A, 0x04, 0xFF, 0x00, 0x00, 0x40 };\n\tstatic unsigned char tda8275a_init[] =\n\t\t { 0x00, 0x00, 0x00, 0x00, 0xdC, 0x05, 0x8b,\n\t\t   0x0c, 0x04, 0x20, 0xFF, 0x00, 0x00, 0x4b };\n\tstruct i2c_msg msg = {.addr = priv->tda827x_addr, .flags=0,\n\t\t\t      .buf=tda8275_init, .len = 14};\n\tif (priv->ver & TDA8275A)\n\t\tmsg.buf = tda8275a_init;\n\n\tif (fe->ops.analog_ops.i2c_gate_ctrl)\n\t\tfe->ops.analog_ops.i2c_gate_ctrl(fe, 1);\n\ti2c_transfer(priv->i2c_props.adap, &msg, 1);\n\tif (fe->ops.analog_ops.i2c_gate_ctrl)\n\t\tfe->ops.analog_ops.i2c_gate_ctrl(fe, 0);\n}\n\n \n\nstatic void tda829x_release(struct dvb_frontend *fe)\n{\n\tstruct tda8290_priv *priv = fe->analog_demod_priv;\n\n\t \n\tif (priv->ver & (TDA18271 | TDA8275 | TDA8275A))\n\t\tif (fe->ops.tuner_ops.release)\n\t\t\tfe->ops.tuner_ops.release(fe);\n\n\tkfree(fe->analog_demod_priv);\n\tfe->analog_demod_priv = NULL;\n}\n\nstatic struct tda18271_config tda829x_tda18271_config = {\n\t.gate    = TDA18271_GATE_ANALOG,\n};\n\nstatic int tda829x_find_tuner(struct dvb_frontend *fe)\n{\n\tstruct tda8290_priv *priv = fe->analog_demod_priv;\n\tint i, ret, tuners_found;\n\tu32 tuner_addrs;\n\tu8 data;\n\tstruct i2c_msg msg = { .flags = I2C_M_RD, .buf = &data, .len = 1 };\n\n\tif (fe->ops.analog_ops.i2c_gate_ctrl)\n\t\tfe->ops.analog_ops.i2c_gate_ctrl(fe, 1);\n\n\t \n\ttuners_found = 0;\n\ttuner_addrs = 0;\n\tfor (i = 0x60; i <= 0x63; i++) {\n\t\tmsg.addr = i;\n\t\tret = i2c_transfer(priv->i2c_props.adap, &msg, 1);\n\t\tif (ret == 1) {\n\t\t\ttuners_found++;\n\t\t\ttuner_addrs = (tuner_addrs << 8) + i;\n\t\t}\n\t}\n\t \n\n\tif (fe->ops.analog_ops.i2c_gate_ctrl)\n\t\tfe->ops.analog_ops.i2c_gate_ctrl(fe, 0);\n\n\tif (tuners_found > 1)\n\t\tfor (i = 0; i < tuners_found; i++) {\n\t\t\tmsg.addr = tuner_addrs  & 0xff;\n\t\t\tret = i2c_transfer(priv->i2c_props.adap, &msg, 1);\n\t\t\tif (ret == 1)\n\t\t\t\ttuner_addrs = tuner_addrs >> 8;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\tif (tuner_addrs == 0) {\n\t\ttuner_addrs = 0x60;\n\t\ttuner_info(\"could not clearly identify tuner address, defaulting to %x\\n\",\n\t\t\t   tuner_addrs);\n\t} else {\n\t\ttuner_addrs = tuner_addrs & 0xff;\n\t\ttuner_info(\"setting tuner address to %x\\n\", tuner_addrs);\n\t}\n\tpriv->tda827x_addr = tuner_addrs;\n\tmsg.addr = tuner_addrs;\n\n\tif (fe->ops.analog_ops.i2c_gate_ctrl)\n\t\tfe->ops.analog_ops.i2c_gate_ctrl(fe, 1);\n\tret = i2c_transfer(priv->i2c_props.adap, &msg, 1);\n\n\tif (ret != 1) {\n\t\ttuner_warn(\"tuner access failed!\\n\");\n\t\tif (fe->ops.analog_ops.i2c_gate_ctrl)\n\t\t\tfe->ops.analog_ops.i2c_gate_ctrl(fe, 0);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tif ((data == 0x83) || (data == 0x84)) {\n\t\tpriv->ver |= TDA18271;\n\t\ttda829x_tda18271_config.config = priv->cfg.config;\n\t\ttda829x_tda18271_config.std_map = priv->tda18271_std_map;\n\t\tdvb_attach(tda18271_attach, fe, priv->tda827x_addr,\n\t\t\t   priv->i2c_props.adap, &tda829x_tda18271_config);\n\t} else {\n\t\tif ((data & 0x3c) == 0)\n\t\t\tpriv->ver |= TDA8275;\n\t\telse\n\t\t\tpriv->ver |= TDA8275A;\n\n\t\tdvb_attach(tda827x_attach, fe, priv->tda827x_addr,\n\t\t\t   priv->i2c_props.adap, &priv->cfg);\n\t\tpriv->cfg.switch_addr = priv->i2c_props.addr;\n\t}\n\tif (fe->ops.tuner_ops.init)\n\t\tfe->ops.tuner_ops.init(fe);\n\n\tif (fe->ops.tuner_ops.sleep)\n\t\tfe->ops.tuner_ops.sleep(fe);\n\n\tif (fe->ops.analog_ops.i2c_gate_ctrl)\n\t\tfe->ops.analog_ops.i2c_gate_ctrl(fe, 0);\n\n\treturn 0;\n}\n\nstatic int tda8290_probe(struct tuner_i2c_props *i2c_props)\n{\n#define TDA8290_ID 0x89\n\tu8 reg = 0x1f, id;\n\tstruct i2c_msg msg_read[] = {\n\t\t{ .addr = i2c_props->addr, .flags = 0, .len = 1, .buf = &reg },\n\t\t{ .addr = i2c_props->addr, .flags = I2C_M_RD, .len = 1, .buf = &id },\n\t};\n\n\t \n\tif (i2c_transfer(i2c_props->adap, msg_read, 2) != 2) {\n\t\tprintk(KERN_WARNING \"%s: couldn't read register 0x%02x\\n\",\n\t\t\t       __func__, reg);\n\t\treturn -ENODEV;\n\t}\n\n\tif (id == TDA8290_ID) {\n\t\tif (debug)\n\t\t\tprintk(KERN_DEBUG \"%s: tda8290 detected @ %d-%04x\\n\",\n\t\t\t       __func__, i2c_adapter_id(i2c_props->adap),\n\t\t\t       i2c_props->addr);\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\nstatic int tda8295_probe(struct tuner_i2c_props *i2c_props)\n{\n#define TDA8295_ID 0x8a\n#define TDA8295C2_ID 0x8b\n\tu8 reg = 0x2f, id;\n\tstruct i2c_msg msg_read[] = {\n\t\t{ .addr = i2c_props->addr, .flags = 0, .len = 1, .buf = &reg },\n\t\t{ .addr = i2c_props->addr, .flags = I2C_M_RD, .len = 1, .buf = &id },\n\t};\n\n\t \n\tif (i2c_transfer(i2c_props->adap, msg_read, 2) != 2) {\n\t\tprintk(KERN_WARNING \"%s: couldn't read register 0x%02x\\n\",\n\t\t\t       __func__, reg);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((id & 0xfe) == TDA8295_ID) {\n\t\tif (debug)\n\t\t\tprintk(KERN_DEBUG \"%s: %s detected @ %d-%04x\\n\",\n\t\t\t       __func__, (id == TDA8295_ID) ?\n\t\t\t       \"tda8295c1\" : \"tda8295c2\",\n\t\t\t       i2c_adapter_id(i2c_props->adap),\n\t\t\t       i2c_props->addr);\n\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic const struct analog_demod_ops tda8290_ops = {\n\t.set_params     = tda8290_set_params,\n\t.has_signal     = tda8290_has_signal,\n\t.standby        = tda8290_standby,\n\t.release        = tda829x_release,\n\t.i2c_gate_ctrl  = tda8290_i2c_bridge,\n};\n\nstatic const struct analog_demod_ops tda8295_ops = {\n\t.set_params     = tda8295_set_params,\n\t.has_signal     = tda8295_has_signal,\n\t.standby        = tda8295_standby,\n\t.release        = tda829x_release,\n\t.i2c_gate_ctrl  = tda8295_i2c_bridge,\n};\n\nstruct dvb_frontend *tda829x_attach(struct dvb_frontend *fe,\n\t\t\t\t    struct i2c_adapter *i2c_adap, u8 i2c_addr,\n\t\t\t\t    struct tda829x_config *cfg)\n{\n\tstruct tda8290_priv *priv = NULL;\n\tchar *name;\n\n\tpriv = kzalloc(sizeof(struct tda8290_priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn NULL;\n\tfe->analog_demod_priv = priv;\n\n\tpriv->i2c_props.addr     = i2c_addr;\n\tpriv->i2c_props.adap     = i2c_adap;\n\tpriv->i2c_props.name     = \"tda829x\";\n\tif (cfg) {\n\t\tpriv->cfg.config = cfg->lna_cfg;\n\t\tpriv->tda18271_std_map = cfg->tda18271_std_map;\n\t}\n\n\tif (tda8290_probe(&priv->i2c_props) == 0) {\n\t\tpriv->ver = TDA8290;\n\t\tmemcpy(&fe->ops.analog_ops, &tda8290_ops,\n\t\t       sizeof(struct analog_demod_ops));\n\t}\n\n\tif (tda8295_probe(&priv->i2c_props) == 0) {\n\t\tpriv->ver = TDA8295;\n\t\tmemcpy(&fe->ops.analog_ops, &tda8295_ops,\n\t\t       sizeof(struct analog_demod_ops));\n\t}\n\n\tif (cfg && cfg->no_i2c_gate)\n\t\tfe->ops.analog_ops.i2c_gate_ctrl = NULL;\n\n\tif (!(cfg) || (TDA829X_PROBE_TUNER == cfg->probe_tuner)) {\n\t\ttda8295_power(fe, 1);\n\t\tif (tda829x_find_tuner(fe) < 0)\n\t\t\tgoto fail;\n\t}\n\n\tswitch (priv->ver) {\n\tcase TDA8290:\n\t\tname = \"tda8290\";\n\t\tbreak;\n\tcase TDA8295:\n\t\tname = \"tda8295\";\n\t\tbreak;\n\tcase TDA8290 | TDA8275:\n\t\tname = \"tda8290+75\";\n\t\tbreak;\n\tcase TDA8295 | TDA8275:\n\t\tname = \"tda8295+75\";\n\t\tbreak;\n\tcase TDA8290 | TDA8275A:\n\t\tname = \"tda8290+75a\";\n\t\tbreak;\n\tcase TDA8295 | TDA8275A:\n\t\tname = \"tda8295+75a\";\n\t\tbreak;\n\tcase TDA8290 | TDA18271:\n\t\tname = \"tda8290+18271\";\n\t\tbreak;\n\tcase TDA8295 | TDA18271:\n\t\tname = \"tda8295+18271\";\n\t\tbreak;\n\tdefault:\n\t\tgoto fail;\n\t}\n\ttuner_info(\"type set to %s\\n\", name);\n\n\tfe->ops.analog_ops.info.name = name;\n\n\tif (priv->ver & TDA8290) {\n\t\tif (priv->ver & (TDA8275 | TDA8275A))\n\t\t\ttda8290_init_tuner(fe);\n\t\ttda8290_init_if(fe);\n\t} else if (priv->ver & TDA8295)\n\t\ttda8295_init_if(fe);\n\n\treturn fe;\n\nfail:\n\tmemset(&fe->ops.analog_ops, 0, sizeof(struct analog_demod_ops));\n\n\ttda829x_release(fe);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(tda829x_attach);\n\nint tda829x_probe(struct i2c_adapter *i2c_adap, u8 i2c_addr)\n{\n\tstruct tuner_i2c_props i2c_props = {\n\t\t.adap = i2c_adap,\n\t\t.addr = i2c_addr,\n\t};\n\n\tstatic unsigned char soft_reset[]   = { 0x00, 0x00 };\n\tstatic unsigned char easy_mode_b[]  = { 0x01, 0x02 };\n\tstatic unsigned char easy_mode_g[]  = { 0x01, 0x04 };\n\tstatic unsigned char restore_9886[] = { 0x00, 0xd6, 0x30 };\n\tstatic unsigned char addr_dto_lsb = 0x07;\n\tunsigned char data;\n#define PROBE_BUFFER_SIZE 8\n\tunsigned char buf[PROBE_BUFFER_SIZE];\n\tint i;\n\n\t \n\ttuner_i2c_xfer_send_recv(&i2c_props,\n\t\t\t\t soft_reset, 1, buf, PROBE_BUFFER_SIZE);\n\tfor (i = 1; i < PROBE_BUFFER_SIZE; i++) {\n\t\tif (buf[i] != buf[0])\n\t\t\tbreak;\n\t}\n\n\t \n\tif (i == PROBE_BUFFER_SIZE)\n\t\treturn -ENODEV;\n\n\tif ((tda8290_probe(&i2c_props) == 0) ||\n\t    (tda8295_probe(&i2c_props) == 0))\n\t\treturn 0;\n\n\t \n\ttuner_i2c_xfer_send(&i2c_props, easy_mode_b, 2);\n\ttuner_i2c_xfer_send(&i2c_props, soft_reset, 2);\n\ttuner_i2c_xfer_send_recv(&i2c_props, &addr_dto_lsb, 1, &data, 1);\n\tif (data == 0) {\n\t\ttuner_i2c_xfer_send(&i2c_props, easy_mode_g, 2);\n\t\ttuner_i2c_xfer_send(&i2c_props, soft_reset, 2);\n\t\ttuner_i2c_xfer_send_recv(&i2c_props,\n\t\t\t\t\t &addr_dto_lsb, 1, &data, 1);\n\t\tif (data == 0x7b) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\ttuner_i2c_xfer_send(&i2c_props, restore_9886, 3);\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(tda829x_probe);\n\nMODULE_DESCRIPTION(\"Philips/NXP TDA8290/TDA8295 analog IF demodulator driver\");\nMODULE_AUTHOR(\"Gerd Knorr, Hartmut Hackmann, Michael Krufky\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}