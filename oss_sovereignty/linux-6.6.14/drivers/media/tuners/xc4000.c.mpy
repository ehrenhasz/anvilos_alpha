{
  "module_name": "xc4000.c",
  "hash_id": "792bbfaaaedc82e1a9fa18e09f14e5bd478f76604e16141ea0748427b8ddc1ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/xc4000.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/videodev2.h>\n#include <linux/delay.h>\n#include <linux/dvb/frontend.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n#include <asm/unaligned.h>\n\n#include <media/dvb_frontend.h>\n\n#include \"xc4000.h\"\n#include \"tuner-i2c.h\"\n#include \"xc2028-types.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Debugging level (0 to 2, default: 0 (off)).\");\n\nstatic int no_poweroff;\nmodule_param(no_poweroff, int, 0644);\nMODULE_PARM_DESC(no_poweroff, \"Power management (1: disabled, 2: enabled, 0 (default): use device-specific default mode).\");\n\nstatic int audio_std;\nmodule_param(audio_std, int, 0644);\nMODULE_PARM_DESC(audio_std, \"Audio standard. XC4000 audio decoder explicitly needs to know what audio standard is needed for some video standards with audio A2 or NICAM. The valid settings are a sum of:\\n\"\n\t\" 1: use NICAM/B or A2/B instead of NICAM/A or A2/A\\n\"\n\t\" 2: use A2 instead of NICAM or BTSC\\n\"\n\t\" 4: use SECAM/K3 instead of K1\\n\"\n\t\" 8: use PAL-D/K audio for SECAM-D/K\\n\"\n\t\"16: use FM radio input 1 instead of input 2\\n\"\n\t\"32: use mono audio (the lower three bits are ignored)\");\n\nstatic char firmware_name[30];\nmodule_param_string(firmware_name, firmware_name, sizeof(firmware_name), 0);\nMODULE_PARM_DESC(firmware_name, \"Firmware file name. Allows overriding the default firmware name.\");\n\nstatic DEFINE_MUTEX(xc4000_list_mutex);\nstatic LIST_HEAD(hybrid_tuner_instance_list);\n\n#define dprintk(level, fmt, arg...) if (debug >= level) \\\n\tprintk(KERN_INFO \"%s: \" fmt, \"xc4000\", ## arg)\n\n \nstruct firmware_description {\n\tunsigned int  type;\n\tv4l2_std_id   id;\n\t__u16         int_freq;\n\tunsigned char *ptr;\n\tunsigned int  size;\n};\n\nstruct firmware_properties {\n\tunsigned int\ttype;\n\tv4l2_std_id\tid;\n\tv4l2_std_id\tstd_req;\n\t__u16\t\tint_freq;\n\tunsigned int\tscode_table;\n\tint\t\tscode_nr;\n};\n\nstruct xc4000_priv {\n\tstruct tuner_i2c_props i2c_props;\n\tstruct list_head hybrid_tuner_instance_list;\n\tstruct firmware_description *firm;\n\tint\tfirm_size;\n\tu32\tif_khz;\n\tu32\tfreq_hz, freq_offset;\n\tu32\tbandwidth;\n\tu8\tvideo_standard;\n\tu8\trf_mode;\n\tu8\tdefault_pm;\n\tu8\tdvb_amplitude;\n\tu8\tset_smoothedcvbs;\n\tu8\tignore_i2c_write_errors;\n\t__u16\tfirm_version;\n\tstruct firmware_properties cur_fw;\n\t__u16\thwmodel;\n\t__u16\thwvers;\n\tstruct mutex\tlock;\n};\n\n#define XC4000_AUDIO_STD_B\t\t 1\n#define XC4000_AUDIO_STD_A2\t\t 2\n#define XC4000_AUDIO_STD_K3\t\t 4\n#define XC4000_AUDIO_STD_L\t\t 8\n#define XC4000_AUDIO_STD_INPUT1\t\t16\n#define XC4000_AUDIO_STD_MONO\t\t32\n\n#define XC4000_DEFAULT_FIRMWARE \"dvb-fe-xc4000-1.4.fw\"\n#define XC4000_DEFAULT_FIRMWARE_NEW \"dvb-fe-xc4000-1.4.1.fw\"\n\n \n#define MAX_TV_STANDARD\t\t\t24\n#define XC_MAX_I2C_WRITE_LENGTH\t\t64\n#define XC_POWERED_DOWN\t\t\t0x80000000U\n\n \n#define XC_RF_MODE_AIR\t\t\t0\n#define XC_RF_MODE_CABLE\t\t1\n\n \n#define XC_PRODUCT_ID_FW_NOT_LOADED\t0x2000\n#define XC_PRODUCT_ID_XC4000\t\t0x0FA0\n#define XC_PRODUCT_ID_XC4100\t\t0x1004\n\n \n#define XREG_INIT         0x00\n#define XREG_VIDEO_MODE   0x01\n#define XREG_AUDIO_MODE   0x02\n#define XREG_RF_FREQ      0x03\n#define XREG_D_CODE       0x04\n#define XREG_DIRECTSITTING_MODE 0x05\n#define XREG_SEEK_MODE    0x06\n#define XREG_POWER_DOWN   0x08\n#define XREG_SIGNALSOURCE 0x0A\n#define XREG_SMOOTHEDCVBS 0x0E\n#define XREG_AMPLITUDE    0x10\n\n \n#define XREG_ADC_ENV      0x00\n#define XREG_QUALITY      0x01\n#define XREG_FRAME_LINES  0x02\n#define XREG_HSYNC_FREQ   0x03\n#define XREG_LOCK         0x04\n#define XREG_FREQ_ERROR   0x05\n#define XREG_SNR          0x06\n#define XREG_VERSION      0x07\n#define XREG_PRODUCT_ID   0x08\n#define XREG_SIGNAL_LEVEL 0x0A\n#define XREG_NOISE_LEVEL  0x0B\n\n \n\nstruct XC_TV_STANDARD {\n\tconst char  *Name;\n\tu16\t    audio_mode;\n\tu16\t    video_mode;\n\tu16\t    int_freq;\n};\n\n \n#define XC4000_MN_NTSC_PAL_BTSC\t\t0\n#define XC4000_MN_NTSC_PAL_A2\t\t1\n#define XC4000_MN_NTSC_PAL_EIAJ\t\t2\n#define XC4000_MN_NTSC_PAL_Mono\t\t3\n#define XC4000_BG_PAL_A2\t\t4\n#define XC4000_BG_PAL_NICAM\t\t5\n#define XC4000_BG_PAL_MONO\t\t6\n#define XC4000_I_PAL_NICAM\t\t7\n#define XC4000_I_PAL_NICAM_MONO\t\t8\n#define XC4000_DK_PAL_A2\t\t9\n#define XC4000_DK_PAL_NICAM\t\t10\n#define XC4000_DK_PAL_MONO\t\t11\n#define XC4000_DK_SECAM_A2DK1\t\t12\n#define XC4000_DK_SECAM_A2LDK3\t\t13\n#define XC4000_DK_SECAM_A2MONO\t\t14\n#define XC4000_DK_SECAM_NICAM\t\t15\n#define XC4000_L_SECAM_NICAM\t\t16\n#define XC4000_LC_SECAM_NICAM\t\t17\n#define XC4000_DTV6\t\t\t18\n#define XC4000_DTV8\t\t\t19\n#define XC4000_DTV7_8\t\t\t20\n#define XC4000_DTV7\t\t\t21\n#define XC4000_FM_Radio_INPUT2\t\t22\n#define XC4000_FM_Radio_INPUT1\t\t23\n\nstatic struct XC_TV_STANDARD xc4000_standard[MAX_TV_STANDARD] = {\n\t{\"M/N-NTSC/PAL-BTSC\",\t0x0000, 0x80A0, 4500},\n\t{\"M/N-NTSC/PAL-A2\",\t0x0000, 0x80A0, 4600},\n\t{\"M/N-NTSC/PAL-EIAJ\",\t0x0040, 0x80A0, 4500},\n\t{\"M/N-NTSC/PAL-Mono\",\t0x0078, 0x80A0, 4500},\n\t{\"B/G-PAL-A2\",\t\t0x0000, 0x8159, 5640},\n\t{\"B/G-PAL-NICAM\",\t0x0004, 0x8159, 5740},\n\t{\"B/G-PAL-MONO\",\t0x0078, 0x8159, 5500},\n\t{\"I-PAL-NICAM\",\t\t0x0080, 0x8049, 6240},\n\t{\"I-PAL-NICAM-MONO\",\t0x0078, 0x8049, 6000},\n\t{\"D/K-PAL-A2\",\t\t0x0000, 0x8049, 6380},\n\t{\"D/K-PAL-NICAM\",\t0x0080, 0x8049, 6200},\n\t{\"D/K-PAL-MONO\",\t0x0078, 0x8049, 6500},\n\t{\"D/K-SECAM-A2 DK1\",\t0x0000, 0x8049, 6340},\n\t{\"D/K-SECAM-A2 L/DK3\",\t0x0000, 0x8049, 6000},\n\t{\"D/K-SECAM-A2 MONO\",\t0x0078, 0x8049, 6500},\n\t{\"D/K-SECAM-NICAM\",\t0x0080, 0x8049, 6200},\n\t{\"L-SECAM-NICAM\",\t0x8080, 0x0009, 6200},\n\t{\"L'-SECAM-NICAM\",\t0x8080, 0x4009, 6200},\n\t{\"DTV6\",\t\t0x00C0, 0x8002,    0},\n\t{\"DTV8\",\t\t0x00C0, 0x800B,    0},\n\t{\"DTV7/8\",\t\t0x00C0, 0x801B,    0},\n\t{\"DTV7\",\t\t0x00C0, 0x8007,    0},\n\t{\"FM Radio-INPUT2\",\t0x0008, 0x9800, 10700},\n\t{\"FM Radio-INPUT1\",\t0x0008, 0x9000, 10700}\n};\n\nstatic int xc4000_readreg(struct xc4000_priv *priv, u16 reg, u16 *val);\nstatic int xc4000_tuner_reset(struct dvb_frontend *fe);\nstatic void xc_debug_dump(struct xc4000_priv *priv);\n\nstatic int xc_send_i2c_data(struct xc4000_priv *priv, u8 *buf, int len)\n{\n\tstruct i2c_msg msg = { .addr = priv->i2c_props.addr,\n\t\t\t       .flags = 0, .buf = buf, .len = len };\n\tif (i2c_transfer(priv->i2c_props.adap, &msg, 1) != 1) {\n\t\tif (priv->ignore_i2c_write_errors == 0) {\n\t\t\tprintk(KERN_ERR \"xc4000: I2C write failed (len=%i)\\n\",\n\t\t\t       len);\n\t\t\tif (len == 4) {\n\t\t\t\tprintk(KERN_ERR \"bytes %*ph\\n\", 4, buf);\n\t\t\t}\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int xc4000_tuner_reset(struct dvb_frontend *fe)\n{\n\tstruct xc4000_priv *priv = fe->tuner_priv;\n\tint ret;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tif (fe->callback) {\n\t\tret = fe->callback(((fe->dvb) && (fe->dvb->priv)) ?\n\t\t\t\t\t   fe->dvb->priv :\n\t\t\t\t\t   priv->i2c_props.adap->algo_data,\n\t\t\t\t\t   DVB_FRONTEND_COMPONENT_TUNER,\n\t\t\t\t\t   XC4000_TUNER_RESET, 0);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR \"xc4000: reset failed\\n\");\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t} else {\n\t\tprintk(KERN_ERR \"xc4000: no tuner reset callback function, fatal\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int xc_write_reg(struct xc4000_priv *priv, u16 regAddr, u16 i2cData)\n{\n\tu8 buf[4];\n\n\tbuf[0] = (regAddr >> 8) & 0xFF;\n\tbuf[1] = regAddr & 0xFF;\n\tbuf[2] = (i2cData >> 8) & 0xFF;\n\tbuf[3] = i2cData & 0xFF;\n\n\treturn xc_send_i2c_data(priv, buf, 4);\n}\n\nstatic int xc_load_i2c_sequence(struct dvb_frontend *fe, const u8 *i2c_sequence)\n{\n\tstruct xc4000_priv *priv = fe->tuner_priv;\n\n\tint i, nbytes_to_send, result;\n\tunsigned int len, pos, index;\n\tu8 buf[XC_MAX_I2C_WRITE_LENGTH];\n\n\tindex = 0;\n\twhile ((i2c_sequence[index] != 0xFF) ||\n\t\t(i2c_sequence[index + 1] != 0xFF)) {\n\t\tlen = i2c_sequence[index] * 256 + i2c_sequence[index+1];\n\t\tif (len == 0x0000) {\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tindex += 2;\n\t\t} else if (len & 0x8000) {\n\t\t\t \n\t\t\tmsleep(len & 0x7FFF);\n\t\t\tindex += 2;\n\t\t} else {\n\t\t\t \n\t\t\tindex += 2;\n\t\t\tbuf[0] = i2c_sequence[index];\n\t\t\tbuf[1] = i2c_sequence[index + 1];\n\t\t\tpos = 2;\n\t\t\twhile (pos < len) {\n\t\t\t\tif ((len - pos) > XC_MAX_I2C_WRITE_LENGTH - 2)\n\t\t\t\t\tnbytes_to_send =\n\t\t\t\t\t\tXC_MAX_I2C_WRITE_LENGTH;\n\t\t\t\telse\n\t\t\t\t\tnbytes_to_send = (len - pos + 2);\n\t\t\t\tfor (i = 2; i < nbytes_to_send; i++) {\n\t\t\t\t\tbuf[i] = i2c_sequence[index + pos +\n\t\t\t\t\t\ti - 2];\n\t\t\t\t}\n\t\t\t\tresult = xc_send_i2c_data(priv, buf,\n\t\t\t\t\tnbytes_to_send);\n\n\t\t\t\tif (result != 0)\n\t\t\t\t\treturn result;\n\n\t\t\t\tpos += nbytes_to_send - 2;\n\t\t\t}\n\t\t\tindex += len;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int xc_set_tv_standard(struct xc4000_priv *priv,\n\tu16 video_mode, u16 audio_mode)\n{\n\tint ret;\n\tdprintk(1, \"%s(0x%04x,0x%04x)\\n\", __func__, video_mode, audio_mode);\n\tdprintk(1, \"%s() Standard = %s\\n\",\n\t\t__func__,\n\t\txc4000_standard[priv->video_standard].Name);\n\n\t \n\tpriv->ignore_i2c_write_errors = 1;\n\n\tret = xc_write_reg(priv, XREG_VIDEO_MODE, video_mode);\n\tif (ret == 0)\n\t\tret = xc_write_reg(priv, XREG_AUDIO_MODE, audio_mode);\n\n\tpriv->ignore_i2c_write_errors = 0;\n\n\treturn ret;\n}\n\nstatic int xc_set_signal_source(struct xc4000_priv *priv, u16 rf_mode)\n{\n\tdprintk(1, \"%s(%d) Source = %s\\n\", __func__, rf_mode,\n\t\trf_mode == XC_RF_MODE_AIR ? \"ANTENNA\" : \"CABLE\");\n\n\tif ((rf_mode != XC_RF_MODE_AIR) && (rf_mode != XC_RF_MODE_CABLE)) {\n\t\trf_mode = XC_RF_MODE_CABLE;\n\t\tprintk(KERN_ERR\n\t\t\t\"%s(), Invalid mode, defaulting to CABLE\",\n\t\t\t__func__);\n\t}\n\treturn xc_write_reg(priv, XREG_SIGNALSOURCE, rf_mode);\n}\n\nstatic const struct dvb_tuner_ops xc4000_tuner_ops;\n\nstatic int xc_set_rf_frequency(struct xc4000_priv *priv, u32 freq_hz)\n{\n\tu16 freq_code;\n\n\tdprintk(1, \"%s(%u)\\n\", __func__, freq_hz);\n\n\tif ((freq_hz > xc4000_tuner_ops.info.frequency_max_hz) ||\n\t    (freq_hz < xc4000_tuner_ops.info.frequency_min_hz))\n\t\treturn -EINVAL;\n\n\tfreq_code = (u16)(freq_hz / 15625);\n\n\t \n\t \n\treturn xc_write_reg(priv, XREG_RF_FREQ, freq_code);\n}\n\nstatic int xc_get_adc_envelope(struct xc4000_priv *priv, u16 *adc_envelope)\n{\n\treturn xc4000_readreg(priv, XREG_ADC_ENV, adc_envelope);\n}\n\nstatic int xc_get_frequency_error(struct xc4000_priv *priv, u32 *freq_error_hz)\n{\n\tint result;\n\tu16 regData;\n\tu32 tmp;\n\n\tresult = xc4000_readreg(priv, XREG_FREQ_ERROR, &regData);\n\tif (result != 0)\n\t\treturn result;\n\n\ttmp = (u32)regData & 0xFFFFU;\n\ttmp = (tmp < 0x8000U ? tmp : 0x10000U - tmp);\n\t(*freq_error_hz) = tmp * 15625;\n\treturn result;\n}\n\nstatic int xc_get_lock_status(struct xc4000_priv *priv, u16 *lock_status)\n{\n\treturn xc4000_readreg(priv, XREG_LOCK, lock_status);\n}\n\nstatic int xc_get_version(struct xc4000_priv *priv,\n\tu8 *hw_majorversion, u8 *hw_minorversion,\n\tu8 *fw_majorversion, u8 *fw_minorversion)\n{\n\tu16 data;\n\tint result;\n\n\tresult = xc4000_readreg(priv, XREG_VERSION, &data);\n\tif (result != 0)\n\t\treturn result;\n\n\t(*hw_majorversion) = (data >> 12) & 0x0F;\n\t(*hw_minorversion) = (data >>  8) & 0x0F;\n\t(*fw_majorversion) = (data >>  4) & 0x0F;\n\t(*fw_minorversion) = data & 0x0F;\n\n\treturn 0;\n}\n\nstatic int xc_get_hsync_freq(struct xc4000_priv *priv, u32 *hsync_freq_hz)\n{\n\tu16 regData;\n\tint result;\n\n\tresult = xc4000_readreg(priv, XREG_HSYNC_FREQ, &regData);\n\tif (result != 0)\n\t\treturn result;\n\n\t(*hsync_freq_hz) = ((regData & 0x0fff) * 763)/100;\n\treturn result;\n}\n\nstatic int xc_get_frame_lines(struct xc4000_priv *priv, u16 *frame_lines)\n{\n\treturn xc4000_readreg(priv, XREG_FRAME_LINES, frame_lines);\n}\n\nstatic int xc_get_quality(struct xc4000_priv *priv, u16 *quality)\n{\n\treturn xc4000_readreg(priv, XREG_QUALITY, quality);\n}\n\nstatic int xc_get_signal_level(struct xc4000_priv *priv, u16 *signal)\n{\n\treturn xc4000_readreg(priv, XREG_SIGNAL_LEVEL, signal);\n}\n\nstatic int xc_get_noise_level(struct xc4000_priv *priv, u16 *noise)\n{\n\treturn xc4000_readreg(priv, XREG_NOISE_LEVEL, noise);\n}\n\nstatic u16 xc_wait_for_lock(struct xc4000_priv *priv)\n{\n\tu16\tlock_state = 0;\n\tint\twatchdog_count = 40;\n\n\twhile ((lock_state == 0) && (watchdog_count > 0)) {\n\t\txc_get_lock_status(priv, &lock_state);\n\t\tif (lock_state != 1) {\n\t\t\tmsleep(5);\n\t\t\twatchdog_count--;\n\t\t}\n\t}\n\treturn lock_state;\n}\n\nstatic int xc_tune_channel(struct xc4000_priv *priv, u32 freq_hz)\n{\n\tint\tfound = 1;\n\tint\tresult;\n\n\tdprintk(1, \"%s(%u)\\n\", __func__, freq_hz);\n\n\t \n\tpriv->ignore_i2c_write_errors = 1;\n\tresult = xc_set_rf_frequency(priv, freq_hz);\n\tpriv->ignore_i2c_write_errors = 0;\n\n\tif (result != 0)\n\t\treturn 0;\n\n\t \n\tif ((priv->cur_fw.type & (FM | DTV6 | DTV7 | DTV78 | DTV8)) == 0) {\n\t\tif (xc_wait_for_lock(priv) != 1)\n\t\t\tfound = 0;\n\t}\n\n\t \n\tmsleep(debug ? 100 : 10);\n\n\tif (debug)\n\t\txc_debug_dump(priv);\n\n\treturn found;\n}\n\nstatic int xc4000_readreg(struct xc4000_priv *priv, u16 reg, u16 *val)\n{\n\tu8 buf[2] = { reg >> 8, reg & 0xff };\n\tu8 bval[2] = { 0, 0 };\n\tstruct i2c_msg msg[2] = {\n\t\t{ .addr = priv->i2c_props.addr,\n\t\t\t.flags = 0, .buf = &buf[0], .len = 2 },\n\t\t{ .addr = priv->i2c_props.addr,\n\t\t\t.flags = I2C_M_RD, .buf = &bval[0], .len = 2 },\n\t};\n\n\tif (i2c_transfer(priv->i2c_props.adap, msg, 2) != 2) {\n\t\tprintk(KERN_ERR \"xc4000: I2C read failed\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\t*val = (bval[0] << 8) | bval[1];\n\treturn 0;\n}\n\n#define dump_firm_type(t)\tdump_firm_type_and_int_freq(t, 0)\nstatic void dump_firm_type_and_int_freq(unsigned int type, u16 int_freq)\n{\n\tif (type & BASE)\n\t\tprintk(KERN_CONT \"BASE \");\n\tif (type & INIT1)\n\t\tprintk(KERN_CONT \"INIT1 \");\n\tif (type & F8MHZ)\n\t\tprintk(KERN_CONT \"F8MHZ \");\n\tif (type & MTS)\n\t\tprintk(KERN_CONT \"MTS \");\n\tif (type & D2620)\n\t\tprintk(KERN_CONT \"D2620 \");\n\tif (type & D2633)\n\t\tprintk(KERN_CONT \"D2633 \");\n\tif (type & DTV6)\n\t\tprintk(KERN_CONT \"DTV6 \");\n\tif (type & QAM)\n\t\tprintk(KERN_CONT \"QAM \");\n\tif (type & DTV7)\n\t\tprintk(KERN_CONT \"DTV7 \");\n\tif (type & DTV78)\n\t\tprintk(KERN_CONT \"DTV78 \");\n\tif (type & DTV8)\n\t\tprintk(KERN_CONT \"DTV8 \");\n\tif (type & FM)\n\t\tprintk(KERN_CONT \"FM \");\n\tif (type & INPUT1)\n\t\tprintk(KERN_CONT \"INPUT1 \");\n\tif (type & LCD)\n\t\tprintk(KERN_CONT \"LCD \");\n\tif (type & NOGD)\n\t\tprintk(KERN_CONT \"NOGD \");\n\tif (type & MONO)\n\t\tprintk(KERN_CONT \"MONO \");\n\tif (type & ATSC)\n\t\tprintk(KERN_CONT \"ATSC \");\n\tif (type & IF)\n\t\tprintk(KERN_CONT \"IF \");\n\tif (type & LG60)\n\t\tprintk(KERN_CONT \"LG60 \");\n\tif (type & ATI638)\n\t\tprintk(KERN_CONT \"ATI638 \");\n\tif (type & OREN538)\n\t\tprintk(KERN_CONT \"OREN538 \");\n\tif (type & OREN36)\n\t\tprintk(KERN_CONT \"OREN36 \");\n\tif (type & TOYOTA388)\n\t\tprintk(KERN_CONT \"TOYOTA388 \");\n\tif (type & TOYOTA794)\n\t\tprintk(KERN_CONT \"TOYOTA794 \");\n\tif (type & DIBCOM52)\n\t\tprintk(KERN_CONT \"DIBCOM52 \");\n\tif (type & ZARLINK456)\n\t\tprintk(KERN_CONT \"ZARLINK456 \");\n\tif (type & CHINA)\n\t\tprintk(KERN_CONT \"CHINA \");\n\tif (type & F6MHZ)\n\t\tprintk(KERN_CONT \"F6MHZ \");\n\tif (type & INPUT2)\n\t\tprintk(KERN_CONT \"INPUT2 \");\n\tif (type & SCODE)\n\t\tprintk(KERN_CONT \"SCODE \");\n\tif (type & HAS_IF)\n\t\tprintk(KERN_CONT \"HAS_IF_%d \", int_freq);\n}\n\nstatic int seek_firmware(struct dvb_frontend *fe, unsigned int type,\n\t\t\t v4l2_std_id *id)\n{\n\tstruct xc4000_priv *priv = fe->tuner_priv;\n\tint\t\ti, best_i = -1;\n\tunsigned int\tbest_nr_diffs = 255U;\n\n\tif (!priv->firm) {\n\t\tprintk(KERN_ERR \"Error! firmware not loaded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (((type & ~SCODE) == 0) && (*id == 0))\n\t\t*id = V4L2_STD_PAL;\n\n\t \n\tfor (i = 0; i < priv->firm_size; i++) {\n\t\tv4l2_std_id\tid_diff_mask =\n\t\t\t(priv->firm[i].id ^ (*id)) & (*id);\n\t\tunsigned int\ttype_diff_mask =\n\t\t\t(priv->firm[i].type ^ type)\n\t\t\t& (BASE_TYPES | DTV_TYPES | LCD | NOGD | MONO | SCODE);\n\t\tunsigned int\tnr_diffs;\n\n\t\tif (type_diff_mask\n\t\t    & (BASE | INIT1 | FM | DTV6 | DTV7 | DTV78 | DTV8 | SCODE))\n\t\t\tcontinue;\n\n\t\tnr_diffs = hweight64(id_diff_mask) + hweight32(type_diff_mask);\n\t\tif (!nr_diffs)\t \n\t\t\tgoto found;\n\n\t\tif (nr_diffs < best_nr_diffs) {\n\t\t\tbest_nr_diffs = nr_diffs;\n\t\t\tbest_i = i;\n\t\t}\n\t}\n\n\t \n\tif (best_i < 0) {\n\t\ti = -ENOENT;\n\t\tgoto ret;\n\t}\n\n\tif (best_nr_diffs > 0U) {\n\t\tprintk(KERN_WARNING\n\t\t       \"Selecting best matching firmware (%u bits differ) for type=(%x), id %016llx:\\n\",\n\t\t       best_nr_diffs, type, (unsigned long long)*id);\n\t\ti = best_i;\n\t}\n\nfound:\n\t*id = priv->firm[i].id;\n\nret:\n\tif (debug) {\n\t\tprintk(KERN_DEBUG \"%s firmware for type=\",\n\t\t       (i < 0) ? \"Can't find\" : \"Found\");\n\t\tdump_firm_type(type);\n\t\tprintk(KERN_DEBUG \"(%x), id %016llx.\\n\", type, (unsigned long long)*id);\n\t}\n\treturn i;\n}\n\nstatic int load_firmware(struct dvb_frontend *fe, unsigned int type,\n\t\t\t v4l2_std_id *id)\n{\n\tstruct xc4000_priv *priv = fe->tuner_priv;\n\tint                pos, rc;\n\tunsigned char      *p;\n\n\tpos = seek_firmware(fe, type, id);\n\tif (pos < 0)\n\t\treturn pos;\n\n\tp = priv->firm[pos].ptr;\n\n\t \n\tpriv->ignore_i2c_write_errors = 1;\n\n\trc = xc_load_i2c_sequence(fe, p);\n\n\tpriv->ignore_i2c_write_errors = 0;\n\n\treturn rc;\n}\n\nstatic int xc4000_fwupload(struct dvb_frontend *fe)\n{\n\tstruct xc4000_priv *priv = fe->tuner_priv;\n\tconst struct firmware *fw   = NULL;\n\tconst unsigned char   *p, *endp;\n\tint                   rc = 0;\n\tint\t\t      n, n_array;\n\tchar\t\t      name[33];\n\tconst char\t      *fname;\n\n\tif (firmware_name[0] != '\\0') {\n\t\tfname = firmware_name;\n\n\t\tdprintk(1, \"Reading custom firmware %s\\n\", fname);\n\t\trc = request_firmware(&fw, fname,\n\t\t\t\t      priv->i2c_props.adap->dev.parent);\n\t} else {\n\t\tfname = XC4000_DEFAULT_FIRMWARE_NEW;\n\t\tdprintk(1, \"Trying to read firmware %s\\n\", fname);\n\t\trc = request_firmware(&fw, fname,\n\t\t\t\t      priv->i2c_props.adap->dev.parent);\n\t\tif (rc == -ENOENT) {\n\t\t\tfname = XC4000_DEFAULT_FIRMWARE;\n\t\t\tdprintk(1, \"Trying to read firmware %s\\n\", fname);\n\t\t\trc = request_firmware(&fw, fname,\n\t\t\t\t\t      priv->i2c_props.adap->dev.parent);\n\t\t}\n\t}\n\n\tif (rc < 0) {\n\t\tif (rc == -ENOENT)\n\t\t\tprintk(KERN_ERR \"Error: firmware %s not found.\\n\", fname);\n\t\telse\n\t\t\tprintk(KERN_ERR \"Error %d while requesting firmware %s\\n\",\n\t\t\t       rc, fname);\n\n\t\treturn rc;\n\t}\n\tdprintk(1, \"Loading Firmware: %s\\n\", fname);\n\n\tp = fw->data;\n\tendp = p + fw->size;\n\n\tif (fw->size < sizeof(name) - 1 + 2 + 2) {\n\t\tprintk(KERN_ERR \"Error: firmware file %s has invalid size!\\n\",\n\t\t       fname);\n\t\tgoto corrupt;\n\t}\n\n\tmemcpy(name, p, sizeof(name) - 1);\n\tname[sizeof(name) - 1] = '\\0';\n\tp += sizeof(name) - 1;\n\n\tpriv->firm_version = get_unaligned_le16(p);\n\tp += 2;\n\n\tn_array = get_unaligned_le16(p);\n\tp += 2;\n\n\tdprintk(1, \"Loading %d firmware images from %s, type: %s, ver %d.%d\\n\",\n\t\tn_array, fname, name,\n\t\tpriv->firm_version >> 8, priv->firm_version & 0xff);\n\n\tpriv->firm = kcalloc(n_array, sizeof(*priv->firm), GFP_KERNEL);\n\tif (priv->firm == NULL) {\n\t\tprintk(KERN_ERR \"Not enough memory to load firmware file.\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto done;\n\t}\n\tpriv->firm_size = n_array;\n\n\tn = -1;\n\twhile (p < endp) {\n\t\t__u32 type, size;\n\t\tv4l2_std_id id;\n\t\t__u16 int_freq = 0;\n\n\t\tn++;\n\t\tif (n >= n_array) {\n\t\t\tprintk(KERN_ERR \"More firmware images in file than were expected!\\n\");\n\t\t\tgoto corrupt;\n\t\t}\n\n\t\t \n\t\tif (endp - p < sizeof(type) + sizeof(id) + sizeof(size))\n\t\t\tgoto header;\n\n\t\ttype = get_unaligned_le32(p);\n\t\tp += sizeof(type);\n\n\t\tid = get_unaligned_le64(p);\n\t\tp += sizeof(id);\n\n\t\tif (type & HAS_IF) {\n\t\t\tint_freq = get_unaligned_le16(p);\n\t\t\tp += sizeof(int_freq);\n\t\t\tif (endp - p < sizeof(size))\n\t\t\t\tgoto header;\n\t\t}\n\n\t\tsize = get_unaligned_le32(p);\n\t\tp += sizeof(size);\n\n\t\tif (!size || size > endp - p) {\n\t\t\tprintk(KERN_ERR \"Firmware type (%x), id %llx is corrupted (size=%zd, expected %d)\\n\",\n\t\t\t       type, (unsigned long long)id,\n\t\t\t       endp - p, size);\n\t\t\tgoto corrupt;\n\t\t}\n\n\t\tpriv->firm[n].ptr = kmemdup(p, size, GFP_KERNEL);\n\t\tif (priv->firm[n].ptr == NULL) {\n\t\t\tprintk(KERN_ERR \"Not enough memory to load firmware file.\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (debug) {\n\t\t\tprintk(KERN_DEBUG \"Reading firmware type \");\n\t\t\tdump_firm_type_and_int_freq(type, int_freq);\n\t\t\tprintk(KERN_DEBUG \"(%x), id %llx, size=%d.\\n\",\n\t\t\t       type, (unsigned long long)id, size);\n\t\t}\n\n\t\tpriv->firm[n].type = type;\n\t\tpriv->firm[n].id   = id;\n\t\tpriv->firm[n].size = size;\n\t\tpriv->firm[n].int_freq = int_freq;\n\n\t\tp += size;\n\t}\n\n\tif (n + 1 != priv->firm_size) {\n\t\tprintk(KERN_ERR \"Firmware file is incomplete!\\n\");\n\t\tgoto corrupt;\n\t}\n\n\tgoto done;\n\nheader:\n\tprintk(KERN_ERR \"Firmware header is incomplete!\\n\");\ncorrupt:\n\trc = -EINVAL;\n\tprintk(KERN_ERR \"Error: firmware file is corrupted!\\n\");\n\ndone:\n\trelease_firmware(fw);\n\tif (rc == 0)\n\t\tdprintk(1, \"Firmware files loaded.\\n\");\n\n\treturn rc;\n}\n\nstatic int load_scode(struct dvb_frontend *fe, unsigned int type,\n\t\t\t v4l2_std_id *id, __u16 int_freq, int scode)\n{\n\tstruct xc4000_priv *priv = fe->tuner_priv;\n\tint\t\tpos, rc;\n\tunsigned char\t*p;\n\tu8\t\tscode_buf[13];\n\tu8\t\tindirect_mode[5];\n\n\tdprintk(1, \"%s called int_freq=%d\\n\", __func__, int_freq);\n\n\tif (!int_freq) {\n\t\tpos = seek_firmware(fe, type, id);\n\t\tif (pos < 0)\n\t\t\treturn pos;\n\t} else {\n\t\tfor (pos = 0; pos < priv->firm_size; pos++) {\n\t\t\tif ((priv->firm[pos].int_freq == int_freq) &&\n\t\t\t    (priv->firm[pos].type & HAS_IF))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pos == priv->firm_size)\n\t\t\treturn -ENOENT;\n\t}\n\n\tp = priv->firm[pos].ptr;\n\n\tif (priv->firm[pos].size != 12 * 16 || scode >= 16)\n\t\treturn -EINVAL;\n\tp += 12 * scode;\n\n\tif (debug) {\n\t\ttuner_info(\"Loading SCODE for type=\");\n\t\tdump_firm_type_and_int_freq(priv->firm[pos].type,\n\t\t\t\t\t    priv->firm[pos].int_freq);\n\t\tprintk(KERN_CONT \"(%x), id %016llx.\\n\", priv->firm[pos].type,\n\t\t       (unsigned long long)*id);\n\t}\n\n\tscode_buf[0] = 0x00;\n\tmemcpy(&scode_buf[1], p, 12);\n\n\t \n\trc = xc_write_reg(priv, XREG_DIRECTSITTING_MODE, 0);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"failed to put device into direct mode!\\n\");\n\t\treturn -EIO;\n\t}\n\n\trc = xc_send_i2c_data(priv, scode_buf, 13);\n\tif (rc != 0) {\n\t\t \n\t\tprintk(KERN_ERR \"Failed to set scode %d\\n\", rc);\n\t}\n\n\t \n\tmemset(indirect_mode, 0, sizeof(indirect_mode));\n\tindirect_mode[4] = 0x88;\n\txc_send_i2c_data(priv, indirect_mode, sizeof(indirect_mode));\n\tmsleep(10);\n\n\treturn 0;\n}\n\nstatic int check_firmware(struct dvb_frontend *fe, unsigned int type,\n\t\t\t  v4l2_std_id std, __u16 int_freq)\n{\n\tstruct xc4000_priv         *priv = fe->tuner_priv;\n\tstruct firmware_properties new_fw;\n\tint\t\t\t   rc = 0, is_retry = 0;\n\tu16\t\t\t   hwmodel;\n\tv4l2_std_id\t\t   std0;\n\tu8\t\t\t   hw_major = 0, hw_minor = 0, fw_major = 0, fw_minor = 0;\n\n\tdprintk(1, \"%s called\\n\", __func__);\n\n\tif (!priv->firm) {\n\t\trc = xc4000_fwupload(fe);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\nretry:\n\tnew_fw.type = type;\n\tnew_fw.id = std;\n\tnew_fw.std_req = std;\n\tnew_fw.scode_table = SCODE;\n\tnew_fw.scode_nr = 0;\n\tnew_fw.int_freq = int_freq;\n\n\tdprintk(1, \"checking firmware, user requested type=\");\n\tif (debug) {\n\t\tdump_firm_type(new_fw.type);\n\t\tprintk(KERN_CONT \"(%x), id %016llx, \", new_fw.type,\n\t\t       (unsigned long long)new_fw.std_req);\n\t\tif (!int_freq)\n\t\t\tprintk(KERN_CONT \"scode_tbl \");\n\t\telse\n\t\t\tprintk(KERN_CONT \"int_freq %d, \", new_fw.int_freq);\n\t\tprintk(KERN_CONT \"scode_nr %d\\n\", new_fw.scode_nr);\n\t}\n\n\t \n\tif (priv->cur_fw.type & BASE) {\n\t\tdprintk(1, \"BASE firmware not changed.\\n\");\n\t\tgoto skip_base;\n\t}\n\n\t \n\tmemset(&priv->cur_fw, 0, sizeof(priv->cur_fw));\n\n\t \n\trc = xc4000_tuner_reset(fe);\n\tif (rc < 0)\n\t\tgoto fail;\n\n\t \n\tstd0 = 0;\n\trc = load_firmware(fe, BASE, &std0);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"Error %d while loading base firmware\\n\", rc);\n\t\tgoto fail;\n\t}\n\n\t \n\tdprintk(1, \"Load init1 firmware, if exists\\n\");\n\n\trc = load_firmware(fe, BASE | INIT1, &std0);\n\tif (rc == -ENOENT)\n\t\trc = load_firmware(fe, BASE | INIT1, &std0);\n\tif (rc < 0 && rc != -ENOENT) {\n\t\ttuner_err(\"Error %d while loading init1 firmware\\n\",\n\t\t\t  rc);\n\t\tgoto fail;\n\t}\n\nskip_base:\n\t \n\tif (priv->cur_fw.type == (BASE | new_fw.type) &&\n\t    priv->cur_fw.std_req == std) {\n\t\tdprintk(1, \"Std-specific firmware already loaded.\\n\");\n\t\tgoto skip_std_specific;\n\t}\n\n\t \n\tpriv->cur_fw.scode_table = 0;\n\n\t \n\trc = load_firmware(fe, new_fw.type, &new_fw.id);\n\n\tif (rc < 0)\n\t\tgoto fail;\n\nskip_std_specific:\n\tif (priv->cur_fw.scode_table == new_fw.scode_table &&\n\t    priv->cur_fw.scode_nr == new_fw.scode_nr) {\n\t\tdprintk(1, \"SCODE firmware already loaded.\\n\");\n\t\tgoto check_device;\n\t}\n\n\t \n\trc = load_scode(fe, new_fw.type | new_fw.scode_table, &new_fw.id,\n\t\t\tnew_fw.int_freq, new_fw.scode_nr);\n\tif (rc != 0)\n\t\tdprintk(1, \"load scode failed %d\\n\", rc);\n\ncheck_device:\n\tif (xc4000_readreg(priv, XREG_PRODUCT_ID, &hwmodel) < 0) {\n\t\tprintk(KERN_ERR \"Unable to read tuner registers.\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (xc_get_version(priv, &hw_major, &hw_minor, &fw_major,\n\t\t\t   &fw_minor) != 0) {\n\t\tprintk(KERN_ERR \"Unable to read tuner registers.\\n\");\n\t\tgoto fail;\n\t}\n\n\tdprintk(1, \"Device is Xceive %d version %d.%d, firmware version %d.%d\\n\",\n\t\thwmodel, hw_major, hw_minor, fw_major, fw_minor);\n\n\t \n\tif (priv->firm_version != ((fw_major << 8) | fw_minor)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"Incorrect readback of firmware version %d.%d.\\n\",\n\t\t       fw_major, fw_minor);\n\t\tgoto fail;\n\t}\n\n\t \n\tif (priv->hwmodel == 0 &&\n\t    (hwmodel == XC_PRODUCT_ID_XC4000 ||\n\t     hwmodel == XC_PRODUCT_ID_XC4100)) {\n\t\tpriv->hwmodel = hwmodel;\n\t\tpriv->hwvers = (hw_major << 8) | hw_minor;\n\t} else if (priv->hwmodel == 0 || priv->hwmodel != hwmodel ||\n\t\t   priv->hwvers != ((hw_major << 8) | hw_minor)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"Read invalid device hardware information - tuner hung?\\n\");\n\t\tgoto fail;\n\t}\n\n\tpriv->cur_fw = new_fw;\n\n\t \n\tpriv->cur_fw.type |= BASE;\n\n\treturn 0;\n\nfail:\n\tmemset(&priv->cur_fw, 0, sizeof(priv->cur_fw));\n\tif (!is_retry) {\n\t\tmsleep(50);\n\t\tis_retry = 1;\n\t\tdprintk(1, \"Retrying firmware load\\n\");\n\t\tgoto retry;\n\t}\n\n\tif (rc == -ENOENT)\n\t\trc = -EINVAL;\n\treturn rc;\n}\n\nstatic void xc_debug_dump(struct xc4000_priv *priv)\n{\n\tu16\tadc_envelope;\n\tu32\tfreq_error_hz = 0;\n\tu16\tlock_status;\n\tu32\thsync_freq_hz = 0;\n\tu16\tframe_lines;\n\tu16\tquality;\n\tu16\tsignal = 0;\n\tu16\tnoise = 0;\n\tu8\thw_majorversion = 0, hw_minorversion = 0;\n\tu8\tfw_majorversion = 0, fw_minorversion = 0;\n\n\txc_get_adc_envelope(priv, &adc_envelope);\n\tdprintk(1, \"*** ADC envelope (0-1023) = %d\\n\", adc_envelope);\n\n\txc_get_frequency_error(priv, &freq_error_hz);\n\tdprintk(1, \"*** Frequency error = %d Hz\\n\", freq_error_hz);\n\n\txc_get_lock_status(priv, &lock_status);\n\tdprintk(1, \"*** Lock status (0-Wait, 1-Locked, 2-No-signal) = %d\\n\",\n\t\tlock_status);\n\n\txc_get_version(priv, &hw_majorversion, &hw_minorversion,\n\t\t       &fw_majorversion, &fw_minorversion);\n\tdprintk(1, \"*** HW: V%02x.%02x, FW: V%02x.%02x\\n\",\n\t\thw_majorversion, hw_minorversion,\n\t\tfw_majorversion, fw_minorversion);\n\n\tif (priv->video_standard < XC4000_DTV6) {\n\t\txc_get_hsync_freq(priv, &hsync_freq_hz);\n\t\tdprintk(1, \"*** Horizontal sync frequency = %d Hz\\n\",\n\t\t\thsync_freq_hz);\n\n\t\txc_get_frame_lines(priv, &frame_lines);\n\t\tdprintk(1, \"*** Frame lines = %d\\n\", frame_lines);\n\t}\n\n\txc_get_quality(priv, &quality);\n\tdprintk(1, \"*** Quality (0:<8dB, 7:>56dB) = %d\\n\", quality);\n\n\txc_get_signal_level(priv, &signal);\n\tdprintk(1, \"*** Signal level = -%ddB (%d)\\n\", signal >> 8, signal);\n\n\txc_get_noise_level(priv, &noise);\n\tdprintk(1, \"*** Noise level = %ddB (%d)\\n\", noise >> 8, noise);\n}\n\nstatic int xc4000_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 delsys = c->delivery_system;\n\tu32 bw = c->bandwidth_hz;\n\tstruct xc4000_priv *priv = fe->tuner_priv;\n\tunsigned int type;\n\tint\tret = -EREMOTEIO;\n\n\tdprintk(1, \"%s() frequency=%d (Hz)\\n\", __func__, c->frequency);\n\n\tmutex_lock(&priv->lock);\n\n\tswitch (delsys) {\n\tcase SYS_ATSC:\n\t\tdprintk(1, \"%s() VSB modulation\\n\", __func__);\n\t\tpriv->rf_mode = XC_RF_MODE_AIR;\n\t\tpriv->freq_offset = 1750000;\n\t\tpriv->video_standard = XC4000_DTV6;\n\t\ttype = DTV6;\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_B:\n\t\tdprintk(1, \"%s() QAM modulation\\n\", __func__);\n\t\tpriv->rf_mode = XC_RF_MODE_CABLE;\n\t\tpriv->freq_offset = 1750000;\n\t\tpriv->video_standard = XC4000_DTV6;\n\t\ttype = DTV6;\n\t\tbreak;\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tdprintk(1, \"%s() OFDM\\n\", __func__);\n\t\tif (bw == 0) {\n\t\t\tif (c->frequency < 400000000) {\n\t\t\t\tpriv->freq_offset = 2250000;\n\t\t\t} else {\n\t\t\t\tpriv->freq_offset = 2750000;\n\t\t\t}\n\t\t\tpriv->video_standard = XC4000_DTV7_8;\n\t\t\ttype = DTV78;\n\t\t} else if (bw <= 6000000) {\n\t\t\tpriv->video_standard = XC4000_DTV6;\n\t\t\tpriv->freq_offset = 1750000;\n\t\t\ttype = DTV6;\n\t\t} else if (bw <= 7000000) {\n\t\t\tpriv->video_standard = XC4000_DTV7;\n\t\t\tpriv->freq_offset = 2250000;\n\t\t\ttype = DTV7;\n\t\t} else {\n\t\t\tpriv->video_standard = XC4000_DTV8;\n\t\t\tpriv->freq_offset = 2750000;\n\t\t\ttype = DTV8;\n\t\t}\n\t\tpriv->rf_mode = XC_RF_MODE_AIR;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"xc4000 delivery system not supported!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tpriv->freq_hz = c->frequency - priv->freq_offset;\n\n\tdprintk(1, \"%s() frequency=%d (compensated)\\n\",\n\t\t__func__, priv->freq_hz);\n\n\t \n\tif (check_firmware(fe, type, 0, priv->if_khz) != 0)\n\t\tgoto fail;\n\n\tpriv->bandwidth = c->bandwidth_hz;\n\n\tret = xc_set_signal_source(priv, priv->rf_mode);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"xc4000: xc_set_signal_source(%d) failed\\n\",\n\t\t       priv->rf_mode);\n\t\tgoto fail;\n\t} else {\n\t\tu16\tvideo_mode, audio_mode;\n\t\tvideo_mode = xc4000_standard[priv->video_standard].video_mode;\n\t\taudio_mode = xc4000_standard[priv->video_standard].audio_mode;\n\t\tif (type == DTV6 && priv->firm_version != 0x0102)\n\t\t\tvideo_mode |= 0x0001;\n\t\tret = xc_set_tv_standard(priv, video_mode, audio_mode);\n\t\tif (ret != 0) {\n\t\t\tprintk(KERN_ERR \"xc4000: xc_set_tv_standard failed\\n\");\n\t\t\t \n\t\t\t \n\t\t}\n\t}\n\n\tif (xc_write_reg(priv, XREG_D_CODE, 0) == 0)\n\t\tret = 0;\n\tif (priv->dvb_amplitude != 0) {\n\t\tif (xc_write_reg(priv, XREG_AMPLITUDE,\n\t\t\t\t (priv->firm_version != 0x0102 ||\n\t\t\t\t  priv->dvb_amplitude != 134 ?\n\t\t\t\t  priv->dvb_amplitude : 132)) != 0)\n\t\t\tret = -EREMOTEIO;\n\t}\n\tif (priv->set_smoothedcvbs != 0) {\n\t\tif (xc_write_reg(priv, XREG_SMOOTHEDCVBS, 1) != 0)\n\t\t\tret = -EREMOTEIO;\n\t}\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"xc4000: setting registers failed\\n\");\n\t\t \n\t}\n\n\txc_tune_channel(priv, priv->freq_hz);\n\n\tret = 0;\n\nfail:\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int xc4000_set_analog_params(struct dvb_frontend *fe,\n\tstruct analog_parameters *params)\n{\n\tstruct xc4000_priv *priv = fe->tuner_priv;\n\tunsigned int type = 0;\n\tint\tret = -EREMOTEIO;\n\n\tif (params->mode == V4L2_TUNER_RADIO) {\n\t\tdprintk(1, \"%s() frequency=%d (in units of 62.5Hz)\\n\",\n\t\t\t__func__, params->frequency);\n\n\t\tmutex_lock(&priv->lock);\n\n\t\tparams->std = 0;\n\t\tpriv->freq_hz = params->frequency * 125L / 2;\n\n\t\tif (audio_std & XC4000_AUDIO_STD_INPUT1) {\n\t\t\tpriv->video_standard = XC4000_FM_Radio_INPUT1;\n\t\t\ttype = FM | INPUT1;\n\t\t} else {\n\t\t\tpriv->video_standard = XC4000_FM_Radio_INPUT2;\n\t\t\ttype = FM | INPUT2;\n\t\t}\n\n\t\tgoto tune_channel;\n\t}\n\n\tdprintk(1, \"%s() frequency=%d (in units of 62.5khz)\\n\",\n\t\t__func__, params->frequency);\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tpriv->freq_hz = params->frequency * 62500;\n\n\tparams->std &= V4L2_STD_ALL;\n\t \n\tif (!params->std)\n\t\tparams->std = V4L2_STD_PAL_BG;\n\n\tif (audio_std & XC4000_AUDIO_STD_MONO)\n\t\ttype = MONO;\n\n\tif (params->std & V4L2_STD_MN) {\n\t\tparams->std = V4L2_STD_MN;\n\t\tif (audio_std & XC4000_AUDIO_STD_MONO) {\n\t\t\tpriv->video_standard = XC4000_MN_NTSC_PAL_Mono;\n\t\t} else if (audio_std & XC4000_AUDIO_STD_A2) {\n\t\t\tparams->std |= V4L2_STD_A2;\n\t\t\tpriv->video_standard = XC4000_MN_NTSC_PAL_A2;\n\t\t} else {\n\t\t\tparams->std |= V4L2_STD_BTSC;\n\t\t\tpriv->video_standard = XC4000_MN_NTSC_PAL_BTSC;\n\t\t}\n\t\tgoto tune_channel;\n\t}\n\n\tif (params->std & V4L2_STD_PAL_BG) {\n\t\tparams->std = V4L2_STD_PAL_BG;\n\t\tif (audio_std & XC4000_AUDIO_STD_MONO) {\n\t\t\tpriv->video_standard = XC4000_BG_PAL_MONO;\n\t\t} else if (!(audio_std & XC4000_AUDIO_STD_A2)) {\n\t\t\tif (!(audio_std & XC4000_AUDIO_STD_B)) {\n\t\t\t\tparams->std |= V4L2_STD_NICAM_A;\n\t\t\t\tpriv->video_standard = XC4000_BG_PAL_NICAM;\n\t\t\t} else {\n\t\t\t\tparams->std |= V4L2_STD_NICAM_B;\n\t\t\t\tpriv->video_standard = XC4000_BG_PAL_NICAM;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!(audio_std & XC4000_AUDIO_STD_B)) {\n\t\t\t\tparams->std |= V4L2_STD_A2_A;\n\t\t\t\tpriv->video_standard = XC4000_BG_PAL_A2;\n\t\t\t} else {\n\t\t\t\tparams->std |= V4L2_STD_A2_B;\n\t\t\t\tpriv->video_standard = XC4000_BG_PAL_A2;\n\t\t\t}\n\t\t}\n\t\tgoto tune_channel;\n\t}\n\n\tif (params->std & V4L2_STD_PAL_I) {\n\t\t \n\t\tparams->std = V4L2_STD_PAL_I | V4L2_STD_NICAM;\n\t\tif (audio_std & XC4000_AUDIO_STD_MONO)\n\t\t\tpriv->video_standard = XC4000_I_PAL_NICAM_MONO;\n\t\telse\n\t\t\tpriv->video_standard = XC4000_I_PAL_NICAM;\n\t\tgoto tune_channel;\n\t}\n\n\tif (params->std & V4L2_STD_PAL_DK) {\n\t\tparams->std = V4L2_STD_PAL_DK;\n\t\tif (audio_std & XC4000_AUDIO_STD_MONO) {\n\t\t\tpriv->video_standard = XC4000_DK_PAL_MONO;\n\t\t} else if (audio_std & XC4000_AUDIO_STD_A2) {\n\t\t\tparams->std |= V4L2_STD_A2;\n\t\t\tpriv->video_standard = XC4000_DK_PAL_A2;\n\t\t} else {\n\t\t\tparams->std |= V4L2_STD_NICAM;\n\t\t\tpriv->video_standard = XC4000_DK_PAL_NICAM;\n\t\t}\n\t\tgoto tune_channel;\n\t}\n\n\tif (params->std & V4L2_STD_SECAM_DK) {\n\t\t \n\t\tparams->std = V4L2_STD_SECAM_DK | V4L2_STD_A2;\n\t\tif (audio_std & XC4000_AUDIO_STD_L) {\n\t\t\ttype = 0;\n\t\t\tpriv->video_standard = XC4000_DK_SECAM_NICAM;\n\t\t} else if (audio_std & XC4000_AUDIO_STD_MONO) {\n\t\t\tpriv->video_standard = XC4000_DK_SECAM_A2MONO;\n\t\t} else if (audio_std & XC4000_AUDIO_STD_K3) {\n\t\t\tparams->std |= V4L2_STD_SECAM_K3;\n\t\t\tpriv->video_standard = XC4000_DK_SECAM_A2LDK3;\n\t\t} else {\n\t\t\tpriv->video_standard = XC4000_DK_SECAM_A2DK1;\n\t\t}\n\t\tgoto tune_channel;\n\t}\n\n\tif (params->std & V4L2_STD_SECAM_L) {\n\t\t \n\t\ttype = 0;\n\t\tparams->std = V4L2_STD_SECAM_L | V4L2_STD_NICAM;\n\t\tpriv->video_standard = XC4000_L_SECAM_NICAM;\n\t\tgoto tune_channel;\n\t}\n\n\tif (params->std & V4L2_STD_SECAM_LC) {\n\t\t \n\t\ttype = 0;\n\t\tparams->std = V4L2_STD_SECAM_LC | V4L2_STD_NICAM;\n\t\tpriv->video_standard = XC4000_LC_SECAM_NICAM;\n\t\tgoto tune_channel;\n\t}\n\ntune_channel:\n\t \n\tpriv->rf_mode = XC_RF_MODE_CABLE;\n\n\tif (check_firmware(fe, type, params->std,\n\t\t\t   xc4000_standard[priv->video_standard].int_freq) != 0)\n\t\tgoto fail;\n\n\tret = xc_set_signal_source(priv, priv->rf_mode);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"xc4000: xc_set_signal_source(%d) failed\\n\",\n\t\t       priv->rf_mode);\n\t\tgoto fail;\n\t} else {\n\t\tu16\tvideo_mode, audio_mode;\n\t\tvideo_mode = xc4000_standard[priv->video_standard].video_mode;\n\t\taudio_mode = xc4000_standard[priv->video_standard].audio_mode;\n\t\tif (priv->video_standard < XC4000_BG_PAL_A2) {\n\t\t\tif (type & NOGD)\n\t\t\t\tvideo_mode &= 0xFF7F;\n\t\t} else if (priv->video_standard < XC4000_I_PAL_NICAM) {\n\t\t\tif (priv->firm_version == 0x0102)\n\t\t\t\tvideo_mode &= 0xFEFF;\n\t\t\tif (audio_std & XC4000_AUDIO_STD_B)\n\t\t\t\tvideo_mode |= 0x0080;\n\t\t}\n\t\tret = xc_set_tv_standard(priv, video_mode, audio_mode);\n\t\tif (ret != 0) {\n\t\t\tprintk(KERN_ERR \"xc4000: xc_set_tv_standard failed\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (xc_write_reg(priv, XREG_D_CODE, 0) == 0)\n\t\tret = 0;\n\tif (xc_write_reg(priv, XREG_AMPLITUDE, 1) != 0)\n\t\tret = -EREMOTEIO;\n\tif (priv->set_smoothedcvbs != 0) {\n\t\tif (xc_write_reg(priv, XREG_SMOOTHEDCVBS, 1) != 0)\n\t\t\tret = -EREMOTEIO;\n\t}\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"xc4000: setting registers failed\\n\");\n\t\tgoto fail;\n\t}\n\n\txc_tune_channel(priv, priv->freq_hz);\n\n\tret = 0;\n\nfail:\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int xc4000_get_signal(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct xc4000_priv *priv = fe->tuner_priv;\n\tu16 value = 0;\n\tint rc;\n\n\tmutex_lock(&priv->lock);\n\trc = xc4000_readreg(priv, XREG_SIGNAL_LEVEL, &value);\n\tmutex_unlock(&priv->lock);\n\n\tif (rc < 0)\n\t\tgoto ret;\n\n\t \n\ttuner_dbg(\"Signal strength: -%ddB (%05d)\\n\", value >> 8, value);\n\n\t \n\tif ((priv->video_standard == XC4000_DTV6) ||\n\t    (priv->video_standard == XC4000_DTV7) ||\n\t    (priv->video_standard == XC4000_DTV7_8) ||\n\t    (priv->video_standard == XC4000_DTV8))\n\t\tgoto digital;\n\n\t \n\tmutex_lock(&priv->lock);\n\trc = xc4000_readreg(priv, XREG_NOISE_LEVEL, &value);\n\tmutex_unlock(&priv->lock);\n\n\ttuner_dbg(\"Noise level: %ddB (%05d)\\n\", value >> 8, value);\n\n\t \n\tif (value >= 0x2000) {\n\t\tvalue = 0;\n\t} else {\n\t\tvalue = (~value << 3) & 0xffff;\n\t}\n\n\tgoto ret;\n\n\t \ndigital:\n\t \n\tif (value <= 0x3200) {\n\t\tvalue = 0xffff;\n\t \n\t} else if (value >= 0x713A) {\n\t\tvalue = 0;\n\t} else {\n\t\tvalue = ~(value - 0x3200) << 2;\n\t}\n\nret:\n\t*strength = value;\n\n\treturn rc;\n}\n\nstatic int xc4000_get_frequency(struct dvb_frontend *fe, u32 *freq)\n{\n\tstruct xc4000_priv *priv = fe->tuner_priv;\n\n\t*freq = priv->freq_hz + priv->freq_offset;\n\n\tif (debug) {\n\t\tmutex_lock(&priv->lock);\n\t\tif ((priv->cur_fw.type\n\t\t     & (BASE | FM | DTV6 | DTV7 | DTV78 | DTV8)) == BASE) {\n\t\t\tu16\tsnr = 0;\n\t\t\tif (xc4000_readreg(priv, XREG_SNR, &snr) == 0) {\n\t\t\t\tmutex_unlock(&priv->lock);\n\t\t\t\tdprintk(1, \"%s() freq = %u, SNR = %d\\n\",\n\t\t\t\t\t__func__, *freq, snr);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&priv->lock);\n\t}\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\treturn 0;\n}\n\nstatic int xc4000_get_bandwidth(struct dvb_frontend *fe, u32 *bw)\n{\n\tstruct xc4000_priv *priv = fe->tuner_priv;\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t*bw = priv->bandwidth;\n\treturn 0;\n}\n\nstatic int xc4000_get_status(struct dvb_frontend *fe, u32 *status)\n{\n\tstruct xc4000_priv *priv = fe->tuner_priv;\n\tu16\tlock_status = 0;\n\n\tmutex_lock(&priv->lock);\n\n\tif (priv->cur_fw.type & BASE)\n\t\txc_get_lock_status(priv, &lock_status);\n\n\t*status = (lock_status == 1 ?\n\t\t   TUNER_STATUS_LOCKED | TUNER_STATUS_STEREO : 0);\n\tif (priv->cur_fw.type & (DTV6 | DTV7 | DTV78 | DTV8))\n\t\t*status &= (~TUNER_STATUS_STEREO);\n\n\tmutex_unlock(&priv->lock);\n\n\tdprintk(2, \"%s() lock_status = %d\\n\", __func__, lock_status);\n\n\treturn 0;\n}\n\nstatic int xc4000_sleep(struct dvb_frontend *fe)\n{\n\tstruct xc4000_priv *priv = fe->tuner_priv;\n\tint\tret = 0;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tif ((no_poweroff == 2 ||\n\t     (no_poweroff == 0 && priv->default_pm != 0)) &&\n\t    (priv->cur_fw.type & BASE) != 0) {\n\t\t \n\t\tpriv->cur_fw.type = XC_POWERED_DOWN;\n\n\t\tif (xc_write_reg(priv, XREG_POWER_DOWN, 0) != 0) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"xc4000: %s() unable to shutdown tuner\\n\",\n\t\t\t       __func__);\n\t\t\tret = -EREMOTEIO;\n\t\t}\n\t\tmsleep(20);\n\t}\n\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int xc4000_init(struct dvb_frontend *fe)\n{\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\treturn 0;\n}\n\nstatic void xc4000_release(struct dvb_frontend *fe)\n{\n\tstruct xc4000_priv *priv = fe->tuner_priv;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tmutex_lock(&xc4000_list_mutex);\n\n\tif (priv)\n\t\thybrid_tuner_release_state(priv);\n\n\tmutex_unlock(&xc4000_list_mutex);\n\n\tfe->tuner_priv = NULL;\n}\n\nstatic const struct dvb_tuner_ops xc4000_tuner_ops = {\n\t.info = {\n\t\t.name              = \"Xceive XC4000\",\n\t\t.frequency_min_hz  =    1 * MHz,\n\t\t.frequency_max_hz  = 1023 * MHz,\n\t\t.frequency_step_hz =   50 * kHz,\n\t},\n\n\t.release\t   = xc4000_release,\n\t.init\t\t   = xc4000_init,\n\t.sleep\t\t   = xc4000_sleep,\n\n\t.set_params\t   = xc4000_set_params,\n\t.set_analog_params = xc4000_set_analog_params,\n\t.get_frequency\t   = xc4000_get_frequency,\n\t.get_rf_strength   = xc4000_get_signal,\n\t.get_bandwidth\t   = xc4000_get_bandwidth,\n\t.get_status\t   = xc4000_get_status\n};\n\nstruct dvb_frontend *xc4000_attach(struct dvb_frontend *fe,\n\t\t\t\t   struct i2c_adapter *i2c,\n\t\t\t\t   struct xc4000_config *cfg)\n{\n\tstruct xc4000_priv *priv = NULL;\n\tint\tinstance;\n\tu16\tid = 0;\n\n\tdprintk(1, \"%s(%d-%04x)\\n\", __func__,\n\t\ti2c ? i2c_adapter_id(i2c) : -1,\n\t\tcfg ? cfg->i2c_address : -1);\n\n\tmutex_lock(&xc4000_list_mutex);\n\n\tinstance = hybrid_tuner_request_state(struct xc4000_priv, priv,\n\t\t\t\t\t      hybrid_tuner_instance_list,\n\t\t\t\t\t      i2c, cfg->i2c_address, \"xc4000\");\n\tswitch (instance) {\n\tcase 0:\n\t\tgoto fail;\n\tcase 1:\n\t\t \n\t\tpriv->bandwidth = 6000000;\n\t\t \n\t\tpriv->if_khz = 4560;\n\t\tpriv->default_pm = 0;\n\t\tpriv->dvb_amplitude = 134;\n\t\tpriv->set_smoothedcvbs = 1;\n\t\tmutex_init(&priv->lock);\n\t\tfe->tuner_priv = priv;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tfe->tuner_priv = priv;\n\t\tbreak;\n\t}\n\n\tif (cfg->if_khz != 0) {\n\t\t \n\t\tpriv->if_khz = cfg->if_khz;\n\t\tpriv->default_pm = cfg->default_pm;\n\t\tpriv->dvb_amplitude = cfg->dvb_amplitude;\n\t\tpriv->set_smoothedcvbs = cfg->set_smoothedcvbs;\n\t}\n\n\t \n\n\tif (instance == 1) {\n\t\tif (xc4000_readreg(priv, XREG_PRODUCT_ID, &id) != 0)\n\t\t\tgoto fail;\n\t} else {\n\t\tid = ((priv->cur_fw.type & BASE) != 0 ?\n\t\t      priv->hwmodel : XC_PRODUCT_ID_FW_NOT_LOADED);\n\t}\n\n\tswitch (id) {\n\tcase XC_PRODUCT_ID_XC4000:\n\tcase XC_PRODUCT_ID_XC4100:\n\t\tprintk(KERN_INFO\n\t\t\t\"xc4000: Successfully identified at address 0x%02x\\n\",\n\t\t\tcfg->i2c_address);\n\t\tprintk(KERN_INFO\n\t\t\t\"xc4000: Firmware has been loaded previously\\n\");\n\t\tbreak;\n\tcase XC_PRODUCT_ID_FW_NOT_LOADED:\n\t\tprintk(KERN_INFO\n\t\t\t\"xc4000: Successfully identified at address 0x%02x\\n\",\n\t\t\tcfg->i2c_address);\n\t\tprintk(KERN_INFO\n\t\t\t\"xc4000: Firmware has not been loaded previously\\n\");\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR\n\t\t\t\"xc4000: Device not found at addr 0x%02x (0x%x)\\n\",\n\t\t\tcfg->i2c_address, id);\n\t\tgoto fail;\n\t}\n\n\tmutex_unlock(&xc4000_list_mutex);\n\n\tmemcpy(&fe->ops.tuner_ops, &xc4000_tuner_ops,\n\t\tsizeof(struct dvb_tuner_ops));\n\n\tif (instance == 1) {\n\t\tint\tret;\n\t\tmutex_lock(&priv->lock);\n\t\tret = xc4000_fwupload(fe);\n\t\tmutex_unlock(&priv->lock);\n\t\tif (ret != 0)\n\t\t\tgoto fail2;\n\t}\n\n\treturn fe;\nfail:\n\tmutex_unlock(&xc4000_list_mutex);\nfail2:\n\txc4000_release(fe);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(xc4000_attach);\n\nMODULE_AUTHOR(\"Steven Toth, Davide Ferri\");\nMODULE_DESCRIPTION(\"Xceive xc4000 silicon tuner driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(XC4000_DEFAULT_FIRMWARE_NEW);\nMODULE_FIRMWARE(XC4000_DEFAULT_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}