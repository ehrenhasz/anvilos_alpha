{
  "module_name": "tda18250.c",
  "hash_id": "3cccf0b46d5ce760587831f9fc261e0353f8e4dfb4c85ea4d7c6c8d0971d4d90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/tda18250.c",
  "human_readable_source": "\n \n\n#include \"tda18250_priv.h\"\n#include <linux/regmap.h>\n\nstatic const struct dvb_tuner_ops tda18250_ops;\n\nstatic int tda18250_power_control(struct dvb_frontend *fe,\n\t\tunsigned int power_state)\n{\n\tstruct i2c_client *client = fe->tuner_priv;\n\tstruct tda18250_dev *dev = i2c_get_clientdata(client);\n\tint ret;\n\tunsigned int utmp;\n\n\tdev_dbg(&client->dev, \"power state: %d\", power_state);\n\n\tswitch (power_state) {\n\tcase TDA18250_POWER_NORMAL:\n\t\tret = regmap_write_bits(dev->regmap, R06_POWER2, 0x07, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_write_bits(dev->regmap, R25_REF, 0xc0, 0xc0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tbreak;\n\tcase TDA18250_POWER_STANDBY:\n\t\tif (dev->loopthrough) {\n\t\t\tret = regmap_write_bits(dev->regmap,\n\t\t\t\t\tR25_REF, 0xc0, 0x80);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tret = regmap_write_bits(dev->regmap,\n\t\t\t\t\tR06_POWER2, 0x07, 0x02);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tret = regmap_write_bits(dev->regmap,\n\t\t\t\t\tR10_LT1, 0x80, 0x00);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t} else {\n\t\t\tret = regmap_write_bits(dev->regmap,\n\t\t\t\t\tR25_REF, 0xc0, 0x80);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tret = regmap_write_bits(dev->regmap,\n\t\t\t\t\tR06_POWER2, 0x07, 0x01);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tret = regmap_read(dev->regmap,\n\t\t\t\t\tR0D_AGC12, &utmp);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tret = regmap_write_bits(dev->regmap,\n\t\t\t\t\tR0D_AGC12, 0x03, 0x03);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tret = regmap_write_bits(dev->regmap,\n\t\t\t\t\tR10_LT1, 0x80, 0x80);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tret = regmap_write_bits(dev->regmap,\n\t\t\t\t\tR0D_AGC12, 0x03, utmp & 0x03);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\nstatic int tda18250_wait_for_irq(struct dvb_frontend *fe,\n\t\tint maxwait, int step, u8 irq)\n{\n\tstruct i2c_client *client = fe->tuner_priv;\n\tstruct tda18250_dev *dev = i2c_get_clientdata(client);\n\tint ret;\n\tunsigned long timeout;\n\tbool triggered;\n\tunsigned int utmp;\n\n\ttriggered = false;\n\ttimeout = jiffies + msecs_to_jiffies(maxwait);\n\twhile (!time_after(jiffies, timeout)) {\n\t\t\n\t\tret = regmap_read(dev->regmap, R08_IRQ1, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tif ((utmp & irq) == irq) {\n\t\t\ttriggered = true;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(step);\n\t}\n\n\tdev_dbg(&client->dev, \"waited IRQ (0x%02x) %d ms, triggered: %s\", irq,\n\t\t\tjiffies_to_msecs(jiffies) -\n\t\t\t(jiffies_to_msecs(timeout) - maxwait),\n\t\t\ttriggered ? \"true\" : \"false\");\n\n\tif (!triggered)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\nstatic int tda18250_init(struct dvb_frontend *fe)\n{\n\tstruct i2c_client *client = fe->tuner_priv;\n\tstruct tda18250_dev *dev = i2c_get_clientdata(client);\n\tint ret, i;\n\n\t \n\tstatic const u8 init_regs[][2] = {\n\t\t{ R0C_AGC11, 0xc7 },\n\t\t{ R0D_AGC12, 0x5d },\n\t\t{ R0E_AGC13, 0x40 },\n\t\t{ R0F_AGC14, 0x0e },\n\t\t{ R10_LT1, 0x47 },\n\t\t{ R11_LT2, 0x4e },\n\t\t{ R12_AGC21, 0x26 },\n\t\t{ R13_AGC22, 0x60 },\n\t\t{ R18_AGC32, 0x37 },\n\t\t{ R19_AGC33, 0x09 },\n\t\t{ R1A_AGCK, 0x00 },\n\t\t{ R1E_WI_FI, 0x29 },\n\t\t{ R1F_RF_BPF, 0x06 },\n\t\t{ R20_IR_MIX, 0xc6 },\n\t\t{ R21_IF_AGC, 0x00 },\n\t\t{ R2C_PS1, 0x75 },\n\t\t{ R2D_PS2, 0x06 },\n\t\t{ R2E_PS3, 0x07 },\n\t\t{ R30_RSSI2, 0x0e },\n\t\t{ R31_IRQ_CTRL, 0x00 },\n\t\t{ R39_SD5, 0x00 },\n\t\t{ R3B_REGU, 0x55 },\n\t\t{ R3C_RCCAL1, 0xa7 },\n\t\t{ R3F_IRCAL2, 0x85 },\n\t\t{ R40_IRCAL3, 0x87 },\n\t\t{ R41_IRCAL4, 0xc0 },\n\t\t{ R43_PD1, 0x40 },\n\t\t{ R44_PD2, 0xc0 },\n\t\t{ R46_CPUMP, 0x0c },\n\t\t{ R47_LNAPOL, 0x64 },\n\t\t{ R4B_XTALOSC1, 0x30 },\n\t\t{ R59_AGC2_UP2, 0x05 },\n\t\t{ R5B_AGC_AUTO, 0x07 },\n\t\t{ R5C_AGC_DEBUG, 0x00 },\n\t};\n\n\t \n\tstatic const u8 xtal_regs[][5] = {\n\t\t\t\t\t \n\t\t[TDA18250_XTAL_FREQ_16MHZ]  = { 0x3e, 0x80, 0x50, 0x00, 0x20 },\n\t\t[TDA18250_XTAL_FREQ_24MHZ]  = { 0x5d, 0xc0, 0xec, 0x00, 0x18 },\n\t\t[TDA18250_XTAL_FREQ_25MHZ]  = { 0x61, 0xa8, 0xec, 0x80, 0x19 },\n\t\t[TDA18250_XTAL_FREQ_27MHZ]  = { 0x69, 0x78, 0x8d, 0x80, 0x1b },\n\t\t[TDA18250_XTAL_FREQ_30MHZ]  = { 0x75, 0x30, 0x8f, 0x00, 0x1e },\n\t};\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tret = tda18250_power_control(fe, TDA18250_POWER_NORMAL);\n\tif (ret)\n\t\tgoto err;\n\n\tmsleep(20);\n\n\tif (dev->warm)\n\t\tgoto warm;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(init_regs); i++) {\n\t\tret = regmap_write(dev->regmap, init_regs[i][0],\n\t\t\t\tinit_regs[i][1]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tret = regmap_bulk_write(dev->regmap, R4D_XTALFLX1,\n\t\t\txtal_regs[dev->xtal_freq], 5);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write_bits(dev->regmap, R10_LT1, 0x80,\n\t\t\tdev->loopthrough ? 0x00 : 0x80);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_write(dev->regmap, R0A_IRQ3, TDA18250_IRQ_HW_INIT);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_write(dev->regmap, R2A_MSM1, 0x70);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, R2B_MSM2, 0x01);\n\tif (ret)\n\t\tgoto err;\n\n\tret = tda18250_wait_for_irq(fe, 500, 10, TDA18250_IRQ_HW_INIT);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_write(dev->regmap, R2A_MSM1, 0x02);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, R2B_MSM2, 0x01);\n\tif (ret)\n\t\tgoto err;\n\n\tret = tda18250_wait_for_irq(fe, 500, 10, TDA18250_IRQ_CAL);\n\tif (ret)\n\t\tgoto err;\n\n\tdev->warm = true;\n\nwarm:\n\t \n\tret = regmap_write_bits(dev->regmap, R0C_AGC11, 0x80, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\", ret);\n\treturn ret;\n}\n\nstatic int tda18250_set_agc(struct dvb_frontend *fe)\n{\n\tstruct i2c_client *client = fe->tuner_priv;\n\tstruct tda18250_dev *dev = i2c_get_clientdata(client);\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret;\n\tu8 utmp, utmp2;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tret = regmap_write_bits(dev->regmap, R1F_RF_BPF, 0x87, 0x06);\n\tif (ret)\n\t\tgoto err;\n\n\tutmp = ((c->frequency < 100000000) &&\n\t\t\t((c->delivery_system == SYS_DVBC_ANNEX_A) ||\n\t\t\t(c->delivery_system == SYS_DVBC_ANNEX_C)) &&\n\t\t\t(c->bandwidth_hz == 6000000)) ? 0x80 : 0x00;\n\tret = regmap_write(dev->regmap, R5A_H3H5, utmp);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tswitch (c->delivery_system) {\n\tcase SYS_ATSC:\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tutmp = 4;\n\t\tbreak;\n\tdefault:  \n\t\tswitch (c->bandwidth_hz) {\n\t\tcase 6000000:\n\t\t\tutmp = (c->frequency < 800000000) ? 6 : 4;\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tutmp = (c->frequency < 100000000) ? 2 : 3;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tret = regmap_write_bits(dev->regmap, R0C_AGC11, 0x07, utmp);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tswitch (c->delivery_system) {\n\tcase SYS_ATSC:\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tutmp = (c->frequency < 320000000) ? 20 : 16;\n\t\tutmp2 = (c->frequency < 320000000) ? 22 : 18;\n\t\tbreak;\n\tdefault:  \n\t\tswitch (c->bandwidth_hz) {\n\t\tcase 6000000:\n\t\t\tif (c->frequency < 600000000) {\n\t\t\t\tutmp = 18;\n\t\t\t\tutmp2 = 22;\n\t\t\t} else if (c->frequency < 800000000) {\n\t\t\t\tutmp = 16;\n\t\t\t\tutmp2 = 20;\n\t\t\t} else {\n\t\t\t\tutmp = 14;\n\t\t\t\tutmp2 = 16;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tutmp = (c->frequency < 320000000) ? 16 : 18;\n\t\t\tutmp2 = (c->frequency < 320000000) ? 18 : 20;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tret = regmap_write_bits(dev->regmap, R58_AGC2_UP1, 0x1f, utmp2+8);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write_bits(dev->regmap, R13_AGC22, 0x1f, utmp);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write_bits(dev->regmap, R14_AGC23, 0x1f, utmp2);\n\tif (ret)\n\t\tgoto err;\n\n\tswitch (c->delivery_system) {\n\tcase SYS_ATSC:\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tutmp = 98;\n\t\tbreak;\n\tdefault:  \n\t\tutmp = 90;\n\t\tbreak;\n\t}\n\tret = regmap_write_bits(dev->regmap, R16_AGC25, 0xf8, utmp);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write_bits(dev->regmap, R12_AGC21, 0x60,\n\t\t\t(c->frequency > 800000000) ? 0x40 : 0x20);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tswitch (c->delivery_system) {\n\tcase SYS_ATSC:\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tutmp = (c->frequency < 320000000) ? 5 : 7;\n\t\tutmp2 = (c->frequency < 320000000) ? 10 : 12;\n\t\tbreak;\n\tdefault:  \n\t\tutmp = 7;\n\t\tutmp2 = 12;\n\t\tbreak;\n\t}\n\tret = regmap_write(dev->regmap, R17_AGC31, (utmp << 4) | utmp2);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tswitch (c->delivery_system) {\n\tcase SYS_ATSC:\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tif (c->bandwidth_hz == 8000000)\n\t\t\tutmp = 0x04;\n\t\telse\n\t\t\tutmp = (c->frequency < 320000000) ? 0x04 : 0x02;\n\t\tbreak;\n\tdefault:  \n\t\tif (c->bandwidth_hz == 6000000)\n\t\t\tutmp = ((c->frequency > 172544000) &&\n\t\t\t\t(c->frequency < 320000000)) ? 0x04 : 0x02;\n\t\telse  \n\t\t\tutmp = ((c->frequency > 320000000) &&\n\t\t\t\t(c->frequency < 600000000)) ? 0x02 : 0x04;\n\t\tbreak;\n\t}\n\tret = regmap_write_bits(dev->regmap, R20_IR_MIX, 0x06, utmp);\n\tif (ret)\n\t\tgoto err;\n\n\tswitch (c->delivery_system) {\n\tcase SYS_ATSC:\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tutmp = 0;\n\t\tbreak;\n\tdefault:  \n\t\tutmp = (c->frequency < 600000000) ? 0 : 3;\n\t\tbreak;\n\t}\n\tret = regmap_write_bits(dev->regmap, R16_AGC25, 0x03, utmp);\n\tif (ret)\n\t\tgoto err;\n\n\tutmp = 0x09;\n\tswitch (c->delivery_system) {\n\tcase SYS_ATSC:\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tif (c->bandwidth_hz == 8000000)\n\t\t\tutmp = 0x0c;\n\t\tbreak;\n\tdefault:  \n\t\tutmp = 0x0c;\n\t\tbreak;\n\t}\n\tret = regmap_write_bits(dev->regmap, R0F_AGC14, 0x3f, utmp);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\", ret);\n\treturn ret;\n}\n\nstatic int tda18250_pll_calc(struct dvb_frontend *fe, u8 *rdiv,\n\t\tu8 *ndiv, u8 *icp)\n{\n\tstruct i2c_client *client = fe->tuner_priv;\n\tstruct tda18250_dev *dev = i2c_get_clientdata(client);\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret;\n\tunsigned int uval, exp, lopd, scale;\n\tunsigned long fvco;\n\n\tret = regmap_read(dev->regmap, R34_MD1, &uval);\n\tif (ret)\n\t\tgoto err;\n\n\texp = (uval & 0x70) >> 4;\n\tif (exp > 5)\n\t\texp = 0;\n\tlopd = 1 << (exp - 1);\n\tscale = uval & 0x0f;\n\tfvco = lopd * scale * ((c->frequency / 1000) + dev->if_frequency);\n\n\tswitch (dev->xtal_freq) {\n\tcase TDA18250_XTAL_FREQ_16MHZ:\n\t\t*rdiv = 1;\n\t\t*ndiv = 0;\n\t\t*icp = (fvco < 6622000) ? 0x05 : 0x02;\n\tbreak;\n\tcase TDA18250_XTAL_FREQ_24MHZ:\n\tcase TDA18250_XTAL_FREQ_25MHZ:\n\t\t*rdiv = 3;\n\t\t*ndiv = 1;\n\t\t*icp = (fvco < 6622000) ? 0x05 : 0x02;\n\tbreak;\n\tcase TDA18250_XTAL_FREQ_27MHZ:\n\t\tif (fvco < 6643000) {\n\t\t\t*rdiv = 2;\n\t\t\t*ndiv = 0;\n\t\t\t*icp = 0x05;\n\t\t} else if (fvco < 6811000) {\n\t\t\t*rdiv = 2;\n\t\t\t*ndiv = 0;\n\t\t\t*icp = 0x06;\n\t\t} else {\n\t\t\t*rdiv = 3;\n\t\t\t*ndiv = 1;\n\t\t\t*icp = 0x02;\n\t\t}\n\tbreak;\n\tcase TDA18250_XTAL_FREQ_30MHZ:\n\t\t*rdiv = 2;\n\t\t*ndiv = 0;\n\t\t*icp = (fvco < 6811000) ? 0x05 : 0x02;\n\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&client->dev,\n\t\t\t\"lopd=%d scale=%u fvco=%lu, rdiv=%d ndiv=%d icp=%d\",\n\t\t\tlopd, scale, fvco, *rdiv, *ndiv, *icp);\n\treturn 0;\nerr:\n\treturn ret;\n}\n\nstatic int tda18250_set_params(struct dvb_frontend *fe)\n{\n\tstruct i2c_client *client = fe->tuner_priv;\n\tstruct tda18250_dev *dev = i2c_get_clientdata(client);\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 if_khz;\n\tint ret;\n\tunsigned int i, j;\n\tu8 utmp;\n\tu8 buf[3];\n\n\t#define REG      0\n\t#define MASK     1\n\t#define DVBT_6   2\n\t#define DVBT_7   3\n\t#define DVBT_8   4\n\t#define DVBC_6   5\n\t#define DVBC_8   6\n\t#define ATSC     7\n\n\tstatic const u8 delsys_params[][16] = {\n\t\t[REG]    = { 0x22, 0x23, 0x24, 0x21, 0x0d, 0x0c, 0x0f, 0x14,\n\t\t\t     0x0e, 0x12, 0x58, 0x59, 0x1a, 0x19, 0x1e, 0x30 },\n\t\t[MASK]   = { 0x77, 0xff, 0xff, 0x87, 0xf0, 0x78, 0x07, 0xe0,\n\t\t\t     0x60, 0x0f, 0x60, 0x0f, 0x33, 0x30, 0x80, 0x06 },\n\t\t[DVBT_6] = { 0x51, 0x03, 0x83, 0x82, 0x40, 0x48, 0x01, 0xe0,\n\t\t\t     0x60, 0x0f, 0x60, 0x05, 0x03, 0x10, 0x00, 0x04 },\n\t\t[DVBT_7] = { 0x52, 0x03, 0x85, 0x82, 0x40, 0x48, 0x01, 0xe0,\n\t\t\t     0x60, 0x0f, 0x60, 0x05, 0x03, 0x10, 0x00, 0x04 },\n\t\t[DVBT_8] = { 0x53, 0x03, 0x87, 0x82, 0x40, 0x48, 0x06, 0xe0,\n\t\t\t     0x60, 0x07, 0x60, 0x05, 0x03, 0x10, 0x00, 0x04 },\n\t\t[DVBC_6] = { 0x32, 0x05, 0x86, 0x82, 0x50, 0x00, 0x06, 0x60,\n\t\t\t     0x40, 0x0e, 0x60, 0x05, 0x33, 0x10, 0x00, 0x04 },\n\t\t[DVBC_8] = { 0x53, 0x03, 0x88, 0x82, 0x50, 0x00, 0x06, 0x60,\n\t\t\t     0x40, 0x0e, 0x60, 0x05, 0x33, 0x10, 0x00, 0x04 },\n\t\t[ATSC]   = { 0x51, 0x03, 0x83, 0x82, 0x40, 0x48, 0x01, 0xe0,\n\t\t\t     0x40, 0x0e, 0x60, 0x05, 0x03, 0x00, 0x80, 0x04 },\n\t};\n\n\tdev_dbg(&client->dev,\n\t\t\t\"delivery_system=%d frequency=%u bandwidth_hz=%u\",\n\t\t\tc->delivery_system, c->frequency, c->bandwidth_hz);\n\n\n\tswitch (c->delivery_system) {\n\tcase SYS_ATSC:\n\t\tj = ATSC;\n\t\tif_khz = dev->if_atsc;\n\t\tbreak;\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tif (c->bandwidth_hz == 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t} else if (c->bandwidth_hz <= 6000000) {\n\t\t\tj = DVBT_6;\n\t\t\tif_khz = dev->if_dvbt_6;\n\t\t} else if (c->bandwidth_hz <= 7000000) {\n\t\t\tj = DVBT_7;\n\t\t\tif_khz = dev->if_dvbt_7;\n\t\t} else if (c->bandwidth_hz <= 8000000) {\n\t\t\tj = DVBT_8;\n\t\t\tif_khz = dev->if_dvbt_8;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\tcase SYS_DVBC_ANNEX_C:\n\t\tif (c->bandwidth_hz == 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t} else if (c->bandwidth_hz <= 6000000) {\n\t\t\tj = DVBC_6;\n\t\t\tif_khz = dev->if_dvbc_6;\n\t\t} else if (c->bandwidth_hz <= 8000000) {\n\t\t\tj = DVBC_8;\n\t\t\tif_khz = dev->if_dvbc_8;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(&client->dev, \"unsupported delivery system=%d\",\n\t\t\t\tc->delivery_system);\n\t\tgoto err;\n\t}\n\n\t \n\tfor (i = 0; i < 16; i++) {\n\t\tret = regmap_write_bits(dev->regmap, delsys_params[REG][i],\n\t\t\t delsys_params[MASK][i],  delsys_params[j][i]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tif (dev->if_frequency != if_khz) {\n\t\tutmp = DIV_ROUND_CLOSEST(if_khz, 50);\n\t\tret = regmap_write(dev->regmap, R26_IF, utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tdev->if_frequency = if_khz;\n\t\tdev_dbg(&client->dev, \"set IF=%u kHz\", if_khz);\n\n\t}\n\n\tret = tda18250_set_agc(fe);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write_bits(dev->regmap, R1A_AGCK, 0x03, 0x01);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write_bits(dev->regmap, R14_AGC23, 0x40, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tbuf[0] = ((c->frequency / 1000) >> 16) & 0xff;\n\tbuf[1] = ((c->frequency / 1000) >>  8) & 0xff;\n\tbuf[2] = ((c->frequency / 1000) >>  0) & 0xff;\n\tret = regmap_bulk_write(dev->regmap, R27_RF1, buf, 3);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, R0A_IRQ3, TDA18250_IRQ_TUNE);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_write(dev->regmap, R2A_MSM1, 0x01);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, R2B_MSM2, 0x01);\n\tif (ret)\n\t\tgoto err;\n\n\tret = tda18250_wait_for_irq(fe, 500, 10, TDA18250_IRQ_TUNE);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = tda18250_pll_calc(fe, &buf[0], &buf[1], &buf[2]);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write_bits(dev->regmap, R4F_XTALFLX3, 0xe0,\n\t\t\t(buf[0] << 6) | (buf[1] << 5));\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_write(dev->regmap, R0A_IRQ3, TDA18250_IRQ_TUNE);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write_bits(dev->regmap, R46_CPUMP, 0x07, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write_bits(dev->regmap, R39_SD5, 0x03, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_write(dev->regmap, R2A_MSM1, 0x01);  \n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, R2B_MSM2, 0x01);  \n\tif (ret)\n\t\tgoto err;\n\n\tret = tda18250_wait_for_irq(fe, 500, 10, TDA18250_IRQ_TUNE);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tmsleep(20);\n\n\tret = regmap_write_bits(dev->regmap, R2B_MSM2, 0x04, 0x04);\n\tif (ret)\n\t\tgoto err;\n\n\tmsleep(20);\n\n\t \n\tret = regmap_write_bits(dev->regmap, R1A_AGCK, 0x03, 0x03);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write_bits(dev->regmap, R14_AGC23, 0x40, 0x40);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_write_bits(dev->regmap, R46_CPUMP, 0x07, buf[2]);\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\nstatic int tda18250_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct i2c_client *client = fe->tuner_priv;\n\tstruct tda18250_dev *dev = i2c_get_clientdata(client);\n\n\t*frequency = dev->if_frequency * 1000;\n\treturn 0;\n}\n\nstatic int tda18250_sleep(struct dvb_frontend *fe)\n{\n\tstruct i2c_client *client = fe->tuner_priv;\n\tstruct tda18250_dev *dev = i2c_get_clientdata(client);\n\tint ret;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tret = regmap_write_bits(dev->regmap, R0C_AGC11, 0x80, 0x00);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdev->if_frequency = 0;\n\n\tret = tda18250_power_control(fe, TDA18250_POWER_STANDBY);\n\treturn ret;\n}\n\nstatic const struct dvb_tuner_ops tda18250_ops = {\n\t.info = {\n\t\t.name              = \"NXP TDA18250\",\n\t\t.frequency_min_hz  =  42 * MHz,\n\t\t.frequency_max_hz  = 870 * MHz,\n\t},\n\n\t.init = tda18250_init,\n\t.set_params = tda18250_set_params,\n\t.get_if_frequency = tda18250_get_if_frequency,\n\t.sleep = tda18250_sleep,\n};\n\nstatic int tda18250_probe(struct i2c_client *client)\n{\n\tstruct tda18250_config *cfg = client->dev.platform_data;\n\tstruct dvb_frontend *fe = cfg->fe;\n\tstruct tda18250_dev *dev;\n\tint ret;\n\tunsigned char chip_id[3];\n\n\t \n\tstatic const struct regmap_range tda18250_yes_ranges[] = {\n\t\tregmap_reg_range(R05_POWER1, R0B_IRQ4),\n\t\tregmap_reg_range(R21_IF_AGC, R21_IF_AGC),\n\t\tregmap_reg_range(R2A_MSM1, R2B_MSM2),\n\t\tregmap_reg_range(R2F_RSSI1, R31_IRQ_CTRL),\n\t};\n\n\tstatic const struct regmap_access_table tda18250_volatile_table = {\n\t\t.yes_ranges = tda18250_yes_ranges,\n\t\t.n_yes_ranges = ARRAY_SIZE(tda18250_yes_ranges),\n\t};\n\n\tstatic const struct regmap_config tda18250_regmap_config = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = TDA18250_NUM_REGS - 1,\n\t\t.volatile_table = &tda18250_volatile_table,\n\t};\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\ti2c_set_clientdata(client, dev);\n\n\tdev->fe = cfg->fe;\n\tdev->loopthrough = cfg->loopthrough;\n\tif (cfg->xtal_freq < TDA18250_XTAL_FREQ_MAX) {\n\t\tdev->xtal_freq = cfg->xtal_freq;\n\t} else {\n\t\tret = -EINVAL;\n\t\tdev_err(&client->dev, \"xtal_freq invalid=%d\", cfg->xtal_freq);\n\t\tgoto err_kfree;\n\t}\n\tdev->if_dvbt_6 = cfg->if_dvbt_6;\n\tdev->if_dvbt_7 = cfg->if_dvbt_7;\n\tdev->if_dvbt_8 = cfg->if_dvbt_8;\n\tdev->if_dvbc_6 = cfg->if_dvbc_6;\n\tdev->if_dvbc_8 = cfg->if_dvbc_8;\n\tdev->if_atsc = cfg->if_atsc;\n\n\tdev->if_frequency = 0;\n\tdev->warm = false;\n\n\tdev->regmap = devm_regmap_init_i2c(client, &tda18250_regmap_config);\n\tif (IS_ERR(dev->regmap)) {\n\t\tret = PTR_ERR(dev->regmap);\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tregmap_bulk_read(dev->regmap, R00_ID1, &chip_id, 3);\n\tdev_dbg(&client->dev, \"chip_id=%02x:%02x:%02x\",\n\t\t\tchip_id[0], chip_id[1], chip_id[2]);\n\n\tswitch (chip_id[0]) {\n\tcase 0xc7:\n\t\tdev->slave = false;\n\t\tbreak;\n\tcase 0x47:\n\t\tdev->slave = true;\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODEV;\n\t\tgoto err_kfree;\n\t}\n\n\tif (chip_id[1] != 0x4a) {\n\t\tret = -ENODEV;\n\t\tgoto err_kfree;\n\t}\n\n\tswitch (chip_id[2]) {\n\tcase 0x20:\n\t\tdev_info(&client->dev,\n\t\t\t\t\"NXP TDA18250AHN/%s successfully identified\",\n\t\t\t\tdev->slave ? \"S\" : \"M\");\n\t\tbreak;\n\tcase 0x21:\n\t\tdev_info(&client->dev,\n\t\t\t\t\"NXP TDA18250BHN/%s successfully identified\",\n\t\t\t\tdev->slave ? \"S\" : \"M\");\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODEV;\n\t\tgoto err_kfree;\n\t}\n\n\tfe->tuner_priv = client;\n\tmemcpy(&fe->ops.tuner_ops, &tda18250_ops,\n\t\t\tsizeof(struct dvb_tuner_ops));\n\n\t \n\ttda18250_power_control(fe, TDA18250_POWER_STANDBY);\n\n\treturn 0;\nerr_kfree:\n\tkfree(dev);\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\", ret);\n\treturn ret;\n}\n\nstatic void tda18250_remove(struct i2c_client *client)\n{\n\tstruct tda18250_dev *dev = i2c_get_clientdata(client);\n\tstruct dvb_frontend *fe = dev->fe;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tmemset(&fe->ops.tuner_ops, 0, sizeof(struct dvb_tuner_ops));\n\tfe->tuner_priv = NULL;\n\tkfree(dev);\n}\n\nstatic const struct i2c_device_id tda18250_id_table[] = {\n\t{\"tda18250\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, tda18250_id_table);\n\nstatic struct i2c_driver tda18250_driver = {\n\t.driver = {\n\t\t.name\t= \"tda18250\",\n\t},\n\t.probe\t\t= tda18250_probe,\n\t.remove\t\t= tda18250_remove,\n\t.id_table\t= tda18250_id_table,\n};\n\nmodule_i2c_driver(tda18250_driver);\n\nMODULE_DESCRIPTION(\"NXP TDA18250 silicon tuner driver\");\nMODULE_AUTHOR(\"Olli Salonen <olli.salonen@iki.fi>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}