{
  "module_name": "qm1d1c0042.c",
  "hash_id": "ebfa29764a3dc50ff679bd36003aee3d410f4afc5c93505e986111f050afdb42",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/qm1d1c0042.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include \"qm1d1c0042.h\"\n\n#define QM1D1C0042_NUM_REGS 0x20\n#define QM1D1C0042_NUM_REG_ROWS 2\n\nstatic const u8\nreg_initval[QM1D1C0042_NUM_REG_ROWS][QM1D1C0042_NUM_REGS] = { {\n\t\t0x48, 0x1c, 0xa0, 0x10, 0xbc, 0xc5, 0x20, 0x33,\n\t\t0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,\n\t\t0x00, 0xff, 0xf3, 0x00, 0x2a, 0x64, 0xa6, 0x86,\n\t\t0x8c, 0xcf, 0xb8, 0xf1, 0xa8, 0xf2, 0x89, 0x00\n\t}, {\n\t\t0x68, 0x1c, 0xc0, 0x10, 0xbc, 0xc1, 0x11, 0x33,\n\t\t0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,\n\t\t0x00, 0xff, 0xf3, 0x00, 0x3f, 0x25, 0x5c, 0xd6,\n\t\t0x55, 0xcf, 0x95, 0xf6, 0x36, 0xf2, 0x09, 0x00\n\t}\n};\n\nstatic int reg_index;\n\nstatic const struct qm1d1c0042_config default_cfg = {\n\t.xtal_freq = 16000,\n\t.lpf = 1,\n\t.fast_srch = 0,\n\t.lpf_wait = 20,\n\t.fast_srch_wait = 4,\n\t.normal_srch_wait = 15,\n};\n\nstruct qm1d1c0042_state {\n\tstruct qm1d1c0042_config cfg;\n\tstruct i2c_client *i2c;\n\tu8 regs[QM1D1C0042_NUM_REGS];\n};\n\nstatic struct qm1d1c0042_state *cfg_to_state(struct qm1d1c0042_config *c)\n{\n\treturn container_of(c, struct qm1d1c0042_state, cfg);\n}\n\nstatic int reg_write(struct qm1d1c0042_state *state, u8 reg, u8 val)\n{\n\tu8 wbuf[2] = { reg, val };\n\tint ret;\n\n\tret = i2c_master_send(state->i2c, wbuf, sizeof(wbuf));\n\tif (ret >= 0 && ret < sizeof(wbuf))\n\t\tret = -EIO;\n\treturn (ret == sizeof(wbuf)) ? 0 : ret;\n}\n\nstatic int reg_read(struct qm1d1c0042_state *state, u8 reg, u8 *val)\n{\n\tstruct i2c_msg msgs[2] = {\n\t\t{\n\t\t\t.addr = state->i2c->addr,\n\t\t\t.flags = 0,\n\t\t\t.buf = &reg,\n\t\t\t.len = 1,\n\t\t},\n\t\t{\n\t\t\t.addr = state->i2c->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = val,\n\t\t\t.len = 1,\n\t\t},\n\t};\n\tint ret;\n\n\tret = i2c_transfer(state->i2c->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret >= 0 && ret < ARRAY_SIZE(msgs))\n\t\tret = -EIO;\n\treturn (ret == ARRAY_SIZE(msgs)) ? 0 : ret;\n}\n\n\nstatic int qm1d1c0042_set_srch_mode(struct qm1d1c0042_state *state, bool fast)\n{\n\tif (fast)\n\t\tstate->regs[0x03] |= 0x01;  \n\telse\n\t\tstate->regs[0x03] &= ~0x01 & 0xff;\n\n\treturn reg_write(state, 0x03, state->regs[0x03]);\n}\n\nstatic int qm1d1c0042_wakeup(struct qm1d1c0042_state *state)\n{\n\tint ret;\n\n\tstate->regs[0x01] |= 1 << 3;              \n\tstate->regs[0x01] &= (~(1 << 0)) & 0xff;  \n\tstate->regs[0x05] &= (~(1 << 3)) & 0xff;  \n\tret = reg_write(state, 0x01, state->regs[0x01]);\n\tif (ret == 0)\n\t\tret = reg_write(state, 0x05, state->regs[0x05]);\n\n\tif (ret < 0)\n\t\tdev_warn(&state->i2c->dev, \"(%s) failed. [adap%d-fe%d]\\n\",\n\t\t\t__func__, state->cfg.fe->dvb->num, state->cfg.fe->id);\n\treturn ret;\n}\n\n \n\nstatic int qm1d1c0042_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct qm1d1c0042_state *state;\n\tstruct qm1d1c0042_config *cfg;\n\n\tstate = fe->tuner_priv;\n\tcfg = priv_cfg;\n\n\tif (cfg->fe)\n\t\tstate->cfg.fe = cfg->fe;\n\n\tif (cfg->xtal_freq != QM1D1C0042_CFG_XTAL_DFLT)\n\t\tdev_warn(&state->i2c->dev,\n\t\t\t\"(%s) changing xtal_freq not supported. \", __func__);\n\tstate->cfg.xtal_freq = default_cfg.xtal_freq;\n\n\tstate->cfg.lpf = cfg->lpf;\n\tstate->cfg.fast_srch = cfg->fast_srch;\n\n\tif (cfg->lpf_wait != QM1D1C0042_CFG_WAIT_DFLT)\n\t\tstate->cfg.lpf_wait = cfg->lpf_wait;\n\telse\n\t\tstate->cfg.lpf_wait = default_cfg.lpf_wait;\n\n\tif (cfg->fast_srch_wait != QM1D1C0042_CFG_WAIT_DFLT)\n\t\tstate->cfg.fast_srch_wait = cfg->fast_srch_wait;\n\telse\n\t\tstate->cfg.fast_srch_wait = default_cfg.fast_srch_wait;\n\n\tif (cfg->normal_srch_wait != QM1D1C0042_CFG_WAIT_DFLT)\n\t\tstate->cfg.normal_srch_wait = cfg->normal_srch_wait;\n\telse\n\t\tstate->cfg.normal_srch_wait = default_cfg.normal_srch_wait;\n\treturn 0;\n}\n\n \n \nstatic const u32 conv_table[9][3] = {\n\t{ 2151000, 1, 7 },\n\t{ 1950000, 1, 6 },\n\t{ 1800000, 1, 5 },\n\t{ 1600000, 1, 4 },\n\t{ 1450000, 1, 3 },\n\t{ 1250000, 1, 2 },\n\t{ 1200000, 0, 7 },\n\t{  975000, 0, 6 },\n\t{  950000, 0, 0 }\n};\n\nstatic int qm1d1c0042_set_params(struct dvb_frontend *fe)\n{\n\tstruct qm1d1c0042_state *state;\n\tu32 freq;\n\tint i, ret;\n\tu8 val, mask;\n\tu32 a, sd;\n\ts32 b;\n\n\tstate = fe->tuner_priv;\n\tfreq = fe->dtv_property_cache.frequency;\n\n\tstate->regs[0x08] &= 0xf0;\n\tstate->regs[0x08] |= 0x09;\n\n\tstate->regs[0x13] &= 0x9f;\n\tstate->regs[0x13] |= 0x20;\n\n\t \n\tval = state->regs[0x02] & 0x0f;\n\tfor (i = 0; i < 8; i++)\n\t\tif (freq < conv_table[i][0] && freq >= conv_table[i + 1][0]) {\n\t\t\tval |= conv_table[i][1] << 7;\n\t\t\tval |= conv_table[i][2] << 4;\n\t\t\tbreak;\n\t\t}\n\tret = reg_write(state, 0x02, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ta = DIV_ROUND_CLOSEST(freq, state->cfg.xtal_freq);\n\n\tstate->regs[0x06] &= 0x40;\n\tstate->regs[0x06] |= (a - 12) / 4;\n\tret = reg_write(state, 0x06, state->regs[0x06]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstate->regs[0x07] &= 0xf0;\n\tstate->regs[0x07] |= (a - 4 * ((a - 12) / 4 + 1) - 5) & 0x0f;\n\tret = reg_write(state, 0x07, state->regs[0x07]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tval = state->regs[0x08];\n\tif (state->cfg.lpf) {\n\t\t \n\t\tval &= 0xf0;\n\t\tval |= 0x02;\n\t}\n\tret = reg_write(state, 0x08, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tb = (s32)div64_s64(((s64) freq) << 20, state->cfg.xtal_freq)\n\t\t\t   - (((s64) a) << 20);\n\n\tif (b >= 0)\n\t\tsd = b;\n\telse\n\t\tsd = (1 << 22) + b;\n\n\tstate->regs[0x09] &= 0xc0;\n\tstate->regs[0x09] |= (sd >> 16) & 0x3f;\n\tstate->regs[0x0a] = (sd >> 8) & 0xff;\n\tstate->regs[0x0b] = sd & 0xff;\n\tret = reg_write(state, 0x09, state->regs[0x09]);\n\tif (ret == 0)\n\t\tret = reg_write(state, 0x0a, state->regs[0x0a]);\n\tif (ret == 0)\n\t\tret = reg_write(state, 0x0b, state->regs[0x0b]);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (!state->cfg.lpf) {\n\t\t \n\t\tret = reg_write(state, 0x13, state->regs[0x13]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tmask = state->cfg.lpf ? 0x3f : 0x7f;\n\tval = state->regs[0x0c] & mask;\n\tret = reg_write(state, 0x0c, val);\n\tif (ret < 0)\n\t\treturn ret;\n\tusleep_range(2000, 3000);\n\tval = state->regs[0x0c] | ~mask;\n\tret = reg_write(state, 0x0c, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (state->cfg.lpf)\n\t\tmsleep(state->cfg.lpf_wait);\n\telse if (state->regs[0x03] & 0x01)\n\t\tmsleep(state->cfg.fast_srch_wait);\n\telse\n\t\tmsleep(state->cfg.normal_srch_wait);\n\n\tif (state->cfg.lpf) {\n\t\t \n\t\tret = reg_write(state, 0x08, 0x09);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = reg_write(state, 0x13, state->regs[0x13]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int qm1d1c0042_sleep(struct dvb_frontend *fe)\n{\n\tstruct qm1d1c0042_state *state;\n\tint ret;\n\n\tstate = fe->tuner_priv;\n\tstate->regs[0x01] &= (~(1 << 3)) & 0xff;  \n\tstate->regs[0x01] |= 1 << 0;              \n\tstate->regs[0x05] |= 1 << 3;              \n\tret = reg_write(state, 0x05, state->regs[0x05]);\n\tif (ret == 0)\n\t\tret = reg_write(state, 0x01, state->regs[0x01]);\n\tif (ret < 0)\n\t\tdev_warn(&state->i2c->dev, \"(%s) failed. [adap%d-fe%d]\\n\",\n\t\t\t__func__, fe->dvb->num, fe->id);\n\treturn ret;\n}\n\nstatic int qm1d1c0042_init(struct dvb_frontend *fe)\n{\n\tstruct qm1d1c0042_state *state;\n\tu8 val;\n\tint i, ret;\n\n\tstate = fe->tuner_priv;\n\n\treg_write(state, 0x01, 0x0c);\n\treg_write(state, 0x01, 0x0c);\n\n\tret = reg_write(state, 0x01, 0x0c);  \n\tif (ret < 0)\n\t\tgoto failed;\n\tusleep_range(2000, 3000);\n\n\tret = reg_write(state, 0x01, 0x1c);  \n\tif (ret < 0)\n\t\tgoto failed;\n\n\t \n\tret = reg_read(state, 0x00, &val);\n\tif (ret < 0)\n\t\tgoto failed;\n\tfor (reg_index = 0; reg_index < QM1D1C0042_NUM_REG_ROWS;\n\t     reg_index++) {\n\t\tif (val == reg_initval[reg_index][0x00])\n\t\t\tbreak;\n\t}\n\tif (reg_index >= QM1D1C0042_NUM_REG_ROWS) {\n\t\tret = -EINVAL;\n\t\tgoto failed;\n\t}\n\tmemcpy(state->regs, reg_initval[reg_index], QM1D1C0042_NUM_REGS);\n\tusleep_range(2000, 3000);\n\n\tstate->regs[0x0c] |= 0x40;\n\tret = reg_write(state, 0x0c, state->regs[0x0c]);\n\tif (ret < 0)\n\t\tgoto failed;\n\tmsleep(state->cfg.lpf_wait);\n\n\t \n\tfor (i = 1; i <= 0x0c ; i++) {\n\t\tret = reg_write(state, i, state->regs[i]);\n\t\tif (ret < 0)\n\t\t\tgoto failed;\n\t}\n\tfor (i = 0x11; i < QM1D1C0042_NUM_REGS; i++) {\n\t\tret = reg_write(state, i, state->regs[i]);\n\t\tif (ret < 0)\n\t\t\tgoto failed;\n\t}\n\n\tret = qm1d1c0042_wakeup(state);\n\tif (ret < 0)\n\t\tgoto failed;\n\n\tret = qm1d1c0042_set_srch_mode(state, state->cfg.fast_srch);\n\tif (ret < 0)\n\t\tgoto failed;\n\n\treturn ret;\n\nfailed:\n\tdev_warn(&state->i2c->dev, \"(%s) failed. [adap%d-fe%d]\\n\",\n\t\t__func__, fe->dvb->num, fe->id);\n\treturn ret;\n}\n\n \n\nstatic const struct dvb_tuner_ops qm1d1c0042_ops = {\n\t.info = {\n\t\t.name = \"Sharp QM1D1C0042\",\n\n\t\t.frequency_min_hz =  950 * MHz,\n\t\t.frequency_max_hz = 2150 * MHz,\n\t},\n\n\t.init = qm1d1c0042_init,\n\t.sleep = qm1d1c0042_sleep,\n\t.set_config = qm1d1c0042_set_config,\n\t.set_params = qm1d1c0042_set_params,\n};\n\n\nstatic int qm1d1c0042_probe(struct i2c_client *client)\n{\n\tstruct qm1d1c0042_state *state;\n\tstruct qm1d1c0042_config *cfg;\n\tstruct dvb_frontend *fe;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\tstate->i2c = client;\n\n\tcfg = client->dev.platform_data;\n\tfe = cfg->fe;\n\tfe->tuner_priv = state;\n\tqm1d1c0042_set_config(fe, cfg);\n\tmemcpy(&fe->ops.tuner_ops, &qm1d1c0042_ops, sizeof(qm1d1c0042_ops));\n\n\ti2c_set_clientdata(client, &state->cfg);\n\tdev_info(&client->dev, \"Sharp QM1D1C0042 attached.\\n\");\n\treturn 0;\n}\n\nstatic void qm1d1c0042_remove(struct i2c_client *client)\n{\n\tstruct qm1d1c0042_state *state;\n\n\tstate = cfg_to_state(i2c_get_clientdata(client));\n\tstate->cfg.fe->tuner_priv = NULL;\n\tkfree(state);\n}\n\n\nstatic const struct i2c_device_id qm1d1c0042_id[] = {\n\t{\"qm1d1c0042\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, qm1d1c0042_id);\n\nstatic struct i2c_driver qm1d1c0042_driver = {\n\t.driver = {\n\t\t.name\t= \"qm1d1c0042\",\n\t},\n\t.probe\t\t= qm1d1c0042_probe,\n\t.remove\t\t= qm1d1c0042_remove,\n\t.id_table\t= qm1d1c0042_id,\n};\n\nmodule_i2c_driver(qm1d1c0042_driver);\n\nMODULE_DESCRIPTION(\"Sharp QM1D1C0042 tuner\");\nMODULE_AUTHOR(\"Akihiro TSUKADA\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}