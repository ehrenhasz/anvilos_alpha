{
  "module_name": "fc0011.c",
  "hash_id": "e80debb1162304059b04415ff066da93db1e4b2b820c4dd50e17b3ae3c856bbe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/fc0011.c",
  "human_readable_source": "\n \n\n#include \"fc0011.h\"\n\n\n \nenum {\n\tFC11_REG_0,\n\tFC11_REG_FA,\t\t \n\tFC11_REG_FP,\t\t \n\tFC11_REG_XINHI,\t\t \n\tFC11_REG_XINLO,\t\t \n\tFC11_REG_VCO,\t\t \n\tFC11_REG_VCOSEL,\t \n\tFC11_REG_7,\t\t \n\tFC11_REG_8,\t\t \n\tFC11_REG_9,\n\tFC11_REG_10,\t\t \n\tFC11_REG_11,\t\t \n\tFC11_REG_12,\n\tFC11_REG_RCCAL,\t\t \n\tFC11_REG_VCOCAL,\t \n\tFC11_REG_15,\n\tFC11_REG_16,\t\t \n\tFC11_REG_17,\n\n\tFC11_NR_REGS,\t\t \n};\n\nenum FC11_REG_VCOSEL_bits {\n\tFC11_VCOSEL_2\t\t= 0x08,  \n\tFC11_VCOSEL_1\t\t= 0x10,  \n\tFC11_VCOSEL_CLKOUT\t= 0x20,  \n\tFC11_VCOSEL_BW7M\t= 0x40,  \n\tFC11_VCOSEL_BW6M\t= 0x80,  \n};\n\nenum FC11_REG_RCCAL_bits {\n\tFC11_RCCAL_FORCE\t= 0x10,  \n};\n\nenum FC11_REG_VCOCAL_bits {\n\tFC11_VCOCAL_RUN\t\t= 0,\t \n\tFC11_VCOCAL_VALUEMASK\t= 0x3F,\t \n\tFC11_VCOCAL_OK\t\t= 0x40,\t \n\tFC11_VCOCAL_RESET\t= 0x80,  \n};\n\n\nstruct fc0011_priv {\n\tstruct i2c_adapter *i2c;\n\tu8 addr;\n\n\tu32 frequency;\n\tu32 bandwidth;\n};\n\n\nstatic int fc0011_writereg(struct fc0011_priv *priv, u8 reg, u8 val)\n{\n\tu8 buf[2] = { reg, val };\n\tstruct i2c_msg msg = { .addr = priv->addr,\n\t\t.flags = 0, .buf = buf, .len = 2 };\n\n\tif (i2c_transfer(priv->i2c, &msg, 1) != 1) {\n\t\tdev_err(&priv->i2c->dev,\n\t\t\t\"I2C write reg failed, reg: %02x, val: %02x\\n\",\n\t\t\treg, val);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int fc0011_readreg(struct fc0011_priv *priv, u8 reg, u8 *val)\n{\n\tu8 dummy;\n\tstruct i2c_msg msg[2] = {\n\t\t{ .addr = priv->addr,\n\t\t  .flags = 0, .buf = &reg, .len = 1 },\n\t\t{ .addr = priv->addr,\n\t\t  .flags = I2C_M_RD, .buf = val ? : &dummy, .len = 1 },\n\t};\n\n\tif (i2c_transfer(priv->i2c, msg, 2) != 2) {\n\t\tdev_err(&priv->i2c->dev,\n\t\t\t\"I2C read failed, reg: %02x\\n\", reg);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void fc0011_release(struct dvb_frontend *fe)\n{\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic int fc0011_init(struct dvb_frontend *fe)\n{\n\tstruct fc0011_priv *priv = fe->tuner_priv;\n\tint err;\n\n\tif (WARN_ON(!fe->callback))\n\t\treturn -EINVAL;\n\n\terr = fe->callback(priv->i2c, DVB_FRONTEND_COMPONENT_TUNER,\n\t\t\t   FC0011_FE_CALLBACK_POWER, priv->addr);\n\tif (err) {\n\t\tdev_err(&priv->i2c->dev, \"Power-on callback failed\\n\");\n\t\treturn err;\n\t}\n\terr = fe->callback(priv->i2c, DVB_FRONTEND_COMPONENT_TUNER,\n\t\t\t   FC0011_FE_CALLBACK_RESET, priv->addr);\n\tif (err) {\n\t\tdev_err(&priv->i2c->dev, \"Reset callback failed\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int fc0011_vcocal_trigger(struct fc0011_priv *priv)\n{\n\tint err;\n\n\terr = fc0011_writereg(priv, FC11_REG_VCOCAL, FC11_VCOCAL_RESET);\n\tif (err)\n\t\treturn err;\n\terr = fc0011_writereg(priv, FC11_REG_VCOCAL, FC11_VCOCAL_RUN);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \nstatic int fc0011_vcocal_read(struct fc0011_priv *priv, u8 *value)\n{\n\tint err;\n\n\terr = fc0011_writereg(priv, FC11_REG_VCOCAL, FC11_VCOCAL_RUN);\n\tif (err)\n\t\treturn err;\n\tusleep_range(10000, 20000);\n\terr = fc0011_readreg(priv, FC11_REG_VCOCAL, value);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int fc0011_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct fc0011_priv *priv = fe->tuner_priv;\n\tint err;\n\tunsigned int i, vco_retries;\n\tu32 freq = p->frequency / 1000;\n\tu32 bandwidth = p->bandwidth_hz / 1000;\n\tu32 fvco, xin, frac, xdiv, xdivr;\n\tu8 fa, fp, vco_sel, vco_cal;\n\tu8 regs[FC11_NR_REGS] = { };\n\n\tregs[FC11_REG_7] = 0x0F;\n\tregs[FC11_REG_8] = 0x3E;\n\tregs[FC11_REG_10] = 0xB8;\n\tregs[FC11_REG_11] = 0x80;\n\tregs[FC11_REG_RCCAL] = 0x04;\n\terr = fc0011_writereg(priv, FC11_REG_7, regs[FC11_REG_7]);\n\terr |= fc0011_writereg(priv, FC11_REG_8, regs[FC11_REG_8]);\n\terr |= fc0011_writereg(priv, FC11_REG_10, regs[FC11_REG_10]);\n\terr |= fc0011_writereg(priv, FC11_REG_11, regs[FC11_REG_11]);\n\terr |= fc0011_writereg(priv, FC11_REG_RCCAL, regs[FC11_REG_RCCAL]);\n\tif (err)\n\t\treturn -EIO;\n\n\t \n\tif (freq < 54000) {\n\t\tfvco = freq * 64;\n\t\tregs[FC11_REG_VCO] = 0x82;\n\t} else if (freq < 108000) {\n\t\tfvco = freq * 32;\n\t\tregs[FC11_REG_VCO] = 0x42;\n\t} else if (freq < 216000) {\n\t\tfvco = freq * 16;\n\t\tregs[FC11_REG_VCO] = 0x22;\n\t} else if (freq < 432000) {\n\t\tfvco = freq * 8;\n\t\tregs[FC11_REG_VCO] = 0x12;\n\t} else {\n\t\tfvco = freq * 4;\n\t\tregs[FC11_REG_VCO] = 0x0A;\n\t}\n\n\t \n\txdiv = fvco / 18000;\n\tWARN_ON(xdiv > 0xFF);\n\tfrac = fvco - xdiv * 18000;\n\tfrac = (frac << 15) / 18000;\n\tif (frac >= 16384)\n\t\tfrac += 32786;\n\tif (!frac)\n\t\txin = 0;\n\telse\n\t\txin = clamp_t(u32, frac, 512, 65024);\n\tregs[FC11_REG_XINHI] = xin >> 8;\n\tregs[FC11_REG_XINLO] = xin;\n\n\t \n\txdivr = xdiv;\n\tif (fvco - xdiv * 18000 >= 9000)\n\t\txdivr += 1;  \n\tfp = xdivr / 8;\n\tfa = xdivr - fp * 8;\n\tif (fa < 2) {\n\t\tfp -= 1;\n\t\tfa += 8;\n\t}\n\tif (fp > 0x1F) {\n\t\tfp = 0x1F;\n\t\tfa = 0xF;\n\t}\n\tif (fa >= fp) {\n\t\tdev_warn(&priv->i2c->dev,\n\t\t\t \"fa %02X >= fp %02X, but trying to continue\\n\",\n\t\t\t (unsigned int)(u8)fa, (unsigned int)(u8)fp);\n\t}\n\tregs[FC11_REG_FA] = fa;\n\tregs[FC11_REG_FP] = fp;\n\n\t \n\tswitch (bandwidth) {\n\tcase 8000:\n\t\tbreak;\n\tcase 7000:\n\t\tregs[FC11_REG_VCOSEL] |= FC11_VCOSEL_BW7M;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&priv->i2c->dev, \"Unsupported bandwidth %u kHz. Using 6000 kHz.\\n\",\n\t\t\t bandwidth);\n\t\tbandwidth = 6000;\n\t\tfallthrough;\n\tcase 6000:\n\t\tregs[FC11_REG_VCOSEL] |= FC11_VCOSEL_BW6M;\n\t\tbreak;\n\t}\n\n\t \n\tif (fvco < 2320000) {\n\t\tvco_sel = 0;\n\t\tregs[FC11_REG_VCOSEL] &= ~(FC11_VCOSEL_1 | FC11_VCOSEL_2);\n\t} else if (fvco < 3080000) {\n\t\tvco_sel = 1;\n\t\tregs[FC11_REG_VCOSEL] &= ~(FC11_VCOSEL_1 | FC11_VCOSEL_2);\n\t\tregs[FC11_REG_VCOSEL] |= FC11_VCOSEL_1;\n\t} else {\n\t\tvco_sel = 2;\n\t\tregs[FC11_REG_VCOSEL] &= ~(FC11_VCOSEL_1 | FC11_VCOSEL_2);\n\t\tregs[FC11_REG_VCOSEL] |= FC11_VCOSEL_2;\n\t}\n\n\t \n\tif (freq < 45000) {\n\t\tregs[FC11_REG_FA] = 0x6;\n\t\tregs[FC11_REG_FP] = 0x11;\n\t}\n\n\t \n\tregs[FC11_REG_VCOSEL] |= FC11_VCOSEL_CLKOUT;\n\n\t \n\tfor (i = FC11_REG_FA; i <= FC11_REG_VCOSEL; i++) {\n\t\terr = fc0011_writereg(priv, i, regs[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = fc0011_vcocal_trigger(priv);\n\tif (err)\n\t\treturn err;\n\terr = fc0011_vcocal_read(priv, &vco_cal);\n\tif (err)\n\t\treturn err;\n\tvco_retries = 0;\n\twhile (!(vco_cal & FC11_VCOCAL_OK) && vco_retries < 3) {\n\t\t \n\t\terr = fe->callback(priv->i2c, DVB_FRONTEND_COMPONENT_TUNER,\n\t\t\t\t   FC0011_FE_CALLBACK_RESET, priv->addr);\n\t\tif (err) {\n\t\t\tdev_err(&priv->i2c->dev, \"Failed to reset tuner\\n\");\n\t\t\treturn err;\n\t\t}\n\t\t \n\t\terr = 0;\n\t\tfor (i = FC11_REG_FA; i <= FC11_REG_VCOSEL; i++)\n\t\t\terr |= fc0011_writereg(priv, i, regs[i]);\n\t\terr |= fc0011_writereg(priv, FC11_REG_7, regs[FC11_REG_7]);\n\t\terr |= fc0011_writereg(priv, FC11_REG_8, regs[FC11_REG_8]);\n\t\terr |= fc0011_writereg(priv, FC11_REG_10, regs[FC11_REG_10]);\n\t\terr |= fc0011_writereg(priv, FC11_REG_11, regs[FC11_REG_11]);\n\t\terr |= fc0011_writereg(priv, FC11_REG_RCCAL, regs[FC11_REG_RCCAL]);\n\t\tif (err)\n\t\t\treturn -EIO;\n\t\t \n\t\terr = fc0011_vcocal_trigger(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = fc0011_vcocal_read(priv, &vco_cal);\n\t\tif (err)\n\t\t\treturn err;\n\t\tvco_retries++;\n\t}\n\tif (!(vco_cal & FC11_VCOCAL_OK)) {\n\t\tdev_err(&priv->i2c->dev,\n\t\t\t\"Failed to read VCO calibration value (got %02X)\\n\",\n\t\t\t(unsigned int)vco_cal);\n\t\treturn -EIO;\n\t}\n\tvco_cal &= FC11_VCOCAL_VALUEMASK;\n\n\tswitch (vco_sel) {\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\tcase 0:\n\t\tif (vco_cal < 8) {\n\t\t\tregs[FC11_REG_VCOSEL] &= ~(FC11_VCOSEL_1 | FC11_VCOSEL_2);\n\t\t\tregs[FC11_REG_VCOSEL] |= FC11_VCOSEL_1;\n\t\t\terr = fc0011_writereg(priv, FC11_REG_VCOSEL,\n\t\t\t\t\t      regs[FC11_REG_VCOSEL]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\terr = fc0011_vcocal_trigger(priv);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tregs[FC11_REG_VCOSEL] &= ~(FC11_VCOSEL_1 | FC11_VCOSEL_2);\n\t\t\terr = fc0011_writereg(priv, FC11_REG_VCOSEL,\n\t\t\t\t\t      regs[FC11_REG_VCOSEL]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tif (vco_cal < 5) {\n\t\t\tregs[FC11_REG_VCOSEL] &= ~(FC11_VCOSEL_1 | FC11_VCOSEL_2);\n\t\t\tregs[FC11_REG_VCOSEL] |= FC11_VCOSEL_2;\n\t\t\terr = fc0011_writereg(priv, FC11_REG_VCOSEL,\n\t\t\t\t\t      regs[FC11_REG_VCOSEL]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\terr = fc0011_vcocal_trigger(priv);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else if (vco_cal <= 48) {\n\t\t\tregs[FC11_REG_VCOSEL] &= ~(FC11_VCOSEL_1 | FC11_VCOSEL_2);\n\t\t\tregs[FC11_REG_VCOSEL] |= FC11_VCOSEL_1;\n\t\t\terr = fc0011_writereg(priv, FC11_REG_VCOSEL,\n\t\t\t\t\t      regs[FC11_REG_VCOSEL]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tregs[FC11_REG_VCOSEL] &= ~(FC11_VCOSEL_1 | FC11_VCOSEL_2);\n\t\t\terr = fc0011_writereg(priv, FC11_REG_VCOSEL,\n\t\t\t\t\t      regs[FC11_REG_VCOSEL]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\terr = fc0011_vcocal_trigger(priv);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif (vco_cal > 53) {\n\t\t\tregs[FC11_REG_VCOSEL] &= ~(FC11_VCOSEL_1 | FC11_VCOSEL_2);\n\t\t\tregs[FC11_REG_VCOSEL] |= FC11_VCOSEL_1;\n\t\t\terr = fc0011_writereg(priv, FC11_REG_VCOSEL,\n\t\t\t\t\t      regs[FC11_REG_VCOSEL]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\terr = fc0011_vcocal_trigger(priv);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tregs[FC11_REG_VCOSEL] &= ~(FC11_VCOSEL_1 | FC11_VCOSEL_2);\n\t\t\tregs[FC11_REG_VCOSEL] |= FC11_VCOSEL_2;\n\t\t\terr = fc0011_writereg(priv, FC11_REG_VCOSEL,\n\t\t\t\t\t      regs[FC11_REG_VCOSEL]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\t}\n\terr = fc0011_vcocal_read(priv, NULL);\n\tif (err)\n\t\treturn err;\n\tusleep_range(10000, 50000);\n\n\terr = fc0011_readreg(priv, FC11_REG_RCCAL, &regs[FC11_REG_RCCAL]);\n\tif (err)\n\t\treturn err;\n\tregs[FC11_REG_RCCAL] |= FC11_RCCAL_FORCE;\n\terr = fc0011_writereg(priv, FC11_REG_RCCAL, regs[FC11_REG_RCCAL]);\n\tif (err)\n\t\treturn err;\n\tregs[FC11_REG_16] = 0xB;\n\terr = fc0011_writereg(priv, FC11_REG_16, regs[FC11_REG_16]);\n\tif (err)\n\t\treturn err;\n\n\tdev_dbg(&priv->i2c->dev, \"Tuned to fa=%02X fp=%02X xin=%02X%02X vco=%02X vcosel=%02X vcocal=%02X(%u) bw=%u\\n\",\n\t\t(unsigned int)regs[FC11_REG_FA],\n\t\t(unsigned int)regs[FC11_REG_FP],\n\t\t(unsigned int)regs[FC11_REG_XINHI],\n\t\t(unsigned int)regs[FC11_REG_XINLO],\n\t\t(unsigned int)regs[FC11_REG_VCO],\n\t\t(unsigned int)regs[FC11_REG_VCOSEL],\n\t\t(unsigned int)vco_cal, vco_retries,\n\t\t(unsigned int)bandwidth);\n\n\tpriv->frequency = p->frequency;\n\tpriv->bandwidth = p->bandwidth_hz;\n\n\treturn 0;\n}\n\nstatic int fc0011_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct fc0011_priv *priv = fe->tuner_priv;\n\n\t*frequency = priv->frequency;\n\n\treturn 0;\n}\n\nstatic int fc0011_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\t*frequency = 0;\n\n\treturn 0;\n}\n\nstatic int fc0011_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\n{\n\tstruct fc0011_priv *priv = fe->tuner_priv;\n\n\t*bandwidth = priv->bandwidth;\n\n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops fc0011_tuner_ops = {\n\t.info = {\n\t\t.name\t\t  = \"Fitipower FC0011\",\n\n\t\t.frequency_min_hz =   45 * MHz,\n\t\t.frequency_max_hz = 1000 * MHz,\n\t},\n\n\t.release\t\t= fc0011_release,\n\t.init\t\t\t= fc0011_init,\n\n\t.set_params\t\t= fc0011_set_params,\n\n\t.get_frequency\t\t= fc0011_get_frequency,\n\t.get_if_frequency\t= fc0011_get_if_frequency,\n\t.get_bandwidth\t\t= fc0011_get_bandwidth,\n};\n\nstruct dvb_frontend *fc0011_attach(struct dvb_frontend *fe,\n\t\t\t\t   struct i2c_adapter *i2c,\n\t\t\t\t   const struct fc0011_config *config)\n{\n\tstruct fc0011_priv *priv;\n\n\tpriv = kzalloc(sizeof(struct fc0011_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn NULL;\n\n\tpriv->i2c = i2c;\n\tpriv->addr = config->i2c_address;\n\n\tfe->tuner_priv = priv;\n\tfe->ops.tuner_ops = fc0011_tuner_ops;\n\n\tdev_info(&priv->i2c->dev, \"Fitipower FC0011 tuner attached\\n\");\n\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(fc0011_attach);\n\nMODULE_DESCRIPTION(\"Fitipower FC0011 silicon tuner driver\");\nMODULE_AUTHOR(\"Michael Buesch <m@bues.ch>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}