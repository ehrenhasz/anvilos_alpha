{
  "module_name": "tua9001.c",
  "hash_id": "1b1a7bc3a2ea3520e535da3809f15ee78d03ee415a9d8cd93e99bc432c71ad28",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/tua9001.c",
  "human_readable_source": "\n \n\n#include \"tua9001_priv.h\"\n\nstatic int tua9001_init(struct dvb_frontend *fe)\n{\n\tstruct tua9001_dev *dev = fe->tuner_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret, i;\n\tstatic const struct tua9001_reg_val data[] = {\n\t\t{0x1e, 0x6512},\n\t\t{0x25, 0xb888},\n\t\t{0x39, 0x5460},\n\t\t{0x3b, 0x00c0},\n\t\t{0x3a, 0xf000},\n\t\t{0x08, 0x0000},\n\t\t{0x32, 0x0030},\n\t\t{0x41, 0x703a},\n\t\t{0x40, 0x1c78},\n\t\t{0x2c, 0x1c00},\n\t\t{0x36, 0xc013},\n\t\t{0x37, 0x6f18},\n\t\t{0x27, 0x0008},\n\t\t{0x2a, 0x0001},\n\t\t{0x34, 0x0a40},\n\t};\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tif (fe->callback) {\n\t\tret = fe->callback(client->adapter,\n\t\t\t\t   DVB_FRONTEND_COMPONENT_TUNER,\n\t\t\t\t   TUA9001_CMD_RESETN, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(data); i++) {\n\t\tret = regmap_write(dev->regmap, data[i].reg, data[i].val);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int tua9001_sleep(struct dvb_frontend *fe)\n{\n\tstruct tua9001_dev *dev = fe->tuner_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tif (fe->callback) {\n\t\tret = fe->callback(client->adapter,\n\t\t\t\t   DVB_FRONTEND_COMPONENT_TUNER,\n\t\t\t\t   TUA9001_CMD_RESETN, 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int tua9001_set_params(struct dvb_frontend *fe)\n{\n\tstruct tua9001_dev *dev = fe->tuner_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, i;\n\tu16 val;\n\tstruct tua9001_reg_val data[2];\n\n\tdev_dbg(&client->dev,\n\t\t\"delivery_system=%u frequency=%u bandwidth_hz=%u\\n\",\n\t\tc->delivery_system, c->frequency, c->bandwidth_hz);\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\t\tswitch (c->bandwidth_hz) {\n\t\tcase 8000000:\n\t\t\tval  = 0x0000;\n\t\t\tbreak;\n\t\tcase 7000000:\n\t\t\tval  = 0x1000;\n\t\t\tbreak;\n\t\tcase 6000000:\n\t\t\tval  = 0x2000;\n\t\t\tbreak;\n\t\tcase 5000000:\n\t\t\tval  = 0x3000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdata[0].reg = 0x04;\n\tdata[0].val = val;\n\tdata[1].reg = 0x1f;\n\tdata[1].val = div_u64((u64) (c->frequency - 150000000) * 48, 1000000);\n\n\tif (fe->callback) {\n\t\tret = fe->callback(client->adapter,\n\t\t\t\t   DVB_FRONTEND_COMPONENT_TUNER,\n\t\t\t\t   TUA9001_CMD_RXEN, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(data); i++) {\n\t\tret = regmap_write(dev->regmap, data[i].reg, data[i].val);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif (fe->callback) {\n\t\tret = fe->callback(client->adapter,\n\t\t\t\t   DVB_FRONTEND_COMPONENT_TUNER,\n\t\t\t\t   TUA9001_CMD_RXEN, 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int tua9001_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct tua9001_dev *dev = fe->tuner_priv;\n\tstruct i2c_client *client = dev->client;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t*frequency = 0;  \n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops tua9001_tuner_ops = {\n\t.info = {\n\t\t.name             = \"Infineon TUA9001\",\n\t\t.frequency_min_hz = 170 * MHz,\n\t\t.frequency_max_hz = 862 * MHz,\n\t},\n\n\t.init = tua9001_init,\n\t.sleep = tua9001_sleep,\n\t.set_params = tua9001_set_params,\n\n\t.get_if_frequency = tua9001_get_if_frequency,\n};\n\nstatic int tua9001_probe(struct i2c_client *client)\n{\n\tstruct tua9001_dev *dev;\n\tstruct tua9001_platform_data *pdata = client->dev.platform_data;\n\tstruct dvb_frontend *fe = pdata->dvb_frontend;\n\tint ret;\n\tstatic const struct regmap_config regmap_config = {\n\t\t.reg_bits =  8,\n\t\t.val_bits = 16,\n\t};\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tdev->fe = pdata->dvb_frontend;\n\tdev->client = client;\n\tdev->regmap = devm_regmap_init_i2c(client, &regmap_config);\n\tif (IS_ERR(dev->regmap)) {\n\t\tret = PTR_ERR(dev->regmap);\n\t\tgoto err_kfree;\n\t}\n\n\tif (fe->callback) {\n\t\tret = fe->callback(client->adapter,\n\t\t\t\t   DVB_FRONTEND_COMPONENT_TUNER,\n\t\t\t\t   TUA9001_CMD_CEN, 1);\n\t\tif (ret)\n\t\t\tgoto err_kfree;\n\n\t\tret = fe->callback(client->adapter,\n\t\t\t\t   DVB_FRONTEND_COMPONENT_TUNER,\n\t\t\t\t   TUA9001_CMD_RXEN, 0);\n\t\tif (ret)\n\t\t\tgoto err_kfree;\n\n\t\tret = fe->callback(client->adapter,\n\t\t\t\t   DVB_FRONTEND_COMPONENT_TUNER,\n\t\t\t\t   TUA9001_CMD_RESETN, 1);\n\t\tif (ret)\n\t\t\tgoto err_kfree;\n\t}\n\n\tfe->tuner_priv = dev;\n\tmemcpy(&fe->ops.tuner_ops, &tua9001_tuner_ops,\n\t\t\tsizeof(struct dvb_tuner_ops));\n\ti2c_set_clientdata(client, dev);\n\n\tdev_info(&client->dev, \"Infineon TUA9001 successfully attached\\n\");\n\treturn 0;\nerr_kfree:\n\tkfree(dev);\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void tua9001_remove(struct i2c_client *client)\n{\n\tstruct tua9001_dev *dev = i2c_get_clientdata(client);\n\tstruct dvb_frontend *fe = dev->fe;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tif (fe->callback) {\n\t\tret = fe->callback(client->adapter,\n\t\t\t\t   DVB_FRONTEND_COMPONENT_TUNER,\n\t\t\t\t   TUA9001_CMD_CEN, 0);\n\t\tif (ret)\n\t\t\tdev_err(&client->dev, \"Tuner disable failed (%pe)\\n\", ERR_PTR(ret));\n\t}\n\tkfree(dev);\n}\n\nstatic const struct i2c_device_id tua9001_id_table[] = {\n\t{\"tua9001\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, tua9001_id_table);\n\nstatic struct i2c_driver tua9001_driver = {\n\t.driver = {\n\t\t.name\t= \"tua9001\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= tua9001_probe,\n\t.remove\t\t= tua9001_remove,\n\t.id_table\t= tua9001_id_table,\n};\n\nmodule_i2c_driver(tua9001_driver);\n\nMODULE_DESCRIPTION(\"Infineon TUA9001 silicon tuner driver\");\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}