{
  "module_name": "max2165.c",
  "hash_id": "f3cbd11b6b38e76564f7f8d86449103c4ea5f9ee71f001e3c2c71efac2d3e665",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/max2165.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/videodev2.h>\n#include <linux/delay.h>\n#include <linux/dvb/frontend.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n\n#include \"max2165.h\"\n#include \"max2165_priv.h\"\n#include \"tuner-i2c.h\"\n\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) \\\n\t\t\tprintk(KERN_DEBUG \"max2165: \" args); \\\n\t} while (0)\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off debugging (default:off).\");\n\nstatic int max2165_write_reg(struct max2165_priv *priv, u8 reg, u8 data)\n{\n\tint ret;\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = { .flags = 0, .buf = buf, .len = 2 };\n\n\tmsg.addr = priv->config->i2c_address;\n\n\tif (debug >= 2)\n\t\tdprintk(\"%s: reg=0x%02X, data=0x%02X\\n\", __func__, reg, data);\n\n\tret = i2c_transfer(priv->i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tdprintk(\"%s: error reg=0x%x, data=0x%x, ret=%i\\n\",\n\t\t\t__func__, reg, data, ret);\n\n\treturn (ret != 1) ? -EIO : 0;\n}\n\nstatic int max2165_read_reg(struct max2165_priv *priv, u8 reg, u8 *p_data)\n{\n\tint ret;\n\tu8 dev_addr = priv->config->i2c_address;\n\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0 };\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = dev_addr, .flags = 0, .buf = b0, .len = 1 },\n\t\t{ .addr = dev_addr, .flags = I2C_M_RD, .buf = b1, .len = 1 },\n\t};\n\n\tret = i2c_transfer(priv->i2c, msg, 2);\n\tif (ret != 2) {\n\t\tdprintk(\"%s: error reg=0x%x, ret=%i\\n\", __func__, reg, ret);\n\t\treturn -EIO;\n\t}\n\n\t*p_data = b1[0];\n\tif (debug >= 2)\n\t\tdprintk(\"%s: reg=0x%02X, data=0x%02X\\n\",\n\t\t\t__func__, reg, b1[0]);\n\treturn 0;\n}\n\nstatic int max2165_mask_write_reg(struct max2165_priv *priv, u8 reg,\n\tu8 mask, u8 data)\n{\n\tint ret;\n\tu8 v;\n\n\tdata &= mask;\n\tret = max2165_read_reg(priv, reg, &v);\n\tif (ret != 0)\n\t\treturn ret;\n\tv &= ~mask;\n\tv |= data;\n\tret = max2165_write_reg(priv, reg, v);\n\n\treturn ret;\n}\n\nstatic int max2165_read_rom_table(struct max2165_priv *priv)\n{\n\tu8 dat[3];\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tmax2165_write_reg(priv, REG_ROM_TABLE_ADDR, i + 1);\n\t\tmax2165_read_reg(priv, REG_ROM_TABLE_DATA, &dat[i]);\n\t}\n\n\tpriv->tf_ntch_low_cfg = dat[0] >> 4;\n\tpriv->tf_ntch_hi_cfg = dat[0] & 0x0F;\n\tpriv->tf_balun_low_ref = dat[1] & 0x0F;\n\tpriv->tf_balun_hi_ref = dat[1] >> 4;\n\tpriv->bb_filter_7mhz_cfg = dat[2] & 0x0F;\n\tpriv->bb_filter_8mhz_cfg = dat[2] >> 4;\n\n\tdprintk(\"tf_ntch_low_cfg = 0x%X\\n\", priv->tf_ntch_low_cfg);\n\tdprintk(\"tf_ntch_hi_cfg = 0x%X\\n\", priv->tf_ntch_hi_cfg);\n\tdprintk(\"tf_balun_low_ref = 0x%X\\n\", priv->tf_balun_low_ref);\n\tdprintk(\"tf_balun_hi_ref = 0x%X\\n\", priv->tf_balun_hi_ref);\n\tdprintk(\"bb_filter_7mhz_cfg = 0x%X\\n\", priv->bb_filter_7mhz_cfg);\n\tdprintk(\"bb_filter_8mhz_cfg = 0x%X\\n\", priv->bb_filter_8mhz_cfg);\n\n\treturn 0;\n}\n\nstatic int max2165_set_osc(struct max2165_priv *priv, u8 osc  )\n{\n\tu8 v;\n\n\tv = (osc / 2);\n\tif (v == 2)\n\t\tv = 0x7;\n\telse\n\t\tv -= 8;\n\n\tmax2165_mask_write_reg(priv, REG_PLL_CFG, 0x07, v);\n\n\treturn 0;\n}\n\nstatic int max2165_set_bandwidth(struct max2165_priv *priv, u32 bw)\n{\n\tu8 val;\n\n\tif (bw == 8000000)\n\t\tval = priv->bb_filter_8mhz_cfg;\n\telse\n\t\tval = priv->bb_filter_7mhz_cfg;\n\n\tmax2165_mask_write_reg(priv, REG_BASEBAND_CTRL, 0xF0, val << 4);\n\n\treturn 0;\n}\n\nstatic int fixpt_div32(u32 dividend, u32 divisor, u32 *quotient, u32 *fraction)\n{\n\tu32 remainder;\n\tu32 q, f = 0;\n\tint i;\n\n\tif (0 == divisor)\n\t\treturn -EINVAL;\n\n\tq = dividend / divisor;\n\tremainder = dividend - q * divisor;\n\n\tfor (i = 0; i < 31; i++) {\n\t\tremainder <<= 1;\n\t\tif (remainder >= divisor) {\n\t\t\tf += 1;\n\t\t\tremainder -= divisor;\n\t\t}\n\t\tf <<= 1;\n\t}\n\n\t*quotient = q;\n\t*fraction = f;\n\n\treturn 0;\n}\n\nstatic int max2165_set_rf(struct max2165_priv *priv, u32 freq)\n{\n\tu8 tf;\n\tu8 tf_ntch;\n\tu32 t;\n\tu32 quotient, fraction;\n\tint ret;\n\n\t \n\tret = fixpt_div32(freq / 1000, priv->config->osc_clk * 1000,\n\t\t\t &quotient, &fraction);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tfraction >>= 12;\n\n\tmax2165_write_reg(priv, REG_NDIV_INT, quotient);\n\tmax2165_mask_write_reg(priv, REG_NDIV_FRAC2, 0x0F, fraction >> 16);\n\tmax2165_write_reg(priv, REG_NDIV_FRAC1, fraction >> 8);\n\tmax2165_write_reg(priv, REG_NDIV_FRAC0, fraction);\n\n\t \n\ttf_ntch = (freq < 725000000) ?\n\t\tpriv->tf_ntch_low_cfg : priv->tf_ntch_hi_cfg;\n\n\t \n\tt = priv->tf_balun_low_ref;\n\tt += (priv->tf_balun_hi_ref - priv->tf_balun_low_ref)\n\t\t* (freq / 1000 - 470000) / (780000 - 470000);\n\n\ttf = t;\n\tdprintk(\"tf = %X\\n\", tf);\n\ttf |= tf_ntch << 4;\n\n\tmax2165_write_reg(priv, REG_TRACK_FILTER, tf);\n\n\treturn 0;\n}\n\nstatic void max2165_debug_status(struct max2165_priv *priv)\n{\n\tu8 status, autotune;\n\tu8 auto_vco_success, auto_vco_active;\n\tu8 pll_locked;\n\tu8 dc_offset_low, dc_offset_hi;\n\tu8 signal_lv_over_threshold;\n\tu8 vco, vco_sub_band, adc;\n\n\tmax2165_read_reg(priv, REG_STATUS, &status);\n\tmax2165_read_reg(priv, REG_AUTOTUNE, &autotune);\n\n\tauto_vco_success = (status >> 6) & 0x01;\n\tauto_vco_active = (status >> 5) & 0x01;\n\tpll_locked = (status >> 4) & 0x01;\n\tdc_offset_low = (status >> 3) & 0x01;\n\tdc_offset_hi = (status >> 2) & 0x01;\n\tsignal_lv_over_threshold = status & 0x01;\n\n\tvco = autotune >> 6;\n\tvco_sub_band = (autotune >> 3) & 0x7;\n\tadc = autotune & 0x7;\n\n\tdprintk(\"auto VCO active: %d, auto VCO success: %d\\n\",\n\t\tauto_vco_active, auto_vco_success);\n\tdprintk(\"PLL locked: %d\\n\", pll_locked);\n\tdprintk(\"DC offset low: %d, DC offset high: %d\\n\",\n\t\tdc_offset_low, dc_offset_hi);\n\tdprintk(\"Signal lvl over threshold: %d\\n\", signal_lv_over_threshold);\n\tdprintk(\"VCO: %d, VCO Sub-band: %d, ADC: %d\\n\", vco, vco_sub_band, adc);\n}\n\nstatic int max2165_set_params(struct dvb_frontend *fe)\n{\n\tstruct max2165_priv *priv = fe->tuner_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret;\n\n\tswitch (c->bandwidth_hz) {\n\tcase 7000000:\n\tcase 8000000:\n\t\tpriv->frequency = c->frequency;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_INFO \"MAX2165: bandwidth %d Hz not supported.\\n\",\n\t\t       c->bandwidth_hz);\n\t\treturn -EINVAL;\n\t}\n\n\tdprintk(\"%s() frequency=%d\\n\", __func__, c->frequency);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tmax2165_set_bandwidth(priv, c->bandwidth_hz);\n\tret = max2165_set_rf(priv, priv->frequency);\n\tmdelay(50);\n\tmax2165_debug_status(priv);\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tif (ret != 0)\n\t\treturn -EREMOTEIO;\n\n\treturn 0;\n}\n\nstatic int max2165_get_frequency(struct dvb_frontend *fe, u32 *freq)\n{\n\tstruct max2165_priv *priv = fe->tuner_priv;\n\tdprintk(\"%s()\\n\", __func__);\n\t*freq = priv->frequency;\n\treturn 0;\n}\n\nstatic int max2165_get_bandwidth(struct dvb_frontend *fe, u32 *bw)\n{\n\tstruct max2165_priv *priv = fe->tuner_priv;\n\tdprintk(\"%s()\\n\", __func__);\n\n\t*bw = priv->bandwidth;\n\treturn 0;\n}\n\nstatic int max2165_get_status(struct dvb_frontend *fe, u32 *status)\n{\n\tstruct max2165_priv *priv = fe->tuner_priv;\n\tu16 lock_status = 0;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tmax2165_debug_status(priv);\n\t*status = lock_status;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\treturn 0;\n}\n\nstatic int max2165_sleep(struct dvb_frontend *fe)\n{\n\tdprintk(\"%s()\\n\", __func__);\n\treturn 0;\n}\n\nstatic int max2165_init(struct dvb_frontend *fe)\n{\n\tstruct max2165_priv *priv = fe->tuner_priv;\n\tdprintk(\"%s()\\n\", __func__);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t \n\t \n\tmax2165_write_reg(priv, REG_NDIV_FRAC2, 0x18);\n\t \n\tmax2165_write_reg(priv, REG_LNA, 0x01);\n\tmax2165_write_reg(priv, REG_PLL_CFG, 0x7A);\n\tmax2165_write_reg(priv, REG_TEST, 0x08);\n\tmax2165_write_reg(priv, REG_SHUTDOWN, 0x40);\n\tmax2165_write_reg(priv, REG_VCO_CTRL, 0x84);\n\tmax2165_write_reg(priv, REG_BASEBAND_CTRL, 0xC3);\n\tmax2165_write_reg(priv, REG_DC_OFFSET_CTRL, 0x75);\n\tmax2165_write_reg(priv, REG_DC_OFFSET_DAC, 0x00);\n\tmax2165_write_reg(priv, REG_ROM_TABLE_ADDR, 0x00);\n\n\tmax2165_set_osc(priv, priv->config->osc_clk);\n\n\tmax2165_read_rom_table(priv);\n\n\tmax2165_set_bandwidth(priv, 8000000);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\treturn 0;\n}\n\nstatic void max2165_release(struct dvb_frontend *fe)\n{\n\tstruct max2165_priv *priv = fe->tuner_priv;\n\tdprintk(\"%s()\\n\", __func__);\n\n\tkfree(priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic const struct dvb_tuner_ops max2165_tuner_ops = {\n\t.info = {\n\t\t.name              = \"Maxim MAX2165\",\n\t\t.frequency_min_hz  = 470 * MHz,\n\t\t.frequency_max_hz  = 862 * MHz,\n\t\t.frequency_step_hz =  50 * kHz,\n\t},\n\n\t.release\t   = max2165_release,\n\t.init\t\t   = max2165_init,\n\t.sleep\t\t   = max2165_sleep,\n\n\t.set_params\t   = max2165_set_params,\n\t.set_analog_params = NULL,\n\t.get_frequency\t   = max2165_get_frequency,\n\t.get_bandwidth\t   = max2165_get_bandwidth,\n\t.get_status\t   = max2165_get_status\n};\n\nstruct dvb_frontend *max2165_attach(struct dvb_frontend *fe,\n\t\t\t\t   struct i2c_adapter *i2c,\n\t\t\t\t   struct max2165_config *cfg)\n{\n\tstruct max2165_priv *priv = NULL;\n\n\tdprintk(\"%s(%d-%04x)\\n\", __func__,\n\t\ti2c ? i2c_adapter_id(i2c) : -1,\n\t\tcfg ? cfg->i2c_address : -1);\n\n\tpriv = kzalloc(sizeof(struct max2165_priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn NULL;\n\n\tmemcpy(&fe->ops.tuner_ops, &max2165_tuner_ops,\n\t\tsizeof(struct dvb_tuner_ops));\n\n\tpriv->config = cfg;\n\tpriv->i2c = i2c;\n\tfe->tuner_priv = priv;\n\n\tmax2165_init(fe);\n\tmax2165_debug_status(priv);\n\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(max2165_attach);\n\nMODULE_AUTHOR(\"David T. L. Wong <davidtlwong@gmail.com>\");\nMODULE_DESCRIPTION(\"Maxim MAX2165 silicon tuner driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}