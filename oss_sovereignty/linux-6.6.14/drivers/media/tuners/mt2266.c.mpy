{
  "module_name": "mt2266.c",
  "hash_id": "941c8b8885b9f29ea75df6df215f4d3a7850c7c09620a31fed229c7878a2322b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/mt2266.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/dvb/frontend.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n#include \"mt2266.h\"\n\n#define I2C_ADDRESS 0x60\n\n#define REG_PART_REV   0\n#define REG_TUNE       1\n#define REG_BAND       6\n#define REG_BANDWIDTH  8\n#define REG_LOCK       0x12\n\n#define PART_REV 0x85\n\nstruct mt2266_priv {\n\tstruct mt2266_config *cfg;\n\tstruct i2c_adapter   *i2c;\n\n\tu32 frequency;\n\tu32 bandwidth;\n\tu8 band;\n};\n\n#define MT2266_VHF 1\n#define MT2266_UHF 0\n\n \n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off debugging (default:off).\");\n\n#define dprintk(args...) do { if (debug) {printk(KERN_DEBUG \"MT2266: \" args); printk(\"\\n\"); }} while (0)\n\n\nstatic int mt2266_readreg(struct mt2266_priv *priv, u8 reg, u8 *val)\n{\n\tstruct i2c_msg msg[2] = {\n\t\t{ .addr = priv->cfg->i2c_address, .flags = 0,        .buf = &reg, .len = 1 },\n\t\t{ .addr = priv->cfg->i2c_address, .flags = I2C_M_RD, .buf = val,  .len = 1 },\n\t};\n\tif (i2c_transfer(priv->i2c, msg, 2) != 2) {\n\t\tprintk(KERN_WARNING \"MT2266 I2C read failed\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\n\nstatic int mt2266_writereg(struct mt2266_priv *priv, u8 reg, u8 val)\n{\n\tu8 buf[2] = { reg, val };\n\tstruct i2c_msg msg = {\n\t\t.addr = priv->cfg->i2c_address, .flags = 0, .buf = buf, .len = 2\n\t};\n\tif (i2c_transfer(priv->i2c, &msg, 1) != 1) {\n\t\tprintk(KERN_WARNING \"MT2266 I2C write failed\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\n\nstatic int mt2266_writeregs(struct mt2266_priv *priv,u8 *buf, u8 len)\n{\n\tstruct i2c_msg msg = {\n\t\t.addr = priv->cfg->i2c_address, .flags = 0, .buf = buf, .len = len\n\t};\n\tif (i2c_transfer(priv->i2c, &msg, 1) != 1) {\n\t\tprintk(KERN_WARNING \"MT2266 I2C write failed (len=%i)\\n\",(int)len);\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\n\nstatic u8 mt2266_init1[] = { REG_TUNE, 0x00, 0x00, 0x28,\n\t\t\t\t 0x00, 0x52, 0x99, 0x3f };\n\nstatic u8 mt2266_init2[] = {\n    0x17, 0x6d, 0x71, 0x61, 0xc0, 0xbf, 0xff, 0xdc, 0x00, 0x0a, 0xd4,\n    0x03, 0x64, 0x64, 0x64, 0x64, 0x22, 0xaa, 0xf2, 0x1e, 0x80, 0x14,\n    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x7f, 0x5e, 0x3f, 0xff, 0xff,\n    0xff, 0x00, 0x77, 0x0f, 0x2d\n};\n\nstatic u8 mt2266_init_8mhz[] = { REG_BANDWIDTH, 0x22, 0x22, 0x22, 0x22,\n\t\t\t\t\t\t0x22, 0x22, 0x22, 0x22 };\n\nstatic u8 mt2266_init_7mhz[] = { REG_BANDWIDTH, 0x32, 0x32, 0x32, 0x32,\n\t\t\t\t\t\t0x32, 0x32, 0x32, 0x32 };\n\nstatic u8 mt2266_init_6mhz[] = { REG_BANDWIDTH, 0xa7, 0xa7, 0xa7, 0xa7,\n\t\t\t\t\t\t0xa7, 0xa7, 0xa7, 0xa7 };\n\nstatic u8 mt2266_uhf[] = { 0x1d, 0xdc, 0x00, 0x0a, 0xd4, 0x03, 0x64, 0x64,\n\t\t\t   0x64, 0x64, 0x22, 0xaa, 0xf2, 0x1e, 0x80, 0x14 };\n\nstatic u8 mt2266_vhf[] = { 0x1d, 0xfe, 0x00, 0x00, 0xb4, 0x03, 0xa5, 0xa5,\n\t\t\t   0xa5, 0xa5, 0x82, 0xaa, 0xf1, 0x17, 0x80, 0x1f };\n\n#define FREF 30000       \n\nstatic int mt2266_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct mt2266_priv *priv;\n\tint ret=0;\n\tu32 freq;\n\tu32 tune;\n\tu8  lnaband;\n\tu8  b[10];\n\tint i;\n\tu8 band;\n\n\tpriv = fe->tuner_priv;\n\n\tfreq = priv->frequency / 1000;  \n\tif (freq < 470000 && freq > 230000)\n\t\treturn -EINVAL;  \n\n\tpriv->frequency = c->frequency;\n\ttune = 2 * freq * (8192/16) / (FREF/16);\n\tband = (freq < 300000) ? MT2266_VHF : MT2266_UHF;\n\tif (band == MT2266_VHF)\n\t\ttune *= 2;\n\n\tswitch (c->bandwidth_hz) {\n\tcase 6000000:\n\t\tmt2266_writeregs(priv, mt2266_init_6mhz,\n\t\t\t\t sizeof(mt2266_init_6mhz));\n\t\tbreak;\n\tcase 8000000:\n\t\tmt2266_writeregs(priv, mt2266_init_8mhz,\n\t\t\t\t sizeof(mt2266_init_8mhz));\n\t\tbreak;\n\tcase 7000000:\n\tdefault:\n\t\tmt2266_writeregs(priv, mt2266_init_7mhz,\n\t\t\t\t sizeof(mt2266_init_7mhz));\n\t\tbreak;\n\t}\n\tpriv->bandwidth = c->bandwidth_hz;\n\n\tif (band == MT2266_VHF && priv->band == MT2266_UHF) {\n\t\tdprintk(\"Switch from UHF to VHF\");\n\t\tmt2266_writereg(priv, 0x05, 0x04);\n\t\tmt2266_writereg(priv, 0x19, 0x61);\n\t\tmt2266_writeregs(priv, mt2266_vhf, sizeof(mt2266_vhf));\n\t} else if (band == MT2266_UHF && priv->band == MT2266_VHF) {\n\t\tdprintk(\"Switch from VHF to UHF\");\n\t\tmt2266_writereg(priv, 0x05, 0x52);\n\t\tmt2266_writereg(priv, 0x19, 0x61);\n\t\tmt2266_writeregs(priv, mt2266_uhf, sizeof(mt2266_uhf));\n\t}\n\tmsleep(10);\n\n\tif (freq <= 495000)\n\t\tlnaband = 0xEE;\n\telse if (freq <= 525000)\n\t\tlnaband = 0xDD;\n\telse if (freq <= 550000)\n\t\tlnaband = 0xCC;\n\telse if (freq <= 580000)\n\t\tlnaband = 0xBB;\n\telse if (freq <= 605000)\n\t\tlnaband = 0xAA;\n\telse if (freq <= 630000)\n\t\tlnaband = 0x99;\n\telse if (freq <= 655000)\n\t\tlnaband = 0x88;\n\telse if (freq <= 685000)\n\t\tlnaband = 0x77;\n\telse if (freq <= 710000)\n\t\tlnaband = 0x66;\n\telse if (freq <= 735000)\n\t\tlnaband = 0x55;\n\telse if (freq <= 765000)\n\t\tlnaband = 0x44;\n\telse if (freq <= 802000)\n\t\tlnaband = 0x33;\n\telse if (freq <= 840000)\n\t\tlnaband = 0x22;\n\telse\n\t\tlnaband = 0x11;\n\n\tb[0] = REG_TUNE;\n\tb[1] = (tune >> 8) & 0x1F;\n\tb[2] = tune & 0xFF;\n\tb[3] = tune >> 13;\n\tmt2266_writeregs(priv,b,4);\n\n\tdprintk(\"set_parms: tune=%d band=%d %s\",\n\t\t(int) tune, (int) lnaband,\n\t\t(band == MT2266_UHF) ? \"UHF\" : \"VHF\");\n\tdprintk(\"set_parms: [1..3]: %2x %2x %2x\",\n\t\t(int) b[1], (int) b[2], (int)b[3]);\n\n\tif (band == MT2266_UHF) {\n\t\tb[0] = 0x05;\n\t\tb[1] = (priv->band == MT2266_VHF) ? 0x52 : 0x62;\n\t\tb[2] = lnaband;\n\t\tmt2266_writeregs(priv, b, 3);\n\t}\n\n\t \n\ti = 0;\n\tdo {\n\t\tmt2266_readreg(priv,REG_LOCK,b);\n\t\tif (b[0] & 0x40)\n\t\t\tbreak;\n\t\tmsleep(10);\n\t\ti++;\n\t} while (i<10);\n\tdprintk(\"Lock when i=%i\",(int)i);\n\n\tif (band == MT2266_UHF && priv->band == MT2266_VHF)\n\t\tmt2266_writereg(priv, 0x05, 0x62);\n\n\tpriv->band = band;\n\n\treturn ret;\n}\n\nstatic void mt2266_calibrate(struct mt2266_priv *priv)\n{\n\tmt2266_writereg(priv, 0x11, 0x03);\n\tmt2266_writereg(priv, 0x11, 0x01);\n\tmt2266_writeregs(priv, mt2266_init1, sizeof(mt2266_init1));\n\tmt2266_writeregs(priv, mt2266_init2, sizeof(mt2266_init2));\n\tmt2266_writereg(priv, 0x33, 0x5e);\n\tmt2266_writereg(priv, 0x10, 0x10);\n\tmt2266_writereg(priv, 0x10, 0x00);\n\tmt2266_writeregs(priv, mt2266_init_8mhz, sizeof(mt2266_init_8mhz));\n\tmsleep(25);\n\tmt2266_writereg(priv, 0x17, 0x6d);\n\tmt2266_writereg(priv, 0x1c, 0x00);\n\tmsleep(75);\n\tmt2266_writereg(priv, 0x17, 0x6d);\n\tmt2266_writereg(priv, 0x1c, 0xff);\n}\n\nstatic int mt2266_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct mt2266_priv *priv = fe->tuner_priv;\n\t*frequency = priv->frequency;\n\treturn 0;\n}\n\nstatic int mt2266_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\n{\n\tstruct mt2266_priv *priv = fe->tuner_priv;\n\t*bandwidth = priv->bandwidth;\n\treturn 0;\n}\n\nstatic int mt2266_init(struct dvb_frontend *fe)\n{\n\tint ret;\n\tstruct mt2266_priv *priv = fe->tuner_priv;\n\tret = mt2266_writereg(priv, 0x17, 0x6d);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = mt2266_writereg(priv, 0x1c, 0xff);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic int mt2266_sleep(struct dvb_frontend *fe)\n{\n\tstruct mt2266_priv *priv = fe->tuner_priv;\n\tmt2266_writereg(priv, 0x17, 0x6d);\n\tmt2266_writereg(priv, 0x1c, 0x00);\n\treturn 0;\n}\n\nstatic void mt2266_release(struct dvb_frontend *fe)\n{\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic const struct dvb_tuner_ops mt2266_tuner_ops = {\n\t.info = {\n\t\t.name              = \"Microtune MT2266\",\n\t\t.frequency_min_hz  = 174 * MHz,\n\t\t.frequency_max_hz  = 862 * MHz,\n\t\t.frequency_step_hz =  50 * kHz,\n\t},\n\t.release       = mt2266_release,\n\t.init          = mt2266_init,\n\t.sleep         = mt2266_sleep,\n\t.set_params    = mt2266_set_params,\n\t.get_frequency = mt2266_get_frequency,\n\t.get_bandwidth = mt2266_get_bandwidth\n};\n\nstruct dvb_frontend * mt2266_attach(struct dvb_frontend *fe, struct i2c_adapter *i2c, struct mt2266_config *cfg)\n{\n\tstruct mt2266_priv *priv = NULL;\n\tu8 id = 0;\n\n\tpriv = kzalloc(sizeof(struct mt2266_priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn NULL;\n\n\tpriv->cfg      = cfg;\n\tpriv->i2c      = i2c;\n\tpriv->band     = MT2266_UHF;\n\n\tif (mt2266_readreg(priv, 0, &id)) {\n\t\tkfree(priv);\n\t\treturn NULL;\n\t}\n\tif (id != PART_REV) {\n\t\tkfree(priv);\n\t\treturn NULL;\n\t}\n\tprintk(KERN_INFO \"MT2266: successfully identified\\n\");\n\tmemcpy(&fe->ops.tuner_ops, &mt2266_tuner_ops, sizeof(struct dvb_tuner_ops));\n\n\tfe->tuner_priv = priv;\n\tmt2266_calibrate(priv);\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(mt2266_attach);\n\nMODULE_AUTHOR(\"Olivier DANET\");\nMODULE_DESCRIPTION(\"Microtune MT2266 silicon tuner driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}