{
  "module_name": "si2157.c",
  "hash_id": "8868386cb28e9d1b7632c509b62aa1a53e4e1c7745811c0f049a4f4767a47e30",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/si2157.c",
  "human_readable_source": "\n \n\n#include \"si2157_priv.h\"\n\nstatic const struct dvb_tuner_ops si2157_ops;\n\nstatic int tuner_lock_debug;\nmodule_param(tuner_lock_debug, int, 0644);\nMODULE_PARM_DESC(tuner_lock_debug, \"if set, signal lock is briefly waited on after setting params\");\n\n \nstatic int si2157_cmd_execute(struct i2c_client *client, struct si2157_cmd *cmd)\n{\n\tstruct si2157_dev *dev = i2c_get_clientdata(client);\n\tint ret;\n\tunsigned long timeout;\n\n\tmutex_lock(&dev->i2c_mutex);\n\n\tif (cmd->wlen) {\n\t\t \n\t\tret = i2c_master_send(client, cmd->args, cmd->wlen);\n\t\tif (ret < 0) {\n\t\t\tgoto err_mutex_unlock;\n\t\t} else if (ret != cmd->wlen) {\n\t\t\tret = -EREMOTEIO;\n\t\t\tgoto err_mutex_unlock;\n\t\t}\n\t}\n\n\tif (cmd->rlen) {\n\t\t \n\t\t#define TIMEOUT 80\n\t\ttimeout = jiffies + msecs_to_jiffies(TIMEOUT);\n\t\twhile (!time_after(jiffies, timeout)) {\n\t\t\tret = i2c_master_recv(client, cmd->args, cmd->rlen);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto err_mutex_unlock;\n\t\t\t} else if (ret != cmd->rlen) {\n\t\t\t\tret = -EREMOTEIO;\n\t\t\t\tgoto err_mutex_unlock;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((cmd->args[0] >> 7) & 0x01)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(&client->dev, \"cmd execution took %d ms, status=%x\\n\",\n\t\t\tjiffies_to_msecs(jiffies) -\n\t\t\t(jiffies_to_msecs(timeout) - TIMEOUT),\n\t\t\tcmd->args[0]);\n\n\t\tif (!((cmd->args[0] >> 7) & 0x01)) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto err_mutex_unlock;\n\t\t}\n\t\t \n\t\tif (cmd->args[0] & 0x40) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto err_mutex_unlock;\n\t\t}\n\t}\n\n\tmutex_unlock(&dev->i2c_mutex);\n\treturn 0;\n\nerr_mutex_unlock:\n\tmutex_unlock(&dev->i2c_mutex);\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct si2157_tuner_info si2157_tuners[] = {\n\t{ SI2141, 0x60, false, SI2141_60_FIRMWARE, SI2141_A10_FIRMWARE },\n\t{ SI2141, 0x61, false, SI2141_61_FIRMWARE, SI2141_A10_FIRMWARE },\n\t{ SI2146, 0x11, false, SI2146_11_FIRMWARE, NULL },\n\t{ SI2147, 0x50, false, SI2147_50_FIRMWARE, NULL },\n\t{ SI2148, 0x32, true,  SI2148_32_FIRMWARE, SI2158_A20_FIRMWARE },\n\t{ SI2148, 0x33, true,  SI2148_33_FIRMWARE, SI2158_A20_FIRMWARE },\n\t{ SI2157, 0x50, false, SI2157_50_FIRMWARE, SI2157_A30_FIRMWARE },\n\t{ SI2158, 0x50, false, SI2158_50_FIRMWARE, SI2158_A20_FIRMWARE },\n\t{ SI2158, 0x51, false, SI2158_51_FIRMWARE, SI2158_A20_FIRMWARE },\n\t{ SI2177, 0x50, false, SI2177_50_FIRMWARE, SI2157_A30_FIRMWARE },\n};\n\nstatic int si2157_load_firmware(struct dvb_frontend *fe,\n\t\t\t\tconst char *fw_name)\n{\n\tstruct i2c_client *client = fe->tuner_priv;\n\tconst struct firmware *fw;\n\tint ret, len, remaining;\n\tstruct si2157_cmd cmd;\n\n\t \n\tret = firmware_request_nowarn(&fw, fw_name, &client->dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (fw->size % 17 != 0) {\n\t\tdev_err(&client->dev, \"firmware file '%s' is invalid\\n\",\n\t\t\tfw_name);\n\t\tret = -EINVAL;\n\t\tgoto err_release_firmware;\n\t}\n\n\tdev_info(&client->dev, \"downloading firmware from file '%s'\\n\",\n\t\t fw_name);\n\n\tfor (remaining = fw->size; remaining > 0; remaining -= 17) {\n\t\tlen = fw->data[fw->size - remaining];\n\t\tif (len > SI2157_ARGLEN) {\n\t\t\tdev_err(&client->dev, \"Bad firmware length\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_release_firmware;\n\t\t}\n\t\tmemcpy(cmd.args, &fw->data[(fw->size - remaining) + 1], len);\n\t\tcmd.wlen = len;\n\t\tcmd.rlen = 1;\n\t\tret = si2157_cmd_execute(client, &cmd);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"firmware download failed %d\\n\",\n\t\t\t\t\tret);\n\t\t\tgoto err_release_firmware;\n\t\t}\n\t}\n\nerr_release_firmware:\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic int si2157_find_and_load_firmware(struct dvb_frontend *fe)\n{\n\tstruct i2c_client *client = fe->tuner_priv;\n\tstruct si2157_dev *dev = i2c_get_clientdata(client);\n\tconst char *fw_alt_name = NULL;\n\tunsigned char part_id, rom_id;\n\tconst char *fw_name = NULL;\n\tstruct si2157_cmd cmd;\n\tbool required = true;\n\tint ret, i;\n\n\tif (dev->dont_load_firmware) {\n\t\tdev_info(&client->dev,\n\t\t\t \"device is buggy, skipping firmware download\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tmemcpy(cmd.args, \"\\x02\", 1);\n\tcmd.wlen = 1;\n\tcmd.rlen = 13;\n\tret = si2157_cmd_execute(client, &cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tpart_id = cmd.args[2];\n\trom_id = cmd.args[12];\n\n\tfor (i = 0; i < ARRAY_SIZE(si2157_tuners); i++) {\n\t\tif (si2157_tuners[i].part_id != part_id)\n\t\t\tcontinue;\n\t\trequired = si2157_tuners[i].required;\n\t\tfw_alt_name = si2157_tuners[i].fw_alt_name;\n\n\t\t \n\t\tif (si2157_tuners[i].rom_id == rom_id) {\n\t\t\tfw_name = si2157_tuners[i].fw_name;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (required && !fw_name && !fw_alt_name) {\n\t\tdev_err(&client->dev,\n\t\t\t\"unknown chip version Si21%d-%c%c%c ROM 0x%02x\\n\",\n\t\t\tpart_id, cmd.args[1], cmd.args[3], cmd.args[4], rom_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdev->part_id = part_id;\n\n\tdev_info(&client->dev,\n\t\t \"found a 'Silicon Labs Si21%d-%c%c%c ROM 0x%02x'\\n\",\n\t\t part_id, cmd.args[1], cmd.args[3], cmd.args[4], rom_id);\n\n\tif (fw_name)\n\t\tret = si2157_load_firmware(fe, fw_name);\n\telse\n\t\tret = -ENOENT;\n\n\t \n\tif (ret == -ENOENT && fw_alt_name)\n\t\tret = si2157_load_firmware(fe, fw_alt_name);\n\n\tif (ret == -ENOENT) {\n\t\tif (!required) {\n\t\t\tdev_info(&client->dev, \"Using ROM firmware.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tdev_err(&client->dev, \"Can't continue without a firmware.\\n\");\n\t} else if (ret < 0) {\n\t\tdev_err(&client->dev, \"error %d when loading firmware\\n\", ret);\n\t}\n\treturn ret;\n}\n\nstatic int si2157_init(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct i2c_client *client = fe->tuner_priv;\n\tstruct si2157_dev *dev = i2c_get_clientdata(client);\n\tunsigned int xtal_trim;\n\tstruct si2157_cmd cmd;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tmemcpy(cmd.args, \"\\x15\\x00\\x02\\x04\", 4);\n\tcmd.wlen = 4;\n\tcmd.rlen = 4;\n\tret = si2157_cmd_execute(client, &cmd);\n\n\txtal_trim = cmd.args[2] | (cmd.args[3] << 8);\n\n\tif (ret == 0 && xtal_trim < 16)\n\t\tgoto warm;\n\n\tdev->if_frequency = 0;  \n\n\t \n\tif (dev->part_id == SI2146) {\n\t\t \n\t\tmemcpy(cmd.args, \"\\xc0\\x05\\x01\\x00\\x00\\x0b\\x00\\x00\\x01\", 9);\n\t\tcmd.wlen = 9;\n\t} else if (dev->part_id == SI2141) {\n\t\t \n\t\tmemcpy(cmd.args, \"\\xc0\\x00\\x0d\\x0e\\x00\\x01\\x01\\x01\\x01\\x03\", 10);\n\t\tcmd.wlen = 10;\n\t} else {\n\t\tmemcpy(cmd.args, \"\\xc0\\x00\\x0c\\x00\\x00\\x01\\x01\\x01\\x01\\x01\\x01\\x02\\x00\\x00\\x01\", 15);\n\t\tcmd.wlen = 15;\n\t}\n\tcmd.rlen = 1;\n\tret = si2157_cmd_execute(client, &cmd);\n\tif (ret && (dev->part_id != SI2141 || ret != -EAGAIN))\n\t\tgoto err;\n\n\t \n\tif (dev->part_id == SI2141) {\n\t\tmemcpy(cmd.args, \"\\xc0\\x08\\x01\\x02\\x00\\x00\\x01\", 7);\n\t\tcmd.wlen = 7;\n\t\tret = si2157_cmd_execute(client, &cmd);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tret = si2157_find_and_load_firmware(fe);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tmemcpy(cmd.args, \"\\x01\\x01\", 2);\n\tcmd.wlen = 2;\n\tcmd.rlen = 1;\n\tret = si2157_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tmemcpy(cmd.args, \"\\x11\", 1);\n\tcmd.wlen = 1;\n\tcmd.rlen = 10;\n\tret = si2157_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tdev_info(&client->dev, \"firmware version: %c.%c.%d\\n\",\n\t\t\tcmd.args[6], cmd.args[7], cmd.args[8]);\n\n\t \n\tmemcpy(cmd.args, \"\\x14\\x00\\x01\\x05\\x01\\x00\", 6);\n\tcmd.wlen = 6;\n\tcmd.rlen = 1;\n\tret = si2157_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tmemcpy(cmd.args, \"\\x14\\x00\\x01\\x06\\x01\\x00\", 6);\n\tcmd.wlen = 6;\n\tcmd.rlen = 1;\n\tret = si2157_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tmemcpy(cmd.args, \"\\x14\\x00\\x01\\x07\\x01\\x00\", 6);\n\tcmd.wlen = 6;\n\tcmd.rlen = 1;\n\tret = si2157_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\nwarm:\n\t \n\tc->strength.len = 1;\n\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t \n\tschedule_delayed_work(&dev->stat_work, msecs_to_jiffies(1000));\n\n\tdev->active = true;\n\treturn 0;\n\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int si2157_sleep(struct dvb_frontend *fe)\n{\n\tstruct i2c_client *client = fe->tuner_priv;\n\tstruct si2157_dev *dev = i2c_get_clientdata(client);\n\tint ret;\n\tstruct si2157_cmd cmd;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tdev->active = false;\n\n\t \n\tcancel_delayed_work_sync(&dev->stat_work);\n\n\t \n\tmemcpy(cmd.args, \"\\x16\\x00\", 2);\n\tcmd.wlen = 2;\n\tcmd.rlen = 1;\n\tret = si2157_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int si2157_tune_wait(struct i2c_client *client, u8 is_digital)\n{\n#define TUN_TIMEOUT 40\n#define DIG_TIMEOUT 30\n#define ANALOG_TIMEOUT 150\n\tstruct si2157_dev *dev = i2c_get_clientdata(client);\n\tint ret;\n\tunsigned long timeout;\n\tunsigned long start_time;\n\tu8 wait_status;\n\tu8  tune_lock_mask;\n\n\tif (is_digital)\n\t\ttune_lock_mask = 0x04;\n\telse\n\t\ttune_lock_mask = 0x02;\n\n\tmutex_lock(&dev->i2c_mutex);\n\n\t \n\tstart_time = jiffies;\n\ttimeout = start_time + msecs_to_jiffies(TUN_TIMEOUT);\n\twhile (1) {\n\t\tret = i2c_master_recv(client, &wait_status,\n\t\t\t\t      sizeof(wait_status));\n\t\tif (ret < 0) {\n\t\t\tgoto err_mutex_unlock;\n\t\t} else if (ret != sizeof(wait_status)) {\n\t\t\tret = -EREMOTEIO;\n\t\t\tgoto err_mutex_unlock;\n\t\t}\n\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\n\t\t \n\t\tif ((wait_status & 0x81) == 0x81)\n\t\t\tbreak;\n\t\tusleep_range(5000, 10000);\n\t}\n\n\tdev_dbg(&client->dev, \"tuning took %d ms, status=0x%x\\n\",\n\t\tjiffies_to_msecs(jiffies) - jiffies_to_msecs(start_time),\n\t\twait_status);\n\n\t \n\tif (tuner_lock_debug && (wait_status & 0x81) == 0x81) {\n\t\tif (is_digital)\n\t\t\ttimeout = jiffies + msecs_to_jiffies(DIG_TIMEOUT);\n\t\telse\n\t\t\ttimeout = jiffies + msecs_to_jiffies(ANALOG_TIMEOUT);\n\n\t\twhile (!time_after(jiffies, timeout)) {\n\t\t\tret = i2c_master_recv(client, &wait_status,\n\t\t\t\t\t      sizeof(wait_status));\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto err_mutex_unlock;\n\t\t\t} else if (ret != sizeof(wait_status)) {\n\t\t\t\tret = -EREMOTEIO;\n\t\t\t\tgoto err_mutex_unlock;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (wait_status & tune_lock_mask)\n\t\t\t\tbreak;\n\t\t\tusleep_range(5000, 10000);\n\t\t}\n\n\t\tdev_dbg(&client->dev, \"tuning+lock took %d ms, status=0x%x\\n\",\n\t\t\tjiffies_to_msecs(jiffies) - jiffies_to_msecs(start_time),\n\t\t\twait_status);\n\t}\n\n\tif ((wait_status & 0xc0) != 0x80) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto err_mutex_unlock;\n\t}\n\n\tmutex_unlock(&dev->i2c_mutex);\n\treturn 0;\n\nerr_mutex_unlock:\n\tmutex_unlock(&dev->i2c_mutex);\n\tdev_err(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int si2157_set_params(struct dvb_frontend *fe)\n{\n\tstruct i2c_client *client = fe->tuner_priv;\n\tstruct si2157_dev *dev = i2c_get_clientdata(client);\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret;\n\tstruct si2157_cmd cmd;\n\tu8 bw, delivery_system;\n\tu32 bandwidth;\n\tu32 if_frequency = 5000000;\n\n\tdev_dbg(&client->dev,\n\t\t\t\"delivery_system=%d frequency=%u bandwidth_hz=%u\\n\",\n\t\t\tc->delivery_system, c->frequency, c->bandwidth_hz);\n\n\tif (!dev->active) {\n\t\tret = -EAGAIN;\n\t\tgoto err;\n\t}\n\n\tif (SUPPORTS_1700KHz(dev) && c->bandwidth_hz <= 1700000) {\n\t\tbandwidth = 1700000;\n\t\tbw = 9;\n\t} else if (c->bandwidth_hz <= 6000000) {\n\t\tbandwidth = 6000000;\n\t\tbw = 6;\n\t} else if (SUPPORTS_1700KHz(dev) && c->bandwidth_hz <= 6100000) {\n\t\tbandwidth = 6100000;\n\t\tbw = 10;\n\t} else if (c->bandwidth_hz <= 7000000) {\n\t\tbandwidth = 7000000;\n\t\tbw = 7;\n\t} else {\n\t\tbandwidth = 8000000;\n\t\tbw = 8;\n\t}\n\n\tswitch (c->delivery_system) {\n\tcase SYS_ATSC:\n\t\t\tdelivery_system = 0x00;\n\t\t\tif_frequency = 3250000;\n\t\t\tbreak;\n\tcase SYS_DVBC_ANNEX_B:\n\t\t\tdelivery_system = 0x10;\n\t\t\tif_frequency = 4000000;\n\t\t\tbreak;\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:  \n\t\t\tdelivery_system = 0x20;\n\t\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\tcase SYS_DVBC_ANNEX_C:\n\t\t\tdelivery_system = 0x30;\n\t\t\tbreak;\n\tcase SYS_ISDBT:\n\t\t\tdelivery_system = 0x40;\n\t\t\tbreak;\n\tcase SYS_DTMB:\n\t\t\tdelivery_system = 0x60;\n\t\t\tbreak;\n\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t}\n\n\tmemcpy(cmd.args, \"\\x14\\x00\\x03\\x07\\x00\\x00\", 6);\n\tcmd.args[4] = delivery_system | bw;\n\tif (dev->inversion)\n\t\tcmd.args[5] = 0x01;\n\tcmd.wlen = 6;\n\tcmd.rlen = 4;\n\tret = si2157_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tif (dev->part_id == SI2146)\n\t\tmemcpy(cmd.args, \"\\x14\\x00\\x02\\x07\\x00\\x01\", 6);\n\telse\n\t\tmemcpy(cmd.args, \"\\x14\\x00\\x02\\x07\\x00\\x00\", 6);\n\tcmd.args[4] = dev->if_port;\n\tcmd.wlen = 6;\n\tcmd.rlen = 4;\n\tret = si2157_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tif (if_frequency != dev->if_frequency) {\n\t\tmemcpy(cmd.args, \"\\x14\\x00\\x06\\x07\", 4);\n\t\tcmd.args[4] = (if_frequency / 1000) & 0xff;\n\t\tcmd.args[5] = ((if_frequency / 1000) >> 8) & 0xff;\n\t\tcmd.wlen = 6;\n\t\tcmd.rlen = 4;\n\t\tret = si2157_cmd_execute(client, &cmd);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tdev->if_frequency = if_frequency;\n\t}\n\n\t \n\tmemcpy(cmd.args, \"\\x41\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8);\n\tcmd.args[4] = (c->frequency >>  0) & 0xff;\n\tcmd.args[5] = (c->frequency >>  8) & 0xff;\n\tcmd.args[6] = (c->frequency >> 16) & 0xff;\n\tcmd.args[7] = (c->frequency >> 24) & 0xff;\n\tcmd.wlen = 8;\n\tcmd.rlen = 1;\n\tret = si2157_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tdev->bandwidth = bandwidth;\n\tdev->frequency = c->frequency;\n\n\tsi2157_tune_wait(client, 1);  \n\n\treturn 0;\nerr:\n\tdev->bandwidth = 0;\n\tdev->frequency = 0;\n\tdev->if_frequency = 0;\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int si2157_set_analog_params(struct dvb_frontend *fe,\n\t\t\t\t    struct analog_parameters *params)\n{\n\tstruct i2c_client *client = fe->tuner_priv;\n\tstruct si2157_dev *dev = i2c_get_clientdata(client);\n\tchar *std;  \n\tint ret;\n\tstruct si2157_cmd cmd;\n\tu32 bandwidth = 0;\n\tu32 if_frequency = 0;\n\tu32 freq = 0;\n\tu64 tmp_lval = 0;\n\tu8 system = 0;\n\tu8 color = 0;     \n\tu8 invert_analog = 1;  \n\n\tif (!SUPPORTS_ATV_IF(dev)) {\n\t\tdev_info(&client->dev, \"Analog tuning not supported yet for Si21%d\\n\",\n\t\t\t dev->part_id);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (!dev->active)\n\t\tsi2157_init(fe);\n\n\tif (!dev->active) {\n\t\tret = -EAGAIN;\n\t\tgoto err;\n\t}\n\tif (params->mode == V4L2_TUNER_RADIO) {\n\t \n\t\tdev_err(&client->dev, \"si2157 does not currently support FM radio\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\ttmp_lval = params->frequency * 625LL;\n\tdo_div(tmp_lval, 10);  \n\tfreq = (u32)tmp_lval;\n\n\tif (freq < 1000000)  \n\t\tfreq = freq * 1000;\n\tdev->frequency = freq;\n\n\t \n\tif (params->std & (V4L2_STD_B | V4L2_STD_GH)) {\n\t\tif (freq >= 470000000) {\n\t\t\tstd = \"palGH\";\n\t\t\tbandwidth = 8000000;\n\t\t\tif_frequency = 6000000;\n\t\t\tsystem = 1;\n\t\t\tif (params->std &\n\t\t\t    (V4L2_STD_SECAM_G | V4L2_STD_SECAM_H)) {\n\t\t\t\tstd = \"secamGH\";\n\t\t\t\tcolor = 0x10;\n\t\t\t}\n\t\t} else {\n\t\t\tstd = \"palB\";\n\t\t\tbandwidth = 7000000;\n\t\t\tif_frequency = 6000000;\n\t\t\tsystem = 0;\n\t\t\tif (params->std & V4L2_STD_SECAM_B) {\n\t\t\t\tstd = \"secamB\";\n\t\t\t\tcolor = 0x10;\n\t\t\t}\n\t\t}\n\t} else if (params->std & V4L2_STD_MN) {\n\t\tstd = \"MN\";\n\t\tbandwidth = 6000000;\n\t\tif_frequency = 5400000;\n\t\tsystem = 2;\n\t} else if (params->std & V4L2_STD_PAL_I) {\n\t\tstd = \"palI\";\n\t\tbandwidth = 8000000;\n\t\tif_frequency = 7250000;  \n\t\tsystem = 4;\n\t} else if (params->std & V4L2_STD_DK) {\n\t\tstd = \"palDK\";\n\t\tbandwidth = 8000000;\n\t\tif_frequency = 6900000;  \n\t\tsystem = 5;\n\t\tif (params->std & V4L2_STD_SECAM_DK) {\n\t\t\tstd = \"secamDK\";\n\t\t\tcolor = 0x10;\n\t\t}\n\t} else if (params->std & V4L2_STD_SECAM_L) {\n\t\tstd = \"secamL\";\n\t\tbandwidth = 8000000;\n\t\tif_frequency = 6750000;  \n\t\tsystem = 6;\n\t\tcolor = 0x10;\n\t} else if (params->std & V4L2_STD_SECAM_LC) {\n\t\tstd = \"secamL'\";\n\t\tbandwidth = 7000000;\n\t\tif_frequency = 1250000;  \n\t\tsystem = 7;\n\t\tcolor = 0x10;\n\t} else {\n\t\tstd = \"unknown\";\n\t}\n\t \n\tfreq = freq - 1250000 + (bandwidth / 2);\n\n\tdev_dbg(&client->dev,\n\t\t\"mode=%d system=%u std='%s' params->frequency=%u center freq=%u if=%u bandwidth=%u\\n\",\n\t\tparams->mode, system, std, params->frequency,\n\t\tfreq, if_frequency, bandwidth);\n\n\t \n\tmemcpy(cmd.args, \"\\x14\\x00\\x03\\x06\\x08\\x02\", 6);\n\t \n\t \n\t \n\tcmd.args[4] = (dev->if_port == 1) ? 8 : 10;\n\t \n\tcmd.args[5] = (dev->if_port == 1) ? 2 : 1;\n\tcmd.wlen = 6;\n\tcmd.rlen = 4;\n\tret = si2157_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tmemcpy(cmd.args, \"\\x14\\x00\\x0d\\x06\\x94\\x64\", 6);\n\tcmd.wlen = 6;\n\tcmd.rlen = 4;\n\tret = si2157_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tdev->if_frequency = if_frequency | 1;\n\n\t \n\tif_frequency = if_frequency + 1250000 - (bandwidth / 2);\n\tdev_dbg(&client->dev, \"IF Ctr freq=%d\\n\", if_frequency);\n\n\tmemcpy(cmd.args, \"\\x14\\x00\\x0C\\x06\", 4);\n\tcmd.args[4] = (if_frequency / 1000) & 0xff;\n\tcmd.args[5] = ((if_frequency / 1000) >> 8) & 0xff;\n\tcmd.wlen = 6;\n\tcmd.rlen = 4;\n\tret = si2157_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tmemcpy(cmd.args, \"\\x14\\x00\\x07\\x06\\x32\\xc8\", 6);\n\tcmd.wlen = 6;\n\tcmd.rlen = 4;\n\tret = si2157_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tmemcpy(cmd.args, \"\\x14\\x00\\x04\\x06\\x00\\x00\", 6);\n\tcmd.args[4] = system | color;\n\t \n\tif (invert_analog)\n\t\tcmd.args[5] |= 0x02;\n\tcmd.wlen = 6;\n\tcmd.rlen = 1;\n\tret = si2157_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tmemcpy(cmd.args, \"\\x41\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", 8);\n\tcmd.args[4] = (freq >>  0) & 0xff;\n\tcmd.args[5] = (freq >>  8) & 0xff;\n\tcmd.args[6] = (freq >> 16) & 0xff;\n\tcmd.args[7] = (freq >> 24) & 0xff;\n\tcmd.wlen = 8;\n\tcmd.rlen = 1;\n\tret = si2157_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tdev->bandwidth = bandwidth;\n\n\tsi2157_tune_wait(client, 0);  \n\n\treturn 0;\nerr:\n\tdev->bandwidth = 0;\n\tdev->frequency = 0;\n\tdev->if_frequency = 0;\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int si2157_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct i2c_client *client = fe->tuner_priv;\n\tstruct si2157_dev *dev = i2c_get_clientdata(client);\n\n\t*frequency = dev->frequency;\n\tdev_dbg(&client->dev, \"freq=%u\\n\", dev->frequency);\n\treturn 0;\n}\n\nstatic int si2157_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\n{\n\tstruct i2c_client *client = fe->tuner_priv;\n\tstruct si2157_dev *dev = i2c_get_clientdata(client);\n\n\t*bandwidth = dev->bandwidth;\n\tdev_dbg(&client->dev, \"bandwidth=%u\\n\", dev->bandwidth);\n\treturn 0;\n}\n\nstatic int si2157_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct i2c_client *client = fe->tuner_priv;\n\tstruct si2157_dev *dev = i2c_get_clientdata(client);\n\n\t*frequency = dev->if_frequency & ~1;  \n\tdev_dbg(&client->dev, \"if_frequency=%u\\n\", *frequency);\n\treturn 0;\n}\n\nstatic int si2157_get_rf_strength(struct dvb_frontend *fe, u16 *rssi)\n{\n\tstruct i2c_client *client = fe->tuner_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct si2157_cmd cmd;\n\tint ret;\n\tint strength;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tmemcpy(cmd.args, \"\\x42\\x00\", 2);\n\tcmd.wlen = 2;\n\tcmd.rlen = 12;\n\tret = si2157_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tc->strength.stat[0].scale = FE_SCALE_DECIBEL;\n\tc->strength.stat[0].svalue = (s8)cmd.args[3] * 1000;\n\n\t \n\tstrength = (s8)cmd.args[3] + 100;\n\tstrength = clamp_val(strength, 0, 80);\n\t*rssi = (u16)(strength * 0xffff / 80);\n\n\tdev_dbg(&client->dev, \"strength=%d rssi=%u\\n\",\n\t\t(s8)cmd.args[3], *rssi);\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct dvb_tuner_ops si2157_ops = {\n\t.info = {\n\t\t.name             = \"Silicon Labs Si2141/Si2146/2147/2148/2157/2158\",\n\t\t.frequency_min_hz =  42 * MHz,\n\t\t.frequency_max_hz = 870 * MHz,\n\t},\n\n\t.init = si2157_init,\n\t.sleep = si2157_sleep,\n\t.set_params = si2157_set_params,\n\t.set_analog_params = si2157_set_analog_params,\n\t.get_frequency     = si2157_get_frequency,\n\t.get_bandwidth     = si2157_get_bandwidth,\n\t.get_if_frequency  = si2157_get_if_frequency,\n\n\t.get_rf_strength   = si2157_get_rf_strength,\n};\n\nstatic void si2157_stat_work(struct work_struct *work)\n{\n\tstruct si2157_dev *dev = container_of(work, struct si2157_dev, stat_work.work);\n\tstruct dvb_frontend *fe = dev->fe;\n\tstruct i2c_client *client = fe->tuner_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct si2157_cmd cmd;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tmemcpy(cmd.args, \"\\x42\\x00\", 2);\n\tcmd.wlen = 2;\n\tcmd.rlen = 12;\n\tret = si2157_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tc->strength.stat[0].scale = FE_SCALE_DECIBEL;\n\tc->strength.stat[0].svalue = (s8) cmd.args[3] * 1000;\n\n\tschedule_delayed_work(&dev->stat_work, msecs_to_jiffies(2000));\n\treturn;\nerr:\n\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n}\n\nstatic int si2157_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct si2157_config *cfg = client->dev.platform_data;\n\tstruct dvb_frontend *fe = cfg->fe;\n\tstruct si2157_dev *dev;\n\tstruct si2157_cmd cmd;\n\tint ret;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tdev_err(&client->dev, \"kzalloc() failed\\n\");\n\t\tgoto err;\n\t}\n\n\ti2c_set_clientdata(client, dev);\n\tdev->fe = cfg->fe;\n\tdev->inversion = cfg->inversion;\n\tdev->dont_load_firmware = cfg->dont_load_firmware;\n\tdev->if_port = cfg->if_port;\n\tdev->part_id = (u8)id->driver_data;\n\tdev->if_frequency = 5000000;  \n\tmutex_init(&dev->i2c_mutex);\n\tINIT_DELAYED_WORK(&dev->stat_work, si2157_stat_work);\n\n\t \n\tcmd.wlen = 0;\n\tcmd.rlen = 1;\n\tret = si2157_cmd_execute(client, &cmd);\n\tif (ret && ret != -EAGAIN)\n\t\tgoto err_kfree;\n\n\tmemcpy(&fe->ops.tuner_ops, &si2157_ops, sizeof(struct dvb_tuner_ops));\n\tfe->tuner_priv = client;\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tif (cfg->mdev) {\n\t\tdev->mdev = cfg->mdev;\n\n\t\tdev->ent.name = KBUILD_MODNAME;\n\t\tdev->ent.function = MEDIA_ENT_F_TUNER;\n\n\t\tdev->pad[SI2157_PAD_RF_INPUT].flags = MEDIA_PAD_FL_SINK;\n\t\tdev->pad[SI2157_PAD_RF_INPUT].sig_type = PAD_SIGNAL_ANALOG;\n\t\tdev->pad[SI2157_PAD_VID_OUT].flags = MEDIA_PAD_FL_SOURCE;\n\t\tdev->pad[SI2157_PAD_VID_OUT].sig_type = PAD_SIGNAL_ANALOG;\n\t\tdev->pad[SI2157_PAD_AUD_OUT].flags = MEDIA_PAD_FL_SOURCE;\n\t\tdev->pad[SI2157_PAD_AUD_OUT].sig_type = PAD_SIGNAL_AUDIO;\n\n\t\tret = media_entity_pads_init(&dev->ent, SI2157_NUM_PADS,\n\t\t\t\t\t     &dev->pad[0]);\n\n\t\tif (ret)\n\t\t\tgoto err_kfree;\n\n\t\tret = media_device_register_entity(cfg->mdev, &dev->ent);\n\t\tif (ret) {\n\t\t\tmedia_entity_cleanup(&dev->ent);\n\t\t\tgoto err_kfree;\n\t\t}\n\t}\n#endif\n\n\tdev_info(&client->dev, \"Silicon Labs Si21%d successfully attached\\n\",\n\t\t dev->part_id);\n\n\treturn 0;\n\nerr_kfree:\n\tkfree(dev);\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void si2157_remove(struct i2c_client *client)\n{\n\tstruct si2157_dev *dev = i2c_get_clientdata(client);\n\tstruct dvb_frontend *fe = dev->fe;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tcancel_delayed_work_sync(&dev->stat_work);\n\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tif (dev->mdev)\n\t\tmedia_device_unregister_entity(&dev->ent);\n#endif\n\n\tmemset(&fe->ops.tuner_ops, 0, sizeof(struct dvb_tuner_ops));\n\tfe->tuner_priv = NULL;\n\tkfree(dev);\n}\n\n \nstatic const struct i2c_device_id si2157_id_table[] = {\n\t{\"si2157\", SI2157},\n\t{\"si2146\", SI2146},\n\t{\"si2141\", SI2141},\n\t{\"si2177\", SI2177},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, si2157_id_table);\n\nstatic struct i2c_driver si2157_driver = {\n\t.driver = {\n\t\t.name\t\t     = \"si2157\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= si2157_probe,\n\t.remove\t\t= si2157_remove,\n\t.id_table\t= si2157_id_table,\n};\n\nmodule_i2c_driver(si2157_driver);\n\nMODULE_DESCRIPTION(\"Silicon Labs Si2141/Si2146/2147/2148/2157/2158 silicon tuner driver\");\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(SI2158_A20_FIRMWARE);\nMODULE_FIRMWARE(SI2141_A10_FIRMWARE);\nMODULE_FIRMWARE(SI2157_A30_FIRMWARE);\nMODULE_FIRMWARE(SI2141_60_FIRMWARE);\nMODULE_FIRMWARE(SI2141_61_FIRMWARE);\nMODULE_FIRMWARE(SI2146_11_FIRMWARE);\nMODULE_FIRMWARE(SI2147_50_FIRMWARE);\nMODULE_FIRMWARE(SI2148_32_FIRMWARE);\nMODULE_FIRMWARE(SI2148_33_FIRMWARE);\nMODULE_FIRMWARE(SI2157_50_FIRMWARE);\nMODULE_FIRMWARE(SI2158_50_FIRMWARE);\nMODULE_FIRMWARE(SI2158_51_FIRMWARE);\nMODULE_FIRMWARE(SI2177_50_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}