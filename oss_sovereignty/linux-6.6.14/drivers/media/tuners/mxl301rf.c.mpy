{
  "module_name": "mxl301rf.c",
  "hash_id": "8d6b756c16cf6739547da3dcdde10d7d007127f4599f883da222505e6b595db9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/mxl301rf.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include \"mxl301rf.h\"\n\nstruct mxl301rf_state {\n\tstruct mxl301rf_config cfg;\n\tstruct i2c_client *i2c;\n};\n\nstatic struct mxl301rf_state *cfg_to_state(struct mxl301rf_config *c)\n{\n\treturn container_of(c, struct mxl301rf_state, cfg);\n}\n\nstatic int raw_write(struct mxl301rf_state *state, const u8 *buf, int len)\n{\n\tint ret;\n\n\tret = i2c_master_send(state->i2c, buf, len);\n\tif (ret >= 0 && ret < len)\n\t\tret = -EIO;\n\treturn (ret == len) ? 0 : ret;\n}\n\nstatic int reg_write(struct mxl301rf_state *state, u8 reg, u8 val)\n{\n\tu8 buf[2] = { reg, val };\n\n\treturn raw_write(state, buf, 2);\n}\n\nstatic int reg_read(struct mxl301rf_state *state, u8 reg, u8 *val)\n{\n\tu8 wbuf[2] = { 0xfb, reg };\n\tint ret;\n\n\tret = raw_write(state, wbuf, sizeof(wbuf));\n\tif (ret == 0)\n\t\tret = i2c_master_recv(state->i2c, val, 1);\n\tif (ret >= 0 && ret < 1)\n\t\tret = -EIO;\n\treturn (ret == 1) ? 0 : ret;\n}\n\n \n\n \nstatic int mxl301rf_get_rf_strength(struct dvb_frontend *fe, u16 *out)\n{\n\tstruct mxl301rf_state *state;\n\tint ret;\n\tu8  rf_in1, rf_in2, rf_off1, rf_off2;\n\tu16 rf_in, rf_off;\n\ts64 level;\n\tstruct dtv_fe_stats *rssi;\n\n\trssi = &fe->dtv_property_cache.strength;\n\trssi->len = 1;\n\trssi->stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t*out = 0;\n\n\tstate = fe->tuner_priv;\n\tret = reg_write(state, 0x14, 0x01);\n\tif (ret < 0)\n\t\treturn ret;\n\tusleep_range(1000, 2000);\n\n\tret = reg_read(state, 0x18, &rf_in1);\n\tif (ret == 0)\n\t\tret = reg_read(state, 0x19, &rf_in2);\n\tif (ret == 0)\n\t\tret = reg_read(state, 0xd6, &rf_off1);\n\tif (ret == 0)\n\t\tret = reg_read(state, 0xd7, &rf_off2);\n\tif (ret != 0)\n\t\treturn ret;\n\n\trf_in = (rf_in2 & 0x07) << 8 | rf_in1;\n\trf_off = (rf_off2 & 0x0f) << 5 | (rf_off1 >> 3);\n\tlevel = rf_in - rf_off - (113 << 3);  \n\tlevel = level * 1000 / 8;\n\trssi->stat[0].svalue = level;\n\trssi->stat[0].scale = FE_SCALE_DECIBEL;\n\t \n\t*out = (rf_in - rf_off + (1 << 9) - 1) * 100 / ((5 << 9) - 2);\n\treturn 0;\n}\n\n \nstruct shf {\n\tu32\tfreq;\t\t \n\tu32\tofst_th;\t \n\tu8\tshf_val;\t \n\tu8\tshf_dir;\t \n};\n\nstatic const struct shf shf_tab[] = {\n\t{  64500, 500, 0x92, 0x07 },\n\t{ 191500, 300, 0xe2, 0x07 },\n\t{ 205500, 500, 0x2c, 0x04 },\n\t{ 212500, 500, 0x1e, 0x04 },\n\t{ 226500, 500, 0xd4, 0x07 },\n\t{  99143, 500, 0x9c, 0x07 },\n\t{ 173143, 500, 0xd4, 0x07 },\n\t{ 191143, 300, 0xd4, 0x07 },\n\t{ 207143, 500, 0xce, 0x07 },\n\t{ 225143, 500, 0xce, 0x07 },\n\t{ 243143, 500, 0xd4, 0x07 },\n\t{ 261143, 500, 0xd4, 0x07 },\n\t{ 291143, 500, 0xd4, 0x07 },\n\t{ 339143, 500, 0x2c, 0x04 },\n\t{ 117143, 500, 0x7a, 0x07 },\n\t{ 135143, 300, 0x7a, 0x07 },\n\t{ 153143, 500, 0x01, 0x07 }\n};\n\nstruct reg_val {\n\tu8 reg;\n\tu8 val;\n} __attribute__ ((__packed__));\n\nstatic const struct reg_val set_idac[] = {\n\t{ 0x0d, 0x00 },\n\t{ 0x0c, 0x67 },\n\t{ 0x6f, 0x89 },\n\t{ 0x70, 0x0c },\n\t{ 0x6f, 0x8a },\n\t{ 0x70, 0x0e },\n\t{ 0x6f, 0x8b },\n\t{ 0x70, 0x1c },\n};\n\nstatic int mxl301rf_set_params(struct dvb_frontend *fe)\n{\n\tstruct reg_val tune0[] = {\n\t\t{ 0x13, 0x00 },\t\t \n\t\t{ 0x3b, 0xc0 },\n\t\t{ 0x3b, 0x80 },\n\t\t{ 0x10, 0x95 },\t\t \n\t\t{ 0x1a, 0x05 },\n\t\t{ 0x61, 0x00 },\t\t \n\t\t{ 0x62, 0xa0 }\t\t \n\t};\n\n\tstruct reg_val tune1[] = {\n\t\t{ 0x11, 0x40 },\t\t \n\t\t{ 0x12, 0x0e },\t\t \n\t\t{ 0x13, 0x01 }\t\t \n\t};\n\n\tstruct mxl301rf_state *state;\n\tu32 freq;\n\tu16 f;\n\tu32 tmp, div;\n\tint i, ret;\n\n\tstate = fe->tuner_priv;\n\tfreq = fe->dtv_property_cache.frequency;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(shf_tab); i++) {\n\t\tif (freq >= (shf_tab[i].freq - shf_tab[i].ofst_th) * 1000 &&\n\t\t    freq <= (shf_tab[i].freq + shf_tab[i].ofst_th) * 1000) {\n\t\t\ttune0[5].val = shf_tab[i].shf_val;\n\t\t\ttune0[6].val = 0xa0 | shf_tab[i].shf_dir;\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = raw_write(state, (u8 *) tune0, sizeof(tune0));\n\tif (ret < 0)\n\t\tgoto failed;\n\tusleep_range(3000, 4000);\n\n\t \n\tf = freq / 1000000;\n\ttmp = freq % 1000000;\n\tdiv = 1000000;\n\tfor (i = 0; i < 6; i++) {\n\t\tf <<= 1;\n\t\tdiv >>= 1;\n\t\tif (tmp > div) {\n\t\t\ttmp -= div;\n\t\t\tf |= 1;\n\t\t}\n\t}\n\tif (tmp > 7812)\n\t\tf++;\n\ttune1[0].val = f & 0xff;\n\ttune1[1].val = f >> 8;\n\tret = raw_write(state, (u8 *) tune1, sizeof(tune1));\n\tif (ret < 0)\n\t\tgoto failed;\n\tmsleep(31);\n\n\tret = reg_write(state, 0x1a, 0x0d);\n\tif (ret < 0)\n\t\tgoto failed;\n\tret = raw_write(state, (u8 *) set_idac, sizeof(set_idac));\n\tif (ret < 0)\n\t\tgoto failed;\n\treturn 0;\n\nfailed:\n\tdev_warn(&state->i2c->dev, \"(%s) failed. [adap%d-fe%d]\\n\",\n\t\t__func__, fe->dvb->num, fe->id);\n\treturn ret;\n}\n\nstatic const struct reg_val standby_data[] = {\n\t{ 0x01, 0x00 },\n\t{ 0x13, 0x00 }\n};\n\nstatic int mxl301rf_sleep(struct dvb_frontend *fe)\n{\n\tstruct mxl301rf_state *state;\n\tint ret;\n\n\tstate = fe->tuner_priv;\n\tret = raw_write(state, (u8 *)standby_data, sizeof(standby_data));\n\tif (ret < 0)\n\t\tdev_warn(&state->i2c->dev, \"(%s) failed. [adap%d-fe%d]\\n\",\n\t\t\t__func__, fe->dvb->num, fe->id);\n\treturn ret;\n}\n\n\n \nstatic int mxl301rf_init(struct dvb_frontend *fe)\n{\n\tstruct mxl301rf_state *state;\n\tint ret;\n\n\tstate = fe->tuner_priv;\n\n\tret = reg_write(state, 0x01, 0x01);\n\tif (ret < 0) {\n\t\tdev_warn(&state->i2c->dev, \"(%s) failed. [adap%d-fe%d]\\n\",\n\t\t\t __func__, fe->dvb->num, fe->id);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \n\nstatic const struct dvb_tuner_ops mxl301rf_ops = {\n\t.info = {\n\t\t.name = \"MaxLinear MxL301RF\",\n\n\t\t.frequency_min_hz =  93 * MHz,\n\t\t.frequency_max_hz = 803 * MHz + 142857,\n\t},\n\n\t.init = mxl301rf_init,\n\t.sleep = mxl301rf_sleep,\n\n\t.set_params = mxl301rf_set_params,\n\t.get_rf_strength = mxl301rf_get_rf_strength,\n};\n\n\nstatic int mxl301rf_probe(struct i2c_client *client)\n{\n\tstruct mxl301rf_state *state;\n\tstruct mxl301rf_config *cfg;\n\tstruct dvb_frontend *fe;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->i2c = client;\n\tcfg = client->dev.platform_data;\n\n\tmemcpy(&state->cfg, cfg, sizeof(state->cfg));\n\tfe = cfg->fe;\n\tfe->tuner_priv = state;\n\tmemcpy(&fe->ops.tuner_ops, &mxl301rf_ops, sizeof(mxl301rf_ops));\n\n\ti2c_set_clientdata(client, &state->cfg);\n\tdev_info(&client->dev, \"MaxLinear MxL301RF attached.\\n\");\n\treturn 0;\n}\n\nstatic void mxl301rf_remove(struct i2c_client *client)\n{\n\tstruct mxl301rf_state *state;\n\n\tstate = cfg_to_state(i2c_get_clientdata(client));\n\tstate->cfg.fe->tuner_priv = NULL;\n\tkfree(state);\n}\n\n\nstatic const struct i2c_device_id mxl301rf_id[] = {\n\t{\"mxl301rf\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, mxl301rf_id);\n\nstatic struct i2c_driver mxl301rf_driver = {\n\t.driver = {\n\t\t.name\t= \"mxl301rf\",\n\t},\n\t.probe\t\t= mxl301rf_probe,\n\t.remove\t\t= mxl301rf_remove,\n\t.id_table\t= mxl301rf_id,\n};\n\nmodule_i2c_driver(mxl301rf_driver);\n\nMODULE_DESCRIPTION(\"MaxLinear MXL301RF tuner\");\nMODULE_AUTHOR(\"Akihiro TSUKADA\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}