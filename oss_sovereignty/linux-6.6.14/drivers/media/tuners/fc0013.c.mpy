{
  "module_name": "fc0013.c",
  "hash_id": "3b804568c1a99ba5b4b9bb83f4d26ae09f8b628ac9a26281fa31a9308011d1b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/fc0013.c",
  "human_readable_source": "\n \n\n#include \"fc0013.h\"\n#include \"fc0013-priv.h\"\n\nstatic int fc0013_writereg(struct fc0013_priv *priv, u8 reg, u8 val)\n{\n\tu8 buf[2] = {reg, val};\n\tstruct i2c_msg msg = {\n\t\t.addr = priv->addr, .flags = 0, .buf = buf, .len = 2\n\t};\n\n\tif (i2c_transfer(priv->i2c, &msg, 1) != 1) {\n\t\terr(\"I2C write reg failed, reg: %02x, val: %02x\", reg, val);\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic int fc0013_readreg(struct fc0013_priv *priv, u8 reg, u8 *val)\n{\n\tstruct i2c_msg msg[2] = {\n\t\t{ .addr = priv->addr, .flags = 0, .buf = &reg, .len = 1 },\n\t\t{ .addr = priv->addr, .flags = I2C_M_RD, .buf = val, .len = 1 },\n\t};\n\n\tif (i2c_transfer(priv->i2c, msg, 2) != 2) {\n\t\terr(\"I2C read reg failed, reg: %02x\", reg);\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic void fc0013_release(struct dvb_frontend *fe)\n{\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic int fc0013_init(struct dvb_frontend *fe)\n{\n\tstruct fc0013_priv *priv = fe->tuner_priv;\n\tint i, ret = 0;\n\tunsigned char reg[] = {\n\t\t0x00,\t \n\t\t0x09,\t \n\t\t0x16,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x17,\t \n\t\t0x02,\t \n\t\t0x0a,\t \n\t\t0xff,\t \n\t\t0x6f,\t \n\t\t0xb8,\t \n\t\t0x82,\t \n\t\t0xfc,\t \n\t\t0x01,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x50,\t \n\t\t0x01,\t \n\t};\n\n\tswitch (priv->xtal_freq) {\n\tcase FC_XTAL_27_MHZ:\n\tcase FC_XTAL_28_8_MHZ:\n\t\treg[0x07] |= 0x20;\n\t\tbreak;\n\tcase FC_XTAL_36_MHZ:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (priv->dual_master)\n\t\treg[0x0c] |= 0x02;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\tfor (i = 1; i < sizeof(reg); i++) {\n\t\tret = fc0013_writereg(priv, i, reg[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\tif (ret)\n\t\terr(\"fc0013_writereg failed: %d\", ret);\n\n\treturn ret;\n}\n\nstatic int fc0013_sleep(struct dvb_frontend *fe)\n{\n\t \n\treturn 0;\n}\n\nint fc0013_rc_cal_add(struct dvb_frontend *fe, int rc_val)\n{\n\tstruct fc0013_priv *priv = fe->tuner_priv;\n\tint ret;\n\tu8 rc_cal;\n\tint val;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\t \n\tret = fc0013_writereg(priv, 0x10, 0x00);\n\tif (ret)\n\t\tgoto error_out;\n\n\t \n\tret = fc0013_readreg(priv, 0x10, &rc_cal);\n\tif (ret)\n\t\tgoto error_out;\n\n\trc_cal &= 0x0f;\n\n\tval = (int)rc_cal + rc_val;\n\n\t \n\tret = fc0013_writereg(priv, 0x0d, 0x11);\n\tif (ret)\n\t\tgoto error_out;\n\n\t \n\tif (val > 15)\n\t\tret = fc0013_writereg(priv, 0x10, 0x0f);\n\telse if (val < 0)\n\t\tret = fc0013_writereg(priv, 0x10, 0x00);\n\telse\n\t\tret = fc0013_writereg(priv, 0x10, (u8)val);\n\nerror_out:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\treturn ret;\n}\nEXPORT_SYMBOL(fc0013_rc_cal_add);\n\nint fc0013_rc_cal_reset(struct dvb_frontend *fe)\n{\n\tstruct fc0013_priv *priv = fe->tuner_priv;\n\tint ret;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\tret = fc0013_writereg(priv, 0x0d, 0x01);\n\tif (!ret)\n\t\tret = fc0013_writereg(priv, 0x10, 0x00);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\treturn ret;\n}\nEXPORT_SYMBOL(fc0013_rc_cal_reset);\n\nstatic int fc0013_set_vhf_track(struct fc0013_priv *priv, u32 freq)\n{\n\tint ret;\n\tu8 tmp;\n\n\tret = fc0013_readreg(priv, 0x1d, &tmp);\n\tif (ret)\n\t\tgoto error_out;\n\ttmp &= 0xe3;\n\tif (freq <= 177500) {\t\t \n\t\tret = fc0013_writereg(priv, 0x1d, tmp | 0x1c);\n\t} else if (freq <= 184500) {\t \n\t\tret = fc0013_writereg(priv, 0x1d, tmp | 0x18);\n\t} else if (freq <= 191500) {\t \n\t\tret = fc0013_writereg(priv, 0x1d, tmp | 0x14);\n\t} else if (freq <= 198500) {\t \n\t\tret = fc0013_writereg(priv, 0x1d, tmp | 0x10);\n\t} else if (freq <= 205500) {\t \n\t\tret = fc0013_writereg(priv, 0x1d, tmp | 0x0c);\n\t} else if (freq <= 219500) {\t \n\t\tret = fc0013_writereg(priv, 0x1d, tmp | 0x08);\n\t} else if (freq < 300000) {\t \n\t\tret = fc0013_writereg(priv, 0x1d, tmp | 0x04);\n\t} else {\t\t\t \n\t\tret = fc0013_writereg(priv, 0x1d, tmp | 0x1c);\n\t}\nerror_out:\n\treturn ret;\n}\n\nstatic int fc0013_set_params(struct dvb_frontend *fe)\n{\n\tstruct fc0013_priv *priv = fe->tuner_priv;\n\tint i, ret = 0;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tu32 freq = p->frequency / 1000;\n\tu32 delsys = p->delivery_system;\n\tunsigned char reg[7], am, pm, multi, tmp;\n\tunsigned long f_vco;\n\tunsigned short xtal_freq_khz_2, xin, xdiv;\n\tbool vco_select = false;\n\n\tif (fe->callback) {\n\t\tret = fe->callback(priv->i2c, DVB_FRONTEND_COMPONENT_TUNER,\n\t\t\tFC_FE_CALLBACK_VHF_ENABLE, (freq > 300000 ? 0 : 1));\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\tswitch (priv->xtal_freq) {\n\tcase FC_XTAL_27_MHZ:\n\t\txtal_freq_khz_2 = 27000 / 2;\n\t\tbreak;\n\tcase FC_XTAL_36_MHZ:\n\t\txtal_freq_khz_2 = 36000 / 2;\n\t\tbreak;\n\tcase FC_XTAL_28_8_MHZ:\n\tdefault:\n\t\txtal_freq_khz_2 = 28800 / 2;\n\t\tbreak;\n\t}\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\t \n\tret = fc0013_set_vhf_track(priv, freq);\n\tif (ret)\n\t\tgoto exit;\n\n\tif (freq < 300000) {\n\t\t \n\t\tret = fc0013_readreg(priv, 0x07, &tmp);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t\tret = fc0013_writereg(priv, 0x07, tmp | 0x10);\n\t\tif (ret)\n\t\t\tgoto exit;\n\n\t\t \n\t\tret = fc0013_readreg(priv, 0x14, &tmp);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t\tret = fc0013_writereg(priv, 0x14, tmp & 0x1f);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t} else if (freq <= 862000) {\n\t\t \n\t\tret = fc0013_readreg(priv, 0x07, &tmp);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t\tret = fc0013_writereg(priv, 0x07, tmp & 0xef);\n\t\tif (ret)\n\t\t\tgoto exit;\n\n\t\t \n\t\tret = fc0013_readreg(priv, 0x14, &tmp);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t\tret = fc0013_writereg(priv, 0x14, (tmp & 0x1f) | 0x40);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t} else {\n\t\t \n\t\tret = fc0013_readreg(priv, 0x07, &tmp);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t\tret = fc0013_writereg(priv, 0x07, tmp & 0xef);\n\t\tif (ret)\n\t\t\tgoto exit;\n\n\t\t \n\t\tret = fc0013_readreg(priv, 0x14, &tmp);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t\tret = fc0013_writereg(priv, 0x14, (tmp & 0x1f) | 0x20);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\t \n\tif (freq < 37084) {\t\t \n\t\tmulti = 96;\n\t\treg[5] = 0x82;\n\t\treg[6] = 0x00;\n\t} else if (freq < 55625) {\t \n\t\tmulti = 64;\n\t\treg[5] = 0x02;\n\t\treg[6] = 0x02;\n\t} else if (freq < 74167) {\t \n\t\tmulti = 48;\n\t\treg[5] = 0x42;\n\t\treg[6] = 0x00;\n\t} else if (freq < 111250) {\t \n\t\tmulti = 32;\n\t\treg[5] = 0x82;\n\t\treg[6] = 0x02;\n\t} else if (freq < 148334) {\t \n\t\tmulti = 24;\n\t\treg[5] = 0x22;\n\t\treg[6] = 0x00;\n\t} else if (freq < 222500) {\t \n\t\tmulti = 16;\n\t\treg[5] = 0x42;\n\t\treg[6] = 0x02;\n\t} else if (freq < 296667) {\t \n\t\tmulti = 12;\n\t\treg[5] = 0x12;\n\t\treg[6] = 0x00;\n\t} else if (freq < 445000) {\t \n\t\tmulti = 8;\n\t\treg[5] = 0x22;\n\t\treg[6] = 0x02;\n\t} else if (freq < 593334) {\t \n\t\tmulti = 6;\n\t\treg[5] = 0x0a;\n\t\treg[6] = 0x00;\n\t} else if (freq < 950000) {\t \n\t\tmulti = 4;\n\t\treg[5] = 0x12;\n\t\treg[6] = 0x02;\n\t} else {\n\t\tmulti = 2;\n\t\treg[5] = 0x0a;\n\t\treg[6] = 0x02;\n\t}\n\n\tf_vco = freq * multi;\n\n\tif (f_vco >= 3060000) {\n\t\treg[6] |= 0x08;\n\t\tvco_select = true;\n\t}\n\n\tif (freq >= 45000) {\n\t\t \n\t\txdiv = (unsigned short)(f_vco / xtal_freq_khz_2);\n\t\tif ((f_vco - xdiv * xtal_freq_khz_2) >= (xtal_freq_khz_2 / 2))\n\t\t\txdiv++;\n\n\t\tpm = (unsigned char)(xdiv / 8);\n\t\tam = (unsigned char)(xdiv - (8 * pm));\n\n\t\tif (am < 2) {\n\t\t\treg[1] = am + 8;\n\t\t\treg[2] = pm - 1;\n\t\t} else {\n\t\t\treg[1] = am;\n\t\t\treg[2] = pm;\n\t\t}\n\t} else {\n\t\t \n\t\treg[1] = 0x06;\n\t\treg[2] = 0x11;\n\t}\n\n\t \n\treg[6] |= 0x20;\n\n\t \n\txin = (unsigned short)(f_vco - (f_vco / xtal_freq_khz_2) * xtal_freq_khz_2);\n\txin = (xin << 15) / xtal_freq_khz_2;\n\tif (xin >= 16384)\n\t\txin += 32768;\n\n\treg[3] = xin >> 8;\n\treg[4] = xin & 0xff;\n\n\tif (delsys == SYS_DVBT) {\n\t\treg[6] &= 0x3f;  \n\t\tswitch (p->bandwidth_hz) {\n\t\tcase 6000000:\n\t\t\treg[6] |= 0x80;\n\t\t\tbreak;\n\t\tcase 7000000:\n\t\t\treg[6] |= 0x40;\n\t\t\tbreak;\n\t\tcase 8000000:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\terr(\"%s: modulation type not supported!\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treg[5] |= 0x07;\n\n\tfor (i = 1; i <= 6; i++) {\n\t\tret = fc0013_writereg(priv, i, reg[i]);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\tret = fc0013_readreg(priv, 0x11, &tmp);\n\tif (ret)\n\t\tgoto exit;\n\tif (multi == 64)\n\t\tret = fc0013_writereg(priv, 0x11, tmp | 0x04);\n\telse\n\t\tret = fc0013_writereg(priv, 0x11, tmp & 0xfb);\n\tif (ret)\n\t\tgoto exit;\n\n\t \n\tret = fc0013_writereg(priv, 0x0e, 0x80);\n\tif (!ret)\n\t\tret = fc0013_writereg(priv, 0x0e, 0x00);\n\n\t \n\tif (!ret)\n\t\tret = fc0013_writereg(priv, 0x0e, 0x00);\n\n\tif (!ret) {\n\t\tmsleep(10);\n\t\tret = fc0013_readreg(priv, 0x0e, &tmp);\n\t}\n\tif (ret)\n\t\tgoto exit;\n\n\t \n\ttmp &= 0x3f;\n\n\tif (vco_select) {\n\t\tif (tmp > 0x3c) {\n\t\t\treg[6] &= ~0x08;\n\t\t\tret = fc0013_writereg(priv, 0x06, reg[6]);\n\t\t\tif (!ret)\n\t\t\t\tret = fc0013_writereg(priv, 0x0e, 0x80);\n\t\t\tif (!ret)\n\t\t\t\tret = fc0013_writereg(priv, 0x0e, 0x00);\n\t\t}\n\t} else {\n\t\tif (tmp < 0x02) {\n\t\t\treg[6] |= 0x08;\n\t\t\tret = fc0013_writereg(priv, 0x06, reg[6]);\n\t\t\tif (!ret)\n\t\t\t\tret = fc0013_writereg(priv, 0x0e, 0x80);\n\t\t\tif (!ret)\n\t\t\t\tret = fc0013_writereg(priv, 0x0e, 0x00);\n\t\t}\n\t}\n\n\tpriv->frequency = p->frequency;\n\tpriv->bandwidth = p->bandwidth_hz;\n\nexit:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\tif (ret)\n\t\twarn(\"%s: failed: %d\", __func__, ret);\n\treturn ret;\n}\n\nstatic int fc0013_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct fc0013_priv *priv = fe->tuner_priv;\n\t*frequency = priv->frequency;\n\treturn 0;\n}\n\nstatic int fc0013_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\t \n\t*frequency = 0;\n\treturn 0;\n}\n\nstatic int fc0013_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\n{\n\tstruct fc0013_priv *priv = fe->tuner_priv;\n\t*bandwidth = priv->bandwidth;\n\treturn 0;\n}\n\n#define INPUT_ADC_LEVEL\t-8\n\nstatic int fc0013_get_rf_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct fc0013_priv *priv = fe->tuner_priv;\n\tint ret;\n\tunsigned char tmp;\n\tint int_temp, lna_gain, int_lna, tot_agc_gain, power;\n\tstatic const int fc0013_lna_gain_table[] = {\n\t\t \n\t\t-63, -58, -99, -73,\n\t\t-63, -65, -54, -60,\n\t\t \n\t\t 71,  70,  68,  67,\n\t\t 65,  63,  61,  58,\n\t\t \n\t\t197, 191, 188, 186,\n\t\t184, 182, 181, 179,\n\t};\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\tret = fc0013_writereg(priv, 0x13, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\tret = fc0013_readreg(priv, 0x13, &tmp);\n\tif (ret)\n\t\tgoto err;\n\tint_temp = tmp;\n\n\tret = fc0013_readreg(priv, 0x14, &tmp);\n\tif (ret)\n\t\tgoto err;\n\tlna_gain = tmp & 0x1f;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\tif (lna_gain < ARRAY_SIZE(fc0013_lna_gain_table)) {\n\t\tint_lna = fc0013_lna_gain_table[lna_gain];\n\t\ttot_agc_gain = (abs((int_temp >> 5) - 7) - 2 +\n\t\t\t\t(int_temp & 0x1f)) * 2;\n\t\tpower = INPUT_ADC_LEVEL - tot_agc_gain - int_lna / 10;\n\n\t\tif (power >= 45)\n\t\t\t*strength = 255;\t \n\t\telse if (power < -95)\n\t\t\t*strength = 0;\n\t\telse\n\t\t\t*strength = (power + 95) * 255 / 140;\n\n\t\t*strength |= *strength << 8;\n\t} else {\n\t\tret = -1;\n\t}\n\n\tgoto exit;\n\nerr:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \nexit:\n\tif (ret)\n\t\twarn(\"%s: failed: %d\", __func__, ret);\n\treturn ret;\n}\n\nstatic const struct dvb_tuner_ops fc0013_tuner_ops = {\n\t.info = {\n\t\t.name\t\t  = \"Fitipower FC0013\",\n\n\t\t.frequency_min_hz =   37 * MHz,\t \n\t\t.frequency_max_hz = 1680 * MHz,\t \n\t},\n\n\t.release\t= fc0013_release,\n\n\t.init\t\t= fc0013_init,\n\t.sleep\t\t= fc0013_sleep,\n\n\t.set_params\t= fc0013_set_params,\n\n\t.get_frequency\t= fc0013_get_frequency,\n\t.get_if_frequency = fc0013_get_if_frequency,\n\t.get_bandwidth\t= fc0013_get_bandwidth,\n\n\t.get_rf_strength = fc0013_get_rf_strength,\n};\n\nstruct dvb_frontend *fc0013_attach(struct dvb_frontend *fe,\n\tstruct i2c_adapter *i2c, u8 i2c_address, int dual_master,\n\tenum fc001x_xtal_freq xtal_freq)\n{\n\tstruct fc0013_priv *priv = NULL;\n\n\tpriv = kzalloc(sizeof(struct fc0013_priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn NULL;\n\n\tpriv->i2c = i2c;\n\tpriv->dual_master = dual_master;\n\tpriv->addr = i2c_address;\n\tpriv->xtal_freq = xtal_freq;\n\n\tinfo(\"Fitipower FC0013 successfully attached.\");\n\n\tfe->tuner_priv = priv;\n\n\tmemcpy(&fe->ops.tuner_ops, &fc0013_tuner_ops,\n\t\tsizeof(struct dvb_tuner_ops));\n\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(fc0013_attach);\n\nMODULE_DESCRIPTION(\"Fitipower FC0013 silicon tuner driver\");\nMODULE_AUTHOR(\"Hans-Frieder Vogt <hfvogt@gmx.net>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}