{
  "module_name": "tea5767.c",
  "hash_id": "ae74feead60fc6226d992df1370285b3025dbe17b0d205817960ed51104d5e28",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/tea5767.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/videodev2.h>\n#include \"tuner-i2c.h\"\n#include \"tea5767.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable verbose debug messages\");\n\n \n\nstruct tea5767_priv {\n\tstruct tuner_i2c_props\ti2c_props;\n\tu32\t\t\tfrequency;\n\tstruct tea5767_ctrl\tctrl;\n};\n\n \n\n \n\n \n#define TEA5767_MUTE\t\t0x80\t \n#define TEA5767_SEARCH\t\t0x40\t \n \n\n \n \n\n \n\n \n#define TEA5767_SEARCH_UP\t0x80\n\n \n#define TEA5767_SRCH_HIGH_LVL\t0x60\n\n \n#define TEA5767_SRCH_MID_LVL\t0x40\n\n \n#define TEA5767_SRCH_LOW_LVL\t0x20\n\n \n#define TEA5767_HIGH_LO_INJECT\t0x10\n\n \n#define TEA5767_MONO\t\t0x08\n\n \n#define TEA5767_MUTE_RIGHT\t0x04\n\n \n#define TEA5767_MUTE_LEFT\t0x02\n\n#define TEA5767_PORT1_HIGH\t0x01\n\n \n#define TEA5767_PORT2_HIGH\t0x80\n \n#define TEA5767_STDBY\t\t0x40\n\n \n#define TEA5767_JAPAN_BAND\t0x20\n\n \n#define TEA5767_XTAL_32768\t0x10\n\n \n#define TEA5767_SOFT_MUTE\t0x08\n\n \n#define TEA5767_HIGH_CUT_CTRL\t0x04\n\n \n#define TEA5767_ST_NOISE_CTL\t0x02\n\n \n#define TEA5767_SRCH_IND\t0x01\n\n \n\n \n#define TEA5767_PLLREF_ENABLE\t0x80\n\n \n#define TEA5767_DEEMPH_75\t0X40\n\n \n\n \n#define TEA5767_READY_FLAG_MASK\t0x80\n#define TEA5767_BAND_LIMIT_MASK\t0X40\n \n\n \n \n\n \n#define TEA5767_STEREO_MASK\t0x80\n#define TEA5767_IF_CNTR_MASK\t0x7f\n\n \n#define TEA5767_ADC_LEVEL_MASK\t0xf0\n\n \n#define TEA5767_CHIP_ID_MASK\t0x0f\n\n \n \n#define TEA5767_RESERVED_MASK\t0xff\n\n \n\nstatic void tea5767_status_dump(struct tea5767_priv *priv,\n\t\t\t\tunsigned char *buffer)\n{\n\tunsigned int div, frq;\n\n\tif (TEA5767_READY_FLAG_MASK & buffer[0])\n\t\ttuner_info(\"Ready Flag ON\\n\");\n\telse\n\t\ttuner_info(\"Ready Flag OFF\\n\");\n\n\tif (TEA5767_BAND_LIMIT_MASK & buffer[0])\n\t\ttuner_info(\"Tuner at band limit\\n\");\n\telse\n\t\ttuner_info(\"Tuner not at band limit\\n\");\n\n\tdiv = ((buffer[0] & 0x3f) << 8) | buffer[1];\n\n\tswitch (priv->ctrl.xtal_freq) {\n\tcase TEA5767_HIGH_LO_13MHz:\n\t\tfrq = (div * 50000 - 700000 - 225000) / 4;\t \n\t\tbreak;\n\tcase TEA5767_LOW_LO_13MHz:\n\t\tfrq = (div * 50000 + 700000 + 225000) / 4;\t \n\t\tbreak;\n\tcase TEA5767_LOW_LO_32768:\n\t\tfrq = (div * 32768 + 700000 + 225000) / 4;\t \n\t\tbreak;\n\tcase TEA5767_HIGH_LO_32768:\n\tdefault:\n\t\tfrq = (div * 32768 - 700000 - 225000) / 4;\t \n\t\tbreak;\n\t}\n\tbuffer[0] = (div >> 8) & 0x3f;\n\tbuffer[1] = div & 0xff;\n\n\ttuner_info(\"Frequency %d.%03d KHz (divider = 0x%04x)\\n\",\n\t\t   frq / 1000, frq % 1000, div);\n\n\tif (TEA5767_STEREO_MASK & buffer[2])\n\t\ttuner_info(\"Stereo\\n\");\n\telse\n\t\ttuner_info(\"Mono\\n\");\n\n\ttuner_info(\"IF Counter = %d\\n\", buffer[2] & TEA5767_IF_CNTR_MASK);\n\n\ttuner_info(\"ADC Level = %d\\n\",\n\t\t   (buffer[3] & TEA5767_ADC_LEVEL_MASK) >> 4);\n\n\ttuner_info(\"Chip ID = %d\\n\", (buffer[3] & TEA5767_CHIP_ID_MASK));\n\n\ttuner_info(\"Reserved = 0x%02x\\n\",\n\t\t   (buffer[4] & TEA5767_RESERVED_MASK));\n}\n\n \nstatic int set_radio_freq(struct dvb_frontend *fe,\n\t\t\t  struct analog_parameters *params)\n{\n\tstruct tea5767_priv *priv = fe->tuner_priv;\n\tunsigned int frq = params->frequency;\n\tunsigned char buffer[5];\n\tunsigned div;\n\tint rc;\n\n\ttuner_dbg(\"radio freq = %d.%03d MHz\\n\", frq/16000,(frq/16)%1000);\n\n\tbuffer[2] = 0;\n\n\tif (priv->ctrl.port1)\n\t\tbuffer[2] |= TEA5767_PORT1_HIGH;\n\n\tif (params->audmode == V4L2_TUNER_MODE_MONO) {\n\t\ttuner_dbg(\"TEA5767 set to mono\\n\");\n\t\tbuffer[2] |= TEA5767_MONO;\n\t} else {\n\t\ttuner_dbg(\"TEA5767 set to stereo\\n\");\n\t}\n\n\n\tbuffer[3] = 0;\n\n\tif (priv->ctrl.port2)\n\t\tbuffer[3] |= TEA5767_PORT2_HIGH;\n\n\tif (priv->ctrl.high_cut)\n\t\tbuffer[3] |= TEA5767_HIGH_CUT_CTRL;\n\n\tif (priv->ctrl.st_noise)\n\t\tbuffer[3] |= TEA5767_ST_NOISE_CTL;\n\n\tif (priv->ctrl.soft_mute)\n\t\tbuffer[3] |= TEA5767_SOFT_MUTE;\n\n\tif (priv->ctrl.japan_band)\n\t\tbuffer[3] |= TEA5767_JAPAN_BAND;\n\n\tbuffer[4] = 0;\n\n\tif (priv->ctrl.deemph_75)\n\t\tbuffer[4] |= TEA5767_DEEMPH_75;\n\n\tif (priv->ctrl.pllref)\n\t\tbuffer[4] |= TEA5767_PLLREF_ENABLE;\n\n\n\t \n\t \n\n\tswitch (priv->ctrl.xtal_freq) {\n\tcase TEA5767_HIGH_LO_13MHz:\n\t\ttuner_dbg(\"radio HIGH LO inject xtal @ 13 MHz\\n\");\n\t\tbuffer[2] |= TEA5767_HIGH_LO_INJECT;\n\t\tdiv = (frq * (4000 / 16) + 700000 + 225000 + 25000) / 50000;\n\t\tbreak;\n\tcase TEA5767_LOW_LO_13MHz:\n\t\ttuner_dbg(\"radio LOW LO inject xtal @ 13 MHz\\n\");\n\n\t\tdiv = (frq * (4000 / 16) - 700000 - 225000 + 25000) / 50000;\n\t\tbreak;\n\tcase TEA5767_LOW_LO_32768:\n\t\ttuner_dbg(\"radio LOW LO inject xtal @ 32,768 MHz\\n\");\n\t\tbuffer[3] |= TEA5767_XTAL_32768;\n\t\t \n\t\tdiv = ((frq * (4000 / 16) - 700000 - 225000) + 16384) >> 15;\n\t\tbreak;\n\tcase TEA5767_HIGH_LO_32768:\n\tdefault:\n\t\ttuner_dbg(\"radio HIGH LO inject xtal @ 32,768 MHz\\n\");\n\n\t\tbuffer[2] |= TEA5767_HIGH_LO_INJECT;\n\t\tbuffer[3] |= TEA5767_XTAL_32768;\n\t\tdiv = ((frq * (4000 / 16) + 700000 + 225000) + 16384) >> 15;\n\t\tbreak;\n\t}\n\tbuffer[0] = (div >> 8) & 0x3f;\n\tbuffer[1] = div & 0xff;\n\n\tif (5 != (rc = tuner_i2c_xfer_send(&priv->i2c_props, buffer, 5)))\n\t\ttuner_warn(\"i2c i/o error: rc == %d (should be 5)\\n\", rc);\n\n\tif (debug) {\n\t\tif (5 != (rc = tuner_i2c_xfer_recv(&priv->i2c_props, buffer, 5)))\n\t\t\ttuner_warn(\"i2c i/o error: rc == %d (should be 5)\\n\", rc);\n\t\telse\n\t\t\ttea5767_status_dump(priv, buffer);\n\t}\n\n\tpriv->frequency = frq * 125 / 2;\n\n\treturn 0;\n}\n\nstatic int tea5767_read_status(struct dvb_frontend *fe, char *buffer)\n{\n\tstruct tea5767_priv *priv = fe->tuner_priv;\n\tint rc;\n\n\tmemset(buffer, 0, 5);\n\tif (5 != (rc = tuner_i2c_xfer_recv(&priv->i2c_props, buffer, 5))) {\n\t\ttuner_warn(\"i2c i/o error: rc == %d (should be 5)\\n\", rc);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int tea5767_signal(struct dvb_frontend *fe, const char *buffer)\n{\n\tstruct tea5767_priv *priv = fe->tuner_priv;\n\n\tint signal = ((buffer[3] & TEA5767_ADC_LEVEL_MASK) << 8);\n\n\ttuner_dbg(\"Signal strength: %d\\n\", signal);\n\n\treturn signal;\n}\n\nstatic inline int tea5767_stereo(struct dvb_frontend *fe, const char *buffer)\n{\n\tstruct tea5767_priv *priv = fe->tuner_priv;\n\n\tint stereo = buffer[2] & TEA5767_STEREO_MASK;\n\n\ttuner_dbg(\"Radio ST GET = %02x\\n\", stereo);\n\n\treturn (stereo ? V4L2_TUNER_SUB_STEREO : 0);\n}\n\nstatic int tea5767_get_status(struct dvb_frontend *fe, u32 *status)\n{\n\tunsigned char buffer[5];\n\n\t*status = 0;\n\n\tif (0 == tea5767_read_status(fe, buffer)) {\n\t\tif (tea5767_signal(fe, buffer))\n\t\t\t*status = TUNER_STATUS_LOCKED;\n\t\tif (tea5767_stereo(fe, buffer))\n\t\t\t*status |= TUNER_STATUS_STEREO;\n\t}\n\n\treturn 0;\n}\n\nstatic int tea5767_get_rf_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tunsigned char buffer[5];\n\n\t*strength = 0;\n\n\tif (0 == tea5767_read_status(fe, buffer))\n\t\t*strength = tea5767_signal(fe, buffer);\n\n\treturn 0;\n}\n\nstatic int tea5767_standby(struct dvb_frontend *fe)\n{\n\tunsigned char buffer[5];\n\tstruct tea5767_priv *priv = fe->tuner_priv;\n\tunsigned div, rc;\n\n\tdiv = (87500 * 4 + 700 + 225 + 25) / 50;  \n\tbuffer[0] = (div >> 8) & 0x3f;\n\tbuffer[1] = div & 0xff;\n\tbuffer[2] = TEA5767_PORT1_HIGH;\n\tbuffer[3] = TEA5767_PORT2_HIGH | TEA5767_HIGH_CUT_CTRL |\n\t\t    TEA5767_ST_NOISE_CTL | TEA5767_JAPAN_BAND | TEA5767_STDBY;\n\tbuffer[4] = 0;\n\n\tif (5 != (rc = tuner_i2c_xfer_send(&priv->i2c_props, buffer, 5)))\n\t\ttuner_warn(\"i2c i/o error: rc == %d (should be 5)\\n\", rc);\n\n\treturn 0;\n}\n\nint tea5767_autodetection(struct i2c_adapter* i2c_adap, u8 i2c_addr)\n{\n\tstruct tuner_i2c_props i2c = { .adap = i2c_adap, .addr = i2c_addr };\n\tunsigned char buffer[7] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n\tint rc;\n\n\tif ((rc = tuner_i2c_xfer_recv(&i2c, buffer, 7))< 5) {\n\t\tpr_warn(\"It is not a TEA5767. Received %i bytes.\\n\", rc);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (buffer[0] == buffer[1] && buffer[0] == buffer[2] &&\n\t    buffer[0] == buffer[3] && buffer[0] == buffer[4]) {\n\t\tpr_warn(\"All bytes are equal. It is not a TEA5767\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (((buffer[3] & 0x0f) != 0x00) || (buffer[4] != 0x00)) {\n\t\tpr_warn(\"Chip ID is not zero. It is not a TEA5767\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\n\treturn 0;\n}\n\nstatic void tea5767_release(struct dvb_frontend *fe)\n{\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic int tea5767_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct tea5767_priv *priv = fe->tuner_priv;\n\t*frequency = priv->frequency;\n\n\treturn 0;\n}\n\nstatic int tea5767_set_config (struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct tea5767_priv *priv = fe->tuner_priv;\n\n\tmemcpy(&priv->ctrl, priv_cfg, sizeof(priv->ctrl));\n\n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops tea5767_tuner_ops = {\n\t.info = {\n\t\t.name           = \"tea5767\", \n\t},\n\n\t.set_analog_params = set_radio_freq,\n\t.set_config\t   = tea5767_set_config,\n\t.sleep             = tea5767_standby,\n\t.release           = tea5767_release,\n\t.get_frequency     = tea5767_get_frequency,\n\t.get_status        = tea5767_get_status,\n\t.get_rf_strength   = tea5767_get_rf_strength,\n};\n\nstruct dvb_frontend *tea5767_attach(struct dvb_frontend *fe,\n\t\t\t\t    struct i2c_adapter* i2c_adap,\n\t\t\t\t    u8 i2c_addr)\n{\n\tstruct tea5767_priv *priv = NULL;\n\n\tpriv = kzalloc(sizeof(struct tea5767_priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn NULL;\n\tfe->tuner_priv = priv;\n\n\tpriv->i2c_props.addr  = i2c_addr;\n\tpriv->i2c_props.adap  = i2c_adap;\n\tpriv->i2c_props.name  = \"tea5767\";\n\n\tpriv->ctrl.xtal_freq  = TEA5767_HIGH_LO_32768;\n\tpriv->ctrl.port1      = 1;\n\tpriv->ctrl.port2      = 1;\n\tpriv->ctrl.high_cut   = 1;\n\tpriv->ctrl.st_noise   = 1;\n\tpriv->ctrl.japan_band = 1;\n\n\tmemcpy(&fe->ops.tuner_ops, &tea5767_tuner_ops,\n\t       sizeof(struct dvb_tuner_ops));\n\n\ttuner_info(\"type set to %s\\n\", \"Philips TEA5767HN FM Radio\");\n\n\treturn fe;\n}\n\nEXPORT_SYMBOL_GPL(tea5767_attach);\nEXPORT_SYMBOL_GPL(tea5767_autodetection);\n\nMODULE_DESCRIPTION(\"Philips TEA5767 FM tuner driver\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab <mchehab@kernel.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}