{
  "module_name": "it913x.c",
  "hash_id": "10b303d2c11fd109f170928b48eacba5f1253386eee24db2f560a00f151e6dd8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/it913x.c",
  "human_readable_source": "\n \n\n#include \"it913x.h\"\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\nstruct it913x_dev {\n\tstruct platform_device *pdev;\n\tstruct regmap *regmap;\n\tstruct dvb_frontend *fe;\n\tu8 chip_ver:2;\n\tu8 role:2;\n\tu16 xtal;\n\tu8 fdiv;\n\tu8 clk_mode;\n\tu32 fn_min;\n\tbool active;\n};\n\nstatic int it913x_init(struct dvb_frontend *fe)\n{\n\tstruct it913x_dev *dev = fe->tuner_priv;\n\tstruct platform_device *pdev = dev->pdev;\n\tint ret;\n\tunsigned int utmp;\n\tu8 iqik_m_cal, nv_val, buf[2];\n\tstatic const u8 nv[] = {48, 32, 24, 16, 12, 8, 6, 4, 2};\n\tunsigned long timeout;\n\n\tdev_dbg(&pdev->dev, \"role %u\\n\", dev->role);\n\n\tret = regmap_write(dev->regmap, 0x80ec4c, 0x68);\n\tif (ret)\n\t\tgoto err;\n\n\tusleep_range(10000, 100000);\n\n\tret = regmap_read(dev->regmap, 0x80ec86, &utmp);\n\tif (ret)\n\t\tgoto err;\n\n\tswitch (utmp) {\n\tcase 0:\n\t\t \n\t\tdev->clk_mode = utmp;\n\t\tdev->xtal = 2000;\n\t\tdev->fdiv = 3;\n\t\tiqik_m_cal = 16;\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tdev->clk_mode = utmp;\n\t\tdev->xtal = 640;\n\t\tdev->fdiv = 1;\n\t\tiqik_m_cal = 6;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"unknown clock identifier %d\\n\", utmp);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = regmap_read(dev->regmap, 0x80ed03,  &utmp);\n\tif (ret)\n\t\tgoto err;\n\n\telse if (utmp < ARRAY_SIZE(nv))\n\t\tnv_val = nv[utmp];\n\telse\n\t\tnv_val = 2;\n\n\t#define TIMEOUT 50\n\ttimeout = jiffies + msecs_to_jiffies(TIMEOUT);\n\twhile (!time_after(jiffies, timeout)) {\n\t\tret = regmap_bulk_read(dev->regmap, 0x80ed23, buf, 2);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tutmp = (buf[1] << 8) | (buf[0] << 0);\n\t\tif (utmp)\n\t\t\tbreak;\n\t}\n\n\tdev_dbg(&pdev->dev, \"r_fbc_m_bdry took %u ms, val %u\\n\",\n\t\t\tjiffies_to_msecs(jiffies) -\n\t\t\t(jiffies_to_msecs(timeout) - TIMEOUT), utmp);\n\n\tdev->fn_min = dev->xtal * utmp;\n\tdev->fn_min /= (dev->fdiv * nv_val);\n\tdev->fn_min *= 1000;\n\tdev_dbg(&pdev->dev, \"fn_min %u\\n\", dev->fn_min);\n\n\t \n\tif (dev->chip_ver == 1) {\n\t\t#define TIMEOUT 50\n\t\ttimeout = jiffies + msecs_to_jiffies(TIMEOUT);\n\t\twhile (!time_after(jiffies, timeout)) {\n\t\t\tret = regmap_read(dev->regmap, 0x80ec82, &utmp);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tif (utmp)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(&pdev->dev, \"p_tsm_init_mode took %u ms, val %u\\n\",\n\t\t\t\tjiffies_to_msecs(jiffies) -\n\t\t\t\t(jiffies_to_msecs(timeout) - TIMEOUT), utmp);\n\t} else {\n\t\tmsleep(50);\n\t}\n\n\tret = regmap_write(dev->regmap, 0x80ed81, iqik_m_cal);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x80ec57, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x80ec58, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x80ec40, 0x01);\n\tif (ret)\n\t\tgoto err;\n\n\tdev->active = true;\n\n\treturn 0;\nerr:\n\tdev_dbg(&pdev->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int it913x_sleep(struct dvb_frontend *fe)\n{\n\tstruct it913x_dev *dev = fe->tuner_priv;\n\tstruct platform_device *pdev = dev->pdev;\n\tint ret, len;\n\n\tdev_dbg(&pdev->dev, \"role %u\\n\", dev->role);\n\n\tdev->active = false;\n\n\tret  = regmap_bulk_write(dev->regmap, 0x80ec40, \"\\x00\", 1);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tif (dev->role == IT913X_ROLE_DUAL_MASTER)\n\t\tlen = 4;\n\telse\n\t\tlen = 15;\n\n\tdev_dbg(&pdev->dev, \"role %u, len %d\\n\", dev->role, len);\n\n\tret = regmap_bulk_write(dev->regmap, 0x80ec02,\n\t\t\t\"\\x3f\\x1f\\x3f\\x3e\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\tlen);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_bulk_write(dev->regmap, 0x80ec12, \"\\x00\\x00\\x00\\x00\", 4);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_bulk_write(dev->regmap, 0x80ec17,\n\t\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 9);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_bulk_write(dev->regmap, 0x80ec22,\n\t\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 10);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_bulk_write(dev->regmap, 0x80ec20, \"\\x00\", 1);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_bulk_write(dev->regmap, 0x80ec3f, \"\\x01\", 1);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&pdev->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int it913x_set_params(struct dvb_frontend *fe)\n{\n\tstruct it913x_dev *dev = fe->tuner_priv;\n\tstruct platform_device *pdev = dev->pdev;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret;\n\tunsigned int utmp;\n\tu32 pre_lo_freq, t_cal_freq;\n\tu16 iqik_m_cal, n_div;\n\tu8 u8tmp, n, l_band, lna_band;\n\n\tdev_dbg(&pdev->dev, \"role=%u, frequency %u, bandwidth_hz %u\\n\",\n\t\t\tdev->role, c->frequency, c->bandwidth_hz);\n\n\tif (!dev->active) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (c->frequency <=         74000000) {\n\t\tn_div = 48;\n\t\tn = 0;\n\t} else if (c->frequency <= 111000000) {\n\t\tn_div = 32;\n\t\tn = 1;\n\t} else if (c->frequency <= 148000000) {\n\t\tn_div = 24;\n\t\tn = 2;\n\t} else if (c->frequency <= 222000000) {\n\t\tn_div = 16;\n\t\tn = 3;\n\t} else if (c->frequency <= 296000000) {\n\t\tn_div = 12;\n\t\tn = 4;\n\t} else if (c->frequency <= 445000000) {\n\t\tn_div = 8;\n\t\tn = 5;\n\t} else if (c->frequency <= dev->fn_min) {\n\t\tn_div = 6;\n\t\tn = 6;\n\t} else if (c->frequency <= 950000000) {\n\t\tn_div = 4;\n\t\tn = 7;\n\t} else {\n\t\tn_div = 2;\n\t\tn = 0;\n\t}\n\n\tret = regmap_read(dev->regmap, 0x80ed81, &utmp);\n\tif (ret)\n\t\tgoto err;\n\n\tiqik_m_cal = utmp * n_div;\n\n\tif (utmp < 0x20) {\n\t\tif (dev->clk_mode == 0)\n\t\t\tiqik_m_cal = (iqik_m_cal * 9) >> 5;\n\t\telse\n\t\t\tiqik_m_cal >>= 1;\n\t} else {\n\t\tiqik_m_cal = 0x40 - iqik_m_cal;\n\t\tif (dev->clk_mode == 0)\n\t\t\tiqik_m_cal = ~((iqik_m_cal * 9) >> 5);\n\t\telse\n\t\t\tiqik_m_cal = ~(iqik_m_cal >> 1);\n\t}\n\n\tt_cal_freq = (c->frequency / 1000) * n_div * dev->fdiv;\n\tpre_lo_freq = t_cal_freq / dev->xtal;\n\tutmp = pre_lo_freq * dev->xtal;\n\n\tif ((t_cal_freq - utmp) >= (dev->xtal >> 1))\n\t\tpre_lo_freq++;\n\n\tpre_lo_freq += (u32) n << 13;\n\t \n\tt_cal_freq = pre_lo_freq + (u32)iqik_m_cal;\n\tdev_dbg(&pdev->dev, \"t_cal_freq %u, pre_lo_freq %u\\n\",\n\t\t\tt_cal_freq, pre_lo_freq);\n\n\tif (c->frequency <=         440000000) {\n\t\tl_band = 0;\n\t\tlna_band = 0;\n\t} else if (c->frequency <=  484000000) {\n\t\tl_band = 1;\n\t\tlna_band = 1;\n\t} else if (c->frequency <=  533000000) {\n\t\tl_band = 1;\n\t\tlna_band = 2;\n\t} else if (c->frequency <=  587000000) {\n\t\tl_band = 1;\n\t\tlna_band = 3;\n\t} else if (c->frequency <=  645000000) {\n\t\tl_band = 1;\n\t\tlna_band = 4;\n\t} else if (c->frequency <=  710000000) {\n\t\tl_band = 1;\n\t\tlna_band = 5;\n\t} else if (c->frequency <=  782000000) {\n\t\tl_band = 1;\n\t\tlna_band = 6;\n\t} else if (c->frequency <=  860000000) {\n\t\tl_band = 1;\n\t\tlna_band = 7;\n\t} else if (c->frequency <= 1492000000) {\n\t\tl_band = 1;\n\t\tlna_band = 0;\n\t} else if (c->frequency <= 1685000000) {\n\t\tl_band = 1;\n\t\tlna_band = 1;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tret = regmap_write(dev->regmap, 0x80ee06, lna_band);\n\tif (ret)\n\t\tgoto err;\n\n\tif (c->bandwidth_hz <=      5000000)\n\t\tu8tmp = 0;\n\telse if (c->bandwidth_hz <= 6000000)\n\t\tu8tmp = 2;\n\telse if (c->bandwidth_hz <= 7000000)\n\t\tu8tmp = 4;\n\telse\n\t\tu8tmp = 6;        \n\n\tret = regmap_write(dev->regmap, 0x80ec56, u8tmp);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_write(dev->regmap, 0x80ec4c, 0xa0 | (l_band << 3));\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x80ec4d, (t_cal_freq >> 0) & 0xff);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x80ec4e, (t_cal_freq >> 8) & 0xff);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x80011e, (pre_lo_freq >> 0) & 0xff);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x80011f, (pre_lo_freq >> 8) & 0xff);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&pdev->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct dvb_tuner_ops it913x_tuner_ops = {\n\t.info = {\n\t\t.name             = \"ITE IT913X\",\n\t\t.frequency_min_hz = 174 * MHz,\n\t\t.frequency_max_hz = 862 * MHz,\n\t},\n\n\t.init = it913x_init,\n\t.sleep = it913x_sleep,\n\t.set_params = it913x_set_params,\n};\n\nstatic int it913x_probe(struct platform_device *pdev)\n{\n\tstruct it913x_platform_data *pdata = pdev->dev.platform_data;\n\tstruct dvb_frontend *fe = pdata->fe;\n\tstruct it913x_dev *dev;\n\tconst struct platform_device_id *id = platform_get_device_id(pdev);\n\tint ret;\n\tchar *chip_ver_str;\n\n\tdev = kzalloc(sizeof(struct it913x_dev), GFP_KERNEL);\n\tif (dev == NULL) {\n\t\tret = -ENOMEM;\n\t\tdev_err(&pdev->dev, \"kzalloc() failed\\n\");\n\t\tgoto err;\n\t}\n\n\tdev->pdev = pdev;\n\tdev->regmap = pdata->regmap;\n\tdev->fe = pdata->fe;\n\tdev->chip_ver = id->driver_data;\n\tdev->role = pdata->role;\n\n\tfe->tuner_priv = dev;\n\tmemcpy(&fe->ops.tuner_ops, &it913x_tuner_ops,\n\t\t\tsizeof(struct dvb_tuner_ops));\n\tplatform_set_drvdata(pdev, dev);\n\n\tif (dev->chip_ver == 1)\n\t\tchip_ver_str = \"AX\";\n\telse if (dev->chip_ver == 2)\n\t\tchip_ver_str = \"BX\";\n\telse\n\t\tchip_ver_str = \"??\";\n\n\tdev_info(&pdev->dev, \"ITE IT913X %s successfully attached\\n\",\n\t\t chip_ver_str);\n\tdev_dbg(&pdev->dev, \"chip_ver %u, role %u\\n\", dev->chip_ver, dev->role);\n\treturn 0;\nerr:\n\tdev_dbg(&pdev->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic void it913x_remove(struct platform_device *pdev)\n{\n\tstruct it913x_dev *dev = platform_get_drvdata(pdev);\n\tstruct dvb_frontend *fe = dev->fe;\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\tmemset(&fe->ops.tuner_ops, 0, sizeof(struct dvb_tuner_ops));\n\tfe->tuner_priv = NULL;\n\tkfree(dev);\n}\n\nstatic const struct platform_device_id it913x_id_table[] = {\n\t{\"it9133ax-tuner\", 1},\n\t{\"it9133bx-tuner\", 2},\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, it913x_id_table);\n\nstatic struct platform_driver it913x_driver = {\n\t.driver = {\n\t\t.name\t= \"it913x\",\n\t\t.suppress_bind_attrs\t= true,\n\t},\n\t.probe\t\t= it913x_probe,\n\t.remove_new\t= it913x_remove,\n\t.id_table\t= it913x_id_table,\n};\n\nmodule_platform_driver(it913x_driver);\n\nMODULE_DESCRIPTION(\"ITE IT913X silicon tuner driver\");\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}