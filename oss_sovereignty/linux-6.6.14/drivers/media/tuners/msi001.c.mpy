{
  "module_name": "msi001.c",
  "hash_id": "936f665db23b072342ad54c7eb91c9631247574d70cb3b017e7d8d3eb65274be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/msi001.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/gcd.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n\nstatic const struct v4l2_frequency_band bands[] = {\n\t{\n\t\t.type = V4L2_TUNER_RF,\n\t\t.index = 0,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   =   49000000,\n\t\t.rangehigh  =  263000000,\n\t}, {\n\t\t.type = V4L2_TUNER_RF,\n\t\t.index = 1,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   =  390000000,\n\t\t.rangehigh  =  960000000,\n\t},\n};\n\nstruct msi001_dev {\n\tstruct spi_device *spi;\n\tstruct v4l2_subdev sd;\n\n\t \n\tstruct v4l2_ctrl_handler hdl;\n\tstruct v4l2_ctrl *bandwidth_auto;\n\tstruct v4l2_ctrl *bandwidth;\n\tstruct v4l2_ctrl *lna_gain;\n\tstruct v4l2_ctrl *mixer_gain;\n\tstruct v4l2_ctrl *if_gain;\n\n\tunsigned int f_tuner;\n};\n\nstatic inline struct msi001_dev *sd_to_msi001_dev(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct msi001_dev, sd);\n}\n\nstatic int msi001_wreg(struct msi001_dev *dev, u32 data)\n{\n\t \n\treturn spi_write(dev->spi, &data, 3);\n};\n\nstatic int msi001_set_gain(struct msi001_dev *dev, int lna_gain, int mixer_gain,\n\t\t\t   int if_gain)\n{\n\tstruct spi_device *spi = dev->spi;\n\tint ret;\n\tu32 reg;\n\n\tdev_dbg(&spi->dev, \"lna=%d mixer=%d if=%d\\n\",\n\t\tlna_gain, mixer_gain, if_gain);\n\n\treg = 1 << 0;\n\treg |= (59 - if_gain) << 4;\n\treg |= 0 << 10;\n\treg |= (1 - mixer_gain) << 12;\n\treg |= (1 - lna_gain) << 13;\n\treg |= 4 << 14;\n\treg |= 0 << 17;\n\tret = msi001_wreg(dev, reg);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&spi->dev, \"failed %d\\n\", ret);\n\treturn ret;\n};\n\nstatic int msi001_set_tuner(struct msi001_dev *dev)\n{\n\tstruct spi_device *spi = dev->spi;\n\tint ret, i;\n\tunsigned int uitmp, div_n, k, k_thresh, k_frac, div_lo, f_if1;\n\tu32 reg;\n\tu64 f_vco;\n\tu8 mode, filter_mode;\n\n\tstatic const struct {\n\t\tu32 rf;\n\t\tu8 mode;\n\t\tu8 div_lo;\n\t} band_lut[] = {\n\t\t{ 50000000, 0xe1, 16},  \n\t\t{108000000, 0x42, 32},  \n\t\t{330000000, 0x44, 16},  \n\t\t{960000000, 0x48,  4},  \n\t\t{      ~0U, 0x50,  2},  \n\t};\n\tstatic const struct {\n\t\tu32 freq;\n\t\tu8 filter_mode;\n\t} if_freq_lut[] = {\n\t\t{      0, 0x03},  \n\t\t{ 450000, 0x02},  \n\t\t{1620000, 0x01},  \n\t\t{2048000, 0x00},  \n\t};\n\tstatic const struct {\n\t\tu32 freq;\n\t\tu8 val;\n\t} bandwidth_lut[] = {\n\t\t{ 200000, 0x00},  \n\t\t{ 300000, 0x01},  \n\t\t{ 600000, 0x02},  \n\t\t{1536000, 0x03},  \n\t\t{5000000, 0x04},  \n\t\t{6000000, 0x05},  \n\t\t{7000000, 0x06},  \n\t\t{8000000, 0x07},  \n\t};\n\n\tunsigned int f_rf = dev->f_tuner;\n\n\t \n\tunsigned int bandwidth;\n\n\t \n\tunsigned int f_if = 0;\n\t#define F_REF 24000000\n\t#define DIV_PRE_N 4\n\t#define\tF_VCO_STEP div_lo\n\n\tdev_dbg(&spi->dev, \"f_rf=%d f_if=%d\\n\", f_rf, f_if);\n\n\tfor (i = 0; i < ARRAY_SIZE(band_lut); i++) {\n\t\tif (f_rf <= band_lut[i].rf) {\n\t\t\tmode = band_lut[i].mode;\n\t\t\tdiv_lo = band_lut[i].div_lo;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == ARRAY_SIZE(band_lut)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tif ((mode >> 0) & 0x1)\n\t\tf_if1 =  5 * F_REF;\n\telse\n\t\tf_if1 =  0;\n\n\tfor (i = 0; i < ARRAY_SIZE(if_freq_lut); i++) {\n\t\tif (f_if == if_freq_lut[i].freq) {\n\t\t\tfilter_mode = if_freq_lut[i].filter_mode;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == ARRAY_SIZE(if_freq_lut)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tbandwidth = dev->bandwidth->val;\n\tbandwidth = clamp(bandwidth, 200000U, 8000000U);\n\n\tfor (i = 0; i < ARRAY_SIZE(bandwidth_lut); i++) {\n\t\tif (bandwidth <= bandwidth_lut[i].freq) {\n\t\t\tbandwidth = bandwidth_lut[i].val;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == ARRAY_SIZE(bandwidth_lut)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdev->bandwidth->val = bandwidth_lut[i].freq;\n\n\tdev_dbg(&spi->dev, \"bandwidth selected=%d\\n\", bandwidth_lut[i].freq);\n\n\t \n\n\t \n\tf_vco = (u64) (f_rf + f_if + f_if1) * div_lo;\n\tdiv_n = div_u64_rem(f_vco, DIV_PRE_N * F_REF, &k);\n\tk_thresh = (DIV_PRE_N * F_REF) / F_VCO_STEP;\n\tk_frac = div_u64((u64) k * k_thresh, (DIV_PRE_N * F_REF));\n\n\t \n\tuitmp = gcd(k_thresh, k_frac);\n\tk_thresh /= uitmp;\n\tk_frac /= uitmp;\n\n\t \n\tuitmp = DIV_ROUND_UP(k_thresh, 4095);\n\tk_thresh = DIV_ROUND_CLOSEST(k_thresh, uitmp);\n\tk_frac = DIV_ROUND_CLOSEST(k_frac, uitmp);\n\n\t \n\tuitmp = (unsigned int) F_REF * DIV_PRE_N * div_n;\n\tuitmp += (unsigned int) F_REF * DIV_PRE_N * k_frac / k_thresh;\n\tuitmp /= div_lo;\n\n\tdev_dbg(&spi->dev,\n\t\t\"f_rf=%u:%u f_vco=%llu div_n=%u k_thresh=%u k_frac=%u div_lo=%u\\n\",\n\t\tf_rf, uitmp, f_vco, div_n, k_thresh, k_frac, div_lo);\n\n\tret = msi001_wreg(dev, 0x00000e);\n\tif (ret)\n\t\tgoto err;\n\n\tret = msi001_wreg(dev, 0x000003);\n\tif (ret)\n\t\tgoto err;\n\n\treg = 0 << 0;\n\treg |= mode << 4;\n\treg |= filter_mode << 12;\n\treg |= bandwidth << 14;\n\treg |= 0x02 << 17;\n\treg |= 0x00 << 20;\n\tret = msi001_wreg(dev, reg);\n\tif (ret)\n\t\tgoto err;\n\n\treg = 5 << 0;\n\treg |= k_thresh << 4;\n\treg |= 1 << 19;\n\treg |= 1 << 21;\n\tret = msi001_wreg(dev, reg);\n\tif (ret)\n\t\tgoto err;\n\n\treg = 2 << 0;\n\treg |= k_frac << 4;\n\treg |= div_n << 16;\n\tret = msi001_wreg(dev, reg);\n\tif (ret)\n\t\tgoto err;\n\n\tret = msi001_set_gain(dev, dev->lna_gain->cur.val,\n\t\t\t      dev->mixer_gain->cur.val, dev->if_gain->cur.val);\n\tif (ret)\n\t\tgoto err;\n\n\treg = 6 << 0;\n\treg |= 63 << 4;\n\treg |= 4095 << 10;\n\tret = msi001_wreg(dev, reg);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&spi->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int msi001_standby(struct v4l2_subdev *sd)\n{\n\tstruct msi001_dev *dev = sd_to_msi001_dev(sd);\n\n\treturn msi001_wreg(dev, 0x000000);\n}\n\nstatic int msi001_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *v)\n{\n\tstruct msi001_dev *dev = sd_to_msi001_dev(sd);\n\tstruct spi_device *spi = dev->spi;\n\n\tdev_dbg(&spi->dev, \"index=%d\\n\", v->index);\n\n\tstrscpy(v->name, \"Mirics MSi001\", sizeof(v->name));\n\tv->type = V4L2_TUNER_RF;\n\tv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\n\tv->rangelow =    49000000;\n\tv->rangehigh =  960000000;\n\n\treturn 0;\n}\n\nstatic int msi001_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *v)\n{\n\tstruct msi001_dev *dev = sd_to_msi001_dev(sd);\n\tstruct spi_device *spi = dev->spi;\n\n\tdev_dbg(&spi->dev, \"index=%d\\n\", v->index);\n\treturn 0;\n}\n\nstatic int msi001_g_frequency(struct v4l2_subdev *sd, struct v4l2_frequency *f)\n{\n\tstruct msi001_dev *dev = sd_to_msi001_dev(sd);\n\tstruct spi_device *spi = dev->spi;\n\n\tdev_dbg(&spi->dev, \"tuner=%d\\n\", f->tuner);\n\tf->frequency = dev->f_tuner;\n\treturn 0;\n}\n\nstatic int msi001_s_frequency(struct v4l2_subdev *sd,\n\t\t\t      const struct v4l2_frequency *f)\n{\n\tstruct msi001_dev *dev = sd_to_msi001_dev(sd);\n\tstruct spi_device *spi = dev->spi;\n\tunsigned int band;\n\n\tdev_dbg(&spi->dev, \"tuner=%d type=%d frequency=%u\\n\",\n\t\tf->tuner, f->type, f->frequency);\n\n\tif (f->frequency < ((bands[0].rangehigh + bands[1].rangelow) / 2))\n\t\tband = 0;\n\telse\n\t\tband = 1;\n\tdev->f_tuner = clamp_t(unsigned int, f->frequency,\n\t\t\t       bands[band].rangelow, bands[band].rangehigh);\n\n\treturn msi001_set_tuner(dev);\n}\n\nstatic int msi001_enum_freq_bands(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_frequency_band *band)\n{\n\tstruct msi001_dev *dev = sd_to_msi001_dev(sd);\n\tstruct spi_device *spi = dev->spi;\n\n\tdev_dbg(&spi->dev, \"tuner=%d type=%d index=%d\\n\",\n\t\tband->tuner, band->type, band->index);\n\n\tif (band->index >= ARRAY_SIZE(bands))\n\t\treturn -EINVAL;\n\n\tband->capability = bands[band->index].capability;\n\tband->rangelow = bands[band->index].rangelow;\n\tband->rangehigh = bands[band->index].rangehigh;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_tuner_ops msi001_tuner_ops = {\n\t.standby                  = msi001_standby,\n\t.g_tuner                  = msi001_g_tuner,\n\t.s_tuner                  = msi001_s_tuner,\n\t.g_frequency              = msi001_g_frequency,\n\t.s_frequency              = msi001_s_frequency,\n\t.enum_freq_bands          = msi001_enum_freq_bands,\n};\n\nstatic const struct v4l2_subdev_ops msi001_ops = {\n\t.tuner                    = &msi001_tuner_ops,\n};\n\nstatic int msi001_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct msi001_dev *dev = container_of(ctrl->handler, struct msi001_dev, hdl);\n\tstruct spi_device *spi = dev->spi;\n\n\tint ret;\n\n\tdev_dbg(&spi->dev, \"id=%d name=%s val=%d min=%lld max=%lld step=%lld\\n\",\n\t\tctrl->id, ctrl->name, ctrl->val, ctrl->minimum, ctrl->maximum,\n\t\tctrl->step);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_RF_TUNER_BANDWIDTH_AUTO:\n\tcase V4L2_CID_RF_TUNER_BANDWIDTH:\n\t\tret = msi001_set_tuner(dev);\n\t\tbreak;\n\tcase  V4L2_CID_RF_TUNER_LNA_GAIN:\n\t\tret = msi001_set_gain(dev, dev->lna_gain->val,\n\t\t\t\t      dev->mixer_gain->cur.val,\n\t\t\t\t      dev->if_gain->cur.val);\n\t\tbreak;\n\tcase  V4L2_CID_RF_TUNER_MIXER_GAIN:\n\t\tret = msi001_set_gain(dev, dev->lna_gain->cur.val,\n\t\t\t\t      dev->mixer_gain->val,\n\t\t\t\t      dev->if_gain->cur.val);\n\t\tbreak;\n\tcase  V4L2_CID_RF_TUNER_IF_GAIN:\n\t\tret = msi001_set_gain(dev, dev->lna_gain->cur.val,\n\t\t\t\t      dev->mixer_gain->cur.val,\n\t\t\t\t      dev->if_gain->val);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&spi->dev, \"unknown control %d\\n\", ctrl->id);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops msi001_ctrl_ops = {\n\t.s_ctrl                   = msi001_s_ctrl,\n};\n\nstatic int msi001_probe(struct spi_device *spi)\n{\n\tstruct msi001_dev *dev;\n\tint ret;\n\n\tdev_dbg(&spi->dev, \"\\n\");\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tdev->spi = spi;\n\tdev->f_tuner = bands[0].rangelow;\n\tv4l2_spi_subdev_init(&dev->sd, spi, &msi001_ops);\n\n\t \n\tv4l2_ctrl_handler_init(&dev->hdl, 5);\n\tdev->bandwidth_auto = v4l2_ctrl_new_std(&dev->hdl, &msi001_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_BANDWIDTH_AUTO, 0, 1, 1, 1);\n\tdev->bandwidth = v4l2_ctrl_new_std(&dev->hdl, &msi001_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_BANDWIDTH, 200000, 8000000, 1, 200000);\n\tif (dev->hdl.error) {\n\t\tret = dev->hdl.error;\n\t\tdev_err(&spi->dev, \"Could not initialize controls\\n\");\n\t\t \n\t\tgoto err_ctrl_handler_free;\n\t}\n\n\tv4l2_ctrl_auto_cluster(2, &dev->bandwidth_auto, 0, false);\n\tdev->lna_gain = v4l2_ctrl_new_std(&dev->hdl, &msi001_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_LNA_GAIN, 0, 1, 1, 1);\n\tdev->mixer_gain = v4l2_ctrl_new_std(&dev->hdl, &msi001_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_MIXER_GAIN, 0, 1, 1, 1);\n\tdev->if_gain = v4l2_ctrl_new_std(&dev->hdl, &msi001_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_IF_GAIN, 0, 59, 1, 0);\n\tif (dev->hdl.error) {\n\t\tret = dev->hdl.error;\n\t\tdev_err(&spi->dev, \"Could not initialize controls\\n\");\n\t\t \n\t\tgoto err_ctrl_handler_free;\n\t}\n\n\tdev->sd.ctrl_handler = &dev->hdl;\n\treturn 0;\nerr_ctrl_handler_free:\n\tv4l2_ctrl_handler_free(&dev->hdl);\n\tkfree(dev);\nerr:\n\treturn ret;\n}\n\nstatic void msi001_remove(struct spi_device *spi)\n{\n\tstruct v4l2_subdev *sd = spi_get_drvdata(spi);\n\tstruct msi001_dev *dev = sd_to_msi001_dev(sd);\n\n\tdev_dbg(&spi->dev, \"\\n\");\n\n\t \n\tv4l2_device_unregister_subdev(&dev->sd);\n\tv4l2_ctrl_handler_free(&dev->hdl);\n\tkfree(dev);\n}\n\nstatic const struct spi_device_id msi001_id_table[] = {\n\t{\"msi001\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, msi001_id_table);\n\nstatic struct spi_driver msi001_driver = {\n\t.driver = {\n\t\t.name\t= \"msi001\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= msi001_probe,\n\t.remove\t\t= msi001_remove,\n\t.id_table\t= msi001_id_table,\n};\nmodule_spi_driver(msi001_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"Mirics MSi001\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}