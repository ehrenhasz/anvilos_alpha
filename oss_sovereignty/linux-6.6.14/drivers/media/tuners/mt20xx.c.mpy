{
  "module_name": "mt20xx.c",
  "hash_id": "9bee670940e12228f67991762221afdf38db242027de2bd12d785719a925a9b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/mt20xx.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include \"tuner-i2c.h\"\n#include \"mt20xx.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable verbose debug messages\");\n\n \n\nstatic unsigned int optimize_vco  = 1;\nmodule_param(optimize_vco,      int, 0644);\n\nstatic unsigned int tv_antenna    = 1;\nmodule_param(tv_antenna,        int, 0644);\n\nstatic unsigned int radio_antenna;\nmodule_param(radio_antenna,     int, 0644);\n\n \n\n#define MT2032 0x04\n#define MT2030 0x06\n#define MT2040 0x07\n#define MT2050 0x42\n\nstatic char *microtune_part[] = {\n\t[ MT2030 ] = \"MT2030\",\n\t[ MT2032 ] = \"MT2032\",\n\t[ MT2040 ] = \"MT2040\",\n\t[ MT2050 ] = \"MT2050\",\n};\n\nstruct microtune_priv {\n\tstruct tuner_i2c_props i2c_props;\n\n\tunsigned int xogc;\n\t\n\n\tu32 frequency;\n};\n\nstatic void microtune_release(struct dvb_frontend *fe)\n{\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic int microtune_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct microtune_priv *priv = fe->tuner_priv;\n\t*frequency = priv->frequency;\n\treturn 0;\n}\n\n\nstatic int mt2032_spurcheck(struct dvb_frontend *fe,\n\t\t\t    int f1, int f2, int spectrum_from,int spectrum_to)\n{\n\tstruct microtune_priv *priv = fe->tuner_priv;\n\tint n1=1,n2,f;\n\n\tf1=f1/1000; \n\tf2=f2/1000;\n\tspectrum_from/=1000;\n\tspectrum_to/=1000;\n\n\ttuner_dbg(\"spurcheck f1=%d f2=%d  from=%d to=%d\\n\",\n\t\t  f1,f2,spectrum_from,spectrum_to);\n\n\tdo {\n\t    n2=-n1;\n\t    f=n1*(f1-f2);\n\t    do {\n\t\tn2--;\n\t\tf=f-f2;\n\t\ttuner_dbg(\"spurtest n1=%d n2=%d ftest=%d\\n\",n1,n2,f);\n\n\t\tif( (f>spectrum_from) && (f<spectrum_to))\n\t\t\ttuner_dbg(\"mt2032 spurcheck triggered: %d\\n\",n1);\n\t    } while ( (f>(f2-spectrum_to)) || (n2>-5));\n\t    n1++;\n\t} while (n1<5);\n\n\treturn 1;\n}\n\nstatic int mt2032_compute_freq(struct dvb_frontend *fe,\n\t\t\t       unsigned int rfin,\n\t\t\t       unsigned int if1, unsigned int if2,\n\t\t\t       unsigned int spectrum_from,\n\t\t\t       unsigned int spectrum_to,\n\t\t\t       unsigned char *buf,\n\t\t\t       int *ret_sel,\n\t\t\t       unsigned int xogc) \n{\n\tstruct microtune_priv *priv = fe->tuner_priv;\n\tunsigned int fref,lo1,lo1n,lo1a,s,sel,lo1freq, desired_lo1,\n\t\tdesired_lo2,lo2,lo2n,lo2a,lo2num,lo2freq;\n\n\tfref= 5250 *1000; \n\tdesired_lo1=rfin+if1;\n\n\tlo1=(2*(desired_lo1/1000)+(fref/1000)) / (2*fref/1000);\n\tlo1n=lo1/8;\n\tlo1a=lo1-(lo1n*8);\n\n\ts=rfin/1000/1000+1090;\n\n\tif(optimize_vco) {\n\t\tif(s>1890) sel=0;\n\t\telse if(s>1720) sel=1;\n\t\telse if(s>1530) sel=2;\n\t\telse if(s>1370) sel=3;\n\t\telse sel=4; \n\t}\n\telse {\n\t\tif(s>1790) sel=0; \n\t\telse if(s>1617) sel=1;\n\t\telse if(s>1449) sel=2;\n\t\telse if(s>1291) sel=3;\n\t\telse sel=4; \n\t}\n\t*ret_sel=sel;\n\n\tlo1freq=(lo1a+8*lo1n)*fref;\n\n\ttuner_dbg(\"mt2032: rfin=%d lo1=%d lo1n=%d lo1a=%d sel=%d, lo1freq=%d\\n\",\n\t\t  rfin,lo1,lo1n,lo1a,sel,lo1freq);\n\n\tdesired_lo2=lo1freq-rfin-if2;\n\tlo2=(desired_lo2)/fref;\n\tlo2n=lo2/8;\n\tlo2a=lo2-(lo2n*8);\n\tlo2num=((desired_lo2/1000)%(fref/1000))* 3780/(fref/1000); \n\tlo2freq=(lo2a+8*lo2n)*fref + lo2num*(fref/1000)/3780*1000;\n\n\ttuner_dbg(\"mt2032: rfin=%d lo2=%d lo2n=%d lo2a=%d num=%d lo2freq=%d\\n\",\n\t\t  rfin,lo2,lo2n,lo2a,lo2num,lo2freq);\n\n\tif (lo1a > 7 || lo1n < 17 || lo1n > 48 || lo2a > 7 || lo2n < 17 ||\n\t\t\tlo2n > 30) {\n\t\ttuner_info(\"mt2032: frequency parameters out of range: %d %d %d %d\\n\",\n\t\t\t   lo1a, lo1n, lo2a,lo2n);\n\t\treturn(-1);\n\t}\n\n\tmt2032_spurcheck(fe, lo1freq, desired_lo2,  spectrum_from, spectrum_to);\n\t\n\n\t\n\tbuf[0]=lo1n-1;\n\tbuf[1]=lo1a | (sel<<4);\n\tbuf[2]=0x86; \n\tbuf[3]=0x0f; \n\tbuf[4]=0x1f;\n\tbuf[5]=(lo2n-1) | (lo2a<<5);\n\tif(rfin >400*1000*1000)\n\t\tbuf[6]=0xe4;\n\telse\n\t\tbuf[6]=0xf4; \n\tbuf[7]=8+xogc;\n\tbuf[8]=0xc3; \n\tbuf[9]=0x4e; \n\tbuf[10]=0xec; \n\tbuf[11]=(lo2num&0xff);\n\tbuf[12]=(lo2num>>8) |0x80; \n\n\treturn 0;\n}\n\nstatic int mt2032_check_lo_lock(struct dvb_frontend *fe)\n{\n\tstruct microtune_priv *priv = fe->tuner_priv;\n\tint try,lock=0;\n\tunsigned char buf[2];\n\n\tfor(try=0;try<10;try++) {\n\t\tbuf[0]=0x0e;\n\t\ttuner_i2c_xfer_send(&priv->i2c_props,buf,1);\n\t\ttuner_i2c_xfer_recv(&priv->i2c_props,buf,1);\n\t\ttuner_dbg(\"mt2032 Reg.E=0x%02x\\n\",buf[0]);\n\t\tlock=buf[0] &0x06;\n\n\t\tif (lock==6)\n\t\t\tbreak;\n\n\t\ttuner_dbg(\"mt2032: pll wait 1ms for lock (0x%2x)\\n\",buf[0]);\n\t\tudelay(1000);\n\t}\n\treturn lock;\n}\n\nstatic int mt2032_optimize_vco(struct dvb_frontend *fe,int sel,int lock)\n{\n\tstruct microtune_priv *priv = fe->tuner_priv;\n\tunsigned char buf[2];\n\tint tad1;\n\n\tbuf[0]=0x0f;\n\ttuner_i2c_xfer_send(&priv->i2c_props,buf,1);\n\ttuner_i2c_xfer_recv(&priv->i2c_props,buf,1);\n\ttuner_dbg(\"mt2032 Reg.F=0x%02x\\n\",buf[0]);\n\ttad1=buf[0]&0x07;\n\n\tif(tad1 ==0) return lock;\n\tif(tad1 ==1) return lock;\n\n\tif(tad1==2) {\n\t\tif(sel==0)\n\t\t\treturn lock;\n\t\telse sel--;\n\t}\n\telse {\n\t\tif(sel<4)\n\t\t\tsel++;\n\t\telse\n\t\t\treturn lock;\n\t}\n\n\ttuner_dbg(\"mt2032 optimize_vco: sel=%d\\n\",sel);\n\n\tbuf[0]=0x0f;\n\tbuf[1]=sel;\n\ttuner_i2c_xfer_send(&priv->i2c_props,buf,2);\n\tlock=mt2032_check_lo_lock(fe);\n\treturn lock;\n}\n\n\nstatic void mt2032_set_if_freq(struct dvb_frontend *fe, unsigned int rfin,\n\t\t\t       unsigned int if1, unsigned int if2,\n\t\t\t       unsigned int from, unsigned int to)\n{\n\tunsigned char buf[21];\n\tint lint_try,ret,sel,lock=0;\n\tstruct microtune_priv *priv = fe->tuner_priv;\n\n\ttuner_dbg(\"mt2032_set_if_freq rfin=%d if1=%d if2=%d from=%d to=%d\\n\",\n\t\t  rfin,if1,if2,from,to);\n\n\tbuf[0]=0;\n\tret=tuner_i2c_xfer_send(&priv->i2c_props,buf,1);\n\ttuner_i2c_xfer_recv(&priv->i2c_props,buf,21);\n\n\tbuf[0]=0;\n\tret=mt2032_compute_freq(fe,rfin,if1,if2,from,to,&buf[1],&sel,priv->xogc);\n\tif (ret<0)\n\t\treturn;\n\n\t\n\tbuf[0]=0;\n\tret=tuner_i2c_xfer_send(&priv->i2c_props,buf,4);\n\tbuf[5]=5;\n\tret=tuner_i2c_xfer_send(&priv->i2c_props,buf+5,4);\n\tbuf[11]=11;\n\tret=tuner_i2c_xfer_send(&priv->i2c_props,buf+11,3);\n\tif(ret!=3)\n\t\ttuner_warn(\"i2c i/o error: rc == %d (should be 3)\\n\",ret);\n\n\t\n\tfor(lint_try=0; lint_try<2; lint_try++) {\n\t\tlock=mt2032_check_lo_lock(fe);\n\n\t\tif(optimize_vco)\n\t\t\tlock=mt2032_optimize_vco(fe,sel,lock);\n\t\tif(lock==6) break;\n\n\t\ttuner_dbg(\"mt2032: re-init PLLs by LINT\\n\");\n\t\tbuf[0]=7;\n\t\tbuf[1]=0x80 +8+priv->xogc; \n\t\ttuner_i2c_xfer_send(&priv->i2c_props,buf,2);\n\t\tmdelay(10);\n\t\tbuf[1]=8+priv->xogc;\n\t\ttuner_i2c_xfer_send(&priv->i2c_props,buf,2);\n\t}\n\n\tif (lock!=6)\n\t\ttuner_warn(\"MT2032 Fatal Error: PLLs didn't lock.\\n\");\n\n\tbuf[0]=2;\n\tbuf[1]=0x20; \n\tret=tuner_i2c_xfer_send(&priv->i2c_props,buf,2);\n\tif (ret!=2)\n\t\ttuner_warn(\"i2c i/o error: rc == %d (should be 2)\\n\",ret);\n}\n\n\nstatic int mt2032_set_tv_freq(struct dvb_frontend *fe,\n\t\t\t      struct analog_parameters *params)\n{\n\tint if2,from,to;\n\n\t\n\tif (params->std & V4L2_STD_525_60) {\n\t\t\n\t\tfrom = 40750*1000;\n\t\tto   = 46750*1000;\n\t\tif2  = 45750*1000;\n\t} else {\n\t\t\n\t\tfrom = 32900*1000;\n\t\tto   = 39900*1000;\n\t\tif2  = 38900*1000;\n\t}\n\n\tmt2032_set_if_freq(fe, params->frequency*62500,\n\t\t\t   1090*1000*1000, if2, from, to);\n\n\treturn 0;\n}\n\nstatic int mt2032_set_radio_freq(struct dvb_frontend *fe,\n\t\t\t\t struct analog_parameters *params)\n{\n\tstruct microtune_priv *priv = fe->tuner_priv;\n\tint if2;\n\n\tif (params->std & V4L2_STD_525_60) {\n\t\ttuner_dbg(\"pinnacle ntsc\\n\");\n\t\tif2 = 41300 * 1000;\n\t} else {\n\t\ttuner_dbg(\"pinnacle pal\\n\");\n\t\tif2 = 33300 * 1000;\n\t}\n\n\t\n\tmt2032_set_if_freq(fe, params->frequency * 125 / 2,\n\t\t\t   1085*1000*1000,if2,if2,if2);\n\n\treturn 0;\n}\n\nstatic int mt2032_set_params(struct dvb_frontend *fe,\n\t\t\t     struct analog_parameters *params)\n{\n\tstruct microtune_priv *priv = fe->tuner_priv;\n\tint ret = -EINVAL;\n\n\tswitch (params->mode) {\n\tcase V4L2_TUNER_RADIO:\n\t\tret = mt2032_set_radio_freq(fe, params);\n\t\tpriv->frequency = params->frequency * 125 / 2;\n\t\tbreak;\n\tcase V4L2_TUNER_ANALOG_TV:\n\tcase V4L2_TUNER_DIGITAL_TV:\n\t\tret = mt2032_set_tv_freq(fe, params);\n\t\tpriv->frequency = params->frequency * 62500;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct dvb_tuner_ops mt2032_tuner_ops = {\n\t.set_analog_params = mt2032_set_params,\n\t.release           = microtune_release,\n\t.get_frequency     = microtune_get_frequency,\n};\n\n\nstatic int mt2032_init(struct dvb_frontend *fe)\n{\n\tstruct microtune_priv *priv = fe->tuner_priv;\n\tunsigned char buf[21];\n\tint ret,xogc,xok=0;\n\n\t\n\tbuf[1]=2; \n\tbuf[2]=0xff;\n\tbuf[3]=0x0f;\n\tbuf[4]=0x1f;\n\tret=tuner_i2c_xfer_send(&priv->i2c_props,buf+1,4);\n\n\tbuf[5]=6; \n\tbuf[6]=0xe4;\n\tbuf[7]=0x8f;\n\tbuf[8]=0xc3;\n\tbuf[9]=0x4e;\n\tbuf[10]=0xec;\n\tret=tuner_i2c_xfer_send(&priv->i2c_props,buf+5,6);\n\n\tbuf[12]=13;  \n\tbuf[13]=0x32;\n\tret=tuner_i2c_xfer_send(&priv->i2c_props,buf+12,2);\n\n\t\n\txogc=7;\n\tdo {\n\t\ttuner_dbg(\"mt2032: xogc = 0x%02x\\n\",xogc&0x07);\n\t\tmdelay(10);\n\t\tbuf[0]=0x0e;\n\t\ttuner_i2c_xfer_send(&priv->i2c_props,buf,1);\n\t\ttuner_i2c_xfer_recv(&priv->i2c_props,buf,1);\n\t\txok=buf[0]&0x01;\n\t\ttuner_dbg(\"mt2032: xok = 0x%02x\\n\",xok);\n\t\tif (xok == 1) break;\n\n\t\txogc--;\n\t\ttuner_dbg(\"mt2032: xogc = 0x%02x\\n\",xogc&0x07);\n\t\tif (xogc == 3) {\n\t\t\txogc=4; \n\t\t\tbreak;\n\t\t}\n\t\tbuf[0]=0x07;\n\t\tbuf[1]=0x88 + xogc;\n\t\tret=tuner_i2c_xfer_send(&priv->i2c_props,buf,2);\n\t\tif (ret!=2)\n\t\t\ttuner_warn(\"i2c i/o error: rc == %d (should be 2)\\n\",ret);\n\t} while (xok != 1 );\n\tpriv->xogc=xogc;\n\n\tmemcpy(&fe->ops.tuner_ops, &mt2032_tuner_ops, sizeof(struct dvb_tuner_ops));\n\n\treturn(1);\n}\n\nstatic void mt2050_set_antenna(struct dvb_frontend *fe, unsigned char antenna)\n{\n\tstruct microtune_priv *priv = fe->tuner_priv;\n\tunsigned char buf[2];\n\n\tbuf[0] = 6;\n\tbuf[1] = antenna ? 0x11 : 0x10;\n\ttuner_i2c_xfer_send(&priv->i2c_props, buf, 2);\n\ttuner_dbg(\"mt2050: enabled antenna connector %d\\n\", antenna);\n}\n\nstatic void mt2050_set_if_freq(struct dvb_frontend *fe,unsigned int freq, unsigned int if2)\n{\n\tstruct microtune_priv *priv = fe->tuner_priv;\n\tunsigned int if1=1218*1000*1000;\n\tunsigned int f_lo1,f_lo2,lo1,lo2,f_lo1_modulo,f_lo2_modulo,num1,num2,div1a,div1b,div2a,div2b;\n\tint ret;\n\tunsigned char buf[6];\n\n\ttuner_dbg(\"mt2050_set_if_freq freq=%d if1=%d if2=%d\\n\",\n\t\t  freq,if1,if2);\n\n\tf_lo1=freq+if1;\n\tf_lo1=(f_lo1/1000000)*1000000;\n\n\tf_lo2=f_lo1-freq-if2;\n\tf_lo2=(f_lo2/50000)*50000;\n\n\tlo1=f_lo1/4000000;\n\tlo2=f_lo2/4000000;\n\n\tf_lo1_modulo= f_lo1-(lo1*4000000);\n\tf_lo2_modulo= f_lo2-(lo2*4000000);\n\n\tnum1=4*f_lo1_modulo/4000000;\n\tnum2=4096*(f_lo2_modulo/1000)/4000;\n\n\t\n\n\tdiv1a=(lo1/12)-1;\n\tdiv1b=lo1-(div1a+1)*12;\n\n\tdiv2a=(lo2/8)-1;\n\tdiv2b=lo2-(div2a+1)*8;\n\n\tif (debug > 1) {\n\t\ttuner_dbg(\"lo1 lo2 = %d %d\\n\", lo1, lo2);\n\t\ttuner_dbg(\"num1 num2 div1a div1b div2a div2b= %x %x %x %x %x %x\\n\",\n\t\t\t  num1,num2,div1a,div1b,div2a,div2b);\n\t}\n\n\tbuf[0]=1;\n\tbuf[1]= 4*div1b + num1;\n\tif(freq<275*1000*1000) buf[1] = buf[1]|0x80;\n\n\tbuf[2]=div1a;\n\tbuf[3]=32*div2b + num2/256;\n\tbuf[4]=num2-(num2/256)*256;\n\tbuf[5]=div2a;\n\tif(num2!=0) buf[5]=buf[5]|0x40;\n\n\tif (debug > 1)\n\t\ttuner_dbg(\"bufs is: %*ph\\n\", 6, buf);\n\n\tret=tuner_i2c_xfer_send(&priv->i2c_props,buf,6);\n\tif (ret!=6)\n\t\ttuner_warn(\"i2c i/o error: rc == %d (should be 6)\\n\",ret);\n}\n\nstatic int mt2050_set_tv_freq(struct dvb_frontend *fe,\n\t\t\t      struct analog_parameters *params)\n{\n\tunsigned int if2;\n\n\tif (params->std & V4L2_STD_525_60) {\n\t\t\n\t\tif2 = 45750*1000;\n\t} else {\n\t\t\n\t\tif2 = 38900*1000;\n\t}\n\tif (V4L2_TUNER_DIGITAL_TV == params->mode) {\n\t\t\n\t\tif2 = 36150*1000;\n\t}\n\tmt2050_set_if_freq(fe, params->frequency*62500, if2);\n\tmt2050_set_antenna(fe, tv_antenna);\n\n\treturn 0;\n}\n\nstatic int mt2050_set_radio_freq(struct dvb_frontend *fe,\n\t\t\t\t struct analog_parameters *params)\n{\n\tstruct microtune_priv *priv = fe->tuner_priv;\n\tint if2;\n\n\tif (params->std & V4L2_STD_525_60) {\n\t\ttuner_dbg(\"pinnacle ntsc\\n\");\n\t\tif2 = 41300 * 1000;\n\t} else {\n\t\ttuner_dbg(\"pinnacle pal\\n\");\n\t\tif2 = 33300 * 1000;\n\t}\n\n\tmt2050_set_if_freq(fe, params->frequency * 125 / 2, if2);\n\tmt2050_set_antenna(fe, radio_antenna);\n\n\treturn 0;\n}\n\nstatic int mt2050_set_params(struct dvb_frontend *fe,\n\t\t\t     struct analog_parameters *params)\n{\n\tstruct microtune_priv *priv = fe->tuner_priv;\n\tint ret = -EINVAL;\n\n\tswitch (params->mode) {\n\tcase V4L2_TUNER_RADIO:\n\t\tret = mt2050_set_radio_freq(fe, params);\n\t\tpriv->frequency = params->frequency * 125 / 2;\n\t\tbreak;\n\tcase V4L2_TUNER_ANALOG_TV:\n\tcase V4L2_TUNER_DIGITAL_TV:\n\t\tret = mt2050_set_tv_freq(fe, params);\n\t\tpriv->frequency = params->frequency * 62500;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct dvb_tuner_ops mt2050_tuner_ops = {\n\t.set_analog_params = mt2050_set_params,\n\t.release           = microtune_release,\n\t.get_frequency     = microtune_get_frequency,\n};\n\nstatic int mt2050_init(struct dvb_frontend *fe)\n{\n\tstruct microtune_priv *priv = fe->tuner_priv;\n\tunsigned char buf[2];\n\n\tbuf[0] = 6;\n\tbuf[1] = 0x10;\n\ttuner_i2c_xfer_send(&priv->i2c_props, buf, 2);  \n\n\tbuf[0] = 0x0f;\n\tbuf[1] = 0x0f;\n\ttuner_i2c_xfer_send(&priv->i2c_props, buf, 2);  \n\n\tbuf[0] = 0x0d;\n\ttuner_i2c_xfer_send(&priv->i2c_props, buf, 1);\n\ttuner_i2c_xfer_recv(&priv->i2c_props, buf, 1);\n\n\ttuner_dbg(\"mt2050: sro is %x\\n\", buf[0]);\n\n\tmemcpy(&fe->ops.tuner_ops, &mt2050_tuner_ops, sizeof(struct dvb_tuner_ops));\n\n\treturn 0;\n}\n\nstruct dvb_frontend *microtune_attach(struct dvb_frontend *fe,\n\t\t\t\t      struct i2c_adapter* i2c_adap,\n\t\t\t\t      u8 i2c_addr)\n{\n\tstruct microtune_priv *priv = NULL;\n\tchar *name;\n\tunsigned char buf[21];\n\tint company_code;\n\n\tpriv = kzalloc(sizeof(struct microtune_priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn NULL;\n\tfe->tuner_priv = priv;\n\n\tpriv->i2c_props.addr = i2c_addr;\n\tpriv->i2c_props.adap = i2c_adap;\n\tpriv->i2c_props.name = \"mt20xx\";\n\n\t\n\n\tmemset(buf,0,sizeof(buf));\n\n\tname = \"unknown\";\n\n\ttuner_i2c_xfer_send(&priv->i2c_props,buf,1);\n\ttuner_i2c_xfer_recv(&priv->i2c_props,buf,21);\n\tif (debug)\n\t\ttuner_dbg(\"MT20xx hexdump: %*ph\\n\", 21, buf);\n\n\tcompany_code = buf[0x11] << 8 | buf[0x12];\n\ttuner_info(\"microtune: companycode=%04x part=%02x rev=%02x\\n\",\n\t\t   company_code,buf[0x13],buf[0x14]);\n\n\n\tif (buf[0x13] < ARRAY_SIZE(microtune_part) &&\n\t    NULL != microtune_part[buf[0x13]])\n\t\tname = microtune_part[buf[0x13]];\n\tswitch (buf[0x13]) {\n\tcase MT2032:\n\t\tmt2032_init(fe);\n\t\tbreak;\n\tcase MT2050:\n\t\tmt2050_init(fe);\n\t\tbreak;\n\tdefault:\n\t\ttuner_info(\"microtune %s found, not (yet?) supported, sorry :-/\\n\",\n\t\t\t   name);\n\t\treturn NULL;\n\t}\n\n\tstrscpy(fe->ops.tuner_ops.info.name, name,\n\t\tsizeof(fe->ops.tuner_ops.info.name));\n\ttuner_info(\"microtune %s found, OK\\n\",name);\n\treturn fe;\n}\n\nEXPORT_SYMBOL_GPL(microtune_attach);\n\nMODULE_DESCRIPTION(\"Microtune tuner driver\");\nMODULE_AUTHOR(\"Ralph Metzler, Gerd Knorr, Gunther Mayer\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}