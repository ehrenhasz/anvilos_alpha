{
  "module_name": "mt2063.c",
  "hash_id": "67057863e07b83e39a501505c51bbc871ae48ecab02334c23c88964714cd3ffb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/tuners/mt2063.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/videodev2.h>\n#include <linux/gcd.h>\n\n#include \"mt2063.h\"\n\nstatic unsigned int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Set Verbosity level\");\n\n#define dprintk(level, fmt, arg...) do {\t\t\t\t\\\nif (debug >= level)\t\t\t\t\t\t\t\\\n\tprintk(KERN_DEBUG \"mt2063 %s: \" fmt, __func__, ## arg);\t\\\n} while (0)\n\n\n \n\n \n#define MT2063_SPUR_PRESENT_ERR             (0x00800000)\n\n \n#define MT2063_SPUR_CNT_MASK                (0x001f0000)\n#define MT2063_SPUR_SHIFT                   (16)\n\n \n#define MT2063_UPC_RANGE                    (0x04000000)\n\n \n#define MT2063_DNC_RANGE                    (0x08000000)\n\n \n\n \n#define MT2063_DECT_AVOID_US_FREQS      0x00000001\n\n#define MT2063_DECT_AVOID_EURO_FREQS    0x00000002\n\n#define MT2063_EXCLUDE_US_DECT_FREQUENCIES(s) (((s) & MT2063_DECT_AVOID_US_FREQS) != 0)\n\n#define MT2063_EXCLUDE_EURO_DECT_FREQUENCIES(s) (((s) & MT2063_DECT_AVOID_EURO_FREQS) != 0)\n\nenum MT2063_DECT_Avoid_Type {\n\tMT2063_NO_DECT_AVOIDANCE = 0,\t\t\t\t \n\tMT2063_AVOID_US_DECT = MT2063_DECT_AVOID_US_FREQS,\t \n\tMT2063_AVOID_EURO_DECT = MT2063_DECT_AVOID_EURO_FREQS,\t \n\tMT2063_AVOID_BOTH\t\t\t\t\t \n};\n\n#define MT2063_MAX_ZONES 48\n\nstruct MT2063_ExclZone_t {\n\tu32 min_;\n\tu32 max_;\n\tstruct MT2063_ExclZone_t *next_;\n};\n\n \nstruct MT2063_AvoidSpursData_t {\n\tu32 f_ref;\n\tu32 f_in;\n\tu32 f_LO1;\n\tu32 f_if1_Center;\n\tu32 f_if1_Request;\n\tu32 f_if1_bw;\n\tu32 f_LO2;\n\tu32 f_out;\n\tu32 f_out_bw;\n\tu32 f_LO1_Step;\n\tu32 f_LO2_Step;\n\tu32 f_LO1_FracN_Avoid;\n\tu32 f_LO2_FracN_Avoid;\n\tu32 f_zif_bw;\n\tu32 f_min_LO_Separation;\n\tu32 maxH1;\n\tu32 maxH2;\n\tenum MT2063_DECT_Avoid_Type avoidDECT;\n\tu32 bSpurPresent;\n\tu32 bSpurAvoided;\n\tu32 nSpursFound;\n\tu32 nZones;\n\tstruct MT2063_ExclZone_t *freeZones;\n\tstruct MT2063_ExclZone_t *usedZones;\n\tstruct MT2063_ExclZone_t MT2063_ExclZones[MT2063_MAX_ZONES];\n};\n\n \nenum MT2063_Mask_Bits {\n\tMT2063_REG_SD = 0x0040,\t\t \n\tMT2063_SRO_SD = 0x0020,\t\t \n\tMT2063_AFC_SD = 0x0010,\t\t \n\tMT2063_PD_SD = 0x0002,\t\t \n\tMT2063_PDADC_SD = 0x0001,\t \n\tMT2063_VCO_SD = 0x8000,\t\t \n\tMT2063_LTX_SD = 0x4000,\t\t \n\tMT2063_LT1_SD = 0x2000,\t\t \n\tMT2063_LNA_SD = 0x1000,\t\t \n\tMT2063_UPC_SD = 0x0800,\t\t \n\tMT2063_DNC_SD = 0x0400,\t\t \n\tMT2063_VGA_SD = 0x0200,\t\t \n\tMT2063_AMP_SD = 0x0100,\t\t \n\tMT2063_ALL_SD = 0xFF73,\t\t \n\tMT2063_NONE_SD = 0x0000\t\t \n};\n\n \nenum MT2063_DNC_Output_Enable {\n\tMT2063_DNC_NONE = 0,\n\tMT2063_DNC_1,\n\tMT2063_DNC_2,\n\tMT2063_DNC_BOTH\n};\n\n \nenum MT2063_Register_Offsets {\n\tMT2063_REG_PART_REV = 0,\t \n\tMT2063_REG_LO1CQ_1,\t\t \n\tMT2063_REG_LO1CQ_2,\t\t \n\tMT2063_REG_LO2CQ_1,\t\t \n\tMT2063_REG_LO2CQ_2,\t\t \n\tMT2063_REG_LO2CQ_3,\t\t \n\tMT2063_REG_RSVD_06,\t\t \n\tMT2063_REG_LO_STATUS,\t\t \n\tMT2063_REG_FIFFC,\t\t \n\tMT2063_REG_CLEARTUNE,\t\t \n\tMT2063_REG_ADC_OUT,\t\t \n\tMT2063_REG_LO1C_1,\t\t \n\tMT2063_REG_LO1C_2,\t\t \n\tMT2063_REG_LO2C_1,\t\t \n\tMT2063_REG_LO2C_2,\t\t \n\tMT2063_REG_LO2C_3,\t\t \n\tMT2063_REG_RSVD_10,\t\t \n\tMT2063_REG_PWR_1,\t\t \n\tMT2063_REG_PWR_2,\t\t \n\tMT2063_REG_TEMP_STATUS,\t\t \n\tMT2063_REG_XO_STATUS,\t\t \n\tMT2063_REG_RF_STATUS,\t\t \n\tMT2063_REG_FIF_STATUS,\t\t \n\tMT2063_REG_LNA_OV,\t\t \n\tMT2063_REG_RF_OV,\t\t \n\tMT2063_REG_FIF_OV,\t\t \n\tMT2063_REG_LNA_TGT,\t\t \n\tMT2063_REG_PD1_TGT,\t\t \n\tMT2063_REG_PD2_TGT,\t\t \n\tMT2063_REG_RSVD_1D,\t\t \n\tMT2063_REG_RSVD_1E,\t\t \n\tMT2063_REG_RSVD_1F,\t\t \n\tMT2063_REG_RSVD_20,\t\t \n\tMT2063_REG_BYP_CTRL,\t\t \n\tMT2063_REG_RSVD_22,\t\t \n\tMT2063_REG_RSVD_23,\t\t \n\tMT2063_REG_RSVD_24,\t\t \n\tMT2063_REG_RSVD_25,\t\t \n\tMT2063_REG_RSVD_26,\t\t \n\tMT2063_REG_RSVD_27,\t\t \n\tMT2063_REG_FIFF_CTRL,\t\t \n\tMT2063_REG_FIFF_OFFSET,\t\t \n\tMT2063_REG_CTUNE_CTRL,\t\t \n\tMT2063_REG_CTUNE_OV,\t\t \n\tMT2063_REG_CTRL_2C,\t\t \n\tMT2063_REG_FIFF_CTRL2,\t\t \n\tMT2063_REG_RSVD_2E,\t\t \n\tMT2063_REG_DNC_GAIN,\t\t \n\tMT2063_REG_VGA_GAIN,\t\t \n\tMT2063_REG_RSVD_31,\t\t \n\tMT2063_REG_TEMP_SEL,\t\t \n\tMT2063_REG_RSVD_33,\t\t \n\tMT2063_REG_RSVD_34,\t\t \n\tMT2063_REG_RSVD_35,\t\t \n\tMT2063_REG_RSVD_36,\t\t \n\tMT2063_REG_RSVD_37,\t\t \n\tMT2063_REG_RSVD_38,\t\t \n\tMT2063_REG_RSVD_39,\t\t \n\tMT2063_REG_RSVD_3A,\t\t \n\tMT2063_REG_RSVD_3B,\t\t \n\tMT2063_REG_RSVD_3C,\t\t \n\tMT2063_REG_END_REGS\n};\n\nstruct mt2063_state {\n\tstruct i2c_adapter *i2c;\n\n\tbool init;\n\n\tconst struct mt2063_config *config;\n\tstruct dvb_tuner_ops ops;\n\tstruct dvb_frontend *frontend;\n\n\tu32 frequency;\n\tu32 srate;\n\tu32 bandwidth;\n\tu32 reference;\n\n\tu32 tuner_id;\n\tstruct MT2063_AvoidSpursData_t AS_Data;\n\tu32 f_IF1_actual;\n\tu32 rcvr_mode;\n\tu32 ctfilt_sw;\n\tu32 CTFiltMax[31];\n\tu32 num_regs;\n\tu8 reg[MT2063_REG_END_REGS];\n};\n\n \nstatic int mt2063_write(struct mt2063_state *state, u8 reg, u8 *data, u32 len)\n{\n\tstruct dvb_frontend *fe = state->frontend;\n\tint ret;\n\tu8 buf[60];\n\tstruct i2c_msg msg = {\n\t\t.addr = state->config->tuner_address,\n\t\t.flags = 0,\n\t\t.buf = buf,\n\t\t.len = len + 1\n\t};\n\n\tdprintk(2, \"\\n\");\n\n\tmsg.buf[0] = reg;\n\tmemcpy(msg.buf + 1, data, len);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tif (ret < 0)\n\t\tprintk(KERN_ERR \"%s error ret=%d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\n \nstatic int mt2063_setreg(struct mt2063_state *state, u8 reg, u8 val)\n{\n\tint status;\n\n\tdprintk(2, \"\\n\");\n\n\tif (reg >= MT2063_REG_END_REGS)\n\t\treturn -ERANGE;\n\n\tstatus = mt2063_write(state, reg, &val, 1);\n\tif (status < 0)\n\t\treturn status;\n\n\tstate->reg[reg] = val;\n\n\treturn 0;\n}\n\n \nstatic int mt2063_read(struct mt2063_state *state,\n\t\t\t   u8 subAddress, u8 *pData, u32 cnt)\n{\n\tint status = 0;\t \n\tstruct dvb_frontend *fe = state->frontend;\n\tu32 i = 0;\n\n\tdprintk(2, \"addr 0x%02x, cnt %d\\n\", subAddress, cnt);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tu8 b0[] = { subAddress + i };\n\t\tstruct i2c_msg msg[] = {\n\t\t\t{\n\t\t\t\t.addr = state->config->tuner_address,\n\t\t\t\t.flags = 0,\n\t\t\t\t.buf = b0,\n\t\t\t\t.len = 1\n\t\t\t}, {\n\t\t\t\t.addr = state->config->tuner_address,\n\t\t\t\t.flags = I2C_M_RD,\n\t\t\t\t.buf = pData + i,\n\t\t\t\t.len = 1\n\t\t\t}\n\t\t};\n\n\t\tstatus = i2c_transfer(state->i2c, msg, 2);\n\t\tdprintk(2, \"addr 0x%02x, ret = %d, val = 0x%02x\\n\",\n\t\t\t   subAddress + i, status, *(pData + i));\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tif (status < 0)\n\t\tprintk(KERN_ERR \"Can't read from address 0x%02x,\\n\",\n\t\t       subAddress + i);\n\n\treturn status;\n}\n\n \nstatic int MT2063_Sleep(struct dvb_frontend *fe)\n{\n\t \n\tmsleep(100);\n\n\treturn 0;\n}\n\n \n\n \n#define ceil(n, d) (((n) < 0) ? (-((-(n))/(d))) : (n)/(d) + ((n)%(d) != 0))\n#define floor(n, d) (((n) < 0) ? (-((-(n))/(d))) - ((n)%(d) != 0) : (n)/(d))\n\nstruct MT2063_FIFZone_t {\n\ts32 min_;\n\ts32 max_;\n};\n\nstatic struct MT2063_ExclZone_t *InsertNode(struct MT2063_AvoidSpursData_t\n\t\t\t\t\t    *pAS_Info,\n\t\t\t\t\t    struct MT2063_ExclZone_t *pPrevNode)\n{\n\tstruct MT2063_ExclZone_t *pNode;\n\n\tdprintk(2, \"\\n\");\n\n\t \n\tif (pAS_Info->freeZones != NULL) {\n\t\t \n\t\tpNode = pAS_Info->freeZones;\n\t\tpAS_Info->freeZones = pNode->next_;\n\t} else {\n\t\t \n\t\tpNode = &pAS_Info->MT2063_ExclZones[pAS_Info->nZones];\n\t}\n\n\tif (pPrevNode != NULL) {\n\t\tpNode->next_ = pPrevNode->next_;\n\t\tpPrevNode->next_ = pNode;\n\t} else {\t\t \n\n\t\tpNode->next_ = pAS_Info->usedZones;\n\t\tpAS_Info->usedZones = pNode;\n\t}\n\n\tpAS_Info->nZones++;\n\treturn pNode;\n}\n\nstatic struct MT2063_ExclZone_t *RemoveNode(struct MT2063_AvoidSpursData_t\n\t\t\t\t\t    *pAS_Info,\n\t\t\t\t\t    struct MT2063_ExclZone_t *pPrevNode,\n\t\t\t\t\t    struct MT2063_ExclZone_t\n\t\t\t\t\t    *pNodeToRemove)\n{\n\tstruct MT2063_ExclZone_t *pNext = pNodeToRemove->next_;\n\n\tdprintk(2, \"\\n\");\n\n\t \n\tif (pPrevNode != NULL)\n\t\tpPrevNode->next_ = pNext;\n\n\t \n\tpNodeToRemove->next_ = pAS_Info->freeZones;\n\tpAS_Info->freeZones = pNodeToRemove;\n\n\t \n\tpAS_Info->nZones--;\n\n\treturn pNext;\n}\n\n \nstatic void MT2063_AddExclZone(struct MT2063_AvoidSpursData_t *pAS_Info,\n\t\t\t       u32 f_min, u32 f_max)\n{\n\tstruct MT2063_ExclZone_t *pNode = pAS_Info->usedZones;\n\tstruct MT2063_ExclZone_t *pPrev = NULL;\n\tstruct MT2063_ExclZone_t *pNext = NULL;\n\n\tdprintk(2, \"\\n\");\n\n\t \n\tif ((f_max > (pAS_Info->f_if1_Center - (pAS_Info->f_if1_bw / 2)))\n\t    && (f_min < (pAS_Info->f_if1_Center + (pAS_Info->f_if1_bw / 2)))\n\t    && (f_min < f_max)) {\n\t\t \n\n\t\t \n\t\twhile ((pNode != NULL) && (pNode->max_ < f_min)) {\n\t\t\tpPrev = pNode;\n\t\t\tpNode = pNode->next_;\n\t\t}\n\n\t\tif ((pNode != NULL) && (pNode->min_ < f_max)) {\n\t\t\t \n\t\t\tif (f_min < pNode->min_)\n\t\t\t\tpNode->min_ = f_min;\n\t\t\tif (f_max > pNode->max_)\n\t\t\t\tpNode->max_ = f_max;\n\t\t} else {\n\t\t\tpNode = InsertNode(pAS_Info, pPrev);\n\t\t\tpNode->min_ = f_min;\n\t\t\tpNode->max_ = f_max;\n\t\t}\n\n\t\t \n\t\tpNext = pNode->next_;\n\t\twhile ((pNext != NULL) && (pNext->min_ < pNode->max_)) {\n\t\t\tif (pNext->max_ > pNode->max_)\n\t\t\t\tpNode->max_ = pNext->max_;\n\t\t\t \n\t\t\tpNext = RemoveNode(pAS_Info, pNode, pNext);\n\t\t}\n\t}\n}\n\n \nstatic void MT2063_ResetExclZones(struct MT2063_AvoidSpursData_t *pAS_Info)\n{\n\tu32 center;\n\n\tdprintk(2, \"\\n\");\n\n\tpAS_Info->nZones = 0;\t \n\tpAS_Info->usedZones = NULL;\t \n\tpAS_Info->freeZones = NULL;\t \n\n\tcenter =\n\t    pAS_Info->f_ref *\n\t    ((pAS_Info->f_if1_Center - pAS_Info->f_if1_bw / 2 +\n\t      pAS_Info->f_in) / pAS_Info->f_ref) - pAS_Info->f_in;\n\twhile (center <\n\t       pAS_Info->f_if1_Center + pAS_Info->f_if1_bw / 2 +\n\t       pAS_Info->f_LO1_FracN_Avoid) {\n\t\t \n\t\tMT2063_AddExclZone(pAS_Info,\n\t\t\t\t   center - pAS_Info->f_LO1_FracN_Avoid,\n\t\t\t\t   center - 1);\n\t\tMT2063_AddExclZone(pAS_Info, center + 1,\n\t\t\t\t   center + pAS_Info->f_LO1_FracN_Avoid);\n\t\tcenter += pAS_Info->f_ref;\n\t}\n\n\tcenter =\n\t    pAS_Info->f_ref *\n\t    ((pAS_Info->f_if1_Center - pAS_Info->f_if1_bw / 2 -\n\t      pAS_Info->f_out) / pAS_Info->f_ref) + pAS_Info->f_out;\n\twhile (center <\n\t       pAS_Info->f_if1_Center + pAS_Info->f_if1_bw / 2 +\n\t       pAS_Info->f_LO2_FracN_Avoid) {\n\t\t \n\t\tMT2063_AddExclZone(pAS_Info,\n\t\t\t\t   center - pAS_Info->f_LO2_FracN_Avoid,\n\t\t\t\t   center - 1);\n\t\tMT2063_AddExclZone(pAS_Info, center + 1,\n\t\t\t\t   center + pAS_Info->f_LO2_FracN_Avoid);\n\t\tcenter += pAS_Info->f_ref;\n\t}\n\n\tif (MT2063_EXCLUDE_US_DECT_FREQUENCIES(pAS_Info->avoidDECT)) {\n\t\t \n\t\tMT2063_AddExclZone(pAS_Info, 1920836000 - pAS_Info->f_in, 1922236000 - pAS_Info->f_in);\t \n\t\tMT2063_AddExclZone(pAS_Info, 1922564000 - pAS_Info->f_in, 1923964000 - pAS_Info->f_in);\t \n\t\tMT2063_AddExclZone(pAS_Info, 1924292000 - pAS_Info->f_in, 1925692000 - pAS_Info->f_in);\t \n\t\tMT2063_AddExclZone(pAS_Info, 1926020000 - pAS_Info->f_in, 1927420000 - pAS_Info->f_in);\t \n\t\tMT2063_AddExclZone(pAS_Info, 1927748000 - pAS_Info->f_in, 1929148000 - pAS_Info->f_in);\t \n\t}\n\n\tif (MT2063_EXCLUDE_EURO_DECT_FREQUENCIES(pAS_Info->avoidDECT)) {\n\t\tMT2063_AddExclZone(pAS_Info, 1896644000 - pAS_Info->f_in, 1898044000 - pAS_Info->f_in);\t \n\t\tMT2063_AddExclZone(pAS_Info, 1894916000 - pAS_Info->f_in, 1896316000 - pAS_Info->f_in);\t \n\t\tMT2063_AddExclZone(pAS_Info, 1893188000 - pAS_Info->f_in, 1894588000 - pAS_Info->f_in);\t \n\t\tMT2063_AddExclZone(pAS_Info, 1891460000 - pAS_Info->f_in, 1892860000 - pAS_Info->f_in);\t \n\t\tMT2063_AddExclZone(pAS_Info, 1889732000 - pAS_Info->f_in, 1891132000 - pAS_Info->f_in);\t \n\t\tMT2063_AddExclZone(pAS_Info, 1888004000 - pAS_Info->f_in, 1889404000 - pAS_Info->f_in);\t \n\t\tMT2063_AddExclZone(pAS_Info, 1886276000 - pAS_Info->f_in, 1887676000 - pAS_Info->f_in);\t \n\t\tMT2063_AddExclZone(pAS_Info, 1884548000 - pAS_Info->f_in, 1885948000 - pAS_Info->f_in);\t \n\t\tMT2063_AddExclZone(pAS_Info, 1882820000 - pAS_Info->f_in, 1884220000 - pAS_Info->f_in);\t \n\t\tMT2063_AddExclZone(pAS_Info, 1881092000 - pAS_Info->f_in, 1882492000 - pAS_Info->f_in);\t \n\t}\n}\n\n \nstatic u32 MT2063_ChooseFirstIF(struct MT2063_AvoidSpursData_t *pAS_Info)\n{\n\t \n\tconst u32 f_Desired =\n\t    pAS_Info->f_LO1_Step *\n\t    ((pAS_Info->f_if1_Request + pAS_Info->f_in +\n\t      pAS_Info->f_LO1_Step / 2) / pAS_Info->f_LO1_Step) -\n\t    pAS_Info->f_in;\n\tconst u32 f_Step =\n\t    (pAS_Info->f_LO1_Step >\n\t     pAS_Info->f_LO2_Step) ? pAS_Info->f_LO1_Step : pAS_Info->\n\t    f_LO2_Step;\n\tu32 f_Center;\n\ts32 i;\n\ts32 j = 0;\n\tu32 bDesiredExcluded = 0;\n\tu32 bZeroExcluded = 0;\n\ts32 tmpMin, tmpMax;\n\ts32 bestDiff;\n\tstruct MT2063_ExclZone_t *pNode = pAS_Info->usedZones;\n\tstruct MT2063_FIFZone_t zones[MT2063_MAX_ZONES];\n\n\tdprintk(2, \"\\n\");\n\n\tif (pAS_Info->nZones == 0)\n\t\treturn f_Desired;\n\n\t \n\tif (pAS_Info->f_if1_Center > f_Desired)\n\t\tf_Center =\n\t\t    f_Desired +\n\t\t    f_Step *\n\t\t    ((pAS_Info->f_if1_Center - f_Desired +\n\t\t      f_Step / 2) / f_Step);\n\telse\n\t\tf_Center =\n\t\t    f_Desired -\n\t\t    f_Step *\n\t\t    ((f_Desired - pAS_Info->f_if1_Center +\n\t\t      f_Step / 2) / f_Step);\n\n\t \n\twhile (pNode != NULL) {\n\t\t \n\t\ttmpMin =\n\t\t    floor((s32) (pNode->min_ - f_Center), (s32) f_Step);\n\n\t\t \n\t\ttmpMax =\n\t\t    ceil((s32) (pNode->max_ - f_Center), (s32) f_Step);\n\n\t\tif ((pNode->min_ < f_Desired) && (pNode->max_ > f_Desired))\n\t\t\tbDesiredExcluded = 1;\n\n\t\tif ((tmpMin < 0) && (tmpMax > 0))\n\t\t\tbZeroExcluded = 1;\n\n\t\t \n\t\tif ((j > 0) && (tmpMin < zones[j - 1].max_))\n\t\t\tzones[j - 1].max_ = tmpMax;\n\t\telse {\n\t\t\t \n\t\t\tzones[j].min_ = tmpMin;\n\t\t\tzones[j].max_ = tmpMax;\n\t\t\tj++;\n\t\t}\n\t\tpNode = pNode->next_;\n\t}\n\n\t \n\tif (bDesiredExcluded == 0)\n\t\treturn f_Desired;\n\n\t \n\tif (bZeroExcluded == 0)\n\t\treturn f_Center;\n\n\t \n\tbestDiff = zones[0].min_;\n\tfor (i = 0; i < j; i++) {\n\t\tif (abs(zones[i].min_) < abs(bestDiff))\n\t\t\tbestDiff = zones[i].min_;\n\t\tif (abs(zones[i].max_) < abs(bestDiff))\n\t\t\tbestDiff = zones[i].max_;\n\t}\n\n\tif (bestDiff < 0)\n\t\treturn f_Center - ((u32) (-bestDiff) * f_Step);\n\n\treturn f_Center + (bestDiff * f_Step);\n}\n\n \nstatic u32 IsSpurInBand(struct MT2063_AvoidSpursData_t *pAS_Info,\n\t\t\tu32 *fm, u32 * fp)\n{\n\t \n\tu32 n, n0;\n\tconst u32 f_LO1 = pAS_Info->f_LO1;\n\tconst u32 f_LO2 = pAS_Info->f_LO2;\n\tconst u32 d = pAS_Info->f_out + pAS_Info->f_out_bw / 2;\n\tconst u32 c = d - pAS_Info->f_out_bw;\n\tconst u32 f = pAS_Info->f_zif_bw / 2;\n\tconst u32 f_Scale = (f_LO1 / (UINT_MAX / 2 / pAS_Info->maxH1)) + 1;\n\ts32 f_nsLO1, f_nsLO2;\n\ts32 f_Spur;\n\tu32 ma, mb, mc, md, me, mf;\n\tu32 lo_gcd, gd_Scale, gc_Scale, gf_Scale, hgds, hgfs, hgcs;\n\n\tdprintk(2, \"\\n\");\n\n\t*fm = 0;\n\n\t \n\tlo_gcd = gcd(f_LO1, f_LO2);\n\tgd_Scale = max((u32) gcd(lo_gcd, d), f_Scale);\n\thgds = gd_Scale / 2;\n\tgc_Scale = max((u32) gcd(lo_gcd, c), f_Scale);\n\thgcs = gc_Scale / 2;\n\tgf_Scale = max((u32) gcd(lo_gcd, f), f_Scale);\n\thgfs = gf_Scale / 2;\n\n\tn0 = DIV_ROUND_UP(f_LO2 - d, f_LO1 - f_LO2);\n\n\t \n\tfor (n = n0; n <= pAS_Info->maxH1; ++n) {\n\t\tmd = (n * ((f_LO1 + hgds) / gd_Scale) -\n\t\t      ((d + hgds) / gd_Scale)) / ((f_LO2 + hgds) / gd_Scale);\n\n\t\t \n\t\tif (md >= pAS_Info->maxH1)\n\t\t\tbreak;\n\n\t\tma = (n * ((f_LO1 + hgds) / gd_Scale) +\n\t\t      ((d + hgds) / gd_Scale)) / ((f_LO2 + hgds) / gd_Scale);\n\n\t\t \n\t\tif (md == ma)\n\t\t\tcontinue;\n\n\t\tmc = (n * ((f_LO1 + hgcs) / gc_Scale) -\n\t\t      ((c + hgcs) / gc_Scale)) / ((f_LO2 + hgcs) / gc_Scale);\n\t\tif (mc != md) {\n\t\t\tf_nsLO1 = (s32) (n * (f_LO1 / gc_Scale));\n\t\t\tf_nsLO2 = (s32) (mc * (f_LO2 / gc_Scale));\n\t\t\tf_Spur =\n\t\t\t    (gc_Scale * (f_nsLO1 - f_nsLO2)) +\n\t\t\t    n * (f_LO1 % gc_Scale) - mc * (f_LO2 % gc_Scale);\n\n\t\t\t*fp = ((f_Spur - (s32) c) / (mc - n)) + 1;\n\t\t\t*fm = (((s32) d - f_Spur) / (mc - n)) + 1;\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tme = (n * ((f_LO1 + hgfs) / gf_Scale) +\n\t\t      ((f + hgfs) / gf_Scale)) / ((f_LO2 + hgfs) / gf_Scale);\n\t\tmf = (n * ((f_LO1 + hgfs) / gf_Scale) -\n\t\t      ((f + hgfs) / gf_Scale)) / ((f_LO2 + hgfs) / gf_Scale);\n\t\tif (me != mf) {\n\t\t\tf_nsLO1 = n * (f_LO1 / gf_Scale);\n\t\t\tf_nsLO2 = me * (f_LO2 / gf_Scale);\n\t\t\tf_Spur =\n\t\t\t    (gf_Scale * (f_nsLO1 - f_nsLO2)) +\n\t\t\t    n * (f_LO1 % gf_Scale) - me * (f_LO2 % gf_Scale);\n\n\t\t\t*fp = ((f_Spur + (s32) f) / (me - n)) + 1;\n\t\t\t*fm = (((s32) f - f_Spur) / (me - n)) + 1;\n\t\t\treturn 1;\n\t\t}\n\n\t\tmb = (n * ((f_LO1 + hgcs) / gc_Scale) +\n\t\t      ((c + hgcs) / gc_Scale)) / ((f_LO2 + hgcs) / gc_Scale);\n\t\tif (ma != mb) {\n\t\t\tf_nsLO1 = n * (f_LO1 / gc_Scale);\n\t\t\tf_nsLO2 = ma * (f_LO2 / gc_Scale);\n\t\t\tf_Spur =\n\t\t\t    (gc_Scale * (f_nsLO1 - f_nsLO2)) +\n\t\t\t    n * (f_LO1 % gc_Scale) - ma * (f_LO2 % gc_Scale);\n\n\t\t\t*fp = (((s32) d + f_Spur) / (ma - n)) + 1;\n\t\t\t*fm = (-(f_Spur + (s32) c) / (ma - n)) + 1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t \n\treturn 0;\n}\n\n \nstatic u32 MT2063_AvoidSpurs(struct MT2063_AvoidSpursData_t *pAS_Info)\n{\n\tint status = 0;\n\tu32 fm, fp;\t\t \n\tpAS_Info->bSpurAvoided = 0;\n\tpAS_Info->nSpursFound = 0;\n\n\tdprintk(2, \"\\n\");\n\n\tif (pAS_Info->maxH1 == 0)\n\t\treturn 0;\n\n\t \n\tpAS_Info->bSpurPresent = IsSpurInBand(pAS_Info, &fm, &fp);\n\tif (pAS_Info->bSpurPresent) {\n\t\tu32 zfIF1 = pAS_Info->f_LO1 - pAS_Info->f_in;\t \n\t\tu32 zfLO1 = pAS_Info->f_LO1;\t \n\t\tu32 zfLO2 = pAS_Info->f_LO2;\t \n\t\tu32 delta_IF1;\n\t\tu32 new_IF1;\n\n\t\t \n\t\tdo {\n\t\t\tpAS_Info->nSpursFound++;\n\n\t\t\t \n\t\t\tMT2063_AddExclZone(pAS_Info, zfIF1 - fm, zfIF1 + fp);\n\n\t\t\t \n\t\t\tnew_IF1 = MT2063_ChooseFirstIF(pAS_Info);\n\n\t\t\tif (new_IF1 > zfIF1) {\n\t\t\t\tpAS_Info->f_LO1 += (new_IF1 - zfIF1);\n\t\t\t\tpAS_Info->f_LO2 += (new_IF1 - zfIF1);\n\t\t\t} else {\n\t\t\t\tpAS_Info->f_LO1 -= (zfIF1 - new_IF1);\n\t\t\t\tpAS_Info->f_LO2 -= (zfIF1 - new_IF1);\n\t\t\t}\n\t\t\tzfIF1 = new_IF1;\n\n\t\t\tif (zfIF1 > pAS_Info->f_if1_Center)\n\t\t\t\tdelta_IF1 = zfIF1 - pAS_Info->f_if1_Center;\n\t\t\telse\n\t\t\t\tdelta_IF1 = pAS_Info->f_if1_Center - zfIF1;\n\n\t\t\tpAS_Info->bSpurPresent = IsSpurInBand(pAS_Info, &fm, &fp);\n\t\t \n\t\t} while ((2 * delta_IF1 + pAS_Info->f_out_bw <= pAS_Info->f_if1_bw) && pAS_Info->bSpurPresent);\n\n\t\t \n\t\tif (pAS_Info->bSpurPresent == 1) {\n\t\t\tstatus |= MT2063_SPUR_PRESENT_ERR;\n\t\t\tpAS_Info->f_LO1 = zfLO1;\n\t\t\tpAS_Info->f_LO2 = zfLO2;\n\t\t} else\n\t\t\tpAS_Info->bSpurAvoided = 1;\n\t}\n\n\tstatus |=\n\t    ((pAS_Info->\n\t      nSpursFound << MT2063_SPUR_SHIFT) & MT2063_SPUR_CNT_MASK);\n\n\treturn status;\n}\n\n \n#define MT2063_REF_FREQ          (16000000UL)\t \n#define MT2063_IF1_BW            (22000000UL)\t \n#define MT2063_TUNE_STEP_SIZE       (50000UL)\t \n#define MT2063_SPUR_STEP_HZ        (250000UL)\t \n#define MT2063_ZIF_BW             (2000000UL)\t \n#define MT2063_MAX_HARMONICS_1         (15UL)\t \n#define MT2063_MAX_HARMONICS_2          (5UL)\t \n#define MT2063_MIN_LO_SEP         (1000000UL)\t \n#define MT2063_LO1_FRACN_AVOID          (0UL)\t \n#define MT2063_LO2_FRACN_AVOID     (199999UL)\t \n#define MT2063_MIN_FIN_FREQ      (44000000UL)\t \n#define MT2063_MAX_FIN_FREQ    (1100000000UL)\t \n#define MT2063_MIN_FOUT_FREQ     (36000000UL)\t \n#define MT2063_MAX_FOUT_FREQ     (57000000UL)\t \n#define MT2063_MIN_DNC_FREQ    (1293000000UL)\t \n#define MT2063_MAX_DNC_FREQ    (1614000000UL)\t \n#define MT2063_MIN_UPC_FREQ    (1396000000UL)\t \n#define MT2063_MAX_UPC_FREQ    (2750000000UL)\t \n\n \n#define MT2063_B0       (0x9B)\n#define MT2063_B1       (0x9C)\n#define MT2063_B2       (0x9D)\n#define MT2063_B3       (0x9E)\n\n \nstatic int mt2063_lockStatus(struct mt2063_state *state)\n{\n\tconst u32 nMaxWait = 100;\t \n\tconst u32 nPollRate = 2;\t \n\tconst u32 nMaxLoops = nMaxWait / nPollRate;\n\tconst u8 LO1LK = 0x80;\n\tu8 LO2LK = 0x08;\n\tint status;\n\tu32 nDelays = 0;\n\n\tdprintk(2, \"\\n\");\n\n\t \n\tif (state->tuner_id == MT2063_B0)\n\t\tLO2LK = 0x40;\n\n\tdo {\n\t\tstatus = mt2063_read(state, MT2063_REG_LO_STATUS,\n\t\t\t\t     &state->reg[MT2063_REG_LO_STATUS], 1);\n\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tif ((state->reg[MT2063_REG_LO_STATUS] & (LO1LK | LO2LK)) ==\n\t\t    (LO1LK | LO2LK)) {\n\t\t\treturn TUNER_STATUS_LOCKED | TUNER_STATUS_STEREO;\n\t\t}\n\t\tmsleep(nPollRate);\t \n\t} while (++nDelays < nMaxLoops);\n\n\t \n\treturn 0;\n}\n\n \n\nenum mt2063_delivery_sys {\n\tMT2063_CABLE_QAM = 0,\n\tMT2063_CABLE_ANALOG,\n\tMT2063_OFFAIR_COFDM,\n\tMT2063_OFFAIR_COFDM_SAWLESS,\n\tMT2063_OFFAIR_ANALOG,\n\tMT2063_OFFAIR_8VSB,\n\tMT2063_NUM_RCVR_MODES\n};\n\nstatic const char *mt2063_mode_name[] = {\n\t[MT2063_CABLE_QAM]\t\t= \"digital cable\",\n\t[MT2063_CABLE_ANALOG]\t\t= \"analog cable\",\n\t[MT2063_OFFAIR_COFDM]\t\t= \"digital offair\",\n\t[MT2063_OFFAIR_COFDM_SAWLESS]\t= \"digital offair without SAW\",\n\t[MT2063_OFFAIR_ANALOG]\t\t= \"analog offair\",\n\t[MT2063_OFFAIR_8VSB]\t\t= \"analog offair 8vsb\",\n};\n\nstatic const u8 RFAGCEN[]\t= {  0,  0,  0,  0,  0,  0 };\nstatic const u8 LNARIN[]\t= {  0,  0,  3,  3,  3,  3 };\nstatic const u8 FIFFQEN[]\t= {  1,  1,  1,  1,  1,  1 };\nstatic const u8 FIFFQ[]\t\t= {  0,  0,  0,  0,  0,  0 };\nstatic const u8 DNC1GC[]\t= {  0,  0,  0,  0,  0,  0 };\nstatic const u8 DNC2GC[]\t= {  0,  0,  0,  0,  0,  0 };\nstatic const u8 ACLNAMAX[]\t= { 31, 31, 31, 31, 31, 31 };\nstatic const u8 LNATGT[]\t= { 44, 43, 43, 43, 43, 43 };\nstatic const u8 RFOVDIS[]\t= {  0,  0,  0,  0,  0,  0 };\nstatic const u8 ACRFMAX[]\t= { 31, 31, 31, 31, 31, 31 };\nstatic const u8 PD1TGT[]\t= { 36, 36, 38, 38, 36, 38 };\nstatic const u8 FIFOVDIS[]\t= {  0,  0,  0,  0,  0,  0 };\nstatic const u8 ACFIFMAX[]\t= { 29, 29, 29, 29, 29, 29 };\nstatic const u8 PD2TGT[]\t= { 40, 33, 38, 42, 30, 38 };\n\n \nstatic u32 mt2063_get_dnc_output_enable(struct mt2063_state *state,\n\t\t\t\t\tenum MT2063_DNC_Output_Enable *pValue)\n{\n\tdprintk(2, \"\\n\");\n\n\tif ((state->reg[MT2063_REG_DNC_GAIN] & 0x03) == 0x03) {\t \n\t\tif ((state->reg[MT2063_REG_VGA_GAIN] & 0x03) == 0x03)\t \n\t\t\t*pValue = MT2063_DNC_NONE;\n\t\telse\n\t\t\t*pValue = MT2063_DNC_2;\n\t} else {\t \n\t\tif ((state->reg[MT2063_REG_VGA_GAIN] & 0x03) == 0x03)\t \n\t\t\t*pValue = MT2063_DNC_1;\n\t\telse\n\t\t\t*pValue = MT2063_DNC_BOTH;\n\t}\n\treturn 0;\n}\n\n \nstatic u32 mt2063_set_dnc_output_enable(struct mt2063_state *state,\n\t\t\t\t\tenum MT2063_DNC_Output_Enable nValue)\n{\n\tint status = 0;\t \n\tu8 val = 0;\n\n\tdprintk(2, \"\\n\");\n\n\t \n\tswitch (nValue) {\n\tcase MT2063_DNC_NONE:\n\t\tval = (state->reg[MT2063_REG_DNC_GAIN] & 0xFC) | 0x03;\t \n\t\tif (state->reg[MT2063_REG_DNC_GAIN] !=\n\t\t    val)\n\t\t\tstatus |=\n\t\t\t    mt2063_setreg(state,\n\t\t\t\t\t  MT2063_REG_DNC_GAIN,\n\t\t\t\t\t  val);\n\n\t\tval = (state->reg[MT2063_REG_VGA_GAIN] & 0xFC) | 0x03;\t \n\t\tif (state->reg[MT2063_REG_VGA_GAIN] !=\n\t\t    val)\n\t\t\tstatus |=\n\t\t\t    mt2063_setreg(state,\n\t\t\t\t\t  MT2063_REG_VGA_GAIN,\n\t\t\t\t\t  val);\n\n\t\tval = (state->reg[MT2063_REG_RSVD_20] & ~0x40);\t \n\t\tif (state->reg[MT2063_REG_RSVD_20] !=\n\t\t    val)\n\t\t\tstatus |=\n\t\t\t    mt2063_setreg(state,\n\t\t\t\t\t  MT2063_REG_RSVD_20,\n\t\t\t\t\t  val);\n\n\t\tbreak;\n\tcase MT2063_DNC_1:\n\t\tval = (state->reg[MT2063_REG_DNC_GAIN] & 0xFC) | (DNC1GC[state->rcvr_mode] & 0x03);\t \n\t\tif (state->reg[MT2063_REG_DNC_GAIN] !=\n\t\t    val)\n\t\t\tstatus |=\n\t\t\t    mt2063_setreg(state,\n\t\t\t\t\t  MT2063_REG_DNC_GAIN,\n\t\t\t\t\t  val);\n\n\t\tval = (state->reg[MT2063_REG_VGA_GAIN] & 0xFC) | 0x03;\t \n\t\tif (state->reg[MT2063_REG_VGA_GAIN] !=\n\t\t    val)\n\t\t\tstatus |=\n\t\t\t    mt2063_setreg(state,\n\t\t\t\t\t  MT2063_REG_VGA_GAIN,\n\t\t\t\t\t  val);\n\n\t\tval = (state->reg[MT2063_REG_RSVD_20] & ~0x40);\t \n\t\tif (state->reg[MT2063_REG_RSVD_20] !=\n\t\t    val)\n\t\t\tstatus |=\n\t\t\t    mt2063_setreg(state,\n\t\t\t\t\t  MT2063_REG_RSVD_20,\n\t\t\t\t\t  val);\n\n\t\tbreak;\n\tcase MT2063_DNC_2:\n\t\tval = (state->reg[MT2063_REG_DNC_GAIN] & 0xFC) | 0x03;\t \n\t\tif (state->reg[MT2063_REG_DNC_GAIN] !=\n\t\t    val)\n\t\t\tstatus |=\n\t\t\t    mt2063_setreg(state,\n\t\t\t\t\t  MT2063_REG_DNC_GAIN,\n\t\t\t\t\t  val);\n\n\t\tval = (state->reg[MT2063_REG_VGA_GAIN] & 0xFC) | (DNC2GC[state->rcvr_mode] & 0x03);\t \n\t\tif (state->reg[MT2063_REG_VGA_GAIN] !=\n\t\t    val)\n\t\t\tstatus |=\n\t\t\t    mt2063_setreg(state,\n\t\t\t\t\t  MT2063_REG_VGA_GAIN,\n\t\t\t\t\t  val);\n\n\t\tval = (state->reg[MT2063_REG_RSVD_20] | 0x40);\t \n\t\tif (state->reg[MT2063_REG_RSVD_20] !=\n\t\t    val)\n\t\t\tstatus |=\n\t\t\t    mt2063_setreg(state,\n\t\t\t\t\t  MT2063_REG_RSVD_20,\n\t\t\t\t\t  val);\n\n\t\tbreak;\n\tcase MT2063_DNC_BOTH:\n\t\tval = (state->reg[MT2063_REG_DNC_GAIN] & 0xFC) | (DNC1GC[state->rcvr_mode] & 0x03);\t \n\t\tif (state->reg[MT2063_REG_DNC_GAIN] !=\n\t\t    val)\n\t\t\tstatus |=\n\t\t\t    mt2063_setreg(state,\n\t\t\t\t\t  MT2063_REG_DNC_GAIN,\n\t\t\t\t\t  val);\n\n\t\tval = (state->reg[MT2063_REG_VGA_GAIN] & 0xFC) | (DNC2GC[state->rcvr_mode] & 0x03);\t \n\t\tif (state->reg[MT2063_REG_VGA_GAIN] !=\n\t\t    val)\n\t\t\tstatus |=\n\t\t\t    mt2063_setreg(state,\n\t\t\t\t\t  MT2063_REG_VGA_GAIN,\n\t\t\t\t\t  val);\n\n\t\tval = (state->reg[MT2063_REG_RSVD_20] | 0x40);\t \n\t\tif (state->reg[MT2063_REG_RSVD_20] !=\n\t\t    val)\n\t\t\tstatus |=\n\t\t\t    mt2063_setreg(state,\n\t\t\t\t\t  MT2063_REG_RSVD_20,\n\t\t\t\t\t  val);\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\n \n\nstatic u32 MT2063_SetReceiverMode(struct mt2063_state *state,\n\t\t\t\t  enum mt2063_delivery_sys Mode)\n{\n\tint status = 0;\t \n\tu8 val;\n\tu32 longval;\n\n\tdprintk(2, \"\\n\");\n\n\tif (Mode >= MT2063_NUM_RCVR_MODES)\n\t\tstatus = -ERANGE;\n\n\t \n\tif (status >= 0) {\n\t\tval =\n\t\t    (state->\n\t\t     reg[MT2063_REG_PD1_TGT] & ~0x40) | (RFAGCEN[Mode]\n\t\t\t\t\t\t\t\t   ? 0x40 :\n\t\t\t\t\t\t\t\t   0x00);\n\t\tif (state->reg[MT2063_REG_PD1_TGT] != val)\n\t\t\tstatus |= mt2063_setreg(state, MT2063_REG_PD1_TGT, val);\n\t}\n\n\t \n\tif (status >= 0) {\n\t\tu8 val = (state->reg[MT2063_REG_CTRL_2C] & ~0x03) |\n\t\t\t (LNARIN[Mode] & 0x03);\n\t\tif (state->reg[MT2063_REG_CTRL_2C] != val)\n\t\t\tstatus |= mt2063_setreg(state, MT2063_REG_CTRL_2C, val);\n\t}\n\n\t \n\tif (status >= 0) {\n\t\tval =\n\t\t    (state->\n\t\t     reg[MT2063_REG_FIFF_CTRL2] & ~0xF0) |\n\t\t    (FIFFQEN[Mode] << 7) | (FIFFQ[Mode] << 4);\n\t\tif (state->reg[MT2063_REG_FIFF_CTRL2] != val) {\n\t\t\tstatus |=\n\t\t\t    mt2063_setreg(state, MT2063_REG_FIFF_CTRL2, val);\n\t\t\t \n\t\t\tval =\n\t\t\t    (state->reg[MT2063_REG_FIFF_CTRL] | 0x01);\n\t\t\tstatus |=\n\t\t\t    mt2063_setreg(state, MT2063_REG_FIFF_CTRL, val);\n\t\t\tval =\n\t\t\t    (state->\n\t\t\t     reg[MT2063_REG_FIFF_CTRL] & ~0x01);\n\t\t\tstatus |=\n\t\t\t    mt2063_setreg(state, MT2063_REG_FIFF_CTRL, val);\n\t\t}\n\t}\n\n\t \n\tstatus |= mt2063_get_dnc_output_enable(state, &longval);\n\tstatus |= mt2063_set_dnc_output_enable(state, longval);\n\n\t \n\tif (status >= 0) {\n\t\tu8 val = (state->reg[MT2063_REG_LNA_OV] & ~0x1F) |\n\t\t\t (ACLNAMAX[Mode] & 0x1F);\n\t\tif (state->reg[MT2063_REG_LNA_OV] != val)\n\t\t\tstatus |= mt2063_setreg(state, MT2063_REG_LNA_OV, val);\n\t}\n\n\t \n\tif (status >= 0) {\n\t\tu8 val = (state->reg[MT2063_REG_LNA_TGT] & ~0x3F) |\n\t\t\t (LNATGT[Mode] & 0x3F);\n\t\tif (state->reg[MT2063_REG_LNA_TGT] != val)\n\t\t\tstatus |= mt2063_setreg(state, MT2063_REG_LNA_TGT, val);\n\t}\n\n\t \n\tif (status >= 0) {\n\t\tu8 val = (state->reg[MT2063_REG_RF_OV] & ~0x1F) |\n\t\t\t (ACRFMAX[Mode] & 0x1F);\n\t\tif (state->reg[MT2063_REG_RF_OV] != val)\n\t\t\tstatus |= mt2063_setreg(state, MT2063_REG_RF_OV, val);\n\t}\n\n\t \n\tif (status >= 0) {\n\t\tu8 val = (state->reg[MT2063_REG_PD1_TGT] & ~0x3F) |\n\t\t\t (PD1TGT[Mode] & 0x3F);\n\t\tif (state->reg[MT2063_REG_PD1_TGT] != val)\n\t\t\tstatus |= mt2063_setreg(state, MT2063_REG_PD1_TGT, val);\n\t}\n\n\t \n\tif (status >= 0) {\n\t\tu8 val = ACFIFMAX[Mode];\n\t\tif (state->reg[MT2063_REG_PART_REV] != MT2063_B3 && val > 5)\n\t\t\tval = 5;\n\t\tval = (state->reg[MT2063_REG_FIF_OV] & ~0x1F) |\n\t\t      (val & 0x1F);\n\t\tif (state->reg[MT2063_REG_FIF_OV] != val)\n\t\t\tstatus |= mt2063_setreg(state, MT2063_REG_FIF_OV, val);\n\t}\n\n\t \n\tif (status >= 0) {\n\t\tu8 val = (state->reg[MT2063_REG_PD2_TGT] & ~0x3F) |\n\t\t    (PD2TGT[Mode] & 0x3F);\n\t\tif (state->reg[MT2063_REG_PD2_TGT] != val)\n\t\t\tstatus |= mt2063_setreg(state, MT2063_REG_PD2_TGT, val);\n\t}\n\n\t \n\tif (status >= 0) {\n\t\tval = (state->reg[MT2063_REG_LNA_TGT] & ~0x80) |\n\t\t      (RFOVDIS[Mode] ? 0x80 : 0x00);\n\t\tif (state->reg[MT2063_REG_LNA_TGT] != val)\n\t\t\tstatus |= mt2063_setreg(state, MT2063_REG_LNA_TGT, val);\n\t}\n\n\t \n\tif (status >= 0) {\n\t\tval = (state->reg[MT2063_REG_PD1_TGT] & ~0x80) |\n\t\t      (FIFOVDIS[Mode] ? 0x80 : 0x00);\n\t\tif (state->reg[MT2063_REG_PD1_TGT] != val)\n\t\t\tstatus |= mt2063_setreg(state, MT2063_REG_PD1_TGT, val);\n\t}\n\n\tif (status >= 0) {\n\t\tstate->rcvr_mode = Mode;\n\t\tdprintk(1, \"mt2063 mode changed to %s\\n\",\n\t\t\tmt2063_mode_name[state->rcvr_mode]);\n\t}\n\n\treturn status;\n}\n\n \nstatic u32 MT2063_ClearPowerMaskBits(struct mt2063_state *state,\n\t\t\t\t     enum MT2063_Mask_Bits Bits)\n{\n\tint status = 0;\n\n\tdprintk(2, \"\\n\");\n\tBits = (enum MT2063_Mask_Bits)(Bits & MT2063_ALL_SD);\t \n\tif ((Bits & 0xFF00) != 0) {\n\t\tstate->reg[MT2063_REG_PWR_2] &= ~(u8) (Bits >> 8);\n\t\tstatus |=\n\t\t    mt2063_write(state,\n\t\t\t\t    MT2063_REG_PWR_2,\n\t\t\t\t    &state->reg[MT2063_REG_PWR_2], 1);\n\t}\n\tif ((Bits & 0xFF) != 0) {\n\t\tstate->reg[MT2063_REG_PWR_1] &= ~(u8) (Bits & 0xFF);\n\t\tstatus |=\n\t\t    mt2063_write(state,\n\t\t\t\t    MT2063_REG_PWR_1,\n\t\t\t\t    &state->reg[MT2063_REG_PWR_1], 1);\n\t}\n\n\treturn status;\n}\n\n \nstatic u32 MT2063_SoftwareShutdown(struct mt2063_state *state, u8 Shutdown)\n{\n\tint status;\n\n\tdprintk(2, \"\\n\");\n\tif (Shutdown == 1)\n\t\tstate->reg[MT2063_REG_PWR_1] |= 0x04;\n\telse\n\t\tstate->reg[MT2063_REG_PWR_1] &= ~0x04;\n\n\tstatus = mt2063_write(state,\n\t\t\t    MT2063_REG_PWR_1,\n\t\t\t    &state->reg[MT2063_REG_PWR_1], 1);\n\n\tif (Shutdown != 1) {\n\t\tstate->reg[MT2063_REG_BYP_CTRL] =\n\t\t    (state->reg[MT2063_REG_BYP_CTRL] & 0x9F) | 0x40;\n\t\tstatus |=\n\t\t    mt2063_write(state,\n\t\t\t\t    MT2063_REG_BYP_CTRL,\n\t\t\t\t    &state->reg[MT2063_REG_BYP_CTRL],\n\t\t\t\t    1);\n\t\tstate->reg[MT2063_REG_BYP_CTRL] =\n\t\t    (state->reg[MT2063_REG_BYP_CTRL] & 0x9F);\n\t\tstatus |=\n\t\t    mt2063_write(state,\n\t\t\t\t    MT2063_REG_BYP_CTRL,\n\t\t\t\t    &state->reg[MT2063_REG_BYP_CTRL],\n\t\t\t\t    1);\n\t}\n\n\treturn status;\n}\n\nstatic u32 MT2063_Round_fLO(u32 f_LO, u32 f_LO_Step, u32 f_ref)\n{\n\treturn f_ref * (f_LO / f_ref)\n\t    + f_LO_Step * (((f_LO % f_ref) + (f_LO_Step / 2)) / f_LO_Step);\n}\n\n \nstatic u32 MT2063_fLO_FractionalTerm(u32 f_ref, u32 num, u32 denom)\n{\n\tu32 t1 = (f_ref >> 14) * num;\n\tu32 term1 = t1 / denom;\n\tu32 loss = t1 % denom;\n\tu32 term2 =\n\t    (((f_ref & 0x00003FFF) * num + (loss << 14)) + (denom / 2)) / denom;\n\treturn (term1 << 14) + term2;\n}\n\n \nstatic u32 MT2063_CalcLO1Mult(u32 *Div,\n\t\t\t      u32 *FracN,\n\t\t\t      u32 f_LO,\n\t\t\t      u32 f_LO_Step, u32 f_Ref)\n{\n\t \n\t*Div = f_LO / f_Ref;\n\n\t \n\t*FracN =\n\t    (64 * (((f_LO % f_Ref) + (f_LO_Step / 2)) / f_LO_Step) +\n\t     (f_Ref / f_LO_Step / 2)) / (f_Ref / f_LO_Step);\n\n\treturn (f_Ref * (*Div)) + MT2063_fLO_FractionalTerm(f_Ref, *FracN, 64);\n}\n\n \nstatic u32 MT2063_CalcLO2Mult(u32 *Div,\n\t\t\t      u32 *FracN,\n\t\t\t      u32 f_LO,\n\t\t\t      u32 f_LO_Step, u32 f_Ref)\n{\n\t \n\t*Div = f_LO / f_Ref;\n\n\t \n\t*FracN =\n\t    (8191 * (((f_LO % f_Ref) + (f_LO_Step / 2)) / f_LO_Step) +\n\t     (f_Ref / f_LO_Step / 2)) / (f_Ref / f_LO_Step);\n\n\treturn (f_Ref * (*Div)) + MT2063_fLO_FractionalTerm(f_Ref, *FracN,\n\t\t\t\t\t\t\t    8191);\n}\n\n \nstatic u32 FindClearTuneFilter(struct mt2063_state *state, u32 f_in)\n{\n\tu32 RFBand;\n\tu32 idx;\t\t \n\n\t \n\tRFBand = 31;\t\t \n\tfor (idx = 0; idx < 31; ++idx) {\n\t\tif (state->CTFiltMax[idx] >= f_in) {\n\t\t\tRFBand = idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn RFBand;\n}\n\n \nstatic u32 MT2063_Tune(struct mt2063_state *state, u32 f_in)\n{\t\t\t\t \n\n\tint status = 0;\n\tu32 LO1;\t\t \n\tu32 Num1;\t\t \n\tu32 f_IF1;\t\t \n\tu32 LO2;\t\t \n\tu32 Num2;\t\t \n\tu32 ofLO1, ofLO2;\t \n\tu8 fiffc = 0x80;\t \n\tu32 fiffof;\t\t \n\tconst u8 LO1LK = 0x80;\t \n\tu8 LO2LK = 0x08;\t \n\tu8 val;\n\tu32 RFBand;\n\n\tdprintk(2, \"\\n\");\n\t \n\tif ((f_in < MT2063_MIN_FIN_FREQ) || (f_in > MT2063_MAX_FIN_FREQ))\n\t\treturn -EINVAL;\n\n\tif ((state->AS_Data.f_out < MT2063_MIN_FOUT_FREQ)\n\t    || (state->AS_Data.f_out > MT2063_MAX_FOUT_FREQ))\n\t\treturn -EINVAL;\n\n\t \n\tofLO1 = state->AS_Data.f_LO1;\n\tofLO2 = state->AS_Data.f_LO2;\n\n\t \n\tif (state->ctfilt_sw == 1) {\n\t\tval = (state->reg[MT2063_REG_CTUNE_CTRL] | 0x08);\n\t\tif (state->reg[MT2063_REG_CTUNE_CTRL] != val) {\n\t\t\tstatus |=\n\t\t\t    mt2063_setreg(state, MT2063_REG_CTUNE_CTRL, val);\n\t\t}\n\t\tval = state->reg[MT2063_REG_CTUNE_OV];\n\t\tRFBand = FindClearTuneFilter(state, f_in);\n\t\tstate->reg[MT2063_REG_CTUNE_OV] =\n\t\t    (u8) ((state->reg[MT2063_REG_CTUNE_OV] & ~0x1F)\n\t\t\t      | RFBand);\n\t\tif (state->reg[MT2063_REG_CTUNE_OV] != val) {\n\t\t\tstatus |=\n\t\t\t    mt2063_setreg(state, MT2063_REG_CTUNE_OV, val);\n\t\t}\n\t}\n\n\t \n\tif (status >= 0) {\n\t\tstatus |=\n\t\t    mt2063_read(state,\n\t\t\t\t   MT2063_REG_FIFFC,\n\t\t\t\t   &state->reg[MT2063_REG_FIFFC], 1);\n\t\tfiffc = state->reg[MT2063_REG_FIFFC];\n\t}\n\t \n\tstate->AS_Data.f_in = f_in;\n\t \n\tstate->AS_Data.f_if1_Request =\n\t    MT2063_Round_fLO(state->AS_Data.f_if1_Request + f_in,\n\t\t\t     state->AS_Data.f_LO1_Step,\n\t\t\t     state->AS_Data.f_ref) - f_in;\n\n\t \n\tMT2063_ResetExclZones(&state->AS_Data);\n\n\tf_IF1 = MT2063_ChooseFirstIF(&state->AS_Data);\n\n\tstate->AS_Data.f_LO1 =\n\t    MT2063_Round_fLO(f_IF1 + f_in, state->AS_Data.f_LO1_Step,\n\t\t\t     state->AS_Data.f_ref);\n\n\tstate->AS_Data.f_LO2 =\n\t    MT2063_Round_fLO(state->AS_Data.f_LO1 - state->AS_Data.f_out - f_in,\n\t\t\t     state->AS_Data.f_LO2_Step, state->AS_Data.f_ref);\n\n\t \n\tstatus |= MT2063_AvoidSpurs(&state->AS_Data);\n\t \n\tstate->AS_Data.f_LO1 =\n\t    MT2063_CalcLO1Mult(&LO1, &Num1, state->AS_Data.f_LO1,\n\t\t\t       state->AS_Data.f_LO1_Step, state->AS_Data.f_ref);\n\tstate->AS_Data.f_LO2 =\n\t    MT2063_Round_fLO(state->AS_Data.f_LO1 - state->AS_Data.f_out - f_in,\n\t\t\t     state->AS_Data.f_LO2_Step, state->AS_Data.f_ref);\n\tstate->AS_Data.f_LO2 =\n\t    MT2063_CalcLO2Mult(&LO2, &Num2, state->AS_Data.f_LO2,\n\t\t\t       state->AS_Data.f_LO2_Step, state->AS_Data.f_ref);\n\n\t \n\tif ((state->AS_Data.f_LO1 < MT2063_MIN_UPC_FREQ)\n\t    || (state->AS_Data.f_LO1 > MT2063_MAX_UPC_FREQ))\n\t\tstatus |= MT2063_UPC_RANGE;\n\tif ((state->AS_Data.f_LO2 < MT2063_MIN_DNC_FREQ)\n\t    || (state->AS_Data.f_LO2 > MT2063_MAX_DNC_FREQ))\n\t\tstatus |= MT2063_DNC_RANGE;\n\t \n\tif (state->tuner_id == MT2063_B0)\n\t\tLO2LK = 0x40;\n\n\t \n\tif ((ofLO1 != state->AS_Data.f_LO1)\n\t    || (ofLO2 != state->AS_Data.f_LO2)\n\t    || ((state->reg[MT2063_REG_LO_STATUS] & (LO1LK | LO2LK)) !=\n\t\t(LO1LK | LO2LK))) {\n\t\t \n\t\tfiffof =\n\t\t    (state->AS_Data.f_LO1 -\n\t\t     f_in) / (state->AS_Data.f_ref / 64) - 8 * (u32) fiffc -\n\t\t    4992;\n\t\tif (fiffof > 0xFF)\n\t\t\tfiffof = 0xFF;\n\n\t\t \n\t\tif (status >= 0) {\n\t\t\tstate->reg[MT2063_REG_LO1CQ_1] = (u8) (LO1 & 0xFF);\t \n\t\t\tstate->reg[MT2063_REG_LO1CQ_2] = (u8) (Num1 & 0x3F);\t \n\t\t\tstate->reg[MT2063_REG_LO2CQ_1] = (u8) (((LO2 & 0x7F) << 1)\t \n\t\t\t\t\t\t\t\t   |(Num2 >> 12));\t \n\t\t\tstate->reg[MT2063_REG_LO2CQ_2] = (u8) ((Num2 & 0x0FF0) >> 4);\t \n\t\t\tstate->reg[MT2063_REG_LO2CQ_3] = (u8) (0xE0 | (Num2 & 0x000F));\t \n\n\t\t\t \n\t\t\tstatus |= mt2063_write(state, MT2063_REG_LO1CQ_1, &state->reg[MT2063_REG_LO1CQ_1], 5);\t \n\t\t\tif (state->tuner_id == MT2063_B0) {\n\t\t\t\t \n\t\t\t\tstatus |= mt2063_write(state, MT2063_REG_LO2CQ_3, &state->reg[MT2063_REG_LO2CQ_3], 1);\t \n\t\t\t}\n\t\t\t \n\t\t\tif (state->reg[MT2063_REG_FIFF_OFFSET] !=\n\t\t\t    (u8) fiffof) {\n\t\t\t\tstate->reg[MT2063_REG_FIFF_OFFSET] =\n\t\t\t\t    (u8) fiffof;\n\t\t\t\tstatus |=\n\t\t\t\t    mt2063_write(state,\n\t\t\t\t\t\t    MT2063_REG_FIFF_OFFSET,\n\t\t\t\t\t\t    &state->\n\t\t\t\t\t\t    reg[MT2063_REG_FIFF_OFFSET],\n\t\t\t\t\t\t    1);\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tstatus = mt2063_lockStatus(state);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tif (!status)\n\t\t\treturn -EINVAL;\t\t \n\n\t\t \n\t\tstate->f_IF1_actual = state->AS_Data.f_LO1 - f_in;\n\t}\n\n\treturn status;\n}\n\nstatic const u8 MT2063B0_defaults[] = {\n\t \n\t0x19, 0x05,\n\t0x1B, 0x1D,\n\t0x1C, 0x1F,\n\t0x1D, 0x0F,\n\t0x1E, 0x3F,\n\t0x1F, 0x0F,\n\t0x20, 0x3F,\n\t0x22, 0x21,\n\t0x23, 0x3F,\n\t0x24, 0x20,\n\t0x25, 0x3F,\n\t0x27, 0xEE,\n\t0x2C, 0x27,\t \n\t0x30, 0x03,\n\t0x2C, 0x07,\t \n\t0x2D, 0x87,\n\t0x2E, 0xAA,\n\t0x28, 0xE1,\t \n\t0x28, 0xE0,\t \n\t0x00\n};\n\n \nstatic const u8 MT2063B1_defaults[] = {\n\t \n\t0x05, 0xF0,\n\t0x11, 0x10,\t \n\t0x19, 0x05,\n\t0x1A, 0x6C,\n\t0x1B, 0x24,\n\t0x1C, 0x28,\n\t0x1D, 0x8F,\n\t0x1E, 0x14,\n\t0x1F, 0x8F,\n\t0x20, 0x57,\n\t0x22, 0x21,\t \n\t0x23, 0x3C,\t \n\t0x24, 0x20,\t \n\t0x2C, 0x24,\t \n\t0x2D, 0x87,\t \n\t0x2F, 0xF3,\n\t0x30, 0x0C,\t \n\t0x31, 0x1B,\t \n\t0x2C, 0x04,\t \n\t0x28, 0xE1,\t \n\t0x28, 0xE0,\t \n\t0x00\n};\n\n \nstatic const u8 MT2063B3_defaults[] = {\n\t \n\t0x05, 0xF0,\n\t0x19, 0x3D,\n\t0x2C, 0x24,\t \n\t0x2C, 0x04,\t \n\t0x28, 0xE1,\t \n\t0x28, 0xE0,\t \n\t0x00\n};\n\nstatic int mt2063_init(struct dvb_frontend *fe)\n{\n\tint status;\n\tstruct mt2063_state *state = fe->tuner_priv;\n\tu8 all_resets = 0xF0;\t \n\tconst u8 *def = NULL;\n\tchar *step;\n\tu32 FCRUN;\n\ts32 maxReads;\n\tu32 fcu_osc;\n\tu32 i;\n\n\tdprintk(2, \"\\n\");\n\n\tstate->rcvr_mode = MT2063_CABLE_QAM;\n\n\t \n\tstatus = mt2063_read(state, MT2063_REG_PART_REV,\n\t\t\t     &state->reg[MT2063_REG_PART_REV], 1);\n\tif (status < 0) {\n\t\tprintk(KERN_ERR \"Can't read mt2063 part ID\\n\");\n\t\treturn status;\n\t}\n\n\t \n\tswitch (state->reg[MT2063_REG_PART_REV]) {\n\tcase MT2063_B0:\n\t\tstep = \"B0\";\n\t\tbreak;\n\tcase MT2063_B1:\n\t\tstep = \"B1\";\n\t\tbreak;\n\tcase MT2063_B2:\n\t\tstep = \"B2\";\n\t\tbreak;\n\tcase MT2063_B3:\n\t\tstep = \"B3\";\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"mt2063: Unknown mt2063 device ID (0x%02x)\\n\",\n\t\t       state->reg[MT2063_REG_PART_REV]);\n\t\treturn -ENODEV;\t \n\t}\n\n\t \n\tstatus = mt2063_read(state, MT2063_REG_RSVD_3B,\n\t\t\t     &state->reg[MT2063_REG_RSVD_3B], 1);\n\n\t \n\tif (status < 0 || ((state->reg[MT2063_REG_RSVD_3B] & 0x80) != 0x00)) {\n\t\tprintk(KERN_ERR \"mt2063: Unknown part ID (0x%02x%02x)\\n\",\n\t\t       state->reg[MT2063_REG_PART_REV],\n\t\t       state->reg[MT2063_REG_RSVD_3B]);\n\t\treturn -ENODEV;\t \n\t}\n\n\tprintk(KERN_INFO \"mt2063: detected a mt2063 %s\\n\", step);\n\n\t \n\tstatus = mt2063_write(state, MT2063_REG_LO2CQ_3, &all_resets, 1);\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\t \n\tswitch (state->reg[MT2063_REG_PART_REV]) {\n\tcase MT2063_B3:\n\t\tdef = MT2063B3_defaults;\n\t\tbreak;\n\n\tcase MT2063_B1:\n\t\tdef = MT2063B1_defaults;\n\t\tbreak;\n\n\tcase MT2063_B0:\n\t\tdef = MT2063B0_defaults;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\twhile (status >= 0 && *def) {\n\t\tu8 reg = *def++;\n\t\tu8 val = *def++;\n\t\tstatus = mt2063_write(state, reg, &val, 1);\n\t}\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\tFCRUN = 1;\n\tmaxReads = 10;\n\twhile (status >= 0 && (FCRUN != 0) && (maxReads-- > 0)) {\n\t\tmsleep(2);\n\t\tstatus = mt2063_read(state,\n\t\t\t\t\t MT2063_REG_XO_STATUS,\n\t\t\t\t\t &state->\n\t\t\t\t\t reg[MT2063_REG_XO_STATUS], 1);\n\t\tFCRUN = (state->reg[MT2063_REG_XO_STATUS] & 0x40) >> 6;\n\t}\n\n\tif (FCRUN != 0 || status < 0)\n\t\treturn -ENODEV;\n\n\tstatus = mt2063_read(state,\n\t\t\t   MT2063_REG_FIFFC,\n\t\t\t   &state->reg[MT2063_REG_FIFFC], 1);\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\tstatus = mt2063_read(state,\n\t\t\t\tMT2063_REG_PART_REV,\n\t\t\t\tstate->reg, MT2063_REG_END_REGS);\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\tstate->tuner_id = state->reg[MT2063_REG_PART_REV];\n\tstate->AS_Data.f_ref = MT2063_REF_FREQ;\n\tstate->AS_Data.f_if1_Center = (state->AS_Data.f_ref / 8) *\n\t\t\t\t      ((u32) state->reg[MT2063_REG_FIFFC] + 640);\n\tstate->AS_Data.f_if1_bw = MT2063_IF1_BW;\n\tstate->AS_Data.f_out = 43750000UL;\n\tstate->AS_Data.f_out_bw = 6750000UL;\n\tstate->AS_Data.f_zif_bw = MT2063_ZIF_BW;\n\tstate->AS_Data.f_LO1_Step = state->AS_Data.f_ref / 64;\n\tstate->AS_Data.f_LO2_Step = MT2063_TUNE_STEP_SIZE;\n\tstate->AS_Data.maxH1 = MT2063_MAX_HARMONICS_1;\n\tstate->AS_Data.maxH2 = MT2063_MAX_HARMONICS_2;\n\tstate->AS_Data.f_min_LO_Separation = MT2063_MIN_LO_SEP;\n\tstate->AS_Data.f_if1_Request = state->AS_Data.f_if1_Center;\n\tstate->AS_Data.f_LO1 = 2181000000UL;\n\tstate->AS_Data.f_LO2 = 1486249786UL;\n\tstate->f_IF1_actual = state->AS_Data.f_if1_Center;\n\tstate->AS_Data.f_in = state->AS_Data.f_LO1 - state->f_IF1_actual;\n\tstate->AS_Data.f_LO1_FracN_Avoid = MT2063_LO1_FRACN_AVOID;\n\tstate->AS_Data.f_LO2_FracN_Avoid = MT2063_LO2_FRACN_AVOID;\n\tstate->num_regs = MT2063_REG_END_REGS;\n\tstate->AS_Data.avoidDECT = MT2063_AVOID_BOTH;\n\tstate->ctfilt_sw = 0;\n\n\tstate->CTFiltMax[0] = 69230000;\n\tstate->CTFiltMax[1] = 105770000;\n\tstate->CTFiltMax[2] = 140350000;\n\tstate->CTFiltMax[3] = 177110000;\n\tstate->CTFiltMax[4] = 212860000;\n\tstate->CTFiltMax[5] = 241130000;\n\tstate->CTFiltMax[6] = 274370000;\n\tstate->CTFiltMax[7] = 309820000;\n\tstate->CTFiltMax[8] = 342450000;\n\tstate->CTFiltMax[9] = 378870000;\n\tstate->CTFiltMax[10] = 416210000;\n\tstate->CTFiltMax[11] = 456500000;\n\tstate->CTFiltMax[12] = 495790000;\n\tstate->CTFiltMax[13] = 534530000;\n\tstate->CTFiltMax[14] = 572610000;\n\tstate->CTFiltMax[15] = 598970000;\n\tstate->CTFiltMax[16] = 635910000;\n\tstate->CTFiltMax[17] = 672130000;\n\tstate->CTFiltMax[18] = 714840000;\n\tstate->CTFiltMax[19] = 739660000;\n\tstate->CTFiltMax[20] = 770410000;\n\tstate->CTFiltMax[21] = 814660000;\n\tstate->CTFiltMax[22] = 846950000;\n\tstate->CTFiltMax[23] = 867820000;\n\tstate->CTFiltMax[24] = 915980000;\n\tstate->CTFiltMax[25] = 947450000;\n\tstate->CTFiltMax[26] = 983110000;\n\tstate->CTFiltMax[27] = 1021630000;\n\tstate->CTFiltMax[28] = 1061870000;\n\tstate->CTFiltMax[29] = 1098330000;\n\tstate->CTFiltMax[30] = 1138990000;\n\n\t \n\n\tstate->reg[MT2063_REG_CTUNE_CTRL] = 0x0A;\n\tstatus = mt2063_write(state, MT2063_REG_CTUNE_CTRL,\n\t\t\t      &state->reg[MT2063_REG_CTUNE_CTRL], 1);\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\tstatus = mt2063_read(state, MT2063_REG_FIFFC,\n\t\t\t     &state->reg[MT2063_REG_FIFFC], 1);\n\tif (status < 0)\n\t\treturn status;\n\n\tfcu_osc = state->reg[MT2063_REG_FIFFC];\n\n\tstate->reg[MT2063_REG_CTUNE_CTRL] = 0x00;\n\tstatus = mt2063_write(state, MT2063_REG_CTUNE_CTRL,\n\t\t\t      &state->reg[MT2063_REG_CTUNE_CTRL], 1);\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\tfor (i = 0; i < 31; i++)\n\t\tstate->CTFiltMax[i] = (state->CTFiltMax[i] / 768) * (fcu_osc + 640);\n\n\tstatus = MT2063_SoftwareShutdown(state, 1);\n\tif (status < 0)\n\t\treturn status;\n\tstatus = MT2063_ClearPowerMaskBits(state, MT2063_ALL_SD);\n\tif (status < 0)\n\t\treturn status;\n\n\tstate->init = true;\n\n\treturn 0;\n}\n\nstatic int mt2063_get_status(struct dvb_frontend *fe, u32 *tuner_status)\n{\n\tstruct mt2063_state *state = fe->tuner_priv;\n\tint status;\n\n\tdprintk(2, \"\\n\");\n\n\tif (!state->init)\n\t\treturn -ENODEV;\n\n\t*tuner_status = 0;\n\tstatus = mt2063_lockStatus(state);\n\tif (status < 0)\n\t\treturn status;\n\tif (status)\n\t\t*tuner_status = TUNER_STATUS_LOCKED;\n\n\tdprintk(1, \"Tuner status: %d\", *tuner_status);\n\n\treturn 0;\n}\n\nstatic void mt2063_release(struct dvb_frontend *fe)\n{\n\tstruct mt2063_state *state = fe->tuner_priv;\n\n\tdprintk(2, \"\\n\");\n\n\tfe->tuner_priv = NULL;\n\tkfree(state);\n}\n\nstatic int mt2063_set_analog_params(struct dvb_frontend *fe,\n\t\t\t\t    struct analog_parameters *params)\n{\n\tstruct mt2063_state *state = fe->tuner_priv;\n\ts32 pict_car;\n\ts32 pict2chanb_vsb;\n\ts32 ch_bw;\n\ts32 if_mid;\n\ts32 rcvr_mode;\n\tint status;\n\n\tdprintk(2, \"\\n\");\n\n\tif (!state->init) {\n\t\tstatus = mt2063_init(fe);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\tswitch (params->mode) {\n\tcase V4L2_TUNER_RADIO:\n\t\tpict_car = 38900000;\n\t\tch_bw = 8000000;\n\t\tpict2chanb_vsb = -(ch_bw / 2);\n\t\trcvr_mode = MT2063_OFFAIR_ANALOG;\n\t\tbreak;\n\tcase V4L2_TUNER_ANALOG_TV:\n\t\trcvr_mode = MT2063_CABLE_ANALOG;\n\t\tif (params->std & ~V4L2_STD_MN) {\n\t\t\tpict_car = 38900000;\n\t\t\tch_bw = 6000000;\n\t\t\tpict2chanb_vsb = -1250000;\n\t\t} else if (params->std & V4L2_STD_PAL_G) {\n\t\t\tpict_car = 38900000;\n\t\t\tch_bw = 7000000;\n\t\t\tpict2chanb_vsb = -1250000;\n\t\t} else {\t\t \n\t\t\tpict_car = 38900000;\n\t\t\tch_bw = 8000000;\n\t\t\tpict2chanb_vsb = -1250000;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif_mid = pict_car - (pict2chanb_vsb + (ch_bw / 2));\n\n\tstate->AS_Data.f_LO2_Step = 125000;\t \n\tstate->AS_Data.f_out = if_mid;\n\tstate->AS_Data.f_out_bw = ch_bw + 750000;\n\tstatus = MT2063_SetReceiverMode(state, rcvr_mode);\n\tif (status < 0)\n\t\treturn status;\n\n\tdprintk(1, \"Tuning to frequency: %d, bandwidth %d, foffset %d\\n\",\n\t\tparams->frequency, ch_bw, pict2chanb_vsb);\n\n\tstatus = MT2063_Tune(state, (params->frequency + (pict2chanb_vsb + (ch_bw / 2))));\n\tif (status < 0)\n\t\treturn status;\n\n\tstate->frequency = params->frequency;\n\treturn 0;\n}\n\n \n#define MAX_SYMBOL_RATE_6MHz\t5217391\n\nstatic int mt2063_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct mt2063_state *state = fe->tuner_priv;\n\tint status;\n\ts32 pict_car;\n\ts32 pict2chanb_vsb;\n\ts32 ch_bw;\n\ts32 if_mid;\n\ts32 rcvr_mode;\n\n\tif (!state->init) {\n\t\tstatus = mt2063_init(fe);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\tdprintk(2, \"\\n\");\n\n\tif (c->bandwidth_hz == 0)\n\t\treturn -EINVAL;\n\tif (c->bandwidth_hz <= 6000000)\n\t\tch_bw = 6000000;\n\telse if (c->bandwidth_hz <= 7000000)\n\t\tch_bw = 7000000;\n\telse\n\t\tch_bw = 8000000;\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\t\trcvr_mode = MT2063_OFFAIR_COFDM;\n\t\tpict_car = 36125000;\n\t\tpict2chanb_vsb = -(ch_bw / 2);\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\tcase SYS_DVBC_ANNEX_C:\n\t\trcvr_mode = MT2063_CABLE_QAM;\n\t\tpict_car = 36125000;\n\t\tpict2chanb_vsb = -(ch_bw / 2);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif_mid = pict_car - (pict2chanb_vsb + (ch_bw / 2));\n\n\tstate->AS_Data.f_LO2_Step = 125000;\t \n\tstate->AS_Data.f_out = if_mid;\n\tstate->AS_Data.f_out_bw = ch_bw + 750000;\n\tstatus = MT2063_SetReceiverMode(state, rcvr_mode);\n\tif (status < 0)\n\t\treturn status;\n\n\tdprintk(1, \"Tuning to frequency: %d, bandwidth %d, foffset %d\\n\",\n\t\tc->frequency, ch_bw, pict2chanb_vsb);\n\n\tstatus = MT2063_Tune(state, (c->frequency + (pict2chanb_vsb + (ch_bw / 2))));\n\n\tif (status < 0)\n\t\treturn status;\n\n\tstate->frequency = c->frequency;\n\treturn 0;\n}\n\nstatic int mt2063_get_if_frequency(struct dvb_frontend *fe, u32 *freq)\n{\n\tstruct mt2063_state *state = fe->tuner_priv;\n\n\tdprintk(2, \"\\n\");\n\n\tif (!state->init)\n\t\treturn -ENODEV;\n\n\t*freq = state->AS_Data.f_out;\n\n\tdprintk(1, \"IF frequency: %d\\n\", *freq);\n\n\treturn 0;\n}\n\nstatic int mt2063_get_bandwidth(struct dvb_frontend *fe, u32 *bw)\n{\n\tstruct mt2063_state *state = fe->tuner_priv;\n\n\tdprintk(2, \"\\n\");\n\n\tif (!state->init)\n\t\treturn -ENODEV;\n\n\t*bw = state->AS_Data.f_out_bw - 750000;\n\n\tdprintk(1, \"bandwidth: %d\\n\", *bw);\n\n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops mt2063_ops = {\n\t.info = {\n\t\t .name = \"MT2063 Silicon Tuner\",\n\t\t .frequency_min_hz  =  45 * MHz,\n\t\t .frequency_max_hz  = 865 * MHz,\n\t },\n\n\t.init = mt2063_init,\n\t.sleep = MT2063_Sleep,\n\t.get_status = mt2063_get_status,\n\t.set_analog_params = mt2063_set_analog_params,\n\t.set_params    = mt2063_set_params,\n\t.get_if_frequency = mt2063_get_if_frequency,\n\t.get_bandwidth = mt2063_get_bandwidth,\n\t.release = mt2063_release,\n};\n\nstruct dvb_frontend *mt2063_attach(struct dvb_frontend *fe,\n\t\t\t\t   struct mt2063_config *config,\n\t\t\t\t   struct i2c_adapter *i2c)\n{\n\tstruct mt2063_state *state = NULL;\n\n\tdprintk(2, \"\\n\");\n\n\tstate = kzalloc(sizeof(struct mt2063_state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->frontend = fe;\n\tstate->reference = config->refclock / 1000;\t \n\tfe->tuner_priv = state;\n\tfe->ops.tuner_ops = mt2063_ops;\n\n\tprintk(KERN_INFO \"%s: Attaching MT2063\\n\", __func__);\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(mt2063_attach);\n\n#if 0\n \nstatic int tuner_MT2063_SoftwareShutdown(struct dvb_frontend *fe)\n{\n\tstruct mt2063_state *state = fe->tuner_priv;\n\tint err = 0;\n\n\tdprintk(2, \"\\n\");\n\n\terr = MT2063_SoftwareShutdown(state, 1);\n\tif (err < 0)\n\t\tprintk(KERN_ERR \"%s: Couldn't shutdown\\n\", __func__);\n\n\treturn err;\n}\n\nstatic int tuner_MT2063_ClearPowerMaskBits(struct dvb_frontend *fe)\n{\n\tstruct mt2063_state *state = fe->tuner_priv;\n\tint err = 0;\n\n\tdprintk(2, \"\\n\");\n\n\terr = MT2063_ClearPowerMaskBits(state, MT2063_ALL_SD);\n\tif (err < 0)\n\t\tprintk(KERN_ERR \"%s: Invalid parameter\\n\", __func__);\n\n\treturn err;\n}\n#endif\n\nMODULE_AUTHOR(\"Mauro Carvalho Chehab\");\nMODULE_DESCRIPTION(\"MT2063 Silicon tuner\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}