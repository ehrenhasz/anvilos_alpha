{
  "module_name": "af9015.c",
  "hash_id": "4496c06cac7c8293e6e661d1efcdafed6834abee82e44a529f6d6fd8abeb79ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/af9015.c",
  "human_readable_source": "\n \n\n#include \"af9015.h\"\n\nstatic int dvb_usb_af9015_remote;\nmodule_param_named(remote, dvb_usb_af9015_remote, int, 0644);\nMODULE_PARM_DESC(remote, \"select remote\");\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)\n{\n#define REQ_HDR_LEN 8  \n#define ACK_HDR_LEN 2  \n\tstruct af9015_state *state = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\tint ret, wlen, rlen;\n\tu8 write = 1;\n\n\tmutex_lock(&d->usb_mutex);\n\n\tstate->buf[0] = req->cmd;\n\tstate->buf[1] = state->seq++;\n\tstate->buf[2] = req->i2c_addr << 1;\n\tstate->buf[3] = req->addr >> 8;\n\tstate->buf[4] = req->addr & 0xff;\n\tstate->buf[5] = req->mbox;\n\tstate->buf[6] = req->addr_len;\n\tstate->buf[7] = req->data_len;\n\n\tswitch (req->cmd) {\n\tcase GET_CONFIG:\n\tcase READ_MEMORY:\n\tcase RECONNECT_USB:\n\t\twrite = 0;\n\t\tbreak;\n\tcase READ_I2C:\n\t\twrite = 0;\n\t\tstate->buf[2] |= 0x01;  \n\t\tfallthrough;\n\tcase WRITE_I2C:\n\t\tstate->buf[0] = READ_WRITE_I2C;\n\t\tbreak;\n\tcase WRITE_MEMORY:\n\t\tif (((req->addr & 0xff00) == 0xff00) ||\n\t\t    ((req->addr & 0xff00) == 0xae00))\n\t\t\tstate->buf[0] = WRITE_VIRTUAL_MEMORY;\n\t\tbreak;\n\tcase WRITE_VIRTUAL_MEMORY:\n\tcase COPY_FIRMWARE:\n\tcase DOWNLOAD_FIRMWARE:\n\tcase BOOT:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&intf->dev, \"unknown cmd %d\\n\", req->cmd);\n\t\tret = -EIO;\n\t\tgoto error;\n\t}\n\n\t \n\tif ((write && (req->data_len > BUF_LEN - REQ_HDR_LEN)) ||\n\t    (!write && (req->data_len > BUF_LEN - ACK_HDR_LEN))) {\n\t\tdev_err(&intf->dev, \"too much data, cmd %u, len %u\\n\",\n\t\t\treq->cmd, req->data_len);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\twlen = REQ_HDR_LEN;\n\trlen = ACK_HDR_LEN;\n\tif (write) {\n\t\twlen += req->data_len;\n\t\tmemcpy(&state->buf[REQ_HDR_LEN], req->data, req->data_len);\n\t} else {\n\t\trlen += req->data_len;\n\t}\n\n\t \n\tif (req->cmd == DOWNLOAD_FIRMWARE || req->cmd == RECONNECT_USB)\n\t\trlen = 0;\n\n\tret = dvb_usbv2_generic_rw_locked(d, state->buf, wlen,\n\t\t\t\t\t  state->buf, rlen);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tif (rlen && state->buf[1]) {\n\t\tdev_err(&intf->dev, \"cmd failed %u\\n\", state->buf[1]);\n\t\tret = -EIO;\n\t\tgoto error;\n\t}\n\n\t \n\tif (!write)\n\t\tmemcpy(req->data, &state->buf[ACK_HDR_LEN], req->data_len);\nerror:\n\tmutex_unlock(&d->usb_mutex);\n\n\treturn ret;\n}\n\nstatic int af9015_write_reg_i2c(struct dvb_usb_device *d, u8 addr, u16 reg,\n\t\t\t\tu8 val)\n{\n\tstruct af9015_state *state = d_to_priv(d);\n\tstruct req_t req = {WRITE_I2C, addr, reg, 1, 1, 1, &val};\n\n\tif (addr == state->af9013_i2c_addr[0] ||\n\t    addr == state->af9013_i2c_addr[1])\n\t\treq.addr_len = 3;\n\n\treturn af9015_ctrl_msg(d, &req);\n}\n\nstatic int af9015_read_reg_i2c(struct dvb_usb_device *d, u8 addr, u16 reg,\n\t\t\t       u8 *val)\n{\n\tstruct af9015_state *state = d_to_priv(d);\n\tstruct req_t req = {READ_I2C, addr, reg, 0, 1, 1, val};\n\n\tif (addr == state->af9013_i2c_addr[0] ||\n\t    addr == state->af9013_i2c_addr[1])\n\t\treq.addr_len = 3;\n\n\treturn af9015_ctrl_msg(d, &req);\n}\n\nstatic int af9015_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t   int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstruct af9015_state *state = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\tint ret;\n\tu16 addr;\n\tu8 mbox, addr_len;\n\tstruct req_t req;\n\n\t \n\n\tif (msg[0].len == 0 || msg[0].flags & I2C_M_RD) {\n\t\taddr = 0x0000;\n\t\tmbox = 0;\n\t\taddr_len = 0;\n\t} else if (msg[0].len == 1) {\n\t\taddr = msg[0].buf[0];\n\t\tmbox = 0;\n\t\taddr_len = 1;\n\t} else if (msg[0].len == 2) {\n\t\taddr = msg[0].buf[0] << 8 | msg[0].buf[1] << 0;\n\t\tmbox = 0;\n\t\taddr_len = 2;\n\t} else {\n\t\taddr = msg[0].buf[0] << 8 | msg[0].buf[1] << 0;\n\t\tmbox = msg[0].buf[2];\n\t\taddr_len = 3;\n\t}\n\n\tif (num == 1 && !(msg[0].flags & I2C_M_RD)) {\n\t\t \n\t\tif (msg[0].len > 21) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto err;\n\t\t}\n\t\tif (msg[0].addr == state->af9013_i2c_addr[0])\n\t\t\treq.cmd = WRITE_MEMORY;\n\t\telse\n\t\t\treq.cmd = WRITE_I2C;\n\t\treq.i2c_addr = msg[0].addr;\n\t\treq.addr = addr;\n\t\treq.mbox = mbox;\n\t\treq.addr_len = addr_len;\n\t\treq.data_len = msg[0].len - addr_len;\n\t\treq.data = &msg[0].buf[addr_len];\n\t\tret = af9015_ctrl_msg(d, &req);\n\t} else if (num == 2 && !(msg[0].flags & I2C_M_RD) &&\n\t\t   (msg[1].flags & I2C_M_RD)) {\n\t\t \n\t\tif (msg[0].len > 3 || msg[1].len > 61) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto err;\n\t\t}\n\t\tif (msg[0].addr == state->af9013_i2c_addr[0])\n\t\t\treq.cmd = READ_MEMORY;\n\t\telse\n\t\t\treq.cmd = READ_I2C;\n\t\treq.i2c_addr = msg[0].addr;\n\t\treq.addr = addr;\n\t\treq.mbox = mbox;\n\t\treq.addr_len = addr_len;\n\t\treq.data_len = msg[1].len;\n\t\treq.data = &msg[1].buf[0];\n\t\tret = af9015_ctrl_msg(d, &req);\n\t} else if (num == 1 && (msg[0].flags & I2C_M_RD)) {\n\t\t \n\t\tif (msg[0].len > 61) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto err;\n\t\t}\n\t\tif (msg[0].addr == state->af9013_i2c_addr[0]) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\treq.cmd = READ_I2C;\n\t\treq.i2c_addr = msg[0].addr;\n\t\treq.addr = addr;\n\t\treq.mbox = mbox;\n\t\treq.addr_len = addr_len;\n\t\treq.data_len = msg[0].len;\n\t\treq.data = &msg[0].buf[0];\n\t\tret = af9015_ctrl_msg(d, &req);\n\t} else {\n\t\tret = -EOPNOTSUPP;\n\t\tdev_dbg(&intf->dev, \"unknown msg, num %u\\n\", num);\n\t}\n\tif (ret)\n\t\tgoto err;\n\n\treturn num;\nerr:\n\tdev_dbg(&intf->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic u32 af9015_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm af9015_i2c_algo = {\n\t.master_xfer = af9015_i2c_xfer,\n\t.functionality = af9015_i2c_func,\n};\n\nstatic int af9015_identify_state(struct dvb_usb_device *d, const char **name)\n{\n\tstruct usb_interface *intf = d->intf;\n\tint ret;\n\tu8 reply;\n\tstruct req_t req = {GET_CONFIG, 0, 0, 0, 0, 1, &reply};\n\n\tret = af9015_ctrl_msg(d, &req);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(&intf->dev, \"reply %02x\\n\", reply);\n\n\tif (reply == 0x02)\n\t\tret = WARM;\n\telse\n\t\tret = COLD;\n\n\treturn ret;\n}\n\nstatic int af9015_download_firmware(struct dvb_usb_device *d,\n\t\t\t\t    const struct firmware *firmware)\n{\n\tstruct af9015_state *state = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\tint ret, i, rem;\n\tstruct req_t req = {DOWNLOAD_FIRMWARE, 0, 0, 0, 0, 0, NULL};\n\tu16 checksum;\n\n\tdev_dbg(&intf->dev, \"\\n\");\n\n\t \n\tfor (i = 0, checksum = 0; i < firmware->size; i++)\n\t\tchecksum += firmware->data[i];\n\n\tstate->firmware_size = firmware->size;\n\tstate->firmware_checksum = checksum;\n\n\t#define LEN_MAX (BUF_LEN - REQ_HDR_LEN)  \n\tfor (rem = firmware->size; rem > 0; rem -= LEN_MAX) {\n\t\treq.data_len = min(LEN_MAX, rem);\n\t\treq.data = (u8 *)&firmware->data[firmware->size - rem];\n\t\treq.addr = 0x5100 + firmware->size - rem;\n\t\tret = af9015_ctrl_msg(d, &req);\n\t\tif (ret) {\n\t\t\tdev_err(&intf->dev, \"firmware download failed %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treq.cmd = BOOT;\n\treq.data_len = 0;\n\tret = af9015_ctrl_msg(d, &req);\n\tif (ret) {\n\t\tdev_err(&intf->dev, \"firmware boot failed %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&intf->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\n#define AF9015_EEPROM_SIZE 256\n \n#define GOLDEN_RATIO_PRIME_32 0x9e370001UL\n\n \nstatic int af9015_eeprom_hash(struct dvb_usb_device *d)\n{\n\tstruct af9015_state *state = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\tint ret, i;\n\tu8 buf[AF9015_EEPROM_SIZE];\n\tstruct req_t req = {READ_I2C, AF9015_I2C_EEPROM, 0, 0, 1, 1, NULL};\n\n\t \n\tfor (i = 0; i < AF9015_EEPROM_SIZE; i++) {\n\t\treq.addr = i;\n\t\treq.data = &buf[i];\n\t\tret = af9015_ctrl_msg(d, &req);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\t \n\tfor (i = 0; i < AF9015_EEPROM_SIZE / sizeof(u32); i++) {\n\t\tstate->eeprom_sum *= GOLDEN_RATIO_PRIME_32;\n\t\tstate->eeprom_sum += le32_to_cpu(((__le32 *)buf)[i]);\n\t}\n\n\tfor (i = 0; i < AF9015_EEPROM_SIZE; i += 16)\n\t\tdev_dbg(&intf->dev, \"%*ph\\n\", 16, buf + i);\n\n\tdev_dbg(&intf->dev, \"eeprom sum %.8x\\n\", state->eeprom_sum);\n\treturn 0;\nerr:\n\tdev_dbg(&intf->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9015_read_config(struct dvb_usb_device *d)\n{\n\tstruct af9015_state *state = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\tint ret;\n\tu8 val, i, offset = 0;\n\tstruct req_t req = {READ_I2C, AF9015_I2C_EEPROM, 0, 0, 1, 1, &val};\n\n\tdev_dbg(&intf->dev, \"\\n\");\n\n\t \n\treq.addr = AF9015_EEPROM_IR_MODE;\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tret = af9015_ctrl_msg(d, &req);\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\tif (ret)\n\t\tgoto error;\n\n\tret = af9015_eeprom_hash(d);\n\tif (ret)\n\t\tgoto error;\n\n\tstate->ir_mode = val;\n\tdev_dbg(&intf->dev, \"ir mode %02x\\n\", val);\n\n\t \n\treq.addr = AF9015_EEPROM_TS_MODE;\n\tret = af9015_ctrl_msg(d, &req);\n\tif (ret)\n\t\tgoto error;\n\n\tstate->dual_mode = val;\n\tdev_dbg(&intf->dev, \"ts mode %02x\\n\", state->dual_mode);\n\n\tstate->af9013_i2c_addr[0] = AF9015_I2C_DEMOD;\n\n\tif (state->dual_mode) {\n\t\t \n\t\treq.addr = AF9015_EEPROM_DEMOD2_I2C;\n\t\tret = af9015_ctrl_msg(d, &req);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tstate->af9013_i2c_addr[1] = val >> 1;\n\t}\n\n\tfor (i = 0; i < state->dual_mode + 1; i++) {\n\t\tif (i == 1)\n\t\t\toffset = AF9015_EEPROM_OFFSET;\n\t\t \n\t\treq.addr = AF9015_EEPROM_XTAL_TYPE1 + offset;\n\t\tret = af9015_ctrl_msg(d, &req);\n\t\tif (ret)\n\t\t\tgoto error;\n\t\tswitch (val) {\n\t\tcase 0:\n\t\t\tstate->af9013_pdata[i].clk = 28800000;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tstate->af9013_pdata[i].clk = 20480000;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstate->af9013_pdata[i].clk = 28000000;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tstate->af9013_pdata[i].clk = 25000000;\n\t\t\tbreak;\n\t\t}\n\t\tdev_dbg(&intf->dev, \"[%d] xtal %02x, clk %u\\n\",\n\t\t\ti, val, state->af9013_pdata[i].clk);\n\n\t\t \n\t\treq.addr = AF9015_EEPROM_IF1H + offset;\n\t\tret = af9015_ctrl_msg(d, &req);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tstate->af9013_pdata[i].if_frequency = val << 8;\n\n\t\treq.addr = AF9015_EEPROM_IF1L + offset;\n\t\tret = af9015_ctrl_msg(d, &req);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tstate->af9013_pdata[i].if_frequency += val;\n\t\tstate->af9013_pdata[i].if_frequency *= 1000;\n\t\tdev_dbg(&intf->dev, \"[%d] if frequency %u\\n\",\n\t\t\ti, state->af9013_pdata[i].if_frequency);\n\n\t\t \n\t\treq.addr = AF9015_EEPROM_MT2060_IF1H  + offset;\n\t\tret = af9015_ctrl_msg(d, &req);\n\t\tif (ret)\n\t\t\tgoto error;\n\t\tstate->mt2060_if1[i] = val << 8;\n\t\treq.addr = AF9015_EEPROM_MT2060_IF1L + offset;\n\t\tret = af9015_ctrl_msg(d, &req);\n\t\tif (ret)\n\t\t\tgoto error;\n\t\tstate->mt2060_if1[i] += val;\n\t\tdev_dbg(&intf->dev, \"[%d] MT2060 IF1 %u\\n\",\n\t\t\ti, state->mt2060_if1[i]);\n\n\t\t \n\t\treq.addr =  AF9015_EEPROM_TUNER_ID1 + offset;\n\t\tret = af9015_ctrl_msg(d, &req);\n\t\tif (ret)\n\t\t\tgoto error;\n\t\tswitch (val) {\n\t\tcase AF9013_TUNER_ENV77H11D5:\n\t\tcase AF9013_TUNER_MT2060:\n\t\tcase AF9013_TUNER_QT1010:\n\t\tcase AF9013_TUNER_UNKNOWN:\n\t\tcase AF9013_TUNER_MT2060_2:\n\t\tcase AF9013_TUNER_TDA18271:\n\t\tcase AF9013_TUNER_QT1010A:\n\t\tcase AF9013_TUNER_TDA18218:\n\t\t\tstate->af9013_pdata[i].spec_inv = 1;\n\t\t\tbreak;\n\t\tcase AF9013_TUNER_MXL5003D:\n\t\tcase AF9013_TUNER_MXL5005D:\n\t\tcase AF9013_TUNER_MXL5005R:\n\t\tcase AF9013_TUNER_MXL5007T:\n\t\t\tstate->af9013_pdata[i].spec_inv = 0;\n\t\t\tbreak;\n\t\tcase AF9013_TUNER_MC44S803:\n\t\t\tstate->af9013_pdata[i].gpio[1] = AF9013_GPIO_LO;\n\t\t\tstate->af9013_pdata[i].spec_inv = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"tuner id %02x not supported, please report!\\n\",\n\t\t\t\tval);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tstate->af9013_pdata[i].tuner = val;\n\t\tdev_dbg(&intf->dev, \"[%d] tuner id %02x\\n\", i, val);\n\t}\n\nerror:\n\tif (ret)\n\t\tdev_err(&intf->dev, \"eeprom read failed %d\\n\", ret);\n\n\t \n\tif (le16_to_cpu(d->udev->descriptor.idVendor) == USB_VID_AVERMEDIA &&\n\t    ((le16_to_cpu(d->udev->descriptor.idProduct) == USB_PID_AVERMEDIA_A850) ||\n\t    (le16_to_cpu(d->udev->descriptor.idProduct) == USB_PID_AVERMEDIA_A850T))) {\n\t\tdev_dbg(&intf->dev, \"AverMedia A850: overriding config\\n\");\n\t\t \n\t\tstate->dual_mode = 0;\n\n\t\t \n\t\tstate->af9013_pdata[0].if_frequency = 4570000;\n\t}\n\n\treturn ret;\n}\n\nstatic int af9015_get_stream_config(struct dvb_frontend *fe, u8 *ts_type,\n\t\t\t\t    struct usb_data_stream_properties *stream)\n{\n\tstruct dvb_usb_device *d = fe_to_d(fe);\n\tstruct usb_interface *intf = d->intf;\n\n\tdev_dbg(&intf->dev, \"adap %u\\n\", fe_to_adap(fe)->id);\n\n\tif (d->udev->speed == USB_SPEED_FULL)\n\t\tstream->u.bulk.buffersize = 5 * 188;\n\n\treturn 0;\n}\n\nstatic int af9015_streaming_ctrl(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dvb_usb_device *d = fe_to_d(fe);\n\tstruct af9015_state *state = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\tint ret;\n\tunsigned int utmp1, utmp2, reg1, reg2;\n\tu8 buf[2];\n\tconst unsigned int adap_id = fe_to_adap(fe)->id;\n\n\tdev_dbg(&intf->dev, \"adap id %d, onoff %d\\n\", adap_id, onoff);\n\n\tif (!state->usb_ts_if_configured[adap_id]) {\n\t\tdev_dbg(&intf->dev, \"set usb and ts interface\\n\");\n\n\t\t \n\t\tutmp1 = (d->udev->speed == USB_SPEED_FULL ? 5 : 87) * 188 / 4;\n\t\tutmp2 = (d->udev->speed == USB_SPEED_FULL ? 64 : 512) / 4;\n\n\t\tbuf[0] = (utmp1 >> 0) & 0xff;\n\t\tbuf[1] = (utmp1 >> 8) & 0xff;\n\t\tif (adap_id == 0) {\n\t\t\t \n\t\t\treg1 = 0xdd88;\n\t\t\treg2 = 0xdd0c;\n\t\t} else {\n\t\t\t \n\t\t\treg1 = 0xdd8a;\n\t\t\treg2 = 0xdd0d;\n\t\t}\n\t\tret = regmap_bulk_write(state->regmap, reg1, buf, 2);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_write(state->regmap, reg2, utmp2);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tif (state->dual_mode) {\n\t\t\tutmp1 = 0x01;\n\t\t\tutmp2 = 0x10;\n\t\t} else {\n\t\t\tutmp1 = 0x00;\n\t\t\tutmp2 = 0x00;\n\t\t}\n\t\tret = regmap_update_bits(state->regmap, 0xd50b, 0x01, utmp1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_update_bits(state->regmap, 0xd520, 0x10, utmp2);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tstate->usb_ts_if_configured[adap_id] = true;\n\t}\n\n\tif (adap_id == 0 && onoff) {\n\t\t \n\t\tret = regmap_update_bits(state->regmap, 0xdd13, 0x20, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_update_bits(state->regmap, 0xdd11, 0x20, 0x20);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_update_bits(state->regmap, 0xd507, 0x04, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else if (adap_id == 1 && onoff) {\n\t\t \n\t\tret = regmap_update_bits(state->regmap, 0xdd13, 0x40, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_update_bits(state->regmap, 0xdd11, 0x40, 0x40);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_update_bits(state->regmap, 0xd50b, 0x02, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else if (adap_id == 0 && !onoff) {\n\t\t \n\t\tret = regmap_update_bits(state->regmap, 0xd507, 0x04, 0x04);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_update_bits(state->regmap, 0xdd11, 0x20, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_update_bits(state->regmap, 0xdd13, 0x20, 0x20);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else if (adap_id == 1 && !onoff) {\n\t\t \n\t\tret = regmap_update_bits(state->regmap, 0xd50b, 0x02, 0x02);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_update_bits(state->regmap, 0xdd11, 0x40, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_update_bits(state->regmap, 0xdd13, 0x40, 0x40);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&intf->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9015_get_adapter_count(struct dvb_usb_device *d)\n{\n\tstruct af9015_state *state = d_to_priv(d);\n\n\treturn state->dual_mode + 1;\n}\n\n \nstatic int af9015_af9013_set_frontend(struct dvb_frontend *fe)\n{\n\tint ret;\n\tstruct af9015_state *state = fe_to_priv(fe);\n\n\tif (mutex_lock_interruptible(&state->fe_mutex))\n\t\treturn -EAGAIN;\n\n\tret = state->set_frontend[fe_to_adap(fe)->id](fe);\n\n\tmutex_unlock(&state->fe_mutex);\n\n\treturn ret;\n}\n\n \nstatic int af9015_af9013_read_status(struct dvb_frontend *fe,\n\t\t\t\t     enum fe_status *status)\n{\n\tint ret;\n\tstruct af9015_state *state = fe_to_priv(fe);\n\n\tif (mutex_lock_interruptible(&state->fe_mutex))\n\t\treturn -EAGAIN;\n\n\tret = state->read_status[fe_to_adap(fe)->id](fe, status);\n\n\tmutex_unlock(&state->fe_mutex);\n\n\treturn ret;\n}\n\n \nstatic int af9015_af9013_init(struct dvb_frontend *fe)\n{\n\tint ret;\n\tstruct af9015_state *state = fe_to_priv(fe);\n\n\tif (mutex_lock_interruptible(&state->fe_mutex))\n\t\treturn -EAGAIN;\n\n\tret = state->init[fe_to_adap(fe)->id](fe);\n\n\tmutex_unlock(&state->fe_mutex);\n\n\treturn ret;\n}\n\n \nstatic int af9015_af9013_sleep(struct dvb_frontend *fe)\n{\n\tint ret;\n\tstruct af9015_state *state = fe_to_priv(fe);\n\n\tif (mutex_lock_interruptible(&state->fe_mutex))\n\t\treturn -EAGAIN;\n\n\tret = state->sleep[fe_to_adap(fe)->id](fe);\n\n\tmutex_unlock(&state->fe_mutex);\n\n\treturn ret;\n}\n\n \nstatic int af9015_tuner_init(struct dvb_frontend *fe)\n{\n\tint ret;\n\tstruct af9015_state *state = fe_to_priv(fe);\n\n\tif (mutex_lock_interruptible(&state->fe_mutex))\n\t\treturn -EAGAIN;\n\n\tret = state->tuner_init[fe_to_adap(fe)->id](fe);\n\n\tmutex_unlock(&state->fe_mutex);\n\n\treturn ret;\n}\n\n \nstatic int af9015_tuner_sleep(struct dvb_frontend *fe)\n{\n\tint ret;\n\tstruct af9015_state *state = fe_to_priv(fe);\n\n\tif (mutex_lock_interruptible(&state->fe_mutex))\n\t\treturn -EAGAIN;\n\n\tret = state->tuner_sleep[fe_to_adap(fe)->id](fe);\n\n\tmutex_unlock(&state->fe_mutex);\n\n\treturn ret;\n}\n\nstatic int af9015_copy_firmware(struct dvb_usb_device *d)\n{\n\tstruct af9015_state *state = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\tint ret;\n\tunsigned long timeout;\n\tu8 val, firmware_info[4];\n\tstruct req_t req = {COPY_FIRMWARE, 0, 0x5100, 0, 0, 4, firmware_info};\n\n\tdev_dbg(&intf->dev, \"\\n\");\n\n\tfirmware_info[0] = (state->firmware_size >> 8) & 0xff;\n\tfirmware_info[1] = (state->firmware_size >> 0) & 0xff;\n\tfirmware_info[2] = (state->firmware_checksum >> 8) & 0xff;\n\tfirmware_info[3] = (state->firmware_checksum >> 0) & 0xff;\n\n\t \n\tret = af9015_read_reg_i2c(d, state->af9013_i2c_addr[1], 0x98be, &val);\n\tif (ret)\n\t\tgoto err;\n\n\tdev_dbg(&intf->dev, \"firmware status %02x\\n\", val);\n\n\tif (val == 0x0c)\n\t\treturn 0;\n\n\t \n\tret = regmap_write(state->regmap, 0xd416, 0x04);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = af9015_ctrl_msg(d, &req);\n\tif (ret) {\n\t\tdev_err(&intf->dev, \"firmware copy cmd failed %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\t \n\tret = regmap_write(state->regmap, 0xd416, 0x14);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = af9015_write_reg_i2c(d, state->af9013_i2c_addr[1], 0xe205, 0x01);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tfor (val = 0x00, timeout = jiffies + msecs_to_jiffies(1000);\n\t     !time_after(jiffies, timeout) && val != 0x0c && val != 0x04;) {\n\t\tmsleep(20);\n\n\t\t \n\t\tret = af9015_read_reg_i2c(d, state->af9013_i2c_addr[1],\n\t\t\t\t\t  0x98be, &val);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tdev_dbg(&intf->dev, \"firmware status %02x\\n\", val);\n\t}\n\n\tdev_dbg(&intf->dev, \"firmware boot took %u ms\\n\",\n\t\tjiffies_to_msecs(jiffies) - (jiffies_to_msecs(timeout) - 1000));\n\n\tif (val == 0x04) {\n\t\tret = -ENODEV;\n\t\tdev_err(&intf->dev, \"firmware did not run\\n\");\n\t\tgoto err;\n\t} else if (val != 0x0c) {\n\t\tret = -ETIMEDOUT;\n\t\tdev_err(&intf->dev, \"firmware boot timeout\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&intf->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9015_af9013_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct af9015_state *state = adap_to_priv(adap);\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct usb_interface *intf = d->intf;\n\tstruct i2c_client *client;\n\tint ret;\n\n\tdev_dbg(&intf->dev, \"adap id %u\\n\", adap->id);\n\n\tif (adap->id == 0) {\n\t\tstate->af9013_pdata[0].ts_mode = AF9013_TS_MODE_USB;\n\t\tmemcpy(state->af9013_pdata[0].api_version, \"\\x0\\x1\\x9\\x0\", 4);\n\t\tstate->af9013_pdata[0].gpio[0] = AF9013_GPIO_HI;\n\t\tstate->af9013_pdata[0].gpio[3] = AF9013_GPIO_TUNER_ON;\n\t} else if (adap->id == 1) {\n\t\tstate->af9013_pdata[1].ts_mode = AF9013_TS_MODE_SERIAL;\n\t\tstate->af9013_pdata[1].ts_output_pin = 7;\n\t\tmemcpy(state->af9013_pdata[1].api_version, \"\\x0\\x1\\x9\\x0\", 4);\n\t\tstate->af9013_pdata[1].gpio[0] = AF9013_GPIO_TUNER_ON;\n\t\tstate->af9013_pdata[1].gpio[1] = AF9013_GPIO_LO;\n\n\t\t \n\t\tif (state->dual_mode) {\n\t\t\t \n\t\t\tmsleep(100);\n\n\t\t\tret = af9015_copy_firmware(adap_to_d(adap));\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&intf->dev,\n\t\t\t\t\t\"firmware copy to 2nd frontend failed, will disable it\\n\");\n\t\t\t\tstate->dual_mode = 0;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\tret = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\tclient = dvb_module_probe(\"af9013\", NULL, &d->i2c_adap,\n\t\t\t\t  state->af9013_i2c_addr[adap->id],\n\t\t\t\t  &state->af9013_pdata[adap->id]);\n\tif (!client) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\tadap->fe[0] = state->af9013_pdata[adap->id].get_dvb_frontend(client);\n\tstate->demod_i2c_client[adap->id] = client;\n\n\t \n\tif (adap->fe[0]) {\n\t\tstate->set_frontend[adap->id] = adap->fe[0]->ops.set_frontend;\n\t\tadap->fe[0]->ops.set_frontend = af9015_af9013_set_frontend;\n\t\tstate->read_status[adap->id] = adap->fe[0]->ops.read_status;\n\t\tadap->fe[0]->ops.read_status = af9015_af9013_read_status;\n\t\tstate->init[adap->id] = adap->fe[0]->ops.init;\n\t\tadap->fe[0]->ops.init = af9015_af9013_init;\n\t\tstate->sleep[adap->id] = adap->fe[0]->ops.sleep;\n\t\tadap->fe[0]->ops.sleep = af9015_af9013_sleep;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&intf->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9015_frontend_detach(struct dvb_usb_adapter *adap)\n{\n\tstruct af9015_state *state = adap_to_priv(adap);\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct usb_interface *intf = d->intf;\n\tstruct i2c_client *client;\n\n\tdev_dbg(&intf->dev, \"adap id %u\\n\", adap->id);\n\n\t \n\tclient = state->demod_i2c_client[adap->id];\n\tdvb_module_release(client);\n\n\treturn 0;\n}\n\nstatic struct mt2060_config af9015_mt2060_config = {\n\t.i2c_address = 0x60,\n\t.clock_out = 0,\n};\n\nstatic struct qt1010_config af9015_qt1010_config = {\n\t.i2c_address = 0x62,\n};\n\nstatic struct tda18271_config af9015_tda18271_config = {\n\t.gate = TDA18271_GATE_DIGITAL,\n\t.small_i2c = TDA18271_16_BYTE_CHUNK_INIT,\n};\n\nstatic struct mxl5005s_config af9015_mxl5003_config = {\n\t.i2c_address     = 0x63,\n\t.if_freq         = IF_FREQ_4570000HZ,\n\t.xtal_freq       = CRYSTAL_FREQ_16000000HZ,\n\t.agc_mode        = MXL_SINGLE_AGC,\n\t.tracking_filter = MXL_TF_DEFAULT,\n\t.rssi_enable     = MXL_RSSI_ENABLE,\n\t.cap_select      = MXL_CAP_SEL_ENABLE,\n\t.div_out         = MXL_DIV_OUT_4,\n\t.clock_out       = MXL_CLOCK_OUT_DISABLE,\n\t.output_load     = MXL5005S_IF_OUTPUT_LOAD_200_OHM,\n\t.top\t\t = MXL5005S_TOP_25P2,\n\t.mod_mode        = MXL_DIGITAL_MODE,\n\t.if_mode         = MXL_ZERO_IF,\n\t.AgcMasterByte   = 0x00,\n};\n\nstatic struct mxl5005s_config af9015_mxl5005_config = {\n\t.i2c_address     = 0x63,\n\t.if_freq         = IF_FREQ_4570000HZ,\n\t.xtal_freq       = CRYSTAL_FREQ_16000000HZ,\n\t.agc_mode        = MXL_SINGLE_AGC,\n\t.tracking_filter = MXL_TF_OFF,\n\t.rssi_enable     = MXL_RSSI_ENABLE,\n\t.cap_select      = MXL_CAP_SEL_ENABLE,\n\t.div_out         = MXL_DIV_OUT_4,\n\t.clock_out       = MXL_CLOCK_OUT_DISABLE,\n\t.output_load     = MXL5005S_IF_OUTPUT_LOAD_200_OHM,\n\t.top\t\t = MXL5005S_TOP_25P2,\n\t.mod_mode        = MXL_DIGITAL_MODE,\n\t.if_mode         = MXL_ZERO_IF,\n\t.AgcMasterByte   = 0x00,\n};\n\nstatic struct mc44s803_config af9015_mc44s803_config = {\n\t.i2c_address = 0x60,\n\t.dig_out = 1,\n};\n\nstatic struct tda18218_config af9015_tda18218_config = {\n\t.i2c_address = 0x60,\n\t.i2c_wr_max = 21,  \n};\n\nstatic struct mxl5007t_config af9015_mxl5007t_config = {\n\t.xtal_freq_hz = MxL_XTAL_24_MHZ,\n\t.if_freq_hz = MxL_IF_4_57_MHZ,\n};\n\nstatic int af9015_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct af9015_state *state = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\tstruct i2c_client *client;\n\tstruct i2c_adapter *adapter;\n\tint ret;\n\n\tdev_dbg(&intf->dev, \"adap id %u\\n\", adap->id);\n\n\tclient = state->demod_i2c_client[adap->id];\n\tadapter = state->af9013_pdata[adap->id].get_i2c_adapter(client);\n\n\tswitch (state->af9013_pdata[adap->id].tuner) {\n\tcase AF9013_TUNER_MT2060:\n\tcase AF9013_TUNER_MT2060_2:\n\t\tret = dvb_attach(mt2060_attach, adap->fe[0], adapter,\n\t\t\t\t &af9015_mt2060_config,\n\t\t\t\t state->mt2060_if1[adap->id]) == NULL ? -ENODEV : 0;\n\t\tbreak;\n\tcase AF9013_TUNER_QT1010:\n\tcase AF9013_TUNER_QT1010A:\n\t\tret = dvb_attach(qt1010_attach, adap->fe[0], adapter,\n\t\t\t\t &af9015_qt1010_config) == NULL ? -ENODEV : 0;\n\t\tbreak;\n\tcase AF9013_TUNER_TDA18271:\n\t\tret = dvb_attach(tda18271_attach, adap->fe[0], 0x60, adapter,\n\t\t\t\t &af9015_tda18271_config) == NULL ? -ENODEV : 0;\n\t\tbreak;\n\tcase AF9013_TUNER_TDA18218:\n\t\tret = dvb_attach(tda18218_attach, adap->fe[0], adapter,\n\t\t\t\t &af9015_tda18218_config) == NULL ? -ENODEV : 0;\n\t\tbreak;\n\tcase AF9013_TUNER_MXL5003D:\n\t\tret = dvb_attach(mxl5005s_attach, adap->fe[0], adapter,\n\t\t\t\t &af9015_mxl5003_config) == NULL ? -ENODEV : 0;\n\t\tbreak;\n\tcase AF9013_TUNER_MXL5005D:\n\tcase AF9013_TUNER_MXL5005R:\n\t\tret = dvb_attach(mxl5005s_attach, adap->fe[0], adapter,\n\t\t\t\t &af9015_mxl5005_config) == NULL ? -ENODEV : 0;\n\t\tbreak;\n\tcase AF9013_TUNER_ENV77H11D5:\n\t\tret = dvb_attach(dvb_pll_attach, adap->fe[0], 0x60, adapter,\n\t\t\t\t DVB_PLL_TDA665X) == NULL ? -ENODEV : 0;\n\t\tbreak;\n\tcase AF9013_TUNER_MC44S803:\n\t\tret = dvb_attach(mc44s803_attach, adap->fe[0], adapter,\n\t\t\t\t &af9015_mc44s803_config) == NULL ? -ENODEV : 0;\n\t\tbreak;\n\tcase AF9013_TUNER_MXL5007T:\n\t\tret = dvb_attach(mxl5007t_attach, adap->fe[0], adapter,\n\t\t\t\t 0x60, &af9015_mxl5007t_config) == NULL ? -ENODEV : 0;\n\t\tbreak;\n\tcase AF9013_TUNER_UNKNOWN:\n\tdefault:\n\t\tdev_err(&intf->dev, \"unknown tuner, tuner id %02x\\n\",\n\t\t\tstate->af9013_pdata[adap->id].tuner);\n\t\tret = -ENODEV;\n\t}\n\n\tif (adap->fe[0]->ops.tuner_ops.init) {\n\t\tstate->tuner_init[adap->id] =\n\t\t\tadap->fe[0]->ops.tuner_ops.init;\n\t\tadap->fe[0]->ops.tuner_ops.init = af9015_tuner_init;\n\t}\n\n\tif (adap->fe[0]->ops.tuner_ops.sleep) {\n\t\tstate->tuner_sleep[adap->id] =\n\t\t\tadap->fe[0]->ops.tuner_ops.sleep;\n\t\tadap->fe[0]->ops.tuner_ops.sleep = af9015_tuner_sleep;\n\t}\n\n\treturn ret;\n}\n\nstatic int af9015_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)\n{\n\tstruct af9015_state *state = adap_to_priv(adap);\n\tstruct af9013_platform_data *pdata = &state->af9013_pdata[adap->id];\n\tint ret;\n\n\tmutex_lock(&state->fe_mutex);\n\tret = pdata->pid_filter_ctrl(adap->fe[0], onoff);\n\tmutex_unlock(&state->fe_mutex);\n\n\treturn ret;\n}\n\nstatic int af9015_pid_filter(struct dvb_usb_adapter *adap, int index,\n\t\t\t     u16 pid, int onoff)\n{\n\tstruct af9015_state *state = adap_to_priv(adap);\n\tstruct af9013_platform_data *pdata = &state->af9013_pdata[adap->id];\n\tint ret;\n\n\tmutex_lock(&state->fe_mutex);\n\tret = pdata->pid_filter(adap->fe[0], index, pid, onoff);\n\tmutex_unlock(&state->fe_mutex);\n\n\treturn ret;\n}\n\nstatic int af9015_init(struct dvb_usb_device *d)\n{\n\tstruct af9015_state *state = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\tint ret;\n\n\tdev_dbg(&intf->dev, \"\\n\");\n\n\tmutex_init(&state->fe_mutex);\n\n\t \n\tret = regmap_write(state->regmap, 0x98e9, 0xff);\n\tif (ret)\n\t\tgoto error;\n\nerror:\n\treturn ret;\n}\n\n#if IS_ENABLED(CONFIG_RC_CORE)\nstruct af9015_rc_setup {\n\tunsigned int id;\n\tchar *rc_codes;\n};\n\nstatic char *af9015_rc_setup_match(unsigned int id,\n\t\t\t\t   const struct af9015_rc_setup *table)\n{\n\tfor (; table->rc_codes; table++)\n\t\tif (table->id == id)\n\t\t\treturn table->rc_codes;\n\treturn NULL;\n}\n\nstatic const struct af9015_rc_setup af9015_rc_setup_modparam[] = {\n\t{ AF9015_REMOTE_A_LINK_DTU_M, RC_MAP_ALINK_DTU_M },\n\t{ AF9015_REMOTE_MSI_DIGIVOX_MINI_II_V3, RC_MAP_MSI_DIGIVOX_II },\n\t{ AF9015_REMOTE_MYGICTV_U718, RC_MAP_TOTAL_MEDIA_IN_HAND },\n\t{ AF9015_REMOTE_DIGITTRADE_DVB_T, RC_MAP_DIGITTRADE },\n\t{ AF9015_REMOTE_AVERMEDIA_KS, RC_MAP_AVERMEDIA_RM_KS },\n\t{ }\n};\n\nstatic const struct af9015_rc_setup af9015_rc_setup_hashes[] = {\n\t{ 0xb8feb708, RC_MAP_MSI_DIGIVOX_II },\n\t{ 0xa3703d00, RC_MAP_ALINK_DTU_M },\n\t{ 0x9b7dc64e, RC_MAP_TOTAL_MEDIA_IN_HAND },  \n\t{ 0x5d49e3db, RC_MAP_DIGITTRADE },  \n\t{ }\n};\n\nstatic int af9015_rc_query(struct dvb_usb_device *d)\n{\n\tstruct af9015_state *state = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\tint ret;\n\tu8 buf[17];\n\n\t \n\tret = regmap_bulk_read(state->regmap, 0x98d9, buf, sizeof(buf));\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tif (buf[1] || buf[2] || buf[3]) {\n\t\tdev_dbg(&intf->dev, \"invalid data\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif ((state->rc_repeat != buf[6] || buf[0]) &&\n\t    !memcmp(&buf[12], state->rc_last, 4)) {\n\t\tdev_dbg(&intf->dev, \"key repeated\\n\");\n\t\trc_repeat(d->rc_dev);\n\t\tstate->rc_repeat = buf[6];\n\t\treturn 0;\n\t}\n\n\t \n\tif (buf[16] != 0xff && buf[0] != 0x01) {\n\t\tenum rc_proto proto;\n\n\t\tdev_dbg(&intf->dev, \"key pressed %*ph\\n\", 4, buf + 12);\n\n\t\t \n\t\tret = regmap_write(state->regmap, 0x98e9, 0xff);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\t \n\t\tmemcpy(state->rc_last, &buf[12], 4);\n\t\tif (buf[14] == (u8)~buf[15]) {\n\t\t\tif (buf[12] == (u8)~buf[13]) {\n\t\t\t\t \n\t\t\t\tstate->rc_keycode = RC_SCANCODE_NEC(buf[12],\n\t\t\t\t\t\t\t\t    buf[14]);\n\t\t\t\tproto = RC_PROTO_NEC;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tstate->rc_keycode = RC_SCANCODE_NECX(buf[12] << 8 |\n\t\t\t\t\t\t\t\t     buf[13],\n\t\t\t\t\t\t\t\t     buf[14]);\n\t\t\t\tproto = RC_PROTO_NECX;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tstate->rc_keycode = RC_SCANCODE_NEC32(buf[12] << 24 |\n\t\t\t\t\t\t\t      buf[13] << 16 |\n\t\t\t\t\t\t\t      buf[14] << 8  |\n\t\t\t\t\t\t\t      buf[15]);\n\t\t\tproto = RC_PROTO_NEC32;\n\t\t}\n\t\trc_keydown(d->rc_dev, proto, state->rc_keycode, 0);\n\t} else {\n\t\tdev_dbg(&intf->dev, \"no key press\\n\");\n\t\t \n\t\t \n\t\tstate->rc_last[2] = state->rc_last[3];\n\t}\n\n\tstate->rc_repeat = buf[6];\n\tstate->rc_failed = false;\n\nerror:\n\tif (ret) {\n\t\tdev_warn(&intf->dev, \"rc query failed %d\\n\", ret);\n\n\t\t \n\t\tif (!state->rc_failed)\n\t\t\tret = 0;\n\n\t\tstate->rc_failed = true;\n\t}\n\n\treturn ret;\n}\n\nstatic int af9015_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)\n{\n\tstruct af9015_state *state = d_to_priv(d);\n\tu16 vid = le16_to_cpu(d->udev->descriptor.idVendor);\n\n\tif (state->ir_mode == AF9015_IR_MODE_DISABLED)\n\t\treturn 0;\n\n\t \n\tif (!rc->map_name)\n\t\trc->map_name = af9015_rc_setup_match(dvb_usb_af9015_remote,\n\t\t\t\t\t\t     af9015_rc_setup_modparam);\n\n\t \n\tif (!rc->map_name)\n\t\trc->map_name = af9015_rc_setup_match(state->eeprom_sum,\n\t\t\t\t\t\t     af9015_rc_setup_hashes);\n\n\t \n\tif (!rc->map_name && vid == USB_VID_AFATECH) {\n\t\t \n\t\tchar manufacturer[10];\n\n\t\tmemset(manufacturer, 0, sizeof(manufacturer));\n\t\tusb_string(d->udev, d->udev->descriptor.iManufacturer,\n\t\t\t   manufacturer, sizeof(manufacturer));\n\t\tif (!strcmp(\"MSI\", manufacturer)) {\n\t\t\t \n\t\t\trc->map_name = af9015_rc_setup_match(AF9015_REMOTE_MSI_DIGIVOX_MINI_II_V3,\n\t\t\t\t\t\t\t     af9015_rc_setup_modparam);\n\t\t}\n\t}\n\n\t \n\tif (!rc->map_name)\n\t\trc->map_name = RC_MAP_EMPTY;\n\n\trc->allowed_protos = RC_PROTO_BIT_NEC | RC_PROTO_BIT_NECX |\n\t\t\t\t\t\tRC_PROTO_BIT_NEC32;\n\trc->query = af9015_rc_query;\n\trc->interval = 500;\n\n\treturn 0;\n}\n#else\n\t#define af9015_get_rc_config NULL\n#endif\n\nstatic int af9015_regmap_write(void *context, const void *data, size_t count)\n{\n\tstruct dvb_usb_device *d = context;\n\tstruct usb_interface *intf = d->intf;\n\tint ret;\n\tu16 reg = ((u8 *)data)[0] << 8 | ((u8 *)data)[1] << 0;\n\tu8 *val = &((u8 *)data)[2];\n\tconst unsigned int len = count - 2;\n\tstruct req_t req = {WRITE_MEMORY, 0, reg, 0, 0, len, val};\n\n\tret = af9015_ctrl_msg(d, &req);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&intf->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9015_regmap_read(void *context, const void *reg_buf,\n\t\t\t      size_t reg_size, void *val_buf, size_t val_size)\n{\n\tstruct dvb_usb_device *d = context;\n\tstruct usb_interface *intf = d->intf;\n\tint ret;\n\tu16 reg = ((u8 *)reg_buf)[0] << 8 | ((u8 *)reg_buf)[1] << 0;\n\tu8 *val = &((u8 *)val_buf)[0];\n\tconst unsigned int len = val_size;\n\tstruct req_t req = {READ_MEMORY, 0, reg, 0, 0, len, val};\n\n\tret = af9015_ctrl_msg(d, &req);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&intf->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9015_probe(struct dvb_usb_device *d)\n{\n\tstruct af9015_state *state = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tint ret;\n\tchar manufacturer[sizeof(\"ITE Technologies, Inc.\")];\n\tstatic const struct regmap_config regmap_config = {\n\t\t.reg_bits    =  16,\n\t\t.val_bits    =  8,\n\t};\n\tstatic const struct regmap_bus regmap_bus = {\n\t\t.read = af9015_regmap_read,\n\t\t.write = af9015_regmap_write,\n\t};\n\n\tdev_dbg(&intf->dev, \"\\n\");\n\n\tmemset(manufacturer, 0, sizeof(manufacturer));\n\tusb_string(udev, udev->descriptor.iManufacturer,\n\t\t   manufacturer, sizeof(manufacturer));\n\t \n\tif ((le16_to_cpu(udev->descriptor.idVendor) == USB_VID_TERRATEC) &&\n\t    (le16_to_cpu(udev->descriptor.idProduct) == 0x0099)) {\n\t\tif (!strcmp(\"ITE Technologies, Inc.\", manufacturer)) {\n\t\t\tret = -ENODEV;\n\t\t\tdev_dbg(&intf->dev, \"rejecting device\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tstate->regmap = regmap_init(&intf->dev, &regmap_bus, d, &regmap_config);\n\tif (IS_ERR(state->regmap)) {\n\t\tret = PTR_ERR(state->regmap);\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&intf->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic void af9015_disconnect(struct dvb_usb_device *d)\n{\n\tstruct af9015_state *state = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\n\tdev_dbg(&intf->dev, \"\\n\");\n\n\tregmap_exit(state->regmap);\n}\n\n \nstatic const struct dvb_usb_device_properties af9015_props = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\t.size_of_priv = sizeof(struct af9015_state),\n\n\t.generic_bulk_ctrl_endpoint = 0x02,\n\t.generic_bulk_ctrl_endpoint_response = 0x81,\n\n\t.probe = af9015_probe,\n\t.disconnect = af9015_disconnect,\n\t.identify_state = af9015_identify_state,\n\t.firmware = AF9015_FIRMWARE,\n\t.download_firmware = af9015_download_firmware,\n\n\t.i2c_algo = &af9015_i2c_algo,\n\t.read_config = af9015_read_config,\n\t.frontend_attach = af9015_af9013_frontend_attach,\n\t.frontend_detach = af9015_frontend_detach,\n\t.tuner_attach = af9015_tuner_attach,\n\t.init = af9015_init,\n\t.get_rc_config = af9015_get_rc_config,\n\t.get_stream_config = af9015_get_stream_config,\n\t.streaming_ctrl = af9015_streaming_ctrl,\n\n\t.get_adapter_count = af9015_get_adapter_count,\n\t.adapter = {\n\t\t{\n\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t.pid_filter_count = 32,\n\t\t\t.pid_filter = af9015_pid_filter,\n\t\t\t.pid_filter_ctrl = af9015_pid_filter_ctrl,\n\n\t\t\t.stream = DVB_USB_STREAM_BULK(0x84, 6, 87 * 188),\n\t\t}, {\n\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t.pid_filter_count = 32,\n\t\t\t.pid_filter = af9015_pid_filter,\n\t\t\t.pid_filter_ctrl = af9015_pid_filter_ctrl,\n\n\t\t\t.stream = DVB_USB_STREAM_BULK(0x85, 6, 87 * 188),\n\t\t},\n\t},\n};\n\nstatic const struct usb_device_id af9015_id_table[] = {\n\t{ DVB_USB_DEVICE(USB_VID_AFATECH, USB_PID_AFATECH_AF9015_9015,\n\t\t&af9015_props, \"Afatech AF9015 reference design\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_AFATECH, USB_PID_AFATECH_AF9015_9016,\n\t\t&af9015_props, \"Afatech AF9015 reference design\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_LEADTEK, USB_PID_WINFAST_DTV_DONGLE_GOLD,\n\t\t&af9015_props, \"Leadtek WinFast DTV Dongle Gold\", RC_MAP_LEADTEK_Y04G0051) },\n\t{ DVB_USB_DEVICE(USB_VID_PINNACLE, USB_PID_PINNACLE_PCTV71E,\n\t\t&af9015_props, \"Pinnacle PCTV 71e\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_399U,\n\t\t&af9015_props, \"KWorld PlusTV Dual DVB-T Stick (DVB-T 399U)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_VISIONPLUS, USB_PID_TINYTWIN,\n\t\t&af9015_props, \"DigitalNow TinyTwin\", RC_MAP_AZUREWAVE_AD_TU700) },\n\t{ DVB_USB_DEVICE(USB_VID_VISIONPLUS, USB_PID_AZUREWAVE_AD_TU700,\n\t\t&af9015_props, \"TwinHan AzureWave AD-TU700(704J)\", RC_MAP_AZUREWAVE_AD_TU700) },\n\t{ DVB_USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_T_USB_XE_REV2,\n\t\t&af9015_props, \"TerraTec Cinergy T USB XE\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_PC160_2T,\n\t\t&af9015_props, \"KWorld PlusTV Dual DVB-T PCI (DVB-T PC160-2T)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_VOLAR_X,\n\t\t&af9015_props, \"AVerMedia AVerTV DVB-T Volar X\", RC_MAP_AVERMEDIA_M135A) },\n\t{ DVB_USB_DEVICE(USB_VID_XTENSIONS, USB_PID_XTENSIONS_XD_380,\n\t\t&af9015_props, \"Xtensions XD-380\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_MSI_2, USB_PID_MSI_DIGIVOX_DUO,\n\t\t&af9015_props, \"MSI DIGIVOX Duo\", RC_MAP_MSI_DIGIVOX_III) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_VOLAR_X_2,\n\t\t&af9015_props, \"Fujitsu-Siemens Slim Mobile USB DVB-T\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_TELESTAR,  USB_PID_TELESTAR_STARSTICK_2,\n\t\t&af9015_props, \"Telestar Starstick 2\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_A309,\n\t\t&af9015_props, \"AVerMedia A309\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_MSI_2, USB_PID_MSI_DIGI_VOX_MINI_III,\n\t\t&af9015_props, \"MSI Digi VOX mini III\", RC_MAP_MSI_DIGIVOX_III) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_395U,\n\t\t&af9015_props, \"KWorld USB DVB-T TV Stick II (VS-DVB-T 395U)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_395U_2,\n\t\t&af9015_props, \"KWorld USB DVB-T TV Stick II (VS-DVB-T 395U)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_395U_3,\n\t\t&af9015_props, \"KWorld USB DVB-T TV Stick II (VS-DVB-T 395U)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_AFATECH, USB_PID_TREKSTOR_DVBT,\n\t\t&af9015_props, \"TrekStor DVB-T USB Stick\", RC_MAP_TREKSTOR) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_A850,\n\t\t&af9015_props, \"AverMedia AVerTV Volar Black HD (A850)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_A805,\n\t\t&af9015_props, \"AverMedia AVerTV Volar GPS 805 (A805)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_CONCEPTRONIC_CTVDIGRCU,\n\t\t&af9015_props, \"Conceptronic USB2.0 DVB-T CTVDIGRCU V3.0\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_MC810,\n\t\t&af9015_props, \"KWorld Digital MC-810\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KYE, USB_PID_GENIUS_TVGO_DVB_T03,\n\t\t&af9015_props, \"Genius TVGo DVB-T03\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_399U_2,\n\t\t&af9015_props, \"KWorld PlusTV Dual DVB-T Stick (DVB-T 399U)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_PC160_T,\n\t\t&af9015_props, \"KWorld PlusTV DVB-T PCI Pro Card (DVB-T PC160-T)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_SVEON_STV20,\n\t\t&af9015_props, \"Sveon STV20 Tuner USB DVB-T HDTV\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_TINYTWIN_2,\n\t\t&af9015_props, \"DigitalNow TinyTwin v2\", RC_MAP_DIGITALNOW_TINYTWIN) },\n\t{ DVB_USB_DEVICE(USB_VID_LEADTEK, USB_PID_WINFAST_DTV2000DS,\n\t\t&af9015_props, \"Leadtek WinFast DTV2000DS\", RC_MAP_LEADTEK_Y04G0051) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_UB383_T,\n\t\t&af9015_props, \"KWorld USB DVB-T Stick Mobile (UB383-T)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_395U_4,\n\t\t&af9015_props, \"KWorld USB DVB-T TV Stick II (VS-DVB-T 395U)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_A815M,\n\t\t&af9015_props, \"AverMedia AVerTV Volar M (A815Mac)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_T_STICK_RC,\n\t\t&af9015_props, \"TerraTec Cinergy T Stick RC\", RC_MAP_TERRATEC_SLIM_2) },\n\t \n\t{ DVB_USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_T_STICK_DUAL_RC,\n\t\t&af9015_props, \"TerraTec Cinergy T Stick Dual RC\", RC_MAP_TERRATEC_SLIM) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_A850T,\n\t\t&af9015_props, \"AverMedia AVerTV Red HD+ (A850T)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_GTEK, USB_PID_TINYTWIN_3,\n\t\t&af9015_props, \"DigitalNow TinyTwin v3\", RC_MAP_DIGITALNOW_TINYTWIN) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_SVEON_STV22,\n\t\t&af9015_props, \"Sveon STV22 Dual USB DVB-T Tuner HDTV\", RC_MAP_MSI_DIGIVOX_III) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, af9015_id_table);\n\n \nstatic struct usb_driver af9015_usb_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = af9015_id_table,\n\t.probe = dvb_usbv2_probe,\n\t.disconnect = dvb_usbv2_disconnect,\n\t.suspend = dvb_usbv2_suspend,\n\t.resume = dvb_usbv2_resume,\n\t.reset_resume = dvb_usbv2_reset_resume,\n\t.no_dynamic_id = 1,\n\t.soft_unbind = 1,\n};\n\nmodule_usb_driver(af9015_usb_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"Afatech AF9015 driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(AF9015_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}