{
  "module_name": "mxl111sf-tuner.c",
  "hash_id": "0b76a24d68bdf600bc64150c06de0d810411a78fa104ca607a7804ee3aa6d20b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/mxl111sf-tuner.c",
  "human_readable_source": "\n \n\n#include \"mxl111sf-tuner.h\"\n#include \"mxl111sf-phy.h\"\n#include \"mxl111sf-reg.h\"\n\n \nstatic int mxl111sf_tuner_debug;\nmodule_param_named(debug, mxl111sf_tuner_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=info (or-able)).\");\n\n#define mxl_dbg(fmt, arg...) \\\n\tif (mxl111sf_tuner_debug) \\\n\t\tmxl_printk(KERN_DEBUG, fmt, ##arg)\n\n \n\nstruct mxl111sf_tuner_state {\n\tstruct mxl111sf_state *mxl_state;\n\n\tconst struct mxl111sf_tuner_config *cfg;\n\n\tenum mxl_if_freq if_freq;\n\n\tu32 frequency;\n\tu32 bandwidth;\n};\n\nstatic int mxl111sf_tuner_read_reg(struct mxl111sf_tuner_state *state,\n\t\t\t\t   u8 addr, u8 *data)\n{\n\treturn (state->cfg->read_reg) ?\n\t\tstate->cfg->read_reg(state->mxl_state, addr, data) :\n\t\t-EINVAL;\n}\n\nstatic int mxl111sf_tuner_write_reg(struct mxl111sf_tuner_state *state,\n\t\t\t\t    u8 addr, u8 data)\n{\n\treturn (state->cfg->write_reg) ?\n\t\tstate->cfg->write_reg(state->mxl_state, addr, data) :\n\t\t-EINVAL;\n}\n\nstatic int mxl111sf_tuner_program_regs(struct mxl111sf_tuner_state *state,\n\t\t\t       struct mxl111sf_reg_ctrl_info *ctrl_reg_info)\n{\n\treturn (state->cfg->program_regs) ?\n\t\tstate->cfg->program_regs(state->mxl_state, ctrl_reg_info) :\n\t\t-EINVAL;\n}\n\nstatic int mxl1x1sf_tuner_top_master_ctrl(struct mxl111sf_tuner_state *state,\n\t\t\t\t\t  int onoff)\n{\n\treturn (state->cfg->top_master_ctrl) ?\n\t\tstate->cfg->top_master_ctrl(state->mxl_state, onoff) :\n\t\t-EINVAL;\n}\n\n \n\nstatic struct mxl111sf_reg_ctrl_info mxl_phy_tune_rf[] = {\n\t{0x1d, 0x7f, 0x00},  \n\t{0x1e, 0xff, 0x00},  \n\t{0x1f, 0xff, 0x00},  \n\t{0,    0,    0}\n};\n\n \n\nstatic struct mxl111sf_reg_ctrl_info *mxl111sf_calc_phy_tune_regs(u32 freq,\n\t\t\t\t\t\t\t\t  u8 bw)\n{\n\tu8 filt_bw;\n\n\t \n\tswitch (bw) {\n\tcase 0:  \n\t\tfilt_bw = 25;\n\t\tbreak;\n\tcase 1:  \n\t\tfilt_bw = 69;\n\t\tbreak;\n\tcase 6:\n\t\tfilt_bw = 21;\n\t\tbreak;\n\tcase 7:\n\t\tfilt_bw = 42;\n\t\tbreak;\n\tcase 8:\n\t\tfilt_bw = 63;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: invalid bandwidth setting!\", __func__);\n\t\treturn NULL;\n\t}\n\n\t \n\tfreq /= 1000000;\n\n\tfreq *= 64;\n#if 0\n\t \n\tfreq += 0.5;\n#endif\n\t \n\tmxl_phy_tune_rf[0].data = filt_bw;\n\n\t \n\tmxl_phy_tune_rf[1].data = (freq & 0xff);\n\tmxl_phy_tune_rf[2].data = (freq >> 8) & 0xff;\n\n\t \n\treturn mxl_phy_tune_rf;\n}\n\nstatic int mxl1x1sf_tuner_set_if_output_freq(struct mxl111sf_tuner_state *state)\n{\n\tint ret;\n\tu8 ctrl;\n#if 0\n\tu16 iffcw;\n\tu32 if_freq;\n#endif\n\tmxl_dbg(\"(IF polarity = %d, IF freq = 0x%02x)\",\n\t\tstate->cfg->invert_spectrum, state->cfg->if_freq);\n\n\t \n\tctrl = state->cfg->invert_spectrum;\n\n\tctrl |= state->cfg->if_freq;\n\n\tret = mxl111sf_tuner_write_reg(state, V6_TUNER_IF_SEL_REG, ctrl);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n#if 0\n\tif_freq /= 1000000;\n\n\t \n\tif_freq += 0.5;\n\n\tif (MXL_IF_LO == state->cfg->if_freq) {\n\t\tctrl = 0x08;\n\t\tiffcw = (u16)(if_freq / (108 * 4096));\n\t} else if (MXL_IF_HI == state->cfg->if_freq) {\n\t\tctrl = 0x08;\n\t\tiffcw = (u16)(if_freq / (216 * 4096));\n\t} else {\n\t\tctrl = 0;\n\t\tiffcw = 0;\n\t}\n\n\tctrl |= (iffcw >> 8);\n#endif\n\tret = mxl111sf_tuner_read_reg(state, V6_TUNER_IF_FCW_BYP_REG, &ctrl);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tctrl &= 0xf0;\n\tctrl |= 0x90;\n\n\tret = mxl111sf_tuner_write_reg(state, V6_TUNER_IF_FCW_BYP_REG, ctrl);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n#if 0\n\tctrl = iffcw & 0x00ff;\n#endif\n\tret = mxl111sf_tuner_write_reg(state, V6_TUNER_IF_FCW_REG, ctrl);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tstate->if_freq = state->cfg->if_freq;\nfail:\n\treturn ret;\n}\n\nstatic int mxl1x1sf_tune_rf(struct dvb_frontend *fe, u32 freq, u8 bw)\n{\n\tstruct mxl111sf_tuner_state *state = fe->tuner_priv;\n\tstatic struct mxl111sf_reg_ctrl_info *reg_ctrl_array;\n\tint ret;\n\tu8 mxl_mode;\n\n\tmxl_dbg(\"(freq = %d, bw = 0x%x)\", freq, bw);\n\n\t \n\tret = mxl111sf_tuner_write_reg(state, START_TUNE_REG, 0);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\t \n\tret = mxl111sf_tuner_read_reg(state, MXL_MODE_REG, &mxl_mode);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\t \n\treg_ctrl_array = mxl111sf_calc_phy_tune_regs(freq, bw);\n\tif (!reg_ctrl_array)\n\t\treturn -EINVAL;\n\n\tret = mxl111sf_tuner_program_regs(state, reg_ctrl_array);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tif ((mxl_mode & MXL_DEV_MODE_MASK) == MXL_TUNER_MODE) {\n\t\t \n\t\tmxl1x1sf_tuner_top_master_ctrl(state, 0);\n\t\tmxl1x1sf_tuner_top_master_ctrl(state, 1);\n\t\tmxl1x1sf_tuner_set_if_output_freq(state);\n\t}\n\n\tret = mxl111sf_tuner_write_reg(state, START_TUNE_REG, 1);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tif (state->cfg->ant_hunt)\n\t\tstate->cfg->ant_hunt(fe);\nfail:\n\treturn ret;\n}\n\nstatic int mxl1x1sf_tuner_get_lock_status(struct mxl111sf_tuner_state *state,\n\t\t\t\t\t  int *rf_synth_lock,\n\t\t\t\t\t  int *ref_synth_lock)\n{\n\tint ret;\n\tu8 data;\n\n\t*rf_synth_lock = 0;\n\t*ref_synth_lock = 0;\n\n\tret = mxl111sf_tuner_read_reg(state, V6_RF_LOCK_STATUS_REG, &data);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\t*ref_synth_lock = ((data & 0x03) == 0x03) ? 1 : 0;\n\t*rf_synth_lock  = ((data & 0x0c) == 0x0c) ? 1 : 0;\nfail:\n\treturn ret;\n}\n\n#if 0\nstatic int mxl1x1sf_tuner_loop_thru_ctrl(struct mxl111sf_tuner_state *state,\n\t\t\t\t\t int onoff)\n{\n\treturn mxl111sf_tuner_write_reg(state, V6_TUNER_LOOP_THRU_CTRL_REG,\n\t\t\t\t\tonoff ? 1 : 0);\n}\n#endif\n\n \n\nstatic int mxl111sf_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 delsys  = c->delivery_system;\n\tstruct mxl111sf_tuner_state *state = fe->tuner_priv;\n\tint ret;\n\tu8 bw;\n\n\tmxl_dbg(\"()\");\n\n\tswitch (delsys) {\n\tcase SYS_ATSC:\n\tcase SYS_ATSCMH:\n\t\tbw = 0;  \n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_B:\n\t\tbw = 1;  \n\t\tbreak;\n\tcase SYS_DVBT:\n\t\tswitch (c->bandwidth_hz) {\n\t\tcase 6000000:\n\t\t\tbw = 6;\n\t\t\tbreak;\n\t\tcase 7000000:\n\t\t\tbw = 7;\n\t\t\tbreak;\n\t\tcase 8000000:\n\t\t\tbw = 8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"%s: bandwidth not set!\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: modulation type not supported!\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tret = mxl1x1sf_tune_rf(fe, c->frequency, bw);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tstate->frequency = c->frequency;\n\tstate->bandwidth = c->bandwidth_hz;\nfail:\n\treturn ret;\n}\n\n \n\n#if 0\nstatic int mxl111sf_tuner_init(struct dvb_frontend *fe)\n{\n\tstruct mxl111sf_tuner_state *state = fe->tuner_priv;\n\tint ret;\n\n\t \n\n\treturn ret;\n}\n\nstatic int mxl111sf_tuner_sleep(struct dvb_frontend *fe)\n{\n\tstruct mxl111sf_tuner_state *state = fe->tuner_priv;\n\tint ret;\n\n\t \n\n\treturn ret;\n}\n#endif\n\n \n\nstatic int mxl111sf_tuner_get_status(struct dvb_frontend *fe, u32 *status)\n{\n\tstruct mxl111sf_tuner_state *state = fe->tuner_priv;\n\tint rf_locked, ref_locked, ret;\n\n\t*status = 0;\n\n\tret = mxl1x1sf_tuner_get_lock_status(state, &rf_locked, &ref_locked);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tmxl_info(\"%s%s\", rf_locked ? \"rf locked \" : \"\",\n\t\t ref_locked ? \"ref locked\" : \"\");\n\n\tif ((rf_locked) || (ref_locked))\n\t\t*status |= TUNER_STATUS_LOCKED;\nfail:\n\treturn ret;\n}\n\nstatic int mxl111sf_get_rf_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct mxl111sf_tuner_state *state = fe->tuner_priv;\n\tu8 val1, val2;\n\tint ret;\n\n\t*strength = 0;\n\n\tret = mxl111sf_tuner_write_reg(state, 0x00, 0x02);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_tuner_read_reg(state, V6_DIG_RF_PWR_LSB_REG, &val1);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_tuner_read_reg(state, V6_DIG_RF_PWR_MSB_REG, &val2);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\t*strength = val1 | ((val2 & 0x07) << 8);\nfail:\n\tret = mxl111sf_tuner_write_reg(state, 0x00, 0x00);\n\tmxl_fail(ret);\n\n\treturn ret;\n}\n\n \n\nstatic int mxl111sf_tuner_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct mxl111sf_tuner_state *state = fe->tuner_priv;\n\t*frequency = state->frequency;\n\treturn 0;\n}\n\nstatic int mxl111sf_tuner_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\n{\n\tstruct mxl111sf_tuner_state *state = fe->tuner_priv;\n\t*bandwidth = state->bandwidth;\n\treturn 0;\n}\n\nstatic int mxl111sf_tuner_get_if_frequency(struct dvb_frontend *fe,\n\t\t\t\t\t   u32 *frequency)\n{\n\tstruct mxl111sf_tuner_state *state = fe->tuner_priv;\n\n\t*frequency = 0;\n\n\tswitch (state->if_freq) {\n\tcase MXL_IF_4_0:    \n\t\t*frequency = 4000000;\n\t\tbreak;\n\tcase MXL_IF_4_5:    \n\t\t*frequency = 4500000;\n\t\tbreak;\n\tcase MXL_IF_4_57:   \n\t\t*frequency = 4570000;\n\t\tbreak;\n\tcase MXL_IF_5_0:    \n\t\t*frequency = 5000000;\n\t\tbreak;\n\tcase MXL_IF_5_38:   \n\t\t*frequency = 5380000;\n\t\tbreak;\n\tcase MXL_IF_6_0:    \n\t\t*frequency = 6000000;\n\t\tbreak;\n\tcase MXL_IF_6_28:   \n\t\t*frequency = 6280000;\n\t\tbreak;\n\tcase MXL_IF_7_2:    \n\t\t*frequency = 7200000;\n\t\tbreak;\n\tcase MXL_IF_35_25:  \n\t\t*frequency = 35250000;\n\t\tbreak;\n\tcase MXL_IF_36:     \n\t\t*frequency = 36000000;\n\t\tbreak;\n\tcase MXL_IF_36_15:  \n\t\t*frequency = 36150000;\n\t\tbreak;\n\tcase MXL_IF_44:     \n\t\t*frequency = 44000000;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void mxl111sf_tuner_release(struct dvb_frontend *fe)\n{\n\tstruct mxl111sf_tuner_state *state = fe->tuner_priv;\n\tmxl_dbg(\"()\");\n\tkfree(state);\n\tfe->tuner_priv = NULL;\n}\n\n \n\nstatic const struct dvb_tuner_ops mxl111sf_tuner_tuner_ops = {\n\t.info = {\n\t\t.name = \"MaxLinear MxL111SF\",\n#if 0\n\t\t.frequency_min_hz  = ,\n\t\t.frequency_max_hz  = ,\n\t\t.frequency_step_hz = ,\n#endif\n\t},\n#if 0\n\t.init              = mxl111sf_tuner_init,\n\t.sleep             = mxl111sf_tuner_sleep,\n#endif\n\t.set_params        = mxl111sf_tuner_set_params,\n\t.get_status        = mxl111sf_tuner_get_status,\n\t.get_rf_strength   = mxl111sf_get_rf_strength,\n\t.get_frequency     = mxl111sf_tuner_get_frequency,\n\t.get_bandwidth     = mxl111sf_tuner_get_bandwidth,\n\t.get_if_frequency  = mxl111sf_tuner_get_if_frequency,\n\t.release           = mxl111sf_tuner_release,\n};\n\nstruct dvb_frontend *mxl111sf_tuner_attach(struct dvb_frontend *fe,\n\t\t\t\tstruct mxl111sf_state *mxl_state,\n\t\t\t\tconst struct mxl111sf_tuner_config *cfg)\n{\n\tstruct mxl111sf_tuner_state *state = NULL;\n\n\tmxl_dbg(\"()\");\n\n\tstate = kzalloc(sizeof(struct mxl111sf_tuner_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn NULL;\n\n\tstate->mxl_state = mxl_state;\n\tstate->cfg = cfg;\n\n\tmemcpy(&fe->ops.tuner_ops, &mxl111sf_tuner_tuner_ops,\n\t       sizeof(struct dvb_tuner_ops));\n\n\tfe->tuner_priv = state;\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(mxl111sf_tuner_attach);\n\nMODULE_DESCRIPTION(\"MaxLinear MxL111SF CMOS tuner driver\");\nMODULE_AUTHOR(\"Michael Krufky <mkrufky@linuxtv.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.1\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}