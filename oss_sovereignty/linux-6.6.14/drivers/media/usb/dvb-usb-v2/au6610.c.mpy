{
  "module_name": "au6610.c",
  "hash_id": "293b2120eeebb752bffa8c5af93b3b1dee5eb0abbd12c51ebc109bdfdac304d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/au6610.c",
  "human_readable_source": "\n \n\n#include \"au6610.h\"\n#include \"zl10353.h\"\n#include \"qt1010.h\"\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic int au6610_usb_msg(struct dvb_usb_device *d, u8 operation, u8 addr,\n\t\t\t  u8 *wbuf, u16 wlen, u8 *rbuf, u16 rlen)\n{\n\tint ret;\n\tu16 index;\n\tu8 *usb_buf;\n\n\t \n\tusb_buf = kmalloc(6, GFP_KERNEL);\n\tif (!usb_buf)\n\t\treturn -ENOMEM;\n\n\tswitch (wlen) {\n\tcase 1:\n\t\tindex = wbuf[0] << 8;\n\t\tbreak;\n\tcase 2:\n\t\tindex = wbuf[0] << 8;\n\t\tindex += wbuf[1];\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&d->udev->dev, \"%s: wlen=%d, aborting\\n\",\n\t\t\t\tKBUILD_MODNAME, wlen);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tret = usb_control_msg(d->udev, usb_rcvctrlpipe(d->udev, 0), operation,\n\t\t\t      USB_TYPE_VENDOR|USB_DIR_IN, addr << 1, index,\n\t\t\t      usb_buf, 6, AU6610_USB_TIMEOUT);\n\n\tdvb_usb_dbg_usb_control_msg(d->udev, operation,\n\t\t\t(USB_TYPE_VENDOR|USB_DIR_IN), addr << 1, index,\n\t\t\tusb_buf, 6);\n\n\tif (ret < 0)\n\t\tgoto error;\n\n\tswitch (operation) {\n\tcase AU6610_REQ_I2C_READ:\n\tcase AU6610_REQ_USB_READ:\n\t\t \n\t\trbuf[0] = usb_buf[4];\n\t}\nerror:\n\tkfree(usb_buf);\n\treturn ret;\n}\n\nstatic int au6610_i2c_msg(struct dvb_usb_device *d, u8 addr,\n\t\t\t  u8 *wbuf, u16 wlen, u8 *rbuf, u16 rlen)\n{\n\tu8 request;\n\tu8 wo = (rbuf == NULL || rlen == 0);  \n\n\tif (wo) {\n\t\trequest = AU6610_REQ_I2C_WRITE;\n\t} else {  \n\t\trequest = AU6610_REQ_I2C_READ;\n\t}\n\n\treturn au6610_usb_msg(d, request, addr, wbuf, wlen, rbuf, rlen);\n}\n\n\n \nstatic int au6610_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t   int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint i;\n\n\tif (num > 2)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tfor (i = 0; i < num; i++) {\n\t\t \n\t\tif (i+1 < num && (msg[i+1].flags & I2C_M_RD)) {\n\t\t\tif (au6610_i2c_msg(d, msg[i].addr, msg[i].buf,\n\t\t\t\t\t   msg[i].len, msg[i+1].buf,\n\t\t\t\t\t   msg[i+1].len) < 0)\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t} else if (au6610_i2c_msg(d, msg[i].addr, msg[i].buf,\n\t\t\t\t\t       msg[i].len, NULL, 0) < 0)\n\t\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&d->i2c_mutex);\n\treturn i;\n}\n\n\nstatic u32 au6610_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm au6610_i2c_algo = {\n\t.master_xfer   = au6610_i2c_xfer,\n\t.functionality = au6610_i2c_func,\n};\n\n \nstatic struct zl10353_config au6610_zl10353_config = {\n\t.demod_address = 0x0f,\n\t.no_tuner = 1,\n\t.parallel_ts = 1,\n};\n\nstatic int au6610_zl10353_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tadap->fe[0] = dvb_attach(zl10353_attach, &au6610_zl10353_config,\n\t\t\t&adap_to_d(adap)->i2c_adap);\n\tif (adap->fe[0] == NULL)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic struct qt1010_config au6610_qt1010_config = {\n\t.i2c_address = 0x62\n};\n\nstatic int au6610_qt1010_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\treturn dvb_attach(qt1010_attach, adap->fe[0],\n\t\t\t&adap_to_d(adap)->i2c_adap,\n\t\t\t&au6610_qt1010_config) == NULL ? -ENODEV : 0;\n}\n\nstatic int au6610_init(struct dvb_usb_device *d)\n{\n\t \n\t \n\treturn usb_set_interface(d->udev, 0, 5);\n}\n\nstatic struct dvb_usb_device_properties au6610_props = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\n\t.i2c_algo = &au6610_i2c_algo,\n\t.frontend_attach = au6610_zl10353_frontend_attach,\n\t.tuner_attach = au6610_qt1010_tuner_attach,\n\t.init = au6610_init,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t\t.stream = DVB_USB_STREAM_ISOC(0x82, 5, 40, 942, 1),\n\t\t},\n\t},\n};\n\nstatic const struct usb_device_id au6610_id_table[] = {\n\t{ DVB_USB_DEVICE(USB_VID_ALCOR_MICRO, USB_PID_SIGMATEK_DVB_110,\n\t\t&au6610_props, \"Sigmatek DVB-110\", NULL) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, au6610_id_table);\n\nstatic struct usb_driver au6610_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = au6610_id_table,\n\t.probe = dvb_usbv2_probe,\n\t.disconnect = dvb_usbv2_disconnect,\n\t.suspend = dvb_usbv2_suspend,\n\t.resume = dvb_usbv2_resume,\n\t.reset_resume = dvb_usbv2_reset_resume,\n\t.no_dynamic_id = 1,\n\t.soft_unbind = 1,\n};\n\nmodule_usb_driver(au6610_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"Driver for Alcor Micro AU6610 DVB-T USB2.0\");\nMODULE_VERSION(\"0.1\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}