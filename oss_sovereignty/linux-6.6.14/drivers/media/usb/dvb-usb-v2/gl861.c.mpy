{
  "module_name": "gl861.c",
  "hash_id": "98d78dc7920c4f0e275da4e565c9c4d407b7e39bc3f55334d4541c7b3d1b6e24",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/gl861.c",
  "human_readable_source": "\n \n#include <linux/string.h>\n\n#include \"dvb_usb.h\"\n\n#include \"zl10353.h\"\n#include \"qt1010.h\"\n#include \"tc90522.h\"\n#include \"dvb-pll.h\"\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstruct gl861 {\n\t \n\tu8 buf[16];\n\n\tstruct i2c_adapter *demod_sub_i2c;\n\tstruct i2c_client  *i2c_client_demod;\n\tstruct i2c_client  *i2c_client_tuner;\n};\n\n#define CMD_WRITE_SHORT     0x01\n#define CMD_READ            0x02\n#define CMD_WRITE           0x03\n\nstatic int gl861_ctrl_msg(struct dvb_usb_device *d, u8 request, u16 value,\n\t\t\t  u16 index, void *data, u16 size)\n{\n\tstruct gl861 *ctx = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\tint ret;\n\tunsigned int pipe;\n\tu8 requesttype;\n\n\tmutex_lock(&d->usb_mutex);\n\n\tswitch (request) {\n\tcase CMD_WRITE:\n\t\tmemcpy(ctx->buf, data, size);\n\t\tfallthrough;\n\tcase CMD_WRITE_SHORT:\n\t\tpipe = usb_sndctrlpipe(d->udev, 0);\n\t\trequesttype = USB_TYPE_VENDOR | USB_DIR_OUT;\n\t\tbreak;\n\tcase CMD_READ:\n\t\tpipe = usb_rcvctrlpipe(d->udev, 0);\n\t\trequesttype = USB_TYPE_VENDOR | USB_DIR_IN;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err_mutex_unlock;\n\t}\n\n\tret = usb_control_msg(d->udev, pipe, request, requesttype, value,\n\t\t\t      index, ctx->buf, size, 200);\n\tdev_dbg(&intf->dev, \"%d | %02x %02x %*ph %*ph %*ph %s %*ph\\n\",\n\t\tret, requesttype, request, 2, &value, 2, &index, 2, &size,\n\t\t(requesttype & USB_DIR_IN) ? \"<<<\" : \">>>\", size, ctx->buf);\n\tif (ret < 0)\n\t\tgoto err_mutex_unlock;\n\n\tif (request == CMD_READ)\n\t\tmemcpy(data, ctx->buf, size);\n\n\tusleep_range(1000, 2000);  \n\n\tmutex_unlock(&d->usb_mutex);\n\n\treturn 0;\n\nerr_mutex_unlock:\n\tmutex_unlock(&d->usb_mutex);\n\tdev_dbg(&intf->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int gl861_short_write(struct dvb_usb_device *d, u8 addr, u8 reg, u8 val)\n{\n\treturn gl861_ctrl_msg(d, CMD_WRITE_SHORT,\n\t\t\t      (addr << 9) | val, reg, NULL, 0);\n}\n\nstatic int gl861_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t\t int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstruct usb_interface *intf = d->intf;\n\tstruct gl861 *ctx = d_to_priv(d);\n\tint ret;\n\tu8 request, *data;\n\tu16 value, index, size;\n\n\t \n\tif (num == 1 && !(msg[0].flags & I2C_M_RD)) {\n\t\t \n\t\tif (msg[0].len < 2 || msg[0].len > sizeof(ctx->buf)) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto err;\n\t\t}\n\n\t\tvalue = (msg[0].addr << 1) << 8;\n\t\tindex = msg[0].buf[0];\n\n\t\tif (msg[0].len == 2) {\n\t\t\trequest = CMD_WRITE_SHORT;\n\t\t\tvalue |= msg[0].buf[1];\n\t\t\tsize = 0;\n\t\t\tdata = NULL;\n\t\t} else {\n\t\t\trequest = CMD_WRITE;\n\t\t\tsize = msg[0].len - 1;\n\t\t\tdata = &msg[0].buf[1];\n\t\t}\n\n\t\tret = gl861_ctrl_msg(d, request, value, index, data, size);\n\t} else if (num == 2 && !(msg[0].flags & I2C_M_RD) &&\n\t\t   (msg[1].flags & I2C_M_RD)) {\n\t\t \n\t\tif (msg[0].len != 1 || msg[1].len > sizeof(ctx->buf)) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto err;\n\t\t}\n\n\t\tvalue = (msg[0].addr << 1) << 8;\n\t\tindex = msg[0].buf[0];\n\t\trequest = CMD_READ;\n\n\t\tret = gl861_ctrl_msg(d, request, value, index,\n\t\t\t\t     msg[1].buf, msg[1].len);\n\t} else if (num == 1 && (msg[0].flags & I2C_M_RD)) {\n\t\t \n\t\tif (msg[0].len > sizeof(ctx->buf)) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto err;\n\t\t}\n\t\tvalue = (msg[0].addr << 1) << 8;\n\t\tindex = 0x0100;\n\t\trequest = CMD_READ;\n\n\t\tret = gl861_ctrl_msg(d, request, value, index,\n\t\t\t\t     msg[0].buf, msg[0].len);\n\t} else {\n\t\t \n\t\tdev_dbg(&intf->dev, \"unknown i2c msg, num %u\\n\", num);\n\t\tret = -EOPNOTSUPP;\n\t}\n\tif (ret)\n\t\tgoto err;\n\n\treturn num;\nerr:\n\tdev_dbg(&intf->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic u32 gl861_i2c_functionality(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm gl861_i2c_algo = {\n\t.master_xfer   = gl861_i2c_master_xfer,\n\t.functionality = gl861_i2c_functionality,\n};\n\n \nstatic struct zl10353_config gl861_zl10353_config = {\n\t.demod_address = 0x0f,\n\t.no_tuner = 1,\n\t.parallel_ts = 1,\n};\n\nstatic int gl861_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\n\tadap->fe[0] = dvb_attach(zl10353_attach, &gl861_zl10353_config,\n\t\t&adap_to_d(adap)->i2c_adap);\n\tif (adap->fe[0] == NULL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic struct qt1010_config gl861_qt1010_config = {\n\t.i2c_address = 0x62\n};\n\nstatic int gl861_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\treturn dvb_attach(qt1010_attach,\n\t\t\t  adap->fe[0], &adap_to_d(adap)->i2c_adap,\n\t\t\t  &gl861_qt1010_config) == NULL ? -ENODEV : 0;\n}\n\nstatic int gl861_init(struct dvb_usb_device *d)\n{\n\t \n\treturn usb_set_interface(d->udev, 0, 0);\n}\n\n \nstatic struct dvb_usb_device_properties gl861_props = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\n\t.size_of_priv = sizeof(struct gl861),\n\n\t.i2c_algo = &gl861_i2c_algo,\n\t.frontend_attach = gl861_frontend_attach,\n\t.tuner_attach = gl861_tuner_attach,\n\t.init = gl861_init,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t\t.stream = DVB_USB_STREAM_BULK(0x81, 7, 512),\n\t\t}\n\t}\n};\n\n\n \nstruct friio_config {\n\tstruct i2c_board_info demod_info;\n\tstruct tc90522_config demod_cfg;\n\n\tstruct i2c_board_info tuner_info;\n\tstruct dvb_pll_config tuner_cfg;\n};\n\nstatic const struct friio_config friio_config = {\n\t.demod_info = { I2C_BOARD_INFO(TC90522_I2C_DEV_TER, 0x18), },\n\t.demod_cfg = { .split_tuner_read_i2c = true, },\n\t.tuner_info = { I2C_BOARD_INFO(\"tua6034_friio\", 0x60), },\n};\n\n\n \n\n#define FRIIO_CTL_LNB (1 << 0)\n#define FRIIO_CTL_STROBE (1 << 1)\n#define FRIIO_CTL_CLK (1 << 2)\n#define FRIIO_CTL_LED (1 << 3)\n\n#define FRIIO_LED_RUNNING 0x6400ff64\n#define FRIIO_LED_STOPPED 0x96ff00ff\n\n \nstatic int friio_ext_ctl(struct dvb_usb_device *d,\n\t\t\t    u32 sat_color, int power_on)\n{\n\tint i, ret;\n\tstruct i2c_msg msg;\n\tu8 *buf;\n\tu32 mask;\n\tu8 power = (power_on) ? FRIIO_CTL_LNB : 0;\n\n\tbuf = kmalloc(2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmsg.addr = 0x00;\n\tmsg.flags = 0;\n\tmsg.len = 2;\n\tmsg.buf = buf;\n\tbuf[0] = 0x00;\n\n\t \n\tbuf[1] = power | FRIIO_CTL_LED | FRIIO_CTL_STROBE;\n\tret = i2c_transfer(&d->i2c_adap, &msg, 1);\n\tbuf[1] |= FRIIO_CTL_CLK;\n\tret += i2c_transfer(&d->i2c_adap, &msg, 1);\n\n\tbuf[1] = power | FRIIO_CTL_STROBE;\n\tret += i2c_transfer(&d->i2c_adap, &msg, 1);\n\tbuf[1] |= FRIIO_CTL_CLK;\n\tret += i2c_transfer(&d->i2c_adap, &msg, 1);\n\n\t \n\tmask = 1UL << 31;\n\tfor (i = 0; i < 32; i++) {\n\t\tbuf[1] = power | FRIIO_CTL_STROBE;\n\t\tif (sat_color & mask)\n\t\t\tbuf[1] |= FRIIO_CTL_LED;\n\t\tret += i2c_transfer(&d->i2c_adap, &msg, 1);\n\t\tbuf[1] |= FRIIO_CTL_CLK;\n\t\tret += i2c_transfer(&d->i2c_adap, &msg, 1);\n\t\tmask >>= 1;\n\t}\n\n\t \n\tbuf[1] = power;\n\tret += i2c_transfer(&d->i2c_adap, &msg, 1);\n\tbuf[1] |= FRIIO_CTL_CLK;\n\tret += i2c_transfer(&d->i2c_adap, &msg, 1);\n\n\tkfree(buf);\n\treturn (ret == 70) ? 0 : -EREMOTEIO;\n}\n\n \n \nstatic int friio_reset(struct dvb_usb_device *d)\n{\n\tint i, ret;\n\tu8 wbuf[1], rbuf[2];\n\n\tstatic const u8 friio_init_cmds[][2] = {\n\t\t{0x33, 0x08}, {0x37, 0x40}, {0x3a, 0x1f}, {0x3b, 0xff},\n\t\t{0x3c, 0x1f}, {0x3d, 0xff}, {0x38, 0x00}, {0x35, 0x00},\n\t\t{0x39, 0x00}, {0x36, 0x00},\n\t};\n\n\tret = usb_set_interface(d->udev, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = gl861_short_write(d, 0x00, 0x11, 0x02);\n\tif (ret < 0)\n\t\treturn ret;\n\tusleep_range(2000, 3000);\n\n\tret = gl861_short_write(d, 0x00, 0x11, 0x00);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\n\tusleep_range(1000, 2000);\n\twbuf[0] = 0x80;\n\tret = gl861_ctrl_msg(d, CMD_WRITE, 0x09 << 9, 0x03, wbuf, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(2000, 3000);\n\tret = gl861_ctrl_msg(d, CMD_READ, 0x09 << 9, 0x0100, rbuf, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (rbuf[0] != 0xff || rbuf[1] != 0xff)\n\t\treturn -ENODEV;\n\n\n\tusleep_range(1000, 2000);\n\twbuf[0] = 0x80;\n\tret = gl861_ctrl_msg(d, CMD_WRITE, 0x48 << 9, 0x03, wbuf, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(2000, 3000);\n\tret = gl861_ctrl_msg(d, CMD_READ, 0x48 << 9, 0x0100, rbuf, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (rbuf[0] != 0xff || rbuf[1] != 0xff)\n\t\treturn -ENODEV;\n\n\tret = gl861_short_write(d, 0x00, 0x30, 0x04);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = gl861_short_write(d, 0x00, 0x00, 0x01);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = gl861_short_write(d, 0x00, 0x06, 0x0f);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(friio_init_cmds); i++) {\n\t\tret = gl861_short_write(d, 0x00, friio_init_cmds[i][0],\n\t\t\t\t\tfriio_init_cmds[i][1]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int friio_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\treturn onoff ? friio_reset(d) : 0;\n}\n\nstatic int friio_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tconst struct i2c_board_info *info;\n\tstruct dvb_usb_device *d;\n\tstruct tc90522_config cfg;\n\tstruct i2c_client *cl;\n\tstruct gl861 *priv;\n\n\tinfo = &friio_config.demod_info;\n\tcfg = friio_config.demod_cfg;\n\td = adap_to_d(adap);\n\tcl = dvb_module_probe(\"tc90522\", info->type,\n\t\t\t      &d->i2c_adap, info->addr, &cfg);\n\tif (!cl)\n\t\treturn -ENODEV;\n\tadap->fe[0] = cfg.fe;\n\n\tpriv = adap_to_priv(adap);\n\tpriv->i2c_client_demod = cl;\n\tpriv->demod_sub_i2c = cfg.tuner_i2c;\n\treturn 0;\n}\n\nstatic int friio_frontend_detach(struct dvb_usb_adapter *adap)\n{\n\tstruct gl861 *priv;\n\n\tpriv = adap_to_priv(adap);\n\tdvb_module_release(priv->i2c_client_demod);\n\treturn 0;\n}\n\nstatic int friio_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tconst struct i2c_board_info *info;\n\tstruct dvb_pll_config cfg;\n\tstruct i2c_client *cl;\n\tstruct gl861 *priv;\n\n\tpriv = adap_to_priv(adap);\n\tinfo = &friio_config.tuner_info;\n\tcfg = friio_config.tuner_cfg;\n\tcfg.fe = adap->fe[0];\n\n\tcl = dvb_module_probe(\"dvb_pll\", info->type,\n\t\t\t      priv->demod_sub_i2c, info->addr, &cfg);\n\tif (!cl)\n\t\treturn -ENODEV;\n\tpriv->i2c_client_tuner = cl;\n\treturn 0;\n}\n\nstatic int friio_tuner_detach(struct dvb_usb_adapter *adap)\n{\n\tstruct gl861 *priv;\n\n\tpriv = adap_to_priv(adap);\n\tdvb_module_release(priv->i2c_client_tuner);\n\treturn 0;\n}\n\nstatic int friio_init(struct dvb_usb_device *d)\n{\n\tint i;\n\tint ret;\n\tstruct gl861 *priv;\n\n\tstatic const u8 demod_init[][2] = {\n\t\t{0x01, 0x40}, {0x04, 0x38}, {0x05, 0x40}, {0x07, 0x40},\n\t\t{0x0f, 0x4f}, {0x11, 0x21}, {0x12, 0x0b}, {0x13, 0x2f},\n\t\t{0x14, 0x31}, {0x16, 0x02}, {0x21, 0xc4}, {0x22, 0x20},\n\t\t{0x2c, 0x79}, {0x2d, 0x34}, {0x2f, 0x00}, {0x30, 0x28},\n\t\t{0x31, 0x31}, {0x32, 0xdf}, {0x38, 0x01}, {0x39, 0x78},\n\t\t{0x3b, 0x33}, {0x3c, 0x33}, {0x48, 0x90}, {0x51, 0x68},\n\t\t{0x5e, 0x38}, {0x71, 0x00}, {0x72, 0x08}, {0x77, 0x00},\n\t\t{0xc0, 0x21}, {0xc1, 0x10}, {0xe4, 0x1a}, {0xea, 0x1f},\n\t\t{0x77, 0x00}, {0x71, 0x00}, {0x71, 0x00}, {0x76, 0x0c},\n\t};\n\n\t \n\tret = friio_ext_ctl(d, FRIIO_LED_STOPPED, true);\n\tif (ret < 0)\n\t\treturn ret;\n\tmsleep(20);\n\n\t \n\tpriv = d_to_priv(d);\n\tfor (i = 0; i < ARRAY_SIZE(demod_init); i++) {\n\t\tint ret;\n\n\t\tret = i2c_master_send(priv->i2c_client_demod, demod_init[i], 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tmsleep(100);\n\treturn 0;\n}\n\nstatic void friio_exit(struct dvb_usb_device *d)\n{\n\tfriio_ext_ctl(d, FRIIO_LED_STOPPED, false);\n}\n\nstatic int friio_streaming_ctrl(struct dvb_frontend *fe, int onoff)\n{\n\tu32 led_color;\n\n\tled_color = onoff ? FRIIO_LED_RUNNING : FRIIO_LED_STOPPED;\n\treturn friio_ext_ctl(fe_to_d(fe), led_color, true);\n}\n\n\nstatic struct dvb_usb_device_properties friio_props = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\n\t.size_of_priv = sizeof(struct gl861),\n\n\t.i2c_algo = &gl861_i2c_algo,\n\t.power_ctrl = friio_power_ctrl,\n\t.frontend_attach = friio_frontend_attach,\n\t.frontend_detach = friio_frontend_detach,\n\t.tuner_attach = friio_tuner_attach,\n\t.tuner_detach = friio_tuner_detach,\n\t.init = friio_init,\n\t.exit = friio_exit,\n\t.streaming_ctrl = friio_streaming_ctrl,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t\t.stream = DVB_USB_STREAM_BULK(0x01, 8, 16384),\n\t\t}\n\t}\n};\n\nstatic const struct usb_device_id gl861_id_table[] = {\n\t{ DVB_USB_DEVICE(USB_VID_MSI, USB_PID_MSI_MEGASKY580_55801,\n\t\t&gl861_props, \"MSI Mega Sky 55801 DVB-T USB2.0\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_ALINK, USB_PID_ALINK_DTU,\n\t\t&gl861_props, \"A-LINK DTU DVB-T USB2.0\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_774, USB_PID_FRIIO_WHITE,\n\t\t&friio_props, \"774 Friio White ISDB-T USB2.0\", NULL) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, gl861_id_table);\n\nstatic struct usb_driver gl861_usb_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = gl861_id_table,\n\t.probe = dvb_usbv2_probe,\n\t.disconnect = dvb_usbv2_disconnect,\n\t.suspend = dvb_usbv2_suspend,\n\t.resume = dvb_usbv2_resume,\n\t.reset_resume = dvb_usbv2_reset_resume,\n\t.no_dynamic_id = 1,\n\t.soft_unbind = 1,\n};\n\nmodule_usb_driver(gl861_usb_driver);\n\nMODULE_AUTHOR(\"Carl Lundqvist <comabug@gmail.com>\");\nMODULE_DESCRIPTION(\"Driver MSI Mega Sky 580 DVB-T USB2.0 / GL861\");\nMODULE_VERSION(\"0.1\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}