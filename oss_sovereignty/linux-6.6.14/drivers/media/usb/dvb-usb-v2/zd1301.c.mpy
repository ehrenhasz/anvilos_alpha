{
  "module_name": "zd1301.c",
  "hash_id": "2f1d2edfb529f44e3a98a81ef7e58a94f824bbab66a5f9966fd0371f9660a277",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/zd1301.c",
  "human_readable_source": "\n \n\n#include \"dvb_usb.h\"\n#include \"zd1301_demod.h\"\n#include \"mt2060.h\"\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstruct zd1301_dev {\n\t#define BUF_LEN 8\n\tu8 buf[BUF_LEN];  \n\tstruct zd1301_demod_platform_data demod_pdata;\n\tstruct mt2060_platform_data mt2060_pdata;\n\tstruct platform_device *platform_device_demod;\n\tstruct i2c_client *i2c_client_tuner;\n};\n\nstatic int zd1301_ctrl_msg(struct dvb_usb_device *d, const u8 *wbuf,\n\t\t\t   unsigned int wlen, u8 *rbuf, unsigned int rlen)\n{\n\tstruct zd1301_dev *dev = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\tint ret, actual_length;\n\n\tmutex_lock(&d->usb_mutex);\n\n\tmemcpy(&dev->buf, wbuf, wlen);\n\n\tdev_dbg(&intf->dev, \">>> %*ph\\n\", wlen, dev->buf);\n\n\tret = usb_bulk_msg(d->udev, usb_sndbulkpipe(d->udev, 0x04), dev->buf,\n\t\t\t   wlen, &actual_length, 1000);\n\tif (ret) {\n\t\tdev_err(&intf->dev, \"1st usb_bulk_msg() failed %d\\n\", ret);\n\t\tgoto err_mutex_unlock;\n\t}\n\n\tif (rlen) {\n\t\tret = usb_bulk_msg(d->udev, usb_rcvbulkpipe(d->udev, 0x83),\n\t\t\t\t   dev->buf, rlen, &actual_length, 1000);\n\t\tif (ret) {\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"2nd usb_bulk_msg() failed %d\\n\", ret);\n\t\t\tgoto err_mutex_unlock;\n\t\t}\n\n\t\tdev_dbg(&intf->dev, \"<<< %*ph\\n\", actual_length, dev->buf);\n\n\t\tif (actual_length != rlen) {\n\t\t\t \n\t\t\tdev_dbg(&intf->dev, \"repeating reply message\\n\");\n\n\t\t\tret = usb_bulk_msg(d->udev,\n\t\t\t\t\t   usb_rcvbulkpipe(d->udev, 0x83),\n\t\t\t\t\t   dev->buf, rlen, &actual_length,\n\t\t\t\t\t   1000);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&intf->dev,\n\t\t\t\t\t\"3rd usb_bulk_msg() failed %d\\n\", ret);\n\t\t\t\tgoto err_mutex_unlock;\n\t\t\t}\n\n\t\t\tdev_dbg(&intf->dev,\n\t\t\t\t\"<<< %*ph\\n\", actual_length, dev->buf);\n\t\t}\n\n\t\tmemcpy(rbuf, dev->buf, rlen);\n\t}\n\nerr_mutex_unlock:\n\tmutex_unlock(&d->usb_mutex);\n\treturn ret;\n}\n\nstatic int zd1301_demod_wreg(void *reg_priv, u16 reg, u8 val)\n{\n\tstruct dvb_usb_device *d = reg_priv;\n\tstruct usb_interface *intf = d->intf;\n\tint ret;\n\tu8 buf[7] = {0x07, 0x00, 0x03, 0x01,\n\t\t     (reg >> 0) & 0xff, (reg >> 8) & 0xff, val};\n\n\tret = zd1301_ctrl_msg(d, buf, 7, NULL, 0);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int zd1301_demod_rreg(void *reg_priv, u16 reg, u8 *val)\n{\n\tstruct dvb_usb_device *d = reg_priv;\n\tstruct usb_interface *intf = d->intf;\n\tint ret;\n\tu8 buf[7] = {0x07, 0x00, 0x04, 0x01,\n\t\t     (reg >> 0) & 0xff, (reg >> 8) & 0xff, 0};\n\n\tret = zd1301_ctrl_msg(d, buf, 7, buf, 7);\n\tif (ret)\n\t\tgoto err;\n\n\t*val = buf[6];\n\n\treturn 0;\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int zd1301_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct zd1301_dev *dev = adap_to_priv(adap);\n\tstruct usb_interface *intf = d->intf;\n\tstruct platform_device *pdev;\n\tstruct i2c_client *client;\n\tstruct i2c_board_info board_info;\n\tstruct i2c_adapter *adapter;\n\tstruct dvb_frontend *frontend;\n\tint ret;\n\n\tdev_dbg(&intf->dev, \"\\n\");\n\n\t \n\tdev->demod_pdata.reg_priv = d;\n\tdev->demod_pdata.reg_read = zd1301_demod_rreg;\n\tdev->demod_pdata.reg_write = zd1301_demod_wreg;\n\trequest_module(\"%s\", \"zd1301_demod\");\n\tpdev = platform_device_register_data(&intf->dev,\n\t\t\t\t\t     \"zd1301_demod\",\n\t\t\t\t\t     PLATFORM_DEVID_AUTO,\n\t\t\t\t\t     &dev->demod_pdata,\n\t\t\t\t\t     sizeof(dev->demod_pdata));\n\tif (IS_ERR(pdev)) {\n\t\tret = PTR_ERR(pdev);\n\t\tgoto err;\n\t}\n\tif (!pdev->dev.driver) {\n\t\tret = -ENODEV;\n\t\tgoto err_platform_device_unregister;\n\t}\n\tif (!try_module_get(pdev->dev.driver->owner)) {\n\t\tret = -ENODEV;\n\t\tgoto err_platform_device_unregister;\n\t}\n\n\tadapter = zd1301_demod_get_i2c_adapter(pdev);\n\tfrontend = zd1301_demod_get_dvb_frontend(pdev);\n\tif (!adapter || !frontend) {\n\t\tret = -ENODEV;\n\t\tgoto err_module_put_demod;\n\t}\n\n\t \n\tdev->mt2060_pdata.i2c_write_max = 9;\n\tdev->mt2060_pdata.dvb_frontend = frontend;\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrscpy(board_info.type, \"mt2060\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x60;\n\tboard_info.platform_data = &dev->mt2060_pdata;\n\trequest_module(\"%s\", \"mt2060\");\n\tclient = i2c_new_client_device(adapter, &board_info);\n\tif (!i2c_client_has_driver(client)) {\n\t\tret = -ENODEV;\n\t\tgoto err_module_put_demod;\n\t}\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\tret = -ENODEV;\n\t\tgoto err_i2c_unregister_device;\n\t}\n\n\tdev->platform_device_demod = pdev;\n\tdev->i2c_client_tuner = client;\n\tadap->fe[0] = frontend;\n\n\treturn 0;\nerr_i2c_unregister_device:\n\ti2c_unregister_device(client);\nerr_module_put_demod:\n\tmodule_put(pdev->dev.driver->owner);\nerr_platform_device_unregister:\n\tplatform_device_unregister(pdev);\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int zd1301_frontend_detach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct zd1301_dev *dev = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\tstruct platform_device *pdev;\n\tstruct i2c_client *client;\n\n\tdev_dbg(&intf->dev, \"\\n\");\n\n\tclient = dev->i2c_client_tuner;\n\tpdev = dev->platform_device_demod;\n\n\t \n\tif (client) {\n\t\tmodule_put(client->dev.driver->owner);\n\t\ti2c_unregister_device(client);\n\t}\n\n\t \n\tif (pdev) {\n\t\tmodule_put(pdev->dev.driver->owner);\n\t\tplatform_device_unregister(pdev);\n\t}\n\n\treturn 0;\n}\n\nstatic int zd1301_streaming_ctrl(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dvb_usb_device *d = fe_to_d(fe);\n\tstruct usb_interface *intf = d->intf;\n\tint ret;\n\tu8 buf[3] = {0x03, 0x00, onoff ? 0x07 : 0x08};\n\n\tdev_dbg(&intf->dev, \"onoff=%d\\n\", onoff);\n\n\tret = zd1301_ctrl_msg(d, buf, 3, NULL, 0);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct dvb_usb_device_properties zd1301_props = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\t.size_of_priv = sizeof(struct zd1301_dev),\n\n\t.frontend_attach = zd1301_frontend_attach,\n\t.frontend_detach = zd1301_frontend_detach,\n\t.streaming_ctrl  = zd1301_streaming_ctrl,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t\t.stream = DVB_USB_STREAM_BULK(0x81, 6, 21 * 188),\n\t\t},\n\t},\n};\n\nstatic const struct usb_device_id zd1301_id_table[] = {\n\t{DVB_USB_DEVICE(USB_VID_ZYDAS, 0x13a1, &zd1301_props,\n\t\t\t\"ZyDAS ZD1301 reference design\", NULL)},\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, zd1301_id_table);\n\n \nstatic struct usb_driver zd1301_usb_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = zd1301_id_table,\n\t.probe = dvb_usbv2_probe,\n\t.disconnect = dvb_usbv2_disconnect,\n\t.suspend = dvb_usbv2_suspend,\n\t.resume = dvb_usbv2_resume,\n\t.reset_resume = dvb_usbv2_reset_resume,\n\t.no_dynamic_id = 1,\n\t.soft_unbind = 1,\n};\nmodule_usb_driver(zd1301_usb_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"ZyDAS ZD1301 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}