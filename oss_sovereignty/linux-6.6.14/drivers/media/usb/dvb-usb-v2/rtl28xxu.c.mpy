{
  "module_name": "rtl28xxu.c",
  "hash_id": "54d7aa90a7520c3bd93ee5edca6a64272b196c5e0de6a1c522f2b3630ec33866",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/rtl28xxu.c",
  "human_readable_source": "\n \n\n#include \"rtl28xxu.h\"\n\nstatic int rtl28xxu_disable_rc;\nmodule_param_named(disable_rc, rtl28xxu_disable_rc, int, 0644);\nMODULE_PARM_DESC(disable_rc, \"disable RTL2832U remote controller\");\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic int rtl28xxu_ctrl_msg(struct dvb_usb_device *d, struct rtl28xxu_req *req)\n{\n\tstruct rtl28xxu_dev *dev = d->priv;\n\tint ret;\n\tunsigned int pipe;\n\tu8 requesttype;\n\n\tmutex_lock(&d->usb_mutex);\n\n\tif (req->size > sizeof(dev->buf)) {\n\t\tdev_err(&d->intf->dev, \"too large message %u\\n\", req->size);\n\t\tret = -EINVAL;\n\t\tgoto err_mutex_unlock;\n\t}\n\n\tif (req->index & CMD_WR_FLAG) {\n\t\t \n\t\tmemcpy(dev->buf, req->data, req->size);\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\n\t\tpipe = usb_sndctrlpipe(d->udev, 0);\n\t} else {\n\t\t \n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\n\n\t\t \n\t\tif (req->size)\n\t\t\tpipe = usb_rcvctrlpipe(d->udev, 0);\n\t\telse\n\t\t\tpipe = usb_sndctrlpipe(d->udev, 0);\n\t}\n\n\tret = usb_control_msg(d->udev, pipe, 0, requesttype, req->value,\n\t\t\treq->index, dev->buf, req->size, 1000);\n\tdvb_usb_dbg_usb_control_msg(d->udev, 0, requesttype, req->value,\n\t\t\treq->index, dev->buf, req->size);\n\tif (ret < 0)\n\t\tgoto err_mutex_unlock;\n\n\t \n\tif (requesttype == (USB_TYPE_VENDOR | USB_DIR_IN))\n\t\tmemcpy(req->data, dev->buf, req->size);\n\n\tmutex_unlock(&d->usb_mutex);\n\n\treturn 0;\nerr_mutex_unlock:\n\tmutex_unlock(&d->usb_mutex);\n\tdev_dbg(&d->intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl28xxu_wr_regs(struct dvb_usb_device *d, u16 reg, u8 *val, int len)\n{\n\tstruct rtl28xxu_req req;\n\n\tif (reg < 0x3000)\n\t\treq.index = CMD_USB_WR;\n\telse if (reg < 0x4000)\n\t\treq.index = CMD_SYS_WR;\n\telse\n\t\treq.index = CMD_IR_WR;\n\n\treq.value = reg;\n\treq.size = len;\n\treq.data = val;\n\n\treturn rtl28xxu_ctrl_msg(d, &req);\n}\n\nstatic int rtl28xxu_rd_regs(struct dvb_usb_device *d, u16 reg, u8 *val, int len)\n{\n\tstruct rtl28xxu_req req;\n\n\tif (reg < 0x3000)\n\t\treq.index = CMD_USB_RD;\n\telse if (reg < 0x4000)\n\t\treq.index = CMD_SYS_RD;\n\telse\n\t\treq.index = CMD_IR_RD;\n\n\treq.value = reg;\n\treq.size = len;\n\treq.data = val;\n\n\treturn rtl28xxu_ctrl_msg(d, &req);\n}\n\nstatic int rtl28xxu_wr_reg(struct dvb_usb_device *d, u16 reg, u8 val)\n{\n\treturn rtl28xxu_wr_regs(d, reg, &val, 1);\n}\n\nstatic int rtl28xxu_rd_reg(struct dvb_usb_device *d, u16 reg, u8 *val)\n{\n\treturn rtl28xxu_rd_regs(d, reg, val, 1);\n}\n\nstatic int rtl28xxu_wr_reg_mask(struct dvb_usb_device *d, u16 reg, u8 val,\n\t\tu8 mask)\n{\n\tint ret;\n\tu8 tmp;\n\n\t \n\tif (mask != 0xff) {\n\t\tret = rtl28xxu_rd_reg(d, reg, &tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval &= mask;\n\t\ttmp &= ~mask;\n\t\tval |= tmp;\n\t}\n\n\treturn rtl28xxu_wr_reg(d, reg, val);\n}\n\n \nstatic int rtl28xxu_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\tint num)\n{\n\tint ret;\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstruct rtl28xxu_dev *dev = d->priv;\n\tstruct rtl28xxu_req req;\n\n\t \n\n\t \n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tif (num == 2 && !(msg[0].flags & I2C_M_RD) &&\n\t\t(msg[1].flags & I2C_M_RD)) {\n\t\tif (msg[0].len > 24 || msg[1].len > 24) {\n\t\t\t \n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto err_mutex_unlock;\n\t\t} else if (msg[0].addr == 0x10) {\n\t\t\tif (msg[0].len < 1 || msg[1].len < 1) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto err_mutex_unlock;\n\t\t\t}\n\t\t\t \n\t\t\tif (msg[0].buf[0] == 0x00) {\n\t\t\t\t \n\t\t\t\tmsg[1].buf[0] = dev->page;\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\treq.value = (msg[0].buf[0] << 8) | (msg[0].addr << 1);\n\t\t\t\treq.index = CMD_DEMOD_RD | dev->page;\n\t\t\t\treq.size = msg[1].len;\n\t\t\t\treq.data = &msg[1].buf[0];\n\t\t\t\tret = rtl28xxu_ctrl_msg(d, &req);\n\t\t\t}\n\t\t} else if (msg[0].len < 2) {\n\t\t\tif (msg[0].len < 1) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto err_mutex_unlock;\n\t\t\t}\n\t\t\t \n\t\t\treq.value = (msg[0].buf[0] << 8) | (msg[0].addr << 1);\n\t\t\treq.index = CMD_I2C_RD;\n\t\t\treq.size = msg[1].len;\n\t\t\treq.data = &msg[1].buf[0];\n\t\t\tret = rtl28xxu_ctrl_msg(d, &req);\n\t\t} else {\n\t\t\t \n\t\t\treq.value = (msg[0].addr << 1);\n\t\t\treq.index = CMD_I2C_DA_WR;\n\t\t\treq.size = msg[0].len;\n\t\t\treq.data = msg[0].buf;\n\t\t\tret = rtl28xxu_ctrl_msg(d, &req);\n\t\t\tif (ret)\n\t\t\t\tgoto err_mutex_unlock;\n\n\t\t\treq.value = (msg[0].addr << 1);\n\t\t\treq.index = CMD_I2C_DA_RD;\n\t\t\treq.size = msg[1].len;\n\t\t\treq.data = msg[1].buf;\n\t\t\tret = rtl28xxu_ctrl_msg(d, &req);\n\t\t}\n\t} else if (num == 1 && !(msg[0].flags & I2C_M_RD)) {\n\t\tif (msg[0].len > 22) {\n\t\t\t \n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto err_mutex_unlock;\n\t\t} else if (msg[0].addr == 0x10) {\n\t\t\tif (msg[0].len < 1) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto err_mutex_unlock;\n\t\t\t}\n\t\t\t \n\t\t\tif (msg[0].buf[0] == 0x00) {\n\t\t\t\tif (msg[0].len < 2) {\n\t\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\t\tgoto err_mutex_unlock;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tdev->page = msg[0].buf[1];\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\treq.value = (msg[0].buf[0] << 8) |\n\t\t\t\t\t(msg[0].addr << 1);\n\t\t\t\treq.index = CMD_DEMOD_WR | dev->page;\n\t\t\t\treq.size = msg[0].len-1;\n\t\t\t\treq.data = &msg[0].buf[1];\n\t\t\t\tret = rtl28xxu_ctrl_msg(d, &req);\n\t\t\t}\n\t\t} else if ((msg[0].len < 23) && (!dev->new_i2c_write)) {\n\t\t\tif (msg[0].len < 1) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto err_mutex_unlock;\n\t\t\t}\n\t\t\t \n\t\t\treq.value = (msg[0].buf[0] << 8) | (msg[0].addr << 1);\n\t\t\treq.index = CMD_I2C_WR;\n\t\t\treq.size = msg[0].len-1;\n\t\t\treq.data = &msg[0].buf[1];\n\t\t\tret = rtl28xxu_ctrl_msg(d, &req);\n\t\t} else {\n\t\t\t \n\t\t\treq.value = (msg[0].addr << 1);\n\t\t\treq.index = CMD_I2C_DA_WR;\n\t\t\treq.size = msg[0].len;\n\t\t\treq.data = msg[0].buf;\n\t\t\tret = rtl28xxu_ctrl_msg(d, &req);\n\t\t}\n\t} else if (num == 1 && (msg[0].flags & I2C_M_RD)) {\n\t\treq.value = (msg[0].addr << 1);\n\t\treq.index = CMD_I2C_DA_RD;\n\t\treq.size = msg[0].len;\n\t\treq.data = msg[0].buf;\n\t\tret = rtl28xxu_ctrl_msg(d, &req);\n\t} else {\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\t \n\tif (ret == -EPIPE)\n\t\tret = -EAGAIN;\n\nerr_mutex_unlock:\n\tmutex_unlock(&d->i2c_mutex);\n\n\treturn ret ? ret : num;\n}\n\nstatic u32 rtl28xxu_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm rtl28xxu_i2c_algo = {\n\t.master_xfer   = rtl28xxu_i2c_xfer,\n\t.functionality = rtl28xxu_i2c_func,\n};\n\nstatic int rtl2831u_read_config(struct dvb_usb_device *d)\n{\n\tstruct rtl28xxu_dev *dev = d_to_priv(d);\n\tint ret;\n\tu8 buf[1];\n\t \n\tstruct rtl28xxu_req req_gate_open = {0x0120, 0x0011, 0x0001, \"\\x08\"};\n\t \n\tstruct rtl28xxu_req req_mt2060 = {0x00c0, CMD_I2C_RD, 1, buf};\n\tstruct rtl28xxu_req req_qt1010 = {0x0fc4, CMD_I2C_RD, 1, buf};\n\n\tdev_dbg(&d->intf->dev, \"\\n\");\n\n\t \n\n\t \n\tret = rtl28xxu_wr_reg(d, SYS_GPIO_DIR, 0x0a);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = rtl28xxu_wr_reg(d, SYS_GPIO_OUT_EN, 0x15);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\n\t \n\tmsleep(20);\n\n\tdev->tuner_name = \"NONE\";\n\n\t \n\tret = rtl28xxu_ctrl_msg(d, &req_gate_open);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = rtl28xxu_ctrl_msg(d, &req_qt1010);\n\tif (ret == 0 && buf[0] == 0x2c) {\n\t\tdev->tuner = TUNER_RTL2830_QT1010;\n\t\tdev->tuner_name = \"QT1010\";\n\t\tgoto found;\n\t}\n\n\t \n\tret = rtl28xxu_ctrl_msg(d, &req_gate_open);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = rtl28xxu_ctrl_msg(d, &req_mt2060);\n\tif (ret == 0 && buf[0] == 0x63) {\n\t\tdev->tuner = TUNER_RTL2830_MT2060;\n\t\tdev->tuner_name = \"MT2060\";\n\t\tgoto found;\n\t}\n\n\t \n\tdev->tuner = TUNER_RTL2830_MXL5005S;\n\tdev->tuner_name = \"MXL5005S\";\n\tgoto found;\n\nfound:\n\tdev_dbg(&d->intf->dev, \"tuner=%s\\n\", dev->tuner_name);\n\n\treturn 0;\nerr:\n\tdev_dbg(&d->intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2832u_read_config(struct dvb_usb_device *d)\n{\n\tstruct rtl28xxu_dev *dev = d_to_priv(d);\n\tint ret;\n\tu8 buf[2];\n\t \n\tstruct rtl28xxu_req req_gate_open = {0x0120, 0x0011, 0x0001, \"\\x18\"};\n\t \n\tstruct rtl28xxu_req req_gate_close = {0x0120, 0x0011, 0x0001, \"\\x10\"};\n\t \n\tstruct rtl28xxu_req req_fc0012 = {0x00c6, CMD_I2C_RD, 1, buf};\n\tstruct rtl28xxu_req req_fc0013 = {0x00c6, CMD_I2C_RD, 1, buf};\n\tstruct rtl28xxu_req req_mt2266 = {0x00c0, CMD_I2C_RD, 1, buf};\n\tstruct rtl28xxu_req req_fc2580 = {0x01ac, CMD_I2C_RD, 1, buf};\n\tstruct rtl28xxu_req req_mt2063 = {0x00c0, CMD_I2C_RD, 1, buf};\n\tstruct rtl28xxu_req req_max3543 = {0x00c0, CMD_I2C_RD, 1, buf};\n\tstruct rtl28xxu_req req_tua9001 = {0x7ec0, CMD_I2C_RD, 2, buf};\n\tstruct rtl28xxu_req req_mxl5007t = {0xd9c0, CMD_I2C_RD, 1, buf};\n\tstruct rtl28xxu_req req_e4000 = {0x02c8, CMD_I2C_RD, 1, buf};\n\tstruct rtl28xxu_req req_tda18272 = {0x00c0, CMD_I2C_RD, 2, buf};\n\tstruct rtl28xxu_req req_r820t = {0x0034, CMD_I2C_RD, 1, buf};\n\tstruct rtl28xxu_req req_r828d = {0x0074, CMD_I2C_RD, 1, buf};\n\tstruct rtl28xxu_req req_mn88472 = {0xff38, CMD_I2C_RD, 1, buf};\n\tstruct rtl28xxu_req req_mn88473 = {0xff38, CMD_I2C_RD, 1, buf};\n\tstruct rtl28xxu_req req_cxd2837er = {0xfdd8, CMD_I2C_RD, 1, buf};\n\tstruct rtl28xxu_req req_si2157 = {0x00c0, CMD_I2C_RD, 1, buf};\n\tstruct rtl28xxu_req req_si2168 = {0x00c8, CMD_I2C_RD, 1, buf};\n\n\tdev_dbg(&d->intf->dev, \"\\n\");\n\n\t \n\tret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_DIR, 0x00, 0x40);\n\tif (ret)\n\t\tgoto err;\n\n\tret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_EN, 0x48, 0x48);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\n\t \n\tret = rtl28xxu_ctrl_msg(d, &req_gate_open);\n\tif (ret)\n\t\tgoto err;\n\n\tdev->tuner_name = \"NONE\";\n\n\t \n\tret = rtl28xxu_ctrl_msg(d, &req_fc0012);\n\tif (ret == 0 && buf[0] == 0xa1) {\n\t\tdev->tuner = TUNER_RTL2832_FC0012;\n\t\tdev->tuner_name = \"FC0012\";\n\t\tgoto tuner_found;\n\t}\n\n\t \n\tret = rtl28xxu_ctrl_msg(d, &req_fc0013);\n\tif (ret == 0 && buf[0] == 0xa3) {\n\t\tdev->tuner = TUNER_RTL2832_FC0013;\n\t\tdev->tuner_name = \"FC0013\";\n\t\tgoto tuner_found;\n\t}\n\n\t \n\tret = rtl28xxu_ctrl_msg(d, &req_mt2266);\n\tif (ret == 0 && buf[0] == 0x85) {\n\t\tdev->tuner = TUNER_RTL2832_MT2266;\n\t\tdev->tuner_name = \"MT2266\";\n\t\tgoto tuner_found;\n\t}\n\n\t \n\tret = rtl28xxu_ctrl_msg(d, &req_fc2580);\n\tif (ret == 0 && buf[0] == 0x56) {\n\t\tdev->tuner = TUNER_RTL2832_FC2580;\n\t\tdev->tuner_name = \"FC2580\";\n\t\tgoto tuner_found;\n\t}\n\n\t \n\tret = rtl28xxu_ctrl_msg(d, &req_mt2063);\n\tif (ret == 0 && (buf[0] == 0x9e || buf[0] == 0x9c)) {\n\t\tdev->tuner = TUNER_RTL2832_MT2063;\n\t\tdev->tuner_name = \"MT2063\";\n\t\tgoto tuner_found;\n\t}\n\n\t \n\tret = rtl28xxu_ctrl_msg(d, &req_max3543);\n\tif (ret == 0 && buf[0] == 0x38) {\n\t\tdev->tuner = TUNER_RTL2832_MAX3543;\n\t\tdev->tuner_name = \"MAX3543\";\n\t\tgoto tuner_found;\n\t}\n\n\t \n\tret = rtl28xxu_ctrl_msg(d, &req_tua9001);\n\tif (ret == 0 && buf[0] == 0x23 && buf[1] == 0x28) {\n\t\tdev->tuner = TUNER_RTL2832_TUA9001;\n\t\tdev->tuner_name = \"TUA9001\";\n\t\tgoto tuner_found;\n\t}\n\n\t \n\tret = rtl28xxu_ctrl_msg(d, &req_mxl5007t);\n\tif (ret == 0 && buf[0] == 0x14) {\n\t\tdev->tuner = TUNER_RTL2832_MXL5007T;\n\t\tdev->tuner_name = \"MXL5007T\";\n\t\tgoto tuner_found;\n\t}\n\n\t \n\tret = rtl28xxu_ctrl_msg(d, &req_e4000);\n\tif (ret == 0 && buf[0] == 0x40) {\n\t\tdev->tuner = TUNER_RTL2832_E4000;\n\t\tdev->tuner_name = \"E4000\";\n\t\tgoto tuner_found;\n\t}\n\n\t \n\tret = rtl28xxu_ctrl_msg(d, &req_tda18272);\n\tif (ret == 0 && (buf[0] == 0xc7 || buf[1] == 0x60)) {\n\t\tdev->tuner = TUNER_RTL2832_TDA18272;\n\t\tdev->tuner_name = \"TDA18272\";\n\t\tgoto tuner_found;\n\t}\n\n\t \n\tret = rtl28xxu_ctrl_msg(d, &req_r820t);\n\tif (ret == 0 && buf[0] == 0x69) {\n\t\tdev->tuner = TUNER_RTL2832_R820T;\n\t\tdev->tuner_name = \"R820T\";\n\t\tgoto tuner_found;\n\t}\n\n\t \n\tret = rtl28xxu_ctrl_msg(d, &req_r828d);\n\tif (ret == 0 && buf[0] == 0x69) {\n\t\tdev->tuner = TUNER_RTL2832_R828D;\n\t\tdev->tuner_name = \"R828D\";\n\t\tgoto tuner_found;\n\t}\n\n\t \n\tret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_VAL, 0x00, 0x21);\n\tif (ret)\n\t\tgoto err;\n\n\tret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_EN, 0x00, 0x21);\n\tif (ret)\n\t\tgoto err;\n\n\tmsleep(50);\n\n\tret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_VAL, 0x21, 0x21);\n\tif (ret)\n\t\tgoto err;\n\n\tret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_EN, 0x21, 0x21);\n\tif (ret)\n\t\tgoto err;\n\n\tmsleep(50);\n\n\t \n\tret = rtl28xxu_ctrl_msg(d, &req_si2157);\n\tif (ret == 0 && ((buf[0] & 0x80) == 0x80)) {\n\t\tdev->tuner = TUNER_RTL2832_SI2157;\n\t\tdev->tuner_name = \"SI2157\";\n\t\tgoto tuner_found;\n\t}\n\ntuner_found:\n\tdev_dbg(&d->intf->dev, \"tuner=%s\\n\", dev->tuner_name);\n\n\t \n\tif (dev->tuner == TUNER_RTL2832_R828D) {\n\t\t \n\t\tret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_VAL, 0x00, 0x01);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_EN, 0x00, 0x01);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tmsleep(50);\n\n\t\t \n\t\tret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_VAL, 0x01, 0x01);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_DIR, 0x00, 0x01);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_EN, 0x01, 0x01);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tmsleep(20);\n\n\t\t \n\t\tret = rtl28xxu_ctrl_msg(d, &req_mn88472);\n\t\tif (ret == 0 && buf[0] == 0x02) {\n\t\t\tdev_dbg(&d->intf->dev, \"MN88472 found\\n\");\n\t\t\tdev->slave_demod = SLAVE_DEMOD_MN88472;\n\t\t\tgoto demod_found;\n\t\t}\n\n\t\tret = rtl28xxu_ctrl_msg(d, &req_mn88473);\n\t\tif (ret == 0 && buf[0] == 0x03) {\n\t\t\tdev_dbg(&d->intf->dev, \"MN88473 found\\n\");\n\t\t\tdev->slave_demod = SLAVE_DEMOD_MN88473;\n\t\t\tgoto demod_found;\n\t\t}\n\n\t\tret = rtl28xxu_ctrl_msg(d, &req_cxd2837er);\n\t\tif (ret == 0 && buf[0] == 0xb1) {\n\t\t\tdev_dbg(&d->intf->dev, \"CXD2837ER found\\n\");\n\t\t\tdev->slave_demod = SLAVE_DEMOD_CXD2837ER;\n\t\t\tgoto demod_found;\n\t\t}\n\t}\n\tif (dev->tuner == TUNER_RTL2832_SI2157) {\n\t\t \n\t\tret = rtl28xxu_ctrl_msg(d, &req_si2168);\n\t\tif (ret == 0 && ((buf[0] & 0x80) == 0x80)) {\n\t\t\tdev_dbg(&d->intf->dev, \"Si2168 found\\n\");\n\t\t\tdev->slave_demod = SLAVE_DEMOD_SI2168;\n\t\t\tgoto demod_found;\n\t\t}\n\t}\n\ndemod_found:\n\t \n\tret = rtl28xxu_ctrl_msg(d, &req_gate_close);\n\tif (ret < 0)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&d->intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl28xxu_read_config(struct dvb_usb_device *d)\n{\n\tstruct rtl28xxu_dev *dev = d_to_priv(d);\n\n\tif (dev->chip_id == CHIP_ID_RTL2831U)\n\t\treturn rtl2831u_read_config(d);\n\telse\n\t\treturn rtl2832u_read_config(d);\n}\n\nstatic int rtl28xxu_identify_state(struct dvb_usb_device *d, const char **name)\n{\n\tstruct rtl28xxu_dev *dev = d_to_priv(d);\n\tint ret;\n\tstruct rtl28xxu_req req_demod_i2c = {0x0020, CMD_I2C_DA_RD, 0, NULL};\n\n\tdev_dbg(&d->intf->dev, \"\\n\");\n\n\t \n\tret = rtl28xxu_ctrl_msg(d, &req_demod_i2c);\n\tif (ret == -EPIPE) {\n\t\tdev->chip_id = CHIP_ID_RTL2831U;\n\t} else if (ret == 0) {\n\t\tdev->chip_id = CHIP_ID_RTL2832U;\n\t} else {\n\t\tdev_err(&d->intf->dev, \"chip type detection failed %d\\n\", ret);\n\t\tgoto err;\n\t}\n\tdev_dbg(&d->intf->dev, \"chip_id=%u\\n\", dev->chip_id);\n\n\t \n\td->i2c_adap.retries = 3;\n\td->i2c_adap.timeout = msecs_to_jiffies(10);\n\n\treturn WARM;\nerr:\n\tdev_dbg(&d->intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct rtl2830_platform_data rtl2830_mt2060_platform_data = {\n\t.clk = 28800000,\n\t.spec_inv = 1,\n\t.vtop = 0x20,\n\t.krf = 0x04,\n\t.agc_targ_val = 0x2d,\n\n};\n\nstatic const struct rtl2830_platform_data rtl2830_qt1010_platform_data = {\n\t.clk = 28800000,\n\t.spec_inv = 1,\n\t.vtop = 0x20,\n\t.krf = 0x04,\n\t.agc_targ_val = 0x2d,\n};\n\nstatic const struct rtl2830_platform_data rtl2830_mxl5005s_platform_data = {\n\t.clk = 28800000,\n\t.spec_inv = 0,\n\t.vtop = 0x3f,\n\t.krf = 0x04,\n\t.agc_targ_val = 0x3e,\n};\n\nstatic int rtl2831u_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct rtl28xxu_dev *dev = d_to_priv(d);\n\tstruct rtl2830_platform_data *pdata = &dev->rtl2830_platform_data;\n\tstruct i2c_board_info board_info;\n\tstruct i2c_client *client;\n\tint ret;\n\n\tdev_dbg(&d->intf->dev, \"\\n\");\n\n\tswitch (dev->tuner) {\n\tcase TUNER_RTL2830_QT1010:\n\t\t*pdata = rtl2830_qt1010_platform_data;\n\t\tbreak;\n\tcase TUNER_RTL2830_MT2060:\n\t\t*pdata = rtl2830_mt2060_platform_data;\n\t\tbreak;\n\tcase TUNER_RTL2830_MXL5005S:\n\t\t*pdata = rtl2830_mxl5005s_platform_data;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&d->intf->dev, \"unknown tuner %s\\n\", dev->tuner_name);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t \n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrscpy(board_info.type, \"rtl2830\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x10;\n\tboard_info.platform_data = pdata;\n\trequest_module(\"%s\", board_info.type);\n\tclient = i2c_new_client_device(&d->i2c_adap, &board_info);\n\tif (!i2c_client_has_driver(client)) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tadap->fe[0] = pdata->get_dvb_frontend(client);\n\tdev->demod_i2c_adapter = pdata->get_i2c_adapter(client);\n\n\tdev->i2c_client_demod = client;\n\n\treturn 0;\nerr:\n\tdev_dbg(&d->intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct rtl2832_platform_data rtl2832_fc2580_platform_data = {\n\t.clk = 28800000,\n\t.tuner = TUNER_RTL2832_FC2580,\n};\n\nstatic const struct rtl2832_platform_data rtl2832_fc0012_platform_data = {\n\t.clk = 28800000,\n\t.tuner = TUNER_RTL2832_FC0012\n};\n\nstatic const struct rtl2832_platform_data rtl2832_fc0013_platform_data = {\n\t.clk = 28800000,\n\t.tuner = TUNER_RTL2832_FC0013\n};\n\nstatic const struct rtl2832_platform_data rtl2832_tua9001_platform_data = {\n\t.clk = 28800000,\n\t.tuner = TUNER_RTL2832_TUA9001,\n};\n\nstatic const struct rtl2832_platform_data rtl2832_e4000_platform_data = {\n\t.clk = 28800000,\n\t.tuner = TUNER_RTL2832_E4000,\n};\n\nstatic const struct rtl2832_platform_data rtl2832_r820t_platform_data = {\n\t.clk = 28800000,\n\t.tuner = TUNER_RTL2832_R820T,\n};\n\nstatic const struct rtl2832_platform_data rtl2832_si2157_platform_data = {\n\t.clk = 28800000,\n\t.tuner = TUNER_RTL2832_SI2157,\n};\n\nstatic int rtl2832u_fc0012_tuner_callback(struct dvb_usb_device *d,\n\t\tint cmd, int arg)\n{\n\tint ret;\n\tu8 val;\n\n\tdev_dbg(&d->intf->dev, \"cmd=%d arg=%d\\n\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase FC_FE_CALLBACK_VHF_ENABLE:\n\t\t \n\t\tret = rtl28xxu_rd_reg(d, SYS_GPIO_OUT_VAL, &val);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (arg)\n\t\t\tval &= 0xbf;  \n\t\telse\n\t\t\tval |= 0x40;  \n\n\n\t\tret = rtl28xxu_wr_reg(d, SYS_GPIO_OUT_VAL, val);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\treturn 0;\nerr:\n\tdev_dbg(&d->intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2832u_tua9001_tuner_callback(struct dvb_usb_device *d,\n\t\tint cmd, int arg)\n{\n\tint ret;\n\tu8 val;\n\n\tdev_dbg(&d->intf->dev, \"cmd=%d arg=%d\\n\", cmd, arg);\n\n\t \n\n\tswitch (cmd) {\n\tcase TUA9001_CMD_RESETN:\n\t\tif (arg)\n\t\t\tval = (1 << 4);\n\t\telse\n\t\t\tval = (0 << 4);\n\n\t\tret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_VAL, val, 0x10);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tbreak;\n\tcase TUA9001_CMD_RXEN:\n\t\tif (arg)\n\t\t\tval = (1 << 1);\n\t\telse\n\t\t\tval = (0 << 1);\n\n\t\tret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_VAL, val, 0x02);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tbreak;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&d->intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2832u_frontend_callback(void *adapter_priv, int component,\n\t\tint cmd, int arg)\n{\n\tstruct i2c_adapter *adapter = adapter_priv;\n\tstruct device *parent = adapter->dev.parent;\n\tstruct i2c_adapter *parent_adapter;\n\tstruct dvb_usb_device *d;\n\tstruct rtl28xxu_dev *dev;\n\n\t \n\tif (parent != NULL && parent->type == &i2c_adapter_type)\n\t\tparent_adapter = to_i2c_adapter(parent);\n\telse\n\t\treturn -EINVAL;\n\n\td = i2c_get_adapdata(parent_adapter);\n\tdev = d->priv;\n\n\tdev_dbg(&d->intf->dev, \"component=%d cmd=%d arg=%d\\n\",\n\t\tcomponent, cmd, arg);\n\n\tswitch (component) {\n\tcase DVB_FRONTEND_COMPONENT_TUNER:\n\t\tswitch (dev->tuner) {\n\t\tcase TUNER_RTL2832_FC0012:\n\t\t\treturn rtl2832u_fc0012_tuner_callback(d, cmd, arg);\n\t\tcase TUNER_RTL2832_TUA9001:\n\t\t\treturn rtl2832u_tua9001_tuner_callback(d, cmd, arg);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rtl2832u_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct rtl28xxu_dev *dev = d_to_priv(d);\n\tstruct rtl2832_platform_data *pdata = &dev->rtl2832_platform_data;\n\tstruct i2c_board_info board_info;\n\tstruct i2c_client *client;\n\tint ret;\n\n\tdev_dbg(&d->intf->dev, \"\\n\");\n\n\tswitch (dev->tuner) {\n\tcase TUNER_RTL2832_FC0012:\n\t\t*pdata = rtl2832_fc0012_platform_data;\n\t\tbreak;\n\tcase TUNER_RTL2832_FC0013:\n\t\t*pdata = rtl2832_fc0013_platform_data;\n\t\tbreak;\n\tcase TUNER_RTL2832_FC2580:\n\t\t*pdata = rtl2832_fc2580_platform_data;\n\t\tbreak;\n\tcase TUNER_RTL2832_TUA9001:\n\t\t*pdata = rtl2832_tua9001_platform_data;\n\t\tbreak;\n\tcase TUNER_RTL2832_E4000:\n\t\t*pdata = rtl2832_e4000_platform_data;\n\t\tbreak;\n\tcase TUNER_RTL2832_R820T:\n\tcase TUNER_RTL2832_R828D:\n\t\t*pdata = rtl2832_r820t_platform_data;\n\t\tbreak;\n\tcase TUNER_RTL2832_SI2157:\n\t\t*pdata = rtl2832_si2157_platform_data;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&d->intf->dev, \"unknown tuner %s\\n\", dev->tuner_name);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t \n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrscpy(board_info.type, \"rtl2832\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x10;\n\tboard_info.platform_data = pdata;\n\trequest_module(\"%s\", board_info.type);\n\tclient = i2c_new_client_device(&d->i2c_adap, &board_info);\n\tif (!i2c_client_has_driver(client)) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tadap->fe[0] = pdata->get_dvb_frontend(client);\n\tdev->demod_i2c_adapter = pdata->get_i2c_adapter(client);\n\n\tdev->i2c_client_demod = client;\n\n\t \n\tadap->fe[0]->callback = rtl2832u_frontend_callback;\n\n\tif (dev->slave_demod) {\n\t\tstruct i2c_board_info info = {};\n\n\t\t \n\t\tif (dev->slave_demod == SLAVE_DEMOD_MN88472) {\n\t\t\tstruct mn88472_config mn88472_config = {};\n\n\t\t\tmn88472_config.fe = &adap->fe[1];\n\t\t\tmn88472_config.i2c_wr_max = 22;\n\t\t\tstrscpy(info.type, \"mn88472\", I2C_NAME_SIZE);\n\t\t\tmn88472_config.xtal = 20500000;\n\t\t\tmn88472_config.ts_mode = SERIAL_TS_MODE;\n\t\t\tmn88472_config.ts_clock = VARIABLE_TS_CLOCK;\n\t\t\tinfo.addr = 0x18;\n\t\t\tinfo.platform_data = &mn88472_config;\n\t\t\trequest_module(info.type);\n\t\t\tclient = i2c_new_client_device(&d->i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client))\n\t\t\t\tgoto err_slave_demod_failed;\n\n\t\t\tif (!try_module_get(client->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client);\n\t\t\t\tgoto err_slave_demod_failed;\n\t\t\t}\n\n\t\t\tdev->i2c_client_slave_demod = client;\n\t\t} else if (dev->slave_demod == SLAVE_DEMOD_MN88473) {\n\t\t\tstruct mn88473_config mn88473_config = {};\n\n\t\t\tmn88473_config.fe = &adap->fe[1];\n\t\t\tmn88473_config.i2c_wr_max = 22;\n\t\t\tstrscpy(info.type, \"mn88473\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x18;\n\t\t\tinfo.platform_data = &mn88473_config;\n\t\t\trequest_module(info.type);\n\t\t\tclient = i2c_new_client_device(&d->i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client))\n\t\t\t\tgoto err_slave_demod_failed;\n\n\t\t\tif (!try_module_get(client->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client);\n\t\t\t\tgoto err_slave_demod_failed;\n\t\t\t}\n\n\t\t\tdev->i2c_client_slave_demod = client;\n\t\t} else if (dev->slave_demod == SLAVE_DEMOD_CXD2837ER) {\n\t\t\tstruct cxd2841er_config cxd2837er_config = {};\n\n\t\t\tcxd2837er_config.i2c_addr = 0xd8;\n\t\t\tcxd2837er_config.xtal = SONY_XTAL_20500;\n\t\t\tcxd2837er_config.flags = (CXD2841ER_AUTO_IFHZ |\n\t\t\t\tCXD2841ER_NO_AGCNEG | CXD2841ER_TSBITS |\n\t\t\t\tCXD2841ER_EARLY_TUNE | CXD2841ER_TS_SERIAL);\n\t\t\tadap->fe[1] = dvb_attach(cxd2841er_attach_t_c,\n\t\t\t\t\t\t &cxd2837er_config,\n\t\t\t\t\t\t &d->i2c_adap);\n\t\t\tif (!adap->fe[1])\n\t\t\t\tgoto err_slave_demod_failed;\n\t\t\tadap->fe[1]->id = 1;\n\t\t\tdev->i2c_client_slave_demod = NULL;\n\t\t} else {\n\t\t\tstruct si2168_config si2168_config = {};\n\t\t\tstruct i2c_adapter *adapter;\n\n\t\t\tsi2168_config.i2c_adapter = &adapter;\n\t\t\tsi2168_config.fe = &adap->fe[1];\n\t\t\tsi2168_config.ts_mode = SI2168_TS_SERIAL;\n\t\t\tsi2168_config.ts_clock_inv = false;\n\t\t\tsi2168_config.ts_clock_gapped = true;\n\t\t\tstrscpy(info.type, \"si2168\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x64;\n\t\t\tinfo.platform_data = &si2168_config;\n\t\t\trequest_module(info.type);\n\t\t\tclient = i2c_new_client_device(&d->i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client))\n\t\t\t\tgoto err_slave_demod_failed;\n\n\t\t\tif (!try_module_get(client->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client);\n\t\t\t\tgoto err_slave_demod_failed;\n\t\t\t}\n\n\t\t\tdev->i2c_client_slave_demod = client;\n\n\t\t\t \n\t\t\tdev->new_i2c_write = true;\n\t\t}\n\t}\n\treturn 0;\n\nerr:\n\tdev_dbg(&d->intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n\nerr_slave_demod_failed:\n\t \n\tdev->slave_demod = SLAVE_DEMOD_NONE;\n\treturn 0;\n}\n\nstatic int rtl28xxu_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct rtl28xxu_dev *dev = adap_to_priv(adap);\n\n\tif (dev->chip_id == CHIP_ID_RTL2831U)\n\t\treturn rtl2831u_frontend_attach(adap);\n\telse\n\t\treturn rtl2832u_frontend_attach(adap);\n}\n\nstatic int rtl28xxu_frontend_detach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct rtl28xxu_dev *dev = d_to_priv(d);\n\tstruct i2c_client *client;\n\n\tdev_dbg(&d->intf->dev, \"\\n\");\n\n\t \n\tclient = dev->i2c_client_slave_demod;\n\tif (client) {\n\t\tmodule_put(client->dev.driver->owner);\n\t\ti2c_unregister_device(client);\n\t}\n\n\t \n\tclient = dev->i2c_client_demod;\n\tif (client) {\n\t\tmodule_put(client->dev.driver->owner);\n\t\ti2c_unregister_device(client);\n\t}\n\n\treturn 0;\n}\n\nstatic struct qt1010_config rtl28xxu_qt1010_config = {\n\t.i2c_address = 0x62,  \n};\n\nstatic struct mt2060_config rtl28xxu_mt2060_config = {\n\t.i2c_address = 0x60,  \n\t.clock_out = 0,\n};\n\nstatic struct mxl5005s_config rtl28xxu_mxl5005s_config = {\n\t.i2c_address     = 0x63,  \n\t.if_freq         = IF_FREQ_4570000HZ,\n\t.xtal_freq       = CRYSTAL_FREQ_16000000HZ,\n\t.agc_mode        = MXL_SINGLE_AGC,\n\t.tracking_filter = MXL_TF_C_H,\n\t.rssi_enable     = MXL_RSSI_ENABLE,\n\t.cap_select      = MXL_CAP_SEL_ENABLE,\n\t.div_out         = MXL_DIV_OUT_4,\n\t.clock_out       = MXL_CLOCK_OUT_DISABLE,\n\t.output_load     = MXL5005S_IF_OUTPUT_LOAD_200_OHM,\n\t.top\t\t = MXL5005S_TOP_25P2,\n\t.mod_mode        = MXL_DIGITAL_MODE,\n\t.if_mode         = MXL_ZERO_IF,\n\t.AgcMasterByte   = 0x00,\n};\n\nstatic int rtl2831u_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tint ret;\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct rtl28xxu_dev *dev = d_to_priv(d);\n\tstruct dvb_frontend *fe;\n\n\tdev_dbg(&d->intf->dev, \"\\n\");\n\n\tswitch (dev->tuner) {\n\tcase TUNER_RTL2830_QT1010:\n\t\tfe = dvb_attach(qt1010_attach, adap->fe[0],\n\t\t\t\tdev->demod_i2c_adapter,\n\t\t\t\t&rtl28xxu_qt1010_config);\n\t\tbreak;\n\tcase TUNER_RTL2830_MT2060:\n\t\tfe = dvb_attach(mt2060_attach, adap->fe[0],\n\t\t\t\tdev->demod_i2c_adapter,\n\t\t\t\t&rtl28xxu_mt2060_config, 1220);\n\t\tbreak;\n\tcase TUNER_RTL2830_MXL5005S:\n\t\tfe = dvb_attach(mxl5005s_attach, adap->fe[0],\n\t\t\t\tdev->demod_i2c_adapter,\n\t\t\t\t&rtl28xxu_mxl5005s_config);\n\t\tbreak;\n\tdefault:\n\t\tfe = NULL;\n\t\tdev_err(&d->intf->dev, \"unknown tuner %d\\n\", dev->tuner);\n\t}\n\n\tif (fe == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&d->intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct fc0012_config rtl2832u_fc0012_config = {\n\t.i2c_address = 0x63,  \n\t.xtal_freq = FC_XTAL_28_8_MHZ,\n};\n\nstatic const struct r820t_config rtl2832u_r820t_config = {\n\t.i2c_addr = 0x1a,\n\t.xtal = 28800000,\n\t.max_i2c_msg_len = 2,\n\t.rafael_chip = CHIP_R820T,\n};\n\nstatic const struct r820t_config rtl2832u_r828d_config = {\n\t.i2c_addr = 0x3a,\n\t.xtal = 16000000,\n\t.max_i2c_msg_len = 2,\n\t.rafael_chip = CHIP_R828D,\n};\n\nstatic int rtl2832u_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tint ret;\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct rtl28xxu_dev *dev = d_to_priv(d);\n\tstruct dvb_frontend *fe = NULL;\n\tstruct i2c_board_info info;\n\tstruct i2c_client *client;\n\tstruct v4l2_subdev *subdev = NULL;\n\tstruct platform_device *pdev;\n\tstruct rtl2832_sdr_platform_data pdata;\n\n\tdev_dbg(&d->intf->dev, \"\\n\");\n\n\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\tmemset(&pdata, 0, sizeof(pdata));\n\n\tswitch (dev->tuner) {\n\tcase TUNER_RTL2832_FC0012:\n\t\tfe = dvb_attach(fc0012_attach, adap->fe[0],\n\t\t\tdev->demod_i2c_adapter, &rtl2832u_fc0012_config);\n\n\t\t \n\t\tadap->fe[0]->ops.read_signal_strength =\n\t\t\t\tadap->fe[0]->ops.tuner_ops.get_rf_strength;\n\t\tbreak;\n\tcase TUNER_RTL2832_FC0013:\n\t\tfe = dvb_attach(fc0013_attach, adap->fe[0],\n\t\t\tdev->demod_i2c_adapter, 0xc6>>1, 0, FC_XTAL_28_8_MHZ);\n\n\t\t \n\t\tadap->fe[0]->ops.read_signal_strength =\n\t\t\t\tadap->fe[0]->ops.tuner_ops.get_rf_strength;\n\t\tbreak;\n\tcase TUNER_RTL2832_E4000: {\n\t\t\tstruct e4000_config e4000_config = {\n\t\t\t\t.fe = adap->fe[0],\n\t\t\t\t.clock = 28800000,\n\t\t\t};\n\n\t\t\tstrscpy(info.type, \"e4000\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x64;\n\t\t\tinfo.platform_data = &e4000_config;\n\n\t\t\trequest_module(info.type);\n\t\t\tclient = i2c_new_client_device(dev->demod_i2c_adapter,\n\t\t\t\t\t\t       &info);\n\t\t\tif (!i2c_client_has_driver(client))\n\t\t\t\tbreak;\n\n\t\t\tif (!try_module_get(client->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdev->i2c_client_tuner = client;\n\t\t\tsubdev = i2c_get_clientdata(client);\n\t\t}\n\t\tbreak;\n\tcase TUNER_RTL2832_FC2580: {\n\t\t\tstruct fc2580_platform_data fc2580_pdata = {\n\t\t\t\t.dvb_frontend = adap->fe[0],\n\t\t\t};\n\t\t\tstruct i2c_board_info board_info = {};\n\n\t\t\tstrscpy(board_info.type, \"fc2580\", I2C_NAME_SIZE);\n\t\t\tboard_info.addr = 0x56;\n\t\t\tboard_info.platform_data = &fc2580_pdata;\n\t\t\trequest_module(\"fc2580\");\n\t\t\tclient = i2c_new_client_device(dev->demod_i2c_adapter,\n\t\t\t\t\t\t       &board_info);\n\t\t\tif (!i2c_client_has_driver(client))\n\t\t\t\tbreak;\n\t\t\tif (!try_module_get(client->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev->i2c_client_tuner = client;\n\t\t\tsubdev = fc2580_pdata.get_v4l2_subdev(client);\n\t\t}\n\t\tbreak;\n\tcase TUNER_RTL2832_TUA9001: {\n\t\tstruct tua9001_platform_data tua9001_pdata = {\n\t\t\t.dvb_frontend = adap->fe[0],\n\t\t};\n\t\tstruct i2c_board_info board_info = {};\n\n\t\t \n\t\tret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_DIR, 0x00, 0x12);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_EN, 0x12, 0x12);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tstrscpy(board_info.type, \"tua9001\", I2C_NAME_SIZE);\n\t\tboard_info.addr = 0x60;\n\t\tboard_info.platform_data = &tua9001_pdata;\n\t\trequest_module(\"tua9001\");\n\t\tclient = i2c_new_client_device(dev->demod_i2c_adapter,\n\t\t\t\t\t       &board_info);\n\t\tif (!i2c_client_has_driver(client))\n\t\t\tbreak;\n\t\tif (!try_module_get(client->dev.driver->owner)) {\n\t\t\ti2c_unregister_device(client);\n\t\t\tbreak;\n\t\t}\n\t\tdev->i2c_client_tuner = client;\n\t\tbreak;\n\t}\n\tcase TUNER_RTL2832_R820T:\n\t\tfe = dvb_attach(r820t_attach, adap->fe[0],\n\t\t\t\tdev->demod_i2c_adapter,\n\t\t\t\t&rtl2832u_r820t_config);\n\n\t\t \n\t\tadap->fe[0]->ops.read_signal_strength =\n\t\t\t\tadap->fe[0]->ops.tuner_ops.get_rf_strength;\n\t\tbreak;\n\tcase TUNER_RTL2832_R828D:\n\t\tfe = dvb_attach(r820t_attach, adap->fe[0],\n\t\t\t\tdev->demod_i2c_adapter,\n\t\t\t\t&rtl2832u_r828d_config);\n\t\tadap->fe[0]->ops.read_signal_strength =\n\t\t\t\tadap->fe[0]->ops.tuner_ops.get_rf_strength;\n\n\t\tif (adap->fe[1]) {\n\t\t\tfe = dvb_attach(r820t_attach, adap->fe[1],\n\t\t\t\t\tdev->demod_i2c_adapter,\n\t\t\t\t\t&rtl2832u_r828d_config);\n\t\t\tadap->fe[1]->ops.read_signal_strength =\n\t\t\t\t\tadap->fe[1]->ops.tuner_ops.get_rf_strength;\n\t\t}\n\t\tbreak;\n\tcase TUNER_RTL2832_SI2157: {\n\t\t\tstruct si2157_config si2157_config = {\n\t\t\t\t.fe = adap->fe[0],\n\t\t\t\t.if_port = 0,\n\t\t\t\t.inversion = false,\n\t\t\t};\n\n\t\t\tstrscpy(info.type, \"si2157\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x60;\n\t\t\tinfo.platform_data = &si2157_config;\n\t\t\trequest_module(info.type);\n\t\t\tclient = i2c_new_client_device(&d->i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client))\n\t\t\t\tbreak;\n\n\t\t\tif (!try_module_get(client->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdev->i2c_client_tuner = client;\n\t\t\tsubdev = i2c_get_clientdata(client);\n\n\t\t\t \n\t\t\tif (adap->fe[1]) {\n\t\t\t\tadap->fe[1]->tuner_priv =\n\t\t\t\t\t\tadap->fe[0]->tuner_priv;\n\t\t\t\tmemcpy(&adap->fe[1]->ops.tuner_ops,\n\t\t\t\t\t\t&adap->fe[0]->ops.tuner_ops,\n\t\t\t\t\t\tsizeof(struct dvb_tuner_ops));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&d->intf->dev, \"unknown tuner %d\\n\", dev->tuner);\n\t}\n\tif (fe == NULL && dev->i2c_client_tuner == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t \n\tswitch (dev->tuner) {\n\tcase TUNER_RTL2832_FC2580:\n\tcase TUNER_RTL2832_FC0012:\n\tcase TUNER_RTL2832_FC0013:\n\tcase TUNER_RTL2832_E4000:\n\tcase TUNER_RTL2832_R820T:\n\tcase TUNER_RTL2832_R828D:\n\t\tpdata.clk = dev->rtl2832_platform_data.clk;\n\t\tpdata.tuner = dev->tuner;\n\t\tpdata.regmap = dev->rtl2832_platform_data.regmap;\n\t\tpdata.dvb_frontend = adap->fe[0];\n\t\tpdata.dvb_usb_device = d;\n\t\tpdata.v4l2_subdev = subdev;\n\n\t\trequest_module(\"%s\", \"rtl2832_sdr\");\n\t\tpdev = platform_device_register_data(&d->intf->dev,\n\t\t\t\t\t\t     \"rtl2832_sdr\",\n\t\t\t\t\t\t     PLATFORM_DEVID_AUTO,\n\t\t\t\t\t\t     &pdata, sizeof(pdata));\n\t\tif (IS_ERR(pdev) || pdev->dev.driver == NULL)\n\t\t\tbreak;\n\t\tdev->platform_device_sdr = pdev;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&d->intf->dev, \"no SDR for tuner=%d\\n\", dev->tuner);\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&d->intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl28xxu_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct rtl28xxu_dev *dev = adap_to_priv(adap);\n\n\tif (dev->chip_id == CHIP_ID_RTL2831U)\n\t\treturn rtl2831u_tuner_attach(adap);\n\telse\n\t\treturn rtl2832u_tuner_attach(adap);\n}\n\nstatic int rtl28xxu_tuner_detach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct rtl28xxu_dev *dev = d_to_priv(d);\n\tstruct i2c_client *client;\n\tstruct platform_device *pdev;\n\n\tdev_dbg(&d->intf->dev, \"\\n\");\n\n\t \n\tpdev = dev->platform_device_sdr;\n\tif (pdev)\n\t\tplatform_device_unregister(pdev);\n\n\t \n\tclient = dev->i2c_client_tuner;\n\tif (client) {\n\t\tmodule_put(client->dev.driver->owner);\n\t\ti2c_unregister_device(client);\n\t}\n\n\treturn 0;\n}\n\nstatic int rtl28xxu_init(struct dvb_usb_device *d)\n{\n\tint ret;\n\tu8 val;\n\n\tdev_dbg(&d->intf->dev, \"\\n\");\n\n\t \n\tret = rtl28xxu_rd_reg(d, USB_SYSCTL_0, &val);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tval |= 0x09;\n\tret = rtl28xxu_wr_reg(d, USB_SYSCTL_0, val);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = rtl28xxu_wr_regs(d, USB_EPA_MAXPKT, \"\\x00\\x02\\x00\\x00\", 4);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = rtl28xxu_wr_regs(d, USB_EPA_FIFO_CFG, \"\\x14\\x00\\x00\\x00\", 4);\n\tif (ret)\n\t\tgoto err;\n\n\treturn ret;\nerr:\n\tdev_dbg(&d->intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2831u_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tint ret;\n\tu8 gpio, sys0, epa_ctl[2];\n\n\tdev_dbg(&d->intf->dev, \"onoff=%d\\n\", onoff);\n\n\t \n\tret = rtl28xxu_rd_reg(d, SYS_SYS0, &sys0);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = rtl28xxu_rd_reg(d, SYS_GPIO_OUT_VAL, &gpio);\n\tif (ret)\n\t\tgoto err;\n\n\tdev_dbg(&d->intf->dev, \"RD SYS0=%02x GPIO_OUT_VAL=%02x\\n\", sys0, gpio);\n\n\tif (onoff) {\n\t\tgpio |= 0x01;  \n\t\tgpio &= (~0x10);  \n\t\tgpio |= 0x04;  \n\t\tsys0 = sys0 & 0x0f;\n\t\tsys0 |= 0xe0;\n\t\tepa_ctl[0] = 0x00;  \n\t\tepa_ctl[1] = 0x00;  \n\t} else {\n\t\tgpio &= (~0x01);  \n\t\tgpio |= 0x10;  \n\t\tgpio &= (~0x04);  \n\t\tsys0 = sys0 & (~0xc0);\n\t\tepa_ctl[0] = 0x10;  \n\t\tepa_ctl[1] = 0x02;  \n\t}\n\n\tdev_dbg(&d->intf->dev, \"WR SYS0=%02x GPIO_OUT_VAL=%02x\\n\", sys0, gpio);\n\n\t \n\tret = rtl28xxu_wr_reg(d, SYS_SYS0, sys0);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = rtl28xxu_wr_reg(d, SYS_GPIO_OUT_VAL, gpio);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = rtl28xxu_wr_regs(d, USB_EPA_CTL, epa_ctl, 2);\n\tif (ret)\n\t\tgoto err;\n\n\tif (onoff)\n\t\tusb_clear_halt(d->udev, usb_rcvbulkpipe(d->udev, 0x81));\n\n\treturn ret;\nerr:\n\tdev_dbg(&d->intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2832u_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tint ret;\n\n\tdev_dbg(&d->intf->dev, \"onoff=%d\\n\", onoff);\n\n\tif (onoff) {\n\t\t \n\t\tret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_VAL, 0x08, 0x18);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tret = rtl28xxu_wr_reg_mask(d, SYS_DEMOD_CTL1, 0x00, 0x10);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tret = rtl28xxu_wr_reg_mask(d, SYS_DEMOD_CTL, 0x80, 0x80);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tret = rtl28xxu_wr_reg_mask(d, SYS_DEMOD_CTL, 0x20, 0x20);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tret = rtl28xxu_wr_regs(d, USB_EPA_CTL, \"\\x00\\x00\", 2);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = usb_clear_halt(d->udev, usb_rcvbulkpipe(d->udev, 0x81));\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\t \n\t\tret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_VAL, 0x10, 0x10);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tret = rtl28xxu_wr_reg_mask(d, SYS_DEMOD_CTL, 0x00, 0x80);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tret = rtl28xxu_wr_regs(d, USB_EPA_CTL, \"\\x10\\x02\", 2);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn ret;\nerr:\n\tdev_dbg(&d->intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl28xxu_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tstruct rtl28xxu_dev *dev = d_to_priv(d);\n\n\tif (dev->chip_id == CHIP_ID_RTL2831U)\n\t\treturn rtl2831u_power_ctrl(d, onoff);\n\telse\n\t\treturn rtl2832u_power_ctrl(d, onoff);\n}\n\nstatic int rtl28xxu_frontend_ctrl(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dvb_usb_device *d = fe_to_d(fe);\n\tstruct rtl28xxu_dev *dev = fe_to_priv(fe);\n\tstruct rtl2832_platform_data *pdata = &dev->rtl2832_platform_data;\n\tint ret;\n\tu8 val;\n\n\tdev_dbg(&d->intf->dev, \"fe=%d onoff=%d\\n\", fe->id, onoff);\n\n\tif (dev->chip_id == CHIP_ID_RTL2831U)\n\t\treturn 0;\n\n\tif (fe->id == 0) {\n\t\t \n\t\tif (onoff)\n\t\t\tval = 0x48;  \n\t\telse\n\t\t\tval = 0x00;  \n\n\t\tret = rtl28xxu_wr_reg_mask(d, SYS_DEMOD_CTL, val, 0x48);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else if (fe->id == 1) {\n\t\t \n\t\tret = pdata->slave_ts_ctrl(dev->i2c_client_demod, onoff);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&d->intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\n#if IS_ENABLED(CONFIG_RC_CORE)\nstatic int rtl2831u_rc_query(struct dvb_usb_device *d)\n{\n\tint ret, i;\n\tstruct rtl28xxu_dev *dev = d->priv;\n\tu8 buf[5];\n\tu32 rc_code;\n\tstatic const struct rtl28xxu_reg_val rc_nec_tab[] = {\n\t\t{ 0x3033, 0x80 },\n\t\t{ 0x3020, 0x43 },\n\t\t{ 0x3021, 0x16 },\n\t\t{ 0x3022, 0x16 },\n\t\t{ 0x3023, 0x5a },\n\t\t{ 0x3024, 0x2d },\n\t\t{ 0x3025, 0x16 },\n\t\t{ 0x3026, 0x01 },\n\t\t{ 0x3028, 0xb0 },\n\t\t{ 0x3029, 0x04 },\n\t\t{ 0x302c, 0x88 },\n\t\t{ 0x302e, 0x13 },\n\t\t{ 0x3030, 0xdf },\n\t\t{ 0x3031, 0x05 },\n\t};\n\n\t \n\tif (!dev->rc_active) {\n\t\tfor (i = 0; i < ARRAY_SIZE(rc_nec_tab); i++) {\n\t\t\tret = rtl28xxu_wr_reg(d, rc_nec_tab[i].reg,\n\t\t\t\t\trc_nec_tab[i].val);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t\tdev->rc_active = true;\n\t}\n\n\tret = rtl28xxu_rd_regs(d, SYS_IRRC_RP, buf, 5);\n\tif (ret)\n\t\tgoto err;\n\n\tif (buf[4] & 0x01) {\n\t\tenum rc_proto proto;\n\n\t\tif (buf[2] == (u8) ~buf[3]) {\n\t\t\tif (buf[0] == (u8) ~buf[1]) {\n\t\t\t\t \n\t\t\t\trc_code = RC_SCANCODE_NEC(buf[0], buf[2]);\n\t\t\t\tproto = RC_PROTO_NEC;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\trc_code = RC_SCANCODE_NECX(buf[0] << 8 | buf[1],\n\t\t\t\t\t\t\t   buf[2]);\n\t\t\t\tproto = RC_PROTO_NECX;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\trc_code = RC_SCANCODE_NEC32(buf[0] << 24 | buf[1] << 16 |\n\t\t\t\t\t\t    buf[2] << 8  | buf[3]);\n\t\t\tproto = RC_PROTO_NEC32;\n\t\t}\n\n\t\trc_keydown(d->rc_dev, proto, rc_code, 0);\n\n\t\tret = rtl28xxu_wr_reg(d, SYS_IRRC_SR, 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tret = rtl28xxu_wr_reg(d, SYS_IRRC_SR, 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn ret;\nerr:\n\tdev_dbg(&d->intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2831u_get_rc_config(struct dvb_usb_device *d,\n\t\tstruct dvb_usb_rc *rc)\n{\n\trc->map_name = RC_MAP_EMPTY;\n\trc->allowed_protos = RC_PROTO_BIT_NEC | RC_PROTO_BIT_NECX |\n\t\t\t\t\t\t\tRC_PROTO_BIT_NEC32;\n\trc->query = rtl2831u_rc_query;\n\trc->interval = 400;\n\n\treturn 0;\n}\n\nstatic int rtl2832u_rc_query(struct dvb_usb_device *d)\n{\n\tint ret, i, len;\n\tstruct rtl28xxu_dev *dev = d->priv;\n\tstruct ir_raw_event ev = {};\n\tu8 buf[128];\n\tstatic const struct rtl28xxu_reg_val_mask refresh_tab[] = {\n\t\t{IR_RX_IF,               0x03, 0xff},\n\t\t{IR_RX_BUF_CTRL,         0x80, 0xff},\n\t\t{IR_RX_CTRL,             0x80, 0xff},\n\t};\n\n\t \n\tif (!dev->rc_active) {\n\t\tstatic const struct rtl28xxu_reg_val_mask init_tab[] = {\n\t\t\t{SYS_DEMOD_CTL1,         0x00, 0x04},\n\t\t\t{SYS_DEMOD_CTL1,         0x00, 0x08},\n\t\t\t{USB_CTRL,               0x20, 0x20},\n\t\t\t{SYS_GPIO_DIR,           0x00, 0x08},\n\t\t\t{SYS_GPIO_OUT_EN,        0x08, 0x08},\n\t\t\t{SYS_GPIO_OUT_VAL,       0x08, 0x08},\n\t\t\t{IR_MAX_DURATION0,       0xd0, 0xff},\n\t\t\t{IR_MAX_DURATION1,       0x07, 0xff},\n\t\t\t{IR_IDLE_LEN0,           0xc0, 0xff},\n\t\t\t{IR_IDLE_LEN1,           0x00, 0xff},\n\t\t\t{IR_GLITCH_LEN,          0x03, 0xff},\n\t\t\t{IR_RX_CLK,              0x09, 0xff},\n\t\t\t{IR_RX_CFG,              0x1c, 0xff},\n\t\t\t{IR_MAX_H_TOL_LEN,       0x1e, 0xff},\n\t\t\t{IR_MAX_L_TOL_LEN,       0x1e, 0xff},\n\t\t\t{IR_RX_CTRL,             0x80, 0xff},\n\t\t};\n\n\t\tfor (i = 0; i < ARRAY_SIZE(init_tab); i++) {\n\t\t\tret = rtl28xxu_wr_reg_mask(d, init_tab[i].reg,\n\t\t\t\t\tinit_tab[i].val, init_tab[i].mask);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tdev->rc_active = true;\n\t}\n\n\tret = rtl28xxu_rd_reg(d, IR_RX_IF, &buf[0]);\n\tif (ret)\n\t\tgoto err;\n\n\tif (buf[0] != 0x83)\n\t\tgoto exit;\n\n\tret = rtl28xxu_rd_reg(d, IR_RX_BC, &buf[0]);\n\tif (ret || buf[0] > sizeof(buf))\n\t\tgoto err;\n\n\tlen = buf[0];\n\n\t \n\tret = rtl28xxu_rd_regs(d, IR_RX_BUF, buf, len);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(refresh_tab); i++) {\n\t\tret = rtl28xxu_wr_reg_mask(d, refresh_tab[i].reg,\n\t\t\t\trefresh_tab[i].val, refresh_tab[i].mask);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tfor (i = 0; i < len; i++) {\n\t\tev.pulse = buf[i] >> 7;\n\t\tev.duration = 51 * (buf[i] & 0x7f);\n\t\tir_raw_event_store_with_filter(d->rc_dev, &ev);\n\t}\n\n\t \n\tir_raw_event_handle(d->rc_dev);\nexit:\n\treturn ret;\nerr:\n\tdev_dbg(&d->intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2832u_get_rc_config(struct dvb_usb_device *d,\n\t\tstruct dvb_usb_rc *rc)\n{\n\t \n\tif (rtl28xxu_disable_rc)\n\t\treturn rtl28xxu_wr_reg(d, IR_RX_IE, 0x00);\n\n\t \n\tif (!rc->map_name)\n\t\trc->map_name = RC_MAP_EMPTY;\n\trc->allowed_protos = RC_PROTO_BIT_ALL_IR_DECODER;\n\trc->driver_type = RC_DRIVER_IR_RAW;\n\trc->query = rtl2832u_rc_query;\n\trc->interval = 200;\n\t \n\trc->timeout = 0xbf * 51;\n\n\treturn 0;\n}\n\nstatic int rtl28xxu_get_rc_config(struct dvb_usb_device *d,\n\t\tstruct dvb_usb_rc *rc)\n{\n\tstruct rtl28xxu_dev *dev = d_to_priv(d);\n\n\tif (dev->chip_id == CHIP_ID_RTL2831U)\n\t\treturn rtl2831u_get_rc_config(d, rc);\n\telse\n\t\treturn rtl2832u_get_rc_config(d, rc);\n}\n#else\n#define rtl28xxu_get_rc_config NULL\n#endif\n\nstatic int rtl28xxu_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)\n{\n\tstruct rtl28xxu_dev *dev = adap_to_priv(adap);\n\n\tif (dev->chip_id == CHIP_ID_RTL2831U) {\n\t\tstruct rtl2830_platform_data *pdata = &dev->rtl2830_platform_data;\n\n\t\treturn pdata->pid_filter_ctrl(adap->fe[0], onoff);\n\t} else {\n\t\tstruct rtl2832_platform_data *pdata = &dev->rtl2832_platform_data;\n\n\t\treturn pdata->pid_filter_ctrl(adap->fe[0], onoff);\n\t}\n}\n\nstatic int rtl28xxu_pid_filter(struct dvb_usb_adapter *adap, int index,\n\t\t\t       u16 pid, int onoff)\n{\n\tstruct rtl28xxu_dev *dev = adap_to_priv(adap);\n\n\tif (dev->chip_id == CHIP_ID_RTL2831U) {\n\t\tstruct rtl2830_platform_data *pdata = &dev->rtl2830_platform_data;\n\n\t\treturn pdata->pid_filter(adap->fe[0], index, pid, onoff);\n\t} else {\n\t\tstruct rtl2832_platform_data *pdata = &dev->rtl2832_platform_data;\n\n\t\treturn pdata->pid_filter(adap->fe[0], index, pid, onoff);\n\t}\n}\n\nstatic const struct dvb_usb_device_properties rtl28xxu_props = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\t.size_of_priv = sizeof(struct rtl28xxu_dev),\n\n\t.identify_state = rtl28xxu_identify_state,\n\t.power_ctrl = rtl28xxu_power_ctrl,\n\t.frontend_ctrl = rtl28xxu_frontend_ctrl,\n\t.i2c_algo = &rtl28xxu_i2c_algo,\n\t.read_config = rtl28xxu_read_config,\n\t.frontend_attach = rtl28xxu_frontend_attach,\n\t.frontend_detach = rtl28xxu_frontend_detach,\n\t.tuner_attach = rtl28xxu_tuner_attach,\n\t.tuner_detach = rtl28xxu_tuner_detach,\n\t.init = rtl28xxu_init,\n\t.get_rc_config = rtl28xxu_get_rc_config,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\n\t\t\t.pid_filter_count = 32,\n\t\t\t.pid_filter_ctrl = rtl28xxu_pid_filter_ctrl,\n\t\t\t.pid_filter = rtl28xxu_pid_filter,\n\n\t\t\t.stream = DVB_USB_STREAM_BULK(0x81, 6, 8 * 512),\n\t\t},\n\t},\n};\n\nstatic const struct usb_device_id rtl28xxu_id_table[] = {\n\t \n\t{ DVB_USB_DEVICE(USB_VID_REALTEK, USB_PID_REALTEK_RTL2831U,\n\t\t&rtl28xxu_props, \"Realtek RTL2831U reference design\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_WIDEVIEW, USB_PID_FREECOM_DVBT,\n\t\t&rtl28xxu_props, \"Freecom USB2.0 DVB-T\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_WIDEVIEW, USB_PID_FREECOM_DVBT_2,\n\t\t&rtl28xxu_props, \"Freecom USB2.0 DVB-T\", NULL) },\n\n\t \n\t{ DVB_USB_DEVICE(USB_VID_REALTEK, 0x2832,\n\t\t&rtl28xxu_props, \"Realtek RTL2832U reference design\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_REALTEK, 0x2838,\n\t\t&rtl28xxu_props, \"Realtek RTL2832U reference design\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_T_STICK_BLACK_REV1,\n\t\t&rtl28xxu_props, \"TerraTec Cinergy T Stick Black\", RC_MAP_TERRATEC_SLIM) },\n\t{ DVB_USB_DEVICE(USB_VID_GTEK, USB_PID_DELOCK_USB2_DVBT,\n\t\t&rtl28xxu_props, \"G-Tek Electronics Group Lifeview LV5TDLX DVB-T\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_TERRATEC, USB_PID_NOXON_DAB_STICK,\n\t\t&rtl28xxu_props, \"TerraTec NOXON DAB Stick\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_TERRATEC, USB_PID_NOXON_DAB_STICK_REV2,\n\t\t&rtl28xxu_props, \"TerraTec NOXON DAB Stick (rev 2)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_TERRATEC, USB_PID_NOXON_DAB_STICK_REV3,\n\t\t&rtl28xxu_props, \"TerraTec NOXON DAB Stick (rev 3)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_GTEK, USB_PID_TREKSTOR_TERRES_2_0,\n\t\t&rtl28xxu_props, \"Trekstor DVB-T Stick Terres 2.0\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_DEXATEK, 0x1101,\n\t\t&rtl28xxu_props, \"Dexatek DK DVB-T Dongle\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_LEADTEK, 0x6680,\n\t\t&rtl28xxu_props, \"DigitalNow Quad DVB-T Receiver\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_LEADTEK, USB_PID_WINFAST_DTV_DONGLE_MINID,\n\t\t&rtl28xxu_props, \"Leadtek Winfast DTV Dongle Mini D\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_LEADTEK, USB_PID_WINFAST_DTV2000DS_PLUS,\n\t\t&rtl28xxu_props, \"Leadtek WinFast DTV2000DS Plus\", RC_MAP_LEADTEK_Y04G0051) },\n\t{ DVB_USB_DEVICE(USB_VID_TERRATEC, 0x00d3,\n\t\t&rtl28xxu_props, \"TerraTec Cinergy T Stick RC (Rev. 3)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_DEXATEK, 0x1102,\n\t\t&rtl28xxu_props, \"Dexatek DK mini DVB-T Dongle\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_TERRATEC, 0x00d7,\n\t\t&rtl28xxu_props, \"TerraTec Cinergy T Stick+\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, 0xd3a8,\n\t\t&rtl28xxu_props, \"ASUS My Cinema-U3100Mini Plus V2\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, 0xd393,\n\t\t&rtl28xxu_props, \"GIGABYTE U7300\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_DEXATEK, 0x1104,\n\t\t&rtl28xxu_props, \"MSI DIGIVOX Micro HD\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_COMPRO, 0x0620,\n\t\t&rtl28xxu_props, \"Compro VideoMate U620F\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_COMPRO, 0x0650,\n\t\t&rtl28xxu_props, \"Compro VideoMate U650F\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, 0xd394,\n\t\t&rtl28xxu_props, \"MaxMedia HU394-T\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_LEADTEK, 0x6a03,\n\t\t&rtl28xxu_props, \"Leadtek WinFast DTV Dongle mini\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_GTEK, USB_PID_CPYTO_REDI_PC50A,\n\t\t&rtl28xxu_props, \"Crypto ReDi PC 50 A\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KYE, 0x707f,\n\t\t&rtl28xxu_props, \"Genius TVGo DVB-T03\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, 0xd395,\n\t\t&rtl28xxu_props, \"Peak DVB-T USB\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_SVEON_STV20_RTL2832U,\n\t\t&rtl28xxu_props, \"Sveon STV20\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_SVEON_STV21,\n\t\t&rtl28xxu_props, \"Sveon STV21\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_SVEON_STV27,\n\t\t&rtl28xxu_props, \"Sveon STV27\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_TURBOX_DTT_2000,\n\t\t&rtl28xxu_props, \"TURBO-X Pure TV Tuner DTT-2000\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_GTEK, USB_PID_PROLECTRIX_DV107669,\n\t\t&rtl28xxu_props, \"PROlectrix DV107669\", NULL) },\n\n\t \n\t{ DVB_USB_DEVICE(USB_VID_HANFTEK, 0x0131,\n\t\t&rtl28xxu_props, \"Astrometa DVB-T2\",\n\t\tRC_MAP_ASTROMETA_T2HYBRID) },\n\t{ DVB_USB_DEVICE(0x5654, 0xca42,\n\t\t&rtl28xxu_props, \"GoTView MasterHD 3\", NULL) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, rtl28xxu_id_table);\n\nstatic struct usb_driver rtl28xxu_usb_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = rtl28xxu_id_table,\n\t.probe = dvb_usbv2_probe,\n\t.disconnect = dvb_usbv2_disconnect,\n\t.suspend = dvb_usbv2_suspend,\n\t.resume = dvb_usbv2_resume,\n\t.reset_resume = dvb_usbv2_reset_resume,\n\t.no_dynamic_id = 1,\n\t.soft_unbind = 1,\n};\n\nmodule_usb_driver(rtl28xxu_usb_driver);\n\nMODULE_DESCRIPTION(\"Realtek RTL28xxU DVB USB driver\");\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_AUTHOR(\"Thomas Mair <thomas.mair86@googlemail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}