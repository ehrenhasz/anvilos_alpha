{
  "module_name": "mxl111sf-demod.c",
  "hash_id": "8c11d4a762af1897467beb6f80aa93d3588b979ba33612011131816f0d23e970",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/mxl111sf-demod.c",
  "human_readable_source": "\n \n\n#include \"mxl111sf-demod.h\"\n#include \"mxl111sf-reg.h\"\n\n \nstatic int mxl111sf_demod_debug;\nmodule_param_named(debug, mxl111sf_demod_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=info (or-able)).\");\n\n#define mxl_dbg(fmt, arg...) \\\n\tif (mxl111sf_demod_debug) \\\n\t\tmxl_printk(KERN_DEBUG, fmt, ##arg)\n\n \n\nstruct mxl111sf_demod_state {\n\tstruct mxl111sf_state *mxl_state;\n\n\tconst struct mxl111sf_demod_config *cfg;\n\n\tstruct dvb_frontend fe;\n};\n\n \n\nstatic int mxl111sf_demod_read_reg(struct mxl111sf_demod_state *state,\n\t\t\t\t   u8 addr, u8 *data)\n{\n\treturn (state->cfg->read_reg) ?\n\t\tstate->cfg->read_reg(state->mxl_state, addr, data) :\n\t\t-EINVAL;\n}\n\nstatic int mxl111sf_demod_write_reg(struct mxl111sf_demod_state *state,\n\t\t\t\t    u8 addr, u8 data)\n{\n\treturn (state->cfg->write_reg) ?\n\t\tstate->cfg->write_reg(state->mxl_state, addr, data) :\n\t\t-EINVAL;\n}\n\nstatic\nint mxl111sf_demod_program_regs(struct mxl111sf_demod_state *state,\n\t\t\t\tstruct mxl111sf_reg_ctrl_info *ctrl_reg_info)\n{\n\treturn (state->cfg->program_regs) ?\n\t\tstate->cfg->program_regs(state->mxl_state, ctrl_reg_info) :\n\t\t-EINVAL;\n}\n\n \n \n\nstatic\nint mxl1x1sf_demod_get_tps_code_rate(struct mxl111sf_demod_state *state,\n\t\t\t\t     enum fe_code_rate *code_rate)\n{\n\tu8 val;\n\tint ret = mxl111sf_demod_read_reg(state, V6_CODE_RATE_TPS_REG, &val);\n\t \n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tswitch (val & V6_CODE_RATE_TPS_MASK) {\n\tcase 0:\n\t\t*code_rate = FEC_1_2;\n\t\tbreak;\n\tcase 1:\n\t\t*code_rate = FEC_2_3;\n\t\tbreak;\n\tcase 2:\n\t\t*code_rate = FEC_3_4;\n\t\tbreak;\n\tcase 3:\n\t\t*code_rate = FEC_5_6;\n\t\tbreak;\n\tcase 4:\n\t\t*code_rate = FEC_7_8;\n\t\tbreak;\n\t}\nfail:\n\treturn ret;\n}\n\nstatic\nint mxl1x1sf_demod_get_tps_modulation(struct mxl111sf_demod_state *state,\n\t\t\t\t      enum fe_modulation *modulation)\n{\n\tu8 val;\n\tint ret = mxl111sf_demod_read_reg(state, V6_MODORDER_TPS_REG, &val);\n\t \n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tswitch ((val & V6_PARAM_CONSTELLATION_MASK) >> 4) {\n\tcase 0:\n\t\t*modulation = QPSK;\n\t\tbreak;\n\tcase 1:\n\t\t*modulation = QAM_16;\n\t\tbreak;\n\tcase 2:\n\t\t*modulation = QAM_64;\n\t\tbreak;\n\t}\nfail:\n\treturn ret;\n}\n\nstatic\nint mxl1x1sf_demod_get_tps_guard_fft_mode(struct mxl111sf_demod_state *state,\n\t\t\t\t\t  enum fe_transmit_mode *fft_mode)\n{\n\tu8 val;\n\tint ret = mxl111sf_demod_read_reg(state, V6_MODE_TPS_REG, &val);\n\t \n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tswitch ((val & V6_PARAM_FFT_MODE_MASK) >> 2) {\n\tcase 0:\n\t\t*fft_mode = TRANSMISSION_MODE_2K;\n\t\tbreak;\n\tcase 1:\n\t\t*fft_mode = TRANSMISSION_MODE_8K;\n\t\tbreak;\n\tcase 2:\n\t\t*fft_mode = TRANSMISSION_MODE_4K;\n\t\tbreak;\n\t}\nfail:\n\treturn ret;\n}\n\nstatic\nint mxl1x1sf_demod_get_tps_guard_interval(struct mxl111sf_demod_state *state,\n\t\t\t\t\t  enum fe_guard_interval *guard)\n{\n\tu8 val;\n\tint ret = mxl111sf_demod_read_reg(state, V6_CP_TPS_REG, &val);\n\t \n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tswitch ((val & V6_PARAM_GI_MASK) >> 4) {\n\tcase 0:\n\t\t*guard = GUARD_INTERVAL_1_32;\n\t\tbreak;\n\tcase 1:\n\t\t*guard = GUARD_INTERVAL_1_16;\n\t\tbreak;\n\tcase 2:\n\t\t*guard = GUARD_INTERVAL_1_8;\n\t\tbreak;\n\tcase 3:\n\t\t*guard = GUARD_INTERVAL_1_4;\n\t\tbreak;\n\t}\nfail:\n\treturn ret;\n}\n\nstatic\nint mxl1x1sf_demod_get_tps_hierarchy(struct mxl111sf_demod_state *state,\n\t\t\t\t     enum fe_hierarchy *hierarchy)\n{\n\tu8 val;\n\tint ret = mxl111sf_demod_read_reg(state, V6_TPS_HIERACHY_REG, &val);\n\t \n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tswitch ((val & V6_TPS_HIERARCHY_INFO_MASK) >> 6) {\n\tcase 0:\n\t\t*hierarchy = HIERARCHY_NONE;\n\t\tbreak;\n\tcase 1:\n\t\t*hierarchy = HIERARCHY_1;\n\t\tbreak;\n\tcase 2:\n\t\t*hierarchy = HIERARCHY_2;\n\t\tbreak;\n\tcase 3:\n\t\t*hierarchy = HIERARCHY_4;\n\t\tbreak;\n\t}\nfail:\n\treturn ret;\n}\n\n \n \n\nstatic\nint mxl1x1sf_demod_get_sync_lock_status(struct mxl111sf_demod_state *state,\n\t\t\t\t\tint *sync_lock)\n{\n\tu8 val = 0;\n\tint ret = mxl111sf_demod_read_reg(state, V6_SYNC_LOCK_REG, &val);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\t*sync_lock = (val & SYNC_LOCK_MASK) >> 4;\nfail:\n\treturn ret;\n}\n\nstatic\nint mxl1x1sf_demod_get_rs_lock_status(struct mxl111sf_demod_state *state,\n\t\t\t\t      int *rs_lock)\n{\n\tu8 val = 0;\n\tint ret = mxl111sf_demod_read_reg(state, V6_RS_LOCK_DET_REG, &val);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\t*rs_lock = (val & RS_LOCK_DET_MASK) >> 3;\nfail:\n\treturn ret;\n}\n\nstatic\nint mxl1x1sf_demod_get_tps_lock_status(struct mxl111sf_demod_state *state,\n\t\t\t\t       int *tps_lock)\n{\n\tu8 val = 0;\n\tint ret = mxl111sf_demod_read_reg(state, V6_TPS_LOCK_REG, &val);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\t*tps_lock = (val & V6_PARAM_TPS_LOCK_MASK) >> 6;\nfail:\n\treturn ret;\n}\n\nstatic\nint mxl1x1sf_demod_get_fec_lock_status(struct mxl111sf_demod_state *state,\n\t\t\t\t       int *fec_lock)\n{\n\tu8 val = 0;\n\tint ret = mxl111sf_demod_read_reg(state, V6_IRQ_STATUS_REG, &val);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\t*fec_lock = (val & IRQ_MASK_FEC_LOCK) >> 4;\nfail:\n\treturn ret;\n}\n\n#if 0\nstatic\nint mxl1x1sf_demod_get_cp_lock_status(struct mxl111sf_demod_state *state,\n\t\t\t\t      int *cp_lock)\n{\n\tu8 val = 0;\n\tint ret = mxl111sf_demod_read_reg(state, V6_CP_LOCK_DET_REG, &val);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\t*cp_lock = (val & V6_CP_LOCK_DET_MASK) >> 2;\nfail:\n\treturn ret;\n}\n#endif\n\nstatic int mxl1x1sf_demod_reset_irq_status(struct mxl111sf_demod_state *state)\n{\n\treturn mxl111sf_demod_write_reg(state, 0x0e, 0xff);\n}\n\n \n\nstatic int mxl111sf_demod_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct mxl111sf_demod_state *state = fe->demodulator_priv;\n\tint ret = 0;\n\n\tstruct mxl111sf_reg_ctrl_info phy_pll_patch[] = {\n\t\t{0x00, 0xff, 0x01},  \n\t\t{0x40, 0xff, 0x05},\n\t\t{0x40, 0xff, 0x01},\n\t\t{0x41, 0xff, 0xca},\n\t\t{0x41, 0xff, 0xc0},\n\t\t{0x00, 0xff, 0x00},  \n\t\t{0,    0,    0}\n\t};\n\n\tmxl_dbg(\"()\");\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tret = fe->ops.tuner_ops.set_params(fe);\n\t\tif (mxl_fail(ret))\n\t\t\tgoto fail;\n\t\tmsleep(50);\n\t}\n\tret = mxl111sf_demod_program_regs(state, phy_pll_patch);\n\tmxl_fail(ret);\n\tmsleep(50);\n\tret = mxl1x1sf_demod_reset_irq_status(state);\n\tmxl_fail(ret);\n\tmsleep(100);\nfail:\n\treturn ret;\n}\n\n \n\n#if 0\n \n \nstatic\nint mxl1x1sf_demod_reset_packet_error_count(struct mxl111sf_demod_state *state)\n{\n\tstruct mxl111sf_reg_ctrl_info reset_per_count[] = {\n\t\t{0x20, 0x01, 0x01},\n\t\t{0x20, 0x01, 0x00},\n\t\t{0,    0,    0}\n\t};\n\treturn mxl111sf_demod_program_regs(state, reset_per_count);\n}\n#endif\n\n \n \nstatic int mxl111sf_demod_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct mxl111sf_demod_state *state = fe->demodulator_priv;\n\tu32 fec_per_count, fec_per_scale;\n\tu8 val;\n\tint ret;\n\n\t*ucblocks = 0;\n\n\t \n\tret = mxl111sf_demod_read_reg(state, V6_FEC_PER_COUNT_REG, &val);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tfec_per_count = val;\n\n\t \n\tret = mxl111sf_demod_read_reg(state, V6_FEC_PER_SCALE_REG, &val);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tval &= V6_FEC_PER_SCALE_MASK;\n\tval *= 4;\n\n\tfec_per_scale = 1 << val;\n\n\tfec_per_count *= fec_per_scale;\n\n\t*ucblocks = fec_per_count;\nfail:\n\treturn ret;\n}\n\n#ifdef MXL111SF_DEMOD_ENABLE_CALCULATIONS\n \n#define CALCULATE_BER(avg_errors, count) \\\n\t((u32)(avg_errors * 4)/(count*64*188*8))\n#define CALCULATE_SNR(data) \\\n\t((u32)((10 * (u32)data / 64) - 2.5))\n#else\n#define CALCULATE_BER(avg_errors, count) 0\n#define CALCULATE_SNR(data) 0\n#endif\n\nstatic int mxl111sf_demod_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct mxl111sf_demod_state *state = fe->demodulator_priv;\n\tu8 val1, val2, val3;\n\tint ret;\n\n\t*ber = 0;\n\n\tret = mxl111sf_demod_read_reg(state, V6_RS_AVG_ERRORS_LSB_REG, &val1);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_demod_read_reg(state, V6_RS_AVG_ERRORS_MSB_REG, &val2);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_demod_read_reg(state, V6_N_ACCUMULATE_REG, &val3);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\t*ber = CALCULATE_BER((val1 | (val2 << 8)), val3);\nfail:\n\treturn ret;\n}\n\nstatic int mxl111sf_demod_calc_snr(struct mxl111sf_demod_state *state,\n\t\t\t\t   u16 *snr)\n{\n\tu8 val1, val2;\n\tint ret;\n\n\t*snr = 0;\n\n\tret = mxl111sf_demod_read_reg(state, V6_SNR_RB_LSB_REG, &val1);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_demod_read_reg(state, V6_SNR_RB_MSB_REG, &val2);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\t*snr = CALCULATE_SNR(val1 | ((val2 & 0x03) << 8));\nfail:\n\treturn ret;\n}\n\nstatic int mxl111sf_demod_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct mxl111sf_demod_state *state = fe->demodulator_priv;\n\n\tint ret = mxl111sf_demod_calc_snr(state, snr);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\t*snr /= 10;  \nfail:\n\treturn ret;\n}\n\nstatic int mxl111sf_demod_read_status(struct dvb_frontend *fe,\n\t\t\t\t      enum fe_status *status)\n{\n\tstruct mxl111sf_demod_state *state = fe->demodulator_priv;\n\tint ret, locked, cr_lock, sync_lock, fec_lock;\n\n\t*status = 0;\n\n\tret = mxl1x1sf_demod_get_rs_lock_status(state, &locked);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl1x1sf_demod_get_tps_lock_status(state, &cr_lock);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl1x1sf_demod_get_sync_lock_status(state, &sync_lock);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl1x1sf_demod_get_fec_lock_status(state, &fec_lock);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tif (locked)\n\t\t*status |= FE_HAS_SIGNAL;\n\tif (cr_lock)\n\t\t*status |= FE_HAS_CARRIER;\n\tif (sync_lock)\n\t\t*status |= FE_HAS_SYNC;\n\tif (fec_lock)  \n\t\t*status |= FE_HAS_VITERBI;\n\n\tif ((locked) && (cr_lock) && (sync_lock))\n\t\t*status |= FE_HAS_LOCK;\nfail:\n\treturn ret;\n}\n\nstatic int mxl111sf_demod_read_signal_strength(struct dvb_frontend *fe,\n\t\t\t\t\t       u16 *signal_strength)\n{\n\tstruct mxl111sf_demod_state *state = fe->demodulator_priv;\n\tenum fe_modulation modulation;\n\tint ret;\n\tu16 snr;\n\n\tret = mxl111sf_demod_calc_snr(state, &snr);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = mxl1x1sf_demod_get_tps_modulation(state, &modulation);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (modulation) {\n\tcase QPSK:\n\t\t*signal_strength = (snr >= 1300) ?\n\t\t\tmin(65535, snr * 44) : snr * 38;\n\t\tbreak;\n\tcase QAM_16:\n\t\t*signal_strength = (snr >= 1500) ?\n\t\t\tmin(65535, snr * 38) : snr * 33;\n\t\tbreak;\n\tcase QAM_64:\n\t\t*signal_strength = (snr >= 2000) ?\n\t\t\tmin(65535, snr * 29) : snr * 25;\n\t\tbreak;\n\tdefault:\n\t\t*signal_strength = 0;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxl111sf_demod_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t       struct dtv_frontend_properties *p)\n{\n\tstruct mxl111sf_demod_state *state = fe->demodulator_priv;\n\n\tmxl_dbg(\"()\");\n#if 0\n\tp->inversion =   ? INVERSION_ON : INVERSION_OFF;\n#endif\n\tif (fe->ops.tuner_ops.get_bandwidth)\n\t\tfe->ops.tuner_ops.get_bandwidth(fe, &p->bandwidth_hz);\n\tif (fe->ops.tuner_ops.get_frequency)\n\t\tfe->ops.tuner_ops.get_frequency(fe, &p->frequency);\n\tmxl1x1sf_demod_get_tps_code_rate(state, &p->code_rate_HP);\n\tmxl1x1sf_demod_get_tps_code_rate(state, &p->code_rate_LP);\n\tmxl1x1sf_demod_get_tps_modulation(state, &p->modulation);\n\tmxl1x1sf_demod_get_tps_guard_fft_mode(state,\n\t\t\t\t\t      &p->transmission_mode);\n\tmxl1x1sf_demod_get_tps_guard_interval(state,\n\t\t\t\t\t      &p->guard_interval);\n\tmxl1x1sf_demod_get_tps_hierarchy(state,\n\t\t\t\t\t &p->hierarchy);\n\n\treturn 0;\n}\n\nstatic\nint mxl111sf_demod_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t     struct dvb_frontend_tune_settings *tune)\n{\n\ttune->min_delay_ms = 1000;\n\treturn 0;\n}\n\nstatic void mxl111sf_demod_release(struct dvb_frontend *fe)\n{\n\tstruct mxl111sf_demod_state *state = fe->demodulator_priv;\n\tmxl_dbg(\"()\");\n\tkfree(state);\n\tfe->demodulator_priv = NULL;\n}\n\nstatic const struct dvb_frontend_ops mxl111sf_demod_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name               = \"MaxLinear MxL111SF DVB-T demodulator\",\n\t\t.frequency_min_hz      = 177 * MHz,\n\t\t.frequency_max_hz      = 858 * MHz,\n\t\t.frequency_stepsize_hz = 166666,\n\t\t.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |\n\t\t\tFE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_HIERARCHY_AUTO | FE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_RECOVER\n\t},\n\t.release              = mxl111sf_demod_release,\n#if 0\n\t.init                 = mxl111sf_init,\n\t.i2c_gate_ctrl        = mxl111sf_i2c_gate_ctrl,\n#endif\n\t.set_frontend         = mxl111sf_demod_set_frontend,\n\t.get_frontend         = mxl111sf_demod_get_frontend,\n\t.get_tune_settings    = mxl111sf_demod_get_tune_settings,\n\t.read_status          = mxl111sf_demod_read_status,\n\t.read_signal_strength = mxl111sf_demod_read_signal_strength,\n\t.read_ber             = mxl111sf_demod_read_ber,\n\t.read_snr             = mxl111sf_demod_read_snr,\n\t.read_ucblocks        = mxl111sf_demod_read_ucblocks,\n};\n\nstruct dvb_frontend *mxl111sf_demod_attach(struct mxl111sf_state *mxl_state,\n\t\t\t\t   const struct mxl111sf_demod_config *cfg)\n{\n\tstruct mxl111sf_demod_state *state = NULL;\n\n\tmxl_dbg(\"()\");\n\n\tstate = kzalloc(sizeof(struct mxl111sf_demod_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn NULL;\n\n\tstate->mxl_state = mxl_state;\n\tstate->cfg = cfg;\n\n\tmemcpy(&state->fe.ops, &mxl111sf_demod_ops,\n\t       sizeof(struct dvb_frontend_ops));\n\n\tstate->fe.demodulator_priv = state;\n\treturn &state->fe;\n}\nEXPORT_SYMBOL_GPL(mxl111sf_demod_attach);\n\nMODULE_DESCRIPTION(\"MaxLinear MxL111SF DVB-T demodulator driver\");\nMODULE_AUTHOR(\"Michael Krufky <mkrufky@linuxtv.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.1\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}