{
  "module_name": "az6007.c",
  "hash_id": "a978d4666cc4d9246aa28f760ee1f321e5a6c310c0f7a141452787c5b23f659c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/az6007.c",
  "human_readable_source": "\n \n\n#include \"drxk.h\"\n#include \"mt2063.h\"\n#include <media/dvb_ca_en50221.h>\n#include \"dvb_usb.h\"\n#include \"cypress_firmware.h\"\n\n#define AZ6007_FIRMWARE \"dvb-usb-terratec-h7-az6007.fw\"\n\nstatic int az6007_xfer_debug;\nmodule_param_named(xfer_debug, az6007_xfer_debug, int, 0644);\nMODULE_PARM_DESC(xfer_debug, \"Enable xfer debug\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n \n\n#define FX2_OED\t\t\t0xb5\n#define AZ6007_READ_DATA\t0xb7\n#define AZ6007_I2C_RD\t\t0xb9\n#define AZ6007_POWER\t\t0xbc\n#define AZ6007_I2C_WR\t\t0xbd\n#define FX2_SCON1\t\t0xc0\n#define AZ6007_TS_THROUGH\t0xc7\n#define AZ6007_READ_IR\t\t0xb4\n\nstruct az6007_device_state {\n\tstruct mutex\t\tmutex;\n\tstruct mutex\t\tca_mutex;\n\tstruct dvb_ca_en50221\tca;\n\tunsigned\t\twarm:1;\n\tint\t\t\t(*gate_ctrl) (struct dvb_frontend *, int);\n\tunsigned char\t\tdata[4096];\n};\n\nstatic struct drxk_config terratec_h7_drxk = {\n\t.adr = 0x29,\n\t.parallel_ts = true,\n\t.dynamic_clk = true,\n\t.single_master = true,\n\t.enable_merr_cfg = true,\n\t.no_i2c_bridge = false,\n\t.chunk_size = 64,\n\t.mpeg_out_clk_strength = 0x02,\n\t.qam_demod_parameter_count = 2,\n\t.microcode_name = \"dvb-usb-terratec-h7-drxk.fw\",\n};\n\nstatic struct drxk_config cablestar_hdci_drxk = {\n\t.adr = 0x29,\n\t.parallel_ts = true,\n\t.dynamic_clk = true,\n\t.single_master = true,\n\t.enable_merr_cfg = true,\n\t.no_i2c_bridge = false,\n\t.chunk_size = 64,\n\t.mpeg_out_clk_strength = 0x02,\n\t.qam_demod_parameter_count = 2,\n\t.microcode_name = \"dvb-usb-technisat-cablestar-hdci-drxk.fw\",\n};\n\nstatic int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct az6007_device_state *st = fe_to_priv(fe);\n\tstruct dvb_usb_adapter *adap = fe->sec_priv;\n\tint status = 0;\n\n\tpr_debug(\"%s: %s\\n\", __func__, enable ? \"enable\" : \"disable\");\n\n\tif (!adap || !st)\n\t\treturn -EINVAL;\n\n\tif (enable)\n\t\tstatus = st->gate_ctrl(fe, 1);\n\telse\n\t\tstatus = st->gate_ctrl(fe, 0);\n\n\treturn status;\n}\n\nstatic struct mt2063_config az6007_mt2063_config = {\n\t.tuner_address = 0x60,\n\t.refclock = 36125000,\n};\n\nstatic int __az6007_read(struct usb_device *udev, u8 req, u16 value,\n\t\t\t    u16 index, u8 *b, int blen)\n{\n\tint ret;\n\n\tret = usb_control_msg(udev,\n\t\t\t      usb_rcvctrlpipe(udev, 0),\n\t\t\t      req,\n\t\t\t      USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t      value, index, b, blen, 5000);\n\tif (ret < 0) {\n\t\tpr_warn(\"usb read operation failed. (%d)\\n\", ret);\n\t\treturn -EIO;\n\t}\n\n\tif (az6007_xfer_debug) {\n\t\tprintk(KERN_DEBUG \"az6007: IN  req: %02x, value: %04x, index: %04x\\n\",\n\t\t       req, value, index);\n\t\tprint_hex_dump_bytes(\"az6007: payload: \",\n\t\t\t\t     DUMP_PREFIX_NONE, b, blen);\n\t}\n\n\treturn ret;\n}\n\nstatic int az6007_read(struct dvb_usb_device *d, u8 req, u16 value,\n\t\t\t    u16 index, u8 *b, int blen)\n{\n\tstruct az6007_device_state *st = d->priv;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&st->mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tret = __az6007_read(d->udev, req, value, index, b, blen);\n\n\tmutex_unlock(&st->mutex);\n\n\treturn ret;\n}\n\nstatic int __az6007_write(struct usb_device *udev, u8 req, u16 value,\n\t\t\t     u16 index, u8 *b, int blen)\n{\n\tint ret;\n\n\tif (az6007_xfer_debug) {\n\t\tprintk(KERN_DEBUG \"az6007: OUT req: %02x, value: %04x, index: %04x\\n\",\n\t\t       req, value, index);\n\t\tprint_hex_dump_bytes(\"az6007: payload: \",\n\t\t\t\t     DUMP_PREFIX_NONE, b, blen);\n\t}\n\n\tif (blen > 64) {\n\t\tpr_err(\"az6007: tried to write %d bytes, but I2C max size is 64 bytes\\n\",\n\t\t       blen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = usb_control_msg(udev,\n\t\t\t      usb_sndctrlpipe(udev, 0),\n\t\t\t      req,\n\t\t\t      USB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t      value, index, b, blen, 5000);\n\tif (ret != blen) {\n\t\tpr_err(\"usb write operation failed. (%d)\\n\", ret);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int az6007_write(struct dvb_usb_device *d, u8 req, u16 value,\n\t\t\t    u16 index, u8 *b, int blen)\n{\n\tstruct az6007_device_state *st = d->priv;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&st->mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tret = __az6007_write(d->udev, req, value, index, b, blen);\n\n\tmutex_unlock(&st->mutex);\n\n\treturn ret;\n}\n\nstatic int az6007_streaming_ctrl(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dvb_usb_device *d = fe_to_d(fe);\n\n\tpr_debug(\"%s: %s\\n\", __func__, onoff ? \"enable\" : \"disable\");\n\n\treturn az6007_write(d, 0xbc, onoff, 0, NULL, 0);\n}\n\n#if IS_ENABLED(CONFIG_RC_CORE)\n \nstatic int az6007_rc_query(struct dvb_usb_device *d)\n{\n\tstruct az6007_device_state *st = d_to_priv(d);\n\tunsigned code;\n\tenum rc_proto proto;\n\n\tif (az6007_read(d, AZ6007_READ_IR, 0, 0, st->data, 10) < 0)\n\t\treturn -EIO;\n\n\tif (st->data[1] == 0x44)\n\t\treturn 0;\n\n\tif ((st->data[3] ^ st->data[4]) == 0xff) {\n\t\tif ((st->data[1] ^ st->data[2]) == 0xff) {\n\t\t\tcode = RC_SCANCODE_NEC(st->data[1], st->data[3]);\n\t\t\tproto = RC_PROTO_NEC;\n\t\t} else {\n\t\t\tcode = RC_SCANCODE_NECX(st->data[1] << 8 | st->data[2],\n\t\t\t\t\t\tst->data[3]);\n\t\t\tproto = RC_PROTO_NECX;\n\t\t}\n\t} else {\n\t\tcode = RC_SCANCODE_NEC32(st->data[1] << 24 |\n\t\t\t\t\t st->data[2] << 16 |\n\t\t\t\t\t st->data[3] << 8  |\n\t\t\t\t\t st->data[4]);\n\t\tproto = RC_PROTO_NEC32;\n\t}\n\n\trc_keydown(d->rc_dev, proto, code, st->data[5]);\n\n\treturn 0;\n}\n\nstatic int az6007_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)\n{\n\tpr_debug(\"Getting az6007 Remote Control properties\\n\");\n\n\trc->allowed_protos = RC_PROTO_BIT_NEC | RC_PROTO_BIT_NECX |\n\t\t\t\t\t\tRC_PROTO_BIT_NEC32;\n\trc->query          = az6007_rc_query;\n\trc->interval       = 400;\n\n\treturn 0;\n}\n#else\n\t#define az6007_get_rc_config NULL\n#endif\n\nstatic int az6007_ci_read_attribute_mem(struct dvb_ca_en50221 *ca,\n\t\t\t\t\tint slot,\n\t\t\t\t\tint address)\n{\n\tstruct dvb_usb_device *d = ca->data;\n\tstruct az6007_device_state *state = d_to_priv(d);\n\n\tint ret;\n\tu8 req;\n\tu16 value;\n\tu16 index;\n\tint blen;\n\tu8 *b;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\tb = kmalloc(12, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&state->ca_mutex);\n\n\treq = 0xC1;\n\tvalue = address;\n\tindex = 0;\n\tblen = 1;\n\n\tret = az6007_read(d, req, value, index, b, blen);\n\tif (ret < 0) {\n\t\tpr_warn(\"usb in operation failed. (%d)\\n\", ret);\n\t\tret = -EINVAL;\n\t} else {\n\t\tret = b[0];\n\t}\n\n\tmutex_unlock(&state->ca_mutex);\n\tkfree(b);\n\treturn ret;\n}\n\nstatic int az6007_ci_write_attribute_mem(struct dvb_ca_en50221 *ca,\n\t\t\t\t\t int slot,\n\t\t\t\t\t int address,\n\t\t\t\t\t u8 value)\n{\n\tstruct dvb_usb_device *d = ca->data;\n\tstruct az6007_device_state *state = d_to_priv(d);\n\n\tint ret;\n\tu8 req;\n\tu16 value1;\n\tu16 index;\n\tint blen;\n\n\tpr_debug(\"%s(), slot %d\\n\", __func__, slot);\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&state->ca_mutex);\n\treq = 0xC2;\n\tvalue1 = address;\n\tindex = value;\n\tblen = 0;\n\n\tret = az6007_write(d, req, value1, index, NULL, blen);\n\tif (ret != 0)\n\t\tpr_warn(\"usb out operation failed. (%d)\\n\", ret);\n\n\tmutex_unlock(&state->ca_mutex);\n\treturn ret;\n}\n\nstatic int az6007_ci_read_cam_control(struct dvb_ca_en50221 *ca,\n\t\t\t\t      int slot,\n\t\t\t\t      u8 address)\n{\n\tstruct dvb_usb_device *d = ca->data;\n\tstruct az6007_device_state *state = d_to_priv(d);\n\n\tint ret;\n\tu8 req;\n\tu16 value;\n\tu16 index;\n\tint blen;\n\tu8 *b;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\tb = kmalloc(12, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&state->ca_mutex);\n\n\treq = 0xC3;\n\tvalue = address;\n\tindex = 0;\n\tblen = 2;\n\n\tret = az6007_read(d, req, value, index, b, blen);\n\tif (ret < 0) {\n\t\tpr_warn(\"usb in operation failed. (%d)\\n\", ret);\n\t\tret = -EINVAL;\n\t} else {\n\t\tif (b[0] == 0)\n\t\t\tpr_warn(\"Read CI IO error\\n\");\n\n\t\tret = b[1];\n\t\tpr_debug(\"read cam data = %x from 0x%x\\n\", b[1], value);\n\t}\n\n\tmutex_unlock(&state->ca_mutex);\n\tkfree(b);\n\treturn ret;\n}\n\nstatic int az6007_ci_write_cam_control(struct dvb_ca_en50221 *ca,\n\t\t\t\t       int slot,\n\t\t\t\t       u8 address,\n\t\t\t\t       u8 value)\n{\n\tstruct dvb_usb_device *d = ca->data;\n\tstruct az6007_device_state *state = d_to_priv(d);\n\n\tint ret;\n\tu8 req;\n\tu16 value1;\n\tu16 index;\n\tint blen;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&state->ca_mutex);\n\treq = 0xC4;\n\tvalue1 = address;\n\tindex = value;\n\tblen = 0;\n\n\tret = az6007_write(d, req, value1, index, NULL, blen);\n\tif (ret != 0) {\n\t\tpr_warn(\"usb out operation failed. (%d)\\n\", ret);\n\t\tgoto failed;\n\t}\n\nfailed:\n\tmutex_unlock(&state->ca_mutex);\n\treturn ret;\n}\n\nstatic int CI_CamReady(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct dvb_usb_device *d = ca->data;\n\n\tint ret;\n\tu8 req;\n\tu16 value;\n\tu16 index;\n\tint blen;\n\tu8 *b;\n\n\tb = kmalloc(12, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\n\treq = 0xC8;\n\tvalue = 0;\n\tindex = 0;\n\tblen = 1;\n\n\tret = az6007_read(d, req, value, index, b, blen);\n\tif (ret < 0) {\n\t\tpr_warn(\"usb in operation failed. (%d)\\n\", ret);\n\t\tret = -EIO;\n\t} else{\n\t\tret = b[0];\n\t}\n\tkfree(b);\n\treturn ret;\n}\n\nstatic int az6007_ci_slot_reset(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct dvb_usb_device *d = ca->data;\n\tstruct az6007_device_state *state = d_to_priv(d);\n\n\tint ret, i;\n\tu8 req;\n\tu16 value;\n\tu16 index;\n\tint blen;\n\n\tmutex_lock(&state->ca_mutex);\n\n\treq = 0xC6;\n\tvalue = 1;\n\tindex = 0;\n\tblen = 0;\n\n\tret = az6007_write(d, req, value, index, NULL, blen);\n\tif (ret != 0) {\n\t\tpr_warn(\"usb out operation failed. (%d)\\n\", ret);\n\t\tgoto failed;\n\t}\n\n\tmsleep(500);\n\treq = 0xC6;\n\tvalue = 0;\n\tindex = 0;\n\tblen = 0;\n\n\tret = az6007_write(d, req, value, index, NULL, blen);\n\tif (ret != 0) {\n\t\tpr_warn(\"usb out operation failed. (%d)\\n\", ret);\n\t\tgoto failed;\n\t}\n\n\tfor (i = 0; i < 15; i++) {\n\t\tmsleep(100);\n\n\t\tif (CI_CamReady(ca, slot)) {\n\t\t\tpr_debug(\"CAM Ready\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tmsleep(5000);\n\nfailed:\n\tmutex_unlock(&state->ca_mutex);\n\treturn ret;\n}\n\nstatic int az6007_ci_slot_shutdown(struct dvb_ca_en50221 *ca, int slot)\n{\n\treturn 0;\n}\n\nstatic int az6007_ci_slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct dvb_usb_device *d = ca->data;\n\tstruct az6007_device_state *state = d_to_priv(d);\n\n\tint ret;\n\tu8 req;\n\tu16 value;\n\tu16 index;\n\tint blen;\n\n\tpr_debug(\"%s()\\n\", __func__);\n\tmutex_lock(&state->ca_mutex);\n\treq = 0xC7;\n\tvalue = 1;\n\tindex = 0;\n\tblen = 0;\n\n\tret = az6007_write(d, req, value, index, NULL, blen);\n\tif (ret != 0) {\n\t\tpr_warn(\"usb out operation failed. (%d)\\n\", ret);\n\t\tgoto failed;\n\t}\n\nfailed:\n\tmutex_unlock(&state->ca_mutex);\n\treturn ret;\n}\n\nstatic int az6007_ci_poll_slot_status(struct dvb_ca_en50221 *ca, int slot, int open)\n{\n\tstruct dvb_usb_device *d = ca->data;\n\tstruct az6007_device_state *state = d_to_priv(d);\n\tint ret;\n\tu8 req;\n\tu16 value;\n\tu16 index;\n\tint blen;\n\tu8 *b;\n\n\tb = kmalloc(12, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\tmutex_lock(&state->ca_mutex);\n\n\treq = 0xC5;\n\tvalue = 0;\n\tindex = 0;\n\tblen = 1;\n\n\tret = az6007_read(d, req, value, index, b, blen);\n\tif (ret < 0) {\n\t\tpr_warn(\"usb in operation failed. (%d)\\n\", ret);\n\t\tret = -EIO;\n\t} else\n\t\tret = 0;\n\n\tif (!ret && b[0] == 1) {\n\t\tret = DVB_CA_EN50221_POLL_CAM_PRESENT |\n\t\t      DVB_CA_EN50221_POLL_CAM_READY;\n\t}\n\n\tmutex_unlock(&state->ca_mutex);\n\tkfree(b);\n\treturn ret;\n}\n\n\nstatic void az6007_ci_uninit(struct dvb_usb_device *d)\n{\n\tstruct az6007_device_state *state;\n\n\tpr_debug(\"%s()\\n\", __func__);\n\n\tif (NULL == d)\n\t\treturn;\n\n\tstate = d_to_priv(d);\n\tif (NULL == state)\n\t\treturn;\n\n\tif (NULL == state->ca.data)\n\t\treturn;\n\n\tdvb_ca_en50221_release(&state->ca);\n\n\tmemset(&state->ca, 0, sizeof(state->ca));\n}\n\n\nstatic int az6007_ci_init(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct az6007_device_state *state = adap_to_priv(adap);\n\tint ret;\n\n\tpr_debug(\"%s()\\n\", __func__);\n\n\tmutex_init(&state->ca_mutex);\n\tstate->ca.owner\t\t\t= THIS_MODULE;\n\tstate->ca.read_attribute_mem\t= az6007_ci_read_attribute_mem;\n\tstate->ca.write_attribute_mem\t= az6007_ci_write_attribute_mem;\n\tstate->ca.read_cam_control\t= az6007_ci_read_cam_control;\n\tstate->ca.write_cam_control\t= az6007_ci_write_cam_control;\n\tstate->ca.slot_reset\t\t= az6007_ci_slot_reset;\n\tstate->ca.slot_shutdown\t\t= az6007_ci_slot_shutdown;\n\tstate->ca.slot_ts_enable\t= az6007_ci_slot_ts_enable;\n\tstate->ca.poll_slot_status\t= az6007_ci_poll_slot_status;\n\tstate->ca.data\t\t\t= d;\n\n\tret = dvb_ca_en50221_init(&adap->dvb_adap,\n\t\t\t\t  &state->ca,\n\t\t\t\t  0,  \n\t\t\t\t  1); \n\tif (ret != 0) {\n\t\tpr_err(\"Cannot initialize CI: Error %d.\\n\", ret);\n\t\tmemset(&state->ca, 0, sizeof(state->ca));\n\t\treturn ret;\n\t}\n\n\tpr_debug(\"CI initialized.\\n\");\n\n\treturn 0;\n}\n\nstatic int az6007_read_mac_addr(struct dvb_usb_adapter *adap, u8 mac[6])\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct az6007_device_state *st = adap_to_priv(adap);\n\tint ret;\n\n\tret = az6007_read(d, AZ6007_READ_DATA, 6, 0, st->data, 6);\n\tmemcpy(mac, st->data, 6);\n\n\tif (ret > 0)\n\t\tpr_debug(\"%s: mac is %pM\\n\", __func__, mac);\n\n\treturn ret;\n}\n\nstatic int az6007_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct az6007_device_state *st = adap_to_priv(adap);\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\n\tpr_debug(\"attaching demod drxk\\n\");\n\n\tadap->fe[0] = dvb_attach(drxk_attach, &terratec_h7_drxk,\n\t\t\t\t &d->i2c_adap);\n\tif (!adap->fe[0])\n\t\treturn -EINVAL;\n\n\tadap->fe[0]->sec_priv = adap;\n\tst->gate_ctrl = adap->fe[0]->ops.i2c_gate_ctrl;\n\tadap->fe[0]->ops.i2c_gate_ctrl = drxk_gate_ctrl;\n\n\taz6007_ci_init(adap);\n\n\treturn 0;\n}\n\nstatic int az6007_cablestar_hdci_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct az6007_device_state *st = adap_to_priv(adap);\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\n\tpr_debug(\"attaching demod drxk\\n\");\n\n\tadap->fe[0] = dvb_attach(drxk_attach, &cablestar_hdci_drxk,\n\t\t\t\t &d->i2c_adap);\n\tif (!adap->fe[0])\n\t\treturn -EINVAL;\n\n\tadap->fe[0]->sec_priv = adap;\n\tst->gate_ctrl = adap->fe[0]->ops.i2c_gate_ctrl;\n\tadap->fe[0]->ops.i2c_gate_ctrl = drxk_gate_ctrl;\n\n\taz6007_ci_init(adap);\n\n\treturn 0;\n}\n\nstatic int az6007_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\n\tpr_debug(\"attaching tuner mt2063\\n\");\n\n\t \n\tif (adap->fe[0]->ops.i2c_gate_ctrl)\n\t\tadap->fe[0]->ops.i2c_gate_ctrl(adap->fe[0], 1);\n\tif (!dvb_attach(mt2063_attach, adap->fe[0],\n\t\t\t&az6007_mt2063_config,\n\t\t\t&d->i2c_adap))\n\t\treturn -EINVAL;\n\n\tif (adap->fe[0]->ops.i2c_gate_ctrl)\n\t\tadap->fe[0]->ops.i2c_gate_ctrl(adap->fe[0], 0);\n\n\treturn 0;\n}\n\nstatic int az6007_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tstruct az6007_device_state *state = d_to_priv(d);\n\tint ret;\n\n\tpr_debug(\"%s()\\n\", __func__);\n\n\tif (!state->warm) {\n\t\tmutex_init(&state->mutex);\n\n\t\tret = az6007_write(d, AZ6007_POWER, 0, 2, NULL, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tmsleep(60);\n\t\tret = az6007_write(d, AZ6007_POWER, 1, 4, NULL, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tmsleep(100);\n\t\tret = az6007_write(d, AZ6007_POWER, 1, 3, NULL, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tmsleep(20);\n\t\tret = az6007_write(d, AZ6007_POWER, 1, 4, NULL, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmsleep(400);\n\t\tret = az6007_write(d, FX2_SCON1, 0, 3, NULL, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tmsleep(150);\n\t\tret = az6007_write(d, FX2_SCON1, 1, 3, NULL, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tmsleep(430);\n\t\tret = az6007_write(d, AZ6007_POWER, 0, 0, NULL, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tstate->warm = true;\n\n\t\treturn 0;\n\t}\n\n\tif (!onoff)\n\t\treturn 0;\n\n\taz6007_write(d, AZ6007_POWER, 0, 0, NULL, 0);\n\taz6007_write(d, AZ6007_TS_THROUGH, 0, 0, NULL, 0);\n\n\treturn 0;\n}\n\n \nstatic int az6007_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],\n\t\t\t   int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstruct az6007_device_state *st = d_to_priv(d);\n\tint i, j, len;\n\tint ret = 0;\n\tu16 index;\n\tu16 value;\n\tint length;\n\tu8 req, addr;\n\n\tif (mutex_lock_interruptible(&st->mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tfor (i = 0; i < num; i++) {\n\t\taddr = msgs[i].addr << 1;\n\t\tif (((i + 1) < num)\n\t\t    && (msgs[i].len == 1)\n\t\t    && ((msgs[i].flags & I2C_M_RD) != I2C_M_RD)\n\t\t    && (msgs[i + 1].flags & I2C_M_RD)\n\t\t    && (msgs[i].addr == msgs[i + 1].addr)) {\n\t\t\t \n\t\t\tif (az6007_xfer_debug)\n\t\t\t\tprintk(KERN_DEBUG \"az6007: I2C W/R addr=0x%x len=%d/%d\\n\",\n\t\t\t\t       addr, msgs[i].len, msgs[i + 1].len);\n\t\t\treq = AZ6007_I2C_RD;\n\t\t\tindex = msgs[i].buf[0];\n\t\t\tvalue = addr | (1 << 8);\n\t\t\tlength = 6 + msgs[i + 1].len;\n\t\t\tlen = msgs[i + 1].len;\n\t\t\tret = __az6007_read(d->udev, req, value, index,\n\t\t\t\t\t    st->data, length);\n\t\t\tif (ret >= len) {\n\t\t\t\tfor (j = 0; j < len; j++)\n\t\t\t\t\tmsgs[i + 1].buf[j] = st->data[j + 5];\n\t\t\t} else\n\t\t\t\tret = -EIO;\n\t\t\ti++;\n\t\t} else if (!(msgs[i].flags & I2C_M_RD)) {\n\t\t\t \n\t\t\tif (az6007_xfer_debug)\n\t\t\t\tprintk(KERN_DEBUG \"az6007: I2C W addr=0x%x len=%d\\n\",\n\t\t\t\t       addr, msgs[i].len);\n\t\t\tif (msgs[i].len < 1) {\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\treq = AZ6007_I2C_WR;\n\t\t\tindex = msgs[i].buf[0];\n\t\t\tvalue = addr | (1 << 8);\n\t\t\tlength = msgs[i].len - 1;\n\t\t\tlen = msgs[i].len - 1;\n\t\t\tfor (j = 0; j < len; j++)\n\t\t\t\tst->data[j] = msgs[i].buf[j + 1];\n\t\t\tret =  __az6007_write(d->udev, req, value, index,\n\t\t\t\t\t      st->data, length);\n\t\t} else {\n\t\t\t \n\t\t\tif (az6007_xfer_debug)\n\t\t\t\tprintk(KERN_DEBUG \"az6007: I2C R addr=0x%x len=%d\\n\",\n\t\t\t\t       addr, msgs[i].len);\n\t\t\tif (msgs[i].len < 1) {\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\treq = AZ6007_I2C_RD;\n\t\t\tindex = msgs[i].buf[0];\n\t\t\tvalue = addr;\n\t\t\tlength = msgs[i].len + 6;\n\t\t\tlen = msgs[i].len;\n\t\t\tret = __az6007_read(d->udev, req, value, index,\n\t\t\t\t\t    st->data, length);\n\t\t\tfor (j = 0; j < len; j++)\n\t\t\t\tmsgs[i].buf[j] = st->data[j + 5];\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\nerr:\n\tmutex_unlock(&st->mutex);\n\n\tif (ret < 0) {\n\t\tpr_info(\"%s ERROR: %i\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\treturn num;\n}\n\nstatic u32 az6007_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm az6007_i2c_algo = {\n\t.master_xfer = az6007_i2c_xfer,\n\t.functionality = az6007_i2c_func,\n};\n\nstatic int az6007_identify_state(struct dvb_usb_device *d, const char **name)\n{\n\tint ret;\n\tu8 *mac;\n\n\tpr_debug(\"Identifying az6007 state\\n\");\n\n\tmac = kmalloc(6, GFP_ATOMIC);\n\tif (!mac)\n\t\treturn -ENOMEM;\n\n\t \n\tret = __az6007_read(d->udev, AZ6007_READ_DATA, 6, 0, mac, 6);\n\tif (ret == 6)\n\t\tret = WARM;\n\telse\n\t\tret = COLD;\n\n\tkfree(mac);\n\n\tif (ret == COLD) {\n\t\t__az6007_write(d->udev, 0x09, 1, 0, NULL, 0);\n\t\t__az6007_write(d->udev, 0x00, 0, 0, NULL, 0);\n\t\t__az6007_write(d->udev, 0x00, 0, 0, NULL, 0);\n\t}\n\n\tpr_debug(\"Device is on %s state\\n\",\n\t\t ret == WARM ? \"warm\" : \"cold\");\n\treturn ret;\n}\n\nstatic void az6007_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\taz6007_ci_uninit(d);\n\tdvb_usbv2_disconnect(intf);\n}\n\nstatic int az6007_download_firmware(struct dvb_usb_device *d,\n\tconst struct firmware *fw)\n{\n\tpr_debug(\"Loading az6007 firmware\\n\");\n\n\treturn cypress_load_firmware(d->udev, fw, CYPRESS_FX2);\n}\n\n \nstatic struct dvb_usb_device_properties az6007_props = {\n\t.driver_name         = KBUILD_MODNAME,\n\t.owner               = THIS_MODULE,\n\t.firmware            = AZ6007_FIRMWARE,\n\n\t.adapter_nr          = adapter_nr,\n\t.size_of_priv        = sizeof(struct az6007_device_state),\n\t.i2c_algo            = &az6007_i2c_algo,\n\t.tuner_attach        = az6007_tuner_attach,\n\t.frontend_attach     = az6007_frontend_attach,\n\t.streaming_ctrl      = az6007_streaming_ctrl,\n\t.get_rc_config       = az6007_get_rc_config,\n\t.read_mac_address    = az6007_read_mac_addr,\n\t.download_firmware   = az6007_download_firmware,\n\t.identify_state\t     = az6007_identify_state,\n\t.power_ctrl          = az6007_power_ctrl,\n\t.num_adapters        = 1,\n\t.adapter             = {\n\t\t{ .stream = DVB_USB_STREAM_BULK(0x02, 10, 4096), }\n\t}\n};\n\nstatic struct dvb_usb_device_properties az6007_cablestar_hdci_props = {\n\t.driver_name         = KBUILD_MODNAME,\n\t.owner               = THIS_MODULE,\n\t.firmware            = AZ6007_FIRMWARE,\n\n\t.adapter_nr          = adapter_nr,\n\t.size_of_priv        = sizeof(struct az6007_device_state),\n\t.i2c_algo            = &az6007_i2c_algo,\n\t.tuner_attach        = az6007_tuner_attach,\n\t.frontend_attach     = az6007_cablestar_hdci_frontend_attach,\n\t.streaming_ctrl      = az6007_streaming_ctrl,\n \n\t.get_rc_config       = NULL,\n\t.read_mac_address    = az6007_read_mac_addr,\n\t.download_firmware   = az6007_download_firmware,\n\t.identify_state\t     = az6007_identify_state,\n\t.power_ctrl          = az6007_power_ctrl,\n\t.num_adapters        = 1,\n\t.adapter             = {\n\t\t{ .stream = DVB_USB_STREAM_BULK(0x02, 10, 4096), }\n\t}\n};\n\nstatic const struct usb_device_id az6007_usb_table[] = {\n\t{DVB_USB_DEVICE(USB_VID_AZUREWAVE, USB_PID_AZUREWAVE_6007,\n\t\t&az6007_props, \"Azurewave 6007\", RC_MAP_EMPTY)},\n\t{DVB_USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_H7,\n\t\t&az6007_props, \"Terratec H7\", RC_MAP_NEC_TERRATEC_CINERGY_XS)},\n\t{DVB_USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_H7_2,\n\t\t&az6007_props, \"Terratec H7\", RC_MAP_NEC_TERRATEC_CINERGY_XS)},\n\t{DVB_USB_DEVICE(USB_VID_TECHNISAT, USB_PID_TECHNISAT_USB2_CABLESTAR_HDCI,\n\t\t&az6007_cablestar_hdci_props, \"Technisat CableStar Combo HD CI\", RC_MAP_EMPTY)},\n\t{0},\n};\n\nMODULE_DEVICE_TABLE(usb, az6007_usb_table);\n\nstatic int az6007_suspend(struct usb_interface *intf, pm_message_t msg)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\n\taz6007_ci_uninit(d);\n\treturn dvb_usbv2_suspend(intf, msg);\n}\n\nstatic int az6007_resume(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tstruct dvb_usb_adapter *adap = &d->adapter[0];\n\n\taz6007_ci_init(adap);\n\treturn dvb_usbv2_resume(intf);\n}\n\n \nstatic struct usb_driver az6007_usb_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= az6007_usb_table,\n\t.probe\t\t= dvb_usbv2_probe,\n\t.disconnect\t= az6007_usb_disconnect,\n\t.no_dynamic_id\t= 1,\n\t.soft_unbind\t= 1,\n\t \n\t.suspend\t= az6007_suspend,\n\t.resume\t\t= az6007_resume,\n};\n\nmodule_usb_driver(az6007_usb_driver);\n\nMODULE_AUTHOR(\"Henry Wang <Henry.wang@AzureWave.com>\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab\");\nMODULE_DESCRIPTION(\"Driver for AzureWave 6007 DVB-C/T USB2.0 and clones\");\nMODULE_VERSION(\"2.0\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(AZ6007_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}