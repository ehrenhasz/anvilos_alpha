{
  "module_name": "lmedm04.c",
  "hash_id": "5baf42aea88a77298edc37f15bcdf07eaa41c0465d1cab74ec9a1a0cd4cafc4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/lmedm04.c",
  "human_readable_source": "\n \n#define DVB_USB_LOG_PREFIX \"LME2510(C)\"\n#include <linux/usb.h>\n#include <linux/usb/input.h>\n#include <media/rc-core.h>\n\n#include \"dvb_usb.h\"\n#include \"lmedm04.h\"\n#include \"tda826x.h\"\n#include \"tda10086.h\"\n#include \"stv0288.h\"\n#include \"ix2505v.h\"\n#include \"stv0299.h\"\n#include \"dvb-pll.h\"\n#include \"z0194a.h\"\n#include \"m88rs2000.h\"\n#include \"ts2020.h\"\n\n\n#define LME2510_C_S7395\t\"dvb-usb-lme2510c-s7395.fw\";\n#define LME2510_C_LG\t\"dvb-usb-lme2510c-lg.fw\";\n#define LME2510_C_S0194\t\"dvb-usb-lme2510c-s0194.fw\";\n#define LME2510_C_RS2000 \"dvb-usb-lme2510c-rs2000.fw\";\n#define LME2510_LG\t\"dvb-usb-lme2510-lg.fw\";\n#define LME2510_S0194\t\"dvb-usb-lme2510-s0194.fw\";\n\n \nstatic int dvb_usb_lme2510_debug;\n#define lme_debug(var, level, args...) do { \\\n\tif ((var >= level)) \\\n\t\tpr_debug(DVB_USB_LOG_PREFIX\": \" args); \\\n} while (0)\n#define deb_info(level, args...) lme_debug(dvb_usb_lme2510_debug, level, args)\n#define debug_data_snipet(level, name, p) \\\n\t deb_info(level, name\" (%8phN)\", p);\n#define info(args...) pr_info(DVB_USB_LOG_PREFIX\": \"args)\n\nmodule_param_named(debug, dvb_usb_lme2510_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=info (or-able)).\");\n\nstatic int dvb_usb_lme2510_firmware;\nmodule_param_named(firmware, dvb_usb_lme2510_firmware, int, 0644);\nMODULE_PARM_DESC(firmware, \"set default firmware 0=Sharp7395 1=LG\");\n\nstatic int pid_filter;\nmodule_param_named(pid, pid_filter, int, 0644);\nMODULE_PARM_DESC(pid, \"set default 0=default 1=off 2=on\");\n\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n#define TUNER_DEFAULT\t0x0\n#define TUNER_LG\t0x1\n#define TUNER_S7395\t0x2\n#define TUNER_S0194\t0x3\n#define TUNER_RS2000\t0x4\n\nstruct lme2510_state {\n\tunsigned long int_urb_due;\n\tenum fe_status lock_status;\n\tu8 id;\n\tu8 tuner_config;\n\tu8 signal_level;\n\tu8 signal_sn;\n\tu8 time_key;\n\tu8 i2c_talk_onoff;\n\tu8 i2c_gate;\n\tu8 i2c_tuner_gate_w;\n\tu8 i2c_tuner_gate_r;\n\tu8 i2c_tuner_addr;\n\tu8 stream_on;\n\tu8 pid_size;\n\tu8 pid_off;\n\tu8 int_buffer[128];\n\tstruct urb *lme_urb;\n\tu8 usb_buffer[64];\n\t \n\tint (*fe_read_status)(struct dvb_frontend *, enum fe_status *);\n\tint (*fe_read_signal_strength)(struct dvb_frontend *, u16 *);\n\tint (*fe_read_snr)(struct dvb_frontend *, u16 *);\n\tint (*fe_read_ber)(struct dvb_frontend *, u32 *);\n\tint (*fe_read_ucblocks)(struct dvb_frontend *, u32 *);\n\tint (*fe_set_voltage)(struct dvb_frontend *, enum fe_sec_voltage);\n\tu8 dvb_usb_lme2510_firmware;\n};\n\nstatic int lme2510_usb_talk(struct dvb_usb_device *d,\n\t\t\t    u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct lme2510_state *st = d->priv;\n\tint ret = 0;\n\n\tif (max(wlen, rlen) > sizeof(st->usb_buffer))\n\t\treturn -EINVAL;\n\n\tret = mutex_lock_interruptible(&d->usb_mutex);\n\tif (ret < 0)\n\t\treturn -EAGAIN;\n\n\tmemcpy(st->usb_buffer, wbuf, wlen);\n\n\tret = dvb_usbv2_generic_rw_locked(d, st->usb_buffer, wlen,\n\t\t\t\t\t  st->usb_buffer, rlen);\n\n\tif (rlen)\n\t\tmemcpy(rbuf, st->usb_buffer, rlen);\n\n\tmutex_unlock(&d->usb_mutex);\n\n\treturn ret;\n}\n\nstatic int lme2510_stream_restart(struct dvb_usb_device *d)\n{\n\tstruct lme2510_state *st = d->priv;\n\tu8 all_pids[] = LME_ALL_PIDS;\n\tu8 stream_on[] = LME_ST_ON_W;\n\tu8 rbuff[1];\n\tif (st->pid_off)\n\t\tlme2510_usb_talk(d, all_pids, sizeof(all_pids),\n\t\t\t\t rbuff, sizeof(rbuff));\n\t \n\treturn lme2510_usb_talk(d, stream_on, sizeof(stream_on),\n\t\t\t\trbuff, sizeof(rbuff));\n}\n\nstatic int lme2510_enable_pid(struct dvb_usb_device *d, u8 index, u16 pid_out)\n{\n\tstruct lme2510_state *st = d->priv;\n\tstatic u8 pid_buff[] = LME_ZERO_PID;\n\tstatic u8 rbuf[1];\n\tu8 pid_no = index * 2;\n\tu8 pid_len = pid_no + 2;\n\tint ret = 0;\n\tdeb_info(1, \"PID Setting Pid %04x\", pid_out);\n\n\tif (st->pid_size == 0)\n\t\tret |= lme2510_stream_restart(d);\n\n\tpid_buff[2] = pid_no;\n\tpid_buff[3] = (u8)pid_out & 0xff;\n\tpid_buff[4] = pid_no + 1;\n\tpid_buff[5] = (u8)(pid_out >> 8);\n\n\tif (pid_len > st->pid_size)\n\t\tst->pid_size = pid_len;\n\tpid_buff[7] = 0x80 + st->pid_size;\n\n\tret |= lme2510_usb_talk(d, pid_buff ,\n\t\tsizeof(pid_buff) , rbuf, sizeof(rbuf));\n\n\tif (st->stream_on)\n\t\tret |= lme2510_stream_restart(d);\n\n\treturn ret;\n}\n\n \n#define reg_to_16bits(x)\t((x) | ((x) << 8))\n\nstatic void lme2510_update_stats(struct dvb_usb_adapter *adap)\n{\n\tstruct lme2510_state *st = adap_to_priv(adap);\n\tstruct dvb_frontend *fe = adap->fe[0];\n\tstruct dtv_frontend_properties *c;\n\tu32 s_tmp = 0, c_tmp = 0;\n\n\tif (!fe)\n\t\treturn;\n\n\tc = &fe->dtv_property_cache;\n\n\tc->block_count.len = 1;\n\tc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->block_error.len = 1;\n\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_count.len = 1;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_error.len = 1;\n\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\tif (st->i2c_talk_onoff) {\n\t\tc->strength.len = 1;\n\t\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->cnr.len = 1;\n\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\treturn;\n\t}\n\n\tswitch (st->tuner_config) {\n\tcase TUNER_LG:\n\t\ts_tmp = reg_to_16bits(0xff - st->signal_level);\n\t\tc_tmp = reg_to_16bits(0xff - st->signal_sn);\n\t\tbreak;\n\tcase TUNER_S7395:\n\tcase TUNER_S0194:\n\t\ts_tmp = 0xffff - (((st->signal_level * 2) << 8) * 5 / 4);\n\t\tc_tmp = reg_to_16bits((0xff - st->signal_sn - 0xa1) * 3);\n\t\tbreak;\n\tcase TUNER_RS2000:\n\t\ts_tmp = reg_to_16bits(st->signal_level);\n\t\tc_tmp = reg_to_16bits(st->signal_sn);\n\t}\n\n\tc->strength.len = 1;\n\tc->strength.stat[0].scale = FE_SCALE_RELATIVE;\n\tc->strength.stat[0].uvalue = (u64)s_tmp;\n\n\tc->cnr.len = 1;\n\tc->cnr.stat[0].scale = FE_SCALE_RELATIVE;\n\tc->cnr.stat[0].uvalue = (u64)c_tmp;\n}\n\nstatic void lme2510_int_response(struct urb *lme_urb)\n{\n\tstruct dvb_usb_adapter *adap = lme_urb->context;\n\tstruct lme2510_state *st = adap_to_priv(adap);\n\tu8 *ibuf, *rbuf;\n\tint i = 0, offset;\n\tu32 key;\n\tu8 signal_lock = 0;\n\n\tswitch (lme_urb->status) {\n\tcase 0:\n\tcase -ETIMEDOUT:\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:\n\t\tinfo(\"Error %x\", lme_urb->status);\n\t\tbreak;\n\t}\n\n\trbuf = (u8 *) lme_urb->transfer_buffer;\n\n\toffset = ((lme_urb->actual_length/8) > 4)\n\t\t\t? 4 : (lme_urb->actual_length/8) ;\n\n\tfor (i = 0; i < offset; ++i) {\n\t\tibuf = (u8 *)&rbuf[i*8];\n\t\tdeb_info(5, \"INT O/S C =%02x C/O=%02x Type =%02x%02x\",\n\t\toffset, i, ibuf[0], ibuf[1]);\n\n\t\tswitch (ibuf[0]) {\n\t\tcase 0xaa:\n\t\t\tdebug_data_snipet(1, \"INT Remote data snippet\", ibuf);\n\t\t\tif (!adap_to_d(adap)->rc_dev)\n\t\t\t\tbreak;\n\n\t\t\tkey = RC_SCANCODE_NEC32(ibuf[2] << 24 |\n\t\t\t\t\t\tibuf[3] << 16 |\n\t\t\t\t\t\tibuf[4] << 8  |\n\t\t\t\t\t\tibuf[5]);\n\n\t\t\tdeb_info(1, \"INT Key = 0x%08x\", key);\n\t\t\trc_keydown(adap_to_d(adap)->rc_dev, RC_PROTO_NEC32, key,\n\t\t\t\t   0);\n\t\t\tbreak;\n\t\tcase 0xbb:\n\t\t\tswitch (st->tuner_config) {\n\t\t\tcase TUNER_LG:\n\t\t\t\tsignal_lock = ibuf[2] & BIT(5);\n\t\t\t\tst->signal_level = ibuf[4];\n\t\t\t\tst->signal_sn = ibuf[3];\n\t\t\t\tst->time_key = ibuf[7];\n\t\t\t\tbreak;\n\t\t\tcase TUNER_S7395:\n\t\t\tcase TUNER_S0194:\n\t\t\t\t \n\t\t\t\tif (ibuf[1] == 0x03) {\n\t\t\t\t\tsignal_lock = ibuf[2] & BIT(4);\n\t\t\t\t\tst->signal_level = ibuf[3];\n\t\t\t\t\tst->signal_sn = ibuf[4];\n\t\t\t\t} else {\n\t\t\t\t\tst->signal_level = ibuf[4];\n\t\t\t\t\tst->signal_sn = ibuf[5];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TUNER_RS2000:\n\t\t\t\tsignal_lock = ibuf[2] & 0xee;\n\t\t\t\tst->signal_level = ibuf[5];\n\t\t\t\tst->signal_sn = ibuf[4];\n\t\t\t\tst->time_key = ibuf[7];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tsignal_lock |= ibuf[2] & BIT(0);\n\n\t\t\tif (!signal_lock)\n\t\t\t\tst->lock_status &= ~FE_HAS_LOCK;\n\n\t\t\tlme2510_update_stats(adap);\n\n\t\t\tdebug_data_snipet(5, \"INT Remote data snippet in\", ibuf);\n\t\tbreak;\n\t\tcase 0xcc:\n\t\t\tdebug_data_snipet(1, \"INT Control data snippet\", ibuf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdebug_data_snipet(1, \"INT Unknown data snippet\", ibuf);\n\t\tbreak;\n\t\t}\n\t}\n\n\tusb_submit_urb(lme_urb, GFP_ATOMIC);\n\n\t \n\tst->int_urb_due = jiffies + msecs_to_jiffies(200);\n}\n\nstatic int lme2510_int_read(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct lme2510_state *lme_int = adap_to_priv(adap);\n\tstruct usb_host_endpoint *ep;\n\n\tlme_int->lme_urb = usb_alloc_urb(0, GFP_KERNEL);\n\n\tif (lme_int->lme_urb == NULL)\n\t\t\treturn -ENOMEM;\n\n\tusb_fill_int_urb(lme_int->lme_urb,\n\t\t\t d->udev,\n\t\t\t usb_rcvintpipe(d->udev, 0xa),\n\t\t\t lme_int->int_buffer,\n\t\t\t sizeof(lme_int->int_buffer),\n\t\t\t lme2510_int_response,\n\t\t\t adap,\n\t\t\t 8);\n\n\t \n\tep = usb_pipe_endpoint(d->udev, lme_int->lme_urb->pipe);\n\n\tif (usb_endpoint_type(&ep->desc) == USB_ENDPOINT_XFER_BULK)\n\t\tlme_int->lme_urb->pipe = usb_rcvbulkpipe(d->udev, 0xa);\n\n\tusb_submit_urb(lme_int->lme_urb, GFP_KERNEL);\n\tinfo(\"INT Interrupt Service Started\");\n\n\treturn 0;\n}\n\nstatic int lme2510_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct lme2510_state *st = adap_to_priv(adap);\n\tstatic u8 clear_pid_reg[] = LME_ALL_PIDS;\n\tstatic u8 rbuf[1];\n\tint ret = 0;\n\n\tdeb_info(1, \"PID Clearing Filter\");\n\n\tmutex_lock(&d->i2c_mutex);\n\n\tif (!onoff) {\n\t\tret |= lme2510_usb_talk(d, clear_pid_reg,\n\t\t\tsizeof(clear_pid_reg), rbuf, sizeof(rbuf));\n\t\tst->pid_off = true;\n\t} else\n\t\tst->pid_off = false;\n\n\tst->pid_size = 0;\n\n\tmutex_unlock(&d->i2c_mutex);\n\n\tif (ret)\n\t\treturn -EREMOTEIO;\n\n\treturn 0;\n}\n\nstatic int lme2510_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid,\n\tint onoff)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tint ret = 0;\n\n\tdeb_info(3, \"%s PID=%04x Index=%04x onoff=%02x\", __func__,\n\t\tpid, index, onoff);\n\n\tif (onoff) {\n\t\tmutex_lock(&d->i2c_mutex);\n\t\tret |= lme2510_enable_pid(d, index, pid);\n\t\tmutex_unlock(&d->i2c_mutex);\n\t}\n\n\n\treturn ret;\n}\n\n\nstatic int lme2510_return_status(struct dvb_usb_device *d)\n{\n\tint ret;\n\tu8 *data;\n\n\tdata = kzalloc(6, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(d->udev, usb_rcvctrlpipe(d->udev, 0),\n\t\t\t      0x06, 0x80, 0x0302, 0x00,\n\t\t\t      data, 0x6, 200);\n\tif (ret != 6)\n\t\tret = -EINVAL;\n\telse\n\t\tret = data[2];\n\n\tinfo(\"Firmware Status: %6ph\", data);\n\n\tkfree(data);\n\treturn ret;\n}\n\nstatic int lme2510_msg(struct dvb_usb_device *d,\n\t\tu8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct lme2510_state *st = d->priv;\n\n\tst->i2c_talk_onoff = 1;\n\n\treturn lme2510_usb_talk(d, wbuf, wlen, rbuf, rlen);\n}\n\nstatic int lme2510_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t\t int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstruct lme2510_state *st = d->priv;\n\tstatic u8 obuf[64], ibuf[64];\n\tint i, read, read_o;\n\tu16 len;\n\tu8 gate;\n\n\tmutex_lock(&d->i2c_mutex);\n\n\tfor (i = 0; i < num; i++) {\n\t\tread_o = msg[i].flags & I2C_M_RD;\n\t\tread = i + 1 < num && msg[i + 1].flags & I2C_M_RD;\n\t\tread |= read_o;\n\t\tgate = (msg[i].addr == st->i2c_tuner_addr)\n\t\t\t? (read)\t? st->i2c_tuner_gate_r\n\t\t\t\t\t: st->i2c_tuner_gate_w\n\t\t\t: st->i2c_gate;\n\t\tobuf[0] = gate | (read << 7);\n\n\t\tif (gate == 5)\n\t\t\tobuf[1] = (read) ? 2 : msg[i].len + 1;\n\t\telse\n\t\t\tobuf[1] = msg[i].len + read + 1;\n\n\t\tobuf[2] = msg[i].addr << 1;\n\n\t\tif (read) {\n\t\t\tif (read_o)\n\t\t\t\tlen = 3;\n\t\t\telse {\n\t\t\t\tmemcpy(&obuf[3], msg[i].buf, msg[i].len);\n\t\t\t\tobuf[msg[i].len+3] = msg[i+1].len;\n\t\t\t\tlen = msg[i].len+4;\n\t\t\t}\n\t\t} else {\n\t\t\tmemcpy(&obuf[3], msg[i].buf, msg[i].len);\n\t\t\tlen = msg[i].len+3;\n\t\t}\n\n\t\tif (lme2510_msg(d, obuf, len, ibuf, 64) < 0) {\n\t\t\tdeb_info(1, \"i2c transfer failed.\");\n\t\t\tmutex_unlock(&d->i2c_mutex);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tif (read) {\n\t\t\tif (read_o)\n\t\t\t\tmemcpy(msg[i].buf, &ibuf[1], msg[i].len);\n\t\t\telse {\n\t\t\t\tmemcpy(msg[i+1].buf, &ibuf[1], msg[i+1].len);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&d->i2c_mutex);\n\treturn i;\n}\n\nstatic u32 lme2510_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm lme2510_i2c_algo = {\n\t.master_xfer   = lme2510_i2c_xfer,\n\t.functionality = lme2510_i2c_func,\n};\n\nstatic int lme2510_streaming_ctrl(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dvb_usb_adapter *adap = fe_to_adap(fe);\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct lme2510_state *st = adap_to_priv(adap);\n\tstatic u8 clear_reg_3[] = LME_ALL_PIDS;\n\tstatic u8 rbuf[1];\n\tint ret = 0, rlen = sizeof(rbuf);\n\n\tdeb_info(1, \"STM  (%02x)\", onoff);\n\n\t \n\tif (onoff == 1)\n\t\tst->stream_on = 1;\n\telse {\n\t\tdeb_info(1, \"STM Steam Off\");\n\t\t \n\t\tmutex_lock(&d->i2c_mutex);\n\n\t\tret = lme2510_usb_talk(d, clear_reg_3,\n\t\t\t\tsizeof(clear_reg_3), rbuf, rlen);\n\t\tst->stream_on = 0;\n\t\tst->i2c_talk_onoff = 1;\n\n\t\tmutex_unlock(&d->i2c_mutex);\n\t}\n\n\treturn (ret < 0) ? -ENODEV : 0;\n}\n\nstatic u8 check_sum(u8 *p, u8 len)\n{\n\tu8 sum = 0;\n\twhile (len--)\n\t\tsum += *p++;\n\treturn sum;\n}\n\nstatic int lme2510_download_firmware(struct dvb_usb_device *d,\n\t\t\t\t\tconst struct firmware *fw)\n{\n\tint ret = 0;\n\tu8 *data;\n\tu16 j, wlen, len_in, start, end;\n\tu8 packet_size, dlen, i;\n\tu8 *fw_data;\n\n\tpacket_size = 0x31;\n\tlen_in = 1;\n\n\tdata = kzalloc(128, GFP_KERNEL);\n\tif (!data) {\n\t\tinfo(\"FRM Could not start Firmware Download\"\\\n\t\t\t\"(Buffer allocation failed)\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinfo(\"FRM Starting Firmware Download\");\n\n\tfor (i = 1; i < 3; i++) {\n\t\tstart = (i == 1) ? 0 : 512;\n\t\tend = (i == 1) ? 512 : fw->size;\n\t\tfor (j = start; j < end; j += (packet_size+1)) {\n\t\t\tfw_data = (u8 *)(fw->data + j);\n\t\t\tif ((end - j) > packet_size) {\n\t\t\t\tdata[0] = i;\n\t\t\t\tdlen = packet_size;\n\t\t\t} else {\n\t\t\t\tdata[0] = i | 0x80;\n\t\t\t\tdlen = (u8)(end - j)-1;\n\t\t\t}\n\t\t\tdata[1] = dlen;\n\t\t\tmemcpy(&data[2], fw_data, dlen+1);\n\t\t\twlen = (u8) dlen + 4;\n\t\t\tdata[wlen-1] = check_sum(fw_data, dlen+1);\n\t\t\tdeb_info(1, \"Data S=%02x:E=%02x CS= %02x\", data[3],\n\t\t\t\tdata[dlen+2], data[dlen+3]);\n\t\t\tlme2510_usb_talk(d, data, wlen, data, len_in);\n\t\t\tret |= (data[0] == 0x88) ? 0 : -1;\n\t\t}\n\t}\n\n\tdata[0] = 0x8a;\n\tlen_in = 1;\n\tmsleep(2000);\n\tlme2510_usb_talk(d, data, len_in, data, len_in);\n\tmsleep(400);\n\n\tif (ret < 0)\n\t\tinfo(\"FRM Firmware Download Failed (%04x)\" , ret);\n\telse\n\t\tinfo(\"FRM Firmware Download Completed - Resetting Device\");\n\n\tkfree(data);\n\treturn RECONNECTS_USB;\n}\n\nstatic void lme_coldreset(struct dvb_usb_device *d)\n{\n\tu8 data[1] = {0};\n\tdata[0] = 0x0a;\n\tinfo(\"FRM Firmware Cold Reset\");\n\n\tlme2510_usb_talk(d, data, sizeof(data), data, sizeof(data));\n\n\treturn;\n}\n\nstatic const char fw_c_s7395[] = LME2510_C_S7395;\nstatic const char fw_c_lg[] = LME2510_C_LG;\nstatic const char fw_c_s0194[] = LME2510_C_S0194;\nstatic const char fw_c_rs2000[] = LME2510_C_RS2000;\nstatic const char fw_lg[] = LME2510_LG;\nstatic const char fw_s0194[] = LME2510_S0194;\n\nstatic const char *lme_firmware_switch(struct dvb_usb_device *d, int cold)\n{\n\tstruct lme2510_state *st = d->priv;\n\tstruct usb_device *udev = d->udev;\n\tconst struct firmware *fw = NULL;\n\tconst char *fw_lme;\n\tint ret = 0;\n\n\tcold = (cold > 0) ? (cold & 1) : 0;\n\n\tswitch (le16_to_cpu(udev->descriptor.idProduct)) {\n\tcase 0x1122:\n\t\tswitch (st->dvb_usb_lme2510_firmware) {\n\t\tdefault:\n\t\tcase TUNER_S0194:\n\t\t\tfw_lme = fw_s0194;\n\t\t\tret = request_firmware(&fw, fw_lme, &udev->dev);\n\t\t\tif (ret == 0) {\n\t\t\t\tst->dvb_usb_lme2510_firmware = TUNER_S0194;\n\t\t\t\tcold = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase TUNER_LG:\n\t\t\tfw_lme = fw_lg;\n\t\t\tret = request_firmware(&fw, fw_lme, &udev->dev);\n\t\t\tif (ret == 0) {\n\t\t\t\tst->dvb_usb_lme2510_firmware = TUNER_LG;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tst->dvb_usb_lme2510_firmware = TUNER_DEFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 0x1120:\n\t\tswitch (st->dvb_usb_lme2510_firmware) {\n\t\tdefault:\n\t\tcase TUNER_S7395:\n\t\t\tfw_lme = fw_c_s7395;\n\t\t\tret = request_firmware(&fw, fw_lme, &udev->dev);\n\t\t\tif (ret == 0) {\n\t\t\t\tst->dvb_usb_lme2510_firmware = TUNER_S7395;\n\t\t\t\tcold = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase TUNER_LG:\n\t\t\tfw_lme = fw_c_lg;\n\t\t\tret = request_firmware(&fw, fw_lme, &udev->dev);\n\t\t\tif (ret == 0) {\n\t\t\t\tst->dvb_usb_lme2510_firmware = TUNER_LG;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase TUNER_S0194:\n\t\t\tfw_lme = fw_c_s0194;\n\t\t\tret = request_firmware(&fw, fw_lme, &udev->dev);\n\t\t\tif (ret == 0) {\n\t\t\t\tst->dvb_usb_lme2510_firmware = TUNER_S0194;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tst->dvb_usb_lme2510_firmware = TUNER_DEFAULT;\n\t\t\tcold = 0;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 0x22f0:\n\t\tfw_lme = fw_c_rs2000;\n\t\tst->dvb_usb_lme2510_firmware = TUNER_RS2000;\n\t\tbreak;\n\tdefault:\n\t\tfw_lme = fw_c_s7395;\n\t}\n\n\trelease_firmware(fw);\n\n\tif (cold) {\n\t\tdvb_usb_lme2510_firmware = st->dvb_usb_lme2510_firmware;\n\t\tinfo(\"FRM Changing to %s firmware\", fw_lme);\n\t\tlme_coldreset(d);\n\t\treturn NULL;\n\t}\n\n\treturn fw_lme;\n}\n\nstatic struct tda10086_config tda10086_config = {\n\t.demod_address = 0x0e,\n\t.invert = 0,\n\t.diseqc_tone = 1,\n\t.xtal_freq = TDA10086_XTAL_16M,\n};\n\nstatic struct stv0288_config lme_config = {\n\t.demod_address = 0x68,\n\t.min_delay_ms = 15,\n\t.inittab = s7395_inittab,\n};\n\nstatic struct ix2505v_config lme_tuner = {\n\t.tuner_address = 0x60,\n\t.min_delay_ms = 100,\n\t.tuner_gain = 0x0,\n\t.tuner_chargepump = 0x3,\n};\n\nstatic struct stv0299_config sharp_z0194_config = {\n\t.demod_address = 0x68,\n\t.inittab = sharp_z0194a_inittab,\n\t.mclk = 88000000UL,\n\t.invert = 0,\n\t.skip_reinit = 0,\n\t.lock_output = STV0299_LOCKOUTPUT_1,\n\t.volt13_op0_op1 = STV0299_VOLT13_OP1,\n\t.min_delay_ms = 100,\n\t.set_symbol_rate = sharp_z0194a_set_symbol_rate,\n};\n\nstatic struct m88rs2000_config m88rs2000_config = {\n\t.demod_addr = 0x68\n};\n\nstatic struct ts2020_config ts2020_config = {\n\t.tuner_address = 0x60,\n\t.clk_out_div = 7,\n\t.dont_poll = true\n};\n\nstatic int dm04_lme2510_set_voltage(struct dvb_frontend *fe,\n\t\t\t\t    enum fe_sec_voltage voltage)\n{\n\tstruct dvb_usb_device *d = fe_to_d(fe);\n\tstruct lme2510_state *st = fe_to_priv(fe);\n\tstatic u8 voltage_low[] = LME_VOLTAGE_L;\n\tstatic u8 voltage_high[] = LME_VOLTAGE_H;\n\tstatic u8 rbuf[1];\n\tint ret = 0, len = 3, rlen = 1;\n\n\tmutex_lock(&d->i2c_mutex);\n\n\tswitch (voltage) {\n\tcase SEC_VOLTAGE_18:\n\t\tret |= lme2510_usb_talk(d,\n\t\t\tvoltage_high, len, rbuf, rlen);\n\t\tbreak;\n\n\tcase SEC_VOLTAGE_OFF:\n\tcase SEC_VOLTAGE_13:\n\tdefault:\n\t\tret |= lme2510_usb_talk(d,\n\t\t\t\tvoltage_low, len, rbuf, rlen);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&d->i2c_mutex);\n\n\tif (st->tuner_config == TUNER_RS2000)\n\t\tif (st->fe_set_voltage)\n\t\t\tst->fe_set_voltage(fe, voltage);\n\n\n\treturn (ret < 0) ? -ENODEV : 0;\n}\n\nstatic int dm04_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct dvb_usb_device *d = fe_to_d(fe);\n\tstruct lme2510_state *st = d->priv;\n\tint ret = 0;\n\n\tif (st->i2c_talk_onoff) {\n\t\tif (st->fe_read_status) {\n\t\t\tret = st->fe_read_status(fe, status);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tst->lock_status = *status;\n\n\t\tif (*status & FE_HAS_LOCK && st->stream_on) {\n\t\t\tmutex_lock(&d->i2c_mutex);\n\n\t\t\tst->i2c_talk_onoff = 0;\n\t\t\tret = lme2510_stream_restart(d);\n\n\t\t\tmutex_unlock(&d->i2c_mutex);\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\t \n\tif (st->tuner_config == TUNER_RS2000 &&\n\t    time_after(jiffies, st->int_urb_due))\n\t\tst->lock_status &= ~FE_HAS_LOCK;\n\n\t*status = st->lock_status;\n\n\tif (!(*status & FE_HAS_LOCK)) {\n\t\tstruct dvb_usb_adapter *adap = fe_to_adap(fe);\n\n\t\tst->i2c_talk_onoff = 1;\n\n\t\tlme2510_update_stats(adap);\n\t}\n\n\treturn ret;\n}\n\nstatic int dm04_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct lme2510_state *st = fe_to_priv(fe);\n\n\tif (st->fe_read_signal_strength && !st->stream_on)\n\t\treturn st->fe_read_signal_strength(fe, strength);\n\n\tif (c->strength.stat[0].scale == FE_SCALE_RELATIVE)\n\t\t*strength = (u16)c->strength.stat[0].uvalue;\n\telse\n\t\t*strength = 0;\n\n\treturn 0;\n}\n\nstatic int dm04_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct lme2510_state *st = fe_to_priv(fe);\n\n\tif (st->fe_read_snr && !st->stream_on)\n\t\treturn st->fe_read_snr(fe, snr);\n\n\tif (c->cnr.stat[0].scale == FE_SCALE_RELATIVE)\n\t\t*snr = (u16)c->cnr.stat[0].uvalue;\n\telse\n\t\t*snr = 0;\n\n\treturn 0;\n}\n\nstatic int dm04_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct lme2510_state *st = fe_to_priv(fe);\n\n\tif (st->fe_read_ber && !st->stream_on)\n\t\treturn st->fe_read_ber(fe, ber);\n\n\t*ber = 0;\n\n\treturn 0;\n}\n\nstatic int dm04_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct lme2510_state *st = fe_to_priv(fe);\n\n\tif (st->fe_read_ucblocks && !st->stream_on)\n\t\treturn st->fe_read_ucblocks(fe, ucblocks);\n\n\t*ucblocks = 0;\n\n\treturn 0;\n}\n\nstatic int lme_name(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct lme2510_state *st = adap_to_priv(adap);\n\tconst char *desc = d->name;\n\tstatic const char * const fe_name[] = {\n\t\t\"\", \" LG TDQY-P001F\", \" SHARP:BS2F7HZ7395\",\n\t\t\" SHARP:BS2F7HZ0194\", \" RS2000\"};\n\tchar *name = adap->fe[0]->ops.info.name;\n\n\tstrscpy(name, desc, 128);\n\tstrlcat(name, fe_name[st->tuner_config], 128);\n\n\treturn 0;\n}\n\nstatic int dm04_lme2510_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct lme2510_state *st = d->priv;\n\tint ret = 0;\n\n\tst->i2c_talk_onoff = 1;\n\tswitch (le16_to_cpu(d->udev->descriptor.idProduct)) {\n\tcase 0x1122:\n\tcase 0x1120:\n\t\tst->i2c_gate = 4;\n\t\tadap->fe[0] = dvb_attach(tda10086_attach,\n\t\t\t&tda10086_config, &d->i2c_adap);\n\t\tif (adap->fe[0]) {\n\t\t\tinfo(\"TUN Found Frontend TDA10086\");\n\t\t\tst->i2c_tuner_gate_w = 4;\n\t\t\tst->i2c_tuner_gate_r = 4;\n\t\t\tst->i2c_tuner_addr = 0x60;\n\t\t\tst->tuner_config = TUNER_LG;\n\t\t\tif (st->dvb_usb_lme2510_firmware != TUNER_LG) {\n\t\t\t\tst->dvb_usb_lme2510_firmware = TUNER_LG;\n\t\t\t\tret = lme_firmware_switch(d, 1) ? 0 : -ENODEV;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tst->i2c_gate = 4;\n\t\tadap->fe[0] = dvb_attach(stv0299_attach,\n\t\t\t\t&sharp_z0194_config, &d->i2c_adap);\n\t\tif (adap->fe[0]) {\n\t\t\tinfo(\"FE Found Stv0299\");\n\t\t\tst->i2c_tuner_gate_w = 4;\n\t\t\tst->i2c_tuner_gate_r = 5;\n\t\t\tst->i2c_tuner_addr = 0x60;\n\t\t\tst->tuner_config = TUNER_S0194;\n\t\t\tif (st->dvb_usb_lme2510_firmware != TUNER_S0194) {\n\t\t\t\tst->dvb_usb_lme2510_firmware = TUNER_S0194;\n\t\t\t\tret = lme_firmware_switch(d, 1) ? 0 : -ENODEV;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tst->i2c_gate = 5;\n\t\tadap->fe[0] = dvb_attach(stv0288_attach, &lme_config,\n\t\t\t&d->i2c_adap);\n\n\t\tif (adap->fe[0]) {\n\t\t\tinfo(\"FE Found Stv0288\");\n\t\t\tst->i2c_tuner_gate_w = 4;\n\t\t\tst->i2c_tuner_gate_r = 5;\n\t\t\tst->i2c_tuner_addr = 0x60;\n\t\t\tst->tuner_config = TUNER_S7395;\n\t\t\tif (st->dvb_usb_lme2510_firmware != TUNER_S7395) {\n\t\t\t\tst->dvb_usb_lme2510_firmware = TUNER_S7395;\n\t\t\t\tret = lme_firmware_switch(d, 1) ? 0 : -ENODEV;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase 0x22f0:\n\t\tst->i2c_gate = 5;\n\t\tadap->fe[0] = dvb_attach(m88rs2000_attach,\n\t\t\t&m88rs2000_config, &d->i2c_adap);\n\n\t\tif (adap->fe[0]) {\n\t\t\tinfo(\"FE Found M88RS2000\");\n\t\t\tst->i2c_tuner_gate_w = 5;\n\t\t\tst->i2c_tuner_gate_r = 5;\n\t\t\tst->i2c_tuner_addr = 0x60;\n\t\t\tst->tuner_config = TUNER_RS2000;\n\t\t\tst->fe_set_voltage =\n\t\t\t\tadap->fe[0]->ops.set_voltage;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (adap->fe[0] == NULL) {\n\t\tinfo(\"DM04/QQBOX Not Powered up or not Supported\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (ret) {\n\t\tif (adap->fe[0]) {\n\t\t\tdvb_frontend_detach(adap->fe[0]);\n\t\t\tadap->fe[0] = NULL;\n\t\t}\n\t\td->rc_map = NULL;\n\t\treturn -ENODEV;\n\t}\n\n\tst->fe_read_status = adap->fe[0]->ops.read_status;\n\tst->fe_read_signal_strength = adap->fe[0]->ops.read_signal_strength;\n\tst->fe_read_snr = adap->fe[0]->ops.read_snr;\n\tst->fe_read_ber = adap->fe[0]->ops.read_ber;\n\tst->fe_read_ucblocks = adap->fe[0]->ops.read_ucblocks;\n\n\tadap->fe[0]->ops.read_status = dm04_read_status;\n\tadap->fe[0]->ops.read_signal_strength = dm04_read_signal_strength;\n\tadap->fe[0]->ops.read_snr = dm04_read_snr;\n\tadap->fe[0]->ops.read_ber = dm04_read_ber;\n\tadap->fe[0]->ops.read_ucblocks = dm04_read_ucblocks;\n\tadap->fe[0]->ops.set_voltage = dm04_lme2510_set_voltage;\n\n\tret = lme_name(adap);\n\treturn ret;\n}\n\nstatic int dm04_lme2510_tuner(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct lme2510_state *st = adap_to_priv(adap);\n\tstatic const char * const tun_msg[] = {\"\", \"TDA8263\", \"IX2505V\", \"DVB_PLL_OPERA\", \"RS2000\"};\n\tint ret = 0;\n\n\tswitch (st->tuner_config) {\n\tcase TUNER_LG:\n\t\tif (dvb_attach(tda826x_attach, adap->fe[0], 0x60,\n\t\t\t&d->i2c_adap, 1))\n\t\t\tret = st->tuner_config;\n\t\tbreak;\n\tcase TUNER_S7395:\n\t\tif (dvb_attach(ix2505v_attach , adap->fe[0], &lme_tuner,\n\t\t\t&d->i2c_adap))\n\t\t\tret = st->tuner_config;\n\t\tbreak;\n\tcase TUNER_S0194:\n\t\tif (dvb_attach(dvb_pll_attach , adap->fe[0], 0x60,\n\t\t\t&d->i2c_adap, DVB_PLL_OPERA1))\n\t\t\tret = st->tuner_config;\n\t\tbreak;\n\tcase TUNER_RS2000:\n\t\tif (dvb_attach(ts2020_attach, adap->fe[0],\n\t\t\t       &ts2020_config, &d->i2c_adap))\n\t\t\tret = st->tuner_config;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ret) {\n\t\tinfo(\"TUN Found %s tuner\", tun_msg[ret]);\n\t} else {\n\t\tinfo(\"TUN No tuner found\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = lme2510_int_read(adap);\n\tif (ret < 0) {\n\t\tinfo(\"INT Unable to start Interrupt Service\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn ret;\n}\n\nstatic int lme2510_powerup(struct dvb_usb_device *d, int onoff)\n{\n\tstruct lme2510_state *st = d->priv;\n\tstatic u8 lnb_on[] = LNB_ON;\n\tstatic u8 lnb_off[] = LNB_OFF;\n\tstatic u8 rbuf[1];\n\tint ret = 0, len = 3, rlen = 1;\n\n\tmutex_lock(&d->i2c_mutex);\n\n\tret = lme2510_usb_talk(d, onoff ? lnb_on : lnb_off, len, rbuf, rlen);\n\n\tst->i2c_talk_onoff = 1;\n\n\tmutex_unlock(&d->i2c_mutex);\n\n\treturn ret;\n}\n\nstatic int lme2510_identify_state(struct dvb_usb_device *d, const char **name)\n{\n\tstruct lme2510_state *st = d->priv;\n\tint status;\n\n\tusb_reset_configuration(d->udev);\n\n\tusb_set_interface(d->udev,\n\t\td->props->bInterfaceNumber, 1);\n\n\tst->dvb_usb_lme2510_firmware = dvb_usb_lme2510_firmware;\n\n\tstatus = lme2510_return_status(d);\n\tif (status == 0x44) {\n\t\t*name = lme_firmware_switch(d, 0);\n\t\treturn COLD;\n\t}\n\n\tif (status != 0x47)\n\t\treturn -EINVAL;\n\n\treturn WARM;\n}\n\nstatic int lme2510_get_stream_config(struct dvb_frontend *fe, u8 *ts_type,\n\t\tstruct usb_data_stream_properties *stream)\n{\n\tstruct dvb_usb_adapter *adap = fe_to_adap(fe);\n\tstruct dvb_usb_device *d;\n\n\tif (adap == NULL)\n\t\treturn 0;\n\n\td = adap_to_d(adap);\n\n\t \n\tif (pid_filter == 2) {\n\t\tadap->pid_filtering  = true;\n\t\tadap->max_feed_count = 15;\n\t}\n\n\tif (!(le16_to_cpu(d->udev->descriptor.idProduct)\n\t\t== 0x1122))\n\t\tstream->endpoint = 0x8;\n\n\treturn 0;\n}\n\nstatic int lme2510_get_rc_config(struct dvb_usb_device *d,\n\tstruct dvb_usb_rc *rc)\n{\n\trc->allowed_protos = RC_PROTO_BIT_NEC32;\n\treturn 0;\n}\n\nstatic void lme2510_exit(struct dvb_usb_device *d)\n{\n\tstruct lme2510_state *st = d->priv;\n\n\tif (st->lme_urb) {\n\t\tusb_kill_urb(st->lme_urb);\n\t\tusb_free_urb(st->lme_urb);\n\t\tinfo(\"Interrupt Service Stopped\");\n\t}\n}\n\nstatic struct dvb_usb_device_properties lme2510_props = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.bInterfaceNumber = 0,\n\t.adapter_nr = adapter_nr,\n\t.size_of_priv = sizeof(struct lme2510_state),\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\t.generic_bulk_ctrl_endpoint_response = 0x01,\n\n\t.download_firmware = lme2510_download_firmware,\n\n\t.power_ctrl       = lme2510_powerup,\n\t.identify_state   = lme2510_identify_state,\n\t.i2c_algo         = &lme2510_i2c_algo,\n\n\t.frontend_attach  = dm04_lme2510_frontend_attach,\n\t.tuner_attach = dm04_lme2510_tuner,\n\t.get_stream_config = lme2510_get_stream_config,\n\t.streaming_ctrl   = lme2510_streaming_ctrl,\n\n\t.get_rc_config = lme2510_get_rc_config,\n\n\t.exit = lme2510_exit,\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER|\n\t\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t.pid_filter_count = 15,\n\t\t\t.pid_filter = lme2510_pid_filter,\n\t\t\t.pid_filter_ctrl  = lme2510_pid_filter_ctrl,\n\t\t\t.stream =\n\t\t\tDVB_USB_STREAM_BULK(0x86, 10, 4096),\n\t\t},\n\t},\n};\n\nstatic const struct usb_device_id lme2510_id_table[] = {\n\t{\tDVB_USB_DEVICE(0x3344, 0x1122, &lme2510_props,\n\t\t\"DM04_LME2510_DVB-S\", RC_MAP_LME2510)\t},\n\t{\tDVB_USB_DEVICE(0x3344, 0x1120, &lme2510_props,\n\t\t\"DM04_LME2510C_DVB-S\", RC_MAP_LME2510)\t},\n\t{\tDVB_USB_DEVICE(0x3344, 0x22f0, &lme2510_props,\n\t\t\"DM04_LME2510C_DVB-S RS2000\", RC_MAP_LME2510)\t},\n\t{}\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, lme2510_id_table);\n\nstatic struct usb_driver lme2510_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.probe\t\t= dvb_usbv2_probe,\n\t.disconnect\t= dvb_usbv2_disconnect,\n\t.id_table\t= lme2510_id_table,\n\t.no_dynamic_id = 1,\n\t.soft_unbind = 1,\n};\n\nmodule_usb_driver(lme2510_driver);\n\nMODULE_AUTHOR(\"Malcolm Priestley <tvboxspy@gmail.com>\");\nMODULE_DESCRIPTION(\"LME2510(C) DVB-S USB2.0\");\nMODULE_VERSION(\"2.07\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(LME2510_C_S7395);\nMODULE_FIRMWARE(LME2510_C_LG);\nMODULE_FIRMWARE(LME2510_C_S0194);\nMODULE_FIRMWARE(LME2510_C_RS2000);\nMODULE_FIRMWARE(LME2510_LG);\nMODULE_FIRMWARE(LME2510_S0194);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}