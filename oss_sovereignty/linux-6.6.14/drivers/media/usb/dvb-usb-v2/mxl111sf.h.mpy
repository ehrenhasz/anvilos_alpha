{
  "module_name": "mxl111sf.h",
  "hash_id": "0a68161c450598208889f3113cc2e3f3b6510559c5a4f652089187bd8a1fe624",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/mxl111sf.h",
  "human_readable_source": " \n \n\n#ifndef _DVB_USB_MXL111SF_H_\n#define _DVB_USB_MXL111SF_H_\n\n#ifdef DVB_USB_LOG_PREFIX\n#undef DVB_USB_LOG_PREFIX\n#endif\n#define DVB_USB_LOG_PREFIX \"mxl111sf\"\n#include \"dvb_usb.h\"\n#include <media/tveeprom.h>\n#include <media/media-entity.h>\n\n \n#define MXL_MAX_XFER_SIZE  64\n\n#define MXL_EP1_REG_READ     1\n#define MXL_EP2_REG_WRITE    2\n#define MXL_EP3_INTERRUPT    3\n#define MXL_EP4_MPEG2        4\n#define MXL_EP5_I2S          5\n#define MXL_EP6_656          6\n#define MXL_EP6_MPEG2        6\n\n#ifdef USING_ENUM_mxl111sf_current_mode\nenum mxl111sf_current_mode {\n\tmxl_mode_dvbt = MXL_EP4_MPEG2,\n\tmxl_mode_mh   = MXL_EP5_I2S,\n\tmxl_mode_atsc = MXL_EP6_MPEG2,\n};\n#endif\n\nenum mxl111sf_gpio_port_expander {\n\tmxl111sf_gpio_hw,\n\tmxl111sf_PCA9534,\n};\n\nstruct mxl111sf_adap_state {\n\tint alt_mode;\n\tint gpio_mode;\n\tint device_mode;\n\tint ep6_clockphase;\n\tint (*fe_init)(struct dvb_frontend *);\n\tint (*fe_sleep)(struct dvb_frontend *);\n};\n\nenum mxl111sf_pads {\n\tMXL111SF_PAD_RF_INPUT,\n\tMXL111SF_PAD_OUTPUT,\n\tMXL111SF_NUM_PADS\n};\n\nstruct mxl111sf_state {\n\tstruct dvb_usb_device *d;\n\n\tenum mxl111sf_gpio_port_expander gpio_port_expander;\n\tu8 port_expander_addr;\n\n\tu8 chip_id;\n\tu8 chip_ver;\n#define MXL111SF_V6     1\n#define MXL111SF_V8_100 2\n#define MXL111SF_V8_200 3\n\tu8 chip_rev;\n\n#ifdef USING_ENUM_mxl111sf_current_mode\n\tenum mxl111sf_current_mode current_mode;\n#endif\n\n#define MXL_TUNER_MODE         0\n#define MXL_SOC_MODE           1\n#define MXL_DEV_MODE_MASK      0x01\n#if 1\n\tint device_mode;\n#endif\n\t \n\tint alt_mode;\n\tint gpio_mode;\n\tstruct tveeprom tv;\n\n\tstruct mutex fe_lock;\n\tu8 num_frontends;\n\tstruct mxl111sf_adap_state adap_state[3];\n\tu8 sndbuf[MXL_MAX_XFER_SIZE];\n\tu8 rcvbuf[MXL_MAX_XFER_SIZE];\n\tstruct mutex msg_lock;\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tstruct media_entity tuner;\n\tstruct media_pad tuner_pads[MXL111SF_NUM_PADS];\n#endif\n};\n\nint mxl111sf_read_reg(struct mxl111sf_state *state, u8 addr, u8 *data);\nint mxl111sf_write_reg(struct mxl111sf_state *state, u8 addr, u8 data);\n\nstruct mxl111sf_reg_ctrl_info {\n\tu8 addr;\n\tu8 mask;\n\tu8 data;\n};\n\nint mxl111sf_write_reg_mask(struct mxl111sf_state *state,\n\t\t\t    u8 addr, u8 mask, u8 data);\nint mxl111sf_ctrl_program_regs(struct mxl111sf_state *state,\n\t\t\t       struct mxl111sf_reg_ctrl_info *ctrl_reg_info);\n\n \nint mxl111sf_ctrl_msg(struct mxl111sf_state *state,\n\t\t      u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen);\n\n#define mxl_printk(kern, fmt, arg...) \\\n\tprintk(kern \"%s: \" fmt \"\\n\", __func__, ##arg)\n\n#define mxl_info(fmt, arg...) \\\n\tmxl_printk(KERN_INFO, fmt, ##arg)\n\nextern int dvb_usb_mxl111sf_debug;\n#define mxl_debug(fmt, arg...) \\\n\tif (dvb_usb_mxl111sf_debug) \\\n\t\tmxl_printk(KERN_DEBUG, fmt, ##arg)\n\n#define MXL_I2C_DBG 0x04\n#define MXL_ADV_DBG 0x10\n#define mxl_debug_adv(fmt, arg...) \\\n\tif (dvb_usb_mxl111sf_debug & MXL_ADV_DBG) \\\n\t\tmxl_printk(KERN_DEBUG, fmt, ##arg)\n\n#define mxl_i2c(fmt, arg...) \\\n\tif (dvb_usb_mxl111sf_debug & MXL_I2C_DBG) \\\n\t\tmxl_printk(KERN_DEBUG, fmt, ##arg)\n\n#define mxl_i2c_adv(fmt, arg...) \\\n\tif ((dvb_usb_mxl111sf_debug & (MXL_I2C_DBG | MXL_ADV_DBG)) == \\\n\t\t(MXL_I2C_DBG | MXL_ADV_DBG)) \\\n\t\t\tmxl_printk(KERN_DEBUG, fmt, ##arg)\n\n \n#if (defined(__MXL111SF_TUNER_H__)) || (defined(__MXL111SF_DEMOD_H__))\n#define MXL_ADV_DEBUG_ENABLED MXL_ADV_DBG\n#else\n#define MXL_ADV_DEBUG_ENABLED dvb_usb_mxl111sf_debug\n#endif\n\n#define mxl_fail(ret)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint __ret;\t\t\t\t\t\t\t\\\n\t__ret = (ret < 0);\t\t\t\t\t\t\\\n\tif ((__ret) && (MXL_ADV_DEBUG_ENABLED & MXL_ADV_DBG))\t\t\\\n\t\tmxl_printk(KERN_ERR, \"error %d on line %d\",\t\t\\\n\t\t\t   ret, __LINE__);\t\t\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\\\n})\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}