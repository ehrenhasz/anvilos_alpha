{
  "module_name": "dvb_usb.h",
  "hash_id": "210ce9789cbab96703feb53f54af23f5c49598c263f6c3b19c14deab3eaefa20",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/dvb_usb.h",
  "human_readable_source": " \n \n\n#ifndef DVB_USB_H\n#define DVB_USB_H\n\n#include <linux/usb/input.h>\n#include <linux/firmware.h>\n#include <media/rc-core.h>\n#include <media/media-device.h>\n\n#include <media/dvb_frontend.h>\n#include <media/dvb_demux.h>\n#include <media/dvb_net.h>\n#include <media/dmxdev.h>\n#include <media/dvb-usb-ids.h>\n\n \n\n \n#define adap_to_d(adap) (container_of(adap, struct dvb_usb_device, \\\n\t\tadapter[adap->id]))\n#define adap_to_priv(adap) (adap_to_d(adap)->priv)\n#define fe_to_adap(fe) ((struct dvb_usb_adapter *) ((fe)->dvb->priv))\n#define fe_to_d(fe) (adap_to_d(fe_to_adap(fe)))\n#define fe_to_priv(fe) (fe_to_d(fe)->priv)\n#define d_to_priv(d) (d->priv)\n\n#define dvb_usb_dbg_usb_control_msg(udev, r, t, v, i, b, l) { \\\n\tchar *direction; \\\n\tif (t == (USB_TYPE_VENDOR | USB_DIR_OUT)) \\\n\t\tdirection = \">>>\"; \\\n\telse \\\n\t\tdirection = \"<<<\"; \\\n\tdev_dbg(&udev->dev, \"%s: %02x %02x %02x %02x %02x %02x %02x %02x \" \\\n\t\t\t\"%s %*ph\\n\",  __func__, t, r, v & 0xff, v >> 8, \\\n\t\t\ti & 0xff, i >> 8, l & 0xff, l >> 8, direction, l, b); \\\n}\n\n#define DVB_USB_STREAM_BULK(endpoint_, count_, size_) { \\\n\t.type = USB_BULK, \\\n\t.count = count_, \\\n\t.endpoint = endpoint_, \\\n\t.u = { \\\n\t\t.bulk = { \\\n\t\t\t.buffersize = size_, \\\n\t\t} \\\n\t} \\\n}\n\n#define DVB_USB_STREAM_ISOC(endpoint_, count_, frames_, size_, interval_) { \\\n\t.type = USB_ISOC, \\\n\t.count = count_, \\\n\t.endpoint = endpoint_, \\\n\t.u = { \\\n\t\t.isoc = { \\\n\t\t\t.framesperurb = frames_, \\\n\t\t\t.framesize = size_,\\\n\t\t\t.interval = interval_, \\\n\t\t} \\\n\t} \\\n}\n\n#define DVB_USB_DEVICE(vend, prod, props_, name_, rc) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.driver_info = (kernel_ulong_t) &((const struct dvb_usb_driver_info) { \\\n\t\t.props = (props_), \\\n\t\t.name = (name_), \\\n\t\t.rc_map = (rc), \\\n\t})\n\nstruct dvb_usb_device;\nstruct dvb_usb_adapter;\n\n \nstruct dvb_usb_driver_info {\n\tconst char *name;\n\tconst char *rc_map;\n\tconst struct dvb_usb_device_properties *props;\n};\n\n \nstruct dvb_usb_rc {\n\tconst char *map_name;\n\tu64 allowed_protos;\n\tint (*change_protocol)(struct rc_dev *dev, u64 *rc_proto);\n\tint (*query) (struct dvb_usb_device *d);\n\tunsigned int interval;\n\tenum rc_driver_type driver_type;\n\tbool bulk_mode;\n\tint timeout;\n};\n\n \nstruct usb_data_stream_properties {\n#define USB_BULK  1\n#define USB_ISOC  2\n\tu8 type;\n\tu8 count;\n\tu8 endpoint;\n\n\tunion {\n\t\tstruct {\n\t\t\tunsigned int buffersize;  \n\t\t} bulk;\n\t\tstruct {\n\t\t\tint framesperurb;\n\t\t\tint framesize;\n\t\t\tint interval;\n\t\t} isoc;\n\t} u;\n};\n\n \nstruct dvb_usb_adapter_properties {\n#define MAX_NO_OF_FE_PER_ADAP 3\n#define DVB_USB_ADAP_HAS_PID_FILTER               0x01\n#define DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF 0x02\n#define DVB_USB_ADAP_NEED_PID_FILTERING           0x04\n\tu8 caps;\n\n\tu8 pid_filter_count;\n\tint (*pid_filter_ctrl) (struct dvb_usb_adapter *, int);\n\tint (*pid_filter) (struct dvb_usb_adapter *, int, u16, int);\n\n\tstruct usb_data_stream_properties stream;\n};\n\n \nstruct dvb_usb_device_properties {\n#define MAX_NO_OF_ADAPTER_PER_DEVICE 2\n\tconst char *driver_name;\n\tstruct module *owner;\n\tshort *adapter_nr;\n\n\tu8 bInterfaceNumber;\n\tunsigned int size_of_priv;\n\tu8 generic_bulk_ctrl_endpoint;\n\tu8 generic_bulk_ctrl_endpoint_response;\n\tunsigned int generic_bulk_ctrl_delay;\n\n\tint (*probe)(struct dvb_usb_device *);\n\tvoid (*disconnect)(struct dvb_usb_device *);\n#define WARM                  0\n#define COLD                  1\n\tint (*identify_state) (struct dvb_usb_device *, const char **);\n\tconst char *firmware;\n#define RECONNECTS_USB        1\n\tint (*download_firmware) (struct dvb_usb_device *,\n\t\t\tconst struct firmware *);\n\n\tstruct i2c_algorithm *i2c_algo;\n\n\tunsigned int num_adapters;\n\tint (*get_adapter_count) (struct dvb_usb_device *);\n\tstruct dvb_usb_adapter_properties adapter[MAX_NO_OF_ADAPTER_PER_DEVICE];\n\tint (*power_ctrl) (struct dvb_usb_device *, int);\n\tint (*read_config) (struct dvb_usb_device *d);\n\tint (*read_mac_address) (struct dvb_usb_adapter *, u8 []);\n\tint (*frontend_attach) (struct dvb_usb_adapter *);\n\tint (*frontend_detach)(struct dvb_usb_adapter *);\n\tint (*tuner_attach) (struct dvb_usb_adapter *);\n\tint (*tuner_detach)(struct dvb_usb_adapter *);\n\tint (*frontend_ctrl) (struct dvb_frontend *, int);\n\tint (*streaming_ctrl) (struct dvb_frontend *, int);\n\tint (*init) (struct dvb_usb_device *);\n\tvoid (*exit) (struct dvb_usb_device *);\n\tint (*get_rc_config) (struct dvb_usb_device *, struct dvb_usb_rc *);\n#define DVB_USB_FE_TS_TYPE_188        0\n#define DVB_USB_FE_TS_TYPE_204        1\n#define DVB_USB_FE_TS_TYPE_RAW        2\n\tint (*get_stream_config) (struct dvb_frontend *,  u8 *,\n\t\t\tstruct usb_data_stream_properties *);\n};\n\n \nstruct usb_data_stream {\n#define MAX_NO_URBS_FOR_DATA_STREAM 10\n\tstruct usb_device *udev;\n\tstruct usb_data_stream_properties props;\n\n#define USB_STATE_INIT    0x00\n#define USB_STATE_URB_BUF 0x01\n\tu8 state;\n\n\tvoid (*complete) (struct usb_data_stream *, u8 *, size_t);\n\n\tstruct urb    *urb_list[MAX_NO_URBS_FOR_DATA_STREAM];\n\tint            buf_num;\n\tunsigned long  buf_size;\n\tu8            *buf_list[MAX_NO_URBS_FOR_DATA_STREAM];\n\tdma_addr_t     dma_addr[MAX_NO_URBS_FOR_DATA_STREAM];\n\n\tint urbs_initialized;\n\tint urbs_submitted;\n\n\tvoid *user_priv;\n};\n\n \nstruct dvb_usb_adapter {\n\tconst struct dvb_usb_adapter_properties *props;\n\tstruct usb_data_stream stream;\n\tu8 id;\n\tu8 ts_type;\n\tbool suspend_resume_active;\n\tbool pid_filtering;\n\tu8 feed_count;\n\tu8 max_feed_count;\n\ts8 active_fe;\n#define ADAP_INIT                0\n#define ADAP_SLEEP               1\n#define ADAP_STREAMING           2\n\tunsigned long state_bits;\n\n\t \n\tstruct dvb_adapter   dvb_adap;\n\tstruct dmxdev        dmxdev;\n\tstruct dvb_demux     demux;\n\tstruct dvb_net       dvb_net;\n\n\tstruct dvb_frontend *fe[MAX_NO_OF_FE_PER_ADAP];\n\tint (*fe_init[MAX_NO_OF_FE_PER_ADAP]) (struct dvb_frontend *);\n\tint (*fe_sleep[MAX_NO_OF_FE_PER_ADAP]) (struct dvb_frontend *);\n};\n\n \nstruct dvb_usb_device {\n\tconst struct dvb_usb_device_properties *props;\n\tconst char *name;\n\tconst char *rc_map;\n\tbool rc_polling_active;\n\tstruct usb_interface *intf;\n\tstruct usb_device *udev;\n\tstruct dvb_usb_rc rc;\n\tint powered;\n\n\t \n\tstruct mutex usb_mutex;\n\n\t \n\tstruct mutex i2c_mutex;\n\tstruct i2c_adapter i2c_adap;\n\n\tstruct dvb_usb_adapter adapter[MAX_NO_OF_ADAPTER_PER_DEVICE];\n\n\t \n\tstruct rc_dev *rc_dev;\n\tchar rc_phys[64];\n\tstruct delayed_work rc_query_work;\n\n\tvoid *priv;\n};\n\nextern int dvb_usbv2_probe(struct usb_interface *,\n\t\tconst struct usb_device_id *);\nextern void dvb_usbv2_disconnect(struct usb_interface *);\nextern int dvb_usbv2_suspend(struct usb_interface *, pm_message_t);\nextern int dvb_usbv2_resume(struct usb_interface *);\nextern int dvb_usbv2_reset_resume(struct usb_interface *);\n\n \nextern int dvb_usbv2_generic_rw(struct dvb_usb_device *, u8 *, u16, u8 *, u16);\nextern int dvb_usbv2_generic_write(struct dvb_usb_device *, u8 *, u16);\n \nextern int dvb_usbv2_generic_rw_locked(struct dvb_usb_device *,\n\t\tu8 *, u16, u8 *, u16);\nextern int dvb_usbv2_generic_write_locked(struct dvb_usb_device *, u8 *, u16);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}