{
  "module_name": "dvbsky.c",
  "hash_id": "205097e1b19ffee193d0443729f2075a357450b4fed2c7a9f702c2afb01f6c2d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/dvbsky.c",
  "human_readable_source": "\n \n\n#include \"dvb_usb.h\"\n#include \"m88ds3103.h\"\n#include \"ts2020.h\"\n#include \"sp2.h\"\n#include \"si2168.h\"\n#include \"si2157.h\"\n\n#define DVBSKY_MSG_DELAY\t0 \n#define DVBSKY_BUF_LEN\t64\n\nstatic int dvb_usb_dvbsky_disable_rc;\nmodule_param_named(disable_rc, dvb_usb_dvbsky_disable_rc, int, 0644);\nMODULE_PARM_DESC(disable_rc, \"Disable inbuilt IR receiver.\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstruct dvbsky_state {\n\tu8 ibuf[DVBSKY_BUF_LEN];\n\tu8 obuf[DVBSKY_BUF_LEN];\n\tu8 last_lock;\n\tstruct i2c_client *i2c_client_demod;\n\tstruct i2c_client *i2c_client_tuner;\n\tstruct i2c_client *i2c_client_ci;\n\n\t \n\tint (*fe_set_voltage)(struct dvb_frontend *fe,\n\t\tenum fe_sec_voltage voltage);\n\tint (*fe_read_status)(struct dvb_frontend *fe,\n\t\tenum fe_status *status);\n};\n\nstatic int dvbsky_usb_generic_rw(struct dvb_usb_device *d,\n\t\tu8 *wbuf, u16 wlen, u8 *rbuf, u16 rlen)\n{\n\tint ret;\n\tstruct dvbsky_state *state = d_to_priv(d);\n\n\tmutex_lock(&d->usb_mutex);\n\tif (wlen != 0)\n\t\tmemcpy(state->obuf, wbuf, wlen);\n\n\tret = dvb_usbv2_generic_rw_locked(d, state->obuf, wlen,\n\t\t\tstate->ibuf, rlen);\n\n\tif (!ret && (rlen != 0))\n\t\tmemcpy(rbuf, state->ibuf, rlen);\n\n\tmutex_unlock(&d->usb_mutex);\n\treturn ret;\n}\n\nstatic int dvbsky_stream_ctrl(struct dvb_usb_device *d, u8 onoff)\n{\n\tstruct dvbsky_state *state = d_to_priv(d);\n\tstatic const u8 obuf_pre[3] = { 0x37, 0, 0 };\n\tstatic const u8 obuf_post[3] = { 0x36, 3, 0 };\n\tint ret;\n\n\tmutex_lock(&d->usb_mutex);\n\tmemcpy(state->obuf, obuf_pre, 3);\n\tret = dvb_usbv2_generic_write_locked(d, state->obuf, 3);\n\tif (!ret && onoff) {\n\t\tmsleep(20);\n\t\tmemcpy(state->obuf, obuf_post, 3);\n\t\tret = dvb_usbv2_generic_write_locked(d, state->obuf, 3);\n\t}\n\tmutex_unlock(&d->usb_mutex);\n\treturn ret;\n}\n\nstatic int dvbsky_streaming_ctrl(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dvb_usb_device *d = fe_to_d(fe);\n\n\treturn dvbsky_stream_ctrl(d, (onoff == 0) ? 0 : 1);\n}\n\n \nstatic int dvbsky_gpio_ctrl(struct dvb_usb_device *d, u8 gport, u8 value)\n{\n\tint ret;\n\tu8 obuf[3], ibuf[2];\n\n\tobuf[0] = 0x0e;\n\tobuf[1] = gport;\n\tobuf[2] = value;\n\tret = dvbsky_usb_generic_rw(d, obuf, 3, ibuf, 1);\n\treturn ret;\n}\n\n \nstatic int dvbsky_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\tint num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint ret = 0;\n\tu8 ibuf[64], obuf[64];\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tif (num > 2) {\n\t\tdev_err(&d->udev->dev,\n\t\t\"too many i2c messages[%d], max 2.\", num);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto i2c_error;\n\t}\n\n\tif (num == 1) {\n\t\tif (msg[0].len > 60) {\n\t\t\tdev_err(&d->udev->dev,\n\t\t\t\"too many i2c bytes[%d], max 60.\",\n\t\t\tmsg[0].len);\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto i2c_error;\n\t\t}\n\t\tif (msg[0].flags & I2C_M_RD) {\n\t\t\t \n\t\t\tobuf[0] = 0x09;\n\t\t\tobuf[1] = 0;\n\t\t\tobuf[2] = msg[0].len;\n\t\t\tobuf[3] = msg[0].addr;\n\t\t\tret = dvbsky_usb_generic_rw(d, obuf, 4,\n\t\t\t\t\tibuf, msg[0].len + 1);\n\t\t\tif (!ret)\n\t\t\t\tmemcpy(msg[0].buf, &ibuf[1], msg[0].len);\n\t\t} else {\n\t\t\t \n\t\t\tobuf[0] = 0x08;\n\t\t\tobuf[1] = msg[0].addr;\n\t\t\tobuf[2] = msg[0].len;\n\t\t\tmemcpy(&obuf[3], msg[0].buf, msg[0].len);\n\t\t\tret = dvbsky_usb_generic_rw(d, obuf,\n\t\t\t\t\tmsg[0].len + 3, ibuf, 1);\n\t\t}\n\t} else {\n\t\tif ((msg[0].len > 60) || (msg[1].len > 60)) {\n\t\t\tdev_err(&d->udev->dev,\n\t\t\t\"too many i2c bytes[w-%d][r-%d], max 60.\",\n\t\t\tmsg[0].len, msg[1].len);\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto i2c_error;\n\t\t}\n\t\t \n\t\tobuf[0] = 0x09;\n\t\tobuf[1] = msg[0].len;\n\t\tobuf[2] = msg[1].len;\n\t\tobuf[3] = msg[0].addr;\n\t\tmemcpy(&obuf[4], msg[0].buf, msg[0].len);\n\t\tret = dvbsky_usb_generic_rw(d, obuf,\n\t\t\tmsg[0].len + 4, ibuf, msg[1].len + 1);\n\t\tif (!ret)\n\t\t\tmemcpy(msg[1].buf, &ibuf[1], msg[1].len);\n\t}\ni2c_error:\n\tmutex_unlock(&d->i2c_mutex);\n\treturn (ret) ? ret : num;\n}\n\nstatic u32 dvbsky_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm dvbsky_i2c_algo = {\n\t.master_xfer   = dvbsky_i2c_xfer,\n\t.functionality = dvbsky_i2c_func,\n};\n\n#if IS_ENABLED(CONFIG_RC_CORE)\nstatic int dvbsky_rc_query(struct dvb_usb_device *d)\n{\n\tu32 code = 0xffff, scancode;\n\tu8 rc5_command, rc5_system;\n\tu8 obuf[2], ibuf[2], toggle;\n\tint ret;\n\n\tobuf[0] = 0x10;\n\tret = dvbsky_usb_generic_rw(d, obuf, 1, ibuf, 2);\n\tif (ret == 0)\n\t\tcode = (ibuf[0] << 8) | ibuf[1];\n\tif (code != 0xffff) {\n\t\tdev_dbg(&d->udev->dev, \"rc code: %x\\n\", code);\n\t\trc5_command = code & 0x3F;\n\t\trc5_system = (code & 0x7C0) >> 6;\n\t\ttoggle = (code & 0x800) ? 1 : 0;\n\t\tscancode = rc5_system << 8 | rc5_command;\n\t\trc_keydown(d->rc_dev, RC_PROTO_RC5, scancode, toggle);\n\t}\n\treturn 0;\n}\n\nstatic int dvbsky_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)\n{\n\tif (dvb_usb_dvbsky_disable_rc) {\n\t\trc->map_name = NULL;\n\t\treturn 0;\n\t}\n\n\trc->allowed_protos = RC_PROTO_BIT_RC5;\n\trc->query          = dvbsky_rc_query;\n\trc->interval       = 300;\n\treturn 0;\n}\n#else\n\t#define dvbsky_get_rc_config NULL\n#endif\n\nstatic int dvbsky_usb_set_voltage(struct dvb_frontend *fe,\n\tenum fe_sec_voltage voltage)\n{\n\tstruct dvb_usb_device *d = fe_to_d(fe);\n\tstruct dvbsky_state *state = d_to_priv(d);\n\tu8 value;\n\n\tif (voltage == SEC_VOLTAGE_OFF)\n\t\tvalue = 0;\n\telse\n\t\tvalue = 1;\n\tdvbsky_gpio_ctrl(d, 0x80, value);\n\n\treturn state->fe_set_voltage(fe, voltage);\n}\n\nstatic int dvbsky_read_mac_addr(struct dvb_usb_adapter *adap, u8 mac[6])\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tu8 obuf[] = { 0x1e, 0x00 };\n\tu8 ibuf[6] = { 0 };\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = 0x51,\n\t\t\t.flags = 0,\n\t\t\t.buf = obuf,\n\t\t\t.len = 2,\n\t\t}, {\n\t\t\t.addr = 0x51,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = ibuf,\n\t\t\t.len = 6,\n\t\t}\n\t};\n\n\tif (i2c_transfer(&d->i2c_adap, msg, 2) == 2)\n\t\tmemcpy(mac, ibuf, 6);\n\n\treturn 0;\n}\n\nstatic int dvbsky_usb_read_status(struct dvb_frontend *fe,\n\t\t\t\t  enum fe_status *status)\n{\n\tstruct dvb_usb_device *d = fe_to_d(fe);\n\tstruct dvbsky_state *state = d_to_priv(d);\n\tint ret;\n\n\tret = state->fe_read_status(fe, status);\n\n\t \n\tif ((*status & FE_HAS_LOCK) && (!state->last_lock))\n\t\tdvbsky_stream_ctrl(d, 1);\n\n\tstate->last_lock = (*status & FE_HAS_LOCK) ? 1 : 0;\n\treturn ret;\n}\n\nstatic int dvbsky_s960_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvbsky_state *state = adap_to_priv(adap);\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct i2c_adapter *i2c_adapter;\n\tstruct m88ds3103_platform_data m88ds3103_pdata = {};\n\tstruct ts2020_config ts2020_config = {};\n\n\t \n\tm88ds3103_pdata.clk = 27000000;\n\tm88ds3103_pdata.i2c_wr_max = 33;\n\tm88ds3103_pdata.clk_out = 0;\n\tm88ds3103_pdata.ts_mode = M88DS3103_TS_CI;\n\tm88ds3103_pdata.ts_clk = 16000;\n\tm88ds3103_pdata.ts_clk_pol = 0;\n\tm88ds3103_pdata.agc = 0x99;\n\tm88ds3103_pdata.lnb_hv_pol = 1;\n\tm88ds3103_pdata.lnb_en_pol = 1;\n\n\tstate->i2c_client_demod = dvb_module_probe(\"m88ds3103\", NULL,\n\t\t\t\t\t\t   &d->i2c_adap,\n\t\t\t\t\t\t   0x68, &m88ds3103_pdata);\n\tif (!state->i2c_client_demod)\n\t\treturn -ENODEV;\n\n\tadap->fe[0] = m88ds3103_pdata.get_dvb_frontend(state->i2c_client_demod);\n\ti2c_adapter = m88ds3103_pdata.get_i2c_adapter(state->i2c_client_demod);\n\n\t \n\tts2020_config.fe = adap->fe[0];\n\tts2020_config.get_agc_pwm = m88ds3103_get_agc_pwm;\n\n\tstate->i2c_client_tuner = dvb_module_probe(\"ts2020\", NULL,\n\t\t\t\t\t\t   i2c_adapter,\n\t\t\t\t\t\t   0x60, &ts2020_config);\n\tif (!state->i2c_client_tuner) {\n\t\tdvb_module_release(state->i2c_client_demod);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tadap->fe[0]->ops.read_signal_strength =\n\t\t\tadap->fe[0]->ops.tuner_ops.get_rf_strength;\n\n\t \n\tstate->fe_read_status = adap->fe[0]->ops.read_status;\n\tadap->fe[0]->ops.read_status = dvbsky_usb_read_status;\n\n\t \n\tstate->fe_set_voltage = adap->fe[0]->ops.set_voltage;\n\tadap->fe[0]->ops.set_voltage = dvbsky_usb_set_voltage;\n\n\treturn 0;\n}\n\nstatic int dvbsky_usb_ci_set_voltage(struct dvb_frontend *fe,\n\tenum fe_sec_voltage voltage)\n{\n\tstruct dvb_usb_device *d = fe_to_d(fe);\n\tstruct dvbsky_state *state = d_to_priv(d);\n\tu8 value;\n\n\tif (voltage == SEC_VOLTAGE_OFF)\n\t\tvalue = 0;\n\telse\n\t\tvalue = 1;\n\tdvbsky_gpio_ctrl(d, 0x00, value);\n\n\treturn state->fe_set_voltage(fe, voltage);\n}\n\nstatic int dvbsky_ci_ctrl(void *priv, u8 read, int addr,\n\t\t\t\t\tu8 data, int *mem)\n{\n\tstruct dvb_usb_device *d = priv;\n\tint ret = 0;\n\tu8 command[4], respond[2], command_size, respond_size;\n\n\tcommand[1] = (u8)((addr >> 8) & 0xff);  \n\tcommand[2] = (u8)(addr & 0xff);  \n\tif (read) {\n\t\tcommand[0] = 0x71;\n\t\tcommand_size = 3;\n\t\trespond_size = 2;\n\t} else {\n\t\tcommand[0] = 0x70;\n\t\tcommand[3] = data;\n\t\tcommand_size = 4;\n\t\trespond_size = 1;\n\t}\n\tret = dvbsky_usb_generic_rw(d, command, command_size,\n\t\t\trespond, respond_size);\n\tif (ret)\n\t\tgoto err;\n\tif (read)\n\t\t*mem = respond[1];\n\treturn ret;\nerr:\n\tdev_err(&d->udev->dev, \"ci control failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int dvbsky_s960c_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvbsky_state *state = adap_to_priv(adap);\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct i2c_adapter *i2c_adapter;\n\tstruct m88ds3103_platform_data m88ds3103_pdata = {};\n\tstruct ts2020_config ts2020_config = {};\n\tstruct sp2_config sp2_config = {};\n\n\t \n\tm88ds3103_pdata.clk = 27000000;\n\tm88ds3103_pdata.i2c_wr_max = 33;\n\tm88ds3103_pdata.clk_out = 0;\n\tm88ds3103_pdata.ts_mode = M88DS3103_TS_CI;\n\tm88ds3103_pdata.ts_clk = 10000;\n\tm88ds3103_pdata.ts_clk_pol = 1;\n\tm88ds3103_pdata.agc = 0x99;\n\tm88ds3103_pdata.lnb_hv_pol = 0;\n\tm88ds3103_pdata.lnb_en_pol = 1;\n\n\tstate->i2c_client_demod = dvb_module_probe(\"m88ds3103\", NULL,\n\t\t\t\t\t\t   &d->i2c_adap,\n\t\t\t\t\t\t   0x68, &m88ds3103_pdata);\n\tif (!state->i2c_client_demod)\n\t\treturn -ENODEV;\n\n\tadap->fe[0] = m88ds3103_pdata.get_dvb_frontend(state->i2c_client_demod);\n\ti2c_adapter = m88ds3103_pdata.get_i2c_adapter(state->i2c_client_demod);\n\n\t \n\tts2020_config.fe = adap->fe[0];\n\tts2020_config.get_agc_pwm = m88ds3103_get_agc_pwm;\n\n\tstate->i2c_client_tuner = dvb_module_probe(\"ts2020\", NULL,\n\t\t\t\t\t\t   i2c_adapter,\n\t\t\t\t\t\t   0x60, &ts2020_config);\n\tif (!state->i2c_client_tuner) {\n\t\tdvb_module_release(state->i2c_client_demod);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tsp2_config.dvb_adap = &adap->dvb_adap;\n\tsp2_config.priv = d;\n\tsp2_config.ci_control = dvbsky_ci_ctrl;\n\n\tstate->i2c_client_ci = dvb_module_probe(\"sp2\", NULL,\n\t\t\t\t\t\t&d->i2c_adap,\n\t\t\t\t\t\t0x40, &sp2_config);\n\n\tif (!state->i2c_client_ci) {\n\t\tdvb_module_release(state->i2c_client_tuner);\n\t\tdvb_module_release(state->i2c_client_demod);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tadap->fe[0]->ops.read_signal_strength =\n\t\t\tadap->fe[0]->ops.tuner_ops.get_rf_strength;\n\n\t \n\tstate->fe_read_status = adap->fe[0]->ops.read_status;\n\tadap->fe[0]->ops.read_status = dvbsky_usb_read_status;\n\n\t \n\tstate->fe_set_voltage = adap->fe[0]->ops.set_voltage;\n\tadap->fe[0]->ops.set_voltage = dvbsky_usb_ci_set_voltage;\n\n\treturn 0;\n}\n\nstatic int dvbsky_t680c_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvbsky_state *state = adap_to_priv(adap);\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct i2c_adapter *i2c_adapter;\n\tstruct si2168_config si2168_config = {};\n\tstruct si2157_config si2157_config = {};\n\tstruct sp2_config sp2_config = {};\n\n\t \n\tsi2168_config.i2c_adapter = &i2c_adapter;\n\tsi2168_config.fe = &adap->fe[0];\n\tsi2168_config.ts_mode = SI2168_TS_PARALLEL;\n\n\tstate->i2c_client_demod = dvb_module_probe(\"si2168\", NULL,\n\t\t\t\t\t\t   &d->i2c_adap,\n\t\t\t\t\t\t   0x64, &si2168_config);\n\tif (!state->i2c_client_demod)\n\t\treturn -ENODEV;\n\n\t \n\tsi2157_config.fe = adap->fe[0];\n\tsi2157_config.if_port = 1;\n\n\tstate->i2c_client_tuner = dvb_module_probe(\"si2157\", NULL,\n\t\t\t\t\t\t   i2c_adapter,\n\t\t\t\t\t\t   0x60, &si2157_config);\n\tif (!state->i2c_client_tuner) {\n\t\tdvb_module_release(state->i2c_client_demod);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tsp2_config.dvb_adap = &adap->dvb_adap;\n\tsp2_config.priv = d;\n\tsp2_config.ci_control = dvbsky_ci_ctrl;\n\n\tstate->i2c_client_ci = dvb_module_probe(\"sp2\", NULL,\n\t\t\t\t\t\t&d->i2c_adap,\n\t\t\t\t\t\t0x40, &sp2_config);\n\n\tif (!state->i2c_client_ci) {\n\t\tdvb_module_release(state->i2c_client_tuner);\n\t\tdvb_module_release(state->i2c_client_demod);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int dvbsky_t330_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvbsky_state *state = adap_to_priv(adap);\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct i2c_adapter *i2c_adapter;\n\tstruct si2168_config si2168_config = {};\n\tstruct si2157_config si2157_config = {};\n\n\t \n\tsi2168_config.i2c_adapter = &i2c_adapter;\n\tsi2168_config.fe = &adap->fe[0];\n\tsi2168_config.ts_mode = SI2168_TS_PARALLEL;\n\tsi2168_config.ts_clock_gapped = true;\n\n\tstate->i2c_client_demod = dvb_module_probe(\"si2168\", NULL,\n\t\t\t\t\t\t   &d->i2c_adap,\n\t\t\t\t\t\t   0x64, &si2168_config);\n\tif (!state->i2c_client_demod)\n\t\treturn -ENODEV;\n\n\t \n\tsi2157_config.fe = adap->fe[0];\n\tsi2157_config.if_port = 1;\n\n\tstate->i2c_client_tuner = dvb_module_probe(\"si2157\", NULL,\n\t\t\t\t\t\t   i2c_adapter,\n\t\t\t\t\t\t   0x60, &si2157_config);\n\tif (!state->i2c_client_tuner) {\n\t\tdvb_module_release(state->i2c_client_demod);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int dvbsky_mygica_t230c_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvbsky_state *state = adap_to_priv(adap);\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct i2c_adapter *i2c_adapter;\n\tstruct si2168_config si2168_config = {};\n\tstruct si2157_config si2157_config = {};\n\n\t \n\tsi2168_config.i2c_adapter = &i2c_adapter;\n\tsi2168_config.fe = &adap->fe[0];\n\tsi2168_config.ts_mode = SI2168_TS_PARALLEL;\n\tif (le16_to_cpu(d->udev->descriptor.idProduct) == USB_PID_MYGICA_T230C2 ||\n\t    le16_to_cpu(d->udev->descriptor.idProduct) == USB_PID_MYGICA_T230C2_LITE ||\n\t    le16_to_cpu(d->udev->descriptor.idProduct) == USB_PID_MYGICA_T230A)\n\t\tsi2168_config.ts_mode |= SI2168_TS_CLK_MANUAL;\n\tsi2168_config.ts_clock_inv = 1;\n\n\tstate->i2c_client_demod = dvb_module_probe(\"si2168\", NULL,\n\t\t\t\t\t\t   &d->i2c_adap,\n\t\t\t\t\t\t   0x64, &si2168_config);\n\tif (!state->i2c_client_demod)\n\t\treturn -ENODEV;\n\n\t \n\tsi2157_config.fe = adap->fe[0];\n\tif (le16_to_cpu(d->udev->descriptor.idProduct) == USB_PID_MYGICA_T230) {\n\t\tsi2157_config.if_port = 1;\n\t\tstate->i2c_client_tuner = dvb_module_probe(\"si2157\", NULL,\n\t\t\t\t\t\t\t   i2c_adapter,\n\t\t\t\t\t\t\t   0x60,\n\t\t\t\t\t\t\t   &si2157_config);\n\t} else {\n\t\tsi2157_config.if_port = 0;\n\t\tstate->i2c_client_tuner = dvb_module_probe(\"si2157\", \"si2141\",\n\t\t\t\t\t\t\t   i2c_adapter,\n\t\t\t\t\t\t\t   0x60,\n\t\t\t\t\t\t\t   &si2157_config);\n\t}\n\tif (!state->i2c_client_tuner) {\n\t\tdvb_module_release(state->i2c_client_demod);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int dvbsky_identify_state(struct dvb_usb_device *d, const char **name)\n{\n\tif (le16_to_cpu(d->udev->descriptor.idProduct) == USB_PID_MYGICA_T230A) {\n\t\tdvbsky_gpio_ctrl(d, 0x87, 0);\n\t\tmsleep(20);\n\t\tdvbsky_gpio_ctrl(d, 0x86, 1);\n\t\tdvbsky_gpio_ctrl(d, 0x80, 0);\n\t\tmsleep(100);\n\t\tdvbsky_gpio_ctrl(d, 0x80, 1);\n\t\tmsleep(50);\n\t} else {\n\t\tdvbsky_gpio_ctrl(d, 0x04, 1);\n\t\tmsleep(20);\n\t\tdvbsky_gpio_ctrl(d, 0x83, 0);\n\t\tdvbsky_gpio_ctrl(d, 0xc0, 1);\n\t\tmsleep(100);\n\t\tdvbsky_gpio_ctrl(d, 0x83, 1);\n\t\tdvbsky_gpio_ctrl(d, 0xc0, 0);\n\t\tmsleep(50);\n\t}\n\treturn WARM;\n}\n\nstatic int dvbsky_init(struct dvb_usb_device *d)\n{\n\tstruct dvbsky_state *state = d_to_priv(d);\n\tstate->last_lock = 0;\n\treturn 0;\n}\n\nstatic int dvbsky_frontend_detach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct dvbsky_state *state = d_to_priv(d);\n\n\tdev_dbg(&d->udev->dev, \"%s: adap=%d\\n\", __func__, adap->id);\n\n\tdvb_module_release(state->i2c_client_tuner);\n\tdvb_module_release(state->i2c_client_demod);\n\tdvb_module_release(state->i2c_client_ci);\n\n\treturn 0;\n}\n\n \nstatic struct dvb_usb_device_properties dvbsky_s960_props = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\t.size_of_priv = sizeof(struct dvbsky_state),\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\t.generic_bulk_ctrl_endpoint_response = 0x81,\n\t.generic_bulk_ctrl_delay = DVBSKY_MSG_DELAY,\n\n\t.i2c_algo         = &dvbsky_i2c_algo,\n\t.frontend_attach  = dvbsky_s960_attach,\n\t.frontend_detach  = dvbsky_frontend_detach,\n\t.init             = dvbsky_init,\n\t.get_rc_config    = dvbsky_get_rc_config,\n\t.streaming_ctrl   = dvbsky_streaming_ctrl,\n\t.identify_state\t  = dvbsky_identify_state,\n\t.read_mac_address = dvbsky_read_mac_addr,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t\t.stream = DVB_USB_STREAM_BULK(0x82, 8, 4096),\n\t\t}\n\t}\n};\n\nstatic struct dvb_usb_device_properties dvbsky_s960c_props = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\t.size_of_priv = sizeof(struct dvbsky_state),\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\t.generic_bulk_ctrl_endpoint_response = 0x81,\n\t.generic_bulk_ctrl_delay = DVBSKY_MSG_DELAY,\n\n\t.i2c_algo         = &dvbsky_i2c_algo,\n\t.frontend_attach  = dvbsky_s960c_attach,\n\t.frontend_detach  = dvbsky_frontend_detach,\n\t.init             = dvbsky_init,\n\t.get_rc_config    = dvbsky_get_rc_config,\n\t.streaming_ctrl   = dvbsky_streaming_ctrl,\n\t.identify_state\t  = dvbsky_identify_state,\n\t.read_mac_address = dvbsky_read_mac_addr,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t\t.stream = DVB_USB_STREAM_BULK(0x82, 8, 4096),\n\t\t}\n\t}\n};\n\nstatic struct dvb_usb_device_properties dvbsky_t680c_props = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\t.size_of_priv = sizeof(struct dvbsky_state),\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\t.generic_bulk_ctrl_endpoint_response = 0x81,\n\t.generic_bulk_ctrl_delay = DVBSKY_MSG_DELAY,\n\n\t.i2c_algo         = &dvbsky_i2c_algo,\n\t.frontend_attach  = dvbsky_t680c_attach,\n\t.frontend_detach  = dvbsky_frontend_detach,\n\t.init             = dvbsky_init,\n\t.get_rc_config    = dvbsky_get_rc_config,\n\t.streaming_ctrl   = dvbsky_streaming_ctrl,\n\t.identify_state\t  = dvbsky_identify_state,\n\t.read_mac_address = dvbsky_read_mac_addr,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t\t.stream = DVB_USB_STREAM_BULK(0x82, 8, 4096),\n\t\t}\n\t}\n};\n\nstatic struct dvb_usb_device_properties dvbsky_t330_props = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\t.size_of_priv = sizeof(struct dvbsky_state),\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\t.generic_bulk_ctrl_endpoint_response = 0x81,\n\t.generic_bulk_ctrl_delay = DVBSKY_MSG_DELAY,\n\n\t.i2c_algo         = &dvbsky_i2c_algo,\n\t.frontend_attach  = dvbsky_t330_attach,\n\t.frontend_detach  = dvbsky_frontend_detach,\n\t.init             = dvbsky_init,\n\t.get_rc_config    = dvbsky_get_rc_config,\n\t.streaming_ctrl   = dvbsky_streaming_ctrl,\n\t.identify_state\t  = dvbsky_identify_state,\n\t.read_mac_address = dvbsky_read_mac_addr,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t\t.stream = DVB_USB_STREAM_BULK(0x82, 8, 4096),\n\t\t}\n\t}\n};\n\nstatic struct dvb_usb_device_properties mygica_t230c_props = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\t.size_of_priv = sizeof(struct dvbsky_state),\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\t.generic_bulk_ctrl_endpoint_response = 0x81,\n\t.generic_bulk_ctrl_delay = DVBSKY_MSG_DELAY,\n\n\t.i2c_algo         = &dvbsky_i2c_algo,\n\t.frontend_attach  = dvbsky_mygica_t230c_attach,\n\t.frontend_detach  = dvbsky_frontend_detach,\n\t.init             = dvbsky_init,\n\t.get_rc_config    = dvbsky_get_rc_config,\n\t.streaming_ctrl   = dvbsky_streaming_ctrl,\n\t.identify_state\t  = dvbsky_identify_state,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t\t.stream = DVB_USB_STREAM_BULK(0x82, 8, 4096),\n\t\t}\n\t}\n};\n\nstatic const struct usb_device_id dvbsky_id_table[] = {\n\t{ DVB_USB_DEVICE(0x0572, 0x6831,\n\t\t&dvbsky_s960_props, \"DVBSky S960/S860\", RC_MAP_DVBSKY) },\n\t{ DVB_USB_DEVICE(0x0572, 0x960c,\n\t\t&dvbsky_s960c_props, \"DVBSky S960CI\", RC_MAP_DVBSKY) },\n\t{ DVB_USB_DEVICE(0x0572, 0x680c,\n\t\t&dvbsky_t680c_props, \"DVBSky T680CI\", RC_MAP_DVBSKY) },\n\t{ DVB_USB_DEVICE(0x0572, 0x0320,\n\t\t&dvbsky_t330_props, \"DVBSky T330\", RC_MAP_DVBSKY) },\n\t{ DVB_USB_DEVICE(USB_VID_TECHNOTREND,\n\t\tUSB_PID_TECHNOTREND_TVSTICK_CT2_4400,\n\t\t&dvbsky_t330_props, \"TechnoTrend TVStick CT2-4400\",\n\t\tRC_MAP_TT_1500) },\n\t{ DVB_USB_DEVICE(USB_VID_TECHNOTREND,\n\t\tUSB_PID_TECHNOTREND_CONNECT_CT2_4650_CI,\n\t\t&dvbsky_t680c_props, \"TechnoTrend TT-connect CT2-4650 CI\",\n\t\tRC_MAP_TT_1500) },\n\t{ DVB_USB_DEVICE(USB_VID_TECHNOTREND,\n\t\tUSB_PID_TECHNOTREND_CONNECT_CT2_4650_CI_2,\n\t\t&dvbsky_t680c_props, \"TechnoTrend TT-connect CT2-4650 CI v1.1\",\n\t\tRC_MAP_TT_1500) },\n\t{ DVB_USB_DEVICE(USB_VID_TECHNOTREND,\n\t\tUSB_PID_TECHNOTREND_CONNECT_S2_4650_CI,\n\t\t&dvbsky_s960c_props, \"TechnoTrend TT-connect S2-4650 CI\",\n\t\tRC_MAP_TT_1500) },\n\t{ DVB_USB_DEVICE(USB_VID_TERRATEC,\n\t\tUSB_PID_TERRATEC_H7_3,\n\t\t&dvbsky_t680c_props, \"Terratec H7 Rev.4\",\n\t\tRC_MAP_TT_1500) },\n\t{ DVB_USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_S2_R4,\n\t\t&dvbsky_s960_props, \"Terratec Cinergy S2 Rev.4\",\n\t\tRC_MAP_DVBSKY) },\n\t{ DVB_USB_DEVICE(USB_VID_CONEXANT, USB_PID_MYGICA_T230,\n\t\t&mygica_t230c_props, \"MyGica Mini DVB-(T/T2/C) USB Stick T230\",\n\t\tRC_MAP_TOTAL_MEDIA_IN_HAND_02) },\n\t{ DVB_USB_DEVICE(USB_VID_CONEXANT, USB_PID_MYGICA_T230C,\n\t\t&mygica_t230c_props, \"MyGica Mini DVB-(T/T2/C) USB Stick T230C\",\n\t\tRC_MAP_TOTAL_MEDIA_IN_HAND_02) },\n\t{ DVB_USB_DEVICE(USB_VID_CONEXANT, USB_PID_MYGICA_T230C_LITE,\n\t\t&mygica_t230c_props, \"MyGica Mini DVB-(T/T2/C) USB Stick T230C Lite\",\n\t\tNULL) },\n\t{ DVB_USB_DEVICE(USB_VID_CONEXANT, USB_PID_MYGICA_T230C2,\n\t\t&mygica_t230c_props, \"MyGica Mini DVB-(T/T2/C) USB Stick T230C v2\",\n\t\tRC_MAP_TOTAL_MEDIA_IN_HAND_02) },\n\t{ DVB_USB_DEVICE(USB_VID_CONEXANT, USB_PID_MYGICA_T230C2_LITE,\n\t\t &mygica_t230c_props, \"MyGica Mini DVB-(T/T2/C) USB Stick T230C v2  Lite\",\n\t\t NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_CONEXANT, USB_PID_MYGICA_T230A,\n\t\t &mygica_t230c_props, \"MyGica Mini DVB-(T/T2/C) USB Stick T230A\",\n\t\t NULL) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, dvbsky_id_table);\n\nstatic struct usb_driver dvbsky_usb_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = dvbsky_id_table,\n\t.probe = dvb_usbv2_probe,\n\t.disconnect = dvb_usbv2_disconnect,\n\t.suspend = dvb_usbv2_suspend,\n\t.resume = dvb_usbv2_resume,\n\t.reset_resume = dvb_usbv2_reset_resume,\n\t.no_dynamic_id = 1,\n\t.soft_unbind = 1,\n};\n\nmodule_usb_driver(dvbsky_usb_driver);\n\nMODULE_AUTHOR(\"Max nibble <nibble.max@gmail.com>\");\nMODULE_DESCRIPTION(\"Driver for DVBSky USB\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}