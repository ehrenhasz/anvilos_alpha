{
  "module_name": "mxl111sf-gpio.c",
  "hash_id": "73ee6ee610ace271fc74b8217295c65dcaed51e935e1055ddd96636fcf08534c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/mxl111sf-gpio.c",
  "human_readable_source": "\n \n\n#include \"mxl111sf-gpio.h\"\n#include \"mxl111sf-i2c.h\"\n#include \"mxl111sf.h\"\n\n \n\n#define MXL_GPIO_MUX_REG_0 0x84\n#define MXL_GPIO_MUX_REG_1 0x89\n#define MXL_GPIO_MUX_REG_2 0x82\n\n#define MXL_GPIO_DIR_INPUT  0\n#define MXL_GPIO_DIR_OUTPUT 1\n\n\nstatic int mxl111sf_set_gpo_state(struct mxl111sf_state *state, u8 pin, u8 val)\n{\n\tint ret;\n\tu8 tmp;\n\n\tmxl_debug_adv(\"(%d, %d)\", pin, val);\n\n\tif ((pin > 0) && (pin < 8)) {\n\t\tret = mxl111sf_read_reg(state, 0x19, &tmp);\n\t\tif (mxl_fail(ret))\n\t\t\tgoto fail;\n\t\ttmp &= ~(1 << (pin - 1));\n\t\ttmp |= (val << (pin - 1));\n\t\tret = mxl111sf_write_reg(state, 0x19, tmp);\n\t\tif (mxl_fail(ret))\n\t\t\tgoto fail;\n\t} else if (pin <= 10) {\n\t\tif (pin == 0)\n\t\t\tpin += 7;\n\t\tret = mxl111sf_read_reg(state, 0x30, &tmp);\n\t\tif (mxl_fail(ret))\n\t\t\tgoto fail;\n\t\ttmp &= ~(1 << (pin - 3));\n\t\ttmp |= (val << (pin - 3));\n\t\tret = mxl111sf_write_reg(state, 0x30, tmp);\n\t\tif (mxl_fail(ret))\n\t\t\tgoto fail;\n\t} else\n\t\tret = -EINVAL;\nfail:\n\treturn ret;\n}\n\nstatic int mxl111sf_get_gpi_state(struct mxl111sf_state *state, u8 pin, u8 *val)\n{\n\tint ret;\n\tu8 tmp;\n\n\tmxl_debug(\"(0x%02x)\", pin);\n\n\t*val = 0;\n\n\tswitch (pin) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\t\tret = mxl111sf_read_reg(state, 0x23, &tmp);\n\t\tif (mxl_fail(ret))\n\t\t\tgoto fail;\n\t\t*val = (tmp >> (pin + 4)) & 0x01;\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\tcase 6:\n\tcase 7:\n\t\tret = mxl111sf_read_reg(state, 0x2f, &tmp);\n\t\tif (mxl_fail(ret))\n\t\t\tgoto fail;\n\t\t*val = (tmp >> pin) & 0x01;\n\t\tbreak;\n\tcase 8:\n\tcase 9:\n\tcase 10:\n\t\tret = mxl111sf_read_reg(state, 0x22, &tmp);\n\t\tif (mxl_fail(ret))\n\t\t\tgoto fail;\n\t\t*val = (tmp >> (pin - 3)) & 0x01;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;  \n\t}\nfail:\n\treturn ret;\n}\n\nstruct mxl_gpio_cfg {\n\tu8 pin;\n\tu8 dir;\n\tu8 val;\n};\n\nstatic int mxl111sf_config_gpio_pins(struct mxl111sf_state *state,\n\t\t\t\t     struct mxl_gpio_cfg *gpio_cfg)\n{\n\tint ret;\n\tu8 tmp;\n\n\tmxl_debug_adv(\"(%d, %d)\", gpio_cfg->pin, gpio_cfg->dir);\n\n\tswitch (gpio_cfg->pin) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\t\tret = mxl111sf_read_reg(state, MXL_GPIO_MUX_REG_0, &tmp);\n\t\tif (mxl_fail(ret))\n\t\t\tgoto fail;\n\t\ttmp &= ~(1 << (gpio_cfg->pin + 4));\n\t\ttmp |= (gpio_cfg->dir << (gpio_cfg->pin + 4));\n\t\tret = mxl111sf_write_reg(state, MXL_GPIO_MUX_REG_0, tmp);\n\t\tif (mxl_fail(ret))\n\t\t\tgoto fail;\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\tcase 6:\n\tcase 7:\n\t\tret = mxl111sf_read_reg(state, MXL_GPIO_MUX_REG_1, &tmp);\n\t\tif (mxl_fail(ret))\n\t\t\tgoto fail;\n\t\ttmp &= ~(1 << gpio_cfg->pin);\n\t\ttmp |= (gpio_cfg->dir << gpio_cfg->pin);\n\t\tret = mxl111sf_write_reg(state, MXL_GPIO_MUX_REG_1, tmp);\n\t\tif (mxl_fail(ret))\n\t\t\tgoto fail;\n\t\tbreak;\n\tcase 8:\n\tcase 9:\n\tcase 10:\n\t\tret = mxl111sf_read_reg(state, MXL_GPIO_MUX_REG_2, &tmp);\n\t\tif (mxl_fail(ret))\n\t\t\tgoto fail;\n\t\ttmp &= ~(1 << (gpio_cfg->pin - 3));\n\t\ttmp |= (gpio_cfg->dir << (gpio_cfg->pin - 3));\n\t\tret = mxl111sf_write_reg(state, MXL_GPIO_MUX_REG_2, tmp);\n\t\tif (mxl_fail(ret))\n\t\t\tgoto fail;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;  \n\t}\n\n\tret = (MXL_GPIO_DIR_OUTPUT == gpio_cfg->dir) ?\n\t\tmxl111sf_set_gpo_state(state,\n\t\t\t\t       gpio_cfg->pin, gpio_cfg->val) :\n\t\tmxl111sf_get_gpi_state(state,\n\t\t\t\t       gpio_cfg->pin, &gpio_cfg->val);\n\tmxl_fail(ret);\nfail:\n\treturn ret;\n}\n\nstatic int mxl111sf_hw_do_set_gpio(struct mxl111sf_state *state,\n\t\t\t\t   int gpio, int direction, int val)\n{\n\tstruct mxl_gpio_cfg gpio_config = {\n\t\t.pin = gpio,\n\t\t.dir = direction,\n\t\t.val = val,\n\t};\n\n\tmxl_debug(\"(%d, %d, %d)\", gpio, direction, val);\n\n\treturn mxl111sf_config_gpio_pins(state, &gpio_config);\n}\n\n \n\n#define PIN_MUX_MPEG_MODE_MASK          0x40    \n#define PIN_MUX_MPEG_PAR_EN_MASK        0x01    \n#define PIN_MUX_MPEG_SER_EN_MASK        0x02    \n#define PIN_MUX_MPG_IN_MUX_MASK         0x80    \n#define PIN_MUX_BT656_ENABLE_MASK       0x04    \n#define PIN_MUX_I2S_ENABLE_MASK         0x40    \n#define PIN_MUX_SPI_MODE_MASK           0x10    \n#define PIN_MUX_MCLK_EN_CTRL_MASK       0x10    \n#define PIN_MUX_MPSYN_EN_CTRL_MASK      0x20    \n#define PIN_MUX_MDVAL_EN_CTRL_MASK      0x40    \n#define PIN_MUX_MPERR_EN_CTRL_MASK      0x80    \n#define PIN_MUX_MDAT_EN_0_MASK          0x10    \n#define PIN_MUX_MDAT_EN_1_MASK          0x20    \n#define PIN_MUX_MDAT_EN_2_MASK          0x40    \n#define PIN_MUX_MDAT_EN_3_MASK          0x80    \n#define PIN_MUX_MDAT_EN_4_MASK          0x10    \n#define PIN_MUX_MDAT_EN_5_MASK          0x20    \n#define PIN_MUX_MDAT_EN_6_MASK          0x40    \n#define PIN_MUX_MDAT_EN_7_MASK          0x80    \n\nint mxl111sf_config_pin_mux_modes(struct mxl111sf_state *state,\n\t\t\t\t  enum mxl111sf_mux_config pin_mux_config)\n{\n\tu8 r12, r15, r17, r18, r3D, r82, r84, r89;\n\tint ret;\n\n\tmxl_debug(\"(%d)\", pin_mux_config);\n\n\tret = mxl111sf_read_reg(state, 0x17, &r17);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_read_reg(state, 0x18, &r18);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_read_reg(state, 0x12, &r12);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_read_reg(state, 0x15, &r15);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_read_reg(state, 0x82, &r82);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_read_reg(state, 0x84, &r84);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_read_reg(state, 0x89, &r89);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_read_reg(state, 0x3D, &r3D);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tswitch (pin_mux_config) {\n\tcase PIN_MUX_TS_OUT_PARALLEL:\n\t\t \n\t\tr17 |= PIN_MUX_MPEG_MODE_MASK;\n\t\t \n\t\tr18 |= PIN_MUX_MPEG_PAR_EN_MASK;\n\t\t \n\t\tr18 &= ~PIN_MUX_MPEG_SER_EN_MASK;\n\t\t \n\t\tr3D &= ~PIN_MUX_MPG_IN_MUX_MASK;\n\t\t \n\t\tr12 &= ~PIN_MUX_BT656_ENABLE_MASK;\n\t\t \n\t\tr15 &= ~PIN_MUX_I2S_ENABLE_MASK;\n\t\t \n\t\tr3D &= ~PIN_MUX_SPI_MODE_MASK;\n\t\t \n\t\tr82 |= PIN_MUX_MCLK_EN_CTRL_MASK;\n\t\t \n\t\tr82 |= PIN_MUX_MPERR_EN_CTRL_MASK;\n\t\t \n\t\tr82 |= PIN_MUX_MDVAL_EN_CTRL_MASK;\n\t\t \n\t\tr82 |= PIN_MUX_MPSYN_EN_CTRL_MASK;\n\t\t \n\t\tr84 |= 0xF0;\n\t\t \n\t\tr89 |= 0xF0;\n\t\tbreak;\n\tcase PIN_MUX_TS_OUT_SERIAL:\n\t\t \n\t\tr17 |= PIN_MUX_MPEG_MODE_MASK;\n\t\t \n\t\tr18 &= ~PIN_MUX_MPEG_PAR_EN_MASK;\n\t\t \n\t\tr18 |= PIN_MUX_MPEG_SER_EN_MASK;\n\t\t \n\t\tr3D &= ~PIN_MUX_MPG_IN_MUX_MASK;\n\t\t \n\t\tr12 &= ~PIN_MUX_BT656_ENABLE_MASK;\n\t\t \n\t\tr15 &= ~PIN_MUX_I2S_ENABLE_MASK;\n\t\t \n\t\tr3D &= ~PIN_MUX_SPI_MODE_MASK;\n\t\t \n\t\tr82 |= PIN_MUX_MCLK_EN_CTRL_MASK;\n\t\t \n\t\tr82 |= PIN_MUX_MPERR_EN_CTRL_MASK;\n\t\t \n\t\tr82 |= PIN_MUX_MDVAL_EN_CTRL_MASK;\n\t\t \n\t\tr82 |= PIN_MUX_MPSYN_EN_CTRL_MASK;\n\t\t \n\t\tr84 |= 0xF0;\n\t\t \n\t\tr89 |= 0xF0;\n\t\tbreak;\n\tcase PIN_MUX_GPIO_MODE:\n\t\t \n\t\tr17 &= ~PIN_MUX_MPEG_MODE_MASK;\n\t\t \n\t\tr18 &= ~PIN_MUX_MPEG_PAR_EN_MASK;\n\t\t \n\t\tr18 &= ~PIN_MUX_MPEG_SER_EN_MASK;\n\t\t \n\t\tr3D &= ~PIN_MUX_MPG_IN_MUX_MASK;\n\t\t \n\t\tr12 &= ~PIN_MUX_BT656_ENABLE_MASK;\n\t\t \n\t\tr15 &= ~PIN_MUX_I2S_ENABLE_MASK;\n\t\t \n\t\tr3D &= ~PIN_MUX_SPI_MODE_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MCLK_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MPERR_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MDVAL_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MPSYN_EN_CTRL_MASK;\n\t\t \n\t\tr84 &= 0x0F;\n\t\t \n\t\tr89 &= 0x0F;\n\t\tbreak;\n\tcase PIN_MUX_TS_SERIAL_IN_MODE_0:\n\t\t \n\t\tr17 &= ~PIN_MUX_MPEG_MODE_MASK;\n\t\t \n\t\tr18 &= ~PIN_MUX_MPEG_PAR_EN_MASK;\n\t\t \n\t\tr18 |= PIN_MUX_MPEG_SER_EN_MASK;\n\t\t \n\t\tr3D &= ~PIN_MUX_MPG_IN_MUX_MASK;\n\t\t \n\t\tr12 &= ~PIN_MUX_BT656_ENABLE_MASK;\n\t\t \n\t\tr15 &= ~PIN_MUX_I2S_ENABLE_MASK;\n\t\t \n\t\tr3D &= ~PIN_MUX_SPI_MODE_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MCLK_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MPERR_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MDVAL_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MPSYN_EN_CTRL_MASK;\n\t\t \n\t\tr84 &= 0x0F;\n\t\t \n\t\tr89 &= 0x0F;\n\t\tbreak;\n\tcase PIN_MUX_TS_SERIAL_IN_MODE_1:\n\t\t \n\t\tr17 &= ~PIN_MUX_MPEG_MODE_MASK;\n\t\t \n\t\tr18 &= ~PIN_MUX_MPEG_PAR_EN_MASK;\n\t\t \n\t\tr18 |= PIN_MUX_MPEG_SER_EN_MASK;\n\t\t \n\t\tr3D |= PIN_MUX_MPG_IN_MUX_MASK;\n\t\t \n\t\tr12 &= ~PIN_MUX_BT656_ENABLE_MASK;\n\t\t \n\t\tr15 &= ~PIN_MUX_I2S_ENABLE_MASK;\n\t\t \n\t\tr3D &= ~PIN_MUX_SPI_MODE_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MCLK_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MPERR_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MDVAL_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MPSYN_EN_CTRL_MASK;\n\t\t \n\t\tr84 &= 0x0F;\n\t\t \n\t\tr89 &= 0x0F;\n\t\tbreak;\n\tcase PIN_MUX_TS_SPI_IN_MODE_1:\n\t\t \n\t\tr17 &= ~PIN_MUX_MPEG_MODE_MASK;\n\t\t \n\t\tr18 &= ~PIN_MUX_MPEG_PAR_EN_MASK;\n\t\t \n\t\tr18 |= PIN_MUX_MPEG_SER_EN_MASK;\n\t\t \n\t\tr3D |= PIN_MUX_MPG_IN_MUX_MASK;\n\t\t \n\t\tr12 &= ~PIN_MUX_BT656_ENABLE_MASK;\n\t\t \n\t\tr15 |= PIN_MUX_I2S_ENABLE_MASK;\n\t\t \n\t\tr3D |= PIN_MUX_SPI_MODE_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MCLK_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MPERR_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MDVAL_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MPSYN_EN_CTRL_MASK;\n\t\t \n\t\tr84 &= 0x0F;\n\t\t \n\t\tr89 &= 0x0F;\n\t\tbreak;\n\tcase PIN_MUX_TS_SPI_IN_MODE_0:\n\t\t \n\t\tr17 &= ~PIN_MUX_MPEG_MODE_MASK;\n\t\t \n\t\tr18 &= ~PIN_MUX_MPEG_PAR_EN_MASK;\n\t\t \n\t\tr18 |= PIN_MUX_MPEG_SER_EN_MASK;\n\t\t \n\t\tr3D &= ~PIN_MUX_MPG_IN_MUX_MASK;\n\t\t \n\t\tr12 &= ~PIN_MUX_BT656_ENABLE_MASK;\n\t\t \n\t\tr15 |= PIN_MUX_I2S_ENABLE_MASK;\n\t\t \n\t\tr3D |= PIN_MUX_SPI_MODE_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MCLK_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MPERR_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MDVAL_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MPSYN_EN_CTRL_MASK;\n\t\t \n\t\tr84 &= 0x0F;\n\t\t \n\t\tr89 &= 0x0F;\n\t\tbreak;\n\tcase PIN_MUX_TS_PARALLEL_IN:\n\t\t \n\t\tr17 &= ~PIN_MUX_MPEG_MODE_MASK;\n\t\t \n\t\tr18 |= PIN_MUX_MPEG_PAR_EN_MASK;\n\t\t \n\t\tr18 &= ~PIN_MUX_MPEG_SER_EN_MASK;\n\t\t \n\t\tr3D &= ~PIN_MUX_MPG_IN_MUX_MASK;\n\t\t \n\t\tr12 &= ~PIN_MUX_BT656_ENABLE_MASK;\n\t\t \n\t\tr15 &= ~PIN_MUX_I2S_ENABLE_MASK;\n\t\t \n\t\tr3D &= ~PIN_MUX_SPI_MODE_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MCLK_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MPERR_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MDVAL_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MPSYN_EN_CTRL_MASK;\n\t\t \n\t\tr84 &= 0x0F;\n\t\t \n\t\tr89 &= 0x0F;\n\t\tbreak;\n\tcase PIN_MUX_BT656_I2S_MODE:\n\t\t \n\t\tr17 &= ~PIN_MUX_MPEG_MODE_MASK;\n\t\t \n\t\tr18 &= ~PIN_MUX_MPEG_PAR_EN_MASK;\n\t\t \n\t\tr18 &= ~PIN_MUX_MPEG_SER_EN_MASK;\n\t\t \n\t\tr3D &= ~PIN_MUX_MPG_IN_MUX_MASK;\n\t\t \n\t\tr12 |= PIN_MUX_BT656_ENABLE_MASK;\n\t\t \n\t\tr15 |= PIN_MUX_I2S_ENABLE_MASK;\n\t\t \n\t\tr3D &= ~PIN_MUX_SPI_MODE_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MCLK_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MPERR_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MDVAL_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MPSYN_EN_CTRL_MASK;\n\t\t \n\t\tr84 &= 0x0F;\n\t\t \n\t\tr89 &= 0x0F;\n\t\tbreak;\n\tcase PIN_MUX_DEFAULT:\n\tdefault:\n\t\t \n\t\tr17 |= PIN_MUX_MPEG_MODE_MASK;\n\t\t \n\t\tr18 &= ~PIN_MUX_MPEG_PAR_EN_MASK;\n\t\t \n\t\tr18 &= ~PIN_MUX_MPEG_SER_EN_MASK;\n\t\t \n\t\tr3D &= ~PIN_MUX_MPG_IN_MUX_MASK;\n\t\t \n\t\tr12 &= ~PIN_MUX_BT656_ENABLE_MASK;\n\t\t \n\t\tr15 &= ~PIN_MUX_I2S_ENABLE_MASK;\n\t\t \n\t\tr3D &= ~PIN_MUX_SPI_MODE_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MCLK_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MPERR_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MDVAL_EN_CTRL_MASK;\n\t\t \n\t\tr82 &= ~PIN_MUX_MPSYN_EN_CTRL_MASK;\n\t\t \n\t\tr84 &= 0x0F;\n\t\t \n\t\tr89 &= 0x0F;\n\t\tbreak;\n\t}\n\n\tret = mxl111sf_write_reg(state, 0x17, r17);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_write_reg(state, 0x18, r18);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_write_reg(state, 0x12, r12);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_write_reg(state, 0x15, r15);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_write_reg(state, 0x82, r82);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_write_reg(state, 0x84, r84);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_write_reg(state, 0x89, r89);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_write_reg(state, 0x3D, r3D);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\nfail:\n\treturn ret;\n}\n\n \n\nstatic int mxl111sf_hw_set_gpio(struct mxl111sf_state *state, int gpio, int val)\n{\n\treturn mxl111sf_hw_do_set_gpio(state, gpio, MXL_GPIO_DIR_OUTPUT, val);\n}\n\nstatic int mxl111sf_hw_gpio_initialize(struct mxl111sf_state *state)\n{\n\tu8 gpioval = 0x07;  \n\tint i, ret;\n\n\tmxl_debug(\"()\");\n\n\tfor (i = 3; i < 8; i++) {\n\t\tret = mxl111sf_hw_set_gpio(state, i, (gpioval >> i) & 0x01);\n\t\tif (mxl_fail(ret))\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n#define PCA9534_I2C_ADDR (0x40 >> 1)\nstatic int pca9534_set_gpio(struct mxl111sf_state *state, int gpio, int val)\n{\n\tu8 w[2] = { 1, 0 };\n\tu8 r = 0;\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = PCA9534_I2C_ADDR,\n\t\t  .flags = 0, .buf = w, .len = 1 },\n\t\t{ .addr = PCA9534_I2C_ADDR,\n\t\t  .flags = I2C_M_RD, .buf = &r, .len = 1 },\n\t};\n\n\tmxl_debug(\"(%d, %d)\", gpio, val);\n\n\t \n\ti2c_transfer(&state->d->i2c_adap, msg, 2);\n\n\t \n\tmsg[0].len = 2;\n#if 0\n\tw[0] = 1;\n#endif\n\tw[1] = r;\n\n\t \n\tw[1] &= ~(1 << gpio);\n\n\t \n\tw[1] |= ((val ? 1 : 0) << gpio);\n\n\t \n\ti2c_transfer(&state->d->i2c_adap, &msg[0], 1);\n\n\treturn 0;\n}\n\nstatic int pca9534_init_port_expander(struct mxl111sf_state *state)\n{\n\tu8 w[2] = { 1, 0x07 };  \n\n\tstruct i2c_msg msg = {\n\t\t.addr = PCA9534_I2C_ADDR,\n\t\t.flags = 0, .buf = w, .len = 2\n\t};\n\n\tmxl_debug(\"()\");\n\n\ti2c_transfer(&state->d->i2c_adap, &msg, 1);\n\n\t \n\tw[0] = 3;\n\tw[1] = 0;\n\n\ti2c_transfer(&state->d->i2c_adap, &msg, 1);\n\n\treturn 0;\n}\n\nint mxl111sf_set_gpio(struct mxl111sf_state *state, int gpio, int val)\n{\n\tmxl_debug(\"(%d, %d)\", gpio, val);\n\n\tswitch (state->gpio_port_expander) {\n\tdefault:\n\t\tmxl_printk(KERN_ERR,\n\t\t\t   \"gpio_port_expander undefined, assuming PCA9534\");\n\t\tfallthrough;\n\tcase mxl111sf_PCA9534:\n\t\treturn pca9534_set_gpio(state, gpio, val);\n\tcase mxl111sf_gpio_hw:\n\t\treturn mxl111sf_hw_set_gpio(state, gpio, val);\n\t}\n}\n\nstatic int mxl111sf_probe_port_expander(struct mxl111sf_state *state)\n{\n\tint ret;\n\tu8 w = 1;\n\tu8 r = 0;\n\tstruct i2c_msg msg[] = {\n\t\t{ .flags = 0,        .buf = &w, .len = 1 },\n\t\t{ .flags = I2C_M_RD, .buf = &r, .len = 1 },\n\t};\n\n\tmxl_debug(\"()\");\n\n\tmsg[0].addr = 0x70 >> 1;\n\tmsg[1].addr = 0x70 >> 1;\n\n\t \n\tret = i2c_transfer(&state->d->i2c_adap, msg, 2);\n\tif (ret == 2) {\n\t\tstate->port_expander_addr = msg[0].addr;\n\t\tstate->gpio_port_expander = mxl111sf_PCA9534;\n\t\tmxl_debug(\"found port expander at 0x%02x\",\n\t\t\t  state->port_expander_addr);\n\t\treturn 0;\n\t}\n\n\tmsg[0].addr = 0x40 >> 1;\n\tmsg[1].addr = 0x40 >> 1;\n\n\tret = i2c_transfer(&state->d->i2c_adap, msg, 2);\n\tif (ret == 2) {\n\t\tstate->port_expander_addr = msg[0].addr;\n\t\tstate->gpio_port_expander = mxl111sf_PCA9534;\n\t\tmxl_debug(\"found port expander at 0x%02x\",\n\t\t\t  state->port_expander_addr);\n\t\treturn 0;\n\t}\n\tstate->port_expander_addr = 0xff;\n\tstate->gpio_port_expander = mxl111sf_gpio_hw;\n\tmxl_debug(\"using hardware gpio\");\n\treturn 0;\n}\n\nint mxl111sf_init_port_expander(struct mxl111sf_state *state)\n{\n\tmxl_debug(\"()\");\n\n\tif (0x00 == state->port_expander_addr)\n\t\tmxl111sf_probe_port_expander(state);\n\n\tswitch (state->gpio_port_expander) {\n\tdefault:\n\t\tmxl_printk(KERN_ERR,\n\t\t\t   \"gpio_port_expander undefined, assuming PCA9534\");\n\t\tfallthrough;\n\tcase mxl111sf_PCA9534:\n\t\treturn pca9534_init_port_expander(state);\n\tcase mxl111sf_gpio_hw:\n\t\treturn mxl111sf_hw_gpio_initialize(state);\n\t}\n}\n\n \n\nint mxl111sf_gpio_mode_switch(struct mxl111sf_state *state, unsigned int mode)\n{\n \n\tmxl_debug(\"(%d)\", mode);\n\n\tswitch (mode) {\n\tcase MXL111SF_GPIO_MOD_MH:\n\t\tmxl111sf_set_gpio(state, 4, 0);\n\t\tmxl111sf_set_gpio(state, 5, 0);\n\t\tmsleep(50);\n\t\tmxl111sf_set_gpio(state, 7, 1);\n\t\tmsleep(50);\n\t\tmxl111sf_set_gpio(state, 6, 1);\n\t\tmsleep(50);\n\n\t\tmxl111sf_set_gpio(state, 3, 0);\n\t\tbreak;\n\tcase MXL111SF_GPIO_MOD_ATSC:\n\t\tmxl111sf_set_gpio(state, 6, 0);\n\t\tmxl111sf_set_gpio(state, 7, 0);\n\t\tmsleep(50);\n\t\tmxl111sf_set_gpio(state, 5, 1);\n\t\tmsleep(50);\n\t\tmxl111sf_set_gpio(state, 4, 1);\n\t\tmsleep(50);\n\t\tmxl111sf_set_gpio(state, 3, 1);\n\t\tbreak;\n\tdefault:  \n\t\tmxl111sf_init_port_expander(state);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}