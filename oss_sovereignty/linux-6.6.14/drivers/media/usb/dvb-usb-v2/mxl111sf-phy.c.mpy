{
  "module_name": "mxl111sf-phy.c",
  "hash_id": "e673349868a715f5be684ce844ce7582ee26e50a23c9d8e03e137990afc424ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/mxl111sf-phy.c",
  "human_readable_source": "\n \n\n#include \"mxl111sf-phy.h\"\n#include \"mxl111sf-reg.h\"\n\nint mxl111sf_init_tuner_demod(struct mxl111sf_state *state)\n{\n\tstruct mxl111sf_reg_ctrl_info mxl_111_overwrite_default[] = {\n\t\t{0x07, 0xff, 0x0c},\n\t\t{0x58, 0xff, 0x9d},\n\t\t{0x09, 0xff, 0x00},\n\t\t{0x06, 0xff, 0x06},\n\t\t{0xc8, 0xff, 0x40},  \n\t\t{0x8d, 0x01, 0x01},  \n\t\t{0x32, 0xff, 0xac},  \n\t\t{0x42, 0xff, 0x43},  \n\t\t{0x74, 0xff, 0xc4},  \n\t\t{0x71, 0xff, 0xe6},  \n\t\t{0x83, 0xff, 0x64},  \n\t\t{0x85, 0xff, 0x64},  \n\t\t{0x88, 0xff, 0xf0},  \n\t\t{0x6f, 0xf0, 0xb0},  \n\t\t{0x00, 0xff, 0x01},  \n\t\t{0x81, 0xff, 0x11},  \n\t\t{0xf4, 0xff, 0x07},  \n\t\t{0xd4, 0x1f, 0x0f},  \n\t\t{0xd6, 0xff, 0x0c},  \n\t\t{0x00, 0xff, 0x00},  \n\t\t{0,    0,    0}\n\t};\n\n\tmxl_debug(\"()\");\n\n\treturn mxl111sf_ctrl_program_regs(state, mxl_111_overwrite_default);\n}\n\nint mxl1x1sf_soft_reset(struct mxl111sf_state *state)\n{\n\tint ret;\n\tmxl_debug(\"()\");\n\n\tret = mxl111sf_write_reg(state, 0xff, 0x00);  \n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_write_reg(state, 0x02, 0x01);  \n\tmxl_fail(ret);\nfail:\n\treturn ret;\n}\n\nint mxl1x1sf_set_device_mode(struct mxl111sf_state *state, int mode)\n{\n\tint ret;\n\n\tmxl_debug(\"(%s)\", MXL_SOC_MODE == mode ?\n\t\t\"MXL_SOC_MODE\" : \"MXL_TUNER_MODE\");\n\n\t \n\tret = mxl111sf_write_reg(state, 0x03,\n\t\t\t\t MXL_SOC_MODE == mode ? 0x01 : 0x00);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl111sf_write_reg_mask(state,\n\t\t\t\t      0x7d, 0x40, MXL_SOC_MODE == mode ?\n\t\t\t\t      0x00 :  \n\t\t\t\t      0x40);  \n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tstate->device_mode = mode;\nfail:\n\treturn ret;\n}\n\n \nint mxl1x1sf_top_master_ctrl(struct mxl111sf_state *state, int onoff)\n{\n\tmxl_debug(\"(%d)\", onoff);\n\n\treturn mxl111sf_write_reg(state, 0x01, onoff ? 0x01 : 0x00);\n}\n\nint mxl111sf_disable_656_port(struct mxl111sf_state *state)\n{\n\tmxl_debug(\"()\");\n\n\treturn mxl111sf_write_reg_mask(state, 0x12, 0x04, 0x00);\n}\n\nint mxl111sf_enable_usb_output(struct mxl111sf_state *state)\n{\n\tmxl_debug(\"()\");\n\n\treturn mxl111sf_write_reg_mask(state, 0x17, 0x40, 0x00);\n}\n\n \nint mxl111sf_config_mpeg_in(struct mxl111sf_state *state,\n\t\t\t    unsigned int parallel_serial,\n\t\t\t    unsigned int msb_lsb_1st,\n\t\t\t    unsigned int clock_phase,\n\t\t\t    unsigned int mpeg_valid_pol,\n\t\t\t    unsigned int mpeg_sync_pol)\n{\n\tint ret;\n\tu8 mode, tmp;\n\n\tmxl_debug(\"(%u,%u,%u,%u,%u)\", parallel_serial, msb_lsb_1st,\n\t\t  clock_phase, mpeg_valid_pol, mpeg_sync_pol);\n\n\t \n\tret = mxl111sf_write_reg(state, V6_PIN_MUX_MODE_REG, V6_ENABLE_PIN_MUX);\n\tmxl_fail(ret);\n\n\t \n\tmxl111sf_read_reg(state, V6_MPEG_IN_CLK_INV_REG, &mode);\n\n\tif (clock_phase == TSIF_NORMAL)\n\t\tmode &= ~V6_INVERTED_CLK_PHASE;\n\telse\n\t\tmode |= V6_INVERTED_CLK_PHASE;\n\n\tret = mxl111sf_write_reg(state, V6_MPEG_IN_CLK_INV_REG, mode);\n\tmxl_fail(ret);\n\n\t \n\tret = mxl111sf_read_reg(state, V6_MPEG_IN_CTRL_REG, &mode);\n\tmxl_fail(ret);\n\n\t \n\tif (parallel_serial == TSIF_INPUT_PARALLEL) {\n\t\t \n\t\tmode &= ~V6_MPEG_IN_DATA_SERIAL;\n\n\t\t \n\t\tmode |= V6_MPEG_IN_DATA_PARALLEL;\n\t} else {\n\t\t \n\t\tmode &= ~V6_MPEG_IN_DATA_PARALLEL;\n\n\t\t \n\t\tmode |= V6_MPEG_IN_DATA_SERIAL;\n\n\t\t \n\t\tret = mxl111sf_read_reg(state,\n\t\t\t\t\tV6_MPEG_INOUT_BIT_ORDER_CTRL_REG,\n\t\t\t\t\t&tmp);\n\t\tmxl_fail(ret);\n\n\t\tif (msb_lsb_1st == MPEG_SER_MSB_FIRST_ENABLED)\n\t\t\ttmp |= V6_MPEG_SER_MSB_FIRST;\n\t\telse\n\t\t\ttmp &= ~V6_MPEG_SER_MSB_FIRST;\n\n\t\tret = mxl111sf_write_reg(state,\n\t\t\t\t\t V6_MPEG_INOUT_BIT_ORDER_CTRL_REG,\n\t\t\t\t\t tmp);\n\t\tmxl_fail(ret);\n\t}\n\n\t \n\tif (mpeg_sync_pol == TSIF_NORMAL)\n\t\tmode &= ~V6_INVERTED_MPEG_SYNC;\n\telse\n\t\tmode |= V6_INVERTED_MPEG_SYNC;\n\n\t \n\tif (mpeg_valid_pol == 0)\n\t\tmode &= ~V6_INVERTED_MPEG_VALID;\n\telse\n\t\tmode |= V6_INVERTED_MPEG_VALID;\n\n\tret = mxl111sf_write_reg(state, V6_MPEG_IN_CTRL_REG, mode);\n\tmxl_fail(ret);\n\n\treturn ret;\n}\n\nint mxl111sf_init_i2s_port(struct mxl111sf_state *state, u8 sample_size)\n{\n\tstatic struct mxl111sf_reg_ctrl_info init_i2s[] = {\n\t\t{0x1b, 0xff, 0x1e},  \n\t\t{0x15, 0x60, 0x60},  \n\t\t{0x17, 0xe0, 0x20},  \n#if 0\n\t\t{0x12, 0x01, 0x00},  \n#endif\n\t\t{0x00, 0xff, 0x02},  \n\t\t{0x26, 0x0d, 0x0d},  \n\t\t{0x00, 0xff, 0x00},\n\t\t{0,    0,    0}\n\t};\n\tint ret;\n\n\tmxl_debug(\"(0x%02x)\", sample_size);\n\n\tret = mxl111sf_ctrl_program_regs(state, init_i2s);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl111sf_write_reg(state, V6_I2S_NUM_SAMPLES_REG, sample_size);\n\tmxl_fail(ret);\nfail:\n\treturn ret;\n}\n\nint mxl111sf_disable_i2s_port(struct mxl111sf_state *state)\n{\n\tstatic struct mxl111sf_reg_ctrl_info disable_i2s[] = {\n\t\t{0x15, 0x40, 0x00},\n\t\t{0,    0,    0}\n\t};\n\n\tmxl_debug(\"()\");\n\n\treturn mxl111sf_ctrl_program_regs(state, disable_i2s);\n}\n\nint mxl111sf_config_i2s(struct mxl111sf_state *state,\n\t\t\tu8 msb_start_pos, u8 data_width)\n{\n\tint ret;\n\tu8 tmp;\n\n\tmxl_debug(\"(0x%02x, 0x%02x)\", msb_start_pos, data_width);\n\n\tret = mxl111sf_read_reg(state, V6_I2S_STREAM_START_BIT_REG, &tmp);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\ttmp &= 0xe0;\n\ttmp |= msb_start_pos;\n\tret = mxl111sf_write_reg(state, V6_I2S_STREAM_START_BIT_REG, tmp);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl111sf_read_reg(state, V6_I2S_STREAM_END_BIT_REG, &tmp);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\ttmp &= 0xe0;\n\ttmp |= data_width;\n\tret = mxl111sf_write_reg(state, V6_I2S_STREAM_END_BIT_REG, tmp);\n\tmxl_fail(ret);\nfail:\n\treturn ret;\n}\n\nint mxl111sf_config_spi(struct mxl111sf_state *state, int onoff)\n{\n\tu8 val;\n\tint ret;\n\n\tmxl_debug(\"(%d)\", onoff);\n\n\tret = mxl111sf_write_reg(state, 0x00, 0x02);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl111sf_read_reg(state, V8_SPI_MODE_REG, &val);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tif (onoff)\n\t\tval |= 0x04;\n\telse\n\t\tval &= ~0x04;\n\n\tret = mxl111sf_write_reg(state, V8_SPI_MODE_REG, val);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl111sf_write_reg(state, 0x00, 0x00);\n\tmxl_fail(ret);\nfail:\n\treturn ret;\n}\n\nint mxl111sf_idac_config(struct mxl111sf_state *state,\n\t\t\t u8 control_mode, u8 current_setting,\n\t\t\t u8 current_value, u8 hysteresis_value)\n{\n\tint ret;\n\tu8 val;\n\t \n\tval = current_value;\n\n\tif (control_mode == IDAC_MANUAL_CONTROL) {\n\t\t \n\t\tval |= IDAC_MANUAL_CONTROL_BIT_MASK;\n\n\t\tif (current_setting == IDAC_CURRENT_SINKING_ENABLE)\n\t\t\t \n\t\t\tval |= IDAC_CURRENT_SINKING_BIT_MASK;\n\t\telse\n\t\t\t \n\t\t\tval &= ~IDAC_CURRENT_SINKING_BIT_MASK;\n\t} else {\n\t\t \n\t\tval &= ~IDAC_MANUAL_CONTROL_BIT_MASK;\n\n\t\t \n\t\tret = mxl111sf_write_reg(state, V6_IDAC_HYSTERESIS_REG,\n\t\t\t\t\t (hysteresis_value & 0x3F));\n\t\tmxl_fail(ret);\n\t}\n\n\tret = mxl111sf_write_reg(state, V6_IDAC_SETTINGS_REG, val);\n\tmxl_fail(ret);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}