{
  "module_name": "af9035.c",
  "hash_id": "ebee561601cd46533b03a5b02c6b8d8c281b4c12e649a9fc5d92a3048da0c86d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/af9035.c",
  "human_readable_source": "\n \n\n#include \"af9035.h\"\n\n \n#define MAX_XFER_SIZE  64\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic u16 af9035_checksum(const u8 *buf, size_t len)\n{\n\tsize_t i;\n\tu16 checksum = 0;\n\n\tfor (i = 1; i < len; i++) {\n\t\tif (i % 2)\n\t\t\tchecksum += buf[i] << 8;\n\t\telse\n\t\t\tchecksum += buf[i];\n\t}\n\tchecksum = ~checksum;\n\n\treturn checksum;\n}\n\nstatic int af9035_ctrl_msg(struct dvb_usb_device *d, struct usb_req *req)\n{\n#define REQ_HDR_LEN 4  \n#define ACK_HDR_LEN 3  \n#define CHECKSUM_LEN 2\n#define USB_TIMEOUT 2000\n\tstruct state *state = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\tint ret, wlen, rlen;\n\tu16 checksum, tmp_checksum;\n\n\tmutex_lock(&d->usb_mutex);\n\n\t \n\tif (req->wlen > (BUF_LEN - REQ_HDR_LEN - CHECKSUM_LEN) ||\n\t\t\treq->rlen > (BUF_LEN - ACK_HDR_LEN - CHECKSUM_LEN)) {\n\t\tdev_err(&intf->dev, \"too much data wlen=%d rlen=%d\\n\",\n\t\t\treq->wlen, req->rlen);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tstate->buf[0] = REQ_HDR_LEN + req->wlen + CHECKSUM_LEN - 1;\n\tstate->buf[1] = req->mbox;\n\tstate->buf[2] = req->cmd;\n\tstate->buf[3] = state->seq++;\n\tmemcpy(&state->buf[REQ_HDR_LEN], req->wbuf, req->wlen);\n\n\twlen = REQ_HDR_LEN + req->wlen + CHECKSUM_LEN;\n\trlen = ACK_HDR_LEN + req->rlen + CHECKSUM_LEN;\n\n\t \n\tchecksum = af9035_checksum(state->buf, state->buf[0] - 1);\n\tstate->buf[state->buf[0] - 1] = (checksum >> 8);\n\tstate->buf[state->buf[0] - 0] = (checksum & 0xff);\n\n\t \n\tif (req->cmd == CMD_FW_DL)\n\t\trlen = 0;\n\n\tret = dvb_usbv2_generic_rw_locked(d,\n\t\t\tstate->buf, wlen, state->buf, rlen);\n\tif (ret)\n\t\tgoto exit;\n\n\t \n\tif (req->cmd == CMD_FW_DL)\n\t\tgoto exit;\n\n\t \n\tchecksum = af9035_checksum(state->buf, rlen - 2);\n\ttmp_checksum = (state->buf[rlen - 2] << 8) | state->buf[rlen - 1];\n\tif (tmp_checksum != checksum) {\n\t\tdev_err(&intf->dev, \"command=%02x checksum mismatch (%04x != %04x)\\n\",\n\t\t\treq->cmd, tmp_checksum, checksum);\n\t\tret = -EIO;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (state->buf[2]) {\n\t\t \n\t\tif (req->cmd == CMD_IR_GET || state->buf[2] == 1) {\n\t\t\tret = 1;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tdev_dbg(&intf->dev, \"command=%02x failed fw error=%d\\n\",\n\t\t\treq->cmd, state->buf[2]);\n\t\tret = -EIO;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (req->rlen)\n\t\tmemcpy(req->rbuf, &state->buf[ACK_HDR_LEN], req->rlen);\nexit:\n\tmutex_unlock(&d->usb_mutex);\n\treturn ret;\n}\n\n \nstatic int af9035_wr_regs(struct dvb_usb_device *d, u32 reg, u8 *val, int len)\n{\n\tstruct usb_interface *intf = d->intf;\n\tu8 wbuf[MAX_XFER_SIZE];\n\tu8 mbox = (reg >> 16) & 0xff;\n\tstruct usb_req req = { CMD_MEM_WR, mbox, 6 + len, wbuf, 0, NULL };\n\n\tif (6 + len > sizeof(wbuf)) {\n\t\tdev_warn(&intf->dev, \"i2c wr: len=%d is too big!\\n\", len);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\twbuf[0] = len;\n\twbuf[1] = 2;\n\twbuf[2] = 0;\n\twbuf[3] = 0;\n\twbuf[4] = (reg >> 8) & 0xff;\n\twbuf[5] = (reg >> 0) & 0xff;\n\tmemcpy(&wbuf[6], val, len);\n\n\treturn af9035_ctrl_msg(d, &req);\n}\n\n \nstatic int af9035_rd_regs(struct dvb_usb_device *d, u32 reg, u8 *val, int len)\n{\n\tu8 wbuf[] = { len, 2, 0, 0, (reg >> 8) & 0xff, reg & 0xff };\n\tu8 mbox = (reg >> 16) & 0xff;\n\tstruct usb_req req = { CMD_MEM_RD, mbox, sizeof(wbuf), wbuf, len, val };\n\n\treturn af9035_ctrl_msg(d, &req);\n}\n\n \nstatic int af9035_wr_reg(struct dvb_usb_device *d, u32 reg, u8 val)\n{\n\treturn af9035_wr_regs(d, reg, &val, 1);\n}\n\n \nstatic int af9035_rd_reg(struct dvb_usb_device *d, u32 reg, u8 *val)\n{\n\treturn af9035_rd_regs(d, reg, val, 1);\n}\n\n \nstatic int af9035_wr_reg_mask(struct dvb_usb_device *d, u32 reg, u8 val,\n\t\tu8 mask)\n{\n\tint ret;\n\tu8 tmp;\n\n\t \n\tif (mask != 0xff) {\n\t\tret = af9035_rd_regs(d, reg, &tmp, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval &= mask;\n\t\ttmp &= ~mask;\n\t\tval |= tmp;\n\t}\n\n\treturn af9035_wr_regs(d, reg, &val, 1);\n}\n\nstatic int af9035_add_i2c_dev(struct dvb_usb_device *d, const char *type,\n\t\tu8 addr, void *platform_data, struct i2c_adapter *adapter)\n{\n\tint ret, num;\n\tstruct state *state = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\tstruct i2c_client *client;\n\tstruct i2c_board_info board_info = {\n\t\t.addr = addr,\n\t\t.platform_data = platform_data,\n\t};\n\n\tstrscpy(board_info.type, type, I2C_NAME_SIZE);\n\n\t \n\tfor (num = 0; num < AF9035_I2C_CLIENT_MAX; num++) {\n\t\tif (state->i2c_client[num] == NULL)\n\t\t\tbreak;\n\t}\n\n\tdev_dbg(&intf->dev, \"num=%d\\n\", num);\n\n\tif (num == AF9035_I2C_CLIENT_MAX) {\n\t\tdev_err(&intf->dev, \"I2C client out of index\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\trequest_module(\"%s\", board_info.type);\n\n\t \n\tclient = i2c_new_client_device(adapter, &board_info);\n\tif (!i2c_client_has_driver(client)) {\n\t\tdev_err(&intf->dev, \"failed to bind i2c device to %s driver\\n\", type);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t \n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tstate->i2c_client[num] = client;\n\treturn 0;\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void af9035_del_i2c_dev(struct dvb_usb_device *d)\n{\n\tint num;\n\tstruct state *state = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\tstruct i2c_client *client;\n\n\t \n\tnum = AF9035_I2C_CLIENT_MAX;\n\twhile (num--) {\n\t\tif (state->i2c_client[num] != NULL)\n\t\t\tbreak;\n\t}\n\n\tdev_dbg(&intf->dev, \"num=%d\\n\", num);\n\n\tif (num == -1) {\n\t\tdev_err(&intf->dev, \"I2C client out of index\\n\");\n\t\tgoto err;\n\t}\n\n\tclient = state->i2c_client[num];\n\n\t \n\tmodule_put(client->dev.driver->owner);\n\n\t \n\ti2c_unregister_device(client);\n\n\tstate->i2c_client[num] = NULL;\n\treturn;\nerr:\n\tdev_dbg(&intf->dev, \"failed\\n\");\n}\n\nstatic int af9035_i2c_master_xfer(struct i2c_adapter *adap,\n\t\tstruct i2c_msg msg[], int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstruct state *state = d_to_priv(d);\n\tint ret;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\t \n#define AF9035_IS_I2C_XFER_WRITE_READ(_msg, _num) \\\n\t(_num == 2 && !(_msg[0].flags & I2C_M_RD) && (_msg[1].flags & I2C_M_RD))\n#define AF9035_IS_I2C_XFER_WRITE(_msg, _num) \\\n\t(_num == 1 && !(_msg[0].flags & I2C_M_RD))\n#define AF9035_IS_I2C_XFER_READ(_msg, _num) \\\n\t(_num == 1 && (_msg[0].flags & I2C_M_RD))\n\n\tif (AF9035_IS_I2C_XFER_WRITE_READ(msg, num)) {\n\t\tif (msg[0].len > 40 || msg[1].len > 40) {\n\t\t\t \n\t\t\tret = -EOPNOTSUPP;\n\t\t} else if ((msg[0].addr == state->af9033_i2c_addr[0]) ||\n\t\t\t   (msg[0].addr == state->af9033_i2c_addr[1])) {\n\t\t\tif (msg[0].len < 3 || msg[1].len < 1) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\t \n\t\t\tu32 reg = msg[0].buf[0] << 16 | msg[0].buf[1] << 8 |\n\t\t\t\t\tmsg[0].buf[2];\n\n\t\t\tif (msg[0].addr == state->af9033_i2c_addr[1])\n\t\t\t\treg |= 0x100000;\n\n\t\t\tret = af9035_rd_regs(d, reg, &msg[1].buf[0],\n\t\t\t\t\tmsg[1].len);\n\t\t} else if (state->no_read) {\n\t\t\tmemset(msg[1].buf, 0, msg[1].len);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t \n\t\t\tu8 buf[MAX_XFER_SIZE];\n\t\t\tstruct usb_req req = { CMD_I2C_RD, 0, 5 + msg[0].len,\n\t\t\t\t\tbuf, msg[1].len, msg[1].buf };\n\n\t\t\tif (state->chip_type == 0x9306) {\n\t\t\t\treq.cmd = CMD_GENERIC_I2C_RD;\n\t\t\t\treq.wlen = 3 + msg[0].len;\n\t\t\t}\n\t\t\treq.mbox |= ((msg[0].addr & 0x80)  >>  3);\n\n\t\t\tbuf[0] = msg[1].len;\n\t\t\tif (state->chip_type == 0x9306) {\n\t\t\t\tbuf[1] = 0x03;  \n\t\t\t\tbuf[2] = msg[0].addr << 1;\n\t\t\t\tmemcpy(&buf[3], msg[0].buf, msg[0].len);\n\t\t\t} else {\n\t\t\t\tbuf[1] = msg[0].addr << 1;\n\t\t\t\tbuf[3] = 0x00;  \n\t\t\t\tbuf[4] = 0x00;  \n\n\t\t\t\t \n\t\t\t\tif (msg[0].len > 2) {\n\t\t\t\t\tbuf[2] = 0x00;  \n\t\t\t\t\tmemcpy(&buf[5], msg[0].buf, msg[0].len);\n\n\t\t\t\t \n\t\t\t\t} else {\n\t\t\t\t\treq.wlen = 5;\n\t\t\t\t\tbuf[2] = msg[0].len;\n\t\t\t\t\tif (msg[0].len == 2) {\n\t\t\t\t\t\tbuf[3] = msg[0].buf[0];\n\t\t\t\t\t\tbuf[4] = msg[0].buf[1];\n\t\t\t\t\t} else if (msg[0].len == 1) {\n\t\t\t\t\t\tbuf[4] = msg[0].buf[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = af9035_ctrl_msg(d, &req);\n\t\t}\n\t} else if (AF9035_IS_I2C_XFER_WRITE(msg, num)) {\n\t\tif (msg[0].len > 40) {\n\t\t\t \n\t\t\tret = -EOPNOTSUPP;\n\t\t} else if ((msg[0].addr == state->af9033_i2c_addr[0]) ||\n\t\t\t   (msg[0].addr == state->af9033_i2c_addr[1])) {\n\t\t\tif (msg[0].len < 3) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\t \n\t\t\tu32 reg = msg[0].buf[0] << 16 | msg[0].buf[1] << 8 |\n\t\t\t\t\tmsg[0].buf[2];\n\n\t\t\tif (msg[0].addr == state->af9033_i2c_addr[1])\n\t\t\t\treg |= 0x100000;\n\n\t\t\tret = af9035_wr_regs(d, reg, &msg[0].buf[3], msg[0].len - 3);\n\t\t} else {\n\t\t\t \n\t\t\tu8 buf[MAX_XFER_SIZE];\n\t\t\tstruct usb_req req = { CMD_I2C_WR, 0, 5 + msg[0].len,\n\t\t\t\t\tbuf, 0, NULL };\n\n\t\t\tif (state->chip_type == 0x9306) {\n\t\t\t\treq.cmd = CMD_GENERIC_I2C_WR;\n\t\t\t\treq.wlen = 3 + msg[0].len;\n\t\t\t}\n\n\t\t\treq.mbox |= ((msg[0].addr & 0x80)  >>  3);\n\t\t\tbuf[0] = msg[0].len;\n\t\t\tif (state->chip_type == 0x9306) {\n\t\t\t\tbuf[1] = 0x03;  \n\t\t\t\tbuf[2] = msg[0].addr << 1;\n\t\t\t\tmemcpy(&buf[3], msg[0].buf, msg[0].len);\n\t\t\t} else {\n\t\t\t\tbuf[1] = msg[0].addr << 1;\n\t\t\t\tbuf[2] = 0x00;  \n\t\t\t\tbuf[3] = 0x00;  \n\t\t\t\tbuf[4] = 0x00;  \n\t\t\t\tmemcpy(&buf[5], msg[0].buf, msg[0].len);\n\t\t\t}\n\t\t\tret = af9035_ctrl_msg(d, &req);\n\t\t}\n\t} else if (AF9035_IS_I2C_XFER_READ(msg, num)) {\n\t\tif (msg[0].len > 40) {\n\t\t\t \n\t\t\tret = -EOPNOTSUPP;\n\t\t} else if (state->no_read) {\n\t\t\tmemset(msg[0].buf, 0, msg[0].len);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t \n\t\t\tu8 buf[5];\n\t\t\tstruct usb_req req = { CMD_I2C_RD, 0, sizeof(buf),\n\t\t\t\t\t\tbuf, msg[0].len, msg[0].buf };\n\n\t\t\tif (state->chip_type == 0x9306) {\n\t\t\t\treq.cmd = CMD_GENERIC_I2C_RD;\n\t\t\t\treq.wlen = 3;\n\t\t\t}\n\t\t\treq.mbox |= ((msg[0].addr & 0x80)  >>  3);\n\t\t\tbuf[0] = msg[0].len;\n\t\t\tif (state->chip_type == 0x9306) {\n\t\t\t\tbuf[1] = 0x03;  \n\t\t\t\tbuf[2] = msg[0].addr << 1;\n\t\t\t} else {\n\t\t\t\tbuf[1] = msg[0].addr << 1;\n\t\t\t\tbuf[2] = 0x00;  \n\t\t\t\tbuf[3] = 0x00;  \n\t\t\t\tbuf[4] = 0x00;  \n\t\t\t}\n\t\t\tret = af9035_ctrl_msg(d, &req);\n\t\t}\n\t} else {\n\t\t \n\t\tret = -EOPNOTSUPP;\n\t}\n\nunlock:\n\tmutex_unlock(&d->i2c_mutex);\n\n\tif (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn num;\n}\n\nstatic u32 af9035_i2c_functionality(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm af9035_i2c_algo = {\n\t.master_xfer = af9035_i2c_master_xfer,\n\t.functionality = af9035_i2c_functionality,\n};\n\nstatic int af9035_identify_state(struct dvb_usb_device *d, const char **name)\n{\n\tstruct state *state = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\tint ret, i, ts_mode_invalid;\n\tunsigned int utmp, eeprom_addr;\n\tu8 tmp;\n\tu8 wbuf[1] = { 1 };\n\tu8 rbuf[4];\n\tstruct usb_req req = { CMD_FW_QUERYINFO, 0, sizeof(wbuf), wbuf,\n\t\t\tsizeof(rbuf), rbuf };\n\n\tret = af9035_rd_regs(d, 0x1222, rbuf, 3);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tstate->chip_version = rbuf[0];\n\tstate->chip_type = rbuf[2] << 8 | rbuf[1] << 0;\n\n\tret = af9035_rd_reg(d, 0x384f, &state->prechip_version);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tdev_info(&intf->dev, \"prechip_version=%02x chip_version=%02x chip_type=%04x\\n\",\n\t\t state->prechip_version, state->chip_version, state->chip_type);\n\n\tif (state->chip_type == 0x9135) {\n\t\tif (state->chip_version == 0x02) {\n\t\t\t*name = AF9035_FIRMWARE_IT9135_V2;\n\t\t\tutmp = 0x00461d;\n\t\t} else {\n\t\t\t*name = AF9035_FIRMWARE_IT9135_V1;\n\t\t\tutmp = 0x00461b;\n\t\t}\n\n\t\t \n\t\tret = af9035_rd_reg(d, utmp, &tmp);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tif (tmp == 0x00) {\n\t\t\tdev_dbg(&intf->dev, \"no eeprom\\n\");\n\t\t\tstate->no_eeprom = true;\n\t\t\tgoto check_firmware_status;\n\t\t}\n\n\t\teeprom_addr = EEPROM_BASE_IT9135;\n\t} else if (state->chip_type == 0x9306) {\n\t\t*name = AF9035_FIRMWARE_IT9303;\n\t\tstate->no_eeprom = true;\n\t\tgoto check_firmware_status;\n\t} else {\n\t\t*name = AF9035_FIRMWARE_AF9035;\n\t\teeprom_addr = EEPROM_BASE_AF9035;\n\t}\n\n\t \n\tfor (i = 0; i < 256; i += 32) {\n\t\tret = af9035_rd_regs(d, eeprom_addr + i, &state->eeprom[i], 32);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tdev_dbg(&intf->dev, \"eeprom dump:\\n\");\n\tfor (i = 0; i < 256; i += 16)\n\t\tdev_dbg(&intf->dev, \"%*ph\\n\", 16, &state->eeprom[i]);\n\n\t \n\ttmp = state->eeprom[EEPROM_TS_MODE];\n\tts_mode_invalid = 0;\n\tswitch (tmp) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\tstate->dual_mode = true;\n\t\tbreak;\n\tcase 5:\n\t\tif (state->chip_type != 0x9135 && state->chip_type != 0x9306)\n\t\t\tstate->dual_mode = true;\t \n\t\telse\n\t\t\tts_mode_invalid = 1;\n\t\tbreak;\n\tdefault:\n\t\tts_mode_invalid = 1;\n\t}\n\n\tdev_dbg(&intf->dev, \"ts mode=%d dual mode=%d\\n\", tmp, state->dual_mode);\n\n\tif (ts_mode_invalid)\n\t\tdev_info(&intf->dev, \"ts mode=%d not supported, defaulting to single tuner mode!\", tmp);\n\ncheck_firmware_status:\n\tret = af9035_ctrl_msg(d, &req);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tdev_dbg(&intf->dev, \"reply=%*ph\\n\", 4, rbuf);\n\tif (rbuf[0] || rbuf[1] || rbuf[2] || rbuf[3])\n\t\tret = WARM;\n\telse\n\t\tret = COLD;\n\n\treturn ret;\n\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int af9035_download_firmware_old(struct dvb_usb_device *d,\n\t\tconst struct firmware *fw)\n{\n\tstruct usb_interface *intf = d->intf;\n\tint ret, i, j, len;\n\tu8 wbuf[1];\n\tstruct usb_req req = { 0, 0, 0, NULL, 0, NULL };\n\tstruct usb_req req_fw_dl = { CMD_FW_DL, 0, 0, wbuf, 0, NULL };\n\tu8 hdr_core;\n\tu16 hdr_addr, hdr_data_len, hdr_checksum;\n\t#define MAX_DATA 58\n\t#define HDR_SIZE 7\n\n\t \n\n\tfor (i = fw->size; i > HDR_SIZE;) {\n\t\thdr_core = fw->data[fw->size - i + 0];\n\t\thdr_addr = fw->data[fw->size - i + 1] << 8;\n\t\thdr_addr |= fw->data[fw->size - i + 2] << 0;\n\t\thdr_data_len = fw->data[fw->size - i + 3] << 8;\n\t\thdr_data_len |= fw->data[fw->size - i + 4] << 0;\n\t\thdr_checksum = fw->data[fw->size - i + 5] << 8;\n\t\thdr_checksum |= fw->data[fw->size - i + 6] << 0;\n\n\t\tdev_dbg(&intf->dev, \"core=%d addr=%04x data_len=%d checksum=%04x\\n\",\n\t\t\thdr_core, hdr_addr, hdr_data_len, hdr_checksum);\n\n\t\tif (((hdr_core != 1) && (hdr_core != 2)) ||\n\t\t\t\t(hdr_data_len > i)) {\n\t\t\tdev_dbg(&intf->dev, \"bad firmware\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\treq.cmd = CMD_FW_DL_BEGIN;\n\t\tret = af9035_ctrl_msg(d, &req);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\t \n\t\tfor (j = HDR_SIZE + hdr_data_len; j > 0; j -= MAX_DATA) {\n\t\t\tlen = j;\n\t\t\tif (len > MAX_DATA)\n\t\t\t\tlen = MAX_DATA;\n\t\t\treq_fw_dl.wlen = len;\n\t\t\treq_fw_dl.wbuf = (u8 *) &fw->data[fw->size - i +\n\t\t\t\t\tHDR_SIZE + hdr_data_len - j];\n\t\t\tret = af9035_ctrl_msg(d, &req_fw_dl);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\treq.cmd = CMD_FW_DL_END;\n\t\tret = af9035_ctrl_msg(d, &req);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\ti -= hdr_data_len + HDR_SIZE;\n\n\t\tdev_dbg(&intf->dev, \"data uploaded=%zu\\n\", fw->size - i);\n\t}\n\n\t \n\tif (i)\n\t\tdev_warn(&intf->dev, \"bad firmware\\n\");\n\n\treturn 0;\n\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int af9035_download_firmware_new(struct dvb_usb_device *d,\n\t\tconst struct firmware *fw)\n{\n\tstruct usb_interface *intf = d->intf;\n\tint ret, i, i_prev;\n\tstruct usb_req req_fw_dl = { CMD_FW_SCATTER_WR, 0, 0, NULL, 0, NULL };\n\t#define HDR_SIZE 7\n\n\t \n\tfor (i = HDR_SIZE, i_prev = 0; i <= fw->size; i++) {\n\t\tif (i == fw->size ||\n\t\t\t\t(fw->data[i + 0] == 0x03 &&\n\t\t\t\t(fw->data[i + 1] == 0x00 ||\n\t\t\t\tfw->data[i + 1] == 0x01) &&\n\t\t\t\tfw->data[i + 2] == 0x00)) {\n\t\t\treq_fw_dl.wlen = i - i_prev;\n\t\t\treq_fw_dl.wbuf = (u8 *) &fw->data[i_prev];\n\t\t\ti_prev = i;\n\t\t\tret = af9035_ctrl_msg(d, &req_fw_dl);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\n\t\t\tdev_dbg(&intf->dev, \"data uploaded=%d\\n\", i);\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int af9035_download_firmware(struct dvb_usb_device *d,\n\t\tconst struct firmware *fw)\n{\n\tstruct usb_interface *intf = d->intf;\n\tstruct state *state = d_to_priv(d);\n\tint ret;\n\tu8 wbuf[1];\n\tu8 rbuf[4];\n\tu8 tmp;\n\tstruct usb_req req = { 0, 0, 0, NULL, 0, NULL };\n\tstruct usb_req req_fw_ver = { CMD_FW_QUERYINFO, 0, 1, wbuf, 4, rbuf };\n\n\tdev_dbg(&intf->dev, \"\\n\");\n\n\t \n\tif (state->dual_mode) {\n\t\t \n\t\tret = af9035_wr_reg_mask(d, 0x00d8b0, 0x01, 0x01);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tret = af9035_wr_reg_mask(d, 0x00d8b1, 0x01, 0x01);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tret = af9035_wr_reg_mask(d, 0x00d8af, 0x00, 0x01);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tusleep_range(10000, 50000);\n\n\t\tret = af9035_wr_reg_mask(d, 0x00d8af, 0x01, 0x01);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\t \n\t\ttmp = state->eeprom[EEPROM_2ND_DEMOD_ADDR];\n\n\t\t \n\t\tif (!tmp)\n\t\t\ttmp = 0x1d << 1;  \n\n\t\tif ((state->chip_type == 0x9135) ||\n\t\t\t\t(state->chip_type == 0x9306)) {\n\t\t\tret = af9035_wr_reg(d, 0x004bfb, tmp);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t} else {\n\t\t\tret = af9035_wr_reg(d, 0x00417f, tmp);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\n\t\t\t \n\t\t\tret = af9035_wr_reg_mask(d, 0x00d81a, 0x01, 0x01);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (fw->data[0] == 0x01)\n\t\tret = af9035_download_firmware_old(d, fw);\n\telse\n\t\tret = af9035_download_firmware_new(d, fw);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\treq.cmd = CMD_FW_BOOT;\n\tret = af9035_ctrl_msg(d, &req);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\twbuf[0] = 1;\n\tret = af9035_ctrl_msg(d, &req_fw_ver);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tif (!(rbuf[0] || rbuf[1] || rbuf[2] || rbuf[3])) {\n\t\tdev_err(&intf->dev, \"firmware did not run\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tdev_info(&intf->dev, \"firmware version=%d.%d.%d.%d\",\n\t\t rbuf[0], rbuf[1], rbuf[2], rbuf[3]);\n\n\treturn 0;\n\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int af9035_read_config(struct dvb_usb_device *d)\n{\n\tstruct usb_interface *intf = d->intf;\n\tstruct state *state = d_to_priv(d);\n\tint ret, i;\n\tu8 tmp;\n\tu16 tmp16;\n\n\t \n\tstate->af9033_i2c_addr[0] = 0x1c;\n\tstate->af9033_i2c_addr[1] = 0x1d;\n\tstate->af9033_config[0].adc_multiplier = AF9033_ADC_MULTIPLIER_2X;\n\tstate->af9033_config[1].adc_multiplier = AF9033_ADC_MULTIPLIER_2X;\n\tstate->af9033_config[0].ts_mode = AF9033_TS_MODE_USB;\n\tstate->af9033_config[1].ts_mode = AF9033_TS_MODE_SERIAL;\n\tstate->it930x_addresses = 0;\n\n\tif (state->chip_type == 0x9135) {\n\t\t \n\t\tstate->af9033_config[0].dyn0_clk = true;\n\t\tstate->af9033_config[1].dyn0_clk = true;\n\n\t\tif (state->chip_version == 0x02) {\n\t\t\tstate->af9033_config[0].tuner = AF9033_TUNER_IT9135_60;\n\t\t\tstate->af9033_config[1].tuner = AF9033_TUNER_IT9135_60;\n\t\t} else {\n\t\t\tstate->af9033_config[0].tuner = AF9033_TUNER_IT9135_38;\n\t\t\tstate->af9033_config[1].tuner = AF9033_TUNER_IT9135_38;\n\t\t}\n\n\t\tif (state->no_eeprom) {\n\t\t\t \n\t\t\tstate->ir_mode = 0x05;\n\t\t\tstate->ir_type = 0x00;\n\n\t\t\tgoto skip_eeprom;\n\t\t}\n\t} else if (state->chip_type == 0x9306) {\n\t\t \n\t\tif ((le16_to_cpu(d->udev->descriptor.idVendor) == USB_VID_AVERMEDIA) &&\n\t\t    (le16_to_cpu(d->udev->descriptor.idProduct) == USB_PID_AVERMEDIA_TD310)) {\n\t\t\tstate->it930x_addresses = 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tstate->ir_mode = state->eeprom[EEPROM_IR_MODE];\n\tstate->ir_type = state->eeprom[EEPROM_IR_TYPE];\n\n\tif (state->dual_mode) {\n\t\t \n\t\ttmp = state->eeprom[EEPROM_2ND_DEMOD_ADDR];\n\t\tif (tmp)\n\t\t\tstate->af9033_i2c_addr[1] = tmp >> 1;\n\n\t\tdev_dbg(&intf->dev, \"2nd demod I2C addr=%02x\\n\",\n\t\t\tstate->af9033_i2c_addr[1]);\n\t}\n\n\tfor (i = 0; i < state->dual_mode + 1; i++) {\n\t\tunsigned int eeprom_offset = 0;\n\n\t\t \n\t\ttmp = state->eeprom[EEPROM_1_TUNER_ID + eeprom_offset];\n\t\tdev_dbg(&intf->dev, \"[%d]tuner=%02x\\n\", i, tmp);\n\n\t\t \n\t\tif (state->chip_type == 0x9135) {\n\t\t\tif (state->chip_version == 0x02) {\n\t\t\t\t \n\t\t\t\tswitch (tmp) {\n\t\t\t\tcase AF9033_TUNER_IT9135_60:\n\t\t\t\tcase AF9033_TUNER_IT9135_61:\n\t\t\t\tcase AF9033_TUNER_IT9135_62:\n\t\t\t\t\tstate->af9033_config[i].tuner = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tswitch (tmp) {\n\t\t\t\tcase AF9033_TUNER_IT9135_38:\n\t\t\t\tcase AF9033_TUNER_IT9135_51:\n\t\t\t\tcase AF9033_TUNER_IT9135_52:\n\t\t\t\t\tstate->af9033_config[i].tuner = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tstate->af9033_config[i].tuner = tmp;\n\t\t}\n\n\t\tif (state->af9033_config[i].tuner != tmp) {\n\t\t\tdev_info(&intf->dev, \"[%d] overriding tuner from %02x to %02x\\n\",\n\t\t\t\t i, tmp, state->af9033_config[i].tuner);\n\t\t}\n\n\t\tswitch (state->af9033_config[i].tuner) {\n\t\tcase AF9033_TUNER_TUA9001:\n\t\tcase AF9033_TUNER_FC0011:\n\t\tcase AF9033_TUNER_MXL5007T:\n\t\tcase AF9033_TUNER_TDA18218:\n\t\tcase AF9033_TUNER_FC2580:\n\t\tcase AF9033_TUNER_FC0012:\n\t\t\tstate->af9033_config[i].spec_inv = 1;\n\t\t\tbreak;\n\t\tcase AF9033_TUNER_IT9135_38:\n\t\tcase AF9033_TUNER_IT9135_51:\n\t\tcase AF9033_TUNER_IT9135_52:\n\t\tcase AF9033_TUNER_IT9135_60:\n\t\tcase AF9033_TUNER_IT9135_61:\n\t\tcase AF9033_TUNER_IT9135_62:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&intf->dev, \"tuner id=%02x not supported, please report!\",\n\t\t\t\t tmp);\n\t\t}\n\n\t\t \n\t\tif (i == 1)\n\t\t\tswitch (state->af9033_config[i].tuner) {\n\t\t\tcase AF9033_TUNER_FC0012:\n\t\t\tcase AF9033_TUNER_IT9135_38:\n\t\t\tcase AF9033_TUNER_IT9135_51:\n\t\t\tcase AF9033_TUNER_IT9135_52:\n\t\t\tcase AF9033_TUNER_IT9135_60:\n\t\t\tcase AF9033_TUNER_IT9135_61:\n\t\t\tcase AF9033_TUNER_IT9135_62:\n\t\t\tcase AF9033_TUNER_MXL5007T:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstate->dual_mode = false;\n\t\t\t\tdev_info(&intf->dev, \"driver does not support 2nd tuner and will disable it\");\n\t\t}\n\n\t\t \n\t\ttmp = state->eeprom[EEPROM_1_IF_L + eeprom_offset];\n\t\ttmp16 = tmp << 0;\n\t\ttmp = state->eeprom[EEPROM_1_IF_H + eeprom_offset];\n\t\ttmp16 |= tmp << 8;\n\t\tdev_dbg(&intf->dev, \"[%d]IF=%d\\n\", i, tmp16);\n\n\t\teeprom_offset += 0x10;  \n\t}\n\nskip_eeprom:\n\t \n\tret = af9035_rd_reg(d, 0x00d800, &tmp);\n\tif (ret < 0)\n\t\tgoto err;\n\n\ttmp = (tmp >> 0) & 0x0f;\n\n\tfor (i = 0; i < ARRAY_SIZE(state->af9033_config); i++) {\n\t\tif (state->chip_type == 0x9135)\n\t\t\tstate->af9033_config[i].clock = clock_lut_it9135[tmp];\n\t\telse\n\t\t\tstate->af9033_config[i].clock = clock_lut_af9035[tmp];\n\t}\n\n\tstate->no_read = false;\n\t \n\tif (state->af9033_config[0].tuner == AF9033_TUNER_MXL5007T &&\n\t\tle16_to_cpu(d->udev->descriptor.idVendor) == USB_VID_AVERMEDIA)\n\n\t\tswitch (le16_to_cpu(d->udev->descriptor.idProduct)) {\n\t\tcase USB_PID_AVERMEDIA_A867:\n\t\tcase USB_PID_AVERMEDIA_TWINSTAR:\n\t\t\tdev_info(&intf->dev,\n\t\t\t\t \"Device may have issues with I2C read operations. Enabling fix.\\n\");\n\t\t\tstate->no_read = true;\n\t\t\tbreak;\n\t\t}\n\n\treturn 0;\n\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int af9035_tua9001_tuner_callback(struct dvb_usb_device *d,\n\t\tint cmd, int arg)\n{\n\tstruct usb_interface *intf = d->intf;\n\tint ret;\n\tu8 val;\n\n\tdev_dbg(&intf->dev, \"cmd=%d arg=%d\\n\", cmd, arg);\n\n\t \n\n\tswitch (cmd) {\n\tcase TUA9001_CMD_RESETN:\n\t\tif (arg)\n\t\t\tval = 0x00;\n\t\telse\n\t\t\tval = 0x01;\n\n\t\tret = af9035_wr_reg_mask(d, 0x00d8e7, val, 0x01);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tbreak;\n\tcase TUA9001_CMD_RXEN:\n\t\tif (arg)\n\t\t\tval = 0x01;\n\t\telse\n\t\t\tval = 0x00;\n\n\t\tret = af9035_wr_reg_mask(d, 0x00d8eb, val, 0x01);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\n\treturn ret;\n}\n\n\nstatic int af9035_fc0011_tuner_callback(struct dvb_usb_device *d,\n\t\tint cmd, int arg)\n{\n\tstruct usb_interface *intf = d->intf;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase FC0011_FE_CALLBACK_POWER:\n\t\t \n\t\tret = af9035_wr_reg_mask(d, 0xd8eb, 1, 1);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tret = af9035_wr_reg_mask(d, 0xd8ec, 1, 1);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tret = af9035_wr_reg_mask(d, 0xd8ed, 1, 1);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\t \n\t\tret = af9035_wr_reg_mask(d, 0xd8d0, 1, 1);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tret = af9035_wr_reg_mask(d, 0xd8d1, 1, 1);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tusleep_range(10000, 50000);\n\t\tbreak;\n\tcase FC0011_FE_CALLBACK_RESET:\n\t\tret = af9035_wr_reg(d, 0xd8e9, 1);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tret = af9035_wr_reg(d, 0xd8e8, 1);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tret = af9035_wr_reg(d, 0xd8e7, 1);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tusleep_range(10000, 20000);\n\n\t\tret = af9035_wr_reg(d, 0xd8e7, 0);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tusleep_range(10000, 20000);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int af9035_tuner_callback(struct dvb_usb_device *d, int cmd, int arg)\n{\n\tstruct state *state = d_to_priv(d);\n\n\tswitch (state->af9033_config[0].tuner) {\n\tcase AF9033_TUNER_FC0011:\n\t\treturn af9035_fc0011_tuner_callback(d, cmd, arg);\n\tcase AF9033_TUNER_TUA9001:\n\t\treturn af9035_tua9001_tuner_callback(d, cmd, arg);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int af9035_frontend_callback(void *adapter_priv, int component,\n\t\t\t\t    int cmd, int arg)\n{\n\tstruct i2c_adapter *adap = adapter_priv;\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstruct usb_interface *intf = d->intf;\n\n\tdev_dbg(&intf->dev, \"component=%d cmd=%d arg=%d\\n\",\n\t\tcomponent, cmd, arg);\n\n\tswitch (component) {\n\tcase DVB_FRONTEND_COMPONENT_TUNER:\n\t\treturn af9035_tuner_callback(d, cmd, arg);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int af9035_get_adapter_count(struct dvb_usb_device *d)\n{\n\tstruct state *state = d_to_priv(d);\n\n\treturn state->dual_mode + 1;\n}\n\nstatic int af9035_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct state *state = adap_to_priv(adap);\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct usb_interface *intf = d->intf;\n\tint ret;\n\n\tdev_dbg(&intf->dev, \"adap->id=%d\\n\", adap->id);\n\n\tif (!state->af9033_config[adap->id].tuner) {\n\t\t \n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tstate->af9033_config[adap->id].fe = &adap->fe[0];\n\tstate->af9033_config[adap->id].ops = &state->ops;\n\tret = af9035_add_i2c_dev(d, \"af9033\", state->af9033_i2c_addr[adap->id],\n\t\t\t&state->af9033_config[adap->id], &d->i2c_adap);\n\tif (ret)\n\t\tgoto err;\n\n\tif (adap->fe[0] == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t \n\tadap->fe[0]->ops.i2c_gate_ctrl = NULL;\n\tadap->fe[0]->callback = af9035_frontend_callback;\n\n\treturn 0;\n\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\n\treturn ret;\n}\n\n \n#define I2C_SPEED_366K 7\n\nstatic int it930x_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct state *state = adap_to_priv(adap);\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct usb_interface *intf = d->intf;\n\tint ret;\n\tstruct si2168_config si2168_config;\n\tstruct i2c_adapter *adapter;\n\n\tdev_dbg(&intf->dev, \"adap->id=%d\\n\", adap->id);\n\n\t \n\tret = af9035_wr_reg(d, 0x00f6a7, I2C_SPEED_366K);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = af9035_wr_reg(d, 0x00f103, I2C_SPEED_366K);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = af9035_wr_reg_mask(d, 0xd8d4, 0x01, 0x01);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = af9035_wr_reg_mask(d, 0xd8d5, 0x01, 0x01);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = af9035_wr_reg_mask(d, 0xd8d3, 0x01, 0x01);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = af9035_wr_reg_mask(d, 0xd8b8, 0x01, 0x01);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = af9035_wr_reg_mask(d, 0xd8b9, 0x01, 0x01);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = af9035_wr_reg_mask(d, 0xd8b7, 0x00, 0x01);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tmsleep(200);\n\n\tret = af9035_wr_reg_mask(d, 0xd8b7, 0x01, 0x01);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tmemset(&si2168_config, 0, sizeof(si2168_config));\n\tsi2168_config.i2c_adapter = &adapter;\n\tsi2168_config.fe = &adap->fe[0];\n\tsi2168_config.ts_mode = SI2168_TS_SERIAL;\n\n\tstate->af9033_config[adap->id].fe = &adap->fe[0];\n\tstate->af9033_config[adap->id].ops = &state->ops;\n\tret = af9035_add_i2c_dev(d, \"si2168\",\n\t\t\t\t it930x_addresses_table[state->it930x_addresses].frontend_i2c_addr,\n\t\t\t\t &si2168_config, &d->i2c_adap);\n\tif (ret)\n\t\tgoto err;\n\n\tif (adap->fe[0] == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\tstate->i2c_adapter_demod = adapter;\n\n\treturn 0;\n\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int af9035_frontend_detach(struct dvb_usb_adapter *adap)\n{\n\tstruct state *state = adap_to_priv(adap);\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct usb_interface *intf = d->intf;\n\n\tdev_dbg(&intf->dev, \"adap->id=%d\\n\", adap->id);\n\n\tif (adap->id == 1) {\n\t\tif (state->i2c_client[1])\n\t\t\taf9035_del_i2c_dev(d);\n\t} else if (adap->id == 0) {\n\t\tif (state->i2c_client[0])\n\t\t\taf9035_del_i2c_dev(d);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct fc0011_config af9035_fc0011_config = {\n\t.i2c_address = 0x60,\n};\n\nstatic struct mxl5007t_config af9035_mxl5007t_config[] = {\n\t{\n\t\t.xtal_freq_hz = MxL_XTAL_24_MHZ,\n\t\t.if_freq_hz = MxL_IF_4_57_MHZ,\n\t\t.invert_if = 0,\n\t\t.loop_thru_enable = 0,\n\t\t.clk_out_enable = 0,\n\t\t.clk_out_amp = MxL_CLKOUT_AMP_0_94V,\n\t}, {\n\t\t.xtal_freq_hz = MxL_XTAL_24_MHZ,\n\t\t.if_freq_hz = MxL_IF_4_57_MHZ,\n\t\t.invert_if = 0,\n\t\t.loop_thru_enable = 1,\n\t\t.clk_out_enable = 1,\n\t\t.clk_out_amp = MxL_CLKOUT_AMP_0_94V,\n\t}\n};\n\nstatic struct tda18218_config af9035_tda18218_config = {\n\t.i2c_address = 0x60,\n\t.i2c_wr_max = 21,\n};\n\nstatic const struct fc0012_config af9035_fc0012_config[] = {\n\t{\n\t\t.i2c_address = 0x63,\n\t\t.xtal_freq = FC_XTAL_36_MHZ,\n\t\t.dual_master = true,\n\t\t.loop_through = true,\n\t\t.clock_out = true,\n\t}, {\n\t\t.i2c_address = 0x63 | 0x80,  \n\t\t.xtal_freq = FC_XTAL_36_MHZ,\n\t\t.dual_master = true,\n\t}\n};\n\nstatic int af9035_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct state *state = adap_to_priv(adap);\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct usb_interface *intf = d->intf;\n\tint ret;\n\tstruct dvb_frontend *fe;\n\tstruct i2c_msg msg[1];\n\tu8 tuner_addr;\n\n\tdev_dbg(&intf->dev, \"adap->id=%d\\n\", adap->id);\n\n\t \n\n\tswitch (state->af9033_config[adap->id].tuner) {\n\tcase AF9033_TUNER_TUA9001: {\n\t\tstruct tua9001_platform_data tua9001_pdata = {\n\t\t\t.dvb_frontend = adap->fe[0],\n\t\t};\n\n\t\t \n\n\t\t \n\t\tret = af9035_wr_reg_mask(d, 0x00d8ec, 0x01, 0x01);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tret = af9035_wr_reg_mask(d, 0x00d8ed, 0x01, 0x01);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tret = af9035_wr_reg_mask(d, 0x00d8e8, 0x01, 0x01);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tret = af9035_wr_reg_mask(d, 0x00d8e9, 0x01, 0x01);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\t \n\t\tret = af9035_add_i2c_dev(d, \"tua9001\", 0x60, &tua9001_pdata,\n\t\t\t\t\t &d->i2c_adap);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tfe = adap->fe[0];\n\t\tbreak;\n\t}\n\tcase AF9033_TUNER_FC0011:\n\t\tfe = dvb_attach(fc0011_attach, adap->fe[0],\n\t\t\t\t&d->i2c_adap, &af9035_fc0011_config);\n\t\tbreak;\n\tcase AF9033_TUNER_MXL5007T:\n\t\tif (adap->id == 0) {\n\t\t\tret = af9035_wr_reg(d, 0x00d8e0, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\n\t\t\tret = af9035_wr_reg(d, 0x00d8e1, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\n\t\t\tret = af9035_wr_reg(d, 0x00d8df, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\n\t\t\tmsleep(30);\n\n\t\t\tret = af9035_wr_reg(d, 0x00d8df, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\n\t\t\tmsleep(300);\n\n\t\t\tret = af9035_wr_reg(d, 0x00d8c0, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\n\t\t\tret = af9035_wr_reg(d, 0x00d8c1, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\n\t\t\tret = af9035_wr_reg(d, 0x00d8bf, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\n\t\t\tret = af9035_wr_reg(d, 0x00d8b4, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\n\t\t\tret = af9035_wr_reg(d, 0x00d8b5, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\n\t\t\tret = af9035_wr_reg(d, 0x00d8b3, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\n\t\t\ttuner_addr = 0x60;\n\t\t} else {\n\t\t\ttuner_addr = 0x60 | 0x80;  \n\t\t}\n\n\t\t \n\t\tfe = dvb_attach(mxl5007t_attach, adap->fe[0], &d->i2c_adap,\n\t\t\t\ttuner_addr, &af9035_mxl5007t_config[adap->id]);\n\t\tbreak;\n\tcase AF9033_TUNER_TDA18218:\n\t\t \n\t\tfe = dvb_attach(tda18218_attach, adap->fe[0],\n\t\t\t\t&d->i2c_adap, &af9035_tda18218_config);\n\t\tbreak;\n\tcase AF9033_TUNER_FC2580: {\n\t\tstruct fc2580_platform_data fc2580_pdata = {\n\t\t\t.dvb_frontend = adap->fe[0],\n\t\t};\n\n\t\t \n\t\tret = af9035_wr_reg_mask(d, 0xd8eb, 0x01, 0x01);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tret = af9035_wr_reg_mask(d, 0xd8ec, 0x01, 0x01);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tret = af9035_wr_reg_mask(d, 0xd8ed, 0x01, 0x01);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tusleep_range(10000, 50000);\n\t\t \n\t\tret = af9035_add_i2c_dev(d, \"fc2580\", 0x56, &fc2580_pdata,\n\t\t\t\t\t &d->i2c_adap);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tfe = adap->fe[0];\n\t\tbreak;\n\t}\n\tcase AF9033_TUNER_FC0012:\n\t\t \n\n\t\tif (adap->id == 0) {\n\t\t\t \n\t\t\tret = af9035_wr_reg_mask(d, 0xd8eb, 0x01, 0x01);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\n\t\t\tret = af9035_wr_reg_mask(d, 0xd8ec, 0x01, 0x01);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\n\t\t\tret = af9035_wr_reg_mask(d, 0xd8ed, 0x01, 0x01);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t} else {\n\t\t\t \n\t\t\tmsg[0].addr = 0x63;\n\t\t\tmsg[0].flags = 0;\n\t\t\tmsg[0].len = 2;\n\t\t\tmsg[0].buf = \"\\x0d\\x02\";\n\t\t\tret = i2c_transfer(&d->i2c_adap, msg, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tusleep_range(10000, 50000);\n\n\t\tfe = dvb_attach(fc0012_attach, adap->fe[0], &d->i2c_adap,\n\t\t\t\t&af9035_fc0012_config[adap->id]);\n\t\tbreak;\n\tcase AF9033_TUNER_IT9135_38:\n\tcase AF9033_TUNER_IT9135_51:\n\tcase AF9033_TUNER_IT9135_52:\n\tcase AF9033_TUNER_IT9135_60:\n\tcase AF9033_TUNER_IT9135_61:\n\tcase AF9033_TUNER_IT9135_62:\n\t{\n\t\tstruct platform_device *pdev;\n\t\tconst char *name;\n\t\tstruct it913x_platform_data it913x_pdata = {\n\t\t\t.regmap = state->af9033_config[adap->id].regmap,\n\t\t\t.fe = adap->fe[0],\n\t\t};\n\n\t\tswitch (state->af9033_config[adap->id].tuner) {\n\t\tcase AF9033_TUNER_IT9135_38:\n\t\tcase AF9033_TUNER_IT9135_51:\n\t\tcase AF9033_TUNER_IT9135_52:\n\t\t\tname = \"it9133ax-tuner\";\n\t\t\tbreak;\n\t\tcase AF9033_TUNER_IT9135_60:\n\t\tcase AF9033_TUNER_IT9135_61:\n\t\tcase AF9033_TUNER_IT9135_62:\n\t\t\tname = \"it9133bx-tuner\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (state->dual_mode) {\n\t\t\tif (adap->id == 0)\n\t\t\t\tit913x_pdata.role = IT913X_ROLE_DUAL_MASTER;\n\t\t\telse\n\t\t\t\tit913x_pdata.role = IT913X_ROLE_DUAL_SLAVE;\n\t\t} else {\n\t\t\tit913x_pdata.role = IT913X_ROLE_SINGLE;\n\t\t}\n\n\t\trequest_module(\"%s\", \"it913x\");\n\t\tpdev = platform_device_register_data(&d->intf->dev, name,\n\t\t\t\t\t\t     PLATFORM_DEVID_AUTO,\n\t\t\t\t\t\t     &it913x_pdata,\n\t\t\t\t\t\t     sizeof(it913x_pdata));\n\t\tif (IS_ERR(pdev) || !pdev->dev.driver) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tif (!try_module_get(pdev->dev.driver->owner)) {\n\t\t\tplatform_device_unregister(pdev);\n\t\t\tret = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\n\t\tstate->platform_device_tuner[adap->id] = pdev;\n\t\tfe = adap->fe[0];\n\t\tbreak;\n\t}\n\tdefault:\n\t\tfe = NULL;\n\t}\n\n\tif (fe == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int it930x_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct state *state = adap_to_priv(adap);\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct usb_interface *intf = d->intf;\n\tint ret;\n\tstruct si2157_config si2157_config;\n\n\tdev_dbg(&intf->dev, \"adap->id=%d\\n\", adap->id);\n\n\tmemset(&si2157_config, 0, sizeof(si2157_config));\n\tsi2157_config.fe = adap->fe[0];\n\n\t \n\tif ((le16_to_cpu(d->udev->descriptor.idVendor) == USB_VID_DEXATEK &&\n\t     le16_to_cpu(d->udev->descriptor.idProduct) == 0x0100) ||\n\t    (le16_to_cpu(d->udev->descriptor.idVendor) == USB_VID_TERRATEC &&\n\t     le16_to_cpu(d->udev->descriptor.idProduct) == USB_PID_TERRATEC_CINERGY_TC2_STICK))\n\t\tsi2157_config.dont_load_firmware = true;\n\n\tsi2157_config.if_port = it930x_addresses_table[state->it930x_addresses].tuner_if_port;\n\tret = af9035_add_i2c_dev(d, \"si2157\",\n\t\t\t\t it930x_addresses_table[state->it930x_addresses].tuner_i2c_addr,\n\t\t\t\t &si2157_config, state->i2c_adapter_demod);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\n\treturn ret;\n}\n\n\nstatic int it930x_tuner_detach(struct dvb_usb_adapter *adap)\n{\n\tstruct state *state = adap_to_priv(adap);\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct usb_interface *intf = d->intf;\n\n\tdev_dbg(&intf->dev, \"adap->id=%d\\n\", adap->id);\n\n\tif (adap->id == 1) {\n\t\tif (state->i2c_client[3])\n\t\t\taf9035_del_i2c_dev(d);\n\t} else if (adap->id == 0) {\n\t\tif (state->i2c_client[1])\n\t\t\taf9035_del_i2c_dev(d);\n\t}\n\n\treturn 0;\n}\n\n\nstatic int af9035_tuner_detach(struct dvb_usb_adapter *adap)\n{\n\tstruct state *state = adap_to_priv(adap);\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct usb_interface *intf = d->intf;\n\n\tdev_dbg(&intf->dev, \"adap->id=%d\\n\", adap->id);\n\n\tswitch (state->af9033_config[adap->id].tuner) {\n\tcase AF9033_TUNER_TUA9001:\n\tcase AF9033_TUNER_FC2580:\n\t\tif (adap->id == 1) {\n\t\t\tif (state->i2c_client[3])\n\t\t\t\taf9035_del_i2c_dev(d);\n\t\t} else if (adap->id == 0) {\n\t\t\tif (state->i2c_client[1])\n\t\t\t\taf9035_del_i2c_dev(d);\n\t\t}\n\t\tbreak;\n\tcase AF9033_TUNER_IT9135_38:\n\tcase AF9033_TUNER_IT9135_51:\n\tcase AF9033_TUNER_IT9135_52:\n\tcase AF9033_TUNER_IT9135_60:\n\tcase AF9033_TUNER_IT9135_61:\n\tcase AF9033_TUNER_IT9135_62:\n\t{\n\t\tstruct platform_device *pdev;\n\n\t\tpdev = state->platform_device_tuner[adap->id];\n\t\tif (pdev) {\n\t\t\tmodule_put(pdev->dev.driver->owner);\n\t\t\tplatform_device_unregister(pdev);\n\t\t}\n\t\tbreak;\n\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int af9035_init(struct dvb_usb_device *d)\n{\n\tstruct state *state = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\tint ret, i;\n\tu16 frame_size = (d->udev->speed == USB_SPEED_FULL ? 5 : 87) * 188 / 4;\n\tu8 packet_size = (d->udev->speed == USB_SPEED_FULL ? 64 : 512) / 4;\n\tstruct reg_val_mask tab[] = {\n\t\t{ 0x80f99d, 0x01, 0x01 },\n\t\t{ 0x80f9a4, 0x01, 0x01 },\n\t\t{ 0x00dd11, 0x00, 0x20 },\n\t\t{ 0x00dd11, 0x00, 0x40 },\n\t\t{ 0x00dd13, 0x00, 0x20 },\n\t\t{ 0x00dd13, 0x00, 0x40 },\n\t\t{ 0x00dd11, 0x20, 0x20 },\n\t\t{ 0x00dd88, (frame_size >> 0) & 0xff, 0xff},\n\t\t{ 0x00dd89, (frame_size >> 8) & 0xff, 0xff},\n\t\t{ 0x00dd0c, packet_size, 0xff},\n\t\t{ 0x00dd11, state->dual_mode << 6, 0x40 },\n\t\t{ 0x00dd8a, (frame_size >> 0) & 0xff, 0xff},\n\t\t{ 0x00dd8b, (frame_size >> 8) & 0xff, 0xff},\n\t\t{ 0x00dd0d, packet_size, 0xff },\n\t\t{ 0x80f9a3, state->dual_mode, 0x01 },\n\t\t{ 0x80f9cd, state->dual_mode, 0x01 },\n\t\t{ 0x80f99d, 0x00, 0x01 },\n\t\t{ 0x80f9a4, 0x00, 0x01 },\n\t};\n\n\tdev_dbg(&intf->dev, \"USB speed=%d frame_size=%04x packet_size=%02x\\n\",\n\t\td->udev->speed, frame_size, packet_size);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(tab); i++) {\n\t\tret = af9035_wr_reg_mask(d, tab[i].reg, tab[i].val,\n\t\t\t\ttab[i].mask);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int it930x_init(struct dvb_usb_device *d)\n{\n\tstruct state *state = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\tint ret, i;\n\tu16 frame_size = (d->udev->speed == USB_SPEED_FULL ? 5 : 816) * 188 / 4;\n\tu8 packet_size = (d->udev->speed == USB_SPEED_FULL ? 64 : 512) / 4;\n\tstruct reg_val_mask tab[] = {\n\t\t{ 0x00da1a, 0x00, 0x01 },  \n\t\t{ 0x00f41f, 0x04, 0x04 },  \n\t\t{ 0x00da10, 0x00, 0x01 },  \n\t\t{ 0x00f41a, 0x01, 0x01 },  \n\t\t{ 0x00da1d, 0x01, 0x01 },  \n\t\t{ 0x00dd11, 0x00, 0x20 },  \n\t\t{ 0x00dd13, 0x00, 0x20 },  \n\t\t{ 0x00dd11, 0x20, 0x20 },  \n\t\t{ 0x00dd11, 0x00, 0x40 },  \n\t\t{ 0x00dd13, 0x00, 0x40 },  \n\t\t{ 0x00dd11, state->dual_mode << 6, 0x40 },  \n\t\t{ 0x00dd88, (frame_size >> 0) & 0xff, 0xff},\n\t\t{ 0x00dd89, (frame_size >> 8) & 0xff, 0xff},\n\t\t{ 0x00dd0c, packet_size, 0xff},\n\t\t{ 0x00dd8a, (frame_size >> 0) & 0xff, 0xff},\n\t\t{ 0x00dd8b, (frame_size >> 8) & 0xff, 0xff},\n\t\t{ 0x00dd0d, packet_size, 0xff },\n\t\t{ 0x00da1d, 0x00, 0x01 },  \n\t\t{ 0x00d833, 0x01, 0xff },  \n\t\t{ 0x00d830, 0x00, 0xff },  \n\t\t{ 0x00d831, 0x01, 0xff },  \n\t\t{ 0x00d832, 0x00, 0xff },  \n\n\t\t \n\t\t{ 0x00d8b0, 0x01, 0xff },  \n\t\t{ 0x00d8b1, 0x01, 0xff },  \n\t\t{ 0x00d8af, 0x00, 0xff },  \n\n\t\t \n\t\t{ 0x00d8c4, 0x01, 0xff },  \n\t\t{ 0x00d8c5, 0x01, 0xff },  \n\t\t{ 0x00d8c3, 0x00, 0xff },  \n\n\t\t \n\t\t{ 0x00d8dc, 0x01, 0xff },  \n\t\t{ 0x00d8dd, 0x01, 0xff },  \n\t\t{ 0x00d8db, 0x00, 0xff },  \n\n\t\t \n\t\t{ 0x00d8e4, 0x01, 0xff },  \n\t\t{ 0x00d8e5, 0x01, 0xff },  \n\t\t{ 0x00d8e3, 0x00, 0xff },  \n\n\t\t \n\t\t{ 0x00d8e8, 0x01, 0xff },  \n\t\t{ 0x00d8e9, 0x01, 0xff },  \n\t\t{ 0x00d8e7, 0x00, 0xff },  \n\n\t\t{ 0x00da58, 0x00, 0x01 },  \n\t\t{ 0x00da73, 0x01, 0xff },  \n\t\t{ 0x00da78, 0x47, 0xff },  \n\t\t{ 0x00da4c, 0x01, 0xff },  \n\t\t{ 0x00da5a, 0x1f, 0xff },  \n\t};\n\n\tdev_dbg(&intf->dev, \"USB speed=%d frame_size=%04x packet_size=%02x\\n\",\n\t\td->udev->speed, frame_size, packet_size);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(tab); i++) {\n\t\tret = af9035_wr_reg_mask(d, tab[i].reg,\n\t\t\t\ttab[i].val, tab[i].mask);\n\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\n\treturn ret;\n}\n\n\n#if IS_ENABLED(CONFIG_RC_CORE)\nstatic int af9035_rc_query(struct dvb_usb_device *d)\n{\n\tstruct usb_interface *intf = d->intf;\n\tint ret;\n\tenum rc_proto proto;\n\tu32 key;\n\tu8 buf[4];\n\tstruct usb_req req = { CMD_IR_GET, 0, 0, NULL, 4, buf };\n\n\tret = af9035_ctrl_msg(d, &req);\n\tif (ret == 1)\n\t\treturn 0;\n\telse if (ret < 0)\n\t\tgoto err;\n\n\tif ((buf[2] + buf[3]) == 0xff) {\n\t\tif ((buf[0] + buf[1]) == 0xff) {\n\t\t\t \n\t\t\tkey = RC_SCANCODE_NEC(buf[0], buf[2]);\n\t\t\tproto = RC_PROTO_NEC;\n\t\t} else {\n\t\t\t \n\t\t\tkey = RC_SCANCODE_NECX(buf[0] << 8 | buf[1], buf[2]);\n\t\t\tproto = RC_PROTO_NECX;\n\t\t}\n\t} else {\n\t\t \n\t\tkey = RC_SCANCODE_NEC32(buf[0] << 24 | buf[1] << 16 |\n\t\t\t\t\tbuf[2] << 8  | buf[3]);\n\t\tproto = RC_PROTO_NEC32;\n\t}\n\n\tdev_dbg(&intf->dev, \"%*ph\\n\", 4, buf);\n\n\trc_keydown(d->rc_dev, proto, key, 0);\n\n\treturn 0;\n\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int af9035_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)\n{\n\tstruct state *state = d_to_priv(d);\n\tstruct usb_interface *intf = d->intf;\n\n\tdev_dbg(&intf->dev, \"ir_mode=%02x ir_type=%02x\\n\",\n\t\tstate->ir_mode, state->ir_type);\n\n\t \n\tif (state->ir_mode == 0x05) {\n\t\tswitch (state->ir_type) {\n\t\tcase 0:  \n\t\tdefault:\n\t\t\trc->allowed_protos = RC_PROTO_BIT_NEC |\n\t\t\t\t\tRC_PROTO_BIT_NECX | RC_PROTO_BIT_NEC32;\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\trc->allowed_protos = RC_PROTO_BIT_RC6_MCE;\n\t\t\tbreak;\n\t\t}\n\n\t\trc->query = af9035_rc_query;\n\t\trc->interval = 500;\n\n\t\t \n\t\tif (!rc->map_name)\n\t\t\trc->map_name = RC_MAP_EMPTY;\n\t}\n\n\treturn 0;\n}\n#else\n\t#define af9035_get_rc_config NULL\n#endif\n\nstatic int af9035_get_stream_config(struct dvb_frontend *fe, u8 *ts_type,\n\t\tstruct usb_data_stream_properties *stream)\n{\n\tstruct dvb_usb_device *d = fe_to_d(fe);\n\tstruct usb_interface *intf = d->intf;\n\n\tdev_dbg(&intf->dev, \"adap=%d\\n\", fe_to_adap(fe)->id);\n\n\tif (d->udev->speed == USB_SPEED_FULL)\n\t\tstream->u.bulk.buffersize = 5 * 188;\n\n\treturn 0;\n}\n\nstatic int af9035_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)\n{\n\tstruct state *state = adap_to_priv(adap);\n\n\treturn state->ops.pid_filter_ctrl(adap->fe[0], onoff);\n}\n\nstatic int af9035_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid,\n\t\tint onoff)\n{\n\tstruct state *state = adap_to_priv(adap);\n\n\treturn state->ops.pid_filter(adap->fe[0], index, pid, onoff);\n}\n\nstatic int af9035_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tchar manufacturer[sizeof(\"Afatech\")];\n\n\tmemset(manufacturer, 0, sizeof(manufacturer));\n\tusb_string(udev, udev->descriptor.iManufacturer,\n\t\t\tmanufacturer, sizeof(manufacturer));\n\t \n\tif ((le16_to_cpu(udev->descriptor.idVendor) == USB_VID_TERRATEC) &&\n\t\t\t(le16_to_cpu(udev->descriptor.idProduct) == 0x0099)) {\n\t\tif (!strcmp(\"Afatech\", manufacturer)) {\n\t\t\tdev_dbg(&udev->dev, \"rejecting device\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn dvb_usbv2_probe(intf, id);\n}\n\n \nstatic const struct dvb_usb_device_properties af9035_props = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\t.size_of_priv = sizeof(struct state),\n\n\t.generic_bulk_ctrl_endpoint = 0x02,\n\t.generic_bulk_ctrl_endpoint_response = 0x81,\n\n\t.identify_state = af9035_identify_state,\n\t.download_firmware = af9035_download_firmware,\n\n\t.i2c_algo = &af9035_i2c_algo,\n\t.read_config = af9035_read_config,\n\t.frontend_attach = af9035_frontend_attach,\n\t.frontend_detach = af9035_frontend_detach,\n\t.tuner_attach = af9035_tuner_attach,\n\t.tuner_detach = af9035_tuner_detach,\n\t.init = af9035_init,\n\t.get_rc_config = af9035_get_rc_config,\n\t.get_stream_config = af9035_get_stream_config,\n\n\t.get_adapter_count = af9035_get_adapter_count,\n\t.adapter = {\n\t\t{\n\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\n\t\t\t.pid_filter_count = 32,\n\t\t\t.pid_filter_ctrl = af9035_pid_filter_ctrl,\n\t\t\t.pid_filter = af9035_pid_filter,\n\n\t\t\t.stream = DVB_USB_STREAM_BULK(0x84, 6, 87 * 188),\n\t\t}, {\n\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\n\t\t\t.pid_filter_count = 32,\n\t\t\t.pid_filter_ctrl = af9035_pid_filter_ctrl,\n\t\t\t.pid_filter = af9035_pid_filter,\n\n\t\t\t.stream = DVB_USB_STREAM_BULK(0x85, 6, 87 * 188),\n\t\t},\n\t},\n};\n\nstatic const struct dvb_usb_device_properties it930x_props = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\t.size_of_priv = sizeof(struct state),\n\n\t.generic_bulk_ctrl_endpoint = 0x02,\n\t.generic_bulk_ctrl_endpoint_response = 0x81,\n\n\t.identify_state = af9035_identify_state,\n\t.download_firmware = af9035_download_firmware,\n\n\t.i2c_algo = &af9035_i2c_algo,\n\t.read_config = af9035_read_config,\n\t.frontend_attach = it930x_frontend_attach,\n\t.frontend_detach = af9035_frontend_detach,\n\t.tuner_attach = it930x_tuner_attach,\n\t.tuner_detach = it930x_tuner_detach,\n\t.init = it930x_init,\n\t.get_stream_config = af9035_get_stream_config,\n\n\t.get_adapter_count = af9035_get_adapter_count,\n\t.adapter = {\n\t\t{\n\t\t\t.stream = DVB_USB_STREAM_BULK(0x84, 4, 816 * 188),\n\t\t}, {\n\t\t\t.stream = DVB_USB_STREAM_BULK(0x85, 4, 816 * 188),\n\t\t},\n\t},\n};\n\nstatic const struct usb_device_id af9035_id_table[] = {\n\t \n\t{ DVB_USB_DEVICE(USB_VID_AFATECH, USB_PID_AFATECH_AF9035_9035,\n\t\t&af9035_props, \"Afatech AF9035 reference design\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_AFATECH, USB_PID_AFATECH_AF9035_1000,\n\t\t&af9035_props, \"Afatech AF9035 reference design\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_AFATECH, USB_PID_AFATECH_AF9035_1001,\n\t\t&af9035_props, \"Afatech AF9035 reference design\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_AFATECH, USB_PID_AFATECH_AF9035_1002,\n\t\t&af9035_props, \"Afatech AF9035 reference design\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_AFATECH, USB_PID_AFATECH_AF9035_1003,\n\t\t&af9035_props, \"Afatech AF9035 reference design\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_T_STICK,\n\t\t&af9035_props, \"TerraTec Cinergy T Stick\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_A835,\n\t\t&af9035_props, \"AVerMedia AVerTV Volar HD/PRO (A835)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_B835,\n\t\t&af9035_props, \"AVerMedia AVerTV Volar HD/PRO (A835)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_1867,\n\t\t&af9035_props, \"AVerMedia HD Volar (A867)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_A867,\n\t\t&af9035_props, \"AVerMedia HD Volar (A867)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_TWINSTAR,\n\t\t&af9035_props, \"AVerMedia Twinstar (A825)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_ASUS, USB_PID_ASUS_U3100MINI_PLUS,\n\t\t&af9035_props, \"Asus U3100Mini Plus\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_TERRATEC, 0x00aa,\n\t\t&af9035_props, \"TerraTec Cinergy T Stick (rev. 2)\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, 0x0337,\n\t\t&af9035_props, \"AVerMedia HD Volar (A867)\", NULL) },\n       { DVB_USB_DEVICE(USB_VID_GTEK, USB_PID_EVOLVEO_XTRATV_STICK,\n\t       &af9035_props, \"EVOLVEO XtraTV stick\", NULL) },\n\n\t \n\t{ DVB_USB_DEVICE(USB_VID_ITETECH, USB_PID_ITETECH_IT9135,\n\t\t&af9035_props, \"ITE 9135 Generic\", RC_MAP_IT913X_V1) },\n\t{ DVB_USB_DEVICE(USB_VID_ITETECH, USB_PID_ITETECH_IT9135_9005,\n\t\t&af9035_props, \"ITE 9135(9005) Generic\", RC_MAP_IT913X_V2) },\n\t{ DVB_USB_DEVICE(USB_VID_ITETECH, USB_PID_ITETECH_IT9135_9006,\n\t\t&af9035_props, \"ITE 9135(9006) Generic\", RC_MAP_IT913X_V1) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_A835B_1835,\n\t\t&af9035_props, \"Avermedia A835B(1835)\", RC_MAP_IT913X_V2) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_A835B_2835,\n\t\t&af9035_props, \"Avermedia A835B(2835)\", RC_MAP_IT913X_V2) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_A835B_3835,\n\t\t&af9035_props, \"Avermedia A835B(3835)\", RC_MAP_IT913X_V2) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_A835B_4835,\n\t\t&af9035_props, \"Avermedia A835B(4835)\",\tRC_MAP_IT913X_V2) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_TD110,\n\t\t&af9035_props, \"Avermedia AverTV Volar HD 2 (TD110)\", RC_MAP_AVERMEDIA_RM_KS) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_H335,\n\t\t&af9035_props, \"Avermedia H335\", RC_MAP_IT913X_V2) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_KWORLD_UB499_2T_T09,\n\t\t&af9035_props, \"Kworld UB499-2T T09\", RC_MAP_IT913X_V1) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_SVEON_STV22_IT9137,\n\t\t&af9035_props, \"Sveon STV22 Dual DVB-T HDTV\",\n\t\t\t\t\t\t\tRC_MAP_IT913X_V1) },\n\t{ DVB_USB_DEVICE(USB_VID_KWORLD_2, USB_PID_CTVDIGDUAL_V2,\n\t\t&af9035_props, \"Digital Dual TV Receiver CTVDIGDUAL_V2\",\n\t\t\t\t\t\t\tRC_MAP_IT913X_V1) },\n\t{ DVB_USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_T1,\n\t\t&af9035_props, \"TerraTec T1\", RC_MAP_IT913X_V1) },\n\t \n\t{ DVB_USB_DEVICE(USB_VID_TERRATEC, 0x0099,\n\t\t&af9035_props, \"TerraTec Cinergy T Stick Dual RC (rev. 2)\",\n\t\tNULL) },\n\t{ DVB_USB_DEVICE(USB_VID_LEADTEK, 0x6a05,\n\t\t&af9035_props, \"Leadtek WinFast DTV Dongle Dual\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xf900,\n\t\t&af9035_props, \"Hauppauge WinTV-MiniStick 2\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_PCTV, USB_PID_PCTV_78E,\n\t\t&af9035_props, \"PCTV AndroiDTV (78e)\", RC_MAP_IT913X_V1) },\n\t{ DVB_USB_DEVICE(USB_VID_PCTV, USB_PID_PCTV_79E,\n\t\t&af9035_props, \"PCTV microStick (79e)\", RC_MAP_IT913X_V2) },\n\n\t \n\t{ DVB_USB_DEVICE(USB_VID_ITETECH, USB_PID_ITETECH_IT9303,\n\t\t&it930x_props, \"ITE 9303 Generic\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_TD310,\n\t\t&it930x_props, \"AVerMedia TD310 DVB-T2\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_DEXATEK, 0x0100,\n\t\t&it930x_props, \"Logilink VG0022A\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_TC2_STICK,\n\t\t&it930x_props, \"TerraTec Cinergy TC2 Stick\", NULL) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, af9035_id_table);\n\nstatic struct usb_driver af9035_usb_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = af9035_id_table,\n\t.probe = af9035_probe,\n\t.disconnect = dvb_usbv2_disconnect,\n\t.suspend = dvb_usbv2_suspend,\n\t.resume = dvb_usbv2_resume,\n\t.reset_resume = dvb_usbv2_reset_resume,\n\t.no_dynamic_id = 1,\n\t.soft_unbind = 1,\n};\n\nmodule_usb_driver(af9035_usb_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"Afatech AF9035 driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(AF9035_FIRMWARE_AF9035);\nMODULE_FIRMWARE(AF9035_FIRMWARE_IT9135_V1);\nMODULE_FIRMWARE(AF9035_FIRMWARE_IT9135_V2);\nMODULE_FIRMWARE(AF9035_FIRMWARE_IT9303);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}