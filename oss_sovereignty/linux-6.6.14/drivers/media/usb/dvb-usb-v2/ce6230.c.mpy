{
  "module_name": "ce6230.c",
  "hash_id": "ceadba22d08bc643472516c50f26d7e6b69d205448d4987f959758b8fe0311f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/ce6230.c",
  "human_readable_source": "\n \n\n#include \"ce6230.h\"\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic int ce6230_ctrl_msg(struct dvb_usb_device *d, struct usb_req *req)\n{\n\tint ret;\n\tunsigned int pipe;\n\tu8 request;\n\tu8 requesttype;\n\tu16 value;\n\tu16 index;\n\tu8 *buf;\n\n\trequest = req->cmd;\n\tvalue = req->value;\n\tindex = req->index;\n\n\tswitch (req->cmd) {\n\tcase I2C_READ:\n\tcase DEMOD_READ:\n\tcase REG_READ:\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\n\t\tbreak;\n\tcase I2C_WRITE:\n\tcase DEMOD_WRITE:\n\tcase REG_WRITE:\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&d->udev->dev, \"%s: unknown command=%02x\\n\",\n\t\t\t\tKBUILD_MODNAME, req->cmd);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tbuf = kmalloc(req->data_len, GFP_KERNEL);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tif (requesttype == (USB_TYPE_VENDOR | USB_DIR_OUT)) {\n\t\t \n\t\tmemcpy(buf, req->data, req->data_len);\n\t\tpipe = usb_sndctrlpipe(d->udev, 0);\n\t} else {\n\t\t \n\t\tpipe = usb_rcvctrlpipe(d->udev, 0);\n\t}\n\n\tmsleep(1);  \n\n\tret = usb_control_msg(d->udev, pipe, request, requesttype, value, index,\n\t\t\tbuf, req->data_len, CE6230_USB_TIMEOUT);\n\n\tdvb_usb_dbg_usb_control_msg(d->udev, request, requesttype, value, index,\n\t\t\tbuf, req->data_len);\n\n\tif (ret < 0)\n\t\tdev_err(&d->udev->dev, \"%s: usb_control_msg() failed=%d\\n\",\n\t\t\t\tKBUILD_MODNAME, ret);\n\telse\n\t\tret = 0;\n\n\t \n\tif (!ret && requesttype == (USB_TYPE_VENDOR | USB_DIR_IN))\n\t\tmemcpy(req->data, buf, req->data_len);\n\n\tkfree(buf);\nerror:\n\treturn ret;\n}\n\n \nstatic struct zl10353_config ce6230_zl10353_config;\n\nstatic int ce6230_i2c_master_xfer(struct i2c_adapter *adap,\n\t\tstruct i2c_msg msg[], int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint ret = 0, i = 0;\n\tstruct usb_req req;\n\n\tif (num > 2)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&req, 0, sizeof(req));\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\twhile (i < num) {\n\t\tif (num > i + 1 && (msg[i+1].flags & I2C_M_RD)) {\n\t\t\tif (msg[i].addr ==\n\t\t\t\tce6230_zl10353_config.demod_address) {\n\t\t\t\tif (msg[i].len < 1) {\n\t\t\t\t\ti = -EOPNOTSUPP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treq.cmd = DEMOD_READ;\n\t\t\t\treq.value = msg[i].addr >> 1;\n\t\t\t\treq.index = msg[i].buf[0];\n\t\t\t\treq.data_len = msg[i+1].len;\n\t\t\t\treq.data = &msg[i+1].buf[0];\n\t\t\t\tret = ce6230_ctrl_msg(d, &req);\n\t\t\t} else {\n\t\t\t\tdev_err(&d->udev->dev, \"%s: I2C read not \" \\\n\t\t\t\t\t\t\"implemented\\n\",\n\t\t\t\t\t\tKBUILD_MODNAME);\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t}\n\t\t\ti += 2;\n\t\t} else {\n\t\t\tif (msg[i].addr ==\n\t\t\t\tce6230_zl10353_config.demod_address) {\n\t\t\t\tif (msg[i].len < 1) {\n\t\t\t\t\ti = -EOPNOTSUPP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treq.cmd = DEMOD_WRITE;\n\t\t\t\treq.value = msg[i].addr >> 1;\n\t\t\t\treq.index = msg[i].buf[0];\n\t\t\t\treq.data_len = msg[i].len-1;\n\t\t\t\treq.data = &msg[i].buf[1];\n\t\t\t\tret = ce6230_ctrl_msg(d, &req);\n\t\t\t} else {\n\t\t\t\treq.cmd = I2C_WRITE;\n\t\t\t\treq.value = 0x2000 + (msg[i].addr >> 1);\n\t\t\t\treq.index = 0x0000;\n\t\t\t\treq.data_len = msg[i].len;\n\t\t\t\treq.data = &msg[i].buf[0];\n\t\t\t\tret = ce6230_ctrl_msg(d, &req);\n\t\t\t}\n\t\t\ti += 1;\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&d->i2c_mutex);\n\treturn ret ? ret : i;\n}\n\nstatic u32 ce6230_i2c_functionality(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm ce6230_i2c_algorithm = {\n\t.master_xfer   = ce6230_i2c_master_xfer,\n\t.functionality = ce6230_i2c_functionality,\n};\n\n \nstatic struct zl10353_config ce6230_zl10353_config = {\n\t.demod_address = 0x1e,\n\t.adc_clock = 450000,\n\t.if2 = 45700,\n\t.no_tuner = 1,\n\t.parallel_ts = 1,\n\t.clock_ctl_1 = 0x34,\n\t.pll_0 = 0x0e,\n};\n\nstatic int ce6230_zl10353_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\n\tdev_dbg(&d->udev->dev, \"%s:\\n\", __func__);\n\n\tadap->fe[0] = dvb_attach(zl10353_attach, &ce6230_zl10353_config,\n\t\t\t&d->i2c_adap);\n\tif (adap->fe[0] == NULL)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic struct mxl5005s_config ce6230_mxl5003s_config = {\n\t.i2c_address     = 0xc6,\n\t.if_freq         = IF_FREQ_4570000HZ,\n\t.xtal_freq       = CRYSTAL_FREQ_16000000HZ,\n\t.agc_mode        = MXL_SINGLE_AGC,\n\t.tracking_filter = MXL_TF_DEFAULT,\n\t.rssi_enable     = MXL_RSSI_ENABLE,\n\t.cap_select      = MXL_CAP_SEL_ENABLE,\n\t.div_out         = MXL_DIV_OUT_4,\n\t.clock_out       = MXL_CLOCK_OUT_DISABLE,\n\t.output_load     = MXL5005S_IF_OUTPUT_LOAD_200_OHM,\n\t.top\t\t = MXL5005S_TOP_25P2,\n\t.mod_mode        = MXL_DIGITAL_MODE,\n\t.if_mode         = MXL_ZERO_IF,\n\t.AgcMasterByte   = 0x00,\n};\n\nstatic int ce6230_mxl5003s_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tint ret;\n\n\tdev_dbg(&d->udev->dev, \"%s:\\n\", __func__);\n\n\tret = dvb_attach(mxl5005s_attach, adap->fe[0], &d->i2c_adap,\n\t\t\t&ce6230_mxl5003s_config) == NULL ? -ENODEV : 0;\n\treturn ret;\n}\n\nstatic int ce6230_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tint ret;\n\n\tdev_dbg(&d->udev->dev, \"%s: onoff=%d\\n\", __func__, onoff);\n\n\t \n\tret = usb_set_interface(d->udev, 1, onoff);\n\tif (ret)\n\t\tdev_err(&d->udev->dev, \"%s: usb_set_interface() failed=%d\\n\",\n\t\t\t\tKBUILD_MODNAME, ret);\n\n\treturn ret;\n}\n\n \nstatic struct dvb_usb_device_properties ce6230_props = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\t.bInterfaceNumber = 1,\n\n\t.i2c_algo = &ce6230_i2c_algorithm,\n\t.power_ctrl = ce6230_power_ctrl,\n\t.frontend_attach = ce6230_zl10353_frontend_attach,\n\t.tuner_attach = ce6230_mxl5003s_tuner_attach,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 6,\n\t\t\t\t.endpoint = 0x82,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = (16 * 512),\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t},\n};\n\nstatic const struct usb_device_id ce6230_id_table[] = {\n\t{ DVB_USB_DEVICE(USB_VID_INTEL, USB_PID_INTEL_CE9500,\n\t\t&ce6230_props, \"Intel CE9500 reference design\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_AVERMEDIA, USB_PID_AVERMEDIA_A310,\n\t\t&ce6230_props, \"AVerMedia A310 USB 2.0 DVB-T tuner\", NULL) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, ce6230_id_table);\n\nstatic struct usb_driver ce6230_usb_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = ce6230_id_table,\n\t.probe = dvb_usbv2_probe,\n\t.disconnect = dvb_usbv2_disconnect,\n\t.suspend = dvb_usbv2_suspend,\n\t.resume = dvb_usbv2_resume,\n\t.reset_resume = dvb_usbv2_reset_resume,\n\t.no_dynamic_id = 1,\n\t.soft_unbind = 1,\n};\n\nmodule_usb_driver(ce6230_usb_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"Intel CE6230 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}