{
  "module_name": "usb_urb.c",
  "hash_id": "fc3baffd8a68c6d17f93b26e1b891d6393aa0b4e8dbcceb9505dc18f741338cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/usb_urb.c",
  "human_readable_source": "\n \n#include \"dvb_usb_common.h\"\n\n \n\nint usb_urb_reconfig(struct usb_data_stream *stream,\n\t\tstruct usb_data_stream_properties *props);\n\nstatic void usb_urb_complete(struct urb *urb)\n{\n\tstruct usb_data_stream *stream = urb->context;\n\tint ptype = usb_pipetype(urb->pipe);\n\tint i;\n\tu8 *b;\n\n\tdev_dbg_ratelimited(&stream->udev->dev,\n\t\t\t\"%s: %s urb completed status=%d length=%d/%d pack_num=%d errors=%d\\n\",\n\t\t\t__func__, ptype == PIPE_ISOCHRONOUS ? \"isoc\" : \"bulk\",\n\t\t\turb->status, urb->actual_length,\n\t\t\turb->transfer_buffer_length,\n\t\t\turb->number_of_packets, urb->error_count);\n\n\tswitch (urb->status) {\n\tcase 0:          \n\tcase -ETIMEDOUT:     \n\t\tbreak;\n\tcase -ECONNRESET:    \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:         \n\t\tdev_dbg_ratelimited(&stream->udev->dev,\n\t\t\t\t\"%s: urb completion failed=%d\\n\",\n\t\t\t\t__func__, urb->status);\n\t\tbreak;\n\t}\n\n\tb = (u8 *) urb->transfer_buffer;\n\tswitch (ptype) {\n\tcase PIPE_ISOCHRONOUS:\n\t\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\t\tif (urb->iso_frame_desc[i].status != 0)\n\t\t\t\tdev_dbg(&stream->udev->dev,\n\t\t\t\t\t\t\"%s: iso frame descriptor has an error=%d\\n\",\n\t\t\t\t\t\t__func__,\n\t\t\t\t\t\turb->iso_frame_desc[i].status);\n\t\t\telse if (urb->iso_frame_desc[i].actual_length > 0)\n\t\t\t\tstream->complete(stream,\n\t\t\t\t\tb + urb->iso_frame_desc[i].offset,\n\t\t\t\t\turb->iso_frame_desc[i].actual_length);\n\n\t\t\turb->iso_frame_desc[i].status = 0;\n\t\t\turb->iso_frame_desc[i].actual_length = 0;\n\t\t}\n\t\tbreak;\n\tcase PIPE_BULK:\n\t\tif (urb->actual_length > 0)\n\t\t\tstream->complete(stream, b, urb->actual_length);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&stream->udev->dev,\n\t\t\t\t\"%s: unknown endpoint type in completion handler\\n\",\n\t\t\t\tKBUILD_MODNAME);\n\t\treturn;\n\t}\n\tusb_submit_urb(urb, GFP_ATOMIC);\n}\n\nint usb_urb_killv2(struct usb_data_stream *stream)\n{\n\tint i;\n\tfor (i = 0; i < stream->urbs_submitted; i++) {\n\t\tdev_dbg(&stream->udev->dev, \"%s: kill urb=%d\\n\", __func__, i);\n\t\t \n\t\tusb_kill_urb(stream->urb_list[i]);\n\t}\n\tstream->urbs_submitted = 0;\n\treturn 0;\n}\n\nint usb_urb_submitv2(struct usb_data_stream *stream,\n\t\tstruct usb_data_stream_properties *props)\n{\n\tint i, ret;\n\n\tif (props) {\n\t\tret = usb_urb_reconfig(stream, props);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < stream->urbs_initialized; i++) {\n\t\tdev_dbg(&stream->udev->dev, \"%s: submit urb=%d\\n\", __func__, i);\n\t\tret = usb_submit_urb(stream->urb_list[i], GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tdev_err(&stream->udev->dev,\n\t\t\t\t\t\"%s: could not submit urb no. %d - get them all back\\n\",\n\t\t\t\t\tKBUILD_MODNAME, i);\n\t\t\tusb_urb_killv2(stream);\n\t\t\treturn ret;\n\t\t}\n\t\tstream->urbs_submitted++;\n\t}\n\treturn 0;\n}\n\nstatic int usb_urb_free_urbs(struct usb_data_stream *stream)\n{\n\tint i;\n\n\tusb_urb_killv2(stream);\n\n\tfor (i = stream->urbs_initialized - 1; i >= 0; i--) {\n\t\tif (stream->urb_list[i]) {\n\t\t\tdev_dbg(&stream->udev->dev, \"%s: free urb=%d\\n\",\n\t\t\t\t\t__func__, i);\n\t\t\t \n\t\t\tusb_free_urb(stream->urb_list[i]);\n\t\t}\n\t}\n\tstream->urbs_initialized = 0;\n\n\treturn 0;\n}\n\nstatic int usb_urb_alloc_bulk_urbs(struct usb_data_stream *stream)\n{\n\tint i, j;\n\n\t \n\tfor (i = 0; i < stream->props.count; i++) {\n\t\tdev_dbg(&stream->udev->dev, \"%s: alloc urb=%d\\n\", __func__, i);\n\t\tstream->urb_list[i] = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!stream->urb_list[i]) {\n\t\t\tdev_dbg(&stream->udev->dev, \"%s: failed\\n\", __func__);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tusb_free_urb(stream->urb_list[j]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tusb_fill_bulk_urb(stream->urb_list[i],\n\t\t\t\tstream->udev,\n\t\t\t\tusb_rcvbulkpipe(stream->udev,\n\t\t\t\t\t\tstream->props.endpoint),\n\t\t\t\tstream->buf_list[i],\n\t\t\t\tstream->props.u.bulk.buffersize,\n\t\t\t\tusb_urb_complete, stream);\n\n\t\tstream->urbs_initialized++;\n\t}\n\treturn 0;\n}\n\nstatic int usb_urb_alloc_isoc_urbs(struct usb_data_stream *stream)\n{\n\tint i, j;\n\n\t \n\tfor (i = 0; i < stream->props.count; i++) {\n\t\tstruct urb *urb;\n\t\tint frame_offset = 0;\n\t\tdev_dbg(&stream->udev->dev, \"%s: alloc urb=%d\\n\", __func__, i);\n\t\tstream->urb_list[i] = usb_alloc_urb(\n\t\t\t\tstream->props.u.isoc.framesperurb, GFP_ATOMIC);\n\t\tif (!stream->urb_list[i]) {\n\t\t\tdev_dbg(&stream->udev->dev, \"%s: failed\\n\", __func__);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tusb_free_urb(stream->urb_list[j]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\turb = stream->urb_list[i];\n\n\t\turb->dev = stream->udev;\n\t\turb->context = stream;\n\t\turb->complete = usb_urb_complete;\n\t\turb->pipe = usb_rcvisocpipe(stream->udev,\n\t\t\t\tstream->props.endpoint);\n\t\turb->transfer_flags = URB_ISO_ASAP;\n\t\turb->interval = stream->props.u.isoc.interval;\n\t\turb->number_of_packets = stream->props.u.isoc.framesperurb;\n\t\turb->transfer_buffer_length = stream->props.u.isoc.framesize *\n\t\t\t\tstream->props.u.isoc.framesperurb;\n\t\turb->transfer_buffer = stream->buf_list[i];\n\n\t\tfor (j = 0; j < stream->props.u.isoc.framesperurb; j++) {\n\t\t\turb->iso_frame_desc[j].offset = frame_offset;\n\t\t\turb->iso_frame_desc[j].length =\n\t\t\t\t\tstream->props.u.isoc.framesize;\n\t\t\tframe_offset += stream->props.u.isoc.framesize;\n\t\t}\n\n\t\tstream->urbs_initialized++;\n\t}\n\treturn 0;\n}\n\nstatic int usb_free_stream_buffers(struct usb_data_stream *stream)\n{\n\tif (stream->state & USB_STATE_URB_BUF) {\n\t\twhile (stream->buf_num) {\n\t\t\tstream->buf_num--;\n\t\t\tkfree(stream->buf_list[stream->buf_num]);\n\t\t}\n\t}\n\n\tstream->state &= ~USB_STATE_URB_BUF;\n\n\treturn 0;\n}\n\nstatic int usb_alloc_stream_buffers(struct usb_data_stream *stream, int num,\n\t\t\t\t    unsigned long size)\n{\n\tstream->buf_num = 0;\n\tstream->buf_size = size;\n\n\tdev_dbg(&stream->udev->dev,\n\t\t\t\"%s: all in all I will use %lu bytes for streaming\\n\",\n\t\t\t__func__,  num * size);\n\n\tfor (stream->buf_num = 0; stream->buf_num < num; stream->buf_num++) {\n\t\tstream->buf_list[stream->buf_num] = kzalloc(size, GFP_ATOMIC);\n\t\tif (!stream->buf_list[stream->buf_num]) {\n\t\t\tdev_dbg(&stream->udev->dev, \"%s: alloc buf=%d failed\\n\",\n\t\t\t\t\t__func__, stream->buf_num);\n\t\t\tusb_free_stream_buffers(stream);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdev_dbg(&stream->udev->dev, \"%s: alloc buf=%d %p (dma %llu)\\n\",\n\t\t\t\t__func__, stream->buf_num,\n\t\t\t\tstream->buf_list[stream->buf_num],\n\t\t\t\t(long long)stream->dma_addr[stream->buf_num]);\n\t\tstream->state |= USB_STATE_URB_BUF;\n\t}\n\n\treturn 0;\n}\n\nint usb_urb_reconfig(struct usb_data_stream *stream,\n\t\tstruct usb_data_stream_properties *props)\n{\n\tint buf_size;\n\n\tif (!props)\n\t\treturn 0;\n\n\t \n\tif (props->type == USB_BULK) {\n\t\tbuf_size = stream->props.u.bulk.buffersize;\n\t} else if (props->type == USB_ISOC) {\n\t\tbuf_size = props->u.isoc.framesize * props->u.isoc.framesperurb;\n\t} else {\n\t\tdev_err(&stream->udev->dev, \"%s: invalid endpoint type=%d\\n\",\n\t\t\t\tKBUILD_MODNAME, props->type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (stream->buf_num < props->count || stream->buf_size < buf_size) {\n\t\tdev_err(&stream->udev->dev,\n\t\t\t\t\"%s: cannot reconfigure as allocated buffers are too small\\n\",\n\t\t\t\tKBUILD_MODNAME);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (stream->props.type == props->type &&\n\t\t\tstream->props.count == props->count &&\n\t\t\tstream->props.endpoint == props->endpoint) {\n\t\tif (props->type == USB_BULK &&\n\t\t\t\tprops->u.bulk.buffersize ==\n\t\t\t\tstream->props.u.bulk.buffersize)\n\t\t\treturn 0;\n\t\telse if (props->type == USB_ISOC &&\n\t\t\t\tprops->u.isoc.framesperurb ==\n\t\t\t\tstream->props.u.isoc.framesperurb &&\n\t\t\t\tprops->u.isoc.framesize ==\n\t\t\t\tstream->props.u.isoc.framesize &&\n\t\t\t\tprops->u.isoc.interval ==\n\t\t\t\tstream->props.u.isoc.interval)\n\t\t\treturn 0;\n\t}\n\n\tdev_dbg(&stream->udev->dev, \"%s: re-alloc urbs\\n\", __func__);\n\n\tusb_urb_free_urbs(stream);\n\tmemcpy(&stream->props, props, sizeof(*props));\n\tif (props->type == USB_BULK)\n\t\treturn usb_urb_alloc_bulk_urbs(stream);\n\telse if (props->type == USB_ISOC)\n\t\treturn usb_urb_alloc_isoc_urbs(stream);\n\n\treturn 0;\n}\n\nint usb_urb_initv2(struct usb_data_stream *stream,\n\t\tconst struct usb_data_stream_properties *props)\n{\n\tint ret;\n\n\tif (!stream || !props)\n\t\treturn -EINVAL;\n\n\tmemcpy(&stream->props, props, sizeof(*props));\n\n\tif (!stream->complete) {\n\t\tdev_err(&stream->udev->dev,\n\t\t\t\t\"%s: there is no data callback - this doesn't make sense\\n\",\n\t\t\t\tKBUILD_MODNAME);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (stream->props.type) {\n\tcase USB_BULK:\n\t\tret = usb_alloc_stream_buffers(stream, stream->props.count,\n\t\t\t\tstream->props.u.bulk.buffersize);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn usb_urb_alloc_bulk_urbs(stream);\n\tcase USB_ISOC:\n\t\tret = usb_alloc_stream_buffers(stream, stream->props.count,\n\t\t\t\tstream->props.u.isoc.framesize *\n\t\t\t\tstream->props.u.isoc.framesperurb);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn usb_urb_alloc_isoc_urbs(stream);\n\tdefault:\n\t\tdev_err(&stream->udev->dev,\n\t\t\t\t\"%s: unknown urb-type for data transfer\\n\",\n\t\t\t\tKBUILD_MODNAME);\n\t\treturn -EINVAL;\n\t}\n}\n\nint usb_urb_exitv2(struct usb_data_stream *stream)\n{\n\tusb_urb_free_urbs(stream);\n\tusb_free_stream_buffers(stream);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}