{
  "module_name": "anysee.c",
  "hash_id": "ff2aeced2f93c6085a24018f71c96a046041edc3a82f3332d2586d1e8c4ae0eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/anysee.c",
  "human_readable_source": "\n \n\n#include \"anysee.h\"\n#include \"dvb-pll.h\"\n#include \"tda1002x.h\"\n#include \"mt352.h\"\n#include \"mt352_priv.h\"\n#include \"zl10353.h\"\n#include \"tda18212.h\"\n#include \"cx24116.h\"\n#include \"stv0900.h\"\n#include \"stv6110.h\"\n#include \"isl6423.h\"\n#include \"cxd2820r.h\"\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic int anysee_ctrl_msg(struct dvb_usb_device *d,\n\t\tu8 *sbuf, u8 slen, u8 *rbuf, u8 rlen)\n{\n\tstruct anysee_state *state = d_to_priv(d);\n\tint act_len, ret, i;\n\n\tmutex_lock(&d->usb_mutex);\n\n\tmemcpy(&state->buf[0], sbuf, slen);\n\tstate->buf[60] = state->seq++;\n\n\tdev_dbg(&d->udev->dev, \"%s: >>> %*ph\\n\", __func__, slen, state->buf);\n\n\t \n\tret = dvb_usbv2_generic_rw_locked(d, state->buf, sizeof(state->buf),\n\t\t\tstate->buf, sizeof(state->buf));\n\tif (ret)\n\t\tgoto error_unlock;\n\n\t \n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\t \n\t\tret = usb_bulk_msg(d->udev, usb_rcvbulkpipe(d->udev,\n\t\t\t\td->props->generic_bulk_ctrl_endpoint),\n\t\t\t\tstate->buf, sizeof(state->buf), &act_len, 2000);\n\t\tif (ret) {\n\t\t\tdev_dbg(&d->udev->dev,\n\t\t\t\t\t\"%s: recv bulk message failed=%d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t} else {\n\t\t\tdev_dbg(&d->udev->dev, \"%s: <<< %*ph\\n\", __func__,\n\t\t\t\t\trlen, state->buf);\n\n\t\t\tif (state->buf[63] != 0x4f)\n\t\t\t\tdev_dbg(&d->udev->dev,\n\t\t\t\t\t\t\"%s: cmd failed\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret) {\n\t\t \n\t\tdev_err(&d->udev->dev, \"%s: recv bulk message failed=%d\\n\",\n\t\t\t\tKBUILD_MODNAME, ret);\n\t\tgoto error_unlock;\n\t}\n\n\t \n\tif (rbuf && rlen)\n\t\tmemcpy(rbuf, state->buf, rlen);\n\nerror_unlock:\n\tmutex_unlock(&d->usb_mutex);\n\treturn ret;\n}\n\nstatic int anysee_read_reg(struct dvb_usb_device *d, u16 reg, u8 *val)\n{\n\tu8 buf[] = {CMD_REG_READ, reg >> 8, reg & 0xff, 0x01};\n\tint ret;\n\tret = anysee_ctrl_msg(d, buf, sizeof(buf), val, 1);\n\tdev_dbg(&d->udev->dev, \"%s: reg=%04x val=%02x\\n\", __func__, reg, *val);\n\treturn ret;\n}\n\nstatic int anysee_write_reg(struct dvb_usb_device *d, u16 reg, u8 val)\n{\n\tu8 buf[] = {CMD_REG_WRITE, reg >> 8, reg & 0xff, 0x01, val};\n\tdev_dbg(&d->udev->dev, \"%s: reg=%04x val=%02x\\n\", __func__, reg, val);\n\treturn anysee_ctrl_msg(d, buf, sizeof(buf), NULL, 0);\n}\n\n \nstatic int anysee_wr_reg_mask(struct dvb_usb_device *d, u16 reg, u8 val,\n\tu8 mask)\n{\n\tint ret;\n\tu8 tmp;\n\n\t \n\tif (mask != 0xff) {\n\t\tret = anysee_read_reg(d, reg, &tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval &= mask;\n\t\ttmp &= ~mask;\n\t\tval |= tmp;\n\t}\n\n\treturn anysee_write_reg(d, reg, val);\n}\n\n \nstatic int anysee_rd_reg_mask(struct dvb_usb_device *d, u16 reg, u8 *val,\n\tu8 mask)\n{\n\tint ret, i;\n\tu8 tmp;\n\n\tret = anysee_read_reg(d, reg, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp &= mask;\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tif ((mask >> i) & 0x01)\n\t\t\tbreak;\n\t}\n\t*val = tmp >> i;\n\n\treturn 0;\n}\n\nstatic int anysee_get_hw_info(struct dvb_usb_device *d, u8 *id)\n{\n\tu8 buf[] = {CMD_GET_HW_INFO};\n\treturn anysee_ctrl_msg(d, buf, sizeof(buf), id, 3);\n}\n\nstatic int anysee_streaming_ctrl(struct dvb_frontend *fe, int onoff)\n{\n\tu8 buf[] = {CMD_STREAMING_CTRL, (u8)onoff, 0x00};\n\tdev_dbg(&fe_to_d(fe)->udev->dev, \"%s: onoff=%d\\n\", __func__, onoff);\n\treturn anysee_ctrl_msg(fe_to_d(fe), buf, sizeof(buf), NULL, 0);\n}\n\nstatic int anysee_led_ctrl(struct dvb_usb_device *d, u8 mode, u8 interval)\n{\n\tu8 buf[] = {CMD_LED_AND_IR_CTRL, 0x01, mode, interval};\n\tdev_dbg(&d->udev->dev, \"%s: state=%d interval=%d\\n\", __func__,\n\t\t\tmode, interval);\n\treturn anysee_ctrl_msg(d, buf, sizeof(buf), NULL, 0);\n}\n\nstatic int anysee_ir_ctrl(struct dvb_usb_device *d, u8 onoff)\n{\n\tu8 buf[] = {CMD_LED_AND_IR_CTRL, 0x02, onoff};\n\tdev_dbg(&d->udev->dev, \"%s: onoff=%d\\n\", __func__, onoff);\n\treturn anysee_ctrl_msg(d, buf, sizeof(buf), NULL, 0);\n}\n\n \nstatic int anysee_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msg,\n\tint num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint ret = 0, inc, i = 0;\n\tu8 buf[52];  \n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\twhile (i < num) {\n\t\tif (num > i + 1 && (msg[i+1].flags & I2C_M_RD)) {\n\t\t\tif (msg[i].len != 2 || msg[i + 1].len > 60) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf[0] = CMD_I2C_READ;\n\t\t\tbuf[1] = (msg[i].addr << 1) | 0x01;\n\t\t\tbuf[2] = msg[i].buf[0];\n\t\t\tbuf[3] = msg[i].buf[1];\n\t\t\tbuf[4] = msg[i].len-1;\n\t\t\tbuf[5] = msg[i+1].len;\n\t\t\tret = anysee_ctrl_msg(d, buf, 6, msg[i+1].buf,\n\t\t\t\tmsg[i+1].len);\n\t\t\tinc = 2;\n\t\t} else {\n\t\t\tif (msg[i].len > 48) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf[0] = CMD_I2C_WRITE;\n\t\t\tbuf[1] = (msg[i].addr << 1);\n\t\t\tbuf[2] = msg[i].len;\n\t\t\tbuf[3] = 0x01;\n\t\t\tmemcpy(&buf[4], msg[i].buf, msg[i].len);\n\t\t\tret = anysee_ctrl_msg(d, buf, 4 + msg[i].len, NULL, 0);\n\t\t\tinc = 1;\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\ti += inc;\n\t}\n\n\tmutex_unlock(&d->i2c_mutex);\n\n\treturn ret ? ret : i;\n}\n\nstatic u32 anysee_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm anysee_i2c_algo = {\n\t.master_xfer   = anysee_master_xfer,\n\t.functionality = anysee_i2c_func,\n};\n\nstatic int anysee_mt352_demod_init(struct dvb_frontend *fe)\n{\n\tstatic u8 clock_config[]   = { CLOCK_CTL,  0x38, 0x28 };\n\tstatic u8 reset[]          = { RESET,      0x80 };\n\tstatic u8 adc_ctl_1_cfg[]  = { ADC_CTL_1,  0x40 };\n\tstatic u8 agc_cfg[]        = { AGC_TARGET, 0x28, 0x20 };\n\tstatic u8 gpp_ctl_cfg[]    = { GPP_CTL,    0x33 };\n\tstatic u8 capt_range_cfg[] = { CAPT_RANGE, 0x32 };\n\n\tmt352_write(fe, clock_config,   sizeof(clock_config));\n\tudelay(200);\n\tmt352_write(fe, reset,          sizeof(reset));\n\tmt352_write(fe, adc_ctl_1_cfg,  sizeof(adc_ctl_1_cfg));\n\n\tmt352_write(fe, agc_cfg,        sizeof(agc_cfg));\n\tmt352_write(fe, gpp_ctl_cfg,    sizeof(gpp_ctl_cfg));\n\tmt352_write(fe, capt_range_cfg, sizeof(capt_range_cfg));\n\n\treturn 0;\n}\n\n \nstatic struct tda10023_config anysee_tda10023_config = {\n\t.demod_address = (0x1a >> 1),\n\t.invert = 0,\n\t.xtal   = 16000000,\n\t.pll_m  = 11,\n\t.pll_p  = 3,\n\t.pll_n  = 1,\n\t.output_mode = TDA10023_OUTPUT_MODE_PARALLEL_C,\n\t.deltaf = 0xfeeb,\n};\n\nstatic struct mt352_config anysee_mt352_config = {\n\t.demod_address = (0x1e >> 1),\n\t.demod_init    = anysee_mt352_demod_init,\n};\n\nstatic struct zl10353_config anysee_zl10353_config = {\n\t.demod_address = (0x1e >> 1),\n\t.parallel_ts = 1,\n};\n\nstatic struct zl10353_config anysee_zl10353_tda18212_config2 = {\n\t.demod_address = (0x1e >> 1),\n\t.parallel_ts = 1,\n\t.disable_i2c_gate_ctrl = 1,\n\t.no_tuner = 1,\n\t.if2 = 41500,\n};\n\nstatic struct zl10353_config anysee_zl10353_tda18212_config = {\n\t.demod_address = (0x18 >> 1),\n\t.parallel_ts = 1,\n\t.disable_i2c_gate_ctrl = 1,\n\t.no_tuner = 1,\n\t.if2 = 41500,\n};\n\nstatic struct tda10023_config anysee_tda10023_tda18212_config = {\n\t.demod_address = (0x1a >> 1),\n\t.xtal   = 16000000,\n\t.pll_m  = 12,\n\t.pll_p  = 3,\n\t.pll_n  = 1,\n\t.output_mode = TDA10023_OUTPUT_MODE_PARALLEL_B,\n\t.deltaf = 0xba02,\n};\n\nstatic const struct tda18212_config anysee_tda18212_config = {\n\t.if_dvbt_6 = 4150,\n\t.if_dvbt_7 = 4150,\n\t.if_dvbt_8 = 4150,\n\t.if_dvbc = 5000,\n};\n\nstatic const struct tda18212_config anysee_tda18212_config2 = {\n\t.if_dvbt_6 = 3550,\n\t.if_dvbt_7 = 3700,\n\t.if_dvbt_8 = 4150,\n\t.if_dvbt2_6 = 3250,\n\t.if_dvbt2_7 = 4000,\n\t.if_dvbt2_8 = 4000,\n\t.if_dvbc = 5000,\n};\n\nstatic struct cx24116_config anysee_cx24116_config = {\n\t.demod_address = (0xaa >> 1),\n\t.mpg_clk_pos_pol = 0x00,\n\t.i2c_wr_max = 48,\n};\n\nstatic struct stv0900_config anysee_stv0900_config = {\n\t.demod_address = (0xd0 >> 1),\n\t.demod_mode = 0,\n\t.xtal = 8000000,\n\t.clkmode = 3,\n\t.diseqc_mode = 2,\n\t.tun1_maddress = 0,\n\t.tun1_adc = 1,  \n\t.path1_mode = 3,\n};\n\nstatic struct stv6110_config anysee_stv6110_config = {\n\t.i2c_address = (0xc0 >> 1),\n\t.mclk = 16000000,\n\t.clk_div = 1,\n};\n\nstatic struct isl6423_config anysee_isl6423_config = {\n\t.current_max = SEC_CURRENT_800m,\n\t.curlim  = SEC_CURRENT_LIM_OFF,\n\t.mod_extern = 1,\n\t.addr = (0x10 >> 1),\n};\n\nstatic struct cxd2820r_config anysee_cxd2820r_config = {\n\t.i2c_address = 0x6d,  \n\t.ts_mode = 0x38,\n};\n\n \n\nstatic int anysee_read_config(struct dvb_usb_device *d)\n{\n\tstruct anysee_state *state = d_to_priv(d);\n\tint ret;\n\tu8 hw_info[3];\n\n\t \n\tret = anysee_get_hw_info(d, hw_info);\n\tif (ret)\n\t\tgoto error;\n\n\tret = anysee_get_hw_info(d, hw_info);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tdev_info(&d->udev->dev, \"%s: firmware version %d.%d hardware id %d\\n\",\n\t\t\tKBUILD_MODNAME, hw_info[1], hw_info[2], hw_info[0]);\n\n\tstate->hw = hw_info[0];\nerror:\n\treturn ret;\n}\n\n \nstatic int anysee_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\t \n\treturn anysee_wr_reg_mask(fe_to_d(fe), REG_IOE, (enable << 4), 0x10);\n}\n\nstatic int anysee_frontend_ctrl(struct dvb_frontend *fe, int onoff)\n{\n\tstruct anysee_state *state = fe_to_priv(fe);\n\tstruct dvb_usb_device *d = fe_to_d(fe);\n\tint ret;\n\tdev_dbg(&d->udev->dev, \"%s: fe=%d onoff=%d\\n\", __func__, fe->id, onoff);\n\n\t \n\tif (onoff == 0)\n\t\treturn 0;\n\n\tswitch (state->hw) {\n\tcase ANYSEE_HW_507FA:  \n\t\t \n\t\t \n\n\t\tif (fe->id == 0)  {\n\t\t\t \n\t\t\tret = anysee_wr_reg_mask(d, REG_IOD, (0 << 0), 0x01);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\n\t\t\t \n\t\t\tret = anysee_wr_reg_mask(d, REG_IOD, (1 << 5), 0x20);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\n\t\t\t \n\t\t\tret = anysee_wr_reg_mask(d, REG_IOE, (1 << 0), 0x01);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t} else {\n\t\t\t \n\t\t\tret = anysee_wr_reg_mask(d, REG_IOD, (0 << 5), 0x20);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\n\t\t\t \n\t\t\tret = anysee_wr_reg_mask(d, REG_IOD, (1 << 0), 0x01);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\n\t\t\t \n\t\t\tret = anysee_wr_reg_mask(d, REG_IOE, (0 << 0), 0x01);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tbreak;\n\tcase ANYSEE_HW_508TC:  \n\tcase ANYSEE_HW_508PTC:  \n\t\t \n\t\t \n\n\t\tif (fe->id == 0)  {\n\t\t\t \n\t\t\tret = anysee_wr_reg_mask(d, REG_IOD, (0 << 6), 0x40);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\n\t\t\t \n\t\t\tret = anysee_wr_reg_mask(d, REG_IOD, (1 << 5), 0x20);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\n\t\t\t \n\t\t\tret = anysee_wr_reg_mask(d, REG_IOE, (1 << 0), 0x01);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t} else {\n\t\t\t \n\t\t\tret = anysee_wr_reg_mask(d, REG_IOD, (0 << 5), 0x20);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\n\t\t\t \n\t\t\tret = anysee_wr_reg_mask(d, REG_IOD, (1 << 6), 0x40);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\n\t\t\t \n\t\t\tret = anysee_wr_reg_mask(d, REG_IOE, (0 << 0), 0x01);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t}\n\nerror:\n\treturn ret;\n}\n\nstatic int anysee_add_i2c_dev(struct dvb_usb_device *d, const char *type,\n\t\tu8 addr, void *platform_data)\n{\n\tint ret, num;\n\tstruct anysee_state *state = d_to_priv(d);\n\tstruct i2c_client *client;\n\tstruct i2c_adapter *adapter = &d->i2c_adap;\n\tstruct i2c_board_info board_info = {\n\t\t.addr = addr,\n\t\t.platform_data = platform_data,\n\t};\n\n\tstrscpy(board_info.type, type, I2C_NAME_SIZE);\n\n\t \n\tfor (num = 0; num < ANYSEE_I2C_CLIENT_MAX; num++) {\n\t\tif (state->i2c_client[num] == NULL)\n\t\t\tbreak;\n\t}\n\n\tdev_dbg(&d->udev->dev, \"%s: num=%d\\n\", __func__, num);\n\n\tif (num == ANYSEE_I2C_CLIENT_MAX) {\n\t\tdev_err(&d->udev->dev, \"%s: I2C client out of index\\n\",\n\t\t\t\tKBUILD_MODNAME);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\trequest_module(\"%s\", board_info.type);\n\n\t \n\tclient = i2c_new_client_device(adapter, &board_info);\n\tif (!i2c_client_has_driver(client)) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t \n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tstate->i2c_client[num] = client;\n\treturn 0;\nerr:\n\tdev_dbg(&d->udev->dev, \"%s: failed=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic void anysee_del_i2c_dev(struct dvb_usb_device *d)\n{\n\tint num;\n\tstruct anysee_state *state = d_to_priv(d);\n\tstruct i2c_client *client;\n\n\t \n\tnum = ANYSEE_I2C_CLIENT_MAX;\n\twhile (num--) {\n\t\tif (state->i2c_client[num] != NULL)\n\t\t\tbreak;\n\t}\n\n\tdev_dbg(&d->udev->dev, \"%s: num=%d\\n\", __func__, num);\n\n\tif (num == -1) {\n\t\tdev_err(&d->udev->dev, \"%s: I2C client out of index\\n\",\n\t\t\t\tKBUILD_MODNAME);\n\t\tgoto err;\n\t}\n\n\tclient = state->i2c_client[num];\n\n\t \n\tmodule_put(client->dev.driver->owner);\n\n\t \n\ti2c_unregister_device(client);\n\n\tstate->i2c_client[num] = NULL;\nerr:\n\tdev_dbg(&d->udev->dev, \"%s: failed\\n\", __func__);\n}\n\nstatic int anysee_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct anysee_state *state = adap_to_priv(adap);\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tint ret = 0;\n\tu8 tmp;\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = 0x60,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = \"\\x00\",\n\t\t}, {\n\t\t\t.addr = 0x60,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 1,\n\t\t\t.buf = &tmp,\n\t\t}\n\t};\n\n\tswitch (state->hw) {\n\tcase ANYSEE_HW_507T:  \n\t\t \n\n\t\t \n\t\tadap->fe[0] = dvb_attach(mt352_attach, &anysee_mt352_config,\n\t\t\t\t&d->i2c_adap);\n\t\tif (adap->fe[0])\n\t\t\tbreak;\n\n\t\t \n\t\tadap->fe[0] = dvb_attach(zl10353_attach, &anysee_zl10353_config,\n\t\t\t\t&d->i2c_adap);\n\n\t\tbreak;\n\tcase ANYSEE_HW_507CD:  \n\t\t \n\n\t\t \n\t\tret = anysee_wr_reg_mask(d, REG_IOD, (1 << 0), 0x01);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\t \n\t\tret = anysee_wr_reg_mask(d, REG_IOA, (0 << 7), 0x80);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\t \n\t\tadap->fe[0] = dvb_attach(zl10353_attach, &anysee_zl10353_config,\n\t\t\t\t&d->i2c_adap);\n\n\t\tbreak;\n\tcase ANYSEE_HW_507DC:  \n\t\t \n\n\t\t \n\t\tret = anysee_wr_reg_mask(d, REG_IOD, (1 << 0), 0x01);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\t \n\t\tadap->fe[0] = dvb_attach(tda10023_attach,\n\t\t\t\t&anysee_tda10023_config, &d->i2c_adap, 0x48);\n\n\t\tbreak;\n\tcase ANYSEE_HW_507SI:  \n\t\t \n\n\t\t \n\t\tret = anysee_wr_reg_mask(d, REG_IOD, (1 << 0), 0x01);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\t \n\t\tadap->fe[0] = dvb_attach(cx24116_attach, &anysee_cx24116_config,\n\t\t\t\t&d->i2c_adap);\n\n\t\tbreak;\n\tcase ANYSEE_HW_507FA:  \n\t\t \n\t\t \n\n\t\t \n\t\tret = anysee_wr_reg_mask(d, REG_IOE, (1 << 4), 0x10);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\t \n\t\ttmp = 0;\n\t\tret = i2c_transfer(&d->i2c_adap, msg, 2);\n\t\tif (ret == 2 && tmp == 0xc7) {\n\t\t\tdev_dbg(&d->udev->dev, \"%s: TDA18212 found\\n\",\n\t\t\t\t\t__func__);\n\t\t\tstate->has_tda18212 = true;\n\t\t}\n\t\telse\n\t\t\ttmp = 0;\n\n\t\t \n\t\tret = anysee_wr_reg_mask(d, REG_IOE, (0 << 4), 0x10);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\t \n\t\tret = anysee_wr_reg_mask(d, REG_IOD, (0 << 0), 0x01);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\t \n\t\tret = anysee_wr_reg_mask(d, REG_IOD, (1 << 5), 0x20);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\t \n\t\tif (tmp == 0xc7) {\n\t\t\t \n\t\t\tadap->fe[0] = dvb_attach(tda10023_attach,\n\t\t\t\t\t&anysee_tda10023_tda18212_config,\n\t\t\t\t\t&d->i2c_adap, 0x48);\n\n\t\t\t \n\t\t\tif (adap->fe[0])\n\t\t\t\tadap->fe[0]->ops.i2c_gate_ctrl =\n\t\t\t\t\t\tanysee_i2c_gate_ctrl;\n\t\t} else {\n\t\t\t \n\t\t\tadap->fe[0] = dvb_attach(tda10023_attach,\n\t\t\t\t\t&anysee_tda10023_config,\n\t\t\t\t\t&d->i2c_adap, 0x48);\n\t\t}\n\n\t\t \n\t\tif (!adap->fe[0])\n\t\t\tbreak;\n\n\t\t \n\t\tret = anysee_wr_reg_mask(d, REG_IOD, (0 << 5), 0x20);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\t \n\t\tret = anysee_wr_reg_mask(d, REG_IOD, (1 << 0), 0x01);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\t \n\t\tif (tmp == 0xc7) {\n\t\t\t \n\t\t\tadap->fe[1] = dvb_attach(zl10353_attach,\n\t\t\t\t\t&anysee_zl10353_tda18212_config2,\n\t\t\t\t\t&d->i2c_adap);\n\n\t\t\t \n\t\t\tif (adap->fe[1])\n\t\t\t\tadap->fe[1]->ops.i2c_gate_ctrl =\n\t\t\t\t\t\tanysee_i2c_gate_ctrl;\n\t\t} else {\n\t\t\t \n\t\t\tadap->fe[1] = dvb_attach(zl10353_attach,\n\t\t\t\t\t&anysee_zl10353_config,\n\t\t\t\t\t&d->i2c_adap);\n\t\t}\n\n\t\tbreak;\n\tcase ANYSEE_HW_508TC:  \n\tcase ANYSEE_HW_508PTC:  \n\t\t \n\t\t \n\n\t\t \n\t\tret = anysee_wr_reg_mask(d, REG_IOD, (0 << 6), 0x40);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\t \n\t\tret = anysee_wr_reg_mask(d, REG_IOD, (1 << 5), 0x20);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\t \n\t\tadap->fe[0] = dvb_attach(tda10023_attach,\n\t\t\t\t&anysee_tda10023_tda18212_config,\n\t\t\t\t&d->i2c_adap, 0x48);\n\n\t\t \n\t\tif (adap->fe[0])\n\t\t\tadap->fe[0]->ops.i2c_gate_ctrl = anysee_i2c_gate_ctrl;\n\n\t\t \n\t\tif (!adap->fe[0])\n\t\t\tbreak;\n\n\t\t \n\t\tret = anysee_wr_reg_mask(d, REG_IOD, (0 << 5), 0x20);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\t \n\t\tret = anysee_wr_reg_mask(d, REG_IOD, (1 << 6), 0x40);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\t \n\t\tadap->fe[1] = dvb_attach(zl10353_attach,\n\t\t\t\t&anysee_zl10353_tda18212_config,\n\t\t\t\t&d->i2c_adap);\n\n\t\t \n\t\tif (adap->fe[1])\n\t\t\tadap->fe[1]->ops.i2c_gate_ctrl = anysee_i2c_gate_ctrl;\n\n\t\tstate->has_ci = true;\n\n\t\tbreak;\n\tcase ANYSEE_HW_508S2:  \n\tcase ANYSEE_HW_508PS2:  \n\t\t \n\t\t \n\n\t\t \n\t\tret = anysee_wr_reg_mask(d, REG_IOE, (1 << 5), 0x20);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\t \n\t\tadap->fe[0] = dvb_attach(stv0900_attach,\n\t\t\t\t&anysee_stv0900_config, &d->i2c_adap, 0);\n\n\t\tstate->has_ci = true;\n\n\t\tbreak;\n\tcase ANYSEE_HW_508T2C:  \n\t\t \n\n\t\t \n\t\tret = anysee_wr_reg_mask(d, REG_IOE, (1 << 5), 0x20);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\t \n\t\tadap->fe[0] = dvb_attach(cxd2820r_attach,\n\t\t\t\t&anysee_cxd2820r_config, &d->i2c_adap, NULL);\n\n\t\tstate->has_ci = true;\n\n\t\tbreak;\n\t}\n\n\tif (!adap->fe[0]) {\n\t\t \n\t\tret = -ENODEV;\n\t\tdev_err(&d->udev->dev,\n\t\t\t\t\"%s: Unsupported Anysee version. Please report to <linux-media@vger.kernel.org>.\\n\",\n\t\t\t\tKBUILD_MODNAME);\n\t}\nerror:\n\treturn ret;\n}\n\nstatic int anysee_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct anysee_state *state = adap_to_priv(adap);\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct dvb_frontend *fe;\n\tint ret;\n\tdev_dbg(&d->udev->dev, \"%s:\\n\", __func__);\n\n\tswitch (state->hw) {\n\tcase ANYSEE_HW_507T:  \n\t\t \n\n\t\t \n\t\tfe = dvb_attach(dvb_pll_attach, adap->fe[0], (0xc2 >> 1), NULL,\n\t\t\t\tDVB_PLL_THOMSON_DTT7579);\n\n\t\tbreak;\n\tcase ANYSEE_HW_507CD:  \n\t\t \n\n\t\t \n\t\tfe = dvb_attach(dvb_pll_attach, adap->fe[0], (0xc2 >> 1),\n\t\t\t\t&d->i2c_adap, DVB_PLL_THOMSON_DTT7579);\n\n\t\tbreak;\n\tcase ANYSEE_HW_507DC:  \n\t\t \n\n\t\t \n\t\tfe = dvb_attach(dvb_pll_attach, adap->fe[0], (0xc0 >> 1),\n\t\t\t\t&d->i2c_adap, DVB_PLL_SAMSUNG_DTOS403IH102A);\n\n\t\tbreak;\n\tcase ANYSEE_HW_507SI:  \n\t\t \n\n\t\t \n\t\tfe = dvb_attach(isl6423_attach, adap->fe[0], &d->i2c_adap,\n\t\t\t\t&anysee_isl6423_config);\n\n\t\tbreak;\n\tcase ANYSEE_HW_507FA:  \n\t\t \n\t\t \n\n\t\t \n\n\t\t \n\t\tif (state->has_tda18212) {\n\t\t\tstruct tda18212_config tda18212_config =\n\t\t\t\t\tanysee_tda18212_config;\n\n\t\t\ttda18212_config.fe = adap->fe[0];\n\t\t\tret = anysee_add_i2c_dev(d, \"tda18212\", 0x60,\n\t\t\t\t\t&tda18212_config);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\t \n\t\t\tif (adap->fe[1]) {\n\t\t\t\tadap->fe[1]->tuner_priv =\n\t\t\t\t\t\tadap->fe[0]->tuner_priv;\n\t\t\t\tmemcpy(&adap->fe[1]->ops.tuner_ops,\n\t\t\t\t\t\t&adap->fe[0]->ops.tuner_ops,\n\t\t\t\t\t\tsizeof(struct dvb_tuner_ops));\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t \n\t\t\tfe = dvb_attach(dvb_pll_attach, adap->fe[0],\n\t\t\t\t\t(0xc0 >> 1), &d->i2c_adap,\n\t\t\t\t\tDVB_PLL_SAMSUNG_DTOS403IH102A);\n\n\t\t\tif (fe && adap->fe[1]) {\n\t\t\t\t \n\t\t\t\tfe = dvb_attach(dvb_pll_attach, adap->fe[1],\n\t\t\t\t\t\t(0xc0 >> 1), &d->i2c_adap,\n\t\t\t\t\t\tDVB_PLL_SAMSUNG_DTOS403IH102A);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\tcase ANYSEE_HW_508TC:  \n\tcase ANYSEE_HW_508PTC:  \n\t{\n\t\t \n\t\t \n\t\tstruct tda18212_config tda18212_config = anysee_tda18212_config;\n\n\t\ttda18212_config.fe = adap->fe[0];\n\t\tret = anysee_add_i2c_dev(d, \"tda18212\", 0x60, &tda18212_config);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tif (adap->fe[1]) {\n\t\t\tadap->fe[1]->tuner_priv = adap->fe[0]->tuner_priv;\n\t\t\tmemcpy(&adap->fe[1]->ops.tuner_ops,\n\t\t\t\t\t&adap->fe[0]->ops.tuner_ops,\n\t\t\t\t\tsizeof(struct dvb_tuner_ops));\n\t\t}\n\n\t\treturn 0;\n\t}\n\tcase ANYSEE_HW_508S2:  \n\tcase ANYSEE_HW_508PS2:  \n\t\t \n\t\t \n\n\t\t \n\t\tfe = dvb_attach(stv6110_attach, adap->fe[0],\n\t\t\t\t&anysee_stv6110_config, &d->i2c_adap);\n\n\t\tif (fe) {\n\t\t\t \n\t\t\tfe = dvb_attach(isl6423_attach, adap->fe[0],\n\t\t\t\t\t&d->i2c_adap, &anysee_isl6423_config);\n\t\t}\n\n\t\tbreak;\n\n\tcase ANYSEE_HW_508T2C:  \n\t{\n\t\t \n\t\tstruct tda18212_config tda18212_config =\n\t\t\t\tanysee_tda18212_config2;\n\n\t\ttda18212_config.fe = adap->fe[0];\n\t\tret = anysee_add_i2c_dev(d, \"tda18212\", 0x60, &tda18212_config);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\treturn 0;\n\t}\n\tdefault:\n\t\tfe = NULL;\n\t}\n\n\tif (fe)\n\t\tret = 0;\n\telse\n\t\tret = -ENODEV;\nerr:\n\treturn ret;\n}\n\n#if IS_ENABLED(CONFIG_RC_CORE)\nstatic int anysee_rc_query(struct dvb_usb_device *d)\n{\n\tu8 buf[] = {CMD_GET_IR_CODE};\n\tu8 ircode[2];\n\tint ret;\n\n\t \n\n\tret = anysee_ctrl_msg(d, buf, sizeof(buf), ircode, sizeof(ircode));\n\tif (ret)\n\t\treturn ret;\n\n\tif (ircode[0]) {\n\t\tdev_dbg(&d->udev->dev, \"%s: key pressed %02x\\n\", __func__,\n\t\t\t\tircode[1]);\n\t\trc_keydown(d->rc_dev, RC_PROTO_NEC,\n\t\t\t   RC_SCANCODE_NEC(0x08, ircode[1]), 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int anysee_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)\n{\n\trc->allowed_protos = RC_PROTO_BIT_NEC;\n\trc->query          = anysee_rc_query;\n\trc->interval       = 250;   \n\n\treturn 0;\n}\n#else\n\t#define anysee_get_rc_config NULL\n#endif\n\nstatic int anysee_ci_read_attribute_mem(struct dvb_ca_en50221 *ci, int slot,\n\tint addr)\n{\n\tstruct dvb_usb_device *d = ci->data;\n\tint ret;\n\tu8 buf[] = {CMD_CI, 0x02, 0x40 | addr >> 8, addr & 0xff, 0x00, 1};\n\tu8 val;\n\n\tret = anysee_ctrl_msg(d, buf, sizeof(buf), &val, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn val;\n}\n\nstatic int anysee_ci_write_attribute_mem(struct dvb_ca_en50221 *ci, int slot,\n\tint addr, u8 val)\n{\n\tstruct dvb_usb_device *d = ci->data;\n\tu8 buf[] = {CMD_CI, 0x03, 0x40 | addr >> 8, addr & 0xff, 0x00, 1, val};\n\n\treturn anysee_ctrl_msg(d, buf, sizeof(buf), NULL, 0);\n}\n\nstatic int anysee_ci_read_cam_control(struct dvb_ca_en50221 *ci, int slot,\n\tu8 addr)\n{\n\tstruct dvb_usb_device *d = ci->data;\n\tint ret;\n\tu8 buf[] = {CMD_CI, 0x04, 0x40, addr, 0x00, 1};\n\tu8 val;\n\n\tret = anysee_ctrl_msg(d, buf, sizeof(buf), &val, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn val;\n}\n\nstatic int anysee_ci_write_cam_control(struct dvb_ca_en50221 *ci, int slot,\n\tu8 addr, u8 val)\n{\n\tstruct dvb_usb_device *d = ci->data;\n\tu8 buf[] = {CMD_CI, 0x05, 0x40, addr, 0x00, 1, val};\n\n\treturn anysee_ctrl_msg(d, buf, sizeof(buf), NULL, 0);\n}\n\nstatic int anysee_ci_slot_reset(struct dvb_ca_en50221 *ci, int slot)\n{\n\tstruct dvb_usb_device *d = ci->data;\n\tint ret;\n\tstruct anysee_state *state = d_to_priv(d);\n\n\tstate->ci_cam_ready = jiffies + msecs_to_jiffies(1000);\n\n\tret = anysee_wr_reg_mask(d, REG_IOA, (0 << 7), 0x80);\n\tif (ret)\n\t\treturn ret;\n\n\tmsleep(300);\n\n\tret = anysee_wr_reg_mask(d, REG_IOA, (1 << 7), 0x80);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int anysee_ci_slot_shutdown(struct dvb_ca_en50221 *ci, int slot)\n{\n\tstruct dvb_usb_device *d = ci->data;\n\tint ret;\n\n\tret = anysee_wr_reg_mask(d, REG_IOA, (0 << 7), 0x80);\n\tif (ret)\n\t\treturn ret;\n\n\tmsleep(30);\n\n\tret = anysee_wr_reg_mask(d, REG_IOA, (1 << 7), 0x80);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int anysee_ci_slot_ts_enable(struct dvb_ca_en50221 *ci, int slot)\n{\n\tstruct dvb_usb_device *d = ci->data;\n\n\treturn anysee_wr_reg_mask(d, REG_IOD, (0 << 1), 0x02);\n}\n\nstatic int anysee_ci_poll_slot_status(struct dvb_ca_en50221 *ci, int slot,\n\tint open)\n{\n\tstruct dvb_usb_device *d = ci->data;\n\tstruct anysee_state *state = d_to_priv(d);\n\tint ret;\n\tu8 tmp = 0;\n\n\tret = anysee_rd_reg_mask(d, REG_IOC, &tmp, 0x40);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tmp == 0) {\n\t\tret = DVB_CA_EN50221_POLL_CAM_PRESENT;\n\t\tif (time_after(jiffies, state->ci_cam_ready))\n\t\t\tret |= DVB_CA_EN50221_POLL_CAM_READY;\n\t}\n\n\treturn ret;\n}\n\nstatic int anysee_ci_init(struct dvb_usb_device *d)\n{\n\tstruct anysee_state *state = d_to_priv(d);\n\tint ret;\n\n\tstate->ci.owner               = THIS_MODULE;\n\tstate->ci.read_attribute_mem  = anysee_ci_read_attribute_mem;\n\tstate->ci.write_attribute_mem = anysee_ci_write_attribute_mem;\n\tstate->ci.read_cam_control    = anysee_ci_read_cam_control;\n\tstate->ci.write_cam_control   = anysee_ci_write_cam_control;\n\tstate->ci.slot_reset          = anysee_ci_slot_reset;\n\tstate->ci.slot_shutdown       = anysee_ci_slot_shutdown;\n\tstate->ci.slot_ts_enable      = anysee_ci_slot_ts_enable;\n\tstate->ci.poll_slot_status    = anysee_ci_poll_slot_status;\n\tstate->ci.data                = d;\n\n\tret = anysee_wr_reg_mask(d, REG_IOA, (1 << 7), 0x80);\n\tif (ret)\n\t\treturn ret;\n\n\tret = anysee_wr_reg_mask(d, REG_IOD, (0 << 2)|(0 << 1)|(0 << 0), 0x07);\n\tif (ret)\n\t\treturn ret;\n\n\tret = anysee_wr_reg_mask(d, REG_IOD, (1 << 2)|(1 << 1)|(1 << 0), 0x07);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dvb_ca_en50221_init(&d->adapter[0].dvb_adap, &state->ci, 0, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tstate->ci_attached = true;\n\n\treturn 0;\n}\n\nstatic void anysee_ci_release(struct dvb_usb_device *d)\n{\n\tstruct anysee_state *state = d_to_priv(d);\n\n\t \n\tif (state->ci_attached)\n\t\tdvb_ca_en50221_release(&state->ci);\n\n\treturn;\n}\n\nstatic int anysee_init(struct dvb_usb_device *d)\n{\n\tstruct anysee_state *state = d_to_priv(d);\n\tint ret;\n\n\t \n\tret = usb_set_interface(d->udev, 0, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = anysee_led_ctrl(d, 0x01, 0x03);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = anysee_ir_ctrl(d, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (state->has_ci) {\n\t\tret = anysee_ci_init(d);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void anysee_exit(struct dvb_usb_device *d)\n{\n\tstruct anysee_state *state = d_to_priv(d);\n\n\tif (state->i2c_client[0])\n\t\tanysee_del_i2c_dev(d);\n\n\treturn anysee_ci_release(d);\n}\n\n \nstatic struct dvb_usb_device_properties anysee_props = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\t.size_of_priv = sizeof(struct anysee_state),\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\t.generic_bulk_ctrl_endpoint_response = 0x81,\n\n\t.i2c_algo         = &anysee_i2c_algo,\n\t.read_config      = anysee_read_config,\n\t.frontend_attach  = anysee_frontend_attach,\n\t.tuner_attach     = anysee_tuner_attach,\n\t.init             = anysee_init,\n\t.get_rc_config    = anysee_get_rc_config,\n\t.frontend_ctrl    = anysee_frontend_ctrl,\n\t.streaming_ctrl   = anysee_streaming_ctrl,\n\t.exit             = anysee_exit,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t\t.stream = DVB_USB_STREAM_BULK(0x82, 8, 16 * 512),\n\t\t}\n\t}\n};\n\nstatic const struct usb_device_id anysee_id_table[] = {\n\t{ DVB_USB_DEVICE(USB_VID_CYPRESS, USB_PID_ANYSEE,\n\t\t&anysee_props, \"Anysee\", RC_MAP_ANYSEE) },\n\t{ DVB_USB_DEVICE(USB_VID_AMT, USB_PID_ANYSEE,\n\t\t&anysee_props, \"Anysee\", RC_MAP_ANYSEE) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, anysee_id_table);\n\nstatic struct usb_driver anysee_usb_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = anysee_id_table,\n\t.probe = dvb_usbv2_probe,\n\t.disconnect = dvb_usbv2_disconnect,\n\t.suspend = dvb_usbv2_suspend,\n\t.resume = dvb_usbv2_resume,\n\t.reset_resume = dvb_usbv2_reset_resume,\n\t.no_dynamic_id = 1,\n\t.soft_unbind = 1,\n};\n\nmodule_usb_driver(anysee_usb_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"Driver Anysee E30 DVB-C & DVB-T USB2.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}