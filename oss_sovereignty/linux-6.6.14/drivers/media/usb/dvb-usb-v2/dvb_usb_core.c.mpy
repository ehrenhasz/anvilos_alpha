{
  "module_name": "dvb_usb_core.c",
  "hash_id": "f45dedfec89a3c8e872fd083e5a8f1afb5c4ae2fdbad52e76b6b350207c2f356",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c",
  "human_readable_source": "\n \n\n#include \"dvb_usb_common.h\"\n#include <media/media-device.h>\n\nstatic int dvb_usbv2_disable_rc_polling;\nmodule_param_named(disable_rc_polling, dvb_usbv2_disable_rc_polling, int, 0644);\nMODULE_PARM_DESC(disable_rc_polling,\n\t\t\"disable remote control polling (default: 0)\");\nstatic int dvb_usb_force_pid_filter_usage;\nmodule_param_named(force_pid_filter_usage, dvb_usb_force_pid_filter_usage,\n\t\tint, 0444);\nMODULE_PARM_DESC(force_pid_filter_usage,\n\t\t\"force all DVB USB devices to use a PID filter, if any (default: 0)\");\n\nstatic int dvb_usbv2_download_firmware(struct dvb_usb_device *d,\n\t\tconst char *name)\n{\n\tint ret;\n\tconst struct firmware *fw;\n\tdev_dbg(&d->udev->dev, \"%s:\\n\", __func__);\n\n\tif (!d->props->download_firmware) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = request_firmware(&fw, name, &d->udev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&d->udev->dev,\n\t\t\t\t\"%s: Did not find the firmware file '%s' (status %d). You can use <kernel_dir>/scripts/get_dvb_firmware to get the firmware\\n\",\n\t\t\t\tKBUILD_MODNAME, name, ret);\n\t\tgoto err;\n\t}\n\n\tdev_info(&d->udev->dev, \"%s: downloading firmware from file '%s'\\n\",\n\t\t\tKBUILD_MODNAME, name);\n\n\tret = d->props->download_firmware(d, fw);\n\trelease_firmware(fw);\n\tif (ret < 0)\n\t\tgoto err;\n\n\treturn ret;\nerr:\n\tdev_dbg(&d->udev->dev, \"%s: failed=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int dvb_usbv2_i2c_init(struct dvb_usb_device *d)\n{\n\tint ret;\n\tdev_dbg(&d->udev->dev, \"%s:\\n\", __func__);\n\n\tif (!d->props->i2c_algo)\n\t\treturn 0;\n\n\tstrscpy(d->i2c_adap.name, d->name, sizeof(d->i2c_adap.name));\n\td->i2c_adap.algo = d->props->i2c_algo;\n\td->i2c_adap.dev.parent = &d->udev->dev;\n\ti2c_set_adapdata(&d->i2c_adap, d);\n\n\tret = i2c_add_adapter(&d->i2c_adap);\n\tif (ret < 0) {\n\t\td->i2c_adap.algo = NULL;\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&d->udev->dev, \"%s: failed=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int dvb_usbv2_i2c_exit(struct dvb_usb_device *d)\n{\n\tdev_dbg(&d->udev->dev, \"%s:\\n\", __func__);\n\n\tif (d->i2c_adap.algo)\n\t\ti2c_del_adapter(&d->i2c_adap);\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_RC_CORE)\nstatic void dvb_usb_read_remote_control(struct work_struct *work)\n{\n\tstruct dvb_usb_device *d = container_of(work,\n\t\t\tstruct dvb_usb_device, rc_query_work.work);\n\tint ret;\n\n\t \n\tif (dvb_usbv2_disable_rc_polling || d->rc.bulk_mode) {\n\t\td->rc_polling_active = false;\n\t\treturn;\n\t}\n\n\tret = d->rc.query(d);\n\tif (ret < 0) {\n\t\tdev_err(&d->udev->dev, \"%s: rc.query() failed=%d\\n\",\n\t\t\t\tKBUILD_MODNAME, ret);\n\t\td->rc_polling_active = false;\n\t\treturn;  \n\t}\n\n\tschedule_delayed_work(&d->rc_query_work,\n\t\t\tmsecs_to_jiffies(d->rc.interval));\n}\n\nstatic int dvb_usbv2_remote_init(struct dvb_usb_device *d)\n{\n\tint ret;\n\tstruct rc_dev *dev;\n\tdev_dbg(&d->udev->dev, \"%s:\\n\", __func__);\n\n\tif (dvb_usbv2_disable_rc_polling || !d->props->get_rc_config)\n\t\treturn 0;\n\n\td->rc.map_name = d->rc_map;\n\tret = d->props->get_rc_config(d, &d->rc);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tif (!d->rc.map_name)\n\t\treturn 0;\n\n\tdev = rc_allocate_device(d->rc.driver_type);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tdev->dev.parent = &d->udev->dev;\n\tdev->device_name = d->name;\n\tusb_make_path(d->udev, d->rc_phys, sizeof(d->rc_phys));\n\tstrlcat(d->rc_phys, \"/ir0\", sizeof(d->rc_phys));\n\tdev->input_phys = d->rc_phys;\n\tusb_to_input_id(d->udev, &dev->input_id);\n\tdev->driver_name = d->props->driver_name;\n\tdev->map_name = d->rc.map_name;\n\tdev->allowed_protocols = d->rc.allowed_protos;\n\tdev->change_protocol = d->rc.change_protocol;\n\tdev->timeout = d->rc.timeout;\n\tdev->priv = d;\n\n\tret = rc_register_device(dev);\n\tif (ret < 0) {\n\t\trc_free_device(dev);\n\t\tgoto err;\n\t}\n\n\td->rc_dev = dev;\n\n\t \n\tif (d->rc.query && !d->rc.bulk_mode) {\n\t\t \n\t\tINIT_DELAYED_WORK(&d->rc_query_work,\n\t\t\t\tdvb_usb_read_remote_control);\n\t\tdev_info(&d->udev->dev,\n\t\t\t\t\"%s: schedule remote query interval to %d msecs\\n\",\n\t\t\t\tKBUILD_MODNAME, d->rc.interval);\n\t\tschedule_delayed_work(&d->rc_query_work,\n\t\t\t\tmsecs_to_jiffies(d->rc.interval));\n\t\td->rc_polling_active = true;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&d->udev->dev, \"%s: failed=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int dvb_usbv2_remote_exit(struct dvb_usb_device *d)\n{\n\tdev_dbg(&d->udev->dev, \"%s:\\n\", __func__);\n\n\tif (d->rc_dev) {\n\t\tcancel_delayed_work_sync(&d->rc_query_work);\n\t\trc_unregister_device(d->rc_dev);\n\t\td->rc_dev = NULL;\n\t}\n\n\treturn 0;\n}\n#else\n\t#define dvb_usbv2_remote_init(args...) 0\n\t#define dvb_usbv2_remote_exit(args...)\n#endif\n\nstatic void dvb_usb_data_complete(struct usb_data_stream *stream, u8 *buf,\n\t\tsize_t len)\n{\n\tstruct dvb_usb_adapter *adap = stream->user_priv;\n\tdvb_dmx_swfilter(&adap->demux, buf, len);\n}\n\nstatic void dvb_usb_data_complete_204(struct usb_data_stream *stream, u8 *buf,\n\t\tsize_t len)\n{\n\tstruct dvb_usb_adapter *adap = stream->user_priv;\n\tdvb_dmx_swfilter_204(&adap->demux, buf, len);\n}\n\nstatic void dvb_usb_data_complete_raw(struct usb_data_stream *stream, u8 *buf,\n\t\tsize_t len)\n{\n\tstruct dvb_usb_adapter *adap = stream->user_priv;\n\tdvb_dmx_swfilter_raw(&adap->demux, buf, len);\n}\n\nstatic int dvb_usbv2_adapter_stream_init(struct dvb_usb_adapter *adap)\n{\n\tdev_dbg(&adap_to_d(adap)->udev->dev, \"%s: adap=%d\\n\", __func__,\n\t\t\tadap->id);\n\n\tadap->stream.udev = adap_to_d(adap)->udev;\n\tadap->stream.user_priv = adap;\n\tadap->stream.complete = dvb_usb_data_complete;\n\n\treturn usb_urb_initv2(&adap->stream, &adap->props->stream);\n}\n\nstatic int dvb_usbv2_adapter_stream_exit(struct dvb_usb_adapter *adap)\n{\n\tdev_dbg(&adap_to_d(adap)->udev->dev, \"%s: adap=%d\\n\", __func__,\n\t\t\tadap->id);\n\n\treturn usb_urb_exitv2(&adap->stream);\n}\n\nstatic int dvb_usb_start_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct dvb_usb_adapter *adap = dvbdmxfeed->demux->priv;\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tint ret = 0;\n\tstruct usb_data_stream_properties stream_props;\n\tdev_dbg(&d->udev->dev,\n\t\t\t\"%s: adap=%d active_fe=%d feed_type=%d setting pid [%s]: %04x (%04d) at index %d\\n\",\n\t\t\t__func__, adap->id, adap->active_fe, dvbdmxfeed->type,\n\t\t\tadap->pid_filtering ? \"yes\" : \"no\", dvbdmxfeed->pid,\n\t\t\tdvbdmxfeed->pid, dvbdmxfeed->index);\n\n\t \n\twait_on_bit(&adap->state_bits, ADAP_INIT, TASK_UNINTERRUPTIBLE);\n\n\tif (adap->active_fe == -1)\n\t\treturn -EINVAL;\n\n\t \n\tif (adap->feed_count++ > 0)\n\t\tgoto skip_feed_start;\n\n\t \n\tset_bit(ADAP_STREAMING, &adap->state_bits);\n\n\t \n\tif (d->props->get_stream_config) {\n\t\tmemcpy(&stream_props, &adap->props->stream,\n\t\t\t\tsizeof(struct usb_data_stream_properties));\n\t\tret = d->props->get_stream_config(adap->fe[adap->active_fe],\n\t\t\t\t&adap->ts_type, &stream_props);\n\t\tif (ret)\n\t\t\tdev_err(&d->udev->dev,\n\t\t\t\t\t\"%s: get_stream_config() failed=%d\\n\",\n\t\t\t\t\tKBUILD_MODNAME, ret);\n\t} else {\n\t\tstream_props = adap->props->stream;\n\t}\n\n\tswitch (adap->ts_type) {\n\tcase DVB_USB_FE_TS_TYPE_204:\n\t\tadap->stream.complete = dvb_usb_data_complete_204;\n\t\tbreak;\n\tcase DVB_USB_FE_TS_TYPE_RAW:\n\t\tadap->stream.complete = dvb_usb_data_complete_raw;\n\t\tbreak;\n\tcase DVB_USB_FE_TS_TYPE_188:\n\tdefault:\n\t\tadap->stream.complete = dvb_usb_data_complete;\n\t\tbreak;\n\t}\n\n\t \n\tusb_urb_submitv2(&adap->stream, &stream_props);\n\n\t \n\tif (adap->pid_filtering && adap->props->pid_filter_ctrl) {\n\t\tret = adap->props->pid_filter_ctrl(adap, 1);\n\t\tif (ret)\n\t\t\tdev_err(&d->udev->dev,\n\t\t\t\t\t\"%s: pid_filter_ctrl() failed=%d\\n\",\n\t\t\t\t\tKBUILD_MODNAME, ret);\n\t}\n\n\t \n\tif (d->props->streaming_ctrl) {\n\t\tret = d->props->streaming_ctrl(adap->fe[adap->active_fe], 1);\n\t\tif (ret)\n\t\t\tdev_err(&d->udev->dev,\n\t\t\t\t\t\"%s: streaming_ctrl() failed=%d\\n\",\n\t\t\t\t\tKBUILD_MODNAME, ret);\n\t}\nskip_feed_start:\n\n\t \n\tif (adap->pid_filtering && adap->props->pid_filter) {\n\t\tret = adap->props->pid_filter(adap, dvbdmxfeed->index,\n\t\t\t\tdvbdmxfeed->pid, 1);\n\t\tif (ret)\n\t\t\tdev_err(&d->udev->dev, \"%s: pid_filter() failed=%d\\n\",\n\t\t\t\t\tKBUILD_MODNAME, ret);\n\t}\n\n\tif (ret)\n\t\tdev_dbg(&d->udev->dev, \"%s: failed=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int dvb_usb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct dvb_usb_adapter *adap = dvbdmxfeed->demux->priv;\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tint ret = 0;\n\tdev_dbg(&d->udev->dev,\n\t\t\t\"%s: adap=%d active_fe=%d feed_type=%d setting pid [%s]: %04x (%04d) at index %d\\n\",\n\t\t\t__func__, adap->id, adap->active_fe, dvbdmxfeed->type,\n\t\t\tadap->pid_filtering ? \"yes\" : \"no\", dvbdmxfeed->pid,\n\t\t\tdvbdmxfeed->pid, dvbdmxfeed->index);\n\n\tif (adap->active_fe == -1)\n\t\treturn -EINVAL;\n\n\t \n\tif (adap->pid_filtering && adap->props->pid_filter) {\n\t\tret = adap->props->pid_filter(adap, dvbdmxfeed->index,\n\t\t\t\tdvbdmxfeed->pid, 0);\n\t\tif (ret)\n\t\t\tdev_err(&d->udev->dev, \"%s: pid_filter() failed=%d\\n\",\n\t\t\t\t\tKBUILD_MODNAME, ret);\n\t}\n\n\t \n\tif (--adap->feed_count > 0)\n\t\tgoto skip_feed_stop;\n\n\t \n\tif (d->props->streaming_ctrl) {\n\t\tret = d->props->streaming_ctrl(adap->fe[adap->active_fe], 0);\n\t\tif (ret)\n\t\t\tdev_err(&d->udev->dev,\n\t\t\t\t\t\"%s: streaming_ctrl() failed=%d\\n\",\n\t\t\t\t\tKBUILD_MODNAME, ret);\n\t}\n\n\t \n\tif (adap->pid_filtering && adap->props->pid_filter_ctrl) {\n\t\tret = adap->props->pid_filter_ctrl(adap, 0);\n\t\tif (ret)\n\t\t\tdev_err(&d->udev->dev,\n\t\t\t\t\t\"%s: pid_filter_ctrl() failed=%d\\n\",\n\t\t\t\t\tKBUILD_MODNAME, ret);\n\t}\n\n\t \n\tusb_urb_killv2(&adap->stream);\n\n\t \n\tclear_bit(ADAP_STREAMING, &adap->state_bits);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&adap->state_bits, ADAP_STREAMING);\nskip_feed_stop:\n\n\tif (ret)\n\t\tdev_dbg(&d->udev->dev, \"%s: failed=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int dvb_usbv2_media_device_init(struct dvb_usb_adapter *adap)\n{\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tstruct media_device *mdev;\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct usb_device *udev = d->udev;\n\n\tmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\tmedia_device_usb_init(mdev, udev, d->name);\n\n\tdvb_register_media_controller(&adap->dvb_adap, mdev);\n\n\tdev_info(&d->udev->dev, \"media controller created\\n\");\n#endif\n\treturn 0;\n}\n\nstatic int dvb_usbv2_media_device_register(struct dvb_usb_adapter *adap)\n{\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\treturn media_device_register(adap->dvb_adap.mdev);\n#else\n\treturn 0;\n#endif\n}\n\nstatic void dvb_usbv2_media_device_unregister(struct dvb_usb_adapter *adap)\n{\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\n\tif (!adap->dvb_adap.mdev)\n\t\treturn;\n\n\tmedia_device_unregister(adap->dvb_adap.mdev);\n\tmedia_device_cleanup(adap->dvb_adap.mdev);\n\tkfree(adap->dvb_adap.mdev);\n\tadap->dvb_adap.mdev = NULL;\n\n#endif\n}\n\nstatic int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)\n{\n\tint ret;\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\n\tdev_dbg(&d->udev->dev, \"%s: adap=%d\\n\", __func__, adap->id);\n\n\tret = dvb_register_adapter(&adap->dvb_adap, d->name, d->props->owner,\n\t\t\t&d->udev->dev, d->props->adapter_nr);\n\tif (ret < 0) {\n\t\tdev_dbg(&d->udev->dev, \"%s: dvb_register_adapter() failed=%d\\n\",\n\t\t\t\t__func__, ret);\n\t\tgoto err_dvb_register_adapter;\n\t}\n\n\tadap->dvb_adap.priv = adap;\n\n\tret = dvb_usbv2_media_device_init(adap);\n\tif (ret < 0) {\n\t\tdev_dbg(&d->udev->dev, \"%s: dvb_usbv2_media_device_init() failed=%d\\n\",\n\t\t\t\t__func__, ret);\n\t\tgoto err_dvb_register_mc;\n\t}\n\n\tif (d->props->read_mac_address) {\n\t\tret = d->props->read_mac_address(adap,\n\t\t\t\tadap->dvb_adap.proposed_mac);\n\t\tif (ret < 0)\n\t\t\tgoto err_dvb_dmx_init;\n\n\t\tdev_info(&d->udev->dev, \"%s: MAC address: %pM\\n\",\n\t\t\t\tKBUILD_MODNAME, adap->dvb_adap.proposed_mac);\n\t}\n\n\tadap->demux.dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING;\n\tadap->demux.priv             = adap;\n\tadap->demux.filternum        = 0;\n\tadap->demux.filternum        = adap->max_feed_count;\n\tadap->demux.feednum          = adap->demux.filternum;\n\tadap->demux.start_feed       = dvb_usb_start_feed;\n\tadap->demux.stop_feed        = dvb_usb_stop_feed;\n\tadap->demux.write_to_decoder = NULL;\n\tret = dvb_dmx_init(&adap->demux);\n\tif (ret < 0) {\n\t\tdev_err(&d->udev->dev, \"%s: dvb_dmx_init() failed=%d\\n\",\n\t\t\t\tKBUILD_MODNAME, ret);\n\t\tgoto err_dvb_dmx_init;\n\t}\n\n\tadap->dmxdev.filternum       = adap->demux.filternum;\n\tadap->dmxdev.demux           = &adap->demux.dmx;\n\tadap->dmxdev.capabilities    = 0;\n\tret = dvb_dmxdev_init(&adap->dmxdev, &adap->dvb_adap);\n\tif (ret < 0) {\n\t\tdev_err(&d->udev->dev, \"%s: dvb_dmxdev_init() failed=%d\\n\",\n\t\t\t\tKBUILD_MODNAME, ret);\n\t\tgoto err_dvb_dmxdev_init;\n\t}\n\n\tret = dvb_net_init(&adap->dvb_adap, &adap->dvb_net, &adap->demux.dmx);\n\tif (ret < 0) {\n\t\tdev_err(&d->udev->dev, \"%s: dvb_net_init() failed=%d\\n\",\n\t\t\t\tKBUILD_MODNAME, ret);\n\t\tgoto err_dvb_net_init;\n\t}\n\n\treturn 0;\nerr_dvb_net_init:\n\tdvb_dmxdev_release(&adap->dmxdev);\nerr_dvb_dmxdev_init:\n\tdvb_dmx_release(&adap->demux);\nerr_dvb_dmx_init:\n\tdvb_usbv2_media_device_unregister(adap);\nerr_dvb_register_mc:\n\tdvb_unregister_adapter(&adap->dvb_adap);\nerr_dvb_register_adapter:\n\tadap->dvb_adap.priv = NULL;\n\treturn ret;\n}\n\nstatic int dvb_usbv2_adapter_dvb_exit(struct dvb_usb_adapter *adap)\n{\n\tdev_dbg(&adap_to_d(adap)->udev->dev, \"%s: adap=%d\\n\", __func__,\n\t\t\tadap->id);\n\n\tif (adap->dvb_adap.priv) {\n\t\tdvb_net_release(&adap->dvb_net);\n\t\tadap->demux.dmx.close(&adap->demux.dmx);\n\t\tdvb_dmxdev_release(&adap->dmxdev);\n\t\tdvb_dmx_release(&adap->demux);\n\t\tdvb_unregister_adapter(&adap->dvb_adap);\n\t}\n\n\treturn 0;\n}\n\nstatic int dvb_usbv2_device_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tint ret;\n\n\tif (onoff)\n\t\td->powered++;\n\telse\n\t\td->powered--;\n\n\tif (d->powered == 0 || (onoff && d->powered == 1)) {\n\t\t \n\t\tdev_dbg(&d->udev->dev, \"%s: power=%d\\n\", __func__, onoff);\n\t\tif (d->props->power_ctrl) {\n\t\t\tret = d->props->power_ctrl(d, onoff);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&d->udev->dev, \"%s: failed=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int dvb_usb_fe_init(struct dvb_frontend *fe)\n{\n\tint ret;\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tdev_dbg(&d->udev->dev, \"%s: adap=%d fe=%d\\n\", __func__, adap->id,\n\t\t\tfe->id);\n\n\tif (!adap->suspend_resume_active) {\n\t\tadap->active_fe = fe->id;\n\t\tset_bit(ADAP_INIT, &adap->state_bits);\n\t}\n\n\tret = dvb_usbv2_device_power_ctrl(d, 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tif (d->props->frontend_ctrl) {\n\t\tret = d->props->frontend_ctrl(fe, 1);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tif (adap->fe_init[fe->id]) {\n\t\tret = adap->fe_init[fe->id](fe);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\nerr:\n\tif (!adap->suspend_resume_active) {\n\t\tclear_bit(ADAP_INIT, &adap->state_bits);\n\t\tsmp_mb__after_atomic();\n\t\twake_up_bit(&adap->state_bits, ADAP_INIT);\n\t}\n\n\tdev_dbg(&d->udev->dev, \"%s: ret=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int dvb_usb_fe_sleep(struct dvb_frontend *fe)\n{\n\tint ret;\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tdev_dbg(&d->udev->dev, \"%s: adap=%d fe=%d\\n\", __func__, adap->id,\n\t\t\tfe->id);\n\n\tif (!adap->suspend_resume_active) {\n\t\tset_bit(ADAP_SLEEP, &adap->state_bits);\n\t\twait_on_bit(&adap->state_bits, ADAP_STREAMING,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t}\n\n\tif (adap->fe_sleep[fe->id]) {\n\t\tret = adap->fe_sleep[fe->id](fe);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tif (d->props->frontend_ctrl) {\n\t\tret = d->props->frontend_ctrl(fe, 0);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tret = dvb_usbv2_device_power_ctrl(d, 0);\n\nerr:\n\tif (!adap->suspend_resume_active) {\n\t\tadap->active_fe = -1;\n\t\tclear_bit(ADAP_SLEEP, &adap->state_bits);\n\t\tsmp_mb__after_atomic();\n\t\twake_up_bit(&adap->state_bits, ADAP_SLEEP);\n\t}\n\n\tdev_dbg(&d->udev->dev, \"%s: ret=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int dvb_usbv2_adapter_frontend_init(struct dvb_usb_adapter *adap)\n{\n\tint ret, i, count_registered = 0;\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tdev_dbg(&d->udev->dev, \"%s: adap=%d\\n\", __func__, adap->id);\n\n\tmemset(adap->fe, 0, sizeof(adap->fe));\n\tadap->active_fe = -1;\n\n\tif (d->props->frontend_attach) {\n\t\tret = d->props->frontend_attach(adap);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(&d->udev->dev,\n\t\t\t\t\t\"%s: frontend_attach() failed=%d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\tgoto err_dvb_frontend_detach;\n\t\t}\n\t} else {\n\t\tdev_dbg(&d->udev->dev, \"%s: frontend_attach() do not exists\\n\",\n\t\t\t\t__func__);\n\t\tret = 0;\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < MAX_NO_OF_FE_PER_ADAP && adap->fe[i]; i++) {\n\t\tadap->fe[i]->id = i;\n\t\t \n\t\tadap->fe_init[i] = adap->fe[i]->ops.init;\n\t\tadap->fe[i]->ops.init = dvb_usb_fe_init;\n\t\tadap->fe_sleep[i] = adap->fe[i]->ops.sleep;\n\t\tadap->fe[i]->ops.sleep = dvb_usb_fe_sleep;\n\n\t\tret = dvb_register_frontend(&adap->dvb_adap, adap->fe[i]);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&d->udev->dev,\n\t\t\t\t\t\"%s: frontend%d registration failed\\n\",\n\t\t\t\t\tKBUILD_MODNAME, i);\n\t\t\tgoto err_dvb_unregister_frontend;\n\t\t}\n\n\t\tcount_registered++;\n\t}\n\n\tif (d->props->tuner_attach) {\n\t\tret = d->props->tuner_attach(adap);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(&d->udev->dev, \"%s: tuner_attach() failed=%d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\tgoto err_dvb_unregister_frontend;\n\t\t}\n\t}\n\n\tret = dvb_create_media_graph(&adap->dvb_adap, true);\n\tif (ret < 0)\n\t\tgoto err_dvb_unregister_frontend;\n\n\tret = dvb_usbv2_media_device_register(adap);\n\n\treturn ret;\n\nerr_dvb_unregister_frontend:\n\tfor (i = count_registered - 1; i >= 0; i--)\n\t\tdvb_unregister_frontend(adap->fe[i]);\n\nerr_dvb_frontend_detach:\n\tfor (i = MAX_NO_OF_FE_PER_ADAP - 1; i >= 0; i--) {\n\t\tif (adap->fe[i]) {\n\t\t\tdvb_frontend_detach(adap->fe[i]);\n\t\t\tadap->fe[i] = NULL;\n\t\t}\n\t}\n\nerr:\n\tdev_dbg(&d->udev->dev, \"%s: failed=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int dvb_usbv2_adapter_frontend_exit(struct dvb_usb_adapter *adap)\n{\n\tint ret, i;\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\n\tdev_dbg(&d->udev->dev, \"%s: adap=%d\\n\", __func__, adap->id);\n\n\tfor (i = MAX_NO_OF_FE_PER_ADAP - 1; i >= 0; i--) {\n\t\tif (adap->fe[i]) {\n\t\t\tdvb_unregister_frontend(adap->fe[i]);\n\t\t\tdvb_frontend_detach(adap->fe[i]);\n\t\t}\n\t}\n\n\tif (d->props->tuner_detach) {\n\t\tret = d->props->tuner_detach(adap);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(&d->udev->dev, \"%s: tuner_detach() failed=%d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t}\n\t}\n\n\tif (d->props->frontend_detach) {\n\t\tret = d->props->frontend_detach(adap);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(&d->udev->dev,\n\t\t\t\t\t\"%s: frontend_detach() failed=%d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dvb_usbv2_adapter_init(struct dvb_usb_device *d)\n{\n\tstruct dvb_usb_adapter *adap;\n\tint ret, i, adapter_count;\n\n\t \n\tadapter_count = d->props->num_adapters;\n\tif (d->props->get_adapter_count) {\n\t\tret = d->props->get_adapter_count(d);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tadapter_count = ret;\n\t}\n\n\tfor (i = 0; i < adapter_count; i++) {\n\t\tadap = &d->adapter[i];\n\t\tadap->id = i;\n\t\tadap->props = &d->props->adapter[i];\n\n\t\t \n\t\tif (d->udev->speed == USB_SPEED_FULL &&\n\t\t\t\t!(adap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER)) {\n\t\t\tdev_err(&d->udev->dev,\n\t\t\t\t\t\"%s: this USB2.0 device cannot be run on a USB1.1 port (it lacks a hardware PID filter)\\n\",\n\t\t\t\t\tKBUILD_MODNAME);\n\t\t\tret = -ENODEV;\n\t\t\tgoto err;\n\t\t} else if ((d->udev->speed == USB_SPEED_FULL &&\n\t\t\t\tadap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER) ||\n\t\t\t\t(adap->props->caps & DVB_USB_ADAP_NEED_PID_FILTERING)) {\n\t\t\tdev_info(&d->udev->dev,\n\t\t\t\t\t\"%s: will use the device's hardware PID filter (table count: %d)\\n\",\n\t\t\t\t\tKBUILD_MODNAME,\n\t\t\t\t\tadap->props->pid_filter_count);\n\t\t\tadap->pid_filtering  = 1;\n\t\t\tadap->max_feed_count = adap->props->pid_filter_count;\n\t\t} else {\n\t\t\tdev_info(&d->udev->dev,\n\t\t\t\t\t\"%s: will pass the complete MPEG2 transport stream to the software demuxer\\n\",\n\t\t\t\t\tKBUILD_MODNAME);\n\t\t\tadap->pid_filtering  = 0;\n\t\t\tadap->max_feed_count = 255;\n\t\t}\n\n\t\tif (!adap->pid_filtering && dvb_usb_force_pid_filter_usage &&\n\t\t\t\tadap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER) {\n\t\t\tdev_info(&d->udev->dev,\n\t\t\t\t\t\"%s: PID filter enabled by module option\\n\",\n\t\t\t\t\tKBUILD_MODNAME);\n\t\t\tadap->pid_filtering  = 1;\n\t\t\tadap->max_feed_count = adap->props->pid_filter_count;\n\t\t}\n\n\t\tret = dvb_usbv2_adapter_stream_init(adap);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = dvb_usbv2_adapter_dvb_init(adap);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = dvb_usbv2_adapter_frontend_init(adap);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tif (adap->fe[1])\n\t\t\tadap->dvb_adap.mfe_shared = 1;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&d->udev->dev, \"%s: failed=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int dvb_usbv2_adapter_exit(struct dvb_usb_device *d)\n{\n\tint i;\n\tdev_dbg(&d->udev->dev, \"%s:\\n\", __func__);\n\n\tfor (i = MAX_NO_OF_ADAPTER_PER_DEVICE - 1; i >= 0; i--) {\n\t\tif (d->adapter[i].props) {\n\t\t\tdvb_usbv2_adapter_dvb_exit(&d->adapter[i]);\n\t\t\tdvb_usbv2_adapter_stream_exit(&d->adapter[i]);\n\t\t\tdvb_usbv2_adapter_frontend_exit(&d->adapter[i]);\n\t\t\tdvb_usbv2_media_device_unregister(&d->adapter[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dvb_usbv2_exit(struct dvb_usb_device *d)\n{\n\tdev_dbg(&d->udev->dev, \"%s:\\n\", __func__);\n\n\tdvb_usbv2_remote_exit(d);\n\tdvb_usbv2_adapter_exit(d);\n\tdvb_usbv2_i2c_exit(d);\n\n\treturn 0;\n}\n\nstatic int dvb_usbv2_init(struct dvb_usb_device *d)\n{\n\tint ret;\n\tdev_dbg(&d->udev->dev, \"%s:\\n\", __func__);\n\n\tdvb_usbv2_device_power_ctrl(d, 1);\n\n\tif (d->props->read_config) {\n\t\tret = d->props->read_config(d);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tret = dvb_usbv2_i2c_init(d);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = dvb_usbv2_adapter_init(d);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tif (d->props->init) {\n\t\tret = d->props->init(d);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tret = dvb_usbv2_remote_init(d);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tdvb_usbv2_device_power_ctrl(d, 0);\n\n\treturn 0;\nerr:\n\tdvb_usbv2_device_power_ctrl(d, 0);\n\tdev_dbg(&d->udev->dev, \"%s: failed=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nint dvb_usbv2_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tint ret;\n\tstruct dvb_usb_device *d;\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct dvb_usb_driver_info *driver_info =\n\t\t\t(struct dvb_usb_driver_info *) id->driver_info;\n\n\tdev_dbg(&udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\n\tif (!id->driver_info) {\n\t\tdev_err(&udev->dev, \"%s: driver_info failed\\n\", KBUILD_MODNAME);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\td = kzalloc(sizeof(struct dvb_usb_device), GFP_KERNEL);\n\tif (!d) {\n\t\tdev_err(&udev->dev, \"%s: kzalloc() failed\\n\", KBUILD_MODNAME);\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\td->intf = intf;\n\td->name = driver_info->name;\n\td->rc_map = driver_info->rc_map;\n\td->udev = udev;\n\td->props = driver_info->props;\n\n\tif (intf->cur_altsetting->desc.bInterfaceNumber !=\n\t\t\td->props->bInterfaceNumber) {\n\t\tret = -ENODEV;\n\t\tgoto err_kfree_d;\n\t}\n\n\tmutex_init(&d->usb_mutex);\n\tmutex_init(&d->i2c_mutex);\n\n\tif (d->props->size_of_priv) {\n\t\td->priv = kzalloc(d->props->size_of_priv, GFP_KERNEL);\n\t\tif (!d->priv) {\n\t\t\tdev_err(&d->udev->dev, \"%s: kzalloc() failed\\n\",\n\t\t\t\t\tKBUILD_MODNAME);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_kfree_d;\n\t\t}\n\t}\n\n\tif (d->props->probe) {\n\t\tret = d->props->probe(d);\n\t\tif (ret)\n\t\t\tgoto err_kfree_priv;\n\t}\n\n\tif (d->props->identify_state) {\n\t\tconst char *name = NULL;\n\t\tret = d->props->identify_state(d, &name);\n\t\tif (ret == COLD) {\n\t\t\tdev_info(&d->udev->dev,\n\t\t\t\t\t\"%s: found a '%s' in cold state\\n\",\n\t\t\t\t\tKBUILD_MODNAME, d->name);\n\n\t\t\tif (!name)\n\t\t\t\tname = d->props->firmware;\n\n\t\t\tret = dvb_usbv2_download_firmware(d, name);\n\t\t\tif (ret == 0) {\n\t\t\t\t \n\t\t\t\t;\n\t\t\t} else if (ret == RECONNECTS_USB) {\n\t\t\t\t \n\t\t\t\tgoto exit;\n\t\t\t} else {\n\t\t\t\tgoto err_free_all;\n\t\t\t}\n\t\t} else if (ret != WARM) {\n\t\t\tgoto err_free_all;\n\t\t}\n\t}\n\n\tdev_info(&d->udev->dev, \"%s: found a '%s' in warm state\\n\",\n\t\t\tKBUILD_MODNAME, d->name);\n\n\tret = dvb_usbv2_init(d);\n\tif (ret < 0)\n\t\tgoto err_free_all;\n\n\tdev_info(&d->udev->dev,\n\t\t\t\"%s: '%s' successfully initialized and connected\\n\",\n\t\t\tKBUILD_MODNAME, d->name);\nexit:\n\tusb_set_intfdata(intf, d);\n\n\treturn 0;\nerr_free_all:\n\tdvb_usbv2_exit(d);\n\tif (d->props->disconnect)\n\t\td->props->disconnect(d);\nerr_kfree_priv:\n\tkfree(d->priv);\nerr_kfree_d:\n\tkfree(d);\nerr:\n\tdev_dbg(&udev->dev, \"%s: failed=%d\\n\", __func__, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(dvb_usbv2_probe);\n\nvoid dvb_usbv2_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *devname = kstrdup(dev_name(&d->udev->dev), GFP_KERNEL);\n\tconst char *drvname = d->name;\n\n\tdev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\n\tif (d->props->exit)\n\t\td->props->exit(d);\n\n\tdvb_usbv2_exit(d);\n\n\tif (d->props->disconnect)\n\t\td->props->disconnect(d);\n\n\tkfree(d->priv);\n\tkfree(d);\n\n\tpr_info(\"%s: '%s:%s' successfully deinitialized and disconnected\\n\",\n\t\tKBUILD_MODNAME, drvname, devname);\n\tkfree(devname);\n}\nEXPORT_SYMBOL(dvb_usbv2_disconnect);\n\nint dvb_usbv2_suspend(struct usb_interface *intf, pm_message_t msg)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tint ret = 0, i, active_fe;\n\tstruct dvb_frontend *fe;\n\tdev_dbg(&d->udev->dev, \"%s:\\n\", __func__);\n\n\t \n\tif (d->rc_polling_active)\n\t\tcancel_delayed_work_sync(&d->rc_query_work);\n\n\tfor (i = MAX_NO_OF_ADAPTER_PER_DEVICE - 1; i >= 0; i--) {\n\t\tactive_fe = d->adapter[i].active_fe;\n\t\tif (d->adapter[i].dvb_adap.priv && active_fe != -1) {\n\t\t\tfe = d->adapter[i].fe[active_fe];\n\t\t\td->adapter[i].suspend_resume_active = true;\n\n\t\t\tif (d->props->streaming_ctrl)\n\t\t\t\td->props->streaming_ctrl(fe, 0);\n\n\t\t\t \n\t\t\tusb_urb_killv2(&d->adapter[i].stream);\n\n\t\t\tret = dvb_frontend_suspend(fe);\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dvb_usbv2_suspend);\n\nstatic int dvb_usbv2_resume_common(struct dvb_usb_device *d)\n{\n\tint ret = 0, i, active_fe;\n\tstruct dvb_frontend *fe;\n\tdev_dbg(&d->udev->dev, \"%s:\\n\", __func__);\n\n\tfor (i = 0; i < MAX_NO_OF_ADAPTER_PER_DEVICE; i++) {\n\t\tactive_fe = d->adapter[i].active_fe;\n\t\tif (d->adapter[i].dvb_adap.priv && active_fe != -1) {\n\t\t\tfe = d->adapter[i].fe[active_fe];\n\n\t\t\tret = dvb_frontend_resume(fe);\n\n\t\t\t \n\t\t\tusb_urb_submitv2(&d->adapter[i].stream, NULL);\n\n\t\t\tif (d->props->streaming_ctrl)\n\t\t\t\td->props->streaming_ctrl(fe, 1);\n\n\t\t\td->adapter[i].suspend_resume_active = false;\n\t\t}\n\t}\n\n\t \n\tif (d->rc_polling_active)\n\t\tschedule_delayed_work(&d->rc_query_work,\n\t\t\t\tmsecs_to_jiffies(d->rc.interval));\n\n\treturn ret;\n}\n\nint dvb_usbv2_resume(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tdev_dbg(&d->udev->dev, \"%s:\\n\", __func__);\n\n\treturn dvb_usbv2_resume_common(d);\n}\nEXPORT_SYMBOL(dvb_usbv2_resume);\n\nint dvb_usbv2_reset_resume(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tint ret;\n\tdev_dbg(&d->udev->dev, \"%s:\\n\", __func__);\n\n\tdvb_usbv2_device_power_ctrl(d, 1);\n\n\tif (d->props->init)\n\t\td->props->init(d);\n\n\tret = dvb_usbv2_resume_common(d);\n\n\tdvb_usbv2_device_power_ctrl(d, 0);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dvb_usbv2_reset_resume);\n\nMODULE_VERSION(\"2.0\");\nMODULE_AUTHOR(\"Patrick Boettcher <patrick.boettcher@posteo.de>\");\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"DVB USB common\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}