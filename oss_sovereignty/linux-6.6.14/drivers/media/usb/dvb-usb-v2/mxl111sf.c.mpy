{
  "module_name": "mxl111sf.c",
  "hash_id": "14665de5f7a6151f4443e0f6ceab1bd26a72013015f95f6e3d058aea01fb02e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/mxl111sf.c",
  "human_readable_source": "\n \n\n#include <linux/vmalloc.h>\n#include <linux/i2c.h>\n#include <media/tuner.h>\n\n#include \"mxl111sf.h\"\n#include \"mxl111sf-reg.h\"\n#include \"mxl111sf-phy.h\"\n#include \"mxl111sf-i2c.h\"\n#include \"mxl111sf-gpio.h\"\n\n#include \"mxl111sf-demod.h\"\n#include \"mxl111sf-tuner.h\"\n\n#include \"lgdt3305.h\"\n#include \"lg2160.h\"\n\nint dvb_usb_mxl111sf_debug;\nmodule_param_named(debug, dvb_usb_mxl111sf_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=info, 2=xfer, 4=i2c, 8=reg, 16=adv (or-able)).\");\n\nstatic int dvb_usb_mxl111sf_isoc;\nmodule_param_named(isoc, dvb_usb_mxl111sf_isoc, int, 0644);\nMODULE_PARM_DESC(isoc, \"enable usb isoc xfer (0=bulk, 1=isoc).\");\n\nstatic int dvb_usb_mxl111sf_spi;\nmodule_param_named(spi, dvb_usb_mxl111sf_spi, int, 0644);\nMODULE_PARM_DESC(spi, \"use spi rather than tp for data xfer (0=tp, 1=spi).\");\n\n#define ANT_PATH_AUTO 0\n#define ANT_PATH_EXTERNAL 1\n#define ANT_PATH_INTERNAL 2\n\nstatic int dvb_usb_mxl111sf_rfswitch =\n#if 0\n\t\tANT_PATH_AUTO;\n#else\n\t\tANT_PATH_EXTERNAL;\n#endif\n\nmodule_param_named(rfswitch, dvb_usb_mxl111sf_rfswitch, int, 0644);\nMODULE_PARM_DESC(rfswitch, \"force rf switch position (0=auto, 1=ext, 2=int).\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nint mxl111sf_ctrl_msg(struct mxl111sf_state *state,\n\t\t      u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct dvb_usb_device *d = state->d;\n\tint wo = (rbuf == NULL || rlen == 0);  \n\tint ret;\n\n\tif (1 + wlen > MXL_MAX_XFER_SIZE) {\n\t\tpr_warn(\"%s: len=%d is too big!\\n\", __func__, wlen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpr_debug(\"%s(wlen = %d, rlen = %d)\\n\", __func__, wlen, rlen);\n\n\tmutex_lock(&state->msg_lock);\n\tmemset(state->sndbuf, 0, 1+wlen);\n\tmemset(state->rcvbuf, 0, rlen);\n\n\tstate->sndbuf[0] = cmd;\n\tmemcpy(&state->sndbuf[1], wbuf, wlen);\n\n\tret = (wo) ? dvb_usbv2_generic_write(d, state->sndbuf, 1+wlen) :\n\t\tdvb_usbv2_generic_rw(d, state->sndbuf, 1+wlen, state->rcvbuf,\n\t\t\t\t     rlen);\n\n\tif (rbuf)\n\t\tmemcpy(rbuf, state->rcvbuf, rlen);\n\n\tmutex_unlock(&state->msg_lock);\n\n\tmxl_fail(ret);\n\n\treturn ret;\n}\n\n \n\n#define MXL_CMD_REG_READ\t0xaa\n#define MXL_CMD_REG_WRITE\t0x55\n\nint mxl111sf_read_reg(struct mxl111sf_state *state, u8 addr, u8 *data)\n{\n\tu8 buf[2];\n\tint ret;\n\n\tret = mxl111sf_ctrl_msg(state, MXL_CMD_REG_READ, &addr, 1, buf, 2);\n\tif (mxl_fail(ret)) {\n\t\tmxl_debug(\"error reading reg: 0x%02x\", addr);\n\t\tgoto fail;\n\t}\n\n\tif (buf[0] == addr)\n\t\t*data = buf[1];\n\telse {\n\t\tpr_err(\"invalid response reading reg: 0x%02x != 0x%02x, 0x%02x\",\n\t\t    addr, buf[0], buf[1]);\n\t\tret = -EINVAL;\n\t}\n\n\tpr_debug(\"R: (0x%02x, 0x%02x)\\n\", addr, buf[1]);\nfail:\n\treturn ret;\n}\n\nint mxl111sf_write_reg(struct mxl111sf_state *state, u8 addr, u8 data)\n{\n\tu8 buf[] = { addr, data };\n\tint ret;\n\n\tpr_debug(\"W: (0x%02x, 0x%02x)\\n\", addr, data);\n\n\tret = mxl111sf_ctrl_msg(state, MXL_CMD_REG_WRITE, buf, 2, NULL, 0);\n\tif (mxl_fail(ret))\n\t\tpr_err(\"error writing reg: 0x%02x, val: 0x%02x\", addr, data);\n\treturn ret;\n}\n\n \n\nint mxl111sf_write_reg_mask(struct mxl111sf_state *state,\n\t\t\t\t   u8 addr, u8 mask, u8 data)\n{\n\tint ret;\n\tu8 val = 0;\n\n\tif (mask != 0xff) {\n\t\tret = mxl111sf_read_reg(state, addr, &val);\n#if 1\n\t\t \n\t\tif (mxl_fail(ret))\n\t\t\tpr_err(\"error writing addr: 0x%02x, mask: 0x%02x, data: 0x%02x, retrying...\",\n\t\t\t       addr, mask, data);\n\n\t\tret = mxl111sf_read_reg(state, addr, &val);\n#endif\n\t\tif (mxl_fail(ret))\n\t\t\tgoto fail;\n\t}\n\tval &= ~mask;\n\tval |= data;\n\n\tret = mxl111sf_write_reg(state, addr, val);\n\tmxl_fail(ret);\nfail:\n\treturn ret;\n}\n\n \n\nint mxl111sf_ctrl_program_regs(struct mxl111sf_state *state,\n\t\t\t       struct mxl111sf_reg_ctrl_info *ctrl_reg_info)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0;  ctrl_reg_info[i].addr |\n\t\t     ctrl_reg_info[i].mask |\n\t\t     ctrl_reg_info[i].data;  i++) {\n\n\t\tret = mxl111sf_write_reg_mask(state,\n\t\t\t\t\t      ctrl_reg_info[i].addr,\n\t\t\t\t\t      ctrl_reg_info[i].mask,\n\t\t\t\t\t      ctrl_reg_info[i].data);\n\t\tif (mxl_fail(ret)) {\n\t\t\tpr_err(\"failed on reg #%d (0x%02x)\", i,\n\t\t\t    ctrl_reg_info[i].addr);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\n \n\nstatic int mxl1x1sf_get_chip_info(struct mxl111sf_state *state)\n{\n\tint ret;\n\tu8 id, ver;\n\tchar *mxl_chip, *mxl_rev;\n\n\tif ((state->chip_id) && (state->chip_ver))\n\t\treturn 0;\n\n\tret = mxl111sf_read_reg(state, CHIP_ID_REG, &id);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tstate->chip_id = id;\n\n\tret = mxl111sf_read_reg(state, TOP_CHIP_REV_ID_REG, &ver);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tstate->chip_ver = ver;\n\n\tswitch (id) {\n\tcase 0x61:\n\t\tmxl_chip = \"MxL101SF\";\n\t\tbreak;\n\tcase 0x63:\n\t\tmxl_chip = \"MxL111SF\";\n\t\tbreak;\n\tdefault:\n\t\tmxl_chip = \"UNKNOWN MxL1X1\";\n\t\tbreak;\n\t}\n\tswitch (ver) {\n\tcase 0x36:\n\t\tstate->chip_rev = MXL111SF_V6;\n\t\tmxl_rev = \"v6\";\n\t\tbreak;\n\tcase 0x08:\n\t\tstate->chip_rev = MXL111SF_V8_100;\n\t\tmxl_rev = \"v8_100\";\n\t\tbreak;\n\tcase 0x18:\n\t\tstate->chip_rev = MXL111SF_V8_200;\n\t\tmxl_rev = \"v8_200\";\n\t\tbreak;\n\tdefault:\n\t\tstate->chip_rev = 0;\n\t\tmxl_rev = \"UNKNOWN REVISION\";\n\t\tbreak;\n\t}\n\tpr_info(\"%s detected, %s (0x%x)\", mxl_chip, mxl_rev, ver);\nfail:\n\treturn ret;\n}\n\n#define get_chip_info(state)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint ___ret;\t\t\t\t\t\t\t\\\n\t___ret = mxl1x1sf_get_chip_info(state);\t\t\t\t\\\n\tif (mxl_fail(___ret)) {\t\t\t\t\t\t\\\n\t\tmxl_debug(\"failed to get chip info\"\t\t\t\\\n\t\t\t  \" on first probe attempt\");\t\t\t\\\n\t\t___ret = mxl1x1sf_get_chip_info(state);\t\t\t\\\n\t\tif (mxl_fail(___ret))\t\t\t\t\t\\\n\t\t\tpr_err(\"failed to get chip info during probe\");\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tmxl_debug(\"probe needed a retry \"\t\t\\\n\t\t\t\t  \"in order to succeed.\");\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t___ret;\t\t\t\t\t\t\t\t\\\n})\n\n \n#if 0\nstatic int mxl111sf_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\t \n\treturn 0;\n}\n#endif\n\nstatic int mxl111sf_adap_fe_init(struct dvb_frontend *fe)\n{\n\tstruct dvb_usb_device *d = fe_to_d(fe);\n\tstruct mxl111sf_state *state = fe_to_priv(fe);\n\tstruct mxl111sf_adap_state *adap_state = &state->adap_state[fe->id];\n\tint err;\n\n\t \n\tif (!state->chip_id) {\n\t\tmxl_debug(\"driver not yet initialized, exit.\");\n\t\tgoto fail;\n\t}\n\n\tpr_debug(\"%s()\\n\", __func__);\n\n\tmutex_lock(&state->fe_lock);\n\n\tstate->alt_mode = adap_state->alt_mode;\n\n\tif (usb_set_interface(d->udev, 0, state->alt_mode) < 0)\n\t\tpr_err(\"set interface failed\");\n\n\terr = mxl1x1sf_soft_reset(state);\n\tmxl_fail(err);\n\terr = mxl111sf_init_tuner_demod(state);\n\tmxl_fail(err);\n\terr = mxl1x1sf_set_device_mode(state, adap_state->device_mode);\n\n\tmxl_fail(err);\n\terr = mxl111sf_enable_usb_output(state);\n\tmxl_fail(err);\n\terr = mxl1x1sf_top_master_ctrl(state, 1);\n\tmxl_fail(err);\n\n\tif ((MXL111SF_GPIO_MOD_DVBT != adap_state->gpio_mode) &&\n\t    (state->chip_rev > MXL111SF_V6)) {\n\t\tmxl111sf_config_pin_mux_modes(state,\n\t\t\t\t\t      PIN_MUX_TS_SPI_IN_MODE_1);\n\t\tmxl_fail(err);\n\t}\n\terr = mxl111sf_init_port_expander(state);\n\tif (!mxl_fail(err)) {\n\t\tstate->gpio_mode = adap_state->gpio_mode;\n\t\terr = mxl111sf_gpio_mode_switch(state, state->gpio_mode);\n\t\tmxl_fail(err);\n#if 0\n\t\terr = fe->ops.init(fe);\n#endif\n\t\tmsleep(100);  \n\t}\n\n\treturn (adap_state->fe_init) ? adap_state->fe_init(fe) : 0;\nfail:\n\treturn -ENODEV;\n}\n\nstatic int mxl111sf_adap_fe_sleep(struct dvb_frontend *fe)\n{\n\tstruct mxl111sf_state *state = fe_to_priv(fe);\n\tstruct mxl111sf_adap_state *adap_state = &state->adap_state[fe->id];\n\tint err;\n\n\t \n\tif (!state->chip_id) {\n\t\tmxl_debug(\"driver not yet initialized, exit.\");\n\t\tgoto fail;\n\t}\n\n\tpr_debug(\"%s()\\n\", __func__);\n\n\terr = (adap_state->fe_sleep) ? adap_state->fe_sleep(fe) : 0;\n\n\tmutex_unlock(&state->fe_lock);\n\n\treturn err;\nfail:\n\treturn -ENODEV;\n}\n\n\nstatic int mxl111sf_ep6_streaming_ctrl(struct dvb_frontend *fe, int onoff)\n{\n\tstruct mxl111sf_state *state = fe_to_priv(fe);\n\tstruct mxl111sf_adap_state *adap_state = &state->adap_state[fe->id];\n\tint ret = 0;\n\n\tpr_debug(\"%s(%d)\\n\", __func__, onoff);\n\n\tif (onoff) {\n\t\tret = mxl111sf_enable_usb_output(state);\n\t\tmxl_fail(ret);\n\t\tret = mxl111sf_config_mpeg_in(state, 1, 1,\n\t\t\t\t\t      adap_state->ep6_clockphase,\n\t\t\t\t\t      0, 0);\n\t\tmxl_fail(ret);\n#if 0\n\t} else {\n\t\tret = mxl111sf_disable_656_port(state);\n\t\tmxl_fail(ret);\n#endif\n\t}\n\n\treturn ret;\n}\n\nstatic int mxl111sf_ep5_streaming_ctrl(struct dvb_frontend *fe, int onoff)\n{\n\tstruct mxl111sf_state *state = fe_to_priv(fe);\n\tint ret = 0;\n\n\tpr_debug(\"%s(%d)\\n\", __func__, onoff);\n\n\tif (onoff) {\n\t\tret = mxl111sf_enable_usb_output(state);\n\t\tmxl_fail(ret);\n\n\t\tret = mxl111sf_init_i2s_port(state, 200);\n\t\tmxl_fail(ret);\n\t\tret = mxl111sf_config_i2s(state, 0, 15);\n\t\tmxl_fail(ret);\n\t} else {\n\t\tret = mxl111sf_disable_i2s_port(state);\n\t\tmxl_fail(ret);\n\t}\n\tif (state->chip_rev > MXL111SF_V6)\n\t\tret = mxl111sf_config_spi(state, onoff);\n\tmxl_fail(ret);\n\n\treturn ret;\n}\n\nstatic int mxl111sf_ep4_streaming_ctrl(struct dvb_frontend *fe, int onoff)\n{\n\tstruct mxl111sf_state *state = fe_to_priv(fe);\n\tint ret = 0;\n\n\tpr_debug(\"%s(%d)\\n\", __func__, onoff);\n\n\tif (onoff) {\n\t\tret = mxl111sf_enable_usb_output(state);\n\t\tmxl_fail(ret);\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic struct lgdt3305_config hauppauge_lgdt3305_config = {\n\t.i2c_addr           = 0xb2 >> 1,\n\t.mpeg_mode          = LGDT3305_MPEG_SERIAL,\n\t.tpclk_edge         = LGDT3305_TPCLK_RISING_EDGE,\n\t.tpvalid_polarity   = LGDT3305_TP_VALID_HIGH,\n\t.deny_i2c_rptr      = 1,\n\t.spectral_inversion = 0,\n\t.qam_if_khz         = 6000,\n\t.vsb_if_khz         = 6000,\n};\n\nstatic int mxl111sf_lgdt3305_frontend_attach(struct dvb_usb_adapter *adap, u8 fe_id)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct mxl111sf_state *state = d_to_priv(d);\n\tstruct mxl111sf_adap_state *adap_state = &state->adap_state[fe_id];\n\tint ret;\n\n\tpr_debug(\"%s()\\n\", __func__);\n\n\t \n\tstate->d = d;\n\tadap_state->alt_mode = (dvb_usb_mxl111sf_isoc) ? 2 : 1;\n\tstate->alt_mode = adap_state->alt_mode;\n\n\tif (usb_set_interface(d->udev, 0, state->alt_mode) < 0)\n\t\tpr_err(\"set interface failed\");\n\n\tstate->gpio_mode = MXL111SF_GPIO_MOD_ATSC;\n\tadap_state->gpio_mode = state->gpio_mode;\n\tadap_state->device_mode = MXL_TUNER_MODE;\n\tadap_state->ep6_clockphase = 1;\n\n\tret = mxl1x1sf_soft_reset(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_init_tuner_demod(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl1x1sf_set_device_mode(state, adap_state->device_mode);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl111sf_enable_usb_output(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl1x1sf_top_master_ctrl(state, 1);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl111sf_init_port_expander(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_gpio_mode_switch(state, state->gpio_mode);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tadap->fe[fe_id] = dvb_attach(lgdt3305_attach,\n\t\t\t\t &hauppauge_lgdt3305_config,\n\t\t\t\t &d->i2c_adap);\n\tif (adap->fe[fe_id]) {\n\t\tstate->num_frontends++;\n\t\tadap_state->fe_init = adap->fe[fe_id]->ops.init;\n\t\tadap->fe[fe_id]->ops.init = mxl111sf_adap_fe_init;\n\t\tadap_state->fe_sleep = adap->fe[fe_id]->ops.sleep;\n\t\tadap->fe[fe_id]->ops.sleep = mxl111sf_adap_fe_sleep;\n\t\treturn 0;\n\t}\n\tret = -EIO;\nfail:\n\treturn ret;\n}\n\nstatic struct lg2160_config hauppauge_lg2160_config = {\n\t.lg_chip            = LG2160,\n\t.i2c_addr           = 0x1c >> 1,\n\t.deny_i2c_rptr      = 1,\n\t.spectral_inversion = 0,\n\t.if_khz             = 6000,\n};\n\nstatic int mxl111sf_lg2160_frontend_attach(struct dvb_usb_adapter *adap, u8 fe_id)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct mxl111sf_state *state = d_to_priv(d);\n\tstruct mxl111sf_adap_state *adap_state = &state->adap_state[fe_id];\n\tint ret;\n\n\tpr_debug(\"%s()\\n\", __func__);\n\n\t \n\tstate->d = d;\n\tadap_state->alt_mode = (dvb_usb_mxl111sf_isoc) ? 2 : 1;\n\tstate->alt_mode = adap_state->alt_mode;\n\n\tif (usb_set_interface(d->udev, 0, state->alt_mode) < 0)\n\t\tpr_err(\"set interface failed\");\n\n\tstate->gpio_mode = MXL111SF_GPIO_MOD_MH;\n\tadap_state->gpio_mode = state->gpio_mode;\n\tadap_state->device_mode = MXL_TUNER_MODE;\n\tadap_state->ep6_clockphase = 1;\n\n\tret = mxl1x1sf_soft_reset(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_init_tuner_demod(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl1x1sf_set_device_mode(state, adap_state->device_mode);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl111sf_enable_usb_output(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl1x1sf_top_master_ctrl(state, 1);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl111sf_init_port_expander(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_gpio_mode_switch(state, state->gpio_mode);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = get_chip_info(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tadap->fe[fe_id] = dvb_attach(lg2160_attach,\n\t\t\t      &hauppauge_lg2160_config,\n\t\t\t      &d->i2c_adap);\n\tif (adap->fe[fe_id]) {\n\t\tstate->num_frontends++;\n\t\tadap_state->fe_init = adap->fe[fe_id]->ops.init;\n\t\tadap->fe[fe_id]->ops.init = mxl111sf_adap_fe_init;\n\t\tadap_state->fe_sleep = adap->fe[fe_id]->ops.sleep;\n\t\tadap->fe[fe_id]->ops.sleep = mxl111sf_adap_fe_sleep;\n\t\treturn 0;\n\t}\n\tret = -EIO;\nfail:\n\treturn ret;\n}\n\nstatic struct lg2160_config hauppauge_lg2161_1019_config = {\n\t.lg_chip            = LG2161_1019,\n\t.i2c_addr           = 0x1c >> 1,\n\t.deny_i2c_rptr      = 1,\n\t.spectral_inversion = 0,\n\t.if_khz             = 6000,\n\t.output_if          = 2,  \n};\n\nstatic struct lg2160_config hauppauge_lg2161_1040_config = {\n\t.lg_chip            = LG2161_1040,\n\t.i2c_addr           = 0x1c >> 1,\n\t.deny_i2c_rptr      = 1,\n\t.spectral_inversion = 0,\n\t.if_khz             = 6000,\n\t.output_if          = 4,  \n};\n\nstatic int mxl111sf_lg2161_frontend_attach(struct dvb_usb_adapter *adap, u8 fe_id)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct mxl111sf_state *state = d_to_priv(d);\n\tstruct mxl111sf_adap_state *adap_state = &state->adap_state[fe_id];\n\tint ret;\n\n\tpr_debug(\"%s()\\n\", __func__);\n\n\t \n\tstate->d = d;\n\tadap_state->alt_mode = (dvb_usb_mxl111sf_isoc) ? 2 : 1;\n\tstate->alt_mode = adap_state->alt_mode;\n\n\tif (usb_set_interface(d->udev, 0, state->alt_mode) < 0)\n\t\tpr_err(\"set interface failed\");\n\n\tstate->gpio_mode = MXL111SF_GPIO_MOD_MH;\n\tadap_state->gpio_mode = state->gpio_mode;\n\tadap_state->device_mode = MXL_TUNER_MODE;\n\tadap_state->ep6_clockphase = 1;\n\n\tret = mxl1x1sf_soft_reset(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_init_tuner_demod(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl1x1sf_set_device_mode(state, adap_state->device_mode);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl111sf_enable_usb_output(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl1x1sf_top_master_ctrl(state, 1);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl111sf_init_port_expander(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_gpio_mode_switch(state, state->gpio_mode);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = get_chip_info(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tadap->fe[fe_id] = dvb_attach(lg2160_attach,\n\t\t\t      (MXL111SF_V8_200 == state->chip_rev) ?\n\t\t\t      &hauppauge_lg2161_1040_config :\n\t\t\t      &hauppauge_lg2161_1019_config,\n\t\t\t      &d->i2c_adap);\n\tif (adap->fe[fe_id]) {\n\t\tstate->num_frontends++;\n\t\tadap_state->fe_init = adap->fe[fe_id]->ops.init;\n\t\tadap->fe[fe_id]->ops.init = mxl111sf_adap_fe_init;\n\t\tadap_state->fe_sleep = adap->fe[fe_id]->ops.sleep;\n\t\tadap->fe[fe_id]->ops.sleep = mxl111sf_adap_fe_sleep;\n\t\treturn 0;\n\t}\n\tret = -EIO;\nfail:\n\treturn ret;\n}\n\nstatic struct lg2160_config hauppauge_lg2161_1019_ep6_config = {\n\t.lg_chip            = LG2161_1019,\n\t.i2c_addr           = 0x1c >> 1,\n\t.deny_i2c_rptr      = 1,\n\t.spectral_inversion = 0,\n\t.if_khz             = 6000,\n\t.output_if          = 1,  \n};\n\nstatic struct lg2160_config hauppauge_lg2161_1040_ep6_config = {\n\t.lg_chip            = LG2161_1040,\n\t.i2c_addr           = 0x1c >> 1,\n\t.deny_i2c_rptr      = 1,\n\t.spectral_inversion = 0,\n\t.if_khz             = 6000,\n\t.output_if          = 7,  \n};\n\nstatic int mxl111sf_lg2161_ep6_frontend_attach(struct dvb_usb_adapter *adap, u8 fe_id)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct mxl111sf_state *state = d_to_priv(d);\n\tstruct mxl111sf_adap_state *adap_state = &state->adap_state[fe_id];\n\tint ret;\n\n\tpr_debug(\"%s()\\n\", __func__);\n\n\t \n\tstate->d = d;\n\tadap_state->alt_mode = (dvb_usb_mxl111sf_isoc) ? 2 : 1;\n\tstate->alt_mode = adap_state->alt_mode;\n\n\tif (usb_set_interface(d->udev, 0, state->alt_mode) < 0)\n\t\tpr_err(\"set interface failed\");\n\n\tstate->gpio_mode = MXL111SF_GPIO_MOD_MH;\n\tadap_state->gpio_mode = state->gpio_mode;\n\tadap_state->device_mode = MXL_TUNER_MODE;\n\tadap_state->ep6_clockphase = 0;\n\n\tret = mxl1x1sf_soft_reset(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_init_tuner_demod(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl1x1sf_set_device_mode(state, adap_state->device_mode);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl111sf_enable_usb_output(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl1x1sf_top_master_ctrl(state, 1);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl111sf_init_port_expander(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_gpio_mode_switch(state, state->gpio_mode);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = get_chip_info(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tadap->fe[fe_id] = dvb_attach(lg2160_attach,\n\t\t\t      (MXL111SF_V8_200 == state->chip_rev) ?\n\t\t\t      &hauppauge_lg2161_1040_ep6_config :\n\t\t\t      &hauppauge_lg2161_1019_ep6_config,\n\t\t\t      &d->i2c_adap);\n\tif (adap->fe[fe_id]) {\n\t\tstate->num_frontends++;\n\t\tadap_state->fe_init = adap->fe[fe_id]->ops.init;\n\t\tadap->fe[fe_id]->ops.init = mxl111sf_adap_fe_init;\n\t\tadap_state->fe_sleep = adap->fe[fe_id]->ops.sleep;\n\t\tadap->fe[fe_id]->ops.sleep = mxl111sf_adap_fe_sleep;\n\t\treturn 0;\n\t}\n\tret = -EIO;\nfail:\n\treturn ret;\n}\n\nstatic const struct mxl111sf_demod_config mxl_demod_config = {\n\t.read_reg        = mxl111sf_read_reg,\n\t.write_reg       = mxl111sf_write_reg,\n\t.program_regs    = mxl111sf_ctrl_program_regs,\n};\n\nstatic int mxl111sf_attach_demod(struct dvb_usb_adapter *adap, u8 fe_id)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tstruct mxl111sf_state *state = d_to_priv(d);\n\tstruct mxl111sf_adap_state *adap_state = &state->adap_state[fe_id];\n\tint ret;\n\n\tpr_debug(\"%s()\\n\", __func__);\n\n\t \n\tstate->d = d;\n\tadap_state->alt_mode = (dvb_usb_mxl111sf_isoc) ? 1 : 2;\n\tstate->alt_mode = adap_state->alt_mode;\n\n\tif (usb_set_interface(d->udev, 0, state->alt_mode) < 0)\n\t\tpr_err(\"set interface failed\");\n\n\tstate->gpio_mode = MXL111SF_GPIO_MOD_DVBT;\n\tadap_state->gpio_mode = state->gpio_mode;\n\tadap_state->device_mode = MXL_SOC_MODE;\n\tadap_state->ep6_clockphase = 1;\n\n\tret = mxl1x1sf_soft_reset(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl111sf_init_tuner_demod(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl1x1sf_set_device_mode(state, adap_state->device_mode);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl111sf_enable_usb_output(state);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tret = mxl1x1sf_top_master_ctrl(state, 1);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\t \n\tmxl111sf_init_port_expander(state);\n\n\tadap->fe[fe_id] = dvb_attach(mxl111sf_demod_attach, state,\n\t\t\t      &mxl_demod_config);\n\tif (adap->fe[fe_id]) {\n\t\tstate->num_frontends++;\n\t\tadap_state->fe_init = adap->fe[fe_id]->ops.init;\n\t\tadap->fe[fe_id]->ops.init = mxl111sf_adap_fe_init;\n\t\tadap_state->fe_sleep = adap->fe[fe_id]->ops.sleep;\n\t\tadap->fe[fe_id]->ops.sleep = mxl111sf_adap_fe_sleep;\n\t\treturn 0;\n\t}\n\tret = -EIO;\nfail:\n\treturn ret;\n}\n\nstatic inline int mxl111sf_set_ant_path(struct mxl111sf_state *state,\n\t\t\t\t\tint antpath)\n{\n\treturn mxl111sf_idac_config(state, 1, 1,\n\t\t\t\t    (antpath == ANT_PATH_INTERNAL) ?\n\t\t\t\t    0x3f : 0x00, 0);\n}\n\n#define DbgAntHunt(x, pwr0, pwr1, pwr2, pwr3) \\\n\tpr_err(\"%s(%d) FINAL input set to %s rxPwr:%d|%d|%d|%d\\n\", \\\n\t    __func__, __LINE__, \\\n\t    (ANT_PATH_EXTERNAL == x) ? \"EXTERNAL\" : \"INTERNAL\", \\\n\t    pwr0, pwr1, pwr2, pwr3)\n\n#define ANT_HUNT_SLEEP 90\n#define ANT_EXT_TWEAK 0\n\nstatic int mxl111sf_ant_hunt(struct dvb_frontend *fe)\n{\n\tstruct mxl111sf_state *state = fe_to_priv(fe);\n\tint antctrl = dvb_usb_mxl111sf_rfswitch;\n\n\tu16 rxPwrA, rxPwr0, rxPwr1, rxPwr2;\n\n\t \n\tmxl111sf_set_ant_path(state, antctrl == ANT_PATH_AUTO ?\n\t\t\t      ANT_PATH_EXTERNAL : antctrl);\n\n\tif (antctrl == ANT_PATH_AUTO) {\n#if 0\n\t\tmsleep(ANT_HUNT_SLEEP);\n#endif\n\t\tfe->ops.tuner_ops.get_rf_strength(fe, &rxPwrA);\n\n\t\tmxl111sf_set_ant_path(state, ANT_PATH_EXTERNAL);\n\t\tmsleep(ANT_HUNT_SLEEP);\n\t\tfe->ops.tuner_ops.get_rf_strength(fe, &rxPwr0);\n\n\t\tmxl111sf_set_ant_path(state, ANT_PATH_EXTERNAL);\n\t\tmsleep(ANT_HUNT_SLEEP);\n\t\tfe->ops.tuner_ops.get_rf_strength(fe, &rxPwr1);\n\n\t\tmxl111sf_set_ant_path(state, ANT_PATH_INTERNAL);\n\t\tmsleep(ANT_HUNT_SLEEP);\n\t\tfe->ops.tuner_ops.get_rf_strength(fe, &rxPwr2);\n\n\t\tif (rxPwr1+ANT_EXT_TWEAK >= rxPwr2) {\n\t\t\t \n\t\t\tmxl111sf_set_ant_path(state, ANT_PATH_EXTERNAL);\n\t\t\tDbgAntHunt(ANT_PATH_EXTERNAL, rxPwrA,\n\t\t\t\t   rxPwr0, rxPwr1, rxPwr2);\n\t\t} else {\n\t\t\t \n\t\t\tDbgAntHunt(ANT_PATH_INTERNAL, rxPwrA,\n\t\t\t\t   rxPwr0, rxPwr1, rxPwr2);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct mxl111sf_tuner_config mxl_tuner_config = {\n\t.if_freq         = MXL_IF_6_0,  \n\t.invert_spectrum = 0,\n\t.read_reg        = mxl111sf_read_reg,\n\t.write_reg       = mxl111sf_write_reg,\n\t.program_regs    = mxl111sf_ctrl_program_regs,\n\t.top_master_ctrl = mxl1x1sf_top_master_ctrl,\n\t.ant_hunt        = mxl111sf_ant_hunt,\n};\n\nstatic int mxl111sf_attach_tuner(struct dvb_usb_adapter *adap)\n{\n\tstruct mxl111sf_state *state = adap_to_priv(adap);\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tstruct media_device *mdev = dvb_get_media_controller(&adap->dvb_adap);\n\tint ret;\n#endif\n\tint i;\n\n\tpr_debug(\"%s()\\n\", __func__);\n\n\tfor (i = 0; i < state->num_frontends; i++) {\n\t\tif (dvb_attach(mxl111sf_tuner_attach, adap->fe[i], state,\n\t\t\t\t&mxl_tuner_config) == NULL)\n\t\t\treturn -EIO;\n\t\tadap->fe[i]->ops.read_signal_strength = adap->fe[i]->ops.tuner_ops.get_rf_strength;\n\t}\n\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tstate->tuner.function = MEDIA_ENT_F_TUNER;\n\tstate->tuner.name = \"mxl111sf tuner\";\n\tstate->tuner_pads[MXL111SF_PAD_RF_INPUT].flags = MEDIA_PAD_FL_SINK;\n\tstate->tuner_pads[MXL111SF_PAD_RF_INPUT].sig_type = PAD_SIGNAL_ANALOG;\n\tstate->tuner_pads[MXL111SF_PAD_OUTPUT].flags = MEDIA_PAD_FL_SOURCE;\n\tstate->tuner_pads[MXL111SF_PAD_OUTPUT].sig_type = PAD_SIGNAL_ANALOG;\n\n\tret = media_entity_pads_init(&state->tuner,\n\t\t\t\t     MXL111SF_NUM_PADS, state->tuner_pads);\n\tif (ret)\n\t\treturn ret;\n\n\tret = media_device_register_entity(mdev, &state->tuner);\n\tif (ret)\n\t\treturn ret;\n#endif\n\treturn 0;\n}\n\nstatic u32 mxl111sf_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm mxl111sf_i2c_algo = {\n\t.master_xfer   = mxl111sf_i2c_xfer,\n\t.functionality = mxl111sf_i2c_func,\n#ifdef NEED_ALGO_CONTROL\n\t.algo_control = dummy_algo_control,\n#endif\n};\n\nstatic int mxl111sf_init(struct dvb_usb_device *d)\n{\n\tstruct mxl111sf_state *state = d_to_priv(d);\n\tint ret;\n\tstatic u8 eeprom[256];\n\tu8 reg = 0;\n\tstruct i2c_msg msg[2] = {\n\t\t{ .addr = 0xa0 >> 1, .len = 1, .buf = &reg },\n\t\t{ .addr = 0xa0 >> 1, .flags = I2C_M_RD,\n\t\t  .len = sizeof(eeprom), .buf = eeprom },\n\t};\n\n\tret = get_chip_info(state);\n\tif (mxl_fail(ret))\n\t\tpr_err(\"failed to get chip info during probe\");\n\n\tmutex_init(&state->fe_lock);\n\n\tif (state->chip_rev > MXL111SF_V6)\n\t\tmxl111sf_config_pin_mux_modes(state, PIN_MUX_TS_SPI_IN_MODE_1);\n\n\tret = i2c_transfer(&d->i2c_adap, msg, 2);\n\tif (mxl_fail(ret))\n\t\treturn 0;\n\ttveeprom_hauppauge_analog(&state->tv, (0x84 == eeprom[0xa0]) ?\n\t\t\t\t  eeprom + 0xa0 : eeprom + 0x80);\n#if 0\n\tswitch (state->tv.model) {\n\tcase 117001:\n\tcase 126001:\n\tcase 138001:\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"%s: warning: unknown hauppauge model #%d\\n\",\n\t\t       __func__, state->tv.model);\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int mxl111sf_frontend_attach_dvbt(struct dvb_usb_adapter *adap)\n{\n\treturn mxl111sf_attach_demod(adap, 0);\n}\n\nstatic int mxl111sf_frontend_attach_atsc(struct dvb_usb_adapter *adap)\n{\n\treturn mxl111sf_lgdt3305_frontend_attach(adap, 0);\n}\n\nstatic int mxl111sf_frontend_attach_mh(struct dvb_usb_adapter *adap)\n{\n\treturn mxl111sf_lg2160_frontend_attach(adap, 0);\n}\n\nstatic int mxl111sf_frontend_attach_atsc_mh(struct dvb_usb_adapter *adap)\n{\n\tint ret;\n\tpr_debug(\"%s\\n\", __func__);\n\n\tret = mxl111sf_lgdt3305_frontend_attach(adap, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mxl111sf_attach_demod(adap, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mxl111sf_lg2160_frontend_attach(adap, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic int mxl111sf_frontend_attach_mercury(struct dvb_usb_adapter *adap)\n{\n\tint ret;\n\tpr_debug(\"%s\\n\", __func__);\n\n\tret = mxl111sf_lgdt3305_frontend_attach(adap, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mxl111sf_attach_demod(adap, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mxl111sf_lg2161_ep6_frontend_attach(adap, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic int mxl111sf_frontend_attach_mercury_mh(struct dvb_usb_adapter *adap)\n{\n\tint ret;\n\tpr_debug(\"%s\\n\", __func__);\n\n\tret = mxl111sf_attach_demod(adap, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (dvb_usb_mxl111sf_spi)\n\t\tret = mxl111sf_lg2161_frontend_attach(adap, 1);\n\telse\n\t\tret = mxl111sf_lg2161_ep6_frontend_attach(adap, 1);\n\n\treturn ret;\n}\n\nstatic void mxl111sf_stream_config_bulk(struct usb_data_stream_properties *stream, u8 endpoint)\n{\n\tpr_debug(\"%s: endpoint=%d size=8192\\n\", __func__, endpoint);\n\tstream->type = USB_BULK;\n\tstream->count = 5;\n\tstream->endpoint = endpoint;\n\tstream->u.bulk.buffersize = 8192;\n}\n\nstatic void mxl111sf_stream_config_isoc(struct usb_data_stream_properties *stream,\n\t\tu8 endpoint, int framesperurb, int framesize)\n{\n\tpr_debug(\"%s: endpoint=%d size=%d\\n\", __func__, endpoint,\n\t\t\tframesperurb * framesize);\n\tstream->type = USB_ISOC;\n\tstream->count = 5;\n\tstream->endpoint = endpoint;\n\tstream->u.isoc.framesperurb = framesperurb;\n\tstream->u.isoc.framesize = framesize;\n\tstream->u.isoc.interval = 1;\n}\n\n \n\n \nstatic int mxl111sf_get_stream_config_dvbt(struct dvb_frontend *fe,\n\t\tu8 *ts_type, struct usb_data_stream_properties *stream)\n{\n\tpr_debug(\"%s: fe=%d\\n\", __func__, fe->id);\n\n\t*ts_type = DVB_USB_FE_TS_TYPE_188;\n\tif (dvb_usb_mxl111sf_isoc)\n\t\tmxl111sf_stream_config_isoc(stream, 4, 96, 564);\n\telse\n\t\tmxl111sf_stream_config_bulk(stream, 4);\n\treturn 0;\n}\n\nstatic int mxl111sf_probe(struct dvb_usb_device *dev)\n{\n\tstruct mxl111sf_state *state = d_to_priv(dev);\n\n\tmutex_init(&state->msg_lock);\n\treturn 0;\n}\n\nstatic struct dvb_usb_device_properties mxl111sf_props_dvbt = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\t.size_of_priv = sizeof(struct mxl111sf_state),\n\n\t.generic_bulk_ctrl_endpoint = 0x02,\n\t.generic_bulk_ctrl_endpoint_response = 0x81,\n\n\t.probe             = mxl111sf_probe,\n\t.i2c_algo          = &mxl111sf_i2c_algo,\n\t.frontend_attach   = mxl111sf_frontend_attach_dvbt,\n\t.tuner_attach      = mxl111sf_attach_tuner,\n\t.init              = mxl111sf_init,\n\t.streaming_ctrl    = mxl111sf_ep4_streaming_ctrl,\n\t.get_stream_config = mxl111sf_get_stream_config_dvbt,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t\t.stream = DVB_USB_STREAM_ISOC(6, 5, 24, 3072, 1),\n\t\t}\n\t}\n};\n\n \nstatic int mxl111sf_get_stream_config_atsc(struct dvb_frontend *fe,\n\t\tu8 *ts_type, struct usb_data_stream_properties *stream)\n{\n\tpr_debug(\"%s: fe=%d\\n\", __func__, fe->id);\n\n\t*ts_type = DVB_USB_FE_TS_TYPE_188;\n\tif (dvb_usb_mxl111sf_isoc)\n\t\tmxl111sf_stream_config_isoc(stream, 6, 24, 3072);\n\telse\n\t\tmxl111sf_stream_config_bulk(stream, 6);\n\treturn 0;\n}\n\nstatic struct dvb_usb_device_properties mxl111sf_props_atsc = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\t.size_of_priv = sizeof(struct mxl111sf_state),\n\n\t.generic_bulk_ctrl_endpoint = 0x02,\n\t.generic_bulk_ctrl_endpoint_response = 0x81,\n\n\t.probe             = mxl111sf_probe,\n\t.i2c_algo          = &mxl111sf_i2c_algo,\n\t.frontend_attach   = mxl111sf_frontend_attach_atsc,\n\t.tuner_attach      = mxl111sf_attach_tuner,\n\t.init              = mxl111sf_init,\n\t.streaming_ctrl    = mxl111sf_ep6_streaming_ctrl,\n\t.get_stream_config = mxl111sf_get_stream_config_atsc,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t\t.stream = DVB_USB_STREAM_ISOC(6, 5, 24, 3072, 1),\n\t\t}\n\t}\n};\n\n \nstatic int mxl111sf_get_stream_config_mh(struct dvb_frontend *fe,\n\t\tu8 *ts_type, struct usb_data_stream_properties *stream)\n{\n\tpr_debug(\"%s: fe=%d\\n\", __func__, fe->id);\n\n\t*ts_type = DVB_USB_FE_TS_TYPE_RAW;\n\tif (dvb_usb_mxl111sf_isoc)\n\t\tmxl111sf_stream_config_isoc(stream, 5, 96, 200);\n\telse\n\t\tmxl111sf_stream_config_bulk(stream, 5);\n\treturn 0;\n}\n\nstatic struct dvb_usb_device_properties mxl111sf_props_mh = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\t.size_of_priv = sizeof(struct mxl111sf_state),\n\n\t.generic_bulk_ctrl_endpoint = 0x02,\n\t.generic_bulk_ctrl_endpoint_response = 0x81,\n\n\t.probe             = mxl111sf_probe,\n\t.i2c_algo          = &mxl111sf_i2c_algo,\n\t.frontend_attach   = mxl111sf_frontend_attach_mh,\n\t.tuner_attach      = mxl111sf_attach_tuner,\n\t.init              = mxl111sf_init,\n\t.streaming_ctrl    = mxl111sf_ep5_streaming_ctrl,\n\t.get_stream_config = mxl111sf_get_stream_config_mh,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t\t.stream = DVB_USB_STREAM_ISOC(6, 5, 24, 3072, 1),\n\t\t}\n\t}\n};\n\n \nstatic int mxl111sf_get_stream_config_atsc_mh(struct dvb_frontend *fe,\n\t\tu8 *ts_type, struct usb_data_stream_properties *stream)\n{\n\tpr_debug(\"%s: fe=%d\\n\", __func__, fe->id);\n\n\tif (fe->id == 0) {\n\t\t*ts_type = DVB_USB_FE_TS_TYPE_188;\n\t\tif (dvb_usb_mxl111sf_isoc)\n\t\t\tmxl111sf_stream_config_isoc(stream, 6, 24, 3072);\n\t\telse\n\t\t\tmxl111sf_stream_config_bulk(stream, 6);\n\t} else if (fe->id == 1) {\n\t\t*ts_type = DVB_USB_FE_TS_TYPE_188;\n\t\tif (dvb_usb_mxl111sf_isoc)\n\t\t\tmxl111sf_stream_config_isoc(stream, 4, 96, 564);\n\t\telse\n\t\t\tmxl111sf_stream_config_bulk(stream, 4);\n\t} else if (fe->id == 2) {\n\t\t*ts_type = DVB_USB_FE_TS_TYPE_RAW;\n\t\tif (dvb_usb_mxl111sf_isoc)\n\t\t\tmxl111sf_stream_config_isoc(stream, 5, 96, 200);\n\t\telse\n\t\t\tmxl111sf_stream_config_bulk(stream, 5);\n\t}\n\treturn 0;\n}\n\nstatic int mxl111sf_streaming_ctrl_atsc_mh(struct dvb_frontend *fe, int onoff)\n{\n\tpr_debug(\"%s: fe=%d onoff=%d\\n\", __func__, fe->id, onoff);\n\n\tif (fe->id == 0)\n\t\treturn mxl111sf_ep6_streaming_ctrl(fe, onoff);\n\telse if (fe->id == 1)\n\t\treturn mxl111sf_ep4_streaming_ctrl(fe, onoff);\n\telse if (fe->id == 2)\n\t\treturn mxl111sf_ep5_streaming_ctrl(fe, onoff);\n\treturn 0;\n}\n\nstatic struct dvb_usb_device_properties mxl111sf_props_atsc_mh = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\t.size_of_priv = sizeof(struct mxl111sf_state),\n\n\t.generic_bulk_ctrl_endpoint = 0x02,\n\t.generic_bulk_ctrl_endpoint_response = 0x81,\n\n\t.probe             = mxl111sf_probe,\n\t.i2c_algo          = &mxl111sf_i2c_algo,\n\t.frontend_attach   = mxl111sf_frontend_attach_atsc_mh,\n\t.tuner_attach      = mxl111sf_attach_tuner,\n\t.init              = mxl111sf_init,\n\t.streaming_ctrl    = mxl111sf_streaming_ctrl_atsc_mh,\n\t.get_stream_config = mxl111sf_get_stream_config_atsc_mh,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t\t.stream = DVB_USB_STREAM_ISOC(6, 5, 24, 3072, 1),\n\t\t}\n\t}\n};\n\n \nstatic int mxl111sf_get_stream_config_mercury(struct dvb_frontend *fe,\n\t\tu8 *ts_type, struct usb_data_stream_properties *stream)\n{\n\tpr_debug(\"%s: fe=%d\\n\", __func__, fe->id);\n\n\tif (fe->id == 0) {\n\t\t*ts_type = DVB_USB_FE_TS_TYPE_188;\n\t\tif (dvb_usb_mxl111sf_isoc)\n\t\t\tmxl111sf_stream_config_isoc(stream, 6, 24, 3072);\n\t\telse\n\t\t\tmxl111sf_stream_config_bulk(stream, 6);\n\t} else if (fe->id == 1) {\n\t\t*ts_type = DVB_USB_FE_TS_TYPE_188;\n\t\tif (dvb_usb_mxl111sf_isoc)\n\t\t\tmxl111sf_stream_config_isoc(stream, 4, 96, 564);\n\t\telse\n\t\t\tmxl111sf_stream_config_bulk(stream, 4);\n\t} else if (fe->id == 2 && dvb_usb_mxl111sf_spi) {\n\t\t*ts_type = DVB_USB_FE_TS_TYPE_RAW;\n\t\tif (dvb_usb_mxl111sf_isoc)\n\t\t\tmxl111sf_stream_config_isoc(stream, 5, 96, 200);\n\t\telse\n\t\t\tmxl111sf_stream_config_bulk(stream, 5);\n\t} else if (fe->id == 2 && !dvb_usb_mxl111sf_spi) {\n\t\t*ts_type = DVB_USB_FE_TS_TYPE_RAW;\n\t\tif (dvb_usb_mxl111sf_isoc)\n\t\t\tmxl111sf_stream_config_isoc(stream, 6, 24, 3072);\n\t\telse\n\t\t\tmxl111sf_stream_config_bulk(stream, 6);\n\t}\n\treturn 0;\n}\n\nstatic int mxl111sf_streaming_ctrl_mercury(struct dvb_frontend *fe, int onoff)\n{\n\tpr_debug(\"%s: fe=%d onoff=%d\\n\", __func__, fe->id, onoff);\n\n\tif (fe->id == 0)\n\t\treturn mxl111sf_ep6_streaming_ctrl(fe, onoff);\n\telse if (fe->id == 1)\n\t\treturn mxl111sf_ep4_streaming_ctrl(fe, onoff);\n\telse if (fe->id == 2 && dvb_usb_mxl111sf_spi)\n\t\treturn mxl111sf_ep5_streaming_ctrl(fe, onoff);\n\telse if (fe->id == 2 && !dvb_usb_mxl111sf_spi)\n\t\treturn mxl111sf_ep6_streaming_ctrl(fe, onoff);\n\treturn 0;\n}\n\nstatic struct dvb_usb_device_properties mxl111sf_props_mercury = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\t.size_of_priv = sizeof(struct mxl111sf_state),\n\n\t.generic_bulk_ctrl_endpoint = 0x02,\n\t.generic_bulk_ctrl_endpoint_response = 0x81,\n\n\t.probe             = mxl111sf_probe,\n\t.i2c_algo          = &mxl111sf_i2c_algo,\n\t.frontend_attach   = mxl111sf_frontend_attach_mercury,\n\t.tuner_attach      = mxl111sf_attach_tuner,\n\t.init              = mxl111sf_init,\n\t.streaming_ctrl    = mxl111sf_streaming_ctrl_mercury,\n\t.get_stream_config = mxl111sf_get_stream_config_mercury,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t\t.stream = DVB_USB_STREAM_ISOC(6, 5, 24, 3072, 1),\n\t\t}\n\t}\n};\n\n \nstatic int mxl111sf_get_stream_config_mercury_mh(struct dvb_frontend *fe,\n\t\tu8 *ts_type, struct usb_data_stream_properties *stream)\n{\n\tpr_debug(\"%s: fe=%d\\n\", __func__, fe->id);\n\n\tif (fe->id == 0) {\n\t\t*ts_type = DVB_USB_FE_TS_TYPE_188;\n\t\tif (dvb_usb_mxl111sf_isoc)\n\t\t\tmxl111sf_stream_config_isoc(stream, 4, 96, 564);\n\t\telse\n\t\t\tmxl111sf_stream_config_bulk(stream, 4);\n\t} else if (fe->id == 1 && dvb_usb_mxl111sf_spi) {\n\t\t*ts_type = DVB_USB_FE_TS_TYPE_RAW;\n\t\tif (dvb_usb_mxl111sf_isoc)\n\t\t\tmxl111sf_stream_config_isoc(stream, 5, 96, 200);\n\t\telse\n\t\t\tmxl111sf_stream_config_bulk(stream, 5);\n\t} else if (fe->id == 1 && !dvb_usb_mxl111sf_spi) {\n\t\t*ts_type = DVB_USB_FE_TS_TYPE_RAW;\n\t\tif (dvb_usb_mxl111sf_isoc)\n\t\t\tmxl111sf_stream_config_isoc(stream, 6, 24, 3072);\n\t\telse\n\t\t\tmxl111sf_stream_config_bulk(stream, 6);\n\t}\n\treturn 0;\n}\n\nstatic int mxl111sf_streaming_ctrl_mercury_mh(struct dvb_frontend *fe, int onoff)\n{\n\tpr_debug(\"%s: fe=%d onoff=%d\\n\", __func__, fe->id, onoff);\n\n\tif (fe->id == 0)\n\t\treturn mxl111sf_ep4_streaming_ctrl(fe, onoff);\n\telse if (fe->id == 1  && dvb_usb_mxl111sf_spi)\n\t\treturn mxl111sf_ep5_streaming_ctrl(fe, onoff);\n\telse if (fe->id == 1 && !dvb_usb_mxl111sf_spi)\n\t\treturn mxl111sf_ep6_streaming_ctrl(fe, onoff);\n\treturn 0;\n}\n\nstatic struct dvb_usb_device_properties mxl111sf_props_mercury_mh = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\t.size_of_priv = sizeof(struct mxl111sf_state),\n\n\t.generic_bulk_ctrl_endpoint = 0x02,\n\t.generic_bulk_ctrl_endpoint_response = 0x81,\n\n\t.probe             = mxl111sf_probe,\n\t.i2c_algo          = &mxl111sf_i2c_algo,\n\t.frontend_attach   = mxl111sf_frontend_attach_mercury_mh,\n\t.tuner_attach      = mxl111sf_attach_tuner,\n\t.init              = mxl111sf_init,\n\t.streaming_ctrl    = mxl111sf_streaming_ctrl_mercury_mh,\n\t.get_stream_config = mxl111sf_get_stream_config_mercury_mh,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t\t.stream = DVB_USB_STREAM_ISOC(6, 5, 24, 3072, 1),\n\t\t}\n\t}\n};\n\nstatic const struct usb_device_id mxl111sf_id_table[] = {\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xc600, &mxl111sf_props_atsc_mh, \"Hauppauge 126xxx ATSC+\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xc601, &mxl111sf_props_atsc, \"Hauppauge 126xxx ATSC\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xc602, &mxl111sf_props_mh, \"HCW 126xxx\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xc603, &mxl111sf_props_atsc_mh, \"Hauppauge 126xxx ATSC+\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xc604, &mxl111sf_props_dvbt, \"Hauppauge 126xxx DVBT\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xc609, &mxl111sf_props_atsc, \"Hauppauge 126xxx ATSC\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xc60a, &mxl111sf_props_mh, \"HCW 126xxx\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xc60b, &mxl111sf_props_atsc_mh, \"Hauppauge 126xxx ATSC+\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xc60c, &mxl111sf_props_dvbt, \"Hauppauge 126xxx DVBT\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xc653, &mxl111sf_props_atsc_mh, \"Hauppauge 126xxx ATSC+\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xc65b, &mxl111sf_props_atsc_mh, \"Hauppauge 126xxx ATSC+\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xb700, &mxl111sf_props_atsc_mh, \"Hauppauge 117xxx ATSC+\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xb701, &mxl111sf_props_atsc, \"Hauppauge 126xxx ATSC\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xb702, &mxl111sf_props_mh, \"HCW 117xxx\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xb703, &mxl111sf_props_atsc_mh, \"Hauppauge 117xxx ATSC+\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xb704, &mxl111sf_props_dvbt, \"Hauppauge 117xxx DVBT\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xb753, &mxl111sf_props_atsc_mh, \"Hauppauge 117xxx ATSC+\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xb763, &mxl111sf_props_atsc_mh, \"Hauppauge 117xxx ATSC+\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xb764, &mxl111sf_props_dvbt, \"Hauppauge 117xxx DVBT\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xd853, &mxl111sf_props_mercury, \"Hauppauge Mercury\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xd854, &mxl111sf_props_dvbt, \"Hauppauge 138xxx DVBT\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xd863, &mxl111sf_props_mercury, \"Hauppauge Mercury\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xd864, &mxl111sf_props_dvbt, \"Hauppauge 138xxx DVBT\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xd8d3, &mxl111sf_props_mercury, \"Hauppauge Mercury\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xd8d4, &mxl111sf_props_dvbt, \"Hauppauge 138xxx DVBT\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xd8e3, &mxl111sf_props_mercury, \"Hauppauge Mercury\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xd8e4, &mxl111sf_props_dvbt, \"Hauppauge 138xxx DVBT\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xd8ff, &mxl111sf_props_mercury, \"Hauppauge Mercury\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xc612, &mxl111sf_props_mercury_mh, \"Hauppauge 126xxx\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xc613, &mxl111sf_props_mercury, \"Hauppauge WinTV-Aero-M\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xc61a, &mxl111sf_props_mercury_mh, \"Hauppauge 126xxx\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xc61b, &mxl111sf_props_mercury, \"Hauppauge WinTV-Aero-M\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xb757, &mxl111sf_props_atsc_mh, \"Hauppauge 117xxx ATSC+\", NULL) },\n\t{ DVB_USB_DEVICE(USB_VID_HAUPPAUGE, 0xb767, &mxl111sf_props_atsc_mh, \"Hauppauge 117xxx ATSC+\", NULL) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, mxl111sf_id_table);\n\nstatic struct usb_driver mxl111sf_usb_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = mxl111sf_id_table,\n\t.probe = dvb_usbv2_probe,\n\t.disconnect = dvb_usbv2_disconnect,\n\t.suspend = dvb_usbv2_suspend,\n\t.resume = dvb_usbv2_resume,\n\t.no_dynamic_id = 1,\n\t.soft_unbind = 1,\n};\n\nmodule_usb_driver(mxl111sf_usb_driver);\n\nMODULE_AUTHOR(\"Michael Krufky <mkrufky@linuxtv.org>\");\nMODULE_DESCRIPTION(\"Driver for MaxLinear MxL111SF\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}