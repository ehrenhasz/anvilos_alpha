{
  "module_name": "ec168.c",
  "hash_id": "eafbb5a5e68db9e95ee2d0638166c2d20c2a5fcdc24e810e9511284c10de9d72",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb-v2/ec168.c",
  "human_readable_source": "\n \n\n#include \"ec168.h\"\n#include \"ec100.h\"\n#include \"mxl5005s.h\"\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic int ec168_ctrl_msg(struct dvb_usb_device *d, struct ec168_req *req)\n{\n\tint ret;\n\tunsigned int pipe;\n\tu8 request, requesttype;\n\tu8 *buf;\n\n\tswitch (req->cmd) {\n\tcase DOWNLOAD_FIRMWARE:\n\tcase GPIO:\n\tcase WRITE_I2C:\n\tcase STREAMING_CTRL:\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\n\t\trequest = req->cmd;\n\t\tbreak;\n\tcase READ_I2C:\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\n\t\trequest = req->cmd;\n\t\tbreak;\n\tcase GET_CONFIG:\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\n\t\trequest = CONFIG;\n\t\tbreak;\n\tcase SET_CONFIG:\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\n\t\trequest = CONFIG;\n\t\tbreak;\n\tcase WRITE_DEMOD:\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\n\t\trequest = DEMOD_RW;\n\t\tbreak;\n\tcase READ_DEMOD:\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\n\t\trequest = DEMOD_RW;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&d->udev->dev, \"%s: unknown command=%02x\\n\",\n\t\t\t\tKBUILD_MODNAME, req->cmd);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tbuf = kmalloc(req->size, GFP_KERNEL);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tif (requesttype == (USB_TYPE_VENDOR | USB_DIR_OUT)) {\n\t\t \n\t\tmemcpy(buf, req->data, req->size);\n\t\tpipe = usb_sndctrlpipe(d->udev, 0);\n\t} else {\n\t\t \n\t\tpipe = usb_rcvctrlpipe(d->udev, 0);\n\t}\n\n\tmsleep(1);  \n\n\tret = usb_control_msg(d->udev, pipe, request, requesttype, req->value,\n\t\treq->index, buf, req->size, EC168_USB_TIMEOUT);\n\n\tdvb_usb_dbg_usb_control_msg(d->udev, request, requesttype, req->value,\n\t\t\treq->index, buf, req->size);\n\n\tif (ret < 0)\n\t\tgoto err_dealloc;\n\telse\n\t\tret = 0;\n\n\t \n\tif (!ret && requesttype == (USB_TYPE_VENDOR | USB_DIR_IN))\n\t\tmemcpy(req->data, buf, req->size);\n\n\tkfree(buf);\n\treturn ret;\n\nerr_dealloc:\n\tkfree(buf);\nerror:\n\tdev_dbg(&d->udev->dev, \"%s: failed=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\n \nstatic struct ec100_config ec168_ec100_config;\n\nstatic int ec168_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\tint num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstruct ec168_req req;\n\tint i = 0;\n\tint ret;\n\n\tif (num > 2)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\twhile (i < num) {\n\t\tif (num > i + 1 && (msg[i+1].flags & I2C_M_RD)) {\n\t\t\tif (msg[i].addr == ec168_ec100_config.demod_address) {\n\t\t\t\tif (msg[i].len < 1) {\n\t\t\t\t\ti = -EOPNOTSUPP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treq.cmd = READ_DEMOD;\n\t\t\t\treq.value = 0;\n\t\t\t\treq.index = 0xff00 + msg[i].buf[0];  \n\t\t\t\treq.size = msg[i+1].len;  \n\t\t\t\treq.data = &msg[i+1].buf[0];\n\t\t\t\tret = ec168_ctrl_msg(d, &req);\n\t\t\t\ti += 2;\n\t\t\t} else {\n\t\t\t\tdev_err(&d->udev->dev, \"%s: I2C read not \" \\\n\t\t\t\t\t\t\"implemented\\n\",\n\t\t\t\t\t\tKBUILD_MODNAME);\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t} else {\n\t\t\tif (msg[i].addr == ec168_ec100_config.demod_address) {\n\t\t\t\tif (msg[i].len < 1) {\n\t\t\t\t\ti = -EOPNOTSUPP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treq.cmd = WRITE_DEMOD;\n\t\t\t\treq.value = msg[i].buf[1];  \n\t\t\t\treq.index = 0xff00 + msg[i].buf[0];  \n\t\t\t\treq.size = 0;\n\t\t\t\treq.data = NULL;\n\t\t\t\tret = ec168_ctrl_msg(d, &req);\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tif (msg[i].len < 1) {\n\t\t\t\t\ti = -EOPNOTSUPP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treq.cmd = WRITE_I2C;\n\t\t\t\treq.value = msg[i].buf[0];  \n\t\t\t\treq.index = 0x0100 + msg[i].addr;  \n\t\t\t\treq.size = msg[i].len-1;\n\t\t\t\treq.data = &msg[i].buf[1];\n\t\t\t\tret = ec168_ctrl_msg(d, &req);\n\t\t\t\ti += 1;\n\t\t\t}\n\t\t}\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t}\n\tret = i;\n\nerror:\n\tmutex_unlock(&d->i2c_mutex);\n\treturn ret;\n}\n\nstatic u32 ec168_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm ec168_i2c_algo = {\n\t.master_xfer   = ec168_i2c_xfer,\n\t.functionality = ec168_i2c_func,\n};\n\n \nstatic int ec168_identify_state(struct dvb_usb_device *d, const char **name)\n{\n\tint ret;\n\tu8 reply;\n\tstruct ec168_req req = {GET_CONFIG, 0, 1, sizeof(reply), &reply};\n\tdev_dbg(&d->udev->dev, \"%s:\\n\", __func__);\n\n\tret = ec168_ctrl_msg(d, &req);\n\tif (ret)\n\t\tgoto error;\n\n\tdev_dbg(&d->udev->dev, \"%s: reply=%02x\\n\", __func__, reply);\n\n\tif (reply == 0x01)\n\t\tret = WARM;\n\telse\n\t\tret = COLD;\n\n\treturn ret;\nerror:\n\tdev_dbg(&d->udev->dev, \"%s: failed=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int ec168_download_firmware(struct dvb_usb_device *d,\n\t\tconst struct firmware *fw)\n{\n\tint ret, len, remaining;\n\tstruct ec168_req req = {DOWNLOAD_FIRMWARE, 0, 0, 0, NULL};\n\tdev_dbg(&d->udev->dev, \"%s:\\n\", __func__);\n\n\t#define LEN_MAX 2048  \n\tfor (remaining = fw->size; remaining > 0; remaining -= LEN_MAX) {\n\t\tlen = remaining;\n\t\tif (len > LEN_MAX)\n\t\t\tlen = LEN_MAX;\n\n\t\treq.size = len;\n\t\treq.data = (u8 *) &fw->data[fw->size - remaining];\n\t\treq.index = fw->size - remaining;\n\n\t\tret = ec168_ctrl_msg(d, &req);\n\t\tif (ret) {\n\t\t\tdev_err(&d->udev->dev,\n\t\t\t\t\t\"%s: firmware download failed=%d\\n\",\n\t\t\t\t\tKBUILD_MODNAME, ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treq.size = 0;\n\n\t \n\treq.cmd = SET_CONFIG;\n\treq.value = 0;\n\treq.index = 0x0001;\n\tret = ec168_ctrl_msg(d, &req);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\treq.cmd = GPIO;\n\treq.value = 0;\n\treq.index = 0x0206;\n\tret = ec168_ctrl_msg(d, &req);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\treq.cmd = WRITE_I2C;\n\treq.value = 0;\n\treq.index = 0x00c6;\n\tret = ec168_ctrl_msg(d, &req);\n\tif (ret)\n\t\tgoto error;\n\n\treturn ret;\nerror:\n\tdev_dbg(&d->udev->dev, \"%s: failed=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic struct ec100_config ec168_ec100_config = {\n\t.demod_address = 0xff,  \n};\n\nstatic int ec168_ec100_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tdev_dbg(&d->udev->dev, \"%s:\\n\", __func__);\n\n\tadap->fe[0] = dvb_attach(ec100_attach, &ec168_ec100_config,\n\t\t\t&d->i2c_adap);\n\tif (adap->fe[0] == NULL)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic struct mxl5005s_config ec168_mxl5003s_config = {\n\t.i2c_address     = 0xc6,\n\t.if_freq         = IF_FREQ_4570000HZ,\n\t.xtal_freq       = CRYSTAL_FREQ_16000000HZ,\n\t.agc_mode        = MXL_SINGLE_AGC,\n\t.tracking_filter = MXL_TF_OFF,\n\t.rssi_enable     = MXL_RSSI_ENABLE,\n\t.cap_select      = MXL_CAP_SEL_ENABLE,\n\t.div_out         = MXL_DIV_OUT_4,\n\t.clock_out       = MXL_CLOCK_OUT_DISABLE,\n\t.output_load     = MXL5005S_IF_OUTPUT_LOAD_200_OHM,\n\t.top\t\t = MXL5005S_TOP_25P2,\n\t.mod_mode        = MXL_DIGITAL_MODE,\n\t.if_mode         = MXL_ZERO_IF,\n\t.AgcMasterByte   = 0x00,\n};\n\nstatic int ec168_mxl5003s_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\tdev_dbg(&d->udev->dev, \"%s:\\n\", __func__);\n\n\treturn dvb_attach(mxl5005s_attach, adap->fe[0], &d->i2c_adap,\n\t\t\t&ec168_mxl5003s_config) == NULL ? -ENODEV : 0;\n}\n\nstatic int ec168_streaming_ctrl(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dvb_usb_device *d = fe_to_d(fe);\n\tstruct ec168_req req = {STREAMING_CTRL, 0x7f01, 0x0202, 0, NULL};\n\tdev_dbg(&d->udev->dev, \"%s: onoff=%d\\n\", __func__, onoff);\n\n\tif (onoff)\n\t\treq.index = 0x0102;\n\treturn ec168_ctrl_msg(d, &req);\n}\n\n \n \nstatic const struct dvb_usb_device_properties ec168_props = {\n\t.driver_name = KBUILD_MODNAME,\n\t.owner = THIS_MODULE,\n\t.adapter_nr = adapter_nr,\n\t.bInterfaceNumber = 1,\n\n\t.identify_state = ec168_identify_state,\n\t.firmware = EC168_FIRMWARE,\n\t.download_firmware = ec168_download_firmware,\n\n\t.i2c_algo = &ec168_i2c_algo,\n\t.frontend_attach = ec168_ec100_frontend_attach,\n\t.tuner_attach = ec168_mxl5003s_tuner_attach,\n\t.streaming_ctrl = ec168_streaming_ctrl,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t\t.stream = DVB_USB_STREAM_BULK(0x82, 6, 32 * 512),\n\t\t}\n\t},\n};\n\nstatic const struct usb_device_id ec168_id[] = {\n\t{ DVB_USB_DEVICE(USB_VID_E3C, USB_PID_E3C_EC168,\n\t\t     &ec168_props, \"E3C EC168 reference design\", NULL)},\n\t{ DVB_USB_DEVICE(USB_VID_E3C, USB_PID_E3C_EC168_2,\n\t\t     &ec168_props, \"E3C EC168 reference design\", NULL)},\n\t{ DVB_USB_DEVICE(USB_VID_E3C, USB_PID_E3C_EC168_3,\n\t\t     &ec168_props, \"E3C EC168 reference design\", NULL)},\n\t{ DVB_USB_DEVICE(USB_VID_E3C, USB_PID_E3C_EC168_4,\n\t\t     &ec168_props, \"E3C EC168 reference design\", NULL)},\n\t{ DVB_USB_DEVICE(USB_VID_E3C, USB_PID_E3C_EC168_5,\n\t\t     &ec168_props, \"E3C EC168 reference design\", NULL)},\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, ec168_id);\n\nstatic struct usb_driver ec168_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = ec168_id,\n\t.probe = dvb_usbv2_probe,\n\t.disconnect = dvb_usbv2_disconnect,\n\t.suspend = dvb_usbv2_suspend,\n\t.resume = dvb_usbv2_resume,\n\t.no_dynamic_id = 1,\n\t.soft_unbind = 1,\n};\n\nmodule_usb_driver(ec168_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"E3C EC168 driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(EC168_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}