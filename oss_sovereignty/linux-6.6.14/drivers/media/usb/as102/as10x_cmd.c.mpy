{
  "module_name": "as10x_cmd.c",
  "hash_id": "c9fc574673adba018525418a21eb78eb2568e8f9e1bc1742f37f29d27b8b53b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/as102/as10x_cmd.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include \"as102_drv.h\"\n#include \"as10x_cmd.h\"\n\n \nint as10x_cmd_turn_on(struct as10x_bus_adapter_t *adap)\n{\n\tint error = AS10X_CMD_ERROR;\n\tstruct as10x_cmd_t *pcmd, *prsp;\n\n\tpcmd = adap->cmd;\n\tprsp = adap->rsp;\n\n\t \n\tas10x_cmd_build(pcmd, (++adap->cmd_xid),\n\t\t\tsizeof(pcmd->body.turn_on.req));\n\n\t \n\tpcmd->body.turn_on.req.proc_id = cpu_to_le16(CONTROL_PROC_TURNON);\n\n\t \n\tif (adap->ops->xfer_cmd) {\n\t\terror = adap->ops->xfer_cmd(adap, (uint8_t *) pcmd,\n\t\t\t\t\t    sizeof(pcmd->body.turn_on.req) +\n\t\t\t\t\t    HEADER_SIZE,\n\t\t\t\t\t    (uint8_t *) prsp,\n\t\t\t\t\t    sizeof(prsp->body.turn_on.rsp) +\n\t\t\t\t\t    HEADER_SIZE);\n\t}\n\n\tif (error < 0)\n\t\tgoto out;\n\n\t \n\terror = as10x_rsp_parse(prsp, CONTROL_PROC_TURNON_RSP);\n\nout:\n\treturn error;\n}\n\n \nint as10x_cmd_turn_off(struct as10x_bus_adapter_t *adap)\n{\n\tint error = AS10X_CMD_ERROR;\n\tstruct as10x_cmd_t *pcmd, *prsp;\n\n\tpcmd = adap->cmd;\n\tprsp = adap->rsp;\n\n\t \n\tas10x_cmd_build(pcmd, (++adap->cmd_xid),\n\t\t\tsizeof(pcmd->body.turn_off.req));\n\n\t \n\tpcmd->body.turn_off.req.proc_id = cpu_to_le16(CONTROL_PROC_TURNOFF);\n\n\t \n\tif (adap->ops->xfer_cmd) {\n\t\terror = adap->ops->xfer_cmd(\n\t\t\tadap, (uint8_t *) pcmd,\n\t\t\tsizeof(pcmd->body.turn_off.req) + HEADER_SIZE,\n\t\t\t(uint8_t *) prsp,\n\t\t\tsizeof(prsp->body.turn_off.rsp) + HEADER_SIZE);\n\t}\n\n\tif (error < 0)\n\t\tgoto out;\n\n\t \n\terror = as10x_rsp_parse(prsp, CONTROL_PROC_TURNOFF_RSP);\n\nout:\n\treturn error;\n}\n\n \nint as10x_cmd_set_tune(struct as10x_bus_adapter_t *adap,\n\t\t       struct as10x_tune_args *ptune)\n{\n\tint error = AS10X_CMD_ERROR;\n\tstruct as10x_cmd_t *preq, *prsp;\n\n\tpreq = adap->cmd;\n\tprsp = adap->rsp;\n\n\t \n\tas10x_cmd_build(preq, (++adap->cmd_xid),\n\t\t\tsizeof(preq->body.set_tune.req));\n\n\t \n\tpreq->body.set_tune.req.proc_id = cpu_to_le16(CONTROL_PROC_SETTUNE);\n\tpreq->body.set_tune.req.args.freq = (__force __u32)cpu_to_le32(ptune->freq);\n\tpreq->body.set_tune.req.args.bandwidth = ptune->bandwidth;\n\tpreq->body.set_tune.req.args.hier_select = ptune->hier_select;\n\tpreq->body.set_tune.req.args.modulation = ptune->modulation;\n\tpreq->body.set_tune.req.args.hierarchy = ptune->hierarchy;\n\tpreq->body.set_tune.req.args.interleaving_mode  =\n\t\tptune->interleaving_mode;\n\tpreq->body.set_tune.req.args.code_rate  = ptune->code_rate;\n\tpreq->body.set_tune.req.args.guard_interval = ptune->guard_interval;\n\tpreq->body.set_tune.req.args.transmission_mode  =\n\t\tptune->transmission_mode;\n\n\t \n\tif (adap->ops->xfer_cmd) {\n\t\terror = adap->ops->xfer_cmd(adap,\n\t\t\t\t\t    (uint8_t *) preq,\n\t\t\t\t\t    sizeof(preq->body.set_tune.req)\n\t\t\t\t\t    + HEADER_SIZE,\n\t\t\t\t\t    (uint8_t *) prsp,\n\t\t\t\t\t    sizeof(prsp->body.set_tune.rsp)\n\t\t\t\t\t    + HEADER_SIZE);\n\t}\n\n\tif (error < 0)\n\t\tgoto out;\n\n\t \n\terror = as10x_rsp_parse(prsp, CONTROL_PROC_SETTUNE_RSP);\n\nout:\n\treturn error;\n}\n\n \nint as10x_cmd_get_tune_status(struct as10x_bus_adapter_t *adap,\n\t\t\t      struct as10x_tune_status *pstatus)\n{\n\tint error = AS10X_CMD_ERROR;\n\tstruct as10x_cmd_t  *preq, *prsp;\n\n\tpreq = adap->cmd;\n\tprsp = adap->rsp;\n\n\t \n\tas10x_cmd_build(preq, (++adap->cmd_xid),\n\t\t\tsizeof(preq->body.get_tune_status.req));\n\n\t \n\tpreq->body.get_tune_status.req.proc_id =\n\t\tcpu_to_le16(CONTROL_PROC_GETTUNESTAT);\n\n\t \n\tif (adap->ops->xfer_cmd) {\n\t\terror = adap->ops->xfer_cmd(\n\t\t\tadap,\n\t\t\t(uint8_t *) preq,\n\t\t\tsizeof(preq->body.get_tune_status.req) + HEADER_SIZE,\n\t\t\t(uint8_t *) prsp,\n\t\t\tsizeof(prsp->body.get_tune_status.rsp) + HEADER_SIZE);\n\t}\n\n\tif (error < 0)\n\t\tgoto out;\n\n\t \n\terror = as10x_rsp_parse(prsp, CONTROL_PROC_GETTUNESTAT_RSP);\n\tif (error < 0)\n\t\tgoto out;\n\n\t \n\tpstatus->tune_state = prsp->body.get_tune_status.rsp.sts.tune_state;\n\tpstatus->signal_strength  =\n\t\tle16_to_cpu((__force __le16)prsp->body.get_tune_status.rsp.sts.signal_strength);\n\tpstatus->PER = le16_to_cpu((__force __le16)prsp->body.get_tune_status.rsp.sts.PER);\n\tpstatus->BER = le16_to_cpu((__force __le16)prsp->body.get_tune_status.rsp.sts.BER);\n\nout:\n\treturn error;\n}\n\n \nint as10x_cmd_get_tps(struct as10x_bus_adapter_t *adap, struct as10x_tps *ptps)\n{\n\tint error = AS10X_CMD_ERROR;\n\tstruct as10x_cmd_t *pcmd, *prsp;\n\n\tpcmd = adap->cmd;\n\tprsp = adap->rsp;\n\n\t \n\tas10x_cmd_build(pcmd, (++adap->cmd_xid),\n\t\t\tsizeof(pcmd->body.get_tps.req));\n\n\t \n\tpcmd->body.get_tune_status.req.proc_id =\n\t\tcpu_to_le16(CONTROL_PROC_GETTPS);\n\n\t \n\tif (adap->ops->xfer_cmd) {\n\t\terror = adap->ops->xfer_cmd(adap,\n\t\t\t\t\t    (uint8_t *) pcmd,\n\t\t\t\t\t    sizeof(pcmd->body.get_tps.req) +\n\t\t\t\t\t    HEADER_SIZE,\n\t\t\t\t\t    (uint8_t *) prsp,\n\t\t\t\t\t    sizeof(prsp->body.get_tps.rsp) +\n\t\t\t\t\t    HEADER_SIZE);\n\t}\n\n\tif (error < 0)\n\t\tgoto out;\n\n\t \n\terror = as10x_rsp_parse(prsp, CONTROL_PROC_GETTPS_RSP);\n\tif (error < 0)\n\t\tgoto out;\n\n\t \n\tptps->modulation = prsp->body.get_tps.rsp.tps.modulation;\n\tptps->hierarchy = prsp->body.get_tps.rsp.tps.hierarchy;\n\tptps->interleaving_mode = prsp->body.get_tps.rsp.tps.interleaving_mode;\n\tptps->code_rate_HP = prsp->body.get_tps.rsp.tps.code_rate_HP;\n\tptps->code_rate_LP = prsp->body.get_tps.rsp.tps.code_rate_LP;\n\tptps->guard_interval = prsp->body.get_tps.rsp.tps.guard_interval;\n\tptps->transmission_mode  = prsp->body.get_tps.rsp.tps.transmission_mode;\n\tptps->DVBH_mask_HP = prsp->body.get_tps.rsp.tps.DVBH_mask_HP;\n\tptps->DVBH_mask_LP = prsp->body.get_tps.rsp.tps.DVBH_mask_LP;\n\tptps->cell_ID = le16_to_cpu((__force __le16)prsp->body.get_tps.rsp.tps.cell_ID);\n\nout:\n\treturn error;\n}\n\n \nint as10x_cmd_get_demod_stats(struct as10x_bus_adapter_t *adap,\n\t\t\t      struct as10x_demod_stats *pdemod_stats)\n{\n\tint error = AS10X_CMD_ERROR;\n\tstruct as10x_cmd_t *pcmd, *prsp;\n\n\tpcmd = adap->cmd;\n\tprsp = adap->rsp;\n\n\t \n\tas10x_cmd_build(pcmd, (++adap->cmd_xid),\n\t\t\tsizeof(pcmd->body.get_demod_stats.req));\n\n\t \n\tpcmd->body.get_demod_stats.req.proc_id =\n\t\tcpu_to_le16(CONTROL_PROC_GET_DEMOD_STATS);\n\n\t \n\tif (adap->ops->xfer_cmd) {\n\t\terror = adap->ops->xfer_cmd(adap,\n\t\t\t\t(uint8_t *) pcmd,\n\t\t\t\tsizeof(pcmd->body.get_demod_stats.req)\n\t\t\t\t+ HEADER_SIZE,\n\t\t\t\t(uint8_t *) prsp,\n\t\t\t\tsizeof(prsp->body.get_demod_stats.rsp)\n\t\t\t\t+ HEADER_SIZE);\n\t}\n\n\tif (error < 0)\n\t\tgoto out;\n\n\t \n\terror = as10x_rsp_parse(prsp, CONTROL_PROC_GET_DEMOD_STATS_RSP);\n\tif (error < 0)\n\t\tgoto out;\n\n\t \n\tpdemod_stats->frame_count =\n\t\tle32_to_cpu((__force __le32)prsp->body.get_demod_stats.rsp.stats.frame_count);\n\tpdemod_stats->bad_frame_count =\n\t\tle32_to_cpu((__force __le32)prsp->body.get_demod_stats.rsp.stats.bad_frame_count);\n\tpdemod_stats->bytes_fixed_by_rs =\n\t\tle32_to_cpu((__force __le32)prsp->body.get_demod_stats.rsp.stats.bytes_fixed_by_rs);\n\tpdemod_stats->mer =\n\t\tle16_to_cpu((__force __le16)prsp->body.get_demod_stats.rsp.stats.mer);\n\tpdemod_stats->has_started =\n\t\tprsp->body.get_demod_stats.rsp.stats.has_started;\n\nout:\n\treturn error;\n}\n\n \nint as10x_cmd_get_impulse_resp(struct as10x_bus_adapter_t *adap,\n\t\t\t       uint8_t *is_ready)\n{\n\tint error = AS10X_CMD_ERROR;\n\tstruct as10x_cmd_t *pcmd, *prsp;\n\n\tpcmd = adap->cmd;\n\tprsp = adap->rsp;\n\n\t \n\tas10x_cmd_build(pcmd, (++adap->cmd_xid),\n\t\t\tsizeof(pcmd->body.get_impulse_rsp.req));\n\n\t \n\tpcmd->body.get_impulse_rsp.req.proc_id =\n\t\tcpu_to_le16(CONTROL_PROC_GET_IMPULSE_RESP);\n\n\t \n\tif (adap->ops->xfer_cmd) {\n\t\terror = adap->ops->xfer_cmd(adap,\n\t\t\t\t\t(uint8_t *) pcmd,\n\t\t\t\t\tsizeof(pcmd->body.get_impulse_rsp.req)\n\t\t\t\t\t+ HEADER_SIZE,\n\t\t\t\t\t(uint8_t *) prsp,\n\t\t\t\t\tsizeof(prsp->body.get_impulse_rsp.rsp)\n\t\t\t\t\t+ HEADER_SIZE);\n\t}\n\n\tif (error < 0)\n\t\tgoto out;\n\n\t \n\terror = as10x_rsp_parse(prsp, CONTROL_PROC_GET_IMPULSE_RESP_RSP);\n\tif (error < 0)\n\t\tgoto out;\n\n\t \n\t*is_ready = prsp->body.get_impulse_rsp.rsp.is_ready;\n\nout:\n\treturn error;\n}\n\n \nvoid as10x_cmd_build(struct as10x_cmd_t *pcmd,\n\t\t     uint16_t xid, uint16_t cmd_len)\n{\n\tpcmd->header.req_id = cpu_to_le16(xid);\n\tpcmd->header.prog = cpu_to_le16(SERVICE_PROG_ID);\n\tpcmd->header.version = cpu_to_le16(SERVICE_PROG_VERSION);\n\tpcmd->header.data_len = cpu_to_le16(cmd_len);\n}\n\n \nint as10x_rsp_parse(struct as10x_cmd_t *prsp, uint16_t proc_id)\n{\n\tint error;\n\n\t \n\terror = prsp->body.common.rsp.error;\n\n\tif ((error == 0) &&\n\t    (le16_to_cpu(prsp->body.common.rsp.proc_id) == proc_id)) {\n\t\treturn 0;\n\t}\n\n\treturn AS10X_CMD_ERROR;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}