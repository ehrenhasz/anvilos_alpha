{
  "module_name": "as102_usb_drv.c",
  "hash_id": "ee11e2f06a6cba615b211e141628343cbb62c207b766e1a2f1364371952b9481",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/as102/as102_usb_drv.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/usb.h>\n\n#include \"as102_drv.h\"\n#include \"as102_usb_drv.h\"\n#include \"as102_fw.h\"\n\nstatic void as102_usb_disconnect(struct usb_interface *interface);\nstatic int as102_usb_probe(struct usb_interface *interface,\n\t\t\t   const struct usb_device_id *id);\n\nstatic int as102_usb_start_stream(struct as102_dev_t *dev);\nstatic void as102_usb_stop_stream(struct as102_dev_t *dev);\n\nstatic int as102_open(struct inode *inode, struct file *file);\nstatic int as102_release(struct inode *inode, struct file *file);\n\nstatic const struct usb_device_id as102_usb_id_table[] = {\n\t{ USB_DEVICE(AS102_USB_DEVICE_VENDOR_ID, AS102_USB_DEVICE_PID_0001) },\n\t{ USB_DEVICE(PCTV_74E_USB_VID, PCTV_74E_USB_PID) },\n\t{ USB_DEVICE(ELGATO_EYETV_DTT_USB_VID, ELGATO_EYETV_DTT_USB_PID) },\n\t{ USB_DEVICE(NBOX_DVBT_DONGLE_USB_VID, NBOX_DVBT_DONGLE_USB_PID) },\n\t{ USB_DEVICE(SKY_IT_DIGITAL_KEY_USB_VID, SKY_IT_DIGITAL_KEY_USB_PID) },\n\t{ }  \n};\n\n \nstatic const char * const as102_device_names[] = {\n\tAS102_REFERENCE_DESIGN,\n\tAS102_PCTV_74E,\n\tAS102_ELGATO_EYETV_DTT_NAME,\n\tAS102_NBOX_DVBT_DONGLE_NAME,\n\tAS102_SKY_IT_DIGITAL_KEY_NAME,\n\tNULL  \n};\n\n \nstatic uint8_t const as102_elna_cfg[] = {\n\t0xA0,\n\t0xC0,\n\t0xC0,\n\t0xA0,\n\t0xA0,\n\t0x00  \n};\n\nstruct usb_driver as102_usb_driver = {\n\t.name\t\t= DRIVER_FULL_NAME,\n\t.probe\t\t= as102_usb_probe,\n\t.disconnect\t= as102_usb_disconnect,\n\t.id_table\t= as102_usb_id_table\n};\n\nstatic const struct file_operations as102_dev_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= as102_open,\n\t.release\t= as102_release,\n};\n\nstatic struct usb_class_driver as102_usb_class_driver = {\n\t.name\t\t= \"aton2-%d\",\n\t.fops\t\t= &as102_dev_fops,\n\t.minor_base\t= AS102_DEVICE_MAJOR,\n};\n\nstatic int as102_usb_xfer_cmd(struct as10x_bus_adapter_t *bus_adap,\n\t\t\t      unsigned char *send_buf, int send_buf_len,\n\t\t\t      unsigned char *recv_buf, int recv_buf_len)\n{\n\tint ret = 0;\n\n\tif (send_buf != NULL) {\n\t\tret = usb_control_msg(bus_adap->usb_dev,\n\t\t\t\t      usb_sndctrlpipe(bus_adap->usb_dev, 0),\n\t\t\t\t      AS102_USB_DEVICE_TX_CTRL_CMD,\n\t\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t      USB_RECIP_DEVICE,\n\t\t\t\t      bus_adap->cmd_xid,  \n\t\t\t\t      0,  \n\t\t\t\t      send_buf, send_buf_len,\n\t\t\t\t      USB_CTRL_SET_TIMEOUT  );\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(&bus_adap->usb_dev->dev,\n\t\t\t\t\"usb_control_msg(send) failed, err %i\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (ret != send_buf_len) {\n\t\t\tdev_dbg(&bus_adap->usb_dev->dev,\n\t\t\t\"only wrote %d of %d bytes\\n\", ret, send_buf_len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (recv_buf != NULL) {\n#ifdef TRACE\n\t\tdev_dbg(bus_adap->usb_dev->dev,\n\t\t\t\"want to read: %d bytes\\n\", recv_buf_len);\n#endif\n\t\tret = usb_control_msg(bus_adap->usb_dev,\n\t\t\t\t      usb_rcvctrlpipe(bus_adap->usb_dev, 0),\n\t\t\t\t      AS102_USB_DEVICE_RX_CTRL_CMD,\n\t\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t\t      USB_RECIP_DEVICE,\n\t\t\t\t      bus_adap->cmd_xid,  \n\t\t\t\t      0,  \n\t\t\t\t      recv_buf, recv_buf_len,\n\t\t\t\t      USB_CTRL_GET_TIMEOUT  );\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(&bus_adap->usb_dev->dev,\n\t\t\t\t\"usb_control_msg(recv) failed, err %i\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n#ifdef TRACE\n\t\tdev_dbg(bus_adap->usb_dev->dev,\n\t\t\t\"read %d bytes\\n\", recv_buf_len);\n#endif\n\t}\n\n\treturn ret;\n}\n\nstatic int as102_send_ep1(struct as10x_bus_adapter_t *bus_adap,\n\t\t\t  unsigned char *send_buf,\n\t\t\t  int send_buf_len,\n\t\t\t  int swap32)\n{\n\tint ret, actual_len;\n\n\tret = usb_bulk_msg(bus_adap->usb_dev,\n\t\t\t   usb_sndbulkpipe(bus_adap->usb_dev, 1),\n\t\t\t   send_buf, send_buf_len, &actual_len, 200);\n\tif (ret) {\n\t\tdev_dbg(&bus_adap->usb_dev->dev,\n\t\t\t\"usb_bulk_msg(send) failed, err %i\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (actual_len != send_buf_len) {\n\t\tdev_dbg(&bus_adap->usb_dev->dev, \"only wrote %d of %d bytes\\n\",\n\t\t\tactual_len, send_buf_len);\n\t\treturn -1;\n\t}\n\treturn actual_len;\n}\n\nstatic int as102_read_ep2(struct as10x_bus_adapter_t *bus_adap,\n\t\t   unsigned char *recv_buf, int recv_buf_len)\n{\n\tint ret, actual_len;\n\n\tif (recv_buf == NULL)\n\t\treturn -EINVAL;\n\n\tret = usb_bulk_msg(bus_adap->usb_dev,\n\t\t\t   usb_rcvbulkpipe(bus_adap->usb_dev, 2),\n\t\t\t   recv_buf, recv_buf_len, &actual_len, 200);\n\tif (ret) {\n\t\tdev_dbg(&bus_adap->usb_dev->dev,\n\t\t\t\"usb_bulk_msg(recv) failed, err %i\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (actual_len != recv_buf_len) {\n\t\tdev_dbg(&bus_adap->usb_dev->dev, \"only read %d of %d bytes\\n\",\n\t\t\tactual_len, recv_buf_len);\n\t\treturn -1;\n\t}\n\treturn actual_len;\n}\n\nstatic const struct as102_priv_ops_t as102_priv_ops = {\n\t.upload_fw_pkt\t= as102_send_ep1,\n\t.xfer_cmd\t= as102_usb_xfer_cmd,\n\t.as102_read_ep2\t= as102_read_ep2,\n\t.start_stream\t= as102_usb_start_stream,\n\t.stop_stream\t= as102_usb_stop_stream,\n};\n\nstatic int as102_submit_urb_stream(struct as102_dev_t *dev, struct urb *urb)\n{\n\tint err;\n\n\tusb_fill_bulk_urb(urb,\n\t\t\t  dev->bus_adap.usb_dev,\n\t\t\t  usb_rcvbulkpipe(dev->bus_adap.usb_dev, 0x2),\n\t\t\t  urb->transfer_buffer,\n\t\t\t  AS102_USB_BUF_SIZE,\n\t\t\t  as102_urb_stream_irq,\n\t\t\t  dev);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err)\n\t\tdev_dbg(&urb->dev->dev,\n\t\t\t\"%s: usb_submit_urb failed\\n\", __func__);\n\n\treturn err;\n}\n\nvoid as102_urb_stream_irq(struct urb *urb)\n{\n\tstruct as102_dev_t *as102_dev = urb->context;\n\n\tif (urb->actual_length > 0) {\n\t\tdvb_dmx_swfilter(&as102_dev->dvb_dmx,\n\t\t\t\t urb->transfer_buffer,\n\t\t\t\t urb->actual_length);\n\t} else {\n\t\tif (urb->actual_length == 0)\n\t\t\tmemset(urb->transfer_buffer, 0, AS102_USB_BUF_SIZE);\n\t}\n\n\t \n\tif (as102_dev->streaming)\n\t\tas102_submit_urb_stream(as102_dev, urb);\n}\n\nstatic void as102_free_usb_stream_buffer(struct as102_dev_t *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_STREAM_URB; i++)\n\t\tusb_free_urb(dev->stream_urb[i]);\n\n\tusb_free_coherent(dev->bus_adap.usb_dev,\n\t\t\tMAX_STREAM_URB * AS102_USB_BUF_SIZE,\n\t\t\tdev->stream,\n\t\t\tdev->dma_addr);\n}\n\nstatic int as102_alloc_usb_stream_buffer(struct as102_dev_t *dev)\n{\n\tint i;\n\n\tdev->stream = usb_alloc_coherent(dev->bus_adap.usb_dev,\n\t\t\t\t       MAX_STREAM_URB * AS102_USB_BUF_SIZE,\n\t\t\t\t       GFP_KERNEL,\n\t\t\t\t       &dev->dma_addr);\n\tif (!dev->stream) {\n\t\tdev_dbg(&dev->bus_adap.usb_dev->dev,\n\t\t\t\"%s: usb_buffer_alloc failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(dev->stream, 0, MAX_STREAM_URB * AS102_USB_BUF_SIZE);\n\n\t \n\tfor (i = 0; i < MAX_STREAM_URB; i++) {\n\t\tstruct urb *urb;\n\n\t\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (urb == NULL) {\n\t\t\tas102_free_usb_stream_buffer(dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\turb->transfer_buffer = dev->stream + (i * AS102_USB_BUF_SIZE);\n\t\turb->transfer_dma = dev->dma_addr + (i * AS102_USB_BUF_SIZE);\n\t\turb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\t\turb->transfer_buffer_length = AS102_USB_BUF_SIZE;\n\n\t\tdev->stream_urb[i] = urb;\n\t}\n\treturn 0;\n}\n\nstatic void as102_usb_stop_stream(struct as102_dev_t *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_STREAM_URB; i++)\n\t\tusb_kill_urb(dev->stream_urb[i]);\n}\n\nstatic int as102_usb_start_stream(struct as102_dev_t *dev)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < MAX_STREAM_URB; i++) {\n\t\tret = as102_submit_urb_stream(dev, dev->stream_urb[i]);\n\t\tif (ret) {\n\t\t\tas102_usb_stop_stream(dev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void as102_usb_release(struct kref *kref)\n{\n\tstruct as102_dev_t *as102_dev;\n\n\tas102_dev = container_of(kref, struct as102_dev_t, kref);\n\tusb_put_dev(as102_dev->bus_adap.usb_dev);\n\tkfree(as102_dev);\n}\n\nstatic void as102_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct as102_dev_t *as102_dev;\n\n\t \n\tas102_dev = usb_get_intfdata(intf);\n\n\t \n\tas102_dvb_unregister(as102_dev);\n\n\t \n\tas102_free_usb_stream_buffer(as102_dev);\n\n\tusb_set_intfdata(intf, NULL);\n\n\t \n\tusb_deregister_dev(intf, &as102_usb_class_driver);\n\n\t \n\tkref_put(&as102_dev->kref, as102_usb_release);\n\n\tpr_info(\"%s: device has been disconnected\\n\", DRIVER_NAME);\n}\n\nstatic int as102_usb_probe(struct usb_interface *intf,\n\t\t\t   const struct usb_device_id *id)\n{\n\tint ret;\n\tstruct as102_dev_t *as102_dev;\n\tint i;\n\n\t \n\tif (ARRAY_SIZE(as102_usb_id_table) !=\n\t    (sizeof(as102_device_names) / sizeof(const char *))) {\n\t\tpr_err(\"Device names table invalid size\");\n\t\treturn -EINVAL;\n\t}\n\n\tas102_dev = kzalloc(sizeof(struct as102_dev_t), GFP_KERNEL);\n\tif (as102_dev == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(as102_usb_id_table); i++) {\n\t\tif (id == &as102_usb_id_table[i]) {\n\t\t\tas102_dev->name = as102_device_names[i];\n\t\t\tas102_dev->elna_cfg = as102_elna_cfg[i];\n\t\t}\n\t}\n\n\tif (as102_dev->name == NULL)\n\t\tas102_dev->name = \"Unknown AS102 device\";\n\n\t \n\tas102_dev->bus_adap.ops = &as102_priv_ops;\n\n\t \n\tas102_dev->bus_adap.cmd = &as102_dev->bus_adap.token.usb.c;\n\tas102_dev->bus_adap.rsp = &as102_dev->bus_adap.token.usb.r;\n\n\t \n\tkref_init(&as102_dev->kref);\n\n\t \n\tusb_set_intfdata(intf, (void *) as102_dev);\n\n\t \n\tas102_dev->bus_adap.usb_dev = usb_get_dev(interface_to_usbdev(intf));\n\n\t \n\tret = usb_register_dev(intf, &as102_usb_class_driver);\n\tif (ret < 0) {\n\t\t \n\t\tdev_err(&intf->dev,\n\t\t\t\"%s: usb_register_dev() failed (errno = %d)\\n\",\n\t\t\t__func__, ret);\n\t\tgoto failed;\n\t}\n\n\tpr_info(\"%s: device has been detected\\n\", DRIVER_NAME);\n\n\t \n\tret = as102_alloc_usb_stream_buffer(as102_dev);\n\tif (ret != 0)\n\t\tgoto failed_stream;\n\n\t \n\tret = as102_dvb_register(as102_dev);\n\tif (ret != 0)\n\t\tgoto failed_dvb;\n\n\treturn ret;\n\nfailed_dvb:\n\tas102_free_usb_stream_buffer(as102_dev);\nfailed_stream:\n\tusb_deregister_dev(intf, &as102_usb_class_driver);\nfailed:\n\tusb_put_dev(as102_dev->bus_adap.usb_dev);\n\tusb_set_intfdata(intf, NULL);\n\tkfree(as102_dev);\n\treturn ret;\n}\n\nstatic int as102_open(struct inode *inode, struct file *file)\n{\n\tint ret = 0, minor = 0;\n\tstruct usb_interface *intf = NULL;\n\tstruct as102_dev_t *dev = NULL;\n\n\t \n\tminor = iminor(inode);\n\n\t \n\tintf = usb_find_interface(&as102_usb_driver, minor);\n\tif (intf == NULL) {\n\t\tpr_err(\"%s: can't find device for minor %d\\n\",\n\t\t       __func__, minor);\n\t\tret = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t \n\tdev = usb_get_intfdata(intf);\n\tif (dev == NULL) {\n\t\tret = -EFAULT;\n\t\tgoto exit;\n\t}\n\n\t \n\tfile->private_data = dev;\n\n\t \n\tkref_get(&dev->kref);\n\nexit:\n\treturn ret;\n}\n\nstatic int as102_release(struct inode *inode, struct file *file)\n{\n\tstruct as102_dev_t *dev = NULL;\n\n\tdev = file->private_data;\n\tif (dev != NULL) {\n\t\t \n\t\tkref_put(&dev->kref, as102_usb_release);\n\t}\n\n\treturn 0;\n}\n\nMODULE_DEVICE_TABLE(usb, as102_usb_id_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}