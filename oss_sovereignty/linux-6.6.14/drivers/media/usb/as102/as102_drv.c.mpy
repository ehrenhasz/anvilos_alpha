{
  "module_name": "as102_drv.c",
  "hash_id": "ebaf8557f8f6fb4ea874c37739e72998fd1c5fb86f556c329658ca8c89288507",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/as102/as102_drv.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kref.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n\n \n#include \"as102_drv.h\"\n#include \"as10x_cmd.h\"\n#include \"as102_fe.h\"\n#include \"as102_fw.h\"\n#include <media/dvbdev.h>\n\nint dual_tuner;\nmodule_param_named(dual_tuner, dual_tuner, int, 0644);\nMODULE_PARM_DESC(dual_tuner, \"Activate Dual-Tuner config (default: off)\");\n\nstatic int fw_upload = 1;\nmodule_param_named(fw_upload, fw_upload, int, 0644);\nMODULE_PARM_DESC(fw_upload, \"Turn on/off default FW upload (default: on)\");\n\nstatic int pid_filtering;\nmodule_param_named(pid_filtering, pid_filtering, int, 0644);\nMODULE_PARM_DESC(pid_filtering, \"Activate HW PID filtering (default: off)\");\n\nstatic int ts_auto_disable;\nmodule_param_named(ts_auto_disable, ts_auto_disable, int, 0644);\nMODULE_PARM_DESC(ts_auto_disable, \"Stream Auto Enable on FW (default: off)\");\n\nint elna_enable = 1;\nmodule_param_named(elna_enable, elna_enable, int, 0644);\nMODULE_PARM_DESC(elna_enable, \"Activate eLNA (default: on)\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic void as102_stop_stream(struct as102_dev_t *dev)\n{\n\tstruct as10x_bus_adapter_t *bus_adap;\n\n\tif (dev != NULL)\n\t\tbus_adap = &dev->bus_adap;\n\telse\n\t\treturn;\n\n\tif (bus_adap->ops->stop_stream != NULL)\n\t\tbus_adap->ops->stop_stream(dev);\n\n\tif (ts_auto_disable) {\n\t\tif (mutex_lock_interruptible(&dev->bus_adap.lock))\n\t\t\treturn;\n\n\t\tif (as10x_cmd_stop_streaming(bus_adap) < 0)\n\t\t\tdev_dbg(&dev->bus_adap.usb_dev->dev,\n\t\t\t\t\"as10x_cmd_stop_streaming failed\\n\");\n\n\t\tmutex_unlock(&dev->bus_adap.lock);\n\t}\n}\n\nstatic int as102_start_stream(struct as102_dev_t *dev)\n{\n\tstruct as10x_bus_adapter_t *bus_adap;\n\tint ret = -EFAULT;\n\n\tif (dev != NULL)\n\t\tbus_adap = &dev->bus_adap;\n\telse\n\t\treturn ret;\n\n\tif (bus_adap->ops->start_stream != NULL)\n\t\tret = bus_adap->ops->start_stream(dev);\n\n\tif (ts_auto_disable) {\n\t\tif (mutex_lock_interruptible(&dev->bus_adap.lock))\n\t\t\treturn -EFAULT;\n\n\t\tret = as10x_cmd_start_streaming(bus_adap);\n\n\t\tmutex_unlock(&dev->bus_adap.lock);\n\t}\n\n\treturn ret;\n}\n\nstatic int as10x_pid_filter(struct as102_dev_t *dev,\n\t\t\t    int index, u16 pid, int onoff) {\n\n\tstruct as10x_bus_adapter_t *bus_adap = &dev->bus_adap;\n\tint ret = -EFAULT;\n\n\tif (mutex_lock_interruptible(&dev->bus_adap.lock)) {\n\t\tdev_dbg(&dev->bus_adap.usb_dev->dev,\n\t\t\t\"amutex_lock_interruptible(lock) failed !\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tswitch (onoff) {\n\tcase 0:\n\t\tret = as10x_cmd_del_PID_filter(bus_adap, (uint16_t) pid);\n\t\tdev_dbg(&dev->bus_adap.usb_dev->dev,\n\t\t\t\"DEL_PID_FILTER([%02d] 0x%04x) ret = %d\\n\",\n\t\t\tindex, pid, ret);\n\t\tbreak;\n\tcase 1:\n\t{\n\t\tstruct as10x_ts_filter filter;\n\n\t\tfilter.type = TS_PID_TYPE_TS;\n\t\tfilter.idx = 0xFF;\n\t\tfilter.pid = pid;\n\n\t\tret = as10x_cmd_add_PID_filter(bus_adap, &filter);\n\t\tdev_dbg(&dev->bus_adap.usb_dev->dev,\n\t\t\t\"ADD_PID_FILTER([%02d -> %02d], 0x%04x) ret = %d\\n\",\n\t\t\tindex, filter.idx, filter.pid, ret);\n\t\tbreak;\n\t}\n\t}\n\n\tmutex_unlock(&dev->bus_adap.lock);\n\treturn ret;\n}\n\nstatic int as102_dvb_dmx_start_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tint ret = 0;\n\tstruct dvb_demux *demux = dvbdmxfeed->demux;\n\tstruct as102_dev_t *as102_dev = demux->priv;\n\n\tif (mutex_lock_interruptible(&as102_dev->sem))\n\t\treturn -ERESTARTSYS;\n\n\tif (pid_filtering)\n\t\tas10x_pid_filter(as102_dev, dvbdmxfeed->index,\n\t\t\t\t dvbdmxfeed->pid, 1);\n\n\tif (as102_dev->streaming++ == 0)\n\t\tret = as102_start_stream(as102_dev);\n\n\tmutex_unlock(&as102_dev->sem);\n\treturn ret;\n}\n\nstatic int as102_dvb_dmx_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct dvb_demux *demux = dvbdmxfeed->demux;\n\tstruct as102_dev_t *as102_dev = demux->priv;\n\n\tif (mutex_lock_interruptible(&as102_dev->sem))\n\t\treturn -ERESTARTSYS;\n\n\tif (--as102_dev->streaming == 0)\n\t\tas102_stop_stream(as102_dev);\n\n\tif (pid_filtering)\n\t\tas10x_pid_filter(as102_dev, dvbdmxfeed->index,\n\t\t\t\t dvbdmxfeed->pid, 0);\n\n\tmutex_unlock(&as102_dev->sem);\n\treturn 0;\n}\n\nstatic int as102_set_tune(void *priv, struct as10x_tune_args *tune_args)\n{\n\tstruct as10x_bus_adapter_t *bus_adap = priv;\n\tint ret;\n\n\t \n\tif (mutex_lock_interruptible(&bus_adap->lock))\n\t\treturn -EBUSY;\n\n\tret =  as10x_cmd_set_tune(bus_adap, tune_args);\n\tif (ret != 0)\n\t\tdev_dbg(&bus_adap->usb_dev->dev,\n\t\t\t\"as10x_cmd_set_tune failed. (err = %d)\\n\", ret);\n\n\tmutex_unlock(&bus_adap->lock);\n\n\treturn ret;\n}\n\nstatic int as102_get_tps(void *priv, struct as10x_tps *tps)\n{\n\tstruct as10x_bus_adapter_t *bus_adap = priv;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&bus_adap->lock))\n\t\treturn -EBUSY;\n\n\t \n\tret = as10x_cmd_get_tps(bus_adap, tps);\n\n\tmutex_unlock(&bus_adap->lock);\n\n\treturn ret;\n}\n\nstatic int as102_get_status(void *priv, struct as10x_tune_status *tstate)\n{\n\tstruct as10x_bus_adapter_t *bus_adap = priv;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&bus_adap->lock))\n\t\treturn -EBUSY;\n\n\t \n\tret = as10x_cmd_get_tune_status(bus_adap, tstate);\n\tif (ret < 0) {\n\t\tdev_dbg(&bus_adap->usb_dev->dev,\n\t\t\t\"as10x_cmd_get_tune_status failed (err = %d)\\n\",\n\t\t\tret);\n\t}\n\n\tmutex_unlock(&bus_adap->lock);\n\n\treturn ret;\n}\n\nstatic int as102_get_stats(void *priv, struct as10x_demod_stats *demod_stats)\n{\n\tstruct as10x_bus_adapter_t *bus_adap = priv;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&bus_adap->lock))\n\t\treturn -EBUSY;\n\n\t \n\tret = as10x_cmd_get_demod_stats(bus_adap, demod_stats);\n\tif (ret < 0) {\n\t\tdev_dbg(&bus_adap->usb_dev->dev,\n\t\t\t\"as10x_cmd_get_demod_stats failed (probably not tuned)\\n\");\n\t} else {\n\t\tdev_dbg(&bus_adap->usb_dev->dev,\n\t\t\t\"demod status: fc: 0x%08x, bad fc: 0x%08x, bytes corrected: 0x%08x , MER: 0x%04x\\n\",\n\t\t\tdemod_stats->frame_count,\n\t\t\tdemod_stats->bad_frame_count,\n\t\t\tdemod_stats->bytes_fixed_by_rs,\n\t\t\tdemod_stats->mer);\n\t}\n\tmutex_unlock(&bus_adap->lock);\n\n\treturn ret;\n}\n\nstatic int as102_stream_ctrl(void *priv, int acquire, uint32_t elna_cfg)\n{\n\tstruct as10x_bus_adapter_t *bus_adap = priv;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&bus_adap->lock))\n\t\treturn -EBUSY;\n\n\tif (acquire) {\n\t\tif (elna_enable)\n\t\t\tas10x_cmd_set_context(bus_adap,\n\t\t\t\t\t      CONTEXT_LNA, elna_cfg);\n\n\t\tret = as10x_cmd_turn_on(bus_adap);\n\t} else {\n\t\tret = as10x_cmd_turn_off(bus_adap);\n\t}\n\n\tmutex_unlock(&bus_adap->lock);\n\n\treturn ret;\n}\n\nstatic const struct as102_fe_ops as102_fe_ops = {\n\t.set_tune = as102_set_tune,\n\t.get_tps  = as102_get_tps,\n\t.get_status = as102_get_status,\n\t.get_stats = as102_get_stats,\n\t.stream_ctrl = as102_stream_ctrl,\n};\n\nint as102_dvb_register(struct as102_dev_t *as102_dev)\n{\n\tstruct device *dev = &as102_dev->bus_adap.usb_dev->dev;\n\tint ret;\n\n\tret = dvb_register_adapter(&as102_dev->dvb_adap,\n\t\t\t   as102_dev->name, THIS_MODULE,\n\t\t\t   dev, adapter_nr);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: dvb_register_adapter() failed: %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tas102_dev->dvb_dmx.priv = as102_dev;\n\tas102_dev->dvb_dmx.filternum = pid_filtering ? 16 : 256;\n\tas102_dev->dvb_dmx.feednum = 256;\n\tas102_dev->dvb_dmx.start_feed = as102_dvb_dmx_start_feed;\n\tas102_dev->dvb_dmx.stop_feed = as102_dvb_dmx_stop_feed;\n\n\tas102_dev->dvb_dmx.dmx.capabilities = DMX_TS_FILTERING |\n\t\t\t\t\t      DMX_SECTION_FILTERING;\n\n\tas102_dev->dvb_dmxdev.filternum = as102_dev->dvb_dmx.filternum;\n\tas102_dev->dvb_dmxdev.demux = &as102_dev->dvb_dmx.dmx;\n\tas102_dev->dvb_dmxdev.capabilities = 0;\n\n\tret = dvb_dmx_init(&as102_dev->dvb_dmx);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: dvb_dmx_init() failed: %d\\n\", __func__, ret);\n\t\tgoto edmxinit;\n\t}\n\n\tret = dvb_dmxdev_init(&as102_dev->dvb_dmxdev, &as102_dev->dvb_adap);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: dvb_dmxdev_init() failed: %d\\n\",\n\t\t\t__func__, ret);\n\t\tgoto edmxdinit;\n\t}\n\n\t \n\tas102_dev->dvb_fe = dvb_attach(as102_attach, as102_dev->name,\n\t\t\t\t       &as102_fe_ops,\n\t\t\t\t       &as102_dev->bus_adap,\n\t\t\t\t       as102_dev->elna_cfg);\n\tif (!as102_dev->dvb_fe) {\n\t\tret = -ENODEV;\n\t\tdev_err(dev, \"%s: as102_attach() failed: %d\",\n\t\t    __func__, ret);\n\t\tgoto efereg;\n\t}\n\n\tret =  dvb_register_frontend(&as102_dev->dvb_adap, as102_dev->dvb_fe);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: as102_dvb_register_frontend() failed: %d\",\n\t\t    __func__, ret);\n\t\tgoto efereg;\n\t}\n\n\t \n\tmutex_init(&as102_dev->bus_adap.lock);\n\n\t \n\tmutex_init(&as102_dev->sem);\n\n\t \n\tif (fw_upload)\n\t\ttry_then_request_module(as102_fw_upload(&as102_dev->bus_adap),\n\t\t\t\t\"firmware_class\");\n\n\tpr_info(\"Registered device %s\", as102_dev->name);\n\treturn 0;\n\nefereg:\n\tdvb_dmxdev_release(&as102_dev->dvb_dmxdev);\nedmxdinit:\n\tdvb_dmx_release(&as102_dev->dvb_dmx);\nedmxinit:\n\tdvb_unregister_adapter(&as102_dev->dvb_adap);\n\treturn ret;\n}\n\nvoid as102_dvb_unregister(struct as102_dev_t *as102_dev)\n{\n\t \n\tdvb_unregister_frontend(as102_dev->dvb_fe);\n\n\t \n\tdvb_frontend_detach(as102_dev->dvb_fe);\n\n\t \n\tdvb_dmxdev_release(&as102_dev->dvb_dmxdev);\n\tdvb_dmx_release(&as102_dev->dvb_dmx);\n\n\t \n\tdvb_unregister_adapter(&as102_dev->dvb_adap);\n\n\tpr_info(\"Unregistered device %s\", as102_dev->name);\n}\n\nmodule_usb_driver(as102_usb_driver);\n\n \nMODULE_DESCRIPTION(DRIVER_FULL_NAME);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Pierrick Hascoet <pierrick.hascoet@abilis.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}