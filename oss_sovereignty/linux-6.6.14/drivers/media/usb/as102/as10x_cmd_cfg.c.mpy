{
  "module_name": "as10x_cmd_cfg.c",
  "hash_id": "a142d30cbe1bad48ee2227d787304c8bb92c4ca66eb9565d51129e9349c55bc7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/as102/as10x_cmd_cfg.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include \"as102_drv.h\"\n#include \"as10x_cmd.h\"\n\n \n \n \n\n \nint as10x_cmd_get_context(struct as10x_bus_adapter_t *adap, uint16_t tag,\n\t\t\t  uint32_t *pvalue)\n{\n\tint  error;\n\tstruct as10x_cmd_t *pcmd, *prsp;\n\n\tpcmd = adap->cmd;\n\tprsp = adap->rsp;\n\n\t \n\tas10x_cmd_build(pcmd, (++adap->cmd_xid),\n\t\t\tsizeof(pcmd->body.context.req));\n\n\t \n\tpcmd->body.context.req.proc_id = cpu_to_le16(CONTROL_PROC_CONTEXT);\n\tpcmd->body.context.req.tag = cpu_to_le16(tag);\n\tpcmd->body.context.req.type = cpu_to_le16(GET_CONTEXT_DATA);\n\n\t \n\tif (adap->ops->xfer_cmd) {\n\t\terror  = adap->ops->xfer_cmd(adap,\n\t\t\t\t\t     (uint8_t *) pcmd,\n\t\t\t\t\t     sizeof(pcmd->body.context.req)\n\t\t\t\t\t     + HEADER_SIZE,\n\t\t\t\t\t     (uint8_t *) prsp,\n\t\t\t\t\t     sizeof(prsp->body.context.rsp)\n\t\t\t\t\t     + HEADER_SIZE);\n\t} else {\n\t\terror = AS10X_CMD_ERROR;\n\t}\n\n\tif (error < 0)\n\t\tgoto out;\n\n\t \n\t \n\terror = as10x_context_rsp_parse(prsp, CONTROL_PROC_CONTEXT_RSP);\n\n\tif (error == 0) {\n\t\t \n\t\t*pvalue = le32_to_cpu((__force __le32)prsp->body.context.rsp.reg_val.u.value32);\n\t\t \n\t}\n\nout:\n\treturn error;\n}\n\n \nint as10x_cmd_set_context(struct as10x_bus_adapter_t *adap, uint16_t tag,\n\t\t\t  uint32_t value)\n{\n\tint error;\n\tstruct as10x_cmd_t *pcmd, *prsp;\n\n\tpcmd = adap->cmd;\n\tprsp = adap->rsp;\n\n\t \n\tas10x_cmd_build(pcmd, (++adap->cmd_xid),\n\t\t\tsizeof(pcmd->body.context.req));\n\n\t \n\tpcmd->body.context.req.proc_id = cpu_to_le16(CONTROL_PROC_CONTEXT);\n\t \n\tpcmd->body.context.req.reg_val.u.value32 = (__force u32)cpu_to_le32(value);\n\tpcmd->body.context.req.tag = cpu_to_le16(tag);\n\tpcmd->body.context.req.type = cpu_to_le16(SET_CONTEXT_DATA);\n\n\t \n\tif (adap->ops->xfer_cmd) {\n\t\terror  = adap->ops->xfer_cmd(adap,\n\t\t\t\t\t     (uint8_t *) pcmd,\n\t\t\t\t\t     sizeof(pcmd->body.context.req)\n\t\t\t\t\t     + HEADER_SIZE,\n\t\t\t\t\t     (uint8_t *) prsp,\n\t\t\t\t\t     sizeof(prsp->body.context.rsp)\n\t\t\t\t\t     + HEADER_SIZE);\n\t} else {\n\t\terror = AS10X_CMD_ERROR;\n\t}\n\n\tif (error < 0)\n\t\tgoto out;\n\n\t \n\t \n\terror = as10x_context_rsp_parse(prsp, CONTROL_PROC_CONTEXT_RSP);\n\nout:\n\treturn error;\n}\n\n \nint as10x_cmd_eLNA_change_mode(struct as10x_bus_adapter_t *adap, uint8_t mode)\n{\n\tint error;\n\tstruct as10x_cmd_t *pcmd, *prsp;\n\n\tpcmd = adap->cmd;\n\tprsp = adap->rsp;\n\n\t \n\tas10x_cmd_build(pcmd, (++adap->cmd_xid),\n\t\t\tsizeof(pcmd->body.cfg_change_mode.req));\n\n\t \n\tpcmd->body.cfg_change_mode.req.proc_id =\n\t\tcpu_to_le16(CONTROL_PROC_ELNA_CHANGE_MODE);\n\tpcmd->body.cfg_change_mode.req.mode = mode;\n\n\t \n\tif (adap->ops->xfer_cmd) {\n\t\terror  = adap->ops->xfer_cmd(adap, (uint8_t *) pcmd,\n\t\t\t\tsizeof(pcmd->body.cfg_change_mode.req)\n\t\t\t\t+ HEADER_SIZE, (uint8_t *) prsp,\n\t\t\t\tsizeof(prsp->body.cfg_change_mode.rsp)\n\t\t\t\t+ HEADER_SIZE);\n\t} else {\n\t\terror = AS10X_CMD_ERROR;\n\t}\n\n\tif (error < 0)\n\t\tgoto out;\n\n\t \n\terror = as10x_rsp_parse(prsp, CONTROL_PROC_ELNA_CHANGE_MODE_RSP);\n\nout:\n\treturn error;\n}\n\n \nint as10x_context_rsp_parse(struct as10x_cmd_t *prsp, uint16_t proc_id)\n{\n\tint err;\n\n\terr = prsp->body.context.rsp.error;\n\n\tif ((err == 0) &&\n\t    (le16_to_cpu(prsp->body.context.rsp.proc_id) == proc_id)) {\n\t\treturn 0;\n\t}\n\treturn AS10X_CMD_ERROR;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}