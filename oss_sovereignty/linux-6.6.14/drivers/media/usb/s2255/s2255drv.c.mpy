{
  "module_name": "s2255drv.c",
  "hash_id": "402fda53edffb9170a9e0076b7dd7caef39b7bdedb2b662d727ad6e6ad00887b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/s2255/s2255drv.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/kernel.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/usb.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-vmalloc.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n\n#define S2255_VERSION\t\t\"1.25.1\"\n#define FIRMWARE_FILE_NAME \"f2255usb.bin\"\n\n \n#define S2255_DEF_JPEG_QUAL     50\n \n#define S2255_VR_IN\t\t0\n \n#define S2255_VR_OUT\t\t1\n \n#define S2255_VR_FW\t\t0x30\n \n#define S2255_CONFIG_EP         2\n \n#define S2255_DSP_BOOTTIME      800\n \n#define S2255_LOAD_TIMEOUT      (5000 + S2255_DSP_BOOTTIME)\n#define S2255_MIN_BUFS          2\n#define S2255_SETMODE_TIMEOUT   500\n#define S2255_VIDSTATUS_TIMEOUT 350\n#define S2255_MARKER_FRAME\tcpu_to_le32(0x2255DA4AL)\n#define S2255_MARKER_RESPONSE\tcpu_to_le32(0x2255ACACL)\n#define S2255_RESPONSE_SETMODE  cpu_to_le32(0x01)\n#define S2255_RESPONSE_FW       cpu_to_le32(0x10)\n#define S2255_RESPONSE_STATUS   cpu_to_le32(0x20)\n#define S2255_USB_XFER_SIZE\t(16 * 1024)\n#define MAX_CHANNELS\t\t4\n#define SYS_FRAMES\t\t4\n \n#define SYS_FRAMES_MAXSIZE\t(720*288*2*2 + 4096)\n#define DEF_USB_BLOCK\t\tS2255_USB_XFER_SIZE\n#define LINE_SZ_4CIFS_NTSC\t640\n#define LINE_SZ_2CIFS_NTSC\t640\n#define LINE_SZ_1CIFS_NTSC\t320\n#define LINE_SZ_4CIFS_PAL\t704\n#define LINE_SZ_2CIFS_PAL\t704\n#define LINE_SZ_1CIFS_PAL\t352\n#define NUM_LINES_4CIFS_NTSC\t240\n#define NUM_LINES_2CIFS_NTSC\t240\n#define NUM_LINES_1CIFS_NTSC\t240\n#define NUM_LINES_4CIFS_PAL\t288\n#define NUM_LINES_2CIFS_PAL\t288\n#define NUM_LINES_1CIFS_PAL\t288\n#define LINE_SZ_DEF\t\t640\n#define NUM_LINES_DEF\t\t240\n\n\n \n#define FORMAT_NTSC\t1\n#define FORMAT_PAL\t2\n\n#define SCALE_4CIFS\t1\t \n#define SCALE_2CIFS\t2\t \n#define SCALE_1CIFS\t3\t \n \n#define SCALE_4CIFSI\t4\t \n\n#define COLOR_YUVPL\t1\t \n#define COLOR_YUVPK\t2\t \n#define COLOR_Y8\t4\t \n#define COLOR_JPG       5        \n\n#define MASK_COLOR       0x000000ff\n#define MASK_JPG_QUALITY 0x0000ff00\n#define MASK_INPUT_TYPE  0x000f0000\n \n#define FDEC_1\t\t1\t \n#define FDEC_2\t\t2\t \n#define FDEC_3\t\t3\t \n#define FDEC_5\t\t5\t \n\n \n#define DEF_SCALE\tSCALE_4CIFS\n#define DEF_COLOR\tCOLOR_YUVPL\n#define DEF_FDEC\tFDEC_1\n#define DEF_BRIGHT\t0\n#define DEF_CONTRAST\t0x5c\n#define DEF_SATURATION\t0x80\n#define DEF_HUE\t\t0\n\n \n#define IN_DATA_TOKEN\tcpu_to_le32(0x2255c0de)\n#define CMD_2255\t0xc2255000\n#define CMD_SET_MODE\tcpu_to_le32((CMD_2255 | 0x10))\n#define CMD_START\tcpu_to_le32((CMD_2255 | 0x20))\n#define CMD_STOP\tcpu_to_le32((CMD_2255 | 0x30))\n#define CMD_STATUS\tcpu_to_le32((CMD_2255 | 0x40))\n\nstruct s2255_mode {\n\tu32 format;\t \n\tu32 scale;\t \n\tu32 color;\t \n\tu32 fdec;\t \n\tu32 bright;\t \n\tu32 contrast;\t \n\tu32 saturation;\t \n\tu32 hue;\t \n\tu32 single;\t \n\tu32 usb_block;\t \n\tu32 restart;\t \n};\n\n\n#define S2255_READ_IDLE\t\t0\n#define S2255_READ_FRAME\t1\n\n \nstruct s2255_framei {\n\tunsigned long size;\n\tunsigned long ulState;\t \n\tvoid *lpvbits;\t\t \n\tunsigned long cur_size;\t \n};\n\n \nstruct s2255_bufferi {\n\tunsigned long dwFrames;\t\t\t \n\tstruct s2255_framei frame[SYS_FRAMES];\t \n};\n\n#define DEF_MODEI_NTSC_CONT\t{FORMAT_NTSC, DEF_SCALE, DEF_COLOR,\t\\\n\t\t\tDEF_FDEC, DEF_BRIGHT, DEF_CONTRAST, DEF_SATURATION, \\\n\t\t\tDEF_HUE, 0, DEF_USB_BLOCK, 0}\n\n \n#define S2255_FW_NOTLOADED\t0\n#define S2255_FW_LOADED_DSPWAIT\t1\n#define S2255_FW_SUCCESS\t2\n#define S2255_FW_FAILED\t\t3\n#define S2255_FW_DISCONNECTING  4\n#define S2255_FW_MARKER\t\tcpu_to_le32(0x22552f2f)\n \n#define S2255_READ_IDLE         0\n#define S2255_READ_FRAME        1\nstruct s2255_fw {\n\tint\t\t      fw_loaded;\n\tint\t\t      fw_size;\n\tstruct urb\t      *fw_urb;\n\tatomic_t\t      fw_state;\n\tvoid\t\t      *pfw_data;\n\twait_queue_head_t     wait_fw;\n\tconst struct firmware *fw;\n};\n\nstruct s2255_pipeinfo {\n\tu32 max_transfer_size;\n\tu32 cur_transfer_size;\n\tu8 *transfer_buffer;\n\tu32 state;\n\tvoid *stream_urb;\n\tvoid *dev;\t \n\tu32 err_count;\n\tu32 idx;\n};\n\nstruct s2255_fmt;  \nstruct s2255_dev;\n\n \nstruct s2255_vc {\n\tstruct s2255_dev        *dev;\n\tstruct video_device\tvdev;\n\tstruct v4l2_ctrl_handler hdl;\n\tstruct v4l2_ctrl\t*jpegqual_ctrl;\n\tint\t\t\tresources;\n\tstruct list_head        buf_list;\n\tstruct s2255_bufferi\tbuffer;\n\tstruct s2255_mode\tmode;\n\tv4l2_std_id\t\tstd;\n\t \n\tunsigned\t\tjpegqual;\n\t \n\tstruct v4l2_captureparm cap_parm;\n\tint\t\t\tcur_frame;\n\tint\t\t\tlast_frame;\n\t \n\tunsigned long\t\treq_image_size;\n\t \n\tunsigned long\t\tpkt_size;\n\tint\t\t\tbad_payload;\n\tunsigned long\t\tframe_count;\n\t \n\tint                     jpg_size;\n\t \n\tint                     configured;\n\twait_queue_head_t       wait_setmode;\n\tint                     setmode_ready;\n\t \n\tint                     vidstatus;\n\twait_queue_head_t       wait_vidstatus;\n\tint                     vidstatus_ready;\n\tunsigned int\t\twidth;\n\tunsigned int\t\theight;\n\tenum v4l2_field         field;\n\tconst struct s2255_fmt\t*fmt;\n\tint idx;  \n\tstruct vb2_queue vb_vidq;\n\tstruct mutex vb_lock;  \n\tspinlock_t qlock;\n};\n\n\nstruct s2255_dev {\n\tstruct s2255_vc         vc[MAX_CHANNELS];\n\tstruct v4l2_device      v4l2_dev;\n\tatomic_t                num_channels;\n\tint\t\t\tframes;\n\tstruct mutex\t\tlock;\t \n\tstruct mutex\t\tcmdlock;  \n\tstruct usb_device\t*udev;\n\tstruct usb_interface\t*interface;\n\tu8\t\t\tread_endpoint;\n\tstruct timer_list\ttimer;\n\tstruct s2255_fw\t*fw_data;\n\tstruct s2255_pipeinfo\tpipe;\n\tu32\t\t\tcc;\t \n\tint\t\t\tframe_ready;\n\tint                     chn_ready;\n\t \n\tint                     dsp_fw_ver;\n\tu16                     pid;  \n#define S2255_CMDBUF_SIZE 512\n\t__le32                  *cmdbuf;\n};\n\nstatic inline struct s2255_dev *to_s2255_dev(struct v4l2_device *v4l2_dev)\n{\n\treturn container_of(v4l2_dev, struct s2255_dev, v4l2_dev);\n}\n\nstruct s2255_fmt {\n\tu32 fourcc;\n\tint depth;\n};\n\n \nstruct s2255_buffer {\n\t \n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head list;\n};\n\n\n \n#define S2255_CUR_USB_FWVER\t((3 << 8) | 12)\n \n#define S2255_CUR_DSP_FWVER     10104\n \n#define S2255_MIN_DSP_STATUS      5\n#define S2255_MIN_DSP_COLORFILTER 8\n#define S2255_NORMS\t\t(V4L2_STD_ALL)\n\n \n\n \n#define S2255_V4L2_YC_ON  1\n#define S2255_V4L2_YC_OFF 0\n#define V4L2_CID_S2255_COLORFILTER (V4L2_CID_USER_S2255_BASE + 0)\n\n \n#define PREFIX_SIZE\t\t512\n\n \nstatic unsigned long G_chnmap[MAX_CHANNELS] = {3, 2, 1, 0};\n\nstatic int debug;\n\nstatic int s2255_start_readpipe(struct s2255_dev *dev);\nstatic void s2255_stop_readpipe(struct s2255_dev *dev);\nstatic int s2255_start_acquire(struct s2255_vc *vc);\nstatic int s2255_stop_acquire(struct s2255_vc *vc);\nstatic void s2255_fillbuff(struct s2255_vc *vc, struct s2255_buffer *buf,\n\t\t\t   int jpgsize);\nstatic int s2255_set_mode(struct s2255_vc *vc, struct s2255_mode *mode);\nstatic int s2255_board_shutdown(struct s2255_dev *dev);\nstatic void s2255_fwload_start(struct s2255_dev *dev);\nstatic void s2255_destroy(struct s2255_dev *dev);\nstatic long s2255_vendor_req(struct s2255_dev *dev, unsigned char req,\n\t\t\t     u16 index, u16 value, void *buf,\n\t\t\t     s32 buf_len, int bOut);\n\n \n#define S2255_DRIVER_NAME \"s2255\"\n#define s2255_dev_err(dev, fmt, arg...)\t\t\t\t\t\\\n\t\tdev_err(dev, S2255_DRIVER_NAME \" - \" fmt, ##arg)\n\n#define dprintk(dev, level, fmt, arg...) \\\n\tv4l2_dbg(level, debug, &dev->v4l2_dev, fmt, ## arg)\n\nstatic struct usb_driver s2255_driver;\n\n \nstatic int video_nr = -1;\t \n\n \nstatic int jpeg_enable = 1;\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Debug level(0-100) default 0\");\nmodule_param(video_nr, int, 0644);\nMODULE_PARM_DESC(video_nr, \"start video minor(-1 default autodetect)\");\nmodule_param(jpeg_enable, int, 0644);\nMODULE_PARM_DESC(jpeg_enable, \"Jpeg enable(1-on 0-off) default 1\");\n\n \n#define USB_SENSORAY_VID\t0x1943\nstatic const struct usb_device_id s2255_table[] = {\n\t{USB_DEVICE(USB_SENSORAY_VID, 0x2255)},\n\t{USB_DEVICE(USB_SENSORAY_VID, 0x2257)},  \n\t{ }\t\t\t \n};\nMODULE_DEVICE_TABLE(usb, s2255_table);\n\n#define BUFFER_TIMEOUT msecs_to_jiffies(400)\n\n \n \nstatic const struct s2255_fmt formats[] = {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_YUYV,\n\t\t.depth = 16\n\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_UYVY,\n\t\t.depth = 16\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YUV422P,\n\t\t.depth = 16\n\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_GREY,\n\t\t.depth = 8\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_JPEG,\n\t\t.depth = 24\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_MJPEG,\n\t\t.depth = 24\n\t}\n};\n\nstatic int norm_maxw(struct s2255_vc *vc)\n{\n\treturn (vc->std & V4L2_STD_525_60) ?\n\t    LINE_SZ_4CIFS_NTSC : LINE_SZ_4CIFS_PAL;\n}\n\nstatic int norm_maxh(struct s2255_vc *vc)\n{\n\treturn (vc->std & V4L2_STD_525_60) ?\n\t    (NUM_LINES_1CIFS_NTSC * 2) : (NUM_LINES_1CIFS_PAL * 2);\n}\n\nstatic int norm_minw(struct s2255_vc *vc)\n{\n\treturn (vc->std & V4L2_STD_525_60) ?\n\t    LINE_SZ_1CIFS_NTSC : LINE_SZ_1CIFS_PAL;\n}\n\nstatic int norm_minh(struct s2255_vc *vc)\n{\n\treturn (vc->std & V4L2_STD_525_60) ?\n\t    (NUM_LINES_1CIFS_NTSC) : (NUM_LINES_1CIFS_PAL);\n}\n\n\n \nstatic void planar422p_to_yuv_packed(const unsigned char *in,\n\t\t\t\t     unsigned char *out,\n\t\t\t\t     int width, int height,\n\t\t\t\t     int fmt)\n{\n\tunsigned char *pY;\n\tunsigned char *pCb;\n\tunsigned char *pCr;\n\tunsigned long size = height * width;\n\tunsigned int i;\n\tpY = (unsigned char *)in;\n\tpCr = (unsigned char *)in + height * width;\n\tpCb = (unsigned char *)in + height * width + (height * width / 2);\n\tfor (i = 0; i < size * 2; i += 4) {\n\t\tout[i] = (fmt == V4L2_PIX_FMT_YUYV) ? *pY++ : *pCr++;\n\t\tout[i + 1] = (fmt == V4L2_PIX_FMT_YUYV) ? *pCr++ : *pY++;\n\t\tout[i + 2] = (fmt == V4L2_PIX_FMT_YUYV) ? *pY++ : *pCb++;\n\t\tout[i + 3] = (fmt == V4L2_PIX_FMT_YUYV) ? *pCb++ : *pY++;\n\t}\n\treturn;\n}\n\nstatic void s2255_reset_dsppower(struct s2255_dev *dev)\n{\n\ts2255_vendor_req(dev, 0x40, 0x0000, 0x0001, NULL, 0, 1);\n\tmsleep(50);\n\ts2255_vendor_req(dev, 0x50, 0x0000, 0x0000, NULL, 0, 1);\n\tmsleep(600);\n\ts2255_vendor_req(dev, 0x10, 0x0000, 0x0000, NULL, 0, 1);\n\treturn;\n}\n\n \nstatic void s2255_timer(struct timer_list *t)\n{\n\tstruct s2255_dev *dev = from_timer(dev, t, timer);\n\tstruct s2255_fw *data = dev->fw_data;\n\tif (usb_submit_urb(data->fw_urb, GFP_ATOMIC) < 0) {\n\t\tpr_err(\"s2255: can't submit urb\\n\");\n\t\tatomic_set(&data->fw_state, S2255_FW_FAILED);\n\t\t \n\t\twake_up(&data->wait_fw);\n\t\treturn;\n\t}\n}\n\n\n \nstatic void s2255_fwchunk_complete(struct urb *urb)\n{\n\tstruct s2255_fw *data = urb->context;\n\tstruct usb_device *udev = urb->dev;\n\tint len;\n\tif (urb->status) {\n\t\tdev_err(&udev->dev, \"URB failed with status %d\\n\", urb->status);\n\t\tatomic_set(&data->fw_state, S2255_FW_FAILED);\n\t\t \n\t\twake_up(&data->wait_fw);\n\t\treturn;\n\t}\n\tif (data->fw_urb == NULL) {\n\t\ts2255_dev_err(&udev->dev, \"disconnected\\n\");\n\t\tatomic_set(&data->fw_state, S2255_FW_FAILED);\n\t\t \n\t\twake_up(&data->wait_fw);\n\t\treturn;\n\t}\n#define CHUNK_SIZE 512\n\t \n\tif (data->fw_loaded < data->fw_size) {\n\t\tlen = (data->fw_loaded + CHUNK_SIZE) > data->fw_size ?\n\t\t    data->fw_size % CHUNK_SIZE : CHUNK_SIZE;\n\n\t\tif (len < CHUNK_SIZE)\n\t\t\tmemset(data->pfw_data, 0, CHUNK_SIZE);\n\n\t\tmemcpy(data->pfw_data,\n\t\t       (char *) data->fw->data + data->fw_loaded, len);\n\n\t\tusb_fill_bulk_urb(data->fw_urb, udev, usb_sndbulkpipe(udev, 2),\n\t\t\t\t  data->pfw_data, CHUNK_SIZE,\n\t\t\t\t  s2255_fwchunk_complete, data);\n\t\tif (usb_submit_urb(data->fw_urb, GFP_ATOMIC) < 0) {\n\t\t\tdev_err(&udev->dev, \"failed submit URB\\n\");\n\t\t\tatomic_set(&data->fw_state, S2255_FW_FAILED);\n\t\t\t \n\t\t\twake_up(&data->wait_fw);\n\t\t\treturn;\n\t\t}\n\t\tdata->fw_loaded += len;\n\t} else\n\t\tatomic_set(&data->fw_state, S2255_FW_LOADED_DSPWAIT);\n\treturn;\n\n}\n\nstatic void s2255_got_frame(struct s2255_vc *vc, int jpgsize)\n{\n\tstruct s2255_buffer *buf;\n\tstruct s2255_dev *dev = to_s2255_dev(vc->vdev.v4l2_dev);\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&vc->qlock, flags);\n\tif (list_empty(&vc->buf_list)) {\n\t\tdprintk(dev, 1, \"No active queue to serve\\n\");\n\t\tspin_unlock_irqrestore(&vc->qlock, flags);\n\t\treturn;\n\t}\n\tbuf = list_entry(vc->buf_list.next,\n\t\t\t struct s2255_buffer, list);\n\tlist_del(&buf->list);\n\tbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\tbuf->vb.field = vc->field;\n\tbuf->vb.sequence = vc->frame_count;\n\tspin_unlock_irqrestore(&vc->qlock, flags);\n\n\ts2255_fillbuff(vc, buf, jpgsize);\n\t \n\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\tdprintk(dev, 2, \"%s: [buf] [%p]\\n\", __func__, buf);\n}\n\nstatic const struct s2255_fmt *format_by_fourcc(int fourcc)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ARRAY_SIZE(formats); i++) {\n\t\tif (-1 == formats[i].fourcc)\n\t\t\tcontinue;\n\t\tif (!jpeg_enable && ((formats[i].fourcc == V4L2_PIX_FMT_JPEG) ||\n\t\t\t\t     (formats[i].fourcc == V4L2_PIX_FMT_MJPEG)))\n\t\t\tcontinue;\n\t\tif (formats[i].fourcc == fourcc)\n\t\t\treturn formats + i;\n\t}\n\treturn NULL;\n}\n\n \nstatic void s2255_fillbuff(struct s2255_vc *vc,\n\t\t\t   struct s2255_buffer *buf, int jpgsize)\n{\n\tint pos = 0;\n\tconst char *tmpbuf;\n\tchar *vbuf = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\n\tunsigned long last_frame;\n\tstruct s2255_dev *dev = vc->dev;\n\n\tif (!vbuf)\n\t\treturn;\n\tlast_frame = vc->last_frame;\n\tif (last_frame != -1) {\n\t\ttmpbuf =\n\t\t    (const char *)vc->buffer.frame[last_frame].lpvbits;\n\t\tswitch (vc->fmt->fourcc) {\n\t\tcase V4L2_PIX_FMT_YUYV:\n\t\tcase V4L2_PIX_FMT_UYVY:\n\t\t\tplanar422p_to_yuv_packed((const unsigned char *)tmpbuf,\n\t\t\t\t\t\t vbuf, vc->width,\n\t\t\t\t\t\t vc->height,\n\t\t\t\t\t\t vc->fmt->fourcc);\n\t\t\tbreak;\n\t\tcase V4L2_PIX_FMT_GREY:\n\t\t\tmemcpy(vbuf, tmpbuf, vc->width * vc->height);\n\t\t\tbreak;\n\t\tcase V4L2_PIX_FMT_JPEG:\n\t\tcase V4L2_PIX_FMT_MJPEG:\n\t\t\tvb2_set_plane_payload(&buf->vb.vb2_buf, 0, jpgsize);\n\t\t\tmemcpy(vbuf, tmpbuf, jpgsize);\n\t\t\tbreak;\n\t\tcase V4L2_PIX_FMT_YUV422P:\n\t\t\tmemcpy(vbuf, tmpbuf,\n\t\t\t       vc->width * vc->height * 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"s2255: unknown format?\\n\");\n\t\t}\n\t\tvc->last_frame = -1;\n\t} else {\n\t\tpr_err(\"s2255: =======no frame\\n\");\n\t\treturn;\n\t}\n\tdprintk(dev, 2, \"s2255fill at : Buffer %p size= %d\\n\",\n\t\tvbuf, pos);\n}\n\n\n \n\nstatic int queue_setup(struct vb2_queue *vq,\n\t\t       unsigned int *nbuffers, unsigned int *nplanes,\n\t\t       unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct s2255_vc *vc = vb2_get_drv_priv(vq);\n\tif (*nbuffers < S2255_MIN_BUFS)\n\t\t*nbuffers = S2255_MIN_BUFS;\n\t*nplanes = 1;\n\tsizes[0] = vc->width * vc->height * (vc->fmt->depth >> 3);\n\treturn 0;\n}\n\nstatic int buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct s2255_vc *vc = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct s2255_buffer *buf = container_of(vbuf, struct s2255_buffer, vb);\n\tint w = vc->width;\n\tint h = vc->height;\n\tunsigned long size;\n\n\tdprintk(vc->dev, 4, \"%s\\n\", __func__);\n\tif (vc->fmt == NULL)\n\t\treturn -EINVAL;\n\n\tif ((w < norm_minw(vc)) ||\n\t    (w > norm_maxw(vc)) ||\n\t    (h < norm_minh(vc)) ||\n\t    (h > norm_maxh(vc))) {\n\t\tdprintk(vc->dev, 4, \"invalid buffer prepare\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsize = w * h * (vc->fmt->depth >> 3);\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tdprintk(vc->dev, 4, \"invalid buffer prepare\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(&buf->vb.vb2_buf, 0, size);\n\treturn 0;\n}\n\nstatic void buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct s2255_buffer *buf = container_of(vbuf, struct s2255_buffer, vb);\n\tstruct s2255_vc *vc = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned long flags = 0;\n\tdprintk(vc->dev, 1, \"%s\\n\", __func__);\n\tspin_lock_irqsave(&vc->qlock, flags);\n\tlist_add_tail(&buf->list, &vc->buf_list);\n\tspin_unlock_irqrestore(&vc->qlock, flags);\n}\n\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count);\nstatic void stop_streaming(struct vb2_queue *vq);\n\nstatic const struct vb2_ops s2255_video_qops = {\n\t.queue_setup = queue_setup,\n\t.buf_prepare = buffer_prepare,\n\t.buf_queue = buffer_queue,\n\t.start_streaming = start_streaming,\n\t.stop_streaming = stop_streaming,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n};\n\nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct s2255_vc *vc = video_drvdata(file);\n\tstruct s2255_dev *dev = vc->dev;\n\n\tstrscpy(cap->driver, \"s2255\", sizeof(cap->driver));\n\tstrscpy(cap->card, \"s2255\", sizeof(cap->card));\n\tusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t       struct v4l2_fmtdesc *f)\n{\n\tint index = f->index;\n\n\tif (index >= ARRAY_SIZE(formats))\n\t\treturn -EINVAL;\n\tif (!jpeg_enable && ((formats[index].fourcc == V4L2_PIX_FMT_JPEG) ||\n\t\t\t(formats[index].fourcc == V4L2_PIX_FMT_MJPEG)))\n\t\treturn -EINVAL;\n\tf->pixelformat = formats[index].fourcc;\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *f)\n{\n\tstruct s2255_vc *vc = video_drvdata(file);\n\tint is_ntsc = vc->std & V4L2_STD_525_60;\n\n\tf->fmt.pix.width = vc->width;\n\tf->fmt.pix.height = vc->height;\n\tif (f->fmt.pix.height >=\n\t    (is_ntsc ? NUM_LINES_1CIFS_NTSC : NUM_LINES_1CIFS_PAL) * 2)\n\t\tf->fmt.pix.field = V4L2_FIELD_INTERLACED;\n\telse\n\t\tf->fmt.pix.field = V4L2_FIELD_TOP;\n\tf->fmt.pix.pixelformat = vc->fmt->fourcc;\n\tf->fmt.pix.bytesperline = f->fmt.pix.width * (vc->fmt->depth >> 3);\n\tf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *f)\n{\n\tconst struct s2255_fmt *fmt;\n\tenum v4l2_field field;\n\tstruct s2255_vc *vc = video_drvdata(file);\n\tint is_ntsc = vc->std & V4L2_STD_525_60;\n\n\tfmt = format_by_fourcc(f->fmt.pix.pixelformat);\n\n\tif (fmt == NULL)\n\t\treturn -EINVAL;\n\n\tdprintk(vc->dev, 50, \"%s NTSC: %d suggested width: %d, height: %d\\n\",\n\t\t__func__, is_ntsc, f->fmt.pix.width, f->fmt.pix.height);\n\tif (is_ntsc) {\n\t\t \n\t\tif (f->fmt.pix.height >= NUM_LINES_1CIFS_NTSC * 2) {\n\t\t\tf->fmt.pix.height = NUM_LINES_1CIFS_NTSC * 2;\n\t\t\tfield = V4L2_FIELD_INTERLACED;\n\t\t} else {\n\t\t\tf->fmt.pix.height = NUM_LINES_1CIFS_NTSC;\n\t\t\tfield = V4L2_FIELD_TOP;\n\t\t}\n\t\tif (f->fmt.pix.width >= LINE_SZ_4CIFS_NTSC)\n\t\t\tf->fmt.pix.width = LINE_SZ_4CIFS_NTSC;\n\t\telse\n\t\t\tf->fmt.pix.width = LINE_SZ_1CIFS_NTSC;\n\t} else {\n\t\t \n\t\tif (f->fmt.pix.height >= NUM_LINES_1CIFS_PAL * 2) {\n\t\t\tf->fmt.pix.height = NUM_LINES_1CIFS_PAL * 2;\n\t\t\tfield = V4L2_FIELD_INTERLACED;\n\t\t} else {\n\t\t\tf->fmt.pix.height = NUM_LINES_1CIFS_PAL;\n\t\t\tfield = V4L2_FIELD_TOP;\n\t\t}\n\t\tif (f->fmt.pix.width >= LINE_SZ_4CIFS_PAL)\n\t\t\tf->fmt.pix.width = LINE_SZ_4CIFS_PAL;\n\t\telse\n\t\t\tf->fmt.pix.width = LINE_SZ_1CIFS_PAL;\n\t}\n\tf->fmt.pix.field = field;\n\tf->fmt.pix.bytesperline = (f->fmt.pix.width * fmt->depth) >> 3;\n\tf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tdprintk(vc->dev, 50, \"%s: set width %d height %d field %d\\n\", __func__,\n\t\tf->fmt.pix.width, f->fmt.pix.height, f->fmt.pix.field);\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *f)\n{\n\tstruct s2255_vc *vc = video_drvdata(file);\n\tconst struct s2255_fmt *fmt;\n\tstruct vb2_queue *q = &vc->vb_vidq;\n\tstruct s2255_mode mode;\n\tint ret;\n\n\tret = vidioc_try_fmt_vid_cap(file, vc, f);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfmt = format_by_fourcc(f->fmt.pix.pixelformat);\n\n\tif (fmt == NULL)\n\t\treturn -EINVAL;\n\n\tif (vb2_is_busy(q)) {\n\t\tdprintk(vc->dev, 1, \"queue busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tmode = vc->mode;\n\tvc->fmt = fmt;\n\tvc->width = f->fmt.pix.width;\n\tvc->height = f->fmt.pix.height;\n\tvc->field = f->fmt.pix.field;\n\tif (vc->width > norm_minw(vc)) {\n\t\tif (vc->height > norm_minh(vc)) {\n\t\t\tif (vc->cap_parm.capturemode &\n\t\t\t    V4L2_MODE_HIGHQUALITY)\n\t\t\t\tmode.scale = SCALE_4CIFSI;\n\t\t\telse\n\t\t\t\tmode.scale = SCALE_4CIFS;\n\t\t} else\n\t\t\tmode.scale = SCALE_2CIFS;\n\n\t} else {\n\t\tmode.scale = SCALE_1CIFS;\n\t}\n\t \n\tswitch (vc->fmt->fourcc) {\n\tcase V4L2_PIX_FMT_GREY:\n\t\tmode.color &= ~MASK_COLOR;\n\t\tmode.color |= COLOR_Y8;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_JPEG:\n\tcase V4L2_PIX_FMT_MJPEG:\n\t\tmode.color &= ~MASK_COLOR;\n\t\tmode.color |= COLOR_JPG;\n\t\tmode.color |= (vc->jpegqual << 8);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV422P:\n\t\tmode.color &= ~MASK_COLOR;\n\t\tmode.color |= COLOR_YUVPL;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_UYVY:\n\tdefault:\n\t\tmode.color &= ~MASK_COLOR;\n\t\tmode.color |= COLOR_YUVPK;\n\t\tbreak;\n\t}\n\tif ((mode.color & MASK_COLOR) != (vc->mode.color & MASK_COLOR))\n\t\tmode.restart = 1;\n\telse if (mode.scale != vc->mode.scale)\n\t\tmode.restart = 1;\n\telse if (mode.format != vc->mode.format)\n\t\tmode.restart = 1;\n\tvc->mode = mode;\n\t(void) s2255_set_mode(vc, &mode);\n\treturn 0;\n}\n\n\n \nstatic int s2255_write_config(struct usb_device *udev, unsigned char *pbuf,\n\t\t\t      int size)\n{\n\tint pipe;\n\tint done;\n\tlong retval = -1;\n\tif (udev) {\n\t\tpipe = usb_sndbulkpipe(udev, S2255_CONFIG_EP);\n\t\tretval = usb_bulk_msg(udev, pipe, pbuf, size, &done, 500);\n\t}\n\treturn retval;\n}\n\nstatic u32 get_transfer_size(struct s2255_mode *mode)\n{\n\tint linesPerFrame = LINE_SZ_DEF;\n\tint pixelsPerLine = NUM_LINES_DEF;\n\tu32 outImageSize;\n\tu32 usbInSize;\n\tunsigned int mask_mult;\n\n\tif (mode == NULL)\n\t\treturn 0;\n\n\tif (mode->format == FORMAT_NTSC) {\n\t\tswitch (mode->scale) {\n\t\tcase SCALE_4CIFS:\n\t\tcase SCALE_4CIFSI:\n\t\t\tlinesPerFrame = NUM_LINES_4CIFS_NTSC * 2;\n\t\t\tpixelsPerLine = LINE_SZ_4CIFS_NTSC;\n\t\t\tbreak;\n\t\tcase SCALE_2CIFS:\n\t\t\tlinesPerFrame = NUM_LINES_2CIFS_NTSC;\n\t\t\tpixelsPerLine = LINE_SZ_2CIFS_NTSC;\n\t\t\tbreak;\n\t\tcase SCALE_1CIFS:\n\t\t\tlinesPerFrame = NUM_LINES_1CIFS_NTSC;\n\t\t\tpixelsPerLine = LINE_SZ_1CIFS_NTSC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else if (mode->format == FORMAT_PAL) {\n\t\tswitch (mode->scale) {\n\t\tcase SCALE_4CIFS:\n\t\tcase SCALE_4CIFSI:\n\t\t\tlinesPerFrame = NUM_LINES_4CIFS_PAL * 2;\n\t\t\tpixelsPerLine = LINE_SZ_4CIFS_PAL;\n\t\t\tbreak;\n\t\tcase SCALE_2CIFS:\n\t\t\tlinesPerFrame = NUM_LINES_2CIFS_PAL;\n\t\t\tpixelsPerLine = LINE_SZ_2CIFS_PAL;\n\t\t\tbreak;\n\t\tcase SCALE_1CIFS:\n\t\t\tlinesPerFrame = NUM_LINES_1CIFS_PAL;\n\t\t\tpixelsPerLine = LINE_SZ_1CIFS_PAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\toutImageSize = linesPerFrame * pixelsPerLine;\n\tif ((mode->color & MASK_COLOR) != COLOR_Y8) {\n\t\t \n\t\toutImageSize *= 2;\n\t}\n\n\t \n\tusbInSize = outImageSize + PREFIX_SIZE;\t \n\tmask_mult = 0xffffffffUL - DEF_USB_BLOCK + 1;\n\t \n\tif (usbInSize & ~mask_mult)\n\t\tusbInSize = (usbInSize & mask_mult) + (DEF_USB_BLOCK);\n\treturn usbInSize;\n}\n\nstatic void s2255_print_cfg(struct s2255_dev *sdev, struct s2255_mode *mode)\n{\n\tstruct device *dev = &sdev->udev->dev;\n\tdev_info(dev, \"------------------------------------------------\\n\");\n\tdev_info(dev, \"format: %d\\nscale %d\\n\", mode->format, mode->scale);\n\tdev_info(dev, \"fdec: %d\\ncolor %d\\n\", mode->fdec, mode->color);\n\tdev_info(dev, \"bright: 0x%x\\n\", mode->bright);\n\tdev_info(dev, \"------------------------------------------------\\n\");\n}\n\n \nstatic int s2255_set_mode(struct s2255_vc *vc,\n\t\t\t  struct s2255_mode *mode)\n{\n\tint res;\n\tunsigned long chn_rev;\n\tstruct s2255_dev *dev = to_s2255_dev(vc->vdev.v4l2_dev);\n\tint i;\n\t__le32 *buffer = dev->cmdbuf;\n\n\tmutex_lock(&dev->cmdlock);\n\tchn_rev = G_chnmap[vc->idx];\n\tdprintk(dev, 3, \"%s channel: %d\\n\", __func__, vc->idx);\n\t \n\tif ((mode->color & MASK_COLOR) == COLOR_JPG) {\n\t\tmode->color &= ~MASK_COLOR;\n\t\tmode->color |= COLOR_JPG;\n\t\tmode->color &= ~MASK_JPG_QUALITY;\n\t\tmode->color |= (vc->jpegqual << 8);\n\t}\n\t \n\tvc->mode = *mode;\n\tvc->req_image_size = get_transfer_size(mode);\n\tdprintk(dev, 1, \"%s: reqsize %ld\\n\", __func__, vc->req_image_size);\n\t \n\tbuffer[0] = IN_DATA_TOKEN;\n\tbuffer[1] = (__le32) cpu_to_le32(chn_rev);\n\tbuffer[2] = CMD_SET_MODE;\n\tfor (i = 0; i < sizeof(struct s2255_mode) / sizeof(u32); i++)\n\t\tbuffer[3 + i] = cpu_to_le32(((u32 *)&vc->mode)[i]);\n\tvc->setmode_ready = 0;\n\tres = s2255_write_config(dev->udev, (unsigned char *)buffer, 512);\n\tif (debug)\n\t\ts2255_print_cfg(dev, mode);\n\t \n\tif (mode->restart) {\n\t\twait_event_timeout(vc->wait_setmode,\n\t\t\t\t   (vc->setmode_ready != 0),\n\t\t\t\t   msecs_to_jiffies(S2255_SETMODE_TIMEOUT));\n\t\tif (vc->setmode_ready != 1) {\n\t\t\tdprintk(dev, 0, \"s2255: no set mode response\\n\");\n\t\t\tres = -EFAULT;\n\t\t}\n\t}\n\t \n\tvc->mode.restart = 0;\n\tdprintk(dev, 1, \"%s chn %d, result: %d\\n\", __func__, vc->idx, res);\n\tmutex_unlock(&dev->cmdlock);\n\treturn res;\n}\n\nstatic int s2255_cmd_status(struct s2255_vc *vc, u32 *pstatus)\n{\n\tint res;\n\tu32 chn_rev;\n\tstruct s2255_dev *dev = to_s2255_dev(vc->vdev.v4l2_dev);\n\t__le32 *buffer = dev->cmdbuf;\n\n\tmutex_lock(&dev->cmdlock);\n\tchn_rev = G_chnmap[vc->idx];\n\tdprintk(dev, 4, \"%s chan %d\\n\", __func__, vc->idx);\n\t \n\tbuffer[0] = IN_DATA_TOKEN;\n\tbuffer[1] = (__le32) cpu_to_le32(chn_rev);\n\tbuffer[2] = CMD_STATUS;\n\t*pstatus = 0;\n\tvc->vidstatus_ready = 0;\n\tres = s2255_write_config(dev->udev, (unsigned char *)buffer, 512);\n\twait_event_timeout(vc->wait_vidstatus,\n\t\t\t   (vc->vidstatus_ready != 0),\n\t\t\t   msecs_to_jiffies(S2255_VIDSTATUS_TIMEOUT));\n\tif (vc->vidstatus_ready != 1) {\n\t\tdprintk(dev, 0, \"s2255: no vidstatus response\\n\");\n\t\tres = -EFAULT;\n\t}\n\t*pstatus = vc->vidstatus;\n\tdprintk(dev, 4, \"%s, vid status %d\\n\", __func__, *pstatus);\n\tmutex_unlock(&dev->cmdlock);\n\treturn res;\n}\n\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct s2255_vc *vc = vb2_get_drv_priv(vq);\n\tint j;\n\n\tvc->last_frame = -1;\n\tvc->bad_payload = 0;\n\tvc->cur_frame = 0;\n\tvc->frame_count = 0;\n\tfor (j = 0; j < SYS_FRAMES; j++) {\n\t\tvc->buffer.frame[j].ulState = S2255_READ_IDLE;\n\t\tvc->buffer.frame[j].cur_size = 0;\n\t}\n\treturn s2255_start_acquire(vc);\n}\n\n \nstatic void stop_streaming(struct vb2_queue *vq)\n{\n\tstruct s2255_vc *vc = vb2_get_drv_priv(vq);\n\tstruct s2255_buffer *buf, *node;\n\tunsigned long flags;\n\t(void) s2255_stop_acquire(vc);\n\tspin_lock_irqsave(&vc->qlock, flags);\n\tlist_for_each_entry_safe(buf, node, &vc->buf_list, list) {\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\tdprintk(vc->dev, 2, \"[%p/%d] done\\n\",\n\t\t\tbuf, buf->vb.vb2_buf.index);\n\t}\n\tspin_unlock_irqrestore(&vc->qlock, flags);\n}\n\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)\n{\n\tstruct s2255_vc *vc = video_drvdata(file);\n\tstruct s2255_mode mode;\n\tstruct vb2_queue *q = &vc->vb_vidq;\n\n\t \n\tif (vb2_is_busy(q))\n\t\treturn -EBUSY;\n\n\tmode = vc->mode;\n\tif (i & V4L2_STD_525_60) {\n\t\tdprintk(vc->dev, 4, \"%s 60 Hz\\n\", __func__);\n\t\t \n\t\tif (mode.format != FORMAT_NTSC) {\n\t\t\tmode.restart = 1;\n\t\t\tmode.format = FORMAT_NTSC;\n\t\t\tmode.fdec = FDEC_1;\n\t\t\tvc->width = LINE_SZ_4CIFS_NTSC;\n\t\t\tvc->height = NUM_LINES_4CIFS_NTSC * 2;\n\t\t}\n\t} else if (i & V4L2_STD_625_50) {\n\t\tdprintk(vc->dev, 4, \"%s 50 Hz\\n\", __func__);\n\t\tif (mode.format != FORMAT_PAL) {\n\t\t\tmode.restart = 1;\n\t\t\tmode.format = FORMAT_PAL;\n\t\t\tmode.fdec = FDEC_1;\n\t\t\tvc->width = LINE_SZ_4CIFS_PAL;\n\t\t\tvc->height = NUM_LINES_4CIFS_PAL * 2;\n\t\t}\n\t} else\n\t\treturn -EINVAL;\n\tvc->std = i;\n\tif (mode.restart)\n\t\ts2255_set_mode(vc, &mode);\n\treturn 0;\n}\n\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *i)\n{\n\tstruct s2255_vc *vc = video_drvdata(file);\n\n\t*i = vc->std;\n\treturn 0;\n}\n\n \nstatic int vidioc_enum_input(struct file *file, void *priv,\n\t\t\t     struct v4l2_input *inp)\n{\n\tstruct s2255_vc *vc = video_drvdata(file);\n\tstruct s2255_dev *dev = vc->dev;\n\tu32 status = 0;\n\n\tif (inp->index != 0)\n\t\treturn -EINVAL;\n\tinp->type = V4L2_INPUT_TYPE_CAMERA;\n\tinp->std = S2255_NORMS;\n\tinp->status = 0;\n\tif (dev->dsp_fw_ver >= S2255_MIN_DSP_STATUS) {\n\t\tint rc;\n\t\trc = s2255_cmd_status(vc, &status);\n\t\tdprintk(dev, 4, \"s2255_cmd_status rc: %d status %x\\n\",\n\t\t\trc, status);\n\t\tif (rc == 0)\n\t\t\tinp->status =  (status & 0x01) ? 0\n\t\t\t\t: V4L2_IN_ST_NO_SIGNAL;\n\t}\n\tswitch (dev->pid) {\n\tcase 0x2255:\n\tdefault:\n\t\tstrscpy(inp->name, \"Composite\", sizeof(inp->name));\n\t\tbreak;\n\tcase 0x2257:\n\t\tstrscpy(inp->name, (vc->idx < 2) ? \"Composite\" : \"S-Video\",\n\t\t\tsizeof(inp->name));\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\t*i = 0;\n\treturn 0;\n}\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tif (i > 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int s2255_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct s2255_vc *vc =\n\t\tcontainer_of(ctrl->handler, struct s2255_vc, hdl);\n\tstruct s2255_mode mode;\n\tmode = vc->mode;\n\t \n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tmode.bright = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tmode.contrast = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\tmode.hue = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tmode.saturation = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_S2255_COLORFILTER:\n\t\tmode.color &= ~MASK_INPUT_TYPE;\n\t\tmode.color |= !ctrl->val << 16;\n\t\tbreak;\n\tcase V4L2_CID_JPEG_COMPRESSION_QUALITY:\n\t\tvc->jpegqual = ctrl->val;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tmode.restart = 0;\n\t \n\ts2255_set_mode(vc, &mode);\n\treturn 0;\n}\n\nstatic int vidioc_g_jpegcomp(struct file *file, void *priv,\n\t\t\t struct v4l2_jpegcompression *jc)\n{\n\tstruct s2255_vc *vc = video_drvdata(file);\n\n\tmemset(jc, 0, sizeof(*jc));\n\tjc->quality = vc->jpegqual;\n\tdprintk(vc->dev, 2, \"%s: quality %d\\n\", __func__, jc->quality);\n\treturn 0;\n}\n\nstatic int vidioc_s_jpegcomp(struct file *file, void *priv,\n\t\t\t const struct v4l2_jpegcompression *jc)\n{\n\tstruct s2255_vc *vc = video_drvdata(file);\n\n\tif (jc->quality < 0 || jc->quality > 100)\n\t\treturn -EINVAL;\n\tv4l2_ctrl_s_ctrl(vc->jpegqual_ctrl, jc->quality);\n\tdprintk(vc->dev, 2, \"%s: quality %d\\n\", __func__, jc->quality);\n\treturn 0;\n}\n\nstatic int vidioc_g_parm(struct file *file, void *priv,\n\t\t\t struct v4l2_streamparm *sp)\n{\n\t__u32 def_num, def_dem;\n\tstruct s2255_vc *vc = video_drvdata(file);\n\n\tif (sp->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\tsp->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\n\tsp->parm.capture.capturemode = vc->cap_parm.capturemode;\n\tsp->parm.capture.readbuffers = S2255_MIN_BUFS;\n\tdef_num = (vc->mode.format == FORMAT_NTSC) ? 1001 : 1000;\n\tdef_dem = (vc->mode.format == FORMAT_NTSC) ? 30000 : 25000;\n\tsp->parm.capture.timeperframe.denominator = def_dem;\n\tswitch (vc->mode.fdec) {\n\tdefault:\n\tcase FDEC_1:\n\t\tsp->parm.capture.timeperframe.numerator = def_num;\n\t\tbreak;\n\tcase FDEC_2:\n\t\tsp->parm.capture.timeperframe.numerator = def_num * 2;\n\t\tbreak;\n\tcase FDEC_3:\n\t\tsp->parm.capture.timeperframe.numerator = def_num * 3;\n\t\tbreak;\n\tcase FDEC_5:\n\t\tsp->parm.capture.timeperframe.numerator = def_num * 5;\n\t\tbreak;\n\t}\n\tdprintk(vc->dev, 4, \"%s capture mode, %d timeperframe %d/%d\\n\",\n\t\t__func__,\n\t\tsp->parm.capture.capturemode,\n\t\tsp->parm.capture.timeperframe.numerator,\n\t\tsp->parm.capture.timeperframe.denominator);\n\treturn 0;\n}\n\nstatic int vidioc_s_parm(struct file *file, void *priv,\n\t\t\t struct v4l2_streamparm *sp)\n{\n\tstruct s2255_vc *vc = video_drvdata(file);\n\tstruct s2255_mode mode;\n\tint fdec = FDEC_1;\n\t__u32 def_num, def_dem;\n\tif (sp->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\tmode = vc->mode;\n\t \n\tif ((vc->cap_parm.capturemode != sp->parm.capture.capturemode)\n\t    && vb2_is_streaming(&vc->vb_vidq))\n\t\treturn -EBUSY;\n\tdef_num = (mode.format == FORMAT_NTSC) ? 1001 : 1000;\n\tdef_dem = (mode.format == FORMAT_NTSC) ? 30000 : 25000;\n\tif (def_dem != sp->parm.capture.timeperframe.denominator)\n\t\tsp->parm.capture.timeperframe.numerator = def_num;\n\telse if (sp->parm.capture.timeperframe.numerator <= def_num)\n\t\tsp->parm.capture.timeperframe.numerator = def_num;\n\telse if (sp->parm.capture.timeperframe.numerator <= (def_num * 2)) {\n\t\tsp->parm.capture.timeperframe.numerator = def_num * 2;\n\t\tfdec = FDEC_2;\n\t} else if (sp->parm.capture.timeperframe.numerator <= (def_num * 3)) {\n\t\tsp->parm.capture.timeperframe.numerator = def_num * 3;\n\t\tfdec = FDEC_3;\n\t} else {\n\t\tsp->parm.capture.timeperframe.numerator = def_num * 5;\n\t\tfdec = FDEC_5;\n\t}\n\tmode.fdec = fdec;\n\tsp->parm.capture.timeperframe.denominator = def_dem;\n\tsp->parm.capture.readbuffers = S2255_MIN_BUFS;\n\ts2255_set_mode(vc, &mode);\n\tdprintk(vc->dev, 4, \"%s capture mode, %d timeperframe %d/%d, fdec %d\\n\",\n\t\t__func__,\n\t\tsp->parm.capture.capturemode,\n\t\tsp->parm.capture.timeperframe.numerator,\n\t\tsp->parm.capture.timeperframe.denominator, fdec);\n\treturn 0;\n}\n\n#define NUM_SIZE_ENUMS 3\nstatic const struct v4l2_frmsize_discrete ntsc_sizes[] = {\n\t{ 640, 480 },\n\t{ 640, 240 },\n\t{ 320, 240 },\n};\nstatic const struct v4l2_frmsize_discrete pal_sizes[] = {\n\t{ 704, 576 },\n\t{ 704, 288 },\n\t{ 352, 288 },\n};\n\nstatic int vidioc_enum_framesizes(struct file *file, void *priv,\n\t\t\t    struct v4l2_frmsizeenum *fe)\n{\n\tstruct s2255_vc *vc = video_drvdata(file);\n\tint is_ntsc = vc->std & V4L2_STD_525_60;\n\tconst struct s2255_fmt *fmt;\n\n\tif (fe->index >= NUM_SIZE_ENUMS)\n\t\treturn -EINVAL;\n\n\tfmt = format_by_fourcc(fe->pixel_format);\n\tif (fmt == NULL)\n\t\treturn -EINVAL;\n\tfe->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\tfe->discrete = is_ntsc ?  ntsc_sizes[fe->index] : pal_sizes[fe->index];\n\treturn 0;\n}\n\nstatic int vidioc_enum_frameintervals(struct file *file, void *priv,\n\t\t\t    struct v4l2_frmivalenum *fe)\n{\n\tstruct s2255_vc *vc = video_drvdata(file);\n\tconst struct s2255_fmt *fmt;\n\tconst struct v4l2_frmsize_discrete *sizes;\n\tint is_ntsc = vc->std & V4L2_STD_525_60;\n#define NUM_FRAME_ENUMS 4\n\tint frm_dec[NUM_FRAME_ENUMS] = {1, 2, 3, 5};\n\tint i;\n\n\tif (fe->index >= NUM_FRAME_ENUMS)\n\t\treturn -EINVAL;\n\n\tfmt = format_by_fourcc(fe->pixel_format);\n\tif (fmt == NULL)\n\t\treturn -EINVAL;\n\n\tsizes = is_ntsc ? ntsc_sizes : pal_sizes;\n\tfor (i = 0; i < NUM_SIZE_ENUMS; i++, sizes++)\n\t\tif (fe->width == sizes->width &&\n\t\t    fe->height == sizes->height)\n\t\t\tbreak;\n\tif (i == NUM_SIZE_ENUMS)\n\t\treturn -EINVAL;\n\n\tfe->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\tfe->discrete.denominator = is_ntsc ? 30000 : 25000;\n\tfe->discrete.numerator = (is_ntsc ? 1001 : 1000) * frm_dec[fe->index];\n\tdprintk(vc->dev, 4, \"%s discrete %d/%d\\n\", __func__,\n\t\tfe->discrete.numerator,\n\t\tfe->discrete.denominator);\n\treturn 0;\n}\n\nstatic int s2255_open(struct file *file)\n{\n\tstruct s2255_vc *vc = video_drvdata(file);\n\tstruct s2255_dev *dev = vc->dev;\n\tint state;\n\tint rc = 0;\n\n\trc = v4l2_fh_open(file);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tdprintk(dev, 1, \"s2255: %s\\n\", __func__);\n\tstate = atomic_read(&dev->fw_data->fw_state);\n\tswitch (state) {\n\tcase S2255_FW_DISCONNECTING:\n\t\treturn -ENODEV;\n\tcase S2255_FW_FAILED:\n\t\ts2255_dev_err(&dev->udev->dev,\n\t\t\t\"firmware load failed. retrying.\\n\");\n\t\ts2255_fwload_start(dev);\n\t\twait_event_timeout(dev->fw_data->wait_fw,\n\t\t\t\t   ((atomic_read(&dev->fw_data->fw_state)\n\t\t\t\t     == S2255_FW_SUCCESS) ||\n\t\t\t\t    (atomic_read(&dev->fw_data->fw_state)\n\t\t\t\t     == S2255_FW_DISCONNECTING)),\n\t\t\t\t   msecs_to_jiffies(S2255_LOAD_TIMEOUT));\n\t\t \n\t\tstate = atomic_read(&dev->fw_data->fw_state);\n\t\tbreak;\n\tcase S2255_FW_NOTLOADED:\n\tcase S2255_FW_LOADED_DSPWAIT:\n\t\t \n\t\tpr_info(\"%s waiting for firmware load\\n\", __func__);\n\t\twait_event_timeout(dev->fw_data->wait_fw,\n\t\t\t\t   ((atomic_read(&dev->fw_data->fw_state)\n\t\t\t\t     == S2255_FW_SUCCESS) ||\n\t\t\t\t    (atomic_read(&dev->fw_data->fw_state)\n\t\t\t\t     == S2255_FW_DISCONNECTING)),\n\t\t\t\t   msecs_to_jiffies(S2255_LOAD_TIMEOUT));\n\t\t \n\t\tstate = atomic_read(&dev->fw_data->fw_state);\n\t\tbreak;\n\tcase S2255_FW_SUCCESS:\n\tdefault:\n\t\tbreak;\n\t}\n\t \n\tswitch (state) {\n\tcase S2255_FW_SUCCESS:\n\t\tbreak;\n\tcase S2255_FW_FAILED:\n\t\tpr_info(\"2255 firmware load failed.\\n\");\n\t\treturn -ENODEV;\n\tcase S2255_FW_DISCONNECTING:\n\t\tpr_info(\"%s: disconnecting\\n\", __func__);\n\t\treturn -ENODEV;\n\tcase S2255_FW_LOADED_DSPWAIT:\n\tcase S2255_FW_NOTLOADED:\n\t\tpr_info(\"%s: firmware not loaded, please retry\\n\",\n\t\t\t__func__);\n\t\t \n\t\tatomic_set(&dev->fw_data->fw_state,\n\t\t\t   S2255_FW_FAILED);\n\t\treturn -EAGAIN;\n\tdefault:\n\t\tpr_info(\"%s: unknown state\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\tif (!vc->configured) {\n\t\t \n\t\tvc->fmt = &formats[0];\n\t\ts2255_set_mode(vc, &vc->mode);\n\t\tvc->configured = 1;\n\t}\n\treturn 0;\n}\n\nstatic void s2255_destroy(struct s2255_dev *dev)\n{\n\tdprintk(dev, 1, \"%s\", __func__);\n\t \n\ts2255_board_shutdown(dev);\n\t \n\ttimer_shutdown_sync(&dev->timer);   \n\tif (dev->fw_data->fw_urb) {\n\t\tusb_kill_urb(dev->fw_data->fw_urb);\n\t\tusb_free_urb(dev->fw_data->fw_urb);\n\t\tdev->fw_data->fw_urb = NULL;\n\t}\n\trelease_firmware(dev->fw_data->fw);\n\tkfree(dev->fw_data->pfw_data);\n\tkfree(dev->fw_data);\n\t \n\ts2255_reset_dsppower(dev);\n\tmutex_destroy(&dev->lock);\n\tusb_put_dev(dev->udev);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tkfree(dev->cmdbuf);\n\tkfree(dev);\n}\n\nstatic const struct v4l2_file_operations s2255_fops_v4l = {\n\t.owner = THIS_MODULE,\n\t.open = s2255_open,\n\t.release = vb2_fop_release,\n\t.poll = vb2_fop_poll,\n\t.unlocked_ioctl = video_ioctl2,\t \n\t.mmap = vb2_fop_mmap,\n\t.read = vb2_fop_read,\n};\n\nstatic const struct v4l2_ioctl_ops s2255_ioctl_ops = {\n\t.vidioc_querycap = vidioc_querycap,\n\t.vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap = vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap = vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap = vidioc_s_fmt_vid_cap,\n\t.vidioc_reqbufs = vb2_ioctl_reqbufs,\n\t.vidioc_querybuf = vb2_ioctl_querybuf,\n\t.vidioc_qbuf = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf = vb2_ioctl_dqbuf,\n\t.vidioc_s_std = vidioc_s_std,\n\t.vidioc_g_std = vidioc_g_std,\n\t.vidioc_enum_input = vidioc_enum_input,\n\t.vidioc_g_input = vidioc_g_input,\n\t.vidioc_s_input = vidioc_s_input,\n\t.vidioc_streamon = vb2_ioctl_streamon,\n\t.vidioc_streamoff = vb2_ioctl_streamoff,\n\t.vidioc_s_jpegcomp = vidioc_s_jpegcomp,\n\t.vidioc_g_jpegcomp = vidioc_g_jpegcomp,\n\t.vidioc_s_parm = vidioc_s_parm,\n\t.vidioc_g_parm = vidioc_g_parm,\n\t.vidioc_enum_framesizes = vidioc_enum_framesizes,\n\t.vidioc_enum_frameintervals = vidioc_enum_frameintervals,\n\t.vidioc_log_status  = v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic void s2255_video_device_release(struct video_device *vdev)\n{\n\tstruct s2255_dev *dev = to_s2255_dev(vdev->v4l2_dev);\n\tstruct s2255_vc *vc =\n\t\tcontainer_of(vdev, struct s2255_vc, vdev);\n\n\tdprintk(dev, 4, \"%s, chnls: %d\\n\", __func__,\n\t\tatomic_read(&dev->num_channels));\n\n\tv4l2_ctrl_handler_free(&vc->hdl);\n\n\tif (atomic_dec_and_test(&dev->num_channels))\n\t\ts2255_destroy(dev);\n\treturn;\n}\n\nstatic const struct video_device template = {\n\t.name = \"s2255v\",\n\t.fops = &s2255_fops_v4l,\n\t.ioctl_ops = &s2255_ioctl_ops,\n\t.release = s2255_video_device_release,\n\t.tvnorms = S2255_NORMS,\n};\n\nstatic const struct v4l2_ctrl_ops s2255_ctrl_ops = {\n\t.s_ctrl = s2255_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config color_filter_ctrl = {\n\t.ops = &s2255_ctrl_ops,\n\t.name = \"Color Filter\",\n\t.id = V4L2_CID_S2255_COLORFILTER,\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.step = 1,\n\t.def = 1,\n};\n\nstatic int s2255_probe_v4l(struct s2255_dev *dev)\n{\n\tint ret;\n\tint i;\n\tint cur_nr = video_nr;\n\tstruct s2255_vc *vc;\n\tstruct vb2_queue *q;\n\n\tret = v4l2_device_register(&dev->interface->dev, &dev->v4l2_dev);\n\tif (ret)\n\t\treturn ret;\n\t \n\t \n\tfor (i = 0; i < MAX_CHANNELS; i++) {\n\t\tvc = &dev->vc[i];\n\t\tINIT_LIST_HEAD(&vc->buf_list);\n\n\t\tv4l2_ctrl_handler_init(&vc->hdl, 6);\n\t\tv4l2_ctrl_new_std(&vc->hdl, &s2255_ctrl_ops,\n\t\t\t\tV4L2_CID_BRIGHTNESS, -127, 127, 1, DEF_BRIGHT);\n\t\tv4l2_ctrl_new_std(&vc->hdl, &s2255_ctrl_ops,\n\t\t\t\tV4L2_CID_CONTRAST, 0, 255, 1, DEF_CONTRAST);\n\t\tv4l2_ctrl_new_std(&vc->hdl, &s2255_ctrl_ops,\n\t\t\t\tV4L2_CID_SATURATION, 0, 255, 1, DEF_SATURATION);\n\t\tv4l2_ctrl_new_std(&vc->hdl, &s2255_ctrl_ops,\n\t\t\t\tV4L2_CID_HUE, 0, 255, 1, DEF_HUE);\n\t\tvc->jpegqual_ctrl = v4l2_ctrl_new_std(&vc->hdl,\n\t\t\t\t&s2255_ctrl_ops,\n\t\t\t\tV4L2_CID_JPEG_COMPRESSION_QUALITY,\n\t\t\t\t0, 100, 1, S2255_DEF_JPEG_QUAL);\n\t\tif (dev->dsp_fw_ver >= S2255_MIN_DSP_COLORFILTER &&\n\t\t    (dev->pid != 0x2257 || vc->idx <= 1))\n\t\t\tv4l2_ctrl_new_custom(&vc->hdl, &color_filter_ctrl,\n\t\t\t\t\t     NULL);\n\t\tif (vc->hdl.error) {\n\t\t\tret = vc->hdl.error;\n\t\t\tv4l2_ctrl_handler_free(&vc->hdl);\n\t\t\tdev_err(&dev->udev->dev, \"couldn't register control\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tq = &vc->vb_vidq;\n\t\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tq->io_modes = VB2_MMAP | VB2_READ | VB2_USERPTR;\n\t\tq->drv_priv = vc;\n\t\tq->lock = &vc->vb_lock;\n\t\tq->buf_struct_size = sizeof(struct s2255_buffer);\n\t\tq->mem_ops = &vb2_vmalloc_memops;\n\t\tq->ops = &s2255_video_qops;\n\t\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\t\tret = vb2_queue_init(q);\n\t\tif (ret != 0) {\n\t\t\tdev_err(&dev->udev->dev,\n\t\t\t\t\"%s vb2_queue_init 0x%x\\n\", __func__, ret);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tvc->vdev = template;\n\t\tvc->vdev.queue = q;\n\t\tvc->vdev.ctrl_handler = &vc->hdl;\n\t\tvc->vdev.lock = &dev->lock;\n\t\tvc->vdev.v4l2_dev = &dev->v4l2_dev;\n\t\tvc->vdev.device_caps = V4L2_CAP_VIDEO_CAPTURE |\n\t\t\t\t       V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\t\tvideo_set_drvdata(&vc->vdev, vc);\n\t\tif (video_nr == -1)\n\t\t\tret = video_register_device(&vc->vdev,\n\t\t\t\t\t\t    VFL_TYPE_VIDEO,\n\t\t\t\t\t\t    video_nr);\n\t\telse\n\t\t\tret = video_register_device(&vc->vdev,\n\t\t\t\t\t\t    VFL_TYPE_VIDEO,\n\t\t\t\t\t\t    cur_nr + i);\n\n\t\tif (ret) {\n\t\t\tdev_err(&dev->udev->dev,\n\t\t\t\t\"failed to register video device!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tatomic_inc(&dev->num_channels);\n\t\tv4l2_info(&dev->v4l2_dev, \"V4L2 device registered as %s\\n\",\n\t\t\t  video_device_node_name(&vc->vdev));\n\n\t}\n\tpr_info(\"Sensoray 2255 V4L driver Revision: %s\\n\",\n\t\tS2255_VERSION);\n\t \n\tif (atomic_read(&dev->num_channels) == 0) {\n\t\tv4l2_device_unregister(&dev->v4l2_dev);\n\t\treturn ret;\n\t}\n\tif (atomic_read(&dev->num_channels) != MAX_CHANNELS)\n\t\tpr_warn(\"s2255: Not all channels available.\\n\");\n\treturn 0;\n}\n\n \nstatic int save_frame(struct s2255_dev *dev, struct s2255_pipeinfo *pipe_info)\n{\n\tchar *pdest;\n\tu32 offset = 0;\n\tint bframe = 0;\n\tchar *psrc;\n\tunsigned long copy_size;\n\tunsigned long size;\n\ts32 idx = -1;\n\tstruct s2255_framei *frm;\n\tunsigned char *pdata;\n\tstruct s2255_vc *vc;\n\tdprintk(dev, 100, \"buffer to user\\n\");\n\tvc = &dev->vc[dev->cc];\n\tidx = vc->cur_frame;\n\tfrm = &vc->buffer.frame[idx];\n\tif (frm->ulState == S2255_READ_IDLE) {\n\t\tint jj;\n\t\tunsigned int cc;\n\t\t__le32 *pdword;  \n\t\tint payload;\n\t\t \n\t\tpdata = (unsigned char *)pipe_info->transfer_buffer;\n\t\tpdword = (__le32 *)pdata;\n\t\tfor (jj = 0; jj < (pipe_info->cur_transfer_size - 12); jj++) {\n\t\t\tswitch (*pdword) {\n\t\t\tcase S2255_MARKER_FRAME:\n\t\t\t\tdprintk(dev, 4, \"marker @ offset: %d [%x %x]\\n\",\n\t\t\t\t\tjj, pdata[0], pdata[1]);\n\t\t\t\toffset = jj + PREFIX_SIZE;\n\t\t\t\tbframe = 1;\n\t\t\t\tcc = le32_to_cpu(pdword[1]);\n\t\t\t\tif (cc >= MAX_CHANNELS) {\n\t\t\t\t\tdprintk(dev, 0,\n\t\t\t\t\t\t\"bad channel\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tdev->cc = G_chnmap[cc];\n\t\t\t\tvc = &dev->vc[dev->cc];\n\t\t\t\tpayload =  le32_to_cpu(pdword[3]);\n\t\t\t\tif (payload > vc->req_image_size) {\n\t\t\t\t\tvc->bad_payload++;\n\t\t\t\t\t \n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tvc->pkt_size = payload;\n\t\t\t\tvc->jpg_size = le32_to_cpu(pdword[4]);\n\t\t\t\tbreak;\n\t\t\tcase S2255_MARKER_RESPONSE:\n\n\t\t\t\tpdata += DEF_USB_BLOCK;\n\t\t\t\tjj += DEF_USB_BLOCK;\n\t\t\t\tif (le32_to_cpu(pdword[1]) >= MAX_CHANNELS)\n\t\t\t\t\tbreak;\n\t\t\t\tcc = G_chnmap[le32_to_cpu(pdword[1])];\n\t\t\t\tif (cc >= MAX_CHANNELS)\n\t\t\t\t\tbreak;\n\t\t\t\tvc = &dev->vc[cc];\n\t\t\t\tswitch (pdword[2]) {\n\t\t\t\tcase S2255_RESPONSE_SETMODE:\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\tvc->setmode_ready = 1;\n\t\t\t\t\twake_up(&vc->wait_setmode);\n\t\t\t\t\tdprintk(dev, 5, \"setmode rdy %d\\n\", cc);\n\t\t\t\t\tbreak;\n\t\t\t\tcase S2255_RESPONSE_FW:\n\t\t\t\t\tdev->chn_ready |= (1 << cc);\n\t\t\t\t\tif ((dev->chn_ready & 0x0f) != 0x0f)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t \n\t\t\t\t\tpr_info(\"s2255: fw loaded\\n\");\n\t\t\t\t\tatomic_set(&dev->fw_data->fw_state,\n\t\t\t\t\t\t   S2255_FW_SUCCESS);\n\t\t\t\t\twake_up(&dev->fw_data->wait_fw);\n\t\t\t\t\tbreak;\n\t\t\t\tcase S2255_RESPONSE_STATUS:\n\t\t\t\t\tvc->vidstatus = le32_to_cpu(pdword[3]);\n\t\t\t\t\tvc->vidstatus_ready = 1;\n\t\t\t\t\twake_up(&vc->wait_vidstatus);\n\t\t\t\t\tdprintk(dev, 5, \"vstat %x chan %d\\n\",\n\t\t\t\t\t\tle32_to_cpu(pdword[3]), cc);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tpr_info(\"s2255 unknown resp\\n\");\n\t\t\t\t}\n\t\t\t\tpdata++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpdata++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bframe)\n\t\t\t\tbreak;\n\t\t}  \n\t\tif (!bframe)\n\t\t\treturn -EINVAL;\n\t}\n\tvc = &dev->vc[dev->cc];\n\tidx = vc->cur_frame;\n\tfrm = &vc->buffer.frame[idx];\n\t \n\tif (!vb2_is_streaming(&vc->vb_vidq)) {\n\t\t \n\t\tfrm->ulState = S2255_READ_IDLE;\n\t\treturn -EINVAL;\n\t}\n\n\tif (frm->ulState == S2255_READ_IDLE) {\n\t\tfrm->ulState = S2255_READ_FRAME;\n\t\tfrm->cur_size = 0;\n\t}\n\n\t \n\tpsrc = (u8 *)pipe_info->transfer_buffer + offset;\n\n\n\tif (frm->lpvbits == NULL) {\n\t\tdprintk(dev, 1, \"s2255 frame buffer == NULL.%p %p %d %d\",\n\t\t\tfrm, dev, dev->cc, idx);\n\t\treturn -ENOMEM;\n\t}\n\n\tpdest = frm->lpvbits + frm->cur_size;\n\n\tcopy_size = (pipe_info->cur_transfer_size - offset);\n\n\tsize = vc->pkt_size - PREFIX_SIZE;\n\n\t \n\tif ((copy_size + frm->cur_size) < vc->req_image_size)\n\t\tmemcpy(pdest, psrc, copy_size);\n\n\tfrm->cur_size += copy_size;\n\tdprintk(dev, 4, \"cur_size: %lu, size: %lu\\n\", frm->cur_size, size);\n\n\tif (frm->cur_size >= size) {\n\t\tdprintk(dev, 2, \"******[%d]Buffer[%d]full*******\\n\",\n\t\t\tdev->cc, idx);\n\t\tvc->last_frame = vc->cur_frame;\n\t\tvc->cur_frame++;\n\t\t \n\t\tif ((vc->cur_frame == SYS_FRAMES) ||\n\t\t    (vc->cur_frame == vc->buffer.dwFrames))\n\t\t\tvc->cur_frame = 0;\n\t\t \n\t\tif (vb2_is_streaming(&vc->vb_vidq))\n\t\t\ts2255_got_frame(vc, vc->jpg_size);\n\t\tvc->frame_count++;\n\t\tfrm->ulState = S2255_READ_IDLE;\n\t\tfrm->cur_size = 0;\n\n\t}\n\t \n\treturn 0;\n}\n\nstatic void s2255_read_video_callback(struct s2255_dev *dev,\n\t\t\t\t      struct s2255_pipeinfo *pipe_info)\n{\n\tint res;\n\tdprintk(dev, 50, \"callback read video\\n\");\n\n\tif (dev->cc >= MAX_CHANNELS) {\n\t\tdev->cc = 0;\n\t\tdev_err(&dev->udev->dev, \"invalid channel\\n\");\n\t\treturn;\n\t}\n\t \n\tres = save_frame(dev, pipe_info);\n\tif (res != 0)\n\t\tdprintk(dev, 4, \"s2255: read callback failed\\n\");\n\n\tdprintk(dev, 50, \"callback read video done\\n\");\n\treturn;\n}\n\nstatic long s2255_vendor_req(struct s2255_dev *dev, unsigned char Request,\n\t\t\t     u16 Index, u16 Value, void *TransferBuffer,\n\t\t\t     s32 TransferBufferLength, int bOut)\n{\n\tint r;\n\tunsigned char *buf;\n\n\tbuf = kmalloc(TransferBufferLength, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (!bOut) {\n\t\tr = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t\t    Request,\n\t\t\t\t    USB_TYPE_VENDOR | USB_RECIP_DEVICE |\n\t\t\t\t    USB_DIR_IN,\n\t\t\t\t    Value, Index, buf,\n\t\t\t\t    TransferBufferLength, USB_CTRL_SET_TIMEOUT);\n\n\t\tif (r >= 0)\n\t\t\tmemcpy(TransferBuffer, buf, TransferBufferLength);\n\t} else {\n\t\tmemcpy(buf, TransferBuffer, TransferBufferLength);\n\t\tr = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\t\t\t    Request, USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\t    Value, Index, buf,\n\t\t\t\t    TransferBufferLength, USB_CTRL_SET_TIMEOUT);\n\t}\n\tkfree(buf);\n\treturn r;\n}\n\n \nstatic int s2255_get_fx2fw(struct s2255_dev *dev)\n{\n\tint fw;\n\tint ret;\n\tunsigned char transBuffer[64];\n\tret = s2255_vendor_req(dev, S2255_VR_FW, 0, 0, transBuffer, 2,\n\t\t\t       S2255_VR_IN);\n\tif (ret < 0)\n\t\tdprintk(dev, 2, \"get fw error: %x\\n\", ret);\n\tfw = transBuffer[0] + (transBuffer[1] << 8);\n\tdprintk(dev, 2, \"Get FW %x %x\\n\", transBuffer[0], transBuffer[1]);\n\treturn fw;\n}\n\n \nstatic int s2255_create_sys_buffers(struct s2255_vc *vc)\n{\n\tunsigned long i;\n\tunsigned long reqsize;\n\tvc->buffer.dwFrames = SYS_FRAMES;\n\t \n\treqsize = SYS_FRAMES_MAXSIZE;\n\n\tif (reqsize > SYS_FRAMES_MAXSIZE)\n\t\treqsize = SYS_FRAMES_MAXSIZE;\n\n\tfor (i = 0; i < SYS_FRAMES; i++) {\n\t\t \n\t\tvc->buffer.frame[i].lpvbits = vmalloc(reqsize);\n\t\tvc->buffer.frame[i].size = reqsize;\n\t\tif (vc->buffer.frame[i].lpvbits == NULL) {\n\t\t\tpr_info(\"out of memory.  using less frames\\n\");\n\t\t\tvc->buffer.dwFrames = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < SYS_FRAMES; i++) {\n\t\tvc->buffer.frame[i].ulState = 0;\n\t\tvc->buffer.frame[i].cur_size = 0;\n\t}\n\n\tvc->cur_frame = 0;\n\tvc->last_frame = -1;\n\treturn 0;\n}\n\nstatic int s2255_release_sys_buffers(struct s2255_vc *vc)\n{\n\tunsigned long i;\n\tfor (i = 0; i < SYS_FRAMES; i++) {\n\t\tvfree(vc->buffer.frame[i].lpvbits);\n\t\tvc->buffer.frame[i].lpvbits = NULL;\n\t}\n\treturn 0;\n}\n\nstatic int s2255_board_init(struct s2255_dev *dev)\n{\n\tstruct s2255_mode mode_def = DEF_MODEI_NTSC_CONT;\n\tint fw_ver;\n\tint j;\n\tstruct s2255_pipeinfo *pipe = &dev->pipe;\n\tdprintk(dev, 4, \"board init: %p\", dev);\n\tmemset(pipe, 0, sizeof(*pipe));\n\tpipe->dev = dev;\n\tpipe->cur_transfer_size = S2255_USB_XFER_SIZE;\n\tpipe->max_transfer_size = S2255_USB_XFER_SIZE;\n\n\tpipe->transfer_buffer = kzalloc(pipe->max_transfer_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (pipe->transfer_buffer == NULL) {\n\t\tdprintk(dev, 1, \"out of memory!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\t \n\tfw_ver = s2255_get_fx2fw(dev);\n\n\tpr_info(\"s2255: usb firmware version %d.%d\\n\",\n\t\t(fw_ver >> 8) & 0xff,\n\t\tfw_ver & 0xff);\n\n\tif (fw_ver < S2255_CUR_USB_FWVER)\n\t\tpr_info(\"s2255: newer USB firmware available\\n\");\n\n\tfor (j = 0; j < MAX_CHANNELS; j++) {\n\t\tstruct s2255_vc *vc = &dev->vc[j];\n\t\tvc->mode = mode_def;\n\t\tif (dev->pid == 0x2257 && j > 1)\n\t\t\tvc->mode.color |= (1 << 16);\n\t\tvc->jpegqual = S2255_DEF_JPEG_QUAL;\n\t\tvc->width = LINE_SZ_4CIFS_NTSC;\n\t\tvc->height = NUM_LINES_4CIFS_NTSC * 2;\n\t\tvc->std = V4L2_STD_NTSC_M;\n\t\tvc->fmt = &formats[0];\n\t\tvc->mode.restart = 1;\n\t\tvc->req_image_size = get_transfer_size(&mode_def);\n\t\tvc->frame_count = 0;\n\t\t \n\t\ts2255_create_sys_buffers(vc);\n\t}\n\t \n\ts2255_start_readpipe(dev);\n\tdprintk(dev, 1, \"%s: success\\n\", __func__);\n\treturn 0;\n}\n\nstatic int s2255_board_shutdown(struct s2255_dev *dev)\n{\n\tu32 i;\n\tdprintk(dev, 1, \"%s: dev: %p\", __func__,  dev);\n\n\tfor (i = 0; i < MAX_CHANNELS; i++) {\n\t\tif (vb2_is_streaming(&dev->vc[i].vb_vidq))\n\t\t\ts2255_stop_acquire(&dev->vc[i]);\n\t}\n\ts2255_stop_readpipe(dev);\n\tfor (i = 0; i < MAX_CHANNELS; i++)\n\t\ts2255_release_sys_buffers(&dev->vc[i]);\n\t \n\tkfree(dev->pipe.transfer_buffer);\n\treturn 0;\n}\n\nstatic void read_pipe_completion(struct urb *purb)\n{\n\tstruct s2255_pipeinfo *pipe_info;\n\tstruct s2255_dev *dev;\n\tint status;\n\tint pipe;\n\tpipe_info = purb->context;\n\tif (pipe_info == NULL) {\n\t\tdev_err(&purb->dev->dev, \"no context!\\n\");\n\t\treturn;\n\t}\n\tdev = pipe_info->dev;\n\tif (dev == NULL) {\n\t\tdev_err(&purb->dev->dev, \"no context!\\n\");\n\t\treturn;\n\t}\n\tstatus = purb->status;\n\t \n\tif (status == -ESHUTDOWN) {\n\t\tdprintk(dev, 2, \"%s: err shutdown\\n\", __func__);\n\t\tpipe_info->err_count++;\n\t\treturn;\n\t}\n\n\tif (pipe_info->state == 0) {\n\t\tdprintk(dev, 2, \"%s: exiting USB pipe\", __func__);\n\t\treturn;\n\t}\n\n\tif (status == 0)\n\t\ts2255_read_video_callback(dev, pipe_info);\n\telse {\n\t\tpipe_info->err_count++;\n\t\tdprintk(dev, 1, \"%s: failed URB %d\\n\", __func__, status);\n\t}\n\n\tpipe = usb_rcvbulkpipe(dev->udev, dev->read_endpoint);\n\t \n\tusb_fill_bulk_urb(pipe_info->stream_urb, dev->udev,\n\t\t\t  pipe,\n\t\t\t  pipe_info->transfer_buffer,\n\t\t\t  pipe_info->cur_transfer_size,\n\t\t\t  read_pipe_completion, pipe_info);\n\n\tif (pipe_info->state != 0) {\n\t\tif (usb_submit_urb(pipe_info->stream_urb, GFP_ATOMIC))\n\t\t\tdev_err(&dev->udev->dev, \"error submitting urb\\n\");\n\t} else {\n\t\tdprintk(dev, 2, \"%s :complete state 0\\n\", __func__);\n\t}\n\treturn;\n}\n\nstatic int s2255_start_readpipe(struct s2255_dev *dev)\n{\n\tint pipe;\n\tint retval;\n\tstruct s2255_pipeinfo *pipe_info = &dev->pipe;\n\tpipe = usb_rcvbulkpipe(dev->udev, dev->read_endpoint);\n\tdprintk(dev, 2, \"%s: IN %d\\n\", __func__, dev->read_endpoint);\n\tpipe_info->state = 1;\n\tpipe_info->err_count = 0;\n\tpipe_info->stream_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pipe_info->stream_urb)\n\t\treturn -ENOMEM;\n\t \n\tusb_fill_bulk_urb(pipe_info->stream_urb, dev->udev,\n\t\t\t  pipe,\n\t\t\t  pipe_info->transfer_buffer,\n\t\t\t  pipe_info->cur_transfer_size,\n\t\t\t  read_pipe_completion, pipe_info);\n\tretval = usb_submit_urb(pipe_info->stream_urb, GFP_KERNEL);\n\tif (retval) {\n\t\tpr_err(\"s2255: start read pipe failed\\n\");\n\t\treturn retval;\n\t}\n\treturn 0;\n}\n\n \nstatic int s2255_start_acquire(struct s2255_vc *vc)\n{\n\tint res;\n\tunsigned long chn_rev;\n\tint j;\n\tstruct s2255_dev *dev = to_s2255_dev(vc->vdev.v4l2_dev);\n\t__le32 *buffer = dev->cmdbuf;\n\n\tmutex_lock(&dev->cmdlock);\n\tchn_rev = G_chnmap[vc->idx];\n\tvc->last_frame = -1;\n\tvc->bad_payload = 0;\n\tvc->cur_frame = 0;\n\tfor (j = 0; j < SYS_FRAMES; j++) {\n\t\tvc->buffer.frame[j].ulState = 0;\n\t\tvc->buffer.frame[j].cur_size = 0;\n\t}\n\n\t \n\tbuffer[0] = IN_DATA_TOKEN;\n\tbuffer[1] = (__le32) cpu_to_le32(chn_rev);\n\tbuffer[2] = CMD_START;\n\tres = s2255_write_config(dev->udev, (unsigned char *)buffer, 512);\n\tif (res != 0)\n\t\tdev_err(&dev->udev->dev, \"CMD_START error\\n\");\n\n\tdprintk(dev, 2, \"start acquire exit[%d] %d\\n\", vc->idx, res);\n\tmutex_unlock(&dev->cmdlock);\n\treturn res;\n}\n\nstatic int s2255_stop_acquire(struct s2255_vc *vc)\n{\n\tint res;\n\tunsigned long chn_rev;\n\tstruct s2255_dev *dev = to_s2255_dev(vc->vdev.v4l2_dev);\n\t__le32 *buffer = dev->cmdbuf;\n\n\tmutex_lock(&dev->cmdlock);\n\tchn_rev = G_chnmap[vc->idx];\n\t \n\tbuffer[0] = IN_DATA_TOKEN;\n\tbuffer[1] = (__le32) cpu_to_le32(chn_rev);\n\tbuffer[2] = CMD_STOP;\n\n\tres = s2255_write_config(dev->udev, (unsigned char *)buffer, 512);\n\tif (res != 0)\n\t\tdev_err(&dev->udev->dev, \"CMD_STOP error\\n\");\n\n\tdprintk(dev, 4, \"%s: chn %d, res %d\\n\", __func__, vc->idx, res);\n\tmutex_unlock(&dev->cmdlock);\n\treturn res;\n}\n\nstatic void s2255_stop_readpipe(struct s2255_dev *dev)\n{\n\tstruct s2255_pipeinfo *pipe = &dev->pipe;\n\n\tpipe->state = 0;\n\tif (pipe->stream_urb) {\n\t\t \n\t\tusb_kill_urb(pipe->stream_urb);\n\t\tusb_free_urb(pipe->stream_urb);\n\t\tpipe->stream_urb = NULL;\n\t}\n\tdprintk(dev, 4, \"%s\", __func__);\n\treturn;\n}\n\nstatic void s2255_fwload_start(struct s2255_dev *dev)\n{\n\ts2255_reset_dsppower(dev);\n\tdev->fw_data->fw_size = dev->fw_data->fw->size;\n\tatomic_set(&dev->fw_data->fw_state, S2255_FW_NOTLOADED);\n\tmemcpy(dev->fw_data->pfw_data,\n\t       dev->fw_data->fw->data, CHUNK_SIZE);\n\tdev->fw_data->fw_loaded = CHUNK_SIZE;\n\tusb_fill_bulk_urb(dev->fw_data->fw_urb, dev->udev,\n\t\t\t  usb_sndbulkpipe(dev->udev, 2),\n\t\t\t  dev->fw_data->pfw_data,\n\t\t\t  CHUNK_SIZE, s2255_fwchunk_complete,\n\t\t\t  dev->fw_data);\n\tmod_timer(&dev->timer, jiffies + HZ);\n}\n\n \nstatic int s2255_probe(struct usb_interface *interface,\n\t\t       const struct usb_device_id *id)\n{\n\tstruct s2255_dev *dev = NULL;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint i;\n\tint retval = -ENOMEM;\n\t__le32 *pdata;\n\tint fw_size;\n\n\t \n\tdev = kzalloc(sizeof(struct s2255_dev), GFP_KERNEL);\n\tif (dev == NULL) {\n\t\ts2255_dev_err(&interface->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdev->cmdbuf = kzalloc(S2255_CMDBUF_SIZE, GFP_KERNEL);\n\tif (dev->cmdbuf == NULL) {\n\t\ts2255_dev_err(&interface->dev, \"out of memory\\n\");\n\t\tgoto errorFWDATA1;\n\t}\n\n\tatomic_set(&dev->num_channels, 0);\n\tdev->pid = id->idProduct;\n\tdev->fw_data = kzalloc(sizeof(struct s2255_fw), GFP_KERNEL);\n\tif (!dev->fw_data)\n\t\tgoto errorFWDATA1;\n\tmutex_init(&dev->lock);\n\tmutex_init(&dev->cmdlock);\n\t \n\tdev->udev = usb_get_dev(interface_to_usbdev(interface));\n\tif (dev->udev == NULL) {\n\t\tdev_err(&interface->dev, \"null usb device\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto errorUDEV;\n\t}\n\tdev_dbg(&interface->dev, \"dev: %p, udev %p interface %p\\n\",\n\t\tdev, dev->udev, interface);\n\tdev->interface = interface;\n\t \n\tiface_desc = interface->cur_altsetting;\n\tdev_dbg(&interface->dev, \"num EP: %d\\n\",\n\t\tiface_desc->desc.bNumEndpoints);\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\t\tif (!dev->read_endpoint && usb_endpoint_is_bulk_in(endpoint)) {\n\t\t\t \n\t\t\tdev->read_endpoint = endpoint->bEndpointAddress;\n\t\t}\n\t}\n\n\tif (!dev->read_endpoint) {\n\t\tdev_err(&interface->dev, \"Could not find bulk-in endpoint\\n\");\n\t\tgoto errorEP;\n\t}\n\ttimer_setup(&dev->timer, s2255_timer, 0);\n\tinit_waitqueue_head(&dev->fw_data->wait_fw);\n\tfor (i = 0; i < MAX_CHANNELS; i++) {\n\t\tstruct s2255_vc *vc = &dev->vc[i];\n\t\tvc->idx = i;\n\t\tvc->dev = dev;\n\t\tinit_waitqueue_head(&vc->wait_setmode);\n\t\tinit_waitqueue_head(&vc->wait_vidstatus);\n\t\tspin_lock_init(&vc->qlock);\n\t\tmutex_init(&vc->vb_lock);\n\t}\n\n\tdev->fw_data->fw_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->fw_data->fw_urb)\n\t\tgoto errorFWURB;\n\n\tdev->fw_data->pfw_data = kzalloc(CHUNK_SIZE, GFP_KERNEL);\n\tif (!dev->fw_data->pfw_data) {\n\t\tdev_err(&interface->dev, \"out of memory!\\n\");\n\t\tgoto errorFWDATA2;\n\t}\n\t \n\tif (request_firmware(&dev->fw_data->fw,\n\t\t\t     FIRMWARE_FILE_NAME, &dev->udev->dev)) {\n\t\tdev_err(&interface->dev, \"sensoray 2255 failed to get firmware\\n\");\n\t\tgoto errorREQFW;\n\t}\n\t \n\tfw_size = dev->fw_data->fw->size;\n\tpdata = (__le32 *) &dev->fw_data->fw->data[fw_size - 8];\n\n\tif (*pdata != S2255_FW_MARKER) {\n\t\tdev_err(&interface->dev, \"Firmware invalid.\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto errorFWMARKER;\n\t} else {\n\t\t \n\t\t__le32 *pRel;\n\t\tpRel = (__le32 *) &dev->fw_data->fw->data[fw_size - 4];\n\t\tpr_info(\"s2255 dsp fw version %x\\n\", le32_to_cpu(*pRel));\n\t\tdev->dsp_fw_ver = le32_to_cpu(*pRel);\n\t\tif (dev->dsp_fw_ver < S2255_CUR_DSP_FWVER)\n\t\t\tpr_info(\"s2255: f2255usb.bin out of date.\\n\");\n\t\tif (dev->pid == 0x2257 &&\n\t\t\t\tdev->dsp_fw_ver < S2255_MIN_DSP_COLORFILTER)\n\t\t\tpr_warn(\"2257 needs firmware %d or above.\\n\",\n\t\t\t\tS2255_MIN_DSP_COLORFILTER);\n\t}\n\tusb_reset_device(dev->udev);\n\t \n\tretval = s2255_board_init(dev);\n\tif (retval)\n\t\tgoto errorBOARDINIT;\n\ts2255_fwload_start(dev);\n\t \n\tretval = s2255_probe_v4l(dev);\n\tif (retval)\n\t\tgoto errorBOARDINIT;\n\tdev_info(&interface->dev, \"Sensoray 2255 detected\\n\");\n\treturn 0;\nerrorBOARDINIT:\n\ts2255_board_shutdown(dev);\nerrorFWMARKER:\n\trelease_firmware(dev->fw_data->fw);\nerrorREQFW:\n\tkfree(dev->fw_data->pfw_data);\nerrorFWDATA2:\n\tusb_free_urb(dev->fw_data->fw_urb);\nerrorFWURB:\n\ttimer_shutdown_sync(&dev->timer);\nerrorEP:\n\tusb_put_dev(dev->udev);\nerrorUDEV:\n\tkfree(dev->fw_data);\n\tmutex_destroy(&dev->lock);\nerrorFWDATA1:\n\tkfree(dev->cmdbuf);\n\tkfree(dev);\n\tpr_warn(\"Sensoray 2255 driver load failed: 0x%x\\n\", retval);\n\treturn retval;\n}\n\n \nstatic void s2255_disconnect(struct usb_interface *interface)\n{\n\tstruct s2255_dev *dev = to_s2255_dev(usb_get_intfdata(interface));\n\tint i;\n\tint channels = atomic_read(&dev->num_channels);\n\tmutex_lock(&dev->lock);\n\tv4l2_device_disconnect(&dev->v4l2_dev);\n\tmutex_unlock(&dev->lock);\n\t \n\tatomic_inc(&dev->num_channels);\n\t \n\tfor (i = 0; i < channels; i++)\n\t\tvideo_unregister_device(&dev->vc[i].vdev);\n\t \n\tatomic_set(&dev->fw_data->fw_state, S2255_FW_DISCONNECTING);\n\twake_up(&dev->fw_data->wait_fw);\n\tfor (i = 0; i < MAX_CHANNELS; i++) {\n\t\tdev->vc[i].setmode_ready = 1;\n\t\twake_up(&dev->vc[i].wait_setmode);\n\t\tdev->vc[i].vidstatus_ready = 1;\n\t\twake_up(&dev->vc[i].wait_vidstatus);\n\t}\n\tif (atomic_dec_and_test(&dev->num_channels))\n\t\ts2255_destroy(dev);\n\tdev_info(&interface->dev, \"%s\\n\", __func__);\n}\n\nstatic struct usb_driver s2255_driver = {\n\t.name = S2255_DRIVER_NAME,\n\t.probe = s2255_probe,\n\t.disconnect = s2255_disconnect,\n\t.id_table = s2255_table,\n};\n\nmodule_usb_driver(s2255_driver);\n\nMODULE_DESCRIPTION(\"Sensoray 2255 Video for Linux driver\");\nMODULE_AUTHOR(\"Dean Anderson (Sensoray Company Inc.)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(S2255_VERSION);\nMODULE_FIRMWARE(FIRMWARE_FILE_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}