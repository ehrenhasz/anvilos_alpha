{
  "module_name": "ttusb_dec.c",
  "hash_id": "997f646e10fe084969edab53cd36128458f0357519381a1fc767d06cb41e015e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/ttusb-dec/ttusb_dec.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/usb.h>\n#include <linux/interrupt.h>\n#include <linux/firmware.h>\n#include <linux/crc32.h>\n#include <linux/init.h>\n#include <linux/input.h>\n\n#include <linux/mutex.h>\n\n#include <media/dmxdev.h>\n#include <media/dvb_demux.h>\n#include <media/dvb_frontend.h>\n#include <media/dvb_net.h>\n#include \"ttusbdecfe.h\"\n\nstatic int debug;\nstatic int output_pva;\nstatic int enable_rc;\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off debugging (default:off).\");\nmodule_param(output_pva, int, 0444);\nMODULE_PARM_DESC(output_pva, \"Output PVA from dvr device (default:off)\");\nmodule_param(enable_rc, int, 0644);\nMODULE_PARM_DESC(enable_rc, \"Turn on/off IR remote control(default: off)\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n#define dprintk\tif (debug) printk\n\n#define DRIVER_NAME\t\t\"TechnoTrend/Hauppauge DEC USB\"\n\n#define COMMAND_PIPE\t\t0x03\n#define RESULT_PIPE\t\t0x04\n#define IN_PIPE\t\t\t0x08\n#define OUT_PIPE\t\t0x07\n#define IRQ_PIPE\t\t0x0A\n\n#define COMMAND_PACKET_SIZE\t0x3c\n#define ARM_PACKET_SIZE\t\t0x1000\n#define IRQ_PACKET_SIZE\t\t0x8\n\n#define ISO_BUF_COUNT\t\t0x04\n#define FRAMES_PER_ISO_BUF\t0x04\n#define ISO_FRAME_SIZE\t\t0x0380\n\n#define\tMAX_PVA_LENGTH\t\t6144\n\nenum ttusb_dec_model {\n\tTTUSB_DEC2000T,\n\tTTUSB_DEC2540T,\n\tTTUSB_DEC3000S\n};\n\nenum ttusb_dec_packet_type {\n\tTTUSB_DEC_PACKET_PVA,\n\tTTUSB_DEC_PACKET_SECTION,\n\tTTUSB_DEC_PACKET_EMPTY\n};\n\nenum ttusb_dec_interface {\n\tTTUSB_DEC_INTERFACE_INITIAL,\n\tTTUSB_DEC_INTERFACE_IN,\n\tTTUSB_DEC_INTERFACE_OUT\n};\n\ntypedef int (dvb_filter_pes2ts_cb_t) (void *, unsigned char *);\n\nstruct dvb_filter_pes2ts {\n\tunsigned char buf[188];\n\tunsigned char cc;\n\tdvb_filter_pes2ts_cb_t *cb;\n\tvoid *priv;\n};\n\nstruct ttusb_dec {\n\tenum ttusb_dec_model\t\tmodel;\n\tchar\t\t\t\t*model_name;\n\tchar\t\t\t\t*firmware_name;\n\tint\t\t\t\tcan_playback;\n\n\t \n\tstruct dvb_adapter\t\tadapter;\n\tstruct dmxdev\t\t\tdmxdev;\n\tstruct dvb_demux\t\tdemux;\n\tstruct dmx_frontend\t\tfrontend;\n\tstruct dvb_net\t\t\tdvb_net;\n\tstruct dvb_frontend*\t\tfe;\n\n\tu16\t\t\tpid[DMX_PES_OTHER];\n\n\t \n\tstruct usb_device\t\t*udev;\n\tu8\t\t\t\ttrans_count;\n\tunsigned int\t\t\tcommand_pipe;\n\tunsigned int\t\t\tresult_pipe;\n\tunsigned int\t\t\tin_pipe;\n\tunsigned int\t\t\tout_pipe;\n\tunsigned int\t\t\tirq_pipe;\n\tenum ttusb_dec_interface\tinterface;\n\tstruct mutex\t\t\tusb_mutex;\n\n\tvoid\t\t\t*irq_buffer;\n\tstruct urb\t\t*irq_urb;\n\tdma_addr_t\t\tirq_dma_handle;\n\tvoid\t\t\t*iso_buffer;\n\tstruct urb\t\t*iso_urb[ISO_BUF_COUNT];\n\tint\t\t\tiso_stream_count;\n\tstruct mutex\t\tiso_mutex;\n\n\tu8\t\t\t\tpacket[MAX_PVA_LENGTH + 4];\n\tenum ttusb_dec_packet_type\tpacket_type;\n\tint\t\t\t\tpacket_state;\n\tint\t\t\t\tpacket_length;\n\tint\t\t\t\tpacket_payload_length;\n\tu16\t\t\t\tnext_packet_id;\n\n\tint\t\t\t\tpva_stream_count;\n\tint\t\t\t\tfilter_stream_count;\n\n\tstruct dvb_filter_pes2ts\ta_pes2ts;\n\tstruct dvb_filter_pes2ts\tv_pes2ts;\n\n\tu8\t\t\tv_pes[16 + MAX_PVA_LENGTH];\n\tint\t\t\tv_pes_length;\n\tint\t\t\tv_pes_postbytes;\n\n\tstruct list_head\turb_frame_list;\n\tstruct tasklet_struct\turb_tasklet;\n\tspinlock_t\t\turb_frame_list_lock;\n\n\tstruct dvb_demux_filter\t*audio_filter;\n\tstruct dvb_demux_filter\t*video_filter;\n\tstruct list_head\tfilter_info_list;\n\tspinlock_t\t\tfilter_info_list_lock;\n\n\tstruct input_dev\t*rc_input_dev;\n\tchar\t\t\trc_phys[64];\n\n\tint\t\t\tactive;  \n};\n\nstruct urb_frame {\n\tu8\t\t\tdata[ISO_FRAME_SIZE];\n\tint\t\t\tlength;\n\tstruct list_head\turb_frame_list;\n};\n\nstruct filter_info {\n\tu8\t\t\tstream_id;\n\tstruct dvb_demux_filter\t*filter;\n\tstruct list_head\tfilter_info_list;\n};\n\nstatic u16 rc_keys[] = {\n\tKEY_POWER,\n\tKEY_MUTE,\n\tKEY_1,\n\tKEY_2,\n\tKEY_3,\n\tKEY_4,\n\tKEY_5,\n\tKEY_6,\n\tKEY_7,\n\tKEY_8,\n\tKEY_9,\n\tKEY_0,\n\tKEY_CHANNELUP,\n\tKEY_VOLUMEDOWN,\n\tKEY_OK,\n\tKEY_VOLUMEUP,\n\tKEY_CHANNELDOWN,\n\tKEY_PREVIOUS,\n\tKEY_ESC,\n\tKEY_RED,\n\tKEY_GREEN,\n\tKEY_YELLOW,\n\tKEY_BLUE,\n\tKEY_OPTION,\n\tKEY_M,\n\tKEY_RADIO\n};\n\nstatic void dvb_filter_pes2ts_init(struct dvb_filter_pes2ts *p2ts,\n\t\t\t\t   unsigned short pid,\n\t\t\t\t   dvb_filter_pes2ts_cb_t *cb, void *priv)\n{\n\tunsigned char *buf=p2ts->buf;\n\n\tbuf[0]=0x47;\n\tbuf[1]=(pid>>8);\n\tbuf[2]=pid&0xff;\n\tp2ts->cc=0;\n\tp2ts->cb=cb;\n\tp2ts->priv=priv;\n}\n\nstatic int dvb_filter_pes2ts(struct dvb_filter_pes2ts *p2ts,\n\t\t\t     unsigned char *pes, int len, int payload_start)\n{\n\tunsigned char *buf=p2ts->buf;\n\tint ret=0, rest;\n\n\t\n\n\tif (payload_start)\n\t\tbuf[1]|=0x40;\n\telse\n\t\tbuf[1]&=~0x40;\n\twhile (len>=184) {\n\t\tbuf[3]=0x10|((p2ts->cc++)&0x0f);\n\t\tmemcpy(buf+4, pes, 184);\n\t\tif ((ret=p2ts->cb(p2ts->priv, buf)))\n\t\t\treturn ret;\n\t\tlen-=184; pes+=184;\n\t\tbuf[1]&=~0x40;\n\t}\n\tif (!len)\n\t\treturn 0;\n\tbuf[3]=0x30|((p2ts->cc++)&0x0f);\n\trest=183-len;\n\tif (rest) {\n\t\tbuf[5]=0x00;\n\t\tif (rest-1)\n\t\t\tmemset(buf+6, 0xff, rest-1);\n\t}\n\tbuf[4]=rest;\n\tmemcpy(buf+5+rest, pes, len);\n\treturn p2ts->cb(p2ts->priv, buf);\n}\n\nstatic void ttusb_dec_set_model(struct ttusb_dec *dec,\n\t\t\t\tenum ttusb_dec_model model);\n\nstatic void ttusb_dec_handle_irq( struct urb *urb)\n{\n\tstruct ttusb_dec *dec = urb->context;\n\tchar *buffer = dec->irq_buffer;\n\tint retval;\n\tint index = buffer[4];\n\n\tswitch(urb->status) {\n\t\tcase 0:  \n\t\t\tbreak;\n\t\tcase -ECONNRESET:\n\t\tcase -ENOENT:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ETIME:\n\t\t\t \n\t\t\tdprintk(\"%s:urb shutting down with status: %d\\n\",\n\t\t\t\t\t__func__, urb->status);\n\t\t\treturn;\n\t\tdefault:\n\t\t\tdprintk(\"%s:nonzero status received: %d\\n\",\n\t\t\t\t\t__func__,urb->status);\n\t\t\tgoto exit;\n\t}\n\n\tif ((buffer[0] == 0x1) && (buffer[2] == 0x15))  {\n\t\t \n\t\tif (index - 1 < ARRAY_SIZE(rc_keys)) {\n\t\t\tdprintk(\"%s:rc signal:%d\\n\", __func__, index);\n\t\t\tinput_report_key(dec->rc_input_dev, rc_keys[index - 1], 1);\n\t\t\tinput_sync(dec->rc_input_dev);\n\t\t\tinput_report_key(dec->rc_input_dev, rc_keys[index - 1], 0);\n\t\t\tinput_sync(dec->rc_input_dev);\n\t\t}\n\t}\n\nexit:\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval)\n\t\tprintk(\"%s - usb_commit_urb failed with result: %d\\n\",\n\t\t\t__func__, retval);\n}\n\nstatic u16 crc16(u16 crc, const u8 *buf, size_t len)\n{\n\tu16 tmp;\n\n\twhile (len--) {\n\t\tcrc ^= *buf++;\n\t\tcrc ^= (u8)crc >> 4;\n\t\ttmp = (u8)crc;\n\t\tcrc ^= (tmp ^ (tmp << 1)) << 4;\n\t}\n\treturn crc;\n}\n\nstatic int ttusb_dec_send_command(struct ttusb_dec *dec, const u8 command,\n\t\t\t\t  int param_length, const u8 params[],\n\t\t\t\t  int *result_length, u8 cmd_result[])\n{\n\tint result, actual_len;\n\tu8 *b;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tb = kzalloc(COMMAND_PACKET_SIZE + 4, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\n\tresult = mutex_lock_interruptible(&dec->usb_mutex);\n\tif (result) {\n\t\tprintk(\"%s: Failed to lock usb mutex.\\n\", __func__);\n\t\tgoto err_free;\n\t}\n\n\tb[0] = 0xaa;\n\tb[1] = ++dec->trans_count;\n\tb[2] = command;\n\tb[3] = param_length;\n\n\tif (params)\n\t\tmemcpy(&b[4], params, param_length);\n\n\tif (debug) {\n\t\tprintk(KERN_DEBUG \"%s: command: %*ph\\n\",\n\t\t       __func__, param_length, b);\n\t}\n\n\tresult = usb_bulk_msg(dec->udev, dec->command_pipe, b,\n\t\t\t      COMMAND_PACKET_SIZE + 4, &actual_len, 1000);\n\n\tif (result) {\n\t\tprintk(\"%s: command bulk message failed: error %d\\n\",\n\t\t       __func__, result);\n\t\tgoto err_mutex_unlock;\n\t}\n\n\tresult = usb_bulk_msg(dec->udev, dec->result_pipe, b,\n\t\t\t      COMMAND_PACKET_SIZE + 4, &actual_len, 1000);\n\n\tif (result) {\n\t\tprintk(\"%s: result bulk message failed: error %d\\n\",\n\t\t       __func__, result);\n\t\tgoto err_mutex_unlock;\n\t} else {\n\t\tif (debug) {\n\t\t\tprintk(KERN_DEBUG \"%s: result: %*ph\\n\",\n\t\t\t       __func__, actual_len, b);\n\t\t}\n\n\t\tif (result_length)\n\t\t\t*result_length = b[3];\n\t\tif (cmd_result && b[3] > 0)\n\t\t\tmemcpy(cmd_result, &b[4], b[3]);\n\t}\n\nerr_mutex_unlock:\n\tmutex_unlock(&dec->usb_mutex);\nerr_free:\n\tkfree(b);\n\treturn result;\n}\n\nstatic int ttusb_dec_get_stb_state (struct ttusb_dec *dec, unsigned int *mode,\n\t\t\t\t    unsigned int *model, unsigned int *version)\n{\n\tu8 c[COMMAND_PACKET_SIZE];\n\tint c_length;\n\tint result;\n\t__be32 tmp;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tresult = ttusb_dec_send_command(dec, 0x08, 0, NULL, &c_length, c);\n\tif (result)\n\t\treturn result;\n\n\tif (c_length >= 0x0c) {\n\t\tif (mode != NULL) {\n\t\t\tmemcpy(&tmp, c, 4);\n\t\t\t*mode = ntohl(tmp);\n\t\t}\n\t\tif (model != NULL) {\n\t\t\tmemcpy(&tmp, &c[4], 4);\n\t\t\t*model = ntohl(tmp);\n\t\t}\n\t\tif (version != NULL) {\n\t\t\tmemcpy(&tmp, &c[8], 4);\n\t\t\t*version = ntohl(tmp);\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\treturn -ENOENT;\n\t}\n}\n\nstatic int ttusb_dec_audio_pes2ts_cb(void *priv, unsigned char *data)\n{\n\tstruct ttusb_dec *dec = priv;\n\n\tdec->audio_filter->feed->cb.ts(data, 188, NULL, 0,\n\t\t\t\t       &dec->audio_filter->feed->feed.ts, NULL);\n\n\treturn 0;\n}\n\nstatic int ttusb_dec_video_pes2ts_cb(void *priv, unsigned char *data)\n{\n\tstruct ttusb_dec *dec = priv;\n\n\tdec->video_filter->feed->cb.ts(data, 188, NULL, 0,\n\t\t\t\t       &dec->video_filter->feed->feed.ts, NULL);\n\n\treturn 0;\n}\n\nstatic void ttusb_dec_set_pids(struct ttusb_dec *dec)\n{\n\tu8 b[] = { 0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0xff, 0xff,\n\t\t   0xff, 0xff, 0xff, 0xff };\n\n\t__be16 pcr = htons(dec->pid[DMX_PES_PCR]);\n\t__be16 audio = htons(dec->pid[DMX_PES_AUDIO]);\n\t__be16 video = htons(dec->pid[DMX_PES_VIDEO]);\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tmemcpy(&b[0], &pcr, 2);\n\tmemcpy(&b[2], &audio, 2);\n\tmemcpy(&b[4], &video, 2);\n\n\tttusb_dec_send_command(dec, 0x50, sizeof(b), b, NULL, NULL);\n\n\tdvb_filter_pes2ts_init(&dec->a_pes2ts, dec->pid[DMX_PES_AUDIO],\n\t\t\t       ttusb_dec_audio_pes2ts_cb, dec);\n\tdvb_filter_pes2ts_init(&dec->v_pes2ts, dec->pid[DMX_PES_VIDEO],\n\t\t\t       ttusb_dec_video_pes2ts_cb, dec);\n\tdec->v_pes_length = 0;\n\tdec->v_pes_postbytes = 0;\n}\n\nstatic void ttusb_dec_process_pva(struct ttusb_dec *dec, u8 *pva, int length)\n{\n\tif (length < 8) {\n\t\tprintk(\"%s: packet too short - discarding\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (length > 8 + MAX_PVA_LENGTH) {\n\t\tprintk(\"%s: packet too long - discarding\\n\", __func__);\n\t\treturn;\n\t}\n\n\tswitch (pva[2]) {\n\n\tcase 0x01: {\t\t \n\t\tint prebytes = pva[5] & 0x03;\n\t\tint postbytes = (pva[5] & 0x0c) >> 2;\n\t\t__be16 v_pes_payload_length;\n\n\t\tif (output_pva) {\n\t\t\tdec->video_filter->feed->cb.ts(pva, length, NULL, 0,\n\t\t\t\t&dec->video_filter->feed->feed.ts, NULL);\n\t\t\treturn;\n\t\t}\n\n\t\tif (dec->v_pes_postbytes > 0 &&\n\t\t    dec->v_pes_postbytes == prebytes) {\n\t\t\tmemcpy(&dec->v_pes[dec->v_pes_length],\n\t\t\t       &pva[12], prebytes);\n\n\t\t\tdvb_filter_pes2ts(&dec->v_pes2ts, dec->v_pes,\n\t\t\t\t\t  dec->v_pes_length + prebytes, 1);\n\t\t}\n\n\t\tif (pva[5] & 0x10) {\n\t\t\tdec->v_pes[7] = 0x80;\n\t\t\tdec->v_pes[8] = 0x05;\n\n\t\t\tdec->v_pes[9] = 0x21 | ((pva[8] & 0xc0) >> 5);\n\t\t\tdec->v_pes[10] = ((pva[8] & 0x3f) << 2) |\n\t\t\t\t\t ((pva[9] & 0xc0) >> 6);\n\t\t\tdec->v_pes[11] = 0x01 |\n\t\t\t\t\t ((pva[9] & 0x3f) << 2) |\n\t\t\t\t\t ((pva[10] & 0x80) >> 6);\n\t\t\tdec->v_pes[12] = ((pva[10] & 0x7f) << 1) |\n\t\t\t\t\t ((pva[11] & 0xc0) >> 7);\n\t\t\tdec->v_pes[13] = 0x01 | ((pva[11] & 0x7f) << 1);\n\n\t\t\tmemcpy(&dec->v_pes[14], &pva[12 + prebytes],\n\t\t\t       length - 12 - prebytes);\n\t\t\tdec->v_pes_length = 14 + length - 12 - prebytes;\n\t\t} else {\n\t\t\tdec->v_pes[7] = 0x00;\n\t\t\tdec->v_pes[8] = 0x00;\n\n\t\t\tmemcpy(&dec->v_pes[9], &pva[8], length - 8);\n\t\t\tdec->v_pes_length = 9 + length - 8;\n\t\t}\n\n\t\tdec->v_pes_postbytes = postbytes;\n\n\t\tif (dec->v_pes[9 + dec->v_pes[8]] == 0x00 &&\n\t\t    dec->v_pes[10 + dec->v_pes[8]] == 0x00 &&\n\t\t    dec->v_pes[11 + dec->v_pes[8]] == 0x01)\n\t\t\tdec->v_pes[6] = 0x84;\n\t\telse\n\t\t\tdec->v_pes[6] = 0x80;\n\n\t\tv_pes_payload_length = htons(dec->v_pes_length - 6 +\n\t\t\t\t\t     postbytes);\n\t\tmemcpy(&dec->v_pes[4], &v_pes_payload_length, 2);\n\n\t\tif (postbytes == 0)\n\t\t\tdvb_filter_pes2ts(&dec->v_pes2ts, dec->v_pes,\n\t\t\t\t\t  dec->v_pes_length, 1);\n\n\t\tbreak;\n\t}\n\n\tcase 0x02:\t\t \n\t\tif (output_pva) {\n\t\t\tdec->audio_filter->feed->cb.ts(pva, length, NULL, 0,\n\t\t\t\t&dec->audio_filter->feed->feed.ts, NULL);\n\t\t\treturn;\n\t\t}\n\n\t\tdvb_filter_pes2ts(&dec->a_pes2ts, &pva[8], length - 8,\n\t\t\t\t  pva[5] & 0x10);\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(\"%s: unknown PVA type: %02x.\\n\", __func__,\n\t\t       pva[2]);\n\t\tbreak;\n\t}\n}\n\nstatic void ttusb_dec_process_filter(struct ttusb_dec *dec, u8 *packet,\n\t\t\t\t     int length)\n{\n\tstruct list_head *item;\n\tstruct filter_info *finfo;\n\tstruct dvb_demux_filter *filter = NULL;\n\tunsigned long flags;\n\tu8 sid;\n\n\tsid = packet[1];\n\tspin_lock_irqsave(&dec->filter_info_list_lock, flags);\n\tfor (item = dec->filter_info_list.next; item != &dec->filter_info_list;\n\t     item = item->next) {\n\t\tfinfo = list_entry(item, struct filter_info, filter_info_list);\n\t\tif (finfo->stream_id == sid) {\n\t\t\tfilter = finfo->filter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dec->filter_info_list_lock, flags);\n\n\tif (filter)\n\t\tfilter->feed->cb.sec(&packet[2], length - 2, NULL, 0,\n\t\t\t\t     &filter->filter, NULL);\n}\n\nstatic void ttusb_dec_process_packet(struct ttusb_dec *dec)\n{\n\tint i;\n\tu16 csum = 0;\n\tu16 packet_id;\n\n\tif (dec->packet_length % 2) {\n\t\tprintk(\"%s: odd sized packet - discarding\\n\", __func__);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < dec->packet_length; i += 2)\n\t\tcsum ^= ((dec->packet[i] << 8) + dec->packet[i + 1]);\n\n\tif (csum) {\n\t\tprintk(\"%s: checksum failed - discarding\\n\", __func__);\n\t\treturn;\n\t}\n\n\tpacket_id = dec->packet[dec->packet_length - 4] << 8;\n\tpacket_id += dec->packet[dec->packet_length - 3];\n\n\tif ((packet_id != dec->next_packet_id) && dec->next_packet_id) {\n\t\tprintk(\"%s: warning: lost packets between %u and %u\\n\",\n\t\t       __func__, dec->next_packet_id - 1, packet_id);\n\t}\n\n\tif (packet_id == 0xffff)\n\t\tdec->next_packet_id = 0x8000;\n\telse\n\t\tdec->next_packet_id = packet_id + 1;\n\n\tswitch (dec->packet_type) {\n\tcase TTUSB_DEC_PACKET_PVA:\n\t\tif (dec->pva_stream_count)\n\t\t\tttusb_dec_process_pva(dec, dec->packet,\n\t\t\t\t\t      dec->packet_payload_length);\n\t\tbreak;\n\n\tcase TTUSB_DEC_PACKET_SECTION:\n\t\tif (dec->filter_stream_count)\n\t\t\tttusb_dec_process_filter(dec, dec->packet,\n\t\t\t\t\t\t dec->packet_payload_length);\n\t\tbreak;\n\n\tcase TTUSB_DEC_PACKET_EMPTY:\n\t\tbreak;\n\t}\n}\n\nstatic void swap_bytes(u8 *b, int length)\n{\n\tlength -= length % 2;\n\tfor (; length; b += 2, length -= 2)\n\t\tswap(*b, *(b + 1));\n}\n\nstatic void ttusb_dec_process_urb_frame(struct ttusb_dec *dec, u8 *b,\n\t\t\t\t\tint length)\n{\n\tswap_bytes(b, length);\n\n\twhile (length) {\n\t\tswitch (dec->packet_state) {\n\n\t\tcase 0:\n\t\tcase 1:\n\t\tcase 2:\n\t\t\tif (*b++ == 0xaa)\n\t\t\t\tdec->packet_state++;\n\t\t\telse\n\t\t\t\tdec->packet_state = 0;\n\n\t\t\tlength--;\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tif (*b == 0x00) {\n\t\t\t\tdec->packet_state++;\n\t\t\t\tdec->packet_length = 0;\n\t\t\t} else if (*b != 0xaa) {\n\t\t\t\tdec->packet_state = 0;\n\t\t\t}\n\n\t\t\tb++;\n\t\t\tlength--;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tdec->packet[dec->packet_length++] = *b++;\n\n\t\t\tif (dec->packet_length == 2) {\n\t\t\t\tif (dec->packet[0] == 'A' &&\n\t\t\t\t    dec->packet[1] == 'V') {\n\t\t\t\t\tdec->packet_type =\n\t\t\t\t\t\tTTUSB_DEC_PACKET_PVA;\n\t\t\t\t\tdec->packet_state++;\n\t\t\t\t} else if (dec->packet[0] == 'S') {\n\t\t\t\t\tdec->packet_type =\n\t\t\t\t\t\tTTUSB_DEC_PACKET_SECTION;\n\t\t\t\t\tdec->packet_state++;\n\t\t\t\t} else if (dec->packet[0] == 0x00) {\n\t\t\t\t\tdec->packet_type =\n\t\t\t\t\t\tTTUSB_DEC_PACKET_EMPTY;\n\t\t\t\t\tdec->packet_payload_length = 2;\n\t\t\t\t\tdec->packet_state = 7;\n\t\t\t\t} else {\n\t\t\t\t\tprintk(\"%s: unknown packet type: %02x%02x\\n\",\n\t\t\t\t\t       __func__,\n\t\t\t\t\t       dec->packet[0], dec->packet[1]);\n\t\t\t\t\tdec->packet_state = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlength--;\n\t\t\tbreak;\n\n\t\tcase 5:\n\t\t\tdec->packet[dec->packet_length++] = *b++;\n\n\t\t\tif (dec->packet_type == TTUSB_DEC_PACKET_PVA &&\n\t\t\t    dec->packet_length == 8) {\n\t\t\t\tdec->packet_state++;\n\t\t\t\tdec->packet_payload_length = 8 +\n\t\t\t\t\t(dec->packet[6] << 8) +\n\t\t\t\t\tdec->packet[7];\n\t\t\t} else if (dec->packet_type ==\n\t\t\t\t\tTTUSB_DEC_PACKET_SECTION &&\n\t\t\t\t   dec->packet_length == 5) {\n\t\t\t\tdec->packet_state++;\n\t\t\t\tdec->packet_payload_length = 5 +\n\t\t\t\t\t((dec->packet[3] & 0x0f) << 8) +\n\t\t\t\t\tdec->packet[4];\n\t\t\t}\n\n\t\t\tlength--;\n\t\t\tbreak;\n\n\t\tcase 6: {\n\t\t\tint remainder = dec->packet_payload_length -\n\t\t\t\t\tdec->packet_length;\n\n\t\t\tif (length >= remainder) {\n\t\t\t\tmemcpy(dec->packet + dec->packet_length,\n\t\t\t\t       b, remainder);\n\t\t\t\tdec->packet_length += remainder;\n\t\t\t\tb += remainder;\n\t\t\t\tlength -= remainder;\n\t\t\t\tdec->packet_state++;\n\t\t\t} else {\n\t\t\t\tmemcpy(&dec->packet[dec->packet_length],\n\t\t\t\t       b, length);\n\t\t\t\tdec->packet_length += length;\n\t\t\t\tlength = 0;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 7: {\n\t\t\tint tail = 4;\n\n\t\t\tdec->packet[dec->packet_length++] = *b++;\n\n\t\t\tif (dec->packet_type == TTUSB_DEC_PACKET_SECTION &&\n\t\t\t    dec->packet_payload_length % 2)\n\t\t\t\ttail++;\n\n\t\t\tif (dec->packet_length ==\n\t\t\t    dec->packet_payload_length + tail) {\n\t\t\t\tttusb_dec_process_packet(dec);\n\t\t\t\tdec->packet_state = 0;\n\t\t\t}\n\n\t\t\tlength--;\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tprintk(\"%s: illegal packet state encountered.\\n\",\n\t\t\t       __func__);\n\t\t\tdec->packet_state = 0;\n\t\t}\n\t}\n}\n\nstatic void ttusb_dec_process_urb_frame_list(struct tasklet_struct *t)\n{\n\tstruct ttusb_dec *dec = from_tasklet(dec, t, urb_tasklet);\n\tstruct list_head *item;\n\tstruct urb_frame *frame;\n\tunsigned long flags;\n\n\twhile (1) {\n\t\tspin_lock_irqsave(&dec->urb_frame_list_lock, flags);\n\t\tif ((item = dec->urb_frame_list.next) != &dec->urb_frame_list) {\n\t\t\tframe = list_entry(item, struct urb_frame,\n\t\t\t\t\t   urb_frame_list);\n\t\t\tlist_del(&frame->urb_frame_list);\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&dec->urb_frame_list_lock,\n\t\t\t\t\t       flags);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_irqrestore(&dec->urb_frame_list_lock, flags);\n\n\t\tttusb_dec_process_urb_frame(dec, frame->data, frame->length);\n\t\tkfree(frame);\n\t}\n}\n\nstatic void ttusb_dec_process_urb(struct urb *urb)\n{\n\tstruct ttusb_dec *dec = urb->context;\n\n\tif (!urb->status) {\n\t\tint i;\n\n\t\tfor (i = 0; i < FRAMES_PER_ISO_BUF; i++) {\n\t\t\tstruct usb_iso_packet_descriptor *d;\n\t\t\tu8 *b;\n\t\t\tint length;\n\t\t\tstruct urb_frame *frame;\n\n\t\t\td = &urb->iso_frame_desc[i];\n\t\t\tb = urb->transfer_buffer + d->offset;\n\t\t\tlength = d->actual_length;\n\n\t\t\tif ((frame = kmalloc(sizeof(struct urb_frame),\n\t\t\t\t\t     GFP_ATOMIC))) {\n\t\t\t\tunsigned long flags;\n\n\t\t\t\tmemcpy(frame->data, b, length);\n\t\t\t\tframe->length = length;\n\n\t\t\t\tspin_lock_irqsave(&dec->urb_frame_list_lock,\n\t\t\t\t\t\t     flags);\n\t\t\t\tlist_add_tail(&frame->urb_frame_list,\n\t\t\t\t\t      &dec->urb_frame_list);\n\t\t\t\tspin_unlock_irqrestore(&dec->urb_frame_list_lock,\n\t\t\t\t\t\t       flags);\n\n\t\t\t\ttasklet_schedule(&dec->urb_tasklet);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t  \n\t\tif (urb->status != -ENOENT)\n\t\t\tdprintk(\"%s: urb error: %d\\n\", __func__,\n\t\t\t\turb->status);\n\t}\n\n\tif (dec->iso_stream_count)\n\t\tusb_submit_urb(urb, GFP_ATOMIC);\n}\n\nstatic void ttusb_dec_setup_urbs(struct ttusb_dec *dec)\n{\n\tint i, j, buffer_offset = 0;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tfor (i = 0; i < ISO_BUF_COUNT; i++) {\n\t\tint frame_offset = 0;\n\t\tstruct urb *urb = dec->iso_urb[i];\n\n\t\turb->dev = dec->udev;\n\t\turb->context = dec;\n\t\turb->complete = ttusb_dec_process_urb;\n\t\turb->pipe = dec->in_pipe;\n\t\turb->transfer_flags = URB_ISO_ASAP;\n\t\turb->interval = 1;\n\t\turb->number_of_packets = FRAMES_PER_ISO_BUF;\n\t\turb->transfer_buffer_length = ISO_FRAME_SIZE *\n\t\t\t\t\t      FRAMES_PER_ISO_BUF;\n\t\turb->transfer_buffer = dec->iso_buffer + buffer_offset;\n\t\tbuffer_offset += ISO_FRAME_SIZE * FRAMES_PER_ISO_BUF;\n\n\t\tfor (j = 0; j < FRAMES_PER_ISO_BUF; j++) {\n\t\t\turb->iso_frame_desc[j].offset = frame_offset;\n\t\t\turb->iso_frame_desc[j].length = ISO_FRAME_SIZE;\n\t\t\tframe_offset += ISO_FRAME_SIZE;\n\t\t}\n\t}\n}\n\nstatic void ttusb_dec_stop_iso_xfer(struct ttusb_dec *dec)\n{\n\tint i;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (mutex_lock_interruptible(&dec->iso_mutex))\n\t\treturn;\n\n\tdec->iso_stream_count--;\n\n\tif (!dec->iso_stream_count) {\n\t\tfor (i = 0; i < ISO_BUF_COUNT; i++)\n\t\t\tusb_kill_urb(dec->iso_urb[i]);\n\t}\n\n\tmutex_unlock(&dec->iso_mutex);\n}\n\n \nstatic int ttusb_dec_set_interface(struct ttusb_dec *dec,\n\t\t\t\t   enum ttusb_dec_interface interface)\n{\n\tint result = 0;\n\tu8 b[] = { 0x05 };\n\n\tif (interface != dec->interface) {\n\t\tswitch (interface) {\n\t\tcase TTUSB_DEC_INTERFACE_INITIAL:\n\t\t\tresult = usb_set_interface(dec->udev, 0, 0);\n\t\t\tbreak;\n\t\tcase TTUSB_DEC_INTERFACE_IN:\n\t\t\tresult = ttusb_dec_send_command(dec, 0x80, sizeof(b),\n\t\t\t\t\t\t\tb, NULL, NULL);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\t\t\tresult = usb_set_interface(dec->udev, 0, 8);\n\t\t\tbreak;\n\t\tcase TTUSB_DEC_INTERFACE_OUT:\n\t\t\tresult = usb_set_interface(dec->udev, 0, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tdec->interface = interface;\n\t}\n\n\treturn 0;\n}\n\nstatic int ttusb_dec_start_iso_xfer(struct ttusb_dec *dec)\n{\n\tint i, result;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (mutex_lock_interruptible(&dec->iso_mutex))\n\t\treturn -EAGAIN;\n\n\tif (!dec->iso_stream_count) {\n\t\tttusb_dec_setup_urbs(dec);\n\n\t\tdec->packet_state = 0;\n\t\tdec->v_pes_postbytes = 0;\n\t\tdec->next_packet_id = 0;\n\n\t\tfor (i = 0; i < ISO_BUF_COUNT; i++) {\n\t\t\tif ((result = usb_submit_urb(dec->iso_urb[i],\n\t\t\t\t\t\t     GFP_ATOMIC))) {\n\t\t\t\tprintk(\"%s: failed urb submission %d: error %d\\n\",\n\t\t\t\t       __func__, i, result);\n\n\t\t\t\twhile (i) {\n\t\t\t\t\tusb_kill_urb(dec->iso_urb[i - 1]);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\n\t\t\t\tmutex_unlock(&dec->iso_mutex);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\n\tdec->iso_stream_count++;\n\n\tmutex_unlock(&dec->iso_mutex);\n\n\treturn 0;\n}\n\nstatic int ttusb_dec_start_ts_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\n\tstruct ttusb_dec *dec = dvbdmx->priv;\n\tu8 b0[] = { 0x05 };\n\tint result = 0;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tdprintk(\"  ts_type:\");\n\n\tif (dvbdmxfeed->ts_type & TS_DECODER)\n\t\tdprintk(\" TS_DECODER\");\n\n\tif (dvbdmxfeed->ts_type & TS_PACKET)\n\t\tdprintk(\" TS_PACKET\");\n\n\tif (dvbdmxfeed->ts_type & TS_PAYLOAD_ONLY)\n\t\tdprintk(\" TS_PAYLOAD_ONLY\");\n\n\tdprintk(\"\\n\");\n\n\tswitch (dvbdmxfeed->pes_type) {\n\n\tcase DMX_PES_VIDEO:\n\t\tdprintk(\"  pes_type: DMX_PES_VIDEO\\n\");\n\t\tdec->pid[DMX_PES_PCR] = dvbdmxfeed->pid;\n\t\tdec->pid[DMX_PES_VIDEO] = dvbdmxfeed->pid;\n\t\tdec->video_filter = dvbdmxfeed->filter;\n\t\tttusb_dec_set_pids(dec);\n\t\tbreak;\n\n\tcase DMX_PES_AUDIO:\n\t\tdprintk(\"  pes_type: DMX_PES_AUDIO\\n\");\n\t\tdec->pid[DMX_PES_AUDIO] = dvbdmxfeed->pid;\n\t\tdec->audio_filter = dvbdmxfeed->filter;\n\t\tttusb_dec_set_pids(dec);\n\t\tbreak;\n\n\tcase DMX_PES_TELETEXT:\n\t\tdec->pid[DMX_PES_TELETEXT] = dvbdmxfeed->pid;\n\t\tdprintk(\"  pes_type: DMX_PES_TELETEXT(not supported)\\n\");\n\t\treturn -ENOSYS;\n\n\tcase DMX_PES_PCR:\n\t\tdprintk(\"  pes_type: DMX_PES_PCR\\n\");\n\t\tdec->pid[DMX_PES_PCR] = dvbdmxfeed->pid;\n\t\tttusb_dec_set_pids(dec);\n\t\tbreak;\n\n\tcase DMX_PES_OTHER:\n\t\tdprintk(\"  pes_type: DMX_PES_OTHER(not supported)\\n\");\n\t\treturn -ENOSYS;\n\n\tdefault:\n\t\tdprintk(\"  pes_type: unknown (%d)\\n\", dvbdmxfeed->pes_type);\n\t\treturn -EINVAL;\n\n\t}\n\n\tresult = ttusb_dec_send_command(dec, 0x80, sizeof(b0), b0, NULL, NULL);\n\tif (result)\n\t\treturn result;\n\n\tdec->pva_stream_count++;\n\treturn ttusb_dec_start_iso_xfer(dec);\n}\n\nstatic int ttusb_dec_start_sec_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct ttusb_dec *dec = dvbdmxfeed->demux->priv;\n\tu8 b0[] = { 0x00, 0x00, 0x00, 0x01,\n\t\t    0x00, 0x00, 0x00, 0x00,\n\t\t    0x00, 0x00, 0x00, 0x00,\n\t\t    0x00, 0x00, 0x00, 0x00,\n\t\t    0x00, 0xff, 0x00, 0x00,\n\t\t    0x00, 0x00, 0x00, 0x00,\n\t\t    0x00, 0x00, 0x00, 0x00,\n\t\t    0x00 };\n\t__be16 pid;\n\tu8 c[COMMAND_PACKET_SIZE];\n\tint c_length;\n\tint result;\n\tstruct filter_info *finfo;\n\tunsigned long flags;\n\tu8 x = 1;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tpid = htons(dvbdmxfeed->pid);\n\tmemcpy(&b0[0], &pid, 2);\n\tmemcpy(&b0[4], &x, 1);\n\tmemcpy(&b0[5], &dvbdmxfeed->filter->filter.filter_value[0], 1);\n\n\tresult = ttusb_dec_send_command(dec, 0x60, sizeof(b0), b0,\n\t\t\t\t\t&c_length, c);\n\n\tif (!result) {\n\t\tif (c_length == 2) {\n\t\t\tif (!(finfo = kmalloc(sizeof(struct filter_info),\n\t\t\t\t\t      GFP_ATOMIC)))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tfinfo->stream_id = c[1];\n\t\t\tfinfo->filter = dvbdmxfeed->filter;\n\n\t\t\tspin_lock_irqsave(&dec->filter_info_list_lock, flags);\n\t\t\tlist_add_tail(&finfo->filter_info_list,\n\t\t\t\t      &dec->filter_info_list);\n\t\t\tspin_unlock_irqrestore(&dec->filter_info_list_lock,\n\t\t\t\t\t       flags);\n\n\t\t\tdvbdmxfeed->priv = finfo;\n\n\t\t\tdec->filter_stream_count++;\n\t\t\treturn ttusb_dec_start_iso_xfer(dec);\n\t\t}\n\n\t\treturn -EAGAIN;\n\t} else\n\t\treturn result;\n}\n\nstatic int ttusb_dec_start_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (!dvbdmx->dmx.frontend)\n\t\treturn -EINVAL;\n\n\tdprintk(\"  pid: 0x%04X\\n\", dvbdmxfeed->pid);\n\n\tswitch (dvbdmxfeed->type) {\n\n\tcase DMX_TYPE_TS:\n\t\treturn ttusb_dec_start_ts_feed(dvbdmxfeed);\n\n\tcase DMX_TYPE_SEC:\n\t\treturn ttusb_dec_start_sec_feed(dvbdmxfeed);\n\n\tdefault:\n\t\tdprintk(\"  type: unknown (%d)\\n\", dvbdmxfeed->type);\n\t\treturn -EINVAL;\n\n\t}\n}\n\nstatic int ttusb_dec_stop_ts_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct ttusb_dec *dec = dvbdmxfeed->demux->priv;\n\tu8 b0[] = { 0x00 };\n\n\tttusb_dec_send_command(dec, 0x81, sizeof(b0), b0, NULL, NULL);\n\n\tdec->pva_stream_count--;\n\n\tttusb_dec_stop_iso_xfer(dec);\n\n\treturn 0;\n}\n\nstatic int ttusb_dec_stop_sec_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct ttusb_dec *dec = dvbdmxfeed->demux->priv;\n\tu8 b0[] = { 0x00, 0x00 };\n\tstruct filter_info *finfo = dvbdmxfeed->priv;\n\tunsigned long flags;\n\n\tb0[1] = finfo->stream_id;\n\tspin_lock_irqsave(&dec->filter_info_list_lock, flags);\n\tlist_del(&finfo->filter_info_list);\n\tspin_unlock_irqrestore(&dec->filter_info_list_lock, flags);\n\tkfree(finfo);\n\tttusb_dec_send_command(dec, 0x62, sizeof(b0), b0, NULL, NULL);\n\n\tdec->filter_stream_count--;\n\n\tttusb_dec_stop_iso_xfer(dec);\n\n\treturn 0;\n}\n\nstatic int ttusb_dec_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tdprintk(\"%s\\n\", __func__);\n\n\tswitch (dvbdmxfeed->type) {\n\tcase DMX_TYPE_TS:\n\t\treturn ttusb_dec_stop_ts_feed(dvbdmxfeed);\n\n\tcase DMX_TYPE_SEC:\n\t\treturn ttusb_dec_stop_sec_feed(dvbdmxfeed);\n\t}\n\n\treturn 0;\n}\n\nstatic void ttusb_dec_free_iso_urbs(struct ttusb_dec *dec)\n{\n\tint i;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tfor (i = 0; i < ISO_BUF_COUNT; i++)\n\t\tusb_free_urb(dec->iso_urb[i]);\n\tkfree(dec->iso_buffer);\n}\n\nstatic int ttusb_dec_alloc_iso_urbs(struct ttusb_dec *dec)\n{\n\tint i;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tdec->iso_buffer = kcalloc(FRAMES_PER_ISO_BUF * ISO_BUF_COUNT,\n\t\t\tISO_FRAME_SIZE, GFP_KERNEL);\n\tif (!dec->iso_buffer)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ISO_BUF_COUNT; i++) {\n\t\tstruct urb *urb;\n\n\t\tif (!(urb = usb_alloc_urb(FRAMES_PER_ISO_BUF, GFP_ATOMIC))) {\n\t\t\tttusb_dec_free_iso_urbs(dec);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdec->iso_urb[i] = urb;\n\t}\n\n\tttusb_dec_setup_urbs(dec);\n\n\treturn 0;\n}\n\nstatic void ttusb_dec_init_tasklet(struct ttusb_dec *dec)\n{\n\tspin_lock_init(&dec->urb_frame_list_lock);\n\tINIT_LIST_HEAD(&dec->urb_frame_list);\n\ttasklet_setup(&dec->urb_tasklet, ttusb_dec_process_urb_frame_list);\n}\n\nstatic int ttusb_init_rc( struct ttusb_dec *dec)\n{\n\tstruct input_dev *input_dev;\n\tu8 b[] = { 0x00, 0x01 };\n\tint i;\n\tint err;\n\n\tusb_make_path(dec->udev, dec->rc_phys, sizeof(dec->rc_phys));\n\tstrlcat(dec->rc_phys, \"/input0\", sizeof(dec->rc_phys));\n\n\tinput_dev = input_allocate_device();\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tinput_dev->name = \"ttusb_dec remote control\";\n\tinput_dev->phys = dec->rc_phys;\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY);\n\tinput_dev->keycodesize = sizeof(u16);\n\tinput_dev->keycodemax = 0x1a;\n\tinput_dev->keycode = rc_keys;\n\n\tfor (i = 0; i < ARRAY_SIZE(rc_keys); i++)\n\t\t  set_bit(rc_keys[i], input_dev->keybit);\n\n\terr = input_register_device(input_dev);\n\tif (err) {\n\t\tinput_free_device(input_dev);\n\t\treturn err;\n\t}\n\n\tdec->rc_input_dev = input_dev;\n\tif (usb_submit_urb(dec->irq_urb, GFP_KERNEL))\n\t\tprintk(\"%s: usb_submit_urb failed\\n\",__func__);\n\t \n\tttusb_dec_send_command(dec,0xb0,sizeof(b),b,NULL,NULL);\n\n\treturn 0;\n}\n\nstatic void ttusb_dec_init_v_pes(struct ttusb_dec *dec)\n{\n\tdprintk(\"%s\\n\", __func__);\n\n\tdec->v_pes[0] = 0x00;\n\tdec->v_pes[1] = 0x00;\n\tdec->v_pes[2] = 0x01;\n\tdec->v_pes[3] = 0xe0;\n}\n\nstatic int ttusb_dec_init_usb(struct ttusb_dec *dec)\n{\n\tint result;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tmutex_init(&dec->usb_mutex);\n\tmutex_init(&dec->iso_mutex);\n\n\tdec->command_pipe = usb_sndbulkpipe(dec->udev, COMMAND_PIPE);\n\tdec->result_pipe = usb_rcvbulkpipe(dec->udev, RESULT_PIPE);\n\tdec->in_pipe = usb_rcvisocpipe(dec->udev, IN_PIPE);\n\tdec->out_pipe = usb_sndisocpipe(dec->udev, OUT_PIPE);\n\tdec->irq_pipe = usb_rcvintpipe(dec->udev, IRQ_PIPE);\n\n\tif(enable_rc) {\n\t\tdec->irq_urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif(!dec->irq_urb) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdec->irq_buffer = usb_alloc_coherent(dec->udev,IRQ_PACKET_SIZE,\n\t\t\t\t\tGFP_KERNEL, &dec->irq_dma_handle);\n\t\tif(!dec->irq_buffer) {\n\t\t\tusb_free_urb(dec->irq_urb);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tusb_fill_int_urb(dec->irq_urb, dec->udev,dec->irq_pipe,\n\t\t\t\t dec->irq_buffer, IRQ_PACKET_SIZE,\n\t\t\t\t ttusb_dec_handle_irq, dec, 1);\n\t\tdec->irq_urb->transfer_dma = dec->irq_dma_handle;\n\t\tdec->irq_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t}\n\n\tresult = ttusb_dec_alloc_iso_urbs(dec);\n\tif (result) {\n\t\tusb_free_urb(dec->irq_urb);\n\t\tusb_free_coherent(dec->udev, IRQ_PACKET_SIZE,\n\t\t\t\t  dec->irq_buffer, dec->irq_dma_handle);\n\t}\n\treturn result;\n}\n\nstatic int ttusb_dec_boot_dsp(struct ttusb_dec *dec)\n{\n\tint i, j, actual_len, result, size, trans_count;\n\tu8 b0[] = { 0x00, 0x00, 0x00, 0x00,\n\t\t    0x00, 0x00, 0x00, 0x00,\n\t\t    0x61, 0x00 };\n\tu8 b1[] = { 0x61 };\n\tu8 *b;\n\tchar idstring[21];\n\tconst u8 *firmware = NULL;\n\tsize_t firmware_size = 0;\n\tu16 firmware_csum = 0;\n\t__be16 firmware_csum_ns;\n\t__be32 firmware_size_nl;\n\tu32 crc32_csum, crc32_check;\n\t__be32 tmp;\n\tconst struct firmware *fw_entry = NULL;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tresult = request_firmware(&fw_entry, dec->firmware_name, &dec->udev->dev);\n\tif (result) {\n\t\tprintk(KERN_ERR \"%s: Firmware (%s) unavailable.\\n\",\n\t\t       __func__, dec->firmware_name);\n\t\treturn result;\n\t}\n\n\tfirmware = fw_entry->data;\n\tfirmware_size = fw_entry->size;\n\n\tif (firmware_size < 60) {\n\t\tprintk(\"%s: firmware size too small for DSP code (%zu < 60).\\n\",\n\t\t\t__func__, firmware_size);\n\t\trelease_firmware(fw_entry);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tcrc32_csum = crc32(~0L, firmware, 56) ^ ~0L;\n\tmemcpy(&tmp, &firmware[56], 4);\n\tcrc32_check = ntohl(tmp);\n\tif (crc32_csum != crc32_check) {\n\t\tprintk(\"%s: crc32 check of DSP code failed (calculated 0x%08x != 0x%08x in file), file invalid.\\n\",\n\t\t\t__func__, crc32_csum, crc32_check);\n\t\trelease_firmware(fw_entry);\n\t\treturn -ENOENT;\n\t}\n\tmemcpy(idstring, &firmware[36], 20);\n\tidstring[20] = '\\0';\n\tprintk(KERN_INFO \"ttusb_dec: found DSP code \\\"%s\\\".\\n\", idstring);\n\n\tfirmware_size_nl = htonl(firmware_size);\n\tmemcpy(b0, &firmware_size_nl, 4);\n\tfirmware_csum = crc16(~0, firmware, firmware_size) ^ ~0;\n\tfirmware_csum_ns = htons(firmware_csum);\n\tmemcpy(&b0[6], &firmware_csum_ns, 2);\n\n\tresult = ttusb_dec_send_command(dec, 0x41, sizeof(b0), b0, NULL, NULL);\n\n\tif (result) {\n\t\trelease_firmware(fw_entry);\n\t\treturn result;\n\t}\n\n\ttrans_count = 0;\n\tj = 0;\n\n\tb = kmalloc(ARM_PACKET_SIZE, GFP_KERNEL);\n\tif (b == NULL) {\n\t\trelease_firmware(fw_entry);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < firmware_size; i += COMMAND_PACKET_SIZE) {\n\t\tsize = firmware_size - i;\n\t\tif (size > COMMAND_PACKET_SIZE)\n\t\t\tsize = COMMAND_PACKET_SIZE;\n\n\t\tb[j + 0] = 0xaa;\n\t\tb[j + 1] = trans_count++;\n\t\tb[j + 2] = 0xf0;\n\t\tb[j + 3] = size;\n\t\tmemcpy(&b[j + 4], &firmware[i], size);\n\n\t\tj += COMMAND_PACKET_SIZE + 4;\n\n\t\tif (j >= ARM_PACKET_SIZE) {\n\t\t\tresult = usb_bulk_msg(dec->udev, dec->command_pipe, b,\n\t\t\t\t\t      ARM_PACKET_SIZE, &actual_len,\n\t\t\t\t\t      100);\n\t\t\tj = 0;\n\t\t} else if (size < COMMAND_PACKET_SIZE) {\n\t\t\tresult = usb_bulk_msg(dec->udev, dec->command_pipe, b,\n\t\t\t\t\t      j - COMMAND_PACKET_SIZE + size,\n\t\t\t\t\t      &actual_len, 100);\n\t\t}\n\t}\n\n\tresult = ttusb_dec_send_command(dec, 0x43, sizeof(b1), b1, NULL, NULL);\n\n\trelease_firmware(fw_entry);\n\tkfree(b);\n\n\treturn result;\n}\n\nstatic int ttusb_dec_init_stb(struct ttusb_dec *dec)\n{\n\tint result;\n\tunsigned int mode = 0, model = 0, version = 0;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tresult = ttusb_dec_get_stb_state(dec, &mode, &model, &version);\n\tif (result)\n\t\treturn result;\n\n\tif (!mode) {\n\t\tif (version == 0xABCDEFAB)\n\t\t\tprintk(KERN_INFO \"ttusb_dec: no version info in Firmware\\n\");\n\t\telse\n\t\t\tprintk(KERN_INFO \"ttusb_dec: Firmware %x.%02x%c%c\\n\",\n\t\t\t       version >> 24, (version >> 16) & 0xff,\n\t\t\t       (version >> 8) & 0xff, version & 0xff);\n\n\t\tresult = ttusb_dec_boot_dsp(dec);\n\t\tif (result)\n\t\t\treturn result;\n\t} else {\n\t\t \n\t\tswitch (model) {\n\t\tcase 0x00070001:\n\t\tcase 0x00070008:\n\t\tcase 0x0007000c:\n\t\t\tttusb_dec_set_model(dec, TTUSB_DEC3000S);\n\t\t\tbreak;\n\t\tcase 0x00070009:\n\t\tcase 0x00070013:\n\t\t\tttusb_dec_set_model(dec, TTUSB_DEC2000T);\n\t\t\tbreak;\n\t\tcase 0x00070011:\n\t\t\tttusb_dec_set_model(dec, TTUSB_DEC2540T);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unknown model returned by firmware (%08x) - please report\\n\",\n\t\t\t       __func__, model);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif (version >= 0x01770000)\n\t\t\tdec->can_playback = 1;\n\t}\n\treturn 0;\n}\n\nstatic int ttusb_dec_init_dvb(struct ttusb_dec *dec)\n{\n\tint result;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif ((result = dvb_register_adapter(&dec->adapter,\n\t\t\t\t\t   dec->model_name, THIS_MODULE,\n\t\t\t\t\t   &dec->udev->dev,\n\t\t\t\t\t   adapter_nr)) < 0) {\n\t\tprintk(\"%s: dvb_register_adapter failed: error %d\\n\",\n\t\t       __func__, result);\n\n\t\treturn result;\n\t}\n\n\tdec->demux.dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING;\n\n\tdec->demux.priv = (void *)dec;\n\tdec->demux.filternum = 31;\n\tdec->demux.feednum = 31;\n\tdec->demux.start_feed = ttusb_dec_start_feed;\n\tdec->demux.stop_feed = ttusb_dec_stop_feed;\n\tdec->demux.write_to_decoder = NULL;\n\n\tif ((result = dvb_dmx_init(&dec->demux)) < 0) {\n\t\tprintk(\"%s: dvb_dmx_init failed: error %d\\n\", __func__,\n\t\t       result);\n\n\t\tdvb_unregister_adapter(&dec->adapter);\n\n\t\treturn result;\n\t}\n\n\tdec->dmxdev.filternum = 32;\n\tdec->dmxdev.demux = &dec->demux.dmx;\n\tdec->dmxdev.capabilities = 0;\n\n\tif ((result = dvb_dmxdev_init(&dec->dmxdev, &dec->adapter)) < 0) {\n\t\tprintk(\"%s: dvb_dmxdev_init failed: error %d\\n\",\n\t\t       __func__, result);\n\n\t\tdvb_dmx_release(&dec->demux);\n\t\tdvb_unregister_adapter(&dec->adapter);\n\n\t\treturn result;\n\t}\n\n\tdec->frontend.source = DMX_FRONTEND_0;\n\n\tif ((result = dec->demux.dmx.add_frontend(&dec->demux.dmx,\n\t\t\t\t\t\t  &dec->frontend)) < 0) {\n\t\tprintk(\"%s: dvb_dmx_init failed: error %d\\n\", __func__,\n\t\t       result);\n\n\t\tdvb_dmxdev_release(&dec->dmxdev);\n\t\tdvb_dmx_release(&dec->demux);\n\t\tdvb_unregister_adapter(&dec->adapter);\n\n\t\treturn result;\n\t}\n\n\tif ((result = dec->demux.dmx.connect_frontend(&dec->demux.dmx,\n\t\t\t\t\t\t      &dec->frontend)) < 0) {\n\t\tprintk(\"%s: dvb_dmx_init failed: error %d\\n\", __func__,\n\t\t       result);\n\n\t\tdec->demux.dmx.remove_frontend(&dec->demux.dmx, &dec->frontend);\n\t\tdvb_dmxdev_release(&dec->dmxdev);\n\t\tdvb_dmx_release(&dec->demux);\n\t\tdvb_unregister_adapter(&dec->adapter);\n\n\t\treturn result;\n\t}\n\n\tdvb_net_init(&dec->adapter, &dec->dvb_net, &dec->demux.dmx);\n\n\treturn 0;\n}\n\nstatic void ttusb_dec_exit_dvb(struct ttusb_dec *dec)\n{\n\tdprintk(\"%s\\n\", __func__);\n\n\tdvb_net_release(&dec->dvb_net);\n\tdec->demux.dmx.close(&dec->demux.dmx);\n\tdec->demux.dmx.remove_frontend(&dec->demux.dmx, &dec->frontend);\n\tdvb_dmxdev_release(&dec->dmxdev);\n\tdvb_dmx_release(&dec->demux);\n\tif (dec->fe) {\n\t\tdvb_unregister_frontend(dec->fe);\n\t\tdvb_frontend_detach(dec->fe);\n\t}\n\tdvb_unregister_adapter(&dec->adapter);\n}\n\nstatic void ttusb_dec_exit_rc(struct ttusb_dec *dec)\n{\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (dec->rc_input_dev) {\n\t\tinput_unregister_device(dec->rc_input_dev);\n\t\tdec->rc_input_dev = NULL;\n\t}\n}\n\n\nstatic void ttusb_dec_exit_usb(struct ttusb_dec *dec)\n{\n\tint i;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (enable_rc) {\n\t\t \n\t\tif (dec->interface == TTUSB_DEC_INTERFACE_IN)\n\t\t\tusb_kill_urb(dec->irq_urb);\n\n\t\tusb_free_urb(dec->irq_urb);\n\n\t\tusb_free_coherent(dec->udev, IRQ_PACKET_SIZE,\n\t\t\t\t  dec->irq_buffer, dec->irq_dma_handle);\n\t}\n\n\tdec->iso_stream_count = 0;\n\n\tfor (i = 0; i < ISO_BUF_COUNT; i++)\n\t\tusb_kill_urb(dec->iso_urb[i]);\n\n\tttusb_dec_free_iso_urbs(dec);\n}\n\nstatic void ttusb_dec_exit_tasklet(struct ttusb_dec *dec)\n{\n\tstruct list_head *item;\n\tstruct urb_frame *frame;\n\n\ttasklet_kill(&dec->urb_tasklet);\n\n\twhile ((item = dec->urb_frame_list.next) != &dec->urb_frame_list) {\n\t\tframe = list_entry(item, struct urb_frame, urb_frame_list);\n\t\tlist_del(&frame->urb_frame_list);\n\t\tkfree(frame);\n\t}\n}\n\nstatic void ttusb_dec_init_filters(struct ttusb_dec *dec)\n{\n\tINIT_LIST_HEAD(&dec->filter_info_list);\n\tspin_lock_init(&dec->filter_info_list_lock);\n}\n\nstatic void ttusb_dec_exit_filters(struct ttusb_dec *dec)\n{\n\tstruct list_head *item;\n\tstruct filter_info *finfo;\n\n\twhile ((item = dec->filter_info_list.next) != &dec->filter_info_list) {\n\t\tfinfo = list_entry(item, struct filter_info, filter_info_list);\n\t\tlist_del(&finfo->filter_info_list);\n\t\tkfree(finfo);\n\t}\n}\n\nstatic int fe_send_command(struct dvb_frontend* fe, const u8 command,\n\t\t\t   int param_length, const u8 params[],\n\t\t\t   int *result_length, u8 cmd_result[])\n{\n\tstruct ttusb_dec* dec = fe->dvb->priv;\n\treturn ttusb_dec_send_command(dec, command, param_length, params, result_length, cmd_result);\n}\n\nstatic const struct ttusbdecfe_config fe_config = {\n\t.send_command = fe_send_command\n};\n\nstatic int ttusb_dec_probe(struct usb_interface *intf,\n\t\t\t   const struct usb_device_id *id)\n{\n\tstruct usb_device *udev;\n\tstruct ttusb_dec *dec;\n\tint result;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tudev = interface_to_usbdev(intf);\n\n\tif (!(dec = kzalloc(sizeof(struct ttusb_dec), GFP_KERNEL))) {\n\t\tprintk(\"%s: couldn't allocate memory.\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tusb_set_intfdata(intf, (void *)dec);\n\n\tswitch (id->idProduct) {\n\tcase 0x1006:\n\t\tttusb_dec_set_model(dec, TTUSB_DEC3000S);\n\t\tbreak;\n\n\tcase 0x1008:\n\t\tttusb_dec_set_model(dec, TTUSB_DEC2000T);\n\t\tbreak;\n\n\tcase 0x1009:\n\t\tttusb_dec_set_model(dec, TTUSB_DEC2540T);\n\t\tbreak;\n\t}\n\n\tdec->udev = udev;\n\n\tresult = ttusb_dec_init_usb(dec);\n\tif (result)\n\t\tgoto err_usb;\n\tresult = ttusb_dec_init_stb(dec);\n\tif (result)\n\t\tgoto err_stb;\n\tresult = ttusb_dec_init_dvb(dec);\n\tif (result)\n\t\tgoto err_stb;\n\n\tdec->adapter.priv = dec;\n\tswitch (id->idProduct) {\n\tcase 0x1006:\n\t\tdec->fe = ttusbdecfe_dvbs_attach(&fe_config);\n\t\tbreak;\n\n\tcase 0x1008:\n\tcase 0x1009:\n\t\tdec->fe = ttusbdecfe_dvbt_attach(&fe_config);\n\t\tbreak;\n\t}\n\n\tif (dec->fe == NULL) {\n\t\tprintk(\"dvb-ttusb-dec: A frontend driver was not found for device [%04x:%04x]\\n\",\n\t\t       le16_to_cpu(dec->udev->descriptor.idVendor),\n\t\t       le16_to_cpu(dec->udev->descriptor.idProduct));\n\t} else {\n\t\tif (dvb_register_frontend(&dec->adapter, dec->fe)) {\n\t\t\tprintk(\"budget-ci: Frontend registration failed!\\n\");\n\t\t\tif (dec->fe->ops.release)\n\t\t\t\tdec->fe->ops.release(dec->fe);\n\t\t\tdec->fe = NULL;\n\t\t}\n\t}\n\n\tttusb_dec_init_v_pes(dec);\n\tttusb_dec_init_filters(dec);\n\tttusb_dec_init_tasklet(dec);\n\n\tdec->active = 1;\n\n\tttusb_dec_set_interface(dec, TTUSB_DEC_INTERFACE_IN);\n\n\tif (enable_rc)\n\t\tttusb_init_rc(dec);\n\n\treturn 0;\nerr_stb:\n\tttusb_dec_exit_usb(dec);\nerr_usb:\n\tkfree(dec);\n\treturn result;\n}\n\nstatic void ttusb_dec_disconnect(struct usb_interface *intf)\n{\n\tstruct ttusb_dec *dec = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (dec->active) {\n\t\tttusb_dec_exit_tasklet(dec);\n\t\tttusb_dec_exit_filters(dec);\n\t\tif(enable_rc)\n\t\t\tttusb_dec_exit_rc(dec);\n\t\tttusb_dec_exit_usb(dec);\n\t\tttusb_dec_exit_dvb(dec);\n\t}\n\n\tkfree(dec);\n}\n\nstatic void ttusb_dec_set_model(struct ttusb_dec *dec,\n\t\t\t\tenum ttusb_dec_model model)\n{\n\tdec->model = model;\n\n\tswitch (model) {\n\tcase TTUSB_DEC2000T:\n\t\tdec->model_name = \"DEC2000-t\";\n\t\tdec->firmware_name = \"dvb-ttusb-dec-2000t.fw\";\n\t\tbreak;\n\n\tcase TTUSB_DEC2540T:\n\t\tdec->model_name = \"DEC2540-t\";\n\t\tdec->firmware_name = \"dvb-ttusb-dec-2540t.fw\";\n\t\tbreak;\n\n\tcase TTUSB_DEC3000S:\n\t\tdec->model_name = \"DEC3000-s\";\n\t\tdec->firmware_name = \"dvb-ttusb-dec-3000s.fw\";\n\t\tbreak;\n\t}\n}\n\nstatic const struct usb_device_id ttusb_dec_table[] = {\n\t{USB_DEVICE(0x0b48, 0x1006)},\t \n\t \n\t{USB_DEVICE(0x0b48, 0x1008)},\t \n\t{USB_DEVICE(0x0b48, 0x1009)},\t \n\t{}\n};\n\nstatic struct usb_driver ttusb_dec_driver = {\n\t.name\t\t= \"ttusb-dec\",\n\t.probe\t\t= ttusb_dec_probe,\n\t.disconnect\t= ttusb_dec_disconnect,\n\t.id_table\t= ttusb_dec_table,\n};\n\nmodule_usb_driver(ttusb_dec_driver);\n\nMODULE_AUTHOR(\"Alex Woods <linux-dvb@giblets.org>\");\nMODULE_DESCRIPTION(DRIVER_NAME);\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(usb, ttusb_dec_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}