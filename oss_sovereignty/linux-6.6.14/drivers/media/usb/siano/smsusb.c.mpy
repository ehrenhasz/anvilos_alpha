{
  "module_name": "smsusb.c",
  "hash_id": "3f5de6ae07c64bcefe854386856ae101697dde0813fd184e471acf30485a7ab4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/siano/smsusb.c",
  "human_readable_source": "\n \n\n#include \"smscoreapi.h\"\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/usb.h>\n#include <linux/firmware.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <media/media-device.h>\n\n#include \"sms-cards.h\"\n#include \"smsendian.h\"\n\n#define USB1_BUFFER_SIZE\t\t0x1000\n#define USB2_BUFFER_SIZE\t\t0x2000\n\n#define MAX_BUFFERS\t\t50\n#define MAX_URBS\t\t10\n\nstruct smsusb_device_t;\n\nenum smsusb_state {\n\tSMSUSB_DISCONNECTED,\n\tSMSUSB_SUSPENDED,\n\tSMSUSB_ACTIVE\n};\n\nstruct smsusb_urb_t {\n\tstruct list_head entry;\n\tstruct smscore_buffer_t *cb;\n\tstruct smsusb_device_t *dev;\n\n\tstruct urb urb;\n\n\t \n\tstruct work_struct wq;\n};\n\nstruct smsusb_device_t {\n\tstruct usb_device *udev;\n\tstruct smscore_device_t *coredev;\n\n\tstruct smsusb_urb_t\tsurbs[MAX_URBS];\n\n\tint\t\tresponse_alignment;\n\tint\t\tbuffer_size;\n\n\tunsigned char in_ep;\n\tunsigned char out_ep;\n\tenum smsusb_state state;\n};\n\nstatic int smsusb_submit_urb(struct smsusb_device_t *dev,\n\t\t\t     struct smsusb_urb_t *surb);\n\n \nstatic void do_submit_urb(struct work_struct *work)\n{\n\tstruct smsusb_urb_t *surb = container_of(work, struct smsusb_urb_t, wq);\n\tstruct smsusb_device_t *dev = surb->dev;\n\n\tsmsusb_submit_urb(dev, surb);\n}\n\n \nstatic void smsusb_onresponse(struct urb *urb)\n{\n\tstruct smsusb_urb_t *surb = (struct smsusb_urb_t *) urb->context;\n\tstruct smsusb_device_t *dev = surb->dev;\n\n\tif (urb->status == -ESHUTDOWN) {\n\t\tpr_err(\"error, urb status %d (-ESHUTDOWN), %d bytes\\n\",\n\t\t\turb->status, urb->actual_length);\n\t\treturn;\n\t}\n\n\tif ((urb->actual_length > 0) && (urb->status == 0)) {\n\t\tstruct sms_msg_hdr *phdr = (struct sms_msg_hdr *)surb->cb->p;\n\n\t\tsmsendian_handle_message_header(phdr);\n\t\tif (urb->actual_length >= phdr->msg_length) {\n\t\t\tsurb->cb->size = phdr->msg_length;\n\n\t\t\tif (dev->response_alignment &&\n\t\t\t    (phdr->msg_flags & MSG_HDR_FLAG_SPLIT_MSG)) {\n\n\t\t\t\tsurb->cb->offset =\n\t\t\t\t\tdev->response_alignment +\n\t\t\t\t\t((phdr->msg_flags >> 8) & 3);\n\n\t\t\t\t \n\t\t\t\tif (((int) phdr->msg_length +\n\t\t\t\t     surb->cb->offset) > urb->actual_length) {\n\t\t\t\t\tpr_err(\"invalid response msglen %d offset %d size %d\\n\",\n\t\t\t\t\t\tphdr->msg_length,\n\t\t\t\t\t\tsurb->cb->offset,\n\t\t\t\t\t\turb->actual_length);\n\t\t\t\t\tgoto exit_and_resubmit;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tmemcpy((char *) phdr + surb->cb->offset,\n\t\t\t\t       phdr, sizeof(struct sms_msg_hdr));\n\t\t\t} else\n\t\t\t\tsurb->cb->offset = 0;\n\n\t\t\tpr_debug(\"received %s(%d) size: %d\\n\",\n\t\t\t\t  smscore_translate_msg(phdr->msg_type),\n\t\t\t\t  phdr->msg_type, phdr->msg_length);\n\n\t\t\tsmsendian_handle_rx_message((struct sms_msg_data *) phdr);\n\n\t\t\tsmscore_onresponse(dev->coredev, surb->cb);\n\t\t\tsurb->cb = NULL;\n\t\t} else {\n\t\t\tpr_err(\"invalid response msglen %d actual %d\\n\",\n\t\t\t\tphdr->msg_length, urb->actual_length);\n\t\t}\n\t} else\n\t\tpr_err(\"error, urb status %d, %d bytes\\n\",\n\t\t\turb->status, urb->actual_length);\n\n\nexit_and_resubmit:\n\tINIT_WORK(&surb->wq, do_submit_urb);\n\tschedule_work(&surb->wq);\n}\n\nstatic int smsusb_submit_urb(struct smsusb_device_t *dev,\n\t\t\t     struct smsusb_urb_t *surb)\n{\n\tif (!surb->cb) {\n\t\t \n\t\tsurb->cb = smscore_getbuffer(dev->coredev);\n\t\tif (!surb->cb) {\n\t\t\tpr_err(\"smscore_getbuffer(...) returned NULL\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tusb_fill_bulk_urb(\n\t\t&surb->urb,\n\t\tdev->udev,\n\t\tusb_rcvbulkpipe(dev->udev, dev->in_ep),\n\t\tsurb->cb->p,\n\t\tdev->buffer_size,\n\t\tsmsusb_onresponse,\n\t\tsurb\n\t);\n\tsurb->urb.transfer_flags |= URB_FREE_BUFFER;\n\n\treturn usb_submit_urb(&surb->urb, GFP_ATOMIC);\n}\n\nstatic void smsusb_stop_streaming(struct smsusb_device_t *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_URBS; i++) {\n\t\tusb_kill_urb(&dev->surbs[i].urb);\n\t\tif (dev->surbs[i].wq.func)\n\t\t\tcancel_work_sync(&dev->surbs[i].wq);\n\n\t\tif (dev->surbs[i].cb) {\n\t\t\tsmscore_putbuffer(dev->coredev, dev->surbs[i].cb);\n\t\t\tdev->surbs[i].cb = NULL;\n\t\t}\n\t}\n}\n\nstatic int smsusb_start_streaming(struct smsusb_device_t *dev)\n{\n\tint i, rc;\n\n\tfor (i = 0; i < MAX_URBS; i++) {\n\t\trc = smsusb_submit_urb(dev, &dev->surbs[i]);\n\t\tif (rc < 0) {\n\t\t\tpr_err(\"smsusb_submit_urb(...) failed\\n\");\n\t\t\tsmsusb_stop_streaming(dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int smsusb_sendrequest(void *context, void *buffer, size_t size)\n{\n\tstruct smsusb_device_t *dev = (struct smsusb_device_t *) context;\n\tstruct sms_msg_hdr *phdr;\n\tint dummy, ret;\n\n\tif (dev->state != SMSUSB_ACTIVE) {\n\t\tpr_debug(\"Device not active yet\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tphdr = kmemdup(buffer, size, GFP_KERNEL);\n\tif (!phdr)\n\t\treturn -ENOMEM;\n\n\tpr_debug(\"sending %s(%d) size: %d\\n\",\n\t\t  smscore_translate_msg(phdr->msg_type), phdr->msg_type,\n\t\t  phdr->msg_length);\n\n\tsmsendian_handle_tx_message((struct sms_msg_data *) phdr);\n\tsmsendian_handle_message_header((struct sms_msg_hdr *)phdr);\n\tret = usb_bulk_msg(dev->udev, usb_sndbulkpipe(dev->udev, 2),\n\t\t\t    phdr, size, &dummy, 1000);\n\n\tkfree(phdr);\n\treturn ret;\n}\n\nstatic char *smsusb1_fw_lkup[] = {\n\t\"dvbt_stellar_usb.inp\",\n\t\"dvbh_stellar_usb.inp\",\n\t\"tdmb_stellar_usb.inp\",\n\t\"none\",\n\t\"dvbt_bda_stellar_usb.inp\",\n};\n\nstatic inline char *sms_get_fw_name(int mode, int board_id)\n{\n\tchar **fw = sms_get_board(board_id)->fw;\n\treturn (fw && fw[mode]) ? fw[mode] : smsusb1_fw_lkup[mode];\n}\n\nstatic int smsusb1_load_firmware(struct usb_device *udev, int id, int board_id)\n{\n\tconst struct firmware *fw;\n\tu8 *fw_buffer;\n\tint rc, dummy;\n\tchar *fw_filename;\n\n\tif (id < 0)\n\t\tid = sms_get_board(board_id)->default_mode;\n\n\tif (id < DEVICE_MODE_DVBT || id > DEVICE_MODE_DVBT_BDA) {\n\t\tpr_err(\"invalid firmware id specified %d\\n\", id);\n\t\treturn -EINVAL;\n\t}\n\n\tfw_filename = sms_get_fw_name(id, board_id);\n\n\trc = request_firmware(&fw, fw_filename, &udev->dev);\n\tif (rc < 0) {\n\t\tpr_warn(\"failed to open '%s' mode %d, trying again with default firmware\\n\",\n\t\t\tfw_filename, id);\n\n\t\tfw_filename = smsusb1_fw_lkup[id];\n\t\trc = request_firmware(&fw, fw_filename, &udev->dev);\n\t\tif (rc < 0) {\n\t\t\tpr_warn(\"failed to open '%s' mode %d\\n\",\n\t\t\t\t fw_filename, id);\n\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tfw_buffer = kmalloc(fw->size, GFP_KERNEL);\n\tif (fw_buffer) {\n\t\tmemcpy(fw_buffer, fw->data, fw->size);\n\n\t\trc = usb_bulk_msg(udev, usb_sndbulkpipe(udev, 2),\n\t\t\t\t  fw_buffer, fw->size, &dummy, 1000);\n\n\t\tpr_debug(\"sent %zu(%d) bytes, rc %d\\n\", fw->size, dummy, rc);\n\n\t\tkfree(fw_buffer);\n\t} else {\n\t\tpr_err(\"failed to allocate firmware buffer\\n\");\n\t\trc = -ENOMEM;\n\t}\n\tpr_debug(\"read FW %s, size=%zu\\n\", fw_filename, fw->size);\n\n\trelease_firmware(fw);\n\n\treturn rc;\n}\n\nstatic void smsusb1_detectmode(void *context, int *mode)\n{\n\tchar *product_string =\n\t\t((struct smsusb_device_t *) context)->udev->product;\n\n\t*mode = DEVICE_MODE_NONE;\n\n\tif (!product_string) {\n\t\tproduct_string = \"none\";\n\t\tpr_err(\"product string not found\\n\");\n\t} else if (strstr(product_string, \"DVBH\"))\n\t\t*mode = 1;\n\telse if (strstr(product_string, \"BDA\"))\n\t\t*mode = 4;\n\telse if (strstr(product_string, \"DVBT\"))\n\t\t*mode = 0;\n\telse if (strstr(product_string, \"TDMB\"))\n\t\t*mode = 2;\n\n\tpr_debug(\"%d \\\"%s\\\"\\n\", *mode, product_string);\n}\n\nstatic int smsusb1_setmode(void *context, int mode)\n{\n\tstruct sms_msg_hdr msg = { MSG_SW_RELOAD_REQ, 0, HIF_TASK,\n\t\t\t     sizeof(struct sms_msg_hdr), 0 };\n\n\tif (mode < DEVICE_MODE_DVBT || mode > DEVICE_MODE_DVBT_BDA) {\n\t\tpr_err(\"invalid firmware id specified %d\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\treturn smsusb_sendrequest(context, &msg, sizeof(msg));\n}\n\nstatic void smsusb_term_device(struct usb_interface *intf)\n{\n\tstruct smsusb_device_t *dev = usb_get_intfdata(intf);\n\n\tif (dev) {\n\t\tdev->state = SMSUSB_DISCONNECTED;\n\n\t\tsmsusb_stop_streaming(dev);\n\n\t\t \n\t\tif (dev->coredev)\n\t\t\tsmscore_unregister_device(dev->coredev);\n\n\t\tpr_debug(\"device 0x%p destroyed\\n\", dev);\n\t\tkfree(dev);\n\t}\n\n\tusb_set_intfdata(intf, NULL);\n}\n\nstatic void *siano_media_device_register(struct smsusb_device_t *dev,\n\t\t\t\t\tint board_id)\n{\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tstruct media_device *mdev;\n\tstruct usb_device *udev = dev->udev;\n\tstruct sms_board *board = sms_get_board(board_id);\n\tint ret;\n\n\tmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\n\tif (!mdev)\n\t\treturn NULL;\n\n\tmedia_device_usb_init(mdev, udev, board->name);\n\n\tret = media_device_register(mdev);\n\tif (ret) {\n\t\tmedia_device_cleanup(mdev);\n\t\tkfree(mdev);\n\t\treturn NULL;\n\t}\n\n\tpr_info(\"media controller created\\n\");\n\n\treturn mdev;\n#else\n\treturn NULL;\n#endif\n}\n\nstatic int smsusb_init_device(struct usb_interface *intf, int board_id)\n{\n\tstruct smsdevice_params_t params;\n\tstruct smsusb_device_t *dev;\n\tvoid *mdev;\n\tint i, rc;\n\tint align = 0;\n\n\t \n\tdev = kzalloc(sizeof(struct smsusb_device_t), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tmemset(&params, 0, sizeof(params));\n\tusb_set_intfdata(intf, dev);\n\tdev->udev = interface_to_usbdev(intf);\n\tdev->state = SMSUSB_DISCONNECTED;\n\n\tfor (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {\n\t\tstruct usb_endpoint_descriptor *desc =\n\t\t\t\t&intf->cur_altsetting->endpoint[i].desc;\n\n\t\tif (desc->bEndpointAddress & USB_DIR_IN) {\n\t\t\tdev->in_ep = desc->bEndpointAddress;\n\t\t\talign = usb_endpoint_maxp(desc) - sizeof(struct sms_msg_hdr);\n\t\t} else {\n\t\t\tdev->out_ep = desc->bEndpointAddress;\n\t\t}\n\t}\n\n\tpr_debug(\"in_ep = %02x, out_ep = %02x\\n\", dev->in_ep, dev->out_ep);\n\tif (!dev->in_ep || !dev->out_ep || align < 0) {   \n\t\tsmsusb_term_device(intf);\n\t\treturn -ENODEV;\n\t}\n\n\tparams.device_type = sms_get_board(board_id)->type;\n\n\tswitch (params.device_type) {\n\tcase SMS_STELLAR:\n\t\tdev->buffer_size = USB1_BUFFER_SIZE;\n\n\t\tparams.setmode_handler = smsusb1_setmode;\n\t\tparams.detectmode_handler = smsusb1_detectmode;\n\t\tbreak;\n\tcase SMS_UNKNOWN_TYPE:\n\t\tpr_err(\"Unspecified sms device type!\\n\");\n\t\tfallthrough;\n\tdefault:\n\t\tdev->buffer_size = USB2_BUFFER_SIZE;\n\t\tdev->response_alignment = align;\n\n\t\tparams.flags |= SMS_DEVICE_FAMILY2;\n\t\tbreak;\n\t}\n\n\tparams.device = &dev->udev->dev;\n\tparams.usb_device = dev->udev;\n\tparams.buffer_size = dev->buffer_size;\n\tparams.num_buffers = MAX_BUFFERS;\n\tparams.sendrequest_handler = smsusb_sendrequest;\n\tparams.context = dev;\n\tusb_make_path(dev->udev, params.devpath, sizeof(params.devpath));\n\n\tmdev = siano_media_device_register(dev, board_id);\n\n\t \n\trc = smscore_register_device(&params, &dev->coredev, 0, mdev);\n\tif (rc < 0) {\n\t\tpr_err(\"smscore_register_device(...) failed, rc %d\\n\", rc);\n\t\tgoto err_unregister_device;\n\t}\n\n\tsmscore_set_board_id(dev->coredev, board_id);\n\n\tdev->coredev->is_usb_device = true;\n\n\t \n\tfor (i = 0; i < MAX_URBS; i++) {\n\t\tdev->surbs[i].dev = dev;\n\t\tusb_init_urb(&dev->surbs[i].urb);\n\t}\n\n\tpr_debug(\"smsusb_start_streaming(...).\\n\");\n\trc = smsusb_start_streaming(dev);\n\tif (rc < 0) {\n\t\tpr_err(\"smsusb_start_streaming(...) failed\\n\");\n\t\tgoto err_unregister_device;\n\t}\n\n\tdev->state = SMSUSB_ACTIVE;\n\n\trc = smscore_start_device(dev->coredev);\n\tif (rc < 0) {\n\t\tpr_err(\"smscore_start_device(...) failed\\n\");\n\t\tgoto err_unregister_device;\n\t}\n\n\tpr_debug(\"device 0x%p created\\n\", dev);\n\n\treturn rc;\n\nerr_unregister_device:\n\tsmsusb_term_device(intf);\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tmedia_device_unregister(mdev);\n#endif\n\tkfree(mdev);\n\treturn rc;\n}\n\nstatic int smsusb_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tchar devpath[32];\n\tint i, rc;\n\n\tpr_info(\"board id=%lu, interface number %d\\n\",\n\t\t id->driver_info,\n\t\t intf->cur_altsetting->desc.bInterfaceNumber);\n\n\tif (sms_get_board(id->driver_info)->intf_num !=\n\t    intf->cur_altsetting->desc.bInterfaceNumber) {\n\t\tpr_debug(\"interface %d won't be used. Expecting interface %d to popup\\n\",\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber,\n\t\t\tsms_get_board(id->driver_info)->intf_num);\n\t\treturn -ENODEV;\n\t}\n\n\tif (intf->num_altsetting > 1) {\n\t\trc = usb_set_interface(udev,\n\t\t\t\t       intf->cur_altsetting->desc.bInterfaceNumber,\n\t\t\t\t       0);\n\t\tif (rc < 0) {\n\t\t\tpr_err(\"usb_set_interface failed, rc %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tpr_debug(\"smsusb_probe %d\\n\",\n\t       intf->cur_altsetting->desc.bInterfaceNumber);\n\tfor (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {\n\t\tpr_debug(\"endpoint %d %02x %02x %d\\n\", i,\n\t\t       intf->cur_altsetting->endpoint[i].desc.bEndpointAddress,\n\t\t       intf->cur_altsetting->endpoint[i].desc.bmAttributes,\n\t\t       intf->cur_altsetting->endpoint[i].desc.wMaxPacketSize);\n\t\tif (intf->cur_altsetting->endpoint[i].desc.bEndpointAddress &\n\t\t    USB_DIR_IN)\n\t\t\trc = usb_clear_halt(udev, usb_rcvbulkpipe(udev,\n\t\t\t\tintf->cur_altsetting->endpoint[i].desc.bEndpointAddress));\n\t\telse\n\t\t\trc = usb_clear_halt(udev, usb_sndbulkpipe(udev,\n\t\t\t\tintf->cur_altsetting->endpoint[i].desc.bEndpointAddress));\n\t}\n\tif ((udev->actconfig->desc.bNumInterfaces == 2) &&\n\t    (intf->cur_altsetting->desc.bInterfaceNumber == 0)) {\n\t\tpr_debug(\"rom interface 0 is not used\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (id->driver_info == SMS1XXX_BOARD_SIANO_STELLAR_ROM) {\n\t\t \n\n\t\tsnprintf(devpath, sizeof(devpath), \"usb\\\\%d-%s\",\n\t\t\t udev->bus->busnum, udev->devpath);\n\t\tpr_info(\"stellar device in cold state was found at %s.\\n\",\n\t\t\tdevpath);\n\t\trc = smsusb1_load_firmware(\n\t\t\t\tudev, smscore_registry_getmode(devpath),\n\t\t\t\tid->driver_info);\n\n\t\t \n\t\tif (!rc)\n\t\t\tpr_info(\"stellar device now in warm state\\n\");\n\t\telse\n\t\t\tpr_err(\"Failed to put stellar in warm state. Error: %d\\n\",\n\t\t\t       rc);\n\n\t\treturn rc;\n\t} else {\n\t\trc = smsusb_init_device(intf, id->driver_info);\n\t}\n\n\tpr_info(\"Device initialized with return code %d\\n\", rc);\n\tsms_board_load_modules(id->driver_info);\n\treturn rc;\n}\n\nstatic void smsusb_disconnect(struct usb_interface *intf)\n{\n\tsmsusb_term_device(intf);\n}\n\nstatic int smsusb_suspend(struct usb_interface *intf, pm_message_t msg)\n{\n\tstruct smsusb_device_t *dev = usb_get_intfdata(intf);\n\tprintk(KERN_INFO \"%s  Entering status %d.\\n\", __func__, msg.event);\n\tdev->state = SMSUSB_SUSPENDED;\n\t \n\tsmsusb_stop_streaming(dev);\n\treturn 0;\n}\n\nstatic int smsusb_resume(struct usb_interface *intf)\n{\n\tint rc, i;\n\tstruct smsusb_device_t *dev = usb_get_intfdata(intf);\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\n\tprintk(KERN_INFO \"%s  Entering.\\n\", __func__);\n\tusb_clear_halt(udev, usb_rcvbulkpipe(udev, dev->in_ep));\n\tusb_clear_halt(udev, usb_sndbulkpipe(udev, dev->out_ep));\n\n\tfor (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++)\n\t\tprintk(KERN_INFO \"endpoint %d %02x %02x %d\\n\", i,\n\t\t       intf->cur_altsetting->endpoint[i].desc.bEndpointAddress,\n\t\t       intf->cur_altsetting->endpoint[i].desc.bmAttributes,\n\t\t       intf->cur_altsetting->endpoint[i].desc.wMaxPacketSize);\n\n\tif (intf->num_altsetting > 0) {\n\t\trc = usb_set_interface(udev,\n\t\t\t\t       intf->cur_altsetting->desc.\n\t\t\t\t       bInterfaceNumber, 0);\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_INFO \"%s usb_set_interface failed, rc %d\\n\",\n\t\t\t       __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tsmsusb_start_streaming(dev);\n\treturn 0;\n}\n\nstatic const struct usb_device_id smsusb_id_table[] = {\n\t \n\t{ USB_DEVICE(0x187f, 0x0010),\n\t\t.driver_info = SMS1XXX_BOARD_SIANO_STELLAR_ROM },\n\t \n\t{ USB_DEVICE(0x187f, 0x0100),\n\t\t.driver_info = SMS1XXX_BOARD_SIANO_STELLAR },\n\n\t{ USB_DEVICE(0x187f, 0x0200),\n\t\t.driver_info = SMS1XXX_BOARD_SIANO_NOVA_A },\n\t{ USB_DEVICE(0x187f, 0x0201),\n\t\t.driver_info = SMS1XXX_BOARD_SIANO_NOVA_B },\n\t{ USB_DEVICE(0x187f, 0x0300),\n\t\t.driver_info = SMS1XXX_BOARD_SIANO_VEGA },\n\t{ USB_DEVICE(0x2040, 0x1700),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_CATAMOUNT },\n\t{ USB_DEVICE(0x2040, 0x1800),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_OKEMO_A },\n\t{ USB_DEVICE(0x2040, 0x1801),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_OKEMO_B },\n\t{ USB_DEVICE(0x2040, 0x2000),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD },\n\t{ USB_DEVICE(0x2040, 0x2009),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2 },\n\t{ USB_DEVICE(0x2040, 0x200a),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD },\n\t{ USB_DEVICE(0x2040, 0x2010),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD },\n\t{ USB_DEVICE(0x2040, 0x2011),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD },\n\t{ USB_DEVICE(0x2040, 0x2019),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD },\n\t{ USB_DEVICE(0x2040, 0x5500),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },\n\t{ USB_DEVICE(0x2040, 0x5510),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },\n\t{ USB_DEVICE(0x2040, 0x5520),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },\n\t{ USB_DEVICE(0x2040, 0x5530),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },\n\t{ USB_DEVICE(0x2040, 0x5580),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },\n\t{ USB_DEVICE(0x2040, 0x5590),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },\n\t{ USB_DEVICE(0x2040, 0xb900),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },\n\t{ USB_DEVICE(0x2040, 0xb910),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },\n\t{ USB_DEVICE(0x2040, 0xb980),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },\n\t{ USB_DEVICE(0x2040, 0xb990),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },\n\t{ USB_DEVICE(0x2040, 0xc000),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },\n\t{ USB_DEVICE(0x2040, 0xc010),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },\n\t{ USB_DEVICE(0x2040, 0xc080),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },\n\t{ USB_DEVICE(0x2040, 0xc090),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },\n\t{ USB_DEVICE(0x2040, 0xc0a0),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },\n\t{ USB_DEVICE(0x2040, 0xf5a0),\n\t\t.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },\n\t{ USB_DEVICE(0x187f, 0x0202),\n\t\t.driver_info = SMS1XXX_BOARD_SIANO_NICE },\n\t{ USB_DEVICE(0x187f, 0x0301),\n\t\t.driver_info = SMS1XXX_BOARD_SIANO_VENICE },\n\t{ USB_DEVICE(0x187f, 0x0302),\n\t\t.driver_info = SMS1XXX_BOARD_SIANO_VENICE },\n\t{ USB_DEVICE(0x187f, 0x0310),\n\t\t.driver_info = SMS1XXX_BOARD_SIANO_MING },\n\t{ USB_DEVICE(0x187f, 0x0500),\n\t\t.driver_info = SMS1XXX_BOARD_SIANO_PELE },\n\t{ USB_DEVICE(0x187f, 0x0600),\n\t\t.driver_info = SMS1XXX_BOARD_SIANO_RIO },\n\t{ USB_DEVICE(0x187f, 0x0700),\n\t\t.driver_info = SMS1XXX_BOARD_SIANO_DENVER_2160 },\n\t{ USB_DEVICE(0x187f, 0x0800),\n\t\t.driver_info = SMS1XXX_BOARD_SIANO_DENVER_1530 },\n\t{ USB_DEVICE(0x19D2, 0x0086),\n\t\t.driver_info = SMS1XXX_BOARD_ZTE_DVB_DATA_CARD },\n\t{ USB_DEVICE(0x19D2, 0x0078),\n\t\t.driver_info = SMS1XXX_BOARD_ONDA_MDTV_DATA_CARD },\n\t{ USB_DEVICE(0x3275, 0x0080),\n\t\t.driver_info = SMS1XXX_BOARD_SIANO_RIO },\n\t{ USB_DEVICE(0x2013, 0x0257),\n\t\t.driver_info = SMS1XXX_BOARD_PCTV_77E },\n\t{ }  \n\t};\n\nMODULE_DEVICE_TABLE(usb, smsusb_id_table);\n\nstatic struct usb_driver smsusb_driver = {\n\t.name\t\t\t= \"smsusb\",\n\t.probe\t\t\t= smsusb_probe,\n\t.disconnect\t\t= smsusb_disconnect,\n\t.id_table\t\t= smsusb_id_table,\n\n\t.suspend\t\t= smsusb_suspend,\n\t.resume\t\t\t= smsusb_resume,\n};\n\nmodule_usb_driver(smsusb_driver);\n\nMODULE_DESCRIPTION(\"Driver for the Siano SMS1xxx USB dongle\");\nMODULE_AUTHOR(\"Siano Mobile Silicon, INC. (uris@siano-ms.com)\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}