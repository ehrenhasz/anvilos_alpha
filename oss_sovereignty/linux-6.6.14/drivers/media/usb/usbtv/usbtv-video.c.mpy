{
  "module_name": "usbtv-video.c",
  "hash_id": "04bbb9a0713e763c5e9c17cd55f46c1ee53cc4e4168024aeb3cea1043c9192b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/usbtv/usbtv-video.c",
  "human_readable_source": " \n \n\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-v4l2.h>\n\n#include \"usbtv.h\"\n\nstatic const struct usbtv_norm_params norm_params[] = {\n\t{\n\t\t.norm = V4L2_STD_525_60,\n\t\t.cap_width = 720,\n\t\t.cap_height = 480,\n\t},\n\t{\n\t\t.norm = V4L2_STD_625_50,\n\t\t.cap_width = 720,\n\t\t.cap_height = 576,\n\t}\n};\n\nstatic int usbtv_configure_for_norm(struct usbtv *usbtv, v4l2_std_id norm)\n{\n\tint i, ret = 0;\n\tconst struct usbtv_norm_params *params = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(norm_params); i++) {\n\t\tif (norm_params[i].norm & norm) {\n\t\t\tparams = &norm_params[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (params) {\n\t\tusbtv->width = params->cap_width;\n\t\tusbtv->height = params->cap_height;\n\t\tusbtv->n_chunks = usbtv->width * usbtv->height\n\t\t\t\t\t\t/ 4 / USBTV_CHUNK;\n\t\tusbtv->norm = norm;\n\t} else\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nstatic int usbtv_select_input(struct usbtv *usbtv, int input)\n{\n\tint ret;\n\n\tstatic const u16 composite[][2] = {\n\t\t{ USBTV_BASE + 0x0105, 0x0060 },\n\t\t{ USBTV_BASE + 0x011f, 0x00f2 },\n\t\t{ USBTV_BASE + 0x0127, 0x0060 },\n\t\t{ USBTV_BASE + 0x00ae, 0x0010 },\n\t\t{ USBTV_BASE + 0x0239, 0x0060 },\n\t};\n\n\tstatic const u16 svideo[][2] = {\n\t\t{ USBTV_BASE + 0x0105, 0x0010 },\n\t\t{ USBTV_BASE + 0x011f, 0x00ff },\n\t\t{ USBTV_BASE + 0x0127, 0x0060 },\n\t\t{ USBTV_BASE + 0x00ae, 0x0030 },\n\t\t{ USBTV_BASE + 0x0239, 0x0060 },\n\t};\n\n\tswitch (input) {\n\tcase USBTV_COMPOSITE_INPUT:\n\t\tret = usbtv_set_regs(usbtv, composite, ARRAY_SIZE(composite));\n\t\tbreak;\n\tcase USBTV_SVIDEO_INPUT:\n\t\tret = usbtv_set_regs(usbtv, svideo, ARRAY_SIZE(svideo));\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (!ret)\n\t\tusbtv->input = input;\n\n\treturn ret;\n}\n\nstatic uint16_t usbtv_norm_to_16f_reg(v4l2_std_id norm)\n{\n\t \n\tif (norm & V4L2_STD_NTSC)\n\t\treturn 0x00b8;\n\t \n\tif (norm & V4L2_STD_PAL)\n\t\treturn 0x00ee;\n\t \n\tif (norm & V4L2_STD_SECAM)\n\t\treturn 0x00ff;\n\tif (norm & V4L2_STD_NTSC_443)\n\t\treturn 0x00a8;\n\tif (norm & (V4L2_STD_PAL_M | V4L2_STD_PAL_60))\n\t\treturn 0x00bc;\n\tif (norm & V4L2_STD_PAL_Nc)\n\t\treturn 0x00fe;\n\t \n\treturn 0x0000;\n}\n\nstatic int usbtv_select_norm(struct usbtv *usbtv, v4l2_std_id norm)\n{\n\tint ret;\n\t \n\tstatic const u16 pal[][2] = {\n\t\t \n\t\t{ USBTV_BASE + 0x0003, 0x0004 },\n\t\t{ USBTV_BASE + 0x001a, 0x0068 },\n\t\t{ USBTV_BASE + 0x0100, 0x00d3 },\n\t\t{ USBTV_BASE + 0x010e, 0x0072 },\n\t\t{ USBTV_BASE + 0x010f, 0x00a2 },\n\t\t{ USBTV_BASE + 0x0112, 0x00b0 },\n\t\t{ USBTV_BASE + 0x0115, 0x0015 },\n\t\t{ USBTV_BASE + 0x0117, 0x0001 },\n\t\t{ USBTV_BASE + 0x0118, 0x002c },\n\t\t{ USBTV_BASE + 0x012d, 0x0010 },\n\t\t{ USBTV_BASE + 0x012f, 0x0020 },\n\t\t{ USBTV_BASE + 0x0220, 0x002e },\n\t\t{ USBTV_BASE + 0x0225, 0x0008 },\n\t\t{ USBTV_BASE + 0x024e, 0x0002 },\n\t\t{ USBTV_BASE + 0x024f, 0x0002 },\n\t\t{ USBTV_BASE + 0x0254, 0x0059 },\n\t\t{ USBTV_BASE + 0x025a, 0x0016 },\n\t\t{ USBTV_BASE + 0x025b, 0x0035 },\n\t\t{ USBTV_BASE + 0x0263, 0x0017 },\n\t\t{ USBTV_BASE + 0x0266, 0x0016 },\n\t\t{ USBTV_BASE + 0x0267, 0x0036 },\n\t\t \n\t\t{ USBTV_BASE + 0x024e, 0x0002 },\n\t\t{ USBTV_BASE + 0x024f, 0x0002 },\n\t};\n\n\tstatic const u16 ntsc[][2] = {\n\t\t \n\t\t{ USBTV_BASE + 0x0003, 0x0004 },\n\t\t{ USBTV_BASE + 0x001a, 0x0079 },\n\t\t{ USBTV_BASE + 0x0100, 0x00d3 },\n\t\t{ USBTV_BASE + 0x010e, 0x0068 },\n\t\t{ USBTV_BASE + 0x010f, 0x009c },\n\t\t{ USBTV_BASE + 0x0112, 0x00f0 },\n\t\t{ USBTV_BASE + 0x0115, 0x0015 },\n\t\t{ USBTV_BASE + 0x0117, 0x0000 },\n\t\t{ USBTV_BASE + 0x0118, 0x00fc },\n\t\t{ USBTV_BASE + 0x012d, 0x0004 },\n\t\t{ USBTV_BASE + 0x012f, 0x0008 },\n\t\t{ USBTV_BASE + 0x0220, 0x002e },\n\t\t{ USBTV_BASE + 0x0225, 0x0008 },\n\t\t{ USBTV_BASE + 0x024e, 0x0002 },\n\t\t{ USBTV_BASE + 0x024f, 0x0001 },\n\t\t{ USBTV_BASE + 0x0254, 0x005f },\n\t\t{ USBTV_BASE + 0x025a, 0x0012 },\n\t\t{ USBTV_BASE + 0x025b, 0x0001 },\n\t\t{ USBTV_BASE + 0x0263, 0x001c },\n\t\t{ USBTV_BASE + 0x0266, 0x0011 },\n\t\t{ USBTV_BASE + 0x0267, 0x0005 },\n\t\t \n\t\t{ USBTV_BASE + 0x024e, 0x0002 },\n\t\t{ USBTV_BASE + 0x024f, 0x0002 },\n\t};\n\n\tstatic const u16 secam[][2] = {\n\t\t \n\t\t{ USBTV_BASE + 0x0003, 0x0004 },\n\t\t{ USBTV_BASE + 0x001a, 0x0073 },\n\t\t{ USBTV_BASE + 0x0100, 0x00dc },\n\t\t{ USBTV_BASE + 0x010e, 0x0072 },\n\t\t{ USBTV_BASE + 0x010f, 0x00a2 },\n\t\t{ USBTV_BASE + 0x0112, 0x0090 },\n\t\t{ USBTV_BASE + 0x0115, 0x0035 },\n\t\t{ USBTV_BASE + 0x0117, 0x0001 },\n\t\t{ USBTV_BASE + 0x0118, 0x0030 },\n\t\t{ USBTV_BASE + 0x012d, 0x0004 },\n\t\t{ USBTV_BASE + 0x012f, 0x0008 },\n\t\t{ USBTV_BASE + 0x0220, 0x002d },\n\t\t{ USBTV_BASE + 0x0225, 0x0028 },\n\t\t{ USBTV_BASE + 0x024e, 0x0008 },\n\t\t{ USBTV_BASE + 0x024f, 0x0002 },\n\t\t{ USBTV_BASE + 0x0254, 0x0069 },\n\t\t{ USBTV_BASE + 0x025a, 0x0016 },\n\t\t{ USBTV_BASE + 0x025b, 0x0035 },\n\t\t{ USBTV_BASE + 0x0263, 0x0021 },\n\t\t{ USBTV_BASE + 0x0266, 0x0016 },\n\t\t{ USBTV_BASE + 0x0267, 0x0036 },\n\t\t \n\t\t{ USBTV_BASE + 0x024e, 0x0002 },\n\t\t{ USBTV_BASE + 0x024f, 0x0002 },\n\t};\n\n\tret = usbtv_configure_for_norm(usbtv, norm);\n\n\tif (!ret) {\n\t\t \n\t\tstatic const v4l2_std_id ntsc_mask =\n\t\t\tV4L2_STD_NTSC | V4L2_STD_NTSC_443;\n\t\tstatic const v4l2_std_id pal_mask =\n\t\t\tV4L2_STD_PAL | V4L2_STD_PAL_60 | V4L2_STD_PAL_M |\n\t\t\tV4L2_STD_PAL_Nc;\n\n\t\tif (norm & ntsc_mask)\n\t\t\tret = usbtv_set_regs(usbtv, ntsc, ARRAY_SIZE(ntsc));\n\t\telse if (norm & pal_mask)\n\t\t\tret = usbtv_set_regs(usbtv, pal, ARRAY_SIZE(pal));\n\t\telse if (norm & V4L2_STD_SECAM)\n\t\t\tret = usbtv_set_regs(usbtv, secam, ARRAY_SIZE(secam));\n\t\telse\n\t\t\tret = -EINVAL;\n\t}\n\n\tif (!ret) {\n\t\t \n\t\tconst u16 cfg[][2] = {\n\t\t\t{ USBTV_BASE + 0x016f, usbtv_norm_to_16f_reg(norm) }\n\t\t};\n\t\tret = usbtv_set_regs(usbtv, cfg, ARRAY_SIZE(cfg));\n\t}\n\n\treturn ret;\n}\n\nstatic int usbtv_setup_capture(struct usbtv *usbtv)\n{\n\tint ret;\n\tstatic const u16 setup[][2] = {\n\t\t \n\t\t{ USBTV_BASE + 0x0008, 0x0001 },\n\t\t{ USBTV_BASE + 0x01d0, 0x00ff },\n\t\t{ USBTV_BASE + 0x01d9, 0x0002 },\n\n\t\t \n\t\t{ USBTV_BASE + 0x0239, 0x0040 },\n\t\t{ USBTV_BASE + 0x0240, 0x0000 },\n\t\t{ USBTV_BASE + 0x0241, 0x0000 },\n\t\t{ USBTV_BASE + 0x0242, 0x0002 },\n\t\t{ USBTV_BASE + 0x0243, 0x0080 },\n\t\t{ USBTV_BASE + 0x0244, 0x0012 },\n\t\t{ USBTV_BASE + 0x0245, 0x0090 },\n\t\t{ USBTV_BASE + 0x0246, 0x0000 },\n\n\t\t{ USBTV_BASE + 0x0278, 0x002d },\n\t\t{ USBTV_BASE + 0x0279, 0x000a },\n\t\t{ USBTV_BASE + 0x027a, 0x0032 },\n\t\t{ 0xf890, 0x000c },\n\t\t{ 0xf894, 0x0086 },\n\n\t\t{ USBTV_BASE + 0x00ac, 0x00c0 },\n\t\t{ USBTV_BASE + 0x00ad, 0x0000 },\n\t\t{ USBTV_BASE + 0x00a2, 0x0012 },\n\t\t{ USBTV_BASE + 0x00a3, 0x00e0 },\n\t\t{ USBTV_BASE + 0x00a4, 0x0028 },\n\t\t{ USBTV_BASE + 0x00a5, 0x0082 },\n\t\t{ USBTV_BASE + 0x00a7, 0x0080 },\n\t\t{ USBTV_BASE + 0x0000, 0x0014 },\n\t\t{ USBTV_BASE + 0x0006, 0x0003 },\n\t\t{ USBTV_BASE + 0x0090, 0x0099 },\n\t\t{ USBTV_BASE + 0x0091, 0x0090 },\n\t\t{ USBTV_BASE + 0x0094, 0x0068 },\n\t\t{ USBTV_BASE + 0x0095, 0x0070 },\n\t\t{ USBTV_BASE + 0x009c, 0x0030 },\n\t\t{ USBTV_BASE + 0x009d, 0x00c0 },\n\t\t{ USBTV_BASE + 0x009e, 0x00e0 },\n\t\t{ USBTV_BASE + 0x0019, 0x0006 },\n\t\t{ USBTV_BASE + 0x008c, 0x00ba },\n\t\t{ USBTV_BASE + 0x0101, 0x00ff },\n\t\t{ USBTV_BASE + 0x010c, 0x00b3 },\n\t\t{ USBTV_BASE + 0x01b2, 0x0080 },\n\t\t{ USBTV_BASE + 0x01b4, 0x00a0 },\n\t\t{ USBTV_BASE + 0x014c, 0x00ff },\n\t\t{ USBTV_BASE + 0x014d, 0x00ca },\n\t\t{ USBTV_BASE + 0x0113, 0x0053 },\n\t\t{ USBTV_BASE + 0x0119, 0x008a },\n\t\t{ USBTV_BASE + 0x013c, 0x0003 },\n\t\t{ USBTV_BASE + 0x0150, 0x009c },\n\t\t{ USBTV_BASE + 0x0151, 0x0071 },\n\t\t{ USBTV_BASE + 0x0152, 0x00c6 },\n\t\t{ USBTV_BASE + 0x0153, 0x0084 },\n\t\t{ USBTV_BASE + 0x0154, 0x00bc },\n\t\t{ USBTV_BASE + 0x0155, 0x00a0 },\n\t\t{ USBTV_BASE + 0x0156, 0x00a0 },\n\t\t{ USBTV_BASE + 0x0157, 0x009c },\n\t\t{ USBTV_BASE + 0x0158, 0x001f },\n\t\t{ USBTV_BASE + 0x0159, 0x0006 },\n\t\t{ USBTV_BASE + 0x015d, 0x0000 },\n\t};\n\n\tret = usbtv_set_regs(usbtv, setup, ARRAY_SIZE(setup));\n\tif (ret)\n\t\treturn ret;\n\n\tret = usbtv_select_norm(usbtv, usbtv->norm);\n\tif (ret)\n\t\treturn ret;\n\n\tret = usbtv_select_input(usbtv, usbtv->input);\n\tif (ret)\n\t\treturn ret;\n\n\tret = v4l2_ctrl_handler_setup(&usbtv->ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic void usbtv_chunk_to_vbuf(u32 *frame, __be32 *src, int chunk_no, int odd)\n{\n\tint half;\n\n\tfor (half = 0; half < 2; half++) {\n\t\tint part_no = chunk_no * 2 + half;\n\t\tint line = part_no / 3;\n\t\tint part_index = (line * 2 + !odd) * 3 + (part_no % 3);\n\n\t\tu32 *dst = &frame[part_index * USBTV_CHUNK/2];\n\n\t\tmemcpy(dst, src, USBTV_CHUNK/2 * sizeof(*src));\n\t\tsrc += USBTV_CHUNK/2;\n\t}\n}\n\n \nstatic void usbtv_image_chunk(struct usbtv *usbtv, __be32 *chunk)\n{\n\tint frame_id, odd, chunk_no;\n\tu32 *frame;\n\tstruct usbtv_buf *buf;\n\tunsigned long flags;\n\n\t \n\tif (!USBTV_MAGIC_OK(chunk))\n\t\treturn;\n\tframe_id = USBTV_FRAME_ID(chunk);\n\todd = USBTV_ODD(chunk);\n\tchunk_no = USBTV_CHUNK_NO(chunk);\n\tif (chunk_no >= usbtv->n_chunks)\n\t\treturn;\n\n\t \n\tif (chunk_no == 0) {\n\t\tusbtv->frame_id = frame_id;\n\t\tusbtv->chunks_done = 0;\n\t}\n\n\tif (usbtv->frame_id != frame_id)\n\t\treturn;\n\n\tspin_lock_irqsave(&usbtv->buflock, flags);\n\tif (list_empty(&usbtv->bufs)) {\n\t\t \n\t\tspin_unlock_irqrestore(&usbtv->buflock, flags);\n\t\treturn;\n\t}\n\n\t \n\tbuf = list_first_entry(&usbtv->bufs, struct usbtv_buf, list);\n\tframe = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\n\n\t \n\tusbtv_chunk_to_vbuf(frame, &chunk[1], chunk_no, odd);\n\tusbtv->chunks_done++;\n\n\t \n\tif (chunk_no == usbtv->n_chunks-1) {\n\t\t \n\t\tif (odd && !usbtv->last_odd) {\n\t\t\tint size = vb2_plane_size(&buf->vb.vb2_buf, 0);\n\t\t\tenum vb2_buffer_state state = usbtv->chunks_done ==\n\t\t\t\tusbtv->n_chunks ?\n\t\t\t\tVB2_BUF_STATE_DONE :\n\t\t\t\tVB2_BUF_STATE_ERROR;\n\n\t\t\tbuf->vb.field = V4L2_FIELD_INTERLACED;\n\t\t\tbuf->vb.sequence = usbtv->sequence++;\n\t\t\tbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\t\tvb2_set_plane_payload(&buf->vb.vb2_buf, 0, size);\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t\t\tlist_del(&buf->list);\n\t\t}\n\t\tusbtv->last_odd = odd;\n\t}\n\n\tspin_unlock_irqrestore(&usbtv->buflock, flags);\n}\n\n \nstatic void usbtv_iso_cb(struct urb *ip)\n{\n\tint ret;\n\tint i;\n\tstruct usbtv *usbtv = (struct usbtv *)ip->context;\n\n\tswitch (ip->status) {\n\t \n\tcase 0:\n\t\tbreak;\n\t \n\tcase -ENODEV:\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\t \n\tdefault:\n\t\tdev_warn(usbtv->dev, \"Bad response for ISO request.\\n\");\n\t\tgoto resubmit;\n\t}\n\n\tfor (i = 0; i < ip->number_of_packets; i++) {\n\t\tint size = ip->iso_frame_desc[i].actual_length;\n\t\tunsigned char *data = ip->transfer_buffer +\n\t\t\t\tip->iso_frame_desc[i].offset;\n\t\tint offset;\n\n\t\tfor (offset = 0; USBTV_CHUNK_SIZE * offset < size; offset++)\n\t\t\tusbtv_image_chunk(usbtv,\n\t\t\t\t(__be32 *)&data[USBTV_CHUNK_SIZE * offset]);\n\t}\n\nresubmit:\n\tret = usb_submit_urb(ip, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tdev_warn(usbtv->dev, \"Could not resubmit ISO URB\\n\");\n}\n\nstatic struct urb *usbtv_setup_iso_transfer(struct usbtv *usbtv)\n{\n\tstruct urb *ip;\n\tint size = usbtv->iso_size;\n\tint i;\n\n\tip = usb_alloc_urb(USBTV_ISOC_PACKETS, GFP_KERNEL);\n\tif (ip == NULL)\n\t\treturn NULL;\n\n\tip->dev = usbtv->udev;\n\tip->context = usbtv;\n\tip->pipe = usb_rcvisocpipe(usbtv->udev, USBTV_VIDEO_ENDP);\n\tip->interval = 1;\n\tip->transfer_flags = URB_ISO_ASAP;\n\tip->transfer_buffer = kcalloc(USBTV_ISOC_PACKETS, size,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!ip->transfer_buffer) {\n\t\tusb_free_urb(ip);\n\t\treturn NULL;\n\t}\n\tip->complete = usbtv_iso_cb;\n\tip->number_of_packets = USBTV_ISOC_PACKETS;\n\tip->transfer_buffer_length = size * USBTV_ISOC_PACKETS;\n\tfor (i = 0; i < USBTV_ISOC_PACKETS; i++) {\n\t\tip->iso_frame_desc[i].offset = size * i;\n\t\tip->iso_frame_desc[i].length = size;\n\t}\n\n\treturn ip;\n}\n\nstatic void usbtv_stop(struct usbtv *usbtv)\n{\n\tint i;\n\tunsigned long flags;\n\n\t \n\tfor (i = 0; i < USBTV_ISOC_TRANSFERS; i++) {\n\t\tstruct urb *ip = usbtv->isoc_urbs[i];\n\n\t\tif (ip == NULL)\n\t\t\tcontinue;\n\t\tusb_kill_urb(ip);\n\t\tkfree(ip->transfer_buffer);\n\t\tusb_free_urb(ip);\n\t\tusbtv->isoc_urbs[i] = NULL;\n\t}\n\n\t \n\tspin_lock_irqsave(&usbtv->buflock, flags);\n\twhile (!list_empty(&usbtv->bufs)) {\n\t\tstruct usbtv_buf *buf = list_first_entry(&usbtv->bufs,\n\t\t\t\t\t\tstruct usbtv_buf, list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\tlist_del(&buf->list);\n\t}\n\tspin_unlock_irqrestore(&usbtv->buflock, flags);\n}\n\nstatic int usbtv_start(struct usbtv *usbtv)\n{\n\tint i;\n\tint ret;\n\n\tusbtv_audio_suspend(usbtv);\n\n\tret = usb_set_interface(usbtv->udev, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = usbtv_setup_capture(usbtv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = usb_set_interface(usbtv->udev, 0, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusbtv_audio_resume(usbtv);\n\n\tfor (i = 0; i < USBTV_ISOC_TRANSFERS; i++) {\n\t\tstruct urb *ip;\n\n\t\tip = usbtv_setup_iso_transfer(usbtv);\n\t\tif (ip == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto start_fail;\n\t\t}\n\t\tusbtv->isoc_urbs[i] = ip;\n\n\t\tret = usb_submit_urb(ip, GFP_KERNEL);\n\t\tif (ret < 0)\n\t\t\tgoto start_fail;\n\t}\n\n\treturn 0;\n\nstart_fail:\n\tusbtv_stop(usbtv);\n\treturn ret;\n}\n\nstatic int usbtv_querycap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_capability *cap)\n{\n\tstruct usbtv *dev = video_drvdata(file);\n\n\tstrscpy(cap->driver, \"usbtv\", sizeof(cap->driver));\n\tstrscpy(cap->card, \"usbtv\", sizeof(cap->card));\n\tusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\n\treturn 0;\n}\n\nstatic int usbtv_enum_input(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_input *i)\n{\n\tstruct usbtv *dev = video_drvdata(file);\n\n\tswitch (i->index) {\n\tcase USBTV_COMPOSITE_INPUT:\n\t\tstrscpy(i->name, \"Composite\", sizeof(i->name));\n\t\tbreak;\n\tcase USBTV_SVIDEO_INPUT:\n\t\tstrscpy(i->name, \"S-Video\", sizeof(i->name));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ti->type = V4L2_INPUT_TYPE_CAMERA;\n\ti->std = dev->vdev.tvnorms;\n\treturn 0;\n}\n\nstatic int usbtv_enum_fmt_vid_cap(struct file *file, void  *priv,\n\t\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\tif (f->index > 0)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = V4L2_PIX_FMT_YUYV;\n\treturn 0;\n}\n\nstatic int usbtv_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct usbtv *usbtv = video_drvdata(file);\n\n\tf->fmt.pix.width = usbtv->width;\n\tf->fmt.pix.height = usbtv->height;\n\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;\n\tf->fmt.pix.field = V4L2_FIELD_INTERLACED;\n\tf->fmt.pix.bytesperline = usbtv->width * 2;\n\tf->fmt.pix.sizeimage = (f->fmt.pix.bytesperline * f->fmt.pix.height);\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\treturn 0;\n}\n\nstatic int usbtv_g_std(struct file *file, void *priv, v4l2_std_id *norm)\n{\n\tstruct usbtv *usbtv = video_drvdata(file);\n\t*norm = usbtv->norm;\n\treturn 0;\n}\n\nstatic int usbtv_s_std(struct file *file, void *priv, v4l2_std_id norm)\n{\n\tint ret = -EINVAL;\n\tstruct usbtv *usbtv = video_drvdata(file);\n\n\tif (norm & USBTV_TV_STD)\n\t\tret = usbtv_select_norm(usbtv, norm);\n\n\treturn ret;\n}\n\nstatic int usbtv_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct usbtv *usbtv = video_drvdata(file);\n\t*i = usbtv->input;\n\treturn 0;\n}\n\nstatic int usbtv_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tstruct usbtv *usbtv = video_drvdata(file);\n\n\treturn usbtv_select_input(usbtv, i);\n}\n\nstatic const struct v4l2_ioctl_ops usbtv_ioctl_ops = {\n\t.vidioc_querycap = usbtv_querycap,\n\t.vidioc_enum_input = usbtv_enum_input,\n\t.vidioc_enum_fmt_vid_cap = usbtv_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap = usbtv_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap = usbtv_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap = usbtv_fmt_vid_cap,\n\t.vidioc_g_std = usbtv_g_std,\n\t.vidioc_s_std = usbtv_s_std,\n\t.vidioc_g_input = usbtv_g_input,\n\t.vidioc_s_input = usbtv_s_input,\n\n\t.vidioc_reqbufs = vb2_ioctl_reqbufs,\n\t.vidioc_prepare_buf = vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf = vb2_ioctl_querybuf,\n\t.vidioc_create_bufs = vb2_ioctl_create_bufs,\n\t.vidioc_qbuf = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf = vb2_ioctl_dqbuf,\n\t.vidioc_streamon = vb2_ioctl_streamon,\n\t.vidioc_streamoff = vb2_ioctl_streamoff,\n};\n\nstatic const struct v4l2_file_operations usbtv_fops = {\n\t.owner = THIS_MODULE,\n\t.unlocked_ioctl = video_ioctl2,\n\t.mmap = vb2_fop_mmap,\n\t.open = v4l2_fh_open,\n\t.release = vb2_fop_release,\n\t.read = vb2_fop_read,\n\t.poll = vb2_fop_poll,\n};\n\nstatic int usbtv_queue_setup(struct vb2_queue *vq,\n\tunsigned int *nbuffers,\n\tunsigned int *nplanes, unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct usbtv *usbtv = vb2_get_drv_priv(vq);\n\tunsigned size = USBTV_CHUNK * usbtv->n_chunks * 2 * sizeof(u32);\n\n\tif (vq->num_buffers + *nbuffers < 2)\n\t\t*nbuffers = 2 - vq->num_buffers;\n\tif (*nplanes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\t*nplanes = 1;\n\tsizes[0] = size;\n\n\treturn 0;\n}\n\nstatic void usbtv_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct usbtv *usbtv = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct usbtv_buf *buf = container_of(vbuf, struct usbtv_buf, vb);\n\tunsigned long flags;\n\n\tif (usbtv->udev == NULL) {\n\t\tvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&usbtv->buflock, flags);\n\tlist_add_tail(&buf->list, &usbtv->bufs);\n\tspin_unlock_irqrestore(&usbtv->buflock, flags);\n}\n\nstatic int usbtv_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct usbtv *usbtv = vb2_get_drv_priv(vq);\n\n\tif (usbtv->udev == NULL)\n\t\treturn -ENODEV;\n\n\tusbtv->last_odd = 1;\n\tusbtv->sequence = 0;\n\treturn usbtv_start(usbtv);\n}\n\nstatic void usbtv_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct usbtv *usbtv = vb2_get_drv_priv(vq);\n\n\tif (usbtv->udev)\n\t\tusbtv_stop(usbtv);\n}\n\nstatic const struct vb2_ops usbtv_vb2_ops = {\n\t.queue_setup = usbtv_queue_setup,\n\t.buf_queue = usbtv_buf_queue,\n\t.start_streaming = usbtv_start_streaming,\n\t.stop_streaming = usbtv_stop_streaming,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n};\n\nstatic int usbtv_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct usbtv *usbtv = container_of(ctrl->handler, struct usbtv,\n\t\t\t\t\t\t\t\tctrl);\n\tu8 *data;\n\tu16 index, size;\n\tint ret;\n\n\tdata = kmalloc(3, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t \n\tif (ctrl->id == V4L2_CID_BRIGHTNESS || ctrl->id == V4L2_CID_CONTRAST) {\n\t\tret = usb_control_msg(usbtv->udev,\n\t\t\tusb_rcvctrlpipe(usbtv->udev, 0), USBTV_CONTROL_REG,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, USBTV_BASE + 0x0244, (void *)data, 3,\n\t\t\tUSB_CTRL_GET_TIMEOUT);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tindex = USBTV_BASE + 0x0244;\n\t\tsize = 3;\n\t\tdata[0] &= 0xf0;\n\t\tdata[0] |= (ctrl->val >> 8) & 0xf;\n\t\tdata[2] = ctrl->val & 0xff;\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tindex = USBTV_BASE + 0x0244;\n\t\tsize = 3;\n\t\tdata[0] &= 0x0f;\n\t\tdata[0] |= (ctrl->val >> 4) & 0xf0;\n\t\tdata[1] = ctrl->val & 0xff;\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tindex = USBTV_BASE + 0x0242;\n\t\tdata[0] = ctrl->val >> 8;\n\t\tdata[1] = ctrl->val & 0xff;\n\t\tsize = 2;\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\tindex = USBTV_BASE + 0x0240;\n\t\tsize = 2;\n\t\tif (ctrl->val > 0) {\n\t\t\tdata[0] = 0x92 + (ctrl->val >> 8);\n\t\t\tdata[1] = ctrl->val & 0xff;\n\t\t} else {\n\t\t\tdata[0] = 0x82 + (-ctrl->val >> 8);\n\t\t\tdata[1] = -ctrl->val & 0xff;\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_SHARPNESS:\n\t\tindex = USBTV_BASE + 0x0239;\n\t\tdata[0] = 0;\n\t\tdata[1] = ctrl->val;\n\t\tsize = 2;\n\t\tbreak;\n\tdefault:\n\t\tkfree(data);\n\t\treturn -EINVAL;\n\t}\n\n\tret = usb_control_msg(usbtv->udev, usb_sndctrlpipe(usbtv->udev, 0),\n\t\t\tUSBTV_CONTROL_REG,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, index, (void *)data, size, USB_CTRL_SET_TIMEOUT);\n\nerror:\n\tif (ret < 0)\n\t\tdev_warn(usbtv->dev, \"Failed to submit a control request.\\n\");\n\n\tkfree(data);\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops usbtv_ctrl_ops = {\n\t.s_ctrl = usbtv_s_ctrl,\n};\n\nstatic void usbtv_release(struct v4l2_device *v4l2_dev)\n{\n\tstruct usbtv *usbtv = container_of(v4l2_dev, struct usbtv, v4l2_dev);\n\n\tv4l2_device_unregister(&usbtv->v4l2_dev);\n\tv4l2_ctrl_handler_free(&usbtv->ctrl);\n\tkfree(usbtv);\n}\n\nint usbtv_video_init(struct usbtv *usbtv)\n{\n\tint ret;\n\n\t(void)usbtv_configure_for_norm(usbtv, V4L2_STD_525_60);\n\n\tspin_lock_init(&usbtv->buflock);\n\tmutex_init(&usbtv->v4l2_lock);\n\tmutex_init(&usbtv->vb2q_lock);\n\tINIT_LIST_HEAD(&usbtv->bufs);\n\n\t \n\tusbtv->vb2q.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tusbtv->vb2q.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\n\tusbtv->vb2q.drv_priv = usbtv;\n\tusbtv->vb2q.buf_struct_size = sizeof(struct usbtv_buf);\n\tusbtv->vb2q.ops = &usbtv_vb2_ops;\n\tusbtv->vb2q.mem_ops = &vb2_vmalloc_memops;\n\tusbtv->vb2q.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tusbtv->vb2q.lock = &usbtv->vb2q_lock;\n\tret = vb2_queue_init(&usbtv->vb2q);\n\tif (ret < 0) {\n\t\tdev_warn(usbtv->dev, \"Could not initialize videobuf2 queue\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tv4l2_ctrl_handler_init(&usbtv->ctrl, 4);\n\tv4l2_ctrl_new_std(&usbtv->ctrl, &usbtv_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 0x3ff, 1, 0x1d0);\n\tv4l2_ctrl_new_std(&usbtv->ctrl, &usbtv_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 0x3ff, 1, 0x1c0);\n\tv4l2_ctrl_new_std(&usbtv->ctrl, &usbtv_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 0x3ff, 1, 0x200);\n\tv4l2_ctrl_new_std(&usbtv->ctrl, &usbtv_ctrl_ops,\n\t\t\tV4L2_CID_HUE, -0xdff, 0xdff, 1, 0x000);\n\tv4l2_ctrl_new_std(&usbtv->ctrl, &usbtv_ctrl_ops,\n\t\t\tV4L2_CID_SHARPNESS, 0x0, 0xff, 1, 0x60);\n\tret = usbtv->ctrl.error;\n\tif (ret < 0) {\n\t\tdev_warn(usbtv->dev, \"Could not initialize controls\\n\");\n\t\tgoto ctrl_fail;\n\t}\n\n\t \n\tusbtv->v4l2_dev.ctrl_handler = &usbtv->ctrl;\n\tusbtv->v4l2_dev.release = usbtv_release;\n\tret = v4l2_device_register(usbtv->dev, &usbtv->v4l2_dev);\n\tif (ret < 0) {\n\t\tdev_warn(usbtv->dev, \"Could not register v4l2 device\\n\");\n\t\tgoto v4l2_fail;\n\t}\n\n\t \n\tstrscpy(usbtv->vdev.name, \"usbtv\", sizeof(usbtv->vdev.name));\n\tusbtv->vdev.v4l2_dev = &usbtv->v4l2_dev;\n\tusbtv->vdev.release = video_device_release_empty;\n\tusbtv->vdev.fops = &usbtv_fops;\n\tusbtv->vdev.ioctl_ops = &usbtv_ioctl_ops;\n\tusbtv->vdev.tvnorms = USBTV_TV_STD;\n\tusbtv->vdev.queue = &usbtv->vb2q;\n\tusbtv->vdev.lock = &usbtv->v4l2_lock;\n\tusbtv->vdev.device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\n\t\t\t\t  V4L2_CAP_STREAMING;\n\tvideo_set_drvdata(&usbtv->vdev, usbtv);\n\tret = video_register_device(&usbtv->vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret < 0) {\n\t\tdev_warn(usbtv->dev, \"Could not register video device\\n\");\n\t\tgoto vdev_fail;\n\t}\n\n\treturn 0;\n\nvdev_fail:\n\tv4l2_device_unregister(&usbtv->v4l2_dev);\nv4l2_fail:\nctrl_fail:\n\tv4l2_ctrl_handler_free(&usbtv->ctrl);\n\n\treturn ret;\n}\n\nvoid usbtv_video_free(struct usbtv *usbtv)\n{\n\tmutex_lock(&usbtv->vb2q_lock);\n\tmutex_lock(&usbtv->v4l2_lock);\n\n\tusbtv_stop(usbtv);\n\tvb2_video_unregister_device(&usbtv->vdev);\n\tv4l2_device_disconnect(&usbtv->v4l2_dev);\n\n\tmutex_unlock(&usbtv->v4l2_lock);\n\tmutex_unlock(&usbtv->vb2q_lock);\n\n\tv4l2_device_put(&usbtv->v4l2_dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}