{
  "module_name": "usbtv-audio.c",
  "hash_id": "31df5f7c39224b3b0895e6bd22c4ba1f4685a5c926d811d10d947840b88187ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/usbtv/usbtv-audio.c",
  "human_readable_source": " \n \n\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/ac97_codec.h>\n#include <sound/pcm_params.h>\n\n#include \"usbtv.h\"\n\nstatic const struct snd_pcm_hardware snd_usbtv_digital_hw = {\n\t.info = SNDRV_PCM_INFO_BATCH |\n\t\tSNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_MMAP_VALID,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates = SNDRV_PCM_RATE_48000,\n\t.rate_min = 48000,\n\t.rate_max = 48000,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.period_bytes_min = 11059,\n\t.period_bytes_max = 13516,\n\t.periods_min = 2,\n\t.periods_max = 98,\n\t.buffer_bytes_max = 62720 * 8,  \n};\n\nstatic int snd_usbtv_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct usbtv *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tchip->snd_substream = substream;\n\truntime->hw = snd_usbtv_digital_hw;\n\n\treturn 0;\n}\n\nstatic int snd_usbtv_pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct usbtv *chip = snd_pcm_substream_chip(substream);\n\n\tif (atomic_read(&chip->snd_stream)) {\n\t\tatomic_set(&chip->snd_stream, 0);\n\t\tschedule_work(&chip->snd_trigger);\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_usbtv_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct usbtv *chip = snd_pcm_substream_chip(substream);\n\n\tchip->snd_buffer_pos = 0;\n\tchip->snd_period_pos = 0;\n\n\treturn 0;\n}\n\nstatic void usbtv_audio_urb_received(struct urb *urb)\n{\n\tstruct usbtv *chip = urb->context;\n\tstruct snd_pcm_substream *substream = chip->snd_substream;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsize_t i, frame_bytes, chunk_length, buffer_pos, period_pos;\n\tint period_elapsed;\n\tunsigned long flags;\n\tvoid *urb_current;\n\n\tswitch (urb->status) {\n\tcase 0:\n\tcase -ETIMEDOUT:\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -EPROTO:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:\n\t\tdev_warn(chip->dev, \"unknown audio urb status %i\\n\",\n\t\t\turb->status);\n\t}\n\n\tif (!atomic_read(&chip->snd_stream))\n\t\treturn;\n\n\tframe_bytes = runtime->frame_bits >> 3;\n\tchunk_length = USBTV_CHUNK / frame_bytes;\n\n\tbuffer_pos = chip->snd_buffer_pos;\n\tperiod_pos = chip->snd_period_pos;\n\tperiod_elapsed = 0;\n\n\tfor (i = 0; i < urb->actual_length; i += USBTV_CHUNK_SIZE) {\n\t\turb_current = urb->transfer_buffer + i + USBTV_AUDIO_HDRSIZE;\n\n\t\tif (buffer_pos + chunk_length >= runtime->buffer_size) {\n\t\t\tsize_t cnt = (runtime->buffer_size - buffer_pos) *\n\t\t\t\tframe_bytes;\n\t\t\tmemcpy(runtime->dma_area + buffer_pos * frame_bytes,\n\t\t\t\turb_current, cnt);\n\t\t\tmemcpy(runtime->dma_area, urb_current + cnt,\n\t\t\t\tchunk_length * frame_bytes - cnt);\n\t\t} else {\n\t\t\tmemcpy(runtime->dma_area + buffer_pos * frame_bytes,\n\t\t\t\turb_current, chunk_length * frame_bytes);\n\t\t}\n\n\t\tbuffer_pos += chunk_length;\n\t\tperiod_pos += chunk_length;\n\n\t\tif (buffer_pos >= runtime->buffer_size)\n\t\t\tbuffer_pos -= runtime->buffer_size;\n\n\t\tif (period_pos >= runtime->period_size) {\n\t\t\tperiod_pos -= runtime->period_size;\n\t\t\tperiod_elapsed = 1;\n\t\t}\n\t}\n\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\n\tchip->snd_buffer_pos = buffer_pos;\n\tchip->snd_period_pos = period_pos;\n\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\n\tif (period_elapsed)\n\t\tsnd_pcm_period_elapsed(substream);\n\n\tusb_submit_urb(urb, GFP_ATOMIC);\n}\n\nstatic int usbtv_audio_start(struct usbtv *chip)\n{\n\tunsigned int pipe;\n\tstatic const u16 setup[][2] = {\n\t\t \n\t\t{ USBTV_BASE + 0x0008, 0x0001 },\n\t\t{ USBTV_BASE + 0x01d0, 0x00ff },\n\t\t{ USBTV_BASE + 0x01d9, 0x0002 },\n\n\t\t{ USBTV_BASE + 0x01da, 0x0013 },\n\t\t{ USBTV_BASE + 0x01db, 0x0012 },\n\t\t{ USBTV_BASE + 0x01e9, 0x0002 },\n\t\t{ USBTV_BASE + 0x01ec, 0x006c },\n\t\t{ USBTV_BASE + 0x0294, 0x0020 },\n\t\t{ USBTV_BASE + 0x0255, 0x00cf },\n\t\t{ USBTV_BASE + 0x0256, 0x0020 },\n\t\t{ USBTV_BASE + 0x01eb, 0x0030 },\n\t\t{ USBTV_BASE + 0x027d, 0x00a6 },\n\t\t{ USBTV_BASE + 0x0280, 0x0011 },\n\t\t{ USBTV_BASE + 0x0281, 0x0040 },\n\t\t{ USBTV_BASE + 0x0282, 0x0011 },\n\t\t{ USBTV_BASE + 0x0283, 0x0040 },\n\t\t{ 0xf891, 0x0010 },\n\n\t\t \n\t\t{ USBTV_BASE + 0x0284, 0x00aa },\n\t};\n\n\tchip->snd_bulk_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (chip->snd_bulk_urb == NULL)\n\t\tgoto err_alloc_urb;\n\n\tpipe = usb_rcvbulkpipe(chip->udev, USBTV_AUDIO_ENDP);\n\n\tchip->snd_bulk_urb->transfer_buffer = kzalloc(\n\t\tUSBTV_AUDIO_URBSIZE, GFP_KERNEL);\n\tif (chip->snd_bulk_urb->transfer_buffer == NULL)\n\t\tgoto err_transfer_buffer;\n\n\tusb_fill_bulk_urb(chip->snd_bulk_urb, chip->udev, pipe,\n\t\tchip->snd_bulk_urb->transfer_buffer, USBTV_AUDIO_URBSIZE,\n\t\tusbtv_audio_urb_received, chip);\n\n\t \n\tusbtv_set_regs(chip, setup, ARRAY_SIZE(setup));\n\n\tusb_clear_halt(chip->udev, pipe);\n\tusb_submit_urb(chip->snd_bulk_urb, GFP_ATOMIC);\n\n\treturn 0;\n\nerr_transfer_buffer:\n\tusb_free_urb(chip->snd_bulk_urb);\n\tchip->snd_bulk_urb = NULL;\n\nerr_alloc_urb:\n\treturn -ENOMEM;\n}\n\nstatic int usbtv_audio_stop(struct usbtv *chip)\n{\n\tstatic const u16 setup[][2] = {\n\t \n\t\t{ USBTV_BASE + 0x027d, 0x0000 },\n\t\t{ USBTV_BASE + 0x0280, 0x0010 },\n\t\t{ USBTV_BASE + 0x0282, 0x0010 },\n\t};\n\n\tif (chip->snd_bulk_urb) {\n\t\tusb_kill_urb(chip->snd_bulk_urb);\n\t\tkfree(chip->snd_bulk_urb->transfer_buffer);\n\t\tusb_free_urb(chip->snd_bulk_urb);\n\t\tchip->snd_bulk_urb = NULL;\n\t}\n\n\tusbtv_set_regs(chip, setup, ARRAY_SIZE(setup));\n\n\treturn 0;\n}\n\nvoid usbtv_audio_suspend(struct usbtv *usbtv)\n{\n\tif (atomic_read(&usbtv->snd_stream) && usbtv->snd_bulk_urb)\n\t\tusb_kill_urb(usbtv->snd_bulk_urb);\n}\n\nvoid usbtv_audio_resume(struct usbtv *usbtv)\n{\n\tif (atomic_read(&usbtv->snd_stream) && usbtv->snd_bulk_urb)\n\t\tusb_submit_urb(usbtv->snd_bulk_urb, GFP_ATOMIC);\n}\n\nstatic void snd_usbtv_trigger(struct work_struct *work)\n{\n\tstruct usbtv *chip = container_of(work, struct usbtv, snd_trigger);\n\n\tif (!chip->snd)\n\t\treturn;\n\n\tif (atomic_read(&chip->snd_stream))\n\t\tusbtv_audio_start(chip);\n\telse\n\t\tusbtv_audio_stop(chip);\n}\n\nstatic int snd_usbtv_card_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct usbtv *chip = snd_pcm_substream_chip(substream);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tatomic_set(&chip->snd_stream, 1);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tatomic_set(&chip->snd_stream, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tschedule_work(&chip->snd_trigger);\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t snd_usbtv_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct usbtv *chip = snd_pcm_substream_chip(substream);\n\n\treturn chip->snd_buffer_pos;\n}\n\nstatic const struct snd_pcm_ops snd_usbtv_pcm_ops = {\n\t.open = snd_usbtv_pcm_open,\n\t.close = snd_usbtv_pcm_close,\n\t.prepare = snd_usbtv_prepare,\n\t.trigger = snd_usbtv_card_trigger,\n\t.pointer = snd_usbtv_pointer,\n};\n\nint usbtv_audio_init(struct usbtv *usbtv)\n{\n\tint rv;\n\tstruct snd_card *card;\n\tstruct snd_pcm *pcm;\n\n\tINIT_WORK(&usbtv->snd_trigger, snd_usbtv_trigger);\n\tatomic_set(&usbtv->snd_stream, 0);\n\n\trv = snd_card_new(&usbtv->udev->dev, SNDRV_DEFAULT_IDX1, \"usbtv\",\n\t\tTHIS_MODULE, 0, &card);\n\tif (rv < 0)\n\t\treturn rv;\n\n\tstrscpy(card->driver, usbtv->dev->driver->name, sizeof(card->driver));\n\tstrscpy(card->shortname, \"usbtv\", sizeof(card->shortname));\n\tsnprintf(card->longname, sizeof(card->longname),\n\t\t\"USBTV Audio at bus %d device %d\", usbtv->udev->bus->busnum,\n\t\tusbtv->udev->devnum);\n\n\tsnd_card_set_dev(card, usbtv->dev);\n\n\tusbtv->snd = card;\n\n\trv = snd_pcm_new(card, \"USBTV Audio\", 0, 0, 1, &pcm);\n\tif (rv < 0)\n\t\tgoto err;\n\n\tstrscpy(pcm->name, \"USBTV Audio Input\", sizeof(pcm->name));\n\tpcm->info_flags = 0;\n\tpcm->private_data = usbtv;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_usbtv_pcm_ops);\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,\n\t\tNULL, USBTV_AUDIO_BUFFER, USBTV_AUDIO_BUFFER);\n\n\trv = snd_card_register(card);\n\tif (rv)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tusbtv->snd = NULL;\n\tsnd_card_free(card);\n\n\treturn rv;\n}\n\nvoid usbtv_audio_free(struct usbtv *usbtv)\n{\n\tcancel_work_sync(&usbtv->snd_trigger);\n\n\tif (usbtv->snd && usbtv->udev) {\n\t\tsnd_card_free_when_closed(usbtv->snd);\n\t\tusbtv->snd = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}