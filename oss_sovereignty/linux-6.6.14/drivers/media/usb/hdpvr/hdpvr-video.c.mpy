{
  "module_name": "hdpvr-video.c",
  "hash_id": "ad45bf9ed8c12a733ee670b5daca1e8dcad68196f1ddeb22fa99b0f7c3531b0d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/hdpvr/hdpvr-video.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/mutex.h>\n#include <linux/workqueue.h>\n\n#include <linux/videodev2.h>\n#include <linux/v4l2-dv-timings.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-dv-timings.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include \"hdpvr.h\"\n\n#define BULK_URB_TIMEOUT   90  \n\n#define print_buffer_status() { \\\n\t\tv4l2_dbg(MSG_BUFFER, hdpvr_debug, &dev->v4l2_dev,\t\\\n\t\t\t \"%s:%d buffer stat: %d free, %d proc\\n\",\t\\\n\t\t\t __func__, __LINE__,\t\t\t\t\\\n\t\t\t list_size(&dev->free_buff_list),\t\t\\\n\t\t\t list_size(&dev->rec_buff_list)); }\n\nstatic const struct v4l2_dv_timings hdpvr_dv_timings[] = {\n\tV4L2_DV_BT_CEA_720X480I59_94,\n\tV4L2_DV_BT_CEA_720X576I50,\n\tV4L2_DV_BT_CEA_720X480P59_94,\n\tV4L2_DV_BT_CEA_720X576P50,\n\tV4L2_DV_BT_CEA_1280X720P50,\n\tV4L2_DV_BT_CEA_1280X720P60,\n\tV4L2_DV_BT_CEA_1920X1080I50,\n\tV4L2_DV_BT_CEA_1920X1080I60,\n};\n\n \n#define HDPVR_DEF_DV_TIMINGS_IDX (0)\n\nstruct hdpvr_fh {\n\tstruct v4l2_fh fh;\n\tbool legacy_mode;\n};\n\nstatic uint list_size(struct list_head *list)\n{\n\tstruct list_head *tmp;\n\tuint count = 0;\n\n\tlist_for_each(tmp, list) {\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\n \n \nstatic void hdpvr_read_bulk_callback(struct urb *urb)\n{\n\tstruct hdpvr_buffer *buf = (struct hdpvr_buffer *)urb->context;\n\tstruct hdpvr_device *dev = buf->dev;\n\n\t \n\tbuf->status = BUFSTAT_READY;\n\twake_up_interruptible(&dev->wait_data);\n}\n\n \n \n\n \nint hdpvr_cancel_queue(struct hdpvr_device *dev)\n{\n\tstruct hdpvr_buffer *buf;\n\n\tlist_for_each_entry(buf, &dev->rec_buff_list, buff_list) {\n\t\tusb_kill_urb(buf->urb);\n\t\tbuf->status = BUFSTAT_AVAILABLE;\n\t}\n\n\tlist_splice_init(&dev->rec_buff_list, dev->free_buff_list.prev);\n\n\treturn 0;\n}\n\nstatic int hdpvr_free_queue(struct list_head *q)\n{\n\tstruct list_head *tmp;\n\tstruct list_head *p;\n\tstruct hdpvr_buffer *buf;\n\tstruct urb *urb;\n\n\tfor (p = q->next; p != q;) {\n\t\tbuf = list_entry(p, struct hdpvr_buffer, buff_list);\n\n\t\turb = buf->urb;\n\t\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\t\ttmp = p->next;\n\t\tlist_del(p);\n\t\tkfree(buf);\n\t\tp = tmp;\n\t}\n\n\treturn 0;\n}\n\n \nint hdpvr_free_buffers(struct hdpvr_device *dev)\n{\n\thdpvr_cancel_queue(dev);\n\n\thdpvr_free_queue(&dev->free_buff_list);\n\thdpvr_free_queue(&dev->rec_buff_list);\n\n\treturn 0;\n}\n\n \nint hdpvr_alloc_buffers(struct hdpvr_device *dev, uint count)\n{\n\tuint i;\n\tint retval = -ENOMEM;\n\tu8 *mem;\n\tstruct hdpvr_buffer *buf;\n\tstruct urb *urb;\n\n\tv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\n\t\t \"allocating %u buffers\\n\", count);\n\n\tfor (i = 0; i < count; i++) {\n\n\t\tbuf = kzalloc(sizeof(struct hdpvr_buffer), GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tv4l2_err(&dev->v4l2_dev, \"cannot allocate buffer\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tbuf->dev = dev;\n\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb)\n\t\t\tgoto exit_urb;\n\t\tbuf->urb = urb;\n\n\t\tmem = usb_alloc_coherent(dev->udev, dev->bulk_in_size, GFP_KERNEL,\n\t\t\t\t\t &urb->transfer_dma);\n\t\tif (!mem) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"cannot allocate usb transfer buffer\\n\");\n\t\t\tgoto exit_urb_buffer;\n\t\t}\n\n\t\tusb_fill_bulk_urb(buf->urb, dev->udev,\n\t\t\t\t  usb_rcvbulkpipe(dev->udev,\n\t\t\t\t\t\t  dev->bulk_in_endpointAddr),\n\t\t\t\t  mem, dev->bulk_in_size,\n\t\t\t\t  hdpvr_read_bulk_callback, buf);\n\n\t\tbuf->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\tbuf->status = BUFSTAT_AVAILABLE;\n\t\tlist_add_tail(&buf->buff_list, &dev->free_buff_list);\n\t}\n\treturn 0;\nexit_urb_buffer:\n\tusb_free_urb(urb);\nexit_urb:\n\tkfree(buf);\nexit:\n\thdpvr_free_buffers(dev);\n\treturn retval;\n}\n\nstatic int hdpvr_submit_buffers(struct hdpvr_device *dev)\n{\n\tstruct hdpvr_buffer *buf;\n\tstruct urb *urb;\n\tint ret = 0, err_count = 0;\n\n\tmutex_lock(&dev->io_mutex);\n\n\twhile (dev->status == STATUS_STREAMING &&\n\t       !list_empty(&dev->free_buff_list)) {\n\n\t\tbuf = list_entry(dev->free_buff_list.next, struct hdpvr_buffer,\n\t\t\t\t buff_list);\n\t\tif (buf->status != BUFSTAT_AVAILABLE) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"buffer not marked as available\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto err;\n\t\t}\n\n\t\turb = buf->urb;\n\t\turb->status = 0;\n\t\turb->actual_length = 0;\n\t\tret = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"usb_submit_urb in %s returned %d\\n\",\n\t\t\t\t __func__, ret);\n\t\t\tif (++err_count > 2)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tbuf->status = BUFSTAT_INPROGRESS;\n\t\tlist_move_tail(&buf->buff_list, &dev->rec_buff_list);\n\t}\nerr:\n\tprint_buffer_status();\n\tmutex_unlock(&dev->io_mutex);\n\treturn ret;\n}\n\nstatic struct hdpvr_buffer *hdpvr_get_next_buffer(struct hdpvr_device *dev)\n{\n\tstruct hdpvr_buffer *buf;\n\n\tmutex_lock(&dev->io_mutex);\n\n\tif (list_empty(&dev->rec_buff_list)) {\n\t\tmutex_unlock(&dev->io_mutex);\n\t\treturn NULL;\n\t}\n\n\tbuf = list_entry(dev->rec_buff_list.next, struct hdpvr_buffer,\n\t\t\t buff_list);\n\tmutex_unlock(&dev->io_mutex);\n\n\treturn buf;\n}\n\nstatic void hdpvr_transmit_buffers(struct work_struct *work)\n{\n\tstruct hdpvr_device *dev = container_of(work, struct hdpvr_device,\n\t\t\t\t\t\tworker);\n\n\twhile (dev->status == STATUS_STREAMING) {\n\n\t\tif (hdpvr_submit_buffers(dev)) {\n\t\t\tv4l2_err(&dev->v4l2_dev, \"couldn't submit buffers\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (wait_event_interruptible(dev->wait_buffer,\n\t\t\t\t!list_empty(&dev->free_buff_list) ||\n\t\t\t\t\t     dev->status != STATUS_STREAMING))\n\t\t\tgoto error;\n\t}\n\n\tv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\n\t\t \"transmit worker exited\\n\");\n\treturn;\nerror:\n\tv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\n\t\t \"transmit buffers errored\\n\");\n\tdev->status = STATUS_ERROR;\n}\n\n \nstatic int hdpvr_start_streaming(struct hdpvr_device *dev)\n{\n\tint ret;\n\tstruct hdpvr_video_info vidinf;\n\n\tif (dev->status == STATUS_STREAMING)\n\t\treturn 0;\n\tif (dev->status != STATUS_IDLE)\n\t\treturn -EAGAIN;\n\n\tret = get_video_info(dev, &vidinf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!vidinf.valid) {\n\t\tmsleep(250);\n\t\tv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\n\t\t\t\t\"no video signal at input %d\\n\", dev->options.video_input);\n\t\treturn -EAGAIN;\n\t}\n\n\tv4l2_dbg(MSG_BUFFER, hdpvr_debug, &dev->v4l2_dev,\n\t\t\t\"video signal: %dx%d@%dhz\\n\", vidinf.width,\n\t\t\tvidinf.height, vidinf.fps);\n\n\t \n\tret = usb_control_msg(dev->udev,\n\t\t\tusb_sndctrlpipe(dev->udev, 0),\n\t\t\t0xb8, 0x38, 0x1, 0, NULL, 0, 8000);\n\tv4l2_dbg(MSG_BUFFER, hdpvr_debug, &dev->v4l2_dev,\n\t\t\t\"encoder start control request returned %d\\n\", ret);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = hdpvr_config_call(dev, CTRL_START_STREAMING_VALUE, 0x00);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->status = STATUS_STREAMING;\n\n\tschedule_work(&dev->worker);\n\n\tv4l2_dbg(MSG_BUFFER, hdpvr_debug, &dev->v4l2_dev,\n\t\t\t\"streaming started\\n\");\n\n\treturn 0;\n}\n\n\n \nstatic int hdpvr_stop_streaming(struct hdpvr_device *dev)\n{\n\tint actual_length;\n\tuint c = 0;\n\tu8 *buf;\n\n\tif (dev->status == STATUS_IDLE)\n\t\treturn 0;\n\telse if (dev->status != STATUS_STREAMING)\n\t\treturn -EAGAIN;\n\n\tbuf = kmalloc(dev->bulk_in_size, GFP_KERNEL);\n\tif (!buf)\n\t\tv4l2_err(&dev->v4l2_dev, \"failed to allocate temporary buffer for emptying the internal device buffer. Next capture start will be slow\\n\");\n\n\tdev->status = STATUS_SHUTTING_DOWN;\n\thdpvr_config_call(dev, CTRL_STOP_STREAMING_VALUE, 0x00);\n\tmutex_unlock(&dev->io_mutex);\n\n\twake_up_interruptible(&dev->wait_buffer);\n\tmsleep(50);\n\n\tflush_work(&dev->worker);\n\n\tmutex_lock(&dev->io_mutex);\n\t \n\thdpvr_cancel_queue(dev);\n\n\t \n\twhile (buf && ++c < 500 &&\n\t       !usb_bulk_msg(dev->udev,\n\t\t\t     usb_rcvbulkpipe(dev->udev,\n\t\t\t\t\t     dev->bulk_in_endpointAddr),\n\t\t\t     buf, dev->bulk_in_size, &actual_length,\n\t\t\t     BULK_URB_TIMEOUT)) {\n\t\tv4l2_dbg(MSG_BUFFER, hdpvr_debug, &dev->v4l2_dev,\n\t\t\t \"%2d: got %d bytes\\n\", c, actual_length);\n\t}\n\tkfree(buf);\n\tv4l2_dbg(MSG_BUFFER, hdpvr_debug, &dev->v4l2_dev,\n\t\t \"used %d urbs to empty device buffers\\n\", c-1);\n\tmsleep(10);\n\n\tdev->status = STATUS_IDLE;\n\n\treturn 0;\n}\n\n\n \n \n\nstatic int hdpvr_open(struct file *file)\n{\n\tstruct hdpvr_fh *fh = kzalloc(sizeof(*fh), GFP_KERNEL);\n\n\tif (fh == NULL)\n\t\treturn -ENOMEM;\n\tfh->legacy_mode = true;\n\tv4l2_fh_init(&fh->fh, video_devdata(file));\n\tv4l2_fh_add(&fh->fh);\n\tfile->private_data = fh;\n\treturn 0;\n}\n\nstatic int hdpvr_release(struct file *file)\n{\n\tstruct hdpvr_device *dev = video_drvdata(file);\n\n\tmutex_lock(&dev->io_mutex);\n\tif (file->private_data == dev->owner) {\n\t\thdpvr_stop_streaming(dev);\n\t\tdev->owner = NULL;\n\t}\n\tmutex_unlock(&dev->io_mutex);\n\n\treturn v4l2_fh_release(file);\n}\n\n \nstatic ssize_t hdpvr_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *pos)\n{\n\tstruct hdpvr_device *dev = video_drvdata(file);\n\tstruct hdpvr_buffer *buf = NULL;\n\tstruct urb *urb;\n\tint ret = 0;\n\tint rem, cnt;\n\n\tif (*pos)\n\t\treturn -ESPIPE;\n\n\tmutex_lock(&dev->io_mutex);\n\tif (dev->status == STATUS_IDLE) {\n\t\tif (hdpvr_start_streaming(dev)) {\n\t\t\tv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\n\t\t\t\t \"start_streaming failed\\n\");\n\t\t\tret = -EIO;\n\t\t\tmsleep(200);\n\t\t\tdev->status = STATUS_IDLE;\n\t\t\tmutex_unlock(&dev->io_mutex);\n\t\t\tgoto err;\n\t\t}\n\t\tdev->owner = file->private_data;\n\t\tprint_buffer_status();\n\t}\n\tmutex_unlock(&dev->io_mutex);\n\n\t \n\tif (!(file->f_flags & O_NONBLOCK)) {\n\t\tif (wait_event_interruptible(dev->wait_data,\n\t\t\t\t\t     !list_empty_careful(&dev->rec_buff_list)))\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\tbuf = hdpvr_get_next_buffer(dev);\n\n\twhile (count > 0 && buf) {\n\n\t\tif (buf->status != BUFSTAT_READY &&\n\t\t    dev->status != STATUS_DISCONNECTED) {\n\t\t\tint err;\n\t\t\t \n\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = -EAGAIN;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\terr = wait_event_interruptible_timeout(dev->wait_data,\n\t\t\t\tbuf->status == BUFSTAT_READY,\n\t\t\t\tmsecs_to_jiffies(1000));\n\t\t\tif (err < 0) {\n\t\t\t\tret = err;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (!err) {\n\t\t\t\tv4l2_info(&dev->v4l2_dev,\n\t\t\t\t\t  \"timeout: restart streaming\\n\");\n\t\t\t\tmutex_lock(&dev->io_mutex);\n\t\t\t\thdpvr_stop_streaming(dev);\n\t\t\t\tmutex_unlock(&dev->io_mutex);\n\t\t\t\t \n\t\t\t\tmsleep(4000);\n\t\t\t\terr = hdpvr_start_streaming(dev);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (buf->status != BUFSTAT_READY)\n\t\t\tbreak;\n\n\t\t \n\t\turb = buf->urb;\n\t\trem = urb->actual_length - buf->pos;\n\t\tcnt = rem > count ? count : rem;\n\n\t\tif (copy_to_user(buffer, urb->transfer_buffer + buf->pos,\n\t\t\t\t cnt)) {\n\t\t\tv4l2_err(&dev->v4l2_dev, \"read: copy_to_user failed\\n\");\n\t\t\tif (!ret)\n\t\t\t\tret = -EFAULT;\n\t\t\tgoto err;\n\t\t}\n\n\t\tbuf->pos += cnt;\n\t\tcount -= cnt;\n\t\tbuffer += cnt;\n\t\tret += cnt;\n\n\t\t \n\t\tif (buf->pos == urb->actual_length) {\n\t\t\tmutex_lock(&dev->io_mutex);\n\t\t\tbuf->pos = 0;\n\t\t\tbuf->status = BUFSTAT_AVAILABLE;\n\n\t\t\tlist_move_tail(&buf->buff_list, &dev->free_buff_list);\n\n\t\t\tprint_buffer_status();\n\n\t\t\tmutex_unlock(&dev->io_mutex);\n\n\t\t\twake_up_interruptible(&dev->wait_buffer);\n\n\t\t\tbuf = hdpvr_get_next_buffer(dev);\n\t\t}\n\t}\nerr:\n\tif (!ret && !buf)\n\t\tret = -EAGAIN;\n\treturn ret;\n}\n\nstatic __poll_t hdpvr_poll(struct file *filp, poll_table *wait)\n{\n\t__poll_t req_events = poll_requested_events(wait);\n\tstruct hdpvr_buffer *buf = NULL;\n\tstruct hdpvr_device *dev = video_drvdata(filp);\n\t__poll_t mask = v4l2_ctrl_poll(filp, wait);\n\n\tif (!(req_events & (EPOLLIN | EPOLLRDNORM)))\n\t\treturn mask;\n\n\tmutex_lock(&dev->io_mutex);\n\n\tif (dev->status == STATUS_IDLE) {\n\t\tif (hdpvr_start_streaming(dev)) {\n\t\t\tv4l2_dbg(MSG_BUFFER, hdpvr_debug, &dev->v4l2_dev,\n\t\t\t\t \"start_streaming failed\\n\");\n\t\t\tdev->status = STATUS_IDLE;\n\t\t} else {\n\t\t\tdev->owner = filp->private_data;\n\t\t}\n\n\t\tprint_buffer_status();\n\t}\n\tmutex_unlock(&dev->io_mutex);\n\n\tbuf = hdpvr_get_next_buffer(dev);\n\t \n\tif (!buf || buf->status != BUFSTAT_READY) {\n\t\tpoll_wait(filp, &dev->wait_data, wait);\n\t\tbuf = hdpvr_get_next_buffer(dev);\n\t}\n\tif (buf && buf->status == BUFSTAT_READY)\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\n\nstatic const struct v4l2_file_operations hdpvr_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= hdpvr_open,\n\t.release\t= hdpvr_release,\n\t.read\t\t= hdpvr_read,\n\t.poll\t\t= hdpvr_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n};\n\n \n \n\nstatic int vidioc_querycap(struct file *file, void  *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct hdpvr_device *dev = video_drvdata(file);\n\n\tstrscpy(cap->driver, \"hdpvr\", sizeof(cap->driver));\n\tstrscpy(cap->card, \"Hauppauge HD PVR\", sizeof(cap->card));\n\tusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\n\treturn 0;\n}\n\nstatic int vidioc_s_std(struct file *file, void *_fh,\n\t\t\tv4l2_std_id std)\n{\n\tstruct hdpvr_device *dev = video_drvdata(file);\n\tstruct hdpvr_fh *fh = _fh;\n\tu8 std_type = 1;\n\n\tif (!fh->legacy_mode && dev->options.video_input == HDPVR_COMPONENT)\n\t\treturn -ENODATA;\n\tif (dev->status != STATUS_IDLE)\n\t\treturn -EBUSY;\n\tif (std & V4L2_STD_525_60)\n\t\tstd_type = 0;\n\tdev->cur_std = std;\n\tdev->width = 720;\n\tdev->height = std_type ? 576 : 480;\n\n\treturn hdpvr_config_call(dev, CTRL_VIDEO_STD_TYPE, std_type);\n}\n\nstatic int vidioc_g_std(struct file *file, void *_fh,\n\t\t\tv4l2_std_id *std)\n{\n\tstruct hdpvr_device *dev = video_drvdata(file);\n\tstruct hdpvr_fh *fh = _fh;\n\n\tif (!fh->legacy_mode && dev->options.video_input == HDPVR_COMPONENT)\n\t\treturn -ENODATA;\n\t*std = dev->cur_std;\n\treturn 0;\n}\n\nstatic int vidioc_querystd(struct file *file, void *_fh, v4l2_std_id *a)\n{\n\tstruct hdpvr_device *dev = video_drvdata(file);\n\tstruct hdpvr_video_info vid_info;\n\tstruct hdpvr_fh *fh = _fh;\n\tint ret;\n\n\t*a = V4L2_STD_UNKNOWN;\n\tif (dev->options.video_input == HDPVR_COMPONENT)\n\t\treturn fh->legacy_mode ? 0 : -ENODATA;\n\tret = get_video_info(dev, &vid_info);\n\tif (vid_info.valid && vid_info.width == 720 &&\n\t    (vid_info.height == 480 || vid_info.height == 576)) {\n\t\t*a = (vid_info.height == 480) ?\n\t\t\tV4L2_STD_525_60 : V4L2_STD_625_50;\n\t}\n\treturn ret;\n}\n\nstatic int vidioc_s_dv_timings(struct file *file, void *_fh,\n\t\t\t\t    struct v4l2_dv_timings *timings)\n{\n\tstruct hdpvr_device *dev = video_drvdata(file);\n\tstruct hdpvr_fh *fh = _fh;\n\tint i;\n\n\tfh->legacy_mode = false;\n\tif (dev->options.video_input)\n\t\treturn -ENODATA;\n\tif (dev->status != STATUS_IDLE)\n\t\treturn -EBUSY;\n\tfor (i = 0; i < ARRAY_SIZE(hdpvr_dv_timings); i++)\n\t\tif (v4l2_match_dv_timings(timings, hdpvr_dv_timings + i, 0, false))\n\t\t\tbreak;\n\tif (i == ARRAY_SIZE(hdpvr_dv_timings))\n\t\treturn -EINVAL;\n\tdev->cur_dv_timings = hdpvr_dv_timings[i];\n\tdev->width = hdpvr_dv_timings[i].bt.width;\n\tdev->height = hdpvr_dv_timings[i].bt.height;\n\treturn 0;\n}\n\nstatic int vidioc_g_dv_timings(struct file *file, void *_fh,\n\t\t\t\t    struct v4l2_dv_timings *timings)\n{\n\tstruct hdpvr_device *dev = video_drvdata(file);\n\tstruct hdpvr_fh *fh = _fh;\n\n\tfh->legacy_mode = false;\n\tif (dev->options.video_input)\n\t\treturn -ENODATA;\n\t*timings = dev->cur_dv_timings;\n\treturn 0;\n}\n\nstatic int vidioc_query_dv_timings(struct file *file, void *_fh,\n\t\t\t\t    struct v4l2_dv_timings *timings)\n{\n\tstruct hdpvr_device *dev = video_drvdata(file);\n\tstruct hdpvr_fh *fh = _fh;\n\tstruct hdpvr_video_info vid_info;\n\tbool interlaced;\n\tint ret = 0;\n\tint i;\n\n\tfh->legacy_mode = false;\n\tif (dev->options.video_input)\n\t\treturn -ENODATA;\n\tret = get_video_info(dev, &vid_info);\n\tif (ret)\n\t\treturn ret;\n\tif (!vid_info.valid)\n\t\treturn -ENOLCK;\n\tinterlaced = vid_info.fps <= 30;\n\tfor (i = 0; i < ARRAY_SIZE(hdpvr_dv_timings); i++) {\n\t\tconst struct v4l2_bt_timings *bt = &hdpvr_dv_timings[i].bt;\n\t\tunsigned hsize;\n\t\tunsigned vsize;\n\t\tunsigned fps;\n\n\t\thsize = V4L2_DV_BT_FRAME_WIDTH(bt);\n\t\tvsize = V4L2_DV_BT_FRAME_HEIGHT(bt);\n\t\tfps = (unsigned)bt->pixelclock / (hsize * vsize);\n\t\tif (bt->width != vid_info.width ||\n\t\t    bt->height != vid_info.height ||\n\t\t    bt->interlaced != interlaced ||\n\t\t    (fps != vid_info.fps && fps + 1 != vid_info.fps))\n\t\t\tcontinue;\n\t\t*timings = hdpvr_dv_timings[i];\n\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(hdpvr_dv_timings))\n\t\tret = -ERANGE;\n\n\treturn ret;\n}\n\nstatic int vidioc_enum_dv_timings(struct file *file, void *_fh,\n\t\t\t\t    struct v4l2_enum_dv_timings *timings)\n{\n\tstruct hdpvr_device *dev = video_drvdata(file);\n\tstruct hdpvr_fh *fh = _fh;\n\n\tfh->legacy_mode = false;\n\tmemset(timings->reserved, 0, sizeof(timings->reserved));\n\tif (dev->options.video_input)\n\t\treturn -ENODATA;\n\tif (timings->index >= ARRAY_SIZE(hdpvr_dv_timings))\n\t\treturn -EINVAL;\n\ttimings->timings = hdpvr_dv_timings[timings->index];\n\treturn 0;\n}\n\nstatic int vidioc_dv_timings_cap(struct file *file, void *_fh,\n\t\t\t\t    struct v4l2_dv_timings_cap *cap)\n{\n\tstruct hdpvr_device *dev = video_drvdata(file);\n\tstruct hdpvr_fh *fh = _fh;\n\n\tfh->legacy_mode = false;\n\tif (dev->options.video_input)\n\t\treturn -ENODATA;\n\tcap->type = V4L2_DV_BT_656_1120;\n\tcap->bt.min_width = 720;\n\tcap->bt.max_width = 1920;\n\tcap->bt.min_height = 480;\n\tcap->bt.max_height = 1080;\n\tcap->bt.min_pixelclock = 27000000;\n\tcap->bt.max_pixelclock = 74250000;\n\tcap->bt.standards = V4L2_DV_BT_STD_CEA861;\n\tcap->bt.capabilities = V4L2_DV_BT_CAP_INTERLACED | V4L2_DV_BT_CAP_PROGRESSIVE;\n\treturn 0;\n}\n\nstatic const char *iname[] = {\n\t[HDPVR_COMPONENT] = \"Component\",\n\t[HDPVR_SVIDEO]    = \"S-Video\",\n\t[HDPVR_COMPOSITE] = \"Composite\",\n};\n\nstatic int vidioc_enum_input(struct file *file, void *_fh, struct v4l2_input *i)\n{\n\tunsigned int n;\n\n\tn = i->index;\n\tif (n >= HDPVR_VIDEO_INPUTS)\n\t\treturn -EINVAL;\n\n\ti->type = V4L2_INPUT_TYPE_CAMERA;\n\n\tstrscpy(i->name, iname[n], sizeof(i->name));\n\n\ti->audioset = 1<<HDPVR_RCA_FRONT | 1<<HDPVR_RCA_BACK | 1<<HDPVR_SPDIF;\n\n\ti->capabilities = n ? V4L2_IN_CAP_STD : V4L2_IN_CAP_DV_TIMINGS;\n\ti->std = n ? V4L2_STD_ALL : 0;\n\n\treturn 0;\n}\n\nstatic int vidioc_s_input(struct file *file, void *_fh,\n\t\t\t  unsigned int index)\n{\n\tstruct hdpvr_device *dev = video_drvdata(file);\n\tint retval;\n\n\tif (index >= HDPVR_VIDEO_INPUTS)\n\t\treturn -EINVAL;\n\n\tif (dev->status != STATUS_IDLE)\n\t\treturn -EBUSY;\n\n\tretval = hdpvr_config_call(dev, CTRL_VIDEO_INPUT_VALUE, index+1);\n\tif (!retval) {\n\t\tdev->options.video_input = index;\n\t\t \n\t}\n\n\treturn retval;\n}\n\nstatic int vidioc_g_input(struct file *file, void *private_data,\n\t\t\t  unsigned int *index)\n{\n\tstruct hdpvr_device *dev = video_drvdata(file);\n\n\t*index = dev->options.video_input;\n\treturn 0;\n}\n\n\nstatic const char *audio_iname[] = {\n\t[HDPVR_RCA_FRONT] = \"RCA front\",\n\t[HDPVR_RCA_BACK]  = \"RCA back\",\n\t[HDPVR_SPDIF]     = \"SPDIF\",\n};\n\nstatic int vidioc_enumaudio(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_audio *audio)\n{\n\tunsigned int n;\n\n\tn = audio->index;\n\tif (n >= HDPVR_AUDIO_INPUTS)\n\t\treturn -EINVAL;\n\n\taudio->capability = V4L2_AUDCAP_STEREO;\n\n\tstrscpy(audio->name, audio_iname[n], sizeof(audio->name));\n\n\treturn 0;\n}\n\nstatic int vidioc_s_audio(struct file *file, void *private_data,\n\t\t\t  const struct v4l2_audio *audio)\n{\n\tstruct hdpvr_device *dev = video_drvdata(file);\n\tint retval;\n\n\tif (audio->index >= HDPVR_AUDIO_INPUTS)\n\t\treturn -EINVAL;\n\n\tif (dev->status != STATUS_IDLE)\n\t\treturn -EBUSY;\n\n\tretval = hdpvr_set_audio(dev, audio->index+1, dev->options.audio_codec);\n\tif (!retval)\n\t\tdev->options.audio_input = audio->index;\n\n\treturn retval;\n}\n\nstatic int vidioc_g_audio(struct file *file, void *private_data,\n\t\t\t  struct v4l2_audio *audio)\n{\n\tstruct hdpvr_device *dev = video_drvdata(file);\n\n\taudio->index = dev->options.audio_input;\n\taudio->capability = V4L2_AUDCAP_STEREO;\n\tstrscpy(audio->name, audio_iname[audio->index], sizeof(audio->name));\n\treturn 0;\n}\n\nstatic int hdpvr_try_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct hdpvr_device *dev =\n\t\tcontainer_of(ctrl->handler, struct hdpvr_device, hdl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\n\t\tif (ctrl->val == V4L2_MPEG_VIDEO_BITRATE_MODE_VBR &&\n\t\t    dev->video_bitrate->val >= dev->video_bitrate_peak->val)\n\t\t\tdev->video_bitrate_peak->val =\n\t\t\t\t\tdev->video_bitrate->val + 100000;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int hdpvr_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct hdpvr_device *dev =\n\t\tcontainer_of(ctrl->handler, struct hdpvr_device, hdl);\n\tstruct hdpvr_options *opt = &dev->options;\n\tint ret = -EINVAL;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tret = hdpvr_config_call(dev, CTRL_BRIGHTNESS, ctrl->val);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tdev->options.brightness = ctrl->val;\n\t\treturn 0;\n\tcase V4L2_CID_CONTRAST:\n\t\tret = hdpvr_config_call(dev, CTRL_CONTRAST, ctrl->val);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tdev->options.contrast = ctrl->val;\n\t\treturn 0;\n\tcase V4L2_CID_SATURATION:\n\t\tret = hdpvr_config_call(dev, CTRL_SATURATION, ctrl->val);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tdev->options.saturation = ctrl->val;\n\t\treturn 0;\n\tcase V4L2_CID_HUE:\n\t\tret = hdpvr_config_call(dev, CTRL_HUE, ctrl->val);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tdev->options.hue = ctrl->val;\n\t\treturn 0;\n\tcase V4L2_CID_SHARPNESS:\n\t\tret = hdpvr_config_call(dev, CTRL_SHARPNESS, ctrl->val);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tdev->options.sharpness = ctrl->val;\n\t\treturn 0;\n\tcase V4L2_CID_MPEG_AUDIO_ENCODING:\n\t\tif (dev->flags & HDPVR_FLAG_AC3_CAP) {\n\t\t\topt->audio_codec = ctrl->val;\n\t\t\treturn hdpvr_set_audio(dev, opt->audio_input + 1,\n\t\t\t\t\t      opt->audio_codec);\n\t\t}\n\t\treturn 0;\n\tcase V4L2_CID_MPEG_VIDEO_ENCODING:\n\t\treturn 0;\n \n \n \n \n \n \n \n \n \n \n \n \n\tcase V4L2_CID_MPEG_VIDEO_BITRATE_MODE: {\n\t\tuint peak_bitrate = dev->video_bitrate_peak->val / 100000;\n\t\tuint bitrate = dev->video_bitrate->val / 100000;\n\n\t\tif (ctrl->is_new) {\n\t\t\tif (ctrl->val == V4L2_MPEG_VIDEO_BITRATE_MODE_CBR)\n\t\t\t\topt->bitrate_mode = HDPVR_CONSTANT;\n\t\t\telse\n\t\t\t\topt->bitrate_mode = HDPVR_VARIABLE_AVERAGE;\n\t\t\thdpvr_config_call(dev, CTRL_BITRATE_MODE_VALUE,\n\t\t\t\t\t  opt->bitrate_mode);\n\t\t\tv4l2_ctrl_activate(dev->video_bitrate_peak,\n\t\t\t\tctrl->val != V4L2_MPEG_VIDEO_BITRATE_MODE_CBR);\n\t\t}\n\n\t\tif (dev->video_bitrate_peak->is_new ||\n\t\t    dev->video_bitrate->is_new) {\n\t\t\topt->bitrate = bitrate;\n\t\t\topt->peak_bitrate = peak_bitrate;\n\t\t\thdpvr_set_bitrate(dev);\n\t\t}\n\t\treturn 0;\n\t}\n\tcase V4L2_CID_MPEG_STREAM_TYPE:\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *private_data,\n\t\t\t\t    struct v4l2_fmtdesc *f)\n{\n\tif (f->index != 0)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = V4L2_PIX_FMT_MPEG;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *_fh,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct hdpvr_device *dev = video_drvdata(file);\n\tstruct hdpvr_fh *fh = _fh;\n\tint ret;\n\n\t \n\tif (fh->legacy_mode) {\n\t\tstruct hdpvr_video_info vid_info;\n\n\t\tret = get_video_info(dev, &vid_info);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (!vid_info.valid)\n\t\t\treturn -EFAULT;\n\t\tf->fmt.pix.width = vid_info.width;\n\t\tf->fmt.pix.height = vid_info.height;\n\t} else {\n\t\tf->fmt.pix.width = dev->width;\n\t\tf->fmt.pix.height = dev->height;\n\t}\n\tf->fmt.pix.pixelformat\t= V4L2_PIX_FMT_MPEG;\n\tf->fmt.pix.sizeimage\t= dev->bulk_in_size;\n\tf->fmt.pix.bytesperline\t= 0;\n\tif (f->fmt.pix.width == 720) {\n\t\t \n\t\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\t\tf->fmt.pix.field = V4L2_FIELD_INTERLACED;\n\t} else {\n\t\t \n\t\tf->fmt.pix.colorspace = V4L2_COLORSPACE_REC709;\n\t\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_encoder_cmd(struct file *filp, void *priv,\n\t\t\t       struct v4l2_encoder_cmd *a)\n{\n\tstruct hdpvr_device *dev = video_drvdata(filp);\n\tint res = 0;\n\n\tmutex_lock(&dev->io_mutex);\n\ta->flags = 0;\n\n\tswitch (a->cmd) {\n\tcase V4L2_ENC_CMD_START:\n\t\tif (dev->owner && filp->private_data != dev->owner) {\n\t\t\tres = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t\tif (dev->status == STATUS_STREAMING)\n\t\t\tbreak;\n\t\tres = hdpvr_start_streaming(dev);\n\t\tif (!res)\n\t\t\tdev->owner = filp->private_data;\n\t\telse\n\t\t\tdev->status = STATUS_IDLE;\n\t\tbreak;\n\tcase V4L2_ENC_CMD_STOP:\n\t\tif (dev->owner && filp->private_data != dev->owner) {\n\t\t\tres = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t\tif (dev->status == STATUS_IDLE)\n\t\t\tbreak;\n\t\tres = hdpvr_stop_streaming(dev);\n\t\tif (!res)\n\t\t\tdev->owner = NULL;\n\t\tbreak;\n\tdefault:\n\t\tv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\n\t\t\t \"Unsupported encoder cmd %d\\n\", a->cmd);\n\t\tres = -EINVAL;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&dev->io_mutex);\n\treturn res;\n}\n\nstatic int vidioc_try_encoder_cmd(struct file *filp, void *priv,\n\t\t\t\t\tstruct v4l2_encoder_cmd *a)\n{\n\ta->flags = 0;\n\tswitch (a->cmd) {\n\tcase V4L2_ENC_CMD_START:\n\tcase V4L2_ENC_CMD_STOP:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct v4l2_ioctl_ops hdpvr_ioctl_ops = {\n\t.vidioc_querycap\t= vidioc_querycap,\n\t.vidioc_s_std\t\t= vidioc_s_std,\n\t.vidioc_g_std\t\t= vidioc_g_std,\n\t.vidioc_querystd\t= vidioc_querystd,\n\t.vidioc_s_dv_timings\t= vidioc_s_dv_timings,\n\t.vidioc_g_dv_timings\t= vidioc_g_dv_timings,\n\t.vidioc_query_dv_timings= vidioc_query_dv_timings,\n\t.vidioc_enum_dv_timings\t= vidioc_enum_dv_timings,\n\t.vidioc_dv_timings_cap\t= vidioc_dv_timings_cap,\n\t.vidioc_enum_input\t= vidioc_enum_input,\n\t.vidioc_g_input\t\t= vidioc_g_input,\n\t.vidioc_s_input\t\t= vidioc_s_input,\n\t.vidioc_enumaudio\t= vidioc_enumaudio,\n\t.vidioc_g_audio\t\t= vidioc_g_audio,\n\t.vidioc_s_audio\t\t= vidioc_s_audio,\n\t.vidioc_enum_fmt_vid_cap= vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t= vidioc_g_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t= vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t= vidioc_g_fmt_vid_cap,\n\t.vidioc_encoder_cmd\t= vidioc_encoder_cmd,\n\t.vidioc_try_encoder_cmd\t= vidioc_try_encoder_cmd,\n\t.vidioc_log_status\t= v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic void hdpvr_device_release(struct video_device *vdev)\n{\n\tstruct hdpvr_device *dev = video_get_drvdata(vdev);\n\n\thdpvr_delete(dev);\n\tflush_work(&dev->worker);\n\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tv4l2_ctrl_handler_free(&dev->hdl);\n\n\t \n#if IS_ENABLED(CONFIG_I2C)\n\tmutex_lock(&dev->i2c_mutex);\n\ti2c_del_adapter(&dev->i2c_adapter);\n\tmutex_unlock(&dev->i2c_mutex);\n#endif  \n\n\tkfree(dev->usbc_buf);\n\tkfree(dev);\n}\n\nstatic const struct video_device hdpvr_video_template = {\n\t.fops\t\t\t= &hdpvr_fops,\n\t.release\t\t= hdpvr_device_release,\n\t.ioctl_ops\t\t= &hdpvr_ioctl_ops,\n\t.tvnorms\t\t= V4L2_STD_ALL,\n\t.device_caps\t\t= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_AUDIO |\n\t\t\t\t  V4L2_CAP_READWRITE,\n};\n\nstatic const struct v4l2_ctrl_ops hdpvr_ctrl_ops = {\n\t.try_ctrl = hdpvr_try_ctrl,\n\t.s_ctrl = hdpvr_s_ctrl,\n};\n\nint hdpvr_register_videodev(struct hdpvr_device *dev, struct device *parent,\n\t\t\t    int devnum)\n{\n\tstruct v4l2_ctrl_handler *hdl = &dev->hdl;\n\tbool ac3 = dev->flags & HDPVR_FLAG_AC3_CAP;\n\tint res;\n\n\t\n\tINIT_WORK(&dev->worker, hdpvr_transmit_buffers);\n\n\tdev->cur_std = V4L2_STD_525_60;\n\tdev->width = 720;\n\tdev->height = 480;\n\tdev->cur_dv_timings = hdpvr_dv_timings[HDPVR_DEF_DV_TIMINGS_IDX];\n\tv4l2_ctrl_handler_init(hdl, 11);\n\tif (dev->fw_ver > 0x15) {\n\t\tv4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0x0, 0xff, 1, 0x80);\n\t\tv4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0x0, 0xff, 1, 0x40);\n\t\tv4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0x0, 0xff, 1, 0x40);\n\t\tv4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\n\t\t\tV4L2_CID_HUE, 0x0, 0x1e, 1, 0xf);\n\t\tv4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\n\t\t\tV4L2_CID_SHARPNESS, 0x0, 0xff, 1, 0x80);\n\t} else {\n\t\tv4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0x0, 0xff, 1, 0x86);\n\t\tv4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0x0, 0xff, 1, 0x80);\n\t\tv4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0x0, 0xff, 1, 0x80);\n\t\tv4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\n\t\t\tV4L2_CID_HUE, 0x0, 0xff, 1, 0x80);\n\t\tv4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\n\t\t\tV4L2_CID_SHARPNESS, 0x0, 0xff, 1, 0x80);\n\t}\n\n\tv4l2_ctrl_new_std_menu(hdl, &hdpvr_ctrl_ops,\n\t\tV4L2_CID_MPEG_STREAM_TYPE,\n\t\tV4L2_MPEG_STREAM_TYPE_MPEG2_TS,\n\t\t0x1, V4L2_MPEG_STREAM_TYPE_MPEG2_TS);\n\tv4l2_ctrl_new_std_menu(hdl, &hdpvr_ctrl_ops,\n\t\tV4L2_CID_MPEG_AUDIO_ENCODING,\n\t\tac3 ? V4L2_MPEG_AUDIO_ENCODING_AC3 : V4L2_MPEG_AUDIO_ENCODING_AAC,\n\t\t0x7, ac3 ? dev->options.audio_codec : V4L2_MPEG_AUDIO_ENCODING_AAC);\n\tv4l2_ctrl_new_std_menu(hdl, &hdpvr_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_ENCODING,\n\t\tV4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC, 0x3,\n\t\tV4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC);\n\n\tdev->video_mode = v4l2_ctrl_new_std_menu(hdl, &hdpvr_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_BITRATE_MODE,\n\t\tV4L2_MPEG_VIDEO_BITRATE_MODE_CBR, 0,\n\t\tV4L2_MPEG_VIDEO_BITRATE_MODE_CBR);\n\n\tdev->video_bitrate = v4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_BITRATE,\n\t\t1000000, 13500000, 100000, 6500000);\n\tdev->video_bitrate_peak = v4l2_ctrl_new_std(hdl, &hdpvr_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_BITRATE_PEAK,\n\t\t1100000, 20200000, 100000, 9000000);\n\tdev->v4l2_dev.ctrl_handler = hdl;\n\tif (hdl->error) {\n\t\tres = hdl->error;\n\t\tv4l2_err(&dev->v4l2_dev, \"Could not register controls\\n\");\n\t\tgoto error;\n\t}\n\tv4l2_ctrl_cluster(3, &dev->video_mode);\n\tres = v4l2_ctrl_handler_setup(hdl);\n\tif (res < 0) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Could not setup controls\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tdev->video_dev = hdpvr_video_template;\n\tstrscpy(dev->video_dev.name, \"Hauppauge HD PVR\",\n\t\tsizeof(dev->video_dev.name));\n\tdev->video_dev.v4l2_dev = &dev->v4l2_dev;\n\tvideo_set_drvdata(&dev->video_dev, dev);\n\n\tres = video_register_device(&dev->video_dev, VFL_TYPE_VIDEO, devnum);\n\tif (res < 0) {\n\t\tv4l2_err(&dev->v4l2_dev, \"video_device registration failed\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\nerror:\n\tv4l2_ctrl_handler_free(hdl);\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}