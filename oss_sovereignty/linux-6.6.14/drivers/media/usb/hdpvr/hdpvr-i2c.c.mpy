{
  "module_name": "hdpvr-i2c.c",
  "hash_id": "2b931189b65b306dae941e5e24f8ad0b2bdc624af8e46517d7f4fd790e9a9f4e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/hdpvr/hdpvr-i2c.c",
  "human_readable_source": "\n\n \n\n#if IS_ENABLED(CONFIG_I2C)\n\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\n#include \"hdpvr.h\"\n\n#define CTRL_READ_REQUEST\t0xb8\n#define CTRL_WRITE_REQUEST\t0x38\n\n#define REQTYPE_I2C_READ\t0xb1\n#define REQTYPE_I2C_WRITE\t0xb0\n#define REQTYPE_I2C_WRITE_STATT\t0xd0\n\n#define Z8F0811_IR_TX_I2C_ADDR\t0x70\n#define Z8F0811_IR_RX_I2C_ADDR\t0x71\n\n\nstruct i2c_client *hdpvr_register_ir_i2c(struct hdpvr_device *dev)\n{\n\tstruct IR_i2c_init_data *init_data = &dev->ir_i2c_init_data;\n\tstruct i2c_board_info info = {\n\t\tI2C_BOARD_INFO(\"ir_z8f0811_hdpvr\", Z8F0811_IR_RX_I2C_ADDR),\n\t};\n\n\t \n\tinit_data->ir_codes = RC_MAP_HAUPPAUGE;\n\tinit_data->internal_get_key_func = IR_KBD_GET_KEY_HAUP_XVR;\n\tinit_data->type = RC_PROTO_BIT_RC5 | RC_PROTO_BIT_RC6_MCE |\n\t\t\t  RC_PROTO_BIT_RC6_6A_32;\n\tinit_data->name = \"HD-PVR\";\n\tinit_data->polling_interval = 405;  \n\tinfo.platform_data = init_data;\n\n\treturn i2c_new_client_device(&dev->i2c_adapter, &info);\n}\n\nstatic int hdpvr_i2c_read(struct hdpvr_device *dev, int bus,\n\t\t\t  unsigned char addr, char *wdata, int wlen,\n\t\t\t  char *data, int len)\n{\n\tint ret;\n\n\tif ((len > sizeof(dev->i2c_buf)) || (wlen > sizeof(dev->i2c_buf)))\n\t\treturn -EINVAL;\n\n\tif (wlen) {\n\t\tmemcpy(dev->i2c_buf, wdata, wlen);\n\t\tret = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\t\t\t      REQTYPE_I2C_WRITE, CTRL_WRITE_REQUEST,\n\t\t\t\t      (bus << 8) | addr, 0, dev->i2c_buf,\n\t\t\t\t      wlen, 1000);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t      REQTYPE_I2C_READ, CTRL_READ_REQUEST,\n\t\t\t      (bus << 8) | addr, 0, dev->i2c_buf, len, 1000);\n\n\tif (ret == len) {\n\t\tmemcpy(data, dev->i2c_buf, len);\n\t\tret = 0;\n\t} else if (ret >= 0)\n\t\tret = -EIO;\n\n\treturn ret;\n}\n\nstatic int hdpvr_i2c_write(struct hdpvr_device *dev, int bus,\n\t\t\t   unsigned char addr, char *data, int len)\n{\n\tint ret;\n\n\tif (len > sizeof(dev->i2c_buf))\n\t\treturn -EINVAL;\n\n\tmemcpy(dev->i2c_buf, data, len);\n\tret = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\t\t      REQTYPE_I2C_WRITE, CTRL_WRITE_REQUEST,\n\t\t\t      (bus << 8) | addr, 0, dev->i2c_buf, len, 1000);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t      REQTYPE_I2C_WRITE_STATT, CTRL_READ_REQUEST,\n\t\t\t      0, 0, dev->i2c_buf, 2, 1000);\n\n\tif ((ret == 2) && (dev->i2c_buf[1] == (len - 1)))\n\t\tret = 0;\n\telse if (ret >= 0)\n\t\tret = -EIO;\n\n\treturn ret;\n}\n\nstatic int hdpvr_transfer(struct i2c_adapter *i2c_adapter, struct i2c_msg *msgs,\n\t\t\t  int num)\n{\n\tstruct hdpvr_device *dev = i2c_get_adapdata(i2c_adapter);\n\tint retval = 0, addr;\n\n\tmutex_lock(&dev->i2c_mutex);\n\n\taddr = msgs[0].addr << 1;\n\n\tif (num == 1) {\n\t\tif (msgs[0].flags & I2C_M_RD)\n\t\t\tretval = hdpvr_i2c_read(dev, 1, addr, NULL, 0,\n\t\t\t\t\t\tmsgs[0].buf, msgs[0].len);\n\t\telse\n\t\t\tretval = hdpvr_i2c_write(dev, 1, addr, msgs[0].buf,\n\t\t\t\t\t\t msgs[0].len);\n\t} else if (num == 2) {\n\t\tif (msgs[0].addr != msgs[1].addr) {\n\t\t\tv4l2_warn(&dev->v4l2_dev, \"refusing 2-phase i2c xfer with conflicting target addresses\\n\");\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif ((msgs[0].flags & I2C_M_RD) || !(msgs[1].flags & I2C_M_RD)) {\n\t\t\tv4l2_warn(&dev->v4l2_dev, \"refusing complex xfer with r0=%d, r1=%d\\n\",\n\t\t\t\t  msgs[0].flags & I2C_M_RD,\n\t\t\t\t  msgs[1].flags & I2C_M_RD);\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tretval = hdpvr_i2c_read(dev, 1, addr, msgs[0].buf, msgs[0].len,\n\t\t\t\t\tmsgs[1].buf, msgs[1].len);\n\t} else {\n\t\tv4l2_warn(&dev->v4l2_dev, \"refusing %d-phase i2c xfer\\n\", num);\n\t}\n\nout:\n\tmutex_unlock(&dev->i2c_mutex);\n\n\treturn retval ? retval : num;\n}\n\nstatic u32 hdpvr_functionality(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm hdpvr_algo = {\n\t.master_xfer   = hdpvr_transfer,\n\t.functionality = hdpvr_functionality,\n};\n\nstatic const struct i2c_adapter hdpvr_i2c_adapter_template = {\n\t.name   = \"Hauppauge HD PVR I2C\",\n\t.owner  = THIS_MODULE,\n\t.algo   = &hdpvr_algo,\n};\n\nstatic int hdpvr_activate_ir(struct hdpvr_device *dev)\n{\n\tchar buffer[2];\n\n\tmutex_lock(&dev->i2c_mutex);\n\n\thdpvr_i2c_read(dev, 0, 0x54, NULL, 0, buffer, 1);\n\n\tbuffer[0] = 0;\n\tbuffer[1] = 0x8;\n\thdpvr_i2c_write(dev, 1, 0x54, buffer, 2);\n\n\tbuffer[1] = 0x18;\n\thdpvr_i2c_write(dev, 1, 0x54, buffer, 2);\n\n\tmutex_unlock(&dev->i2c_mutex);\n\n\treturn 0;\n}\n\nint hdpvr_register_i2c_adapter(struct hdpvr_device *dev)\n{\n\thdpvr_activate_ir(dev);\n\n\tdev->i2c_adapter = hdpvr_i2c_adapter_template;\n\tdev->i2c_adapter.dev.parent = &dev->udev->dev;\n\n\ti2c_set_adapdata(&dev->i2c_adapter, dev);\n\n\treturn i2c_add_adapter(&dev->i2c_adapter);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}