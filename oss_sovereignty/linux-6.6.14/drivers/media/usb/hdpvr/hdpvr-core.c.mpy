{
  "module_name": "hdpvr-core.c",
  "hash_id": "a8788f821161d653d4a371e3154ad83b488b3c98e01ec06d13e38973c667c501",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/hdpvr/hdpvr-core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/atomic.h>\n#include <linux/usb.h>\n#include <linux/mutex.h>\n#include <linux/i2c.h>\n\n#include <linux/videodev2.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-common.h>\n\n#include \"hdpvr.h\"\n\nstatic int video_nr[HDPVR_MAX] = {[0 ... (HDPVR_MAX - 1)] = UNSET};\nmodule_param_array(video_nr, int, NULL, 0);\nMODULE_PARM_DESC(video_nr, \"video device number (-1=Auto)\");\n\n \nstatic atomic_t dev_nr = ATOMIC_INIT(-1);\n\nint hdpvr_debug;\nmodule_param(hdpvr_debug, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(hdpvr_debug, \"enable debugging output\");\n\nstatic uint default_video_input = HDPVR_VIDEO_INPUTS;\nmodule_param(default_video_input, uint, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(default_video_input, \"default video input: 0=Component / 1=S-Video / 2=Composite\");\n\nstatic uint default_audio_input = HDPVR_AUDIO_INPUTS;\nmodule_param(default_audio_input, uint, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(default_audio_input, \"default audio input: 0=RCA back / 1=RCA front / 2=S/PDIF\");\n\nstatic bool boost_audio;\nmodule_param(boost_audio, bool, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(boost_audio, \"boost the audio signal\");\n\n\n \nstatic const struct usb_device_id hdpvr_table[] = {\n\t{ USB_DEVICE(HD_PVR_VENDOR_ID, HD_PVR_PRODUCT_ID) },\n\t{ USB_DEVICE(HD_PVR_VENDOR_ID, HD_PVR_PRODUCT_ID1) },\n\t{ USB_DEVICE(HD_PVR_VENDOR_ID, HD_PVR_PRODUCT_ID2) },\n\t{ USB_DEVICE(HD_PVR_VENDOR_ID, HD_PVR_PRODUCT_ID3) },\n\t{ USB_DEVICE(HD_PVR_VENDOR_ID, HD_PVR_PRODUCT_ID4) },\n\t{ }\t\t\t\t\t \n};\nMODULE_DEVICE_TABLE(usb, hdpvr_table);\n\n\nvoid hdpvr_delete(struct hdpvr_device *dev)\n{\n\thdpvr_free_buffers(dev);\n\tusb_put_dev(dev->udev);\n}\n\nstatic void challenge(u8 *bytes)\n{\n\t__le64 *i64P;\n\tu64 tmp64;\n\tuint i, idx;\n\n\tfor (idx = 0; idx < 32; ++idx) {\n\n\t\tif (idx & 0x3)\n\t\t\tbytes[(idx >> 3) + 3] = bytes[(idx >> 2) & 0x3];\n\n\t\tswitch (idx & 0x3) {\n\t\tcase 0x3:\n\t\t\tbytes[2] += bytes[3] * 4 + bytes[4] + bytes[5];\n\t\t\tbytes[4] += bytes[(idx & 0x1) * 2] * 9 + 9;\n\t\t\tbreak;\n\t\tcase 0x1:\n\t\t\tbytes[0] *= 8;\n\t\t\tbytes[0] += 7*idx + 4;\n\t\t\tbytes[6] += bytes[3] * 3;\n\t\t\tbreak;\n\t\tcase 0x0:\n\t\t\tbytes[3 - (idx >> 3)] = bytes[idx >> 2];\n\t\t\tbytes[5] += bytes[6] * 3;\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tbytes[3] *= bytes[3] + 1;\n\t\t\tbreak;\n\t\tcase 0x2:\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tbytes[1] *= bytes[6] + 1;\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\ti64P = (__le64 *)bytes;\n\t\t\t\ttmp64 = le64_to_cpup(i64P);\n\t\t\t\ttmp64 = tmp64 + (tmp64 << (bytes[7] & 0x0f));\n\t\t\t\t*i64P = cpu_to_le64(tmp64);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic int device_authorization(struct hdpvr_device *dev)\n{\n\n\tint ret, retval = -ENOMEM;\n\tchar request_type = 0x38, rcv_request = 0x81;\n\tchar *response;\n\n\tmutex_lock(&dev->usbc_mutex);\n\tret = usb_control_msg(dev->udev,\n\t\t\t      usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t      rcv_request, 0x80 | request_type,\n\t\t\t      0x0400, 0x0003,\n\t\t\t      dev->usbc_buf, 46,\n\t\t\t      10000);\n\tif (ret != 46) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"unexpected answer of status request, len %d\\n\", ret);\n\t\tgoto unlock;\n\t}\n#ifdef HDPVR_DEBUG\n\telse {\n\t\tv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\n\t\t\t \"Status request returned, len %d: %46ph\\n\",\n\t\t\t ret, dev->usbc_buf);\n\t}\n#endif\n\n\tdev->fw_ver = dev->usbc_buf[1];\n\n\tdev->usbc_buf[46] = '\\0';\n\tv4l2_info(&dev->v4l2_dev, \"firmware version 0x%x dated %s\\n\",\n\t\t\t  dev->fw_ver, &dev->usbc_buf[2]);\n\n\tif (dev->fw_ver > 0x15) {\n\t\tdev->options.brightness\t= 0x80;\n\t\tdev->options.contrast\t= 0x40;\n\t\tdev->options.hue\t= 0xf;\n\t\tdev->options.saturation\t= 0x40;\n\t\tdev->options.sharpness\t= 0x80;\n\t}\n\n\tswitch (dev->fw_ver) {\n\tcase HDPVR_FIRMWARE_VERSION:\n\t\tdev->flags &= ~HDPVR_FLAG_AC3_CAP;\n\t\tbreak;\n\tcase HDPVR_FIRMWARE_VERSION_AC3:\n\tcase HDPVR_FIRMWARE_VERSION_0X12:\n\tcase HDPVR_FIRMWARE_VERSION_0X15:\n\tcase HDPVR_FIRMWARE_VERSION_0X1E:\n\t\tdev->flags |= HDPVR_FLAG_AC3_CAP;\n\t\tbreak;\n\tdefault:\n\t\tv4l2_info(&dev->v4l2_dev, \"untested firmware, the driver might not work.\\n\");\n\t\tif (dev->fw_ver >= HDPVR_FIRMWARE_VERSION_AC3)\n\t\t\tdev->flags |= HDPVR_FLAG_AC3_CAP;\n\t\telse\n\t\t\tdev->flags &= ~HDPVR_FLAG_AC3_CAP;\n\t}\n\n\tresponse = dev->usbc_buf+38;\n#ifdef HDPVR_DEBUG\n\tv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev, \"challenge: %8ph\\n\",\n\t\t response);\n#endif\n\tchallenge(response);\n#ifdef HDPVR_DEBUG\n\tv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev, \" response: %8ph\\n\",\n\t\t response);\n#endif\n\n\tmsleep(100);\n\tret = usb_control_msg(dev->udev,\n\t\t\t      usb_sndctrlpipe(dev->udev, 0),\n\t\t\t      0xd1, 0x00 | request_type,\n\t\t\t      0x0000, 0x0000,\n\t\t\t      response, 8,\n\t\t\t      10000);\n\tv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\n\t\t \"magic request returned %d\\n\", ret);\n\n\tretval = ret != 8;\nunlock:\n\tmutex_unlock(&dev->usbc_mutex);\n\treturn retval;\n}\n\nstatic int hdpvr_device_init(struct hdpvr_device *dev)\n{\n\tint ret;\n\tu8 *buf;\n\n\tif (device_authorization(dev))\n\t\treturn -EACCES;\n\n\t \n\thdpvr_set_options(dev);\n\n\t \n\tmutex_lock(&dev->usbc_mutex);\n\tbuf = dev->usbc_buf;\n\tbuf[0] = 0x03; buf[1] = 0x03; buf[2] = 0x00; buf[3] = 0x00;\n\tret = usb_control_msg(dev->udev,\n\t\t\t      usb_sndctrlpipe(dev->udev, 0),\n\t\t\t      0x01, 0x38,\n\t\t\t      CTRL_LOW_PASS_FILTER_VALUE, CTRL_DEFAULT_INDEX,\n\t\t\t      buf, 4,\n\t\t\t      1000);\n\tv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\n\t\t \"control request returned %d\\n\", ret);\n\tmutex_unlock(&dev->usbc_mutex);\n\n\t \n\tmutex_lock(&dev->usbc_mutex);\n\tbuf[0] = 0x1;\n\tret = usb_control_msg(dev->udev,\n\t\t\t      usb_sndctrlpipe(dev->udev, 0),\n\t\t\t      0xd4, 0x38, 0, 0, buf, 1,\n\t\t\t      1000);\n\tv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\n\t\t \"control request returned %d\\n\", ret);\n\n\t \n\tbuf[0] = boost_audio;\n\tret = usb_control_msg(dev->udev,\n\t\t\t      usb_sndctrlpipe(dev->udev, 0),\n\t\t\t      0xd5, 0x38, 0, 0, buf, 1,\n\t\t\t      1000);\n\tv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\n\t\t \"control request returned %d\\n\", ret);\n\tmutex_unlock(&dev->usbc_mutex);\n\n\tdev->status = STATUS_IDLE;\n\treturn 0;\n}\n\nstatic const struct hdpvr_options hdpvr_default_options = {\n\t.video_std\t= HDPVR_60HZ,\n\t.video_input\t= HDPVR_COMPONENT,\n\t.audio_input\t= HDPVR_RCA_BACK,\n\t.bitrate\t= 65,  \n\t.peak_bitrate\t= 90,  \n\t.bitrate_mode\t= HDPVR_CONSTANT,\n\t.gop_mode\t= HDPVR_SIMPLE_IDR_GOP,\n\t.audio_codec\t= V4L2_MPEG_AUDIO_ENCODING_AAC,\n\t \n\t \n\t.brightness\t= 0x86,\n\t.contrast\t= 0x80,\n\t.hue\t\t= 0x80,\n\t.saturation\t= 0x80,\n\t.sharpness\t= 0x80,\n};\n\nstatic int hdpvr_probe(struct usb_interface *interface,\n\t\t       const struct usb_device_id *id)\n{\n\tstruct hdpvr_device *dev;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n#if IS_ENABLED(CONFIG_I2C)\n\tstruct i2c_client *client;\n#endif\n\tsize_t buffer_size;\n\tint i;\n\tint dev_num;\n\tint retval = -ENOMEM;\n\n\t \n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tdev_err(&interface->dev, \"Out of memory\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\t \n\tINIT_LIST_HEAD(&dev->free_buff_list);\n\tINIT_LIST_HEAD(&dev->rec_buff_list);\n\n\t \n\tif (v4l2_device_register(&interface->dev, &dev->v4l2_dev)) {\n\t\tdev_err(&interface->dev, \"v4l2_device_register failed\\n\");\n\t\tgoto error_free_dev;\n\t}\n\n\tmutex_init(&dev->io_mutex);\n\tmutex_init(&dev->i2c_mutex);\n\tmutex_init(&dev->usbc_mutex);\n\tdev->usbc_buf = kmalloc(64, GFP_KERNEL);\n\tif (!dev->usbc_buf) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Out of memory\\n\");\n\t\tgoto error_v4l2_unregister;\n\t}\n\n\tinit_waitqueue_head(&dev->wait_buffer);\n\tinit_waitqueue_head(&dev->wait_data);\n\n\tdev->options = hdpvr_default_options;\n\n\tif (default_video_input < HDPVR_VIDEO_INPUTS)\n\t\tdev->options.video_input = default_video_input;\n\n\tif (default_audio_input < HDPVR_AUDIO_INPUTS) {\n\t\tdev->options.audio_input = default_audio_input;\n\t\tif (default_audio_input == HDPVR_SPDIF)\n\t\t\tdev->options.audio_codec =\n\t\t\t\tV4L2_MPEG_AUDIO_ENCODING_AC3;\n\t}\n\n\tdev->udev = usb_get_dev(interface_to_usbdev(interface));\n\n\t \n\t \n\tiface_desc = interface->cur_altsetting;\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tif (!dev->bulk_in_endpointAddr &&\n\t\t    usb_endpoint_is_bulk_in(endpoint)) {\n\t\t\t \n\t\t\tbuffer_size = 8192;\n\t\t\tdev->bulk_in_size = buffer_size;\n\t\t\tdev->bulk_in_endpointAddr = endpoint->bEndpointAddress;\n\t\t}\n\n\t}\n\tif (!dev->bulk_in_endpointAddr) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Could not find bulk-in endpoint\\n\");\n\t\tgoto error_put_usb;\n\t}\n\n\t \n\tif (hdpvr_device_init(dev)) {\n\t\tv4l2_err(&dev->v4l2_dev, \"device init failed\\n\");\n\t\tgoto error_put_usb;\n\t}\n\n\tmutex_lock(&dev->io_mutex);\n\tif (hdpvr_alloc_buffers(dev, NUM_BUFFERS)) {\n\t\tmutex_unlock(&dev->io_mutex);\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"allocating transfer buffers failed\\n\");\n\t\tgoto error_put_usb;\n\t}\n\tmutex_unlock(&dev->io_mutex);\n\n#if IS_ENABLED(CONFIG_I2C)\n\tretval = hdpvr_register_i2c_adapter(dev);\n\tif (retval < 0) {\n\t\tv4l2_err(&dev->v4l2_dev, \"i2c adapter register failed\\n\");\n\t\tgoto error_free_buffers;\n\t}\n\n\tclient = hdpvr_register_ir_i2c(dev);\n\tif (IS_ERR(client)) {\n\t\tv4l2_err(&dev->v4l2_dev, \"i2c IR device register failed\\n\");\n\t\tretval = PTR_ERR(client);\n\t\tgoto reg_fail;\n\t}\n#endif\n\n\tdev_num = atomic_inc_return(&dev_nr);\n\tif (dev_num >= HDPVR_MAX) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"max device number reached, device register failed\\n\");\n\t\tatomic_dec(&dev_nr);\n\t\tretval = -ENODEV;\n\t\tgoto reg_fail;\n\t}\n\n\tretval = hdpvr_register_videodev(dev, &interface->dev,\n\t\t\t\t    video_nr[dev_num]);\n\tif (retval < 0) {\n\t\tv4l2_err(&dev->v4l2_dev, \"registering videodev failed\\n\");\n\t\tgoto reg_fail;\n\t}\n\n\t \n\tv4l2_info(&dev->v4l2_dev, \"device now attached to %s\\n\",\n\t\t  video_device_node_name(&dev->video_dev));\n\treturn 0;\n\nreg_fail:\n#if IS_ENABLED(CONFIG_I2C)\n\ti2c_del_adapter(&dev->i2c_adapter);\nerror_free_buffers:\n#endif\n\thdpvr_free_buffers(dev);\nerror_put_usb:\n\tusb_put_dev(dev->udev);\n\tkfree(dev->usbc_buf);\nerror_v4l2_unregister:\n\tv4l2_device_unregister(&dev->v4l2_dev);\nerror_free_dev:\n\tkfree(dev);\nerror:\n\treturn retval;\n}\n\nstatic void hdpvr_disconnect(struct usb_interface *interface)\n{\n\tstruct hdpvr_device *dev = to_hdpvr_dev(usb_get_intfdata(interface));\n\n\tv4l2_info(&dev->v4l2_dev, \"device %s disconnected\\n\",\n\t\t  video_device_node_name(&dev->video_dev));\n\t \n\tmutex_lock(&dev->io_mutex);\n\tdev->status = STATUS_DISCONNECTED;\n\twake_up_interruptible(&dev->wait_data);\n\twake_up_interruptible(&dev->wait_buffer);\n\tmutex_unlock(&dev->io_mutex);\n\tv4l2_device_disconnect(&dev->v4l2_dev);\n\tmsleep(100);\n\tflush_work(&dev->worker);\n\tmutex_lock(&dev->io_mutex);\n\thdpvr_cancel_queue(dev);\n\tmutex_unlock(&dev->io_mutex);\n#if IS_ENABLED(CONFIG_I2C)\n\ti2c_del_adapter(&dev->i2c_adapter);\n#endif\n\tvideo_unregister_device(&dev->video_dev);\n\tatomic_dec(&dev_nr);\n}\n\n\nstatic struct usb_driver hdpvr_usb_driver = {\n\t.name =\t\t\"hdpvr\",\n\t.probe =\thdpvr_probe,\n\t.disconnect =\thdpvr_disconnect,\n\t.id_table =\thdpvr_table,\n};\n\nmodule_usb_driver(hdpvr_usb_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.2.1\");\nMODULE_AUTHOR(\"Janne Grunau\");\nMODULE_DESCRIPTION(\"Hauppauge HD PVR driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}