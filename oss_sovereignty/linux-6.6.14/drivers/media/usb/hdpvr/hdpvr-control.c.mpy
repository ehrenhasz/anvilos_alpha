{
  "module_name": "hdpvr-control.c",
  "hash_id": "902e02bb27a76ba5469173c10071f9fc0294c47006397f327188d8cc024d8998",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/hdpvr/hdpvr-control.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/mutex.h>\n\n#include <linux/videodev2.h>\n\n#include <media/v4l2-common.h>\n\n#include \"hdpvr.h\"\n\n\nint hdpvr_config_call(struct hdpvr_device *dev, uint value, u8 valbuf)\n{\n\tint ret;\n\tchar request_type = 0x38, snd_request = 0x01;\n\n\tmutex_lock(&dev->usbc_mutex);\n\tdev->usbc_buf[0] = valbuf;\n\tret = usb_control_msg(dev->udev,\n\t\t\t      usb_sndctrlpipe(dev->udev, 0),\n\t\t\t      snd_request, 0x00 | request_type,\n\t\t\t      value, CTRL_DEFAULT_INDEX,\n\t\t\t      dev->usbc_buf, 1, 10000);\n\n\tmutex_unlock(&dev->usbc_mutex);\n\tv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\n\t\t \"config call request for value 0x%x returned %d\\n\", value,\n\t\t ret);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nint get_video_info(struct hdpvr_device *dev, struct hdpvr_video_info *vidinf)\n{\n\tint ret;\n\n\tvidinf->valid = false;\n\tmutex_lock(&dev->usbc_mutex);\n\tret = usb_control_msg(dev->udev,\n\t\t\t      usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t      0x81, 0x80 | 0x38,\n\t\t\t      0x1400, 0x0003,\n\t\t\t      dev->usbc_buf, 5,\n\t\t\t      1000);\n\n#ifdef HDPVR_DEBUG\n\tif (hdpvr_debug & MSG_INFO)\n\t\tv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\n\t\t\t \"get video info returned: %d, %5ph\\n\", ret,\n\t\t\t dev->usbc_buf);\n#endif\n\tmutex_unlock(&dev->usbc_mutex);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvidinf->width\t= dev->usbc_buf[1] << 8 | dev->usbc_buf[0];\n\tvidinf->height\t= dev->usbc_buf[3] << 8 | dev->usbc_buf[2];\n\tvidinf->fps\t= dev->usbc_buf[4];\n\tvidinf->valid   = vidinf->width && vidinf->height && vidinf->fps;\n\n\treturn 0;\n}\n\nint get_input_lines_info(struct hdpvr_device *dev)\n{\n\tint ret, lines;\n\n\tmutex_lock(&dev->usbc_mutex);\n\tret = usb_control_msg(dev->udev,\n\t\t\t      usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t      0x81, 0x80 | 0x38,\n\t\t\t      0x1800, 0x0003,\n\t\t\t      dev->usbc_buf, 3,\n\t\t\t      1000);\n\n#ifdef HDPVR_DEBUG\n\tif (hdpvr_debug & MSG_INFO)\n\t\tv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\n\t\t\t \"get input lines info returned: %d, %3ph\\n\", ret,\n\t\t\t dev->usbc_buf);\n#else\n\t(void)ret;\t \n#endif\n\tlines = dev->usbc_buf[1] << 8 | dev->usbc_buf[0];\n\tmutex_unlock(&dev->usbc_mutex);\n\treturn lines;\n}\n\n\nint hdpvr_set_bitrate(struct hdpvr_device *dev)\n{\n\tint ret;\n\n\tmutex_lock(&dev->usbc_mutex);\n\tmemset(dev->usbc_buf, 0, 4);\n\tdev->usbc_buf[0] = dev->options.bitrate;\n\tdev->usbc_buf[2] = dev->options.peak_bitrate;\n\n\tret = usb_control_msg(dev->udev,\n\t\t\t      usb_sndctrlpipe(dev->udev, 0),\n\t\t\t      0x01, 0x38, CTRL_BITRATE_VALUE,\n\t\t\t      CTRL_DEFAULT_INDEX, dev->usbc_buf, 4, 1000);\n\tmutex_unlock(&dev->usbc_mutex);\n\n\treturn ret;\n}\n\nint hdpvr_set_audio(struct hdpvr_device *dev, u8 input,\n\t\t    enum v4l2_mpeg_audio_encoding codec)\n{\n\tint ret = 0;\n\n\tif (dev->flags & HDPVR_FLAG_AC3_CAP) {\n\t\tmutex_lock(&dev->usbc_mutex);\n\t\tmemset(dev->usbc_buf, 0, 2);\n\t\tdev->usbc_buf[0] = input;\n\t\tif (codec == V4L2_MPEG_AUDIO_ENCODING_AAC)\n\t\t\tdev->usbc_buf[1] = 0;\n\t\telse if (codec == V4L2_MPEG_AUDIO_ENCODING_AC3)\n\t\t\tdev->usbc_buf[1] = 1;\n\t\telse {\n\t\t\tmutex_unlock(&dev->usbc_mutex);\n\t\t\tv4l2_err(&dev->v4l2_dev, \"invalid audio codec %d\\n\",\n\t\t\t\t codec);\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = usb_control_msg(dev->udev,\n\t\t\t\t      usb_sndctrlpipe(dev->udev, 0),\n\t\t\t\t      0x01, 0x38, CTRL_AUDIO_INPUT_VALUE,\n\t\t\t\t      CTRL_DEFAULT_INDEX, dev->usbc_buf, 2,\n\t\t\t\t      1000);\n\t\tmutex_unlock(&dev->usbc_mutex);\n\t\tif (ret == 2)\n\t\t\tret = 0;\n\t} else\n\t\tret = hdpvr_config_call(dev, CTRL_AUDIO_INPUT_VALUE, input);\nerror:\n\treturn ret;\n}\n\nint hdpvr_set_options(struct hdpvr_device *dev)\n{\n\thdpvr_config_call(dev, CTRL_VIDEO_STD_TYPE, dev->options.video_std);\n\n\thdpvr_config_call(dev, CTRL_VIDEO_INPUT_VALUE,\n\t\t\t dev->options.video_input+1);\n\n\thdpvr_set_audio(dev, dev->options.audio_input+1,\n\t\t       dev->options.audio_codec);\n\n\thdpvr_set_bitrate(dev);\n\thdpvr_config_call(dev, CTRL_BITRATE_MODE_VALUE,\n\t\t\t dev->options.bitrate_mode);\n\thdpvr_config_call(dev, CTRL_GOP_MODE_VALUE, dev->options.gop_mode);\n\n\thdpvr_config_call(dev, CTRL_BRIGHTNESS, dev->options.brightness);\n\thdpvr_config_call(dev, CTRL_CONTRAST,   dev->options.contrast);\n\thdpvr_config_call(dev, CTRL_HUE,        dev->options.hue);\n\thdpvr_config_call(dev, CTRL_SATURATION, dev->options.saturation);\n\thdpvr_config_call(dev, CTRL_SHARPNESS,  dev->options.sharpness);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}