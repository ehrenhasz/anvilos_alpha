{
  "module_name": "hackrf.c",
  "hash_id": "5c0f22db05f1db7faa8e17f3b103d2df294d8f37bb8d21ba189b6d6e431a87a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/hackrf/hackrf.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-vmalloc.h>\n\n \nstatic bool hackrf_enable_rf_gain_ctrl;\nmodule_param_named(enable_rf_gain_ctrl, hackrf_enable_rf_gain_ctrl, bool, 0644);\nMODULE_PARM_DESC(enable_rf_gain_ctrl, \"enable RX/TX RF amplifier control (warn: could damage amplifier)\");\n\n \nenum {\n\tCMD_SET_TRANSCEIVER_MODE           = 0x01,\n\tCMD_SAMPLE_RATE_SET                = 0x06,\n\tCMD_BASEBAND_FILTER_BANDWIDTH_SET  = 0x07,\n\tCMD_BOARD_ID_READ                  = 0x0e,\n\tCMD_VERSION_STRING_READ            = 0x0f,\n\tCMD_SET_FREQ                       = 0x10,\n\tCMD_AMP_ENABLE                     = 0x11,\n\tCMD_SET_LNA_GAIN                   = 0x13,\n\tCMD_SET_VGA_GAIN                   = 0x14,\n\tCMD_SET_TXVGA_GAIN                 = 0x15,\n};\n\n \n#define MAX_BULK_BUFS            (6)\n#define BULK_BUFFER_SIZE         (128 * 512)\n\nstatic const struct v4l2_frequency_band bands_adc_dac[] = {\n\t{\n\t\t.tuner = 0,\n\t\t.type = V4L2_TUNER_SDR,\n\t\t.index = 0,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   =   200000,\n\t\t.rangehigh  = 24000000,\n\t},\n};\n\nstatic const struct v4l2_frequency_band bands_rx_tx[] = {\n\t{\n\t\t.tuner = 1,\n\t\t.type = V4L2_TUNER_RF,\n\t\t.index = 0,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   =          1,\n\t\t.rangehigh  = 4294967294LL,  \n\t},\n};\n\n \nstruct hackrf_format {\n\tu32\tpixelformat;\n\tu32\tbuffersize;\n};\n\n \nstatic struct hackrf_format formats[] = {\n\t{\n\t\t.pixelformat\t= V4L2_SDR_FMT_CS8,\n\t\t.buffersize\t= BULK_BUFFER_SIZE,\n\t},\n};\n\nstatic const unsigned int NUM_FORMATS = ARRAY_SIZE(formats);\n\n \nstruct hackrf_buffer {\n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head list;\n};\n\nstruct hackrf_dev {\n#define USB_STATE_URB_BUF                1  \n#define RX_ON                            4\n#define TX_ON                            5\n#define RX_ADC_FREQUENCY                11\n#define TX_DAC_FREQUENCY                12\n#define RX_BANDWIDTH                    13\n#define TX_BANDWIDTH                    14\n#define RX_RF_FREQUENCY                 15\n#define TX_RF_FREQUENCY                 16\n#define RX_RF_GAIN                      17\n#define TX_RF_GAIN                      18\n#define RX_IF_GAIN                      19\n#define RX_LNA_GAIN                     20\n#define TX_LNA_GAIN                     21\n\tunsigned long flags;\n\n\tstruct usb_interface *intf;\n\tstruct device *dev;\n\tstruct usb_device *udev;\n\tstruct video_device rx_vdev;\n\tstruct video_device tx_vdev;\n\tstruct v4l2_device v4l2_dev;\n\n\t \n\tstruct vb2_queue rx_vb2_queue;\n\tstruct vb2_queue tx_vb2_queue;\n\tstruct list_head rx_buffer_list;\n\tstruct list_head tx_buffer_list;\n\tspinlock_t buffer_list_lock;  \n\tunsigned int sequence;\t      \n\tunsigned int vb_full;         \n\tunsigned int vb_empty;        \n\n\t \n\tstruct mutex v4l2_lock;       \n\tstruct mutex vb_queue_lock;   \n\n\tstruct urb     *urb_list[MAX_BULK_BUFS];\n\tint            buf_num;\n\tunsigned long  buf_size;\n\tu8             *buf_list[MAX_BULK_BUFS];\n\tdma_addr_t     dma_addr[MAX_BULK_BUFS];\n\tint            urbs_initialized;\n\tint            urbs_submitted;\n\n\t \n\t#define BUF_SIZE 24\n\tu8 buf[BUF_SIZE];\n\n\t \n\tunsigned int f_adc;\n\tunsigned int f_dac;\n\tunsigned int f_rx;\n\tunsigned int f_tx;\n\tu32 pixelformat;\n\tu32 buffersize;\n\n\t \n\tstruct v4l2_ctrl_handler rx_ctrl_handler;\n\tstruct v4l2_ctrl *rx_bandwidth_auto;\n\tstruct v4l2_ctrl *rx_bandwidth;\n\tstruct v4l2_ctrl *rx_rf_gain;\n\tstruct v4l2_ctrl *rx_lna_gain;\n\tstruct v4l2_ctrl *rx_if_gain;\n\tstruct v4l2_ctrl_handler tx_ctrl_handler;\n\tstruct v4l2_ctrl *tx_bandwidth_auto;\n\tstruct v4l2_ctrl *tx_bandwidth;\n\tstruct v4l2_ctrl *tx_rf_gain;\n\tstruct v4l2_ctrl *tx_lna_gain;\n\n\t \n\tunsigned long jiffies_next;\n\tunsigned int sample;\n\tunsigned int sample_measured;\n};\n\n#define hackrf_dbg_usb_control_msg(_dev, _r, _t, _v, _i, _b, _l) { \\\n\tchar *_direction; \\\n\tif (_t & USB_DIR_IN) \\\n\t\t_direction = \"<<<\"; \\\n\telse \\\n\t\t_direction = \">>>\"; \\\n\tdev_dbg(_dev, \"%02x %02x %02x %02x %02x %02x %02x %02x %s %*ph\\n\", \\\n\t\t\t_t, _r, _v & 0xff, _v >> 8, _i & 0xff, \\\n\t\t\t_i >> 8, _l & 0xff, _l >> 8, _direction, _l, _b); \\\n}\n\n \nstatic int hackrf_ctrl_msg(struct hackrf_dev *dev, u8 request, u16 value,\n\t\tu16 index, u8 *data, u16 size)\n{\n\tint ret;\n\tunsigned int pipe;\n\tu8 requesttype;\n\n\tswitch (request) {\n\tcase CMD_SET_TRANSCEIVER_MODE:\n\tcase CMD_SET_FREQ:\n\tcase CMD_AMP_ENABLE:\n\tcase CMD_SAMPLE_RATE_SET:\n\tcase CMD_BASEBAND_FILTER_BANDWIDTH_SET:\n\t\tpipe = usb_sndctrlpipe(dev->udev, 0);\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\n\t\tbreak;\n\tcase CMD_BOARD_ID_READ:\n\tcase CMD_VERSION_STRING_READ:\n\tcase CMD_SET_LNA_GAIN:\n\tcase CMD_SET_VGA_GAIN:\n\tcase CMD_SET_TXVGA_GAIN:\n\t\tpipe = usb_rcvctrlpipe(dev->udev, 0);\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"Unknown command %02x\\n\", request);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tif (!(requesttype & USB_DIR_IN))\n\t\tmemcpy(dev->buf, data, size);\n\n\tret = usb_control_msg(dev->udev, pipe, request, requesttype, value,\n\t\t\tindex, dev->buf, size, 1000);\n\thackrf_dbg_usb_control_msg(dev->dev, request, requesttype, value,\n\t\t\tindex, dev->buf, size);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev, \"usb_control_msg() failed %d request %02x\\n\",\n\t\t\t\tret, request);\n\t\tgoto err;\n\t}\n\n\t \n\tif (requesttype & USB_DIR_IN)\n\t\tmemcpy(data, dev->buf, size);\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\nstatic int hackrf_set_params(struct hackrf_dev *dev)\n{\n\tstruct usb_interface *intf = dev->intf;\n\tint ret, i;\n\tu8 buf[8], u8tmp;\n\tunsigned int uitmp, uitmp1, uitmp2;\n\tconst bool rx = test_bit(RX_ON, &dev->flags);\n\tconst bool tx = test_bit(TX_ON, &dev->flags);\n\tstatic const struct {\n\t\tu32 freq;\n\t} bandwidth_lut[] = {\n\t\t{ 1750000},  \n\t\t{ 2500000},  \n\t\t{ 3500000},  \n\t\t{ 5000000},  \n\t\t{ 5500000},  \n\t\t{ 6000000},  \n\t\t{ 7000000},  \n\t\t{ 8000000},  \n\t\t{ 9000000},  \n\t\t{10000000},  \n\t\t{12000000},  \n\t\t{14000000},  \n\t\t{15000000},  \n\t\t{20000000},  \n\t\t{24000000},  \n\t\t{28000000},  \n\t};\n\n\tif (!rx && !tx) {\n\t\tdev_dbg(&intf->dev, \"device is sleeping\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (rx && test_and_clear_bit(RX_ADC_FREQUENCY, &dev->flags)) {\n\t\tdev_dbg(&intf->dev, \"RX ADC frequency=%u Hz\\n\", dev->f_adc);\n\t\tuitmp1 = dev->f_adc;\n\t\tuitmp2 = 1;\n\t\tset_bit(TX_DAC_FREQUENCY, &dev->flags);\n\t} else if (tx && test_and_clear_bit(TX_DAC_FREQUENCY, &dev->flags)) {\n\t\tdev_dbg(&intf->dev, \"TX DAC frequency=%u Hz\\n\", dev->f_dac);\n\t\tuitmp1 = dev->f_dac;\n\t\tuitmp2 = 1;\n\t\tset_bit(RX_ADC_FREQUENCY, &dev->flags);\n\t} else {\n\t\tuitmp1 = uitmp2 = 0;\n\t}\n\tif (uitmp1 || uitmp2) {\n\t\tbuf[0] = (uitmp1 >>  0) & 0xff;\n\t\tbuf[1] = (uitmp1 >>  8) & 0xff;\n\t\tbuf[2] = (uitmp1 >> 16) & 0xff;\n\t\tbuf[3] = (uitmp1 >> 24) & 0xff;\n\t\tbuf[4] = (uitmp2 >>  0) & 0xff;\n\t\tbuf[5] = (uitmp2 >>  8) & 0xff;\n\t\tbuf[6] = (uitmp2 >> 16) & 0xff;\n\t\tbuf[7] = (uitmp2 >> 24) & 0xff;\n\t\tret = hackrf_ctrl_msg(dev, CMD_SAMPLE_RATE_SET, 0, 0, buf, 8);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tif (rx && test_and_clear_bit(RX_BANDWIDTH, &dev->flags)) {\n\t\tif (dev->rx_bandwidth_auto->val == true)\n\t\t\tuitmp = dev->f_adc;\n\t\telse\n\t\t\tuitmp = dev->rx_bandwidth->val;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(bandwidth_lut); i++) {\n\t\t\tif (uitmp <= bandwidth_lut[i].freq) {\n\t\t\t\tuitmp = bandwidth_lut[i].freq;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdev->rx_bandwidth->val = uitmp;\n\t\tdev->rx_bandwidth->cur.val = uitmp;\n\t\tdev_dbg(&intf->dev, \"RX bandwidth selected=%u\\n\", uitmp);\n\t\tset_bit(TX_BANDWIDTH, &dev->flags);\n\t} else if (tx && test_and_clear_bit(TX_BANDWIDTH, &dev->flags)) {\n\t\tif (dev->tx_bandwidth_auto->val == true)\n\t\t\tuitmp = dev->f_dac;\n\t\telse\n\t\t\tuitmp = dev->tx_bandwidth->val;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(bandwidth_lut); i++) {\n\t\t\tif (uitmp <= bandwidth_lut[i].freq) {\n\t\t\t\tuitmp = bandwidth_lut[i].freq;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdev->tx_bandwidth->val = uitmp;\n\t\tdev->tx_bandwidth->cur.val = uitmp;\n\t\tdev_dbg(&intf->dev, \"TX bandwidth selected=%u\\n\", uitmp);\n\t\tset_bit(RX_BANDWIDTH, &dev->flags);\n\t} else {\n\t\tuitmp = 0;\n\t}\n\tif (uitmp) {\n\t\tuitmp1 = uitmp2 = 0;\n\t\tuitmp1 |= ((uitmp >>  0) & 0xff) << 0;\n\t\tuitmp1 |= ((uitmp >>  8) & 0xff) << 8;\n\t\tuitmp2 |= ((uitmp >> 16) & 0xff) << 0;\n\t\tuitmp2 |= ((uitmp >> 24) & 0xff) << 8;\n\t\tret = hackrf_ctrl_msg(dev, CMD_BASEBAND_FILTER_BANDWIDTH_SET,\n\t\t\t\t      uitmp1, uitmp2, NULL, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tif (rx && test_and_clear_bit(RX_RF_FREQUENCY, &dev->flags)) {\n\t\tdev_dbg(&intf->dev, \"RX RF frequency=%u Hz\\n\", dev->f_rx);\n\t\tuitmp1 = dev->f_rx / 1000000;\n\t\tuitmp2 = dev->f_rx % 1000000;\n\t\tset_bit(TX_RF_FREQUENCY, &dev->flags);\n\t} else if (tx && test_and_clear_bit(TX_RF_FREQUENCY, &dev->flags)) {\n\t\tdev_dbg(&intf->dev, \"TX RF frequency=%u Hz\\n\", dev->f_tx);\n\t\tuitmp1 = dev->f_tx / 1000000;\n\t\tuitmp2 = dev->f_tx % 1000000;\n\t\tset_bit(RX_RF_FREQUENCY, &dev->flags);\n\t} else {\n\t\tuitmp1 = uitmp2 = 0;\n\t}\n\tif (uitmp1 || uitmp2) {\n\t\tbuf[0] = (uitmp1 >>  0) & 0xff;\n\t\tbuf[1] = (uitmp1 >>  8) & 0xff;\n\t\tbuf[2] = (uitmp1 >> 16) & 0xff;\n\t\tbuf[3] = (uitmp1 >> 24) & 0xff;\n\t\tbuf[4] = (uitmp2 >>  0) & 0xff;\n\t\tbuf[5] = (uitmp2 >>  8) & 0xff;\n\t\tbuf[6] = (uitmp2 >> 16) & 0xff;\n\t\tbuf[7] = (uitmp2 >> 24) & 0xff;\n\t\tret = hackrf_ctrl_msg(dev, CMD_SET_FREQ, 0, 0, buf, 8);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tif (rx && test_and_clear_bit(RX_RF_GAIN, &dev->flags)) {\n\t\tdev_dbg(&intf->dev, \"RX RF gain val=%d->%d\\n\",\n\t\t\tdev->rx_rf_gain->cur.val, dev->rx_rf_gain->val);\n\n\t\tu8tmp = (dev->rx_rf_gain->val) ? 1 : 0;\n\t\tret = hackrf_ctrl_msg(dev, CMD_AMP_ENABLE, u8tmp, 0, NULL, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tset_bit(TX_RF_GAIN, &dev->flags);\n\t}\n\n\t \n\tif (tx && test_and_clear_bit(TX_RF_GAIN, &dev->flags)) {\n\t\tdev_dbg(&intf->dev, \"TX RF gain val=%d->%d\\n\",\n\t\t\tdev->tx_rf_gain->cur.val, dev->tx_rf_gain->val);\n\n\t\tu8tmp = (dev->tx_rf_gain->val) ? 1 : 0;\n\t\tret = hackrf_ctrl_msg(dev, CMD_AMP_ENABLE, u8tmp, 0, NULL, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tset_bit(RX_RF_GAIN, &dev->flags);\n\t}\n\n\t \n\tif (rx && test_and_clear_bit(RX_LNA_GAIN, &dev->flags)) {\n\t\tdev_dbg(dev->dev, \"RX LNA gain val=%d->%d\\n\",\n\t\t\tdev->rx_lna_gain->cur.val, dev->rx_lna_gain->val);\n\n\t\tret = hackrf_ctrl_msg(dev, CMD_SET_LNA_GAIN, 0,\n\t\t\t\t      dev->rx_lna_gain->val, &u8tmp, 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tif (rx && test_and_clear_bit(RX_IF_GAIN, &dev->flags)) {\n\t\tdev_dbg(&intf->dev, \"IF gain val=%d->%d\\n\",\n\t\t\tdev->rx_if_gain->cur.val, dev->rx_if_gain->val);\n\n\t\tret = hackrf_ctrl_msg(dev, CMD_SET_VGA_GAIN, 0,\n\t\t\t\t      dev->rx_if_gain->val, &u8tmp, 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tif (tx && test_and_clear_bit(TX_LNA_GAIN, &dev->flags)) {\n\t\tdev_dbg(&intf->dev, \"TX LNA gain val=%d->%d\\n\",\n\t\t\tdev->tx_lna_gain->cur.val, dev->tx_lna_gain->val);\n\n\t\tret = hackrf_ctrl_msg(dev, CMD_SET_TXVGA_GAIN, 0,\n\t\t\t\t      dev->tx_lna_gain->val, &u8tmp, 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\n \nstatic struct hackrf_buffer *hackrf_get_next_buffer(struct hackrf_dev *dev,\n\t\t\t\t\t\t    struct list_head *buffer_list)\n{\n\tunsigned long flags;\n\tstruct hackrf_buffer *buffer = NULL;\n\n\tspin_lock_irqsave(&dev->buffer_list_lock, flags);\n\tif (list_empty(buffer_list))\n\t\tgoto leave;\n\n\tbuffer = list_entry(buffer_list->next, struct hackrf_buffer, list);\n\tlist_del(&buffer->list);\nleave:\n\tspin_unlock_irqrestore(&dev->buffer_list_lock, flags);\n\treturn buffer;\n}\n\nstatic void hackrf_copy_stream(struct hackrf_dev *dev, void *dst, void *src,\n\t\t\t       unsigned int src_len)\n{\n\tmemcpy(dst, src, src_len);\n\n\t \n\tif (unlikely(time_is_before_jiffies(dev->jiffies_next))) {\n\t\t#define MSECS 10000UL\n\t\tunsigned int msecs = jiffies_to_msecs(jiffies -\n\t\t\t\tdev->jiffies_next + msecs_to_jiffies(MSECS));\n\t\tunsigned int samples = dev->sample - dev->sample_measured;\n\n\t\tdev->jiffies_next = jiffies + msecs_to_jiffies(MSECS);\n\t\tdev->sample_measured = dev->sample;\n\t\tdev_dbg(dev->dev, \"slen=%u samples=%u msecs=%u sample rate=%lu\\n\",\n\t\t\t\tsrc_len, samples, msecs,\n\t\t\t\tsamples * 1000UL / msecs);\n\t}\n\n\t \n\tdev->sample += src_len / 2;\n}\n\n \nstatic void hackrf_urb_complete_in(struct urb *urb)\n{\n\tstruct hackrf_dev *dev = urb->context;\n\tstruct usb_interface *intf = dev->intf;\n\tstruct hackrf_buffer *buffer;\n\tunsigned int len;\n\n\tdev_dbg_ratelimited(&intf->dev, \"status=%d length=%u/%u\\n\", urb->status,\n\t\t\t    urb->actual_length, urb->transfer_buffer_length);\n\n\tswitch (urb->status) {\n\tcase 0:              \n\tcase -ETIMEDOUT:     \n\t\tbreak;\n\tcase -ECONNRESET:    \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:             \n\t\tdev_err_ratelimited(&intf->dev, \"URB failed %d\\n\", urb->status);\n\t\tgoto exit_usb_submit_urb;\n\t}\n\n\t \n\tbuffer = hackrf_get_next_buffer(dev, &dev->rx_buffer_list);\n\tif (unlikely(buffer == NULL)) {\n\t\tdev->vb_full++;\n\t\tdev_notice_ratelimited(&intf->dev,\n\t\t\t\t       \"buffer is full - %u packets dropped\\n\",\n\t\t\t\t       dev->vb_full);\n\t\tgoto exit_usb_submit_urb;\n\t}\n\n\tlen = min_t(unsigned long, vb2_plane_size(&buffer->vb.vb2_buf, 0),\n\t\t    urb->actual_length);\n\thackrf_copy_stream(dev, vb2_plane_vaddr(&buffer->vb.vb2_buf, 0),\n\t\t    urb->transfer_buffer, len);\n\tvb2_set_plane_payload(&buffer->vb.vb2_buf, 0, len);\n\tbuffer->vb.sequence = dev->sequence++;\n\tbuffer->vb.vb2_buf.timestamp = ktime_get_ns();\n\tvb2_buffer_done(&buffer->vb.vb2_buf, VB2_BUF_STATE_DONE);\nexit_usb_submit_urb:\n\tusb_submit_urb(urb, GFP_ATOMIC);\n}\n\nstatic void hackrf_urb_complete_out(struct urb *urb)\n{\n\tstruct hackrf_dev *dev = urb->context;\n\tstruct usb_interface *intf = dev->intf;\n\tstruct hackrf_buffer *buffer;\n\tunsigned int len;\n\n\tdev_dbg_ratelimited(&intf->dev, \"status=%d length=%u/%u\\n\", urb->status,\n\t\t\t    urb->actual_length, urb->transfer_buffer_length);\n\n\tswitch (urb->status) {\n\tcase 0:              \n\tcase -ETIMEDOUT:     \n\t\tbreak;\n\tcase -ECONNRESET:    \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:             \n\t\tdev_err_ratelimited(&intf->dev, \"URB failed %d\\n\", urb->status);\n\t}\n\n\t \n\tbuffer = hackrf_get_next_buffer(dev, &dev->tx_buffer_list);\n\tif (unlikely(buffer == NULL)) {\n\t\tdev->vb_empty++;\n\t\tdev_notice_ratelimited(&intf->dev,\n\t\t\t\t       \"buffer is empty - %u packets dropped\\n\",\n\t\t\t\t       dev->vb_empty);\n\t\turb->actual_length = 0;\n\t\tgoto exit_usb_submit_urb;\n\t}\n\n\tlen = min_t(unsigned long, urb->transfer_buffer_length,\n\t\t    vb2_get_plane_payload(&buffer->vb.vb2_buf, 0));\n\thackrf_copy_stream(dev, urb->transfer_buffer,\n\t\t\t   vb2_plane_vaddr(&buffer->vb.vb2_buf, 0), len);\n\turb->actual_length = len;\n\tbuffer->vb.sequence = dev->sequence++;\n\tbuffer->vb.vb2_buf.timestamp = ktime_get_ns();\n\tvb2_buffer_done(&buffer->vb.vb2_buf, VB2_BUF_STATE_DONE);\nexit_usb_submit_urb:\n\tusb_submit_urb(urb, GFP_ATOMIC);\n}\n\nstatic int hackrf_kill_urbs(struct hackrf_dev *dev)\n{\n\tint i;\n\n\tfor (i = dev->urbs_submitted - 1; i >= 0; i--) {\n\t\tdev_dbg(dev->dev, \"kill urb=%d\\n\", i);\n\t\t \n\t\tusb_kill_urb(dev->urb_list[i]);\n\t}\n\tdev->urbs_submitted = 0;\n\n\treturn 0;\n}\n\nstatic int hackrf_submit_urbs(struct hackrf_dev *dev)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < dev->urbs_initialized; i++) {\n\t\tdev_dbg(dev->dev, \"submit urb=%d\\n\", i);\n\t\tret = usb_submit_urb(dev->urb_list[i], GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tdev_err(dev->dev, \"Could not submit URB no. %d - get them all back\\n\",\n\t\t\t\t\ti);\n\t\t\thackrf_kill_urbs(dev);\n\t\t\treturn ret;\n\t\t}\n\t\tdev->urbs_submitted++;\n\t}\n\n\treturn 0;\n}\n\nstatic int hackrf_free_stream_bufs(struct hackrf_dev *dev)\n{\n\tif (dev->flags & USB_STATE_URB_BUF) {\n\t\twhile (dev->buf_num) {\n\t\t\tdev->buf_num--;\n\t\t\tdev_dbg(dev->dev, \"free buf=%d\\n\", dev->buf_num);\n\t\t\tusb_free_coherent(dev->udev, dev->buf_size,\n\t\t\t\t\t  dev->buf_list[dev->buf_num],\n\t\t\t\t\t  dev->dma_addr[dev->buf_num]);\n\t\t}\n\t}\n\tdev->flags &= ~USB_STATE_URB_BUF;\n\n\treturn 0;\n}\n\nstatic int hackrf_alloc_stream_bufs(struct hackrf_dev *dev)\n{\n\tdev->buf_num = 0;\n\tdev->buf_size = BULK_BUFFER_SIZE;\n\n\tdev_dbg(dev->dev, \"all in all I will use %u bytes for streaming\\n\",\n\t\t\tMAX_BULK_BUFS * BULK_BUFFER_SIZE);\n\n\tfor (dev->buf_num = 0; dev->buf_num < MAX_BULK_BUFS; dev->buf_num++) {\n\t\tdev->buf_list[dev->buf_num] = usb_alloc_coherent(dev->udev,\n\t\t\t\tBULK_BUFFER_SIZE, GFP_KERNEL,\n\t\t\t\t&dev->dma_addr[dev->buf_num]);\n\t\tif (!dev->buf_list[dev->buf_num]) {\n\t\t\tdev_dbg(dev->dev, \"alloc buf=%d failed\\n\",\n\t\t\t\t\tdev->buf_num);\n\t\t\thackrf_free_stream_bufs(dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdev_dbg(dev->dev, \"alloc buf=%d %p (dma %llu)\\n\", dev->buf_num,\n\t\t\t\tdev->buf_list[dev->buf_num],\n\t\t\t\t(long long)dev->dma_addr[dev->buf_num]);\n\t\tdev->flags |= USB_STATE_URB_BUF;\n\t}\n\n\treturn 0;\n}\n\nstatic int hackrf_free_urbs(struct hackrf_dev *dev)\n{\n\tint i;\n\n\thackrf_kill_urbs(dev);\n\n\tfor (i = dev->urbs_initialized - 1; i >= 0; i--) {\n\t\tif (dev->urb_list[i]) {\n\t\t\tdev_dbg(dev->dev, \"free urb=%d\\n\", i);\n\t\t\t \n\t\t\tusb_free_urb(dev->urb_list[i]);\n\t\t}\n\t}\n\tdev->urbs_initialized = 0;\n\n\treturn 0;\n}\n\nstatic int hackrf_alloc_urbs(struct hackrf_dev *dev, bool rcv)\n{\n\tint i, j;\n\tunsigned int pipe;\n\tusb_complete_t complete;\n\n\tif (rcv) {\n\t\tpipe = usb_rcvbulkpipe(dev->udev, 0x81);\n\t\tcomplete = &hackrf_urb_complete_in;\n\t} else {\n\t\tpipe = usb_sndbulkpipe(dev->udev, 0x02);\n\t\tcomplete = &hackrf_urb_complete_out;\n\t}\n\n\t \n\tfor (i = 0; i < MAX_BULK_BUFS; i++) {\n\t\tdev_dbg(dev->dev, \"alloc urb=%d\\n\", i);\n\t\tdev->urb_list[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!dev->urb_list[i]) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tusb_free_urb(dev->urb_list[j]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tusb_fill_bulk_urb(dev->urb_list[i],\n\t\t\t\tdev->udev,\n\t\t\t\tpipe,\n\t\t\t\tdev->buf_list[i],\n\t\t\t\tBULK_BUFFER_SIZE,\n\t\t\t\tcomplete, dev);\n\n\t\tdev->urb_list[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\t\tdev->urb_list[i]->transfer_dma = dev->dma_addr[i];\n\t\tdev->urbs_initialized++;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void hackrf_disconnect(struct usb_interface *intf)\n{\n\tstruct v4l2_device *v = usb_get_intfdata(intf);\n\tstruct hackrf_dev *dev = container_of(v, struct hackrf_dev, v4l2_dev);\n\n\tdev_dbg(dev->dev, \"\\n\");\n\n\tmutex_lock(&dev->vb_queue_lock);\n\tmutex_lock(&dev->v4l2_lock);\n\t \n\tdev->udev = NULL;\n\tv4l2_device_disconnect(&dev->v4l2_dev);\n\tvideo_unregister_device(&dev->tx_vdev);\n\tvideo_unregister_device(&dev->rx_vdev);\n\tmutex_unlock(&dev->v4l2_lock);\n\tmutex_unlock(&dev->vb_queue_lock);\n\n\tv4l2_device_put(&dev->v4l2_dev);\n}\n\n \nstatic void hackrf_return_all_buffers(struct vb2_queue *vq,\n\t\t\t\t      enum vb2_buffer_state state)\n{\n\tstruct hackrf_dev *dev = vb2_get_drv_priv(vq);\n\tstruct usb_interface *intf = dev->intf;\n\tstruct hackrf_buffer *buffer, *node;\n\tstruct list_head *buffer_list;\n\tunsigned long flags;\n\n\tdev_dbg(&intf->dev, \"\\n\");\n\n\tif (vq->type == V4L2_BUF_TYPE_SDR_CAPTURE)\n\t\tbuffer_list = &dev->rx_buffer_list;\n\telse\n\t\tbuffer_list = &dev->tx_buffer_list;\n\n\tspin_lock_irqsave(&dev->buffer_list_lock, flags);\n\tlist_for_each_entry_safe(buffer, node, buffer_list, list) {\n\t\tdev_dbg(&intf->dev, \"list_for_each_entry_safe\\n\");\n\t\tvb2_buffer_done(&buffer->vb.vb2_buf, state);\n\t\tlist_del(&buffer->list);\n\t}\n\tspin_unlock_irqrestore(&dev->buffer_list_lock, flags);\n}\n\nstatic int hackrf_queue_setup(struct vb2_queue *vq,\n\t\tunsigned int *nbuffers,\n\t\tunsigned int *nplanes, unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct hackrf_dev *dev = vb2_get_drv_priv(vq);\n\n\tdev_dbg(dev->dev, \"nbuffers=%d\\n\", *nbuffers);\n\n\t \n\tif (vq->num_buffers + *nbuffers < 8)\n\t\t*nbuffers = 8 - vq->num_buffers;\n\t*nplanes = 1;\n\tsizes[0] = PAGE_ALIGN(dev->buffersize);\n\n\tdev_dbg(dev->dev, \"nbuffers=%d sizes[0]=%d\\n\", *nbuffers, sizes[0]);\n\treturn 0;\n}\n\nstatic void hackrf_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct hackrf_dev *dev = vb2_get_drv_priv(vq);\n\tstruct hackrf_buffer *buffer = container_of(vbuf, struct hackrf_buffer, vb);\n\tstruct list_head *buffer_list;\n\tunsigned long flags;\n\n\tdev_dbg_ratelimited(&dev->intf->dev, \"\\n\");\n\n\tif (vq->type == V4L2_BUF_TYPE_SDR_CAPTURE)\n\t\tbuffer_list = &dev->rx_buffer_list;\n\telse\n\t\tbuffer_list = &dev->tx_buffer_list;\n\n\tspin_lock_irqsave(&dev->buffer_list_lock, flags);\n\tlist_add_tail(&buffer->list, buffer_list);\n\tspin_unlock_irqrestore(&dev->buffer_list_lock, flags);\n}\n\nstatic int hackrf_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct hackrf_dev *dev = vb2_get_drv_priv(vq);\n\tstruct usb_interface *intf = dev->intf;\n\tint ret;\n\tunsigned int mode;\n\n\tdev_dbg(&intf->dev, \"count=%i\\n\", count);\n\n\tmutex_lock(&dev->v4l2_lock);\n\n\t \n\tif (vq->type == V4L2_BUF_TYPE_SDR_CAPTURE) {\n\t\tif (test_bit(TX_ON, &dev->flags)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto err_hackrf_return_all_buffers;\n\t\t}\n\n\t\tmode = 1;\n\t\tset_bit(RX_ON, &dev->flags);\n\t} else {\n\t\tif (test_bit(RX_ON, &dev->flags)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto err_hackrf_return_all_buffers;\n\t\t}\n\n\t\tmode = 2;\n\t\tset_bit(TX_ON, &dev->flags);\n\t}\n\n\tdev->sequence = 0;\n\n\tret = hackrf_alloc_stream_bufs(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tret = hackrf_alloc_urbs(dev, (mode == 1));\n\tif (ret)\n\t\tgoto err;\n\n\tret = hackrf_submit_urbs(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tret = hackrf_set_params(dev);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = hackrf_ctrl_msg(dev, CMD_SET_TRANSCEIVER_MODE, mode, 0, NULL, 0);\n\tif (ret)\n\t\tgoto err;\n\n\tmutex_unlock(&dev->v4l2_lock);\n\n\treturn 0;\nerr:\n\thackrf_kill_urbs(dev);\n\thackrf_free_urbs(dev);\n\thackrf_free_stream_bufs(dev);\n\tclear_bit(RX_ON, &dev->flags);\n\tclear_bit(TX_ON, &dev->flags);\nerr_hackrf_return_all_buffers:\n\thackrf_return_all_buffers(vq, VB2_BUF_STATE_QUEUED);\n\tmutex_unlock(&dev->v4l2_lock);\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void hackrf_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct hackrf_dev *dev = vb2_get_drv_priv(vq);\n\tstruct usb_interface *intf = dev->intf;\n\n\tdev_dbg(&intf->dev, \"\\n\");\n\n\tmutex_lock(&dev->v4l2_lock);\n\n\t \n\thackrf_ctrl_msg(dev, CMD_SET_TRANSCEIVER_MODE, 0, 0, NULL, 0);\n\n\thackrf_kill_urbs(dev);\n\thackrf_free_urbs(dev);\n\thackrf_free_stream_bufs(dev);\n\n\thackrf_return_all_buffers(vq, VB2_BUF_STATE_ERROR);\n\n\tif (vq->type == V4L2_BUF_TYPE_SDR_CAPTURE)\n\t\tclear_bit(RX_ON, &dev->flags);\n\telse\n\t\tclear_bit(TX_ON, &dev->flags);\n\n\tmutex_unlock(&dev->v4l2_lock);\n}\n\nstatic const struct vb2_ops hackrf_vb2_ops = {\n\t.queue_setup            = hackrf_queue_setup,\n\t.buf_queue              = hackrf_buf_queue,\n\t.start_streaming        = hackrf_start_streaming,\n\t.stop_streaming         = hackrf_stop_streaming,\n\t.wait_prepare           = vb2_ops_wait_prepare,\n\t.wait_finish            = vb2_ops_wait_finish,\n};\n\nstatic int hackrf_querycap(struct file *file, void *fh,\n\t\tstruct v4l2_capability *cap)\n{\n\tstruct hackrf_dev *dev = video_drvdata(file);\n\tstruct usb_interface *intf = dev->intf;\n\n\tdev_dbg(&intf->dev, \"\\n\");\n\n\tcap->capabilities = V4L2_CAP_SDR_CAPTURE | V4L2_CAP_TUNER |\n\t\t\t    V4L2_CAP_SDR_OUTPUT | V4L2_CAP_MODULATOR |\n\t\t\t    V4L2_CAP_STREAMING | V4L2_CAP_READWRITE |\n\t\t\t    V4L2_CAP_DEVICE_CAPS;\n\tstrscpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\n\tstrscpy(cap->card, dev->rx_vdev.name, sizeof(cap->card));\n\tusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\n\n\treturn 0;\n}\n\nstatic int hackrf_s_fmt_sdr(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *f)\n{\n\tstruct hackrf_dev *dev = video_drvdata(file);\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct vb2_queue *q;\n\tint i;\n\n\tdev_dbg(dev->dev, \"pixelformat fourcc %4.4s\\n\",\n\t\t\t(char *)&f->fmt.sdr.pixelformat);\n\n\tif (vdev->vfl_dir == VFL_DIR_RX)\n\t\tq = &dev->rx_vb2_queue;\n\telse\n\t\tq = &dev->tx_vb2_queue;\n\n\tif (vb2_is_busy(q))\n\t\treturn -EBUSY;\n\n\tfor (i = 0; i < NUM_FORMATS; i++) {\n\t\tif (f->fmt.sdr.pixelformat == formats[i].pixelformat) {\n\t\t\tdev->pixelformat = formats[i].pixelformat;\n\t\t\tdev->buffersize = formats[i].buffersize;\n\t\t\tf->fmt.sdr.buffersize = formats[i].buffersize;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev->pixelformat = formats[0].pixelformat;\n\tdev->buffersize = formats[0].buffersize;\n\tf->fmt.sdr.pixelformat = formats[0].pixelformat;\n\tf->fmt.sdr.buffersize = formats[0].buffersize;\n\n\treturn 0;\n}\n\nstatic int hackrf_g_fmt_sdr(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *f)\n{\n\tstruct hackrf_dev *dev = video_drvdata(file);\n\n\tdev_dbg(dev->dev, \"pixelformat fourcc %4.4s\\n\",\n\t\t\t(char *)&dev->pixelformat);\n\n\tf->fmt.sdr.pixelformat = dev->pixelformat;\n\tf->fmt.sdr.buffersize = dev->buffersize;\n\n\treturn 0;\n}\n\nstatic int hackrf_try_fmt_sdr(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *f)\n{\n\tstruct hackrf_dev *dev = video_drvdata(file);\n\tint i;\n\n\tdev_dbg(dev->dev, \"pixelformat fourcc %4.4s\\n\",\n\t\t\t(char *)&f->fmt.sdr.pixelformat);\n\n\tfor (i = 0; i < NUM_FORMATS; i++) {\n\t\tif (formats[i].pixelformat == f->fmt.sdr.pixelformat) {\n\t\t\tf->fmt.sdr.buffersize = formats[i].buffersize;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tf->fmt.sdr.pixelformat = formats[0].pixelformat;\n\tf->fmt.sdr.buffersize = formats[0].buffersize;\n\n\treturn 0;\n}\n\nstatic int hackrf_enum_fmt_sdr(struct file *file, void *priv,\n\t\t\t       struct v4l2_fmtdesc *f)\n{\n\tstruct hackrf_dev *dev = video_drvdata(file);\n\n\tdev_dbg(dev->dev, \"index=%d\\n\", f->index);\n\n\tif (f->index >= NUM_FORMATS)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = formats[f->index].pixelformat;\n\n\treturn 0;\n}\n\nstatic int hackrf_s_tuner(struct file *file, void *priv,\n\t\tconst struct v4l2_tuner *v)\n{\n\tstruct hackrf_dev *dev = video_drvdata(file);\n\tint ret;\n\n\tdev_dbg(dev->dev, \"index=%d\\n\", v->index);\n\n\tif (v->index == 0)\n\t\tret = 0;\n\telse if (v->index == 1)\n\t\tret = 0;\n\telse\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nstatic int hackrf_g_tuner(struct file *file, void *priv, struct v4l2_tuner *v)\n{\n\tstruct hackrf_dev *dev = video_drvdata(file);\n\tint ret;\n\n\tdev_dbg(dev->dev, \"index=%d\\n\", v->index);\n\n\tif (v->index == 0) {\n\t\tstrscpy(v->name, \"HackRF ADC\", sizeof(v->name));\n\t\tv->type = V4L2_TUNER_SDR;\n\t\tv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\n\t\tv->rangelow  = bands_adc_dac[0].rangelow;\n\t\tv->rangehigh = bands_adc_dac[0].rangehigh;\n\t\tret = 0;\n\t} else if (v->index == 1) {\n\t\tstrscpy(v->name, \"HackRF RF\", sizeof(v->name));\n\t\tv->type = V4L2_TUNER_RF;\n\t\tv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\n\t\tv->rangelow  = bands_rx_tx[0].rangelow;\n\t\tv->rangehigh = bands_rx_tx[0].rangehigh;\n\t\tret = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int hackrf_s_modulator(struct file *file, void *fh,\n\t\t\t      const struct v4l2_modulator *a)\n{\n\tstruct hackrf_dev *dev = video_drvdata(file);\n\n\tdev_dbg(dev->dev, \"index=%d\\n\", a->index);\n\n\treturn a->index > 1 ? -EINVAL : 0;\n}\n\nstatic int hackrf_g_modulator(struct file *file, void *fh,\n\t\t\t      struct v4l2_modulator *a)\n{\n\tstruct hackrf_dev *dev = video_drvdata(file);\n\tint ret;\n\n\tdev_dbg(dev->dev, \"index=%d\\n\", a->index);\n\n\tif (a->index == 0) {\n\t\tstrscpy(a->name, \"HackRF DAC\", sizeof(a->name));\n\t\ta->type = V4L2_TUNER_SDR;\n\t\ta->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\n\t\ta->rangelow  = bands_adc_dac[0].rangelow;\n\t\ta->rangehigh = bands_adc_dac[0].rangehigh;\n\t\tret = 0;\n\t} else if (a->index == 1) {\n\t\tstrscpy(a->name, \"HackRF RF\", sizeof(a->name));\n\t\ta->type = V4L2_TUNER_RF;\n\t\ta->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\n\t\ta->rangelow  = bands_rx_tx[0].rangelow;\n\t\ta->rangehigh = bands_rx_tx[0].rangehigh;\n\t\tret = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int hackrf_s_frequency(struct file *file, void *priv,\n\t\tconst struct v4l2_frequency *f)\n{\n\tstruct hackrf_dev *dev = video_drvdata(file);\n\tstruct usb_interface *intf = dev->intf;\n\tstruct video_device *vdev = video_devdata(file);\n\tint ret;\n\tunsigned int uitmp;\n\n\tdev_dbg(&intf->dev, \"tuner=%d type=%d frequency=%u\\n\",\n\t\t\tf->tuner, f->type, f->frequency);\n\n\tif (f->tuner == 0) {\n\t\tuitmp = clamp(f->frequency, bands_adc_dac[0].rangelow,\n\t\t\t      bands_adc_dac[0].rangehigh);\n\t\tif (vdev->vfl_dir == VFL_DIR_RX) {\n\t\t\tdev->f_adc = uitmp;\n\t\t\tset_bit(RX_ADC_FREQUENCY, &dev->flags);\n\t\t} else {\n\t\t\tdev->f_dac = uitmp;\n\t\t\tset_bit(TX_DAC_FREQUENCY, &dev->flags);\n\t\t}\n\t} else if (f->tuner == 1) {\n\t\tuitmp = clamp(f->frequency, bands_rx_tx[0].rangelow,\n\t\t\t      bands_rx_tx[0].rangehigh);\n\t\tif (vdev->vfl_dir == VFL_DIR_RX) {\n\t\t\tdev->f_rx = uitmp;\n\t\t\tset_bit(RX_RF_FREQUENCY, &dev->flags);\n\t\t} else {\n\t\t\tdev->f_tx = uitmp;\n\t\t\tset_bit(TX_RF_FREQUENCY, &dev->flags);\n\t\t}\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = hackrf_set_params(dev);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int hackrf_g_frequency(struct file *file, void *priv,\n\t\tstruct v4l2_frequency *f)\n{\n\tstruct hackrf_dev *dev = video_drvdata(file);\n\tstruct usb_interface *intf = dev->intf;\n\tstruct video_device *vdev = video_devdata(file);\n\tint ret;\n\n\tdev_dbg(dev->dev, \"tuner=%d type=%d\\n\", f->tuner, f->type);\n\n\tif (f->tuner == 0) {\n\t\tf->type = V4L2_TUNER_SDR;\n\t\tif (vdev->vfl_dir == VFL_DIR_RX)\n\t\t\tf->frequency = dev->f_adc;\n\t\telse\n\t\t\tf->frequency = dev->f_dac;\n\t} else if (f->tuner == 1) {\n\t\tf->type = V4L2_TUNER_RF;\n\t\tif (vdev->vfl_dir == VFL_DIR_RX)\n\t\t\tf->frequency = dev->f_rx;\n\t\telse\n\t\t\tf->frequency = dev->f_tx;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int hackrf_enum_freq_bands(struct file *file, void *priv,\n\t\tstruct v4l2_frequency_band *band)\n{\n\tstruct hackrf_dev *dev = video_drvdata(file);\n\tint ret;\n\n\tdev_dbg(dev->dev, \"tuner=%d type=%d index=%d\\n\",\n\t\t\tband->tuner, band->type, band->index);\n\n\tif (band->tuner == 0) {\n\t\tif (band->index >= ARRAY_SIZE(bands_adc_dac)) {\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\t*band = bands_adc_dac[band->index];\n\t\t\tret = 0;\n\t\t}\n\t} else if (band->tuner == 1) {\n\t\tif (band->index >= ARRAY_SIZE(bands_rx_tx)) {\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\t*band = bands_rx_tx[band->index];\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ioctl_ops hackrf_ioctl_ops = {\n\t.vidioc_querycap          = hackrf_querycap,\n\n\t.vidioc_s_fmt_sdr_cap     = hackrf_s_fmt_sdr,\n\t.vidioc_g_fmt_sdr_cap     = hackrf_g_fmt_sdr,\n\t.vidioc_enum_fmt_sdr_cap  = hackrf_enum_fmt_sdr,\n\t.vidioc_try_fmt_sdr_cap   = hackrf_try_fmt_sdr,\n\n\t.vidioc_s_fmt_sdr_out     = hackrf_s_fmt_sdr,\n\t.vidioc_g_fmt_sdr_out     = hackrf_g_fmt_sdr,\n\t.vidioc_enum_fmt_sdr_out  = hackrf_enum_fmt_sdr,\n\t.vidioc_try_fmt_sdr_out   = hackrf_try_fmt_sdr,\n\n\t.vidioc_reqbufs           = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs       = vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf       = vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf          = vb2_ioctl_querybuf,\n\t.vidioc_qbuf              = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf             = vb2_ioctl_dqbuf,\n\t.vidioc_expbuf            = vb2_ioctl_expbuf,\n\n\t.vidioc_streamon          = vb2_ioctl_streamon,\n\t.vidioc_streamoff         = vb2_ioctl_streamoff,\n\n\t.vidioc_s_tuner           = hackrf_s_tuner,\n\t.vidioc_g_tuner           = hackrf_g_tuner,\n\n\t.vidioc_s_modulator       = hackrf_s_modulator,\n\t.vidioc_g_modulator       = hackrf_g_modulator,\n\n\t.vidioc_s_frequency       = hackrf_s_frequency,\n\t.vidioc_g_frequency       = hackrf_g_frequency,\n\t.vidioc_enum_freq_bands   = hackrf_enum_freq_bands,\n\n\t.vidioc_subscribe_event   = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\t.vidioc_log_status        = v4l2_ctrl_log_status,\n};\n\nstatic const struct v4l2_file_operations hackrf_fops = {\n\t.owner                    = THIS_MODULE,\n\t.open                     = v4l2_fh_open,\n\t.release                  = vb2_fop_release,\n\t.read                     = vb2_fop_read,\n\t.write                    = vb2_fop_write,\n\t.poll                     = vb2_fop_poll,\n\t.mmap                     = vb2_fop_mmap,\n\t.unlocked_ioctl           = video_ioctl2,\n};\n\nstatic const struct video_device hackrf_template = {\n\t.name                     = \"HackRF One\",\n\t.release                  = video_device_release_empty,\n\t.fops                     = &hackrf_fops,\n\t.ioctl_ops                = &hackrf_ioctl_ops,\n};\n\nstatic void hackrf_video_release(struct v4l2_device *v)\n{\n\tstruct hackrf_dev *dev = container_of(v, struct hackrf_dev, v4l2_dev);\n\n\tdev_dbg(dev->dev, \"\\n\");\n\n\tv4l2_ctrl_handler_free(&dev->rx_ctrl_handler);\n\tv4l2_ctrl_handler_free(&dev->tx_ctrl_handler);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tkfree(dev);\n}\n\nstatic int hackrf_s_ctrl_rx(struct v4l2_ctrl *ctrl)\n{\n\tstruct hackrf_dev *dev = container_of(ctrl->handler,\n\t\t\tstruct hackrf_dev, rx_ctrl_handler);\n\tstruct usb_interface *intf = dev->intf;\n\tint ret;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_RF_TUNER_BANDWIDTH_AUTO:\n\tcase V4L2_CID_RF_TUNER_BANDWIDTH:\n\t\tset_bit(RX_BANDWIDTH, &dev->flags);\n\t\tbreak;\n\tcase  V4L2_CID_RF_TUNER_RF_GAIN:\n\t\tset_bit(RX_RF_GAIN, &dev->flags);\n\t\tbreak;\n\tcase  V4L2_CID_RF_TUNER_LNA_GAIN:\n\t\tset_bit(RX_LNA_GAIN, &dev->flags);\n\t\tbreak;\n\tcase  V4L2_CID_RF_TUNER_IF_GAIN:\n\t\tset_bit(RX_IF_GAIN, &dev->flags);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&intf->dev, \"unknown ctrl: id=%d name=%s\\n\",\n\t\t\tctrl->id, ctrl->name);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = hackrf_set_params(dev);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int hackrf_s_ctrl_tx(struct v4l2_ctrl *ctrl)\n{\n\tstruct hackrf_dev *dev = container_of(ctrl->handler,\n\t\t\tstruct hackrf_dev, tx_ctrl_handler);\n\tstruct usb_interface *intf = dev->intf;\n\tint ret;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_RF_TUNER_BANDWIDTH_AUTO:\n\tcase V4L2_CID_RF_TUNER_BANDWIDTH:\n\t\tset_bit(TX_BANDWIDTH, &dev->flags);\n\t\tbreak;\n\tcase  V4L2_CID_RF_TUNER_LNA_GAIN:\n\t\tset_bit(TX_LNA_GAIN, &dev->flags);\n\t\tbreak;\n\tcase  V4L2_CID_RF_TUNER_RF_GAIN:\n\t\tset_bit(TX_RF_GAIN, &dev->flags);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&intf->dev, \"unknown ctrl: id=%d name=%s\\n\",\n\t\t\tctrl->id, ctrl->name);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = hackrf_set_params(dev);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops hackrf_ctrl_ops_rx = {\n\t.s_ctrl = hackrf_s_ctrl_rx,\n};\n\nstatic const struct v4l2_ctrl_ops hackrf_ctrl_ops_tx = {\n\t.s_ctrl = hackrf_s_ctrl_tx,\n};\n\nstatic int hackrf_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct hackrf_dev *dev;\n\tint ret;\n\tu8 u8tmp, buf[BUF_SIZE];\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tmutex_init(&dev->v4l2_lock);\n\tmutex_init(&dev->vb_queue_lock);\n\tspin_lock_init(&dev->buffer_list_lock);\n\tINIT_LIST_HEAD(&dev->rx_buffer_list);\n\tINIT_LIST_HEAD(&dev->tx_buffer_list);\n\tdev->intf = intf;\n\tdev->dev = &intf->dev;\n\tdev->udev = interface_to_usbdev(intf);\n\tdev->pixelformat = formats[0].pixelformat;\n\tdev->buffersize = formats[0].buffersize;\n\tdev->f_adc = bands_adc_dac[0].rangelow;\n\tdev->f_dac = bands_adc_dac[0].rangelow;\n\tdev->f_rx = bands_rx_tx[0].rangelow;\n\tdev->f_tx = bands_rx_tx[0].rangelow;\n\tset_bit(RX_ADC_FREQUENCY, &dev->flags);\n\tset_bit(TX_DAC_FREQUENCY, &dev->flags);\n\tset_bit(RX_RF_FREQUENCY, &dev->flags);\n\tset_bit(TX_RF_FREQUENCY, &dev->flags);\n\n\t \n\tret = hackrf_ctrl_msg(dev, CMD_BOARD_ID_READ, 0, 0, &u8tmp, 1);\n\tif (ret == 0)\n\t\tret = hackrf_ctrl_msg(dev, CMD_VERSION_STRING_READ, 0, 0,\n\t\t\t\tbuf, BUF_SIZE);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Could not detect board\\n\");\n\t\tgoto err_kfree;\n\t}\n\n\tbuf[BUF_SIZE - 1] = '\\0';\n\tdev_info(dev->dev, \"Board ID: %02x\\n\", u8tmp);\n\tdev_info(dev->dev, \"Firmware version: %s\\n\", buf);\n\n\t \n\tdev->rx_vb2_queue.type = V4L2_BUF_TYPE_SDR_CAPTURE;\n\tdev->rx_vb2_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF |\n\t\t\t\t     VB2_READ;\n\tdev->rx_vb2_queue.ops = &hackrf_vb2_ops;\n\tdev->rx_vb2_queue.mem_ops = &vb2_vmalloc_memops;\n\tdev->rx_vb2_queue.drv_priv = dev;\n\tdev->rx_vb2_queue.buf_struct_size = sizeof(struct hackrf_buffer);\n\tdev->rx_vb2_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tret = vb2_queue_init(&dev->rx_vb2_queue);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Could not initialize rx vb2 queue\\n\");\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tdev->tx_vb2_queue.type = V4L2_BUF_TYPE_SDR_OUTPUT;\n\tdev->tx_vb2_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF |\n\t\t\t\t     VB2_WRITE;\n\tdev->tx_vb2_queue.ops = &hackrf_vb2_ops;\n\tdev->tx_vb2_queue.mem_ops = &vb2_vmalloc_memops;\n\tdev->tx_vb2_queue.drv_priv = dev;\n\tdev->tx_vb2_queue.buf_struct_size = sizeof(struct hackrf_buffer);\n\tdev->tx_vb2_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tret = vb2_queue_init(&dev->tx_vb2_queue);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Could not initialize tx vb2 queue\\n\");\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tv4l2_ctrl_handler_init(&dev->rx_ctrl_handler, 5);\n\tdev->rx_bandwidth_auto = v4l2_ctrl_new_std(&dev->rx_ctrl_handler,\n\t\t&hackrf_ctrl_ops_rx, V4L2_CID_RF_TUNER_BANDWIDTH_AUTO,\n\t\t0, 1, 0, 1);\n\tdev->rx_bandwidth = v4l2_ctrl_new_std(&dev->rx_ctrl_handler,\n\t\t&hackrf_ctrl_ops_rx, V4L2_CID_RF_TUNER_BANDWIDTH,\n\t\t1750000, 28000000, 50000, 1750000);\n\tv4l2_ctrl_auto_cluster(2, &dev->rx_bandwidth_auto, 0, false);\n\tdev->rx_rf_gain = v4l2_ctrl_new_std(&dev->rx_ctrl_handler,\n\t\t&hackrf_ctrl_ops_rx, V4L2_CID_RF_TUNER_RF_GAIN, 0, 12, 12, 0);\n\tdev->rx_lna_gain = v4l2_ctrl_new_std(&dev->rx_ctrl_handler,\n\t\t&hackrf_ctrl_ops_rx, V4L2_CID_RF_TUNER_LNA_GAIN, 0, 40, 8, 0);\n\tdev->rx_if_gain = v4l2_ctrl_new_std(&dev->rx_ctrl_handler,\n\t\t&hackrf_ctrl_ops_rx, V4L2_CID_RF_TUNER_IF_GAIN, 0, 62, 2, 0);\n\tif (dev->rx_ctrl_handler.error) {\n\t\tret = dev->rx_ctrl_handler.error;\n\t\tdev_err(dev->dev, \"Could not initialize controls\\n\");\n\t\tgoto err_v4l2_ctrl_handler_free_rx;\n\t}\n\tv4l2_ctrl_grab(dev->rx_rf_gain, !hackrf_enable_rf_gain_ctrl);\n\tv4l2_ctrl_handler_setup(&dev->rx_ctrl_handler);\n\n\t \n\tv4l2_ctrl_handler_init(&dev->tx_ctrl_handler, 4);\n\tdev->tx_bandwidth_auto = v4l2_ctrl_new_std(&dev->tx_ctrl_handler,\n\t\t&hackrf_ctrl_ops_tx, V4L2_CID_RF_TUNER_BANDWIDTH_AUTO,\n\t\t0, 1, 0, 1);\n\tdev->tx_bandwidth = v4l2_ctrl_new_std(&dev->tx_ctrl_handler,\n\t\t&hackrf_ctrl_ops_tx, V4L2_CID_RF_TUNER_BANDWIDTH,\n\t\t1750000, 28000000, 50000, 1750000);\n\tv4l2_ctrl_auto_cluster(2, &dev->tx_bandwidth_auto, 0, false);\n\tdev->tx_lna_gain = v4l2_ctrl_new_std(&dev->tx_ctrl_handler,\n\t\t&hackrf_ctrl_ops_tx, V4L2_CID_RF_TUNER_LNA_GAIN, 0, 47, 1, 0);\n\tdev->tx_rf_gain = v4l2_ctrl_new_std(&dev->tx_ctrl_handler,\n\t\t&hackrf_ctrl_ops_tx, V4L2_CID_RF_TUNER_RF_GAIN, 0, 15, 15, 0);\n\tif (dev->tx_ctrl_handler.error) {\n\t\tret = dev->tx_ctrl_handler.error;\n\t\tdev_err(dev->dev, \"Could not initialize controls\\n\");\n\t\tgoto err_v4l2_ctrl_handler_free_tx;\n\t}\n\tv4l2_ctrl_grab(dev->tx_rf_gain, !hackrf_enable_rf_gain_ctrl);\n\tv4l2_ctrl_handler_setup(&dev->tx_ctrl_handler);\n\n\t \n\tdev->v4l2_dev.release = hackrf_video_release;\n\tret = v4l2_device_register(&intf->dev, &dev->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to register v4l2-device (%d)\\n\", ret);\n\t\tgoto err_v4l2_ctrl_handler_free_tx;\n\t}\n\n\t \n\tdev->rx_vdev = hackrf_template;\n\tdev->rx_vdev.queue = &dev->rx_vb2_queue;\n\tdev->rx_vdev.queue->lock = &dev->vb_queue_lock;\n\tdev->rx_vdev.v4l2_dev = &dev->v4l2_dev;\n\tdev->rx_vdev.ctrl_handler = &dev->rx_ctrl_handler;\n\tdev->rx_vdev.lock = &dev->v4l2_lock;\n\tdev->rx_vdev.vfl_dir = VFL_DIR_RX;\n\tdev->rx_vdev.device_caps = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE |\n\t\t\t\t   V4L2_CAP_SDR_CAPTURE | V4L2_CAP_TUNER;\n\tvideo_set_drvdata(&dev->rx_vdev, dev);\n\tret = video_register_device(&dev->rx_vdev, VFL_TYPE_SDR, -1);\n\tif (ret) {\n\t\tdev_err(dev->dev,\n\t\t\t\"Failed to register as video device (%d)\\n\", ret);\n\t\tgoto err_v4l2_device_unregister;\n\t}\n\tdev_info(dev->dev, \"Registered as %s\\n\",\n\t\t video_device_node_name(&dev->rx_vdev));\n\n\t \n\tdev->tx_vdev = hackrf_template;\n\tdev->tx_vdev.queue = &dev->tx_vb2_queue;\n\tdev->tx_vdev.queue->lock = &dev->vb_queue_lock;\n\tdev->tx_vdev.v4l2_dev = &dev->v4l2_dev;\n\tdev->tx_vdev.ctrl_handler = &dev->tx_ctrl_handler;\n\tdev->tx_vdev.lock = &dev->v4l2_lock;\n\tdev->tx_vdev.vfl_dir = VFL_DIR_TX;\n\tdev->tx_vdev.device_caps = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE |\n\t\t\t\t   V4L2_CAP_SDR_OUTPUT | V4L2_CAP_MODULATOR;\n\tvideo_set_drvdata(&dev->tx_vdev, dev);\n\tret = video_register_device(&dev->tx_vdev, VFL_TYPE_SDR, -1);\n\tif (ret) {\n\t\tdev_err(dev->dev,\n\t\t\t\"Failed to register as video device (%d)\\n\", ret);\n\t\tgoto err_video_unregister_device_rx;\n\t}\n\tdev_info(dev->dev, \"Registered as %s\\n\",\n\t\t video_device_node_name(&dev->tx_vdev));\n\n\tdev_notice(dev->dev, \"SDR API is still slightly experimental and functionality changes may follow\\n\");\n\treturn 0;\nerr_video_unregister_device_rx:\n\tvideo_unregister_device(&dev->rx_vdev);\nerr_v4l2_device_unregister:\n\tv4l2_device_unregister(&dev->v4l2_dev);\nerr_v4l2_ctrl_handler_free_tx:\n\tv4l2_ctrl_handler_free(&dev->tx_ctrl_handler);\nerr_v4l2_ctrl_handler_free_rx:\n\tv4l2_ctrl_handler_free(&dev->rx_ctrl_handler);\nerr_kfree:\n\tkfree(dev);\nerr:\n\tdev_dbg(&intf->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\n \nstatic const struct usb_device_id hackrf_id_table[] = {\n\t{ USB_DEVICE(0x1d50, 0x6089) },  \n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, hackrf_id_table);\n\n \nstatic struct usb_driver hackrf_driver = {\n\t.name                     = KBUILD_MODNAME,\n\t.probe                    = hackrf_probe,\n\t.disconnect               = hackrf_disconnect,\n\t.id_table                 = hackrf_id_table,\n};\n\nmodule_usb_driver(hackrf_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"HackRF\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}