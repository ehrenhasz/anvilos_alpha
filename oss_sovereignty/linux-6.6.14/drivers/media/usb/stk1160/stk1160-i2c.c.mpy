{
  "module_name": "stk1160-i2c.c",
  "hash_id": "49723c7cf770a0d3c820d51663f139ad7ee7f327fbc661c2d3a65f04cfe032ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/stk1160/stk1160-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/i2c.h>\n\n#include \"stk1160.h\"\n#include \"stk1160-reg.h\"\n\nstatic unsigned int i2c_debug;\nmodule_param(i2c_debug, int, 0644);\nMODULE_PARM_DESC(i2c_debug, \"enable debug messages [i2c]\");\n\n#define dprintk_i2c(fmt, args...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (i2c_debug)\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG fmt, ##args);\t\t\t\\\n} while (0)\n\nstatic int stk1160_i2c_busy_wait(struct stk1160 *dev, u8 wait_bit_mask)\n{\n\tunsigned long end;\n\tu8 flag;\n\n\t \n\tend = jiffies + msecs_to_jiffies(STK1160_I2C_TIMEOUT);\n\twhile (time_is_after_jiffies(end)) {\n\n\t\tstk1160_read_reg(dev, STK1160_SICTL+1, &flag);\n\t\t \n\t\tif (flag & wait_bit_mask)\n\t\t\tgoto done;\n\n\t\tusleep_range(10 * USEC_PER_MSEC, 20 * USEC_PER_MSEC);\n\t}\n\n\treturn -ETIMEDOUT;\n\ndone:\n\treturn 0;\n}\n\nstatic int stk1160_i2c_write_reg(struct stk1160 *dev, u8 addr,\n\t\tu8 reg, u8 value)\n{\n\tint rc;\n\n\t \n\trc = stk1160_write_reg(dev, STK1160_SICTL_SDA, addr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = stk1160_write_reg(dev, STK1160_SBUSW_WA, reg);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = stk1160_write_reg(dev, STK1160_SBUSW_WD, value);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = stk1160_write_reg(dev, STK1160_SICTL, 0x01);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = stk1160_i2c_busy_wait(dev, 0x04);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int stk1160_i2c_read_reg(struct stk1160 *dev, u8 addr,\n\t\tu8 reg, u8 *value)\n{\n\tint rc;\n\n\t \n\trc = stk1160_write_reg(dev, STK1160_SICTL_SDA, addr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = stk1160_write_reg(dev, STK1160_SBUSR_RA, reg);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = stk1160_write_reg(dev, STK1160_SICTL, 0x20);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = stk1160_i2c_busy_wait(dev, 0x01);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = stk1160_read_reg(dev, STK1160_SBUSR_RD, value);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\n \nstatic int stk1160_i2c_check_for_device(struct stk1160 *dev,\n\t\tunsigned char addr)\n{\n\tint rc;\n\n\t \n\trc = stk1160_write_reg(dev, STK1160_SICTL_SDA, addr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = stk1160_write_reg(dev, STK1160_SBUSR_RA, 0x00);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = stk1160_write_reg(dev, STK1160_SICTL, 0x20);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = stk1160_i2c_busy_wait(dev, 0x01);\n\tif (rc < 0)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\n \nstatic int stk1160_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t   struct i2c_msg msgs[], int num)\n{\n\tstruct stk1160 *dev = i2c_adap->algo_data;\n\tint addr, rc, i;\n\n\tfor (i = 0; i < num; i++) {\n\t\taddr = msgs[i].addr << 1;\n\t\tdprintk_i2c(\"%s: addr=%x\", __func__, addr);\n\n\t\tif (!msgs[i].len) {\n\t\t\t \n\t\t\trc = stk1160_i2c_check_for_device(dev, addr);\n\t\t\tif (rc < 0) {\n\t\t\t\tdprintk_i2c(\" no device\\n\");\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t} else if (msgs[i].flags & I2C_M_RD) {\n\t\t\t \n\t\t\tdprintk_i2c(\" subaddr not selected\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto err;\n\n\t\t} else if (i + 1 < num && msgs[i].len <= 2 &&\n\t\t\t   (msgs[i + 1].flags & I2C_M_RD) &&\n\t\t\t   msgs[i].addr == msgs[i + 1].addr) {\n\n\t\t\tif (msgs[i].len != 1 || msgs[i + 1].len != 1) {\n\t\t\t\tdprintk_i2c(\" len not supported\");\n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tdprintk_i2c(\" subaddr=%x\", msgs[i].buf[0]);\n\n\t\t\trc = stk1160_i2c_read_reg(dev, addr, msgs[i].buf[0],\n\t\t\t\tmsgs[i + 1].buf);\n\n\t\t\tdprintk_i2c(\" read=%x\", *msgs[i + 1].buf);\n\n\t\t\t \n\t\t\ti++;\n\n\t\t} else {\n\t\t\tif (msgs[i].len != 2) {\n\t\t\t\tdprintk_i2c(\" len not supported\");\n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tdprintk_i2c(\" subaddr=%x write=%x\",\n\t\t\t\tmsgs[i].buf[0],  msgs[i].buf[1]);\n\n\t\t\trc = stk1160_i2c_write_reg(dev, addr, msgs[i].buf[0],\n\t\t\t\tmsgs[i].buf[1]);\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\tgoto err;\n\t\tdprintk_i2c(\" OK\\n\");\n\t}\n\n\treturn num;\nerr:\n\tdprintk_i2c(\" ERROR: %d\\n\", rc);\n\treturn num;\n}\n\n \nstatic u32 functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm algo = {\n\t.master_xfer   = stk1160_i2c_xfer,\n\t.functionality = functionality,\n};\n\nstatic const struct i2c_adapter adap_template = {\n\t.owner = THIS_MODULE,\n\t.name = \"stk1160\",\n\t.algo = &algo,\n};\n\nstatic const struct i2c_client client_template = {\n\t.name = \"stk1160 internal\",\n};\n\n \nint stk1160_i2c_register(struct stk1160 *dev)\n{\n\tint rc;\n\n\tdev->i2c_adap = adap_template;\n\tdev->i2c_adap.dev.parent = dev->dev;\n\tstrscpy(dev->i2c_adap.name, \"stk1160\", sizeof(dev->i2c_adap.name));\n\tdev->i2c_adap.algo_data = dev;\n\n\ti2c_set_adapdata(&dev->i2c_adap, &dev->v4l2_dev);\n\n\trc = i2c_add_adapter(&dev->i2c_adap);\n\tif (rc < 0) {\n\t\tstk1160_err(\"cannot add i2c adapter (%d)\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tdev->i2c_client = client_template;\n\tdev->i2c_client.adapter = &dev->i2c_adap;\n\n\t \n\tstk1160_write_reg(dev, STK1160_SICTL_CD,  0x0f);\n\n\t \n\tstk1160_write_reg(dev, STK1160_ASIC + 3,  0x00);\n\n\treturn 0;\n}\n\n \nint stk1160_i2c_unregister(struct stk1160 *dev)\n{\n\ti2c_del_adapter(&dev->i2c_adap);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}