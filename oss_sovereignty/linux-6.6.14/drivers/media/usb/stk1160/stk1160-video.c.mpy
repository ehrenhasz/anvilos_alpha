{
  "module_name": "stk1160-video.c",
  "hash_id": "0925b3dd1526d7a88d4c6526f72be56b839c22c2572b4eb17320713d8733e410",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/stk1160/stk1160-video.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/slab.h>\n#include <linux/ratelimit.h>\n\n#include \"stk1160.h\"\n\nstatic unsigned int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable debug messages\");\n\nstatic inline void print_err_status(struct stk1160 *dev,\n\t\t\t\t     int packet, int status)\n{\n\tchar *errmsg = \"Unknown\";\n\n\tswitch (status) {\n\tcase -ENOENT:\n\t\terrmsg = \"unlinked synchronously\";\n\t\tbreak;\n\tcase -ECONNRESET:\n\t\terrmsg = \"unlinked asynchronously\";\n\t\tbreak;\n\tcase -ENOSR:\n\t\terrmsg = \"Buffer error (overrun)\";\n\t\tbreak;\n\tcase -EPIPE:\n\t\terrmsg = \"Stalled (device not responding)\";\n\t\tbreak;\n\tcase -EOVERFLOW:\n\t\terrmsg = \"Babble (bad cable?)\";\n\t\tbreak;\n\tcase -EPROTO:\n\t\terrmsg = \"Bit-stuff error (bad cable?)\";\n\t\tbreak;\n\tcase -EILSEQ:\n\t\terrmsg = \"CRC/Timeout (could be anything)\";\n\t\tbreak;\n\tcase -ETIME:\n\t\terrmsg = \"Device does not respond\";\n\t\tbreak;\n\t}\n\n\tif (packet < 0)\n\t\tprintk_ratelimited(KERN_WARNING \"URB status %d [%s].\\n\",\n\t\t\t\tstatus, errmsg);\n\telse\n\t\tprintk_ratelimited(KERN_INFO \"URB packet %d, status %d [%s].\\n\",\n\t\t\t       packet, status, errmsg);\n}\n\nstatic inline\nstruct stk1160_buffer *stk1160_next_buffer(struct stk1160 *dev)\n{\n\tstruct stk1160_buffer *buf = NULL;\n\tunsigned long flags = 0;\n\n\t \n\tWARN_ON(dev->isoc_ctl.buf);\n\n\tspin_lock_irqsave(&dev->buf_lock, flags);\n\tif (!list_empty(&dev->avail_bufs)) {\n\t\tbuf = list_first_entry(&dev->avail_bufs,\n\t\t\t\tstruct stk1160_buffer, list);\n\t\tlist_del(&buf->list);\n\t}\n\tspin_unlock_irqrestore(&dev->buf_lock, flags);\n\n\treturn buf;\n}\n\nstatic inline\nvoid stk1160_buffer_done(struct stk1160 *dev)\n{\n\tstruct stk1160_buffer *buf = dev->isoc_ctl.buf;\n\n\tbuf->vb.sequence = dev->sequence++;\n\tbuf->vb.field = V4L2_FIELD_INTERLACED;\n\tbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\n\tvb2_set_plane_payload(&buf->vb.vb2_buf, 0, buf->bytesused);\n\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\n\tdev->isoc_ctl.buf = NULL;\n}\n\nstatic inline\nvoid stk1160_copy_video(struct stk1160 *dev, u8 *src, int len)\n{\n\tint linesdone, lineoff, lencopy;\n\tint bytesperline = dev->width * 2;\n\tstruct stk1160_buffer *buf = dev->isoc_ctl.buf;\n\tu8 *dst = buf->mem;\n\tint remain;\n\n\t \n\n\tlen -= 4;\n\tsrc += 4;\n\n\tremain = len;\n\n\tlinesdone = buf->pos / bytesperline;\n\tlineoff = buf->pos % bytesperline;  \n\n\tif (!buf->odd)\n\t\tdst += bytesperline;\n\n\t \n\tdst += linesdone * bytesperline * 2 + lineoff;\n\n\t \n\tif (remain < (bytesperline - lineoff))\n\t\tlencopy = remain;\n\telse\n\t\tlencopy = bytesperline - lineoff;\n\n\t \n\tif (lencopy > buf->bytesused - buf->length) {\n\t\tlencopy = buf->bytesused - buf->length;\n\t\tremain = lencopy;\n\t}\n\n\t \n\tif (lencopy == 0 || remain == 0)\n\t\treturn;\n\n\t \n\tif (lencopy < 0) {\n\t\tstk1160_dbg(\"copy skipped: negative lencopy\\n\");\n\t\treturn;\n\t}\n\n\tif ((unsigned long)dst + lencopy >\n\t\t(unsigned long)buf->mem + buf->length) {\n\t\tprintk_ratelimited(KERN_WARNING \"stk1160: buffer overflow detected\\n\");\n\t\treturn;\n\t}\n\n\tmemcpy(dst, src, lencopy);\n\n\tbuf->bytesused += lencopy;\n\tbuf->pos += lencopy;\n\tremain -= lencopy;\n\n\t \n\twhile (remain > 0) {\n\n\t\tdst += lencopy + bytesperline;\n\t\tsrc += lencopy;\n\n\t\t \n\t\tif (remain < bytesperline)\n\t\t\tlencopy = remain;\n\t\telse\n\t\t\tlencopy = bytesperline;\n\n\t\t \n\t\tif (lencopy > buf->bytesused - buf->length) {\n\t\t\tlencopy = buf->bytesused - buf->length;\n\t\t\tremain = lencopy;\n\t\t}\n\n\t\t \n\t\tif (lencopy == 0 || remain == 0)\n\t\t\treturn;\n\n\t\tif (lencopy < 0) {\n\t\t\tprintk_ratelimited(KERN_WARNING \"stk1160: negative lencopy detected\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif ((unsigned long)dst + lencopy >\n\t\t\t(unsigned long)buf->mem + buf->length) {\n\t\t\tprintk_ratelimited(KERN_WARNING \"stk1160: buffer overflow detected\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tmemcpy(dst, src, lencopy);\n\t\tremain -= lencopy;\n\n\t\tbuf->bytesused += lencopy;\n\t\tbuf->pos += lencopy;\n\t}\n}\n\n \nstatic void stk1160_process_isoc(struct stk1160 *dev, struct urb *urb)\n{\n\tint i, len, status;\n\tu8 *p;\n\n\tif (!dev) {\n\t\tstk1160_warn(\"%s called with null device\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (urb->status < 0) {\n\t\t \n\t\tprint_err_status(dev, -1, urb->status);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\tstatus = urb->iso_frame_desc[i].status;\n\t\tif (status < 0) {\n\t\t\tprint_err_status(dev, i, status);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tp = urb->transfer_buffer + urb->iso_frame_desc[i].offset;\n\t\tlen = urb->iso_frame_desc[i].actual_length;\n\n\t\t \n\t\tif (len <= 4)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (p[0] == 0xc0) {\n\n\t\t\t \n\t\t\tif (dev->isoc_ctl.buf != NULL)\n\t\t\t\tstk1160_buffer_done(dev);\n\n\t\t\tdev->isoc_ctl.buf = stk1160_next_buffer(dev);\n\t\t\tif (dev->isoc_ctl.buf == NULL)\n\t\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (dev->isoc_ctl.buf == NULL)\n\t\t\tcontinue;\n\n\t\tif (p[0] == 0xc0 || p[0] == 0x80) {\n\n\t\t\t \n\t\t\tdev->isoc_ctl.buf->odd = *p & 0x40;\n\t\t\tdev->isoc_ctl.buf->pos = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstk1160_copy_video(dev, p, len);\n\t}\n}\n\n\n \nstatic void stk1160_isoc_irq(struct urb *urb)\n{\n\tint i, rc;\n\tstruct stk1160_urb *stk_urb = urb->context;\n\tstruct stk1160 *dev = stk_urb->dev;\n\tstruct device *dma_dev = stk1160_get_dmadev(dev);\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ECONNRESET:    \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\treturn;\n\tdefault:\n\t\tstk1160_err(\"urb error! status %d\\n\", urb->status);\n\t\treturn;\n\t}\n\n\tinvalidate_kernel_vmap_range(stk_urb->transfer_buffer,\n\t\t\t\t     urb->transfer_buffer_length);\n\tdma_sync_sgtable_for_cpu(dma_dev, stk_urb->sgt, DMA_FROM_DEVICE);\n\n\tstk1160_process_isoc(dev, urb);\n\n\t \n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\turb->iso_frame_desc[i].status = 0;\n\t\turb->iso_frame_desc[i].actual_length = 0;\n\t}\n\n\tdma_sync_sgtable_for_device(dma_dev, stk_urb->sgt, DMA_FROM_DEVICE);\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (rc)\n\t\tstk1160_err(\"urb re-submit failed (%d)\\n\", rc);\n}\n\n \nvoid stk1160_cancel_isoc(struct stk1160 *dev)\n{\n\tint i, num_bufs = dev->isoc_ctl.num_bufs;\n\n\t \n\tif (!num_bufs)\n\t\treturn;\n\n\tstk1160_dbg(\"killing %d urbs...\\n\", num_bufs);\n\n\tfor (i = 0; i < num_bufs; i++) {\n\n\t\t \n\t\tusb_kill_urb(dev->isoc_ctl.urb_ctl[i].urb);\n\t}\n\n\tstk1160_dbg(\"all urbs killed\\n\");\n}\n\nstatic void stk_free_urb(struct stk1160 *dev, struct stk1160_urb *stk_urb)\n{\n\tstruct device *dma_dev = stk1160_get_dmadev(dev);\n\n\tdma_vunmap_noncontiguous(dma_dev, stk_urb->transfer_buffer);\n\tdma_free_noncontiguous(dma_dev, stk_urb->urb->transfer_buffer_length,\n\t\t\t       stk_urb->sgt, DMA_FROM_DEVICE);\n\tusb_free_urb(stk_urb->urb);\n\n\tstk_urb->transfer_buffer = NULL;\n\tstk_urb->sgt = NULL;\n\tstk_urb->urb = NULL;\n\tstk_urb->dev = NULL;\n\tstk_urb->dma = 0;\n}\n\n \nvoid stk1160_free_isoc(struct stk1160 *dev)\n{\n\tint i, num_bufs = dev->isoc_ctl.num_bufs;\n\n\tstk1160_dbg(\"freeing %d urb buffers...\\n\", num_bufs);\n\n\tfor (i = 0; i < num_bufs; i++)\n\t\tstk_free_urb(dev, &dev->isoc_ctl.urb_ctl[i]);\n\n\tdev->isoc_ctl.num_bufs = 0;\n\n\tstk1160_dbg(\"all urb buffers freed\\n\");\n}\n\n \nvoid stk1160_uninit_isoc(struct stk1160 *dev)\n{\n\tstk1160_cancel_isoc(dev);\n\tstk1160_free_isoc(dev);\n}\n\nstatic int stk1160_fill_urb(struct stk1160 *dev, struct stk1160_urb *stk_urb,\n\t\t\t    int sb_size, int max_packets)\n{\n\tstruct device *dma_dev = stk1160_get_dmadev(dev);\n\n\tstk_urb->urb = usb_alloc_urb(max_packets, GFP_KERNEL);\n\tif (!stk_urb->urb)\n\t\treturn -ENOMEM;\n\tstk_urb->sgt = dma_alloc_noncontiguous(dma_dev, sb_size,\n\t\t\t\t\t       DMA_FROM_DEVICE, GFP_KERNEL, 0);\n\n\t \n\tif (!stk_urb->sgt)\n\t\tgoto free_urb;\n\n\tstk_urb->transfer_buffer = dma_vmap_noncontiguous(dma_dev, sb_size,\n\t\t\t\t\t\t\t  stk_urb->sgt);\n\tif (!stk_urb->transfer_buffer)\n\t\tgoto free_sgt;\n\n\tstk_urb->dma = stk_urb->sgt->sgl->dma_address;\n\tstk_urb->dev = dev;\n\treturn 0;\nfree_sgt:\n\tdma_free_noncontiguous(dma_dev, sb_size, stk_urb->sgt, DMA_FROM_DEVICE);\n\tstk_urb->sgt = NULL;\nfree_urb:\n\tusb_free_urb(stk_urb->urb);\n\tstk_urb->urb = NULL;\n\n\treturn 0;\n}\n \nint stk1160_alloc_isoc(struct stk1160 *dev)\n{\n\tstruct urb *urb;\n\tint i, j, k, sb_size, max_packets, num_bufs;\n\tint ret;\n\n\t \n\tif (dev->isoc_ctl.num_bufs)\n\t\tstk1160_uninit_isoc(dev);\n\n\tstk1160_dbg(\"allocating urbs...\\n\");\n\n\tnum_bufs = STK1160_NUM_BUFS;\n\tmax_packets = STK1160_NUM_PACKETS;\n\tsb_size = max_packets * dev->max_pkt_size;\n\n\tdev->isoc_ctl.buf = NULL;\n\tdev->isoc_ctl.max_pkt_size = dev->max_pkt_size;\n\n\t \n\tfor (i = 0; i < num_bufs; i++) {\n\n\t\tret = stk1160_fill_urb(dev, &dev->isoc_ctl.urb_ctl[i],\n\t\t\t\t       sb_size, max_packets);\n\t\tif (ret)\n\t\t\tgoto free_i_bufs;\n\n\t\turb = dev->isoc_ctl.urb_ctl[i].urb;\n\n\t\tif (!urb) {\n\t\t\t \n\t\t\tif (i < STK1160_MIN_BUFS)\n\t\t\t\tgoto free_i_bufs;\n\t\t\tgoto nomore_tx_bufs;\n\t\t}\n\t\tmemset(dev->isoc_ctl.urb_ctl[i].transfer_buffer, 0, sb_size);\n\n\t\t \n\t\turb->dev = dev->udev;\n\t\turb->pipe = usb_rcvisocpipe(dev->udev, STK1160_EP_VIDEO);\n\t\turb->transfer_buffer = dev->isoc_ctl.urb_ctl[i].transfer_buffer;\n\t\turb->transfer_buffer_length = sb_size;\n\t\turb->complete = stk1160_isoc_irq;\n\t\turb->context = &dev->isoc_ctl.urb_ctl[i];\n\t\turb->interval = 1;\n\t\turb->start_frame = 0;\n\t\turb->number_of_packets = max_packets;\n\t\turb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\n\t\turb->transfer_dma = dev->isoc_ctl.urb_ctl[i].dma;\n\n\t\tk = 0;\n\t\tfor (j = 0; j < max_packets; j++) {\n\t\t\turb->iso_frame_desc[j].offset = k;\n\t\t\turb->iso_frame_desc[j].length =\n\t\t\t\t\tdev->isoc_ctl.max_pkt_size;\n\t\t\tk += dev->isoc_ctl.max_pkt_size;\n\t\t}\n\t}\n\n\tstk1160_dbg(\"%d urbs allocated\\n\", num_bufs);\n\n\t \n\tdev->isoc_ctl.num_bufs = num_bufs;\n\n\treturn 0;\n\nnomore_tx_bufs:\n\t \n\n\tstk1160_warn(\"%d urbs allocated. Trying to continue...\\n\", i);\n\n\tdev->isoc_ctl.num_bufs = i;\n\n\treturn 0;\n\nfree_i_bufs:\n\t \n\tdev->isoc_ctl.num_bufs = i;\n\tstk1160_free_isoc(dev);\n\treturn -ENOMEM;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}