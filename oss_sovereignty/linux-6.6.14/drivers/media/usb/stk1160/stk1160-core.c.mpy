{
  "module_name": "stk1160-core.c",
  "hash_id": "30a178aad239a15d931498d77979f2a53f9e085ec0a1efed1266c17fd4e188d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/stk1160/stk1160-core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n\n#include <linux/usb.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <media/i2c/saa7115.h>\n\n#include \"stk1160.h\"\n#include \"stk1160-reg.h\"\n\nstatic unsigned int input;\nmodule_param(input, int, 0644);\nMODULE_PARM_DESC(input, \"Set default input\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ezequiel Garcia\");\nMODULE_DESCRIPTION(\"STK1160 driver\");\n\n \nstatic const struct usb_device_id stk1160_id_table[] = {\n\t{ USB_DEVICE(0x05e1, 0x0408) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, stk1160_id_table);\n\n \nstatic unsigned short saa7113_addrs[] = {\n\t0x4a >> 1,\n\tI2C_CLIENT_END\n};\n\n \nint stk1160_read_reg(struct stk1160 *dev, u16 reg, u8 *value)\n{\n\tint ret;\n\tint pipe = usb_rcvctrlpipe(dev->udev, 0);\n\tu8 *buf;\n\n\t*value = 0;\n\n\tbuf = kmalloc(sizeof(u8), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = usb_control_msg(dev->udev, pipe, 0x00,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0x00, reg, buf, sizeof(u8), 1000);\n\tif (ret < 0) {\n\t\tstk1160_err(\"read failed on reg 0x%x (%d)\\n\",\n\t\t\treg, ret);\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\t*value = *buf;\n\tkfree(buf);\n\treturn 0;\n}\n\nint stk1160_write_reg(struct stk1160 *dev, u16 reg, u16 value)\n{\n\tint ret;\n\tint pipe = usb_sndctrlpipe(dev->udev, 0);\n\n\tret =  usb_control_msg(dev->udev, pipe, 0x01,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tvalue, reg, NULL, 0, 1000);\n\tif (ret < 0) {\n\t\tstk1160_err(\"write failed on reg 0x%x (%d)\\n\",\n\t\t\treg, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid stk1160_select_input(struct stk1160 *dev)\n{\n\tint route;\n\tstatic const u8 gctrl[] = {\n\t\t0x98, 0x90, 0x88, 0x80, 0x98\n\t};\n\n\tif (dev->ctl_input == STK1160_SVIDEO_INPUT)\n\t\troute = SAA7115_SVIDEO3;\n\telse\n\t\troute = SAA7115_COMPOSITE0;\n\n\tif (dev->ctl_input < ARRAY_SIZE(gctrl)) {\n\t\tv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_routing,\n\t\t\t\troute, 0, 0);\n\t\tstk1160_write_reg(dev, STK1160_GCTRL, gctrl[dev->ctl_input]);\n\t}\n}\n\n \nstatic void stk1160_reg_reset(struct stk1160 *dev)\n{\n\tint i;\n\n\tstatic const struct regval ctl[] = {\n\t\t{STK1160_GCTRL+2, 0x0078},\n\n\t\t{STK1160_RMCTL+1, 0x0000},\n\t\t{STK1160_RMCTL+3, 0x0002},\n\n\t\t{STK1160_PLLSO,   0x0010},\n\t\t{STK1160_PLLSO+1, 0x0000},\n\t\t{STK1160_PLLSO+2, 0x0014},\n\t\t{STK1160_PLLSO+3, 0x000E},\n\n\t\t{STK1160_PLLFD,   0x0046},\n\n\t\t \n\t\t{STK1160_TIGEN,   0x0012},\n\t\t{STK1160_TICTL,   0x002D},\n\t\t{STK1160_TICTL+1, 0x0001},\n\t\t{STK1160_TICTL+2, 0x0000},\n\t\t{STK1160_TICTL+3, 0x0000},\n\t\t{STK1160_TIGEN,   0x0080},\n\n\t\t{0xffff, 0xffff}\n\t};\n\n\tfor (i = 0; ctl[i].reg != 0xffff; i++)\n\t\tstk1160_write_reg(dev, ctl[i].reg, ctl[i].val);\n}\n\nstatic void stk1160_release(struct v4l2_device *v4l2_dev)\n{\n\tstruct stk1160 *dev = container_of(v4l2_dev, struct stk1160, v4l2_dev);\n\n\tstk1160_dbg(\"releasing all resources\\n\");\n\n\tstk1160_i2c_unregister(dev);\n\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tmutex_destroy(&dev->v4l_lock);\n\tmutex_destroy(&dev->vb_queue_lock);\n\tkfree(dev->alt_max_pkt_size);\n\tkfree(dev);\n}\n\n \n#define hb_mult(wMaxPacketSize) (1 + (((wMaxPacketSize) >> 11) & 0x03))\n\n \nstatic int stk1160_scan_usb(struct usb_interface *intf, struct usb_device *udev,\n\t\tunsigned int *max_pkt_size)\n{\n\tint i, e, sizedescr, size, ifnum;\n\tconst struct usb_endpoint_descriptor *desc;\n\n\tbool has_video = false, has_audio = false;\n\tconst char *speed;\n\n\tifnum = intf->altsetting[0].desc.bInterfaceNumber;\n\n\t \n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\n\t\tfor (e = 0; e < intf->altsetting[i].desc.bNumEndpoints; e++) {\n\n\t\t\t \n\t\t\tdesc = &intf->altsetting[i].endpoint[e].desc;\n\t\t\tsizedescr = le16_to_cpu(desc->wMaxPacketSize);\n\t\t\tsize = sizedescr & 0x7ff;\n\n\t\t\tif (udev->speed == USB_SPEED_HIGH)\n\t\t\t\tsize = size * hb_mult(sizedescr);\n\n\t\t\tif (usb_endpoint_xfer_isoc(desc) &&\n\t\t\t    usb_endpoint_dir_in(desc)) {\n\t\t\t\tswitch (desc->bEndpointAddress) {\n\t\t\t\tcase STK1160_EP_AUDIO:\n\t\t\t\t\thas_audio = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase STK1160_EP_VIDEO:\n\t\t\t\t\thas_video = true;\n\t\t\t\t\tmax_pkt_size[i] = size;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!(has_audio || has_video)) {\n\t\tdev_err(&udev->dev, \"no audio or video endpoints found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (udev->speed) {\n\tcase USB_SPEED_LOW:\n\t\tspeed = \"1.5\";\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tspeed = \"12\";\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tspeed = \"480\";\n\t\tbreak;\n\tdefault:\n\t\tspeed = \"unknown\";\n\t}\n\n\tdev_info(&udev->dev, \"New device %s %s @ %s Mbps (%04x:%04x, interface %d, class %d)\\n\",\n\t\tudev->manufacturer ? udev->manufacturer : \"\",\n\t\tudev->product ? udev->product : \"\",\n\t\tspeed,\n\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\tle16_to_cpu(udev->descriptor.idProduct),\n\t\tifnum,\n\t\tintf->altsetting->desc.bInterfaceNumber);\n\n\t \n\tif (has_audio)\n\t\tdev_warn(&udev->dev, \"audio interface %d found.\\n\\\n\t\t\t\tThis is not implemented by this driver,\\\n\t\t\t\tyou should use snd-usb-audio instead\\n\", ifnum);\n\n\tif (has_video)\n\t\tdev_info(&udev->dev, \"video interface %d found\\n\",\n\t\t\t\tifnum);\n\n\t/*\n\t * Make sure we have 480 Mbps of bandwidth, otherwise things like\n\t * video stream wouldn't likely work, since 12 Mbps is generally\n\t * not enough even for most streams.\n\t */\n\tif (udev->speed != USB_SPEED_HIGH)\n\t\tdev_warn(&udev->dev, \"must be connected to a high-speed USB 2.0 port\\n\\\n\t\t\t\tYou may not be able to stream video smoothly\\n\");\n\n\treturn 0;\n}\n\nstatic int stk1160_probe(struct usb_interface *interface,\n\t\tconst struct usb_device_id *id)\n{\n\tint rc = 0;\n\n\tunsigned int *alt_max_pkt_size;\t/* array of wMaxPacketSize */\n\tstruct usb_device *udev;\n\tstruct stk1160 *dev;\n\n\tudev = interface_to_usbdev(interface);\n\n\t/*\n\t * Since usb audio class is supported by snd-usb-audio,\n\t * we reject audio interface.\n\t */\n\tif (interface->altsetting[0].desc.bInterfaceClass == USB_CLASS_AUDIO)\n\t\treturn -ENODEV;\n\n\t/* Alloc an array for all possible max_pkt_size */\n\talt_max_pkt_size = kmalloc_array(interface->num_altsetting,\n\t\t\t\t\t sizeof(alt_max_pkt_size[0]),\n\t\t\t\t\t GFP_KERNEL);\n\tif (alt_max_pkt_size == NULL)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Scan usb possibilities and populate alt_max_pkt_size array.\n\t * Also, check if device speed is fast enough.\n\t */\n\trc = stk1160_scan_usb(interface, udev, alt_max_pkt_size);\n\tif (rc < 0) {\n\t\tkfree(alt_max_pkt_size);\n\t\treturn rc;\n\t}\n\n\tdev = kzalloc(sizeof(struct stk1160), GFP_KERNEL);\n\tif (dev == NULL) {\n\t\tkfree(alt_max_pkt_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev->alt_max_pkt_size = alt_max_pkt_size;\n\tdev->udev = udev;\n\tdev->num_alt = interface->num_altsetting;\n\tdev->ctl_input = input;\n\n\t/* We save struct device for debug purposes only */\n\tdev->dev = &interface->dev;\n\n\tusb_set_intfdata(interface, dev);\n\n\t/* initialize videobuf2 stuff */\n\trc = stk1160_vb2_setup(dev);\n\tif (rc < 0)\n\t\tgoto free_err;\n\n\t/*\n\t * There is no need to take any locks here in probe\n\t * because we register the device node as the *last* thing.\n\t */\n\tspin_lock_init(&dev->buf_lock);\n\tmutex_init(&dev->v4l_lock);\n\tmutex_init(&dev->vb_queue_lock);\n\n\trc = v4l2_ctrl_handler_init(&dev->ctrl_handler, 0);\n\tif (rc) {\n\t\tstk1160_err(\"v4l2_ctrl_handler_init failed (%d)\\n\", rc);\n\t\tgoto free_err;\n\t}\n\n\t/*\n\t * We obtain a v4l2_dev but defer\n\t * registration of video device node as the last thing.\n\t * There is no need to set the name if we give a device struct\n\t */\n\tdev->v4l2_dev.release = stk1160_release;\n\tdev->v4l2_dev.ctrl_handler = &dev->ctrl_handler;\n\trc = v4l2_device_register(dev->dev, &dev->v4l2_dev);\n\tif (rc) {\n\t\tstk1160_err(\"v4l2_device_register failed (%d)\\n\", rc);\n\t\tgoto free_ctrl;\n\t}\n\n\trc = stk1160_i2c_register(dev);\n\tif (rc < 0)\n\t\tgoto unreg_v4l2;\n\n\t/*\n\t * To the best of my knowledge stk1160 boards only have\n\t * saa7113, but it doesn't hurt to support them all.\n\t */\n\tdev->sd_saa7115 = v4l2_i2c_new_subdev(&dev->v4l2_dev, &dev->i2c_adap,\n\t\t\"saa7115_auto\", 0, saa7113_addrs);\n\n\t/* i2c reset saa711x */\n\tv4l2_device_call_all(&dev->v4l2_dev, 0, core, reset, 0);\n\tv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_stream, 0);\n\n\t/* reset stk1160 to default values */\n\tstk1160_reg_reset(dev);\n\n\t/* select default input */\n\tstk1160_select_input(dev);\n\n\tstk1160_ac97_setup(dev);\n\n\trc = stk1160_video_register(dev);\n\tif (rc < 0)\n\t\tgoto unreg_i2c;\n\n\treturn 0;\n\nunreg_i2c:\n\tstk1160_i2c_unregister(dev);\nunreg_v4l2:\n\tv4l2_device_unregister(&dev->v4l2_dev);\nfree_ctrl:\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\nfree_err:\n\tkfree(alt_max_pkt_size);\n\tkfree(dev);\n\n\treturn rc;\n}\n\nstatic void stk1160_disconnect(struct usb_interface *interface)\n{\n\tstruct stk1160 *dev;\n\n\tdev = usb_get_intfdata(interface);\n\tusb_set_intfdata(interface, NULL);\n\n\t/*\n\t * Wait until all current v4l2 operation are finished\n\t * then deallocate resources\n\t */\n\tmutex_lock(&dev->vb_queue_lock);\n\tmutex_lock(&dev->v4l_lock);\n\n\t/* Here is the only place where isoc get released */\n\tstk1160_uninit_isoc(dev);\n\n\tstk1160_clear_queue(dev, VB2_BUF_STATE_ERROR);\n\n\tvideo_unregister_device(&dev->vdev);\n\tv4l2_device_disconnect(&dev->v4l2_dev);\n\n\t/* This way current users can detect device is gone */\n\tdev->udev = NULL;\n\n\tmutex_unlock(&dev->v4l_lock);\n\tmutex_unlock(&dev->vb_queue_lock);\n\n\t/*\n\t * This calls stk1160_release if it's the last reference.\n\t * Otherwise, release is postponed until there are no users left.\n\t */\n\tv4l2_device_put(&dev->v4l2_dev);\n}\n\nstatic struct usb_driver stk1160_usb_driver = {\n\t.name = \"stk1160\",\n\t.id_table = stk1160_id_table,\n\t.probe = stk1160_probe,\n\t.disconnect = stk1160_disconnect,\n};\n\nmodule_usb_driver(stk1160_usb_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}