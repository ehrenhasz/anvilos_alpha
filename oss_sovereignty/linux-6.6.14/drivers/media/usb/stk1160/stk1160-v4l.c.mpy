{
  "module_name": "stk1160-v4l.c",
  "hash_id": "44ae477e9ad8a90258f24f9b25c3bce6fce826c798e907333f28ef308740bbf4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/stk1160/stk1160-v4l.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-vmalloc.h>\n\n#include <media/i2c/saa7115.h>\n\n#include \"stk1160.h\"\n#include \"stk1160-reg.h\"\n\nstatic bool keep_buffers;\nmodule_param(keep_buffers, bool, 0644);\nMODULE_PARM_DESC(keep_buffers, \"don't release buffers upon stop streaming\");\n\nenum stk1160_decimate_mode {\n\tSTK1160_DECIMATE_MORE_THAN_HALF,\n\tSTK1160_DECIMATE_LESS_THAN_HALF,\n};\n\nstruct stk1160_decimate_ctrl {\n\tbool col_en, row_en;\n\tenum stk1160_decimate_mode col_mode, row_mode;\n\tunsigned int col_n, row_n;\n};\n\n \nstatic struct stk1160_fmt format[] = {\n\t{\n\t\t.fourcc   = V4L2_PIX_FMT_UYVY,\n\t\t.depth    = 16,\n\t}\n};\n\n \nstatic unsigned int\ndiv_round_integer(unsigned int x, unsigned int y)\n{\n\tfor (;; y++) {\n\t\tif (x % y == 0)\n\t\t\treturn x / y;\n\t}\n}\n\nstatic void stk1160_set_std(struct stk1160 *dev)\n{\n\tint i;\n\n\tstatic struct regval std525[] = {\n\n\t\t \n\n\t\t \n\t\t{STK116_CFSPO_STX_L, 0x0000},\n\t\t{STK116_CFSPO_STX_H, 0x0000},\n\t\t{STK116_CFSPO_STY_L, 0x0003},\n\t\t{STK116_CFSPO_STY_H, 0x0000},\n\n\t\t \n\t\t{STK116_CFEPO_ENX_L, 0x05a0},\n\t\t{STK116_CFEPO_ENX_H, 0x0005},\n\t\t{STK116_CFEPO_ENY_L, 0x00f3},\n\t\t{STK116_CFEPO_ENY_H, 0x0000},\n\n\t\t{0xffff, 0xffff}\n\t};\n\n\tstatic struct regval std625[] = {\n\n\t\t \n\n\t\t \n\t\t \n\t\t{STK116_CFSPO,   0x0000},\n\t\t{STK116_CFSPO+1, 0x0000},\n\t\t{STK116_CFSPO+2, 0x0001},\n\t\t{STK116_CFSPO+3, 0x0000},\n\n\t\t \n\t\t{STK116_CFEPO,   0x05a0},\n\t\t{STK116_CFEPO+1, 0x0005},\n\t\t{STK116_CFEPO+2, 0x0121},\n\t\t{STK116_CFEPO+3, 0x0001},\n\n\t\t{0xffff, 0xffff}\n\t};\n\n\tif (dev->norm & V4L2_STD_525_60) {\n\t\tstk1160_dbg(\"registers to NTSC like standard\\n\");\n\t\tfor (i = 0; std525[i].reg != 0xffff; i++)\n\t\t\tstk1160_write_reg(dev, std525[i].reg, std525[i].val);\n\t} else {\n\t\tstk1160_dbg(\"registers to PAL like standard\\n\");\n\t\tfor (i = 0; std625[i].reg != 0xffff; i++)\n\t\t\tstk1160_write_reg(dev, std625[i].reg, std625[i].val);\n\t}\n\n}\n\nstatic void stk1160_set_fmt(struct stk1160 *dev,\n\t\t\t    struct stk1160_decimate_ctrl *ctrl)\n{\n\tu32 val = 0;\n\n\tif (ctrl) {\n\t\t \n\t\tval |= STK1160_DEC_UNIT_SIZE;\n\t\tval |= ctrl->col_en ? STK1160_H_DEC_EN : 0;\n\t\tval |= ctrl->row_en ? STK1160_V_DEC_EN : 0;\n\t\tval |= ctrl->col_mode ==\n\t\t\tSTK1160_DECIMATE_MORE_THAN_HALF ?\n\t\t\tSTK1160_H_DEC_MODE : 0;\n\t\tval |= ctrl->row_mode ==\n\t\t\tSTK1160_DECIMATE_MORE_THAN_HALF ?\n\t\t\tSTK1160_V_DEC_MODE : 0;\n\n\t\t \n\t\tstk1160_write_reg(dev, STK1160_DMCTRL_H_UNITS, ctrl->col_n);\n\t\t \n\t\tstk1160_write_reg(dev, STK1160_DMCTRL_V_UNITS, ctrl->row_n);\n\n\t\tstk1160_dbg(\"decimate 0x%x, column units %d, row units %d\\n\",\n\t\t\t    val, ctrl->col_n, ctrl->row_n);\n\t}\n\n\t \n\tstk1160_write_reg(dev, STK1160_DMCTRL, val);\n}\n\n \nstatic bool stk1160_set_alternate(struct stk1160 *dev)\n{\n\tint i, prev_alt = dev->alt;\n\tunsigned int min_pkt_size;\n\tbool new_pkt_size;\n\n\t \n\tmin_pkt_size = STK1160_MIN_PKT_SIZE;\n\n\tfor (i = 0; i < dev->num_alt; i++) {\n\t\t \n\t\tif (dev->alt_max_pkt_size[i] >= min_pkt_size) {\n\t\t\tdev->alt = i;\n\t\t\tbreak;\n\t\t \n\t\t} else if (dev->alt_max_pkt_size[i] >\n\t\t\t   dev->alt_max_pkt_size[dev->alt])\n\t\t\tdev->alt = i;\n\t}\n\n\tstk1160_dbg(\"setting alternate %d\\n\", dev->alt);\n\n\tif (dev->alt != prev_alt) {\n\t\tstk1160_dbg(\"minimum isoc packet size: %u (alt=%d)\\n\",\n\t\t\t\tmin_pkt_size, dev->alt);\n\t\tstk1160_dbg(\"setting alt %d with wMaxPacketSize=%u\\n\",\n\t\t\t       dev->alt, dev->alt_max_pkt_size[dev->alt]);\n\t\tusb_set_interface(dev->udev, 0, dev->alt);\n\t}\n\n\tnew_pkt_size = dev->max_pkt_size != dev->alt_max_pkt_size[dev->alt];\n\tdev->max_pkt_size = dev->alt_max_pkt_size[dev->alt];\n\n\treturn new_pkt_size;\n}\n\nstatic int stk1160_start_streaming(struct stk1160 *dev)\n{\n\tbool new_pkt_size;\n\tint rc = 0;\n\tint i;\n\n\t \n\tif (!dev->udev)\n\t\treturn -ENODEV;\n\n\tif (mutex_lock_interruptible(&dev->v4l_lock))\n\t\treturn -ERESTARTSYS;\n\t \n\tnew_pkt_size = stk1160_set_alternate(dev);\n\n\t \n\tif (!dev->isoc_ctl.num_bufs || new_pkt_size) {\n\t\trc = stk1160_alloc_isoc(dev);\n\t\tif (rc < 0)\n\t\t\tgoto out_stop_hw;\n\t}\n\n\t \n\tfor (i = 0; i < dev->isoc_ctl.num_bufs; i++) {\n\t\tstruct stk1160_urb *stk_urb = &dev->isoc_ctl.urb_ctl[i];\n\n\t\tdma_sync_sgtable_for_device(stk1160_get_dmadev(dev), stk_urb->sgt,\n\t\t\t\t\t    DMA_FROM_DEVICE);\n\t\trc = usb_submit_urb(dev->isoc_ctl.urb_ctl[i].urb, GFP_KERNEL);\n\t\tif (rc) {\n\t\t\tstk1160_err(\"cannot submit urb[%d] (%d)\\n\", i, rc);\n\t\t\tgoto out_uninit;\n\t\t}\n\t}\n\n\t \n\tv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_stream, 1);\n\n\tdev->sequence = 0;\n\n\t \n\tstk1160_write_reg(dev, STK1160_DCTRL, 0xb3);\n\tstk1160_write_reg(dev, STK1160_DCTRL+3, 0x00);\n\n\tstk1160_dbg(\"streaming started\\n\");\n\n\tmutex_unlock(&dev->v4l_lock);\n\n\treturn 0;\n\nout_uninit:\n\tstk1160_uninit_isoc(dev);\nout_stop_hw:\n\tusb_set_interface(dev->udev, 0, 0);\n\tstk1160_clear_queue(dev, VB2_BUF_STATE_QUEUED);\n\n\tmutex_unlock(&dev->v4l_lock);\n\n\treturn rc;\n}\n\n \nstatic void stk1160_stop_hw(struct stk1160 *dev)\n{\n\t \n\tif (!dev->udev)\n\t\treturn;\n\n\t \n\tdev->alt = 0;\n\tstk1160_dbg(\"setting alternate %d\\n\", dev->alt);\n\tusb_set_interface(dev->udev, 0, 0);\n\n\t \n\tstk1160_write_reg(dev, STK1160_DCTRL, 0x00);\n\tstk1160_write_reg(dev, STK1160_DCTRL+3, 0x00);\n\n\t \n\tv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_stream, 0);\n}\n\nstatic int stk1160_stop_streaming(struct stk1160 *dev)\n{\n\tif (mutex_lock_interruptible(&dev->v4l_lock))\n\t\treturn -ERESTARTSYS;\n\n\t \n\tstk1160_cancel_isoc(dev);\n\n\t \n\tif (!keep_buffers)\n\t\tstk1160_free_isoc(dev);\n\n\tstk1160_stop_hw(dev);\n\n\tstk1160_clear_queue(dev, VB2_BUF_STATE_ERROR);\n\n\tstk1160_dbg(\"streaming stopped\\n\");\n\n\tmutex_unlock(&dev->v4l_lock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations stk1160_fops = {\n\t.owner = THIS_MODULE,\n\t.open = v4l2_fh_open,\n\t.release = vb2_fop_release,\n\t.read = vb2_fop_read,\n\t.poll = vb2_fop_poll,\n\t.mmap = vb2_fop_mmap,\n\t.unlocked_ioctl = video_ioctl2,\n};\n\n \nstatic int vidioc_querycap(struct file *file,\n\t\tvoid *priv, struct v4l2_capability *cap)\n{\n\tstruct stk1160 *dev = video_drvdata(file);\n\n\tstrscpy(cap->driver, \"stk1160\", sizeof(cap->driver));\n\tstrscpy(cap->card, \"stk1160\", sizeof(cap->card));\n\tusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,\n\t\tstruct v4l2_fmtdesc *f)\n{\n\tif (f->index != 0)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = format[f->index].fourcc;\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct stk1160 *dev = video_drvdata(file);\n\n\tf->fmt.pix.width = dev->width;\n\tf->fmt.pix.height = dev->height;\n\tf->fmt.pix.field = V4L2_FIELD_INTERLACED;\n\tf->fmt.pix.pixelformat = dev->fmt->fourcc;\n\tf->fmt.pix.bytesperline = dev->width * 2;\n\tf->fmt.pix.sizeimage = dev->height * f->fmt.pix.bytesperline;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\treturn 0;\n}\n\nstatic int stk1160_try_fmt(struct stk1160 *dev, struct v4l2_format *f,\n\t\t\t    struct stk1160_decimate_ctrl *ctrl)\n{\n\tunsigned int width, height;\n\tunsigned int base_width, base_height;\n\tunsigned int col_n, row_n;\n\tenum stk1160_decimate_mode col_mode, row_mode;\n\tbool col_en, row_en;\n\n\tbase_width = 720;\n\tbase_height = (dev->norm & V4L2_STD_525_60) ? 480 : 576;\n\n\t \n\twidth = clamp_t(unsigned int, f->fmt.pix.width,\n\t\t\tbase_width / 20, base_width);\n\theight = clamp_t(unsigned int, f->fmt.pix.height,\n\t\t\tbase_height / 20, base_height);\n\n\t \n\tcol_n = 0;\n\trow_n = 0;\n\tcol_en = false;\n\trow_en = false;\n\tf->fmt.pix.width = base_width;\n\tf->fmt.pix.height = base_height;\n\trow_mode = STK1160_DECIMATE_LESS_THAN_HALF;\n\tcol_mode = STK1160_DECIMATE_LESS_THAN_HALF;\n\n\tif (width < base_width && width > base_width / 2) {\n\t\t \n\t\tcol_n = div_round_integer(width, base_width - width);\n\t\tif (col_n > 0 && col_n <= 255) {\n\t\t\tcol_en = true;\n\t\t\tcol_mode = STK1160_DECIMATE_LESS_THAN_HALF;\n\t\t\tf->fmt.pix.width = (base_width * col_n) / (col_n + 1);\n\t\t}\n\n\t} else if (width <= base_width / 2) {\n\n\t\t \n\t\tcol_n = div_round_integer(base_width, width) - 1;\n\t\tif (col_n > 0 && col_n <= 255) {\n\t\t\tcol_en = true;\n\t\t\tcol_mode = STK1160_DECIMATE_MORE_THAN_HALF;\n\t\t\tf->fmt.pix.width = base_width / (col_n + 1);\n\t\t}\n\t}\n\n\tif (height < base_height && height > base_height / 2) {\n\t\trow_n = div_round_integer(height, base_height - height);\n\t\tif (row_n > 0 && row_n <= 255) {\n\t\t\trow_en = true;\n\t\t\trow_mode = STK1160_DECIMATE_LESS_THAN_HALF;\n\t\t\tf->fmt.pix.height = (base_height * row_n) / (row_n + 1);\n\t\t}\n\n\t} else if (height <= base_height / 2) {\n\t\trow_n = div_round_integer(base_height, height) - 1;\n\t\tif (row_n > 0 && row_n <= 255) {\n\t\t\trow_en = true;\n\t\t\trow_mode = STK1160_DECIMATE_MORE_THAN_HALF;\n\t\t\tf->fmt.pix.height = base_height / (row_n + 1);\n\t\t}\n\t}\n\n\tf->fmt.pix.pixelformat = dev->fmt->fourcc;\n\tf->fmt.pix.field = V4L2_FIELD_INTERLACED;\n\tf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\n\tf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\tif (ctrl) {\n\t\tctrl->col_en = col_en;\n\t\tctrl->col_n = col_n;\n\t\tctrl->col_mode = col_mode;\n\t\tctrl->row_en = row_en;\n\t\tctrl->row_n = row_n;\n\t\tctrl->row_mode = row_mode;\n\t}\n\n\tstk1160_dbg(\"width %d, height %d\\n\",\n\t\t    f->fmt.pix.width, f->fmt.pix.height);\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct stk1160 *dev = video_drvdata(file);\n\n\treturn stk1160_try_fmt(dev, f, NULL);\n}\n\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct stk1160 *dev = video_drvdata(file);\n\tstruct vb2_queue *q = &dev->vb_vidq;\n\tstruct stk1160_decimate_ctrl ctrl;\n\tint rc;\n\n\tif (vb2_is_busy(q))\n\t\treturn -EBUSY;\n\n\trc = stk1160_try_fmt(dev, f, &ctrl);\n\tif (rc < 0)\n\t\treturn rc;\n\tdev->width = f->fmt.pix.width;\n\tdev->height = f->fmt.pix.height;\n\tstk1160_set_fmt(dev, &ctrl);\n\n\treturn 0;\n}\n\nstatic int vidioc_querystd(struct file *file, void *priv, v4l2_std_id *norm)\n{\n\tstruct stk1160 *dev = video_drvdata(file);\n\tv4l2_device_call_all(&dev->v4l2_dev, 0, video, querystd, norm);\n\treturn 0;\n}\n\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *norm)\n{\n\tstruct stk1160 *dev = video_drvdata(file);\n\n\t*norm = dev->norm;\n\treturn 0;\n}\n\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id norm)\n{\n\tstruct stk1160 *dev = video_drvdata(file);\n\tstruct vb2_queue *q = &dev->vb_vidq;\n\n\tif (dev->norm == norm)\n\t\treturn 0;\n\n\tif (vb2_is_busy(q))\n\t\treturn -EBUSY;\n\n\t \n\tif (!dev->udev)\n\t\treturn -ENODEV;\n\n\t \n\tdev->width = 720;\n\tdev->height = (norm & V4L2_STD_525_60) ? 480 : 576;\n\tdev->norm = norm;\n\n\tstk1160_set_std(dev);\n\n\t \n\tstk1160_set_fmt(dev, NULL);\n\n\tv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_std,\n\t\t\tdev->norm);\n\n\treturn 0;\n}\n\n\nstatic int vidioc_enum_input(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_input *i)\n{\n\tstruct stk1160 *dev = video_drvdata(file);\n\n\tif (i->index > STK1160_MAX_INPUT)\n\t\treturn -EINVAL;\n\n\t \n\tif (i->index == STK1160_SVIDEO_INPUT)\n\t\tsprintf(i->name, \"S-Video\");\n\telse\n\t\tsprintf(i->name, \"Composite%d\", i->index);\n\n\ti->type = V4L2_INPUT_TYPE_CAMERA;\n\ti->std = dev->vdev.tvnorms;\n\treturn 0;\n}\n\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct stk1160 *dev = video_drvdata(file);\n\t*i = dev->ctl_input;\n\treturn 0;\n}\n\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tstruct stk1160 *dev = video_drvdata(file);\n\n\tif (i > STK1160_MAX_INPUT)\n\t\treturn -EINVAL;\n\n\tdev->ctl_input = i;\n\n\tstk1160_select_input(dev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int vidioc_g_register(struct file *file, void *priv,\n\t\t\t     struct v4l2_dbg_register *reg)\n{\n\tstruct stk1160 *dev = video_drvdata(file);\n\tint rc;\n\tu8 val;\n\n\t \n\trc = stk1160_read_reg(dev, reg->reg, &val);\n\treg->val = val;\n\treg->size = 1;\n\n\treturn rc;\n}\n\nstatic int vidioc_s_register(struct file *file, void *priv,\n\t\t\t     const struct v4l2_dbg_register *reg)\n{\n\tstruct stk1160 *dev = video_drvdata(file);\n\n\t \n\treturn stk1160_write_reg(dev, reg->reg, reg->val);\n}\n#endif\n\nstatic const struct v4l2_ioctl_ops stk1160_ioctl_ops = {\n\t.vidioc_querycap      = vidioc_querycap,\n\t.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,\n\t.vidioc_querystd      = vidioc_querystd,\n\t.vidioc_g_std         = vidioc_g_std,\n\t.vidioc_s_std         = vidioc_s_std,\n\t.vidioc_enum_input    = vidioc_enum_input,\n\t.vidioc_g_input       = vidioc_g_input,\n\t.vidioc_s_input       = vidioc_s_input,\n\n\t \n\t.vidioc_reqbufs       = vb2_ioctl_reqbufs,\n\t.vidioc_querybuf      = vb2_ioctl_querybuf,\n\t.vidioc_qbuf          = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf         = vb2_ioctl_dqbuf,\n\t.vidioc_streamon      = vb2_ioctl_streamon,\n\t.vidioc_streamoff     = vb2_ioctl_streamoff,\n\t.vidioc_expbuf        = vb2_ioctl_expbuf,\n\n\t.vidioc_log_status  = v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_register = vidioc_g_register,\n\t.vidioc_s_register = vidioc_s_register,\n#endif\n};\n\n \n\n \nstatic int queue_setup(struct vb2_queue *vq,\n\t\t\t\tunsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t\tunsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct stk1160 *dev = vb2_get_drv_priv(vq);\n\tunsigned long size;\n\n\tsize = dev->width * dev->height * 2;\n\n\t \n\t*nbuffers = clamp_t(unsigned int, *nbuffers,\n\t\t\tSTK1160_MIN_VIDEO_BUFFERS, STK1160_MAX_VIDEO_BUFFERS);\n\n\tif (*nplanes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t \n\t*nplanes = 1;\n\n\tsizes[0] = size;\n\n\tstk1160_dbg(\"%s: buffer count %d, each %ld bytes\\n\",\n\t\t    __func__, *nbuffers, size);\n\n\treturn 0;\n}\n\nstatic void buffer_queue(struct vb2_buffer *vb)\n{\n\tunsigned long flags;\n\tstruct stk1160 *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct stk1160_buffer *buf =\n\t\tcontainer_of(vbuf, struct stk1160_buffer, vb);\n\n\tspin_lock_irqsave(&dev->buf_lock, flags);\n\tif (!dev->udev) {\n\t\t \n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t} else {\n\n\t\tbuf->mem = vb2_plane_vaddr(vb, 0);\n\t\tbuf->length = vb2_plane_size(vb, 0);\n\t\tbuf->bytesused = 0;\n\t\tbuf->pos = 0;\n\n\t\t \n\t\tif (buf->length < dev->width * dev->height * 2)\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\telse\n\t\t\tlist_add_tail(&buf->list, &dev->avail_bufs);\n\n\t}\n\tspin_unlock_irqrestore(&dev->buf_lock, flags);\n}\n\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct stk1160 *dev = vb2_get_drv_priv(vq);\n\treturn stk1160_start_streaming(dev);\n}\n\n \nstatic void stop_streaming(struct vb2_queue *vq)\n{\n\tstruct stk1160 *dev = vb2_get_drv_priv(vq);\n\tstk1160_stop_streaming(dev);\n}\n\nstatic const struct vb2_ops stk1160_video_qops = {\n\t.queue_setup\t\t= queue_setup,\n\t.buf_queue\t\t= buffer_queue,\n\t.start_streaming\t= start_streaming,\n\t.stop_streaming\t\t= stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nstatic const struct video_device v4l_template = {\n\t.name = \"stk1160\",\n\t.tvnorms = V4L2_STD_525_60 | V4L2_STD_625_50,\n\t.fops = &stk1160_fops,\n\t.ioctl_ops = &stk1160_ioctl_ops,\n\t.release = video_device_release_empty,\n};\n\n \n\n \nvoid stk1160_clear_queue(struct stk1160 *dev, enum vb2_buffer_state vb2_state)\n{\n\tstruct stk1160_buffer *buf;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&dev->buf_lock, flags);\n\twhile (!list_empty(&dev->avail_bufs)) {\n\t\tbuf = list_first_entry(&dev->avail_bufs,\n\t\t\tstruct stk1160_buffer, list);\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, vb2_state);\n\t\tstk1160_dbg(\"buffer [%p/%d] aborted\\n\",\n\t\t\t    buf, buf->vb.vb2_buf.index);\n\t}\n\n\t \n\tif (dev->isoc_ctl.buf) {\n\t\tbuf = dev->isoc_ctl.buf;\n\t\tdev->isoc_ctl.buf = NULL;\n\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, vb2_state);\n\t\tstk1160_dbg(\"buffer [%p/%d] aborted\\n\",\n\t\t\t    buf, buf->vb.vb2_buf.index);\n\t}\n\tspin_unlock_irqrestore(&dev->buf_lock, flags);\n}\n\nint stk1160_vb2_setup(struct stk1160 *dev)\n{\n\tint rc;\n\tstruct vb2_queue *q;\n\n\tq = &dev->vb_vidq;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_READ | VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tq->drv_priv = dev;\n\tq->buf_struct_size = sizeof(struct stk1160_buffer);\n\tq->ops = &stk1160_video_qops;\n\tq->mem_ops = &vb2_vmalloc_memops;\n\tq->lock = &dev->vb_queue_lock;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\n\trc = vb2_queue_init(q);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tINIT_LIST_HEAD(&dev->avail_bufs);\n\n\treturn 0;\n}\n\nint stk1160_video_register(struct stk1160 *dev)\n{\n\tint rc;\n\n\t \n\tdev->vdev = v4l_template;\n\tdev->vdev.queue = &dev->vb_vidq;\n\n\t \n\tdev->vdev.lock = &dev->v4l_lock;\n\n\t \n\tdev->vdev.v4l2_dev = &dev->v4l2_dev;\n\tdev->vdev.device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |\n\t\t\t\tV4L2_CAP_READWRITE;\n\n\t \n\tdev->norm = V4L2_STD_NTSC_M;\n\tdev->width = 720;\n\tdev->height = 480;\n\n\t \n\tdev->fmt = &format[0];\n\tstk1160_set_std(dev);\n\n\tv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_std,\n\t\t\tdev->norm);\n\n\tvideo_set_drvdata(&dev->vdev, dev);\n\trc = video_register_device(&dev->vdev, VFL_TYPE_VIDEO, -1);\n\tif (rc < 0) {\n\t\tstk1160_err(\"video_register_device failed (%d)\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tv4l2_info(&dev->v4l2_dev, \"V4L2 device registered as %s\\n\",\n\t\t  video_device_node_name(&dev->vdev));\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}