{
  "module_name": "pwc-dec23.c",
  "hash_id": "70cb11aeeb74179b1aee7d8114d13ec9200f58cbc71f124e4761c8d10b54a1e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/pwc/pwc-dec23.c",
  "human_readable_source": "\n \n\n#include \"pwc-timon.h\"\n#include \"pwc-kiara.h\"\n#include \"pwc-dec23.h\"\n\n#include <linux/string.h>\n#include <linux/slab.h>\n\n \n#define USE_LOOKUP_TABLE_TO_CLAMP\t1\n \n#define UNROLL_LOOP_FOR_COPY\t\t1\n#if UNROLL_LOOP_FOR_COPY\n# undef USE_LOOKUP_TABLE_TO_CLAMP\n# define USE_LOOKUP_TABLE_TO_CLAMP 1\n#endif\n\nstatic void build_subblock_pattern(struct pwc_dec23_private *pdec)\n{\n\tstatic const unsigned int initial_values[12] = {\n\t\t-0x526500, -0x221200, 0x221200, 0x526500,\n\t\t\t   -0x3de200, 0x3de200,\n\t\t-0x6db480, -0x2d5d00, 0x2d5d00, 0x6db480,\n\t\t\t   -0x12c200, 0x12c200\n\n\t};\n\tstatic const unsigned int values_derivated[12] = {\n\t\t0xa4ca, 0x4424, -0x4424, -0xa4ca,\n\t\t\t0x7bc4, -0x7bc4,\n\t\t0xdb69, 0x5aba, -0x5aba, -0xdb69,\n\t\t\t0x2584, -0x2584\n\t};\n\tunsigned int temp_values[12];\n\tint i, j;\n\n\tmemcpy(temp_values, initial_values, sizeof(initial_values));\n\tfor (i = 0; i < 256; i++) {\n\t\tfor (j = 0; j < 12; j++) {\n\t\t\tpdec->table_subblock[i][j] = temp_values[j];\n\t\t\ttemp_values[j] += values_derivated[j];\n\t\t}\n\t}\n}\n\nstatic void build_bit_powermask_table(struct pwc_dec23_private *pdec)\n{\n\tunsigned char *p;\n\tunsigned int bit, byte, mask, val;\n\tunsigned int bitpower = 1;\n\n\tfor (bit = 0; bit < 8; bit++) {\n\t\tmask = bitpower - 1;\n\t\tp = pdec->table_bitpowermask[bit];\n\t\tfor (byte = 0; byte < 256; byte++) {\n\t\t\tval = (byte & mask);\n\t\t\tif (byte & bitpower)\n\t\t\t\tval = -val;\n\t\t\t*p++ = val;\n\t\t}\n\t\tbitpower<<=1;\n\t}\n}\n\n\nstatic void build_table_color(const unsigned int romtable[16][8],\n\t\t\t      unsigned char p0004[16][1024],\n\t\t\t      unsigned char p8004[16][256])\n{\n\tint compression_mode, j, k, bit, pw;\n\tunsigned char *p0, *p8;\n\tconst unsigned int *r;\n\n\t \n\tfor (compression_mode = 0; compression_mode < 16; compression_mode++) {\n\t\tp0 = p0004[compression_mode];\n\t\tp8 = p8004[compression_mode];\n\t\tr  = romtable[compression_mode];\n\n\t\tfor (j = 0; j < 8; j++, r++, p0 += 128) {\n\n\t\t\tfor (k = 0; k < 16; k++) {\n\t\t\t\tif (k == 0)\n\t\t\t\t\tbit = 1;\n\t\t\t\telse if (k >= 1 && k < 3)\n\t\t\t\t\tbit = (r[0] >> 15) & 7;\n\t\t\t\telse if (k >= 3 && k < 6)\n\t\t\t\t\tbit = (r[0] >> 12) & 7;\n\t\t\t\telse if (k >= 6 && k < 10)\n\t\t\t\t\tbit = (r[0] >> 9) & 7;\n\t\t\t\telse if (k >= 10 && k < 13)\n\t\t\t\t\tbit = (r[0] >> 6) & 7;\n\t\t\t\telse if (k >= 13 && k < 15)\n\t\t\t\t\tbit = (r[0] >> 3) & 7;\n\t\t\t\telse\n\t\t\t\t\tbit = (r[0]) & 7;\n\t\t\t\tif (k == 0)\n\t\t\t\t\t*p8++ = 8;\n\t\t\t\telse\n\t\t\t\t\t*p8++ = j - bit;\n\t\t\t\t*p8++ = bit;\n\n\t\t\t\tpw = 1 << bit;\n\t\t\t\tp0[k + 0x00] = (1 * pw) + 0x80;\n\t\t\t\tp0[k + 0x10] = (2 * pw) + 0x80;\n\t\t\t\tp0[k + 0x20] = (3 * pw) + 0x80;\n\t\t\t\tp0[k + 0x30] = (4 * pw) + 0x80;\n\t\t\t\tp0[k + 0x40] = (-1 * pw) + 0x80;\n\t\t\t\tp0[k + 0x50] = (-2 * pw) + 0x80;\n\t\t\t\tp0[k + 0x60] = (-3 * pw) + 0x80;\n\t\t\t\tp0[k + 0x70] = (-4 * pw) + 0x80;\n\t\t\t}\t \n\t\t}\t \n\t}  \n}\n\n \nstatic void fill_table_dc00_d800(struct pwc_dec23_private *pdec)\n{\n#define SCALEBITS 15\n#define ONE_HALF  (1UL << (SCALEBITS - 1))\n\tint i;\n\tunsigned int offset1 = ONE_HALF;\n\tunsigned int offset2 = 0x0000;\n\n\tfor (i=0; i<256; i++) {\n\t\tpdec->table_dc00[i] = offset1 & ~(ONE_HALF);\n\t\tpdec->table_d800[i] = offset2;\n\n\t\toffset1 += 0x7bc4;\n\t\toffset2 += 0x7bc4;\n\t}\n}\n\n \nstatic const unsigned char hash_table_ops[64*4] = {\n\t0x02, 0x00, 0x00, 0x00,\n\t0x00, 0x03, 0x01, 0x00,\n\t0x00, 0x04, 0x01, 0x10,\n\t0x00, 0x06, 0x01, 0x30,\n\t0x02, 0x00, 0x00, 0x00,\n\t0x00, 0x03, 0x01, 0x40,\n\t0x00, 0x05, 0x01, 0x20,\n\t0x01, 0x00, 0x00, 0x00,\n\t0x02, 0x00, 0x00, 0x00,\n\t0x00, 0x03, 0x01, 0x00,\n\t0x00, 0x04, 0x01, 0x50,\n\t0x00, 0x05, 0x02, 0x00,\n\t0x02, 0x00, 0x00, 0x00,\n\t0x00, 0x03, 0x01, 0x40,\n\t0x00, 0x05, 0x03, 0x00,\n\t0x01, 0x00, 0x00, 0x00,\n\t0x02, 0x00, 0x00, 0x00,\n\t0x00, 0x03, 0x01, 0x00,\n\t0x00, 0x04, 0x01, 0x10,\n\t0x00, 0x06, 0x02, 0x10,\n\t0x02, 0x00, 0x00, 0x00,\n\t0x00, 0x03, 0x01, 0x40,\n\t0x00, 0x05, 0x01, 0x60,\n\t0x01, 0x00, 0x00, 0x00,\n\t0x02, 0x00, 0x00, 0x00,\n\t0x00, 0x03, 0x01, 0x00,\n\t0x00, 0x04, 0x01, 0x50,\n\t0x00, 0x05, 0x02, 0x40,\n\t0x02, 0x00, 0x00, 0x00,\n\t0x00, 0x03, 0x01, 0x40,\n\t0x00, 0x05, 0x03, 0x40,\n\t0x01, 0x00, 0x00, 0x00,\n\t0x02, 0x00, 0x00, 0x00,\n\t0x00, 0x03, 0x01, 0x00,\n\t0x00, 0x04, 0x01, 0x10,\n\t0x00, 0x06, 0x01, 0x70,\n\t0x02, 0x00, 0x00, 0x00,\n\t0x00, 0x03, 0x01, 0x40,\n\t0x00, 0x05, 0x01, 0x20,\n\t0x01, 0x00, 0x00, 0x00,\n\t0x02, 0x00, 0x00, 0x00,\n\t0x00, 0x03, 0x01, 0x00,\n\t0x00, 0x04, 0x01, 0x50,\n\t0x00, 0x05, 0x02, 0x00,\n\t0x02, 0x00, 0x00, 0x00,\n\t0x00, 0x03, 0x01, 0x40,\n\t0x00, 0x05, 0x03, 0x00,\n\t0x01, 0x00, 0x00, 0x00,\n\t0x02, 0x00, 0x00, 0x00,\n\t0x00, 0x03, 0x01, 0x00,\n\t0x00, 0x04, 0x01, 0x10,\n\t0x00, 0x06, 0x02, 0x50,\n\t0x02, 0x00, 0x00, 0x00,\n\t0x00, 0x03, 0x01, 0x40,\n\t0x00, 0x05, 0x01, 0x60,\n\t0x01, 0x00, 0x00, 0x00,\n\t0x02, 0x00, 0x00, 0x00,\n\t0x00, 0x03, 0x01, 0x00,\n\t0x00, 0x04, 0x01, 0x50,\n\t0x00, 0x05, 0x02, 0x40,\n\t0x02, 0x00, 0x00, 0x00,\n\t0x00, 0x03, 0x01, 0x40,\n\t0x00, 0x05, 0x03, 0x40,\n\t0x01, 0x00, 0x00, 0x00\n};\n\n \nstatic const unsigned int MulIdx[16][16] = {\n\t{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},\n\t{0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3,},\n\t{0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3,},\n\t{4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4,},\n\t{6, 7, 8, 9, 7, 10, 11, 8, 8, 11, 10, 7, 9, 8, 7, 6,},\n\t{4, 5, 5, 4, 4, 5, 5, 4, 4, 5, 5, 4, 4, 5, 5, 4,},\n\t{1, 3, 0, 2, 1, 3, 0, 2, 1, 3, 0, 2, 1, 3, 0, 2,},\n\t{0, 3, 3, 0, 1, 2, 2, 1, 2, 1, 1, 2, 3, 0, 0, 3,},\n\t{0, 1, 2, 3, 3, 2, 1, 0, 3, 2, 1, 0, 0, 1, 2, 3,},\n\t{1, 1, 1, 1, 3, 3, 3, 3, 0, 0, 0, 0, 2, 2, 2, 2,},\n\t{7, 10, 11, 8, 9, 8, 7, 6, 6, 7, 8, 9, 8, 11, 10, 7,},\n\t{4, 5, 5, 4, 5, 4, 4, 5, 5, 4, 4, 5, 4, 5, 5, 4,},\n\t{7, 9, 6, 8, 10, 8, 7, 11, 11, 7, 8, 10, 8, 6, 9, 7,},\n\t{1, 3, 0, 2, 2, 0, 3, 1, 2, 0, 3, 1, 1, 3, 0, 2,},\n\t{1, 2, 2, 1, 3, 0, 0, 3, 0, 3, 3, 0, 2, 1, 1, 2,},\n\t{10, 8, 7, 11, 8, 6, 9, 7, 7, 9, 6, 8, 11, 7, 8, 10}\n};\n\n#if USE_LOOKUP_TABLE_TO_CLAMP\n#define MAX_OUTER_CROP_VALUE\t(512)\nstatic unsigned char pwc_crop_table[256 + 2*MAX_OUTER_CROP_VALUE];\n#define CLAMP(x) (pwc_crop_table[MAX_OUTER_CROP_VALUE+(x)])\n#else\n#define CLAMP(x) ((x)>255?255:((x)<0?0:x))\n#endif\n\n\n \nvoid pwc_dec23_init(struct pwc_device *pdev, const unsigned char *cmd)\n{\n\tint flags, version, shift, i;\n\tstruct pwc_dec23_private *pdec = &pdev->dec23;\n\n\tmutex_init(&pdec->lock);\n\n\tif (pdec->last_cmd_valid && pdec->last_cmd == cmd[2])\n\t\treturn;\n\n\tif (DEVICE_USE_CODEC3(pdev->type)) {\n\t\tflags = cmd[2] & 0x18;\n\t\tif (flags == 8)\n\t\t\tpdec->nbits = 7;\t \n\t\telse if (flags == 0x10)\n\t\t\tpdec->nbits = 8;\n\t\telse\n\t\t\tpdec->nbits = 6;\n\n\t\tversion = cmd[2] >> 5;\n\t\tbuild_table_color(KiaraRomTable[version][0], pdec->table_0004_pass1, pdec->table_8004_pass1);\n\t\tbuild_table_color(KiaraRomTable[version][1], pdec->table_0004_pass2, pdec->table_8004_pass2);\n\n\t} else {\n\n\t\tflags = cmd[2] & 6;\n\t\tif (flags == 2)\n\t\t\tpdec->nbits = 7;\n\t\telse if (flags == 4)\n\t\t\tpdec->nbits = 8;\n\t\telse\n\t\t\tpdec->nbits = 6;\n\n\t\tversion = cmd[2] >> 3;\n\t\tbuild_table_color(TimonRomTable[version][0], pdec->table_0004_pass1, pdec->table_8004_pass1);\n\t\tbuild_table_color(TimonRomTable[version][1], pdec->table_0004_pass2, pdec->table_8004_pass2);\n\t}\n\n\t \n\tshift = 8 - pdec->nbits;\n\tpdec->scalebits = SCALEBITS - shift;\n\tpdec->nbitsmask = 0xFF >> shift;\n\n\tfill_table_dc00_d800(pdec);\n\tbuild_subblock_pattern(pdec);\n\tbuild_bit_powermask_table(pdec);\n\n#if USE_LOOKUP_TABLE_TO_CLAMP\n\t \n\tfor (i=0;i<MAX_OUTER_CROP_VALUE;i++)\n\t\tpwc_crop_table[i] = 0;\n\tfor (i=0; i<256; i++)\n\t\tpwc_crop_table[MAX_OUTER_CROP_VALUE+i] = i;\n\tfor (i=0; i<MAX_OUTER_CROP_VALUE; i++)\n\t\tpwc_crop_table[MAX_OUTER_CROP_VALUE+256+i] = 255;\n#endif\n\n\tpdec->last_cmd = cmd[2];\n\tpdec->last_cmd_valid = 1;\n}\n\n \nstatic void copy_image_block_Y(const int *src, unsigned char *dst, unsigned int bytes_per_line, unsigned int scalebits)\n{\n#if UNROLL_LOOP_FOR_COPY\n\tconst unsigned char *cm = pwc_crop_table+MAX_OUTER_CROP_VALUE;\n\tconst int *c = src;\n\tunsigned char *d = dst;\n\n\t*d++ = cm[c[0] >> scalebits];\n\t*d++ = cm[c[1] >> scalebits];\n\t*d++ = cm[c[2] >> scalebits];\n\t*d++ = cm[c[3] >> scalebits];\n\n\td = dst + bytes_per_line;\n\t*d++ = cm[c[4] >> scalebits];\n\t*d++ = cm[c[5] >> scalebits];\n\t*d++ = cm[c[6] >> scalebits];\n\t*d++ = cm[c[7] >> scalebits];\n\n\td = dst + bytes_per_line*2;\n\t*d++ = cm[c[8] >> scalebits];\n\t*d++ = cm[c[9] >> scalebits];\n\t*d++ = cm[c[10] >> scalebits];\n\t*d++ = cm[c[11] >> scalebits];\n\n\td = dst + bytes_per_line*3;\n\t*d++ = cm[c[12] >> scalebits];\n\t*d++ = cm[c[13] >> scalebits];\n\t*d++ = cm[c[14] >> scalebits];\n\t*d++ = cm[c[15] >> scalebits];\n#else\n\tint i;\n\tconst int *c = src;\n\tunsigned char *d = dst;\n\tfor (i = 0; i < 4; i++, c++)\n\t\t*d++ = CLAMP((*c) >> scalebits);\n\n\td = dst + bytes_per_line;\n\tfor (i = 0; i < 4; i++, c++)\n\t\t*d++ = CLAMP((*c) >> scalebits);\n\n\td = dst + bytes_per_line*2;\n\tfor (i = 0; i < 4; i++, c++)\n\t\t*d++ = CLAMP((*c) >> scalebits);\n\n\td = dst + bytes_per_line*3;\n\tfor (i = 0; i < 4; i++, c++)\n\t\t*d++ = CLAMP((*c) >> scalebits);\n#endif\n}\n\n \nstatic void copy_image_block_CrCb(const int *src, unsigned char *dst, unsigned int bytes_per_line, unsigned int scalebits)\n{\n#if UNROLL_LOOP_FOR_COPY\n\t \n\tconst unsigned char *cm = pwc_crop_table+MAX_OUTER_CROP_VALUE;\n\tconst int *c = src;\n\tunsigned char *d = dst;\n\n\t*d++ = cm[c[0] >> scalebits];\n\t*d++ = cm[c[4] >> scalebits];\n\t*d++ = cm[c[1] >> scalebits];\n\t*d++ = cm[c[5] >> scalebits];\n\t*d++ = cm[c[2] >> scalebits];\n\t*d++ = cm[c[6] >> scalebits];\n\t*d++ = cm[c[3] >> scalebits];\n\t*d++ = cm[c[7] >> scalebits];\n\n\td = dst + bytes_per_line;\n\t*d++ = cm[c[12] >> scalebits];\n\t*d++ = cm[c[8] >> scalebits];\n\t*d++ = cm[c[13] >> scalebits];\n\t*d++ = cm[c[9] >> scalebits];\n\t*d++ = cm[c[14] >> scalebits];\n\t*d++ = cm[c[10] >> scalebits];\n\t*d++ = cm[c[15] >> scalebits];\n\t*d++ = cm[c[11] >> scalebits];\n#else\n\tint i;\n\tconst int *c1 = src;\n\tconst int *c2 = src + 4;\n\tunsigned char *d = dst;\n\n\tfor (i = 0; i < 4; i++, c1++, c2++) {\n\t\t*d++ = CLAMP((*c1) >> scalebits);\n\t\t*d++ = CLAMP((*c2) >> scalebits);\n\t}\n\tc1 = src + 12;\n\td = dst + bytes_per_line;\n\tfor (i = 0; i < 4; i++, c1++, c2++) {\n\t\t*d++ = CLAMP((*c1) >> scalebits);\n\t\t*d++ = CLAMP((*c2) >> scalebits);\n\t}\n#endif\n}\n\n \n#define fill_nbits(pdec, nbits_wanted) do { \\\n   while (pdec->nbits_in_reservoir<(nbits_wanted)) \\\n    { \\\n      pdec->reservoir |= (*(pdec->stream)++) << (pdec->nbits_in_reservoir); \\\n      pdec->nbits_in_reservoir += 8; \\\n    } \\\n}  while(0);\n\n#define skip_nbits(pdec, nbits_to_skip) do { \\\n   pdec->reservoir >>= (nbits_to_skip); \\\n   pdec->nbits_in_reservoir -= (nbits_to_skip); \\\n}  while(0);\n\n#define get_nbits(pdec, nbits_wanted, result) do { \\\n   fill_nbits(pdec, nbits_wanted); \\\n   result = (pdec->reservoir) & ((1U<<(nbits_wanted))-1); \\\n   skip_nbits(pdec, nbits_wanted); \\\n}  while(0);\n\n#define __get_nbits(pdec, nbits_wanted, result) do { \\\n   result = (pdec->reservoir) & ((1U<<(nbits_wanted))-1); \\\n   skip_nbits(pdec, nbits_wanted); \\\n}  while(0);\n\n#define look_nbits(pdec, nbits_wanted) \\\n   ((pdec->reservoir) & ((1U<<(nbits_wanted))-1))\n\n \nstatic void decode_block(struct pwc_dec23_private *pdec,\n\t\t\t const unsigned char *ptable0004,\n\t\t\t const unsigned char *ptable8004)\n{\n\tunsigned int primary_color;\n\tunsigned int channel_v, offset1, op;\n\tint i;\n\n\tfill_nbits(pdec, 16);\n\t__get_nbits(pdec, pdec->nbits, primary_color);\n\n\tif (look_nbits(pdec,2) == 0) {\n\t\tskip_nbits(pdec, 2);\n\t\t \n\t\tfor (i = 0; i < 16; i++)\n\t\t\tpdec->temp_colors[i] = pdec->table_dc00[primary_color];\n\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < 16; i++)\n\t\tpdec->temp_colors[i] = pdec->table_d800[primary_color];\n\n\t__get_nbits(pdec, 3, channel_v);\n\tchannel_v = ((channel_v & 1) << 2) | (channel_v & 2) | ((channel_v & 4) >> 2);\n\n\tptable0004 += (channel_v * 128);\n\tptable8004 += (channel_v * 32);\n\n\toffset1 = 0;\n\tdo\n\t{\n\t\tunsigned int htable_idx, rows = 0;\n\t\tconst unsigned int *block;\n\n\t\t \n\t\tfill_nbits(pdec, 16);\n\t\thtable_idx = look_nbits(pdec, 6);\n\t\top = hash_table_ops[htable_idx * 4];\n\n\t\tif (op == 2) {\n\t\t\tskip_nbits(pdec, 2);\n\n\t\t} else if (op == 1) {\n\t\t\t \n\t\t\tunsigned int mask, shift;\n\t\t\tunsigned int nbits, col1;\n\t\t\tunsigned int yyyy;\n\n\t\t\tskip_nbits(pdec, 3);\n\t\t\t \n\t\t\t__get_nbits(pdec, 4, yyyy);\n\t\t\toffset1 += 1 + yyyy;\n\t\t\toffset1 &= 0x0F;\n\t\t\tnbits = ptable8004[offset1 * 2];\n\n\t\t\t \n\t\t\t__get_nbits(pdec, nbits+1, col1);\n\n\t\t\t \n\t\t\tmask = pdec->table_bitpowermask[nbits][col1];\n\t\t\tshift = ptable8004[offset1 * 2 + 1];\n\t\t\trows = ((mask << shift) + 0x80) & 0xFF;\n\n\t\t\tblock = pdec->table_subblock[rows];\n\t\t\tfor (i = 0; i < 16; i++)\n\t\t\t\tpdec->temp_colors[i] += block[MulIdx[offset1][i]];\n\n\t\t} else {\n\t\t\t \n\t\t\tunsigned int shift;\n\n\t\t\toffset1 += hash_table_ops [htable_idx * 4 + 2];\n\t\t\toffset1 &= 0x0F;\n\n\t\t\trows = ptable0004[offset1 + hash_table_ops [htable_idx * 4 + 3]];\n\t\t\tblock = pdec->table_subblock[rows];\n\t\t\tfor (i = 0; i < 16; i++)\n\t\t\t\tpdec->temp_colors[i] += block[MulIdx[offset1][i]];\n\n\t\t\tshift = hash_table_ops[htable_idx * 4 + 1];\n\t\t\tskip_nbits(pdec, shift);\n\t\t}\n\n\t} while (op != 2);\n\n}\n\nstatic void DecompressBand23(struct pwc_dec23_private *pdec,\n\t\t\t     const unsigned char *rawyuv,\n\t\t\t     unsigned char *planar_y,\n\t\t\t     unsigned char *planar_u,\n\t\t\t     unsigned char *planar_v,\n\t\t\t     unsigned int   compressed_image_width,\n\t\t\t     unsigned int   real_image_width)\n{\n\tint compression_index, nblocks;\n\tconst unsigned char *ptable0004;\n\tconst unsigned char *ptable8004;\n\n\tpdec->reservoir = 0;\n\tpdec->nbits_in_reservoir = 0;\n\tpdec->stream = rawyuv + 1;\t \n\n\tget_nbits(pdec, 4, compression_index);\n\n\t \n\tnblocks = compressed_image_width / 4;\n\n\tptable0004 = pdec->table_0004_pass1[compression_index];\n\tptable8004 = pdec->table_8004_pass1[compression_index];\n\n\t \n\twhile (nblocks) {\n\t\tdecode_block(pdec, ptable0004, ptable8004);\n\t\tcopy_image_block_Y(pdec->temp_colors, planar_y, real_image_width, pdec->scalebits);\n\t\tplanar_y += 4;\n\t\tnblocks--;\n\t}\n\n\t \n\tnblocks = compressed_image_width / 8;\n\n\tptable0004 = pdec->table_0004_pass2[compression_index];\n\tptable8004 = pdec->table_8004_pass2[compression_index];\n\n\t \n\twhile (nblocks) {\n\t\tdecode_block(pdec, ptable0004, ptable8004);\n\t\tcopy_image_block_CrCb(pdec->temp_colors, planar_u, real_image_width/2, pdec->scalebits);\n\n\t\tdecode_block(pdec, ptable0004, ptable8004);\n\t\tcopy_image_block_CrCb(pdec->temp_colors, planar_v, real_image_width/2, pdec->scalebits);\n\n\t\tplanar_v += 8;\n\t\tplanar_u += 8;\n\t\tnblocks -= 2;\n\t}\n\n}\n\n \nvoid pwc_dec23_decompress(struct pwc_device *pdev,\n\t\t\t  const void *src,\n\t\t\t  void *dst)\n{\n\tint bandlines_left, bytes_per_block;\n\tstruct pwc_dec23_private *pdec = &pdev->dec23;\n\n\t \n\tunsigned char *pout_planar_y;\n\tunsigned char *pout_planar_u;\n\tunsigned char *pout_planar_v;\n\tunsigned int   plane_size;\n\n\tmutex_lock(&pdec->lock);\n\n\tbandlines_left = pdev->height / 4;\n\tbytes_per_block = pdev->width * 4;\n\tplane_size = pdev->height * pdev->width;\n\n\tpout_planar_y = dst;\n\tpout_planar_u = dst + plane_size;\n\tpout_planar_v = dst + plane_size + plane_size / 4;\n\n\twhile (bandlines_left--) {\n\t\tDecompressBand23(pdec, src,\n\t\t\t\t pout_planar_y, pout_planar_u, pout_planar_v,\n\t\t\t\t pdev->width, pdev->width);\n\t\tsrc += pdev->vbandlength;\n\t\tpout_planar_y += bytes_per_block;\n\t\tpout_planar_u += pdev->width;\n\t\tpout_planar_v += pdev->width;\n\t}\n\tmutex_unlock(&pdec->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}