{
  "module_name": "pwc-ctrl.c",
  "hash_id": "e7ede71d0d88a51131bf0e941d8d8373fa7378e12bbf83fff54664a001c6b6b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/pwc/pwc-ctrl.c",
  "human_readable_source": "\n \n\n \n\n \n\n#ifdef __KERNEL__\n#include <linux/uaccess.h>\n#endif\n#include <asm/errno.h>\n\n#include \"pwc.h\"\n#include \"pwc-kiara.h\"\n#include \"pwc-timon.h\"\n#include \"pwc-dec1.h\"\n#include \"pwc-dec23.h\"\n\n \n#define GET_STATUS_B00\t\t\t\t0x0B00\n#define SENSOR_TYPE_FORMATTER1\t\t\t0x0C00\n#define GET_STATUS_3000\t\t\t\t0x3000\n#define READ_RAW_Y_MEAN_FORMATTER\t\t0x3100\n#define SET_POWER_SAVE_MODE_FORMATTER\t\t0x3200\n#define MIRROR_IMAGE_FORMATTER\t\t\t0x3300\n#define LED_FORMATTER\t\t\t\t0x3400\n#define LOWLIGHT\t\t\t\t0x3500\n#define GET_STATUS_3600\t\t\t\t0x3600\n#define SENSOR_TYPE_FORMATTER2\t\t\t0x3700\n#define GET_STATUS_3800\t\t\t\t0x3800\n#define GET_STATUS_4000\t\t\t\t0x4000\n#define GET_STATUS_4100\t\t\t\t0x4100\t \n#define CTL_STATUS_4200\t\t\t\t0x4200\t \n\n \n#define VIDEO_OUTPUT_CONTROL_FORMATTER\t\t0x0100\n\nstatic const char *size2name[PSZ_MAX] =\n{\n\t\"subQCIF\",\n\t\"QSIF\",\n\t\"QCIF\",\n\t\"SIF\",\n\t\"CIF\",\n\t\"VGA\",\n};\n\n \n\n \n\n#define PWC_FPS_MAX_NALA 8\n\nstruct Nala_table_entry {\n\tchar alternate;\t\t\t \n\tint compressed;\t\t\t \n\n\tunsigned char mode[3];\t\t \n};\n\nstatic unsigned int Nala_fps_vector[PWC_FPS_MAX_NALA] = { 4, 5, 7, 10, 12, 15, 20, 24 };\n\nstatic struct Nala_table_entry Nala_table[PSZ_MAX][PWC_FPS_MAX_NALA] =\n{\n#include \"pwc-nala.h\"\n};\n\n \n\nstatic int recv_control_msg(struct pwc_device *pdev,\n\tu8 request, u16 value, int recv_count)\n{\n\tint rc;\n\n\trc = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),\n\t\trequest,\n\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\tvalue, pdev->vcinterface,\n\t\tpdev->ctrl_buf, recv_count, USB_CTRL_GET_TIMEOUT);\n\tif (rc < 0)\n\t\tPWC_ERROR(\"recv_control_msg error %d req %02x val %04x\\n\",\n\t\t\t  rc, request, value);\n\treturn rc;\n}\n\nstatic inline int send_video_command(struct pwc_device *pdev,\n\tint index, const unsigned char *buf, int buflen)\n{\n\tint rc;\n\n\tmemcpy(pdev->ctrl_buf, buf, buflen);\n\n\trc = usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),\n\t\t\tSET_EP_STREAM_CTL,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tVIDEO_OUTPUT_CONTROL_FORMATTER, index,\n\t\t\tpdev->ctrl_buf, buflen, USB_CTRL_SET_TIMEOUT);\n\tif (rc >= 0)\n\t\tmemcpy(pdev->cmd_buf, buf, buflen);\n\telse\n\t\tPWC_ERROR(\"send_video_command error %d\\n\", rc);\n\n\treturn rc;\n}\n\nint send_control_msg(struct pwc_device *pdev,\n\tu8 request, u16 value, void *buf, int buflen)\n{\n\treturn usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),\n\t\t\trequest,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tvalue, pdev->vcinterface,\n\t\t\tbuf, buflen, USB_CTRL_SET_TIMEOUT);\n}\n\nstatic int set_video_mode_Nala(struct pwc_device *pdev, int size, int pixfmt,\n\t\t\t       int frames, int *compression, int send_to_cam)\n{\n\tint fps, ret = 0;\n\tstruct Nala_table_entry *pEntry;\n\tint frames2frames[31] =\n\t{  \n\t   0,  0,  0,  0,  4,   \n\t   5,  5,  7,  7, 10,   \n\t  10, 10, 12, 12, 15,   \n\t  15, 15, 15, 20, 20,   \n\t  20, 20, 20, 24, 24,   \n\t  24, 24, 24, 24, 24,   \n\t  24                    \n\t};\n\tint frames2table[31] =\n\t{ 0, 0, 0, 0, 0,  \n\t  1, 1, 1, 2, 2,  \n\t  3, 3, 4, 4, 4,  \n\t  5, 5, 5, 5, 5,  \n\t  6, 6, 6, 6, 7,  \n\t  7, 7, 7, 7, 7,  \n\t  7               \n\t};\n\n\tif (size < 0 || size > PSZ_CIF)\n\t\treturn -EINVAL;\n\tif (frames < 4)\n\t\tframes = 4;\n\telse if (size > PSZ_QCIF && frames > 15)\n\t\tframes = 15;\n\telse if (frames > 25)\n\t\tframes = 25;\n\tframes = frames2frames[frames];\n\tfps = frames2table[frames];\n\tpEntry = &Nala_table[size][fps];\n\tif (pEntry->alternate == 0)\n\t\treturn -EINVAL;\n\n\tif (send_to_cam)\n\t\tret = send_video_command(pdev, pdev->vendpoint,\n\t\t\t\t\t pEntry->mode, 3);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (pEntry->compressed && pixfmt == V4L2_PIX_FMT_YUV420)\n\t\tpwc_dec1_init(pdev, pEntry->mode);\n\n\t \n\tpdev->pixfmt = pixfmt;\n\tpdev->vframes = frames;\n\tpdev->valternate = pEntry->alternate;\n\tpdev->width  = pwc_image_sizes[size][0];\n\tpdev->height = pwc_image_sizes[size][1];\n\tpdev->frame_size = (pdev->width * pdev->height * 3) / 2;\n\tif (pEntry->compressed) {\n\t\tif (pdev->release < 5) {  \n\t\t\tpdev->vbandlength = 528;\n\t\t\tpdev->frame_size /= 4;\n\t\t}\n\t\telse {\n\t\t\tpdev->vbandlength = 704;\n\t\t\tpdev->frame_size /= 3;\n\t\t}\n\t}\n\telse\n\t\tpdev->vbandlength = 0;\n\n\t \n\t*compression = 3;\n\n\treturn 0;\n}\n\n\nstatic int set_video_mode_Timon(struct pwc_device *pdev, int size, int pixfmt,\n\t\t\t\tint frames, int *compression, int send_to_cam)\n{\n\tconst struct Timon_table_entry *pChoose;\n\tint fps, ret = 0;\n\n\tif (size >= PSZ_MAX || *compression < 0 || *compression > 3)\n\t\treturn -EINVAL;\n\tif (frames < 5)\n\t\tframes = 5;\n\telse if (size == PSZ_VGA && frames > 15)\n\t\tframes = 15;\n\telse if (frames > 30)\n\t\tframes = 30;\n\tfps = (frames / 5) - 1;\n\n\t \n\tdo {\n\t\tpChoose = &Timon_table[size][fps][*compression];\n\t\tif (pChoose->alternate != 0)\n\t\t\tbreak;\n\t\t(*compression)++;\n\t} while (*compression <= 3);\n\n\tif (pChoose->alternate == 0)\n\t\treturn -ENOENT;  \n\n\tif (send_to_cam)\n\t\tret = send_video_command(pdev, pdev->vendpoint,\n\t\t\t\t\t pChoose->mode, 13);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (pChoose->bandlength > 0 && pixfmt == V4L2_PIX_FMT_YUV420)\n\t\tpwc_dec23_init(pdev, pChoose->mode);\n\n\t \n\tpdev->pixfmt = pixfmt;\n\tpdev->vframes = (fps + 1) * 5;\n\tpdev->valternate = pChoose->alternate;\n\tpdev->width  = pwc_image_sizes[size][0];\n\tpdev->height = pwc_image_sizes[size][1];\n\tpdev->vbandlength = pChoose->bandlength;\n\tif (pChoose->bandlength > 0)\n\t\tpdev->frame_size = (pChoose->bandlength * pdev->height) / 4;\n\telse\n\t\tpdev->frame_size = (pdev->width * pdev->height * 12) / 8;\n\treturn 0;\n}\n\n\nstatic int set_video_mode_Kiara(struct pwc_device *pdev, int size, int pixfmt,\n\t\t\t\tint frames, int *compression, int send_to_cam)\n{\n\tconst struct Kiara_table_entry *pChoose;\n\tint fps, ret = 0;\n\n\tif (size >= PSZ_MAX || *compression < 0 || *compression > 3)\n\t\treturn -EINVAL;\n\tif (frames < 5)\n\t\tframes = 5;\n\telse if (size == PSZ_VGA && frames > 15)\n\t\tframes = 15;\n\telse if (frames > 30)\n\t\tframes = 30;\n\tfps = (frames / 5) - 1;\n\n\t \n\tdo {\n\t\tpChoose = &Kiara_table[size][fps][*compression];\n\t\tif (pChoose->alternate != 0)\n\t\t\tbreak;\n\t\t(*compression)++;\n\t} while (*compression <= 3);\n\n\tif (pChoose->alternate == 0)\n\t\treturn -ENOENT;  \n\n\t \n\tif (send_to_cam)\n\t\tret = send_video_command(pdev, 4, pChoose->mode, 12);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (pChoose->bandlength > 0 && pixfmt == V4L2_PIX_FMT_YUV420)\n\t\tpwc_dec23_init(pdev, pChoose->mode);\n\n\t \n\tpdev->pixfmt = pixfmt;\n\tpdev->vframes = (fps + 1) * 5;\n\tpdev->valternate = pChoose->alternate;\n\tpdev->width  = pwc_image_sizes[size][0];\n\tpdev->height = pwc_image_sizes[size][1];\n\tpdev->vbandlength = pChoose->bandlength;\n\tif (pdev->vbandlength > 0)\n\t\tpdev->frame_size = (pdev->vbandlength * pdev->height) / 4;\n\telse\n\t\tpdev->frame_size = (pdev->width * pdev->height * 12) / 8;\n\tPWC_TRACE(\"frame_size=%d, vframes=%d, vsize=%d, vbandlength=%d\\n\",\n\t    pdev->frame_size, pdev->vframes, size, pdev->vbandlength);\n\treturn 0;\n}\n\nint pwc_set_video_mode(struct pwc_device *pdev, int width, int height,\n\tint pixfmt, int frames, int *compression, int send_to_cam)\n{\n\tint ret, size;\n\n\tPWC_DEBUG_FLOW(\"set_video_mode(%dx%d @ %d, pixfmt %08x).\\n\",\n\t\t       width, height, frames, pixfmt);\n\tsize = pwc_get_size(pdev, width, height);\n\tPWC_TRACE(\"decode_size = %d.\\n\", size);\n\n\tif (DEVICE_USE_CODEC1(pdev->type)) {\n\t\tret = set_video_mode_Nala(pdev, size, pixfmt, frames,\n\t\t\t\t\t  compression, send_to_cam);\n\t} else if (DEVICE_USE_CODEC3(pdev->type)) {\n\t\tret = set_video_mode_Kiara(pdev, size, pixfmt, frames,\n\t\t\t\t\t   compression, send_to_cam);\n\t} else {\n\t\tret = set_video_mode_Timon(pdev, size, pixfmt, frames,\n\t\t\t\t\t   compression, send_to_cam);\n\t}\n\tif (ret < 0) {\n\t\tPWC_ERROR(\"Failed to set video mode %s@%d fps; return code = %d\\n\", size2name[size], frames, ret);\n\t\treturn ret;\n\t}\n\tpdev->frame_total_size = pdev->frame_size + pdev->frame_header_size + pdev->frame_trailer_size;\n\tPWC_DEBUG_SIZE(\"Set resolution to %dx%d\\n\", pdev->width, pdev->height);\n\treturn 0;\n}\n\nstatic unsigned int pwc_get_fps_Nala(struct pwc_device *pdev, unsigned int index, unsigned int size)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < PWC_FPS_MAX_NALA; i++) {\n\t\tif (Nala_table[size][i].alternate) {\n\t\t\tif (index--==0) return Nala_fps_vector[i];\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic unsigned int pwc_get_fps_Kiara(struct pwc_device *pdev, unsigned int index, unsigned int size)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < PWC_FPS_MAX_KIARA; i++) {\n\t\tif (Kiara_table[size][i][3].alternate) {\n\t\t\tif (index--==0) return Kiara_fps_vector[i];\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic unsigned int pwc_get_fps_Timon(struct pwc_device *pdev, unsigned int index, unsigned int size)\n{\n\tunsigned int i;\n\n\tfor (i=0; i < PWC_FPS_MAX_TIMON; i++) {\n\t\tif (Timon_table[size][i][3].alternate) {\n\t\t\tif (index--==0) return Timon_fps_vector[i];\n\t\t}\n\t}\n\treturn 0;\n}\n\nunsigned int pwc_get_fps(struct pwc_device *pdev, unsigned int index, unsigned int size)\n{\n\tunsigned int ret;\n\n\tif (DEVICE_USE_CODEC1(pdev->type)) {\n\t\tret = pwc_get_fps_Nala(pdev, index, size);\n\n\t} else if (DEVICE_USE_CODEC3(pdev->type)) {\n\t\tret = pwc_get_fps_Kiara(pdev, index, size);\n\n\t} else {\n\t\tret = pwc_get_fps_Timon(pdev, index, size);\n\t}\n\n\treturn ret;\n}\n\nint pwc_get_u8_ctrl(struct pwc_device *pdev, u8 request, u16 value, int *data)\n{\n\tint ret;\n\n\tret = recv_control_msg(pdev, request, value, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*data = pdev->ctrl_buf[0];\n\treturn 0;\n}\n\nint pwc_set_u8_ctrl(struct pwc_device *pdev, u8 request, u16 value, u8 data)\n{\n\tint ret;\n\n\tpdev->ctrl_buf[0] = data;\n\tret = send_control_msg(pdev, request, value, pdev->ctrl_buf, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint pwc_get_s8_ctrl(struct pwc_device *pdev, u8 request, u16 value, int *data)\n{\n\tint ret;\n\n\tret = recv_control_msg(pdev, request, value, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*data = ((s8 *)pdev->ctrl_buf)[0];\n\treturn 0;\n}\n\nint pwc_get_u16_ctrl(struct pwc_device *pdev, u8 request, u16 value, int *data)\n{\n\tint ret;\n\n\tret = recv_control_msg(pdev, request, value, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*data = (pdev->ctrl_buf[1] << 8) | pdev->ctrl_buf[0];\n\treturn 0;\n}\n\nint pwc_set_u16_ctrl(struct pwc_device *pdev, u8 request, u16 value, u16 data)\n{\n\tint ret;\n\n\tpdev->ctrl_buf[0] = data & 0xff;\n\tpdev->ctrl_buf[1] = data >> 8;\n\tret = send_control_msg(pdev, request, value, pdev->ctrl_buf, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint pwc_button_ctrl(struct pwc_device *pdev, u16 value)\n{\n\tint ret;\n\n\tret = send_control_msg(pdev, SET_STATUS_CTL, value, NULL, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nvoid pwc_camera_power(struct pwc_device *pdev, int power)\n{\n\tint r;\n\n\tif (!pdev->power_save)\n\t\treturn;\n\n\tif (pdev->type < 675 || (pdev->type < 730 && pdev->release < 6))\n\t\treturn;\t \n\n\tif (power)\n\t\tpdev->ctrl_buf[0] = 0x00;  \n\telse\n\t\tpdev->ctrl_buf[0] = 0xFF;  \n\tr = send_control_msg(pdev, SET_STATUS_CTL,\n\t\tSET_POWER_SAVE_MODE_FORMATTER, pdev->ctrl_buf, 1);\n\tif (r < 0)\n\t\tPWC_ERROR(\"Failed to power %s camera (%d)\\n\",\n\t\t\t  power ? \"on\" : \"off\", r);\n}\n\nint pwc_set_leds(struct pwc_device *pdev, int on_value, int off_value)\n{\n\tint r;\n\n\tif (pdev->type < 730)\n\t\treturn 0;\n\ton_value /= 100;\n\toff_value /= 100;\n\tif (on_value < 0)\n\t\ton_value = 0;\n\tif (on_value > 0xff)\n\t\ton_value = 0xff;\n\tif (off_value < 0)\n\t\toff_value = 0;\n\tif (off_value > 0xff)\n\t\toff_value = 0xff;\n\n\tpdev->ctrl_buf[0] = on_value;\n\tpdev->ctrl_buf[1] = off_value;\n\n\tr = send_control_msg(pdev,\n\t\tSET_STATUS_CTL, LED_FORMATTER, pdev->ctrl_buf, 2);\n\tif (r < 0)\n\t\tPWC_ERROR(\"Failed to set LED on/off time (%d)\\n\", r);\n\n\treturn r;\n}\n\n#ifdef CONFIG_USB_PWC_DEBUG\nint pwc_get_cmos_sensor(struct pwc_device *pdev, int *sensor)\n{\n\tint ret, request;\n\n\tif (pdev->type < 675)\n\t\trequest = SENSOR_TYPE_FORMATTER1;\n\telse if (pdev->type < 730)\n\t\treturn -1;  \n\telse\n\t\trequest = SENSOR_TYPE_FORMATTER2;\n\n\tret = recv_control_msg(pdev, GET_STATUS_CTL, request, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (pdev->type < 675)\n\t\t*sensor = pdev->ctrl_buf[0] | 0x100;\n\telse\n\t\t*sensor = pdev->ctrl_buf[0];\n\treturn 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}