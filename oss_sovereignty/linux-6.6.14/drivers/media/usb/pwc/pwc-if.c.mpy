{
  "module_name": "pwc-if.c",
  "hash_id": "47a010380c876a64ad9d8fcf5cf8198c75fe78d11c328819df273521cdf1eae1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/pwc/pwc-if.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#ifdef CONFIG_USB_PWC_INPUT_EVDEV\n#include <linux/usb/input.h>\n#endif\n#include <linux/vmalloc.h>\n#include <asm/io.h>\n#include <linux/kernel.h>\t\t \n\n#include \"pwc.h\"\n#include \"pwc-kiara.h\"\n#include \"pwc-timon.h\"\n#include \"pwc-dec23.h\"\n#include \"pwc-dec1.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/pwc.h>\n\n \n\n \nstatic const struct usb_device_id pwc_device_table [] = {\n\t{ USB_DEVICE(0x041E, 0x400C) },  \n\t{ USB_DEVICE(0x041E, 0x4011) },  \n\n\t{ USB_DEVICE(0x046D, 0x08B0) },  \n\t{ USB_DEVICE(0x046D, 0x08B1) },  \n\t{ USB_DEVICE(0x046D, 0x08B2) },  \n\t{ USB_DEVICE(0x046D, 0x08B3) },  \n\t{ USB_DEVICE(0x046D, 0x08B4) },  \n\t{ USB_DEVICE(0x046D, 0x08B5) },  \n\t{ USB_DEVICE(0x046D, 0x08B6) },  \n\t{ USB_DEVICE(0x046D, 0x08B7) },  \n\t{ USB_DEVICE(0x046D, 0x08B8) },  \n\n\t{ USB_DEVICE(0x0471, 0x0302) },  \n\t{ USB_DEVICE(0x0471, 0x0303) },  \n\t{ USB_DEVICE(0x0471, 0x0304) },  \n\t{ USB_DEVICE(0x0471, 0x0307) },  \n\t{ USB_DEVICE(0x0471, 0x0308) },  \n\t{ USB_DEVICE(0x0471, 0x030C) },  \n\t{ USB_DEVICE(0x0471, 0x0310) },  \n\t{ USB_DEVICE(0x0471, 0x0311) },  \n\t{ USB_DEVICE(0x0471, 0x0312) },  \n\t{ USB_DEVICE(0x0471, 0x0313) },  \n\t{ USB_DEVICE(0x0471, 0x0329) },  \n\t{ USB_DEVICE(0x0471, 0x032C) },  \n\n\t{ USB_DEVICE(0x04CC, 0x8116) },  \n\n\t{ USB_DEVICE(0x055D, 0x9000) },  \n\t{ USB_DEVICE(0x055D, 0x9001) },  \n\t{ USB_DEVICE(0x055D, 0x9002) },\t \n\n\t{ USB_DEVICE(0x069A, 0x0001) },  \n\n\t{ USB_DEVICE(0x06BE, 0x8116) },  \n\n\t{ USB_DEVICE(0x0d81, 0x1900) },  \n\t{ USB_DEVICE(0x0d81, 0x1910) },  \n\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, pwc_device_table);\n\nstatic int usb_pwc_probe(struct usb_interface *intf, const struct usb_device_id *id);\nstatic void usb_pwc_disconnect(struct usb_interface *intf);\nstatic void pwc_isoc_cleanup(struct pwc_device *pdev);\n\nstatic struct usb_driver pwc_driver = {\n\t.name =\t\t\t\"Philips webcam\",\t \n\t.id_table =\t\tpwc_device_table,\n\t.probe =\t\tusb_pwc_probe,\t\t \n\t.disconnect =\t\tusb_pwc_disconnect,\t \n};\n\n#define MAX_DEV_HINTS\t20\n#define MAX_ISOC_ERRORS\t20\n\n#ifdef CONFIG_USB_PWC_DEBUG\n\tint pwc_trace = PWC_DEBUG_LEVEL;\n#endif\nstatic int power_save = -1;\nstatic int leds[2] = { 100, 0 };\n\n \n\nstatic const struct v4l2_file_operations pwc_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.open =\t\tv4l2_fh_open,\n\t.release =\tvb2_fop_release,\n\t.read =\t\tvb2_fop_read,\n\t.poll =\t\tvb2_fop_poll,\n\t.mmap =\t\tvb2_fop_mmap,\n\t.unlocked_ioctl = video_ioctl2,\n};\nstatic const struct video_device pwc_template = {\n\t.name =\t\t\"Philips Webcam\",\t \n\t.release =\tvideo_device_release_empty,\n\t.fops =         &pwc_fops,\n\t.ioctl_ops =\t&pwc_ioctl_ops,\n};\n\n \n \n\nstatic void *pwc_alloc_urb_buffer(struct usb_device *dev,\n\t\t\t\t  size_t size, dma_addr_t *dma_handle)\n{\n\tstruct device *dmadev = dev->bus->sysdev;\n\tvoid *buffer = kmalloc(size, GFP_KERNEL);\n\n\tif (!buffer)\n\t\treturn NULL;\n\n\t*dma_handle = dma_map_single(dmadev, buffer, size, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(dmadev, *dma_handle)) {\n\t\tkfree(buffer);\n\t\treturn NULL;\n\t}\n\n\treturn buffer;\n}\n\nstatic void pwc_free_urb_buffer(struct usb_device *dev,\n\t\t\t\tsize_t size,\n\t\t\t\tvoid *buffer,\n\t\t\t\tdma_addr_t dma_handle)\n{\n\tstruct device *dmadev = dev->bus->sysdev;\n\n\tdma_unmap_single(dmadev, dma_handle, size, DMA_FROM_DEVICE);\n\tkfree(buffer);\n}\n\nstatic struct pwc_frame_buf *pwc_get_next_fill_buf(struct pwc_device *pdev)\n{\n\tunsigned long flags = 0;\n\tstruct pwc_frame_buf *buf = NULL;\n\n\tspin_lock_irqsave(&pdev->queued_bufs_lock, flags);\n\tif (list_empty(&pdev->queued_bufs))\n\t\tgoto leave;\n\n\tbuf = list_entry(pdev->queued_bufs.next, struct pwc_frame_buf, list);\n\tlist_del(&buf->list);\nleave:\n\tspin_unlock_irqrestore(&pdev->queued_bufs_lock, flags);\n\treturn buf;\n}\n\nstatic void pwc_snapshot_button(struct pwc_device *pdev, int down)\n{\n\tif (down) {\n\t\tPWC_TRACE(\"Snapshot button pressed.\\n\");\n\t} else {\n\t\tPWC_TRACE(\"Snapshot button released.\\n\");\n\t}\n\n#ifdef CONFIG_USB_PWC_INPUT_EVDEV\n\tif (pdev->button_dev) {\n\t\tinput_report_key(pdev->button_dev, KEY_CAMERA, down);\n\t\tinput_sync(pdev->button_dev);\n\t}\n#endif\n}\n\nstatic void pwc_frame_complete(struct pwc_device *pdev)\n{\n\tstruct pwc_frame_buf *fbuf = pdev->fill_buf;\n\n\t \n\tif (pdev->type == 730) {\n\t\tunsigned char *ptr = (unsigned char *)fbuf->data;\n\n\t\tif (ptr[1] == 1 && ptr[0] & 0x10) {\n\t\t\tPWC_TRACE(\"Hyundai CMOS sensor bug. Dropping frame.\\n\");\n\t\t\tpdev->drop_frames += 2;\n\t\t}\n\t\tif ((ptr[0] ^ pdev->vmirror) & 0x01) {\n\t\t\tpwc_snapshot_button(pdev, ptr[0] & 0x01);\n\t\t}\n\t\tif ((ptr[0] ^ pdev->vmirror) & 0x02) {\n\t\t\tif (ptr[0] & 0x02)\n\t\t\t\tPWC_TRACE(\"Image is mirrored.\\n\");\n\t\t\telse\n\t\t\t\tPWC_TRACE(\"Image is normal.\\n\");\n\t\t}\n\t\tpdev->vmirror = ptr[0] & 0x03;\n\t\t \n\t\tif (fbuf->filled == 4)\n\t\t\tpdev->drop_frames++;\n\t} else if (pdev->type == 740 || pdev->type == 720) {\n\t\tunsigned char *ptr = (unsigned char *)fbuf->data;\n\t\tif ((ptr[0] ^ pdev->vmirror) & 0x01) {\n\t\t\tpwc_snapshot_button(pdev, ptr[0] & 0x01);\n\t\t}\n\t\tpdev->vmirror = ptr[0] & 0x03;\n\t}\n\n\t \n\tif (pdev->drop_frames > 0) {\n\t\tpdev->drop_frames--;\n\t} else {\n\t\t \n\t\tif (fbuf->filled < pdev->frame_total_size) {\n\t\t\tPWC_DEBUG_FLOW(\"Frame buffer underflow (%d bytes); discarded.\\n\",\n\t\t\t\t       fbuf->filled);\n\t\t} else {\n\t\t\tfbuf->vb.field = V4L2_FIELD_NONE;\n\t\t\tfbuf->vb.sequence = pdev->vframe_count;\n\t\t\tvb2_buffer_done(&fbuf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\t\t\tpdev->fill_buf = NULL;\n\t\t\tpdev->vsync = 0;\n\t\t}\n\t}  \n\tpdev->vframe_count++;\n}\n\n \nstatic void pwc_isoc_handler(struct urb *urb)\n{\n\tstruct pwc_device *pdev = (struct pwc_device *)urb->context;\n\tstruct device *dmadev = urb->dev->bus->sysdev;\n\tint i, fst, flen;\n\tunsigned char *iso_buf = NULL;\n\n\ttrace_pwc_handler_enter(urb, pdev);\n\n\tif (urb->status == -ENOENT || urb->status == -ECONNRESET ||\n\t    urb->status == -ESHUTDOWN) {\n\t\tPWC_DEBUG_OPEN(\"URB (%p) unlinked %ssynchronously.\\n\",\n\t\t\t       urb, urb->status == -ENOENT ? \"\" : \"a\");\n\t\treturn;\n\t}\n\n\tif (pdev->fill_buf == NULL)\n\t\tpdev->fill_buf = pwc_get_next_fill_buf(pdev);\n\n\tif (urb->status != 0) {\n\t\tconst char *errmsg;\n\n\t\terrmsg = \"Unknown\";\n\t\tswitch(urb->status) {\n\t\t\tcase -ENOSR:\t\terrmsg = \"Buffer error (overrun)\"; break;\n\t\t\tcase -EPIPE:\t\terrmsg = \"Stalled (device not responding)\"; break;\n\t\t\tcase -EOVERFLOW:\terrmsg = \"Babble (bad cable?)\"; break;\n\t\t\tcase -EPROTO:\t\terrmsg = \"Bit-stuff error (bad cable?)\"; break;\n\t\t\tcase -EILSEQ:\t\terrmsg = \"CRC/Timeout (could be anything)\"; break;\n\t\t\tcase -ETIME:\t\terrmsg = \"Device does not respond\"; break;\n\t\t}\n\t\tPWC_ERROR(\"pwc_isoc_handler() called with status %d [%s].\\n\",\n\t\t\t  urb->status, errmsg);\n\t\t \n\t\tif (++pdev->visoc_errors > MAX_ISOC_ERRORS)\n\t\t{\n\t\t\tPWC_ERROR(\"Too many ISOC errors, bailing out.\\n\");\n\t\t\tif (pdev->fill_buf) {\n\t\t\t\tvb2_buffer_done(&pdev->fill_buf->vb.vb2_buf,\n\t\t\t\t\t\tVB2_BUF_STATE_ERROR);\n\t\t\t\tpdev->fill_buf = NULL;\n\t\t\t}\n\t\t}\n\t\tpdev->vsync = 0;  \n\t\tgoto handler_end;\n\t}\n\n\t \n\tpdev->visoc_errors = 0;\n\n\tdma_sync_single_for_cpu(dmadev,\n\t\t\t\turb->transfer_dma,\n\t\t\t\turb->transfer_buffer_length,\n\t\t\t\tDMA_FROM_DEVICE);\n\n\t \n\t \n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\tfst  = urb->iso_frame_desc[i].status;\n\t\tflen = urb->iso_frame_desc[i].actual_length;\n\t\tiso_buf = urb->transfer_buffer + urb->iso_frame_desc[i].offset;\n\t\tif (fst != 0) {\n\t\t\tPWC_ERROR(\"Iso frame %d has error %d\\n\", i, fst);\n\t\t\tcontinue;\n\t\t}\n\t\tif (flen > 0 && pdev->vsync) {\n\t\t\tstruct pwc_frame_buf *fbuf = pdev->fill_buf;\n\n\t\t\tif (pdev->vsync == 1) {\n\t\t\t\tfbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\t\t\tpdev->vsync = 2;\n\t\t\t}\n\n\t\t\tif (flen + fbuf->filled > pdev->frame_total_size) {\n\t\t\t\tPWC_ERROR(\"Frame overflow (%d > %d)\\n\",\n\t\t\t\t\t  flen + fbuf->filled,\n\t\t\t\t\t  pdev->frame_total_size);\n\t\t\t\tpdev->vsync = 0;  \n\t\t\t} else {\n\t\t\t\tmemcpy(fbuf->data + fbuf->filled, iso_buf,\n\t\t\t\t       flen);\n\t\t\t\tfbuf->filled += flen;\n\t\t\t}\n\t\t}\n\t\tif (flen < pdev->vlast_packet_size) {\n\t\t\t \n\t\t\tif (pdev->vsync == 2)\n\t\t\t\tpwc_frame_complete(pdev);\n\t\t\tif (pdev->fill_buf == NULL)\n\t\t\t\tpdev->fill_buf = pwc_get_next_fill_buf(pdev);\n\t\t\tif (pdev->fill_buf) {\n\t\t\t\tpdev->fill_buf->filled = 0;\n\t\t\t\tpdev->vsync = 1;\n\t\t\t}\n\t\t}\n\t\tpdev->vlast_packet_size = flen;\n\t}\n\n\tdma_sync_single_for_device(dmadev,\n\t\t\t\t   urb->transfer_dma,\n\t\t\t\t   urb->transfer_buffer_length,\n\t\t\t\t   DMA_FROM_DEVICE);\n\nhandler_end:\n\ttrace_pwc_handler_exit(urb, pdev);\n\n\ti = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (i != 0)\n\t\tPWC_ERROR(\"Error (%d) re-submitting urb in pwc_isoc_handler.\\n\", i);\n}\n\n \nstatic int pwc_isoc_init(struct pwc_device *pdev)\n{\n\tstruct usb_device *udev;\n\tstruct urb *urb;\n\tint i, j, ret;\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *idesc = NULL;\n\tint compression = 0;  \n\n\tpdev->vsync = 0;\n\tpdev->vlast_packet_size = 0;\n\tpdev->fill_buf = NULL;\n\tpdev->vframe_count = 0;\n\tpdev->visoc_errors = 0;\n\tudev = pdev->udev;\n\nretry:\n\t \n\tret = pwc_set_video_mode(pdev, pdev->width, pdev->height, pdev->pixfmt,\n\t\t\t\t pdev->vframes, &compression, 1);\n\n\t \n\tintf = usb_ifnum_to_if(udev, 0);\n\tif (intf)\n\t\tidesc = usb_altnum_to_altsetting(intf, pdev->valternate);\n\tif (!idesc)\n\t\treturn -EIO;\n\n\t \n\tpdev->vmax_packet_size = -1;\n\tfor (i = 0; i < idesc->desc.bNumEndpoints; i++) {\n\t\tif ((idesc->endpoint[i].desc.bEndpointAddress & 0xF) == pdev->vendpoint) {\n\t\t\tpdev->vmax_packet_size = le16_to_cpu(idesc->endpoint[i].desc.wMaxPacketSize);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pdev->vmax_packet_size < 0 || pdev->vmax_packet_size > ISO_MAX_FRAME_SIZE) {\n\t\tPWC_ERROR(\"Failed to find packet size for video endpoint in current alternate setting.\\n\");\n\t\treturn -ENFILE;  \n\t}\n\n\t \n\tPWC_DEBUG_OPEN(\"Setting alternate interface %d\\n\", pdev->valternate);\n\tret = usb_set_interface(pdev->udev, 0, pdev->valternate);\n\tif (ret == -ENOSPC && compression < 3) {\n\t\tcompression++;\n\t\tgoto retry;\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < MAX_ISO_BUFS; i++) {\n\t\turb = usb_alloc_urb(ISO_FRAMES_PER_DESC, GFP_KERNEL);\n\t\tif (urb == NULL) {\n\t\t\tpwc_isoc_cleanup(pdev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpdev->urbs[i] = urb;\n\t\tPWC_DEBUG_MEMORY(\"Allocated URB at 0x%p\\n\", urb);\n\n\t\turb->interval = 1;  \n\t\turb->dev = udev;\n\t\turb->pipe = usb_rcvisocpipe(udev, pdev->vendpoint);\n\t\turb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\n\t\turb->transfer_buffer_length = ISO_BUFFER_SIZE;\n\t\turb->transfer_buffer = pwc_alloc_urb_buffer(udev,\n\t\t\t\t\t\t\t    urb->transfer_buffer_length,\n\t\t\t\t\t\t\t    &urb->transfer_dma);\n\t\tif (urb->transfer_buffer == NULL) {\n\t\t\tPWC_ERROR(\"Failed to allocate urb buffer %d\\n\", i);\n\t\t\tpwc_isoc_cleanup(pdev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\turb->complete = pwc_isoc_handler;\n\t\turb->context = pdev;\n\t\turb->start_frame = 0;\n\t\turb->number_of_packets = ISO_FRAMES_PER_DESC;\n\t\tfor (j = 0; j < ISO_FRAMES_PER_DESC; j++) {\n\t\t\turb->iso_frame_desc[j].offset = j * ISO_MAX_FRAME_SIZE;\n\t\t\turb->iso_frame_desc[j].length = pdev->vmax_packet_size;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < MAX_ISO_BUFS; i++) {\n\t\tret = usb_submit_urb(pdev->urbs[i], GFP_KERNEL);\n\t\tif (ret == -ENOSPC && compression < 3) {\n\t\t\tcompression++;\n\t\t\tpwc_isoc_cleanup(pdev);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (ret) {\n\t\t\tPWC_ERROR(\"isoc_init() submit_urb %d failed with error %d\\n\", i, ret);\n\t\t\tpwc_isoc_cleanup(pdev);\n\t\t\treturn ret;\n\t\t}\n\t\tPWC_DEBUG_MEMORY(\"URB 0x%p submitted.\\n\", pdev->urbs[i]);\n\t}\n\n\t \n\tPWC_DEBUG_OPEN(\"<< pwc_isoc_init()\\n\");\n\treturn 0;\n}\n\nstatic void pwc_iso_stop(struct pwc_device *pdev)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < MAX_ISO_BUFS; i++) {\n\t\tif (pdev->urbs[i]) {\n\t\t\tPWC_DEBUG_MEMORY(\"Unlinking URB %p\\n\", pdev->urbs[i]);\n\t\t\tusb_kill_urb(pdev->urbs[i]);\n\t\t}\n\t}\n}\n\nstatic void pwc_iso_free(struct pwc_device *pdev)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < MAX_ISO_BUFS; i++) {\n\t\tstruct urb *urb = pdev->urbs[i];\n\n\t\tif (urb) {\n\t\t\tPWC_DEBUG_MEMORY(\"Freeing URB\\n\");\n\t\t\tif (urb->transfer_buffer)\n\t\t\t\tpwc_free_urb_buffer(urb->dev,\n\t\t\t\t\t\t    urb->transfer_buffer_length,\n\t\t\t\t\t\t    urb->transfer_buffer,\n\t\t\t\t\t\t    urb->transfer_dma);\n\t\t\tusb_free_urb(urb);\n\t\t\tpdev->urbs[i] = NULL;\n\t\t}\n\t}\n}\n\n \nstatic void pwc_isoc_cleanup(struct pwc_device *pdev)\n{\n\tPWC_DEBUG_OPEN(\">> pwc_isoc_cleanup()\\n\");\n\n\tpwc_iso_stop(pdev);\n\tpwc_iso_free(pdev);\n\tusb_set_interface(pdev->udev, 0, 0);\n\n\tPWC_DEBUG_OPEN(\"<< pwc_isoc_cleanup()\\n\");\n}\n\n \nstatic void pwc_cleanup_queued_bufs(struct pwc_device *pdev,\n\t\t\t\t    enum vb2_buffer_state state)\n{\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&pdev->queued_bufs_lock, flags);\n\twhile (!list_empty(&pdev->queued_bufs)) {\n\t\tstruct pwc_frame_buf *buf;\n\n\t\tbuf = list_entry(pdev->queued_bufs.next, struct pwc_frame_buf,\n\t\t\t\t list);\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t}\n\tspin_unlock_irqrestore(&pdev->queued_bufs_lock, flags);\n}\n\n#ifdef CONFIG_USB_PWC_DEBUG\nstatic const char *pwc_sensor_type_to_string(unsigned int sensor_type)\n{\n\tswitch(sensor_type) {\n\t\tcase 0x00:\n\t\t\treturn \"Hyundai CMOS sensor\";\n\t\tcase 0x20:\n\t\t\treturn \"Sony CCD sensor + TDA8787\";\n\t\tcase 0x2E:\n\t\t\treturn \"Sony CCD sensor + Exas 98L59\";\n\t\tcase 0x2F:\n\t\t\treturn \"Sony CCD sensor + ADI 9804\";\n\t\tcase 0x30:\n\t\t\treturn \"Sharp CCD sensor + TDA8787\";\n\t\tcase 0x3E:\n\t\t\treturn \"Sharp CCD sensor + Exas 98L59\";\n\t\tcase 0x3F:\n\t\t\treturn \"Sharp CCD sensor + ADI 9804\";\n\t\tcase 0x40:\n\t\t\treturn \"UPA 1021 sensor\";\n\t\tcase 0x100:\n\t\t\treturn \"VGA sensor\";\n\t\tcase 0x101:\n\t\t\treturn \"PAL MR sensor\";\n\t\tdefault:\n\t\t\treturn \"unknown type of sensor\";\n\t}\n}\n#endif\n\n \n \n\nstatic void pwc_video_release(struct v4l2_device *v)\n{\n\tstruct pwc_device *pdev = container_of(v, struct pwc_device, v4l2_dev);\n\n\tv4l2_ctrl_handler_free(&pdev->ctrl_handler);\n\tv4l2_device_unregister(&pdev->v4l2_dev);\n\tkfree(pdev->ctrl_buf);\n\tkfree(pdev);\n}\n\n \n \n\nstatic int queue_setup(struct vb2_queue *vq,\n\t\t\t\tunsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t\tunsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct pwc_device *pdev = vb2_get_drv_priv(vq);\n\tint size;\n\n\tif (*nbuffers < MIN_FRAMES)\n\t\t*nbuffers = MIN_FRAMES;\n\telse if (*nbuffers > MAX_FRAMES)\n\t\t*nbuffers = MAX_FRAMES;\n\n\t*nplanes = 1;\n\n\tsize = pwc_get_size(pdev, MAX_WIDTH, MAX_HEIGHT);\n\tsizes[0] = PAGE_ALIGN(pwc_image_sizes[size][0] *\n\t\t\t      pwc_image_sizes[size][1] * 3 / 2);\n\n\treturn 0;\n}\n\nstatic int buffer_init(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct pwc_frame_buf *buf =\n\t\tcontainer_of(vbuf, struct pwc_frame_buf, vb);\n\n\t \n\tbuf->data = vzalloc(PWC_FRAME_SIZE);\n\tif (buf->data == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct pwc_device *pdev = vb2_get_drv_priv(vb->vb2_queue);\n\n\t \n\tif (!pdev->udev)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic void buffer_finish(struct vb2_buffer *vb)\n{\n\tstruct pwc_device *pdev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct pwc_frame_buf *buf =\n\t\tcontainer_of(vbuf, struct pwc_frame_buf, vb);\n\n\tif (vb->state == VB2_BUF_STATE_DONE) {\n\t\t \n\t\tpwc_decompress(pdev, buf);\n\t}\n}\n\nstatic void buffer_cleanup(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct pwc_frame_buf *buf =\n\t\tcontainer_of(vbuf, struct pwc_frame_buf, vb);\n\n\tvfree(buf->data);\n}\n\nstatic void buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct pwc_device *pdev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct pwc_frame_buf *buf =\n\t\tcontainer_of(vbuf, struct pwc_frame_buf, vb);\n\tunsigned long flags = 0;\n\n\t \n\tif (!pdev->udev) {\n\t\tvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&pdev->queued_bufs_lock, flags);\n\tlist_add_tail(&buf->list, &pdev->queued_bufs);\n\tspin_unlock_irqrestore(&pdev->queued_bufs_lock, flags);\n}\n\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct pwc_device *pdev = vb2_get_drv_priv(vq);\n\tint r;\n\n\tif (!pdev->udev)\n\t\treturn -ENODEV;\n\n\tif (mutex_lock_interruptible(&pdev->v4l2_lock))\n\t\treturn -ERESTARTSYS;\n\t \n\tpwc_camera_power(pdev, 1);\n\tpwc_set_leds(pdev, leds[0], leds[1]);\n\n\tr = pwc_isoc_init(pdev);\n\tif (r) {\n\t\t \n\t\tpwc_set_leds(pdev, 0, 0);\n\t\tpwc_camera_power(pdev, 0);\n\t\t \n\t\tpwc_cleanup_queued_bufs(pdev, VB2_BUF_STATE_QUEUED);\n\t}\n\tmutex_unlock(&pdev->v4l2_lock);\n\n\treturn r;\n}\n\nstatic void stop_streaming(struct vb2_queue *vq)\n{\n\tstruct pwc_device *pdev = vb2_get_drv_priv(vq);\n\n\tmutex_lock(&pdev->v4l2_lock);\n\tif (pdev->udev) {\n\t\tpwc_set_leds(pdev, 0, 0);\n\t\tpwc_camera_power(pdev, 0);\n\t\tpwc_isoc_cleanup(pdev);\n\t}\n\n\tpwc_cleanup_queued_bufs(pdev, VB2_BUF_STATE_ERROR);\n\tif (pdev->fill_buf)\n\t\tvb2_buffer_done(&pdev->fill_buf->vb.vb2_buf,\n\t\t\t\tVB2_BUF_STATE_ERROR);\n\tmutex_unlock(&pdev->v4l2_lock);\n}\n\nstatic const struct vb2_ops pwc_vb_queue_ops = {\n\t.queue_setup\t\t= queue_setup,\n\t.buf_init\t\t= buffer_init,\n\t.buf_prepare\t\t= buffer_prepare,\n\t.buf_finish\t\t= buffer_finish,\n\t.buf_cleanup\t\t= buffer_cleanup,\n\t.buf_queue\t\t= buffer_queue,\n\t.start_streaming\t= start_streaming,\n\t.stop_streaming\t\t= stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\n \n \n\n \n\nstatic int usb_pwc_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct pwc_device *pdev = NULL;\n\tint vendor_id, product_id, type_id;\n\tint rc;\n\tint features = 0;\n\tint compression = 0;\n\tint my_power_save = power_save;\n\tchar serial_number[30], *name;\n\n\tvendor_id = le16_to_cpu(udev->descriptor.idVendor);\n\tproduct_id = le16_to_cpu(udev->descriptor.idProduct);\n\n\t \n\tPWC_DEBUG_PROBE(\"probe() called [%04X %04X], if %d\\n\",\n\t\tvendor_id, product_id,\n\t\tintf->altsetting->desc.bInterfaceNumber);\n\n\t \n\tif (intf->altsetting->desc.bInterfaceNumber > 0)\n\t\treturn -ENODEV;\n\n\tif (vendor_id == 0x0471) {\n\t\tswitch (product_id) {\n\t\tcase 0x0302:\n\t\t\tPWC_INFO(\"Philips PCA645VC USB webcam detected.\\n\");\n\t\t\tname = \"Philips 645 webcam\";\n\t\t\ttype_id = 645;\n\t\t\tbreak;\n\t\tcase 0x0303:\n\t\t\tPWC_INFO(\"Philips PCA646VC USB webcam detected.\\n\");\n\t\t\tname = \"Philips 646 webcam\";\n\t\t\ttype_id = 646;\n\t\t\tbreak;\n\t\tcase 0x0304:\n\t\t\tPWC_INFO(\"Askey VC010 type 2 USB webcam detected.\\n\");\n\t\t\tname = \"Askey VC010 webcam\";\n\t\t\ttype_id = 646;\n\t\t\tbreak;\n\t\tcase 0x0307:\n\t\t\tPWC_INFO(\"Philips PCVC675K (Vesta) USB webcam detected.\\n\");\n\t\t\tname = \"Philips 675 webcam\";\n\t\t\ttype_id = 675;\n\t\t\tbreak;\n\t\tcase 0x0308:\n\t\t\tPWC_INFO(\"Philips PCVC680K (Vesta Pro) USB webcam detected.\\n\");\n\t\t\tname = \"Philips 680 webcam\";\n\t\t\ttype_id = 680;\n\t\t\tbreak;\n\t\tcase 0x030C:\n\t\t\tPWC_INFO(\"Philips PCVC690K (Vesta Pro Scan) USB webcam detected.\\n\");\n\t\t\tname = \"Philips 690 webcam\";\n\t\t\ttype_id = 690;\n\t\t\tbreak;\n\t\tcase 0x0310:\n\t\t\tPWC_INFO(\"Philips PCVC730K (ToUCam Fun)/PCVC830 (ToUCam II) USB webcam detected.\\n\");\n\t\t\tname = \"Philips 730 webcam\";\n\t\t\ttype_id = 730;\n\t\t\tbreak;\n\t\tcase 0x0311:\n\t\t\tPWC_INFO(\"Philips PCVC740K (ToUCam Pro)/PCVC840 (ToUCam II) USB webcam detected.\\n\");\n\t\t\tname = \"Philips 740 webcam\";\n\t\t\ttype_id = 740;\n\t\t\tbreak;\n\t\tcase 0x0312:\n\t\t\tPWC_INFO(\"Philips PCVC750K (ToUCam Pro Scan) USB webcam detected.\\n\");\n\t\t\tname = \"Philips 750 webcam\";\n\t\t\ttype_id = 750;\n\t\t\tbreak;\n\t\tcase 0x0313:\n\t\t\tPWC_INFO(\"Philips PCVC720K/40 (ToUCam XS) USB webcam detected.\\n\");\n\t\t\tname = \"Philips 720K/40 webcam\";\n\t\t\ttype_id = 720;\n\t\t\tbreak;\n\t\tcase 0x0329:\n\t\t\tPWC_INFO(\"Philips SPC 900NC USB webcam detected.\\n\");\n\t\t\tname = \"Philips SPC 900NC webcam\";\n\t\t\ttype_id = 740;\n\t\t\tbreak;\n\t\tcase 0x032C:\n\t\t\tPWC_INFO(\"Philips SPC 880NC USB webcam detected.\\n\");\n\t\t\tname = \"Philips SPC 880NC webcam\";\n\t\t\ttype_id = 740;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\telse if (vendor_id == 0x069A) {\n\t\tswitch(product_id) {\n\t\tcase 0x0001:\n\t\t\tPWC_INFO(\"Askey VC010 type 1 USB webcam detected.\\n\");\n\t\t\tname = \"Askey VC010 webcam\";\n\t\t\ttype_id = 645;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\telse if (vendor_id == 0x046d) {\n\t\tswitch(product_id) {\n\t\tcase 0x08b0:\n\t\t\tPWC_INFO(\"Logitech QuickCam Pro 3000 USB webcam detected.\\n\");\n\t\t\tname = \"Logitech QuickCam Pro 3000\";\n\t\t\ttype_id = 740;  \n\t\t\tbreak;\n\t\tcase 0x08b1:\n\t\t\tPWC_INFO(\"Logitech QuickCam Notebook Pro USB webcam detected.\\n\");\n\t\t\tname = \"Logitech QuickCam Notebook Pro\";\n\t\t\ttype_id = 740;  \n\t\t\tbreak;\n\t\tcase 0x08b2:\n\t\t\tPWC_INFO(\"Logitech QuickCam 4000 Pro USB webcam detected.\\n\");\n\t\t\tname = \"Logitech QuickCam Pro 4000\";\n\t\t\ttype_id = 740;  \n\t\t\tif (my_power_save == -1)\n\t\t\t\tmy_power_save = 1;\n\t\t\tbreak;\n\t\tcase 0x08b3:\n\t\t\tPWC_INFO(\"Logitech QuickCam Zoom USB webcam detected.\\n\");\n\t\t\tname = \"Logitech QuickCam Zoom\";\n\t\t\ttype_id = 740;  \n\t\t\tbreak;\n\t\tcase 0x08B4:\n\t\t\tPWC_INFO(\"Logitech QuickCam Zoom (new model) USB webcam detected.\\n\");\n\t\t\tname = \"Logitech QuickCam Zoom\";\n\t\t\ttype_id = 740;  \n\t\t\tif (my_power_save == -1)\n\t\t\t\tmy_power_save = 1;\n\t\t\tbreak;\n\t\tcase 0x08b5:\n\t\t\tPWC_INFO(\"Logitech QuickCam Orbit/Sphere USB webcam detected.\\n\");\n\t\t\tname = \"Logitech QuickCam Orbit\";\n\t\t\ttype_id = 740;  \n\t\t\tif (my_power_save == -1)\n\t\t\t\tmy_power_save = 1;\n\t\t\tfeatures |= FEATURE_MOTOR_PANTILT;\n\t\t\tbreak;\n\t\tcase 0x08b6:\n\t\t\tPWC_INFO(\"Logitech/Cisco VT Camera webcam detected.\\n\");\n\t\t\tname = \"Cisco VT Camera\";\n\t\t\ttype_id = 740;  \n\t\t\tbreak;\n\t\tcase 0x08b7:\n\t\t\tPWC_INFO(\"Logitech ViewPort AV 100 webcam detected.\\n\");\n\t\t\tname = \"Logitech ViewPort AV 100\";\n\t\t\ttype_id = 740;  \n\t\t\tbreak;\n\t\tcase 0x08b8:  \n\t\t\tPWC_INFO(\"Logitech QuickCam detected (reserved ID).\\n\");\n\t\t\tname = \"Logitech QuickCam (res.)\";\n\t\t\ttype_id = 730;  \n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\telse if (vendor_id == 0x055d) {\n\t\t \n\t\tswitch(product_id) {\n\t\tcase 0x9000:\n\t\t\tPWC_INFO(\"Samsung MPC-C10 USB webcam detected.\\n\");\n\t\t\tname = \"Samsung MPC-C10\";\n\t\t\ttype_id = 675;\n\t\t\tbreak;\n\t\tcase 0x9001:\n\t\t\tPWC_INFO(\"Samsung MPC-C30 USB webcam detected.\\n\");\n\t\t\tname = \"Samsung MPC-C30\";\n\t\t\ttype_id = 675;\n\t\t\tbreak;\n\t\tcase 0x9002:\n\t\t\tPWC_INFO(\"Samsung SNC-35E (v3.0) USB webcam detected.\\n\");\n\t\t\tname = \"Samsung MPC-C30\";\n\t\t\ttype_id = 740;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\telse if (vendor_id == 0x041e) {\n\t\tswitch(product_id) {\n\t\tcase 0x400c:\n\t\t\tPWC_INFO(\"Creative Labs Webcam 5 detected.\\n\");\n\t\t\tname = \"Creative Labs Webcam 5\";\n\t\t\ttype_id = 730;\n\t\t\tif (my_power_save == -1)\n\t\t\t\tmy_power_save = 1;\n\t\t\tbreak;\n\t\tcase 0x4011:\n\t\t\tPWC_INFO(\"Creative Labs Webcam Pro Ex detected.\\n\");\n\t\t\tname = \"Creative Labs Webcam Pro Ex\";\n\t\t\ttype_id = 740;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\telse if (vendor_id == 0x04cc) {\n\t\tswitch(product_id) {\n\t\tcase 0x8116:\n\t\t\tPWC_INFO(\"Sotec Afina Eye USB webcam detected.\\n\");\n\t\t\tname = \"Sotec Afina Eye\";\n\t\t\ttype_id = 730;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\telse if (vendor_id == 0x06be) {\n\t\tswitch(product_id) {\n\t\tcase 0x8116:\n\t\t\t \n\t\t\tPWC_INFO(\"AME Co. Afina Eye USB webcam detected.\\n\");\n\t\t\tname = \"AME Co. Afina Eye\";\n\t\t\ttype_id = 750;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t}\n\telse if (vendor_id == 0x0d81) {\n\t\tswitch(product_id) {\n\t\tcase 0x1900:\n\t\t\tPWC_INFO(\"Visionite VCS-UC300 USB webcam detected.\\n\");\n\t\t\tname = \"Visionite VCS-UC300\";\n\t\t\ttype_id = 740;  \n\t\t\tbreak;\n\t\tcase 0x1910:\n\t\t\tPWC_INFO(\"Visionite VCS-UM100 USB webcam detected.\\n\");\n\t\t\tname = \"Visionite VCS-UM100\";\n\t\t\ttype_id = 730;  \n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\telse\n\t\treturn -ENODEV;  \n\n\tif (my_power_save == -1)\n\t\tmy_power_save = 0;\n\n\tmemset(serial_number, 0, 30);\n\tusb_string(udev, udev->descriptor.iSerialNumber, serial_number, 29);\n\tPWC_DEBUG_PROBE(\"Device serial number is %s\\n\", serial_number);\n\n\tif (udev->descriptor.bNumConfigurations > 1)\n\t\tPWC_WARNING(\"Warning: more than 1 configuration available.\\n\");\n\n\t \n\tpdev = kzalloc(sizeof(struct pwc_device), GFP_KERNEL);\n\tif (pdev == NULL) {\n\t\tPWC_ERROR(\"Oops, could not allocate memory for pwc_device.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tpdev->type = type_id;\n\tpdev->features = features;\n\tpwc_construct(pdev);  \n\n\tmutex_init(&pdev->v4l2_lock);\n\tmutex_init(&pdev->vb_queue_lock);\n\tspin_lock_init(&pdev->queued_bufs_lock);\n\tINIT_LIST_HEAD(&pdev->queued_bufs);\n\n\tpdev->udev = udev;\n\tpdev->power_save = my_power_save;\n\n\t \n\tpdev->vb_queue.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tpdev->vb_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\n\tpdev->vb_queue.drv_priv = pdev;\n\tpdev->vb_queue.buf_struct_size = sizeof(struct pwc_frame_buf);\n\tpdev->vb_queue.ops = &pwc_vb_queue_ops;\n\tpdev->vb_queue.mem_ops = &vb2_vmalloc_memops;\n\tpdev->vb_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\trc = vb2_queue_init(&pdev->vb_queue);\n\tif (rc < 0) {\n\t\tPWC_ERROR(\"Oops, could not initialize vb2 queue.\\n\");\n\t\tgoto err_free_mem;\n\t}\n\n\t \n\tpdev->vdev = pwc_template;\n\tstrscpy(pdev->vdev.name, name, sizeof(pdev->vdev.name));\n\tpdev->vdev.queue = &pdev->vb_queue;\n\tpdev->vdev.queue->lock = &pdev->vb_queue_lock;\n\tvideo_set_drvdata(&pdev->vdev, pdev);\n\n\tpdev->release = le16_to_cpu(udev->descriptor.bcdDevice);\n\tPWC_DEBUG_PROBE(\"Release: %04x\\n\", pdev->release);\n\n\t \n\tpdev->ctrl_buf = kmalloc(sizeof(pdev->cmd_buf), GFP_KERNEL);\n\tif (!pdev->ctrl_buf) {\n\t\tPWC_ERROR(\"Oops, could not allocate memory for pwc_device.\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n#ifdef CONFIG_USB_PWC_DEBUG\n\t \n\tif (pwc_get_cmos_sensor(pdev, &rc) >= 0) {\n\t\tPWC_DEBUG_OPEN(\"This %s camera is equipped with a %s (%d).\\n\",\n\t\t\t\tpdev->vdev.name,\n\t\t\t\tpwc_sensor_type_to_string(rc), rc);\n\t}\n#endif\n\n\t \n\tpwc_set_leds(pdev, 0, 0);\n\n\t \n\trc = pwc_set_video_mode(pdev, MAX_WIDTH, MAX_HEIGHT,\n\t\t\t\tV4L2_PIX_FMT_YUV420, 30, &compression, 1);\n\tif (rc)\n\t\tgoto err_free_mem;\n\n\t \n\trc = pwc_init_controls(pdev);\n\tif (rc) {\n\t\tPWC_ERROR(\"Failed to register v4l2 controls (%d).\\n\", rc);\n\t\tgoto err_free_mem;\n\t}\n\n\t \n\tpwc_camera_power(pdev, 0);\n\n\t \n\tpdev->v4l2_dev.release = pwc_video_release;\n\trc = v4l2_device_register(&intf->dev, &pdev->v4l2_dev);\n\tif (rc) {\n\t\tPWC_ERROR(\"Failed to register v4l2-device (%d).\\n\", rc);\n\t\tgoto err_free_controls;\n\t}\n\n\tpdev->v4l2_dev.ctrl_handler = &pdev->ctrl_handler;\n\tpdev->vdev.v4l2_dev = &pdev->v4l2_dev;\n\tpdev->vdev.lock = &pdev->v4l2_lock;\n\tpdev->vdev.device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |\n\t\t\t\t V4L2_CAP_READWRITE;\n\n\trc = video_register_device(&pdev->vdev, VFL_TYPE_VIDEO, -1);\n\tif (rc < 0) {\n\t\tPWC_ERROR(\"Failed to register as video device (%d).\\n\", rc);\n\t\tgoto err_unregister_v4l2_dev;\n\t}\n\tPWC_INFO(\"Registered as %s.\\n\", video_device_node_name(&pdev->vdev));\n\n#ifdef CONFIG_USB_PWC_INPUT_EVDEV\n\t \n\tpdev->button_dev = input_allocate_device();\n\tif (!pdev->button_dev) {\n\t\trc = -ENOMEM;\n\t\tgoto err_video_unreg;\n\t}\n\n\tusb_make_path(udev, pdev->button_phys, sizeof(pdev->button_phys));\n\tstrlcat(pdev->button_phys, \"/input0\", sizeof(pdev->button_phys));\n\n\tpdev->button_dev->name = \"PWC snapshot button\";\n\tpdev->button_dev->phys = pdev->button_phys;\n\tusb_to_input_id(pdev->udev, &pdev->button_dev->id);\n\tpdev->button_dev->dev.parent = &pdev->udev->dev;\n\tpdev->button_dev->evbit[0] = BIT_MASK(EV_KEY);\n\tpdev->button_dev->keybit[BIT_WORD(KEY_CAMERA)] = BIT_MASK(KEY_CAMERA);\n\n\trc = input_register_device(pdev->button_dev);\n\tif (rc) {\n\t\tinput_free_device(pdev->button_dev);\n\t\tpdev->button_dev = NULL;\n\t\tgoto err_video_unreg;\n\t}\n#endif\n\n\treturn 0;\n\n#ifdef CONFIG_USB_PWC_INPUT_EVDEV\nerr_video_unreg:\n\tvideo_unregister_device(&pdev->vdev);\n#endif\nerr_unregister_v4l2_dev:\n\tv4l2_device_unregister(&pdev->v4l2_dev);\nerr_free_controls:\n\tv4l2_ctrl_handler_free(&pdev->ctrl_handler);\nerr_free_mem:\n\tkfree(pdev->ctrl_buf);\n\tkfree(pdev);\n\treturn rc;\n}\n\n \nstatic void usb_pwc_disconnect(struct usb_interface *intf)\n{\n\tstruct v4l2_device *v = usb_get_intfdata(intf);\n\tstruct pwc_device *pdev = container_of(v, struct pwc_device, v4l2_dev);\n\n\tmutex_lock(&pdev->vb_queue_lock);\n\tmutex_lock(&pdev->v4l2_lock);\n\t \n\tif (pdev->vb_queue.streaming)\n\t\tpwc_isoc_cleanup(pdev);\n\tpdev->udev = NULL;\n\n\tv4l2_device_disconnect(&pdev->v4l2_dev);\n\tvideo_unregister_device(&pdev->vdev);\n\tmutex_unlock(&pdev->v4l2_lock);\n\tmutex_unlock(&pdev->vb_queue_lock);\n\n#ifdef CONFIG_USB_PWC_INPUT_EVDEV\n\tif (pdev->button_dev)\n\t\tinput_unregister_device(pdev->button_dev);\n#endif\n\n\tv4l2_device_put(&pdev->v4l2_dev);\n}\n\n\n \n\nstatic unsigned int leds_nargs;\n\n#ifdef CONFIG_USB_PWC_DEBUG\nmodule_param_named(trace, pwc_trace, int, 0644);\n#endif\nmodule_param(power_save, int, 0644);\nmodule_param_array(leds, int, &leds_nargs, 0444);\n\n#ifdef CONFIG_USB_PWC_DEBUG\nMODULE_PARM_DESC(trace, \"For debugging purposes\");\n#endif\nMODULE_PARM_DESC(power_save, \"Turn power saving for new cameras on or off\");\nMODULE_PARM_DESC(leds, \"LED on,off time in milliseconds\");\n\nMODULE_DESCRIPTION(\"Philips & OEM USB webcam driver\");\nMODULE_AUTHOR(\"Luc Saillard <luc@saillard.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"pwcx\");\nMODULE_VERSION( PWC_VERSION );\n\nmodule_usb_driver(pwc_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}