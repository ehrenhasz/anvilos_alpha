{
  "module_name": "pwc-v4l.c",
  "hash_id": "63a27e249c4cf6bb6b3a2d16370e257383641cc92b50e3ac3d0ae66300250a43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/pwc/pwc-v4l.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/poll.h>\n#include <linux/vmalloc.h>\n#include <linux/jiffies.h>\n#include <asm/io.h>\n\n#include \"pwc.h\"\n\n#define PWC_CID_CUSTOM(ctrl) ((V4L2_CID_USER_BASE | 0xf000) + custom_ ## ctrl)\n\nstatic int pwc_g_volatile_ctrl(struct v4l2_ctrl *ctrl);\nstatic int pwc_s_ctrl(struct v4l2_ctrl *ctrl);\n\nstatic const struct v4l2_ctrl_ops pwc_ctrl_ops = {\n\t.g_volatile_ctrl = pwc_g_volatile_ctrl,\n\t.s_ctrl = pwc_s_ctrl,\n};\n\nenum { awb_indoor, awb_outdoor, awb_fl, awb_manual, awb_auto };\nenum { custom_autocontour, custom_contour, custom_noise_reduction,\n\tcustom_awb_speed, custom_awb_delay,\n\tcustom_save_user, custom_restore_user, custom_restore_factory };\n\nstatic const char * const pwc_auto_whitebal_qmenu[] = {\n\t\"Indoor (Incandescant Lighting) Mode\",\n\t\"Outdoor (Sunlight) Mode\",\n\t\"Indoor (Fluorescent Lighting) Mode\",\n\t\"Manual Mode\",\n\t\"Auto Mode\",\n\tNULL\n};\n\nstatic const struct v4l2_ctrl_config pwc_auto_white_balance_cfg = {\n\t.ops\t= &pwc_ctrl_ops,\n\t.id\t= V4L2_CID_AUTO_WHITE_BALANCE,\n\t.type\t= V4L2_CTRL_TYPE_MENU,\n\t.max\t= awb_auto,\n\t.qmenu\t= pwc_auto_whitebal_qmenu,\n};\n\nstatic const struct v4l2_ctrl_config pwc_autocontour_cfg = {\n\t.ops\t= &pwc_ctrl_ops,\n\t.id\t= PWC_CID_CUSTOM(autocontour),\n\t.type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t.name\t= \"Auto contour\",\n\t.min\t= 0,\n\t.max\t= 1,\n\t.step\t= 1,\n};\n\nstatic const struct v4l2_ctrl_config pwc_contour_cfg = {\n\t.ops\t= &pwc_ctrl_ops,\n\t.id\t= PWC_CID_CUSTOM(contour),\n\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t.name\t= \"Contour\",\n\t.flags  = V4L2_CTRL_FLAG_SLIDER,\n\t.min\t= 0,\n\t.max\t= 63,\n\t.step\t= 1,\n};\n\nstatic const struct v4l2_ctrl_config pwc_backlight_cfg = {\n\t.ops\t= &pwc_ctrl_ops,\n\t.id\t= V4L2_CID_BACKLIGHT_COMPENSATION,\n\t.type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t.min\t= 0,\n\t.max\t= 1,\n\t.step\t= 1,\n};\n\nstatic const struct v4l2_ctrl_config pwc_flicker_cfg = {\n\t.ops\t= &pwc_ctrl_ops,\n\t.id\t= V4L2_CID_BAND_STOP_FILTER,\n\t.type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t.min\t= 0,\n\t.max\t= 1,\n\t.step\t= 1,\n};\n\nstatic const struct v4l2_ctrl_config pwc_noise_reduction_cfg = {\n\t.ops\t= &pwc_ctrl_ops,\n\t.id\t= PWC_CID_CUSTOM(noise_reduction),\n\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t.name\t= \"Dynamic Noise Reduction\",\n\t.min\t= 0,\n\t.max\t= 3,\n\t.step\t= 1,\n};\n\nstatic const struct v4l2_ctrl_config pwc_save_user_cfg = {\n\t.ops\t= &pwc_ctrl_ops,\n\t.id\t= PWC_CID_CUSTOM(save_user),\n\t.type\t= V4L2_CTRL_TYPE_BUTTON,\n\t.name    = \"Save User Settings\",\n};\n\nstatic const struct v4l2_ctrl_config pwc_restore_user_cfg = {\n\t.ops\t= &pwc_ctrl_ops,\n\t.id\t= PWC_CID_CUSTOM(restore_user),\n\t.type\t= V4L2_CTRL_TYPE_BUTTON,\n\t.name    = \"Restore User Settings\",\n};\n\nstatic const struct v4l2_ctrl_config pwc_restore_factory_cfg = {\n\t.ops\t= &pwc_ctrl_ops,\n\t.id\t= PWC_CID_CUSTOM(restore_factory),\n\t.type\t= V4L2_CTRL_TYPE_BUTTON,\n\t.name    = \"Restore Factory Settings\",\n};\n\nstatic const struct v4l2_ctrl_config pwc_awb_speed_cfg = {\n\t.ops\t= &pwc_ctrl_ops,\n\t.id\t= PWC_CID_CUSTOM(awb_speed),\n\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t.name\t= \"Auto White Balance Speed\",\n\t.min\t= 1,\n\t.max\t= 32,\n\t.step\t= 1,\n};\n\nstatic const struct v4l2_ctrl_config pwc_awb_delay_cfg = {\n\t.ops\t= &pwc_ctrl_ops,\n\t.id\t= PWC_CID_CUSTOM(awb_delay),\n\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t.name\t= \"Auto White Balance Delay\",\n\t.min\t= 0,\n\t.max\t= 63,\n\t.step\t= 1,\n};\n\nint pwc_init_controls(struct pwc_device *pdev)\n{\n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct v4l2_ctrl_config cfg;\n\tint r, def;\n\n\thdl = &pdev->ctrl_handler;\n\tr = v4l2_ctrl_handler_init(hdl, 20);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = pwc_get_u8_ctrl(pdev, GET_LUM_CTL, BRIGHTNESS_FORMATTER, &def);\n\tif (r || def > 127)\n\t\tdef = 63;\n\tpdev->brightness = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,\n\t\t\t\tV4L2_CID_BRIGHTNESS, 0, 127, 1, def);\n\n\tr = pwc_get_u8_ctrl(pdev, GET_LUM_CTL, CONTRAST_FORMATTER, &def);\n\tif (r || def > 63)\n\t\tdef = 31;\n\tpdev->contrast = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,\n\t\t\t\tV4L2_CID_CONTRAST, 0, 63, 1, def);\n\n\tif (pdev->type >= 675) {\n\t\tif (pdev->type < 730)\n\t\t\tpdev->saturation_fmt = SATURATION_MODE_FORMATTER2;\n\t\telse\n\t\t\tpdev->saturation_fmt = SATURATION_MODE_FORMATTER1;\n\t\tr = pwc_get_s8_ctrl(pdev, GET_CHROM_CTL, pdev->saturation_fmt,\n\t\t\t\t    &def);\n\t\tif (r || def < -100 || def > 100)\n\t\t\tdef = 0;\n\t\tpdev->saturation = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,\n\t\t\t\t      V4L2_CID_SATURATION, -100, 100, 1, def);\n\t}\n\n\tr = pwc_get_u8_ctrl(pdev, GET_LUM_CTL, GAMMA_FORMATTER, &def);\n\tif (r || def > 31)\n\t\tdef = 15;\n\tpdev->gamma = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,\n\t\t\t\tV4L2_CID_GAMMA, 0, 31, 1, def);\n\n\t \n\tr = pwc_get_u8_ctrl(pdev, GET_CHROM_CTL, WB_MODE_FORMATTER, &def);\n\tif (r || def > awb_auto)\n\t\tdef = awb_auto;\n\tcfg = pwc_auto_white_balance_cfg;\n\tcfg.name = v4l2_ctrl_get_name(cfg.id);\n\tcfg.def = def;\n\tpdev->auto_white_balance = v4l2_ctrl_new_custom(hdl, &cfg, NULL);\n\t \n\tif (!pdev->auto_white_balance)\n\t\treturn hdl->error;\n\n\tr = pwc_get_u8_ctrl(pdev, GET_CHROM_CTL,\n\t\t\t    PRESET_MANUAL_RED_GAIN_FORMATTER, &def);\n\tif (r)\n\t\tdef = 127;\n\tpdev->red_balance = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,\n\t\t\t\tV4L2_CID_RED_BALANCE, 0, 255, 1, def);\n\n\tr = pwc_get_u8_ctrl(pdev, GET_CHROM_CTL,\n\t\t\t    PRESET_MANUAL_BLUE_GAIN_FORMATTER, &def);\n\tif (r)\n\t\tdef = 127;\n\tpdev->blue_balance = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,\n\t\t\t\tV4L2_CID_BLUE_BALANCE, 0, 255, 1, def);\n\n\tv4l2_ctrl_auto_cluster(3, &pdev->auto_white_balance, awb_manual, true);\n\n\t \n\tr = pwc_get_u8_ctrl(pdev, GET_LUM_CTL, AGC_MODE_FORMATTER, &def);\n\tif (r || (def != 0 && def != 0xff))\n\t\tdef = 0;\n\t \n\tpdev->autogain = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,\n\t\t\t\tV4L2_CID_AUTOGAIN, 0, 1, 1, def == 0);\n\tif (!pdev->autogain)\n\t\treturn hdl->error;\n\n\tr = pwc_get_u8_ctrl(pdev, GET_LUM_CTL, PRESET_AGC_FORMATTER, &def);\n\tif (r || def > 63)\n\t\tdef = 31;\n\tpdev->gain = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,\n\t\t\t\tV4L2_CID_GAIN, 0, 63, 1, def);\n\n\t \n\tif (DEVICE_USE_CODEC2(pdev->type)) {\n\t\tr = pwc_get_u8_ctrl(pdev, GET_LUM_CTL, SHUTTER_MODE_FORMATTER,\n\t\t\t\t    &def);\n\t\tif (r || (def != 0 && def != 0xff))\n\t\t\tdef = 0;\n\t\t \n\t\tpdev->exposure_auto = v4l2_ctrl_new_std_menu(hdl,\n\t\t\t\t\t&pwc_ctrl_ops,\n\t\t\t\t\tV4L2_CID_EXPOSURE_AUTO,\n\t\t\t\t\t1, 0, def != 0);\n\t\tif (!pdev->exposure_auto)\n\t\t\treturn hdl->error;\n\n\t\t \n\t\tr = pwc_get_u16_ctrl(pdev, GET_STATUS_CTL,\n\t\t\t\t     READ_SHUTTER_FORMATTER, &def);\n\t\tif (r || def > 655)\n\t\t\tdef = 655;\n\t\tpdev->exposure = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,\n\t\t\t\t\tV4L2_CID_EXPOSURE, 0, 655, 1, def);\n\t\t \n\t\tv4l2_ctrl_auto_cluster(2, &pdev->autogain, 0, true);\n\t\tv4l2_ctrl_auto_cluster(2, &pdev->exposure_auto,\n\t\t\t\t       V4L2_EXPOSURE_MANUAL, true);\n\t} else if (DEVICE_USE_CODEC3(pdev->type)) {\n\t\t \n\t\tr = pwc_get_u16_ctrl(pdev, GET_STATUS_CTL,\n\t\t\t\t     READ_SHUTTER_FORMATTER, &def);\n\t\tif (r || def > 255)\n\t\t\tdef = 255;\n\t\tpdev->exposure = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,\n\t\t\t\t\tV4L2_CID_EXPOSURE, 0, 255, 1, def);\n\t\t \n\t\tpdev->autogain_expo_cluster[0] = pdev->autogain;\n\t\tpdev->autogain_expo_cluster[1] = pdev->gain;\n\t\tpdev->autogain_expo_cluster[2] = pdev->exposure;\n\t\tv4l2_ctrl_auto_cluster(3, pdev->autogain_expo_cluster,\n\t\t\t\t       0, true);\n\t}\n\n\t \n\tr = pwc_get_u8_ctrl(pdev, GET_CHROM_CTL, COLOUR_MODE_FORMATTER,\n\t\t\t &def);\n\tif (r || (def != 0 && def != 0xff))\n\t\tdef = 0xff;\n\t \n\tpdev->colorfx = v4l2_ctrl_new_std_menu(hdl, &pwc_ctrl_ops,\n\t\t\t\tV4L2_CID_COLORFX, 1, 0, def == 0);\n\n\t \n\tr = pwc_get_u8_ctrl(pdev, GET_LUM_CTL, AUTO_CONTOUR_FORMATTER, &def);\n\tif (r || (def != 0 && def != 0xff))\n\t\tdef = 0;\n\tcfg = pwc_autocontour_cfg;\n\tcfg.def = def == 0;\n\tpdev->autocontour = v4l2_ctrl_new_custom(hdl, &cfg, NULL);\n\tif (!pdev->autocontour)\n\t\treturn hdl->error;\n\n\tr = pwc_get_u8_ctrl(pdev, GET_LUM_CTL, PRESET_CONTOUR_FORMATTER, &def);\n\tif (r || def > 63)\n\t\tdef = 31;\n\tcfg = pwc_contour_cfg;\n\tcfg.def = def;\n\tpdev->contour = v4l2_ctrl_new_custom(hdl, &cfg, NULL);\n\n\tv4l2_ctrl_auto_cluster(2, &pdev->autocontour, 0, false);\n\n\t \n\tr = pwc_get_u8_ctrl(pdev, GET_LUM_CTL,\n\t\t\t    BACK_LIGHT_COMPENSATION_FORMATTER, &def);\n\tif (r || (def != 0 && def != 0xff))\n\t\tdef = 0;\n\tcfg = pwc_backlight_cfg;\n\tcfg.name = v4l2_ctrl_get_name(cfg.id);\n\tcfg.def = def == 0;\n\tpdev->backlight = v4l2_ctrl_new_custom(hdl, &cfg, NULL);\n\n\t \n\tr = pwc_get_u8_ctrl(pdev, GET_LUM_CTL,\n\t\t\t    FLICKERLESS_MODE_FORMATTER, &def);\n\tif (r || (def != 0 && def != 0xff))\n\t\tdef = 0;\n\tcfg = pwc_flicker_cfg;\n\tcfg.name = v4l2_ctrl_get_name(cfg.id);\n\tcfg.def = def == 0;\n\tpdev->flicker = v4l2_ctrl_new_custom(hdl, &cfg, NULL);\n\n\t \n\tr = pwc_get_u8_ctrl(pdev, GET_LUM_CTL,\n\t\t\t    DYNAMIC_NOISE_CONTROL_FORMATTER, &def);\n\tif (r || def > 3)\n\t\tdef = 2;\n\tcfg = pwc_noise_reduction_cfg;\n\tcfg.def = def;\n\tpdev->noise_reduction = v4l2_ctrl_new_custom(hdl, &cfg, NULL);\n\n\t \n\tpdev->save_user = v4l2_ctrl_new_custom(hdl, &pwc_save_user_cfg, NULL);\n\tpdev->restore_user = v4l2_ctrl_new_custom(hdl, &pwc_restore_user_cfg,\n\t\t\t\t\t\t  NULL);\n\tif (pdev->restore_user)\n\t\tpdev->restore_user->flags |= V4L2_CTRL_FLAG_UPDATE;\n\tpdev->restore_factory = v4l2_ctrl_new_custom(hdl,\n\t\t\t\t\t\t     &pwc_restore_factory_cfg,\n\t\t\t\t\t\t     NULL);\n\tif (pdev->restore_factory)\n\t\tpdev->restore_factory->flags |= V4L2_CTRL_FLAG_UPDATE;\n\n\t \n\tr = pwc_get_u8_ctrl(pdev, GET_CHROM_CTL,\n\t\t\t    AWB_CONTROL_SPEED_FORMATTER, &def);\n\tif (r || def < 1 || def > 32)\n\t\tdef = 1;\n\tcfg = pwc_awb_speed_cfg;\n\tcfg.def = def;\n\tpdev->awb_speed = v4l2_ctrl_new_custom(hdl, &cfg, NULL);\n\n\tr = pwc_get_u8_ctrl(pdev, GET_CHROM_CTL,\n\t\t\t    AWB_CONTROL_DELAY_FORMATTER, &def);\n\tif (r || def > 63)\n\t\tdef = 0;\n\tcfg = pwc_awb_delay_cfg;\n\tcfg.def = def;\n\tpdev->awb_delay = v4l2_ctrl_new_custom(hdl, &cfg, NULL);\n\n\tif (!(pdev->features & FEATURE_MOTOR_PANTILT))\n\t\treturn hdl->error;\n\n\t \n\tpdev->motor_pan = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,\n\t\t\t\tV4L2_CID_PAN_RELATIVE, -4480, 4480, 64, 0);\n\tif (!pdev->motor_pan)\n\t\treturn hdl->error;\n\tpdev->motor_tilt = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,\n\t\t\t\tV4L2_CID_TILT_RELATIVE, -1920, 1920, 64, 0);\n\tpdev->motor_pan_reset = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,\n\t\t\t\tV4L2_CID_PAN_RESET, 0, 0, 0, 0);\n\tpdev->motor_tilt_reset = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,\n\t\t\t\tV4L2_CID_TILT_RESET, 0, 0, 0, 0);\n\tv4l2_ctrl_cluster(4, &pdev->motor_pan);\n\n\treturn hdl->error;\n}\n\nstatic void pwc_vidioc_fill_fmt(struct v4l2_format *f,\n\tint width, int height, u32 pixfmt)\n{\n\tmemset(&f->fmt.pix, 0, sizeof(struct v4l2_pix_format));\n\tf->fmt.pix.width        = width;\n\tf->fmt.pix.height       = height;\n\tf->fmt.pix.field        = V4L2_FIELD_NONE;\n\tf->fmt.pix.pixelformat  = pixfmt;\n\tf->fmt.pix.bytesperline = f->fmt.pix.width;\n\tf->fmt.pix.sizeimage\t= f->fmt.pix.height * f->fmt.pix.width * 3 / 2;\n\tf->fmt.pix.colorspace\t= V4L2_COLORSPACE_SRGB;\n\tPWC_DEBUG_IOCTL(\"pwc_vidioc_fill_fmt() width=%d, height=%d, bytesperline=%d, sizeimage=%d, pixelformat=%c%c%c%c\\n\",\n\t\t\tf->fmt.pix.width,\n\t\t\tf->fmt.pix.height,\n\t\t\tf->fmt.pix.bytesperline,\n\t\t\tf->fmt.pix.sizeimage,\n\t\t\t(f->fmt.pix.pixelformat)&255,\n\t\t\t(f->fmt.pix.pixelformat>>8)&255,\n\t\t\t(f->fmt.pix.pixelformat>>16)&255,\n\t\t\t(f->fmt.pix.pixelformat>>24)&255);\n}\n\n \nstatic int pwc_vidioc_try_fmt(struct pwc_device *pdev, struct v4l2_format *f)\n{\n\tint size;\n\n\tif (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tPWC_DEBUG_IOCTL(\"Bad video type must be V4L2_BUF_TYPE_VIDEO_CAPTURE\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (f->fmt.pix.pixelformat) {\n\t\tcase V4L2_PIX_FMT_YUV420:\n\t\t\tbreak;\n\t\tcase V4L2_PIX_FMT_PWC1:\n\t\t\tif (DEVICE_USE_CODEC23(pdev->type)) {\n\t\t\t\tPWC_DEBUG_IOCTL(\"codec1 is only supported for old pwc webcam\\n\");\n\t\t\t\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_YUV420;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase V4L2_PIX_FMT_PWC2:\n\t\t\tif (DEVICE_USE_CODEC1(pdev->type)) {\n\t\t\t\tPWC_DEBUG_IOCTL(\"codec23 is only supported for new pwc webcam\\n\");\n\t\t\t\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_YUV420;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPWC_DEBUG_IOCTL(\"Unsupported pixel format\\n\");\n\t\t\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_YUV420;\n\t}\n\n\tsize = pwc_get_size(pdev, f->fmt.pix.width, f->fmt.pix.height);\n\tpwc_vidioc_fill_fmt(f,\n\t\t\t    pwc_image_sizes[size][0],\n\t\t\t    pwc_image_sizes[size][1],\n\t\t\t    f->fmt.pix.pixelformat);\n\n\treturn 0;\n}\n\n \n\nstatic int pwc_s_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct pwc_device *pdev = video_drvdata(file);\n\tint ret, pixelformat, compression = 0;\n\n\tret = pwc_vidioc_try_fmt(pdev, f);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (vb2_is_busy(&pdev->vb_queue))\n\t\treturn -EBUSY;\n\n\tpixelformat = f->fmt.pix.pixelformat;\n\n\tPWC_DEBUG_IOCTL(\"Trying to set format to: width=%d height=%d fps=%d format=%c%c%c%c\\n\",\n\t\t\tf->fmt.pix.width, f->fmt.pix.height, pdev->vframes,\n\t\t\t(pixelformat)&255,\n\t\t\t(pixelformat>>8)&255,\n\t\t\t(pixelformat>>16)&255,\n\t\t\t(pixelformat>>24)&255);\n\n\tret = pwc_set_video_mode(pdev, f->fmt.pix.width, f->fmt.pix.height,\n\t\t\t\t pixelformat, 30, &compression, 0);\n\n\tPWC_DEBUG_IOCTL(\"pwc_set_video_mode(), return=%d\\n\", ret);\n\n\tpwc_vidioc_fill_fmt(f, pdev->width, pdev->height, pdev->pixfmt);\n\treturn ret;\n}\n\nstatic int pwc_querycap(struct file *file, void *fh, struct v4l2_capability *cap)\n{\n\tstruct pwc_device *pdev = video_drvdata(file);\n\n\tstrscpy(cap->driver, PWC_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, pdev->vdev.name, sizeof(cap->card));\n\tusb_make_path(pdev->udev, cap->bus_info, sizeof(cap->bus_info));\n\treturn 0;\n}\n\nstatic int pwc_enum_input(struct file *file, void *fh, struct v4l2_input *i)\n{\n\tif (i->index)\t \n\t\treturn -EINVAL;\n\n\tstrscpy(i->name, \"Camera\", sizeof(i->name));\n\ti->type = V4L2_INPUT_TYPE_CAMERA;\n\treturn 0;\n}\n\nstatic int pwc_g_input(struct file *file, void *fh, unsigned int *i)\n{\n\t*i = 0;\n\treturn 0;\n}\n\nstatic int pwc_s_input(struct file *file, void *fh, unsigned int i)\n{\n\treturn i ? -EINVAL : 0;\n}\n\nstatic int pwc_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct pwc_device *pdev =\n\t\tcontainer_of(ctrl->handler, struct pwc_device, ctrl_handler);\n\tint ret = 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\tif (pdev->color_bal_valid &&\n\t\t\t(pdev->auto_white_balance->val != awb_auto ||\n\t\t\t time_before(jiffies,\n\t\t\t\tpdev->last_color_bal_update + HZ / 4))) {\n\t\t\tpdev->red_balance->val  = pdev->last_red_balance;\n\t\t\tpdev->blue_balance->val = pdev->last_blue_balance;\n\t\t\tbreak;\n\t\t}\n\t\tret = pwc_get_u8_ctrl(pdev, GET_STATUS_CTL,\n\t\t\t\t      READ_RED_GAIN_FORMATTER,\n\t\t\t\t      &pdev->red_balance->val);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = pwc_get_u8_ctrl(pdev, GET_STATUS_CTL,\n\t\t\t\t      READ_BLUE_GAIN_FORMATTER,\n\t\t\t\t      &pdev->blue_balance->val);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tpdev->last_red_balance  = pdev->red_balance->val;\n\t\tpdev->last_blue_balance = pdev->blue_balance->val;\n\t\tpdev->last_color_bal_update = jiffies;\n\t\tpdev->color_bal_valid = true;\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\tif (pdev->gain_valid && time_before(jiffies,\n\t\t\t\tpdev->last_gain_update + HZ / 4)) {\n\t\t\tpdev->gain->val = pdev->last_gain;\n\t\t\tbreak;\n\t\t}\n\t\tret = pwc_get_u8_ctrl(pdev, GET_STATUS_CTL,\n\t\t\t\t      READ_AGC_FORMATTER, &pdev->gain->val);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tpdev->last_gain = pdev->gain->val;\n\t\tpdev->last_gain_update = jiffies;\n\t\tpdev->gain_valid = true;\n\t\tif (!DEVICE_USE_CODEC3(pdev->type))\n\t\t\tbreak;\n\t\t \n\t\tfallthrough;\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tif (pdev->exposure_valid && time_before(jiffies,\n\t\t\t\tpdev->last_exposure_update + HZ / 4)) {\n\t\t\tpdev->exposure->val = pdev->last_exposure;\n\t\t\tbreak;\n\t\t}\n\t\tret = pwc_get_u16_ctrl(pdev, GET_STATUS_CTL,\n\t\t\t\t       READ_SHUTTER_FORMATTER,\n\t\t\t\t       &pdev->exposure->val);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tpdev->last_exposure = pdev->exposure->val;\n\t\tpdev->last_exposure_update = jiffies;\n\t\tpdev->exposure_valid = true;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\tPWC_ERROR(\"g_ctrl %s error %d\\n\", ctrl->name, ret);\n\n\treturn ret;\n}\n\nstatic int pwc_set_awb(struct pwc_device *pdev)\n{\n\tint ret;\n\n\tif (pdev->auto_white_balance->is_new) {\n\t\tret = pwc_set_u8_ctrl(pdev, SET_CHROM_CTL,\n\t\t\t\t      WB_MODE_FORMATTER,\n\t\t\t\t      pdev->auto_white_balance->val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (pdev->auto_white_balance->val != awb_manual)\n\t\t\tpdev->color_bal_valid = false;  \n\n\t\t \n\t\tif (pdev->auto_white_balance->val == awb_indoor ||\n\t\t    pdev->auto_white_balance->val == awb_outdoor ||\n\t\t    pdev->auto_white_balance->val == awb_fl)\n\t\t\tpwc_g_volatile_ctrl(pdev->auto_white_balance);\n\t}\n\tif (pdev->auto_white_balance->val != awb_manual)\n\t\treturn 0;\n\n\tif (pdev->red_balance->is_new) {\n\t\tret = pwc_set_u8_ctrl(pdev, SET_CHROM_CTL,\n\t\t\t\t      PRESET_MANUAL_RED_GAIN_FORMATTER,\n\t\t\t\t      pdev->red_balance->val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (pdev->blue_balance->is_new) {\n\t\tret = pwc_set_u8_ctrl(pdev, SET_CHROM_CTL,\n\t\t\t\t      PRESET_MANUAL_BLUE_GAIN_FORMATTER,\n\t\t\t\t      pdev->blue_balance->val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nstatic int pwc_set_autogain(struct pwc_device *pdev)\n{\n\tint ret;\n\n\tif (pdev->autogain->is_new) {\n\t\tret = pwc_set_u8_ctrl(pdev, SET_LUM_CTL,\n\t\t\t\t      AGC_MODE_FORMATTER,\n\t\t\t\t      pdev->autogain->val ? 0 : 0xff);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (pdev->autogain->val)\n\t\t\tpdev->gain_valid = false;  \n\t}\n\n\tif (pdev->autogain->val)\n\t\treturn 0;\n\n\tif (pdev->gain->is_new) {\n\t\tret = pwc_set_u8_ctrl(pdev, SET_LUM_CTL,\n\t\t\t\t      PRESET_AGC_FORMATTER,\n\t\t\t\t      pdev->gain->val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nstatic int pwc_set_exposure_auto(struct pwc_device *pdev)\n{\n\tint ret;\n\tint is_auto = pdev->exposure_auto->val == V4L2_EXPOSURE_AUTO;\n\n\tif (pdev->exposure_auto->is_new) {\n\t\tret = pwc_set_u8_ctrl(pdev, SET_LUM_CTL,\n\t\t\t\t      SHUTTER_MODE_FORMATTER,\n\t\t\t\t      is_auto ? 0 : 0xff);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (is_auto)\n\t\t\tpdev->exposure_valid = false;  \n\t}\n\n\tif (is_auto)\n\t\treturn 0;\n\n\tif (pdev->exposure->is_new) {\n\t\tret = pwc_set_u16_ctrl(pdev, SET_LUM_CTL,\n\t\t\t\t       PRESET_SHUTTER_FORMATTER,\n\t\t\t\t       pdev->exposure->val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nstatic int pwc_set_autogain_expo(struct pwc_device *pdev)\n{\n\tint ret;\n\n\tif (pdev->autogain->is_new) {\n\t\tret = pwc_set_u8_ctrl(pdev, SET_LUM_CTL,\n\t\t\t\t      AGC_MODE_FORMATTER,\n\t\t\t\t      pdev->autogain->val ? 0 : 0xff);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (pdev->autogain->val) {\n\t\t\tpdev->gain_valid     = false;  \n\t\t\tpdev->exposure_valid = false;  \n\t\t}\n\t}\n\n\tif (pdev->autogain->val)\n\t\treturn 0;\n\n\tif (pdev->gain->is_new) {\n\t\tret = pwc_set_u8_ctrl(pdev, SET_LUM_CTL,\n\t\t\t\t      PRESET_AGC_FORMATTER,\n\t\t\t\t      pdev->gain->val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (pdev->exposure->is_new) {\n\t\tret = pwc_set_u16_ctrl(pdev, SET_LUM_CTL,\n\t\t\t\t       PRESET_SHUTTER_FORMATTER,\n\t\t\t\t       pdev->exposure->val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int pwc_set_motor(struct pwc_device *pdev)\n{\n\tint ret;\n\n\tpdev->ctrl_buf[0] = 0;\n\tif (pdev->motor_pan_reset->is_new)\n\t\tpdev->ctrl_buf[0] |= 0x01;\n\tif (pdev->motor_tilt_reset->is_new)\n\t\tpdev->ctrl_buf[0] |= 0x02;\n\tif (pdev->motor_pan_reset->is_new || pdev->motor_tilt_reset->is_new) {\n\t\tret = send_control_msg(pdev, SET_MPT_CTL,\n\t\t\t\t       PT_RESET_CONTROL_FORMATTER,\n\t\t\t\t       pdev->ctrl_buf, 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tmemset(pdev->ctrl_buf, 0, 4);\n\tif (pdev->motor_pan->is_new) {\n\t\tpdev->ctrl_buf[0] = pdev->motor_pan->val & 0xFF;\n\t\tpdev->ctrl_buf[1] = (pdev->motor_pan->val >> 8);\n\t}\n\tif (pdev->motor_tilt->is_new) {\n\t\tpdev->ctrl_buf[2] = pdev->motor_tilt->val & 0xFF;\n\t\tpdev->ctrl_buf[3] = (pdev->motor_tilt->val >> 8);\n\t}\n\tif (pdev->motor_pan->is_new || pdev->motor_tilt->is_new) {\n\t\tret = send_control_msg(pdev, SET_MPT_CTL,\n\t\t\t\t       PT_RELATIVE_CONTROL_FORMATTER,\n\t\t\t\t       pdev->ctrl_buf, 4);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int pwc_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct pwc_device *pdev =\n\t\tcontainer_of(ctrl->handler, struct pwc_device, ctrl_handler);\n\tint ret = 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tret = pwc_set_u8_ctrl(pdev, SET_LUM_CTL,\n\t\t\t\t      BRIGHTNESS_FORMATTER, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tret = pwc_set_u8_ctrl(pdev, SET_LUM_CTL,\n\t\t\t\t      CONTRAST_FORMATTER, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tret = pwc_set_s8_ctrl(pdev, SET_CHROM_CTL,\n\t\t\t\t      pdev->saturation_fmt, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_GAMMA:\n\t\tret = pwc_set_u8_ctrl(pdev, SET_LUM_CTL,\n\t\t\t\t      GAMMA_FORMATTER, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\tret = pwc_set_awb(pdev);\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\tif (DEVICE_USE_CODEC2(pdev->type))\n\t\t\tret = pwc_set_autogain(pdev);\n\t\telse if (DEVICE_USE_CODEC3(pdev->type))\n\t\t\tret = pwc_set_autogain_expo(pdev);\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tif (DEVICE_USE_CODEC2(pdev->type))\n\t\t\tret = pwc_set_exposure_auto(pdev);\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase V4L2_CID_COLORFX:\n\t\tret = pwc_set_u8_ctrl(pdev, SET_CHROM_CTL,\n\t\t\t\t      COLOUR_MODE_FORMATTER,\n\t\t\t\t      ctrl->val ? 0 : 0xff);\n\t\tbreak;\n\tcase PWC_CID_CUSTOM(autocontour):\n\t\tif (pdev->autocontour->is_new) {\n\t\t\tret = pwc_set_u8_ctrl(pdev, SET_LUM_CTL,\n\t\t\t\t\tAUTO_CONTOUR_FORMATTER,\n\t\t\t\t\tpdev->autocontour->val ? 0 : 0xff);\n\t\t}\n\t\tif (ret == 0 && pdev->contour->is_new) {\n\t\t\tret = pwc_set_u8_ctrl(pdev, SET_LUM_CTL,\n\t\t\t\t\t      PRESET_CONTOUR_FORMATTER,\n\t\t\t\t\t      pdev->contour->val);\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_BACKLIGHT_COMPENSATION:\n\t\tret = pwc_set_u8_ctrl(pdev, SET_LUM_CTL,\n\t\t\t\t      BACK_LIGHT_COMPENSATION_FORMATTER,\n\t\t\t\t      ctrl->val ? 0 : 0xff);\n\t\tbreak;\n\tcase V4L2_CID_BAND_STOP_FILTER:\n\t\tret = pwc_set_u8_ctrl(pdev, SET_LUM_CTL,\n\t\t\t\t      FLICKERLESS_MODE_FORMATTER,\n\t\t\t\t      ctrl->val ? 0 : 0xff);\n\t\tbreak;\n\tcase PWC_CID_CUSTOM(noise_reduction):\n\t\tret = pwc_set_u8_ctrl(pdev, SET_LUM_CTL,\n\t\t\t\t      DYNAMIC_NOISE_CONTROL_FORMATTER,\n\t\t\t\t      ctrl->val);\n\t\tbreak;\n\tcase PWC_CID_CUSTOM(save_user):\n\t\tret = pwc_button_ctrl(pdev, SAVE_USER_DEFAULTS_FORMATTER);\n\t\tbreak;\n\tcase PWC_CID_CUSTOM(restore_user):\n\t\tret = pwc_button_ctrl(pdev, RESTORE_USER_DEFAULTS_FORMATTER);\n\t\tbreak;\n\tcase PWC_CID_CUSTOM(restore_factory):\n\t\tret = pwc_button_ctrl(pdev,\n\t\t\t\t      RESTORE_FACTORY_DEFAULTS_FORMATTER);\n\t\tbreak;\n\tcase PWC_CID_CUSTOM(awb_speed):\n\t\tret = pwc_set_u8_ctrl(pdev, SET_CHROM_CTL,\n\t\t\t\t      AWB_CONTROL_SPEED_FORMATTER,\n\t\t\t\t      ctrl->val);\n\t\tbreak;\n\tcase PWC_CID_CUSTOM(awb_delay):\n\t\tret = pwc_set_u8_ctrl(pdev, SET_CHROM_CTL,\n\t\t\t\t      AWB_CONTROL_DELAY_FORMATTER,\n\t\t\t\t      ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_PAN_RELATIVE:\n\t\tret = pwc_set_motor(pdev);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\tPWC_ERROR(\"s_ctrl %s error %d\\n\", ctrl->name, ret);\n\n\treturn ret;\n}\n\nstatic int pwc_enum_fmt_vid_cap(struct file *file, void *fh, struct v4l2_fmtdesc *f)\n{\n\tstruct pwc_device *pdev = video_drvdata(file);\n\n\t \n\tswitch (f->index) {\n\tcase 0:\n\t\t \n\t\tf->pixelformat = pdev->type <= 646 ? V4L2_PIX_FMT_PWC1 : V4L2_PIX_FMT_PWC2;\n\t\tbreak;\n\tcase 1:\n\t\tf->pixelformat = V4L2_PIX_FMT_YUV420;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int pwc_g_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct pwc_device *pdev = video_drvdata(file);\n\n\tif (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tPWC_DEBUG_IOCTL(\"ioctl(VIDIOC_G_FMT) return size %dx%d\\n\",\n\t\t\tpdev->width, pdev->height);\n\tpwc_vidioc_fill_fmt(f, pdev->width, pdev->height, pdev->pixfmt);\n\treturn 0;\n}\n\nstatic int pwc_try_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct pwc_device *pdev = video_drvdata(file);\n\n\treturn pwc_vidioc_try_fmt(pdev, f);\n}\n\nstatic int pwc_enum_framesizes(struct file *file, void *fh,\n\t\t\t\t\t struct v4l2_frmsizeenum *fsize)\n{\n\tstruct pwc_device *pdev = video_drvdata(file);\n\tunsigned int i = 0, index = fsize->index;\n\n\tif (fsize->pixel_format == V4L2_PIX_FMT_YUV420 ||\n\t    (fsize->pixel_format == V4L2_PIX_FMT_PWC1 &&\n\t\t\tDEVICE_USE_CODEC1(pdev->type)) ||\n\t    (fsize->pixel_format == V4L2_PIX_FMT_PWC2 &&\n\t\t\tDEVICE_USE_CODEC23(pdev->type))) {\n\t\tfor (i = 0; i < PSZ_MAX; i++) {\n\t\t\tif (!(pdev->image_mask & (1UL << i)))\n\t\t\t\tcontinue;\n\t\t\tif (!index--) {\n\t\t\t\tfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\t\t\t\tfsize->discrete.width = pwc_image_sizes[i][0];\n\t\t\t\tfsize->discrete.height = pwc_image_sizes[i][1];\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int pwc_enum_frameintervals(struct file *file, void *fh,\n\t\t\t\t\t   struct v4l2_frmivalenum *fival)\n{\n\tstruct pwc_device *pdev = video_drvdata(file);\n\tint size = -1;\n\tunsigned int i;\n\n\tfor (i = 0; i < PSZ_MAX; i++) {\n\t\tif (pwc_image_sizes[i][0] == fival->width &&\n\t\t\t\tpwc_image_sizes[i][1] == fival->height) {\n\t\t\tsize = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (size < 0 || fival->pixel_format != V4L2_PIX_FMT_YUV420)\n\t\treturn -EINVAL;\n\n\ti = pwc_get_fps(pdev, fival->index, size);\n\tif (!i)\n\t\treturn -EINVAL;\n\n\tfival->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\tfival->discrete.numerator = 1;\n\tfival->discrete.denominator = i;\n\n\treturn 0;\n}\n\nstatic int pwc_g_parm(struct file *file, void *fh,\n\t\t      struct v4l2_streamparm *parm)\n{\n\tstruct pwc_device *pdev = video_drvdata(file);\n\n\tif (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tmemset(parm, 0, sizeof(*parm));\n\n\tparm->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tparm->parm.capture.readbuffers = MIN_FRAMES;\n\tparm->parm.capture.capability |= V4L2_CAP_TIMEPERFRAME;\n\tparm->parm.capture.timeperframe.denominator = pdev->vframes;\n\tparm->parm.capture.timeperframe.numerator = 1;\n\n\treturn 0;\n}\n\nstatic int pwc_s_parm(struct file *file, void *fh,\n\t\t      struct v4l2_streamparm *parm)\n{\n\tstruct pwc_device *pdev = video_drvdata(file);\n\tint compression = 0;\n\tint ret, fps;\n\n\tif (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\t \n\tif (parm->parm.capture.timeperframe.numerator == 0 ||\n\t    parm->parm.capture.timeperframe.denominator == 0)\n\t\tfps = 30;\n\telse\n\t\tfps = parm->parm.capture.timeperframe.denominator /\n\t\t      parm->parm.capture.timeperframe.numerator;\n\n\tif (vb2_is_busy(&pdev->vb_queue))\n\t\treturn -EBUSY;\n\n\tret = pwc_set_video_mode(pdev, pdev->width, pdev->height, pdev->pixfmt,\n\t\t\t\t fps, &compression, 0);\n\n\tpwc_g_parm(file, fh, parm);\n\n\treturn ret;\n}\n\nconst struct v4l2_ioctl_ops pwc_ioctl_ops = {\n\t.vidioc_querycap\t\t    = pwc_querycap,\n\t.vidioc_enum_input\t\t    = pwc_enum_input,\n\t.vidioc_g_input\t\t\t    = pwc_g_input,\n\t.vidioc_s_input\t\t\t    = pwc_s_input,\n\t.vidioc_enum_fmt_vid_cap\t    = pwc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t\t    = pwc_g_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t    = pwc_s_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t\t    = pwc_try_fmt_vid_cap,\n\t.vidioc_reqbufs\t\t\t    = vb2_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t    = vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t    = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t    = vb2_ioctl_dqbuf,\n\t.vidioc_streamon\t\t    = vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t    = vb2_ioctl_streamoff,\n\t.vidioc_log_status\t\t    = v4l2_ctrl_log_status,\n\t.vidioc_enum_framesizes\t\t    = pwc_enum_framesizes,\n\t.vidioc_enum_frameintervals\t    = pwc_enum_frameintervals,\n\t.vidioc_g_parm\t\t\t    = pwc_g_parm,\n\t.vidioc_s_parm\t\t\t    = pwc_s_parm,\n\t.vidioc_subscribe_event\t\t    = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t    = v4l2_event_unsubscribe,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}