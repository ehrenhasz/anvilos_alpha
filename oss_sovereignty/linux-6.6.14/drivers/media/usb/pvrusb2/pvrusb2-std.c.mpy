{
  "module_name": "pvrusb2-std.c",
  "hash_id": "5f5fba379017e696341f9c966246f75d4a0eac5076547f25e2c1bcf7d38dd055",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/pvrusb2/pvrusb2-std.c",
  "human_readable_source": "\n \n\n#include \"pvrusb2-std.h\"\n#include \"pvrusb2-debug.h\"\n#include <asm/string.h>\n#include <linux/slab.h>\n\nstruct std_name {\n\tconst char *name;\n\tv4l2_std_id id;\n};\n\n\n#define CSTD_PAL \\\n\t(V4L2_STD_PAL_B| \\\n\t V4L2_STD_PAL_B1| \\\n\t V4L2_STD_PAL_G| \\\n\t V4L2_STD_PAL_H| \\\n\t V4L2_STD_PAL_I| \\\n\t V4L2_STD_PAL_D| \\\n\t V4L2_STD_PAL_D1| \\\n\t V4L2_STD_PAL_K| \\\n\t V4L2_STD_PAL_M| \\\n\t V4L2_STD_PAL_N| \\\n\t V4L2_STD_PAL_Nc| \\\n\t V4L2_STD_PAL_60)\n\n#define CSTD_NTSC \\\n\t(V4L2_STD_NTSC_M| \\\n\t V4L2_STD_NTSC_M_JP| \\\n\t V4L2_STD_NTSC_M_KR| \\\n\t V4L2_STD_NTSC_443)\n\n#define CSTD_ATSC \\\n\t(V4L2_STD_ATSC_8_VSB| \\\n\t V4L2_STD_ATSC_16_VSB)\n\n#define CSTD_SECAM \\\n\t(V4L2_STD_SECAM_B| \\\n\t V4L2_STD_SECAM_D| \\\n\t V4L2_STD_SECAM_G| \\\n\t V4L2_STD_SECAM_H| \\\n\t V4L2_STD_SECAM_K| \\\n\t V4L2_STD_SECAM_K1| \\\n\t V4L2_STD_SECAM_L| \\\n\t V4L2_STD_SECAM_LC)\n\n#define TSTD_B   (V4L2_STD_PAL_B|V4L2_STD_SECAM_B)\n#define TSTD_B1  (V4L2_STD_PAL_B1)\n#define TSTD_D   (V4L2_STD_PAL_D|V4L2_STD_SECAM_D)\n#define TSTD_D1  (V4L2_STD_PAL_D1)\n#define TSTD_G   (V4L2_STD_PAL_G|V4L2_STD_SECAM_G)\n#define TSTD_H   (V4L2_STD_PAL_H|V4L2_STD_SECAM_H)\n#define TSTD_I   (V4L2_STD_PAL_I)\n#define TSTD_K   (V4L2_STD_PAL_K|V4L2_STD_SECAM_K)\n#define TSTD_K1  (V4L2_STD_SECAM_K1)\n#define TSTD_L   (V4L2_STD_SECAM_L)\n#define TSTD_M   (V4L2_STD_PAL_M|V4L2_STD_NTSC_M)\n#define TSTD_N   (V4L2_STD_PAL_N)\n#define TSTD_Nc  (V4L2_STD_PAL_Nc)\n#define TSTD_60  (V4L2_STD_PAL_60)\n\n#define CSTD_ALL (CSTD_PAL|CSTD_NTSC|CSTD_ATSC|CSTD_SECAM)\n\n \nstatic const struct std_name std_groups[] = {\n\t{\"PAL\",CSTD_PAL},\n\t{\"NTSC\",CSTD_NTSC},\n\t{\"SECAM\",CSTD_SECAM},\n\t{\"ATSC\",CSTD_ATSC},\n};\n\n \nstatic const struct std_name std_items[] = {\n\t{\"B\",TSTD_B},\n\t{\"B1\",TSTD_B1},\n\t{\"D\",TSTD_D},\n\t{\"D1\",TSTD_D1},\n\t{\"G\",TSTD_G},\n\t{\"H\",TSTD_H},\n\t{\"I\",TSTD_I},\n\t{\"K\",TSTD_K},\n\t{\"K1\",TSTD_K1},\n\t{\"L\",TSTD_L},\n\t{\"LC\",V4L2_STD_SECAM_LC},\n\t{\"M\",TSTD_M},\n\t{\"Mj\",V4L2_STD_NTSC_M_JP},\n\t{\"443\",V4L2_STD_NTSC_443},\n\t{\"Mk\",V4L2_STD_NTSC_M_KR},\n\t{\"N\",TSTD_N},\n\t{\"Nc\",TSTD_Nc},\n\t{\"60\",TSTD_60},\n\t{\"8VSB\",V4L2_STD_ATSC_8_VSB},\n\t{\"16VSB\",V4L2_STD_ATSC_16_VSB},\n};\n\n\n\n\nstatic const struct std_name *find_std_name(const struct std_name *arrPtr,\n\t\t\t\t\t    unsigned int arrSize,\n\t\t\t\t\t    const char *bufPtr,\n\t\t\t\t\t    unsigned int bufSize)\n{\n\tunsigned int idx;\n\tconst struct std_name *p;\n\tfor (idx = 0; idx < arrSize; idx++) {\n\t\tp = arrPtr + idx;\n\t\tif (strlen(p->name) != bufSize) continue;\n\t\tif (!memcmp(bufPtr,p->name,bufSize)) return p;\n\t}\n\treturn NULL;\n}\n\n\nint pvr2_std_str_to_id(v4l2_std_id *idPtr,const char *bufPtr,\n\t\t       unsigned int bufSize)\n{\n\tv4l2_std_id id = 0;\n\tv4l2_std_id cmsk = 0;\n\tv4l2_std_id t;\n\tint mMode = 0;\n\tunsigned int cnt;\n\tchar ch;\n\tconst struct std_name *sp;\n\n\twhile (bufSize) {\n\t\tif (!mMode) {\n\t\t\tcnt = 0;\n\t\t\twhile ((cnt < bufSize) && (bufPtr[cnt] != '-')) cnt++;\n\t\t\tif (cnt >= bufSize) return 0; \n\t\t\tsp = find_std_name(std_groups, ARRAY_SIZE(std_groups),\n\t\t\t\t\t   bufPtr,cnt);\n\t\t\tif (!sp) return 0; \n\t\t\tcnt++;\n\t\t\tbufPtr += cnt;\n\t\t\tbufSize -= cnt;\n\t\t\tmMode = !0;\n\t\t\tcmsk = sp->id;\n\t\t\tcontinue;\n\t\t}\n\t\tcnt = 0;\n\t\twhile (cnt < bufSize) {\n\t\t\tch = bufPtr[cnt];\n\t\t\tif (ch == ';') {\n\t\t\t\tmMode = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ch == '/') break;\n\t\t\tcnt++;\n\t\t}\n\t\tsp = find_std_name(std_items, ARRAY_SIZE(std_items),\n\t\t\t\t   bufPtr,cnt);\n\t\tif (!sp) return 0; \n\t\tt = sp->id & cmsk;\n\t\tif (!t) return 0; \n\t\tid |= t;\n\t\tif (cnt < bufSize) cnt++;\n\t\tbufPtr += cnt;\n\t\tbufSize -= cnt;\n\t}\n\n\tif (idPtr) *idPtr = id;\n\treturn !0;\n}\n\n\nunsigned int pvr2_std_id_to_str(char *bufPtr, unsigned int bufSize,\n\t\t\t\tv4l2_std_id id)\n{\n\tunsigned int idx1,idx2;\n\tconst struct std_name *ip,*gp;\n\tint gfl,cfl;\n\tunsigned int c1,c2;\n\tcfl = 0;\n\tc1 = 0;\n\tfor (idx1 = 0; idx1 < ARRAY_SIZE(std_groups); idx1++) {\n\t\tgp = std_groups + idx1;\n\t\tgfl = 0;\n\t\tfor (idx2 = 0; idx2 < ARRAY_SIZE(std_items); idx2++) {\n\t\t\tip = std_items + idx2;\n\t\t\tif (!(gp->id & ip->id & id)) continue;\n\t\t\tif (!gfl) {\n\t\t\t\tif (cfl) {\n\t\t\t\t\tc2 = scnprintf(bufPtr,bufSize,\";\");\n\t\t\t\t\tc1 += c2;\n\t\t\t\t\tbufSize -= c2;\n\t\t\t\t\tbufPtr += c2;\n\t\t\t\t}\n\t\t\t\tcfl = !0;\n\t\t\t\tc2 = scnprintf(bufPtr,bufSize,\n\t\t\t\t\t       \"%s-\",gp->name);\n\t\t\t\tgfl = !0;\n\t\t\t} else {\n\t\t\t\tc2 = scnprintf(bufPtr,bufSize,\"/\");\n\t\t\t}\n\t\t\tc1 += c2;\n\t\t\tbufSize -= c2;\n\t\t\tbufPtr += c2;\n\t\t\tc2 = scnprintf(bufPtr,bufSize,\n\t\t\t\t       ip->name);\n\t\t\tc1 += c2;\n\t\t\tbufSize -= c2;\n\t\t\tbufPtr += c2;\n\t\t}\n\t}\n\treturn c1;\n}\n\n\n\n\nstatic struct v4l2_standard generic_standards[] = {\n\t{\n\t\t.id             = (TSTD_B|TSTD_B1|\n\t\t\t\t   TSTD_D|TSTD_D1|\n\t\t\t\t   TSTD_G|\n\t\t\t\t   TSTD_H|\n\t\t\t\t   TSTD_I|\n\t\t\t\t   TSTD_K|TSTD_K1|\n\t\t\t\t   TSTD_L|\n\t\t\t\t   V4L2_STD_SECAM_LC |\n\t\t\t\t   TSTD_N|TSTD_Nc),\n\t\t.frameperiod    =\n\t\t{\n\t\t\t.numerator  = 1,\n\t\t\t.denominator= 25\n\t\t},\n\t\t.framelines     = 625,\n\t\t.reserved       = {0,0,0,0}\n\t}, {\n\t\t.id             = (TSTD_M|\n\t\t\t\t   V4L2_STD_NTSC_M_JP|\n\t\t\t\t   V4L2_STD_NTSC_M_KR),\n\t\t.frameperiod    =\n\t\t{\n\t\t\t.numerator  = 1001,\n\t\t\t.denominator= 30000\n\t\t},\n\t\t.framelines     = 525,\n\t\t.reserved       = {0,0,0,0}\n\t}, { \n\t\t.id             = (TSTD_60),\n\t\t.frameperiod    =\n\t\t{\n\t\t\t.numerator  = 1001,\n\t\t\t.denominator= 30000\n\t\t},\n\t\t.framelines     = 525,\n\t\t.reserved       = {0,0,0,0}\n\t}, { \n\t\t.id             = V4L2_STD_NTSC_443,\n\t\t.frameperiod    =\n\t\t{\n\t\t\t.numerator  = 1001,\n\t\t\t.denominator= 30000\n\t\t},\n\t\t.framelines     = 525,\n\t\t.reserved       = {0,0,0,0}\n\t}\n};\n\nstatic struct v4l2_standard *match_std(v4l2_std_id id)\n{\n\tunsigned int idx;\n\tfor (idx = 0; idx < ARRAY_SIZE(generic_standards); idx++) {\n\t\tif (generic_standards[idx].id & id) {\n\t\t\treturn generic_standards + idx;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic int pvr2_std_fill(struct v4l2_standard *std,v4l2_std_id id)\n{\n\tstruct v4l2_standard *template;\n\tint idx;\n\tunsigned int bcnt;\n\ttemplate = match_std(id);\n\tif (!template) return 0;\n\tidx = std->index;\n\tmemcpy(std,template,sizeof(*template));\n\tstd->index = idx;\n\tstd->id = id;\n\tbcnt = pvr2_std_id_to_str(std->name,sizeof(std->name)-1,id);\n\tstd->name[bcnt] = 0;\n\tpvr2_trace(PVR2_TRACE_STD,\"Set up standard idx=%u name=%s\",\n\t\t   std->index,std->name);\n\treturn !0;\n}\n\n \nstatic v4l2_std_id std_mixes[] = {\n\tV4L2_STD_PAL_B | V4L2_STD_PAL_G,\n\tV4L2_STD_PAL_D | V4L2_STD_PAL_K,\n\tV4L2_STD_SECAM_B | V4L2_STD_SECAM_G,\n\tV4L2_STD_SECAM_D | V4L2_STD_SECAM_K,\n};\n\nstruct v4l2_standard *pvr2_std_create_enum(unsigned int *countptr,\n\t\t\t\t\t   v4l2_std_id id)\n{\n\tunsigned int std_cnt = 0;\n\tunsigned int idx,bcnt,idx2;\n\tv4l2_std_id idmsk,cmsk,fmsk;\n\tstruct v4l2_standard *stddefs;\n\n\tif (pvrusb2_debug & PVR2_TRACE_STD) {\n\t\tchar buf[100];\n\t\tbcnt = pvr2_std_id_to_str(buf,sizeof(buf),id);\n\t\tpvr2_trace(\n\t\t\tPVR2_TRACE_STD,\"Mapping standards mask=0x%x (%.*s)\",\n\t\t\t(int)id,bcnt,buf);\n\t}\n\n\t*countptr = 0;\n\tstd_cnt = 0;\n\tfmsk = 0;\n\tfor (idmsk = 1, cmsk = id; cmsk; idmsk <<= 1) {\n\t\tif (!(idmsk & cmsk)) continue;\n\t\tcmsk &= ~idmsk;\n\t\tif (match_std(idmsk)) {\n\t\t\tstd_cnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tfmsk |= idmsk;\n\t}\n\n\tfor (idx2 = 0; idx2 < ARRAY_SIZE(std_mixes); idx2++) {\n\t\tif ((id & std_mixes[idx2]) == std_mixes[idx2]) std_cnt++;\n\t}\n\n\t \n\tfmsk &= ~CSTD_ATSC;\n\n\tif (fmsk) {\n\t\tchar buf[100];\n\t\tbcnt = pvr2_std_id_to_str(buf,sizeof(buf),fmsk);\n\t\tpvr2_trace(\n\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\"***WARNING*** Failed to classify the following standard(s): %.*s\",\n\t\t\tbcnt,buf);\n\t}\n\n\tpvr2_trace(PVR2_TRACE_STD,\"Setting up %u unique standard(s)\",\n\t\t   std_cnt);\n\tif (!std_cnt) return NULL; \n\n\tstddefs = kcalloc(std_cnt, sizeof(struct v4l2_standard),\n\t\t\t  GFP_KERNEL);\n\tif (!stddefs)\n\t\treturn NULL;\n\n\tfor (idx = 0; idx < std_cnt; idx++)\n\t\tstddefs[idx].index = idx;\n\n\tidx = 0;\n\n\t \n\tfor (idx2 = 0; (idx2 < ARRAY_SIZE(std_mixes)) && (idx < std_cnt);\n\t     idx2++) {\n\t\tif (!(id & std_mixes[idx2])) continue;\n\t\tif (pvr2_std_fill(stddefs+idx,std_mixes[idx2])) idx++;\n\t}\n\t \n\tfor (idmsk = 1, cmsk = id; cmsk && (idx < std_cnt); idmsk <<= 1) {\n\t\tif (!(idmsk & cmsk)) continue;\n\t\tcmsk &= ~idmsk;\n\t\tif (!pvr2_std_fill(stddefs+idx,idmsk)) continue;\n\t\tidx++;\n\t}\n\n\t*countptr = std_cnt;\n\treturn stddefs;\n}\n\nv4l2_std_id pvr2_std_get_usable(void)\n{\n\treturn CSTD_ALL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}