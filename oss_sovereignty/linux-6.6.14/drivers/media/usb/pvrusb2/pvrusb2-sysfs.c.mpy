{
  "module_name": "pvrusb2-sysfs.c",
  "hash_id": "5012a179bf136ceb26e5680f2b7d3f2249640e682173f341dfe57876e8708bab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/slab.h>\n#include \"pvrusb2-sysfs.h\"\n#include \"pvrusb2-hdw.h\"\n#include \"pvrusb2-debug.h\"\n#ifdef CONFIG_VIDEO_PVRUSB2_DEBUGIFC\n#include \"pvrusb2-debugifc.h\"\n#endif  \n\n#define pvr2_sysfs_trace(...) pvr2_trace(PVR2_TRACE_SYSFS,__VA_ARGS__)\n\nstruct pvr2_sysfs {\n\tstruct pvr2_channel channel;\n\tstruct device *class_dev;\n#ifdef CONFIG_VIDEO_PVRUSB2_DEBUGIFC\n\tstruct pvr2_sysfs_debugifc *debugifc;\n#endif  \n\tstruct pvr2_sysfs_ctl_item *item_first;\n\tstruct pvr2_sysfs_ctl_item *item_last;\n\tstruct device_attribute attr_v4l_minor_number;\n\tstruct device_attribute attr_v4l_radio_minor_number;\n\tstruct device_attribute attr_unit_number;\n\tstruct device_attribute attr_bus_info;\n\tstruct device_attribute attr_hdw_name;\n\tstruct device_attribute attr_hdw_desc;\n\tint v4l_minor_number_created_ok;\n\tint v4l_radio_minor_number_created_ok;\n\tint unit_number_created_ok;\n\tint bus_info_created_ok;\n\tint hdw_name_created_ok;\n\tint hdw_desc_created_ok;\n};\n\n#ifdef CONFIG_VIDEO_PVRUSB2_DEBUGIFC\nstruct pvr2_sysfs_debugifc {\n\tstruct device_attribute attr_debugcmd;\n\tstruct device_attribute attr_debuginfo;\n\tint debugcmd_created_ok;\n\tint debuginfo_created_ok;\n};\n#endif  \n\nstruct pvr2_sysfs_ctl_item {\n\tstruct device_attribute attr_name;\n\tstruct device_attribute attr_type;\n\tstruct device_attribute attr_min;\n\tstruct device_attribute attr_max;\n\tstruct device_attribute attr_def;\n\tstruct device_attribute attr_enum;\n\tstruct device_attribute attr_bits;\n\tstruct device_attribute attr_val;\n\tstruct device_attribute attr_custom;\n\tstruct pvr2_ctrl *cptr;\n\tint ctl_id;\n\tstruct pvr2_sysfs *chptr;\n\tstruct pvr2_sysfs_ctl_item *item_next;\n\tstruct attribute *attr_gen[8];\n\tstruct attribute_group grp;\n\tint created_ok;\n\tchar name[80];\n};\n\nstatic ssize_t show_name(struct device *class_dev,\n\t\t\t struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct pvr2_sysfs_ctl_item *cip;\n\tconst char *name;\n\tcip = container_of(attr, struct pvr2_sysfs_ctl_item, attr_name);\n\tname = pvr2_ctrl_get_desc(cip->cptr);\n\tpvr2_sysfs_trace(\"pvr2_sysfs(%p) show_name(cid=%d) is %s\",\n\t\t\t cip->chptr, cip->ctl_id, name);\n\tif (!name) return -EINVAL;\n\treturn sysfs_emit(buf, \"%s\\n\", name);\n}\n\nstatic ssize_t show_type(struct device *class_dev,\n\t\t\t struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct pvr2_sysfs_ctl_item *cip;\n\tconst char *name;\n\tenum pvr2_ctl_type tp;\n\tcip = container_of(attr, struct pvr2_sysfs_ctl_item, attr_type);\n\ttp = pvr2_ctrl_get_type(cip->cptr);\n\tswitch (tp) {\n\tcase pvr2_ctl_int: name = \"integer\"; break;\n\tcase pvr2_ctl_enum: name = \"enum\"; break;\n\tcase pvr2_ctl_bitmask: name = \"bitmask\"; break;\n\tcase pvr2_ctl_bool: name = \"boolean\"; break;\n\tdefault: name = \"?\"; break;\n\t}\n\tpvr2_sysfs_trace(\"pvr2_sysfs(%p) show_type(cid=%d) is %s\",\n\t\t\t cip->chptr, cip->ctl_id, name);\n\treturn sysfs_emit(buf, \"%s\\n\", name);\n}\n\nstatic ssize_t show_min(struct device *class_dev,\n\t\t\tstruct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct pvr2_sysfs_ctl_item *cip;\n\tlong val;\n\tcip = container_of(attr, struct pvr2_sysfs_ctl_item, attr_min);\n\tval = pvr2_ctrl_get_min(cip->cptr);\n\tpvr2_sysfs_trace(\"pvr2_sysfs(%p) show_min(cid=%d) is %ld\",\n\t\t\t cip->chptr, cip->ctl_id, val);\n\treturn sysfs_emit(buf, \"%ld\\n\", val);\n}\n\nstatic ssize_t show_max(struct device *class_dev,\n\t\t\tstruct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct pvr2_sysfs_ctl_item *cip;\n\tlong val;\n\tcip = container_of(attr, struct pvr2_sysfs_ctl_item, attr_max);\n\tval = pvr2_ctrl_get_max(cip->cptr);\n\tpvr2_sysfs_trace(\"pvr2_sysfs(%p) show_max(cid=%d) is %ld\",\n\t\t\t cip->chptr, cip->ctl_id, val);\n\treturn sysfs_emit(buf, \"%ld\\n\", val);\n}\n\nstatic ssize_t show_def(struct device *class_dev,\n\t\t\tstruct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct pvr2_sysfs_ctl_item *cip;\n\tint val;\n\tint ret;\n\tunsigned int cnt = 0;\n\tcip = container_of(attr, struct pvr2_sysfs_ctl_item, attr_def);\n\tret = pvr2_ctrl_get_def(cip->cptr, &val);\n\tif (ret < 0) return ret;\n\tret = pvr2_ctrl_value_to_sym(cip->cptr, ~0, val,\n\t\t\t\t     buf, PAGE_SIZE - 1, &cnt);\n\tpvr2_sysfs_trace(\"pvr2_sysfs(%p) show_def(cid=%d) is %.*s (%d)\",\n\t\t\t cip->chptr, cip->ctl_id, cnt, buf, val);\n\tbuf[cnt] = '\\n';\n\treturn cnt + 1;\n}\n\nstatic ssize_t show_val_norm(struct device *class_dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct pvr2_sysfs_ctl_item *cip;\n\tint val;\n\tint ret;\n\tunsigned int cnt = 0;\n\tcip = container_of(attr, struct pvr2_sysfs_ctl_item, attr_val);\n\tret = pvr2_ctrl_get_value(cip->cptr, &val);\n\tif (ret < 0) return ret;\n\tret = pvr2_ctrl_value_to_sym(cip->cptr, ~0, val,\n\t\t\t\t     buf, PAGE_SIZE - 1, &cnt);\n\tpvr2_sysfs_trace(\"pvr2_sysfs(%p) show_val_norm(cid=%d) is %.*s (%d)\",\n\t\t\t cip->chptr, cip->ctl_id, cnt, buf, val);\n\tbuf[cnt] = '\\n';\n\treturn cnt+1;\n}\n\nstatic ssize_t show_val_custom(struct device *class_dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct pvr2_sysfs_ctl_item *cip;\n\tint val;\n\tint ret;\n\tunsigned int cnt = 0;\n\tcip = container_of(attr, struct pvr2_sysfs_ctl_item, attr_custom);\n\tret = pvr2_ctrl_get_value(cip->cptr, &val);\n\tif (ret < 0) return ret;\n\tret = pvr2_ctrl_custom_value_to_sym(cip->cptr, ~0, val,\n\t\t\t\t\t    buf, PAGE_SIZE - 1, &cnt);\n\tpvr2_sysfs_trace(\"pvr2_sysfs(%p) show_val_custom(cid=%d) is %.*s (%d)\",\n\t\t\t cip->chptr, cip->ctl_id, cnt, buf, val);\n\tbuf[cnt] = '\\n';\n\treturn cnt+1;\n}\n\nstatic ssize_t show_enum(struct device *class_dev,\n\t\t\t struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct pvr2_sysfs_ctl_item *cip;\n\tlong val;\n\tunsigned int bcnt, ccnt, ecnt;\n\tcip = container_of(attr, struct pvr2_sysfs_ctl_item, attr_enum);\n\tecnt = pvr2_ctrl_get_cnt(cip->cptr);\n\tbcnt = 0;\n\tfor (val = 0; val < ecnt; val++) {\n\t\tpvr2_ctrl_get_valname(cip->cptr, val, buf + bcnt,\n\t\t\t\t      PAGE_SIZE - bcnt, &ccnt);\n\t\tif (!ccnt) continue;\n\t\tbcnt += ccnt;\n\t\tif (bcnt >= PAGE_SIZE) break;\n\t\tbuf[bcnt] = '\\n';\n\t\tbcnt++;\n\t}\n\tpvr2_sysfs_trace(\"pvr2_sysfs(%p) show_enum(cid=%d)\",\n\t\t\t cip->chptr, cip->ctl_id);\n\treturn bcnt;\n}\n\nstatic ssize_t show_bits(struct device *class_dev,\n\t\t\t struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct pvr2_sysfs_ctl_item *cip;\n\tint valid_bits, msk;\n\tunsigned int bcnt, ccnt;\n\tcip = container_of(attr, struct pvr2_sysfs_ctl_item, attr_bits);\n\tvalid_bits = pvr2_ctrl_get_mask(cip->cptr);\n\tbcnt = 0;\n\tfor (msk = 1; valid_bits; msk <<= 1) {\n\t\tif (!(msk & valid_bits)) continue;\n\t\tvalid_bits &= ~msk;\n\t\tpvr2_ctrl_get_valname(cip->cptr, msk, buf + bcnt,\n\t\t\t\t      PAGE_SIZE - bcnt, &ccnt);\n\t\tbcnt += ccnt;\n\t\tif (bcnt >= PAGE_SIZE) break;\n\t\tbuf[bcnt] = '\\n';\n\t\tbcnt++;\n\t}\n\tpvr2_sysfs_trace(\"pvr2_sysfs(%p) show_bits(cid=%d)\",\n\t\t\t cip->chptr, cip->ctl_id);\n\treturn bcnt;\n}\n\nstatic int store_val_any(struct pvr2_sysfs_ctl_item *cip, int customfl,\n\t\t\t const char *buf,unsigned int count)\n{\n\tint ret;\n\tint mask,val;\n\tif (customfl) {\n\t\tret = pvr2_ctrl_custom_sym_to_value(cip->cptr, buf, count,\n\t\t\t\t\t\t    &mask, &val);\n\t} else {\n\t\tret = pvr2_ctrl_sym_to_value(cip->cptr, buf, count,\n\t\t\t\t\t     &mask, &val);\n\t}\n\tif (ret < 0) return ret;\n\tret = pvr2_ctrl_set_mask_value(cip->cptr, mask, val);\n\tpvr2_hdw_commit_ctl(cip->chptr->channel.hdw);\n\treturn ret;\n}\n\nstatic ssize_t store_val_norm(struct device *class_dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct pvr2_sysfs_ctl_item *cip;\n\tint ret;\n\tcip = container_of(attr, struct pvr2_sysfs_ctl_item, attr_val);\n\tpvr2_sysfs_trace(\"pvr2_sysfs(%p) store_val_norm(cid=%d) \\\"%.*s\\\"\",\n\t\t\t cip->chptr, cip->ctl_id, (int)count, buf);\n\tret = store_val_any(cip, 0, buf, count);\n\tif (!ret) ret = count;\n\treturn ret;\n}\n\nstatic ssize_t store_val_custom(struct device *class_dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct pvr2_sysfs_ctl_item *cip;\n\tint ret;\n\tcip = container_of(attr, struct pvr2_sysfs_ctl_item, attr_custom);\n\tpvr2_sysfs_trace(\"pvr2_sysfs(%p) store_val_custom(cid=%d) \\\"%.*s\\\"\",\n\t\t\t cip->chptr, cip->ctl_id, (int)count, buf);\n\tret = store_val_any(cip, 1, buf, count);\n\tif (!ret) ret = count;\n\treturn ret;\n}\n\nstatic void pvr2_sysfs_add_control(struct pvr2_sysfs *sfp,int ctl_id)\n{\n\tstruct pvr2_sysfs_ctl_item *cip;\n\tstruct pvr2_ctrl *cptr;\n\tunsigned int cnt,acnt;\n\tint ret;\n\n\tcptr = pvr2_hdw_get_ctrl_by_index(sfp->channel.hdw,ctl_id);\n\tif (!cptr) return;\n\n\tcip = kzalloc(sizeof(*cip),GFP_KERNEL);\n\tif (!cip) return;\n\tpvr2_sysfs_trace(\"Creating pvr2_sysfs_ctl_item id=%p\",cip);\n\n\tcip->cptr = cptr;\n\tcip->ctl_id = ctl_id;\n\n\tcip->chptr = sfp;\n\tcip->item_next = NULL;\n\tif (sfp->item_last) {\n\t\tsfp->item_last->item_next = cip;\n\t} else {\n\t\tsfp->item_first = cip;\n\t}\n\tsfp->item_last = cip;\n\n\tsysfs_attr_init(&cip->attr_name.attr);\n\tcip->attr_name.attr.name = \"name\";\n\tcip->attr_name.attr.mode = S_IRUGO;\n\tcip->attr_name.show = show_name;\n\n\tsysfs_attr_init(&cip->attr_type.attr);\n\tcip->attr_type.attr.name = \"type\";\n\tcip->attr_type.attr.mode = S_IRUGO;\n\tcip->attr_type.show = show_type;\n\n\tsysfs_attr_init(&cip->attr_min.attr);\n\tcip->attr_min.attr.name = \"min_val\";\n\tcip->attr_min.attr.mode = S_IRUGO;\n\tcip->attr_min.show = show_min;\n\n\tsysfs_attr_init(&cip->attr_max.attr);\n\tcip->attr_max.attr.name = \"max_val\";\n\tcip->attr_max.attr.mode = S_IRUGO;\n\tcip->attr_max.show = show_max;\n\n\tsysfs_attr_init(&cip->attr_def.attr);\n\tcip->attr_def.attr.name = \"def_val\";\n\tcip->attr_def.attr.mode = S_IRUGO;\n\tcip->attr_def.show = show_def;\n\n\tsysfs_attr_init(&cip->attr_val.attr);\n\tcip->attr_val.attr.name = \"cur_val\";\n\tcip->attr_val.attr.mode = S_IRUGO;\n\n\tsysfs_attr_init(&cip->attr_custom.attr);\n\tcip->attr_custom.attr.name = \"custom_val\";\n\tcip->attr_custom.attr.mode = S_IRUGO;\n\n\tsysfs_attr_init(&cip->attr_enum.attr);\n\tcip->attr_enum.attr.name = \"enum_val\";\n\tcip->attr_enum.attr.mode = S_IRUGO;\n\tcip->attr_enum.show = show_enum;\n\n\tsysfs_attr_init(&cip->attr_bits.attr);\n\tcip->attr_bits.attr.name = \"bit_val\";\n\tcip->attr_bits.attr.mode = S_IRUGO;\n\tcip->attr_bits.show = show_bits;\n\n\tif (pvr2_ctrl_is_writable(cptr)) {\n\t\tcip->attr_val.attr.mode |= S_IWUSR|S_IWGRP;\n\t\tcip->attr_custom.attr.mode |= S_IWUSR|S_IWGRP;\n\t}\n\n\tacnt = 0;\n\tcip->attr_gen[acnt++] = &cip->attr_name.attr;\n\tcip->attr_gen[acnt++] = &cip->attr_type.attr;\n\tcip->attr_gen[acnt++] = &cip->attr_val.attr;\n\tcip->attr_gen[acnt++] = &cip->attr_def.attr;\n\tcip->attr_val.show = show_val_norm;\n\tcip->attr_val.store = store_val_norm;\n\tif (pvr2_ctrl_has_custom_symbols(cptr)) {\n\t\tcip->attr_gen[acnt++] = &cip->attr_custom.attr;\n\t\tcip->attr_custom.show = show_val_custom;\n\t\tcip->attr_custom.store = store_val_custom;\n\t}\n\tswitch (pvr2_ctrl_get_type(cptr)) {\n\tcase pvr2_ctl_enum:\n\t\t\n\t\tcip->attr_gen[acnt++] = &cip->attr_enum.attr;\n\t\tbreak;\n\tcase pvr2_ctl_int:\n\t\t\n\t\tcip->attr_gen[acnt++] = &cip->attr_min.attr;\n\t\tcip->attr_gen[acnt++] = &cip->attr_max.attr;\n\t\tbreak;\n\tcase pvr2_ctl_bitmask:\n\t\t\n\t\tcip->attr_gen[acnt++] = &cip->attr_bits.attr;\n\t\tbreak;\n\tdefault: break;\n\t}\n\n\tcnt = scnprintf(cip->name,sizeof(cip->name)-1,\"ctl_%s\",\n\t\t\tpvr2_ctrl_get_name(cptr));\n\tcip->name[cnt] = 0;\n\tcip->grp.name = cip->name;\n\tcip->grp.attrs = cip->attr_gen;\n\n\tret = sysfs_create_group(&sfp->class_dev->kobj,&cip->grp);\n\tif (ret) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"sysfs_create_group error: %d\",\n\t\t\t   ret);\n\t\treturn;\n\t}\n\tcip->created_ok = !0;\n}\n\n#ifdef CONFIG_VIDEO_PVRUSB2_DEBUGIFC\nstatic ssize_t debuginfo_show(struct device *, struct device_attribute *,\n\t\t\t      char *);\nstatic ssize_t debugcmd_show(struct device *, struct device_attribute *,\n\t\t\t     char *);\nstatic ssize_t debugcmd_store(struct device *, struct device_attribute *,\n\t\t\t      const char *, size_t count);\n\nstatic void pvr2_sysfs_add_debugifc(struct pvr2_sysfs *sfp)\n{\n\tstruct pvr2_sysfs_debugifc *dip;\n\tint ret;\n\n\tdip = kzalloc(sizeof(*dip),GFP_KERNEL);\n\tif (!dip) return;\n\tsysfs_attr_init(&dip->attr_debugcmd.attr);\n\tdip->attr_debugcmd.attr.name = \"debugcmd\";\n\tdip->attr_debugcmd.attr.mode = S_IRUGO|S_IWUSR|S_IWGRP;\n\tdip->attr_debugcmd.show = debugcmd_show;\n\tdip->attr_debugcmd.store = debugcmd_store;\n\tsysfs_attr_init(&dip->attr_debuginfo.attr);\n\tdip->attr_debuginfo.attr.name = \"debuginfo\";\n\tdip->attr_debuginfo.attr.mode = S_IRUGO;\n\tdip->attr_debuginfo.show = debuginfo_show;\n\tsfp->debugifc = dip;\n\tret = device_create_file(sfp->class_dev,&dip->attr_debugcmd);\n\tif (ret < 0) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"device_create_file error: %d\",\n\t\t\t   ret);\n\t} else {\n\t\tdip->debugcmd_created_ok = !0;\n\t}\n\tret = device_create_file(sfp->class_dev,&dip->attr_debuginfo);\n\tif (ret < 0) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"device_create_file error: %d\",\n\t\t\t   ret);\n\t} else {\n\t\tdip->debuginfo_created_ok = !0;\n\t}\n}\n\n\nstatic void pvr2_sysfs_tear_down_debugifc(struct pvr2_sysfs *sfp)\n{\n\tif (!sfp->debugifc) return;\n\tif (sfp->debugifc->debuginfo_created_ok) {\n\t\tdevice_remove_file(sfp->class_dev,\n\t\t\t\t\t &sfp->debugifc->attr_debuginfo);\n\t}\n\tif (sfp->debugifc->debugcmd_created_ok) {\n\t\tdevice_remove_file(sfp->class_dev,\n\t\t\t\t\t &sfp->debugifc->attr_debugcmd);\n\t}\n\tkfree(sfp->debugifc);\n\tsfp->debugifc = NULL;\n}\n#endif  \n\n\nstatic void pvr2_sysfs_add_controls(struct pvr2_sysfs *sfp)\n{\n\tunsigned int idx,cnt;\n\tcnt = pvr2_hdw_get_ctrl_count(sfp->channel.hdw);\n\tfor (idx = 0; idx < cnt; idx++) {\n\t\tpvr2_sysfs_add_control(sfp,idx);\n\t}\n}\n\n\nstatic void pvr2_sysfs_tear_down_controls(struct pvr2_sysfs *sfp)\n{\n\tstruct pvr2_sysfs_ctl_item *cip1,*cip2;\n\tfor (cip1 = sfp->item_first; cip1; cip1 = cip2) {\n\t\tcip2 = cip1->item_next;\n\t\tif (cip1->created_ok) {\n\t\t\tsysfs_remove_group(&sfp->class_dev->kobj,&cip1->grp);\n\t\t}\n\t\tpvr2_sysfs_trace(\"Destroying pvr2_sysfs_ctl_item id=%p\",cip1);\n\t\tkfree(cip1);\n\t}\n}\n\n\nstatic void pvr2_sysfs_release(struct device *class_dev)\n{\n\tpvr2_sysfs_trace(\"Releasing class_dev id=%p\",class_dev);\n\tkfree(class_dev);\n}\n\n\nstatic struct class pvr2_class = {\n\t.name\t\t= \"pvrusb2\",\n\t.dev_release\t= pvr2_sysfs_release,\n};\n\n\nstatic void class_dev_destroy(struct pvr2_sysfs *sfp)\n{\n\tstruct device *dev;\n\tif (!sfp->class_dev) return;\n#ifdef CONFIG_VIDEO_PVRUSB2_DEBUGIFC\n\tpvr2_sysfs_tear_down_debugifc(sfp);\n#endif  \n\tpvr2_sysfs_tear_down_controls(sfp);\n\tif (sfp->hdw_desc_created_ok) {\n\t\tdevice_remove_file(sfp->class_dev,\n\t\t\t\t   &sfp->attr_hdw_desc);\n\t}\n\tif (sfp->hdw_name_created_ok) {\n\t\tdevice_remove_file(sfp->class_dev,\n\t\t\t\t   &sfp->attr_hdw_name);\n\t}\n\tif (sfp->bus_info_created_ok) {\n\t\tdevice_remove_file(sfp->class_dev,\n\t\t\t\t\t &sfp->attr_bus_info);\n\t}\n\tif (sfp->v4l_minor_number_created_ok) {\n\t\tdevice_remove_file(sfp->class_dev,\n\t\t\t\t\t &sfp->attr_v4l_minor_number);\n\t}\n\tif (sfp->v4l_radio_minor_number_created_ok) {\n\t\tdevice_remove_file(sfp->class_dev,\n\t\t\t\t\t &sfp->attr_v4l_radio_minor_number);\n\t}\n\tif (sfp->unit_number_created_ok) {\n\t\tdevice_remove_file(sfp->class_dev,\n\t\t\t\t\t &sfp->attr_unit_number);\n\t}\n\tpvr2_sysfs_trace(\"Destroying class_dev id=%p\",sfp->class_dev);\n\tdev_set_drvdata(sfp->class_dev, NULL);\n\tdev = sfp->class_dev->parent;\n\tsfp->class_dev->parent = NULL;\n\tput_device(dev);\n\tdevice_unregister(sfp->class_dev);\n\tsfp->class_dev = NULL;\n}\n\n\nstatic ssize_t v4l_minor_number_show(struct device *class_dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct pvr2_sysfs *sfp;\n\tsfp = dev_get_drvdata(class_dev);\n\tif (!sfp) return -EINVAL;\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t pvr2_hdw_v4l_get_minor_number(sfp->channel.hdw,\n\t\t\t\t\t\t       pvr2_v4l_type_video));\n}\n\n\nstatic ssize_t bus_info_show(struct device *class_dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct pvr2_sysfs *sfp;\n\tsfp = dev_get_drvdata(class_dev);\n\tif (!sfp) return -EINVAL;\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\t pvr2_hdw_get_bus_info(sfp->channel.hdw));\n}\n\n\nstatic ssize_t hdw_name_show(struct device *class_dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct pvr2_sysfs *sfp;\n\tsfp = dev_get_drvdata(class_dev);\n\tif (!sfp) return -EINVAL;\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\t pvr2_hdw_get_type(sfp->channel.hdw));\n}\n\n\nstatic ssize_t hdw_desc_show(struct device *class_dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct pvr2_sysfs *sfp;\n\tsfp = dev_get_drvdata(class_dev);\n\tif (!sfp) return -EINVAL;\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\t pvr2_hdw_get_desc(sfp->channel.hdw));\n}\n\n\nstatic ssize_t v4l_radio_minor_number_show(struct device *class_dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct pvr2_sysfs *sfp;\n\tsfp = dev_get_drvdata(class_dev);\n\tif (!sfp) return -EINVAL;\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t pvr2_hdw_v4l_get_minor_number(sfp->channel.hdw,\n\t\t\t\t\t\t       pvr2_v4l_type_radio));\n}\n\n\nstatic ssize_t unit_number_show(struct device *class_dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct pvr2_sysfs *sfp;\n\tsfp = dev_get_drvdata(class_dev);\n\tif (!sfp) return -EINVAL;\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t pvr2_hdw_get_unit_number(sfp->channel.hdw));\n}\n\n\nstatic void class_dev_create(struct pvr2_sysfs *sfp)\n{\n\tstruct usb_device *usb_dev;\n\tstruct device *class_dev;\n\tint ret;\n\n\tusb_dev = pvr2_hdw_get_dev(sfp->channel.hdw);\n\tif (!usb_dev) return;\n\tclass_dev = kzalloc(sizeof(*class_dev),GFP_KERNEL);\n\tif (!class_dev) return;\n\n\tpvr2_sysfs_trace(\"Creating class_dev id=%p\",class_dev);\n\n\tclass_dev->class = &pvr2_class;\n\n\tdev_set_name(class_dev, \"%s\",\n\t\t     pvr2_hdw_get_device_identifier(sfp->channel.hdw));\n\n\tclass_dev->parent = get_device(&usb_dev->dev);\n\n\tsfp->class_dev = class_dev;\n\tdev_set_drvdata(class_dev, sfp);\n\tret = device_register(class_dev);\n\tif (ret) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"device_register failed\");\n\t\tput_device(class_dev);\n\t\treturn;\n\t}\n\n\tsysfs_attr_init(&sfp->attr_v4l_minor_number.attr);\n\tsfp->attr_v4l_minor_number.attr.name = \"v4l_minor_number\";\n\tsfp->attr_v4l_minor_number.attr.mode = S_IRUGO;\n\tsfp->attr_v4l_minor_number.show = v4l_minor_number_show;\n\tsfp->attr_v4l_minor_number.store = NULL;\n\tret = device_create_file(sfp->class_dev,\n\t\t\t\t       &sfp->attr_v4l_minor_number);\n\tif (ret < 0) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"device_create_file error: %d\",\n\t\t\t   ret);\n\t} else {\n\t\tsfp->v4l_minor_number_created_ok = !0;\n\t}\n\n\tsysfs_attr_init(&sfp->attr_v4l_radio_minor_number.attr);\n\tsfp->attr_v4l_radio_minor_number.attr.name = \"v4l_radio_minor_number\";\n\tsfp->attr_v4l_radio_minor_number.attr.mode = S_IRUGO;\n\tsfp->attr_v4l_radio_minor_number.show = v4l_radio_minor_number_show;\n\tsfp->attr_v4l_radio_minor_number.store = NULL;\n\tret = device_create_file(sfp->class_dev,\n\t\t\t\t       &sfp->attr_v4l_radio_minor_number);\n\tif (ret < 0) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"device_create_file error: %d\",\n\t\t\t   ret);\n\t} else {\n\t\tsfp->v4l_radio_minor_number_created_ok = !0;\n\t}\n\n\tsysfs_attr_init(&sfp->attr_unit_number.attr);\n\tsfp->attr_unit_number.attr.name = \"unit_number\";\n\tsfp->attr_unit_number.attr.mode = S_IRUGO;\n\tsfp->attr_unit_number.show = unit_number_show;\n\tsfp->attr_unit_number.store = NULL;\n\tret = device_create_file(sfp->class_dev,&sfp->attr_unit_number);\n\tif (ret < 0) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"device_create_file error: %d\",\n\t\t\t   ret);\n\t} else {\n\t\tsfp->unit_number_created_ok = !0;\n\t}\n\n\tsysfs_attr_init(&sfp->attr_bus_info.attr);\n\tsfp->attr_bus_info.attr.name = \"bus_info_str\";\n\tsfp->attr_bus_info.attr.mode = S_IRUGO;\n\tsfp->attr_bus_info.show = bus_info_show;\n\tsfp->attr_bus_info.store = NULL;\n\tret = device_create_file(sfp->class_dev,\n\t\t\t\t       &sfp->attr_bus_info);\n\tif (ret < 0) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"device_create_file error: %d\",\n\t\t\t   ret);\n\t} else {\n\t\tsfp->bus_info_created_ok = !0;\n\t}\n\n\tsysfs_attr_init(&sfp->attr_hdw_name.attr);\n\tsfp->attr_hdw_name.attr.name = \"device_hardware_type\";\n\tsfp->attr_hdw_name.attr.mode = S_IRUGO;\n\tsfp->attr_hdw_name.show = hdw_name_show;\n\tsfp->attr_hdw_name.store = NULL;\n\tret = device_create_file(sfp->class_dev,\n\t\t\t\t &sfp->attr_hdw_name);\n\tif (ret < 0) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"device_create_file error: %d\",\n\t\t\t   ret);\n\t} else {\n\t\tsfp->hdw_name_created_ok = !0;\n\t}\n\n\tsysfs_attr_init(&sfp->attr_hdw_desc.attr);\n\tsfp->attr_hdw_desc.attr.name = \"device_hardware_description\";\n\tsfp->attr_hdw_desc.attr.mode = S_IRUGO;\n\tsfp->attr_hdw_desc.show = hdw_desc_show;\n\tsfp->attr_hdw_desc.store = NULL;\n\tret = device_create_file(sfp->class_dev,\n\t\t\t\t &sfp->attr_hdw_desc);\n\tif (ret < 0) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"device_create_file error: %d\",\n\t\t\t   ret);\n\t} else {\n\t\tsfp->hdw_desc_created_ok = !0;\n\t}\n\n\tpvr2_sysfs_add_controls(sfp);\n#ifdef CONFIG_VIDEO_PVRUSB2_DEBUGIFC\n\tpvr2_sysfs_add_debugifc(sfp);\n#endif  \n}\n\n\nstatic void pvr2_sysfs_internal_check(struct pvr2_channel *chp)\n{\n\tstruct pvr2_sysfs *sfp;\n\tsfp = container_of(chp,struct pvr2_sysfs,channel);\n\tif (!sfp->channel.mc_head->disconnect_flag) return;\n\tpvr2_trace(PVR2_TRACE_STRUCT,\"Destroying pvr2_sysfs id=%p\",sfp);\n\tclass_dev_destroy(sfp);\n\tpvr2_channel_done(&sfp->channel);\n\tkfree(sfp);\n}\n\n\nvoid pvr2_sysfs_create(struct pvr2_context *mp)\n{\n\tstruct pvr2_sysfs *sfp;\n\tsfp = kzalloc(sizeof(*sfp),GFP_KERNEL);\n\tif (!sfp)\n\t\treturn;\n\tpvr2_trace(PVR2_TRACE_STRUCT,\"Creating pvr2_sysfs id=%p\",sfp);\n\tpvr2_channel_init(&sfp->channel,mp);\n\tsfp->channel.check_func = pvr2_sysfs_internal_check;\n\n\tclass_dev_create(sfp);\n}\n\n\nvoid pvr2_sysfs_class_create(void)\n{\n\tif (class_register(&pvr2_class))\n\t\tpvr2_sysfs_trace(\"Registration failed for pvr2_sysfs_class\");\n}\n\n\nvoid pvr2_sysfs_class_destroy(void)\n{\n\tclass_unregister(&pvr2_class);\n}\n\n\n#ifdef CONFIG_VIDEO_PVRUSB2_DEBUGIFC\nstatic ssize_t debuginfo_show(struct device *class_dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct pvr2_sysfs *sfp;\n\tsfp = dev_get_drvdata(class_dev);\n\tif (!sfp) return -EINVAL;\n\tpvr2_hdw_trigger_module_log(sfp->channel.hdw);\n\treturn pvr2_debugifc_print_info(sfp->channel.hdw,buf,PAGE_SIZE);\n}\n\n\nstatic ssize_t debugcmd_show(struct device *class_dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct pvr2_sysfs *sfp;\n\tsfp = dev_get_drvdata(class_dev);\n\tif (!sfp) return -EINVAL;\n\treturn pvr2_debugifc_print_status(sfp->channel.hdw,buf,PAGE_SIZE);\n}\n\n\nstatic ssize_t debugcmd_store(struct device *class_dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct pvr2_sysfs *sfp;\n\tint ret;\n\n\tsfp = dev_get_drvdata(class_dev);\n\tif (!sfp) return -EINVAL;\n\n\tret = pvr2_debugifc_docmd(sfp->channel.hdw,buf,count);\n\tif (ret < 0) return ret;\n\treturn count;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}