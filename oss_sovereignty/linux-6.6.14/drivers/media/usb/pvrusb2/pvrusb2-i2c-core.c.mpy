{
  "module_name": "pvrusb2-i2c-core.c",
  "hash_id": "556beb05f08cf0c0e1c6fd58e649a224a656bffb79299236f10a42d852eebab7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <media/i2c/ir-kbd-i2c.h>\n#include \"pvrusb2-i2c-core.h\"\n#include \"pvrusb2-hdw-internal.h\"\n#include \"pvrusb2-debug.h\"\n#include \"pvrusb2-fx2-cmd.h\"\n#include \"pvrusb2.h\"\n\n#define trace_i2c(...) pvr2_trace(PVR2_TRACE_I2C,__VA_ARGS__)\n\n \n\nstatic unsigned int i2c_scan;\nmodule_param(i2c_scan, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(i2c_scan,\"scan i2c bus at insmod time\");\n\nstatic int ir_mode[PVR_NUM] = { [0 ... PVR_NUM-1] = 1 };\nmodule_param_array(ir_mode, int, NULL, 0444);\nMODULE_PARM_DESC(ir_mode,\"specify: 0=disable IR reception, 1=normal IR\");\n\nstatic int pvr2_disable_ir_video;\nmodule_param_named(disable_autoload_ir_video, pvr2_disable_ir_video,\n\t\t   int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(disable_autoload_ir_video,\n\t\t \"1=do not try to autoload ir_video IR receiver\");\n\nstatic int pvr2_i2c_write(struct pvr2_hdw *hdw,  \n\t\t\t  u8 i2c_addr,       \n\t\t\t  u8 *data,          \n\t\t\t  u16 length)        \n{\n\t \n\tint ret;\n\n\n\tif (!data) length = 0;\n\tif (length > (sizeof(hdw->cmd_buffer) - 3)) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"Killing an I2C write to %u that is too large (desired=%u limit=%u)\",\n\t\t\t   i2c_addr,\n\t\t\t   length,(unsigned int)(sizeof(hdw->cmd_buffer) - 3));\n\t\treturn -ENOTSUPP;\n\t}\n\n\tLOCK_TAKE(hdw->ctl_lock);\n\n\t \n\tmemset(hdw->cmd_buffer, 0, sizeof(hdw->cmd_buffer));\n\n\t \n\thdw->cmd_buffer[0] = FX2CMD_I2C_WRITE;       \n\thdw->cmd_buffer[1] = i2c_addr;   \n\thdw->cmd_buffer[2] = length;     \n\tif (length) memcpy(hdw->cmd_buffer + 3, data, length);\n\n\t \n\tret = pvr2_send_request(hdw,\n\t\t\t\thdw->cmd_buffer,\n\t\t\t\tlength + 3,\n\t\t\t\thdw->cmd_buffer,\n\t\t\t\t1);\n\tif (!ret) {\n\t\tif (hdw->cmd_buffer[0] != 8) {\n\t\t\tret = -EIO;\n\t\t\tif (hdw->cmd_buffer[0] != 7) {\n\t\t\t\ttrace_i2c(\"unexpected status from i2_write[%d]: %d\",\n\t\t\t\t\t  i2c_addr,hdw->cmd_buffer[0]);\n\t\t\t}\n\t\t}\n\t}\n\n\tLOCK_GIVE(hdw->ctl_lock);\n\n\treturn ret;\n}\n\nstatic int pvr2_i2c_read(struct pvr2_hdw *hdw,  \n\t\t\t u8 i2c_addr,        \n\t\t\t u8 *data,           \n\t\t\t u16 dlen,           \n\t\t\t u8 *res,            \n\t\t\t u16 rlen)           \n{\n\t \n\tint ret;\n\n\n\tif (!data) dlen = 0;\n\tif (dlen > (sizeof(hdw->cmd_buffer) - 4)) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"Killing an I2C read to %u that has wlen too large (desired=%u limit=%u)\",\n\t\t\t   i2c_addr,\n\t\t\t   dlen,(unsigned int)(sizeof(hdw->cmd_buffer) - 4));\n\t\treturn -ENOTSUPP;\n\t}\n\tif (res && (rlen > (sizeof(hdw->cmd_buffer) - 1))) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"Killing an I2C read to %u that has rlen too large (desired=%u limit=%u)\",\n\t\t\t   i2c_addr,\n\t\t\t   rlen,(unsigned int)(sizeof(hdw->cmd_buffer) - 1));\n\t\treturn -ENOTSUPP;\n\t}\n\n\tLOCK_TAKE(hdw->ctl_lock);\n\n\t \n\tmemset(hdw->cmd_buffer, 0, sizeof(hdw->cmd_buffer));\n\n\t \n\thdw->cmd_buffer[0] = FX2CMD_I2C_READ;   \n\thdw->cmd_buffer[1] = dlen;   \n\thdw->cmd_buffer[2] = rlen;   \n\thdw->cmd_buffer[3] = i2c_addr;   \n\tif (dlen) memcpy(hdw->cmd_buffer + 4, data, dlen);\n\n\t \n\tret = pvr2_send_request(hdw,\n\t\t\t\thdw->cmd_buffer,\n\t\t\t\t4 + dlen,\n\t\t\t\thdw->cmd_buffer,\n\t\t\t\trlen + 1);\n\tif (!ret) {\n\t\tif (hdw->cmd_buffer[0] != 8) {\n\t\t\tret = -EIO;\n\t\t\tif (hdw->cmd_buffer[0] != 7) {\n\t\t\t\ttrace_i2c(\"unexpected status from i2_read[%d]: %d\",\n\t\t\t\t\t  i2c_addr,hdw->cmd_buffer[0]);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (res && rlen) {\n\t\tif (ret) {\n\t\t\t \n\t\t\tmemset(res, 0, rlen);\n\t\t} else {\n\t\t\tmemcpy(res, hdw->cmd_buffer + 1, rlen);\n\t\t}\n\t}\n\n\tLOCK_GIVE(hdw->ctl_lock);\n\n\treturn ret;\n}\n\n \nstatic int pvr2_i2c_basic_op(struct pvr2_hdw *hdw,\n\t\t\t     u8 i2c_addr,\n\t\t\t     u8 *wdata,\n\t\t\t     u16 wlen,\n\t\t\t     u8 *rdata,\n\t\t\t     u16 rlen)\n{\n\tif (!rdata) rlen = 0;\n\tif (!wdata) wlen = 0;\n\tif (rlen || !wlen) {\n\t\treturn pvr2_i2c_read(hdw,i2c_addr,wdata,wlen,rdata,rlen);\n\t} else {\n\t\treturn pvr2_i2c_write(hdw,i2c_addr,wdata,wlen);\n\t}\n}\n\n\n \nstatic int i2c_24xxx_ir(struct pvr2_hdw *hdw,\n\t\t\tu8 i2c_addr,u8 *wdata,u16 wlen,u8 *rdata,u16 rlen)\n{\n\tu8 dat[4];\n\tunsigned int stat;\n\n\tif (!(rlen || wlen)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tif ((wlen != 0) || (rlen == 0)) return -EIO;\n\n\tif (rlen < 3) {\n\t\t \n\t\tif (rlen > 0) rdata[0] = 0;\n\t\tif (rlen > 1) rdata[1] = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tLOCK_TAKE(hdw->ctl_lock); do {\n\t\thdw->cmd_buffer[0] = FX2CMD_GET_IR_CODE;\n\t\tstat = pvr2_send_request(hdw,\n\t\t\t\t\t hdw->cmd_buffer,1,\n\t\t\t\t\t hdw->cmd_buffer,4);\n\t\tdat[0] = hdw->cmd_buffer[0];\n\t\tdat[1] = hdw->cmd_buffer[1];\n\t\tdat[2] = hdw->cmd_buffer[2];\n\t\tdat[3] = hdw->cmd_buffer[3];\n\t} while (0); LOCK_GIVE(hdw->ctl_lock);\n\n\t \n\tif (stat != 0) return stat;\n\n\t \n\trdata[2] = 0xc1;\n\tif (dat[0] != 1) {\n\t\t \n\t\trdata[0] = 0;\n\t\trdata[1] = 0;\n\t} else {\n\t\tu16 val;\n\t\t \n\t\tval = dat[1];\n\t\tval <<= 8;\n\t\tval |= dat[2];\n\t\tval >>= 1;\n\t\tval &= ~0x0003;\n\t\tval |= 0x8000;\n\t\trdata[0] = (val >> 8) & 0xffu;\n\t\trdata[1] = val & 0xffu;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int i2c_hack_wm8775(struct pvr2_hdw *hdw,\n\t\t\t   u8 i2c_addr,u8 *wdata,u16 wlen,u8 *rdata,u16 rlen)\n{\n\tif (!(rlen || wlen)) {\n\t\t\n\t\treturn 0;\n\t}\n\treturn pvr2_i2c_basic_op(hdw,i2c_addr,wdata,wlen,rdata,rlen);\n}\n\n \nstatic int i2c_black_hole(struct pvr2_hdw *hdw,\n\t\t\t   u8 i2c_addr,u8 *wdata,u16 wlen,u8 *rdata,u16 rlen)\n{\n\treturn -EIO;\n}\n\n \nstatic int i2c_hack_cx25840(struct pvr2_hdw *hdw,\n\t\t\t    u8 i2c_addr,u8 *wdata,u16 wlen,u8 *rdata,u16 rlen)\n{\n\tint ret;\n\tunsigned int subaddr;\n\tu8 wbuf[2];\n\tint state = hdw->i2c_cx25840_hack_state;\n\n\tif (!(rlen || wlen)) {\n\t\t\n\t\t\n\t\t\n\t\treturn 0;\n\t}\n\n\tif (state == 3) {\n\t\treturn pvr2_i2c_basic_op(hdw,i2c_addr,wdata,wlen,rdata,rlen);\n\t}\n\n\t \n\n\tif (wlen == 0) {\n\t\tswitch (state) {\n\t\tcase 1: subaddr = 0x0100; break;\n\t\tcase 2: subaddr = 0x0101; break;\n\t\tdefault: goto fail;\n\t\t}\n\t} else if (wlen == 2) {\n\t\tsubaddr = (wdata[0] << 8) | wdata[1];\n\t\tswitch (subaddr) {\n\t\tcase 0x0100: state = 1; break;\n\t\tcase 0x0101: state = 2; break;\n\t\tdefault: goto fail;\n\t\t}\n\t} else {\n\t\tgoto fail;\n\t}\n\tif (!rlen) goto success;\n\tstate = 0;\n\tif (rlen != 1) goto fail;\n\n\t \n\twbuf[0] = subaddr >> 8;\n\twbuf[1] = subaddr;\n\tret = pvr2_i2c_basic_op(hdw,i2c_addr,wbuf,2,rdata,rlen);\n\n\tif ((ret != 0) || (*rdata == 0x04) || (*rdata == 0x0a)) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"***WARNING*** Detected a wedged cx25840 chip; the device will not work.\");\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"***WARNING*** Try power cycling the pvrusb2 device.\");\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"***WARNING*** Disabling further access to the device to prevent other foul-ups.\");\n\t\t\n\t\thdw->i2c_func[0x44] = NULL;\n\t\tpvr2_hdw_render_useless(hdw);\n\t\tgoto fail;\n\t}\n\n\t \n\tpvr2_trace(PVR2_TRACE_CHIPS,\"cx25840 appears to be OK.\");\n\tstate = 3;\n\n success:\n\thdw->i2c_cx25840_hack_state = state;\n\treturn 0;\n\n fail:\n\thdw->i2c_cx25840_hack_state = state;\n\treturn -EIO;\n}\n\n \nstatic int pvr2_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t struct i2c_msg msgs[],\n\t\t\t int num)\n{\n\tint ret = -ENOTSUPP;\n\tpvr2_i2c_func funcp = NULL;\n\tstruct pvr2_hdw *hdw = (struct pvr2_hdw *)(i2c_adap->algo_data);\n\n\tif (!num) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\tif (msgs[0].addr < PVR2_I2C_FUNC_CNT) {\n\t\tfuncp = hdw->i2c_func[msgs[0].addr];\n\t}\n\tif (!funcp) {\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (num == 1) {\n\t\tif (msgs[0].flags & I2C_M_RD) {\n\t\t\t \n\t\t\tu16 tcnt,bcnt,offs;\n\t\t\tif (!msgs[0].len) {\n\t\t\t\t \n\t\t\t\tif (funcp(hdw,msgs[0].addr,NULL,0,NULL,0)) {\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tret = 1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t \n\t\t\ttcnt = msgs[0].len;\n\t\t\toffs = 0;\n\t\t\twhile (tcnt) {\n\t\t\t\tbcnt = tcnt;\n\t\t\t\tif (bcnt > sizeof(hdw->cmd_buffer)-1) {\n\t\t\t\t\tbcnt = sizeof(hdw->cmd_buffer)-1;\n\t\t\t\t}\n\t\t\t\tif (funcp(hdw,msgs[0].addr,NULL,0,\n\t\t\t\t\t  msgs[0].buf+offs,bcnt)) {\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\toffs += bcnt;\n\t\t\t\ttcnt -= bcnt;\n\t\t\t}\n\t\t\tret = 1;\n\t\t\tgoto done;\n\t\t} else {\n\t\t\t \n\t\t\tret = 1;\n\t\t\tif (funcp(hdw,msgs[0].addr,\n\t\t\t\t  msgs[0].buf,msgs[0].len,NULL,0)) {\n\t\t\t\tret = -EIO;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\t} else if (num == 2) {\n\t\tif (msgs[0].addr != msgs[1].addr) {\n\t\t\ttrace_i2c(\"i2c refusing 2 phase transfer with conflicting target addresses\");\n\t\t\tret = -ENOTSUPP;\n\t\t\tgoto done;\n\t\t}\n\t\tif ((!((msgs[0].flags & I2C_M_RD))) &&\n\t\t    (msgs[1].flags & I2C_M_RD)) {\n\t\t\tu16 tcnt,bcnt,wcnt,offs;\n\t\t\t \n\t\t\ttcnt = msgs[1].len;\n\t\t\twcnt = msgs[0].len;\n\t\t\toffs = 0;\n\t\t\twhile (tcnt || wcnt) {\n\t\t\t\tbcnt = tcnt;\n\t\t\t\tif (bcnt > sizeof(hdw->cmd_buffer)-1) {\n\t\t\t\t\tbcnt = sizeof(hdw->cmd_buffer)-1;\n\t\t\t\t}\n\t\t\t\tif (funcp(hdw,msgs[0].addr,\n\t\t\t\t\t  msgs[0].buf,wcnt,\n\t\t\t\t\t  msgs[1].buf+offs,bcnt)) {\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\toffs += bcnt;\n\t\t\t\ttcnt -= bcnt;\n\t\t\t\twcnt = 0;\n\t\t\t}\n\t\t\tret = 2;\n\t\t\tgoto done;\n\t\t} else {\n\t\t\ttrace_i2c(\"i2c refusing complex transfer read0=%d read1=%d\",\n\t\t\t\t  (msgs[0].flags & I2C_M_RD),\n\t\t\t\t  (msgs[1].flags & I2C_M_RD));\n\t\t}\n\t} else {\n\t\ttrace_i2c(\"i2c refusing %d phase transfer\",num);\n\t}\n\n done:\n\tif (pvrusb2_debug & PVR2_TRACE_I2C_TRAF) {\n\t\tunsigned int idx,offs,cnt;\n\t\tfor (idx = 0; idx < num; idx++) {\n\t\t\tcnt = msgs[idx].len;\n\t\t\tpr_info(\"pvrusb2 i2c xfer %u/%u: addr=0x%x len=%d %s\",\n\t\t\t       idx+1,num,\n\t\t\t       msgs[idx].addr,\n\t\t\t       cnt,\n\t\t\t       (msgs[idx].flags & I2C_M_RD ?\n\t\t\t\t\"read\" : \"write\"));\n\t\t\tif ((ret > 0) || !(msgs[idx].flags & I2C_M_RD)) {\n\t\t\t\tif (cnt > 8) cnt = 8;\n\t\t\t\tpr_cont(\" [\");\n\t\t\t\tfor (offs = 0; offs < cnt; offs++) {\n\t\t\t\t\tif (offs) pr_cont(\" \");\n\t\t\t\t\tpr_cont(\"%02x\", msgs[idx].buf[offs]);\n\t\t\t\t}\n\t\t\t\tif (offs < cnt) pr_cont(\" ...\");\n\t\t\t\tpr_cont(\"]\");\n\t\t\t}\n\t\t\tif (idx+1 == num) {\n\t\t\t\tpr_cont(\" result=%d\", ret);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tif (!num) {\n\t\t\tpr_info(\"pvrusb2 i2c xfer null transfer result=%d\\n\",\n\t\t\t       ret);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic u32 pvr2_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_SMBUS_EMUL | I2C_FUNC_I2C;\n}\n\nstatic const struct i2c_algorithm pvr2_i2c_algo_template = {\n\t.master_xfer   = pvr2_i2c_xfer,\n\t.functionality = pvr2_i2c_functionality,\n};\n\nstatic const struct i2c_adapter pvr2_i2c_adap_template = {\n\t.owner         = THIS_MODULE,\n\t.class\t       = 0,\n};\n\n\n \nstatic int do_i2c_probe(struct pvr2_hdw *hdw, int addr)\n{\n\tstruct i2c_msg msg[1];\n\tint rc;\n\tmsg[0].addr = 0;\n\tmsg[0].flags = I2C_M_RD;\n\tmsg[0].len = 0;\n\tmsg[0].buf = NULL;\n\tmsg[0].addr = addr;\n\trc = i2c_transfer(&hdw->i2c_adap, msg, ARRAY_SIZE(msg));\n\treturn rc == 1;\n}\n\nstatic void do_i2c_scan(struct pvr2_hdw *hdw)\n{\n\tint i;\n\tpr_info(\"%s: i2c scan beginning\\n\", hdw->name);\n\tfor (i = 0; i < 128; i++) {\n\t\tif (do_i2c_probe(hdw, i)) {\n\t\t\tpr_info(\"%s: i2c scan: found device @ 0x%x\\n\",\n\t\t\t       hdw->name, i);\n\t\t}\n\t}\n\tpr_info(\"%s: i2c scan done.\\n\", hdw->name);\n}\n\nstatic void pvr2_i2c_register_ir(struct pvr2_hdw *hdw)\n{\n\tstruct i2c_board_info info;\n\tstruct IR_i2c_init_data *init_data = &hdw->ir_init_data;\n\tif (pvr2_disable_ir_video) {\n\t\tpvr2_trace(PVR2_TRACE_INFO,\n\t\t\t   \"Automatic binding of ir_video has been disabled.\");\n\t\treturn;\n\t}\n\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\tswitch (hdw->ir_scheme_active) {\n\tcase PVR2_IR_SCHEME_24XXX:  \n\tcase PVR2_IR_SCHEME_29XXX:  \n\t\tinit_data->ir_codes              = RC_MAP_HAUPPAUGE;\n\t\tinit_data->internal_get_key_func = IR_KBD_GET_KEY_HAUP;\n\t\tinit_data->type                  = RC_PROTO_BIT_RC5;\n\t\tinit_data->name                  = hdw->hdw_desc->description;\n\t\tinit_data->polling_interval      = 100;  \n\t\t \n\t\tinfo.addr          = 0x18;\n\t\tinfo.platform_data = init_data;\n\t\tstrscpy(info.type, \"ir_video\", I2C_NAME_SIZE);\n\t\tpvr2_trace(PVR2_TRACE_INFO, \"Binding %s to i2c address 0x%02x.\",\n\t\t\t   info.type, info.addr);\n\t\ti2c_new_client_device(&hdw->i2c_adap, &info);\n\t\tbreak;\n\tcase PVR2_IR_SCHEME_ZILOG:      \n\tcase PVR2_IR_SCHEME_24XXX_MCE:  \n\t\tinit_data->ir_codes = RC_MAP_HAUPPAUGE;\n\t\tinit_data->internal_get_key_func = IR_KBD_GET_KEY_HAUP_XVR;\n\t\tinit_data->type = RC_PROTO_BIT_RC5 | RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t\t\tRC_PROTO_BIT_RC6_6A_32;\n\t\tinit_data->name = hdw->hdw_desc->description;\n\t\t \n\t\tinfo.addr = 0x71;\n\t\tinfo.platform_data = init_data;\n\t\tstrscpy(info.type, \"ir_z8f0811_haup\", I2C_NAME_SIZE);\n\t\tpvr2_trace(PVR2_TRACE_INFO, \"Binding %s to i2c address 0x%02x.\",\n\t\t\t   info.type, info.addr);\n\t\ti2c_new_client_device(&hdw->i2c_adap, &info);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\nvoid pvr2_i2c_core_init(struct pvr2_hdw *hdw)\n{\n\tunsigned int idx;\n\n\t \n\tfor (idx = 0; idx < PVR2_I2C_FUNC_CNT; idx++) {\n\t\thdw->i2c_func[idx] = pvr2_i2c_basic_op;\n\t}\n\n\t \n\tif (ir_mode[hdw->unit_number] == 0) {\n\t\tpr_info(\"%s: IR disabled\\n\", hdw->name);\n\t\thdw->i2c_func[0x18] = i2c_black_hole;\n\t} else if (ir_mode[hdw->unit_number] == 1) {\n\t\tif (hdw->ir_scheme_active == PVR2_IR_SCHEME_24XXX) {\n\t\t\t \n\t\t\thdw->i2c_func[0x18] = i2c_24xxx_ir;\n\t\t}\n\t}\n\tif (hdw->hdw_desc->flag_has_cx25840) {\n\t\thdw->i2c_func[0x44] = i2c_hack_cx25840;\n\t}\n\tif (hdw->hdw_desc->flag_has_wm8775) {\n\t\thdw->i2c_func[0x1b] = i2c_hack_wm8775;\n\t}\n\n\t\n\thdw->i2c_adap = pvr2_i2c_adap_template;\n\thdw->i2c_algo = pvr2_i2c_algo_template;\n\tstrscpy(hdw->i2c_adap.name, hdw->name, sizeof(hdw->i2c_adap.name));\n\thdw->i2c_adap.dev.parent = &hdw->usb_dev->dev;\n\thdw->i2c_adap.algo = &hdw->i2c_algo;\n\thdw->i2c_adap.algo_data = hdw;\n\thdw->i2c_linked = !0;\n\ti2c_set_adapdata(&hdw->i2c_adap, &hdw->v4l2_dev);\n\ti2c_add_adapter(&hdw->i2c_adap);\n\tif (hdw->i2c_func[0x18] == i2c_24xxx_ir) {\n\t\t \n\t\tif (do_i2c_probe(hdw, 0x71)) {\n\t\t\tpvr2_trace(PVR2_TRACE_INFO,\n\t\t\t\t   \"Device has newer IR hardware; disabling unneeded virtual IR device\");\n\t\t\thdw->i2c_func[0x18] = NULL;\n\t\t\t \n\t\t\thdw->ir_scheme_active = PVR2_IR_SCHEME_24XXX_MCE;\n\t\t}\n\t}\n\tif (i2c_scan) do_i2c_scan(hdw);\n\n\tpvr2_i2c_register_ir(hdw);\n}\n\nvoid pvr2_i2c_core_done(struct pvr2_hdw *hdw)\n{\n\tif (hdw->i2c_linked) {\n\t\ti2c_del_adapter(&hdw->i2c_adap);\n\t\thdw->i2c_linked = 0;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}