{
  "module_name": "pvrusb2-hdw-internal.h",
  "hash_id": "6fb8618f95ae126de03c8a53711830cc64459d01e7ff31eaf8270621ad70a389",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h",
  "human_readable_source": " \n \n#ifndef __PVRUSB2_HDW_INTERNAL_H\n#define __PVRUSB2_HDW_INTERNAL_H\n\n \n\n#include <linux/videodev2.h>\n#include <linux/i2c.h>\n#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include \"pvrusb2-hdw.h\"\n#include \"pvrusb2-io.h\"\n#include <media/v4l2-device.h>\n#include <media/drv-intf/cx2341x.h>\n#include <media/i2c/ir-kbd-i2c.h>\n#include \"pvrusb2-devattr.h\"\n\n \n#define PVR2_CVAL_HSM_FAIL 0\n#define PVR2_CVAL_HSM_FULL 1\n#define PVR2_CVAL_HSM_HIGH 2\n\n#define PVR2_VID_ENDPOINT        0x84\n#define PVR2_UNK_ENDPOINT        0x86     \n#define PVR2_VBI_ENDPOINT        0x88\n\n#define PVR2_CTL_BUFFSIZE        64\n\n#define FREQTABLE_SIZE 500\n\n#define LOCK_TAKE(x) do { mutex_lock(&x##_mutex); x##_held = !0; } while (0)\n#define LOCK_GIVE(x) do { x##_held = 0; mutex_unlock(&x##_mutex); } while (0)\n\ntypedef int (*pvr2_ctlf_is_dirty)(struct pvr2_ctrl *);\ntypedef void (*pvr2_ctlf_clear_dirty)(struct pvr2_ctrl *);\ntypedef int (*pvr2_ctlf_check_value)(struct pvr2_ctrl *,int);\ntypedef int (*pvr2_ctlf_get_value)(struct pvr2_ctrl *,int *);\ntypedef int (*pvr2_ctlf_set_value)(struct pvr2_ctrl *,int msk,int val);\ntypedef int (*pvr2_ctlf_val_to_sym)(struct pvr2_ctrl *,int msk,int val,\n\t\t\t\t    char *,unsigned int,unsigned int *);\ntypedef int (*pvr2_ctlf_sym_to_val)(struct pvr2_ctrl *,\n\t\t\t\t    const char *,unsigned int,\n\t\t\t\t    int *mskp,int *valp);\ntypedef unsigned int (*pvr2_ctlf_get_v4lflags)(struct pvr2_ctrl *);\n\n \nstruct pvr2_ctl_info {\n\t \n\tconst char *name;\n\n\t \n\tconst char *desc;\n\n\t \n\tpvr2_ctlf_get_value get_value;       \n\tpvr2_ctlf_get_value get_def_value;   \n\tpvr2_ctlf_get_value get_min_value;   \n\tpvr2_ctlf_get_value get_max_value;   \n\tpvr2_ctlf_set_value set_value;       \n\tpvr2_ctlf_check_value check_value;   \n\tpvr2_ctlf_val_to_sym val_to_sym;     \n\tpvr2_ctlf_sym_to_val sym_to_val;     \n\tpvr2_ctlf_is_dirty is_dirty;         \n\tpvr2_ctlf_clear_dirty clear_dirty;   \n\tpvr2_ctlf_get_v4lflags get_v4lflags; \n\n\t \n\tenum pvr2_ctl_type type;\n\n\t \n\tint v4l_id;\n\n\t \n\tint internal_id;\n\n\t \n\tint skip_init;\n\n\t \n\tint default_value;\n\n\t \n\tunion {\n\t\tstruct {  \n\t\t\tlong min_value;  \n\t\t\tlong max_value;  \n\t\t} type_int;\n\t\tstruct {  \n\t\t\tunsigned int count;        \n\t\t\tconst char * const *value_names;  \n\t\t} type_enum;\n\t\tstruct {  \n\t\t\tunsigned int valid_bits;  \n\t\t\tconst char **bit_names;   \n\t\t} type_bitmask;\n\t} def;\n};\n\n\n \n#define PVR2_CTLD_INFO_DESC_SIZE 32\nstruct pvr2_ctld_info {\n\tstruct pvr2_ctl_info info;\n\tchar desc[PVR2_CTLD_INFO_DESC_SIZE];\n};\n\nstruct pvr2_ctrl {\n\tconst struct pvr2_ctl_info *info;\n\tstruct pvr2_hdw *hdw;\n};\n\n\n\n \n#define FW1_STATE_UNKNOWN 0\n#define FW1_STATE_MISSING 1\n#define FW1_STATE_FAILED 2\n#define FW1_STATE_RELOAD 3\n#define FW1_STATE_OK 4\n\n \n#define PVR2_PATHWAY_UNKNOWN 0\n#define PVR2_PATHWAY_ANALOG 1\n#define PVR2_PATHWAY_DIGITAL 2\n\ntypedef int (*pvr2_i2c_func)(struct pvr2_hdw *,u8,u8 *,u16,u8 *, u16);\n#define PVR2_I2C_FUNC_CNT 128\n\n \nstruct pvr2_hdw {\n\t \n\tstruct usb_device *usb_dev;\n\tstruct usb_interface *usb_intf;\n\n\t \n\tstruct v4l2_device v4l2_dev;\n\t \n\tconst struct pvr2_device_desc *hdw_desc;\n\n\t \n\tstruct work_struct workpoll;      \n\n\t \n\tstruct pvr2_stream *vid_stream;\n\n\t \n\tstruct mutex big_lock_mutex;\n\tint big_lock_held;   \n\n\t \n\tchar name[32];\n\n\t \n\tchar identifier[32];\n\n\t \n\tstruct i2c_adapter i2c_adap;\n\tstruct i2c_algorithm i2c_algo;\n\tpvr2_i2c_func i2c_func[PVR2_I2C_FUNC_CNT];\n\tint i2c_cx25840_hack_state;\n\tint i2c_linked;\n\n\t \n\tunsigned int ir_scheme_active;  \n\tstruct IR_i2c_init_data ir_init_data;  \n\n\t \n\tunsigned int freqTable[FREQTABLE_SIZE];\n\tunsigned int freqProgSlot;\n\n\t \n\tstruct mutex ctl_lock_mutex;\n\tint ctl_lock_held;   \n\tstruct urb *ctl_write_urb;\n\tstruct urb *ctl_read_urb;\n\tunsigned char *ctl_write_buffer;\n\tunsigned char *ctl_read_buffer;\n\tint ctl_write_pend_flag;\n\tint ctl_read_pend_flag;\n\tint ctl_timeout_flag;\n\tstruct completion ctl_done;\n\tunsigned char cmd_buffer[PVR2_CTL_BUFFSIZE];\n\tint cmd_debug_state;               \n\tunsigned char cmd_debug_code;      \n\tunsigned int cmd_debug_write_len;  \n\tunsigned int cmd_debug_read_len;   \n\n\t \n\tint state_pathway_ok;          \n\tint state_encoder_ok;          \n\tint state_encoder_run;         \n\tint state_encoder_config;      \n\tint state_encoder_waitok;      \n\tint state_encoder_runok;       \n\tint state_decoder_run;         \n\tint state_decoder_ready;       \n\tint state_usbstream_run;       \n\tint state_decoder_quiescent;   \n\tint state_pipeline_config;     \n\tint state_pipeline_req;        \n\tint state_pipeline_pause;      \n\tint state_pipeline_idle;       \n\n\t \n\tunsigned int master_state;\n\n\t \n\tint led_on;\n\n\t \n\tint state_stale;\n\n\tvoid (*state_func)(void *);\n\tvoid *state_data;\n\n\t \n\tstruct timer_list quiescent_timer;\n\n\t \n\tstruct timer_list decoder_stabilization_timer;\n\n\t \n\tstruct timer_list encoder_wait_timer;\n\n\t \n\tstruct timer_list encoder_run_timer;\n\n\t \n\twait_queue_head_t state_wait_data;\n\n\n\tint force_dirty;         \n\tint flag_ok;             \n\tint flag_modulefail;     \n\tint flag_disconnected;   \n\tint flag_init_ok;        \n\tint fw1_state;           \n\tint pathway_state;       \n\tint flag_decoder_missed; \n\tint flag_tripped;        \n\n\tunsigned int decoder_client_id;\n\n\t\n\tchar *fw_buffer;\n\tunsigned int fw_size;\n\tint fw_cpu_flag;  \n\n\t \n\tunsigned int tuner_type;\n\tint tuner_updated;\n\tunsigned int freqValTelevision;   \n\tunsigned int freqValRadio;        \n\tunsigned int freqSlotTelevision;  \n\tunsigned int freqSlotRadio;       \n\tunsigned int freqSelector;        \n\tint freqDirty;\n\n\t \n\tstruct v4l2_tuner tuner_signal_info;\n\tint tuner_signal_stale;\n\n\t \n\tstruct v4l2_cropcap cropcap_info;\n\tint cropcap_stale;\n\n\t \n\tv4l2_std_id std_mask_eeprom; \n\tv4l2_std_id std_mask_avail;  \n\tv4l2_std_id std_mask_cur;    \n\tint std_enum_cur;            \n\tint std_dirty;               \n\tstruct pvr2_ctl_info std_info_enum;\n\tstruct pvr2_ctl_info std_info_avail;\n\tstruct pvr2_ctl_info std_info_cur;\n\tstruct pvr2_ctl_info std_info_detect;\n\n\t\n\tconst char *std_mask_ptrs[32];\n\tchar std_mask_names[32][16];\n\n\tint unit_number;              \n\tunsigned long serial_number;  \n\n\tchar bus_info[32];  \n\n\t \n\tint v4l_minor_number_video;\n\tint v4l_minor_number_vbi;\n\tint v4l_minor_number_radio;\n\n\t \n\tunsigned int input_avail_mask;\n\t \n\tunsigned int input_allowed_mask;\n\n\t \n\tint eeprom_addr;\n\n\tenum pvr2_config active_stream_type;\n\tenum pvr2_config desired_stream_type;\n\n\t \n\tstruct cx2341x_mpeg_params enc_cur_state;\n\tstruct cx2341x_mpeg_params enc_ctl_state;\n\t \n\tint enc_stale;\n\t \n\tint enc_unsafe_stale;\n\t \n\tint enc_cur_valid;\n\n\t \n#define VCREATE_DATA(lab) int lab##_val; int lab##_dirty\n\tVCREATE_DATA(brightness);\n\tVCREATE_DATA(contrast);\n\tVCREATE_DATA(saturation);\n\tVCREATE_DATA(hue);\n\tVCREATE_DATA(volume);\n\tVCREATE_DATA(balance);\n\tVCREATE_DATA(bass);\n\tVCREATE_DATA(treble);\n\tVCREATE_DATA(mute);\n\tVCREATE_DATA(cropl);\n\tVCREATE_DATA(cropt);\n\tVCREATE_DATA(cropw);\n\tVCREATE_DATA(croph);\n\tVCREATE_DATA(input);\n\tVCREATE_DATA(audiomode);\n\tVCREATE_DATA(res_hor);\n\tVCREATE_DATA(res_ver);\n\tVCREATE_DATA(srate);\n#undef VCREATE_DATA\n\n\tstruct pvr2_ctld_info *mpeg_ctrl_info;\n\n\tstruct pvr2_ctrl *controls;\n\tunsigned int control_cnt;\n};\n\n \nunsigned long pvr2_hdw_get_cur_freq(struct pvr2_hdw *);\n\nvoid pvr2_hdw_status_poll(struct pvr2_hdw *);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}