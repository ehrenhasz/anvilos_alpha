{
  "module_name": "pvrusb2-hdw.c",
  "hash_id": "cdc69a19757f5ef65f9ddcfd56d5489bb21eaa668f9d4c408cc8208aab82ce21",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/pvrusb2/pvrusb2-hdw.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-common.h>\n#include <media/tuner.h>\n#include \"pvrusb2.h\"\n#include \"pvrusb2-std.h\"\n#include \"pvrusb2-util.h\"\n#include \"pvrusb2-hdw.h\"\n#include \"pvrusb2-i2c-core.h\"\n#include \"pvrusb2-eeprom.h\"\n#include \"pvrusb2-hdw-internal.h\"\n#include \"pvrusb2-encoder.h\"\n#include \"pvrusb2-debug.h\"\n#include \"pvrusb2-fx2-cmd.h\"\n#include \"pvrusb2-wm8775.h\"\n#include \"pvrusb2-video-v4l.h\"\n#include \"pvrusb2-cx2584x-v4l.h\"\n#include \"pvrusb2-cs53l32a.h\"\n#include \"pvrusb2-audio.h\"\n\n#define TV_MIN_FREQ     55250000L\n#define TV_MAX_FREQ    850000000L\n\n \n#define TIME_MSEC_DECODER_WAIT 50\n\n \n#define TIME_MSEC_DECODER_STABILIZATION_WAIT 300\n\n \n#define TIME_MSEC_ENCODER_WAIT 50\n\n \n#define TIME_MSEC_ENCODER_OK 250\n\nstatic struct pvr2_hdw *unit_pointers[PVR_NUM] = {[ 0 ... PVR_NUM-1 ] = NULL};\nstatic DEFINE_MUTEX(pvr2_unit_mtx);\n\nstatic int ctlchg;\nstatic int procreload;\nstatic int tuner[PVR_NUM] = { [0 ... PVR_NUM-1] = -1 };\nstatic int tolerance[PVR_NUM] = { [0 ... PVR_NUM-1] = 0 };\nstatic int video_std[PVR_NUM] = { [0 ... PVR_NUM-1] = 0 };\nstatic int init_pause_msec;\n\nmodule_param(ctlchg, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(ctlchg, \"0=optimize ctl change 1=always accept new ctl value\");\nmodule_param(init_pause_msec, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(init_pause_msec, \"hardware initialization settling delay\");\nmodule_param(procreload, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(procreload,\n\t\t \"Attempt init failure recovery with firmware reload\");\nmodule_param_array(tuner,    int, NULL, 0444);\nMODULE_PARM_DESC(tuner,\"specify installed tuner type\");\nmodule_param_array(video_std,    int, NULL, 0444);\nMODULE_PARM_DESC(video_std,\"specify initial video standard\");\nmodule_param_array(tolerance,    int, NULL, 0444);\nMODULE_PARM_DESC(tolerance,\"specify stream error tolerance\");\n\n \nstatic int default_tv_freq    = 61250000L;\n \nstatic int default_radio_freq = 104300000L;\n\nmodule_param_named(tv_freq, default_tv_freq, int, 0444);\nMODULE_PARM_DESC(tv_freq, \"specify initial television frequency\");\nmodule_param_named(radio_freq, default_radio_freq, int, 0444);\nMODULE_PARM_DESC(radio_freq, \"specify initial radio frequency\");\n\n#define PVR2_CTL_WRITE_ENDPOINT  0x01\n#define PVR2_CTL_READ_ENDPOINT   0x81\n\n#define PVR2_GPIO_IN 0x9008\n#define PVR2_GPIO_OUT 0x900c\n#define PVR2_GPIO_DIR 0x9020\n\n#define trace_firmware(...) pvr2_trace(PVR2_TRACE_FIRMWARE,__VA_ARGS__)\n\n#define PVR2_FIRMWARE_ENDPOINT   0x02\n\n \n#define FIRMWARE_CHUNK_SIZE 0x2000\n\ntypedef void (*pvr2_subdev_update_func)(struct pvr2_hdw *,\n\t\t\t\t\tstruct v4l2_subdev *);\n\nstatic const pvr2_subdev_update_func pvr2_module_update_functions[] = {\n\t[PVR2_CLIENT_ID_WM8775] = pvr2_wm8775_subdev_update,\n\t[PVR2_CLIENT_ID_SAA7115] = pvr2_saa7115_subdev_update,\n\t[PVR2_CLIENT_ID_MSP3400] = pvr2_msp3400_subdev_update,\n\t[PVR2_CLIENT_ID_CX25840] = pvr2_cx25840_subdev_update,\n\t[PVR2_CLIENT_ID_CS53L32A] = pvr2_cs53l32a_subdev_update,\n};\n\nstatic const char *module_names[] = {\n\t[PVR2_CLIENT_ID_MSP3400] = \"msp3400\",\n\t[PVR2_CLIENT_ID_CX25840] = \"cx25840\",\n\t[PVR2_CLIENT_ID_SAA7115] = \"saa7115\",\n\t[PVR2_CLIENT_ID_TUNER] = \"tuner\",\n\t[PVR2_CLIENT_ID_DEMOD] = \"tuner\",\n\t[PVR2_CLIENT_ID_CS53L32A] = \"cs53l32a\",\n\t[PVR2_CLIENT_ID_WM8775] = \"wm8775\",\n};\n\n\nstatic const unsigned char *module_i2c_addresses[] = {\n\t[PVR2_CLIENT_ID_TUNER] = \"\\x60\\x61\\x62\\x63\",\n\t[PVR2_CLIENT_ID_DEMOD] = \"\\x43\",\n\t[PVR2_CLIENT_ID_MSP3400] = \"\\x40\",\n\t[PVR2_CLIENT_ID_SAA7115] = \"\\x21\",\n\t[PVR2_CLIENT_ID_WM8775] = \"\\x1b\",\n\t[PVR2_CLIENT_ID_CX25840] = \"\\x44\",\n\t[PVR2_CLIENT_ID_CS53L32A] = \"\\x11\",\n};\n\n\nstatic const char *ir_scheme_names[] = {\n\t[PVR2_IR_SCHEME_NONE] = \"none\",\n\t[PVR2_IR_SCHEME_29XXX] = \"29xxx\",\n\t[PVR2_IR_SCHEME_24XXX] = \"24xxx (29xxx emulation)\",\n\t[PVR2_IR_SCHEME_24XXX_MCE] = \"24xxx (MCE device)\",\n\t[PVR2_IR_SCHEME_ZILOG] = \"Zilog\",\n};\n\n\n \nstruct pvr2_mpeg_ids {\n\tconst char *strid;\n\tint id;\n};\nstatic const struct pvr2_mpeg_ids mpeg_ids[] = {\n\t{\n\t\t.strid = \"audio_layer\",\n\t\t.id = V4L2_CID_MPEG_AUDIO_ENCODING,\n\t},{\n\t\t.strid = \"audio_bitrate\",\n\t\t.id = V4L2_CID_MPEG_AUDIO_L2_BITRATE,\n\t},{\n\t\t \n\t\t.strid = \"mpeg_audio_mode\",\n\t\t.id = V4L2_CID_MPEG_AUDIO_MODE,\n\t},{\n\t\t.strid = \"mpeg_audio_mode_extension\",\n\t\t.id = V4L2_CID_MPEG_AUDIO_MODE_EXTENSION,\n\t},{\n\t\t.strid = \"audio_emphasis\",\n\t\t.id = V4L2_CID_MPEG_AUDIO_EMPHASIS,\n\t},{\n\t\t.strid = \"audio_crc\",\n\t\t.id = V4L2_CID_MPEG_AUDIO_CRC,\n\t},{\n\t\t.strid = \"video_aspect\",\n\t\t.id = V4L2_CID_MPEG_VIDEO_ASPECT,\n\t},{\n\t\t.strid = \"video_b_frames\",\n\t\t.id = V4L2_CID_MPEG_VIDEO_B_FRAMES,\n\t},{\n\t\t.strid = \"video_gop_size\",\n\t\t.id = V4L2_CID_MPEG_VIDEO_GOP_SIZE,\n\t},{\n\t\t.strid = \"video_gop_closure\",\n\t\t.id = V4L2_CID_MPEG_VIDEO_GOP_CLOSURE,\n\t},{\n\t\t.strid = \"video_bitrate_mode\",\n\t\t.id = V4L2_CID_MPEG_VIDEO_BITRATE_MODE,\n\t},{\n\t\t.strid = \"video_bitrate\",\n\t\t.id = V4L2_CID_MPEG_VIDEO_BITRATE,\n\t},{\n\t\t.strid = \"video_bitrate_peak\",\n\t\t.id = V4L2_CID_MPEG_VIDEO_BITRATE_PEAK,\n\t},{\n\t\t.strid = \"video_temporal_decimation\",\n\t\t.id = V4L2_CID_MPEG_VIDEO_TEMPORAL_DECIMATION,\n\t},{\n\t\t.strid = \"stream_type\",\n\t\t.id = V4L2_CID_MPEG_STREAM_TYPE,\n\t},{\n\t\t.strid = \"video_spatial_filter_mode\",\n\t\t.id = V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE,\n\t},{\n\t\t.strid = \"video_spatial_filter\",\n\t\t.id = V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER,\n\t},{\n\t\t.strid = \"video_luma_spatial_filter_type\",\n\t\t.id = V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE,\n\t},{\n\t\t.strid = \"video_chroma_spatial_filter_type\",\n\t\t.id = V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE,\n\t},{\n\t\t.strid = \"video_temporal_filter_mode\",\n\t\t.id = V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE,\n\t},{\n\t\t.strid = \"video_temporal_filter\",\n\t\t.id = V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER,\n\t},{\n\t\t.strid = \"video_median_filter_type\",\n\t\t.id = V4L2_CID_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE,\n\t},{\n\t\t.strid = \"video_luma_median_filter_top\",\n\t\t.id = V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_TOP,\n\t},{\n\t\t.strid = \"video_luma_median_filter_bottom\",\n\t\t.id = V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_BOTTOM,\n\t},{\n\t\t.strid = \"video_chroma_median_filter_top\",\n\t\t.id = V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_TOP,\n\t},{\n\t\t.strid = \"video_chroma_median_filter_bottom\",\n\t\t.id = V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_BOTTOM,\n\t}\n};\n#define MPEGDEF_COUNT ARRAY_SIZE(mpeg_ids)\n\n\nstatic const char *control_values_srate[] = {\n\t[V4L2_MPEG_AUDIO_SAMPLING_FREQ_44100]   = \"44.1 kHz\",\n\t[V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000]   = \"48 kHz\",\n\t[V4L2_MPEG_AUDIO_SAMPLING_FREQ_32000]   = \"32 kHz\",\n};\n\n\n\nstatic const char *control_values_input[] = {\n\t[PVR2_CVAL_INPUT_TV]        = \"television\",   \n\t[PVR2_CVAL_INPUT_DTV]       = \"dtv\",\n\t[PVR2_CVAL_INPUT_RADIO]     = \"radio\",\n\t[PVR2_CVAL_INPUT_SVIDEO]    = \"s-video\",\n\t[PVR2_CVAL_INPUT_COMPOSITE] = \"composite\",\n};\n\n\nstatic const char *control_values_audiomode[] = {\n\t[V4L2_TUNER_MODE_MONO]   = \"Mono\",\n\t[V4L2_TUNER_MODE_STEREO] = \"Stereo\",\n\t[V4L2_TUNER_MODE_LANG1]  = \"Lang1\",\n\t[V4L2_TUNER_MODE_LANG2]  = \"Lang2\",\n\t[V4L2_TUNER_MODE_LANG1_LANG2] = \"Lang1+Lang2\",\n};\n\n\nstatic const char *control_values_hsm[] = {\n\t[PVR2_CVAL_HSM_FAIL] = \"Fail\",\n\t[PVR2_CVAL_HSM_HIGH] = \"High\",\n\t[PVR2_CVAL_HSM_FULL] = \"Full\",\n};\n\n\nstatic const char *pvr2_state_names[] = {\n\t[PVR2_STATE_NONE] =    \"none\",\n\t[PVR2_STATE_DEAD] =    \"dead\",\n\t[PVR2_STATE_COLD] =    \"cold\",\n\t[PVR2_STATE_WARM] =    \"warm\",\n\t[PVR2_STATE_ERROR] =   \"error\",\n\t[PVR2_STATE_READY] =   \"ready\",\n\t[PVR2_STATE_RUN] =     \"run\",\n};\n\n\nstruct pvr2_fx2cmd_descdef {\n\tunsigned char id;\n\tunsigned char *desc;\n};\n\nstatic const struct pvr2_fx2cmd_descdef pvr2_fx2cmd_desc[] = {\n\t{FX2CMD_MEM_WRITE_DWORD, \"write encoder dword\"},\n\t{FX2CMD_MEM_READ_DWORD, \"read encoder dword\"},\n\t{FX2CMD_HCW_ZILOG_RESET, \"zilog IR reset control\"},\n\t{FX2CMD_MEM_READ_64BYTES, \"read encoder 64bytes\"},\n\t{FX2CMD_REG_WRITE, \"write encoder register\"},\n\t{FX2CMD_REG_READ, \"read encoder register\"},\n\t{FX2CMD_MEMSEL, \"encoder memsel\"},\n\t{FX2CMD_I2C_WRITE, \"i2c write\"},\n\t{FX2CMD_I2C_READ, \"i2c read\"},\n\t{FX2CMD_GET_USB_SPEED, \"get USB speed\"},\n\t{FX2CMD_STREAMING_ON, \"stream on\"},\n\t{FX2CMD_STREAMING_OFF, \"stream off\"},\n\t{FX2CMD_FWPOST1, \"fwpost1\"},\n\t{FX2CMD_POWER_OFF, \"power off\"},\n\t{FX2CMD_POWER_ON, \"power on\"},\n\t{FX2CMD_DEEP_RESET, \"deep reset\"},\n\t{FX2CMD_GET_EEPROM_ADDR, \"get rom addr\"},\n\t{FX2CMD_GET_IR_CODE, \"get IR code\"},\n\t{FX2CMD_HCW_DEMOD_RESETIN, \"hcw demod resetin\"},\n\t{FX2CMD_HCW_DTV_STREAMING_ON, \"hcw dtv stream on\"},\n\t{FX2CMD_HCW_DTV_STREAMING_OFF, \"hcw dtv stream off\"},\n\t{FX2CMD_ONAIR_DTV_STREAMING_ON, \"onair dtv stream on\"},\n\t{FX2CMD_ONAIR_DTV_STREAMING_OFF, \"onair dtv stream off\"},\n\t{FX2CMD_ONAIR_DTV_POWER_ON, \"onair dtv power on\"},\n\t{FX2CMD_ONAIR_DTV_POWER_OFF, \"onair dtv power off\"},\n\t{FX2CMD_HCW_DEMOD_RESET_PIN, \"hcw demod reset pin\"},\n\t{FX2CMD_HCW_MAKO_SLEEP_PIN, \"hcw mako sleep pin\"},\n};\n\n\nstatic int pvr2_hdw_set_input(struct pvr2_hdw *hdw,int v);\nstatic void pvr2_hdw_state_sched(struct pvr2_hdw *);\nstatic int pvr2_hdw_state_eval(struct pvr2_hdw *);\nstatic void pvr2_hdw_set_cur_freq(struct pvr2_hdw *,unsigned long);\nstatic void pvr2_hdw_worker_poll(struct work_struct *work);\nstatic int pvr2_hdw_wait(struct pvr2_hdw *,int state);\nstatic int pvr2_hdw_untrip_unlocked(struct pvr2_hdw *);\nstatic void pvr2_hdw_state_log_state(struct pvr2_hdw *);\nstatic int pvr2_hdw_cmd_usbstream(struct pvr2_hdw *hdw,int runFl);\nstatic int pvr2_hdw_commit_setup(struct pvr2_hdw *hdw);\nstatic int pvr2_hdw_get_eeprom_addr(struct pvr2_hdw *hdw);\nstatic void pvr2_hdw_quiescent_timeout(struct timer_list *);\nstatic void pvr2_hdw_decoder_stabilization_timeout(struct timer_list *);\nstatic void pvr2_hdw_encoder_wait_timeout(struct timer_list *);\nstatic void pvr2_hdw_encoder_run_timeout(struct timer_list *);\nstatic int pvr2_issue_simple_cmd(struct pvr2_hdw *,u32);\nstatic int pvr2_send_request_ex(struct pvr2_hdw *hdw,\n\t\t\t\tunsigned int timeout,int probe_fl,\n\t\t\t\tvoid *write_data,unsigned int write_len,\n\t\t\t\tvoid *read_data,unsigned int read_len);\nstatic int pvr2_hdw_check_cropcap(struct pvr2_hdw *hdw);\nstatic v4l2_std_id pvr2_hdw_get_detected_std(struct pvr2_hdw *hdw);\n\nstatic void trace_stbit(const char *name,int val)\n{\n\tpvr2_trace(PVR2_TRACE_STBITS,\n\t\t   \"State bit %s <-- %s\",\n\t\t   name,(val ? \"true\" : \"false\"));\n}\n\nstatic int ctrl_channelfreq_get(struct pvr2_ctrl *cptr,int *vp)\n{\n\tstruct pvr2_hdw *hdw = cptr->hdw;\n\tif ((hdw->freqProgSlot > 0) && (hdw->freqProgSlot <= FREQTABLE_SIZE)) {\n\t\t*vp = hdw->freqTable[hdw->freqProgSlot-1];\n\t} else {\n\t\t*vp = 0;\n\t}\n\treturn 0;\n}\n\nstatic int ctrl_channelfreq_set(struct pvr2_ctrl *cptr,int m,int v)\n{\n\tstruct pvr2_hdw *hdw = cptr->hdw;\n\tunsigned int slotId = hdw->freqProgSlot;\n\tif ((slotId > 0) && (slotId <= FREQTABLE_SIZE)) {\n\t\thdw->freqTable[slotId-1] = v;\n\t\t \n\t\tif (hdw->freqSelector) {\n\t\t\tif (hdw->freqSlotRadio == slotId) {\n\t\t\t\thdw->freqSlotRadio = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (hdw->freqSlotTelevision == slotId) {\n\t\t\t\thdw->freqSlotTelevision = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int ctrl_channelprog_get(struct pvr2_ctrl *cptr,int *vp)\n{\n\t*vp = cptr->hdw->freqProgSlot;\n\treturn 0;\n}\n\nstatic int ctrl_channelprog_set(struct pvr2_ctrl *cptr,int m,int v)\n{\n\tstruct pvr2_hdw *hdw = cptr->hdw;\n\tif ((v >= 0) && (v <= FREQTABLE_SIZE)) {\n\t\thdw->freqProgSlot = v;\n\t}\n\treturn 0;\n}\n\nstatic int ctrl_channel_get(struct pvr2_ctrl *cptr,int *vp)\n{\n\tstruct pvr2_hdw *hdw = cptr->hdw;\n\t*vp = hdw->freqSelector ? hdw->freqSlotRadio : hdw->freqSlotTelevision;\n\treturn 0;\n}\n\nstatic int ctrl_channel_set(struct pvr2_ctrl *cptr,int m,int slotId)\n{\n\tunsigned freq = 0;\n\tstruct pvr2_hdw *hdw = cptr->hdw;\n\tif ((slotId < 0) || (slotId > FREQTABLE_SIZE)) return 0;\n\tif (slotId > 0) {\n\t\tfreq = hdw->freqTable[slotId-1];\n\t\tif (!freq) return 0;\n\t\tpvr2_hdw_set_cur_freq(hdw,freq);\n\t}\n\tif (hdw->freqSelector) {\n\t\thdw->freqSlotRadio = slotId;\n\t} else {\n\t\thdw->freqSlotTelevision = slotId;\n\t}\n\treturn 0;\n}\n\nstatic int ctrl_freq_get(struct pvr2_ctrl *cptr,int *vp)\n{\n\t*vp = pvr2_hdw_get_cur_freq(cptr->hdw);\n\treturn 0;\n}\n\nstatic int ctrl_freq_is_dirty(struct pvr2_ctrl *cptr)\n{\n\treturn cptr->hdw->freqDirty != 0;\n}\n\nstatic void ctrl_freq_clear_dirty(struct pvr2_ctrl *cptr)\n{\n\tcptr->hdw->freqDirty = 0;\n}\n\nstatic int ctrl_freq_set(struct pvr2_ctrl *cptr,int m,int v)\n{\n\tpvr2_hdw_set_cur_freq(cptr->hdw,v);\n\treturn 0;\n}\n\nstatic int ctrl_cropl_min_get(struct pvr2_ctrl *cptr, int *left)\n{\n\tstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\n\tint stat = pvr2_hdw_check_cropcap(cptr->hdw);\n\tif (stat != 0) {\n\t\treturn stat;\n\t}\n\t*left = cap->bounds.left;\n\treturn 0;\n}\n\nstatic int ctrl_cropl_max_get(struct pvr2_ctrl *cptr, int *left)\n{\n\tstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\n\tint stat = pvr2_hdw_check_cropcap(cptr->hdw);\n\tif (stat != 0) {\n\t\treturn stat;\n\t}\n\t*left = cap->bounds.left;\n\tif (cap->bounds.width > cptr->hdw->cropw_val) {\n\t\t*left += cap->bounds.width - cptr->hdw->cropw_val;\n\t}\n\treturn 0;\n}\n\nstatic int ctrl_cropt_min_get(struct pvr2_ctrl *cptr, int *top)\n{\n\tstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\n\tint stat = pvr2_hdw_check_cropcap(cptr->hdw);\n\tif (stat != 0) {\n\t\treturn stat;\n\t}\n\t*top = cap->bounds.top;\n\treturn 0;\n}\n\nstatic int ctrl_cropt_max_get(struct pvr2_ctrl *cptr, int *top)\n{\n\tstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\n\tint stat = pvr2_hdw_check_cropcap(cptr->hdw);\n\tif (stat != 0) {\n\t\treturn stat;\n\t}\n\t*top = cap->bounds.top;\n\tif (cap->bounds.height > cptr->hdw->croph_val) {\n\t\t*top += cap->bounds.height - cptr->hdw->croph_val;\n\t}\n\treturn 0;\n}\n\nstatic int ctrl_cropw_max_get(struct pvr2_ctrl *cptr, int *width)\n{\n\tstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\n\tint stat, bleftend, cleft;\n\n\tstat = pvr2_hdw_check_cropcap(cptr->hdw);\n\tif (stat != 0) {\n\t\treturn stat;\n\t}\n\tbleftend = cap->bounds.left+cap->bounds.width;\n\tcleft = cptr->hdw->cropl_val;\n\n\t*width = cleft < bleftend ? bleftend-cleft : 0;\n\treturn 0;\n}\n\nstatic int ctrl_croph_max_get(struct pvr2_ctrl *cptr, int *height)\n{\n\tstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\n\tint stat, btopend, ctop;\n\n\tstat = pvr2_hdw_check_cropcap(cptr->hdw);\n\tif (stat != 0) {\n\t\treturn stat;\n\t}\n\tbtopend = cap->bounds.top+cap->bounds.height;\n\tctop = cptr->hdw->cropt_val;\n\n\t*height = ctop < btopend ? btopend-ctop : 0;\n\treturn 0;\n}\n\nstatic int ctrl_get_cropcapbl(struct pvr2_ctrl *cptr, int *val)\n{\n\tstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\n\tint stat = pvr2_hdw_check_cropcap(cptr->hdw);\n\tif (stat != 0) {\n\t\treturn stat;\n\t}\n\t*val = cap->bounds.left;\n\treturn 0;\n}\n\nstatic int ctrl_get_cropcapbt(struct pvr2_ctrl *cptr, int *val)\n{\n\tstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\n\tint stat = pvr2_hdw_check_cropcap(cptr->hdw);\n\tif (stat != 0) {\n\t\treturn stat;\n\t}\n\t*val = cap->bounds.top;\n\treturn 0;\n}\n\nstatic int ctrl_get_cropcapbw(struct pvr2_ctrl *cptr, int *val)\n{\n\tstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\n\tint stat = pvr2_hdw_check_cropcap(cptr->hdw);\n\tif (stat != 0) {\n\t\treturn stat;\n\t}\n\t*val = cap->bounds.width;\n\treturn 0;\n}\n\nstatic int ctrl_get_cropcapbh(struct pvr2_ctrl *cptr, int *val)\n{\n\tstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\n\tint stat = pvr2_hdw_check_cropcap(cptr->hdw);\n\tif (stat != 0) {\n\t\treturn stat;\n\t}\n\t*val = cap->bounds.height;\n\treturn 0;\n}\n\nstatic int ctrl_get_cropcapdl(struct pvr2_ctrl *cptr, int *val)\n{\n\tstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\n\tint stat = pvr2_hdw_check_cropcap(cptr->hdw);\n\tif (stat != 0) {\n\t\treturn stat;\n\t}\n\t*val = cap->defrect.left;\n\treturn 0;\n}\n\nstatic int ctrl_get_cropcapdt(struct pvr2_ctrl *cptr, int *val)\n{\n\tstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\n\tint stat = pvr2_hdw_check_cropcap(cptr->hdw);\n\tif (stat != 0) {\n\t\treturn stat;\n\t}\n\t*val = cap->defrect.top;\n\treturn 0;\n}\n\nstatic int ctrl_get_cropcapdw(struct pvr2_ctrl *cptr, int *val)\n{\n\tstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\n\tint stat = pvr2_hdw_check_cropcap(cptr->hdw);\n\tif (stat != 0) {\n\t\treturn stat;\n\t}\n\t*val = cap->defrect.width;\n\treturn 0;\n}\n\nstatic int ctrl_get_cropcapdh(struct pvr2_ctrl *cptr, int *val)\n{\n\tstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\n\tint stat = pvr2_hdw_check_cropcap(cptr->hdw);\n\tif (stat != 0) {\n\t\treturn stat;\n\t}\n\t*val = cap->defrect.height;\n\treturn 0;\n}\n\nstatic int ctrl_get_cropcappan(struct pvr2_ctrl *cptr, int *val)\n{\n\tstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\n\tint stat = pvr2_hdw_check_cropcap(cptr->hdw);\n\tif (stat != 0) {\n\t\treturn stat;\n\t}\n\t*val = cap->pixelaspect.numerator;\n\treturn 0;\n}\n\nstatic int ctrl_get_cropcappad(struct pvr2_ctrl *cptr, int *val)\n{\n\tstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\n\tint stat = pvr2_hdw_check_cropcap(cptr->hdw);\n\tif (stat != 0) {\n\t\treturn stat;\n\t}\n\t*val = cap->pixelaspect.denominator;\n\treturn 0;\n}\n\nstatic int ctrl_vres_max_get(struct pvr2_ctrl *cptr,int *vp)\n{\n\t \n\tif (cptr->hdw->std_mask_cur & V4L2_STD_525_60) {\n\t\t*vp = 480;\n\t} else {\n\t\t*vp = 576;\n\t}\n\treturn 0;\n}\n\nstatic int ctrl_vres_min_get(struct pvr2_ctrl *cptr,int *vp)\n{\n\t \n\tif (cptr->hdw->hdw_desc->flag_has_cx25840) {\n\t\t*vp = 75;\n\t} else {\n\t\t*vp = 17;\n\t}\n\treturn 0;\n}\n\nstatic int ctrl_get_input(struct pvr2_ctrl *cptr,int *vp)\n{\n\t*vp = cptr->hdw->input_val;\n\treturn 0;\n}\n\nstatic int ctrl_check_input(struct pvr2_ctrl *cptr,int v)\n{\n\tif (v < 0 || v > PVR2_CVAL_INPUT_MAX)\n\t\treturn 0;\n\treturn ((1UL << v) & cptr->hdw->input_allowed_mask) != 0;\n}\n\nstatic int ctrl_set_input(struct pvr2_ctrl *cptr,int m,int v)\n{\n\treturn pvr2_hdw_set_input(cptr->hdw,v);\n}\n\nstatic int ctrl_isdirty_input(struct pvr2_ctrl *cptr)\n{\n\treturn cptr->hdw->input_dirty != 0;\n}\n\nstatic void ctrl_cleardirty_input(struct pvr2_ctrl *cptr)\n{\n\tcptr->hdw->input_dirty = 0;\n}\n\n\nstatic int ctrl_freq_max_get(struct pvr2_ctrl *cptr, int *vp)\n{\n\tunsigned long fv;\n\tstruct pvr2_hdw *hdw = cptr->hdw;\n\tif (hdw->tuner_signal_stale) {\n\t\tpvr2_hdw_status_poll(hdw);\n\t}\n\tfv = hdw->tuner_signal_info.rangehigh;\n\tif (!fv) {\n\t\t \n\t\t*vp = TV_MAX_FREQ;\n\t\treturn 0;\n\t}\n\tif (hdw->tuner_signal_info.capability & V4L2_TUNER_CAP_LOW) {\n\t\tfv = (fv * 125) / 2;\n\t} else {\n\t\tfv = fv * 62500;\n\t}\n\t*vp = fv;\n\treturn 0;\n}\n\nstatic int ctrl_freq_min_get(struct pvr2_ctrl *cptr, int *vp)\n{\n\tunsigned long fv;\n\tstruct pvr2_hdw *hdw = cptr->hdw;\n\tif (hdw->tuner_signal_stale) {\n\t\tpvr2_hdw_status_poll(hdw);\n\t}\n\tfv = hdw->tuner_signal_info.rangelow;\n\tif (!fv) {\n\t\t \n\t\t*vp = TV_MIN_FREQ;\n\t\treturn 0;\n\t}\n\tif (hdw->tuner_signal_info.capability & V4L2_TUNER_CAP_LOW) {\n\t\tfv = (fv * 125) / 2;\n\t} else {\n\t\tfv = fv * 62500;\n\t}\n\t*vp = fv;\n\treturn 0;\n}\n\nstatic int ctrl_cx2341x_is_dirty(struct pvr2_ctrl *cptr)\n{\n\treturn cptr->hdw->enc_stale != 0;\n}\n\nstatic void ctrl_cx2341x_clear_dirty(struct pvr2_ctrl *cptr)\n{\n\tcptr->hdw->enc_stale = 0;\n\tcptr->hdw->enc_unsafe_stale = 0;\n}\n\nstatic int ctrl_cx2341x_get(struct pvr2_ctrl *cptr,int *vp)\n{\n\tint ret;\n\tstruct v4l2_ext_controls cs;\n\tstruct v4l2_ext_control c1;\n\tmemset(&cs,0,sizeof(cs));\n\tmemset(&c1,0,sizeof(c1));\n\tcs.controls = &c1;\n\tcs.count = 1;\n\tc1.id = cptr->info->v4l_id;\n\tret = cx2341x_ext_ctrls(&cptr->hdw->enc_ctl_state, 0, &cs,\n\t\t\t\tVIDIOC_G_EXT_CTRLS);\n\tif (ret) return ret;\n\t*vp = c1.value;\n\treturn 0;\n}\n\nstatic int ctrl_cx2341x_set(struct pvr2_ctrl *cptr,int m,int v)\n{\n\tint ret;\n\tstruct pvr2_hdw *hdw = cptr->hdw;\n\tstruct v4l2_ext_controls cs;\n\tstruct v4l2_ext_control c1;\n\tmemset(&cs,0,sizeof(cs));\n\tmemset(&c1,0,sizeof(c1));\n\tcs.controls = &c1;\n\tcs.count = 1;\n\tc1.id = cptr->info->v4l_id;\n\tc1.value = v;\n\tret = cx2341x_ext_ctrls(&hdw->enc_ctl_state,\n\t\t\t\thdw->state_encoder_run, &cs,\n\t\t\t\tVIDIOC_S_EXT_CTRLS);\n\tif (ret == -EBUSY) {\n\t\t \n\t\tret = cx2341x_ext_ctrls(&hdw->enc_ctl_state,\n\t\t\t\t\t0, &cs,\n\t\t\t\t\tVIDIOC_S_EXT_CTRLS);\n\t\tif (!ret) hdw->enc_unsafe_stale = !0;\n\t}\n\tif (ret) return ret;\n\thdw->enc_stale = !0;\n\treturn 0;\n}\n\nstatic unsigned int ctrl_cx2341x_getv4lflags(struct pvr2_ctrl *cptr)\n{\n\tstruct v4l2_queryctrl qctrl = {};\n\tstruct pvr2_ctl_info *info;\n\tqctrl.id = cptr->info->v4l_id;\n\tcx2341x_ctrl_query(&cptr->hdw->enc_ctl_state,&qctrl);\n\t \n\tinfo = (struct pvr2_ctl_info *)(cptr->info);\n\tif (qctrl.flags & V4L2_CTRL_FLAG_READ_ONLY) {\n\t\tif (info->set_value) {\n\t\t\tinfo->set_value = NULL;\n\t\t}\n\t} else {\n\t\tif (!(info->set_value)) {\n\t\t\tinfo->set_value = ctrl_cx2341x_set;\n\t\t}\n\t}\n\treturn qctrl.flags;\n}\n\nstatic int ctrl_streamingenabled_get(struct pvr2_ctrl *cptr,int *vp)\n{\n\t*vp = cptr->hdw->state_pipeline_req;\n\treturn 0;\n}\n\nstatic int ctrl_masterstate_get(struct pvr2_ctrl *cptr,int *vp)\n{\n\t*vp = cptr->hdw->master_state;\n\treturn 0;\n}\n\nstatic int ctrl_hsm_get(struct pvr2_ctrl *cptr,int *vp)\n{\n\tint result = pvr2_hdw_is_hsm(cptr->hdw);\n\t*vp = PVR2_CVAL_HSM_FULL;\n\tif (result < 0) *vp = PVR2_CVAL_HSM_FAIL;\n\tif (result) *vp = PVR2_CVAL_HSM_HIGH;\n\treturn 0;\n}\n\nstatic int ctrl_stddetect_get(struct pvr2_ctrl *cptr, int *vp)\n{\n\t*vp = pvr2_hdw_get_detected_std(cptr->hdw);\n\treturn 0;\n}\n\nstatic int ctrl_stdavail_get(struct pvr2_ctrl *cptr,int *vp)\n{\n\t*vp = cptr->hdw->std_mask_avail;\n\treturn 0;\n}\n\nstatic int ctrl_stdavail_set(struct pvr2_ctrl *cptr,int m,int v)\n{\n\tstruct pvr2_hdw *hdw = cptr->hdw;\n\tv4l2_std_id ns;\n\tns = hdw->std_mask_avail;\n\tns = (ns & ~m) | (v & m);\n\tif (ns == hdw->std_mask_avail) return 0;\n\thdw->std_mask_avail = ns;\n\thdw->std_info_cur.def.type_bitmask.valid_bits = hdw->std_mask_avail;\n\treturn 0;\n}\n\nstatic int ctrl_std_val_to_sym(struct pvr2_ctrl *cptr,int msk,int val,\n\t\t\t       char *bufPtr,unsigned int bufSize,\n\t\t\t       unsigned int *len)\n{\n\t*len = pvr2_std_id_to_str(bufPtr,bufSize,msk & val);\n\treturn 0;\n}\n\nstatic int ctrl_std_sym_to_val(struct pvr2_ctrl *cptr,\n\t\t\t       const char *bufPtr,unsigned int bufSize,\n\t\t\t       int *mskp,int *valp)\n{\n\tv4l2_std_id id;\n\tif (!pvr2_std_str_to_id(&id, bufPtr, bufSize))\n\t\treturn -EINVAL;\n\tif (mskp) *mskp = id;\n\tif (valp) *valp = id;\n\treturn 0;\n}\n\nstatic int ctrl_stdcur_get(struct pvr2_ctrl *cptr,int *vp)\n{\n\t*vp = cptr->hdw->std_mask_cur;\n\treturn 0;\n}\n\nstatic int ctrl_stdcur_set(struct pvr2_ctrl *cptr,int m,int v)\n{\n\tstruct pvr2_hdw *hdw = cptr->hdw;\n\tv4l2_std_id ns;\n\tns = hdw->std_mask_cur;\n\tns = (ns & ~m) | (v & m);\n\tif (ns == hdw->std_mask_cur) return 0;\n\thdw->std_mask_cur = ns;\n\thdw->std_dirty = !0;\n\treturn 0;\n}\n\nstatic int ctrl_stdcur_is_dirty(struct pvr2_ctrl *cptr)\n{\n\treturn cptr->hdw->std_dirty != 0;\n}\n\nstatic void ctrl_stdcur_clear_dirty(struct pvr2_ctrl *cptr)\n{\n\tcptr->hdw->std_dirty = 0;\n}\n\nstatic int ctrl_signal_get(struct pvr2_ctrl *cptr,int *vp)\n{\n\tstruct pvr2_hdw *hdw = cptr->hdw;\n\tpvr2_hdw_status_poll(hdw);\n\t*vp = hdw->tuner_signal_info.signal;\n\treturn 0;\n}\n\nstatic int ctrl_audio_modes_present_get(struct pvr2_ctrl *cptr,int *vp)\n{\n\tint val = 0;\n\tunsigned int subchan;\n\tstruct pvr2_hdw *hdw = cptr->hdw;\n\tpvr2_hdw_status_poll(hdw);\n\tsubchan = hdw->tuner_signal_info.rxsubchans;\n\tif (subchan & V4L2_TUNER_SUB_MONO) {\n\t\tval |= (1 << V4L2_TUNER_MODE_MONO);\n\t}\n\tif (subchan & V4L2_TUNER_SUB_STEREO) {\n\t\tval |= (1 << V4L2_TUNER_MODE_STEREO);\n\t}\n\tif (subchan & V4L2_TUNER_SUB_LANG1) {\n\t\tval |= (1 << V4L2_TUNER_MODE_LANG1);\n\t}\n\tif (subchan & V4L2_TUNER_SUB_LANG2) {\n\t\tval |= (1 << V4L2_TUNER_MODE_LANG2);\n\t}\n\t*vp = val;\n\treturn 0;\n}\n\n\n#define DEFINT(vmin,vmax) \\\n\t.type = pvr2_ctl_int, \\\n\t.def.type_int.min_value = vmin, \\\n\t.def.type_int.max_value = vmax\n\n#define DEFENUM(tab) \\\n\t.type = pvr2_ctl_enum, \\\n\t.def.type_enum.count = ARRAY_SIZE(tab), \\\n\t.def.type_enum.value_names = tab\n\n#define DEFBOOL \\\n\t.type = pvr2_ctl_bool\n\n#define DEFMASK(msk,tab) \\\n\t.type = pvr2_ctl_bitmask, \\\n\t.def.type_bitmask.valid_bits = msk, \\\n\t.def.type_bitmask.bit_names = tab\n\n#define DEFREF(vname) \\\n\t.set_value = ctrl_set_##vname, \\\n\t.get_value = ctrl_get_##vname, \\\n\t.is_dirty = ctrl_isdirty_##vname, \\\n\t.clear_dirty = ctrl_cleardirty_##vname\n\n\n#define VCREATE_FUNCS(vname) \\\nstatic int ctrl_get_##vname(struct pvr2_ctrl *cptr,int *vp) \\\n{*vp = cptr->hdw->vname##_val; return 0;} \\\nstatic int ctrl_set_##vname(struct pvr2_ctrl *cptr,int m,int v) \\\n{cptr->hdw->vname##_val = v; cptr->hdw->vname##_dirty = !0; return 0;} \\\nstatic int ctrl_isdirty_##vname(struct pvr2_ctrl *cptr) \\\n{return cptr->hdw->vname##_dirty != 0;} \\\nstatic void ctrl_cleardirty_##vname(struct pvr2_ctrl *cptr) \\\n{cptr->hdw->vname##_dirty = 0;}\n\nVCREATE_FUNCS(brightness)\nVCREATE_FUNCS(contrast)\nVCREATE_FUNCS(saturation)\nVCREATE_FUNCS(hue)\nVCREATE_FUNCS(volume)\nVCREATE_FUNCS(balance)\nVCREATE_FUNCS(bass)\nVCREATE_FUNCS(treble)\nVCREATE_FUNCS(mute)\nVCREATE_FUNCS(cropl)\nVCREATE_FUNCS(cropt)\nVCREATE_FUNCS(cropw)\nVCREATE_FUNCS(croph)\nVCREATE_FUNCS(audiomode)\nVCREATE_FUNCS(res_hor)\nVCREATE_FUNCS(res_ver)\nVCREATE_FUNCS(srate)\n\n \nstatic const struct pvr2_ctl_info control_defs[] = {\n\t{\n\t\t.v4l_id = V4L2_CID_BRIGHTNESS,\n\t\t.desc = \"Brightness\",\n\t\t.name = \"brightness\",\n\t\t.default_value = 128,\n\t\tDEFREF(brightness),\n\t\tDEFINT(0,255),\n\t},{\n\t\t.v4l_id = V4L2_CID_CONTRAST,\n\t\t.desc = \"Contrast\",\n\t\t.name = \"contrast\",\n\t\t.default_value = 68,\n\t\tDEFREF(contrast),\n\t\tDEFINT(0,127),\n\t},{\n\t\t.v4l_id = V4L2_CID_SATURATION,\n\t\t.desc = \"Saturation\",\n\t\t.name = \"saturation\",\n\t\t.default_value = 64,\n\t\tDEFREF(saturation),\n\t\tDEFINT(0,127),\n\t},{\n\t\t.v4l_id = V4L2_CID_HUE,\n\t\t.desc = \"Hue\",\n\t\t.name = \"hue\",\n\t\t.default_value = 0,\n\t\tDEFREF(hue),\n\t\tDEFINT(-128,127),\n\t},{\n\t\t.v4l_id = V4L2_CID_AUDIO_VOLUME,\n\t\t.desc = \"Volume\",\n\t\t.name = \"volume\",\n\t\t.default_value = 62000,\n\t\tDEFREF(volume),\n\t\tDEFINT(0,65535),\n\t},{\n\t\t.v4l_id = V4L2_CID_AUDIO_BALANCE,\n\t\t.desc = \"Balance\",\n\t\t.name = \"balance\",\n\t\t.default_value = 0,\n\t\tDEFREF(balance),\n\t\tDEFINT(-32768,32767),\n\t},{\n\t\t.v4l_id = V4L2_CID_AUDIO_BASS,\n\t\t.desc = \"Bass\",\n\t\t.name = \"bass\",\n\t\t.default_value = 0,\n\t\tDEFREF(bass),\n\t\tDEFINT(-32768,32767),\n\t},{\n\t\t.v4l_id = V4L2_CID_AUDIO_TREBLE,\n\t\t.desc = \"Treble\",\n\t\t.name = \"treble\",\n\t\t.default_value = 0,\n\t\tDEFREF(treble),\n\t\tDEFINT(-32768,32767),\n\t},{\n\t\t.v4l_id = V4L2_CID_AUDIO_MUTE,\n\t\t.desc = \"Mute\",\n\t\t.name = \"mute\",\n\t\t.default_value = 0,\n\t\tDEFREF(mute),\n\t\tDEFBOOL,\n\t}, {\n\t\t.desc = \"Capture crop left margin\",\n\t\t.name = \"crop_left\",\n\t\t.internal_id = PVR2_CID_CROPL,\n\t\t.default_value = 0,\n\t\tDEFREF(cropl),\n\t\tDEFINT(-129, 340),\n\t\t.get_min_value = ctrl_cropl_min_get,\n\t\t.get_max_value = ctrl_cropl_max_get,\n\t\t.get_def_value = ctrl_get_cropcapdl,\n\t}, {\n\t\t.desc = \"Capture crop top margin\",\n\t\t.name = \"crop_top\",\n\t\t.internal_id = PVR2_CID_CROPT,\n\t\t.default_value = 0,\n\t\tDEFREF(cropt),\n\t\tDEFINT(-35, 544),\n\t\t.get_min_value = ctrl_cropt_min_get,\n\t\t.get_max_value = ctrl_cropt_max_get,\n\t\t.get_def_value = ctrl_get_cropcapdt,\n\t}, {\n\t\t.desc = \"Capture crop width\",\n\t\t.name = \"crop_width\",\n\t\t.internal_id = PVR2_CID_CROPW,\n\t\t.default_value = 720,\n\t\tDEFREF(cropw),\n\t\tDEFINT(0, 864),\n\t\t.get_max_value = ctrl_cropw_max_get,\n\t\t.get_def_value = ctrl_get_cropcapdw,\n\t}, {\n\t\t.desc = \"Capture crop height\",\n\t\t.name = \"crop_height\",\n\t\t.internal_id = PVR2_CID_CROPH,\n\t\t.default_value = 480,\n\t\tDEFREF(croph),\n\t\tDEFINT(0, 576),\n\t\t.get_max_value = ctrl_croph_max_get,\n\t\t.get_def_value = ctrl_get_cropcapdh,\n\t}, {\n\t\t.desc = \"Capture capability pixel aspect numerator\",\n\t\t.name = \"cropcap_pixel_numerator\",\n\t\t.internal_id = PVR2_CID_CROPCAPPAN,\n\t\t.get_value = ctrl_get_cropcappan,\n\t}, {\n\t\t.desc = \"Capture capability pixel aspect denominator\",\n\t\t.name = \"cropcap_pixel_denominator\",\n\t\t.internal_id = PVR2_CID_CROPCAPPAD,\n\t\t.get_value = ctrl_get_cropcappad,\n\t}, {\n\t\t.desc = \"Capture capability bounds top\",\n\t\t.name = \"cropcap_bounds_top\",\n\t\t.internal_id = PVR2_CID_CROPCAPBT,\n\t\t.get_value = ctrl_get_cropcapbt,\n\t}, {\n\t\t.desc = \"Capture capability bounds left\",\n\t\t.name = \"cropcap_bounds_left\",\n\t\t.internal_id = PVR2_CID_CROPCAPBL,\n\t\t.get_value = ctrl_get_cropcapbl,\n\t}, {\n\t\t.desc = \"Capture capability bounds width\",\n\t\t.name = \"cropcap_bounds_width\",\n\t\t.internal_id = PVR2_CID_CROPCAPBW,\n\t\t.get_value = ctrl_get_cropcapbw,\n\t}, {\n\t\t.desc = \"Capture capability bounds height\",\n\t\t.name = \"cropcap_bounds_height\",\n\t\t.internal_id = PVR2_CID_CROPCAPBH,\n\t\t.get_value = ctrl_get_cropcapbh,\n\t},{\n\t\t.desc = \"Video Source\",\n\t\t.name = \"input\",\n\t\t.internal_id = PVR2_CID_INPUT,\n\t\t.default_value = PVR2_CVAL_INPUT_TV,\n\t\t.check_value = ctrl_check_input,\n\t\tDEFREF(input),\n\t\tDEFENUM(control_values_input),\n\t},{\n\t\t.desc = \"Audio Mode\",\n\t\t.name = \"audio_mode\",\n\t\t.internal_id = PVR2_CID_AUDIOMODE,\n\t\t.default_value = V4L2_TUNER_MODE_STEREO,\n\t\tDEFREF(audiomode),\n\t\tDEFENUM(control_values_audiomode),\n\t},{\n\t\t.desc = \"Horizontal capture resolution\",\n\t\t.name = \"resolution_hor\",\n\t\t.internal_id = PVR2_CID_HRES,\n\t\t.default_value = 720,\n\t\tDEFREF(res_hor),\n\t\tDEFINT(19,720),\n\t},{\n\t\t.desc = \"Vertical capture resolution\",\n\t\t.name = \"resolution_ver\",\n\t\t.internal_id = PVR2_CID_VRES,\n\t\t.default_value = 480,\n\t\tDEFREF(res_ver),\n\t\tDEFINT(17,576),\n\t\t \n\t\t.get_max_value = ctrl_vres_max_get,\n\t\t.get_min_value = ctrl_vres_min_get,\n\t},{\n\t\t.v4l_id = V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ,\n\t\t.default_value = V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000,\n\t\t.desc = \"Audio Sampling Frequency\",\n\t\t.name = \"srate\",\n\t\tDEFREF(srate),\n\t\tDEFENUM(control_values_srate),\n\t},{\n\t\t.desc = \"Tuner Frequency (Hz)\",\n\t\t.name = \"frequency\",\n\t\t.internal_id = PVR2_CID_FREQUENCY,\n\t\t.default_value = 0,\n\t\t.set_value = ctrl_freq_set,\n\t\t.get_value = ctrl_freq_get,\n\t\t.is_dirty = ctrl_freq_is_dirty,\n\t\t.clear_dirty = ctrl_freq_clear_dirty,\n\t\tDEFINT(0,0),\n\t\t \n\t\t.get_max_value = ctrl_freq_max_get,\n\t\t.get_min_value = ctrl_freq_min_get,\n\t},{\n\t\t.desc = \"Channel\",\n\t\t.name = \"channel\",\n\t\t.set_value = ctrl_channel_set,\n\t\t.get_value = ctrl_channel_get,\n\t\tDEFINT(0,FREQTABLE_SIZE),\n\t},{\n\t\t.desc = \"Channel Program Frequency\",\n\t\t.name = \"freq_table_value\",\n\t\t.set_value = ctrl_channelfreq_set,\n\t\t.get_value = ctrl_channelfreq_get,\n\t\tDEFINT(0,0),\n\t\t \n\t\t.get_max_value = ctrl_freq_max_get,\n\t\t.get_min_value = ctrl_freq_min_get,\n\t},{\n\t\t.desc = \"Channel Program ID\",\n\t\t.name = \"freq_table_channel\",\n\t\t.set_value = ctrl_channelprog_set,\n\t\t.get_value = ctrl_channelprog_get,\n\t\tDEFINT(0,FREQTABLE_SIZE),\n\t},{\n\t\t.desc = \"Streaming Enabled\",\n\t\t.name = \"streaming_enabled\",\n\t\t.get_value = ctrl_streamingenabled_get,\n\t\tDEFBOOL,\n\t},{\n\t\t.desc = \"USB Speed\",\n\t\t.name = \"usb_speed\",\n\t\t.get_value = ctrl_hsm_get,\n\t\tDEFENUM(control_values_hsm),\n\t},{\n\t\t.desc = \"Master State\",\n\t\t.name = \"master_state\",\n\t\t.get_value = ctrl_masterstate_get,\n\t\tDEFENUM(pvr2_state_names),\n\t},{\n\t\t.desc = \"Signal Present\",\n\t\t.name = \"signal_present\",\n\t\t.get_value = ctrl_signal_get,\n\t\tDEFINT(0,65535),\n\t},{\n\t\t.desc = \"Audio Modes Present\",\n\t\t.name = \"audio_modes_present\",\n\t\t.get_value = ctrl_audio_modes_present_get,\n\t\t \n\t\tDEFMASK(((1 << V4L2_TUNER_MODE_MONO)|\n\t\t\t (1 << V4L2_TUNER_MODE_STEREO)|\n\t\t\t (1 << V4L2_TUNER_MODE_LANG1)|\n\t\t\t (1 << V4L2_TUNER_MODE_LANG2)),\n\t\t\tcontrol_values_audiomode),\n\t},{\n\t\t.desc = \"Video Standards Available Mask\",\n\t\t.name = \"video_standard_mask_available\",\n\t\t.internal_id = PVR2_CID_STDAVAIL,\n\t\t.skip_init = !0,\n\t\t.get_value = ctrl_stdavail_get,\n\t\t.set_value = ctrl_stdavail_set,\n\t\t.val_to_sym = ctrl_std_val_to_sym,\n\t\t.sym_to_val = ctrl_std_sym_to_val,\n\t\t.type = pvr2_ctl_bitmask,\n\t},{\n\t\t.desc = \"Video Standards In Use Mask\",\n\t\t.name = \"video_standard_mask_active\",\n\t\t.internal_id = PVR2_CID_STDCUR,\n\t\t.skip_init = !0,\n\t\t.get_value = ctrl_stdcur_get,\n\t\t.set_value = ctrl_stdcur_set,\n\t\t.is_dirty = ctrl_stdcur_is_dirty,\n\t\t.clear_dirty = ctrl_stdcur_clear_dirty,\n\t\t.val_to_sym = ctrl_std_val_to_sym,\n\t\t.sym_to_val = ctrl_std_sym_to_val,\n\t\t.type = pvr2_ctl_bitmask,\n\t},{\n\t\t.desc = \"Video Standards Detected Mask\",\n\t\t.name = \"video_standard_mask_detected\",\n\t\t.internal_id = PVR2_CID_STDDETECT,\n\t\t.skip_init = !0,\n\t\t.get_value = ctrl_stddetect_get,\n\t\t.val_to_sym = ctrl_std_val_to_sym,\n\t\t.sym_to_val = ctrl_std_sym_to_val,\n\t\t.type = pvr2_ctl_bitmask,\n\t}\n};\n\n#define CTRLDEF_COUNT ARRAY_SIZE(control_defs)\n\n\nconst char *pvr2_config_get_name(enum pvr2_config cfg)\n{\n\tswitch (cfg) {\n\tcase pvr2_config_empty: return \"empty\";\n\tcase pvr2_config_mpeg: return \"mpeg\";\n\tcase pvr2_config_vbi: return \"vbi\";\n\tcase pvr2_config_pcm: return \"pcm\";\n\tcase pvr2_config_rawvideo: return \"raw video\";\n\t}\n\treturn \"<unknown>\";\n}\n\n\nstruct usb_device *pvr2_hdw_get_dev(struct pvr2_hdw *hdw)\n{\n\treturn hdw->usb_dev;\n}\n\n\nunsigned long pvr2_hdw_get_sn(struct pvr2_hdw *hdw)\n{\n\treturn hdw->serial_number;\n}\n\n\nconst char *pvr2_hdw_get_bus_info(struct pvr2_hdw *hdw)\n{\n\treturn hdw->bus_info;\n}\n\n\nconst char *pvr2_hdw_get_device_identifier(struct pvr2_hdw *hdw)\n{\n\treturn hdw->identifier;\n}\n\n\nunsigned long pvr2_hdw_get_cur_freq(struct pvr2_hdw *hdw)\n{\n\treturn hdw->freqSelector ? hdw->freqValTelevision : hdw->freqValRadio;\n}\n\n \nstatic void pvr2_hdw_set_cur_freq(struct pvr2_hdw *hdw,unsigned long val)\n{\n\tif (hdw->input_val == PVR2_CVAL_INPUT_RADIO) {\n\t\tif (hdw->freqSelector) {\n\t\t\t \n\t\t\thdw->freqSelector = 0;\n\t\t\thdw->freqDirty = !0;\n\t\t}\n\t\tif (hdw->freqValRadio != val) {\n\t\t\thdw->freqValRadio = val;\n\t\t\thdw->freqSlotRadio = 0;\n\t\t\thdw->freqDirty = !0;\n\t\t}\n\t} else {\n\t\tif (!(hdw->freqSelector)) {\n\t\t\t \n\t\t\thdw->freqSelector = 1;\n\t\t\thdw->freqDirty = !0;\n\t\t}\n\t\tif (hdw->freqValTelevision != val) {\n\t\t\thdw->freqValTelevision = val;\n\t\t\thdw->freqSlotTelevision = 0;\n\t\t\thdw->freqDirty = !0;\n\t\t}\n\t}\n}\n\nint pvr2_hdw_get_unit_number(struct pvr2_hdw *hdw)\n{\n\treturn hdw->unit_number;\n}\n\n\n \nstatic int pvr2_locate_firmware(struct pvr2_hdw *hdw,\n\t\t\t\tconst struct firmware **fw_entry,\n\t\t\t\tconst char *fwtypename,\n\t\t\t\tunsigned int fwcount,\n\t\t\t\tconst char *fwnames[])\n{\n\tunsigned int idx;\n\tint ret = -EINVAL;\n\tfor (idx = 0; idx < fwcount; idx++) {\n\t\tret = request_firmware(fw_entry,\n\t\t\t\t       fwnames[idx],\n\t\t\t\t       &hdw->usb_dev->dev);\n\t\tif (!ret) {\n\t\t\ttrace_firmware(\"Located %s firmware: %s; uploading...\",\n\t\t\t\t       fwtypename,\n\t\t\t\t       fwnames[idx]);\n\t\t\treturn idx;\n\t\t}\n\t\tif (ret == -ENOENT) continue;\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"request_firmware fatal error with code=%d\",ret);\n\t\treturn ret;\n\t}\n\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t   \"***WARNING*** Device %s firmware seems to be missing.\",\n\t\t   fwtypename);\n\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t   \"Did you install the pvrusb2 firmware files in their proper location?\");\n\tif (fwcount == 1) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"request_firmware unable to locate %s file %s\",\n\t\t\t   fwtypename,fwnames[0]);\n\t} else {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"request_firmware unable to locate one of the following %s files:\",\n\t\t\t   fwtypename);\n\t\tfor (idx = 0; idx < fwcount; idx++) {\n\t\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t\t   \"request_firmware: Failed to find %s\",\n\t\t\t\t   fwnames[idx]);\n\t\t}\n\t}\n\treturn ret;\n}\n\n\n \nstatic int pvr2_upload_firmware1(struct pvr2_hdw *hdw)\n{\n\tconst struct firmware *fw_entry = NULL;\n\tvoid  *fw_ptr;\n\tunsigned int pipe;\n\tunsigned int fwsize;\n\tint ret;\n\tu16 address;\n\n\tif (!hdw->hdw_desc->fx2_firmware.cnt) {\n\t\thdw->fw1_state = FW1_STATE_OK;\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"Connected device type defines no firmware to upload; ignoring firmware\");\n\t\treturn -ENOTTY;\n\t}\n\n\thdw->fw1_state = FW1_STATE_FAILED; \n\n\ttrace_firmware(\"pvr2_upload_firmware1\");\n\n\tret = pvr2_locate_firmware(hdw,&fw_entry,\"fx2 controller\",\n\t\t\t\t   hdw->hdw_desc->fx2_firmware.cnt,\n\t\t\t\t   hdw->hdw_desc->fx2_firmware.lst);\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT) hdw->fw1_state = FW1_STATE_MISSING;\n\t\treturn ret;\n\t}\n\n\tusb_clear_halt(hdw->usb_dev, usb_sndbulkpipe(hdw->usb_dev, 0 & 0x7f));\n\n\tpipe = usb_sndctrlpipe(hdw->usb_dev, 0);\n\tfwsize = fw_entry->size;\n\n\tif ((fwsize != 0x2000) &&\n\t    (!(hdw->hdw_desc->flag_fx2_16kb && (fwsize == 0x4000)))) {\n\t\tif (hdw->hdw_desc->flag_fx2_16kb) {\n\t\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t\t   \"Wrong fx2 firmware size (expected 8192 or 16384, got %u)\",\n\t\t\t\t   fwsize);\n\t\t} else {\n\t\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t\t   \"Wrong fx2 firmware size (expected 8192, got %u)\",\n\t\t\t\t   fwsize);\n\t\t}\n\t\trelease_firmware(fw_entry);\n\t\treturn -ENOMEM;\n\t}\n\n\tfw_ptr = kmalloc(0x800, GFP_KERNEL);\n\tif (fw_ptr == NULL){\n\t\trelease_firmware(fw_entry);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tpvr2_hdw_cpureset_assert(hdw,1);\n\n\t \n\n\tret = 0;\n\tfor (address = 0; address < fwsize; address += 0x800) {\n\t\tmemcpy(fw_ptr, fw_entry->data + address, 0x800);\n\t\tret += usb_control_msg(hdw->usb_dev, pipe, 0xa0, 0x40, address,\n\t\t\t\t       0, fw_ptr, 0x800, 1000);\n\t}\n\n\ttrace_firmware(\"Upload done, releasing device's CPU\");\n\n\t \n\tpvr2_hdw_cpureset_assert(hdw,0);\n\n\tkfree(fw_ptr);\n\trelease_firmware(fw_entry);\n\n\ttrace_firmware(\"Upload done (%d bytes sent)\",ret);\n\n\t \n\tif (ret == fwsize) {\n\t\thdw->fw1_state = FW1_STATE_RELOAD;\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}\n\n\n \n\nint pvr2_upload_firmware2(struct pvr2_hdw *hdw)\n{\n\tconst struct firmware *fw_entry = NULL;\n\tvoid  *fw_ptr;\n\tunsigned int pipe, fw_len, fw_done, bcnt, icnt;\n\tint actual_length;\n\tint ret = 0;\n\tint fwidx;\n\tstatic const char *fw_files[] = {\n\t\tCX2341X_FIRM_ENC_FILENAME,\n\t};\n\n\tif (hdw->hdw_desc->flag_skip_cx23416_firmware) {\n\t\treturn 0;\n\t}\n\n\ttrace_firmware(\"pvr2_upload_firmware2\");\n\n\tret = pvr2_locate_firmware(hdw,&fw_entry,\"encoder\",\n\t\t\t\t   ARRAY_SIZE(fw_files), fw_files);\n\tif (ret < 0) return ret;\n\tfwidx = ret;\n\tret = 0;\n\t \n\thdw->enc_cur_valid = 0;\n\n\t \n\tdel_timer_sync(&hdw->encoder_run_timer);\n\tif (hdw->state_encoder_runok) {\n\t\thdw->state_encoder_runok = 0;\n\t\ttrace_stbit(\"state_encoder_runok\",hdw->state_encoder_runok);\n\t}\n\n\t \n\tret |= pvr2_write_register(hdw, 0x0048, 0xffffffff);  \n\tret |= pvr2_hdw_gpio_chg_dir(hdw,0xffffffff,0x00000088);  \n\tret |= pvr2_hdw_gpio_chg_out(hdw,0xffffffff,0x00000008);  \n\tret |= pvr2_hdw_cmd_deep_reset(hdw);\n\tret |= pvr2_write_register(hdw, 0xa064, 0x00000000);  \n\tret |= pvr2_hdw_gpio_chg_dir(hdw,0xffffffff,0x00000408);  \n\tret |= pvr2_hdw_gpio_chg_out(hdw,0xffffffff,0x00000008);  \n\tret |= pvr2_write_register(hdw, 0x9058, 0xffffffed);  \n\tret |= pvr2_write_register(hdw, 0x9054, 0xfffffffd);  \n\tret |= pvr2_write_register(hdw, 0x07f8, 0x80000800);  \n\tret |= pvr2_write_register(hdw, 0x07fc, 0x0000001a);  \n\tret |= pvr2_write_register(hdw, 0x0700, 0x00000000);  \n\tret |= pvr2_write_register(hdw, 0xaa00, 0x00000000);  \n\tret |= pvr2_write_register(hdw, 0xaa04, 0x00057810);  \n\tret |= pvr2_write_register(hdw, 0xaa10, 0x00148500);  \n\tret |= pvr2_write_register(hdw, 0xaa18, 0x00840000);  \n\tret |= pvr2_issue_simple_cmd(hdw,FX2CMD_FWPOST1);\n\tret |= pvr2_issue_simple_cmd(hdw,FX2CMD_MEMSEL | (1 << 8) | (0 << 16));\n\n\tif (ret) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"firmware2 upload prep failed, ret=%d\",ret);\n\t\trelease_firmware(fw_entry);\n\t\tgoto done;\n\t}\n\n\t \n\n\tfw_len = fw_entry->size;\n\n\tif (fw_len % sizeof(u32)) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"size of %s firmware must be a multiple of %zu bytes\",\n\t\t\t   fw_files[fwidx],sizeof(u32));\n\t\trelease_firmware(fw_entry);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tfw_ptr = kmalloc(FIRMWARE_CHUNK_SIZE, GFP_KERNEL);\n\tif (fw_ptr == NULL){\n\t\trelease_firmware(fw_entry);\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"failed to allocate memory for firmware2 upload\");\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tpipe = usb_sndbulkpipe(hdw->usb_dev, PVR2_FIRMWARE_ENDPOINT);\n\n\tfw_done = 0;\n\tfor (fw_done = 0; fw_done < fw_len;) {\n\t\tbcnt = fw_len - fw_done;\n\t\tif (bcnt > FIRMWARE_CHUNK_SIZE) bcnt = FIRMWARE_CHUNK_SIZE;\n\t\tmemcpy(fw_ptr, fw_entry->data + fw_done, bcnt);\n\t\t \n\t\t \n\t\tfor (icnt = 0; icnt < bcnt/4 ; icnt++)\n\t\t\t((u32 *)fw_ptr)[icnt] = swab32(((u32 *)fw_ptr)[icnt]);\n\n\t\tret |= usb_bulk_msg(hdw->usb_dev, pipe, fw_ptr,bcnt,\n\t\t\t\t    &actual_length, 1000);\n\t\tret |= (actual_length != bcnt);\n\t\tif (ret) break;\n\t\tfw_done += bcnt;\n\t}\n\n\ttrace_firmware(\"upload of %s : %i / %i \",\n\t\t       fw_files[fwidx],fw_done,fw_len);\n\n\tkfree(fw_ptr);\n\trelease_firmware(fw_entry);\n\n\tif (ret) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"firmware2 upload transfer failure\");\n\t\tgoto done;\n\t}\n\n\t \n\n\tret |= pvr2_write_register(hdw, 0x9054, 0xffffffff);  \n\tret |= pvr2_write_register(hdw, 0x9058, 0xffffffe8);  \n\tret |= pvr2_issue_simple_cmd(hdw,FX2CMD_MEMSEL | (1 << 8) | (0 << 16));\n\n\tif (ret) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"firmware2 upload post-proc failure\");\n\t}\n\n done:\n\tif (hdw->hdw_desc->signal_routing_scheme ==\n\t    PVR2_ROUTING_SCHEME_GOTVIEW) {\n\t\t \n\t\tpvr2_hdw_gpio_chg_dir(hdw,(1 << 11),~0);\n\t}\n\treturn ret;\n}\n\n\nstatic const char *pvr2_get_state_name(unsigned int st)\n{\n\tif (st < ARRAY_SIZE(pvr2_state_names)) {\n\t\treturn pvr2_state_names[st];\n\t}\n\treturn \"???\";\n}\n\nstatic int pvr2_decoder_enable(struct pvr2_hdw *hdw,int enablefl)\n{\n\t \n\tpvr2_trace(PVR2_TRACE_CHIPS, \"subdev v4l2 stream=%s\",\n\t\t   (enablefl ? \"on\" : \"off\"));\n\tv4l2_device_call_all(&hdw->v4l2_dev, 0, video, s_stream, enablefl);\n\tv4l2_device_call_all(&hdw->v4l2_dev, 0, audio, s_stream, enablefl);\n\tif (hdw->decoder_client_id) {\n\t\t \n\t\treturn 0;\n\t}\n\tif (!hdw->flag_decoder_missed) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"***WARNING*** No decoder present\");\n\t\thdw->flag_decoder_missed = !0;\n\t\ttrace_stbit(\"flag_decoder_missed\",\n\t\t\t    hdw->flag_decoder_missed);\n\t}\n\treturn -EIO;\n}\n\n\nint pvr2_hdw_get_state(struct pvr2_hdw *hdw)\n{\n\treturn hdw->master_state;\n}\n\n\nstatic int pvr2_hdw_untrip_unlocked(struct pvr2_hdw *hdw)\n{\n\tif (!hdw->flag_tripped) return 0;\n\thdw->flag_tripped = 0;\n\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t   \"Clearing driver error status\");\n\treturn !0;\n}\n\n\nint pvr2_hdw_untrip(struct pvr2_hdw *hdw)\n{\n\tint fl;\n\tLOCK_TAKE(hdw->big_lock); do {\n\t\tfl = pvr2_hdw_untrip_unlocked(hdw);\n\t} while (0); LOCK_GIVE(hdw->big_lock);\n\tif (fl) pvr2_hdw_state_sched(hdw);\n\treturn 0;\n}\n\n\n\n\nint pvr2_hdw_get_streaming(struct pvr2_hdw *hdw)\n{\n\treturn hdw->state_pipeline_req != 0;\n}\n\n\nint pvr2_hdw_set_streaming(struct pvr2_hdw *hdw,int enable_flag)\n{\n\tint ret,st;\n\tLOCK_TAKE(hdw->big_lock);\n\tpvr2_hdw_untrip_unlocked(hdw);\n\tif (!enable_flag != !hdw->state_pipeline_req) {\n\t\thdw->state_pipeline_req = enable_flag != 0;\n\t\tpvr2_trace(PVR2_TRACE_START_STOP,\n\t\t\t   \"/*--TRACE_STREAM--*/ %s\",\n\t\t\t   enable_flag ? \"enable\" : \"disable\");\n\t}\n\tpvr2_hdw_state_sched(hdw);\n\tLOCK_GIVE(hdw->big_lock);\n\tif ((ret = pvr2_hdw_wait(hdw,0)) < 0) return ret;\n\tif (enable_flag) {\n\t\twhile ((st = hdw->master_state) != PVR2_STATE_RUN) {\n\t\t\tif (st != PVR2_STATE_READY) return -EIO;\n\t\t\tif ((ret = pvr2_hdw_wait(hdw,st)) < 0) return ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint pvr2_hdw_set_stream_type(struct pvr2_hdw *hdw,enum pvr2_config config)\n{\n\tint fl;\n\tLOCK_TAKE(hdw->big_lock);\n\tif ((fl = (hdw->desired_stream_type != config)) != 0) {\n\t\thdw->desired_stream_type = config;\n\t\thdw->state_pipeline_config = 0;\n\t\ttrace_stbit(\"state_pipeline_config\",\n\t\t\t    hdw->state_pipeline_config);\n\t\tpvr2_hdw_state_sched(hdw);\n\t}\n\tLOCK_GIVE(hdw->big_lock);\n\tif (fl) return 0;\n\treturn pvr2_hdw_wait(hdw,0);\n}\n\n\nstatic int get_default_tuner_type(struct pvr2_hdw *hdw)\n{\n\tint unit_number = hdw->unit_number;\n\tint tp = -1;\n\tif ((unit_number >= 0) && (unit_number < PVR_NUM)) {\n\t\ttp = tuner[unit_number];\n\t}\n\tif (tp < 0) return -EINVAL;\n\thdw->tuner_type = tp;\n\thdw->tuner_updated = !0;\n\treturn 0;\n}\n\n\nstatic v4l2_std_id get_default_standard(struct pvr2_hdw *hdw)\n{\n\tint unit_number = hdw->unit_number;\n\tint tp = 0;\n\tif ((unit_number >= 0) && (unit_number < PVR_NUM)) {\n\t\ttp = video_std[unit_number];\n\t\tif (tp) return tp;\n\t}\n\treturn 0;\n}\n\n\nstatic unsigned int get_default_error_tolerance(struct pvr2_hdw *hdw)\n{\n\tint unit_number = hdw->unit_number;\n\tint tp = 0;\n\tif ((unit_number >= 0) && (unit_number < PVR_NUM)) {\n\t\ttp = tolerance[unit_number];\n\t}\n\treturn tp;\n}\n\n\nstatic int pvr2_hdw_check_firmware(struct pvr2_hdw *hdw)\n{\n\t \n\tint result;\n\tLOCK_TAKE(hdw->ctl_lock); do {\n\t\thdw->cmd_buffer[0] = FX2CMD_GET_EEPROM_ADDR;\n\t\tresult = pvr2_send_request_ex(hdw,HZ*1,!0,\n\t\t\t\t\t   hdw->cmd_buffer,1,\n\t\t\t\t\t   hdw->cmd_buffer,1);\n\t\tif (result < 0) break;\n\t} while(0); LOCK_GIVE(hdw->ctl_lock);\n\tif (result) {\n\t\tpvr2_trace(PVR2_TRACE_INIT,\n\t\t\t   \"Probe of device endpoint 1 result status %d\",\n\t\t\t   result);\n\t} else {\n\t\tpvr2_trace(PVR2_TRACE_INIT,\n\t\t\t   \"Probe of device endpoint 1 succeeded\");\n\t}\n\treturn result == 0;\n}\n\nstruct pvr2_std_hack {\n\tv4l2_std_id pat;   \n\tv4l2_std_id msk;   \n\tv4l2_std_id std;   \n};\n\n \nstatic const struct pvr2_std_hack std_eeprom_maps[] = {\n\t{\t \n\t\t.pat = V4L2_STD_B|V4L2_STD_GH,\n\t\t.std = V4L2_STD_PAL_B|V4L2_STD_PAL_B1|V4L2_STD_PAL_G,\n\t},\n\t{\t \n\t\t.pat = V4L2_STD_MN,\n\t\t.std = V4L2_STD_NTSC_M,\n\t},\n\t{\t \n\t\t.pat = V4L2_STD_PAL_I,\n\t\t.std = V4L2_STD_PAL_I,\n\t},\n\t{\t \n\t\t.pat = V4L2_STD_SECAM_L|V4L2_STD_SECAM_LC,\n\t\t.std = V4L2_STD_SECAM_L|V4L2_STD_SECAM_LC,\n\t},\n\t{\t \n\t\t.pat = V4L2_STD_DK,\n\t\t.std = V4L2_STD_PAL_D|V4L2_STD_PAL_D1|V4L2_STD_PAL_K,\n\t},\n};\n\nstatic void pvr2_hdw_setup_std(struct pvr2_hdw *hdw)\n{\n\tchar buf[40];\n\tunsigned int bcnt;\n\tv4l2_std_id std1,std2,std3;\n\n\tstd1 = get_default_standard(hdw);\n\tstd3 = std1 ? 0 : hdw->hdw_desc->default_std_mask;\n\n\tbcnt = pvr2_std_id_to_str(buf,sizeof(buf),hdw->std_mask_eeprom);\n\tpvr2_trace(PVR2_TRACE_STD,\n\t\t   \"Supported video standard(s) reported available in hardware: %.*s\",\n\t\t   bcnt,buf);\n\n\thdw->std_mask_avail = hdw->std_mask_eeprom;\n\n\tstd2 = (std1|std3) & ~hdw->std_mask_avail;\n\tif (std2) {\n\t\tbcnt = pvr2_std_id_to_str(buf,sizeof(buf),std2);\n\t\tpvr2_trace(PVR2_TRACE_STD,\n\t\t\t   \"Expanding supported video standards to include: %.*s\",\n\t\t\t   bcnt,buf);\n\t\thdw->std_mask_avail |= std2;\n\t}\n\n\thdw->std_info_cur.def.type_bitmask.valid_bits = hdw->std_mask_avail;\n\n\tif (std1) {\n\t\tbcnt = pvr2_std_id_to_str(buf,sizeof(buf),std1);\n\t\tpvr2_trace(PVR2_TRACE_STD,\n\t\t\t   \"Initial video standard forced to %.*s\",\n\t\t\t   bcnt,buf);\n\t\thdw->std_mask_cur = std1;\n\t\thdw->std_dirty = !0;\n\t\treturn;\n\t}\n\tif (std3) {\n\t\tbcnt = pvr2_std_id_to_str(buf,sizeof(buf),std3);\n\t\tpvr2_trace(PVR2_TRACE_STD,\n\t\t\t   \"Initial video standard (determined by device type): %.*s\",\n\t\t\t   bcnt, buf);\n\t\thdw->std_mask_cur = std3;\n\t\thdw->std_dirty = !0;\n\t\treturn;\n\t}\n\n\t{\n\t\tunsigned int idx;\n\t\tfor (idx = 0; idx < ARRAY_SIZE(std_eeprom_maps); idx++) {\n\t\t\tif (std_eeprom_maps[idx].msk ?\n\t\t\t    ((std_eeprom_maps[idx].pat ^\n\t\t\t     hdw->std_mask_eeprom) &\n\t\t\t     std_eeprom_maps[idx].msk) :\n\t\t\t    (std_eeprom_maps[idx].pat !=\n\t\t\t     hdw->std_mask_eeprom)) continue;\n\t\t\tbcnt = pvr2_std_id_to_str(buf,sizeof(buf),\n\t\t\t\t\t\t  std_eeprom_maps[idx].std);\n\t\t\tpvr2_trace(PVR2_TRACE_STD,\n\t\t\t\t   \"Initial video standard guessed as %.*s\",\n\t\t\t\t   bcnt,buf);\n\t\t\thdw->std_mask_cur = std_eeprom_maps[idx].std;\n\t\t\thdw->std_dirty = !0;\n\t\t\treturn;\n\t\t}\n\t}\n\n}\n\n\nstatic unsigned int pvr2_copy_i2c_addr_list(\n\tunsigned short *dst, const unsigned char *src,\n\tunsigned int dst_max)\n{\n\tunsigned int cnt = 0;\n\tif (!src) return 0;\n\twhile (src[cnt] && (cnt + 1) < dst_max) {\n\t\tdst[cnt] = src[cnt];\n\t\tcnt++;\n\t}\n\tdst[cnt] = I2C_CLIENT_END;\n\treturn cnt;\n}\n\n\nstatic void pvr2_hdw_cx25840_vbi_hack(struct pvr2_hdw *hdw)\n{\n\t \n\tstruct v4l2_format fmt;\n\tif (hdw->decoder_client_id != PVR2_CLIENT_ID_CX25840) {\n\t\t \n\t\treturn;\n\t}\n\n\tpvr2_trace(PVR2_TRACE_INIT,\n\t\t   \"Module ID %u: Executing cx25840 VBI hack\",\n\t\t   hdw->decoder_client_id);\n\tmemset(&fmt, 0, sizeof(fmt));\n\tfmt.type = V4L2_BUF_TYPE_SLICED_VBI_CAPTURE;\n\tfmt.fmt.sliced.service_lines[0][21] = V4L2_SLICED_CAPTION_525;\n\tfmt.fmt.sliced.service_lines[1][21] = V4L2_SLICED_CAPTION_525;\n\tv4l2_device_call_all(&hdw->v4l2_dev, hdw->decoder_client_id,\n\t\t\t     vbi, s_sliced_fmt, &fmt.fmt.sliced);\n}\n\n\nstatic int pvr2_hdw_load_subdev(struct pvr2_hdw *hdw,\n\t\t\t\tconst struct pvr2_device_client_desc *cd)\n{\n\tconst char *fname;\n\tunsigned char mid;\n\tstruct v4l2_subdev *sd;\n\tunsigned int i2ccnt;\n\tconst unsigned char *p;\n\t \n\tunsigned short i2caddr[25];\n\n\tmid = cd->module_id;\n\tfname = (mid < ARRAY_SIZE(module_names)) ? module_names[mid] : NULL;\n\tif (!fname) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"Module ID %u for device %s has no name?  The driver might have a configuration problem.\",\n\t\t\t   mid,\n\t\t\t   hdw->hdw_desc->description);\n\t\treturn -EINVAL;\n\t}\n\tpvr2_trace(PVR2_TRACE_INIT,\n\t\t   \"Module ID %u (%s) for device %s being loaded...\",\n\t\t   mid, fname,\n\t\t   hdw->hdw_desc->description);\n\n\ti2ccnt = pvr2_copy_i2c_addr_list(i2caddr, cd->i2c_address_list,\n\t\t\t\t\t ARRAY_SIZE(i2caddr));\n\tif (!i2ccnt && ((p = (mid < ARRAY_SIZE(module_i2c_addresses)) ?\n\t\t\t module_i2c_addresses[mid] : NULL) != NULL)) {\n\t\t \n\t\ti2ccnt = pvr2_copy_i2c_addr_list(i2caddr, p,\n\t\t\t\t\t\t ARRAY_SIZE(i2caddr));\n\t\tif (i2ccnt) {\n\t\t\tpvr2_trace(PVR2_TRACE_INIT,\n\t\t\t\t   \"Module ID %u: Using default i2c address list\",\n\t\t\t\t   mid);\n\t\t}\n\t}\n\n\tif (!i2ccnt) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"Module ID %u (%s) for device %s: No i2c addresses.\tThe driver might have a configuration problem.\",\n\t\t\t   mid, fname, hdw->hdw_desc->description);\n\t\treturn -EINVAL;\n\t}\n\n\tif (i2ccnt == 1) {\n\t\tpvr2_trace(PVR2_TRACE_INIT,\n\t\t\t   \"Module ID %u: Setting up with specified i2c address 0x%x\",\n\t\t\t   mid, i2caddr[0]);\n\t\tsd = v4l2_i2c_new_subdev(&hdw->v4l2_dev, &hdw->i2c_adap,\n\t\t\t\t\t fname, i2caddr[0], NULL);\n\t} else {\n\t\tpvr2_trace(PVR2_TRACE_INIT,\n\t\t\t   \"Module ID %u: Setting up with address probe list\",\n\t\t\t   mid);\n\t\tsd = v4l2_i2c_new_subdev(&hdw->v4l2_dev, &hdw->i2c_adap,\n\t\t\t\t\t fname, 0, i2caddr);\n\t}\n\n\tif (!sd) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"Module ID %u (%s) for device %s failed to load.  Possible missing sub-device kernel module or initialization failure within module.\",\n\t\t\t   mid, fname, hdw->hdw_desc->description);\n\t\treturn -EIO;\n\t}\n\n\t \n\tsd->grp_id = mid;\n\n\tpvr2_trace(PVR2_TRACE_INFO, \"Attached sub-driver %s\", fname);\n\n\n\t \n\tswitch (mid) {\n\tcase PVR2_CLIENT_ID_CX25840:\n\tcase PVR2_CLIENT_ID_SAA7115:\n\t\thdw->decoder_client_id = mid;\n\t\tbreak;\n\tdefault: break;\n\t}\n\n\treturn 0;\n}\n\n\nstatic void pvr2_hdw_load_modules(struct pvr2_hdw *hdw)\n{\n\tunsigned int idx;\n\tconst struct pvr2_string_table *cm;\n\tconst struct pvr2_device_client_table *ct;\n\tint okFl = !0;\n\n\tcm = &hdw->hdw_desc->client_modules;\n\tfor (idx = 0; idx < cm->cnt; idx++) {\n\t\trequest_module(cm->lst[idx]);\n\t}\n\n\tct = &hdw->hdw_desc->client_table;\n\tfor (idx = 0; idx < ct->cnt; idx++) {\n\t\tif (pvr2_hdw_load_subdev(hdw, &ct->lst[idx]) < 0) okFl = 0;\n\t}\n\tif (!okFl) {\n\t\thdw->flag_modulefail = !0;\n\t\tpvr2_hdw_render_useless(hdw);\n\t}\n}\n\n\nstatic void pvr2_hdw_setup_low(struct pvr2_hdw *hdw)\n{\n\tint ret;\n\tunsigned int idx;\n\tstruct pvr2_ctrl *cptr;\n\tint reloadFl = 0;\n\tif (hdw->hdw_desc->fx2_firmware.cnt) {\n\t\tif (!reloadFl) {\n\t\t\treloadFl =\n\t\t\t\t(hdw->usb_intf->cur_altsetting->desc.bNumEndpoints\n\t\t\t\t == 0);\n\t\t\tif (reloadFl) {\n\t\t\t\tpvr2_trace(PVR2_TRACE_INIT,\n\t\t\t\t\t   \"USB endpoint config looks strange; possibly firmware needs to be loaded\");\n\t\t\t}\n\t\t}\n\t\tif (!reloadFl) {\n\t\t\treloadFl = !pvr2_hdw_check_firmware(hdw);\n\t\t\tif (reloadFl) {\n\t\t\t\tpvr2_trace(PVR2_TRACE_INIT,\n\t\t\t\t\t   \"Check for FX2 firmware failed; possibly firmware needs to be loaded\");\n\t\t\t}\n\t\t}\n\t\tif (reloadFl) {\n\t\t\tif (pvr2_upload_firmware1(hdw) != 0) {\n\t\t\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\t   \"Failure uploading firmware1\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\thdw->fw1_state = FW1_STATE_OK;\n\n\tif (!pvr2_hdw_dev_ok(hdw)) return;\n\n\thdw->force_dirty = !0;\n\n\tif (!hdw->hdw_desc->flag_no_powerup) {\n\t\tpvr2_hdw_cmd_powerup(hdw);\n\t\tif (!pvr2_hdw_dev_ok(hdw)) return;\n\t}\n\n\t \n\tif (hdw->ir_scheme_active == PVR2_IR_SCHEME_ZILOG) {\n\t\tpvr2_issue_simple_cmd(hdw,\n\t\t\t\t      FX2CMD_HCW_ZILOG_RESET |\n\t\t\t\t      (1 << 8) |\n\t\t\t\t      ((0) << 16));\n\t}\n\n\t \n\tpvr2_i2c_core_init(hdw);\n\tif (!pvr2_hdw_dev_ok(hdw)) return;\n\n\t \n\tif (le16_to_cpu(hdw->usb_dev->descriptor.idVendor) == 0x2040 &&\n\t    (le16_to_cpu(hdw->usb_dev->descriptor.idProduct) == 0x7502 ||\n\t     le16_to_cpu(hdw->usb_dev->descriptor.idProduct) == 0x7510)) {\n\t\tpr_info(\"%s(): resetting 160xxx demod\\n\", __func__);\n\t\t \n\t\tpvr2_issue_simple_cmd(hdw,\n\t\t\t\t      FX2CMD_HCW_DEMOD_RESET_PIN |\n\t\t\t\t      (1 << 8) |\n\t\t\t\t      ((0) << 16));\n\t\tusleep_range(10000, 10500);\n\t\tpvr2_issue_simple_cmd(hdw,\n\t\t\t\t      FX2CMD_HCW_DEMOD_RESET_PIN |\n\t\t\t\t      (1 << 8) |\n\t\t\t\t      ((1) << 16));\n\t\tusleep_range(10000, 10500);\n\t}\n\n\tpvr2_hdw_load_modules(hdw);\n\tif (!pvr2_hdw_dev_ok(hdw)) return;\n\n\tv4l2_device_call_all(&hdw->v4l2_dev, 0, core, load_fw);\n\n\tfor (idx = 0; idx < CTRLDEF_COUNT; idx++) {\n\t\tcptr = hdw->controls + idx;\n\t\tif (cptr->info->skip_init) continue;\n\t\tif (!cptr->info->set_value) continue;\n\t\tcptr->info->set_value(cptr,~0,cptr->info->default_value);\n\t}\n\n\tpvr2_hdw_cx25840_vbi_hack(hdw);\n\n\t \n\n\thdw->freqValTelevision = default_tv_freq;\n\thdw->freqValRadio = default_radio_freq;\n\n\t\n\t\n\t\n\n\tif (hdw->hdw_desc->flag_has_hauppauge_rom) {\n\t\tret = pvr2_hdw_get_eeprom_addr(hdw);\n\t\tif (!pvr2_hdw_dev_ok(hdw)) return;\n\t\tif (ret < 0) {\n\t\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t\t   \"Unable to determine location of eeprom, skipping\");\n\t\t} else {\n\t\t\thdw->eeprom_addr = ret;\n\t\t\tpvr2_eeprom_analyze(hdw);\n\t\t\tif (!pvr2_hdw_dev_ok(hdw)) return;\n\t\t}\n\t} else {\n\t\thdw->tuner_type = hdw->hdw_desc->default_tuner_type;\n\t\thdw->tuner_updated = !0;\n\t\thdw->std_mask_eeprom = V4L2_STD_ALL;\n\t}\n\n\tif (hdw->serial_number) {\n\t\tidx = scnprintf(hdw->identifier, sizeof(hdw->identifier) - 1,\n\t\t\t\t\"sn-%lu\", hdw->serial_number);\n\t} else if (hdw->unit_number >= 0) {\n\t\tidx = scnprintf(hdw->identifier, sizeof(hdw->identifier) - 1,\n\t\t\t\t\"unit-%c\",\n\t\t\t\thdw->unit_number + 'a');\n\t} else {\n\t\tidx = scnprintf(hdw->identifier, sizeof(hdw->identifier) - 1,\n\t\t\t\t\"unit-??\");\n\t}\n\thdw->identifier[idx] = 0;\n\n\tpvr2_hdw_setup_std(hdw);\n\n\tif (!get_default_tuner_type(hdw)) {\n\t\tpvr2_trace(PVR2_TRACE_INIT,\n\t\t\t   \"pvr2_hdw_setup: Tuner type overridden to %d\",\n\t\t\t   hdw->tuner_type);\n\t}\n\n\n\tif (!pvr2_hdw_dev_ok(hdw)) return;\n\n\tif (hdw->hdw_desc->signal_routing_scheme ==\n\t    PVR2_ROUTING_SCHEME_GOTVIEW) {\n\t\t \n\t\tpvr2_hdw_gpio_chg_dir(hdw,(1 << 11),~0);\n\t}\n\n\tpvr2_hdw_commit_setup(hdw);\n\n\thdw->vid_stream = pvr2_stream_create();\n\tif (!pvr2_hdw_dev_ok(hdw)) return;\n\tpvr2_trace(PVR2_TRACE_INIT,\n\t\t   \"pvr2_hdw_setup: video stream is %p\",hdw->vid_stream);\n\tif (hdw->vid_stream) {\n\t\tidx = get_default_error_tolerance(hdw);\n\t\tif (idx) {\n\t\t\tpvr2_trace(PVR2_TRACE_INIT,\n\t\t\t\t   \"pvr2_hdw_setup: video stream %p setting tolerance %u\",\n\t\t\t\t   hdw->vid_stream,idx);\n\t\t}\n\t\tpvr2_stream_setup(hdw->vid_stream,hdw->usb_dev,\n\t\t\t\t  PVR2_VID_ENDPOINT,idx);\n\t}\n\n\tif (!pvr2_hdw_dev_ok(hdw)) return;\n\n\thdw->flag_init_ok = !0;\n\n\tpvr2_hdw_state_sched(hdw);\n}\n\n\n \nstatic void pvr2_hdw_setup(struct pvr2_hdw *hdw)\n{\n\tpvr2_trace(PVR2_TRACE_INIT,\"pvr2_hdw_setup(hdw=%p) begin\",hdw);\n\tdo {\n\t\tpvr2_hdw_setup_low(hdw);\n\t\tpvr2_trace(PVR2_TRACE_INIT,\n\t\t\t   \"pvr2_hdw_setup(hdw=%p) done, ok=%d init_ok=%d\",\n\t\t\t   hdw,pvr2_hdw_dev_ok(hdw),hdw->flag_init_ok);\n\t\tif (pvr2_hdw_dev_ok(hdw)) {\n\t\t\tif (hdw->flag_init_ok) {\n\t\t\t\tpvr2_trace(\n\t\t\t\t\tPVR2_TRACE_INFO,\n\t\t\t\t\t\"Device initialization completed successfully.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (hdw->fw1_state == FW1_STATE_RELOAD) {\n\t\t\t\tpvr2_trace(\n\t\t\t\t\tPVR2_TRACE_INFO,\n\t\t\t\t\t\"Device microcontroller firmware (re)loaded; it should now reset and reconnect.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpvr2_trace(\n\t\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\"Device initialization was not successful.\");\n\t\t\tif (hdw->fw1_state == FW1_STATE_MISSING) {\n\t\t\t\tpvr2_trace(\n\t\t\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\t\"Giving up since device microcontroller firmware appears to be missing.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hdw->flag_modulefail) {\n\t\t\tpvr2_trace(\n\t\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\"***WARNING*** pvrusb2 driver initialization failed due to the failure of one or more sub-device kernel modules.\");\n\t\t\tpvr2_trace(\n\t\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\"You need to resolve the failing condition before this driver can function.  There should be some earlier messages giving more information about the problem.\");\n\t\t\tbreak;\n\t\t}\n\t\tif (procreload) {\n\t\t\tpvr2_trace(\n\t\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\"Attempting pvrusb2 recovery by reloading primary firmware.\");\n\t\t\tpvr2_trace(\n\t\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\"If this works, device should disconnect and reconnect in a sane state.\");\n\t\t\thdw->fw1_state = FW1_STATE_UNKNOWN;\n\t\t\tpvr2_upload_firmware1(hdw);\n\t\t} else {\n\t\t\tpvr2_trace(\n\t\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\"***WARNING*** pvrusb2 device hardware appears to be jammed and I can't clear it.\");\n\t\t\tpvr2_trace(\n\t\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\"You might need to power cycle the pvrusb2 device in order to recover.\");\n\t\t}\n\t} while (0);\n\tpvr2_trace(PVR2_TRACE_INIT,\"pvr2_hdw_setup(hdw=%p) end\",hdw);\n}\n\n\n \nint pvr2_hdw_initialize(struct pvr2_hdw *hdw,\n\t\t\tvoid (*callback_func)(void *),\n\t\t\tvoid *callback_data)\n{\n\tLOCK_TAKE(hdw->big_lock); do {\n\t\tif (hdw->flag_disconnected) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\thdw->state_data = callback_data;\n\t\thdw->state_func = callback_func;\n\t\tpvr2_hdw_setup(hdw);\n\t} while (0); LOCK_GIVE(hdw->big_lock);\n\treturn hdw->flag_init_ok;\n}\n\n\n \nstruct pvr2_hdw *pvr2_hdw_create(struct usb_interface *intf,\n\t\t\t\t const struct usb_device_id *devid)\n{\n\tunsigned int idx,cnt1,cnt2,m;\n\tstruct pvr2_hdw *hdw = NULL;\n\tint valid_std_mask;\n\tstruct pvr2_ctrl *cptr;\n\tstruct usb_device *usb_dev;\n\tconst struct pvr2_device_desc *hdw_desc;\n\t__u8 ifnum;\n\tstruct v4l2_queryctrl qctrl;\n\tstruct pvr2_ctl_info *ciptr;\n\n\tusb_dev = interface_to_usbdev(intf);\n\n\thdw_desc = (const struct pvr2_device_desc *)(devid->driver_info);\n\n\tif (hdw_desc == NULL) {\n\t\tpvr2_trace(PVR2_TRACE_INIT, \"pvr2_hdw_create: No device description pointer, unable to continue.\");\n\t\tpvr2_trace(PVR2_TRACE_INIT,\n\t\t\t   \"If you have a new device type, please contact Mike Isely <isely@pobox.com> to get it included in the driver\");\n\t\tgoto fail;\n\t}\n\n\thdw = kzalloc(sizeof(*hdw),GFP_KERNEL);\n\tpvr2_trace(PVR2_TRACE_INIT,\"pvr2_hdw_create: hdw=%p, type \\\"%s\\\"\",\n\t\t   hdw,hdw_desc->description);\n\tpvr2_trace(PVR2_TRACE_INFO, \"Hardware description: %s\",\n\t\thdw_desc->description);\n\tif (hdw_desc->flag_is_experimental) {\n\t\tpvr2_trace(PVR2_TRACE_INFO, \"**********\");\n\t\tpvr2_trace(PVR2_TRACE_INFO,\n\t\t\t   \"***WARNING*** Support for this device (%s) is experimental.\",\n\t\t\t\t\t\t\t      hdw_desc->description);\n\t\tpvr2_trace(PVR2_TRACE_INFO,\n\t\t\t   \"Important functionality might not be entirely working.\");\n\t\tpvr2_trace(PVR2_TRACE_INFO,\n\t\t\t   \"Please consider contacting the driver author to help with further stabilization of the driver.\");\n\t\tpvr2_trace(PVR2_TRACE_INFO, \"**********\");\n\t}\n\tif (!hdw) goto fail;\n\n\ttimer_setup(&hdw->quiescent_timer, pvr2_hdw_quiescent_timeout, 0);\n\n\ttimer_setup(&hdw->decoder_stabilization_timer,\n\t\t    pvr2_hdw_decoder_stabilization_timeout, 0);\n\n\ttimer_setup(&hdw->encoder_wait_timer, pvr2_hdw_encoder_wait_timeout,\n\t\t    0);\n\n\ttimer_setup(&hdw->encoder_run_timer, pvr2_hdw_encoder_run_timeout, 0);\n\n\thdw->master_state = PVR2_STATE_DEAD;\n\n\tinit_waitqueue_head(&hdw->state_wait_data);\n\n\thdw->tuner_signal_stale = !0;\n\tcx2341x_fill_defaults(&hdw->enc_ctl_state);\n\n\t \n\tm = 0;\n\tif (hdw_desc->flag_has_analogtuner) m |= 1 << PVR2_CVAL_INPUT_TV;\n\tif (hdw_desc->digital_control_scheme != PVR2_DIGITAL_SCHEME_NONE) {\n\t\tm |= 1 << PVR2_CVAL_INPUT_DTV;\n\t}\n\tif (hdw_desc->flag_has_svideo) m |= 1 << PVR2_CVAL_INPUT_SVIDEO;\n\tif (hdw_desc->flag_has_composite) m |= 1 << PVR2_CVAL_INPUT_COMPOSITE;\n\tif (hdw_desc->flag_has_fmradio) m |= 1 << PVR2_CVAL_INPUT_RADIO;\n\thdw->input_avail_mask = m;\n\thdw->input_allowed_mask = hdw->input_avail_mask;\n\n\t \n\tif (!(hdw->input_avail_mask & (1 << PVR2_CVAL_INPUT_DTV))) {\n\t\thdw->pathway_state = PVR2_PATHWAY_ANALOG;\n\t} else if (!(hdw->input_avail_mask & (1 << PVR2_CVAL_INPUT_TV))) {\n\t\thdw->pathway_state = PVR2_PATHWAY_DIGITAL;\n\t}\n\n\thdw->control_cnt = CTRLDEF_COUNT;\n\thdw->control_cnt += MPEGDEF_COUNT;\n\thdw->controls = kcalloc(hdw->control_cnt, sizeof(struct pvr2_ctrl),\n\t\t\t\tGFP_KERNEL);\n\tif (!hdw->controls) goto fail;\n\thdw->hdw_desc = hdw_desc;\n\thdw->ir_scheme_active = hdw->hdw_desc->ir_scheme;\n\tfor (idx = 0; idx < hdw->control_cnt; idx++) {\n\t\tcptr = hdw->controls + idx;\n\t\tcptr->hdw = hdw;\n\t}\n\tfor (idx = 0; idx < 32; idx++) {\n\t\thdw->std_mask_ptrs[idx] = hdw->std_mask_names[idx];\n\t}\n\tfor (idx = 0; idx < CTRLDEF_COUNT; idx++) {\n\t\tcptr = hdw->controls + idx;\n\t\tcptr->info = control_defs+idx;\n\t}\n\n\t \n\tm = hdw->input_avail_mask;\n\tif (m) for (idx = 0; idx < (sizeof(m) << 3); idx++) {\n\t\tif (!((1UL << idx) & m)) continue;\n\t\thdw->input_val = idx;\n\t\tbreak;\n\t}\n\n\t \n\thdw->mpeg_ctrl_info = kcalloc(MPEGDEF_COUNT,\n\t\t\t\t      sizeof(*(hdw->mpeg_ctrl_info)),\n\t\t\t\t      GFP_KERNEL);\n\tif (!hdw->mpeg_ctrl_info) goto fail;\n\tfor (idx = 0; idx < MPEGDEF_COUNT; idx++) {\n\t\tcptr = hdw->controls + idx + CTRLDEF_COUNT;\n\t\tciptr = &(hdw->mpeg_ctrl_info[idx].info);\n\t\tciptr->desc = hdw->mpeg_ctrl_info[idx].desc;\n\t\tciptr->name = mpeg_ids[idx].strid;\n\t\tciptr->v4l_id = mpeg_ids[idx].id;\n\t\tciptr->skip_init = !0;\n\t\tciptr->get_value = ctrl_cx2341x_get;\n\t\tciptr->get_v4lflags = ctrl_cx2341x_getv4lflags;\n\t\tciptr->is_dirty = ctrl_cx2341x_is_dirty;\n\t\tif (!idx) ciptr->clear_dirty = ctrl_cx2341x_clear_dirty;\n\t\tqctrl.id = ciptr->v4l_id;\n\t\tcx2341x_ctrl_query(&hdw->enc_ctl_state,&qctrl);\n\t\tif (!(qctrl.flags & V4L2_CTRL_FLAG_READ_ONLY)) {\n\t\t\tciptr->set_value = ctrl_cx2341x_set;\n\t\t}\n\t\tstrscpy(hdw->mpeg_ctrl_info[idx].desc, qctrl.name,\n\t\t\tsizeof(hdw->mpeg_ctrl_info[idx].desc));\n\t\tciptr->default_value = qctrl.default_value;\n\t\tswitch (qctrl.type) {\n\t\tdefault:\n\t\tcase V4L2_CTRL_TYPE_INTEGER:\n\t\t\tciptr->type = pvr2_ctl_int;\n\t\t\tciptr->def.type_int.min_value = qctrl.minimum;\n\t\t\tciptr->def.type_int.max_value = qctrl.maximum;\n\t\t\tbreak;\n\t\tcase V4L2_CTRL_TYPE_BOOLEAN:\n\t\t\tciptr->type = pvr2_ctl_bool;\n\t\t\tbreak;\n\t\tcase V4L2_CTRL_TYPE_MENU:\n\t\t\tciptr->type = pvr2_ctl_enum;\n\t\t\tciptr->def.type_enum.value_names =\n\t\t\t\tcx2341x_ctrl_get_menu(&hdw->enc_ctl_state,\n\t\t\t\t\t\t\t\tciptr->v4l_id);\n\t\t\tfor (cnt1 = 0;\n\t\t\t     ciptr->def.type_enum.value_names[cnt1] != NULL;\n\t\t\t     cnt1++) { }\n\t\t\tciptr->def.type_enum.count = cnt1;\n\t\t\tbreak;\n\t\t}\n\t\tcptr->info = ciptr;\n\t}\n\n\t\n\tvalid_std_mask = pvr2_std_get_usable();\n\tfor (idx = 0; idx < 32; idx++) {\n\t\tif (!(valid_std_mask & (1UL << idx))) continue;\n\t\tcnt1 = pvr2_std_id_to_str(\n\t\t\thdw->std_mask_names[idx],\n\t\t\tsizeof(hdw->std_mask_names[idx])-1,\n\t\t\t1UL << idx);\n\t\thdw->std_mask_names[idx][cnt1] = 0;\n\t}\n\tcptr = pvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_STDAVAIL);\n\tif (cptr) {\n\t\tmemcpy(&hdw->std_info_avail,cptr->info,\n\t\t       sizeof(hdw->std_info_avail));\n\t\tcptr->info = &hdw->std_info_avail;\n\t\thdw->std_info_avail.def.type_bitmask.bit_names =\n\t\t\thdw->std_mask_ptrs;\n\t\thdw->std_info_avail.def.type_bitmask.valid_bits =\n\t\t\tvalid_std_mask;\n\t}\n\tcptr = pvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_STDCUR);\n\tif (cptr) {\n\t\tmemcpy(&hdw->std_info_cur,cptr->info,\n\t\t       sizeof(hdw->std_info_cur));\n\t\tcptr->info = &hdw->std_info_cur;\n\t\thdw->std_info_cur.def.type_bitmask.bit_names =\n\t\t\thdw->std_mask_ptrs;\n\t\thdw->std_info_cur.def.type_bitmask.valid_bits =\n\t\t\tvalid_std_mask;\n\t}\n\tcptr = pvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_STDDETECT);\n\tif (cptr) {\n\t\tmemcpy(&hdw->std_info_detect,cptr->info,\n\t\t       sizeof(hdw->std_info_detect));\n\t\tcptr->info = &hdw->std_info_detect;\n\t\thdw->std_info_detect.def.type_bitmask.bit_names =\n\t\t\thdw->std_mask_ptrs;\n\t\thdw->std_info_detect.def.type_bitmask.valid_bits =\n\t\t\tvalid_std_mask;\n\t}\n\n\thdw->cropcap_stale = !0;\n\thdw->eeprom_addr = -1;\n\thdw->unit_number = -1;\n\thdw->v4l_minor_number_video = -1;\n\thdw->v4l_minor_number_vbi = -1;\n\thdw->v4l_minor_number_radio = -1;\n\thdw->ctl_write_buffer = kmalloc(PVR2_CTL_BUFFSIZE,GFP_KERNEL);\n\tif (!hdw->ctl_write_buffer) goto fail;\n\thdw->ctl_read_buffer = kmalloc(PVR2_CTL_BUFFSIZE,GFP_KERNEL);\n\tif (!hdw->ctl_read_buffer) goto fail;\n\thdw->ctl_write_urb = usb_alloc_urb(0,GFP_KERNEL);\n\tif (!hdw->ctl_write_urb) goto fail;\n\thdw->ctl_read_urb = usb_alloc_urb(0,GFP_KERNEL);\n\tif (!hdw->ctl_read_urb) goto fail;\n\n\tif (v4l2_device_register(&intf->dev, &hdw->v4l2_dev) != 0) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"Error registering with v4l core, giving up\");\n\t\tgoto fail;\n\t}\n\tmutex_lock(&pvr2_unit_mtx);\n\tdo {\n\t\tfor (idx = 0; idx < PVR_NUM; idx++) {\n\t\t\tif (unit_pointers[idx]) continue;\n\t\t\thdw->unit_number = idx;\n\t\t\tunit_pointers[idx] = hdw;\n\t\t\tbreak;\n\t\t}\n\t} while (0);\n\tmutex_unlock(&pvr2_unit_mtx);\n\n\tINIT_WORK(&hdw->workpoll, pvr2_hdw_worker_poll);\n\n\tif (hdw->unit_number == -1)\n\t\tgoto fail;\n\n\tcnt1 = 0;\n\tcnt2 = scnprintf(hdw->name+cnt1,sizeof(hdw->name)-cnt1,\"pvrusb2\");\n\tcnt1 += cnt2;\n\tif (hdw->unit_number >= 0) {\n\t\tcnt2 = scnprintf(hdw->name+cnt1,sizeof(hdw->name)-cnt1,\"_%c\",\n\t\t\t\t ('a' + hdw->unit_number));\n\t\tcnt1 += cnt2;\n\t}\n\tif (cnt1 >= sizeof(hdw->name)) cnt1 = sizeof(hdw->name)-1;\n\thdw->name[cnt1] = 0;\n\n\tpvr2_trace(PVR2_TRACE_INIT,\"Driver unit number is %d, name is %s\",\n\t\t   hdw->unit_number,hdw->name);\n\n\thdw->tuner_type = -1;\n\thdw->flag_ok = !0;\n\n\thdw->usb_intf = intf;\n\thdw->usb_dev = usb_dev;\n\n\tusb_make_path(hdw->usb_dev, hdw->bus_info, sizeof(hdw->bus_info));\n\n\tifnum = hdw->usb_intf->cur_altsetting->desc.bInterfaceNumber;\n\tusb_set_interface(hdw->usb_dev,ifnum,0);\n\n\tmutex_init(&hdw->ctl_lock_mutex);\n\tmutex_init(&hdw->big_lock_mutex);\n\n\treturn hdw;\n fail:\n\tif (hdw) {\n\t\ttimer_shutdown_sync(&hdw->quiescent_timer);\n\t\ttimer_shutdown_sync(&hdw->decoder_stabilization_timer);\n\t\ttimer_shutdown_sync(&hdw->encoder_run_timer);\n\t\ttimer_shutdown_sync(&hdw->encoder_wait_timer);\n\t\tflush_work(&hdw->workpoll);\n\t\tv4l2_device_unregister(&hdw->v4l2_dev);\n\t\tusb_free_urb(hdw->ctl_read_urb);\n\t\tusb_free_urb(hdw->ctl_write_urb);\n\t\tkfree(hdw->ctl_read_buffer);\n\t\tkfree(hdw->ctl_write_buffer);\n\t\tkfree(hdw->controls);\n\t\tkfree(hdw->mpeg_ctrl_info);\n\t\tkfree(hdw);\n\t}\n\treturn NULL;\n}\n\n\n \nstatic void pvr2_hdw_remove_usb_stuff(struct pvr2_hdw *hdw)\n{\n\tif (hdw->flag_disconnected) return;\n\tpvr2_trace(PVR2_TRACE_INIT,\"pvr2_hdw_remove_usb_stuff: hdw=%p\",hdw);\n\tif (hdw->ctl_read_urb) {\n\t\tusb_kill_urb(hdw->ctl_read_urb);\n\t\tusb_free_urb(hdw->ctl_read_urb);\n\t\thdw->ctl_read_urb = NULL;\n\t}\n\tif (hdw->ctl_write_urb) {\n\t\tusb_kill_urb(hdw->ctl_write_urb);\n\t\tusb_free_urb(hdw->ctl_write_urb);\n\t\thdw->ctl_write_urb = NULL;\n\t}\n\tif (hdw->ctl_read_buffer) {\n\t\tkfree(hdw->ctl_read_buffer);\n\t\thdw->ctl_read_buffer = NULL;\n\t}\n\tif (hdw->ctl_write_buffer) {\n\t\tkfree(hdw->ctl_write_buffer);\n\t\thdw->ctl_write_buffer = NULL;\n\t}\n\thdw->flag_disconnected = !0;\n\t \n\tv4l2_device_disconnect(&hdw->v4l2_dev);\n\thdw->usb_dev = NULL;\n\thdw->usb_intf = NULL;\n\tpvr2_hdw_render_useless(hdw);\n}\n\nvoid pvr2_hdw_set_v4l2_dev(struct pvr2_hdw *hdw, struct video_device *vdev)\n{\n\tvdev->v4l2_dev = &hdw->v4l2_dev;\n}\n\n \nvoid pvr2_hdw_destroy(struct pvr2_hdw *hdw)\n{\n\tif (!hdw) return;\n\tpvr2_trace(PVR2_TRACE_INIT,\"pvr2_hdw_destroy: hdw=%p\",hdw);\n\tflush_work(&hdw->workpoll);\n\ttimer_shutdown_sync(&hdw->quiescent_timer);\n\ttimer_shutdown_sync(&hdw->decoder_stabilization_timer);\n\ttimer_shutdown_sync(&hdw->encoder_run_timer);\n\ttimer_shutdown_sync(&hdw->encoder_wait_timer);\n\tif (hdw->fw_buffer) {\n\t\tkfree(hdw->fw_buffer);\n\t\thdw->fw_buffer = NULL;\n\t}\n\tif (hdw->vid_stream) {\n\t\tpvr2_stream_destroy(hdw->vid_stream);\n\t\thdw->vid_stream = NULL;\n\t}\n\tv4l2_device_unregister(&hdw->v4l2_dev);\n\tpvr2_hdw_disconnect(hdw);\n\tmutex_lock(&pvr2_unit_mtx);\n\tdo {\n\t\tif ((hdw->unit_number >= 0) &&\n\t\t    (hdw->unit_number < PVR_NUM) &&\n\t\t    (unit_pointers[hdw->unit_number] == hdw)) {\n\t\t\tunit_pointers[hdw->unit_number] = NULL;\n\t\t}\n\t} while (0);\n\tmutex_unlock(&pvr2_unit_mtx);\n\tkfree(hdw->controls);\n\tkfree(hdw->mpeg_ctrl_info);\n\tkfree(hdw);\n}\n\n\nint pvr2_hdw_dev_ok(struct pvr2_hdw *hdw)\n{\n\treturn (hdw && hdw->flag_ok);\n}\n\n\n \nvoid pvr2_hdw_disconnect(struct pvr2_hdw *hdw)\n{\n\tpvr2_trace(PVR2_TRACE_INIT,\"pvr2_hdw_disconnect(hdw=%p)\",hdw);\n\tLOCK_TAKE(hdw->big_lock);\n\tpvr2_i2c_core_done(hdw);\n\tLOCK_TAKE(hdw->ctl_lock);\n\tpvr2_hdw_remove_usb_stuff(hdw);\n\tLOCK_GIVE(hdw->ctl_lock);\n\tLOCK_GIVE(hdw->big_lock);\n}\n\n\n \nunsigned int pvr2_hdw_get_ctrl_count(struct pvr2_hdw *hdw)\n{\n\treturn hdw->control_cnt;\n}\n\n\n \nstruct pvr2_ctrl *pvr2_hdw_get_ctrl_by_index(struct pvr2_hdw *hdw,\n\t\t\t\t\t     unsigned int idx)\n{\n\tif (idx >= hdw->control_cnt) return NULL;\n\treturn hdw->controls + idx;\n}\n\n\n \nstruct pvr2_ctrl *pvr2_hdw_get_ctrl_by_id(struct pvr2_hdw *hdw,\n\t\t\t\t\t  unsigned int ctl_id)\n{\n\tstruct pvr2_ctrl *cptr;\n\tunsigned int idx;\n\tint i;\n\n\t \n\tfor (idx = 0; idx < hdw->control_cnt; idx++) {\n\t\tcptr = hdw->controls + idx;\n\t\ti = cptr->info->internal_id;\n\t\tif (i && (i == ctl_id)) return cptr;\n\t}\n\treturn NULL;\n}\n\n\n \nstruct pvr2_ctrl *pvr2_hdw_get_ctrl_v4l(struct pvr2_hdw *hdw,unsigned int ctl_id)\n{\n\tstruct pvr2_ctrl *cptr;\n\tunsigned int idx;\n\tint i;\n\n\t \n\tfor (idx = 0; idx < hdw->control_cnt; idx++) {\n\t\tcptr = hdw->controls + idx;\n\t\ti = cptr->info->v4l_id;\n\t\tif (i && (i == ctl_id)) return cptr;\n\t}\n\treturn NULL;\n}\n\n\n \nstruct pvr2_ctrl *pvr2_hdw_get_ctrl_nextv4l(struct pvr2_hdw *hdw,\n\t\t\t\t\t    unsigned int ctl_id)\n{\n\tstruct pvr2_ctrl *cptr,*cp2;\n\tunsigned int idx;\n\tint i;\n\n\t \n\tcp2 = NULL;\n\tfor (idx = 0; idx < hdw->control_cnt; idx++) {\n\t\tcptr = hdw->controls + idx;\n\t\ti = cptr->info->v4l_id;\n\t\tif (!i) continue;\n\t\tif (i <= ctl_id) continue;\n\t\tif (cp2 && (cp2->info->v4l_id < i)) continue;\n\t\tcp2 = cptr;\n\t}\n\treturn cp2;\n\treturn NULL;\n}\n\n\nstatic const char *get_ctrl_typename(enum pvr2_ctl_type tp)\n{\n\tswitch (tp) {\n\tcase pvr2_ctl_int: return \"integer\";\n\tcase pvr2_ctl_enum: return \"enum\";\n\tcase pvr2_ctl_bool: return \"boolean\";\n\tcase pvr2_ctl_bitmask: return \"bitmask\";\n\t}\n\treturn \"\";\n}\n\n\nstatic void pvr2_subdev_set_control(struct pvr2_hdw *hdw, int id,\n\t\t\t\t    const char *name, int val)\n{\n\tstruct v4l2_control ctrl;\n\tstruct v4l2_subdev *sd;\n\n\tpvr2_trace(PVR2_TRACE_CHIPS, \"subdev v4l2 %s=%d\", name, val);\n\tmemset(&ctrl, 0, sizeof(ctrl));\n\tctrl.id = id;\n\tctrl.value = val;\n\n\tv4l2_device_for_each_subdev(sd, &hdw->v4l2_dev)\n\t\tv4l2_s_ctrl(NULL, sd->ctrl_handler, &ctrl);\n}\n\n#define PVR2_SUBDEV_SET_CONTROL(hdw, id, lab) \\\n\tif ((hdw)->lab##_dirty || (hdw)->force_dirty) {\t\t\\\n\t\tpvr2_subdev_set_control(hdw, id, #lab, (hdw)->lab##_val); \\\n\t}\n\nstatic v4l2_std_id pvr2_hdw_get_detected_std(struct pvr2_hdw *hdw)\n{\n\tv4l2_std_id std;\n\tstd = (v4l2_std_id)hdw->std_mask_avail;\n\tv4l2_device_call_all(&hdw->v4l2_dev, 0,\n\t\t\t     video, querystd, &std);\n\treturn std;\n}\n\n \nstatic void pvr2_subdev_update(struct pvr2_hdw *hdw)\n{\n\tstruct v4l2_subdev *sd;\n\tunsigned int id;\n\tpvr2_subdev_update_func fp;\n\n\tpvr2_trace(PVR2_TRACE_CHIPS, \"subdev update...\");\n\n\tif (hdw->tuner_updated || hdw->force_dirty) {\n\t\tstruct tuner_setup setup;\n\t\tpvr2_trace(PVR2_TRACE_CHIPS, \"subdev tuner set_type(%d)\",\n\t\t\t   hdw->tuner_type);\n\t\tif (((int)(hdw->tuner_type)) >= 0) {\n\t\t\tmemset(&setup, 0, sizeof(setup));\n\t\t\tsetup.addr = ADDR_UNSET;\n\t\t\tsetup.type = hdw->tuner_type;\n\t\t\tsetup.mode_mask = T_RADIO | T_ANALOG_TV;\n\t\t\tv4l2_device_call_all(&hdw->v4l2_dev, 0,\n\t\t\t\t\t     tuner, s_type_addr, &setup);\n\t\t}\n\t}\n\n\tif (hdw->input_dirty || hdw->std_dirty || hdw->force_dirty) {\n\t\tpvr2_trace(PVR2_TRACE_CHIPS, \"subdev v4l2 set_standard\");\n\t\tif (hdw->input_val == PVR2_CVAL_INPUT_RADIO) {\n\t\t\tv4l2_device_call_all(&hdw->v4l2_dev, 0,\n\t\t\t\t\t     tuner, s_radio);\n\t\t} else {\n\t\t\tv4l2_std_id vs;\n\t\t\tvs = hdw->std_mask_cur;\n\t\t\tv4l2_device_call_all(&hdw->v4l2_dev, 0,\n\t\t\t\t\t     video, s_std, vs);\n\t\t\tpvr2_hdw_cx25840_vbi_hack(hdw);\n\t\t}\n\t\thdw->tuner_signal_stale = !0;\n\t\thdw->cropcap_stale = !0;\n\t}\n\n\tPVR2_SUBDEV_SET_CONTROL(hdw, V4L2_CID_BRIGHTNESS, brightness);\n\tPVR2_SUBDEV_SET_CONTROL(hdw, V4L2_CID_CONTRAST, contrast);\n\tPVR2_SUBDEV_SET_CONTROL(hdw, V4L2_CID_SATURATION, saturation);\n\tPVR2_SUBDEV_SET_CONTROL(hdw, V4L2_CID_HUE, hue);\n\tPVR2_SUBDEV_SET_CONTROL(hdw, V4L2_CID_AUDIO_MUTE, mute);\n\tPVR2_SUBDEV_SET_CONTROL(hdw, V4L2_CID_AUDIO_VOLUME, volume);\n\tPVR2_SUBDEV_SET_CONTROL(hdw, V4L2_CID_AUDIO_BALANCE, balance);\n\tPVR2_SUBDEV_SET_CONTROL(hdw, V4L2_CID_AUDIO_BASS, bass);\n\tPVR2_SUBDEV_SET_CONTROL(hdw, V4L2_CID_AUDIO_TREBLE, treble);\n\n\tif (hdw->input_dirty || hdw->audiomode_dirty || hdw->force_dirty) {\n\t\tstruct v4l2_tuner vt;\n\t\tmemset(&vt, 0, sizeof(vt));\n\t\tvt.type = (hdw->input_val == PVR2_CVAL_INPUT_RADIO) ?\n\t\t\tV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\n\t\tvt.audmode = hdw->audiomode_val;\n\t\tv4l2_device_call_all(&hdw->v4l2_dev, 0, tuner, s_tuner, &vt);\n\t}\n\n\tif (hdw->freqDirty || hdw->force_dirty) {\n\t\tunsigned long fv;\n\t\tstruct v4l2_frequency freq;\n\t\tfv = pvr2_hdw_get_cur_freq(hdw);\n\t\tpvr2_trace(PVR2_TRACE_CHIPS, \"subdev v4l2 set_freq(%lu)\", fv);\n\t\tif (hdw->tuner_signal_stale) pvr2_hdw_status_poll(hdw);\n\t\tmemset(&freq, 0, sizeof(freq));\n\t\tif (hdw->tuner_signal_info.capability & V4L2_TUNER_CAP_LOW) {\n\t\t\t \n\t\t\tfreq.frequency = (fv * 2) / 125;\n\t\t} else {\n\t\t\tfreq.frequency = fv / 62500;\n\t\t}\n\t\t \n\t\tif (hdw->input_val == PVR2_CVAL_INPUT_RADIO) {\n\t\t\tfreq.type = V4L2_TUNER_RADIO;\n\t\t} else {\n\t\t\tfreq.type = V4L2_TUNER_ANALOG_TV;\n\t\t}\n\t\tfreq.tuner = 0;\n\t\tv4l2_device_call_all(&hdw->v4l2_dev, 0, tuner,\n\t\t\t\t     s_frequency, &freq);\n\t}\n\n\tif (hdw->res_hor_dirty || hdw->res_ver_dirty || hdw->force_dirty) {\n\t\tstruct v4l2_subdev_format format = {\n\t\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t};\n\n\t\tformat.format.width = hdw->res_hor_val;\n\t\tformat.format.height = hdw->res_ver_val;\n\t\tformat.format.code = MEDIA_BUS_FMT_FIXED;\n\t\tpvr2_trace(PVR2_TRACE_CHIPS, \"subdev v4l2 set_size(%dx%d)\",\n\t\t\t   format.format.width, format.format.height);\n\t\tv4l2_device_call_all(&hdw->v4l2_dev, 0, pad, set_fmt,\n\t\t\t\t     NULL, &format);\n\t}\n\n\tif (hdw->srate_dirty || hdw->force_dirty) {\n\t\tu32 val;\n\t\tpvr2_trace(PVR2_TRACE_CHIPS, \"subdev v4l2 set_audio %d\",\n\t\t\t   hdw->srate_val);\n\t\tswitch (hdw->srate_val) {\n\t\tdefault:\n\t\tcase V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000:\n\t\t\tval = 48000;\n\t\t\tbreak;\n\t\tcase V4L2_MPEG_AUDIO_SAMPLING_FREQ_44100:\n\t\t\tval = 44100;\n\t\t\tbreak;\n\t\tcase V4L2_MPEG_AUDIO_SAMPLING_FREQ_32000:\n\t\t\tval = 32000;\n\t\t\tbreak;\n\t\t}\n\t\tv4l2_device_call_all(&hdw->v4l2_dev, 0,\n\t\t\t\t     audio, s_clock_freq, val);\n\t}\n\n\t \n\n\tv4l2_device_for_each_subdev(sd, &hdw->v4l2_dev) {\n\t\tid = sd->grp_id;\n\t\tif (id >= ARRAY_SIZE(pvr2_module_update_functions)) continue;\n\t\tfp = pvr2_module_update_functions[id];\n\t\tif (!fp) continue;\n\t\t(*fp)(hdw, sd);\n\t}\n\n\tif (hdw->tuner_signal_stale || hdw->cropcap_stale) {\n\t\tpvr2_hdw_status_poll(hdw);\n\t}\n}\n\n\n \nstatic int pvr2_hdw_commit_setup(struct pvr2_hdw *hdw)\n{\n\tunsigned int idx;\n\tstruct pvr2_ctrl *cptr;\n\tint value;\n\tint commit_flag = hdw->force_dirty;\n\tchar buf[100];\n\tunsigned int bcnt,ccnt;\n\n\tfor (idx = 0; idx < hdw->control_cnt; idx++) {\n\t\tcptr = hdw->controls + idx;\n\t\tif (!cptr->info->is_dirty) continue;\n\t\tif (!cptr->info->is_dirty(cptr)) continue;\n\t\tcommit_flag = !0;\n\n\t\tif (!(pvrusb2_debug & PVR2_TRACE_CTL)) continue;\n\t\tbcnt = scnprintf(buf,sizeof(buf),\"\\\"%s\\\" <-- \",\n\t\t\t\t cptr->info->name);\n\t\tvalue = 0;\n\t\tcptr->info->get_value(cptr,&value);\n\t\tpvr2_ctrl_value_to_sym_internal(cptr,~0,value,\n\t\t\t\t\t\tbuf+bcnt,\n\t\t\t\t\t\tsizeof(buf)-bcnt,&ccnt);\n\t\tbcnt += ccnt;\n\t\tbcnt += scnprintf(buf+bcnt,sizeof(buf)-bcnt,\" <%s>\",\n\t\t\t\t  get_ctrl_typename(cptr->info->type));\n\t\tpvr2_trace(PVR2_TRACE_CTL,\n\t\t\t   \"/*--TRACE_COMMIT--*/ %.*s\",\n\t\t\t   bcnt,buf);\n\t}\n\n\tif (!commit_flag) {\n\t\t \n\t\treturn 0;\n\t}\n\n\thdw->state_pipeline_config = 0;\n\ttrace_stbit(\"state_pipeline_config\",hdw->state_pipeline_config);\n\tpvr2_hdw_state_sched(hdw);\n\n\treturn !0;\n}\n\n\n \nstatic int pvr2_hdw_commit_execute(struct pvr2_hdw *hdw)\n{\n\tunsigned int idx;\n\tstruct pvr2_ctrl *cptr;\n\tint disruptive_change;\n\n\tif (hdw->input_dirty && hdw->state_pathway_ok &&\n\t    (((hdw->input_val == PVR2_CVAL_INPUT_DTV) ?\n\t      PVR2_PATHWAY_DIGITAL : PVR2_PATHWAY_ANALOG) !=\n\t     hdw->pathway_state)) {\n\t\t \n\t\thdw->state_pathway_ok = 0;\n\t\ttrace_stbit(\"state_pathway_ok\", hdw->state_pathway_ok);\n\t}\n\tif (!hdw->state_pathway_ok) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tif (hdw->std_dirty) {\n\t\tint nvres;\n\t\tint gop_size;\n\t\tif (hdw->std_mask_cur & V4L2_STD_525_60) {\n\t\t\tnvres = 480;\n\t\t\tgop_size = 15;\n\t\t} else {\n\t\t\tnvres = 576;\n\t\t\tgop_size = 12;\n\t\t}\n\t\t \n\t\tif (nvres != hdw->res_ver_val) {\n\t\t\thdw->res_ver_val = nvres;\n\t\t\thdw->res_ver_dirty = !0;\n\t\t}\n\t\t \n\t\tif (gop_size != hdw->enc_ctl_state.video_gop_size) {\n\t\t\tstruct v4l2_ext_controls cs;\n\t\t\tstruct v4l2_ext_control c1;\n\t\t\tmemset(&cs, 0, sizeof(cs));\n\t\t\tmemset(&c1, 0, sizeof(c1));\n\t\t\tcs.controls = &c1;\n\t\t\tcs.count = 1;\n\t\t\tc1.id = V4L2_CID_MPEG_VIDEO_GOP_SIZE;\n\t\t\tc1.value = gop_size;\n\t\t\tcx2341x_ext_ctrls(&hdw->enc_ctl_state, 0, &cs,\n\t\t\t\t\t  VIDIOC_S_EXT_CTRLS);\n\t\t}\n\t}\n\n\t \n\tif (hdw->res_hor_dirty && hdw->cropw_val < hdw->res_hor_val) {\n\t\thdw->cropw_val = hdw->res_hor_val;\n\t\thdw->cropw_dirty = !0;\n\t} else if (hdw->cropw_dirty) {\n\t\thdw->res_hor_dirty = !0;            \n\t\thdw->res_hor_val = min(720, hdw->cropw_val);\n\t}\n\tif (hdw->res_ver_dirty && hdw->croph_val < hdw->res_ver_val) {\n\t\thdw->croph_val = hdw->res_ver_val;\n\t\thdw->croph_dirty = !0;\n\t} else if (hdw->croph_dirty) {\n\t\tint nvres = hdw->std_mask_cur & V4L2_STD_525_60 ? 480 : 576;\n\t\thdw->res_ver_dirty = !0;\n\t\thdw->res_ver_val = min(nvres, hdw->croph_val);\n\t}\n\n\t \n\tdisruptive_change =\n\t\t(hdw->std_dirty ||\n\t\t hdw->enc_unsafe_stale ||\n\t\t hdw->srate_dirty ||\n\t\t hdw->res_ver_dirty ||\n\t\t hdw->res_hor_dirty ||\n\t\t hdw->cropw_dirty ||\n\t\t hdw->croph_dirty ||\n\t\t hdw->input_dirty ||\n\t\t (hdw->active_stream_type != hdw->desired_stream_type));\n\tif (disruptive_change && !hdw->state_pipeline_idle) {\n\t\t \n\t\thdw->state_pipeline_pause = !0;\n\t\treturn 0;\n\t}\n\n\tif (hdw->srate_dirty) {\n\t\t \n\t\tstruct v4l2_ext_controls cs;\n\t\tstruct v4l2_ext_control c1;\n\t\tmemset(&cs,0,sizeof(cs));\n\t\tmemset(&c1,0,sizeof(c1));\n\t\tcs.controls = &c1;\n\t\tcs.count = 1;\n\t\tc1.id = V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ;\n\t\tc1.value = hdw->srate_val;\n\t\tcx2341x_ext_ctrls(&hdw->enc_ctl_state, 0, &cs,VIDIOC_S_EXT_CTRLS);\n\t}\n\n\tif (hdw->active_stream_type != hdw->desired_stream_type) {\n\t\t \n\t\thdw->active_stream_type = hdw->desired_stream_type;\n\t}\n\n\tif (hdw->hdw_desc->signal_routing_scheme ==\n\t    PVR2_ROUTING_SCHEME_GOTVIEW) {\n\t\tu32 b;\n\t\t \n\t\tpvr2_hdw_gpio_get_out(hdw,&b);\n\t\tif (hdw->input_val == PVR2_CVAL_INPUT_RADIO) {\n\t\t\t \n\t\t\tpvr2_hdw_gpio_chg_out(hdw,(1 << 11),~0);\n\t\t} else {\n\t\t\t \n\t\t\tpvr2_hdw_gpio_chg_out(hdw,(1 << 11),0);\n\t\t}\n\t}\n\n\t \n\tpvr2_subdev_update(hdw);\n\n\thdw->tuner_updated = 0;\n\thdw->force_dirty = 0;\n\tfor (idx = 0; idx < hdw->control_cnt; idx++) {\n\t\tcptr = hdw->controls + idx;\n\t\tif (!cptr->info->clear_dirty) continue;\n\t\tcptr->info->clear_dirty(cptr);\n\t}\n\n\tif ((hdw->pathway_state == PVR2_PATHWAY_ANALOG) &&\n\t    hdw->state_encoder_run) {\n\t\t \n\t\tif (pvr2_encoder_adjust(hdw) < 0) return !0;\n\t}\n\n\thdw->state_pipeline_config = !0;\n\t \n\ttrace_stbit(\"state_pipeline_config\",hdw->state_pipeline_config);\n\treturn !0;\n}\n\n\nint pvr2_hdw_commit_ctl(struct pvr2_hdw *hdw)\n{\n\tint fl;\n\tLOCK_TAKE(hdw->big_lock);\n\tfl = pvr2_hdw_commit_setup(hdw);\n\tLOCK_GIVE(hdw->big_lock);\n\tif (!fl) return 0;\n\treturn pvr2_hdw_wait(hdw,0);\n}\n\n\nstatic void pvr2_hdw_worker_poll(struct work_struct *work)\n{\n\tint fl = 0;\n\tstruct pvr2_hdw *hdw = container_of(work,struct pvr2_hdw,workpoll);\n\tLOCK_TAKE(hdw->big_lock); do {\n\t\tfl = pvr2_hdw_state_eval(hdw);\n\t} while (0); LOCK_GIVE(hdw->big_lock);\n\tif (fl && hdw->state_func) {\n\t\thdw->state_func(hdw->state_data);\n\t}\n}\n\n\nstatic int pvr2_hdw_wait(struct pvr2_hdw *hdw,int state)\n{\n\treturn wait_event_interruptible(\n\t\thdw->state_wait_data,\n\t\t(hdw->state_stale == 0) &&\n\t\t(!state || (hdw->master_state != state)));\n}\n\n\n \nconst char *pvr2_hdw_get_driver_name(struct pvr2_hdw *hdw)\n{\n\treturn hdw->name;\n}\n\n\nconst char *pvr2_hdw_get_desc(struct pvr2_hdw *hdw)\n{\n\treturn hdw->hdw_desc->description;\n}\n\n\nconst char *pvr2_hdw_get_type(struct pvr2_hdw *hdw)\n{\n\treturn hdw->hdw_desc->shortname;\n}\n\n\nint pvr2_hdw_is_hsm(struct pvr2_hdw *hdw)\n{\n\tint result;\n\tLOCK_TAKE(hdw->ctl_lock); do {\n\t\thdw->cmd_buffer[0] = FX2CMD_GET_USB_SPEED;\n\t\tresult = pvr2_send_request(hdw,\n\t\t\t\t\t   hdw->cmd_buffer,1,\n\t\t\t\t\t   hdw->cmd_buffer,1);\n\t\tif (result < 0) break;\n\t\tresult = (hdw->cmd_buffer[0] != 0);\n\t} while(0); LOCK_GIVE(hdw->ctl_lock);\n\treturn result;\n}\n\n\n \nvoid pvr2_hdw_execute_tuner_poll(struct pvr2_hdw *hdw)\n{\n\tLOCK_TAKE(hdw->big_lock); do {\n\t\tpvr2_hdw_status_poll(hdw);\n\t} while (0); LOCK_GIVE(hdw->big_lock);\n}\n\n\nstatic int pvr2_hdw_check_cropcap(struct pvr2_hdw *hdw)\n{\n\tif (!hdw->cropcap_stale) {\n\t\treturn 0;\n\t}\n\tpvr2_hdw_status_poll(hdw);\n\tif (hdw->cropcap_stale) {\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n\n \nint pvr2_hdw_get_cropcap(struct pvr2_hdw *hdw, struct v4l2_cropcap *pp)\n{\n\tint stat = 0;\n\tLOCK_TAKE(hdw->big_lock);\n\tstat = pvr2_hdw_check_cropcap(hdw);\n\tif (!stat) {\n\t\tmemcpy(pp, &hdw->cropcap_info, sizeof(hdw->cropcap_info));\n\t}\n\tLOCK_GIVE(hdw->big_lock);\n\treturn stat;\n}\n\n\n \nint pvr2_hdw_get_tuner_status(struct pvr2_hdw *hdw,struct v4l2_tuner *vtp)\n{\n\tLOCK_TAKE(hdw->big_lock);\n\tdo {\n\t\tif (hdw->tuner_signal_stale) {\n\t\t\tpvr2_hdw_status_poll(hdw);\n\t\t}\n\t\tmemcpy(vtp,&hdw->tuner_signal_info,sizeof(struct v4l2_tuner));\n\t} while (0);\n\tLOCK_GIVE(hdw->big_lock);\n\treturn 0;\n}\n\n\n \nstruct pvr2_stream *pvr2_hdw_get_video_stream(struct pvr2_hdw *hp)\n{\n\treturn hp->vid_stream;\n}\n\n\nvoid pvr2_hdw_trigger_module_log(struct pvr2_hdw *hdw)\n{\n\tint nr = pvr2_hdw_get_unit_number(hdw);\n\tLOCK_TAKE(hdw->big_lock);\n\tdo {\n\t\tpr_info(\"pvrusb2: =================  START STATUS CARD #%d  =================\\n\", nr);\n\t\tv4l2_device_call_all(&hdw->v4l2_dev, 0, core, log_status);\n\t\tpvr2_trace(PVR2_TRACE_INFO,\"cx2341x config:\");\n\t\tcx2341x_log_status(&hdw->enc_ctl_state, \"pvrusb2\");\n\t\tpvr2_hdw_state_log_state(hdw);\n\t\tpr_info(\"pvrusb2: ==================  END STATUS CARD #%d  ==================\\n\", nr);\n\t} while (0);\n\tLOCK_GIVE(hdw->big_lock);\n}\n\n\n \n#define EEPROM_SIZE 8192\n#define trace_eeprom(...) pvr2_trace(PVR2_TRACE_EEPROM,__VA_ARGS__)\nstatic u8 *pvr2_full_eeprom_fetch(struct pvr2_hdw *hdw)\n{\n\tstruct i2c_msg msg[2];\n\tu8 *eeprom;\n\tu8 iadd[2];\n\tu8 addr;\n\tu16 eepromSize;\n\tunsigned int offs;\n\tint ret;\n\tint mode16 = 0;\n\tunsigned pcnt,tcnt;\n\teeprom = kzalloc(EEPROM_SIZE, GFP_KERNEL);\n\tif (!eeprom) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"Failed to allocate memory required to read eeprom\");\n\t\treturn NULL;\n\t}\n\n\ttrace_eeprom(\"Value for eeprom addr from controller was 0x%x\",\n\t\t     hdw->eeprom_addr);\n\taddr = hdw->eeprom_addr;\n\t \n\tif (addr & 0x80) addr >>= 1;\n\n\t \n\tmode16 = (addr & 1);\n\teepromSize = (mode16 ? EEPROM_SIZE : 256);\n\ttrace_eeprom(\"Examining %d byte eeprom at location 0x%x using %d bit addressing\",\n\t\t     eepromSize, addr,\n\t\t     mode16 ? 16 : 8);\n\n\tmsg[0].addr = addr;\n\tmsg[0].flags = 0;\n\tmsg[0].len = mode16 ? 2 : 1;\n\tmsg[0].buf = iadd;\n\tmsg[1].addr = addr;\n\tmsg[1].flags = I2C_M_RD;\n\n\t \n\tfor (tcnt = 0; tcnt < EEPROM_SIZE; tcnt += pcnt) {\n\t\tpcnt = 16;\n\t\tif (pcnt + tcnt > EEPROM_SIZE) pcnt = EEPROM_SIZE-tcnt;\n\t\toffs = tcnt + (eepromSize - EEPROM_SIZE);\n\t\tif (mode16) {\n\t\t\tiadd[0] = offs >> 8;\n\t\t\tiadd[1] = offs;\n\t\t} else {\n\t\t\tiadd[0] = offs;\n\t\t}\n\t\tmsg[1].len = pcnt;\n\t\tmsg[1].buf = eeprom+tcnt;\n\t\tif ((ret = i2c_transfer(&hdw->i2c_adap,\n\t\t\t\t\tmsg,ARRAY_SIZE(msg))) != 2) {\n\t\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t\t   \"eeprom fetch set offs err=%d\",ret);\n\t\t\tkfree(eeprom);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn eeprom;\n}\n\n\nvoid pvr2_hdw_cpufw_set_enabled(struct pvr2_hdw *hdw,\n\t\t\t\tint mode,\n\t\t\t\tint enable_flag)\n{\n\tint ret;\n\tu16 address;\n\tunsigned int pipe;\n\tLOCK_TAKE(hdw->big_lock);\n\tdo {\n\t\tif ((hdw->fw_buffer == NULL) == !enable_flag) break;\n\n\t\tif (!enable_flag) {\n\t\t\tpvr2_trace(PVR2_TRACE_FIRMWARE,\n\t\t\t\t   \"Cleaning up after CPU firmware fetch\");\n\t\t\tkfree(hdw->fw_buffer);\n\t\t\thdw->fw_buffer = NULL;\n\t\t\thdw->fw_size = 0;\n\t\t\tif (hdw->fw_cpu_flag) {\n\t\t\t\t \n\t\t\t\tpvr2_hdw_cpureset_assert(hdw,0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\thdw->fw_cpu_flag = (mode != 2);\n\t\tif (hdw->fw_cpu_flag) {\n\t\t\thdw->fw_size = (mode == 1) ? 0x4000 : 0x2000;\n\t\t\tpvr2_trace(PVR2_TRACE_FIRMWARE,\n\t\t\t\t   \"Preparing to suck out CPU firmware (size=%u)\",\n\t\t\t\t   hdw->fw_size);\n\t\t\thdw->fw_buffer = kzalloc(hdw->fw_size,GFP_KERNEL);\n\t\t\tif (!hdw->fw_buffer) {\n\t\t\t\thdw->fw_size = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tpvr2_hdw_cpureset_assert(hdw,1);\n\n\t\t\t \n\n\t\t\tpvr2_trace(PVR2_TRACE_FIRMWARE,\n\t\t\t\t   \"Grabbing CPU firmware\");\n\t\t\tpipe = usb_rcvctrlpipe(hdw->usb_dev, 0);\n\t\t\tfor(address = 0; address < hdw->fw_size;\n\t\t\t    address += 0x800) {\n\t\t\t\tret = usb_control_msg(hdw->usb_dev,pipe,\n\t\t\t\t\t\t      0xa0,0xc0,\n\t\t\t\t\t\t      address,0,\n\t\t\t\t\t\t      hdw->fw_buffer+address,\n\t\t\t\t\t\t      0x800,1000);\n\t\t\t\tif (ret < 0) break;\n\t\t\t}\n\n\t\t\tpvr2_trace(PVR2_TRACE_FIRMWARE,\n\t\t\t\t   \"Done grabbing CPU firmware\");\n\t\t} else {\n\t\t\tpvr2_trace(PVR2_TRACE_FIRMWARE,\n\t\t\t\t   \"Sucking down EEPROM contents\");\n\t\t\thdw->fw_buffer = pvr2_full_eeprom_fetch(hdw);\n\t\t\tif (!hdw->fw_buffer) {\n\t\t\t\tpvr2_trace(PVR2_TRACE_FIRMWARE,\n\t\t\t\t\t   \"EEPROM content suck failed.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thdw->fw_size = EEPROM_SIZE;\n\t\t\tpvr2_trace(PVR2_TRACE_FIRMWARE,\n\t\t\t\t   \"Done sucking down EEPROM contents\");\n\t\t}\n\t} while (0);\n\tLOCK_GIVE(hdw->big_lock);\n}\n\n\n \nint pvr2_hdw_cpufw_get_enabled(struct pvr2_hdw *hdw)\n{\n\treturn hdw->fw_buffer != NULL;\n}\n\n\nint pvr2_hdw_cpufw_get(struct pvr2_hdw *hdw,unsigned int offs,\n\t\t       char *buf,unsigned int cnt)\n{\n\tint ret = -EINVAL;\n\tLOCK_TAKE(hdw->big_lock);\n\tdo {\n\t\tif (!buf) break;\n\t\tif (!cnt) break;\n\n\t\tif (!hdw->fw_buffer) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (offs >= hdw->fw_size) {\n\t\t\tpvr2_trace(PVR2_TRACE_FIRMWARE,\n\t\t\t\t   \"Read firmware data offs=%d EOF\",\n\t\t\t\t   offs);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (offs + cnt > hdw->fw_size) cnt = hdw->fw_size - offs;\n\n\t\tmemcpy(buf,hdw->fw_buffer+offs,cnt);\n\n\t\tpvr2_trace(PVR2_TRACE_FIRMWARE,\n\t\t\t   \"Read firmware data offs=%d cnt=%d\",\n\t\t\t   offs,cnt);\n\t\tret = cnt;\n\t} while (0);\n\tLOCK_GIVE(hdw->big_lock);\n\n\treturn ret;\n}\n\n\nint pvr2_hdw_v4l_get_minor_number(struct pvr2_hdw *hdw,\n\t\t\t\t  enum pvr2_v4l_type index)\n{\n\tswitch (index) {\n\tcase pvr2_v4l_type_video: return hdw->v4l_minor_number_video;\n\tcase pvr2_v4l_type_vbi: return hdw->v4l_minor_number_vbi;\n\tcase pvr2_v4l_type_radio: return hdw->v4l_minor_number_radio;\n\tdefault: return -1;\n\t}\n}\n\n\n \nvoid pvr2_hdw_v4l_store_minor_number(struct pvr2_hdw *hdw,\n\t\t\t\t     enum pvr2_v4l_type index,int v)\n{\n\tswitch (index) {\n\tcase pvr2_v4l_type_video: hdw->v4l_minor_number_video = v;break;\n\tcase pvr2_v4l_type_vbi: hdw->v4l_minor_number_vbi = v;break;\n\tcase pvr2_v4l_type_radio: hdw->v4l_minor_number_radio = v;break;\n\tdefault: break;\n\t}\n}\n\n\nstatic void pvr2_ctl_write_complete(struct urb *urb)\n{\n\tstruct pvr2_hdw *hdw = urb->context;\n\thdw->ctl_write_pend_flag = 0;\n\tif (hdw->ctl_read_pend_flag) return;\n\tcomplete(&hdw->ctl_done);\n}\n\n\nstatic void pvr2_ctl_read_complete(struct urb *urb)\n{\n\tstruct pvr2_hdw *hdw = urb->context;\n\thdw->ctl_read_pend_flag = 0;\n\tif (hdw->ctl_write_pend_flag) return;\n\tcomplete(&hdw->ctl_done);\n}\n\nstruct hdw_timer {\n\tstruct timer_list timer;\n\tstruct pvr2_hdw *hdw;\n};\n\nstatic void pvr2_ctl_timeout(struct timer_list *t)\n{\n\tstruct hdw_timer *timer = from_timer(timer, t, timer);\n\tstruct pvr2_hdw *hdw = timer->hdw;\n\n\tif (hdw->ctl_write_pend_flag || hdw->ctl_read_pend_flag) {\n\t\thdw->ctl_timeout_flag = !0;\n\t\tif (hdw->ctl_write_pend_flag)\n\t\t\tusb_unlink_urb(hdw->ctl_write_urb);\n\t\tif (hdw->ctl_read_pend_flag)\n\t\t\tusb_unlink_urb(hdw->ctl_read_urb);\n\t}\n}\n\n\n \nstatic int pvr2_send_request_ex(struct pvr2_hdw *hdw,\n\t\t\t\tunsigned int timeout,int probe_fl,\n\t\t\t\tvoid *write_data,unsigned int write_len,\n\t\t\t\tvoid *read_data,unsigned int read_len)\n{\n\tunsigned int idx;\n\tint status = 0;\n\tstruct hdw_timer timer = {\n\t\t.hdw = hdw,\n\t};\n\n\tif (!hdw->ctl_lock_held) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"Attempted to execute control transfer without lock!!\");\n\t\treturn -EDEADLK;\n\t}\n\tif (!hdw->flag_ok && !probe_fl) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"Attempted to execute control transfer when device not ok\");\n\t\treturn -EIO;\n\t}\n\tif (!(hdw->ctl_read_urb && hdw->ctl_write_urb)) {\n\t\tif (!probe_fl) {\n\t\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t\t   \"Attempted to execute control transfer when USB is disconnected\");\n\t\t}\n\t\treturn -ENOTTY;\n\t}\n\n\t \n\tif (!write_data) write_len = 0;\n\tif (!read_data) read_len = 0;\n\tif (write_len > PVR2_CTL_BUFFSIZE) {\n\t\tpvr2_trace(\n\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\"Attempted to execute %d byte control-write transfer (limit=%d)\",\n\t\t\twrite_len,PVR2_CTL_BUFFSIZE);\n\t\treturn -EINVAL;\n\t}\n\tif (read_len > PVR2_CTL_BUFFSIZE) {\n\t\tpvr2_trace(\n\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\"Attempted to execute %d byte control-read transfer (limit=%d)\",\n\t\t\twrite_len,PVR2_CTL_BUFFSIZE);\n\t\treturn -EINVAL;\n\t}\n\tif ((!write_len) && (!read_len)) {\n\t\tpvr2_trace(\n\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\"Attempted to execute null control transfer?\");\n\t\treturn -EINVAL;\n\t}\n\n\n\thdw->cmd_debug_state = 1;\n\tif (write_len && write_data)\n\t\thdw->cmd_debug_code = ((unsigned char *)write_data)[0];\n\telse\n\t\thdw->cmd_debug_code = 0;\n\thdw->cmd_debug_write_len = write_len;\n\thdw->cmd_debug_read_len = read_len;\n\n\t \n\tinit_completion(&hdw->ctl_done);\n\thdw->ctl_timeout_flag = 0;\n\thdw->ctl_write_pend_flag = 0;\n\thdw->ctl_read_pend_flag = 0;\n\ttimer_setup_on_stack(&timer.timer, pvr2_ctl_timeout, 0);\n\ttimer.timer.expires = jiffies + timeout;\n\n\tif (write_len && write_data) {\n\t\thdw->cmd_debug_state = 2;\n\t\t \n\t\tfor (idx = 0; idx < write_len; idx++) {\n\t\t\thdw->ctl_write_buffer[idx] =\n\t\t\t\t((unsigned char *)write_data)[idx];\n\t\t}\n\t\t \n\t\tusb_fill_bulk_urb(hdw->ctl_write_urb,\n\t\t\t\t  hdw->usb_dev,\n\t\t\t\t  usb_sndbulkpipe(hdw->usb_dev,\n\t\t\t\t\t\t  PVR2_CTL_WRITE_ENDPOINT),\n\t\t\t\t  hdw->ctl_write_buffer,\n\t\t\t\t  write_len,\n\t\t\t\t  pvr2_ctl_write_complete,\n\t\t\t\t  hdw);\n\t\thdw->ctl_write_urb->actual_length = 0;\n\t\thdw->ctl_write_pend_flag = !0;\n\t\tif (usb_urb_ep_type_check(hdw->ctl_write_urb)) {\n\t\t\tpvr2_trace(\n\t\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\"Invalid write control endpoint\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstatus = usb_submit_urb(hdw->ctl_write_urb,GFP_KERNEL);\n\t\tif (status < 0) {\n\t\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t\t   \"Failed to submit write-control URB status=%d\",\nstatus);\n\t\t\thdw->ctl_write_pend_flag = 0;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (read_len) {\n\t\thdw->cmd_debug_state = 3;\n\t\tmemset(hdw->ctl_read_buffer,0x43,read_len);\n\t\t \n\t\tusb_fill_bulk_urb(hdw->ctl_read_urb,\n\t\t\t\t  hdw->usb_dev,\n\t\t\t\t  usb_rcvbulkpipe(hdw->usb_dev,\n\t\t\t\t\t\t  PVR2_CTL_READ_ENDPOINT),\n\t\t\t\t  hdw->ctl_read_buffer,\n\t\t\t\t  read_len,\n\t\t\t\t  pvr2_ctl_read_complete,\n\t\t\t\t  hdw);\n\t\thdw->ctl_read_urb->actual_length = 0;\n\t\thdw->ctl_read_pend_flag = !0;\n\t\tif (usb_urb_ep_type_check(hdw->ctl_read_urb)) {\n\t\t\tpvr2_trace(\n\t\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\"Invalid read control endpoint\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstatus = usb_submit_urb(hdw->ctl_read_urb,GFP_KERNEL);\n\t\tif (status < 0) {\n\t\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t\t   \"Failed to submit read-control URB status=%d\",\nstatus);\n\t\t\thdw->ctl_read_pend_flag = 0;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tadd_timer(&timer.timer);\n\n\t \n\thdw->cmd_debug_state = 4;\n\twhile (hdw->ctl_write_pend_flag || hdw->ctl_read_pend_flag) {\n\t\twait_for_completion(&hdw->ctl_done);\n\t}\n\thdw->cmd_debug_state = 5;\n\n\t \n\tdel_timer_sync(&timer.timer);\n\n\thdw->cmd_debug_state = 6;\n\tstatus = 0;\n\n\tif (hdw->ctl_timeout_flag) {\n\t\tstatus = -ETIMEDOUT;\n\t\tif (!probe_fl) {\n\t\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t\t   \"Timed out control-write\");\n\t\t}\n\t\tgoto done;\n\t}\n\n\tif (write_len) {\n\t\t \n\t\tif ((hdw->ctl_write_urb->status != 0) &&\n\t\t    (hdw->ctl_write_urb->status != -ENOENT) &&\n\t\t    (hdw->ctl_write_urb->status != -ESHUTDOWN) &&\n\t\t    (hdw->ctl_write_urb->status != -ECONNRESET)) {\n\t\t\t \n\t\t\tstatus = hdw->ctl_write_urb->status;\n\t\t\tif (!probe_fl) {\n\t\t\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\t   \"control-write URB failure, status=%d\",\n\t\t\t\t\t   status);\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\t\tif (hdw->ctl_write_urb->actual_length < write_len) {\n\t\t\t \n\t\t\tstatus = -EIO;\n\t\t\tif (!probe_fl) {\n\t\t\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\t   \"control-write URB short, expected=%d got=%d\",\n\t\t\t\t\t   write_len,\n\t\t\t\t\t   hdw->ctl_write_urb->actual_length);\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (read_len && read_data) {\n\t\t \n\t\tif ((hdw->ctl_read_urb->status != 0) &&\n\t\t    (hdw->ctl_read_urb->status != -ENOENT) &&\n\t\t    (hdw->ctl_read_urb->status != -ESHUTDOWN) &&\n\t\t    (hdw->ctl_read_urb->status != -ECONNRESET)) {\n\t\t\t \n\t\t\tstatus = hdw->ctl_read_urb->status;\n\t\t\tif (!probe_fl) {\n\t\t\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\t   \"control-read URB failure, status=%d\",\n\t\t\t\t\t   status);\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\t\tif (hdw->ctl_read_urb->actual_length < read_len) {\n\t\t\t \n\t\t\tstatus = -EIO;\n\t\t\tif (!probe_fl) {\n\t\t\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\t   \"control-read URB short, expected=%d got=%d\",\n\t\t\t\t\t   read_len,\n\t\t\t\t\t   hdw->ctl_read_urb->actual_length);\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\t\t \n\t\tfor (idx = 0; idx < read_len; idx++) {\n\t\t\t((unsigned char *)read_data)[idx] =\n\t\t\t\thdw->ctl_read_buffer[idx];\n\t\t}\n\t}\n\n done:\n\n\thdw->cmd_debug_state = 0;\n\tif ((status < 0) && (!probe_fl)) {\n\t\tpvr2_hdw_render_useless(hdw);\n\t}\n\tdestroy_timer_on_stack(&timer.timer);\n\n\treturn status;\n}\n\n\nint pvr2_send_request(struct pvr2_hdw *hdw,\n\t\t      void *write_data,unsigned int write_len,\n\t\t      void *read_data,unsigned int read_len)\n{\n\treturn pvr2_send_request_ex(hdw,HZ*4,0,\n\t\t\t\t    write_data,write_len,\n\t\t\t\t    read_data,read_len);\n}\n\n\nstatic int pvr2_issue_simple_cmd(struct pvr2_hdw *hdw,u32 cmdcode)\n{\n\tint ret;\n\tunsigned int cnt = 1;\n\tunsigned int args = 0;\n\tLOCK_TAKE(hdw->ctl_lock);\n\thdw->cmd_buffer[0] = cmdcode & 0xffu;\n\targs = (cmdcode >> 8) & 0xffu;\n\targs = (args > 2) ? 2 : args;\n\tif (args) {\n\t\tcnt += args;\n\t\thdw->cmd_buffer[1] = (cmdcode >> 16) & 0xffu;\n\t\tif (args > 1) {\n\t\t\thdw->cmd_buffer[2] = (cmdcode >> 24) & 0xffu;\n\t\t}\n\t}\n\tif (pvrusb2_debug & PVR2_TRACE_INIT) {\n\t\tunsigned int idx;\n\t\tunsigned int ccnt,bcnt;\n\t\tchar tbuf[50];\n\t\tcmdcode &= 0xffu;\n\t\tbcnt = 0;\n\t\tccnt = scnprintf(tbuf+bcnt,\n\t\t\t\t sizeof(tbuf)-bcnt,\n\t\t\t\t \"Sending FX2 command 0x%x\",cmdcode);\n\t\tbcnt += ccnt;\n\t\tfor (idx = 0; idx < ARRAY_SIZE(pvr2_fx2cmd_desc); idx++) {\n\t\t\tif (pvr2_fx2cmd_desc[idx].id == cmdcode) {\n\t\t\t\tccnt = scnprintf(tbuf+bcnt,\n\t\t\t\t\t\t sizeof(tbuf)-bcnt,\n\t\t\t\t\t\t \" \\\"%s\\\"\",\n\t\t\t\t\t\t pvr2_fx2cmd_desc[idx].desc);\n\t\t\t\tbcnt += ccnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (args) {\n\t\t\tccnt = scnprintf(tbuf+bcnt,\n\t\t\t\t\t sizeof(tbuf)-bcnt,\n\t\t\t\t\t \" (%u\",hdw->cmd_buffer[1]);\n\t\t\tbcnt += ccnt;\n\t\t\tif (args > 1) {\n\t\t\t\tccnt = scnprintf(tbuf+bcnt,\n\t\t\t\t\t\t sizeof(tbuf)-bcnt,\n\t\t\t\t\t\t \",%u\",hdw->cmd_buffer[2]);\n\t\t\t\tbcnt += ccnt;\n\t\t\t}\n\t\t\tccnt = scnprintf(tbuf+bcnt,\n\t\t\t\t\t sizeof(tbuf)-bcnt,\n\t\t\t\t\t \")\");\n\t\t\tbcnt += ccnt;\n\t\t}\n\t\tpvr2_trace(PVR2_TRACE_INIT,\"%.*s\",bcnt,tbuf);\n\t}\n\tret = pvr2_send_request(hdw,hdw->cmd_buffer,cnt,NULL,0);\n\tLOCK_GIVE(hdw->ctl_lock);\n\treturn ret;\n}\n\n\nint pvr2_write_register(struct pvr2_hdw *hdw, u16 reg, u32 data)\n{\n\tint ret;\n\n\tLOCK_TAKE(hdw->ctl_lock);\n\n\thdw->cmd_buffer[0] = FX2CMD_REG_WRITE;   \n\tPVR2_DECOMPOSE_LE(hdw->cmd_buffer,1,data);\n\thdw->cmd_buffer[5] = 0;\n\thdw->cmd_buffer[6] = (reg >> 8) & 0xff;\n\thdw->cmd_buffer[7] = reg & 0xff;\n\n\n\tret = pvr2_send_request(hdw, hdw->cmd_buffer, 8, hdw->cmd_buffer, 0);\n\n\tLOCK_GIVE(hdw->ctl_lock);\n\n\treturn ret;\n}\n\n\nstatic int pvr2_read_register(struct pvr2_hdw *hdw, u16 reg, u32 *data)\n{\n\tint ret = 0;\n\n\tLOCK_TAKE(hdw->ctl_lock);\n\n\thdw->cmd_buffer[0] = FX2CMD_REG_READ;   \n\thdw->cmd_buffer[1] = 0;\n\thdw->cmd_buffer[2] = 0;\n\thdw->cmd_buffer[3] = 0;\n\thdw->cmd_buffer[4] = 0;\n\thdw->cmd_buffer[5] = 0;\n\thdw->cmd_buffer[6] = (reg >> 8) & 0xff;\n\thdw->cmd_buffer[7] = reg & 0xff;\n\n\tret |= pvr2_send_request(hdw, hdw->cmd_buffer, 8, hdw->cmd_buffer, 4);\n\t*data = PVR2_COMPOSE_LE(hdw->cmd_buffer,0);\n\n\tLOCK_GIVE(hdw->ctl_lock);\n\n\treturn ret;\n}\n\n\nvoid pvr2_hdw_render_useless(struct pvr2_hdw *hdw)\n{\n\tif (!hdw->flag_ok) return;\n\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t   \"Device being rendered inoperable\");\n\tif (hdw->vid_stream) {\n\t\tpvr2_stream_setup(hdw->vid_stream,NULL,0,0);\n\t}\n\thdw->flag_ok = 0;\n\ttrace_stbit(\"flag_ok\",hdw->flag_ok);\n\tpvr2_hdw_state_sched(hdw);\n}\n\n\nvoid pvr2_hdw_device_reset(struct pvr2_hdw *hdw)\n{\n\tint ret;\n\tpvr2_trace(PVR2_TRACE_INIT,\"Performing a device reset...\");\n\tret = usb_lock_device_for_reset(hdw->usb_dev,NULL);\n\tif (ret == 0) {\n\t\tret = usb_reset_device(hdw->usb_dev);\n\t\tusb_unlock_device(hdw->usb_dev);\n\t} else {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"Failed to lock USB device ret=%d\",ret);\n\t}\n\tif (init_pause_msec) {\n\t\tpvr2_trace(PVR2_TRACE_INFO,\n\t\t\t   \"Waiting %u msec for hardware to settle\",\n\t\t\t   init_pause_msec);\n\t\tmsleep(init_pause_msec);\n\t}\n\n}\n\n\nvoid pvr2_hdw_cpureset_assert(struct pvr2_hdw *hdw,int val)\n{\n\tchar *da;\n\tunsigned int pipe;\n\tint ret;\n\n\tif (!hdw->usb_dev) return;\n\n\tda = kmalloc(16, GFP_KERNEL);\n\n\tif (da == NULL) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"Unable to allocate memory to control CPU reset\");\n\t\treturn;\n\t}\n\n\tpvr2_trace(PVR2_TRACE_INIT,\"cpureset_assert(%d)\",val);\n\n\tda[0] = val ? 0x01 : 0x00;\n\n\t \n\tpipe = usb_sndctrlpipe(hdw->usb_dev, 0);\n\tret = usb_control_msg(hdw->usb_dev,pipe,0xa0,0x40,0xe600,0,da,1,1000);\n\tif (ret < 0) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"cpureset_assert(%d) error=%d\",val,ret);\n\t\tpvr2_hdw_render_useless(hdw);\n\t}\n\n\tkfree(da);\n}\n\n\nint pvr2_hdw_cmd_deep_reset(struct pvr2_hdw *hdw)\n{\n\treturn pvr2_issue_simple_cmd(hdw,FX2CMD_DEEP_RESET);\n}\n\n\nint pvr2_hdw_cmd_powerup(struct pvr2_hdw *hdw)\n{\n\treturn pvr2_issue_simple_cmd(hdw,FX2CMD_POWER_ON);\n}\n\n\n\nint pvr2_hdw_cmd_decoder_reset(struct pvr2_hdw *hdw)\n{\n\tpvr2_trace(PVR2_TRACE_INIT,\n\t\t   \"Requesting decoder reset\");\n\tif (hdw->decoder_client_id) {\n\t\tv4l2_device_call_all(&hdw->v4l2_dev, hdw->decoder_client_id,\n\t\t\t\t     core, reset, 0);\n\t\tpvr2_hdw_cx25840_vbi_hack(hdw);\n\t\treturn 0;\n\t}\n\tpvr2_trace(PVR2_TRACE_INIT,\n\t\t   \"Unable to reset decoder: nothing attached\");\n\treturn -ENOTTY;\n}\n\n\nstatic int pvr2_hdw_cmd_hcw_demod_reset(struct pvr2_hdw *hdw, int onoff)\n{\n\thdw->flag_ok = !0;\n\n\t \n\tif (le16_to_cpu(hdw->usb_dev->descriptor.idVendor) == 0x2040 &&\n\t    (le16_to_cpu(hdw->usb_dev->descriptor.idProduct) == 0x7502 ||\n\t     le16_to_cpu(hdw->usb_dev->descriptor.idProduct) == 0x7510)) {\n\t\tpr_debug(\"%s(): resetting demod on Hauppauge 160xxx platform skipped\\n\",\n\t\t\t __func__);\n\t\t \n\t\treturn pvr2_issue_simple_cmd(hdw,\n\t\t\t\t\t     FX2CMD_HCW_MAKO_SLEEP_PIN |\n\t\t\t\t\t     (1 << 8) |\n\t\t\t\t\t     ((onoff ? 1 : 0) << 16));\n\t}\n\n\treturn pvr2_issue_simple_cmd(hdw,\n\t\t\t\t     FX2CMD_HCW_DEMOD_RESETIN |\n\t\t\t\t     (1 << 8) |\n\t\t\t\t     ((onoff ? 1 : 0) << 16));\n}\n\n\nstatic int pvr2_hdw_cmd_onair_fe_power_ctrl(struct pvr2_hdw *hdw, int onoff)\n{\n\thdw->flag_ok = !0;\n\treturn pvr2_issue_simple_cmd(hdw,(onoff ?\n\t\t\t\t\t  FX2CMD_ONAIR_DTV_POWER_ON :\n\t\t\t\t\t  FX2CMD_ONAIR_DTV_POWER_OFF));\n}\n\n\nstatic int pvr2_hdw_cmd_onair_digital_path_ctrl(struct pvr2_hdw *hdw,\n\t\t\t\t\t\tint onoff)\n{\n\treturn pvr2_issue_simple_cmd(hdw,(onoff ?\n\t\t\t\t\t  FX2CMD_ONAIR_DTV_STREAMING_ON :\n\t\t\t\t\t  FX2CMD_ONAIR_DTV_STREAMING_OFF));\n}\n\n\nstatic void pvr2_hdw_cmd_modeswitch(struct pvr2_hdw *hdw,int digitalFl)\n{\n\tint cmode;\n\t \n\tcmode = (digitalFl ? PVR2_PATHWAY_DIGITAL : PVR2_PATHWAY_ANALOG);\n\tif (cmode == hdw->pathway_state) {\n\t\t \n\t\treturn;\n\t}\n\n\tswitch (hdw->hdw_desc->digital_control_scheme) {\n\tcase PVR2_DIGITAL_SCHEME_HAUPPAUGE:\n\t\tpvr2_hdw_cmd_hcw_demod_reset(hdw,digitalFl);\n\t\tif (cmode == PVR2_PATHWAY_ANALOG) {\n\t\t\t \n\t\t\tpvr2_hdw_cmd_decoder_reset(hdw);\n\t\t}\n\t\tbreak;\n\tcase PVR2_DIGITAL_SCHEME_ONAIR:\n\t\t \n\t\tpvr2_hdw_cmd_onair_fe_power_ctrl(hdw,digitalFl);\n\t\tbreak;\n\tdefault: break;\n\t}\n\n\tpvr2_hdw_untrip_unlocked(hdw);\n\thdw->pathway_state = cmode;\n}\n\n\nstatic void pvr2_led_ctrl_hauppauge(struct pvr2_hdw *hdw, int onoff)\n{\n\t \n\tif (onoff) {\n\t\tpvr2_hdw_gpio_chg_dir(hdw, 0xffffffff, 0x00000481);\n\t} else {\n\t\tpvr2_hdw_gpio_chg_dir(hdw, 0xffffffff, 0x00000401);\n\t}\n\tpvr2_hdw_gpio_chg_out(hdw, 0xffffffff, 0x00000000);\n}\n\n\ntypedef void (*led_method_func)(struct pvr2_hdw *,int);\n\nstatic led_method_func led_methods[] = {\n\t[PVR2_LED_SCHEME_HAUPPAUGE] = pvr2_led_ctrl_hauppauge,\n};\n\n\n \nstatic void pvr2_led_ctrl(struct pvr2_hdw *hdw,int onoff)\n{\n\tunsigned int scheme_id;\n\tled_method_func fp;\n\n\tif ((!onoff) == (!hdw->led_on)) return;\n\n\thdw->led_on = onoff != 0;\n\n\tscheme_id = hdw->hdw_desc->led_scheme;\n\tif (scheme_id < ARRAY_SIZE(led_methods)) {\n\t\tfp = led_methods[scheme_id];\n\t} else {\n\t\tfp = NULL;\n\t}\n\n\tif (fp) (*fp)(hdw,onoff);\n}\n\n\n \nstatic int pvr2_hdw_cmd_usbstream(struct pvr2_hdw *hdw,int runFl)\n{\n\tint ret;\n\n\t \n\tif (hdw->pathway_state == PVR2_PATHWAY_ANALOG) {\n\t\treturn pvr2_issue_simple_cmd(hdw,\n\t\t\t\t\t     (runFl ?\n\t\t\t\t\t      FX2CMD_STREAMING_ON :\n\t\t\t\t\t      FX2CMD_STREAMING_OFF));\n\t\t \n\t}\n\n\tif (hdw->pathway_state != PVR2_PATHWAY_DIGITAL) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (hdw->hdw_desc->digital_control_scheme) {\n\tcase PVR2_DIGITAL_SCHEME_HAUPPAUGE:\n\t\treturn pvr2_issue_simple_cmd(hdw,\n\t\t\t\t\t     (runFl ?\n\t\t\t\t\t      FX2CMD_HCW_DTV_STREAMING_ON :\n\t\t\t\t\t      FX2CMD_HCW_DTV_STREAMING_OFF));\n\tcase PVR2_DIGITAL_SCHEME_ONAIR:\n\t\tret = pvr2_issue_simple_cmd(hdw,\n\t\t\t\t\t    (runFl ?\n\t\t\t\t\t     FX2CMD_STREAMING_ON :\n\t\t\t\t\t     FX2CMD_STREAMING_OFF));\n\t\tif (ret) return ret;\n\t\treturn pvr2_hdw_cmd_onair_digital_path_ctrl(hdw,runFl);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n\n \nstatic int state_eval_pathway_ok(struct pvr2_hdw *hdw)\n{\n\tif (hdw->state_pathway_ok) {\n\t\t \n\t\treturn 0;\n\t}\n\tif (!hdw->state_pipeline_idle) {\n\t\t \n\t\treturn 0;\n\t}\n\tpvr2_hdw_cmd_modeswitch(hdw,hdw->input_val == PVR2_CVAL_INPUT_DTV);\n\thdw->state_pathway_ok = !0;\n\ttrace_stbit(\"state_pathway_ok\",hdw->state_pathway_ok);\n\treturn !0;\n}\n\n\n \nstatic int state_eval_encoder_ok(struct pvr2_hdw *hdw)\n{\n\tif (hdw->state_encoder_ok) return 0;\n\tif (hdw->flag_tripped) return 0;\n\tif (hdw->state_encoder_run) return 0;\n\tif (hdw->state_encoder_config) return 0;\n\tif (hdw->state_decoder_run) return 0;\n\tif (hdw->state_usbstream_run) return 0;\n\tif (hdw->pathway_state == PVR2_PATHWAY_DIGITAL) {\n\t\tif (!hdw->hdw_desc->flag_digital_requires_cx23416) return 0;\n\t} else if (hdw->pathway_state != PVR2_PATHWAY_ANALOG) {\n\t\treturn 0;\n\t}\n\n\tif (pvr2_upload_firmware2(hdw) < 0) {\n\t\thdw->flag_tripped = !0;\n\t\ttrace_stbit(\"flag_tripped\",hdw->flag_tripped);\n\t\treturn !0;\n\t}\n\thdw->state_encoder_ok = !0;\n\ttrace_stbit(\"state_encoder_ok\",hdw->state_encoder_ok);\n\treturn !0;\n}\n\n\n \nstatic int state_eval_encoder_config(struct pvr2_hdw *hdw)\n{\n\tif (hdw->state_encoder_config) {\n\t\tif (hdw->state_encoder_ok) {\n\t\t\tif (hdw->state_pipeline_req &&\n\t\t\t    !hdw->state_pipeline_pause) return 0;\n\t\t}\n\t\thdw->state_encoder_config = 0;\n\t\thdw->state_encoder_waitok = 0;\n\t\ttrace_stbit(\"state_encoder_waitok\",hdw->state_encoder_waitok);\n\t\t \n\t\tdel_timer_sync(&hdw->encoder_wait_timer);\n\t} else {\n\t\tif (!hdw->state_pathway_ok ||\n\t\t    (hdw->pathway_state != PVR2_PATHWAY_ANALOG) ||\n\t\t    !hdw->state_encoder_ok ||\n\t\t    !hdw->state_pipeline_idle ||\n\t\t    hdw->state_pipeline_pause ||\n\t\t    !hdw->state_pipeline_req ||\n\t\t    !hdw->state_pipeline_config) {\n\t\t\t \n\t\t\tif (timer_pending(&hdw->encoder_wait_timer)) {\n\t\t\t\tdel_timer_sync(&hdw->encoder_wait_timer);\n\t\t\t}\n\t\t\tif (hdw->state_encoder_waitok) {\n\t\t\t\t \n\t\t\t\thdw->state_encoder_waitok = 0;\n\t\t\t\ttrace_stbit(\"state_encoder_waitok\",\n\t\t\t\t\t    hdw->state_encoder_waitok);\n\t\t\t\treturn !0;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (!hdw->state_encoder_waitok) {\n\t\t\tif (!timer_pending(&hdw->encoder_wait_timer)) {\n\t\t\t\t \n\t\t\t\tif (!hdw->state_encoder_waitok) {\n\t\t\t\t\thdw->encoder_wait_timer.expires =\n\t\t\t\t\t\tjiffies + msecs_to_jiffies(\n\t\t\t\t\t\tTIME_MSEC_ENCODER_WAIT);\n\t\t\t\t\tadd_timer(&hdw->encoder_wait_timer);\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t\tpvr2_encoder_configure(hdw);\n\t\tif (hdw->state_encoder_ok) hdw->state_encoder_config = !0;\n\t}\n\ttrace_stbit(\"state_encoder_config\",hdw->state_encoder_config);\n\treturn !0;\n}\n\n\n \nstatic int state_check_disable_encoder_run(struct pvr2_hdw *hdw)\n{\n\tif (!hdw->state_encoder_ok) {\n\t\t \n\t\treturn !0;\n\t}\n\tif (!hdw->state_pathway_ok) {\n\t\t \n\t\treturn !0;\n\t}\n\n\tswitch (hdw->pathway_state) {\n\tcase PVR2_PATHWAY_ANALOG:\n\t\tif (!hdw->state_decoder_run) {\n\t\t\t \n\t\t\treturn !0;\n\t\t}\n\t\tbreak;\n\tcase PVR2_PATHWAY_DIGITAL:\n\t\tif (hdw->state_encoder_runok) {\n\t\t\t \n\t\t\treturn !0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn !0;\n\t}\n\n\t \n\treturn 0;\n}\n\n\n \nstatic int state_check_enable_encoder_run(struct pvr2_hdw *hdw)\n{\n\tif (!hdw->state_encoder_ok) {\n\t\t \n\t\treturn 0;\n\t}\n\tif (!hdw->state_pathway_ok) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tswitch (hdw->pathway_state) {\n\tcase PVR2_PATHWAY_ANALOG:\n\t\tif (hdw->state_decoder_run && hdw->state_decoder_ready) {\n\t\t\t \n\t\t\treturn !0;\n\t\t}\n\t\tbreak;\n\tcase PVR2_PATHWAY_DIGITAL:\n\t\tif ((hdw->hdw_desc->digital_control_scheme ==\n\t\t     PVR2_DIGITAL_SCHEME_ONAIR) &&\n\t\t    !hdw->state_encoder_runok) {\n\t\t\t \n\t\t\treturn !0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\t \n\treturn 0;\n}\n\n\n \nstatic int state_eval_encoder_run(struct pvr2_hdw *hdw)\n{\n\tif (hdw->state_encoder_run) {\n\t\tif (!state_check_disable_encoder_run(hdw)) return 0;\n\t\tif (hdw->state_encoder_ok) {\n\t\t\tdel_timer_sync(&hdw->encoder_run_timer);\n\t\t\tif (pvr2_encoder_stop(hdw) < 0) return !0;\n\t\t}\n\t\thdw->state_encoder_run = 0;\n\t} else {\n\t\tif (!state_check_enable_encoder_run(hdw)) return 0;\n\t\tif (pvr2_encoder_start(hdw) < 0) return !0;\n\t\thdw->state_encoder_run = !0;\n\t\tif (!hdw->state_encoder_runok) {\n\t\t\thdw->encoder_run_timer.expires = jiffies +\n\t\t\t\t msecs_to_jiffies(TIME_MSEC_ENCODER_OK);\n\t\t\tadd_timer(&hdw->encoder_run_timer);\n\t\t}\n\t}\n\ttrace_stbit(\"state_encoder_run\",hdw->state_encoder_run);\n\treturn !0;\n}\n\n\n \nstatic void pvr2_hdw_quiescent_timeout(struct timer_list *t)\n{\n\tstruct pvr2_hdw *hdw = from_timer(hdw, t, quiescent_timer);\n\thdw->state_decoder_quiescent = !0;\n\ttrace_stbit(\"state_decoder_quiescent\",hdw->state_decoder_quiescent);\n\thdw->state_stale = !0;\n\tschedule_work(&hdw->workpoll);\n}\n\n\n \nstatic void pvr2_hdw_decoder_stabilization_timeout(struct timer_list *t)\n{\n\tstruct pvr2_hdw *hdw = from_timer(hdw, t, decoder_stabilization_timer);\n\thdw->state_decoder_ready = !0;\n\ttrace_stbit(\"state_decoder_ready\", hdw->state_decoder_ready);\n\thdw->state_stale = !0;\n\tschedule_work(&hdw->workpoll);\n}\n\n\n \nstatic void pvr2_hdw_encoder_wait_timeout(struct timer_list *t)\n{\n\tstruct pvr2_hdw *hdw = from_timer(hdw, t, encoder_wait_timer);\n\thdw->state_encoder_waitok = !0;\n\ttrace_stbit(\"state_encoder_waitok\",hdw->state_encoder_waitok);\n\thdw->state_stale = !0;\n\tschedule_work(&hdw->workpoll);\n}\n\n\n \nstatic void pvr2_hdw_encoder_run_timeout(struct timer_list *t)\n{\n\tstruct pvr2_hdw *hdw = from_timer(hdw, t, encoder_run_timer);\n\tif (!hdw->state_encoder_runok) {\n\t\thdw->state_encoder_runok = !0;\n\t\ttrace_stbit(\"state_encoder_runok\",hdw->state_encoder_runok);\n\t\thdw->state_stale = !0;\n\t\tschedule_work(&hdw->workpoll);\n\t}\n}\n\n\n \nstatic int state_eval_decoder_run(struct pvr2_hdw *hdw)\n{\n\tif (hdw->state_decoder_run) {\n\t\tif (hdw->state_encoder_ok) {\n\t\t\tif (hdw->state_pipeline_req &&\n\t\t\t    !hdw->state_pipeline_pause &&\n\t\t\t    hdw->state_pathway_ok) return 0;\n\t\t}\n\t\tif (!hdw->flag_decoder_missed) {\n\t\t\tpvr2_decoder_enable(hdw,0);\n\t\t}\n\t\thdw->state_decoder_quiescent = 0;\n\t\thdw->state_decoder_run = 0;\n\t\t \n\t\tdel_timer_sync(&hdw->quiescent_timer);\n\t\t \n\t\tdel_timer_sync(&hdw->decoder_stabilization_timer);\n\t\thdw->state_decoder_ready = 0;\n\t} else {\n\t\tif (!hdw->state_decoder_quiescent) {\n\t\t\tif (!timer_pending(&hdw->quiescent_timer)) {\n\t\t\t\t \n\t\t\t\tif (!hdw->state_decoder_quiescent) {\n\t\t\t\t\thdw->quiescent_timer.expires =\n\t\t\t\t\t\tjiffies + msecs_to_jiffies(\n\t\t\t\t\t\tTIME_MSEC_DECODER_WAIT);\n\t\t\t\t\tadd_timer(&hdw->quiescent_timer);\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t\tif (!hdw->state_pathway_ok ||\n\t\t    (hdw->pathway_state != PVR2_PATHWAY_ANALOG) ||\n\t\t    !hdw->state_pipeline_req ||\n\t\t    hdw->state_pipeline_pause ||\n\t\t    !hdw->state_pipeline_config ||\n\t\t    !hdw->state_encoder_config ||\n\t\t    !hdw->state_encoder_ok) return 0;\n\t\tdel_timer_sync(&hdw->quiescent_timer);\n\t\tif (hdw->flag_decoder_missed) return 0;\n\t\tif (pvr2_decoder_enable(hdw,!0) < 0) return 0;\n\t\thdw->state_decoder_quiescent = 0;\n\t\thdw->state_decoder_ready = 0;\n\t\thdw->state_decoder_run = !0;\n\t\tif (hdw->decoder_client_id == PVR2_CLIENT_ID_SAA7115) {\n\t\t\thdw->decoder_stabilization_timer.expires =\n\t\t\t\tjiffies + msecs_to_jiffies(\n\t\t\t\tTIME_MSEC_DECODER_STABILIZATION_WAIT);\n\t\t\tadd_timer(&hdw->decoder_stabilization_timer);\n\t\t} else {\n\t\t\thdw->state_decoder_ready = !0;\n\t\t}\n\t}\n\ttrace_stbit(\"state_decoder_quiescent\",hdw->state_decoder_quiescent);\n\ttrace_stbit(\"state_decoder_run\",hdw->state_decoder_run);\n\ttrace_stbit(\"state_decoder_ready\", hdw->state_decoder_ready);\n\treturn !0;\n}\n\n\n \nstatic int state_eval_usbstream_run(struct pvr2_hdw *hdw)\n{\n\tif (hdw->state_usbstream_run) {\n\t\tint fl = !0;\n\t\tif (hdw->pathway_state == PVR2_PATHWAY_ANALOG) {\n\t\t\tfl = (hdw->state_encoder_ok &&\n\t\t\t      hdw->state_encoder_run);\n\t\t} else if ((hdw->pathway_state == PVR2_PATHWAY_DIGITAL) &&\n\t\t\t   (hdw->hdw_desc->flag_digital_requires_cx23416)) {\n\t\t\tfl = hdw->state_encoder_ok;\n\t\t}\n\t\tif (fl &&\n\t\t    hdw->state_pipeline_req &&\n\t\t    !hdw->state_pipeline_pause &&\n\t\t    hdw->state_pathway_ok) {\n\t\t\treturn 0;\n\t\t}\n\t\tpvr2_hdw_cmd_usbstream(hdw,0);\n\t\thdw->state_usbstream_run = 0;\n\t} else {\n\t\tif (!hdw->state_pipeline_req ||\n\t\t    hdw->state_pipeline_pause ||\n\t\t    !hdw->state_pathway_ok) return 0;\n\t\tif (hdw->pathway_state == PVR2_PATHWAY_ANALOG) {\n\t\t\tif (!hdw->state_encoder_ok ||\n\t\t\t    !hdw->state_encoder_run) return 0;\n\t\t} else if ((hdw->pathway_state == PVR2_PATHWAY_DIGITAL) &&\n\t\t\t   (hdw->hdw_desc->flag_digital_requires_cx23416)) {\n\t\t\tif (!hdw->state_encoder_ok) return 0;\n\t\t\tif (hdw->state_encoder_run) return 0;\n\t\t\tif (hdw->hdw_desc->digital_control_scheme ==\n\t\t\t    PVR2_DIGITAL_SCHEME_ONAIR) {\n\t\t\t\t \n\t\t\t\tif (!hdw->state_encoder_runok) return 0;\n\t\t\t}\n\t\t}\n\t\tif (pvr2_hdw_cmd_usbstream(hdw,!0) < 0) return 0;\n\t\thdw->state_usbstream_run = !0;\n\t}\n\ttrace_stbit(\"state_usbstream_run\",hdw->state_usbstream_run);\n\treturn !0;\n}\n\n\n \nstatic int state_eval_pipeline_config(struct pvr2_hdw *hdw)\n{\n\tif (hdw->state_pipeline_config ||\n\t    hdw->state_pipeline_pause) return 0;\n\tpvr2_hdw_commit_execute(hdw);\n\treturn !0;\n}\n\n\n \nstatic int state_update_pipeline_state(struct pvr2_hdw *hdw)\n{\n\tunsigned int st;\n\tint updatedFl = 0;\n\t \n\tst = !(hdw->state_encoder_run ||\n\t       hdw->state_decoder_run ||\n\t       hdw->state_usbstream_run ||\n\t       (!hdw->state_decoder_quiescent));\n\tif (!st != !hdw->state_pipeline_idle) {\n\t\thdw->state_pipeline_idle = st;\n\t\tupdatedFl = !0;\n\t}\n\tif (hdw->state_pipeline_idle && hdw->state_pipeline_pause) {\n\t\thdw->state_pipeline_pause = 0;\n\t\tupdatedFl = !0;\n\t}\n\treturn updatedFl;\n}\n\n\ntypedef int (*state_eval_func)(struct pvr2_hdw *);\n\n \nstatic const state_eval_func eval_funcs[] = {\n\tstate_eval_pathway_ok,\n\tstate_eval_pipeline_config,\n\tstate_eval_encoder_ok,\n\tstate_eval_encoder_config,\n\tstate_eval_decoder_run,\n\tstate_eval_encoder_run,\n\tstate_eval_usbstream_run,\n};\n\n\n \nstatic int pvr2_hdw_state_update(struct pvr2_hdw *hdw)\n{\n\tunsigned int i;\n\tint state_updated = 0;\n\tint check_flag;\n\n\tif (!hdw->state_stale) return 0;\n\tif ((hdw->fw1_state != FW1_STATE_OK) ||\n\t    !hdw->flag_ok) {\n\t\thdw->state_stale = 0;\n\t\treturn !0;\n\t}\n\t \n\tdo {\n\t\tcheck_flag = 0;\n\t\tstate_update_pipeline_state(hdw);\n\t\t \n\t\tfor (i = 0; (i<ARRAY_SIZE(eval_funcs)) && hdw->flag_ok; i++) {\n\t\t\tif ((*eval_funcs[i])(hdw)) {\n\t\t\t\tcheck_flag = !0;\n\t\t\t\tstate_updated = !0;\n\t\t\t\tstate_update_pipeline_state(hdw);\n\t\t\t}\n\t\t}\n\t} while (check_flag && hdw->flag_ok);\n\thdw->state_stale = 0;\n\ttrace_stbit(\"state_stale\",hdw->state_stale);\n\treturn state_updated;\n}\n\n\nstatic unsigned int print_input_mask(unsigned int msk,\n\t\t\t\t     char *buf,unsigned int acnt)\n{\n\tunsigned int idx,ccnt;\n\tunsigned int tcnt = 0;\n\tfor (idx = 0; idx < ARRAY_SIZE(control_values_input); idx++) {\n\t\tif (!((1UL << idx) & msk)) continue;\n\t\tccnt = scnprintf(buf+tcnt,\n\t\t\t\t acnt-tcnt,\n\t\t\t\t \"%s%s\",\n\t\t\t\t (tcnt ? \", \" : \"\"),\n\t\t\t\t control_values_input[idx]);\n\t\ttcnt += ccnt;\n\t}\n\treturn tcnt;\n}\n\n\nstatic const char *pvr2_pathway_state_name(int id)\n{\n\tswitch (id) {\n\tcase PVR2_PATHWAY_ANALOG: return \"analog\";\n\tcase PVR2_PATHWAY_DIGITAL: return \"digital\";\n\tdefault: return \"unknown\";\n\t}\n}\n\n\nstatic unsigned int pvr2_hdw_report_unlocked(struct pvr2_hdw *hdw,int which,\n\t\t\t\t\t     char *buf,unsigned int acnt)\n{\n\tswitch (which) {\n\tcase 0:\n\t\treturn scnprintf(\n\t\t\tbuf,acnt,\n\t\t\t\"driver:%s%s%s%s%s <mode=%s>\",\n\t\t\t(hdw->flag_ok ? \" <ok>\" : \" <fail>\"),\n\t\t\t(hdw->flag_init_ok ? \" <init>\" : \" <uninitialized>\"),\n\t\t\t(hdw->flag_disconnected ? \" <disconnected>\" :\n\t\t\t \" <connected>\"),\n\t\t\t(hdw->flag_tripped ? \" <tripped>\" : \"\"),\n\t\t\t(hdw->flag_decoder_missed ? \" <no decoder>\" : \"\"),\n\t\t\tpvr2_pathway_state_name(hdw->pathway_state));\n\n\tcase 1:\n\t\treturn scnprintf(\n\t\t\tbuf,acnt,\n\t\t\t\"pipeline:%s%s%s%s\",\n\t\t\t(hdw->state_pipeline_idle ? \" <idle>\" : \"\"),\n\t\t\t(hdw->state_pipeline_config ?\n\t\t\t \" <configok>\" : \" <stale>\"),\n\t\t\t(hdw->state_pipeline_req ? \" <req>\" : \"\"),\n\t\t\t(hdw->state_pipeline_pause ? \" <pause>\" : \"\"));\n\tcase 2:\n\t\treturn scnprintf(\n\t\t\tbuf,acnt,\n\t\t\t\"worker:%s%s%s%s%s%s%s\",\n\t\t\t(hdw->state_decoder_run ?\n\t\t\t (hdw->state_decoder_ready ?\n\t\t\t  \"<decode:run>\" : \" <decode:start>\") :\n\t\t\t (hdw->state_decoder_quiescent ?\n\t\t\t  \"\" : \" <decode:stop>\")),\n\t\t\t(hdw->state_decoder_quiescent ?\n\t\t\t \" <decode:quiescent>\" : \"\"),\n\t\t\t(hdw->state_encoder_ok ?\n\t\t\t \"\" : \" <encode:init>\"),\n\t\t\t(hdw->state_encoder_run ?\n\t\t\t (hdw->state_encoder_runok ?\n\t\t\t  \" <encode:run>\" :\n\t\t\t  \" <encode:firstrun>\") :\n\t\t\t (hdw->state_encoder_runok ?\n\t\t\t  \" <encode:stop>\" :\n\t\t\t  \" <encode:virgin>\")),\n\t\t\t(hdw->state_encoder_config ?\n\t\t\t \" <encode:configok>\" :\n\t\t\t (hdw->state_encoder_waitok ?\n\t\t\t  \"\" : \" <encode:waitok>\")),\n\t\t\t(hdw->state_usbstream_run ?\n\t\t\t \" <usb:run>\" : \" <usb:stop>\"),\n\t\t\t(hdw->state_pathway_ok ?\n\t\t\t \" <pathway:ok>\" : \"\"));\n\tcase 3:\n\t\treturn scnprintf(\n\t\t\tbuf,acnt,\n\t\t\t\"state: %s\",\n\t\t\tpvr2_get_state_name(hdw->master_state));\n\tcase 4: {\n\t\tunsigned int tcnt = 0;\n\t\tunsigned int ccnt;\n\n\t\tccnt = scnprintf(buf,\n\t\t\t\t acnt,\n\t\t\t\t \"Hardware supported inputs: \");\n\t\ttcnt += ccnt;\n\t\ttcnt += print_input_mask(hdw->input_avail_mask,\n\t\t\t\t\t buf+tcnt,\n\t\t\t\t\t acnt-tcnt);\n\t\tif (hdw->input_avail_mask != hdw->input_allowed_mask) {\n\t\t\tccnt = scnprintf(buf+tcnt,\n\t\t\t\t\t acnt-tcnt,\n\t\t\t\t\t \"; allowed inputs: \");\n\t\t\ttcnt += ccnt;\n\t\t\ttcnt += print_input_mask(hdw->input_allowed_mask,\n\t\t\t\t\t\t buf+tcnt,\n\t\t\t\t\t\t acnt-tcnt);\n\t\t}\n\t\treturn tcnt;\n\t}\n\tcase 5: {\n\t\tstruct pvr2_stream_stats stats;\n\t\tif (!hdw->vid_stream) break;\n\t\tpvr2_stream_get_stats(hdw->vid_stream,\n\t\t\t\t      &stats,\n\t\t\t\t      0);\n\t\treturn scnprintf(\n\t\t\tbuf,acnt,\n\t\t\t\"Bytes streamed=%u URBs: queued=%u idle=%u ready=%u processed=%u failed=%u\",\n\t\t\tstats.bytes_processed,\n\t\t\tstats.buffers_in_queue,\n\t\t\tstats.buffers_in_idle,\n\t\t\tstats.buffers_in_ready,\n\t\t\tstats.buffers_processed,\n\t\t\tstats.buffers_failed);\n\t}\n\tcase 6: {\n\t\tunsigned int id = hdw->ir_scheme_active;\n\t\treturn scnprintf(buf, acnt, \"ir scheme: id=%d %s\", id,\n\t\t\t\t (id >= ARRAY_SIZE(ir_scheme_names) ?\n\t\t\t\t  \"?\" : ir_scheme_names[id]));\n\t}\n\tdefault: break;\n\t}\n\treturn 0;\n}\n\n\n \nstatic unsigned int pvr2_hdw_report_clients(struct pvr2_hdw *hdw,\n\t\t\t\t\t    char *buf, unsigned int acnt)\n{\n\tstruct v4l2_subdev *sd;\n\tunsigned int tcnt = 0;\n\tunsigned int ccnt;\n\tstruct i2c_client *client;\n\tconst char *p;\n\tunsigned int id;\n\n\tccnt = scnprintf(buf, acnt, \"Associated v4l2-subdev drivers and I2C clients:\\n\");\n\ttcnt += ccnt;\n\tv4l2_device_for_each_subdev(sd, &hdw->v4l2_dev) {\n\t\tid = sd->grp_id;\n\t\tp = NULL;\n\t\tif (id < ARRAY_SIZE(module_names)) p = module_names[id];\n\t\tif (p) {\n\t\t\tccnt = scnprintf(buf + tcnt, acnt - tcnt, \"  %s:\", p);\n\t\t\ttcnt += ccnt;\n\t\t} else {\n\t\t\tccnt = scnprintf(buf + tcnt, acnt - tcnt,\n\t\t\t\t\t \"  (unknown id=%u):\", id);\n\t\t\ttcnt += ccnt;\n\t\t}\n\t\tclient = v4l2_get_subdevdata(sd);\n\t\tif (client) {\n\t\t\tccnt = scnprintf(buf + tcnt, acnt - tcnt,\n\t\t\t\t\t \" %s @ %02x\\n\", client->name,\n\t\t\t\t\t client->addr);\n\t\t\ttcnt += ccnt;\n\t\t} else {\n\t\t\tccnt = scnprintf(buf + tcnt, acnt - tcnt,\n\t\t\t\t\t \" no i2c client\\n\");\n\t\t\ttcnt += ccnt;\n\t\t}\n\t}\n\treturn tcnt;\n}\n\n\nunsigned int pvr2_hdw_state_report(struct pvr2_hdw *hdw,\n\t\t\t\t   char *buf,unsigned int acnt)\n{\n\tunsigned int bcnt,ccnt,idx;\n\tbcnt = 0;\n\tLOCK_TAKE(hdw->big_lock);\n\tfor (idx = 0; ; idx++) {\n\t\tccnt = pvr2_hdw_report_unlocked(hdw,idx,buf,acnt);\n\t\tif (!ccnt) break;\n\t\tbcnt += ccnt; acnt -= ccnt; buf += ccnt;\n\t\tif (!acnt) break;\n\t\tbuf[0] = '\\n'; ccnt = 1;\n\t\tbcnt += ccnt; acnt -= ccnt; buf += ccnt;\n\t}\n\tccnt = pvr2_hdw_report_clients(hdw, buf, acnt);\n\tbcnt += ccnt; acnt -= ccnt; buf += ccnt;\n\tLOCK_GIVE(hdw->big_lock);\n\treturn bcnt;\n}\n\n\nstatic void pvr2_hdw_state_log_state(struct pvr2_hdw *hdw)\n{\n\tchar buf[256];\n\tunsigned int idx, ccnt;\n\tunsigned int lcnt, ucnt;\n\n\tfor (idx = 0; ; idx++) {\n\t\tccnt = pvr2_hdw_report_unlocked(hdw,idx,buf,sizeof(buf));\n\t\tif (!ccnt) break;\n\t\tpr_info(\"%s %.*s\\n\", hdw->name, ccnt, buf);\n\t}\n\tccnt = pvr2_hdw_report_clients(hdw, buf, sizeof(buf));\n\tif (ccnt >= sizeof(buf))\n\t\tccnt = sizeof(buf);\n\n\tucnt = 0;\n\twhile (ucnt < ccnt) {\n\t\tlcnt = 0;\n\t\twhile ((lcnt + ucnt < ccnt) && (buf[lcnt + ucnt] != '\\n')) {\n\t\t\tlcnt++;\n\t\t}\n\t\tpr_info(\"%s %.*s\\n\", hdw->name, lcnt, buf + ucnt);\n\t\tucnt += lcnt + 1;\n\t}\n}\n\n\n \nstatic int pvr2_hdw_state_eval(struct pvr2_hdw *hdw)\n{\n\tunsigned int st;\n\tint state_updated = 0;\n\tint callback_flag = 0;\n\tint analog_mode;\n\n\tpvr2_trace(PVR2_TRACE_STBITS,\n\t\t   \"Drive state check START\");\n\tif (pvrusb2_debug & PVR2_TRACE_STBITS) {\n\t\tpvr2_hdw_state_log_state(hdw);\n\t}\n\n\t \n\tstate_updated = pvr2_hdw_state_update(hdw);\n\n\tanalog_mode = (hdw->pathway_state != PVR2_PATHWAY_DIGITAL);\n\n\t \n\tif (!hdw->flag_ok) {\n\t\tst = PVR2_STATE_DEAD;\n\t} else if (hdw->fw1_state != FW1_STATE_OK) {\n\t\tst = PVR2_STATE_COLD;\n\t} else if ((analog_mode ||\n\t\t    hdw->hdw_desc->flag_digital_requires_cx23416) &&\n\t\t   !hdw->state_encoder_ok) {\n\t\tst = PVR2_STATE_WARM;\n\t} else if (hdw->flag_tripped ||\n\t\t   (analog_mode && hdw->flag_decoder_missed)) {\n\t\tst = PVR2_STATE_ERROR;\n\t} else if (hdw->state_usbstream_run &&\n\t\t   (!analog_mode ||\n\t\t    (hdw->state_encoder_run && hdw->state_decoder_run))) {\n\t\tst = PVR2_STATE_RUN;\n\t} else {\n\t\tst = PVR2_STATE_READY;\n\t}\n\tif (hdw->master_state != st) {\n\t\tpvr2_trace(PVR2_TRACE_STATE,\n\t\t\t   \"Device state change from %s to %s\",\n\t\t\t   pvr2_get_state_name(hdw->master_state),\n\t\t\t   pvr2_get_state_name(st));\n\t\tpvr2_led_ctrl(hdw,st == PVR2_STATE_RUN);\n\t\thdw->master_state = st;\n\t\tstate_updated = !0;\n\t\tcallback_flag = !0;\n\t}\n\tif (state_updated) {\n\t\t \n\t\twake_up(&hdw->state_wait_data);\n\t}\n\n\tif (pvrusb2_debug & PVR2_TRACE_STBITS) {\n\t\tpvr2_hdw_state_log_state(hdw);\n\t}\n\tpvr2_trace(PVR2_TRACE_STBITS,\n\t\t   \"Drive state check DONE callback=%d\",callback_flag);\n\n\treturn callback_flag;\n}\n\n\n \nstatic void pvr2_hdw_state_sched(struct pvr2_hdw *hdw)\n{\n\tif (hdw->state_stale) return;\n\thdw->state_stale = !0;\n\ttrace_stbit(\"state_stale\",hdw->state_stale);\n\tschedule_work(&hdw->workpoll);\n}\n\n\nint pvr2_hdw_gpio_get_dir(struct pvr2_hdw *hdw,u32 *dp)\n{\n\treturn pvr2_read_register(hdw,PVR2_GPIO_DIR,dp);\n}\n\n\nint pvr2_hdw_gpio_get_out(struct pvr2_hdw *hdw,u32 *dp)\n{\n\treturn pvr2_read_register(hdw,PVR2_GPIO_OUT,dp);\n}\n\n\nint pvr2_hdw_gpio_get_in(struct pvr2_hdw *hdw,u32 *dp)\n{\n\treturn pvr2_read_register(hdw,PVR2_GPIO_IN,dp);\n}\n\n\nint pvr2_hdw_gpio_chg_dir(struct pvr2_hdw *hdw,u32 msk,u32 val)\n{\n\tu32 cval,nval;\n\tint ret;\n\tif (~msk) {\n\t\tret = pvr2_read_register(hdw,PVR2_GPIO_DIR,&cval);\n\t\tif (ret) return ret;\n\t\tnval = (cval & ~msk) | (val & msk);\n\t\tpvr2_trace(PVR2_TRACE_GPIO,\n\t\t\t   \"GPIO direction changing 0x%x:0x%x from 0x%x to 0x%x\",\n\t\t\t   msk,val,cval,nval);\n\t} else {\n\t\tnval = val;\n\t\tpvr2_trace(PVR2_TRACE_GPIO,\n\t\t\t   \"GPIO direction changing to 0x%x\",nval);\n\t}\n\treturn pvr2_write_register(hdw,PVR2_GPIO_DIR,nval);\n}\n\n\nint pvr2_hdw_gpio_chg_out(struct pvr2_hdw *hdw,u32 msk,u32 val)\n{\n\tu32 cval,nval;\n\tint ret;\n\tif (~msk) {\n\t\tret = pvr2_read_register(hdw,PVR2_GPIO_OUT,&cval);\n\t\tif (ret) return ret;\n\t\tnval = (cval & ~msk) | (val & msk);\n\t\tpvr2_trace(PVR2_TRACE_GPIO,\n\t\t\t   \"GPIO output changing 0x%x:0x%x from 0x%x to 0x%x\",\n\t\t\t   msk,val,cval,nval);\n\t} else {\n\t\tnval = val;\n\t\tpvr2_trace(PVR2_TRACE_GPIO,\n\t\t\t   \"GPIO output changing to 0x%x\",nval);\n\t}\n\treturn pvr2_write_register(hdw,PVR2_GPIO_OUT,nval);\n}\n\n\nvoid pvr2_hdw_status_poll(struct pvr2_hdw *hdw)\n{\n\tstruct v4l2_tuner *vtp = &hdw->tuner_signal_info;\n\tmemset(vtp, 0, sizeof(*vtp));\n\tvtp->type = (hdw->input_val == PVR2_CVAL_INPUT_RADIO) ?\n\t\tV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\n\thdw->tuner_signal_stale = 0;\n\t \n\tv4l2_device_call_all(&hdw->v4l2_dev, 0, tuner, g_tuner, vtp);\n\tpvr2_trace(PVR2_TRACE_CHIPS, \"subdev status poll type=%u strength=%u audio=0x%x cap=0x%x low=%u hi=%u\",\n\t\t   vtp->type,\n\t\t   vtp->signal, vtp->rxsubchans, vtp->capability,\n\t\t   vtp->rangelow, vtp->rangehigh);\n\n\t \n\thdw->cropcap_stale = 0;\n}\n\n\nunsigned int pvr2_hdw_get_input_available(struct pvr2_hdw *hdw)\n{\n\treturn hdw->input_avail_mask;\n}\n\n\nunsigned int pvr2_hdw_get_input_allowed(struct pvr2_hdw *hdw)\n{\n\treturn hdw->input_allowed_mask;\n}\n\n\nstatic int pvr2_hdw_set_input(struct pvr2_hdw *hdw,int v)\n{\n\tif (hdw->input_val != v) {\n\t\thdw->input_val = v;\n\t\thdw->input_dirty = !0;\n\t}\n\n\t \n\tif (hdw->input_val == PVR2_CVAL_INPUT_RADIO) {\n\t\thdw->freqSelector = 0;\n\t\thdw->freqDirty = !0;\n\t} else if ((hdw->input_val == PVR2_CVAL_INPUT_TV) ||\n\t\t   (hdw->input_val == PVR2_CVAL_INPUT_DTV)) {\n\t\thdw->freqSelector = 1;\n\t\thdw->freqDirty = !0;\n\t}\n\treturn 0;\n}\n\n\nint pvr2_hdw_set_input_allowed(struct pvr2_hdw *hdw,\n\t\t\t       unsigned int change_mask,\n\t\t\t       unsigned int change_val)\n{\n\tint ret = 0;\n\tunsigned int nv,m,idx;\n\tLOCK_TAKE(hdw->big_lock);\n\tdo {\n\t\tnv = hdw->input_allowed_mask & ~change_mask;\n\t\tnv |= (change_val & change_mask);\n\t\tnv &= hdw->input_avail_mask;\n\t\tif (!nv) {\n\t\t\t \n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\thdw->input_allowed_mask = nv;\n\t\tif ((1UL << hdw->input_val) & hdw->input_allowed_mask) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (!hdw->input_allowed_mask) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tm = hdw->input_allowed_mask;\n\t\tfor (idx = 0; idx < (sizeof(m) << 3); idx++) {\n\t\t\tif (!((1UL << idx) & m)) continue;\n\t\t\tpvr2_hdw_set_input(hdw,idx);\n\t\t\tbreak;\n\t\t}\n\t} while (0);\n\tLOCK_GIVE(hdw->big_lock);\n\treturn ret;\n}\n\n\n \nstatic int pvr2_hdw_get_eeprom_addr(struct pvr2_hdw *hdw)\n{\n\tint result;\n\tLOCK_TAKE(hdw->ctl_lock); do {\n\t\thdw->cmd_buffer[0] = FX2CMD_GET_EEPROM_ADDR;\n\t\tresult = pvr2_send_request(hdw,\n\t\t\t\t\t   hdw->cmd_buffer,1,\n\t\t\t\t\t   hdw->cmd_buffer,1);\n\t\tif (result < 0) break;\n\t\tresult = hdw->cmd_buffer[0];\n\t} while(0); LOCK_GIVE(hdw->ctl_lock);\n\treturn result;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}