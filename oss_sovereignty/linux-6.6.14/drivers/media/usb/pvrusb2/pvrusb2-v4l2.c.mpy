{
  "module_name": "pvrusb2-v4l2.c",
  "hash_id": "5930dad6619c04f4d4429ec5d40d5db7ceb0205c11011ea399edaefd96e6d461",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include \"pvrusb2-context.h\"\n#include \"pvrusb2-hdw.h\"\n#include \"pvrusb2.h\"\n#include \"pvrusb2-debug.h\"\n#include \"pvrusb2-v4l2.h\"\n#include \"pvrusb2-ioread.h\"\n#include <linux/videodev2.h>\n#include <linux/module.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n\nstruct pvr2_v4l2_dev;\nstruct pvr2_v4l2_fh;\nstruct pvr2_v4l2;\n\nstruct pvr2_v4l2_dev {\n\tstruct video_device devbase;  \n\tstruct pvr2_v4l2 *v4lp;\n\tstruct pvr2_context_stream *stream;\n\t \n\tenum pvr2_config config;  \n\tint v4l_type;  \n\tenum pvr2_v4l_type minor_type;  \n};\n\nstruct pvr2_v4l2_fh {\n\tstruct v4l2_fh fh;\n\tstruct pvr2_channel channel;\n\tstruct pvr2_v4l2_dev *pdi;\n\tstruct pvr2_ioread *rhp;\n\tstruct file *file;\n\twait_queue_head_t wait_data;\n\tint fw_mode_flag;\n\t \n\tunsigned char *input_map;\n\tunsigned int input_cnt;\n};\n\nstruct pvr2_v4l2 {\n\tstruct pvr2_channel channel;\n\n\t \n\tstruct pvr2_v4l2_dev *dev_video;\n\tstruct pvr2_v4l2_dev *dev_radio;\n};\n\nstatic int video_nr[PVR_NUM] = {[0 ... PVR_NUM-1] = -1};\nmodule_param_array(video_nr, int, NULL, 0444);\nMODULE_PARM_DESC(video_nr, \"Offset for device's video dev minor\");\nstatic int radio_nr[PVR_NUM] = {[0 ... PVR_NUM-1] = -1};\nmodule_param_array(radio_nr, int, NULL, 0444);\nMODULE_PARM_DESC(radio_nr, \"Offset for device's radio dev minor\");\nstatic int vbi_nr[PVR_NUM] = {[0 ... PVR_NUM-1] = -1};\nmodule_param_array(vbi_nr, int, NULL, 0444);\nMODULE_PARM_DESC(vbi_nr, \"Offset for device's vbi dev minor\");\n\n#define PVR_FORMAT_PIX  0\n#define PVR_FORMAT_VBI  1\n\nstatic struct v4l2_format pvr_format [] = {\n\t[PVR_FORMAT_PIX] = {\n\t\t.type   = V4L2_BUF_TYPE_VIDEO_CAPTURE,\n\t\t.fmt    = {\n\t\t\t.pix        = {\n\t\t\t\t.width          = 720,\n\t\t\t\t.height         = 576,\n\t\t\t\t.pixelformat    = V4L2_PIX_FMT_MPEG,\n\t\t\t\t.field          = V4L2_FIELD_INTERLACED,\n\t\t\t\t \n\t\t\t\t.sizeimage      = 32 * 1024,\n\t\t\t}\n\t\t}\n\t},\n\t[PVR_FORMAT_VBI] = {\n\t\t.type   = V4L2_BUF_TYPE_VBI_CAPTURE,\n\t\t.fmt    = {\n\t\t\t.vbi        = {\n\t\t\t\t.sampling_rate = 27000000,\n\t\t\t\t.offset = 248,\n\t\t\t\t.samples_per_line = 1443,\n\t\t\t\t.sample_format = V4L2_PIX_FMT_GREY,\n\t\t\t\t.start = { 0, 0 },\n\t\t\t\t.count = { 0, 0 },\n\t\t\t\t.flags = 0,\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\n \nstatic int pvr2_querycap(struct file *file, void *priv, struct v4l2_capability *cap)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\n\tstrscpy(cap->driver, \"pvrusb2\", sizeof(cap->driver));\n\tstrscpy(cap->bus_info, pvr2_hdw_get_bus_info(hdw),\n\t\tsizeof(cap->bus_info));\n\tstrscpy(cap->card, pvr2_hdw_get_desc(hdw), sizeof(cap->card));\n\tcap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_TUNER |\n\t\t\t    V4L2_CAP_AUDIO | V4L2_CAP_RADIO |\n\t\t\t    V4L2_CAP_READWRITE | V4L2_CAP_DEVICE_CAPS;\n\treturn 0;\n}\n\nstatic int pvr2_g_std(struct file *file, void *priv, v4l2_std_id *std)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tint val = 0;\n\tint ret;\n\n\tret = pvr2_ctrl_get_value(\n\t\t\tpvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_STDCUR), &val);\n\t*std = val;\n\treturn ret;\n}\n\nstatic int pvr2_s_std(struct file *file, void *priv, v4l2_std_id std)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tint ret;\n\n\tret = pvr2_ctrl_set_value(\n\t\tpvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_STDCUR), std);\n\tpvr2_hdw_commit_ctl(hdw);\n\treturn ret;\n}\n\nstatic int pvr2_querystd(struct file *file, void *priv, v4l2_std_id *std)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tint val = 0;\n\tint ret;\n\n\tret = pvr2_ctrl_get_value(\n\t\tpvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_STDDETECT), &val);\n\t*std = val;\n\treturn ret;\n}\n\nstatic int pvr2_enum_input(struct file *file, void *priv, struct v4l2_input *vi)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tstruct pvr2_ctrl *cptr;\n\tstruct v4l2_input tmp;\n\tunsigned int cnt;\n\tint val;\n\n\tcptr = pvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_INPUT);\n\n\tmemset(&tmp, 0, sizeof(tmp));\n\ttmp.index = vi->index;\n\tif (vi->index >= fh->input_cnt)\n\t\treturn -EINVAL;\n\tval = fh->input_map[vi->index];\n\tswitch (val) {\n\tcase PVR2_CVAL_INPUT_TV:\n\tcase PVR2_CVAL_INPUT_DTV:\n\tcase PVR2_CVAL_INPUT_RADIO:\n\t\ttmp.type = V4L2_INPUT_TYPE_TUNER;\n\t\tbreak;\n\tcase PVR2_CVAL_INPUT_SVIDEO:\n\tcase PVR2_CVAL_INPUT_COMPOSITE:\n\t\ttmp.type = V4L2_INPUT_TYPE_CAMERA;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcnt = 0;\n\tpvr2_ctrl_get_valname(cptr, val,\n\t\t\ttmp.name, sizeof(tmp.name) - 1, &cnt);\n\ttmp.name[cnt] = 0;\n\n\t \n\n\t \n\t*vi = tmp;\n\treturn 0;\n}\n\nstatic int pvr2_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tunsigned int idx;\n\tstruct pvr2_ctrl *cptr;\n\tint val;\n\tint ret;\n\n\tcptr = pvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_INPUT);\n\tval = 0;\n\tret = pvr2_ctrl_get_value(cptr, &val);\n\t*i = 0;\n\tfor (idx = 0; idx < fh->input_cnt; idx++) {\n\t\tif (fh->input_map[idx] == val) {\n\t\t\t*i = idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int pvr2_s_input(struct file *file, void *priv, unsigned int inp)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tint ret;\n\n\tif (inp >= fh->input_cnt)\n\t\treturn -EINVAL;\n\tret = pvr2_ctrl_set_value(\n\t\t\tpvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_INPUT),\n\t\t\tfh->input_map[inp]);\n\tpvr2_hdw_commit_ctl(hdw);\n\treturn ret;\n}\n\nstatic int pvr2_enumaudio(struct file *file, void *priv, struct v4l2_audio *vin)\n{\n\t \n\n\tif (vin->index > 0)\n\t\treturn -EINVAL;\n\tstrscpy(vin->name, \"PVRUSB2 Audio\", sizeof(vin->name));\n\tvin->capability = V4L2_AUDCAP_STEREO;\n\treturn 0;\n}\n\nstatic int pvr2_g_audio(struct file *file, void *priv, struct v4l2_audio *vin)\n{\n\t \n\tvin->index = 0;\n\tstrscpy(vin->name, \"PVRUSB2 Audio\", sizeof(vin->name));\n\tvin->capability = V4L2_AUDCAP_STEREO;\n\treturn 0;\n}\n\nstatic int pvr2_s_audio(struct file *file, void *priv, const struct v4l2_audio *vout)\n{\n\tif (vout->index)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int pvr2_g_tuner(struct file *file, void *priv, struct v4l2_tuner *vt)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\n\tif (vt->index != 0)\n\t\treturn -EINVAL;  \n\n\tpvr2_hdw_execute_tuner_poll(hdw);\n\treturn pvr2_hdw_get_tuner_status(hdw, vt);\n}\n\nstatic int pvr2_s_tuner(struct file *file, void *priv, const struct v4l2_tuner *vt)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tint ret;\n\n\tif (vt->index != 0)\n\t\treturn -EINVAL;\n\n\tret = pvr2_ctrl_set_value(\n\t\t\tpvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_AUDIOMODE),\n\t\t\tvt->audmode);\n\tpvr2_hdw_commit_ctl(hdw);\n\treturn ret;\n}\n\nstatic int pvr2_s_frequency(struct file *file, void *priv, const struct v4l2_frequency *vf)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tunsigned long fv;\n\tstruct v4l2_tuner vt;\n\tint cur_input;\n\tstruct pvr2_ctrl *ctrlp;\n\tint ret;\n\n\tret = pvr2_hdw_get_tuner_status(hdw, &vt);\n\tif (ret != 0)\n\t\treturn ret;\n\tctrlp = pvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_INPUT);\n\tret = pvr2_ctrl_get_value(ctrlp, &cur_input);\n\tif (ret != 0)\n\t\treturn ret;\n\tif (vf->type == V4L2_TUNER_RADIO) {\n\t\tif (cur_input != PVR2_CVAL_INPUT_RADIO)\n\t\t\tpvr2_ctrl_set_value(ctrlp, PVR2_CVAL_INPUT_RADIO);\n\t} else {\n\t\tif (cur_input == PVR2_CVAL_INPUT_RADIO)\n\t\t\tpvr2_ctrl_set_value(ctrlp, PVR2_CVAL_INPUT_TV);\n\t}\n\tfv = vf->frequency;\n\tif (vt.capability & V4L2_TUNER_CAP_LOW)\n\t\tfv = (fv * 125) / 2;\n\telse\n\t\tfv = fv * 62500;\n\tret = pvr2_ctrl_set_value(\n\t\t\tpvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_FREQUENCY),fv);\n\tpvr2_hdw_commit_ctl(hdw);\n\treturn ret;\n}\n\nstatic int pvr2_g_frequency(struct file *file, void *priv, struct v4l2_frequency *vf)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tint val = 0;\n\tint cur_input;\n\tstruct v4l2_tuner vt;\n\tint ret;\n\n\tret = pvr2_hdw_get_tuner_status(hdw, &vt);\n\tif (ret != 0)\n\t\treturn ret;\n\tret = pvr2_ctrl_get_value(\n\t\t\tpvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_FREQUENCY),\n\t\t\t&val);\n\tif (ret != 0)\n\t\treturn ret;\n\tpvr2_ctrl_get_value(\n\t\t\tpvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_INPUT),\n\t\t\t&cur_input);\n\tif (cur_input == PVR2_CVAL_INPUT_RADIO)\n\t\tvf->type = V4L2_TUNER_RADIO;\n\telse\n\t\tvf->type = V4L2_TUNER_ANALOG_TV;\n\tif (vt.capability & V4L2_TUNER_CAP_LOW)\n\t\tval = (val * 2) / 125;\n\telse\n\t\tval /= 62500;\n\tvf->frequency = val;\n\treturn 0;\n}\n\nstatic int pvr2_enum_fmt_vid_cap(struct file *file, void *priv, struct v4l2_fmtdesc *fd)\n{\n\t \n\tif (fd->index)\n\t\treturn -EINVAL;\n\n\tfd->pixelformat = V4L2_PIX_FMT_MPEG;\n\treturn 0;\n}\n\nstatic int pvr2_g_fmt_vid_cap(struct file *file, void *priv, struct v4l2_format *vf)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tint val;\n\n\tmemcpy(vf, &pvr_format[PVR_FORMAT_PIX], sizeof(struct v4l2_format));\n\tval = 0;\n\tpvr2_ctrl_get_value(\n\t\t\tpvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_HRES),\n\t\t\t&val);\n\tvf->fmt.pix.width = val;\n\tval = 0;\n\tpvr2_ctrl_get_value(\n\t\t\tpvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_VRES),\n\t\t\t&val);\n\tvf->fmt.pix.height = val;\n\treturn 0;\n}\n\nstatic int pvr2_try_fmt_vid_cap(struct file *file, void *priv, struct v4l2_format *vf)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tint lmin, lmax, ldef;\n\tstruct pvr2_ctrl *hcp, *vcp;\n\tint h = vf->fmt.pix.height;\n\tint w = vf->fmt.pix.width;\n\n\thcp = pvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_HRES);\n\tvcp = pvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_VRES);\n\n\tlmin = pvr2_ctrl_get_min(hcp);\n\tlmax = pvr2_ctrl_get_max(hcp);\n\tpvr2_ctrl_get_def(hcp, &ldef);\n\tif (w == -1)\n\t\tw = ldef;\n\telse if (w < lmin)\n\t\tw = lmin;\n\telse if (w > lmax)\n\t\tw = lmax;\n\tlmin = pvr2_ctrl_get_min(vcp);\n\tlmax = pvr2_ctrl_get_max(vcp);\n\tpvr2_ctrl_get_def(vcp, &ldef);\n\tif (h == -1)\n\t\th = ldef;\n\telse if (h < lmin)\n\t\th = lmin;\n\telse if (h > lmax)\n\t\th = lmax;\n\n\tmemcpy(vf, &pvr_format[PVR_FORMAT_PIX],\n\t\t\tsizeof(struct v4l2_format));\n\tvf->fmt.pix.width = w;\n\tvf->fmt.pix.height = h;\n\treturn 0;\n}\n\nstatic int pvr2_s_fmt_vid_cap(struct file *file, void *priv, struct v4l2_format *vf)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tstruct pvr2_ctrl *hcp, *vcp;\n\tint ret = pvr2_try_fmt_vid_cap(file, fh, vf);\n\n\tif (ret)\n\t\treturn ret;\n\thcp = pvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_HRES);\n\tvcp = pvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_VRES);\n\tpvr2_ctrl_set_value(hcp, vf->fmt.pix.width);\n\tpvr2_ctrl_set_value(vcp, vf->fmt.pix.height);\n\tpvr2_hdw_commit_ctl(hdw);\n\treturn 0;\n}\n\nstatic int pvr2_streamon(struct file *file, void *priv, enum v4l2_buf_type i)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tstruct pvr2_v4l2_dev *pdi = fh->pdi;\n\tint ret;\n\n\tif (!fh->pdi->stream) {\n\t\t \n\t\treturn -EPERM;\n\t}\n\tret = pvr2_hdw_set_stream_type(hdw, pdi->config);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn pvr2_hdw_set_streaming(hdw, !0);\n}\n\nstatic int pvr2_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\n\tif (!fh->pdi->stream) {\n\t\t \n\t\treturn -EPERM;\n\t}\n\treturn pvr2_hdw_set_streaming(hdw, 0);\n}\n\nstatic int pvr2_queryctrl(struct file *file, void *priv,\n\t\tstruct v4l2_queryctrl *vc)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tstruct pvr2_ctrl *cptr;\n\tint val;\n\n\tif (vc->id & V4L2_CTRL_FLAG_NEXT_CTRL) {\n\t\tcptr = pvr2_hdw_get_ctrl_nextv4l(\n\t\t\t\thdw, (vc->id & ~V4L2_CTRL_FLAG_NEXT_CTRL));\n\t\tif (cptr)\n\t\t\tvc->id = pvr2_ctrl_get_v4lid(cptr);\n\t} else {\n\t\tcptr = pvr2_hdw_get_ctrl_v4l(hdw, vc->id);\n\t}\n\tif (!cptr) {\n\t\tpvr2_trace(PVR2_TRACE_V4LIOCTL,\n\t\t\t\t\"QUERYCTRL id=0x%x not implemented here\",\n\t\t\t\tvc->id);\n\t\treturn -EINVAL;\n\t}\n\n\tpvr2_trace(PVR2_TRACE_V4LIOCTL,\n\t\t\t\"QUERYCTRL id=0x%x mapping name=%s (%s)\",\n\t\t\tvc->id, pvr2_ctrl_get_name(cptr),\n\t\t\tpvr2_ctrl_get_desc(cptr));\n\tstrscpy(vc->name, pvr2_ctrl_get_desc(cptr), sizeof(vc->name));\n\tvc->flags = pvr2_ctrl_get_v4lflags(cptr);\n\tpvr2_ctrl_get_def(cptr, &val);\n\tvc->default_value = val;\n\tswitch (pvr2_ctrl_get_type(cptr)) {\n\tcase pvr2_ctl_enum:\n\t\tvc->type = V4L2_CTRL_TYPE_MENU;\n\t\tvc->minimum = 0;\n\t\tvc->maximum = pvr2_ctrl_get_cnt(cptr) - 1;\n\t\tvc->step = 1;\n\t\tbreak;\n\tcase pvr2_ctl_bool:\n\t\tvc->type = V4L2_CTRL_TYPE_BOOLEAN;\n\t\tvc->minimum = 0;\n\t\tvc->maximum = 1;\n\t\tvc->step = 1;\n\t\tbreak;\n\tcase pvr2_ctl_int:\n\t\tvc->type = V4L2_CTRL_TYPE_INTEGER;\n\t\tvc->minimum = pvr2_ctrl_get_min(cptr);\n\t\tvc->maximum = pvr2_ctrl_get_max(cptr);\n\t\tvc->step = 1;\n\t\tbreak;\n\tdefault:\n\t\tpvr2_trace(PVR2_TRACE_V4LIOCTL,\n\t\t\t\t\"QUERYCTRL id=0x%x name=%s not mappable\",\n\t\t\t\tvc->id, pvr2_ctrl_get_name(cptr));\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int pvr2_querymenu(struct file *file, void *priv, struct v4l2_querymenu *vm)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tunsigned int cnt = 0;\n\tint ret;\n\n\tret = pvr2_ctrl_get_valname(pvr2_hdw_get_ctrl_v4l(hdw, vm->id),\n\t\t\tvm->index,\n\t\t\tvm->name, sizeof(vm->name) - 1,\n\t\t\t&cnt);\n\tvm->name[cnt] = 0;\n\treturn ret;\n}\n\nstatic int pvr2_g_ctrl(struct file *file, void *priv, struct v4l2_control *vc)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tint val = 0;\n\tint ret;\n\n\tret = pvr2_ctrl_get_value(pvr2_hdw_get_ctrl_v4l(hdw, vc->id),\n\t\t\t&val);\n\tvc->value = val;\n\treturn ret;\n}\n\nstatic int pvr2_s_ctrl(struct file *file, void *priv, struct v4l2_control *vc)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tint ret;\n\n\tret = pvr2_ctrl_set_value(pvr2_hdw_get_ctrl_v4l(hdw, vc->id),\n\t\t\tvc->value);\n\tpvr2_hdw_commit_ctl(hdw);\n\treturn ret;\n}\n\nstatic int pvr2_g_ext_ctrls(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_ext_controls *ctls)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tstruct v4l2_ext_control *ctrl;\n\tstruct pvr2_ctrl *cptr;\n\tunsigned int idx;\n\tint val;\n\tint ret;\n\n\tret = 0;\n\tfor (idx = 0; idx < ctls->count; idx++) {\n\t\tctrl = ctls->controls + idx;\n\t\tcptr = pvr2_hdw_get_ctrl_v4l(hdw, ctrl->id);\n\t\tif (cptr) {\n\t\t\tif (ctls->which == V4L2_CTRL_WHICH_DEF_VAL)\n\t\t\t\tpvr2_ctrl_get_def(cptr, &val);\n\t\t\telse\n\t\t\t\tret = pvr2_ctrl_get_value(cptr, &val);\n\t\t} else\n\t\t\tret = -EINVAL;\n\n\t\tif (ret) {\n\t\t\tctls->error_idx = idx;\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tctrl->value64 = 0;\n\t\tctrl->value = val;\n\t}\n\treturn 0;\n}\n\nstatic int pvr2_s_ext_ctrls(struct file *file, void *priv,\n\t\tstruct v4l2_ext_controls *ctls)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tstruct v4l2_ext_control *ctrl;\n\tunsigned int idx;\n\tint ret;\n\n\tret = 0;\n\tfor (idx = 0; idx < ctls->count; idx++) {\n\t\tctrl = ctls->controls + idx;\n\t\tret = pvr2_ctrl_set_value(\n\t\t\t\tpvr2_hdw_get_ctrl_v4l(hdw, ctrl->id),\n\t\t\t\tctrl->value);\n\t\tif (ret) {\n\t\t\tctls->error_idx = idx;\n\t\t\tgoto commit;\n\t\t}\n\t}\ncommit:\n\tpvr2_hdw_commit_ctl(hdw);\n\treturn ret;\n}\n\nstatic int pvr2_try_ext_ctrls(struct file *file, void *priv,\n\t\tstruct v4l2_ext_controls *ctls)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tstruct v4l2_ext_control *ctrl;\n\tstruct pvr2_ctrl *pctl;\n\tunsigned int idx;\n\n\t \n\tfor (idx = 0; idx < ctls->count; idx++) {\n\t\tctrl = ctls->controls + idx;\n\t\tpctl = pvr2_hdw_get_ctrl_v4l(hdw, ctrl->id);\n\t\tif (!pctl) {\n\t\t\tctls->error_idx = idx;\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int pvr2_g_pixelaspect(struct file *file, void *priv,\n\t\t\t      int type, struct v4l2_fract *f)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tstruct v4l2_cropcap cap = { .type = type };\n\tint ret;\n\n\tif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\tret = pvr2_hdw_get_cropcap(hdw, &cap);\n\tif (!ret)\n\t\t*f = cap.pixelaspect;\n\treturn ret;\n}\n\nstatic int pvr2_g_selection(struct file *file, void *priv,\n\t\t\t    struct v4l2_selection *sel)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tstruct v4l2_cropcap cap;\n\tint val = 0;\n\tint ret;\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tret = pvr2_ctrl_get_value(\n\t\t\t  pvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPL), &val);\n\t\tif (ret != 0)\n\t\t\treturn -EINVAL;\n\t\tsel->r.left = val;\n\t\tret = pvr2_ctrl_get_value(\n\t\t\t  pvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPT), &val);\n\t\tif (ret != 0)\n\t\t\treturn -EINVAL;\n\t\tsel->r.top = val;\n\t\tret = pvr2_ctrl_get_value(\n\t\t\t  pvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPW), &val);\n\t\tif (ret != 0)\n\t\t\treturn -EINVAL;\n\t\tsel->r.width = val;\n\t\tret = pvr2_ctrl_get_value(\n\t\t\t  pvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPH), &val);\n\t\tif (ret != 0)\n\t\t\treturn -EINVAL;\n\t\tsel->r.height = val;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tret = pvr2_hdw_get_cropcap(hdw, &cap);\n\t\tsel->r = cap.defrect;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tret = pvr2_hdw_get_cropcap(hdw, &cap);\n\t\tsel->r = cap.bounds;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int pvr2_s_selection(struct file *file, void *priv,\n\t\t\t    struct v4l2_selection *sel)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\tint ret;\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\n\t    sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\tret = pvr2_ctrl_set_value(\n\t\t\tpvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPL),\n\t\t\tsel->r.left);\n\tif (ret != 0)\n\t\tgoto commit;\n\tret = pvr2_ctrl_set_value(\n\t\t\tpvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPT),\n\t\t\tsel->r.top);\n\tif (ret != 0)\n\t\tgoto commit;\n\tret = pvr2_ctrl_set_value(\n\t\t\tpvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPW),\n\t\t\tsel->r.width);\n\tif (ret != 0)\n\t\tgoto commit;\n\tret = pvr2_ctrl_set_value(\n\t\t\tpvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPH),\n\t\t\tsel->r.height);\ncommit:\n\tpvr2_hdw_commit_ctl(hdw);\n\treturn ret;\n}\n\nstatic int pvr2_log_status(struct file *file, void *priv)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\n\tpvr2_hdw_trigger_module_log(hdw);\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops pvr2_ioctl_ops = {\n\t.vidioc_querycap\t\t    = pvr2_querycap,\n\t.vidioc_s_audio\t\t\t    = pvr2_s_audio,\n\t.vidioc_g_audio\t\t\t    = pvr2_g_audio,\n\t.vidioc_enumaudio\t\t    = pvr2_enumaudio,\n\t.vidioc_enum_input\t\t    = pvr2_enum_input,\n\t.vidioc_g_pixelaspect\t\t    = pvr2_g_pixelaspect,\n\t.vidioc_s_selection\t\t    = pvr2_s_selection,\n\t.vidioc_g_selection\t\t    = pvr2_g_selection,\n\t.vidioc_g_input\t\t\t    = pvr2_g_input,\n\t.vidioc_s_input\t\t\t    = pvr2_s_input,\n\t.vidioc_g_frequency\t\t    = pvr2_g_frequency,\n\t.vidioc_s_frequency\t\t    = pvr2_s_frequency,\n\t.vidioc_s_tuner\t\t\t    = pvr2_s_tuner,\n\t.vidioc_g_tuner\t\t\t    = pvr2_g_tuner,\n\t.vidioc_g_std\t\t\t    = pvr2_g_std,\n\t.vidioc_s_std\t\t\t    = pvr2_s_std,\n\t.vidioc_querystd\t\t    = pvr2_querystd,\n\t.vidioc_log_status\t\t    = pvr2_log_status,\n\t.vidioc_enum_fmt_vid_cap\t    = pvr2_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t\t    = pvr2_g_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t    = pvr2_s_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t\t    = pvr2_try_fmt_vid_cap,\n\t.vidioc_streamon\t\t    = pvr2_streamon,\n\t.vidioc_streamoff\t\t    = pvr2_streamoff,\n\t.vidioc_queryctrl\t\t    = pvr2_queryctrl,\n\t.vidioc_querymenu\t\t    = pvr2_querymenu,\n\t.vidioc_g_ctrl\t\t\t    = pvr2_g_ctrl,\n\t.vidioc_s_ctrl\t\t\t    = pvr2_s_ctrl,\n\t.vidioc_g_ext_ctrls\t\t    = pvr2_g_ext_ctrls,\n\t.vidioc_s_ext_ctrls\t\t    = pvr2_s_ext_ctrls,\n\t.vidioc_try_ext_ctrls\t\t    = pvr2_try_ext_ctrls,\n};\n\nstatic void pvr2_v4l2_dev_destroy(struct pvr2_v4l2_dev *dip)\n{\n\tstruct pvr2_hdw *hdw = dip->v4lp->channel.mc_head->hdw;\n\tenum pvr2_config cfg = dip->config;\n\tchar msg[80];\n\tunsigned int mcnt;\n\n\t \n\tmcnt = scnprintf(msg, sizeof(msg) - 1,\n\t\t\t \"pvrusb2: unregistered device %s [%s]\",\n\t\t\t video_device_node_name(&dip->devbase),\n\t\t\t pvr2_config_get_name(cfg));\n\tmsg[mcnt] = 0;\n\n\tpvr2_hdw_v4l_store_minor_number(hdw,dip->minor_type,-1);\n\n\t \n\tdip->v4lp = NULL;\n\tdip->stream = NULL;\n\n\t \n\tvideo_unregister_device(&dip->devbase);\n\n\tpr_info(\"%s\\n\", msg);\n\n}\n\n\nstatic void pvr2_v4l2_dev_disassociate_parent(struct pvr2_v4l2_dev *dip)\n{\n\tif (!dip) return;\n\tif (!dip->devbase.v4l2_dev->dev) return;\n\tdip->devbase.v4l2_dev->dev = NULL;\n\tdevice_move(&dip->devbase.dev, NULL, DPM_ORDER_NONE);\n}\n\n\nstatic void pvr2_v4l2_destroy_no_lock(struct pvr2_v4l2 *vp)\n{\n\tif (vp->dev_video) {\n\t\tpvr2_v4l2_dev_destroy(vp->dev_video);\n\t\tvp->dev_video = NULL;\n\t}\n\tif (vp->dev_radio) {\n\t\tpvr2_v4l2_dev_destroy(vp->dev_radio);\n\t\tvp->dev_radio = NULL;\n\t}\n\n\tpvr2_trace(PVR2_TRACE_STRUCT,\"Destroying pvr2_v4l2 id=%p\",vp);\n\tpvr2_channel_done(&vp->channel);\n\tkfree(vp);\n}\n\n\nstatic void pvr2_video_device_release(struct video_device *vdev)\n{\n\tstruct pvr2_v4l2_dev *dev;\n\tdev = container_of(vdev,struct pvr2_v4l2_dev,devbase);\n\tkfree(dev);\n}\n\n\nstatic void pvr2_v4l2_internal_check(struct pvr2_channel *chp)\n{\n\tstruct pvr2_v4l2 *vp;\n\tvp = container_of(chp,struct pvr2_v4l2,channel);\n\tif (!vp->channel.mc_head->disconnect_flag) return;\n\tpvr2_v4l2_dev_disassociate_parent(vp->dev_video);\n\tpvr2_v4l2_dev_disassociate_parent(vp->dev_radio);\n\tif (!list_empty(&vp->dev_video->devbase.fh_list) ||\n\t    (vp->dev_radio &&\n\t     !list_empty(&vp->dev_radio->devbase.fh_list))) {\n\t\tpvr2_trace(PVR2_TRACE_STRUCT,\n\t\t\t   \"pvr2_v4l2 internal_check exit-empty id=%p\", vp);\n\t\treturn;\n\t}\n\tpvr2_v4l2_destroy_no_lock(vp);\n}\n\n\nstatic int pvr2_v4l2_release(struct file *file)\n{\n\tstruct pvr2_v4l2_fh *fhp = file->private_data;\n\tstruct pvr2_v4l2 *vp = fhp->pdi->v4lp;\n\tstruct pvr2_hdw *hdw = fhp->channel.mc_head->hdw;\n\n\tpvr2_trace(PVR2_TRACE_OPEN_CLOSE,\"pvr2_v4l2_release\");\n\n\tif (fhp->rhp) {\n\t\tstruct pvr2_stream *sp;\n\t\tpvr2_hdw_set_streaming(hdw,0);\n\t\tsp = pvr2_ioread_get_stream(fhp->rhp);\n\t\tif (sp) pvr2_stream_set_callback(sp,NULL,NULL);\n\t\tpvr2_ioread_destroy(fhp->rhp);\n\t\tfhp->rhp = NULL;\n\t}\n\n\tv4l2_fh_del(&fhp->fh);\n\tv4l2_fh_exit(&fhp->fh);\n\tfile->private_data = NULL;\n\n\tpvr2_channel_done(&fhp->channel);\n\tpvr2_trace(PVR2_TRACE_STRUCT,\n\t\t   \"Destroying pvr_v4l2_fh id=%p\",fhp);\n\tif (fhp->input_map) {\n\t\tkfree(fhp->input_map);\n\t\tfhp->input_map = NULL;\n\t}\n\tkfree(fhp);\n\tif (vp->channel.mc_head->disconnect_flag &&\n\t    list_empty(&vp->dev_video->devbase.fh_list) &&\n\t    (!vp->dev_radio ||\n\t     list_empty(&vp->dev_radio->devbase.fh_list))) {\n\t\tpvr2_v4l2_destroy_no_lock(vp);\n\t}\n\treturn 0;\n}\n\n\nstatic int pvr2_v4l2_open(struct file *file)\n{\n\tstruct pvr2_v4l2_dev *dip;  \n\tstruct pvr2_v4l2_fh *fhp;\n\tstruct pvr2_v4l2 *vp;\n\tstruct pvr2_hdw *hdw;\n\tunsigned int input_mask = 0;\n\tunsigned int input_cnt,idx;\n\tint ret = 0;\n\n\tdip = container_of(video_devdata(file),struct pvr2_v4l2_dev,devbase);\n\n\tvp = dip->v4lp;\n\thdw = vp->channel.hdw;\n\n\tpvr2_trace(PVR2_TRACE_OPEN_CLOSE,\"pvr2_v4l2_open\");\n\n\tif (!pvr2_hdw_dev_ok(hdw)) {\n\t\tpvr2_trace(PVR2_TRACE_OPEN_CLOSE,\n\t\t\t   \"pvr2_v4l2_open: hardware not ready\");\n\t\treturn -EIO;\n\t}\n\n\tfhp = kzalloc(sizeof(*fhp),GFP_KERNEL);\n\tif (!fhp) {\n\t\treturn -ENOMEM;\n\t}\n\n\tv4l2_fh_init(&fhp->fh, &dip->devbase);\n\tinit_waitqueue_head(&fhp->wait_data);\n\tfhp->pdi = dip;\n\n\tpvr2_trace(PVR2_TRACE_STRUCT,\"Creating pvr_v4l2_fh id=%p\",fhp);\n\tpvr2_channel_init(&fhp->channel,vp->channel.mc_head);\n\n\tif (dip->v4l_type == VFL_TYPE_RADIO) {\n\t\t \n\t\tinput_mask = (1 << PVR2_CVAL_INPUT_RADIO);\n\t} else {\n\t\t \n\t\tinput_mask = ((1 << PVR2_CVAL_INPUT_RADIO) |\n\t\t\t      (1 << PVR2_CVAL_INPUT_TV) |\n\t\t\t      (1 << PVR2_CVAL_INPUT_COMPOSITE) |\n\t\t\t      (1 << PVR2_CVAL_INPUT_SVIDEO));\n\t}\n\tret = pvr2_channel_limit_inputs(&fhp->channel,input_mask);\n\tif (ret) {\n\t\tpvr2_channel_done(&fhp->channel);\n\t\tpvr2_trace(PVR2_TRACE_STRUCT,\n\t\t\t   \"Destroying pvr_v4l2_fh id=%p (input mask error)\",\n\t\t\t   fhp);\n\t\tv4l2_fh_exit(&fhp->fh);\n\t\tkfree(fhp);\n\t\treturn ret;\n\t}\n\n\tinput_mask &= pvr2_hdw_get_input_available(hdw);\n\tinput_cnt = 0;\n\tfor (idx = 0; idx < (sizeof(input_mask) << 3); idx++) {\n\t\tif (input_mask & (1UL << idx)) input_cnt++;\n\t}\n\tfhp->input_cnt = input_cnt;\n\tfhp->input_map = kzalloc(input_cnt,GFP_KERNEL);\n\tif (!fhp->input_map) {\n\t\tpvr2_channel_done(&fhp->channel);\n\t\tpvr2_trace(PVR2_TRACE_STRUCT,\n\t\t\t   \"Destroying pvr_v4l2_fh id=%p (input map failure)\",\n\t\t\t   fhp);\n\t\tv4l2_fh_exit(&fhp->fh);\n\t\tkfree(fhp);\n\t\treturn -ENOMEM;\n\t}\n\tinput_cnt = 0;\n\tfor (idx = 0; idx < (sizeof(input_mask) << 3); idx++) {\n\t\tif (!(input_mask & (1UL << idx))) continue;\n\t\tfhp->input_map[input_cnt++] = idx;\n\t}\n\n\tfhp->file = file;\n\tfile->private_data = fhp;\n\n\tfhp->fw_mode_flag = pvr2_hdw_cpufw_get_enabled(hdw);\n\tv4l2_fh_add(&fhp->fh);\n\n\treturn 0;\n}\n\n\nstatic void pvr2_v4l2_notify(struct pvr2_v4l2_fh *fhp)\n{\n\twake_up(&fhp->wait_data);\n}\n\nstatic int pvr2_v4l2_iosetup(struct pvr2_v4l2_fh *fh)\n{\n\tint ret;\n\tstruct pvr2_stream *sp;\n\tstruct pvr2_hdw *hdw;\n\tif (fh->rhp) return 0;\n\n\tif (!fh->pdi->stream) {\n\t\t \n\t\treturn -EPERM;\n\t}\n\n\t \n\tif ((ret = pvr2_channel_claim_stream(&fh->channel,\n\t\t\t\t\t     fh->pdi->stream)) != 0) {\n\t\t \n\t\treturn ret;\n\t}\n\n\tfh->rhp = pvr2_channel_create_mpeg_stream(fh->pdi->stream);\n\tif (!fh->rhp) {\n\t\tpvr2_channel_claim_stream(&fh->channel,NULL);\n\t\treturn -ENOMEM;\n\t}\n\n\thdw = fh->channel.mc_head->hdw;\n\tsp = fh->pdi->stream->stream;\n\tpvr2_stream_set_callback(sp,(pvr2_stream_callback)pvr2_v4l2_notify,fh);\n\tpvr2_hdw_set_stream_type(hdw,fh->pdi->config);\n\tif ((ret = pvr2_hdw_set_streaming(hdw,!0)) < 0) return ret;\n\treturn pvr2_ioread_set_enabled(fh->rhp,!0);\n}\n\n\nstatic ssize_t pvr2_v4l2_read(struct file *file,\n\t\t\t      char __user *buff, size_t count, loff_t *ppos)\n{\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tint ret;\n\n\tif (fh->fw_mode_flag) {\n\t\tstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\n\t\tchar *tbuf;\n\t\tint c1,c2;\n\t\tint tcnt = 0;\n\t\tunsigned int offs = *ppos;\n\n\t\ttbuf = kmalloc(PAGE_SIZE,GFP_KERNEL);\n\t\tif (!tbuf) return -ENOMEM;\n\n\t\twhile (count) {\n\t\t\tc1 = count;\n\t\t\tif (c1 > PAGE_SIZE) c1 = PAGE_SIZE;\n\t\t\tc2 = pvr2_hdw_cpufw_get(hdw,offs,tbuf,c1);\n\t\t\tif (c2 < 0) {\n\t\t\t\ttcnt = c2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!c2) break;\n\t\t\tif (copy_to_user(buff,tbuf,c2)) {\n\t\t\t\ttcnt = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toffs += c2;\n\t\t\ttcnt += c2;\n\t\t\tbuff += c2;\n\t\t\tcount -= c2;\n\t\t\t*ppos += c2;\n\t\t}\n\t\tkfree(tbuf);\n\t\treturn tcnt;\n\t}\n\n\tif (!fh->rhp) {\n\t\tret = pvr2_v4l2_iosetup(fh);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\tret = pvr2_ioread_read(fh->rhp,buff,count);\n\t\tif (ret >= 0) break;\n\t\tif (ret != -EAGAIN) break;\n\t\tif (file->f_flags & O_NONBLOCK) break;\n\t\t \n\t\tret = wait_event_interruptible(\n\t\t\tfh->wait_data,\n\t\t\tpvr2_ioread_avail(fh->rhp) >= 0);\n\t\tif (ret < 0) break;\n\t}\n\n\treturn ret;\n}\n\n\nstatic __poll_t pvr2_v4l2_poll(struct file *file, poll_table *wait)\n{\n\t__poll_t mask = 0;\n\tstruct pvr2_v4l2_fh *fh = file->private_data;\n\tint ret;\n\n\tif (fh->fw_mode_flag) {\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\t\treturn mask;\n\t}\n\n\tif (!fh->rhp) {\n\t\tret = pvr2_v4l2_iosetup(fh);\n\t\tif (ret) return EPOLLERR;\n\t}\n\n\tpoll_wait(file,&fh->wait_data,wait);\n\n\tif (pvr2_ioread_avail(fh->rhp) >= 0) {\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\t}\n\n\treturn mask;\n}\n\n\nstatic const struct v4l2_file_operations vdev_fops = {\n\t.owner      = THIS_MODULE,\n\t.open       = pvr2_v4l2_open,\n\t.release    = pvr2_v4l2_release,\n\t.read       = pvr2_v4l2_read,\n\t.unlocked_ioctl = video_ioctl2,\n\t.poll       = pvr2_v4l2_poll,\n};\n\n\nstatic const struct video_device vdev_template = {\n\t.fops       = &vdev_fops,\n};\n\n\nstatic void pvr2_v4l2_dev_init(struct pvr2_v4l2_dev *dip,\n\t\t\t       struct pvr2_v4l2 *vp,\n\t\t\t       int v4l_type)\n{\n\tint mindevnum;\n\tint unit_number;\n\tstruct pvr2_hdw *hdw;\n\tint *nr_ptr = NULL;\n\tu32 caps = V4L2_CAP_TUNER | V4L2_CAP_READWRITE;\n\n\tdip->v4lp = vp;\n\n\thdw = vp->channel.mc_head->hdw;\n\tdip->v4l_type = v4l_type;\n\tswitch (v4l_type) {\n\tcase VFL_TYPE_VIDEO:\n\t\tdip->stream = &vp->channel.mc_head->video_stream;\n\t\tdip->config = pvr2_config_mpeg;\n\t\tdip->minor_type = pvr2_v4l_type_video;\n\t\tnr_ptr = video_nr;\n\t\tcaps |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_AUDIO;\n\t\tif (!dip->stream) {\n\t\t\tpr_err(KBUILD_MODNAME\n\t\t\t\t\": Failed to set up pvrusb2 v4l video dev due to missing stream instance\\n\");\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase VFL_TYPE_VBI:\n\t\tdip->config = pvr2_config_vbi;\n\t\tdip->minor_type = pvr2_v4l_type_vbi;\n\t\tnr_ptr = vbi_nr;\n\t\tcaps |= V4L2_CAP_VBI_CAPTURE;\n\t\tbreak;\n\tcase VFL_TYPE_RADIO:\n\t\tdip->stream = &vp->channel.mc_head->video_stream;\n\t\tdip->config = pvr2_config_mpeg;\n\t\tdip->minor_type = pvr2_v4l_type_radio;\n\t\tnr_ptr = radio_nr;\n\t\tcaps |= V4L2_CAP_RADIO;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tpr_err(KBUILD_MODNAME \": Failed to set up pvrusb2 v4l dev due to unrecognized config\\n\");\n\t\treturn;\n\t}\n\n\tdip->devbase = vdev_template;\n\tdip->devbase.release = pvr2_video_device_release;\n\tdip->devbase.ioctl_ops = &pvr2_ioctl_ops;\n\tdip->devbase.device_caps = caps;\n\t{\n\t\tint val;\n\t\tpvr2_ctrl_get_value(\n\t\t\tpvr2_hdw_get_ctrl_by_id(hdw,\n\t\t\t\t\t\tPVR2_CID_STDAVAIL), &val);\n\t\tdip->devbase.tvnorms = (v4l2_std_id)val;\n\t}\n\n\tmindevnum = -1;\n\tunit_number = pvr2_hdw_get_unit_number(hdw);\n\tif (nr_ptr && (unit_number >= 0) && (unit_number < PVR_NUM)) {\n\t\tmindevnum = nr_ptr[unit_number];\n\t}\n\tpvr2_hdw_set_v4l2_dev(hdw, &dip->devbase);\n\tif ((video_register_device(&dip->devbase,\n\t\t\t\t   dip->v4l_type, mindevnum) < 0) &&\n\t    (video_register_device(&dip->devbase,\n\t\t\t\t   dip->v4l_type, -1) < 0)) {\n\t\tpr_err(KBUILD_MODNAME\n\t\t\t\": Failed to register pvrusb2 v4l device\\n\");\n\t}\n\n\tpr_info(\"pvrusb2: registered device %s [%s]\\n\",\n\t       video_device_node_name(&dip->devbase),\n\t       pvr2_config_get_name(dip->config));\n\n\tpvr2_hdw_v4l_store_minor_number(hdw,\n\t\t\t\t\tdip->minor_type,dip->devbase.minor);\n}\n\n\nstruct pvr2_v4l2 *pvr2_v4l2_create(struct pvr2_context *mnp)\n{\n\tstruct pvr2_v4l2 *vp;\n\n\tvp = kzalloc(sizeof(*vp),GFP_KERNEL);\n\tif (!vp) return vp;\n\tpvr2_channel_init(&vp->channel,mnp);\n\tpvr2_trace(PVR2_TRACE_STRUCT,\"Creating pvr2_v4l2 id=%p\",vp);\n\n\tvp->channel.check_func = pvr2_v4l2_internal_check;\n\n\t \n\tvp->dev_video = kzalloc(sizeof(*vp->dev_video),GFP_KERNEL);\n\tif (!vp->dev_video) goto fail;\n\tpvr2_v4l2_dev_init(vp->dev_video,vp,VFL_TYPE_VIDEO);\n\tif (pvr2_hdw_get_input_available(vp->channel.mc_head->hdw) &\n\t    (1 << PVR2_CVAL_INPUT_RADIO)) {\n\t\tvp->dev_radio = kzalloc(sizeof(*vp->dev_radio),GFP_KERNEL);\n\t\tif (!vp->dev_radio) goto fail;\n\t\tpvr2_v4l2_dev_init(vp->dev_radio,vp,VFL_TYPE_RADIO);\n\t}\n\n\treturn vp;\n fail:\n\tpvr2_trace(PVR2_TRACE_STRUCT,\"Failure creating pvr2_v4l2 id=%p\",vp);\n\tpvr2_v4l2_destroy_no_lock(vp);\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}