{
  "module_name": "pvrusb2-ioread.c",
  "hash_id": "d522d42769755db6a308e29aa18e8ae92f64cb698455296e85d2d19ea94f4587",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/pvrusb2/pvrusb2-ioread.c",
  "human_readable_source": "\n \n\n#include \"pvrusb2-ioread.h\"\n#include \"pvrusb2-debug.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n\n#define BUFFER_COUNT 32\n#define BUFFER_SIZE PAGE_ALIGN(0x4000)\n\nstruct pvr2_ioread {\n\tstruct pvr2_stream *stream;\n\tchar *buffer_storage[BUFFER_COUNT];\n\tchar *sync_key_ptr;\n\tunsigned int sync_key_len;\n\tunsigned int sync_buf_offs;\n\tunsigned int sync_state;\n\tunsigned int sync_trashed_count;\n\tint enabled;         \n\tint spigot_open;     \n\tint stream_running;  \n\n\t \n\tstruct pvr2_buffer *c_buf;\n\tchar *c_data_ptr;\n\tunsigned int c_data_len;\n\tunsigned int c_data_offs;\n\tstruct mutex mutex;\n};\n\nstatic int pvr2_ioread_init(struct pvr2_ioread *cp)\n{\n\tunsigned int idx;\n\n\tcp->stream = NULL;\n\tmutex_init(&cp->mutex);\n\n\tfor (idx = 0; idx < BUFFER_COUNT; idx++) {\n\t\tcp->buffer_storage[idx] = kmalloc(BUFFER_SIZE,GFP_KERNEL);\n\t\tif (!(cp->buffer_storage[idx])) break;\n\t}\n\n\tif (idx < BUFFER_COUNT) {\n\t\t\n\t\tfor (idx = 0; idx < BUFFER_COUNT; idx++) {\n\t\t\tif (!(cp->buffer_storage[idx])) continue;\n\t\t\tkfree(cp->buffer_storage[idx]);\n\t\t}\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic void pvr2_ioread_done(struct pvr2_ioread *cp)\n{\n\tunsigned int idx;\n\n\tpvr2_ioread_setup(cp,NULL);\n\tfor (idx = 0; idx < BUFFER_COUNT; idx++) {\n\t\tif (!(cp->buffer_storage[idx])) continue;\n\t\tkfree(cp->buffer_storage[idx]);\n\t}\n}\n\nstruct pvr2_ioread *pvr2_ioread_create(void)\n{\n\tstruct pvr2_ioread *cp;\n\tcp = kzalloc(sizeof(*cp),GFP_KERNEL);\n\tif (!cp) return NULL;\n\tpvr2_trace(PVR2_TRACE_STRUCT,\"pvr2_ioread_create id=%p\",cp);\n\tif (pvr2_ioread_init(cp) < 0) {\n\t\tkfree(cp);\n\t\treturn NULL;\n\t}\n\treturn cp;\n}\n\nvoid pvr2_ioread_destroy(struct pvr2_ioread *cp)\n{\n\tif (!cp) return;\n\tpvr2_ioread_done(cp);\n\tpvr2_trace(PVR2_TRACE_STRUCT,\"pvr2_ioread_destroy id=%p\",cp);\n\tif (cp->sync_key_ptr) {\n\t\tkfree(cp->sync_key_ptr);\n\t\tcp->sync_key_ptr = NULL;\n\t}\n\tkfree(cp);\n}\n\nvoid pvr2_ioread_set_sync_key(struct pvr2_ioread *cp,\n\t\t\t      const char *sync_key_ptr,\n\t\t\t      unsigned int sync_key_len)\n{\n\tif (!cp) return;\n\n\tif (!sync_key_ptr) sync_key_len = 0;\n\tif ((sync_key_len == cp->sync_key_len) &&\n\t    ((!sync_key_len) ||\n\t     (!memcmp(sync_key_ptr,cp->sync_key_ptr,sync_key_len)))) return;\n\n\tif (sync_key_len != cp->sync_key_len) {\n\t\tif (cp->sync_key_ptr) {\n\t\t\tkfree(cp->sync_key_ptr);\n\t\t\tcp->sync_key_ptr = NULL;\n\t\t}\n\t\tcp->sync_key_len = 0;\n\t\tif (sync_key_len) {\n\t\t\tcp->sync_key_ptr = kmalloc(sync_key_len,GFP_KERNEL);\n\t\t\tif (cp->sync_key_ptr) {\n\t\t\t\tcp->sync_key_len = sync_key_len;\n\t\t\t}\n\t\t}\n\t}\n\tif (!cp->sync_key_len) return;\n\tmemcpy(cp->sync_key_ptr,sync_key_ptr,cp->sync_key_len);\n}\n\nstatic void pvr2_ioread_stop(struct pvr2_ioread *cp)\n{\n\tif (!(cp->enabled)) return;\n\tpvr2_trace(PVR2_TRACE_START_STOP,\n\t\t   \"/*---TRACE_READ---*/ pvr2_ioread_stop id=%p\",cp);\n\tpvr2_stream_kill(cp->stream);\n\tcp->c_buf = NULL;\n\tcp->c_data_ptr = NULL;\n\tcp->c_data_len = 0;\n\tcp->c_data_offs = 0;\n\tcp->enabled = 0;\n\tcp->stream_running = 0;\n\tcp->spigot_open = 0;\n\tif (cp->sync_state) {\n\t\tpvr2_trace(PVR2_TRACE_DATA_FLOW,\n\t\t\t   \"/*---TRACE_READ---*/ sync_state <== 0\");\n\t\tcp->sync_state = 0;\n\t}\n}\n\nstatic int pvr2_ioread_start(struct pvr2_ioread *cp)\n{\n\tint stat;\n\tstruct pvr2_buffer *bp;\n\tif (cp->enabled) return 0;\n\tif (!(cp->stream)) return 0;\n\tpvr2_trace(PVR2_TRACE_START_STOP,\n\t\t   \"/*---TRACE_READ---*/ pvr2_ioread_start id=%p\",cp);\n\twhile ((bp = pvr2_stream_get_idle_buffer(cp->stream)) != NULL) {\n\t\tstat = pvr2_buffer_queue(bp);\n\t\tif (stat < 0) {\n\t\t\tpvr2_trace(PVR2_TRACE_DATA_FLOW,\n\t\t\t\t   \"/*---TRACE_READ---*/ pvr2_ioread_start id=%p error=%d\",\n\t\t\t\t   cp,stat);\n\t\t\tpvr2_ioread_stop(cp);\n\t\t\treturn stat;\n\t\t}\n\t}\n\tcp->enabled = !0;\n\tcp->c_buf = NULL;\n\tcp->c_data_ptr = NULL;\n\tcp->c_data_len = 0;\n\tcp->c_data_offs = 0;\n\tcp->stream_running = 0;\n\tif (cp->sync_key_len) {\n\t\tpvr2_trace(PVR2_TRACE_DATA_FLOW,\n\t\t\t   \"/*---TRACE_READ---*/ sync_state <== 1\");\n\t\tcp->sync_state = 1;\n\t\tcp->sync_trashed_count = 0;\n\t\tcp->sync_buf_offs = 0;\n\t}\n\tcp->spigot_open = 0;\n\treturn 0;\n}\n\nstruct pvr2_stream *pvr2_ioread_get_stream(struct pvr2_ioread *cp)\n{\n\treturn cp->stream;\n}\n\nint pvr2_ioread_setup(struct pvr2_ioread *cp,struct pvr2_stream *sp)\n{\n\tint ret;\n\tunsigned int idx;\n\tstruct pvr2_buffer *bp;\n\n\tmutex_lock(&cp->mutex);\n\tdo {\n\t\tif (cp->stream) {\n\t\t\tpvr2_trace(PVR2_TRACE_START_STOP,\n\t\t\t\t   \"/*---TRACE_READ---*/ pvr2_ioread_setup (tear-down) id=%p\",\n\t\t\t\t   cp);\n\t\t\tpvr2_ioread_stop(cp);\n\t\t\tpvr2_stream_kill(cp->stream);\n\t\t\tif (pvr2_stream_get_buffer_count(cp->stream)) {\n\t\t\t\tpvr2_stream_set_buffer_count(cp->stream,0);\n\t\t\t}\n\t\t\tcp->stream = NULL;\n\t\t}\n\t\tif (sp) {\n\t\t\tpvr2_trace(PVR2_TRACE_START_STOP,\n\t\t\t\t   \"/*---TRACE_READ---*/ pvr2_ioread_setup (setup) id=%p\",\n\t\t\t\t   cp);\n\t\t\tpvr2_stream_kill(sp);\n\t\t\tret = pvr2_stream_set_buffer_count(sp,BUFFER_COUNT);\n\t\t\tif (ret < 0) {\n\t\t\t\tmutex_unlock(&cp->mutex);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tfor (idx = 0; idx < BUFFER_COUNT; idx++) {\n\t\t\t\tbp = pvr2_stream_get_buffer(sp,idx);\n\t\t\t\tpvr2_buffer_set_buffer(bp,\n\t\t\t\t\t\t       cp->buffer_storage[idx],\n\t\t\t\t\t\t       BUFFER_SIZE);\n\t\t\t}\n\t\t\tcp->stream = sp;\n\t\t}\n\t} while (0);\n\tmutex_unlock(&cp->mutex);\n\n\treturn 0;\n}\n\nint pvr2_ioread_set_enabled(struct pvr2_ioread *cp,int fl)\n{\n\tint ret = 0;\n\tif ((!fl) == (!(cp->enabled))) return ret;\n\n\tmutex_lock(&cp->mutex);\n\tdo {\n\t\tif (fl) {\n\t\t\tret = pvr2_ioread_start(cp);\n\t\t} else {\n\t\t\tpvr2_ioread_stop(cp);\n\t\t}\n\t} while (0);\n\tmutex_unlock(&cp->mutex);\n\treturn ret;\n}\n\nstatic int pvr2_ioread_get_buffer(struct pvr2_ioread *cp)\n{\n\tint stat;\n\n\twhile (cp->c_data_len <= cp->c_data_offs) {\n\t\tif (cp->c_buf) {\n\t\t\t\n\t\t\tstat = pvr2_buffer_queue(cp->c_buf);\n\t\t\tif (stat < 0) {\n\t\t\t\t\n\t\t\t\tpvr2_trace(PVR2_TRACE_DATA_FLOW,\n\t\t\t\t\t   \"/*---TRACE_READ---*/ pvr2_ioread_read id=%p queue_error=%d\",\n\t\t\t\t\t   cp,stat);\n\t\t\t\tpvr2_ioread_stop(cp);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcp->c_buf = NULL;\n\t\t\tcp->c_data_ptr = NULL;\n\t\t\tcp->c_data_len = 0;\n\t\t\tcp->c_data_offs = 0;\n\t\t}\n\t\t\n\t\tcp->c_buf = pvr2_stream_get_ready_buffer(cp->stream);\n\t\tif (!cp->c_buf) break; \n\t\tcp->c_data_len = pvr2_buffer_get_count(cp->c_buf);\n\t\tif (!cp->c_data_len) {\n\t\t\t\n\t\t\tstat = pvr2_buffer_get_status(cp->c_buf);\n\t\t\tif (stat < 0) {\n\t\t\t\t\n\t\t\t\tpvr2_trace(PVR2_TRACE_DATA_FLOW,\n\t\t\t\t\t   \"/*---TRACE_READ---*/ pvr2_ioread_read id=%p buffer_error=%d\",\n\t\t\t\t\t   cp,stat);\n\t\t\t\tpvr2_ioread_stop(cp);\n\t\t\t\t\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tcontinue;\n\t\t}\n\t\tcp->c_data_offs = 0;\n\t\tcp->c_data_ptr = cp->buffer_storage[\n\t\t\tpvr2_buffer_get_id(cp->c_buf)];\n\t}\n\treturn !0;\n}\n\nstatic void pvr2_ioread_filter(struct pvr2_ioread *cp)\n{\n\tunsigned int idx;\n\tif (!cp->enabled) return;\n\tif (cp->sync_state != 1) return;\n\n\t\n\t\n\t\n\tmutex_lock(&cp->mutex);\n\twhile (1) {\n\t\t\n\t\tif (!pvr2_ioread_get_buffer(cp)) break;\n\t\tif (!cp->c_data_len) break;\n\n\t\t\n\t\t\n\t\tfor (idx = cp->c_data_offs; idx < cp->c_data_len; idx++) {\n\t\t\tif (cp->sync_buf_offs >= cp->sync_key_len) break;\n\t\t\tif (cp->c_data_ptr[idx] ==\n\t\t\t    cp->sync_key_ptr[cp->sync_buf_offs]) {\n\t\t\t\t\n\t\t\t\t(cp->sync_buf_offs)++;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tcp->sync_buf_offs = 0;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tcp->c_data_offs += idx;\n\t\tcp->sync_trashed_count += idx;\n\n\t\t\n\t\tif (cp->sync_buf_offs >= cp->sync_key_len) {\n\t\t\tcp->sync_trashed_count -= cp->sync_key_len;\n\t\t\tpvr2_trace(PVR2_TRACE_DATA_FLOW,\n\t\t\t\t   \"/*---TRACE_READ---*/ sync_state <== 2 (skipped %u bytes)\",\n\t\t\t\t   cp->sync_trashed_count);\n\t\t\tcp->sync_state = 2;\n\t\t\tcp->sync_buf_offs = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cp->c_data_offs < cp->c_data_len) {\n\t\t\t\n\t\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t\t   \"ERROR: pvr2_ioread filter sync problem len=%u offs=%u\",\n\t\t\t\t   cp->c_data_len,cp->c_data_offs);\n\t\t\t\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\n\t\tcontinue; \n\t}\n\tmutex_unlock(&cp->mutex);\n}\n\nint pvr2_ioread_avail(struct pvr2_ioread *cp)\n{\n\tint ret;\n\tif (!(cp->enabled)) {\n\t\t\n\t\treturn -EIO;\n\t}\n\n\tif (cp->sync_state == 1) {\n\t\tpvr2_ioread_filter(cp);\n\t\tif (cp->sync_state == 1) return -EAGAIN;\n\t}\n\n\tret = 0;\n\tif (cp->stream_running) {\n\t\tif (!pvr2_stream_get_ready_count(cp->stream)) {\n\t\t\t\n\t\t\tret = -EAGAIN;\n\t\t}\n\t} else {\n\t\tif (pvr2_stream_get_ready_count(cp->stream) < BUFFER_COUNT/2) {\n\t\t\t\n\t\t\tret = -EAGAIN;\n\t\t}\n\t}\n\n\tif ((!(cp->spigot_open)) != (!(ret == 0))) {\n\t\tcp->spigot_open = (ret == 0);\n\t\tpvr2_trace(PVR2_TRACE_DATA_FLOW,\n\t\t\t   \"/*---TRACE_READ---*/ data is %s\",\n\t\t\t   cp->spigot_open ? \"available\" : \"pending\");\n\t}\n\n\treturn ret;\n}\n\nint pvr2_ioread_read(struct pvr2_ioread *cp,void __user *buf,unsigned int cnt)\n{\n\tunsigned int copied_cnt;\n\tunsigned int bcnt;\n\tconst char *src;\n\tint stat;\n\tint ret = 0;\n\tunsigned int req_cnt = cnt;\n\n\tif (!cnt) {\n\t\tpvr2_trace(PVR2_TRACE_TRAP,\n\t\t\t   \"/*---TRACE_READ---*/ pvr2_ioread_read id=%p ZERO Request? Returning zero.\",\ncp);\n\t\treturn 0;\n\t}\n\n\tstat = pvr2_ioread_avail(cp);\n\tif (stat < 0) return stat;\n\n\tcp->stream_running = !0;\n\n\tmutex_lock(&cp->mutex);\n\tdo {\n\n\t\t\n\t\tcopied_cnt = 0;\n\t\tif (!buf) cnt = 0;\n\t\twhile (1) {\n\t\t\tif (!pvr2_ioread_get_buffer(cp)) {\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!cnt) break;\n\n\t\t\tif (cp->sync_state == 2) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tsrc = cp->sync_key_ptr + cp->sync_buf_offs;\n\t\t\t\tbcnt = cp->sync_key_len - cp->sync_buf_offs;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tsrc = cp->c_data_ptr + cp->c_data_offs;\n\t\t\t\tbcnt = cp->c_data_len - cp->c_data_offs;\n\t\t\t}\n\n\t\t\tif (!bcnt) break;\n\n\t\t\t\n\t\t\tif (bcnt > cnt) bcnt = cnt;\n\n\t\t\tif (copy_to_user(buf,src,bcnt)) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt -= bcnt;\n\t\t\tbuf += bcnt;\n\t\t\tcopied_cnt += bcnt;\n\n\t\t\tif (cp->sync_state == 2) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tcp->sync_buf_offs += bcnt;\n\t\t\t\tif (cp->sync_buf_offs >= cp->sync_key_len) {\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tpvr2_trace(PVR2_TRACE_DATA_FLOW,\n\t\t\t\t\t\t   \"/*---TRACE_READ---*/ sync_state <== 0\");\n\t\t\t\t\tcp->sync_state = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tcp->c_data_offs += bcnt;\n\t\t\t}\n\t\t}\n\n\t} while (0);\n\tmutex_unlock(&cp->mutex);\n\n\tif (!ret) {\n\t\tif (copied_cnt) {\n\t\t\t\n\t\t\tret = copied_cnt;\n\t\t} else {\n\t\t\t\n\t\t\t\n\t\t\tret = -EAGAIN;\n\t\t}\n\t}\n\n\tpvr2_trace(PVR2_TRACE_DATA_FLOW,\n\t\t   \"/*---TRACE_READ---*/ pvr2_ioread_read id=%p request=%d result=%d\",\n\t\t   cp,req_cnt,ret);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}