{
  "module_name": "pvrusb2-encoder.c",
  "hash_id": "a38fa2bd9dd794d769fc009a5a2d05984e7baaa675d8026acc503110025485ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/pvrusb2/pvrusb2-encoder.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>   \n#include <linux/firmware.h>\n#include \"pvrusb2-util.h\"\n#include \"pvrusb2-encoder.h\"\n#include \"pvrusb2-hdw-internal.h\"\n#include \"pvrusb2-debug.h\"\n#include \"pvrusb2-fx2-cmd.h\"\n\n\n\n \n#define IVTV_MBOX_FIRMWARE_DONE 0x00000004\n#define IVTV_MBOX_DRIVER_DONE 0x00000002\n#define IVTV_MBOX_DRIVER_BUSY 0x00000001\n\n#define MBOX_BASE 0x44\n\n\nstatic int pvr2_encoder_write_words(struct pvr2_hdw *hdw,\n\t\t\t\t    unsigned int offs,\n\t\t\t\t    const u32 *data, unsigned int dlen)\n{\n\tunsigned int idx,addr;\n\tunsigned int bAddr;\n\tint ret;\n\tunsigned int chunkCnt;\n\n\t \n\twhile (dlen) {\n\t\tchunkCnt = 8;\n\t\tif (chunkCnt > dlen) chunkCnt = dlen;\n\t\tmemset(hdw->cmd_buffer,0,sizeof(hdw->cmd_buffer));\n\t\tbAddr = 0;\n\t\thdw->cmd_buffer[bAddr++] = FX2CMD_MEM_WRITE_DWORD;\n\t\tfor (idx = 0; idx < chunkCnt; idx++) {\n\t\t\taddr = idx + offs;\n\t\t\thdw->cmd_buffer[bAddr+6] = (addr & 0xffu);\n\t\t\thdw->cmd_buffer[bAddr+5] = ((addr>>8) & 0xffu);\n\t\t\thdw->cmd_buffer[bAddr+4] = ((addr>>16) & 0xffu);\n\t\t\tPVR2_DECOMPOSE_LE(hdw->cmd_buffer, bAddr,data[idx]);\n\t\t\tbAddr += 7;\n\t\t}\n\t\tret = pvr2_send_request(hdw,\n\t\t\t\t\thdw->cmd_buffer,1+(chunkCnt*7),\n\t\t\t\t\tNULL,0);\n\t\tif (ret) return ret;\n\t\tdata += chunkCnt;\n\t\tdlen -= chunkCnt;\n\t\toffs += chunkCnt;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int pvr2_encoder_read_words(struct pvr2_hdw *hdw,\n\t\t\t\t   unsigned int offs,\n\t\t\t\t   u32 *data, unsigned int dlen)\n{\n\tunsigned int idx;\n\tint ret;\n\tunsigned int chunkCnt;\n\n\t \n\n\twhile (dlen) {\n\t\tchunkCnt = 16;\n\t\tif (chunkCnt > dlen) chunkCnt = dlen;\n\t\tif (chunkCnt < 16) chunkCnt = 1;\n\t\thdw->cmd_buffer[0] =\n\t\t\t((chunkCnt == 1) ?\n\t\t\t FX2CMD_MEM_READ_DWORD : FX2CMD_MEM_READ_64BYTES);\n\t\thdw->cmd_buffer[1] = 0;\n\t\thdw->cmd_buffer[2] = 0;\n\t\thdw->cmd_buffer[3] = 0;\n\t\thdw->cmd_buffer[4] = 0;\n\t\thdw->cmd_buffer[5] = ((offs>>16) & 0xffu);\n\t\thdw->cmd_buffer[6] = ((offs>>8) & 0xffu);\n\t\thdw->cmd_buffer[7] = (offs & 0xffu);\n\t\tret = pvr2_send_request(hdw,\n\t\t\t\t\thdw->cmd_buffer,8,\n\t\t\t\t\thdw->cmd_buffer,\n\t\t\t\t\t(chunkCnt == 1 ? 4 : 16 * 4));\n\t\tif (ret) return ret;\n\n\t\tfor (idx = 0; idx < chunkCnt; idx++) {\n\t\t\tdata[idx] = PVR2_COMPOSE_LE(hdw->cmd_buffer,idx*4);\n\t\t}\n\t\tdata += chunkCnt;\n\t\tdlen -= chunkCnt;\n\t\toffs += chunkCnt;\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic int pvr2_encoder_cmd(void *ctxt,\n\t\t\t    u32 cmd,\n\t\t\t    int arg_cnt_send,\n\t\t\t    int arg_cnt_recv,\n\t\t\t    u32 *argp)\n{\n\tunsigned int poll_count;\n\tunsigned int try_count = 0;\n\tint retry_flag;\n\tint ret = 0;\n\tunsigned int idx;\n\t \n\tu32 wrData[16];\n\tu32 rdData[16];\n\tstruct pvr2_hdw *hdw = (struct pvr2_hdw *)ctxt;\n\n\n\t \n\n\tif (arg_cnt_send > (ARRAY_SIZE(wrData) - 4)) {\n\t\tpvr2_trace(\n\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\"Failed to write cx23416 command - too many input arguments (was given %u limit %lu)\",\n\t\t\targ_cnt_send, (long unsigned) ARRAY_SIZE(wrData) - 4);\n\t\treturn -EINVAL;\n\t}\n\n\tif (arg_cnt_recv > (ARRAY_SIZE(rdData) - 4)) {\n\t\tpvr2_trace(\n\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\"Failed to write cx23416 command - too many return arguments (was given %u limit %lu)\",\n\t\t\targ_cnt_recv, (long unsigned) ARRAY_SIZE(rdData) - 4);\n\t\treturn -EINVAL;\n\t}\n\n\n\tLOCK_TAKE(hdw->ctl_lock);\n\twhile (1) {\n\t\tif (!hdw->state_encoder_ok) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tretry_flag = 0;\n\t\ttry_count++;\n\t\tret = 0;\n\t\twrData[0] = 0;\n\t\twrData[1] = cmd;\n\t\twrData[2] = 0;\n\t\twrData[3] = 0x00060000;\n\t\tfor (idx = 0; idx < arg_cnt_send; idx++) {\n\t\t\twrData[idx+4] = argp[idx];\n\t\t}\n\t\tfor (; idx < ARRAY_SIZE(wrData) - 4; idx++) {\n\t\t\twrData[idx+4] = 0;\n\t\t}\n\n\t\tret = pvr2_encoder_write_words(hdw,MBOX_BASE,wrData,idx);\n\t\tif (ret) break;\n\t\twrData[0] = IVTV_MBOX_DRIVER_DONE|IVTV_MBOX_DRIVER_BUSY;\n\t\tret = pvr2_encoder_write_words(hdw,MBOX_BASE,wrData,1);\n\t\tif (ret) break;\n\t\tpoll_count = 0;\n\t\twhile (1) {\n\t\t\tpoll_count++;\n\t\t\tret = pvr2_encoder_read_words(hdw,MBOX_BASE,rdData,\n\t\t\t\t\t\t      arg_cnt_recv+4);\n\t\t\tif (ret) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rdData[0] & IVTV_MBOX_FIRMWARE_DONE) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rdData[0] && (poll_count < 1000)) continue;\n\t\t\tif (!rdData[0]) {\n\t\t\t\tretry_flag = !0;\n\t\t\t\tpvr2_trace(\n\t\t\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\t\"Encoder timed out waiting for us; arranging to retry\");\n\t\t\t} else {\n\t\t\t\tpvr2_trace(\n\t\t\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\t\"***WARNING*** device's encoder appears to be stuck (status=0x%08x)\",\nrdData[0]);\n\t\t\t}\n\t\t\tpvr2_trace(\n\t\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\"Encoder command: 0x%02x\",cmd);\n\t\t\tfor (idx = 4; idx < arg_cnt_send; idx++) {\n\t\t\t\tpvr2_trace(\n\t\t\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\t\"Encoder arg%d: 0x%08x\",\n\t\t\t\t\tidx-3,wrData[idx]);\n\t\t\t}\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t\tif (retry_flag) {\n\t\t\tif (try_count < 20) continue;\n\t\t\tpvr2_trace(\n\t\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\"Too many retries...\");\n\t\t\tret = -EBUSY;\n\t\t}\n\t\tif (ret) {\n\t\t\tdel_timer_sync(&hdw->encoder_run_timer);\n\t\t\thdw->state_encoder_ok = 0;\n\t\t\tpvr2_trace(PVR2_TRACE_STBITS,\n\t\t\t\t   \"State bit %s <-- %s\",\n\t\t\t\t   \"state_encoder_ok\",\n\t\t\t\t   (hdw->state_encoder_ok ? \"true\" : \"false\"));\n\t\t\tif (hdw->state_encoder_runok) {\n\t\t\t\thdw->state_encoder_runok = 0;\n\t\t\t\tpvr2_trace(PVR2_TRACE_STBITS,\n\t\t\t\t   \"State bit %s <-- %s\",\n\t\t\t\t\t   \"state_encoder_runok\",\n\t\t\t\t\t   (hdw->state_encoder_runok ?\n\t\t\t\t\t    \"true\" : \"false\"));\n\t\t\t}\n\t\t\tpvr2_trace(\n\t\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\t\"Giving up on command.  This is normally recovered via a firmware reload and re-initialization; concern is only warranted if this happens repeatedly and rapidly.\");\n\t\t\tbreak;\n\t\t}\n\t\twrData[0] = 0x7;\n\t\tfor (idx = 0; idx < arg_cnt_recv; idx++) {\n\t\t\targp[idx] = rdData[idx+4];\n\t\t}\n\n\t\twrData[0] = 0x0;\n\t\tret = pvr2_encoder_write_words(hdw,MBOX_BASE,wrData,1);\n\t\tbreak;\n\t}\n\tLOCK_GIVE(hdw->ctl_lock);\n\n\treturn ret;\n}\n\n\nstatic int pvr2_encoder_vcmd(struct pvr2_hdw *hdw, int cmd,\n\t\t\t     int args, ...)\n{\n\tva_list vl;\n\tunsigned int idx;\n\tu32 data[12];\n\n\tif (args > ARRAY_SIZE(data)) {\n\t\tpvr2_trace(\n\t\t\tPVR2_TRACE_ERROR_LEGS,\n\t\t\t\"Failed to write cx23416 command - too many arguments (was given %u limit %lu)\",\n\t\t\targs, (long unsigned) ARRAY_SIZE(data));\n\t\treturn -EINVAL;\n\t}\n\n\tva_start(vl, args);\n\tfor (idx = 0; idx < args; idx++) {\n\t\tdata[idx] = va_arg(vl, u32);\n\t}\n\tva_end(vl);\n\n\treturn pvr2_encoder_cmd(hdw,cmd,args,0,data);\n}\n\n\n \nstatic int pvr2_encoder_prep_config(struct pvr2_hdw *hdw)\n{\n\tint ret = 0;\n\tint encMisc3Arg = 0;\n\n#if 0\n\t \n\tLOCK_TAKE(hdw->ctl_lock); do {\n\t\tu32 dat[1];\n\t\tdat[0] = 0x80000640;\n\t\tpvr2_encoder_write_words(hdw,0x01fe,dat,1);\n\t\tpvr2_encoder_write_words(hdw,0x023e,dat,1);\n\t} while(0); LOCK_GIVE(hdw->ctl_lock);\n#endif\n\n\t \n\n\n#if 0\n\t \n\tret |= pvr2_encoder_vcmd(hdw, CX2341X_ENC_MISC,4, 5,0,0,0);\n#endif\n\n\t \n\tif (hdw->hdw_desc->flag_has_cx25840) {\n\t\tencMisc3Arg = 1;\n\t} else {\n\t\tencMisc3Arg = 0;\n\t}\n\tret |= pvr2_encoder_vcmd(hdw, CX2341X_ENC_MISC,4, 3,\n\t\t\t\t encMisc3Arg,0,0);\n\n\tret |= pvr2_encoder_vcmd(hdw, CX2341X_ENC_MISC,4, 8,0,0,0);\n\n#if 0\n\t \n\tret |= pvr2_encoder_vcmd(hdw, CX2341X_ENC_MISC,4, 4,1,0,0);\n#endif\n\n\tret |= pvr2_encoder_vcmd(hdw, CX2341X_ENC_MISC,4, 0,3,0,0);\n\tret |= pvr2_encoder_vcmd(hdw, CX2341X_ENC_MISC,4,15,0,0,0);\n\n\t \n\tret |= pvr2_encoder_vcmd(hdw, CX2341X_ENC_MISC, 2, 4, 1);\n\n\treturn ret;\n}\n\nint pvr2_encoder_adjust(struct pvr2_hdw *hdw)\n{\n\tint ret;\n\tret = cx2341x_update(hdw,pvr2_encoder_cmd,\n\t\t\t     (hdw->enc_cur_valid ? &hdw->enc_cur_state : NULL),\n\t\t\t     &hdw->enc_ctl_state);\n\tif (ret) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"Error from cx2341x module code=%d\",ret);\n\t} else {\n\t\thdw->enc_cur_state = hdw->enc_ctl_state;\n\t\thdw->enc_cur_valid = !0;\n\t}\n\treturn ret;\n}\n\n\nint pvr2_encoder_configure(struct pvr2_hdw *hdw)\n{\n\tint ret;\n\tint val;\n\tpvr2_trace(PVR2_TRACE_ENCODER, \"pvr2_encoder_configure (cx2341x module)\");\n\thdw->enc_ctl_state.port = CX2341X_PORT_STREAMING;\n\thdw->enc_ctl_state.width = hdw->res_hor_val;\n\thdw->enc_ctl_state.height = hdw->res_ver_val;\n\thdw->enc_ctl_state.is_50hz = ((hdw->std_mask_cur & V4L2_STD_525_60) ?\n\t\t\t\t      0 : 1);\n\n\tret = 0;\n\n\tret |= pvr2_encoder_prep_config(hdw);\n\n\t \n\tval = 0xf0;\n\tif (hdw->hdw_desc->flag_has_cx25840) {\n\t\t \n\t\tval = 0x140;\n\t}\n\n\tif (!ret) ret = pvr2_encoder_vcmd(\n\t\thdw,CX2341X_ENC_SET_NUM_VSYNC_LINES, 2,\n\t\tval, val);\n\n\t \n\tif (!ret) ret = pvr2_encoder_vcmd(\n\t\thdw,CX2341X_ENC_SET_EVENT_NOTIFICATION, 4,\n\t\t0, 0, 0x10000000, 0xffffffff);\n\n\tif (!ret) ret = pvr2_encoder_vcmd(\n\t\thdw,CX2341X_ENC_SET_VBI_LINE, 5,\n\t\t0xffffffff,0,0,0,0);\n\n\tif (ret) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"Failed to configure cx23416\");\n\t\treturn ret;\n\t}\n\n\tret = pvr2_encoder_adjust(hdw);\n\tif (ret) return ret;\n\n\tret = pvr2_encoder_vcmd(\n\t\thdw, CX2341X_ENC_INITIALIZE_INPUT, 0);\n\n\tif (ret) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"Failed to initialize cx23416 video input\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n\nint pvr2_encoder_start(struct pvr2_hdw *hdw)\n{\n\tint status;\n\n\t \n\tpvr2_write_register(hdw, 0x0048, 0xbfffffff);\n\n\tpvr2_encoder_vcmd(hdw,CX2341X_ENC_MUTE_VIDEO,1,\n\t\t\t  hdw->input_val == PVR2_CVAL_INPUT_RADIO ? 1 : 0);\n\n\tswitch (hdw->active_stream_type) {\n\tcase pvr2_config_vbi:\n\t\tstatus = pvr2_encoder_vcmd(hdw,CX2341X_ENC_START_CAPTURE,2,\n\t\t\t\t\t   0x01,0x14);\n\t\tbreak;\n\tcase pvr2_config_mpeg:\n\t\tstatus = pvr2_encoder_vcmd(hdw,CX2341X_ENC_START_CAPTURE,2,\n\t\t\t\t\t   0,0x13);\n\t\tbreak;\n\tdefault:  \n\t\tstatus = pvr2_encoder_vcmd(hdw,CX2341X_ENC_START_CAPTURE,2,\n\t\t\t\t\t   0,0x13);\n\t\tbreak;\n\t}\n\treturn status;\n}\n\nint pvr2_encoder_stop(struct pvr2_hdw *hdw)\n{\n\tint status;\n\n\t \n\tpvr2_write_register(hdw, 0x0048, 0xffffffff);\n\n\tswitch (hdw->active_stream_type) {\n\tcase pvr2_config_vbi:\n\t\tstatus = pvr2_encoder_vcmd(hdw,CX2341X_ENC_STOP_CAPTURE,3,\n\t\t\t\t\t   0x01,0x01,0x14);\n\t\tbreak;\n\tcase pvr2_config_mpeg:\n\t\tstatus = pvr2_encoder_vcmd(hdw,CX2341X_ENC_STOP_CAPTURE,3,\n\t\t\t\t\t   0x01,0,0x13);\n\t\tbreak;\n\tdefault:  \n\t\tstatus = pvr2_encoder_vcmd(hdw,CX2341X_ENC_STOP_CAPTURE,3,\n\t\t\t\t\t   0x01,0,0x13);\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}