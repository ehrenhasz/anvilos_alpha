{
  "module_name": "pvrusb2-io.c",
  "hash_id": "35b25cd2c7e13aeaf8eb48a497cd26017fa9d9da6828f8ee1c877886780cb366",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/pvrusb2/pvrusb2-io.c",
  "human_readable_source": "\n \n\n#include \"pvrusb2-io.h\"\n#include \"pvrusb2-debug.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n\nstatic const char *pvr2_buffer_state_decode(enum pvr2_buffer_state);\n\n#define BUFFER_SIG 0x47653271\n\n\n\n\n#ifdef SANITY_CHECK_BUFFERS\n#define BUFFER_CHECK(bp) do { \\\n\tif ((bp)->signature != BUFFER_SIG) { \\\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS, \\\n\t\t\"Buffer %p is bad at %s:%d\", \\\n\t\t(bp), __FILE__, __LINE__); \\\n\t\tpvr2_buffer_describe(bp, \"BadSig\"); \\\n\t\tBUG(); \\\n\t} \\\n} while (0)\n#else\n#define BUFFER_CHECK(bp) do {} while (0)\n#endif\n\nstruct pvr2_stream {\n\t \n\tstruct list_head queued_list;\n\tunsigned int q_count;\n\tunsigned int q_bcount;\n\t \n\tstruct list_head ready_list;\n\tunsigned int r_count;\n\tunsigned int r_bcount;\n\t \n\tstruct list_head idle_list;\n\tunsigned int i_count;\n\tunsigned int i_bcount;\n\t \n\tstruct pvr2_buffer **buffers;\n\t \n\tunsigned int buffer_slot_count;\n\t \n\tunsigned int buffer_total_count;\n\t \n\tunsigned int buffer_target_count;\n\t \n\tpvr2_stream_callback callback_func;\n\tvoid *callback_data;\n\t \n\tstruct usb_device *dev;\n\tint endpoint;\n\t \n\tspinlock_t list_lock;\n\tstruct mutex mutex;\n\t \n\tunsigned int fail_count;\n\tunsigned int fail_tolerance;\n\n\tunsigned int buffers_processed;\n\tunsigned int buffers_failed;\n\tunsigned int bytes_processed;\n};\n\nstruct pvr2_buffer {\n\tint id;\n\tint signature;\n\tenum pvr2_buffer_state state;\n\tvoid *ptr;                \n\tunsigned int max_count;   \n\tunsigned int used_count;  \n\tint status;               \n\tstruct pvr2_stream *stream;\n\tstruct list_head list_overhead;\n\tstruct urb *purb;\n};\n\nstatic const char *pvr2_buffer_state_decode(enum pvr2_buffer_state st)\n{\n\tswitch (st) {\n\tcase pvr2_buffer_state_none: return \"none\";\n\tcase pvr2_buffer_state_idle: return \"idle\";\n\tcase pvr2_buffer_state_queued: return \"queued\";\n\tcase pvr2_buffer_state_ready: return \"ready\";\n\t}\n\treturn \"unknown\";\n}\n\n#ifdef SANITY_CHECK_BUFFERS\nstatic void pvr2_buffer_describe(struct pvr2_buffer *bp, const char *msg)\n{\n\tpvr2_trace(PVR2_TRACE_INFO,\n\t\t   \"buffer%s%s %p state=%s id=%d status=%d stream=%p purb=%p sig=0x%x\",\n\t\t   (msg ? \" \" : \"\"),\n\t\t   (msg ? msg : \"\"),\n\t\t   bp,\n\t\t   (bp ? pvr2_buffer_state_decode(bp->state) : \"(invalid)\"),\n\t\t   (bp ? bp->id : 0),\n\t\t   (bp ? bp->status : 0),\n\t\t   (bp ? bp->stream : NULL),\n\t\t   (bp ? bp->purb : NULL),\n\t\t   (bp ? bp->signature : 0));\n}\n#endif   \n\nstatic void pvr2_buffer_remove(struct pvr2_buffer *bp)\n{\n\tunsigned int *cnt;\n\tunsigned int *bcnt;\n\tunsigned int ccnt;\n\tstruct pvr2_stream *sp = bp->stream;\n\tswitch (bp->state) {\n\tcase pvr2_buffer_state_idle:\n\t\tcnt = &sp->i_count;\n\t\tbcnt = &sp->i_bcount;\n\t\tccnt = bp->max_count;\n\t\tbreak;\n\tcase pvr2_buffer_state_queued:\n\t\tcnt = &sp->q_count;\n\t\tbcnt = &sp->q_bcount;\n\t\tccnt = bp->max_count;\n\t\tbreak;\n\tcase pvr2_buffer_state_ready:\n\t\tcnt = &sp->r_count;\n\t\tbcnt = &sp->r_bcount;\n\t\tccnt = bp->used_count;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tlist_del_init(&bp->list_overhead);\n\t(*cnt)--;\n\t(*bcnt) -= ccnt;\n\tpvr2_trace(PVR2_TRACE_BUF_FLOW,\n\t\t   \"/*---TRACE_FLOW---*/ bufferPool\t%8s dec cap=%07d cnt=%02d\",\n\t\t   pvr2_buffer_state_decode(bp->state), *bcnt, *cnt);\n\tbp->state = pvr2_buffer_state_none;\n}\n\nstatic void pvr2_buffer_set_none(struct pvr2_buffer *bp)\n{\n\tunsigned long irq_flags;\n\tstruct pvr2_stream *sp;\n\tBUFFER_CHECK(bp);\n\tsp = bp->stream;\n\tpvr2_trace(PVR2_TRACE_BUF_FLOW,\n\t\t   \"/*---TRACE_FLOW---*/ bufferState    %p %6s --> %6s\",\n\t\t   bp,\n\t\t   pvr2_buffer_state_decode(bp->state),\n\t\t   pvr2_buffer_state_decode(pvr2_buffer_state_none));\n\tspin_lock_irqsave(&sp->list_lock, irq_flags);\n\tpvr2_buffer_remove(bp);\n\tspin_unlock_irqrestore(&sp->list_lock, irq_flags);\n}\n\nstatic int pvr2_buffer_set_ready(struct pvr2_buffer *bp)\n{\n\tint fl;\n\tunsigned long irq_flags;\n\tstruct pvr2_stream *sp;\n\tBUFFER_CHECK(bp);\n\tsp = bp->stream;\n\tpvr2_trace(PVR2_TRACE_BUF_FLOW,\n\t\t   \"/*---TRACE_FLOW---*/ bufferState    %p %6s --> %6s\",\n\t\t   bp,\n\t\t   pvr2_buffer_state_decode(bp->state),\n\t\t   pvr2_buffer_state_decode(pvr2_buffer_state_ready));\n\tspin_lock_irqsave(&sp->list_lock, irq_flags);\n\tfl = (sp->r_count == 0);\n\tpvr2_buffer_remove(bp);\n\tlist_add_tail(&bp->list_overhead, &sp->ready_list);\n\tbp->state = pvr2_buffer_state_ready;\n\t(sp->r_count)++;\n\tsp->r_bcount += bp->used_count;\n\tpvr2_trace(PVR2_TRACE_BUF_FLOW,\n\t\t   \"/*---TRACE_FLOW---*/ bufferPool\t%8s inc cap=%07d cnt=%02d\",\n\t\t   pvr2_buffer_state_decode(bp->state),\n\t\t   sp->r_bcount, sp->r_count);\n\tspin_unlock_irqrestore(&sp->list_lock, irq_flags);\n\treturn fl;\n}\n\nstatic void pvr2_buffer_set_idle(struct pvr2_buffer *bp)\n{\n\tunsigned long irq_flags;\n\tstruct pvr2_stream *sp;\n\tBUFFER_CHECK(bp);\n\tsp = bp->stream;\n\tpvr2_trace(PVR2_TRACE_BUF_FLOW,\n\t\t   \"/*---TRACE_FLOW---*/ bufferState    %p %6s --> %6s\",\n\t\t   bp,\n\t\t   pvr2_buffer_state_decode(bp->state),\n\t\t   pvr2_buffer_state_decode(pvr2_buffer_state_idle));\n\tspin_lock_irqsave(&sp->list_lock, irq_flags);\n\tpvr2_buffer_remove(bp);\n\tlist_add_tail(&bp->list_overhead, &sp->idle_list);\n\tbp->state = pvr2_buffer_state_idle;\n\t(sp->i_count)++;\n\tsp->i_bcount += bp->max_count;\n\tpvr2_trace(PVR2_TRACE_BUF_FLOW,\n\t\t   \"/*---TRACE_FLOW---*/ bufferPool\t%8s inc cap=%07d cnt=%02d\",\n\t\t   pvr2_buffer_state_decode(bp->state),\n\t\t   sp->i_bcount, sp->i_count);\n\tspin_unlock_irqrestore(&sp->list_lock, irq_flags);\n}\n\nstatic void pvr2_buffer_set_queued(struct pvr2_buffer *bp)\n{\n\tunsigned long irq_flags;\n\tstruct pvr2_stream *sp;\n\tBUFFER_CHECK(bp);\n\tsp = bp->stream;\n\tpvr2_trace(PVR2_TRACE_BUF_FLOW,\n\t\t   \"/*---TRACE_FLOW---*/ bufferState    %p %6s --> %6s\",\n\t\t   bp,\n\t\t   pvr2_buffer_state_decode(bp->state),\n\t\t   pvr2_buffer_state_decode(pvr2_buffer_state_queued));\n\tspin_lock_irqsave(&sp->list_lock, irq_flags);\n\tpvr2_buffer_remove(bp);\n\tlist_add_tail(&bp->list_overhead, &sp->queued_list);\n\tbp->state = pvr2_buffer_state_queued;\n\t(sp->q_count)++;\n\tsp->q_bcount += bp->max_count;\n\tpvr2_trace(PVR2_TRACE_BUF_FLOW,\n\t\t   \"/*---TRACE_FLOW---*/ bufferPool\t%8s inc cap=%07d cnt=%02d\",\n\t\t   pvr2_buffer_state_decode(bp->state),\n\t\t   sp->q_bcount, sp->q_count);\n\tspin_unlock_irqrestore(&sp->list_lock, irq_flags);\n}\n\nstatic void pvr2_buffer_wipe(struct pvr2_buffer *bp)\n{\n\tif (bp->state == pvr2_buffer_state_queued) {\n\t\tusb_kill_urb(bp->purb);\n\t}\n}\n\nstatic int pvr2_buffer_init(struct pvr2_buffer *bp,\n\t\t\t    struct pvr2_stream *sp,\n\t\t\t    unsigned int id)\n{\n\tmemset(bp, 0, sizeof(*bp));\n\tbp->signature = BUFFER_SIG;\n\tbp->id = id;\n\tpvr2_trace(PVR2_TRACE_BUF_POOL,\n\t\t   \"/*---TRACE_FLOW---*/ bufferInit     %p stream=%p\", bp, sp);\n\tbp->stream = sp;\n\tbp->state = pvr2_buffer_state_none;\n\tINIT_LIST_HEAD(&bp->list_overhead);\n\tbp->purb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (! bp->purb) return -ENOMEM;\n#ifdef SANITY_CHECK_BUFFERS\n\tpvr2_buffer_describe(bp, \"create\");\n#endif\n\treturn 0;\n}\n\nstatic void pvr2_buffer_done(struct pvr2_buffer *bp)\n{\n#ifdef SANITY_CHECK_BUFFERS\n\tpvr2_buffer_describe(bp, \"delete\");\n#endif\n\tpvr2_buffer_wipe(bp);\n\tpvr2_buffer_set_none(bp);\n\tbp->signature = 0;\n\tbp->stream = NULL;\n\tusb_free_urb(bp->purb);\n\tpvr2_trace(PVR2_TRACE_BUF_POOL, \"/*---TRACE_FLOW---*/ bufferDone     %p\",\n\t\t   bp);\n}\n\nstatic int pvr2_stream_buffer_count(struct pvr2_stream *sp, unsigned int cnt)\n{\n\tint ret;\n\tunsigned int scnt;\n\n\t \n\tif (cnt == sp->buffer_total_count) return 0;\n\n\tpvr2_trace(PVR2_TRACE_BUF_POOL,\n\t\t   \"/*---TRACE_FLOW---*/ poolResize\tstream=%p cur=%d adj=%+d\",\n\t\t   sp,\n\t\t   sp->buffer_total_count,\n\t\t   cnt-sp->buffer_total_count);\n\n\tscnt = cnt & ~0x1f;\n\tif (cnt > scnt) scnt += 0x20;\n\n\tif (cnt > sp->buffer_total_count) {\n\t\tif (scnt > sp->buffer_slot_count) {\n\t\t\tstruct pvr2_buffer **nb;\n\n\t\t\tnb = kmalloc_array(scnt, sizeof(*nb), GFP_KERNEL);\n\t\t\tif (!nb) return -ENOMEM;\n\t\t\tif (sp->buffer_slot_count) {\n\t\t\t\tmemcpy(nb, sp->buffers,\n\t\t\t\t       sp->buffer_slot_count * sizeof(*nb));\n\t\t\t\tkfree(sp->buffers);\n\t\t\t}\n\t\t\tsp->buffers = nb;\n\t\t\tsp->buffer_slot_count = scnt;\n\t\t}\n\t\twhile (sp->buffer_total_count < cnt) {\n\t\t\tstruct pvr2_buffer *bp;\n\t\t\tbp = kmalloc(sizeof(*bp), GFP_KERNEL);\n\t\t\tif (!bp) return -ENOMEM;\n\t\t\tret = pvr2_buffer_init(bp, sp, sp->buffer_total_count);\n\t\t\tif (ret) {\n\t\t\t\tkfree(bp);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tsp->buffers[sp->buffer_total_count] = bp;\n\t\t\t(sp->buffer_total_count)++;\n\t\t\tpvr2_buffer_set_idle(bp);\n\t\t}\n\t} else {\n\t\twhile (sp->buffer_total_count > cnt) {\n\t\t\tstruct pvr2_buffer *bp;\n\t\t\tbp = sp->buffers[sp->buffer_total_count - 1];\n\t\t\t \n\t\t\tsp->buffers[sp->buffer_total_count - 1] = NULL;\n\t\t\t(sp->buffer_total_count)--;\n\t\t\tpvr2_buffer_done(bp);\n\t\t\tkfree(bp);\n\t\t}\n\t\tif (scnt < sp->buffer_slot_count) {\n\t\t\tstruct pvr2_buffer **nb = NULL;\n\t\t\tif (scnt) {\n\t\t\t\tnb = kmemdup(sp->buffers, scnt * sizeof(*nb),\n\t\t\t\t\t     GFP_KERNEL);\n\t\t\t\tif (!nb) return -ENOMEM;\n\t\t\t}\n\t\t\tkfree(sp->buffers);\n\t\t\tsp->buffers = nb;\n\t\t\tsp->buffer_slot_count = scnt;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int pvr2_stream_achieve_buffer_count(struct pvr2_stream *sp)\n{\n\tstruct pvr2_buffer *bp;\n\tunsigned int cnt;\n\n\tif (sp->buffer_total_count == sp->buffer_target_count) return 0;\n\n\tpvr2_trace(PVR2_TRACE_BUF_POOL,\n\t\t   \"/*---TRACE_FLOW---*/ poolCheck\tstream=%p cur=%d tgt=%d\",\n\t\t   sp, sp->buffer_total_count, sp->buffer_target_count);\n\n\tif (sp->buffer_total_count < sp->buffer_target_count) {\n\t\treturn pvr2_stream_buffer_count(sp, sp->buffer_target_count);\n\t}\n\n\tcnt = 0;\n\twhile ((sp->buffer_total_count - cnt) > sp->buffer_target_count) {\n\t\tbp = sp->buffers[sp->buffer_total_count - (cnt + 1)];\n\t\tif (bp->state != pvr2_buffer_state_idle) break;\n\t\tcnt++;\n\t}\n\tif (cnt) {\n\t\tpvr2_stream_buffer_count(sp, sp->buffer_total_count - cnt);\n\t}\n\n\treturn 0;\n}\n\nstatic void pvr2_stream_internal_flush(struct pvr2_stream *sp)\n{\n\tstruct list_head *lp;\n\tstruct pvr2_buffer *bp1;\n\twhile ((lp = sp->queued_list.next) != &sp->queued_list) {\n\t\tbp1 = list_entry(lp, struct pvr2_buffer, list_overhead);\n\t\tpvr2_buffer_wipe(bp1);\n\t\t \n\t\tif (bp1->state != pvr2_buffer_state_queued) continue;\n\t\tpvr2_buffer_set_idle(bp1);\n\t}\n\tif (sp->buffer_total_count != sp->buffer_target_count) {\n\t\tpvr2_stream_achieve_buffer_count(sp);\n\t}\n}\n\nstatic void pvr2_stream_init(struct pvr2_stream *sp)\n{\n\tspin_lock_init(&sp->list_lock);\n\tmutex_init(&sp->mutex);\n\tINIT_LIST_HEAD(&sp->queued_list);\n\tINIT_LIST_HEAD(&sp->ready_list);\n\tINIT_LIST_HEAD(&sp->idle_list);\n}\n\nstatic void pvr2_stream_done(struct pvr2_stream *sp)\n{\n\tmutex_lock(&sp->mutex); do {\n\t\tpvr2_stream_internal_flush(sp);\n\t\tpvr2_stream_buffer_count(sp, 0);\n\t} while (0); mutex_unlock(&sp->mutex);\n}\n\nstatic void buffer_complete(struct urb *urb)\n{\n\tstruct pvr2_buffer *bp = urb->context;\n\tstruct pvr2_stream *sp;\n\tunsigned long irq_flags;\n\tBUFFER_CHECK(bp);\n\tsp = bp->stream;\n\tbp->used_count = 0;\n\tbp->status = 0;\n\tpvr2_trace(PVR2_TRACE_BUF_FLOW,\n\t\t   \"/*---TRACE_FLOW---*/ bufferComplete %p stat=%d cnt=%d\",\n\t\t   bp, urb->status, urb->actual_length);\n\tspin_lock_irqsave(&sp->list_lock, irq_flags);\n\tif ((!(urb->status)) ||\n\t    (urb->status == -ENOENT) ||\n\t    (urb->status == -ECONNRESET) ||\n\t    (urb->status == -ESHUTDOWN)) {\n\t\t(sp->buffers_processed)++;\n\t\tsp->bytes_processed += urb->actual_length;\n\t\tbp->used_count = urb->actual_length;\n\t\tif (sp->fail_count) {\n\t\t\tpvr2_trace(PVR2_TRACE_TOLERANCE,\n\t\t\t\t   \"stream %p transfer ok - fail count reset\",\n\t\t\t\t   sp);\n\t\t\tsp->fail_count = 0;\n\t\t}\n\t} else if (sp->fail_count < sp->fail_tolerance) {\n\t\t \n\t\t\n\t\t(sp->fail_count)++;\n\t\t(sp->buffers_failed)++;\n\t\tpvr2_trace(PVR2_TRACE_TOLERANCE,\n\t\t\t   \"stream %p ignoring error %d - fail count increased to %u\",\n\t\t\t   sp, urb->status, sp->fail_count);\n\t} else {\n\t\t(sp->buffers_failed)++;\n\t\tbp->status = urb->status;\n\t}\n\tspin_unlock_irqrestore(&sp->list_lock, irq_flags);\n\tpvr2_buffer_set_ready(bp);\n\tif (sp->callback_func) {\n\t\tsp->callback_func(sp->callback_data);\n\t}\n}\n\nstruct pvr2_stream *pvr2_stream_create(void)\n{\n\tstruct pvr2_stream *sp;\n\tsp = kzalloc(sizeof(*sp), GFP_KERNEL);\n\tif (!sp) return sp;\n\tpvr2_trace(PVR2_TRACE_INIT, \"pvr2_stream_create: sp=%p\", sp);\n\tpvr2_stream_init(sp);\n\treturn sp;\n}\n\nvoid pvr2_stream_destroy(struct pvr2_stream *sp)\n{\n\tif (!sp) return;\n\tpvr2_trace(PVR2_TRACE_INIT, \"pvr2_stream_destroy: sp=%p\", sp);\n\tpvr2_stream_done(sp);\n\tkfree(sp);\n}\n\nvoid pvr2_stream_setup(struct pvr2_stream *sp,\n\t\t       struct usb_device *dev,\n\t\t       int endpoint,\n\t\t       unsigned int tolerance)\n{\n\tmutex_lock(&sp->mutex); do {\n\t\tpvr2_stream_internal_flush(sp);\n\t\tsp->dev = dev;\n\t\tsp->endpoint = endpoint;\n\t\tsp->fail_tolerance = tolerance;\n\t} while (0); mutex_unlock(&sp->mutex);\n}\n\nvoid pvr2_stream_set_callback(struct pvr2_stream *sp,\n\t\t\t      pvr2_stream_callback func,\n\t\t\t      void *data)\n{\n\tunsigned long irq_flags;\n\tmutex_lock(&sp->mutex);\n\tdo {\n\t\tspin_lock_irqsave(&sp->list_lock, irq_flags);\n\t\tsp->callback_data = data;\n\t\tsp->callback_func = func;\n\t\tspin_unlock_irqrestore(&sp->list_lock, irq_flags);\n\t} while (0);\n\tmutex_unlock(&sp->mutex);\n}\n\nvoid pvr2_stream_get_stats(struct pvr2_stream *sp,\n\t\t\t   struct pvr2_stream_stats *stats,\n\t\t\t   int zero_counts)\n{\n\tunsigned long irq_flags;\n\tspin_lock_irqsave(&sp->list_lock, irq_flags);\n\tif (stats) {\n\t\tstats->buffers_in_queue = sp->q_count;\n\t\tstats->buffers_in_idle = sp->i_count;\n\t\tstats->buffers_in_ready = sp->r_count;\n\t\tstats->buffers_processed = sp->buffers_processed;\n\t\tstats->buffers_failed = sp->buffers_failed;\n\t\tstats->bytes_processed = sp->bytes_processed;\n\t}\n\tif (zero_counts) {\n\t\tsp->buffers_processed = 0;\n\t\tsp->buffers_failed = 0;\n\t\tsp->bytes_processed = 0;\n\t}\n\tspin_unlock_irqrestore(&sp->list_lock, irq_flags);\n}\n\n \nint pvr2_stream_get_buffer_count(struct pvr2_stream *sp)\n{\n\treturn sp->buffer_target_count;\n}\n\nint pvr2_stream_set_buffer_count(struct pvr2_stream *sp, unsigned int cnt)\n{\n\tint ret;\n\tif (sp->buffer_target_count == cnt) return 0;\n\tmutex_lock(&sp->mutex);\n\tdo {\n\t\tsp->buffer_target_count = cnt;\n\t\tret = pvr2_stream_achieve_buffer_count(sp);\n\t} while (0);\n\tmutex_unlock(&sp->mutex);\n\treturn ret;\n}\n\nstruct pvr2_buffer *pvr2_stream_get_idle_buffer(struct pvr2_stream *sp)\n{\n\tstruct list_head *lp = sp->idle_list.next;\n\tif (lp == &sp->idle_list) return NULL;\n\treturn list_entry(lp, struct pvr2_buffer, list_overhead);\n}\n\nstruct pvr2_buffer *pvr2_stream_get_ready_buffer(struct pvr2_stream *sp)\n{\n\tstruct list_head *lp = sp->ready_list.next;\n\tif (lp == &sp->ready_list) return NULL;\n\treturn list_entry(lp, struct pvr2_buffer, list_overhead);\n}\n\nstruct pvr2_buffer *pvr2_stream_get_buffer(struct pvr2_stream *sp, int id)\n{\n\tif (id < 0) return NULL;\n\tif (id >= sp->buffer_total_count) return NULL;\n\treturn sp->buffers[id];\n}\n\nint pvr2_stream_get_ready_count(struct pvr2_stream *sp)\n{\n\treturn sp->r_count;\n}\n\nvoid pvr2_stream_kill(struct pvr2_stream *sp)\n{\n\tstruct pvr2_buffer *bp;\n\tmutex_lock(&sp->mutex);\n\tdo {\n\t\tpvr2_stream_internal_flush(sp);\n\t\twhile ((bp = pvr2_stream_get_ready_buffer(sp)) != NULL) {\n\t\t\tpvr2_buffer_set_idle(bp);\n\t\t}\n\t\tif (sp->buffer_total_count != sp->buffer_target_count) {\n\t\t\tpvr2_stream_achieve_buffer_count(sp);\n\t\t}\n\t} while (0);\n\tmutex_unlock(&sp->mutex);\n}\n\nint pvr2_buffer_queue(struct pvr2_buffer *bp)\n{\n#undef SEED_BUFFER\n#ifdef SEED_BUFFER\n\tunsigned int idx;\n\tunsigned int val;\n#endif\n\tint ret = 0;\n\tstruct pvr2_stream *sp;\n\tif (!bp) return -EINVAL;\n\tsp = bp->stream;\n\tmutex_lock(&sp->mutex);\n\tdo {\n\t\tpvr2_buffer_wipe(bp);\n\t\tif (!sp->dev) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tpvr2_buffer_set_queued(bp);\n#ifdef SEED_BUFFER\n\t\tfor (idx = 0; idx < (bp->max_count) / 4; idx++) {\n\t\t\tval = bp->id << 24;\n\t\t\tval |= idx;\n\t\t\t((unsigned int *)(bp->ptr))[idx] = val;\n\t\t}\n#endif\n\t\tbp->status = -EINPROGRESS;\n\t\tusb_fill_bulk_urb(bp->purb,      \n\t\t\t\t  sp->dev,       \n\t\t\t\t  \n\t\t\t\t  usb_rcvbulkpipe(sp->dev, sp->endpoint),\n\t\t\t\t  bp->ptr,       \n\t\t\t\t  bp->max_count, \n\t\t\t\t  buffer_complete,\n\t\t\t\t  bp);\n\t\tusb_submit_urb(bp->purb, GFP_KERNEL);\n\t} while (0);\n\tmutex_unlock(&sp->mutex);\n\treturn ret;\n}\n\nint pvr2_buffer_set_buffer(struct pvr2_buffer *bp, void *ptr, unsigned int cnt)\n{\n\tint ret = 0;\n\tunsigned long irq_flags;\n\tstruct pvr2_stream *sp;\n\tif (!bp) return -EINVAL;\n\tsp = bp->stream;\n\tmutex_lock(&sp->mutex);\n\tdo {\n\t\tspin_lock_irqsave(&sp->list_lock, irq_flags);\n\t\tif (bp->state != pvr2_buffer_state_idle) {\n\t\t\tret = -EPERM;\n\t\t} else {\n\t\t\tbp->ptr = ptr;\n\t\t\tbp->stream->i_bcount -= bp->max_count;\n\t\t\tbp->max_count = cnt;\n\t\t\tbp->stream->i_bcount += bp->max_count;\n\t\t\tpvr2_trace(PVR2_TRACE_BUF_FLOW,\n\t\t\t\t   \"/*---TRACE_FLOW---*/ bufferPool\t%8s cap cap=%07d cnt=%02d\",\n\t\t\t\t   pvr2_buffer_state_decode(\n\t\t\t\t\t   pvr2_buffer_state_idle),\n\t\t\t\t   bp->stream->i_bcount, bp->stream->i_count);\n\t\t}\n\t\tspin_unlock_irqrestore(&sp->list_lock, irq_flags);\n\t} while (0);\n\tmutex_unlock(&sp->mutex);\n\treturn ret;\n}\n\nunsigned int pvr2_buffer_get_count(struct pvr2_buffer *bp)\n{\n\treturn bp->used_count;\n}\n\nint pvr2_buffer_get_status(struct pvr2_buffer *bp)\n{\n\treturn bp->status;\n}\n\nint pvr2_buffer_get_id(struct pvr2_buffer *bp)\n{\n\treturn bp->id;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}