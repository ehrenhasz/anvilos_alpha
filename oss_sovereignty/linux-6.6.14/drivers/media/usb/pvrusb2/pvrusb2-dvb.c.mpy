{
  "module_name": "pvrusb2-dvb.c",
  "hash_id": "0faf2f8110813ee106bf2838a16759da7da083136d7ba91dcebd3aed94c8a701",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/pvrusb2/pvrusb2-dvb.c",
  "human_readable_source": "\n \n\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <media/dvbdev.h>\n#include \"pvrusb2-debug.h\"\n#include \"pvrusb2-hdw-internal.h\"\n#include \"pvrusb2-hdw.h\"\n#include \"pvrusb2-io.h\"\n#include \"pvrusb2-dvb.h\"\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic int pvr2_dvb_feed_func(struct pvr2_dvb_adapter *adap)\n{\n\tint ret;\n\tunsigned int count;\n\tstruct pvr2_buffer *bp;\n\tstruct pvr2_stream *stream;\n\n\tpvr2_trace(PVR2_TRACE_DVB_FEED, \"dvb feed thread started\");\n\tset_freezable();\n\n\tstream = adap->channel.stream->stream;\n\n\tfor (;;) {\n\t\tif (kthread_should_stop()) break;\n\n\t\t \n\t\ttry_to_freeze();\n\n\t\tbp = pvr2_stream_get_ready_buffer(stream);\n\t\tif (bp != NULL) {\n\t\t\tcount = pvr2_buffer_get_count(bp);\n\t\t\tif (count) {\n\t\t\t\tdvb_dmx_swfilter(\n\t\t\t\t\t&adap->demux,\n\t\t\t\t\tadap->buffer_storage[\n\t\t\t\t\t    pvr2_buffer_get_id(bp)],\n\t\t\t\t\tcount);\n\t\t\t} else {\n\t\t\t\tret = pvr2_buffer_get_status(bp);\n\t\t\t\tif (ret < 0) break;\n\t\t\t}\n\t\t\tret = pvr2_buffer_queue(bp);\n\t\t\tif (ret < 0) break;\n\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\n\t\t \n\t\tret = wait_event_interruptible(\n\t\t    adap->buffer_wait_data,\n\t\t    (pvr2_stream_get_ready_count(stream) > 0) ||\n\t\t    kthread_should_stop());\n\t\tif (ret < 0) break;\n\t}\n\n\t \n\n\tpvr2_trace(PVR2_TRACE_DVB_FEED, \"dvb feed thread stopped\");\n\n\treturn 0;\n}\n\nstatic int pvr2_dvb_feed_thread(void *data)\n{\n\tint stat = pvr2_dvb_feed_func(data);\n\n\twhile (!kthread_should_stop()) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule();\n\t}\n\treturn stat;\n}\n\nstatic void pvr2_dvb_notify(struct pvr2_dvb_adapter *adap)\n{\n\twake_up(&adap->buffer_wait_data);\n}\n\nstatic void pvr2_dvb_stream_end(struct pvr2_dvb_adapter *adap)\n{\n\tunsigned int idx;\n\tstruct pvr2_stream *stream;\n\n\tif (adap->thread) {\n\t\tkthread_stop(adap->thread);\n\t\tadap->thread = NULL;\n\t}\n\n\tif (adap->channel.stream) {\n\t\tstream = adap->channel.stream->stream;\n\t} else {\n\t\tstream = NULL;\n\t}\n\tif (stream) {\n\t\tpvr2_hdw_set_streaming(adap->channel.hdw, 0);\n\t\tpvr2_stream_set_callback(stream, NULL, NULL);\n\t\tpvr2_stream_kill(stream);\n\t\tpvr2_stream_set_buffer_count(stream, 0);\n\t\tpvr2_channel_claim_stream(&adap->channel, NULL);\n\t}\n\n\tif (adap->stream_run) {\n\t\tfor (idx = 0; idx < PVR2_DVB_BUFFER_COUNT; idx++) {\n\t\t\tif (!(adap->buffer_storage[idx])) continue;\n\t\t\tkfree(adap->buffer_storage[idx]);\n\t\t\tadap->buffer_storage[idx] = NULL;\n\t\t}\n\t\tadap->stream_run = 0;\n\t}\n}\n\nstatic int pvr2_dvb_stream_do_start(struct pvr2_dvb_adapter *adap)\n{\n\tstruct pvr2_context *pvr = adap->channel.mc_head;\n\tunsigned int idx;\n\tint ret;\n\tstruct pvr2_buffer *bp;\n\tstruct pvr2_stream *stream = NULL;\n\n\tif (adap->stream_run) return -EIO;\n\n\tret = pvr2_channel_claim_stream(&adap->channel, &pvr->video_stream);\n\t \n\tif (ret < 0) return ret;\n\n\tstream = adap->channel.stream->stream;\n\n\tfor (idx = 0; idx < PVR2_DVB_BUFFER_COUNT; idx++) {\n\t\tadap->buffer_storage[idx] = kmalloc(PVR2_DVB_BUFFER_SIZE,\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!(adap->buffer_storage[idx])) return -ENOMEM;\n\t}\n\n\tpvr2_stream_set_callback(pvr->video_stream.stream,\n\t\t\t\t (pvr2_stream_callback) pvr2_dvb_notify, adap);\n\n\tret = pvr2_stream_set_buffer_count(stream, PVR2_DVB_BUFFER_COUNT);\n\tif (ret < 0) return ret;\n\n\tfor (idx = 0; idx < PVR2_DVB_BUFFER_COUNT; idx++) {\n\t\tbp = pvr2_stream_get_buffer(stream, idx);\n\t\tpvr2_buffer_set_buffer(bp,\n\t\t\t\t       adap->buffer_storage[idx],\n\t\t\t\t       PVR2_DVB_BUFFER_SIZE);\n\t}\n\n\tret = pvr2_hdw_set_streaming(adap->channel.hdw, 1);\n\tif (ret < 0) return ret;\n\n\twhile ((bp = pvr2_stream_get_idle_buffer(stream)) != NULL) {\n\t\tret = pvr2_buffer_queue(bp);\n\t\tif (ret < 0) return ret;\n\t}\n\n\tadap->thread = kthread_run(pvr2_dvb_feed_thread, adap, \"pvrusb2-dvb\");\n\n\tif (IS_ERR(adap->thread)) {\n\t\tret = PTR_ERR(adap->thread);\n\t\tadap->thread = NULL;\n\t\treturn ret;\n\t}\n\n\tadap->stream_run = !0;\n\n\treturn 0;\n}\n\nstatic int pvr2_dvb_stream_start(struct pvr2_dvb_adapter *adap)\n{\n\tint ret = pvr2_dvb_stream_do_start(adap);\n\tif (ret < 0) pvr2_dvb_stream_end(adap);\n\treturn ret;\n}\n\nstatic int pvr2_dvb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed, int onoff)\n{\n\tstruct pvr2_dvb_adapter *adap = dvbdmxfeed->demux->priv;\n\tint ret = 0;\n\n\tif (adap == NULL) return -ENODEV;\n\n\tmutex_lock(&adap->lock);\n\tdo {\n\t\tif (onoff) {\n\t\t\tif (!adap->feedcount) {\n\t\t\t\tpvr2_trace(PVR2_TRACE_DVB_FEED,\n\t\t\t\t\t   \"start feeding demux\");\n\t\t\t\tret = pvr2_dvb_stream_start(adap);\n\t\t\t\tif (ret < 0) break;\n\t\t\t}\n\t\t\t(adap->feedcount)++;\n\t\t} else if (adap->feedcount > 0) {\n\t\t\t(adap->feedcount)--;\n\t\t\tif (!adap->feedcount) {\n\t\t\t\tpvr2_trace(PVR2_TRACE_DVB_FEED,\n\t\t\t\t\t   \"stop feeding demux\");\n\t\t\t\tpvr2_dvb_stream_end(adap);\n\t\t\t}\n\t\t}\n\t} while (0);\n\tmutex_unlock(&adap->lock);\n\n\treturn ret;\n}\n\nstatic int pvr2_dvb_start_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tpvr2_trace(PVR2_TRACE_DVB_FEED, \"start pid: 0x%04x\", dvbdmxfeed->pid);\n\treturn pvr2_dvb_ctrl_feed(dvbdmxfeed, 1);\n}\n\nstatic int pvr2_dvb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tpvr2_trace(PVR2_TRACE_DVB_FEED, \"stop pid: 0x%04x\", dvbdmxfeed->pid);\n\treturn pvr2_dvb_ctrl_feed(dvbdmxfeed, 0);\n}\n\nstatic int pvr2_dvb_bus_ctrl(struct dvb_frontend *fe, int acquire)\n{\n\tstruct pvr2_dvb_adapter *adap = fe->dvb->priv;\n\treturn pvr2_channel_limit_inputs(\n\t    &adap->channel,\n\t    (acquire ? (1 << PVR2_CVAL_INPUT_DTV) : 0));\n}\n\nstatic int pvr2_dvb_adapter_init(struct pvr2_dvb_adapter *adap)\n{\n\tint ret;\n\n\tret = dvb_register_adapter(&adap->dvb_adap, \"pvrusb2-dvb\",\n\t\t\t\t   THIS_MODULE ,\n\t\t\t\t   &adap->channel.hdw->usb_dev->dev,\n\t\t\t\t   adapter_nr);\n\tif (ret < 0) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"dvb_register_adapter failed: error %d\", ret);\n\t\tgoto err;\n\t}\n\tadap->dvb_adap.priv = adap;\n\n\tadap->demux.dmx.capabilities = DMX_TS_FILTERING |\n\t\t\t\t       DMX_SECTION_FILTERING |\n\t\t\t\t       DMX_MEMORY_BASED_FILTERING;\n\tadap->demux.priv             = adap;\n\tadap->demux.filternum        = 256;\n\tadap->demux.feednum          = 256;\n\tadap->demux.start_feed       = pvr2_dvb_start_feed;\n\tadap->demux.stop_feed        = pvr2_dvb_stop_feed;\n\tadap->demux.write_to_decoder = NULL;\n\n\tret = dvb_dmx_init(&adap->demux);\n\tif (ret < 0) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"dvb_dmx_init failed: error %d\", ret);\n\t\tgoto err_dmx;\n\t}\n\n\tadap->dmxdev.filternum       = adap->demux.filternum;\n\tadap->dmxdev.demux           = &adap->demux.dmx;\n\tadap->dmxdev.capabilities    = 0;\n\n\tret = dvb_dmxdev_init(&adap->dmxdev, &adap->dvb_adap);\n\tif (ret < 0) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"dvb_dmxdev_init failed: error %d\", ret);\n\t\tgoto err_dmx_dev;\n\t}\n\n\tdvb_net_init(&adap->dvb_adap, &adap->dvb_net, &adap->demux.dmx);\n\n\treturn 0;\n\nerr_dmx_dev:\n\tdvb_dmx_release(&adap->demux);\nerr_dmx:\n\tdvb_unregister_adapter(&adap->dvb_adap);\nerr:\n\treturn ret;\n}\n\nstatic int pvr2_dvb_adapter_exit(struct pvr2_dvb_adapter *adap)\n{\n\tpvr2_trace(PVR2_TRACE_INFO, \"unregistering DVB devices\");\n\tdvb_net_release(&adap->dvb_net);\n\tadap->demux.dmx.close(&adap->demux.dmx);\n\tdvb_dmxdev_release(&adap->dmxdev);\n\tdvb_dmx_release(&adap->demux);\n\tdvb_unregister_adapter(&adap->dvb_adap);\n\treturn 0;\n}\n\nstatic int pvr2_dvb_frontend_init(struct pvr2_dvb_adapter *adap)\n{\n\tstruct pvr2_hdw *hdw = adap->channel.hdw;\n\tconst struct pvr2_dvb_props *dvb_props = hdw->hdw_desc->dvb_props;\n\tint ret = 0;\n\n\tif (dvb_props == NULL) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS, \"fe_props not defined!\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = pvr2_channel_limit_inputs(\n\t    &adap->channel,\n\t    (1 << PVR2_CVAL_INPUT_DTV));\n\tif (ret) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"failed to grab control of dtv input (code=%d)\",\n\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tif (dvb_props->frontend_attach == NULL) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"frontend_attach not defined!\");\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (dvb_props->frontend_attach(adap) == 0 && adap->fe[0]) {\n\t\tif (dvb_register_frontend(&adap->dvb_adap, adap->fe[0])) {\n\t\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t\t   \"frontend registration failed!\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto fail_frontend0;\n\t\t}\n\t\tif (adap->fe[0]->ops.analog_ops.standby)\n\t\t\tadap->fe[0]->ops.analog_ops.standby(adap->fe[0]);\n\n\t\tpvr2_trace(PVR2_TRACE_INFO, \"transferring fe[%d] ts_bus_ctrl() to pvr2_dvb_bus_ctrl()\",\n\t\t\t   adap->fe[0]->id);\n\t\tadap->fe[0]->ops.ts_bus_ctrl = pvr2_dvb_bus_ctrl;\n\t} else {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"no frontend was attached!\");\n\t\tret = -ENODEV;\n\t\treturn ret;\n\t}\n\n\tif (dvb_props->tuner_attach && dvb_props->tuner_attach(adap)) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS, \"tuner attach failed\");\n\t\tret = -ENODEV;\n\t\tgoto fail_tuner;\n\t}\n\n\tif (adap->fe[1]) {\n\t\tadap->fe[1]->id = 1;\n\t\tadap->fe[1]->tuner_priv = adap->fe[0]->tuner_priv;\n\t\tmemcpy(&adap->fe[1]->ops.tuner_ops,\n\t\t       &adap->fe[0]->ops.tuner_ops,\n\t\t       sizeof(struct dvb_tuner_ops));\n\n\t\tif (dvb_register_frontend(&adap->dvb_adap, adap->fe[1])) {\n\t\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t\t   \"frontend registration failed!\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto fail_frontend1;\n\t\t}\n\t\t \n\t\tadap->dvb_adap.mfe_shared = 1;\n\n\t\tif (adap->fe[1]->ops.analog_ops.standby)\n\t\t\tadap->fe[1]->ops.analog_ops.standby(adap->fe[1]);\n\n\t\tpvr2_trace(PVR2_TRACE_INFO, \"transferring fe[%d] ts_bus_ctrl() to pvr2_dvb_bus_ctrl()\",\n\t\t\t   adap->fe[1]->id);\n\t\tadap->fe[1]->ops.ts_bus_ctrl = pvr2_dvb_bus_ctrl;\n\t}\ndone:\n\tpvr2_channel_limit_inputs(&adap->channel, 0);\n\treturn ret;\n\nfail_frontend1:\n\tdvb_frontend_detach(adap->fe[1]);\n\tadap->fe[1] = NULL;\nfail_tuner:\n\tdvb_unregister_frontend(adap->fe[0]);\nfail_frontend0:\n\tdvb_frontend_detach(adap->fe[0]);\n\tadap->fe[0] = NULL;\n\tdvb_module_release(adap->i2c_client_tuner);\n\tdvb_module_release(adap->i2c_client_demod[1]);\n\tdvb_module_release(adap->i2c_client_demod[0]);\n\n\treturn ret;\n}\n\nstatic int pvr2_dvb_frontend_exit(struct pvr2_dvb_adapter *adap)\n{\n\tif (adap->fe[1]) {\n\t\tdvb_unregister_frontend(adap->fe[1]);\n\t\tdvb_frontend_detach(adap->fe[1]);\n\t\tadap->fe[1] = NULL;\n\t}\n\tif (adap->fe[0]) {\n\t\tdvb_unregister_frontend(adap->fe[0]);\n\t\tdvb_frontend_detach(adap->fe[0]);\n\t\tadap->fe[0] = NULL;\n\t}\n\n\tdvb_module_release(adap->i2c_client_tuner);\n\tadap->i2c_client_tuner = NULL;\n\tdvb_module_release(adap->i2c_client_demod[1]);\n\tadap->i2c_client_demod[1] = NULL;\n\tdvb_module_release(adap->i2c_client_demod[0]);\n\tadap->i2c_client_demod[0] = NULL;\n\n\treturn 0;\n}\n\nstatic void pvr2_dvb_destroy(struct pvr2_dvb_adapter *adap)\n{\n\tpvr2_dvb_stream_end(adap);\n\tpvr2_dvb_frontend_exit(adap);\n\tpvr2_dvb_adapter_exit(adap);\n\tpvr2_channel_done(&adap->channel);\n\tkfree(adap);\n}\n\nstatic void pvr2_dvb_internal_check(struct pvr2_channel *chp)\n{\n\tstruct pvr2_dvb_adapter *adap;\n\tadap = container_of(chp, struct pvr2_dvb_adapter, channel);\n\tif (!adap->channel.mc_head->disconnect_flag) return;\n\tpvr2_dvb_destroy(adap);\n}\n\nstruct pvr2_dvb_adapter *pvr2_dvb_create(struct pvr2_context *pvr)\n{\n\tint ret = 0;\n\tstruct pvr2_dvb_adapter *adap;\n\tif (!pvr->hdw->hdw_desc->dvb_props) {\n\t\t \n\t\treturn NULL;\n\t}\n\tadap = kzalloc(sizeof(*adap), GFP_KERNEL);\n\tif (!adap) return adap;\n\tpvr2_channel_init(&adap->channel, pvr);\n\tadap->channel.check_func = pvr2_dvb_internal_check;\n\tinit_waitqueue_head(&adap->buffer_wait_data);\n\tmutex_init(&adap->lock);\n\tret = pvr2_dvb_adapter_init(adap);\n\tif (ret < 0) goto fail1;\n\tret = pvr2_dvb_frontend_init(adap);\n\tif (ret < 0) goto fail2;\n\treturn adap;\n\nfail2:\n\tpvr2_dvb_adapter_exit(adap);\nfail1:\n\tpvr2_channel_done(&adap->channel);\n\treturn NULL;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}