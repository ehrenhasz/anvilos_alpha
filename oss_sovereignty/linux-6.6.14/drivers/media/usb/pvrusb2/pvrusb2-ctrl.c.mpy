{
  "module_name": "pvrusb2-ctrl.c",
  "hash_id": "16bb6295bef23d921fde409ac5d6e39caadc2cf00e004c2727e51f369d7e7039",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c",
  "human_readable_source": "\n \n\n#include \"pvrusb2-ctrl.h\"\n#include \"pvrusb2-hdw-internal.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n\n\nstatic int pvr2_ctrl_range_check(struct pvr2_ctrl *cptr,int val)\n{\n\tif (cptr->info->check_value) {\n\t\tif (!cptr->info->check_value(cptr,val)) return -ERANGE;\n\t} else if (cptr->info->type == pvr2_ctl_enum) {\n\t\tif (val < 0) return -ERANGE;\n\t\tif (val >= cptr->info->def.type_enum.count) return -ERANGE;\n\t} else {\n\t\tint lim;\n\t\tlim = cptr->info->def.type_int.min_value;\n\t\tif (cptr->info->get_min_value) {\n\t\t\tcptr->info->get_min_value(cptr,&lim);\n\t\t}\n\t\tif (val < lim) return -ERANGE;\n\t\tlim = cptr->info->def.type_int.max_value;\n\t\tif (cptr->info->get_max_value) {\n\t\t\tcptr->info->get_max_value(cptr,&lim);\n\t\t}\n\t\tif (val > lim) return -ERANGE;\n\t}\n\treturn 0;\n}\n\n\n \nint pvr2_ctrl_set_value(struct pvr2_ctrl *cptr,int val)\n{\n\treturn pvr2_ctrl_set_mask_value(cptr,~0,val);\n}\n\n\n \nint pvr2_ctrl_set_mask_value(struct pvr2_ctrl *cptr,int mask,int val)\n{\n\tint ret = 0;\n\tif (!cptr) return -EINVAL;\n\tLOCK_TAKE(cptr->hdw->big_lock); do {\n\t\tif (cptr->info->set_value) {\n\t\t\tif (cptr->info->type == pvr2_ctl_bitmask) {\n\t\t\t\tmask &= cptr->info->def.type_bitmask.valid_bits;\n\t\t\t} else if ((cptr->info->type == pvr2_ctl_int)||\n\t\t\t\t   (cptr->info->type == pvr2_ctl_enum)) {\n\t\t\t\tret = pvr2_ctrl_range_check(cptr,val);\n\t\t\t\tif (ret < 0) break;\n\t\t\t} else if (cptr->info->type != pvr2_ctl_bool) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = cptr->info->set_value(cptr,mask,val);\n\t\t} else {\n\t\t\tret = -EPERM;\n\t\t}\n\t} while(0); LOCK_GIVE(cptr->hdw->big_lock);\n\treturn ret;\n}\n\n\n \nint pvr2_ctrl_get_value(struct pvr2_ctrl *cptr,int *valptr)\n{\n\tint ret = 0;\n\tif (!cptr) return -EINVAL;\n\tLOCK_TAKE(cptr->hdw->big_lock); do {\n\t\tret = cptr->info->get_value(cptr,valptr);\n\t} while(0); LOCK_GIVE(cptr->hdw->big_lock);\n\treturn ret;\n}\n\n\n \nenum pvr2_ctl_type pvr2_ctrl_get_type(struct pvr2_ctrl *cptr)\n{\n\tif (!cptr) return pvr2_ctl_int;\n\treturn cptr->info->type;\n}\n\n\n \nint pvr2_ctrl_get_max(struct pvr2_ctrl *cptr)\n{\n\tint ret = 0;\n\tif (!cptr) return 0;\n\tLOCK_TAKE(cptr->hdw->big_lock); do {\n\t\tif (cptr->info->get_max_value) {\n\t\t\tcptr->info->get_max_value(cptr,&ret);\n\t\t} else if (cptr->info->type == pvr2_ctl_int) {\n\t\t\tret = cptr->info->def.type_int.max_value;\n\t\t}\n\t} while(0); LOCK_GIVE(cptr->hdw->big_lock);\n\treturn ret;\n}\n\n\n \nint pvr2_ctrl_get_min(struct pvr2_ctrl *cptr)\n{\n\tint ret = 0;\n\tif (!cptr) return 0;\n\tLOCK_TAKE(cptr->hdw->big_lock); do {\n\t\tif (cptr->info->get_min_value) {\n\t\t\tcptr->info->get_min_value(cptr,&ret);\n\t\t} else if (cptr->info->type == pvr2_ctl_int) {\n\t\t\tret = cptr->info->def.type_int.min_value;\n\t\t}\n\t} while(0); LOCK_GIVE(cptr->hdw->big_lock);\n\treturn ret;\n}\n\n\n \nint pvr2_ctrl_get_def(struct pvr2_ctrl *cptr, int *valptr)\n{\n\tint ret = 0;\n\tif (!cptr) return -EINVAL;\n\tLOCK_TAKE(cptr->hdw->big_lock); do {\n\t\tif (cptr->info->get_def_value) {\n\t\t\tret = cptr->info->get_def_value(cptr, valptr);\n\t\t} else {\n\t\t\t*valptr = cptr->info->default_value;\n\t\t}\n\t} while(0); LOCK_GIVE(cptr->hdw->big_lock);\n\treturn ret;\n}\n\n\n \nint pvr2_ctrl_get_cnt(struct pvr2_ctrl *cptr)\n{\n\tint ret = 0;\n\tif (!cptr) return 0;\n\tLOCK_TAKE(cptr->hdw->big_lock); do {\n\t\tif (cptr->info->type == pvr2_ctl_enum) {\n\t\t\tret = cptr->info->def.type_enum.count;\n\t\t}\n\t} while(0); LOCK_GIVE(cptr->hdw->big_lock);\n\treturn ret;\n}\n\n\n \nint pvr2_ctrl_get_mask(struct pvr2_ctrl *cptr)\n{\n\tint ret = 0;\n\tif (!cptr) return 0;\n\tLOCK_TAKE(cptr->hdw->big_lock); do {\n\t\tif (cptr->info->type == pvr2_ctl_bitmask) {\n\t\t\tret = cptr->info->def.type_bitmask.valid_bits;\n\t\t}\n\t} while(0); LOCK_GIVE(cptr->hdw->big_lock);\n\treturn ret;\n}\n\n\n \nconst char *pvr2_ctrl_get_name(struct pvr2_ctrl *cptr)\n{\n\tif (!cptr) return NULL;\n\treturn cptr->info->name;\n}\n\n\n \nconst char *pvr2_ctrl_get_desc(struct pvr2_ctrl *cptr)\n{\n\tif (!cptr) return NULL;\n\treturn cptr->info->desc;\n}\n\n\n \nint pvr2_ctrl_get_valname(struct pvr2_ctrl *cptr,int val,\n\t\t\t  char *bptr,unsigned int bmax,\n\t\t\t  unsigned int *blen)\n{\n\tint ret = -EINVAL;\n\tif (!cptr) return 0;\n\t*blen = 0;\n\tLOCK_TAKE(cptr->hdw->big_lock); do {\n\t\tif (cptr->info->type == pvr2_ctl_enum) {\n\t\t\tconst char * const *names;\n\t\t\tnames = cptr->info->def.type_enum.value_names;\n\t\t\tif (pvr2_ctrl_range_check(cptr,val) == 0) {\n\t\t\t\tif (names[val]) {\n\t\t\t\t\t*blen = scnprintf(\n\t\t\t\t\t\tbptr,bmax,\"%s\",\n\t\t\t\t\t\tnames[val]);\n\t\t\t\t} else {\n\t\t\t\t\t*blen = 0;\n\t\t\t\t}\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t} else if (cptr->info->type == pvr2_ctl_bitmask) {\n\t\t\tconst char **names;\n\t\t\tunsigned int idx;\n\t\t\tint msk;\n\t\t\tnames = cptr->info->def.type_bitmask.bit_names;\n\t\t\tval &= cptr->info->def.type_bitmask.valid_bits;\n\t\t\tfor (idx = 0, msk = 1; val; idx++, msk <<= 1) {\n\t\t\t\tif (val & msk) {\n\t\t\t\t\t*blen = scnprintf(bptr,bmax,\"%s\",\n\t\t\t\t\t\t\t  names[idx]);\n\t\t\t\t\tret = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while(0); LOCK_GIVE(cptr->hdw->big_lock);\n\treturn ret;\n}\n\n\n \nint pvr2_ctrl_get_v4lid(struct pvr2_ctrl *cptr)\n{\n\tif (!cptr) return 0;\n\treturn cptr->info->v4l_id;\n}\n\n\nunsigned int pvr2_ctrl_get_v4lflags(struct pvr2_ctrl *cptr)\n{\n\tunsigned int flags = 0;\n\n\tif (cptr->info->get_v4lflags) {\n\t\tflags = cptr->info->get_v4lflags(cptr);\n\t}\n\n\tif (cptr->info->set_value) {\n\t\tflags &= ~V4L2_CTRL_FLAG_READ_ONLY;\n\t} else {\n\t\tflags |= V4L2_CTRL_FLAG_READ_ONLY;\n\t}\n\n\treturn flags;\n}\n\n\n \nint pvr2_ctrl_is_writable(struct pvr2_ctrl *cptr)\n{\n\tif (!cptr) return 0;\n\treturn cptr->info->set_value != NULL;\n}\n\n\n \nint pvr2_ctrl_has_custom_symbols(struct pvr2_ctrl *cptr)\n{\n\tif (!cptr) return 0;\n\tif (!cptr->info->val_to_sym) return 0;\n\tif (!cptr->info->sym_to_val) return 0;\n\treturn !0;\n}\n\n\n \nint pvr2_ctrl_custom_value_to_sym(struct pvr2_ctrl *cptr,\n\t\t\t\t  int mask,int val,\n\t\t\t\t  char *buf,unsigned int maxlen,\n\t\t\t\t  unsigned int *len)\n{\n\tif (!cptr) return -EINVAL;\n\tif (!cptr->info->val_to_sym) return -EINVAL;\n\treturn cptr->info->val_to_sym(cptr,mask,val,buf,maxlen,len);\n}\n\n\n \nint pvr2_ctrl_custom_sym_to_value(struct pvr2_ctrl *cptr,\n\t\t\t\t  const char *buf,unsigned int len,\n\t\t\t\t  int *maskptr,int *valptr)\n{\n\tif (!cptr) return -EINVAL;\n\tif (!cptr->info->sym_to_val) return -EINVAL;\n\treturn cptr->info->sym_to_val(cptr,buf,len,maskptr,valptr);\n}\n\n\nstatic unsigned int gen_bitmask_string(int msk,int val,int msk_only,\n\t\t\t\t       const char **names,\n\t\t\t\t       char *ptr,unsigned int len)\n{\n\tunsigned int idx;\n\tlong sm,um;\n\tint spcFl;\n\tunsigned int uc,cnt;\n\tconst char *idStr;\n\n\tspcFl = 0;\n\tuc = 0;\n\tum = 0;\n\tfor (idx = 0, sm = 1; msk; idx++, sm <<= 1) {\n\t\tif (sm & msk) {\n\t\t\tmsk &= ~sm;\n\t\t\tidStr = names[idx];\n\t\t\tif (idStr) {\n\t\t\t\tcnt = scnprintf(ptr,len,\"%s%s%s\",\n\t\t\t\t\t\t(spcFl ? \" \" : \"\"),\n\t\t\t\t\t\t(msk_only ? \"\" :\n\t\t\t\t\t\t ((val & sm) ? \"+\" : \"-\")),\n\t\t\t\t\t\tidStr);\n\t\t\t\tptr += cnt; len -= cnt; uc += cnt;\n\t\t\t\tspcFl = !0;\n\t\t\t} else {\n\t\t\t\tum |= sm;\n\t\t\t}\n\t\t}\n\t}\n\tif (um) {\n\t\tif (msk_only) {\n\t\t\tcnt = scnprintf(ptr,len,\"%s0x%lx\",\n\t\t\t\t\t(spcFl ? \" \" : \"\"),\n\t\t\t\t\tum);\n\t\t\tptr += cnt; len -= cnt; uc += cnt;\n\t\t\tspcFl = !0;\n\t\t} else if (um & val) {\n\t\t\tcnt = scnprintf(ptr,len,\"%s+0x%lx\",\n\t\t\t\t\t(spcFl ? \" \" : \"\"),\n\t\t\t\t\tum & val);\n\t\t\tptr += cnt; len -= cnt; uc += cnt;\n\t\t\tspcFl = !0;\n\t\t} else if (um & ~val) {\n\t\t\tcnt = scnprintf(ptr,len,\"%s+0x%lx\",\n\t\t\t\t\t(spcFl ? \" \" : \"\"),\n\t\t\t\t\tum & ~val);\n\t\t\tptr += cnt; len -= cnt; uc += cnt;\n\t\t\tspcFl = !0;\n\t\t}\n\t}\n\treturn uc;\n}\n\n\nstatic const char *boolNames[] = {\n\t\"false\",\n\t\"true\",\n\t\"no\",\n\t\"yes\",\n};\n\n\nstatic int parse_token(const char *ptr,unsigned int len,\n\t\t       int *valptr,\n\t\t       const char * const *names, unsigned int namecnt)\n{\n\tunsigned int slen;\n\tunsigned int idx;\n\t*valptr = 0;\n\tif (!names) namecnt = 0;\n\tfor (idx = 0; idx < namecnt; idx++) {\n\t\tif (!names[idx]) continue;\n\t\tslen = strlen(names[idx]);\n\t\tif (slen != len) continue;\n\t\tif (memcmp(names[idx],ptr,slen)) continue;\n\t\t*valptr = idx;\n\t\treturn 0;\n\t}\n\treturn kstrtoint(ptr, 0, valptr) ? -EINVAL : 1;\n}\n\n\nstatic int parse_mtoken(const char *ptr,unsigned int len,\n\t\t\tint *valptr,\n\t\t\tconst char **names,int valid_bits)\n{\n\tunsigned int slen;\n\tunsigned int idx;\n\tint msk;\n\t*valptr = 0;\n\tfor (idx = 0, msk = 1; valid_bits; idx++, msk <<= 1) {\n\t\tif (!(msk & valid_bits)) continue;\n\t\tvalid_bits &= ~msk;\n\t\tif (!names[idx]) continue;\n\t\tslen = strlen(names[idx]);\n\t\tif (slen != len) continue;\n\t\tif (memcmp(names[idx],ptr,slen)) continue;\n\t\t*valptr = msk;\n\t\treturn 0;\n\t}\n\treturn kstrtoint(ptr, 0, valptr);\n}\n\n\nstatic int parse_tlist(const char *ptr,unsigned int len,\n\t\t       int *maskptr,int *valptr,\n\t\t       const char **names,int valid_bits)\n{\n\tunsigned int cnt;\n\tint mask,val,kv,mode,ret;\n\tmask = 0;\n\tval = 0;\n\tret = 0;\n\twhile (len) {\n\t\tcnt = 0;\n\t\twhile ((cnt < len) &&\n\t\t       ((ptr[cnt] <= 32) ||\n\t\t\t(ptr[cnt] >= 127))) cnt++;\n\t\tptr += cnt;\n\t\tlen -= cnt;\n\t\tmode = 0;\n\t\tif ((*ptr == '-') || (*ptr == '+')) {\n\t\t\tmode = (*ptr == '-') ? -1 : 1;\n\t\t\tptr++;\n\t\t\tlen--;\n\t\t}\n\t\tcnt = 0;\n\t\twhile (cnt < len) {\n\t\t\tif (ptr[cnt] <= 32) break;\n\t\t\tif (ptr[cnt] >= 127) break;\n\t\t\tcnt++;\n\t\t}\n\t\tif (!cnt) break;\n\t\tif (parse_mtoken(ptr,cnt,&kv,names,valid_bits)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tptr += cnt;\n\t\tlen -= cnt;\n\t\tswitch (mode) {\n\t\tcase 0:\n\t\t\tmask = valid_bits;\n\t\t\tval |= kv;\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tmask |= kv;\n\t\t\tval &= ~kv;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmask |= kv;\n\t\t\tval |= kv;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\t*maskptr = mask;\n\t*valptr = val;\n\treturn ret;\n}\n\n\n \nint pvr2_ctrl_sym_to_value(struct pvr2_ctrl *cptr,\n\t\t\t   const char *ptr,unsigned int len,\n\t\t\t   int *maskptr,int *valptr)\n{\n\tint ret = -EINVAL;\n\tunsigned int cnt;\n\n\t*maskptr = 0;\n\t*valptr = 0;\n\n\tcnt = 0;\n\twhile ((cnt < len) && ((ptr[cnt] <= 32) || (ptr[cnt] >= 127))) cnt++;\n\tlen -= cnt; ptr += cnt;\n\tcnt = 0;\n\twhile ((cnt < len) && ((ptr[len-(cnt+1)] <= 32) ||\n\t\t\t       (ptr[len-(cnt+1)] >= 127))) cnt++;\n\tlen -= cnt;\n\n\tif (!len) return -EINVAL;\n\n\tLOCK_TAKE(cptr->hdw->big_lock); do {\n\t\tif (cptr->info->type == pvr2_ctl_int) {\n\t\t\tret = parse_token(ptr,len,valptr,NULL,0);\n\t\t\tif (ret >= 0) {\n\t\t\t\tret = pvr2_ctrl_range_check(cptr,*valptr);\n\t\t\t}\n\t\t\t*maskptr = ~0;\n\t\t} else if (cptr->info->type == pvr2_ctl_bool) {\n\t\t\tret = parse_token(ptr,len,valptr,boolNames,\n\t\t\t\t\t  ARRAY_SIZE(boolNames));\n\t\t\tif (ret == 1) {\n\t\t\t\t*valptr = *valptr ? !0 : 0;\n\t\t\t} else if (ret == 0) {\n\t\t\t\t*valptr = (*valptr & 1) ? !0 : 0;\n\t\t\t}\n\t\t\t*maskptr = 1;\n\t\t} else if (cptr->info->type == pvr2_ctl_enum) {\n\t\t\tret = parse_token(\n\t\t\t\tptr,len,valptr,\n\t\t\t\tcptr->info->def.type_enum.value_names,\n\t\t\t\tcptr->info->def.type_enum.count);\n\t\t\tif (ret >= 0) {\n\t\t\t\tret = pvr2_ctrl_range_check(cptr,*valptr);\n\t\t\t}\n\t\t\t*maskptr = ~0;\n\t\t} else if (cptr->info->type == pvr2_ctl_bitmask) {\n\t\t\tret = parse_tlist(\n\t\t\t\tptr,len,maskptr,valptr,\n\t\t\t\tcptr->info->def.type_bitmask.bit_names,\n\t\t\t\tcptr->info->def.type_bitmask.valid_bits);\n\t\t}\n\t} while(0); LOCK_GIVE(cptr->hdw->big_lock);\n\treturn ret;\n}\n\n\n \nint pvr2_ctrl_value_to_sym_internal(struct pvr2_ctrl *cptr,\n\t\t\t\t    int mask,int val,\n\t\t\t\t    char *buf,unsigned int maxlen,\n\t\t\t\t    unsigned int *len)\n{\n\tint ret = -EINVAL;\n\n\t*len = 0;\n\tif (cptr->info->type == pvr2_ctl_int) {\n\t\t*len = scnprintf(buf,maxlen,\"%d\",val);\n\t\tret = 0;\n\t} else if (cptr->info->type == pvr2_ctl_bool) {\n\t\t*len = scnprintf(buf,maxlen,\"%s\",val ? \"true\" : \"false\");\n\t\tret = 0;\n\t} else if (cptr->info->type == pvr2_ctl_enum) {\n\t\tconst char * const *names;\n\t\tnames = cptr->info->def.type_enum.value_names;\n\t\tif ((val >= 0) &&\n\t\t    (val < cptr->info->def.type_enum.count)) {\n\t\t\tif (names[val]) {\n\t\t\t\t*len = scnprintf(\n\t\t\t\t\tbuf,maxlen,\"%s\",\n\t\t\t\t\tnames[val]);\n\t\t\t} else {\n\t\t\t\t*len = 0;\n\t\t\t}\n\t\t\tret = 0;\n\t\t}\n\t} else if (cptr->info->type == pvr2_ctl_bitmask) {\n\t\t*len = gen_bitmask_string(\n\t\t\tval & mask & cptr->info->def.type_bitmask.valid_bits,\n\t\t\t~0,!0,\n\t\t\tcptr->info->def.type_bitmask.bit_names,\n\t\t\tbuf,maxlen);\n\t}\n\treturn ret;\n}\n\n\n \nint pvr2_ctrl_value_to_sym(struct pvr2_ctrl *cptr,\n\t\t\t   int mask,int val,\n\t\t\t   char *buf,unsigned int maxlen,\n\t\t\t   unsigned int *len)\n{\n\tint ret;\n\tLOCK_TAKE(cptr->hdw->big_lock); do {\n\t\tret = pvr2_ctrl_value_to_sym_internal(cptr,mask,val,\n\t\t\t\t\t\t      buf,maxlen,len);\n\t} while(0); LOCK_GIVE(cptr->hdw->big_lock);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}