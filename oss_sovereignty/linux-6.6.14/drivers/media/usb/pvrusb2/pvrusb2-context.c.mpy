{
  "module_name": "pvrusb2-context.c",
  "hash_id": "f58093bb14a60b8cb7bf8942578eca5bae5fce27a9bf00818b64cbea778b899c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/pvrusb2/pvrusb2-context.c",
  "human_readable_source": "\n \n\n#include \"pvrusb2-context.h\"\n#include \"pvrusb2-io.h\"\n#include \"pvrusb2-ioread.h\"\n#include \"pvrusb2-hdw.h\"\n#include \"pvrusb2-debug.h\"\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic struct pvr2_context *pvr2_context_exist_first;\nstatic struct pvr2_context *pvr2_context_exist_last;\nstatic struct pvr2_context *pvr2_context_notify_first;\nstatic struct pvr2_context *pvr2_context_notify_last;\nstatic DEFINE_MUTEX(pvr2_context_mutex);\nstatic DECLARE_WAIT_QUEUE_HEAD(pvr2_context_sync_data);\nstatic DECLARE_WAIT_QUEUE_HEAD(pvr2_context_cleanup_data);\nstatic int pvr2_context_cleanup_flag;\nstatic int pvr2_context_cleaned_flag;\nstatic struct task_struct *pvr2_context_thread_ptr;\n\n\nstatic void pvr2_context_set_notify(struct pvr2_context *mp, int fl)\n{\n\tint signal_flag = 0;\n\tmutex_lock(&pvr2_context_mutex);\n\tif (fl) {\n\t\tif (!mp->notify_flag) {\n\t\t\tsignal_flag = (pvr2_context_notify_first == NULL);\n\t\t\tmp->notify_prev = pvr2_context_notify_last;\n\t\t\tmp->notify_next = NULL;\n\t\t\tpvr2_context_notify_last = mp;\n\t\t\tif (mp->notify_prev) {\n\t\t\t\tmp->notify_prev->notify_next = mp;\n\t\t\t} else {\n\t\t\t\tpvr2_context_notify_first = mp;\n\t\t\t}\n\t\t\tmp->notify_flag = !0;\n\t\t}\n\t} else {\n\t\tif (mp->notify_flag) {\n\t\t\tmp->notify_flag = 0;\n\t\t\tif (mp->notify_next) {\n\t\t\t\tmp->notify_next->notify_prev = mp->notify_prev;\n\t\t\t} else {\n\t\t\t\tpvr2_context_notify_last = mp->notify_prev;\n\t\t\t}\n\t\t\tif (mp->notify_prev) {\n\t\t\t\tmp->notify_prev->notify_next = mp->notify_next;\n\t\t\t} else {\n\t\t\t\tpvr2_context_notify_first = mp->notify_next;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&pvr2_context_mutex);\n\tif (signal_flag) wake_up(&pvr2_context_sync_data);\n}\n\n\nstatic void pvr2_context_destroy(struct pvr2_context *mp)\n{\n\tpvr2_trace(PVR2_TRACE_CTXT,\"pvr2_context %p (destroy)\",mp);\n\tpvr2_hdw_destroy(mp->hdw);\n\tpvr2_context_set_notify(mp, 0);\n\tmutex_lock(&pvr2_context_mutex);\n\tif (mp->exist_next) {\n\t\tmp->exist_next->exist_prev = mp->exist_prev;\n\t} else {\n\t\tpvr2_context_exist_last = mp->exist_prev;\n\t}\n\tif (mp->exist_prev) {\n\t\tmp->exist_prev->exist_next = mp->exist_next;\n\t} else {\n\t\tpvr2_context_exist_first = mp->exist_next;\n\t}\n\tif (!pvr2_context_exist_first) {\n\t\t \n\t\twake_up(&pvr2_context_sync_data);\n\t}\n\tmutex_unlock(&pvr2_context_mutex);\n\tkfree(mp);\n}\n\n\nstatic void pvr2_context_notify(struct pvr2_context *mp)\n{\n\tpvr2_context_set_notify(mp,!0);\n}\n\n\nstatic void pvr2_context_check(struct pvr2_context *mp)\n{\n\tstruct pvr2_channel *ch1, *ch2;\n\tpvr2_trace(PVR2_TRACE_CTXT,\n\t\t   \"pvr2_context %p (notify)\", mp);\n\tif (!mp->initialized_flag && !mp->disconnect_flag) {\n\t\tmp->initialized_flag = !0;\n\t\tpvr2_trace(PVR2_TRACE_CTXT,\n\t\t\t   \"pvr2_context %p (initialize)\", mp);\n\t\t \n\t\tif (pvr2_hdw_initialize(mp->hdw,\n\t\t\t\t\t(void (*)(void *))pvr2_context_notify,\n\t\t\t\t\tmp)) {\n\t\t\tmp->video_stream.stream =\n\t\t\t\tpvr2_hdw_get_video_stream(mp->hdw);\n\t\t\t \n\t\t\tif (mp->setup_func) mp->setup_func(mp);\n\t\t} else {\n\t\t\tpvr2_trace(PVR2_TRACE_CTXT,\n\t\t\t\t   \"pvr2_context %p (thread skipping setup)\",\n\t\t\t\t   mp);\n\t\t\t \n\t\t}\n\t}\n\n\tfor (ch1 = mp->mc_first; ch1; ch1 = ch2) {\n\t\tch2 = ch1->mc_next;\n\t\tif (ch1->check_func) ch1->check_func(ch1);\n\t}\n\n\tif (mp->disconnect_flag && !mp->mc_first) {\n\t\t \n\t\tpvr2_context_destroy(mp);\n\t\treturn;\n\t}\n}\n\n\nstatic int pvr2_context_shutok(void)\n{\n\treturn pvr2_context_cleanup_flag && (pvr2_context_exist_first == NULL);\n}\n\n\nstatic int pvr2_context_thread_func(void *foo)\n{\n\tstruct pvr2_context *mp;\n\n\tpvr2_trace(PVR2_TRACE_CTXT,\"pvr2_context thread start\");\n\n\tdo {\n\t\twhile ((mp = pvr2_context_notify_first) != NULL) {\n\t\t\tpvr2_context_set_notify(mp, 0);\n\t\t\tpvr2_context_check(mp);\n\t\t}\n\t\twait_event_interruptible(\n\t\t\tpvr2_context_sync_data,\n\t\t\t((pvr2_context_notify_first != NULL) ||\n\t\t\t pvr2_context_shutok()));\n\t} while (!pvr2_context_shutok());\n\n\tpvr2_context_cleaned_flag = !0;\n\twake_up(&pvr2_context_cleanup_data);\n\n\tpvr2_trace(PVR2_TRACE_CTXT,\"pvr2_context thread cleaned up\");\n\n\twait_event_interruptible(\n\t\tpvr2_context_sync_data,\n\t\tkthread_should_stop());\n\n\tpvr2_trace(PVR2_TRACE_CTXT,\"pvr2_context thread end\");\n\n\treturn 0;\n}\n\n\nint pvr2_context_global_init(void)\n{\n\tpvr2_context_thread_ptr = kthread_run(pvr2_context_thread_func,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      \"pvrusb2-context\");\n\treturn IS_ERR(pvr2_context_thread_ptr) ? -ENOMEM : 0;\n}\n\n\nvoid pvr2_context_global_done(void)\n{\n\tpvr2_context_cleanup_flag = !0;\n\twake_up(&pvr2_context_sync_data);\n\twait_event_interruptible(\n\t\tpvr2_context_cleanup_data,\n\t\tpvr2_context_cleaned_flag);\n\tkthread_stop(pvr2_context_thread_ptr);\n}\n\n\nstruct pvr2_context *pvr2_context_create(\n\tstruct usb_interface *intf,\n\tconst struct usb_device_id *devid,\n\tvoid (*setup_func)(struct pvr2_context *))\n{\n\tstruct pvr2_context *mp = NULL;\n\tmp = kzalloc(sizeof(*mp),GFP_KERNEL);\n\tif (!mp) goto done;\n\tpvr2_trace(PVR2_TRACE_CTXT,\"pvr2_context %p (create)\",mp);\n\tmp->setup_func = setup_func;\n\tmutex_init(&mp->mutex);\n\tmutex_lock(&pvr2_context_mutex);\n\tmp->exist_prev = pvr2_context_exist_last;\n\tmp->exist_next = NULL;\n\tpvr2_context_exist_last = mp;\n\tif (mp->exist_prev) {\n\t\tmp->exist_prev->exist_next = mp;\n\t} else {\n\t\tpvr2_context_exist_first = mp;\n\t}\n\tmutex_unlock(&pvr2_context_mutex);\n\tmp->hdw = pvr2_hdw_create(intf,devid);\n\tif (!mp->hdw) {\n\t\tpvr2_context_destroy(mp);\n\t\tmp = NULL;\n\t\tgoto done;\n\t}\n\tpvr2_context_set_notify(mp, !0);\n done:\n\treturn mp;\n}\n\n\nstatic void pvr2_context_reset_input_limits(struct pvr2_context *mp)\n{\n\tunsigned int tmsk,mmsk;\n\tstruct pvr2_channel *cp;\n\tstruct pvr2_hdw *hdw = mp->hdw;\n\tmmsk = pvr2_hdw_get_input_available(hdw);\n\ttmsk = mmsk;\n\tfor (cp = mp->mc_first; cp; cp = cp->mc_next) {\n\t\tif (!cp->input_mask) continue;\n\t\ttmsk &= cp->input_mask;\n\t}\n\tpvr2_hdw_set_input_allowed(hdw,mmsk,tmsk);\n\tpvr2_hdw_commit_ctl(hdw);\n}\n\n\nstatic void pvr2_context_enter(struct pvr2_context *mp)\n{\n\tmutex_lock(&mp->mutex);\n}\n\n\nstatic void pvr2_context_exit(struct pvr2_context *mp)\n{\n\tint destroy_flag = 0;\n\tif (!(mp->mc_first || !mp->disconnect_flag)) {\n\t\tdestroy_flag = !0;\n\t}\n\tmutex_unlock(&mp->mutex);\n\tif (destroy_flag) pvr2_context_notify(mp);\n}\n\n\nvoid pvr2_context_disconnect(struct pvr2_context *mp)\n{\n\tpvr2_hdw_disconnect(mp->hdw);\n\tmp->disconnect_flag = !0;\n\tif (!pvr2_context_shutok())\n\t\tpvr2_context_notify(mp);\n}\n\n\nvoid pvr2_channel_init(struct pvr2_channel *cp,struct pvr2_context *mp)\n{\n\tpvr2_context_enter(mp);\n\tcp->hdw = mp->hdw;\n\tcp->mc_head = mp;\n\tcp->mc_next = NULL;\n\tcp->mc_prev = mp->mc_last;\n\tif (mp->mc_last) {\n\t\tmp->mc_last->mc_next = cp;\n\t} else {\n\t\tmp->mc_first = cp;\n\t}\n\tmp->mc_last = cp;\n\tpvr2_context_exit(mp);\n}\n\n\nstatic void pvr2_channel_disclaim_stream(struct pvr2_channel *cp)\n{\n\tif (!cp->stream) return;\n\tpvr2_stream_kill(cp->stream->stream);\n\tcp->stream->user = NULL;\n\tcp->stream = NULL;\n}\n\n\nvoid pvr2_channel_done(struct pvr2_channel *cp)\n{\n\tstruct pvr2_context *mp = cp->mc_head;\n\tpvr2_context_enter(mp);\n\tcp->input_mask = 0;\n\tpvr2_channel_disclaim_stream(cp);\n\tpvr2_context_reset_input_limits(mp);\n\tif (cp->mc_next) {\n\t\tcp->mc_next->mc_prev = cp->mc_prev;\n\t} else {\n\t\tmp->mc_last = cp->mc_prev;\n\t}\n\tif (cp->mc_prev) {\n\t\tcp->mc_prev->mc_next = cp->mc_next;\n\t} else {\n\t\tmp->mc_first = cp->mc_next;\n\t}\n\tcp->hdw = NULL;\n\tpvr2_context_exit(mp);\n}\n\n\nint pvr2_channel_limit_inputs(struct pvr2_channel *cp,unsigned int cmsk)\n{\n\tunsigned int tmsk,mmsk;\n\tint ret = 0;\n\tstruct pvr2_channel *p2;\n\tstruct pvr2_hdw *hdw = cp->hdw;\n\n\tmmsk = pvr2_hdw_get_input_available(hdw);\n\tcmsk &= mmsk;\n\tif (cmsk == cp->input_mask) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tpvr2_context_enter(cp->mc_head);\n\tdo {\n\t\tif (!cmsk) {\n\t\t\tcp->input_mask = 0;\n\t\t\tpvr2_context_reset_input_limits(cp->mc_head);\n\t\t\tbreak;\n\t\t}\n\t\ttmsk = mmsk;\n\t\tfor (p2 = cp->mc_head->mc_first; p2; p2 = p2->mc_next) {\n\t\t\tif (p2 == cp) continue;\n\t\t\tif (!p2->input_mask) continue;\n\t\t\ttmsk &= p2->input_mask;\n\t\t}\n\t\tif (!(tmsk & cmsk)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\ttmsk &= cmsk;\n\t\tif ((ret = pvr2_hdw_set_input_allowed(hdw,mmsk,tmsk)) != 0) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tcp->input_mask = cmsk;\n\t\tpvr2_hdw_commit_ctl(hdw);\n\t} while (0);\n\tpvr2_context_exit(cp->mc_head);\n\treturn ret;\n}\n\n\nunsigned int pvr2_channel_get_limited_inputs(struct pvr2_channel *cp)\n{\n\treturn cp->input_mask;\n}\n\n\nint pvr2_channel_claim_stream(struct pvr2_channel *cp,\n\t\t\t      struct pvr2_context_stream *sp)\n{\n\tint code = 0;\n\tpvr2_context_enter(cp->mc_head); do {\n\t\tif (sp == cp->stream) break;\n\t\tif (sp && sp->user) {\n\t\t\tcode = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t\tpvr2_channel_disclaim_stream(cp);\n\t\tif (!sp) break;\n\t\tsp->user = cp;\n\t\tcp->stream = sp;\n\t} while (0);\n\tpvr2_context_exit(cp->mc_head);\n\treturn code;\n}\n\n\n\nstatic char stream_sync_key[] = {\n\t0x00, 0x00, 0x01, 0xba,\n};\n\nstruct pvr2_ioread *pvr2_channel_create_mpeg_stream(\n\tstruct pvr2_context_stream *sp)\n{\n\tstruct pvr2_ioread *cp;\n\tcp = pvr2_ioread_create();\n\tif (!cp) return NULL;\n\tpvr2_ioread_setup(cp,sp->stream);\n\tpvr2_ioread_set_sync_key(cp,stream_sync_key,sizeof(stream_sync_key));\n\treturn cp;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}