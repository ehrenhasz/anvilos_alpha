{
  "module_name": "spca1528.c",
  "hash_id": "169235d690dfe89dc1dc5efaad4ac8cd7863f1ed65a23fe3e3acb711d2225e1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/spca1528.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"spca1528\"\n\n#include \"gspca.h\"\n#include \"jpeg.h\"\n\nMODULE_AUTHOR(\"Jean-Francois Moine <http://moinejf.free.fr>\");\nMODULE_DESCRIPTION(\"SPCA1528 USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t \n\n\tu8 pkt_seq;\n\n\tu8 jpeg_hdr[JPEG_HDR_SZ];\n};\n\nstatic const struct v4l2_pix_format vga_mode[] = {\n \n\t{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 4 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 2},\n\t{640, 480, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n};\n\n \nstatic void reg_r(struct gspca_dev *gspca_dev,\n\t\t\tu8 req,\n\t\t\tu16 index,\n\t\t\tint len)\n{\n#if USB_BUF_SZ < 64\n#error \"USB buffer too small\"\n#endif\n\tstruct usb_device *dev = gspca_dev->dev;\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\treq,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0x0000,\t\t\t \n\t\t\tindex,\n\t\t\tgspca_dev->usb_buf, len,\n\t\t\t500);\n\tgspca_dbg(gspca_dev, D_USBI, \"GET %02x 0000 %04x %02x\\n\", req, index,\n\t\t  gspca_dev->usb_buf[0]);\n\tif (ret < 0) {\n\t\tpr_err(\"reg_r err %d\\n\", ret);\n\t\tgspca_dev->usb_err = ret;\n\t\t \n\t\tmemset(gspca_dev->usb_buf, 0, USB_BUF_SZ);\n\t}\n}\n\nstatic void reg_w(struct gspca_dev *gspca_dev,\n\t\t\tu8 req,\n\t\t\tu16 value,\n\t\t\tu16 index)\n{\n\tstruct usb_device *dev = gspca_dev->dev;\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tgspca_dbg(gspca_dev, D_USBO, \"SET %02x %04x %04x\\n\", req, value, index);\n\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\treq,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tvalue, index,\n\t\t\tNULL, 0, 500);\n\tif (ret < 0) {\n\t\tpr_err(\"reg_w err %d\\n\", ret);\n\t\tgspca_dev->usb_err = ret;\n\t}\n}\n\nstatic void reg_wb(struct gspca_dev *gspca_dev,\n\t\t\tu8 req,\n\t\t\tu16 value,\n\t\t\tu16 index,\n\t\t\tu8 byte)\n{\n\tstruct usb_device *dev = gspca_dev->dev;\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tgspca_dbg(gspca_dev, D_USBO, \"SET %02x %04x %04x %02x\\n\",\n\t\t  req, value, index, byte);\n\tgspca_dev->usb_buf[0] = byte;\n\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\treq,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tvalue, index,\n\t\t\tgspca_dev->usb_buf, 1, 500);\n\tif (ret < 0) {\n\t\tpr_err(\"reg_w err %d\\n\", ret);\n\t\tgspca_dev->usb_err = ret;\n\t}\n}\n\nstatic void wait_status_0(struct gspca_dev *gspca_dev)\n{\n\tint i, w;\n\n\ti = 16;\n\tw = 0;\n\tdo {\n\t\treg_r(gspca_dev, 0x21, 0x0000, 1);\n\t\tif (gspca_dev->usb_buf[0] == 0)\n\t\t\treturn;\n\t\tw += 15;\n\t\tmsleep(w);\n\t} while (--i > 0);\n\tgspca_err(gspca_dev, \"wait_status_0 timeout\\n\");\n\tgspca_dev->usb_err = -ETIME;\n}\n\nstatic void wait_status_1(struct gspca_dev *gspca_dev)\n{\n\tint i;\n\n\ti = 10;\n\tdo {\n\t\treg_r(gspca_dev, 0x21, 0x0001, 1);\n\t\tmsleep(10);\n\t\tif (gspca_dev->usb_buf[0] == 1) {\n\t\t\treg_wb(gspca_dev, 0x21, 0x0000, 0x0001, 0x00);\n\t\t\treg_r(gspca_dev, 0x21, 0x0001, 1);\n\t\t\treturn;\n\t\t}\n\t} while (--i > 0);\n\tgspca_err(gspca_dev, \"wait_status_1 timeout\\n\");\n\tgspca_dev->usb_err = -ETIME;\n}\n\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\n{\n\treg_wb(gspca_dev, 0xc0, 0x0000, 0x00c0, val);\n}\n\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 val)\n{\n\treg_wb(gspca_dev, 0xc1, 0x0000, 0x00c1, val);\n}\n\nstatic void sethue(struct gspca_dev *gspca_dev, s32 val)\n{\n\treg_wb(gspca_dev, 0xc2, 0x0000, 0x0000, val);\n}\n\nstatic void setcolor(struct gspca_dev *gspca_dev, s32 val)\n{\n\treg_wb(gspca_dev, 0xc3, 0x0000, 0x00c3, val);\n}\n\nstatic void setsharpness(struct gspca_dev *gspca_dev, s32 val)\n{\n\treg_wb(gspca_dev, 0xc4, 0x0000, 0x00c4, val);\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id)\n{\n\tgspca_dev->cam.cam_mode = vga_mode;\n\tgspca_dev->cam.nmodes = ARRAY_SIZE(vga_mode);\n\tgspca_dev->cam.npkt = 128;  \n\t\t\t \n\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\treg_w(gspca_dev, 0x00, 0x0001, 0x2067);\n\treg_w(gspca_dev, 0x00, 0x00d0, 0x206b);\n\treg_w(gspca_dev, 0x00, 0x0000, 0x206c);\n\treg_w(gspca_dev, 0x00, 0x0001, 0x2069);\n\tmsleep(8);\n\treg_w(gspca_dev, 0x00, 0x00c0, 0x206b);\n\treg_w(gspca_dev, 0x00, 0x0000, 0x206c);\n\treg_w(gspca_dev, 0x00, 0x0001, 0x2069);\n\n\treg_r(gspca_dev, 0x20, 0x0000, 1);\n\treg_r(gspca_dev, 0x20, 0x0000, 5);\n\treg_r(gspca_dev, 0x23, 0x0000, 64);\n\tgspca_dbg(gspca_dev, D_PROBE, \"%s%s\\n\", &gspca_dev->usb_buf[0x1c],\n\t\t  &gspca_dev->usb_buf[0x30]);\n\treg_r(gspca_dev, 0x23, 0x0001, 64);\n\treturn gspca_dev->usb_err;\n}\n\n \nstatic int sd_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tu8 mode;\n\n\treg_r(gspca_dev, 0x00, 0x2520, 1);\n\twait_status_0(gspca_dev);\n\treg_w(gspca_dev, 0xc5, 0x0003, 0x0000);\n\twait_status_1(gspca_dev);\n\n\twait_status_0(gspca_dev);\n\tmode = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\n\treg_wb(gspca_dev, 0x25, 0x0000, 0x0004, mode);\n\treg_r(gspca_dev, 0x25, 0x0004, 1);\n\treg_wb(gspca_dev, 0x27, 0x0000, 0x0000, 0x06);\t \n\treg_r(gspca_dev, 0x27, 0x0000, 1);\n\n \n\n\treturn gspca_dev->usb_err;\n}\n\n \nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t \n\tjpeg_define(sd->jpeg_hdr, gspca_dev->pixfmt.height,\n\t\t\tgspca_dev->pixfmt.width,\n\t\t\t0x22);\t\t \n\n\t \n\tjpeg_set_qual(sd->jpeg_hdr, 85);\n\n\treg_r(gspca_dev, 0x00, 0x2520, 1);\n\tmsleep(8);\n\n\t \n\twait_status_0(gspca_dev);\n\treg_w(gspca_dev, 0x31, 0x0000, 0x0004);\t \n\twait_status_1(gspca_dev);\n\twait_status_0(gspca_dev);\n\tmsleep(200);\n\n\tsd->pkt_seq = 0;\n\treturn gspca_dev->usb_err;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\t \n\twait_status_0(gspca_dev);\n\treg_w(gspca_dev, 0x31, 0x0000, 0x0000);\t \n\twait_status_1(gspca_dev);\n\twait_status_0(gspca_dev);\n}\n\n \nstatic void add_packet(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\n\t\t\tint len)\n{\n\tint i;\n\n\ti = 0;\n\tdo {\n\t\tif (data[i] == 0xff) {\n\t\t\tgspca_frame_add(gspca_dev, INTER_PACKET,\n\t\t\t\t\tdata, i + 1);\n\t\t\tlen -= i;\n\t\t\tdata += i;\n\t\t\t*data = 0x00;\n\t\t\ti = 0;\n\t\t}\n\t} while (++i < len);\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t \n\t\t\tint len)\t\t\t \n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstatic const u8 ffd9[] = {0xff, 0xd9};\n\n\t \n\tif (len < 3)\n\t\treturn;\t\t\t\t \n\tif (*data == 0x02) {\n\t\tif (data[1] & 0x02) {\n\t\t\tsd->pkt_seq = !(data[1] & 1);\n\t\t\tadd_packet(gspca_dev, data + 2, len - 2);\n\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET,\n\t\t\t\t\tffd9, 2);\n\t\t\treturn;\n\t\t}\n\t\tif ((data[1] & 1) != sd->pkt_seq)\n\t\t\tgoto err;\n\t\tif (gspca_dev->last_packet_type == LAST_PACKET)\n\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\t\t\t\tsd->jpeg_hdr, JPEG_HDR_SZ);\n\t\tadd_packet(gspca_dev, data + 2, len - 2);\n\t\treturn;\n\t}\nerr:\n\tgspca_dev->last_packet_type = DISCARD_PACKET;\n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\n\tgspca_dev->usb_err = 0;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsetbrightness(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tsetcontrast(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\tsethue(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tsetcolor(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SHARPNESS:\n\t\tsetsharpness(gspca_dev, ctrl->val);\n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 5);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 8, 1, 1);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_HUE, 0, 255, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 8, 1, 1);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_SHARPNESS, 0, 255, 1, 0);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\treturn 0;\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.isoc_init = sd_isoc_init,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.pkt_scan = sd_pkt_scan,\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x04fc, 0x1528)},\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\t \n\tif (intf->cur_altsetting->desc.bInterfaceNumber != 1)\n\t\treturn -ENODEV;\n\n\treturn gspca_dev_probe2(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}