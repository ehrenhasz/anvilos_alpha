{
  "module_name": "benq.c",
  "hash_id": "bad3cb24d31a0c028b8778beae4034a6233735118331835a8aaaacca6c6a29cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/benq.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"benq\"\n\n#include \"gspca.h\"\n\nMODULE_AUTHOR(\"Jean-Francois Moine <http://moinejf.free.fr>\");\nMODULE_DESCRIPTION(\"Benq DC E300 USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t \n};\n\nstatic const struct v4l2_pix_format vga_mode[] = {\n\t{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG},\n};\n\nstatic void sd_isoc_irq(struct urb *urb);\n\n \nstatic void reg_w(struct gspca_dev *gspca_dev,\n\t\t\tu16 value, u16 index)\n{\n\tstruct usb_device *dev = gspca_dev->dev;\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t0x02,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tvalue,\n\t\t\tindex,\n\t\t\tNULL,\n\t\t\t0,\n\t\t\t500);\n\tif (ret < 0) {\n\t\tpr_err(\"reg_w err %d\\n\", ret);\n\t\tgspca_dev->usb_err = ret;\n\t}\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id)\n{\n\tgspca_dev->cam.cam_mode = vga_mode;\n\tgspca_dev->cam.nmodes = ARRAY_SIZE(vga_mode);\n\tgspca_dev->cam.no_urb_create = 1;\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\treturn 0;\n}\n\n \nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct urb *urb;\n\tint i, n;\n\n\t \n#if MAX_NURBS < 4\n#error \"Not enough URBs in the gspca table\"\n#endif\n#define SD_PKT_SZ 64\n#define SD_NPKT 32\n\tfor (n = 0; n < 4; n++) {\n\t\turb = usb_alloc_urb(SD_NPKT, GFP_KERNEL);\n\t\tif (!urb)\n\t\t\treturn -ENOMEM;\n\t\tgspca_dev->urb[n] = urb;\n\t\turb->transfer_buffer = usb_alloc_coherent(gspca_dev->dev,\n\t\t\t\t\t\tSD_PKT_SZ * SD_NPKT,\n\t\t\t\t\t\tGFP_KERNEL,\n\t\t\t\t\t\t&urb->transfer_dma);\n\n\t\tif (urb->transfer_buffer == NULL) {\n\t\t\tpr_err(\"usb_alloc_coherent failed\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\turb->dev = gspca_dev->dev;\n\t\turb->context = gspca_dev;\n\t\turb->transfer_buffer_length = SD_PKT_SZ * SD_NPKT;\n\t\turb->pipe = usb_rcvisocpipe(gspca_dev->dev,\n\t\t\t\t\tn & 1 ? 0x82 : 0x83);\n\t\turb->transfer_flags = URB_ISO_ASAP\n\t\t\t\t\t| URB_NO_TRANSFER_DMA_MAP;\n\t\turb->interval = 1;\n\t\turb->complete = sd_isoc_irq;\n\t\turb->number_of_packets = SD_NPKT;\n\t\tfor (i = 0; i < SD_NPKT; i++) {\n\t\t\turb->iso_frame_desc[i].length = SD_PKT_SZ;\n\t\t\turb->iso_frame_desc[i].offset = SD_PKT_SZ * i;\n\t\t}\n\t}\n\n\treturn gspca_dev->usb_err;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_interface *intf;\n\n\treg_w(gspca_dev, 0x003c, 0x0003);\n\treg_w(gspca_dev, 0x003c, 0x0004);\n\treg_w(gspca_dev, 0x003c, 0x0005);\n\treg_w(gspca_dev, 0x003c, 0x0006);\n\treg_w(gspca_dev, 0x003c, 0x0007);\n\n\tintf = usb_ifnum_to_if(gspca_dev->dev, gspca_dev->iface);\n\tusb_set_interface(gspca_dev->dev, gspca_dev->iface,\n\t\t\t\t\tintf->num_altsetting - 1);\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t \n\t\t\tint len)\t\t \n{\n\t \n}\n\n \nstatic void sd_isoc_irq(struct urb *urb)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *) urb->context;\n\tstruct urb *urb0;\n\tu8 *data;\n\tint i, st;\n\n\tgspca_dbg(gspca_dev, D_PACK, \"sd isoc irq\\n\");\n\tif (!gspca_dev->streaming)\n\t\treturn;\n\tif (urb->status != 0) {\n\t\tif (urb->status == -ESHUTDOWN)\n\t\t\treturn;\t\t \n#ifdef CONFIG_PM\n\t\tif (gspca_dev->frozen)\n\t\t\treturn;\n#endif\n\t\tpr_err(\"urb status: %d\\n\", urb->status);\n\t\treturn;\n\t}\n\n\t \n\tif (urb == gspca_dev->urb[0] || urb == gspca_dev->urb[2])\n\t\treturn;\n\n\t \n\tif (urb == gspca_dev->urb[1])\n\t\turb0 = gspca_dev->urb[0];\n\telse\n\t\turb0 = gspca_dev->urb[2];\n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\n\t\t \n\t\tif (urb0->iso_frame_desc[i].actual_length != SD_PKT_SZ\n\t\t    || urb->iso_frame_desc[i].actual_length != SD_PKT_SZ) {\n\t\t\tgspca_err(gspca_dev, \"ISOC bad lengths %d / %d\\n\",\n\t\t\t\t  urb0->iso_frame_desc[i].actual_length,\n\t\t\t\t  urb->iso_frame_desc[i].actual_length);\n\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\tcontinue;\n\t\t}\n\t\tst = urb0->iso_frame_desc[i].status;\n\t\tif (st == 0)\n\t\t\tst = urb->iso_frame_desc[i].status;\n\t\tif (st) {\n\t\t\tpr_err(\"ISOC data error: [%d] status=%d\\n\",\n\t\t\t\ti, st);\n\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tdata = (u8 *) urb0->transfer_buffer\n\t\t\t\t\t+ urb0->iso_frame_desc[i].offset;\n\t\tif (data[0] == 0x80 && (data[1] & 0xfe) == 0xba) {\n\n\t\t\t \n\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET,\n\t\t\t\t\tNULL, 0);\n\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\t\t\t\tdata + 4, SD_PKT_SZ - 4);\n\t\t} else if (data[0] == 0x04 && (data[1] & 0xfe) == 0xba) {\n\t\t\tgspca_frame_add(gspca_dev, INTER_PACKET,\n\t\t\t\t\tdata + 4, SD_PKT_SZ - 4);\n\t\t} else {\n\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\tcontinue;\n\t\t}\n\t\tdata = (u8 *) urb->transfer_buffer\n\t\t\t\t\t+ urb->iso_frame_desc[i].offset;\n\t\tgspca_frame_add(gspca_dev, INTER_PACKET,\n\t\t\t\tdata, SD_PKT_SZ);\n\t}\n\n\t \n\tst = usb_submit_urb(urb0, GFP_ATOMIC);\n\tif (st < 0)\n\t\tpr_err(\"usb_submit_urb(0) ret %d\\n\", st);\n\tst = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (st < 0)\n\t\tpr_err(\"usb_submit_urb() ret %d\\n\", st);\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.pkt_scan = sd_pkt_scan,\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x04a5, 0x3035)},\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}