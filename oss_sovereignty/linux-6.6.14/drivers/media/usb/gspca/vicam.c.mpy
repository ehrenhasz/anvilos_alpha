{
  "module_name": "vicam.c",
  "hash_id": "8d58babe2d200071ba58ade59694a332c8f1a5318a5c375cb1b76633dd8d6a88",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/vicam.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"vicam\"\n#define HEADER_SIZE 64\n\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/firmware.h>\n#include <linux/ihex.h>\n#include \"gspca.h\"\n\n#define VICAM_FIRMWARE \"vicam/firmware.fw\"\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_DESCRIPTION(\"GSPCA ViCam USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(VICAM_FIRMWARE);\n\nstruct sd {\n\tstruct gspca_dev gspca_dev;\t \n\tstruct work_struct work_struct;\n};\n\n \nstatic struct v4l2_pix_format vicam_mode[] = {\n\t{ 256, 122, V4L2_PIX_FMT_SGRBG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 256,\n\t\t.sizeimage = 256 * 122,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,},\n\t \n\t{ 256, 200, V4L2_PIX_FMT_SGRBG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 256,\n\t\t.sizeimage = 256 * 200,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,},\n\t{ 256, 240, V4L2_PIX_FMT_SGRBG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 256,\n\t\t.sizeimage = 256 * 240,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,},\n#if 0    \n\t{ 512, 122, V4L2_PIX_FMT_SGRBG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 512,\n\t\t.sizeimage = 512 * 122,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,},\n#endif\n\t{ 512, 244, V4L2_PIX_FMT_SGRBG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 512,\n\t\t.sizeimage = 512 * 244,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,},\n};\n\nstatic int vicam_control_msg(struct gspca_dev *gspca_dev, u8 request,\n\tu16 value, u16 index, u8 *data, u16 len)\n{\n\tint ret;\n\n\tret = usb_control_msg(gspca_dev->dev,\n\t\t\t      usb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t      request,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      value, index, data, len, 1000);\n\tif (ret < 0)\n\t\tpr_err(\"control msg req %02X error %d\\n\", request, ret);\n\n\treturn ret;\n}\n\nstatic int vicam_set_camera_power(struct gspca_dev *gspca_dev, int state)\n{\n\tint ret;\n\n\tret = vicam_control_msg(gspca_dev, 0x50, state, 0, NULL, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (state)\n\t\tret = vicam_control_msg(gspca_dev, 0x55, 1, 0, NULL, 0);\n\n\treturn ret;\n}\n\n \nstatic int vicam_read_frame(struct gspca_dev *gspca_dev, u8 *data, int size)\n{\n\tint ret, unscaled_height, act_len = 0;\n\tu8 *req_data = gspca_dev->usb_buf;\n\ts32 expo = v4l2_ctrl_g_ctrl(gspca_dev->exposure);\n\ts32 gain = v4l2_ctrl_g_ctrl(gspca_dev->gain);\n\n\tmemset(req_data, 0, 16);\n\treq_data[0] = gain;\n\tif (gspca_dev->pixfmt.width == 256)\n\t\treq_data[1] |= 0x01;  \n\tif (gspca_dev->pixfmt.height <= 122) {\n\t\treq_data[1] |= 0x10;  \n\t\tunscaled_height = gspca_dev->pixfmt.height * 2;\n\t} else\n\t\tunscaled_height = gspca_dev->pixfmt.height;\n\treq_data[2] = 0x90;  \n\tif (unscaled_height <= 200)\n\t\treq_data[3] = 0x06;  \n\telse if (unscaled_height <= 242)  \n\t\treq_data[3] = 0x07;  \n\telse  \n\t\treq_data[3] = 0x08;  \n\n\tif (expo < 256) {\n\t\t \n\t\treq_data[4] = 255 - expo;\n\t\treq_data[5] = 0x00;\n\t\treq_data[6] = 0x00;\n\t\treq_data[7] = 0x01;\n\t} else {\n\t\t \n\t\treq_data[4] = 0x00;\n\t\treq_data[5] = 0x00;\n\t\treq_data[6] = expo & 0xFF;\n\t\treq_data[7] = expo >> 8;\n\t}\n\treq_data[8] = ((244 - unscaled_height) / 2) & ~0x01;  \n\t \n\n\tmutex_lock(&gspca_dev->usb_lock);\n\tret = vicam_control_msg(gspca_dev, 0x51, 0x80, 0, req_data, 16);\n\tmutex_unlock(&gspca_dev->usb_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = usb_bulk_msg(gspca_dev->dev,\n\t\t\t   usb_rcvbulkpipe(gspca_dev->dev, 0x81),\n\t\t\t   data, size, &act_len, 10000);\n\t \n\tif (ret < 0 || act_len != size) {\n\t\tpr_err(\"bulk read fail (%d) len %d/%d\\n\",\n\t\t       ret, act_len, size);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \nstatic void vicam_dostream(struct work_struct *work)\n{\n\tstruct sd *sd = container_of(work, struct sd, work_struct);\n\tstruct gspca_dev *gspca_dev = &sd->gspca_dev;\n\tint ret, frame_sz;\n\tu8 *buffer;\n\n\tframe_sz = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].sizeimage +\n\t\t   HEADER_SIZE;\n\tbuffer = kmalloc(frame_sz, GFP_KERNEL);\n\tif (!buffer) {\n\t\tpr_err(\"Couldn't allocate USB buffer\\n\");\n\t\tgoto exit;\n\t}\n\n\twhile (gspca_dev->present && gspca_dev->streaming) {\n#ifdef CONFIG_PM\n\t\tif (gspca_dev->frozen)\n\t\t\tbreak;\n#endif\n\t\tret = vicam_read_frame(gspca_dev, buffer, frame_sz);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\t\t\tbuffer + HEADER_SIZE,\n\t\t\t\tframe_sz - HEADER_SIZE);\n\t\tgspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\n\t}\nexit:\n\tkfree(buffer);\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct cam *cam = &gspca_dev->cam;\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\n\t \n\tcam->bulk = 1;\n\tcam->bulk_size = 64;\n\tcam->cam_mode = vicam_mode;\n\tcam->nmodes = ARRAY_SIZE(vicam_mode);\n\n\tINIT_WORK(&sd->work_struct, vicam_dostream);\n\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\tint ret;\n\tconst struct ihex_binrec *rec;\n\tconst struct firmware *fw;\n\tu8 *firmware_buf;\n\n\tret = request_ihex_firmware(&fw, VICAM_FIRMWARE,\n\t\t\t\t    &gspca_dev->dev->dev);\n\tif (ret) {\n\t\tpr_err(\"Failed to load \\\"vicam/firmware.fw\\\": %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfirmware_buf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!firmware_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\tfor (rec = (void *)fw->data; rec; rec = ihex_next_binrec(rec)) {\n\t\tmemcpy(firmware_buf, rec->data, be16_to_cpu(rec->len));\n\t\tret = vicam_control_msg(gspca_dev, 0xff, 0, 0, firmware_buf,\n\t\t\t\t\tbe16_to_cpu(rec->len));\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tkfree(firmware_buf);\nexit:\n\trelease_firmware(fw);\n\treturn ret;\n}\n\n \nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\tint ret;\n\n\tret = vicam_set_camera_power(gspca_dev, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tschedule_work(&sd->work_struct);\n\n\treturn 0;\n}\n\n \n \nstatic void sd_stop0(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *dev = (struct sd *)gspca_dev;\n\n\t \n\tmutex_unlock(&gspca_dev->usb_lock);\n\t \n\tflush_work(&dev->work_struct);\n\tmutex_lock(&gspca_dev->usb_lock);\n\n\tif (gspca_dev->present)\n\t\tvicam_set_camera_power(gspca_dev, 0);\n}\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 2);\n\tgspca_dev->exposure = v4l2_ctrl_new_std(hdl, NULL,\n\t\t\tV4L2_CID_EXPOSURE, 0, 2047, 1, 256);\n\tgspca_dev->gain = v4l2_ctrl_new_std(hdl, NULL,\n\t\t\tV4L2_CID_GAIN, 0, 255, 1, 200);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\treturn 0;\n}\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x04c1, 0x009d)},\n\t{USB_DEVICE(0x0602, 0x1001)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name   = MODULE_NAME,\n\t.config = sd_config,\n\t.init   = sd_init,\n\t.init_controls = sd_init_controls,\n\t.start  = sd_start,\n\t.stop0  = sd_stop0,\n};\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id,\n\t\t\t&sd_desc,\n\t\t\tsizeof(struct sd),\n\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name       = MODULE_NAME,\n\t.id_table   = device_table,\n\t.probe      = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume  = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}