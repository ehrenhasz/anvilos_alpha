{
  "module_name": "stv0680.c",
  "hash_id": "0948bbf57a279e546729ce91f621f2481a64563e55d01ea4f3a933b0ca6eb392",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/stv0680.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"stv0680\"\n\n#include \"gspca.h\"\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_DESCRIPTION(\"STV0680 USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t\t \n\tstruct v4l2_pix_format mode;\n\tu8 orig_mode;\n\tu8 video_mode;\n\tu8 current_mode;\n};\n\nstatic int stv_sndctrl(struct gspca_dev *gspca_dev, int set, u8 req, u16 val,\n\t\t       int size)\n{\n\tint ret;\n\tu8 req_type = 0;\n\tunsigned int pipe = 0;\n\n\tswitch (set) {\n\tcase 0:  \n\t\treq_type = USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_ENDPOINT;\n\t\tpipe = usb_rcvctrlpipe(gspca_dev->dev, 0);\n\t\tbreak;\n\tcase 1:  \n\t\treq_type = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_ENDPOINT;\n\t\tpipe = usb_sndctrlpipe(gspca_dev->dev, 0);\n\t\tbreak;\n\tcase 2:\t \n\t\treq_type = USB_DIR_IN | USB_RECIP_DEVICE;\n\t\tpipe = usb_rcvctrlpipe(gspca_dev->dev, 0);\n\t\tbreak;\n\tcase 3:\t \n\t\treq_type = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE;\n\t\tpipe = usb_sndctrlpipe(gspca_dev->dev, 0);\n\t\tbreak;\n\t}\n\n\tret = usb_control_msg(gspca_dev->dev, pipe,\n\t\t\t      req, req_type,\n\t\t\t      val, 0, gspca_dev->usb_buf, size, 500);\n\n\tif ((ret < 0) && (req != 0x0a))\n\t\tpr_err(\"usb_control_msg error %i, request = 0x%x, error = %i\\n\",\n\t\t       set, req, ret);\n\n\treturn ret;\n}\n\nstatic int stv0680_handle_error(struct gspca_dev *gspca_dev, int ret)\n{\n\tstv_sndctrl(gspca_dev, 0, 0x80, 0, 0x02);  \n\tgspca_err(gspca_dev, \"last error: %i,  command = 0x%x\\n\",\n\t\t  gspca_dev->usb_buf[0], gspca_dev->usb_buf[1]);\n\treturn ret;\n}\n\nstatic int stv0680_get_video_mode(struct gspca_dev *gspca_dev)\n{\n\t \n\tmemset(gspca_dev->usb_buf, 0, 8);\n\tgspca_dev->usb_buf[0] = 0x0f;\n\n\tif (stv_sndctrl(gspca_dev, 0, 0x87, 0, 0x08) != 0x08) {\n\t\tgspca_err(gspca_dev, \"Get_Camera_Mode failed\\n\");\n\t\treturn stv0680_handle_error(gspca_dev, -EIO);\n\t}\n\n\treturn gspca_dev->usb_buf[0];  \n}\n\nstatic int stv0680_set_video_mode(struct gspca_dev *gspca_dev, u8 mode)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->current_mode == mode)\n\t\treturn 0;\n\n\tmemset(gspca_dev->usb_buf, 0, 8);\n\tgspca_dev->usb_buf[0] = mode;\n\n\tif (stv_sndctrl(gspca_dev, 3, 0x07, 0x0100, 0x08) != 0x08) {\n\t\tgspca_err(gspca_dev, \"Set_Camera_Mode failed\\n\");\n\t\treturn stv0680_handle_error(gspca_dev, -EIO);\n\t}\n\n\t \n\tif (stv0680_get_video_mode(gspca_dev) != mode) {\n\t\tgspca_err(gspca_dev, \"Error setting camera video mode!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tsd->current_mode = mode;\n\n\treturn 0;\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id)\n{\n\tint ret;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam = &gspca_dev->cam;\n\n\t \n\tmsleep(1000);\n\n\t \n\tif (stv_sndctrl(gspca_dev, 0, 0x88, 0x5678, 0x02) != 0x02 ||\n\t    gspca_dev->usb_buf[0] != 0x56 || gspca_dev->usb_buf[1] != 0x78) {\n\t\tgspca_err(gspca_dev, \"STV(e): camera ping failed!!\\n\");\n\t\treturn stv0680_handle_error(gspca_dev, -ENODEV);\n\t}\n\n\t \n\tif (stv_sndctrl(gspca_dev, 2, 0x06, 0x0200, 0x09) != 0x09)\n\t\treturn stv0680_handle_error(gspca_dev, -ENODEV);\n\n\tif (stv_sndctrl(gspca_dev, 2, 0x06, 0x0200, 0x22) != 0x22 ||\n\t    gspca_dev->usb_buf[7] != 0xa0 || gspca_dev->usb_buf[8] != 0x23) {\n\t\tgspca_err(gspca_dev, \"Could not get descriptor 0200\\n\");\n\t\treturn stv0680_handle_error(gspca_dev, -ENODEV);\n\t}\n\tif (stv_sndctrl(gspca_dev, 0, 0x8a, 0, 0x02) != 0x02)\n\t\treturn stv0680_handle_error(gspca_dev, -ENODEV);\n\tif (stv_sndctrl(gspca_dev, 0, 0x8b, 0, 0x24) != 0x24)\n\t\treturn stv0680_handle_error(gspca_dev, -ENODEV);\n\tif (stv_sndctrl(gspca_dev, 0, 0x85, 0, 0x10) != 0x10)\n\t\treturn stv0680_handle_error(gspca_dev, -ENODEV);\n\n\tif (!(gspca_dev->usb_buf[7] & 0x09)) {\n\t\tgspca_err(gspca_dev, \"Camera supports neither CIF nor QVGA mode\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (gspca_dev->usb_buf[7] & 0x01)\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"Camera supports CIF mode\\n\");\n\tif (gspca_dev->usb_buf[7] & 0x02)\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"Camera supports VGA mode\\n\");\n\tif (gspca_dev->usb_buf[7] & 0x04)\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"Camera supports QCIF mode\\n\");\n\tif (gspca_dev->usb_buf[7] & 0x08)\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"Camera supports QVGA mode\\n\");\n\n\tif (gspca_dev->usb_buf[7] & 0x01)\n\t\tsd->video_mode = 0x00;  \n\telse\n\t\tsd->video_mode = 0x03;  \n\n\t \n\tgspca_dbg(gspca_dev, D_PROBE, \"Firmware rev is %i.%i\\n\",\n\t\t  gspca_dev->usb_buf[0], gspca_dev->usb_buf[1]);\n\tgspca_dbg(gspca_dev, D_PROBE, \"ASIC rev is %i.%i\",\n\t\t  gspca_dev->usb_buf[2], gspca_dev->usb_buf[3]);\n\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor ID is %i\",\n\t\t  (gspca_dev->usb_buf[4]*16) + (gspca_dev->usb_buf[5]>>4));\n\n\n\tret = stv0680_get_video_mode(gspca_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tsd->current_mode = sd->orig_mode = ret;\n\n\tret = stv0680_set_video_mode(gspca_dev, sd->video_mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (stv_sndctrl(gspca_dev, 0, 0x8f, 0, 0x10) != 0x10)\n\t\treturn stv0680_handle_error(gspca_dev, -EIO);\n\n\tcam->bulk = 1;\n\tcam->bulk_nurbs = 1;  \n\tcam->bulk_size = (gspca_dev->usb_buf[0] << 24) |\n\t\t\t (gspca_dev->usb_buf[1] << 16) |\n\t\t\t (gspca_dev->usb_buf[2] << 8) |\n\t\t\t (gspca_dev->usb_buf[3]);\n\tsd->mode.width = (gspca_dev->usb_buf[4] << 8) |\n\t\t\t (gspca_dev->usb_buf[5]);   \n\tsd->mode.height = (gspca_dev->usb_buf[6] << 8) |\n\t\t\t  (gspca_dev->usb_buf[7]);  \n\tsd->mode.pixelformat = V4L2_PIX_FMT_STV0680;\n\tsd->mode.field = V4L2_FIELD_NONE;\n\tsd->mode.bytesperline = sd->mode.width;\n\tsd->mode.sizeimage = cam->bulk_size;\n\tsd->mode.colorspace = V4L2_COLORSPACE_SRGB;\n\n\t \n\n\tcam->cam_mode = &sd->mode;\n\tcam->nmodes = 1;\n\n\n\tret = stv0680_set_video_mode(gspca_dev, sd->orig_mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (stv_sndctrl(gspca_dev, 2, 0x06, 0x0100, 0x12) != 0x12 ||\n\t    gspca_dev->usb_buf[8] != 0x53 || gspca_dev->usb_buf[9] != 0x05) {\n\t\tpr_err(\"Could not get descriptor 0100\\n\");\n\t\treturn stv0680_handle_error(gspca_dev, -EIO);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\treturn 0;\n}\n\n \nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tint ret;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tret = stv0680_set_video_mode(gspca_dev, sd->video_mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (stv_sndctrl(gspca_dev, 0, 0x85, 0, 0x10) != 0x10)\n\t\treturn stv0680_handle_error(gspca_dev, -EIO);\n\n\t \n\tif (stv_sndctrl(gspca_dev, 1, 0x09, sd->video_mode << 8, 0x0) != 0x0)\n\t\treturn stv0680_handle_error(gspca_dev, -EIO);\n\n\treturn 0;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\t \n\tif (stv_sndctrl(gspca_dev, 1, 0x04, 0x0000, 0x0) != 0x0)\n\t\tstv0680_handle_error(gspca_dev, -EIO);\n}\n\nstatic void sd_stop0(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (!sd->gspca_dev.present)\n\t\treturn;\n\n\tstv0680_set_video_mode(gspca_dev, sd->orig_mode);\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\n\t\t\tint len)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t \n\tif (len != sd->mode.sizeimage) {\n\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\treturn;\n\t}\n\n\t \n\tgspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\n\n\t \n\tgspca_frame_add(gspca_dev, FIRST_PACKET, data, len);\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.stop0 = sd_stop0,\n\t.pkt_scan = sd_pkt_scan,\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x0553, 0x0202)},\n\t{USB_DEVICE(0x041e, 0x4007)},\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}