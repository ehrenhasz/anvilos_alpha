{
  "module_name": "pac7311.c",
  "hash_id": "1ec5f9eba15c10034e492713cac7876aa52aa2eb7fa1e0500081240ffcb318c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/pac7311.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"pac7311\"\n\n#include <linux/input.h>\n#include \"gspca.h\"\n \n#include \"pac_common.h\"\n\n#define PAC7311_GAIN_DEFAULT     122\n#define PAC7311_EXPOSURE_DEFAULT   3  \n\nMODULE_AUTHOR(\"Thomas Kaiser thomas@kaiser-linux.li\");\nMODULE_DESCRIPTION(\"Pixart PAC7311\");\nMODULE_LICENSE(\"GPL\");\n\nstruct sd {\n\tstruct gspca_dev gspca_dev;\t\t \n\n\tstruct v4l2_ctrl *contrast;\n\tstruct v4l2_ctrl *hflip;\n\n\tu8 sof_read;\n\tu8 autogain_ignore_frames;\n\n\tatomic_t avg_lum;\n};\n\nstatic const struct v4l2_pix_format vga_mode[] = {\n\t{160, 120, V4L2_PIX_FMT_PJPG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 160 * 120 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 2},\n\t{320, 240, V4L2_PIX_FMT_PJPG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{640, 480, V4L2_PIX_FMT_PJPG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\n\n#define LOAD_PAGE4\t\t254\n#define END_OF_SEQUENCE\t\t0\n\nstatic const __u8 init_7311[] = {\n\t0xff, 0x01,\n\t0x78, 0x40,\t \n\t0x78, 0x40,\t \n\t0x78, 0x44,\t \n\t0xff, 0x04,\n\t0x27, 0x80,\n\t0x28, 0xca,\n\t0x29, 0x53,\n\t0x2a, 0x0e,\n\t0xff, 0x01,\n\t0x3e, 0x20,\n};\n\nstatic const __u8 start_7311[] = {\n \n\t0xff, 1,\t0x01,\t\t \n\t0x02, 43,\t0x48, 0x0a, 0x40, 0x08, 0x00, 0x00, 0x08, 0x00,\n\t\t\t0x06, 0xff, 0x11, 0xff, 0x5a, 0x30, 0x90, 0x4c,\n\t\t\t0x00, 0x07, 0x00, 0x0a, 0x10, 0x00, 0xa0, 0x10,\n\t\t\t0x02, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x00,\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x00,\n\t0x3e, 42,\t0x00, 0x00, 0x78, 0x52, 0x4a, 0x52, 0x78, 0x6e,\n\t\t\t0x48, 0x46, 0x48, 0x6e, 0x5f, 0x49, 0x42, 0x49,\n\t\t\t0x5f, 0x5f, 0x49, 0x42, 0x49, 0x5f, 0x6e, 0x48,\n\t\t\t0x46, 0x48, 0x6e, 0x78, 0x52, 0x4a, 0x52, 0x78,\n\t\t\t0x00, 0x00, 0x09, 0x1b, 0x34, 0x49, 0x5c, 0x9b,\n\t\t\t0xd0, 0xff,\n\t0x78, 6,\t0x44, 0x00, 0xf2, 0x01, 0x01, 0x80,\n\t0x7f, 18,\t0x2a, 0x1c, 0x00, 0xc8, 0x02, 0x58, 0x03, 0x84,\n\t\t\t0x12, 0x00, 0x1a, 0x04, 0x08, 0x0c, 0x10, 0x14,\n\t\t\t0x18, 0x20,\n\t0x96, 3,\t0x01, 0x08, 0x04,\n\t0xa0, 4,\t0x44, 0x44, 0x44, 0x04,\n\t0xf0, 13,\t0x01, 0x00, 0x00, 0x00, 0x22, 0x00, 0x20, 0x00,\n\t\t\t0x3f, 0x00, 0x0a, 0x01, 0x00,\n\t0xff, 1,\t0x04,\t\t \n\t0, LOAD_PAGE4,\t\t\t \n\t0x11, 1,\t0x01,\n\t0, END_OF_SEQUENCE\t\t \n};\n\n#define SKIP\t\t0xaa\n \nstatic const __u8 page4_7311[] = {\n\tSKIP, SKIP, 0x04, 0x54, 0x07, 0x2b, 0x09, 0x0f,\n\t0x09, 0x00, SKIP, SKIP, 0x07, 0x00, 0x00, 0x62,\n\t0x08, SKIP, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x03, 0xa0, 0x01, 0xf4, SKIP,\n\tSKIP, 0x00, 0x08, SKIP, 0x03, SKIP, 0x00, 0x68,\n\t0xca, 0x10, 0x06, 0x78, 0x00, 0x00, 0x00, 0x00,\n\t0x23, 0x28, 0x04, 0x11, 0x00, 0x00\n};\n\nstatic void reg_w_buf(struct gspca_dev *gspca_dev,\n\t\t  __u8 index,\n\t\t  const u8 *buffer, int len)\n{\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tmemcpy(gspca_dev->usb_buf, buffer, len);\n\tret = usb_control_msg(gspca_dev->dev,\n\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t0,\t\t \n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0,\t\t \n\t\t\tindex, gspca_dev->usb_buf, len,\n\t\t\t500);\n\tif (ret < 0) {\n\t\tpr_err(\"reg_w_buf() failed index 0x%02x, error %d\\n\",\n\t\t       index, ret);\n\t\tgspca_dev->usb_err = ret;\n\t}\n}\n\n\nstatic void reg_w(struct gspca_dev *gspca_dev,\n\t\t  __u8 index,\n\t\t  __u8 value)\n{\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tgspca_dev->usb_buf[0] = value;\n\tret = usb_control_msg(gspca_dev->dev,\n\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t0,\t\t\t \n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, index, gspca_dev->usb_buf, 1,\n\t\t\t500);\n\tif (ret < 0) {\n\t\tpr_err(\"reg_w() failed index 0x%02x, value 0x%02x, error %d\\n\",\n\t\t       index, value, ret);\n\t\tgspca_dev->usb_err = ret;\n\t}\n}\n\nstatic void reg_w_seq(struct gspca_dev *gspca_dev,\n\t\tconst __u8 *seq, int len)\n{\n\twhile (--len >= 0) {\n\t\treg_w(gspca_dev, seq[0], seq[1]);\n\t\tseq += 2;\n\t}\n}\n\n \nstatic void reg_w_page(struct gspca_dev *gspca_dev,\n\t\t\tconst __u8 *page, int len)\n{\n\tint index;\n\tint ret = 0;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tfor (index = 0; index < len; index++) {\n\t\tif (page[index] == SKIP)\t\t \n\t\t\tcontinue;\n\t\tgspca_dev->usb_buf[0] = page[index];\n\t\tret = usb_control_msg(gspca_dev->dev,\n\t\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t\t0,\t\t\t \n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\t0, index, gspca_dev->usb_buf, 1,\n\t\t\t\t500);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"reg_w_page() failed index 0x%02x, value 0x%02x, error %d\\n\",\n\t\t\t       index, page[index], ret);\n\t\t\tgspca_dev->usb_err = ret;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void reg_w_var(struct gspca_dev *gspca_dev,\n\t\t\tconst __u8 *seq,\n\t\t\tconst __u8 *page4, unsigned int page4_len)\n{\n\tint index, len;\n\n\tfor (;;) {\n\t\tindex = *seq++;\n\t\tlen = *seq++;\n\t\tswitch (len) {\n\t\tcase END_OF_SEQUENCE:\n\t\t\treturn;\n\t\tcase LOAD_PAGE4:\n\t\t\treg_w_page(gspca_dev, page4, page4_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len > USB_BUF_SZ) {\n\t\t\t\tgspca_err(gspca_dev, \"Incorrect variable sequence\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile (len > 0) {\n\t\t\t\tif (len < 8) {\n\t\t\t\t\treg_w_buf(gspca_dev,\n\t\t\t\t\t\tindex, seq, len);\n\t\t\t\t\tseq += len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treg_w_buf(gspca_dev, index, seq, 8);\n\t\t\t\tseq += 8;\n\t\t\t\tindex += 8;\n\t\t\t\tlen -= 8;\n\t\t\t}\n\t\t}\n\t}\n\t \n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct cam *cam = &gspca_dev->cam;\n\n\tcam->cam_mode = vga_mode;\n\tcam->nmodes = ARRAY_SIZE(vga_mode);\n\tcam->input_flags = V4L2_IN_ST_VFLIP;\n\n\treturn 0;\n}\n\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 val)\n{\n\treg_w(gspca_dev, 0xff, 0x04);\n\treg_w(gspca_dev, 0x10, val);\n\t \n\treg_w(gspca_dev, 0x11, 0x01);\n}\n\nstatic void setgain(struct gspca_dev *gspca_dev, s32 val)\n{\n\treg_w(gspca_dev, 0xff, 0x04);\t\t\t \n\treg_w(gspca_dev, 0x0e, 0x00);\n\treg_w(gspca_dev, 0x0f, gspca_dev->gain->maximum - val + 1);\n\n\t \n\treg_w(gspca_dev, 0x11, 0x01);\n}\n\nstatic void setexposure(struct gspca_dev *gspca_dev, s32 val)\n{\n\treg_w(gspca_dev, 0xff, 0x04);\t\t\t \n\treg_w(gspca_dev, 0x02, val);\n\n\t \n\treg_w(gspca_dev, 0x11, 0x01);\n\n\t \n\treg_w(gspca_dev, 0xff, 0x01);\n\tif (gspca_dev->pixfmt.width != 640 && val <= 3)\n\t\treg_w(gspca_dev, 0x08, 0x09);\n\telse\n\t\treg_w(gspca_dev, 0x08, 0x08);\n\n\t \n\tif (gspca_dev->pixfmt.width == 640 && val == 2)\n\t\treg_w(gspca_dev, 0x80, 0x01);\n\telse\n\t\treg_w(gspca_dev, 0x80, 0x1c);\n\n\t \n\treg_w(gspca_dev, 0x11, 0x01);\n}\n\nstatic void sethvflip(struct gspca_dev *gspca_dev, s32 hflip, s32 vflip)\n{\n\t__u8 data;\n\n\treg_w(gspca_dev, 0xff, 0x04);\t\t\t \n\tdata = (hflip ? 0x04 : 0x00) |\n\t       (vflip ? 0x08 : 0x00);\n\treg_w(gspca_dev, 0x21, data);\n\n\t \n\treg_w(gspca_dev, 0x11, 0x01);\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\treg_w_seq(gspca_dev, init_7311, sizeof(init_7311)/2);\n\treturn gspca_dev->usb_err;\n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tif (ctrl->id == V4L2_CID_AUTOGAIN && ctrl->is_new && ctrl->val) {\n\t\t \n\t\tgspca_dev->exposure->val    = PAC7311_EXPOSURE_DEFAULT;\n\t\tgspca_dev->gain->val        = PAC7311_GAIN_DEFAULT;\n\t\tsd->autogain_ignore_frames  = PAC_AUTOGAIN_IGNORE_FRAMES;\n\t}\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_CONTRAST:\n\t\tsetcontrast(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\tif (gspca_dev->exposure->is_new || (ctrl->is_new && ctrl->val))\n\t\t\tsetexposure(gspca_dev, gspca_dev->exposure->val);\n\t\tif (gspca_dev->gain->is_new || (ctrl->is_new && ctrl->val))\n\t\t\tsetgain(gspca_dev, gspca_dev->gain->val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tsethvflip(gspca_dev, sd->hflip->val, 1);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\n \nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 5);\n\n\tsd->contrast = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_CONTRAST, 0, 15, 1, 7);\n\tgspca_dev->autogain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\tgspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_EXPOSURE, 2, 63, 1,\n\t\t\t\t\tPAC7311_EXPOSURE_DEFAULT);\n\tgspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_GAIN, 0, 244, 1,\n\t\t\t\t\tPAC7311_GAIN_DEFAULT);\n\tsd->hflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\n\tv4l2_ctrl_auto_cluster(3, &gspca_dev->autogain, 0, false);\n\treturn 0;\n}\n\n \nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tsd->sof_read = 0;\n\n\treg_w_var(gspca_dev, start_7311,\n\t\tpage4_7311, sizeof(page4_7311));\n\tsetcontrast(gspca_dev, v4l2_ctrl_g_ctrl(sd->contrast));\n\tsetgain(gspca_dev, v4l2_ctrl_g_ctrl(gspca_dev->gain));\n\tsetexposure(gspca_dev, v4l2_ctrl_g_ctrl(gspca_dev->exposure));\n\tsethvflip(gspca_dev, v4l2_ctrl_g_ctrl(sd->hflip), 1);\n\n\t \n\tswitch (gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv) {\n\tcase 2:\t\t\t\t\t \n\t\treg_w(gspca_dev, 0xff, 0x01);\n\t\treg_w(gspca_dev, 0x17, 0x20);\n\t\treg_w(gspca_dev, 0x87, 0x10);\n\t\tbreak;\n\tcase 1:\t\t\t\t\t \n\t\treg_w(gspca_dev, 0xff, 0x01);\n\t\treg_w(gspca_dev, 0x17, 0x30);\n\t\treg_w(gspca_dev, 0x87, 0x11);\n\t\tbreak;\n\tcase 0:\t\t\t\t\t \n\t\treg_w(gspca_dev, 0xff, 0x01);\n\t\treg_w(gspca_dev, 0x17, 0x00);\n\t\treg_w(gspca_dev, 0x87, 0x12);\n\t\tbreak;\n\t}\n\n\tsd->sof_read = 0;\n\tsd->autogain_ignore_frames = 0;\n\tatomic_set(&sd->avg_lum, -1);\n\n\t \n\treg_w(gspca_dev, 0xff, 0x01);\n\treg_w(gspca_dev, 0x78, 0x05);\n\n\treturn gspca_dev->usb_err;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\treg_w(gspca_dev, 0xff, 0x04);\n\treg_w(gspca_dev, 0x27, 0x80);\n\treg_w(gspca_dev, 0x28, 0xca);\n\treg_w(gspca_dev, 0x29, 0x53);\n\treg_w(gspca_dev, 0x2a, 0x0e);\n\treg_w(gspca_dev, 0xff, 0x01);\n\treg_w(gspca_dev, 0x3e, 0x20);\n\treg_w(gspca_dev, 0x78, 0x44);  \n\treg_w(gspca_dev, 0x78, 0x44);  \n\treg_w(gspca_dev, 0x78, 0x44);  \n}\n\nstatic void do_autogain(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint avg_lum = atomic_read(&sd->avg_lum);\n\tint desired_lum, deadzone;\n\n\tif (avg_lum == -1)\n\t\treturn;\n\n\tdesired_lum = 170;\n\tdeadzone = 20;\n\n\tif (sd->autogain_ignore_frames > 0)\n\t\tsd->autogain_ignore_frames--;\n\telse if (gspca_coarse_grained_expo_autogain(gspca_dev, avg_lum,\n\t\t\t\t\t\t    desired_lum, deadzone))\n\t\tsd->autogain_ignore_frames = PAC_AUTOGAIN_IGNORE_FRAMES;\n}\n\n \nstatic const unsigned char pac_jpeg_header1[] = {\n  0xff, 0xd8,\t\t \n\n  0xff, 0xc0,\t\t \n  0x00, 0x11,\t\t \n  0x08\t\t\t \n   \n   \n};\n\n \nstatic const unsigned char pac_jpeg_header2[] = {\n  0x03,\t\t\t \n  0x01, 0x21, 0x00,\t \n  0x02, 0x11, 0x01,\t \n  0x03, 0x11, 0x01,\t \n\n  0xff, 0xda,\t\t \n  0x00, 0x0c,\t\t \n  0x03,\t\t\t \n  0x01, 0x00,\t\t \n  0x02, 0x11,\t\t \n  0x03, 0x11,\t\t \n  0x00, 0x3f,\t\t \n  0x00\t\t\t \n};\n\nstatic void pac_start_frame(struct gspca_dev *gspca_dev,\n\t\t__u16 lines, __u16 samples_per_line)\n{\n\tunsigned char tmpbuf[4];\n\n\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\tpac_jpeg_header1, sizeof(pac_jpeg_header1));\n\n\ttmpbuf[0] = lines >> 8;\n\ttmpbuf[1] = lines & 0xff;\n\ttmpbuf[2] = samples_per_line >> 8;\n\ttmpbuf[3] = samples_per_line & 0xff;\n\n\tgspca_frame_add(gspca_dev, INTER_PACKET,\n\t\ttmpbuf, sizeof(tmpbuf));\n\tgspca_frame_add(gspca_dev, INTER_PACKET,\n\t\tpac_jpeg_header2, sizeof(pac_jpeg_header2));\n}\n\n \nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t \n\t\t\tint len)\t\t\t \n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 *image;\n\tunsigned char *sof;\n\n\tsof = pac_find_sof(gspca_dev, &sd->sof_read, data, len);\n\tif (sof) {\n\t\tint n, lum_offset, footer_length;\n\n\t\t \n\t\tlum_offset = 24 + sizeof pac_sof_marker;\n\t\tfooter_length = 26;\n\n\t\t \n\t\tn = (sof - data) - (footer_length + sizeof pac_sof_marker);\n\t\tif (n < 0) {\n\t\t\tgspca_dev->image_len += n;\n\t\t\tn = 0;\n\t\t} else {\n\t\t\tgspca_frame_add(gspca_dev, INTER_PACKET, data, n);\n\t\t}\n\t\timage = gspca_dev->image;\n\t\tif (image != NULL\n\t\t && image[gspca_dev->image_len - 2] == 0xff\n\t\t && image[gspca_dev->image_len - 1] == 0xd9)\n\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\n\n\t\tn = sof - data;\n\t\tlen -= n;\n\t\tdata = sof;\n\n\t\t \n\t\tif (gspca_dev->last_packet_type == LAST_PACKET &&\n\t\t\t\tn >= lum_offset)\n\t\t\tatomic_set(&sd->avg_lum, data[-lum_offset] +\n\t\t\t\t\t\tdata[-lum_offset + 1]);\n\t\telse\n\t\t\tatomic_set(&sd->avg_lum, -1);\n\n\t\t \n\t\tpac_start_frame(gspca_dev,\n\t\t\tgspca_dev->pixfmt.height, gspca_dev->pixfmt.width);\n\t}\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n}\n\n#if IS_ENABLED(CONFIG_INPUT)\nstatic int sd_int_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t \n\t\t\tint len)\t\t \n{\n\tint ret = -EINVAL;\n\tu8 data0, data1;\n\n\tif (len == 2) {\n\t\tdata0 = data[0];\n\t\tdata1 = data[1];\n\t\tif ((data0 == 0x00 && data1 == 0x11) ||\n\t\t    (data0 == 0x22 && data1 == 0x33) ||\n\t\t    (data0 == 0x44 && data1 == 0x55) ||\n\t\t    (data0 == 0x66 && data1 == 0x77) ||\n\t\t    (data0 == 0x88 && data1 == 0x99) ||\n\t\t    (data0 == 0xaa && data1 == 0xbb) ||\n\t\t    (data0 == 0xcc && data1 == 0xdd) ||\n\t\t    (data0 == 0xee && data1 == 0xff)) {\n\t\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);\n\t\t\tinput_sync(gspca_dev->input_dev);\n\t\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\n\t\t\tinput_sync(gspca_dev->input_dev);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}\n#endif\n\nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.pkt_scan = sd_pkt_scan,\n\t.dq_callback = do_autogain,\n#if IS_ENABLED(CONFIG_INPUT)\n\t.int_pkt_scan = sd_int_pkt_scan,\n#endif\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x093a, 0x2600)},\n\t{USB_DEVICE(0x093a, 0x2601)},\n\t{USB_DEVICE(0x093a, 0x2603)},\n\t{USB_DEVICE(0x093a, 0x2608)},\n\t{USB_DEVICE(0x093a, 0x260e)},\n\t{USB_DEVICE(0x093a, 0x260f)},\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}