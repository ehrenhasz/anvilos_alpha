{
  "module_name": "w996Xcf.c",
  "hash_id": "4b3f11556767c9ed9f416d50e69f42a8f12fb527fe1086b5a1299ac3db30a4da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/w996Xcf.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define W9968CF_I2C_BUS_DELAY    4  \n\n#define Y_QUANTABLE (&sd->jpeg_hdr[JPEG_QT0_OFFSET])\n#define UV_QUANTABLE (&sd->jpeg_hdr[JPEG_QT1_OFFSET])\n\nstatic const struct v4l2_pix_format w9968cf_vga_mode[] = {\n\t{160, 120, V4L2_PIX_FMT_UYVY, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160 * 2,\n\t\t.sizeimage = 160 * 120 * 2,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG},\n\t{176, 144, V4L2_PIX_FMT_UYVY, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176 * 2,\n\t\t.sizeimage = 176 * 144 * 2,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG},\n\t{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320 * 2,\n\t\t.sizeimage = 320 * 240 * 2,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG},\n\t{352, 288, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352 * 2,\n\t\t.sizeimage = 352 * 288 * 2,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG},\n\t{640, 480, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640 * 2,\n\t\t.sizeimage = 640 * 480 * 2,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG},\n};\n\nstatic void reg_w(struct sd *sd, u16 index, u16 value);\n\n \nstatic void w9968cf_write_fsb(struct sd *sd, u16* data)\n{\n\tstruct usb_device *udev = sd->gspca_dev.dev;\n\tu16 value;\n\tint ret;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn;\n\n\tvalue = *data++;\n\tmemcpy(sd->gspca_dev.usb_buf, data, 6);\n\n\t \n\tudelay(150);\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0,\n\t\t\t      USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,\n\t\t\t      value, 0x06, sd->gspca_dev.usb_buf, 6, 500);\n\tif (ret < 0) {\n\t\tpr_err(\"Write FSB registers failed (%d)\\n\", ret);\n\t\tsd->gspca_dev.usb_err = ret;\n\t}\n}\n\n \nstatic void w9968cf_write_sb(struct sd *sd, u16 value)\n{\n\tint ret;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn;\n\n\t \n\tudelay(150);\n\n\t \n\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\tusb_sndctrlpipe(sd->gspca_dev.dev, 0),\n\t\t0,\n\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\tvalue, 0x01, NULL, 0, 500);\n\n\tudelay(W9968CF_I2C_BUS_DELAY);\n\n\tif (ret < 0) {\n\t\tpr_err(\"Write SB reg [01] %04x failed\\n\", value);\n\t\tsd->gspca_dev.usb_err = ret;\n\t}\n}\n\n \nstatic int w9968cf_read_sb(struct sd *sd)\n{\n\tint ret;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn -1;\n\n\t \n\tudelay(150);\n\n\t \n\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_rcvctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\t1,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, 0x01, sd->gspca_dev.usb_buf, 2, 500);\n\tif (ret >= 0) {\n\t\tret = sd->gspca_dev.usb_buf[0] |\n\t\t      (sd->gspca_dev.usb_buf[1] << 8);\n\t} else {\n\t\tpr_err(\"Read SB reg [01] failed\\n\");\n\t\tsd->gspca_dev.usb_err = ret;\n\t\t \n\t\tmemset(sd->gspca_dev.usb_buf, 0, 2);\n\t}\n\n\tudelay(W9968CF_I2C_BUS_DELAY);\n\n\treturn ret;\n}\n\n \nstatic void w9968cf_upload_quantizationtables(struct sd *sd)\n{\n\tu16 a, b;\n\tint i, j;\n\n\treg_w(sd, 0x39, 0x0010);  \n\n\tfor (i = 0, j = 0; i < 32; i++, j += 2) {\n\t\ta = Y_QUANTABLE[j] | ((unsigned)(Y_QUANTABLE[j + 1]) << 8);\n\t\tb = UV_QUANTABLE[j] | ((unsigned)(UV_QUANTABLE[j + 1]) << 8);\n\t\treg_w(sd, 0x40 + i, a);\n\t\treg_w(sd, 0x60 + i, b);\n\t}\n\treg_w(sd, 0x39, 0x0012);  \n}\n\n \n\nstatic void w9968cf_smbus_start(struct sd *sd)\n{\n\tw9968cf_write_sb(sd, 0x0011);  \n\tw9968cf_write_sb(sd, 0x0010);  \n}\n\nstatic void w9968cf_smbus_stop(struct sd *sd)\n{\n\tw9968cf_write_sb(sd, 0x0010);  \n\tw9968cf_write_sb(sd, 0x0011);  \n\tw9968cf_write_sb(sd, 0x0013);  \n}\n\nstatic void w9968cf_smbus_write_byte(struct sd *sd, u8 v)\n{\n\tu8 bit;\n\tint sda;\n\n\tfor (bit = 0 ; bit < 8 ; bit++) {\n\t\tsda = (v & 0x80) ? 2 : 0;\n\t\tv <<= 1;\n\t\t \n\t\tw9968cf_write_sb(sd, 0x10 | sda);\n\t\t \n\t\tw9968cf_write_sb(sd, 0x11 | sda);\n\t\t \n\t\tw9968cf_write_sb(sd, 0x10 | sda);\n\t}\n}\n\nstatic void w9968cf_smbus_read_byte(struct sd *sd, u8 *v)\n{\n\tu8 bit;\n\n\t \n\t*v = 0;\n\tfor (bit = 0 ; bit < 8 ; bit++) {\n\t\t*v <<= 1;\n\t\t \n\t\tw9968cf_write_sb(sd, 0x0013);\n\t\t*v |= (w9968cf_read_sb(sd) & 0x0008) ? 1 : 0;\n\t\t \n\t\tw9968cf_write_sb(sd, 0x0012);\n\t}\n}\n\nstatic void w9968cf_smbus_write_nack(struct sd *sd)\n{\n\t \n\tw9968cf_write_sb(sd, 0x0013);  \n\tw9968cf_write_sb(sd, 0x0012);  \n}\n\nstatic void w9968cf_smbus_read_ack(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint sda;\n\n\t \n\tw9968cf_write_sb(sd, 0x0012);  \n\tw9968cf_write_sb(sd, 0x0013);  \n\tsda = w9968cf_read_sb(sd);\n\tw9968cf_write_sb(sd, 0x0012);  \n\tif (sda >= 0 && (sda & 0x08)) {\n\t\tgspca_dbg(gspca_dev, D_USBI, \"Did not receive i2c ACK\\n\");\n\t\tsd->gspca_dev.usb_err = -EIO;\n\t}\n}\n\n \nstatic void w9968cf_i2c_w(struct sd *sd, u8 reg, u8 value)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tu16* data = (u16 *)sd->gspca_dev.usb_buf;\n\n\tdata[0] = 0x082f | ((sd->sensor_addr & 0x80) ? 0x1500 : 0x0);\n\tdata[0] |= (sd->sensor_addr & 0x40) ? 0x4000 : 0x0;\n\tdata[1] = 0x2082 | ((sd->sensor_addr & 0x40) ? 0x0005 : 0x0);\n\tdata[1] |= (sd->sensor_addr & 0x20) ? 0x0150 : 0x0;\n\tdata[1] |= (sd->sensor_addr & 0x10) ? 0x5400 : 0x0;\n\tdata[2] = 0x8208 | ((sd->sensor_addr & 0x08) ? 0x0015 : 0x0);\n\tdata[2] |= (sd->sensor_addr & 0x04) ? 0x0540 : 0x0;\n\tdata[2] |= (sd->sensor_addr & 0x02) ? 0x5000 : 0x0;\n\tdata[3] = 0x1d20 | ((sd->sensor_addr & 0x02) ? 0x0001 : 0x0);\n\tdata[3] |= (sd->sensor_addr & 0x01) ? 0x0054 : 0x0;\n\n\tw9968cf_write_fsb(sd, data);\n\n\tdata[0] = 0x8208 | ((reg & 0x80) ? 0x0015 : 0x0);\n\tdata[0] |= (reg & 0x40) ? 0x0540 : 0x0;\n\tdata[0] |= (reg & 0x20) ? 0x5000 : 0x0;\n\tdata[1] = 0x0820 | ((reg & 0x20) ? 0x0001 : 0x0);\n\tdata[1] |= (reg & 0x10) ? 0x0054 : 0x0;\n\tdata[1] |= (reg & 0x08) ? 0x1500 : 0x0;\n\tdata[1] |= (reg & 0x04) ? 0x4000 : 0x0;\n\tdata[2] = 0x2082 | ((reg & 0x04) ? 0x0005 : 0x0);\n\tdata[2] |= (reg & 0x02) ? 0x0150 : 0x0;\n\tdata[2] |= (reg & 0x01) ? 0x5400 : 0x0;\n\tdata[3] = 0x001d;\n\n\tw9968cf_write_fsb(sd, data);\n\n\tdata[0] = 0x8208 | ((value & 0x80) ? 0x0015 : 0x0);\n\tdata[0] |= (value & 0x40) ? 0x0540 : 0x0;\n\tdata[0] |= (value & 0x20) ? 0x5000 : 0x0;\n\tdata[1] = 0x0820 | ((value & 0x20) ? 0x0001 : 0x0);\n\tdata[1] |= (value & 0x10) ? 0x0054 : 0x0;\n\tdata[1] |= (value & 0x08) ? 0x1500 : 0x0;\n\tdata[1] |= (value & 0x04) ? 0x4000 : 0x0;\n\tdata[2] = 0x2082 | ((value & 0x04) ? 0x0005 : 0x0);\n\tdata[2] |= (value & 0x02) ? 0x0150 : 0x0;\n\tdata[2] |= (value & 0x01) ? 0x5400 : 0x0;\n\tdata[3] = 0xfe1d;\n\n\tw9968cf_write_fsb(sd, data);\n\n\tgspca_dbg(gspca_dev, D_USBO, \"i2c 0x%02x -> [0x%02x]\\n\", value, reg);\n}\n\n \nstatic int w9968cf_i2c_r(struct sd *sd, u8 reg)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint ret = 0;\n\tu8 value;\n\n\t \n\tw9968cf_write_sb(sd, 0x0013);  \n\n\tw9968cf_smbus_start(sd);\n\tw9968cf_smbus_write_byte(sd, sd->sensor_addr);\n\tw9968cf_smbus_read_ack(sd);\n\tw9968cf_smbus_write_byte(sd, reg);\n\tw9968cf_smbus_read_ack(sd);\n\tw9968cf_smbus_stop(sd);\n\tw9968cf_smbus_start(sd);\n\tw9968cf_smbus_write_byte(sd, sd->sensor_addr + 1);\n\tw9968cf_smbus_read_ack(sd);\n\tw9968cf_smbus_read_byte(sd, &value);\n\t \n\tw9968cf_smbus_write_nack(sd);\n\tw9968cf_smbus_stop(sd);\n\n\t \n\tw9968cf_write_sb(sd, 0x0030);\n\n\tif (sd->gspca_dev.usb_err >= 0) {\n\t\tret = value;\n\t\tgspca_dbg(gspca_dev, D_USBI, \"i2c [0x%02X] -> 0x%02X\\n\",\n\t\t\t  reg, value);\n\t} else\n\t\tgspca_err(gspca_dev, \"i2c read [0x%02x] failed\\n\", reg);\n\n\treturn ret;\n}\n\n \nstatic void w9968cf_configure(struct sd *sd)\n{\n\treg_w(sd, 0x00, 0xff00);  \n\treg_w(sd, 0x00, 0xbf17);  \n\treg_w(sd, 0x00, 0xbf10);  \n\treg_w(sd, 0x01, 0x0010);  \n\treg_w(sd, 0x01, 0x0000);  \n\treg_w(sd, 0x01, 0x0010);  \n\treg_w(sd, 0x01, 0x0030);  \n\n\tsd->stopped = 1;\n}\n\nstatic void w9968cf_init(struct sd *sd)\n{\n\tunsigned long hw_bufsize = sd->sif ? (352 * 288 * 2) : (640 * 480 * 2),\n\t\t      y0 = 0x0000,\n\t\t      u0 = y0 + hw_bufsize / 2,\n\t\t      v0 = u0 + hw_bufsize / 4,\n\t\t      y1 = v0 + hw_bufsize / 4,\n\t\t      u1 = y1 + hw_bufsize / 2,\n\t\t      v1 = u1 + hw_bufsize / 4;\n\n\treg_w(sd, 0x00, 0xff00);  \n\treg_w(sd, 0x00, 0xbf10);  \n\n\treg_w(sd, 0x03, 0x405d);  \n\treg_w(sd, 0x04, 0x0030);  \n\n\treg_w(sd, 0x20, y0 & 0xffff);  \n\treg_w(sd, 0x21, y0 >> 16);     \n\treg_w(sd, 0x24, u0 & 0xffff);  \n\treg_w(sd, 0x25, u0 >> 16);     \n\treg_w(sd, 0x28, v0 & 0xffff);  \n\treg_w(sd, 0x29, v0 >> 16);     \n\n\treg_w(sd, 0x22, y1 & 0xffff);  \n\treg_w(sd, 0x23, y1 >> 16);     \n\treg_w(sd, 0x26, u1 & 0xffff);  \n\treg_w(sd, 0x27, u1 >> 16);     \n\treg_w(sd, 0x2a, v1 & 0xffff);  \n\treg_w(sd, 0x2b, v1 >> 16);     \n\n\treg_w(sd, 0x32, y1 & 0xffff);  \n\treg_w(sd, 0x33, y1 >> 16);     \n\n\treg_w(sd, 0x34, y1 & 0xffff);  \n\treg_w(sd, 0x35, y1 >> 16);     \n\n\treg_w(sd, 0x36, 0x0000); \n\treg_w(sd, 0x37, 0x0804); \n\treg_w(sd, 0x38, 0x0000); \n\treg_w(sd, 0x3f, 0x0000);  \n}\n\nstatic void w9968cf_set_crop_window(struct sd *sd)\n{\n\tint start_cropx, start_cropy,  x, y, fw, fh, cw, ch,\n\t    max_width, max_height;\n\n\tif (sd->sif) {\n\t\tmax_width  = 352;\n\t\tmax_height = 288;\n\t} else {\n\t\tmax_width  = 640;\n\t\tmax_height = 480;\n\t}\n\n\tif (sd->sensor == SEN_OV7620) {\n\t\t \n\t\tif (sd->freq->val == 1) {\n\t\t\tstart_cropx = 277;\n\t\t\tstart_cropy = 37;\n\t\t} else {\n\t\t\tstart_cropx = 105;\n\t\t\tstart_cropy = 37;\n\t\t}\n\t} else {\n\t\tstart_cropx = 320;\n\t\tstart_cropy = 35;\n\t}\n\n\t \n\t#define SC(x) ((x) << 10)\n\n\t \n\tfw = SC(sd->gspca_dev.pixfmt.width) / max_width;\n\tfh = SC(sd->gspca_dev.pixfmt.height) / max_height;\n\n\tcw = (fw >= fh) ? max_width : SC(sd->gspca_dev.pixfmt.width) / fh;\n\tch = (fw >= fh) ? SC(sd->gspca_dev.pixfmt.height) / fw : max_height;\n\n\tsd->sensor_width = max_width;\n\tsd->sensor_height = max_height;\n\n\tx = (max_width - cw) / 2;\n\ty = (max_height - ch) / 2;\n\n\treg_w(sd, 0x10, start_cropx + x);\n\treg_w(sd, 0x11, start_cropy + y);\n\treg_w(sd, 0x12, start_cropx + x + cw);\n\treg_w(sd, 0x13, start_cropy + y + ch);\n}\n\nstatic void w9968cf_mode_init_regs(struct sd *sd)\n{\n\tint val, vs_polarity, hs_polarity;\n\n\tw9968cf_set_crop_window(sd);\n\n\treg_w(sd, 0x14, sd->gspca_dev.pixfmt.width);\n\treg_w(sd, 0x15, sd->gspca_dev.pixfmt.height);\n\n\t \n\treg_w(sd, 0x30, sd->gspca_dev.pixfmt.width);\n\treg_w(sd, 0x31, sd->gspca_dev.pixfmt.height);\n\n\t \n\tif (w9968cf_vga_mode[sd->gspca_dev.curr_mode].pixelformat ==\n\t    V4L2_PIX_FMT_JPEG) {\n\t\treg_w(sd, 0x2c, sd->gspca_dev.pixfmt.width / 2);\n\t\treg_w(sd, 0x2d, sd->gspca_dev.pixfmt.width / 4);\n\t} else\n\t\treg_w(sd, 0x2c, sd->gspca_dev.pixfmt.width);\n\n\treg_w(sd, 0x00, 0xbf17);  \n\treg_w(sd, 0x00, 0xbf10);  \n\n\t \n\tval = sd->gspca_dev.pixfmt.width * sd->gspca_dev.pixfmt.height;\n\treg_w(sd, 0x3d, val & 0xffff);  \n\treg_w(sd, 0x3e, val >> 16);     \n\n\tif (w9968cf_vga_mode[sd->gspca_dev.curr_mode].pixelformat ==\n\t    V4L2_PIX_FMT_JPEG) {\n\t\t \n\t\tjpeg_define(sd->jpeg_hdr, sd->gspca_dev.pixfmt.height,\n\t\t\t    sd->gspca_dev.pixfmt.width, 0x22);  \n\t\tjpeg_set_qual(sd->jpeg_hdr, v4l2_ctrl_g_ctrl(sd->jpegqual));\n\t\tw9968cf_upload_quantizationtables(sd);\n\t\tv4l2_ctrl_grab(sd->jpegqual, true);\n\t}\n\n\t \n\tif (sd->sensor == SEN_OV7620) {\n\t\t \n\t\tvs_polarity = 1;\n\t\ths_polarity = 1;\n\t} else {\n\t\tvs_polarity = 1;\n\t\ths_polarity = 0;\n\t}\n\n\tval = (vs_polarity << 12) | (hs_polarity << 11);\n\n\t \n\tif (w9968cf_vga_mode[sd->gspca_dev.curr_mode].pixelformat ==\n\t    V4L2_PIX_FMT_JPEG) {\n\t\t \n\t\tval |= 0x0003;  \n\t} else\n\t\tval |= 0x0080;  \n\n\t \n\t \n\t \n\n\tval |= 0x8000;  \n\n\treg_w(sd, 0x16, val);\n\n\tsd->gspca_dev.empty_packet = 0;\n}\n\nstatic void w9968cf_stop0(struct sd *sd)\n{\n\tv4l2_ctrl_grab(sd->jpegqual, false);\n\treg_w(sd, 0x39, 0x0000);  \n\treg_w(sd, 0x16, 0x0000);  \n}\n\n \nstatic void w9968cf_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t \n\t\t\tint len)\t\t\t \n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (w9968cf_vga_mode[gspca_dev->curr_mode].pixelformat ==\n\t    V4L2_PIX_FMT_JPEG) {\n\t\tif (len >= 2 &&\n\t\t    data[0] == 0xff &&\n\t\t    data[1] == 0xd8) {\n\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET,\n\t\t\t\t\tNULL, 0);\n\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\t\t\t\tsd->jpeg_hdr, JPEG_HDR_SZ);\n\t\t\t \n\t\t\tlen -= 2;\n\t\t\tdata += 2;\n\t\t}\n\t} else {\n\t\t \n\t\tif (gspca_dev->empty_packet) {\n\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET,\n\t\t\t\t\t\tNULL, 0);\n\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\t\t\t\tNULL, 0);\n\t\t\tgspca_dev->empty_packet = 0;\n\t\t}\n\t}\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}