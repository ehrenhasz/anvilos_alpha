{
  "module_name": "spca500.c",
  "hash_id": "8b5fe8ad6ff541be44833472999df5ffa82c20092dbb476f7905a18d9b6cbbda",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/spca500.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"spca500\"\n\n#include \"gspca.h\"\n#include \"jpeg.h\"\n\nMODULE_AUTHOR(\"Michel Xhaard <mxhaard@users.sourceforge.net>\");\nMODULE_DESCRIPTION(\"GSPCA/SPCA500 USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define QUALITY 85\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t\t \n\n\tchar subtype;\n#define AgfaCl20 0\n#define AiptekPocketDV 1\n#define BenqDC1016 2\n#define CreativePCCam300 3\n#define DLinkDSC350 4\n#define Gsmartmini 5\n#define IntelPocketPCCamera 6\n#define KodakEZ200 7\n#define LogitechClickSmart310 8\n#define LogitechClickSmart510 9\n#define LogitechTraveler 10\n#define MustekGsmart300 11\n#define Optimedia 12\n#define PalmPixDC85 13\n#define ToptroIndus 14\n\n\tu8 jpeg_hdr[JPEG_HDR_SZ];\n};\n\nstatic const struct v4l2_pix_format vga_mode[] = {\n\t{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{640, 480, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\n\nstatic const struct v4l2_pix_format sif_mode[] = {\n\t{176, 144, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 176 * 144 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{352, 288, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352,\n\t\t.sizeimage = 352 * 288 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\n\n \n#define SPCA500_OFFSET_PADDINGLB 2\n#define SPCA500_OFFSET_PADDINGHB 3\n#define SPCA500_OFFSET_MODE      4\n#define SPCA500_OFFSET_IMGWIDTH  5\n#define SPCA500_OFFSET_IMGHEIGHT 6\n#define SPCA500_OFFSET_IMGMODE   7\n#define SPCA500_OFFSET_QTBLINDEX 8\n#define SPCA500_OFFSET_FRAMSEQ   9\n#define SPCA500_OFFSET_CDSPINFO  10\n#define SPCA500_OFFSET_GPIO      11\n#define SPCA500_OFFSET_AUGPIO    12\n#define SPCA500_OFFSET_DATA      16\n\n\nstatic const __u16 spca500_visual_defaults[][3] = {\n\t{0x00, 0x0003, 0x816b},\t \n\t{0x00, 0x0000, 0x8167},\t \n\t{0x00, 0x0020, 0x8168},\t \n\t{0x00, 0x0003, 0x816b},\t \n\t{0x00, 0x0000, 0x816a},\t \n\t{0x00, 0x0020, 0x8169},\t \n\t{0x00, 0x0050, 0x8157},\t \n\t{0x00, 0x0030, 0x8158},\t \n\t{0x00, 0x0028, 0x8159},\t \n\t{0x00, 0x000a, 0x815a},\t \n\t{0x00, 0x0001, 0x8202},\t \n\t{0x0c, 0x0004, 0x0000},\n\t \n\t{}\n};\nstatic const __u16 Clicksmart510_defaults[][3] = {\n\t{0x00, 0x00, 0x8211},\n\t{0x00, 0x01, 0x82c0},\n\t{0x00, 0x10, 0x82cb},\n\t{0x00, 0x0f, 0x800d},\n\t{0x00, 0x82, 0x8225},\n\t{0x00, 0x21, 0x8228},\n\t{0x00, 0x00, 0x8203},\n\t{0x00, 0x00, 0x8204},\n\t{0x00, 0x08, 0x8205},\n\t{0x00, 0xf8, 0x8206},\n\t{0x00, 0x28, 0x8207},\n\t{0x00, 0xa0, 0x8208},\n\t{0x00, 0x08, 0x824a},\n\t{0x00, 0x08, 0x8214},\n\t{0x00, 0x80, 0x82c1},\n\t{0x00, 0x00, 0x82c2},\n\t{0x00, 0x00, 0x82ca},\n\t{0x00, 0x80, 0x82c1},\n\t{0x00, 0x04, 0x82c2},\n\t{0x00, 0x00, 0x82ca},\n\t{0x00, 0xfc, 0x8100},\n\t{0x00, 0xfc, 0x8105},\n\t{0x00, 0x30, 0x8101},\n\t{0x00, 0x00, 0x8102},\n\t{0x00, 0x00, 0x8103},\n\t{0x00, 0x66, 0x8107},\n\t{0x00, 0x00, 0x816b},\n\t{0x00, 0x00, 0x8155},\n\t{0x00, 0x01, 0x8156},\n\t{0x00, 0x60, 0x8157},\n\t{0x00, 0x40, 0x8158},\n\t{0x00, 0x0a, 0x8159},\n\t{0x00, 0x06, 0x815a},\n\t{0x00, 0x00, 0x813f},\n\t{0x00, 0x00, 0x8200},\n\t{0x00, 0x19, 0x8201},\n\t{0x00, 0x00, 0x82c1},\n\t{0x00, 0xa0, 0x82c2},\n\t{0x00, 0x00, 0x82ca},\n\t{0x00, 0x00, 0x8117},\n\t{0x00, 0x00, 0x8118},\n\t{0x00, 0x65, 0x8119},\n\t{0x00, 0x00, 0x811a},\n\t{0x00, 0x00, 0x811b},\n\t{0x00, 0x55, 0x811c},\n\t{0x00, 0x65, 0x811d},\n\t{0x00, 0x55, 0x811e},\n\t{0x00, 0x16, 0x811f},\n\t{0x00, 0x19, 0x8120},\n\t{0x00, 0x80, 0x8103},\n\t{0x00, 0x83, 0x816b},\n\t{0x00, 0x25, 0x8168},\n\t{0x00, 0x01, 0x820f},\n\t{0x00, 0xff, 0x8115},\n\t{0x00, 0x48, 0x8116},\n\t{0x00, 0x50, 0x8151},\n\t{0x00, 0x40, 0x8152},\n\t{0x00, 0x78, 0x8153},\n\t{0x00, 0x40, 0x8154},\n\t{0x00, 0x00, 0x8167},\n\t{0x00, 0x20, 0x8168},\n\t{0x00, 0x00, 0x816a},\n\t{0x00, 0x03, 0x816b},\n\t{0x00, 0x20, 0x8169},\n\t{0x00, 0x60, 0x8157},\n\t{0x00, 0x00, 0x8190},\n\t{0x00, 0x00, 0x81a1},\n\t{0x00, 0x00, 0x81b2},\n\t{0x00, 0x27, 0x8191},\n\t{0x00, 0x27, 0x81a2},\n\t{0x00, 0x27, 0x81b3},\n\t{0x00, 0x4b, 0x8192},\n\t{0x00, 0x4b, 0x81a3},\n\t{0x00, 0x4b, 0x81b4},\n\t{0x00, 0x66, 0x8193},\n\t{0x00, 0x66, 0x81a4},\n\t{0x00, 0x66, 0x81b5},\n\t{0x00, 0x79, 0x8194},\n\t{0x00, 0x79, 0x81a5},\n\t{0x00, 0x79, 0x81b6},\n\t{0x00, 0x8a, 0x8195},\n\t{0x00, 0x8a, 0x81a6},\n\t{0x00, 0x8a, 0x81b7},\n\t{0x00, 0x9b, 0x8196},\n\t{0x00, 0x9b, 0x81a7},\n\t{0x00, 0x9b, 0x81b8},\n\t{0x00, 0xa6, 0x8197},\n\t{0x00, 0xa6, 0x81a8},\n\t{0x00, 0xa6, 0x81b9},\n\t{0x00, 0xb2, 0x8198},\n\t{0x00, 0xb2, 0x81a9},\n\t{0x00, 0xb2, 0x81ba},\n\t{0x00, 0xbe, 0x8199},\n\t{0x00, 0xbe, 0x81aa},\n\t{0x00, 0xbe, 0x81bb},\n\t{0x00, 0xc8, 0x819a},\n\t{0x00, 0xc8, 0x81ab},\n\t{0x00, 0xc8, 0x81bc},\n\t{0x00, 0xd2, 0x819b},\n\t{0x00, 0xd2, 0x81ac},\n\t{0x00, 0xd2, 0x81bd},\n\t{0x00, 0xdb, 0x819c},\n\t{0x00, 0xdb, 0x81ad},\n\t{0x00, 0xdb, 0x81be},\n\t{0x00, 0xe4, 0x819d},\n\t{0x00, 0xe4, 0x81ae},\n\t{0x00, 0xe4, 0x81bf},\n\t{0x00, 0xed, 0x819e},\n\t{0x00, 0xed, 0x81af},\n\t{0x00, 0xed, 0x81c0},\n\t{0x00, 0xf7, 0x819f},\n\t{0x00, 0xf7, 0x81b0},\n\t{0x00, 0xf7, 0x81c1},\n\t{0x00, 0xff, 0x81a0},\n\t{0x00, 0xff, 0x81b1},\n\t{0x00, 0xff, 0x81c2},\n\t{0x00, 0x03, 0x8156},\n\t{0x00, 0x00, 0x8211},\n\t{0x00, 0x20, 0x8168},\n\t{0x00, 0x01, 0x8202},\n\t{0x00, 0x30, 0x8101},\n\t{0x00, 0x00, 0x8111},\n\t{0x00, 0x00, 0x8112},\n\t{0x00, 0x00, 0x8113},\n\t{0x00, 0x00, 0x8114},\n\t{}\n};\n\nstatic const __u8 qtable_creative_pccam[2][64] = {\n\t{\t\t\t\t \n\t 0x05, 0x03, 0x03, 0x05, 0x07, 0x0c, 0x0f, 0x12,\n\t 0x04, 0x04, 0x04, 0x06, 0x08, 0x11, 0x12, 0x11,\n\t 0x04, 0x04, 0x05, 0x07, 0x0c, 0x11, 0x15, 0x11,\n\t 0x04, 0x05, 0x07, 0x09, 0x0f, 0x1a, 0x18, 0x13,\n\t 0x05, 0x07, 0x0b, 0x11, 0x14, 0x21, 0x1f, 0x17,\n\t 0x07, 0x0b, 0x11, 0x13, 0x18, 0x1f, 0x22, 0x1c,\n\t 0x0f, 0x13, 0x17, 0x1a, 0x1f, 0x24, 0x24, 0x1e,\n\t 0x16, 0x1c, 0x1d, 0x1d, 0x22, 0x1e, 0x1f, 0x1e},\n\t{\t\t\t\t \n\t 0x05, 0x05, 0x07, 0x0e, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x05, 0x06, 0x08, 0x14, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x07, 0x08, 0x11, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x0e, 0x14, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e}\n};\n\nstatic const __u8 qtable_kodak_ez200[2][64] = {\n\t{\t\t\t\t \n\t 0x02, 0x01, 0x01, 0x02, 0x02, 0x04, 0x05, 0x06,\n\t 0x01, 0x01, 0x01, 0x02, 0x03, 0x06, 0x06, 0x06,\n\t 0x01, 0x01, 0x02, 0x02, 0x04, 0x06, 0x07, 0x06,\n\t 0x01, 0x02, 0x02, 0x03, 0x05, 0x09, 0x08, 0x06,\n\t 0x02, 0x02, 0x04, 0x06, 0x07, 0x0b, 0x0a, 0x08,\n\t 0x02, 0x04, 0x06, 0x06, 0x08, 0x0a, 0x0b, 0x09,\n\t 0x05, 0x06, 0x08, 0x09, 0x0a, 0x0c, 0x0c, 0x0a,\n\t 0x07, 0x09, 0x0a, 0x0a, 0x0b, 0x0a, 0x0a, 0x0a},\n\t{\t\t\t\t \n\t 0x02, 0x02, 0x02, 0x05, 0x0a, 0x0a, 0x0a, 0x0a,\n\t 0x02, 0x02, 0x03, 0x07, 0x0a, 0x0a, 0x0a, 0x0a,\n\t 0x02, 0x03, 0x06, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,\n\t 0x05, 0x07, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,\n\t 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,\n\t 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,\n\t 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,\n\t 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a}\n};\n\nstatic const __u8 qtable_pocketdv[2][64] = {\n\t{\t\t \n\t 0x06, 0x04, 0x04, 0x06, 0x0a, 0x10, 0x14, 0x18,\n\t 0x05, 0x05, 0x06, 0x08, 0x0a, 0x17, 0x18, 0x16,\n\t 0x06, 0x05, 0x06, 0x0a, 0x10, 0x17, 0x1c, 0x16,\n\t 0x06, 0x07, 0x09, 0x0c, 0x14, 0x23, 0x20, 0x19,\n\t 0x07, 0x09, 0x0f, 0x16, 0x1b, 0x2c, 0x29, 0x1f,\n\t 0x0a, 0x0e, 0x16, 0x1a, 0x20, 0x2a, 0x2d, 0x25,\n\t 0x14, 0x1a, 0x1f, 0x23, 0x29, 0x30, 0x30, 0x28,\n\t 0x1d, 0x25, 0x26, 0x27, 0x2d, 0x28, 0x29, 0x28,\n\t },\n\t{\t\t \n\t 0x07, 0x07, 0x0a, 0x13, 0x28, 0x28, 0x28, 0x28,\n\t 0x07, 0x08, 0x0a, 0x1a, 0x28, 0x28, 0x28, 0x28,\n\t 0x0a, 0x0a, 0x16, 0x28, 0x28, 0x28, 0x28, 0x28,\n\t 0x13, 0x1a, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,\n\t 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,\n\t 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,\n\t 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,\n\t 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28}\n};\n\n \nstatic void reg_r(struct gspca_dev *gspca_dev,\n\t\t  __u16 index,\n\t\t  __u16 length)\n{\n\tusb_control_msg(gspca_dev->dev,\n\t\t\tusb_rcvctrlpipe(gspca_dev->dev, 0),\n\t\t\t0,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0,\t\t \n\t\t\tindex, gspca_dev->usb_buf, length, 500);\n}\n\nstatic int reg_w(struct gspca_dev *gspca_dev,\n\t\t     __u16 req, __u16 index, __u16 value)\n{\n\tint ret;\n\n\tgspca_dbg(gspca_dev, D_USBO, \"reg write: [0x%02x] = 0x%02x\\n\",\n\t\t  index, value);\n\tret = usb_control_msg(gspca_dev->dev,\n\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\treq,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tvalue, index, NULL, 0, 500);\n\tif (ret < 0)\n\t\tpr_err(\"reg write: error %d\\n\", ret);\n\treturn ret;\n}\n\n \nstatic int reg_r_12(struct gspca_dev *gspca_dev,\n\t\t\t__u16 req,\t \n\t\t\t__u16 index,\t \n\t\t\t__u16 length)\t \n{\n\tint ret;\n\n\tgspca_dev->usb_buf[1] = 0;\n\tret = usb_control_msg(gspca_dev->dev,\n\t\t\tusb_rcvctrlpipe(gspca_dev->dev, 0),\n\t\t\treq,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0,\t\t \n\t\t\tindex,\n\t\t\tgspca_dev->usb_buf, length,\n\t\t\t500);\t\t \n\tif (ret < 0) {\n\t\tpr_err(\"reg_r_12 err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn (gspca_dev->usb_buf[1] << 8) + gspca_dev->usb_buf[0];\n}\n\n \nstatic int reg_r_wait(struct gspca_dev *gspca_dev,\n\t\t\t__u16 reg, __u16 index, __u16 value)\n{\n\tint ret, cnt = 20;\n\n\twhile (--cnt > 0) {\n\t\tret = reg_r_12(gspca_dev, reg, index, 1);\n\t\tif (ret == value)\n\t\t\treturn 0;\n\t\tmsleep(50);\n\t}\n\treturn -EIO;\n}\n\nstatic int write_vector(struct gspca_dev *gspca_dev,\n\t\t\tconst __u16 data[][3])\n{\n\tint ret, i = 0;\n\n\twhile (data[i][0] != 0 || data[i][1] != 0 || data[i][2] != 0) {\n\t\tret = reg_w(gspca_dev, data[i][0], data[i][2], data[i][1]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ti++;\n\t}\n\treturn 0;\n}\n\nstatic int spca50x_setup_qtable(struct gspca_dev *gspca_dev,\n\t\t\t\tunsigned int request,\n\t\t\t\tunsigned int ybase,\n\t\t\t\tunsigned int cbase,\n\t\t\t\tconst __u8 qtable[2][64])\n{\n\tint i, err;\n\n\t \n\tfor (i = 0; i < 64; i++) {\n\t\terr = reg_w(gspca_dev, request, ybase + i, qtable[0][i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < 64; i++) {\n\t\terr = reg_w(gspca_dev, request, cbase + i, qtable[1][i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void spca500_ping310(struct gspca_dev *gspca_dev)\n{\n\treg_r(gspca_dev, 0x0d04, 2);\n\tgspca_dbg(gspca_dev, D_STREAM, \"ClickSmart310 ping 0x0d04 0x%02x 0x%02x\\n\",\n\t\t  gspca_dev->usb_buf[0], gspca_dev->usb_buf[1]);\n}\n\nstatic void spca500_clksmart310_init(struct gspca_dev *gspca_dev)\n{\n\treg_r(gspca_dev, 0x0d05, 2);\n\tgspca_dbg(gspca_dev, D_STREAM, \"ClickSmart310 init 0x0d05 0x%02x 0x%02x\\n\",\n\t\t  gspca_dev->usb_buf[0], gspca_dev->usb_buf[1]);\n\treg_w(gspca_dev, 0x00, 0x8167, 0x5a);\n\tspca500_ping310(gspca_dev);\n\n\treg_w(gspca_dev, 0x00, 0x8168, 0x22);\n\treg_w(gspca_dev, 0x00, 0x816a, 0xc0);\n\treg_w(gspca_dev, 0x00, 0x816b, 0x0b);\n\treg_w(gspca_dev, 0x00, 0x8169, 0x25);\n\treg_w(gspca_dev, 0x00, 0x8157, 0x5b);\n\treg_w(gspca_dev, 0x00, 0x8158, 0x5b);\n\treg_w(gspca_dev, 0x00, 0x813f, 0x03);\n\treg_w(gspca_dev, 0x00, 0x8151, 0x4a);\n\treg_w(gspca_dev, 0x00, 0x8153, 0x78);\n\treg_w(gspca_dev, 0x00, 0x0d01, 0x04);\n\t\t\t\t\t\t \n\treg_w(gspca_dev, 0x00, 0x0d02, 0x01);\n\treg_w(gspca_dev, 0x00, 0x8169, 0x25);\n\treg_w(gspca_dev, 0x00, 0x0d01, 0x02);\n}\n\nstatic void spca500_setmode(struct gspca_dev *gspca_dev,\n\t\t\t__u8 xmult, __u8 ymult)\n{\n\tint mode;\n\n\t \n\treg_w(gspca_dev, 0, 0x8001, xmult);\n\n\t \n\treg_w(gspca_dev, 0, 0x8002, ymult);\n\n\t \n\tmode = gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv;\n\treg_w(gspca_dev, 0, 0x8003, mode << 4);\n}\n\nstatic int spca500_full_reset(struct gspca_dev *gspca_dev)\n{\n\tint err;\n\n\t \n\terr = reg_w(gspca_dev, 0xe0, 0x0001, 0x0000);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = reg_r_wait(gspca_dev, 0x06, 0x0000, 0x0000);\n\tif (err < 0)\n\t\treturn err;\n\terr = reg_w(gspca_dev, 0xe0, 0x0000, 0x0000);\n\tif (err < 0)\n\t\treturn err;\n\terr = reg_r_wait(gspca_dev, 0x06, 0, 0);\n\tif (err < 0) {\n\t\tgspca_err(gspca_dev, \"reg_r_wait() failed\\n\");\n\t\treturn err;\n\t}\n\t \n\treturn 0;\n}\n\n \n \n \n \n \n \nstatic int spca500_synch310(struct gspca_dev *gspca_dev)\n{\n\tif (usb_set_interface(gspca_dev->dev, gspca_dev->iface, 0) < 0) {\n\t\tgspca_err(gspca_dev, \"Set packet size: set interface error\\n\");\n\t\tgoto error;\n\t}\n\tspca500_ping310(gspca_dev);\n\n\treg_r(gspca_dev, 0x0d00, 1);\n\n\t \n\tgspca_dbg(gspca_dev, D_PACK, \"ClickSmart310 sync alt: %d\\n\",\n\t\t  gspca_dev->alt);\n\n\t \n\tif (usb_set_interface(gspca_dev->dev,\n\t\t\t\tgspca_dev->iface,\n\t\t\t\tgspca_dev->alt) < 0) {\n\t\tgspca_err(gspca_dev, \"Set packet size: set interface error\\n\");\n\t\tgoto error;\n\t}\n\treturn 0;\nerror:\n\treturn -EBUSY;\n}\n\nstatic void spca500_reinit(struct gspca_dev *gspca_dev)\n{\n\tint err;\n\t__u8 Data;\n\n\t \n\n\treg_w(gspca_dev, 0x00, 0x0d01, 0x01);\n\treg_w(gspca_dev, 0x00, 0x0d03, 0x00);\n\treg_w(gspca_dev, 0x00, 0x0d02, 0x01);\n\n\t \n\treg_w(gspca_dev, 0x00, 0x850a, 0x0001);\n\n\terr = spca50x_setup_qtable(gspca_dev, 0x00, 0x8800, 0x8840,\n\t\t\t\t qtable_pocketdv);\n\tif (err < 0)\n\t\tgspca_err(gspca_dev, \"spca50x_setup_qtable failed on init\\n\");\n\n\t \n\treg_w(gspca_dev, 0x00, 0x8880, 2);\n\t \n\treg_w(gspca_dev, 0x00, 0x800a, 0x00);\n\t \n\treg_w(gspca_dev, 0x00, 0x820f, 0x01);\n\t \n\treg_w(gspca_dev, 0x00, 0x870a, 0x04);\n\t \n\treg_w(gspca_dev, 0, 0x8003, 0x00);\n\t \n\treg_w(gspca_dev, 0x00, 0x8000, 0x0004);\n\tmsleep(2000);\n\tif (reg_r_wait(gspca_dev, 0, 0x8000, 0x44) != 0) {\n\t\treg_r(gspca_dev, 0x816b, 1);\n\t\tData = gspca_dev->usb_buf[0];\n\t\treg_w(gspca_dev, 0x00, 0x816b, Data);\n\t}\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam;\n\n\tcam = &gspca_dev->cam;\n\tsd->subtype = id->driver_info;\n\tif (sd->subtype != LogitechClickSmart310) {\n\t\tcam->cam_mode = vga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(vga_mode);\n\t} else {\n\t\tcam->cam_mode = sif_mode;\n\t\tcam->nmodes = ARRAY_SIZE(sif_mode);\n\t}\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t \n\tgspca_dbg(gspca_dev, D_STREAM, \"SPCA500 init\\n\");\n\tif (sd->subtype == LogitechClickSmart310)\n\t\tspca500_clksmart310_init(gspca_dev);\n \n\tgspca_dbg(gspca_dev, D_STREAM, \"SPCA500 init done\\n\");\n\treturn 0;\n}\n\nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint err;\n\t__u8 Data;\n\t__u8 xmult, ymult;\n\n\t \n\tjpeg_define(sd->jpeg_hdr, gspca_dev->pixfmt.height,\n\t\t\tgspca_dev->pixfmt.width,\n\t\t\t0x22);\t\t \n\tjpeg_set_qual(sd->jpeg_hdr, QUALITY);\n\n\tif (sd->subtype == LogitechClickSmart310) {\n\t\txmult = 0x16;\n\t\tymult = 0x12;\n\t} else {\n\t\txmult = 0x28;\n\t\tymult = 0x1e;\n\t}\n\n\t \n\treg_r(gspca_dev, 0x8a04, 1);\n\tgspca_dbg(gspca_dev, D_STREAM, \"Spca500 Sensor Address 0x%02x\\n\",\n\t\t  gspca_dev->usb_buf[0]);\n\tgspca_dbg(gspca_dev, D_STREAM, \"Spca500 curr_mode: %d Xmult: 0x%02x, Ymult: 0x%02x\",\n\t\t  gspca_dev->curr_mode, xmult, ymult);\n\n\t \n\tswitch (sd->subtype) {\n\tcase LogitechClickSmart310:\n\t\t spca500_setmode(gspca_dev, xmult, ymult);\n\n\t\t \n\t\treg_w(gspca_dev, 0x00, 0x850a, 0x0001);\n\t\treg_w(gspca_dev, 0x00, 0x8880, 3);\n\t\terr = spca50x_setup_qtable(gspca_dev,\n\t\t\t\t\t   0x00, 0x8800, 0x8840,\n\t\t\t\t\t   qtable_creative_pccam);\n\t\tif (err < 0)\n\t\t\tgspca_err(gspca_dev, \"spca50x_setup_qtable failed\\n\");\n\t\t \n\t\treg_w(gspca_dev, 0x00, 0x870a, 0x04);\n\n\t\t \n\t\treg_w(gspca_dev, 0x00, 0x8000, 0x0004);\n\t\tmsleep(500);\n\t\tif (reg_r_wait(gspca_dev, 0, 0x8000, 0x44) != 0)\n\t\t\tgspca_err(gspca_dev, \"reg_r_wait() failed\\n\");\n\n\t\treg_r(gspca_dev, 0x816b, 1);\n\t\tData = gspca_dev->usb_buf[0];\n\t\treg_w(gspca_dev, 0x00, 0x816b, Data);\n\n\t\tspca500_synch310(gspca_dev);\n\n\t\twrite_vector(gspca_dev, spca500_visual_defaults);\n\t\tspca500_setmode(gspca_dev, xmult, ymult);\n\t\t \n\t\terr = reg_w(gspca_dev, 0x00, 0x850a, 0x0001);\n\t\tif (err < 0)\n\t\t\tgspca_err(gspca_dev, \"failed to enable drop packet\\n\");\n\t\treg_w(gspca_dev, 0x00, 0x8880, 3);\n\t\terr = spca50x_setup_qtable(gspca_dev,\n\t\t\t\t\t   0x00, 0x8800, 0x8840,\n\t\t\t\t\t   qtable_creative_pccam);\n\t\tif (err < 0)\n\t\t\tgspca_err(gspca_dev, \"spca50x_setup_qtable failed\\n\");\n\n\t\t \n\t\treg_w(gspca_dev, 0x00, 0x870a, 0x04);\n\n\t\t \n\t\treg_w(gspca_dev, 0x00, 0x8000, 0x0004);\n\n\t\tif (reg_r_wait(gspca_dev, 0, 0x8000, 0x44) != 0)\n\t\t\tgspca_err(gspca_dev, \"reg_r_wait() failed\\n\");\n\n\t\treg_r(gspca_dev, 0x816b, 1);\n\t\tData = gspca_dev->usb_buf[0];\n\t\treg_w(gspca_dev, 0x00, 0x816b, Data);\n\t\tbreak;\n\tcase CreativePCCam300:\t\t \n\tcase IntelPocketPCCamera:\t \n\n\t\t \n\t\terr = spca500_full_reset(gspca_dev);\n\t\tif (err < 0)\n\t\t\tgspca_err(gspca_dev, \"spca500_full_reset failed\\n\");\n\n\t\t \n\t\terr = reg_w(gspca_dev, 0x00, 0x850a, 0x0001);\n\t\tif (err < 0)\n\t\t\tgspca_err(gspca_dev, \"failed to enable drop packet\\n\");\n\t\treg_w(gspca_dev, 0x00, 0x8880, 3);\n\t\terr = spca50x_setup_qtable(gspca_dev,\n\t\t\t\t\t   0x00, 0x8800, 0x8840,\n\t\t\t\t\t   qtable_creative_pccam);\n\t\tif (err < 0)\n\t\t\tgspca_err(gspca_dev, \"spca50x_setup_qtable failed\\n\");\n\n\t\tspca500_setmode(gspca_dev, xmult, ymult);\n\t\treg_w(gspca_dev, 0x20, 0x0001, 0x0004);\n\n\t\t \n\t\treg_w(gspca_dev, 0x00, 0x8000, 0x0004);\n\n\t\tif (reg_r_wait(gspca_dev, 0, 0x8000, 0x44) != 0)\n\t\t\tgspca_err(gspca_dev, \"reg_r_wait() failed\\n\");\n\n\t\treg_r(gspca_dev, 0x816b, 1);\n\t\tData = gspca_dev->usb_buf[0];\n\t\treg_w(gspca_dev, 0x00, 0x816b, Data);\n\n \n\t\tbreak;\n\tcase KodakEZ200:\t\t \n\n\t\t \n\t\terr = spca500_full_reset(gspca_dev);\n\t\tif (err < 0)\n\t\t\tgspca_err(gspca_dev, \"spca500_full_reset failed\\n\");\n\t\t \n\t\treg_w(gspca_dev, 0x00, 0x850a, 0x0001);\n\t\treg_w(gspca_dev, 0x00, 0x8880, 0);\n\t\terr = spca50x_setup_qtable(gspca_dev,\n\t\t\t\t\t   0x00, 0x8800, 0x8840,\n\t\t\t\t\t   qtable_kodak_ez200);\n\t\tif (err < 0)\n\t\t\tgspca_err(gspca_dev, \"spca50x_setup_qtable failed\\n\");\n\t\tspca500_setmode(gspca_dev, xmult, ymult);\n\n\t\treg_w(gspca_dev, 0x20, 0x0001, 0x0004);\n\n\t\t \n\t\treg_w(gspca_dev, 0x00, 0x8000, 0x0004);\n\n\t\tif (reg_r_wait(gspca_dev, 0, 0x8000, 0x44) != 0)\n\t\t\tgspca_err(gspca_dev, \"reg_r_wait() failed\\n\");\n\n\t\treg_r(gspca_dev, 0x816b, 1);\n\t\tData = gspca_dev->usb_buf[0];\n\t\treg_w(gspca_dev, 0x00, 0x816b, Data);\n\n \n\t\tbreak;\n\n\tcase BenqDC1016:\n\tcase DLinkDSC350:\t\t \n\tcase AiptekPocketDV:\t\t \n\tcase Gsmartmini:\t\t \n\tcase MustekGsmart300:\t\t \n\tcase PalmPixDC85:\n\tcase Optimedia:\n\tcase ToptroIndus:\n\tcase AgfaCl20:\n\t\tspca500_reinit(gspca_dev);\n\t\treg_w(gspca_dev, 0x00, 0x0d01, 0x01);\n\t\t \n\t\treg_w(gspca_dev, 0x00, 0x850a, 0x0001);\n\n\t\terr = spca50x_setup_qtable(gspca_dev,\n\t\t\t\t   0x00, 0x8800, 0x8840, qtable_pocketdv);\n\t\tif (err < 0)\n\t\t\tgspca_err(gspca_dev, \"spca50x_setup_qtable failed\\n\");\n\t\treg_w(gspca_dev, 0x00, 0x8880, 2);\n\n\t\t \n\t\treg_w(gspca_dev, 0x00, 0x800a, 0x00);\n\t\t \n\t\treg_w(gspca_dev, 0x00, 0x820f, 0x01);\n\t\t \n\t\treg_w(gspca_dev, 0x00, 0x870a, 0x04);\n\n\t\tspca500_setmode(gspca_dev, xmult, ymult);\n\t\t \n\t\treg_w(gspca_dev, 0x00, 0x8000, 0x0004);\n\n\t\treg_r_wait(gspca_dev, 0, 0x8000, 0x44);\n\n\t\treg_r(gspca_dev, 0x816b, 1);\n\t\tData = gspca_dev->usb_buf[0];\n\t\treg_w(gspca_dev, 0x00, 0x816b, Data);\n\t\tbreak;\n\tcase LogitechTraveler:\n\tcase LogitechClickSmart510:\n\t\treg_w(gspca_dev, 0x02, 0x00, 0x00);\n\t\t \n\t\treg_w(gspca_dev, 0x00, 0x850a, 0x0001);\n\n\t\terr = spca50x_setup_qtable(gspca_dev,\n\t\t\t\t\t0x00, 0x8800,\n\t\t\t\t\t0x8840, qtable_creative_pccam);\n\t\tif (err < 0)\n\t\t\tgspca_err(gspca_dev, \"spca50x_setup_qtable failed\\n\");\n\t\treg_w(gspca_dev, 0x00, 0x8880, 3);\n\t\treg_w(gspca_dev, 0x00, 0x800a, 0x00);\n\t\t \n\t\treg_w(gspca_dev, 0x00, 0x870a, 0x04);\n\n\t\tspca500_setmode(gspca_dev, xmult, ymult);\n\n\t\t \n\t\treg_w(gspca_dev, 0x00, 0x8000, 0x0004);\n\t\treg_r_wait(gspca_dev, 0, 0x8000, 0x44);\n\n\t\treg_r(gspca_dev, 0x816b, 1);\n\t\tData = gspca_dev->usb_buf[0];\n\t\treg_w(gspca_dev, 0x00, 0x816b, Data);\n\t\twrite_vector(gspca_dev, Clicksmart510_defaults);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\treg_w(gspca_dev, 0, 0x8003, 0x00);\n\n\t \n\treg_w(gspca_dev, 0x00, 0x8000, 0x0004);\n\treg_r(gspca_dev, 0x8000, 1);\n\tgspca_dbg(gspca_dev, D_STREAM, \"stop SPCA500 done reg8000: 0x%2x\\n\",\n\t\t  gspca_dev->usb_buf[0]);\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t \n\t\t\tint len)\t\t\t \n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint i;\n\tstatic __u8 ffd9[] = {0xff, 0xd9};\n\n \n\tif (data[0] == 0xff) {\n\t\tif (data[1] != 0x01) {\t \n \n\t\t\treturn;\n\t\t}\n\t\tgspca_frame_add(gspca_dev, LAST_PACKET,\n\t\t\t\t\tffd9, 2);\n\n\t\t \n\t\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\t\tsd->jpeg_hdr, JPEG_HDR_SZ);\n\n\t\tdata += SPCA500_OFFSET_DATA;\n\t\tlen -= SPCA500_OFFSET_DATA;\n\t} else {\n\t\tdata += 1;\n\t\tlen -= 1;\n\t}\n\n\t \n\ti = 0;\n\tdo {\n\t\tif (data[i] == 0xff) {\n\t\t\tgspca_frame_add(gspca_dev, INTER_PACKET,\n\t\t\t\t\tdata, i + 1);\n\t\t\tlen -= i;\n\t\t\tdata += i;\n\t\t\t*data = 0x00;\n\t\t\ti = 0;\n\t\t}\n\t\ti++;\n\t} while (i < len);\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n}\n\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\n{\n\treg_w(gspca_dev, 0x00, 0x8167,\n\t\t\t(__u8) (val - 128));\n}\n\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 val)\n{\n\treg_w(gspca_dev, 0x00, 0x8168, val);\n}\n\nstatic void setcolors(struct gspca_dev *gspca_dev, s32 val)\n{\n\treg_w(gspca_dev, 0x00, 0x8169, val);\n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\n\tgspca_dev->usb_err = 0;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsetbrightness(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tsetcontrast(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tsetcolors(gspca_dev, ctrl->val);\n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 3);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 255, 1, 127);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 63, 1, 31);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 63, 1, 31);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\treturn 0;\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.pkt_scan = sd_pkt_scan,\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x040a, 0x0300), .driver_info = KodakEZ200},\n\t{USB_DEVICE(0x041e, 0x400a), .driver_info = CreativePCCam300},\n\t{USB_DEVICE(0x046d, 0x0890), .driver_info = LogitechTraveler},\n\t{USB_DEVICE(0x046d, 0x0900), .driver_info = LogitechClickSmart310},\n\t{USB_DEVICE(0x046d, 0x0901), .driver_info = LogitechClickSmart510},\n\t{USB_DEVICE(0x04a5, 0x300c), .driver_info = BenqDC1016},\n\t{USB_DEVICE(0x04fc, 0x7333), .driver_info = PalmPixDC85},\n\t{USB_DEVICE(0x055f, 0xc200), .driver_info = MustekGsmart300},\n\t{USB_DEVICE(0x055f, 0xc220), .driver_info = Gsmartmini},\n\t{USB_DEVICE(0x06bd, 0x0404), .driver_info = AgfaCl20},\n\t{USB_DEVICE(0x06be, 0x0800), .driver_info = Optimedia},\n\t{USB_DEVICE(0x084d, 0x0003), .driver_info = DLinkDSC350},\n\t{USB_DEVICE(0x08ca, 0x0103), .driver_info = AiptekPocketDV},\n\t{USB_DEVICE(0x2899, 0x012c), .driver_info = ToptroIndus},\n\t{USB_DEVICE(0x8086, 0x0630), .driver_info = IntelPocketPCCamera},\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}