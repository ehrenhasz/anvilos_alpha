{
  "module_name": "gspca.c",
  "hash_id": "a99fdab0212120c4a6c388d7e64c2941b1ada8929cd7c9c5a839c5c13b864c42",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/gspca.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define GSPCA_VERSION\t\"2.14.0\"\n\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/pagemap.h>\n#include <linux/io.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/ktime.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-event.h>\n\n#include \"gspca.h\"\n\n#if IS_ENABLED(CONFIG_INPUT)\n#include <linux/input.h>\n#include <linux/usb/input.h>\n#endif\n\n \n#define DEF_NURBS 3\t\t \n#if DEF_NURBS > MAX_NURBS\n#error \"DEF_NURBS too big\"\n#endif\n\nMODULE_AUTHOR(\"Jean-Fran\u00e7ois Moine <http://moinejf.free.fr>\");\nMODULE_DESCRIPTION(\"GSPCA USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(GSPCA_VERSION);\n\nint gspca_debug;\nEXPORT_SYMBOL(gspca_debug);\n\nstatic void PDEBUG_MODE(struct gspca_dev *gspca_dev, int debug, char *txt,\n\t\t\t__u32 pixfmt, int w, int h)\n{\n\tif ((pixfmt >> 24) >= '0' && (pixfmt >> 24) <= 'z') {\n\t\tgspca_dbg(gspca_dev, debug, \"%s %c%c%c%c %dx%d\\n\",\n\t\t\t  txt,\n\t\t\t  pixfmt & 0xff,\n\t\t\t  (pixfmt >> 8) & 0xff,\n\t\t\t  (pixfmt >> 16) & 0xff,\n\t\t\t  pixfmt >> 24,\n\t\t\t  w, h);\n\t} else {\n\t\tgspca_dbg(gspca_dev, debug, \"%s 0x%08x %dx%d\\n\",\n\t\t\t  txt,\n\t\t\t  pixfmt,\n\t\t\t  w, h);\n\t}\n}\n\n \n#define GSPCA_MEMORY_NO 0\t \n#define GSPCA_MEMORY_READ 7\n\n \n#if IS_ENABLED(CONFIG_INPUT)\nstatic void int_irq(struct urb *urb)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *) urb->context;\n\tint ret;\n\n\tret = urb->status;\n\tswitch (ret) {\n\tcase 0:\n\t\tif (gspca_dev->sd_desc->int_pkt_scan(gspca_dev,\n\t\t    urb->transfer_buffer, urb->actual_length) < 0) {\n\t\t\tgspca_err(gspca_dev, \"Unknown packet received\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ENODEV:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tgspca_err(gspca_dev, \"URB error %i, resubmitting\\n\",\n\t\t\t  urb->status);\n\t\turb->status = 0;\n\t\tret = 0;\n\t}\n\n\tif (ret == 0) {\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret < 0)\n\t\t\tpr_err(\"Resubmit URB failed with error %i\\n\", ret);\n\t}\n}\n\nstatic int gspca_input_connect(struct gspca_dev *dev)\n{\n\tstruct input_dev *input_dev;\n\tint err = 0;\n\n\tdev->input_dev = NULL;\n\tif (dev->sd_desc->int_pkt_scan || dev->sd_desc->other_input)  {\n\t\tinput_dev = input_allocate_device();\n\t\tif (!input_dev)\n\t\t\treturn -ENOMEM;\n\n\t\tusb_make_path(dev->dev, dev->phys, sizeof(dev->phys));\n\t\tstrlcat(dev->phys, \"/input0\", sizeof(dev->phys));\n\n\t\tinput_dev->name = dev->sd_desc->name;\n\t\tinput_dev->phys = dev->phys;\n\n\t\tusb_to_input_id(dev->dev, &input_dev->id);\n\n\t\tinput_dev->evbit[0] = BIT_MASK(EV_KEY);\n\t\tinput_dev->keybit[BIT_WORD(KEY_CAMERA)] = BIT_MASK(KEY_CAMERA);\n\t\tinput_dev->dev.parent = &dev->dev->dev;\n\n\t\terr = input_register_device(input_dev);\n\t\tif (err) {\n\t\t\tpr_err(\"Input device registration failed with error %i\\n\",\n\t\t\t       err);\n\t\t\tinput_dev->dev.parent = NULL;\n\t\t\tinput_free_device(input_dev);\n\t\t} else {\n\t\t\tdev->input_dev = input_dev;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int alloc_and_submit_int_urb(struct gspca_dev *gspca_dev,\n\t\t\t  struct usb_endpoint_descriptor *ep)\n{\n\tunsigned int buffer_len;\n\tint interval;\n\tstruct urb *urb;\n\tstruct usb_device *dev;\n\tvoid *buffer = NULL;\n\tint ret = -EINVAL;\n\n\tbuffer_len = le16_to_cpu(ep->wMaxPacketSize);\n\tinterval = ep->bInterval;\n\tgspca_dbg(gspca_dev, D_CONF, \"found int in endpoint: 0x%x, buffer_len=%u, interval=%u\\n\",\n\t\t  ep->bEndpointAddress, buffer_len, interval);\n\n\tdev = gspca_dev->dev;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tbuffer = usb_alloc_coherent(dev, buffer_len,\n\t\t\t\tGFP_KERNEL, &urb->transfer_dma);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto error_buffer;\n\t}\n\tusb_fill_int_urb(urb, dev,\n\t\tusb_rcvintpipe(dev, ep->bEndpointAddress),\n\t\tbuffer, buffer_len,\n\t\tint_irq, (void *)gspca_dev, interval);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tgspca_err(gspca_dev, \"submit int URB failed with error %i\\n\",\n\t\t\t  ret);\n\t\tgoto error_submit;\n\t}\n\tgspca_dev->int_urb = urb;\n\treturn ret;\n\nerror_submit:\n\tusb_free_coherent(dev,\n\t\t\t  urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer,\n\t\t\t  urb->transfer_dma);\nerror_buffer:\n\tusb_free_urb(urb);\nerror:\n\treturn ret;\n}\n\nstatic void gspca_input_create_urb(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *intf_desc;\n\tstruct usb_endpoint_descriptor *ep;\n\tint i;\n\n\tif (gspca_dev->sd_desc->int_pkt_scan)  {\n\t\tintf = usb_ifnum_to_if(gspca_dev->dev, gspca_dev->iface);\n\t\tintf_desc = intf->cur_altsetting;\n\t\tfor (i = 0; i < intf_desc->desc.bNumEndpoints; i++) {\n\t\t\tep = &intf_desc->endpoint[i].desc;\n\t\t\tif (usb_endpoint_dir_in(ep) &&\n\t\t\t    usb_endpoint_xfer_int(ep)) {\n\n\t\t\t\talloc_and_submit_int_urb(gspca_dev, ep);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void gspca_input_destroy_urb(struct gspca_dev *gspca_dev)\n{\n\tstruct urb *urb;\n\n\turb = gspca_dev->int_urb;\n\tif (urb) {\n\t\tgspca_dev->int_urb = NULL;\n\t\tusb_kill_urb(urb);\n\t\tusb_free_coherent(gspca_dev->dev,\n\t\t\t\t  urb->transfer_buffer_length,\n\t\t\t\t  urb->transfer_buffer,\n\t\t\t\t  urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\t}\n}\n#else\nstatic inline void gspca_input_destroy_urb(struct gspca_dev *gspca_dev)\n{\n}\n\nstatic inline void gspca_input_create_urb(struct gspca_dev *gspca_dev)\n{\n}\n\nstatic inline int gspca_input_connect(struct gspca_dev *dev)\n{\n\treturn 0;\n}\n#endif\n\n \nstatic void fill_frame(struct gspca_dev *gspca_dev,\n\t\t\tstruct urb *urb)\n{\n\tu8 *data;\t\t \n\tint i, len, st;\n\tcam_pkt_op pkt_scan;\n\n\tif (urb->status != 0) {\n\t\tif (urb->status == -ESHUTDOWN)\n\t\t\treturn;\t\t \n#ifdef CONFIG_PM\n\t\tif (gspca_dev->frozen)\n\t\t\treturn;\n#endif\n\t\tgspca_err(gspca_dev, \"urb status: %d\\n\", urb->status);\n\t\turb->status = 0;\n\t\tgoto resubmit;\n\t}\n\tpkt_scan = gspca_dev->sd_desc->pkt_scan;\n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\tlen = urb->iso_frame_desc[i].actual_length;\n\n\t\t \n\t\tst = urb->iso_frame_desc[i].status;\n\t\tif (st) {\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"ISOC data error: [%d] len=%d, status=%d\\n\",\n\t\t\t       i, len, st);\n\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\tcontinue;\n\t\t}\n\t\tif (len == 0) {\n\t\t\tif (gspca_dev->empty_packet == 0)\n\t\t\t\tgspca_dev->empty_packet = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tgspca_dbg(gspca_dev, D_PACK, \"packet [%d] o:%d l:%d\\n\",\n\t\t\t  i, urb->iso_frame_desc[i].offset, len);\n\t\tdata = (u8 *) urb->transfer_buffer\n\t\t\t\t\t+ urb->iso_frame_desc[i].offset;\n\t\tpkt_scan(gspca_dev, data, len);\n\t}\n\nresubmit:\n\tif (!gspca_dev->streaming)\n\t\treturn;\n\t \n\tst = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (st < 0)\n\t\tpr_err(\"usb_submit_urb() ret %d\\n\", st);\n}\n\n \nstatic void isoc_irq(struct urb *urb)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *) urb->context;\n\n\tgspca_dbg(gspca_dev, D_PACK, \"isoc irq\\n\");\n\tif (!gspca_dev->streaming)\n\t\treturn;\n\tfill_frame(gspca_dev, urb);\n}\n\n \nstatic void bulk_irq(struct urb *urb)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *) urb->context;\n\tint st;\n\n\tgspca_dbg(gspca_dev, D_PACK, \"bulk irq\\n\");\n\tif (!gspca_dev->streaming)\n\t\treturn;\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ESHUTDOWN:\n\t\treturn;\t\t \n\tdefault:\n#ifdef CONFIG_PM\n\t\tif (gspca_dev->frozen)\n\t\t\treturn;\n#endif\n\t\tgspca_err(gspca_dev, \"urb status: %d\\n\", urb->status);\n\t\turb->status = 0;\n\t\tgoto resubmit;\n\t}\n\n\tgspca_dbg(gspca_dev, D_PACK, \"packet l:%d\\n\", urb->actual_length);\n\tgspca_dev->sd_desc->pkt_scan(gspca_dev,\n\t\t\t\turb->transfer_buffer,\n\t\t\t\turb->actual_length);\n\nresubmit:\n\tif (!gspca_dev->streaming)\n\t\treturn;\n\t \n\tif (gspca_dev->cam.bulk_nurbs != 0) {\n\t\tst = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (st < 0)\n\t\t\tpr_err(\"usb_submit_urb() ret %d\\n\", st);\n\t}\n}\n\n \nvoid gspca_frame_add(struct gspca_dev *gspca_dev,\n\t\t\tenum gspca_packet_type packet_type,\n\t\t\tconst u8 *data,\n\t\t\tint len)\n{\n\tstruct gspca_buffer *buf;\n\tunsigned long flags;\n\n\tgspca_dbg(gspca_dev, D_PACK, \"add t:%d l:%d\\n\",\tpacket_type, len);\n\n\tspin_lock_irqsave(&gspca_dev->qlock, flags);\n\tbuf = list_first_entry_or_null(&gspca_dev->buf_list,\n\t\t\t\t       typeof(*buf), list);\n\tspin_unlock_irqrestore(&gspca_dev->qlock, flags);\n\n\tif (packet_type == FIRST_PACKET) {\n\t\t \n\t\tif (!buf) {\n\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\tgspca_dev->sequence++;\n\t\t\treturn;\n\t\t}\n\t\tgspca_dev->image = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\n\t\tgspca_dev->image_len = 0;\n\t} else {\n\t\tswitch (gspca_dev->last_packet_type) {\n\t\tcase DISCARD_PACKET:\n\t\t\tif (packet_type == LAST_PACKET) {\n\t\t\t\tgspca_dev->last_packet_type = packet_type;\n\t\t\t\tgspca_dev->image = NULL;\n\t\t\t\tgspca_dev->image_len = 0;\n\t\t\t}\n\t\t\treturn;\n\t\tcase LAST_PACKET:\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (len > 0) {\n\t\tif (gspca_dev->image_len + len > PAGE_ALIGN(gspca_dev->pixfmt.sizeimage)) {\n\t\t\tgspca_err(gspca_dev, \"frame overflow %d > %d\\n\",\n\t\t\t\t  gspca_dev->image_len + len,\n\t\t\t\t  PAGE_ALIGN(gspca_dev->pixfmt.sizeimage));\n\t\t\tpacket_type = DISCARD_PACKET;\n\t\t} else {\n \n\t\t\tmemcpy(gspca_dev->image + gspca_dev->image_len,\n\t\t\t\tdata, len);\n\t\t\tgspca_dev->image_len += len;\n\t\t}\n\t}\n\tgspca_dev->last_packet_type = packet_type;\n\n\t \n\tif (packet_type == LAST_PACKET) {\n\t\tif (gspca_dev->image_len > gspca_dev->pixfmt.sizeimage)\n\t\t\tgspca_dev->image_len = gspca_dev->pixfmt.sizeimage;\n\t\tspin_lock_irqsave(&gspca_dev->qlock, flags);\n\t\tlist_del(&buf->list);\n\t\tspin_unlock_irqrestore(&gspca_dev->qlock, flags);\n\t\tbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\tvb2_set_plane_payload(&buf->vb.vb2_buf, 0,\n\t\t\t\t      gspca_dev->image_len);\n\t\tbuf->vb.sequence = gspca_dev->sequence++;\n\t\tbuf->vb.field = V4L2_FIELD_NONE;\n\t\tgspca_dbg(gspca_dev, D_FRAM, \"frame complete len:%d\\n\",\n\t\t\t  gspca_dev->image_len);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\t\tgspca_dev->image = NULL;\n\t\tgspca_dev->image_len = 0;\n\t}\n}\nEXPORT_SYMBOL(gspca_frame_add);\n\nstatic void destroy_urbs(struct gspca_dev *gspca_dev)\n{\n\tstruct urb *urb;\n\tunsigned int i;\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"kill transfer\\n\");\n\n\t \n\tfor (i = 0; i < MAX_NURBS; i++)\n\t\tusb_kill_urb(gspca_dev->urb[i]);\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"releasing urbs\\n\");\n\tfor (i = 0; i < MAX_NURBS; i++) {\n\t\turb = gspca_dev->urb[i];\n\t\tif (!urb)\n\t\t\tcontinue;\n\t\tgspca_dev->urb[i] = NULL;\n\t\tusb_free_coherent(gspca_dev->dev,\n\t\t\t\t  urb->transfer_buffer_length,\n\t\t\t\t  urb->transfer_buffer,\n\t\t\t\t  urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\t}\n}\n\nstatic int gspca_set_alt0(struct gspca_dev *gspca_dev)\n{\n\tint ret;\n\n\tif (gspca_dev->alt == 0)\n\t\treturn 0;\n\tret = usb_set_interface(gspca_dev->dev, gspca_dev->iface, 0);\n\tif (ret < 0)\n\t\tpr_err(\"set alt 0 err %d\\n\", ret);\n\treturn ret;\n}\n\n \nstatic struct usb_host_endpoint *alt_xfer(struct usb_host_interface *alt,\n\t\t\t\t\t  int xfer, int xfer_ep)\n{\n\tstruct usb_host_endpoint *ep;\n\tint i, attr;\n\n\tfor (i = 0; i < alt->desc.bNumEndpoints; i++) {\n\t\tep = &alt->endpoint[i];\n\t\tattr = ep->desc.bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\n\t\tif (attr == xfer\n\t\t    && ep->desc.wMaxPacketSize != 0\n\t\t    && usb_endpoint_dir_in(&ep->desc)\n\t\t    && (xfer_ep < 0 || ep->desc.bEndpointAddress == xfer_ep))\n\t\t\treturn ep;\n\t}\n\treturn NULL;\n}\n\n \nstatic u32 which_bandwidth(struct gspca_dev *gspca_dev)\n{\n\tu32 bandwidth;\n\n\t \n\tbandwidth = gspca_dev->pixfmt.sizeimage;\n\n\t \n\tif (!gspca_dev->cam.needs_full_bandwidth &&\n\t    bandwidth < gspca_dev->pixfmt.width *\n\t\t\t\tgspca_dev->pixfmt.height)\n\t\tbandwidth = bandwidth * 3 / 8;\t \n\n\t \n\tif (gspca_dev->sd_desc->get_streamparm) {\n\t\tstruct v4l2_streamparm parm;\n\n\t\tgspca_dev->sd_desc->get_streamparm(gspca_dev, &parm);\n\t\tbandwidth *= parm.parm.capture.timeperframe.denominator;\n\t\tbandwidth /= parm.parm.capture.timeperframe.numerator;\n\t} else {\n\n\t\t \n\t\tif (gspca_dev->pixfmt.width >= 640\n\t\t && gspca_dev->dev->speed == USB_SPEED_FULL)\n\t\t\tbandwidth *= 15;\t\t \n\t\telse\n\t\t\tbandwidth *= 30;\t\t \n\t}\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"min bandwidth: %d\\n\", bandwidth);\n\treturn bandwidth;\n}\n\n \n#define MAX_ALT 16\nstruct ep_tb_s {\n\tu32 alt;\n\tu32 bandwidth;\n};\n\n \nstatic int build_isoc_ep_tb(struct gspca_dev *gspca_dev,\n\t\t\tstruct usb_interface *intf,\n\t\t\tstruct ep_tb_s *ep_tb)\n{\n\tstruct usb_host_endpoint *ep;\n\tint i, j, nbalt, psize, found;\n\tu32 bandwidth, last_bw;\n\n\tnbalt = intf->num_altsetting;\n\tif (nbalt > MAX_ALT)\n\t\tnbalt = MAX_ALT;\t \n\n\t \n\ti = 0;\n\tlast_bw = 0;\n\tfor (;;) {\n\t\tep_tb->bandwidth = 2000 * 2000 * 120;\n\t\tfound = 0;\n\t\tfor (j = 0; j < nbalt; j++) {\n\t\t\tep = alt_xfer(&intf->altsetting[j],\n\t\t\t\t      USB_ENDPOINT_XFER_ISOC,\n\t\t\t\t      gspca_dev->xfer_ep);\n\t\t\tif (ep == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (ep->desc.bInterval == 0) {\n\t\t\t\tpr_err(\"alt %d iso endp with 0 interval\\n\", j);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpsize = le16_to_cpu(ep->desc.wMaxPacketSize);\n\t\t\tpsize = (psize & 0x07ff) * (1 + ((psize >> 11) & 3));\n\t\t\tbandwidth = psize * 1000;\n\t\t\tif (gspca_dev->dev->speed == USB_SPEED_HIGH\n\t\t\t || gspca_dev->dev->speed >= USB_SPEED_SUPER)\n\t\t\t\tbandwidth *= 8;\n\t\t\tbandwidth /= 1 << (ep->desc.bInterval - 1);\n\t\t\tif (bandwidth <= last_bw)\n\t\t\t\tcontinue;\n\t\t\tif (bandwidth < ep_tb->bandwidth) {\n\t\t\t\tep_tb->bandwidth = bandwidth;\n\t\t\t\tep_tb->alt = j;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tbreak;\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"alt %d bandwidth %d\\n\",\n\t\t\t  ep_tb->alt, ep_tb->bandwidth);\n\t\tlast_bw = ep_tb->bandwidth;\n\t\ti++;\n\t\tep_tb++;\n\t}\n\n\t \n\tif (gspca_dev->audio &&\n\t\t\tgspca_dev->dev->speed == USB_SPEED_FULL &&\n\t\t\tlast_bw >= 1000000 &&\n\t\t\ti > 1) {\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"dev has usb audio, skipping highest alt\\n\");\n\t\ti--;\n\t\tep_tb--;\n\t}\n\n\t \n\tbandwidth = which_bandwidth(gspca_dev);\n\tep_tb--;\n\twhile (i > 1) {\n\t\tep_tb--;\n\t\tif (ep_tb->bandwidth < bandwidth)\n\t\t\tbreak;\n\t\ti--;\n\t}\n\treturn i;\n}\n\n \nstatic int create_urbs(struct gspca_dev *gspca_dev,\n\t\t\tstruct usb_host_endpoint *ep)\n{\n\tstruct urb *urb;\n\tint n, nurbs, i, psize, npkt, bsize;\n\n\t \n\tpsize = le16_to_cpu(ep->desc.wMaxPacketSize);\n\n\tif (!gspca_dev->cam.bulk) {\t\t \n\n\t\t \n\t\tif (gspca_dev->pkt_size == 0)\n\t\t\tpsize = (psize & 0x07ff) * (1 + ((psize >> 11) & 3));\n\t\telse\n\t\t\tpsize = gspca_dev->pkt_size;\n\t\tnpkt = gspca_dev->cam.npkt;\n\t\tif (npkt == 0)\n\t\t\tnpkt = 32;\t\t \n\t\tbsize = psize * npkt;\n\t\tgspca_dbg(gspca_dev, D_STREAM,\n\t\t\t  \"isoc %d pkts size %d = bsize:%d\\n\",\n\t\t\t  npkt, psize, bsize);\n\t\tnurbs = DEF_NURBS;\n\t} else {\t\t\t\t \n\t\tnpkt = 0;\n\t\tbsize = gspca_dev->cam.bulk_size;\n\t\tif (bsize == 0)\n\t\t\tbsize = psize;\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"bulk bsize:%d\\n\", bsize);\n\t\tif (gspca_dev->cam.bulk_nurbs != 0)\n\t\t\tnurbs = gspca_dev->cam.bulk_nurbs;\n\t\telse\n\t\t\tnurbs = 1;\n\t}\n\n\tfor (n = 0; n < nurbs; n++) {\n\t\turb = usb_alloc_urb(npkt, GFP_KERNEL);\n\t\tif (!urb)\n\t\t\treturn -ENOMEM;\n\t\tgspca_dev->urb[n] = urb;\n\t\turb->transfer_buffer = usb_alloc_coherent(gspca_dev->dev,\n\t\t\t\t\t\tbsize,\n\t\t\t\t\t\tGFP_KERNEL,\n\t\t\t\t\t\t&urb->transfer_dma);\n\n\t\tif (urb->transfer_buffer == NULL) {\n\t\t\tpr_err(\"usb_alloc_coherent failed\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\turb->dev = gspca_dev->dev;\n\t\turb->context = gspca_dev;\n\t\turb->transfer_buffer_length = bsize;\n\t\tif (npkt != 0) {\t\t \n\t\t\turb->pipe = usb_rcvisocpipe(gspca_dev->dev,\n\t\t\t\t\t\t    ep->desc.bEndpointAddress);\n\t\t\turb->transfer_flags = URB_ISO_ASAP\n\t\t\t\t\t| URB_NO_TRANSFER_DMA_MAP;\n\t\t\turb->interval = 1 << (ep->desc.bInterval - 1);\n\t\t\turb->complete = isoc_irq;\n\t\t\turb->number_of_packets = npkt;\n\t\t\tfor (i = 0; i < npkt; i++) {\n\t\t\t\turb->iso_frame_desc[i].length = psize;\n\t\t\t\turb->iso_frame_desc[i].offset = psize * i;\n\t\t\t}\n\t\t} else {\t\t \n\t\t\turb->pipe = usb_rcvbulkpipe(gspca_dev->dev,\n\t\t\t\t\t\tep->desc.bEndpointAddress);\n\t\t\turb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\t\t\turb->complete = bulk_irq;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void gspca_stream_off(struct gspca_dev *gspca_dev)\n{\n\tgspca_dev->streaming = false;\n\tgspca_dev->usb_err = 0;\n\tif (gspca_dev->sd_desc->stopN)\n\t\tgspca_dev->sd_desc->stopN(gspca_dev);\n\tdestroy_urbs(gspca_dev);\n\tgspca_input_destroy_urb(gspca_dev);\n\tgspca_set_alt0(gspca_dev);\n\tif (gspca_dev->present)\n\t\tgspca_input_create_urb(gspca_dev);\n\tif (gspca_dev->sd_desc->stop0)\n\t\tgspca_dev->sd_desc->stop0(gspca_dev);\n\tgspca_dbg(gspca_dev, D_STREAM, \"stream off OK\\n\");\n}\n\n \nstatic int gspca_init_transfer(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_endpoint *ep;\n\tstruct urb *urb;\n\tstruct ep_tb_s ep_tb[MAX_ALT];\n\tint n, ret, xfer, alt, alt_idx;\n\n\t \n\tgspca_dev->image = NULL;\n\tgspca_dev->image_len = 0;\n\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\n\tgspca_dev->usb_err = 0;\n\n\t \n\tintf = usb_ifnum_to_if(gspca_dev->dev, gspca_dev->iface);\n\tgspca_dev->alt = gspca_dev->cam.bulk ? intf->num_altsetting : 0;\n\tif (gspca_dev->sd_desc->isoc_init) {\n\t\tret = gspca_dev->sd_desc->isoc_init(gspca_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\txfer = gspca_dev->cam.bulk ? USB_ENDPOINT_XFER_BULK\n\t\t\t\t   : USB_ENDPOINT_XFER_ISOC;\n\n\t \n\tif (gspca_dev->alt != 0) {\n\t\tgspca_dev->alt--;\t \n\t\tep = alt_xfer(&intf->altsetting[gspca_dev->alt], xfer,\n\t\t\t      gspca_dev->xfer_ep);\n\t\tif (ep == NULL) {\n\t\t\tpr_err(\"bad altsetting %d\\n\", gspca_dev->alt);\n\t\t\treturn -EIO;\n\t\t}\n\t\tep_tb[0].alt = gspca_dev->alt;\n\t\talt_idx = 1;\n\t} else {\n\t\t \n\t\talt_idx = build_isoc_ep_tb(gspca_dev, intf, ep_tb);\n\t\tif (alt_idx <= 0) {\n\t\t\tpr_err(\"no transfer endpoint found\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t \n\tgspca_input_destroy_urb(gspca_dev);\n\n\tgspca_dev->alt = ep_tb[--alt_idx].alt;\n\talt = -1;\n\tfor (;;) {\n\t\tif (alt != gspca_dev->alt) {\n\t\t\talt = gspca_dev->alt;\n\t\t\tif (intf->num_altsetting > 1) {\n\t\t\t\tret = usb_set_interface(gspca_dev->dev,\n\t\t\t\t\t\t\tgspca_dev->iface,\n\t\t\t\t\t\t\talt);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (ret == -ENOSPC)\n\t\t\t\t\t\tgoto retry;  \n\t\t\t\t\tpr_err(\"set alt %d err %d\\n\", alt, ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!gspca_dev->cam.no_urb_create) {\n\t\t\tgspca_dbg(gspca_dev, D_STREAM, \"init transfer alt %d\\n\",\n\t\t\t\t  alt);\n\t\t\tret = create_urbs(gspca_dev,\n\t\t\t\talt_xfer(&intf->altsetting[alt], xfer,\n\t\t\t\t\t gspca_dev->xfer_ep));\n\t\t\tif (ret < 0) {\n\t\t\t\tdestroy_urbs(gspca_dev);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (gspca_dev->cam.bulk)\n\t\t\tusb_clear_halt(gspca_dev->dev,\n\t\t\t\t\tgspca_dev->urb[0]->pipe);\n\n\t\t \n\t\tret = gspca_dev->sd_desc->start(gspca_dev);\n\t\tif (ret < 0) {\n\t\t\tdestroy_urbs(gspca_dev);\n\t\t\tgoto out;\n\t\t}\n\t\tv4l2_ctrl_handler_setup(gspca_dev->vdev.ctrl_handler);\n\t\tgspca_dev->streaming = true;\n\n\t\t \n\t\tif (gspca_dev->cam.bulk && gspca_dev->cam.bulk_nurbs == 0)\n\t\t\tbreak;\n\n\t\t \n\t\tfor (n = 0; n < MAX_NURBS; n++) {\n\t\t\turb = gspca_dev->urb[n];\n\t\t\tif (urb == NULL)\n\t\t\t\tbreak;\n\t\t\tret = usb_submit_urb(urb, GFP_KERNEL);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (ret >= 0)\n\t\t\tbreak;\t\t\t \n\n\t\t \n\t\tgspca_stream_off(gspca_dev);\n\t\tif (ret != -ENOSPC) {\n\t\t\tpr_err(\"usb_submit_urb alt %d err %d\\n\",\n\t\t\t       gspca_dev->alt, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \nretry:\n\t\tgspca_err(gspca_dev, \"alt %d - bandwidth not wide enough, trying again\\n\",\n\t\t\t  alt);\n\t\tmsleep(20);\t \n\t\tif (gspca_dev->sd_desc->isoc_nego) {\n\t\t\tret = gspca_dev->sd_desc->isoc_nego(gspca_dev);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (alt_idx <= 0) {\n\t\t\t\tpr_err(\"no transfer endpoint found\\n\");\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgspca_dev->alt = ep_tb[--alt_idx].alt;\n\t\t}\n\t}\nout:\n\tgspca_input_create_urb(gspca_dev);\n\treturn ret;\n}\n\nstatic void gspca_set_default_mode(struct gspca_dev *gspca_dev)\n{\n\tint i;\n\n\ti = gspca_dev->cam.nmodes - 1;\t \n\tgspca_dev->curr_mode = i;\n\tgspca_dev->pixfmt = gspca_dev->cam.cam_mode[i];\n\n\t \n\tv4l2_ctrl_handler_setup(gspca_dev->vdev.ctrl_handler);\n}\n\nstatic int wxh_to_mode(struct gspca_dev *gspca_dev,\n\t\t\tint width, int height, u32 pixelformat)\n{\n\tint i;\n\n\tfor (i = 0; i < gspca_dev->cam.nmodes; i++) {\n\t\tif (width == gspca_dev->cam.cam_mode[i].width\n\t\t    && height == gspca_dev->cam.cam_mode[i].height\n\t\t    && pixelformat == gspca_dev->cam.cam_mode[i].pixelformat)\n\t\t\treturn i;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int wxh_to_nearest_mode(struct gspca_dev *gspca_dev,\n\t\t\tint width, int height, u32 pixelformat)\n{\n\tint i;\n\n\tfor (i = gspca_dev->cam.nmodes; --i >= 0; ) {\n\t\tif (width >= gspca_dev->cam.cam_mode[i].width\n\t\t    && height >= gspca_dev->cam.cam_mode[i].height\n\t\t    && pixelformat == gspca_dev->cam.cam_mode[i].pixelformat)\n\t\t\treturn i;\n\t}\n\tfor (i = gspca_dev->cam.nmodes; --i > 0; ) {\n\t\tif (width >= gspca_dev->cam.cam_mode[i].width\n\t\t    && height >= gspca_dev->cam.cam_mode[i].height)\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\n \nstatic int gspca_get_mode(struct gspca_dev *gspca_dev,\n\t\t\tint mode,\n\t\t\tint pixfmt)\n{\n\tint modeU, modeD;\n\n\tmodeU = modeD = mode;\n\twhile ((modeU < gspca_dev->cam.nmodes) || modeD >= 0) {\n\t\tif (--modeD >= 0) {\n\t\t\tif (gspca_dev->cam.cam_mode[modeD].pixelformat\n\t\t\t\t\t\t\t\t== pixfmt)\n\t\t\t\treturn modeD;\n\t\t}\n\t\tif (++modeU < gspca_dev->cam.nmodes) {\n\t\t\tif (gspca_dev->cam.cam_mode[modeU].pixelformat\n\t\t\t\t\t\t\t\t== pixfmt)\n\t\t\t\treturn modeU;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int vidioc_g_chip_info(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_dbg_chip_info *chip)\n{\n\tstruct gspca_dev *gspca_dev = video_drvdata(file);\n\n\tgspca_dev->usb_err = 0;\n\tif (gspca_dev->sd_desc->get_chip_info)\n\t\treturn gspca_dev->sd_desc->get_chip_info(gspca_dev, chip);\n\treturn chip->match.addr ? -EINVAL : 0;\n}\n\nstatic int vidioc_g_register(struct file *file, void *priv,\n\t\tstruct v4l2_dbg_register *reg)\n{\n\tstruct gspca_dev *gspca_dev = video_drvdata(file);\n\n\tgspca_dev->usb_err = 0;\n\treturn gspca_dev->sd_desc->get_register(gspca_dev, reg);\n}\n\nstatic int vidioc_s_register(struct file *file, void *priv,\n\t\tconst struct v4l2_dbg_register *reg)\n{\n\tstruct gspca_dev *gspca_dev = video_drvdata(file);\n\n\tgspca_dev->usb_err = 0;\n\treturn gspca_dev->sd_desc->set_register(gspca_dev, reg);\n}\n#endif\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,\n\t\t\t\tstruct v4l2_fmtdesc *fmtdesc)\n{\n\tstruct gspca_dev *gspca_dev = video_drvdata(file);\n\tint i, j, index;\n\t__u32 fmt_tb[8];\n\n\t \n\tindex = 0;\n\tfor (i = gspca_dev->cam.nmodes; --i >= 0; ) {\n\t\tfmt_tb[index] = gspca_dev->cam.cam_mode[i].pixelformat;\n\t\tj = 0;\n\t\tfor (;;) {\n\t\t\tif (fmt_tb[j] == fmt_tb[index])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tif (j == index) {\n\t\t\tif (fmtdesc->index == index)\n\t\t\t\tbreak;\t\t \n\t\t\tindex++;\n\t\t\tif (index >= ARRAY_SIZE(fmt_tb))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (i < 0)\n\t\treturn -EINVAL;\t\t \n\n\tfmtdesc->pixelformat = fmt_tb[index];\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *_priv,\n\t\t\t\tstruct v4l2_format *fmt)\n{\n\tstruct gspca_dev *gspca_dev = video_drvdata(file);\n\tu32 priv = fmt->fmt.pix.priv;\n\n\tfmt->fmt.pix = gspca_dev->pixfmt;\n\t \n\tfmt->fmt.pix.priv = priv;\n\treturn 0;\n}\n\nstatic int try_fmt_vid_cap(struct gspca_dev *gspca_dev,\n\t\t\tstruct v4l2_format *fmt)\n{\n\tint w, h, mode, mode2;\n\n\tw = fmt->fmt.pix.width;\n\th = fmt->fmt.pix.height;\n\n\tPDEBUG_MODE(gspca_dev, D_CONF, \"try fmt cap\",\n\t\t    fmt->fmt.pix.pixelformat, w, h);\n\n\t \n\tmode = wxh_to_nearest_mode(gspca_dev, w, h, fmt->fmt.pix.pixelformat);\n\n\t \n\tif (gspca_dev->cam.cam_mode[mode].pixelformat\n\t\t\t\t\t\t!= fmt->fmt.pix.pixelformat) {\n\n\t\t \n\t\tmode2 = gspca_get_mode(gspca_dev, mode,\n\t\t\t\t\tfmt->fmt.pix.pixelformat);\n\t\tif (mode2 >= 0)\n\t\t\tmode = mode2;\n\t}\n\tfmt->fmt.pix = gspca_dev->cam.cam_mode[mode];\n\tif (gspca_dev->sd_desc->try_fmt) {\n\t\t \n\t\tfmt->fmt.pix.width = w;\n\t\tfmt->fmt.pix.height = h;\n\t\tgspca_dev->sd_desc->try_fmt(gspca_dev, fmt);\n\t}\n\treturn mode;\t\t\t \n}\n\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *_priv,\n\t\t\t\t  struct v4l2_format *fmt)\n{\n\tstruct gspca_dev *gspca_dev = video_drvdata(file);\n\tu32 priv = fmt->fmt.pix.priv;\n\n\tif (try_fmt_vid_cap(gspca_dev, fmt) < 0)\n\t\treturn -EINVAL;\n\t \n\tfmt->fmt.pix.priv = priv;\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *_priv,\n\t\t\t\tstruct v4l2_format *fmt)\n{\n\tstruct gspca_dev *gspca_dev = video_drvdata(file);\n\tu32 priv = fmt->fmt.pix.priv;\n\tint mode;\n\n\tif (vb2_is_busy(&gspca_dev->queue))\n\t\treturn -EBUSY;\n\n\tmode = try_fmt_vid_cap(gspca_dev, fmt);\n\tif (mode < 0)\n\t\treturn -EINVAL;\n\n\tgspca_dev->curr_mode = mode;\n\tif (gspca_dev->sd_desc->try_fmt)\n\t\t \n\t\tgspca_dev->pixfmt = fmt->fmt.pix;\n\telse\n\t\tgspca_dev->pixfmt = gspca_dev->cam.cam_mode[mode];\n\t \n\tfmt->fmt.pix.priv = priv;\n\treturn 0;\n}\n\nstatic int vidioc_enum_framesizes(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_frmsizeenum *fsize)\n{\n\tstruct gspca_dev *gspca_dev = video_drvdata(file);\n\tint i;\n\t__u32 index = 0;\n\n\tif (gspca_dev->sd_desc->enum_framesizes)\n\t\treturn gspca_dev->sd_desc->enum_framesizes(gspca_dev, fsize);\n\n\tfor (i = 0; i < gspca_dev->cam.nmodes; i++) {\n\t\tif (fsize->pixel_format !=\n\t\t\t\tgspca_dev->cam.cam_mode[i].pixelformat)\n\t\t\tcontinue;\n\n\t\tif (fsize->index == index) {\n\t\t\tfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\t\t\tfsize->discrete.width =\n\t\t\t\tgspca_dev->cam.cam_mode[i].width;\n\t\t\tfsize->discrete.height =\n\t\t\t\tgspca_dev->cam.cam_mode[i].height;\n\t\t\treturn 0;\n\t\t}\n\t\tindex++;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int vidioc_enum_frameintervals(struct file *filp, void *priv,\n\t\t\t\t      struct v4l2_frmivalenum *fival)\n{\n\tstruct gspca_dev *gspca_dev = video_drvdata(filp);\n\tint mode;\n\t__u32 i;\n\n\tmode = wxh_to_mode(gspca_dev, fival->width, fival->height,\n\t\t\t   fival->pixel_format);\n\tif (mode < 0)\n\t\treturn -EINVAL;\n\n\tif (gspca_dev->cam.mode_framerates == NULL ||\n\t\t\tgspca_dev->cam.mode_framerates[mode].nrates == 0)\n\t\treturn -EINVAL;\n\n\tif (fival->pixel_format !=\n\t\t\tgspca_dev->cam.cam_mode[mode].pixelformat)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < gspca_dev->cam.mode_framerates[mode].nrates; i++) {\n\t\tif (fival->index == i) {\n\t\t\tfival->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\t\t\tfival->discrete.numerator = 1;\n\t\t\tfival->discrete.denominator =\n\t\t\t\tgspca_dev->cam.mode_framerates[mode].rates[i];\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void gspca_release(struct v4l2_device *v4l2_device)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(v4l2_device, struct gspca_dev, v4l2_dev);\n\n\tv4l2_ctrl_handler_free(gspca_dev->vdev.ctrl_handler);\n\tv4l2_device_unregister(&gspca_dev->v4l2_dev);\n\tkfree(gspca_dev->usb_buf);\n\tkfree(gspca_dev);\n}\n\nstatic int vidioc_querycap(struct file *file, void  *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct gspca_dev *gspca_dev = video_drvdata(file);\n\n\tstrscpy((char *)cap->driver, gspca_dev->sd_desc->name,\n\t\tsizeof(cap->driver));\n\tif (gspca_dev->dev->product != NULL) {\n\t\tstrscpy((char *)cap->card, gspca_dev->dev->product,\n\t\t\tsizeof(cap->card));\n\t} else {\n\t\tsnprintf((char *) cap->card, sizeof cap->card,\n\t\t\t\"USB Camera (%04x:%04x)\",\n\t\t\tle16_to_cpu(gspca_dev->dev->descriptor.idVendor),\n\t\t\tle16_to_cpu(gspca_dev->dev->descriptor.idProduct));\n\t}\n\tusb_make_path(gspca_dev->dev, (char *) cap->bus_info,\n\t\t\tsizeof(cap->bus_info));\n\treturn 0;\n}\n\nstatic int vidioc_enum_input(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_input *input)\n{\n\tstruct gspca_dev *gspca_dev = video_drvdata(file);\n\n\tif (input->index != 0)\n\t\treturn -EINVAL;\n\tinput->type = V4L2_INPUT_TYPE_CAMERA;\n\tinput->status = gspca_dev->cam.input_flags;\n\tstrscpy(input->name, gspca_dev->sd_desc->name,\n\t\tsizeof input->name);\n\treturn 0;\n}\n\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\t*i = 0;\n\treturn 0;\n}\n\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tif (i > 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int vidioc_g_jpegcomp(struct file *file, void *priv,\n\t\t\tstruct v4l2_jpegcompression *jpegcomp)\n{\n\tstruct gspca_dev *gspca_dev = video_drvdata(file);\n\n\tgspca_dev->usb_err = 0;\n\treturn gspca_dev->sd_desc->get_jcomp(gspca_dev, jpegcomp);\n}\n\nstatic int vidioc_s_jpegcomp(struct file *file, void *priv,\n\t\t\tconst struct v4l2_jpegcompression *jpegcomp)\n{\n\tstruct gspca_dev *gspca_dev = video_drvdata(file);\n\n\tgspca_dev->usb_err = 0;\n\treturn gspca_dev->sd_desc->set_jcomp(gspca_dev, jpegcomp);\n}\n\nstatic int vidioc_g_parm(struct file *filp, void *priv,\n\t\t\tstruct v4l2_streamparm *parm)\n{\n\tstruct gspca_dev *gspca_dev = video_drvdata(filp);\n\n\tparm->parm.capture.readbuffers = gspca_dev->queue.min_buffers_needed;\n\n\tif (!gspca_dev->sd_desc->get_streamparm)\n\t\treturn 0;\n\n\tparm->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\n\tgspca_dev->usb_err = 0;\n\tgspca_dev->sd_desc->get_streamparm(gspca_dev, parm);\n\treturn gspca_dev->usb_err;\n}\n\nstatic int vidioc_s_parm(struct file *filp, void *priv,\n\t\t\tstruct v4l2_streamparm *parm)\n{\n\tstruct gspca_dev *gspca_dev = video_drvdata(filp);\n\n\tparm->parm.capture.readbuffers = gspca_dev->queue.min_buffers_needed;\n\n\tif (!gspca_dev->sd_desc->set_streamparm) {\n\t\tparm->parm.capture.capability = 0;\n\t\treturn 0;\n\t}\n\n\tparm->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\n\tgspca_dev->usb_err = 0;\n\tgspca_dev->sd_desc->set_streamparm(gspca_dev, parm);\n\treturn gspca_dev->usb_err;\n}\n\nstatic int gspca_queue_setup(struct vb2_queue *vq,\n\t\t\t     unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t     unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct gspca_dev *gspca_dev = vb2_get_drv_priv(vq);\n\tunsigned int size = PAGE_ALIGN(gspca_dev->pixfmt.sizeimage);\n\n\tif (*nplanes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\t*nplanes = 1;\n\tsizes[0] = size;\n\treturn 0;\n}\n\nstatic int gspca_buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct gspca_dev *gspca_dev = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned long size = PAGE_ALIGN(gspca_dev->pixfmt.sizeimage);\n\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tgspca_err(gspca_dev, \"buffer too small (%lu < %lu)\\n\",\n\t\t\t vb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void gspca_buffer_finish(struct vb2_buffer *vb)\n{\n\tstruct gspca_dev *gspca_dev = vb2_get_drv_priv(vb->vb2_queue);\n\n\tif (!gspca_dev->sd_desc->dq_callback)\n\t\treturn;\n\n\tgspca_dev->usb_err = 0;\n\tif (gspca_dev->present)\n\t\tgspca_dev->sd_desc->dq_callback(gspca_dev);\n}\n\nstatic void gspca_buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct gspca_dev *gspca_dev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct gspca_buffer *buf = to_gspca_buffer(vb);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gspca_dev->qlock, flags);\n\tlist_add_tail(&buf->list, &gspca_dev->buf_list);\n\tspin_unlock_irqrestore(&gspca_dev->qlock, flags);\n}\n\nstatic void gspca_return_all_buffers(struct gspca_dev *gspca_dev,\n\t\t\t\t     enum vb2_buffer_state state)\n{\n\tstruct gspca_buffer *buf, *node;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gspca_dev->qlock, flags);\n\tlist_for_each_entry_safe(buf, node, &gspca_dev->buf_list, list) {\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t\tlist_del(&buf->list);\n\t}\n\tspin_unlock_irqrestore(&gspca_dev->qlock, flags);\n}\n\nstatic int gspca_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct gspca_dev *gspca_dev = vb2_get_drv_priv(vq);\n\tint ret;\n\n\tgspca_dev->sequence = 0;\n\n\tret = gspca_init_transfer(gspca_dev);\n\tif (ret)\n\t\tgspca_return_all_buffers(gspca_dev, VB2_BUF_STATE_QUEUED);\n\treturn ret;\n}\n\nstatic void gspca_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct gspca_dev *gspca_dev = vb2_get_drv_priv(vq);\n\n\tgspca_stream_off(gspca_dev);\n\n\t \n\tgspca_return_all_buffers(gspca_dev, VB2_BUF_STATE_ERROR);\n}\n\nstatic const struct vb2_ops gspca_qops = {\n\t.queue_setup\t\t= gspca_queue_setup,\n\t.buf_prepare\t\t= gspca_buffer_prepare,\n\t.buf_finish\t\t= gspca_buffer_finish,\n\t.buf_queue\t\t= gspca_buffer_queue,\n\t.start_streaming\t= gspca_start_streaming,\n\t.stop_streaming\t\t= gspca_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nstatic const struct v4l2_file_operations dev_fops = {\n\t.owner = THIS_MODULE,\n\t.open = v4l2_fh_open,\n\t.release = vb2_fop_release,\n\t.unlocked_ioctl = video_ioctl2,\n\t.read = vb2_fop_read,\n\t.mmap = vb2_fop_mmap,\n\t.poll = vb2_fop_poll,\n};\n\nstatic const struct v4l2_ioctl_ops dev_ioctl_ops = {\n\t.vidioc_querycap\t= vidioc_querycap,\n\t.vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t= vidioc_try_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t= vidioc_g_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t= vidioc_s_fmt_vid_cap,\n\t.vidioc_enum_input\t= vidioc_enum_input,\n\t.vidioc_g_input\t\t= vidioc_g_input,\n\t.vidioc_s_input\t\t= vidioc_s_input,\n\t.vidioc_g_jpegcomp\t= vidioc_g_jpegcomp,\n\t.vidioc_s_jpegcomp\t= vidioc_s_jpegcomp,\n\t.vidioc_g_parm\t\t= vidioc_g_parm,\n\t.vidioc_s_parm\t\t= vidioc_s_parm,\n\t.vidioc_enum_framesizes = vidioc_enum_framesizes,\n\t.vidioc_enum_frameintervals = vidioc_enum_frameintervals,\n\n\t.vidioc_reqbufs\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t= vb2_ioctl_create_bufs,\n\t.vidioc_querybuf\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t= vb2_ioctl_expbuf,\n\t.vidioc_streamon\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t= vb2_ioctl_streamoff,\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_chip_info\t= vidioc_g_chip_info,\n\t.vidioc_g_register\t= vidioc_g_register,\n\t.vidioc_s_register\t= vidioc_s_register,\n#endif\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic const struct video_device gspca_template = {\n\t.name = \"gspca main driver\",\n\t.fops = &dev_fops,\n\t.ioctl_ops = &dev_ioctl_ops,\n\t.release = video_device_release_empty,  \n};\n\n \nint gspca_dev_probe2(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id,\n\t\tconst struct sd_desc *sd_desc,\n\t\tint dev_size,\n\t\tstruct module *module)\n{\n\tstruct gspca_dev *gspca_dev;\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct vb2_queue *q;\n\tint ret;\n\n\tpr_info(\"%s-\" GSPCA_VERSION \" probing %04x:%04x\\n\",\n\t\tsd_desc->name, id->idVendor, id->idProduct);\n\n\t \n\tif (dev_size < sizeof *gspca_dev)\n\t\tdev_size = sizeof *gspca_dev;\n\tgspca_dev = kzalloc(dev_size, GFP_KERNEL);\n\tif (!gspca_dev) {\n\t\tpr_err(\"couldn't kzalloc gspca struct\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tgspca_dev->usb_buf = kzalloc(USB_BUF_SZ, GFP_KERNEL);\n\tif (!gspca_dev->usb_buf) {\n\t\tpr_err(\"out of memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgspca_dev->dev = dev;\n\tgspca_dev->iface = intf->cur_altsetting->desc.bInterfaceNumber;\n\tgspca_dev->xfer_ep = -1;\n\n\t \n\tif (dev->actconfig->desc.bNumInterfaces != 1) {\n\t\tint i;\n\t\tstruct usb_interface *intf2;\n\n\t\tfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {\n\t\t\tintf2 = dev->actconfig->interface[i];\n\t\t\tif (intf2 != NULL\n\t\t\t && intf2->altsetting != NULL\n\t\t\t && intf2->altsetting->desc.bInterfaceClass ==\n\t\t\t\t\t USB_CLASS_AUDIO) {\n\t\t\t\tgspca_dev->audio = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tgspca_dev->v4l2_dev.release = gspca_release;\n\tret = v4l2_device_register(&intf->dev, &gspca_dev->v4l2_dev);\n\tif (ret)\n\t\tgoto out;\n\tgspca_dev->present = true;\n\tgspca_dev->sd_desc = sd_desc;\n\tgspca_dev->empty_packet = -1;\t \n\tgspca_dev->vdev = gspca_template;\n\tgspca_dev->vdev.v4l2_dev = &gspca_dev->v4l2_dev;\n\tgspca_dev->vdev.device_caps = V4L2_CAP_VIDEO_CAPTURE |\n\t\t\t\t      V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\tvideo_set_drvdata(&gspca_dev->vdev, gspca_dev);\n\tgspca_dev->module = module;\n\n\tmutex_init(&gspca_dev->usb_lock);\n\tgspca_dev->vdev.lock = &gspca_dev->usb_lock;\n\tinit_waitqueue_head(&gspca_dev->wq);\n\n\t \n\tq = &gspca_dev->queue;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\n\tq->drv_priv = gspca_dev;\n\tq->buf_struct_size = sizeof(struct gspca_buffer);\n\tq->ops = &gspca_qops;\n\tq->mem_ops = &vb2_vmalloc_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->min_buffers_needed = 2;\n\tq->lock = &gspca_dev->usb_lock;\n\tret = vb2_queue_init(q);\n\tif (ret)\n\t\tgoto out;\n\tgspca_dev->vdev.queue = q;\n\n\tINIT_LIST_HEAD(&gspca_dev->buf_list);\n\tspin_lock_init(&gspca_dev->qlock);\n\n\t \n\tret = sd_desc->config(gspca_dev, id);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = sd_desc->init(gspca_dev);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (sd_desc->init_controls)\n\t\tret = sd_desc->init_controls(gspca_dev);\n\tif (ret < 0)\n\t\tgoto out;\n\tgspca_set_default_mode(gspca_dev);\n\n\tret = gspca_input_connect(gspca_dev);\n\tif (ret)\n\t\tgoto out;\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\tif (!gspca_dev->sd_desc->get_register)\n\t\tv4l2_disable_ioctl(&gspca_dev->vdev, VIDIOC_DBG_G_REGISTER);\n\tif (!gspca_dev->sd_desc->set_register)\n\t\tv4l2_disable_ioctl(&gspca_dev->vdev, VIDIOC_DBG_S_REGISTER);\n#endif\n\tif (!gspca_dev->sd_desc->get_jcomp)\n\t\tv4l2_disable_ioctl(&gspca_dev->vdev, VIDIOC_G_JPEGCOMP);\n\tif (!gspca_dev->sd_desc->set_jcomp)\n\t\tv4l2_disable_ioctl(&gspca_dev->vdev, VIDIOC_S_JPEGCOMP);\n\n\t \n\tret = video_register_device(&gspca_dev->vdev,\n\t\t\t\t  VFL_TYPE_VIDEO,\n\t\t\t\t  -1);\n\tif (ret < 0) {\n\t\tpr_err(\"video_register_device err %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tusb_set_intfdata(intf, gspca_dev);\n\tgspca_dbg(gspca_dev, D_PROBE, \"%s created\\n\",\n\t\t  video_device_node_name(&gspca_dev->vdev));\n\n\tgspca_input_create_urb(gspca_dev);\n\n\treturn 0;\nout:\n#if IS_ENABLED(CONFIG_INPUT)\n\tif (gspca_dev->input_dev)\n\t\tinput_unregister_device(gspca_dev->input_dev);\n#endif\n\tv4l2_ctrl_handler_free(gspca_dev->vdev.ctrl_handler);\n\tv4l2_device_unregister(&gspca_dev->v4l2_dev);\n\tif (sd_desc->probe_error)\n\t\tsd_desc->probe_error(gspca_dev);\n\tkfree(gspca_dev->usb_buf);\n\tkfree(gspca_dev);\n\treturn ret;\n}\nEXPORT_SYMBOL(gspca_dev_probe2);\n\n \nint gspca_dev_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id,\n\t\tconst struct sd_desc *sd_desc,\n\t\tint dev_size,\n\t\tstruct module *module)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\n\t \n\tif (dev->descriptor.bNumConfigurations != 1) {\n\t\tpr_err(\"%04x:%04x too many config\\n\",\n\t\t       id->idVendor, id->idProduct);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (dev->actconfig->desc.bNumInterfaces != 1\n\t && intf->cur_altsetting->desc.bInterfaceNumber != 0)\n\t\treturn -ENODEV;\n\n\treturn gspca_dev_probe2(intf, id, sd_desc, dev_size, module);\n}\nEXPORT_SYMBOL(gspca_dev_probe);\n\n \nvoid gspca_disconnect(struct usb_interface *intf)\n{\n\tstruct gspca_dev *gspca_dev = usb_get_intfdata(intf);\n#if IS_ENABLED(CONFIG_INPUT)\n\tstruct input_dev *input_dev;\n#endif\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"%s disconnect\\n\",\n\t\t  video_device_node_name(&gspca_dev->vdev));\n\n\tmutex_lock(&gspca_dev->usb_lock);\n\tgspca_dev->present = false;\n\tdestroy_urbs(gspca_dev);\n\tgspca_input_destroy_urb(gspca_dev);\n\n\tvb2_queue_error(&gspca_dev->queue);\n\n#if IS_ENABLED(CONFIG_INPUT)\n\tinput_dev = gspca_dev->input_dev;\n\tif (input_dev) {\n\t\tgspca_dev->input_dev = NULL;\n\t\tinput_unregister_device(input_dev);\n\t}\n#endif\n\n\tv4l2_device_disconnect(&gspca_dev->v4l2_dev);\n\tvideo_unregister_device(&gspca_dev->vdev);\n\n\tmutex_unlock(&gspca_dev->usb_lock);\n\n\t \n\tv4l2_device_put(&gspca_dev->v4l2_dev);\n}\nEXPORT_SYMBOL(gspca_disconnect);\n\n#ifdef CONFIG_PM\nint gspca_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct gspca_dev *gspca_dev = usb_get_intfdata(intf);\n\n\tgspca_input_destroy_urb(gspca_dev);\n\n\tif (!vb2_start_streaming_called(&gspca_dev->queue))\n\t\treturn 0;\n\n\tmutex_lock(&gspca_dev->usb_lock);\n\tgspca_dev->frozen = 1;\t\t \n\tgspca_dev->usb_err = 0;\n\tif (gspca_dev->sd_desc->stopN)\n\t\tgspca_dev->sd_desc->stopN(gspca_dev);\n\tdestroy_urbs(gspca_dev);\n\tgspca_set_alt0(gspca_dev);\n\tif (gspca_dev->sd_desc->stop0)\n\t\tgspca_dev->sd_desc->stop0(gspca_dev);\n\tmutex_unlock(&gspca_dev->usb_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(gspca_suspend);\n\nint gspca_resume(struct usb_interface *intf)\n{\n\tstruct gspca_dev *gspca_dev = usb_get_intfdata(intf);\n\tint streaming, ret = 0;\n\n\tmutex_lock(&gspca_dev->usb_lock);\n\tgspca_dev->frozen = 0;\n\tgspca_dev->usb_err = 0;\n\tgspca_dev->sd_desc->init(gspca_dev);\n\t \n\tstreaming = vb2_start_streaming_called(&gspca_dev->queue);\n\tif (streaming)\n\t\tret = gspca_init_transfer(gspca_dev);\n\telse\n\t\tgspca_input_create_urb(gspca_dev);\n\tmutex_unlock(&gspca_dev->usb_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(gspca_resume);\n#endif\n\n \nstatic int __init gspca_init(void)\n{\n\tpr_info(\"v\" GSPCA_VERSION \" registered\\n\");\n\treturn 0;\n}\nstatic void __exit gspca_exit(void)\n{\n}\n\nmodule_init(gspca_init);\nmodule_exit(gspca_exit);\n\nmodule_param_named(debug, gspca_debug, int, 0644);\nMODULE_PARM_DESC(debug,\n\t\t\"1:probe 2:config 3:stream 4:frame 5:packet 6:usbi 7:usbo\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}