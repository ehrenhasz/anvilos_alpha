{
  "module_name": "t613.c",
  "hash_id": "73f3c3372400019ddf0af1e9eb89d81b97ac85203cea9d98934d88a50dbc7f5b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/t613.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"t613\"\n\n#include <linux/input.h>\n#include <linux/slab.h>\n#include \"gspca.h\"\n\nMODULE_AUTHOR(\"Leandro Costantino <le_costantino@pixartargentina.com.ar>\");\nMODULE_DESCRIPTION(\"GSPCA/T613 (JPEG Compliance) USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstruct sd {\n\tstruct gspca_dev gspca_dev;\t \n\tstruct v4l2_ctrl *freq;\n\tstruct {  \n\t\tstruct v4l2_ctrl *awb;\n\t\tstruct v4l2_ctrl *gain;\n\t\tstruct v4l2_ctrl *red_balance;\n\t\tstruct v4l2_ctrl *blue_balance;\n\t};\n\n\tu8 sensor;\n\tu8 button_pressed;\n};\nenum sensors {\n\tSENSOR_OM6802,\n\tSENSOR_OTHER,\n\tSENSOR_TAS5130A,\n\tSENSOR_LT168G,\t\t \n};\n\nstatic const struct v4l2_pix_format vga_mode_t16[] = {\n\t{160, 120, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 160 * 120 * 4 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 4},\n#if 0  \n\t{176, 144, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 176 * 144 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 3},\n#endif\n\t{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 2},\n#if 0  \n\t{352, 288, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352,\n\t\t.sizeimage = 352 * 288 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n#endif\n\t{640, 480, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\n\n \nstruct additional_sensor_data {\n\tconst u8 n3[6];\n\tconst u8 *n4, n4sz;\n\tconst u8 reg80, reg8e;\n\tconst u8 nset8[6];\n\tconst u8 data1[10];\n\tconst u8 data2[9];\n\tconst u8 data3[9];\n\tconst u8 data5[6];\n\tconst u8 stream[4];\n};\n\nstatic const u8 n4_om6802[] = {\n\t0x09, 0x01, 0x12, 0x04, 0x66, 0x8a, 0x80, 0x3c,\n\t0x81, 0x22, 0x84, 0x50, 0x8a, 0x78, 0x8b, 0x68,\n\t0x8c, 0x88, 0x8e, 0x33, 0x8f, 0x24, 0xaa, 0xb1,\n\t0xa2, 0x60, 0xa5, 0x30, 0xa6, 0x3a, 0xa8, 0xe8,\n\t0xae, 0x05, 0xb1, 0x00, 0xbb, 0x04, 0xbc, 0x48,\n\t0xbe, 0x36, 0xc6, 0x88, 0xe9, 0x00, 0xc5, 0xc0,\n\t0x65, 0x0a, 0xbb, 0x86, 0xaf, 0x58, 0xb0, 0x68,\n\t0x87, 0x40, 0x89, 0x2b, 0x8d, 0xff, 0x83, 0x40,\n\t0xac, 0x84, 0xad, 0x86, 0xaf, 0x46\n};\nstatic const u8 n4_other[] = {\n\t0x66, 0x00, 0x7f, 0x00, 0x80, 0xac, 0x81, 0x69,\n\t0x84, 0x40, 0x85, 0x70, 0x86, 0x20, 0x8a, 0x68,\n\t0x8b, 0x58, 0x8c, 0x88, 0x8d, 0xff, 0x8e, 0xb8,\n\t0x8f, 0x28, 0xa2, 0x60, 0xa5, 0x40, 0xa8, 0xa8,\n\t0xac, 0x84, 0xad, 0x84, 0xae, 0x24, 0xaf, 0x56,\n\t0xb0, 0x68, 0xb1, 0x00, 0xb2, 0x88, 0xbb, 0xc5,\n\t0xbc, 0x4a, 0xbe, 0x36, 0xc2, 0x88, 0xc5, 0xc0,\n\t0xc6, 0xda, 0xe9, 0x26, 0xeb, 0x00\n};\nstatic const u8 n4_tas5130a[] = {\n\t0x80, 0x3c, 0x81, 0x68, 0x83, 0xa0, 0x84, 0x20,\n\t0x8a, 0x68, 0x8b, 0x58, 0x8c, 0x88, 0x8e, 0xb4,\n\t0x8f, 0x24, 0xa1, 0xb1, 0xa2, 0x30, 0xa5, 0x10,\n\t0xa6, 0x4a, 0xae, 0x03, 0xb1, 0x44, 0xb2, 0x08,\n\t0xb7, 0x06, 0xb9, 0xe7, 0xbb, 0xc4, 0xbc, 0x4a,\n\t0xbe, 0x36, 0xbf, 0xff, 0xc2, 0x88, 0xc5, 0xc8,\n\t0xc6, 0xda\n};\nstatic const u8 n4_lt168g[] = {\n\t0x66, 0x01, 0x7f, 0x00, 0x80, 0x7c, 0x81, 0x28,\n\t0x83, 0x44, 0x84, 0x20, 0x86, 0x20, 0x8a, 0x70,\n\t0x8b, 0x58, 0x8c, 0x88, 0x8d, 0xa0, 0x8e, 0xb3,\n\t0x8f, 0x24, 0xa1, 0xb0, 0xa2, 0x38, 0xa5, 0x20,\n\t0xa6, 0x4a, 0xa8, 0xe8, 0xaf, 0x38, 0xb0, 0x68,\n\t0xb1, 0x44, 0xb2, 0x88, 0xbb, 0x86, 0xbd, 0x40,\n\t0xbe, 0x26, 0xc1, 0x05, 0xc2, 0x88, 0xc5, 0xc0,\n\t0xda, 0x8e, 0xdb, 0xca, 0xdc, 0xa8, 0xdd, 0x8c,\n\t0xde, 0x44, 0xdf, 0x0c, 0xe9, 0x80\n};\n\nstatic const struct additional_sensor_data sensor_data[] = {\n[SENSOR_OM6802] = {\n\t.n3 =\n\t\t{0x61, 0x68, 0x65, 0x0a, 0x60, 0x04},\n\t.n4 = n4_om6802,\n\t.n4sz = sizeof n4_om6802,\n\t.reg80 = 0x3c,\n\t.reg8e = 0x33,\n\t.nset8 = {0xa8, 0xf0, 0xc6, 0x88, 0xc0, 0x00},\n\t.data1 =\n\t\t{0xc2, 0x28, 0x0f, 0x22, 0xcd, 0x27, 0x2c, 0x06,\n\t\t 0xb3, 0xfc},\n\t.data2 =\n\t\t{0x80, 0xff, 0xff, 0x80, 0xff, 0xff, 0x80, 0xff,\n\t\t 0xff},\n\t.data3 =\n\t\t{0x80, 0xff, 0xff, 0x80, 0xff, 0xff, 0x80, 0xff,\n\t\t 0xff},\n\t.data5 =\t \n\t\t{0x0c, 0x03, 0xab, 0x13, 0x81, 0x23},\n\t.stream =\n\t\t{0x0b, 0x04, 0x0a, 0x78},\n    },\n[SENSOR_OTHER] = {\n\t.n3 =\n\t\t{0x61, 0xc2, 0x65, 0x88, 0x60, 0x00},\n\t.n4 = n4_other,\n\t.n4sz = sizeof n4_other,\n\t.reg80 = 0xac,\n\t.reg8e = 0xb8,\n\t.nset8 = {0xa8, 0xa8, 0xc6, 0xda, 0xc0, 0x00},\n\t.data1 =\n\t\t{0xc1, 0x48, 0x04, 0x1b, 0xca, 0x2e, 0x33, 0x3a,\n\t\t 0xe8, 0xfc},\n\t.data2 =\n\t\t{0x4e, 0x9c, 0xec, 0x40, 0x80, 0xc0, 0x48, 0x96,\n\t\t 0xd9},\n\t.data3 =\n\t\t{0x4e, 0x9c, 0xec, 0x40, 0x80, 0xc0, 0x48, 0x96,\n\t\t 0xd9},\n\t.data5 =\n\t\t{0x0c, 0x03, 0xab, 0x29, 0x81, 0x69},\n\t.stream =\n\t\t{0x0b, 0x04, 0x0a, 0x00},\n    },\n[SENSOR_TAS5130A] = {\n\t.n3 =\n\t\t{0x61, 0xc2, 0x65, 0x0d, 0x60, 0x08},\n\t.n4 = n4_tas5130a,\n\t.n4sz = sizeof n4_tas5130a,\n\t.reg80 = 0x3c,\n\t.reg8e = 0xb4,\n\t.nset8 = {0xa8, 0xf0, 0xc6, 0xda, 0xc0, 0x00},\n\t.data1 =\n\t\t{0xbb, 0x28, 0x10, 0x10, 0xbb, 0x28, 0x1e, 0x27,\n\t\t 0xc8, 0xfc},\n\t.data2 =\n\t\t{0x60, 0xa8, 0xe0, 0x60, 0xa8, 0xe0, 0x60, 0xa8,\n\t\t 0xe0},\n\t.data3 =\n\t\t{0x60, 0xa8, 0xe0, 0x60, 0xa8, 0xe0, 0x60, 0xa8,\n\t\t 0xe0},\n\t.data5 =\n\t\t{0x0c, 0x03, 0xab, 0x10, 0x81, 0x20},\n\t.stream =\n\t\t{0x0b, 0x04, 0x0a, 0x40},\n    },\n[SENSOR_LT168G] = {\n\t.n3 = {0x61, 0xc2, 0x65, 0x68, 0x60, 0x00},\n\t.n4 = n4_lt168g,\n\t.n4sz = sizeof n4_lt168g,\n\t.reg80 = 0x7c,\n\t.reg8e = 0xb3,\n\t.nset8 = {0xa8, 0xf0, 0xc6, 0xba, 0xc0, 0x00},\n\t.data1 = {0xc0, 0x38, 0x08, 0x10, 0xc0, 0x30, 0x10, 0x40,\n\t\t 0xb0, 0xf4},\n\t.data2 = {0x40, 0x80, 0xc0, 0x50, 0xa0, 0xf0, 0x53, 0xa6,\n\t\t 0xff},\n\t.data3 = {0x40, 0x80, 0xc0, 0x50, 0xa0, 0xf0, 0x53, 0xa6,\n\t\t 0xff},\n\t.data5 = {0x0c, 0x03, 0xab, 0x4b, 0x81, 0x2b},\n\t.stream = {0x0b, 0x04, 0x0a, 0x28},\n    },\n};\n\n#define MAX_EFFECTS 7\nstatic const u8 effects_table[MAX_EFFECTS][6] = {\n\t{0xa8, 0xe8, 0xc6, 0xd2, 0xc0, 0x00},\t \n\t{0xa8, 0xc8, 0xc6, 0x52, 0xc0, 0x04},\t \n\t{0xa8, 0xe8, 0xc6, 0xd2, 0xc0, 0x20},\t \n\t{0xa8, 0xe8, 0xc6, 0xd2, 0xc0, 0x80},\t \n\t{0xa8, 0xc8, 0xc6, 0x52, 0xc0, 0x02},\t \n\t{0xa8, 0xc8, 0xc6, 0xd2, 0xc0, 0x10},\t \n\t{0xa8, 0xc8, 0xc6, 0xd2, 0xc0, 0x40},\t \n};\n\n#define GAMMA_MAX (15)\nstatic const u8 gamma_table[GAMMA_MAX+1][17] = {\n \n\t{0x00, 0x00, 0x01, 0x04, 0x08, 0x0e, 0x16, 0x21,\t \n\t 0x2e, 0x3d, 0x50, 0x65, 0x7d, 0x99, 0xb8, 0xdb,\n\t 0xff},\n\t{0x00, 0x01, 0x03, 0x08, 0x0e, 0x16, 0x21, 0x2d,\t \n\t 0x3c, 0x4d, 0x60, 0x75, 0x8d, 0xa6, 0xc2, 0xe1,\n\t 0xff},\n\t{0x00, 0x01, 0x05, 0x0b, 0x12, 0x1c, 0x28, 0x35,\t \n\t 0x45, 0x56, 0x69, 0x7e, 0x95, 0xad, 0xc7, 0xe3,\n\t 0xff},\n\t{0x00, 0x02, 0x07, 0x0f, 0x18, 0x24, 0x30, 0x3f,\t \n\t 0x4f, 0x61, 0x73, 0x88, 0x9d, 0xb4, 0xcd, 0xe6,\n\t 0xff},\n\t{0x00, 0x04, 0x0b, 0x15, 0x20, 0x2d, 0x3b, 0x4a,\t \n\t 0x5b, 0x6c, 0x7f, 0x92, 0xa7, 0xbc, 0xd2, 0xe9,\n\t 0xff},\n\t{0x00, 0x07, 0x11, 0x15, 0x20, 0x2d, 0x48, 0x58,\t \n\t 0x68, 0x79, 0x8b, 0x9d, 0xb0, 0xc4, 0xd7, 0xec,\n\t 0xff},\n\t{0x00, 0x0c, 0x1a, 0x29, 0x38, 0x47, 0x57, 0x67,\t \n\t 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee,\n\t 0xff},\n\t{0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,\t \n\t 0x80, 0x90, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0,\n\t 0xff},\n\t{0x00, 0x15, 0x27, 0x38, 0x49, 0x59, 0x69, 0x79,\t \n\t 0x88, 0x97, 0xa7, 0xb6, 0xc4, 0xd3, 0xe2, 0xf0,\n\t 0xff},\n\t{0x00, 0x1c, 0x30, 0x43, 0x54, 0x65, 0x75, 0x84,\t \n\t 0x93, 0xa1, 0xb0, 0xbd, 0xca, 0xd8, 0xe5, 0xf2,\n\t 0xff},\n\t{0x00, 0x24, 0x3b, 0x4f, 0x60, 0x70, 0x80, 0x8e,\t \n\t 0x9c, 0xaa, 0xb7, 0xc4, 0xd0, 0xdc, 0xe8, 0xf3,\n\t 0xff},\n\t{0x00, 0x2a, 0x3c, 0x5d, 0x6e, 0x7e, 0x8d, 0x9b,\t \n\t 0xa8, 0xb4, 0xc0, 0xcb, 0xd6, 0xe1, 0xeb, 0xf5,\n\t 0xff},\n\t{0x00, 0x3f, 0x5a, 0x6e, 0x7f, 0x8e, 0x9c, 0xa8,\t \n\t 0xb4, 0xbf, 0xc9, 0xd3, 0xdc, 0xe5, 0xee, 0xf6,\n\t 0xff},\n\t{0x00, 0x54, 0x6f, 0x83, 0x93, 0xa0, 0xad, 0xb7,\t \n\t 0xc2, 0xcb, 0xd4, 0xdc, 0xe4, 0xeb, 0xf2, 0xf9,\n\t 0xff},\n\t{0x00, 0x6e, 0x88, 0x9a, 0xa8, 0xb3, 0xbd, 0xc6,\t \n\t 0xcf, 0xd6, 0xdd, 0xe3, 0xe9, 0xef, 0xf4, 0xfa,\n\t 0xff},\n\t{0x00, 0x93, 0xa8, 0xb7, 0xc1, 0xca, 0xd2, 0xd8,\t \n\t 0xde, 0xe3, 0xe8, 0xed, 0xf1, 0xf5, 0xf8, 0xfc,\n\t 0xff}\n};\n\nstatic const u8 tas5130a_sensor_init[][8] = {\n\t{0x62, 0x08, 0x63, 0x70, 0x64, 0x1d, 0x60, 0x09},\n\t{0x62, 0x20, 0x63, 0x01, 0x64, 0x02, 0x60, 0x09},\n\t{0x62, 0x07, 0x63, 0x03, 0x64, 0x00, 0x60, 0x09},\n};\n\nstatic u8 sensor_reset[] = {0x61, 0x68, 0x62, 0xff, 0x60, 0x07};\n\n \nstatic u8 reg_r(struct gspca_dev *gspca_dev,\n\t\t   u16 index)\n{\n\tusb_control_msg(gspca_dev->dev,\n\t\t\tusb_rcvctrlpipe(gspca_dev->dev, 0),\n\t\t\t0,\t\t \n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0,\t\t \n\t\t\tindex,\n\t\t\tgspca_dev->usb_buf, 1, 500);\n\treturn gspca_dev->usb_buf[0];\n}\n\nstatic void reg_w(struct gspca_dev *gspca_dev,\n\t\t  u16 index)\n{\n\tusb_control_msg(gspca_dev->dev,\n\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t0,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, index,\n\t\t\tNULL, 0, 500);\n}\n\nstatic void reg_w_buf(struct gspca_dev *gspca_dev,\n\t\t  const u8 *buffer, u16 len)\n{\n\tif (len <= USB_BUF_SZ) {\n\t\tmemcpy(gspca_dev->usb_buf, buffer, len);\n\t\tusb_control_msg(gspca_dev->dev,\n\t\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t\t0,\n\t\t\t   USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\t0x01, 0,\n\t\t\t\tgspca_dev->usb_buf, len, 500);\n\t} else {\n\t\tu8 *tmpbuf;\n\n\t\ttmpbuf = kmemdup(buffer, len, GFP_KERNEL);\n\t\tif (!tmpbuf) {\n\t\t\tpr_err(\"Out of memory\\n\");\n\t\t\treturn;\n\t\t}\n\t\tusb_control_msg(gspca_dev->dev,\n\t\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t\t0,\n\t\t\t   USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\t0x01, 0,\n\t\t\t\ttmpbuf, len, 500);\n\t\tkfree(tmpbuf);\n\t}\n}\n\n \nstatic void reg_w_ixbuf(struct gspca_dev *gspca_dev,\n\t\t\tu8 reg,\n\t\t\tconst u8 *buffer, u16 len)\n{\n\tint i;\n\tu8 *p, *tmpbuf;\n\n\tif (len * 2 <= USB_BUF_SZ) {\n\t\tp = tmpbuf = gspca_dev->usb_buf;\n\t} else {\n\t\tp = tmpbuf = kmalloc_array(len, 2, GFP_KERNEL);\n\t\tif (!tmpbuf) {\n\t\t\tpr_err(\"Out of memory\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\ti = len;\n\twhile (--i >= 0) {\n\t\t*p++ = reg++;\n\t\t*p++ = *buffer++;\n\t}\n\tusb_control_msg(gspca_dev->dev,\n\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t0,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0x01, 0,\n\t\t\ttmpbuf, len * 2, 500);\n\tif (len * 2 > USB_BUF_SZ)\n\t\tkfree(tmpbuf);\n}\n\nstatic void om6802_sensor_init(struct gspca_dev *gspca_dev)\n{\n\tint i;\n\tconst u8 *p;\n\tu8 byte;\n\tu8 val[6] = {0x62, 0, 0x64, 0, 0x60, 0x05};\n\tstatic const u8 sensor_init[] = {\n\t\t0xdf, 0x6d,\n\t\t0xdd, 0x18,\n\t\t0x5a, 0xe0,\n\t\t0x5c, 0x07,\n\t\t0x5d, 0xb0,\n\t\t0x5e, 0x1e,\n\t\t0x60, 0x71,\n\t\t0xef, 0x00,\n\t\t0xe9, 0x00,\n\t\t0xea, 0x00,\n\t\t0x90, 0x24,\n\t\t0x91, 0xb2,\n\t\t0x82, 0x32,\n\t\t0xfd, 0x41,\n\t\t0x00\t\t\t \n\t};\n\n\treg_w_buf(gspca_dev, sensor_reset, sizeof sensor_reset);\n\tmsleep(100);\n\ti = 4;\n\twhile (--i > 0) {\n\t\tbyte = reg_r(gspca_dev, 0x0060);\n\t\tif (!(byte & 0x01))\n\t\t\tbreak;\n\t\tmsleep(100);\n\t}\n\tbyte = reg_r(gspca_dev, 0x0063);\n\tif (byte != 0x17) {\n\t\tpr_err(\"Bad sensor reset %02x\\n\", byte);\n\t\t \n\t}\n\n\tp = sensor_init;\n\twhile (*p != 0) {\n\t\tval[1] = *p++;\n\t\tval[3] = *p++;\n\t\tif (*p == 0)\n\t\t\treg_w(gspca_dev, 0x3c80);\n\t\treg_w_buf(gspca_dev, val, sizeof val);\n\t\ti = 4;\n\t\twhile (--i >= 0) {\n\t\t\tmsleep(15);\n\t\t\tbyte = reg_r(gspca_dev, 0x60);\n\t\t\tif (!(byte & 0x01))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tmsleep(15);\n\treg_w(gspca_dev, 0x3c80);\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct cam *cam  = &gspca_dev->cam;\n\n\tcam->cam_mode = vga_mode_t16;\n\tcam->nmodes = ARRAY_SIZE(vga_mode_t16);\n\n\treturn 0;\n}\n\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 brightness)\n{\n\tu8 set6[4] = { 0x8f, 0x24, 0xc3, 0x00 };\n\n\tif (brightness < 7) {\n\t\tset6[1] = 0x26;\n\t\tset6[3] = 0x70 - brightness * 0x10;\n\t} else {\n\t\tset6[3] = 0x00 + ((brightness - 7) * 0x10);\n\t}\n\n\treg_w_buf(gspca_dev, set6, sizeof set6);\n}\n\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 contrast)\n{\n\tu16 reg_to_write;\n\n\tif (contrast < 7)\n\t\treg_to_write = 0x8ea9 - contrast * 0x200;\n\telse\n\t\treg_to_write = 0x00a9 + (contrast - 7) * 0x200;\n\n\treg_w(gspca_dev, reg_to_write);\n}\n\nstatic void setcolors(struct gspca_dev *gspca_dev, s32 val)\n{\n\tu16 reg_to_write;\n\n\treg_to_write = 0x80bb + val * 0x100;\t \n\treg_w(gspca_dev, reg_to_write);\n}\n\nstatic void setgamma(struct gspca_dev *gspca_dev, s32 val)\n{\n\tgspca_dbg(gspca_dev, D_CONF, \"Gamma: %d\\n\", val);\n\treg_w_ixbuf(gspca_dev, 0x90,\n\t\tgamma_table[val], sizeof gamma_table[0]);\n}\n\nstatic void setawb_n_RGB(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 all_gain_reg[8] = {\n\t\t0x87, 0x00, 0x88, 0x00, 0x89, 0x00, 0x80, 0x00 };\n\ts32 red_gain, blue_gain, green_gain;\n\n\tgreen_gain = sd->gain->val;\n\n\tred_gain = green_gain + sd->red_balance->val;\n\tif (red_gain > 0x40)\n\t\tred_gain = 0x40;\n\telse if (red_gain < 0x10)\n\t\tred_gain = 0x10;\n\n\tblue_gain = green_gain + sd->blue_balance->val;\n\tif (blue_gain > 0x40)\n\t\tblue_gain = 0x40;\n\telse if (blue_gain < 0x10)\n\t\tblue_gain = 0x10;\n\n\tall_gain_reg[1] = red_gain;\n\tall_gain_reg[3] = blue_gain;\n\tall_gain_reg[5] = green_gain;\n\tall_gain_reg[7] = sensor_data[sd->sensor].reg80;\n\tif (!sd->awb->val)\n\t\tall_gain_reg[7] &= ~0x04;  \n\n\treg_w_buf(gspca_dev, all_gain_reg, sizeof all_gain_reg);\n}\n\nstatic void setsharpness(struct gspca_dev *gspca_dev, s32 val)\n{\n\tu16 reg_to_write;\n\n\treg_to_write = 0x0aa6 + 0x1000 * val;\n\n\treg_w(gspca_dev, reg_to_write);\n}\n\nstatic void setfreq(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 reg66;\n\tu8 freq[4] = { 0x66, 0x00, 0xa8, 0xe8 };\n\n\tswitch (sd->sensor) {\n\tcase SENSOR_LT168G:\n\t\tif (val != 0)\n\t\t\tfreq[3] = 0xa8;\n\t\treg66 = 0x41;\n\t\tbreak;\n\tcase SENSOR_OM6802:\n\t\treg66 = 0xca;\n\t\tbreak;\n\tdefault:\n\t\treg66 = 0x40;\n\t\tbreak;\n\t}\n\tswitch (val) {\n\tcase 0:\t\t\t\t \n\t\tfreq[3] = 0xf0;\n\t\tbreak;\n\tcase 2:\t\t\t\t \n\t\treg66 &= ~0x40;\n\t\tbreak;\n\t}\n\tfreq[1] = reg66;\n\n\treg_w_buf(gspca_dev, freq, sizeof freq);\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\t \n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tconst struct additional_sensor_data *sensor;\n\tint i;\n\tu16 sensor_id;\n\tu8 test_byte = 0;\n\n\tstatic const u8 read_indexs[] =\n\t\t{ 0x0a, 0x0b, 0x66, 0x80, 0x81, 0x8e, 0x8f, 0xa5,\n\t\t  0xa6, 0xa8, 0xbb, 0xbc, 0xc6, 0x00 };\n\tstatic const u8 n1[] =\n\t\t\t{0x08, 0x03, 0x09, 0x03, 0x12, 0x04};\n\tstatic const u8 n2[] =\n\t\t\t{0x08, 0x00};\n\n\tsensor_id = (reg_r(gspca_dev, 0x06) << 8)\n\t\t\t| reg_r(gspca_dev, 0x07);\n\tswitch (sensor_id & 0xff0f) {\n\tcase 0x0801:\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"sensor tas5130a\\n\");\n\t\tsd->sensor = SENSOR_TAS5130A;\n\t\tbreak;\n\tcase 0x0802:\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"sensor lt168g\\n\");\n\t\tsd->sensor = SENSOR_LT168G;\n\t\tbreak;\n\tcase 0x0803:\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"sensor 'other'\\n\");\n\t\tsd->sensor = SENSOR_OTHER;\n\t\tbreak;\n\tcase 0x0807:\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"sensor om6802\\n\");\n\t\tsd->sensor = SENSOR_OM6802;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown sensor %04x\\n\", sensor_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sd->sensor == SENSOR_OM6802) {\n\t\treg_w_buf(gspca_dev, n1, sizeof n1);\n\t\ti = 5;\n\t\twhile (--i >= 0) {\n\t\t\treg_w_buf(gspca_dev, sensor_reset, sizeof sensor_reset);\n\t\t\ttest_byte = reg_r(gspca_dev, 0x0063);\n\t\t\tmsleep(100);\n\t\t\tif (test_byte == 0x17)\n\t\t\t\tbreak;\t\t \n\t\t}\n\t\tif (i < 0) {\n\t\t\tpr_err(\"Bad sensor reset %02x\\n\", test_byte);\n\t\t\treturn -EIO;\n\t\t}\n\t\treg_w_buf(gspca_dev, n2, sizeof n2);\n\t}\n\n\ti = 0;\n\twhile (read_indexs[i] != 0x00) {\n\t\ttest_byte = reg_r(gspca_dev, read_indexs[i]);\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Reg 0x%02x = 0x%02x\\n\",\n\t\t\t  read_indexs[i], test_byte);\n\t\ti++;\n\t}\n\n\tsensor = &sensor_data[sd->sensor];\n\treg_w_buf(gspca_dev, sensor->n3, sizeof sensor->n3);\n\treg_w_buf(gspca_dev, sensor->n4, sensor->n4sz);\n\n\tif (sd->sensor == SENSOR_LT168G) {\n\t\ttest_byte = reg_r(gspca_dev, 0x80);\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Reg 0x%02x = 0x%02x\\n\", 0x80,\n\t\t\t  test_byte);\n\t\treg_w(gspca_dev, 0x6c80);\n\t}\n\n\treg_w_ixbuf(gspca_dev, 0xd0, sensor->data1, sizeof sensor->data1);\n\treg_w_ixbuf(gspca_dev, 0xc7, sensor->data2, sizeof sensor->data2);\n\treg_w_ixbuf(gspca_dev, 0xe0, sensor->data3, sizeof sensor->data3);\n\n\treg_w(gspca_dev, (sensor->reg80 << 8) + 0x80);\n\treg_w(gspca_dev, (sensor->reg80 << 8) + 0x80);\n\treg_w(gspca_dev, (sensor->reg8e << 8) + 0x8e);\n\treg_w(gspca_dev, (0x20 << 8) + 0x87);\n\treg_w(gspca_dev, (0x20 << 8) + 0x88);\n\treg_w(gspca_dev, (0x20 << 8) + 0x89);\n\n\treg_w_buf(gspca_dev, sensor->data5, sizeof sensor->data5);\n\treg_w_buf(gspca_dev, sensor->nset8, sizeof sensor->nset8);\n\treg_w_buf(gspca_dev, sensor->stream, sizeof sensor->stream);\n\n\tif (sd->sensor == SENSOR_LT168G) {\n\t\ttest_byte = reg_r(gspca_dev, 0x80);\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Reg 0x%02x = 0x%02x\\n\", 0x80,\n\t\t\t  test_byte);\n\t\treg_w(gspca_dev, 0x6c80);\n\t}\n\n\treg_w_ixbuf(gspca_dev, 0xd0, sensor->data1, sizeof sensor->data1);\n\treg_w_ixbuf(gspca_dev, 0xc7, sensor->data2, sizeof sensor->data2);\n\treg_w_ixbuf(gspca_dev, 0xe0, sensor->data3, sizeof sensor->data3);\n\n\treturn 0;\n}\n\nstatic void setmirror(struct gspca_dev *gspca_dev, s32 val)\n{\n\tu8 hflipcmd[8] =\n\t\t{0x62, 0x07, 0x63, 0x03, 0x64, 0x00, 0x60, 0x09};\n\n\tif (val)\n\t\thflipcmd[3] = 0x01;\n\n\treg_w_buf(gspca_dev, hflipcmd, sizeof hflipcmd);\n}\n\nstatic void seteffect(struct gspca_dev *gspca_dev, s32 val)\n{\n\tint idx = 0;\n\n\tswitch (val) {\n\tcase V4L2_COLORFX_NONE:\n\t\tbreak;\n\tcase V4L2_COLORFX_BW:\n\t\tidx = 2;\n\t\tbreak;\n\tcase V4L2_COLORFX_SEPIA:\n\t\tidx = 3;\n\t\tbreak;\n\tcase V4L2_COLORFX_SKETCH:\n\t\tidx = 4;\n\t\tbreak;\n\tcase V4L2_COLORFX_NEGATIVE:\n\t\tidx = 6;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treg_w_buf(gspca_dev, effects_table[idx],\n\t\t\t\tsizeof effects_table[0]);\n\n\tif (val == V4L2_COLORFX_SKETCH)\n\t\treg_w(gspca_dev, 0x4aa6);\n\telse\n\t\treg_w(gspca_dev, 0xfaa6);\n}\n\n \nstatic void poll_sensor(struct gspca_dev *gspca_dev)\n{\n\tstatic const u8 poll1[] =\n\t\t{0x67, 0x05, 0x68, 0x81, 0x69, 0x80, 0x6a, 0x82,\n\t\t 0x6b, 0x68, 0x6c, 0x69, 0x72, 0xd9, 0x73, 0x34,\n\t\t 0x74, 0x32, 0x75, 0x92, 0x76, 0x00, 0x09, 0x01,\n\t\t 0x60, 0x14};\n\tstatic const u8 poll2[] =\n\t\t{0x67, 0x02, 0x68, 0x71, 0x69, 0x72, 0x72, 0xa9,\n\t\t 0x73, 0x02, 0x73, 0x02, 0x60, 0x14};\n\tstatic const u8 noise03[] =\t \n\t\t{0xa6, 0x0a, 0xea, 0xcf, 0xbe, 0x26, 0xb1, 0x5f,\n\t\t 0xa1, 0xb1, 0xda, 0x6b, 0xdb, 0x98, 0xdf, 0x0c,\n\t\t 0xc2, 0x80, 0xc3, 0x10};\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"[Sensor requires polling]\\n\");\n\treg_w_buf(gspca_dev, poll1, sizeof poll1);\n\treg_w_buf(gspca_dev, poll2, sizeof poll2);\n\treg_w_buf(gspca_dev, noise03, sizeof noise03);\n}\n\nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tconst struct additional_sensor_data *sensor;\n\tint i, mode;\n\tu8 t2[] = { 0x07, 0x00, 0x0d, 0x60, 0x0e, 0x80 };\n\tstatic const u8 t3[] =\n\t\t{ 0x07, 0x00, 0x88, 0x02, 0x06, 0x00, 0xe7, 0x01 };\n\n\tmode = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\n\tswitch (mode) {\n\tcase 0:\t\t \n\t\tbreak;\n\tcase 1:\t\t \n\t\tt2[1] = 0x40;\n\t\tbreak;\n\tcase 2:\t\t \n\t\tt2[1] = 0x10;\n\t\tbreak;\n\tcase 3:\t\t \n\t\tt2[1] = 0x50;\n\t\tbreak;\n\tdefault:\n \n\t\tt2[1] = 0x20;\n\t\tbreak;\n\t}\n\n\tswitch (sd->sensor) {\n\tcase SENSOR_OM6802:\n\t\tom6802_sensor_init(gspca_dev);\n\t\tbreak;\n\tcase SENSOR_TAS5130A:\n\t\ti = 0;\n\t\tfor (;;) {\n\t\t\treg_w_buf(gspca_dev, tas5130a_sensor_init[i],\n\t\t\t\t\t sizeof tas5130a_sensor_init[0]);\n\t\t\tif (i >= ARRAY_SIZE(tas5130a_sensor_init) - 1)\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t}\n\t\treg_w(gspca_dev, 0x3c80);\n\t\t \n\t\treg_w_buf(gspca_dev, tas5130a_sensor_init[i],\n\t\t\t\t sizeof tas5130a_sensor_init[0]);\n\t\treg_w(gspca_dev, 0x3c80);\n\t\tbreak;\n\t}\n\tsensor = &sensor_data[sd->sensor];\n\tsetfreq(gspca_dev, v4l2_ctrl_g_ctrl(sd->freq));\n\treg_r(gspca_dev, 0x0012);\n\treg_w_buf(gspca_dev, t2, sizeof t2);\n\treg_w_ixbuf(gspca_dev, 0xb3, t3, sizeof t3);\n\treg_w(gspca_dev, 0x0013);\n\tmsleep(15);\n\treg_w_buf(gspca_dev, sensor->stream, sizeof sensor->stream);\n\treg_w_buf(gspca_dev, sensor->stream, sizeof sensor->stream);\n\n\tif (sd->sensor == SENSOR_OM6802)\n\t\tpoll_sensor(gspca_dev);\n\n\treturn 0;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\treg_w_buf(gspca_dev, sensor_data[sd->sensor].stream,\n\t\t\tsizeof sensor_data[sd->sensor].stream);\n\treg_w_buf(gspca_dev, sensor_data[sd->sensor].stream,\n\t\t\tsizeof sensor_data[sd->sensor].stream);\n\tif (sd->sensor == SENSOR_OM6802) {\n\t\tmsleep(20);\n\t\treg_w(gspca_dev, 0x0309);\n\t}\n#if IS_ENABLED(CONFIG_INPUT)\n\t \n\tif (sd->button_pressed) {\n\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\n\t\tinput_sync(gspca_dev->input_dev);\n\t\tsd->button_pressed = 0;\n\t}\n#endif\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t \n\t\t\tint len)\t\t\t \n{\n\tstruct sd *sd __maybe_unused = (struct sd *) gspca_dev;\n\tint pkt_type;\n\n\tif (data[0] == 0x5a) {\n#if IS_ENABLED(CONFIG_INPUT)\n\t\tif (len > 20) {\n\t\t\tu8 state = (data[20] & 0x80) ? 1 : 0;\n\t\t\tif (sd->button_pressed != state) {\n\t\t\t\tinput_report_key(gspca_dev->input_dev,\n\t\t\t\t\t\t KEY_CAMERA, state);\n\t\t\t\tinput_sync(gspca_dev->input_dev);\n\t\t\t\tsd->button_pressed = state;\n\t\t\t}\n\t\t}\n#endif\n\t\t \n\t\treturn;\n\t}\n\tdata += 2;\n\tlen -= 2;\n\tif (data[0] == 0xff && data[1] == 0xd8)\n\t\tpkt_type = FIRST_PACKET;\n\telse if (data[len - 2] == 0xff && data[len - 1] == 0xd9)\n\t\tpkt_type = LAST_PACKET;\n\telse\n\t\tpkt_type = INTER_PACKET;\n\tgspca_frame_add(gspca_dev, pkt_type, data, len);\n}\n\nstatic int sd_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\ts32 red_gain, blue_gain, green_gain;\n\n\tgspca_dev->usb_err = 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\tred_gain = reg_r(gspca_dev, 0x0087);\n\t\tif (red_gain > 0x40)\n\t\t\tred_gain = 0x40;\n\t\telse if (red_gain < 0x10)\n\t\t\tred_gain = 0x10;\n\n\t\tblue_gain = reg_r(gspca_dev, 0x0088);\n\t\tif (blue_gain > 0x40)\n\t\t\tblue_gain = 0x40;\n\t\telse if (blue_gain < 0x10)\n\t\t\tblue_gain = 0x10;\n\n\t\tgreen_gain = reg_r(gspca_dev, 0x0089);\n\t\tif (green_gain > 0x40)\n\t\t\tgreen_gain = 0x40;\n\t\telse if (green_gain < 0x10)\n\t\t\tgreen_gain = 0x10;\n\n\t\tsd->gain->val = green_gain;\n\t\tsd->red_balance->val = red_gain - green_gain;\n\t\tsd->blue_balance->val = blue_gain - green_gain;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\n\tgspca_dev->usb_err = 0;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsetbrightness(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tsetcontrast(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tsetcolors(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_GAMMA:\n\t\tsetgamma(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tsetmirror(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SHARPNESS:\n\t\tsetsharpness(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_POWER_LINE_FREQUENCY:\n\t\tsetfreq(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_BACKLIGHT_COMPENSATION:\n\t\treg_w(gspca_dev, ctrl->val ? 0xf48e : 0xb48e);\n\t\tbreak;\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\tsetawb_n_RGB(gspca_dev);\n\t\tbreak;\n\tcase V4L2_CID_COLORFX:\n\t\tseteffect(gspca_dev, ctrl->val);\n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.g_volatile_ctrl = sd_g_volatile_ctrl,\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 12);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 14, 1, 8);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 0x0d, 1, 7);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 0xf, 1, 5);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_GAMMA, 0, GAMMA_MAX, 1, 10);\n\t \n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BACKLIGHT_COMPENSATION, 0, 1, 1, 1);\n\tif (sd->sensor == SENSOR_TAS5130A)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\tsd->awb = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_AUTO_WHITE_BALANCE, 0, 1, 1, 1);\n\tsd->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, 0x10, 0x40, 1, 0x20);\n\tsd->blue_balance = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BLUE_BALANCE, -0x30, 0x30, 1, 0);\n\tsd->red_balance = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_RED_BALANCE, -0x30, 0x30, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_SHARPNESS, 0, 15, 1, 6);\n\tv4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_COLORFX, V4L2_COLORFX_SKETCH,\n\t\t\t~((1 << V4L2_COLORFX_NONE) |\n\t\t\t  (1 << V4L2_COLORFX_BW) |\n\t\t\t  (1 << V4L2_COLORFX_SEPIA) |\n\t\t\t  (1 << V4L2_COLORFX_SKETCH) |\n\t\t\t  (1 << V4L2_COLORFX_NEGATIVE)),\n\t\t\tV4L2_COLORFX_NONE);\n\tsd->freq = v4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_POWER_LINE_FREQUENCY,\n\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_60HZ, 1,\n\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_50HZ);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\n\tv4l2_ctrl_auto_cluster(4, &sd->awb, 0, true);\n\n\treturn 0;\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.pkt_scan = sd_pkt_scan,\n#if IS_ENABLED(CONFIG_INPUT)\n\t.other_input = 1,\n#endif\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x17a1, 0x0128)},\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t    const struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t       THIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}