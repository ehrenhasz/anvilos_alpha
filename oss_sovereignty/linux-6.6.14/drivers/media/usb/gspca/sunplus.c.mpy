{
  "module_name": "sunplus.c",
  "hash_id": "39a263cb4b4c877dd199f09669181c36ec465e098ac7e23b49c6a0d15bb93fe9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/sunplus.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"sunplus\"\n\n#include \"gspca.h\"\n#include \"jpeg.h\"\n\nMODULE_AUTHOR(\"Michel Xhaard <mxhaard@users.sourceforge.net>\");\nMODULE_DESCRIPTION(\"GSPCA/SPCA5xx USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define QUALITY 85\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t \n\n\tbool autogain;\n\n\tu8 bridge;\n#define BRIDGE_SPCA504 0\n#define BRIDGE_SPCA504B 1\n#define BRIDGE_SPCA504C 2\n#define BRIDGE_SPCA533 3\n#define BRIDGE_SPCA536 4\n\tu8 subtype;\n#define AiptekMiniPenCam13 1\n#define LogitechClickSmart420 2\n#define LogitechClickSmart820 3\n#define MegapixV4 4\n#define MegaImageVI 5\n\n\tu8 jpeg_hdr[JPEG_HDR_SZ];\n};\n\nstatic const struct v4l2_pix_format vga_mode[] = {\n\t{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 2},\n\t{640, 480, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n};\n\nstatic const struct v4l2_pix_format custom_mode[] = {\n\t{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 2},\n\t{464, 480, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 464,\n\t\t.sizeimage = 464 * 480 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n};\n\nstatic const struct v4l2_pix_format vga_mode2[] = {\n\t{176, 144, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 176 * 144 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 4},\n\t{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 3},\n\t{352, 288, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352,\n\t\t.sizeimage = 352 * 288 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 2},\n\t{640, 480, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n};\n\n#define SPCA50X_OFFSET_DATA 10\n#define SPCA504_PCCAM600_OFFSET_SNAPSHOT 3\n#define SPCA504_PCCAM600_OFFSET_COMPRESS 4\n#define SPCA504_PCCAM600_OFFSET_MODE\t 5\n#define SPCA504_PCCAM600_OFFSET_DATA\t 14\n  \n#define SPCA533_OFFSET_DATA\t16\n#define SPCA533_OFFSET_FRAMSEQ\t15\n \n#define SPCA536_OFFSET_DATA\t4\n#define SPCA536_OFFSET_FRAMSEQ\t1\n\nstruct cmd {\n\tu8 req;\n\tu16 val;\n\tu16 idx;\n};\n\n \nstatic const struct cmd spca504_pccam600_init_data[] = {\n \n\t{0x00, 0x0000, 0x2000},\n\t{0x00, 0x0013, 0x2301},\n\t{0x00, 0x0003, 0x2000},\n\t{0x00, 0x0001, 0x21ac},\n\t{0x00, 0x0001, 0x21a6},\n\t{0x00, 0x0000, 0x21a7},\t \n\t{0x00, 0x0020, 0x21a8},\t \n\t{0x00, 0x0001, 0x21ac},\t \n\t{0x00, 0x0000, 0x21ad},\t \n\t{0x00, 0x001a, 0x21ae},\t \n\t{0x00, 0x0002, 0x21a3},\t \n\t{0x30, 0x0154, 0x0008},\n\t{0x30, 0x0004, 0x0006},\n\t{0x30, 0x0258, 0x0009},\n\t{0x30, 0x0004, 0x0000},\n\t{0x30, 0x0093, 0x0004},\n\t{0x30, 0x0066, 0x0005},\n\t{0x00, 0x0000, 0x2000},\n\t{0x00, 0x0013, 0x2301},\n\t{0x00, 0x0003, 0x2000},\n\t{0x00, 0x0013, 0x2301},\n\t{0x00, 0x0003, 0x2000},\n};\n\n \nstatic const struct cmd spca504_pccam600_open_data[] = {\n\t{0x00, 0x0001, 0x2501},\n\t{0x20, 0x0500, 0x0001},\t \n\t{0x00, 0x0003, 0x2880},\n\t{0x00, 0x0001, 0x2881},\n};\n\n \nstatic const struct cmd spca504A_clicksmart420_init_data[] = {\n \n\t{0x00, 0x0000, 0x2000},\n\t{0x00, 0x0013, 0x2301},\n\t{0x00, 0x0003, 0x2000},\n\t{0x00, 0x0001, 0x21ac},\n\t{0x00, 0x0001, 0x21a6},\n\t{0x00, 0x0000, 0x21a7},\t \n\t{0x00, 0x0020, 0x21a8},\t \n\t{0x00, 0x0001, 0x21ac},\t \n\t{0x00, 0x0000, 0x21ad},\t \n\t{0x00, 0x001a, 0x21ae},\t \n\t{0x00, 0x0002, 0x21a3},\t \n\t{0x30, 0x0004, 0x000a},\n\t{0xb0, 0x0001, 0x0000},\n\n\t{0xa1, 0x0080, 0x0001},\n\t{0x30, 0x0049, 0x0000},\n\t{0x30, 0x0060, 0x0005},\n\t{0x0c, 0x0004, 0x0000},\n\t{0x00, 0x0000, 0x0000},\n\t{0x00, 0x0000, 0x2000},\n\t{0x00, 0x0013, 0x2301},\n\t{0x00, 0x0003, 0x2000},\n};\n\n \nstatic const struct cmd spca504A_clicksmart420_open_data[] = {\n\t{0x00, 0x0001, 0x2501},\n\t{0x20, 0x0502, 0x0000},\n\t{0x06, 0x0000, 0x0000},\n\t{0x00, 0x0004, 0x2880},\n\t{0x00, 0x0001, 0x2881},\n\n\t{0xa0, 0x0000, 0x0503},\n};\n\nstatic const u8 qtable_creative_pccam[2][64] = {\n\t{\t\t\t\t \n\t 0x05, 0x03, 0x03, 0x05, 0x07, 0x0c, 0x0f, 0x12,\n\t 0x04, 0x04, 0x04, 0x06, 0x08, 0x11, 0x12, 0x11,\n\t 0x04, 0x04, 0x05, 0x07, 0x0c, 0x11, 0x15, 0x11,\n\t 0x04, 0x05, 0x07, 0x09, 0x0f, 0x1a, 0x18, 0x13,\n\t 0x05, 0x07, 0x0b, 0x11, 0x14, 0x21, 0x1f, 0x17,\n\t 0x07, 0x0b, 0x11, 0x13, 0x18, 0x1f, 0x22, 0x1c,\n\t 0x0f, 0x13, 0x17, 0x1a, 0x1f, 0x24, 0x24, 0x1e,\n\t 0x16, 0x1c, 0x1d, 0x1d, 0x22, 0x1e, 0x1f, 0x1e},\n\t{\t\t\t\t \n\t 0x05, 0x05, 0x07, 0x0e, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x05, 0x06, 0x08, 0x14, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x07, 0x08, 0x11, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x0e, 0x14, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e}\n};\n\n \nstatic const u8 qtable_spca504_default[2][64] = {\n\t{\t\t\t\t \n\t 0x05, 0x03, 0x03, 0x05, 0x07, 0x0c, 0x0f, 0x12,\n\t 0x04, 0x04, 0x04, 0x06, 0x08, 0x11, 0x12, 0x11,\n\t 0x04, 0x04, 0x05, 0x07, 0x0c, 0x11, 0x15, 0x11,\n\t 0x04, 0x05, 0x07, 0x09, 0x0f, 0x1a, 0x18, 0x13,\n\t 0x05, 0x07, 0x0b, 0x11, 0x14, 0x21, 0x1f, 0x17,\n\t 0x07, 0x0b, 0x11, 0x13, 0x18, 0x1f, 0x22, 0x1c,\n\t 0x0f, 0x13, 0x17, 0x1a, 0x1f, 0x24, 0x24, 0x1e,\n\t 0x16, 0x1c, 0x1d, 0x1d, 0x1d   , 0x1e, 0x1f, 0x1e,\n\t },\n\t{\t\t\t\t \n\t 0x05, 0x05, 0x07, 0x0e, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x05, 0x06, 0x08, 0x14, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x07, 0x08, 0x11, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x0e, 0x14, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,\n\t 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e}\n};\n\n \nstatic void reg_r(struct gspca_dev *gspca_dev,\n\t\t  u8 req,\n\t\t  u16 index,\n\t\t  u16 len)\n{\n\tint ret;\n\n\tif (len > USB_BUF_SZ) {\n\t\tgspca_err(gspca_dev, \"reg_r: buffer overflow\\n\");\n\t\treturn;\n\t}\n\tif (len == 0) {\n\t\tgspca_err(gspca_dev, \"reg_r: zero-length read\\n\");\n\t\treturn;\n\t}\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tret = usb_control_msg(gspca_dev->dev,\n\t\t\tusb_rcvctrlpipe(gspca_dev->dev, 0),\n\t\t\treq,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0,\t\t \n\t\t\tindex,\n\t\t\tgspca_dev->usb_buf, len,\n\t\t\t500);\n\tif (ret < 0) {\n\t\tpr_err(\"reg_r err %d\\n\", ret);\n\t\tgspca_dev->usb_err = ret;\n\t\t \n\t\tmemset(gspca_dev->usb_buf, 0, USB_BUF_SZ);\n\t}\n}\n\n \nstatic void reg_w_1(struct gspca_dev *gspca_dev,\n\t\t   u8 req,\n\t\t   u16 value,\n\t\t   u16 index,\n\t\t   u16 byte)\n{\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tgspca_dev->usb_buf[0] = byte;\n\tret = usb_control_msg(gspca_dev->dev,\n\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\treq,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tvalue, index,\n\t\t\tgspca_dev->usb_buf, 1,\n\t\t\t500);\n\tif (ret < 0) {\n\t\tpr_err(\"reg_w_1 err %d\\n\", ret);\n\t\tgspca_dev->usb_err = ret;\n\t}\n}\n\n \nstatic void reg_w_riv(struct gspca_dev *gspca_dev,\n\t\t     u8 req, u16 index, u16 value)\n{\n\tstruct usb_device *dev = gspca_dev->dev;\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tret = usb_control_msg(dev,\n\t\t\tusb_sndctrlpipe(dev, 0),\n\t\t\treq,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tvalue, index, NULL, 0, 500);\n\tif (ret < 0) {\n\t\tpr_err(\"reg_w_riv err %d\\n\", ret);\n\t\tgspca_dev->usb_err = ret;\n\t\treturn;\n\t}\n\tgspca_dbg(gspca_dev, D_USBO, \"reg_w_riv: 0x%02x,0x%04x:0x%04x\\n\",\n\t\t  req, index, value);\n}\n\nstatic void write_vector(struct gspca_dev *gspca_dev,\n\t\t\tconst struct cmd *data, int ncmds)\n{\n\twhile (--ncmds >= 0) {\n\t\treg_w_riv(gspca_dev, data->req, data->idx, data->val);\n\t\tdata++;\n\t}\n}\n\nstatic void setup_qtable(struct gspca_dev *gspca_dev,\n\t\t\tconst u8 qtable[2][64])\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < 64; i++)\n\t\treg_w_riv(gspca_dev, 0x00, 0x2800 + i, qtable[0][i]);\n\n\t \n\tfor (i = 0; i < 64; i++)\n\t\treg_w_riv(gspca_dev, 0x00, 0x2840 + i, qtable[1][i]);\n}\n\nstatic void spca504_acknowledged_command(struct gspca_dev *gspca_dev,\n\t\t\t     u8 req, u16 idx, u16 val)\n{\n\treg_w_riv(gspca_dev, req, idx, val);\n\treg_r(gspca_dev, 0x01, 0x0001, 1);\n\tgspca_dbg(gspca_dev, D_FRAM, \"before wait 0x%04x\\n\",\n\t\t  gspca_dev->usb_buf[0]);\n\treg_w_riv(gspca_dev, req, idx, val);\n\n\tmsleep(200);\n\treg_r(gspca_dev, 0x01, 0x0001, 1);\n\tgspca_dbg(gspca_dev, D_FRAM, \"after wait 0x%04x\\n\",\n\t\t  gspca_dev->usb_buf[0]);\n}\n\nstatic void spca504_read_info(struct gspca_dev *gspca_dev)\n{\n\tint i;\n\tu8 info[6];\n\n\tif (gspca_debug < D_STREAM)\n\t\treturn;\n\n\tfor (i = 0; i < 6; i++) {\n\t\treg_r(gspca_dev, 0, i, 1);\n\t\tinfo[i] = gspca_dev->usb_buf[0];\n\t}\n\tgspca_dbg(gspca_dev, D_STREAM,\n\t\t  \"Read info: %d %d %d %d %d %d. Should be 1,0,2,2,0,0\\n\",\n\t\t  info[0], info[1], info[2],\n\t\t  info[3], info[4], info[5]);\n}\n\nstatic void spca504A_acknowledged_command(struct gspca_dev *gspca_dev,\n\t\t\tu8 req,\n\t\t\tu16 idx, u16 val, u8 endcode, u8 count)\n{\n\tu16 status;\n\n\treg_w_riv(gspca_dev, req, idx, val);\n\treg_r(gspca_dev, 0x01, 0x0001, 1);\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tgspca_dbg(gspca_dev, D_FRAM, \"Status 0x%02x Need 0x%02x\\n\",\n\t\t  gspca_dev->usb_buf[0], endcode);\n\tif (!count)\n\t\treturn;\n\tcount = 200;\n\twhile (--count > 0) {\n\t\tmsleep(10);\n\t\t \n \n\t\treg_r(gspca_dev, 0x01, 0x0001, 1);\n\t\tstatus = gspca_dev->usb_buf[0];\n\t\tif (status == endcode) {\n\t\t\tgspca_dbg(gspca_dev, D_FRAM, \"status 0x%04x after wait %d\\n\",\n\t\t\t\t  status, 200 - count);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void spca504B_PollingDataReady(struct gspca_dev *gspca_dev)\n{\n\tint count = 10;\n\n\twhile (--count > 0) {\n\t\treg_r(gspca_dev, 0x21, 0, 1);\n\t\tif ((gspca_dev->usb_buf[0] & 0x01) == 0)\n\t\t\tbreak;\n\t\tmsleep(10);\n\t}\n}\n\nstatic void spca504B_WaitCmdStatus(struct gspca_dev *gspca_dev)\n{\n\tint count = 50;\n\n\twhile (--count > 0) {\n\t\treg_r(gspca_dev, 0x21, 1, 1);\n\t\tif (gspca_dev->usb_buf[0] != 0) {\n\t\t\treg_w_1(gspca_dev, 0x21, 0, 1, 0);\n\t\t\treg_r(gspca_dev, 0x21, 1, 1);\n\t\t\tspca504B_PollingDataReady(gspca_dev);\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(10);\n\t}\n}\n\nstatic void spca50x_GetFirmware(struct gspca_dev *gspca_dev)\n{\n\tu8 *data;\n\n\tif (gspca_debug < D_STREAM)\n\t\treturn;\n\n\tdata = gspca_dev->usb_buf;\n\treg_r(gspca_dev, 0x20, 0, 5);\n\tgspca_dbg(gspca_dev, D_STREAM, \"FirmWare: %d %d %d %d %d\\n\",\n\t\t  data[0], data[1], data[2], data[3], data[4]);\n\treg_r(gspca_dev, 0x23, 0, 64);\n\treg_r(gspca_dev, 0x23, 1, 64);\n}\n\nstatic void spca504B_SetSizeType(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 Size;\n\n\tSize = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\n\tswitch (sd->bridge) {\n\tcase BRIDGE_SPCA533:\n\t\treg_w_riv(gspca_dev, 0x31, 0, 0);\n\t\tspca504B_WaitCmdStatus(gspca_dev);\n\t\tspca504B_PollingDataReady(gspca_dev);\n\t\tspca50x_GetFirmware(gspca_dev);\n\n\t\treg_w_1(gspca_dev, 0x24, 0, 8, 2);\t\t \n\t\treg_r(gspca_dev, 0x24, 8, 1);\n\n\t\treg_w_1(gspca_dev, 0x25, 0, 4, Size);\n\t\treg_r(gspca_dev, 0x25, 4, 1);\t\t\t \n\t\tspca504B_PollingDataReady(gspca_dev);\n\n\t\t \n\t\treg_w_riv(gspca_dev, 0x31, 0x0004, 0x00);\n\t\tspca504B_WaitCmdStatus(gspca_dev);\n\t\tspca504B_PollingDataReady(gspca_dev);\n\t\tbreak;\n\tdefault:\n \n \n\t\treg_w_1(gspca_dev, 0x25, 0, 4, Size);\n\t\treg_r(gspca_dev, 0x25, 4, 1);\t\t\t \n\t\treg_w_1(gspca_dev, 0x27, 0, 0, 6);\n\t\treg_r(gspca_dev, 0x27, 0, 1);\t\t\t \n\t\tspca504B_PollingDataReady(gspca_dev);\n\t\tbreak;\n\tcase BRIDGE_SPCA504:\n\t\tSize += 3;\n\t\tif (sd->subtype == AiptekMiniPenCam13) {\n\t\t\t \n\t\t\tspca504A_acknowledged_command(gspca_dev,\n\t\t\t\t\t\t0x08, Size, 0,\n\t\t\t\t\t\t0x80 | (Size & 0x0f), 1);\n\t\t\tspca504A_acknowledged_command(gspca_dev,\n\t\t\t\t\t\t\t1, 3, 0, 0x9f, 0);\n\t\t} else {\n\t\t\tspca504_acknowledged_command(gspca_dev, 0x08, Size, 0);\n\t\t}\n\t\tbreak;\n\tcase BRIDGE_SPCA504C:\n\t\t \n\t\treg_w_riv(gspca_dev, 0xa0, (0x0500 | (Size & 0x0f)), 0x00);\n\t\treg_w_riv(gspca_dev, 0x20, 0x01, 0x0500 | (Size & 0x0f));\n\t\tbreak;\n\t}\n}\n\nstatic void spca504_wait_status(struct gspca_dev *gspca_dev)\n{\n\tint cnt;\n\n\tcnt = 256;\n\twhile (--cnt > 0) {\n\t\t \n\t\treg_r(gspca_dev, 0x06, 0x00, 1);\n\t\tif (gspca_dev->usb_buf[0] == 0)\n\t\t\treturn;\n\t\tmsleep(10);\n\t}\n}\n\nstatic void spca504B_setQtable(struct gspca_dev *gspca_dev)\n{\n\treg_w_1(gspca_dev, 0x26, 0, 0, 3);\n\treg_r(gspca_dev, 0x26, 0, 1);\n\tspca504B_PollingDataReady(gspca_dev);\n}\n\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu16 reg;\n\n\treg = sd->bridge == BRIDGE_SPCA536 ? 0x20f0 : 0x21a7;\n\treg_w_riv(gspca_dev, 0x00, reg, val);\n}\n\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu16 reg;\n\n\treg = sd->bridge == BRIDGE_SPCA536 ? 0x20f1 : 0x21a8;\n\treg_w_riv(gspca_dev, 0x00, reg, val);\n}\n\nstatic void setcolors(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu16 reg;\n\n\treg = sd->bridge == BRIDGE_SPCA536 ? 0x20f6 : 0x21ae;\n\treg_w_riv(gspca_dev, 0x00, reg, val);\n}\n\nstatic void init_ctl_reg(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint pollreg = 1;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_SPCA504:\n\tcase BRIDGE_SPCA504C:\n\t\tpollreg = 0;\n\t\tfallthrough;\n\tdefault:\n \n \n\t\treg_w_riv(gspca_dev, 0, 0x21ad, 0x00);\t \n\t\treg_w_riv(gspca_dev, 0, 0x21ac, 0x01);\t \n\t\treg_w_riv(gspca_dev, 0, 0x21a3, 0x00);\t \n\t\tbreak;\n\tcase BRIDGE_SPCA536:\n\t\treg_w_riv(gspca_dev, 0, 0x20f5, 0x40);\n\t\treg_w_riv(gspca_dev, 0, 0x20f4, 0x01);\n\t\treg_w_riv(gspca_dev, 0, 0x2089, 0x00);\n\t\tbreak;\n\t}\n\tif (pollreg)\n\t\tspca504B_PollingDataReady(gspca_dev);\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam;\n\n\tcam = &gspca_dev->cam;\n\n\tsd->bridge = id->driver_info >> 8;\n\tsd->subtype = id->driver_info;\n\n\tif (sd->subtype == AiptekMiniPenCam13) {\n\n\t\t \n\t\treg_r(gspca_dev, 0x20, 0, 1);\n\t\tswitch (gspca_dev->usb_buf[0]) {\n\t\tcase 1:\n\t\t\tbreak;\t\t \n\t\tcase 2:\n\t\t\tsd->bridge = BRIDGE_SPCA504B;\n\t\t\tsd->subtype = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tswitch (sd->bridge) {\n\tdefault:\n \n \n \n\t\tcam->cam_mode = vga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(vga_mode);\n\t\tbreak;\n\tcase BRIDGE_SPCA533:\n\t\tcam->cam_mode = custom_mode;\n\t\tif (sd->subtype == MegaImageVI)\t\t \n\t\t\tcam->nmodes = ARRAY_SIZE(custom_mode) - 1;\n\t\telse\n\t\t\tcam->nmodes = ARRAY_SIZE(custom_mode);\n\t\tbreak;\n\tcase BRIDGE_SPCA504C:\n\t\tcam->cam_mode = vga_mode2;\n\t\tcam->nmodes = ARRAY_SIZE(vga_mode2);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_SPCA504B:\n\t\treg_w_riv(gspca_dev, 0x1d, 0x00, 0);\n\t\treg_w_riv(gspca_dev, 0x00, 0x2306, 0x01);\n\t\treg_w_riv(gspca_dev, 0x00, 0x0d04, 0x00);\n\t\treg_w_riv(gspca_dev, 0x00, 0x2000, 0x00);\n\t\treg_w_riv(gspca_dev, 0x00, 0x2301, 0x13);\n\t\treg_w_riv(gspca_dev, 0x00, 0x2306, 0x00);\n\t\tfallthrough;\n\tcase BRIDGE_SPCA533:\n\t\tspca504B_PollingDataReady(gspca_dev);\n\t\tspca50x_GetFirmware(gspca_dev);\n\t\tbreak;\n\tcase BRIDGE_SPCA536:\n\t\tspca50x_GetFirmware(gspca_dev);\n\t\treg_r(gspca_dev, 0x00, 0x5002, 1);\n\t\treg_w_1(gspca_dev, 0x24, 0, 0, 0);\n\t\treg_r(gspca_dev, 0x24, 0, 1);\n\t\tspca504B_PollingDataReady(gspca_dev);\n\t\treg_w_riv(gspca_dev, 0x34, 0, 0);\n\t\tspca504B_WaitCmdStatus(gspca_dev);\n\t\tbreak;\n\tcase BRIDGE_SPCA504C:\t \n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Opening SPCA504 (PC-CAM 600)\\n\");\n\t\treg_w_riv(gspca_dev, 0xe0, 0x0000, 0x0000);\n\t\treg_w_riv(gspca_dev, 0xe0, 0x0000, 0x0001);\t \n\t\tspca504_wait_status(gspca_dev);\n\t\tif (sd->subtype == LogitechClickSmart420)\n\t\t\twrite_vector(gspca_dev,\n\t\t\t\tspca504A_clicksmart420_open_data,\n\t\t\t\tARRAY_SIZE(spca504A_clicksmart420_open_data));\n\t\telse\n\t\t\twrite_vector(gspca_dev, spca504_pccam600_open_data,\n\t\t\t\tARRAY_SIZE(spca504_pccam600_open_data));\n\t\tsetup_qtable(gspca_dev, qtable_creative_pccam);\n\t\tbreak;\n\tdefault:\n \n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Opening SPCA504\\n\");\n\t\tif (sd->subtype == AiptekMiniPenCam13) {\n\t\t\tspca504_read_info(gspca_dev);\n\n\t\t\t \n\t\t\tspca504A_acknowledged_command(gspca_dev, 0x24,\n\t\t\t\t\t\t\t8, 3, 0x9e, 1);\n\t\t\t \n\t\t\tspca504A_acknowledged_command(gspca_dev, 0x24,\n\t\t\t\t\t\t\t8, 3, 0x9e, 0);\n\n\t\t\tspca504A_acknowledged_command(gspca_dev, 0x24,\n\t\t\t\t\t\t\t0, 0, 0x9d, 1);\n\t\t\t \n\t\t\t \n\t\t\tspca504A_acknowledged_command(gspca_dev, 0x08,\n\t\t\t\t\t\t\t6, 0, 0x86, 1);\n \n \n \n \n\t\t\treg_w_riv(gspca_dev, 0x00, 0x270c, 0x05);\n\t\t\t\t\t\t\t \n\t\t\treg_w_riv(gspca_dev, 0x00, 0x2310, 0x05);\n\t\t\tspca504A_acknowledged_command(gspca_dev, 0x01,\n\t\t\t\t\t\t\t0x0f, 0, 0xff, 0);\n\t\t}\n\t\t \n\t\treg_w_riv(gspca_dev, 0, 0x2000, 0);\n\t\treg_w_riv(gspca_dev, 0, 0x2883, 1);\n\t\tsetup_qtable(gspca_dev, qtable_spca504_default);\n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint enable;\n\n\t \n\tjpeg_define(sd->jpeg_hdr, gspca_dev->pixfmt.height,\n\t\t\tgspca_dev->pixfmt.width,\n\t\t\t0x22);\t\t \n\tjpeg_set_qual(sd->jpeg_hdr, QUALITY);\n\n\tif (sd->bridge == BRIDGE_SPCA504B)\n\t\tspca504B_setQtable(gspca_dev);\n\tspca504B_SetSizeType(gspca_dev);\n\tswitch (sd->bridge) {\n\tdefault:\n \n \n \n\t\tswitch (sd->subtype) {\n\t\tcase MegapixV4:\n\t\tcase LogitechClickSmart820:\n\t\tcase MegaImageVI:\n\t\t\treg_w_riv(gspca_dev, 0xf0, 0, 0);\n\t\t\tspca504B_WaitCmdStatus(gspca_dev);\n\t\t\treg_w_riv(gspca_dev, 0xf0, 4, 0);\n\t\t\tspca504B_WaitCmdStatus(gspca_dev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treg_w_riv(gspca_dev, 0x31, 0x0004, 0x00);\n\t\t\tspca504B_WaitCmdStatus(gspca_dev);\n\t\t\tspca504B_PollingDataReady(gspca_dev);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BRIDGE_SPCA504:\n\t\tif (sd->subtype == AiptekMiniPenCam13) {\n\t\t\tspca504_read_info(gspca_dev);\n\n\t\t\t \n\t\t\tspca504A_acknowledged_command(gspca_dev, 0x24,\n\t\t\t\t\t\t\t8, 3, 0x9e, 1);\n\t\t\t \n\t\t\tspca504A_acknowledged_command(gspca_dev, 0x24,\n\t\t\t\t\t\t\t8, 3, 0x9e, 0);\n\t\t\tspca504A_acknowledged_command(gspca_dev, 0x24,\n\t\t\t\t\t\t\t0, 0, 0x9d, 1);\n\t\t} else {\n\t\t\tspca504_acknowledged_command(gspca_dev, 0x24, 8, 3);\n\t\t\tspca504_read_info(gspca_dev);\n\t\t\tspca504_acknowledged_command(gspca_dev, 0x24, 8, 3);\n\t\t\tspca504_acknowledged_command(gspca_dev, 0x24, 0, 0);\n\t\t}\n\t\tspca504B_SetSizeType(gspca_dev);\n\t\treg_w_riv(gspca_dev, 0x00, 0x270c, 0x05);\n\t\t\t\t\t\t\t \n\t\treg_w_riv(gspca_dev, 0x00, 0x2310, 0x05);\n\t\tbreak;\n\tcase BRIDGE_SPCA504C:\n\t\tif (sd->subtype == LogitechClickSmart420) {\n\t\t\twrite_vector(gspca_dev,\n\t\t\t\tspca504A_clicksmart420_init_data,\n\t\t\t\tARRAY_SIZE(spca504A_clicksmart420_init_data));\n\t\t} else {\n\t\t\twrite_vector(gspca_dev, spca504_pccam600_init_data,\n\t\t\t\tARRAY_SIZE(spca504_pccam600_init_data));\n\t\t}\n\t\tenable = (sd->autogain ? 0x04 : 0x01);\n\t\treg_w_riv(gspca_dev, 0x0c, 0x0000, enable);\n\t\t\t\t\t\t\t \n\t\treg_w_riv(gspca_dev, 0xb0, 0x0000, enable);\n\t\t\t\t\t\t\t \n\n\t\t \n\t\treg_w_riv(gspca_dev, 0x30, 0x0001, 800);\t \n\t\treg_w_riv(gspca_dev, 0x30, 0x0002, 1600);\n\t\tspca504B_SetSizeType(gspca_dev);\n\t\tbreak;\n\t}\n\tinit_ctl_reg(gspca_dev);\n\treturn gspca_dev->usb_err;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tswitch (sd->bridge) {\n\tdefault:\n \n \n \n\t\treg_w_riv(gspca_dev, 0x31, 0, 0);\n\t\tspca504B_WaitCmdStatus(gspca_dev);\n\t\tspca504B_PollingDataReady(gspca_dev);\n\t\tbreak;\n\tcase BRIDGE_SPCA504:\n\tcase BRIDGE_SPCA504C:\n\t\treg_w_riv(gspca_dev, 0x00, 0x2000, 0x0000);\n\n\t\tif (sd->subtype == AiptekMiniPenCam13) {\n\t\t\t \n \n\t\t\tspca504A_acknowledged_command(gspca_dev, 0x24,\n\t\t\t\t\t\t\t0x00, 0x00, 0x9d, 1);\n\t\t\tspca504A_acknowledged_command(gspca_dev, 0x01,\n\t\t\t\t\t\t\t0x0f, 0x00, 0xff, 1);\n\t\t} else {\n\t\t\tspca504_acknowledged_command(gspca_dev, 0x24, 0, 0);\n\t\t\treg_w_riv(gspca_dev, 0x01, 0x000f, 0x0000);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t \n\t\t\tint len)\t\t\t \n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint i, sof = 0;\n\tstatic u8 ffd9[] = {0xff, 0xd9};\n\n \n\tswitch (sd->bridge) {\n\tcase BRIDGE_SPCA533:\n\t\tif (data[0] == 0xff) {\n\t\t\tif (data[1] != 0x01) {\t \n \n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsof = 1;\n\t\t\tdata += SPCA533_OFFSET_DATA;\n\t\t\tlen -= SPCA533_OFFSET_DATA;\n\t\t} else {\n\t\t\tdata += 1;\n\t\t\tlen -= 1;\n\t\t}\n\t\tbreak;\n\tcase BRIDGE_SPCA536:\n\t\tif (data[0] == 0xff) {\n\t\t\tsof = 1;\n\t\t\tdata += SPCA536_OFFSET_DATA;\n\t\t\tlen -= SPCA536_OFFSET_DATA;\n\t\t} else {\n\t\t\tdata += 2;\n\t\t\tlen -= 2;\n\t\t}\n\t\tbreak;\n\tdefault:\n \n \n\t\tswitch (data[0]) {\n\t\tcase 0xfe:\t\t\t \n\t\t\tsof = 1;\n\t\t\tdata += SPCA50X_OFFSET_DATA;\n\t\t\tlen -= SPCA50X_OFFSET_DATA;\n\t\t\tbreak;\n\t\tcase 0xff:\t\t\t \n \n\t\t\treturn;\n\t\tdefault:\n\t\t\tdata += 1;\n\t\t\tlen -= 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BRIDGE_SPCA504C:\n\t\tswitch (data[0]) {\n\t\tcase 0xfe:\t\t\t \n\t\t\tsof = 1;\n\t\t\tdata += SPCA504_PCCAM600_OFFSET_DATA;\n\t\t\tlen -= SPCA504_PCCAM600_OFFSET_DATA;\n\t\t\tbreak;\n\t\tcase 0xff:\t\t\t \n \n\t\t\treturn;\n\t\tdefault:\n\t\t\tdata += 1;\n\t\t\tlen -= 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tif (sof) {\t\t \n\t\tgspca_frame_add(gspca_dev, LAST_PACKET,\n\t\t\t\tffd9, 2);\n\n\t\t \n\t\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\t\tsd->jpeg_hdr, JPEG_HDR_SZ);\n\t}\n\n\t \n\ti = 0;\n\tdo {\n\t\tif (data[i] == 0xff) {\n\t\t\tgspca_frame_add(gspca_dev, INTER_PACKET,\n\t\t\t\t\tdata, i + 1);\n\t\t\tlen -= i;\n\t\t\tdata += i;\n\t\t\t*data = 0x00;\n\t\t\ti = 0;\n\t\t}\n\t\ti++;\n\t} while (i < len);\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsetbrightness(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tsetcontrast(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tsetcolors(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\tsd->autogain = ctrl->val;\n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 4);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 255, 1, 0x20);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 255, 1, 0x1a);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\treturn 0;\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.pkt_scan = sd_pkt_scan,\n};\n\n \n#define BS(bridge, subtype) \\\n\t.driver_info = (BRIDGE_ ## bridge << 8) \\\n\t\t\t| (subtype)\nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x041e, 0x400b), BS(SPCA504C, 0)},\n\t{USB_DEVICE(0x041e, 0x4012), BS(SPCA504C, 0)},\n\t{USB_DEVICE(0x041e, 0x4013), BS(SPCA504C, 0)},\n\t{USB_DEVICE(0x0458, 0x7006), BS(SPCA504B, 0)},\n\t{USB_DEVICE(0x0461, 0x0821), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x046d, 0x0905), BS(SPCA533, LogitechClickSmart820)},\n\t{USB_DEVICE(0x046d, 0x0960), BS(SPCA504C, LogitechClickSmart420)},\n\t{USB_DEVICE(0x0471, 0x0322), BS(SPCA504B, 0)},\n\t{USB_DEVICE(0x04a5, 0x3003), BS(SPCA504B, 0)},\n\t{USB_DEVICE(0x04a5, 0x3008), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x04a5, 0x300a), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x04f1, 0x1001), BS(SPCA504B, 0)},\n\t{USB_DEVICE(0x04fc, 0x500c), BS(SPCA504B, 0)},\n\t{USB_DEVICE(0x04fc, 0x504a), BS(SPCA504, AiptekMiniPenCam13)},\n\t{USB_DEVICE(0x04fc, 0x504b), BS(SPCA504B, 0)},\n\t{USB_DEVICE(0x04fc, 0x5330), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x04fc, 0x5360), BS(SPCA536, 0)},\n\t{USB_DEVICE(0x04fc, 0xffff), BS(SPCA504B, 0)},\n\t{USB_DEVICE(0x052b, 0x1507), BS(SPCA533, MegapixV4)},\n\t{USB_DEVICE(0x052b, 0x1513), BS(SPCA533, MegapixV4)},\n\t{USB_DEVICE(0x052b, 0x1803), BS(SPCA533, MegaImageVI)},\n\t{USB_DEVICE(0x0546, 0x3155), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x0546, 0x3191), BS(SPCA504B, 0)},\n\t{USB_DEVICE(0x0546, 0x3273), BS(SPCA504B, 0)},\n\t{USB_DEVICE(0x055f, 0xc211), BS(SPCA536, 0)},\n\t{USB_DEVICE(0x055f, 0xc230), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x055f, 0xc232), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x055f, 0xc360), BS(SPCA536, 0)},\n\t{USB_DEVICE(0x055f, 0xc420), BS(SPCA504, 0)},\n\t{USB_DEVICE(0x055f, 0xc430), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x055f, 0xc440), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x055f, 0xc520), BS(SPCA504, 0)},\n\t{USB_DEVICE(0x055f, 0xc530), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x055f, 0xc540), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x055f, 0xc630), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x055f, 0xc650), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x05da, 0x1018), BS(SPCA504B, 0)},\n\t{USB_DEVICE(0x06d6, 0x0031), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x06d6, 0x0041), BS(SPCA504B, 0)},\n\t{USB_DEVICE(0x0733, 0x1311), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x0733, 0x1314), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x0733, 0x2211), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x0733, 0x2221), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x0733, 0x3261), BS(SPCA536, 0)},\n\t{USB_DEVICE(0x0733, 0x3281), BS(SPCA536, 0)},\n\t{USB_DEVICE(0x08ca, 0x0104), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x08ca, 0x0106), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x08ca, 0x2008), BS(SPCA504B, 0)},\n\t{USB_DEVICE(0x08ca, 0x2010), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x08ca, 0x2016), BS(SPCA504B, 0)},\n\t{USB_DEVICE(0x08ca, 0x2018), BS(SPCA504B, 0)},\n\t{USB_DEVICE(0x08ca, 0x2020), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x08ca, 0x2022), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x08ca, 0x2024), BS(SPCA536, 0)},\n\t{USB_DEVICE(0x08ca, 0x2028), BS(SPCA533, 0)},\n\t{USB_DEVICE(0x08ca, 0x2040), BS(SPCA536, 0)},\n\t{USB_DEVICE(0x08ca, 0x2042), BS(SPCA536, 0)},\n\t{USB_DEVICE(0x08ca, 0x2050), BS(SPCA536, 0)},\n\t{USB_DEVICE(0x08ca, 0x2060), BS(SPCA536, 0)},\n\t{USB_DEVICE(0x0d64, 0x0303), BS(SPCA536, 0)},\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}