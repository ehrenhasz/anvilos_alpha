{
  "module_name": "stk1135.c",
  "hash_id": "01f6ceee9252cf7d74cad550639c606a11a96cb1c8ddf16bb3415575f50b5528",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/stk1135.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"stk1135\"\n\n#include \"gspca.h\"\n#include \"stk1135.h\"\n\nMODULE_AUTHOR(\"Ondrej Zary\");\nMODULE_DESCRIPTION(\"Syntek STK1135 USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t \n\n\tu8 pkt_seq;\n\tu8 sensor_page;\n\n\tbool flip_status;\n\tu8 flip_debounce;\n\n\tstruct v4l2_ctrl *hflip;\n\tstruct v4l2_ctrl *vflip;\n};\n\nstatic const struct v4l2_pix_format stk1135_modes[] = {\n\t \n\t{640, 480, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB},\n};\n\n \nstatic u8 reg_r(struct gspca_dev *gspca_dev, u16 index)\n{\n\tstruct usb_device *dev = gspca_dev->dev;\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn 0;\n\tret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t0x00,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0x00,\n\t\t\tindex,\n\t\t\tgspca_dev->usb_buf, 1,\n\t\t\t500);\n\n\tgspca_dbg(gspca_dev, D_USBI, \"reg_r 0x%x=0x%02x\\n\",\n\t\t  index, gspca_dev->usb_buf[0]);\n\tif (ret < 0) {\n\t\tpr_err(\"reg_r 0x%x err %d\\n\", index, ret);\n\t\tgspca_dev->usb_err = ret;\n\t\treturn 0;\n\t}\n\n\treturn gspca_dev->usb_buf[0];\n}\n\n \nstatic void reg_w(struct gspca_dev *gspca_dev, u16 index, u8 val)\n{\n\tint ret;\n\tstruct usb_device *dev = gspca_dev->dev;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t0x01,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tval,\n\t\t\tindex,\n\t\t\tNULL,\n\t\t\t0,\n\t\t\t500);\n\tgspca_dbg(gspca_dev, D_USBO, \"reg_w 0x%x:=0x%02x\\n\", index, val);\n\tif (ret < 0) {\n\t\tpr_err(\"reg_w 0x%x err %d\\n\", index, ret);\n\t\tgspca_dev->usb_err = ret;\n\t}\n}\n\nstatic void reg_w_mask(struct gspca_dev *gspca_dev, u16 index, u8 val, u8 mask)\n{\n\tval = (reg_r(gspca_dev, index) & ~mask) | (val & mask);\n\treg_w(gspca_dev, index, val);\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id)\n{\n\tgspca_dev->cam.cam_mode = stk1135_modes;\n\tgspca_dev->cam.nmodes = ARRAY_SIZE(stk1135_modes);\n\treturn 0;\n}\n\nstatic int stk1135_serial_wait_ready(struct gspca_dev *gspca_dev)\n{\n\tint i = 0;\n\tu8 val;\n\n\tdo {\n\t\tval = reg_r(gspca_dev, STK1135_REG_SICTL + 1);\n\t\tif (i++ > 500) {  \n\t\t\tpr_err(\"serial bus timeout: status=0x%02x\\n\", val);\n\t\t\treturn -1;\n\t\t}\n\t \n\t} while ((val & 0x10) || !(val & 0x05));\n\n\treturn 0;\n}\n\nstatic u8 sensor_read_8(struct gspca_dev *gspca_dev, u8 addr)\n{\n\treg_w(gspca_dev, STK1135_REG_SBUSR, addr);\n\t \n\treg_w(gspca_dev, STK1135_REG_SICTL, 0x20);\n\t \n\tif (stk1135_serial_wait_ready(gspca_dev)) {\n\t\tpr_err(\"Sensor read failed\\n\");\n\t\treturn 0;\n\t}\n\n\treturn reg_r(gspca_dev, STK1135_REG_SBUSR + 1);\n}\n\nstatic u16 sensor_read_16(struct gspca_dev *gspca_dev, u8 addr)\n{\n\treturn (sensor_read_8(gspca_dev, addr) << 8) |\n\t\tsensor_read_8(gspca_dev, 0xf1);\n}\n\nstatic void sensor_write_8(struct gspca_dev *gspca_dev, u8 addr, u8 data)\n{\n\t \n\treg_w(gspca_dev, STK1135_REG_SBUSW, addr);\n\treg_w(gspca_dev, STK1135_REG_SBUSW + 1, data);\n\t \n\treg_w(gspca_dev, STK1135_REG_SICTL, 0x01);\n\t \n\tif (stk1135_serial_wait_ready(gspca_dev)) {\n\t\tpr_err(\"Sensor write failed\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void sensor_write_16(struct gspca_dev *gspca_dev, u8 addr, u16 data)\n{\n\tsensor_write_8(gspca_dev, addr, data >> 8);\n\tsensor_write_8(gspca_dev, 0xf1, data & 0xff);\n}\n\nstatic void sensor_set_page(struct gspca_dev *gspca_dev, u8 page)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (page != sd->sensor_page) {\n\t\tsensor_write_16(gspca_dev, 0xf0, page);\n\t\tsd->sensor_page = page;\n\t}\n}\n\nstatic u16 sensor_read(struct gspca_dev *gspca_dev, u16 reg)\n{\n\tsensor_set_page(gspca_dev, reg >> 8);\n\treturn sensor_read_16(gspca_dev, reg & 0xff);\n}\n\nstatic void sensor_write(struct gspca_dev *gspca_dev, u16 reg, u16 val)\n{\n\tsensor_set_page(gspca_dev, reg >> 8);\n\tsensor_write_16(gspca_dev, reg & 0xff, val);\n}\n\nstatic void sensor_write_mask(struct gspca_dev *gspca_dev,\n\t\t\tu16 reg, u16 val, u16 mask)\n{\n\tval = (sensor_read(gspca_dev, reg) & ~mask) | (val & mask);\n\tsensor_write(gspca_dev, reg, val);\n}\n\nstruct sensor_val {\n\tu16 reg;\n\tu16 val;\n};\n\n \nstatic void stk1135_configure_mt9m112(struct gspca_dev *gspca_dev)\n{\n\tstatic const struct sensor_val cfg[] = {\n\t\t \n\t\t{ 0x00d, 0x000b }, { 0x00d, 0x0008 }, { 0x035, 0x0022 },\n\t\t \n\t\t{ 0x106, 0x700e },\n\n\t\t{ 0x2dd, 0x18e0 },  \n\n\t\t \n\t\t{ 0x21f, 0x0180 },  \n\t\t{ 0x220, 0xc814 }, { 0x221, 0x8080 },  \n\t\t{ 0x222, 0xa078 }, { 0x223, 0xa078 },  \n\t\t{ 0x224, 0x5f20 }, { 0x228, 0xea02 },  \n\t\t{ 0x229, 0x867a },  \n\n\t\t \n\t\t \n\t\t{ 0x25e, 0x594c }, { 0x25f, 0x4d51 }, { 0x260, 0x0002 },\n\t\t \n\t\t{ 0x2ef, 0x0008 }, { 0x2f2, 0x0000 },\n\t\t \n\t\t{ 0x202, 0x00ee }, { 0x203, 0x3923 }, { 0x204, 0x0724 },\n\t\t \n\t\t{ 0x209, 0x00cd }, { 0x20a, 0x0093 }, { 0x20b, 0x0004 }, \n\t\t{ 0x20c, 0x005c }, { 0x20d, 0x00d9 }, { 0x20e, 0x0053 }, \n\t\t{ 0x20f, 0x0008 }, { 0x210, 0x0091 }, { 0x211, 0x00cf }, \n\t\t{ 0x215, 0x0000 },  \n\t\t \n\t\t{ 0x216, 0x0000 }, { 0x217, 0x0000 }, { 0x218, 0x0000 }, \n\t\t{ 0x219, 0x0000 }, { 0x21a, 0x0000 }, { 0x21b, 0x0000 }, \n\t\t{ 0x21c, 0x0000 }, { 0x21d, 0x0000 }, { 0x21e, 0x0000 }, \n\t\t \n\t\t{ 0x106, 0xf00e }, { 0x106, 0x700e },\n\n\t\t \n\t\t{ 0x180, 0x0007 },  \n\t\t \n\t\t{ 0x181, 0xde13 }, { 0x182, 0xebe2 }, { 0x183, 0x00f6 },  \n\t\t{ 0x184, 0xe114 }, { 0x185, 0xeadd }, { 0x186, 0xfdf6 },  \n\t\t{ 0x187, 0xe511 }, { 0x188, 0xede6 }, { 0x189, 0xfbf7 },  \n\t\t \n\t\t{ 0x18a, 0xd613 }, { 0x18b, 0xedec },  \n\t\t{ 0x18c, 0xf9f2 }, { 0x18d, 0x0000 },  \n\t\t{ 0x18e, 0xd815 }, { 0x18f, 0xe9ea },  \n\t\t{ 0x190, 0xf9f1 }, { 0x191, 0x0002 },  \n\t\t{ 0x192, 0xde10 }, { 0x193, 0xefef },  \n\t\t{ 0x194, 0xfbf4 }, { 0x195, 0x0002 },  \n\t\t \n\t\t{ 0x1b6, 0x0e06 }, { 0x1b7, 0x2713 },  \n\t\t{ 0x1b8, 0x1106 }, { 0x1b9, 0x2713 },  \n\t\t{ 0x1ba, 0x0c03 }, { 0x1bb, 0x2a0f },  \n\t\t \n\t\t{ 0x1bc, 0x1208 }, { 0x1bd, 0x1a16 }, { 0x1be, 0x0022 },  \n\t\t{ 0x1bf, 0x150a }, { 0x1c0, 0x1c1a }, { 0x1c1, 0x002d },  \n\t\t{ 0x1c2, 0x1109 }, { 0x1c3, 0x1414 }, { 0x1c4, 0x002a },  \n\t\t{ 0x106, 0x740e },  \n\n\t\t \n\t\t{ 0x153, 0x0b03 }, { 0x154, 0x4722 }, { 0x155, 0xac82 },\n\t\t{ 0x156, 0xdac7 }, { 0x157, 0xf5e9 }, { 0x158, 0xff00 },\n\t\t \n\t\t{ 0x1dc, 0x0b03 }, { 0x1dd, 0x4722 }, { 0x1de, 0xac82 },\n\t\t{ 0x1df, 0xdac7 }, { 0x1e0, 0xf5e9 }, { 0x1e1, 0xff00 },\n\n\t\t \n\t\t{ 0x13a, 0x4300 }, { 0x19b, 0x4300 },  \n\t\t{ 0x108, 0x0180 },  \n\n\t\t{ 0x22f, 0xd100 }, { 0x29c, 0xd100 },  \n\n\t\t \n\t\t{ 0x2d2, 0x0000 }, { 0x2cc, 0x0004 }, { 0x2cb, 0x0001 },\n\n\t\t{ 0x22e, 0x0c3c }, { 0x267, 0x1010 },  \n\n\t\t \n\t\t{ 0x065, 0xa000 },  \n\t\t{ 0x066, 0x2003 }, { 0x067, 0x0501 },  \n\t\t{ 0x065, 0x2000 },  \n\n\t\t{ 0x005, 0x01b8 }, { 0x007, 0x00d8 },  \n\n\t\t \n\t\t{ 0x239, 0x06c0 }, { 0x23b, 0x040e },  \n\t\t{ 0x23a, 0x06c0 }, { 0x23c, 0x0564 },  \n\t\t \n\t\t{ 0x257, 0x0208 }, { 0x258, 0x0271 },  \n\t\t{ 0x259, 0x0209 }, { 0x25a, 0x0271 },  \n\n\t\t{ 0x25c, 0x120d }, { 0x25d, 0x1712 },  \n\t\t{ 0x264, 0x5e1c },  \n\t\t \n\t\t{ 0x25b, 0x0003 }, { 0x236, 0x7810 }, { 0x237, 0x8304 },\n\n\t\t{ 0x008, 0x0021 },  \n\t};\n\tint i;\n\tu16 width, height;\n\n\tfor (i = 0; i < ARRAY_SIZE(cfg); i++)\n\t\tsensor_write(gspca_dev, cfg[i].reg, cfg[i].val);\n\n\t \n\twidth = gspca_dev->pixfmt.width;\n\theight = gspca_dev->pixfmt.height;\n\tif (width <= 640 && height <= 512) {  \n\t\tsensor_write(gspca_dev, 0x1a7, width);\n\t\tsensor_write(gspca_dev, 0x1aa, height);\n\t\t \n\t\tsensor_write(gspca_dev, 0x0c8, 0x0000);\n\t\t \n\t\tsensor_write(gspca_dev, 0x2c8, 0x0000);\n\t} else {  \n\t\tsensor_write(gspca_dev, 0x1a1, width);\n\t\tsensor_write(gspca_dev, 0x1a4, height);\n\t\t \n\t\tsensor_write(gspca_dev, 0x0c8, 0x0008);\n\t\t \n\t\tsensor_write(gspca_dev, 0x2c8, 0x040b);\n\t}\n}\n\nstatic void stk1135_configure_clock(struct gspca_dev *gspca_dev)\n{\n\t \n\treg_w(gspca_dev, STK1135_REG_TMGEN, 0x12);\n\t \n\t \n\treg_w(gspca_dev, STK1135_REG_TCP1 + 0, 0x41);\n\treg_w(gspca_dev, STK1135_REG_TCP1 + 1, 0x00);\n\treg_w(gspca_dev, STK1135_REG_TCP1 + 2, 0x00);\n\treg_w(gspca_dev, STK1135_REG_TCP1 + 3, 0x00);\n\n\t \n\treg_w(gspca_dev, STK1135_REG_SENSO + 0, 0x10);\n\t \n\treg_w(gspca_dev, STK1135_REG_SENSO + 1, 0x00);\n\t \n\treg_w(gspca_dev, STK1135_REG_SENSO + 3, 0x07);\n\t \n\treg_w(gspca_dev, STK1135_REG_PLLFD, 0x06);\n\t \n\treg_w(gspca_dev, STK1135_REG_TMGEN, 0x80);\n\t \n\treg_w(gspca_dev, STK1135_REG_SENSO + 2, 0x04);\n\n\t \n\treg_w(gspca_dev, STK1135_REG_SICTL + 2, 0x1f);\n\n\t \n\tudelay(1000);\n}\n\nstatic void stk1135_camera_disable(struct gspca_dev *gspca_dev)\n{\n\t \n\treg_w(gspca_dev, STK1135_REG_CIEPO + 2, 0x00);\n\treg_w(gspca_dev, STK1135_REG_CIEPO + 3, 0x00);\n\t \n\treg_w_mask(gspca_dev, STK1135_REG_SCTRL, 0x00, 0x80);\n\n\t \n\tsensor_write_mask(gspca_dev, 0x00d, 0x0004, 0x000c);\n\n\t \n\treg_w_mask(gspca_dev, STK1135_REG_SENSO + 2, 0x00, 0x01);\n\t \n\treg_w(gspca_dev, STK1135_REG_TMGEN, 0x00);\n\t \n\treg_w(gspca_dev, STK1135_REG_SENSO + 1, 0x20);\n\t \n\treg_w(gspca_dev, STK1135_REG_SENSO, 0x00);\n\n\t \n\treg_w(gspca_dev, STK1135_REG_GCTRL, 0x49);\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\tu16 sensor_id;\n\tchar *sensor_name;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t \n\treg_w(gspca_dev, STK1135_REG_GCTRL + 2, 0x78);\n\t \n\treg_w(gspca_dev, STK1135_REG_GCTRL, (1 << 5));\n\t \n\treg_w(gspca_dev, STK1135_REG_GCTRL + 3, 0x80);\n\t \n\treg_w(gspca_dev, STK1135_REG_ICTRL + 1, 0x00);\n\treg_w(gspca_dev, STK1135_REG_ICTRL + 3, 0x03);\n\t \n\treg_w(gspca_dev, STK1135_REG_RMCTL + 1, 0x00);\n\treg_w(gspca_dev, STK1135_REG_RMCTL + 3, 0x02);\n\n\t \n\treg_w(gspca_dev, STK1135_REG_SICTL, 0x80);\n\treg_w(gspca_dev, STK1135_REG_SICTL, 0x00);\n\t \n\treg_w(gspca_dev, STK1135_REG_SICTL + 3, 0xba);\n\t \n\treg_w(gspca_dev, STK1135_REG_ASIC + 3, 0x00);\n\n\tstk1135_configure_clock(gspca_dev);\n\n\t \n\tsd->sensor_page = 0xff;\n\tsensor_id = sensor_read(gspca_dev, 0x000);\n\n\tswitch (sensor_id) {\n\tcase 0x148c:\n\t\tsensor_name = \"MT9M112\";\n\t\tbreak;\n\tdefault:\n\t\tsensor_name = \"unknown\";\n\t}\n\tpr_info(\"Detected sensor type %s (0x%x)\\n\", sensor_name, sensor_id);\n\n\tstk1135_camera_disable(gspca_dev);\n\n\treturn gspca_dev->usb_err;\n}\n\n \nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu16 width, height;\n\n\t \n\treg_w(gspca_dev, STK1135_REG_GCTRL, (1 << 5));\n\n\tstk1135_configure_clock(gspca_dev);\n\n\t \n\treg_w(gspca_dev, STK1135_REG_CISPO + 0, 0x00);\n\treg_w(gspca_dev, STK1135_REG_CISPO + 1, 0x00);\n\treg_w(gspca_dev, STK1135_REG_CISPO + 2, 0x00);\n\treg_w(gspca_dev, STK1135_REG_CISPO + 3, 0x00);\n\n\t \n\twidth = gspca_dev->pixfmt.width;\n\theight = gspca_dev->pixfmt.height;\n\treg_w(gspca_dev, STK1135_REG_CIEPO + 0, width & 0xff);\n\treg_w(gspca_dev, STK1135_REG_CIEPO + 1, width >> 8);\n\treg_w(gspca_dev, STK1135_REG_CIEPO + 2, height & 0xff);\n\treg_w(gspca_dev, STK1135_REG_CIEPO + 3, height >> 8);\n\n\t \n\treg_w(gspca_dev, STK1135_REG_SCTRL, 0x20);\n\n\tstk1135_configure_mt9m112(gspca_dev);\n\n\t \n\treg_w_mask(gspca_dev, STK1135_REG_SCTRL, 0x80, 0x80);\n\n\tif (gspca_dev->usb_err >= 0)\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"camera started alt: 0x%02x\\n\",\n\t\t\t  gspca_dev->alt);\n\n\tsd->pkt_seq = 0;\n\n\treturn gspca_dev->usb_err;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_device *dev = gspca_dev->dev;\n\n\tusb_set_interface(dev, gspca_dev->iface, 0);\n\n\tstk1135_camera_disable(gspca_dev);\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"camera stopped\\n\");\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t \n\t\t\tint len)\t\t\t \n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint skip = sizeof(struct stk1135_pkt_header);\n\tbool flip;\n\tenum gspca_packet_type pkt_type = INTER_PACKET;\n\tstruct stk1135_pkt_header *hdr = (void *)data;\n\tu8 seq;\n\n\tif (len < 4) {\n\t\tgspca_dbg(gspca_dev, D_PACK, \"received short packet (less than 4 bytes)\\n\");\n\t\treturn;\n\t}\n\n\t \n\tflip = !(le16_to_cpu(hdr->gpio) & (1 << 8));\n\t \n\tif (sd->flip_status != flip)\n\t\tsd->flip_debounce++;\n\telse\n\t\tsd->flip_debounce = 0;\n\n\t \n\tif (!(hdr->flags & STK1135_HDR_FRAME_START)) {\n\t\tseq = hdr->seq & STK1135_HDR_SEQ_MASK;\n\t\tif (seq != sd->pkt_seq) {\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"received out-of-sequence packet\\n\");\n\t\t\t \n\t\t\tsd->pkt_seq = seq;\n\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\treturn;\n\t\t}\n\t}\n\tsd->pkt_seq++;\n\tif (sd->pkt_seq > STK1135_HDR_SEQ_MASK)\n\t\tsd->pkt_seq = 0;\n\n\tif (len == sizeof(struct stk1135_pkt_header))\n\t\treturn;\n\n\tif (hdr->flags & STK1135_HDR_FRAME_START) {  \n\t\tskip = 8;\t \n\t\tgspca_frame_add(gspca_dev, LAST_PACKET, data, 0);\n\t\tpkt_type = FIRST_PACKET;\n\t}\n\tgspca_frame_add(gspca_dev, pkt_type, data + skip, len - skip);\n}\n\nstatic void sethflip(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->flip_status)\n\t\tval = !val;\n\tsensor_write_mask(gspca_dev, 0x020, val ? 0x0002 : 0x0000 , 0x0002);\n}\n\nstatic void setvflip(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->flip_status)\n\t\tval = !val;\n\tsensor_write_mask(gspca_dev, 0x020, val ? 0x0001 : 0x0000 , 0x0001);\n}\n\nstatic void stk1135_dq_callback(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->flip_debounce > 100) {\n\t\tsd->flip_status = !sd->flip_status;\n\t\tsethflip(gspca_dev, v4l2_ctrl_g_ctrl(sd->hflip));\n\t\tsetvflip(gspca_dev, v4l2_ctrl_g_ctrl(sd->vflip));\n\t}\n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\n\tgspca_dev->usb_err = 0;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_HFLIP:\n\t\tsethflip(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tsetvflip(gspca_dev, ctrl->val);\n\t\tbreak;\n\t}\n\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 2);\n\tsd->hflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\tsd->vflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\treturn 0;\n}\n\nstatic void stk1135_try_fmt(struct gspca_dev *gspca_dev, struct v4l2_format *fmt)\n{\n\tfmt->fmt.pix.width = clamp(fmt->fmt.pix.width, 32U, 1280U);\n\tfmt->fmt.pix.height = clamp(fmt->fmt.pix.height, 32U, 1024U);\n\t \n\tfmt->fmt.pix.width += (fmt->fmt.pix.width & 1);\n\tfmt->fmt.pix.height += (fmt->fmt.pix.height & 1);\n\n\tfmt->fmt.pix.bytesperline = fmt->fmt.pix.width;\n\tfmt->fmt.pix.sizeimage = fmt->fmt.pix.width * fmt->fmt.pix.height;\n}\n\nstatic int stk1135_enum_framesizes(struct gspca_dev *gspca_dev,\n\t\t\tstruct v4l2_frmsizeenum *fsize)\n{\n\tif (fsize->index != 0 || fsize->pixel_format != V4L2_PIX_FMT_SBGGR8)\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\tfsize->stepwise.min_width = 32;\n\tfsize->stepwise.min_height = 32;\n\tfsize->stepwise.max_width = 1280;\n\tfsize->stepwise.max_height = 1024;\n\tfsize->stepwise.step_width = 2;\n\tfsize->stepwise.step_height = 2;\n\n\treturn 0;\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.pkt_scan = sd_pkt_scan,\n\t.dq_callback = stk1135_dq_callback,\n\t.try_fmt = stk1135_try_fmt,\n\t.enum_framesizes = stk1135_enum_framesizes,\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x174f, 0x6a31)},\t \n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}