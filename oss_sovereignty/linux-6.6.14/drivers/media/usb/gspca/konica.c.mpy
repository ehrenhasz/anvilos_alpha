{
  "module_name": "konica.c",
  "hash_id": "25c69baabcae606507f055ca4337109b11bace05df23760f0c0615c7bf1ce951",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/konica.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"konica\"\n\n#include <linux/input.h>\n#include \"gspca.h\"\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_DESCRIPTION(\"Konica chipset USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define WHITEBAL_REG   0x01\n#define BRIGHTNESS_REG 0x02\n#define SHARPNESS_REG  0x03\n#define CONTRAST_REG   0x04\n#define SATURATION_REG 0x05\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t \n\tstruct urb *last_data_urb;\n\tu8 snapshot_pressed;\n};\n\n\n \nstatic const struct v4l2_pix_format vga_mode[] = {\n\t{160, 120, V4L2_PIX_FMT_KONICA420, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 160 * 136 * 3 / 2 + 960,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0x0a},\n\t{176, 144, V4L2_PIX_FMT_KONICA420, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 176 * 144 * 3 / 2 + 960,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0x04},\n\t{320, 240, V4L2_PIX_FMT_KONICA420, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3 / 2 + 960,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0x05},\n};\n\nstatic void sd_isoc_irq(struct urb *urb);\n\nstatic void reg_w(struct gspca_dev *gspca_dev, u16 value, u16 index)\n{\n\tstruct usb_device *dev = gspca_dev->dev;\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t0x02,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tvalue,\n\t\t\tindex,\n\t\t\tNULL,\n\t\t\t0,\n\t\t\t1000);\n\tif (ret < 0) {\n\t\tpr_err(\"reg_w err writing %02x to %02x: %d\\n\",\n\t\t       value, index, ret);\n\t\tgspca_dev->usb_err = ret;\n\t}\n}\n\nstatic void reg_r(struct gspca_dev *gspca_dev, u16 value, u16 index)\n{\n\tstruct usb_device *dev = gspca_dev->dev;\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t0x03,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tvalue,\n\t\t\tindex,\n\t\t\tgspca_dev->usb_buf,\n\t\t\t2,\n\t\t\t1000);\n\tif (ret < 0) {\n\t\tpr_err(\"reg_r err %d\\n\", ret);\n\t\tgspca_dev->usb_err = ret;\n\t\t \n\t\tmemset(gspca_dev->usb_buf, 0, 2);\n\t}\n}\n\nstatic void konica_stream_on(struct gspca_dev *gspca_dev)\n{\n\treg_w(gspca_dev, 1, 0x0b);\n}\n\nstatic void konica_stream_off(struct gspca_dev *gspca_dev)\n{\n\treg_w(gspca_dev, 0, 0x0b);\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id)\n{\n\tgspca_dev->cam.cam_mode = vga_mode;\n\tgspca_dev->cam.nmodes = ARRAY_SIZE(vga_mode);\n\tgspca_dev->cam.no_urb_create = 1;\n\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\tint i;\n\n\t \n\tmsleep(6000);\n\tfor (i = 0; i < 20; i++) {\n\t\treg_r(gspca_dev, 0, 0x10);\n\t\tif (gspca_dev->usb_buf[0] == 3)\n\t\t\tbreak;\n\t\tmsleep(100);\n\t}\n\treg_w(gspca_dev, 0, 0x0d);\n\n\treturn gspca_dev->usb_err;\n}\n\nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct urb *urb;\n\tint i, n, packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tpr_err(\"Couldn't get altsetting\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (alt->desc.bNumEndpoints < 2)\n\t\treturn -ENODEV;\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\n\tn = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\n\treg_w(gspca_dev, n, 0x08);\n\n\tkonica_stream_on(gspca_dev);\n\n\tif (gspca_dev->usb_err)\n\t\treturn gspca_dev->usb_err;\n\n\t \n#if MAX_NURBS < 4\n#error \"Not enough URBs in the gspca table\"\n#endif\n#define SD_NPKT 32\n\tfor (n = 0; n < 4; n++) {\n\t\ti = n & 1 ? 0 : 1;\n\t\tpacket_size =\n\t\t\tle16_to_cpu(alt->endpoint[i].desc.wMaxPacketSize);\n\t\turb = usb_alloc_urb(SD_NPKT, GFP_KERNEL);\n\t\tif (!urb)\n\t\t\treturn -ENOMEM;\n\t\tgspca_dev->urb[n] = urb;\n\t\turb->transfer_buffer = usb_alloc_coherent(gspca_dev->dev,\n\t\t\t\t\t\tpacket_size * SD_NPKT,\n\t\t\t\t\t\tGFP_KERNEL,\n\t\t\t\t\t\t&urb->transfer_dma);\n\t\tif (urb->transfer_buffer == NULL) {\n\t\t\tpr_err(\"usb_buffer_alloc failed\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\turb->dev = gspca_dev->dev;\n\t\turb->context = gspca_dev;\n\t\turb->transfer_buffer_length = packet_size * SD_NPKT;\n\t\turb->pipe = usb_rcvisocpipe(gspca_dev->dev,\n\t\t\t\t\tn & 1 ? 0x81 : 0x82);\n\t\turb->transfer_flags = URB_ISO_ASAP\n\t\t\t\t\t| URB_NO_TRANSFER_DMA_MAP;\n\t\turb->interval = 1;\n\t\turb->complete = sd_isoc_irq;\n\t\turb->number_of_packets = SD_NPKT;\n\t\tfor (i = 0; i < SD_NPKT; i++) {\n\t\t\turb->iso_frame_desc[i].length = packet_size;\n\t\t\turb->iso_frame_desc[i].offset = packet_size * i;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd __maybe_unused = (struct sd *) gspca_dev;\n\n\tkonica_stream_off(gspca_dev);\n#if IS_ENABLED(CONFIG_INPUT)\n\t \n\tif (sd->snapshot_pressed) {\n\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\n\t\tinput_sync(gspca_dev->input_dev);\n\t\tsd->snapshot_pressed = 0;\n\t}\n#endif\n}\n\n \nstatic void sd_isoc_irq(struct urb *urb)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *) urb->context;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct urb *data_urb, *status_urb;\n\tu8 *data;\n\tint i, st;\n\n\tgspca_dbg(gspca_dev, D_PACK, \"sd isoc irq\\n\");\n\tif (!gspca_dev->streaming)\n\t\treturn;\n\n\tif (urb->status != 0) {\n\t\tif (urb->status == -ESHUTDOWN)\n\t\t\treturn;\t\t \n#ifdef CONFIG_PM\n\t\tif (gspca_dev->frozen)\n\t\t\treturn;\n#endif\n\t\tgspca_err(gspca_dev, \"urb status: %d\\n\", urb->status);\n\t\tst = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (st < 0)\n\t\t\tpr_err(\"resubmit urb error %d\\n\", st);\n\t\treturn;\n\t}\n\n\t \n\tif (urb->transfer_buffer_length > 32) {\n\t\tsd->last_data_urb = urb;\n\t\treturn;\n\t}\n\n\tstatus_urb = urb;\n\tdata_urb   = sd->last_data_urb;\n\tsd->last_data_urb = NULL;\n\n\tif (!data_urb || data_urb->start_frame != status_urb->start_frame) {\n\t\tgspca_err(gspca_dev, \"lost sync on frames\\n\");\n\t\tgoto resubmit;\n\t}\n\n\tif (data_urb->number_of_packets != status_urb->number_of_packets) {\n\t\tgspca_err(gspca_dev, \"no packets does not match, data: %d, status: %d\\n\",\n\t\t\t  data_urb->number_of_packets,\n\t\t\t  status_urb->number_of_packets);\n\t\tgoto resubmit;\n\t}\n\n\tfor (i = 0; i < status_urb->number_of_packets; i++) {\n\t\tif (data_urb->iso_frame_desc[i].status ||\n\t\t    status_urb->iso_frame_desc[i].status) {\n\t\t\tgspca_err(gspca_dev, \"pkt %d data-status %d, status-status %d\\n\",\n\t\t\t\t  i,\n\t\t\t\t  data_urb->iso_frame_desc[i].status,\n\t\t\t\t  status_urb->iso_frame_desc[i].status);\n\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (status_urb->iso_frame_desc[i].actual_length != 1) {\n\t\t\tgspca_err(gspca_dev, \"bad status packet length %d\\n\",\n\t\t\t\t  status_urb->iso_frame_desc[i].actual_length);\n\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\tcontinue;\n\t\t}\n\n\t\tst = *((u8 *)status_urb->transfer_buffer\n\t\t\t\t+ status_urb->iso_frame_desc[i].offset);\n\n\t\tdata = (u8 *)data_urb->transfer_buffer\n\t\t\t\t+ data_urb->iso_frame_desc[i].offset;\n\n\t\t \n\t\tif (st & 0x80) {\n\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\n\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, NULL, 0);\n\t\t} else {\n#if IS_ENABLED(CONFIG_INPUT)\n\t\t\tu8 button_state = st & 0x40 ? 1 : 0;\n\t\t\tif (sd->snapshot_pressed != button_state) {\n\t\t\t\tinput_report_key(gspca_dev->input_dev,\n\t\t\t\t\t\t KEY_CAMERA,\n\t\t\t\t\t\t button_state);\n\t\t\t\tinput_sync(gspca_dev->input_dev);\n\t\t\t\tsd->snapshot_pressed = button_state;\n\t\t\t}\n#endif\n\t\t\tif (st & 0x01)\n\t\t\t\tcontinue;\n\t\t}\n\t\tgspca_frame_add(gspca_dev, INTER_PACKET, data,\n\t\t\t\tdata_urb->iso_frame_desc[i].actual_length);\n\t}\n\nresubmit:\n\tif (data_urb) {\n\t\tst = usb_submit_urb(data_urb, GFP_ATOMIC);\n\t\tif (st < 0)\n\t\t\tgspca_err(gspca_dev, \"usb_submit_urb(data_urb) ret %d\\n\",\n\t\t\t\t  st);\n\t}\n\tst = usb_submit_urb(status_urb, GFP_ATOMIC);\n\tif (st < 0)\n\t\tgspca_err(gspca_dev, \"usb_submit_urb(status_urb) ret %d\\n\", st);\n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\n\tgspca_dev->usb_err = 0;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tkonica_stream_off(gspca_dev);\n\t\treg_w(gspca_dev, ctrl->val, BRIGHTNESS_REG);\n\t\tkonica_stream_on(gspca_dev);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tkonica_stream_off(gspca_dev);\n\t\treg_w(gspca_dev, ctrl->val, CONTRAST_REG);\n\t\tkonica_stream_on(gspca_dev);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tkonica_stream_off(gspca_dev);\n\t\treg_w(gspca_dev, ctrl->val, SATURATION_REG);\n\t\tkonica_stream_on(gspca_dev);\n\t\tbreak;\n\tcase V4L2_CID_WHITE_BALANCE_TEMPERATURE:\n\t\tkonica_stream_off(gspca_dev);\n\t\treg_w(gspca_dev, ctrl->val, WHITEBAL_REG);\n\t\tkonica_stream_on(gspca_dev);\n\t\tbreak;\n\tcase V4L2_CID_SHARPNESS:\n\t\tkonica_stream_off(gspca_dev);\n\t\treg_w(gspca_dev, ctrl->val, SHARPNESS_REG);\n\t\tkonica_stream_on(gspca_dev);\n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 5);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 9, 1, 4);\n\t \n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 9, 1, 4);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 9, 1, 4);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_WHITE_BALANCE_TEMPERATURE,\n\t\t\t0, 33, 1, 25);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_SHARPNESS, 0, 9, 1, 4);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\treturn 0;\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n#if IS_ENABLED(CONFIG_INPUT)\n\t.other_input = 1,\n#endif\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x04c8, 0x0720)},  \n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}