{
  "module_name": "mars.c",
  "hash_id": "135611d6fc660a1653feafa2e7a9dcccb8426ed25d4fb1a0e153fe1e194803c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/mars.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"mars\"\n\n#include \"gspca.h\"\n#include \"jpeg.h\"\n\nMODULE_AUTHOR(\"Michel Xhaard <mxhaard@users.sourceforge.net>\");\nMODULE_DESCRIPTION(\"GSPCA/Mars USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define QUALITY 50\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t \n\n\tstruct v4l2_ctrl *brightness;\n\tstruct v4l2_ctrl *saturation;\n\tstruct v4l2_ctrl *sharpness;\n\tstruct v4l2_ctrl *gamma;\n\tstruct {  \n\t\tstruct v4l2_ctrl *illum_top;\n\t\tstruct v4l2_ctrl *illum_bottom;\n\t};\n\tu8 jpeg_hdr[JPEG_HDR_SZ];\n};\n\n \nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val);\nstatic void setcolors(struct gspca_dev *gspca_dev, s32 val);\nstatic void setgamma(struct gspca_dev *gspca_dev, s32 val);\nstatic void setsharpness(struct gspca_dev *gspca_dev, s32 val);\n\nstatic const struct v4l2_pix_format vga_mode[] = {\n\t{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 2},\n\t{640, 480, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n};\n\nstatic const __u8 mi_data[0x20] = {\n \n\t0x48, 0x22, 0x01, 0x47, 0x10, 0x00, 0x00, 0x00,\n \n\t0x00, 0x01, 0x30, 0x01, 0x30, 0x01, 0x30, 0x01,\n \n\t0x30, 0x00, 0x04, 0x00, 0x06, 0x01, 0xe2, 0x02,\n \n\t0x82, 0x00, 0x20, 0x17, 0x80, 0x08, 0x0c, 0x00\n};\n\n \nstatic void reg_w(struct gspca_dev *gspca_dev,\n\t\t int len)\n{\n\tint alen, ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\n\tret = usb_bulk_msg(gspca_dev->dev,\n\t\t\tusb_sndbulkpipe(gspca_dev->dev, 4),\n\t\t\tgspca_dev->usb_buf,\n\t\t\tlen,\n\t\t\t&alen,\n\t\t\t500);\t \n\tif (ret < 0) {\n\t\tpr_err(\"reg write [%02x] error %d\\n\",\n\t\t       gspca_dev->usb_buf[0], ret);\n\t\tgspca_dev->usb_err = ret;\n\t}\n}\n\nstatic void mi_w(struct gspca_dev *gspca_dev,\n\t\t u8 addr,\n\t\t u8 value)\n{\n\tgspca_dev->usb_buf[0] = 0x1f;\n\tgspca_dev->usb_buf[1] = 0;\t\t\t \n\tgspca_dev->usb_buf[2] = addr;\n\tgspca_dev->usb_buf[3] = value;\n\n\treg_w(gspca_dev, 4);\n}\n\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\n{\n\tgspca_dev->usb_buf[0] = 0x61;\n\tgspca_dev->usb_buf[1] = val;\n\treg_w(gspca_dev, 2);\n}\n\nstatic void setcolors(struct gspca_dev *gspca_dev, s32 val)\n{\n\tgspca_dev->usb_buf[0] = 0x5f;\n\tgspca_dev->usb_buf[1] = val << 3;\n\tgspca_dev->usb_buf[2] = ((val >> 2) & 0xf8) | 0x04;\n\treg_w(gspca_dev, 3);\n}\n\nstatic void setgamma(struct gspca_dev *gspca_dev, s32 val)\n{\n\tgspca_dev->usb_buf[0] = 0x06;\n\tgspca_dev->usb_buf[1] = val * 0x40;\n\treg_w(gspca_dev, 2);\n}\n\nstatic void setsharpness(struct gspca_dev *gspca_dev, s32 val)\n{\n\tgspca_dev->usb_buf[0] = 0x67;\n\tgspca_dev->usb_buf[1] = val * 4 + 3;\n\treg_w(gspca_dev, 2);\n}\n\nstatic void setilluminators(struct gspca_dev *gspca_dev, bool top, bool bottom)\n{\n\t \n\tgspca_dev->usb_buf[0] = 0x22;\n\tif (top)\n\t\tgspca_dev->usb_buf[1] = 0x76;\n\telse if (bottom)\n\t\tgspca_dev->usb_buf[1] = 0x7a;\n\telse\n\t\tgspca_dev->usb_buf[1] = 0x7e;\n\treg_w(gspca_dev, 2);\n}\n\nstatic int mars_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tif (ctrl->id == V4L2_CID_ILLUMINATORS_1) {\n\t\t \n\t\tif (ctrl->is_new && ctrl->val)\n\t\t\tsd->illum_bottom->val = 0;\n\t\tif (sd->illum_bottom->is_new && sd->illum_bottom->val)\n\t\t\tsd->illum_top->val = 0;\n\t}\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsetbrightness(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tsetcolors(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_GAMMA:\n\t\tsetgamma(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_ILLUMINATORS_1:\n\t\tsetilluminators(gspca_dev, sd->illum_top->val,\n\t\t\t\t\t   sd->illum_bottom->val);\n\t\tbreak;\n\tcase V4L2_CID_SHARPNESS:\n\t\tsetsharpness(gspca_dev, ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops mars_ctrl_ops = {\n\t.s_ctrl = mars_s_ctrl,\n};\n\n \nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 6);\n\tsd->brightness = v4l2_ctrl_new_std(hdl, &mars_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 30, 1, 15);\n\tsd->saturation = v4l2_ctrl_new_std(hdl, &mars_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 255, 1, 200);\n\tsd->gamma = v4l2_ctrl_new_std(hdl, &mars_ctrl_ops,\n\t\t\tV4L2_CID_GAMMA, 0, 3, 1, 1);\n\tsd->sharpness = v4l2_ctrl_new_std(hdl, &mars_ctrl_ops,\n\t\t\tV4L2_CID_SHARPNESS, 0, 2, 1, 1);\n\tsd->illum_top = v4l2_ctrl_new_std(hdl, &mars_ctrl_ops,\n\t\t\tV4L2_CID_ILLUMINATORS_1, 0, 1, 1, 0);\n\tsd->illum_top->flags |= V4L2_CTRL_FLAG_UPDATE;\n\tsd->illum_bottom = v4l2_ctrl_new_std(hdl, &mars_ctrl_ops,\n\t\t\tV4L2_CID_ILLUMINATORS_2, 0, 1, 1, 0);\n\tsd->illum_bottom->flags |= V4L2_CTRL_FLAG_UPDATE;\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\tv4l2_ctrl_cluster(2, &sd->illum_top);\n\treturn 0;\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct cam *cam;\n\n\tcam = &gspca_dev->cam;\n\tcam->cam_mode = vga_mode;\n\tcam->nmodes = ARRAY_SIZE(vga_mode);\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\treturn 0;\n}\n\nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 *data;\n\tint i;\n\n\t \n\tjpeg_define(sd->jpeg_hdr, gspca_dev->pixfmt.height,\n\t\t\tgspca_dev->pixfmt.width,\n\t\t\t0x21);\t\t \n\tjpeg_set_qual(sd->jpeg_hdr, QUALITY);\n\n\tdata = gspca_dev->usb_buf;\n\n\tdata[0] = 0x01;\t\t \n\tdata[1] = 0x01;\n\treg_w(gspca_dev, 2);\n\n\t \n\tdata[0] = 0x00;\t\t \n\tdata[1] = 0x0c | 0x01;\t \n\tdata[2] = 0x01;\t\t \n\tdata[3] = gspca_dev->pixfmt.width / 8;\t \n\tdata[4] = gspca_dev->pixfmt.height / 8;\t \n\tdata[5] = 0x30;\t\t \n\tdata[6] = 0x02;\t\t \n\tdata[7] = v4l2_ctrl_g_ctrl(sd->gamma) * 0x40;\t \n\tdata[8] = 0x01;\t\t \n \n \n \n\tdata[9] = 0x52;\t\t \n \n\tdata[10] = 0x18;\n\n\treg_w(gspca_dev, 11);\n\n\tdata[0] = 0x23;\t\t \n\tdata[1] = 0x09;\t\t \n\n\treg_w(gspca_dev, 2);\n\n\tdata[0] = 0x3c;\t\t \n \n \n \n\tdata[1] = 50;\t\t \n\treg_w(gspca_dev, 2);\n\n\t \n\tdata[0] = 0x5e;\t\t \n\tdata[1] = 0;\t\t \n \n\t\t\t\t \n\t\t\t\t \n\tdata[2] = v4l2_ctrl_g_ctrl(sd->saturation) << 3;\n\tdata[3] = ((v4l2_ctrl_g_ctrl(sd->saturation) >> 2) & 0xf8) | 0x04;\n\tdata[4] = v4l2_ctrl_g_ctrl(sd->brightness);  \n\tdata[5] = 0x00;\n\n\treg_w(gspca_dev, 6);\n\n\tdata[0] = 0x67;\n \n\tdata[1] = v4l2_ctrl_g_ctrl(sd->sharpness) * 4 + 3;\n\tdata[2] = 0x14;\n\treg_w(gspca_dev, 3);\n\n\tdata[0] = 0x69;\n\tdata[1] = 0x2f;\n\tdata[2] = 0x28;\n\tdata[3] = 0x42;\n\treg_w(gspca_dev, 4);\n\n\tdata[0] = 0x63;\n\tdata[1] = 0x07;\n\treg_w(gspca_dev, 2);\n \n\n\t \n\tfor (i = 0; i < sizeof mi_data; i++)\n\t\tmi_w(gspca_dev, i + 1, mi_data[i]);\n\n\tdata[0] = 0x00;\n\tdata[1] = 0x4d;\t\t \n\treg_w(gspca_dev, 2);\n\n\tsetilluminators(gspca_dev, v4l2_ctrl_g_ctrl(sd->illum_top),\n\t\t\t\t   v4l2_ctrl_g_ctrl(sd->illum_bottom));\n\n\treturn gspca_dev->usb_err;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (v4l2_ctrl_g_ctrl(sd->illum_top) ||\n\t    v4l2_ctrl_g_ctrl(sd->illum_bottom)) {\n\t\tsetilluminators(gspca_dev, false, false);\n\t\tmsleep(20);\n\t}\n\n\tgspca_dev->usb_buf[0] = 1;\n\tgspca_dev->usb_buf[1] = 0;\n\treg_w(gspca_dev, 2);\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t \n\t\t\tint len)\t\t\t \n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint p;\n\n\tif (len < 6) {\n \n\t\treturn;\n\t}\n\tfor (p = 0; p < len - 6; p++) {\n\t\tif (data[0 + p] == 0xff\n\t\t    && data[1 + p] == 0xff\n\t\t    && data[2 + p] == 0x00\n\t\t    && data[3 + p] == 0xff\n\t\t    && data[4 + p] == 0x96) {\n\t\t\tif (data[5 + p] == 0x64\n\t\t\t    || data[5 + p] == 0x65\n\t\t\t    || data[5 + p] == 0x66\n\t\t\t    || data[5 + p] == 0x67) {\n\t\t\t\tgspca_dbg(gspca_dev, D_PACK, \"sof offset: %d len: %d\\n\",\n\t\t\t\t\t  p, len);\n\t\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET,\n\t\t\t\t\t\tdata, p);\n\n\t\t\t\t \n\t\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\t\t\t\tsd->jpeg_hdr, JPEG_HDR_SZ);\n\t\t\t\tdata += p + 16;\n\t\t\t\tlen -= p + 16;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.pkt_scan = sd_pkt_scan,\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x093a, 0x050f)},\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}