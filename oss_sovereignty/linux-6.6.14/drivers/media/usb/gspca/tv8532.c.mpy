{
  "module_name": "tv8532.c",
  "hash_id": "6c98b3523956a3efadfc448e961808e971d4bfc17973722018abc7e489b5b2a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/tv8532.c",
  "human_readable_source": "\n \n#define MODULE_NAME \"tv8532\"\n\n#include \"gspca.h\"\n\nMODULE_AUTHOR(\"Michel Xhaard <mxhaard@users.sourceforge.net>\");\nMODULE_DESCRIPTION(\"TV8532 USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t \n\n\t__u8 packet;\n};\n\nstatic const struct v4l2_pix_format sif_mode[] = {\n\t{176, 144, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 176 * 144,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{352, 288, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352,\n\t\t.sizeimage = 352 * 288,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n};\n\n \n#define R00_PART_CONTROL 0x00\n#define\t\tLATENT_CHANGE\t0x80\n#define\t\tEXPO_CHANGE\t0x04\n#define R01_TIMING_CONTROL_LOW 0x01\n#define\t\tCMD_EEprom_Open 0x30\n#define\t\tCMD_EEprom_Close 0x29\n#define R03_TABLE_ADDR 0x03\n#define R04_WTRAM_DATA_L 0x04\n#define R05_WTRAM_DATA_M 0x05\n#define R06_WTRAM_DATA_H 0x06\n#define R07_TABLE_LEN\t0x07\n#define R08_RAM_WRITE_ACTION 0x08\n#define R0C_AD_WIDTHL\t0x0c\n#define R0D_AD_WIDTHH\t0x0d\n#define R0E_AD_HEIGHTL\t0x0e\n#define R0F_AD_HEIGHTH\t0x0f\n#define R10_AD_COL_BEGINL 0x10\n#define R11_AD_COL_BEGINH 0x11\n#define\t\tMIRROR\t\t0x04\t \n#define R14_AD_ROW_BEGINL 0x14\n#define R15_AD_ROWBEGINH  0x15\n#define R1C_AD_EXPOSE_TIMEL 0x1c\n#define R20_GAIN_G1L\t0x20\n#define R21_GAIN_G1H\t0x21\n#define R22_GAIN_RL\t0x22\n#define R23_GAIN_RH\t0x23\n#define R24_GAIN_BL\t0x24\n#define R25_GAIN_BH\t0x25\n#define R26_GAIN_G2L\t0x26\n#define R27_GAIN_G2H\t0x27\n#define R28_QUANT\t0x28\n#define R29_LINE\t0x29\n#define R2C_POLARITY\t0x2c\n#define R2D_POINT\t0x2d\n#define R2E_POINTH\t0x2e\n#define R2F_POINTB\t0x2f\n#define R30_POINTBH\t0x30\n#define R31_UPD\t\t0x31\n#define R2A_HIGH_BUDGET 0x2a\n#define R2B_LOW_BUDGET\t0x2b\n#define R34_VID\t\t0x34\n#define R35_VIDH\t0x35\n#define R36_PID\t\t0x36\n#define R37_PIDH\t0x37\n#define R39_Test1\t0x39\t\t \n#define R3B_Test3\t0x3b\t\t \n#define R83_AD_IDH\t0x83\n#define R91_AD_SLOPEREG 0x91\n#define R94_AD_BITCONTROL 0x94\n\nstatic const u8 eeprom_data[][3] = {\n \n\t{0x01, 0x00, 0x01},\n\t{0x01, 0x80, 0x11},\n\t{0x05, 0x00, 0x14},\n\t{0x05, 0x00, 0x1c},\n\t{0x0d, 0x00, 0x1e},\n\t{0x05, 0x00, 0x1f},\n\t{0x05, 0x05, 0x19},\n\t{0x05, 0x01, 0x1b},\n\t{0x05, 0x09, 0x1e},\n\t{0x0d, 0x89, 0x2e},\n\t{0x05, 0x89, 0x2f},\n\t{0x05, 0x0d, 0xd9},\n\t{0x05, 0x09, 0xf1},\n};\n\n\n \nstatic void reg_w1(struct gspca_dev *gspca_dev,\n\t\t  __u16 index, __u8 value)\n{\n\tgspca_dev->usb_buf[0] = value;\n\tusb_control_msg(gspca_dev->dev,\n\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t0x02,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0,\t \n\t\t\tindex, gspca_dev->usb_buf, 1, 500);\n}\n\n \nstatic void reg_w2(struct gspca_dev *gspca_dev,\n\t\t  u16 index, u16 value)\n{\n\tgspca_dev->usb_buf[0] = value;\n\tgspca_dev->usb_buf[1] = value >> 8;\n\tusb_control_msg(gspca_dev->dev,\n\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t0x02,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0,\t \n\t\t\tindex, gspca_dev->usb_buf, 2, 500);\n}\n\nstatic void tv_8532WriteEEprom(struct gspca_dev *gspca_dev)\n{\n\tint i;\n\n\treg_w1(gspca_dev, R01_TIMING_CONTROL_LOW, CMD_EEprom_Open);\n\tfor (i = 0; i < ARRAY_SIZE(eeprom_data); i++) {\n\t\treg_w1(gspca_dev, R03_TABLE_ADDR, i);\n\t\treg_w1(gspca_dev, R04_WTRAM_DATA_L, eeprom_data[i][2]);\n\t\treg_w1(gspca_dev, R05_WTRAM_DATA_M, eeprom_data[i][1]);\n\t\treg_w1(gspca_dev, R06_WTRAM_DATA_H, eeprom_data[i][0]);\n\t\treg_w1(gspca_dev, R08_RAM_WRITE_ACTION, 0);\n\t}\n\treg_w1(gspca_dev, R07_TABLE_LEN, i);\n\treg_w1(gspca_dev, R01_TIMING_CONTROL_LOW, CMD_EEprom_Close);\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct cam *cam;\n\n\tcam = &gspca_dev->cam;\n\tcam->cam_mode = sif_mode;\n\tcam->nmodes = ARRAY_SIZE(sif_mode);\n\n\treturn 0;\n}\n\nstatic void tv_8532_setReg(struct gspca_dev *gspca_dev)\n{\n\treg_w1(gspca_dev, R3B_Test3, 0x0a);\t \n\t \n\treg_w1(gspca_dev, R0E_AD_HEIGHTL, 0x90);\n\treg_w1(gspca_dev, R0F_AD_HEIGHTH, 0x01);\n\treg_w2(gspca_dev, R1C_AD_EXPOSE_TIMEL, 0x018f);\n\treg_w1(gspca_dev, R10_AD_COL_BEGINL, 0x44);\n\t\t\t\t\t\t \n\treg_w1(gspca_dev, R11_AD_COL_BEGINH, 0x00);\n\t\t\t\t\t\t \n\treg_w1(gspca_dev, R14_AD_ROW_BEGINL, 0x0a);\n\n\treg_w1(gspca_dev, R94_AD_BITCONTROL, 0x02);\n\treg_w1(gspca_dev, R91_AD_SLOPEREG, 0x00);\n\treg_w1(gspca_dev, R00_PART_CONTROL, LATENT_CHANGE | EXPO_CHANGE);\n\t\t\t\t\t\t \n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\ttv_8532WriteEEprom(gspca_dev);\n\n\treturn 0;\n}\n\nstatic void setexposure(struct gspca_dev *gspca_dev, s32 val)\n{\n\treg_w2(gspca_dev, R1C_AD_EXPOSE_TIMEL, val);\n\treg_w1(gspca_dev, R00_PART_CONTROL, LATENT_CHANGE | EXPO_CHANGE);\n\t\t\t\t\t\t \n}\n\nstatic void setgain(struct gspca_dev *gspca_dev, s32 val)\n{\n\treg_w2(gspca_dev, R20_GAIN_G1L, val);\n\treg_w2(gspca_dev, R22_GAIN_RL, val);\n\treg_w2(gspca_dev, R24_GAIN_BL, val);\n\treg_w2(gspca_dev, R26_GAIN_G2L, val);\n}\n\n \nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\treg_w1(gspca_dev, R0C_AD_WIDTHL, 0xe8);\t\t \n\treg_w1(gspca_dev, R0D_AD_WIDTHH, 0x03);\n\n\t \n\treg_w1(gspca_dev, R28_QUANT, 0x90);\n\t\t\t\t\t \n\tif (gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv) {\n\t\t \n\t\treg_w1(gspca_dev, R29_LINE, 0x41);\n\t\t\t\t\t \n\t} else {\n\t\t \n\t\treg_w1(gspca_dev, R29_LINE, 0x81);\n\t\t\t\t\t \n\t}\n\t \n\treg_w1(gspca_dev, R2C_POLARITY, 0x10);\t\t \n\treg_w1(gspca_dev, R2D_POINT, 0x14);\n\treg_w1(gspca_dev, R2E_POINTH, 0x01);\n\treg_w1(gspca_dev, R2F_POINTB, 0x12);\n\treg_w1(gspca_dev, R30_POINTBH, 0x01);\n\n\ttv_8532_setReg(gspca_dev);\n\n\t \n\treg_w1(gspca_dev, R31_UPD, 0x01);\t \n\tmsleep(200);\n\treg_w1(gspca_dev, R31_UPD, 0x00);\t \n\n\tgspca_dev->empty_packet = 0;\t\t \n\tsd->packet = 0;\t\t\t\t \n\n\treturn 0;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\treg_w1(gspca_dev, R3B_Test3, 0x0b);\t \n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t \n\t\t\tint len)\t\t\t \n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint packet_type0, packet_type1;\n\n\tpacket_type0 = packet_type1 = INTER_PACKET;\n\tif (gspca_dev->empty_packet) {\n\t\tgspca_dev->empty_packet = 0;\n\t\tsd->packet = gspca_dev->pixfmt.height / 2;\n\t\tpacket_type0 = FIRST_PACKET;\n\t} else if (sd->packet == 0)\n\t\treturn;\t\t\t \n\tsd->packet--;\n\tif (sd->packet == 0)\n\t\tpacket_type1 = LAST_PACKET;\n\n\t \n\tgspca_frame_add(gspca_dev, packet_type0,\n\t\t\tdata + 2, gspca_dev->pixfmt.width);\n\tgspca_frame_add(gspca_dev, packet_type1,\n\t\t\tdata + gspca_dev->pixfmt.width + 5,\n\t\t\tgspca_dev->pixfmt.width);\n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\n\tgspca_dev->usb_err = 0;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE:\n\t\tsetexposure(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_GAIN:\n\t\tsetgain(gspca_dev, ctrl->val);\n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 2);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE, 0, 0x18f, 1, 0x18f);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, 0, 0x7ff, 1, 0x100);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\treturn 0;\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.pkt_scan = sd_pkt_scan,\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x046d, 0x0920)},\n\t{USB_DEVICE(0x046d, 0x0921)},\n\t{USB_DEVICE(0x0545, 0x808b)},\n\t{USB_DEVICE(0x0545, 0x8333)},\n\t{USB_DEVICE(0x0923, 0x010f)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t    const struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t       THIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}