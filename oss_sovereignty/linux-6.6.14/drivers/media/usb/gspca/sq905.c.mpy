{
  "module_name": "sq905.c",
  "hash_id": "b6703a1118abfad8c18b544d46947e03a93f49e2aaf8a54cd36170030a119c27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/sq905.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"sq905\"\n\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include \"gspca.h\"\n\nMODULE_AUTHOR(\"Adam Baker <linux@baker-net.org.uk>, Theodore Kilgore <kilgota@auburn.edu>\");\nMODULE_DESCRIPTION(\"GSPCA/SQ905 USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define SQ905_CMD_TIMEOUT 500\n#define SQ905_DATA_TIMEOUT 1000\n\n \n#define SQ905_MAX_TRANSFER 0x8000\n#define FRAME_HEADER_LEN 64\n\n \n\n \n\n#define SQ905_BULK_READ\t0x03\t \n#define SQ905_COMMAND\t0x06\t \n#define SQ905_PING\t0x07\t \n#define SQ905_READ_DONE 0xc0     \n\n \n#define SQ905_HIRES_MASK\t0x00000300\n#define SQ905_ORIENTATION_MASK\t0x00000100\n\n \n\n#define SQ905_ID      0xf0\t \n#define SQ905_CONFIG  0x20\t \n#define SQ905_DATA    0x30\t \n#define SQ905_CLEAR   0xa0\t \n#define SQ905_CAPTURE_LOW  0x60\t \n#define SQ905_CAPTURE_MED  0x61\t \n#define SQ905_CAPTURE_HIGH 0x62\t \n \n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t \n\n\t \n\tstruct work_struct work_struct;\n\tstruct workqueue_struct *work_thread;\n};\n\nstatic struct v4l2_pix_format sq905_mode[] = {\n\t{ 160, 120, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 160 * 120,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n\t{ 320, 240, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n\t{ 640, 480, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0}\n};\n\n \nstatic int sq905_command(struct gspca_dev *gspca_dev, u16 index)\n{\n\tint ret;\n\n\tgspca_dev->usb_buf[0] = '\\0';\n\tret = usb_control_msg(gspca_dev->dev,\n\t\t\t      usb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t      USB_REQ_SYNCH_FRAME,                 \n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      SQ905_COMMAND, index, gspca_dev->usb_buf, 1,\n\t\t\t      SQ905_CMD_TIMEOUT);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: usb_control_msg failed (%d)\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = usb_control_msg(gspca_dev->dev,\n\t\t\t      usb_rcvctrlpipe(gspca_dev->dev, 0),\n\t\t\t      USB_REQ_SYNCH_FRAME,                 \n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      SQ905_PING, 0, gspca_dev->usb_buf, 1,\n\t\t\t      SQ905_CMD_TIMEOUT);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: usb_control_msg failed 2 (%d)\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sq905_ack_frame(struct gspca_dev *gspca_dev)\n{\n\tint ret;\n\n\tgspca_dev->usb_buf[0] = '\\0';\n\tret = usb_control_msg(gspca_dev->dev,\n\t\t\t      usb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t      USB_REQ_SYNCH_FRAME,                 \n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      SQ905_READ_DONE, 0, gspca_dev->usb_buf, 1,\n\t\t\t      SQ905_CMD_TIMEOUT);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: usb_control_msg failed (%d)\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nsq905_read_data(struct gspca_dev *gspca_dev, u8 *data, int size, int need_lock)\n{\n\tint ret;\n\tint act_len = 0;\n\n\tgspca_dev->usb_buf[0] = '\\0';\n\tif (need_lock)\n\t\tmutex_lock(&gspca_dev->usb_lock);\n\tret = usb_control_msg(gspca_dev->dev,\n\t\t\t      usb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t      USB_REQ_SYNCH_FRAME,                 \n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      SQ905_BULK_READ, size, gspca_dev->usb_buf,\n\t\t\t      1, SQ905_CMD_TIMEOUT);\n\tif (need_lock)\n\t\tmutex_unlock(&gspca_dev->usb_lock);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: usb_control_msg failed (%d)\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\tret = usb_bulk_msg(gspca_dev->dev,\n\t\t\t   usb_rcvbulkpipe(gspca_dev->dev, 0x81),\n\t\t\t   data, size, &act_len, SQ905_DATA_TIMEOUT);\n\n\t \n\tif (ret < 0 || act_len != size) {\n\t\tpr_err(\"bulk read fail (%d) len %d/%d\\n\", ret, act_len, size);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \nstatic void sq905_dostream(struct work_struct *work)\n{\n\tstruct sd *dev = container_of(work, struct sd, work_struct);\n\tstruct gspca_dev *gspca_dev = &dev->gspca_dev;\n\tint bytes_left;  \n\tint data_len;    \n\tint header_read;  \n\tint packet_type;\n\tint frame_sz;\n\tint ret;\n\tu8 *data;\n\tu8 *buffer;\n\n\tbuffer = kmalloc(SQ905_MAX_TRANSFER, GFP_KERNEL);\n\tif (!buffer) {\n\t\tpr_err(\"Couldn't allocate USB buffer\\n\");\n\t\tgoto quit_stream;\n\t}\n\n\tframe_sz = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].sizeimage\n\t\t\t+ FRAME_HEADER_LEN;\n\n\twhile (gspca_dev->present && gspca_dev->streaming) {\n#ifdef CONFIG_PM\n\t\tif (gspca_dev->frozen)\n\t\t\tbreak;\n#endif\n\t\t \n\t\tbytes_left = frame_sz;\n\t\theader_read = 0;\n\n\t\t \n\t\twhile (bytes_left > 0 && gspca_dev->present) {\n\t\t\tdata_len = bytes_left > SQ905_MAX_TRANSFER ?\n\t\t\t\tSQ905_MAX_TRANSFER : bytes_left;\n\t\t\tret = sq905_read_data(gspca_dev, buffer, data_len, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto quit_stream;\n\t\t\tgspca_dbg(gspca_dev, D_PACK,\n\t\t\t\t  \"Got %d bytes out of %d for frame\\n\",\n\t\t\t\t  data_len, bytes_left);\n\t\t\tbytes_left -= data_len;\n\t\t\tdata = buffer;\n\t\t\tif (!header_read) {\n\t\t\t\tpacket_type = FIRST_PACKET;\n\t\t\t\t \n\t\t\t\tdata += FRAME_HEADER_LEN;\n\t\t\t\tdata_len -= FRAME_HEADER_LEN;\n\t\t\t\theader_read = 1;\n\t\t\t} else if (bytes_left == 0) {\n\t\t\t\tpacket_type = LAST_PACKET;\n\t\t\t} else {\n\t\t\t\tpacket_type = INTER_PACKET;\n\t\t\t}\n\t\t\tgspca_frame_add(gspca_dev, packet_type,\n\t\t\t\t\tdata, data_len);\n\t\t\t \n\t\t\tif (packet_type == FIRST_PACKET &&\n\t\t\t    bytes_left == 0)\n\t\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET,\n\t\t\t\t\t\tNULL, 0);\n\t\t}\n\t\tif (gspca_dev->present) {\n\t\t\t \n\t\t\tmutex_lock(&gspca_dev->usb_lock);\n\t\t\tret = sq905_ack_frame(gspca_dev);\n\t\t\tmutex_unlock(&gspca_dev->usb_lock);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto quit_stream;\n\t\t}\n\t}\nquit_stream:\n\tif (gspca_dev->present) {\n\t\tmutex_lock(&gspca_dev->usb_lock);\n\t\tsq905_command(gspca_dev, SQ905_CLEAR);\n\t\tmutex_unlock(&gspca_dev->usb_lock);\n\t}\n\tkfree(buffer);\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct cam *cam = &gspca_dev->cam;\n\tstruct sd *dev = (struct sd *) gspca_dev;\n\n\t \n\tcam->bulk = 1;\n\tcam->bulk_size = 64;\n\n\tINIT_WORK(&dev->work_struct, sq905_dostream);\n\n\treturn 0;\n}\n\n \n \nstatic void sd_stop0(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *dev = (struct sd *) gspca_dev;\n\n\t \n\tmutex_unlock(&gspca_dev->usb_lock);\n\t \n\tdestroy_workqueue(dev->work_thread);\n\tdev->work_thread = NULL;\n\tmutex_lock(&gspca_dev->usb_lock);\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\tu32 ident;\n\tint ret;\n\n\t \n\tret = sq905_command(gspca_dev, SQ905_CLEAR);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = sq905_command(gspca_dev, SQ905_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = sq905_read_data(gspca_dev, gspca_dev->usb_buf, 4, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tident = be32_to_cpup((__be32 *)gspca_dev->usb_buf);\n\tret = sq905_command(gspca_dev, SQ905_CLEAR);\n\tif (ret < 0)\n\t\treturn ret;\n\tgspca_dbg(gspca_dev, D_CONF, \"SQ905 camera ID %08x detected\\n\", ident);\n\tgspca_dev->cam.cam_mode = sq905_mode;\n\tgspca_dev->cam.nmodes = ARRAY_SIZE(sq905_mode);\n\tif (!(ident & SQ905_HIRES_MASK))\n\t\tgspca_dev->cam.nmodes--;\n\n\tif (ident & SQ905_ORIENTATION_MASK)\n\t\tgspca_dev->cam.input_flags = V4L2_IN_ST_VFLIP;\n\telse\n\t\tgspca_dev->cam.input_flags = V4L2_IN_ST_VFLIP |\n\t\t\t\t\t     V4L2_IN_ST_HFLIP;\n\treturn 0;\n}\n\n \nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *dev = (struct sd *) gspca_dev;\n\tint ret;\n\n\t \n\tswitch (gspca_dev->curr_mode) {\n\tdefault:\n \n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Start streaming at high resolution\\n\");\n\t\tret = sq905_command(&dev->gspca_dev, SQ905_CAPTURE_HIGH);\n\t\tbreak;\n\tcase 1:\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Start streaming at medium resolution\\n\");\n\t\tret = sq905_command(&dev->gspca_dev, SQ905_CAPTURE_MED);\n\t\tbreak;\n\tcase 0:\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Start streaming at low resolution\\n\");\n\t\tret = sq905_command(&dev->gspca_dev, SQ905_CAPTURE_LOW);\n\t}\n\n\tif (ret < 0) {\n\t\tgspca_err(gspca_dev, \"Start streaming command failed\\n\");\n\t\treturn ret;\n\t}\n\t \n\tdev->work_thread = create_singlethread_workqueue(MODULE_NAME);\n\tif (!dev->work_thread)\n\t\treturn -ENOMEM;\n\n\tqueue_work(dev->work_thread, &dev->work_struct);\n\n\treturn 0;\n}\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x2770, 0x9120)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name   = MODULE_NAME,\n\t.config = sd_config,\n\t.init   = sd_init,\n\t.start  = sd_start,\n\t.stop0  = sd_stop0,\n};\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id,\n\t\t\t&sd_desc,\n\t\t\tsizeof(struct sd),\n\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name       = MODULE_NAME,\n\t.id_table   = device_table,\n\t.probe      = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume  = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}