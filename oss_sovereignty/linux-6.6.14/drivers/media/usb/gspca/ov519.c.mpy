{
  "module_name": "ov519.c",
  "hash_id": "71e61c8cc3d59d5147ac3ebb06bd6b33012876fb0dda5568818c7661b2e4fb6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/ov519.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"ov519\"\n\n#include <linux/input.h>\n#include \"gspca.h\"\n\n \n \n#define CONEX_CAM\n#include \"jpeg.h\"\n\nMODULE_AUTHOR(\"Jean-Francois Moine <http://moinejf.free.fr>\");\nMODULE_DESCRIPTION(\"OV519 USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic int frame_rate;\n\n \nstatic int i2c_detect_tries = 10;\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t\t \n\n\tstruct v4l2_ctrl *jpegqual;\n\tstruct v4l2_ctrl *freq;\n\tstruct {  \n\t\tstruct v4l2_ctrl *hflip;\n\t\tstruct v4l2_ctrl *vflip;\n\t};\n\tstruct {  \n\t\tstruct v4l2_ctrl *autobright;\n\t\tstruct v4l2_ctrl *brightness;\n\t};\n\n\tu8 revision;\n\n\tu8 packet_nr;\n\n\tchar bridge;\n#define BRIDGE_OV511\t\t0\n#define BRIDGE_OV511PLUS\t1\n#define BRIDGE_OV518\t\t2\n#define BRIDGE_OV518PLUS\t3\n#define BRIDGE_OV519\t\t4\t\t \n#define BRIDGE_OVFX2\t\t5\n#define BRIDGE_W9968CF\t\t6\n#define BRIDGE_MASK\t\t7\n\n\tchar invert_led;\n#define BRIDGE_INVERT_LED\t8\n\n\tchar snapshot_pressed;\n\tchar snapshot_needs_reset;\n\n\t \n\tu8 sif;\n\n#define QUALITY_MIN 50\n#define QUALITY_MAX 70\n#define QUALITY_DEF 50\n\n\tu8 stopped;\t\t \n\tu8 first_frame;\n\n\tu8 frame_rate;\t\t \n\tu8 clockdiv;\t\t \n\n\ts8 sensor;\t\t \n\n\tu8 sensor_addr;\n\tu16 sensor_width;\n\tu16 sensor_height;\n\ts16 sensor_reg_cache[256];\n\n\tu8 jpeg_hdr[JPEG_HDR_SZ];\n};\nenum sensors {\n\tSEN_OV2610,\n\tSEN_OV2610AE,\n\tSEN_OV3610,\n\tSEN_OV6620,\n\tSEN_OV6630,\n\tSEN_OV66308AF,\n\tSEN_OV7610,\n\tSEN_OV7620,\n\tSEN_OV7620AE,\n\tSEN_OV7640,\n\tSEN_OV7648,\n\tSEN_OV7660,\n\tSEN_OV7670,\n\tSEN_OV76BE,\n\tSEN_OV8610,\n\tSEN_OV9600,\n};\n\n \n#include \"w996Xcf.c\"\n\n \nstruct ctrl_valid {\n\tunsigned int has_brightness:1;\n\tunsigned int has_contrast:1;\n\tunsigned int has_exposure:1;\n\tunsigned int has_autogain:1;\n\tunsigned int has_sat:1;\n\tunsigned int has_hvflip:1;\n\tunsigned int has_autobright:1;\n\tunsigned int has_freq:1;\n};\n\nstatic const struct ctrl_valid valid_controls[] = {\n\t[SEN_OV2610] = {\n\t\t.has_exposure = 1,\n\t\t.has_autogain = 1,\n\t},\n\t[SEN_OV2610AE] = {\n\t\t.has_exposure = 1,\n\t\t.has_autogain = 1,\n\t},\n\t[SEN_OV3610] = {\n\t\t \n\t},\n\t[SEN_OV6620] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV6630] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV66308AF] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7610] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7620] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7620AE] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7640] = {\n\t\t.has_brightness = 1,\n\t\t.has_sat = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7648] = {\n\t\t.has_brightness = 1,\n\t\t.has_sat = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7660] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_hvflip = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV7670] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_hvflip = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV76BE] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t\t.has_freq = 1,\n\t},\n\t[SEN_OV8610] = {\n\t\t.has_brightness = 1,\n\t\t.has_contrast = 1,\n\t\t.has_sat = 1,\n\t\t.has_autobright = 1,\n\t},\n\t[SEN_OV9600] = {\n\t\t.has_exposure = 1,\n\t\t.has_autogain = 1,\n\t},\n};\n\nstatic const struct v4l2_pix_format ov519_vga_mode[] = {\n\t{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{640, 480, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\nstatic const struct v4l2_pix_format ov519_sif_mode[] = {\n\t{160, 120, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 160 * 120 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 3},\n\t{176, 144, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 176 * 144 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 2},\n\t{352, 288, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352,\n\t\t.sizeimage = 352 * 288 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\n\n \nstatic const struct v4l2_pix_format ov518_vga_mode[] = {\n\t{320, 240, V4L2_PIX_FMT_OV518, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{640, 480, V4L2_PIX_FMT_OV518, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 2,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\nstatic const struct v4l2_pix_format ov518_sif_mode[] = {\n\t{160, 120, V4L2_PIX_FMT_OV518, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 70000,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 3},\n\t{176, 144, V4L2_PIX_FMT_OV518, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 70000,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{320, 240, V4L2_PIX_FMT_OV518, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 2},\n\t{352, 288, V4L2_PIX_FMT_OV518, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352,\n\t\t.sizeimage = 352 * 288 * 3,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\n\nstatic const struct v4l2_pix_format ov511_vga_mode[] = {\n\t{320, 240, V4L2_PIX_FMT_OV511, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{640, 480, V4L2_PIX_FMT_OV511, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 2,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\nstatic const struct v4l2_pix_format ov511_sif_mode[] = {\n\t{160, 120, V4L2_PIX_FMT_OV511, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 70000,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 3},\n\t{176, 144, V4L2_PIX_FMT_OV511, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 70000,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{320, 240, V4L2_PIX_FMT_OV511, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 2},\n\t{352, 288, V4L2_PIX_FMT_OV511, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352,\n\t\t.sizeimage = 352 * 288 * 3,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\n\nstatic const struct v4l2_pix_format ovfx2_ov2610_mode[] = {\n\t{800, 600, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 800,\n\t\t.sizeimage = 800 * 600,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{1600, 1200, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 1600,\n\t\t.sizeimage = 1600 * 1200,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB},\n};\nstatic const struct v4l2_pix_format ovfx2_ov3610_mode[] = {\n\t{640, 480, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{800, 600, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 800,\n\t\t.sizeimage = 800 * 600,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{1024, 768, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 1024,\n\t\t.sizeimage = 1024 * 768,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{1600, 1200, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 1600,\n\t\t.sizeimage = 1600 * 1200,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n\t{2048, 1536, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 2048,\n\t\t.sizeimage = 2048 * 1536,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n};\nstatic const struct v4l2_pix_format ovfx2_ov9600_mode[] = {\n\t{640, 480, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{1280, 1024, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 1280,\n\t\t.sizeimage = 1280 * 1024,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB},\n};\n\n \n#define R51x_FIFO_PSIZE\t\t\t0x30\t \n#define R51x_SYS_RESET\t\t\t0x50\n\t \n\t#define\tOV511_RESET_OMNICE\t0x08\n#define R51x_SYS_INIT\t\t\t0x53\n#define R51x_SYS_SNAP\t\t\t0x52\n#define R51x_SYS_CUST_ID\t\t0x5f\n#define R51x_COMP_LUT_BEGIN\t\t0x80\n\n \n#define R511_CAM_DELAY\t\t\t0x10\n#define R511_CAM_EDGE\t\t\t0x11\n#define R511_CAM_PXCNT\t\t\t0x12\n#define R511_CAM_LNCNT\t\t\t0x13\n#define R511_CAM_PXDIV\t\t\t0x14\n#define R511_CAM_LNDIV\t\t\t0x15\n#define R511_CAM_UV_EN\t\t\t0x16\n#define R511_CAM_LINE_MODE\t\t0x17\n#define R511_CAM_OPTS\t\t\t0x18\n\n#define R511_SNAP_FRAME\t\t\t0x19\n#define R511_SNAP_PXCNT\t\t\t0x1a\n#define R511_SNAP_LNCNT\t\t\t0x1b\n#define R511_SNAP_PXDIV\t\t\t0x1c\n#define R511_SNAP_LNDIV\t\t\t0x1d\n#define R511_SNAP_UV_EN\t\t\t0x1e\n#define R511_SNAP_OPTS\t\t\t0x1f\n\n#define R511_DRAM_FLOW_CTL\t\t0x20\n#define R511_FIFO_OPTS\t\t\t0x31\n#define R511_I2C_CTL\t\t\t0x40\n#define R511_SYS_LED_CTL\t\t0x55\t \n#define R511_COMP_EN\t\t\t0x78\n#define R511_COMP_LUT_EN\t\t0x79\n\n \n#define R518_GPIO_OUT\t\t\t0x56\t \n#define R518_GPIO_CTL\t\t\t0x57\t \n\n \n#define OV519_R10_H_SIZE\t\t0x10\n#define OV519_R11_V_SIZE\t\t0x11\n#define OV519_R12_X_OFFSETL\t\t0x12\n#define OV519_R13_X_OFFSETH\t\t0x13\n#define OV519_R14_Y_OFFSETL\t\t0x14\n#define OV519_R15_Y_OFFSETH\t\t0x15\n#define OV519_R16_DIVIDER\t\t0x16\n#define OV519_R20_DFR\t\t\t0x20\n#define OV519_R25_FORMAT\t\t0x25\n\n \n#define OV519_R51_RESET1\t\t0x51\n#define OV519_R54_EN_CLK1\t\t0x54\n#define OV519_R57_SNAPSHOT\t\t0x57\n\n#define OV519_GPIO_DATA_OUT0\t\t0x71\n#define OV519_GPIO_IO_CTRL0\t\t0x72\n\n \n\n \n \n#define OVFX2_BULK_SIZE (13 * 4096)\n\n \n#define R51x_I2C_W_SID\t\t0x41\n#define R51x_I2C_SADDR_3\t0x42\n#define R51x_I2C_SADDR_2\t0x43\n#define R51x_I2C_R_SID\t\t0x44\n#define R51x_I2C_DATA\t\t0x45\n#define R518_I2C_CTL\t\t0x47\t \n#define OVFX2_I2C_ADDR\t\t0x00\n\n \n#define OV7xx0_SID   0x42\n#define OV_HIRES_SID 0x60\t\t \n#define OV8xx0_SID   0xa0\n#define OV6xx0_SID   0xc0\n\n \n#define OV7610_REG_GAIN\t\t0x00\t \n#define OV7610_REG_BLUE\t\t0x01\t \n#define OV7610_REG_RED\t\t0x02\t \n#define OV7610_REG_SAT\t\t0x03\t \n#define OV8610_REG_HUE\t\t0x04\t \n#define OV7610_REG_CNT\t\t0x05\t \n#define OV7610_REG_BRT\t\t0x06\t \n#define OV7610_REG_COM_C\t0x14\t \n#define OV7610_REG_ID_HIGH\t0x1c\t \n#define OV7610_REG_ID_LOW\t0x1d\t \n#define OV7610_REG_COM_I\t0x29\t \n\n \n#define OV7670_R00_GAIN\t\t0x00\t \n#define OV7670_R01_BLUE\t\t0x01\t \n#define OV7670_R02_RED\t\t0x02\t \n#define OV7670_R03_VREF\t\t0x03\t \n#define OV7670_R04_COM1\t\t0x04\t \n \n#define OV7670_R0C_COM3\t\t0x0c\t \n#define OV7670_R0D_COM4\t\t0x0d\t \n#define OV7670_R0E_COM5\t\t0x0e\t \n#define OV7670_R0F_COM6\t\t0x0f\t \n#define OV7670_R10_AECH\t\t0x10\t \n#define OV7670_R11_CLKRC\t0x11\t \n#define OV7670_R12_COM7\t\t0x12\t \n#define   OV7670_COM7_FMT_VGA\t 0x00\n \n#define   OV7670_COM7_FMT_QVGA\t 0x10\t \n#define   OV7670_COM7_FMT_MASK\t 0x38\n#define   OV7670_COM7_RESET\t 0x80\t \n#define OV7670_R13_COM8\t\t0x13\t \n#define   OV7670_COM8_AEC\t 0x01\t \n#define   OV7670_COM8_AWB\t 0x02\t \n#define   OV7670_COM8_AGC\t 0x04\t \n#define   OV7670_COM8_BFILT\t 0x20\t \n#define   OV7670_COM8_AECSTEP\t 0x40\t \n#define   OV7670_COM8_FASTAEC\t 0x80\t \n#define OV7670_R14_COM9\t\t0x14\t \n#define OV7670_R15_COM10\t0x15\t \n#define OV7670_R17_HSTART\t0x17\t \n#define OV7670_R18_HSTOP\t0x18\t \n#define OV7670_R19_VSTART\t0x19\t \n#define OV7670_R1A_VSTOP\t0x1a\t \n#define OV7670_R1E_MVFP\t\t0x1e\t \n#define   OV7670_MVFP_VFLIP\t 0x10\t \n#define   OV7670_MVFP_MIRROR\t 0x20\t \n#define OV7670_R24_AEW\t\t0x24\t \n#define OV7670_R25_AEB\t\t0x25\t \n#define OV7670_R26_VPT\t\t0x26\t \n#define OV7670_R32_HREF\t\t0x32\t \n#define OV7670_R3A_TSLB\t\t0x3a\t \n#define OV7670_R3B_COM11\t0x3b\t \n#define   OV7670_COM11_EXP\t 0x02\n#define   OV7670_COM11_HZAUTO\t 0x10\t \n#define OV7670_R3C_COM12\t0x3c\t \n#define OV7670_R3D_COM13\t0x3d\t \n#define   OV7670_COM13_GAMMA\t 0x80\t \n#define   OV7670_COM13_UVSAT\t 0x40\t \n#define OV7670_R3E_COM14\t0x3e\t \n#define OV7670_R3F_EDGE\t\t0x3f\t \n#define OV7670_R40_COM15\t0x40\t \n \n#define OV7670_R41_COM16\t0x41\t \n#define   OV7670_COM16_AWBGAIN\t 0x08\t \n \n#define OV7670_R55_BRIGHT\t0x55\t \n#define OV7670_R56_CONTRAS\t0x56\t \n#define OV7670_R69_GFIX\t\t0x69\t \n \n#define OV7670_R9F_HAECC1\t0x9f\t \n#define OV7670_RA0_HAECC2\t0xa0\t \n#define OV7670_RA5_BD50MAX\t0xa5\t \n#define OV7670_RA6_HAECC3\t0xa6\t \n#define OV7670_RA7_HAECC4\t0xa7\t \n#define OV7670_RA8_HAECC5\t0xa8\t \n#define OV7670_RA9_HAECC6\t0xa9\t \n#define OV7670_RAA_HAECC7\t0xaa\t \n#define OV7670_RAB_BD60MAX\t0xab\t \n\nstruct ov_regvals {\n\tu8 reg;\n\tu8 val;\n};\nstruct ov_i2c_regvals {\n\tu8 reg;\n\tu8 val;\n};\n\n \nstatic const struct ov_i2c_regvals norm_2610[] = {\n\t{ 0x12, 0x80 },\t \n};\n\nstatic const struct ov_i2c_regvals norm_2610ae[] = {\n\t{0x12, 0x80},\t \n\t{0x13, 0xcd},\n\t{0x09, 0x01},\n\t{0x0d, 0x00},\n\t{0x11, 0x80},\n\t{0x12, 0x20},\t \n\t{0x33, 0x0c},\n\t{0x35, 0x90},\n\t{0x36, 0x37},\n \n\t{0x11, 0x83},\t \n\t{0x2d, 0x00},\t \n\t{0x24, 0xb0},\t \n\t{0x25, 0x90},\n\t{0x10, 0x43},\n};\n\nstatic const struct ov_i2c_regvals norm_3620b[] = {\n\t \n\t{ 0x12, 0x80 },  \n\t{ 0x12, 0x00 },  \n\n\t \n\t{ 0x11, 0x80 },\n\n\t \n\t{ 0x13, 0xc0 },\n\n\t \n\t{ 0x09, 0x08 },\n\n\t \n\t{ 0x0c, 0x08 },\n\n\t \n\t{ 0x0d, 0xa1 },\n\n\t \n\t{ 0x0e, 0x70 },\n\n\t \n\t{ 0x0f, 0x42 },\n\n\t \n\t{ 0x14, 0xc6 },\n\n\t \n\t{ 0x15, 0x02 },\n\n\t \n\t{ 0x33, 0x09 },\n\n\t \n\t{ 0x34, 0x50 },\n\n\t \n\t{ 0x36, 0x00 },\n\n\t \n\t{ 0x37, 0x04 },\n\n\t \n\t{ 0x38, 0x52 },\n\n\t \n\t{ 0x3a, 0x00 },\n\n\t \n\t{ 0x3c, 0x1f },\n\n\t \n\t{ 0x44, 0x00 },\n\n\t \n\t{ 0x40, 0x00 },\n\n\t \n\t{ 0x41, 0x00 },\n\n\t \n\t{ 0x42, 0x00 },\n\n\t \n\t{ 0x43, 0x00 },\n\n\t \n\t{ 0x45, 0x80 },\n\n\t \n\t{ 0x48, 0xc0 },\n\n\t \n\t{ 0x49, 0x19 },\n\n\t \n\t{ 0x4b, 0x80 },\n\n\t \n\t{ 0x4d, 0xc4 },\n\n\t \n\t{ 0x35, 0x4c },\n\n\t \n\t{ 0x3d, 0x00 },\n\n\t \n\t{ 0x3e, 0x00 },\n\n\t \n\t{ 0x3b, 0x18 },\n\n\t \n\t{ 0x33, 0x19 },\n\n\t \n\t{ 0x34, 0x5a },\n\n\t \n\t{ 0x3b, 0x00 },\n\n\t \n\t{ 0x33, 0x09 },\n\n\t \n\t{ 0x34, 0x50 },\n\n\t \n\t{ 0x12, 0x40 },\n\n\t \n\t{ 0x17, 0x1f },\n\n\t \n\t{ 0x18, 0x5f },\n\n\t \n\t{ 0x19, 0x00 },\n\n\t \n\t{ 0x1a, 0x60 },\n\n\t \n\t{ 0x32, 0x12 },\n\n\t \n\t{ 0x03, 0x4a },\n\n\t \n\t{ 0x11, 0x80 },\n\n\t \n\t{ 0x12, 0x00 },\n\n\t \n\t{ 0x12, 0x40 },\n\n\t \n\t{ 0x17, 0x1f },\n\n\t \n\t{ 0x18, 0x5f },\n\n\t \n\t{ 0x19, 0x00 },\n\n\t \n\t{ 0x1a, 0x60 },\n\n\t \n\t{ 0x32, 0x12 },\n\n\t \n\t{ 0x03, 0x4a },\n\n\t \n\t{ 0x02, 0xaf },\n\n\t \n\t{ 0x2d, 0xd2 },\n\n\t \n\t{ 0x00, 0x18 },\n\n\t \n\t{ 0x01, 0xf0 },\n\n\t \n\t{ 0x10, 0x0a },\n\n\t{ 0xe1, 0x67 },\n\t{ 0xe3, 0x03 },\n\t{ 0xe4, 0x26 },\n\t{ 0xe5, 0x3e },\n\t{ 0xf8, 0x01 },\n\t{ 0xff, 0x01 },\n};\n\nstatic const struct ov_i2c_regvals norm_6x20[] = {\n\t{ 0x12, 0x80 },  \n\t{ 0x11, 0x01 },\n\t{ 0x03, 0x60 },\n\t{ 0x05, 0x7f },  \n\t{ 0x07, 0xa8 },\n\t \n\t{ 0x0c, 0x24 },\n\t{ 0x0d, 0x24 },\n\t{ 0x0f, 0x15 },  \n\t{ 0x10, 0x75 },  \n\t{ 0x12, 0x24 },  \n\t{ 0x14, 0x04 },\n\t \n\t{ 0x16, 0x06 },\n \n\t{ 0x26, 0xb2 },  \n\t \n\t{ 0x28, 0x05 },\n\t{ 0x2a, 0x04 },  \n \n\t{ 0x2d, 0x85 },\n\t{ 0x33, 0xa0 },  \n\t{ 0x34, 0xd2 },  \n\t{ 0x38, 0x8b },\n\t{ 0x39, 0x40 },\n\n\t{ 0x3c, 0x39 },  \n\t{ 0x3c, 0x3c },  \n\t{ 0x3c, 0x24 },  \n\n\t{ 0x3d, 0x80 },\n\t \n\t{ 0x4a, 0x80 },\n\t{ 0x4b, 0x80 },\n\t{ 0x4d, 0xd2 },  \n\t{ 0x4e, 0xc1 },\n\t{ 0x4f, 0x04 },\n \n \n};\n\nstatic const struct ov_i2c_regvals norm_6x30[] = {\n\t{ 0x12, 0x80 },  \n\t{ 0x00, 0x1f },  \n\t{ 0x01, 0x99 },  \n\t{ 0x02, 0x7c },  \n\t{ 0x03, 0xc0 },  \n\t{ 0x05, 0x0a },  \n\t{ 0x06, 0x95 },  \n\t{ 0x07, 0x2d },  \n\t{ 0x0c, 0x20 },\n\t{ 0x0d, 0x20 },\n\t{ 0x0e, 0xa0 },  \n\t{ 0x0f, 0x05 },\n\t{ 0x10, 0x9a },\n\t{ 0x11, 0x00 },  \n\t{ 0x12, 0x24 },  \n\t{ 0x13, 0x21 },\n\t{ 0x14, 0x80 },\n\t{ 0x15, 0x01 },\n\t{ 0x16, 0x03 },\n\t{ 0x17, 0x38 },\n\t{ 0x18, 0xea },\n\t{ 0x19, 0x04 },\n\t{ 0x1a, 0x93 },\n\t{ 0x1b, 0x00 },\n\t{ 0x1e, 0xc4 },\n\t{ 0x1f, 0x04 },\n\t{ 0x20, 0x20 },\n\t{ 0x21, 0x10 },\n\t{ 0x22, 0x88 },\n\t{ 0x23, 0xc0 },  \n\t{ 0x25, 0x9a },  \n\t{ 0x26, 0xb2 },  \n\t{ 0x27, 0xa2 },\n\t{ 0x28, 0x00 },\n\t{ 0x29, 0x00 },\n\t{ 0x2a, 0x84 },  \n\t{ 0x2b, 0xa8 },  \n\t{ 0x2c, 0xa0 },\n\t{ 0x2d, 0x95 },  \n\t{ 0x2e, 0x88 },\n\t{ 0x33, 0x26 },\n\t{ 0x34, 0x03 },\n\t{ 0x36, 0x8f },\n\t{ 0x37, 0x80 },\n\t{ 0x38, 0x83 },\n\t{ 0x39, 0x80 },\n\t{ 0x3a, 0x0f },\n\t{ 0x3b, 0x3c },\n\t{ 0x3c, 0x1a },\n\t{ 0x3d, 0x80 },\n\t{ 0x3e, 0x80 },\n\t{ 0x3f, 0x0e },\n\t{ 0x40, 0x00 },  \n\t{ 0x41, 0x00 },  \n\t{ 0x42, 0x80 },\n\t{ 0x43, 0x3f },  \n\t{ 0x44, 0x80 },\n\t{ 0x45, 0x20 },\n\t{ 0x46, 0x20 },\n\t{ 0x47, 0x80 },\n\t{ 0x48, 0x7f },\n\t{ 0x49, 0x00 },\n\t{ 0x4a, 0x00 },\n\t{ 0x4b, 0x80 },\n\t{ 0x4c, 0xd0 },\n\t{ 0x4d, 0x10 },  \n\t{ 0x4e, 0x40 },\n\t{ 0x4f, 0x07 },  \n\t{ 0x50, 0xff },\n\t{ 0x54, 0x23 },  \n\t{ 0x55, 0xff },\n\t{ 0x56, 0x12 },\n\t{ 0x57, 0x81 },\n\t{ 0x58, 0x75 },\n\t{ 0x59, 0x01 },  \n\t{ 0x5a, 0x2c },\n\t{ 0x5b, 0x0f },  \n\t{ 0x5c, 0x10 },\n\t{ 0x3d, 0x80 },\n\t{ 0x27, 0xa6 },\n\t{ 0x12, 0x20 },  \n\t{ 0x12, 0x24 },\n};\n\n \nstatic const struct ov_i2c_regvals norm_7610[] = {\n\t{ 0x10, 0xff },\n\t{ 0x16, 0x06 },\n\t{ 0x28, 0x24 },\n\t{ 0x2b, 0xac },\n\t{ 0x12, 0x00 },\n\t{ 0x38, 0x81 },\n\t{ 0x28, 0x24 },\t \n\t{ 0x0f, 0x85 },\t \n\t{ 0x15, 0x01 },\n\t{ 0x20, 0x1c },\n\t{ 0x23, 0x2a },\n\t{ 0x24, 0x10 },\n\t{ 0x25, 0x8a },\n\t{ 0x26, 0xa2 },\n\t{ 0x27, 0xc2 },\n\t{ 0x2a, 0x04 },\n\t{ 0x2c, 0xfe },\n\t{ 0x2d, 0x93 },\n\t{ 0x30, 0x71 },\n\t{ 0x31, 0x60 },\n\t{ 0x32, 0x26 },\n\t{ 0x33, 0x20 },\n\t{ 0x34, 0x48 },\n\t{ 0x12, 0x24 },\n\t{ 0x11, 0x01 },\n\t{ 0x0c, 0x24 },\n\t{ 0x0d, 0x24 },\n};\n\nstatic const struct ov_i2c_regvals norm_7620[] = {\n\t{ 0x12, 0x80 },\t\t \n\t{ 0x00, 0x00 },\t\t \n\t{ 0x01, 0x80 },\t\t \n\t{ 0x02, 0x80 },\t\t \n\t{ 0x03, 0xc0 },\t\t \n\t{ 0x06, 0x60 },\n\t{ 0x07, 0x00 },\n\t{ 0x0c, 0x24 },\n\t{ 0x0c, 0x24 },\n\t{ 0x0d, 0x24 },\n\t{ 0x11, 0x01 },\n\t{ 0x12, 0x24 },\n\t{ 0x13, 0x01 },\n\t{ 0x14, 0x84 },\n\t{ 0x15, 0x01 },\n\t{ 0x16, 0x03 },\n\t{ 0x17, 0x2f },\n\t{ 0x18, 0xcf },\n\t{ 0x19, 0x06 },\n\t{ 0x1a, 0xf5 },\n\t{ 0x1b, 0x00 },\n\t{ 0x20, 0x18 },\n\t{ 0x21, 0x80 },\n\t{ 0x22, 0x80 },\n\t{ 0x23, 0x00 },\n\t{ 0x26, 0xa2 },\n\t{ 0x27, 0xea },\n\t{ 0x28, 0x22 },  \n\t{ 0x29, 0x00 },\n\t{ 0x2a, 0x10 },\n\t{ 0x2b, 0x00 },\n\t{ 0x2c, 0x88 },\n\t{ 0x2d, 0x91 },\n\t{ 0x2e, 0x80 },\n\t{ 0x2f, 0x44 },\n\t{ 0x60, 0x27 },\n\t{ 0x61, 0x02 },\n\t{ 0x62, 0x5f },\n\t{ 0x63, 0xd5 },\n\t{ 0x64, 0x57 },\n\t{ 0x65, 0x83 },\n\t{ 0x66, 0x55 },\n\t{ 0x67, 0x92 },\n\t{ 0x68, 0xcf },\n\t{ 0x69, 0x76 },\n\t{ 0x6a, 0x22 },\n\t{ 0x6b, 0x00 },\n\t{ 0x6c, 0x02 },\n\t{ 0x6d, 0x44 },\n\t{ 0x6e, 0x80 },\n\t{ 0x6f, 0x1d },\n\t{ 0x70, 0x8b },\n\t{ 0x71, 0x00 },\n\t{ 0x72, 0x14 },\n\t{ 0x73, 0x54 },\n\t{ 0x74, 0x00 },\n\t{ 0x75, 0x8e },\n\t{ 0x76, 0x00 },\n\t{ 0x77, 0xff },\n\t{ 0x78, 0x80 },\n\t{ 0x79, 0x80 },\n\t{ 0x7a, 0x80 },\n\t{ 0x7b, 0xe2 },\n\t{ 0x7c, 0x00 },\n};\n\n \nstatic const struct ov_i2c_regvals norm_7640[] = {\n\t{ 0x12, 0x80 },\n\t{ 0x12, 0x14 },\n};\n\nstatic const struct ov_regvals init_519_ov7660[] = {\n\t{ 0x5d,\t0x03 },  \n\t{ 0x53,\t0x9b },  \n\t{ 0x54,\t0x0f },  \n\t{ 0xa2,\t0x20 },  \n\t{ 0xa3,\t0x18 },\n\t{ 0xa4,\t0x04 },\n\t{ 0xa5,\t0x28 },\n\t{ 0x37,\t0x00 },\t \n\t{ 0x55,\t0x02 },  \n\t \n\t{ 0x20,\t0x0c },\t \n\t{ 0x21,\t0x38 },\n\t{ 0x22,\t0x1d },\n\t{ 0x17,\t0x50 },  \n\t{ 0x37,\t0x00 },  \n\t{ 0x40,\t0xff },  \n\t{ 0x46,\t0x00 },  \n};\nstatic const struct ov_i2c_regvals norm_7660[] = {\n\t{OV7670_R12_COM7, OV7670_COM7_RESET},\n\t{OV7670_R11_CLKRC, 0x81},\n\t{0x92, 0x00},\t\t\t \n\t{0x93, 0x00},\t\t\t \n\t{0x9d, 0x4c},\t\t\t \n\t{0x9e, 0x3f},\t\t\t \n\t{OV7670_R3B_COM11, 0x02},\n\t{OV7670_R13_COM8, 0xf5},\n\t{OV7670_R10_AECH, 0x00},\n\t{OV7670_R00_GAIN, 0x00},\n\t{OV7670_R01_BLUE, 0x7c},\n\t{OV7670_R02_RED, 0x9d},\n\t{OV7670_R12_COM7, 0x00},\n\t{OV7670_R04_COM1, 00},\n\t{OV7670_R18_HSTOP, 0x01},\n\t{OV7670_R17_HSTART, 0x13},\n\t{OV7670_R32_HREF, 0x92},\n\t{OV7670_R19_VSTART, 0x02},\n\t{OV7670_R1A_VSTOP, 0x7a},\n\t{OV7670_R03_VREF, 0x00},\n\t{OV7670_R0E_COM5, 0x04},\n\t{OV7670_R0F_COM6, 0x62},\n\t{OV7670_R15_COM10, 0x00},\n\t{0x16, 0x02},\t\t\t \n\t{0x1b, 0x00},\t\t\t \n\t{OV7670_R1E_MVFP, 0x01},\n\t{0x29, 0x3c},\t\t\t \n\t{0x33, 0x00},\t\t\t \n\t{0x34, 0x07},\t\t\t \n\t{0x35, 0x84},\t\t\t \n\t{0x36, 0x00},\t\t\t \n\t{0x37, 0x04},\t\t\t \n\t{0x39, 0x43},\t\t\t \n\t{OV7670_R3A_TSLB, 0x00},\n\t{OV7670_R3C_COM12, 0x6c},\n\t{OV7670_R3D_COM13, 0x98},\n\t{OV7670_R3F_EDGE, 0x23},\n\t{OV7670_R40_COM15, 0xc1},\n\t{OV7670_R41_COM16, 0x22},\n\t{0x6b, 0x0a},\t\t\t \n\t{0xa1, 0x08},\t\t\t \n\t{0x69, 0x80},\t\t\t \n\t{0x43, 0xf0},\t\t\t \n\t{0x44, 0x10},\n\t{0x45, 0x78},\n\t{0x46, 0xa8},\n\t{0x47, 0x60},\n\t{0x48, 0x80},\n\t{0x59, 0xba},\n\t{0x5a, 0x9a},\n\t{0x5b, 0x22},\n\t{0x5c, 0xb9},\n\t{0x5d, 0x9b},\n\t{0x5e, 0x10},\n\t{0x5f, 0xe0},\n\t{0x60, 0x85},\n\t{0x61, 0x60},\n\t{0x9f, 0x9d},\t\t\t \n\t{0xa0, 0xa0},\t\t\t \n\t{0x4f, 0x60},\t\t\t \n\t{0x50, 0x64},\n\t{0x51, 0x04},\n\t{0x52, 0x18},\n\t{0x53, 0x3c},\n\t{0x54, 0x54},\n\t{0x55, 0x40},\n\t{0x56, 0x40},\n\t{0x57, 0x40},\n\t{0x58, 0x0d},\t\t\t \n\t{0x8b, 0xcc},\t\t\t \n\t{0x8c, 0xcc},\n\t{0x8d, 0xcf},\n\t{0x6c, 0x40},\t\t\t \n\t{0x6d, 0xe0},\n\t{0x6e, 0xa0},\n\t{0x6f, 0x80},\n\t{0x70, 0x70},\n\t{0x71, 0x80},\n\t{0x72, 0x60},\n\t{0x73, 0x60},\n\t{0x74, 0x50},\n\t{0x75, 0x40},\n\t{0x76, 0x38},\n\t{0x77, 0x3c},\n\t{0x78, 0x32},\n\t{0x79, 0x1a},\n\t{0x7a, 0x28},\n\t{0x7b, 0x24},\n\t{0x7c, 0x04},\t\t\t \n\t{0x7d, 0x12},\n\t{0x7e, 0x26},\n\t{0x7f, 0x46},\n\t{0x80, 0x54},\n\t{0x81, 0x64},\n\t{0x82, 0x70},\n\t{0x83, 0x7c},\n\t{0x84, 0x86},\n\t{0x85, 0x8e},\n\t{0x86, 0x9c},\n\t{0x87, 0xab},\n\t{0x88, 0xc4},\n\t{0x89, 0xd1},\n\t{0x8a, 0xe5},\n\t{OV7670_R14_COM9, 0x1e},\n\t{OV7670_R24_AEW, 0x80},\n\t{OV7670_R25_AEB, 0x72},\n\t{OV7670_R26_VPT, 0xb3},\n\t{0x62, 0x80},\t\t\t \n\t{0x63, 0x80},\t\t\t \n\t{0x64, 0x06},\t\t\t \n\t{0x65, 0x00},\t\t\t \n\t{0x66, 0x01},\t\t\t \n\t{0x94, 0x0e},\t\t\t \n\t{0x95, 0x14},\n\t{OV7670_R13_COM8, OV7670_COM8_FASTAEC\n\t\t\t| OV7670_COM8_AECSTEP\n\t\t\t| OV7670_COM8_BFILT\n\t\t\t| 0x10\n\t\t\t| OV7670_COM8_AGC\n\t\t\t| OV7670_COM8_AWB\n\t\t\t| OV7670_COM8_AEC},\n\t{0xa1, 0xc8}\n};\nstatic const struct ov_i2c_regvals norm_9600[] = {\n\t{0x12, 0x80},\n\t{0x0c, 0x28},\n\t{0x11, 0x80},\n\t{0x13, 0xb5},\n\t{0x14, 0x3e},\n\t{0x1b, 0x04},\n\t{0x24, 0xb0},\n\t{0x25, 0x90},\n\t{0x26, 0x94},\n\t{0x35, 0x90},\n\t{0x37, 0x07},\n\t{0x38, 0x08},\n\t{0x01, 0x8e},\n\t{0x02, 0x85}\n};\n\n \nstatic const struct ov_i2c_regvals norm_7670[] = {\n\t{ OV7670_R12_COM7, OV7670_COM7_RESET },\n\t{ OV7670_R3A_TSLB, 0x04 },\t\t \n\t{ OV7670_R12_COM7, OV7670_COM7_FMT_VGA },  \n\t{ OV7670_R11_CLKRC, 0x01 },\n \n\t{ OV7670_R17_HSTART, 0x13 },\n\t{ OV7670_R18_HSTOP, 0x01 },\n\t{ OV7670_R32_HREF, 0xb6 },\n\t{ OV7670_R19_VSTART, 0x02 },\n\t{ OV7670_R1A_VSTOP, 0x7a },\n\t{ OV7670_R03_VREF, 0x0a },\n\n\t{ OV7670_R0C_COM3, 0x00 },\n\t{ OV7670_R3E_COM14, 0x00 },\n \n\t{ 0x70, 0x3a },\n\t{ 0x71, 0x35 },\n\t{ 0x72, 0x11 },\n\t{ 0x73, 0xf0 },\n\t{ 0xa2, 0x02 },\n \n\n \n\t{ 0x7a, 0x20 },\n\t{ 0x7b, 0x10 },\n\t{ 0x7c, 0x1e },\n\t{ 0x7d, 0x35 },\n\t{ 0x7e, 0x5a },\n\t{ 0x7f, 0x69 },\n\t{ 0x80, 0x76 },\n\t{ 0x81, 0x80 },\n\t{ 0x82, 0x88 },\n\t{ 0x83, 0x8f },\n\t{ 0x84, 0x96 },\n\t{ 0x85, 0xa3 },\n\t{ 0x86, 0xaf },\n\t{ 0x87, 0xc4 },\n\t{ 0x88, 0xd7 },\n\t{ 0x89, 0xe8 },\n\n \n\t{ OV7670_R13_COM8, OV7670_COM8_FASTAEC\n\t\t\t | OV7670_COM8_AECSTEP\n\t\t\t | OV7670_COM8_BFILT },\n\t{ OV7670_R00_GAIN, 0x00 },\n\t{ OV7670_R10_AECH, 0x00 },\n\t{ OV7670_R0D_COM4, 0x40 },  \n\t{ OV7670_R14_COM9, 0x18 },  \n\t{ OV7670_RA5_BD50MAX, 0x05 },\n\t{ OV7670_RAB_BD60MAX, 0x07 },\n\t{ OV7670_R24_AEW, 0x95 },\n\t{ OV7670_R25_AEB, 0x33 },\n\t{ OV7670_R26_VPT, 0xe3 },\n\t{ OV7670_R9F_HAECC1, 0x78 },\n\t{ OV7670_RA0_HAECC2, 0x68 },\n\t{ 0xa1, 0x03 },  \n\t{ OV7670_RA6_HAECC3, 0xd8 },\n\t{ OV7670_RA7_HAECC4, 0xd8 },\n\t{ OV7670_RA8_HAECC5, 0xf0 },\n\t{ OV7670_RA9_HAECC6, 0x90 },\n\t{ OV7670_RAA_HAECC7, 0x94 },\n\t{ OV7670_R13_COM8, OV7670_COM8_FASTAEC\n\t\t\t| OV7670_COM8_AECSTEP\n\t\t\t| OV7670_COM8_BFILT\n\t\t\t| OV7670_COM8_AGC\n\t\t\t| OV7670_COM8_AEC },\n\n \n\t{ OV7670_R0E_COM5, 0x61 },\n\t{ OV7670_R0F_COM6, 0x4b },\n\t{ 0x16, 0x02 },\n\t{ OV7670_R1E_MVFP, 0x07 },\n\t{ 0x21, 0x02 },\n\t{ 0x22, 0x91 },\n\t{ 0x29, 0x07 },\n\t{ 0x33, 0x0b },\n\t{ 0x35, 0x0b },\n\t{ 0x37, 0x1d },\n\t{ 0x38, 0x71 },\n\t{ 0x39, 0x2a },\n\t{ OV7670_R3C_COM12, 0x78 },\n\t{ 0x4d, 0x40 },\n\t{ 0x4e, 0x20 },\n\t{ OV7670_R69_GFIX, 0x00 },\n\t{ 0x6b, 0x4a },\n\t{ 0x74, 0x10 },\n\t{ 0x8d, 0x4f },\n\t{ 0x8e, 0x00 },\n\t{ 0x8f, 0x00 },\n\t{ 0x90, 0x00 },\n\t{ 0x91, 0x00 },\n\t{ 0x96, 0x00 },\n\t{ 0x9a, 0x00 },\n\t{ 0xb0, 0x84 },\n\t{ 0xb1, 0x0c },\n\t{ 0xb2, 0x0e },\n\t{ 0xb3, 0x82 },\n\t{ 0xb8, 0x0a },\n\n \n\t{ 0x43, 0x0a },\n\t{ 0x44, 0xf0 },\n\t{ 0x45, 0x34 },\n\t{ 0x46, 0x58 },\n\t{ 0x47, 0x28 },\n\t{ 0x48, 0x3a },\n\t{ 0x59, 0x88 },\n\t{ 0x5a, 0x88 },\n\t{ 0x5b, 0x44 },\n\t{ 0x5c, 0x67 },\n\t{ 0x5d, 0x49 },\n\t{ 0x5e, 0x0e },\n\t{ 0x6c, 0x0a },\n\t{ 0x6d, 0x55 },\n\t{ 0x6e, 0x11 },\n\t{ 0x6f, 0x9f },\t\t\t \n\t{ 0x6a, 0x40 },\n\t{ OV7670_R01_BLUE, 0x40 },\n\t{ OV7670_R02_RED, 0x60 },\n\t{ OV7670_R13_COM8, OV7670_COM8_FASTAEC\n\t\t\t| OV7670_COM8_AECSTEP\n\t\t\t| OV7670_COM8_BFILT\n\t\t\t| OV7670_COM8_AGC\n\t\t\t| OV7670_COM8_AEC\n\t\t\t| OV7670_COM8_AWB },\n\n \n\t{ 0x4f, 0x80 },\n\t{ 0x50, 0x80 },\n\t{ 0x51, 0x00 },\n\t{ 0x52, 0x22 },\n\t{ 0x53, 0x5e },\n\t{ 0x54, 0x80 },\n\t{ 0x58, 0x9e },\n\n\t{ OV7670_R41_COM16, OV7670_COM16_AWBGAIN },\n\t{ OV7670_R3F_EDGE, 0x00 },\n\t{ 0x75, 0x05 },\n\t{ 0x76, 0xe1 },\n\t{ 0x4c, 0x00 },\n\t{ 0x77, 0x01 },\n\t{ OV7670_R3D_COM13, OV7670_COM13_GAMMA\n\t\t\t  | OV7670_COM13_UVSAT\n\t\t\t  | 2},\t\t \n\t{ 0x4b, 0x09 },\n\t{ 0xc9, 0x60 },\n\t{ OV7670_R41_COM16, 0x38 },\n\t{ 0x56, 0x40 },\n\n\t{ 0x34, 0x11 },\n\t{ OV7670_R3B_COM11, OV7670_COM11_EXP|OV7670_COM11_HZAUTO },\n\t{ 0xa4, 0x88 },\n\t{ 0x96, 0x00 },\n\t{ 0x97, 0x30 },\n\t{ 0x98, 0x20 },\n\t{ 0x99, 0x30 },\n\t{ 0x9a, 0x84 },\n\t{ 0x9b, 0x29 },\n\t{ 0x9c, 0x03 },\n\t{ 0x9d, 0x4c },\n\t{ 0x9e, 0x3f },\n\t{ 0x78, 0x04 },\n\n \n\t{ 0x79, 0x01 },\n\t{ 0xc8, 0xf0 },\n\t{ 0x79, 0x0f },\n\t{ 0xc8, 0x00 },\n\t{ 0x79, 0x10 },\n\t{ 0xc8, 0x7e },\n\t{ 0x79, 0x0a },\n\t{ 0xc8, 0x80 },\n\t{ 0x79, 0x0b },\n\t{ 0xc8, 0x01 },\n\t{ 0x79, 0x0c },\n\t{ 0xc8, 0x0f },\n\t{ 0x79, 0x0d },\n\t{ 0xc8, 0x20 },\n\t{ 0x79, 0x09 },\n\t{ 0xc8, 0x80 },\n\t{ 0x79, 0x02 },\n\t{ 0xc8, 0xc0 },\n\t{ 0x79, 0x03 },\n\t{ 0xc8, 0x40 },\n\t{ 0x79, 0x05 },\n\t{ 0xc8, 0x30 },\n\t{ 0x79, 0x26 },\n};\n\nstatic const struct ov_i2c_regvals norm_8610[] = {\n\t{ 0x12, 0x80 },\n\t{ 0x00, 0x00 },\n\t{ 0x01, 0x80 },\n\t{ 0x02, 0x80 },\n\t{ 0x03, 0xc0 },\n\t{ 0x04, 0x30 },\n\t{ 0x05, 0x30 },  \n\t{ 0x06, 0x70 },  \n\t{ 0x0a, 0x86 },\n\t{ 0x0b, 0xb0 },\n\t{ 0x0c, 0x20 },\n\t{ 0x0d, 0x20 },\n\t{ 0x11, 0x01 },\n\t{ 0x12, 0x25 },\n\t{ 0x13, 0x01 },\n\t{ 0x14, 0x04 },\n\t{ 0x15, 0x01 },  \n\t{ 0x16, 0x03 },\n\t{ 0x17, 0x38 },  \n\t{ 0x18, 0xea },  \n\t{ 0x19, 0x02 },  \n\t{ 0x1a, 0xf5 },\n\t{ 0x1b, 0x00 },\n\t{ 0x20, 0xd0 },  \n\t{ 0x23, 0xc0 },  \n\t{ 0x24, 0x30 },  \n\t{ 0x25, 0x50 },  \n\t{ 0x26, 0xa2 },\n\t{ 0x27, 0xea },\n\t{ 0x28, 0x00 },\n\t{ 0x29, 0x00 },\n\t{ 0x2a, 0x80 },\n\t{ 0x2b, 0xc8 },  \n\t{ 0x2c, 0xac },\n\t{ 0x2d, 0x45 },  \n\t{ 0x2e, 0x80 },\n\t{ 0x2f, 0x14 },  \n\t{ 0x4c, 0x00 },\n\t{ 0x4d, 0x30 },  \n\t{ 0x60, 0x02 },  \n\t{ 0x61, 0x00 },  \n\t{ 0x62, 0x5f },  \n\t{ 0x63, 0xff },\n\t{ 0x64, 0x53 },  \n\t{ 0x65, 0x00 },\n\t{ 0x66, 0x55 },\n\t{ 0x67, 0xb0 },\n\t{ 0x68, 0xc0 },  \n\t{ 0x69, 0x02 },\n\t{ 0x6a, 0x22 },\n\t{ 0x6b, 0x00 },\n\t{ 0x6c, 0x99 },  \n\t{ 0x6d, 0x11 },  \n\t{ 0x6e, 0x11 },  \n\t{ 0x6f, 0x01 },\n\t{ 0x70, 0x8b },\n\t{ 0x71, 0x00 },\n\t{ 0x72, 0x14 },\n\t{ 0x73, 0x54 },\n\t{ 0x74, 0x00 }, \n\t{ 0x75, 0x0e },\n\t{ 0x76, 0x02 },  \n\t{ 0x77, 0xff },\n\t{ 0x78, 0x80 },\n\t{ 0x79, 0x80 },\n\t{ 0x7a, 0x80 },\n\t{ 0x7b, 0x10 },  \n\t{ 0x7c, 0x00 },\n\t{ 0x7d, 0x08 },  \n\t{ 0x7e, 0x08 },  \n\t{ 0x7f, 0xfb },\n\t{ 0x80, 0x28 },\n\t{ 0x81, 0x00 },\n\t{ 0x82, 0x23 },\n\t{ 0x83, 0x0b },\n\t{ 0x84, 0x00 },\n\t{ 0x85, 0x62 },  \n\t{ 0x86, 0xc9 },\n\t{ 0x87, 0x00 },\n\t{ 0x88, 0x00 },\n\t{ 0x89, 0x01 },\n\t{ 0x12, 0x20 },\n\t{ 0x12, 0x25 },  \n};\n\nstatic unsigned char ov7670_abs_to_sm(unsigned char v)\n{\n\tif (v > 127)\n\t\treturn v & 0x7f;\n\treturn (128 - v) | 0x80;\n}\n\n \nstatic void reg_w(struct sd *sd, u16 index, u16 value)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint ret, req = 0;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn;\n\n\t \n\tudelay(150);\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\treq = 2;\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\treq = 0x0a;\n\t\tfallthrough;\n\tcase BRIDGE_W9968CF:\n\t\tgspca_dbg(gspca_dev, D_USBO, \"SET %02x %04x %04x\\n\",\n\t\t\t  req, value, index);\n\t\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_sndctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\treq,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tvalue, index, NULL, 0, 500);\n\t\tgoto leave;\n\tdefault:\n\t\treq = 1;\n\t}\n\n\tgspca_dbg(gspca_dev, D_USBO, \"SET %02x 0000 %04x %02x\\n\",\n\t\t  req, index, value);\n\tsd->gspca_dev.usb_buf[0] = value;\n\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_sndctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\treq,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, index,\n\t\t\tsd->gspca_dev.usb_buf, 1, 500);\nleave:\n\tif (ret < 0) {\n\t\tgspca_err(gspca_dev, \"reg_w %02x failed %d\\n\", index, ret);\n\t\tsd->gspca_dev.usb_err = ret;\n\t\treturn;\n\t}\n}\n\n \n \nstatic int reg_r(struct sd *sd, u16 index)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint ret;\n\tint req;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn -1;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\treq = 3;\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\treq = 0x0b;\n\t\tbreak;\n\tdefault:\n\t\treq = 1;\n\t}\n\n\t \n\tudelay(150);\n\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_rcvctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\treq,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, index, sd->gspca_dev.usb_buf, 1, 500);\n\n\tif (ret >= 0) {\n\t\tret = sd->gspca_dev.usb_buf[0];\n\t\tgspca_dbg(gspca_dev, D_USBI, \"GET %02x 0000 %04x %02x\\n\",\n\t\t\t  req, index, ret);\n\t} else {\n\t\tgspca_err(gspca_dev, \"reg_r %02x failed %d\\n\", index, ret);\n\t\tsd->gspca_dev.usb_err = ret;\n\t\t \n\t\tgspca_dev->usb_buf[0] = 0;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int reg_r8(struct sd *sd,\n\t\t  u16 index)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint ret;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn -1;\n\n\t \n\tudelay(150);\n\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_rcvctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\t1,\t\t\t \n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, index, sd->gspca_dev.usb_buf, 8, 500);\n\n\tif (ret >= 0) {\n\t\tret = sd->gspca_dev.usb_buf[0];\n\t} else {\n\t\tgspca_err(gspca_dev, \"reg_r8 %02x failed %d\\n\", index, ret);\n\t\tsd->gspca_dev.usb_err = ret;\n\t\t \n\t\tmemset(gspca_dev->usb_buf, 0, 8);\n\t}\n\n\treturn ret;\n}\n\n \nstatic void reg_w_mask(struct sd *sd,\n\t\t\tu16 index,\n\t\t\tu8 value,\n\t\t\tu8 mask)\n{\n\tint ret;\n\tu8 oldval;\n\n\tif (mask != 0xff) {\n\t\tvalue &= mask;\t\t\t \n\t\tret = reg_r(sd, index);\n\t\tif (ret < 0)\n\t\t\treturn;\n\n\t\toldval = ret & ~mask;\t\t \n\t\tvalue |= oldval;\t\t \n\t}\n\treg_w(sd, index, value);\n}\n\n \nstatic void ov518_reg_w32(struct sd *sd, u16 index, u32 value, int n)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint ret;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn;\n\n\t*((__le32 *) sd->gspca_dev.usb_buf) = __cpu_to_le32(value);\n\n\t \n\tudelay(150);\n\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_sndctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\t1  ,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, index,\n\t\t\tsd->gspca_dev.usb_buf, n, 500);\n\tif (ret < 0) {\n\t\tgspca_err(gspca_dev, \"reg_w32 %02x failed %d\\n\", index, ret);\n\t\tsd->gspca_dev.usb_err = ret;\n\t}\n}\n\nstatic void ov511_i2c_w(struct sd *sd, u8 reg, u8 value)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint rc, retries;\n\n\tgspca_dbg(gspca_dev, D_USBO, \"ov511_i2c_w %02x %02x\\n\", reg, value);\n\n\t \n\tfor (retries = 6; ; ) {\n\t\t \n\t\treg_w(sd, R51x_I2C_SADDR_3, reg);\n\n\t\t \n\t\treg_w(sd, R51x_I2C_DATA, value);\n\n\t\t \n\t\treg_w(sd, R511_I2C_CTL, 0x01);\n\n\t\tdo {\n\t\t\trc = reg_r(sd, R511_I2C_CTL);\n\t\t} while (rc > 0 && ((rc & 1) == 0));  \n\n\t\tif (rc < 0)\n\t\t\treturn;\n\n\t\tif ((rc & 2) == 0)  \n\t\t\tbreak;\n\t\tif (--retries < 0) {\n\t\t\tgspca_dbg(gspca_dev, D_USBO, \"i2c write retries exhausted\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int ov511_i2c_r(struct sd *sd, u8 reg)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint rc, value, retries;\n\n\t \n\tfor (retries = 6; ; ) {\n\t\t \n\t\treg_w(sd, R51x_I2C_SADDR_2, reg);\n\n\t\t \n\t\treg_w(sd, R511_I2C_CTL, 0x03);\n\n\t\tdo {\n\t\t\trc = reg_r(sd, R511_I2C_CTL);\n\t\t} while (rc > 0 && ((rc & 1) == 0));  \n\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif ((rc & 2) == 0)  \n\t\t\tbreak;\n\n\t\t \n\t\treg_w(sd, R511_I2C_CTL, 0x10);\n\n\t\tif (--retries < 0) {\n\t\t\tgspca_dbg(gspca_dev, D_USBI, \"i2c write retries exhausted\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tfor (retries = 6; ; ) {\n\t\t \n\t\treg_w(sd, R511_I2C_CTL, 0x05);\n\n\t\tdo {\n\t\t\trc = reg_r(sd, R511_I2C_CTL);\n\t\t} while (rc > 0 && ((rc & 1) == 0));  \n\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif ((rc & 2) == 0)  \n\t\t\tbreak;\n\n\t\t \n\t\treg_w(sd, R511_I2C_CTL, 0x10);\n\n\t\tif (--retries < 0) {\n\t\t\tgspca_dbg(gspca_dev, D_USBI, \"i2c read retries exhausted\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tvalue = reg_r(sd, R51x_I2C_DATA);\n\n\tgspca_dbg(gspca_dev, D_USBI, \"ov511_i2c_r %02x %02x\\n\", reg, value);\n\n\t \n\treg_w(sd, R511_I2C_CTL, 0x05);\n\n\treturn value;\n}\n\n \nstatic void ov518_i2c_w(struct sd *sd,\n\t\tu8 reg,\n\t\tu8 value)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tgspca_dbg(gspca_dev, D_USBO, \"ov518_i2c_w %02x %02x\\n\", reg, value);\n\n\t \n\treg_w(sd, R51x_I2C_SADDR_3, reg);\n\n\t \n\treg_w(sd, R51x_I2C_DATA, value);\n\n\t \n\treg_w(sd, R518_I2C_CTL, 0x01);\n\n\t \n\tmsleep(4);\n\treg_r8(sd, R518_I2C_CTL);\n}\n\n \nstatic int ov518_i2c_r(struct sd *sd, u8 reg)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint value;\n\n\t \n\treg_w(sd, R51x_I2C_SADDR_2, reg);\n\n\t \n\treg_w(sd, R518_I2C_CTL, 0x03);\n\treg_r8(sd, R518_I2C_CTL);\n\n\t \n\treg_w(sd, R518_I2C_CTL, 0x05);\n\treg_r8(sd, R518_I2C_CTL);\n\n\tvalue = reg_r(sd, R51x_I2C_DATA);\n\tgspca_dbg(gspca_dev, D_USBI, \"ov518_i2c_r %02x %02x\\n\", reg, value);\n\treturn value;\n}\n\nstatic void ovfx2_i2c_w(struct sd *sd, u8 reg, u8 value)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint ret;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn;\n\n\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_sndctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\t0x02,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t(u16) value, (u16) reg, NULL, 0, 500);\n\n\tif (ret < 0) {\n\t\tgspca_err(gspca_dev, \"ovfx2_i2c_w %02x failed %d\\n\", reg, ret);\n\t\tsd->gspca_dev.usb_err = ret;\n\t}\n\n\tgspca_dbg(gspca_dev, D_USBO, \"ovfx2_i2c_w %02x %02x\\n\", reg, value);\n}\n\nstatic int ovfx2_i2c_r(struct sd *sd, u8 reg)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint ret;\n\n\tif (sd->gspca_dev.usb_err < 0)\n\t\treturn -1;\n\n\tret = usb_control_msg(sd->gspca_dev.dev,\n\t\t\tusb_rcvctrlpipe(sd->gspca_dev.dev, 0),\n\t\t\t0x03,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, (u16) reg, sd->gspca_dev.usb_buf, 1, 500);\n\n\tif (ret >= 0) {\n\t\tret = sd->gspca_dev.usb_buf[0];\n\t\tgspca_dbg(gspca_dev, D_USBI, \"ovfx2_i2c_r %02x %02x\\n\",\n\t\t\t  reg, ret);\n\t} else {\n\t\tgspca_err(gspca_dev, \"ovfx2_i2c_r %02x failed %d\\n\", reg, ret);\n\t\tsd->gspca_dev.usb_err = ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void i2c_w(struct sd *sd, u8 reg, u8 value)\n{\n\tif (sd->sensor_reg_cache[reg] == value)\n\t\treturn;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tov511_i2c_w(sd, reg, value);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\tcase BRIDGE_OV519:\n\t\tov518_i2c_w(sd, reg, value);\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\tovfx2_i2c_w(sd, reg, value);\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\tw9968cf_i2c_w(sd, reg, value);\n\t\tbreak;\n\t}\n\n\tif (sd->gspca_dev.usb_err >= 0) {\n\t\t \n\t\tif (reg == 0x12 && (value & 0x80))\n\t\t\tmemset(sd->sensor_reg_cache, -1,\n\t\t\t\tsizeof(sd->sensor_reg_cache));\n\t\telse\n\t\t\tsd->sensor_reg_cache[reg] = value;\n\t}\n}\n\nstatic int i2c_r(struct sd *sd, u8 reg)\n{\n\tint ret = -1;\n\n\tif (sd->sensor_reg_cache[reg] != -1)\n\t\treturn sd->sensor_reg_cache[reg];\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tret = ov511_i2c_r(sd, reg);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\tcase BRIDGE_OV519:\n\t\tret = ov518_i2c_r(sd, reg);\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\tret = ovfx2_i2c_r(sd, reg);\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\tret = w9968cf_i2c_r(sd, reg);\n\t\tbreak;\n\t}\n\n\tif (ret >= 0)\n\t\tsd->sensor_reg_cache[reg] = ret;\n\n\treturn ret;\n}\n\n \nstatic void i2c_w_mask(struct sd *sd,\n\t\t\tu8 reg,\n\t\t\tu8 value,\n\t\t\tu8 mask)\n{\n\tint rc;\n\tu8 oldval;\n\n\tvalue &= mask;\t\t\t \n\trc = i2c_r(sd, reg);\n\tif (rc < 0)\n\t\treturn;\n\toldval = rc & ~mask;\t\t \n\tvalue |= oldval;\t\t \n\ti2c_w(sd, reg, value);\n}\n\n \nstatic inline void ov51x_stop(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"stopping\\n\");\n\tsd->stopped = 1;\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\treg_w(sd, R51x_SYS_RESET, 0x3d);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\treg_w_mask(sd, R51x_SYS_RESET, 0x3a, 0x3a);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\treg_w(sd, OV519_R51_RESET1, 0x0f);\n\t\treg_w(sd, OV519_R51_RESET1, 0x00);\n\t\treg_w(sd, 0x22, 0x00);\t\t \n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\treg_w_mask(sd, 0x0f, 0x00, 0x02);\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\treg_w(sd, 0x3c, 0x0a05);  \n\t\tbreak;\n\t}\n}\n\n \nstatic inline void ov51x_restart(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"restarting\\n\");\n\tif (!sd->stopped)\n\t\treturn;\n\tsd->stopped = 0;\n\n\t \n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\treg_w(sd, R51x_SYS_RESET, 0x00);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\treg_w(sd, 0x2f, 0x80);\n\t\treg_w(sd, R51x_SYS_RESET, 0x00);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\treg_w(sd, OV519_R51_RESET1, 0x0f);\n\t\treg_w(sd, OV519_R51_RESET1, 0x00);\n\t\treg_w(sd, 0x22, 0x1d);\t\t \n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\treg_w_mask(sd, 0x0f, 0x02, 0x02);\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\treg_w(sd, 0x3c, 0x8a05);  \n\t\tbreak;\n\t}\n}\n\nstatic void ov51x_set_slave_ids(struct sd *sd, u8 slave);\n\n \nstatic int init_ov_sensor(struct sd *sd, u8 slave)\n{\n\tint i;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tov51x_set_slave_ids(sd, slave);\n\n\t \n\ti2c_w(sd, 0x12, 0x80);\n\n\t \n\tmsleep(150);\n\n\tfor (i = 0; i < i2c_detect_tries; i++) {\n\t\tif (i2c_r(sd, OV7610_REG_ID_HIGH) == 0x7f &&\n\t\t    i2c_r(sd, OV7610_REG_ID_LOW) == 0xa2) {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"I2C synced in %d attempt(s)\\n\",\n\t\t\t\t  i);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\ti2c_w(sd, 0x12, 0x80);\n\n\t\t \n\t\tmsleep(150);\n\n\t\t \n\t\tif (i2c_r(sd, 0x00) < 0)\n\t\t\treturn -1;\n\t}\n\treturn -1;\n}\n\n \nstatic void ov51x_set_slave_ids(struct sd *sd,\n\t\t\t\tu8 slave)\n{\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OVFX2:\n\t\treg_w(sd, OVFX2_I2C_ADDR, slave);\n\t\treturn;\n\tcase BRIDGE_W9968CF:\n\t\tsd->sensor_addr = slave;\n\t\treturn;\n\t}\n\n\treg_w(sd, R51x_I2C_W_SID, slave);\n\treg_w(sd, R51x_I2C_R_SID, slave + 1);\n}\n\nstatic void write_regvals(struct sd *sd,\n\t\t\t const struct ov_regvals *regvals,\n\t\t\t int n)\n{\n\twhile (--n >= 0) {\n\t\treg_w(sd, regvals->reg, regvals->val);\n\t\tregvals++;\n\t}\n}\n\nstatic void write_i2c_regvals(struct sd *sd,\n\t\t\tconst struct ov_i2c_regvals *regvals,\n\t\t\tint n)\n{\n\twhile (--n >= 0) {\n\t\ti2c_w(sd, regvals->reg, regvals->val);\n\t\tregvals++;\n\t}\n}\n\n \n\n \nstatic void ov_hires_configure(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint high, low;\n\n\tif (sd->bridge != BRIDGE_OVFX2) {\n\t\tgspca_err(gspca_dev, \"error hires sensors only supported with ovfx2\\n\");\n\t\treturn;\n\t}\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"starting ov hires configuration\\n\");\n\n\t \n\thigh = i2c_r(sd, 0x0a);\n\tlow = i2c_r(sd, 0x0b);\n\t \n\tswitch (high) {\n\tcase 0x96:\n\t\tswitch (low) {\n\t\tcase 0x40:\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is a OV2610\\n\");\n\t\t\tsd->sensor = SEN_OV2610;\n\t\t\treturn;\n\t\tcase 0x41:\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is a OV2610AE\\n\");\n\t\t\tsd->sensor = SEN_OV2610AE;\n\t\t\treturn;\n\t\tcase 0xb1:\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is a OV9600\\n\");\n\t\t\tsd->sensor = SEN_OV9600;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase 0x36:\n\t\tif ((low & 0x0f) == 0x00) {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is a OV3610\\n\");\n\t\t\tsd->sensor = SEN_OV3610;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\tgspca_err(gspca_dev, \"Error unknown sensor type: %02x%02x\\n\",\n\t\t  high, low);\n}\n\n \nstatic void ov8xx0_configure(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint rc;\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"starting ov8xx0 configuration\\n\");\n\n\t \n\trc = i2c_r(sd, OV7610_REG_COM_I);\n\tif (rc < 0) {\n\t\tgspca_err(gspca_dev, \"Error detecting sensor type\\n\");\n\t\treturn;\n\t}\n\tif ((rc & 3) == 1)\n\t\tsd->sensor = SEN_OV8610;\n\telse\n\t\tgspca_err(gspca_dev, \"Unknown image sensor version: %d\\n\",\n\t\t\t  rc & 3);\n}\n\n \nstatic void ov7xx0_configure(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint rc, high, low;\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"starting OV7xx0 configuration\\n\");\n\n\t \n\trc = i2c_r(sd, OV7610_REG_COM_I);\n\n\t \n\tif (rc < 0) {\n\t\tgspca_err(gspca_dev, \"Error detecting sensor type\\n\");\n\t\treturn;\n\t}\n\tif ((rc & 3) == 3) {\n\t\t \n\t\thigh = i2c_r(sd, 0x0a);\n\t\tlow = i2c_r(sd, 0x0b);\n\t\t \n\t\tif (high == 0x76 && (low & 0xf0) == 0x70) {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV76%02x\\n\",\n\t\t\t\t  low);\n\t\t\tsd->sensor = SEN_OV7670;\n\t\t} else {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV7610\\n\");\n\t\t\tsd->sensor = SEN_OV7610;\n\t\t}\n\t} else if ((rc & 3) == 1) {\n\t\t \n\t\tif (i2c_r(sd, 0x15) & 1) {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV7620AE\\n\");\n\t\t\tsd->sensor = SEN_OV7620AE;\n\t\t} else {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV76BE\\n\");\n\t\t\tsd->sensor = SEN_OV76BE;\n\t\t}\n\t} else if ((rc & 3) == 0) {\n\t\t \n\t\thigh = i2c_r(sd, 0x0a);\n\t\tif (high < 0) {\n\t\t\tgspca_err(gspca_dev, \"Error detecting camera chip PID\\n\");\n\t\t\treturn;\n\t\t}\n\t\tlow = i2c_r(sd, 0x0b);\n\t\tif (low < 0) {\n\t\t\tgspca_err(gspca_dev, \"Error detecting camera chip VER\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (high == 0x76) {\n\t\t\tswitch (low) {\n\t\t\tcase 0x30:\n\t\t\t\tgspca_err(gspca_dev, \"Sensor is an OV7630/OV7635\\n\");\n\t\t\t\tgspca_err(gspca_dev, \"7630 is not supported by this driver\\n\");\n\t\t\t\treturn;\n\t\t\tcase 0x40:\n\t\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV7645\\n\");\n\t\t\t\tsd->sensor = SEN_OV7640;  \n\t\t\t\tbreak;\n\t\t\tcase 0x45:\n\t\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV7645B\\n\");\n\t\t\t\tsd->sensor = SEN_OV7640;  \n\t\t\t\tbreak;\n\t\t\tcase 0x48:\n\t\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV7648\\n\");\n\t\t\t\tsd->sensor = SEN_OV7648;\n\t\t\t\tbreak;\n\t\t\tcase 0x60:\n\t\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is a OV7660\\n\");\n\t\t\t\tsd->sensor = SEN_OV7660;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgspca_err(gspca_dev, \"Unknown sensor: 0x76%02x\\n\",\n\t\t\t\t\t  low);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV7620\\n\");\n\t\t\tsd->sensor = SEN_OV7620;\n\t\t}\n\t} else {\n\t\tgspca_err(gspca_dev, \"Unknown image sensor version: %d\\n\",\n\t\t\t  rc & 3);\n\t}\n}\n\n \nstatic void ov6xx0_configure(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint rc;\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"starting OV6xx0 configuration\\n\");\n\n\t \n\trc = i2c_r(sd, OV7610_REG_COM_I);\n\tif (rc < 0) {\n\t\tgspca_err(gspca_dev, \"Error detecting sensor type\\n\");\n\t\treturn;\n\t}\n\n\t \n\tswitch (rc) {\n\tcase 0x00:\n\t\tsd->sensor = SEN_OV6630;\n\t\tpr_warn(\"WARNING: Sensor is an OV66308. Your camera may have been misdetected in previous driver versions.\\n\");\n\t\tbreak;\n\tcase 0x01:\n\t\tsd->sensor = SEN_OV6620;\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV6620\\n\");\n\t\tbreak;\n\tcase 0x02:\n\t\tsd->sensor = SEN_OV6630;\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV66308AE\\n\");\n\t\tbreak;\n\tcase 0x03:\n\t\tsd->sensor = SEN_OV66308AF;\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor is an OV66308AF\\n\");\n\t\tbreak;\n\tcase 0x90:\n\t\tsd->sensor = SEN_OV6630;\n\t\tpr_warn(\"WARNING: Sensor is an OV66307. Your camera may have been misdetected in previous driver versions.\\n\");\n\t\tbreak;\n\tdefault:\n\t\tgspca_err(gspca_dev, \"FATAL: Unknown sensor version: 0x%02x\\n\",\n\t\t\t  rc);\n\t\treturn;\n\t}\n\n\t \n\tsd->sif = 1;\n}\n\n \nstatic void ov51x_led_control(struct sd *sd, int on)\n{\n\tif (sd->invert_led)\n\t\ton = !on;\n\n\tswitch (sd->bridge) {\n\t \n\tcase BRIDGE_OV511PLUS:\n\t\treg_w(sd, R511_SYS_LED_CTL, on);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\treg_w_mask(sd, R518_GPIO_OUT, 0x02 * on, 0x02);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\treg_w_mask(sd, OV519_GPIO_DATA_OUT0, on, 1);\n\t\tbreak;\n\t}\n}\n\nstatic void sd_reset_snapshot(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (!sd->snapshot_needs_reset)\n\t\treturn;\n\n\t \n\tsd->snapshot_needs_reset = 0;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\treg_w(sd, R51x_SYS_SNAP, 0x02);\n\t\treg_w(sd, R51x_SYS_SNAP, 0x00);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\treg_w(sd, R51x_SYS_SNAP, 0x02);  \n\t\treg_w(sd, R51x_SYS_SNAP, 0x01);  \n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\treg_w(sd, R51x_SYS_RESET, 0x40);\n\t\treg_w(sd, R51x_SYS_RESET, 0x00);\n\t\tbreak;\n\t}\n}\n\nstatic void ov51x_upload_quan_tables(struct sd *sd)\n{\n\tstatic const unsigned char yQuanTable511[] = {\n\t\t0, 1, 1, 2, 2, 3, 3, 4,\n\t\t1, 1, 1, 2, 2, 3, 4, 4,\n\t\t1, 1, 2, 2, 3, 4, 4, 4,\n\t\t2, 2, 2, 3, 4, 4, 4, 4,\n\t\t2, 2, 3, 4, 4, 5, 5, 5,\n\t\t3, 3, 4, 4, 5, 5, 5, 5,\n\t\t3, 4, 4, 4, 5, 5, 5, 5,\n\t\t4, 4, 4, 4, 5, 5, 5, 5\n\t};\n\n\tstatic const unsigned char uvQuanTable511[] = {\n\t\t0, 2, 2, 3, 4, 4, 4, 4,\n\t\t2, 2, 2, 4, 4, 4, 4, 4,\n\t\t2, 2, 3, 4, 4, 4, 4, 4,\n\t\t3, 4, 4, 4, 4, 4, 4, 4,\n\t\t4, 4, 4, 4, 4, 4, 4, 4,\n\t\t4, 4, 4, 4, 4, 4, 4, 4,\n\t\t4, 4, 4, 4, 4, 4, 4, 4,\n\t\t4, 4, 4, 4, 4, 4, 4, 4\n\t};\n\n\t \n\tstatic const unsigned char yQuanTable518[] = {\n\t\t5, 4, 5, 6, 6, 7, 7, 7,\n\t\t5, 5, 5, 5, 6, 7, 7, 7,\n\t\t6, 6, 6, 6, 7, 7, 7, 8,\n\t\t7, 7, 6, 7, 7, 7, 8, 8\n\t};\n\tstatic const unsigned char uvQuanTable518[] = {\n\t\t6, 6, 6, 7, 7, 7, 7, 7,\n\t\t6, 6, 6, 7, 7, 7, 7, 7,\n\t\t6, 6, 6, 7, 7, 7, 7, 8,\n\t\t7, 7, 7, 7, 7, 7, 8, 8\n\t};\n\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tconst unsigned char *pYTable, *pUVTable;\n\tunsigned char val0, val1;\n\tint i, size, reg = R51x_COMP_LUT_BEGIN;\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"Uploading quantization tables\\n\");\n\n\tif (sd->bridge == BRIDGE_OV511 || sd->bridge == BRIDGE_OV511PLUS) {\n\t\tpYTable = yQuanTable511;\n\t\tpUVTable = uvQuanTable511;\n\t\tsize = 32;\n\t} else {\n\t\tpYTable = yQuanTable518;\n\t\tpUVTable = uvQuanTable518;\n\t\tsize = 16;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tval0 = *pYTable++;\n\t\tval1 = *pYTable++;\n\t\tval0 &= 0x0f;\n\t\tval1 &= 0x0f;\n\t\tval0 |= val1 << 4;\n\t\treg_w(sd, reg, val0);\n\n\t\tval0 = *pUVTable++;\n\t\tval1 = *pUVTable++;\n\t\tval0 &= 0x0f;\n\t\tval1 &= 0x0f;\n\t\tval0 |= val1 << 4;\n\t\treg_w(sd, reg + size, val0);\n\n\t\treg++;\n\t}\n}\n\n \nstatic void ov511_configure(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t \n\tstatic const struct ov_regvals init_511[] = {\n\t\t{ R51x_SYS_RESET,\t0x7f },\n\t\t{ R51x_SYS_INIT,\t0x01 },\n\t\t{ R51x_SYS_RESET,\t0x7f },\n\t\t{ R51x_SYS_INIT,\t0x01 },\n\t\t{ R51x_SYS_RESET,\t0x3f },\n\t\t{ R51x_SYS_INIT,\t0x01 },\n\t\t{ R51x_SYS_RESET,\t0x3d },\n\t};\n\n\tstatic const struct ov_regvals norm_511[] = {\n\t\t{ R511_DRAM_FLOW_CTL,\t0x01 },\n\t\t{ R51x_SYS_SNAP,\t0x00 },\n\t\t{ R51x_SYS_SNAP,\t0x02 },\n\t\t{ R51x_SYS_SNAP,\t0x00 },\n\t\t{ R511_FIFO_OPTS,\t0x1f },\n\t\t{ R511_COMP_EN,\t\t0x00 },\n\t\t{ R511_COMP_LUT_EN,\t0x03 },\n\t};\n\n\tstatic const struct ov_regvals norm_511_p[] = {\n\t\t{ R511_DRAM_FLOW_CTL,\t0xff },\n\t\t{ R51x_SYS_SNAP,\t0x00 },\n\t\t{ R51x_SYS_SNAP,\t0x02 },\n\t\t{ R51x_SYS_SNAP,\t0x00 },\n\t\t{ R511_FIFO_OPTS,\t0xff },\n\t\t{ R511_COMP_EN,\t\t0x00 },\n\t\t{ R511_COMP_LUT_EN,\t0x03 },\n\t};\n\n\tstatic const struct ov_regvals compress_511[] = {\n\t\t{ 0x70, 0x1f },\n\t\t{ 0x71, 0x05 },\n\t\t{ 0x72, 0x06 },\n\t\t{ 0x73, 0x06 },\n\t\t{ 0x74, 0x14 },\n\t\t{ 0x75, 0x03 },\n\t\t{ 0x76, 0x04 },\n\t\t{ 0x77, 0x04 },\n\t};\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"Device custom id %x\\n\",\n\t\t  reg_r(sd, R51x_SYS_CUST_ID));\n\n\twrite_regvals(sd, init_511, ARRAY_SIZE(init_511));\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\t\twrite_regvals(sd, norm_511, ARRAY_SIZE(norm_511));\n\t\tbreak;\n\tcase BRIDGE_OV511PLUS:\n\t\twrite_regvals(sd, norm_511_p, ARRAY_SIZE(norm_511_p));\n\t\tbreak;\n\t}\n\n\t \n\twrite_regvals(sd, compress_511, ARRAY_SIZE(compress_511));\n\n\tov51x_upload_quan_tables(sd);\n}\n\n \nstatic void ov518_configure(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t \n\tstatic const struct ov_regvals init_518[] = {\n\t\t{ R51x_SYS_RESET,\t0x40 },\n\t\t{ R51x_SYS_INIT,\t0xe1 },\n\t\t{ R51x_SYS_RESET,\t0x3e },\n\t\t{ R51x_SYS_INIT,\t0xe1 },\n\t\t{ R51x_SYS_RESET,\t0x00 },\n\t\t{ R51x_SYS_INIT,\t0xe1 },\n\t\t{ 0x46,\t\t\t0x00 },\n\t\t{ 0x5d,\t\t\t0x03 },\n\t};\n\n\tstatic const struct ov_regvals norm_518[] = {\n\t\t{ R51x_SYS_SNAP,\t0x02 },  \n\t\t{ R51x_SYS_SNAP,\t0x01 },  \n\t\t{ 0x31,\t\t\t0x0f },\n\t\t{ 0x5d,\t\t\t0x03 },\n\t\t{ 0x24,\t\t\t0x9f },\n\t\t{ 0x25,\t\t\t0x90 },\n\t\t{ 0x20,\t\t\t0x00 },\n\t\t{ 0x51,\t\t\t0x04 },\n\t\t{ 0x71,\t\t\t0x19 },\n\t\t{ 0x2f,\t\t\t0x80 },\n\t};\n\n\tstatic const struct ov_regvals norm_518_p[] = {\n\t\t{ R51x_SYS_SNAP,\t0x02 },  \n\t\t{ R51x_SYS_SNAP,\t0x01 },  \n\t\t{ 0x31,\t\t\t0x0f },\n\t\t{ 0x5d,\t\t\t0x03 },\n\t\t{ 0x24,\t\t\t0x9f },\n\t\t{ 0x25,\t\t\t0x90 },\n\t\t{ 0x20,\t\t\t0x60 },\n\t\t{ 0x51,\t\t\t0x02 },\n\t\t{ 0x71,\t\t\t0x19 },\n\t\t{ 0x40,\t\t\t0xff },\n\t\t{ 0x41,\t\t\t0x42 },\n\t\t{ 0x46,\t\t\t0x00 },\n\t\t{ 0x33,\t\t\t0x04 },\n\t\t{ 0x21,\t\t\t0x19 },\n\t\t{ 0x3f,\t\t\t0x10 },\n\t\t{ 0x2f,\t\t\t0x80 },\n\t};\n\n\t \n\tsd->revision = reg_r(sd, R51x_SYS_CUST_ID) & 0x1f;\n\tgspca_dbg(gspca_dev, D_PROBE, \"Device revision %d\\n\", sd->revision);\n\n\twrite_regvals(sd, init_518, ARRAY_SIZE(init_518));\n\n\t \n\treg_w_mask(sd, R518_GPIO_CTL, 0x00, 0x02);\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV518:\n\t\twrite_regvals(sd, norm_518, ARRAY_SIZE(norm_518));\n\t\tbreak;\n\tcase BRIDGE_OV518PLUS:\n\t\twrite_regvals(sd, norm_518_p, ARRAY_SIZE(norm_518_p));\n\t\tbreak;\n\t}\n\n\tov51x_upload_quan_tables(sd);\n\n\treg_w(sd, 0x2f, 0x80);\n}\n\nstatic void ov519_configure(struct sd *sd)\n{\n\tstatic const struct ov_regvals init_519[] = {\n\t\t{ 0x5a, 0x6d },  \n\t\t{ 0x53, 0x9b },  \n\t\t{ OV519_R54_EN_CLK1, 0xff },  \n\t\t{ 0x5d, 0x03 },\n\t\t{ 0x49, 0x01 },\n\t\t{ 0x48, 0x00 },\n\t\t \n\t\t{ OV519_GPIO_IO_CTRL0,   0xee },\n\t\t{ OV519_R51_RESET1, 0x0f },\n\t\t{ OV519_R51_RESET1, 0x00 },\n\t\t{ 0x22, 0x00 },\n\t\t \n\t};\n\n\twrite_regvals(sd, init_519, ARRAY_SIZE(init_519));\n}\n\nstatic void ovfx2_configure(struct sd *sd)\n{\n\tstatic const struct ov_regvals init_fx2[] = {\n\t\t{ 0x00, 0x60 },\n\t\t{ 0x02, 0x01 },\n\t\t{ 0x0f, 0x1d },\n\t\t{ 0xe9, 0x82 },\n\t\t{ 0xea, 0xc7 },\n\t\t{ 0xeb, 0x10 },\n\t\t{ 0xec, 0xf6 },\n\t};\n\n\tsd->stopped = 1;\n\n\twrite_regvals(sd, init_fx2, ARRAY_SIZE(init_fx2));\n}\n\n \n \nstatic void ov519_set_mode(struct sd *sd)\n{\n\tstatic const struct ov_regvals bridge_ov7660[2][10] = {\n\t\t{{0x10, 0x14}, {0x11, 0x1e}, {0x12, 0x00}, {0x13, 0x00},\n\t\t {0x14, 0x00}, {0x15, 0x00}, {0x16, 0x00}, {0x20, 0x0c},\n\t\t {0x25, 0x01}, {0x26, 0x00}},\n\t\t{{0x10, 0x28}, {0x11, 0x3c}, {0x12, 0x00}, {0x13, 0x00},\n\t\t {0x14, 0x00}, {0x15, 0x00}, {0x16, 0x00}, {0x20, 0x0c},\n\t\t {0x25, 0x03}, {0x26, 0x00}}\n\t};\n\tstatic const struct ov_i2c_regvals sensor_ov7660[2][3] = {\n\t\t{{0x12, 0x00}, {0x24, 0x00}, {0x0c, 0x0c}},\n\t\t{{0x12, 0x00}, {0x04, 0x00}, {0x0c, 0x00}}\n\t};\n\tstatic const struct ov_i2c_regvals sensor_ov7660_2[] = {\n\t\t{OV7670_R17_HSTART, 0x13},\n\t\t{OV7670_R18_HSTOP, 0x01},\n\t\t{OV7670_R32_HREF, 0x92},\n\t\t{OV7670_R19_VSTART, 0x02},\n\t\t{OV7670_R1A_VSTOP, 0x7a},\n\t\t{OV7670_R03_VREF, 0x00},\n \n \n \n \n\t};\n\n\twrite_regvals(sd, bridge_ov7660[sd->gspca_dev.curr_mode],\n\t\t\tARRAY_SIZE(bridge_ov7660[0]));\n\twrite_i2c_regvals(sd, sensor_ov7660[sd->gspca_dev.curr_mode],\n\t\t\tARRAY_SIZE(sensor_ov7660[0]));\n\twrite_i2c_regvals(sd, sensor_ov7660_2,\n\t\t\tARRAY_SIZE(sensor_ov7660_2));\n}\n\n \n \nstatic void ov519_set_fr(struct sd *sd)\n{\n\tint fr;\n\tu8 clock;\n\t \n\tstatic const u8 fr_tb[2][6][3] = {\n\t\t{{0x04, 0xff, 0x00},\n\t\t {0x04, 0x1f, 0x00},\n\t\t {0x04, 0x1b, 0x00},\n\t\t {0x04, 0x15, 0x00},\n\t\t {0x04, 0x09, 0x00},\n\t\t {0x04, 0x01, 0x00}},\n\t\t{{0x0c, 0xff, 0x00},\n\t\t {0x0c, 0x1f, 0x00},\n\t\t {0x0c, 0x1b, 0x00},\n\t\t {0x04, 0xff, 0x01},\n\t\t {0x04, 0x1f, 0x01},\n\t\t {0x04, 0x1b, 0x01}},\n\t};\n\n\tif (frame_rate > 0)\n\t\tsd->frame_rate = frame_rate;\n\tif (sd->frame_rate >= 30)\n\t\tfr = 0;\n\telse if (sd->frame_rate >= 25)\n\t\tfr = 1;\n\telse if (sd->frame_rate >= 20)\n\t\tfr = 2;\n\telse if (sd->frame_rate >= 15)\n\t\tfr = 3;\n\telse if (sd->frame_rate >= 10)\n\t\tfr = 4;\n\telse\n\t\tfr = 5;\n\treg_w(sd, 0xa4, fr_tb[sd->gspca_dev.curr_mode][fr][0]);\n\treg_w(sd, 0x23, fr_tb[sd->gspca_dev.curr_mode][fr][1]);\n\tclock = fr_tb[sd->gspca_dev.curr_mode][fr][2];\n\tif (sd->sensor == SEN_OV7660)\n\t\tclock |= 0x80;\t\t \n\tov518_i2c_w(sd, OV7670_R11_CLKRC, clock);\n}\n\nstatic void setautogain(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\ti2c_w_mask(sd, 0x13, val ? 0x05 : 0x00, 0x05);\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam = &gspca_dev->cam;\n\n\tsd->bridge = id->driver_info & BRIDGE_MASK;\n\tsd->invert_led = (id->driver_info & BRIDGE_INVERT_LED) != 0;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tcam->cam_mode = ov511_vga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(ov511_vga_mode);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\tcam->cam_mode = ov518_vga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(ov518_vga_mode);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\tcam->cam_mode = ov519_vga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(ov519_vga_mode);\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\tcam->cam_mode = ov519_vga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(ov519_vga_mode);\n\t\tcam->bulk_size = OVFX2_BULK_SIZE;\n\t\tcam->bulk_nurbs = MAX_NURBS;\n\t\tcam->bulk = 1;\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\tcam->cam_mode = w9968cf_vga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(w9968cf_vga_mode);\n\t\tbreak;\n\t}\n\n\tsd->frame_rate = 15;\n\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam = &gspca_dev->cam;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tov511_configure(gspca_dev);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\tov518_configure(gspca_dev);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\tov519_configure(sd);\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\tovfx2_configure(sd);\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\tw9968cf_configure(sd);\n\t\tbreak;\n\t}\n\n\t \n\tsd->sensor = -1;\n\n\t \n\tif (init_ov_sensor(sd, OV7xx0_SID) >= 0) {\n\t\tov7xx0_configure(sd);\n\n\t \n\t} else if (init_ov_sensor(sd, OV6xx0_SID) >= 0) {\n\t\tov6xx0_configure(sd);\n\n\t \n\t} else if (init_ov_sensor(sd, OV8xx0_SID) >= 0) {\n\t\tov8xx0_configure(sd);\n\n\t \n\t} else if (init_ov_sensor(sd, OV_HIRES_SID) >= 0) {\n\t\tov_hires_configure(sd);\n\t} else {\n\t\tgspca_err(gspca_dev, \"Can't determine sensor slave IDs\\n\");\n\t\tgoto error;\n\t}\n\n\tif (sd->sensor < 0)\n\t\tgoto error;\n\n\tov51x_led_control(sd, 0);\t \n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tif (sd->sif) {\n\t\t\tcam->cam_mode = ov511_sif_mode;\n\t\t\tcam->nmodes = ARRAY_SIZE(ov511_sif_mode);\n\t\t}\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\tif (sd->sif) {\n\t\t\tcam->cam_mode = ov518_sif_mode;\n\t\t\tcam->nmodes = ARRAY_SIZE(ov518_sif_mode);\n\t\t}\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\tif (sd->sif) {\n\t\t\tcam->cam_mode = ov519_sif_mode;\n\t\t\tcam->nmodes = ARRAY_SIZE(ov519_sif_mode);\n\t\t}\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\tswitch (sd->sensor) {\n\t\tcase SEN_OV2610:\n\t\tcase SEN_OV2610AE:\n\t\t\tcam->cam_mode = ovfx2_ov2610_mode;\n\t\t\tcam->nmodes = ARRAY_SIZE(ovfx2_ov2610_mode);\n\t\t\tbreak;\n\t\tcase SEN_OV3610:\n\t\t\tcam->cam_mode = ovfx2_ov3610_mode;\n\t\t\tcam->nmodes = ARRAY_SIZE(ovfx2_ov3610_mode);\n\t\t\tbreak;\n\t\tcase SEN_OV9600:\n\t\t\tcam->cam_mode = ovfx2_ov9600_mode;\n\t\t\tcam->nmodes = ARRAY_SIZE(ovfx2_ov9600_mode);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (sd->sif) {\n\t\t\t\tcam->cam_mode = ov519_sif_mode;\n\t\t\t\tcam->nmodes = ARRAY_SIZE(ov519_sif_mode);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\tif (sd->sif)\n\t\t\tcam->nmodes = ARRAY_SIZE(w9968cf_vga_mode) - 1;\n\n\t\t \n\t\tw9968cf_init(sd);\n\t\tbreak;\n\t}\n\n\t \n\tswitch (sd->sensor) {\n\tcase SEN_OV2610:\n\t\twrite_i2c_regvals(sd, norm_2610, ARRAY_SIZE(norm_2610));\n\n\t\t \n\t\ti2c_w_mask(sd, 0x13, 0x27, 0x27);\n\t\tbreak;\n\tcase SEN_OV2610AE:\n\t\twrite_i2c_regvals(sd, norm_2610ae, ARRAY_SIZE(norm_2610ae));\n\n\t\t \n\t\ti2c_w_mask(sd, 0x13, 0x05, 0x05);\n\t\tbreak;\n\tcase SEN_OV3610:\n\t\twrite_i2c_regvals(sd, norm_3620b, ARRAY_SIZE(norm_3620b));\n\n\t\t \n\t\ti2c_w_mask(sd, 0x13, 0x27, 0x27);\n\t\tbreak;\n\tcase SEN_OV6620:\n\t\twrite_i2c_regvals(sd, norm_6x20, ARRAY_SIZE(norm_6x20));\n\t\tbreak;\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\t\twrite_i2c_regvals(sd, norm_6x30, ARRAY_SIZE(norm_6x30));\n\t\tbreak;\n\tdefault:\n \n \n\t\twrite_i2c_regvals(sd, norm_7610, ARRAY_SIZE(norm_7610));\n\t\ti2c_w_mask(sd, 0x0e, 0x00, 0x40);\n\t\tbreak;\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\t\twrite_i2c_regvals(sd, norm_7620, ARRAY_SIZE(norm_7620));\n\t\tbreak;\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\t\twrite_i2c_regvals(sd, norm_7640, ARRAY_SIZE(norm_7640));\n\t\tbreak;\n\tcase SEN_OV7660:\n\t\ti2c_w(sd, OV7670_R12_COM7, OV7670_COM7_RESET);\n\t\tmsleep(14);\n\t\treg_w(sd, OV519_R57_SNAPSHOT, 0x23);\n\t\twrite_regvals(sd, init_519_ov7660,\n\t\t\t\tARRAY_SIZE(init_519_ov7660));\n\t\twrite_i2c_regvals(sd, norm_7660, ARRAY_SIZE(norm_7660));\n\t\tsd->gspca_dev.curr_mode = 1;\t \n\t\tov519_set_mode(sd);\n\t\tov519_set_fr(sd);\n\t\tsd_reset_snapshot(gspca_dev);\n\t\tov51x_restart(sd);\n\t\tov51x_stop(sd);\t\t\t \n\t\tov51x_led_control(sd, 0);\n\t\tbreak;\n\tcase SEN_OV7670:\n\t\twrite_i2c_regvals(sd, norm_7670, ARRAY_SIZE(norm_7670));\n\t\tbreak;\n\tcase SEN_OV8610:\n\t\twrite_i2c_regvals(sd, norm_8610, ARRAY_SIZE(norm_8610));\n\t\tbreak;\n\tcase SEN_OV9600:\n\t\twrite_i2c_regvals(sd, norm_9600, ARRAY_SIZE(norm_9600));\n\n\t\t \n \n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\nerror:\n\tgspca_err(gspca_dev, \"OV519 Config failed\\n\");\n\treturn -EINVAL;\n}\n\n \nstatic int sd_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OVFX2:\n\t\tif (gspca_dev->pixfmt.width != 800)\n\t\t\tgspca_dev->cam.bulk_size = OVFX2_BULK_SIZE;\n\t\telse\n\t\t\tgspca_dev->cam.bulk_size = 7 * 4096;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic void ov511_mode_init_regs(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint hsegs, vsegs, packet_size, fps, needed;\n\tint interlaced = 0;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\tsd->gspca_dev.usb_err = -EIO;\n\t\treturn;\n\t}\n\n\tif (alt->desc.bNumEndpoints < 1) {\n\t\tsd->gspca_dev.usb_err = -ENODEV;\n\t\treturn;\n\t}\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\treg_w(sd, R51x_FIFO_PSIZE, packet_size >> 5);\n\n\treg_w(sd, R511_CAM_UV_EN, 0x01);\n\treg_w(sd, R511_SNAP_UV_EN, 0x01);\n\treg_w(sd, R511_SNAP_OPTS, 0x03);\n\n\t \n\thsegs = (sd->gspca_dev.pixfmt.width >> 3) - 1;\n\tvsegs = (sd->gspca_dev.pixfmt.height >> 3) - 1;\n\n\treg_w(sd, R511_CAM_PXCNT, hsegs);\n\treg_w(sd, R511_CAM_LNCNT, vsegs);\n\treg_w(sd, R511_CAM_PXDIV, 0x00);\n\treg_w(sd, R511_CAM_LNDIV, 0x00);\n\n\t \n\treg_w(sd, R511_CAM_OPTS, 0x03);\n\n\t \n\treg_w(sd, R511_SNAP_PXCNT, hsegs);\n\treg_w(sd, R511_SNAP_LNCNT, vsegs);\n\treg_w(sd, R511_SNAP_PXDIV, 0x00);\n\treg_w(sd, R511_SNAP_LNDIV, 0x00);\n\n\t \n\tif (frame_rate > 0)\n\t\tsd->frame_rate = frame_rate;\n\n\tswitch (sd->sensor) {\n\tcase SEN_OV6620:\n\t\t \n\t\tsd->clockdiv = 3;\n\t\tbreak;\n\n\t \n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\tcase SEN_OV76BE:\n\t\tif (sd->gspca_dev.pixfmt.width == 320)\n\t\t\tinterlaced = 1;\n\t\tfallthrough;\n\tcase SEN_OV6630:\n\tcase SEN_OV7610:\n\tcase SEN_OV7670:\n\t\tswitch (sd->frame_rate) {\n\t\tcase 30:\n\t\tcase 25:\n\t\t\t \n\t\t\tif (sd->gspca_dev.pixfmt.width != 640) {\n\t\t\t\tsd->clockdiv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tfallthrough;\n\t\tdefault:\n \n \n\t\t\tsd->clockdiv = 1;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tsd->clockdiv = 2;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tsd->clockdiv = 5;\n\t\t\tbreak;\n\t\t}\n\t\tif (interlaced) {\n\t\t\tsd->clockdiv = (sd->clockdiv + 1) * 2 - 1;\n\t\t\t \n\t\t\tif (sd->clockdiv > 10)\n\t\t\t\tsd->clockdiv = 10;\n\t\t}\n\t\tbreak;\n\n\tcase SEN_OV8610:\n\t\t \n\t\tsd->clockdiv = 0;\n\t\tbreak;\n\t}\n\n\t \n\tfps = (interlaced ? 60 : 30) / (sd->clockdiv + 1) + 1;\n\tneeded = fps * sd->gspca_dev.pixfmt.width *\n\t\t\tsd->gspca_dev.pixfmt.height * 3 / 2;\n\t \n\tif (needed > 1000 * packet_size) {\n\t\t \n\t\treg_w(sd, R511_COMP_EN, 0x07);\n\t\treg_w(sd, R511_COMP_LUT_EN, 0x03);\n\t} else {\n\t\treg_w(sd, R511_COMP_EN, 0x06);\n\t\treg_w(sd, R511_COMP_LUT_EN, 0x00);\n\t}\n\n\treg_w(sd, R51x_SYS_RESET, OV511_RESET_OMNICE);\n\treg_w(sd, R51x_SYS_RESET, 0);\n}\n\n \nstatic void ov518_mode_init_regs(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint hsegs, vsegs, packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\tsd->gspca_dev.usb_err = -EIO;\n\t\treturn;\n\t}\n\n\tif (alt->desc.bNumEndpoints < 1) {\n\t\tsd->gspca_dev.usb_err = -ENODEV;\n\t\treturn;\n\t}\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tov518_reg_w32(sd, R51x_FIFO_PSIZE, packet_size & ~7, 2);\n\n\t \n\treg_w(sd, 0x2b, 0);\n\treg_w(sd, 0x2c, 0);\n\treg_w(sd, 0x2d, 0);\n\treg_w(sd, 0x2e, 0);\n\treg_w(sd, 0x3b, 0);\n\treg_w(sd, 0x3c, 0);\n\treg_w(sd, 0x3d, 0);\n\treg_w(sd, 0x3e, 0);\n\n\tif (sd->bridge == BRIDGE_OV518) {\n\t\t \n\t\treg_w_mask(sd, 0x20, 0x08, 0x08);\n\n\t\t \n\t\treg_w_mask(sd, 0x28, 0x80, 0xf0);\n\t\treg_w_mask(sd, 0x38, 0x80, 0xf0);\n\t} else {\n\t\treg_w(sd, 0x28, 0x80);\n\t\treg_w(sd, 0x38, 0x80);\n\t}\n\n\thsegs = sd->gspca_dev.pixfmt.width / 16;\n\tvsegs = sd->gspca_dev.pixfmt.height / 4;\n\n\treg_w(sd, 0x29, hsegs);\n\treg_w(sd, 0x2a, vsegs);\n\n\treg_w(sd, 0x39, hsegs);\n\treg_w(sd, 0x3a, vsegs);\n\n\t \n\treg_w(sd, 0x2f, 0x80);\n\n\t \n\tif (sd->bridge == BRIDGE_OV518PLUS && sd->revision == 0 &&\n\t\t\t\t\t      sd->sensor == SEN_OV7620AE)\n\t\tsd->clockdiv = 0;\n\telse\n\t\tsd->clockdiv = 1;\n\n\t \n\t \n\treg_w(sd, 0x51, 0x04);\n\treg_w(sd, 0x22, 0x18);\n\treg_w(sd, 0x23, 0xff);\n\n\tif (sd->bridge == BRIDGE_OV518PLUS) {\n\t\tswitch (sd->sensor) {\n\t\tcase SEN_OV7620AE:\n\t\t\t \n\t\t\tif (sd->revision > 0 &&\n\t\t\t\t\tsd->gspca_dev.pixfmt.width == 640) {\n\t\t\t\treg_w(sd, 0x20, 0x60);\n\t\t\t\treg_w(sd, 0x21, 0x1f);\n\t\t\t} else {\n\t\t\t\treg_w(sd, 0x20, 0x00);\n\t\t\t\treg_w(sd, 0x21, 0x19);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEN_OV7620:\n\t\t\treg_w(sd, 0x20, 0x00);\n\t\t\treg_w(sd, 0x21, 0x19);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treg_w(sd, 0x21, 0x19);\n\t\t}\n\t} else\n\t\treg_w(sd, 0x71, 0x17);\t \n\n\t \n\t \n\ti2c_w(sd, 0x54, 0x23);\n\n\treg_w(sd, 0x2f, 0x80);\n\n\tif (sd->bridge == BRIDGE_OV518PLUS) {\n\t\treg_w(sd, 0x24, 0x94);\n\t\treg_w(sd, 0x25, 0x90);\n\t\tov518_reg_w32(sd, 0xc4,    400, 2);\t \n\t\tov518_reg_w32(sd, 0xc6,    540, 2);\t \n\t\tov518_reg_w32(sd, 0xc7,    540, 2);\t \n\t\tov518_reg_w32(sd, 0xc8,    108, 2);\t \n\t\tov518_reg_w32(sd, 0xca, 131098, 3);\t \n\t\tov518_reg_w32(sd, 0xcb,    532, 2);\t \n\t\tov518_reg_w32(sd, 0xcc,   2400, 2);\t \n\t\tov518_reg_w32(sd, 0xcd,     32, 2);\t \n\t\tov518_reg_w32(sd, 0xce,    608, 2);\t \n\t} else {\n\t\treg_w(sd, 0x24, 0x9f);\n\t\treg_w(sd, 0x25, 0x90);\n\t\tov518_reg_w32(sd, 0xc4,    400, 2);\t \n\t\tov518_reg_w32(sd, 0xc6,    381, 2);\t \n\t\tov518_reg_w32(sd, 0xc7,    381, 2);\t \n\t\tov518_reg_w32(sd, 0xc8,    128, 2);\t \n\t\tov518_reg_w32(sd, 0xca, 183331, 3);\t \n\t\tov518_reg_w32(sd, 0xcb,    746, 2);\t \n\t\tov518_reg_w32(sd, 0xcc,   1750, 2);\t \n\t\tov518_reg_w32(sd, 0xcd,     45, 2);\t \n\t\tov518_reg_w32(sd, 0xce,    851, 2);\t \n\t}\n\n\treg_w(sd, 0x2f, 0x80);\n}\n\n \nstatic void ov519_mode_init_regs(struct sd *sd)\n{\n\tstatic const struct ov_regvals mode_init_519_ov7670[] = {\n\t\t{ 0x5d,\t0x03 },  \n\t\t{ 0x53,\t0x9f },  \n\t\t{ OV519_R54_EN_CLK1, 0x0f },  \n\t\t{ 0xa2,\t0x20 },  \n\t\t{ 0xa3,\t0x18 },\n\t\t{ 0xa4,\t0x04 },\n\t\t{ 0xa5,\t0x28 },\n\t\t{ 0x37,\t0x00 },\t \n\t\t{ 0x55,\t0x02 },  \n\t\t \n\t\t{ 0x20,\t0x0c },\n\t\t{ 0x21,\t0x38 },\n\t\t{ 0x22,\t0x1d },\n\t\t{ 0x17,\t0x50 },  \n\t\t{ 0x37,\t0x00 },  \n\t\t{ 0x40,\t0xff },  \n\t\t{ 0x46,\t0x00 },  \n\t\t{ 0x59,\t0x04 },\t \n\t\t{ 0xff,\t0x00 },  \n\t\t \n\t};\n\n\tstatic const struct ov_regvals mode_init_519[] = {\n\t\t{ 0x5d,\t0x03 },  \n\t\t{ 0x53,\t0x9f },  \n\t\t{ OV519_R54_EN_CLK1, 0x0f },  \n\t\t{ 0xa2,\t0x20 },  \n\t\t{ 0xa3,\t0x18 },\n\t\t{ 0xa4,\t0x04 },\n\t\t{ 0xa5,\t0x28 },\n\t\t{ 0x37,\t0x00 },\t \n\t\t{ 0x55,\t0x02 },  \n\t\t \n\t\t{ 0x22,\t0x1d },\n\t\t{ 0x17,\t0x50 },  \n\t\t{ 0x37,\t0x00 },  \n\t\t{ 0x40,\t0xff },  \n\t\t{ 0x46,\t0x00 },  \n\t\t{ 0x59,\t0x04 },\t \n\t\t{ 0xff,\t0x00 },  \n\t\t \n\t};\n\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\t \n\tswitch (sd->sensor) {\n\tdefault:\n\t\twrite_regvals(sd, mode_init_519, ARRAY_SIZE(mode_init_519));\n\t\tif (sd->sensor == SEN_OV7640 ||\n\t\t    sd->sensor == SEN_OV7648) {\n\t\t\t \n\t\t\treg_w_mask(sd, OV519_R20_DFR, 0x10, 0x10);\n\t\t}\n\t\tbreak;\n\tcase SEN_OV7660:\n\t\treturn;\t\t \n\tcase SEN_OV7670:\n\t\twrite_regvals(sd, mode_init_519_ov7670,\n\t\t\t\tARRAY_SIZE(mode_init_519_ov7670));\n\t\tbreak;\n\t}\n\n\treg_w(sd, OV519_R10_H_SIZE,\tsd->gspca_dev.pixfmt.width >> 4);\n\treg_w(sd, OV519_R11_V_SIZE,\tsd->gspca_dev.pixfmt.height >> 3);\n\tif (sd->sensor == SEN_OV7670 &&\n\t    sd->gspca_dev.cam.cam_mode[sd->gspca_dev.curr_mode].priv)\n\t\treg_w(sd, OV519_R12_X_OFFSETL, 0x04);\n\telse if (sd->sensor == SEN_OV7648 &&\n\t    sd->gspca_dev.cam.cam_mode[sd->gspca_dev.curr_mode].priv)\n\t\treg_w(sd, OV519_R12_X_OFFSETL, 0x01);\n\telse\n\t\treg_w(sd, OV519_R12_X_OFFSETL, 0x00);\n\treg_w(sd, OV519_R13_X_OFFSETH,\t0x00);\n\treg_w(sd, OV519_R14_Y_OFFSETL,\t0x00);\n\treg_w(sd, OV519_R15_Y_OFFSETH,\t0x00);\n\treg_w(sd, OV519_R16_DIVIDER,\t0x00);\n\treg_w(sd, OV519_R25_FORMAT,\t0x03);  \n\treg_w(sd, 0x26,\t\t\t0x00);  \n\n\t \n\tif (frame_rate > 0)\n\t\tsd->frame_rate = frame_rate;\n\n \n\tsd->clockdiv = 0;\n\tswitch (sd->sensor) {\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\t\tswitch (sd->frame_rate) {\n\t\tdefault:\n \n\t\t\treg_w(sd, 0xa4, 0x0c);\n\t\t\treg_w(sd, 0x23, 0xff);\n\t\t\tbreak;\n\t\tcase 25:\n\t\t\treg_w(sd, 0xa4, 0x0c);\n\t\t\treg_w(sd, 0x23, 0x1f);\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\treg_w(sd, 0xa4, 0x0c);\n\t\t\treg_w(sd, 0x23, 0x1b);\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\treg_w(sd, 0xa4, 0x04);\n\t\t\treg_w(sd, 0x23, 0xff);\n\t\t\tsd->clockdiv = 1;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\treg_w(sd, 0xa4, 0x04);\n\t\t\treg_w(sd, 0x23, 0x1f);\n\t\t\tsd->clockdiv = 1;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\treg_w(sd, 0xa4, 0x04);\n\t\t\treg_w(sd, 0x23, 0x1b);\n\t\t\tsd->clockdiv = 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SEN_OV8610:\n\t\tswitch (sd->frame_rate) {\n\t\tdefault:\t \n \n\t\t\treg_w(sd, 0xa4, 0x06);\n\t\t\treg_w(sd, 0x23, 0xff);\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\treg_w(sd, 0xa4, 0x06);\n\t\t\treg_w(sd, 0x23, 0x1f);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\treg_w(sd, 0xa4, 0x06);\n\t\t\treg_w(sd, 0x23, 0x1b);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SEN_OV7670:\t\t \n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Setting framerate to %d fps\\n\",\n\t\t\t  (sd->frame_rate == 0) ? 15 : sd->frame_rate);\n\t\treg_w(sd, 0xa4, 0x10);\n\t\tswitch (sd->frame_rate) {\n\t\tcase 30:\n\t\t\treg_w(sd, 0x23, 0xff);\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\treg_w(sd, 0x23, 0x1b);\n\t\t\tbreak;\n\t\tdefault:\n \n\t\t\treg_w(sd, 0x23, 0xff);\n\t\t\tsd->clockdiv = 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void mode_init_ov_sensor_regs(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint qvga, xstart, xend, ystart, yend;\n\tu8 v;\n\n\tqvga = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv & 1;\n\n\t \n\tswitch (sd->sensor) {\n\tcase SEN_OV2610:\n\t\ti2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x28, qvga ? 0x00 : 0x20, 0x20);\n\t\ti2c_w(sd, 0x24, qvga ? 0x20 : 0x3a);\n\t\ti2c_w(sd, 0x25, qvga ? 0x30 : 0x60);\n\t\ti2c_w_mask(sd, 0x2d, qvga ? 0x40 : 0x00, 0x40);\n\t\ti2c_w_mask(sd, 0x67, qvga ? 0xf0 : 0x90, 0xf0);\n\t\ti2c_w_mask(sd, 0x74, qvga ? 0x20 : 0x00, 0x20);\n\t\treturn;\n\tcase SEN_OV2610AE: {\n\t\tu8 v;\n\n\t\t \n\t\tv = 80;\n\t\tif (qvga) {\n\t\t\tif (sd->frame_rate < 25)\n\t\t\t\tv = 0x81;\n\t\t} else {\n\t\t\tif (sd->frame_rate < 10)\n\t\t\t\tv = 0x81;\n\t\t}\n\t\ti2c_w(sd, 0x11, v);\n\t\ti2c_w(sd, 0x12, qvga ? 0x60 : 0x20);\n\t\treturn;\n\t    }\n\tcase SEN_OV3610:\n\t\tif (qvga) {\n\t\t\txstart = (1040 - gspca_dev->pixfmt.width) / 2 +\n\t\t\t\t(0x1f << 4);\n\t\t\tystart = (776 - gspca_dev->pixfmt.height) / 2;\n\t\t} else {\n\t\t\txstart = (2076 - gspca_dev->pixfmt.width) / 2 +\n\t\t\t\t(0x10 << 4);\n\t\t\tystart = (1544 - gspca_dev->pixfmt.height) / 2;\n\t\t}\n\t\txend = xstart + gspca_dev->pixfmt.width;\n\t\tyend = ystart + gspca_dev->pixfmt.height;\n\t\t \n\t\ti2c_w_mask(sd, 0x12, qvga ? 0x40 : 0x00, 0xf0);\n\t\ti2c_w_mask(sd, 0x32,\n\t\t\t   (((xend >> 1) & 7) << 3) | ((xstart >> 1) & 7),\n\t\t\t   0x3f);\n\t\ti2c_w_mask(sd, 0x03,\n\t\t\t   (((yend >> 1) & 3) << 2) | ((ystart >> 1) & 3),\n\t\t\t   0x0f);\n\t\ti2c_w(sd, 0x17, xstart >> 4);\n\t\ti2c_w(sd, 0x18, xend >> 4);\n\t\ti2c_w(sd, 0x19, ystart >> 3);\n\t\ti2c_w(sd, 0x1a, yend >> 3);\n\t\treturn;\n\tcase SEN_OV8610:\n\t\t \n\t\ti2c_w_mask(sd, OV7610_REG_COM_C, qvga ? (1 << 5) : 0, 1 << 5);\n\t\ti2c_w_mask(sd, 0x13, 0x00, 0x20);  \n\t\ti2c_w_mask(sd, 0x12, 0x04, 0x06);  \n\t\ti2c_w_mask(sd, 0x2d, 0x00, 0x40);  \n\t\ti2c_w_mask(sd, 0x28, 0x20, 0x20);  \n\t\tbreak;\n\tcase SEN_OV7610:\n\t\ti2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w(sd, 0x35, qvga ? 0x1e : 0x9e);\n\t\ti2c_w_mask(sd, 0x13, 0x00, 0x20);  \n\t\ti2c_w_mask(sd, 0x12, 0x04, 0x06);  \n\t\tbreak;\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\tcase SEN_OV76BE:\n\t\ti2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x28, qvga ? 0x00 : 0x20, 0x20);\n\t\ti2c_w(sd, 0x24, qvga ? 0x20 : 0x3a);\n\t\ti2c_w(sd, 0x25, qvga ? 0x30 : 0x60);\n\t\ti2c_w_mask(sd, 0x2d, qvga ? 0x40 : 0x00, 0x40);\n\t\ti2c_w_mask(sd, 0x67, qvga ? 0xb0 : 0x90, 0xf0);\n\t\ti2c_w_mask(sd, 0x74, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x13, 0x00, 0x20);  \n\t\ti2c_w_mask(sd, 0x12, 0x04, 0x06);  \n\t\tif (sd->sensor == SEN_OV76BE)\n\t\t\ti2c_w(sd, 0x35, qvga ? 0x1e : 0x9e);\n\t\tbreak;\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\t\ti2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x28, qvga ? 0x00 : 0x20, 0x20);\n\t\t \n\t\ti2c_w_mask(sd, 0x2d, qvga ? 0x40 : 0x00, 0x40);\n\t\t \n\t\ti2c_w_mask(sd, 0x67, qvga ? 0xf0 : 0x90, 0xf0);\n\t\t \n\t\ti2c_w_mask(sd, 0x74, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x12, 0x04, 0x04);  \n\t\tbreak;\n\tcase SEN_OV7670:\n\t\t \n\t\ti2c_w_mask(sd, OV7670_R12_COM7,\n\t\t\t qvga ? OV7670_COM7_FMT_QVGA : OV7670_COM7_FMT_VGA,\n\t\t\t OV7670_COM7_FMT_MASK);\n\t\ti2c_w_mask(sd, 0x13, 0x00, 0x20);  \n\t\ti2c_w_mask(sd, OV7670_R13_COM8, OV7670_COM8_AWB,\n\t\t\t\tOV7670_COM8_AWB);\n\t\tif (qvga) {\t\t \n\t\t\txstart = 164;\n\t\t\txend = 28;\n\t\t\tystart = 14;\n\t\t\tyend = 494;\n\t\t} else {\t\t \n\t\t\txstart = 158;\n\t\t\txend = 14;\n\t\t\tystart = 10;\n\t\t\tyend = 490;\n\t\t}\n\t\t \n\t\ti2c_w(sd, OV7670_R17_HSTART, xstart >> 3);\n\t\ti2c_w(sd, OV7670_R18_HSTOP, xend >> 3);\n\t\tv = i2c_r(sd, OV7670_R32_HREF);\n\t\tv = (v & 0xc0) | ((xend & 0x7) << 3) | (xstart & 0x07);\n\t\tmsleep(10);\t \n\t\ti2c_w(sd, OV7670_R32_HREF, v);\n\n\t\ti2c_w(sd, OV7670_R19_VSTART, ystart >> 2);\n\t\ti2c_w(sd, OV7670_R1A_VSTOP, yend >> 2);\n\t\tv = i2c_r(sd, OV7670_R03_VREF);\n\t\tv = (v & 0xc0) | ((yend & 0x3) << 2) | (ystart & 0x03);\n\t\tmsleep(10);\t \n\t\ti2c_w(sd, OV7670_R03_VREF, v);\n\t\tbreak;\n\tcase SEN_OV6620:\n\t\ti2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x13, 0x00, 0x20);  \n\t\ti2c_w_mask(sd, 0x12, 0x04, 0x06);  \n\t\tbreak;\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\t\ti2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\n\t\ti2c_w_mask(sd, 0x12, 0x04, 0x06);  \n\t\tbreak;\n\tcase SEN_OV9600: {\n\t\tconst struct ov_i2c_regvals *vals;\n\t\tstatic const struct ov_i2c_regvals sxga_15[] = {\n\t\t\t{0x11, 0x80}, {0x14, 0x3e}, {0x24, 0x85}, {0x25, 0x75}\n\t\t};\n\t\tstatic const struct ov_i2c_regvals sxga_7_5[] = {\n\t\t\t{0x11, 0x81}, {0x14, 0x3e}, {0x24, 0x85}, {0x25, 0x75}\n\t\t};\n\t\tstatic const struct ov_i2c_regvals vga_30[] = {\n\t\t\t{0x11, 0x81}, {0x14, 0x7e}, {0x24, 0x70}, {0x25, 0x60}\n\t\t};\n\t\tstatic const struct ov_i2c_regvals vga_15[] = {\n\t\t\t{0x11, 0x83}, {0x14, 0x3e}, {0x24, 0x80}, {0x25, 0x70}\n\t\t};\n\n\t\t \n\t\ti2c_w_mask(sd, 0x12, qvga ? 0x40 : 0x00, 0x40);\n\t\tif (qvga)\n\t\t\tvals = sd->frame_rate < 30 ? vga_15 : vga_30;\n\t\telse\n\t\t\tvals = sd->frame_rate < 15 ? sxga_7_5 : sxga_15;\n\t\twrite_i2c_regvals(sd, vals, ARRAY_SIZE(sxga_15));\n\t\treturn;\n\t    }\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\ti2c_w(sd, 0x11, sd->clockdiv);\n}\n\n \nstatic void sethvflip(struct gspca_dev *gspca_dev, s32 hflip, s32 vflip)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->gspca_dev.streaming)\n\t\treg_w(sd, OV519_R51_RESET1, 0x0f);\t \n\ti2c_w_mask(sd, OV7670_R1E_MVFP,\n\t\tOV7670_MVFP_MIRROR * hflip | OV7670_MVFP_VFLIP * vflip,\n\t\tOV7670_MVFP_MIRROR | OV7670_MVFP_VFLIP);\n\tif (sd->gspca_dev.streaming)\n\t\treg_w(sd, OV519_R51_RESET1, 0x00);\t \n}\n\nstatic void set_ov_sensor_window(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev;\n\tint qvga, crop;\n\tint hwsbase, hwebase, vwsbase, vwebase, hwscale, vwscale;\n\n\t \n\tswitch (sd->sensor) {\n\tcase SEN_OV2610:\n\tcase SEN_OV2610AE:\n\tcase SEN_OV3610:\n\tcase SEN_OV7670:\n\tcase SEN_OV9600:\n\t\tmode_init_ov_sensor_regs(sd);\n\t\treturn;\n\tcase SEN_OV7660:\n\t\tov519_set_mode(sd);\n\t\tov519_set_fr(sd);\n\t\treturn;\n\t}\n\n\tgspca_dev = &sd->gspca_dev;\n\tqvga = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv & 1;\n\tcrop = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv & 2;\n\n\t \n\tswitch (sd->sensor) {\n\tcase SEN_OV8610:\n\t\thwsbase = 0x1e;\n\t\thwebase = 0x1e;\n\t\tvwsbase = 0x02;\n\t\tvwebase = 0x02;\n\t\tbreak;\n\tcase SEN_OV7610:\n\tcase SEN_OV76BE:\n\t\thwsbase = 0x38;\n\t\thwebase = 0x3a;\n\t\tvwsbase = vwebase = 0x05;\n\t\tbreak;\n\tcase SEN_OV6620:\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\t\thwsbase = 0x38;\n\t\thwebase = 0x3a;\n\t\tvwsbase = 0x05;\n\t\tvwebase = 0x06;\n\t\tif (sd->sensor == SEN_OV66308AF && qvga)\n\t\t\t \n\t\t\thwsbase++;\n\t\tif (crop) {\n\t\t\thwsbase += 8;\n\t\t\thwebase += 8;\n\t\t\tvwsbase += 11;\n\t\t\tvwebase += 11;\n\t\t}\n\t\tbreak;\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\t\thwsbase = 0x2f;\t\t \n\t\thwebase = 0x2f;\n\t\tvwsbase = vwebase = 0x05;\n\t\tbreak;\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\t\thwsbase = 0x1a;\n\t\thwebase = 0x1a;\n\t\tvwsbase = vwebase = 0x03;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tswitch (sd->sensor) {\n\tcase SEN_OV6620:\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\t\tif (qvga) {\t\t \n\t\t\thwscale = 0;\n\t\t\tvwscale = 0;\n\t\t} else {\t\t \n\t\t\thwscale = 1;\n\t\t\tvwscale = 1;\t \n\t\t}\n\t\tbreak;\n\tcase SEN_OV8610:\n\t\tif (qvga) {\t\t \n\t\t\thwscale = 1;\n\t\t\tvwscale = 1;\n\t\t} else {\t\t \n\t\t\thwscale = 2;\n\t\t\tvwscale = 2;\n\t\t}\n\t\tbreak;\n\tdefault:\t\t\t \n\t\tif (qvga) {\t\t \n\t\t\thwscale = 1;\n\t\t\tvwscale = 0;\n\t\t} else {\t\t \n\t\t\thwscale = 2;\n\t\t\tvwscale = 1;\n\t\t}\n\t}\n\n\tmode_init_ov_sensor_regs(sd);\n\n\ti2c_w(sd, 0x17, hwsbase);\n\ti2c_w(sd, 0x18, hwebase + (sd->sensor_width >> hwscale));\n\ti2c_w(sd, 0x19, vwsbase);\n\ti2c_w(sd, 0x1a, vwebase + (sd->sensor_height >> vwscale));\n}\n\n \nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t \n\tsd->sensor_width = sd->gspca_dev.pixfmt.width;\n\tsd->sensor_height = sd->gspca_dev.pixfmt.height;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tov511_mode_init_regs(sd);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\tov518_mode_init_regs(sd);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\tov519_mode_init_regs(sd);\n\t\tbreak;\n\t \n\tcase BRIDGE_W9968CF:\n\t\tw9968cf_mode_init_regs(sd);\n\t\tbreak;\n\t}\n\n\tset_ov_sensor_window(sd);\n\n\t \n\tsd->snapshot_needs_reset = 1;\n\tsd_reset_snapshot(gspca_dev);\n\n\tsd->first_frame = 3;\n\n\tov51x_restart(sd);\n\tov51x_led_control(sd, 1);\n\treturn gspca_dev->usb_err;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tov51x_stop(sd);\n\tov51x_led_control(sd, 0);\n}\n\nstatic void sd_stop0(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (!sd->gspca_dev.present)\n\t\treturn;\n\tif (sd->bridge == BRIDGE_W9968CF)\n\t\tw9968cf_stop0(sd);\n\n#if IS_ENABLED(CONFIG_INPUT)\n\t \n\tif (sd->snapshot_pressed) {\n\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\n\t\tinput_sync(gspca_dev->input_dev);\n\t\tsd->snapshot_pressed = 0;\n\t}\n#endif\n\tif (sd->bridge == BRIDGE_OV519)\n\t\treg_w(sd, OV519_R57_SNAPSHOT, 0x23);\n}\n\nstatic void ov51x_handle_button(struct gspca_dev *gspca_dev, u8 state)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->snapshot_pressed != state) {\n#if IS_ENABLED(CONFIG_INPUT)\n\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, state);\n\t\tinput_sync(gspca_dev->input_dev);\n#endif\n\t\tif (state)\n\t\t\tsd->snapshot_needs_reset = 1;\n\n\t\tsd->snapshot_pressed = state;\n\t} else {\n\t\t \n\t\tswitch (sd->bridge) {\n\t\tcase BRIDGE_OV511:\n\t\tcase BRIDGE_OV511PLUS:\n\t\tcase BRIDGE_OV519:\n\t\t\tif (state)\n\t\t\t\tsd->snapshot_needs_reset = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void ov511_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *in,\t\t\t \n\t\t\tint len)\t\t \n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t \n\tif (!(in[0] | in[1] | in[2] | in[3] | in[4] | in[5] | in[6] | in[7]) &&\n\t    (in[8] & 0x08)) {\n\t\tov51x_handle_button(gspca_dev, (in[8] >> 2) & 1);\n\t\tif (in[8] & 0x80) {\n\t\t\t \n\t\t\tif ((in[9] + 1) * 8 != gspca_dev->pixfmt.width ||\n\t\t\t    (in[10] + 1) * 8 != gspca_dev->pixfmt.height) {\n\t\t\t\tgspca_err(gspca_dev, \"Invalid frame size, got: %dx%d, requested: %dx%d\\n\",\n\t\t\t\t\t  (in[9] + 1) * 8, (in[10] + 1) * 8,\n\t\t\t\t\t  gspca_dev->pixfmt.width,\n\t\t\t\t\t  gspca_dev->pixfmt.height);\n\t\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET, in, 11);\n\t\t\treturn;\n\t\t} else {\n\t\t\t \n\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, in, 0);\n\t\t\tsd->packet_nr = 0;\n\t\t}\n\t}\n\n\t \n\tlen--;\n\n\t \n\tgspca_frame_add(gspca_dev, INTER_PACKET, in, len);\n}\n\nstatic void ov518_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t \n\t\t\tint len)\t\t\t \n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t \n\tif ((!(data[0] | data[1] | data[2] | data[3] | data[5])) && data[6]) {\n\t\tov51x_handle_button(gspca_dev, (data[6] >> 1) & 1);\n\t\tgspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\n\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, NULL, 0);\n\t\tsd->packet_nr = 0;\n\t}\n\n\tif (gspca_dev->last_packet_type == DISCARD_PACKET)\n\t\treturn;\n\n\t \n\tif (len & 7) {\n\t\tlen--;\n\t\tif (sd->packet_nr == data[len])\n\t\t\tsd->packet_nr++;\n\t\t \n\t\telse if (sd->packet_nr == 0 || data[len]) {\n\t\t\tgspca_err(gspca_dev, \"Invalid packet nr: %d (expect: %d)\\n\",\n\t\t\t\t  (int)data[len], (int)sd->packet_nr);\n\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n}\n\nstatic void ov519_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t \n\t\t\tint len)\t\t\t \n{\n\t \n\n\tif (data[0] == 0xff && data[1] == 0xff && data[2] == 0xff) {\n\t\tswitch (data[3]) {\n\t\tcase 0x50:\t\t \n\t\t\t \n#define HDRSZ 16\n\t\t\tdata += HDRSZ;\n\t\t\tlen -= HDRSZ;\n#undef HDRSZ\n\t\t\tif (data[0] == 0xff || data[1] == 0xd8)\n\t\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\t\t\t\t\tdata, len);\n\t\t\telse\n\t\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\treturn;\n\t\tcase 0x51:\t\t \n\t\t\tov51x_handle_button(gspca_dev, data[11] & 1);\n\t\t\tif (data[9] != 0)\n\t\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET,\n\t\t\t\t\tNULL, 0);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n}\n\nstatic void ovfx2_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t \n\t\t\tint len)\t\t\t \n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n\n\t \n\tif (len < gspca_dev->cam.bulk_size) {\n\t\t \n\t\tif (sd->first_frame) {\n\t\t\tsd->first_frame--;\n\t\t\tif (gspca_dev->image_len <\n\t\t\t\t  sd->gspca_dev.pixfmt.width *\n\t\t\t\t\tsd->gspca_dev.pixfmt.height)\n\t\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t}\n\t\tgspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\n\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, NULL, 0);\n\t}\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t \n\t\t\tint len)\t\t\t \n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tswitch (sd->bridge) {\n\tcase BRIDGE_OV511:\n\tcase BRIDGE_OV511PLUS:\n\t\tov511_pkt_scan(gspca_dev, data, len);\n\t\tbreak;\n\tcase BRIDGE_OV518:\n\tcase BRIDGE_OV518PLUS:\n\t\tov518_pkt_scan(gspca_dev, data, len);\n\t\tbreak;\n\tcase BRIDGE_OV519:\n\t\tov519_pkt_scan(gspca_dev, data, len);\n\t\tbreak;\n\tcase BRIDGE_OVFX2:\n\t\tovfx2_pkt_scan(gspca_dev, data, len);\n\t\tbreak;\n\tcase BRIDGE_W9968CF:\n\t\tw9968cf_pkt_scan(gspca_dev, data, len);\n\t\tbreak;\n\t}\n}\n\n \n\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstatic const struct ov_i2c_regvals brit_7660[][7] = {\n\t\t{{0x0f, 0x6a}, {0x24, 0x40}, {0x25, 0x2b}, {0x26, 0x90},\n\t\t\t{0x27, 0xe0}, {0x28, 0xe0}, {0x2c, 0xe0}},\n\t\t{{0x0f, 0x6a}, {0x24, 0x50}, {0x25, 0x40}, {0x26, 0xa1},\n\t\t\t{0x27, 0xc0}, {0x28, 0xc0}, {0x2c, 0xc0}},\n\t\t{{0x0f, 0x6a}, {0x24, 0x68}, {0x25, 0x58}, {0x26, 0xc2},\n\t\t\t{0x27, 0xa0}, {0x28, 0xa0}, {0x2c, 0xa0}},\n\t\t{{0x0f, 0x6a}, {0x24, 0x70}, {0x25, 0x68}, {0x26, 0xd3},\n\t\t\t{0x27, 0x80}, {0x28, 0x80}, {0x2c, 0x80}},\n\t\t{{0x0f, 0x6a}, {0x24, 0x80}, {0x25, 0x70}, {0x26, 0xd3},\n\t\t\t{0x27, 0x20}, {0x28, 0x20}, {0x2c, 0x20}},\n\t\t{{0x0f, 0x6a}, {0x24, 0x88}, {0x25, 0x78}, {0x26, 0xd3},\n\t\t\t{0x27, 0x40}, {0x28, 0x40}, {0x2c, 0x40}},\n\t\t{{0x0f, 0x6a}, {0x24, 0x90}, {0x25, 0x80}, {0x26, 0xd4},\n\t\t\t{0x27, 0x60}, {0x28, 0x60}, {0x2c, 0x60}}\n\t};\n\n\tswitch (sd->sensor) {\n\tcase SEN_OV8610:\n\tcase SEN_OV7610:\n\tcase SEN_OV76BE:\n\tcase SEN_OV6620:\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\t\ti2c_w(sd, OV7610_REG_BRT, val);\n\t\tbreak;\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\t\ti2c_w(sd, OV7610_REG_BRT, val);\n\t\tbreak;\n\tcase SEN_OV7660:\n\t\twrite_i2c_regvals(sd, brit_7660[val],\n\t\t\t\tARRAY_SIZE(brit_7660[0]));\n\t\tbreak;\n\tcase SEN_OV7670:\n \n\t\ti2c_w(sd, OV7670_R55_BRIGHT, ov7670_abs_to_sm(val));\n\t\tbreak;\n\t}\n}\n\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstatic const struct ov_i2c_regvals contrast_7660[][31] = {\n\t\t{{0x6c, 0xf0}, {0x6d, 0xf0}, {0x6e, 0xf8}, {0x6f, 0xa0},\n\t\t {0x70, 0x58}, {0x71, 0x38}, {0x72, 0x30}, {0x73, 0x30},\n\t\t {0x74, 0x28}, {0x75, 0x28}, {0x76, 0x24}, {0x77, 0x24},\n\t\t {0x78, 0x22}, {0x79, 0x28}, {0x7a, 0x2a}, {0x7b, 0x34},\n\t\t {0x7c, 0x0f}, {0x7d, 0x1e}, {0x7e, 0x3d}, {0x7f, 0x65},\n\t\t {0x80, 0x70}, {0x81, 0x77}, {0x82, 0x7d}, {0x83, 0x83},\n\t\t {0x84, 0x88}, {0x85, 0x8d}, {0x86, 0x96}, {0x87, 0x9f},\n\t\t {0x88, 0xb0}, {0x89, 0xc4}, {0x8a, 0xd9}},\n\t\t{{0x6c, 0xf0}, {0x6d, 0xf0}, {0x6e, 0xf8}, {0x6f, 0x94},\n\t\t {0x70, 0x58}, {0x71, 0x40}, {0x72, 0x30}, {0x73, 0x30},\n\t\t {0x74, 0x30}, {0x75, 0x30}, {0x76, 0x2c}, {0x77, 0x24},\n\t\t {0x78, 0x22}, {0x79, 0x28}, {0x7a, 0x2a}, {0x7b, 0x31},\n\t\t {0x7c, 0x0f}, {0x7d, 0x1e}, {0x7e, 0x3d}, {0x7f, 0x62},\n\t\t {0x80, 0x6d}, {0x81, 0x75}, {0x82, 0x7b}, {0x83, 0x81},\n\t\t {0x84, 0x87}, {0x85, 0x8d}, {0x86, 0x98}, {0x87, 0xa1},\n\t\t {0x88, 0xb2}, {0x89, 0xc6}, {0x8a, 0xdb}},\n\t\t{{0x6c, 0xf0}, {0x6d, 0xf0}, {0x6e, 0xf0}, {0x6f, 0x84},\n\t\t {0x70, 0x58}, {0x71, 0x48}, {0x72, 0x40}, {0x73, 0x40},\n\t\t {0x74, 0x28}, {0x75, 0x28}, {0x76, 0x28}, {0x77, 0x24},\n\t\t {0x78, 0x26}, {0x79, 0x28}, {0x7a, 0x28}, {0x7b, 0x34},\n\t\t {0x7c, 0x0f}, {0x7d, 0x1e}, {0x7e, 0x3c}, {0x7f, 0x5d},\n\t\t {0x80, 0x68}, {0x81, 0x71}, {0x82, 0x79}, {0x83, 0x81},\n\t\t {0x84, 0x86}, {0x85, 0x8b}, {0x86, 0x95}, {0x87, 0x9e},\n\t\t {0x88, 0xb1}, {0x89, 0xc5}, {0x8a, 0xd9}},\n\t\t{{0x6c, 0xf0}, {0x6d, 0xf0}, {0x6e, 0xf0}, {0x6f, 0x70},\n\t\t {0x70, 0x58}, {0x71, 0x58}, {0x72, 0x48}, {0x73, 0x48},\n\t\t {0x74, 0x38}, {0x75, 0x40}, {0x76, 0x34}, {0x77, 0x34},\n\t\t {0x78, 0x2e}, {0x79, 0x28}, {0x7a, 0x24}, {0x7b, 0x22},\n\t\t {0x7c, 0x0f}, {0x7d, 0x1e}, {0x7e, 0x3c}, {0x7f, 0x58},\n\t\t {0x80, 0x63}, {0x81, 0x6e}, {0x82, 0x77}, {0x83, 0x80},\n\t\t {0x84, 0x87}, {0x85, 0x8f}, {0x86, 0x9c}, {0x87, 0xa9},\n\t\t {0x88, 0xc0}, {0x89, 0xd4}, {0x8a, 0xe6}},\n\t\t{{0x6c, 0xa0}, {0x6d, 0xf0}, {0x6e, 0x90}, {0x6f, 0x80},\n\t\t {0x70, 0x70}, {0x71, 0x80}, {0x72, 0x60}, {0x73, 0x60},\n\t\t {0x74, 0x58}, {0x75, 0x60}, {0x76, 0x4c}, {0x77, 0x38},\n\t\t {0x78, 0x38}, {0x79, 0x2a}, {0x7a, 0x20}, {0x7b, 0x0e},\n\t\t {0x7c, 0x0a}, {0x7d, 0x14}, {0x7e, 0x26}, {0x7f, 0x46},\n\t\t {0x80, 0x54}, {0x81, 0x64}, {0x82, 0x70}, {0x83, 0x7c},\n\t\t {0x84, 0x87}, {0x85, 0x93}, {0x86, 0xa6}, {0x87, 0xb4},\n\t\t {0x88, 0xd0}, {0x89, 0xe5}, {0x8a, 0xf5}},\n\t\t{{0x6c, 0x60}, {0x6d, 0x80}, {0x6e, 0x60}, {0x6f, 0x80},\n\t\t {0x70, 0x80}, {0x71, 0x80}, {0x72, 0x88}, {0x73, 0x30},\n\t\t {0x74, 0x70}, {0x75, 0x68}, {0x76, 0x64}, {0x77, 0x50},\n\t\t {0x78, 0x3c}, {0x79, 0x22}, {0x7a, 0x10}, {0x7b, 0x08},\n\t\t {0x7c, 0x06}, {0x7d, 0x0e}, {0x7e, 0x1a}, {0x7f, 0x3a},\n\t\t {0x80, 0x4a}, {0x81, 0x5a}, {0x82, 0x6b}, {0x83, 0x7b},\n\t\t {0x84, 0x89}, {0x85, 0x96}, {0x86, 0xaf}, {0x87, 0xc3},\n\t\t {0x88, 0xe1}, {0x89, 0xf2}, {0x8a, 0xfa}},\n\t\t{{0x6c, 0x20}, {0x6d, 0x40}, {0x6e, 0x20}, {0x6f, 0x60},\n\t\t {0x70, 0x88}, {0x71, 0xc8}, {0x72, 0xc0}, {0x73, 0xb8},\n\t\t {0x74, 0xa8}, {0x75, 0xb8}, {0x76, 0x80}, {0x77, 0x5c},\n\t\t {0x78, 0x26}, {0x79, 0x10}, {0x7a, 0x08}, {0x7b, 0x04},\n\t\t {0x7c, 0x02}, {0x7d, 0x06}, {0x7e, 0x0a}, {0x7f, 0x22},\n\t\t {0x80, 0x33}, {0x81, 0x4c}, {0x82, 0x64}, {0x83, 0x7b},\n\t\t {0x84, 0x90}, {0x85, 0xa7}, {0x86, 0xc7}, {0x87, 0xde},\n\t\t {0x88, 0xf1}, {0x89, 0xf9}, {0x8a, 0xfd}},\n\t};\n\n\tswitch (sd->sensor) {\n\tcase SEN_OV7610:\n\tcase SEN_OV6620:\n\t\ti2c_w(sd, OV7610_REG_CNT, val);\n\t\tbreak;\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\t\ti2c_w_mask(sd, OV7610_REG_CNT, val >> 4, 0x0f);\n\t\tbreak;\n\tcase SEN_OV8610: {\n\t\tstatic const u8 ctab[] = {\n\t\t\t0x03, 0x09, 0x0b, 0x0f, 0x53, 0x6f, 0x35, 0x7f\n\t\t};\n\n\t\t \n\t\ti2c_w(sd, 0x64, ctab[val >> 5]);\n\t\tbreak;\n\t    }\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE: {\n\t\tstatic const u8 ctab[] = {\n\t\t\t0x01, 0x05, 0x09, 0x11, 0x15, 0x35, 0x37, 0x57,\n\t\t\t0x5b, 0xa5, 0xa7, 0xc7, 0xc9, 0xcf, 0xef, 0xff\n\t\t};\n\n\t\t \n\t\ti2c_w(sd, 0x64, ctab[val >> 4]);\n\t\tbreak;\n\t    }\n\tcase SEN_OV7660:\n\t\twrite_i2c_regvals(sd, contrast_7660[val],\n\t\t\t\t\tARRAY_SIZE(contrast_7660[0]));\n\t\tbreak;\n\tcase SEN_OV7670:\n\t\t \n\t\ti2c_w(sd, OV7670_R56_CONTRAS, val >> 1);\n\t\tbreak;\n\t}\n}\n\nstatic void setexposure(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\ti2c_w(sd, 0x10, val);\n}\n\nstatic void setcolors(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstatic const struct ov_i2c_regvals colors_7660[][6] = {\n\t\t{{0x4f, 0x28}, {0x50, 0x2a}, {0x51, 0x02}, {0x52, 0x0a},\n\t\t {0x53, 0x19}, {0x54, 0x23}},\n\t\t{{0x4f, 0x47}, {0x50, 0x4a}, {0x51, 0x03}, {0x52, 0x11},\n\t\t {0x53, 0x2c}, {0x54, 0x3e}},\n\t\t{{0x4f, 0x66}, {0x50, 0x6b}, {0x51, 0x05}, {0x52, 0x19},\n\t\t {0x53, 0x40}, {0x54, 0x59}},\n\t\t{{0x4f, 0x84}, {0x50, 0x8b}, {0x51, 0x06}, {0x52, 0x20},\n\t\t {0x53, 0x53}, {0x54, 0x73}},\n\t\t{{0x4f, 0xa3}, {0x50, 0xab}, {0x51, 0x08}, {0x52, 0x28},\n\t\t {0x53, 0x66}, {0x54, 0x8e}},\n\t};\n\n\tswitch (sd->sensor) {\n\tcase SEN_OV8610:\n\tcase SEN_OV7610:\n\tcase SEN_OV76BE:\n\tcase SEN_OV6620:\n\tcase SEN_OV6630:\n\tcase SEN_OV66308AF:\n\t\ti2c_w(sd, OV7610_REG_SAT, val);\n\t\tbreak;\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\t\t \n \n\t\ti2c_w(sd, OV7610_REG_SAT, val);\n\t\tbreak;\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\t\ti2c_w(sd, OV7610_REG_SAT, val & 0xf0);\n\t\tbreak;\n\tcase SEN_OV7660:\n\t\twrite_i2c_regvals(sd, colors_7660[val],\n\t\t\t\t\tARRAY_SIZE(colors_7660[0]));\n\t\tbreak;\n\tcase SEN_OV7670:\n\t\t \n\t\t \n\t\tbreak;\n\t}\n}\n\nstatic void setautobright(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\ti2c_w_mask(sd, 0x2d, val ? 0x10 : 0x00, 0x10);\n}\n\nstatic void setfreq_i(struct sd *sd, s32 val)\n{\n\tif (sd->sensor == SEN_OV7660\n\t || sd->sensor == SEN_OV7670) {\n\t\tswitch (val) {\n\t\tcase 0:  \n\t\t\ti2c_w_mask(sd, OV7670_R13_COM8, 0, OV7670_COM8_BFILT);\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\ti2c_w_mask(sd, OV7670_R13_COM8, OV7670_COM8_BFILT,\n\t\t\t\t   OV7670_COM8_BFILT);\n\t\t\ti2c_w_mask(sd, OV7670_R3B_COM11, 0x08, 0x18);\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\ti2c_w_mask(sd, OV7670_R13_COM8, OV7670_COM8_BFILT,\n\t\t\t\t   OV7670_COM8_BFILT);\n\t\t\ti2c_w_mask(sd, OV7670_R3B_COM11, 0x00, 0x18);\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\ti2c_w_mask(sd, OV7670_R13_COM8, OV7670_COM8_BFILT,\n\t\t\t\t   OV7670_COM8_BFILT);\n\t\t\ti2c_w_mask(sd, OV7670_R3B_COM11, OV7670_COM11_HZAUTO,\n\t\t\t\t   0x18);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (val) {\n\t\tcase 0:  \n\t\t\ti2c_w_mask(sd, 0x2d, 0x00, 0x04);\n\t\t\ti2c_w_mask(sd, 0x2a, 0x00, 0x80);\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\ti2c_w_mask(sd, 0x2d, 0x04, 0x04);\n\t\t\ti2c_w_mask(sd, 0x2a, 0x80, 0x80);\n\t\t\t \n\t\t\tif (sd->sensor == SEN_OV6620 ||\n\t\t\t    sd->sensor == SEN_OV6630 ||\n\t\t\t    sd->sensor == SEN_OV66308AF)\n\t\t\t\ti2c_w(sd, 0x2b, 0x5e);\n\t\t\telse\n\t\t\t\ti2c_w(sd, 0x2b, 0xac);\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\ti2c_w_mask(sd, 0x2d, 0x04, 0x04);\n\t\t\tif (sd->sensor == SEN_OV6620 ||\n\t\t\t    sd->sensor == SEN_OV6630 ||\n\t\t\t    sd->sensor == SEN_OV66308AF) {\n\t\t\t\t \n\t\t\t\ti2c_w_mask(sd, 0x2a, 0x80, 0x80);\n\t\t\t\ti2c_w(sd, 0x2b, 0xa8);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\ti2c_w_mask(sd, 0x2a, 0x00, 0x80);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void setfreq(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tsetfreq_i(sd, val);\n\n\t \n\tif (sd->bridge == BRIDGE_W9968CF)\n\t\tw9968cf_set_crop_window(sd);\n}\n\nstatic int sd_get_jcomp(struct gspca_dev *gspca_dev,\n\t\t\tstruct v4l2_jpegcompression *jcomp)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->bridge != BRIDGE_W9968CF)\n\t\treturn -ENOTTY;\n\n\tmemset(jcomp, 0, sizeof *jcomp);\n\tjcomp->quality = v4l2_ctrl_g_ctrl(sd->jpegqual);\n\tjcomp->jpeg_markers = V4L2_JPEG_MARKER_DHT | V4L2_JPEG_MARKER_DQT |\n\t\t\t      V4L2_JPEG_MARKER_DRI;\n\treturn 0;\n}\n\nstatic int sd_set_jcomp(struct gspca_dev *gspca_dev,\n\t\t\tconst struct v4l2_jpegcompression *jcomp)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->bridge != BRIDGE_W9968CF)\n\t\treturn -ENOTTY;\n\n\tv4l2_ctrl_s_ctrl(sd->jpegqual, jcomp->quality);\n\treturn 0;\n}\n\nstatic int sd_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTOGAIN:\n\t\tgspca_dev->exposure->val = i2c_r(sd, 0x10);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsetbrightness(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tsetcontrast(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_POWER_LINE_FREQUENCY:\n\t\tsetfreq(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTOBRIGHTNESS:\n\t\tif (ctrl->is_new)\n\t\t\tsetautobright(gspca_dev, ctrl->val);\n\t\tif (!ctrl->val && sd->brightness->is_new)\n\t\t\tsetbrightness(gspca_dev, sd->brightness->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tsetcolors(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tsethvflip(gspca_dev, ctrl->val, sd->vflip->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\tif (ctrl->is_new)\n\t\t\tsetautogain(gspca_dev, ctrl->val);\n\t\tif (!ctrl->val && gspca_dev->exposure->is_new)\n\t\t\tsetexposure(gspca_dev, gspca_dev->exposure->val);\n\t\tbreak;\n\tcase V4L2_CID_JPEG_COMPRESSION_QUALITY:\n\t\treturn -EBUSY;  \n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.g_volatile_ctrl = sd_g_volatile_ctrl,\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 10);\n\tif (valid_controls[sd->sensor].has_brightness)\n\t\tsd->brightness = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0,\n\t\t\tsd->sensor == SEN_OV7660 ? 6 : 255, 1,\n\t\t\tsd->sensor == SEN_OV7660 ? 3 : 127);\n\tif (valid_controls[sd->sensor].has_contrast) {\n\t\tif (sd->sensor == SEN_OV7660)\n\t\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\tV4L2_CID_CONTRAST, 0, 6, 1, 3);\n\t\telse\n\t\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\tV4L2_CID_CONTRAST, 0, 255, 1,\n\t\t\t\t(sd->sensor == SEN_OV6630 ||\n\t\t\t\t sd->sensor == SEN_OV66308AF) ? 200 : 127);\n\t}\n\tif (valid_controls[sd->sensor].has_sat)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0,\n\t\t\tsd->sensor == SEN_OV7660 ? 4 : 255, 1,\n\t\t\tsd->sensor == SEN_OV7660 ? 2 : 127);\n\tif (valid_controls[sd->sensor].has_exposure)\n\t\tgspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE, 0, 255, 1, 127);\n\tif (valid_controls[sd->sensor].has_hvflip) {\n\t\tsd->hflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\t\tsd->vflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\t}\n\tif (valid_controls[sd->sensor].has_autobright)\n\t\tsd->autobright = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_AUTOBRIGHTNESS, 0, 1, 1, 1);\n\tif (valid_controls[sd->sensor].has_autogain)\n\t\tgspca_dev->autogain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\tif (valid_controls[sd->sensor].has_freq) {\n\t\tif (sd->sensor == SEN_OV7670)\n\t\t\tsd->freq = v4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\n\t\t\t\tV4L2_CID_POWER_LINE_FREQUENCY,\n\t\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_AUTO, 0,\n\t\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_AUTO);\n\t\telse\n\t\t\tsd->freq = v4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\n\t\t\t\tV4L2_CID_POWER_LINE_FREQUENCY,\n\t\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_60HZ, 0, 0);\n\t}\n\tif (sd->bridge == BRIDGE_W9968CF)\n\t\tsd->jpegqual = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_JPEG_COMPRESSION_QUALITY,\n\t\t\tQUALITY_MIN, QUALITY_MAX, 1, QUALITY_DEF);\n\n\tif (hdl->error) {\n\t\tgspca_err(gspca_dev, \"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\tif (gspca_dev->autogain)\n\t\tv4l2_ctrl_auto_cluster(3, &gspca_dev->autogain, 0, true);\n\tif (sd->autobright)\n\t\tv4l2_ctrl_auto_cluster(2, &sd->autobright, 0, false);\n\tif (sd->hflip)\n\t\tv4l2_ctrl_cluster(2, &sd->hflip);\n\treturn 0;\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.isoc_init = sd_isoc_init,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.stop0 = sd_stop0,\n\t.pkt_scan = sd_pkt_scan,\n\t.dq_callback = sd_reset_snapshot,\n\t.get_jcomp = sd_get_jcomp,\n\t.set_jcomp = sd_set_jcomp,\n#if IS_ENABLED(CONFIG_INPUT)\n\t.other_input = 1,\n#endif\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x041e, 0x4003), .driver_info = BRIDGE_W9968CF },\n\t{USB_DEVICE(0x041e, 0x4052),\n\t\t.driver_info = BRIDGE_OV519 | BRIDGE_INVERT_LED },\n\t{USB_DEVICE(0x041e, 0x405f), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x041e, 0x4060), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x041e, 0x4061), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x041e, 0x4064), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x041e, 0x4067), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x041e, 0x4068), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x045e, 0x028c),\n\t\t.driver_info = BRIDGE_OV519 | BRIDGE_INVERT_LED },\n\t{USB_DEVICE(0x054c, 0x0154), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x054c, 0x0155), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x05a9, 0x0511), .driver_info = BRIDGE_OV511 },\n\t{USB_DEVICE(0x05a9, 0x0518), .driver_info = BRIDGE_OV518 },\n\t{USB_DEVICE(0x05a9, 0x0519),\n\t\t.driver_info = BRIDGE_OV519 | BRIDGE_INVERT_LED },\n\t{USB_DEVICE(0x05a9, 0x0530),\n\t\t.driver_info = BRIDGE_OV519 | BRIDGE_INVERT_LED },\n\t{USB_DEVICE(0x05a9, 0x2800), .driver_info = BRIDGE_OVFX2 },\n\t{USB_DEVICE(0x05a9, 0x4519), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x05a9, 0x8519), .driver_info = BRIDGE_OV519 },\n\t{USB_DEVICE(0x05a9, 0xa511), .driver_info = BRIDGE_OV511PLUS },\n\t{USB_DEVICE(0x05a9, 0xa518), .driver_info = BRIDGE_OV518PLUS },\n\t{USB_DEVICE(0x0813, 0x0002), .driver_info = BRIDGE_OV511PLUS },\n\t{USB_DEVICE(0x0b62, 0x0059), .driver_info = BRIDGE_OVFX2 },\n\t{USB_DEVICE(0x0e96, 0xc001), .driver_info = BRIDGE_OVFX2 },\n\t{USB_DEVICE(0x1046, 0x9967), .driver_info = BRIDGE_W9968CF },\n\t{USB_DEVICE(0x8020, 0xef04), .driver_info = BRIDGE_OVFX2 },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n\nmodule_param(frame_rate, int, 0644);\nMODULE_PARM_DESC(frame_rate, \"Frame rate (5, 10, 15, 20 or 30 fps)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}