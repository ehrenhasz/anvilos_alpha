{
  "module_name": "sonixb.c",
  "hash_id": "81348731e04206552318b74ea27120f8e8c68d752532fcd8796efe17989692a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/sonixb.c",
  "human_readable_source": "\n \n\n \n\n#define MODULE_NAME \"sonixb\"\n\n#include <linux/input.h>\n#include \"gspca.h\"\n\nMODULE_AUTHOR(\"Jean-Fran\u00e7ois Moine <http://moinejf.free.fr>\");\nMODULE_DESCRIPTION(\"GSPCA/SN9C102 USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t \n\n\tstruct v4l2_ctrl *brightness;\n\tstruct v4l2_ctrl *plfreq;\n\n\tatomic_t avg_lum;\n\tint prev_avg_lum;\n\tint exposure_knee;\n\tint header_read;\n\tu8 header[12];  \n\n\tunsigned char autogain_ignore_frames;\n\tunsigned char frames_to_drop;\n\n\t__u8 bridge;\t\t\t \n#define BRIDGE_101 0\n#define BRIDGE_102 0  \n#define BRIDGE_103 1\n\n\t__u8 sensor;\t\t\t \n#define SENSOR_HV7131D 0\n#define SENSOR_HV7131R 1\n#define SENSOR_OV6650 2\n#define SENSOR_OV7630 3\n#define SENSOR_PAS106 4\n#define SENSOR_PAS202 5\n#define SENSOR_TAS5110C 6\n#define SENSOR_TAS5110D 7\n#define SENSOR_TAS5130CXX 8\n\t__u8 reg11;\n};\n\ntypedef const __u8 sensor_init_t[8];\n\nstruct sensor_data {\n\tconst __u8 *bridge_init;\n\tsensor_init_t *sensor_init;\n\tint sensor_init_size;\n\tint flags;\n\t__u8 sensor_addr;\n};\n\n \n#define F_SIF\t\t0x01\t \n\n \n#define MODE_RAW 0x10\t\t \n#define MODE_REDUCED_SIF 0x20\t \n\n#define COMP 0xc7\t\t \n\n#define SYS_CLK 0x04\n\n#define SENS(bridge, sensor, _flags, _sensor_addr) \\\n{ \\\n\t.bridge_init = bridge, \\\n\t.sensor_init = sensor, \\\n\t.sensor_init_size = sizeof(sensor), \\\n\t.flags = _flags, .sensor_addr = _sensor_addr \\\n}\n\n \n#define AUTOGAIN_IGNORE_FRAMES 1\n\nstatic const struct v4l2_pix_format vga_mode[] = {\n\t{160, 120, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 160 * 120,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 2 | MODE_RAW},\n\t{160, 120, V4L2_PIX_FMT_SN9C10X, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 160 * 120 * 5 / 4,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 2},\n\t{320, 240, V4L2_PIX_FMT_SN9C10X, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 5 / 4,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{640, 480, V4L2_PIX_FMT_SN9C10X, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 5 / 4,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n};\nstatic const struct v4l2_pix_format sif_mode[] = {\n\t{160, 120, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 160 * 120,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1 | MODE_RAW | MODE_REDUCED_SIF},\n\t{160, 120, V4L2_PIX_FMT_SN9C10X, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 160 * 120 * 5 / 4,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1 | MODE_REDUCED_SIF},\n\t{176, 144, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 176 * 144,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1 | MODE_RAW},\n\t{176, 144, V4L2_PIX_FMT_SN9C10X, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 176 * 144 * 5 / 4,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{320, 240, V4L2_PIX_FMT_SN9C10X, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 5 / 4,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0 | MODE_REDUCED_SIF},\n\t{352, 288, V4L2_PIX_FMT_SN9C10X, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352,\n\t\t.sizeimage = 352 * 288 * 5 / 4,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n};\n\nstatic const __u8 initHv7131d[] = {\n\t0x04, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x80, 0x11, 0x00, 0x00, 0x00,\n\t0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x02, 0x02, 0x00,\n\t0x28, 0x1e, 0x60, 0x8e, 0x42,\n};\nstatic const __u8 hv7131d_sensor_init[][8] = {\n\t{0xa0, 0x11, 0x01, 0x04, 0x00, 0x00, 0x00, 0x17},\n\t{0xa0, 0x11, 0x02, 0x00, 0x00, 0x00, 0x00, 0x17},\n\t{0xa0, 0x11, 0x28, 0x00, 0x00, 0x00, 0x00, 0x17},\n\t{0xa0, 0x11, 0x30, 0x30, 0x00, 0x00, 0x00, 0x17},  \n\t{0xa0, 0x11, 0x34, 0x02, 0x00, 0x00, 0x00, 0x17},  \n};\n\nstatic const __u8 initHv7131r[] = {\n\t0x46, 0x77, 0x00, 0x04, 0x00, 0x00, 0x00, 0x80, 0x11, 0x00, 0x00, 0x00,\n\t0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x02, 0x01, 0x00,\n\t0x28, 0x1e, 0x60, 0x8a, 0x20,\n};\nstatic const __u8 hv7131r_sensor_init[][8] = {\n\t{0xc0, 0x11, 0x31, 0x38, 0x2a, 0x2e, 0x00, 0x10},\n\t{0xa0, 0x11, 0x01, 0x08, 0x2a, 0x2e, 0x00, 0x10},\n\t{0xb0, 0x11, 0x20, 0x00, 0xd0, 0x2e, 0x00, 0x10},\n\t{0xc0, 0x11, 0x25, 0x03, 0x0e, 0x28, 0x00, 0x16},\n\t{0xa0, 0x11, 0x30, 0x10, 0x0e, 0x28, 0x00, 0x15},\n};\nstatic const __u8 initOv6650[] = {\n\t0x44, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,\n\t0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x01, 0x01, 0x0a, 0x16, 0x12, 0x68, 0x8b,\n\t0x10,\n};\nstatic const __u8 ov6650_sensor_init[][8] = {\n\t \n\t \n\n\t \n\t{0xa0, 0x60, 0x12, 0x80, 0x00, 0x00, 0x00, 0x10},\n\t \n\t{0xd0, 0x60, 0x11, 0xc0, 0x1b, 0x18, 0xc1, 0x10},\n\t \n\t{0xb0, 0x60, 0x15, 0x00, 0x02, 0x18, 0xc1, 0x10},\n \n\t{0xd0, 0x60, 0x26, 0x01, 0x14, 0xd8, 0xa4, 0x10},  \n\t{0xd0, 0x60, 0x26, 0x01, 0x14, 0xd8, 0xa4, 0x10},\n\t{0xa0, 0x60, 0x30, 0x3d, 0x0a, 0xd8, 0xa4, 0x10},\n\t \n\t{0xa0, 0x60, 0x61, 0x08, 0x00, 0x00, 0x00, 0x10},\n\t \n\t \n\t{0xa0, 0x60, 0x68, 0x04, 0x68, 0xd8, 0xa4, 0x10},\n\t{0xd0, 0x60, 0x17, 0x24, 0xd6, 0x04, 0x94, 0x10},  \n};\n\nstatic const __u8 initOv7630[] = {\n\t0x04, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,\t \n\t0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\t \n\t0x00, 0x01, 0x01, 0x0a,\t\t\t\t \n\t0x28, 0x1e,\t\t\t \n\t0x68, 0x8f, MCK_INIT1,\t\t\t\t \n};\nstatic const __u8 ov7630_sensor_init[][8] = {\n\t{0xa0, 0x21, 0x12, 0x80, 0x00, 0x00, 0x00, 0x10},\n\t{0xb0, 0x21, 0x01, 0x77, 0x3a, 0x00, 0x00, 0x10},\n \n\t{0xd0, 0x21, 0x12, 0x5c, 0x00, 0x80, 0x34, 0x10},\t \n\t{0xa0, 0x21, 0x1b, 0x04, 0x00, 0x80, 0x34, 0x10},\n\t{0xa0, 0x21, 0x20, 0x44, 0x00, 0x80, 0x34, 0x10},\n\t{0xa0, 0x21, 0x23, 0xee, 0x00, 0x80, 0x34, 0x10},\n\t{0xd0, 0x21, 0x26, 0xa0, 0x9a, 0xa0, 0x30, 0x10},\n\t{0xb0, 0x21, 0x2a, 0x80, 0x00, 0xa0, 0x30, 0x10},\n\t{0xb0, 0x21, 0x2f, 0x3d, 0x24, 0xa0, 0x30, 0x10},\n\t{0xa0, 0x21, 0x32, 0x86, 0x24, 0xa0, 0x30, 0x10},\n\t{0xb0, 0x21, 0x60, 0xa9, 0x4a, 0xa0, 0x30, 0x10},\n \n\t{0xa0, 0x21, 0x65, 0x00, 0x42, 0xa0, 0x30, 0x10},\n\t{0xa0, 0x21, 0x69, 0x38, 0x42, 0xa0, 0x30, 0x10},\n\t{0xc0, 0x21, 0x6f, 0x88, 0x0b, 0x00, 0x30, 0x10},\n\t{0xc0, 0x21, 0x74, 0x21, 0x8e, 0x00, 0x30, 0x10},\n\t{0xa0, 0x21, 0x7d, 0xf7, 0x8e, 0x00, 0x30, 0x10},\n\t{0xd0, 0x21, 0x17, 0x1c, 0xbd, 0x06, 0xf6, 0x10},\n};\n\nstatic const __u8 initPas106[] = {\n\t0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x40, 0x00, 0x00, 0x00,\n\t0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x04, 0x01, 0x00,\n\t0x16, 0x12, 0x24, COMP1, MCK_INIT1,\n};\n \n\n \n\nstatic const __u8 pas106_sensor_init[][8] = {\n\t \n\t{ 0xa1, 0x40, 0x02, 0x04, 0x00, 0x00, 0x00, 0x14 },\n\t \n\t{ 0xa1, 0x40, 0x03, 0x13, 0x00, 0x00, 0x00, 0x14 },\n\t \n\t{ 0xa1, 0x40, 0x04, 0x06, 0x00, 0x00, 0x00, 0x14 },\n\t \n\t{ 0xa1, 0x40, 0x05, 0x65, 0x00, 0x00, 0x00, 0x14 },\n\t \n\t{ 0xa1, 0x40, 0x06, 0xcd, 0x00, 0x00, 0x00, 0x14 },\n\t \n\t{ 0xa1, 0x40, 0x07, 0xc1, 0x00, 0x00, 0x00, 0x14 },\n\t \n\t{ 0xa1, 0x40, 0x08, 0x06, 0x00, 0x00, 0x00, 0x14 },\n\t{ 0xa1, 0x40, 0x08, 0x06, 0x00, 0x00, 0x00, 0x14 },\n\t \n\t{ 0xa1, 0x40, 0x09, 0x05, 0x00, 0x00, 0x00, 0x14 },\n\t \n\t{ 0xa1, 0x40, 0x0a, 0x04, 0x00, 0x00, 0x00, 0x14 },\n\t \n\t{ 0xa1, 0x40, 0x0b, 0x04, 0x00, 0x00, 0x00, 0x14 },\n\t \n\t{ 0xa1, 0x40, 0x0c, 0x05, 0x00, 0x00, 0x00, 0x14 },\n\t \n\t{ 0xa1, 0x40, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x14 },\n\t \n\t{ 0xa1, 0x40, 0x0e, 0x0e, 0x00, 0x00, 0x00, 0x14 },\n\t \n\t{ 0xa1, 0x40, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x14 },\n\t \n\t{ 0xa1, 0x40, 0x10, 0x06, 0x00, 0x00, 0x00, 0x14 },\n\t \n\t{ 0xa1, 0x40, 0x11, 0x06, 0x00, 0x00, 0x00, 0x14 },\n\t \n\t{ 0xa1, 0x40, 0x12, 0x06, 0x00, 0x00, 0x00, 0x14 },\n\t \n\t{ 0xa1, 0x40, 0x14, 0x02, 0x00, 0x00, 0x00, 0x14 },\n\t \n\t{ 0xa1, 0x40, 0x13, 0x01, 0x00, 0x00, 0x00, 0x14 },\n};\n\nstatic const __u8 initPas202[] = {\n\t0x44, 0x44, 0x21, 0x30, 0x00, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x00,\n\t0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x06, 0x03, 0x0a,\n\t0x28, 0x1e, 0x20, 0x89, 0x20,\n};\n\n \nstatic const __u8 pas202_sensor_init[][8] = {\n\t \n\t{0xa0, 0x40, 0x02, 0x04, 0x00, 0x00, 0x00, 0x10},\n\t{0xd0, 0x40, 0x04, 0x07, 0x34, 0x00, 0x09, 0x10},\n\t{0xd0, 0x40, 0x08, 0x01, 0x00, 0x00, 0x01, 0x10},\n\t{0xd0, 0x40, 0x0c, 0x00, 0x0c, 0x01, 0x32, 0x10},\n\t{0xd0, 0x40, 0x10, 0x00, 0x01, 0x00, 0x63, 0x10},\n\t{0xa0, 0x40, 0x15, 0x70, 0x01, 0x00, 0x63, 0x10},\n\t{0xa0, 0x40, 0x18, 0x00, 0x01, 0x00, 0x63, 0x10},\n\t{0xa0, 0x40, 0x11, 0x01, 0x01, 0x00, 0x63, 0x10},\n\t{0xa0, 0x40, 0x03, 0x56, 0x01, 0x00, 0x63, 0x10},\n\t{0xa0, 0x40, 0x11, 0x01, 0x01, 0x00, 0x63, 0x10},\n};\n\nstatic const __u8 initTas5110c[] = {\n\t0x44, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x11, 0x00, 0x00, 0x00,\n\t0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x45, 0x09, 0x0a,\n\t0x16, 0x12, 0x60, 0x86, 0x2b,\n};\n \nstatic const __u8 initTas5110d[] = {\n\t0x44, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x11, 0x00, 0x00, 0x00,\n\t0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x41, 0x09, 0x0a,\n\t0x16, 0x12, 0x60, 0x86, 0x2b,\n};\n \nstatic const __u8 tas5110c_sensor_init[][8] = {\n\t{0x30, 0x11, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x10},\n\t{0x30, 0x11, 0x02, 0x20, 0xa9, 0x00, 0x00, 0x10},\n};\n \nstatic const __u8 tas5110d_sensor_init[][8] = {\n\t{0xa0, 0x61, 0x9a, 0xca, 0x00, 0x00, 0x00, 0x17},  \n};\n\nstatic const __u8 initTas5130[] = {\n\t0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x11, 0x00, 0x00, 0x00,\n\t0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x68, 0x0c, 0x0a,\n\t0x28, 0x1e, 0x60, COMP, MCK_INIT,\n};\nstatic const __u8 tas5130_sensor_init[][8] = {\n \n\t{0x30, 0x11, 0x00, 0x40, 0x01, 0x00, 0x00, 0x10},\n\t\t\t\t\t \n\t{0x30, 0x11, 0x02, 0x20, 0x70, 0x00, 0x00, 0x10},\n};\n\nstatic const struct sensor_data sensor_data[] = {\n\tSENS(initHv7131d, hv7131d_sensor_init, 0, 0),\n\tSENS(initHv7131r, hv7131r_sensor_init, 0, 0),\n\tSENS(initOv6650, ov6650_sensor_init, F_SIF, 0x60),\n\tSENS(initOv7630, ov7630_sensor_init, 0, 0x21),\n\tSENS(initPas106, pas106_sensor_init, F_SIF, 0),\n\tSENS(initPas202, pas202_sensor_init, 0, 0),\n\tSENS(initTas5110c, tas5110c_sensor_init, F_SIF, 0),\n\tSENS(initTas5110d, tas5110d_sensor_init, F_SIF, 0),\n\tSENS(initTas5130, tas5130_sensor_init, 0, 0),\n};\n\n \nstatic void reg_r(struct gspca_dev *gspca_dev,\n\t\t  __u16 value)\n{\n\tint res;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\n\tres = usb_control_msg(gspca_dev->dev,\n\t\t\tusb_rcvctrlpipe(gspca_dev->dev, 0),\n\t\t\t0,\t\t\t \n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\tvalue,\n\t\t\t0,\t\t\t \n\t\t\tgspca_dev->usb_buf, 1,\n\t\t\t500);\n\n\tif (res < 0) {\n\t\tdev_err(gspca_dev->v4l2_dev.dev,\n\t\t\t\"Error reading register %02x: %d\\n\", value, res);\n\t\tgspca_dev->usb_err = res;\n\t\t \n\t\tgspca_dev->usb_buf[0] = 0;\n\t}\n}\n\nstatic void reg_w(struct gspca_dev *gspca_dev,\n\t\t  __u16 value,\n\t\t  const __u8 *buffer,\n\t\t  int len)\n{\n\tint res;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\n\tmemcpy(gspca_dev->usb_buf, buffer, len);\n\tres = usb_control_msg(gspca_dev->dev,\n\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t0x08,\t\t\t \n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\tvalue,\n\t\t\t0,\t\t\t \n\t\t\tgspca_dev->usb_buf, len,\n\t\t\t500);\n\n\tif (res < 0) {\n\t\tdev_err(gspca_dev->v4l2_dev.dev,\n\t\t\t\"Error writing register %02x: %d\\n\", value, res);\n\t\tgspca_dev->usb_err = res;\n\t}\n}\n\nstatic void i2c_w(struct gspca_dev *gspca_dev, const u8 *buf)\n{\n\tint retry = 60;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\n\t \n\treg_w(gspca_dev, 0x08, buf, 8);\n\twhile (retry--) {\n\t\tif (gspca_dev->usb_err < 0)\n\t\t\treturn;\n\t\tmsleep(1);\n\t\treg_r(gspca_dev, 0x08);\n\t\tif (gspca_dev->usb_buf[0] & 0x04) {\n\t\t\tif (gspca_dev->usb_buf[0] & 0x08) {\n\t\t\t\tdev_err(gspca_dev->v4l2_dev.dev,\n\t\t\t\t\t\"i2c error writing %8ph\\n\", buf);\n\t\t\t\tgspca_dev->usb_err = -EIO;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdev_err(gspca_dev->v4l2_dev.dev, \"i2c write timeout\\n\");\n\tgspca_dev->usb_err = -EIO;\n}\n\nstatic void i2c_w_vector(struct gspca_dev *gspca_dev,\n\t\t\tconst __u8 buffer[][8], int len)\n{\n\tfor (;;) {\n\t\tif (gspca_dev->usb_err < 0)\n\t\t\treturn;\n\t\ti2c_w(gspca_dev, *buffer);\n\t\tlen -= 8;\n\t\tif (len <= 0)\n\t\t\tbreak;\n\t\tbuffer++;\n\t}\n}\n\nstatic void setbrightness(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tswitch (sd->sensor) {\n\tcase  SENSOR_OV6650:\n\tcase  SENSOR_OV7630: {\n\t\t__u8 i2cOV[] =\n\t\t\t{0xa0, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x10};\n\n\t\t \n\t\ti2cOV[1] = sensor_data[sd->sensor].sensor_addr;\n\t\ti2cOV[3] = sd->brightness->val;\n\t\ti2c_w(gspca_dev, i2cOV);\n\t\tbreak;\n\t}\n\tcase SENSOR_PAS106:\n\tcase SENSOR_PAS202: {\n\t\t__u8 i2cpbright[] =\n\t\t\t{0xb0, 0x40, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x16};\n\t\t__u8 i2cpdoit[] =\n\t\t\t{0xa0, 0x40, 0x11, 0x01, 0x00, 0x00, 0x00, 0x16};\n\n\t\t \n\t\tif (sd->sensor == SENSOR_PAS106) {\n\t\t\ti2cpbright[2] = 7;\n\t\t\ti2cpdoit[2] = 0x13;\n\t\t}\n\n\t\tif (sd->brightness->val < 127) {\n\t\t\t \n\t\t\ti2cpbright[3] = 0x01;\n\t\t\t \n\t\t\ti2cpbright[4] = 127 - sd->brightness->val;\n\t\t} else\n\t\t\ti2cpbright[4] = sd->brightness->val - 127;\n\n\t\ti2c_w(gspca_dev, i2cpbright);\n\t\ti2c_w(gspca_dev, i2cpdoit);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void setgain(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 gain = gspca_dev->gain->val;\n\n\tswitch (sd->sensor) {\n\tcase SENSOR_HV7131D: {\n\t\t__u8 i2c[] =\n\t\t\t{0xc0, 0x11, 0x31, 0x00, 0x00, 0x00, 0x00, 0x17};\n\n\t\ti2c[3] = 0x3f - gain;\n\t\ti2c[4] = 0x3f - gain;\n\t\ti2c[5] = 0x3f - gain;\n\n\t\ti2c_w(gspca_dev, i2c);\n\t\tbreak;\n\t}\n\tcase SENSOR_TAS5110C:\n\tcase SENSOR_TAS5130CXX: {\n\t\t__u8 i2c[] =\n\t\t\t{0x30, 0x11, 0x02, 0x20, 0x70, 0x00, 0x00, 0x10};\n\n\t\ti2c[4] = 255 - gain;\n\t\ti2c_w(gspca_dev, i2c);\n\t\tbreak;\n\t}\n\tcase SENSOR_TAS5110D: {\n\t\t__u8 i2c[] = {\n\t\t\t0xb0, 0x61, 0x02, 0x00, 0x10, 0x00, 0x00, 0x17 };\n\t\tgain = 255 - gain;\n\t\t \n\t\ti2c[3] |= (gain & 0x80) >> 7;\n\t\ti2c[3] |= (gain & 0x40) >> 5;\n\t\ti2c[3] |= (gain & 0x20) >> 3;\n\t\ti2c[3] |= (gain & 0x10) >> 1;\n\t\ti2c[3] |= (gain & 0x08) << 1;\n\t\ti2c[3] |= (gain & 0x04) << 3;\n\t\ti2c[3] |= (gain & 0x02) << 5;\n\t\ti2c[3] |= (gain & 0x01) << 7;\n\t\ti2c_w(gspca_dev, i2c);\n\t\tbreak;\n\t}\n\tcase SENSOR_OV6650:\n\tcase SENSOR_OV7630: {\n\t\t__u8 i2c[] = {0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};\n\n\t\t \n\t\tif (sd->sensor == SENSOR_OV7630 && gain >= 32)\n\t\t\tgain += 16;\n\n\t\ti2c[1] = sensor_data[sd->sensor].sensor_addr;\n\t\ti2c[3] = gain;\n\t\ti2c_w(gspca_dev, i2c);\n\t\tbreak;\n\t}\n\tcase SENSOR_PAS106:\n\tcase SENSOR_PAS202: {\n\t\t__u8 i2cpgain[] =\n\t\t\t{0xa0, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x15};\n\t\t__u8 i2cpcolorgain[] =\n\t\t\t{0xc0, 0x40, 0x07, 0x00, 0x00, 0x00, 0x00, 0x15};\n\t\t__u8 i2cpdoit[] =\n\t\t\t{0xa0, 0x40, 0x11, 0x01, 0x00, 0x00, 0x00, 0x16};\n\n\t\t \n\t\tif (sd->sensor == SENSOR_PAS106) {\n\t\t\ti2cpgain[2] = 0x0e;\n\t\t\ti2cpcolorgain[0] = 0xd0;\n\t\t\ti2cpcolorgain[2] = 0x09;\n\t\t\ti2cpdoit[2] = 0x13;\n\t\t}\n\n\t\ti2cpgain[3] = gain;\n\t\ti2cpcolorgain[3] = gain >> 1;\n\t\ti2cpcolorgain[4] = gain >> 1;\n\t\ti2cpcolorgain[5] = gain >> 1;\n\t\ti2cpcolorgain[6] = gain >> 1;\n\n\t\ti2c_w(gspca_dev, i2cpgain);\n\t\ti2c_w(gspca_dev, i2cpcolorgain);\n\t\ti2c_w(gspca_dev, i2cpdoit);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tif (sd->bridge == BRIDGE_103) {\n\t\t\tu8 buf[3] = { gain, gain, gain };  \n\t\t\treg_w(gspca_dev, 0x05, buf, 3);\n\t\t} else {\n\t\t\tu8 buf[2];\n\t\t\tbuf[0] = gain << 4 | gain;  \n\t\t\tbuf[1] = gain;  \n\t\t\treg_w(gspca_dev, 0x10, buf, 2);\n\t\t}\n\t}\n}\n\nstatic void setexposure(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tswitch (sd->sensor) {\n\tcase SENSOR_HV7131D: {\n\t\t \n\t\t__u8 i2c[] = {0xc0, 0x11, 0x25, 0x00, 0x00, 0x00, 0x00, 0x17};\n\t\tu16 reg = gspca_dev->exposure->val;\n\n\t\ti2c[3] = reg >> 8;\n\t\ti2c[4] = reg & 0xff;\n\t\ti2c_w(gspca_dev, i2c);\n\t\tbreak;\n\t}\n\tcase SENSOR_TAS5110C:\n\tcase SENSOR_TAS5110D: {\n\t\t \n\t\tu8 reg = gspca_dev->exposure->val;\n\n\t\treg = (reg << 4) | 0x0b;\n\t\treg_w(gspca_dev, 0x19, &reg, 1);\n\t\tbreak;\n\t}\n\tcase SENSOR_OV6650:\n\tcase SENSOR_OV7630: {\n\t\t \n\t\t__u8 i2c[] = {0xb0, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x10};\n\t\tint reg10, reg11, reg10_max;\n\n\t\t \n\t\tif (sd->sensor == SENSOR_OV6650) {\n\t\t\treg10_max = 0x4d;\n\t\t\ti2c[4] = 0xc0;  \n\t\t} else\n\t\t\treg10_max = 0x41;\n\n\t\treg11 = (15 * gspca_dev->exposure->val + 999) / 1000;\n\t\tif (reg11 < 1)\n\t\t\treg11 = 1;\n\t\telse if (reg11 > 16)\n\t\t\treg11 = 16;\n\n\t\t \n\t\tif (gspca_dev->pixfmt.width == 640 && reg11 < 4)\n\t\t\treg11 = 4;\n\n\t\t \n\t\treg10 = (gspca_dev->exposure->val * 15 * reg10_max)\n\t\t\t\t/ (1000 * reg11);\n\n\t\t \n\t\tif (gspca_dev->autogain->val && reg10 < 10)\n\t\t\treg10 = 10;\n\t\telse if (reg10 > reg10_max)\n\t\t\treg10 = reg10_max;\n\n\t\t \n\t\ti2c[1] = sensor_data[sd->sensor].sensor_addr;\n\t\ti2c[3] = reg10;\n\t\ti2c[4] |= reg11 - 1;\n\n\t\t \n\t\tif (sd->reg11 == reg11)\n\t\t\ti2c[0] = 0xa0;\n\n\t\ti2c_w(gspca_dev, i2c);\n\t\tif (gspca_dev->usb_err == 0)\n\t\t\tsd->reg11 = reg11;\n\t\tbreak;\n\t}\n\tcase SENSOR_PAS202: {\n\t\t__u8 i2cpframerate[] =\n\t\t\t{0xb0, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, 0x16};\n\t\t__u8 i2cpexpo[] =\n\t\t\t{0xa0, 0x40, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x16};\n\t\tconst __u8 i2cpdoit[] =\n\t\t\t{0xa0, 0x40, 0x11, 0x01, 0x00, 0x00, 0x00, 0x16};\n\t\tint framerate_ctrl;\n\n\t\t \n\t\tif (gspca_dev->exposure->val < 200) {\n\t\t\ti2cpexpo[3] = 255 - (gspca_dev->exposure->val * 255)\n\t\t\t\t\t\t/ 200;\n\t\t\tframerate_ctrl = 500;\n\t\t} else {\n\t\t\t \n\t\t\tframerate_ctrl = (gspca_dev->exposure->val - 200)\n\t\t\t\t\t\t\t* 1000 / 229 +  500;\n\t\t}\n\n\t\ti2cpframerate[3] = framerate_ctrl >> 6;\n\t\ti2cpframerate[4] = framerate_ctrl & 0x3f;\n\t\ti2c_w(gspca_dev, i2cpframerate);\n\t\ti2c_w(gspca_dev, i2cpexpo);\n\t\ti2c_w(gspca_dev, i2cpdoit);\n\t\tbreak;\n\t}\n\tcase SENSOR_PAS106: {\n\t\t__u8 i2cpframerate[] =\n\t\t\t{0xb1, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x14};\n\t\t__u8 i2cpexpo[] =\n\t\t\t{0xa1, 0x40, 0x05, 0x00, 0x00, 0x00, 0x00, 0x14};\n\t\tconst __u8 i2cpdoit[] =\n\t\t\t{0xa1, 0x40, 0x13, 0x01, 0x00, 0x00, 0x00, 0x14};\n\t\tint framerate_ctrl;\n\n\t\t \n\t\tif (gspca_dev->exposure->val < 150) {\n\t\t\ti2cpexpo[3] = 150 - gspca_dev->exposure->val;\n\t\t\tframerate_ctrl = 300;\n\t\t} else {\n\t\t\t \n\t\t\tframerate_ctrl = (gspca_dev->exposure->val - 150)\n\t\t\t\t\t\t* 1000 / 230 + 300;\n\t\t}\n\n\t\ti2cpframerate[3] = framerate_ctrl >> 4;\n\t\ti2cpframerate[4] = framerate_ctrl & 0x0f;\n\t\ti2c_w(gspca_dev, i2cpframerate);\n\t\ti2c_w(gspca_dev, i2cpexpo);\n\t\ti2c_w(gspca_dev, i2cpdoit);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void setfreq(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->sensor == SENSOR_OV6650 || sd->sensor == SENSOR_OV7630) {\n\t\t \n\t\t__u8 i2c[] = {0xa0, 0x00, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x10};\n\t\tswitch (sd->plfreq->val) {\n\t\tdefault:\n \n \n\t\t\ti2c[3] = 0;\n\t\t\tbreak;\n\t\tcase 1:\t\t\t \n\t\t\ti2c[3] = (sd->sensor == SENSOR_OV6650)\n\t\t\t\t\t? 0x4f : 0x8a;\n\t\t\tbreak;\n\t\t}\n\t\ti2c[1] = sensor_data[sd->sensor].sensor_addr;\n\t\ti2c_w(gspca_dev, i2c);\n\t}\n}\n\nstatic void do_autogain(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint deadzone, desired_avg_lum, avg_lum;\n\n\tavg_lum = atomic_read(&sd->avg_lum);\n\tif (avg_lum == -1)\n\t\treturn;\n\n\tif (sd->autogain_ignore_frames > 0) {\n\t\tsd->autogain_ignore_frames--;\n\t\treturn;\n\t}\n\n\t \n\tif (sensor_data[sd->sensor].flags & F_SIF) {\n\t\tdeadzone = 500;\n\t\t \n\t\tdesired_avg_lum = 5000;\n\t} else {\n\t\tdeadzone = 1500;\n\t\tdesired_avg_lum = 13000;\n\t}\n\n\tif (sd->brightness)\n\t\tdesired_avg_lum = sd->brightness->val * desired_avg_lum / 127;\n\n\tif (gspca_dev->exposure->maximum < 500) {\n\t\tif (gspca_coarse_grained_expo_autogain(gspca_dev, avg_lum,\n\t\t\t\tdesired_avg_lum, deadzone))\n\t\t\tsd->autogain_ignore_frames = AUTOGAIN_IGNORE_FRAMES;\n\t} else {\n\t\tint gain_knee = (s32)gspca_dev->gain->maximum * 9 / 10;\n\t\tif (gspca_expo_autogain(gspca_dev, avg_lum, desired_avg_lum,\n\t\t\t\tdeadzone, gain_knee, sd->exposure_knee))\n\t\t\tsd->autogain_ignore_frames = AUTOGAIN_IGNORE_FRAMES;\n\t}\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam;\n\n\treg_r(gspca_dev, 0x00);\n\tif (gspca_dev->usb_buf[0] != 0x10)\n\t\treturn -ENODEV;\n\n\t \n\tsd->sensor = id->driver_info >> 8;\n\tsd->bridge = id->driver_info & 0xff;\n\n\tcam = &gspca_dev->cam;\n\tif (!(sensor_data[sd->sensor].flags & F_SIF)) {\n\t\tcam->cam_mode = vga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(vga_mode);\n\t} else {\n\t\tcam->cam_mode = sif_mode;\n\t\tcam->nmodes = ARRAY_SIZE(sif_mode);\n\t}\n\tcam->npkt = 36;\t\t\t \n\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\tconst __u8 stop = 0x09;  \n\n\treg_w(gspca_dev, 0x01, &stop, 1);\n\n\treturn gspca_dev->usb_err;\n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tif (ctrl->id == V4L2_CID_AUTOGAIN && ctrl->is_new && ctrl->val) {\n\t\t \n\t\tgspca_dev->gain->val = gspca_dev->gain->default_value;\n\t\tgspca_dev->exposure->val = gspca_dev->exposure->default_value;\n\t\tsd->autogain_ignore_frames = AUTOGAIN_IGNORE_FRAMES;\n\t}\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsetbrightness(gspca_dev);\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\tif (gspca_dev->exposure->is_new || (ctrl->is_new && ctrl->val))\n\t\t\tsetexposure(gspca_dev);\n\t\tif (gspca_dev->gain->is_new || (ctrl->is_new && ctrl->val))\n\t\t\tsetgain(gspca_dev);\n\t\tbreak;\n\tcase V4L2_CID_POWER_LINE_FREQUENCY:\n\t\tsetfreq(gspca_dev);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\n \nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 5);\n\n\tif (sd->sensor == SENSOR_OV6650 || sd->sensor == SENSOR_OV7630 ||\n\t    sd->sensor == SENSOR_PAS106 || sd->sensor == SENSOR_PAS202)\n\t\tsd->brightness = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_BRIGHTNESS, 0, 255, 1, 127);\n\n\t \n\tswitch (sd->sensor) {\n\tcase SENSOR_OV6650:\n\tcase SENSOR_PAS106:\n\tcase SENSOR_PAS202:\n\t\tgspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_GAIN, 0, 31, 1, 15);\n\t\tbreak;\n\tcase SENSOR_OV7630:\n\t\tgspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_GAIN, 0, 47, 1, 31);\n\t\tbreak;\n\tcase SENSOR_HV7131D:\n\t\tgspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_GAIN, 0, 63, 1, 31);\n\t\tbreak;\n\tcase SENSOR_TAS5110C:\n\tcase SENSOR_TAS5110D:\n\tcase SENSOR_TAS5130CXX:\n\t\tgspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_GAIN, 0, 255, 1, 127);\n\t\tbreak;\n\tdefault:\n\t\tif (sd->bridge == BRIDGE_103) {\n\t\t\tgspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\t\tV4L2_CID_GAIN, 0, 127, 1, 63);\n\t\t} else {\n\t\t\tgspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\t\tV4L2_CID_GAIN, 0, 15, 1, 7);\n\t\t}\n\t}\n\n\t \n\tswitch (sd->sensor) {\n\tcase SENSOR_HV7131D:\n\t\tgspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_EXPOSURE, 0, 8191, 1, 482);\n\t\tsd->exposure_knee = 964;\n\t\tbreak;\n\tcase SENSOR_OV6650:\n\tcase SENSOR_OV7630:\n\tcase SENSOR_PAS106:\n\tcase SENSOR_PAS202:\n\t\tgspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_EXPOSURE, 0, 1023, 1, 66);\n\t\tsd->exposure_knee = 200;\n\t\tbreak;\n\tcase SENSOR_TAS5110C:\n\tcase SENSOR_TAS5110D:\n\t\tgspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_EXPOSURE, 2, 15, 1, 2);\n\t\tbreak;\n\t}\n\n\tif (gspca_dev->exposure) {\n\t\tgspca_dev->autogain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\t\tV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\t}\n\n\tif (sd->sensor == SENSOR_OV6650 || sd->sensor == SENSOR_OV7630)\n\t\tsd->plfreq = v4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_POWER_LINE_FREQUENCY,\n\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_60HZ, 0,\n\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_DISABLED);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\n\tif (gspca_dev->autogain)\n\t\tv4l2_ctrl_auto_cluster(3, &gspca_dev->autogain, 0, false);\n\n\treturn 0;\n}\n\n \nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam = &gspca_dev->cam;\n\tint i, mode;\n\t__u8 regs[0x31];\n\n\tmode = cam->cam_mode[gspca_dev->curr_mode].priv & 0x07;\n\t \n\tmemcpy(&regs[0x01], sensor_data[sd->sensor].bridge_init, 0x19);\n\t \n\tregs[0x18] |= mode << 4;\n\n\t \n\tif (sd->bridge == BRIDGE_103) {\n\t\tregs[0x05] = 0x20;  \n\t\tregs[0x06] = 0x20;  \n\t\tregs[0x07] = 0x20;  \n\t} else {\n\t\tregs[0x10] = 0x00;  \n\t\tregs[0x11] = 0x00;  \n\t}\n\n\t \n\tif (sensor_data[sd->sensor].flags & F_SIF) {\n\t\tregs[0x1a] = 0x14;  \n\t\tregs[0x1b] = 0x0a;  \n\t\tregs[0x1c] = 0x02;  \n\t\tregs[0x1d] = 0x02;  \n\t\tregs[0x1e] = 0x09;  \n\t\tregs[0x1f] = 0x07;  \n\t} else {\n\t\tregs[0x1a] = 0x1d;  \n\t\tregs[0x1b] = 0x10;  \n\t\tregs[0x1c] = 0x05;  \n\t\tregs[0x1d] = 0x03;  \n\t\tregs[0x1e] = 0x0f;  \n\t\tregs[0x1f] = 0x0c;  \n\t}\n\n\t \n\tfor (i = 0; i < 16; i++)\n\t\tregs[0x20 + i] = i * 16;\n\tregs[0x20 + i] = 255;\n\n\t \n\tswitch (sd->sensor) {\n\tcase SENSOR_TAS5130CXX:\n\t\t \n\t\tregs[0x19] = mode ? 0x23 : 0x43;\n\t\tbreak;\n\tcase SENSOR_OV7630:\n\t\t \n\t\tif (sd->bridge == BRIDGE_103) {\n\t\t\tregs[0x01] = 0x44;  \n\t\t\tregs[0x12] = 0x02;  \n\t\t}\n\t\tbreak;\n\tcase SENSOR_PAS202:\n\t\t \n\t\tif (sd->bridge == BRIDGE_103)\n\t\t\tregs[0x12] += 1;\n\t\tbreak;\n\t}\n\t \n\tif (cam->cam_mode[gspca_dev->curr_mode].priv & MODE_RAW)\n\t\tregs[0x18] &= ~0x80;\n\n\t \n\tif (cam->cam_mode[gspca_dev->curr_mode].priv & MODE_REDUCED_SIF) {\n\t\tregs[0x12] += 16;\t \n\t\tregs[0x13] += 24;\t \n\t\tregs[0x15]  = 320 / 16;  \n\t\tregs[0x16]  = 240 / 16;  \n\t}\n\n\t \n\treg_w(gspca_dev, 0x01, &regs[0x01], 1);\n\t \n\treg_w(gspca_dev, 0x17, &regs[0x17], 1);\n\t \n\treg_w(gspca_dev, 0x01, &regs[0x01],\n\t      (sd->bridge == BRIDGE_103) ? 0x30 : 0x1f);\n\n\t \n\ti2c_w_vector(gspca_dev, sensor_data[sd->sensor].sensor_init,\n\t\t\tsensor_data[sd->sensor].sensor_init_size);\n\n\t \n\tswitch (sd->sensor) {\n\tcase SENSOR_PAS202: {\n\t\tconst __u8 i2cpclockdiv[] =\n\t\t\t{0xa0, 0x40, 0x02, 0x03, 0x00, 0x00, 0x00, 0x10};\n\t\t \n\t\tif (mode)\n\t\t\ti2c_w(gspca_dev, i2cpclockdiv);\n\t\tbreak;\n\t    }\n\tcase SENSOR_OV7630:\n\t\t \n\t\tif (sd->bridge == BRIDGE_103) {\n\t\t\tconst __u8 i2c[] = { 0xa0, 0x21, 0x13,\n\t\t\t\t\t     0x80, 0x00, 0x00, 0x00, 0x10 };\n\t\t\ti2c_w(gspca_dev, i2c);\n\t\t}\n\t\tbreak;\n\t}\n\t \n\treg_w(gspca_dev, 0x15, &regs[0x15], 2);\n\t \n\treg_w(gspca_dev, 0x18, &regs[0x18], 1);\n\t \n\treg_w(gspca_dev, 0x12, &regs[0x12], 1);\n\t \n\treg_w(gspca_dev, 0x13, &regs[0x13], 1);\n\t \n\t\t\t\t \n\treg_w(gspca_dev, 0x17, &regs[0x17], 1);\n\t \t \n\treg_w(gspca_dev, 0x19, &regs[0x19], 1);\n\t \n\treg_w(gspca_dev, 0x1c, &regs[0x1c], 4);\n\t \n\treg_w(gspca_dev, 0x01, &regs[0x01], 1);\n\t \n\treg_w(gspca_dev, 0x18, &regs[0x18], 2);\n\tmsleep(20);\n\n\tsd->reg11 = -1;\n\n\tsetgain(gspca_dev);\n\tsetbrightness(gspca_dev);\n\tsetexposure(gspca_dev);\n\tsetfreq(gspca_dev);\n\n\tsd->frames_to_drop = 0;\n\tsd->autogain_ignore_frames = 0;\n\tgspca_dev->exp_too_high_cnt = 0;\n\tgspca_dev->exp_too_low_cnt = 0;\n\tatomic_set(&sd->avg_lum, -1);\n\treturn gspca_dev->usb_err;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\tsd_init(gspca_dev);\n}\n\nstatic u8* find_sof(struct gspca_dev *gspca_dev, u8 *data, int len)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint i, header_size = (sd->bridge == BRIDGE_103) ? 18 : 12;\n\n\t \n\tfor (i = 0; i < len; i++) {\n\t\tswitch (sd->header_read) {\n\t\tcase 0:\n\t\t\tif (data[i] == 0xff)\n\t\t\t\tsd->header_read++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (data[i] == 0xff)\n\t\t\t\tsd->header_read++;\n\t\t\telse\n\t\t\t\tsd->header_read = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (data[i] == 0x00)\n\t\t\t\tsd->header_read++;\n\t\t\telse if (data[i] != 0xff)\n\t\t\t\tsd->header_read = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (data[i] == 0xc4)\n\t\t\t\tsd->header_read++;\n\t\t\telse if (data[i] == 0xff)\n\t\t\t\tsd->header_read = 1;\n\t\t\telse\n\t\t\t\tsd->header_read = 0;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (data[i] == 0xc4)\n\t\t\t\tsd->header_read++;\n\t\t\telse if (data[i] == 0xff)\n\t\t\t\tsd->header_read = 1;\n\t\t\telse\n\t\t\t\tsd->header_read = 0;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tif (data[i] == 0x96)\n\t\t\t\tsd->header_read++;\n\t\t\telse if (data[i] == 0xff)\n\t\t\t\tsd->header_read = 1;\n\t\t\telse\n\t\t\t\tsd->header_read = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsd->header[sd->header_read - 6] = data[i];\n\t\t\tsd->header_read++;\n\t\t\tif (sd->header_read == header_size) {\n\t\t\t\tsd->header_read = 0;\n\t\t\t\treturn data + i + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t \n\t\t\tint len)\t\t\t \n{\n\tint fr_h_sz = 0, lum_offset = 0, len_after_sof = 0;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam = &gspca_dev->cam;\n\tu8 *sof;\n\n\tsof = find_sof(gspca_dev, data, len);\n\tif (sof) {\n\t\tif (sd->bridge == BRIDGE_103) {\n\t\t\tfr_h_sz = 18;\n\t\t\tlum_offset = 3;\n\t\t} else {\n\t\t\tfr_h_sz = 12;\n\t\t\tlum_offset = 2;\n\t\t}\n\n\t\tlen_after_sof = len - (sof - data);\n\t\tlen = (sof - data) - fr_h_sz;\n\t\tif (len < 0)\n\t\t\tlen = 0;\n\t}\n\n\tif (cam->cam_mode[gspca_dev->curr_mode].priv & MODE_RAW) {\n\t\t \n\t\tint used;\n\t\tint size = cam->cam_mode[gspca_dev->curr_mode].sizeimage;\n\n\t\tused = gspca_dev->image_len;\n\t\tif (used + len > size)\n\t\t\tlen = size - used;\n\t}\n\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n\n\tif (sof) {\n\t\tint  lum = sd->header[lum_offset] +\n\t\t\t  (sd->header[lum_offset + 1] << 8);\n\n\t\t \n\t\tif (lum == 0 && sd->prev_avg_lum != 0) {\n\t\t\tlum = -1;\n\t\t\tsd->frames_to_drop = 2;\n\t\t\tsd->prev_avg_lum = 0;\n\t\t} else\n\t\t\tsd->prev_avg_lum = lum;\n\t\tatomic_set(&sd->avg_lum, lum);\n\n\t\tif (sd->frames_to_drop)\n\t\t\tsd->frames_to_drop--;\n\t\telse\n\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\n\n\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, sof, len_after_sof);\n\t}\n}\n\n#if IS_ENABLED(CONFIG_INPUT)\nstatic int sd_int_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t \n\t\t\tint len)\t\t \n{\n\tint ret = -EINVAL;\n\n\tif (len == 1 && data[0] == 1) {\n\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);\n\t\tinput_sync(gspca_dev->input_dev);\n\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\n\t\tinput_sync(gspca_dev->input_dev);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n#endif\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.pkt_scan = sd_pkt_scan,\n\t.dq_callback = do_autogain,\n#if IS_ENABLED(CONFIG_INPUT)\n\t.int_pkt_scan = sd_int_pkt_scan,\n#endif\n};\n\n \n#define SB(sensor, bridge) \\\n\t.driver_info = (SENSOR_ ## sensor << 8) | BRIDGE_ ## bridge\n\n\nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x0c45, 0x6001), SB(TAS5110C, 102)},  \n\t{USB_DEVICE(0x0c45, 0x6005), SB(TAS5110C, 101)},  \n\t{USB_DEVICE(0x0c45, 0x6007), SB(TAS5110D, 101)},  \n\t{USB_DEVICE(0x0c45, 0x6009), SB(PAS106, 101)},\n\t{USB_DEVICE(0x0c45, 0x600d), SB(PAS106, 101)},\n\t{USB_DEVICE(0x0c45, 0x6011), SB(OV6650, 101)},\n\t{USB_DEVICE(0x0c45, 0x6019), SB(OV7630, 101)},\n\t{USB_DEVICE(0x0c45, 0x6024), SB(TAS5130CXX, 102)},\n\t{USB_DEVICE(0x0c45, 0x6025), SB(TAS5130CXX, 102)},\n\t{USB_DEVICE(0x0c45, 0x6027), SB(OV7630, 101)},  \n\t{USB_DEVICE(0x0c45, 0x6028), SB(PAS202, 102)},\n\t{USB_DEVICE(0x0c45, 0x6029), SB(PAS106, 102)},\n\t{USB_DEVICE(0x0c45, 0x602a), SB(HV7131D, 102)},\n\t \n\t{USB_DEVICE(0x0c45, 0x602c), SB(OV7630, 102)},\n\t{USB_DEVICE(0x0c45, 0x602d), SB(HV7131R, 102)},\n\t{USB_DEVICE(0x0c45, 0x602e), SB(OV7630, 102)},\n\t   \n\t   \n\t{USB_DEVICE(0x0c45, 0x6083), SB(HV7131D, 103)},\n\t{USB_DEVICE(0x0c45, 0x608c), SB(HV7131R, 103)},\n\t \n\t{USB_DEVICE(0x0c45, 0x608f), SB(OV7630, 103)},\n\t{USB_DEVICE(0x0c45, 0x60a8), SB(PAS106, 103)},\n\t{USB_DEVICE(0x0c45, 0x60aa), SB(TAS5130CXX, 103)},\n\t{USB_DEVICE(0x0c45, 0x60af), SB(PAS202, 103)},\n\t{USB_DEVICE(0x0c45, 0x60b0), SB(OV7630, 103)},\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}