{
  "module_name": "dtcs033.c",
  "hash_id": "0e74168211bb6a4f0ea30ef82abd306b2c8c96c8b52b98a6bb975bb6e6258a09",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/dtcs033.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#define MODULE_NAME \"dtcs033\"\n#include \"gspca.h\"\n\nMODULE_AUTHOR(\"Robert Butora <robert.butora.fi@gmail.com>\");\nMODULE_DESCRIPTION(\"Scopium DTCS033 astro-cam USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstruct dtcs033_usb_requests {\n\tu8 bRequestType;\n\tu8 bRequest;\n\tu16 wValue;\n\tu16 wIndex;\n\tu16 wLength;\n};\n\n \nstatic void reg_rw(struct gspca_dev *gspca_dev,\n\t\tu8 bRequestType, u8 bRequest,\n\t\tu16 wValue, u16 wIndex, u16 wLength)\n{\n\tstruct usb_device *udev = gspca_dev->dev;\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\n\tret = usb_control_msg(udev,\n\t\tusb_rcvctrlpipe(udev, 0),\n\t\tbRequest,\n\t\tbRequestType,\n\t\twValue, wIndex,\n\t\tgspca_dev->usb_buf, wLength, 500);\n\n\tif (ret < 0) {\n\t\tgspca_dev->usb_err = ret;\n\t\tpr_err(\"usb_control_msg error %d\\n\", ret);\n\t}\n\n\treturn;\n}\n \nstatic int reg_reqs(struct gspca_dev *gspca_dev,\n\t\t    const struct dtcs033_usb_requests *preqs, int n_reqs)\n{\n\tint i = 0;\n\tconst struct dtcs033_usb_requests *preq;\n\n\twhile ((i < n_reqs) && (gspca_dev->usb_err >= 0)) {\n\n\t\tpreq = &preqs[i];\n\n\t\treg_rw(gspca_dev, preq->bRequestType, preq->bRequest,\n\t\t\tpreq->wValue, preq->wIndex, preq->wLength);\n\n\t\tif (gspca_dev->usb_err < 0) {\n\n\t\t\tgspca_err(gspca_dev, \"usb error request no: %d / %d\\n\",\n\t\t\t\t  i, n_reqs);\n\t\t} else if (preq->bRequestType & USB_DIR_IN) {\n\n\t\t\tgspca_dbg(gspca_dev, D_STREAM,\n\t\t\t\t  \"USB IN (%d) returned[%d] %3ph %s\",\n\t\t\t\t  i,\n\t\t\t\t  preq->wLength,\n\t\t\t\t  gspca_dev->usb_buf,\n\t\t\t\t  preq->wLength > 3 ? \"...\\n\" : \"\\n\");\n\t\t}\n\n\t\ti++;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\n \n\n#define DT_COLS (640)\nstatic const struct v4l2_pix_format dtcs033_mode[] = {\n\t \n\t{DT_COLS, 480, V4L2_PIX_FMT_GREY, V4L2_FIELD_NONE,\n\t\t.bytesperline = DT_COLS,\n\t\t.sizeimage = DT_COLS*480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t},\n\t \n\t{DT_COLS, 480, V4L2_PIX_FMT_SRGGB8, V4L2_FIELD_NONE,\n\t\t.bytesperline = DT_COLS,\n\t\t.sizeimage = DT_COLS*480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t}\n};\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\tconst struct usb_device_id *id)\n{\n\tgspca_dev->cam.cam_mode = dtcs033_mode;\n\tgspca_dev->cam.nmodes = ARRAY_SIZE(dtcs033_mode);\n\n\tgspca_dev->cam.bulk = 1;\n\tgspca_dev->cam.bulk_nurbs = 1;\n\tgspca_dev->cam.bulk_size = DT_COLS*512;\n\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\treturn 0;\n}\n\n \nstatic int  dtcs033_start(struct gspca_dev *gspca_dev);\nstatic void dtcs033_stopN(struct gspca_dev *gspca_dev);\n\n \nstatic void dtcs033_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,   \n\t\t\tint len)    \n{\n\t \n\tif (len != DT_COLS*512) {\n\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tgspca_frame_add(gspca_dev, FIRST_PACKET, NULL, 0);\n\tgspca_frame_add(gspca_dev, INTER_PACKET,\n\t\tdata + 16*DT_COLS,\n\t\tlen  - 32*DT_COLS);  \n\tgspca_frame_add(gspca_dev, LAST_PACKET,  NULL, 0);\n\n\treturn;\n}\n\n \n\nstatic void dtcs033_setexposure(struct gspca_dev *gspca_dev,\n\t\t\ts32 expo, s32 gain)\n{\n\t \n\tu16 sGain   = (u16)gain;\n\tu16 gainVal = 224+(sGain-14)*(768-224)/(33-14);\n\tu16 wIndex =  0x0100|(0x00FF&gainVal);\n\tu16 wValue = (0xFF00&gainVal)>>8;\n\n\t \n\tu16 sXTime   = (u16)expo;\n\tu16 xtimeVal = (524*(150-(sXTime-1)))/150;\n\n\tconst u8 bRequestType =\n\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE;\n\tconst u8 bRequest = 0x18;\n\n\treg_rw(gspca_dev,\n\t\tbRequestType, bRequest, wValue, wIndex, 0);\n\tif (gspca_dev->usb_err < 0)\n\t\tgspca_err(gspca_dev, \"usb error in setexposure(gain) sequence\\n\");\n\n\treg_rw(gspca_dev,\n\t\tbRequestType, bRequest, (xtimeVal<<4), 0x6300, 0);\n\tif (gspca_dev->usb_err < 0)\n\t\tgspca_err(gspca_dev, \"usb error in setexposure(time) sequence\\n\");\n}\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev; \n\n\t \n\tstruct {\n\t\tstruct v4l2_ctrl *exposure;\n\t\tstruct v4l2_ctrl *gain;\n\t};\n};\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\tcontainer_of(ctrl->handler,\n\t\tstruct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE:\n\t\tdtcs033_setexposure(gspca_dev,\n\t\t\t\tctrl->val, sd->gain->val);\n\t\tbreak;\n\tcase V4L2_CID_GAIN:\n\t\tdtcs033_setexposure(gspca_dev,\n\t\t\t\tsd->exposure->val, ctrl->val);\n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int dtcs033_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 2);\n\t \n\tsd->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\tV4L2_CID_EXPOSURE,\n\t\t\t\t1,  150,  1,  75); \n\tsd->gain     = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\tV4L2_CID_GAIN,\n\t\t\t\t14,  33,  1,  24); \n\tif (hdl->error) {\n\t\tgspca_err(gspca_dev, \"Could not initialize controls: %d\\n\",\n\t\t\t  hdl->error);\n\t\treturn hdl->error;\n\t}\n\n\tv4l2_ctrl_cluster(2, &sd->exposure);\n\treturn 0;\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name     = MODULE_NAME,\n\t.config   = sd_config,\n\t.init     = sd_init,\n\t.start    = dtcs033_start,\n\t.stopN    = dtcs033_stopN,\n\t.pkt_scan = dtcs033_pkt_scan,\n\t.init_controls = dtcs033_init_controls,\n};\n\n \n\nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x0547, 0x7303)},\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id,\n\t\t\t&sd_desc, sizeof(struct sd),\n\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name       = MODULE_NAME,\n\t.id_table   = device_table,\n\t.probe      = sd_probe,\n\t.disconnect   = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend      = gspca_suspend,\n\t.resume       = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\nmodule_usb_driver(sd_driver);\n\n\n \nstatic const struct dtcs033_usb_requests dtcs033_start_reqs[] = {\n \n{ 0x40, 0x01, 0x0001, 0x000F, 0x0000 },\n{ 0x40, 0x01, 0x0000, 0x000F, 0x0000 },\n{ 0x40, 0x01, 0x0001, 0x000F, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x7F00, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x1001, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x0004, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x7F01, 0x0000 },\n{ 0x40, 0x18, 0x30E0, 0x0009, 0x0000 },\n{ 0x40, 0x18, 0x0500, 0x012C, 0x0000 },\n{ 0x40, 0x18, 0x0380, 0x0200, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x035C, 0x0000 },\n{ 0x40, 0x18, 0x05C0, 0x0438, 0x0000 },\n{ 0x40, 0x18, 0x0440, 0x0500, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x0668, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x0700, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x0800, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x0900, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x0A00, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x0B00, 0x0000 },\n{ 0x40, 0x18, 0x30E0, 0x6009, 0x0000 },\n{ 0x40, 0x18, 0x0500, 0x612C, 0x0000 },\n{ 0x40, 0x18, 0x2090, 0x6274, 0x0000 },\n{ 0x40, 0x18, 0x05C0, 0x6338, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x6400, 0x0000 },\n{ 0x40, 0x18, 0x05C0, 0x6538, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x6600, 0x0000 },\n{ 0x40, 0x18, 0x0680, 0x6744, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x6800, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x6900, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x6A00, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x6B00, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x6C00, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x6D00, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x6E00, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x808C, 0x0000 },\n{ 0x40, 0x18, 0x0010, 0x8101, 0x0000 },\n{ 0x40, 0x18, 0x30E0, 0x8200, 0x0000 },\n{ 0x40, 0x18, 0x0810, 0x832C, 0x0000 },\n{ 0x40, 0x18, 0x0680, 0x842B, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x8500, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x8600, 0x0000 },\n{ 0x40, 0x18, 0x0280, 0x8715, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x880C, 0x0000 },\n{ 0x40, 0x18, 0x0010, 0x8901, 0x0000 },\n{ 0x40, 0x18, 0x30E0, 0x8A00, 0x0000 },\n{ 0x40, 0x18, 0x0810, 0x8B2C, 0x0000 },\n{ 0x40, 0x18, 0x0680, 0x8C2B, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x8D00, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x8E00, 0x0000 },\n{ 0x40, 0x18, 0x0280, 0x8F15, 0x0000 },\n{ 0x40, 0x18, 0x0010, 0xD040, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0xD100, 0x0000 },\n{ 0x40, 0x18, 0x00B0, 0xD20A, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0xD300, 0x0000 },\n{ 0x40, 0x18, 0x30E2, 0xD40D, 0x0000 },\n{ 0x40, 0x18, 0x0001, 0xD5C0, 0x0000 },\n{ 0x40, 0x18, 0x00A0, 0xD60A, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0xD700, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x7F00, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x1501, 0x0000 },\n{ 0x40, 0x18, 0x0001, 0x01FF, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x0200, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x0304, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x1101, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x1201, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x1300, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x1400, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x1601, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x1800, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x1900, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x1A00, 0x0000 },\n{ 0x40, 0x18, 0x2000, 0x1B00, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x1C00, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x2100, 0x0000 },\n{ 0x40, 0x18, 0x00C0, 0x228E, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x3001, 0x0000 },\n{ 0x40, 0x18, 0x0010, 0x3101, 0x0000 },\n{ 0x40, 0x18, 0x0008, 0x3301, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x3400, 0x0000 },\n{ 0x40, 0x18, 0x0012, 0x3549, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x3620, 0x0000 },\n{ 0x40, 0x18, 0x0001, 0x3700, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x4000, 0x0000 },\n{ 0x40, 0x18, 0xFFFF, 0x41FF, 0x0000 },\n{ 0x40, 0x18, 0xFFFF, 0x42FF, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x500F, 0x0000 },\n{ 0x40, 0x18, 0x2272, 0x5108, 0x0000 },\n{ 0x40, 0x18, 0x2272, 0x5208, 0x0000 },\n{ 0x40, 0x18, 0xFFFF, 0x53FF, 0x0000 },\n{ 0x40, 0x18, 0xFFFF, 0x54FF, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x6000, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x6102, 0x0000 },\n{ 0x40, 0x18, 0x0010, 0x6214, 0x0000 },\n{ 0x40, 0x18, 0x0C80, 0x6300, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x6401, 0x0000 },\n{ 0x40, 0x18, 0x0680, 0x6551, 0x0000 },\n{ 0x40, 0x18, 0xFFFF, 0x66FF, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x6702, 0x0000 },\n{ 0x40, 0x18, 0x0010, 0x6800, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x6900, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x6A00, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x6B00, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x6C00, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x6D01, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x6E00, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x6F00, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x7000, 0x0000 },\n{ 0x40, 0x18, 0x0001, 0x7118, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x2001, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x1101, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x1301, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x1300, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x1501, 0x0000 },\n{ 0xC0, 0x11, 0x0000, 0x24C0, 0x0003 },\n{ 0x40, 0x18, 0x0000, 0x3000, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x3620, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x1501, 0x0000 },\n{ 0x40, 0x18, 0x0010, 0x6300, 0x0000 },\n{ 0x40, 0x18, 0x0002, 0x01F0, 0x0000 },\n{ 0x40, 0x01, 0x0003, 0x000F, 0x0000 }\n};\n\nstatic const struct dtcs033_usb_requests dtcs033_stop_reqs[] = {\n \n{ 0x40, 0x01, 0x0001, 0x000F, 0x0000 },\n{ 0x40, 0x01, 0x0000, 0x000F, 0x0000 },\n{ 0x40, 0x18, 0x0000, 0x0003, 0x0000 }\n};\nstatic int dtcs033_start(struct gspca_dev *gspca_dev)\n{\n\treturn reg_reqs(gspca_dev, dtcs033_start_reqs,\n\t\tARRAY_SIZE(dtcs033_start_reqs));\n}\n\nstatic void dtcs033_stopN(struct gspca_dev *gspca_dev)\n{\n\treg_reqs(gspca_dev, dtcs033_stop_reqs,\n\t\tARRAY_SIZE(dtcs033_stop_reqs));\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}