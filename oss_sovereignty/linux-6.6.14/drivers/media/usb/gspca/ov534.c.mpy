{
  "module_name": "ov534.c",
  "hash_id": "6ff55b3995a2c7c5d7cee49011bebe5b42957221cf9333705a3fc9120a97378d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/ov534.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"ov534\"\n\n#include \"gspca.h\"\n\n#include <linux/fixp-arith.h>\n#include <media/v4l2-ctrls.h>\n\n#define OV534_REG_ADDRESS\t0xf1\t \n#define OV534_REG_SUBADDR\t0xf2\n#define OV534_REG_WRITE\t\t0xf3\n#define OV534_REG_READ\t\t0xf4\n#define OV534_REG_OPERATION\t0xf5\n#define OV534_REG_STATUS\t0xf6\n\n#define OV534_OP_WRITE_3\t0x37\n#define OV534_OP_WRITE_2\t0x33\n#define OV534_OP_READ_2\t\t0xf9\n\n#define CTRL_TIMEOUT 500\n#define DEFAULT_FRAME_RATE 30\n\nMODULE_AUTHOR(\"Antonio Ospite <ospite@studenti.unina.it>\");\nMODULE_DESCRIPTION(\"GSPCA/OV534 USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t \n\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tstruct v4l2_ctrl *hue;\n\tstruct v4l2_ctrl *saturation;\n\tstruct v4l2_ctrl *brightness;\n\tstruct v4l2_ctrl *contrast;\n\tstruct {  \n\t\tstruct v4l2_ctrl *autogain;\n\t\tstruct v4l2_ctrl *gain;\n\t};\n\tstruct v4l2_ctrl *autowhitebalance;\n\tstruct {  \n\t\tstruct v4l2_ctrl *autoexposure;\n\t\tstruct v4l2_ctrl *exposure;\n\t};\n\tstruct v4l2_ctrl *sharpness;\n\tstruct v4l2_ctrl *hflip;\n\tstruct v4l2_ctrl *vflip;\n\tstruct v4l2_ctrl *plfreq;\n\n\t__u32 last_pts;\n\tu16 last_fid;\n\tu8 frame_rate;\n\n\tu8 sensor;\n};\nenum sensors {\n\tSENSOR_OV767x,\n\tSENSOR_OV772x,\n\tNSENSORS\n};\n\nstatic int sd_start(struct gspca_dev *gspca_dev);\nstatic void sd_stopN(struct gspca_dev *gspca_dev);\n\n\nstatic const struct v4l2_pix_format ov772x_mode[] = {\n\t{320, 240, V4L2_PIX_FMT_YUYV, V4L2_FIELD_NONE,\n\t .bytesperline = 320 * 2,\n\t .sizeimage = 320 * 240 * 2,\n\t .colorspace = V4L2_COLORSPACE_SRGB,\n\t .priv = 1},\n\t{640, 480, V4L2_PIX_FMT_YUYV, V4L2_FIELD_NONE,\n\t .bytesperline = 640 * 2,\n\t .sizeimage = 640 * 480 * 2,\n\t .colorspace = V4L2_COLORSPACE_SRGB,\n\t .priv = 0},\n\t{320, 240, V4L2_PIX_FMT_SGRBG8, V4L2_FIELD_NONE,\n\t .bytesperline = 320,\n\t .sizeimage = 320 * 240,\n\t .colorspace = V4L2_COLORSPACE_SRGB,\n\t .priv = 1},\n\t{640, 480, V4L2_PIX_FMT_SGRBG8, V4L2_FIELD_NONE,\n\t .bytesperline = 640,\n\t .sizeimage = 640 * 480,\n\t .colorspace = V4L2_COLORSPACE_SRGB,\n\t .priv = 0},\n};\nstatic const struct v4l2_pix_format ov767x_mode[] = {\n\t{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG},\n\t{640, 480, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG},\n};\n\nstatic const u8 qvga_rates[] = {187, 150, 137, 125, 100, 75, 60, 50, 37, 30};\nstatic const u8 vga_rates[] = {60, 50, 40, 30, 15};\n\nstatic const struct framerates ov772x_framerates[] = {\n\t{  \n\t\t.rates = qvga_rates,\n\t\t.nrates = ARRAY_SIZE(qvga_rates),\n\t},\n\t{  \n\t\t.rates = vga_rates,\n\t\t.nrates = ARRAY_SIZE(vga_rates),\n\t},\n\t{  \n\t\t.rates = qvga_rates,\n\t\t.nrates = ARRAY_SIZE(qvga_rates),\n\t},\n\t{  \n\t\t.rates = vga_rates,\n\t\t.nrates = ARRAY_SIZE(vga_rates),\n\t},\n};\n\nstruct reg_array {\n\tconst u8 (*val)[2];\n\tint len;\n};\n\nstatic const u8 bridge_init_767x[][2] = {\n \n \n\t{0xf1, 0x42},\n\t{0x88, 0xf8},\n\t{0x89, 0xff},\n\t{0x76, 0x03},\n\t{0x92, 0x03},\n\t{0x95, 0x10},\n\t{0xe2, 0x00},\n\t{0xe7, 0x3e},\n\t{0x8d, 0x1c},\n\t{0x8e, 0x00},\n\t{0x8f, 0x00},\n\t{0x1f, 0x00},\n\t{0xc3, 0xf9},\n\t{0x89, 0xff},\n\t{0x88, 0xf8},\n\t{0x76, 0x03},\n\t{0x92, 0x01},\n\t{0x93, 0x18},\n\t{0x1c, 0x00},\n\t{0x1d, 0x48},\n\t{0x1d, 0x00},\n\t{0x1d, 0xff},\n\t{0x1d, 0x02},\n\t{0x1d, 0x58},\n\t{0x1d, 0x00},\n\t{0x1c, 0x0a},\n\t{0x1d, 0x0a},\n\t{0x1d, 0x0e},\n\t{0xc0, 0x50},\t \n\t{0xc1, 0x3c},\t \n\t{0x34, 0x05},\t \n\t{0xc2, 0x0c},\t \n\t{0xc3, 0xf9},\t \n\t{0x34, 0x05},\t \n\t{0xe7, 0x2e},\t \n\t{0x31, 0xf9},\t \n\t{0x35, 0x02},\t \n\t{0xd9, 0x10},\n\t{0x25, 0x42},\t \n\t{0x94, 0x11},\t \n};\nstatic const u8 sensor_init_767x[][2] = {\n\t{0x12, 0x80},\n\t{0x11, 0x03},\n\t{0x3a, 0x04},\n\t{0x12, 0x00},\n\t{0x17, 0x13},\n\t{0x18, 0x01},\n\t{0x32, 0xb6},\n\t{0x19, 0x02},\n\t{0x1a, 0x7a},\n\t{0x03, 0x0a},\n\t{0x0c, 0x00},\n\t{0x3e, 0x00},\n\t{0x70, 0x3a},\n\t{0x71, 0x35},\n\t{0x72, 0x11},\n\t{0x73, 0xf0},\n\t{0xa2, 0x02},\n\t{0x7a, 0x2a},\t \n\t{0x7b, 0x12},\n\t{0x7c, 0x1d},\n\t{0x7d, 0x2d},\n\t{0x7e, 0x45},\n\t{0x7f, 0x50},\n\t{0x80, 0x59},\n\t{0x81, 0x62},\n\t{0x82, 0x6b},\n\t{0x83, 0x73},\n\t{0x84, 0x7b},\n\t{0x85, 0x8a},\n\t{0x86, 0x98},\n\t{0x87, 0xb2},\n\t{0x88, 0xca},\n\t{0x89, 0xe0},\n\t{0x13, 0xe0},\n\t{0x00, 0x00},\n\t{0x10, 0x00},\n\t{0x0d, 0x40},\n\t{0x14, 0x38},\t \n\t{0xa5, 0x05},\n\t{0xab, 0x07},\n\t{0x24, 0x95},\n\t{0x25, 0x33},\n\t{0x26, 0xe3},\n\t{0x9f, 0x78},\n\t{0xa0, 0x68},\n\t{0xa1, 0x03},\n\t{0xa6, 0xd8},\n\t{0xa7, 0xd8},\n\t{0xa8, 0xf0},\n\t{0xa9, 0x90},\n\t{0xaa, 0x94},\n\t{0x13, 0xe5},\n\t{0x0e, 0x61},\n\t{0x0f, 0x4b},\n\t{0x16, 0x02},\n\t{0x21, 0x02},\n\t{0x22, 0x91},\n\t{0x29, 0x07},\n\t{0x33, 0x0b},\n\t{0x35, 0x0b},\n\t{0x37, 0x1d},\n\t{0x38, 0x71},\n\t{0x39, 0x2a},\n\t{0x3c, 0x78},\n\t{0x4d, 0x40},\n\t{0x4e, 0x20},\n\t{0x69, 0x00},\n\t{0x6b, 0x4a},\n\t{0x74, 0x10},\n\t{0x8d, 0x4f},\n\t{0x8e, 0x00},\n\t{0x8f, 0x00},\n\t{0x90, 0x00},\n\t{0x91, 0x00},\n\t{0x96, 0x00},\n\t{0x9a, 0x80},\n\t{0xb0, 0x84},\n\t{0xb1, 0x0c},\n\t{0xb2, 0x0e},\n\t{0xb3, 0x82},\n\t{0xb8, 0x0a},\n\t{0x43, 0x0a},\n\t{0x44, 0xf0},\n\t{0x45, 0x34},\n\t{0x46, 0x58},\n\t{0x47, 0x28},\n\t{0x48, 0x3a},\n\t{0x59, 0x88},\n\t{0x5a, 0x88},\n\t{0x5b, 0x44},\n\t{0x5c, 0x67},\n\t{0x5d, 0x49},\n\t{0x5e, 0x0e},\n\t{0x6c, 0x0a},\n\t{0x6d, 0x55},\n\t{0x6e, 0x11},\n\t{0x6f, 0x9f},\n\t{0x6a, 0x40},\n\t{0x01, 0x40},\n\t{0x02, 0x40},\n\t{0x13, 0xe7},\n\t{0x4f, 0x80},\n\t{0x50, 0x80},\n\t{0x51, 0x00},\n\t{0x52, 0x22},\n\t{0x53, 0x5e},\n\t{0x54, 0x80},\n\t{0x58, 0x9e},\n\t{0x41, 0x08},\n\t{0x3f, 0x00},\n\t{0x75, 0x04},\n\t{0x76, 0xe1},\n\t{0x4c, 0x00},\n\t{0x77, 0x01},\n\t{0x3d, 0xc2},\n\t{0x4b, 0x09},\n\t{0xc9, 0x60},\n\t{0x41, 0x38},\t \n\t{0x56, 0x40},\n\t{0x34, 0x11},\n\t{0x3b, 0xc2},\n\t{0xa4, 0x8a},\t \n\t{0x96, 0x00},\n\t{0x97, 0x30},\n\t{0x98, 0x20},\n\t{0x99, 0x20},\n\t{0x9a, 0x84},\n\t{0x9b, 0x29},\n\t{0x9c, 0x03},\n\t{0x9d, 0x4c},\n\t{0x9e, 0x3f},\n\t{0x78, 0x04},\n\t{0x79, 0x01},\n\t{0xc8, 0xf0},\n\t{0x79, 0x0f},\n\t{0xc8, 0x00},\n\t{0x79, 0x10},\n\t{0xc8, 0x7e},\n\t{0x79, 0x0a},\n\t{0xc8, 0x80},\n\t{0x79, 0x0b},\n\t{0xc8, 0x01},\n\t{0x79, 0x0c},\n\t{0xc8, 0x0f},\n\t{0x79, 0x0d},\n\t{0xc8, 0x20},\n\t{0x79, 0x09},\n\t{0xc8, 0x80},\n\t{0x79, 0x02},\n\t{0xc8, 0xc0},\n\t{0x79, 0x03},\n\t{0xc8, 0x20},\n\t{0x79, 0x26},\n};\nstatic const u8 bridge_start_vga_767x[][2] = {\n \n\t{0x94, 0xaa},\n\t{0xf1, 0x42},\n\t{0xe5, 0x04},\n\t{0xc0, 0x50},\n\t{0xc1, 0x3c},\n\t{0xc2, 0x0c},\n\t{0x35, 0x02},\t \n\t{0xd9, 0x10},\n\t{0xda, 0x00},\t \n\t{0x34, 0x05},\t \n\t{0xc3, 0xf9},\t \n\t{0x8c, 0x00},\t \n\t{0x8d, 0x1c},\t \n \n\t{0x50, 0x00},\t \n\t{0x51, 0xa0},\t \n\t{0x52, 0x3c},\t \n\t{0x53, 0x00},\t \n\t{0x54, 0x00},\t \n\t{0x55, 0x00},\t \n\t{0x57, 0x00},\t \n\t{0x5c, 0x00},\t \n\t{0x5a, 0xa0},\t \n\t{0x5b, 0x78},\t \n\t{0x1c, 0x0a},\n\t{0x1d, 0x0a},\n\t{0x94, 0x11},\n};\nstatic const u8 sensor_start_vga_767x[][2] = {\n\t{0x11, 0x01},\n\t{0x1e, 0x04},\n\t{0x19, 0x02},\n\t{0x1a, 0x7a},\n};\nstatic const u8 bridge_start_qvga_767x[][2] = {\n \n\t{0x94, 0xaa},\n\t{0xf1, 0x42},\n\t{0xe5, 0x04},\n\t{0xc0, 0x80},\n\t{0xc1, 0x60},\n\t{0xc2, 0x0c},\n\t{0x35, 0x02},\t \n\t{0xd9, 0x10},\n\t{0xc0, 0x50},\t \n\t{0xc1, 0x3c},\t \n\t{0x8c, 0x00},\t \n\t{0x8d, 0x1c},\t \n\t{0x34, 0x05},\t \n\t{0xc2, 0x4c},\t \n\t{0xc3, 0xf9},\t \n\t{0x1c, 0x00},\t \n\t{0x1d, 0x48},\t \n\t{0x50, 0x89},\t \n\t{0x51, 0xa0},\t \n\t{0x52, 0x78},\t \n\t{0x53, 0x00},\t \n\t{0x54, 0x00},\t \n\t{0x55, 0x00},\t \n\t{0x57, 0x00},\t \n\t{0x5c, 0x00},\t \n\t{0x5a, 0x50},\t \n\t{0x5b, 0x3c},\t \n\t{0x1c, 0x0a},\n\t{0x1d, 0x0a},\n\t{0x94, 0x11},\n};\nstatic const u8 sensor_start_qvga_767x[][2] = {\n\t{0x11, 0x01},\n\t{0x1e, 0x04},\n\t{0x19, 0x02},\n\t{0x1a, 0x7a},\n};\n\nstatic const u8 bridge_init_772x[][2] = {\n\t{ 0x88, 0xf8 },\n\t{ 0x89, 0xff },\n\t{ 0x76, 0x03 },\n\t{ 0x92, 0x01 },\n\t{ 0x93, 0x18 },\n\t{ 0x94, 0x10 },\n\t{ 0x95, 0x10 },\n\t{ 0xe2, 0x00 },\n\t{ 0xe7, 0x3e },\n\n\t{ 0x96, 0x00 },\n\n\t{ 0x97, 0x20 },\n\t{ 0x97, 0x20 },\n\t{ 0x97, 0x20 },\n\t{ 0x97, 0x0a },\n\t{ 0x97, 0x3f },\n\t{ 0x97, 0x4a },\n\t{ 0x97, 0x20 },\n\t{ 0x97, 0x15 },\n\t{ 0x97, 0x0b },\n\n\t{ 0x8e, 0x40 },\n\t{ 0x1f, 0x81 },\n\t{ 0x34, 0x05 },\n\t{ 0xe3, 0x04 },\n\t{ 0x89, 0x00 },\n\t{ 0x76, 0x00 },\n\t{ 0xe7, 0x2e },\n\t{ 0x31, 0xf9 },\n\t{ 0x25, 0x42 },\n\t{ 0x21, 0xf0 },\n\n\t{ 0x1c, 0x0a },\n\t{ 0x1d, 0x08 },  \n\t{ 0x1d, 0x0e },  \n};\nstatic const u8 sensor_init_772x[][2] = {\n\t{ 0x12, 0x80 },\n\t{ 0x11, 0x01 },\n \n\t{ 0x11, 0x01 },\n\t{ 0x11, 0x01 },\n\t{ 0x11, 0x01 },\n\t{ 0x11, 0x01 },\n\t{ 0x11, 0x01 },\n\t{ 0x11, 0x01 },\n\t{ 0x11, 0x01 },\n\t{ 0x11, 0x01 },\n\t{ 0x11, 0x01 },\n\t{ 0x11, 0x01 },\n\n\t{ 0x3d, 0x03 },\n\t{ 0x17, 0x26 },\n\t{ 0x18, 0xa0 },\n\t{ 0x19, 0x07 },\n\t{ 0x1a, 0xf0 },\n\t{ 0x32, 0x00 },\n\t{ 0x29, 0xa0 },\n\t{ 0x2c, 0xf0 },\n\t{ 0x65, 0x20 },\n\t{ 0x11, 0x01 },\n\t{ 0x42, 0x7f },\n\t{ 0x63, 0xaa },\t\t \n\t{ 0x64, 0xff },\n\t{ 0x66, 0x00 },\n\t{ 0x13, 0xf0 },\t\t \n\t{ 0x0d, 0x41 },\n\t{ 0x0f, 0xc5 },\n\t{ 0x14, 0x11 },\n\n\t{ 0x22, 0x7f },\n\t{ 0x23, 0x03 },\n\t{ 0x24, 0x40 },\n\t{ 0x25, 0x30 },\n\t{ 0x26, 0xa1 },\n\t{ 0x2a, 0x00 },\n\t{ 0x2b, 0x00 },\n\t{ 0x6b, 0xaa },\n\t{ 0x13, 0xff },\t\t \n\n\t{ 0x90, 0x05 },\n\t{ 0x91, 0x01 },\n\t{ 0x92, 0x03 },\n\t{ 0x93, 0x00 },\n\t{ 0x94, 0x60 },\n\t{ 0x95, 0x3c },\n\t{ 0x96, 0x24 },\n\t{ 0x97, 0x1e },\n\t{ 0x98, 0x62 },\n\t{ 0x99, 0x80 },\n\t{ 0x9a, 0x1e },\n\t{ 0x9b, 0x08 },\n\t{ 0x9c, 0x20 },\n\t{ 0x9e, 0x81 },\n\n\t{ 0xa6, 0x07 },\n\t{ 0x7e, 0x0c },\n\t{ 0x7f, 0x16 },\n\t{ 0x80, 0x2a },\n\t{ 0x81, 0x4e },\n\t{ 0x82, 0x61 },\n\t{ 0x83, 0x6f },\n\t{ 0x84, 0x7b },\n\t{ 0x85, 0x86 },\n\t{ 0x86, 0x8e },\n\t{ 0x87, 0x97 },\n\t{ 0x88, 0xa4 },\n\t{ 0x89, 0xaf },\n\t{ 0x8a, 0xc5 },\n\t{ 0x8b, 0xd7 },\n\t{ 0x8c, 0xe8 },\n\t{ 0x8d, 0x20 },\n\n\t{ 0x2b, 0x00 },\n\t{ 0x22, 0x7f },\n\t{ 0x23, 0x03 },\n\t{ 0x11, 0x01 },\n\t{ 0x64, 0xff },\n\t{ 0x0d, 0x41 },\n\n\t{ 0x14, 0x41 },\n\t{ 0x0e, 0xcd },\n\t{ 0xac, 0xbf },\n\t{ 0x8e, 0x00 },\t\t \n};\nstatic const u8 bridge_start_vga_yuyv_772x[][2] = {\n\t{0x88, 0x00},\n\t{0x1c, 0x00},\n\t{0x1d, 0x40},\n\t{0x1d, 0x02},\n\t{0x1d, 0x00},\n\t{0x1d, 0x02},\n\t{0x1d, 0x58},\n\t{0x1d, 0x00},\n\t{0x8d, 0x1c},\n\t{0x8e, 0x80},\n\t{0xc0, 0x50},\n\t{0xc1, 0x3c},\n\t{0xc2, 0x0c},\n\t{0xc3, 0x69},\n};\nstatic const u8 sensor_start_vga_yuyv_772x[][2] = {\n\t{0x12, 0x00},\n\t{0x17, 0x26},\n\t{0x18, 0xa0},\n\t{0x19, 0x07},\n\t{0x1a, 0xf0},\n\t{0x29, 0xa0},\n\t{0x2c, 0xf0},\n\t{0x65, 0x20},\n\t{0x67, 0x00},\n};\nstatic const u8 bridge_start_qvga_yuyv_772x[][2] = {\n\t{0x88, 0x00},\n\t{0x1c, 0x00},\n\t{0x1d, 0x40},\n\t{0x1d, 0x02},\n\t{0x1d, 0x00},\n\t{0x1d, 0x01},\n\t{0x1d, 0x4b},\n\t{0x1d, 0x00},\n\t{0x8d, 0x1c},\n\t{0x8e, 0x80},\n\t{0xc0, 0x28},\n\t{0xc1, 0x1e},\n\t{0xc2, 0x0c},\n\t{0xc3, 0x69},\n};\nstatic const u8 sensor_start_qvga_yuyv_772x[][2] = {\n\t{0x12, 0x40},\n\t{0x17, 0x3f},\n\t{0x18, 0x50},\n\t{0x19, 0x03},\n\t{0x1a, 0x78},\n\t{0x29, 0x50},\n\t{0x2c, 0x78},\n\t{0x65, 0x2f},\n\t{0x67, 0x00},\n};\nstatic const u8 bridge_start_vga_gbrg_772x[][2] = {\n\t{0x88, 0x08},\n\t{0x1c, 0x00},\n\t{0x1d, 0x00},\n\t{0x1d, 0x02},\n\t{0x1d, 0x00},\n\t{0x1d, 0x01},\n\t{0x1d, 0x2c},\n\t{0x1d, 0x00},\n\t{0x8d, 0x00},\n\t{0x8e, 0x00},\n\t{0xc0, 0x50},\n\t{0xc1, 0x3c},\n\t{0xc2, 0x01},\n\t{0xc3, 0x01},\n};\nstatic const u8 sensor_start_vga_gbrg_772x[][2] = {\n\t{0x12, 0x01},\n\t{0x17, 0x26},\n\t{0x18, 0xa0},\n\t{0x19, 0x07},\n\t{0x1a, 0xf0},\n\t{0x29, 0xa0},\n\t{0x2c, 0xf0},\n\t{0x65, 0x20},\n\t{0x67, 0x02},\n};\nstatic const u8 bridge_start_qvga_gbrg_772x[][2] = {\n\t{0x88, 0x08},\n\t{0x1c, 0x00},\n\t{0x1d, 0x00},\n\t{0x1d, 0x02},\n\t{0x1d, 0x00},\n\t{0x1d, 0x00},\n\t{0x1d, 0x4b},\n\t{0x1d, 0x00},\n\t{0x8d, 0x00},\n\t{0x8e, 0x00},\n\t{0xc0, 0x28},\n\t{0xc1, 0x1e},\n\t{0xc2, 0x01},\n\t{0xc3, 0x01},\n};\nstatic const u8 sensor_start_qvga_gbrg_772x[][2] = {\n\t{0x12, 0x41},\n\t{0x17, 0x3f},\n\t{0x18, 0x50},\n\t{0x19, 0x03},\n\t{0x1a, 0x78},\n\t{0x29, 0x50},\n\t{0x2c, 0x78},\n\t{0x65, 0x2f},\n\t{0x67, 0x02},\n};\n\nstatic void ov534_reg_write(struct gspca_dev *gspca_dev, u16 reg, u8 val)\n{\n\tstruct usb_device *udev = gspca_dev->dev;\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\n\tgspca_dbg(gspca_dev, D_USBO, \"SET 01 0000 %04x %02x\\n\", reg, val);\n\tgspca_dev->usb_buf[0] = val;\n\tret = usb_control_msg(udev,\n\t\t\t      usb_sndctrlpipe(udev, 0),\n\t\t\t      0x01,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      0x00, reg, gspca_dev->usb_buf, 1, CTRL_TIMEOUT);\n\tif (ret < 0) {\n\t\tpr_err(\"write failed %d\\n\", ret);\n\t\tgspca_dev->usb_err = ret;\n\t}\n}\n\nstatic u8 ov534_reg_read(struct gspca_dev *gspca_dev, u16 reg)\n{\n\tstruct usb_device *udev = gspca_dev->dev;\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn 0;\n\tret = usb_control_msg(udev,\n\t\t\t      usb_rcvctrlpipe(udev, 0),\n\t\t\t      0x01,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      0x00, reg, gspca_dev->usb_buf, 1, CTRL_TIMEOUT);\n\tgspca_dbg(gspca_dev, D_USBI, \"GET 01 0000 %04x %02x\\n\",\n\t\t  reg, gspca_dev->usb_buf[0]);\n\tif (ret < 0) {\n\t\tpr_err(\"read failed %d\\n\", ret);\n\t\tgspca_dev->usb_err = ret;\n\t\t \n\t\tgspca_dev->usb_buf[0] = 0;\n\t}\n\treturn gspca_dev->usb_buf[0];\n}\n\n \nstatic void ov534_set_led(struct gspca_dev *gspca_dev, int status)\n{\n\tu8 data;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"led status: %d\\n\", status);\n\n\tdata = ov534_reg_read(gspca_dev, 0x21);\n\tdata |= 0x80;\n\tov534_reg_write(gspca_dev, 0x21, data);\n\n\tdata = ov534_reg_read(gspca_dev, 0x23);\n\tif (status)\n\t\tdata |= 0x80;\n\telse\n\t\tdata &= ~0x80;\n\n\tov534_reg_write(gspca_dev, 0x23, data);\n\n\tif (!status) {\n\t\tdata = ov534_reg_read(gspca_dev, 0x21);\n\t\tdata &= ~0x80;\n\t\tov534_reg_write(gspca_dev, 0x21, data);\n\t}\n}\n\nstatic int sccb_check_status(struct gspca_dev *gspca_dev)\n{\n\tu8 data;\n\tint i;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tusleep_range(10000, 20000);\n\t\tdata = ov534_reg_read(gspca_dev, OV534_REG_STATUS);\n\n\t\tswitch (data) {\n\t\tcase 0x00:\n\t\t\treturn 1;\n\t\tcase 0x04:\n\t\t\treturn 0;\n\t\tcase 0x03:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgspca_err(gspca_dev, \"sccb status 0x%02x, attempt %d/5\\n\",\n\t\t\t\t  data, i + 1);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void sccb_reg_write(struct gspca_dev *gspca_dev, u8 reg, u8 val)\n{\n\tgspca_dbg(gspca_dev, D_USBO, \"sccb write: %02x %02x\\n\", reg, val);\n\tov534_reg_write(gspca_dev, OV534_REG_SUBADDR, reg);\n\tov534_reg_write(gspca_dev, OV534_REG_WRITE, val);\n\tov534_reg_write(gspca_dev, OV534_REG_OPERATION, OV534_OP_WRITE_3);\n\n\tif (!sccb_check_status(gspca_dev)) {\n\t\tpr_err(\"sccb_reg_write failed\\n\");\n\t\tgspca_dev->usb_err = -EIO;\n\t}\n}\n\nstatic u8 sccb_reg_read(struct gspca_dev *gspca_dev, u16 reg)\n{\n\tov534_reg_write(gspca_dev, OV534_REG_SUBADDR, reg);\n\tov534_reg_write(gspca_dev, OV534_REG_OPERATION, OV534_OP_WRITE_2);\n\tif (!sccb_check_status(gspca_dev))\n\t\tpr_err(\"sccb_reg_read failed 1\\n\");\n\n\tov534_reg_write(gspca_dev, OV534_REG_OPERATION, OV534_OP_READ_2);\n\tif (!sccb_check_status(gspca_dev))\n\t\tpr_err(\"sccb_reg_read failed 2\\n\");\n\n\treturn ov534_reg_read(gspca_dev, OV534_REG_READ);\n}\n\n \nstatic void reg_w_array(struct gspca_dev *gspca_dev,\n\t\t\tconst u8 (*data)[2], int len)\n{\n\twhile (--len >= 0) {\n\t\tov534_reg_write(gspca_dev, (*data)[0], (*data)[1]);\n\t\tdata++;\n\t}\n}\n\n \nstatic void sccb_w_array(struct gspca_dev *gspca_dev,\n\t\t\tconst u8 (*data)[2], int len)\n{\n\twhile (--len >= 0) {\n\t\tif ((*data)[0] != 0xff) {\n\t\t\tsccb_reg_write(gspca_dev, (*data)[0], (*data)[1]);\n\t\t} else {\n\t\t\tsccb_reg_read(gspca_dev, (*data)[1]);\n\t\t\tsccb_reg_write(gspca_dev, 0xff, 0x00);\n\t\t}\n\t\tdata++;\n\t}\n}\n\n \nstatic void set_frame_rate(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint i;\n\tstruct rate_s {\n\t\tu8 fps;\n\t\tu8 r11;\n\t\tu8 r0d;\n\t\tu8 re5;\n\t};\n\tconst struct rate_s *r;\n\tstatic const struct rate_s rate_0[] = {\t \n\t\t{60, 0x01, 0xc1, 0x04},\n\t\t{50, 0x01, 0x41, 0x02},\n\t\t{40, 0x02, 0xc1, 0x04},\n\t\t{30, 0x04, 0x81, 0x02},\n\t\t{15, 0x03, 0x41, 0x04},\n\t};\n\tstatic const struct rate_s rate_1[] = {\t \n \n\t\t{187, 0x01, 0x81, 0x02},  \n\t\t{150, 0x01, 0xc1, 0x04},\n\t\t{137, 0x02, 0xc1, 0x02},\n\t\t{125, 0x02, 0x81, 0x02},\n\t\t{100, 0x02, 0xc1, 0x04},\n\t\t{75, 0x03, 0xc1, 0x04},\n\t\t{60, 0x04, 0xc1, 0x04},\n\t\t{50, 0x02, 0x41, 0x04},\n\t\t{37, 0x03, 0x41, 0x04},\n\t\t{30, 0x04, 0x41, 0x04},\n\t};\n\n\tif (sd->sensor != SENSOR_OV772x)\n\t\treturn;\n\tif (gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv == 0) {\n\t\tr = rate_0;\n\t\ti = ARRAY_SIZE(rate_0);\n\t} else {\n\t\tr = rate_1;\n\t\ti = ARRAY_SIZE(rate_1);\n\t}\n\twhile (--i > 0) {\n\t\tif (sd->frame_rate >= r->fps)\n\t\t\tbreak;\n\t\tr++;\n\t}\n\n\tsccb_reg_write(gspca_dev, 0x11, r->r11);\n\tsccb_reg_write(gspca_dev, 0x0d, r->r0d);\n\tov534_reg_write(gspca_dev, 0xe5, r->re5);\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"frame_rate: %d\\n\", r->fps);\n}\n\nstatic void sethue(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->sensor == SENSOR_OV767x) {\n\t\t \n\t} else {\n\t\ts16 huesin;\n\t\ts16 huecos;\n\n\t\t \n\t\thuesin = fixp_sin16(val) * 0x80 / 0x7fff;\n\t\thuecos = fixp_cos16(val) * 0x80 / 0x7fff;\n\n\t\tif (huesin < 0) {\n\t\t\tsccb_reg_write(gspca_dev, 0xab,\n\t\t\t\tsccb_reg_read(gspca_dev, 0xab) | 0x2);\n\t\t\thuesin = -huesin;\n\t\t} else {\n\t\t\tsccb_reg_write(gspca_dev, 0xab,\n\t\t\t\tsccb_reg_read(gspca_dev, 0xab) & ~0x2);\n\n\t\t}\n\t\tsccb_reg_write(gspca_dev, 0xa9, (u8)huecos);\n\t\tsccb_reg_write(gspca_dev, 0xaa, (u8)huesin);\n\t}\n}\n\nstatic void setsaturation(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->sensor == SENSOR_OV767x) {\n\t\tint i;\n\t\tstatic u8 color_tb[][6] = {\n\t\t\t{0x42, 0x42, 0x00, 0x11, 0x30, 0x41},\n\t\t\t{0x52, 0x52, 0x00, 0x16, 0x3c, 0x52},\n\t\t\t{0x66, 0x66, 0x00, 0x1b, 0x4b, 0x66},\n\t\t\t{0x80, 0x80, 0x00, 0x22, 0x5e, 0x80},\n\t\t\t{0x9a, 0x9a, 0x00, 0x29, 0x71, 0x9a},\n\t\t\t{0xb8, 0xb8, 0x00, 0x31, 0x87, 0xb8},\n\t\t\t{0xdd, 0xdd, 0x00, 0x3b, 0xa2, 0xdd},\n\t\t};\n\n\t\tfor (i = 0; i < ARRAY_SIZE(color_tb[0]); i++)\n\t\t\tsccb_reg_write(gspca_dev, 0x4f + i, color_tb[val][i]);\n\t} else {\n\t\tsccb_reg_write(gspca_dev, 0xa7, val);  \n\t\tsccb_reg_write(gspca_dev, 0xa8, val);  \n\t}\n}\n\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->sensor == SENSOR_OV767x) {\n\t\tif (val < 0)\n\t\t\tval = 0x80 - val;\n\t\tsccb_reg_write(gspca_dev, 0x55, val);\t \n\t} else {\n\t\tsccb_reg_write(gspca_dev, 0x9b, val);\n\t}\n}\n\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->sensor == SENSOR_OV767x)\n\t\tsccb_reg_write(gspca_dev, 0x56, val);\t \n\telse\n\t\tsccb_reg_write(gspca_dev, 0x9c, val);\n}\n\nstatic void setgain(struct gspca_dev *gspca_dev, s32 val)\n{\n\tswitch (val & 0x30) {\n\tcase 0x00:\n\t\tval &= 0x0f;\n\t\tbreak;\n\tcase 0x10:\n\t\tval &= 0x0f;\n\t\tval |= 0x30;\n\t\tbreak;\n\tcase 0x20:\n\t\tval &= 0x0f;\n\t\tval |= 0x70;\n\t\tbreak;\n\tdefault:\n \n\t\tval &= 0x0f;\n\t\tval |= 0xf0;\n\t\tbreak;\n\t}\n\tsccb_reg_write(gspca_dev, 0x00, val);\n}\n\nstatic s32 getgain(struct gspca_dev *gspca_dev)\n{\n\treturn sccb_reg_read(gspca_dev, 0x00);\n}\n\nstatic void setexposure(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->sensor == SENSOR_OV767x) {\n\n\t\t \n\t\tsccb_reg_write(gspca_dev, 0x10, val);\t \n\t} else {\n\n\t\t \n\t\tsccb_reg_write(gspca_dev, 0x08, val >> 7);\n\t\tsccb_reg_write(gspca_dev, 0x10, val << 1);\n\t}\n}\n\nstatic s32 getexposure(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->sensor == SENSOR_OV767x) {\n\t\t \n\t\treturn sccb_reg_read(gspca_dev, 0x10);\t \n\t} else {\n\t\tu8 hi = sccb_reg_read(gspca_dev, 0x08);\n\t\tu8 lo = sccb_reg_read(gspca_dev, 0x10);\n\t\treturn (hi << 8 | lo) >> 1;\n\t}\n}\n\nstatic void setagc(struct gspca_dev *gspca_dev, s32 val)\n{\n\tif (val) {\n\t\tsccb_reg_write(gspca_dev, 0x13,\n\t\t\t\tsccb_reg_read(gspca_dev, 0x13) | 0x04);\n\t\tsccb_reg_write(gspca_dev, 0x64,\n\t\t\t\tsccb_reg_read(gspca_dev, 0x64) | 0x03);\n\t} else {\n\t\tsccb_reg_write(gspca_dev, 0x13,\n\t\t\t\tsccb_reg_read(gspca_dev, 0x13) & ~0x04);\n\t\tsccb_reg_write(gspca_dev, 0x64,\n\t\t\t\tsccb_reg_read(gspca_dev, 0x64) & ~0x03);\n\t}\n}\n\nstatic void setawb(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (val) {\n\t\tsccb_reg_write(gspca_dev, 0x13,\n\t\t\t\tsccb_reg_read(gspca_dev, 0x13) | 0x02);\n\t\tif (sd->sensor == SENSOR_OV772x)\n\t\t\tsccb_reg_write(gspca_dev, 0x63,\n\t\t\t\tsccb_reg_read(gspca_dev, 0x63) | 0xc0);\n\t} else {\n\t\tsccb_reg_write(gspca_dev, 0x13,\n\t\t\t\tsccb_reg_read(gspca_dev, 0x13) & ~0x02);\n\t\tif (sd->sensor == SENSOR_OV772x)\n\t\t\tsccb_reg_write(gspca_dev, 0x63,\n\t\t\t\tsccb_reg_read(gspca_dev, 0x63) & ~0xc0);\n\t}\n}\n\nstatic void setaec(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 data;\n\n\tdata = sd->sensor == SENSOR_OV767x ?\n\t\t\t0x05 :\t\t \n\t\t\t0x01;\t\t \n\tswitch (val) {\n\tcase V4L2_EXPOSURE_AUTO:\n\t\tsccb_reg_write(gspca_dev, 0x13,\n\t\t\t\tsccb_reg_read(gspca_dev, 0x13) | data);\n\t\tbreak;\n\tcase V4L2_EXPOSURE_MANUAL:\n\t\tsccb_reg_write(gspca_dev, 0x13,\n\t\t\t\tsccb_reg_read(gspca_dev, 0x13) & ~data);\n\t\tbreak;\n\t}\n}\n\nstatic void setsharpness(struct gspca_dev *gspca_dev, s32 val)\n{\n\tsccb_reg_write(gspca_dev, 0x91, val);\t \n\tsccb_reg_write(gspca_dev, 0x8e, val);\t \n}\n\nstatic void sethvflip(struct gspca_dev *gspca_dev, s32 hflip, s32 vflip)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 val;\n\n\tif (sd->sensor == SENSOR_OV767x) {\n\t\tval = sccb_reg_read(gspca_dev, 0x1e);\t \n\t\tval &= ~0x30;\n\t\tif (hflip)\n\t\t\tval |= 0x20;\n\t\tif (vflip)\n\t\t\tval |= 0x10;\n\t\tsccb_reg_write(gspca_dev, 0x1e, val);\n\t} else {\n\t\tval = sccb_reg_read(gspca_dev, 0x0c);\n\t\tval &= ~0xc0;\n\t\tif (hflip == 0)\n\t\t\tval |= 0x40;\n\t\tif (vflip == 0)\n\t\t\tval |= 0x80;\n\t\tsccb_reg_write(gspca_dev, 0x0c, val);\n\t}\n}\n\nstatic void setlightfreq(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tval = val ? 0x9e : 0x00;\n\tif (sd->sensor == SENSOR_OV767x) {\n\t\tsccb_reg_write(gspca_dev, 0x2a, 0x00);\n\t\tif (val)\n\t\t\tval = 0x9d;\t \n\t}\n\tsccb_reg_write(gspca_dev, 0x2b, val);\n}\n\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam;\n\n\tcam = &gspca_dev->cam;\n\n\tcam->cam_mode = ov772x_mode;\n\tcam->nmodes = ARRAY_SIZE(ov772x_mode);\n\n\tsd->frame_rate = DEFAULT_FRAME_RATE;\n\n\treturn 0;\n}\n\nstatic int ov534_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct sd *sd = container_of(ctrl->handler, struct sd, ctrl_handler);\n\tstruct gspca_dev *gspca_dev = &sd->gspca_dev;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTOGAIN:\n\t\tgspca_dev->usb_err = 0;\n\t\tif (ctrl->val && sd->gain && gspca_dev->streaming)\n\t\t\tsd->gain->val = getgain(gspca_dev);\n\t\treturn gspca_dev->usb_err;\n\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\tgspca_dev->usb_err = 0;\n\t\tif (ctrl->val == V4L2_EXPOSURE_AUTO && sd->exposure &&\n\t\t    gspca_dev->streaming)\n\t\t\tsd->exposure->val = getexposure(gspca_dev);\n\t\treturn gspca_dev->usb_err;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int ov534_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct sd *sd = container_of(ctrl->handler, struct sd, ctrl_handler);\n\tstruct gspca_dev *gspca_dev = &sd->gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_HUE:\n\t\tsethue(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tsetsaturation(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsetbrightness(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tsetcontrast(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t \n\t\tsetagc(gspca_dev, ctrl->val);\n\t\tif (!gspca_dev->usb_err && !ctrl->val && sd->gain)\n\t\t\tsetgain(gspca_dev, sd->gain->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\tsetawb(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t \n\t\tsetaec(gspca_dev, ctrl->val);\n\t\tif (!gspca_dev->usb_err && ctrl->val == V4L2_EXPOSURE_MANUAL &&\n\t\t    sd->exposure)\n\t\t\tsetexposure(gspca_dev, sd->exposure->val);\n\t\tbreak;\n\tcase V4L2_CID_SHARPNESS:\n\t\tsetsharpness(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tsethvflip(gspca_dev, ctrl->val, sd->vflip->val);\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tsethvflip(gspca_dev, sd->hflip->val, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_POWER_LINE_FREQUENCY:\n\t\tsetlightfreq(gspca_dev, ctrl->val);\n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops ov534_ctrl_ops = {\n\t.g_volatile_ctrl = ov534_g_volatile_ctrl,\n\t.s_ctrl = ov534_s_ctrl,\n};\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct v4l2_ctrl_handler *hdl = &sd->ctrl_handler;\n\t \n\tint saturation_min;\n\tint saturation_max;\n\tint saturation_def;\n\tint brightness_min;\n\tint brightness_max;\n\tint brightness_def;\n\tint contrast_max;\n\tint contrast_def;\n\tint exposure_min;\n\tint exposure_max;\n\tint exposure_def;\n\tint hflip_def;\n\n\tif (sd->sensor == SENSOR_OV767x) {\n\t\tsaturation_min = 0;\n\t\tsaturation_max = 6;\n\t\tsaturation_def = 3;\n\t\tbrightness_min = -127;\n\t\tbrightness_max = 127;\n\t\tbrightness_def = 0;\n\t\tcontrast_max = 0x80;\n\t\tcontrast_def = 0x40;\n\t\texposure_min = 0x08;\n\t\texposure_max = 0x60;\n\t\texposure_def = 0x13;\n\t\thflip_def = 1;\n\t} else {\n\t\tsaturation_min = 0;\n\t\tsaturation_max = 255;\n\t\tsaturation_def = 64;\n\t\tbrightness_min = 0;\n\t\tbrightness_max = 255;\n\t\tbrightness_def = 0;\n\t\tcontrast_max = 255;\n\t\tcontrast_def = 32;\n\t\texposure_min = 0;\n\t\texposure_max = 255;\n\t\texposure_def = 120;\n\t\thflip_def = 0;\n\t}\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\n\tv4l2_ctrl_handler_init(hdl, 13);\n\n\tif (sd->sensor == SENSOR_OV772x)\n\t\tsd->hue = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\n\t\t\t\tV4L2_CID_HUE, -90, 90, 1, 0);\n\n\tsd->saturation = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, saturation_min, saturation_max, 1,\n\t\t\tsaturation_def);\n\tsd->brightness = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, brightness_min, brightness_max, 1,\n\t\t\tbrightness_def);\n\tsd->contrast = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, contrast_max, 1, contrast_def);\n\n\tif (sd->sensor == SENSOR_OV772x) {\n\t\tsd->autogain = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\n\t\t\t\tV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\t\tsd->gain = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\n\t\t\t\tV4L2_CID_GAIN, 0, 63, 1, 20);\n\t}\n\n\tsd->autoexposure = v4l2_ctrl_new_std_menu(hdl, &ov534_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE_AUTO,\n\t\t\tV4L2_EXPOSURE_MANUAL, 0,\n\t\t\tV4L2_EXPOSURE_AUTO);\n\tsd->exposure = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE, exposure_min, exposure_max, 1,\n\t\t\texposure_def);\n\n\tsd->autowhitebalance = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\n\t\t\tV4L2_CID_AUTO_WHITE_BALANCE, 0, 1, 1, 1);\n\n\tif (sd->sensor == SENSOR_OV772x)\n\t\tsd->sharpness = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\n\t\t\t\tV4L2_CID_SHARPNESS, 0, 63, 1, 0);\n\n\tsd->hflip = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\n\t\t\tV4L2_CID_HFLIP, 0, 1, 1, hflip_def);\n\tsd->vflip = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\n\t\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\tsd->plfreq = v4l2_ctrl_new_std_menu(hdl, &ov534_ctrl_ops,\n\t\t\tV4L2_CID_POWER_LINE_FREQUENCY,\n\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_50HZ, 0,\n\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_DISABLED);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\n\tif (sd->sensor == SENSOR_OV772x)\n\t\tv4l2_ctrl_auto_cluster(2, &sd->autogain, 0, true);\n\n\tv4l2_ctrl_auto_cluster(2, &sd->autoexposure, V4L2_EXPOSURE_MANUAL,\n\t\t\t       true);\n\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu16 sensor_id;\n\tstatic const struct reg_array bridge_init[NSENSORS] = {\n\t[SENSOR_OV767x] = {bridge_init_767x, ARRAY_SIZE(bridge_init_767x)},\n\t[SENSOR_OV772x] = {bridge_init_772x, ARRAY_SIZE(bridge_init_772x)},\n\t};\n\tstatic const struct reg_array sensor_init[NSENSORS] = {\n\t[SENSOR_OV767x] = {sensor_init_767x, ARRAY_SIZE(sensor_init_767x)},\n\t[SENSOR_OV772x] = {sensor_init_772x, ARRAY_SIZE(sensor_init_772x)},\n\t};\n\n\t \n\tov534_reg_write(gspca_dev, 0xe7, 0x3a);\n\tov534_reg_write(gspca_dev, 0xe0, 0x08);\n\tmsleep(100);\n\n\t \n\tov534_reg_write(gspca_dev, OV534_REG_ADDRESS, 0x42);\n\n\t \n\tsccb_reg_write(gspca_dev, 0x12, 0x80);\n\tusleep_range(10000, 20000);\n\n\t \n\tsccb_reg_read(gspca_dev, 0x0a);\n\tsensor_id = sccb_reg_read(gspca_dev, 0x0a) << 8;\n\tsccb_reg_read(gspca_dev, 0x0b);\n\tsensor_id |= sccb_reg_read(gspca_dev, 0x0b);\n\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor ID: %04x\\n\", sensor_id);\n\n\tif ((sensor_id & 0xfff0) == 0x7670) {\n\t\tsd->sensor = SENSOR_OV767x;\n\t\tgspca_dev->cam.cam_mode = ov767x_mode;\n\t\tgspca_dev->cam.nmodes = ARRAY_SIZE(ov767x_mode);\n\t} else {\n\t\tsd->sensor = SENSOR_OV772x;\n\t\tgspca_dev->cam.bulk = 1;\n\t\tgspca_dev->cam.bulk_size = 16384;\n\t\tgspca_dev->cam.bulk_nurbs = 2;\n\t\tgspca_dev->cam.mode_framerates = ov772x_framerates;\n\t}\n\n\t \n\treg_w_array(gspca_dev, bridge_init[sd->sensor].val,\n\t\t\tbridge_init[sd->sensor].len);\n\tov534_set_led(gspca_dev, 1);\n\tsccb_w_array(gspca_dev, sensor_init[sd->sensor].val,\n\t\t\tsensor_init[sd->sensor].len);\n\n\tsd_stopN(gspca_dev);\n \n\n\treturn gspca_dev->usb_err;\n}\n\nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint mode;\n\tstatic const struct reg_array bridge_start[NSENSORS][4] = {\n\t[SENSOR_OV767x] = {{bridge_start_qvga_767x,\n\t\t\t\t\tARRAY_SIZE(bridge_start_qvga_767x)},\n\t\t\t{bridge_start_vga_767x,\n\t\t\t\t\tARRAY_SIZE(bridge_start_vga_767x)}},\n\t[SENSOR_OV772x] = {{bridge_start_qvga_yuyv_772x,\n\t\t\t\tARRAY_SIZE(bridge_start_qvga_yuyv_772x)},\n\t\t\t{bridge_start_vga_yuyv_772x,\n\t\t\t\tARRAY_SIZE(bridge_start_vga_yuyv_772x)},\n\t\t\t{bridge_start_qvga_gbrg_772x,\n\t\t\t\tARRAY_SIZE(bridge_start_qvga_gbrg_772x)},\n\t\t\t{bridge_start_vga_gbrg_772x,\n\t\t\t\tARRAY_SIZE(bridge_start_vga_gbrg_772x)} },\n\t};\n\tstatic const struct reg_array sensor_start[NSENSORS][4] = {\n\t[SENSOR_OV767x] = {{sensor_start_qvga_767x,\n\t\t\t\t\tARRAY_SIZE(sensor_start_qvga_767x)},\n\t\t\t{sensor_start_vga_767x,\n\t\t\t\t\tARRAY_SIZE(sensor_start_vga_767x)}},\n\t[SENSOR_OV772x] = {{sensor_start_qvga_yuyv_772x,\n\t\t\t\tARRAY_SIZE(sensor_start_qvga_yuyv_772x)},\n\t\t\t{sensor_start_vga_yuyv_772x,\n\t\t\t\tARRAY_SIZE(sensor_start_vga_yuyv_772x)},\n\t\t\t{sensor_start_qvga_gbrg_772x,\n\t\t\t\tARRAY_SIZE(sensor_start_qvga_gbrg_772x)},\n\t\t\t{sensor_start_vga_gbrg_772x,\n\t\t\t\tARRAY_SIZE(sensor_start_vga_gbrg_772x)} },\n\t};\n\n\t \n\tif (sd->sensor == SENSOR_OV767x)\n\t\tsccb_reg_write(gspca_dev, 0x1e, 0x04);\n\t\t\t\t\t \n\n\tmode = gspca_dev->curr_mode;\t \n\treg_w_array(gspca_dev, bridge_start[sd->sensor][mode].val,\n\t\t\t\tbridge_start[sd->sensor][mode].len);\n\tsccb_w_array(gspca_dev, sensor_start[sd->sensor][mode].val,\n\t\t\t\tsensor_start[sd->sensor][mode].len);\n\n\tset_frame_rate(gspca_dev);\n\n\tif (sd->hue)\n\t\tsethue(gspca_dev, v4l2_ctrl_g_ctrl(sd->hue));\n\tsetsaturation(gspca_dev, v4l2_ctrl_g_ctrl(sd->saturation));\n\tif (sd->autogain)\n\t\tsetagc(gspca_dev, v4l2_ctrl_g_ctrl(sd->autogain));\n\tsetawb(gspca_dev, v4l2_ctrl_g_ctrl(sd->autowhitebalance));\n\tsetaec(gspca_dev, v4l2_ctrl_g_ctrl(sd->autoexposure));\n\tif (sd->gain)\n\t\tsetgain(gspca_dev, v4l2_ctrl_g_ctrl(sd->gain));\n\tsetexposure(gspca_dev, v4l2_ctrl_g_ctrl(sd->exposure));\n\tsetbrightness(gspca_dev, v4l2_ctrl_g_ctrl(sd->brightness));\n\tsetcontrast(gspca_dev, v4l2_ctrl_g_ctrl(sd->contrast));\n\tif (sd->sharpness)\n\t\tsetsharpness(gspca_dev, v4l2_ctrl_g_ctrl(sd->sharpness));\n\tsethvflip(gspca_dev, v4l2_ctrl_g_ctrl(sd->hflip),\n\t\t  v4l2_ctrl_g_ctrl(sd->vflip));\n\tsetlightfreq(gspca_dev, v4l2_ctrl_g_ctrl(sd->plfreq));\n\n\tov534_set_led(gspca_dev, 1);\n\tov534_reg_write(gspca_dev, 0xe0, 0x00);\n\treturn gspca_dev->usb_err;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\tov534_reg_write(gspca_dev, 0xe0, 0x09);\n\tov534_set_led(gspca_dev, 0);\n}\n\n \n#define UVC_STREAM_EOH\t(1 << 7)\n#define UVC_STREAM_ERR\t(1 << 6)\n#define UVC_STREAM_STI\t(1 << 5)\n#define UVC_STREAM_RES\t(1 << 4)\n#define UVC_STREAM_SCR\t(1 << 3)\n#define UVC_STREAM_PTS\t(1 << 2)\n#define UVC_STREAM_EOF\t(1 << 1)\n#define UVC_STREAM_FID\t(1 << 0)\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data, int len)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\t__u32 this_pts;\n\tu16 this_fid;\n\tint remaining_len = len;\n\tint payload_len;\n\n\tpayload_len = gspca_dev->cam.bulk ? 2048 : 2040;\n\tdo {\n\t\tlen = min(remaining_len, payload_len);\n\n\t\t \n\n\t\t \n\t\tif (data[0] != 12 || len < 12) {\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"bad header\\n\");\n\t\t\tgoto discard;\n\t\t}\n\n\t\t \n\t\tif (data[1] & UVC_STREAM_ERR) {\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"payload error\\n\");\n\t\t\tgoto discard;\n\t\t}\n\n\t\t \n\t\tif (!(data[1] & UVC_STREAM_PTS)) {\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"PTS not present\\n\");\n\t\t\tgoto discard;\n\t\t}\n\t\tthis_pts = (data[5] << 24) | (data[4] << 16)\n\t\t\t\t\t\t| (data[3] << 8) | data[2];\n\t\tthis_fid = (data[1] & UVC_STREAM_FID) ? 1 : 0;\n\n\t\t \n\t\tif (this_pts != sd->last_pts || this_fid != sd->last_fid) {\n\t\t\tif (gspca_dev->last_packet_type == INTER_PACKET)\n\t\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET,\n\t\t\t\t\t\tNULL, 0);\n\t\t\tsd->last_pts = this_pts;\n\t\t\tsd->last_fid = this_fid;\n\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\t\t\t\tdata + 12, len - 12);\n\t\t \n\t\t} else if (data[1] & UVC_STREAM_EOF) {\n\t\t\tsd->last_pts = 0;\n\t\t\tif (gspca_dev->pixfmt.pixelformat != V4L2_PIX_FMT_JPEG\n\t\t\t && gspca_dev->image_len + len - 12 !=\n\t\t\t    gspca_dev->pixfmt.sizeimage) {\n\t\t\t\tgspca_dbg(gspca_dev, D_PACK, \"wrong sized frame\\n\");\n\t\t\t\tgoto discard;\n\t\t\t}\n\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET,\n\t\t\t\t\tdata + 12, len - 12);\n\t\t} else {\n\n\t\t\t \n\t\t\tgspca_frame_add(gspca_dev, INTER_PACKET,\n\t\t\t\t\tdata + 12, len - 12);\n\t\t}\n\n\t\t \n\t\tgoto scan_next;\n\ndiscard:\n\t\t \n\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\nscan_next:\n\t\tremaining_len -= len;\n\t\tdata += len;\n\t} while (remaining_len > 0);\n}\n\n \nstatic void sd_get_streamparm(struct gspca_dev *gspca_dev,\n\t\t\t     struct v4l2_streamparm *parm)\n{\n\tstruct v4l2_captureparm *cp = &parm->parm.capture;\n\tstruct v4l2_fract *tpf = &cp->timeperframe;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\ttpf->numerator = 1;\n\ttpf->denominator = sd->frame_rate;\n}\n\n \nstatic void sd_set_streamparm(struct gspca_dev *gspca_dev,\n\t\t\t     struct v4l2_streamparm *parm)\n{\n\tstruct v4l2_captureparm *cp = &parm->parm.capture;\n\tstruct v4l2_fract *tpf = &cp->timeperframe;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (tpf->numerator == 0 || tpf->denominator == 0)\n\t\tsd->frame_rate = DEFAULT_FRAME_RATE;\n\telse\n\t\tsd->frame_rate = tpf->denominator / tpf->numerator;\n\n\tif (gspca_dev->streaming)\n\t\tset_frame_rate(gspca_dev);\n\n\t \n\ttpf->numerator = 1;\n\ttpf->denominator = sd->frame_rate;\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name     = MODULE_NAME,\n\t.config   = sd_config,\n\t.init     = sd_init,\n\t.init_controls = sd_init_controls,\n\t.start    = sd_start,\n\t.stopN    = sd_stopN,\n\t.pkt_scan = sd_pkt_scan,\n\t.get_streamparm = sd_get_streamparm,\n\t.set_streamparm = sd_set_streamparm,\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x1415, 0x2000)},\n\t{USB_DEVICE(0x06f8, 0x3002)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name       = MODULE_NAME,\n\t.id_table   = device_table,\n\t.probe      = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend    = gspca_suspend,\n\t.resume     = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}