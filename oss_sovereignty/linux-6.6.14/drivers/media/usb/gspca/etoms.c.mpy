{
  "module_name": "etoms.c",
  "hash_id": "8aaeb2bd024aecd22ebea8d554a22bdc79a0353acf2bbd64961c0a393625322a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/etoms.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"etoms\"\n\n#include \"gspca.h\"\n\nMODULE_AUTHOR(\"Michel Xhaard <mxhaard@users.sourceforge.net>\");\nMODULE_DESCRIPTION(\"Etoms USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t \n\n\tunsigned char autogain;\n\n\tchar sensor;\n#define SENSOR_PAS106 0\n#define SENSOR_TAS5130CXX 1\n\tsigned char ag_cnt;\n#define AG_CNT_START 13\n};\n\nstatic const struct v4l2_pix_format vga_mode[] = {\n\t{320, 240, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n \n};\n\nstatic const struct v4l2_pix_format sif_mode[] = {\n\t{176, 144, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 176 * 144,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{352, 288, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352,\n\t\t.sizeimage = 352 * 288,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n};\n\n#define ETOMS_ALT_SIZE_1000   12\n\n#define ET_GPIO_DIR_CTRL 0x04\t \n#define ET_GPIO_OUT 0x05\t \n#define ET_GPIO_IN 0x06\t\t \n#define ET_RESET_ALL 0x03\n#define ET_ClCK 0x01\n#define ET_CTRL 0x02\t\t \n\n#define ET_COMP 0x12\t\t \n#define ET_MAXQt 0x13\n#define ET_MINQt 0x14\n#define ET_COMP_VAL0 0x02\n#define ET_COMP_VAL1 0x03\n\n#define ET_REG1d 0x1d\n#define ET_REG1e 0x1e\n#define ET_REG1f 0x1f\n#define ET_REG20 0x20\n#define ET_REG21 0x21\n#define ET_REG22 0x22\n#define ET_REG23 0x23\n#define ET_REG24 0x24\n#define ET_REG25 0x25\n \n#define ET_LUMA_CENTER 0x39\n\n#define ET_G_RED 0x4d\n#define ET_G_GREEN1 0x4e\n#define ET_G_BLUE 0x4f\n#define ET_G_GREEN2 0x50\n#define ET_G_GR_H 0x51\n#define ET_G_GB_H 0x52\n\n#define ET_O_RED 0x34\n#define ET_O_GREEN1 0x35\n#define ET_O_BLUE 0x36\n#define ET_O_GREEN2 0x37\n\n#define ET_SYNCHRO 0x68\n#define ET_STARTX 0x69\n#define ET_STARTY 0x6a\n#define ET_WIDTH_LOW 0x6b\n#define ET_HEIGTH_LOW 0x6c\n#define ET_W_H_HEIGTH 0x6d\n\n#define ET_REG6e 0x6e\t\t \n#define ET_REG6f 0x6f\t\t \n#define ET_REG70 0x70\t\t \n#define ET_REG71 0x71\t\t \n#define ET_REG72 0x72\t\t \n#define ET_REG73 0x73\t\t \n#define ET_REG74 0x74\t\t \n#define ET_REG75 0x75\t\t \n\n#define ET_I2C_CLK 0x8c\n#define ET_PXL_CLK 0x60\n\n#define ET_I2C_BASE 0x89\n#define ET_I2C_COUNT 0x8a\n#define ET_I2C_PREFETCH 0x8b\n#define ET_I2C_REG 0x88\n#define ET_I2C_DATA7 0x87\n#define ET_I2C_DATA6 0x86\n#define ET_I2C_DATA5 0x85\n#define ET_I2C_DATA4 0x84\n#define ET_I2C_DATA3 0x83\n#define ET_I2C_DATA2 0x82\n#define ET_I2C_DATA1 0x81\n#define ET_I2C_DATA0 0x80\n\n#define PAS106_REG2 0x02\t \n#define PAS106_REG3 0x03\t \n#define PAS106_REG4 0x04\t \n#define PAS106_REG5 0x05\t \n#define PAS106_REG6 0x06\t \n#define PAS106_REG7 0x07\t \n#define PAS106_REG9 0x09\n#define PAS106_REG0e 0x0e\t \n#define PAS106_REG13 0x13\t \n\nstatic const __u8 GainRGBG[] = { 0x80, 0x80, 0x80, 0x80, 0x00, 0x00 };\n\nstatic const __u8 I2c2[] = { 0x08, 0x08, 0x08, 0x08, 0x0d };\n\nstatic const __u8 I2c3[] = { 0x12, 0x05 };\n\nstatic const __u8 I2c4[] = { 0x41, 0x08 };\n\n \nstatic void reg_r(struct gspca_dev *gspca_dev,\n\t\t  __u16 index,\n\t\t  __u16 len)\n{\n\tstruct usb_device *dev = gspca_dev->dev;\n\n\tif (len > USB_BUF_SZ) {\n\t\tgspca_err(gspca_dev, \"reg_r: buffer overflow\\n\");\n\t\treturn;\n\t}\n\n\tusb_control_msg(dev,\n\t\t\tusb_rcvctrlpipe(dev, 0),\n\t\t\t0,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t0,\n\t\t\tindex, gspca_dev->usb_buf, len, 500);\n\tgspca_dbg(gspca_dev, D_USBI, \"reg read [%02x] -> %02x ..\\n\",\n\t\t  index, gspca_dev->usb_buf[0]);\n}\n\nstatic void reg_w_val(struct gspca_dev *gspca_dev,\n\t\t\t__u16 index,\n\t\t\t__u8 val)\n{\n\tstruct usb_device *dev = gspca_dev->dev;\n\n\tgspca_dev->usb_buf[0] = val;\n\tusb_control_msg(dev,\n\t\t\tusb_sndctrlpipe(dev, 0),\n\t\t\t0,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t0,\n\t\t\tindex, gspca_dev->usb_buf, 1, 500);\n}\n\nstatic void reg_w(struct gspca_dev *gspca_dev,\n\t\t  __u16 index,\n\t\t  const __u8 *buffer,\n\t\t  __u16 len)\n{\n\tstruct usb_device *dev = gspca_dev->dev;\n\n\tif (len > USB_BUF_SZ) {\n\t\tpr_err(\"reg_w: buffer overflow\\n\");\n\t\treturn;\n\t}\n\tgspca_dbg(gspca_dev, D_USBO, \"reg write [%02x] = %02x..\\n\",\n\t\t  index, *buffer);\n\n\tmemcpy(gspca_dev->usb_buf, buffer, len);\n\tusb_control_msg(dev,\n\t\t\tusb_sndctrlpipe(dev, 0),\n\t\t\t0,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t0, index, gspca_dev->usb_buf, len, 500);\n}\n\nstatic int i2c_w(struct gspca_dev *gspca_dev,\n\t\t __u8 reg,\n\t\t const __u8 *buffer,\n\t\t int len, __u8 mode)\n{\n\t \n\t__u8 ptchcount;\n\n\t \n\treg_w_val(gspca_dev, ET_I2C_BASE, 0x40);\n\t\t\t\t\t  \n\t \n\tptchcount = ((len & 0x07) << 4) | (mode & 0x03);\n\treg_w_val(gspca_dev, ET_I2C_COUNT, ptchcount);\n\t \n\treg_w_val(gspca_dev, ET_I2C_REG, reg);\n\twhile (--len >= 0)\n\t\treg_w_val(gspca_dev, ET_I2C_DATA0 + len, buffer[len]);\n\treturn 0;\n}\n\nstatic int i2c_r(struct gspca_dev *gspca_dev,\n\t\t\t__u8 reg)\n{\n\t \n\treg_w_val(gspca_dev, ET_I2C_BASE, 0x40);\n\t\t\t\t\t \n\t \n\treg_w_val(gspca_dev, ET_I2C_COUNT, 0x11);\n\treg_w_val(gspca_dev, ET_I2C_REG, reg);\t \n\treg_w_val(gspca_dev, ET_I2C_PREFETCH, 0x02);\t \n\treg_w_val(gspca_dev, ET_I2C_PREFETCH, 0x00);\n\treg_r(gspca_dev, ET_I2C_DATA0, 1);\t \n\treturn 0;\n}\n\nstatic int Et_WaitStatus(struct gspca_dev *gspca_dev)\n{\n\tint retry = 10;\n\n\twhile (retry--) {\n\t\treg_r(gspca_dev, ET_ClCK, 1);\n\t\tif (gspca_dev->usb_buf[0] != 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int et_video(struct gspca_dev *gspca_dev,\n\t\t    int on)\n{\n\tint ret;\n\n\treg_w_val(gspca_dev, ET_GPIO_OUT,\n\t\t  on ? 0x10\t\t \n\t\t     : 0);\t\t \n\tret = Et_WaitStatus(gspca_dev);\n\tif (ret != 0)\n\t\tgspca_err(gspca_dev, \"timeout video on/off\\n\");\n\treturn ret;\n}\n\nstatic void Et_init2(struct gspca_dev *gspca_dev)\n{\n\t__u8 value;\n\tstatic const __u8 FormLine[] = { 0x84, 0x03, 0x14, 0xf4, 0x01, 0x05 };\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"Open Init2 ET\\n\");\n\treg_w_val(gspca_dev, ET_GPIO_DIR_CTRL, 0x2f);\n\treg_w_val(gspca_dev, ET_GPIO_OUT, 0x10);\n\treg_r(gspca_dev, ET_GPIO_IN, 1);\n\treg_w_val(gspca_dev, ET_ClCK, 0x14);  \n\tif (gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv)\n\t\tvalue = ET_COMP_VAL1;\t \n\telse\n\t\tvalue = ET_COMP_VAL0;\t \n\treg_w_val(gspca_dev, ET_COMP, value);\n\treg_w_val(gspca_dev, ET_MAXQt, 0x1f);\n\treg_w_val(gspca_dev, ET_MINQt, 0x04);\n\t \n\treg_w_val(gspca_dev, ET_REG1d, 0xff);\n\treg_w_val(gspca_dev, ET_REG1e, 0xff);\n\treg_w_val(gspca_dev, ET_REG1f, 0xff);\n\treg_w_val(gspca_dev, ET_REG20, 0x35);\n\treg_w_val(gspca_dev, ET_REG21, 0x01);\n\treg_w_val(gspca_dev, ET_REG22, 0x00);\n\treg_w_val(gspca_dev, ET_REG23, 0xff);\n\treg_w_val(gspca_dev, ET_REG24, 0xff);\n\treg_w_val(gspca_dev, ET_REG25, 0x0f);\n\t \n\treg_w_val(gspca_dev, 0x30, 0x11);\t\t \n\treg_w_val(gspca_dev, 0x31, 0x40);\n\treg_w_val(gspca_dev, 0x32, 0x00);\n\treg_w_val(gspca_dev, ET_O_RED, 0x00);\t\t \n\treg_w_val(gspca_dev, ET_O_GREEN1, 0x00);\n\treg_w_val(gspca_dev, ET_O_BLUE, 0x00);\n\treg_w_val(gspca_dev, ET_O_GREEN2, 0x00);\n\t \n\treg_w_val(gspca_dev, ET_G_RED, 0x80);\t\t \n\treg_w_val(gspca_dev, ET_G_GREEN1, 0x80);\n\treg_w_val(gspca_dev, ET_G_BLUE, 0x80);\n\treg_w_val(gspca_dev, ET_G_GREEN2, 0x80);\n\treg_w_val(gspca_dev, ET_G_GR_H, 0x00);\n\treg_w_val(gspca_dev, ET_G_GB_H, 0x00);\t\t \n\t \n\treg_w_val(gspca_dev, 0x61, 0x80);\t\t \n\treg_w_val(gspca_dev, 0x62, 0x02);\n\treg_w_val(gspca_dev, 0x63, 0x03);\n\treg_w_val(gspca_dev, 0x64, 0x14);\n\treg_w_val(gspca_dev, 0x65, 0x0e);\n\treg_w_val(gspca_dev, 0x66, 0x02);\n\treg_w_val(gspca_dev, 0x67, 0x02);\n\n\t \n\treg_w_val(gspca_dev, ET_SYNCHRO, 0x8f);\t\t \n\treg_w_val(gspca_dev, ET_STARTX, 0x69);\t\t \n\treg_w_val(gspca_dev, ET_REG6e, 0x86);\n\treg_w_val(gspca_dev, ET_REG6f, 0x01);\n\treg_w_val(gspca_dev, ET_REG70, 0x26);\n\treg_w_val(gspca_dev, ET_REG71, 0x7a);\n\treg_w_val(gspca_dev, ET_REG72, 0x01);\n\t \n\treg_w_val(gspca_dev, ET_REG73, 0x00);\n\treg_w_val(gspca_dev, ET_REG74, 0x18);\t\t \n\treg_w_val(gspca_dev, ET_REG75, 0x0f);\t\t \n\t \n\treg_w_val(gspca_dev, 0x8a, 0x20);\n\treg_w_val(gspca_dev, 0x8d, 0x0f);\n\treg_w_val(gspca_dev, 0x8e, 0x08);\n\t \n\treg_w_val(gspca_dev, 0x03, 0x08);\n\treg_w_val(gspca_dev, ET_PXL_CLK, 0x03);\n\treg_w_val(gspca_dev, 0x81, 0xff);\n\treg_w_val(gspca_dev, 0x80, 0x00);\n\treg_w_val(gspca_dev, 0x81, 0xff);\n\treg_w_val(gspca_dev, 0x80, 0x20);\n\treg_w_val(gspca_dev, 0x03, 0x01);\n\treg_w_val(gspca_dev, 0x03, 0x00);\n\treg_w_val(gspca_dev, 0x03, 0x08);\n\t \n\n \n\t \n\tif (gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv)\n\t\tvalue = 0x04;\t\t \n\telse\t\t\t\t \n\t\tvalue = 0x1e;\t \n\treg_w_val(gspca_dev, ET_PXL_CLK, value);\n\t \n\treg_w(gspca_dev, 0x62, FormLine, 6);\n\n\t \n\treg_w_val(gspca_dev, 0x81, 0x47);\t \n\treg_w_val(gspca_dev, 0x80, 0x40);\t \n\t \n\t \n\t \n\t \n\treg_w_val(gspca_dev, 0x81, 0x30);\t \n\treg_w_val(gspca_dev, 0x80, 0x20);\t \n}\n\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++)\n\t\treg_w_val(gspca_dev, ET_O_RED + i, val);\n}\n\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 val)\n{\n\t__u8 RGBG[] = { 0x80, 0x80, 0x80, 0x80, 0x00, 0x00 };\n\n\tmemset(RGBG, val, sizeof(RGBG) - 2);\n\treg_w(gspca_dev, ET_G_RED, RGBG, 6);\n}\n\nstatic void setcolors(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\t__u8 I2cc[] = { 0x05, 0x02, 0x02, 0x05, 0x0d };\n\t__u8 i2cflags = 0x01;\n\t \n\n\tI2cc[3] = val;\t \n\tI2cc[0] = 15 - val;\t \n\t \n\t \n\tif (sd->sensor == SENSOR_PAS106) {\n\t\ti2c_w(gspca_dev, PAS106_REG13, &i2cflags, 1, 3);\n\t\ti2c_w(gspca_dev, PAS106_REG9, I2cc, sizeof I2cc, 1);\n\t}\n}\n\nstatic s32 getcolors(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->sensor == SENSOR_PAS106) {\n \n\t\ti2c_r(gspca_dev, PAS106_REG9 + 3);\t \n\t\treturn gspca_dev->usb_buf[0] & 0x0f;\n\t}\n\treturn 0;\n}\n\nstatic void setautogain(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->autogain)\n\t\tsd->ag_cnt = AG_CNT_START;\n\telse\n\t\tsd->ag_cnt = -1;\n}\n\nstatic void Et_init1(struct gspca_dev *gspca_dev)\n{\n\t__u8 value;\n \n\t__u8 I2c0[] = { 0x0a, 0x12, 0x05, 0x6d, 0xcd, 0x00, 0x01, 0x00 };\n\t\t\t\t\t\t \n \n\n\tgspca_dbg(gspca_dev, D_STREAM, \"Open Init1 ET\\n\\n\");\n\treg_w_val(gspca_dev, ET_GPIO_DIR_CTRL, 7);\n\treg_r(gspca_dev, ET_GPIO_IN, 1);\n\treg_w_val(gspca_dev, ET_RESET_ALL, 1);\n\treg_w_val(gspca_dev, ET_RESET_ALL, 0);\n\treg_w_val(gspca_dev, ET_ClCK, 0x10);\n\treg_w_val(gspca_dev, ET_CTRL, 0x19);\n\t \n\tif (gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv)\n\t\tvalue = ET_COMP_VAL1;\n\telse\n\t\tvalue = ET_COMP_VAL0;\n\tgspca_dbg(gspca_dev, D_STREAM, \"Open mode %d Compression %d\\n\",\n\t\t  gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv,\n\t\t  value);\n\treg_w_val(gspca_dev, ET_COMP, value);\n\treg_w_val(gspca_dev, ET_MAXQt, 0x1d);\n\treg_w_val(gspca_dev, ET_MINQt, 0x02);\n\t \n\treg_w_val(gspca_dev, ET_REG1d, 0xff);\n\treg_w_val(gspca_dev, ET_REG1e, 0xff);\n\treg_w_val(gspca_dev, ET_REG1f, 0xff);\n\treg_w_val(gspca_dev, ET_REG20, 0x35);\n\treg_w_val(gspca_dev, ET_REG21, 0x01);\n\treg_w_val(gspca_dev, ET_REG22, 0x00);\n\treg_w_val(gspca_dev, ET_REG23, 0xf7);\n\treg_w_val(gspca_dev, ET_REG24, 0xff);\n\treg_w_val(gspca_dev, ET_REG25, 0x07);\n\t \n\treg_w_val(gspca_dev, ET_G_RED, 0x80);\n\treg_w_val(gspca_dev, ET_G_GREEN1, 0x80);\n\treg_w_val(gspca_dev, ET_G_BLUE, 0x80);\n\treg_w_val(gspca_dev, ET_G_GREEN2, 0x80);\n\treg_w_val(gspca_dev, ET_G_GR_H, 0x00);\n\treg_w_val(gspca_dev, ET_G_GB_H, 0x00);\n\t \n\treg_w_val(gspca_dev, ET_SYNCHRO, 0xf0);\n\treg_w_val(gspca_dev, ET_STARTX, 0x56);\t\t \n\treg_w_val(gspca_dev, ET_STARTY, 0x05);\t\t \n\treg_w_val(gspca_dev, ET_WIDTH_LOW, 0x60);\n\treg_w_val(gspca_dev, ET_HEIGTH_LOW, 0x20);\n\treg_w_val(gspca_dev, ET_W_H_HEIGTH, 0x50);\n\treg_w_val(gspca_dev, ET_REG6e, 0x86);\n\treg_w_val(gspca_dev, ET_REG6f, 0x01);\n\treg_w_val(gspca_dev, ET_REG70, 0x86);\n\treg_w_val(gspca_dev, ET_REG71, 0x14);\n\treg_w_val(gspca_dev, ET_REG72, 0x00);\n\t \n\treg_w_val(gspca_dev, ET_REG73, 0x00);\n\treg_w_val(gspca_dev, ET_REG74, 0x00);\n\treg_w_val(gspca_dev, ET_REG75, 0x0a);\n\treg_w_val(gspca_dev, ET_I2C_CLK, 0x04);\n\treg_w_val(gspca_dev, ET_PXL_CLK, 0x01);\n\t \n\tif (gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv) {\n\t\tI2c0[0] = 0x06;\n\t\ti2c_w(gspca_dev, PAS106_REG2, I2c0, sizeof I2c0, 1);\n\t\ti2c_w(gspca_dev, PAS106_REG9, I2c2, sizeof I2c2, 1);\n\t\tvalue = 0x06;\n\t\ti2c_w(gspca_dev, PAS106_REG2, &value, 1, 1);\n\t\ti2c_w(gspca_dev, PAS106_REG3, I2c3, sizeof I2c3, 1);\n\t\t \n\t\tvalue = 0x04;\n\t\ti2c_w(gspca_dev, PAS106_REG0e, &value, 1, 1);\n\t} else {\n\t\tI2c0[0] = 0x0a;\n\n\t\ti2c_w(gspca_dev, PAS106_REG2, I2c0, sizeof I2c0, 1);\n\t\ti2c_w(gspca_dev, PAS106_REG9, I2c2, sizeof I2c2, 1);\n\t\tvalue = 0x0a;\n\t\ti2c_w(gspca_dev, PAS106_REG2, &value, 1, 1);\n\t\ti2c_w(gspca_dev, PAS106_REG3, I2c3, sizeof I2c3, 1);\n\t\tvalue = 0x04;\n\t\t \n\t\ti2c_w(gspca_dev, PAS106_REG0e, &value, 1, 1);\n\t\t \n\t}\n\n \n \n \n\t \n\ti2c_w(gspca_dev, PAS106_REG7, I2c4, sizeof I2c4, 1);\n\t \n\treg_w(gspca_dev, ET_G_RED, GainRGBG, 6);\n\tsetcolors(gspca_dev, getcolors(gspca_dev));\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam;\n\n\tcam = &gspca_dev->cam;\n\tsd->sensor = id->driver_info;\n\tif (sd->sensor == SENSOR_PAS106) {\n\t\tcam->cam_mode = sif_mode;\n\t\tcam->nmodes = ARRAY_SIZE(sif_mode);\n\t} else {\n\t\tcam->cam_mode = vga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(vga_mode);\n\t}\n\tsd->ag_cnt = -1;\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->sensor == SENSOR_PAS106)\n\t\tEt_init1(gspca_dev);\n\telse\n\t\tEt_init2(gspca_dev);\n\treg_w_val(gspca_dev, ET_RESET_ALL, 0x08);\n\tet_video(gspca_dev, 0);\t\t \n\treturn 0;\n}\n\n \nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->sensor == SENSOR_PAS106)\n\t\tEt_init1(gspca_dev);\n\telse\n\t\tEt_init2(gspca_dev);\n\n\tsetautogain(gspca_dev);\n\n\treg_w_val(gspca_dev, ET_RESET_ALL, 0x08);\n\tet_video(gspca_dev, 1);\t\t \n\treturn 0;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\tet_video(gspca_dev, 0);\t\t \n}\n\nstatic __u8 Et_getgainG(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->sensor == SENSOR_PAS106) {\n\t\ti2c_r(gspca_dev, PAS106_REG0e);\n\t\tgspca_dbg(gspca_dev, D_CONF, \"Etoms gain G %d\\n\",\n\t\t\t  gspca_dev->usb_buf[0]);\n\t\treturn gspca_dev->usb_buf[0];\n\t}\n\treturn 0x1f;\n}\n\nstatic void Et_setgainG(struct gspca_dev *gspca_dev, __u8 gain)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->sensor == SENSOR_PAS106) {\n\t\t__u8 i2cflags = 0x01;\n\n\t\ti2c_w(gspca_dev, PAS106_REG13, &i2cflags, 1, 3);\n\t\ti2c_w(gspca_dev, PAS106_REG0e, &gain, 1, 1);\n\t}\n}\n\n#define BLIMIT(bright) \\\n\t(u8)((bright > 0x1f) ? 0x1f : ((bright < 4) ? 3 : bright))\n#define LIMIT(color) \\\n\t(u8)((color > 0xff) ? 0xff : ((color < 0) ? 0 : color))\n\nstatic void do_autogain(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\t__u8 luma;\n\t__u8 luma_mean = 128;\n\t__u8 luma_delta = 20;\n\t__u8 spring = 4;\n\tint Gbright;\n\t__u8 r, g, b;\n\n\tif (sd->ag_cnt < 0)\n\t\treturn;\n\tif (--sd->ag_cnt >= 0)\n\t\treturn;\n\tsd->ag_cnt = AG_CNT_START;\n\n\tGbright = Et_getgainG(gspca_dev);\n\treg_r(gspca_dev, ET_LUMA_CENTER, 4);\n\tg = (gspca_dev->usb_buf[0] + gspca_dev->usb_buf[3]) >> 1;\n\tr = gspca_dev->usb_buf[1];\n\tb = gspca_dev->usb_buf[2];\n\tr = ((r << 8) - (r << 4) - (r << 3)) >> 10;\n\tb = ((b << 7) >> 10);\n\tg = ((g << 9) + (g << 7) + (g << 5)) >> 10;\n\tluma = LIMIT(r + g + b);\n\tgspca_dbg(gspca_dev, D_FRAM, \"Etoms luma G %d\\n\", luma);\n\tif (luma < luma_mean - luma_delta || luma > luma_mean + luma_delta) {\n\t\tGbright += (luma_mean - luma) >> spring;\n\t\tGbright = BLIMIT(Gbright);\n\t\tgspca_dbg(gspca_dev, D_FRAM, \"Etoms Gbright %d\\n\", Gbright);\n\t\tEt_setgainG(gspca_dev, (__u8) Gbright);\n\t}\n}\n\n#undef BLIMIT\n#undef LIMIT\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t \n\t\t\tint len)\t\t\t \n{\n\tint seqframe;\n\n\tseqframe = data[0] & 0x3f;\n\tlen = (int) (((data[0] & 0xc0) << 2) | data[1]);\n\tif (seqframe == 0x3f) {\n\t\tgspca_dbg(gspca_dev, D_FRAM,\n\t\t\t  \"header packet found datalength %d !!\\n\", len);\n\t\tgspca_dbg(gspca_dev, D_FRAM, \"G %d R %d G %d B %d\",\n\t\t\t  data[2], data[3], data[4], data[5]);\n\t\tdata += 30;\n\t\t \n\t\tgspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\n\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, data, len);\n\t\treturn;\n\t}\n\tif (len) {\n\t\tdata += 8;\n\t\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n\t} else {\t\t\t \n\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t}\n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsetbrightness(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tsetcontrast(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tsetcolors(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\tsd->autogain = ctrl->val;\n\t\tsetautogain(gspca_dev);\n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 4);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 1, 127, 1, 63);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 255, 1, 127);\n\tif (sd->sensor == SENSOR_PAS106)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 15, 1, 7);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\treturn 0;\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.pkt_scan = sd_pkt_scan,\n\t.dq_callback = do_autogain,\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x102c, 0x6151), .driver_info = SENSOR_PAS106},\n\t{USB_DEVICE(0x102c, 0x6251), .driver_info = SENSOR_TAS5130CXX},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t    const struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t       THIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}