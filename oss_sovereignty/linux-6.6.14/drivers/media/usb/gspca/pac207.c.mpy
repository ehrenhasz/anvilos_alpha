{
  "module_name": "pac207.c",
  "hash_id": "1e789ee4f15b13f84a547720a4bd1014216138425df43d879c70989ae4e21b6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/pac207.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"pac207\"\n\n#include <linux/input.h>\n#include \"gspca.h\"\n \n#include \"pac_common.h\"\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_DESCRIPTION(\"Pixart PAC207\");\nMODULE_LICENSE(\"GPL\");\n\n#define PAC207_CTRL_TIMEOUT\t\t100   \n\n#define PAC207_BRIGHTNESS_MIN\t\t0\n#define PAC207_BRIGHTNESS_MAX\t\t255\n#define PAC207_BRIGHTNESS_DEFAULT\t46\n#define PAC207_BRIGHTNESS_REG\t\t0x08\n\n#define PAC207_EXPOSURE_MIN\t\t3\n#define PAC207_EXPOSURE_MAX\t\t90  \n#define PAC207_EXPOSURE_DEFAULT\t\t5  \n#define PAC207_EXPOSURE_REG\t\t0x02\n\n#define PAC207_GAIN_MIN\t\t\t0\n#define PAC207_GAIN_MAX\t\t\t31\n#define PAC207_GAIN_DEFAULT\t\t7  \n#define PAC207_GAIN_REG\t\t\t0x0e\n\n#define PAC207_AUTOGAIN_DEADZONE\t30\n\n \nstatic int led_invert;\nmodule_param(led_invert, int, 0644);\nMODULE_PARM_DESC(led_invert, \"Invert led\");\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t\t \n\n\tstruct v4l2_ctrl *brightness;\n\n\tu8 mode;\n\tu8 sof_read;\n\tu8 header_read;\n\tu8 autogain_ignore_frames;\n\n\tatomic_t avg_lum;\n};\n\nstatic const struct v4l2_pix_format sif_mode[] = {\n\t{176, 144, V4L2_PIX_FMT_PAC207, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = (176 + 2) * 144,\n\t\t\t \n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{352, 288, V4L2_PIX_FMT_PAC207, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352,\n\t\t\t \n\t\t.sizeimage = (352 + 2) * 288,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n};\n\nstatic const __u8 pac207_sensor_init[][8] = {\n\t{0x10, 0x12, 0x0d, 0x12, 0x0c, 0x01, 0x29, 0x84},\n\t{0x49, 0x64, 0x64, 0x64, 0x04, 0x10, 0xf0, 0x30},\n\t{0x00, 0x00, 0x00, 0x70, 0xa0, 0xf8, 0x00, 0x00},\n\t{0x32, 0x00, 0x96, 0x00, 0xa2, 0x02, 0xaf, 0x00},\n};\n\nstatic void pac207_write_regs(struct gspca_dev *gspca_dev, u16 index,\n\tconst u8 *buffer, u16 length)\n{\n\tstruct usb_device *udev = gspca_dev->dev;\n\tint err;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\n\tmemcpy(gspca_dev->usb_buf, buffer, length);\n\n\terr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x01,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t0x00, index,\n\t\t\tgspca_dev->usb_buf, length, PAC207_CTRL_TIMEOUT);\n\tif (err < 0) {\n\t\tpr_err(\"Failed to write registers to index 0x%04X, error %d\\n\",\n\t\t       index, err);\n\t\tgspca_dev->usb_err = err;\n\t}\n}\n\nstatic void pac207_write_reg(struct gspca_dev *gspca_dev, u16 index, u16 value)\n{\n\tstruct usb_device *udev = gspca_dev->dev;\n\tint err;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\n\terr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x00,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\tvalue, index, NULL, 0, PAC207_CTRL_TIMEOUT);\n\tif (err) {\n\t\tpr_err(\"Failed to write a register (index 0x%04X, value 0x%02X, error %d)\\n\",\n\t\t       index, value, err);\n\t\tgspca_dev->usb_err = err;\n\t}\n}\n\nstatic int pac207_read_reg(struct gspca_dev *gspca_dev, u16 index)\n{\n\tstruct usb_device *udev = gspca_dev->dev;\n\tint res;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn 0;\n\n\tres = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 0x00,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t0x00, index,\n\t\t\tgspca_dev->usb_buf, 1, PAC207_CTRL_TIMEOUT);\n\tif (res < 0) {\n\t\tpr_err(\"Failed to read a register (index 0x%04X, error %d)\\n\",\n\t\t       index, res);\n\t\tgspca_dev->usb_err = res;\n\t\treturn 0;\n\t}\n\n\treturn gspca_dev->usb_buf[0];\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct cam *cam;\n\tu8 idreg[2];\n\n\tidreg[0] = pac207_read_reg(gspca_dev, 0x0000);\n\tidreg[1] = pac207_read_reg(gspca_dev, 0x0001);\n\tidreg[0] = ((idreg[0] & 0x0f) << 4) | ((idreg[1] & 0xf0) >> 4);\n\tidreg[1] = idreg[1] & 0x0f;\n\tgspca_dbg(gspca_dev, D_PROBE, \"Pixart Sensor ID 0x%02X Chips ID 0x%02X\\n\",\n\t\t  idreg[0], idreg[1]);\n\n\tif (idreg[0] != 0x27) {\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"Error invalid sensor ID!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tgspca_dbg(gspca_dev, D_PROBE,\n\t\t  \"Pixart PAC207BCA Image Processor and Control Chip detected (vid/pid 0x%04X:0x%04X)\\n\",\n\t\t  id->idVendor, id->idProduct);\n\n\tcam = &gspca_dev->cam;\n\tcam->cam_mode = sif_mode;\n\tcam->nmodes = ARRAY_SIZE(sif_mode);\n\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\tu8 mode;\n\n\t \n\tif (led_invert)\n\t\tmode = 0x02;\n\telse\n\t\tmode = 0x00;\n\tpac207_write_reg(gspca_dev, 0x41, mode);\n\tpac207_write_reg(gspca_dev, 0x0f, 0x00);  \n\n\treturn gspca_dev->usb_err;\n}\n\nstatic void setcontrol(struct gspca_dev *gspca_dev, u16 reg, u16 val)\n{\n\tpac207_write_reg(gspca_dev, reg, val);\n\tpac207_write_reg(gspca_dev, 0x13, 0x01);\t \n\tpac207_write_reg(gspca_dev, 0x1c, 0x01);\t \n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tif (ctrl->id == V4L2_CID_AUTOGAIN && ctrl->is_new && ctrl->val) {\n\t\t \n\t\tgspca_dev->exposure->val    = PAC207_EXPOSURE_DEFAULT;\n\t\tgspca_dev->gain->val        = PAC207_GAIN_DEFAULT;\n\t\tsd->autogain_ignore_frames  = PAC_AUTOGAIN_IGNORE_FRAMES;\n\t}\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsetcontrol(gspca_dev, PAC207_BRIGHTNESS_REG, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\tif (gspca_dev->exposure->is_new || (ctrl->is_new && ctrl->val))\n\t\t\tsetcontrol(gspca_dev, PAC207_EXPOSURE_REG,\n\t\t\t\t   gspca_dev->exposure->val);\n\t\tif (gspca_dev->gain->is_new || (ctrl->is_new && ctrl->val))\n\t\t\tsetcontrol(gspca_dev, PAC207_GAIN_REG,\n\t\t\t\t   gspca_dev->gain->val);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\n \nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 4);\n\n\tsd->brightness = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\tV4L2_CID_BRIGHTNESS,\n\t\t\t\tPAC207_BRIGHTNESS_MIN, PAC207_BRIGHTNESS_MAX,\n\t\t\t\t1, PAC207_BRIGHTNESS_DEFAULT);\n\tgspca_dev->autogain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\tV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\tgspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\tV4L2_CID_EXPOSURE,\n\t\t\t\tPAC207_EXPOSURE_MIN, PAC207_EXPOSURE_MAX,\n\t\t\t\t1, PAC207_EXPOSURE_DEFAULT);\n\tgspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\tV4L2_CID_GAIN,\n\t\t\t\tPAC207_GAIN_MIN, PAC207_GAIN_MAX,\n\t\t\t\t1, PAC207_GAIN_DEFAULT);\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\tv4l2_ctrl_auto_cluster(3, &gspca_dev->autogain, 0, false);\n\treturn 0;\n}\n\n \nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\t__u8 mode;\n\n\tpac207_write_reg(gspca_dev, 0x0f, 0x10);  \n\tpac207_write_regs(gspca_dev, 0x0002, pac207_sensor_init[0], 8);\n\tpac207_write_regs(gspca_dev, 0x000a, pac207_sensor_init[1], 8);\n\tpac207_write_regs(gspca_dev, 0x0012, pac207_sensor_init[2], 8);\n\tpac207_write_regs(gspca_dev, 0x0042, pac207_sensor_init[3], 8);\n\n\t \n\tif (gspca_dev->pixfmt.width == 176)\n\t\tpac207_write_reg(gspca_dev, 0x4a, 0xff);\n\telse\n\t\tpac207_write_reg(gspca_dev, 0x4a, 0x30);\n\tpac207_write_reg(gspca_dev, 0x4b, 0x00);  \n\tpac207_write_reg(gspca_dev, 0x08, v4l2_ctrl_g_ctrl(sd->brightness));\n\n\t \n\tpac207_write_reg(gspca_dev, 0x0e,\n\t\tv4l2_ctrl_g_ctrl(gspca_dev->gain));\n\tpac207_write_reg(gspca_dev, 0x02,\n\t\tv4l2_ctrl_g_ctrl(gspca_dev->exposure));  \n\n\t \n\tif (led_invert)\n\t\tmode = 0x00;\n\telse\n\t\tmode = 0x02;\n\tif (gspca_dev->pixfmt.width == 176) {\t \n\t\tmode |= 0x01;\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"pac207_start mode 176x144\\n\");\n\t} else {\t\t\t\t \n\t\tgspca_dbg(gspca_dev, D_STREAM, \"pac207_start mode 352x288\\n\");\n\t}\n\tpac207_write_reg(gspca_dev, 0x41, mode);\n\n\tpac207_write_reg(gspca_dev, 0x13, 0x01);  \n\tpac207_write_reg(gspca_dev, 0x1c, 0x01);  \n\tmsleep(10);\n\tpac207_write_reg(gspca_dev, 0x40, 0x01);  \n\n\tsd->sof_read = 0;\n\tsd->autogain_ignore_frames = 0;\n\tatomic_set(&sd->avg_lum, -1);\n\treturn gspca_dev->usb_err;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\tu8 mode;\n\n\t \n\tif (led_invert)\n\t\tmode = 0x02;\n\telse\n\t\tmode = 0x00;\n\tpac207_write_reg(gspca_dev, 0x40, 0x00);  \n\tpac207_write_reg(gspca_dev, 0x41, mode);  \n\tpac207_write_reg(gspca_dev, 0x0f, 0x00);  \n}\n\n\nstatic void pac207_do_auto_gain(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint avg_lum = atomic_read(&sd->avg_lum);\n\n\tif (avg_lum == -1)\n\t\treturn;\n\n\tif (sd->autogain_ignore_frames > 0)\n\t\tsd->autogain_ignore_frames--;\n\telse if (gspca_coarse_grained_expo_autogain(gspca_dev, avg_lum,\n\t\t\t90, PAC207_AUTOGAIN_DEADZONE))\n\t\tsd->autogain_ignore_frames = PAC_AUTOGAIN_IGNORE_FRAMES;\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\n\t\t\tint len)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tunsigned char *sof;\n\n\tsof = pac_find_sof(gspca_dev, &sd->sof_read, data, len);\n\tif (sof) {\n\t\tint n;\n\n\t\t \n\t\tn = sof - data;\n\t\tif (n > sizeof pac_sof_marker)\n\t\t\tn -= sizeof pac_sof_marker;\n\t\telse\n\t\t\tn = 0;\n\t\tgspca_frame_add(gspca_dev, LAST_PACKET,\n\t\t\t\tdata, n);\n\t\tsd->header_read = 0;\n\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, NULL, 0);\n\t\tlen -= sof - data;\n\t\tdata = sof;\n\t}\n\tif (sd->header_read < 11) {\n\t\tint needed;\n\n\t\t \n\t\tif (sd->header_read < 5) {\n\t\t\tneeded = 5 - sd->header_read;\n\t\t\tif (len >= needed)\n\t\t\t\tatomic_set(&sd->avg_lum, data[needed - 1]);\n\t\t}\n\t\t \n\t\tneeded = 11 - sd->header_read;\n\t\tif (len <= needed) {\n\t\t\tsd->header_read += len;\n\t\t\treturn;\n\t\t}\n\t\tdata += needed;\n\t\tlen -= needed;\n\t\tsd->header_read = 11;\n\t}\n\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n}\n\n#if IS_ENABLED(CONFIG_INPUT)\nstatic int sd_int_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t \n\t\t\tint len)\t\t \n{\n\tint ret = -EINVAL;\n\n\tif (len == 2 && data[0] == 0x5a && data[1] == 0x5a) {\n\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);\n\t\tinput_sync(gspca_dev->input_dev);\n\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\n\t\tinput_sync(gspca_dev->input_dev);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n#endif\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.dq_callback = pac207_do_auto_gain,\n\t.pkt_scan = sd_pkt_scan,\n#if IS_ENABLED(CONFIG_INPUT)\n\t.int_pkt_scan = sd_int_pkt_scan,\n#endif\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x041e, 0x4028)},\n\t{USB_DEVICE(0x093a, 0x2460)},\n\t{USB_DEVICE(0x093a, 0x2461)},\n\t{USB_DEVICE(0x093a, 0x2463)},\n\t{USB_DEVICE(0x093a, 0x2464)},\n\t{USB_DEVICE(0x093a, 0x2468)},\n\t{USB_DEVICE(0x093a, 0x2470)},\n\t{USB_DEVICE(0x093a, 0x2471)},\n\t{USB_DEVICE(0x093a, 0x2472)},\n\t{USB_DEVICE(0x093a, 0x2474)},\n\t{USB_DEVICE(0x093a, 0x2476)},\n\t{USB_DEVICE(0x145f, 0x013a)},\n\t{USB_DEVICE(0x2001, 0xf115)},\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}