{
  "module_name": "pac7302.c",
  "hash_id": "90c6fa080453173241af59745e10fb366b645755a0528a44eb27001aa43febf8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/pac7302.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/input.h>\n#include \"gspca.h\"\n \n#include \"pac_common.h\"\n\n#define PAC7302_RGB_BALANCE_MIN\t\t  0\n#define PAC7302_RGB_BALANCE_MAX\t\t200\n#define PAC7302_RGB_BALANCE_DEFAULT\t100\n#define PAC7302_GAIN_DEFAULT\t\t 15\n#define PAC7302_GAIN_KNEE\t\t 42\n#define PAC7302_EXPOSURE_DEFAULT\t 66  \n#define PAC7302_EXPOSURE_KNEE\t\t133  \n\nMODULE_AUTHOR(\"Jean-Francois Moine <http://moinejf.free.fr>, Thomas Kaiser thomas@kaiser-linux.li\");\nMODULE_DESCRIPTION(\"Pixart PAC7302\");\nMODULE_LICENSE(\"GPL\");\n\nstruct sd {\n\tstruct gspca_dev gspca_dev;\t\t \n\n\tstruct {  \n\t\tstruct v4l2_ctrl *brightness;\n\t\tstruct v4l2_ctrl *contrast;\n\t};\n\tstruct v4l2_ctrl *saturation;\n\tstruct v4l2_ctrl *white_balance;\n\tstruct v4l2_ctrl *red_balance;\n\tstruct v4l2_ctrl *blue_balance;\n\tstruct {  \n\t\tstruct v4l2_ctrl *hflip;\n\t\tstruct v4l2_ctrl *vflip;\n\t};\n\tstruct v4l2_ctrl *sharpness;\n\tu8 flags;\n#define FL_HFLIP 0x01\t\t \n#define FL_VFLIP 0x02\t\t \n\n\tu8 sof_read;\n\ts8 autogain_ignore_frames;\n\n\tatomic_t avg_lum;\n};\n\nstatic const struct v4l2_pix_format vga_mode[] = {\n\t{640, 480, V4L2_PIX_FMT_PJPG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t},\n};\n\n#define LOAD_PAGE3\t\t255\n#define END_OF_SEQUENCE\t\t0\n\nstatic const u8 init_7302[] = {\n \n\t0xff, 0x01,\t\t \n\t0x78, 0x00,\t\t \n\t0xff, 0x01,\n\t0x78, 0x40,\t\t \n};\nstatic const u8 start_7302[] = {\n \n\t0xff, 1,\t0x00,\t\t \n\t0x00, 12,\t0x01, 0x40, 0x40, 0x40, 0x01, 0xe0, 0x02, 0x80,\n\t\t\t0x00, 0x00, 0x00, 0x00,\n\t0x0d, 24,\t0x03, 0x01, 0x00, 0xb5, 0x07, 0xcb, 0x00, 0x00,\n\t\t\t0x07, 0xc8, 0x00, 0xea, 0x07, 0xcf, 0x07, 0xf7,\n\t\t\t0x07, 0x7e, 0x01, 0x0b, 0x00, 0x00, 0x00, 0x11,\n\t0x26, 2,\t0xaa, 0xaa,\n\t0x2e, 1,\t0x31,\n\t0x38, 1,\t0x01,\n\t0x3a, 3,\t0x14, 0xff, 0x5a,\n\t0x43, 11,\t0x00, 0x0a, 0x18, 0x11, 0x01, 0x2c, 0x88, 0x11,\n\t\t\t0x00, 0x54, 0x11,\n\t0x55, 1,\t0x00,\n\t0x62, 4,\t0x10, 0x1e, 0x1e, 0x18,\n\t0x6b, 1,\t0x00,\n\t0x6e, 3,\t0x08, 0x06, 0x00,\n\t0x72, 3,\t0x00, 0xff, 0x00,\n\t0x7d, 23,\t0x01, 0x01, 0x58, 0x46, 0x50, 0x3c, 0x50, 0x3c,\n\t\t\t0x54, 0x46, 0x54, 0x56, 0x52, 0x50, 0x52, 0x50,\n\t\t\t0x56, 0x64, 0xa4, 0x00, 0xda, 0x00, 0x00,\n\t0xa2, 10,\t0x22, 0x2c, 0x3c, 0x54, 0x69, 0x7c, 0x9c, 0xb9,\n\t\t\t0xd2, 0xeb,\n\t0xaf, 1,\t0x02,\n\t0xb5, 2,\t0x08, 0x08,\n\t0xb8, 2,\t0x08, 0x88,\n\t0xc4, 4,\t0xae, 0x01, 0x04, 0x01,\n\t0xcc, 1,\t0x00,\n\t0xd1, 11,\t0x01, 0x30, 0x49, 0x5e, 0x6f, 0x7f, 0x8e, 0xa9,\n\t\t\t0xc1, 0xd7, 0xec,\n\t0xdc, 1,\t0x01,\n\t0xff, 1,\t0x01,\t\t \n\t0x12, 3,\t0x02, 0x00, 0x01,\n\t0x3e, 2,\t0x00, 0x00,\n\t0x76, 5,\t0x01, 0x20, 0x40, 0x00, 0xf2,\n\t0x7c, 1,\t0x00,\n\t0x7f, 10,\t0x4b, 0x0f, 0x01, 0x2c, 0x02, 0x58, 0x03, 0x20,\n\t\t\t0x02, 0x00,\n\t0x96, 5,\t0x01, 0x10, 0x04, 0x01, 0x04,\n\t0xc8, 14,\t0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00,\n\t\t\t0x07, 0x00, 0x01, 0x07, 0x04, 0x01,\n\t0xd8, 1,\t0x01,\n\t0xdb, 2,\t0x00, 0x01,\n\t0xde, 7,\t0x00, 0x01, 0x04, 0x04, 0x00, 0x00, 0x00,\n\t0xe6, 4,\t0x00, 0x00, 0x00, 0x01,\n\t0xeb, 1,\t0x00,\n\t0xff, 1,\t0x02,\t\t \n\t0x22, 1,\t0x00,\n\t0xff, 1,\t0x03,\t\t \n\t0, LOAD_PAGE3,\t\t\t \n\t0x11, 1,\t0x01,\n\t0xff, 1,\t0x02,\t\t \n\t0x13, 1,\t0x00,\n\t0x22, 4,\t0x1f, 0xa4, 0xf0, 0x96,\n\t0x27, 2,\t0x14, 0x0c,\n\t0x2a, 5,\t0xc8, 0x00, 0x18, 0x12, 0x22,\n\t0x64, 8,\t0x00, 0x00, 0xf0, 0x01, 0x14, 0x44, 0x44, 0x44,\n\t0x6e, 1,\t0x08,\n\t0xff, 1,\t0x01,\t\t \n\t0x78, 1,\t0x00,\n\t0, END_OF_SEQUENCE\t\t \n};\n\n#define SKIP\t\t0xaa\n \nstatic const u8 page3_7302[] = {\n\t0x90, 0x40, 0x03, 0x00, 0xc0, 0x01, 0x14, 0x16,\n\t0x14, 0x12, 0x00, 0x00, 0x00, 0x02, 0x33, 0x00,\n\t0x0f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x47, 0x01, 0xb3, 0x01, 0x00,\n\t0x00, 0x08, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x21,\n\t0x00, 0x00, 0x00, 0x54, 0xf4, 0x02, 0x52, 0x54,\n\t0xa4, 0xb8, 0xe0, 0x2a, 0xf6, 0x00, 0x00, 0x00,\n\t0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0xfc, 0x00, 0xf2, 0x1f, 0x04, 0x00, 0x00,\n\tSKIP, 0x00, 0x00, 0xc0, 0xc0, 0x10, 0x00, 0x00,\n\t0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x40, 0xff, 0x03, 0x19, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0xc8, 0xc8, 0xc8,\n\t0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50,\n\t0x08, 0x10, 0x24, 0x40, 0x00, 0x00, 0x00, 0x00,\n\t0x01, 0x00, 0x02, 0x47, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x02, 0xfa, 0x00, 0x64, 0x5a, 0x28, 0x00,\n\t0x00\n};\n\nstatic void reg_w_buf(struct gspca_dev *gspca_dev,\n\t\tu8 index,\n\t\t  const u8 *buffer, int len)\n{\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tmemcpy(gspca_dev->usb_buf, buffer, len);\n\tret = usb_control_msg(gspca_dev->dev,\n\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t0,\t\t \n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0,\t\t \n\t\t\tindex, gspca_dev->usb_buf, len,\n\t\t\t500);\n\tif (ret < 0) {\n\t\tpr_err(\"reg_w_buf failed i: %02x error %d\\n\",\n\t\t       index, ret);\n\t\tgspca_dev->usb_err = ret;\n\t}\n}\n\n\nstatic void reg_w(struct gspca_dev *gspca_dev,\n\t\tu8 index,\n\t\tu8 value)\n{\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tgspca_dev->usb_buf[0] = value;\n\tret = usb_control_msg(gspca_dev->dev,\n\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t0,\t\t\t \n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, index, gspca_dev->usb_buf, 1,\n\t\t\t500);\n\tif (ret < 0) {\n\t\tpr_err(\"reg_w() failed i: %02x v: %02x error %d\\n\",\n\t\t       index, value, ret);\n\t\tgspca_dev->usb_err = ret;\n\t}\n}\n\nstatic void reg_w_seq(struct gspca_dev *gspca_dev,\n\t\tconst u8 *seq, int len)\n{\n\twhile (--len >= 0) {\n\t\treg_w(gspca_dev, seq[0], seq[1]);\n\t\tseq += 2;\n\t}\n}\n\n \nstatic void reg_w_page(struct gspca_dev *gspca_dev,\n\t\t\tconst u8 *page, int len)\n{\n\tint index;\n\tint ret = 0;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tfor (index = 0; index < len; index++) {\n\t\tif (page[index] == SKIP)\t\t \n\t\t\tcontinue;\n\t\tgspca_dev->usb_buf[0] = page[index];\n\t\tret = usb_control_msg(gspca_dev->dev,\n\t\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t\t0,\t\t\t \n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\t0, index, gspca_dev->usb_buf, 1,\n\t\t\t\t500);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"reg_w_page() failed i: %02x v: %02x error %d\\n\",\n\t\t\t       index, page[index], ret);\n\t\t\tgspca_dev->usb_err = ret;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void reg_w_var(struct gspca_dev *gspca_dev,\n\t\t\tconst u8 *seq,\n\t\t\tconst u8 *page3, unsigned int page3_len)\n{\n\tint index, len;\n\n\tfor (;;) {\n\t\tindex = *seq++;\n\t\tlen = *seq++;\n\t\tswitch (len) {\n\t\tcase END_OF_SEQUENCE:\n\t\t\treturn;\n\t\tcase LOAD_PAGE3:\n\t\t\treg_w_page(gspca_dev, page3, page3_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len > USB_BUF_SZ) {\n\t\t\t\tgspca_err(gspca_dev, \"Incorrect variable sequence\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile (len > 0) {\n\t\t\t\tif (len < 8) {\n\t\t\t\t\treg_w_buf(gspca_dev,\n\t\t\t\t\t\tindex, seq, len);\n\t\t\t\t\tseq += len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treg_w_buf(gspca_dev, index, seq, 8);\n\t\t\t\tseq += 8;\n\t\t\t\tindex += 8;\n\t\t\t\tlen -= 8;\n\t\t\t}\n\t\t}\n\t}\n\t \n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam;\n\n\tcam = &gspca_dev->cam;\n\n\tcam->cam_mode = vga_mode;\t \n\tcam->nmodes = ARRAY_SIZE(vga_mode);\n\n\tsd->flags = id->driver_info;\n\treturn 0;\n}\n\nstatic void setbrightcont(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint i, v;\n\tstatic const u8 max[10] =\n\t\t{0x29, 0x33, 0x42, 0x5a, 0x6e, 0x80, 0x9f, 0xbb,\n\t\t 0xd4, 0xec};\n\tstatic const u8 delta[10] =\n\t\t{0x35, 0x33, 0x33, 0x2f, 0x2a, 0x25, 0x1e, 0x17,\n\t\t 0x11, 0x0b};\n\n\treg_w(gspca_dev, 0xff, 0x00);\t\t \n\tfor (i = 0; i < 10; i++) {\n\t\tv = max[i];\n\t\tv += (sd->brightness->val - (s32)sd->brightness->maximum)\n\t\t\t* 150 / (s32)sd->brightness->maximum;  \n\t\tv -= delta[i] * sd->contrast->val / (s32)sd->contrast->maximum;\n\t\tif (v < 0)\n\t\t\tv = 0;\n\t\telse if (v > 0xff)\n\t\t\tv = 0xff;\n\t\treg_w(gspca_dev, 0xa2 + i, v);\n\t}\n\treg_w(gspca_dev, 0xdc, 0x01);\n}\n\nstatic void setcolors(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint i, v;\n\tstatic const int a[9] =\n\t\t{217, -212, 0, -101, 170, -67, -38, -315, 355};\n\tstatic const int b[9] =\n\t\t{19, 106, 0, 19, 106, 1, 19, 106, 1};\n\n\treg_w(gspca_dev, 0xff, 0x03);\t\t\t \n\treg_w(gspca_dev, 0x11, 0x01);\n\treg_w(gspca_dev, 0xff, 0x00);\t\t\t \n\tfor (i = 0; i < 9; i++) {\n\t\tv = a[i] * sd->saturation->val / (s32)sd->saturation->maximum;\n\t\tv += b[i];\n\t\treg_w(gspca_dev, 0x0f + 2 * i, (v >> 8) & 0x07);\n\t\treg_w(gspca_dev, 0x0f + 2 * i + 1, v);\n\t}\n\treg_w(gspca_dev, 0xdc, 0x01);\n}\n\nstatic void setwhitebalance(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\treg_w(gspca_dev, 0xff, 0x00);\t\t \n\treg_w(gspca_dev, 0xc6, sd->white_balance->val);\n\n\treg_w(gspca_dev, 0xdc, 0x01);\n}\n\nstatic u8 rgbbalance_ctrl_to_reg_value(s32 rgb_ctrl_val)\n{\n\tconst unsigned int k = 1000;\t \n\tunsigned int norm;\n\n\t \n\tnorm = k * (rgb_ctrl_val - PAC7302_RGB_BALANCE_MIN)\n\t\t    / (PAC7302_RGB_BALANCE_MAX - PAC7302_RGB_BALANCE_MIN);\n\t \n\treturn 64 * norm * norm / (k*k)  +  32 * norm / k  +  32;\n\t \n\n\t \n}\n\nstatic void setredbalance(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\treg_w(gspca_dev, 0xff, 0x00);\t\t\t \n\treg_w(gspca_dev, 0x01,\n\t      rgbbalance_ctrl_to_reg_value(sd->red_balance->val));\n\n\treg_w(gspca_dev, 0xdc, 0x01);\n}\n\nstatic void setbluebalance(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\treg_w(gspca_dev, 0xff, 0x00);\t\t\t \n\treg_w(gspca_dev, 0x03,\n\t      rgbbalance_ctrl_to_reg_value(sd->blue_balance->val));\n\n\treg_w(gspca_dev, 0xdc, 0x01);\n}\n\nstatic void setgain(struct gspca_dev *gspca_dev)\n{\n\tu8 reg10, reg12;\n\n\tif (gspca_dev->gain->val < 32) {\n\t\treg10 = gspca_dev->gain->val;\n\t\treg12 = 0;\n\t} else {\n\t\treg10 = 31;\n\t\treg12 = gspca_dev->gain->val - 31;\n\t}\n\n\treg_w(gspca_dev, 0xff, 0x03);\t\t\t \n\treg_w(gspca_dev, 0x10, reg10);\n\treg_w(gspca_dev, 0x12, reg12);\n\n\t \n\treg_w(gspca_dev, 0x11, 0x01);\n}\n\nstatic void setexposure(struct gspca_dev *gspca_dev)\n{\n\tu8 clockdiv;\n\tu16 exposure;\n\n\t \n\tclockdiv = (90 * gspca_dev->exposure->val + 1999) / 2000;\n\n\t \n\tif (clockdiv < 6)\n\t\tclockdiv = 6;\n\telse if (clockdiv > 63)\n\t\tclockdiv = 63;\n\n\t \n\tif (clockdiv < 6 || clockdiv > 12)\n\t\tclockdiv = ((clockdiv + 2) / 3) * 3;\n\n\t \n\texposure = (gspca_dev->exposure->val * 45 * 448) / (1000 * clockdiv);\n\t \n\texposure = 448 - exposure;\n\n\treg_w(gspca_dev, 0xff, 0x03);\t\t\t \n\treg_w(gspca_dev, 0x02, clockdiv);\n\treg_w(gspca_dev, 0x0e, exposure & 0xff);\n\treg_w(gspca_dev, 0x0f, exposure >> 8);\n\n\t \n\treg_w(gspca_dev, 0x11, 0x01);\n}\n\nstatic void sethvflip(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 data, hflip, vflip;\n\n\thflip = sd->hflip->val;\n\tif (sd->flags & FL_HFLIP)\n\t\thflip = !hflip;\n\tvflip = sd->vflip->val;\n\tif (sd->flags & FL_VFLIP)\n\t\tvflip = !vflip;\n\n\treg_w(gspca_dev, 0xff, 0x03);\t\t\t \n\tdata = (hflip ? 0x08 : 0x00) | (vflip ? 0x04 : 0x00);\n\treg_w(gspca_dev, 0x21, data);\n\n\t \n\treg_w(gspca_dev, 0x11, 0x01);\n}\n\nstatic void setsharpness(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\treg_w(gspca_dev, 0xff, 0x00);\t\t \n\treg_w(gspca_dev, 0xb6, sd->sharpness->val);\n\n\treg_w(gspca_dev, 0xdc, 0x01);\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\treg_w_seq(gspca_dev, init_7302, sizeof(init_7302)/2);\n\treturn gspca_dev->usb_err;\n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tif (ctrl->id == V4L2_CID_AUTOGAIN && ctrl->is_new && ctrl->val) {\n\t\t \n\t\tgspca_dev->exposure->val    = PAC7302_EXPOSURE_DEFAULT;\n\t\tgspca_dev->gain->val        = PAC7302_GAIN_DEFAULT;\n\t\tsd->autogain_ignore_frames  = PAC_AUTOGAIN_IGNORE_FRAMES;\n\t}\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsetbrightcont(gspca_dev);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tsetcolors(gspca_dev);\n\t\tbreak;\n\tcase V4L2_CID_WHITE_BALANCE_TEMPERATURE:\n\t\tsetwhitebalance(gspca_dev);\n\t\tbreak;\n\tcase V4L2_CID_RED_BALANCE:\n\t\tsetredbalance(gspca_dev);\n\t\tbreak;\n\tcase V4L2_CID_BLUE_BALANCE:\n\t\tsetbluebalance(gspca_dev);\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\tif (gspca_dev->exposure->is_new || (ctrl->is_new && ctrl->val))\n\t\t\tsetexposure(gspca_dev);\n\t\tif (gspca_dev->gain->is_new || (ctrl->is_new && ctrl->val))\n\t\t\tsetgain(gspca_dev);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tsethvflip(gspca_dev);\n\t\tbreak;\n\tcase V4L2_CID_SHARPNESS:\n\t\tsetsharpness(gspca_dev);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\n \nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 12);\n\n\tsd->brightness = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_BRIGHTNESS, 0, 32, 1, 16);\n\tsd->contrast = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_CONTRAST, 0, 255, 1, 127);\n\n\tsd->saturation = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_SATURATION, 0, 255, 1, 127);\n\tsd->white_balance = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_WHITE_BALANCE_TEMPERATURE,\n\t\t\t\t\t0, 255, 1, 55);\n\tsd->red_balance = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_RED_BALANCE,\n\t\t\t\t\tPAC7302_RGB_BALANCE_MIN,\n\t\t\t\t\tPAC7302_RGB_BALANCE_MAX,\n\t\t\t\t\t1, PAC7302_RGB_BALANCE_DEFAULT);\n\tsd->blue_balance = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_BLUE_BALANCE,\n\t\t\t\t\tPAC7302_RGB_BALANCE_MIN,\n\t\t\t\t\tPAC7302_RGB_BALANCE_MAX,\n\t\t\t\t\t1, PAC7302_RGB_BALANCE_DEFAULT);\n\n\tgspca_dev->autogain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\tgspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_EXPOSURE, 0, 1023, 1,\n\t\t\t\t\tPAC7302_EXPOSURE_DEFAULT);\n\tgspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_GAIN, 0, 62, 1,\n\t\t\t\t\tPAC7302_GAIN_DEFAULT);\n\n\tsd->hflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\tsd->vflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\n\tsd->sharpness = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t\tV4L2_CID_SHARPNESS, 0, 15, 1, 8);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\n\tv4l2_ctrl_cluster(2, &sd->brightness);\n\tv4l2_ctrl_auto_cluster(3, &gspca_dev->autogain, 0, false);\n\tv4l2_ctrl_cluster(2, &sd->hflip);\n\treturn 0;\n}\n\n \nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\treg_w_var(gspca_dev, start_7302,\n\t\tpage3_7302, sizeof(page3_7302));\n\n\tsd->sof_read = 0;\n\tsd->autogain_ignore_frames = 0;\n\tatomic_set(&sd->avg_lum, 270 + sd->brightness->val);\n\n\t \n\treg_w(gspca_dev, 0xff, 0x01);\n\treg_w(gspca_dev, 0x78, 0x01);\n\n\treturn gspca_dev->usb_err;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\n\t \n\treg_w(gspca_dev, 0xff, 0x01);\n\treg_w(gspca_dev, 0x78, 0x00);\n}\n\n \nstatic void sd_stop0(struct gspca_dev *gspca_dev)\n{\n\tif (!gspca_dev->present)\n\t\treturn;\n\treg_w(gspca_dev, 0xff, 0x01);\n\treg_w(gspca_dev, 0x78, 0x40);\n}\n\nstatic void do_autogain(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint avg_lum = atomic_read(&sd->avg_lum);\n\tint desired_lum;\n\tconst int deadzone = 30;\n\n\tif (sd->autogain_ignore_frames < 0)\n\t\treturn;\n\n\tif (sd->autogain_ignore_frames > 0) {\n\t\tsd->autogain_ignore_frames--;\n\t} else {\n\t\tdesired_lum = 270 + sd->brightness->val;\n\n\t\tif (gspca_expo_autogain(gspca_dev, avg_lum, desired_lum,\n\t\t\t\t\tdeadzone, PAC7302_GAIN_KNEE,\n\t\t\t\t\tPAC7302_EXPOSURE_KNEE))\n\t\t\tsd->autogain_ignore_frames =\n\t\t\t\t\t\tPAC_AUTOGAIN_IGNORE_FRAMES;\n\t}\n}\n\n \nstatic const u8 jpeg_header[] = {\n\t0xff, 0xd8,\t \n\n\t0xff, 0xc0,\t \n\t0x00, 0x11,\t \n\t0x08,\t\t \n\t0x02, 0x80,\t \n\t0x01, 0xe0,\t \n\t0x03,\t\t \n\t0x01, 0x21, 0x00,  \n\t0x02, 0x11, 0x01,  \n\t0x03, 0x11, 0x01,  \n\n\t0xff, 0xda,\t \n\t0x00, 0x0c,\t \n\t0x03,\t\t \n\t0x01, 0x00,\t \n\t0x02, 0x11,\t \n\t0x03, 0x11,\t \n\t0x00, 0x3f,\t \n\t0x00\t\t \n};\n\n \nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t \n\t\t\tint len)\t\t\t \n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 *image;\n\tu8 *sof;\n\n\tsof = pac_find_sof(gspca_dev, &sd->sof_read, data, len);\n\tif (sof) {\n\t\tint n, lum_offset, footer_length;\n\n\t\t \n\t\tlum_offset = 61 + sizeof pac_sof_marker;\n\t\tfooter_length = 74;\n\n\t\t \n\t\tn = (sof - data) - (footer_length + sizeof pac_sof_marker);\n\t\tif (n < 0) {\n\t\t\tgspca_dev->image_len += n;\n\t\t} else {\n\t\t\tgspca_frame_add(gspca_dev, INTER_PACKET, data, n);\n\t\t}\n\n\t\timage = gspca_dev->image;\n\t\tif (image != NULL\n\t\t && image[gspca_dev->image_len - 2] == 0xff\n\t\t && image[gspca_dev->image_len - 1] == 0xd9)\n\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\n\n\t\tn = sof - data;\n\t\tlen -= n;\n\t\tdata = sof;\n\n\t\t \n\t\tif (gspca_dev->last_packet_type == LAST_PACKET &&\n\t\t\t\tn >= lum_offset)\n\t\t\tatomic_set(&sd->avg_lum, data[-lum_offset] +\n\t\t\t\t\t\tdata[-lum_offset + 1]);\n\n\t\t \n\t\t \n\t\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\t\t\tjpeg_header, sizeof jpeg_header);\n\t}\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int sd_dbg_s_register(struct gspca_dev *gspca_dev,\n\t\t\tconst struct v4l2_dbg_register *reg)\n{\n\tu8 index;\n\tu8 value;\n\n\t \n\tif (reg->match.addr == 0 &&\n\t    (reg->reg < 0x000000ff) &&\n\t    (reg->val <= 0x000000ff)\n\t) {\n\t\t \n\t\t \n\t\tindex = reg->reg;\n\t\tvalue = reg->val;\n\n\t\t \n\t\treg_w(gspca_dev, 0xff, 0x00);\t\t \n\t\treg_w(gspca_dev, index, value);\n\n\t\treg_w(gspca_dev, 0xdc, 0x01);\n\t}\n\treturn gspca_dev->usb_err;\n}\n#endif\n\n#if IS_ENABLED(CONFIG_INPUT)\nstatic int sd_int_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t \n\t\t\tint len)\t\t \n{\n\tint ret = -EINVAL;\n\tu8 data0, data1;\n\n\tif (len == 2) {\n\t\tdata0 = data[0];\n\t\tdata1 = data[1];\n\t\tif ((data0 == 0x00 && data1 == 0x11) ||\n\t\t    (data0 == 0x22 && data1 == 0x33) ||\n\t\t    (data0 == 0x44 && data1 == 0x55) ||\n\t\t    (data0 == 0x66 && data1 == 0x77) ||\n\t\t    (data0 == 0x88 && data1 == 0x99) ||\n\t\t    (data0 == 0xaa && data1 == 0xbb) ||\n\t\t    (data0 == 0xcc && data1 == 0xdd) ||\n\t\t    (data0 == 0xee && data1 == 0xff)) {\n\t\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);\n\t\t\tinput_sync(gspca_dev->input_dev);\n\t\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\n\t\t\tinput_sync(gspca_dev->input_dev);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}\n#endif\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = KBUILD_MODNAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.stop0 = sd_stop0,\n\t.pkt_scan = sd_pkt_scan,\n\t.dq_callback = do_autogain,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.set_register = sd_dbg_s_register,\n#endif\n#if IS_ENABLED(CONFIG_INPUT)\n\t.int_pkt_scan = sd_int_pkt_scan,\n#endif\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x06f8, 0x3009)},\n\t{USB_DEVICE(0x06f8, 0x301b)},\n\t{USB_DEVICE(0x093a, 0x2620)},\n\t{USB_DEVICE(0x093a, 0x2621)},\n\t{USB_DEVICE(0x093a, 0x2622), .driver_info = FL_VFLIP},\n\t{USB_DEVICE(0x093a, 0x2623), .driver_info = FL_VFLIP},\n\t{USB_DEVICE(0x093a, 0x2624), .driver_info = FL_VFLIP},\n\t{USB_DEVICE(0x093a, 0x2625)},\n\t{USB_DEVICE(0x093a, 0x2626)},\n\t{USB_DEVICE(0x093a, 0x2627), .driver_info = FL_VFLIP},\n\t{USB_DEVICE(0x093a, 0x2628)},\n\t{USB_DEVICE(0x093a, 0x2629), .driver_info = FL_VFLIP},\n\t{USB_DEVICE(0x093a, 0x262a)},\n\t{USB_DEVICE(0x093a, 0x262c)},\n\t{USB_DEVICE(0x145f, 0x013c)},\n\t{USB_DEVICE(0x1ae7, 0x2001)},  \n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}