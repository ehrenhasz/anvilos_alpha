{
  "module_name": "sq905c.c",
  "hash_id": "f7993b2d6a838e0b6499b3fe2e71fae0a19a4a91989e71d4b98942c22c5ad51d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/sq905c.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"sq905c\"\n\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include \"gspca.h\"\n\nMODULE_AUTHOR(\"Theodore Kilgore <kilgota@auburn.edu>\");\nMODULE_DESCRIPTION(\"GSPCA/SQ905C USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define SQ905C_CMD_TIMEOUT 500\n#define SQ905C_DATA_TIMEOUT 1000\n\n \n#define SQ905C_MAX_TRANSFER 0x8000\n\n#define FRAME_HEADER_LEN 0x50\n\n \n#define SQ905C_CLEAR   0xa0\t\t \n#define SQ905C_GET_ID  0x14f4\t\t \n#define SQ905C_CAPTURE_LOW 0xa040\t \n#define SQ905C_CAPTURE_MED 0x1440\t \n#define SQ905C_CAPTURE_HI 0x2840\t \n\n \n#define SQ905C_CAPTURE_INDEX 0x110f\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t \n\tconst struct v4l2_pix_format *cap_mode;\n\t \n\tstruct work_struct work_struct;\n\tstruct workqueue_struct *work_thread;\n};\n\n \nstatic struct v4l2_pix_format sq905c_mode[] = {\n\t{ 320, 240, V4L2_PIX_FMT_SQ905C, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n\t{ 640, 480, V4L2_PIX_FMT_SQ905C, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0}\n};\n\n \nstatic int sq905c_command(struct gspca_dev *gspca_dev, u16 command, u16 index)\n{\n\tint ret;\n\n\tret = usb_control_msg(gspca_dev->dev,\n\t\t\t      usb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t      USB_REQ_SYNCH_FRAME,                 \n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      command, index, NULL, 0,\n\t\t\t      SQ905C_CMD_TIMEOUT);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: usb_control_msg failed (%d)\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sq905c_read(struct gspca_dev *gspca_dev, u16 command, u16 index,\n\t\t       int size)\n{\n\tint ret;\n\n\tret = usb_control_msg(gspca_dev->dev,\n\t\t\t      usb_rcvctrlpipe(gspca_dev->dev, 0),\n\t\t\t      USB_REQ_SYNCH_FRAME,\t\t \n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      command, index, gspca_dev->usb_buf, size,\n\t\t\t      SQ905C_CMD_TIMEOUT);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: usb_control_msg failed (%d)\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void sq905c_dostream(struct work_struct *work)\n{\n\tstruct sd *dev = container_of(work, struct sd, work_struct);\n\tstruct gspca_dev *gspca_dev = &dev->gspca_dev;\n\tint bytes_left;  \n\tint data_len;    \n\tint act_len;\n\tint packet_type;\n\tint ret;\n\tu8 *buffer;\n\n\tbuffer = kmalloc(SQ905C_MAX_TRANSFER, GFP_KERNEL);\n\tif (!buffer) {\n\t\tpr_err(\"Couldn't allocate USB buffer\\n\");\n\t\tgoto quit_stream;\n\t}\n\n\twhile (gspca_dev->present && gspca_dev->streaming) {\n#ifdef CONFIG_PM\n\t\tif (gspca_dev->frozen)\n\t\t\tbreak;\n#endif\n\t\t \n\t\tret = usb_bulk_msg(gspca_dev->dev,\n\t\t\t\tusb_rcvbulkpipe(gspca_dev->dev, 0x81),\n\t\t\t\tbuffer, FRAME_HEADER_LEN, &act_len,\n\t\t\t\tSQ905C_DATA_TIMEOUT);\n\t\tgspca_dbg(gspca_dev, D_STREAM,\n\t\t\t  \"Got %d bytes out of %d for header\\n\",\n\t\t\t  act_len, FRAME_HEADER_LEN);\n\t\tif (ret < 0 || act_len < FRAME_HEADER_LEN)\n\t\t\tgoto quit_stream;\n\t\t \n\t\tbytes_left = buffer[0x40]|(buffer[0x41]<<8)|(buffer[0x42]<<16)\n\t\t\t\t\t|(buffer[0x43]<<24);\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"bytes_left = 0x%x\\n\",\n\t\t\t  bytes_left);\n\t\t \n\t\tpacket_type = FIRST_PACKET;\n\t\tgspca_frame_add(gspca_dev, packet_type,\n\t\t\t\tbuffer, FRAME_HEADER_LEN);\n\t\twhile (bytes_left > 0 && gspca_dev->present) {\n\t\t\tdata_len = bytes_left > SQ905C_MAX_TRANSFER ?\n\t\t\t\tSQ905C_MAX_TRANSFER : bytes_left;\n\t\t\tret = usb_bulk_msg(gspca_dev->dev,\n\t\t\t\tusb_rcvbulkpipe(gspca_dev->dev, 0x81),\n\t\t\t\tbuffer, data_len, &act_len,\n\t\t\t\tSQ905C_DATA_TIMEOUT);\n\t\t\tif (ret < 0 || act_len < data_len)\n\t\t\t\tgoto quit_stream;\n\t\t\tgspca_dbg(gspca_dev, D_STREAM,\n\t\t\t\t  \"Got %d bytes out of %d for frame\\n\",\n\t\t\t\t  data_len, bytes_left);\n\t\t\tbytes_left -= data_len;\n\t\t\tif (bytes_left == 0)\n\t\t\t\tpacket_type = LAST_PACKET;\n\t\t\telse\n\t\t\t\tpacket_type = INTER_PACKET;\n\t\t\tgspca_frame_add(gspca_dev, packet_type,\n\t\t\t\t\tbuffer, data_len);\n\t\t}\n\t}\nquit_stream:\n\tif (gspca_dev->present) {\n\t\tmutex_lock(&gspca_dev->usb_lock);\n\t\tsq905c_command(gspca_dev, SQ905C_CLEAR, 0);\n\t\tmutex_unlock(&gspca_dev->usb_lock);\n\t}\n\tkfree(buffer);\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct cam *cam = &gspca_dev->cam;\n\tstruct sd *dev = (struct sd *) gspca_dev;\n\tint ret;\n\n\tgspca_dbg(gspca_dev, D_PROBE,\n\t\t  \"SQ9050 camera detected (vid/pid 0x%04X:0x%04X)\\n\",\n\t\t  id->idVendor, id->idProduct);\n\n\tret = sq905c_command(gspca_dev, SQ905C_GET_ID, 0);\n\tif (ret < 0) {\n\t\tgspca_err(gspca_dev, \"Get version command failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = sq905c_read(gspca_dev, 0xf5, 0, 20);\n\tif (ret < 0) {\n\t\tgspca_err(gspca_dev, \"Reading version command failed\\n\");\n\t\treturn ret;\n\t}\n\t \n\tgspca_dbg(gspca_dev, D_PROBE,\n\t\t  \"SQ9050 ID string: %02x - %*ph\\n\",\n\t\t  gspca_dev->usb_buf[3], 6, gspca_dev->usb_buf + 14);\n\n\tcam->cam_mode = sq905c_mode;\n\tcam->nmodes = 2;\n\tif (gspca_dev->usb_buf[15] == 0)\n\t\tcam->nmodes = 1;\n\t \n\tcam->bulk_size = 32;\n\tcam->bulk = 1;\n\tINIT_WORK(&dev->work_struct, sq905c_dostream);\n\treturn 0;\n}\n\n \n \nstatic void sd_stop0(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *dev = (struct sd *) gspca_dev;\n\n\t \n\tmutex_unlock(&gspca_dev->usb_lock);\n\t \n\tdestroy_workqueue(dev->work_thread);\n\tdev->work_thread = NULL;\n\tmutex_lock(&gspca_dev->usb_lock);\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\t \n\treturn sq905c_command(gspca_dev, SQ905C_CLEAR, 0);\n}\n\n \nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *dev = (struct sd *) gspca_dev;\n\tint ret;\n\n\tdev->cap_mode = gspca_dev->cam.cam_mode;\n\t \n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 640:\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Start streaming at high resolution\\n\");\n\t\tdev->cap_mode++;\n\t\tret = sq905c_command(gspca_dev, SQ905C_CAPTURE_HI,\n\t\t\t\t\t\tSQ905C_CAPTURE_INDEX);\n\t\tbreak;\n\tdefault:  \n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Start streaming at medium resolution\\n\");\n\t\tret = sq905c_command(gspca_dev, SQ905C_CAPTURE_MED,\n\t\t\t\t\t\tSQ905C_CAPTURE_INDEX);\n\t}\n\n\tif (ret < 0) {\n\t\tgspca_err(gspca_dev, \"Start streaming command failed\\n\");\n\t\treturn ret;\n\t}\n\t \n\tdev->work_thread = create_singlethread_workqueue(MODULE_NAME);\n\tif (!dev->work_thread)\n\t\treturn -ENOMEM;\n\n\tqueue_work(dev->work_thread, &dev->work_struct);\n\n\treturn 0;\n}\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x2770, 0x905c)},\n\t{USB_DEVICE(0x2770, 0x9050)},\n\t{USB_DEVICE(0x2770, 0x9051)},\n\t{USB_DEVICE(0x2770, 0x9052)},\n\t{USB_DEVICE(0x2770, 0x913d)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name   = MODULE_NAME,\n\t.config = sd_config,\n\t.init   = sd_init,\n\t.start  = sd_start,\n\t.stop0  = sd_stop0,\n};\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id,\n\t\t\t&sd_desc,\n\t\t\tsizeof(struct sd),\n\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name       = MODULE_NAME,\n\t.id_table   = device_table,\n\t.probe      = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume  = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}