{
  "module_name": "sq930x.c",
  "hash_id": "502065b56e1499b5dd0fc3ae565afab0c6dca94674951c42d3b72d6ba8456aa8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/sq930x.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"sq930x\"\n\n#include \"gspca.h\"\n\nMODULE_AUTHOR(\"Jean-Francois Moine <http://moinejf.free.fr>\\n\"\n\t\t\"Gerard Klaver <gerard at gkall dot hobby dot nl\\n\"\n\t\t\"Sam Revitch <samr7@cs.washington.edu>\");\nMODULE_DESCRIPTION(\"GSPCA/SQ930x USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t \n\n\tstruct {  \n\t\tstruct v4l2_ctrl *exposure;\n\t\tstruct v4l2_ctrl *gain;\n\t};\n\n\tu8 do_ctrl;\n\tu8 gpio[2];\n\tu8 sensor;\n\tu8 type;\n#define Generic 0\n#define Creative_live_motion 1\n};\nenum sensors {\n\tSENSOR_ICX098BQ,\n\tSENSOR_LZ24BP,\n\tSENSOR_MI0360,\n\tSENSOR_MT9V111,\t\t \n\tSENSOR_OV7660,\n\tSENSOR_OV9630,\n};\n\nstatic struct v4l2_pix_format vga_mode[] = {\n\t{320, 240, V4L2_PIX_FMT_SRGGB8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n\t{640, 480, V4L2_PIX_FMT_SRGGB8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n};\n\n \n#define SQ930_CTRL_UCBUS_IO\t0x0001\n#define SQ930_CTRL_I2C_IO\t0x0002\n#define SQ930_CTRL_GPIO\t\t0x0005\n#define SQ930_CTRL_CAP_START\t0x0010\n#define SQ930_CTRL_CAP_STOP\t0x0011\n#define SQ930_CTRL_SET_EXPOSURE 0x001d\n#define SQ930_CTRL_RESET\t0x001e\n#define SQ930_CTRL_GET_DEV_INFO 0x001f\n\n \n#define SQ930_GPIO_DFL_I2C_SDA\t0x0001\n#define SQ930_GPIO_DFL_I2C_SCL\t0x0002\n#define SQ930_GPIO_RSTBAR\t0x0004\n#define SQ930_GPIO_EXTRA1\t0x0040\n#define SQ930_GPIO_EXTRA2\t0x0080\n \n#define SQ930_GPIO_POWER\t0x0200\n#define SQ930_GPIO_DFL_LED\t0x1000\n\nstruct ucbus_write_cmd {\n\tu16\tbw_addr;\n\tu8\tbw_data;\n};\nstruct i2c_write_cmd {\n\tu8\treg;\n\tu16\tval;\n};\n\nstatic const struct ucbus_write_cmd icx098bq_start_0[] = {\n\t{0x0354, 0x00}, {0x03fa, 0x00}, {0xf800, 0x02}, {0xf801, 0xce},\n\t{0xf802, 0xc1}, {0xf804, 0x00}, {0xf808, 0x00}, {0xf809, 0x0e},\n\t{0xf80a, 0x01}, {0xf80b, 0xee}, {0xf807, 0x60}, {0xf80c, 0x02},\n\t{0xf80d, 0xf0}, {0xf80e, 0x03}, {0xf80f, 0x0a}, {0xf81c, 0x02},\n\t{0xf81d, 0xf0}, {0xf81e, 0x03}, {0xf81f, 0x0a}, {0xf83a, 0x00},\n\t{0xf83b, 0x10}, {0xf83c, 0x00}, {0xf83d, 0x4e}, {0xf810, 0x04},\n\t{0xf811, 0x00}, {0xf812, 0x02}, {0xf813, 0x10}, {0xf803, 0x00},\n\t{0xf814, 0x01}, {0xf815, 0x18}, {0xf816, 0x00}, {0xf817, 0x48},\n\t{0xf818, 0x00}, {0xf819, 0x25}, {0xf81a, 0x00}, {0xf81b, 0x3c},\n\t{0xf82f, 0x03}, {0xf820, 0xff}, {0xf821, 0x0d}, {0xf822, 0xff},\n\t{0xf823, 0x07}, {0xf824, 0xff}, {0xf825, 0x03}, {0xf826, 0xff},\n\t{0xf827, 0x06}, {0xf828, 0xff}, {0xf829, 0x03}, {0xf82a, 0xff},\n\t{0xf82b, 0x0c}, {0xf82c, 0xfd}, {0xf82d, 0x01}, {0xf82e, 0x00},\n\t{0xf830, 0x00}, {0xf831, 0x47}, {0xf832, 0x00}, {0xf833, 0x00},\n\t{0xf850, 0x00}, {0xf851, 0x00}, {0xf852, 0x00}, {0xf853, 0x24},\n\t{0xf854, 0x00}, {0xf855, 0x18}, {0xf856, 0x00}, {0xf857, 0x3c},\n\t{0xf858, 0x00}, {0xf859, 0x0c}, {0xf85a, 0x00}, {0xf85b, 0x30},\n\t{0xf85c, 0x00}, {0xf85d, 0x0c}, {0xf85e, 0x00}, {0xf85f, 0x30},\n\t{0xf860, 0x00}, {0xf861, 0x48}, {0xf862, 0x01}, {0xf863, 0xdc},\n\t{0xf864, 0xff}, {0xf865, 0x98}, {0xf866, 0xff}, {0xf867, 0xc0},\n\t{0xf868, 0xff}, {0xf869, 0x70}, {0xf86c, 0xff}, {0xf86d, 0x00},\n\t{0xf86a, 0xff}, {0xf86b, 0x48}, {0xf86e, 0xff}, {0xf86f, 0x00},\n\t{0xf870, 0x01}, {0xf871, 0xdb}, {0xf872, 0x01}, {0xf873, 0xfa},\n\t{0xf874, 0x01}, {0xf875, 0xdb}, {0xf876, 0x01}, {0xf877, 0xfa},\n\t{0xf878, 0x0f}, {0xf879, 0x0f}, {0xf87a, 0xff}, {0xf87b, 0xff},\n\t{0xf800, 0x03}\n};\nstatic const struct ucbus_write_cmd icx098bq_start_1[] = {\n\t{0xf5f0, 0x00}, {0xf5f1, 0xcd}, {0xf5f2, 0x80}, {0xf5f3, 0x80},\n\t{0xf5f4, 0xc0},\n\t{0xf5f0, 0x49}, {0xf5f1, 0xcd}, {0xf5f2, 0x80}, {0xf5f3, 0x80},\n\t{0xf5f4, 0xc0},\n\t{0xf5fa, 0x00}, {0xf5f6, 0x00}, {0xf5f7, 0x00}, {0xf5f8, 0x00},\n\t{0xf5f9, 0x00}\n};\n\nstatic const struct ucbus_write_cmd icx098bq_start_2[] = {\n\t{0xf800, 0x02}, {0xf807, 0xff}, {0xf805, 0x82}, {0xf806, 0x00},\n\t{0xf807, 0x7f}, {0xf800, 0x03},\n\t{0xf800, 0x02}, {0xf807, 0xff}, {0xf805, 0x40}, {0xf806, 0x00},\n\t{0xf807, 0x7f}, {0xf800, 0x03},\n\t{0xf800, 0x02}, {0xf807, 0xff}, {0xf805, 0xcf}, {0xf806, 0xd0},\n\t{0xf807, 0x7f}, {0xf800, 0x03},\n\t{0xf800, 0x02}, {0xf807, 0xff}, {0xf805, 0x00}, {0xf806, 0x00},\n\t{0xf807, 0x7f}, {0xf800, 0x03}\n};\n\nstatic const struct ucbus_write_cmd lz24bp_start_0[] = {\n\t{0x0354, 0x00}, {0x03fa, 0x00}, {0xf800, 0x02}, {0xf801, 0xbe},\n\t{0xf802, 0xc6}, {0xf804, 0x00}, {0xf808, 0x00}, {0xf809, 0x06},\n\t{0xf80a, 0x01}, {0xf80b, 0xfe}, {0xf807, 0x84}, {0xf80c, 0x02},\n\t{0xf80d, 0xf7}, {0xf80e, 0x03}, {0xf80f, 0x0b}, {0xf81c, 0x00},\n\t{0xf81d, 0x49}, {0xf81e, 0x03}, {0xf81f, 0x0b}, {0xf83a, 0x00},\n\t{0xf83b, 0x01}, {0xf83c, 0x00}, {0xf83d, 0x6b}, {0xf810, 0x03},\n\t{0xf811, 0x10}, {0xf812, 0x02}, {0xf813, 0x6f}, {0xf803, 0x00},\n\t{0xf814, 0x00}, {0xf815, 0x44}, {0xf816, 0x00}, {0xf817, 0x48},\n\t{0xf818, 0x00}, {0xf819, 0x25}, {0xf81a, 0x00}, {0xf81b, 0x3c},\n\t{0xf82f, 0x03}, {0xf820, 0xff}, {0xf821, 0x0d}, {0xf822, 0xff},\n\t{0xf823, 0x07}, {0xf824, 0xfd}, {0xf825, 0x07}, {0xf826, 0xf0},\n\t{0xf827, 0x0c}, {0xf828, 0xff}, {0xf829, 0x03}, {0xf82a, 0xff},\n\t{0xf82b, 0x0c}, {0xf82c, 0xfc}, {0xf82d, 0x01}, {0xf82e, 0x00},\n\t{0xf830, 0x00}, {0xf831, 0x47}, {0xf832, 0x00}, {0xf833, 0x00},\n\t{0xf850, 0x00}, {0xf851, 0x00}, {0xf852, 0x00}, {0xf853, 0x24},\n\t{0xf854, 0x00}, {0xf855, 0x0c}, {0xf856, 0x00}, {0xf857, 0x30},\n\t{0xf858, 0x00}, {0xf859, 0x18}, {0xf85a, 0x00}, {0xf85b, 0x3c},\n\t{0xf85c, 0x00}, {0xf85d, 0x18}, {0xf85e, 0x00}, {0xf85f, 0x3c},\n\t{0xf860, 0xff}, {0xf861, 0x37}, {0xf862, 0xff}, {0xf863, 0x1d},\n\t{0xf864, 0xff}, {0xf865, 0x98}, {0xf866, 0xff}, {0xf867, 0xc0},\n\t{0xf868, 0x00}, {0xf869, 0x37}, {0xf86c, 0x02}, {0xf86d, 0x1d},\n\t{0xf86a, 0x00}, {0xf86b, 0x37}, {0xf86e, 0x02}, {0xf86f, 0x1d},\n\t{0xf870, 0x01}, {0xf871, 0xc6}, {0xf872, 0x02}, {0xf873, 0x04},\n\t{0xf874, 0x01}, {0xf875, 0xc6}, {0xf876, 0x02}, {0xf877, 0x04},\n\t{0xf878, 0x0f}, {0xf879, 0x0f}, {0xf87a, 0xff}, {0xf87b, 0xff},\n\t{0xf800, 0x03}\n};\nstatic const struct ucbus_write_cmd lz24bp_start_1_gen[] = {\n\t{0xf5f0, 0x00}, {0xf5f1, 0xff}, {0xf5f2, 0x80}, {0xf5f3, 0x80},\n\t{0xf5f4, 0xb3},\n\t{0xf5f0, 0x40}, {0xf5f1, 0xff}, {0xf5f2, 0x80}, {0xf5f3, 0x80},\n\t{0xf5f4, 0xb3},\n\t{0xf5fa, 0x00}, {0xf5f6, 0x00}, {0xf5f7, 0x00}, {0xf5f8, 0x00},\n\t{0xf5f9, 0x00}\n};\n\nstatic const struct ucbus_write_cmd lz24bp_start_1_clm[] = {\n\t{0xf5f0, 0x00}, {0xf5f1, 0xff}, {0xf5f2, 0x88}, {0xf5f3, 0x88},\n\t{0xf5f4, 0xc0},\n\t{0xf5f0, 0x40}, {0xf5f1, 0xff}, {0xf5f2, 0x88}, {0xf5f3, 0x88},\n\t{0xf5f4, 0xc0},\n\t{0xf5fa, 0x00}, {0xf5f6, 0x00}, {0xf5f7, 0x00}, {0xf5f8, 0x00},\n\t{0xf5f9, 0x00}\n};\n\nstatic const struct ucbus_write_cmd lz24bp_start_2[] = {\n\t{0xf800, 0x02}, {0xf807, 0xff}, {0xf805, 0x80}, {0xf806, 0x00},\n\t{0xf807, 0x7f}, {0xf800, 0x03},\n\t{0xf800, 0x02}, {0xf807, 0xff}, {0xf805, 0x4e}, {0xf806, 0x00},\n\t{0xf807, 0x7f}, {0xf800, 0x03},\n\t{0xf800, 0x02}, {0xf807, 0xff}, {0xf805, 0xc0}, {0xf806, 0x48},\n\t{0xf807, 0x7f}, {0xf800, 0x03},\n\t{0xf800, 0x02}, {0xf807, 0xff}, {0xf805, 0x00}, {0xf806, 0x00},\n\t{0xf807, 0x7f}, {0xf800, 0x03}\n};\n\nstatic const struct ucbus_write_cmd mi0360_start_0[] = {\n\t{0x0354, 0x00}, {0x03fa, 0x00}, {0xf332, 0xcc}, {0xf333, 0xcc},\n\t{0xf334, 0xcc}, {0xf335, 0xcc}, {0xf33f, 0x00}\n};\nstatic const struct i2c_write_cmd mi0360_init_23[] = {\n\t{0x30, 0x0040},\t\t \n\t{0x31, 0x0000},\t\t \n\t{0x34, 0x0100},\t\t \n\t{0x3d, 0x068f},\t\t \n};\nstatic const struct i2c_write_cmd mi0360_init_24[] = {\n\t{0x03, 0x01e5},\t\t \n\t{0x04, 0x0285},\t\t \n};\nstatic const struct i2c_write_cmd mi0360_init_25[] = {\n\t{0x35, 0x0020},\t\t \n\t{0x2b, 0x0020},\t\t \n\t{0x2c, 0x002a},\t\t \n\t{0x2d, 0x0028},\t\t \n\t{0x2e, 0x0020},\t\t \n};\nstatic const struct ucbus_write_cmd mi0360_start_1[] = {\n\t{0xf5f0, 0x11}, {0xf5f1, 0x99}, {0xf5f2, 0x80}, {0xf5f3, 0x80},\n\t{0xf5f4, 0xa6},\n\t{0xf5f0, 0x51}, {0xf5f1, 0x99}, {0xf5f2, 0x80}, {0xf5f3, 0x80},\n\t{0xf5f4, 0xa6},\n\t{0xf5fa, 0x00}, {0xf5f6, 0x00}, {0xf5f7, 0x00}, {0xf5f8, 0x00},\n\t{0xf5f9, 0x00}\n};\nstatic const struct i2c_write_cmd mi0360_start_2[] = {\n\t{0x62, 0x041d},\t\t \n};\nstatic const struct i2c_write_cmd mi0360_start_3[] = {\n\t{0x05, 0x007b},\t\t \n};\nstatic const struct i2c_write_cmd mi0360_start_4[] = {\n\t{0x05, 0x03f5},\t\t \n};\n\nstatic const struct i2c_write_cmd mt9v111_init_0[] = {\n\t{0x01, 0x0001},\t\t \n\t{0x06, 0x300c},\t\t \n\t{0x08, 0xcc00},\t\t \n\t{0x01, 0x0004},\t\t \n};\nstatic const struct i2c_write_cmd mt9v111_init_1[] = {\n\t{0x03, 0x01e5},\t\t \n\t{0x04, 0x0285},\t\t \n};\nstatic const struct i2c_write_cmd mt9v111_init_2[] = {\n\t{0x30, 0x7800},\n\t{0x31, 0x0000},\n\t{0x07, 0x3002},\t\t \n\t{0x35, 0x0020},\t\t \n\t{0x2b, 0x0020},\t\t \n\t{0x2c, 0x0020},\t\t \n\t{0x2d, 0x0020},\t\t \n\t{0x2e, 0x0020},\t\t \n};\nstatic const struct ucbus_write_cmd mt9v111_start_1[] = {\n\t{0xf5f0, 0x11}, {0xf5f1, 0x96}, {0xf5f2, 0x80}, {0xf5f3, 0x80},\n\t{0xf5f4, 0xaa},\n\t{0xf5f0, 0x51}, {0xf5f1, 0x96}, {0xf5f2, 0x80}, {0xf5f3, 0x80},\n\t{0xf5f4, 0xaa},\n\t{0xf5fa, 0x00}, {0xf5f6, 0x0a}, {0xf5f7, 0x0a}, {0xf5f8, 0x0a},\n\t{0xf5f9, 0x0a}\n};\nstatic const struct i2c_write_cmd mt9v111_init_3[] = {\n\t{0x62, 0x0405},\n};\nstatic const struct i2c_write_cmd mt9v111_init_4[] = {\n \n\t{0x05, 0x005d},\t\t \n};\n\nstatic const struct ucbus_write_cmd ov7660_start_0[] = {\n\t{0x0354, 0x00}, {0x03fa, 0x00}, {0xf332, 0x00}, {0xf333, 0xc0},\n\t{0xf334, 0x39}, {0xf335, 0xe7}, {0xf33f, 0x03}\n};\n\nstatic const struct ucbus_write_cmd ov9630_start_0[] = {\n\t{0x0354, 0x00}, {0x03fa, 0x00}, {0xf332, 0x00}, {0xf333, 0x00},\n\t{0xf334, 0x3e}, {0xf335, 0xf8}, {0xf33f, 0x03}\n};\n\n \nstatic const struct cap_s {\n\tu8\tcc_sizeid;\n\tu8\tcc_bytes[32];\n} capconfig[4][2] = {\n\t[SENSOR_ICX098BQ] = {\n\t\t{2,\t\t\t\t \n\t\t  {0x05, 0x1f, 0x20, 0x0e, 0x00, 0x9f, 0x02, 0xee,\n\t\t   0x01, 0x01, 0x00, 0x08, 0x18, 0x12, 0x78, 0xc8,\n\t\t   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0,\n\t\t   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} },\n\t\t{4,\t\t\t\t \n\t\t  {0x01, 0x1f, 0x20, 0x0e, 0x00, 0x9f, 0x02, 0xee,\n\t\t   0x01, 0x02, 0x00, 0x08, 0x18, 0x12, 0x78, 0xc8,\n\t\t   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} },\n\t},\n\t[SENSOR_LZ24BP] = {\n\t\t{2,\t\t\t\t \n\t\t  {0x05, 0x22, 0x20, 0x0e, 0x00, 0xa2, 0x02, 0xee,\n\t\t   0x01, 0x01, 0x00, 0x08, 0x18, 0x12, 0x78, 0xc8,\n\t\t   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} },\n\t\t{4,\t\t\t\t \n\t\t  {0x01, 0x22, 0x20, 0x0e, 0x00, 0xa2, 0x02, 0xee,\n\t\t   0x01, 0x02, 0x00, 0x08, 0x18, 0x12, 0x78, 0xc8,\n\t\t   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} },\n\t},\n\t[SENSOR_MI0360] = {\n\t\t{2,\t\t\t\t \n\t\t  {0x05, 0x02, 0x20, 0x01, 0x20, 0x82, 0x02, 0xe1,\n\t\t   0x01, 0x01, 0x00, 0x08, 0x18, 0x12, 0x78, 0xc8,\n\t\t   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} },\n\t\t{4,\t\t\t\t \n\t\t  {0x01, 0x02, 0x20, 0x01, 0x20, 0x82, 0x02, 0xe1,\n\t\t   0x01, 0x02, 0x00, 0x08, 0x18, 0x12, 0x78, 0xc8,\n\t\t   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} },\n\t},\n\t[SENSOR_MT9V111] = {\n\t\t{2,\t\t\t\t \n\t\t  {0x05, 0x02, 0x20, 0x01, 0x20, 0x82, 0x02, 0xe1,\n\t\t   0x01, 0x01, 0x00, 0x08, 0x18, 0x12, 0x78, 0xc8,\n\t\t   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} },\n\t\t{4,\t\t\t\t \n\t\t  {0x01, 0x02, 0x20, 0x01, 0x20, 0x82, 0x02, 0xe1,\n\t\t   0x01, 0x02, 0x00, 0x08, 0x18, 0x12, 0x78, 0xc8,\n\t\t   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} },\n\t},\n};\n\nstruct sensor_s {\n\tconst char *name;\n\tu8 i2c_addr;\n\tu8 i2c_dum;\n\tu8 gpio[5];\n\tu8 cmd_len;\n\tconst struct ucbus_write_cmd *cmd;\n};\n\nstatic const struct sensor_s sensor_tb[] = {\n\t[SENSOR_ICX098BQ] = {\n\t\t\"icx098bp\",\n\t\t0x00, 0x00,\n\t\t{0,\n\t\t SQ930_GPIO_DFL_I2C_SDA | SQ930_GPIO_DFL_I2C_SCL,\n\t\t SQ930_GPIO_DFL_I2C_SDA,\n\t\t 0,\n\t\t SQ930_GPIO_RSTBAR\n\t\t},\n\t\t8, icx098bq_start_0\n\t    },\n\t[SENSOR_LZ24BP] = {\n\t\t\"lz24bp\",\n\t\t0x00, 0x00,\n\t\t{0,\n\t\t SQ930_GPIO_DFL_I2C_SDA | SQ930_GPIO_DFL_I2C_SCL,\n\t\t SQ930_GPIO_DFL_I2C_SDA,\n\t\t 0,\n\t\t SQ930_GPIO_RSTBAR\n\t\t},\n\t\t8, lz24bp_start_0\n\t    },\n\t[SENSOR_MI0360] = {\n\t\t\"mi0360\",\n\t\t0x5d, 0x80,\n\t\t{SQ930_GPIO_RSTBAR,\n\t\t SQ930_GPIO_DFL_I2C_SDA | SQ930_GPIO_DFL_I2C_SCL,\n\t\t SQ930_GPIO_DFL_I2C_SDA,\n\t\t 0,\n\t\t 0\n\t\t},\n\t\t7, mi0360_start_0\n\t    },\n\t[SENSOR_MT9V111] = {\n\t\t\"mt9v111\",\n\t\t0x5c, 0x7f,\n\t\t{SQ930_GPIO_RSTBAR,\n\t\t SQ930_GPIO_DFL_I2C_SDA | SQ930_GPIO_DFL_I2C_SCL,\n\t\t SQ930_GPIO_DFL_I2C_SDA,\n\t\t 0,\n\t\t 0\n\t\t},\n\t\t7, mi0360_start_0\n\t    },\n\t[SENSOR_OV7660] = {\n\t\t\"ov7660\",\n\t\t0x21, 0x00,\n\t\t{0,\n\t\t SQ930_GPIO_DFL_I2C_SDA | SQ930_GPIO_DFL_I2C_SCL,\n\t\t SQ930_GPIO_DFL_I2C_SDA,\n\t\t 0,\n\t\t SQ930_GPIO_RSTBAR\n\t\t},\n\t\t7, ov7660_start_0\n\t    },\n\t[SENSOR_OV9630] = {\n\t\t\"ov9630\",\n\t\t0x30, 0x00,\n\t\t{0,\n\t\t SQ930_GPIO_DFL_I2C_SDA | SQ930_GPIO_DFL_I2C_SCL,\n\t\t SQ930_GPIO_DFL_I2C_SDA,\n\t\t 0,\n\t\t SQ930_GPIO_RSTBAR\n\t\t},\n\t\t7, ov9630_start_0\n\t    },\n};\n\nstatic void reg_r(struct gspca_dev *gspca_dev,\n\t\tu16 value, int len)\n{\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tret = usb_control_msg(gspca_dev->dev,\n\t\t\tusb_rcvctrlpipe(gspca_dev->dev, 0),\n\t\t\t0x0c,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tvalue, 0, gspca_dev->usb_buf, len,\n\t\t\t500);\n\tif (ret < 0) {\n\t\tpr_err(\"reg_r %04x failed %d\\n\", value, ret);\n\t\tgspca_dev->usb_err = ret;\n\t\t \n\t\tmemset(gspca_dev->usb_buf, 0, USB_BUF_SZ);\n\t}\n}\n\nstatic void reg_w(struct gspca_dev *gspca_dev, u16 value, u16 index)\n{\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tgspca_dbg(gspca_dev, D_USBO, \"reg_w v: %04x i: %04x\\n\", value, index);\n\tret = usb_control_msg(gspca_dev->dev,\n\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t0x0c,\t\t\t \n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tvalue, index, NULL, 0,\n\t\t\t500);\n\tmsleep(30);\n\tif (ret < 0) {\n\t\tpr_err(\"reg_w %04x %04x failed %d\\n\", value, index, ret);\n\t\tgspca_dev->usb_err = ret;\n\t}\n}\n\nstatic void reg_wb(struct gspca_dev *gspca_dev, u16 value, u16 index,\n\t\tconst u8 *data, int len)\n{\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tgspca_dbg(gspca_dev, D_USBO, \"reg_wb v: %04x i: %04x %02x...%02x\\n\",\n\t\t  value, index, *data, data[len - 1]);\n\tmemcpy(gspca_dev->usb_buf, data, len);\n\tret = usb_control_msg(gspca_dev->dev,\n\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t0x0c,\t\t\t \n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tvalue, index, gspca_dev->usb_buf, len,\n\t\t\t1000);\n\tmsleep(30);\n\tif (ret < 0) {\n\t\tpr_err(\"reg_wb %04x %04x failed %d\\n\", value, index, ret);\n\t\tgspca_dev->usb_err = ret;\n\t}\n}\n\nstatic void i2c_write(struct sd *sd,\n\t\t\tconst struct i2c_write_cmd *cmd,\n\t\t\tint ncmds)\n{\n\tstruct gspca_dev *gspca_dev = &sd->gspca_dev;\n\tconst struct sensor_s *sensor;\n\tu16 val, idx;\n\tu8 *buf;\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\n\tsensor = &sensor_tb[sd->sensor];\n\n\tval = (sensor->i2c_addr << 8) | SQ930_CTRL_I2C_IO;\n\tidx = (cmd->val & 0xff00) | cmd->reg;\n\n\tbuf = gspca_dev->usb_buf;\n\t*buf++ = sensor->i2c_dum;\n\t*buf++ = cmd->val;\n\n\twhile (--ncmds > 0) {\n\t\tcmd++;\n\t\t*buf++ = cmd->reg;\n\t\t*buf++ = cmd->val >> 8;\n\t\t*buf++ = sensor->i2c_dum;\n\t\t*buf++ = cmd->val;\n\t}\n\n\tgspca_dbg(gspca_dev, D_USBO, \"i2c_w v: %04x i: %04x %02x...%02x\\n\",\n\t\t  val, idx, gspca_dev->usb_buf[0], buf[-1]);\n\tret = usb_control_msg(gspca_dev->dev,\n\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t0x0c,\t\t\t \n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tval, idx,\n\t\t\tgspca_dev->usb_buf, buf - gspca_dev->usb_buf,\n\t\t\t500);\n\tif (ret < 0) {\n\t\tpr_err(\"i2c_write failed %d\\n\", ret);\n\t\tgspca_dev->usb_err = ret;\n\t}\n}\n\nstatic void ucbus_write(struct gspca_dev *gspca_dev,\n\t\t\tconst struct ucbus_write_cmd *cmd,\n\t\t\tint ncmds,\n\t\t\tint batchsize)\n{\n\tu8 *buf;\n\tu16 val, idx;\n\tint len, ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\n\tif ((batchsize - 1) * 3 > USB_BUF_SZ) {\n\t\tgspca_err(gspca_dev, \"Bug: usb_buf overflow\\n\");\n\t\tgspca_dev->usb_err = -ENOMEM;\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tlen = ncmds;\n\t\tif (len > batchsize)\n\t\t\tlen = batchsize;\n\t\tncmds -= len;\n\n\t\tval = (cmd->bw_addr << 8) | SQ930_CTRL_UCBUS_IO;\n\t\tidx = (cmd->bw_data << 8) | (cmd->bw_addr >> 8);\n\n\t\tbuf = gspca_dev->usb_buf;\n\t\twhile (--len > 0) {\n\t\t\tcmd++;\n\t\t\t*buf++ = cmd->bw_addr;\n\t\t\t*buf++ = cmd->bw_addr >> 8;\n\t\t\t*buf++ = cmd->bw_data;\n\t\t}\n\t\tif (buf != gspca_dev->usb_buf)\n\t\t\tgspca_dbg(gspca_dev, D_USBO, \"ucbus v: %04x i: %04x %02x...%02x\\n\",\n\t\t\t\t  val, idx,\n\t\t\t\t  gspca_dev->usb_buf[0], buf[-1]);\n\t\telse\n\t\t\tgspca_dbg(gspca_dev, D_USBO, \"ucbus v: %04x i: %04x\\n\",\n\t\t\t\t  val, idx);\n\t\tret = usb_control_msg(gspca_dev->dev,\n\t\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t\t0x0c,\t\t\t \n\t\t\t   USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\tval, idx,\n\t\t\t\tgspca_dev->usb_buf, buf - gspca_dev->usb_buf,\n\t\t\t\t500);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"ucbus_write failed %d\\n\", ret);\n\t\t\tgspca_dev->usb_err = ret;\n\t\t\treturn;\n\t\t}\n\t\tmsleep(30);\n\t\tif (ncmds <= 0)\n\t\t\tbreak;\n\t\tcmd++;\n\t}\n}\n\nstatic void gpio_set(struct sd *sd, u16 val, u16 mask)\n{\n\tstruct gspca_dev *gspca_dev = &sd->gspca_dev;\n\n\tif (mask & 0x00ff) {\n\t\tsd->gpio[0] &= ~mask;\n\t\tsd->gpio[0] |= val;\n\t\treg_w(gspca_dev, 0x0100 | SQ930_CTRL_GPIO,\n\t\t\t~sd->gpio[0] << 8);\n\t}\n\tmask >>= 8;\n\tval >>= 8;\n\tif (mask) {\n\t\tsd->gpio[1] &= ~mask;\n\t\tsd->gpio[1] |= val;\n\t\treg_w(gspca_dev, 0x0300 | SQ930_CTRL_GPIO,\n\t\t\t~sd->gpio[1] << 8);\n\t}\n}\n\nstatic void gpio_init(struct sd *sd,\n\t\t\tconst u8 *gpio)\n{\n\tgpio_set(sd, *gpio++, 0x000f);\n\tgpio_set(sd, *gpio++, 0x000f);\n\tgpio_set(sd, *gpio++, 0x000f);\n\tgpio_set(sd, *gpio++, 0x000f);\n\tgpio_set(sd, *gpio, 0x000f);\n}\n\nstatic void bridge_init(struct sd *sd)\n{\n\tstatic const struct ucbus_write_cmd clkfreq_cmd = {\n\t\t\t\t0xf031, 0\t \n\t};\n\n\tucbus_write(&sd->gspca_dev, &clkfreq_cmd, 1, 1);\n\n\tgpio_set(sd, SQ930_GPIO_POWER, 0xff00);\n}\n\nstatic void cmos_probe(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint i;\n\tconst struct sensor_s *sensor;\n\tstatic const u8 probe_order[] = {\n \n\t\tSENSOR_OV9630,\n\t\tSENSOR_MI0360,\n\t\tSENSOR_OV7660,\n\t\tSENSOR_MT9V111,\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(probe_order); i++) {\n\t\tsensor = &sensor_tb[probe_order[i]];\n\t\tucbus_write(&sd->gspca_dev, sensor->cmd, sensor->cmd_len, 8);\n\t\tgpio_init(sd, sensor->gpio);\n\t\tmsleep(100);\n\t\treg_r(gspca_dev, (sensor->i2c_addr << 8) | 0x001c, 1);\n\t\tmsleep(100);\n\t\tif (gspca_dev->usb_buf[0] != 0)\n\t\t\tbreak;\n\t}\n\tif (i >= ARRAY_SIZE(probe_order)) {\n\t\tpr_err(\"Unknown sensor\\n\");\n\t\tgspca_dev->usb_err = -EINVAL;\n\t\treturn;\n\t}\n\tsd->sensor = probe_order[i];\n\tswitch (sd->sensor) {\n\tcase SENSOR_OV7660:\n\tcase SENSOR_OV9630:\n\t\tpr_err(\"Sensor %s not yet treated\\n\",\n\t\t       sensor_tb[sd->sensor].name);\n\t\tgspca_dev->usb_err = -EINVAL;\n\t\tbreak;\n\t}\n}\n\nstatic void mt9v111_init(struct gspca_dev *gspca_dev)\n{\n\tint i, nwait;\n\tstatic const u8 cmd_001b[] = {\n\t\t0x00, 0x3b, 0xf6, 0x01, 0x03, 0x02, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00\n\t};\n\tstatic const u8 cmd_011b[][7] = {\n\t\t{0x10, 0x01, 0x66, 0x08, 0x00, 0x00, 0x00},\n\t\t{0x01, 0x00, 0x1a, 0x04, 0x00, 0x00, 0x00},\n\t\t{0x20, 0x00, 0x10, 0x04, 0x00, 0x00, 0x00},\n\t\t{0x02, 0x01, 0xae, 0x01, 0x00, 0x00, 0x00},\n\t};\n\n\treg_wb(gspca_dev, 0x001b, 0x0000, cmd_001b, sizeof cmd_001b);\n\tfor (i = 0; i < ARRAY_SIZE(cmd_011b); i++) {\n\t\treg_wb(gspca_dev, 0x001b, 0x0000, cmd_011b[i],\n\t\t\t\tARRAY_SIZE(cmd_011b[0]));\n\t\tmsleep(400);\n\t\tnwait = 20;\n\t\tfor (;;) {\n\t\t\treg_r(gspca_dev, 0x031b, 1);\n\t\t\tif (gspca_dev->usb_buf[0] == 0\n\t\t\t || gspca_dev->usb_err != 0)\n\t\t\t\tbreak;\n\t\t\tif (--nwait < 0) {\n\t\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"mt9v111_init timeout\\n\");\n\t\t\t\tgspca_dev->usb_err = -ETIME;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmsleep(50);\n\t\t}\n\t}\n}\n\nstatic void global_init(struct sd *sd, int first_time)\n{\n\tswitch (sd->sensor) {\n\tcase SENSOR_ICX098BQ:\n\t\tif (first_time)\n\t\t\tucbus_write(&sd->gspca_dev,\n\t\t\t\t\ticx098bq_start_0,\n\t\t\t\t\t8, 8);\n\t\tgpio_init(sd, sensor_tb[sd->sensor].gpio);\n\t\tbreak;\n\tcase SENSOR_LZ24BP:\n\t\tif (sd->type != Creative_live_motion)\n\t\t\tgpio_set(sd, SQ930_GPIO_EXTRA1, 0x00ff);\n\t\telse\n\t\t\tgpio_set(sd, 0, 0x00ff);\n\t\tmsleep(50);\n\t\tif (first_time)\n\t\t\tucbus_write(&sd->gspca_dev,\n\t\t\t\t\tlz24bp_start_0,\n\t\t\t\t\t8, 8);\n\t\tgpio_init(sd, sensor_tb[sd->sensor].gpio);\n\t\tbreak;\n\tcase SENSOR_MI0360:\n\t\tif (first_time)\n\t\t\tucbus_write(&sd->gspca_dev,\n\t\t\t\t\tmi0360_start_0,\n\t\t\t\t\tARRAY_SIZE(mi0360_start_0),\n\t\t\t\t\t8);\n\t\tgpio_init(sd, sensor_tb[sd->sensor].gpio);\n\t\tgpio_set(sd, SQ930_GPIO_EXTRA2, SQ930_GPIO_EXTRA2);\n\t\tbreak;\n\tdefault:\n \n\t\tif (first_time)\n\t\t\tmt9v111_init(&sd->gspca_dev);\n\t\telse\n\t\t\tgpio_init(sd, sensor_tb[sd->sensor].gpio);\n\t\tbreak;\n\t}\n}\n\nstatic void lz24bp_ppl(struct sd *sd, u16 ppl)\n{\n\tstruct ucbus_write_cmd cmds[2] = {\n\t\t{0xf810, ppl >> 8},\n\t\t{0xf811, ppl}\n\t};\n\n\tucbus_write(&sd->gspca_dev, cmds, ARRAY_SIZE(cmds), 2);\n}\n\nstatic void setexposure(struct gspca_dev *gspca_dev, s32 expo, s32 gain)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint i, integclks, intstartclk, frameclks, min_frclk;\n\tconst struct sensor_s *sensor;\n\tu16 cmd;\n\tu8 buf[15];\n\n\tintegclks = expo;\n\ti = 0;\n\tcmd = SQ930_CTRL_SET_EXPOSURE;\n\n\tswitch (sd->sensor) {\n\tcase SENSOR_ICX098BQ:\t\t\t \n\tcase SENSOR_LZ24BP:\n\t\tmin_frclk = sd->sensor == SENSOR_ICX098BQ ? 0x210 : 0x26f;\n\t\tif (integclks >= min_frclk) {\n\t\t\tintstartclk = 0;\n\t\t\tframeclks = integclks;\n\t\t} else {\n\t\t\tintstartclk = min_frclk - integclks;\n\t\t\tframeclks = min_frclk;\n\t\t}\n\t\tbuf[i++] = intstartclk >> 8;\n\t\tbuf[i++] = intstartclk;\n\t\tbuf[i++] = frameclks >> 8;\n\t\tbuf[i++] = frameclks;\n\t\tbuf[i++] = gain;\n\t\tbreak;\n\tdefault:\t\t\t\t \n \n \n\t\tcmd |= 0x0100;\n\t\tsensor = &sensor_tb[sd->sensor];\n\t\tbuf[i++] = sensor->i2c_addr;\t \n\t\tbuf[i++] = 0x08;\t \n\t\tbuf[i++] = 0x09;\t \n\t\tbuf[i++] = integclks >> 8;  \n\t\tbuf[i++] = sensor->i2c_dum;\n\t\tbuf[i++] = integclks;\t \n\t\tbuf[i++] = 0x35;\t \n\t\tbuf[i++] = 0x00;\t \n\t\tbuf[i++] = sensor->i2c_dum;\n\t\tbuf[i++] = 0x80 + gain / 2;  \n\t\tbuf[i++] = 0x00;\n\t\tbuf[i++] = 0x00;\n\t\tbuf[i++] = 0x00;\n\t\tbuf[i++] = 0x00;\n\t\tbuf[i++] = 0x83;\n\t\tbreak;\n\t}\n\treg_wb(gspca_dev, cmd, 0, buf, i);\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam = &gspca_dev->cam;\n\n\tsd->sensor = id->driver_info >> 8;\n\tsd->type = id->driver_info;\n\n\tcam->cam_mode = vga_mode;\n\tcam->nmodes = ARRAY_SIZE(vga_mode);\n\n\tcam->bulk = 1;\n\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tsd->gpio[0] = sd->gpio[1] = 0xff;\t \n\n \n\n\treg_r(gspca_dev, SQ930_CTRL_GET_DEV_INFO, 8);\n\tif (gspca_dev->usb_err < 0)\n\t\treturn gspca_dev->usb_err;\n\n \n\tgspca_dbg(gspca_dev, D_PROBE, \"info: %*ph\\n\", 8, gspca_dev->usb_buf);\n\n\tbridge_init(sd);\n\n\tif (sd->sensor == SENSOR_MI0360) {\n\n\t\t \n\t\tif (gspca_dev->usb_buf[5] == 0xf6)\t \n\t\t\tsd->sensor = SENSOR_ICX098BQ;\n\t\telse\n\t\t\tcmos_probe(gspca_dev);\n\t}\n\tif (gspca_dev->usb_err >= 0) {\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"Sensor %s\\n\",\n\t\t\t  sensor_tb[sd->sensor].name);\n\t\tglobal_init(sd, 1);\n\t}\n\treturn gspca_dev->usb_err;\n}\n\n \nstatic void send_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tconst struct cap_s *cap;\n\tint mode;\n\n\tmode = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\n\tcap = &capconfig[sd->sensor][mode];\n\treg_wb(gspca_dev, 0x0900 | SQ930_CTRL_CAP_START,\n\t\t\t0x0a00 | cap->cc_sizeid,\n\t\t\tcap->cc_bytes, 32);\n}\n\nstatic void send_stop(struct gspca_dev *gspca_dev)\n{\n\treg_w(gspca_dev, SQ930_CTRL_CAP_STOP, 0);\n}\n\n \nstatic int sd_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dev->cam.bulk_nurbs = 1;\t \n\tsd->do_ctrl = 0;\n\tgspca_dev->cam.bulk_size = gspca_dev->pixfmt.width *\n\t\t\tgspca_dev->pixfmt.height + 8;\n\treturn 0;\n}\n\n \nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint mode;\n\n\tbridge_init(sd);\n\tglobal_init(sd, 0);\n\tmsleep(100);\n\n\tswitch (sd->sensor) {\n\tcase SENSOR_ICX098BQ:\n\t\tucbus_write(gspca_dev, icx098bq_start_0,\n\t\t\t\tARRAY_SIZE(icx098bq_start_0),\n\t\t\t\t8);\n\t\tucbus_write(gspca_dev, icx098bq_start_1,\n\t\t\t\tARRAY_SIZE(icx098bq_start_1),\n\t\t\t\t5);\n\t\tucbus_write(gspca_dev, icx098bq_start_2,\n\t\t\t\tARRAY_SIZE(icx098bq_start_2),\n\t\t\t\t6);\n\t\tmsleep(50);\n\n\t\t \n\t\tsend_start(gspca_dev);\n\t\tgpio_set(sd, SQ930_GPIO_EXTRA2 | SQ930_GPIO_RSTBAR, 0x00ff);\n\t\tmsleep(70);\n\t\treg_w(gspca_dev, SQ930_CTRL_CAP_STOP, 0x0000);\n\t\tgpio_set(sd, 0x7f, 0x00ff);\n\n\t\t \n\t\tsend_start(gspca_dev);\n\t\tgpio_set(sd, SQ930_GPIO_EXTRA2 | SQ930_GPIO_RSTBAR, 0x00ff);\n\t\tgoto out;\n\tcase SENSOR_LZ24BP:\n\t\tucbus_write(gspca_dev, lz24bp_start_0,\n\t\t\t\tARRAY_SIZE(lz24bp_start_0),\n\t\t\t\t8);\n\t\tif (sd->type != Creative_live_motion)\n\t\t\tucbus_write(gspca_dev, lz24bp_start_1_gen,\n\t\t\t\t\tARRAY_SIZE(lz24bp_start_1_gen),\n\t\t\t\t\t5);\n\t\telse\n\t\t\tucbus_write(gspca_dev, lz24bp_start_1_clm,\n\t\t\t\t\tARRAY_SIZE(lz24bp_start_1_clm),\n\t\t\t\t\t5);\n\t\tucbus_write(gspca_dev, lz24bp_start_2,\n\t\t\t\tARRAY_SIZE(lz24bp_start_2),\n\t\t\t\t6);\n\t\tmode = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\n\t\tlz24bp_ppl(sd, mode == 1 ? 0x0564 : 0x0310);\n\t\tmsleep(10);\n\t\tbreak;\n\tcase SENSOR_MI0360:\n\t\tucbus_write(gspca_dev, mi0360_start_0,\n\t\t\t\tARRAY_SIZE(mi0360_start_0),\n\t\t\t\t8);\n\t\ti2c_write(sd, mi0360_init_23,\n\t\t\t\tARRAY_SIZE(mi0360_init_23));\n\t\ti2c_write(sd, mi0360_init_24,\n\t\t\t\tARRAY_SIZE(mi0360_init_24));\n\t\ti2c_write(sd, mi0360_init_25,\n\t\t\t\tARRAY_SIZE(mi0360_init_25));\n\t\tucbus_write(gspca_dev, mi0360_start_1,\n\t\t\t\tARRAY_SIZE(mi0360_start_1),\n\t\t\t\t5);\n\t\ti2c_write(sd, mi0360_start_2,\n\t\t\t\tARRAY_SIZE(mi0360_start_2));\n\t\ti2c_write(sd, mi0360_start_3,\n\t\t\t\tARRAY_SIZE(mi0360_start_3));\n\n\t\t \n\t\tsend_start(gspca_dev);\n\t\tmsleep(60);\n\t\tsend_stop(gspca_dev);\n\n\t\ti2c_write(sd,\n\t\t\tmi0360_start_4, ARRAY_SIZE(mi0360_start_4));\n\t\tbreak;\n\tdefault:\n \n\t\tucbus_write(gspca_dev, mi0360_start_0,\n\t\t\t\tARRAY_SIZE(mi0360_start_0),\n\t\t\t\t8);\n\t\ti2c_write(sd, mt9v111_init_0,\n\t\t\t\tARRAY_SIZE(mt9v111_init_0));\n\t\ti2c_write(sd, mt9v111_init_1,\n\t\t\t\tARRAY_SIZE(mt9v111_init_1));\n\t\ti2c_write(sd, mt9v111_init_2,\n\t\t\t\tARRAY_SIZE(mt9v111_init_2));\n\t\tucbus_write(gspca_dev, mt9v111_start_1,\n\t\t\t\tARRAY_SIZE(mt9v111_start_1),\n\t\t\t\t5);\n\t\ti2c_write(sd, mt9v111_init_3,\n\t\t\t\tARRAY_SIZE(mt9v111_init_3));\n\t\ti2c_write(sd, mt9v111_init_4,\n\t\t\t\tARRAY_SIZE(mt9v111_init_4));\n\t\tbreak;\n\t}\n\n\tsend_start(gspca_dev);\nout:\n\tmsleep(1000);\n\n\tif (sd->sensor == SENSOR_MT9V111)\n\t\tgpio_set(sd, SQ930_GPIO_DFL_LED, SQ930_GPIO_DFL_LED);\n\n\tsd->do_ctrl = 1;\t \n\n\treturn gspca_dev->usb_err;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->sensor == SENSOR_MT9V111)\n\t\tgpio_set(sd, 0, SQ930_GPIO_DFL_LED);\n\tsend_stop(gspca_dev);\n}\n\n \n \nstatic void sd_dq_callback(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint ret;\n\n\tif (!sd->do_ctrl || gspca_dev->cam.bulk_nurbs != 0)\n\t\treturn;\n\tsd->do_ctrl = 0;\n\n\tsetexposure(gspca_dev, v4l2_ctrl_g_ctrl(sd->exposure),\n\t\t\tv4l2_ctrl_g_ctrl(sd->gain));\n\n\tgspca_dev->cam.bulk_nurbs = 1;\n\tret = usb_submit_urb(gspca_dev->urb[0], GFP_KERNEL);\n\tif (ret < 0)\n\t\tpr_err(\"sd_dq_callback() err %d\\n\", ret);\n\n\t \n\tmsleep(100);\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t \n\t\t\tint len)\t\t \n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->do_ctrl)\n\t\tgspca_dev->cam.bulk_nurbs = 0;\n\tgspca_frame_add(gspca_dev, FIRST_PACKET, NULL, 0);\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len - 8);\n\tgspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE:\n\t\tsetexposure(gspca_dev, ctrl->val, sd->gain->val);\n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 2);\n\tsd->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE, 1, 0xfff, 1, 0x356);\n\tsd->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, 1, 255, 1, 0x8d);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\tv4l2_ctrl_cluster(2, &sd->exposure);\n\treturn 0;\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name   = MODULE_NAME,\n\t.config = sd_config,\n\t.init   = sd_init,\n\t.init_controls = sd_init_controls,\n\t.isoc_init = sd_isoc_init,\n\t.start  = sd_start,\n\t.stopN  = sd_stopN,\n\t.pkt_scan = sd_pkt_scan,\n\t.dq_callback = sd_dq_callback,\n};\n\n \n#define ST(sensor, type) \\\n\t.driver_info = (SENSOR_ ## sensor << 8) \\\n\t\t\t| (type)\nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x041e, 0x4038), ST(MI0360, 0)},\n\t{USB_DEVICE(0x041e, 0x403c), ST(LZ24BP, 0)},\n\t{USB_DEVICE(0x041e, 0x403d), ST(LZ24BP, 0)},\n\t{USB_DEVICE(0x041e, 0x4041), ST(LZ24BP, Creative_live_motion)},\n\t{USB_DEVICE(0x2770, 0x930b), ST(MI0360, 0)},\n\t{USB_DEVICE(0x2770, 0x930c), ST(MI0360, 0)},\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name\t    = MODULE_NAME,\n\t.id_table   = device_table,\n\t.probe\t    = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend    = gspca_suspend,\n\t.resume     = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}