{
  "module_name": "m5602_mt9m111.c",
  "hash_id": "7259f25d0e602e13c3e10cc71ca28d2ecd981e7c26f49d642fb4f11ab4a12cab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/m5602/m5602_mt9m111.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"m5602_mt9m111.h\"\n\nstatic int mt9m111_s_ctrl(struct v4l2_ctrl *ctrl);\nstatic void mt9m111_dump_registers(struct sd *sd);\n\nstatic const unsigned char preinit_mt9m111[][4] = {\n\t{BRIDGE, M5602_XB_MCU_CLK_DIV, 0x02, 0x00},\n\t{BRIDGE, M5602_XB_MCU_CLK_CTRL, 0xb0, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0, 0x00},\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x0d, 0x00},\n\t{BRIDGE, M5602_XB_SENSOR_CTRL, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_ADC_CTRL, 0xc0, 0x00},\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x09, 0x00},\n\n\t{SENSOR, MT9M111_PAGE_MAP, 0x00, 0x00},\n\t{SENSOR, MT9M111_SC_RESET,\n\t\tMT9M111_RESET |\n\t\tMT9M111_RESTART |\n\t\tMT9M111_ANALOG_STANDBY |\n\t\tMT9M111_CHIP_DISABLE,\n\t\tMT9M111_SHOW_BAD_FRAMES |\n\t\tMT9M111_RESTART_BAD_FRAMES |\n\t\tMT9M111_SYNCHRONIZE_CHANGES},\n\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x05, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x04, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_EN_H, 0x3e, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DIR_H, 0x3e, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DAT_H, 0x02, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_EN_L, 0xff, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DIR_L, 0xff, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DAT_L, 0x00, 0x00},\n\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x07, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x0b, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_EN_H, 0x06, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_EN_L, 0x00, 0x00},\n\n\t{BRIDGE, M5602_XB_I2C_CLK_DIV, 0x0a, 0x00}\n};\n\nstatic const unsigned char init_mt9m111[][4] = {\n\t{BRIDGE, M5602_XB_MCU_CLK_DIV, 0x02, 0x00},\n\t{BRIDGE, M5602_XB_MCU_CLK_CTRL, 0xb0, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0, 0x00},\n\t{BRIDGE, M5602_XB_ADC_CTRL, 0xc0, 0x00},\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x09, 0x00},\n\n\t{BRIDGE, M5602_XB_GPIO_EN_H, 0x06, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_EN_L, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x04, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DIR_H, 0x3e, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DIR_L, 0xff, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DAT_H, 0x02, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DAT_L, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x07, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x0b, 0x00},\n\t{BRIDGE, M5602_XB_I2C_CLK_DIV, 0x0a, 0x00},\n\n\t{SENSOR, MT9M111_SC_RESET, 0x00, 0x29},\n\t{SENSOR, MT9M111_PAGE_MAP, 0x00, 0x00},\n\t{SENSOR, MT9M111_SC_RESET, 0x00, 0x08},\n\t{SENSOR, MT9M111_PAGE_MAP, 0x00, 0x01},\n\t{SENSOR, MT9M111_CP_OPERATING_MODE_CTL, 0x00,\n\t\t\tMT9M111_CP_OPERATING_MODE_CTL},\n\t{SENSOR, MT9M111_CP_LENS_CORRECTION_1, 0x04, 0x2a},\n\t{SENSOR, MT9M111_CP_DEFECT_CORR_CONTEXT_A, 0x00,\n\t\t\t\tMT9M111_2D_DEFECT_CORRECTION_ENABLE},\n\t{SENSOR, MT9M111_CP_DEFECT_CORR_CONTEXT_B, 0x00,\n\t\t\t\tMT9M111_2D_DEFECT_CORRECTION_ENABLE},\n\t{SENSOR, MT9M111_CP_LUMA_OFFSET, 0x00, 0x00},\n\t{SENSOR, MT9M111_CP_LUMA_CLIP, 0xff, 0x00},\n\t{SENSOR, MT9M111_CP_OUTPUT_FORMAT_CTL2_CONTEXT_A, 0x14, 0x00},\n\t{SENSOR, MT9M111_CP_OUTPUT_FORMAT_CTL2_CONTEXT_B, 0x14, 0x00},\n\t{SENSOR, 0xcd, 0x00, 0x0e},\n\t{SENSOR, 0xd0, 0x00, 0x40},\n\n\t{SENSOR, MT9M111_PAGE_MAP, 0x00, 0x02},\n\t{SENSOR, MT9M111_CC_AUTO_EXPOSURE_PARAMETER_18, 0x00, 0x00},\n\t{SENSOR, MT9M111_CC_AWB_PARAMETER_7, 0xef, 0x03},\n\n\t{SENSOR, MT9M111_PAGE_MAP, 0x00, 0x00},\n\t{SENSOR, 0x33, 0x03, 0x49},\n\t{SENSOR, 0x34, 0xc0, 0x19},\n\t{SENSOR, 0x3f, 0x20, 0x20},\n\t{SENSOR, 0x40, 0x20, 0x20},\n\t{SENSOR, 0x5a, 0xc0, 0x0a},\n\t{SENSOR, 0x70, 0x7b, 0x0a},\n\t{SENSOR, 0x71, 0xff, 0x00},\n\t{SENSOR, 0x72, 0x19, 0x0e},\n\t{SENSOR, 0x73, 0x18, 0x0f},\n\t{SENSOR, 0x74, 0x57, 0x32},\n\t{SENSOR, 0x75, 0x56, 0x34},\n\t{SENSOR, 0x76, 0x73, 0x35},\n\t{SENSOR, 0x77, 0x30, 0x12},\n\t{SENSOR, 0x78, 0x79, 0x02},\n\t{SENSOR, 0x79, 0x75, 0x06},\n\t{SENSOR, 0x7a, 0x77, 0x0a},\n\t{SENSOR, 0x7b, 0x78, 0x09},\n\t{SENSOR, 0x7c, 0x7d, 0x06},\n\t{SENSOR, 0x7d, 0x31, 0x10},\n\t{SENSOR, 0x7e, 0x00, 0x7e},\n\t{SENSOR, 0x80, 0x59, 0x04},\n\t{SENSOR, 0x81, 0x59, 0x04},\n\t{SENSOR, 0x82, 0x57, 0x0a},\n\t{SENSOR, 0x83, 0x58, 0x0b},\n\t{SENSOR, 0x84, 0x47, 0x0c},\n\t{SENSOR, 0x85, 0x48, 0x0e},\n\t{SENSOR, 0x86, 0x5b, 0x02},\n\t{SENSOR, 0x87, 0x00, 0x5c},\n\t{SENSOR, MT9M111_CONTEXT_CONTROL, 0x00, MT9M111_SEL_CONTEXT_B},\n\t{SENSOR, 0x60, 0x00, 0x80},\n\t{SENSOR, 0x61, 0x00, 0x00},\n\t{SENSOR, 0x62, 0x00, 0x00},\n\t{SENSOR, 0x63, 0x00, 0x00},\n\t{SENSOR, 0x64, 0x00, 0x00},\n\n\t{SENSOR, MT9M111_SC_ROWSTART, 0x00, 0x0d},  \n\t{SENSOR, MT9M111_SC_COLSTART, 0x00, 0x12},  \n\t{SENSOR, MT9M111_SC_WINDOW_HEIGHT, 0x04, 0x00},  \n\t{SENSOR, MT9M111_SC_WINDOW_WIDTH, 0x05, 0x10},  \n\t{SENSOR, MT9M111_SC_HBLANK_CONTEXT_B, 0x01, 0x60},  \n\t{SENSOR, MT9M111_SC_VBLANK_CONTEXT_B, 0x00, 0x11},  \n\t{SENSOR, MT9M111_SC_HBLANK_CONTEXT_A, 0x01, 0x60},  \n\t{SENSOR, MT9M111_SC_VBLANK_CONTEXT_A, 0x00, 0x11},  \n\t{SENSOR, MT9M111_SC_R_MODE_CONTEXT_A, 0x01, 0x0f},  \n\t{SENSOR, 0x30, 0x04, 0x00},\n\t \n\t{SENSOR, MT9M111_SC_SHUTTER_WIDTH, 0x01, 0x90},\n};\n\nstatic const unsigned char start_mt9m111[][4] = {\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x06, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0, 0x00},\n\t{BRIDGE, M5602_XB_ADC_CTRL, 0xc0, 0x00},\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x09, 0x00},\n\t{BRIDGE, M5602_XB_LINE_OF_FRAME_H, 0x81, 0x00},\n\t{BRIDGE, M5602_XB_PIX_OF_LINE_H, 0x82, 0x00},\n\t{BRIDGE, M5602_XB_SIG_INI, 0x01, 0x00},\n\t{BRIDGE, M5602_XB_VSYNC_PARA, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_VSYNC_PARA, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_VSYNC_PARA, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_VSYNC_PARA, 0x00, 0x00},\n};\n\nstatic struct v4l2_pix_format mt9m111_modes[] = {\n\t{\n\t\t640,\n\t\t480,\n\t\tV4L2_PIX_FMT_SBGGR8,\n\t\tV4L2_FIELD_NONE,\n\t\t.sizeimage = 640 * 480,\n\t\t.bytesperline = 640,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0\n\t}\n};\n\nstatic const struct v4l2_ctrl_ops mt9m111_ctrl_ops = {\n\t.s_ctrl = mt9m111_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config mt9m111_greenbal_cfg = {\n\t.ops\t= &mt9m111_ctrl_ops,\n\t.id\t= M5602_V4L2_CID_GREEN_BALANCE,\n\t.name\t= \"Green Balance\",\n\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t.min\t= 0,\n\t.max\t= 0x7ff,\n\t.step\t= 1,\n\t.def\t= MT9M111_GREEN_GAIN_DEFAULT,\n\t.flags\t= V4L2_CTRL_FLAG_SLIDER,\n};\n\nint mt9m111_probe(struct sd *sd)\n{\n\tu8 data[2] = {0x00, 0x00};\n\tint i, err;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tif (force_sensor) {\n\t\tif (force_sensor == MT9M111_SENSOR) {\n\t\t\tpr_info(\"Forcing a %s sensor\\n\", mt9m111.name);\n\t\t\tgoto sensor_found;\n\t\t}\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"Probing for a mt9m111 sensor\\n\");\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(preinit_mt9m111); i++) {\n\t\tif (preinit_mt9m111[i][0] == BRIDGE) {\n\t\t\terr = m5602_write_bridge(sd,\n\t\t\t\t\tpreinit_mt9m111[i][1],\n\t\t\t\t\tpreinit_mt9m111[i][2]);\n\t\t} else {\n\t\t\tdata[0] = preinit_mt9m111[i][2];\n\t\t\tdata[1] = preinit_mt9m111[i][3];\n\t\t\terr = m5602_write_sensor(sd,\n\t\t\t\t\tpreinit_mt9m111[i][1], data, 2);\n\t\t}\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (m5602_read_sensor(sd, MT9M111_SC_CHIPVER, data, 2))\n\t\treturn -ENODEV;\n\n\tif ((data[0] == 0x14) && (data[1] == 0x3a)) {\n\t\tpr_info(\"Detected a mt9m111 sensor\\n\");\n\t\tgoto sensor_found;\n\t}\n\n\treturn -ENODEV;\n\nsensor_found:\n\tsd->gspca_dev.cam.cam_mode = mt9m111_modes;\n\tsd->gspca_dev.cam.nmodes = ARRAY_SIZE(mt9m111_modes);\n\n\treturn 0;\n}\n\nint mt9m111_init(struct sd *sd)\n{\n\tint i, err = 0;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(init_mt9m111) && !err; i++) {\n\t\tu8 data[2];\n\n\t\tif (init_mt9m111[i][0] == BRIDGE) {\n\t\t\terr = m5602_write_bridge(sd,\n\t\t\t\tinit_mt9m111[i][1],\n\t\t\t\tinit_mt9m111[i][2]);\n\t\t} else {\n\t\t\tdata[0] = init_mt9m111[i][2];\n\t\t\tdata[1] = init_mt9m111[i][3];\n\t\t\terr = m5602_write_sensor(sd,\n\t\t\t\tinit_mt9m111[i][1], data, 2);\n\t\t}\n\t}\n\n\tif (dump_sensor)\n\t\tmt9m111_dump_registers(sd);\n\n\treturn 0;\n}\n\nint mt9m111_init_controls(struct sd *sd)\n{\n\tstruct v4l2_ctrl_handler *hdl = &sd->gspca_dev.ctrl_handler;\n\n\tsd->gspca_dev.vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 7);\n\n\tsd->auto_white_bal = v4l2_ctrl_new_std(hdl, &mt9m111_ctrl_ops,\n\t\t\t\t\t       V4L2_CID_AUTO_WHITE_BALANCE,\n\t\t\t\t\t       0, 1, 1, 0);\n\tsd->green_bal = v4l2_ctrl_new_custom(hdl, &mt9m111_greenbal_cfg, NULL);\n\tsd->red_bal = v4l2_ctrl_new_std(hdl, &mt9m111_ctrl_ops,\n\t\t\t\t\tV4L2_CID_RED_BALANCE, 0, 0x7ff, 1,\n\t\t\t\t\tMT9M111_RED_GAIN_DEFAULT);\n\tsd->blue_bal = v4l2_ctrl_new_std(hdl, &mt9m111_ctrl_ops,\n\t\t\t\t\tV4L2_CID_BLUE_BALANCE, 0, 0x7ff, 1,\n\t\t\t\t\tMT9M111_BLUE_GAIN_DEFAULT);\n\n\tv4l2_ctrl_new_std(hdl, &mt9m111_ctrl_ops, V4L2_CID_GAIN, 0,\n\t\t\t  (INITIAL_MAX_GAIN - 1) * 2 * 2 * 2, 1,\n\t\t\t  MT9M111_DEFAULT_GAIN);\n\n\tsd->hflip = v4l2_ctrl_new_std(hdl, &mt9m111_ctrl_ops, V4L2_CID_HFLIP,\n\t\t\t\t      0, 1, 1, 0);\n\tsd->vflip = v4l2_ctrl_new_std(hdl, &mt9m111_ctrl_ops, V4L2_CID_VFLIP,\n\t\t\t\t      0, 1, 1, 0);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\n\tv4l2_ctrl_auto_cluster(4, &sd->auto_white_bal, 0, false);\n\tv4l2_ctrl_cluster(2, &sd->hflip);\n\n\treturn 0;\n}\n\nint mt9m111_start(struct sd *sd)\n{\n\tint i, err = 0;\n\tu8 data[2];\n\tstruct cam *cam = &sd->gspca_dev.cam;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tint width = cam->cam_mode[sd->gspca_dev.curr_mode].width - 1;\n\tint height = cam->cam_mode[sd->gspca_dev.curr_mode].height;\n\n\tfor (i = 0; i < ARRAY_SIZE(start_mt9m111) && !err; i++) {\n\t\tif (start_mt9m111[i][0] == BRIDGE) {\n\t\t\terr = m5602_write_bridge(sd,\n\t\t\t\tstart_mt9m111[i][1],\n\t\t\t\tstart_mt9m111[i][2]);\n\t\t} else {\n\t\t\tdata[0] = start_mt9m111[i][2];\n\t\t\tdata[1] = start_mt9m111[i][3];\n\t\t\terr = m5602_write_sensor(sd,\n\t\t\t\tstart_mt9m111[i][1], data, 2);\n\t\t}\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, (height >> 8) & 0xff);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, (height & 0xff));\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < 2 && !err; i++)\n\t\terr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_SIG_INI, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_SIG_INI, 2);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < 2 && !err; i++)\n\t\terr = m5602_write_bridge(sd, M5602_XB_HSYNC_PARA, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_HSYNC_PARA,\n\t\t\t\t (width >> 8) & 0xff);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_HSYNC_PARA, width & 0xff);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_SIG_INI, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (width) {\n\tcase 640:\n\t\tgspca_dbg(gspca_dev, D_CONF, \"Configuring camera for VGA mode\\n\");\n\t\tbreak;\n\n\tcase 320:\n\t\tgspca_dbg(gspca_dev, D_CONF, \"Configuring camera for QVGA mode\\n\");\n\t\tbreak;\n\t}\n\treturn err;\n}\n\nvoid mt9m111_disconnect(struct sd *sd)\n{\n\tsd->sensor = NULL;\n}\n\nstatic int mt9m111_set_hvflip(struct gspca_dev *gspca_dev)\n{\n\tint err;\n\tu8 data[2] = {0x00, 0x00};\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint hflip;\n\tint vflip;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set hvflip to %d %d\\n\",\n\t\t  sd->hflip->val, sd->vflip->val);\n\n\t \n\thflip = !sd->hflip->val;\n\tvflip = !sd->vflip->val;\n\n\t \n\terr = m5602_write_sensor(sd, MT9M111_PAGE_MAP, data, 2);\n\tif (err < 0)\n\t\treturn err;\n\n\tdata[0] = MT9M111_RMB_OVER_SIZED;\n\tif (gspca_dev->pixfmt.width == 640) {\n\t\tdata[1] = MT9M111_RMB_ROW_SKIP_2X |\n\t\t\t  MT9M111_RMB_COLUMN_SKIP_2X |\n\t\t\t  (hflip << 1) | vflip;\n\t} else {\n\t\tdata[1] = MT9M111_RMB_ROW_SKIP_4X |\n\t\t\t  MT9M111_RMB_COLUMN_SKIP_4X |\n\t\t\t  (hflip << 1) | vflip;\n\t}\n\terr = m5602_write_sensor(sd, MT9M111_SC_R_MODE_CONTEXT_B,\n\t\t\t\t\tdata, 2);\n\treturn err;\n}\n\nstatic int mt9m111_set_auto_white_balance(struct gspca_dev *gspca_dev,\n\t\t\t\t\t  __s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint err;\n\tu8 data[2];\n\n\terr = m5602_read_sensor(sd, MT9M111_CP_OPERATING_MODE_CTL, data, 2);\n\tif (err < 0)\n\t\treturn err;\n\n\tdata[1] = ((data[1] & 0xfd) | ((val & 0x01) << 1));\n\n\terr = m5602_write_sensor(sd, MT9M111_CP_OPERATING_MODE_CTL, data, 2);\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set auto white balance %d\\n\", val);\n\treturn err;\n}\n\nstatic int mt9m111_set_gain(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err, tmp;\n\tu8 data[2] = {0x00, 0x00};\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t \n\terr = m5602_write_sensor(sd, MT9M111_PAGE_MAP, data, 2);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (val >= INITIAL_MAX_GAIN * 2 * 2 * 2)\n\t\treturn -EINVAL;\n\n\tif ((val >= INITIAL_MAX_GAIN * 2 * 2) &&\n\t    (val < (INITIAL_MAX_GAIN - 1) * 2 * 2 * 2))\n\t\ttmp = (1 << 10) | (val << 9) |\n\t\t\t\t(val << 8) | (val / 8);\n\telse if ((val >= INITIAL_MAX_GAIN * 2) &&\n\t\t (val <  INITIAL_MAX_GAIN * 2 * 2))\n\t\ttmp = (1 << 9) | (1 << 8) | (val / 4);\n\telse if ((val >= INITIAL_MAX_GAIN) &&\n\t\t (val < INITIAL_MAX_GAIN * 2))\n\t\ttmp = (1 << 8) | (val / 2);\n\telse\n\t\ttmp = val;\n\n\tdata[1] = (tmp & 0xff);\n\tdata[0] = (tmp & 0xff00) >> 8;\n\tgspca_dbg(gspca_dev, D_CONF, \"tmp=%d, data[1]=%d, data[0]=%d\\n\", tmp,\n\t\t  data[1], data[0]);\n\n\terr = m5602_write_sensor(sd, MT9M111_SC_GLOBAL_GAIN,\n\t\t\t\t   data, 2);\n\n\treturn err;\n}\n\nstatic int mt9m111_set_green_balance(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tu8 data[2];\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tdata[1] = (val & 0xff);\n\tdata[0] = (val & 0xff00) >> 8;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set green balance %d\\n\", val);\n\terr = m5602_write_sensor(sd, MT9M111_SC_GREEN_1_GAIN,\n\t\t\t\t data, 2);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn m5602_write_sensor(sd, MT9M111_SC_GREEN_2_GAIN,\n\t\t\t\t  data, 2);\n}\n\nstatic int mt9m111_set_blue_balance(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tu8 data[2];\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tdata[1] = (val & 0xff);\n\tdata[0] = (val & 0xff00) >> 8;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set blue balance %d\\n\", val);\n\n\treturn m5602_write_sensor(sd, MT9M111_SC_BLUE_GAIN,\n\t\t\t\t  data, 2);\n}\n\nstatic int mt9m111_set_red_balance(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tu8 data[2];\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tdata[1] = (val & 0xff);\n\tdata[0] = (val & 0xff00) >> 8;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set red balance %d\\n\", val);\n\n\treturn m5602_write_sensor(sd, MT9M111_SC_RED_GAIN,\n\t\t\t\t  data, 2);\n}\n\nstatic int mt9m111_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint err;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\terr = mt9m111_set_auto_white_balance(gspca_dev, ctrl->val);\n\t\tif (err || ctrl->val)\n\t\t\treturn err;\n\t\terr = mt9m111_set_green_balance(gspca_dev, sd->green_bal->val);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = mt9m111_set_red_balance(gspca_dev, sd->red_bal->val);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = mt9m111_set_blue_balance(gspca_dev, sd->blue_bal->val);\n\t\tbreak;\n\tcase V4L2_CID_GAIN:\n\t\terr = mt9m111_set_gain(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\terr = mt9m111_set_hvflip(gspca_dev);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic void mt9m111_dump_registers(struct sd *sd)\n{\n\tu8 address, value[2] = {0x00, 0x00};\n\n\tpr_info(\"Dumping the mt9m111 register state\\n\");\n\n\tpr_info(\"Dumping the mt9m111 sensor core registers\\n\");\n\tvalue[1] = MT9M111_SENSOR_CORE;\n\tm5602_write_sensor(sd, MT9M111_PAGE_MAP, value, 2);\n\tfor (address = 0; address < 0xff; address++) {\n\t\tm5602_read_sensor(sd, address, value, 2);\n\t\tpr_info(\"register 0x%x contains 0x%x%x\\n\",\n\t\t\taddress, value[0], value[1]);\n\t}\n\n\tpr_info(\"Dumping the mt9m111 color pipeline registers\\n\");\n\tvalue[1] = MT9M111_COLORPIPE;\n\tm5602_write_sensor(sd, MT9M111_PAGE_MAP, value, 2);\n\tfor (address = 0; address < 0xff; address++) {\n\t\tm5602_read_sensor(sd, address, value, 2);\n\t\tpr_info(\"register 0x%x contains 0x%x%x\\n\",\n\t\t\taddress, value[0], value[1]);\n\t}\n\n\tpr_info(\"Dumping the mt9m111 camera control registers\\n\");\n\tvalue[1] = MT9M111_CAMERA_CONTROL;\n\tm5602_write_sensor(sd, MT9M111_PAGE_MAP, value, 2);\n\tfor (address = 0; address < 0xff; address++) {\n\t\tm5602_read_sensor(sd, address, value, 2);\n\t\tpr_info(\"register 0x%x contains 0x%x%x\\n\",\n\t\t\taddress, value[0], value[1]);\n\t}\n\n\tpr_info(\"mt9m111 register state dump complete\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}