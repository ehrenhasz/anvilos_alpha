{
  "module_name": "m5602_ov9650.c",
  "hash_id": "13b41a9bc19b021fc0f75c3cf874db3588087bdc660093ae24c9b9f9327f9876",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/m5602/m5602_ov9650.c",
  "human_readable_source": "\n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"m5602_ov9650.h\"\n\nstatic int ov9650_s_ctrl(struct v4l2_ctrl *ctrl);\nstatic void ov9650_dump_registers(struct sd *sd);\n\nstatic const unsigned char preinit_ov9650[][3] = {\n\t \n\t{BRIDGE, M5602_XB_MCU_CLK_DIV, 0x02},\n\t{BRIDGE, M5602_XB_MCU_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_ADC_CTRL, 0xc0},\n\t{BRIDGE, M5602_XB_SENSOR_CTRL, 0x00},\n\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x08},\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x05},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x04},\n\t{BRIDGE, M5602_XB_GPIO_EN_H, 0x06},\n\t{BRIDGE, M5602_XB_GPIO_DIR_H, 0x06},\n\t{BRIDGE, M5602_XB_GPIO_DAT_H, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x00},\n\t{BRIDGE, M5602_XB_I2C_CLK_DIV, 0x0a},\n\t \n\t{SENSOR, OV9650_COM7, OV9650_REGISTER_RESET},\n\t \n\t{SENSOR, OV9650_CLKRC, 0x80},\n\t \n\t{SENSOR, OV9650_OFON, 0x40}\n};\n\nstatic const unsigned char init_ov9650[][3] = {\n\t \n\t{BRIDGE, M5602_XB_MCU_CLK_DIV, 0x02},\n\t{BRIDGE, M5602_XB_MCU_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_ADC_CTRL, 0xc0},\n\t{BRIDGE, M5602_XB_SENSOR_CTRL, 0x00},\n\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x08},\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x05},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x04},\n\t{BRIDGE, M5602_XB_GPIO_EN_H, 0x06},\n\t{BRIDGE, M5602_XB_GPIO_DIR_H, 0x06},\n\t{BRIDGE, M5602_XB_GPIO_DAT_H, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x00},\n\t{BRIDGE, M5602_XB_I2C_CLK_DIV, 0x0a},\n\n\t \n\t{SENSOR, OV9650_COM7, OV9650_REGISTER_RESET},\n\t \n\t{SENSOR, OV9650_COM7, OV9650_REGISTER_RESET},\n\n\t \n\t{SENSOR, OV9650_CLKRC, 0x80},\n\t \n\t{SENSOR, OV9650_OFON, 0x40},\n\n\t \n\t{SENSOR, OV9650_COM8, OV9650_FAST_AGC_AEC |\n\t\t\t      OV9650_AEC_UNLIM_STEP_SIZE},\n\n\t{SENSOR, OV9650_CHLF, 0x10},\n\t{SENSOR, OV9650_ARBLM, 0xbf},\n\t{SENSOR, OV9650_ACOM38, 0x81},\n\t \n\t{SENSOR, OV9650_COM16, 0x00},\n\t \n\t{SENSOR, OV9650_COM13, 0x19},\n\t \n\t{SENSOR, OV9650_TSLB, 0x0c},\n\t \n\t{SENSOR, OV9650_COM24, 0x00},\n\t \n\t{SENSOR, OV9650_COM12, 0x73},\n\t \n\t{SENSOR, OV9650_DBLC1, 0xdf},\n\t{SENSOR, OV9650_COM21, 0x06},\n\t{SENSOR, OV9650_RSVD35, 0x91},\n\t \n\t{SENSOR, OV9650_RSVD16, 0x06},\n\t{SENSOR, OV9650_RSVD94, 0x99},\n\t{SENSOR, OV9650_RSVD95, 0x99},\n\t{SENSOR, OV9650_RSVD96, 0x04},\n\t \n\t{SENSOR, OV9650_COM15, 0x0},\n\t \n\t{SENSOR, OV9650_COM6, 0x4b},\n\t \n\t{SENSOR, OV9650_BBIAS, 0xa0},\n\t \n\t{SENSOR, OV9650_GbBIAS, 0xa0},\n\t \n\t{SENSOR, OV9650_Gr_COM, 0x00},\n\t \n\t{SENSOR, OV9650_RBIAS, 0xa0},\n\t \n\t{SENSOR, OV9650_RBIAS, 0x0},\n\t{SENSOR, OV9650_COM26, 0x80},\n\t{SENSOR, OV9650_ACOMA9, 0x98},\n\t \n\t{SENSOR, OV9650_AEW, 0x68},\n\t \n\t{SENSOR, OV9650_AEB, 0x5c},\n\t \n\t{SENSOR, OV9650_VPT, 0xc3},\n\t \n\t{SENSOR, OV9650_COM9, 0x6e},\n\t \n\t{SENSOR, OV9650_COM10, 0x42},\n\t \n\t{SENSOR, OV9650_HSTART, 0x1a},  \n\t \n\t{SENSOR, OV9650_HSTOP, 0xbf},  \n\t \n\t{SENSOR, OV9650_HREF, 0xb2},\n\t \n\t{SENSOR, OV9650_VSTRT, 0x02},\n\t \n\t{SENSOR, OV9650_VSTOP, 0x7e},\n\t \n\t{SENSOR, OV9650_VREF, 0x10},\n\t{SENSOR, OV9650_ADC, 0x04},\n\t{SENSOR, OV9650_HV, 0x40},\n\n\t \n\t{SENSOR, OV9650_COM22, OV9650_DENOISE_ENABLE |\n\t\t OV9650_WHITE_PIXEL_ENABLE |\n\t\t OV9650_WHITE_PIXEL_OPTION},\n\n\t \n\t{SENSOR, OV9650_COM3, OV9650_VARIOPIXEL},\n\t{SENSOR, OV9650_COM4, OV9650_QVGA_VARIOPIXEL},\n\n\t \n\t{SENSOR, OV9650_COM2, OV9650_SOFT_SLEEP | OV9650_OUTPUT_DRIVE_2X},\n};\n\nstatic const unsigned char res_init_ov9650[][3] = {\n\t{SENSOR, OV9650_COM2, OV9650_OUTPUT_DRIVE_2X},\n\n\t{BRIDGE, M5602_XB_LINE_OF_FRAME_H, 0x82},\n\t{BRIDGE, M5602_XB_LINE_OF_FRAME_L, 0x00},\n\t{BRIDGE, M5602_XB_PIX_OF_LINE_H, 0x82},\n\t{BRIDGE, M5602_XB_PIX_OF_LINE_L, 0x00},\n\t{BRIDGE, M5602_XB_SIG_INI, 0x01}\n};\n\n \nstatic\n    const\n\tstruct dmi_system_id ov9650_flip_dmi_table[] = {\n\t{\n\t\t.ident = \"ASUS A6Ja\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK Computer Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"A6J\")\n\t\t}\n\t},\n\t{\n\t\t.ident = \"ASUS A6JC\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK Computer Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"A6JC\")\n\t\t}\n\t},\n\t{\n\t\t.ident = \"ASUS A6K\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK Computer Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"A6K\")\n\t\t}\n\t},\n\t{\n\t\t.ident = \"ASUS A6Kt\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK Computer Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"A6Kt\")\n\t\t}\n\t},\n\t{\n\t\t.ident = \"ASUS A6VA\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK Computer Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"A6VA\")\n\t\t}\n\t},\n\t{\n\n\t\t.ident = \"ASUS A6VC\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK Computer Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"A6VC\")\n\t\t}\n\t},\n\t{\n\t\t.ident = \"ASUS A6VM\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK Computer Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"A6VM\")\n\t\t}\n\t},\n\t{\n\t\t.ident = \"ASUS A7V\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK Computer Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"A7V\")\n\t\t}\n\t},\n\t{\n\t\t.ident = \"Alienware Aurora m9700\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"alienware\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aurora m9700\")\n\t\t}\n\t},\n\t{}\n};\n\nstatic struct v4l2_pix_format ov9650_modes[] = {\n\t{\n\t\t176,\n\t\t144,\n\t\tV4L2_PIX_FMT_SBGGR8,\n\t\tV4L2_FIELD_NONE,\n\t\t.sizeimage =\n\t\t\t176 * 144,\n\t\t.bytesperline = 176,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 9\n\t}, {\n\t\t320,\n\t\t240,\n\t\tV4L2_PIX_FMT_SBGGR8,\n\t\tV4L2_FIELD_NONE,\n\t\t.sizeimage =\n\t\t\t320 * 240,\n\t\t.bytesperline = 320,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 8\n\t}, {\n\t\t352,\n\t\t288,\n\t\tV4L2_PIX_FMT_SBGGR8,\n\t\tV4L2_FIELD_NONE,\n\t\t.sizeimage =\n\t\t\t352 * 288,\n\t\t.bytesperline = 352,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 9\n\t}, {\n\t\t640,\n\t\t480,\n\t\tV4L2_PIX_FMT_SBGGR8,\n\t\tV4L2_FIELD_NONE,\n\t\t.sizeimage =\n\t\t\t640 * 480,\n\t\t.bytesperline = 640,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 9\n\t}\n};\n\nstatic const struct v4l2_ctrl_ops ov9650_ctrl_ops = {\n\t.s_ctrl = ov9650_s_ctrl,\n};\n\nint ov9650_probe(struct sd *sd)\n{\n\tint err = 0;\n\tu8 prod_id = 0, ver_id = 0, i;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tif (force_sensor) {\n\t\tif (force_sensor == OV9650_SENSOR) {\n\t\t\tpr_info(\"Forcing an %s sensor\\n\", ov9650.name);\n\t\t\tgoto sensor_found;\n\t\t}\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"Probing for an ov9650 sensor\\n\");\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(preinit_ov9650) && !err; i++) {\n\t\tu8 data = preinit_ov9650[i][2];\n\t\tif (preinit_ov9650[i][0] == SENSOR)\n\t\t\terr = m5602_write_sensor(sd,\n\t\t\t\tpreinit_ov9650[i][1], &data, 1);\n\t\telse\n\t\t\terr = m5602_write_bridge(sd,\n\t\t\t\tpreinit_ov9650[i][1], data);\n\t}\n\n\tif (err < 0)\n\t\treturn err;\n\n\tif (m5602_read_sensor(sd, OV9650_PID, &prod_id, 1))\n\t\treturn -ENODEV;\n\n\tif (m5602_read_sensor(sd, OV9650_VER, &ver_id, 1))\n\t\treturn -ENODEV;\n\n\tif ((prod_id == 0x96) && (ver_id == 0x52)) {\n\t\tpr_info(\"Detected an ov9650 sensor\\n\");\n\t\tgoto sensor_found;\n\t}\n\treturn -ENODEV;\n\nsensor_found:\n\tsd->gspca_dev.cam.cam_mode = ov9650_modes;\n\tsd->gspca_dev.cam.nmodes = ARRAY_SIZE(ov9650_modes);\n\n\treturn 0;\n}\n\nint ov9650_init(struct sd *sd)\n{\n\tint i, err = 0;\n\tu8 data;\n\n\tif (dump_sensor)\n\t\tov9650_dump_registers(sd);\n\n\tfor (i = 0; i < ARRAY_SIZE(init_ov9650) && !err; i++) {\n\t\tdata = init_ov9650[i][2];\n\t\tif (init_ov9650[i][0] == SENSOR)\n\t\t\terr = m5602_write_sensor(sd, init_ov9650[i][1],\n\t\t\t\t\t\t  &data, 1);\n\t\telse\n\t\t\terr = m5602_write_bridge(sd, init_ov9650[i][1], data);\n\t}\n\n\treturn 0;\n}\n\nint ov9650_init_controls(struct sd *sd)\n{\n\tstruct v4l2_ctrl_handler *hdl = &sd->gspca_dev.ctrl_handler;\n\n\tsd->gspca_dev.vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 9);\n\n\tsd->auto_white_bal = v4l2_ctrl_new_std(hdl, &ov9650_ctrl_ops,\n\t\t\t\t\t       V4L2_CID_AUTO_WHITE_BALANCE,\n\t\t\t\t\t       0, 1, 1, 1);\n\tsd->red_bal = v4l2_ctrl_new_std(hdl, &ov9650_ctrl_ops,\n\t\t\t\t\tV4L2_CID_RED_BALANCE, 0, 255, 1,\n\t\t\t\t\tRED_GAIN_DEFAULT);\n\tsd->blue_bal = v4l2_ctrl_new_std(hdl, &ov9650_ctrl_ops,\n\t\t\t\t\tV4L2_CID_BLUE_BALANCE, 0, 255, 1,\n\t\t\t\t\tBLUE_GAIN_DEFAULT);\n\n\tsd->autoexpo = v4l2_ctrl_new_std_menu(hdl, &ov9650_ctrl_ops,\n\t\t\t  V4L2_CID_EXPOSURE_AUTO, 1, 0, V4L2_EXPOSURE_AUTO);\n\tsd->expo = v4l2_ctrl_new_std(hdl, &ov9650_ctrl_ops, V4L2_CID_EXPOSURE,\n\t\t\t  0, 0x1ff, 4, EXPOSURE_DEFAULT);\n\n\tsd->autogain = v4l2_ctrl_new_std(hdl, &ov9650_ctrl_ops,\n\t\t\t\t\t V4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\tsd->gain = v4l2_ctrl_new_std(hdl, &ov9650_ctrl_ops, V4L2_CID_GAIN, 0,\n\t\t\t\t     0x3ff, 1, GAIN_DEFAULT);\n\n\tsd->hflip = v4l2_ctrl_new_std(hdl, &ov9650_ctrl_ops, V4L2_CID_HFLIP,\n\t\t\t\t      0, 1, 1, 0);\n\tsd->vflip = v4l2_ctrl_new_std(hdl, &ov9650_ctrl_ops, V4L2_CID_VFLIP,\n\t\t\t\t      0, 1, 1, 0);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\n\tv4l2_ctrl_auto_cluster(3, &sd->auto_white_bal, 0, false);\n\tv4l2_ctrl_auto_cluster(2, &sd->autoexpo, 0, false);\n\tv4l2_ctrl_auto_cluster(2, &sd->autogain, 0, false);\n\tv4l2_ctrl_cluster(2, &sd->hflip);\n\n\treturn 0;\n}\n\nint ov9650_start(struct sd *sd)\n{\n\tu8 data;\n\tint i, err = 0;\n\tstruct cam *cam = &sd->gspca_dev.cam;\n\n\tint width = cam->cam_mode[sd->gspca_dev.curr_mode].width;\n\tint height = cam->cam_mode[sd->gspca_dev.curr_mode].height;\n\tint ver_offs = cam->cam_mode[sd->gspca_dev.curr_mode].priv;\n\tint hor_offs = OV9650_LEFT_OFFSET;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tif ((!dmi_check_system(ov9650_flip_dmi_table) &&\n\t\tsd->vflip->val) ||\n\t\t(dmi_check_system(ov9650_flip_dmi_table) &&\n\t\t!sd->vflip->val))\n\t\tver_offs--;\n\n\tif (width <= 320)\n\t\thor_offs /= 2;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(res_init_ov9650) && !err; i++) {\n\t\tif (res_init_ov9650[i][0] == BRIDGE)\n\t\t\terr = m5602_write_bridge(sd, res_init_ov9650[i][1],\n\t\t\t\tres_init_ov9650[i][2]);\n\t\telse if (res_init_ov9650[i][0] == SENSOR) {\n\t\t\tdata = res_init_ov9650[i][2];\n\t\t\terr = m5602_write_sensor(sd,\n\t\t\t\tres_init_ov9650[i][1], &data, 1);\n\t\t}\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA,\n\t\t\t\t ((ver_offs >> 8) & 0xff));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, (ver_offs & 0xff));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, (height >> 8) & 0xff);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, (height & 0xff));\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < 2 && !err; i++)\n\t\terr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_SIG_INI, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_SIG_INI, 2);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_HSYNC_PARA,\n\t\t\t\t (hor_offs >> 8) & 0xff);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_HSYNC_PARA, hor_offs & 0xff);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_HSYNC_PARA,\n\t\t\t\t ((width + hor_offs) >> 8) & 0xff);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_HSYNC_PARA,\n\t\t\t\t ((width + hor_offs) & 0xff));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_SIG_INI, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (width) {\n\tcase 640:\n\t\tgspca_dbg(gspca_dev, D_CONF, \"Configuring camera for VGA mode\\n\");\n\n\t\tdata = OV9650_VGA_SELECT | OV9650_RGB_SELECT |\n\t\t       OV9650_RAW_RGB_SELECT;\n\t\terr = m5602_write_sensor(sd, OV9650_COM7, &data, 1);\n\t\tbreak;\n\n\tcase 352:\n\t\tgspca_dbg(gspca_dev, D_CONF, \"Configuring camera for CIF mode\\n\");\n\n\t\tdata = OV9650_CIF_SELECT | OV9650_RGB_SELECT |\n\t\t\t\tOV9650_RAW_RGB_SELECT;\n\t\terr = m5602_write_sensor(sd, OV9650_COM7, &data, 1);\n\t\tbreak;\n\n\tcase 320:\n\t\tgspca_dbg(gspca_dev, D_CONF, \"Configuring camera for QVGA mode\\n\");\n\n\t\tdata = OV9650_QVGA_SELECT | OV9650_RGB_SELECT |\n\t\t\t\tOV9650_RAW_RGB_SELECT;\n\t\terr = m5602_write_sensor(sd, OV9650_COM7, &data, 1);\n\t\tbreak;\n\n\tcase 176:\n\t\tgspca_dbg(gspca_dev, D_CONF, \"Configuring camera for QCIF mode\\n\");\n\n\t\tdata = OV9650_QCIF_SELECT | OV9650_RGB_SELECT |\n\t\t\tOV9650_RAW_RGB_SELECT;\n\t\terr = m5602_write_sensor(sd, OV9650_COM7, &data, 1);\n\t\tbreak;\n\t}\n\treturn err;\n}\n\nint ov9650_stop(struct sd *sd)\n{\n\tu8 data = OV9650_SOFT_SLEEP | OV9650_OUTPUT_DRIVE_2X;\n\treturn m5602_write_sensor(sd, OV9650_COM2, &data, 1);\n}\n\nvoid ov9650_disconnect(struct sd *sd)\n{\n\tov9650_stop(sd);\n\n\tsd->sensor = NULL;\n}\n\nstatic int ov9650_set_exposure(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 i2c_data;\n\tint err;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set exposure to %d\\n\", val);\n\n\t \n\ti2c_data = (val >> 10) & 0x3f;\n\terr = m5602_write_sensor(sd, OV9650_AECHM,\n\t\t\t\t  &i2c_data, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\ti2c_data = (val >> 2) & 0xff;\n\terr = m5602_write_sensor(sd, OV9650_AECH,\n\t\t\t\t  &i2c_data, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\ti2c_data = val & 0x03;\n\terr = m5602_write_sensor(sd, OV9650_COM1, &i2c_data, 1);\n\treturn err;\n}\n\nstatic int ov9650_set_gain(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tu8 i2c_data;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Setting gain to %d\\n\", val);\n\n\t \n\t \n\terr = m5602_read_sensor(sd, OV9650_VREF, &i2c_data, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\ti2c_data = ((val & 0x0300) >> 2) |\n\t\t\t(i2c_data & 0x3f);\n\terr = m5602_write_sensor(sd, OV9650_VREF, &i2c_data, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\ti2c_data = val & 0xff;\n\terr = m5602_write_sensor(sd, OV9650_GAIN, &i2c_data, 1);\n\treturn err;\n}\n\nstatic int ov9650_set_red_balance(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tu8 i2c_data;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set red gain to %d\\n\", val);\n\n\ti2c_data = val & 0xff;\n\terr = m5602_write_sensor(sd, OV9650_RED, &i2c_data, 1);\n\treturn err;\n}\n\nstatic int ov9650_set_blue_balance(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tu8 i2c_data;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set blue gain to %d\\n\", val);\n\n\ti2c_data = val & 0xff;\n\terr = m5602_write_sensor(sd, OV9650_BLUE, &i2c_data, 1);\n\treturn err;\n}\n\nstatic int ov9650_set_hvflip(struct gspca_dev *gspca_dev)\n{\n\tint err;\n\tu8 i2c_data;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint hflip = sd->hflip->val;\n\tint vflip = sd->vflip->val;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set hvflip to %d %d\\n\", hflip, vflip);\n\n\tif (dmi_check_system(ov9650_flip_dmi_table))\n\t\tvflip = !vflip;\n\n\ti2c_data = (hflip << 5) | (vflip << 4);\n\terr = m5602_write_sensor(sd, OV9650_MVFP, &i2c_data, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (gspca_dev->streaming)\n\t\terr = ov9650_start(sd);\n\n\treturn err;\n}\n\nstatic int ov9650_set_auto_exposure(struct gspca_dev *gspca_dev,\n\t\t\t\t    __s32 val)\n{\n\tint err;\n\tu8 i2c_data;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set auto exposure control to %d\\n\", val);\n\n\terr = m5602_read_sensor(sd, OV9650_COM8, &i2c_data, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\tval = (val == V4L2_EXPOSURE_AUTO);\n\ti2c_data = ((i2c_data & 0xfe) | ((val & 0x01) << 0));\n\n\treturn m5602_write_sensor(sd, OV9650_COM8, &i2c_data, 1);\n}\n\nstatic int ov9650_set_auto_white_balance(struct gspca_dev *gspca_dev,\n\t\t\t\t\t __s32 val)\n{\n\tint err;\n\tu8 i2c_data;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set auto white balance to %d\\n\", val);\n\n\terr = m5602_read_sensor(sd, OV9650_COM8, &i2c_data, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\ti2c_data = ((i2c_data & 0xfd) | ((val & 0x01) << 1));\n\terr = m5602_write_sensor(sd, OV9650_COM8, &i2c_data, 1);\n\n\treturn err;\n}\n\nstatic int ov9650_set_auto_gain(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tu8 i2c_data;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set auto gain control to %d\\n\", val);\n\n\terr = m5602_read_sensor(sd, OV9650_COM8, &i2c_data, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\ti2c_data = ((i2c_data & 0xfb) | ((val & 0x01) << 2));\n\n\treturn m5602_write_sensor(sd, OV9650_COM8, &i2c_data, 1);\n}\n\nstatic int ov9650_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint err;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\terr = ov9650_set_auto_white_balance(gspca_dev, ctrl->val);\n\t\tif (err || ctrl->val)\n\t\t\treturn err;\n\t\terr = ov9650_set_red_balance(gspca_dev, sd->red_bal->val);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = ov9650_set_blue_balance(gspca_dev, sd->blue_bal->val);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\terr = ov9650_set_auto_exposure(gspca_dev, ctrl->val);\n\t\tif (err || ctrl->val == V4L2_EXPOSURE_AUTO)\n\t\t\treturn err;\n\t\terr = ov9650_set_exposure(gspca_dev, sd->expo->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\terr = ov9650_set_auto_gain(gspca_dev, ctrl->val);\n\t\tif (err || ctrl->val)\n\t\t\treturn err;\n\t\terr = ov9650_set_gain(gspca_dev, sd->gain->val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\terr = ov9650_set_hvflip(gspca_dev);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic void ov9650_dump_registers(struct sd *sd)\n{\n\tint address;\n\tpr_info(\"Dumping the ov9650 register state\\n\");\n\tfor (address = 0; address < 0xa9; address++) {\n\t\tu8 value;\n\t\tm5602_read_sensor(sd, address, &value, 1);\n\t\tpr_info(\"register 0x%x contains 0x%x\\n\", address, value);\n\t}\n\n\tpr_info(\"ov9650 register state dump complete\\n\");\n\n\tpr_info(\"Probing for which registers that are read/write\\n\");\n\tfor (address = 0; address < 0xff; address++) {\n\t\tu8 old_value, ctrl_value;\n\t\tu8 test_value[2] = {0xff, 0xff};\n\n\t\tm5602_read_sensor(sd, address, &old_value, 1);\n\t\tm5602_write_sensor(sd, address, test_value, 1);\n\t\tm5602_read_sensor(sd, address, &ctrl_value, 1);\n\n\t\tif (ctrl_value == test_value[0])\n\t\t\tpr_info(\"register 0x%x is writeable\\n\", address);\n\t\telse\n\t\t\tpr_info(\"register 0x%x is read only\\n\", address);\n\n\t\t \n\t\tm5602_write_sensor(sd, address, &old_value, 1);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}