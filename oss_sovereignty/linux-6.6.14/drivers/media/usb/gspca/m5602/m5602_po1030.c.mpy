{
  "module_name": "m5602_po1030.c",
  "hash_id": "3f8d8ff50673bdbce1d75ed85e177dc87bddfc20b9714ff7a0ea5d772318b9f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/m5602/m5602_po1030.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"m5602_po1030.h\"\n\nstatic int po1030_s_ctrl(struct v4l2_ctrl *ctrl);\nstatic void po1030_dump_registers(struct sd *sd);\n\nstatic const unsigned char preinit_po1030[][3] = {\n\t{BRIDGE, M5602_XB_MCU_CLK_DIV, 0x02},\n\t{BRIDGE, M5602_XB_MCU_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_ADC_CTRL, 0xc0},\n\t{BRIDGE, M5602_XB_SENSOR_CTRL, 0x00},\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x0c},\n\t{BRIDGE, M5602_XB_ADC_CTRL, 0xc0},\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x05},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x04},\n\t{BRIDGE, M5602_XB_GPIO_EN_H, 0x06},\n\t{BRIDGE, M5602_XB_GPIO_DIR_H, 0x06},\n\t{BRIDGE, M5602_XB_GPIO_DAT_H, 0x02},\n\n\t{SENSOR, PO1030_AUTOCTRL2, PO1030_SENSOR_RESET | (1 << 2)},\n\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x04},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x0c},\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x05},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x00}\n};\n\nstatic const unsigned char init_po1030[][3] = {\n\t{BRIDGE, M5602_XB_MCU_CLK_DIV, 0x02},\n\t{BRIDGE, M5602_XB_MCU_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_ADC_CTRL, 0xc0},\n\t{BRIDGE, M5602_XB_SENSOR_CTRL, 0x00},\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x0c},\n\n\t{SENSOR, PO1030_AUTOCTRL2, PO1030_SENSOR_RESET | (1 << 2)},\n\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x05},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x04},\n\t{BRIDGE, M5602_XB_GPIO_EN_H, 0x06},\n\t{BRIDGE, M5602_XB_GPIO_EN_L, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DIR_H, 0x06},\n\t{BRIDGE, M5602_XB_GPIO_DAT_H, 0x02},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x04},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x05},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x00},\n\n\t{SENSOR, PO1030_AUTOCTRL2, 0x04},\n\n\t{SENSOR, PO1030_OUTFORMCTRL2, PO1030_RAW_RGB_BAYER},\n\t{SENSOR, PO1030_AUTOCTRL1, PO1030_WEIGHT_WIN_2X},\n\n\t{SENSOR, PO1030_CONTROL2, 0x03},\n\t{SENSOR, 0x21, 0x90},\n\t{SENSOR, PO1030_YTARGET, 0x60},\n\t{SENSOR, 0x59, 0x13},\n\t{SENSOR, PO1030_OUTFORMCTRL1, PO1030_HREF_ENABLE},\n\t{SENSOR, PO1030_EDGE_ENH_OFF, 0x00},\n\t{SENSOR, PO1030_EGA, 0x80},\n\t{SENSOR, 0x78, 0x14},\n\t{SENSOR, 0x6f, 0x01},\n\t{SENSOR, PO1030_GLOBALGAINMAX, 0x14},\n\t{SENSOR, PO1030_Cb_U_GAIN, 0x38},\n\t{SENSOR, PO1030_Cr_V_GAIN, 0x38},\n\t{SENSOR, PO1030_CONTROL1, PO1030_SHUTTER_MODE |\n\t\t\t\t  PO1030_AUTO_SUBSAMPLING |\n\t\t\t\t  PO1030_FRAME_EQUAL},\n\t{SENSOR, PO1030_GC0, 0x10},\n\t{SENSOR, PO1030_GC1, 0x20},\n\t{SENSOR, PO1030_GC2, 0x40},\n\t{SENSOR, PO1030_GC3, 0x60},\n\t{SENSOR, PO1030_GC4, 0x80},\n\t{SENSOR, PO1030_GC5, 0xa0},\n\t{SENSOR, PO1030_GC6, 0xc0},\n\t{SENSOR, PO1030_GC7, 0xff},\n\n\t \n\t{SENSOR, PO1030_FRAMEWIDTH_H, 0x02},\n\t{SENSOR, PO1030_FRAMEWIDTH_L, 0xef},\n\n\t \n\t{SENSOR, PO1030_FRAMEHEIGHT_H, 0x02},\n\t{SENSOR, PO1030_FRAMEHEIGHT_L, 0x1c},\n\n\t \n\t{SENSOR, PO1030_WINDOWX_H, 0x00},\n\t{SENSOR, PO1030_WINDOWX_L, 0x01},\n\n\t \n\t{SENSOR, PO1030_WINDOWY_H, 0x00},\n\t{SENSOR, PO1030_WINDOWY_L, 0x01},\n\n\t \n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0},\n\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x05},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_EN_H, 0x06},\n\t{BRIDGE, M5602_XB_GPIO_EN_L, 0x00},\n};\n\nstatic struct v4l2_pix_format po1030_modes[] = {\n\t{\n\t\t640,\n\t\t480,\n\t\tV4L2_PIX_FMT_SBGGR8,\n\t\tV4L2_FIELD_NONE,\n\t\t.sizeimage = 640 * 480,\n\t\t.bytesperline = 640,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 2\n\t}\n};\n\nstatic const struct v4l2_ctrl_ops po1030_ctrl_ops = {\n\t.s_ctrl = po1030_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config po1030_greenbal_cfg = {\n\t.ops\t= &po1030_ctrl_ops,\n\t.id\t= M5602_V4L2_CID_GREEN_BALANCE,\n\t.name\t= \"Green Balance\",\n\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t.min\t= 0,\n\t.max\t= 255,\n\t.step\t= 1,\n\t.def\t= PO1030_GREEN_GAIN_DEFAULT,\n\t.flags\t= V4L2_CTRL_FLAG_SLIDER,\n};\n\nint po1030_probe(struct sd *sd)\n{\n\tu8 dev_id_h = 0, i;\n\tint err;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tif (force_sensor) {\n\t\tif (force_sensor == PO1030_SENSOR) {\n\t\t\tpr_info(\"Forcing a %s sensor\\n\", po1030.name);\n\t\t\tgoto sensor_found;\n\t\t}\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"Probing for a po1030 sensor\\n\");\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(preinit_po1030); i++) {\n\t\tu8 data = preinit_po1030[i][2];\n\t\tif (preinit_po1030[i][0] == SENSOR)\n\t\t\terr = m5602_write_sensor(sd, preinit_po1030[i][1],\n\t\t\t\t\t\t &data, 1);\n\t\telse\n\t\t\terr = m5602_write_bridge(sd, preinit_po1030[i][1],\n\t\t\t\t\t\t data);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (m5602_read_sensor(sd, PO1030_DEVID_H, &dev_id_h, 1))\n\t\treturn -ENODEV;\n\n\tif (dev_id_h == 0x30) {\n\t\tpr_info(\"Detected a po1030 sensor\\n\");\n\t\tgoto sensor_found;\n\t}\n\treturn -ENODEV;\n\nsensor_found:\n\tsd->gspca_dev.cam.cam_mode = po1030_modes;\n\tsd->gspca_dev.cam.nmodes = ARRAY_SIZE(po1030_modes);\n\n\treturn 0;\n}\n\nint po1030_init(struct sd *sd)\n{\n\tint i, err = 0;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(init_po1030) && !err; i++) {\n\t\tu8 data[2] = {0x00, 0x00};\n\n\t\tswitch (init_po1030[i][0]) {\n\t\tcase BRIDGE:\n\t\t\terr = m5602_write_bridge(sd,\n\t\t\t\tinit_po1030[i][1],\n\t\t\t\tinit_po1030[i][2]);\n\t\t\tbreak;\n\n\t\tcase SENSOR:\n\t\t\tdata[0] = init_po1030[i][2];\n\t\t\terr = m5602_write_sensor(sd,\n\t\t\t\tinit_po1030[i][1], data, 1);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_info(\"Invalid stream command, exiting init\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\tif (dump_sensor)\n\t\tpo1030_dump_registers(sd);\n\n\treturn 0;\n}\n\nint po1030_init_controls(struct sd *sd)\n{\n\tstruct v4l2_ctrl_handler *hdl = &sd->gspca_dev.ctrl_handler;\n\n\tsd->gspca_dev.vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 9);\n\n\tsd->auto_white_bal = v4l2_ctrl_new_std(hdl, &po1030_ctrl_ops,\n\t\t\t\t\t       V4L2_CID_AUTO_WHITE_BALANCE,\n\t\t\t\t\t       0, 1, 1, 0);\n\tsd->green_bal = v4l2_ctrl_new_custom(hdl, &po1030_greenbal_cfg, NULL);\n\tsd->red_bal = v4l2_ctrl_new_std(hdl, &po1030_ctrl_ops,\n\t\t\t\t\tV4L2_CID_RED_BALANCE, 0, 255, 1,\n\t\t\t\t\tPO1030_RED_GAIN_DEFAULT);\n\tsd->blue_bal = v4l2_ctrl_new_std(hdl, &po1030_ctrl_ops,\n\t\t\t\t\tV4L2_CID_BLUE_BALANCE, 0, 255, 1,\n\t\t\t\t\tPO1030_BLUE_GAIN_DEFAULT);\n\n\tsd->autoexpo = v4l2_ctrl_new_std_menu(hdl, &po1030_ctrl_ops,\n\t\t\t  V4L2_CID_EXPOSURE_AUTO, 1, 0, V4L2_EXPOSURE_MANUAL);\n\tsd->expo = v4l2_ctrl_new_std(hdl, &po1030_ctrl_ops, V4L2_CID_EXPOSURE,\n\t\t\t  0, 0x2ff, 1, PO1030_EXPOSURE_DEFAULT);\n\n\tsd->gain = v4l2_ctrl_new_std(hdl, &po1030_ctrl_ops, V4L2_CID_GAIN, 0,\n\t\t\t\t     0x4f, 1, PO1030_GLOBAL_GAIN_DEFAULT);\n\n\tsd->hflip = v4l2_ctrl_new_std(hdl, &po1030_ctrl_ops, V4L2_CID_HFLIP,\n\t\t\t\t      0, 1, 1, 0);\n\tsd->vflip = v4l2_ctrl_new_std(hdl, &po1030_ctrl_ops, V4L2_CID_VFLIP,\n\t\t\t\t      0, 1, 1, 0);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\n\tv4l2_ctrl_auto_cluster(4, &sd->auto_white_bal, 0, false);\n\tv4l2_ctrl_auto_cluster(2, &sd->autoexpo, 0, false);\n\tv4l2_ctrl_cluster(2, &sd->hflip);\n\n\treturn 0;\n}\n\nint po1030_start(struct sd *sd)\n{\n\tstruct cam *cam = &sd->gspca_dev.cam;\n\tint i, err = 0;\n\tint width = cam->cam_mode[sd->gspca_dev.curr_mode].width;\n\tint height = cam->cam_mode[sd->gspca_dev.curr_mode].height;\n\tint ver_offs = cam->cam_mode[sd->gspca_dev.curr_mode].priv;\n\tu8 data;\n\n\tswitch (width) {\n\tcase 320:\n\t\tdata = PO1030_SUBSAMPLING;\n\t\terr = m5602_write_sensor(sd, PO1030_CONTROL3, &data, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tdata = ((width + 3) >> 8) & 0xff;\n\t\terr = m5602_write_sensor(sd, PO1030_WINDOWWIDTH_H, &data, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tdata = (width + 3) & 0xff;\n\t\terr = m5602_write_sensor(sd, PO1030_WINDOWWIDTH_L, &data, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tdata = ((height + 1) >> 8) & 0xff;\n\t\terr = m5602_write_sensor(sd, PO1030_WINDOWHEIGHT_H, &data, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tdata = (height + 1) & 0xff;\n\t\terr = m5602_write_sensor(sd, PO1030_WINDOWHEIGHT_L, &data, 1);\n\n\t\theight += 6;\n\t\twidth -= 1;\n\t\tbreak;\n\n\tcase 640:\n\t\tdata = 0;\n\t\terr = m5602_write_sensor(sd, PO1030_CONTROL3, &data, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tdata = ((width + 7) >> 8) & 0xff;\n\t\terr = m5602_write_sensor(sd, PO1030_WINDOWWIDTH_H, &data, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tdata = (width + 7) & 0xff;\n\t\terr = m5602_write_sensor(sd, PO1030_WINDOWWIDTH_L, &data, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tdata = ((height + 3) >> 8) & 0xff;\n\t\terr = m5602_write_sensor(sd, PO1030_WINDOWHEIGHT_H, &data, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tdata = (height + 3) & 0xff;\n\t\terr = m5602_write_sensor(sd, PO1030_WINDOWHEIGHT_L, &data, 1);\n\n\t\theight += 12;\n\t\twidth -= 2;\n\t\tbreak;\n\t}\n\terr = m5602_write_bridge(sd, M5602_XB_SENSOR_TYPE, 0x0c);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_LINE_OF_FRAME_H, 0x81);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_PIX_OF_LINE_H, 0x82);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_SIG_INI, 0x01);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA,\n\t\t\t\t ((ver_offs >> 8) & 0xff));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, (ver_offs & 0xff));\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < 2 && !err; i++)\n\t\terr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, (height >> 8) & 0xff);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, (height & 0xff));\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < 2 && !err; i++)\n\t\terr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, 0);\n\n\tfor (i = 0; i < 2 && !err; i++)\n\t\terr = m5602_write_bridge(sd, M5602_XB_SIG_INI, 0);\n\n\tfor (i = 0; i < 2 && !err; i++)\n\t\terr = m5602_write_bridge(sd, M5602_XB_HSYNC_PARA, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_HSYNC_PARA, (width >> 8) & 0xff);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_HSYNC_PARA, (width & 0xff));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_SIG_INI, 0);\n\treturn err;\n}\n\nstatic int po1030_set_exposure(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 i2c_data;\n\tint err;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set exposure to %d\\n\", val & 0xffff);\n\n\ti2c_data = ((val & 0xff00) >> 8);\n\tgspca_dbg(gspca_dev, D_CONF, \"Set exposure to high byte to 0x%x\\n\",\n\t\t  i2c_data);\n\n\terr = m5602_write_sensor(sd, PO1030_INTEGLINES_H,\n\t\t\t\t  &i2c_data, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\ti2c_data = (val & 0xff);\n\tgspca_dbg(gspca_dev, D_CONF, \"Set exposure to low byte to 0x%x\\n\",\n\t\t  i2c_data);\n\terr = m5602_write_sensor(sd, PO1030_INTEGLINES_M,\n\t\t\t\t  &i2c_data, 1);\n\n\treturn err;\n}\n\nstatic int po1030_set_gain(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 i2c_data;\n\tint err;\n\n\ti2c_data = val & 0xff;\n\tgspca_dbg(gspca_dev, D_CONF, \"Set global gain to %d\\n\", i2c_data);\n\terr = m5602_write_sensor(sd, PO1030_GLOBALGAIN,\n\t\t\t\t &i2c_data, 1);\n\treturn err;\n}\n\nstatic int po1030_set_hvflip(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 i2c_data;\n\tint err;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set hvflip %d %d\\n\",\n\t\t  sd->hflip->val, sd->vflip->val);\n\terr = m5602_read_sensor(sd, PO1030_CONTROL2, &i2c_data, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\ti2c_data = (0x3f & i2c_data) | (sd->hflip->val << 7) |\n\t\t   (sd->vflip->val << 6);\n\n\terr = m5602_write_sensor(sd, PO1030_CONTROL2,\n\t\t\t\t &i2c_data, 1);\n\n\treturn err;\n}\n\nstatic int po1030_set_red_balance(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 i2c_data;\n\tint err;\n\n\ti2c_data = val & 0xff;\n\tgspca_dbg(gspca_dev, D_CONF, \"Set red gain to %d\\n\", i2c_data);\n\terr = m5602_write_sensor(sd, PO1030_RED_GAIN,\n\t\t\t\t  &i2c_data, 1);\n\treturn err;\n}\n\nstatic int po1030_set_blue_balance(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 i2c_data;\n\tint err;\n\n\ti2c_data = val & 0xff;\n\tgspca_dbg(gspca_dev, D_CONF, \"Set blue gain to %d\\n\", i2c_data);\n\terr = m5602_write_sensor(sd, PO1030_BLUE_GAIN,\n\t\t\t\t  &i2c_data, 1);\n\n\treturn err;\n}\n\nstatic int po1030_set_green_balance(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 i2c_data;\n\tint err;\n\n\ti2c_data = val & 0xff;\n\tgspca_dbg(gspca_dev, D_CONF, \"Set green gain to %d\\n\", i2c_data);\n\n\terr = m5602_write_sensor(sd, PO1030_GREEN_1_GAIN,\n\t\t\t   &i2c_data, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn m5602_write_sensor(sd, PO1030_GREEN_2_GAIN,\n\t\t\t\t &i2c_data, 1);\n}\n\nstatic int po1030_set_auto_white_balance(struct gspca_dev *gspca_dev,\n\t\t\t\t\t __s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 i2c_data;\n\tint err;\n\n\terr = m5602_read_sensor(sd, PO1030_AUTOCTRL1, &i2c_data, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set auto white balance to %d\\n\", val);\n\ti2c_data = (i2c_data & 0xfe) | (val & 0x01);\n\terr = m5602_write_sensor(sd, PO1030_AUTOCTRL1, &i2c_data, 1);\n\treturn err;\n}\n\nstatic int po1030_set_auto_exposure(struct gspca_dev *gspca_dev,\n\t\t\t\t    __s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 i2c_data;\n\tint err;\n\n\terr = m5602_read_sensor(sd, PO1030_AUTOCTRL1, &i2c_data, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set auto exposure to %d\\n\", val);\n\tval = (val == V4L2_EXPOSURE_AUTO);\n\ti2c_data = (i2c_data & 0xfd) | ((val & 0x01) << 1);\n\treturn m5602_write_sensor(sd, PO1030_AUTOCTRL1, &i2c_data, 1);\n}\n\nvoid po1030_disconnect(struct sd *sd)\n{\n\tsd->sensor = NULL;\n}\n\nstatic int po1030_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint err;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\terr = po1030_set_auto_white_balance(gspca_dev, ctrl->val);\n\t\tif (err || ctrl->val)\n\t\t\treturn err;\n\t\terr = po1030_set_green_balance(gspca_dev, sd->green_bal->val);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = po1030_set_red_balance(gspca_dev, sd->red_bal->val);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = po1030_set_blue_balance(gspca_dev, sd->blue_bal->val);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\terr = po1030_set_auto_exposure(gspca_dev, ctrl->val);\n\t\tif (err || ctrl->val == V4L2_EXPOSURE_AUTO)\n\t\t\treturn err;\n\t\terr = po1030_set_exposure(gspca_dev, sd->expo->val);\n\t\tbreak;\n\tcase V4L2_CID_GAIN:\n\t\terr = po1030_set_gain(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\terr = po1030_set_hvflip(gspca_dev);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic void po1030_dump_registers(struct sd *sd)\n{\n\tint address;\n\tu8 value = 0;\n\n\tpr_info(\"Dumping the po1030 sensor core registers\\n\");\n\tfor (address = 0; address < 0x7f; address++) {\n\t\tm5602_read_sensor(sd, address, &value, 1);\n\t\tpr_info(\"register 0x%x contains 0x%x\\n\", address, value);\n\t}\n\n\tpr_info(\"po1030 register state dump complete\\n\");\n\n\tpr_info(\"Probing for which registers that are read/write\\n\");\n\tfor (address = 0; address < 0xff; address++) {\n\t\tu8 old_value, ctrl_value;\n\t\tu8 test_value[2] = {0xff, 0xff};\n\n\t\tm5602_read_sensor(sd, address, &old_value, 1);\n\t\tm5602_write_sensor(sd, address, test_value, 1);\n\t\tm5602_read_sensor(sd, address, &ctrl_value, 1);\n\n\t\tif (ctrl_value == test_value[0])\n\t\t\tpr_info(\"register 0x%x is writeable\\n\", address);\n\t\telse\n\t\t\tpr_info(\"register 0x%x is read only\\n\", address);\n\n\t\t \n\t\tm5602_write_sensor(sd, address, &old_value, 1);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}