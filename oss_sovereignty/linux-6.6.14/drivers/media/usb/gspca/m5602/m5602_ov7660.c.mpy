{
  "module_name": "m5602_ov7660.c",
  "hash_id": "331c4e04eb40087437d983ef83bb261c8cbdbccd50a6f9940b7b9900a5bd1432",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/m5602/m5602_ov7660.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"m5602_ov7660.h\"\n\nstatic int ov7660_s_ctrl(struct v4l2_ctrl *ctrl);\nstatic void ov7660_dump_registers(struct sd *sd);\n\nstatic const unsigned char preinit_ov7660[][4] = {\n\t{BRIDGE, M5602_XB_MCU_CLK_DIV, 0x02},\n\t{BRIDGE, M5602_XB_MCU_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_ADC_CTRL, 0xc0},\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x0d},\n\t{BRIDGE, M5602_XB_SENSOR_CTRL, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x03},\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x03},\n\t{BRIDGE, M5602_XB_ADC_CTRL, 0xc0},\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x0c},\n\n\t{SENSOR, OV7660_OFON, 0x0c},\n\t{SENSOR, OV7660_COM2, 0x11},\n\t{SENSOR, OV7660_COM7, 0x05},\n\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x01},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x04},\n\t{BRIDGE, M5602_XB_GPIO_EN_H, 0x06},\n\t{BRIDGE, M5602_XB_GPIO_DIR_H, 0x06},\n\t{BRIDGE, M5602_XB_GPIO_DAT_H, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x08},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_ADC_CTRL, 0xc0},\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x0c},\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x05},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_EN_H, 0x06},\n\t{BRIDGE, M5602_XB_GPIO_EN_L, 0x00}\n};\n\nstatic const unsigned char init_ov7660[][4] = {\n\t{BRIDGE, M5602_XB_MCU_CLK_DIV, 0x02},\n\t{BRIDGE, M5602_XB_MCU_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_ADC_CTRL, 0xc0},\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x0d},\n\t{BRIDGE, M5602_XB_SENSOR_CTRL, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x01},\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x01},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_ADC_CTRL, 0xc0},\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x0c},\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x05},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_EN_H, 0x06},\n\t{BRIDGE, M5602_XB_GPIO_EN_L, 0x00},\n\t{SENSOR, OV7660_COM7, 0x80},\n\t{SENSOR, OV7660_CLKRC, 0x80},\n\t{SENSOR, OV7660_COM9, 0x4c},\n\t{SENSOR, OV7660_OFON, 0x43},\n\t{SENSOR, OV7660_COM12, 0x28},\n\t{SENSOR, OV7660_COM8, 0x00},\n\t{SENSOR, OV7660_COM10, 0x40},\n\t{SENSOR, OV7660_HSTART, 0x0c},\n\t{SENSOR, OV7660_HSTOP, 0x61},\n\t{SENSOR, OV7660_HREF, 0xa4},\n\t{SENSOR, OV7660_PSHFT, 0x0b},\n\t{SENSOR, OV7660_VSTART, 0x01},\n\t{SENSOR, OV7660_VSTOP, 0x7a},\n\t{SENSOR, OV7660_VSTOP, 0x00},\n\t{SENSOR, OV7660_COM7, 0x05},\n\t{SENSOR, OV7660_COM6, 0x42},\n\t{SENSOR, OV7660_BBIAS, 0x94},\n\t{SENSOR, OV7660_GbBIAS, 0x94},\n\t{SENSOR, OV7660_RSVD29, 0x94},\n\t{SENSOR, OV7660_RBIAS, 0x94},\n\t{SENSOR, OV7660_COM1, 0x00},\n\t{SENSOR, OV7660_AECH, 0x00},\n\t{SENSOR, OV7660_AECHH, 0x00},\n\t{SENSOR, OV7660_ADC, 0x05},\n\t{SENSOR, OV7660_COM13, 0x00},\n\t{SENSOR, OV7660_RSVDA1, 0x23},\n\t{SENSOR, OV7660_TSLB, 0x0d},\n\t{SENSOR, OV7660_HV, 0x80},\n\t{SENSOR, OV7660_LCC1, 0x00},\n\t{SENSOR, OV7660_LCC2, 0x00},\n\t{SENSOR, OV7660_LCC3, 0x10},\n\t{SENSOR, OV7660_LCC4, 0x40},\n\t{SENSOR, OV7660_LCC5, 0x01},\n\n\t{SENSOR, OV7660_AECH, 0x20},\n\t{SENSOR, OV7660_COM1, 0x00},\n\t{SENSOR, OV7660_OFON, 0x0c},\n\t{SENSOR, OV7660_COM2, 0x11},\n\t{SENSOR, OV7660_COM7, 0x05},\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x01},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x04},\n\t{BRIDGE, M5602_XB_GPIO_EN_H, 0x06},\n\t{BRIDGE, M5602_XB_GPIO_DIR_H, 0x06},\n\t{BRIDGE, M5602_XB_GPIO_DAT_H, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x08},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_ADC_CTRL, 0xc0},\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x0c},\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x05},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_EN_H, 0x06},\n\t{BRIDGE, M5602_XB_GPIO_EN_L, 0x00},\n\t{SENSOR, OV7660_AECH, 0x5f},\n\t{SENSOR, OV7660_COM1, 0x03},\n\t{SENSOR, OV7660_OFON, 0x0c},\n\t{SENSOR, OV7660_COM2, 0x11},\n\t{SENSOR, OV7660_COM7, 0x05},\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x01},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x04},\n\t{BRIDGE, M5602_XB_GPIO_EN_H, 0x06},\n\t{BRIDGE, M5602_XB_GPIO_DIR_H, 0x06},\n\t{BRIDGE, M5602_XB_GPIO_DAT_H, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x08},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_ADC_CTRL, 0xc0},\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x0c},\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x05},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_EN_H, 0x06},\n\t{BRIDGE, M5602_XB_GPIO_EN_L, 0x00},\n\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x06},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0},\n\t{BRIDGE, M5602_XB_ADC_CTRL, 0xc0},\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x0c},\n\t{BRIDGE, M5602_XB_LINE_OF_FRAME_H, 0x81},\n\t{BRIDGE, M5602_XB_PIX_OF_LINE_H, 0x82},\n\t{BRIDGE, M5602_XB_SIG_INI, 0x01},\n\t{BRIDGE, M5602_XB_VSYNC_PARA, 0x00},\n\t{BRIDGE, M5602_XB_VSYNC_PARA, 0x08},\n\t{BRIDGE, M5602_XB_VSYNC_PARA, 0x00},\n\t{BRIDGE, M5602_XB_VSYNC_PARA, 0x00},\n\t{BRIDGE, M5602_XB_VSYNC_PARA, 0x01},\n\t{BRIDGE, M5602_XB_VSYNC_PARA, 0xec},\n\t{BRIDGE, M5602_XB_VSYNC_PARA, 0x00},\n\t{BRIDGE, M5602_XB_VSYNC_PARA, 0x00},\n\t{BRIDGE, M5602_XB_SIG_INI, 0x00},\n\t{BRIDGE, M5602_XB_SIG_INI, 0x02},\n\t{BRIDGE, M5602_XB_HSYNC_PARA, 0x00},\n\t{BRIDGE, M5602_XB_HSYNC_PARA, 0x27},\n\t{BRIDGE, M5602_XB_HSYNC_PARA, 0x02},\n\t{BRIDGE, M5602_XB_HSYNC_PARA, 0xa7},\n\t{BRIDGE, M5602_XB_SIG_INI, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0},\n};\n\nstatic struct v4l2_pix_format ov7660_modes[] = {\n\t{\n\t\t640,\n\t\t480,\n\t\tV4L2_PIX_FMT_SBGGR8,\n\t\tV4L2_FIELD_NONE,\n\t\t.sizeimage =\n\t\t\t640 * 480,\n\t\t.bytesperline = 640,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0\n\t}\n};\n\nstatic const struct v4l2_ctrl_ops ov7660_ctrl_ops = {\n\t.s_ctrl = ov7660_s_ctrl,\n};\n\nint ov7660_probe(struct sd *sd)\n{\n\tint err = 0, i;\n\tu8 prod_id = 0, ver_id = 0;\n\n\tif (force_sensor) {\n\t\tif (force_sensor == OV7660_SENSOR) {\n\t\t\tpr_info(\"Forcing an %s sensor\\n\", ov7660.name);\n\t\t\tgoto sensor_found;\n\t\t}\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(preinit_ov7660) && !err; i++) {\n\t\tu8 data[2];\n\n\t\tif (preinit_ov7660[i][0] == BRIDGE) {\n\t\t\terr = m5602_write_bridge(sd,\n\t\t\t\tpreinit_ov7660[i][1],\n\t\t\t\tpreinit_ov7660[i][2]);\n\t\t} else {\n\t\t\tdata[0] = preinit_ov7660[i][2];\n\t\t\terr = m5602_write_sensor(sd,\n\t\t\t\tpreinit_ov7660[i][1], data, 1);\n\t\t}\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\tif (m5602_read_sensor(sd, OV7660_PID, &prod_id, 1))\n\t\treturn -ENODEV;\n\n\tif (m5602_read_sensor(sd, OV7660_VER, &ver_id, 1))\n\t\treturn -ENODEV;\n\n\tpr_info(\"Sensor reported 0x%x%x\\n\", prod_id, ver_id);\n\n\tif ((prod_id == 0x76) && (ver_id == 0x60)) {\n\t\tpr_info(\"Detected a ov7660 sensor\\n\");\n\t\tgoto sensor_found;\n\t}\n\treturn -ENODEV;\n\nsensor_found:\n\tsd->gspca_dev.cam.cam_mode = ov7660_modes;\n\tsd->gspca_dev.cam.nmodes = ARRAY_SIZE(ov7660_modes);\n\n\treturn 0;\n}\n\nint ov7660_init(struct sd *sd)\n{\n\tint i, err;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(init_ov7660); i++) {\n\t\tu8 data[2];\n\n\t\tif (init_ov7660[i][0] == BRIDGE) {\n\t\t\terr = m5602_write_bridge(sd,\n\t\t\t\tinit_ov7660[i][1],\n\t\t\t\tinit_ov7660[i][2]);\n\t\t} else {\n\t\t\tdata[0] = init_ov7660[i][2];\n\t\t\terr = m5602_write_sensor(sd,\n\t\t\t\tinit_ov7660[i][1], data, 1);\n\t\t}\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (dump_sensor)\n\t\tov7660_dump_registers(sd);\n\n\treturn 0;\n}\n\nint ov7660_init_controls(struct sd *sd)\n{\n\tstruct v4l2_ctrl_handler *hdl = &sd->gspca_dev.ctrl_handler;\n\n\tsd->gspca_dev.vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 6);\n\n\tv4l2_ctrl_new_std(hdl, &ov7660_ctrl_ops, V4L2_CID_AUTO_WHITE_BALANCE,\n\t\t\t  0, 1, 1, 1);\n\tv4l2_ctrl_new_std_menu(hdl, &ov7660_ctrl_ops,\n\t\t\t  V4L2_CID_EXPOSURE_AUTO, 1, 0, V4L2_EXPOSURE_AUTO);\n\n\tsd->autogain = v4l2_ctrl_new_std(hdl, &ov7660_ctrl_ops,\n\t\t\t\t\t V4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\tsd->gain = v4l2_ctrl_new_std(hdl, &ov7660_ctrl_ops, V4L2_CID_GAIN, 0,\n\t\t\t\t     255, 1, OV7660_DEFAULT_GAIN);\n\n\tsd->hflip = v4l2_ctrl_new_std(hdl, &ov7660_ctrl_ops, V4L2_CID_HFLIP,\n\t\t\t\t      0, 1, 1, 0);\n\tsd->vflip = v4l2_ctrl_new_std(hdl, &ov7660_ctrl_ops, V4L2_CID_VFLIP,\n\t\t\t\t      0, 1, 1, 0);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\n\tv4l2_ctrl_auto_cluster(2, &sd->autogain, 0, false);\n\tv4l2_ctrl_cluster(2, &sd->hflip);\n\n\treturn 0;\n}\n\nint ov7660_start(struct sd *sd)\n{\n\treturn 0;\n}\n\nint ov7660_stop(struct sd *sd)\n{\n\treturn 0;\n}\n\nvoid ov7660_disconnect(struct sd *sd)\n{\n\tov7660_stop(sd);\n\n\tsd->sensor = NULL;\n}\n\nstatic int ov7660_set_gain(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tu8 i2c_data = val;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Setting gain to %d\\n\", val);\n\n\terr = m5602_write_sensor(sd, OV7660_GAIN, &i2c_data, 1);\n\treturn err;\n}\n\nstatic int ov7660_set_auto_white_balance(struct gspca_dev *gspca_dev,\n\t\t\t\t\t __s32 val)\n{\n\tint err;\n\tu8 i2c_data;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set auto white balance to %d\\n\", val);\n\n\terr = m5602_read_sensor(sd, OV7660_COM8, &i2c_data, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\ti2c_data = ((i2c_data & 0xfd) | ((val & 0x01) << 1));\n\terr = m5602_write_sensor(sd, OV7660_COM8, &i2c_data, 1);\n\n\treturn err;\n}\n\nstatic int ov7660_set_auto_gain(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tu8 i2c_data;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set auto gain control to %d\\n\", val);\n\n\terr = m5602_read_sensor(sd, OV7660_COM8, &i2c_data, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\ti2c_data = ((i2c_data & 0xfb) | ((val & 0x01) << 2));\n\n\treturn m5602_write_sensor(sd, OV7660_COM8, &i2c_data, 1);\n}\n\nstatic int ov7660_set_auto_exposure(struct gspca_dev *gspca_dev,\n\t\t\t\t    __s32 val)\n{\n\tint err;\n\tu8 i2c_data;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set auto exposure control to %d\\n\", val);\n\n\terr = m5602_read_sensor(sd, OV7660_COM8, &i2c_data, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\tval = (val == V4L2_EXPOSURE_AUTO);\n\ti2c_data = ((i2c_data & 0xfe) | ((val & 0x01) << 0));\n\n\treturn m5602_write_sensor(sd, OV7660_COM8, &i2c_data, 1);\n}\n\nstatic int ov7660_set_hvflip(struct gspca_dev *gspca_dev)\n{\n\tint err;\n\tu8 i2c_data;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set hvflip to %d, %d\\n\",\n\t\t  sd->hflip->val, sd->vflip->val);\n\n\ti2c_data = (sd->hflip->val << 5) | (sd->vflip->val << 4);\n\n\terr = m5602_write_sensor(sd, OV7660_MVFP, &i2c_data, 1);\n\n\treturn err;\n}\n\nstatic int ov7660_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint err;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTO_WHITE_BALANCE:\n\t\terr = ov7660_set_auto_white_balance(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE_AUTO:\n\t\terr = ov7660_set_auto_exposure(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\terr = ov7660_set_auto_gain(gspca_dev, ctrl->val);\n\t\tif (err || ctrl->val)\n\t\t\treturn err;\n\t\terr = ov7660_set_gain(gspca_dev, sd->gain->val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\terr = ov7660_set_hvflip(gspca_dev);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic void ov7660_dump_registers(struct sd *sd)\n{\n\tint address;\n\tpr_info(\"Dumping the ov7660 register state\\n\");\n\tfor (address = 0; address < 0xa9; address++) {\n\t\tu8 value;\n\t\tm5602_read_sensor(sd, address, &value, 1);\n\t\tpr_info(\"register 0x%x contains 0x%x\\n\", address, value);\n\t}\n\n\tpr_info(\"ov7660 register state dump complete\\n\");\n\n\tpr_info(\"Probing for which registers that are read/write\\n\");\n\tfor (address = 0; address < 0xff; address++) {\n\t\tu8 old_value, ctrl_value;\n\t\tu8 test_value[2] = {0xff, 0xff};\n\n\t\tm5602_read_sensor(sd, address, &old_value, 1);\n\t\tm5602_write_sensor(sd, address, test_value, 1);\n\t\tm5602_read_sensor(sd, address, &ctrl_value, 1);\n\n\t\tif (ctrl_value == test_value[0])\n\t\t\tpr_info(\"register 0x%x is writeable\\n\", address);\n\t\telse\n\t\t\tpr_info(\"register 0x%x is read only\\n\", address);\n\n\t\t \n\t\tm5602_write_sensor(sd, address, &old_value, 1);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}