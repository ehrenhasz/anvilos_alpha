{
  "module_name": "m5602_s5k83a.c",
  "hash_id": "59e11b40976b679e472257660102bb9e17f8a6a44d9b1340c5e14f3c13ef81dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/m5602/m5602_s5k83a.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kthread.h>\n#include \"m5602_s5k83a.h\"\n\nstatic int s5k83a_s_ctrl(struct v4l2_ctrl *ctrl);\n\nstatic const struct v4l2_ctrl_ops s5k83a_ctrl_ops = {\n\t.s_ctrl = s5k83a_s_ctrl,\n};\n\nstatic struct v4l2_pix_format s5k83a_modes[] = {\n\t{\n\t\t640,\n\t\t480,\n\t\tV4L2_PIX_FMT_SBGGR8,\n\t\tV4L2_FIELD_NONE,\n\t\t.sizeimage =\n\t\t\t640 * 480,\n\t\t.bytesperline = 640,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0\n\t}\n};\n\nstatic const unsigned char preinit_s5k83a[][4] = {\n\t{BRIDGE, M5602_XB_MCU_CLK_DIV, 0x02, 0x00},\n\t{BRIDGE, M5602_XB_MCU_CLK_CTRL, 0xb0, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0, 0x00},\n\t{BRIDGE, M5602_XB_ADC_CTRL, 0xc0, 0x00},\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x0d, 0x00},\n\t{BRIDGE, M5602_XB_SENSOR_CTRL, 0x00, 0x00},\n\n\t{BRIDGE, M5602_XB_SIG_INI, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x1d, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x08, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_EN_H, 0x3f, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DIR_H, 0x3f, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DAT_H, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_EN_L, 0xff, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DIR_L, 0xff, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DAT_L, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0xb0, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0x80, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0, 0x00},\n\t{BRIDGE, M5602_XB_ADC_CTRL, 0xc0, 0x00},\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x09, 0x00},\n\t{BRIDGE, M5602_XB_MCU_CLK_DIV, 0x02, 0x00},\n\t{BRIDGE, M5602_XB_MCU_CLK_CTRL, 0xb0, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xf0, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x1d, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x1c, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_EN_H, 0x06, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DIR_H, 0x06, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DAT_H, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_EN_L, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_I2C_CLK_DIV, 0x20, 0x00},\n};\n\n \nstatic const unsigned char init_s5k83a[][4] = {\n\t \n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x1d, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x08, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_EN_H, 0x3f, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DIR_H, 0x3f, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DAT_H, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_EN_L, 0xff, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DIR_L, 0xff, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DAT_L, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0xb0, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0x80, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0, 0x00},\n\t{BRIDGE, M5602_XB_ADC_CTRL, 0xc0, 0x00},\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x09, 0x00},\n\t{BRIDGE, M5602_XB_MCU_CLK_DIV, 0x02, 0x00},\n\t{BRIDGE, M5602_XB_MCU_CLK_CTRL, 0xb0, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xf0, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DIR, 0x1d, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DAT, 0x08, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_EN_H, 0x06, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DIR_H, 0x06, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_DAT_H, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_GPIO_EN_L, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_I2C_CLK_DIV, 0x20, 0x00},\n\n\t{SENSOR, S5K83A_PAGE_MAP, 0x04, 0x00},\n\t{SENSOR, 0xaf, 0x01, 0x00},\n\t{SENSOR, S5K83A_PAGE_MAP, 0x00, 0x00},\n\t{SENSOR, 0x7b, 0xff, 0x00},\n\t{SENSOR, S5K83A_PAGE_MAP, 0x05, 0x00},\n\t{SENSOR, 0x01, 0x50, 0x00},\n\t{SENSOR, 0x12, 0x20, 0x00},\n\t{SENSOR, 0x17, 0x40, 0x00},\n\t{SENSOR, 0x1c, 0x00, 0x00},\n\t{SENSOR, 0x02, 0x70, 0x00},\n\t{SENSOR, 0x03, 0x0b, 0x00},\n\t{SENSOR, 0x04, 0xf0, 0x00},\n\t{SENSOR, 0x05, 0x0b, 0x00},\n\t{SENSOR, 0x06, 0x71, 0x00},\n\t{SENSOR, 0x07, 0xe8, 0x00},  \n\t{SENSOR, 0x08, 0x02, 0x00},\n\t{SENSOR, 0x09, 0x88, 0x00},  \n\t{SENSOR, 0x14, 0x00, 0x00},\n\t{SENSOR, 0x15, 0x20, 0x00},  \n\t{SENSOR, 0x19, 0x00, 0x00},\n\t{SENSOR, 0x1a, 0x98, 0x00},  \n\t{SENSOR, 0x0f, 0x02, 0x00},\n\t{SENSOR, 0x10, 0xe5, 0x00},  \n\t \n\t{SENSOR, 0x00, 0x06, 0x00},\n};\n\nstatic const unsigned char start_s5k83a[][4] = {\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x06, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0, 0x00},\n\t{BRIDGE, M5602_XB_ADC_CTRL, 0xc0, 0x00},\n\t{BRIDGE, M5602_XB_SENSOR_TYPE, 0x09, 0x00},\n\t{BRIDGE, M5602_XB_LINE_OF_FRAME_H, 0x81, 0x00},\n\t{BRIDGE, M5602_XB_PIX_OF_LINE_H, 0x82, 0x00},\n\t{BRIDGE, M5602_XB_SIG_INI, 0x01, 0x00},\n\t{BRIDGE, M5602_XB_VSYNC_PARA, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_VSYNC_PARA, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_VSYNC_PARA, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_VSYNC_PARA, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_VSYNC_PARA, 0x01, 0x00},\n\t{BRIDGE, M5602_XB_VSYNC_PARA, 0xe4, 0x00},  \n\t{BRIDGE, M5602_XB_VSYNC_PARA, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_VSYNC_PARA, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_SIG_INI, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_SIG_INI, 0x02, 0x00},\n\t{BRIDGE, M5602_XB_HSYNC_PARA, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_HSYNC_PARA, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_HSYNC_PARA, 0x02, 0x00},\n\t{BRIDGE, M5602_XB_HSYNC_PARA, 0x7f, 0x00},  \n\t{BRIDGE, M5602_XB_SIG_INI, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_DIV, 0x00, 0x00},\n\t{BRIDGE, M5602_XB_SEN_CLK_CTRL, 0xb0, 0x00},\n};\n\nstatic void s5k83a_dump_registers(struct sd *sd);\nstatic int s5k83a_get_rotation(struct sd *sd, u8 *reg_data);\nstatic int s5k83a_set_led_indication(struct sd *sd, u8 val);\nstatic int s5k83a_set_flip_real(struct gspca_dev *gspca_dev,\n\t\t\t\t__s32 vflip, __s32 hflip);\n\nint s5k83a_probe(struct sd *sd)\n{\n\tu8 prod_id = 0, ver_id = 0;\n\tint i, err = 0;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tif (force_sensor) {\n\t\tif (force_sensor == S5K83A_SENSOR) {\n\t\t\tpr_info(\"Forcing a %s sensor\\n\", s5k83a.name);\n\t\t\tgoto sensor_found;\n\t\t}\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"Probing for a s5k83a sensor\\n\");\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(preinit_s5k83a) && !err; i++) {\n\t\tu8 data[2] = {preinit_s5k83a[i][2], preinit_s5k83a[i][3]};\n\t\tif (preinit_s5k83a[i][0] == SENSOR)\n\t\t\terr = m5602_write_sensor(sd, preinit_s5k83a[i][1],\n\t\t\t\tdata, 2);\n\t\telse\n\t\t\terr = m5602_write_bridge(sd, preinit_s5k83a[i][1],\n\t\t\t\tdata[0]);\n\t}\n\n\t \n\tif (m5602_read_sensor(sd, 0x00, &prod_id, 1))\n\t\treturn -ENODEV;\n\n\tif (m5602_read_sensor(sd, 0x01, &ver_id, 1))\n\t\treturn -ENODEV;\n\n\tif ((prod_id == 0xff) || (ver_id == 0xff))\n\t\treturn -ENODEV;\n\telse\n\t\tpr_info(\"Detected a s5k83a sensor\\n\");\n\nsensor_found:\n\tsd->gspca_dev.cam.cam_mode = s5k83a_modes;\n\tsd->gspca_dev.cam.nmodes = ARRAY_SIZE(s5k83a_modes);\n\n\t \n\tsd->rotation_thread = NULL;\n\n\treturn 0;\n}\n\nint s5k83a_init(struct sd *sd)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(init_s5k83a) && !err; i++) {\n\t\tu8 data[2] = {0x00, 0x00};\n\n\t\tswitch (init_s5k83a[i][0]) {\n\t\tcase BRIDGE:\n\t\t\terr = m5602_write_bridge(sd,\n\t\t\t\t\tinit_s5k83a[i][1],\n\t\t\t\t\tinit_s5k83a[i][2]);\n\t\t\tbreak;\n\n\t\tcase SENSOR:\n\t\t\tdata[0] = init_s5k83a[i][2];\n\t\t\terr = m5602_write_sensor(sd,\n\t\t\t\tinit_s5k83a[i][1], data, 1);\n\t\t\tbreak;\n\n\t\tcase SENSOR_LONG:\n\t\t\tdata[0] = init_s5k83a[i][2];\n\t\t\tdata[1] = init_s5k83a[i][3];\n\t\t\terr = m5602_write_sensor(sd,\n\t\t\t\tinit_s5k83a[i][1], data, 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"Invalid stream command, exiting init\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (dump_sensor)\n\t\ts5k83a_dump_registers(sd);\n\n\treturn err;\n}\n\nint s5k83a_init_controls(struct sd *sd)\n{\n\tstruct v4l2_ctrl_handler *hdl = &sd->gspca_dev.ctrl_handler;\n\n\tsd->gspca_dev.vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 6);\n\n\tv4l2_ctrl_new_std(hdl, &s5k83a_ctrl_ops, V4L2_CID_BRIGHTNESS,\n\t\t\t  0, 255, 1, S5K83A_DEFAULT_BRIGHTNESS);\n\n\tv4l2_ctrl_new_std(hdl, &s5k83a_ctrl_ops, V4L2_CID_EXPOSURE,\n\t\t\t  0, S5K83A_MAXIMUM_EXPOSURE, 1,\n\t\t\t  S5K83A_DEFAULT_EXPOSURE);\n\n\tv4l2_ctrl_new_std(hdl, &s5k83a_ctrl_ops, V4L2_CID_GAIN,\n\t\t\t  0, 255, 1, S5K83A_DEFAULT_GAIN);\n\n\tsd->hflip = v4l2_ctrl_new_std(hdl, &s5k83a_ctrl_ops, V4L2_CID_HFLIP,\n\t\t\t\t      0, 1, 1, 0);\n\tsd->vflip = v4l2_ctrl_new_std(hdl, &s5k83a_ctrl_ops, V4L2_CID_VFLIP,\n\t\t\t\t      0, 1, 1, 0);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\n\tv4l2_ctrl_cluster(2, &sd->hflip);\n\n\treturn 0;\n}\n\nstatic int rotation_thread_function(void *data)\n{\n\tstruct sd *sd = (struct sd *) data;\n\tu8 reg, previous_rotation = 0;\n\t__s32 vflip, hflip;\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!schedule_timeout(msecs_to_jiffies(100))) {\n\t\tif (mutex_lock_interruptible(&sd->gspca_dev.usb_lock))\n\t\t\tbreak;\n\n\t\ts5k83a_get_rotation(sd, &reg);\n\t\tif (previous_rotation != reg) {\n\t\t\tprevious_rotation = reg;\n\t\t\tpr_info(\"Camera was flipped\\n\");\n\n\t\t\thflip = sd->hflip->val;\n\t\t\tvflip = sd->vflip->val;\n\n\t\t\tif (reg) {\n\t\t\t\tvflip = !vflip;\n\t\t\t\thflip = !hflip;\n\t\t\t}\n\t\t\ts5k83a_set_flip_real((struct gspca_dev *) sd,\n\t\t\t\t\t      vflip, hflip);\n\t\t}\n\n\t\tmutex_unlock(&sd->gspca_dev.usb_lock);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\n\t \n\tif (previous_rotation) {\n\t\thflip = sd->hflip->val;\n\t\tvflip = sd->vflip->val;\n\t\ts5k83a_set_flip_real((struct gspca_dev *) sd, vflip, hflip);\n\t}\n\n\tsd->rotation_thread = NULL;\n\treturn 0;\n}\n\nint s5k83a_start(struct sd *sd)\n{\n\tint i, err = 0;\n\n\t \n\tsd->rotation_thread = kthread_run(rotation_thread_function,\n\t\t\t\t\t  sd, \"rotation thread\");\n\tif (IS_ERR(sd->rotation_thread)) {\n\t\terr = PTR_ERR(sd->rotation_thread);\n\t\tsd->rotation_thread = NULL;\n\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(start_s5k83a) && !err; i++) {\n\t\tu8 data[2] = {start_s5k83a[i][2], start_s5k83a[i][3]};\n\t\tif (start_s5k83a[i][0] == SENSOR)\n\t\t\terr = m5602_write_sensor(sd, start_s5k83a[i][1],\n\t\t\t\tdata, 2);\n\t\telse\n\t\t\terr = m5602_write_bridge(sd, start_s5k83a[i][1],\n\t\t\t\tdata[0]);\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\treturn s5k83a_set_led_indication(sd, 1);\n}\n\nint s5k83a_stop(struct sd *sd)\n{\n\tif (sd->rotation_thread)\n\t\tkthread_stop(sd->rotation_thread);\n\n\treturn s5k83a_set_led_indication(sd, 0);\n}\n\nvoid s5k83a_disconnect(struct sd *sd)\n{\n\ts5k83a_stop(sd);\n\n\tsd->sensor = NULL;\n}\n\nstatic int s5k83a_set_gain(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tu8 data[2];\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tdata[0] = 0x00;\n\tdata[1] = 0x20;\n\terr = m5602_write_sensor(sd, 0x14, data, 2);\n\tif (err < 0)\n\t\treturn err;\n\n\tdata[0] = 0x01;\n\tdata[1] = 0x00;\n\terr = m5602_write_sensor(sd, 0x0d, data, 2);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tdata[0] = val >> 3;  \n\tdata[1] = val >> 1;  \n\terr = m5602_write_sensor(sd, S5K83A_GAIN, data, 2);\n\n\treturn err;\n}\n\nstatic int s5k83a_set_brightness(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tu8 data[1];\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tdata[0] = val;\n\treturn m5602_write_sensor(sd, S5K83A_BRIGHTNESS, data, 1);\n}\n\nstatic int s5k83a_set_exposure(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tu8 data[2];\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tdata[0] = 0;\n\tdata[1] = val;\n\treturn m5602_write_sensor(sd, S5K83A_EXPOSURE, data, 2);\n}\n\nstatic int s5k83a_set_flip_real(struct gspca_dev *gspca_dev,\n\t\t\t\t__s32 vflip, __s32 hflip)\n{\n\tint err;\n\tu8 data[1];\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tdata[0] = 0x05;\n\terr = m5602_write_sensor(sd, S5K83A_PAGE_MAP, data, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tdata[0] = S5K83A_FLIP_MASK;\n\tdata[0] = (vflip) ? data[0] | 0x40 : data[0];\n\tdata[0] = (hflip) ? data[0] | 0x80 : data[0];\n\n\terr = m5602_write_sensor(sd, S5K83A_FLIP, data, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\tdata[0] = (vflip) ? 0x0b : 0x0a;\n\terr = m5602_write_sensor(sd, S5K83A_VFLIP_TUNE, data, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\tdata[0] = (hflip) ? 0x0a : 0x0b;\n\terr = m5602_write_sensor(sd, S5K83A_HFLIP_TUNE, data, 1);\n\treturn err;\n}\n\nstatic int s5k83a_set_hvflip(struct gspca_dev *gspca_dev)\n{\n\tint err;\n\tu8 reg;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint hflip = sd->hflip->val;\n\tint vflip = sd->vflip->val;\n\n\terr = s5k83a_get_rotation(sd, &reg);\n\tif (err < 0)\n\t\treturn err;\n\tif (reg) {\n\t\thflip = !hflip;\n\t\tvflip = !vflip;\n\t}\n\n\terr = s5k83a_set_flip_real(gspca_dev, vflip, hflip);\n\treturn err;\n}\n\nstatic int s5k83a_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tint err;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\terr = s5k83a_set_brightness(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE:\n\t\terr = s5k83a_set_exposure(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_GAIN:\n\t\terr = s5k83a_set_gain(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\terr = s5k83a_set_hvflip(gspca_dev);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic int s5k83a_set_led_indication(struct sd *sd, u8 val)\n{\n\tint err = 0;\n\tu8 data[1];\n\n\terr = m5602_read_bridge(sd, M5602_XB_GPIO_DAT, data);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (val)\n\t\tdata[0] = data[0] | S5K83A_GPIO_LED_MASK;\n\telse\n\t\tdata[0] = data[0] & ~S5K83A_GPIO_LED_MASK;\n\n\terr = m5602_write_bridge(sd, M5602_XB_GPIO_DAT, data[0]);\n\n\treturn err;\n}\n\n \nstatic int s5k83a_get_rotation(struct sd *sd, u8 *reg_data)\n{\n\tint err = m5602_read_bridge(sd, M5602_XB_GPIO_DAT, reg_data);\n\t*reg_data = (*reg_data & S5K83A_GPIO_ROTATION_MASK) ? 0 : 1;\n\treturn err;\n}\n\nstatic void s5k83a_dump_registers(struct sd *sd)\n{\n\tint address;\n\tu8 page, old_page;\n\tm5602_read_sensor(sd, S5K83A_PAGE_MAP, &old_page, 1);\n\n\tfor (page = 0; page < 16; page++) {\n\t\tm5602_write_sensor(sd, S5K83A_PAGE_MAP, &page, 1);\n\t\tpr_info(\"Dumping the s5k83a register state for page 0x%x\\n\",\n\t\t\tpage);\n\t\tfor (address = 0; address <= 0xff; address++) {\n\t\t\tu8 val = 0;\n\t\t\tm5602_read_sensor(sd, address, &val, 1);\n\t\t\tpr_info(\"register 0x%x contains 0x%x\\n\", address, val);\n\t\t}\n\t}\n\tpr_info(\"s5k83a register state dump complete\\n\");\n\n\tfor (page = 0; page < 16; page++) {\n\t\tm5602_write_sensor(sd, S5K83A_PAGE_MAP, &page, 1);\n\t\tpr_info(\"Probing for which registers that are read/write for page 0x%x\\n\",\n\t\t\tpage);\n\t\tfor (address = 0; address <= 0xff; address++) {\n\t\t\tu8 old_val, ctrl_val, test_val = 0xff;\n\n\t\t\tm5602_read_sensor(sd, address, &old_val, 1);\n\t\t\tm5602_write_sensor(sd, address, &test_val, 1);\n\t\t\tm5602_read_sensor(sd, address, &ctrl_val, 1);\n\n\t\t\tif (ctrl_val == test_val)\n\t\t\t\tpr_info(\"register 0x%x is writeable\\n\",\n\t\t\t\t\taddress);\n\t\t\telse\n\t\t\t\tpr_info(\"register 0x%x is read only\\n\",\n\t\t\t\t\taddress);\n\n\t\t\t \n\t\t\tm5602_write_sensor(sd, address, &old_val, 1);\n\t\t}\n\t}\n\tpr_info(\"Read/write register probing complete\\n\");\n\tm5602_write_sensor(sd, S5K83A_PAGE_MAP, &old_page, 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}