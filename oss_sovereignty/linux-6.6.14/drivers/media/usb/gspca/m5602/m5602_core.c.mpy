{
  "module_name": "m5602_core.c",
  "hash_id": "8fe779ece4a56c8ebeef35e2ddc18259c6f191df2176edca02deb7696226eec4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/m5602/m5602_core.c",
  "human_readable_source": "\n  \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"m5602_ov9650.h\"\n#include \"m5602_ov7660.h\"\n#include \"m5602_mt9m111.h\"\n#include \"m5602_po1030.h\"\n#include \"m5602_s5k83a.h\"\n#include \"m5602_s5k4aa.h\"\n\n \nint force_sensor;\nstatic bool dump_bridge;\nbool dump_sensor;\n\nstatic const struct usb_device_id m5602_table[] = {\n\t{USB_DEVICE(0x0402, 0x5602)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, m5602_table);\n\n \nstatic const unsigned char sensor_urb_skeleton[] = {\n\t0x23, M5602_XB_GPIO_EN_H, 0x81, 0x06,\n\t0x23, M5602_XB_MISC_CTRL, 0x81, 0x80,\n\t0x13, M5602_XB_I2C_DEV_ADDR, 0x81, 0x00,\n\t0x13, M5602_XB_I2C_REG_ADDR, 0x81, 0x00,\n\t0x13, M5602_XB_I2C_DATA, 0x81, 0x00,\n\t0x13, M5602_XB_I2C_CTRL, 0x81, 0x11\n};\n\n \nstatic const unsigned char bridge_urb_skeleton[] = {\n\t0x13, 0x00, 0x81, 0x00\n};\n\n \nint m5602_read_bridge(struct sd *sd, const u8 address, u8 *i2c_data)\n{\n\tint err;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *) sd;\n\tstruct usb_device *udev = sd->gspca_dev.dev;\n\t__u8 *buf = sd->gspca_dev.usb_buf;\n\n\terr = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t      0x04, 0xc0, 0x14,\n\t\t\t      0x8100 + address, buf,\n\t\t\t      1, M5602_URB_MSG_TIMEOUT);\n\t*i2c_data = buf[0];\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Reading bridge register 0x%x containing 0x%x\\n\",\n\t\t  address, *i2c_data);\n\n\t \n\treturn (err < 0) ? err : 0;\n}\n\n \nint m5602_write_bridge(struct sd *sd, const u8 address, const u8 i2c_data)\n{\n\tint err;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *) sd;\n\tstruct usb_device *udev = sd->gspca_dev.dev;\n\t__u8 *buf = sd->gspca_dev.usb_buf;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Writing bridge register 0x%x with 0x%x\\n\",\n\t\t  address, i2c_data);\n\n\tmemcpy(buf, bridge_urb_skeleton,\n\t       sizeof(bridge_urb_skeleton));\n\tbuf[1] = address;\n\tbuf[3] = i2c_data;\n\n\terr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t0x04, 0x40, 0x19,\n\t\t\t\t0x0000, buf,\n\t\t\t\t4, M5602_URB_MSG_TIMEOUT);\n\n\t \n\treturn (err < 0) ? err : 0;\n}\n\nstatic int m5602_wait_for_i2c(struct sd *sd)\n{\n\tint err;\n\tu8 data;\n\n\tdo {\n\t\terr = m5602_read_bridge(sd, M5602_XB_I2C_STATUS, &data);\n\t} while ((data & I2C_BUSY) && !err);\n\treturn err;\n}\n\nint m5602_read_sensor(struct sd *sd, const u8 address,\n\t\t       u8 *i2c_data, const u8 len)\n{\n\tint err, i;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *) sd;\n\n\tif (!len || len > sd->sensor->i2c_regW)\n\t\treturn -EINVAL;\n\n\terr = m5602_wait_for_i2c(sd);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_I2C_DEV_ADDR,\n\t\t\t\t sd->sensor->i2c_slave_id);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = m5602_write_bridge(sd, M5602_XB_I2C_REG_ADDR, address);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\n\t \n\tif (sd->sensor->i2c_regW == 1) {\n\t\terr = m5602_write_bridge(sd, M5602_XB_I2C_CTRL, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = m5602_write_bridge(sd, M5602_XB_I2C_CTRL, 0x08);\n\t} else {\n\t\terr = m5602_write_bridge(sd, M5602_XB_I2C_CTRL, 0x18 + len);\n\t}\n\n\tfor (i = 0; (i < len) && !err; i++) {\n\t\terr = m5602_wait_for_i2c(sd);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = m5602_read_bridge(sd, M5602_XB_I2C_DATA, &(i2c_data[i]));\n\n\t\tgspca_dbg(gspca_dev, D_CONF, \"Reading sensor register 0x%x containing 0x%x\\n\",\n\t\t\t  address, *i2c_data);\n\t}\n\treturn err;\n}\n\nint m5602_write_sensor(struct sd *sd, const u8 address,\n\t\t\tu8 *i2c_data, const u8 len)\n{\n\tint err, i;\n\tu8 *p;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *) sd;\n\tstruct usb_device *udev = sd->gspca_dev.dev;\n\t__u8 *buf = sd->gspca_dev.usb_buf;\n\n\t \n\tif (len > sd->sensor->i2c_regW || !len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, sensor_urb_skeleton,\n\t       sizeof(sensor_urb_skeleton));\n\n\tbuf[11] = sd->sensor->i2c_slave_id;\n\tbuf[15] = address;\n\n\t \n\tp = buf + 16;\n\n\t \n\tfor (i = 0; i < len; i++) {\n\t\tmemcpy(p, sensor_urb_skeleton + 16, 4);\n\t\tp[3] = i2c_data[i];\n\t\tp += 4;\n\t\tgspca_dbg(gspca_dev, D_CONF, \"Writing sensor register 0x%x with 0x%x\\n\",\n\t\t\t  address, i2c_data[i]);\n\t}\n\n\t \n\tmemcpy(p, sensor_urb_skeleton + 20, 4);\n\n\t \n\tp[3] = 0x10 + len;\n\n\terr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t      0x04, 0x40, 0x19,\n\t\t\t      0x0000, buf,\n\t\t\t      20 + len * 4, M5602_URB_MSG_TIMEOUT);\n\n\treturn (err < 0) ? err : 0;\n}\n\n \nstatic void m5602_dump_bridge(struct sd *sd)\n{\n\tint i;\n\tfor (i = 0; i < 0x80; i++) {\n\t\tunsigned char val = 0;\n\t\tm5602_read_bridge(sd, i, &val);\n\t\tpr_info(\"ALi m5602 address 0x%x contains 0x%x\\n\", i, val);\n\t}\n\tpr_info(\"Warning: The ALi m5602 webcam probably won't work until it's power cycled\\n\");\n}\n\nstatic int m5602_probe_sensor(struct sd *sd)\n{\n\t \n\tsd->sensor = &po1030;\n\tif (!sd->sensor->probe(sd))\n\t\treturn 0;\n\n\t \n\tsd->sensor = &mt9m111;\n\tif (!sd->sensor->probe(sd))\n\t\treturn 0;\n\n\t \n\tsd->sensor = &s5k4aa;\n\tif (!sd->sensor->probe(sd))\n\t\treturn 0;\n\n\t \n\tsd->sensor = &ov9650;\n\tif (!sd->sensor->probe(sd))\n\t\treturn 0;\n\n\t \n\tsd->sensor = &ov7660;\n\tif (!sd->sensor->probe(sd))\n\t\treturn 0;\n\n\t \n\tsd->sensor = &s5k83a;\n\tif (!sd->sensor->probe(sd))\n\t\treturn 0;\n\n\t \n\tpr_info(\"Failed to find a sensor\\n\");\n\tsd->sensor = NULL;\n\treturn -ENODEV;\n}\n\nstatic int m5602_configure(struct gspca_dev *gspca_dev,\n\t\t\t   const struct usb_device_id *id);\n\nstatic int m5602_init(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint err;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Initializing ALi m5602 webcam\\n\");\n\t \n\terr = sd->sensor->init(sd);\n\n\treturn err;\n}\n\nstatic int m5602_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (!sd->sensor->init_controls)\n\t\treturn 0;\n\n\treturn sd->sensor->init_controls(sd);\n}\n\nstatic int m5602_start_transfer(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\t__u8 *buf = sd->gspca_dev.usb_buf;\n\tint err;\n\n\t \n\tconst u8 buffer[4] = {0x13, 0xf9, 0x0f, 0x01};\n\n\tif (sd->sensor->start)\n\t\tsd->sensor->start(sd);\n\n\tmemcpy(buf, buffer, sizeof(buffer));\n\terr = usb_control_msg(gspca_dev->dev,\n\t\t\t      usb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t      0x04, 0x40, 0x19, 0x0000, buf,\n\t\t\t      sizeof(buffer), M5602_URB_MSG_TIMEOUT);\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"Transfer started\\n\");\n\treturn (err < 0) ? err : 0;\n}\n\nstatic void m5602_urb_complete(struct gspca_dev *gspca_dev,\n\t\t\t\tu8 *data, int len)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (len < 6) {\n\t\tgspca_dbg(gspca_dev, D_PACK, \"Packet is less than 6 bytes\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (data[0] == 0xff && data[4] == 0xff && data[5] == 0xff &&\n\t    data[2] != sd->frame_id) {\n\t\tgspca_dbg(gspca_dev, D_FRAM, \"Frame delimiter detected\\n\");\n\t\tsd->frame_id = data[2];\n\n\t\t \n\t\tdata += 6;\n\t\tlen -= 6;\n\n\t\t \n\t\tgspca_frame_add(gspca_dev, LAST_PACKET,\n\t\t\t\tNULL, 0);\n\t\tsd->frame_count++;\n\n\t\t \n\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, data, len);\n\n\t\tgspca_dbg(gspca_dev, D_FRAM, \"Starting new frame %d\\n\",\n\t\t\t  sd->frame_count);\n\n\t} else {\n\t\tint cur_frame_len;\n\n\t\tcur_frame_len = gspca_dev->image_len;\n\t\t \n\t\tdata += 4;\n\t\tlen -= 4;\n\n\t\tif (cur_frame_len + len <= gspca_dev->pixfmt.sizeimage) {\n\t\t\tgspca_dbg(gspca_dev, D_FRAM, \"Continuing frame %d copying %d bytes\\n\",\n\t\t\t\t  sd->frame_count, len);\n\n\t\t\tgspca_frame_add(gspca_dev, INTER_PACKET,\n\t\t\t\t\tdata, len);\n\t\t} else {\n\t\t\t \n\t\t\tgspca_frame_add(gspca_dev, INTER_PACKET, data,\n\t\t\t\tgspca_dev->pixfmt.sizeimage - cur_frame_len);\n\t\t}\n\t}\n}\n\nstatic void m5602_stop_transfer(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t \n\tif (sd->sensor->stop)\n\t\tsd->sensor->stop(sd);\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name\t\t= MODULE_NAME,\n\t.config\t\t= m5602_configure,\n\t.init\t\t= m5602_init,\n\t.init_controls\t= m5602_init_controls,\n\t.start\t\t= m5602_start_transfer,\n\t.stopN\t\t= m5602_stop_transfer,\n\t.pkt_scan\t= m5602_urb_complete\n};\n\n \nstatic int m5602_configure(struct gspca_dev *gspca_dev,\n\t\t\t   const struct usb_device_id *id)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam;\n\tint err;\n\n\tcam = &gspca_dev->cam;\n\n\tif (dump_bridge)\n\t\tm5602_dump_bridge(sd);\n\n\t \n\terr = m5602_probe_sensor(sd);\n\tif (err)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\tgspca_err(gspca_dev, \"ALi m5602 webcam failed\\n\");\n\tcam->cam_mode = NULL;\n\tcam->nmodes = 0;\n\n\treturn err;\n}\n\nstatic int m5602_probe(struct usb_interface *intf,\n\t\t       const struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t       THIS_MODULE);\n}\n\nstatic void m5602_disconnect(struct usb_interface *intf)\n{\n\tstruct gspca_dev *gspca_dev = usb_get_intfdata(intf);\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->sensor->disconnect)\n\t\tsd->sensor->disconnect(sd);\n\n\tgspca_disconnect(intf);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = m5602_table,\n\t.probe = m5602_probe,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n\t.disconnect = m5602_disconnect\n};\n\nmodule_usb_driver(sd_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nmodule_param(force_sensor, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(force_sensor,\n\t\t\"forces detection of a sensor, 1 = OV9650, 2 = S5K83A, 3 = S5K4AA, 4 = MT9M111, 5 = PO1030, 6 = OV7660\");\n\nmodule_param(dump_bridge, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(dump_bridge, \"Dumps all usb bridge registers at startup\");\n\nmodule_param(dump_sensor, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(dump_sensor, \"Dumps all usb sensor registers at startup providing a sensor is found\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}