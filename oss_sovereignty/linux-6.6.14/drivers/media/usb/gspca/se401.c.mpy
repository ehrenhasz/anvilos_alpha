{
  "module_name": "se401.c",
  "hash_id": "53893a875233439b581369c1abe564b45756a7d34987eb7bb819c85901dd50d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/se401.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"se401\"\n\n#define BULK_SIZE 4096\n#define PACKET_SIZE 1024\n#define READ_REQ_SIZE 64\n#define MAX_MODES ((READ_REQ_SIZE - 6) / 4)\n \n#define SE401_QUANT_FACT 8\n\n#include <linux/input.h>\n#include <linux/slab.h>\n#include \"gspca.h\"\n#include \"se401.h\"\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_DESCRIPTION(\"Endpoints se401\");\nMODULE_LICENSE(\"GPL\");\n\n \nenum {\n\tEXPO_CHANGED,\n\tEXPO_DROP_FRAME,\n\tEXPO_NO_CHANGE,\n};\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t \n\tstruct {  \n\t\tstruct v4l2_ctrl *exposure;\n\t\tstruct v4l2_ctrl *freq;\n\t};\n\tbool has_brightness;\n\tstruct v4l2_pix_format fmts[MAX_MODES];\n\tint pixels_read;\n\tint packet_read;\n\tu8 packet[PACKET_SIZE];\n\tu8 restart_stream;\n\tu8 button_state;\n\tu8 resetlevel;\n\tu8 resetlevel_frame_count;\n\tint resetlevel_adjust_dir;\n\tint expo_change_state;\n};\n\n\nstatic void se401_write_req(struct gspca_dev *gspca_dev, u16 req, u16 value,\n\t\t\t    int silent)\n{\n\tint err;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\n\terr = usb_control_msg(gspca_dev->dev,\n\t\t\t      usb_sndctrlpipe(gspca_dev->dev, 0), req,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      value, 0, NULL, 0, 1000);\n\tif (err < 0) {\n\t\tif (!silent)\n\t\t\tpr_err(\"write req failed req %#04x val %#04x error %d\\n\",\n\t\t\t       req, value, err);\n\t\tgspca_dev->usb_err = err;\n\t}\n}\n\nstatic void se401_read_req(struct gspca_dev *gspca_dev, u16 req, int silent)\n{\n\tint err;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\n\tif (USB_BUF_SZ < READ_REQ_SIZE) {\n\t\tpr_err(\"USB_BUF_SZ too small!!\\n\");\n\t\tgspca_dev->usb_err = -ENOBUFS;\n\t\treturn;\n\t}\n\n\terr = usb_control_msg(gspca_dev->dev,\n\t\t\t      usb_rcvctrlpipe(gspca_dev->dev, 0), req,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      0, 0, gspca_dev->usb_buf, READ_REQ_SIZE, 1000);\n\tif (err < 0) {\n\t\tif (!silent)\n\t\t\tpr_err(\"read req failed req %#04x error %d\\n\",\n\t\t\t       req, err);\n\t\tgspca_dev->usb_err = err;\n\t\t \n\t\tmemset(gspca_dev->usb_buf, 0, READ_REQ_SIZE);\n\t}\n}\n\nstatic void se401_set_feature(struct gspca_dev *gspca_dev,\n\t\t\t      u16 selector, u16 param)\n{\n\tint err;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\n\terr = usb_control_msg(gspca_dev->dev,\n\t\t\t      usb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t      SE401_REQ_SET_EXT_FEATURE,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      param, selector, NULL, 0, 1000);\n\tif (err < 0) {\n\t\tpr_err(\"set feature failed sel %#04x param %#04x error %d\\n\",\n\t\t       selector, param, err);\n\t\tgspca_dev->usb_err = err;\n\t}\n}\n\nstatic int se401_get_feature(struct gspca_dev *gspca_dev, u16 selector)\n{\n\tint err;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn gspca_dev->usb_err;\n\n\tif (USB_BUF_SZ < 2) {\n\t\tpr_err(\"USB_BUF_SZ too small!!\\n\");\n\t\tgspca_dev->usb_err = -ENOBUFS;\n\t\treturn gspca_dev->usb_err;\n\t}\n\n\terr = usb_control_msg(gspca_dev->dev,\n\t\t\t      usb_rcvctrlpipe(gspca_dev->dev, 0),\n\t\t\t      SE401_REQ_GET_EXT_FEATURE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      0, selector, gspca_dev->usb_buf, 2, 1000);\n\tif (err < 0) {\n\t\tpr_err(\"get feature failed sel %#04x error %d\\n\",\n\t\t       selector, err);\n\t\tgspca_dev->usb_err = err;\n\t\treturn err;\n\t}\n\treturn gspca_dev->usb_buf[0] | (gspca_dev->usb_buf[1] << 8);\n}\n\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\n{\n\t \n\tse401_write_req(gspca_dev, SE401_REQ_SET_BRT, val, 0);\n}\n\nstatic void setgain(struct gspca_dev *gspca_dev, s32 val)\n{\n\tu16 gain = 63 - val;\n\n\t \n\tse401_set_feature(gspca_dev, HV7131_REG_ARCG, gain);\n\t \n\tse401_set_feature(gspca_dev, HV7131_REG_AGCG, gain);\n\t \n\tse401_set_feature(gspca_dev, HV7131_REG_ABCG, gain);\n}\n\nstatic void setexposure(struct gspca_dev *gspca_dev, s32 val, s32 freq)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint integration = val << 6;\n\tu8 expose_h, expose_m, expose_l;\n\n\t \n\tsd->expo_change_state = EXPO_CHANGED;\n\n\tif (freq == V4L2_CID_POWER_LINE_FREQUENCY_50HZ)\n\t\tintegration = integration - integration % 106667;\n\tif (freq == V4L2_CID_POWER_LINE_FREQUENCY_60HZ)\n\t\tintegration = integration - integration % 88889;\n\n\texpose_h = (integration >> 16);\n\texpose_m = (integration >> 8);\n\texpose_l = integration;\n\n\t \n\tse401_set_feature(gspca_dev, HV7131_REG_TITL, expose_l);\n\t \n\tse401_set_feature(gspca_dev, HV7131_REG_TITM, expose_m);\n\t \n\tse401_set_feature(gspca_dev, HV7131_REG_TITU, expose_h);\n}\n\nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\tstruct cam *cam = &gspca_dev->cam;\n\tu8 *cd = gspca_dev->usb_buf;\n\tint i, j, n;\n\tint widths[MAX_MODES], heights[MAX_MODES];\n\n\t \n\tse401_read_req(gspca_dev, SE401_REQ_GET_CAMERA_DESCRIPTOR, 1);\n\tif (gspca_dev->usb_err) {\n\t\t \n\t\tusb_reset_device(gspca_dev->dev);\n\t\tgspca_dev->usb_err = 0;\n\t\tse401_read_req(gspca_dev, SE401_REQ_GET_CAMERA_DESCRIPTOR, 0);\n\t}\n\n\t \n\tse401_write_req(gspca_dev, SE401_REQ_LED_CONTROL, 0, 0);\n\tif (gspca_dev->usb_err)\n\t\treturn gspca_dev->usb_err;\n\n\tif (cd[1] != 0x41) {\n\t\tpr_err(\"Wrong descriptor type\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!(cd[2] & SE401_FORMAT_BAYER)) {\n\t\tpr_err(\"Bayer format not supported!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (cd[3])\n\t\tpr_info(\"ExtraFeatures: %d\\n\", cd[3]);\n\n\tn = cd[4] | (cd[5] << 8);\n\tif (n > MAX_MODES) {\n\t\tpr_err(\"Too many frame sizes\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < n ; i++) {\n\t\twidths[i] = cd[6 + i * 4 + 0] | (cd[6 + i * 4 + 1] << 8);\n\t\theights[i] = cd[6 + i * 4 + 2] | (cd[6 + i * 4 + 3] << 8);\n\t}\n\n\tfor (i = 0; i < n ; i++) {\n\t\tsd->fmts[i].width = widths[i];\n\t\tsd->fmts[i].height = heights[i];\n\t\tsd->fmts[i].field = V4L2_FIELD_NONE;\n\t\tsd->fmts[i].colorspace = V4L2_COLORSPACE_SRGB;\n\t\tsd->fmts[i].priv = 1;\n\n\t\t \n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (widths[j] / 2 == widths[i] &&\n\t\t\t    heights[j] / 2 == heights[i]) {\n\t\t\t\tsd->fmts[i].priv = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (widths[j] / 4 == widths[i] &&\n\t\t\t    heights[j] / 4 == heights[i]) {\n\t\t\t\tsd->fmts[i].priv = 4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (sd->fmts[i].priv == 1) {\n\t\t\t \n\t\t\tsd->fmts[i].pixelformat = V4L2_PIX_FMT_SBGGR8;\n\t\t\tsd->fmts[i].bytesperline = widths[i];\n\t\t\tsd->fmts[i].sizeimage = widths[i] * heights[i];\n\t\t\tpr_info(\"Frame size: %dx%d bayer\\n\",\n\t\t\t\twidths[i], heights[i]);\n\t\t} else {\n\t\t\t \n\t\t\tsd->fmts[i].pixelformat = V4L2_PIX_FMT_SE401;\n\t\t\tsd->fmts[i].bytesperline = 0;\n\t\t\tsd->fmts[i].sizeimage = widths[i] * heights[i] * 3;\n\t\t\tpr_info(\"Frame size: %dx%d 1/%dth janggu\\n\",\n\t\t\t\twidths[i], heights[i],\n\t\t\t\tsd->fmts[i].priv * sd->fmts[i].priv);\n\t\t}\n\t}\n\n\tcam->cam_mode = sd->fmts;\n\tcam->nmodes = n;\n\tcam->bulk = 1;\n\tcam->bulk_size = BULK_SIZE;\n\tcam->bulk_nurbs = 4;\n\tsd->resetlevel = 0x2d;  \n\n\t \n\tse401_read_req(gspca_dev, SE401_REQ_GET_BRT, 1);\n\tsd->has_brightness = !!gspca_dev->usb_err;\n\tgspca_dev->usb_err = 0;\n\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\treturn 0;\n}\n\n \nstatic int sd_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tgspca_dev->alt = 1;\t \n\n\treturn gspca_dev->usb_err;\n}\n\n \nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\tint mult = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\n\tint mode = 0;\n\n\tse401_write_req(gspca_dev, SE401_REQ_CAMERA_POWER, 1, 1);\n\tif (gspca_dev->usb_err) {\n\t\t \n\t\tusb_reset_device(gspca_dev->dev);\n\t\tgspca_dev->usb_err = 0;\n\t\tse401_write_req(gspca_dev, SE401_REQ_CAMERA_POWER, 1, 0);\n\t}\n\tse401_write_req(gspca_dev, SE401_REQ_LED_CONTROL, 1, 0);\n\n\tse401_set_feature(gspca_dev, HV7131_REG_MODE_B, 0x05);\n\n\t \n\tse401_write_req(gspca_dev, SE401_REQ_SET_WIDTH,\n\t\t\tgspca_dev->pixfmt.width * mult, 0);\n\tse401_write_req(gspca_dev, SE401_REQ_SET_HEIGHT,\n\t\t\tgspca_dev->pixfmt.height * mult, 0);\n\t \n\n\tswitch (mult) {\n\tcase 1:  \n\t\tmode = 0x03; break;\n\tcase 2:  \n\t\tmode = SE401_QUANT_FACT << 4; break;\n\tcase 4:  \n\t\tmode = (SE401_QUANT_FACT << 4) | 0x02; break;\n\t}\n\tse401_set_feature(gspca_dev, SE401_OPERATINGMODE, mode);\n\n\tse401_set_feature(gspca_dev, HV7131_REG_ARLV, sd->resetlevel);\n\n\tsd->packet_read = 0;\n\tsd->pixels_read = 0;\n\tsd->restart_stream = 0;\n\tsd->resetlevel_frame_count = 0;\n\tsd->resetlevel_adjust_dir = 0;\n\tsd->expo_change_state = EXPO_NO_CHANGE;\n\n\tse401_write_req(gspca_dev, SE401_REQ_START_CONTINUOUS_CAPTURE, 0, 0);\n\n\treturn gspca_dev->usb_err;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\tse401_write_req(gspca_dev, SE401_REQ_STOP_CONTINUOUS_CAPTURE, 0, 0);\n\tse401_write_req(gspca_dev, SE401_REQ_LED_CONTROL, 0, 0);\n\tse401_write_req(gspca_dev, SE401_REQ_CAMERA_POWER, 0, 0);\n}\n\nstatic void sd_dq_callback(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\tunsigned int ahrc, alrc;\n\tint oldreset, adjust_dir;\n\n\t \n\tif (sd->restart_stream) {\n\t\tsd_stopN(gspca_dev);\n\t\tsd_start(gspca_dev);\n\t\tsd->restart_stream = 0;\n\t}\n\n\t \n\tsd->resetlevel_frame_count++;\n\tif (sd->resetlevel_frame_count < 20)\n\t\treturn;\n\n\t \n\tse401_get_feature(gspca_dev, HV7131_REG_HIREFNOH);\n\tse401_get_feature(gspca_dev, HV7131_REG_HIREFNOL);\n\tse401_get_feature(gspca_dev, HV7131_REG_LOREFNOH);\n\tse401_get_feature(gspca_dev, HV7131_REG_LOREFNOL);\n\tahrc = 256*se401_get_feature(gspca_dev, HV7131_REG_HIREFNOH) +\n\t    se401_get_feature(gspca_dev, HV7131_REG_HIREFNOL);\n\talrc = 256*se401_get_feature(gspca_dev, HV7131_REG_LOREFNOH) +\n\t    se401_get_feature(gspca_dev, HV7131_REG_LOREFNOL);\n\n\t \n\toldreset = sd->resetlevel;\n\tif (alrc > 10) {\n\t\twhile (alrc >= 10 && sd->resetlevel < 63) {\n\t\t\tsd->resetlevel++;\n\t\t\talrc /= 2;\n\t\t}\n\t} else if (ahrc > 20) {\n\t\twhile (ahrc >= 20 && sd->resetlevel > 0) {\n\t\t\tsd->resetlevel--;\n\t\t\tahrc /= 2;\n\t\t}\n\t}\n\t \n\tif (sd->resetlevel > oldreset)\n\t\tadjust_dir = 1;\n\telse\n\t\tadjust_dir = -1;\n\tif (sd->resetlevel_adjust_dir &&\n\t    sd->resetlevel_adjust_dir != adjust_dir)\n\t\tsd->resetlevel = oldreset + (sd->resetlevel - oldreset) / 2;\n\n\tif (sd->resetlevel != oldreset) {\n\t\tsd->resetlevel_adjust_dir = adjust_dir;\n\t\tse401_set_feature(gspca_dev, HV7131_REG_ARLV, sd->resetlevel);\n\t}\n\n\tsd->resetlevel_frame_count = 0;\n}\n\nstatic void sd_complete_frame(struct gspca_dev *gspca_dev, u8 *data, int len)\n{\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\n\tswitch (sd->expo_change_state) {\n\tcase EXPO_CHANGED:\n\t\t \n\t\tsd->expo_change_state = EXPO_DROP_FRAME;\n\t\tbreak;\n\tcase EXPO_DROP_FRAME:\n\t\t \n\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\tsd->expo_change_state = EXPO_NO_CHANGE;\n\t\tbreak;\n\tcase EXPO_NO_CHANGE:\n\t\tbreak;\n\t}\n\tgspca_frame_add(gspca_dev, LAST_PACKET, data, len);\n}\n\nstatic void sd_pkt_scan_janggu(struct gspca_dev *gspca_dev, u8 *data, int len)\n{\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\tint imagesize = gspca_dev->pixfmt.width * gspca_dev->pixfmt.height;\n\tint i, plen, bits, pixels, info, count;\n\n\tif (sd->restart_stream)\n\t\treturn;\n\n\t \n\tif (gspca_dev->last_packet_type == LAST_PACKET && len == 1024) {\n\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\treturn;\n\t}\n\n\ti = 0;\n\twhile (i < len) {\n\t\t \n\t\tif (sd->packet_read < 4) {\n\t\t\tcount = 4 - sd->packet_read;\n\t\t\tif (count > len - i)\n\t\t\t\tcount = len - i;\n\t\t\tmemcpy(&sd->packet[sd->packet_read], &data[i], count);\n\t\t\tsd->packet_read += count;\n\t\t\ti += count;\n\t\t\tif (sd->packet_read < 4)\n\t\t\t\tbreak;\n\t\t}\n\t\tbits   = sd->packet[3] + (sd->packet[2] << 8);\n\t\tpixels = sd->packet[1] + ((sd->packet[0] & 0x3f) << 8);\n\t\tinfo   = (sd->packet[0] & 0xc0) >> 6;\n\t\tplen   = ((bits + 47) >> 4) << 1;\n\t\t \n\t\tif (plen > 1024) {\n\t\t\tpr_err(\"invalid packet len %d restarting stream\\n\",\n\t\t\t       plen);\n\t\t\tgoto error;\n\t\t}\n\t\tif (info == 3) {\n\t\t\tpr_err(\"unknown frame info value restarting stream\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tcount = plen - sd->packet_read;\n\t\tif (count > len - i)\n\t\t\tcount = len - i;\n\t\tmemcpy(&sd->packet[sd->packet_read], &data[i], count);\n\t\tsd->packet_read += count;\n\t\ti += count;\n\t\tif (sd->packet_read < plen)\n\t\t\tbreak;\n\n\t\tsd->pixels_read += pixels;\n\t\tsd->packet_read = 0;\n\n\t\tswitch (info) {\n\t\tcase 0:  \n\t\t\tgspca_frame_add(gspca_dev, INTER_PACKET, sd->packet,\n\t\t\t\t\tplen);\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tif (sd->pixels_read != imagesize) {\n\t\t\t\tpr_err(\"frame size %d expected %d\\n\",\n\t\t\t\t       sd->pixels_read, imagesize);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tsd_complete_frame(gspca_dev, sd->packet, plen);\n\t\t\treturn;  \n\t\tcase 2:  \n\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, sd->packet,\n\t\t\t\t\tplen);\n\t\t\tsd->pixels_read = pixels;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn;\n\nerror:\n\tsd->restart_stream = 1;\n\t \n\tgspca_frame_add(gspca_dev, FIRST_PACKET, NULL, 0);\n\tgspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\n}\n\nstatic void sd_pkt_scan_bayer(struct gspca_dev *gspca_dev, u8 *data, int len)\n{\n\tstruct cam *cam = &gspca_dev->cam;\n\tint imagesize = cam->cam_mode[gspca_dev->curr_mode].sizeimage;\n\n\tif (gspca_dev->image_len == 0) {\n\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, data, len);\n\t\treturn;\n\t}\n\n\tif (gspca_dev->image_len + len >= imagesize) {\n\t\tsd_complete_frame(gspca_dev, data, len);\n\t\treturn;\n\t}\n\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev, u8 *data, int len)\n{\n\tint mult = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\n\n\tif (len == 0)\n\t\treturn;\n\n\tif (mult == 1)  \n\t\tsd_pkt_scan_bayer(gspca_dev, data, len);\n\telse\n\t\tsd_pkt_scan_janggu(gspca_dev, data, len);\n}\n\n#if IS_ENABLED(CONFIG_INPUT)\nstatic int sd_int_pkt_scan(struct gspca_dev *gspca_dev, u8 *data, int len)\n{\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\tu8 state;\n\n\tif (len != 2)\n\t\treturn -EINVAL;\n\n\tswitch (data[0]) {\n\tcase 0:\n\tcase 1:\n\t\tstate = data[0];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (sd->button_state != state) {\n\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, state);\n\t\tinput_sync(gspca_dev->input_dev);\n\t\tsd->button_state = state;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsetbrightness(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_GAIN:\n\t\tsetgain(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE:\n\t\tsetexposure(gspca_dev, ctrl->val, sd->freq->val);\n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 4);\n\tif (sd->has_brightness)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 255, 1, 15);\n\t \n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, 0, 50, 1, 25);\n\tsd->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE, 0, 32767, 1, 15000);\n\tsd->freq = v4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_POWER_LINE_FREQUENCY,\n\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_60HZ, 0, 0);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\tv4l2_ctrl_cluster(2, &sd->exposure);\n\treturn 0;\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.isoc_init = sd_isoc_init,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.dq_callback = sd_dq_callback,\n\t.pkt_scan = sd_pkt_scan,\n#if IS_ENABLED(CONFIG_INPUT)\n\t.int_pkt_scan = sd_int_pkt_scan,\n#endif\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x03e8, 0x0004)},  \n\t{USB_DEVICE(0x0471, 0x030b)},  \n\t{USB_DEVICE(0x047d, 0x5001)},  \n\t{USB_DEVICE(0x047d, 0x5002)},  \n\t{USB_DEVICE(0x047d, 0x5003)},  \n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t\tTHIS_MODULE);\n}\n\nstatic int sd_pre_reset(struct usb_interface *intf)\n{\n\treturn 0;\n}\n\nstatic int sd_post_reset(struct usb_interface *intf)\n{\n\treturn 0;\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n\t.pre_reset = sd_pre_reset,\n\t.post_reset = sd_post_reset,\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}