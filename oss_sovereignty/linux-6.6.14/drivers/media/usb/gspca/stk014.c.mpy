{
  "module_name": "stk014.c",
  "hash_id": "89ec8f59ee269bff43ad73b482ee8a7b2bb9c4fccc24124b4c7dd993bccc5d59",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/stk014.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"stk014\"\n\n#include \"gspca.h\"\n#include \"jpeg.h\"\n\nMODULE_AUTHOR(\"Jean-Francois Moine <http://moinejf.free.fr>\");\nMODULE_DESCRIPTION(\"Syntek DV4000 (STK014) USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define QUALITY 50\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t \n\tu8 jpeg_hdr[JPEG_HDR_SZ];\n};\n\nstatic const struct v4l2_pix_format vga_mode[] = {\n\t{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 1},\n\t{640, 480, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n};\n\n \nstatic u8 reg_r(struct gspca_dev *gspca_dev,\n\t\t\t__u16 index)\n{\n\tstruct usb_device *dev = gspca_dev->dev;\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn 0;\n\tret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t0x00,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0x00,\n\t\t\tindex,\n\t\t\tgspca_dev->usb_buf, 1,\n\t\t\t500);\n\tif (ret < 0) {\n\t\tpr_err(\"reg_r err %d\\n\", ret);\n\t\tgspca_dev->usb_err = ret;\n\t\treturn 0;\n\t}\n\treturn gspca_dev->usb_buf[0];\n}\n\n \nstatic void reg_w(struct gspca_dev *gspca_dev,\n\t\t\t__u16 index, __u16 value)\n{\n\tstruct usb_device *dev = gspca_dev->dev;\n\tint ret;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t0x01,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tvalue,\n\t\t\tindex,\n\t\t\tNULL,\n\t\t\t0,\n\t\t\t500);\n\tif (ret < 0) {\n\t\tpr_err(\"reg_w err %d\\n\", ret);\n\t\tgspca_dev->usb_err = ret;\n\t}\n}\n\n \nstatic void rcv_val(struct gspca_dev *gspca_dev,\n\t\t\tint ads)\n{\n\tstruct usb_device *dev = gspca_dev->dev;\n\tint alen, ret;\n\n\treg_w(gspca_dev, 0x634, (ads >> 16) & 0xff);\n\treg_w(gspca_dev, 0x635, (ads >> 8) & 0xff);\n\treg_w(gspca_dev, 0x636, ads & 0xff);\n\treg_w(gspca_dev, 0x637, 0);\n\treg_w(gspca_dev, 0x638, 4);\t \n\treg_w(gspca_dev, 0x639, 0);\t \n\treg_w(gspca_dev, 0x63a, 0);\n\treg_w(gspca_dev, 0x63b, 0);\n\treg_w(gspca_dev, 0x630, 5);\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tret = usb_bulk_msg(dev,\n\t\t\tusb_rcvbulkpipe(dev, 0x05),\n\t\t\tgspca_dev->usb_buf,\n\t\t\t4,\t\t \n\t\t\t&alen,\n\t\t\t500);\t\t \n\tif (ret < 0) {\n\t\tpr_err(\"rcv_val err %d\\n\", ret);\n\t\tgspca_dev->usb_err = ret;\n\t}\n}\n\n \nstatic void snd_val(struct gspca_dev *gspca_dev,\n\t\t\tint ads,\n\t\t\tunsigned int val)\n{\n\tstruct usb_device *dev = gspca_dev->dev;\n\tint alen, ret;\n\t__u8 seq = 0;\n\n\tif (ads == 0x003f08) {\n\t\treg_r(gspca_dev, 0x0704);\n\t\tseq = reg_r(gspca_dev, 0x0705);\n\t\treg_r(gspca_dev, 0x0650);\n\t\treg_w(gspca_dev, 0x654, seq);\n\t} else {\n\t\treg_w(gspca_dev, 0x654, (ads >> 16) & 0xff);\n\t}\n\treg_w(gspca_dev, 0x655, (ads >> 8) & 0xff);\n\treg_w(gspca_dev, 0x656, ads & 0xff);\n\treg_w(gspca_dev, 0x657, 0);\n\treg_w(gspca_dev, 0x658, 0x04);\t \n\treg_w(gspca_dev, 0x659, 0);\n\treg_w(gspca_dev, 0x65a, 0);\n\treg_w(gspca_dev, 0x65b, 0);\n\treg_w(gspca_dev, 0x650, 5);\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tgspca_dev->usb_buf[0] = val >> 24;\n\tgspca_dev->usb_buf[1] = val >> 16;\n\tgspca_dev->usb_buf[2] = val >> 8;\n\tgspca_dev->usb_buf[3] = val;\n\tret = usb_bulk_msg(dev,\n\t\t\tusb_sndbulkpipe(dev, 6),\n\t\t\tgspca_dev->usb_buf,\n\t\t\t4,\n\t\t\t&alen,\n\t\t\t500);\t \n\tif (ret < 0) {\n\t\tpr_err(\"snd_val err %d\\n\", ret);\n\t\tgspca_dev->usb_err = ret;\n\t} else {\n\t\tif (ads == 0x003f08) {\n\t\t\tseq += 4;\n\t\t\tseq &= 0x3f;\n\t\t\treg_w(gspca_dev, 0x705, seq);\n\t\t}\n\t}\n}\n\n \nstatic void set_par(struct gspca_dev *gspca_dev,\n\t\t   int parval)\n{\n\tsnd_val(gspca_dev, 0x003f08, parval);\n}\n\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\n{\n\tint parval;\n\n\tparval = 0x06000000\t\t \n\t\t+ (val << 16);\n\tset_par(gspca_dev, parval);\n}\n\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 val)\n{\n\tint parval;\n\n\tparval = 0x07000000\t\t \n\t\t+ (val << 16);\n\tset_par(gspca_dev, parval);\n}\n\nstatic void setcolors(struct gspca_dev *gspca_dev, s32 val)\n{\n\tint parval;\n\n\tparval = 0x08000000\t\t \n\t\t+ (val << 16);\n\tset_par(gspca_dev, parval);\n}\n\nstatic void setlightfreq(struct gspca_dev *gspca_dev, s32 val)\n{\n\tset_par(gspca_dev, val == 1\n\t\t\t? 0x33640000\t\t \n\t\t\t: 0x33780000);\t\t \n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id)\n{\n\tgspca_dev->cam.cam_mode = vga_mode;\n\tgspca_dev->cam.nmodes = ARRAY_SIZE(vga_mode);\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\tu8 ret;\n\n\t \n\tusb_set_interface(gspca_dev->dev, gspca_dev->iface, 1);\n\tret = reg_r(gspca_dev, 0x0740);\n\tif (gspca_dev->usb_err >= 0) {\n\t\tif (ret != 0xff) {\n\t\t\tpr_err(\"init reg: 0x%02x\\n\", ret);\n\t\t\tgspca_dev->usb_err = -EIO;\n\t\t}\n\t}\n\treturn gspca_dev->usb_err;\n}\n\n \nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint ret, value;\n\n\t \n\tjpeg_define(sd->jpeg_hdr, gspca_dev->pixfmt.height,\n\t\t\tgspca_dev->pixfmt.width,\n\t\t\t0x22);\t\t \n\tjpeg_set_qual(sd->jpeg_hdr, QUALITY);\n\n\t \n\tusb_set_interface(gspca_dev->dev, gspca_dev->iface, 1);\n\n\tset_par(gspca_dev, 0x10000000);\n\tset_par(gspca_dev, 0x00000000);\n\tset_par(gspca_dev, 0x8002e001);\n\tset_par(gspca_dev, 0x14000000);\n\tif (gspca_dev->pixfmt.width > 320)\n\t\tvalue = 0x8002e001;\t\t \n\telse\n\t\tvalue = 0x4001f000;\t\t \n\tset_par(gspca_dev, value);\n\tret = usb_set_interface(gspca_dev->dev,\n\t\t\t\t\tgspca_dev->iface,\n\t\t\t\t\tgspca_dev->alt);\n\tif (ret < 0) {\n\t\tpr_err(\"set intf %d %d failed\\n\",\n\t\t       gspca_dev->iface, gspca_dev->alt);\n\t\tgspca_dev->usb_err = ret;\n\t\tgoto out;\n\t}\n\treg_r(gspca_dev, 0x0630);\n\trcv_val(gspca_dev, 0x000020);\t \n\treg_r(gspca_dev, 0x0650);\n\tsnd_val(gspca_dev, 0x000020, 0xffffffff);\n\treg_w(gspca_dev, 0x0620, 0);\n\treg_w(gspca_dev, 0x0630, 0);\n\treg_w(gspca_dev, 0x0640, 0);\n\treg_w(gspca_dev, 0x0650, 0);\n\treg_w(gspca_dev, 0x0660, 0);\n\tset_par(gspca_dev, 0x09800000);\t\t \n\tset_par(gspca_dev, 0x0a800000);\t\t \n\tset_par(gspca_dev, 0x0b800000);\t\t \n\tset_par(gspca_dev, 0x0d030000);\t\t \n\n\t \n\tset_par(gspca_dev, 0x01000000);\n\tset_par(gspca_dev, 0x01000000);\n\tif (gspca_dev->usb_err >= 0)\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"camera started alt: 0x%02x\\n\",\n\t\t\t  gspca_dev->alt);\nout:\n\treturn gspca_dev->usb_err;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_device *dev = gspca_dev->dev;\n\n\tset_par(gspca_dev, 0x02000000);\n\tset_par(gspca_dev, 0x02000000);\n\tusb_set_interface(dev, gspca_dev->iface, 1);\n\treg_r(gspca_dev, 0x0630);\n\trcv_val(gspca_dev, 0x000020);\t \n\treg_r(gspca_dev, 0x0650);\n\tsnd_val(gspca_dev, 0x000020, 0xffffffff);\n\treg_w(gspca_dev, 0x0620, 0);\n\treg_w(gspca_dev, 0x0630, 0);\n\treg_w(gspca_dev, 0x0640, 0);\n\treg_w(gspca_dev, 0x0650, 0);\n\treg_w(gspca_dev, 0x0660, 0);\n\tgspca_dbg(gspca_dev, D_STREAM, \"camera stopped\\n\");\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t \n\t\t\tint len)\t\t\t \n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstatic unsigned char ffd9[] = {0xff, 0xd9};\n\n\t \n\tif (data[0] == 0xff && data[1] == 0xfe) {\n\t\tgspca_frame_add(gspca_dev, LAST_PACKET,\n\t\t\t\tffd9, 2);\n\n\t\t \n\t\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\t\tsd->jpeg_hdr, JPEG_HDR_SZ);\n\n\t\t \n#define STKHDRSZ 12\n\t\tdata += STKHDRSZ;\n\t\tlen -= STKHDRSZ;\n\t}\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\n\tgspca_dev->usb_err = 0;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsetbrightness(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tsetcontrast(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tsetcolors(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_POWER_LINE_FREQUENCY:\n\t\tsetlightfreq(gspca_dev, ctrl->val);\n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 4);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 255, 1, 127);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 255, 1, 127);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 255, 1, 127);\n\tv4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_POWER_LINE_FREQUENCY,\n\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_60HZ, 1,\n\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_50HZ);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\treturn 0;\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.pkt_scan = sd_pkt_scan,\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x05e1, 0x0893)},\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}