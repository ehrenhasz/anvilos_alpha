{
  "module_name": "finepix.c",
  "hash_id": "3c448116f3ac841c103d280ca6097c16ad37e7b72a62f34d85f1cedae8f64aa8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/finepix.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"finepix\"\n\n#include \"gspca.h\"\n\nMODULE_AUTHOR(\"Frank Zago <frank@zago.net>\");\nMODULE_DESCRIPTION(\"Fujifilm FinePix USB V4L2 driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define FPIX_TIMEOUT 250\n\n \n#define FPIX_MAX_TRANSFER 0x2000\n\n \nstruct usb_fpix {\n\tstruct gspca_dev gspca_dev;\t \n\n\tstruct work_struct work_struct;\n};\n\n \n#define NEXT_FRAME_DELAY 35\n\n \nstatic const struct v4l2_pix_format fpix_mode[1] = {\n\t{ 320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 3 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0}\n};\n\n \nstatic int command(struct gspca_dev *gspca_dev,\n\t\tint order)\t \n{\n\tstatic u8 order_values[2][12] = {\n\t\t{0xc6, 0, 0, 0, 0, 0, 0,    0, 0x20, 0, 0, 0},\t \n\t\t{0xd3, 0, 0, 0, 0, 0, 0, 0x01,    0, 0, 0, 0},\t \n\t};\n\n\tmemcpy(gspca_dev->usb_buf, order_values[order], 12);\n\treturn usb_control_msg(gspca_dev->dev,\n\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\tUSB_REQ_GET_STATUS,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS |\n\t\t\tUSB_RECIP_INTERFACE, 0, 0, gspca_dev->usb_buf,\n\t\t\t12, FPIX_TIMEOUT);\n}\n\n \nstatic void dostream(struct work_struct *work)\n{\n\tstruct usb_fpix *dev = container_of(work, struct usb_fpix, work_struct);\n\tstruct gspca_dev *gspca_dev = &dev->gspca_dev;\n\tstruct urb *urb = gspca_dev->urb[0];\n\tu8 *data = urb->transfer_buffer;\n\tint ret = 0;\n\tint len;\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"dostream started\\n\");\n\n\t \nagain:\n\twhile (gspca_dev->present && gspca_dev->streaming) {\n#ifdef CONFIG_PM\n\t\tif (gspca_dev->frozen)\n\t\t\tbreak;\n#endif\n\n\t\t \n\t\tmutex_lock(&gspca_dev->usb_lock);\n\t\tret = command(gspca_dev, 1);\n\t\tmutex_unlock(&gspca_dev->usb_lock);\n\t\tif (ret < 0)\n\t\t\tbreak;\n#ifdef CONFIG_PM\n\t\tif (gspca_dev->frozen)\n\t\t\tbreak;\n#endif\n\t\tif (!gspca_dev->present || !gspca_dev->streaming)\n\t\t\tbreak;\n\n\t\t \n\t\tfor (;;) {\n\t\t\tret = usb_bulk_msg(gspca_dev->dev,\n\t\t\t\t\turb->pipe,\n\t\t\t\t\tdata,\n\t\t\t\t\tFPIX_MAX_TRANSFER,\n\t\t\t\t\t&len, FPIX_TIMEOUT);\n\t\t\tif (ret < 0) {\n\t\t\t\t \n\t\t\t\tgoto again;\n\t\t\t}\n#ifdef CONFIG_PM\n\t\t\tif (gspca_dev->frozen)\n\t\t\t\tgoto out;\n#endif\n\t\t\tif (!gspca_dev->present || !gspca_dev->streaming)\n\t\t\t\tgoto out;\n\t\t\tif (len < FPIX_MAX_TRANSFER ||\n\t\t\t\t(data[len - 2] == 0xff &&\n\t\t\t\t\tdata[len - 1] == 0xd9)) {\n\n\t\t\t\t \n\t\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET,\n\t\t\t\t\t\tdata, len);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tgspca_frame_add(gspca_dev,\n\t\t\t\t\tgspca_dev->last_packet_type\n\t\t\t\t\t\t== LAST_PACKET\n\t\t\t\t\t? FIRST_PACKET : INTER_PACKET,\n\t\t\t\t\tdata, len);\n\t\t}\n\n\t\t \n\t\tmsleep(NEXT_FRAME_DELAY);\n\t}\n\nout:\n\tgspca_dbg(gspca_dev, D_STREAM, \"dostream stopped\\n\");\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_fpix *dev = (struct usb_fpix *) gspca_dev;\n\tstruct cam *cam = &gspca_dev->cam;\n\n\tcam->cam_mode = fpix_mode;\n\tcam->nmodes = 1;\n\tcam->bulk = 1;\n\tcam->bulk_size = FPIX_MAX_TRANSFER;\n\n\tINIT_WORK(&dev->work_struct, dostream);\n\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\treturn 0;\n}\n\n \nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_fpix *dev = (struct usb_fpix *) gspca_dev;\n\tint ret, len;\n\n\t \n\tret = command(gspca_dev, 0);\n\tif (ret < 0) {\n\t\tpr_err(\"init failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = usb_bulk_msg(gspca_dev->dev,\n\t\t\tgspca_dev->urb[0]->pipe,\n\t\t\tgspca_dev->urb[0]->transfer_buffer,\n\t\t\tFPIX_MAX_TRANSFER, &len,\n\t\t\tFPIX_TIMEOUT);\n\tif (ret < 0) {\n\t\tpr_err(\"usb_bulk_msg failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = command(gspca_dev, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"frame request failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tusb_clear_halt(gspca_dev->dev, gspca_dev->urb[0]->pipe);\n\n\tschedule_work(&dev->work_struct);\n\n\treturn 0;\n}\n\n \n \nstatic void sd_stop0(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_fpix *dev = (struct usb_fpix *) gspca_dev;\n\n\t \n\tmutex_unlock(&gspca_dev->usb_lock);\n\tflush_work(&dev->work_struct);\n\tmutex_lock(&gspca_dev->usb_lock);\n}\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x04cb, 0x0104)},\n\t{USB_DEVICE(0x04cb, 0x0109)},\n\t{USB_DEVICE(0x04cb, 0x010b)},\n\t{USB_DEVICE(0x04cb, 0x010f)},\n\t{USB_DEVICE(0x04cb, 0x0111)},\n\t{USB_DEVICE(0x04cb, 0x0113)},\n\t{USB_DEVICE(0x04cb, 0x0115)},\n\t{USB_DEVICE(0x04cb, 0x0117)},\n\t{USB_DEVICE(0x04cb, 0x0119)},\n\t{USB_DEVICE(0x04cb, 0x011b)},\n\t{USB_DEVICE(0x04cb, 0x011d)},\n\t{USB_DEVICE(0x04cb, 0x0121)},\n\t{USB_DEVICE(0x04cb, 0x0123)},\n\t{USB_DEVICE(0x04cb, 0x0125)},\n\t{USB_DEVICE(0x04cb, 0x0127)},\n\t{USB_DEVICE(0x04cb, 0x0129)},\n\t{USB_DEVICE(0x04cb, 0x012b)},\n\t{USB_DEVICE(0x04cb, 0x012d)},\n\t{USB_DEVICE(0x04cb, 0x012f)},\n\t{USB_DEVICE(0x04cb, 0x0131)},\n\t{USB_DEVICE(0x04cb, 0x013b)},\n\t{USB_DEVICE(0x04cb, 0x013d)},\n\t{USB_DEVICE(0x04cb, 0x013f)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name   = MODULE_NAME,\n\t.config = sd_config,\n\t.init   = sd_init,\n\t.start  = sd_start,\n\t.stop0  = sd_stop0,\n};\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id,\n\t\t\t&sd_desc,\n\t\t\tsizeof(struct usb_fpix),\n\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name       = MODULE_NAME,\n\t.id_table   = device_table,\n\t.probe      = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume  = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}