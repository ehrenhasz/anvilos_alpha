{
  "module_name": "jl2005bcd.c",
  "hash_id": "23001d27cfc82460f979d55ca54f12fd4b8db928c7d4496e6ad79477e62dffd2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/jl2005bcd.c",
  "human_readable_source": "\n \n\n#define MODULE_NAME \"jl2005bcd\"\n\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include \"gspca.h\"\n\n\nMODULE_AUTHOR(\"Theodore Kilgore <kilgota@auburn.edu>\");\nMODULE_DESCRIPTION(\"JL2005B/C/D USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define JL2005C_CMD_TIMEOUT 500\n#define JL2005C_DATA_TIMEOUT 1000\n\n \n#define JL2005C_MAX_TRANSFER 0x200\n#define FRAME_HEADER_LEN 16\n\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;   \n\tunsigned char firmware_id[6];\n\tconst struct v4l2_pix_format *cap_mode;\n\t \n\tstruct work_struct work_struct;\n\tu8 frame_brightness;\n\tint block_size;\t \n\tint vga;\t \n};\n\n\n \nstatic const struct v4l2_pix_format cif_mode[] = {\n\t{176, 144, V4L2_PIX_FMT_JL2005BCD, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 176 * 144,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n\t{352, 288, V4L2_PIX_FMT_JL2005BCD, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352,\n\t\t.sizeimage = 352 * 288,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n};\n\nstatic const struct v4l2_pix_format vga_mode[] = {\n\t{320, 240, V4L2_PIX_FMT_JL2005BCD, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n\t{640, 480, V4L2_PIX_FMT_JL2005BCD, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n};\n\n \n\n \nstatic int jl2005c_write2(struct gspca_dev *gspca_dev, unsigned char *command)\n{\n\tint retval;\n\n\tmemcpy(gspca_dev->usb_buf, command, 2);\n\tretval = usb_bulk_msg(gspca_dev->dev,\n\t\t\tusb_sndbulkpipe(gspca_dev->dev, 3),\n\t\t\tgspca_dev->usb_buf, 2, NULL, 500);\n\tif (retval < 0)\n\t\tpr_err(\"command write [%02x] error %d\\n\",\n\t\t       gspca_dev->usb_buf[0], retval);\n\treturn retval;\n}\n\n \nstatic int jl2005c_read1(struct gspca_dev *gspca_dev)\n{\n\tint retval;\n\n\tretval = usb_bulk_msg(gspca_dev->dev,\n\t\t\t\tusb_rcvbulkpipe(gspca_dev->dev, 0x84),\n\t\t\t\tgspca_dev->usb_buf, 1, NULL, 500);\n\tif (retval < 0)\n\t\tpr_err(\"read command [0x%02x] error %d\\n\",\n\t\t       gspca_dev->usb_buf[0], retval);\n\treturn retval;\n}\n\n \nstatic int jl2005c_read_reg(struct gspca_dev *gspca_dev, unsigned char reg)\n{\n\tint retval;\n\n\tstatic u8 instruction[2] = {0x95, 0x00};\n\t \n\tinstruction[1] = reg;\n\t \n\tretval = jl2005c_write2(gspca_dev, instruction);\n\tif (retval < 0)\n\t\treturn retval;\n\tretval = jl2005c_read1(gspca_dev);\n\n\treturn retval;\n}\n\nstatic int jl2005c_start_new_frame(struct gspca_dev *gspca_dev)\n{\n\tint i;\n\tint retval;\n\tint frame_brightness = 0;\n\n\tstatic u8 instruction[2] = {0x7f, 0x01};\n\n\tretval = jl2005c_write2(gspca_dev, instruction);\n\tif (retval < 0)\n\t\treturn retval;\n\n\ti = 0;\n\twhile (i < 20 && !frame_brightness) {\n\t\t \n\t\tretval = jl2005c_read_reg(gspca_dev, 0x7e);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tframe_brightness = gspca_dev->usb_buf[0];\n\t\tretval = jl2005c_read_reg(gspca_dev, 0x7d);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\ti++;\n\t}\n\tgspca_dbg(gspca_dev, D_FRAM, \"frame_brightness is 0x%02x\\n\",\n\t\t  gspca_dev->usb_buf[0]);\n\treturn retval;\n}\n\nstatic int jl2005c_write_reg(struct gspca_dev *gspca_dev, unsigned char reg,\n\t\t\t\t\t\t    unsigned char value)\n{\n\tint retval;\n\tu8 instruction[2];\n\n\tinstruction[0] = reg;\n\tinstruction[1] = value;\n\n\tretval = jl2005c_write2(gspca_dev, instruction);\n\tif (retval < 0)\n\t\t\treturn retval;\n\n\treturn retval;\n}\n\nstatic int jl2005c_get_firmware_id(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\tint i = 0;\n\tint retval;\n\tstatic const unsigned char regs_to_read[] = {\n\t\t0x57, 0x02, 0x03, 0x5d, 0x5e, 0x5f\n\t};\n\n\tgspca_dbg(gspca_dev, D_PROBE, \"Running jl2005c_get_firmware_id\\n\");\n\t \n\tretval = jl2005c_read_reg(gspca_dev, regs_to_read[0]);\n\tgspca_dbg(gspca_dev, D_PROBE, \"response is %02x\\n\",\n\t\t  gspca_dev->usb_buf[0]);\n\tif (retval < 0)\n\t\treturn retval;\n\t \n\tfor (i = 0; i < 6; i++) {\n\t\tretval = jl2005c_read_reg(gspca_dev, regs_to_read[i]);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tsd->firmware_id[i] = gspca_dev->usb_buf[0];\n\t}\n\tgspca_dbg(gspca_dev, D_PROBE, \"firmware ID is %02x%02x%02x%02x%02x%02x\\n\",\n\t\t  sd->firmware_id[0],\n\t\t  sd->firmware_id[1],\n\t\t  sd->firmware_id[2],\n\t\t  sd->firmware_id[3],\n\t\t  sd->firmware_id[4],\n\t\t  sd->firmware_id[5]);\n\treturn 0;\n}\n\nstatic int jl2005c_stream_start_vga_lg\n\t\t    (struct gspca_dev *gspca_dev)\n{\n\tint i;\n\tint retval = -1;\n\tstatic u8 instruction[][2] = {\n\t\t{0x05, 0x00},\n\t\t{0x7c, 0x00},\n\t\t{0x7d, 0x18},\n\t\t{0x02, 0x00},\n\t\t{0x01, 0x00},\n\t\t{0x04, 0x52},\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(instruction); i++) {\n\t\tmsleep(60);\n\t\tretval = jl2005c_write2(gspca_dev, instruction[i]);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tmsleep(60);\n\treturn retval;\n}\n\nstatic int jl2005c_stream_start_vga_small(struct gspca_dev *gspca_dev)\n{\n\tint i;\n\tint retval = -1;\n\tstatic u8 instruction[][2] = {\n\t\t{0x06, 0x00},\n\t\t{0x7c, 0x00},\n\t\t{0x7d, 0x1a},\n\t\t{0x02, 0x00},\n\t\t{0x01, 0x00},\n\t\t{0x04, 0x52},\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(instruction); i++) {\n\t\tmsleep(60);\n\t\tretval = jl2005c_write2(gspca_dev, instruction[i]);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tmsleep(60);\n\treturn retval;\n}\n\nstatic int jl2005c_stream_start_cif_lg(struct gspca_dev *gspca_dev)\n{\n\tint i;\n\tint retval = -1;\n\tstatic u8 instruction[][2] = {\n\t\t{0x05, 0x00},\n\t\t{0x7c, 0x00},\n\t\t{0x7d, 0x30},\n\t\t{0x02, 0x00},\n\t\t{0x01, 0x00},\n\t\t{0x04, 0x42},\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(instruction); i++) {\n\t\tmsleep(60);\n\t\tretval = jl2005c_write2(gspca_dev, instruction[i]);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tmsleep(60);\n\treturn retval;\n}\n\nstatic int jl2005c_stream_start_cif_small(struct gspca_dev *gspca_dev)\n{\n\tint i;\n\tint retval = -1;\n\tstatic u8 instruction[][2] = {\n\t\t{0x06, 0x00},\n\t\t{0x7c, 0x00},\n\t\t{0x7d, 0x32},\n\t\t{0x02, 0x00},\n\t\t{0x01, 0x00},\n\t\t{0x04, 0x42},\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(instruction); i++) {\n\t\tmsleep(60);\n\t\tretval = jl2005c_write2(gspca_dev, instruction[i]);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tmsleep(60);\n\treturn retval;\n}\n\n\nstatic int jl2005c_stop(struct gspca_dev *gspca_dev)\n{\n\treturn jl2005c_write_reg(gspca_dev, 0x07, 0x00);\n}\n\n \nstatic void jl2005c_dostream(struct work_struct *work)\n{\n\tstruct sd *dev = container_of(work, struct sd, work_struct);\n\tstruct gspca_dev *gspca_dev = &dev->gspca_dev;\n\tint bytes_left = 0;  \n\tint data_len;    \n\tint header_read = 0;\n\tunsigned char header_sig[2] = {0x4a, 0x4c};\n\tint act_len;\n\tint packet_type;\n\tint ret;\n\tu8 *buffer;\n\n\tbuffer = kmalloc(JL2005C_MAX_TRANSFER, GFP_KERNEL);\n\tif (!buffer) {\n\t\tpr_err(\"Couldn't allocate USB buffer\\n\");\n\t\tgoto quit_stream;\n\t}\n\n\twhile (gspca_dev->present && gspca_dev->streaming) {\n#ifdef CONFIG_PM\n\t\tif (gspca_dev->frozen)\n\t\t\tbreak;\n#endif\n\t\t \n\t\tif (!header_read) {\n\t\t\tmutex_lock(&gspca_dev->usb_lock);\n\t\t\tret = jl2005c_start_new_frame(gspca_dev);\n\t\t\tmutex_unlock(&gspca_dev->usb_lock);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto quit_stream;\n\t\t\tret = usb_bulk_msg(gspca_dev->dev,\n\t\t\t\tusb_rcvbulkpipe(gspca_dev->dev, 0x82),\n\t\t\t\tbuffer, JL2005C_MAX_TRANSFER, &act_len,\n\t\t\t\tJL2005C_DATA_TIMEOUT);\n\t\t\tgspca_dbg(gspca_dev, D_PACK,\n\t\t\t\t  \"Got %d bytes out of %d for header\\n\",\n\t\t\t\t  act_len, JL2005C_MAX_TRANSFER);\n\t\t\tif (ret < 0 || act_len < JL2005C_MAX_TRANSFER)\n\t\t\t\tgoto quit_stream;\n\t\t\t \n\t\t\tif (memcmp(header_sig, buffer, 2) != 0) {\n\t\t\t\tpr_err(\"First block is not the first block\\n\");\n\t\t\t\tgoto quit_stream;\n\t\t\t}\n\t\t\t \n\t\t\tbytes_left = buffer[0x07] * dev->block_size - act_len;\n\t\t\tgspca_dbg(gspca_dev, D_PACK, \"bytes_left = 0x%x\\n\",\n\t\t\t\t  bytes_left);\n\t\t\t \n\t\t\tpacket_type = FIRST_PACKET;\n\t\t\tgspca_frame_add(gspca_dev, packet_type,\n\t\t\t\t\tbuffer, act_len);\n\t\t\theader_read = 1;\n\t\t}\n\t\twhile (bytes_left > 0 && gspca_dev->present) {\n\t\t\tdata_len = bytes_left > JL2005C_MAX_TRANSFER ?\n\t\t\t\tJL2005C_MAX_TRANSFER : bytes_left;\n\t\t\tret = usb_bulk_msg(gspca_dev->dev,\n\t\t\t\tusb_rcvbulkpipe(gspca_dev->dev, 0x82),\n\t\t\t\tbuffer, data_len, &act_len,\n\t\t\t\tJL2005C_DATA_TIMEOUT);\n\t\t\tif (ret < 0 || act_len < data_len)\n\t\t\t\tgoto quit_stream;\n\t\t\tgspca_dbg(gspca_dev, D_PACK,\n\t\t\t\t  \"Got %d bytes out of %d for frame\\n\",\n\t\t\t\t  data_len, bytes_left);\n\t\t\tbytes_left -= data_len;\n\t\t\tif (bytes_left == 0) {\n\t\t\t\tpacket_type = LAST_PACKET;\n\t\t\t\theader_read = 0;\n\t\t\t} else\n\t\t\t\tpacket_type = INTER_PACKET;\n\t\t\tgspca_frame_add(gspca_dev, packet_type,\n\t\t\t\t\tbuffer, data_len);\n\t\t}\n\t}\nquit_stream:\n\tif (gspca_dev->present) {\n\t\tmutex_lock(&gspca_dev->usb_lock);\n\t\tjl2005c_stop(gspca_dev);\n\t\tmutex_unlock(&gspca_dev->usb_lock);\n\t}\n\tkfree(buffer);\n}\n\n\n\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct cam *cam;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tcam = &gspca_dev->cam;\n\t \n\tcam->bulk_size = 64;\n\tcam->bulk = 1;\n\t \n\tjl2005c_get_firmware_id(gspca_dev);\n\t \n\tif ((sd->firmware_id[0] & 0xf0) == 0x40) {\n\t\tcam->cam_mode\t= cif_mode;\n\t\tcam->nmodes\t= ARRAY_SIZE(cif_mode);\n\t\tsd->block_size\t= 0x80;\n\t} else {\n\t\tcam->cam_mode\t= vga_mode;\n\t\tcam->nmodes\t= ARRAY_SIZE(vga_mode);\n\t\tsd->block_size\t= 0x200;\n\t}\n\n\tINIT_WORK(&sd->work_struct, jl2005c_dostream);\n\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\treturn 0;\n}\n\nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tsd->cap_mode = gspca_dev->cam.cam_mode;\n\n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 640:\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Start streaming at vga resolution\\n\");\n\t\tjl2005c_stream_start_vga_lg(gspca_dev);\n\t\tbreak;\n\tcase 320:\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Start streaming at qvga resolution\\n\");\n\t\tjl2005c_stream_start_vga_small(gspca_dev);\n\t\tbreak;\n\tcase 352:\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Start streaming at cif resolution\\n\");\n\t\tjl2005c_stream_start_cif_lg(gspca_dev);\n\t\tbreak;\n\tcase 176:\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Start streaming at qcif resolution\\n\");\n\t\tjl2005c_stream_start_cif_small(gspca_dev);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown resolution specified\\n\");\n\t\treturn -1;\n\t}\n\n\tschedule_work(&sd->work_struct);\n\n\treturn 0;\n}\n\n \n \nstatic void sd_stop0(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *dev = (struct sd *) gspca_dev;\n\n\t \n\tmutex_unlock(&gspca_dev->usb_lock);\n\t \n\tflush_work(&dev->work_struct);\n\tmutex_lock(&gspca_dev->usb_lock);\n}\n\n\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.start = sd_start,\n\t.stop0 = sd_stop0,\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x0979, 0x0227)},\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}