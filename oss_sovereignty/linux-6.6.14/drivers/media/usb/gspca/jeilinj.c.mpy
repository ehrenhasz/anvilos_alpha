{
  "module_name": "jeilinj.c",
  "hash_id": "d085de7d299bb87b910eabd7dfe36a99e0fa744698a7e1d66ea1b5df0df2b7c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/jeilinj.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"jeilinj\"\n\n#include <linux/slab.h>\n#include \"gspca.h\"\n#include \"jpeg.h\"\n\nMODULE_AUTHOR(\"Theodore Kilgore <kilgota@auburn.edu>\");\nMODULE_DESCRIPTION(\"GSPCA/JEILINJ USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define JEILINJ_CMD_TIMEOUT 500\n#define JEILINJ_CMD_DELAY 160\n#define JEILINJ_DATA_TIMEOUT 1000\n\n \n#define JEILINJ_MAX_TRANSFER 0x200\n#define FRAME_HEADER_LEN 0x10\n#define FRAME_START 0xFFFFFFFF\n\nenum {\n\tSAKAR_57379,\n\tSPORTSCAM_DV15,\n};\n\n#define CAMQUALITY_MIN 0\t \n#define CAMQUALITY_MAX 97\t \n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t \n\tint blocks_left;\n\tconst struct v4l2_pix_format *cap_mode;\n\tstruct v4l2_ctrl *freq;\n\tstruct v4l2_ctrl *jpegqual;\n\t \n\tu8 type;\n\tu8 quality;\t\t\t\t  \n#define QUALITY_MIN 35\n#define QUALITY_MAX 85\n#define QUALITY_DEF 85\n\tu8 jpeg_hdr[JPEG_HDR_SZ];\n};\n\nstruct jlj_command {\n\tunsigned char instruction[2];\n\tunsigned char ack_wanted;\n\tunsigned char delay;\n};\n\n \nstatic struct v4l2_pix_format jlj_mode[] = {\n\t{ 320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0},\n\t{ 640, 480, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = 0}\n};\n\n \n\n \nstatic void jlj_write2(struct gspca_dev *gspca_dev, unsigned char *command)\n{\n\tint retval;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tmemcpy(gspca_dev->usb_buf, command, 2);\n\tretval = usb_bulk_msg(gspca_dev->dev,\n\t\t\tusb_sndbulkpipe(gspca_dev->dev, 3),\n\t\t\tgspca_dev->usb_buf, 2, NULL, 500);\n\tif (retval < 0) {\n\t\tpr_err(\"command write [%02x] error %d\\n\",\n\t\t       gspca_dev->usb_buf[0], retval);\n\t\tgspca_dev->usb_err = retval;\n\t}\n}\n\n \nstatic void jlj_read1(struct gspca_dev *gspca_dev, unsigned char *response)\n{\n\tint retval;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tretval = usb_bulk_msg(gspca_dev->dev,\n\tusb_rcvbulkpipe(gspca_dev->dev, 0x84),\n\t\t\t\tgspca_dev->usb_buf, 1, NULL, 500);\n\t*response = gspca_dev->usb_buf[0];\n\tif (retval < 0) {\n\t\tpr_err(\"read command [%02x] error %d\\n\",\n\t\t       gspca_dev->usb_buf[0], retval);\n\t\tgspca_dev->usb_err = retval;\n\t}\n}\n\nstatic void setfreq(struct gspca_dev *gspca_dev, s32 val)\n{\n\tu8 freq_commands[][2] = {\n\t\t{0x71, 0x80},\n\t\t{0x70, 0x07}\n\t};\n\n\tfreq_commands[0][1] |= val >> 1;\n\n\tjlj_write2(gspca_dev, freq_commands[0]);\n\tjlj_write2(gspca_dev, freq_commands[1]);\n}\n\nstatic void setcamquality(struct gspca_dev *gspca_dev, s32 val)\n{\n\tu8 quality_commands[][2] = {\n\t\t{0x71, 0x1E},\n\t\t{0x70, 0x06}\n\t};\n\tu8 camquality;\n\n\t \n\tcamquality = ((QUALITY_MAX - val) * CAMQUALITY_MAX)\n\t\t/ (QUALITY_MAX - QUALITY_MIN);\n\tquality_commands[0][1] += camquality;\n\n\tjlj_write2(gspca_dev, quality_commands[0]);\n\tjlj_write2(gspca_dev, quality_commands[1]);\n}\n\nstatic void setautogain(struct gspca_dev *gspca_dev, s32 val)\n{\n\tu8 autogain_commands[][2] = {\n\t\t{0x94, 0x02},\n\t\t{0xcf, 0x00}\n\t};\n\n\tautogain_commands[1][1] = val << 4;\n\n\tjlj_write2(gspca_dev, autogain_commands[0]);\n\tjlj_write2(gspca_dev, autogain_commands[1]);\n}\n\nstatic void setred(struct gspca_dev *gspca_dev, s32 val)\n{\n\tu8 setred_commands[][2] = {\n\t\t{0x94, 0x02},\n\t\t{0xe6, 0x00}\n\t};\n\n\tsetred_commands[1][1] = val;\n\n\tjlj_write2(gspca_dev, setred_commands[0]);\n\tjlj_write2(gspca_dev, setred_commands[1]);\n}\n\nstatic void setgreen(struct gspca_dev *gspca_dev, s32 val)\n{\n\tu8 setgreen_commands[][2] = {\n\t\t{0x94, 0x02},\n\t\t{0xe7, 0x00}\n\t};\n\n\tsetgreen_commands[1][1] = val;\n\n\tjlj_write2(gspca_dev, setgreen_commands[0]);\n\tjlj_write2(gspca_dev, setgreen_commands[1]);\n}\n\nstatic void setblue(struct gspca_dev *gspca_dev, s32 val)\n{\n\tu8 setblue_commands[][2] = {\n\t\t{0x94, 0x02},\n\t\t{0xe9, 0x00}\n\t};\n\n\tsetblue_commands[1][1] = val;\n\n\tjlj_write2(gspca_dev, setblue_commands[0]);\n\tjlj_write2(gspca_dev, setblue_commands[1]);\n}\n\nstatic int jlj_start(struct gspca_dev *gspca_dev)\n{\n\tint i;\n\tint start_commands_size;\n\tu8 response = 0xff;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct jlj_command start_commands[] = {\n\t\t{{0x71, 0x81}, 0, 0},\n\t\t{{0x70, 0x05}, 0, JEILINJ_CMD_DELAY},\n\t\t{{0x95, 0x70}, 1, 0},\n\t\t{{0x71, 0x81 - gspca_dev->curr_mode}, 0, 0},\n\t\t{{0x70, 0x04}, 0, JEILINJ_CMD_DELAY},\n\t\t{{0x95, 0x70}, 1, 0},\n\t\t{{0x71, 0x00}, 0, 0},    \n\t\t{{0x70, 0x08}, 0, JEILINJ_CMD_DELAY},\n\t\t{{0x95, 0x70}, 1, 0},\n#define SPORTSCAM_DV15_CMD_SIZE 9\n\t\t{{0x94, 0x02}, 0, 0},\n\t\t{{0xde, 0x24}, 0, 0},\n\t\t{{0x94, 0x02}, 0, 0},\n\t\t{{0xdd, 0xf0}, 0, 0},\n\t\t{{0x94, 0x02}, 0, 0},\n\t\t{{0xe3, 0x2c}, 0, 0},\n\t\t{{0x94, 0x02}, 0, 0},\n\t\t{{0xe4, 0x00}, 0, 0},\n\t\t{{0x94, 0x02}, 0, 0},\n\t\t{{0xe5, 0x00}, 0, 0},\n\t\t{{0x94, 0x02}, 0, 0},\n\t\t{{0xe6, 0x2c}, 0, 0},\n\t\t{{0x94, 0x03}, 0, 0},\n\t\t{{0xaa, 0x00}, 0, 0}\n\t};\n\n\tsd->blocks_left = 0;\n\t \n\tif (sd->type == SPORTSCAM_DV15)\n\t\tstart_commands_size = SPORTSCAM_DV15_CMD_SIZE;\n\telse\n\t\tstart_commands_size = ARRAY_SIZE(start_commands);\n\n\tfor (i = 0; i < start_commands_size; i++) {\n\t\tjlj_write2(gspca_dev, start_commands[i].instruction);\n\t\tif (start_commands[i].delay)\n\t\t\tmsleep(start_commands[i].delay);\n\t\tif (start_commands[i].ack_wanted)\n\t\t\tjlj_read1(gspca_dev, &response);\n\t}\n\tsetcamquality(gspca_dev, v4l2_ctrl_g_ctrl(sd->jpegqual));\n\tmsleep(2);\n\tsetfreq(gspca_dev, v4l2_ctrl_g_ctrl(sd->freq));\n\tif (gspca_dev->usb_err < 0)\n\t\tgspca_err(gspca_dev, \"Start streaming command failed\\n\");\n\treturn gspca_dev->usb_err;\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data, int len)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint packet_type;\n\tu32 header_marker;\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"Got %d bytes out of %d for Block 0\\n\",\n\t\t  len, JEILINJ_MAX_TRANSFER);\n\tif (len != JEILINJ_MAX_TRANSFER) {\n\t\tgspca_dbg(gspca_dev, D_PACK, \"bad length\\n\");\n\t\tgoto discard;\n\t}\n\t \n\theader_marker = ((u32 *)data)[0];\n\tif (header_marker == FRAME_START) {\n\t\tsd->blocks_left = data[0x0a] - 1;\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"blocks_left = 0x%x\\n\",\n\t\t\t  sd->blocks_left);\n\t\t \n\t\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\t\t\tsd->jpeg_hdr, JPEG_HDR_SZ);\n\t\t \n\t\tgspca_frame_add(gspca_dev, INTER_PACKET,\n\t\t\t\tdata + FRAME_HEADER_LEN,\n\t\t\t\tJEILINJ_MAX_TRANSFER - FRAME_HEADER_LEN);\n\t} else if (sd->blocks_left > 0) {\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"%d blocks remaining for frame\\n\",\n\t\t\t  sd->blocks_left);\n\t\tsd->blocks_left -= 1;\n\t\tif (sd->blocks_left == 0)\n\t\t\tpacket_type = LAST_PACKET;\n\t\telse\n\t\t\tpacket_type = INTER_PACKET;\n\t\tgspca_frame_add(gspca_dev, packet_type,\n\t\t\t\tdata, JEILINJ_MAX_TRANSFER);\n\t} else\n\t\tgoto discard;\n\treturn;\ndiscard:\n\t \n\tgspca_dev->last_packet_type = DISCARD_PACKET;\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct cam *cam = &gspca_dev->cam;\n\tstruct sd *dev  = (struct sd *) gspca_dev;\n\n\tdev->type = id->driver_info;\n\tdev->quality = QUALITY_DEF;\n\n\tcam->cam_mode = jlj_mode;\n\tcam->nmodes = ARRAY_SIZE(jlj_mode);\n\tcam->bulk = 1;\n\tcam->bulk_nurbs = 1;\n\tcam->bulk_size = JEILINJ_MAX_TRANSFER;\n\treturn 0;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\tint i;\n\tu8 *buf;\n\tstatic u8 stop_commands[][2] = {\n\t\t{0x71, 0x00},\n\t\t{0x70, 0x09},\n\t\t{0x71, 0x80},\n\t\t{0x70, 0x05}\n\t};\n\n\tfor (;;) {\n\t\t \n\t\tusb_bulk_msg(gspca_dev->dev,\n\t\t\t\tgspca_dev->urb[0]->pipe,\n\t\t\t\tgspca_dev->urb[0]->transfer_buffer,\n\t\t\t\tJEILINJ_MAX_TRANSFER, NULL,\n\t\t\t\tJEILINJ_DATA_TIMEOUT);\n\n\t\t \n\t\ti = 0;\n\t\tbuf = gspca_dev->urb[0]->transfer_buffer;\n\t\twhile ((i < (JEILINJ_MAX_TRANSFER - 1)) &&\n\t\t\t((buf[i] != 0xff) || (buf[i+1] != 0xd9)))\n\t\t\ti++;\n\n\t\tif (i != (JEILINJ_MAX_TRANSFER - 1))\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(stop_commands); i++)\n\t\tjlj_write2(gspca_dev, stop_commands[i]);\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\treturn gspca_dev->usb_err;\n}\n\n \nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *dev = (struct sd *) gspca_dev;\n\n\t \n\tjpeg_define(dev->jpeg_hdr, gspca_dev->pixfmt.height,\n\t\t\tgspca_dev->pixfmt.width,\n\t\t\t0x21);           \n\tjpeg_set_qual(dev->jpeg_hdr, dev->quality);\n\tgspca_dbg(gspca_dev, D_STREAM, \"Start streaming at %dx%d\\n\",\n\t\t  gspca_dev->pixfmt.height, gspca_dev->pixfmt.width);\n\tjlj_start(gspca_dev);\n\treturn gspca_dev->usb_err;\n}\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x0979, 0x0280), .driver_info = SAKAR_57379},\n\t{USB_DEVICE(0x0979, 0x0270), .driver_info = SPORTSCAM_DV15},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, device_table);\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_POWER_LINE_FREQUENCY:\n\t\tsetfreq(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_RED_BALANCE:\n\t\tsetred(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_GAIN:\n\t\tsetgreen(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_BLUE_BALANCE:\n\t\tsetblue(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\tsetautogain(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_JPEG_COMPRESSION_QUALITY:\n\t\tjpeg_set_qual(sd->jpeg_hdr, ctrl->val);\n\t\tsetcamquality(gspca_dev, ctrl->val);\n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\tstatic const struct v4l2_ctrl_config custom_autogain = {\n\t\t.ops = &sd_ctrl_ops,\n\t\t.id = V4L2_CID_AUTOGAIN,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Automatic Gain (and Exposure)\",\n\t\t.max = 3,\n\t\t.step = 1,\n\t\t.def = 0,\n\t};\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 6);\n\tsd->freq = v4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_POWER_LINE_FREQUENCY,\n\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_60HZ, 1,\n\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_60HZ);\n\tv4l2_ctrl_new_custom(hdl, &custom_autogain, NULL);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_RED_BALANCE, 0, 3, 1, 2);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, 0, 3, 1, 2);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BLUE_BALANCE, 0, 3, 1, 2);\n\tsd->jpegqual = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_JPEG_COMPRESSION_QUALITY,\n\t\t\tQUALITY_MIN, QUALITY_MAX, 1, QUALITY_DEF);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\treturn 0;\n}\n\nstatic int sd_set_jcomp(struct gspca_dev *gspca_dev,\n\t\t\tconst struct v4l2_jpegcompression *jcomp)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tv4l2_ctrl_s_ctrl(sd->jpegqual, jcomp->quality);\n\treturn 0;\n}\n\nstatic int sd_get_jcomp(struct gspca_dev *gspca_dev,\n\t\t\tstruct v4l2_jpegcompression *jcomp)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tmemset(jcomp, 0, sizeof *jcomp);\n\tjcomp->quality = v4l2_ctrl_g_ctrl(sd->jpegqual);\n\tjcomp->jpeg_markers = V4L2_JPEG_MARKER_DHT\n\t\t\t| V4L2_JPEG_MARKER_DQT;\n\treturn 0;\n}\n\n\n \nstatic const struct sd_desc sd_desc_sakar_57379 = {\n\t.name   = MODULE_NAME,\n\t.config = sd_config,\n\t.init   = sd_init,\n\t.start  = sd_start,\n\t.stopN  = sd_stopN,\n\t.pkt_scan = sd_pkt_scan,\n};\n\n \nstatic const struct sd_desc sd_desc_sportscam_dv15 = {\n\t.name   = MODULE_NAME,\n\t.config = sd_config,\n\t.init   = sd_init,\n\t.init_controls = sd_init_controls,\n\t.start  = sd_start,\n\t.stopN  = sd_stopN,\n\t.pkt_scan = sd_pkt_scan,\n\t.get_jcomp = sd_get_jcomp,\n\t.set_jcomp = sd_set_jcomp,\n};\n\nstatic const struct sd_desc *sd_desc[2] = {\n\t&sd_desc_sakar_57379,\n\t&sd_desc_sportscam_dv15\n};\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id,\n\t\t\tsd_desc[id->driver_info],\n\t\t\tsizeof(struct sd),\n\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name       = MODULE_NAME,\n\t.id_table   = device_table,\n\t.probe      = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume  = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}