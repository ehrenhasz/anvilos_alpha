{
  "module_name": "kinect.c",
  "hash_id": "4e4b5be659704bb63ce38f72fdfe20de5cc1d9709a6e61f3da72859005b5a5fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/kinect.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"kinect\"\n\n#include \"gspca.h\"\n\n#define CTRL_TIMEOUT 500\n\nMODULE_AUTHOR(\"Antonio Ospite <ospite@studenti.unina.it>\");\nMODULE_DESCRIPTION(\"GSPCA/Kinect Sensor Device USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic bool depth_mode;\n\nstruct pkt_hdr {\n\tuint8_t magic[2];\n\tuint8_t pad;\n\tuint8_t flag;\n\tuint8_t unk1;\n\tuint8_t seq;\n\tuint8_t unk2;\n\tuint8_t unk3;\n\tuint32_t timestamp;\n};\n\nstruct cam_hdr {\n\tuint8_t magic[2];\n\t__le16 len;\n\t__le16 cmd;\n\t__le16 tag;\n};\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;  \n\tuint16_t cam_tag;            \n\tuint8_t stream_flag;         \n\tuint8_t obuf[0x400];         \n\tuint8_t ibuf[0x200];         \n};\n\n#define MODE_640x480   0x0001\n#define MODE_640x488   0x0002\n#define MODE_1280x1024 0x0004\n\n#define FORMAT_BAYER   0x0010\n#define FORMAT_UYVY    0x0020\n#define FORMAT_Y10B    0x0040\n\n#define FPS_HIGH       0x0100\n\nstatic const struct v4l2_pix_format depth_camera_mode[] = {\n\t{640, 480, V4L2_PIX_FMT_Y10BPACK, V4L2_FIELD_NONE,\n\t .bytesperline = 640 * 10 / 8,\n\t .sizeimage =  640 * 480 * 10 / 8,\n\t .colorspace = V4L2_COLORSPACE_SRGB,\n\t .priv = MODE_640x488 | FORMAT_Y10B},\n};\n\nstatic const struct v4l2_pix_format video_camera_mode[] = {\n\t{640, 480, V4L2_PIX_FMT_SGRBG8, V4L2_FIELD_NONE,\n\t .bytesperline = 640,\n\t .sizeimage = 640 * 480,\n\t .colorspace = V4L2_COLORSPACE_SRGB,\n\t .priv = MODE_640x480 | FORMAT_BAYER | FPS_HIGH},\n\t{640, 480, V4L2_PIX_FMT_UYVY, V4L2_FIELD_NONE,\n\t .bytesperline = 640 * 2,\n\t .sizeimage = 640 * 480 * 2,\n\t .colorspace = V4L2_COLORSPACE_SRGB,\n\t .priv = MODE_640x480 | FORMAT_UYVY},\n\t{1280, 1024, V4L2_PIX_FMT_SGRBG8, V4L2_FIELD_NONE,\n\t .bytesperline = 1280,\n\t .sizeimage = 1280 * 1024,\n\t .colorspace = V4L2_COLORSPACE_SRGB,\n\t .priv = MODE_1280x1024 | FORMAT_BAYER},\n\t{640, 488, V4L2_PIX_FMT_Y10BPACK, V4L2_FIELD_NONE,\n\t .bytesperline = 640 * 10 / 8,\n\t .sizeimage =  640 * 488 * 10 / 8,\n\t .colorspace = V4L2_COLORSPACE_SRGB,\n\t .priv = MODE_640x488 | FORMAT_Y10B | FPS_HIGH},\n\t{1280, 1024, V4L2_PIX_FMT_Y10BPACK, V4L2_FIELD_NONE,\n\t .bytesperline = 1280 * 10 / 8,\n\t .sizeimage =  1280 * 1024 * 10 / 8,\n\t .colorspace = V4L2_COLORSPACE_SRGB,\n\t .priv = MODE_1280x1024 | FORMAT_Y10B},\n};\n\nstatic int kinect_write(struct usb_device *udev, uint8_t *data,\n\t\t\tuint16_t wLength)\n{\n\treturn usb_control_msg(udev,\n\t\t\t      usb_sndctrlpipe(udev, 0),\n\t\t\t      0x00,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      0, 0, data, wLength, CTRL_TIMEOUT);\n}\n\nstatic int kinect_read(struct usb_device *udev, uint8_t *data, uint16_t wLength)\n{\n\treturn usb_control_msg(udev,\n\t\t\t      usb_rcvctrlpipe(udev, 0),\n\t\t\t      0x00,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      0, 0, data, wLength, CTRL_TIMEOUT);\n}\n\nstatic int send_cmd(struct gspca_dev *gspca_dev, uint16_t cmd, void *cmdbuf,\n\t\tunsigned int cmd_len, void *replybuf, unsigned int reply_len)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct usb_device *udev = gspca_dev->dev;\n\tint res, actual_len;\n\tuint8_t *obuf = sd->obuf;\n\tuint8_t *ibuf = sd->ibuf;\n\tstruct cam_hdr *chdr = (void *)obuf;\n\tstruct cam_hdr *rhdr = (void *)ibuf;\n\n\tif (cmd_len & 1 || cmd_len > (0x400 - sizeof(*chdr))) {\n\t\tpr_err(\"send_cmd: Invalid command length (0x%x)\\n\", cmd_len);\n\t\treturn -1;\n\t}\n\n\tchdr->magic[0] = 0x47;\n\tchdr->magic[1] = 0x4d;\n\tchdr->cmd = cpu_to_le16(cmd);\n\tchdr->tag = cpu_to_le16(sd->cam_tag);\n\tchdr->len = cpu_to_le16(cmd_len / 2);\n\n\tmemcpy(obuf+sizeof(*chdr), cmdbuf, cmd_len);\n\n\tres = kinect_write(udev, obuf, cmd_len + sizeof(*chdr));\n\tgspca_dbg(gspca_dev, D_USBO, \"Control cmd=%04x tag=%04x len=%04x: %d\\n\",\n\t\t  cmd,\n\t\t  sd->cam_tag, cmd_len, res);\n\tif (res < 0) {\n\t\tpr_err(\"send_cmd: Output control transfer failed (%d)\\n\", res);\n\t\treturn res;\n\t}\n\n\tdo {\n\t\tactual_len = kinect_read(udev, ibuf, 0x200);\n\t} while (actual_len == 0);\n\tgspca_dbg(gspca_dev, D_USBO, \"Control reply: %d\\n\", actual_len);\n\tif (actual_len < (int)sizeof(*rhdr)) {\n\t\tpr_err(\"send_cmd: Input control transfer failed (%d)\\n\",\n\t\t       actual_len);\n\t\treturn actual_len < 0 ? actual_len : -EREMOTEIO;\n\t}\n\tactual_len -= sizeof(*rhdr);\n\n\tif (rhdr->magic[0] != 0x52 || rhdr->magic[1] != 0x42) {\n\t\tpr_err(\"send_cmd: Bad magic %02x %02x\\n\",\n\t\t       rhdr->magic[0], rhdr->magic[1]);\n\t\treturn -1;\n\t}\n\tif (rhdr->cmd != chdr->cmd) {\n\t\tpr_err(\"send_cmd: Bad cmd %02x != %02x\\n\",\n\t\t       rhdr->cmd, chdr->cmd);\n\t\treturn -1;\n\t}\n\tif (rhdr->tag != chdr->tag) {\n\t\tpr_err(\"send_cmd: Bad tag %04x != %04x\\n\",\n\t\t       rhdr->tag, chdr->tag);\n\t\treturn -1;\n\t}\n\tif (le16_to_cpu(rhdr->len) != (actual_len/2)) {\n\t\tpr_err(\"send_cmd: Bad len %04x != %04x\\n\",\n\t\t       le16_to_cpu(rhdr->len), (int)(actual_len/2));\n\t\treturn -1;\n\t}\n\n\tif (actual_len > reply_len) {\n\t\tpr_warn(\"send_cmd: Data buffer is %d bytes long, but got %d bytes\\n\",\n\t\t\treply_len, actual_len);\n\t\tmemcpy(replybuf, ibuf+sizeof(*rhdr), reply_len);\n\t} else {\n\t\tmemcpy(replybuf, ibuf+sizeof(*rhdr), actual_len);\n\t}\n\n\tsd->cam_tag++;\n\n\treturn actual_len;\n}\n\nstatic int write_register(struct gspca_dev *gspca_dev, uint16_t reg,\n\t\t\tuint16_t data)\n{\n\tuint16_t reply[2];\n\t__le16 cmd[2];\n\tint res;\n\n\tcmd[0] = cpu_to_le16(reg);\n\tcmd[1] = cpu_to_le16(data);\n\n\tgspca_dbg(gspca_dev, D_USBO, \"Write Reg 0x%04x <= 0x%02x\\n\", reg, data);\n\tres = send_cmd(gspca_dev, 0x03, cmd, 4, reply, 4);\n\tif (res < 0)\n\t\treturn res;\n\tif (res != 2) {\n\t\tpr_warn(\"send_cmd returned %d [%04x %04x], 0000 expected\\n\",\n\t\t\tres, reply[0], reply[1]);\n\t}\n\treturn 0;\n}\n\n \nstatic int sd_config_video(struct gspca_dev *gspca_dev,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam;\n\n\tsd->cam_tag = 0;\n\n\tsd->stream_flag = 0x80;\n\n\tcam = &gspca_dev->cam;\n\n\tcam->cam_mode = video_camera_mode;\n\tcam->nmodes = ARRAY_SIZE(video_camera_mode);\n\n\tgspca_dev->xfer_ep = 0x81;\n\n#if 0\n\t \n\tcam->npkt = 15;\n\tgspca_dev->pkt_size = 960 * 2;\n#endif\n\n\treturn 0;\n}\n\nstatic int sd_config_depth(struct gspca_dev *gspca_dev,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam;\n\n\tsd->cam_tag = 0;\n\n\tsd->stream_flag = 0x70;\n\n\tcam = &gspca_dev->cam;\n\n\tcam->cam_mode = depth_camera_mode;\n\tcam->nmodes = ARRAY_SIZE(depth_camera_mode);\n\n\tgspca_dev->xfer_ep = 0x82;\n\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\tgspca_dbg(gspca_dev, D_PROBE, \"Kinect Camera device.\\n\");\n\n\treturn 0;\n}\n\nstatic int sd_start_video(struct gspca_dev *gspca_dev)\n{\n\tint mode;\n\tuint8_t fmt_reg, fmt_val;\n\tuint8_t res_reg, res_val;\n\tuint8_t fps_reg, fps_val;\n\tuint8_t mode_val;\n\n\tmode = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\n\n\tif (mode & FORMAT_Y10B) {\n\t\tfmt_reg = 0x19;\n\t\tres_reg = 0x1a;\n\t\tfps_reg = 0x1b;\n\t\tmode_val = 0x03;\n\t} else {\n\t\tfmt_reg = 0x0c;\n\t\tres_reg = 0x0d;\n\t\tfps_reg = 0x0e;\n\t\tmode_val = 0x01;\n\t}\n\n\t \n\tif (mode & FORMAT_UYVY)\n\t\tfmt_val = 0x05;\n\telse\n\t\tfmt_val = 0x00;\n\n\tif (mode & MODE_1280x1024)\n\t\tres_val = 0x02;\n\telse\n\t\tres_val = 0x01;\n\n\tif (mode & FPS_HIGH)\n\t\tfps_val = 0x1e;\n\telse\n\t\tfps_val = 0x0f;\n\n\n\t \n\twrite_register(gspca_dev, 0x105, 0x00);\n\n\t \n\twrite_register(gspca_dev, 0x05, 0x00);\n\n\t \n\tif (mode & (FORMAT_Y10B | MODE_1280x1024)) {\n\t\twrite_register(gspca_dev, 0x13, 0x01);\n\t\twrite_register(gspca_dev, 0x14, 0x1e);\n\t\twrite_register(gspca_dev, 0x06, 0x02);\n\t\twrite_register(gspca_dev, 0x06, 0x00);\n\t}\n\n\twrite_register(gspca_dev, fmt_reg, fmt_val);\n\twrite_register(gspca_dev, res_reg, res_val);\n\twrite_register(gspca_dev, fps_reg, fps_val);\n\n\t \n\twrite_register(gspca_dev, 0x05, mode_val);\n\n\t \n\twrite_register(gspca_dev, 0x47, 0x00);\n\n\treturn 0;\n}\n\nstatic int sd_start_depth(struct gspca_dev *gspca_dev)\n{\n\t \n\twrite_register(gspca_dev, 0x105, 0x00);\n\n\t \n\twrite_register(gspca_dev, 0x06, 0x00);\n\t \n\twrite_register(gspca_dev, 0x12, 0x02);\n\t \n\twrite_register(gspca_dev, 0x13, 0x01);\n\t \n\twrite_register(gspca_dev, 0x14, 0x1e);\n\t \n\twrite_register(gspca_dev, 0x06, 0x02);\n\t \n\twrite_register(gspca_dev, 0x17, 0x00);\n\n\treturn 0;\n}\n\nstatic void sd_stopN_video(struct gspca_dev *gspca_dev)\n{\n\t \n\twrite_register(gspca_dev, 0x05, 0x00);\n}\n\nstatic void sd_stopN_depth(struct gspca_dev *gspca_dev)\n{\n\t \n\twrite_register(gspca_dev, 0x06, 0x00);\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev, u8 *__data, int len)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tstruct pkt_hdr *hdr = (void *)__data;\n\tuint8_t *data = __data + sizeof(*hdr);\n\tint datalen = len - sizeof(*hdr);\n\n\tuint8_t sof = sd->stream_flag | 1;\n\tuint8_t mof = sd->stream_flag | 2;\n\tuint8_t eof = sd->stream_flag | 5;\n\n\tif (len < 12)\n\t\treturn;\n\n\tif (hdr->magic[0] != 'R' || hdr->magic[1] != 'B') {\n\t\tpr_warn(\"[Stream %02x] Invalid magic %02x%02x\\n\",\n\t\t\tsd->stream_flag, hdr->magic[0], hdr->magic[1]);\n\t\treturn;\n\t}\n\n\tif (hdr->flag == sof)\n\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, data, datalen);\n\n\telse if (hdr->flag == mof)\n\t\tgspca_frame_add(gspca_dev, INTER_PACKET, data, datalen);\n\n\telse if (hdr->flag == eof)\n\t\tgspca_frame_add(gspca_dev, LAST_PACKET, data, datalen);\n\n\telse\n\t\tpr_warn(\"Packet type not recognized...\\n\");\n}\n\n \nstatic const struct sd_desc sd_desc_video = {\n\t.name      = MODULE_NAME,\n\t.config    = sd_config_video,\n\t.init      = sd_init,\n\t.start     = sd_start_video,\n\t.stopN     = sd_stopN_video,\n\t.pkt_scan  = sd_pkt_scan,\n\t \n};\nstatic const struct sd_desc sd_desc_depth = {\n\t.name      = MODULE_NAME,\n\t.config    = sd_config_depth,\n\t.init      = sd_init,\n\t.start     = sd_start_depth,\n\t.stopN     = sd_stopN_depth,\n\t.pkt_scan  = sd_pkt_scan,\n\t \n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x045e, 0x02ae)},\n\t{USB_DEVICE(0x045e, 0x02bf)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tif (depth_mode)\n\t\treturn gspca_dev_probe(intf, id, &sd_desc_depth,\n\t\t\t\t       sizeof(struct sd), THIS_MODULE);\n\telse\n\t\treturn gspca_dev_probe(intf, id, &sd_desc_video,\n\t\t\t\t       sizeof(struct sd), THIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name       = MODULE_NAME,\n\t.id_table   = device_table,\n\t.probe      = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend    = gspca_suspend,\n\t.resume     = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n\nmodule_param(depth_mode, bool, 0644);\nMODULE_PARM_DESC(depth_mode, \"0=video 1=depth\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}