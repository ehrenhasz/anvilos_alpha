{
  "module_name": "touptek.c",
  "hash_id": "429ffca4612a8a69b60f810eef07b5dbe2ddec367bd05078af90702dd0d9a4c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/touptek.c",
  "human_readable_source": "\n \n\n#include \"gspca.h\"\n\n#define MODULE_NAME \"touptek\"\n\nMODULE_AUTHOR(\"John McMaster\");\nMODULE_DESCRIPTION(\"ToupTek UCMOS / Amscope MU microscope camera driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define GAIN_MAX\t\t511\n\n \n#define BULK_SIZE\t\t0x4000\n\n \n#define REG_COARSE_INTEGRATION_TIME_\t0x3012\n#define REG_GROUPED_PARAMETER_HOLD_\t0x3022\n#define REG_MODE_SELECT\t\t\t0x0100\n#define REG_OP_SYS_CLK_DIV\t\t0x030A\n#define REG_VT_SYS_CLK_DIV\t\t0x0302\n#define REG_PRE_PLL_CLK_DIV\t\t0x0304\n#define REG_VT_PIX_CLK_DIV\t\t0x0300\n#define REG_OP_PIX_CLK_DIV\t\t0x0308\n#define REG_PLL_MULTIPLIER\t\t0x0306\n#define REG_COARSE_INTEGRATION_TIME_\t0x3012\n#define REG_FRAME_LENGTH_LINES\t\t0x0340\n#define REG_FRAME_LENGTH_LINES_\t\t0x300A\n#define REG_GREEN1_GAIN\t\t\t0x3056\n#define REG_GREEN2_GAIN\t\t\t0x305C\n#define REG_GROUPED_PARAMETER_HOLD\t0x0104\n#define REG_LINE_LENGTH_PCK_\t\t0x300C\n#define REG_MODE_SELECT\t\t\t0x0100\n#define REG_PLL_MULTIPLIER\t\t0x0306\n#define REG_READ_MODE\t\t\t0x3040\n#define REG_BLUE_GAIN\t\t\t0x3058\n#define REG_RED_GAIN\t\t\t0x305A\n#define REG_RESET_REGISTER\t\t0x301A\n#define REG_SCALE_M\t\t\t0x0404\n#define REG_SCALING_MODE\t\t0x0400\n#define REG_SOFTWARE_RESET\t\t0x0103\n#define REG_X_ADDR_END\t\t\t0x0348\n#define REG_X_ADDR_START\t\t0x0344\n#define REG_X_ADDR_START\t\t0x0344\n#define REG_X_OUTPUT_SIZE\t\t0x034C\n#define REG_Y_ADDR_END\t\t\t0x034A\n#define REG_Y_ADDR_START\t\t0x0346\n#define REG_Y_OUTPUT_SIZE\t\t0x034E\n\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t \n\t \n\tunsigned int this_f;\n\n\t \n\tstruct v4l2_ctrl *blue;\n\tstruct v4l2_ctrl *red;\n};\n\n \nstruct cmd {\n\tu16 value;\n\tu16 index;\n};\n\nstatic const struct v4l2_pix_format vga_mode[] = {\n\t{800, 600,\n\t\tV4L2_PIX_FMT_SGRBG8,\n\t\tV4L2_FIELD_NONE,\n\t\t.bytesperline = 800,\n\t\t.sizeimage = 800 * 600,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB},\n\t{1600, 1200,\n\t\tV4L2_PIX_FMT_SGRBG8,\n\t\tV4L2_FIELD_NONE,\n\t\t.bytesperline = 1600,\n\t\t.sizeimage = 1600 * 1200,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB},\n\t{3264, 2448,\n\t\tV4L2_PIX_FMT_SGRBG8,\n\t\tV4L2_FIELD_NONE,\n\t\t.bytesperline = 3264,\n\t\t.sizeimage = 3264 * 2448,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB},\n};\n\n \n#if MAX_NURBS < 4\n#error \"Not enough URBs in the gspca table\"\n#endif\n\nstatic int val_reply(struct gspca_dev *gspca_dev, const char *reply, int rc)\n{\n\tif (rc < 0) {\n\t\tgspca_err(gspca_dev, \"reply has error %d\\n\", rc);\n\t\treturn -EIO;\n\t}\n\tif (rc != 1) {\n\t\tgspca_err(gspca_dev, \"Bad reply size %d\\n\", rc);\n\t\treturn -EIO;\n\t}\n\tif (reply[0] != 0x08) {\n\t\tgspca_err(gspca_dev, \"Bad reply 0x%02x\\n\", (int)reply[0]);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic void reg_w(struct gspca_dev *gspca_dev, u16 value, u16 index)\n{\n\tchar *buff = gspca_dev->usb_buf;\n\tint rc;\n\n\tgspca_dbg(gspca_dev, D_USBO,\n\t\t  \"reg_w bReq=0x0B, bReqT=0xC0, wVal=0x%04X, wInd=0x%04X\\n\\n\",\n\t\t  value, index);\n\trc = usb_control_msg(gspca_dev->dev, usb_rcvctrlpipe(gspca_dev->dev, 0),\n\t\t0x0B, 0xC0, value, index, buff, 1, 500);\n\tgspca_dbg(gspca_dev, D_USBO, \"rc=%d, ret={0x%02x}\\n\", rc, (int)buff[0]);\n\tif (rc < 0) {\n\t\tgspca_err(gspca_dev, \"Failed reg_w(0x0B, 0xC0, 0x%04X, 0x%04X) w/ rc %d\\n\",\n\t\t\t  value, index, rc);\n\t\tgspca_dev->usb_err = rc;\n\t\treturn;\n\t}\n\tif (val_reply(gspca_dev, buff, rc)) {\n\t\tgspca_err(gspca_dev, \"Bad reply to reg_w(0x0B, 0xC0, 0x%04X, 0x%04X\\n\",\n\t\t\t  value, index);\n\t\tgspca_dev->usb_err = -EIO;\n\t}\n}\n\nstatic void reg_w_buf(struct gspca_dev *gspca_dev,\n\t\tconst struct cmd *p, int l)\n{\n\tdo {\n\t\treg_w(gspca_dev, p->value, p->index);\n\t\tp++;\n\t} while (--l > 0);\n}\n\nstatic void setexposure(struct gspca_dev *gspca_dev, s32 val)\n{\n\tu16 value;\n\tunsigned int w = gspca_dev->pixfmt.width;\n\n\tif (w == 800)\n\t\tvalue = val * 5;\n\telse if (w == 1600)\n\t\tvalue = val * 3;\n\telse if (w == 3264)\n\t\tvalue = val * 3 / 2;\n\telse {\n\t\tgspca_err(gspca_dev, \"Invalid width %u\\n\", w);\n\t\tgspca_dev->usb_err = -EINVAL;\n\t\treturn;\n\t}\n\tgspca_dbg(gspca_dev, D_STREAM, \"exposure: 0x%04X ms\\n\\n\", value);\n\t \n\t \n\treg_w(gspca_dev, value, REG_COARSE_INTEGRATION_TIME_);\n\treg_w(gspca_dev, value, REG_COARSE_INTEGRATION_TIME_);\n}\n\nstatic int gainify(int in)\n{\n\t \n\tif (in <= 0x7F)\n\t\treturn 0x1000 | in;\n\telse if (in <= 0xFF)\n\t\treturn 0x1080 | in / 2;\n\telse\n\t\treturn 0x1180 | in / 4;\n}\n\nstatic void setggain(struct gspca_dev *gspca_dev, u16 global_gain)\n{\n\tu16 normalized;\n\n\tnormalized = gainify(global_gain);\n\tgspca_dbg(gspca_dev, D_STREAM, \"gain G1/G2 (0x%04X): 0x%04X (src 0x%04X)\\n\\n\",\n\t\t  REG_GREEN1_GAIN,\n\t\t  normalized, global_gain);\n\n\treg_w(gspca_dev, normalized, REG_GREEN1_GAIN);\n\treg_w(gspca_dev, normalized, REG_GREEN2_GAIN);\n}\n\nstatic void setbgain(struct gspca_dev *gspca_dev,\n\t\tu16 gain, u16 global_gain)\n{\n\tu16 normalized;\n\n\tnormalized = global_gain +\n\t\t((u32)global_gain) * gain / GAIN_MAX;\n\tif (normalized > GAIN_MAX) {\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Truncating blue 0x%04X w/ value 0x%04X\\n\\n\",\n\t\t\t  GAIN_MAX, normalized);\n\t\tnormalized = GAIN_MAX;\n\t}\n\tnormalized = gainify(normalized);\n\tgspca_dbg(gspca_dev, D_STREAM, \"gain B (0x%04X): 0x%04X w/ source 0x%04X\\n\\n\",\n\t\t  REG_BLUE_GAIN, normalized, gain);\n\n\treg_w(gspca_dev, normalized, REG_BLUE_GAIN);\n}\n\nstatic void setrgain(struct gspca_dev *gspca_dev,\n\t\tu16 gain, u16 global_gain)\n{\n\tu16 normalized;\n\n\tnormalized = global_gain +\n\t\t((u32)global_gain) * gain / GAIN_MAX;\n\tif (normalized > GAIN_MAX) {\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Truncating gain 0x%04X w/ value 0x%04X\\n\\n\",\n\t\t\t  GAIN_MAX, normalized);\n\t\tnormalized = GAIN_MAX;\n\t}\n\tnormalized = gainify(normalized);\n\tgspca_dbg(gspca_dev, D_STREAM, \"gain R (0x%04X): 0x%04X w / source 0x%04X\\n\\n\",\n\t\t  REG_RED_GAIN, normalized, gain);\n\n\treg_w(gspca_dev, normalized, REG_RED_GAIN);\n}\n\nstatic void configure_wh(struct gspca_dev *gspca_dev)\n{\n\tunsigned int w = gspca_dev->pixfmt.width;\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"configure_wh\\n\\n\");\n\n\tif (w == 800) {\n\t\tstatic const struct cmd reg_init_res[] = {\n\t\t\t{0x0060, REG_X_ADDR_START},\n\t\t\t{0x0CD9, REG_X_ADDR_END},\n\t\t\t{0x0036, REG_Y_ADDR_START},\n\t\t\t{0x098F, REG_Y_ADDR_END},\n\t\t\t{0x07C7, REG_READ_MODE},\n\t\t};\n\n\t\treg_w_buf(gspca_dev,\n\t\t\t       reg_init_res, ARRAY_SIZE(reg_init_res));\n\t} else if (w == 1600) {\n\t\tstatic const struct cmd reg_init_res[] = {\n\t\t\t{0x009C, REG_X_ADDR_START},\n\t\t\t{0x0D19, REG_X_ADDR_END},\n\t\t\t{0x0068, REG_Y_ADDR_START},\n\t\t\t{0x09C5, REG_Y_ADDR_END},\n\t\t\t{0x06C3, REG_READ_MODE},\n\t\t};\n\n\t\treg_w_buf(gspca_dev,\n\t\t\t       reg_init_res, ARRAY_SIZE(reg_init_res));\n\t} else if (w == 3264) {\n\t\tstatic const struct cmd reg_init_res[] = {\n\t\t\t{0x00E8, REG_X_ADDR_START},\n\t\t\t{0x0DA7, REG_X_ADDR_END},\n\t\t\t{0x009E, REG_Y_ADDR_START},\n\t\t\t{0x0A2D, REG_Y_ADDR_END},\n\t\t\t{0x0241, REG_READ_MODE},\n\t\t};\n\n\t\treg_w_buf(gspca_dev,\n\t\t\t       reg_init_res, ARRAY_SIZE(reg_init_res));\n\t} else {\n\t\tgspca_err(gspca_dev, \"bad width %u\\n\", w);\n\t\tgspca_dev->usb_err = -EINVAL;\n\t\treturn;\n\t}\n\n\treg_w(gspca_dev, 0x0000, REG_SCALING_MODE);\n\treg_w(gspca_dev, 0x0010, REG_SCALE_M);\n\treg_w(gspca_dev, w, REG_X_OUTPUT_SIZE);\n\treg_w(gspca_dev, gspca_dev->pixfmt.height, REG_Y_OUTPUT_SIZE);\n\n\tif (w == 800) {\n\t\treg_w(gspca_dev, 0x0384, REG_FRAME_LENGTH_LINES_);\n\t\treg_w(gspca_dev, 0x0960, REG_LINE_LENGTH_PCK_);\n\t} else if (w == 1600) {\n\t\treg_w(gspca_dev, 0x0640, REG_FRAME_LENGTH_LINES_);\n\t\treg_w(gspca_dev, 0x0FA0, REG_LINE_LENGTH_PCK_);\n\t} else if (w == 3264) {\n\t\treg_w(gspca_dev, 0x0B4B, REG_FRAME_LENGTH_LINES_);\n\t\treg_w(gspca_dev, 0x1F40, REG_LINE_LENGTH_PCK_);\n\t} else {\n\t\tgspca_err(gspca_dev, \"bad width %u\\n\", w);\n\t\tgspca_dev->usb_err = -EINVAL;\n\t\treturn;\n\t}\n}\n\n \nstatic void configure_encrypted(struct gspca_dev *gspca_dev)\n{\n\tstatic const struct cmd reg_init_begin[] = {\n\t\t{0x0100, REG_SOFTWARE_RESET},\n\t\t{0x0000, REG_MODE_SELECT},\n\t\t{0x0100, REG_GROUPED_PARAMETER_HOLD},\n\t\t{0x0004, REG_VT_PIX_CLK_DIV},\n\t\t{0x0001, REG_VT_SYS_CLK_DIV},\n\t\t{0x0008, REG_OP_PIX_CLK_DIV},\n\t\t{0x0001, REG_OP_SYS_CLK_DIV},\n\t\t{0x0004, REG_PRE_PLL_CLK_DIV},\n\t\t{0x0040, REG_PLL_MULTIPLIER},\n\t\t{0x0000, REG_GROUPED_PARAMETER_HOLD},\n\t\t{0x0100, REG_GROUPED_PARAMETER_HOLD},\n\t};\n\tstatic const struct cmd reg_init_end[] = {\n\t\t{0x0000, REG_GROUPED_PARAMETER_HOLD},\n\t\t{0x0301, 0x31AE},\n\t\t{0x0805, 0x3064},\n\t\t{0x0071, 0x3170},\n\t\t{0x10DE, REG_RESET_REGISTER},\n\t\t{0x0000, REG_MODE_SELECT},\n\t\t{0x0010, REG_PLL_MULTIPLIER},\n\t\t{0x0100, REG_MODE_SELECT},\n\t};\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"Encrypted begin, w = %u\\n\\n\",\n\t\t  gspca_dev->pixfmt.width);\n\treg_w_buf(gspca_dev, reg_init_begin, ARRAY_SIZE(reg_init_begin));\n\tconfigure_wh(gspca_dev);\n\treg_w_buf(gspca_dev, reg_init_end, ARRAY_SIZE(reg_init_end));\n\treg_w(gspca_dev, 0x0100, REG_GROUPED_PARAMETER_HOLD);\n\treg_w(gspca_dev, 0x0000, REG_GROUPED_PARAMETER_HOLD);\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"Encrypted end\\n\\n\");\n}\n\nstatic int configure(struct gspca_dev *gspca_dev)\n{\n\tint rc;\n\tchar *buff = gspca_dev->usb_buf;\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"configure()\\n\\n\");\n\n\t \n\trc = usb_control_msg(gspca_dev->dev, usb_rcvctrlpipe(gspca_dev->dev, 0),\n\t\t\t     0x16, 0xC0, 0x0000, 0x0000, buff, 2, 500);\n\tif (val_reply(gspca_dev, buff, rc)) {\n\t\tgspca_err(gspca_dev, \"failed key req\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\n\trc = usb_control_msg(gspca_dev->dev, usb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t     0x01, 0x40, 0x0001, 0x000F, NULL, 0, 500);\n\tif (rc < 0) {\n\t\tgspca_err(gspca_dev, \"failed to replay packet 176 w/ rc %d\\n\",\n\t\t\t  rc);\n\t\treturn rc;\n\t}\n\n\trc = usb_control_msg(gspca_dev->dev, usb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t     0x01, 0x40, 0x0000, 0x000F, NULL, 0, 500);\n\tif (rc < 0) {\n\t\tgspca_err(gspca_dev, \"failed to replay packet 178 w/ rc %d\\n\",\n\t\t\t  rc);\n\t\treturn rc;\n\t}\n\n\trc = usb_control_msg(gspca_dev->dev, usb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t     0x01, 0x40, 0x0001, 0x000F, NULL, 0, 500);\n\tif (rc < 0) {\n\t\tgspca_err(gspca_dev, \"failed to replay packet 180 w/ rc %d\\n\",\n\t\t\t  rc);\n\t\treturn rc;\n\t}\n\n\t \n\n\t \n\tgspca_dev->usb_err = 0;\n\tconfigure_encrypted(gspca_dev);\n\tif (gspca_dev->usb_err)\n\t\treturn gspca_dev->usb_err;\n\n\t \n\trc = usb_control_msg(gspca_dev->dev, usb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t     0x01, 0x40, 0x0003, 0x000F, NULL, 0, 500);\n\tif (rc < 0) {\n\t\tgspca_err(gspca_dev, \"failed to replay final packet w/ rc %d\\n\",\n\t\t\t  rc);\n\t\treturn rc;\n\t}\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"Configure complete\\n\\n\");\n\treturn 0;\n}\n\nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t     const struct usb_device_id *id)\n{\n\tgspca_dev->cam.cam_mode = vga_mode;\n\tgspca_dev->cam.nmodes = ARRAY_SIZE(vga_mode);\n\n\t \n\tgspca_dev->cam.no_urb_create = 0;\n\tgspca_dev->cam.bulk_nurbs = 4;\n\t \n\tgspca_dev->cam.bulk_size = BULK_SIZE;\n\t \n\tgspca_dev->cam.bulk = 1;\n\n\treturn 0;\n}\n\nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint rc;\n\n\tsd->this_f = 0;\n\n\trc = configure(gspca_dev);\n\tif (rc < 0) {\n\t\tgspca_err(gspca_dev, \"Failed configure\\n\");\n\t\treturn rc;\n\t}\n\t \n\treturn 0;\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t \n\t\t\tint len)\t \n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (len != BULK_SIZE) {\n\t\t \n\t\tif (sd->this_f + len == gspca_dev->pixfmt.sizeimage) {\n\t\t\tgspca_frame_add(gspca_dev, LAST_PACKET, data, len);\n\t\t\tgspca_dbg(gspca_dev, D_FRAM, \"finish frame sz %u/%u w/ len %u\\n\\n\",\n\t\t\t\t  sd->this_f, gspca_dev->pixfmt.sizeimage, len);\n\t\t \n\t\t} else {\n\t\t\tgspca_frame_add(gspca_dev, DISCARD_PACKET, NULL, 0);\n\t\t\tgspca_dbg(gspca_dev, D_FRAM, \"abort frame sz %u/%u w/ len %u\\n\\n\",\n\t\t\t\t  sd->this_f, gspca_dev->pixfmt.sizeimage, len);\n\t\t}\n\t\tsd->this_f = 0;\n\t} else {\n\t\tif (sd->this_f == 0)\n\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, data, len);\n\t\telse\n\t\t\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n\t\tsd->this_f += len;\n\t}\n}\n\nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\treturn 0;\n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_EXPOSURE:\n\t\tsetexposure(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_GAIN:\n\t\t \n\t\tsetggain(gspca_dev, gspca_dev->gain->val);\n\t\tbreak;\n\tcase V4L2_CID_BLUE_BALANCE:\n\t\tsd->blue->val = ctrl->val;\n\t\tsetbgain(gspca_dev, sd->blue->val, gspca_dev->gain->val);\n\t\tbreak;\n\tcase V4L2_CID_RED_BALANCE:\n\t\tsd->red->val = ctrl->val;\n\t\tsetrgain(gspca_dev, sd->red->val, gspca_dev->gain->val);\n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 4);\n\n\tgspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t \n\t \n\t\tV4L2_CID_EXPOSURE, 0, 800, 1, 350);\n\tgspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, 0, 511, 1, 128);\n\tsd->blue = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BLUE_BALANCE, 0, 1023, 1, 80);\n\tsd->red = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_RED_BALANCE, 0, 1023, 1, 295);\n\n\tif (hdl->error) {\n\t\tgspca_err(gspca_dev, \"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\treturn 0;\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.start = sd_start,\n\t.pkt_scan = sd_pkt_scan,\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t{ USB_DEVICE(0x0547, 0x6801) },  \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\nstatic int sd_probe(struct usb_interface *intf,\n\t\t    const struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t     THIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n#endif\n};\n\nstatic int __init sd_mod_init(void)\n{\n\tint ret;\n\n\tret = usb_register(&sd_driver);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\nstatic void __exit sd_mod_exit(void)\n{\n\tusb_deregister(&sd_driver);\n}\n\nmodule_init(sd_mod_init);\nmodule_exit(sd_mod_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}