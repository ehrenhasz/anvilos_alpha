{
  "module_name": "mr97310a.c",
  "hash_id": "d1c0c369a0fb4fbf01a9df207d0fc0adc99b308c97fce54fb81f616d562b245c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/mr97310a.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"mr97310a\"\n\n#include \"gspca.h\"\n\n#define CAM_TYPE_CIF\t\t\t0\n#define CAM_TYPE_VGA\t\t\t1\n\n#define MR97310A_BRIGHTNESS_DEFAULT\t0\n\n#define MR97310A_EXPOSURE_MIN\t\t0\n#define MR97310A_EXPOSURE_MAX\t\t4095\n#define MR97310A_EXPOSURE_DEFAULT\t1000\n\n#define MR97310A_GAIN_MIN\t\t0\n#define MR97310A_GAIN_MAX\t\t31\n#define MR97310A_GAIN_DEFAULT\t\t25\n\n#define MR97310A_CONTRAST_MIN\t\t0\n#define MR97310A_CONTRAST_MAX\t\t31\n#define MR97310A_CONTRAST_DEFAULT\t23\n\n#define MR97310A_CS_GAIN_MIN\t\t0\n#define MR97310A_CS_GAIN_MAX\t\t0x7ff\n#define MR97310A_CS_GAIN_DEFAULT\t0x110\n\n#define MR97310A_CID_CLOCKDIV (V4L2_CTRL_CLASS_USER + 0x1000)\n#define MR97310A_MIN_CLOCKDIV_MIN\t3\n#define MR97310A_MIN_CLOCKDIV_MAX\t8\n#define MR97310A_MIN_CLOCKDIV_DEFAULT\t3\n\nMODULE_AUTHOR(\"Kyle Guinn <elyk03@gmail.com>,Theodore Kilgore <kilgota@auburn.edu>\");\nMODULE_DESCRIPTION(\"GSPCA/Mars-Semi MR97310A USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic int force_sensor_type = -1;\nmodule_param(force_sensor_type, int, 0644);\nMODULE_PARM_DESC(force_sensor_type, \"Force sensor type (-1 (auto), 0 or 1)\");\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;   \n\tstruct {  \n\t\tstruct v4l2_ctrl *exposure;\n\t\tstruct v4l2_ctrl *min_clockdiv;\n\t};\n\tu8 sof_read;\n\tu8 cam_type;\t \n\tu8 sensor_type;\t \n\tu8 do_lcd_stop;\n\tu8 adj_colors;\n};\n\nstruct sensor_w_data {\n\tu8 reg;\n\tu8 flags;\n\tu8 data[16];\n\tint len;\n};\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev);\n\nstatic const struct v4l2_pix_format vga_mode[] = {\n\t{160, 120, V4L2_PIX_FMT_MR97310A, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 160 * 120,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 4},\n\t{176, 144, V4L2_PIX_FMT_MR97310A, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 176 * 144,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 3},\n\t{320, 240, V4L2_PIX_FMT_MR97310A, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 2},\n\t{352, 288, V4L2_PIX_FMT_MR97310A, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352,\n\t\t.sizeimage = 352 * 288,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{640, 480, V4L2_PIX_FMT_MR97310A, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n};\n\n \nstatic int mr_write(struct gspca_dev *gspca_dev, int len)\n{\n\tint rc;\n\n\trc = usb_bulk_msg(gspca_dev->dev,\n\t\t\t  usb_sndbulkpipe(gspca_dev->dev, 4),\n\t\t\t  gspca_dev->usb_buf, len, NULL, 500);\n\tif (rc < 0)\n\t\tpr_err(\"reg write [%02x] error %d\\n\",\n\t\t       gspca_dev->usb_buf[0], rc);\n\treturn rc;\n}\n\n \nstatic int mr_read(struct gspca_dev *gspca_dev, int len)\n{\n\tint rc;\n\n\trc = usb_bulk_msg(gspca_dev->dev,\n\t\t\t  usb_rcvbulkpipe(gspca_dev->dev, 3),\n\t\t\t  gspca_dev->usb_buf, len, NULL, 500);\n\tif (rc < 0)\n\t\tpr_err(\"reg read [%02x] error %d\\n\",\n\t\t       gspca_dev->usb_buf[0], rc);\n\treturn rc;\n}\n\nstatic int sensor_write_reg(struct gspca_dev *gspca_dev, u8 reg, u8 flags,\n\tconst u8 *data, int len)\n{\n\tgspca_dev->usb_buf[0] = 0x1f;\n\tgspca_dev->usb_buf[1] = flags;\n\tgspca_dev->usb_buf[2] = reg;\n\tmemcpy(gspca_dev->usb_buf + 3, data, len);\n\n\treturn mr_write(gspca_dev, len + 3);\n}\n\nstatic int sensor_write_regs(struct gspca_dev *gspca_dev,\n\tconst struct sensor_w_data *data, int len)\n{\n\tint i, rc;\n\n\tfor (i = 0; i < len; i++) {\n\t\trc = sensor_write_reg(gspca_dev, data[i].reg, data[i].flags,\n\t\t\t\t\t  data[i].data, data[i].len);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int sensor_write1(struct gspca_dev *gspca_dev, u8 reg, u8 data)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 buf, confirm_reg;\n\tint rc;\n\n\tbuf = data;\n\tif (sd->cam_type == CAM_TYPE_CIF) {\n\t\trc = sensor_write_reg(gspca_dev, reg, 0x01, &buf, 1);\n\t\tconfirm_reg = sd->sensor_type ? 0x13 : 0x11;\n\t} else {\n\t\trc = sensor_write_reg(gspca_dev, reg, 0x00, &buf, 1);\n\t\tconfirm_reg = 0x11;\n\t}\n\tif (rc < 0)\n\t\treturn rc;\n\n\tbuf = 0x01;\n\trc = sensor_write_reg(gspca_dev, confirm_reg, 0x00, &buf, 1);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int cam_get_response16(struct gspca_dev *gspca_dev, u8 reg, int verbose)\n{\n\tint err_code;\n\n\tgspca_dev->usb_buf[0] = reg;\n\terr_code = mr_write(gspca_dev, 1);\n\tif (err_code < 0)\n\t\treturn err_code;\n\n\terr_code = mr_read(gspca_dev, 16);\n\tif (err_code < 0)\n\t\treturn err_code;\n\n\tif (verbose)\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"Register: %02x reads %02x%02x%02x\\n\",\n\t\t\t  reg,\n\t\t\t  gspca_dev->usb_buf[0],\n\t\t\t  gspca_dev->usb_buf[1],\n\t\t\t  gspca_dev->usb_buf[2]);\n\n\treturn 0;\n}\n\nstatic int zero_the_pointer(struct gspca_dev *gspca_dev)\n{\n\t__u8 *data = gspca_dev->usb_buf;\n\tint err_code;\n\tu8 status = 0;\n\tint tries = 0;\n\n\terr_code = cam_get_response16(gspca_dev, 0x21, 0);\n\tif (err_code < 0)\n\t\treturn err_code;\n\n\tdata[0] = 0x19;\n\tdata[1] = 0x51;\n\terr_code = mr_write(gspca_dev, 2);\n\tif (err_code < 0)\n\t\treturn err_code;\n\n\terr_code = cam_get_response16(gspca_dev, 0x21, 0);\n\tif (err_code < 0)\n\t\treturn err_code;\n\n\tdata[0] = 0x19;\n\tdata[1] = 0xba;\n\terr_code = mr_write(gspca_dev, 2);\n\tif (err_code < 0)\n\t\treturn err_code;\n\n\terr_code = cam_get_response16(gspca_dev, 0x21, 0);\n\tif (err_code < 0)\n\t\treturn err_code;\n\n\tdata[0] = 0x19;\n\tdata[1] = 0x00;\n\terr_code = mr_write(gspca_dev, 2);\n\tif (err_code < 0)\n\t\treturn err_code;\n\n\terr_code = cam_get_response16(gspca_dev, 0x21, 0);\n\tif (err_code < 0)\n\t\treturn err_code;\n\n\tdata[0] = 0x19;\n\tdata[1] = 0x00;\n\terr_code = mr_write(gspca_dev, 2);\n\tif (err_code < 0)\n\t\treturn err_code;\n\n\twhile (status != 0x0a && tries < 256) {\n\t\terr_code = cam_get_response16(gspca_dev, 0x21, 0);\n\t\tstatus = data[0];\n\t\ttries++;\n\t\tif (err_code < 0)\n\t\t\treturn err_code;\n\t}\n\tif (status != 0x0a)\n\t\tgspca_err(gspca_dev, \"status is %02x\\n\", status);\n\n\ttries = 0;\n\twhile (tries < 4) {\n\t\tdata[0] = 0x19;\n\t\tdata[1] = 0x00;\n\t\terr_code = mr_write(gspca_dev, 2);\n\t\tif (err_code < 0)\n\t\t\treturn err_code;\n\n\t\terr_code = cam_get_response16(gspca_dev, 0x21, 0);\n\t\ttries++;\n\t\tif (err_code < 0)\n\t\t\treturn err_code;\n\t}\n\n\tdata[0] = 0x19;\n\terr_code = mr_write(gspca_dev, 1);\n\tif (err_code < 0)\n\t\treturn err_code;\n\n\terr_code = mr_read(gspca_dev, 16);\n\tif (err_code < 0)\n\t\treturn err_code;\n\n\treturn 0;\n}\n\nstatic int stream_start(struct gspca_dev *gspca_dev)\n{\n\tgspca_dev->usb_buf[0] = 0x01;\n\tgspca_dev->usb_buf[1] = 0x01;\n\treturn mr_write(gspca_dev, 2);\n}\n\nstatic void stream_stop(struct gspca_dev *gspca_dev)\n{\n\tgspca_dev->usb_buf[0] = 0x01;\n\tgspca_dev->usb_buf[1] = 0x00;\n\tif (mr_write(gspca_dev, 2) < 0)\n\t\tgspca_err(gspca_dev, \"Stream Stop failed\\n\");\n}\n\nstatic void lcd_stop(struct gspca_dev *gspca_dev)\n{\n\tgspca_dev->usb_buf[0] = 0x19;\n\tgspca_dev->usb_buf[1] = 0x54;\n\tif (mr_write(gspca_dev, 2) < 0)\n\t\tgspca_err(gspca_dev, \"LCD Stop failed\\n\");\n}\n\nstatic int isoc_enable(struct gspca_dev *gspca_dev)\n{\n\tgspca_dev->usb_buf[0] = 0x00;\n\tgspca_dev->usb_buf[1] = 0x4d;   \n\treturn mr_write(gspca_dev, 2);\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam;\n\tint err_code;\n\n\tcam = &gspca_dev->cam;\n\tcam->cam_mode = vga_mode;\n\tcam->nmodes = ARRAY_SIZE(vga_mode);\n\tsd->do_lcd_stop = 0;\n\n\t \n\terr_code = zero_the_pointer(gspca_dev);\n\tif (err_code < 0)\n\t\treturn err_code;\n\n\terr_code = stream_start(gspca_dev);\n\tif (err_code < 0)\n\t\treturn err_code;\n\n\t \n\terr_code = cam_get_response16(gspca_dev, 0x07, 1);\n\tif (err_code < 0)\n\t\treturn err_code;\n\n\tif (id->idProduct == 0x0110 || id->idProduct == 0x010e) {\n\t\tsd->cam_type = CAM_TYPE_CIF;\n\t\tcam->nmodes--;\n\t\t \n\t\tswitch (gspca_dev->usb_buf[0]) {\n\t\tcase 2:\n\t\t\tsd->sensor_type = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tsd->sensor_type = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unknown CIF Sensor id : %02x\\n\",\n\t\t\t       gspca_dev->usb_buf[1]);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"MR97310A CIF camera detected, sensor: %d\\n\",\n\t\t\t  sd->sensor_type);\n\t} else {\n\t\tsd->cam_type = CAM_TYPE_VGA;\n\n\t\t \n\n\t\tsd->sensor_type = 1;\n\t\tsd->do_lcd_stop = 0;\n\t\tsd->adj_colors = 0;\n\t\tif (gspca_dev->usb_buf[0] == 0x01) {\n\t\t\tsd->sensor_type = 2;\n\t\t} else if ((gspca_dev->usb_buf[0] != 0x03) &&\n\t\t\t\t\t(gspca_dev->usb_buf[0] != 0x04)) {\n\t\t\tpr_err(\"Unknown VGA Sensor id Byte 0: %02x\\n\",\n\t\t\t       gspca_dev->usb_buf[0]);\n\t\t\tpr_err(\"Defaults assumed, may not work\\n\");\n\t\t\tpr_err(\"Please report this\\n\");\n\t\t}\n\t\t \n\t\tif ((gspca_dev->usb_buf[0] == 0x03) &&\n\t\t\t\t\t(gspca_dev->usb_buf[1] == 0x50))\n\t\t\tsd->adj_colors = 1;\n\t\tif (gspca_dev->usb_buf[0] == 0x04) {\n\t\t\tsd->do_lcd_stop = 1;\n\t\t\tswitch (gspca_dev->usb_buf[1]) {\n\t\t\tcase 0x50:\n\t\t\t\tsd->sensor_type = 0;\n\t\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"sensor_type corrected to 0\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 0x20:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_err(\"Unknown VGA Sensor id Byte 1: %02x\\n\",\n\t\t\t\t       gspca_dev->usb_buf[1]);\n\t\t\t\tpr_err(\"Defaults assumed, may not work\\n\");\n\t\t\t\tpr_err(\"Please report this\\n\");\n\t\t\t}\n\t\t}\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"MR97310A VGA camera detected, sensor: %d\\n\",\n\t\t\t  sd->sensor_type);\n\t}\n\t \n\tsd_stopN(gspca_dev);\n\n\tif (force_sensor_type != -1) {\n\t\tsd->sensor_type = !!force_sensor_type;\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"Forcing sensor type to: %d\\n\",\n\t\t\t  sd->sensor_type);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\treturn 0;\n}\n\nstatic int start_cif_cam(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\t__u8 *data = gspca_dev->usb_buf;\n\tint err_code;\n\tstatic const __u8 startup_string[] = {\n\t\t0x00,\n\t\t0x0d,\n\t\t0x01,\n\t\t0x00,  \n\t\t0x00,  \n\t\t0x13,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x50,  \n\t\t0xc0\n\t};\n\n\t \n\n\tmemcpy(data, startup_string, 11);\n\tif (sd->sensor_type)\n\t\tdata[5] = 0xbb;\n\n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 160:\n\t\tdata[9] |= 0x04;   \n\t\tfallthrough;\n\tcase 320:\n\tdefault:\n\t\tdata[3] = 0x28;\t\t\t    \n\t\tdata[4] = 0x3c;\t\t\t    \n\t\tdata[6] = 0x14;\t\t\t    \n\t\tdata[8] = 0x1a + sd->sensor_type;   \n\t\tbreak;\n\tcase 176:\n\t\tdata[9] |= 0x04;   \n\t\tfallthrough;\n\tcase 352:\n\t\tdata[3] = 0x2c;\t\t\t    \n\t\tdata[4] = 0x48;\t\t\t    \n\t\tdata[6] = 0x06;\t\t\t    \n\t\tdata[8] = 0x06 - sd->sensor_type;   \n\t\tbreak;\n\t}\n\terr_code = mr_write(gspca_dev, 11);\n\tif (err_code < 0)\n\t\treturn err_code;\n\n\tif (!sd->sensor_type) {\n\t\tstatic const struct sensor_w_data cif_sensor0_init_data[] = {\n\t\t\t{0x02, 0x00, {0x03, 0x5a, 0xb5, 0x01,\n\t\t\t\t      0x0f, 0x14, 0x0f, 0x10}, 8},\n\t\t\t{0x0c, 0x00, {0x04, 0x01, 0x01, 0x00, 0x1f}, 5},\n\t\t\t{0x12, 0x00, {0x07}, 1},\n\t\t\t{0x1f, 0x00, {0x06}, 1},\n\t\t\t{0x27, 0x00, {0x04}, 1},\n\t\t\t{0x29, 0x00, {0x0c}, 1},\n\t\t\t{0x40, 0x00, {0x40, 0x00, 0x04}, 3},\n\t\t\t{0x50, 0x00, {0x60}, 1},\n\t\t\t{0x60, 0x00, {0x06}, 1},\n\t\t\t{0x6b, 0x00, {0x85, 0x85, 0xc8, 0xc8, 0xc8, 0xc8}, 6},\n\t\t\t{0x72, 0x00, {0x1e, 0x56}, 2},\n\t\t\t{0x75, 0x00, {0x58, 0x40, 0xa2, 0x02, 0x31, 0x02,\n\t\t\t\t      0x31, 0x80, 0x00}, 9},\n\t\t\t{0x11, 0x00, {0x01}, 1},\n\t\t\t{0, 0, {0}, 0}\n\t\t};\n\t\terr_code = sensor_write_regs(gspca_dev, cif_sensor0_init_data,\n\t\t\t\t\t ARRAY_SIZE(cif_sensor0_init_data));\n\t} else {\t \n\t\tstatic const struct sensor_w_data cif_sensor1_init_data[] = {\n\t\t\t \n\t\t\t{0x02, 0x00, {0x10}, 1},\n\t\t\t{0x05, 0x01, {0x22}, 1},  \n\t\t\t{0x06, 0x01, {0x00}, 1},\n\t\t\t{0x09, 0x02, {0x0e}, 1},\n\t\t\t{0x0a, 0x02, {0x05}, 1},\n\t\t\t{0x0b, 0x02, {0x05}, 1},\n\t\t\t{0x0c, 0x02, {0x0f}, 1},\n\t\t\t{0x0d, 0x02, {0x07}, 1},\n\t\t\t{0x0e, 0x02, {0x0c}, 1},\n\t\t\t{0x0f, 0x00, {0x00}, 1},\n\t\t\t{0x10, 0x00, {0x06}, 1},\n\t\t\t{0x11, 0x00, {0x07}, 1},\n\t\t\t{0x12, 0x00, {0x00}, 1},\n\t\t\t{0x13, 0x00, {0x01}, 1},\n\t\t\t{0, 0, {0}, 0}\n\t\t};\n\t\t \n\t\tgspca_dev->usb_buf[0] = 0x0a;\n\t\tgspca_dev->usb_buf[1] = 0x00;\n\t\terr_code = mr_write(gspca_dev, 2);\n\t\tif (err_code < 0)\n\t\t\treturn err_code;\n\t\terr_code = sensor_write_regs(gspca_dev, cif_sensor1_init_data,\n\t\t\t\t\t ARRAY_SIZE(cif_sensor1_init_data));\n\t}\n\treturn err_code;\n}\n\nstatic int start_vga_cam(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\t__u8 *data = gspca_dev->usb_buf;\n\tint err_code;\n\tstatic const __u8 startup_string[] =\n\t\t{0x00, 0x0d, 0x01, 0x00, 0x00, 0x2b, 0x00, 0x00,\n\t\t 0x00, 0x50, 0xc0};\n\t \n\n\tmemcpy(data, startup_string, 11);\n\tif (!sd->sensor_type) {\n\t\tdata[5]  = 0x00;\n\t\tdata[10] = 0x91;\n\t}\n\tif (sd->sensor_type == 2) {\n\t\tdata[5]  = 0x00;\n\t\tdata[10] = 0x18;\n\t}\n\n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 160:\n\t\tdata[9] |= 0x0c;   \n\t\tfallthrough;\n\tcase 320:\n\t\tdata[9] |= 0x04;   \n\t\tfallthrough;\n\tcase 640:\n\tdefault:\n\t\tdata[3] = 0x50;   \n\t\tdata[4] = 0x78;   \n\t\tdata[6] = 0x04;   \n\t\tdata[8] = 0x03;   \n\t\tif (sd->sensor_type == 2) {\n\t\t\tdata[6] = 2;\n\t\t\tdata[8] = 1;\n\t\t}\n\t\tif (sd->do_lcd_stop)\n\t\t\tdata[8] = 0x04;   \n\t\tbreak;\n\n\tcase 176:\n\t\tdata[9] |= 0x04;   \n\t\tfallthrough;\n\tcase 352:\n\t\tdata[3] = 0x2c;   \n\t\tdata[4] = 0x48;   \n\t\tdata[6] = 0x94;   \n\t\tdata[8] = 0x63;   \n\t\tif (sd->do_lcd_stop)\n\t\t\tdata[8] = 0x64;   \n\t\tbreak;\n\t}\n\n\terr_code = mr_write(gspca_dev, 11);\n\tif (err_code < 0)\n\t\treturn err_code;\n\n\tif (!sd->sensor_type) {\n\t\tstatic const struct sensor_w_data vga_sensor0_init_data[] = {\n\t\t\t{0x01, 0x00, {0x0c, 0x00, 0x04}, 3},\n\t\t\t{0x14, 0x00, {0x01, 0xe4, 0x02, 0x84}, 4},\n\t\t\t{0x20, 0x00, {0x00, 0x80, 0x00, 0x08}, 4},\n\t\t\t{0x25, 0x00, {0x03, 0xa9, 0x80}, 3},\n\t\t\t{0x30, 0x00, {0x30, 0x18, 0x10, 0x18}, 4},\n\t\t\t{0, 0, {0}, 0}\n\t\t};\n\t\terr_code = sensor_write_regs(gspca_dev, vga_sensor0_init_data,\n\t\t\t\t\t ARRAY_SIZE(vga_sensor0_init_data));\n\t} else if (sd->sensor_type == 1) {\n\t\tstatic const struct sensor_w_data color_adj[] = {\n\t\t\t{0x02, 0x00, {0x06, 0x59, 0x0c, 0x16, 0x00,\n\t\t\t\t \n\t\t\t\t0x05, 0x01, 0x04}, 8}\n\t\t};\n\n\t\tstatic const struct sensor_w_data color_no_adj[] = {\n\t\t\t{0x02, 0x00, {0x06, 0x59, 0x0c, 0x16, 0x00,\n\t\t\t\t \n\t\t\t\t0x07, 0x00, 0x01}, 8}\n\t\t};\n\n\t\tstatic const struct sensor_w_data vga_sensor1_init_data[] = {\n\t\t\t{0x11, 0x04, {0x01}, 1},\n\t\t\t{0x0a, 0x00, {0x00, 0x01, 0x00, 0x00, 0x01,\n\t\t\t \n\t\t\t \n\t\t\t\t0x00, 0x0a}, 7},\n\t\t\t{0x11, 0x04, {0x01}, 1},\n\t\t\t{0x12, 0x00, {0x00, 0x63, 0x00, 0x70, 0x00, 0x00}, 6},\n\t\t\t{0x11, 0x04, {0x01}, 1},\n\t\t\t{0, 0, {0}, 0}\n\t\t};\n\n\t\tif (sd->adj_colors)\n\t\t\terr_code = sensor_write_regs(gspca_dev, color_adj,\n\t\t\t\t\t ARRAY_SIZE(color_adj));\n\t\telse\n\t\t\terr_code = sensor_write_regs(gspca_dev, color_no_adj,\n\t\t\t\t\t ARRAY_SIZE(color_no_adj));\n\n\t\tif (err_code < 0)\n\t\t\treturn err_code;\n\n\t\terr_code = sensor_write_regs(gspca_dev, vga_sensor1_init_data,\n\t\t\t\t\t ARRAY_SIZE(vga_sensor1_init_data));\n\t} else {\t \n\t\tstatic const struct sensor_w_data vga_sensor2_init_data[] = {\n\n\t\t\t{0x01, 0x00, {0x48}, 1},\n\t\t\t{0x02, 0x00, {0x22}, 1},\n\t\t\t \n\t\t\t{0x05, 0x00, {0x10}, 1},\n\t\t\t{0x06, 0x00, {0x00}, 1},\n\t\t\t{0x07, 0x00, {0x00}, 1},\n\t\t\t{0x08, 0x00, {0x00}, 1},\n\t\t\t{0x09, 0x00, {0x00}, 1},\n\t\t\t \n\t\t\t{0x12, 0x00, {0x00}, 1},\n\t\t\t{0x13, 0x00, {0x04}, 1},  \n\t\t\t{0x14, 0x00, {0x00}, 1},\n\t\t\t{0x15, 0x00, {0x06}, 1},\n\t\t\t{0x16, 0x00, {0x01}, 1},\n\t\t\t{0x17, 0x00, {0xe2}, 1},  \n\t\t\t{0x18, 0x00, {0x02}, 1},\n\t\t\t{0x19, 0x00, {0x82}, 1},  \n\t\t\t{0x1a, 0x00, {0x00}, 1},\n\t\t\t{0x1b, 0x00, {0x20}, 1},\n\t\t\t \n\t\t\t{0x1d, 0x00, {0x80}, 1},  \n\t\t\t{0x1e, 0x00, {0x08}, 1},  \n\t\t\t{0x1f, 0x00, {0x0c}, 1},\n\t\t\t{0x20, 0x00, {0x00}, 1},\n\t\t\t{0, 0, {0}, 0}\n\t\t};\n\t\terr_code = sensor_write_regs(gspca_dev, vga_sensor2_init_data,\n\t\t\t\t\t ARRAY_SIZE(vga_sensor2_init_data));\n\t}\n\treturn err_code;\n}\n\nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint err_code;\n\n\tsd->sof_read = 0;\n\n\t \n\terr_code = zero_the_pointer(gspca_dev);\n\tif (err_code < 0)\n\t\treturn err_code;\n\n\terr_code = stream_start(gspca_dev);\n\tif (err_code < 0)\n\t\treturn err_code;\n\n\tif (sd->cam_type == CAM_TYPE_CIF) {\n\t\terr_code = start_cif_cam(gspca_dev);\n\t} else {\n\t\terr_code = start_vga_cam(gspca_dev);\n\t}\n\tif (err_code < 0)\n\t\treturn err_code;\n\n\treturn isoc_enable(gspca_dev);\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tstream_stop(gspca_dev);\n\t \n\tzero_the_pointer(gspca_dev);\n\tif (sd->do_lcd_stop)\n\t\tlcd_stop(gspca_dev);\n}\n\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 sign_reg = 7;   \n\tu8 value_reg = 8;  \n\tstatic const u8 quick_clix_table[] =\n\t \n\t\t{ 0, 4, 8, 12, 1, 2, 3, 5, 6, 9,  7, 10, 13, 11, 14, 15};\n\tif (sd->cam_type == CAM_TYPE_VGA) {\n\t\tsign_reg += 4;\n\t\tvalue_reg += 4;\n\t}\n\n\t \n\tif (val > 0) {\n\t\tsensor_write1(gspca_dev, sign_reg, 0x00);\n\t} else {\n\t\tsensor_write1(gspca_dev, sign_reg, 0x01);\n\t\tval = 257 - val;\n\t}\n\t \n\tif (sd->do_lcd_stop)\n\t\tval = quick_clix_table[val];\n\n\tsensor_write1(gspca_dev, value_reg, val);\n}\n\nstatic void setexposure(struct gspca_dev *gspca_dev, s32 expo, s32 min_clockdiv)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint exposure = MR97310A_EXPOSURE_DEFAULT;\n\tu8 buf[2];\n\n\tif (sd->cam_type == CAM_TYPE_CIF && sd->sensor_type == 1) {\n\t\t \n\t\texposure = (expo * 9267) / 10000 + 300;\n\t\tsensor_write1(gspca_dev, 3, exposure >> 4);\n\t\tsensor_write1(gspca_dev, 4, exposure & 0x0f);\n\t} else if (sd->sensor_type == 2) {\n\t\texposure = expo;\n\t\texposure >>= 3;\n\t\tsensor_write1(gspca_dev, 3, exposure >> 8);\n\t\tsensor_write1(gspca_dev, 4, exposure & 0xff);\n\t} else {\n\t\t \n\t\tu8 clockdiv = (60 * expo + 7999) / 8000;\n\n\t\t \n\t\tif (clockdiv < min_clockdiv && gspca_dev->pixfmt.width >= 320)\n\t\t\tclockdiv = min_clockdiv;\n\t\telse if (clockdiv < 2)\n\t\t\tclockdiv = 2;\n\n\t\tif (sd->cam_type == CAM_TYPE_VGA && clockdiv < 4)\n\t\t\tclockdiv = 4;\n\n\t\t \n\t\texposure = (60 * 511 * expo) / (8000 * clockdiv);\n\t\tif (exposure > 511)\n\t\t\texposure = 511;\n\n\t\t \n\t\texposure = 511 - exposure;\n\n\t\tbuf[0] = exposure & 0xff;\n\t\tbuf[1] = exposure >> 8;\n\t\tsensor_write_reg(gspca_dev, 0x0e, 0, buf, 2);\n\t\tsensor_write1(gspca_dev, 0x02, clockdiv);\n\t}\n}\n\nstatic void setgain(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 gainreg;\n\n\tif (sd->cam_type == CAM_TYPE_CIF && sd->sensor_type == 1)\n\t\tsensor_write1(gspca_dev, 0x0e, val);\n\telse if (sd->cam_type == CAM_TYPE_VGA && sd->sensor_type == 2)\n\t\tfor (gainreg = 0x0a; gainreg < 0x11; gainreg += 2) {\n\t\t\tsensor_write1(gspca_dev, gainreg, val >> 8);\n\t\t\tsensor_write1(gspca_dev, gainreg + 1, val & 0xff);\n\t\t}\n\telse\n\t\tsensor_write1(gspca_dev, 0x10, val);\n}\n\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 val)\n{\n\tsensor_write1(gspca_dev, 0x1c, val);\n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsetbrightness(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tsetcontrast(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE:\n\t\tsetexposure(gspca_dev, sd->exposure->val,\n\t\t\t    sd->min_clockdiv ? sd->min_clockdiv->val : 0);\n\t\tbreak;\n\tcase V4L2_CID_GAIN:\n\t\tsetgain(gspca_dev, ctrl->val);\n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\tstatic const struct v4l2_ctrl_config clockdiv = {\n\t\t.ops = &sd_ctrl_ops,\n\t\t.id = MR97310A_CID_CLOCKDIV,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Minimum Clock Divider\",\n\t\t.min = MR97310A_MIN_CLOCKDIV_MIN,\n\t\t.max = MR97310A_MIN_CLOCKDIV_MAX,\n\t\t.step = 1,\n\t\t.def = MR97310A_MIN_CLOCKDIV_DEFAULT,\n\t};\n\tbool has_brightness = false;\n\tbool has_argus_brightness = false;\n\tbool has_contrast = false;\n\tbool has_gain = false;\n\tbool has_cs_gain = false;\n\tbool has_exposure = false;\n\tbool has_clockdiv = false;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 4);\n\n\t \n\tif (sd->cam_type == CAM_TYPE_CIF) {\n\t\t \n\t\tif (sd->sensor_type == 0)\n\t\t\thas_exposure = has_gain = has_clockdiv = true;\n\t\telse\n\t\t\thas_exposure = has_gain = has_brightness = true;\n\t} else {\n\t\t \n\t\tif (sd->sensor_type == 0)\n\t\t\t;  \n\t\telse if (sd->sensor_type == 2)\n\t\t\thas_exposure = has_cs_gain = has_contrast = true;\n\t\telse if (sd->do_lcd_stop)\n\t\t\thas_exposure = has_gain = has_argus_brightness =\n\t\t\t\thas_clockdiv = true;\n\t\telse\n\t\t\thas_exposure = has_gain = has_brightness =\n\t\t\t\thas_clockdiv = true;\n\t}\n\n\t \n\t \n\tif (has_brightness)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, -254, 255, 1,\n\t\t\tMR97310A_BRIGHTNESS_DEFAULT);\n\telse if (has_argus_brightness)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 15, 1,\n\t\t\tMR97310A_BRIGHTNESS_DEFAULT);\n\tif (has_contrast)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, MR97310A_CONTRAST_MIN,\n\t\t\tMR97310A_CONTRAST_MAX, 1, MR97310A_CONTRAST_DEFAULT);\n\tif (has_gain)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, MR97310A_GAIN_MIN, MR97310A_GAIN_MAX,\n\t\t\t1, MR97310A_GAIN_DEFAULT);\n\telse if (has_cs_gain)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops, V4L2_CID_GAIN,\n\t\t\tMR97310A_CS_GAIN_MIN, MR97310A_CS_GAIN_MAX,\n\t\t\t1, MR97310A_CS_GAIN_DEFAULT);\n\tif (has_exposure)\n\t\tsd->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE, MR97310A_EXPOSURE_MIN,\n\t\t\tMR97310A_EXPOSURE_MAX, 1, MR97310A_EXPOSURE_DEFAULT);\n\tif (has_clockdiv)\n\t\tsd->min_clockdiv = v4l2_ctrl_new_custom(hdl, &clockdiv, NULL);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\tif (has_exposure && has_clockdiv)\n\t\tv4l2_ctrl_cluster(2, &sd->exposure);\n\treturn 0;\n}\n\n \n#include \"pac_common.h\"\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t \n\t\t\tint len)\t\t \n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tunsigned char *sof;\n\n\tsof = pac_find_sof(gspca_dev, &sd->sof_read, data, len);\n\tif (sof) {\n\t\tint n;\n\n\t\t \n\t\tn = sof - data;\n\t\tif (n > sizeof pac_sof_marker)\n\t\t\tn -= sizeof pac_sof_marker;\n\t\telse\n\t\t\tn = 0;\n\t\tgspca_frame_add(gspca_dev, LAST_PACKET,\n\t\t\t\t\tdata, n);\n\t\t \n\t\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\t\tpac_sof_marker, sizeof pac_sof_marker);\n\t\tlen -= sof - data;\n\t\tdata = sof;\n\t}\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = MODULE_NAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.pkt_scan = sd_pkt_scan,\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x08ca, 0x0110)},\t \n\t{USB_DEVICE(0x08ca, 0x0111)},\t \n\t{USB_DEVICE(0x093a, 0x010f)},\t \n\t{USB_DEVICE(0x093a, 0x010e)},\t \n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t    const struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t       THIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}