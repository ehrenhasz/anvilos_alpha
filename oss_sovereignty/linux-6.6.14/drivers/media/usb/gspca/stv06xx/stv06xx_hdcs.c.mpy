{
  "module_name": "stv06xx_hdcs.c",
  "hash_id": "d18221078e8911b62a0ef80eb85728f44fce666356d8ea74cc1d1609cc2b01af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/stv06xx/stv06xx_hdcs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"stv06xx_hdcs.h\"\n\nstatic struct v4l2_pix_format hdcs1x00_mode[] = {\n\t{\n\t\tHDCS_1X00_DEF_WIDTH,\n\t\tHDCS_1X00_DEF_HEIGHT,\n\t\tV4L2_PIX_FMT_SGRBG8,\n\t\tV4L2_FIELD_NONE,\n\t\t.sizeimage =\n\t\t\tHDCS_1X00_DEF_WIDTH * HDCS_1X00_DEF_HEIGHT,\n\t\t.bytesperline = HDCS_1X00_DEF_WIDTH,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1\n\t}\n};\n\nstatic struct v4l2_pix_format hdcs1020_mode[] = {\n\t{\n\t\tHDCS_1020_DEF_WIDTH,\n\t\tHDCS_1020_DEF_HEIGHT,\n\t\tV4L2_PIX_FMT_SGRBG8,\n\t\tV4L2_FIELD_NONE,\n\t\t.sizeimage =\n\t\t\tHDCS_1020_DEF_WIDTH * HDCS_1020_DEF_HEIGHT,\n\t\t.bytesperline = HDCS_1020_DEF_WIDTH,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1\n\t}\n};\n\nenum hdcs_power_state {\n\tHDCS_STATE_SLEEP,\n\tHDCS_STATE_IDLE,\n\tHDCS_STATE_RUN\n};\n\n \nstruct hdcs {\n\tenum hdcs_power_state state;\n\tint w, h;\n\n\t \n\tstruct {\n\t\tint left, top;\n\t\tint width, height;\n\t\tint border;\n\t} array;\n\n\tstruct {\n\t\t \n\t\tu8 cto;\n\t\t \n\t\tu8 cpo;\n\t\t \n\t\tu16 rs;\n\t\t \n\t\tu16 er;\n\t} exp;\n\n\tint psmp;\n};\n\nstatic int hdcs_reg_write_seq(struct sd *sd, u8 reg, u8 *vals, u8 len)\n{\n\tu8 regs[I2C_MAX_BYTES * 2];\n\tint i;\n\n\tif (unlikely((len <= 0) || (len >= I2C_MAX_BYTES) ||\n\t\t     (reg + len > 0xff)))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < len; i++) {\n\t\tregs[2 * i] = reg;\n\t\tregs[2 * i + 1] = vals[i];\n\t\t \n\t\treg += 2;\n\t}\n\n\treturn stv06xx_write_sensor_bytes(sd, regs, len);\n}\n\nstatic int hdcs_set_state(struct sd *sd, enum hdcs_power_state state)\n{\n\tstruct hdcs *hdcs = sd->sensor_priv;\n\tu8 val;\n\tint ret;\n\n\tif (hdcs->state == state)\n\t\treturn 0;\n\n\t \n\tif (hdcs->state != HDCS_STATE_IDLE) {\n\t\tret = stv06xx_write_sensor(sd, HDCS_REG_CONTROL(sd), 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\thdcs->state = HDCS_STATE_IDLE;\n\n\tif (state == HDCS_STATE_IDLE)\n\t\treturn 0;\n\n\tswitch (state) {\n\tcase HDCS_STATE_SLEEP:\n\t\tval = HDCS_SLEEP_MODE;\n\t\tbreak;\n\n\tcase HDCS_STATE_RUN:\n\t\tval = HDCS_RUN_ENABLE;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = stv06xx_write_sensor(sd, HDCS_REG_CONTROL(sd), val);\n\n\t \n\tif (!ret)\n\t\thdcs->state = state;\n\n\treturn ret;\n}\n\nstatic int hdcs_reset(struct sd *sd)\n{\n\tstruct hdcs *hdcs = sd->sensor_priv;\n\tint err;\n\n\terr = stv06xx_write_sensor(sd, HDCS_REG_CONTROL(sd), 1);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = stv06xx_write_sensor(sd, HDCS_REG_CONTROL(sd), 0);\n\tif (err < 0)\n\t\thdcs->state = HDCS_STATE_IDLE;\n\n\treturn err;\n}\n\nstatic int hdcs_set_exposure(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct hdcs *hdcs = sd->sensor_priv;\n\tint rowexp, srowexp;\n\tint max_srowexp;\n\t \n\tint ct;\n\t \n\tint cp;\n\t \n\tint rp;\n\t \n\tint mnct;\n\tint cycles, err;\n\tu8 exp[14];\n\n\tcycles = val * HDCS_CLK_FREQ_MHZ * 257;\n\n\tct = hdcs->exp.cto + hdcs->psmp + (HDCS_ADC_START_SIG_DUR + 2);\n\tcp = hdcs->exp.cto + (hdcs->w * ct / 2);\n\n\t \n\trp = hdcs->exp.rs + cp;\n\n\trowexp = cycles / rp;\n\n\t \n\tcycles -= rowexp * rp;\n\n\t \n\tif (IS_1020(sd)) {\n\t\t \n\t\tsrowexp = hdcs->w - (cycles + hdcs->exp.er + 13) / ct;\n\n\t\tmnct = (hdcs->exp.er + 12 + ct - 1) / ct;\n\t\tmax_srowexp = hdcs->w - mnct;\n\t} else {\n\t\t \n\t\tsrowexp = cp - hdcs->exp.er - 6 - cycles;\n\n\t\tmnct = (hdcs->exp.er + 5 + ct - 1) / ct;\n\t\tmax_srowexp = cp - mnct * ct - 1;\n\t}\n\n\tif (srowexp < 0)\n\t\tsrowexp = 0;\n\telse if (srowexp > max_srowexp)\n\t\tsrowexp = max_srowexp;\n\n\tif (IS_1020(sd)) {\n\t\texp[0] = HDCS20_CONTROL;\n\t\texp[1] = 0x00;\t\t \n\t\texp[2] = HDCS_ROWEXPL;\n\t\texp[3] = rowexp & 0xff;\n\t\texp[4] = HDCS_ROWEXPH;\n\t\texp[5] = rowexp >> 8;\n\t\texp[6] = HDCS20_SROWEXP;\n\t\texp[7] = (srowexp >> 2) & 0xff;\n\t\texp[8] = HDCS20_ERROR;\n\t\texp[9] = 0x10;\t\t \n\t\texp[10] = HDCS20_CONTROL;\n\t\texp[11] = 0x04;\t\t \n\t\terr = stv06xx_write_sensor_bytes(sd, exp, 6);\n\t} else {\n\t\texp[0] = HDCS00_CONTROL;\n\t\texp[1] = 0x00;          \n\t\texp[2] = HDCS_ROWEXPL;\n\t\texp[3] = rowexp & 0xff;\n\t\texp[4] = HDCS_ROWEXPH;\n\t\texp[5] = rowexp >> 8;\n\t\texp[6] = HDCS00_SROWEXPL;\n\t\texp[7] = srowexp & 0xff;\n\t\texp[8] = HDCS00_SROWEXPH;\n\t\texp[9] = srowexp >> 8;\n\t\texp[10] = HDCS_STATUS;\n\t\texp[11] = 0x10;          \n\t\texp[12] = HDCS00_CONTROL;\n\t\texp[13] = 0x04;          \n\t\terr = stv06xx_write_sensor_bytes(sd, exp, 7);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tgspca_dbg(gspca_dev, D_CONF, \"Writing exposure %d, rowexp %d, srowexp %d\\n\",\n\t\t  val, rowexp, srowexp);\n\treturn err;\n}\n\nstatic int hdcs_set_gains(struct sd *sd, u8 g)\n{\n\tint err;\n\tu8 gains[4];\n\n\t \n\tif (g > 127)\n\t\tg = 0x80 | (g / 2);\n\n\tgains[0] = g;\n\tgains[1] = g;\n\tgains[2] = g;\n\tgains[3] = g;\n\n\terr = hdcs_reg_write_seq(sd, HDCS_ERECPGA, gains, 4);\n\treturn err;\n}\n\nstatic int hdcs_set_gain(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tgspca_dbg(gspca_dev, D_CONF, \"Writing gain %d\\n\", val);\n\treturn hdcs_set_gains((struct sd *) gspca_dev,\n\t\t\t       val & 0xff);\n}\n\nstatic int hdcs_set_size(struct sd *sd,\n\t\tunsigned int width, unsigned int height)\n{\n\tstruct hdcs *hdcs = sd->sensor_priv;\n\tu8 win[4];\n\tunsigned int x, y;\n\tint err;\n\n\t \n\twidth = (width + 3) & ~0x3;\n\theight = (height + 3) & ~0x3;\n\n\tif (width > hdcs->array.width)\n\t\twidth = hdcs->array.width;\n\n\tif (IS_1020(sd)) {\n\t\t \n\t\tif (height + 2 * hdcs->array.border + HDCS_1020_BOTTOM_Y_SKIP\n\t\t\t\t  > hdcs->array.height)\n\t\t\theight = hdcs->array.height - 2 * hdcs->array.border -\n\t\t\t\tHDCS_1020_BOTTOM_Y_SKIP;\n\n\t\ty = (hdcs->array.height - HDCS_1020_BOTTOM_Y_SKIP - height) / 2\n\t\t\t\t+ hdcs->array.top;\n\t} else {\n\t\tif (height > hdcs->array.height)\n\t\t\theight = hdcs->array.height;\n\n\t\ty = hdcs->array.top + (hdcs->array.height - height) / 2;\n\t}\n\n\tx = hdcs->array.left + (hdcs->array.width - width) / 2;\n\n\twin[0] = y / 4;\n\twin[1] = x / 4;\n\twin[2] = (y + height) / 4 - 1;\n\twin[3] = (x + width) / 4 - 1;\n\n\terr = hdcs_reg_write_seq(sd, HDCS_FWROW, win, 4);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\thdcs->w = width;\n\thdcs->h = height;\n\treturn err;\n}\n\nstatic int hdcs_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tint err = -EINVAL;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_GAIN:\n\t\terr = hdcs_set_gain(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE:\n\t\terr = hdcs_set_exposure(gspca_dev, ctrl->val);\n\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic const struct v4l2_ctrl_ops hdcs_ctrl_ops = {\n\t.s_ctrl = hdcs_s_ctrl,\n};\n\nstatic int hdcs_init_controls(struct sd *sd)\n{\n\tstruct v4l2_ctrl_handler *hdl = &sd->gspca_dev.ctrl_handler;\n\n\tv4l2_ctrl_handler_init(hdl, 2);\n\tv4l2_ctrl_new_std(hdl, &hdcs_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE, 0, 0xff, 1, HDCS_DEFAULT_EXPOSURE);\n\tv4l2_ctrl_new_std(hdl, &hdcs_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, 0, 0xff, 1, HDCS_DEFAULT_GAIN);\n\treturn hdl->error;\n}\n\nstatic int hdcs_probe_1x00(struct sd *sd)\n{\n\tstruct hdcs *hdcs;\n\tu16 sensor;\n\tint ret;\n\n\tret = stv06xx_read_sensor(sd, HDCS_IDENT, &sensor);\n\tif (ret < 0 || sensor != 0x08)\n\t\treturn -ENODEV;\n\n\tpr_info(\"HDCS-1000/1100 sensor detected\\n\");\n\n\tsd->gspca_dev.cam.cam_mode = hdcs1x00_mode;\n\tsd->gspca_dev.cam.nmodes = ARRAY_SIZE(hdcs1x00_mode);\n\n\thdcs = kmalloc(sizeof(struct hdcs), GFP_KERNEL);\n\tif (!hdcs)\n\t\treturn -ENOMEM;\n\n\thdcs->array.left = 8;\n\thdcs->array.top = 8;\n\thdcs->array.width = HDCS_1X00_DEF_WIDTH;\n\thdcs->array.height = HDCS_1X00_DEF_HEIGHT;\n\thdcs->array.border = 4;\n\n\thdcs->exp.cto = 4;\n\thdcs->exp.cpo = 2;\n\thdcs->exp.rs = 186;\n\thdcs->exp.er = 100;\n\n\t \n\thdcs->psmp = (sd->bridge == BRIDGE_STV602) ? 20 : 5;\n\n\tsd->sensor_priv = hdcs;\n\n\treturn 0;\n}\n\nstatic int hdcs_probe_1020(struct sd *sd)\n{\n\tstruct hdcs *hdcs;\n\tu16 sensor;\n\tint ret;\n\n\tret = stv06xx_read_sensor(sd, HDCS_IDENT, &sensor);\n\tif (ret < 0 || sensor != 0x10)\n\t\treturn -ENODEV;\n\n\tpr_info(\"HDCS-1020 sensor detected\\n\");\n\n\tsd->gspca_dev.cam.cam_mode = hdcs1020_mode;\n\tsd->gspca_dev.cam.nmodes = ARRAY_SIZE(hdcs1020_mode);\n\n\thdcs = kmalloc(sizeof(struct hdcs), GFP_KERNEL);\n\tif (!hdcs)\n\t\treturn -ENOMEM;\n\n\t \n\thdcs->array.left = 24;\n\thdcs->array.top  = 4;\n\thdcs->array.width = HDCS_1020_DEF_WIDTH;\n\thdcs->array.height = 304;\n\thdcs->array.border = 4;\n\n\thdcs->psmp = 6;\n\n\thdcs->exp.cto = 3;\n\thdcs->exp.cpo = 3;\n\thdcs->exp.rs = 155;\n\thdcs->exp.er = 96;\n\n\tsd->sensor_priv = hdcs;\n\n\treturn 0;\n}\n\nstatic int hdcs_start(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"Starting stream\\n\");\n\n\treturn hdcs_set_state(sd, HDCS_STATE_RUN);\n}\n\nstatic int hdcs_stop(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"Halting stream\\n\");\n\n\treturn hdcs_set_state(sd, HDCS_STATE_SLEEP);\n}\n\nstatic int hdcs_init(struct sd *sd)\n{\n\tstruct hdcs *hdcs = sd->sensor_priv;\n\tint i, err = 0;\n\n\t \n\tif (sd->bridge == BRIDGE_STV602)\n\t\tstv06xx_write_bridge(sd, STV_STV0600_EMULATION, 1);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(stv_bridge_init) && !err; i++) {\n\t\terr = stv06xx_write_bridge(sd, stv_bridge_init[i][0],\n\t\t\t\t\t   stv_bridge_init[i][1]);\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\thdcs_reset(sd);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(stv_sensor_init) && !err; i++) {\n\t\terr = stv06xx_write_sensor(sd, stv_sensor_init[i][0],\n\t\t\t\t\t     stv_sensor_init[i][1]);\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = stv06xx_write_sensor(sd, HDCS_REG_CONFIG(sd), BIT(3));\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (IS_1020(sd))\n\t\terr = stv06xx_write_sensor(sd, HDCS_TCTRL,\n\t\t\t\t(HDCS_ADC_START_SIG_DUR << 6) | hdcs->psmp);\n\telse\n\t\terr = stv06xx_write_sensor(sd, HDCS_TCTRL,\n\t\t\t\t(HDCS_ADC_START_SIG_DUR << 5) | hdcs->psmp);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn hdcs_set_size(sd, hdcs->array.width, hdcs->array.height);\n}\n\nstatic int hdcs_dump(struct sd *sd)\n{\n\tu16 reg, val;\n\n\tpr_info(\"Dumping sensor registers:\\n\");\n\n\tfor (reg = HDCS_IDENT; reg <= HDCS_ROWEXPH; reg++) {\n\t\tstv06xx_read_sensor(sd, reg, &val);\n\t\tpr_info(\"reg 0x%02x = 0x%02x\\n\", reg, val);\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}