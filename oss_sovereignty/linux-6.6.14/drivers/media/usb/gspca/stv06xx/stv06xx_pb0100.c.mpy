{
  "module_name": "stv06xx_pb0100.c",
  "hash_id": "919b95f90133dde975eee6e8eced823e72bbc1348a1c847e8538e4cfd7558295",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/stv06xx/stv06xx_pb0100.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"stv06xx_pb0100.h\"\n\nstruct pb0100_ctrls {\n\tstruct {  \n\t\tstruct v4l2_ctrl *autogain;\n\t\tstruct v4l2_ctrl *gain;\n\t\tstruct v4l2_ctrl *exposure;\n\t\tstruct v4l2_ctrl *red;\n\t\tstruct v4l2_ctrl *blue;\n\t\tstruct v4l2_ctrl *natural;\n\t};\n\tstruct v4l2_ctrl *target;\n};\n\nstatic struct v4l2_pix_format pb0100_mode[] = {\n \n\t{\n\t\t320,\n\t\t240,\n\t\tV4L2_PIX_FMT_SGRBG8,\n\t\tV4L2_FIELD_NONE,\n\t\t.sizeimage = 320 * 240,\n\t\t.bytesperline = 320,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = PB0100_CROP_TO_VGA\n\t},\n\t{\n\t\t352,\n\t\t288,\n\t\tV4L2_PIX_FMT_SGRBG8,\n\t\tV4L2_FIELD_NONE,\n\t\t.sizeimage = 352 * 288,\n\t\t.bytesperline = 352,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0\n\t}\n};\n\nstatic int pb0100_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\tstruct pb0100_ctrls *ctrls = sd->sensor_priv;\n\tint err = -EINVAL;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUTOGAIN:\n\t\terr = pb0100_set_autogain(gspca_dev, ctrl->val);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (ctrl->val)\n\t\t\tbreak;\n\t\terr = pb0100_set_gain(gspca_dev, ctrls->gain->val);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = pb0100_set_exposure(gspca_dev, ctrls->exposure->val);\n\t\tbreak;\n\tcase V4L2_CTRL_CLASS_USER + 0x1001:\n\t\terr = pb0100_set_autogain_target(gspca_dev, ctrl->val);\n\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic const struct v4l2_ctrl_ops pb0100_ctrl_ops = {\n\t.s_ctrl = pb0100_s_ctrl,\n};\n\nstatic int pb0100_init_controls(struct sd *sd)\n{\n\tstruct v4l2_ctrl_handler *hdl = &sd->gspca_dev.ctrl_handler;\n\tstruct pb0100_ctrls *ctrls;\n\tstatic const struct v4l2_ctrl_config autogain_target = {\n\t\t.ops = &pb0100_ctrl_ops,\n\t\t.id = V4L2_CTRL_CLASS_USER + 0x1000,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Automatic Gain Target\",\n\t\t.max = 255,\n\t\t.step = 1,\n\t\t.def = 128,\n\t};\n\tstatic const struct v4l2_ctrl_config natural_light = {\n\t\t.ops = &pb0100_ctrl_ops,\n\t\t.id = V4L2_CTRL_CLASS_USER + 0x1001,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.name = \"Natural Light Source\",\n\t\t.max = 1,\n\t\t.step = 1,\n\t\t.def = 1,\n\t};\n\n\tctrls = kzalloc(sizeof(*ctrls), GFP_KERNEL);\n\tif (!ctrls)\n\t\treturn -ENOMEM;\n\n\tv4l2_ctrl_handler_init(hdl, 6);\n\tctrls->autogain = v4l2_ctrl_new_std(hdl, &pb0100_ctrl_ops,\n\t\t\tV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\tctrls->exposure = v4l2_ctrl_new_std(hdl, &pb0100_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE, 0, 511, 1, 12);\n\tctrls->gain = v4l2_ctrl_new_std(hdl, &pb0100_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, 0, 255, 1, 128);\n\tctrls->red = v4l2_ctrl_new_std(hdl, &pb0100_ctrl_ops,\n\t\t\tV4L2_CID_RED_BALANCE, -255, 255, 1, 0);\n\tctrls->blue = v4l2_ctrl_new_std(hdl, &pb0100_ctrl_ops,\n\t\t\tV4L2_CID_BLUE_BALANCE, -255, 255, 1, 0);\n\tctrls->natural = v4l2_ctrl_new_custom(hdl, &natural_light, NULL);\n\tctrls->target = v4l2_ctrl_new_custom(hdl, &autogain_target, NULL);\n\tif (hdl->error) {\n\t\tkfree(ctrls);\n\t\treturn hdl->error;\n\t}\n\tsd->sensor_priv = ctrls;\n\tv4l2_ctrl_auto_cluster(5, &ctrls->autogain, 0, false);\n\treturn 0;\n}\n\nstatic int pb0100_probe(struct sd *sd)\n{\n\tu16 sensor;\n\tint err;\n\n\terr = stv06xx_read_sensor(sd, PB_IDENT, &sensor);\n\n\tif (err < 0)\n\t\treturn -ENODEV;\n\tif ((sensor >> 8) != 0x64)\n\t\treturn -ENODEV;\n\n\tpr_info(\"Photobit pb0100 sensor detected\\n\");\n\n\tsd->gspca_dev.cam.cam_mode = pb0100_mode;\n\tsd->gspca_dev.cam.nmodes = ARRAY_SIZE(pb0100_mode);\n\n\treturn 0;\n}\n\nstatic int pb0100_start(struct sd *sd)\n{\n\tint err, packet_size, max_packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tstruct cam *cam = &sd->gspca_dev.cam;\n\tu32 mode = cam->cam_mode[sd->gspca_dev.curr_mode].priv;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt)\n\t\treturn -ENODEV;\n\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\n\t \n\tmax_packet_size = sd->sensor->max_packet_size[sd->gspca_dev.curr_mode];\n\tif (packet_size < max_packet_size)\n\t\tstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(4)|BIT(3)|BIT(1));\n\telse\n\t\tstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(5)|BIT(3)|BIT(1));\n\n\t \n\tif (mode & PB0100_CROP_TO_VGA) {\n\t\tstv06xx_write_sensor(sd, PB_RSTART, 30);\n\t\tstv06xx_write_sensor(sd, PB_CSTART, 20);\n\t\tstv06xx_write_sensor(sd, PB_RWSIZE, 240 - 1);\n\t\tstv06xx_write_sensor(sd, PB_CWSIZE, 320 - 1);\n\t} else {\n\t\tstv06xx_write_sensor(sd, PB_RSTART, 8);\n\t\tstv06xx_write_sensor(sd, PB_CSTART, 4);\n\t\tstv06xx_write_sensor(sd, PB_RWSIZE, 288 - 1);\n\t\tstv06xx_write_sensor(sd, PB_CWSIZE, 352 - 1);\n\t}\n\n\tif (mode & PB0100_SUBSAMPLE) {\n\t\tstv06xx_write_bridge(sd, STV_Y_CTRL, 0x02);  \n\t\tstv06xx_write_bridge(sd, STV_X_CTRL, 0x06);\n\n\t\tstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x10);\n\t} else {\n\t\tstv06xx_write_bridge(sd, STV_Y_CTRL, 0x01);\n\t\tstv06xx_write_bridge(sd, STV_X_CTRL, 0x0a);\n\t\t \n\t\tstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x20);\n\t}\n\n\terr = stv06xx_write_sensor(sd, PB_CONTROL, BIT(5)|BIT(3)|BIT(1));\n\tgspca_dbg(gspca_dev, D_STREAM, \"Started stream, status: %d\\n\", err);\n\n\treturn (err < 0) ? err : 0;\n}\n\nstatic int pb0100_stop(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint err;\n\n\terr = stv06xx_write_sensor(sd, PB_ABORTFRAME, 1);\n\n\tif (err < 0)\n\t\tgoto out;\n\n\t \n\terr = stv06xx_write_sensor(sd, PB_CONTROL, BIT(5)|BIT(3));\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"Halting stream\\n\");\nout:\n\treturn (err < 0) ? err : 0;\n}\n\n \n \nstatic int pb0100_init(struct sd *sd)\n{\n\tstv06xx_write_bridge(sd, STV_REG00, 1);\n\tstv06xx_write_bridge(sd, STV_SCAN_RATE, 0);\n\n\t \n\tstv06xx_write_sensor(sd, PB_RESET, 1);\n\tstv06xx_write_sensor(sd, PB_RESET, 0);\n\n\t \n\tstv06xx_write_sensor(sd, PB_CONTROL, BIT(5)|BIT(3));\n\n\t \n\tstv06xx_write_sensor(sd, PB_PREADCTRL, BIT(12)|BIT(10)|BIT(6));\n\tstv06xx_write_sensor(sd, PB_ADCGLOBALGAIN, 12);\n\n\t \n\t \n\tstv06xx_write_sensor(sd, PB_R28, 12);\n\t \n\tstv06xx_write_sensor(sd, PB_ADCMAXGAIN, 180);\n\t \n\tstv06xx_write_sensor(sd, PB_ADCMINGAIN, 12);\n\t \n\tstv06xx_write_sensor(sd, PB_R54, 3);\n\t \n\tstv06xx_write_sensor(sd, PB_R55, 0);\n\tstv06xx_write_sensor(sd, PB_UPDATEINT, 1);\n\t \n\tstv06xx_write_sensor(sd, PB_R15, 800);\n\t \n\tstv06xx_write_sensor(sd, PB_R17, 10);\n\n\tstv06xx_write_sensor(sd, PB_EXPGAIN, 0);\n\n\t \n\tstv06xx_write_sensor(sd, PB_VOFFSET, 0);\n\t \n\tstv06xx_write_sensor(sd, PB_ADCGAINH, 11);\n\t \n\tstv06xx_write_sensor(sd, PB_ADCGAINL, 0);\n\n\t \n\tstv06xx_write_bridge(sd, STV_REG00, 0x11);\n\tstv06xx_write_bridge(sd, STV_REG03, 0x45);\n\tstv06xx_write_bridge(sd, STV_REG04, 0x07);\n\n\t \n\tstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(4)|BIT(3)|BIT(1));\n\tstv06xx_write_sensor(sd, PB_CFILLIN, 14);\n\tstv06xx_write_sensor(sd, PB_VBL, 0);\n\tstv06xx_write_sensor(sd, PB_FINTTIME, 0);\n\tstv06xx_write_sensor(sd, PB_RINTTIME, 123);\n\n\tstv06xx_write_bridge(sd, STV_REG01, 0xc2);\n\tstv06xx_write_bridge(sd, STV_REG02, 0xb0);\n\treturn 0;\n}\n\nstatic int pb0100_dump(struct sd *sd)\n{\n\treturn 0;\n}\n\nstatic int pb0100_set_gain(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct pb0100_ctrls *ctrls = sd->sensor_priv;\n\n\terr = stv06xx_write_sensor(sd, PB_G1GAIN, val);\n\tif (!err)\n\t\terr = stv06xx_write_sensor(sd, PB_G2GAIN, val);\n\tgspca_dbg(gspca_dev, D_CONF, \"Set green gain to %d, status: %d\\n\",\n\t\t  val, err);\n\n\tif (!err)\n\t\terr = pb0100_set_red_balance(gspca_dev, ctrls->red->val);\n\tif (!err)\n\t\terr = pb0100_set_blue_balance(gspca_dev, ctrls->blue->val);\n\n\treturn err;\n}\n\nstatic int pb0100_set_red_balance(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct pb0100_ctrls *ctrls = sd->sensor_priv;\n\n\tval += ctrls->gain->val;\n\tif (val < 0)\n\t\tval = 0;\n\telse if (val > 255)\n\t\tval = 255;\n\n\terr = stv06xx_write_sensor(sd, PB_RGAIN, val);\n\tgspca_dbg(gspca_dev, D_CONF, \"Set red gain to %d, status: %d\\n\",\n\t\t  val, err);\n\n\treturn err;\n}\n\nstatic int pb0100_set_blue_balance(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct pb0100_ctrls *ctrls = sd->sensor_priv;\n\n\tval += ctrls->gain->val;\n\tif (val < 0)\n\t\tval = 0;\n\telse if (val > 255)\n\t\tval = 255;\n\n\terr = stv06xx_write_sensor(sd, PB_BGAIN, val);\n\tgspca_dbg(gspca_dev, D_CONF, \"Set blue gain to %d, status: %d\\n\",\n\t\t  val, err);\n\n\treturn err;\n}\n\nstatic int pb0100_set_exposure(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint err;\n\n\terr = stv06xx_write_sensor(sd, PB_RINTTIME, val);\n\tgspca_dbg(gspca_dev, D_CONF, \"Set exposure to %d, status: %d\\n\",\n\t\t  val, err);\n\n\treturn err;\n}\n\nstatic int pb0100_set_autogain(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct pb0100_ctrls *ctrls = sd->sensor_priv;\n\n\tif (val) {\n\t\tif (ctrls->natural->val)\n\t\t\tval = BIT(6)|BIT(4)|BIT(0);\n\t\telse\n\t\t\tval = BIT(4)|BIT(0);\n\t} else\n\t\tval = 0;\n\n\terr = stv06xx_write_sensor(sd, PB_EXPGAIN, val);\n\tgspca_dbg(gspca_dev, D_CONF, \"Set autogain to %d (natural: %d), status: %d\\n\",\n\t\t  val, ctrls->natural->val, err);\n\n\treturn err;\n}\n\nstatic int pb0100_set_autogain_target(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err, totalpixels, brightpixels, darkpixels;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\t \n\ttotalpixels = gspca_dev->pixfmt.width * gspca_dev->pixfmt.height;\n\ttotalpixels = totalpixels/(8*8) + totalpixels/(64*64);\n\n\tbrightpixels = (totalpixels * val) >> 8;\n\tdarkpixels   = totalpixels - brightpixels;\n\terr = stv06xx_write_sensor(sd, PB_R21, brightpixels);\n\tif (!err)\n\t\terr = stv06xx_write_sensor(sd, PB_R22, darkpixels);\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set autogain target to %d, status: %d\\n\",\n\t\t  val, err);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}