{
  "module_name": "stv06xx_vv6410.c",
  "hash_id": "2be473fe409e9383e23c6cd4353c567f146c5512738fcc24a5400d5dc71a0c30",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/stv06xx/stv06xx_vv6410.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"stv06xx_vv6410.h\"\n\nstatic struct v4l2_pix_format vv6410_mode[] = {\n\t{\n\t\t356,\n\t\t292,\n\t\tV4L2_PIX_FMT_SGRBG8,\n\t\tV4L2_FIELD_NONE,\n\t\t.sizeimage = 356 * 292,\n\t\t.bytesperline = 356,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0\n\t}\n};\n\nstatic int vv6410_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tint err = -EINVAL;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_HFLIP:\n\t\tif (!gspca_dev->streaming)\n\t\t\treturn 0;\n\t\terr = vv6410_set_hflip(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tif (!gspca_dev->streaming)\n\t\t\treturn 0;\n\t\terr = vv6410_set_vflip(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_GAIN:\n\t\terr = vv6410_set_analog_gain(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE:\n\t\terr = vv6410_set_exposure(gspca_dev, ctrl->val);\n\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic const struct v4l2_ctrl_ops vv6410_ctrl_ops = {\n\t.s_ctrl = vv6410_s_ctrl,\n};\n\nstatic int vv6410_probe(struct sd *sd)\n{\n\tu16 data;\n\tint err;\n\n\terr = stv06xx_read_sensor(sd, VV6410_DEVICEH, &data);\n\tif (err < 0)\n\t\treturn -ENODEV;\n\n\tif (data != 0x19)\n\t\treturn -ENODEV;\n\n\tpr_info(\"vv6410 sensor detected\\n\");\n\n\tsd->gspca_dev.cam.cam_mode = vv6410_mode;\n\tsd->gspca_dev.cam.nmodes = ARRAY_SIZE(vv6410_mode);\n\treturn 0;\n}\n\nstatic int vv6410_init_controls(struct sd *sd)\n{\n\tstruct v4l2_ctrl_handler *hdl = &sd->gspca_dev.ctrl_handler;\n\n\tv4l2_ctrl_handler_init(hdl, 2);\n\t \n\t \n\t \n\t \n\t \n\tv4l2_ctrl_new_std(hdl, &vv6410_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE, 0, 32768, 1, 20000);\n\tv4l2_ctrl_new_std(hdl, &vv6410_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, 0, 15, 1, 10);\n\treturn hdl->error;\n}\n\nstatic int vv6410_init(struct sd *sd)\n{\n\tint err = 0, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(stv_bridge_init); i++)\n\t\tstv06xx_write_bridge(sd, stv_bridge_init[i].addr, stv_bridge_init[i].data);\n\n\terr = stv06xx_write_sensor_bytes(sd, (u8 *) vv6410_sensor_init,\n\t\t\t\t\t ARRAY_SIZE(vv6410_sensor_init));\n\treturn (err < 0) ? err : 0;\n}\n\nstatic int vv6410_start(struct sd *sd)\n{\n\tint err;\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tstruct cam *cam = &sd->gspca_dev.cam;\n\tu32 priv = cam->cam_mode[sd->gspca_dev.curr_mode].priv;\n\n\tif (priv & VV6410_SUBSAMPLE) {\n\t\tgspca_dbg(gspca_dev, D_CONF, \"Enabling subsampling\\n\");\n\t\tstv06xx_write_bridge(sd, STV_Y_CTRL, 0x02);\n\t\tstv06xx_write_bridge(sd, STV_X_CTRL, 0x06);\n\n\t\tstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x10);\n\t} else {\n\t\tstv06xx_write_bridge(sd, STV_Y_CTRL, 0x01);\n\t\tstv06xx_write_bridge(sd, STV_X_CTRL, 0x0a);\n\t\tstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x00);\n\n\t}\n\n\t \n\terr = stv06xx_write_bridge(sd, STV_LED_CTRL, LED_ON);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = stv06xx_write_sensor(sd, VV6410_SETUP0, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"Starting stream\\n\");\n\n\treturn 0;\n}\n\nstatic int vv6410_stop(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint err;\n\n\t \n\terr = stv06xx_write_bridge(sd, STV_LED_CTRL, LED_OFF);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = stv06xx_write_sensor(sd, VV6410_SETUP0, VV6410_LOW_POWER_MODE);\n\tif (err < 0)\n\t\treturn err;\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"Halting stream\\n\");\n\n\treturn 0;\n}\n\nstatic int vv6410_dump(struct sd *sd)\n{\n\tu8 i;\n\tint err = 0;\n\n\tpr_info(\"Dumping all vv6410 sensor registers\\n\");\n\tfor (i = 0; i < 0xff && !err; i++) {\n\t\tu16 data;\n\t\terr = stv06xx_read_sensor(sd, i, &data);\n\t\tpr_info(\"Register 0x%x contained 0x%x\\n\", i, data);\n\t}\n\treturn (err < 0) ? err : 0;\n}\n\nstatic int vv6410_set_hflip(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tu16 i2c_data;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\terr = stv06xx_read_sensor(sd, VV6410_DATAFORMAT, &i2c_data);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (val)\n\t\ti2c_data |= VV6410_HFLIP;\n\telse\n\t\ti2c_data &= ~VV6410_HFLIP;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set horizontal flip to %d\\n\", val);\n\terr = stv06xx_write_sensor(sd, VV6410_DATAFORMAT, i2c_data);\n\n\treturn (err < 0) ? err : 0;\n}\n\nstatic int vv6410_set_vflip(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tu16 i2c_data;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\terr = stv06xx_read_sensor(sd, VV6410_DATAFORMAT, &i2c_data);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (val)\n\t\ti2c_data |= VV6410_VFLIP;\n\telse\n\t\ti2c_data &= ~VV6410_VFLIP;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set vertical flip to %d\\n\", val);\n\terr = stv06xx_write_sensor(sd, VV6410_DATAFORMAT, i2c_data);\n\n\treturn (err < 0) ? err : 0;\n}\n\nstatic int vv6410_set_analog_gain(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set analog gain to %d\\n\", val);\n\terr = stv06xx_write_sensor(sd, VV6410_ANALOGGAIN, 0xf0 | (val & 0xf));\n\n\treturn (err < 0) ? err : 0;\n}\n\nstatic int vv6410_set_exposure(struct gspca_dev *gspca_dev, __s32 val)\n{\n\tint err;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tunsigned int fine, coarse;\n\n\tval = (val * val >> 14) + val / 4;\n\n\tfine = val % VV6410_CIF_LINELENGTH;\n\tcoarse = min(512, val / VV6410_CIF_LINELENGTH);\n\n\tgspca_dbg(gspca_dev, D_CONF, \"Set coarse exposure to %d, fine exposure to %d\\n\",\n\t\t  coarse, fine);\n\n\terr = stv06xx_write_sensor(sd, VV6410_FINEH, fine >> 8);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = stv06xx_write_sensor(sd, VV6410_FINEL, fine & 0xff);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = stv06xx_write_sensor(sd, VV6410_COARSEH, coarse >> 8);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = stv06xx_write_sensor(sd, VV6410_COARSEL, coarse & 0xff);\n\nout:\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}