{
  "module_name": "stv06xx_st6422.c",
  "hash_id": "af7ffc72630cb13f67c75c0e796db863089caa219282f3ac42cdeef0321fa297",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/stv06xx/stv06xx_st6422.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"stv06xx_st6422.h\"\n\nstatic struct v4l2_pix_format st6422_mode[] = {\n\t \n\t{\n\t\t162,\n\t\t120,\n\t\tV4L2_PIX_FMT_SGRBG8,\n\t\tV4L2_FIELD_NONE,\n\t\t.sizeimage = 162 * 120,\n\t\t.bytesperline = 162,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1\n\t},\n\t \n\t{\n\t\t324,\n\t\t240,\n\t\tV4L2_PIX_FMT_SGRBG8,\n\t\tV4L2_FIELD_NONE,\n\t\t.sizeimage = 324 * 244,\n\t\t.bytesperline = 324,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0\n\t},\n};\n\n \nstatic int setbrightness(struct sd *sd, s32 val);\nstatic int setcontrast(struct sd *sd, s32 val);\nstatic int setgain(struct sd *sd, u8 gain);\nstatic int setexposure(struct sd *sd, s16 expo);\n\nstatic int st6422_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\tint err = -EINVAL;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\terr = setbrightness(sd, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\terr = setcontrast(sd, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_GAIN:\n\t\terr = setgain(sd, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE:\n\t\terr = setexposure(sd, ctrl->val);\n\t\tbreak;\n\t}\n\n\t \n\tif (err >= 0)\n\t\terr = stv06xx_write_bridge(sd, 0x143f, 0x01);\n\tsd->gspca_dev.usb_err = err;\n\treturn err;\n}\n\nstatic const struct v4l2_ctrl_ops st6422_ctrl_ops = {\n\t.s_ctrl = st6422_s_ctrl,\n};\n\nstatic int st6422_init_controls(struct sd *sd)\n{\n\tstruct v4l2_ctrl_handler *hdl = &sd->gspca_dev.ctrl_handler;\n\n\tv4l2_ctrl_handler_init(hdl, 4);\n\tv4l2_ctrl_new_std(hdl, &st6422_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 31, 1, 3);\n\tv4l2_ctrl_new_std(hdl, &st6422_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 15, 1, 11);\n\tv4l2_ctrl_new_std(hdl, &st6422_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE, 0, 1023, 1, 256);\n\tv4l2_ctrl_new_std(hdl, &st6422_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, 0, 255, 1, 64);\n\n\treturn hdl->error;\n}\n\nstatic int st6422_probe(struct sd *sd)\n{\n\tif (sd->bridge != BRIDGE_ST6422)\n\t\treturn -ENODEV;\n\n\tpr_info(\"st6422 sensor detected\\n\");\n\n\tsd->gspca_dev.cam.cam_mode = st6422_mode;\n\tsd->gspca_dev.cam.nmodes = ARRAY_SIZE(st6422_mode);\n\treturn 0;\n}\n\nstatic int st6422_init(struct sd *sd)\n{\n\tint err = 0, i;\n\n\tstatic const u16 st6422_bridge_init[][2] = {\n\t\t{ STV_ISO_ENABLE, 0x00 },  \n\t\t{ 0x1436, 0x00 },\n\t\t{ 0x1432, 0x03 },\t \n\t\t{ 0x143a, 0xf9 },\t \n\t\t{ 0x0509, 0x38 },\t \n\t\t{ 0x050a, 0x38 },\t \n\t\t{ 0x050b, 0x38 },\t \n\t\t{ 0x050c, 0x2a },\n\t\t{ 0x050d, 0x01 },\n\n\n\t\t{ 0x1431, 0x00 },\t \n\t\t{ 0x1433, 0x34 },\t \n\t\t{ 0x1438, 0x18 },\t \n \n \n\n\t\t{ 0x1439, 0x00 },\n \n\n\t\t{ 0x143b, 0x05 },\n\t\t{ 0x143c, 0x00 },\t \n\n\n \n \n \n\t\t{ 0x143e, 0x01 },\n\t\t{ 0x143d, 0x00 },\n\n\t\t{ 0x1442, 0xe2 },\n \n \n \n \n\n \n \n \n\n \n \n \n\n\t\t{ 0x1500, 0xd0 },\n\t\t{ 0x1500, 0xd0 },\n\t\t{ 0x1500, 0x50 },\t \n\n\t\t{ 0x1501, 0xaf },\n \n \n\t\t{ 0x1502, 0xc2 },\n \n \n\t\t{ 0x1503, 0x45 },\n \n \n\t\t{ 0x1505, 0x02 },\n \n \n \n\n\t\t{ 0x150e, 0x8e },\n\t\t{ 0x150f, 0x37 },\n\t\t{ 0x15c0, 0x00 },\n\t\t{ 0x15c3, 0x08 },\t \n\n\n\t\t{ 0x143f, 0x01 },\t \n\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(st6422_bridge_init) && !err; i++) {\n\t\terr = stv06xx_write_bridge(sd, st6422_bridge_init[i][0],\n\t\t\t\t\t       st6422_bridge_init[i][1]);\n\t}\n\n\treturn err;\n}\n\nstatic int setbrightness(struct sd *sd, s32 val)\n{\n\t \n\treturn stv06xx_write_bridge(sd, 0x1432, val);\n}\n\nstatic int setcontrast(struct sd *sd, s32 val)\n{\n\t \n\treturn stv06xx_write_bridge(sd, 0x143a, val | 0xf0);\n}\n\nstatic int setgain(struct sd *sd, u8 gain)\n{\n\tint err;\n\n\t \n\terr = stv06xx_write_bridge(sd, 0x0509, gain);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = stv06xx_write_bridge(sd, 0x050a, gain);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = stv06xx_write_bridge(sd, 0x050b, gain);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = stv06xx_write_bridge(sd, 0x050c, 0x2a);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn stv06xx_write_bridge(sd, 0x050d, 0x01);\n}\n\nstatic int setexposure(struct sd *sd, s16 expo)\n{\n\tint err;\n\n\terr = stv06xx_write_bridge(sd, 0x143d, expo & 0xff);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn stv06xx_write_bridge(sd, 0x143e, expo >> 8);\n}\n\nstatic int st6422_start(struct sd *sd)\n{\n\tint err;\n\tstruct cam *cam = &sd->gspca_dev.cam;\n\n\tif (cam->cam_mode[sd->gspca_dev.curr_mode].priv)\n\t\terr = stv06xx_write_bridge(sd, 0x1505, 0x0f);\n\telse\n\t\terr = stv06xx_write_bridge(sd, 0x1505, 0x02);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = stv06xx_write_bridge(sd, 0x143f, 0x01);\n\treturn (err < 0) ? err : 0;\n}\n\nstatic int st6422_stop(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\n\tgspca_dbg(gspca_dev, D_STREAM, \"Halting stream\\n\");\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}