{
  "module_name": "spca561.c",
  "hash_id": "44080b26293ce47376b902488e5d37b1db0bdcc34506426eda5cf7c38897d974",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/spca561.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MODULE_NAME \"spca561\"\n\n#include <linux/input.h>\n#include \"gspca.h\"\n\nMODULE_AUTHOR(\"Michel Xhaard <mxhaard@users.sourceforge.net>\");\nMODULE_DESCRIPTION(\"GSPCA/SPCA561 USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define EXPOSURE_MAX (2047 + 325)\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\t \n\n\tstruct {  \n\t\tstruct v4l2_ctrl *contrast;\n\t\tstruct v4l2_ctrl *hue;\n\t};\n\tstruct v4l2_ctrl *autogain;\n\n#define EXPO12A_DEF 3\n\t__u8 expo12a;\t\t \n\n\t__u8 chip_revision;\n#define Rev012A 0\n#define Rev072A 1\n\n\tsigned char ag_cnt;\n#define AG_CNT_START 13\n};\n\nstatic const struct v4l2_pix_format sif_012a_mode[] = {\n\t{160, 120, V4L2_PIX_FMT_SGBRG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 160 * 120,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 3},\n\t{176, 144, V4L2_PIX_FMT_SGBRG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 176 * 144,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 2},\n\t{320, 240, V4L2_PIX_FMT_SPCA561, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 4 / 8,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{352, 288, V4L2_PIX_FMT_SPCA561, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352,\n\t\t.sizeimage = 352 * 288 * 4 / 8,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n};\n\nstatic const struct v4l2_pix_format sif_072a_mode[] = {\n\t{160, 120, V4L2_PIX_FMT_SGBRG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 160 * 120,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 3},\n\t{176, 144, V4L2_PIX_FMT_SGBRG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 176,\n\t\t.sizeimage = 176 * 144,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 2},\n\t{320, 240, V4L2_PIX_FMT_SGBRG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1},\n\t{352, 288, V4L2_PIX_FMT_SGBRG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 352,\n\t\t.sizeimage = 352 * 288,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0},\n};\n\n \n \n#define SPCA561_OFFSET_SNAP 1\n#define SPCA561_OFFSET_TYPE 2\n#define SPCA561_OFFSET_COMPRESS 3\n#define SPCA561_OFFSET_FRAMSEQ   4\n#define SPCA561_OFFSET_GPIO 5\n#define SPCA561_OFFSET_USBBUFF 6\n#define SPCA561_OFFSET_WIN2GRAVE 7\n#define SPCA561_OFFSET_WIN2RAVE 8\n#define SPCA561_OFFSET_WIN2BAVE 9\n#define SPCA561_OFFSET_WIN2GBAVE 10\n#define SPCA561_OFFSET_WIN1GRAVE 11\n#define SPCA561_OFFSET_WIN1RAVE 12\n#define SPCA561_OFFSET_WIN1BAVE 13\n#define SPCA561_OFFSET_WIN1GBAVE 14\n#define SPCA561_OFFSET_FREQ 15\n#define SPCA561_OFFSET_VSYNC 16\n#define SPCA561_INDEX_I2C_BASE 0x8800\n#define SPCA561_SNAPBIT 0x20\n#define SPCA561_SNAPCTRL 0x40\n\nstatic const u16 rev72a_reset[][2] = {\n\t{0x0000, 0x8114},\t \n\t{0x0001, 0x8114},\t \n\t{0x0000, 0x8112},\t \n\t{}\n};\nstatic const __u16 rev72a_init_data1[][2] = {\n\t{0x0003, 0x8701},\t \n\t{0x0001, 0x8703},\t \n\t{0x0011, 0x8118},\t \n\t{0x0001, 0x8118},\t \n\t{0x0092, 0x8804},\t \n\t{0x0010, 0x8802},\t \n\t{}\n};\nstatic const u16 rev72a_init_sensor1[][2] = {\n\t{0x0001, 0x000d},\n\t{0x0002, 0x0018},\n\t{0x0004, 0x0165},\n\t{0x0005, 0x0021},\n\t{0x0007, 0x00aa},\n\t{0x0020, 0x1504},\n\t{0x0039, 0x0002},\n\t{0x0035, 0x0010},\n\t{0x0009, 0x1049},\n\t{0x0028, 0x000b},\n\t{0x003b, 0x000f},\n\t{0x003c, 0x0000},\n\t{}\n};\nstatic const __u16 rev72a_init_data2[][2] = {\n\t{0x0018, 0x8601},\t \n\t{0x0000, 0x8602},\t \n\t{0x0060, 0x8604},\t \n\t{0x0002, 0x8605},\t \n\t{0x0000, 0x8603},\t \n\t{0x0002, 0x865b},\t \n\t{0x0000, 0x865f},\t \n\t{0x00b0, 0x865d},\t \n\t{0x0090, 0x865e},\t \n\t{0x00e0, 0x8406},\t \n\t{0x0000, 0x8660},\t \n\t{0x0002, 0x8201},\t \n\t{0x0008, 0x8200},\t \n\t{0x0001, 0x8200},\t \n \n\t{0x0000, 0x8611},\t \n\t{0x00fd, 0x8612},\t \n\t{0x0003, 0x8613},\t \n\t{0x0000, 0x8614},\t \n \n\t{0x0035, 0x8651},\t \n\t{0x0040, 0x8652},\t \n\t{0x005f, 0x8653},\t \n\t{0x0040, 0x8654},\t \n\t{0x0002, 0x8502},\t \n\t{0x0011, 0x8802},\n\n\t{0x0087, 0x8700},\t \n\t{0x0081, 0x8702},\t \n\n\t{0x0000, 0x8500},\t \n\t \n\n\t{0x0002, 0x865b},\t \n\t{0x0003, 0x865c},\t \n\t{}\n};\nstatic const u16 rev72a_init_sensor2[][2] = {\n\t{0x0003, 0x0121},\n\t{0x0004, 0x0165},\n\t{0x0005, 0x002f},\t \n\t{0x0006, 0x0000},\t \n\t{0x000a, 0x0002},\n\t{0x0009, 0x1061},\t \n\t{0x0035, 0x0014},\n\t{}\n};\n\n \nstatic const __u16 Pb100_1map8300[][2] = {\n\t \n\t{0x8320, 0x3304},\n\n\t{0x8303, 0x0125},\t \n\t{0x8304, 0x0169},\n\t{0x8328, 0x000b},\n\t{0x833c, 0x0001},\t\t \n\n\t{0x832f, 0x1904},\t\t \n\t{0x8307, 0x00aa},\n\t{0x8301, 0x0003},\n\t{0x8302, 0x000e},\n\t{}\n};\nstatic const __u16 Pb100_2map8300[][2] = {\n\t \n\t{0x8339, 0x0000},\n\t{0x8307, 0x00aa},\n\t{}\n};\n\nstatic const __u16 spca561_161rev12A_data1[][2] = {\n\t{0x29, 0x8118},\t\t \n\t{0x08, 0x8114},\t\t \n\t{0x0e, 0x8112},\t\t \n\t{0x00, 0x8102},\t\t \n\t{0x92, 0x8804},\n\t{0x04, 0x8802},\t\t \n\t{}\n};\nstatic const __u16 spca561_161rev12A_data2[][2] = {\n\t{0x21, 0x8118},\n\t{0x10, 0x8500},\n\t{0x07, 0x8601},\n\t{0x07, 0x8602},\n\t{0x04, 0x8501},\n\n\t{0x07, 0x8201},\t\t \n\t{0x08, 0x8200},\n\t{0x01, 0x8200},\n\n\t{0x90, 0x8604},\n\t{0x00, 0x8605},\n\t{0xb0, 0x8603},\n\n\t \n\t{0x07, 0x8601},\t\t \n\t{0x07, 0x8602},\t\t \n\t{0x00, 0x8610},\t\t \n\t{0x00, 0x8611},\t\t \n\t{0x00, 0x8612},\t\t \n\t{0x00, 0x8613},\t\t \n\t{0x43, 0x8614},\t\t \n\t{0x40, 0x8615},\t\t \n\t{0x71, 0x8616},\t\t \n\t{0x40, 0x8617},\t\t \n\n\t{0x0c, 0x8620},\t\t \n\t{0xc8, 0x8631},\t\t \n\t{0xc8, 0x8634},\t\t \n\t{0x23, 0x8635},\t\t \n\t{0x1f, 0x8636},\t\t \n\t{0xdd, 0x8637},\t\t \n\t{0xe1, 0x8638},\t\t \n\t{0x1d, 0x8639},\t\t \n\t{0x21, 0x863a},\t\t \n\t{0xe3, 0x863b},\t\t \n\t{0xdf, 0x863c},\t\t \n\t{0xf0, 0x8505},\n\t{0x32, 0x850a},\n \n\t \n\t{0x29, 0x8118},\n\t{}\n};\n\nstatic void reg_w_val(struct gspca_dev *gspca_dev, __u16 index, __u8 value)\n{\n\tint ret;\n\tstruct usb_device *dev = gspca_dev->dev;\n\n\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t      0,\t\t \n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      value, index, NULL, 0, 500);\n\tgspca_dbg(gspca_dev, D_USBO, \"reg write: 0x%02x:0x%02x\\n\",\n\t\t  index, value);\n\tif (ret < 0)\n\t\tpr_err(\"reg write: error %d\\n\", ret);\n}\n\nstatic void write_vector(struct gspca_dev *gspca_dev,\n\t\t\tconst __u16 data[][2])\n{\n\tint i;\n\n\ti = 0;\n\twhile (data[i][1] != 0) {\n\t\treg_w_val(gspca_dev, data[i][1], data[i][0]);\n\t\ti++;\n\t}\n}\n\n \nstatic void reg_r(struct gspca_dev *gspca_dev,\n\t\t  __u16 index, __u16 length)\n{\n\tusb_control_msg(gspca_dev->dev,\n\t\t\tusb_rcvctrlpipe(gspca_dev->dev, 0),\n\t\t\t0,\t\t\t \n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0,\t\t\t \n\t\t\tindex, gspca_dev->usb_buf, length, 500);\n}\n\n \nstatic void reg_w_buf(struct gspca_dev *gspca_dev,\n\t\t      __u16 index, __u16 len)\n{\n\tusb_control_msg(gspca_dev->dev,\n\t\t\tusb_sndctrlpipe(gspca_dev->dev, 0),\n\t\t\t0,\t\t\t \n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0,\t\t\t \n\t\t\tindex, gspca_dev->usb_buf, len, 500);\n}\n\nstatic void i2c_write(struct gspca_dev *gspca_dev, __u16 value, __u16 reg)\n{\n\tint retry = 60;\n\n\treg_w_val(gspca_dev, 0x8801, reg);\n\treg_w_val(gspca_dev, 0x8805, value);\n\treg_w_val(gspca_dev, 0x8800, value >> 8);\n\tdo {\n\t\treg_r(gspca_dev, 0x8803, 1);\n\t\tif (!gspca_dev->usb_buf[0])\n\t\t\treturn;\n\t\tmsleep(10);\n\t} while (--retry);\n}\n\nstatic int i2c_read(struct gspca_dev *gspca_dev, __u16 reg, __u8 mode)\n{\n\tint retry = 60;\n\t__u8 value;\n\n\treg_w_val(gspca_dev, 0x8804, 0x92);\n\treg_w_val(gspca_dev, 0x8801, reg);\n\treg_w_val(gspca_dev, 0x8802, mode | 0x01);\n\tdo {\n\t\treg_r(gspca_dev, 0x8803, 1);\n\t\tif (!gspca_dev->usb_buf[0]) {\n\t\t\treg_r(gspca_dev, 0x8800, 1);\n\t\t\tvalue = gspca_dev->usb_buf[0];\n\t\t\treg_r(gspca_dev, 0x8805, 1);\n\t\t\treturn ((int) value << 8) | gspca_dev->usb_buf[0];\n\t\t}\n\t\tmsleep(10);\n\t} while (--retry);\n\treturn -1;\n}\n\nstatic void sensor_mapwrite(struct gspca_dev *gspca_dev,\n\t\t\t    const __u16 (*sensormap)[2])\n{\n\twhile ((*sensormap)[0]) {\n\t\tgspca_dev->usb_buf[0] = (*sensormap)[1];\n\t\tgspca_dev->usb_buf[1] = (*sensormap)[1] >> 8;\n\t\treg_w_buf(gspca_dev, (*sensormap)[0], 2);\n\t\tsensormap++;\n\t}\n}\n\nstatic void write_sensor_72a(struct gspca_dev *gspca_dev,\n\t\t\t    const __u16 (*sensor)[2])\n{\n\twhile ((*sensor)[0]) {\n\t\ti2c_write(gspca_dev, (*sensor)[1], (*sensor)[0]);\n\t\tsensor++;\n\t}\n}\n\nstatic void init_161rev12A(struct gspca_dev *gspca_dev)\n{\n\twrite_vector(gspca_dev, spca561_161rev12A_data1);\n\tsensor_mapwrite(gspca_dev, Pb100_1map8300);\n \n\twrite_vector(gspca_dev, spca561_161rev12A_data2);\n\tsensor_mapwrite(gspca_dev, Pb100_2map8300);\n}\n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam;\n\t__u16 vendor, product;\n\t__u8 data1, data2;\n\n\t \n\treg_r(gspca_dev, 0x8104, 1);\n\tdata1 = gspca_dev->usb_buf[0];\n\treg_r(gspca_dev, 0x8105, 1);\n\tdata2 = gspca_dev->usb_buf[0];\n\tvendor = (data2 << 8) | data1;\n\treg_r(gspca_dev, 0x8106, 1);\n\tdata1 = gspca_dev->usb_buf[0];\n\treg_r(gspca_dev, 0x8107, 1);\n\tdata2 = gspca_dev->usb_buf[0];\n\tproduct = (data2 << 8) | data1;\n\tif (vendor != id->idVendor || product != id->idProduct) {\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"Bad vendor / product from device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcam = &gspca_dev->cam;\n\tcam->needs_full_bandwidth = 1;\n\n\tsd->chip_revision = id->driver_info;\n\tif (sd->chip_revision == Rev012A) {\n\t\tcam->cam_mode = sif_012a_mode;\n\t\tcam->nmodes = ARRAY_SIZE(sif_012a_mode);\n\t} else {\n\t\tcam->cam_mode = sif_072a_mode;\n\t\tcam->nmodes = ARRAY_SIZE(sif_072a_mode);\n\t}\n\tsd->expo12a = EXPO12A_DEF;\n\treturn 0;\n}\n\n \nstatic int sd_init_12a(struct gspca_dev *gspca_dev)\n{\n\tgspca_dbg(gspca_dev, D_STREAM, \"Chip revision: 012a\\n\");\n\tinit_161rev12A(gspca_dev);\n\treturn 0;\n}\nstatic int sd_init_72a(struct gspca_dev *gspca_dev)\n{\n\tgspca_dbg(gspca_dev, D_STREAM, \"Chip revision: 072a\\n\");\n\twrite_vector(gspca_dev, rev72a_reset);\n\tmsleep(200);\n\twrite_vector(gspca_dev, rev72a_init_data1);\n\twrite_sensor_72a(gspca_dev, rev72a_init_sensor1);\n\twrite_vector(gspca_dev, rev72a_init_data2);\n\twrite_sensor_72a(gspca_dev, rev72a_init_sensor2);\n\treg_w_val(gspca_dev, 0x8112, 0x30);\n\treturn 0;\n}\n\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\t__u16 reg;\n\n\tif (sd->chip_revision == Rev012A)\n\t\treg = 0x8610;\n\telse\n\t\treg = 0x8611;\n\n\treg_w_val(gspca_dev, reg + 0, val);\t\t \n\treg_w_val(gspca_dev, reg + 1, val);\t\t \n\treg_w_val(gspca_dev, reg + 2, val);\t\t \n\treg_w_val(gspca_dev, reg + 3, val);\t\t \n}\n\nstatic void setwhite(struct gspca_dev *gspca_dev, s32 white, s32 contrast)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\t__u8 blue, red;\n\t__u16 reg;\n\n\t \n\tred = 0x20 + white * 3 / 8;\n\tblue = 0x90 - white * 5 / 8;\n\tif (sd->chip_revision == Rev012A) {\n\t\treg = 0x8614;\n\t} else {\n\t\treg = 0x8651;\n\t\tred += contrast - 0x20;\n\t\tblue += contrast - 0x20;\n\t\treg_w_val(gspca_dev, 0x8652, contrast + 0x20);  \n\t\treg_w_val(gspca_dev, 0x8654, contrast + 0x20);  \n\t}\n\treg_w_val(gspca_dev, reg, red);\n\treg_w_val(gspca_dev, reg + 2, blue);\n}\n\n \nstatic void setexposure(struct gspca_dev *gspca_dev, s32 val)\n{\n\tint i, expo = 0;\n\n\t \n\n\t \n\tstatic const int table[] =  { 0, 450, 550, 625, EXPOSURE_MAX };\n\n\tfor (i = 0; i < ARRAY_SIZE(table) - 1; i++) {\n\t\tif (val <= table[i + 1]) {\n\t\t\texpo  = val - table[i];\n\t\t\tif (i)\n\t\t\t\texpo += 300;\n\t\t\texpo |= i << 11;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgspca_dev->usb_buf[0] = expo;\n\tgspca_dev->usb_buf[1] = expo >> 8;\n\treg_w_buf(gspca_dev, 0x8309, 2);\n}\n\n \nstatic void setgain(struct gspca_dev *gspca_dev, s32 val)\n{\n\t \n\tif (val < 64)\n\t\tgspca_dev->usb_buf[0] = val;\n\telse if (val < 128)\n\t\tgspca_dev->usb_buf[0] = (val / 2) | 0x40;\n\telse\n\t\tgspca_dev->usb_buf[0] = (val / 4) | 0xc0;\n\n\tgspca_dev->usb_buf[1] = 0;\n\treg_w_buf(gspca_dev, 0x8335, 2);\n}\n\nstatic void setautogain(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (val)\n\t\tsd->ag_cnt = AG_CNT_START;\n\telse\n\t\tsd->ag_cnt = -1;\n}\n\nstatic int sd_start_12a(struct gspca_dev *gspca_dev)\n{\n\tint mode;\n\tstatic const __u8 Reg8391[8] =\n\t\t{0x92, 0x30, 0x20, 0x00, 0x0c, 0x00, 0x00, 0x00};\n\n\tmode = gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv;\n\tif (mode <= 1) {\n\t\t \n\t\treg_w_val(gspca_dev, 0x8500, 0x10 | mode);\n\t} else {\n\t\t \n\t\treg_w_val(gspca_dev, 0x8500, mode);\n\t}\t\t \n\n\tgspca_dev->usb_buf[0] = 0xaa;\n\tgspca_dev->usb_buf[1] = 0x00;\n\treg_w_buf(gspca_dev, 0x8307, 2);\n\t \n\treg_w_val(gspca_dev, 0x8700, 0x8a);\n\t\t\t\t\t \n\treg_w_val(gspca_dev, 0x8112, 0x1e | 0x20);\n\treg_w_val(gspca_dev, 0x850b, 0x03);\n\tmemcpy(gspca_dev->usb_buf, Reg8391, 8);\n\treg_w_buf(gspca_dev, 0x8391, 8);\n\treg_w_buf(gspca_dev, 0x8390, 8);\n\n\t \n\treg_w_val(gspca_dev, 0x8114, 0x00);\n\treturn 0;\n}\nstatic int sd_start_72a(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint Clck;\n\tint mode;\n\n\twrite_vector(gspca_dev, rev72a_reset);\n\tmsleep(200);\n\twrite_vector(gspca_dev, rev72a_init_data1);\n\twrite_sensor_72a(gspca_dev, rev72a_init_sensor1);\n\n\tmode = gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv;\n\tswitch (mode) {\n\tdefault:\n\tcase 0:\n\t\tClck = 0x27;\t\t \n\t\tbreak;\n\tcase 1:\n\t\tClck = 0x25;\n\t\tbreak;\n\tcase 2:\n\t\tClck = 0x22;\n\t\tbreak;\n\tcase 3:\n\t\tClck = 0x21;\n\t\tbreak;\n\t}\n\treg_w_val(gspca_dev, 0x8700, Clck);\t \n\treg_w_val(gspca_dev, 0x8702, 0x81);\n\treg_w_val(gspca_dev, 0x8500, mode);\t \n\twrite_sensor_72a(gspca_dev, rev72a_init_sensor2);\n\tsetwhite(gspca_dev, v4l2_ctrl_g_ctrl(sd->hue),\n\t\t\tv4l2_ctrl_g_ctrl(sd->contrast));\n \n\tsetautogain(gspca_dev, v4l2_ctrl_g_ctrl(sd->autogain));\n\treg_w_val(gspca_dev, 0x8112, 0x10 | 0x20);\n\treturn 0;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (sd->chip_revision == Rev012A) {\n\t\treg_w_val(gspca_dev, 0x8112, 0x0e);\n\t\t \n\t\treg_w_val(gspca_dev, 0x8114, 0x08);\n\t} else {\n\t\treg_w_val(gspca_dev, 0x8112, 0x20);\n \n\t}\n}\n\nstatic void do_autogain(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint expotimes;\n\tint pixelclk;\n\tint gainG;\n\t__u8 R, Gr, Gb, B;\n\tint y;\n\t__u8 luma_mean = 110;\n\t__u8 luma_delta = 20;\n\t__u8 spring = 4;\n\n\tif (sd->ag_cnt < 0)\n\t\treturn;\n\tif (--sd->ag_cnt >= 0)\n\t\treturn;\n\tsd->ag_cnt = AG_CNT_START;\n\n\tswitch (sd->chip_revision) {\n\tcase Rev072A:\n\t\treg_r(gspca_dev, 0x8621, 1);\n\t\tGr = gspca_dev->usb_buf[0];\n\t\treg_r(gspca_dev, 0x8622, 1);\n\t\tR = gspca_dev->usb_buf[0];\n\t\treg_r(gspca_dev, 0x8623, 1);\n\t\tB = gspca_dev->usb_buf[0];\n\t\treg_r(gspca_dev, 0x8624, 1);\n\t\tGb = gspca_dev->usb_buf[0];\n\t\ty = (77 * R + 75 * (Gr + Gb) + 29 * B) >> 8;\n\t\t \n\t\t \n\n\t\tif (y < luma_mean - luma_delta ||\n\t\t    y > luma_mean + luma_delta) {\n\t\t\texpotimes = i2c_read(gspca_dev, 0x09, 0x10);\n\t\t\tpixelclk = 0x0800;\n\t\t\texpotimes = expotimes & 0x07ff;\n\t\t\tgainG = i2c_read(gspca_dev, 0x35, 0x10);\n\n\t\t\texpotimes += (luma_mean - y) >> spring;\n\t\t\tgainG += (luma_mean - y) / 50;\n\n\t\t\tif (gainG > 0x3f)\n\t\t\t\tgainG = 0x3f;\n\t\t\telse if (gainG < 3)\n\t\t\t\tgainG = 3;\n\t\t\ti2c_write(gspca_dev, gainG, 0x35);\n\n\t\t\tif (expotimes > 0x0256)\n\t\t\t\texpotimes = 0x0256;\n\t\t\telse if (expotimes < 3)\n\t\t\t\texpotimes = 3;\n\t\t\ti2c_write(gspca_dev, expotimes | pixelclk, 0x09);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t \n\t\t\tint len)\t\t \n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tlen--;\n\tswitch (*data++) {\t\t\t \n\tcase 0:\t\t\t\t\t \n\t\tgspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\n\n\t\t \n\t\tif (len < 2) {\n\t\t\tgspca_err(gspca_dev, \"Short SOF packet, ignoring\\n\\n\\n\\n\\n\");\n\t\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\t\treturn;\n\t\t}\n\n#if IS_ENABLED(CONFIG_INPUT)\n\t\tif (data[0] & 0x20) {\n\t\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);\n\t\t\tinput_sync(gspca_dev->input_dev);\n\t\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\n\t\t\tinput_sync(gspca_dev->input_dev);\n\t\t}\n#endif\n\n\t\tif (data[1] & 0x10) {\n\t\t\t \n\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, data, len);\n\t\t} else {\n\t\t\t \n\t\t\tif (sd->chip_revision == Rev012A) {\n\t\t\t\tdata += 20;\n\t\t\t\tlen -= 20;\n\t\t\t} else {\n\t\t\t\tdata += 16;\n\t\t\t\tlen -= 16;\n\t\t\t}\n\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, data, len);\n\t\t}\n\t\treturn;\n\tcase 0xff:\t\t\t \n\t\treturn;\n\t}\n\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsetbrightness(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\t \n\t\tsetwhite(gspca_dev, sd->hue->val, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\t \n\t\tsetwhite(gspca_dev, ctrl->val, 0);\n\t\tbreak;\n\tcase V4L2_CID_EXPOSURE:\n\t\tsetexposure(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_GAIN:\n\t\tsetgain(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_AUTOGAIN:\n\t\tsetautogain(gspca_dev, ctrl->val);\n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int sd_init_controls_12a(struct gspca_dev *gspca_dev)\n{\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 3);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_HUE, 1, 0x7f, 1, 0x40);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE, 1, EXPOSURE_MAX, 1, 700);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, 0, 255, 1, 63);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\treturn 0;\n}\n\nstatic int sd_init_controls_72a(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 4);\n\tsd->contrast = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 0x3f, 1, 0x20);\n\tsd->hue = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_HUE, 1, 0x7f, 1, 0x40);\n\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 0x3f, 1, 0x20);\n\tsd->autogain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\tv4l2_ctrl_cluster(2, &sd->contrast);\n\treturn 0;\n}\n\n \nstatic const struct sd_desc sd_desc_12a = {\n\t.name = MODULE_NAME,\n\t.init_controls = sd_init_controls_12a,\n\t.config = sd_config,\n\t.init = sd_init_12a,\n\t.start = sd_start_12a,\n\t.stopN = sd_stopN,\n\t.pkt_scan = sd_pkt_scan,\n#if IS_ENABLED(CONFIG_INPUT)\n\t.other_input = 1,\n#endif\n};\nstatic const struct sd_desc sd_desc_72a = {\n\t.name = MODULE_NAME,\n\t.init_controls = sd_init_controls_72a,\n\t.config = sd_config,\n\t.init = sd_init_72a,\n\t.start = sd_start_72a,\n\t.stopN = sd_stopN,\n\t.pkt_scan = sd_pkt_scan,\n\t.dq_callback = do_autogain,\n#if IS_ENABLED(CONFIG_INPUT)\n\t.other_input = 1,\n#endif\n};\nstatic const struct sd_desc *sd_desc[2] = {\n\t&sd_desc_12a,\n\t&sd_desc_72a\n};\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x041e, 0x401a), .driver_info = Rev072A},\n\t{USB_DEVICE(0x041e, 0x403b), .driver_info = Rev012A},\n\t{USB_DEVICE(0x0458, 0x7004), .driver_info = Rev072A},\n\t{USB_DEVICE(0x0461, 0x0815), .driver_info = Rev072A},\n\t{USB_DEVICE(0x046d, 0x0928), .driver_info = Rev012A},\n\t{USB_DEVICE(0x046d, 0x0929), .driver_info = Rev012A},\n\t{USB_DEVICE(0x046d, 0x092a), .driver_info = Rev012A},\n\t{USB_DEVICE(0x046d, 0x092b), .driver_info = Rev012A},\n\t{USB_DEVICE(0x046d, 0x092c), .driver_info = Rev012A},\n\t{USB_DEVICE(0x046d, 0x092d), .driver_info = Rev012A},\n\t{USB_DEVICE(0x046d, 0x092e), .driver_info = Rev012A},\n\t{USB_DEVICE(0x046d, 0x092f), .driver_info = Rev012A},\n\t{USB_DEVICE(0x04fc, 0x0561), .driver_info = Rev072A},\n\t{USB_DEVICE(0x060b, 0xa001), .driver_info = Rev072A},\n\t{USB_DEVICE(0x10fd, 0x7e50), .driver_info = Rev072A},\n\t{USB_DEVICE(0xabcd, 0xcdee), .driver_info = Rev072A},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t    const struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id,\n\t\t\t\tsd_desc[id->driver_info],\n\t\t\t\tsizeof(struct sd),\n\t\t\t       THIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = MODULE_NAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}