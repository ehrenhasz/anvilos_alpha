{
  "module_name": "gl860.c",
  "hash_id": "b78fc99f136acfe825b6d52717f1e4493cb994c0de67ca6222cccf1cdbaeb9f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/gl860/gl860.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"gspca.h\"\n#include \"gl860.h\"\n\nMODULE_AUTHOR(\"Olivier Lorin <o.lorin@laposte.net>\");\nMODULE_DESCRIPTION(\"Genesys Logic USB PC Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n\nstatic void (*dev_init_settings)(struct gspca_dev *gspca_dev);\n\nstatic int  sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id);\nstatic int  sd_init(struct gspca_dev *gspca_dev);\nstatic int  sd_isoc_init(struct gspca_dev *gspca_dev);\nstatic int  sd_start(struct gspca_dev *gspca_dev);\nstatic void sd_stop0(struct gspca_dev *gspca_dev);\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data, int len);\nstatic void sd_callback(struct gspca_dev *gspca_dev);\n\nstatic int gl860_guess_sensor(struct gspca_dev *gspca_dev,\n\t\t\t\tu16 vendor_id, u16 product_id);\n\n \n\nstatic s32 AC50Hz = 0xff;\nmodule_param(AC50Hz, int, 0644);\nMODULE_PARM_DESC(AC50Hz, \" Does AC power frequency is 50Hz? (0/1)\");\n\nstatic char sensor[7];\nmodule_param_string(sensor, sensor, sizeof(sensor), 0644);\nMODULE_PARM_DESC(sensor,\n\t\t\" Driver sensor ('MI1320'/'MI2020'/'OV9655'/'OV2640')\");\n\n \n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsd->vcur.brightness = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tsd->vcur.contrast = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tsd->vcur.saturation = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\tsd->vcur.hue = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_GAMMA:\n\t\tsd->vcur.gamma = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tsd->vcur.mirror = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tsd->vcur.flip = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_POWER_LINE_FREQUENCY:\n\t\tsd->vcur.AC50Hz = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_WHITE_BALANCE_TEMPERATURE:\n\t\tsd->vcur.whitebal = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_SHARPNESS:\n\t\tsd->vcur.sharpness = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_BACKLIGHT_COMPENSATION:\n\t\tsd->vcur.backlight = ctrl->val;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (gspca_dev->streaming)\n\t\tsd->waitSet = 1;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 11);\n\n\tif (sd->vmax.brightness)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops, V4L2_CID_BRIGHTNESS,\n\t\t\t\t  0, sd->vmax.brightness, 1,\n\t\t\t\t  sd->vcur.brightness);\n\n\tif (sd->vmax.contrast)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops, V4L2_CID_CONTRAST,\n\t\t\t\t  0, sd->vmax.contrast, 1,\n\t\t\t\t  sd->vcur.contrast);\n\n\tif (sd->vmax.saturation)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops, V4L2_CID_SATURATION,\n\t\t\t\t  0, sd->vmax.saturation, 1,\n\t\t\t\t  sd->vcur.saturation);\n\n\tif (sd->vmax.hue)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops, V4L2_CID_HUE,\n\t\t\t\t  0, sd->vmax.hue, 1, sd->vcur.hue);\n\n\tif (sd->vmax.gamma)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops, V4L2_CID_GAMMA,\n\t\t\t\t  0, sd->vmax.gamma, 1, sd->vcur.gamma);\n\n\tif (sd->vmax.mirror)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops, V4L2_CID_HFLIP,\n\t\t\t\t  0, sd->vmax.mirror, 1, sd->vcur.mirror);\n\n\tif (sd->vmax.flip)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops, V4L2_CID_VFLIP,\n\t\t\t\t  0, sd->vmax.flip, 1, sd->vcur.flip);\n\n\tif (sd->vmax.AC50Hz)\n\t\tv4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\n\t\t\t\t  V4L2_CID_POWER_LINE_FREQUENCY,\n\t\t\t\t  sd->vmax.AC50Hz, 0, sd->vcur.AC50Hz);\n\n\tif (sd->vmax.whitebal)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t  V4L2_CID_WHITE_BALANCE_TEMPERATURE,\n\t\t\t\t  0, sd->vmax.whitebal, 1, sd->vcur.whitebal);\n\n\tif (sd->vmax.sharpness)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops, V4L2_CID_SHARPNESS,\n\t\t\t\t  0, sd->vmax.sharpness, 1,\n\t\t\t\t  sd->vcur.sharpness);\n\n\tif (sd->vmax.backlight)\n\t\tv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\t\t  V4L2_CID_BACKLIGHT_COMPENSATION,\n\t\t\t\t  0, sd->vmax.backlight, 1,\n\t\t\t\t  sd->vcur.backlight);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic const struct sd_desc sd_desc_mi1320 = {\n\t.name        = MODULE_NAME,\n\t.config      = sd_config,\n\t.init        = sd_init,\n\t.init_controls = sd_init_controls,\n\t.isoc_init   = sd_isoc_init,\n\t.start       = sd_start,\n\t.stop0       = sd_stop0,\n\t.pkt_scan    = sd_pkt_scan,\n\t.dq_callback = sd_callback,\n};\n\nstatic const struct sd_desc sd_desc_mi2020 = {\n\t.name        = MODULE_NAME,\n\t.config      = sd_config,\n\t.init        = sd_init,\n\t.init_controls = sd_init_controls,\n\t.isoc_init   = sd_isoc_init,\n\t.start       = sd_start,\n\t.stop0       = sd_stop0,\n\t.pkt_scan    = sd_pkt_scan,\n\t.dq_callback = sd_callback,\n};\n\nstatic const struct sd_desc sd_desc_ov2640 = {\n\t.name        = MODULE_NAME,\n\t.config      = sd_config,\n\t.init        = sd_init,\n\t.init_controls = sd_init_controls,\n\t.isoc_init   = sd_isoc_init,\n\t.start       = sd_start,\n\t.stop0       = sd_stop0,\n\t.pkt_scan    = sd_pkt_scan,\n\t.dq_callback = sd_callback,\n};\n\nstatic const struct sd_desc sd_desc_ov9655 = {\n\t.name        = MODULE_NAME,\n\t.config      = sd_config,\n\t.init        = sd_init,\n\t.init_controls = sd_init_controls,\n\t.isoc_init   = sd_isoc_init,\n\t.start       = sd_start,\n\t.stop0       = sd_stop0,\n\t.pkt_scan    = sd_pkt_scan,\n\t.dq_callback = sd_callback,\n};\n\n \n\nstatic struct v4l2_pix_format mi2020_mode[] = {\n\t{ 640,  480, V4L2_PIX_FMT_SGBRG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0\n\t},\n\t{ 800,  598, V4L2_PIX_FMT_SGBRG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 800,\n\t\t.sizeimage = 800 * 598,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1\n\t},\n\t{1280, 1024, V4L2_PIX_FMT_SGBRG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 1280,\n\t\t.sizeimage = 1280 * 1024,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 2\n\t},\n\t{1600, 1198, V4L2_PIX_FMT_SGBRG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 1600,\n\t\t.sizeimage = 1600 * 1198,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 3\n\t},\n};\n\nstatic struct v4l2_pix_format ov2640_mode[] = {\n\t{ 640,  480, V4L2_PIX_FMT_SGBRG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0\n\t},\n\t{ 800,  600, V4L2_PIX_FMT_SGBRG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 800,\n\t\t.sizeimage = 800 * 600,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1\n\t},\n\t{1280,  960, V4L2_PIX_FMT_SGBRG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 1280,\n\t\t.sizeimage = 1280 * 960,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 2\n\t},\n\t{1600, 1200, V4L2_PIX_FMT_SGBRG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 1600,\n\t\t.sizeimage = 1600 * 1200,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 3\n\t},\n};\n\nstatic struct v4l2_pix_format mi1320_mode[] = {\n\t{ 640,  480, V4L2_PIX_FMT_SGBRG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0\n\t},\n\t{ 800,  600, V4L2_PIX_FMT_SGBRG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 800,\n\t\t.sizeimage = 800 * 600,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1\n\t},\n\t{1280,  960, V4L2_PIX_FMT_SGBRG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 1280,\n\t\t.sizeimage = 1280 * 960,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 2\n\t},\n};\n\nstatic struct v4l2_pix_format ov9655_mode[] = {\n\t{ 640,  480, V4L2_PIX_FMT_SGBRG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 0\n\t},\n\t{1280,  960, V4L2_PIX_FMT_SGBRG8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 1280,\n\t\t.sizeimage = 1280 * 960,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = 1\n\t},\n};\n\n \n\n \nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam;\n\tu16 vendor_id, product_id;\n\n\t \n\tvendor_id  = id->idVendor;\n\tproduct_id = id->idProduct;\n\n\tsd->nbRightUp = 1;\n\tsd->nbIm = -1;\n\n\tsd->sensor = 0xff;\n\tif (strcmp(sensor, \"MI1320\") == 0)\n\t\tsd->sensor = ID_MI1320;\n\telse if (strcmp(sensor, \"OV2640\") == 0)\n\t\tsd->sensor = ID_OV2640;\n\telse if (strcmp(sensor, \"OV9655\") == 0)\n\t\tsd->sensor = ID_OV9655;\n\telse if (strcmp(sensor, \"MI2020\") == 0)\n\t\tsd->sensor = ID_MI2020;\n\n\t \n\tif (gl860_guess_sensor(gspca_dev, vendor_id, product_id) == -1)\n\t\treturn -1;\n\n\tcam = &gspca_dev->cam;\n\n\tswitch (sd->sensor) {\n\tcase ID_MI1320:\n\t\tgspca_dev->sd_desc = &sd_desc_mi1320;\n\t\tcam->cam_mode = mi1320_mode;\n\t\tcam->nmodes = ARRAY_SIZE(mi1320_mode);\n\t\tdev_init_settings   = mi1320_init_settings;\n\t\tbreak;\n\n\tcase ID_MI2020:\n\t\tgspca_dev->sd_desc = &sd_desc_mi2020;\n\t\tcam->cam_mode = mi2020_mode;\n\t\tcam->nmodes = ARRAY_SIZE(mi2020_mode);\n\t\tdev_init_settings   = mi2020_init_settings;\n\t\tbreak;\n\n\tcase ID_OV2640:\n\t\tgspca_dev->sd_desc = &sd_desc_ov2640;\n\t\tcam->cam_mode = ov2640_mode;\n\t\tcam->nmodes = ARRAY_SIZE(ov2640_mode);\n\t\tdev_init_settings   = ov2640_init_settings;\n\t\tbreak;\n\n\tcase ID_OV9655:\n\t\tgspca_dev->sd_desc = &sd_desc_ov9655;\n\t\tcam->cam_mode = ov9655_mode;\n\t\tcam->nmodes = ARRAY_SIZE(ov9655_mode);\n\t\tdev_init_settings   = ov9655_init_settings;\n\t\tbreak;\n\t}\n\n\tdev_init_settings(gspca_dev);\n\tif (AC50Hz != 0xff)\n\t\t((struct sd *) gspca_dev)->vcur.AC50Hz = AC50Hz;\n\n\treturn 0;\n}\n\n \nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\treturn sd->dev_init_at_startup(gspca_dev);\n}\n\n \nstatic int sd_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\treturn sd->dev_configure_alt(gspca_dev);\n}\n\n \nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\treturn sd->dev_init_pre_alt(gspca_dev);\n}\n\n \nstatic void sd_stop0(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (!sd->gspca_dev.present)\n\t\treturn;\n\n\treturn sd->dev_post_unset_alt(gspca_dev);\n}\n\n \nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data, int len)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstatic s32 nSkipped;\n\n\ts32 mode = (s32) gspca_dev->curr_mode;\n\ts32 nToSkip =\n\t\tsd->swapRB * (gspca_dev->cam.cam_mode[mode].bytesperline + 1);\n\n\t \n\tswitch (*(s16 *) data) {\n\tcase 0x0202:\t\t \n\t\tgspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\n\t\tnSkipped = 0;\n\t\tif (sd->nbIm >= 0 && sd->nbIm < 10)\n\t\t\tsd->nbIm++;\n\t\tgspca_frame_add(gspca_dev, FIRST_PACKET, NULL, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tdata += 2;\n\t\tlen  -= 2;\n\t\tif (nSkipped + len <= nToSkip)\n\t\t\tnSkipped += len;\n\t\telse {\n\t\t\tif (nSkipped < nToSkip && nSkipped + len > nToSkip) {\n\t\t\t\tdata += nToSkip - nSkipped;\n\t\t\t\tlen  -= nToSkip - nSkipped;\n\t\t\t\tnSkipped = nToSkip + 1;\n\t\t\t}\n\t\t\tgspca_frame_add(gspca_dev,\n\t\t\t\tINTER_PACKET, data, len);\n\t\t}\n\t\tbreak;\n\t}\n}\n\n \n \nstatic void sd_callback(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (!_OV9655_) {\n\t\tu8 state;\n\t\tu8 upsideDown;\n\n\t\t \n\t\tctrl_in(gspca_dev, 0xc0, 2, 0x0000, 0x0000, 1, (void *)&state);\n\n\t\t \n\t\t \n\t\tupsideDown = (state == 0xc8 || state == 0x40);\n\n\t\tif (upsideDown && sd->nbRightUp > -4) {\n\t\t\tif (sd->nbRightUp > 0)\n\t\t\t\tsd->nbRightUp = 0;\n\t\t\tif (sd->nbRightUp == -3) {\n\t\t\t\tsd->mirrorMask = 1;\n\t\t\t\tsd->waitSet = 1;\n\t\t\t}\n\t\t\tsd->nbRightUp--;\n\t\t}\n\t\tif (!upsideDown && sd->nbRightUp < 4) {\n\t\t\tif (sd->nbRightUp  < 0)\n\t\t\t\tsd->nbRightUp = 0;\n\t\t\tif (sd->nbRightUp == 3) {\n\t\t\t\tsd->mirrorMask = 0;\n\t\t\t\tsd->waitSet = 1;\n\t\t\t}\n\t\t\tsd->nbRightUp++;\n\t\t}\n\t}\n\n\tif (sd->waitSet)\n\t\tsd->dev_camera_settings(gspca_dev);\n}\n\n \n\nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x05e3, 0x0503)},\n\t{USB_DEVICE(0x05e3, 0xf191)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, device_table);\n\nstatic int sd_probe(struct usb_interface *intf,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id,\n\t\t\t&sd_desc_mi1320, sizeof(struct sd), THIS_MODULE);\n}\n\nstatic void sd_disconnect(struct usb_interface *intf)\n{\n\tgspca_disconnect(intf);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name       = MODULE_NAME,\n\t.id_table   = device_table,\n\t.probe      = sd_probe,\n\t.disconnect = sd_disconnect,\n#ifdef CONFIG_PM\n\t.suspend    = gspca_suspend,\n\t.resume     = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\n \n\nmodule_usb_driver(sd_driver);\n\n \n\nint gl860_RTx(struct gspca_dev *gspca_dev,\n\t\tunsigned char pref, u32 req, u16 val, u16 index,\n\t\ts32 len, void *pdata)\n{\n\tstruct usb_device *udev = gspca_dev->dev;\n\ts32 r = 0;\n\n\tif (pref == 0x40) {  \n\t\tif (len > 0) {\n\t\t\tmemcpy(gspca_dev->usb_buf, pdata, len);\n\t\t\tr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t\treq, pref, val, index,\n\t\t\t\t\tgspca_dev->usb_buf,\n\t\t\t\t\tlen, 400 + 200 * (len > 1));\n\t\t} else {\n\t\t\tr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t\treq, pref, val, index, NULL, len, 400);\n\t\t}\n\t} else {  \n\t\tif (len > 0) {\n\t\t\tr = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t\t\treq, pref, val, index,\n\t\t\t\t\tgspca_dev->usb_buf,\n\t\t\t\t\tlen, 400 + 200 * (len > 1));\n\t\t\tmemcpy(pdata, gspca_dev->usb_buf, len);\n\t\t} else {\n\t\t\tgspca_err(gspca_dev, \"zero-length read request\\n\");\n\t\t\tr = -EINVAL;\n\t\t}\n\t}\n\n\tif (r < 0)\n\t\tpr_err(\"ctrl transfer failed %4d [p%02x r%d v%04x i%04x len%d]\\n\",\n\t\t       r, pref, req, val, index, len);\n\telse if (len > 1 && r < len)\n\t\tgspca_err(gspca_dev, \"short ctrl transfer %d/%d\\n\", r, len);\n\n\tmsleep(1);\n\n\treturn r;\n}\n\nint fetch_validx(struct gspca_dev *gspca_dev, struct validx *tbl, int len)\n{\n\tint n;\n\n\tfor (n = 0; n < len; n++) {\n\t\tif (tbl[n].idx != 0xffff)\n\t\t\tctrl_out(gspca_dev, 0x40, 1, tbl[n].val,\n\t\t\t\t\ttbl[n].idx, 0, NULL);\n\t\telse if (tbl[n].val == 0xffff)\n\t\t\tbreak;\n\t\telse\n\t\t\tmsleep(tbl[n].val);\n\t}\n\treturn n;\n}\n\nint keep_on_fetching_validx(struct gspca_dev *gspca_dev, struct validx *tbl,\n\t\t\t\tint len, int n)\n{\n\twhile (++n < len) {\n\t\tif (tbl[n].idx != 0xffff)\n\t\t\tctrl_out(gspca_dev, 0x40, 1, tbl[n].val, tbl[n].idx,\n\t\t\t\t\t0, NULL);\n\t\telse if (tbl[n].val == 0xffff)\n\t\t\tbreak;\n\t\telse\n\t\t\tmsleep(tbl[n].val);\n\t}\n\treturn n;\n}\n\nvoid fetch_idxdata(struct gspca_dev *gspca_dev, struct idxdata *tbl, int len)\n{\n\tint n;\n\n\tfor (n = 0; n < len; n++) {\n\t\tif (memcmp(tbl[n].data, \"\\xff\\xff\\xff\", 3) != 0)\n\t\t\tctrl_out(gspca_dev, 0x40, 3, 0x7a00, tbl[n].idx,\n\t\t\t\t\t3, tbl[n].data);\n\t\telse\n\t\t\tmsleep(tbl[n].idx);\n\t}\n}\n\nstatic int gl860_guess_sensor(struct gspca_dev *gspca_dev,\n\t\t\t\tu16 vendor_id, u16 product_id)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 probe, nb26, nb96, nOV, ntry;\n\n\tif (product_id == 0xf191)\n\t\tsd->sensor = ID_MI1320;\n\n\tif (sd->sensor == 0xff) {\n\t\tctrl_in(gspca_dev, 0xc0, 2, 0x0000, 0x0004, 1, &probe);\n\t\tctrl_in(gspca_dev, 0xc0, 2, 0x0000, 0x0004, 1, &probe);\n\n\t\tctrl_out(gspca_dev, 0x40, 1, 0x0000, 0x0000, 0, NULL);\n\t\tmsleep(3);\n\t\tctrl_out(gspca_dev, 0x40, 1, 0x0010, 0x0010, 0, NULL);\n\t\tmsleep(3);\n\t\tctrl_out(gspca_dev, 0x40, 1, 0x0008, 0x00c0, 0, NULL);\n\t\tmsleep(3);\n\t\tctrl_out(gspca_dev, 0x40, 1, 0x0001, 0x00c1, 0, NULL);\n\t\tmsleep(3);\n\t\tctrl_out(gspca_dev, 0x40, 1, 0x0001, 0x00c2, 0, NULL);\n\t\tmsleep(3);\n\t\tctrl_out(gspca_dev, 0x40, 1, 0x0020, 0x0006, 0, NULL);\n\t\tmsleep(3);\n\t\tctrl_out(gspca_dev, 0x40, 1, 0x006a, 0x000d, 0, NULL);\n\t\tmsleep(56);\n\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"probing for sensor MI2020 or OVXXXX\\n\");\n\t\tnOV = 0;\n\t\tfor (ntry = 0; ntry < 4; ntry++) {\n\t\t\tctrl_out(gspca_dev, 0x40, 1, 0x0040, 0x0000, 0, NULL);\n\t\t\tmsleep(3);\n\t\t\tctrl_out(gspca_dev, 0x40, 1, 0x0063, 0x0006, 0, NULL);\n\t\t\tmsleep(3);\n\t\t\tctrl_out(gspca_dev, 0x40, 1, 0x7a00, 0x8030, 0, NULL);\n\t\t\tmsleep(10);\n\t\t\tctrl_in(gspca_dev, 0xc0, 2, 0x7a00, 0x8030, 1, &probe);\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"probe=0x%02x\\n\", probe);\n\t\t\tif (probe == 0xff)\n\t\t\t\tnOV++;\n\t\t}\n\n\t\tif (nOV) {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"0xff -> OVXXXX\\n\");\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"probing for sensor OV2640 or OV9655\");\n\n\t\t\tnb26 = nb96 = 0;\n\t\t\tfor (ntry = 0; ntry < 4; ntry++) {\n\t\t\t\tctrl_out(gspca_dev, 0x40, 1, 0x0040, 0x0000,\n\t\t\t\t\t\t0, NULL);\n\t\t\t\tmsleep(3);\n\t\t\t\tctrl_out(gspca_dev, 0x40, 1, 0x6000, 0x800a,\n\t\t\t\t\t\t0, NULL);\n\t\t\t\tmsleep(10);\n\n\t\t\t\t \n\t\t\t\tctrl_in(gspca_dev, 0xc0, 2, 0x6000, 0x800a,\n\t\t\t\t\t\t1, &probe);\n\n\t\t\t\tif (probe == 0x26 || probe == 0x40) {\n\t\t\t\t\tgspca_dbg(gspca_dev, D_PROBE,\n\t\t\t\t\t\t  \"probe=0x%02x -> OV2640\\n\",\n\t\t\t\t\t\t  probe);\n\t\t\t\t\tsd->sensor = ID_OV2640;\n\t\t\t\t\tnb26 += 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (probe == 0x96 || probe == 0x55) {\n\t\t\t\t\tgspca_dbg(gspca_dev, D_PROBE,\n\t\t\t\t\t\t  \"probe=0x%02x -> OV9655\\n\",\n\t\t\t\t\t\t  probe);\n\t\t\t\t\tsd->sensor = ID_OV9655;\n\t\t\t\t\tnb96 += 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"probe=0x%02x\\n\",\n\t\t\t\t\t  probe);\n\t\t\t\tif (probe == 0x00)\n\t\t\t\t\tnb26++;\n\t\t\t\tif (probe == 0xff)\n\t\t\t\t\tnb96++;\n\t\t\t\tmsleep(3);\n\t\t\t}\n\t\t\tif (nb26 < 4 && nb96 < 4)\n\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tgspca_dbg(gspca_dev, D_PROBE, \"Not any 0xff -> MI2020\\n\");\n\t\t\tsd->sensor = ID_MI2020;\n\t\t}\n\t}\n\n\tif (_MI1320_) {\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"05e3:f191 sensor MI1320 (1.3M)\\n\");\n\t} else if (_MI2020_) {\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"05e3:0503 sensor MI2020 (2.0M)\\n\");\n\t} else if (_OV9655_) {\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"05e3:0503 sensor OV9655 (1.3M)\\n\");\n\t} else if (_OV2640_) {\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"05e3:0503 sensor OV2640 (2.0M)\\n\");\n\t} else {\n\t\tgspca_dbg(gspca_dev, D_PROBE, \"***** Unknown sensor *****\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}