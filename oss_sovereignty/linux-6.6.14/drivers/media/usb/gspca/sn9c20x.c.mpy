{
  "module_name": "sn9c20x.c",
  "hash_id": "99a909f9310fb4456c684099cac3043d11d08f5d4071d82381c1dfc6801a9af3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/gspca/sn9c20x.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/input.h>\n\n#include \"gspca.h\"\n#include \"jpeg.h\"\n\n#include <linux/dmi.h>\n\nMODULE_AUTHOR(\"Brian Johnson <brijohn@gmail.com>, microdia project <microdia@googlegroups.com>\");\nMODULE_DESCRIPTION(\"GSPCA/SN9C20X USB Camera Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define SCALE_MASK\t0x0f\n#define SCALE_160x120\t0\n#define SCALE_320x240\t1\n#define SCALE_640x480\t2\n#define SCALE_1280x1024\t3\n#define MODE_RAW\t0x10\n#define MODE_JPEG\t0x20\n#define MODE_SXGA\t0x80\n\n#define SENSOR_OV9650\t0\n#define SENSOR_OV9655\t1\n#define SENSOR_SOI968\t2\n#define SENSOR_OV7660\t3\n#define SENSOR_OV7670\t4\n#define SENSOR_MT9V011\t5\n#define SENSOR_MT9V111\t6\n#define SENSOR_MT9V112\t7\n#define SENSOR_MT9M001\t8\n#define SENSOR_MT9M111\t9\n#define SENSOR_MT9M112  10\n#define SENSOR_HV7131R\t11\n#define SENSOR_MT9VPRB\t12\n\n \n#define HAS_NO_BUTTON\t0x1\n#define LED_REVERSE\t0x2  \n#define FLIP_DETECT\t0x4\n#define HAS_LED_TORCH\t0x8\n\n \nstruct sd {\n\tstruct gspca_dev gspca_dev;\n\n\tstruct {  \n\t\tstruct v4l2_ctrl *brightness;\n\t\tstruct v4l2_ctrl *contrast;\n\t\tstruct v4l2_ctrl *saturation;\n\t\tstruct v4l2_ctrl *hue;\n\t};\n\tstruct {  \n\t\tstruct v4l2_ctrl *blue;\n\t\tstruct v4l2_ctrl *red;\n\t};\n\tstruct {  \n\t\tstruct v4l2_ctrl *hflip;\n\t\tstruct v4l2_ctrl *vflip;\n\t};\n\tstruct v4l2_ctrl *gamma;\n\tstruct {  \n\t\tstruct v4l2_ctrl *autogain;\n\t\tstruct v4l2_ctrl *exposure;\n\t\tstruct v4l2_ctrl *gain;\n\t};\n\tstruct v4l2_ctrl *jpegqual;\n\n\tstruct v4l2_ctrl *led_mode;\n\n\tstruct work_struct work;\n\n\tu32 pktsz;\t\t\t \n\tu16 npkt;\n\ts8 nchg;\n\tu8 fmt;\t\t\t\t \n\n#define MIN_AVG_LUM 80\n#define MAX_AVG_LUM 130\n\tatomic_t avg_lum;\n\tu8 old_step;\n\tu8 older_step;\n\tu8 exposure_step;\n\n\tu8 i2c_addr;\n\tu8 i2c_intf;\n\tu8 sensor;\n\tu8 hstart;\n\tu8 vstart;\n\n\tu8 jpeg_hdr[JPEG_HDR_SZ];\n\n\tu8 flags;\n};\n\nstatic void qual_upd(struct work_struct *work);\n\nstruct i2c_reg_u8 {\n\tu8 reg;\n\tu8 val;\n};\n\nstruct i2c_reg_u16 {\n\tu8 reg;\n\tu16 val;\n};\n\nstatic const struct dmi_system_id flip_dmi_table[] = {\n\t{\n\t\t.ident = \"MSI MS-1034\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MICRO-STAR INT'L CO.,LTD.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MS-1034\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"0341\")\n\t\t}\n\t},\n\t{\n\t\t.ident = \"MSI MS-1039\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MICRO-STAR INT'L CO.,LTD.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MS-1039\"),\n\t\t}\n\t},\n\t{\n\t\t.ident = \"MSI MS-1632\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"MSI\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"MS-1632\")\n\t\t}\n\t},\n\t{\n\t\t.ident = \"MSI MS-1633X\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"MSI\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"MS-1633X\")\n\t\t}\n\t},\n\t{\n\t\t.ident = \"MSI MS-1635X\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"MSI\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"MS-1635X\")\n\t\t}\n\t},\n\t{\n\t\t.ident = \"ASUSTeK W7J\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK Computer Inc.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"W7J       \")\n\t\t}\n\t},\n\t{}\n};\n\nstatic const struct v4l2_pix_format vga_mode[] = {\n\t{160, 120, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 160 * 120 * 4 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = SCALE_160x120 | MODE_JPEG},\n\t{160, 120, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 160 * 120,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = SCALE_160x120 | MODE_RAW},\n\t{160, 120, V4L2_PIX_FMT_SN9C20X_I420, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 240 * 120,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = SCALE_160x120},\n\t{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 4 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = SCALE_320x240 | MODE_JPEG},\n\t{320, 240, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 ,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = SCALE_320x240 | MODE_RAW},\n\t{320, 240, V4L2_PIX_FMT_SN9C20X_I420, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 480 * 240 ,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = SCALE_320x240},\n\t{640, 480, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 4 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = SCALE_640x480 | MODE_JPEG},\n\t{640, 480, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = SCALE_640x480 | MODE_RAW},\n\t{640, 480, V4L2_PIX_FMT_SN9C20X_I420, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 960 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = SCALE_640x480},\n};\n\nstatic const struct v4l2_pix_format sxga_mode[] = {\n\t{160, 120, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 160 * 120 * 4 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = SCALE_160x120 | MODE_JPEG},\n\t{160, 120, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 160 * 120,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = SCALE_160x120 | MODE_RAW},\n\t{160, 120, V4L2_PIX_FMT_SN9C20X_I420, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 240 * 120,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = SCALE_160x120},\n\t{320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 * 4 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = SCALE_320x240 | MODE_JPEG},\n\t{320, 240, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 ,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = SCALE_320x240 | MODE_RAW},\n\t{320, 240, V4L2_PIX_FMT_SN9C20X_I420, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 480 * 240 ,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = SCALE_320x240},\n\t{640, 480, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480 * 4 / 8 + 590,\n\t\t.colorspace = V4L2_COLORSPACE_JPEG,\n\t\t.priv = SCALE_640x480 | MODE_JPEG},\n\t{640, 480, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = SCALE_640x480 | MODE_RAW},\n\t{640, 480, V4L2_PIX_FMT_SN9C20X_I420, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 960 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = SCALE_640x480},\n\t{1280, 1024, V4L2_PIX_FMT_SBGGR8, V4L2_FIELD_NONE,\n\t\t.bytesperline = 1280,\n\t\t.sizeimage = 1280 * 1024,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = SCALE_1280x1024 | MODE_RAW | MODE_SXGA},\n};\n\nstatic const struct v4l2_pix_format mono_mode[] = {\n\t{160, 120, V4L2_PIX_FMT_GREY, V4L2_FIELD_NONE,\n\t\t.bytesperline = 160,\n\t\t.sizeimage = 160 * 120,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = SCALE_160x120 | MODE_RAW},\n\t{320, 240, V4L2_PIX_FMT_GREY, V4L2_FIELD_NONE,\n\t\t.bytesperline = 320,\n\t\t.sizeimage = 320 * 240 ,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = SCALE_320x240 | MODE_RAW},\n\t{640, 480, V4L2_PIX_FMT_GREY, V4L2_FIELD_NONE,\n\t\t.bytesperline = 640,\n\t\t.sizeimage = 640 * 480,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = SCALE_640x480 | MODE_RAW},\n\t{1280, 1024, V4L2_PIX_FMT_GREY, V4L2_FIELD_NONE,\n\t\t.bytesperline = 1280,\n\t\t.sizeimage = 1280 * 1024,\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.priv = SCALE_1280x1024 | MODE_RAW | MODE_SXGA},\n};\n\nstatic const s16 hsv_red_x[] = {\n\t41,  44,  46,  48,  50,  52,  54,  56,\n\t58,  60,  62,  64,  66,  68,  70,  72,\n\t74,  76,  78,  80,  81,  83,  85,  87,\n\t88,  90,  92,  93,  95,  97,  98, 100,\n\t101, 102, 104, 105, 107, 108, 109, 110,\n\t112, 113, 114, 115, 116, 117, 118, 119,\n\t120, 121, 122, 123, 123, 124, 125, 125,\n\t126, 127, 127, 128, 128, 129, 129, 129,\n\t130, 130, 130, 130, 131, 131, 131, 131,\n\t131, 131, 131, 131, 130, 130, 130, 130,\n\t129, 129, 129, 128, 128, 127, 127, 126,\n\t125, 125, 124, 123, 122, 122, 121, 120,\n\t119, 118, 117, 116, 115, 114, 112, 111,\n\t110, 109, 107, 106, 105, 103, 102, 101,\n\t99,  98,  96,  94,  93,  91,  90,  88,\n\t86,  84,  83,  81,  79,  77,  75,  74,\n\t72,  70,  68,  66,  64,  62,  60,  58,\n\t56,  54,  52,  49,  47,  45,  43,  41,\n\t39,  36,  34,  32,  30,  28,  25,  23,\n\t21,  19,  16,  14,  12,   9,   7,   5,\n\t3,   0,  -1,  -3,  -6,  -8, -10, -12,\n\t-15, -17, -19, -22, -24, -26, -28, -30,\n\t-33, -35, -37, -39, -41, -44, -46, -48,\n\t-50, -52, -54, -56, -58, -60, -62, -64,\n\t-66, -68, -70, -72, -74, -76, -78, -80,\n\t-81, -83, -85, -87, -88, -90, -92, -93,\n\t-95, -97, -98, -100, -101, -102, -104, -105,\n\t-107, -108, -109, -110, -112, -113, -114, -115,\n\t-116, -117, -118, -119, -120, -121, -122, -123,\n\t-123, -124, -125, -125, -126, -127, -127, -128,\n\t-128, -128, -128, -128, -128, -128, -128, -128,\n\t-128, -128, -128, -128, -128, -128, -128, -128,\n\t-128, -128, -128, -128, -128, -128, -128, -128,\n\t-128, -127, -127, -126, -125, -125, -124, -123,\n\t-122, -122, -121, -120, -119, -118, -117, -116,\n\t-115, -114, -112, -111, -110, -109, -107, -106,\n\t-105, -103, -102, -101, -99, -98, -96, -94,\n\t-93, -91, -90, -88, -86, -84, -83, -81,\n\t-79, -77, -75, -74, -72, -70, -68, -66,\n\t-64, -62, -60, -58, -56, -54, -52, -49,\n\t-47, -45, -43, -41, -39, -36, -34, -32,\n\t-30, -28, -25, -23, -21, -19, -16, -14,\n\t-12,  -9,  -7,  -5,  -3,   0,   1,   3,\n\t6,   8,  10,  12,  15,  17,  19,  22,\n\t24,  26,  28,  30,  33,  35,  37,  39, 41\n};\n\nstatic const s16 hsv_red_y[] = {\n\t82,  80,  78,  76,  74,  73,  71,  69,\n\t67,  65,  63,  61,  58,  56,  54,  52,\n\t50,  48,  46,  44,  41,  39,  37,  35,\n\t32,  30,  28,  26,  23,  21,  19,  16,\n\t14,  12,  10,   7,   5,   3,   0,  -1,\n\t-3,  -6,  -8, -10, -13, -15, -17, -19,\n\t-22, -24, -26, -29, -31, -33, -35, -38,\n\t-40, -42, -44, -46, -48, -51, -53, -55,\n\t-57, -59, -61, -63, -65, -67, -69, -71,\n\t-73, -75, -77, -79, -81, -82, -84, -86,\n\t-88, -89, -91, -93, -94, -96, -98, -99,\n\t-101, -102, -104, -105, -106, -108, -109, -110,\n\t-112, -113, -114, -115, -116, -117, -119, -120,\n\t-120, -121, -122, -123, -124, -125, -126, -126,\n\t-127, -128, -128, -128, -128, -128, -128, -128,\n\t-128, -128, -128, -128, -128, -128, -128, -128,\n\t-128, -128, -128, -128, -128, -128, -128, -128,\n\t-128, -128, -128, -128, -128, -128, -128, -128,\n\t-127, -127, -126, -125, -125, -124, -123, -122,\n\t-121, -120, -119, -118, -117, -116, -115, -114,\n\t-113, -111, -110, -109, -107, -106, -105, -103,\n\t-102, -100, -99, -97, -96, -94, -92, -91,\n\t-89, -87, -85, -84, -82, -80, -78, -76,\n\t-74, -73, -71, -69, -67, -65, -63, -61,\n\t-58, -56, -54, -52, -50, -48, -46, -44,\n\t-41, -39, -37, -35, -32, -30, -28, -26,\n\t-23, -21, -19, -16, -14, -12, -10,  -7,\n\t-5,  -3,   0,   1,   3,   6,   8,  10,\n\t13,  15,  17,  19,  22,  24,  26,  29,\n\t31,  33,  35,  38,  40,  42,  44,  46,\n\t48,  51,  53,  55,  57,  59,  61,  63,\n\t65,  67,  69,  71,  73,  75,  77,  79,\n\t81,  82,  84,  86,  88,  89,  91,  93,\n\t94,  96,  98,  99, 101, 102, 104, 105,\n\t106, 108, 109, 110, 112, 113, 114, 115,\n\t116, 117, 119, 120, 120, 121, 122, 123,\n\t124, 125, 126, 126, 127, 128, 128, 129,\n\t129, 130, 130, 131, 131, 131, 131, 132,\n\t132, 132, 132, 132, 132, 132, 132, 132,\n\t132, 132, 132, 131, 131, 131, 130, 130,\n\t130, 129, 129, 128, 127, 127, 126, 125,\n\t125, 124, 123, 122, 121, 120, 119, 118,\n\t117, 116, 115, 114, 113, 111, 110, 109,\n\t107, 106, 105, 103, 102, 100,  99,  97,\n\t96, 94, 92, 91, 89, 87, 85, 84, 82\n};\n\nstatic const s16 hsv_green_x[] = {\n\t-124, -124, -125, -125, -125, -125, -125, -125,\n\t-125, -126, -126, -125, -125, -125, -125, -125,\n\t-125, -124, -124, -124, -123, -123, -122, -122,\n\t-121, -121, -120, -120, -119, -118, -117, -117,\n\t-116, -115, -114, -113, -112, -111, -110, -109,\n\t-108, -107, -105, -104, -103, -102, -100, -99,\n\t-98, -96, -95, -93, -92, -91, -89, -87,\n\t-86, -84, -83, -81, -79, -77, -76, -74,\n\t-72, -70, -69, -67, -65, -63, -61, -59,\n\t-57, -55, -53, -51, -49, -47, -45, -43,\n\t-41, -39, -37, -35, -33, -30, -28, -26,\n\t-24, -22, -20, -18, -15, -13, -11,  -9,\n\t-7,  -4,  -2,   0,   1,   3,   6,   8,\n\t10,  12,  14,  17,  19,  21,  23,  25,\n\t27,  29,  32,  34,  36,  38,  40,  42,\n\t44,  46,  48,  50,  52,  54,  56,  58,\n\t60,  62,  64,  66,  68,  70,  71,  73,\n\t75,  77,  78,  80,  82,  83,  85,  87,\n\t88,  90,  91,  93,  94,  96,  97,  98,\n\t100, 101, 102, 104, 105, 106, 107, 108,\n\t109, 111, 112, 113, 113, 114, 115, 116,\n\t117, 118, 118, 119, 120, 120, 121, 122,\n\t122, 123, 123, 124, 124, 124, 125, 125,\n\t125, 125, 125, 125, 125, 126, 126, 125,\n\t125, 125, 125, 125, 125, 124, 124, 124,\n\t123, 123, 122, 122, 121, 121, 120, 120,\n\t119, 118, 117, 117, 116, 115, 114, 113,\n\t112, 111, 110, 109, 108, 107, 105, 104,\n\t103, 102, 100,  99,  98,  96,  95,  93,\n\t92,  91,  89,  87,  86,  84,  83,  81,\n\t79,  77,  76,  74,  72,  70,  69,  67,\n\t65,  63,  61,  59,  57,  55,  53,  51,\n\t49,  47,  45,  43,  41,  39,  37,  35,\n\t33,  30,  28,  26,  24,  22,  20,  18,\n\t15,  13,  11,   9,   7,   4,   2,   0,\n\t-1,  -3,  -6,  -8, -10, -12, -14, -17,\n\t-19, -21, -23, -25, -27, -29, -32, -34,\n\t-36, -38, -40, -42, -44, -46, -48, -50,\n\t-52, -54, -56, -58, -60, -62, -64, -66,\n\t-68, -70, -71, -73, -75, -77, -78, -80,\n\t-82, -83, -85, -87, -88, -90, -91, -93,\n\t-94, -96, -97, -98, -100, -101, -102, -104,\n\t-105, -106, -107, -108, -109, -111, -112, -113,\n\t-113, -114, -115, -116, -117, -118, -118, -119,\n\t-120, -120, -121, -122, -122, -123, -123, -124, -124\n};\n\nstatic const s16 hsv_green_y[] = {\n\t-100, -99, -98, -97, -95, -94, -93, -91,\n\t-90, -89, -87, -86, -84, -83, -81, -80,\n\t-78, -76, -75, -73, -71, -70, -68, -66,\n\t-64, -63, -61, -59, -57, -55, -53, -51,\n\t-49, -48, -46, -44, -42, -40, -38, -36,\n\t-34, -32, -30, -27, -25, -23, -21, -19,\n\t-17, -15, -13, -11,  -9,  -7,  -4,  -2,\n\t0,   1,   3,   5,   7,   9,  11,  14,\n\t16,  18,  20,  22,  24,  26,  28,  30,\n\t32,  34,  36,  38,  40,  42,  44,  46,\n\t48,  50,  52,  54,  56,  58,  59,  61,\n\t63,  65,  67,  68,  70,  72,  74,  75,\n\t77,  78,  80,  82,  83,  85,  86,  88,\n\t89,  90,  92,  93,  95,  96,  97,  98,\n\t100, 101, 102, 103, 104, 105, 106, 107,\n\t108, 109, 110, 111, 112, 112, 113, 114,\n\t115, 115, 116, 116, 117, 117, 118, 118,\n\t119, 119, 119, 120, 120, 120, 120, 120,\n\t121, 121, 121, 121, 121, 121, 120, 120,\n\t120, 120, 120, 119, 119, 119, 118, 118,\n\t117, 117, 116, 116, 115, 114, 114, 113,\n\t112, 111, 111, 110, 109, 108, 107, 106,\n\t105, 104, 103, 102, 100,  99,  98,  97,\n\t95,  94,  93,  91,  90,  89,  87,  86,\n\t84,  83,  81,  80,  78,  76,  75,  73,\n\t71,  70,  68,  66,  64,  63,  61,  59,\n\t57,  55,  53,  51,  49,  48,  46,  44,\n\t42,  40,  38,  36,  34,  32,  30,  27,\n\t25,  23,  21,  19,  17,  15,  13,  11,\n\t9,   7,   4,   2,   0,  -1,  -3,  -5,\n\t-7,  -9, -11, -14, -16, -18, -20, -22,\n\t-24, -26, -28, -30, -32, -34, -36, -38,\n\t-40, -42, -44, -46, -48, -50, -52, -54,\n\t-56, -58, -59, -61, -63, -65, -67, -68,\n\t-70, -72, -74, -75, -77, -78, -80, -82,\n\t-83, -85, -86, -88, -89, -90, -92, -93,\n\t-95, -96, -97, -98, -100, -101, -102, -103,\n\t-104, -105, -106, -107, -108, -109, -110, -111,\n\t-112, -112, -113, -114, -115, -115, -116, -116,\n\t-117, -117, -118, -118, -119, -119, -119, -120,\n\t-120, -120, -120, -120, -121, -121, -121, -121,\n\t-121, -121, -120, -120, -120, -120, -120, -119,\n\t-119, -119, -118, -118, -117, -117, -116, -116,\n\t-115, -114, -114, -113, -112, -111, -111, -110,\n\t-109, -108, -107, -106, -105, -104, -103, -102, -100\n};\n\nstatic const s16 hsv_blue_x[] = {\n\t112, 113, 114, 114, 115, 116, 117, 117,\n\t118, 118, 119, 119, 120, 120, 120, 121,\n\t121, 121, 122, 122, 122, 122, 122, 122,\n\t122, 122, 122, 122, 122, 122, 121, 121,\n\t121, 120, 120, 120, 119, 119, 118, 118,\n\t117, 116, 116, 115, 114, 113, 113, 112,\n\t111, 110, 109, 108, 107, 106, 105, 104,\n\t103, 102, 100,  99,  98,  97,  95,  94,\n\t93,  91,  90,  88,  87,  85,  84,  82,\n\t80,  79,  77,  76,  74,  72,  70,  69,\n\t67,  65,  63,  61,  60,  58,  56,  54,\n\t52,  50,  48,  46,  44,  42,  40,  38,\n\t36,  34,  32,  30,  28,  26,  24,  22,\n\t19,  17,  15,  13,  11,   9,   7,   5,\n\t2,   0,  -1,  -3,  -5,  -7,  -9, -12,\n\t-14, -16, -18, -20, -22, -24, -26, -28,\n\t-31, -33, -35, -37, -39, -41, -43, -45,\n\t-47, -49, -51, -53, -54, -56, -58, -60,\n\t-62, -64, -66, -67, -69, -71, -73, -74,\n\t-76, -78, -79, -81, -83, -84, -86, -87,\n\t-89, -90, -92, -93, -94, -96, -97, -98,\n\t-99, -101, -102, -103, -104, -105, -106, -107,\n\t-108, -109, -110, -111, -112, -113, -114, -114,\n\t-115, -116, -117, -117, -118, -118, -119, -119,\n\t-120, -120, -120, -121, -121, -121, -122, -122,\n\t-122, -122, -122, -122, -122, -122, -122, -122,\n\t-122, -122, -121, -121, -121, -120, -120, -120,\n\t-119, -119, -118, -118, -117, -116, -116, -115,\n\t-114, -113, -113, -112, -111, -110, -109, -108,\n\t-107, -106, -105, -104, -103, -102, -100, -99,\n\t-98, -97, -95, -94, -93, -91, -90, -88,\n\t-87, -85, -84, -82, -80, -79, -77, -76,\n\t-74, -72, -70, -69, -67, -65, -63, -61,\n\t-60, -58, -56, -54, -52, -50, -48, -46,\n\t-44, -42, -40, -38, -36, -34, -32, -30,\n\t-28, -26, -24, -22, -19, -17, -15, -13,\n\t-11,  -9,  -7,  -5,  -2,   0,   1,   3,\n\t5,   7,   9,  12,  14,  16,  18,  20,\n\t22,  24,  26,  28,  31,  33,  35,  37,\n\t39,  41,  43,  45,  47,  49,  51,  53,\n\t54,  56,  58,  60,  62,  64,  66,  67,\n\t69,  71,  73,  74,  76,  78,  79,  81,\n\t83,  84,  86,  87,  89,  90,  92,  93,\n\t94,  96,  97,  98,  99, 101, 102, 103,\n\t104, 105, 106, 107, 108, 109, 110, 111, 112\n};\n\nstatic const s16 hsv_blue_y[] = {\n\t-11, -13, -15, -17, -19, -21, -23, -25,\n\t-27, -29, -31, -33, -35, -37, -39, -41,\n\t-43, -45, -46, -48, -50, -52, -54, -55,\n\t-57, -59, -61, -62, -64, -66, -67, -69,\n\t-71, -72, -74, -75, -77, -78, -80, -81,\n\t-83, -84, -86, -87, -88, -90, -91, -92,\n\t-93, -95, -96, -97, -98, -99, -100, -101,\n\t-102, -103, -104, -105, -106, -106, -107, -108,\n\t-109, -109, -110, -111, -111, -112, -112, -113,\n\t-113, -114, -114, -114, -115, -115, -115, -115,\n\t-116, -116, -116, -116, -116, -116, -116, -116,\n\t-116, -115, -115, -115, -115, -114, -114, -114,\n\t-113, -113, -112, -112, -111, -111, -110, -110,\n\t-109, -108, -108, -107, -106, -105, -104, -103,\n\t-102, -101, -100, -99, -98, -97, -96, -95,\n\t-94, -93, -91, -90, -89, -88, -86, -85,\n\t-84, -82, -81, -79, -78, -76, -75, -73,\n\t-71, -70, -68, -67, -65, -63, -62, -60,\n\t-58, -56, -55, -53, -51, -49, -47, -45,\n\t-44, -42, -40, -38, -36, -34, -32, -30,\n\t-28, -26, -24, -22, -20, -18, -16, -14,\n\t-12, -10,  -8,  -6,  -4,  -2,   0,   1,\n\t3,   5,   7,   9,  11,  13,  15,  17,\n\t19,  21,  23,  25,  27,  29,  31,  33,\n\t35,  37,  39,  41,  43,  45,  46,  48,\n\t50,  52,  54,  55,  57,  59,  61,  62,\n\t64,  66,  67,  69,  71,  72,  74,  75,\n\t77,  78,  80,  81,  83,  84,  86,  87,\n\t88,  90,  91,  92,  93,  95,  96,  97,\n\t98,  99, 100, 101, 102, 103, 104, 105,\n\t106, 106, 107, 108, 109, 109, 110, 111,\n\t111, 112, 112, 113, 113, 114, 114, 114,\n\t115, 115, 115, 115, 116, 116, 116, 116,\n\t116, 116, 116, 116, 116, 115, 115, 115,\n\t115, 114, 114, 114, 113, 113, 112, 112,\n\t111, 111, 110, 110, 109, 108, 108, 107,\n\t106, 105, 104, 103, 102, 101, 100,  99,\n\t98,  97,  96,  95,  94,  93,  91,  90,\n\t89,  88,  86,  85,  84,  82,  81,  79,\n\t78,  76,  75,  73,  71,  70,  68,  67,\n\t65,  63,  62,  60,  58,  56,  55,  53,\n\t51,  49,  47,  45,  44,  42,  40,  38,\n\t36,  34,  32,  30,  28,  26,  24,  22,\n\t20,  18,  16,  14,  12,  10,   8,   6,\n\t4,   2,   0,  -1,  -3,  -5,  -7,  -9, -11\n};\n\nstatic const u16 bridge_init[][2] = {\n\t{0x1000, 0x78}, {0x1001, 0x40}, {0x1002, 0x1c},\n\t{0x1020, 0x80}, {0x1061, 0x01}, {0x1067, 0x40},\n\t{0x1068, 0x30}, {0x1069, 0x20},\t{0x106a, 0x10},\n\t{0x106b, 0x08},\t{0x1188, 0x87},\t{0x11a1, 0x00},\n\t{0x11a2, 0x00},\t{0x11a3, 0x6a},\t{0x11a4, 0x50},\n\t{0x11ab, 0x00},\t{0x11ac, 0x00},\t{0x11ad, 0x50},\n\t{0x11ae, 0x3c},\t{0x118a, 0x04},\t{0x0395, 0x04},\n\t{0x11b8, 0x3a},\t{0x118b, 0x0e},\t{0x10f7, 0x05},\n\t{0x10f8, 0x14},\t{0x10fa, 0xff},\t{0x10f9, 0x00},\n\t{0x11ba, 0x0a},\t{0x11a5, 0x2d},\t{0x11a6, 0x2d},\n\t{0x11a7, 0x3a},\t{0x11a8, 0x05},\t{0x11a9, 0x04},\n\t{0x11aa, 0x3f},\t{0x11af, 0x28},\t{0x11b0, 0xd8},\n\t{0x11b1, 0x14},\t{0x11b2, 0xec},\t{0x11b3, 0x32},\n\t{0x11b4, 0xdd},\t{0x11b5, 0x32},\t{0x11b6, 0xdd},\n\t{0x10e0, 0x2c},\t{0x11bc, 0x40},\t{0x11bd, 0x01},\n\t{0x11be, 0xf0},\t{0x11bf, 0x00},\t{0x118c, 0x1f},\n\t{0x118d, 0x1f},\t{0x118e, 0x1f},\t{0x118f, 0x1f},\n\t{0x1180, 0x01},\t{0x1181, 0x00},\t{0x1182, 0x01},\n\t{0x1183, 0x00},\t{0x1184, 0x50},\t{0x1185, 0x80},\n\t{0x1007, 0x00}\n};\n\n \nstatic const u8 ov_gain[] = {\n\t0x00  , 0x04  , 0x08  , 0x0c  ,\n\t0x10  , 0x12  , 0x14  , 0x16  ,\n\t0x18  , 0x1a  , 0x1c  , 0x1e  ,\n\t0x30  , 0x31  , 0x32  , 0x33  ,\n\t0x34  , 0x35  , 0x36  , 0x37  ,\n\t0x38  , 0x39  , 0x3a  , 0x3b  ,\n\t0x3c  , 0x3d  , 0x3e  , 0x3f  ,\n\t0x70  \n};\n\n \nstatic const u16 micron1_gain[] = {\n\t \n\t0x0020, 0x0028, 0x0030, 0x0038,\n\t \n\t0x00a0, 0x00a4, 0x00a8, 0x00ac,\n\t \n\t0x00b0, 0x00b4, 0x00b8, 0x00bc,\n\t \n\t0x00c0, 0x00c4, 0x00c8, 0x00cc,\n\t \n\t0x00d0, 0x00d4, 0x00d8, 0x00dc,\n\t \n\t0x00e0, 0x00e4, 0x00e8, 0x00ec,\n\t \n\t0x00f0, 0x00f4, 0x00f8, 0x00fc,\n\t \n\t0x01c0\n};\n\n \n \nstatic const u16 micron2_gain[] = {\n\t \n\t0x0008, 0x000a, 0x000c, 0x000e,\n\t \n\t0x0010, 0x0012, 0x0014, 0x0016,\n\t \n\t0x0018, 0x001a, 0x001c, 0x001e,\n\t \n\t0x0020, 0x0051, 0x0052, 0x0053,\n\t \n\t0x0054, 0x0055, 0x0056, 0x0057,\n\t \n\t0x0058, 0x0059, 0x005a, 0x005b,\n\t \n\t0x005c, 0x005d, 0x005e, 0x005f,\n\t \n\t0x0060\n};\n\n \nstatic const u8 hv7131r_gain[] = {\n\t0x08  , 0x0c  , 0x10  , 0x14  ,\n\t0x18  , 0x1c  , 0x20  , 0x24  ,\n\t0x28  , 0x2c  , 0x30  , 0x34  ,\n\t0x38  , 0x3c  , 0x40  , 0x44  ,\n\t0x48  , 0x4c  , 0x50  , 0x54  ,\n\t0x58  , 0x5c  , 0x60  , 0x64  ,\n\t0x68  , 0x6c  , 0x70  , 0x74  ,\n\t0x78  \n};\n\nstatic const struct i2c_reg_u8 soi968_init[] = {\n\t{0x0c, 0x00}, {0x0f, 0x1f},\n\t{0x11, 0x80}, {0x38, 0x52}, {0x1e, 0x00},\n\t{0x33, 0x08}, {0x35, 0x8c}, {0x36, 0x0c},\n\t{0x37, 0x04}, {0x45, 0x04}, {0x47, 0xff},\n\t{0x3e, 0x00}, {0x3f, 0x00}, {0x3b, 0x20},\n\t{0x3a, 0x96}, {0x3d, 0x0a}, {0x14, 0x8e},\n\t{0x13, 0x8b}, {0x12, 0x40}, {0x17, 0x13},\n\t{0x18, 0x63}, {0x19, 0x01}, {0x1a, 0x79},\n\t{0x32, 0x24}, {0x03, 0x00}, {0x11, 0x40},\n\t{0x2a, 0x10}, {0x2b, 0xe0}, {0x10, 0x32},\n\t{0x00, 0x00}, {0x01, 0x80}, {0x02, 0x80},\n};\n\nstatic const struct i2c_reg_u8 ov7660_init[] = {\n\t{0x0e, 0x80}, {0x0d, 0x08}, {0x0f, 0xc3},\n\t{0x04, 0xc3}, {0x10, 0x40}, {0x11, 0x40},\n\t{0x12, 0x05}, {0x13, 0xba}, {0x14, 0x2a},\n\t \n\t{0x17, 0x10}, {0x18, 0x61},\n\t{0x37, 0x0f}, {0x38, 0x02}, {0x39, 0x43},\n\t{0x3a, 0x00}, {0x69, 0x90}, {0x2d, 0x00},\n\t{0x2e, 0x00}, {0x01, 0x78}, {0x02, 0x50},\n};\n\nstatic const struct i2c_reg_u8 ov7670_init[] = {\n\t{0x11, 0x80}, {0x3a, 0x04}, {0x12, 0x01},\n\t{0x32, 0xb6}, {0x03, 0x0a}, {0x0c, 0x00}, {0x3e, 0x00},\n\t{0x70, 0x3a}, {0x71, 0x35}, {0x72, 0x11}, {0x73, 0xf0},\n\t{0xa2, 0x02}, {0x13, 0xe0}, {0x00, 0x00}, {0x10, 0x00},\n\t{0x0d, 0x40}, {0x14, 0x28}, {0xa5, 0x05}, {0xab, 0x07},\n\t{0x24, 0x95}, {0x25, 0x33}, {0x26, 0xe3}, {0x9f, 0x75},\n\t{0xa0, 0x65}, {0xa1, 0x0b}, {0xa6, 0xd8}, {0xa7, 0xd8},\n\t{0xa8, 0xf0}, {0xa9, 0x90}, {0xaa, 0x94}, {0x13, 0xe5},\n\t{0x0e, 0x61}, {0x0f, 0x4b}, {0x16, 0x02}, {0x1e, 0x27},\n\t{0x21, 0x02}, {0x22, 0x91}, {0x29, 0x07}, {0x33, 0x0b},\n\t{0x35, 0x0b}, {0x37, 0x1d}, {0x38, 0x71}, {0x39, 0x2a},\n\t{0x3c, 0x78}, {0x4d, 0x40}, {0x4e, 0x20}, {0x69, 0x00},\n\t{0x74, 0x19}, {0x8d, 0x4f}, {0x8e, 0x00}, {0x8f, 0x00},\n\t{0x90, 0x00}, {0x91, 0x00}, {0x96, 0x00}, {0x9a, 0x80},\n\t{0xb0, 0x84}, {0xb1, 0x0c}, {0xb2, 0x0e}, {0xb3, 0x82},\n\t{0xb8, 0x0a}, {0x43, 0x0a}, {0x44, 0xf0}, {0x45, 0x20},\n\t{0x46, 0x7d}, {0x47, 0x29}, {0x48, 0x4a}, {0x59, 0x8c},\n\t{0x5a, 0xa5}, {0x5b, 0xde}, {0x5c, 0x96}, {0x5d, 0x66},\n\t{0x5e, 0x10}, {0x6c, 0x0a}, {0x6d, 0x55}, {0x6e, 0x11},\n\t{0x6f, 0x9e}, {0x6a, 0x40}, {0x01, 0x40}, {0x02, 0x40},\n\t{0x13, 0xe7}, {0x4f, 0x6e}, {0x50, 0x70}, {0x51, 0x02},\n\t{0x52, 0x1d}, {0x53, 0x56}, {0x54, 0x73}, {0x55, 0x0a},\n\t{0x56, 0x55}, {0x57, 0x80}, {0x58, 0x9e}, {0x41, 0x08},\n\t{0x3f, 0x02}, {0x75, 0x03}, {0x76, 0x63}, {0x4c, 0x04},\n\t{0x77, 0x06}, {0x3d, 0x02}, {0x4b, 0x09}, {0xc9, 0x30},\n\t{0x41, 0x08}, {0x56, 0x48}, {0x34, 0x11}, {0xa4, 0x88},\n\t{0x96, 0x00}, {0x97, 0x30}, {0x98, 0x20}, {0x99, 0x30},\n\t{0x9a, 0x84}, {0x9b, 0x29}, {0x9c, 0x03}, {0x9d, 0x99},\n\t{0x9e, 0x7f}, {0x78, 0x04}, {0x79, 0x01}, {0xc8, 0xf0},\n\t{0x79, 0x0f}, {0xc8, 0x00}, {0x79, 0x10}, {0xc8, 0x7e},\n\t{0x79, 0x0a}, {0xc8, 0x80}, {0x79, 0x0b}, {0xc8, 0x01},\n\t{0x79, 0x0c}, {0xc8, 0x0f}, {0x79, 0x0d}, {0xc8, 0x20},\n\t{0x79, 0x09}, {0xc8, 0x80}, {0x79, 0x02}, {0xc8, 0xc0},\n\t{0x79, 0x03}, {0xc8, 0x40}, {0x79, 0x05}, {0xc8, 0x30},\n\t{0x79, 0x26}, {0x62, 0x20}, {0x63, 0x00}, {0x64, 0x06},\n\t{0x65, 0x00}, {0x66, 0x05}, {0x94, 0x05}, {0x95, 0x0a},\n\t{0x17, 0x13}, {0x18, 0x01}, {0x19, 0x02}, {0x1a, 0x7a},\n\t{0x46, 0x59}, {0x47, 0x30}, {0x58, 0x9a}, {0x59, 0x84},\n\t{0x5a, 0x91}, {0x5b, 0x57}, {0x5c, 0x75}, {0x5d, 0x6d},\n\t{0x5e, 0x13}, {0x64, 0x07}, {0x94, 0x07}, {0x95, 0x0d},\n\t{0xa6, 0xdf}, {0xa7, 0xdf}, {0x48, 0x4d}, {0x51, 0x00},\n\t{0x6b, 0x0a}, {0x11, 0x80}, {0x2a, 0x00}, {0x2b, 0x00},\n\t{0x92, 0x00}, {0x93, 0x00}, {0x55, 0x0a}, {0x56, 0x60},\n\t{0x4f, 0x6e}, {0x50, 0x70}, {0x51, 0x00}, {0x52, 0x1d},\n\t{0x53, 0x56}, {0x54, 0x73}, {0x58, 0x9a}, {0x4f, 0x6e},\n\t{0x50, 0x70}, {0x51, 0x00}, {0x52, 0x1d}, {0x53, 0x56},\n\t{0x54, 0x73}, {0x58, 0x9a}, {0x3f, 0x01}, {0x7b, 0x03},\n\t{0x7c, 0x09}, {0x7d, 0x16}, {0x7e, 0x38}, {0x7f, 0x47},\n\t{0x80, 0x53}, {0x81, 0x5e}, {0x82, 0x6a}, {0x83, 0x74},\n\t{0x84, 0x80}, {0x85, 0x8c}, {0x86, 0x9b}, {0x87, 0xb2},\n\t{0x88, 0xcc}, {0x89, 0xe5}, {0x7a, 0x24}, {0x3b, 0x00},\n\t{0x9f, 0x76}, {0xa0, 0x65}, {0x13, 0xe2}, {0x6b, 0x0a},\n\t{0x11, 0x80}, {0x2a, 0x00}, {0x2b, 0x00}, {0x92, 0x00},\n\t{0x93, 0x00},\n};\n\nstatic const struct i2c_reg_u8 ov9650_init[] = {\n\t{0x00, 0x00}, {0x01, 0x78},\n\t{0x02, 0x78}, {0x03, 0x36}, {0x04, 0x03},\n\t{0x05, 0x00}, {0x06, 0x00}, {0x08, 0x00},\n\t{0x09, 0x01}, {0x0c, 0x00}, {0x0d, 0x00},\n\t{0x0e, 0xa0}, {0x0f, 0x52}, {0x10, 0x7c},\n\t{0x11, 0x80}, {0x12, 0x45}, {0x13, 0xc2},\n\t{0x14, 0x2e}, {0x15, 0x00}, {0x16, 0x07},\n\t{0x17, 0x24}, {0x18, 0xc5}, {0x19, 0x00},\n\t{0x1a, 0x3c}, {0x1b, 0x00}, {0x1e, 0x04},\n\t{0x1f, 0x00}, {0x24, 0x78}, {0x25, 0x68},\n\t{0x26, 0xd4}, {0x27, 0x80}, {0x28, 0x80},\n\t{0x29, 0x30}, {0x2a, 0x00}, {0x2b, 0x00},\n\t{0x2c, 0x80}, {0x2d, 0x00}, {0x2e, 0x00},\n\t{0x2f, 0x00}, {0x30, 0x08}, {0x31, 0x30},\n\t{0x32, 0x84}, {0x33, 0xe2}, {0x34, 0xbf},\n\t{0x35, 0x81}, {0x36, 0xf9}, {0x37, 0x00},\n\t{0x38, 0x93}, {0x39, 0x50}, {0x3a, 0x01},\n\t{0x3b, 0x01}, {0x3c, 0x73}, {0x3d, 0x19},\n\t{0x3e, 0x0b}, {0x3f, 0x80}, {0x40, 0xc1},\n\t{0x41, 0x00}, {0x42, 0x08}, {0x67, 0x80},\n\t{0x68, 0x80}, {0x69, 0x40}, {0x6a, 0x00},\n\t{0x6b, 0x0a}, {0x8b, 0x06}, {0x8c, 0x20},\n\t{0x8d, 0x00}, {0x8e, 0x00}, {0x8f, 0xdf},\n\t{0x92, 0x00}, {0x93, 0x00}, {0x94, 0x88},\n\t{0x95, 0x88}, {0x96, 0x04}, {0xa1, 0x00},\n\t{0xa5, 0x80}, {0xa8, 0x80}, {0xa9, 0xb8},\n\t{0xaa, 0x92}, {0xab, 0x0a},\n};\n\nstatic const struct i2c_reg_u8 ov9655_init[] = {\n\t{0x0e, 0x61}, {0x11, 0x80}, {0x13, 0xba},\n\t{0x14, 0x2e}, {0x16, 0x24}, {0x1e, 0x04}, {0x27, 0x08},\n\t{0x28, 0x08}, {0x29, 0x15}, {0x2c, 0x08}, {0x34, 0x3d},\n\t{0x35, 0x00}, {0x38, 0x12}, {0x0f, 0x42}, {0x39, 0x57},\n\t{0x3a, 0x00}, {0x3b, 0xcc}, {0x3c, 0x0c}, {0x3d, 0x19},\n\t{0x3e, 0x0c}, {0x3f, 0x01}, {0x41, 0x40}, {0x42, 0x80},\n\t{0x45, 0x46}, {0x46, 0x62}, {0x47, 0x2a}, {0x48, 0x3c},\n\t{0x4a, 0xf0}, {0x4b, 0xdc}, {0x4c, 0xdc}, {0x4d, 0xdc},\n\t{0x4e, 0xdc}, {0x6c, 0x04}, {0x6f, 0x9e}, {0x70, 0x05},\n\t{0x71, 0x78}, {0x77, 0x02}, {0x8a, 0x23}, {0x90, 0x7e},\n\t{0x91, 0x7c}, {0x9f, 0x6e}, {0xa0, 0x6e}, {0xa5, 0x68},\n\t{0xa6, 0x60}, {0xa8, 0xc1}, {0xa9, 0xfa}, {0xaa, 0x92},\n\t{0xab, 0x04}, {0xac, 0x80}, {0xad, 0x80}, {0xae, 0x80},\n\t{0xaf, 0x80}, {0xb2, 0xf2}, {0xb3, 0x20}, {0xb5, 0x00},\n\t{0xb6, 0xaf}, {0xbb, 0xae}, {0xbc, 0x44}, {0xbd, 0x44},\n\t{0xbe, 0x3b}, {0xbf, 0x3a}, {0xc1, 0xc8}, {0xc2, 0x01},\n\t{0xc4, 0x00}, {0xc6, 0x85}, {0xc7, 0x81}, {0xc9, 0xe0},\n\t{0xca, 0xe8}, {0xcc, 0xd8}, {0xcd, 0x93}, {0x2d, 0x00},\n\t{0x2e, 0x00}, {0x01, 0x80}, {0x02, 0x80}, {0x12, 0x61},\n\t{0x36, 0xfa}, {0x8c, 0x8d}, {0xc0, 0xaa}, {0x69, 0x0a},\n\t{0x03, 0x09}, {0x17, 0x16}, {0x18, 0x6e}, {0x19, 0x01},\n\t{0x1a, 0x3e}, {0x32, 0x09}, {0x2a, 0x10}, {0x2b, 0x0a},\n\t{0x92, 0x00}, {0x93, 0x00}, {0xa1, 0x00}, {0x10, 0x7c},\n\t{0x04, 0x03}, {0x00, 0x13},\n};\n\nstatic const struct i2c_reg_u16 mt9v112_init[] = {\n\t{0xf0, 0x0000}, {0x0d, 0x0021}, {0x0d, 0x0020},\n\t{0x34, 0xc019}, {0x0a, 0x0011}, {0x0b, 0x000b},\n\t{0x20, 0x0703}, {0x35, 0x2022}, {0xf0, 0x0001},\n\t{0x05, 0x0000}, {0x06, 0x340c}, {0x3b, 0x042a},\n\t{0x3c, 0x0400}, {0xf0, 0x0002}, {0x2e, 0x0c58},\n\t{0x5b, 0x0001}, {0xc8, 0x9f0b}, {0xf0, 0x0001},\n\t{0x9b, 0x5300}, {0xf0, 0x0000}, {0x2b, 0x0020},\n\t{0x2c, 0x002a}, {0x2d, 0x0032}, {0x2e, 0x0020},\n\t{0x09, 0x01dc}, {0x01, 0x000c}, {0x02, 0x0020},\n\t{0x03, 0x01e0}, {0x04, 0x0280}, {0x06, 0x000c},\n\t{0x05, 0x0098}, {0x20, 0x0703}, {0x09, 0x01f2},\n\t{0x2b, 0x00a0}, {0x2c, 0x00a0}, {0x2d, 0x00a0},\n\t{0x2e, 0x00a0}, {0x01, 0x000c}, {0x02, 0x0020},\n\t{0x03, 0x01e0}, {0x04, 0x0280}, {0x06, 0x000c},\n\t{0x05, 0x0098}, {0x09, 0x01c1}, {0x2b, 0x00ae},\n\t{0x2c, 0x00ae}, {0x2d, 0x00ae}, {0x2e, 0x00ae},\n};\n\nstatic const struct i2c_reg_u16 mt9v111_init[] = {\n\t{0x01, 0x0004}, {0x0d, 0x0001}, {0x0d, 0x0000},\n\t{0x01, 0x0001}, {0x05, 0x0004}, {0x2d, 0xe0a0},\n\t{0x2e, 0x0c64},\t{0x2f, 0x0064}, {0x06, 0x600e},\n\t{0x08, 0x0480}, {0x01, 0x0004}, {0x02, 0x0016},\n\t{0x03, 0x01e7}, {0x04, 0x0287}, {0x05, 0x0004},\n\t{0x06, 0x002d},\t{0x07, 0x3002}, {0x08, 0x0008},\n\t{0x0e, 0x0008}, {0x20, 0x0000}\n};\n\nstatic const struct i2c_reg_u16 mt9v011_init[] = {\n\t{0x07, 0x0002},\t{0x0d, 0x0001},\t{0x0d, 0x0000},\n\t{0x01, 0x0008},\t{0x02, 0x0016},\t{0x03, 0x01e1},\n\t{0x04, 0x0281},\t{0x05, 0x0083},\t{0x06, 0x0006},\n\t{0x0d, 0x0002}, {0x0a, 0x0000},\t{0x0b, 0x0000},\n\t{0x0c, 0x0000},\t{0x0d, 0x0000},\t{0x0e, 0x0000},\n\t{0x0f, 0x0000},\t{0x10, 0x0000},\t{0x11, 0x0000},\n\t{0x12, 0x0000},\t{0x13, 0x0000},\t{0x14, 0x0000},\n\t{0x15, 0x0000},\t{0x16, 0x0000},\t{0x17, 0x0000},\n\t{0x18, 0x0000},\t{0x19, 0x0000},\t{0x1a, 0x0000},\n\t{0x1b, 0x0000},\t{0x1c, 0x0000},\t{0x1d, 0x0000},\n\t{0x32, 0x0000},\t{0x20, 0x1101},\t{0x21, 0x0000},\n\t{0x22, 0x0000},\t{0x23, 0x0000},\t{0x24, 0x0000},\n\t{0x25, 0x0000},\t{0x26, 0x0000},\t{0x27, 0x0024},\n\t{0x2f, 0xf7b0},\t{0x30, 0x0005},\t{0x31, 0x0000},\n\t{0x32, 0x0000},\t{0x33, 0x0000},\t{0x34, 0x0100},\n\t{0x3d, 0x068f},\t{0x40, 0x01e0},\t{0x41, 0x00d1},\n\t{0x44, 0x0082},\t{0x5a, 0x0000},\t{0x5b, 0x0000},\n\t{0x5c, 0x0000},\t{0x5d, 0x0000},\t{0x5e, 0x0000},\n\t{0x5f, 0xa31d},\t{0x62, 0x0611},\t{0x0a, 0x0000},\n\t{0x06, 0x0029},\t{0x05, 0x0009},\t{0x20, 0x1101},\n\t{0x20, 0x1101},\t{0x09, 0x0064},\t{0x07, 0x0003},\n\t{0x2b, 0x0033},\t{0x2c, 0x00a0},\t{0x2d, 0x00a0},\n\t{0x2e, 0x0033},\t{0x07, 0x0002},\t{0x06, 0x0000},\n\t{0x06, 0x0029},\t{0x05, 0x0009},\n};\n\nstatic const struct i2c_reg_u16 mt9m001_init[] = {\n\t{0x0d, 0x0001},\n\t{0x0d, 0x0000},\n\t{0x04, 0x0500},\t\t \n\t{0x03, 0x0400},\t\t \n\t{0x20, 0x1100},\n\t{0x06, 0x0010},\n\t{0x2b, 0x0024},\n\t{0x2e, 0x0024},\n\t{0x35, 0x0024},\n\t{0x2d, 0x0020},\n\t{0x2c, 0x0020},\n\t{0x09, 0x0ad4},\n\t{0x35, 0x0057},\n};\n\nstatic const struct i2c_reg_u16 mt9m111_init[] = {\n\t{0xf0, 0x0000}, {0x0d, 0x0021}, {0x0d, 0x0008},\n\t{0xf0, 0x0001}, {0x3a, 0x4300}, {0x9b, 0x4300},\n\t{0x06, 0x708e}, {0xf0, 0x0002}, {0x2e, 0x0a1e},\n\t{0xf0, 0x0000},\n};\n\nstatic const struct i2c_reg_u16 mt9m112_init[] = {\n\t{0xf0, 0x0000}, {0x0d, 0x0021}, {0x0d, 0x0008},\n\t{0xf0, 0x0001}, {0x3a, 0x4300}, {0x9b, 0x4300},\n\t{0x06, 0x708e}, {0xf0, 0x0002}, {0x2e, 0x0a1e},\n\t{0xf0, 0x0000},\n};\n\nstatic const struct i2c_reg_u8 hv7131r_init[] = {\n\t{0x02, 0x08}, {0x02, 0x00}, {0x01, 0x08},\n\t{0x02, 0x00}, {0x20, 0x00}, {0x21, 0xd0},\n\t{0x22, 0x00}, {0x23, 0x09}, {0x01, 0x08},\n\t{0x01, 0x08}, {0x01, 0x08}, {0x25, 0x07},\n\t{0x26, 0xc3}, {0x27, 0x50}, {0x30, 0x62},\n\t{0x31, 0x10}, {0x32, 0x06}, {0x33, 0x10},\n\t{0x20, 0x00}, {0x21, 0xd0}, {0x22, 0x00},\n\t{0x23, 0x09}, {0x01, 0x08},\n};\n\nstatic void reg_r(struct gspca_dev *gspca_dev, u16 reg, u16 length)\n{\n\tstruct usb_device *dev = gspca_dev->dev;\n\tint result;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tresult = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t0x00,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\treg,\n\t\t\t0x00,\n\t\t\tgspca_dev->usb_buf,\n\t\t\tlength,\n\t\t\t500);\n\tif (unlikely(result < 0 || result != length)) {\n\t\tpr_err(\"Read register %02x failed %d\\n\", reg, result);\n\t\tgspca_dev->usb_err = result;\n\t\t \n\t\tmemset(gspca_dev->usb_buf, 0, USB_BUF_SZ);\n\t}\n}\n\nstatic void reg_w(struct gspca_dev *gspca_dev, u16 reg,\n\t\t const u8 *buffer, int length)\n{\n\tstruct usb_device *dev = gspca_dev->dev;\n\tint result;\n\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\tmemcpy(gspca_dev->usb_buf, buffer, length);\n\tresult = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t0x08,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\treg,\n\t\t\t0x00,\n\t\t\tgspca_dev->usb_buf,\n\t\t\tlength,\n\t\t\t500);\n\tif (unlikely(result < 0 || result != length)) {\n\t\tpr_err(\"Write register %02x failed %d\\n\", reg, result);\n\t\tgspca_dev->usb_err = result;\n\t}\n}\n\nstatic void reg_w1(struct gspca_dev *gspca_dev, u16 reg, const u8 value)\n{\n\treg_w(gspca_dev, reg, &value, 1);\n}\n\nstatic void i2c_w(struct gspca_dev *gspca_dev, const u8 *buffer)\n{\n\tint i;\n\n\treg_w(gspca_dev, 0x10c0, buffer, 8);\n\tfor (i = 0; i < 5; i++) {\n\t\treg_r(gspca_dev, 0x10c0, 1);\n\t\tif (gspca_dev->usb_err < 0)\n\t\t\treturn;\n\t\tif (gspca_dev->usb_buf[0] & 0x04) {\n\t\t\tif (gspca_dev->usb_buf[0] & 0x08) {\n\t\t\t\tpr_err(\"i2c_w error\\n\");\n\t\t\t\tgspca_dev->usb_err = -EIO;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tmsleep(10);\n\t}\n\tpr_err(\"i2c_w reg %02x no response\\n\", buffer[2]);\n \n}\n\nstatic void i2c_w1(struct gspca_dev *gspca_dev, u8 reg, u8 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 row[8];\n\n\t \n\trow[0] = sd->i2c_intf | (2 << 4);\n\trow[1] = sd->i2c_addr;\n\trow[2] = reg;\n\trow[3] = val;\n\trow[4] = 0x00;\n\trow[5] = 0x00;\n\trow[6] = 0x00;\n\trow[7] = 0x10;\n\n\ti2c_w(gspca_dev, row);\n}\n\nstatic void i2c_w1_buf(struct gspca_dev *gspca_dev,\n\t\t\tconst struct i2c_reg_u8 *buf, int sz)\n{\n\twhile (--sz >= 0) {\n\t\ti2c_w1(gspca_dev, buf->reg, buf->val);\n\t\tbuf++;\n\t}\n}\n\nstatic void i2c_w2(struct gspca_dev *gspca_dev, u8 reg, u16 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 row[8];\n\n\t \n\trow[0] = sd->i2c_intf | (3 << 4);\n\trow[1] = sd->i2c_addr;\n\trow[2] = reg;\n\trow[3] = val >> 8;\n\trow[4] = val;\n\trow[5] = 0x00;\n\trow[6] = 0x00;\n\trow[7] = 0x10;\n\n\ti2c_w(gspca_dev, row);\n}\n\nstatic void i2c_w2_buf(struct gspca_dev *gspca_dev,\n\t\t\tconst struct i2c_reg_u16 *buf, int sz)\n{\n\twhile (--sz >= 0) {\n\t\ti2c_w2(gspca_dev, buf->reg, buf->val);\n\t\tbuf++;\n\t}\n}\n\nstatic void i2c_r1(struct gspca_dev *gspca_dev, u8 reg, u8 *val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 row[8];\n\n\trow[0] = sd->i2c_intf | (1 << 4);\n\trow[1] = sd->i2c_addr;\n\trow[2] = reg;\n\trow[3] = 0;\n\trow[4] = 0;\n\trow[5] = 0;\n\trow[6] = 0;\n\trow[7] = 0x10;\n\ti2c_w(gspca_dev, row);\n\trow[0] = sd->i2c_intf | (1 << 4) | 0x02;\n\trow[2] = 0;\n\ti2c_w(gspca_dev, row);\n\treg_r(gspca_dev, 0x10c2, 5);\n\t*val = gspca_dev->usb_buf[4];\n}\n\nstatic void i2c_r2(struct gspca_dev *gspca_dev, u8 reg, u16 *val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 row[8];\n\n\trow[0] = sd->i2c_intf | (1 << 4);\n\trow[1] = sd->i2c_addr;\n\trow[2] = reg;\n\trow[3] = 0;\n\trow[4] = 0;\n\trow[5] = 0;\n\trow[6] = 0;\n\trow[7] = 0x10;\n\ti2c_w(gspca_dev, row);\n\trow[0] = sd->i2c_intf | (2 << 4) | 0x02;\n\trow[2] = 0;\n\ti2c_w(gspca_dev, row);\n\treg_r(gspca_dev, 0x10c2, 5);\n\t*val = (gspca_dev->usb_buf[3] << 8) | gspca_dev->usb_buf[4];\n}\n\nstatic void ov9650_init_sensor(struct gspca_dev *gspca_dev)\n{\n\tu16 id;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\ti2c_r2(gspca_dev, 0x1c, &id);\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\n\tif (id != 0x7fa2) {\n\t\tpr_err(\"sensor id for ov9650 doesn't match (0x%04x)\\n\", id);\n\t\tgspca_dev->usb_err = -ENODEV;\n\t\treturn;\n\t}\n\n\ti2c_w1(gspca_dev, 0x12, 0x80);\t\t \n\tmsleep(200);\n\ti2c_w1_buf(gspca_dev, ov9650_init, ARRAY_SIZE(ov9650_init));\n\tif (gspca_dev->usb_err < 0)\n\t\tpr_err(\"OV9650 sensor initialization failed\\n\");\n\tsd->hstart = 1;\n\tsd->vstart = 7;\n}\n\nstatic void ov9655_init_sensor(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\ti2c_w1(gspca_dev, 0x12, 0x80);\t\t \n\tmsleep(200);\n\ti2c_w1_buf(gspca_dev, ov9655_init, ARRAY_SIZE(ov9655_init));\n\tif (gspca_dev->usb_err < 0)\n\t\tpr_err(\"OV9655 sensor initialization failed\\n\");\n\n\tsd->hstart = 1;\n\tsd->vstart = 2;\n}\n\nstatic void soi968_init_sensor(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\ti2c_w1(gspca_dev, 0x12, 0x80);\t\t \n\tmsleep(200);\n\ti2c_w1_buf(gspca_dev, soi968_init, ARRAY_SIZE(soi968_init));\n\tif (gspca_dev->usb_err < 0)\n\t\tpr_err(\"SOI968 sensor initialization failed\\n\");\n\n\tsd->hstart = 60;\n\tsd->vstart = 11;\n}\n\nstatic void ov7660_init_sensor(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\ti2c_w1(gspca_dev, 0x12, 0x80);\t\t \n\tmsleep(200);\n\ti2c_w1_buf(gspca_dev, ov7660_init, ARRAY_SIZE(ov7660_init));\n\tif (gspca_dev->usb_err < 0)\n\t\tpr_err(\"OV7660 sensor initialization failed\\n\");\n\tsd->hstart = 3;\n\tsd->vstart = 3;\n}\n\nstatic void ov7670_init_sensor(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\ti2c_w1(gspca_dev, 0x12, 0x80);\t\t \n\tmsleep(200);\n\ti2c_w1_buf(gspca_dev, ov7670_init, ARRAY_SIZE(ov7670_init));\n\tif (gspca_dev->usb_err < 0)\n\t\tpr_err(\"OV7670 sensor initialization failed\\n\");\n\n\tsd->hstart = 0;\n\tsd->vstart = 1;\n}\n\nstatic void mt9v_init_sensor(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu16 value;\n\n\tsd->i2c_addr = 0x5d;\n\ti2c_r2(gspca_dev, 0xff, &value);\n\tif (gspca_dev->usb_err >= 0\n\t && value == 0x8243) {\n\t\ti2c_w2_buf(gspca_dev, mt9v011_init, ARRAY_SIZE(mt9v011_init));\n\t\tif (gspca_dev->usb_err < 0) {\n\t\t\tpr_err(\"MT9V011 sensor initialization failed\\n\");\n\t\t\treturn;\n\t\t}\n\t\tsd->hstart = 2;\n\t\tsd->vstart = 2;\n\t\tsd->sensor = SENSOR_MT9V011;\n\t\tpr_info(\"MT9V011 sensor detected\\n\");\n\t\treturn;\n\t}\n\n\tgspca_dev->usb_err = 0;\n\tsd->i2c_addr = 0x5c;\n\ti2c_w2(gspca_dev, 0x01, 0x0004);\n\ti2c_r2(gspca_dev, 0xff, &value);\n\tif (gspca_dev->usb_err >= 0\n\t && value == 0x823a) {\n\t\ti2c_w2_buf(gspca_dev, mt9v111_init, ARRAY_SIZE(mt9v111_init));\n\t\tif (gspca_dev->usb_err < 0) {\n\t\t\tpr_err(\"MT9V111 sensor initialization failed\\n\");\n\t\t\treturn;\n\t\t}\n\t\tsd->hstart = 2;\n\t\tsd->vstart = 2;\n\t\tsd->sensor = SENSOR_MT9V111;\n\t\tpr_info(\"MT9V111 sensor detected\\n\");\n\t\treturn;\n\t}\n\n\tgspca_dev->usb_err = 0;\n\tsd->i2c_addr = 0x5d;\n\ti2c_w2(gspca_dev, 0xf0, 0x0000);\n\tif (gspca_dev->usb_err < 0) {\n\t\tgspca_dev->usb_err = 0;\n\t\tsd->i2c_addr = 0x48;\n\t\ti2c_w2(gspca_dev, 0xf0, 0x0000);\n\t}\n\ti2c_r2(gspca_dev, 0x00, &value);\n\tif (gspca_dev->usb_err >= 0\n\t && value == 0x1229) {\n\t\ti2c_w2_buf(gspca_dev, mt9v112_init, ARRAY_SIZE(mt9v112_init));\n\t\tif (gspca_dev->usb_err < 0) {\n\t\t\tpr_err(\"MT9V112 sensor initialization failed\\n\");\n\t\t\treturn;\n\t\t}\n\t\tsd->hstart = 6;\n\t\tsd->vstart = 2;\n\t\tsd->sensor = SENSOR_MT9V112;\n\t\tpr_info(\"MT9V112 sensor detected\\n\");\n\t\treturn;\n\t}\n\n\tgspca_dev->usb_err = -ENODEV;\n}\n\nstatic void mt9m112_init_sensor(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\ti2c_w2_buf(gspca_dev, mt9m112_init, ARRAY_SIZE(mt9m112_init));\n\tif (gspca_dev->usb_err < 0)\n\t\tpr_err(\"MT9M112 sensor initialization failed\\n\");\n\n\tsd->hstart = 0;\n\tsd->vstart = 2;\n}\n\nstatic void mt9m111_init_sensor(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\ti2c_w2_buf(gspca_dev, mt9m111_init, ARRAY_SIZE(mt9m111_init));\n\tif (gspca_dev->usb_err < 0)\n\t\tpr_err(\"MT9M111 sensor initialization failed\\n\");\n\n\tsd->hstart = 0;\n\tsd->vstart = 2;\n}\n\nstatic void mt9m001_init_sensor(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu16 id;\n\n\ti2c_r2(gspca_dev, 0x00, &id);\n\tif (gspca_dev->usb_err < 0)\n\t\treturn;\n\n\t \n\tswitch (id) {\n\tcase 0x8411:\n\tcase 0x8421:\n\t\tpr_info(\"MT9M001 color sensor detected\\n\");\n\t\tbreak;\n\tcase 0x8431:\n\t\tpr_info(\"MT9M001 mono sensor detected\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"No MT9M001 chip detected, ID = %x\\n\\n\", id);\n\t\tgspca_dev->usb_err = -ENODEV;\n\t\treturn;\n\t}\n\n\ti2c_w2_buf(gspca_dev, mt9m001_init, ARRAY_SIZE(mt9m001_init));\n\tif (gspca_dev->usb_err < 0)\n\t\tpr_err(\"MT9M001 sensor initialization failed\\n\");\n\n\tsd->hstart = 1;\n\tsd->vstart = 1;\n}\n\nstatic void hv7131r_init_sensor(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\ti2c_w1_buf(gspca_dev, hv7131r_init, ARRAY_SIZE(hv7131r_init));\n\tif (gspca_dev->usb_err < 0)\n\t\tpr_err(\"HV7131R Sensor initialization failed\\n\");\n\n\tsd->hstart = 0;\n\tsd->vstart = 1;\n}\n\nstatic void set_cmatrix(struct gspca_dev *gspca_dev,\n\t\ts32 brightness, s32 contrast, s32 satur, s32 hue)\n{\n\ts32 hue_coord, hue_index = 180 + hue;\n\tu8 cmatrix[21];\n\n\tmemset(cmatrix, 0, sizeof(cmatrix));\n\tcmatrix[2] = (contrast * 0x25 / 0x100) + 0x26;\n\tcmatrix[0] = 0x13 + (cmatrix[2] - 0x26) * 0x13 / 0x25;\n\tcmatrix[4] = 0x07 + (cmatrix[2] - 0x26) * 0x07 / 0x25;\n\tcmatrix[18] = brightness - 0x80;\n\n\thue_coord = (hsv_red_x[hue_index] * satur) >> 8;\n\tcmatrix[6] = hue_coord;\n\tcmatrix[7] = (hue_coord >> 8) & 0x0f;\n\n\thue_coord = (hsv_red_y[hue_index] * satur) >> 8;\n\tcmatrix[8] = hue_coord;\n\tcmatrix[9] = (hue_coord >> 8) & 0x0f;\n\n\thue_coord = (hsv_green_x[hue_index] * satur) >> 8;\n\tcmatrix[10] = hue_coord;\n\tcmatrix[11] = (hue_coord >> 8) & 0x0f;\n\n\thue_coord = (hsv_green_y[hue_index] * satur) >> 8;\n\tcmatrix[12] = hue_coord;\n\tcmatrix[13] = (hue_coord >> 8) & 0x0f;\n\n\thue_coord = (hsv_blue_x[hue_index] * satur) >> 8;\n\tcmatrix[14] = hue_coord;\n\tcmatrix[15] = (hue_coord >> 8) & 0x0f;\n\n\thue_coord = (hsv_blue_y[hue_index] * satur) >> 8;\n\tcmatrix[16] = hue_coord;\n\tcmatrix[17] = (hue_coord >> 8) & 0x0f;\n\n\treg_w(gspca_dev, 0x10e1, cmatrix, 21);\n}\n\nstatic void set_gamma(struct gspca_dev *gspca_dev, s32 val)\n{\n\tu8 gamma[17];\n\tu8 gval = val * 0xb8 / 0x100;\n\n\tgamma[0] = 0x0a;\n\tgamma[1] = 0x13 + (gval * (0xcb - 0x13) / 0xb8);\n\tgamma[2] = 0x25 + (gval * (0xee - 0x25) / 0xb8);\n\tgamma[3] = 0x37 + (gval * (0xfa - 0x37) / 0xb8);\n\tgamma[4] = 0x45 + (gval * (0xfc - 0x45) / 0xb8);\n\tgamma[5] = 0x55 + (gval * (0xfb - 0x55) / 0xb8);\n\tgamma[6] = 0x65 + (gval * (0xfc - 0x65) / 0xb8);\n\tgamma[7] = 0x74 + (gval * (0xfd - 0x74) / 0xb8);\n\tgamma[8] = 0x83 + (gval * (0xfe - 0x83) / 0xb8);\n\tgamma[9] = 0x92 + (gval * (0xfc - 0x92) / 0xb8);\n\tgamma[10] = 0xa1 + (gval * (0xfc - 0xa1) / 0xb8);\n\tgamma[11] = 0xb0 + (gval * (0xfc - 0xb0) / 0xb8);\n\tgamma[12] = 0xbf + (gval * (0xfb - 0xbf) / 0xb8);\n\tgamma[13] = 0xce + (gval * (0xfb - 0xce) / 0xb8);\n\tgamma[14] = 0xdf + (gval * (0xfd - 0xdf) / 0xb8);\n\tgamma[15] = 0xea + (gval * (0xf9 - 0xea) / 0xb8);\n\tgamma[16] = 0xf5;\n\n\treg_w(gspca_dev, 0x1190, gamma, 17);\n}\n\nstatic void set_redblue(struct gspca_dev *gspca_dev, s32 blue, s32 red)\n{\n\treg_w1(gspca_dev, 0x118c, red);\n\treg_w1(gspca_dev, 0x118f, blue);\n}\n\nstatic void set_hvflip(struct gspca_dev *gspca_dev, s32 hflip, s32 vflip)\n{\n\tu8 value, tslb;\n\tu16 value2;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif ((sd->flags & FLIP_DETECT) && dmi_check_system(flip_dmi_table)) {\n\t\thflip = !hflip;\n\t\tvflip = !vflip;\n\t}\n\n\tswitch (sd->sensor) {\n\tcase SENSOR_OV7660:\n\t\tvalue = 0x01;\n\t\tif (hflip)\n\t\t\tvalue |= 0x20;\n\t\tif (vflip) {\n\t\t\tvalue |= 0x10;\n\t\t\tsd->vstart = 2;\n\t\t} else {\n\t\t\tsd->vstart = 3;\n\t\t}\n\t\treg_w1(gspca_dev, 0x1182, sd->vstart);\n\t\ti2c_w1(gspca_dev, 0x1e, value);\n\t\tbreak;\n\tcase SENSOR_OV9650:\n\t\ti2c_r1(gspca_dev, 0x1e, &value);\n\t\tvalue &= ~0x30;\n\t\ttslb = 0x01;\n\t\tif (hflip)\n\t\t\tvalue |= 0x20;\n\t\tif (vflip) {\n\t\t\tvalue |= 0x10;\n\t\t\ttslb = 0x49;\n\t\t}\n\t\ti2c_w1(gspca_dev, 0x1e, value);\n\t\ti2c_w1(gspca_dev, 0x3a, tslb);\n\t\tbreak;\n\tcase SENSOR_MT9V111:\n\tcase SENSOR_MT9V011:\n\t\ti2c_r2(gspca_dev, 0x20, &value2);\n\t\tvalue2 &= ~0xc0a0;\n\t\tif (hflip)\n\t\t\tvalue2 |= 0x8080;\n\t\tif (vflip)\n\t\t\tvalue2 |= 0x4020;\n\t\ti2c_w2(gspca_dev, 0x20, value2);\n\t\tbreak;\n\tcase SENSOR_MT9M112:\n\tcase SENSOR_MT9M111:\n\tcase SENSOR_MT9V112:\n\t\ti2c_r2(gspca_dev, 0x20, &value2);\n\t\tvalue2 &= ~0x0003;\n\t\tif (hflip)\n\t\t\tvalue2 |= 0x0002;\n\t\tif (vflip)\n\t\t\tvalue2 |= 0x0001;\n\t\ti2c_w2(gspca_dev, 0x20, value2);\n\t\tbreak;\n\tcase SENSOR_HV7131R:\n\t\ti2c_r1(gspca_dev, 0x01, &value);\n\t\tvalue &= ~0x03;\n\t\tif (vflip)\n\t\t\tvalue |= 0x01;\n\t\tif (hflip)\n\t\t\tvalue |= 0x02;\n\t\ti2c_w1(gspca_dev, 0x01, value);\n\t\tbreak;\n\t}\n}\n\nstatic void set_exposure(struct gspca_dev *gspca_dev, s32 expo)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 exp[8] = {sd->i2c_intf, sd->i2c_addr,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x10};\n\tint expo2;\n\n\tif (gspca_dev->streaming)\n\t\texp[7] = 0x1e;\n\n\tswitch (sd->sensor) {\n\tcase SENSOR_OV7660:\n\tcase SENSOR_OV7670:\n\tcase SENSOR_OV9655:\n\tcase SENSOR_OV9650:\n\t\tif (expo > 547)\n\t\t\texpo2 = 547;\n\t\telse\n\t\t\texpo2 = expo;\n\t\texp[0] |= (2 << 4);\n\t\texp[2] = 0x10;\t\t\t \n\t\texp[3] = expo2 >> 2;\n\t\texp[7] = 0x10;\n\t\ti2c_w(gspca_dev, exp);\n\t\texp[2] = 0x04;\t\t\t \n\t\texp[3] = expo2 & 0x0003;\n\t\texp[7] = 0x10;\n\t\ti2c_w(gspca_dev, exp);\n\t\texpo -= expo2;\n\t\texp[7] = 0x1e;\n\t\texp[0] |= (3 << 4);\n\t\texp[2] = 0x2d;\t\t\t \n\t\texp[3] = expo;\n\t\texp[4] = expo >> 8;\n\t\tbreak;\n\tcase SENSOR_MT9M001:\n\tcase SENSOR_MT9V112:\n\tcase SENSOR_MT9V011:\n\t\texp[0] |= (3 << 4);\n\t\texp[2] = 0x09;\n\t\texp[3] = expo >> 8;\n\t\texp[4] = expo;\n\t\tbreak;\n\tcase SENSOR_HV7131R:\n\t\texp[0] |= (4 << 4);\n\t\texp[2] = 0x25;\n\t\texp[3] = expo >> 5;\n\t\texp[4] = expo << 3;\n\t\texp[5] = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\ti2c_w(gspca_dev, exp);\n}\n\nstatic void set_gain(struct gspca_dev *gspca_dev, s32 g)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 gain[8] = {sd->i2c_intf, sd->i2c_addr,\n\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x10};\n\n\tif (gspca_dev->streaming)\n\t\tgain[7] = 0x15;\t\t \n\n\tswitch (sd->sensor) {\n\tcase SENSOR_OV7660:\n\tcase SENSOR_OV7670:\n\tcase SENSOR_SOI968:\n\tcase SENSOR_OV9655:\n\tcase SENSOR_OV9650:\n\t\tgain[0] |= (2 << 4);\n\t\tgain[3] = ov_gain[g];\n\t\tbreak;\n\tcase SENSOR_MT9V011:\n\t\tgain[0] |= (3 << 4);\n\t\tgain[2] = 0x35;\n\t\tgain[3] = micron1_gain[g] >> 8;\n\t\tgain[4] = micron1_gain[g];\n\t\tbreak;\n\tcase SENSOR_MT9V112:\n\t\tgain[0] |= (3 << 4);\n\t\tgain[2] = 0x2f;\n\t\tgain[3] = micron1_gain[g] >> 8;\n\t\tgain[4] = micron1_gain[g];\n\t\tbreak;\n\tcase SENSOR_MT9M001:\n\t\tgain[0] |= (3 << 4);\n\t\tgain[2] = 0x2f;\n\t\tgain[3] = micron2_gain[g] >> 8;\n\t\tgain[4] = micron2_gain[g];\n\t\tbreak;\n\tcase SENSOR_HV7131R:\n\t\tgain[0] |= (2 << 4);\n\t\tgain[2] = 0x30;\n\t\tgain[3] = hv7131r_gain[g];\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\ti2c_w(gspca_dev, gain);\n}\n\nstatic void set_led_mode(struct gspca_dev *gspca_dev, s32 val)\n{\n\treg_w1(gspca_dev, 0x1007, 0x60);\n\treg_w1(gspca_dev, 0x1006, val ? 0x40 : 0x00);\n}\n\nstatic void set_quality(struct gspca_dev *gspca_dev, s32 val)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tjpeg_set_qual(sd->jpeg_hdr, val);\n\treg_w1(gspca_dev, 0x1061, 0x01);\t \n\treg_w1(gspca_dev, 0x10e0, sd->fmt | 0x20);  \n\treg_w(gspca_dev, 0x1100, &sd->jpeg_hdr[JPEG_QT0_OFFSET], 64);\n\treg_w(gspca_dev, 0x1140, &sd->jpeg_hdr[JPEG_QT1_OFFSET], 64);\n\treg_w1(gspca_dev, 0x1061, 0x03);\t \n\treg_w1(gspca_dev, 0x10e0, sd->fmt);\n\tsd->fmt ^= 0x0c;\t\t\t \n\treg_w1(gspca_dev, 0x10e0, sd->fmt);\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int sd_dbg_g_register(struct gspca_dev *gspca_dev,\n\t\t\tstruct v4l2_dbg_register *reg)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\treg->size = 1;\n\tswitch (reg->match.addr) {\n\tcase 0:\n\t\tif (reg->reg < 0x1000 || reg->reg > 0x11ff)\n\t\t\treturn -EINVAL;\n\t\treg_r(gspca_dev, reg->reg, 1);\n\t\treg->val = gspca_dev->usb_buf[0];\n\t\treturn gspca_dev->usb_err;\n\tcase 1:\n\t\tif (sd->sensor >= SENSOR_MT9V011 &&\n\t\t    sd->sensor <= SENSOR_MT9M112) {\n\t\t\ti2c_r2(gspca_dev, reg->reg, (u16 *) &reg->val);\n\t\t\treg->size = 2;\n\t\t} else {\n\t\t\ti2c_r1(gspca_dev, reg->reg, (u8 *) &reg->val);\n\t\t}\n\t\treturn gspca_dev->usb_err;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int sd_dbg_s_register(struct gspca_dev *gspca_dev,\n\t\t\tconst struct v4l2_dbg_register *reg)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tswitch (reg->match.addr) {\n\tcase 0:\n\t\tif (reg->reg < 0x1000 || reg->reg > 0x11ff)\n\t\t\treturn -EINVAL;\n\t\treg_w1(gspca_dev, reg->reg, reg->val);\n\t\treturn gspca_dev->usb_err;\n\tcase 1:\n\t\tif (sd->sensor >= SENSOR_MT9V011 &&\n\t\t    sd->sensor <= SENSOR_MT9M112) {\n\t\t\ti2c_w2(gspca_dev, reg->reg, reg->val);\n\t\t} else {\n\t\t\ti2c_w1(gspca_dev, reg->reg, reg->val);\n\t\t}\n\t\treturn gspca_dev->usb_err;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int sd_chip_info(struct gspca_dev *gspca_dev,\n\t\t\tstruct v4l2_dbg_chip_info *chip)\n{\n\tif (chip->match.addr > 1)\n\t\treturn -EINVAL;\n\tif (chip->match.addr == 1)\n\t\tstrscpy(chip->name, \"sensor\", sizeof(chip->name));\n\treturn 0;\n}\n#endif\n\nstatic int sd_config(struct gspca_dev *gspca_dev,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct cam *cam;\n\n\tcam = &gspca_dev->cam;\n\tcam->needs_full_bandwidth = 1;\n\n\tsd->sensor = id->driver_info >> 8;\n\tsd->i2c_addr = id->driver_info;\n\tsd->flags = id->driver_info >> 16;\n\tsd->i2c_intf = 0x80;\t\t\t \n\n\tswitch (sd->sensor) {\n\tcase SENSOR_MT9M112:\n\tcase SENSOR_MT9M111:\n\tcase SENSOR_OV9650:\n\tcase SENSOR_SOI968:\n\t\tcam->cam_mode = sxga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(sxga_mode);\n\t\tbreak;\n\tcase SENSOR_MT9M001:\n\t\tcam->cam_mode = mono_mode;\n\t\tcam->nmodes = ARRAY_SIZE(mono_mode);\n\t\tbreak;\n\tcase SENSOR_HV7131R:\n\t\tsd->i2c_intf = 0x81;\t\t\t \n\t\tfallthrough;\n\tdefault:\n\t\tcam->cam_mode = vga_mode;\n\t\tcam->nmodes = ARRAY_SIZE(vga_mode);\n\t\tbreak;\n\t}\n\n\tsd->old_step = 0;\n\tsd->older_step = 0;\n\tsd->exposure_step = 16;\n\n\tINIT_WORK(&sd->work, qual_upd);\n\n\treturn 0;\n}\n\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gspca_dev *gspca_dev =\n\t\tcontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\n\tstruct sd *sd = (struct sd *)gspca_dev;\n\n\tgspca_dev->usb_err = 0;\n\n\tif (!gspca_dev->streaming)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\t \n\tcase V4L2_CID_BRIGHTNESS:\n\t\tset_cmatrix(gspca_dev, sd->brightness->val,\n\t\t\tsd->contrast->val, sd->saturation->val, sd->hue->val);\n\t\tbreak;\n\tcase V4L2_CID_GAMMA:\n\t\tset_gamma(gspca_dev, ctrl->val);\n\t\tbreak;\n\t \n\tcase V4L2_CID_BLUE_BALANCE:\n\t\tset_redblue(gspca_dev, sd->blue->val, sd->red->val);\n\t\tbreak;\n\t \n\tcase V4L2_CID_HFLIP:\n\t\tset_hvflip(gspca_dev, sd->hflip->val, sd->vflip->val);\n\t\tbreak;\n\t \n\tcase V4L2_CID_EXPOSURE:\n\t\tset_exposure(gspca_dev, ctrl->val);\n\t\tbreak;\n\t \n\tcase V4L2_CID_GAIN:\n\t\tset_gain(gspca_dev, ctrl->val);\n\t\tbreak;\n\t \n\tcase V4L2_CID_AUTOGAIN:\n\t\tif (sd->sensor == SENSOR_SOI968)\n\t\t\tset_gain(gspca_dev, sd->gain->val);\n\t\telse\n\t\t\tset_exposure(gspca_dev, sd->exposure->val);\n\t\tbreak;\n\tcase V4L2_CID_JPEG_COMPRESSION_QUALITY:\n\t\tset_quality(gspca_dev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_FLASH_LED_MODE:\n\t\tset_led_mode(gspca_dev, ctrl->val);\n\t\tbreak;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic const struct v4l2_ctrl_ops sd_ctrl_ops = {\n\t.s_ctrl = sd_s_ctrl,\n};\n\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\n\n\tgspca_dev->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_init(hdl, 13);\n\n\tsd->brightness = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 255, 1, 127);\n\tsd->contrast = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 255, 1, 127);\n\tsd->saturation = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 255, 1, 127);\n\tsd->hue = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_HUE, -180, 180, 1, 0);\n\n\tsd->gamma = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_GAMMA, 0, 255, 1, 0x10);\n\n\tsd->blue = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_BLUE_BALANCE, 0, 127, 1, 0x28);\n\tsd->red = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_RED_BALANCE, 0, 127, 1, 0x28);\n\n\tif (sd->sensor != SENSOR_OV9655 && sd->sensor != SENSOR_SOI968 &&\n\t    sd->sensor != SENSOR_OV7670 && sd->sensor != SENSOR_MT9M001 &&\n\t    sd->sensor != SENSOR_MT9VPRB) {\n\t\tsd->hflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\t\tsd->vflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\t}\n\n\tif (sd->sensor != SENSOR_SOI968 && sd->sensor != SENSOR_MT9VPRB &&\n\t    sd->sensor != SENSOR_MT9M112 && sd->sensor != SENSOR_MT9M111 &&\n\t    sd->sensor != SENSOR_MT9V111)\n\t\tsd->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_EXPOSURE, 0, 0x1780, 1, 0x33);\n\n\tif (sd->sensor != SENSOR_MT9VPRB && sd->sensor != SENSOR_MT9M112 &&\n\t    sd->sensor != SENSOR_MT9M111 && sd->sensor != SENSOR_MT9V111) {\n\t\tsd->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_GAIN, 0, 28, 1, 0);\n\t\tsd->autogain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\n\t}\n\n\tsd->jpegqual = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\n\t\t\tV4L2_CID_JPEG_COMPRESSION_QUALITY, 50, 90, 1, 80);\n\n\tif (sd->flags & HAS_LED_TORCH)\n\t\tsd->led_mode = v4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\n\t\t\t\tV4L2_CID_FLASH_LED_MODE, V4L2_FLASH_LED_MODE_TORCH,\n\t\t\t\t~0x5, V4L2_FLASH_LED_MODE_NONE);\n\n\tif (hdl->error) {\n\t\tpr_err(\"Could not initialize controls\\n\");\n\t\treturn hdl->error;\n\t}\n\n\tv4l2_ctrl_cluster(4, &sd->brightness);\n\tv4l2_ctrl_cluster(2, &sd->blue);\n\tif (sd->hflip)\n\t\tv4l2_ctrl_cluster(2, &sd->hflip);\n\tif (sd->autogain) {\n\t\tif (sd->sensor == SENSOR_SOI968)\n\t\t\t \n\t\t\tv4l2_ctrl_auto_cluster(3, &sd->autogain, 0, false);\n\t\telse\n\t\t\t \n\t\t\tv4l2_ctrl_auto_cluster(2, &sd->autogain, 0, false);\n\t}\n\treturn 0;\n}\n\nstatic int sd_init(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint i;\n\tu8 value;\n\tu8 i2c_init[9] = {\n\t\t0x80, sd->i2c_addr, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(bridge_init); i++) {\n\t\tvalue = bridge_init[i][1];\n\t\treg_w(gspca_dev, bridge_init[i][0], &value, 1);\n\t\tif (gspca_dev->usb_err < 0) {\n\t\t\tpr_err(\"Device initialization failed\\n\");\n\t\t\treturn gspca_dev->usb_err;\n\t\t}\n\t}\n\n\tif (sd->flags & LED_REVERSE)\n\t\treg_w1(gspca_dev, 0x1006, 0x00);\n\telse\n\t\treg_w1(gspca_dev, 0x1006, 0x20);\n\n\treg_w(gspca_dev, 0x10c0, i2c_init, 9);\n\tif (gspca_dev->usb_err < 0) {\n\t\tpr_err(\"Device initialization failed\\n\");\n\t\treturn gspca_dev->usb_err;\n\t}\n\n\tswitch (sd->sensor) {\n\tcase SENSOR_OV9650:\n\t\tov9650_init_sensor(gspca_dev);\n\t\tif (gspca_dev->usb_err < 0)\n\t\t\tbreak;\n\t\tpr_info(\"OV9650 sensor detected\\n\");\n\t\tbreak;\n\tcase SENSOR_OV9655:\n\t\tov9655_init_sensor(gspca_dev);\n\t\tif (gspca_dev->usb_err < 0)\n\t\t\tbreak;\n\t\tpr_info(\"OV9655 sensor detected\\n\");\n\t\tbreak;\n\tcase SENSOR_SOI968:\n\t\tsoi968_init_sensor(gspca_dev);\n\t\tif (gspca_dev->usb_err < 0)\n\t\t\tbreak;\n\t\tpr_info(\"SOI968 sensor detected\\n\");\n\t\tbreak;\n\tcase SENSOR_OV7660:\n\t\tov7660_init_sensor(gspca_dev);\n\t\tif (gspca_dev->usb_err < 0)\n\t\t\tbreak;\n\t\tpr_info(\"OV7660 sensor detected\\n\");\n\t\tbreak;\n\tcase SENSOR_OV7670:\n\t\tov7670_init_sensor(gspca_dev);\n\t\tif (gspca_dev->usb_err < 0)\n\t\t\tbreak;\n\t\tpr_info(\"OV7670 sensor detected\\n\");\n\t\tbreak;\n\tcase SENSOR_MT9VPRB:\n\t\tmt9v_init_sensor(gspca_dev);\n\t\tif (gspca_dev->usb_err < 0)\n\t\t\tbreak;\n\t\tpr_info(\"MT9VPRB sensor detected\\n\");\n\t\tbreak;\n\tcase SENSOR_MT9M111:\n\t\tmt9m111_init_sensor(gspca_dev);\n\t\tif (gspca_dev->usb_err < 0)\n\t\t\tbreak;\n\t\tpr_info(\"MT9M111 sensor detected\\n\");\n\t\tbreak;\n\tcase SENSOR_MT9M112:\n\t\tmt9m112_init_sensor(gspca_dev);\n\t\tif (gspca_dev->usb_err < 0)\n\t\t\tbreak;\n\t\tpr_info(\"MT9M112 sensor detected\\n\");\n\t\tbreak;\n\tcase SENSOR_MT9M001:\n\t\tmt9m001_init_sensor(gspca_dev);\n\t\tif (gspca_dev->usb_err < 0)\n\t\t\tbreak;\n\t\tbreak;\n\tcase SENSOR_HV7131R:\n\t\thv7131r_init_sensor(gspca_dev);\n\t\tif (gspca_dev->usb_err < 0)\n\t\t\tbreak;\n\t\tpr_info(\"HV7131R sensor detected\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unsupported sensor\\n\");\n\t\tgspca_dev->usb_err = -ENODEV;\n\t}\n\treturn gspca_dev->usb_err;\n}\n\nstatic void configure_sensor_output(struct gspca_dev *gspca_dev, int mode)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tu8 value;\n\n\tswitch (sd->sensor) {\n\tcase SENSOR_SOI968:\n\t\tif (mode & MODE_SXGA) {\n\t\t\ti2c_w1(gspca_dev, 0x17, 0x1d);\n\t\t\ti2c_w1(gspca_dev, 0x18, 0xbd);\n\t\t\ti2c_w1(gspca_dev, 0x19, 0x01);\n\t\t\ti2c_w1(gspca_dev, 0x1a, 0x81);\n\t\t\ti2c_w1(gspca_dev, 0x12, 0x00);\n\t\t\tsd->hstart = 140;\n\t\t\tsd->vstart = 19;\n\t\t} else {\n\t\t\ti2c_w1(gspca_dev, 0x17, 0x13);\n\t\t\ti2c_w1(gspca_dev, 0x18, 0x63);\n\t\t\ti2c_w1(gspca_dev, 0x19, 0x01);\n\t\t\ti2c_w1(gspca_dev, 0x1a, 0x79);\n\t\t\ti2c_w1(gspca_dev, 0x12, 0x40);\n\t\t\tsd->hstart = 60;\n\t\t\tsd->vstart = 11;\n\t\t}\n\t\tbreak;\n\tcase SENSOR_OV9650:\n\t\tif (mode & MODE_SXGA) {\n\t\t\ti2c_w1(gspca_dev, 0x17, 0x1b);\n\t\t\ti2c_w1(gspca_dev, 0x18, 0xbc);\n\t\t\ti2c_w1(gspca_dev, 0x19, 0x01);\n\t\t\ti2c_w1(gspca_dev, 0x1a, 0x82);\n\t\t\ti2c_r1(gspca_dev, 0x12, &value);\n\t\t\ti2c_w1(gspca_dev, 0x12, value & 0x07);\n\t\t} else {\n\t\t\ti2c_w1(gspca_dev, 0x17, 0x24);\n\t\t\ti2c_w1(gspca_dev, 0x18, 0xc5);\n\t\t\ti2c_w1(gspca_dev, 0x19, 0x00);\n\t\t\ti2c_w1(gspca_dev, 0x1a, 0x3c);\n\t\t\ti2c_r1(gspca_dev, 0x12, &value);\n\t\t\ti2c_w1(gspca_dev, 0x12, (value & 0x7) | 0x40);\n\t\t}\n\t\tbreak;\n\tcase SENSOR_MT9M112:\n\tcase SENSOR_MT9M111:\n\t\tif (mode & MODE_SXGA) {\n\t\t\ti2c_w2(gspca_dev, 0xf0, 0x0002);\n\t\t\ti2c_w2(gspca_dev, 0xc8, 0x970b);\n\t\t\ti2c_w2(gspca_dev, 0xf0, 0x0000);\n\t\t} else {\n\t\t\ti2c_w2(gspca_dev, 0xf0, 0x0002);\n\t\t\ti2c_w2(gspca_dev, 0xc8, 0x8000);\n\t\t\ti2c_w2(gspca_dev, 0xf0, 0x0000);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int sd_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_interface *intf;\n\tu32 flags = gspca_dev->cam.cam_mode[(int)gspca_dev->curr_mode].priv;\n\n\t \n\tif (!(flags & (MODE_RAW | MODE_JPEG))) {\n\t\tintf = usb_ifnum_to_if(gspca_dev->dev, gspca_dev->iface);\n\n\t\tif (intf->num_altsetting != 9) {\n\t\t\tpr_warn(\"sn9c20x camera with unknown number of alt settings (%d), please report!\\n\",\n\t\t\t\tintf->num_altsetting);\n\t\t\tgspca_dev->alt = intf->num_altsetting;\n\t\t\treturn 0;\n\t\t}\n\n\t\tswitch (gspca_dev->pixfmt.width) {\n\t\tcase 160:  \n\t\t\tgspca_dev->alt = 2;\n\t\t\tbreak;\n\t\tcase 320:  \n\t\t\tgspca_dev->alt = 6;\n\t\t\tbreak;\n\t\tdefault:   \n\t\t\tgspca_dev->alt = 9;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#define HW_WIN(mode, hstart, vstart) \\\n((const u8 []){hstart, 0, vstart, 0, \\\n(mode & MODE_SXGA ? 1280 >> 4 : 640 >> 4), \\\n(mode & MODE_SXGA ? 1024 >> 3 : 480 >> 3)})\n\n#define CLR_WIN(width, height) \\\n((const u8 [])\\\n{0, width >> 2, 0, height >> 1,\\\n((width >> 10) & 0x01) | ((height >> 8) & 0x6)})\n\nstatic int sd_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint mode = gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv;\n\tint width = gspca_dev->pixfmt.width;\n\tint height = gspca_dev->pixfmt.height;\n\tu8 fmt, scale = 0;\n\n\tjpeg_define(sd->jpeg_hdr, height, width,\n\t\t\t0x21);\n\tjpeg_set_qual(sd->jpeg_hdr, v4l2_ctrl_g_ctrl(sd->jpegqual));\n\n\tif (mode & MODE_RAW)\n\t\tfmt = 0x2d;\n\telse if (mode & MODE_JPEG)\n\t\tfmt = 0x24;\n\telse\n\t\tfmt = 0x2f;\t \n\tsd->fmt = fmt;\n\n\tswitch (mode & SCALE_MASK) {\n\tcase SCALE_1280x1024:\n\t\tscale = 0xc0;\n\t\tpr_info(\"Set 1280x1024\\n\");\n\t\tbreak;\n\tcase SCALE_640x480:\n\t\tscale = 0x80;\n\t\tpr_info(\"Set 640x480\\n\");\n\t\tbreak;\n\tcase SCALE_320x240:\n\t\tscale = 0x90;\n\t\tpr_info(\"Set 320x240\\n\");\n\t\tbreak;\n\tcase SCALE_160x120:\n\t\tscale = 0xa0;\n\t\tpr_info(\"Set 160x120\\n\");\n\t\tbreak;\n\t}\n\n\tconfigure_sensor_output(gspca_dev, mode);\n\treg_w(gspca_dev, 0x1100, &sd->jpeg_hdr[JPEG_QT0_OFFSET], 64);\n\treg_w(gspca_dev, 0x1140, &sd->jpeg_hdr[JPEG_QT1_OFFSET], 64);\n\treg_w(gspca_dev, 0x10fb, CLR_WIN(width, height), 5);\n\treg_w(gspca_dev, 0x1180, HW_WIN(mode, sd->hstart, sd->vstart), 6);\n\treg_w1(gspca_dev, 0x1189, scale);\n\treg_w1(gspca_dev, 0x10e0, fmt);\n\n\tset_cmatrix(gspca_dev, v4l2_ctrl_g_ctrl(sd->brightness),\n\t\t\tv4l2_ctrl_g_ctrl(sd->contrast),\n\t\t\tv4l2_ctrl_g_ctrl(sd->saturation),\n\t\t\tv4l2_ctrl_g_ctrl(sd->hue));\n\tset_gamma(gspca_dev, v4l2_ctrl_g_ctrl(sd->gamma));\n\tset_redblue(gspca_dev, v4l2_ctrl_g_ctrl(sd->blue),\n\t\t\tv4l2_ctrl_g_ctrl(sd->red));\n\tif (sd->gain)\n\t\tset_gain(gspca_dev, v4l2_ctrl_g_ctrl(sd->gain));\n\tif (sd->exposure)\n\t\tset_exposure(gspca_dev, v4l2_ctrl_g_ctrl(sd->exposure));\n\tif (sd->hflip)\n\t\tset_hvflip(gspca_dev, v4l2_ctrl_g_ctrl(sd->hflip),\n\t\t\t\tv4l2_ctrl_g_ctrl(sd->vflip));\n\n\treg_w1(gspca_dev, 0x1007, 0x20);\n\treg_w1(gspca_dev, 0x1061, 0x03);\n\n\t \n\tif (mode & MODE_JPEG) {\n\t\tsd->pktsz = sd->npkt = 0;\n\t\tsd->nchg = 0;\n\t}\n\tif (sd->led_mode)\n\t\tv4l2_ctrl_s_ctrl(sd->led_mode, 0);\n\n\treturn gspca_dev->usb_err;\n}\n\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\n{\n\treg_w1(gspca_dev, 0x1007, 0x00);\n\treg_w1(gspca_dev, 0x1061, 0x01);\n}\n\n \n \nstatic void sd_stop0(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tmutex_unlock(&gspca_dev->usb_lock);\n\tflush_work(&sd->work);\n\tmutex_lock(&gspca_dev->usb_lock);\n}\n\nstatic void do_autoexposure(struct gspca_dev *gspca_dev, u16 avg_lum)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\ts32 cur_exp = v4l2_ctrl_g_ctrl(sd->exposure);\n\ts32 max = sd->exposure->maximum - sd->exposure_step;\n\ts32 min = sd->exposure->minimum + sd->exposure_step;\n\ts16 new_exp;\n\n\t \n\tif (avg_lum < MIN_AVG_LUM) {\n\t\tif (cur_exp > max)\n\t\t\treturn;\n\n\t\tnew_exp = cur_exp + sd->exposure_step;\n\t\tif (new_exp > max)\n\t\t\tnew_exp = max;\n\t\tif (new_exp < min)\n\t\t\tnew_exp = min;\n\t\tv4l2_ctrl_s_ctrl(sd->exposure, new_exp);\n\n\t\tsd->older_step = sd->old_step;\n\t\tsd->old_step = 1;\n\n\t\tif (sd->old_step ^ sd->older_step)\n\t\t\tsd->exposure_step /= 2;\n\t\telse\n\t\t\tsd->exposure_step += 2;\n\t}\n\tif (avg_lum > MAX_AVG_LUM) {\n\t\tif (cur_exp < min)\n\t\t\treturn;\n\t\tnew_exp = cur_exp - sd->exposure_step;\n\t\tif (new_exp > max)\n\t\t\tnew_exp = max;\n\t\tif (new_exp < min)\n\t\t\tnew_exp = min;\n\t\tv4l2_ctrl_s_ctrl(sd->exposure, new_exp);\n\t\tsd->older_step = sd->old_step;\n\t\tsd->old_step = 0;\n\n\t\tif (sd->old_step ^ sd->older_step)\n\t\t\tsd->exposure_step /= 2;\n\t\telse\n\t\t\tsd->exposure_step += 2;\n\t}\n}\n\nstatic void do_autogain(struct gspca_dev *gspca_dev, u16 avg_lum)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\ts32 cur_gain = v4l2_ctrl_g_ctrl(sd->gain);\n\n\tif (avg_lum < MIN_AVG_LUM && cur_gain < sd->gain->maximum)\n\t\tv4l2_ctrl_s_ctrl(sd->gain, cur_gain + 1);\n\tif (avg_lum > MAX_AVG_LUM && cur_gain > sd->gain->minimum)\n\t\tv4l2_ctrl_s_ctrl(sd->gain, cur_gain - 1);\n}\n\nstatic void sd_dqcallback(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint avg_lum;\n\n\tif (sd->autogain == NULL || !v4l2_ctrl_g_ctrl(sd->autogain))\n\t\treturn;\n\n\tavg_lum = atomic_read(&sd->avg_lum);\n\tif (sd->sensor == SENSOR_SOI968)\n\t\tdo_autogain(gspca_dev, avg_lum);\n\telse\n\t\tdo_autoexposure(gspca_dev, avg_lum);\n}\n\n \n \nstatic void qual_upd(struct work_struct *work)\n{\n\tstruct sd *sd = container_of(work, struct sd, work);\n\tstruct gspca_dev *gspca_dev = &sd->gspca_dev;\n\ts32 qual = v4l2_ctrl_g_ctrl(sd->jpegqual);\n\n\t \n\tmutex_lock(&gspca_dev->usb_lock);\n\tgspca_dbg(gspca_dev, D_STREAM, \"qual_upd %d%%\\n\", qual);\n\tgspca_dev->usb_err = 0;\n\tset_quality(gspca_dev, qual);\n\tmutex_unlock(&gspca_dev->usb_lock);\n}\n\n#if IS_ENABLED(CONFIG_INPUT)\nstatic int sd_int_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t \n\t\t\tint len)\t\t \n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tif (!(sd->flags & HAS_NO_BUTTON) && len == 1) {\n\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);\n\t\tinput_sync(gspca_dev->input_dev);\n\t\tinput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\n\t\tinput_sync(gspca_dev->input_dev);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n#endif\n\n \nstatic void transfer_check(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint new_qual, r;\n\n\tnew_qual = 0;\n\n\t \n\tif (data[6] & 0x08) {\t\t\t\t \n\t\tgspca_dev->last_packet_type = DISCARD_PACKET;\n\t\tnew_qual = -5;\n\t} else {\n\n\t\t \n\t\tr = (sd->pktsz * 100) /\n\t\t\t(sd->npkt *\n\t\t\t\tgspca_dev->urb[0]->iso_frame_desc[0].length);\n\t\tif (r >= 85)\n\t\t\tnew_qual = -3;\n\t\telse if (r < 75)\n\t\t\tnew_qual = 2;\n\t}\n\tif (new_qual != 0) {\n\t\tsd->nchg += new_qual;\n\t\tif (sd->nchg < -6 || sd->nchg >= 12) {\n\t\t\t \n\t\t\ts32 curqual = sd->jpegqual->cur.val;\n\t\t\tsd->nchg = 0;\n\t\t\tnew_qual += curqual;\n\t\t\tif (new_qual < sd->jpegqual->minimum)\n\t\t\t\tnew_qual = sd->jpegqual->minimum;\n\t\t\telse if (new_qual > sd->jpegqual->maximum)\n\t\t\t\tnew_qual = sd->jpegqual->maximum;\n\t\t\tif (new_qual != curqual) {\n\t\t\t\tsd->jpegqual->cur.val = new_qual;\n\t\t\t\tschedule_work(&sd->work);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsd->nchg = 0;\n\t}\n\tsd->pktsz = sd->npkt = 0;\n}\n\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\n\t\t\tu8 *data,\t\t\t \n\t\t\tint len)\t\t\t \n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tint avg_lum, is_jpeg;\n\tstatic const u8 frame_header[] = {\n\t\t0xff, 0xff, 0x00, 0xc4, 0xc4, 0x96\n\t};\n\n\tis_jpeg = (sd->fmt & 0x03) == 0;\n\tif (len >= 64 && memcmp(data, frame_header, 6) == 0) {\n\t\tavg_lum = ((data[35] >> 2) & 3) |\n\t\t\t   (data[20] << 2) |\n\t\t\t   (data[19] << 10);\n\t\tavg_lum += ((data[35] >> 4) & 3) |\n\t\t\t    (data[22] << 2) |\n\t\t\t    (data[21] << 10);\n\t\tavg_lum += ((data[35] >> 6) & 3) |\n\t\t\t    (data[24] << 2) |\n\t\t\t    (data[23] << 10);\n\t\tavg_lum += (data[36] & 3) |\n\t\t\t   (data[26] << 2) |\n\t\t\t   (data[25] << 10);\n\t\tavg_lum += ((data[36] >> 2) & 3) |\n\t\t\t    (data[28] << 2) |\n\t\t\t    (data[27] << 10);\n\t\tavg_lum += ((data[36] >> 4) & 3) |\n\t\t\t    (data[30] << 2) |\n\t\t\t    (data[29] << 10);\n\t\tavg_lum += ((data[36] >> 6) & 3) |\n\t\t\t    (data[32] << 2) |\n\t\t\t    (data[31] << 10);\n\t\tavg_lum += ((data[44] >> 4) & 3) |\n\t\t\t    (data[34] << 2) |\n\t\t\t    (data[33] << 10);\n\t\tavg_lum >>= 9;\n\t\tatomic_set(&sd->avg_lum, avg_lum);\n\n\t\tif (is_jpeg)\n\t\t\ttransfer_check(gspca_dev, data);\n\n\t\tgspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\n\t\tlen -= 64;\n\t\tif (len == 0)\n\t\t\treturn;\n\t\tdata += 64;\n\t}\n\tif (gspca_dev->last_packet_type == LAST_PACKET) {\n\t\tif (is_jpeg) {\n\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\t\t\tsd->jpeg_hdr, JPEG_HDR_SZ);\n\t\t\tgspca_frame_add(gspca_dev, INTER_PACKET,\n\t\t\t\tdata, len);\n\t\t} else {\n\t\t\tgspca_frame_add(gspca_dev, FIRST_PACKET,\n\t\t\t\tdata, len);\n\t\t}\n\t} else {\n\t\t \n\t\tif (is_jpeg) {\n\t\t\tsd->npkt++;\n\t\t\tsd->pktsz += len;\n\t\t}\n\t\tgspca_frame_add(gspca_dev, INTER_PACKET, data, len);\n\t}\n}\n\n \nstatic const struct sd_desc sd_desc = {\n\t.name = KBUILD_MODNAME,\n\t.config = sd_config,\n\t.init = sd_init,\n\t.init_controls = sd_init_controls,\n\t.isoc_init = sd_isoc_init,\n\t.start = sd_start,\n\t.stopN = sd_stopN,\n\t.stop0 = sd_stop0,\n\t.pkt_scan = sd_pkt_scan,\n#if IS_ENABLED(CONFIG_INPUT)\n\t.int_pkt_scan = sd_int_pkt_scan,\n#endif\n\t.dq_callback = sd_dqcallback,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.set_register = sd_dbg_s_register,\n\t.get_register = sd_dbg_g_register,\n\t.get_chip_info = sd_chip_info,\n#endif\n};\n\n#define SN9C20X(sensor, i2c_addr, flags) \\\n\t.driver_info =  ((flags & 0xff) << 16) \\\n\t\t\t| (SENSOR_ ## sensor << 8) \\\n\t\t\t| (i2c_addr)\n\nstatic const struct usb_device_id device_table[] = {\n\t{USB_DEVICE(0x0c45, 0x6240), SN9C20X(MT9M001, 0x5d, 0)},\n\t{USB_DEVICE(0x0c45, 0x6242), SN9C20X(MT9M111, 0x5d, HAS_LED_TORCH)},\n\t{USB_DEVICE(0x0c45, 0x6248), SN9C20X(OV9655, 0x30, 0)},\n\t{USB_DEVICE(0x0c45, 0x624c), SN9C20X(MT9M112, 0x5d, 0)},\n\t{USB_DEVICE(0x0c45, 0x624e), SN9C20X(SOI968, 0x30, LED_REVERSE)},\n\t{USB_DEVICE(0x0c45, 0x624f), SN9C20X(OV9650, 0x30,\n\t\t\t\t\t     (FLIP_DETECT | HAS_NO_BUTTON))},\n\t{USB_DEVICE(0x0c45, 0x6251), SN9C20X(OV9650, 0x30, 0)},\n\t{USB_DEVICE(0x0c45, 0x6253), SN9C20X(OV9650, 0x30, 0)},\n\t{USB_DEVICE(0x0c45, 0x6260), SN9C20X(OV7670, 0x21, 0)},\n\t{USB_DEVICE(0x0c45, 0x6270), SN9C20X(MT9VPRB, 0x00, 0)},\n\t{USB_DEVICE(0x0c45, 0x627b), SN9C20X(OV7660, 0x21, FLIP_DETECT)},\n\t{USB_DEVICE(0x0c45, 0x627c), SN9C20X(HV7131R, 0x11, 0)},\n\t{USB_DEVICE(0x0c45, 0x627f), SN9C20X(OV9650, 0x30, 0)},\n\t{USB_DEVICE(0x0c45, 0x6280), SN9C20X(MT9M001, 0x5d, 0)},\n\t{USB_DEVICE(0x0c45, 0x6282), SN9C20X(MT9M111, 0x5d, 0)},\n\t{USB_DEVICE(0x0c45, 0x6288), SN9C20X(OV9655, 0x30, 0)},\n\t{USB_DEVICE(0x0c45, 0x628c), SN9C20X(MT9M112, 0x5d, 0)},\n\t{USB_DEVICE(0x0c45, 0x628e), SN9C20X(SOI968, 0x30, 0)},\n\t{USB_DEVICE(0x0c45, 0x628f), SN9C20X(OV9650, 0x30, 0)},\n\t{USB_DEVICE(0x0c45, 0x62a0), SN9C20X(OV7670, 0x21, 0)},\n\t{USB_DEVICE(0x0c45, 0x62b0), SN9C20X(MT9VPRB, 0x00, 0)},\n\t{USB_DEVICE(0x0c45, 0x62b3), SN9C20X(OV9655, 0x30, LED_REVERSE)},\n\t{USB_DEVICE(0x0c45, 0x62bb), SN9C20X(OV7660, 0x21, LED_REVERSE)},\n\t{USB_DEVICE(0x0c45, 0x62bc), SN9C20X(HV7131R, 0x11, 0)},\n\t{USB_DEVICE(0x045e, 0x00f4), SN9C20X(OV9650, 0x30, 0)},\n\t{USB_DEVICE(0x145f, 0x013d), SN9C20X(OV7660, 0x21, 0)},\n\t{USB_DEVICE(0x0458, 0x7029), SN9C20X(HV7131R, 0x11, 0)},\n\t{USB_DEVICE(0x0458, 0x7045), SN9C20X(MT9M112, 0x5d, LED_REVERSE)},\n\t{USB_DEVICE(0x0458, 0x704a), SN9C20X(MT9M112, 0x5d, 0)},\n\t{USB_DEVICE(0x0458, 0x704c), SN9C20X(MT9M112, 0x5d, 0)},\n\t{USB_DEVICE(0xa168, 0x0610), SN9C20X(HV7131R, 0x11, 0)},\n\t{USB_DEVICE(0xa168, 0x0611), SN9C20X(HV7131R, 0x11, 0)},\n\t{USB_DEVICE(0xa168, 0x0613), SN9C20X(HV7131R, 0x11, 0)},\n\t{USB_DEVICE(0xa168, 0x0618), SN9C20X(HV7131R, 0x11, 0)},\n\t{USB_DEVICE(0xa168, 0x0614), SN9C20X(MT9M111, 0x5d, 0)},\n\t{USB_DEVICE(0xa168, 0x0615), SN9C20X(MT9M111, 0x5d, 0)},\n\t{USB_DEVICE(0xa168, 0x0617), SN9C20X(MT9M111, 0x5d, 0)},\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, device_table);\n\n \nstatic int sd_probe(struct usb_interface *intf,\n\t\t    const struct usb_device_id *id)\n{\n\treturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\n\t\t\t\tTHIS_MODULE);\n}\n\nstatic struct usb_driver sd_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = device_table,\n\t.probe = sd_probe,\n\t.disconnect = gspca_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = gspca_suspend,\n\t.resume = gspca_resume,\n\t.reset_resume = gspca_resume,\n#endif\n};\n\nmodule_usb_driver(sd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}