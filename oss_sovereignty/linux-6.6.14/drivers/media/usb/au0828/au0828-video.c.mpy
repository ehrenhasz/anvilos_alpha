{
  "module_name": "au0828-video.c",
  "hash_id": "311c662090ed7782e7aae9e95a658250cd42a4fded1d31e695631872dd131f8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/au0828/au0828-video.c",
  "human_readable_source": "\n \n\n \n\n#include \"au0828.h\"\n#include \"au8522.h\"\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-mc.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include <media/tuner.h>\n#include \"au0828-reg.h\"\n\nstatic DEFINE_MUTEX(au0828_sysfs_lock);\n\n \n\nstatic unsigned int isoc_debug;\nmodule_param(isoc_debug, int, 0644);\nMODULE_PARM_DESC(isoc_debug, \"enable debug messages [isoc transfers]\");\n\n#define au0828_isocdbg(fmt, arg...) \\\ndo {\\\n\tif (isoc_debug) { \\\n\t\tpr_info(\"au0828 %s :\"fmt, \\\n\t\t       __func__ , ##arg);\t   \\\n\t} \\\n  } while (0)\n\nstatic inline void i2c_gate_ctrl(struct au0828_dev *dev, int val)\n{\n\tif (dev->dvb.frontend && dev->dvb.frontend->ops.analog_ops.i2c_gate_ctrl)\n\t\tdev->dvb.frontend->ops.analog_ops.i2c_gate_ctrl(dev->dvb.frontend, val);\n}\n\nstatic inline void print_err_status(struct au0828_dev *dev,\n\t\t\t\t    int packet, int status)\n{\n\tchar *errmsg = \"Unknown\";\n\n\tswitch (status) {\n\tcase -ENOENT:\n\t\terrmsg = \"unlinked synchronously\";\n\t\tbreak;\n\tcase -ECONNRESET:\n\t\terrmsg = \"unlinked asynchronously\";\n\t\tbreak;\n\tcase -ENOSR:\n\t\terrmsg = \"Buffer error (overrun)\";\n\t\tbreak;\n\tcase -EPIPE:\n\t\terrmsg = \"Stalled (device not responding)\";\n\t\tbreak;\n\tcase -EOVERFLOW:\n\t\terrmsg = \"Babble (bad cable?)\";\n\t\tbreak;\n\tcase -EPROTO:\n\t\terrmsg = \"Bit-stuff error (bad cable?)\";\n\t\tbreak;\n\tcase -EILSEQ:\n\t\terrmsg = \"CRC/Timeout (could be anything)\";\n\t\tbreak;\n\tcase -ETIME:\n\t\terrmsg = \"Device does not respond\";\n\t\tbreak;\n\t}\n\tif (packet < 0) {\n\t\tau0828_isocdbg(\"URB status %d [%s].\\n\",\tstatus, errmsg);\n\t} else {\n\t\tau0828_isocdbg(\"URB packet %d, status %d [%s].\\n\",\n\t\t\t       packet, status, errmsg);\n\t}\n}\n\nstatic int check_dev(struct au0828_dev *dev)\n{\n\tif (test_bit(DEV_DISCONNECTED, &dev->dev_state)) {\n\t\tpr_info(\"v4l2 ioctl: device not present\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (test_bit(DEV_MISCONFIGURED, &dev->dev_state)) {\n\t\tpr_info(\"v4l2 ioctl: device is misconfigured; close and open it again\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \nstatic void au0828_irq_callback(struct urb *urb)\n{\n\tstruct au0828_dmaqueue  *dma_q = urb->context;\n\tstruct au0828_dev *dev = container_of(dma_q, struct au0828_dev, vidq);\n\tunsigned long flags = 0;\n\tint i;\n\n\tswitch (urb->status) {\n\tcase 0:              \n\tcase -ETIMEDOUT:     \n\t\tbreak;\n\tcase -ECONNRESET:    \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\tau0828_isocdbg(\"au0828_irq_callback called: status kill\\n\");\n\t\treturn;\n\tdefault:             \n\t\tau0828_isocdbg(\"urb completion error %d.\\n\", urb->status);\n\t\tbreak;\n\t}\n\n\t \n\tspin_lock_irqsave(&dev->slock, flags);\n\tdev->isoc_ctl.isoc_copy(dev, urb);\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\n\t \n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\turb->iso_frame_desc[i].status = 0;\n\t\turb->iso_frame_desc[i].actual_length = 0;\n\t}\n\turb->status = 0;\n\n\turb->status = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (urb->status) {\n\t\tau0828_isocdbg(\"urb resubmit failed (error=%i)\\n\",\n\t\t\t       urb->status);\n\t}\n\tdev->stream_state = STREAM_ON;\n}\n\n \nstatic void au0828_uninit_isoc(struct au0828_dev *dev)\n{\n\tstruct urb *urb;\n\tint i;\n\n\tau0828_isocdbg(\"au0828: called au0828_uninit_isoc\\n\");\n\n\tdev->isoc_ctl.nfields = -1;\n\tfor (i = 0; i < dev->isoc_ctl.num_bufs; i++) {\n\t\turb = dev->isoc_ctl.urb[i];\n\t\tif (urb) {\n\t\t\tif (!irqs_disabled())\n\t\t\t\tusb_kill_urb(urb);\n\t\t\telse\n\t\t\t\tusb_unlink_urb(urb);\n\n\t\t\tif (dev->isoc_ctl.transfer_buffer[i]) {\n\t\t\t\tusb_free_coherent(dev->usbdev,\n\t\t\t\t\turb->transfer_buffer_length,\n\t\t\t\t\tdev->isoc_ctl.transfer_buffer[i],\n\t\t\t\t\turb->transfer_dma);\n\t\t\t}\n\t\t\tusb_free_urb(urb);\n\t\t\tdev->isoc_ctl.urb[i] = NULL;\n\t\t}\n\t\tdev->isoc_ctl.transfer_buffer[i] = NULL;\n\t}\n\n\tkfree(dev->isoc_ctl.urb);\n\tkfree(dev->isoc_ctl.transfer_buffer);\n\n\tdev->isoc_ctl.urb = NULL;\n\tdev->isoc_ctl.transfer_buffer = NULL;\n\tdev->isoc_ctl.num_bufs = 0;\n\n\tdev->stream_state = STREAM_OFF;\n}\n\n \nstatic int au0828_init_isoc(struct au0828_dev *dev, int max_packets,\n\t\t\t    int num_bufs, int max_pkt_size,\n\t\t\t    int (*isoc_copy) (struct au0828_dev *dev, struct urb *urb))\n{\n\tstruct au0828_dmaqueue *dma_q = &dev->vidq;\n\tint i;\n\tint sb_size, pipe;\n\tstruct urb *urb;\n\tint j, k;\n\tint rc;\n\n\tau0828_isocdbg(\"au0828: called au0828_prepare_isoc\\n\");\n\n\tdev->isoc_ctl.isoc_copy = isoc_copy;\n\tdev->isoc_ctl.num_bufs = num_bufs;\n\n\tdev->isoc_ctl.urb = kcalloc(num_bufs, sizeof(void *),  GFP_KERNEL);\n\tif (!dev->isoc_ctl.urb) {\n\t\tau0828_isocdbg(\"cannot alloc memory for usb buffers\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdev->isoc_ctl.transfer_buffer = kcalloc(num_bufs, sizeof(void *),\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!dev->isoc_ctl.transfer_buffer) {\n\t\tau0828_isocdbg(\"cannot allocate memory for usb transfer\\n\");\n\t\tkfree(dev->isoc_ctl.urb);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev->isoc_ctl.max_pkt_size = max_pkt_size;\n\tdev->isoc_ctl.buf = NULL;\n\n\tsb_size = max_packets * dev->isoc_ctl.max_pkt_size;\n\n\t \n\tfor (i = 0; i < dev->isoc_ctl.num_bufs; i++) {\n\t\turb = usb_alloc_urb(max_packets, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\tau0828_isocdbg(\"cannot allocate URB\\n\");\n\t\t\tau0828_uninit_isoc(dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdev->isoc_ctl.urb[i] = urb;\n\n\t\tdev->isoc_ctl.transfer_buffer[i] = usb_alloc_coherent(dev->usbdev,\n\t\t\tsb_size, GFP_KERNEL, &urb->transfer_dma);\n\t\tif (!dev->isoc_ctl.transfer_buffer[i]) {\n\t\t\tau0828_isocdbg(\"cannot allocate transfer buffer\\n\");\n\t\t\tau0828_uninit_isoc(dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(dev->isoc_ctl.transfer_buffer[i], 0, sb_size);\n\n\t\tpipe = usb_rcvisocpipe(dev->usbdev,\n\t\t\t\t       dev->isoc_in_endpointaddr);\n\n\t\tusb_fill_int_urb(urb, dev->usbdev, pipe,\n\t\t\t\t dev->isoc_ctl.transfer_buffer[i], sb_size,\n\t\t\t\t au0828_irq_callback, dma_q, 1);\n\n\t\turb->number_of_packets = max_packets;\n\t\turb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\n\n\t\tk = 0;\n\t\tfor (j = 0; j < max_packets; j++) {\n\t\t\turb->iso_frame_desc[j].offset = k;\n\t\t\turb->iso_frame_desc[j].length =\n\t\t\t\t\t\tdev->isoc_ctl.max_pkt_size;\n\t\t\tk += dev->isoc_ctl.max_pkt_size;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < dev->isoc_ctl.num_bufs; i++) {\n\t\trc = usb_submit_urb(dev->isoc_ctl.urb[i], GFP_ATOMIC);\n\t\tif (rc) {\n\t\t\tau0828_isocdbg(\"submit of urb %i failed (error=%i)\\n\",\n\t\t\t\t       i, rc);\n\t\t\tau0828_uninit_isoc(dev);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline void buffer_filled(struct au0828_dev *dev,\n\t\t\t\t struct au0828_dmaqueue *dma_q,\n\t\t\t\t struct au0828_buffer *buf)\n{\n\tstruct vb2_v4l2_buffer *vb = &buf->vb;\n\tstruct vb2_queue *q = vb->vb2_buf.vb2_queue;\n\n\t \n\tau0828_isocdbg(\"[%p/%d] wakeup\\n\", buf, buf->top_field);\n\n\tif (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\tvb->sequence = dev->frame_count++;\n\telse\n\t\tvb->sequence = dev->vbi_frame_count++;\n\n\tvb->field = V4L2_FIELD_INTERLACED;\n\tvb->vb2_buf.timestamp = ktime_get_ns();\n\tvb2_buffer_done(&vb->vb2_buf, VB2_BUF_STATE_DONE);\n}\n\n \nstatic void au0828_copy_video(struct au0828_dev *dev,\n\t\t\t      struct au0828_dmaqueue  *dma_q,\n\t\t\t      struct au0828_buffer *buf,\n\t\t\t      unsigned char *p,\n\t\t\t      unsigned char *outp, unsigned long len)\n{\n\tvoid *fieldstart, *startwrite, *startread;\n\tint  linesdone, currlinedone, offset, lencopy, remain;\n\tint bytesperline = dev->width << 1;  \n\n\tif (len == 0)\n\t\treturn;\n\n\tif (dma_q->pos + len > buf->length)\n\t\tlen = buf->length - dma_q->pos;\n\n\tstartread = p;\n\tremain = len;\n\n\t \n\tif (buf->top_field)\n\t\tfieldstart = outp;\n\telse\n\t\tfieldstart = outp + bytesperline;\n\n\tlinesdone = dma_q->pos / bytesperline;\n\tcurrlinedone = dma_q->pos % bytesperline;\n\toffset = linesdone * bytesperline * 2 + currlinedone;\n\tstartwrite = fieldstart + offset;\n\tlencopy = bytesperline - currlinedone;\n\tlencopy = lencopy > remain ? remain : lencopy;\n\n\tif ((char *)startwrite + lencopy > (char *)outp + buf->length) {\n\t\tau0828_isocdbg(\"Overflow of %zi bytes past buffer end (1)\\n\",\n\t\t\t       ((char *)startwrite + lencopy) -\n\t\t\t       ((char *)outp + buf->length));\n\t\tremain = (char *)outp + buf->length - (char *)startwrite;\n\t\tlencopy = remain;\n\t}\n\tif (lencopy <= 0)\n\t\treturn;\n\tmemcpy(startwrite, startread, lencopy);\n\n\tremain -= lencopy;\n\n\twhile (remain > 0) {\n\t\tstartwrite += lencopy + bytesperline;\n\t\tstartread += lencopy;\n\t\tif (bytesperline > remain)\n\t\t\tlencopy = remain;\n\t\telse\n\t\t\tlencopy = bytesperline;\n\n\t\tif ((char *)startwrite + lencopy > (char *)outp +\n\t\t    buf->length) {\n\t\t\tau0828_isocdbg(\"Overflow %zi bytes past buf end (2)\\n\",\n\t\t\t\t       ((char *)startwrite + lencopy) -\n\t\t\t\t       ((char *)outp + buf->length));\n\t\t\tlencopy = remain = (char *)outp + buf->length -\n\t\t\t\t\t   (char *)startwrite;\n\t\t}\n\t\tif (lencopy <= 0)\n\t\t\tbreak;\n\n\t\tmemcpy(startwrite, startread, lencopy);\n\n\t\tremain -= lencopy;\n\t}\n\n\tif (offset > 1440) {\n\t\t \n\t\tif (outp[0] < 0x60 && outp[1440] < 0x60)\n\t\t\tdev->greenscreen_detected = 1;\n\t}\n\n\tdma_q->pos += len;\n}\n\n \nstatic inline void get_next_buf(struct au0828_dmaqueue *dma_q,\n\t\t\t\tstruct au0828_buffer **buf)\n{\n\tstruct au0828_dev *dev = container_of(dma_q, struct au0828_dev, vidq);\n\n\tif (list_empty(&dma_q->active)) {\n\t\tau0828_isocdbg(\"No active queue to serve\\n\");\n\t\tdev->isoc_ctl.buf = NULL;\n\t\t*buf = NULL;\n\t\treturn;\n\t}\n\n\t \n\t*buf = list_entry(dma_q->active.next, struct au0828_buffer, list);\n\t \n\tlist_del(&(*buf)->list);\n\tdma_q->pos = 0;\n\t(*buf)->vb_buf = (*buf)->mem;\n\tdev->isoc_ctl.buf = *buf;\n\n\treturn;\n}\n\nstatic void au0828_copy_vbi(struct au0828_dev *dev,\n\t\t\t      struct au0828_dmaqueue  *dma_q,\n\t\t\t      struct au0828_buffer *buf,\n\t\t\t      unsigned char *p,\n\t\t\t      unsigned char *outp, unsigned long len)\n{\n\tunsigned char *startwrite, *startread;\n\tint bytesperline;\n\tint i, j = 0;\n\n\tif (dev == NULL) {\n\t\tau0828_isocdbg(\"dev is null\\n\");\n\t\treturn;\n\t}\n\n\tif (dma_q == NULL) {\n\t\tau0828_isocdbg(\"dma_q is null\\n\");\n\t\treturn;\n\t}\n\tif (buf == NULL)\n\t\treturn;\n\tif (p == NULL) {\n\t\tau0828_isocdbg(\"p is null\\n\");\n\t\treturn;\n\t}\n\tif (outp == NULL) {\n\t\tau0828_isocdbg(\"outp is null\\n\");\n\t\treturn;\n\t}\n\n\tbytesperline = dev->vbi_width;\n\n\tif (dma_q->pos + len > buf->length)\n\t\tlen = buf->length - dma_q->pos;\n\n\tstartread = p;\n\tstartwrite = outp + (dma_q->pos / 2);\n\n\t \n\tif (buf->top_field == 0)\n\t\tstartwrite += bytesperline * dev->vbi_height;\n\n\tfor (i = 0; i < len; i += 2)\n\t\tstartwrite[j++] = startread[i+1];\n\n\tdma_q->pos += len;\n}\n\n\n \nstatic inline void vbi_get_next_buf(struct au0828_dmaqueue *dma_q,\n\t\t\t\t    struct au0828_buffer **buf)\n{\n\tstruct au0828_dev *dev = container_of(dma_q, struct au0828_dev, vbiq);\n\n\tif (list_empty(&dma_q->active)) {\n\t\tau0828_isocdbg(\"No active queue to serve\\n\");\n\t\tdev->isoc_ctl.vbi_buf = NULL;\n\t\t*buf = NULL;\n\t\treturn;\n\t}\n\n\t \n\t*buf = list_entry(dma_q->active.next, struct au0828_buffer, list);\n\t \n\tlist_del(&(*buf)->list);\n\tdma_q->pos = 0;\n\t(*buf)->vb_buf = (*buf)->mem;\n\tdev->isoc_ctl.vbi_buf = *buf;\n\treturn;\n}\n\n \nstatic inline int au0828_isoc_copy(struct au0828_dev *dev, struct urb *urb)\n{\n\tstruct au0828_buffer    *buf;\n\tstruct au0828_buffer    *vbi_buf;\n\tstruct au0828_dmaqueue  *dma_q = urb->context;\n\tstruct au0828_dmaqueue  *vbi_dma_q = &dev->vbiq;\n\tunsigned char *outp = NULL;\n\tunsigned char *vbioutp = NULL;\n\tint i, len = 0, rc = 1;\n\tunsigned char *p;\n\tunsigned char fbyte;\n\tunsigned int vbi_field_size;\n\tunsigned int remain, lencopy;\n\n\tif (!dev)\n\t\treturn 0;\n\n\tif (test_bit(DEV_DISCONNECTED, &dev->dev_state) ||\n\t    test_bit(DEV_MISCONFIGURED, &dev->dev_state))\n\t\treturn 0;\n\n\tif (urb->status < 0) {\n\t\tprint_err_status(dev, -1, urb->status);\n\t\tif (urb->status == -ENOENT)\n\t\t\treturn 0;\n\t}\n\n\tbuf = dev->isoc_ctl.buf;\n\tif (buf != NULL)\n\t\toutp = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\n\n\tvbi_buf = dev->isoc_ctl.vbi_buf;\n\tif (vbi_buf != NULL)\n\t\tvbioutp = vb2_plane_vaddr(&vbi_buf->vb.vb2_buf, 0);\n\n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\tint status = urb->iso_frame_desc[i].status;\n\n\t\tif (status < 0) {\n\t\t\tprint_err_status(dev, i, status);\n\t\t\tif (urb->iso_frame_desc[i].status != -EPROTO)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (urb->iso_frame_desc[i].actual_length <= 0)\n\t\t\tcontinue;\n\n\t\tif (urb->iso_frame_desc[i].actual_length >\n\t\t\t\t\t\tdev->max_pkt_size) {\n\t\t\tau0828_isocdbg(\"packet bigger than packet size\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tp = urb->transfer_buffer + urb->iso_frame_desc[i].offset;\n\t\tfbyte = p[0];\n\t\tlen = urb->iso_frame_desc[i].actual_length - 4;\n\t\tp += 4;\n\n\t\tif (fbyte & 0x80) {\n\t\t\tlen -= 4;\n\t\t\tp += 4;\n\t\t\tau0828_isocdbg(\"Video frame %s\\n\",\n\t\t\t\t       (fbyte & 0x40) ? \"odd\" : \"even\");\n\t\t\tif (fbyte & 0x40) {\n\t\t\t\t \n\t\t\t\tif (vbi_buf != NULL)\n\t\t\t\t\tbuffer_filled(dev, vbi_dma_q, vbi_buf);\n\t\t\t\tvbi_get_next_buf(vbi_dma_q, &vbi_buf);\n\t\t\t\tif (vbi_buf == NULL)\n\t\t\t\t\tvbioutp = NULL;\n\t\t\t\telse\n\t\t\t\t\tvbioutp = vb2_plane_vaddr(\n\t\t\t\t\t\t&vbi_buf->vb.vb2_buf, 0);\n\n\t\t\t\t \n\t\t\t\tif (buf != NULL)\n\t\t\t\t\tbuffer_filled(dev, dma_q, buf);\n\t\t\t\tget_next_buf(dma_q, &buf);\n\t\t\t\tif (buf == NULL)\n\t\t\t\t\toutp = NULL;\n\t\t\t\telse\n\t\t\t\t\toutp = vb2_plane_vaddr(\n\t\t\t\t\t\t&buf->vb.vb2_buf, 0);\n\n\t\t\t\t \n\t\t\t\tif (dev->vid_timeout_running)\n\t\t\t\t\tmod_timer(&dev->vid_timeout,\n\t\t\t\t\t\t  jiffies + (HZ / 10));\n\t\t\t\tif (dev->vbi_timeout_running)\n\t\t\t\t\tmod_timer(&dev->vbi_timeout,\n\t\t\t\t\t\t  jiffies + (HZ / 10));\n\t\t\t}\n\n\t\t\tif (buf != NULL) {\n\t\t\t\tif (fbyte & 0x40)\n\t\t\t\t\tbuf->top_field = 1;\n\t\t\t\telse\n\t\t\t\t\tbuf->top_field = 0;\n\t\t\t}\n\n\t\t\tif (vbi_buf != NULL) {\n\t\t\t\tif (fbyte & 0x40)\n\t\t\t\t\tvbi_buf->top_field = 1;\n\t\t\t\telse\n\t\t\t\t\tvbi_buf->top_field = 0;\n\t\t\t}\n\n\t\t\tdev->vbi_read = 0;\n\t\t\tvbi_dma_q->pos = 0;\n\t\t\tdma_q->pos = 0;\n\t\t}\n\n\t\tvbi_field_size = dev->vbi_width * dev->vbi_height * 2;\n\t\tif (dev->vbi_read < vbi_field_size) {\n\t\t\tremain  = vbi_field_size - dev->vbi_read;\n\t\t\tif (len < remain)\n\t\t\t\tlencopy = len;\n\t\t\telse\n\t\t\t\tlencopy = remain;\n\n\t\t\tif (vbi_buf != NULL)\n\t\t\t\tau0828_copy_vbi(dev, vbi_dma_q, vbi_buf, p,\n\t\t\t\t\t\tvbioutp, len);\n\n\t\t\tlen -= lencopy;\n\t\t\tp += lencopy;\n\t\t\tdev->vbi_read += lencopy;\n\t\t}\n\n\t\tif (dev->vbi_read >= vbi_field_size && buf != NULL)\n\t\t\tau0828_copy_video(dev, dma_q, buf, p, outp, len);\n\t}\n\treturn rc;\n}\n\nvoid au0828_usb_v4l2_media_release(struct au0828_dev *dev)\n{\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tint i;\n\n\tfor (i = 0; i < AU0828_MAX_INPUT; i++) {\n\t\tif (AUVI_INPUT(i).type == AU0828_VMUX_UNDEFINED)\n\t\t\treturn;\n\t\tmedia_device_unregister_entity(&dev->input_ent[i]);\n\t}\n#endif\n}\n\nstatic void au0828_usb_v4l2_release(struct v4l2_device *v4l2_dev)\n{\n\tstruct au0828_dev *dev =\n\t\tcontainer_of(v4l2_dev, struct au0828_dev, v4l2_dev);\n\n\tv4l2_ctrl_handler_free(&dev->v4l2_ctrl_hdl);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tau0828_usb_v4l2_media_release(dev);\n\tau0828_usb_release(dev);\n}\n\nint au0828_v4l2_device_register(struct usb_interface *interface,\n\t\t\t\tstruct au0828_dev *dev)\n{\n\tint retval;\n\n\tif (AUVI_INPUT(0).type == AU0828_VMUX_UNDEFINED)\n\t\treturn 0;\n\n\t \n#ifdef CONFIG_MEDIA_CONTROLLER\n\tdev->v4l2_dev.mdev = dev->media_dev;\n#endif\n\tretval = v4l2_device_register(&interface->dev, &dev->v4l2_dev);\n\tif (retval) {\n\t\tpr_err(\"%s() v4l2_device_register failed\\n\",\n\t\t       __func__);\n\t\treturn retval;\n\t}\n\n\tdev->v4l2_dev.release = au0828_usb_v4l2_release;\n\n\t \n\tretval = v4l2_ctrl_handler_init(&dev->v4l2_ctrl_hdl, 4);\n\tif (retval) {\n\t\tpr_err(\"%s() v4l2_ctrl_handler_init failed\\n\",\n\t\t       __func__);\n\t\treturn retval;\n\t}\n\tdev->v4l2_dev.ctrl_handler = &dev->v4l2_ctrl_hdl;\n\n\treturn 0;\n}\n\nstatic int queue_setup(struct vb2_queue *vq,\n\t\t       unsigned int *nbuffers, unsigned int *nplanes,\n\t\t       unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct au0828_dev *dev = vb2_get_drv_priv(vq);\n\tunsigned long size = dev->height * dev->bytesperline;\n\n\tif (*nplanes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\t*nplanes = 1;\n\tsizes[0] = size;\n\treturn 0;\n}\n\nstatic int\nbuffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct au0828_buffer *buf = container_of(vbuf,\n\t\t\t\tstruct au0828_buffer, vb);\n\tstruct au0828_dev    *dev = vb2_get_drv_priv(vb->vb2_queue);\n\n\tbuf->length = dev->height * dev->bytesperline;\n\n\tif (vb2_plane_size(vb, 0) < buf->length) {\n\t\tpr_err(\"%s data will not fit into plane (%lu < %lu)\\n\",\n\t\t\t__func__, vb2_plane_size(vb, 0), buf->length);\n\t\treturn -EINVAL;\n\t}\n\tvb2_set_plane_payload(&buf->vb.vb2_buf, 0, buf->length);\n\treturn 0;\n}\n\nstatic void\nbuffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct au0828_buffer    *buf     = container_of(vbuf,\n\t\t\t\t\t\t\tstruct au0828_buffer,\n\t\t\t\t\t\t\tvb);\n\tstruct au0828_dev       *dev     = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct au0828_dmaqueue  *vidq    = &dev->vidq;\n\tunsigned long flags = 0;\n\n\tbuf->mem = vb2_plane_vaddr(vb, 0);\n\tbuf->length = vb2_plane_size(vb, 0);\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\tlist_add_tail(&buf->list, &vidq->active);\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nstatic int au0828_i2s_init(struct au0828_dev *dev)\n{\n\t \n\tau0828_writereg(dev, AU0828_AUDIOCTRL_50C, 0x01);\n\treturn 0;\n}\n\n \nstatic int au0828_analog_stream_enable(struct au0828_dev *d)\n{\n\tstruct usb_interface *iface;\n\tint ret, h, w;\n\n\tdprintk(1, \"au0828_analog_stream_enable called\\n\");\n\n\tif (test_bit(DEV_DISCONNECTED, &d->dev_state))\n\t\treturn -ENODEV;\n\n\tiface = usb_ifnum_to_if(d->usbdev, 0);\n\tif (iface && iface->cur_altsetting->desc.bAlternateSetting != 5) {\n\t\tdprintk(1, \"Changing intf#0 to alt 5\\n\");\n\t\t \n\t\tret = usb_set_interface(d->usbdev, 0, 5);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"Au0828 can't set alt setting to 5!\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\th = d->height / 2 + 2;\n\tw = d->width * 2;\n\n\tau0828_writereg(d, AU0828_SENSORCTRL_VBI_103, 0x00);\n\tau0828_writereg(d, 0x106, 0x00);\n\t \n\tau0828_writereg(d, 0x110, 0x00);\n\tau0828_writereg(d, 0x111, 0x00);\n\tau0828_writereg(d, 0x114, w & 0xff);\n\tau0828_writereg(d, 0x115, w >> 8);\n\t \n\tau0828_writereg(d, 0x112, 0x00);\n\tau0828_writereg(d, 0x113, 0x00);\n\tau0828_writereg(d, 0x116, h & 0xff);\n\tau0828_writereg(d, 0x117, h >> 8);\n\tau0828_writereg(d, AU0828_SENSORCTRL_100, 0xb3);\n\n\treturn 0;\n}\n\nstatic int au0828_analog_stream_disable(struct au0828_dev *d)\n{\n\tdprintk(1, \"au0828_analog_stream_disable called\\n\");\n\tau0828_writereg(d, AU0828_SENSORCTRL_100, 0x0);\n\treturn 0;\n}\n\nstatic void au0828_analog_stream_reset(struct au0828_dev *dev)\n{\n\tdprintk(1, \"au0828_analog_stream_reset called\\n\");\n\tau0828_writereg(dev, AU0828_SENSORCTRL_100, 0x0);\n\tmdelay(30);\n\tau0828_writereg(dev, AU0828_SENSORCTRL_100, 0xb3);\n}\n\n \nstatic int au0828_stream_interrupt(struct au0828_dev *dev)\n{\n\tdev->stream_state = STREAM_INTERRUPT;\n\tif (test_bit(DEV_DISCONNECTED, &dev->dev_state))\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nint au0828_start_analog_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct au0828_dev *dev = vb2_get_drv_priv(vq);\n\tint rc = 0;\n\n\tdprintk(1, \"au0828_start_analog_streaming called %d\\n\",\n\t\tdev->streaming_users);\n\n\tif (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\tdev->frame_count = 0;\n\telse\n\t\tdev->vbi_frame_count = 0;\n\n\tif (dev->streaming_users == 0) {\n\t\t \n\t\tau0828_i2s_init(dev);\n\t\trc = au0828_init_isoc(dev, AU0828_ISO_PACKETS_PER_URB,\n\t\t\t\t   AU0828_MAX_ISO_BUFS, dev->max_pkt_size,\n\t\t\t\t   au0828_isoc_copy);\n\t\tif (rc < 0) {\n\t\t\tpr_info(\"au0828_init_isoc failed\\n\");\n\t\t\treturn rc;\n\t\t}\n\n\t\tv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_stream, 1);\n\n\t\tif (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\t\tdev->vid_timeout_running = 1;\n\t\t\tmod_timer(&dev->vid_timeout, jiffies + (HZ / 10));\n\t\t} else if (vq->type == V4L2_BUF_TYPE_VBI_CAPTURE) {\n\t\t\tdev->vbi_timeout_running = 1;\n\t\t\tmod_timer(&dev->vbi_timeout, jiffies + (HZ / 10));\n\t\t}\n\t}\n\tdev->streaming_users++;\n\treturn rc;\n}\n\nstatic void au0828_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct au0828_dev *dev = vb2_get_drv_priv(vq);\n\tstruct au0828_dmaqueue *vidq = &dev->vidq;\n\tunsigned long flags = 0;\n\n\tdprintk(1, \"au0828_stop_streaming called %d\\n\", dev->streaming_users);\n\n\tif (dev->streaming_users-- == 1) {\n\t\tau0828_uninit_isoc(dev);\n\t\tv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_stream, 0);\n\t}\n\n\tdev->vid_timeout_running = 0;\n\tdel_timer_sync(&dev->vid_timeout);\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\tif (dev->isoc_ctl.buf != NULL) {\n\t\tvb2_buffer_done(&dev->isoc_ctl.buf->vb.vb2_buf,\n\t\t\t\tVB2_BUF_STATE_ERROR);\n\t\tdev->isoc_ctl.buf = NULL;\n\t}\n\twhile (!list_empty(&vidq->active)) {\n\t\tstruct au0828_buffer *buf;\n\n\t\tbuf = list_entry(vidq->active.next, struct au0828_buffer, list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\tlist_del(&buf->list);\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nvoid au0828_stop_vbi_streaming(struct vb2_queue *vq)\n{\n\tstruct au0828_dev *dev = vb2_get_drv_priv(vq);\n\tstruct au0828_dmaqueue *vbiq = &dev->vbiq;\n\tunsigned long flags = 0;\n\n\tdprintk(1, \"au0828_stop_vbi_streaming called %d\\n\",\n\t\tdev->streaming_users);\n\n\tif (dev->streaming_users-- == 1) {\n\t\tau0828_uninit_isoc(dev);\n\t\tv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_stream, 0);\n\t}\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\tif (dev->isoc_ctl.vbi_buf != NULL) {\n\t\tvb2_buffer_done(&dev->isoc_ctl.vbi_buf->vb.vb2_buf,\n\t\t\t\tVB2_BUF_STATE_ERROR);\n\t\tdev->isoc_ctl.vbi_buf = NULL;\n\t}\n\twhile (!list_empty(&vbiq->active)) {\n\t\tstruct au0828_buffer *buf;\n\n\t\tbuf = list_entry(vbiq->active.next, struct au0828_buffer, list);\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\n\tdev->vbi_timeout_running = 0;\n\tdel_timer_sync(&dev->vbi_timeout);\n}\n\nstatic const struct vb2_ops au0828_video_qops = {\n\t.queue_setup     = queue_setup,\n\t.buf_prepare     = buffer_prepare,\n\t.buf_queue       = buffer_queue,\n\t.prepare_streaming = v4l_vb2q_enable_media_source,\n\t.start_streaming = au0828_start_analog_streaming,\n\t.stop_streaming  = au0828_stop_streaming,\n\t.wait_prepare    = vb2_ops_wait_prepare,\n\t.wait_finish     = vb2_ops_wait_finish,\n};\n\n \n \nint au0828_analog_unregister(struct au0828_dev *dev)\n{\n\tdprintk(1, \"au0828_analog_unregister called\\n\");\n\n\t \n\tif (AUVI_INPUT(0).type == AU0828_VMUX_UNDEFINED)\n\t\treturn 0;\n\n\tmutex_lock(&au0828_sysfs_lock);\n\tvb2_video_unregister_device(&dev->vdev);\n\tvb2_video_unregister_device(&dev->vbi_dev);\n\tmutex_unlock(&au0828_sysfs_lock);\n\n\tv4l2_device_disconnect(&dev->v4l2_dev);\n\tv4l2_device_put(&dev->v4l2_dev);\n\n\treturn 1;\n}\n\n \nstatic void au0828_vid_buffer_timeout(struct timer_list *t)\n{\n\tstruct au0828_dev *dev = from_timer(dev, t, vid_timeout);\n\tstruct au0828_dmaqueue *dma_q = &dev->vidq;\n\tstruct au0828_buffer *buf;\n\tunsigned char *vid_data;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\n\tbuf = dev->isoc_ctl.buf;\n\tif (buf != NULL) {\n\t\tvid_data = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\n\t\tmemset(vid_data, 0x00, buf->length);  \n\t\tbuffer_filled(dev, dma_q, buf);\n\t}\n\tget_next_buf(dma_q, &buf);\n\n\tif (dev->vid_timeout_running == 1)\n\t\tmod_timer(&dev->vid_timeout, jiffies + (HZ / 10));\n\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nstatic void au0828_vbi_buffer_timeout(struct timer_list *t)\n{\n\tstruct au0828_dev *dev = from_timer(dev, t, vbi_timeout);\n\tstruct au0828_dmaqueue *dma_q = &dev->vbiq;\n\tstruct au0828_buffer *buf;\n\tunsigned char *vbi_data;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\n\tbuf = dev->isoc_ctl.vbi_buf;\n\tif (buf != NULL) {\n\t\tvbi_data = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\n\t\tmemset(vbi_data, 0x00, buf->length);\n\t\tbuffer_filled(dev, dma_q, buf);\n\t}\n\tvbi_get_next_buf(dma_q, &buf);\n\n\tif (dev->vbi_timeout_running == 1)\n\t\tmod_timer(&dev->vbi_timeout, jiffies + (HZ / 10));\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nstatic int au0828_v4l2_open(struct file *filp)\n{\n\tstruct au0828_dev *dev = video_drvdata(filp);\n\tint ret;\n\n\tdprintk(1,\n\t\t\"%s called std_set %d dev_state %ld stream users %d users %d\\n\",\n\t\t__func__, dev->std_set_in_tuner_core, dev->dev_state,\n\t\tdev->streaming_users, dev->users);\n\n\tif (mutex_lock_interruptible(&dev->lock))\n\t\treturn -ERESTARTSYS;\n\n\tret = v4l2_fh_open(filp);\n\tif (ret) {\n\t\tau0828_isocdbg(\"%s: v4l2_fh_open() returned error %d\\n\",\n\t\t\t\t__func__, ret);\n\t\tmutex_unlock(&dev->lock);\n\t\treturn ret;\n\t}\n\n\tif (dev->users == 0) {\n\t\tau0828_analog_stream_enable(dev);\n\t\tau0828_analog_stream_reset(dev);\n\t\tdev->stream_state = STREAM_OFF;\n\t\tset_bit(DEV_INITIALIZED, &dev->dev_state);\n\t}\n\tdev->users++;\n\tmutex_unlock(&dev->lock);\n\treturn ret;\n}\n\nstatic int au0828_v4l2_close(struct file *filp)\n{\n\tint ret;\n\tstruct au0828_dev *dev = video_drvdata(filp);\n\tstruct video_device *vdev = video_devdata(filp);\n\n\tdprintk(1,\n\t\t\"%s called std_set %d dev_state %ld stream users %d users %d\\n\",\n\t\t__func__, dev->std_set_in_tuner_core, dev->dev_state,\n\t\tdev->streaming_users, dev->users);\n\n\tmutex_lock(&dev->lock);\n\tif (vdev->vfl_type == VFL_TYPE_VIDEO && dev->vid_timeout_running) {\n\t\t \n\t\tdev->vid_timeout_running = 0;\n\t\tdel_timer_sync(&dev->vid_timeout);\n\t} else if (vdev->vfl_type == VFL_TYPE_VBI &&\n\t\t\tdev->vbi_timeout_running) {\n\t\t \n\t\tdev->vbi_timeout_running = 0;\n\t\tdel_timer_sync(&dev->vbi_timeout);\n\t}\n\n\tif (test_bit(DEV_DISCONNECTED, &dev->dev_state))\n\t\tgoto end;\n\n\tif (dev->users == 1) {\n\t\t \n\t\tret = v4l_enable_media_source(vdev);\n\t\tif (ret == 0)\n\t\t\tv4l2_device_call_all(&dev->v4l2_dev, 0, tuner,\n\t\t\t\t\t     standby);\n\t\tdev->std_set_in_tuner_core = 0;\n\n\t\t \n\t\tret = usb_set_interface(dev->usbdev, 0, 0);\n\t\tif (ret < 0)\n\t\t\tpr_info(\"Au0828 can't set alternate to 0!\\n\");\n\t}\nend:\n\t_vb2_fop_release(filp, NULL);\n\tdev->users--;\n\tmutex_unlock(&dev->lock);\n\treturn 0;\n}\n\n \nstatic void au0828_init_tuner(struct au0828_dev *dev)\n{\n\tstruct v4l2_frequency f = {\n\t\t.frequency = dev->ctrl_freq,\n\t\t.type = V4L2_TUNER_ANALOG_TV,\n\t};\n\n\tdprintk(1, \"%s called std_set %d dev_state %ld\\n\", __func__,\n\t\tdev->std_set_in_tuner_core, dev->dev_state);\n\n\tif (dev->std_set_in_tuner_core)\n\t\treturn;\n\tdev->std_set_in_tuner_core = 1;\n\ti2c_gate_ctrl(dev, 1);\n\t \n\tv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_std, dev->std);\n\tv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_frequency, &f);\n\ti2c_gate_ctrl(dev, 0);\n}\n\nstatic int au0828_set_format(struct au0828_dev *dev, unsigned int cmd,\n\t\t\t     struct v4l2_format *format)\n{\n\tint ret;\n\tint width = format->fmt.pix.width;\n\tint height = format->fmt.pix.height;\n\n\t \n\tif (format->fmt.pix.pixelformat != V4L2_PIX_FMT_UYVY)\n\t\treturn -EINVAL;\n\n\t \n\tif (width != 720)\n\t\twidth = 720;\n\tif (height != 480)\n\t\theight = 480;\n\n\tformat->fmt.pix.width = width;\n\tformat->fmt.pix.height = height;\n\tformat->fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;\n\tformat->fmt.pix.bytesperline = width * 2;\n\tformat->fmt.pix.sizeimage = width * height * 2;\n\tformat->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tformat->fmt.pix.field = V4L2_FIELD_INTERLACED;\n\n\tif (cmd == VIDIOC_TRY_FMT)\n\t\treturn 0;\n\n\t \n\tdev->width = width;\n\tdev->height = height;\n\tdev->frame_size = width * height * 2;\n\tdev->field_size = width * height;\n\tdev->bytesperline = width * 2;\n\n\tif (dev->stream_state == STREAM_ON) {\n\t\tdprintk(1, \"VIDIOC_SET_FMT: interrupting stream!\\n\");\n\t\tret = au0828_stream_interrupt(dev);\n\t\tif (ret != 0) {\n\t\t\tdprintk(1, \"error interrupting video stream!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tau0828_analog_stream_enable(dev);\n\n\treturn 0;\n}\n\nstatic int vidioc_querycap(struct file *file, void  *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct au0828_dev *dev = video_drvdata(file);\n\n\tdprintk(1, \"%s called std_set %d dev_state %ld\\n\", __func__,\n\t\tdev->std_set_in_tuner_core, dev->dev_state);\n\n\tstrscpy(cap->driver, \"au0828\", sizeof(cap->driver));\n\tstrscpy(cap->card, dev->board.name, sizeof(cap->card));\n\tusb_make_path(dev->usbdev, cap->bus_info, sizeof(cap->bus_info));\n\n\t \n\tcap->capabilities =\n\t\tV4L2_CAP_AUDIO | V4L2_CAP_READWRITE | V4L2_CAP_STREAMING |\n\t\tV4L2_CAP_TUNER | V4L2_CAP_VBI_CAPTURE | V4L2_CAP_VIDEO_CAPTURE |\n\t\tV4L2_CAP_DEVICE_CAPS;\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,\n\t\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\tif (f->index)\n\t\treturn -EINVAL;\n\n\tdprintk(1, \"%s called\\n\", __func__);\n\n\tf->pixelformat = V4L2_PIX_FMT_UYVY;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct au0828_dev *dev = video_drvdata(file);\n\n\tdprintk(1, \"%s called std_set %d dev_state %ld\\n\", __func__,\n\t\tdev->std_set_in_tuner_core, dev->dev_state);\n\n\tf->fmt.pix.width = dev->width;\n\tf->fmt.pix.height = dev->height;\n\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;\n\tf->fmt.pix.bytesperline = dev->bytesperline;\n\tf->fmt.pix.sizeimage = dev->frame_size;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;  \n\tf->fmt.pix.field = V4L2_FIELD_INTERLACED;\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct au0828_dev *dev = video_drvdata(file);\n\n\tdprintk(1, \"%s called std_set %d dev_state %ld\\n\", __func__,\n\t\tdev->std_set_in_tuner_core, dev->dev_state);\n\n\treturn au0828_set_format(dev, VIDIOC_TRY_FMT, f);\n}\n\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct au0828_dev *dev = video_drvdata(file);\n\tint rc;\n\n\tdprintk(1, \"%s called std_set %d dev_state %ld\\n\", __func__,\n\t\tdev->std_set_in_tuner_core, dev->dev_state);\n\n\trc = check_dev(dev);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (vb2_is_busy(&dev->vb_vidq)) {\n\t\tpr_info(\"%s queue busy\\n\", __func__);\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\trc = au0828_set_format(dev, VIDIOC_S_FMT, f);\nout:\n\treturn rc;\n}\n\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id norm)\n{\n\tstruct au0828_dev *dev = video_drvdata(file);\n\n\tdprintk(1, \"%s called std_set %d dev_state %ld\\n\", __func__,\n\t\tdev->std_set_in_tuner_core, dev->dev_state);\n\n\tif (norm == dev->std)\n\t\treturn 0;\n\n\tif (dev->streaming_users > 0)\n\t\treturn -EBUSY;\n\n\tdev->std = norm;\n\n\tau0828_init_tuner(dev);\n\n\ti2c_gate_ctrl(dev, 1);\n\n\t \n\n\tv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_std, norm);\n\n\ti2c_gate_ctrl(dev, 0);\n\n\treturn 0;\n}\n\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *norm)\n{\n\tstruct au0828_dev *dev = video_drvdata(file);\n\n\tdprintk(1, \"%s called std_set %d dev_state %ld\\n\", __func__,\n\t\tdev->std_set_in_tuner_core, dev->dev_state);\n\n\t*norm = dev->std;\n\treturn 0;\n}\n\nstatic int vidioc_enum_input(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_input *input)\n{\n\tstruct au0828_dev *dev = video_drvdata(file);\n\tunsigned int tmp;\n\n\tstatic const char *inames[] = {\n\t\t[AU0828_VMUX_UNDEFINED] = \"Undefined\",\n\t\t[AU0828_VMUX_COMPOSITE] = \"Composite\",\n\t\t[AU0828_VMUX_SVIDEO] = \"S-Video\",\n\t\t[AU0828_VMUX_CABLE] = \"Cable TV\",\n\t\t[AU0828_VMUX_TELEVISION] = \"Television\",\n\t\t[AU0828_VMUX_DVB] = \"DVB\",\n\t};\n\n\tdprintk(1, \"%s called std_set %d dev_state %ld\\n\", __func__,\n\t\tdev->std_set_in_tuner_core, dev->dev_state);\n\n\ttmp = input->index;\n\n\tif (tmp >= AU0828_MAX_INPUT)\n\t\treturn -EINVAL;\n\tif (AUVI_INPUT(tmp).type == 0)\n\t\treturn -EINVAL;\n\n\tinput->index = tmp;\n\tstrscpy(input->name, inames[AUVI_INPUT(tmp).type], sizeof(input->name));\n\tif ((AUVI_INPUT(tmp).type == AU0828_VMUX_TELEVISION) ||\n\t    (AUVI_INPUT(tmp).type == AU0828_VMUX_CABLE)) {\n\t\tinput->type |= V4L2_INPUT_TYPE_TUNER;\n\t\tinput->audioset = 1;\n\t} else {\n\t\tinput->type |= V4L2_INPUT_TYPE_CAMERA;\n\t\tinput->audioset = 2;\n\t}\n\n\tinput->std = dev->vdev.tvnorms;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct au0828_dev *dev = video_drvdata(file);\n\n\tdprintk(1, \"%s called std_set %d dev_state %ld\\n\", __func__,\n\t\tdev->std_set_in_tuner_core, dev->dev_state);\n\n\t*i = dev->ctrl_input;\n\treturn 0;\n}\n\nstatic void au0828_s_input(struct au0828_dev *dev, int index)\n{\n\tint i;\n\n\tdprintk(1, \"%s called std_set %d dev_state %ld\\n\", __func__,\n\t\tdev->std_set_in_tuner_core, dev->dev_state);\n\n\tswitch (AUVI_INPUT(index).type) {\n\tcase AU0828_VMUX_SVIDEO:\n\t\tdev->input_type = AU0828_VMUX_SVIDEO;\n\t\tdev->ctrl_ainput = 1;\n\t\tbreak;\n\tcase AU0828_VMUX_COMPOSITE:\n\t\tdev->input_type = AU0828_VMUX_COMPOSITE;\n\t\tdev->ctrl_ainput = 1;\n\t\tbreak;\n\tcase AU0828_VMUX_TELEVISION:\n\t\tdev->input_type = AU0828_VMUX_TELEVISION;\n\t\tdev->ctrl_ainput = 0;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(1, \"unknown input type set [%d]\\n\",\n\t\t\tAUVI_INPUT(index).type);\n\t\treturn;\n\t}\n\n\tdev->ctrl_input = index;\n\n\tv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_routing,\n\t\t\tAUVI_INPUT(index).vmux, 0, 0);\n\n\tfor (i = 0; i < AU0828_MAX_INPUT; i++) {\n\t\tint enable = 0;\n\t\tif (AUVI_INPUT(i).audio_setup == NULL)\n\t\t\tcontinue;\n\n\t\tif (i == index)\n\t\t\tenable = 1;\n\t\telse\n\t\t\tenable = 0;\n\t\tif (enable) {\n\t\t\t(AUVI_INPUT(i).audio_setup)(dev, enable);\n\t\t} else {\n\t\t\t \n\t\t\tif ((AUVI_INPUT(i).audio_setup) !=\n\t\t\t    ((AUVI_INPUT(index).audio_setup))) {\n\t\t\t\t(AUVI_INPUT(i).audio_setup)(dev, enable);\n\t\t\t}\n\t\t}\n\t}\n\n\tv4l2_device_call_all(&dev->v4l2_dev, 0, audio, s_routing,\n\t\t\tAUVI_INPUT(index).amux, 0, 0);\n}\n\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int index)\n{\n\tstruct au0828_dev *dev = video_drvdata(file);\n\tstruct video_device *vfd = video_devdata(file);\n\n\tdprintk(1, \"VIDIOC_S_INPUT in function %s, input=%d\\n\", __func__,\n\t\tindex);\n\tif (index >= AU0828_MAX_INPUT)\n\t\treturn -EINVAL;\n\tif (AUVI_INPUT(index).type == 0)\n\t\treturn -EINVAL;\n\n\tif (dev->ctrl_input == index)\n\t\treturn 0;\n\n\tau0828_s_input(dev, index);\n\n\t \n\tv4l_disable_media_source(vfd);\n\treturn v4l_enable_media_source(vfd);\n}\n\nstatic int vidioc_enumaudio(struct file *file, void *priv, struct v4l2_audio *a)\n{\n\tif (a->index > 1)\n\t\treturn -EINVAL;\n\n\tdprintk(1, \"%s called\\n\", __func__);\n\n\tif (a->index == 0)\n\t\tstrscpy(a->name, \"Television\", sizeof(a->name));\n\telse\n\t\tstrscpy(a->name, \"Line in\", sizeof(a->name));\n\n\ta->capability = V4L2_AUDCAP_STEREO;\n\treturn 0;\n}\n\nstatic int vidioc_g_audio(struct file *file, void *priv, struct v4l2_audio *a)\n{\n\tstruct au0828_dev *dev = video_drvdata(file);\n\n\tdprintk(1, \"%s called std_set %d dev_state %ld\\n\", __func__,\n\t\tdev->std_set_in_tuner_core, dev->dev_state);\n\n\ta->index = dev->ctrl_ainput;\n\tif (a->index == 0)\n\t\tstrscpy(a->name, \"Television\", sizeof(a->name));\n\telse\n\t\tstrscpy(a->name, \"Line in\", sizeof(a->name));\n\n\ta->capability = V4L2_AUDCAP_STEREO;\n\treturn 0;\n}\n\nstatic int vidioc_s_audio(struct file *file, void *priv, const struct v4l2_audio *a)\n{\n\tstruct au0828_dev *dev = video_drvdata(file);\n\n\tif (a->index != dev->ctrl_ainput)\n\t\treturn -EINVAL;\n\n\tdprintk(1, \"%s called std_set %d dev_state %ld\\n\", __func__,\n\t\tdev->std_set_in_tuner_core, dev->dev_state);\n\treturn 0;\n}\n\nstatic int vidioc_g_tuner(struct file *file, void *priv, struct v4l2_tuner *t)\n{\n\tstruct au0828_dev *dev = video_drvdata(file);\n\tstruct video_device *vfd = video_devdata(file);\n\tint ret;\n\n\tif (t->index != 0)\n\t\treturn -EINVAL;\n\n\tret = v4l_enable_media_source(vfd);\n\tif (ret)\n\t\treturn ret;\n\n\tdprintk(1, \"%s called std_set %d dev_state %ld\\n\", __func__,\n\t\tdev->std_set_in_tuner_core, dev->dev_state);\n\n\tstrscpy(t->name, \"Auvitek tuner\", sizeof(t->name));\n\n\tau0828_init_tuner(dev);\n\ti2c_gate_ctrl(dev, 1);\n\tv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, g_tuner, t);\n\ti2c_gate_ctrl(dev, 0);\n\treturn 0;\n}\n\nstatic int vidioc_s_tuner(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_tuner *t)\n{\n\tstruct au0828_dev *dev = video_drvdata(file);\n\n\tif (t->index != 0)\n\t\treturn -EINVAL;\n\n\tdprintk(1, \"%s called std_set %d dev_state %ld\\n\", __func__,\n\t\tdev->std_set_in_tuner_core, dev->dev_state);\n\n\tau0828_init_tuner(dev);\n\ti2c_gate_ctrl(dev, 1);\n\tv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_tuner, t);\n\ti2c_gate_ctrl(dev, 0);\n\n\tdprintk(1, \"VIDIOC_S_TUNER: signal = %x, afc = %x\\n\", t->signal,\n\t\tt->afc);\n\n\treturn 0;\n\n}\n\nstatic int vidioc_g_frequency(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_frequency *freq)\n{\n\tstruct au0828_dev *dev = video_drvdata(file);\n\n\tif (freq->tuner != 0)\n\t\treturn -EINVAL;\n\tdprintk(1, \"%s called std_set %d dev_state %ld\\n\", __func__,\n\t\tdev->std_set_in_tuner_core, dev->dev_state);\n\tfreq->frequency = dev->ctrl_freq;\n\treturn 0;\n}\n\nstatic int vidioc_s_frequency(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_frequency *freq)\n{\n\tstruct au0828_dev *dev = video_drvdata(file);\n\tstruct v4l2_frequency new_freq = *freq;\n\n\tif (freq->tuner != 0)\n\t\treturn -EINVAL;\n\n\tdprintk(1, \"%s called std_set %d dev_state %ld\\n\", __func__,\n\t\tdev->std_set_in_tuner_core, dev->dev_state);\n\n\tau0828_init_tuner(dev);\n\ti2c_gate_ctrl(dev, 1);\n\n\tv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_frequency, freq);\n\t \n\tv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, g_frequency, &new_freq);\n\tdev->ctrl_freq = new_freq.frequency;\n\n\ti2c_gate_ctrl(dev, 0);\n\n\tau0828_analog_stream_reset(dev);\n\n\treturn 0;\n}\n\n\n \n\nstatic int vidioc_g_fmt_vbi_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *format)\n{\n\tstruct au0828_dev *dev = video_drvdata(file);\n\n\tdprintk(1, \"%s called std_set %d dev_state %ld\\n\", __func__,\n\t\tdev->std_set_in_tuner_core, dev->dev_state);\n\n\tformat->fmt.vbi.samples_per_line = dev->vbi_width;\n\tformat->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;\n\tformat->fmt.vbi.offset = 0;\n\tformat->fmt.vbi.flags = 0;\n\tformat->fmt.vbi.sampling_rate = 6750000 * 4 / 2;\n\n\tformat->fmt.vbi.count[0] = dev->vbi_height;\n\tformat->fmt.vbi.count[1] = dev->vbi_height;\n\tformat->fmt.vbi.start[0] = 21;\n\tformat->fmt.vbi.start[1] = 284;\n\tmemset(format->fmt.vbi.reserved, 0, sizeof(format->fmt.vbi.reserved));\n\n\treturn 0;\n}\n\nstatic int vidioc_g_pixelaspect(struct file *file, void *priv,\n\t\t\t\tint type, struct v4l2_fract *f)\n{\n\tstruct au0828_dev *dev = video_drvdata(file);\n\n\tif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tdprintk(1, \"%s called std_set %d dev_state %ld\\n\", __func__,\n\t\tdev->std_set_in_tuner_core, dev->dev_state);\n\n\tf->numerator = 54;\n\tf->denominator = 59;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_selection(struct file *file, void *priv,\n\t\t\t      struct v4l2_selection *s)\n{\n\tstruct au0828_dev *dev = video_drvdata(file);\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = dev->width;\n\t\ts->r.height = dev->height;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int vidioc_g_register(struct file *file, void *priv,\n\t\t\t     struct v4l2_dbg_register *reg)\n{\n\tstruct au0828_dev *dev = video_drvdata(file);\n\n\tdprintk(1, \"%s called std_set %d dev_state %ld\\n\", __func__,\n\t\tdev->std_set_in_tuner_core, dev->dev_state);\n\n\treg->val = au0828_read(dev, reg->reg);\n\treg->size = 1;\n\treturn 0;\n}\n\nstatic int vidioc_s_register(struct file *file, void *priv,\n\t\t\t     const struct v4l2_dbg_register *reg)\n{\n\tstruct au0828_dev *dev = video_drvdata(file);\n\n\tdprintk(1, \"%s called std_set %d dev_state %ld\\n\", __func__,\n\t\tdev->std_set_in_tuner_core, dev->dev_state);\n\n\treturn au0828_writereg(dev, reg->reg, reg->val);\n}\n#endif\n\nstatic int vidioc_log_status(struct file *file, void *fh)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tdprintk(1, \"%s called\\n\", __func__);\n\n\tv4l2_ctrl_log_status(file, fh);\n\tv4l2_device_call_all(vdev->v4l2_dev, 0, core, log_status);\n\treturn 0;\n}\n\nvoid au0828_v4l2_suspend(struct au0828_dev *dev)\n{\n\tstruct urb *urb;\n\tint i;\n\n\tpr_info(\"stopping V4L2\\n\");\n\n\tif (dev->stream_state == STREAM_ON) {\n\t\tpr_info(\"stopping V4L2 active URBs\\n\");\n\t\tau0828_analog_stream_disable(dev);\n\t\t \n\t\tfor (i = 0; i < dev->isoc_ctl.num_bufs; i++) {\n\t\t\turb = dev->isoc_ctl.urb[i];\n\t\t\tif (urb) {\n\t\t\t\tif (!irqs_disabled())\n\t\t\t\t\tusb_kill_urb(urb);\n\t\t\t\telse\n\t\t\t\t\tusb_unlink_urb(urb);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dev->vid_timeout_running)\n\t\tdel_timer_sync(&dev->vid_timeout);\n\tif (dev->vbi_timeout_running)\n\t\tdel_timer_sync(&dev->vbi_timeout);\n}\n\nvoid au0828_v4l2_resume(struct au0828_dev *dev)\n{\n\tint i, rc;\n\n\tpr_info(\"restarting V4L2\\n\");\n\n\tif (dev->stream_state == STREAM_ON) {\n\t\tau0828_stream_interrupt(dev);\n\t\tau0828_init_tuner(dev);\n\t}\n\n\tif (dev->vid_timeout_running)\n\t\tmod_timer(&dev->vid_timeout, jiffies + (HZ / 10));\n\tif (dev->vbi_timeout_running)\n\t\tmod_timer(&dev->vbi_timeout, jiffies + (HZ / 10));\n\n\t \n\tau0828_i2s_init(dev);\n\n\tau0828_analog_stream_enable(dev);\n\n\tif (!(dev->stream_state == STREAM_ON)) {\n\t\tau0828_analog_stream_reset(dev);\n\t\t \n\t\tfor (i = 0; i < dev->isoc_ctl.num_bufs; i++) {\n\t\t\trc = usb_submit_urb(dev->isoc_ctl.urb[i], GFP_ATOMIC);\n\t\t\tif (rc) {\n\t\t\t\tau0828_isocdbg(\"submit of urb %i failed (error=%i)\\n\",\n\t\t\t\t\t       i, rc);\n\t\t\t\tau0828_uninit_isoc(dev);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic const struct v4l2_file_operations au0828_v4l_fops = {\n\t.owner      = THIS_MODULE,\n\t.open       = au0828_v4l2_open,\n\t.release    = au0828_v4l2_close,\n\t.read       = vb2_fop_read,\n\t.poll       = vb2_fop_poll,\n\t.mmap       = vb2_fop_mmap,\n\t.unlocked_ioctl = video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops video_ioctl_ops = {\n\t.vidioc_querycap            = vidioc_querycap,\n\t.vidioc_enum_fmt_vid_cap    = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap       = vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap     = vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap       = vidioc_s_fmt_vid_cap,\n\t.vidioc_g_fmt_vbi_cap       = vidioc_g_fmt_vbi_cap,\n\t.vidioc_try_fmt_vbi_cap     = vidioc_g_fmt_vbi_cap,\n\t.vidioc_s_fmt_vbi_cap       = vidioc_g_fmt_vbi_cap,\n\t.vidioc_enumaudio           = vidioc_enumaudio,\n\t.vidioc_g_audio             = vidioc_g_audio,\n\t.vidioc_s_audio             = vidioc_s_audio,\n\t.vidioc_g_pixelaspect       = vidioc_g_pixelaspect,\n\t.vidioc_g_selection         = vidioc_g_selection,\n\n\t.vidioc_reqbufs             = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs         = vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf         = vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf            = vb2_ioctl_querybuf,\n\t.vidioc_qbuf                = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf               = vb2_ioctl_dqbuf,\n\t.vidioc_expbuf               = vb2_ioctl_expbuf,\n\n\t.vidioc_s_std               = vidioc_s_std,\n\t.vidioc_g_std               = vidioc_g_std,\n\t.vidioc_enum_input          = vidioc_enum_input,\n\t.vidioc_g_input             = vidioc_g_input,\n\t.vidioc_s_input             = vidioc_s_input,\n\n\t.vidioc_streamon            = vb2_ioctl_streamon,\n\t.vidioc_streamoff           = vb2_ioctl_streamoff,\n\n\t.vidioc_g_tuner             = vidioc_g_tuner,\n\t.vidioc_s_tuner             = vidioc_s_tuner,\n\t.vidioc_g_frequency         = vidioc_g_frequency,\n\t.vidioc_s_frequency         = vidioc_s_frequency,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_register          = vidioc_g_register,\n\t.vidioc_s_register          = vidioc_s_register,\n#endif\n\t.vidioc_log_status\t    = vidioc_log_status,\n\t.vidioc_subscribe_event     = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event   = v4l2_event_unsubscribe,\n};\n\nstatic const struct video_device au0828_video_template = {\n\t.fops                       = &au0828_v4l_fops,\n\t.release                    = video_device_release_empty,\n\t.ioctl_ops\t\t    = &video_ioctl_ops,\n\t.tvnorms                    = V4L2_STD_NTSC_M | V4L2_STD_PAL_M,\n};\n\nstatic int au0828_vb2_setup(struct au0828_dev *dev)\n{\n\tint rc;\n\tstruct vb2_queue *q;\n\n\t \n\tq = &dev->vb_vidq;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_READ | VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->drv_priv = dev;\n\tq->buf_struct_size = sizeof(struct au0828_buffer);\n\tq->ops = &au0828_video_qops;\n\tq->mem_ops = &vb2_vmalloc_memops;\n\n\trc = vb2_queue_init(q);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tq = &dev->vb_vbiq;\n\tq->type = V4L2_BUF_TYPE_VBI_CAPTURE;\n\tq->io_modes = VB2_READ | VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->drv_priv = dev;\n\tq->buf_struct_size = sizeof(struct au0828_buffer);\n\tq->ops = &au0828_vbi_qops;\n\tq->mem_ops = &vb2_vmalloc_memops;\n\n\trc = vb2_queue_init(q);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic void au0828_analog_create_entities(struct au0828_dev *dev)\n{\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tstatic const char * const inames[] = {\n\t\t[AU0828_VMUX_COMPOSITE] = \"Composite\",\n\t\t[AU0828_VMUX_SVIDEO] = \"S-Video\",\n\t\t[AU0828_VMUX_CABLE] = \"Cable TV\",\n\t\t[AU0828_VMUX_TELEVISION] = \"Television\",\n\t\t[AU0828_VMUX_DVB] = \"DVB\",\n\t};\n\tint ret, i;\n\n\t \n\tdev->video_pad.flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&dev->vdev.entity, 1, &dev->video_pad);\n\tif (ret < 0)\n\t\tpr_err(\"failed to initialize video media entity!\\n\");\n\n\tdev->vbi_pad.flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&dev->vbi_dev.entity, 1, &dev->vbi_pad);\n\tif (ret < 0)\n\t\tpr_err(\"failed to initialize vbi media entity!\\n\");\n\n\t \n\tfor (i = 0; i < AU0828_MAX_INPUT; i++) {\n\t\tstruct media_entity *ent = &dev->input_ent[i];\n\n\t\tif (AUVI_INPUT(i).type == AU0828_VMUX_UNDEFINED)\n\t\t\tbreak;\n\n\t\tent->name = inames[AUVI_INPUT(i).type];\n\t\tent->flags = MEDIA_ENT_FL_CONNECTOR;\n\t\tdev->input_pad[i].flags = MEDIA_PAD_FL_SOURCE;\n\n\t\tswitch (AUVI_INPUT(i).type) {\n\t\tcase AU0828_VMUX_COMPOSITE:\n\t\t\tent->function = MEDIA_ENT_F_CONN_COMPOSITE;\n\t\t\tbreak;\n\t\tcase AU0828_VMUX_SVIDEO:\n\t\t\tent->function = MEDIA_ENT_F_CONN_SVIDEO;\n\t\t\tbreak;\n\t\tcase AU0828_VMUX_CABLE:\n\t\tcase AU0828_VMUX_TELEVISION:\n\t\tcase AU0828_VMUX_DVB:\n\t\tdefault:  \n\t\t\tent->function = MEDIA_ENT_F_CONN_RF;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = media_entity_pads_init(ent, 1, &dev->input_pad[i]);\n\t\tif (ret < 0)\n\t\t\tpr_err(\"failed to initialize input pad[%d]!\\n\", i);\n\n\t\tret = media_device_register_entity(dev->media_dev, ent);\n\t\tif (ret < 0)\n\t\t\tpr_err(\"failed to register input entity %d!\\n\", i);\n\t}\n#endif\n}\n\n \n\nint au0828_analog_register(struct au0828_dev *dev,\n\t\t\t   struct usb_interface *interface)\n{\n\tint retval = -ENOMEM;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint i, ret;\n\n\tdprintk(1, \"au0828_analog_register called for intf#%d!\\n\",\n\t\tinterface->cur_altsetting->desc.bInterfaceNumber);\n\n\t \n\tif (AUVI_INPUT(0).type == AU0828_VMUX_UNDEFINED)\n\t\treturn 0;\n\n\t \n\tretval = usb_set_interface(dev->usbdev,\n\t\t\tinterface->cur_altsetting->desc.bInterfaceNumber, 5);\n\tif (retval != 0) {\n\t\tpr_info(\"Failure setting usb interface0 to as5\\n\");\n\t\treturn retval;\n\t}\n\n\t \n\tiface_desc = interface->cur_altsetting;\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\t\tif (((endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK)\n\t\t     == USB_DIR_IN) &&\n\t\t    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)\n\t\t     == USB_ENDPOINT_XFER_ISOC)) {\n\n\t\t\t \n\t\t\tu16 tmp = le16_to_cpu(endpoint->wMaxPacketSize);\n\t\t\tdev->max_pkt_size = (tmp & 0x07ff) *\n\t\t\t\t(((tmp & 0x1800) >> 11) + 1);\n\t\t\tdev->isoc_in_endpointaddr = endpoint->bEndpointAddress;\n\t\t\tdprintk(1,\n\t\t\t\t\"Found isoc endpoint 0x%02x, max size = %d\\n\",\n\t\t\t\tdev->isoc_in_endpointaddr, dev->max_pkt_size);\n\t\t}\n\t}\n\tif (!(dev->isoc_in_endpointaddr)) {\n\t\tpr_info(\"Could not locate isoc endpoint\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tinit_waitqueue_head(&dev->open);\n\tspin_lock_init(&dev->slock);\n\n\t \n\tINIT_LIST_HEAD(&dev->vidq.active);\n\tINIT_LIST_HEAD(&dev->vbiq.active);\n\n\ttimer_setup(&dev->vid_timeout, au0828_vid_buffer_timeout, 0);\n\ttimer_setup(&dev->vbi_timeout, au0828_vbi_buffer_timeout, 0);\n\n\tdev->width = NTSC_STD_W;\n\tdev->height = NTSC_STD_H;\n\tdev->field_size = dev->width * dev->height;\n\tdev->frame_size = dev->field_size << 1;\n\tdev->bytesperline = dev->width << 1;\n\tdev->vbi_width = 720;\n\tdev->vbi_height = 1;\n\tdev->ctrl_ainput = 0;\n\tdev->ctrl_freq = 960;\n\tdev->std = V4L2_STD_NTSC_M;\n\t \n\tau0828_s_input(dev, 0);\n\n\tmutex_init(&dev->vb_queue_lock);\n\tmutex_init(&dev->vb_vbi_queue_lock);\n\n\t \n\tdev->vdev = au0828_video_template;\n\tdev->vdev.v4l2_dev = &dev->v4l2_dev;\n\tdev->vdev.lock = &dev->lock;\n\tdev->vdev.queue = &dev->vb_vidq;\n\tdev->vdev.queue->lock = &dev->vb_queue_lock;\n\tdev->vdev.device_caps =\n\t\tV4L2_CAP_AUDIO | V4L2_CAP_READWRITE | V4L2_CAP_STREAMING |\n\t\tV4L2_CAP_TUNER | V4L2_CAP_VIDEO_CAPTURE;\n\tstrscpy(dev->vdev.name, \"au0828a video\", sizeof(dev->vdev.name));\n\n\t \n\tdev->vbi_dev = au0828_video_template;\n\tdev->vbi_dev.v4l2_dev = &dev->v4l2_dev;\n\tdev->vbi_dev.lock = &dev->lock;\n\tdev->vbi_dev.queue = &dev->vb_vbiq;\n\tdev->vbi_dev.queue->lock = &dev->vb_vbi_queue_lock;\n\tdev->vbi_dev.device_caps =\n\t\tV4L2_CAP_AUDIO | V4L2_CAP_READWRITE | V4L2_CAP_STREAMING |\n\t\tV4L2_CAP_TUNER | V4L2_CAP_VBI_CAPTURE;\n\tstrscpy(dev->vbi_dev.name, \"au0828a vbi\", sizeof(dev->vbi_dev.name));\n\n\t \n\tau0828_analog_create_entities(dev);\n\n\t \n\tretval = au0828_vb2_setup(dev);\n\tif (retval != 0) {\n\t\tdprintk(1, \"unable to setup videobuf2 queues (error = %d).\\n\",\n\t\t\tretval);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tvideo_set_drvdata(&dev->vdev, dev);\n\tretval = video_register_device(&dev->vdev, VFL_TYPE_VIDEO, -1);\n\tif (retval != 0) {\n\t\tdprintk(1, \"unable to register video device (error = %d).\\n\",\n\t\t\tretval);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tvideo_set_drvdata(&dev->vbi_dev, dev);\n\tretval = video_register_device(&dev->vbi_dev, VFL_TYPE_VBI, -1);\n\tif (retval != 0) {\n\t\tdprintk(1, \"unable to register vbi device (error = %d).\\n\",\n\t\t\tretval);\n\t\tret = -ENODEV;\n\t\tgoto err_reg_vbi_dev;\n\t}\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tretval = v4l2_mc_create_media_graph(dev->media_dev);\n\tif (retval) {\n\t\tpr_err(\"%s() au0282_dev_register failed to create graph\\n\",\n\t\t\t__func__);\n\t\tret = -ENODEV;\n\t\tgoto err_reg_vbi_dev;\n\t}\n#endif\n\n\tdprintk(1, \"%s completed!\\n\", __func__);\n\n\treturn 0;\n\nerr_reg_vbi_dev:\n\tvb2_video_unregister_device(&dev->vdev);\n\treturn ret;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}