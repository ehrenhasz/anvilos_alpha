{
  "module_name": "au0828-dvb.c",
  "hash_id": "3e34f7a4c376a6c40e19c0e8b4ce9e07558c0728b67f5d393fe01bc4b844325c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/au0828/au0828-dvb.c",
  "human_readable_source": "\n \n\n#include \"au0828.h\"\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <media/v4l2-common.h>\n#include <media/tuner.h>\n\n#include \"au8522.h\"\n#include \"xc5000.h\"\n#include \"mxl5007t.h\"\n#include \"tda18271.h\"\n\nstatic int preallocate_big_buffers;\nmodule_param_named(preallocate_big_buffers, preallocate_big_buffers, int, 0644);\nMODULE_PARM_DESC(preallocate_big_buffers, \"Preallocate the larger transfer buffers at module load time\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n#define _AU0828_BULKPIPE 0x83\n#define _BULKPIPESIZE 0xe522\n\nstatic u8 hauppauge_hvr950q_led_states[] = {\n\t0x00,  \n\t0x02,  \n\t0x04,  \n};\n\nstatic struct au8522_led_config hauppauge_hvr950q_led_cfg = {\n\t.gpio_output = 0x00e0,\n\t.gpio_output_enable  = 0x6006,\n\t.gpio_output_disable = 0x0660,\n\n\t.gpio_leds = 0x00e2,\n\t.led_states  = hauppauge_hvr950q_led_states,\n\t.num_led_states = sizeof(hauppauge_hvr950q_led_states),\n\n\t.vsb8_strong   = 20   * 10,\n\t.qam64_strong  = 25   * 10,\n\t.qam256_strong = 32   * 10,\n};\n\nstatic struct au8522_config hauppauge_hvr950q_config = {\n\t.demod_address = 0x8e >> 1,\n\t.status_mode   = AU8522_DEMODLOCKING,\n\t.qam_if        = AU8522_IF_6MHZ,\n\t.vsb_if        = AU8522_IF_6MHZ,\n\t.led_cfg       = &hauppauge_hvr950q_led_cfg,\n};\n\nstatic struct au8522_config fusionhdtv7usb_config = {\n\t.demod_address = 0x8e >> 1,\n\t.status_mode   = AU8522_DEMODLOCKING,\n\t.qam_if        = AU8522_IF_6MHZ,\n\t.vsb_if        = AU8522_IF_6MHZ,\n};\n\nstatic struct au8522_config hauppauge_woodbury_config = {\n\t.demod_address = 0x8e >> 1,\n\t.status_mode   = AU8522_DEMODLOCKING,\n\t.qam_if        = AU8522_IF_4MHZ,\n\t.vsb_if        = AU8522_IF_3_25MHZ,\n};\n\nstatic struct xc5000_config hauppauge_xc5000a_config = {\n\t.i2c_address      = 0x61,\n\t.if_khz           = 6000,\n\t.chip_id          = XC5000A,\n\t.output_amp       = 0x8f,\n};\n\nstatic struct xc5000_config hauppauge_xc5000c_config = {\n\t.i2c_address      = 0x61,\n\t.if_khz           = 6000,\n\t.chip_id          = XC5000C,\n\t.output_amp       = 0x8f,\n};\n\nstatic struct mxl5007t_config mxl5007t_hvr950q_config = {\n\t.xtal_freq_hz = MxL_XTAL_24_MHZ,\n\t.if_freq_hz = MxL_IF_6_MHZ,\n};\n\nstatic struct tda18271_config hauppauge_woodbury_tunerconfig = {\n\t.gate    = TDA18271_GATE_DIGITAL,\n};\n\nstatic void au0828_restart_dvb_streaming(struct work_struct *work);\n\nstatic void au0828_bulk_timeout(struct timer_list *t)\n{\n\tstruct au0828_dev *dev = from_timer(dev, t, bulk_timeout);\n\n\tdprintk(1, \"%s called\\n\", __func__);\n\tdev->bulk_timeout_running = 0;\n\tschedule_work(&dev->restart_streaming);\n}\n\n \nstatic void urb_completion(struct urb *purb)\n{\n\tstruct au0828_dev *dev = purb->context;\n\tint ptype = usb_pipetype(purb->pipe);\n\tunsigned char *ptr;\n\n\tdprintk(2, \"%s: %d\\n\", __func__, purb->actual_length);\n\n\tif (!dev) {\n\t\tdprintk(2, \"%s: no dev!\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (!dev->urb_streaming) {\n\t\tdprintk(2, \"%s: not streaming!\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (ptype != PIPE_BULK) {\n\t\tpr_err(\"%s: Unsupported URB type %d\\n\",\n\t\t       __func__, ptype);\n\t\treturn;\n\t}\n\n\t \n\tptr = purb->transfer_buffer;\n\tif (purb->actual_length > 0 && ptr[0] != 0x47) {\n\t\tdprintk(1, \"Need to restart streaming %02x len=%d!\\n\",\n\t\t\tptr[0], purb->actual_length);\n\t\tschedule_work(&dev->restart_streaming);\n\t\treturn;\n\t} else if (dev->bulk_timeout_running == 1) {\n\t\t \n\t\tdprintk(1, \"%s cancelling bulk timeout\\n\", __func__);\n\t\tdev->bulk_timeout_running = 0;\n\t\tdel_timer(&dev->bulk_timeout);\n\t}\n\n\t \n\tdvb_dmx_swfilter_packets(&dev->dvb.demux,\n\t\tpurb->transfer_buffer, purb->actual_length / 188);\n\n\t \n\tmemset(purb->transfer_buffer, 0, URB_BUFSIZE);\n\n\t \n\tusb_submit_urb(purb, GFP_ATOMIC);\n}\n\nstatic int stop_urb_transfer(struct au0828_dev *dev)\n{\n\tint i;\n\n\tdprintk(2, \"%s()\\n\", __func__);\n\n\tif (!dev->urb_streaming)\n\t\treturn 0;\n\n\tif (dev->bulk_timeout_running == 1) {\n\t\tdev->bulk_timeout_running = 0;\n\t\tdel_timer(&dev->bulk_timeout);\n\t}\n\n\tdev->urb_streaming = false;\n\tfor (i = 0; i < URB_COUNT; i++) {\n\t\tif (dev->urbs[i]) {\n\t\t\tusb_kill_urb(dev->urbs[i]);\n\t\t\tif (!preallocate_big_buffers)\n\t\t\t\tkfree(dev->urbs[i]->transfer_buffer);\n\n\t\t\tusb_free_urb(dev->urbs[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int start_urb_transfer(struct au0828_dev *dev)\n{\n\tstruct urb *purb;\n\tint i, ret;\n\n\tdprintk(2, \"%s()\\n\", __func__);\n\n\tif (dev->urb_streaming) {\n\t\tdprintk(2, \"%s: bulk xfer already running!\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < URB_COUNT; i++) {\n\n\t\tdev->urbs[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!dev->urbs[i])\n\t\t\treturn -ENOMEM;\n\n\t\tpurb = dev->urbs[i];\n\n\t\tif (preallocate_big_buffers)\n\t\t\tpurb->transfer_buffer = dev->dig_transfer_buffer[i];\n\t\telse\n\t\t\tpurb->transfer_buffer = kzalloc(URB_BUFSIZE,\n\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!purb->transfer_buffer) {\n\t\t\tusb_free_urb(purb);\n\t\t\tdev->urbs[i] = NULL;\n\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"%s: failed big buffer allocation, err = %d\\n\",\n\t\t\t       __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpurb->status = -EINPROGRESS;\n\t\tusb_fill_bulk_urb(purb,\n\t\t\t\t  dev->usbdev,\n\t\t\t\t  usb_rcvbulkpipe(dev->usbdev,\n\t\t\t\t\t_AU0828_BULKPIPE),\n\t\t\t\t  purb->transfer_buffer,\n\t\t\t\t  URB_BUFSIZE,\n\t\t\t\t  urb_completion,\n\t\t\t\t  dev);\n\n\t}\n\n\tfor (i = 0; i < URB_COUNT; i++) {\n\t\tret = usb_submit_urb(dev->urbs[i], GFP_ATOMIC);\n\t\tif (ret != 0) {\n\t\t\tstop_urb_transfer(dev);\n\t\t\tpr_err(\"%s: failed urb submission, err = %d\\n\",\n\t\t\t       __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdev->urb_streaming = true;\n\n\t \n\tmod_timer(&dev->bulk_timeout, jiffies + (HZ));\n\tdev->bulk_timeout_running = 1;\n\n\treturn 0;\n}\n\nstatic void au0828_start_transport(struct au0828_dev *dev)\n{\n\tau0828_write(dev, 0x608, 0x90);\n\tau0828_write(dev, 0x609, 0x72);\n\tau0828_write(dev, 0x60a, 0x71);\n\tau0828_write(dev, 0x60b, 0x01);\n\n}\n\nstatic void au0828_stop_transport(struct au0828_dev *dev, int full_stop)\n{\n\tif (full_stop) {\n\t\tau0828_write(dev, 0x608, 0x00);\n\t\tau0828_write(dev, 0x609, 0x00);\n\t\tau0828_write(dev, 0x60a, 0x00);\n\t}\n\tau0828_write(dev, 0x60b, 0x00);\n}\n\nstatic int au0828_dvb_start_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct au0828_dev *dev = demux->priv;\n\tstruct au0828_dvb *dvb = &dev->dvb;\n\tint ret = 0;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tif (!demux->dmx.frontend)\n\t\treturn -EINVAL;\n\n\tif (dvb->frontend) {\n\t\tmutex_lock(&dvb->lock);\n\t\tdvb->start_count++;\n\t\tdprintk(1, \"%s(), start_count: %d, stop_count: %d\\n\", __func__,\n\t\t\tdvb->start_count, dvb->stop_count);\n\t\tif (dvb->feeding++ == 0) {\n\t\t\t \n\t\t\tau0828_start_transport(dev);\n\t\t\tret = start_urb_transfer(dev);\n\t\t\tif (ret < 0) {\n\t\t\t\tau0828_stop_transport(dev, 0);\n\t\t\t\tdvb->feeding--;\t \n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&dvb->lock);\n\t}\n\n\treturn ret;\n}\n\nstatic int au0828_dvb_stop_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct au0828_dev *dev = demux->priv;\n\tstruct au0828_dvb *dvb = &dev->dvb;\n\tint ret = 0;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tif (dvb->frontend) {\n\t\tcancel_work_sync(&dev->restart_streaming);\n\n\t\tmutex_lock(&dvb->lock);\n\t\tdvb->stop_count++;\n\t\tdprintk(1, \"%s(), start_count: %d, stop_count: %d\\n\", __func__,\n\t\t\tdvb->start_count, dvb->stop_count);\n\t\tif (dvb->feeding > 0) {\n\t\t\tdvb->feeding--;\n\t\t\tif (dvb->feeding == 0) {\n\t\t\t\t \n\t\t\t\tret = stop_urb_transfer(dev);\n\t\t\t\tau0828_stop_transport(dev, 0);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&dvb->lock);\n\t}\n\n\treturn ret;\n}\n\nstatic void au0828_restart_dvb_streaming(struct work_struct *work)\n{\n\tstruct au0828_dev *dev = container_of(work, struct au0828_dev,\n\t\t\t\t\t      restart_streaming);\n\tstruct au0828_dvb *dvb = &dev->dvb;\n\n\tif (!dev->urb_streaming)\n\t\treturn;\n\n\tdprintk(1, \"Restarting streaming...!\\n\");\n\n\tmutex_lock(&dvb->lock);\n\n\t \n\tstop_urb_transfer(dev);\n\tau0828_stop_transport(dev, 1);\n\n\t \n\tau0828_start_transport(dev);\n\tstart_urb_transfer(dev);\n\n\tmutex_unlock(&dvb->lock);\n}\n\nstatic int au0828_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct au0828_dev *dev = fe->dvb->priv;\n\tstruct au0828_dvb *dvb = &dev->dvb;\n\tint ret, was_streaming;\n\n\tmutex_lock(&dvb->lock);\n\twas_streaming = dev->urb_streaming;\n\tif (was_streaming) {\n\t\tau0828_stop_transport(dev, 1);\n\n\t\t \n\t\tmutex_unlock(&dvb->lock);\n\t\tcancel_work_sync(&dev->restart_streaming);\n\t\tmutex_lock(&dvb->lock);\n\n\t\tstop_urb_transfer(dev);\n\t}\n\tmutex_unlock(&dvb->lock);\n\n\tret = dvb->set_frontend(fe);\n\n\tif (was_streaming) {\n\t\tmutex_lock(&dvb->lock);\n\t\tau0828_start_transport(dev);\n\t\tstart_urb_transfer(dev);\n\t\tmutex_unlock(&dvb->lock);\n\t}\n\n\treturn ret;\n}\n\nstatic int dvb_register(struct au0828_dev *dev)\n{\n\tstruct au0828_dvb *dvb = &dev->dvb;\n\tint result;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tif (preallocate_big_buffers) {\n\t\tint i;\n\t\tfor (i = 0; i < URB_COUNT; i++) {\n\t\t\tdev->dig_transfer_buffer[i] = kzalloc(URB_BUFSIZE,\n\t\t\t\t\tGFP_KERNEL);\n\n\t\t\tif (!dev->dig_transfer_buffer[i]) {\n\t\t\t\tresult = -ENOMEM;\n\n\t\t\t\tpr_err(\"failed buffer allocation (errno = %d)\\n\",\n\t\t\t\t       result);\n\t\t\t\tgoto fail_adapter;\n\t\t\t}\n\t\t}\n\t}\n\n\tINIT_WORK(&dev->restart_streaming, au0828_restart_dvb_streaming);\n\n\t \n\tresult = dvb_register_adapter(&dvb->adapter,\n\t\t\t\t      KBUILD_MODNAME, THIS_MODULE,\n\t\t\t\t      &dev->usbdev->dev, adapter_nr);\n\tif (result < 0) {\n\t\tpr_err(\"dvb_register_adapter failed (errno = %d)\\n\",\n\t\t       result);\n\t\tgoto fail_adapter;\n\t}\n\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tdvb->adapter.mdev = dev->media_dev;\n#endif\n\n\tdvb->adapter.priv = dev;\n\n\t \n\tresult = dvb_register_frontend(&dvb->adapter, dvb->frontend);\n\tif (result < 0) {\n\t\tpr_err(\"dvb_register_frontend failed (errno = %d)\\n\",\n\t\t       result);\n\t\tgoto fail_frontend;\n\t}\n\n\t \n\tdvb->set_frontend = dvb->frontend->ops.set_frontend;\n\tdvb->frontend->ops.set_frontend = au0828_set_frontend;\n\n\t \n\tdvb->demux.dmx.capabilities =\n\t\tDMX_TS_FILTERING | DMX_SECTION_FILTERING |\n\t\tDMX_MEMORY_BASED_FILTERING;\n\tdvb->demux.priv       = dev;\n\tdvb->demux.filternum  = 256;\n\tdvb->demux.feednum    = 256;\n\tdvb->demux.start_feed = au0828_dvb_start_feed;\n\tdvb->demux.stop_feed  = au0828_dvb_stop_feed;\n\tresult = dvb_dmx_init(&dvb->demux);\n\tif (result < 0) {\n\t\tpr_err(\"dvb_dmx_init failed (errno = %d)\\n\", result);\n\t\tgoto fail_dmx;\n\t}\n\n\tdvb->dmxdev.filternum    = 256;\n\tdvb->dmxdev.demux        = &dvb->demux.dmx;\n\tdvb->dmxdev.capabilities = 0;\n\tresult = dvb_dmxdev_init(&dvb->dmxdev, &dvb->adapter);\n\tif (result < 0) {\n\t\tpr_err(\"dvb_dmxdev_init failed (errno = %d)\\n\", result);\n\t\tgoto fail_dmxdev;\n\t}\n\n\tdvb->fe_hw.source = DMX_FRONTEND_0;\n\tresult = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_hw);\n\tif (result < 0) {\n\t\tpr_err(\"add_frontend failed (DMX_FRONTEND_0, errno = %d)\\n\",\n\t\t       result);\n\t\tgoto fail_fe_hw;\n\t}\n\n\tdvb->fe_mem.source = DMX_MEMORY_FE;\n\tresult = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_mem);\n\tif (result < 0) {\n\t\tpr_err(\"add_frontend failed (DMX_MEMORY_FE, errno = %d)\\n\",\n\t\t       result);\n\t\tgoto fail_fe_mem;\n\t}\n\n\tresult = dvb->demux.dmx.connect_frontend(&dvb->demux.dmx, &dvb->fe_hw);\n\tif (result < 0) {\n\t\tpr_err(\"connect_frontend failed (errno = %d)\\n\", result);\n\t\tgoto fail_fe_conn;\n\t}\n\n\t \n\tdvb_net_init(&dvb->adapter, &dvb->net, &dvb->demux.dmx);\n\n\tdvb->start_count = 0;\n\tdvb->stop_count = 0;\n\n\tresult = dvb_create_media_graph(&dvb->adapter, false);\n\tif (result < 0)\n\t\tgoto fail_create_graph;\n\n\treturn 0;\n\nfail_create_graph:\n\tdvb_net_release(&dvb->net);\nfail_fe_conn:\n\tdvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_mem);\nfail_fe_mem:\n\tdvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_hw);\nfail_fe_hw:\n\tdvb_dmxdev_release(&dvb->dmxdev);\nfail_dmxdev:\n\tdvb_dmx_release(&dvb->demux);\nfail_dmx:\n\tdvb_unregister_frontend(dvb->frontend);\nfail_frontend:\n\tdvb_frontend_detach(dvb->frontend);\n\tdvb_unregister_adapter(&dvb->adapter);\nfail_adapter:\n\n\tif (preallocate_big_buffers) {\n\t\tint i;\n\t\tfor (i = 0; i < URB_COUNT; i++)\n\t\t\tkfree(dev->dig_transfer_buffer[i]);\n\t}\n\n\treturn result;\n}\n\nvoid au0828_dvb_unregister(struct au0828_dev *dev)\n{\n\tstruct au0828_dvb *dvb = &dev->dvb;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tif (dvb->frontend == NULL)\n\t\treturn;\n\n\tcancel_work_sync(&dev->restart_streaming);\n\n\tdvb_net_release(&dvb->net);\n\tdvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_mem);\n\tdvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_hw);\n\tdvb_dmxdev_release(&dvb->dmxdev);\n\tdvb_dmx_release(&dvb->demux);\n\tdvb_unregister_frontend(dvb->frontend);\n\tdvb_frontend_detach(dvb->frontend);\n\tdvb_unregister_adapter(&dvb->adapter);\n\n\tif (preallocate_big_buffers) {\n\t\tint i;\n\t\tfor (i = 0; i < URB_COUNT; i++)\n\t\t\tkfree(dev->dig_transfer_buffer[i]);\n\t}\n\tdvb->frontend = NULL;\n}\n\n \nint au0828_dvb_register(struct au0828_dev *dev)\n{\n\tstruct au0828_dvb *dvb = &dev->dvb;\n\tint ret;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t \n\tswitch (dev->boardnr) {\n\tcase AU0828_BOARD_HAUPPAUGE_HVR850:\n\tcase AU0828_BOARD_HAUPPAUGE_HVR950Q:\n\t\tdvb->frontend = dvb_attach(au8522_attach,\n\t\t\t\t&hauppauge_hvr950q_config,\n\t\t\t\t&dev->i2c_adap);\n\t\tif (dvb->frontend != NULL)\n\t\t\tswitch (dev->board.tuner_type) {\n\t\t\tdefault:\n\t\t\tcase TUNER_XC5000:\n\t\t\t\tdvb_attach(xc5000_attach, dvb->frontend,\n\t\t\t\t\t   &dev->i2c_adap,\n\t\t\t\t\t   &hauppauge_xc5000a_config);\n\t\t\t\tbreak;\n\t\t\tcase TUNER_XC5000C:\n\t\t\t\tdvb_attach(xc5000_attach, dvb->frontend,\n\t\t\t\t\t   &dev->i2c_adap,\n\t\t\t\t\t   &hauppauge_xc5000c_config);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tbreak;\n\tcase AU0828_BOARD_HAUPPAUGE_HVR950Q_MXL:\n\t\tdvb->frontend = dvb_attach(au8522_attach,\n\t\t\t\t&hauppauge_hvr950q_config,\n\t\t\t\t&dev->i2c_adap);\n\t\tif (dvb->frontend != NULL)\n\t\t\tdvb_attach(mxl5007t_attach, dvb->frontend,\n\t\t\t\t   &dev->i2c_adap, 0x60,\n\t\t\t\t   &mxl5007t_hvr950q_config);\n\t\tbreak;\n\tcase AU0828_BOARD_HAUPPAUGE_WOODBURY:\n\t\tdvb->frontend = dvb_attach(au8522_attach,\n\t\t\t\t&hauppauge_woodbury_config,\n\t\t\t\t&dev->i2c_adap);\n\t\tif (dvb->frontend != NULL)\n\t\t\tdvb_attach(tda18271_attach, dvb->frontend,\n\t\t\t\t   0x60, &dev->i2c_adap,\n\t\t\t\t   &hauppauge_woodbury_tunerconfig);\n\t\tbreak;\n\tcase AU0828_BOARD_DVICO_FUSIONHDTV7:\n\t\tdvb->frontend = dvb_attach(au8522_attach,\n\t\t\t\t&fusionhdtv7usb_config,\n\t\t\t\t&dev->i2c_adap);\n\t\tif (dvb->frontend != NULL) {\n\t\t\tdvb_attach(xc5000_attach, dvb->frontend,\n\t\t\t\t&dev->i2c_adap,\n\t\t\t\t&hauppauge_xc5000a_config);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"The frontend of your DVB/ATSC card isn't supported yet\\n\");\n\t\tbreak;\n\t}\n\tif (NULL == dvb->frontend) {\n\t\tpr_err(\"%s() Frontend initialization failed\\n\",\n\t\t       __func__);\n\t\treturn -1;\n\t}\n\t \n\tdvb->frontend->callback = au0828_tuner_callback;\n\n\t \n\tret = dvb_register(dev);\n\tif (ret < 0) {\n\t\tif (dvb->frontend->ops.release)\n\t\t\tdvb->frontend->ops.release(dvb->frontend);\n\t\tdvb->frontend = NULL;\n\t\treturn ret;\n\t}\n\n\ttimer_setup(&dev->bulk_timeout, au0828_bulk_timeout, 0);\n\n\treturn 0;\n}\n\nvoid au0828_dvb_suspend(struct au0828_dev *dev)\n{\n\tstruct au0828_dvb *dvb = &dev->dvb;\n\tint rc;\n\n\tif (dvb->frontend) {\n\t\tif (dev->urb_streaming) {\n\t\t\tcancel_work_sync(&dev->restart_streaming);\n\t\t\t \n\t\t\tmutex_lock(&dvb->lock);\n\t\t\tstop_urb_transfer(dev);\n\t\t\tau0828_stop_transport(dev, 1);\n\t\t\tmutex_unlock(&dvb->lock);\n\t\t\tdev->need_urb_start = true;\n\t\t}\n\t\t \n\t\trc = dvb_frontend_suspend(dvb->frontend);\n\t\tpr_info(\"au0828_dvb_suspend(): Suspending DVB fe %d\\n\", rc);\n\t}\n}\n\nvoid au0828_dvb_resume(struct au0828_dev *dev)\n{\n\tstruct au0828_dvb *dvb = &dev->dvb;\n\tint rc;\n\n\tif (dvb->frontend) {\n\t\t \n\t\trc = dvb_frontend_resume(dvb->frontend);\n\t\tpr_info(\"au0828_dvb_resume(): Resuming DVB fe %d\\n\", rc);\n\t\tif (dev->need_urb_start) {\n\t\t\t \n\t\t\tmutex_lock(&dvb->lock);\n\t\t\tau0828_start_transport(dev);\n\t\t\tstart_urb_transfer(dev);\n\t\t\tmutex_unlock(&dvb->lock);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}