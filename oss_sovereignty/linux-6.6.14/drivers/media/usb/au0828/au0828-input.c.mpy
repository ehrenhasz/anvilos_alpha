{
  "module_name": "au0828-input.c",
  "hash_id": "160910d80001304ff7d87cffb00052328cc6102f62958e95ea61da0db6225155",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/au0828/au0828-input.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include \"au0828.h\"\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/usb.h>\n#include <linux/slab.h>\n#include <media/rc-core.h>\n\nstatic int disable_ir;\nmodule_param(disable_ir,        int, 0444);\nMODULE_PARM_DESC(disable_ir, \"disable infrared remote support\");\n\nstruct au0828_rc {\n\tstruct au0828_dev *dev;\n\tstruct rc_dev *rc;\n\tchar name[32];\n\tchar phys[32];\n\n\t \n\tint polling;\n\tstruct delayed_work work;\n\n\t \n\tu16 i2c_dev_addr;\n\n\tint  (*get_key_i2c)(struct au0828_rc *ir);\n};\n\n \n\nstatic int au8522_rc_write(struct au0828_rc *ir, u16 reg, u8 data)\n{\n\tint rc;\n\tchar buf[] = { (reg >> 8) | 0x80, reg & 0xff, data };\n\tstruct i2c_msg msg = { .addr = ir->i2c_dev_addr, .flags = 0,\n\t\t\t       .buf = buf, .len = sizeof(buf) };\n\n\trc = i2c_transfer(ir->dev->i2c_client.adapter, &msg, 1);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn (rc == 1) ? 0 : -EIO;\n}\n\nstatic int au8522_rc_read(struct au0828_rc *ir, u16 reg, int val,\n\t\t\t\t char *buf, int size)\n{\n\tint rc;\n\tchar obuf[3];\n\tstruct i2c_msg msg[2] = { { .addr = ir->i2c_dev_addr, .flags = 0,\n\t\t\t\t    .buf = obuf, .len = 2 },\n\t\t\t\t  { .addr = ir->i2c_dev_addr, .flags = I2C_M_RD,\n\t\t\t\t    .buf = buf, .len = size } };\n\n\tobuf[0] = 0x40 | reg >> 8;\n\tobuf[1] = reg & 0xff;\n\tif (val >= 0) {\n\t\tobuf[2] = val;\n\t\tmsg[0].len++;\n\t}\n\n\trc = i2c_transfer(ir->dev->i2c_client.adapter, msg, 2);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn (rc == 2) ? 0 : -EIO;\n}\n\nstatic int au8522_rc_andor(struct au0828_rc *ir, u16 reg, u8 mask, u8 value)\n{\n\tint rc;\n\tchar buf, oldbuf;\n\n\trc = au8522_rc_read(ir, reg, -1, &buf, 1);\n\tif (rc < 0)\n\t\treturn rc;\n\n\toldbuf = buf;\n\tbuf = (buf & ~mask) | (value & mask);\n\n\t \n\tif (buf == oldbuf)\n\t\treturn 0;\n\n\treturn au8522_rc_write(ir, reg, buf);\n}\n\n#define au8522_rc_set(ir, reg, bit) au8522_rc_andor(ir, (reg), (bit), (bit))\n#define au8522_rc_clear(ir, reg, bit) au8522_rc_andor(ir, (reg), (bit), 0)\n\n \n\n#define AU8522_UNIT\t\t200  \n#define NEC_START_SPACE\t\t(4500 / AU8522_UNIT)\n#define NEC_START_PULSE\t\t(563 * 16)\n#define RC5_START_SPACE\t\t(4 * AU8522_UNIT)\n#define RC5_START_PULSE\t\t889\n\nstatic int au0828_get_key_au8522(struct au0828_rc *ir)\n{\n\tunsigned char buf[40];\n\tstruct ir_raw_event rawir = {};\n\tint i, j, rc;\n\tint prv_bit, bit, width;\n\tbool first = true;\n\n\t \n\tif (test_bit(DEV_DISCONNECTED, &ir->dev->dev_state))\n\t\treturn 0;\n\n\t \n\trc = au8522_rc_read(ir, 0xe1, -1, buf, 1);\n\tif (rc < 0 || !(buf[0] & (1 << 4))) {\n\t\t \n\t\tau8522_rc_set(ir, 0xe0, 1 << 4);\n\t\treturn 0;\n\t}\n\n\t \n\trc = au8522_rc_read(ir, 0xe3, 0x11, buf, sizeof(buf));\n\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tau8522_rc_clear(ir, 0xe0, 1 << 4);\n\n\t \n\tau8522_rc_set(ir, 0xe0, 1 << 4);\n\n\tdprintk(16, \"RC data received: %*ph\\n\", 40, buf);\n\n\tprv_bit = (buf[0] >> 7) & 0x01;\n\twidth = 0;\n\tfor (i = 0; i < sizeof(buf); i++) {\n\t\tfor (j = 7; j >= 0; j--) {\n\t\t\tbit = (buf[i] >> j) & 0x01;\n\t\t\tif (bit == prv_bit) {\n\t\t\t\twidth++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tif (first) {\n\t\t\t\tfirst = false;\n\n\t\t\t\trawir.pulse = true;\n\t\t\t\tif (width > NEC_START_SPACE - 2 &&\n\t\t\t\t    width < NEC_START_SPACE + 2) {\n\t\t\t\t\t \n\t\t\t\t\trawir.duration = NEC_START_PULSE;\n\t\t\t\t\tdprintk(16, \"Storing NEC start %s with duration %d\",\n\t\t\t\t\t\trawir.pulse ? \"pulse\" : \"space\",\n\t\t\t\t\t\trawir.duration);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\trawir.duration = RC5_START_PULSE;\n\t\t\t\t\tdprintk(16, \"Storing RC5 start %s with duration %d\",\n\t\t\t\t\t\trawir.pulse ? \"pulse\" : \"space\",\n\t\t\t\t\t\trawir.duration);\n\t\t\t\t}\n\t\t\t\tir_raw_event_store(ir->rc, &rawir);\n\t\t\t}\n\n\t\t\trawir.pulse = prv_bit ? false : true;\n\t\t\trawir.duration = AU8522_UNIT * width;\n\t\t\tdprintk(16, \"Storing %s with duration %d\",\n\t\t\t\trawir.pulse ? \"pulse\" : \"space\",\n\t\t\t\trawir.duration);\n\t\t\tir_raw_event_store(ir->rc, &rawir);\n\n\t\t\twidth = 1;\n\t\t\tprv_bit = bit;\n\t\t}\n\t}\n\n\trawir.pulse = prv_bit ? false : true;\n\trawir.duration = AU8522_UNIT * width;\n\tdprintk(16, \"Storing end %s with duration %d\",\n\t\trawir.pulse ? \"pulse\" : \"space\",\n\t\trawir.duration);\n\tir_raw_event_store(ir->rc, &rawir);\n\n\tir_raw_event_handle(ir->rc);\n\n\treturn 1;\n}\n\n \n\nstatic void au0828_rc_work(struct work_struct *work)\n{\n\tstruct au0828_rc *ir = container_of(work, struct au0828_rc, work.work);\n\tint rc;\n\n\trc = ir->get_key_i2c(ir);\n\tif (rc < 0)\n\t\tpr_info(\"Error while getting RC scancode\\n\");\n\n\tschedule_delayed_work(&ir->work, msecs_to_jiffies(ir->polling));\n}\n\nstatic int au0828_rc_start(struct rc_dev *rc)\n{\n\tstruct au0828_rc *ir = rc->priv;\n\n\tINIT_DELAYED_WORK(&ir->work, au0828_rc_work);\n\n\t \n\tau8522_rc_set(ir, 0xe0, 1 << 4);\n\n\tschedule_delayed_work(&ir->work, msecs_to_jiffies(ir->polling));\n\n\treturn 0;\n}\n\nstatic void au0828_rc_stop(struct rc_dev *rc)\n{\n\tstruct au0828_rc *ir = rc->priv;\n\n\tcancel_delayed_work_sync(&ir->work);\n\n\t \n\tif (!test_bit(DEV_DISCONNECTED, &ir->dev->dev_state)) {\n\t\t \n\t\tau8522_rc_clear(ir, 0xe0, 1 << 4);\n\t}\n}\n\nstatic int au0828_probe_i2c_ir(struct au0828_dev *dev)\n{\n\tint i = 0;\n\tstatic const unsigned short addr_list[] = {\n\t\t 0x47, I2C_CLIENT_END\n\t};\n\n\twhile (addr_list[i] != I2C_CLIENT_END) {\n\t\tif (i2c_probe_func_quick_read(dev->i2c_client.adapter,\n\t\t\t\t\t      addr_list[i]) == 1)\n\t\t\treturn addr_list[i];\n\t\ti++;\n\t}\n\n\treturn -ENODEV;\n}\n\nint au0828_rc_register(struct au0828_dev *dev)\n{\n\tstruct au0828_rc *ir;\n\tstruct rc_dev *rc;\n\tint err = -ENOMEM;\n\tu16 i2c_rc_dev_addr = 0;\n\n\tif (!dev->board.has_ir_i2c || disable_ir)\n\t\treturn 0;\n\n\ti2c_rc_dev_addr = au0828_probe_i2c_ir(dev);\n\tif (!i2c_rc_dev_addr)\n\t\treturn -ENODEV;\n\n\tir = kzalloc(sizeof(*ir), GFP_KERNEL);\n\trc = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!ir || !rc)\n\t\tgoto error;\n\n\t \n\tir->dev = dev;\n\tdev->ir = ir;\n\tir->rc = rc;\n\n\trc->priv = ir;\n\trc->open = au0828_rc_start;\n\trc->close = au0828_rc_stop;\n\n\tif (dev->board.has_ir_i2c) {\t \n\t\tswitch (dev->boardnr) {\n\t\tcase AU0828_BOARD_HAUPPAUGE_HVR950Q:\n\t\t\trc->map_name = RC_MAP_HAUPPAUGE;\n\t\t\tir->get_key_i2c = au0828_get_key_au8522;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -ENODEV;\n\t\t\tgoto error;\n\t\t}\n\n\t\tir->i2c_dev_addr = i2c_rc_dev_addr;\n\t}\n\n\t \n\tir->polling = 100;  \n\n\t \n\tsnprintf(ir->name, sizeof(ir->name), \"au0828 IR (%s)\",\n\t\t dev->board.name);\n\n\tusb_make_path(dev->usbdev, ir->phys, sizeof(ir->phys));\n\tstrlcat(ir->phys, \"/input0\", sizeof(ir->phys));\n\n\trc->device_name = ir->name;\n\trc->input_phys = ir->phys;\n\trc->input_id.bustype = BUS_USB;\n\trc->input_id.version = 1;\n\trc->input_id.vendor = le16_to_cpu(dev->usbdev->descriptor.idVendor);\n\trc->input_id.product = le16_to_cpu(dev->usbdev->descriptor.idProduct);\n\trc->dev.parent = &dev->usbdev->dev;\n\trc->driver_name = \"au0828-input\";\n\trc->allowed_protocols = RC_PROTO_BIT_NEC | RC_PROTO_BIT_NECX |\n\t\t\t\tRC_PROTO_BIT_NEC32 | RC_PROTO_BIT_RC5;\n\n\t \n\terr = rc_register_device(rc);\n\tif (err)\n\t\tgoto error;\n\n\tpr_info(\"Remote controller %s initialized\\n\", ir->name);\n\n\treturn 0;\n\nerror:\n\tdev->ir = NULL;\n\trc_free_device(rc);\n\tkfree(ir);\n\treturn err;\n}\n\nvoid au0828_rc_unregister(struct au0828_dev *dev)\n{\n\tstruct au0828_rc *ir = dev->ir;\n\n\t \n\tif (!ir)\n\t\treturn;\n\n\trc_unregister_device(ir->rc);\n\n\t \n\tkfree(ir);\n\tdev->ir = NULL;\n}\n\nint au0828_rc_suspend(struct au0828_dev *dev)\n{\n\tstruct au0828_rc *ir = dev->ir;\n\n\tif (!ir)\n\t\treturn 0;\n\n\tpr_info(\"Stopping RC\\n\");\n\n\tcancel_delayed_work_sync(&ir->work);\n\n\t \n\tau8522_rc_clear(ir, 0xe0, 1 << 4);\n\n\treturn 0;\n}\n\nint au0828_rc_resume(struct au0828_dev *dev)\n{\n\tstruct au0828_rc *ir = dev->ir;\n\n\tif (!ir)\n\t\treturn 0;\n\n\tpr_info(\"Restarting RC\\n\");\n\n\t \n\tau8522_rc_set(ir, 0xe0, 1 << 4);\n\n\tschedule_delayed_work(&ir->work, msecs_to_jiffies(ir->polling));\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}