{
  "module_name": "au0828.h",
  "hash_id": "39df4701a0c8b835614d15b9ce0d643b9298f4a2189bd83e41cff6523bce9116",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/au0828/au0828.h",
  "human_readable_source": " \n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bitops.h>\n#include <linux/usb.h>\n#include <linux/i2c.h>\n#include <linux/i2c-algo-bit.h>\n#include <media/tveeprom.h>\n\n \n#include <linux/videodev2.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-vmalloc.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fh.h>\n#include <media/media-device.h>\n#include <media/media-dev-allocator.h>\n\n \n#include <media/demux.h>\n#include <media/dmxdev.h>\n#include <media/dvb_demux.h>\n#include <media/dvb_frontend.h>\n#include <media/dvb_net.h>\n#include <media/dvbdev.h>\n\n#include \"au0828-reg.h\"\n#include \"au0828-cards.h\"\n\n#define URB_COUNT   16\n#define URB_BUFSIZE (0xe522)\n\n \n#define NTSC_STD_W      720\n#define NTSC_STD_H      480\n\n#define AU0828_INTERLACED_DEFAULT       1\n\n \n#define AU0828_MAX_ISO_BUFS    12   \n#define AU0828_ISO_PACKETS_PER_URB      128\n\n#define AU0828_MIN_BUF 4\n#define AU0828_DEF_BUF 8\n\n#define AU0828_MAX_INPUT        4\n\n \n#define AU0828_RESOURCE_VIDEO 0x01\n#define AU0828_RESOURCE_VBI   0x02\n\nenum au0828_itype {\n\tAU0828_VMUX_UNDEFINED = 0,\n\tAU0828_VMUX_COMPOSITE,\n\tAU0828_VMUX_SVIDEO,\n\tAU0828_VMUX_CABLE,\n\tAU0828_VMUX_TELEVISION,\n\tAU0828_VMUX_DVB,\n};\n\nstruct au0828_input {\n\tenum au0828_itype type;\n\tunsigned int vmux;\n\tunsigned int amux;\n\tvoid (*audio_setup) (void *priv, int enable);\n};\n\nstruct au0828_board {\n\tchar *name;\n\tunsigned int tuner_type;\n\tunsigned char tuner_addr;\n\tunsigned char i2c_clk_divider;\n\tunsigned char has_ir_i2c:1;\n\tunsigned char has_analog:1;\n\tstruct au0828_input input[AU0828_MAX_INPUT];\n};\n\nstruct au0828_dvb {\n\tstruct mutex lock;\n\tstruct dvb_adapter adapter;\n\tstruct dvb_frontend *frontend;\n\tstruct dvb_demux demux;\n\tstruct dmxdev dmxdev;\n\tstruct dmx_frontend fe_hw;\n\tstruct dmx_frontend fe_mem;\n\tstruct dvb_net net;\n\tint feeding;\n\tint start_count;\n\tint stop_count;\n\n\tint (*set_frontend)(struct dvb_frontend *fe);\n};\n\nenum au0828_stream_state {\n\tSTREAM_OFF,\n\tSTREAM_INTERRUPT,\n\tSTREAM_ON\n};\n\n#define AUVI_INPUT(nr) (dev->board.input[nr])\n\n \nenum au0828_dev_state {\n\tDEV_INITIALIZED = 0,\n\tDEV_DISCONNECTED = 1,\n\tDEV_MISCONFIGURED = 2\n};\n\nstruct au0828_dev;\n\nstruct au0828_usb_isoc_ctl {\n\t\t \n\tint\t\t\t\tmax_pkt_size;\n\n\t\t \n\tint\t\t\t\tnum_bufs;\n\n\t\t \n\tstruct urb\t\t\t**urb;\n\n\t\t \n\tchar\t\t\t\t**transfer_buffer;\n\n\t\t \n\tu8\t\t\t\tcmd;\n\tint\t\t\t\tpos, size, pktsize;\n\n\t\t \n\tint\t\t\t\tfield;\n\n\t\t \n\tu32\t\t\t\ttmp_buf;\n\tint\t\t\t\ttmp_buf_len;\n\n\t\t \n\tstruct au0828_buffer\t\t*buf;\n\tstruct au0828_buffer\t\t*vbi_buf;\n\n\t\t \n\tint\t\t\t\tnfields;\n\n\t\t \n\tint (*isoc_copy) (struct au0828_dev *dev, struct urb *urb);\n\n};\n\n \nstruct au0828_buffer {\n\t \n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head list;\n\n\tvoid *mem;\n\tunsigned long length;\n\tint top_field;\n\t \n\tchar *vb_buf;\n};\n\nstruct au0828_dmaqueue {\n\tstruct list_head       active;\n\t \n\tint                    pos;\n};\n\nstruct au0828_dev {\n\tstruct mutex mutex;\n\tstruct usb_device\t*usbdev;\n\tint\t\t\tboardnr;\n\tstruct au0828_board\tboard;\n\tu8\t\t\tctrlmsg[64];\n\n\t \n\tstruct i2c_adapter\t\ti2c_adap;\n\tstruct i2c_algorithm\t\ti2c_algo;\n\tstruct i2c_client\t\ti2c_client;\n\tu32\t\t\t\ti2c_rc;\n\n\t \n\tstruct au0828_dvb\t\tdvb;\n\tstruct work_struct              restart_streaming;\n\tstruct timer_list               bulk_timeout;\n\tint                             bulk_timeout_running;\n\n#ifdef CONFIG_VIDEO_AU0828_V4L2\n\t \n\tstruct v4l2_device v4l2_dev;\n\tstruct v4l2_ctrl_handler v4l2_ctrl_hdl;\n#endif\n#ifdef CONFIG_VIDEO_AU0828_RC\n\tstruct au0828_rc *ir;\n#endif\n\n\tstruct video_device vdev;\n\tstruct video_device vbi_dev;\n\n\t \n\tstruct vb2_queue vb_vidq;\n\tstruct vb2_queue vb_vbiq;\n\tstruct mutex vb_queue_lock;\n\tstruct mutex vb_vbi_queue_lock;\n\n\tunsigned int frame_count;\n\tunsigned int vbi_frame_count;\n\n\tstruct timer_list vid_timeout;\n\tint vid_timeout_running;\n\tstruct timer_list vbi_timeout;\n\tint vbi_timeout_running;\n\n\tint users;\n\tint streaming_users;\n\n\tint width;\n\tint height;\n\tint vbi_width;\n\tint vbi_height;\n\tu32 vbi_read;\n\tv4l2_std_id std;\n\tu32 field_size;\n\tu32 frame_size;\n\tu32 bytesperline;\n\tint type;\n\tu8 ctrl_ainput;\n\t__u8 isoc_in_endpointaddr;\n\tu8 isoc_init_ok;\n\tint greenscreen_detected;\n\tint ctrl_freq;\n\tint input_type;\n\tint std_set_in_tuner_core;\n\tunsigned int ctrl_input;\n\tlong unsigned int dev_state;  ;\n\tenum au0828_stream_state stream_state;\n\twait_queue_head_t open;\n\n\tstruct mutex lock;\n\n\t \n\tstruct au0828_dmaqueue vidq;\n\tstruct au0828_dmaqueue vbiq;\n\tstruct au0828_usb_isoc_ctl isoc_ctl;\n\tspinlock_t slock;\n\n\t \n\tint alt;\t\t \n\tint max_pkt_size;\t \n\tint num_alt;\t\t \n\tunsigned int *alt_max_pkt_size;\t \n\tstruct urb *urb[AU0828_MAX_ISO_BUFS];\t \n\tchar *transfer_buffer[AU0828_MAX_ISO_BUFS]; \n\n\t \n\tbool\t\turb_streaming, need_urb_start;\n\tstruct urb\t*urbs[URB_COUNT];\n\n\t \n\n\tchar *dig_transfer_buffer[URB_COUNT];\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tstruct media_device *media_dev;\n\tstruct media_pad video_pad, vbi_pad;\n\tstruct media_entity *decoder;\n\tstruct media_entity input_ent[AU0828_MAX_INPUT];\n\tstruct media_pad input_pad[AU0828_MAX_INPUT];\n\tstruct media_entity_notify entity_notify;\n\tstruct media_entity *tuner;\n\tstruct media_link *active_link;\n\tstruct media_entity *active_source;\n\tstruct media_entity *active_sink;\n\tstruct media_entity *active_link_owner;\n\tstruct media_entity *active_link_user;\n\tstruct media_pipeline *active_link_user_pipe;\n\tbool active_link_shared;\n#endif\n};\n\n\n \n#define au0828_read(dev, reg) au0828_readreg(dev, reg)\n#define au0828_write(dev, reg, value) au0828_writereg(dev, reg, value)\n#define au0828_andor(dev, reg, mask, value)\t\t\t\t\\\n\t au0828_writereg(dev, reg,\t\t\t\t\t\\\n\t(au0828_readreg(dev, reg) & ~(mask)) | ((value) & (mask)))\n\n#define au0828_set(dev, reg, bit) au0828_andor(dev, (reg), (bit), (bit))\n#define au0828_clear(dev, reg, bit) au0828_andor(dev, (reg), (bit), 0)\n\n \n \nextern u32 au0828_read(struct au0828_dev *dev, u16 reg);\nextern u32 au0828_write(struct au0828_dev *dev, u16 reg, u32 val);\nextern void au0828_usb_release(struct au0828_dev *dev);\nextern int au0828_debug;\n\n \n \nextern struct au0828_board au0828_boards[];\nextern struct usb_device_id au0828_usb_id_table[];\nextern void au0828_gpio_setup(struct au0828_dev *dev);\nextern int au0828_tuner_callback(void *priv, int component,\n\t\t\t\t int command, int arg);\nextern void au0828_card_setup(struct au0828_dev *dev);\n\n \n \nextern int au0828_i2c_register(struct au0828_dev *dev);\nextern int au0828_i2c_unregister(struct au0828_dev *dev);\n\n \n \nextern int au0828_start_analog_streaming(struct vb2_queue *vq,\n\t\t\t\t\t\tunsigned int count);\nextern void au0828_stop_vbi_streaming(struct vb2_queue *vq);\n#ifdef CONFIG_VIDEO_AU0828_V4L2\nextern int au0828_v4l2_device_register(struct usb_interface *interface,\n\t\t\t\t      struct au0828_dev *dev);\n\nextern int au0828_analog_register(struct au0828_dev *dev,\n\t\t\t   struct usb_interface *interface);\nextern int au0828_analog_unregister(struct au0828_dev *dev);\nextern void au0828_usb_v4l2_media_release(struct au0828_dev *dev);\nextern void au0828_v4l2_suspend(struct au0828_dev *dev);\nextern void au0828_v4l2_resume(struct au0828_dev *dev);\n#else\nstatic inline int au0828_v4l2_device_register(struct usb_interface *interface,\n\t\t\t\t\t      struct au0828_dev *dev)\n{ return 0; };\nstatic inline int au0828_analog_register(struct au0828_dev *dev,\n\t\t\t\t     struct usb_interface *interface)\n{ return 0; };\nstatic inline int au0828_analog_unregister(struct au0828_dev *dev)\n{ return 0; };\nstatic inline void au0828_usb_v4l2_media_release(struct au0828_dev *dev) { };\nstatic inline void au0828_v4l2_suspend(struct au0828_dev *dev) { };\nstatic inline void au0828_v4l2_resume(struct au0828_dev *dev) { };\n#endif\n\n \n \nextern int au0828_dvb_register(struct au0828_dev *dev);\nextern void au0828_dvb_unregister(struct au0828_dev *dev);\nvoid au0828_dvb_suspend(struct au0828_dev *dev);\nvoid au0828_dvb_resume(struct au0828_dev *dev);\n\n \nextern const struct vb2_ops au0828_vbi_qops;\n\n#define dprintk(level, fmt, arg...)\\\n\tdo { if (au0828_debug & level)\\\n\t\tprintk(KERN_DEBUG pr_fmt(fmt), ## arg);\\\n\t} while (0)\n\n \n#ifdef CONFIG_VIDEO_AU0828_RC\nextern int au0828_rc_register(struct au0828_dev *dev);\nextern void au0828_rc_unregister(struct au0828_dev *dev);\nextern int au0828_rc_suspend(struct au0828_dev *dev);\nextern int au0828_rc_resume(struct au0828_dev *dev);\n#else\nstatic inline int au0828_rc_register(struct au0828_dev *dev) { return 0; }\nstatic inline void au0828_rc_unregister(struct au0828_dev *dev) { }\nstatic inline int au0828_rc_suspend(struct au0828_dev *dev) { return 0; }\nstatic inline int au0828_rc_resume(struct au0828_dev *dev) { return 0; }\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}