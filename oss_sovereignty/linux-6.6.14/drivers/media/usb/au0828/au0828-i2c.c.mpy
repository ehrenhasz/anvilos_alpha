{
  "module_name": "au0828-i2c.c",
  "hash_id": "4eede7eb1fb36424c209cf88c66aa6cbdedeaec1c7cee1d62d354313adb2db43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/au0828/au0828-i2c.c",
  "human_readable_source": "\n \n\n#include \"au0828.h\"\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n\n#include \"media/tuner.h\"\n#include <media/v4l2-common.h>\n\nstatic int i2c_scan;\nmodule_param(i2c_scan, int, 0444);\nMODULE_PARM_DESC(i2c_scan, \"scan i2c bus at insmod time\");\n\n#define I2C_WAIT_DELAY 25\n#define I2C_WAIT_RETRY 1000\n\nstatic inline int i2c_slave_did_read_ack(struct i2c_adapter *i2c_adap)\n{\n\tstruct au0828_dev *dev = i2c_adap->algo_data;\n\treturn au0828_read(dev, AU0828_I2C_STATUS_201) &\n\t\tAU0828_I2C_STATUS_NO_READ_ACK ? 0 : 1;\n}\n\nstatic int i2c_wait_read_ack(struct i2c_adapter *i2c_adap)\n{\n\tint count;\n\n\tfor (count = 0; count < I2C_WAIT_RETRY; count++) {\n\t\tif (!i2c_slave_did_read_ack(i2c_adap))\n\t\t\tbreak;\n\t\tudelay(I2C_WAIT_DELAY);\n\t}\n\n\tif (I2C_WAIT_RETRY == count)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic inline int i2c_is_read_busy(struct i2c_adapter *i2c_adap)\n{\n\tstruct au0828_dev *dev = i2c_adap->algo_data;\n\treturn au0828_read(dev, AU0828_I2C_STATUS_201) &\n\t\tAU0828_I2C_STATUS_READ_DONE ? 0 : 1;\n}\n\nstatic int i2c_wait_read_done(struct i2c_adapter *i2c_adap)\n{\n\tint count;\n\n\tfor (count = 0; count < I2C_WAIT_RETRY; count++) {\n\t\tif (!i2c_is_read_busy(i2c_adap))\n\t\t\tbreak;\n\t\tudelay(I2C_WAIT_DELAY);\n\t}\n\n\tif (I2C_WAIT_RETRY == count)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic inline int i2c_is_write_done(struct i2c_adapter *i2c_adap)\n{\n\tstruct au0828_dev *dev = i2c_adap->algo_data;\n\treturn au0828_read(dev, AU0828_I2C_STATUS_201) &\n\t\tAU0828_I2C_STATUS_WRITE_DONE ? 1 : 0;\n}\n\nstatic int i2c_wait_write_done(struct i2c_adapter *i2c_adap)\n{\n\tint count;\n\n\tfor (count = 0; count < I2C_WAIT_RETRY; count++) {\n\t\tif (i2c_is_write_done(i2c_adap))\n\t\t\tbreak;\n\t\tudelay(I2C_WAIT_DELAY);\n\t}\n\n\tif (I2C_WAIT_RETRY == count)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic inline int i2c_is_busy(struct i2c_adapter *i2c_adap)\n{\n\tstruct au0828_dev *dev = i2c_adap->algo_data;\n\treturn au0828_read(dev, AU0828_I2C_STATUS_201) &\n\t\tAU0828_I2C_STATUS_BUSY ? 1 : 0;\n}\n\nstatic int i2c_wait_done(struct i2c_adapter *i2c_adap)\n{\n\tint count;\n\n\tfor (count = 0; count < I2C_WAIT_RETRY; count++) {\n\t\tif (!i2c_is_busy(i2c_adap))\n\t\t\tbreak;\n\t\tudelay(I2C_WAIT_DELAY);\n\t}\n\n\tif (I2C_WAIT_RETRY == count)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic int i2c_sendbytes(struct i2c_adapter *i2c_adap,\n\tconst struct i2c_msg *msg, int joined_rlen)\n{\n\tint i, strobe = 0;\n\tstruct au0828_dev *dev = i2c_adap->algo_data;\n\tu8 i2c_speed = dev->board.i2c_clk_divider;\n\n\tdprintk(4, \"%s()\\n\", __func__);\n\n\tau0828_write(dev, AU0828_I2C_MULTIBYTE_MODE_2FF, 0x01);\n\n\tif (((dev->board.tuner_type == TUNER_XC5000) ||\n\t     (dev->board.tuner_type == TUNER_XC5000C)) &&\n\t    (dev->board.tuner_addr == msg->addr)) {\n\t\t \n\t\tif (msg->len == 64)\n\t\t\ti2c_speed = AU0828_I2C_CLK_250KHZ;\n\t\telse\n\t\t\ti2c_speed = AU0828_I2C_CLK_20KHZ;\n\t}\n\t \n\tau0828_write(dev, AU0828_I2C_CLK_DIVIDER_202, i2c_speed);\n\n\t \n\tau0828_write(dev, AU0828_I2C_DEST_ADDR_203, msg->addr << 1);\n\n\tdprintk(4, \"SEND: %02x\\n\", msg->addr);\n\n\t \n\tif (msg->len == 0) {\n\t\t \n\t\tau0828_write(dev, AU0828_I2C_TRIGGER_200,\n\t\t\t     AU0828_I2C_TRIGGER_READ);\n\n\t\tif (!i2c_wait_done(i2c_adap))\n\t\t\treturn -EIO;\n\n\t\tif (i2c_wait_read_ack(i2c_adap))\n\t\t\treturn -EIO;\n\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < msg->len;) {\n\n\t\tdprintk(4, \" %02x\\n\", msg->buf[i]);\n\n\t\tau0828_write(dev, AU0828_I2C_WRITE_FIFO_205, msg->buf[i]);\n\n\t\tstrobe++;\n\t\ti++;\n\n\t\tif ((strobe >= 4) || (i >= msg->len)) {\n\n\t\t\t \n\t\t\tif (i < msg->len)\n\t\t\t\tau0828_write(dev, AU0828_I2C_TRIGGER_200,\n\t\t\t\t\t     AU0828_I2C_TRIGGER_WRITE |\n\t\t\t\t\t     AU0828_I2C_TRIGGER_HOLD);\n\t\t\telse\n\t\t\t\tau0828_write(dev, AU0828_I2C_TRIGGER_200,\n\t\t\t\t\t     AU0828_I2C_TRIGGER_WRITE);\n\n\t\t\t \n\t\t\tstrobe = 0;\n\n\t\t\tif (!i2c_wait_write_done(i2c_adap))\n\t\t\t\treturn -EIO;\n\n\t\t}\n\n\t}\n\tif (!i2c_wait_done(i2c_adap))\n\t\treturn -EIO;\n\n\tdprintk(4, \"\\n\");\n\n\treturn msg->len;\n}\n\n \nstatic int i2c_readbytes(struct i2c_adapter *i2c_adap,\n\tconst struct i2c_msg *msg, int joined)\n{\n\tstruct au0828_dev *dev = i2c_adap->algo_data;\n\tu8 i2c_speed = dev->board.i2c_clk_divider;\n\tint i;\n\n\tdprintk(4, \"%s()\\n\", __func__);\n\n\tau0828_write(dev, AU0828_I2C_MULTIBYTE_MODE_2FF, 0x01);\n\n\t \n\tif (((dev->board.tuner_type == TUNER_XC5000) ||\n\t     (dev->board.tuner_type == TUNER_XC5000C)) &&\n\t    (dev->board.tuner_addr == msg->addr))\n\t\ti2c_speed = AU0828_I2C_CLK_20KHZ;\n\n\t \n\tau0828_write(dev, AU0828_I2C_CLK_DIVIDER_202, i2c_speed);\n\n\t \n\tau0828_write(dev, AU0828_I2C_DEST_ADDR_203, msg->addr << 1);\n\n\tdprintk(4, \" RECV:\\n\");\n\n\t \n\tif (msg->len == 0) {\n\t\tau0828_write(dev, AU0828_I2C_TRIGGER_200,\n\t\t\t     AU0828_I2C_TRIGGER_READ);\n\n\t\tif (i2c_wait_read_ack(i2c_adap))\n\t\t\treturn -EIO;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < msg->len;) {\n\n\t\ti++;\n\n\t\tif (i < msg->len)\n\t\t\tau0828_write(dev, AU0828_I2C_TRIGGER_200,\n\t\t\t\t     AU0828_I2C_TRIGGER_READ |\n\t\t\t\t     AU0828_I2C_TRIGGER_HOLD);\n\t\telse\n\t\t\tau0828_write(dev, AU0828_I2C_TRIGGER_200,\n\t\t\t\t     AU0828_I2C_TRIGGER_READ);\n\n\t\tif (!i2c_wait_read_done(i2c_adap))\n\t\t\treturn -EIO;\n\n\t\tmsg->buf[i-1] = au0828_read(dev, AU0828_I2C_READ_FIFO_209) &\n\t\t\t0xff;\n\n\t\tdprintk(4, \" %02x\\n\", msg->buf[i-1]);\n\t}\n\tif (!i2c_wait_done(i2c_adap))\n\t\treturn -EIO;\n\n\tdprintk(4, \"\\n\");\n\n\treturn msg->len;\n}\n\nstatic int i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t    struct i2c_msg *msgs, int num)\n{\n\tint i, retval = 0;\n\n\tdprintk(4, \"%s(num = %d)\\n\", __func__, num);\n\n\tfor (i = 0; i < num; i++) {\n\t\tdprintk(4, \"%s(num = %d) addr = 0x%02x  len = 0x%x\\n\",\n\t\t\t__func__, num, msgs[i].addr, msgs[i].len);\n\t\tif (msgs[i].flags & I2C_M_RD) {\n\t\t\t \n\t\t\tretval = i2c_readbytes(i2c_adap, &msgs[i], 0);\n\t\t} else if (i + 1 < num && (msgs[i + 1].flags & I2C_M_RD) &&\n\t\t\t   msgs[i].addr == msgs[i + 1].addr) {\n\t\t\t \n\t\t\tretval = i2c_sendbytes(i2c_adap, &msgs[i],\n\t\t\t\t\t       msgs[i + 1].len);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto err;\n\t\t\ti++;\n\t\t\tretval = i2c_readbytes(i2c_adap, &msgs[i], 1);\n\t\t} else {\n\t\t\t \n\t\t\tretval = i2c_sendbytes(i2c_adap, &msgs[i], 0);\n\t\t}\n\t\tif (retval < 0)\n\t\t\tgoto err;\n\t}\n\treturn num;\n\nerr:\n\treturn retval;\n}\n\nstatic u32 au0828_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_SMBUS_EMUL | I2C_FUNC_I2C;\n}\n\nstatic const struct i2c_algorithm au0828_i2c_algo_template = {\n\t.master_xfer\t= i2c_xfer,\n\t.functionality\t= au0828_functionality,\n};\n\n \n\nstatic const struct i2c_adapter au0828_i2c_adap_template = {\n\t.name              = KBUILD_MODNAME,\n\t.owner             = THIS_MODULE,\n\t.algo              = &au0828_i2c_algo_template,\n};\n\nstatic const struct i2c_client au0828_i2c_client_template = {\n\t.name\t= \"au0828 internal\",\n};\n\nstatic char *i2c_devs[128] = {\n\t[0x8e >> 1] = \"au8522\",\n\t[0xa0 >> 1] = \"eeprom\",\n\t[0xc2 >> 1] = \"tuner/xc5000\",\n};\n\nstatic void do_i2c_scan(char *name, struct i2c_client *c)\n{\n\tunsigned char buf;\n\tint i, rc;\n\n\tfor (i = 0; i < 128; i++) {\n\t\tc->addr = i;\n\t\trc = i2c_master_recv(c, &buf, 0);\n\t\tif (rc < 0)\n\t\t\tcontinue;\n\t\tpr_info(\"%s: i2c scan: found device @ 0x%x  [%s]\\n\",\n\t\t       name, i << 1, i2c_devs[i] ? i2c_devs[i] : \"???\");\n\t}\n}\n\n \nint au0828_i2c_register(struct au0828_dev *dev)\n{\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tdev->i2c_adap = au0828_i2c_adap_template;\n\tdev->i2c_algo = au0828_i2c_algo_template;\n\tdev->i2c_client = au0828_i2c_client_template;\n\n\tdev->i2c_adap.dev.parent = &dev->usbdev->dev;\n\n\tstrscpy(dev->i2c_adap.name, KBUILD_MODNAME,\n\t\tsizeof(dev->i2c_adap.name));\n\n\tdev->i2c_adap.algo = &dev->i2c_algo;\n\tdev->i2c_adap.algo_data = dev;\n#ifdef CONFIG_VIDEO_AU0828_V4L2\n\ti2c_set_adapdata(&dev->i2c_adap, &dev->v4l2_dev);\n#else\n\ti2c_set_adapdata(&dev->i2c_adap, dev);\n#endif\n\ti2c_add_adapter(&dev->i2c_adap);\n\n\tdev->i2c_client.adapter = &dev->i2c_adap;\n\n\tif (0 == dev->i2c_rc) {\n\t\tpr_info(\"i2c bus registered\\n\");\n\t\tif (i2c_scan)\n\t\t\tdo_i2c_scan(KBUILD_MODNAME, &dev->i2c_client);\n\t} else\n\t\tpr_info(\"i2c bus register FAILED\\n\");\n\n\treturn dev->i2c_rc;\n}\n\nint au0828_i2c_unregister(struct au0828_dev *dev)\n{\n\ti2c_del_adapter(&dev->i2c_adap);\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}