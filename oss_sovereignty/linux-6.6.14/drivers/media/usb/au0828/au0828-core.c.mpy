{
  "module_name": "au0828-core.c",
  "hash_id": "303eced9a2d5c0d8c386f1907c28926d68f3e869a61cb63a69ecb9aeded189ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/au0828/au0828-core.c",
  "human_readable_source": "\n \n\n#include \"au0828.h\"\n#include \"au8522.h\"\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-common.h>\n#include <linux/mutex.h>\n\n \n#include <media/tuner.h>\n\n \nint au0828_debug;\nmodule_param_named(debug, au0828_debug, int, 0644);\nMODULE_PARM_DESC(debug,\n\t\t \"set debug bitmask: 1=general, 2=USB, 4=I2C, 8=bridge, 16=IR\");\n\nstatic unsigned int disable_usb_speed_check;\nmodule_param(disable_usb_speed_check, int, 0444);\nMODULE_PARM_DESC(disable_usb_speed_check,\n\t\t \"override min bandwidth requirement of 480M bps\");\n\n#define _AU0828_BULKPIPE 0x03\n#define _BULKPIPESIZE 0xffff\n\nstatic int send_control_msg(struct au0828_dev *dev, u16 request, u32 value,\n\t\t\t    u16 index);\nstatic int recv_control_msg(struct au0828_dev *dev, u16 request, u32 value,\n\tu16 index, unsigned char *cp, u16 size);\n\n \n#define CMD_REQUEST_IN\t\t0x00\n#define CMD_REQUEST_OUT\t\t0x01\n\nu32 au0828_readreg(struct au0828_dev *dev, u16 reg)\n{\n\tu8 result = 0;\n\n\trecv_control_msg(dev, CMD_REQUEST_IN, 0, reg, &result, 1);\n\tdprintk(8, \"%s(0x%04x) = 0x%02x\\n\", __func__, reg, result);\n\n\treturn result;\n}\n\nu32 au0828_writereg(struct au0828_dev *dev, u16 reg, u32 val)\n{\n\tdprintk(8, \"%s(0x%04x, 0x%02x)\\n\", __func__, reg, val);\n\treturn send_control_msg(dev, CMD_REQUEST_OUT, val, reg);\n}\n\nstatic int send_control_msg(struct au0828_dev *dev, u16 request, u32 value,\n\tu16 index)\n{\n\tint status = -ENODEV;\n\n\tif (dev->usbdev) {\n\n\t\t \n\t\tstatus = usb_control_msg(dev->usbdev,\n\t\t\t\tusb_sndctrlpipe(dev->usbdev, 0),\n\t\t\t\trequest,\n\t\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t\tUSB_RECIP_DEVICE,\n\t\t\t\tvalue, index, NULL, 0, 1000);\n\n\t\tstatus = min(status, 0);\n\n\t\tif (status < 0) {\n\t\t\tpr_err(\"%s() Failed sending control message, error %d.\\n\",\n\t\t\t\t__func__, status);\n\t\t}\n\n\t}\n\n\treturn status;\n}\n\nstatic int recv_control_msg(struct au0828_dev *dev, u16 request, u32 value,\n\tu16 index, unsigned char *cp, u16 size)\n{\n\tint status = -ENODEV;\n\tmutex_lock(&dev->mutex);\n\tif (dev->usbdev) {\n\t\tstatus = usb_control_msg(dev->usbdev,\n\t\t\t\tusb_rcvctrlpipe(dev->usbdev, 0),\n\t\t\t\trequest,\n\t\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\tvalue, index,\n\t\t\t\tdev->ctrlmsg, size, 1000);\n\n\t\tstatus = min(status, 0);\n\n\t\tif (status < 0) {\n\t\t\tpr_err(\"%s() Failed receiving control message, error %d.\\n\",\n\t\t\t\t__func__, status);\n\t\t}\n\n\t\t \n\t\tmemcpy(cp, dev->ctrlmsg, size);\n\t}\n\tmutex_unlock(&dev->mutex);\n\treturn status;\n}\n\n#ifdef CONFIG_MEDIA_CONTROLLER\nstatic void au0828_media_graph_notify(struct media_entity *new,\n\t\t\t\t      void *notify_data);\n#endif\n\nstatic void au0828_unregister_media_device(struct au0828_dev *dev)\n{\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tstruct media_device *mdev = dev->media_dev;\n\tstruct media_entity_notify *notify, *nextp;\n\n\tif (!mdev || !media_devnode_is_registered(mdev->devnode))\n\t\treturn;\n\n\t \n\tlist_for_each_entry_safe(notify, nextp, &mdev->entity_notify, list) {\n\t\tif (notify->notify != au0828_media_graph_notify)\n\t\t\tcontinue;\n\t\tmedia_device_unregister_entity_notify(mdev, notify);\n\t}\n\n\t \n\tmutex_lock(&mdev->graph_mutex);\n\tdev->media_dev->source_priv = NULL;\n\tdev->media_dev->enable_source = NULL;\n\tdev->media_dev->disable_source = NULL;\n\tmutex_unlock(&mdev->graph_mutex);\n\n\tmedia_device_delete(dev->media_dev, KBUILD_MODNAME, THIS_MODULE);\n\tdev->media_dev = NULL;\n#endif\n}\n\nvoid au0828_usb_release(struct au0828_dev *dev)\n{\n\tau0828_unregister_media_device(dev);\n\n\t \n\tau0828_i2c_unregister(dev);\n\n\tkfree(dev);\n}\n\nstatic void au0828_usb_disconnect(struct usb_interface *interface)\n{\n\tstruct au0828_dev *dev = usb_get_intfdata(interface);\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t \n\tset_bit(DEV_DISCONNECTED, &dev->dev_state);\n\n\tau0828_rc_unregister(dev);\n\t \n\tau0828_dvb_unregister(dev);\n\n\tusb_set_intfdata(interface, NULL);\n\tmutex_lock(&dev->mutex);\n\tdev->usbdev = NULL;\n\tmutex_unlock(&dev->mutex);\n\tif (au0828_analog_unregister(dev)) {\n\t\t \n\t\treturn;\n\t}\n\tau0828_usb_release(dev);\n}\n\nstatic int au0828_media_device_init(struct au0828_dev *dev,\n\t\t\t\t    struct usb_device *udev)\n{\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tstruct media_device *mdev;\n\n\tmdev = media_device_usb_allocate(udev, KBUILD_MODNAME, THIS_MODULE);\n\tif (IS_ERR(mdev))\n\t\treturn PTR_ERR(mdev);\n\n\tdev->media_dev = mdev;\n#endif\n\treturn 0;\n}\n\n#ifdef CONFIG_MEDIA_CONTROLLER\nstatic void au0828_media_graph_notify(struct media_entity *new,\n\t\t\t\t      void *notify_data)\n{\n\tstruct au0828_dev *dev = notify_data;\n\tint ret;\n\tstruct media_entity *entity, *mixer = NULL, *decoder = NULL;\n\n\tif (!new) {\n\t\t \n\t\tmedia_device_for_each_entity(entity, dev->media_dev) {\n\t\t\tif (entity->function == MEDIA_ENT_F_AUDIO_MIXER)\n\t\t\t\tmixer = entity;\n\t\t\telse if (entity->function == MEDIA_ENT_F_ATV_DECODER)\n\t\t\t\tdecoder = entity;\n\t\t}\n\t\tgoto create_link;\n\t}\n\n\tswitch (new->function) {\n\tcase MEDIA_ENT_F_AUDIO_MIXER:\n\t\tmixer = new;\n\t\tif (dev->decoder)\n\t\t\tdecoder = dev->decoder;\n\t\tbreak;\n\tcase MEDIA_ENT_F_ATV_DECODER:\n\t\t \n\t\tmedia_device_for_each_entity(entity, dev->media_dev) {\n\t\t\tif (entity->function == MEDIA_ENT_F_AUDIO_MIXER)\n\t\t\t\tmixer = entity;\n\t\t}\n\t\tdecoder = new;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\ncreate_link:\n\tif (decoder && mixer) {\n\t\tret = media_get_pad_index(decoder, MEDIA_PAD_FL_SOURCE,\n\t\t\t\t\t  PAD_SIGNAL_AUDIO);\n\t\tif (ret >= 0)\n\t\t\tret = media_create_pad_link(decoder, ret,\n\t\t\t\t\t\t    mixer, 0,\n\t\t\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\t\tif (ret < 0)\n\t\t\tdev_err(&dev->usbdev->dev,\n\t\t\t\t\"Mixer Pad Link Create Error: %d\\n\", ret);\n\t}\n}\n\nstatic bool au0828_is_link_shareable(struct media_entity *owner,\n\t\t\t\t     struct media_entity *entity)\n{\n\tbool shareable = false;\n\n\t \n\tswitch (owner->function) {\n\tcase MEDIA_ENT_F_IO_V4L:\n\tcase MEDIA_ENT_F_AUDIO_CAPTURE:\n\tcase MEDIA_ENT_F_IO_VBI:\n\t\tif (entity->function == MEDIA_ENT_F_IO_V4L ||\n\t\t    entity->function == MEDIA_ENT_F_AUDIO_CAPTURE ||\n\t\t    entity->function == MEDIA_ENT_F_IO_VBI)\n\t\t\tshareable = true;\n\t\tbreak;\n\tcase MEDIA_ENT_F_DTV_DEMOD:\n\tdefault:\n\t\tbreak;\n\t}\n\treturn shareable;\n}\n\n \nstatic int au0828_enable_source(struct media_entity *entity,\n\t\t\t\tstruct media_pipeline *pipe)\n{\n\tstruct media_entity  *source, *find_source;\n\tstruct media_entity *sink;\n\tstruct media_link *link, *found_link = NULL;\n\tint ret = 0;\n\tstruct media_device *mdev = entity->graph_obj.mdev;\n\tstruct au0828_dev *dev;\n\n\tif (!mdev)\n\t\treturn -ENODEV;\n\n\tdev = mdev->source_priv;\n\n\t \n\tif (entity->function == MEDIA_ENT_F_DTV_DEMOD) {\n\t\tsink = entity;\n\t\tfind_source = dev->tuner;\n\t} else {\n\t\t \n\t\tif (!dev->decoder) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto end;\n\t\t}\n\n\t\tsink = dev->decoder;\n\n\t\t \n\t\tif (dev->input_type == AU0828_VMUX_TELEVISION)\n\t\t\tfind_source = dev->tuner;\n\t\telse if (dev->input_type == AU0828_VMUX_SVIDEO ||\n\t\t\t dev->input_type == AU0828_VMUX_COMPOSITE)\n\t\t\tfind_source = &dev->input_ent[dev->input_type];\n\t\telse {\n\t\t\t \n\t\t\tret = 0;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\t \n\tif (dev->active_link) {\n\t\tif (dev->active_link_owner == entity) {\n\t\t\t \n\t\t\tpr_debug(\"%s already owns the tuner\\n\", entity->name);\n\t\t\tret = 0;\n\t\t\tgoto end;\n\t\t} else if (au0828_is_link_shareable(dev->active_link_owner,\n\t\t\t   entity)) {\n\t\t\t \n\t\t\tdev->active_link_shared = true;\n\t\t\t \n\t\t\tdev->active_link_user = entity;\n\t\t\tdev->active_link_user_pipe = pipe;\n\t\t\tpr_debug(\"%s owns the tuner %s can share!\\n\",\n\t\t\t\t dev->active_link_owner->name,\n\t\t\t\t entity->name);\n\t\t\tret = 0;\n\t\t\tgoto end;\n\t\t} else {\n\t\t\tret = -EBUSY;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tlist_for_each_entry(link, &sink->links, list) {\n\t\t \n\t\tif (link->sink->entity == sink &&\n\t\t    link->source->entity == find_source) {\n\t\t\tfound_link = link;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found_link) {\n\t\tret = -ENODEV;\n\t\tgoto end;\n\t}\n\n\t \n\tsource = found_link->source->entity;\n\tret = __media_entity_setup_link(found_link, MEDIA_LNK_FL_ENABLED);\n\tif (ret) {\n\t\tpr_err(\"Activate link from %s->%s. Error %d\\n\",\n\t\t\tsource->name, sink->name, ret);\n\t\tgoto end;\n\t}\n\n\tret = __media_pipeline_start(entity->pads, pipe);\n\tif (ret) {\n\t\tpr_err(\"Start Pipeline: %s->%s Error %d\\n\",\n\t\t\tsource->name, entity->name, ret);\n\t\tret = __media_entity_setup_link(found_link, 0);\n\t\tif (ret)\n\t\t\tpr_err(\"Deactivate link Error %d\\n\", ret);\n\t\tgoto end;\n\t}\n\n\t \n\tdev->active_link = found_link;\n\tdev->active_link_owner = entity;\n\tdev->active_source = source;\n\tdev->active_sink = sink;\n\n\tpr_info(\"Enabled Source: %s->%s->%s Ret %d\\n\",\n\t\t dev->active_source->name, dev->active_sink->name,\n\t\t dev->active_link_owner->name, ret);\nend:\n\tpr_debug(\"%s end: ent:%s fnc:%d ret %d\\n\",\n\t\t __func__, entity->name, entity->function, ret);\n\treturn ret;\n}\n\n \nstatic void au0828_disable_source(struct media_entity *entity)\n{\n\tint ret = 0;\n\tstruct media_device *mdev = entity->graph_obj.mdev;\n\tstruct au0828_dev *dev;\n\n\tif (!mdev)\n\t\treturn;\n\n\tdev = mdev->source_priv;\n\n\tif (!dev->active_link)\n\t\treturn;\n\n\t \n\tif (dev->active_link->sink->entity == dev->active_sink &&\n\t    dev->active_link->source->entity == dev->active_source) {\n\t\t \n\t\tbool owner_is_audio = false;\n\n\t\tif (dev->active_link_owner->function ==\n\t\t    MEDIA_ENT_F_AUDIO_CAPTURE)\n\t\t\towner_is_audio = true;\n\n\t\tif (dev->active_link_shared) {\n\t\t\tpr_debug(\"Shared link owner %s user %s %d\\n\",\n\t\t\t\t dev->active_link_owner->name,\n\t\t\t\t entity->name, dev->users);\n\n\t\t\t \n\t\t\tif (dev->active_link_owner != entity) {\n\t\t\t\t \n\t\t\t\tif (owner_is_audio && dev->users > 1)\n\t\t\t\t\treturn;\n\n\t\t\t\tdev->active_link_user = NULL;\n\t\t\t\tdev->active_link_user_pipe = NULL;\n\t\t\t\tdev->active_link_shared = false;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!owner_is_audio && dev->users > 1)\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\t__media_pipeline_stop(dev->active_link_owner->pads);\n\t\t\tpr_debug(\"Pipeline stop for %s\\n\",\n\t\t\t\tdev->active_link_owner->name);\n\n\t\t\tret = __media_pipeline_start(\n\t\t\t\t\tdev->active_link_user->pads,\n\t\t\t\t\tdev->active_link_user_pipe);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"Start Pipeline: %s->%s %d\\n\",\n\t\t\t\t\tdev->active_source->name,\n\t\t\t\t\tdev->active_link_user->name,\n\t\t\t\t\tret);\n\t\t\t\tgoto deactivate_link;\n\t\t\t}\n\t\t\t \n\t\t\tdev->active_link_owner = dev->active_link_user;\n\t\t\tdev->active_link_user = NULL;\n\t\t\tdev->active_link_user_pipe = NULL;\n\t\t\tdev->active_link_shared = false;\n\n\t\t\tpr_debug(\"Pipeline started for %s\\n\",\n\t\t\t\tdev->active_link_owner->name);\n\t\t\treturn;\n\t\t} else if (!owner_is_audio && dev->users > 1)\n\t\t\t \n\t\t\treturn;\n\n\t\tif (dev->active_link_owner != entity)\n\t\t\treturn;\n\n\t\t \n\t\t__media_pipeline_stop(dev->active_link_owner->pads);\n\t\tpr_debug(\"Pipeline stop for %s\\n\",\n\t\t\tdev->active_link_owner->name);\n\ndeactivate_link:\n\t\tret = __media_entity_setup_link(dev->active_link, 0);\n\t\tif (ret)\n\t\t\tpr_err(\"Deactivate link Error %d\\n\", ret);\n\n\t\tpr_info(\"Disabled Source: %s->%s->%s Ret %d\\n\",\n\t\t\t dev->active_source->name, dev->active_sink->name,\n\t\t\t dev->active_link_owner->name, ret);\n\n\t\tdev->active_link = NULL;\n\t\tdev->active_link_owner = NULL;\n\t\tdev->active_source = NULL;\n\t\tdev->active_sink = NULL;\n\t\tdev->active_link_shared = false;\n\t\tdev->active_link_user = NULL;\n\t}\n}\n#endif\n\nstatic int au0828_media_device_register(struct au0828_dev *dev,\n\t\t\t\t\tstruct usb_device *udev)\n{\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tint ret;\n\tstruct media_entity *entity, *demod = NULL;\n\tstruct media_link *link;\n\n\tif (!dev->media_dev)\n\t\treturn 0;\n\n\tif (!media_devnode_is_registered(dev->media_dev->devnode)) {\n\n\t\t \n\t\tret = media_device_register(dev->media_dev);\n\t\tif (ret) {\n\t\t\tmedia_device_delete(dev->media_dev, KBUILD_MODNAME,\n\t\t\t\t\t    THIS_MODULE);\n\t\t\tdev->media_dev = NULL;\n\t\t\tdev_err(&udev->dev,\n\t\t\t\t\"Media Device Register Error: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\t \n\t\tau0828_media_graph_notify(NULL, (void *) dev);\n\t}\n\n\t \n\tmedia_device_for_each_entity(entity, dev->media_dev) {\n\t\tswitch (entity->function) {\n\t\tcase MEDIA_ENT_F_TUNER:\n\t\t\tdev->tuner = entity;\n\t\t\tbreak;\n\t\tcase MEDIA_ENT_F_ATV_DECODER:\n\t\t\tdev->decoder = entity;\n\t\t\tbreak;\n\t\tcase MEDIA_ENT_F_DTV_DEMOD:\n\t\t\tdemod = entity;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (dev->tuner) {\n\t\tlist_for_each_entry(link, &dev->tuner->links, list) {\n\t\t\tif (demod && link->sink->entity == demod)\n\t\t\t\tmedia_entity_setup_link(link, 0);\n\t\t\tif (dev->decoder && link->sink->entity == dev->decoder)\n\t\t\t\tmedia_entity_setup_link(link, 0);\n\t\t}\n\t}\n\n\t \n\tdev->entity_notify.notify_data = (void *) dev;\n\tdev->entity_notify.notify = (void *) au0828_media_graph_notify;\n\tmedia_device_register_entity_notify(dev->media_dev,\n\t\t\t\t\t\t  &dev->entity_notify);\n\n\t \n\tmutex_lock(&dev->media_dev->graph_mutex);\n\tdev->media_dev->source_priv = (void *) dev;\n\tdev->media_dev->enable_source = au0828_enable_source;\n\tdev->media_dev->disable_source = au0828_disable_source;\n\tmutex_unlock(&dev->media_dev->graph_mutex);\n#endif\n\treturn 0;\n}\n\nstatic int au0828_usb_probe(struct usb_interface *interface,\n\tconst struct usb_device_id *id)\n{\n\tint ifnum;\n\tint retval = 0;\n\n\tstruct au0828_dev *dev;\n\tstruct usb_device *usbdev = interface_to_usbdev(interface);\n\n\tifnum = interface->altsetting->desc.bInterfaceNumber;\n\n\tif (ifnum != 0)\n\t\treturn -ENODEV;\n\n\tdprintk(1, \"%s() vendor id 0x%x device id 0x%x ifnum:%d\\n\", __func__,\n\t\tle16_to_cpu(usbdev->descriptor.idVendor),\n\t\tle16_to_cpu(usbdev->descriptor.idProduct),\n\t\tifnum);\n\n\t \n\tif (usbdev->speed != USB_SPEED_HIGH && disable_usb_speed_check == 0) {\n\t\tpr_err(\"au0828: Device initialization failed.\\n\");\n\t\tpr_err(\"au0828: Device must be connected to a high-speed USB 2.0 port.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (dev == NULL) {\n\t\tpr_err(\"%s() Unable to allocate memory\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&dev->lock);\n\tmutex_lock(&dev->lock);\n\tmutex_init(&dev->mutex);\n\tmutex_init(&dev->dvb.lock);\n\tdev->usbdev = usbdev;\n\tdev->boardnr = id->driver_info;\n\tdev->board = au0828_boards[dev->boardnr];\n\n\t \n\tretval = au0828_media_device_init(dev, usbdev);\n\tif (retval) {\n\t\tpr_err(\"%s() au0828_media_device_init failed\\n\",\n\t\t       __func__);\n\t\tmutex_unlock(&dev->lock);\n\t\tkfree(dev);\n\t\treturn retval;\n\t}\n\n\tretval = au0828_v4l2_device_register(interface, dev);\n\tif (retval) {\n\t\tau0828_usb_v4l2_media_release(dev);\n\t\tmutex_unlock(&dev->lock);\n\t\tkfree(dev);\n\t\treturn retval;\n\t}\n\n\t \n\tau0828_write(dev, REG_600, 1 << 4);\n\n\t \n\tau0828_gpio_setup(dev);\n\n\t \n\tau0828_i2c_register(dev);\n\n\t \n\tau0828_card_setup(dev);\n\n\t \n\tusb_set_intfdata(interface, dev);\n\n\t \n\tretval = au0828_analog_register(dev, interface);\n\tif (retval) {\n\t\tpr_err(\"%s() au0828_analog_register failed to register on V4L2\\n\",\n\t\t\t__func__);\n\t\tmutex_unlock(&dev->lock);\n\t\tgoto done;\n\t}\n\n\t \n\tretval = au0828_dvb_register(dev);\n\tif (retval)\n\t\tpr_err(\"%s() au0828_dvb_register failed\\n\",\n\t\t       __func__);\n\n\t \n\tau0828_rc_register(dev);\n\n\tpr_info(\"Registered device AU0828 [%s]\\n\",\n\t\tdev->board.name == NULL ? \"Unset\" : dev->board.name);\n\n\tmutex_unlock(&dev->lock);\n\n\tretval = au0828_media_device_register(dev, usbdev);\n\ndone:\n\tif (retval < 0)\n\t\tau0828_usb_disconnect(interface);\n\n\treturn retval;\n}\n\nstatic int au0828_suspend(struct usb_interface *interface,\n\t\t\t\tpm_message_t message)\n{\n\tstruct au0828_dev *dev = usb_get_intfdata(interface);\n\n\tif (!dev)\n\t\treturn 0;\n\n\tpr_info(\"Suspend\\n\");\n\n\tau0828_rc_suspend(dev);\n\tau0828_v4l2_suspend(dev);\n\tau0828_dvb_suspend(dev);\n\n\t \n\n\treturn 0;\n}\n\nstatic int au0828_resume(struct usb_interface *interface)\n{\n\tstruct au0828_dev *dev = usb_get_intfdata(interface);\n\tif (!dev)\n\t\treturn 0;\n\n\tpr_info(\"Resume\\n\");\n\n\t \n\tau0828_write(dev, REG_600, 1 << 4);\n\n\t \n\tau0828_gpio_setup(dev);\n\n\tau0828_rc_resume(dev);\n\tau0828_v4l2_resume(dev);\n\tau0828_dvb_resume(dev);\n\n\t \n\n\treturn 0;\n}\n\nstatic struct usb_driver au0828_usb_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.probe\t\t= au0828_usb_probe,\n\t.disconnect\t= au0828_usb_disconnect,\n\t.id_table\t= au0828_usb_id_table,\n\t.suspend\t= au0828_suspend,\n\t.resume\t\t= au0828_resume,\n\t.reset_resume\t= au0828_resume,\n};\n\nstatic int __init au0828_init(void)\n{\n\tint ret;\n\n\tif (au0828_debug & 1)\n\t\tpr_info(\"%s() Debugging is enabled\\n\", __func__);\n\n\tif (au0828_debug & 2)\n\t\tpr_info(\"%s() USB Debugging is enabled\\n\", __func__);\n\n\tif (au0828_debug & 4)\n\t\tpr_info(\"%s() I2C Debugging is enabled\\n\", __func__);\n\n\tif (au0828_debug & 8)\n\t\tpr_info(\"%s() Bridge Debugging is enabled\\n\",\n\t\t       __func__);\n\n\tif (au0828_debug & 16)\n\t\tpr_info(\"%s() IR Debugging is enabled\\n\",\n\t\t       __func__);\n\n\tpr_info(\"au0828 driver loaded\\n\");\n\n\tret = usb_register(&au0828_usb_driver);\n\tif (ret)\n\t\tpr_err(\"usb_register failed, error = %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void __exit au0828_exit(void)\n{\n\tusb_deregister(&au0828_usb_driver);\n}\n\nmodule_init(au0828_init);\nmodule_exit(au0828_exit);\n\nMODULE_DESCRIPTION(\"Driver for Auvitek AU0828 based products\");\nMODULE_AUTHOR(\"Steven Toth <stoth@linuxtv.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.0.3\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}