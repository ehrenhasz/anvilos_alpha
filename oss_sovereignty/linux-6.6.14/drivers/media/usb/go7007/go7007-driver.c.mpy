{
  "module_name": "go7007-driver.c",
  "hash_id": "473fdc231f609e730badd9e1078a0836b7b1679628196bac89eb8837ce95a3c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/go7007/go7007-driver.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/unistd.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/firmware.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <media/tuner.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-event.h>\n\n#include \"go7007-priv.h\"\n\n \nint go7007_read_interrupt(struct go7007 *go, u16 *value, u16 *data)\n{\n\tgo->interrupt_available = 0;\n\tgo->hpi_ops->read_interrupt(go);\n\tif (wait_event_timeout(go->interrupt_waitq,\n\t\t\t\tgo->interrupt_available, 5*HZ) < 0) {\n\t\tv4l2_err(&go->v4l2_dev, \"timeout waiting for read interrupt\\n\");\n\t\treturn -1;\n\t}\n\tif (!go->interrupt_available)\n\t\treturn -1;\n\tgo->interrupt_available = 0;\n\t*value = go->interrupt_value & 0xfffe;\n\t*data = go->interrupt_data;\n\treturn 0;\n}\nEXPORT_SYMBOL(go7007_read_interrupt);\n\n \nint go7007_read_addr(struct go7007 *go, u16 addr, u16 *data)\n{\n\tint count = 100;\n\tu16 value;\n\n\tif (go7007_write_interrupt(go, 0x0010, addr) < 0)\n\t\treturn -EIO;\n\twhile (count-- > 0) {\n\t\tif (go7007_read_interrupt(go, &value, data) == 0 &&\n\t\t\t\tvalue == 0xa000)\n\t\t\treturn 0;\n\t}\n\treturn -EIO;\n}\nEXPORT_SYMBOL(go7007_read_addr);\n\n \nstatic int go7007_load_encoder(struct go7007 *go)\n{\n\tconst struct firmware *fw_entry;\n\tchar fw_name[] = \"go7007/go7007fw.bin\";\n\tvoid *bounce;\n\tint fw_len, rv = 0;\n\tu16 intr_val, intr_data;\n\n\tif (go->boot_fw == NULL) {\n\t\tif (request_firmware(&fw_entry, fw_name, go->dev)) {\n\t\t\tv4l2_err(go, \"unable to load firmware from file \\\"%s\\\"\\n\", fw_name);\n\t\t\treturn -1;\n\t\t}\n\t\tif (fw_entry->size < 16 || memcmp(fw_entry->data, \"WISGO7007FW\", 11)) {\n\t\t\tv4l2_err(go, \"file \\\"%s\\\" does not appear to be go7007 firmware\\n\", fw_name);\n\t\t\trelease_firmware(fw_entry);\n\t\t\treturn -1;\n\t\t}\n\t\tfw_len = fw_entry->size - 16;\n\t\tbounce = kmemdup(fw_entry->data + 16, fw_len, GFP_KERNEL);\n\t\tif (bounce == NULL) {\n\t\t\tv4l2_err(go, \"unable to allocate %d bytes for firmware transfer\\n\", fw_len);\n\t\t\trelease_firmware(fw_entry);\n\t\t\treturn -1;\n\t\t}\n\t\trelease_firmware(fw_entry);\n\t\tgo->boot_fw_len = fw_len;\n\t\tgo->boot_fw = bounce;\n\t}\n\tif (go7007_interface_reset(go) < 0 ||\n\t    go7007_send_firmware(go, go->boot_fw, go->boot_fw_len) < 0 ||\n\t    go7007_read_interrupt(go, &intr_val, &intr_data) < 0 ||\n\t\t\t(intr_val & ~0x1) != 0x5a5a) {\n\t\tv4l2_err(go, \"error transferring firmware\\n\");\n\t\trv = -1;\n\t}\n\treturn rv;\n}\n\nMODULE_FIRMWARE(\"go7007/go7007fw.bin\");\n\n \nint go7007_boot_encoder(struct go7007 *go, int init_i2c)\n{\n\tint ret;\n\n\tmutex_lock(&go->hw_lock);\n\tret = go7007_load_encoder(go);\n\tmutex_unlock(&go->hw_lock);\n\tif (ret < 0)\n\t\treturn -1;\n\tif (!init_i2c)\n\t\treturn 0;\n\tif (go7007_i2c_init(go) < 0)\n\t\treturn -1;\n\tgo->i2c_adapter_online = 1;\n\treturn 0;\n}\nEXPORT_SYMBOL(go7007_boot_encoder);\n\n \nstatic int go7007_init_encoder(struct go7007 *go)\n{\n\tif (go->board_info->audio_flags & GO7007_AUDIO_I2S_MASTER) {\n\t\tgo7007_write_addr(go, 0x1000, 0x0811);\n\t\tgo7007_write_addr(go, 0x1000, 0x0c11);\n\t}\n\tswitch (go->board_id) {\n\tcase GO7007_BOARDID_MATRIX_REV:\n\t\t \n\t\tgo7007_write_addr(go, 0x3c82, 0x0001);\n\t\tgo7007_write_addr(go, 0x3c80, 0x00fe);\n\t\tbreak;\n\tcase GO7007_BOARDID_ADLINK_MPG24:\n\t\t \n\t\tgo7007_write_addr(go, 0x3c82, 0x0000);\n\t\tgo7007_write_addr(go, 0x3c80, 0x00df);\n\t\tbreak;\n\tcase GO7007_BOARDID_ADS_USBAV_709:\n\t\t \n\t\t \n\t\t \n\t\tgo7007_write_addr(go, 0x3c82, 0x000d);\n\t\tgo7007_write_addr(go, 0x3c80, 0x00f2);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nint go7007_reset_encoder(struct go7007 *go)\n{\n\tif (go7007_load_encoder(go) < 0)\n\t\treturn -1;\n\treturn go7007_init_encoder(go);\n}\n\n \nstatic int init_i2c_module(struct i2c_adapter *adapter, const struct go_i2c *const i2c)\n{\n\tstruct go7007 *go = i2c_get_adapdata(adapter);\n\tstruct v4l2_device *v4l2_dev = &go->v4l2_dev;\n\tstruct v4l2_subdev *sd;\n\tstruct i2c_board_info info;\n\n\tmemset(&info, 0, sizeof(info));\n\tstrscpy(info.type, i2c->type, sizeof(info.type));\n\tinfo.addr = i2c->addr;\n\tinfo.flags = i2c->flags;\n\n\tsd = v4l2_i2c_new_subdev_board(v4l2_dev, adapter, &info, NULL);\n\tif (sd) {\n\t\tif (i2c->is_video)\n\t\t\tgo->sd_video = sd;\n\t\tif (i2c->is_audio)\n\t\t\tgo->sd_audio = sd;\n\t\treturn 0;\n\t}\n\n\tpr_info(\"go7007: probing for module i2c:%s failed\\n\", i2c->type);\n\treturn -EINVAL;\n}\n\n \nstatic void go7007_remove(struct v4l2_device *v4l2_dev)\n{\n\tstruct go7007 *go = container_of(v4l2_dev, struct go7007, v4l2_dev);\n\n\tv4l2_device_unregister(v4l2_dev);\n\tif (go->hpi_ops->release)\n\t\tgo->hpi_ops->release(go);\n\tif (go->i2c_adapter_online) {\n\t\ti2c_del_adapter(&go->i2c_adapter);\n\t\tgo->i2c_adapter_online = 0;\n\t}\n\n\tkfree(go->boot_fw);\n\tgo7007_v4l2_remove(go);\n\tkfree(go);\n}\n\n \nint go7007_register_encoder(struct go7007 *go, unsigned num_i2c_devs)\n{\n\tint i, ret;\n\n\tdev_info(go->dev, \"go7007: registering new %s\\n\", go->name);\n\n\tgo->v4l2_dev.release = go7007_remove;\n\tret = v4l2_device_register(go->dev, &go->v4l2_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&go->hw_lock);\n\tret = go7007_init_encoder(go);\n\tmutex_unlock(&go->hw_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = go7007_v4l2_ctrl_init(go);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!go->i2c_adapter_online &&\n\t\t\tgo->board_info->flags & GO7007_BOARD_USE_ONBOARD_I2C) {\n\t\tret = go7007_i2c_init(go);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgo->i2c_adapter_online = 1;\n\t}\n\tif (go->i2c_adapter_online) {\n\t\tif (go->board_id == GO7007_BOARDID_ADS_USBAV_709) {\n\t\t\t \n\t\t\tgo7007_write_addr(go, 0x3c82, 0x0009);\n\t\t\tmsleep(50);\n\t\t\tgo7007_write_addr(go, 0x3c82, 0x000d);\n\t\t}\n\t\tfor (i = 0; i < num_i2c_devs; ++i)\n\t\t\tinit_i2c_module(&go->i2c_adapter, &go->board_info->i2c_devs[i]);\n\n\t\tif (go->tuner_type >= 0) {\n\t\t\tstruct tuner_setup setup = {\n\t\t\t\t.addr = ADDR_UNSET,\n\t\t\t\t.type = go->tuner_type,\n\t\t\t\t.mode_mask = T_ANALOG_TV,\n\t\t\t};\n\n\t\t\tv4l2_device_call_all(&go->v4l2_dev, 0, tuner,\n\t\t\t\ts_type_addr, &setup);\n\t\t}\n\t\tif (go->board_id == GO7007_BOARDID_ADLINK_MPG24)\n\t\t\tv4l2_subdev_call(go->sd_video, video, s_routing,\n\t\t\t\t\t0, 0, go->channel_number + 1);\n\t}\n\n\tret = go7007_v4l2_init(go);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (go->board_info->flags & GO7007_BOARD_HAS_AUDIO) {\n\t\tgo->audio_enabled = 1;\n\t\tgo7007_snd_init(go);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(go7007_register_encoder);\n\n \nint go7007_start_encoder(struct go7007 *go)\n{\n\tu8 *fw;\n\tint fw_len, rv = 0, i, x, y;\n\tu16 intr_val, intr_data;\n\n\tgo->modet_enable = 0;\n\tfor (i = 0; i < 4; i++)\n\t\tgo->modet[i].enable = 0;\n\n\tswitch (v4l2_ctrl_g_ctrl(go->modet_mode)) {\n\tcase V4L2_DETECT_MD_MODE_GLOBAL:\n\t\tmemset(go->modet_map, 0, sizeof(go->modet_map));\n\t\tgo->modet[0].enable = 1;\n\t\tgo->modet_enable = 1;\n\t\tbreak;\n\tcase V4L2_DETECT_MD_MODE_REGION_GRID:\n\t\tfor (y = 0; y < go->height / 16; y++) {\n\t\t\tfor (x = 0; x < go->width / 16; x++) {\n\t\t\t\tint idx = y * go->width / 16 + x;\n\n\t\t\t\tgo->modet[go->modet_map[idx]].enable = 1;\n\t\t\t}\n\t\t}\n\t\tgo->modet_enable = 1;\n\t\tbreak;\n\t}\n\n\tif (go->dvd_mode)\n\t\tgo->modet_enable = 0;\n\n\tif (go7007_construct_fw_image(go, &fw, &fw_len) < 0)\n\t\treturn -1;\n\n\tif (go7007_send_firmware(go, fw, fw_len) < 0 ||\n\t\t\tgo7007_read_interrupt(go, &intr_val, &intr_data) < 0) {\n\t\tv4l2_err(&go->v4l2_dev, \"error transferring firmware\\n\");\n\t\trv = -1;\n\t\tgoto start_error;\n\t}\n\n\tgo->state = STATE_DATA;\n\tgo->parse_length = 0;\n\tgo->seen_frame = 0;\n\tif (go7007_stream_start(go) < 0) {\n\t\tv4l2_err(&go->v4l2_dev, \"error starting stream transfer\\n\");\n\t\trv = -1;\n\t\tgoto start_error;\n\t}\n\nstart_error:\n\tkfree(fw);\n\treturn rv;\n}\n\n \nstatic inline void store_byte(struct go7007_buffer *vb, u8 byte)\n{\n\tif (vb && vb->vb.vb2_buf.planes[0].bytesused < GO7007_BUF_SIZE) {\n\t\tu8 *ptr = vb2_plane_vaddr(&vb->vb.vb2_buf, 0);\n\n\t\tptr[vb->vb.vb2_buf.planes[0].bytesused++] = byte;\n\t}\n}\n\nstatic void go7007_set_motion_regions(struct go7007 *go, struct go7007_buffer *vb,\n\t\tu32 motion_regions)\n{\n\tif (motion_regions != go->modet_event_status) {\n\t\tstruct v4l2_event ev = {\n\t\t\t.type = V4L2_EVENT_MOTION_DET,\n\t\t\t.u.motion_det = {\n\t\t\t\t.flags = V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ,\n\t\t\t\t.frame_sequence = vb->vb.sequence,\n\t\t\t\t.region_mask = motion_regions,\n\t\t\t},\n\t\t};\n\n\t\tv4l2_event_queue(&go->vdev, &ev);\n\t\tgo->modet_event_status = motion_regions;\n\t}\n}\n\n \nstatic void go7007_motion_regions(struct go7007 *go, struct go7007_buffer *vb)\n{\n\tu32 *bytesused = &vb->vb.vb2_buf.planes[0].bytesused;\n\tunsigned motion[4] = { 0, 0, 0, 0 };\n\tu32 motion_regions = 0;\n\tunsigned stride = (go->width + 7) >> 3;\n\tunsigned x, y;\n\tint i;\n\n\tfor (i = 0; i < 216; ++i)\n\t\tstore_byte(vb, go->active_map[i]);\n\tfor (y = 0; y < go->height / 16; y++) {\n\t\tfor (x = 0; x < go->width / 16; x++) {\n\t\t\tif (!(go->active_map[y * stride + (x >> 3)] & (1 << (x & 7))))\n\t\t\t\tcontinue;\n\t\t\tmotion[go->modet_map[y * (go->width / 16) + x]]++;\n\t\t}\n\t}\n\tmotion_regions = ((motion[0] > 0) << 0) |\n\t\t\t ((motion[1] > 0) << 1) |\n\t\t\t ((motion[2] > 0) << 2) |\n\t\t\t ((motion[3] > 0) << 3);\n\t*bytesused -= 216;\n\tgo7007_set_motion_regions(go, vb, motion_regions);\n}\n\n \nstatic struct go7007_buffer *frame_boundary(struct go7007 *go, struct go7007_buffer *vb)\n{\n\tu32 *bytesused;\n\tstruct go7007_buffer *vb_tmp = NULL;\n\tunsigned long flags;\n\n\tif (vb == NULL) {\n\t\tspin_lock_irqsave(&go->spinlock, flags);\n\t\tif (!list_empty(&go->vidq_active))\n\t\t\tvb = go->active_buf =\n\t\t\t\tlist_first_entry(&go->vidq_active, struct go7007_buffer, list);\n\t\tspin_unlock_irqrestore(&go->spinlock, flags);\n\t\tgo->next_seq++;\n\t\treturn vb;\n\t}\n\tbytesused = &vb->vb.vb2_buf.planes[0].bytesused;\n\n\tvb->vb.sequence = go->next_seq++;\n\tif (vb->modet_active && *bytesused + 216 < GO7007_BUF_SIZE)\n\t\tgo7007_motion_regions(go, vb);\n\telse\n\t\tgo7007_set_motion_regions(go, vb, 0);\n\n\tvb->vb.vb2_buf.timestamp = ktime_get_ns();\n\tvb_tmp = vb;\n\tspin_lock_irqsave(&go->spinlock, flags);\n\tlist_del(&vb->list);\n\tif (list_empty(&go->vidq_active))\n\t\tvb = NULL;\n\telse\n\t\tvb = list_first_entry(&go->vidq_active,\n\t\t\t\tstruct go7007_buffer, list);\n\tgo->active_buf = vb;\n\tspin_unlock_irqrestore(&go->spinlock, flags);\n\tvb2_buffer_done(&vb_tmp->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\treturn vb;\n}\n\nstatic void write_bitmap_word(struct go7007 *go)\n{\n\tint x, y, i, stride = ((go->width >> 4) + 7) >> 3;\n\n\tfor (i = 0; i < 16; ++i) {\n\t\ty = (((go->parse_length - 1) << 3) + i) / (go->width >> 4);\n\t\tx = (((go->parse_length - 1) << 3) + i) % (go->width >> 4);\n\t\tif (stride * y + (x >> 3) < sizeof(go->active_map))\n\t\t\tgo->active_map[stride * y + (x >> 3)] |=\n\t\t\t\t\t(go->modet_word & 1) << (x & 0x7);\n\t\tgo->modet_word >>= 1;\n\t}\n}\n\n \nvoid go7007_parse_video_stream(struct go7007 *go, u8 *buf, int length)\n{\n\tstruct go7007_buffer *vb = go->active_buf;\n\tint i, seq_start_code = -1, gop_start_code = -1, frame_start_code = -1;\n\n\tswitch (go->format) {\n\tcase V4L2_PIX_FMT_MPEG4:\n\t\tseq_start_code = 0xB0;\n\t\tgop_start_code = 0xB3;\n\t\tframe_start_code = 0xB6;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_MPEG1:\n\tcase V4L2_PIX_FMT_MPEG2:\n\t\tseq_start_code = 0xB3;\n\t\tgop_start_code = 0xB8;\n\t\tframe_start_code = 0x00;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < length; ++i) {\n\t\tif (vb && vb->vb.vb2_buf.planes[0].bytesused >=\n\t\t\t\tGO7007_BUF_SIZE - 3) {\n\t\t\tv4l2_info(&go->v4l2_dev, \"dropping oversized frame\\n\");\n\t\t\tvb2_set_plane_payload(&vb->vb.vb2_buf, 0, 0);\n\t\t\tvb->frame_offset = 0;\n\t\t\tvb->modet_active = 0;\n\t\t\tvb = go->active_buf = NULL;\n\t\t}\n\n\t\tswitch (go->state) {\n\t\tcase STATE_DATA:\n\t\t\tswitch (buf[i]) {\n\t\t\tcase 0x00:\n\t\t\t\tgo->state = STATE_00;\n\t\t\t\tbreak;\n\t\t\tcase 0xFF:\n\t\t\t\tgo->state = STATE_FF;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstore_byte(vb, buf[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STATE_00:\n\t\t\tswitch (buf[i]) {\n\t\t\tcase 0x00:\n\t\t\t\tgo->state = STATE_00_00;\n\t\t\t\tbreak;\n\t\t\tcase 0xFF:\n\t\t\t\tstore_byte(vb, 0x00);\n\t\t\t\tgo->state = STATE_FF;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstore_byte(vb, 0x00);\n\t\t\t\tstore_byte(vb, buf[i]);\n\t\t\t\tgo->state = STATE_DATA;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STATE_00_00:\n\t\t\tswitch (buf[i]) {\n\t\t\tcase 0x00:\n\t\t\t\tstore_byte(vb, 0x00);\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tcase 0x01:\n\t\t\t\tgo->state = STATE_00_00_01;\n\t\t\t\tbreak;\n\t\t\tcase 0xFF:\n\t\t\t\tstore_byte(vb, 0x00);\n\t\t\t\tstore_byte(vb, 0x00);\n\t\t\t\tgo->state = STATE_FF;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstore_byte(vb, 0x00);\n\t\t\t\tstore_byte(vb, 0x00);\n\t\t\t\tstore_byte(vb, buf[i]);\n\t\t\t\tgo->state = STATE_DATA;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STATE_00_00_01:\n\t\t\tif (buf[i] == 0xF8 && go->modet_enable == 0) {\n\t\t\t\t \n\t\t\t\tstore_byte(vb, 0x00);\n\t\t\t\tstore_byte(vb, 0x00);\n\t\t\t\tstore_byte(vb, 0x01);\n\t\t\t\tstore_byte(vb, 0xF8);\n\t\t\t\tgo->state = STATE_DATA;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif ((go->format == V4L2_PIX_FMT_MPEG1 ||\n\t\t\t     go->format == V4L2_PIX_FMT_MPEG2 ||\n\t\t\t     go->format == V4L2_PIX_FMT_MPEG4) &&\n\t\t\t    (buf[i] == seq_start_code ||\n\t\t\t     buf[i] == gop_start_code ||\n\t\t\t     buf[i] == frame_start_code)) {\n\t\t\t\tif (vb == NULL || go->seen_frame)\n\t\t\t\t\tvb = frame_boundary(go, vb);\n\t\t\t\tgo->seen_frame = buf[i] == frame_start_code;\n\t\t\t\tif (vb && go->seen_frame)\n\t\t\t\t\tvb->frame_offset =\n\t\t\t\t\tvb->vb.vb2_buf.planes[0].bytesused;\n\t\t\t}\n\t\t\t \n\t\t\tswitch (buf[i]) {\n\t\t\tcase 0xF5:  \n\t\t\t\tgo->parse_length = 12;\n\t\t\t\tgo->state = STATE_UNPARSED;\n\t\t\t\tbreak;\n\t\t\tcase 0xF6:  \n\t\t\t\tgo->state = STATE_VBI_LEN_A;\n\t\t\t\tbreak;\n\t\t\tcase 0xF8:  \n\t\t\t\tgo->parse_length = 0;\n\t\t\t\tmemset(go->active_map, 0,\n\t\t\t\t\t\tsizeof(go->active_map));\n\t\t\t\tgo->state = STATE_MODET_MAP;\n\t\t\t\tbreak;\n\t\t\tcase 0xFF:  \n\t\t\t\tstore_byte(vb, 0x00);\n\t\t\t\tstore_byte(vb, 0x00);\n\t\t\t\tstore_byte(vb, 0x01);\n\t\t\t\tgo->state = STATE_FF;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstore_byte(vb, 0x00);\n\t\t\t\tstore_byte(vb, 0x00);\n\t\t\t\tstore_byte(vb, 0x01);\n\t\t\t\tstore_byte(vb, buf[i]);\n\t\t\t\tgo->state = STATE_DATA;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STATE_FF:\n\t\t\tswitch (buf[i]) {\n\t\t\tcase 0x00:\n\t\t\t\tstore_byte(vb, 0xFF);\n\t\t\t\tgo->state = STATE_00;\n\t\t\t\tbreak;\n\t\t\tcase 0xFF:\n\t\t\t\tstore_byte(vb, 0xFF);\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tcase 0xD8:\n\t\t\t\tif (go->format == V4L2_PIX_FMT_MJPEG)\n\t\t\t\t\tvb = frame_boundary(go, vb);\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\tstore_byte(vb, 0xFF);\n\t\t\t\tstore_byte(vb, buf[i]);\n\t\t\t\tgo->state = STATE_DATA;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STATE_VBI_LEN_A:\n\t\t\tgo->parse_length = buf[i] << 8;\n\t\t\tgo->state = STATE_VBI_LEN_B;\n\t\t\tbreak;\n\t\tcase STATE_VBI_LEN_B:\n\t\t\tgo->parse_length |= buf[i];\n\t\t\tif (go->parse_length > 0)\n\t\t\t\tgo->state = STATE_UNPARSED;\n\t\t\telse\n\t\t\t\tgo->state = STATE_DATA;\n\t\t\tbreak;\n\t\tcase STATE_MODET_MAP:\n\t\t\tif (go->parse_length < 204) {\n\t\t\t\tif (go->parse_length & 1) {\n\t\t\t\t\tgo->modet_word |= buf[i];\n\t\t\t\t\twrite_bitmap_word(go);\n\t\t\t\t} else\n\t\t\t\t\tgo->modet_word = buf[i] << 8;\n\t\t\t} else if (go->parse_length == 207 && vb) {\n\t\t\t\tvb->modet_active = buf[i];\n\t\t\t}\n\t\t\tif (++go->parse_length == 208)\n\t\t\t\tgo->state = STATE_DATA;\n\t\t\tbreak;\n\t\tcase STATE_UNPARSED:\n\t\t\tif (--go->parse_length == 0)\n\t\t\t\tgo->state = STATE_DATA;\n\t\t\tbreak;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(go7007_parse_video_stream);\n\n \nstruct go7007 *go7007_alloc(const struct go7007_board_info *board,\n\t\t\t\t\t\tstruct device *dev)\n{\n\tstruct go7007 *go;\n\n\tgo = kzalloc(sizeof(struct go7007), GFP_KERNEL);\n\tif (go == NULL)\n\t\treturn NULL;\n\tgo->dev = dev;\n\tgo->board_info = board;\n\tgo->tuner_type = -1;\n\tmutex_init(&go->hw_lock);\n\tinit_waitqueue_head(&go->frame_waitq);\n\tspin_lock_init(&go->spinlock);\n\tgo->status = STATUS_INIT;\n\tinit_waitqueue_head(&go->interrupt_waitq);\n\tgo7007_update_board(go);\n\tgo->format = V4L2_PIX_FMT_MJPEG;\n\tgo->bitrate = 1500000;\n\tgo->fps_scale = 1;\n\tgo->aspect_ratio = GO7007_RATIO_1_1;\n\n\treturn go;\n}\nEXPORT_SYMBOL(go7007_alloc);\n\nvoid go7007_update_board(struct go7007 *go)\n{\n\tconst struct go7007_board_info *board = go->board_info;\n\n\tif (board->sensor_flags & GO7007_SENSOR_TV) {\n\t\tgo->standard = GO7007_STD_NTSC;\n\t\tgo->std = V4L2_STD_NTSC_M;\n\t\tgo->width = 720;\n\t\tgo->height = 480;\n\t\tgo->sensor_framerate = 30000;\n\t} else {\n\t\tgo->standard = GO7007_STD_OTHER;\n\t\tgo->width = board->sensor_width;\n\t\tgo->height = board->sensor_height;\n\t\tgo->sensor_framerate = board->sensor_framerate;\n\t}\n\tgo->encoder_v_offset = board->sensor_v_offset;\n\tgo->encoder_h_offset = board->sensor_h_offset;\n}\nEXPORT_SYMBOL(go7007_update_board);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}