{
  "module_name": "go7007-fw.c",
  "hash_id": "35fdd033835e06de04af91d0d9528c40aed4f9ce102af3451e01a7f44641a71c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/go7007/go7007-fw.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/firmware.h>\n#include <linux/slab.h>\n#include <asm/byteorder.h>\n\n#include \"go7007-priv.h\"\n\n#define GO7007_FW_NAME \"go7007/go7007tv.bin\"\n\n \n\n#define\tFLAG_MODE_MJPEG\t\t(1)\n#define\tFLAG_MODE_MPEG1\t\t(1<<1)\n#define\tFLAG_MODE_MPEG2\t\t(1<<2)\n#define\tFLAG_MODE_MPEG4\t\t(1<<3)\n#define\tFLAG_MODE_H263\t\t(1<<4)\n#define FLAG_MODE_ALL\t\t(FLAG_MODE_MJPEG | FLAG_MODE_MPEG1 | \\\n\t\t\t\t\tFLAG_MODE_MPEG2 | FLAG_MODE_MPEG4 | \\\n\t\t\t\t\tFLAG_MODE_H263)\n#define FLAG_SPECIAL\t\t(1<<8)\n\n#define SPECIAL_FRM_HEAD\t0\n#define SPECIAL_BRC_CTRL\t1\n#define SPECIAL_CONFIG\t\t2\n#define SPECIAL_SEQHEAD\t\t3\n#define SPECIAL_AV_SYNC\t\t4\n#define SPECIAL_FINAL\t\t5\n#define SPECIAL_AUDIO\t\t6\n#define SPECIAL_MODET\t\t7\n\n \n\nstruct code_gen {\n\tunsigned char *p;  \n\tu32 a;  \n\tint b;  \n\tint len;  \n};\n\n#define CODE_GEN(name, dest) struct code_gen name = { dest, 0, 32, 0 }\n\n#define CODE_ADD(name, val, length) do { \\\n\tname.b -= (length); \\\n\tname.a |= (val) << name.b; \\\n\twhile (name.b <= 24) { \\\n\t\t*name.p = name.a >> 24; \\\n\t\t++name.p; \\\n\t\tname.a <<= 8; \\\n\t\tname.b += 8; \\\n\t\tname.len += 8; \\\n\t} \\\n} while (0)\n\n#define CODE_LENGTH(name) (name.len + (32 - name.b))\n\n \n\nstatic const s16 converge_speed_ip[101] = {\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 2,\n\t2, 2, 2, 2, 2, 2, 2, 2, 2, 3,\n\t3, 3, 3, 3, 3, 4, 4, 4, 4, 4,\n\t5, 5, 5, 6, 6, 6, 7, 7, 8, 8,\n\t9, 10, 10, 11, 12, 13, 14, 15, 16, 17,\n\t19, 20, 22, 23, 25, 27, 30, 32, 35, 38,\n\t41, 45, 49, 53, 58, 63, 69, 76, 83, 91,\n\t100\n};\n\nstatic const s16 converge_speed_ipb[101] = {\n\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n\t3, 3, 3, 3, 3, 4, 4, 4, 4, 4,\n\t4, 4, 4, 4, 5, 5, 5, 5, 5, 6,\n\t6, 6, 6, 7, 7, 7, 7, 8, 8, 9,\n\t9, 9, 10, 10, 11, 12, 12, 13, 14, 14,\n\t15, 16, 17, 18, 19, 20, 22, 23, 25, 26,\n\t28, 30, 32, 34, 37, 40, 42, 46, 49, 53,\n\t57, 61, 66, 71, 77, 83, 90, 97, 106, 115,\n\t125, 135, 147, 161, 175, 191, 209, 228, 249, 273,\n\t300\n};\n\nstatic const s16 LAMBDA_table[4][101] = {\n\t{\t16, 16, 16, 16, 17, 17, 17, 18, 18, 18,\n\t\t19, 19, 19, 20, 20, 20, 21, 21, 22, 22,\n\t\t22, 23, 23, 24, 24, 25, 25, 25, 26, 26,\n\t\t27, 27, 28, 28, 29, 29, 30, 31, 31, 32,\n\t\t32, 33, 33, 34, 35, 35, 36, 37, 37, 38,\n\t\t39, 39, 40, 41, 42, 42, 43, 44, 45, 46,\n\t\t46, 47, 48, 49, 50, 51, 52, 53, 54, 55,\n\t\t56, 57, 58, 59, 60, 61, 62, 63, 64, 65,\n\t\t67, 68, 69, 70, 72, 73, 74, 76, 77, 78,\n\t\t80, 81, 83, 84, 86, 87, 89, 90, 92, 94,\n\t\t96\n\t},\n\t{\n\t\t20, 20, 20, 21, 21, 21, 22, 22, 23, 23,\n\t\t23, 24, 24, 25, 25, 26, 26, 27, 27, 28,\n\t\t28, 29, 29, 30, 30, 31, 31, 32, 33, 33,\n\t\t34, 34, 35, 36, 36, 37, 38, 38, 39, 40,\n\t\t40, 41, 42, 43, 43, 44, 45, 46, 47, 48,\n\t\t48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\n\t\t58, 59, 60, 61, 62, 64, 65, 66, 67, 68,\n\t\t70, 71, 72, 73, 75, 76, 78, 79, 80, 82,\n\t\t83, 85, 86, 88, 90, 91, 93, 95, 96, 98,\n\t\t100, 102, 103, 105, 107, 109, 111, 113, 115, 117,\n\t\t120\n\t},\n\t{\n\t\t24, 24, 24, 25, 25, 26, 26, 27, 27, 28,\n\t\t28, 29, 29, 30, 30, 31, 31, 32, 33, 33,\n\t\t34, 34, 35, 36, 36, 37, 38, 38, 39, 40,\n\t\t41, 41, 42, 43, 44, 44, 45, 46, 47, 48,\n\t\t49, 50, 50, 51, 52, 53, 54, 55, 56, 57,\n\t\t58, 59, 60, 62, 63, 64, 65, 66, 67, 69,\n\t\t70, 71, 72, 74, 75, 76, 78, 79, 81, 82,\n\t\t84, 85, 87, 88, 90, 92, 93, 95, 97, 98,\n\t\t100, 102, 104, 106, 108, 110, 112, 114, 116, 118,\n\t\t120, 122, 124, 127, 129, 131, 134, 136, 138, 141,\n\t\t144\n\t},\n\t{\n\t\t32, 32, 33, 33, 34, 34, 35, 36, 36, 37,\n\t\t38, 38, 39, 40, 41, 41, 42, 43, 44, 44,\n\t\t45, 46, 47, 48, 49, 50, 50, 51, 52, 53,\n\t\t54, 55, 56, 57, 58, 59, 60, 62, 63, 64,\n\t\t65, 66, 67, 69, 70, 71, 72, 74, 75, 76,\n\t\t78, 79, 81, 82, 84, 85, 87, 88, 90, 92,\n\t\t93, 95, 97, 98, 100, 102, 104, 106, 108, 110,\n\t\t112, 114, 116, 118, 120, 122, 124, 127, 129, 131,\n\t\t134, 136, 139, 141, 144, 146, 149, 152, 154, 157,\n\t\t160, 163, 166, 169, 172, 175, 178, 181, 185, 188,\n\t\t192\n\t}\n};\n\n \n\nenum mpeg_frame_type {\n\tPFRAME,\n\tBFRAME_PRE,\n\tBFRAME_POST,\n\tBFRAME_BIDIR,\n\tBFRAME_EMPTY\n};\n\nstatic const u32 addrinctab[33][2] = {\n\t{ 0x01, 1 },\t{ 0x03, 3 },\t{ 0x02, 3 },\t{ 0x03, 4 },\n\t{ 0x02, 4 },\t{ 0x03, 5 },\t{ 0x02, 5 },\t{ 0x07, 7 },\n\t{ 0x06, 7 },\t{ 0x0b, 8 },\t{ 0x0a, 8 },\t{ 0x09, 8 },\n\t{ 0x08, 8 },\t{ 0x07, 8 },\t{ 0x06, 8 },\t{ 0x17, 10 },\n\t{ 0x16, 10 },\t{ 0x15, 10 },\t{ 0x14, 10 },\t{ 0x13, 10 },\n\t{ 0x12, 10 },\t{ 0x23, 11 },\t{ 0x22, 11 },\t{ 0x21, 11 },\n\t{ 0x20, 11 },\t{ 0x1f, 11 },\t{ 0x1e, 11 },\t{ 0x1d, 11 },\n\t{ 0x1c, 11 },\t{ 0x1b, 11 },\t{ 0x1a, 11 },\t{ 0x19, 11 },\n\t{ 0x18, 11 }\n};\n\n \n\nstatic const u8 default_intra_quant_table[] = {\n\t 8, 16, 19, 22, 26, 27, 29, 34,\n\t16, 16, 22, 24, 27, 29, 34, 37,\n\t19, 22, 26, 27, 29, 34, 34, 38,\n\t22, 22, 26, 27, 29, 34, 37, 40,\n\t22, 26, 27, 29, 32, 35, 40, 48,\n\t26, 27, 29, 32, 35, 40, 48, 58,\n\t26, 27, 29, 34, 38, 46, 56, 69,\n\t27, 29, 35, 38, 46, 56, 69, 83\n};\n\nstatic const u8 bits_dc_luminance[] = {\n\t0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0\n};\n\nstatic const u8 val_dc_luminance[] = {\n\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n};\n\nstatic const u8 bits_dc_chrominance[] = {\n\t0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0\n};\n\nstatic const u8 val_dc_chrominance[] = {\n\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n};\n\nstatic const u8 bits_ac_luminance[] = {\n\t0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d\n};\n\nstatic const u8 val_ac_luminance[] = {\n\t0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,\n\t0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,\n\t0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,\n\t0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0,\n\t0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16,\n\t0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,\n\t0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,\n\t0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,\n\t0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,\n\t0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,\n\t0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,\n\t0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,\n\t0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,\n\t0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n\t0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,\n\t0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,\n\t0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,\n\t0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,\n\t0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,\n\t0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,\n\t0xf9, 0xfa\n};\n\nstatic const u8 bits_ac_chrominance[] = {\n\t0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77\n};\n\nstatic const u8 val_ac_chrominance[] = {\n\t0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,\n\t0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,\n\t0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,\n\t0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0,\n\t0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34,\n\t0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26,\n\t0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38,\n\t0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,\n\t0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n\t0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,\n\t0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,\n\t0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n\t0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96,\n\t0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5,\n\t0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,\n\t0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,\n\t0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2,\n\t0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,\n\t0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,\n\t0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,\n\t0xf9, 0xfa\n};\n\n \nstatic const int zz[64] = {\n\t0,   1,  8, 16,  9,  2,  3, 10, 17, 24, 32, 25, 18, 11,  4,  5,\n\t12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13,  6,  7, 14, 21, 28,\n\t35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51,\n\t58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63\n};\n\nstatic int copy_packages(__le16 *dest, u16 *src, int pkg_cnt, int space)\n{\n\tint i, cnt = pkg_cnt * 32;\n\n\tif (space < cnt)\n\t\treturn -1;\n\n\tfor (i = 0; i < cnt; ++i)\n\t\tdest[i] = cpu_to_le16p(src + i);\n\n\treturn cnt;\n}\n\nstatic int mjpeg_frame_header(struct go7007 *go, unsigned char *buf, int q)\n{\n\tint i, p = 0;\n\n\tbuf[p++] = 0xff;\n\tbuf[p++] = 0xd8;\n\tbuf[p++] = 0xff;\n\tbuf[p++] = 0xdb;\n\tbuf[p++] = 0;\n\tbuf[p++] = 2 + 65;\n\tbuf[p++] = 0;\n\tbuf[p++] = default_intra_quant_table[0];\n\tfor (i = 1; i < 64; ++i)\n\t\t \n\t\tbuf[p++] = (default_intra_quant_table[zz[i]] * q) >> 3;\n\tbuf[p++] = 0xff;\n\tbuf[p++] = 0xc0;\n\tbuf[p++] = 0;\n\tbuf[p++] = 17;\n\tbuf[p++] = 8;\n\tbuf[p++] = go->height >> 8;\n\tbuf[p++] = go->height & 0xff;\n\tbuf[p++] = go->width >> 8;\n\tbuf[p++] = go->width & 0xff;\n\tbuf[p++] = 3;\n\tbuf[p++] = 1;\n\tbuf[p++] = 0x22;\n\tbuf[p++] = 0;\n\tbuf[p++] = 2;\n\tbuf[p++] = 0x11;\n\tbuf[p++] = 0;\n\tbuf[p++] = 3;\n\tbuf[p++] = 0x11;\n\tbuf[p++] = 0;\n\tbuf[p++] = 0xff;\n\tbuf[p++] = 0xc4;\n\tbuf[p++] = 418 >> 8;\n\tbuf[p++] = 418 & 0xff;\n\tbuf[p++] = 0x00;\n\tmemcpy(buf + p, bits_dc_luminance + 1, 16);\n\tp += 16;\n\tmemcpy(buf + p, val_dc_luminance, sizeof(val_dc_luminance));\n\tp += sizeof(val_dc_luminance);\n\tbuf[p++] = 0x01;\n\tmemcpy(buf + p, bits_dc_chrominance + 1, 16);\n\tp += 16;\n\tmemcpy(buf + p, val_dc_chrominance, sizeof(val_dc_chrominance));\n\tp += sizeof(val_dc_chrominance);\n\tbuf[p++] = 0x10;\n\tmemcpy(buf + p, bits_ac_luminance + 1, 16);\n\tp += 16;\n\tmemcpy(buf + p, val_ac_luminance, sizeof(val_ac_luminance));\n\tp += sizeof(val_ac_luminance);\n\tbuf[p++] = 0x11;\n\tmemcpy(buf + p, bits_ac_chrominance + 1, 16);\n\tp += 16;\n\tmemcpy(buf + p, val_ac_chrominance, sizeof(val_ac_chrominance));\n\tp += sizeof(val_ac_chrominance);\n\tbuf[p++] = 0xff;\n\tbuf[p++] = 0xda;\n\tbuf[p++] = 0;\n\tbuf[p++] = 12;\n\tbuf[p++] = 3;\n\tbuf[p++] = 1;\n\tbuf[p++] = 0x00;\n\tbuf[p++] = 2;\n\tbuf[p++] = 0x11;\n\tbuf[p++] = 3;\n\tbuf[p++] = 0x11;\n\tbuf[p++] = 0;\n\tbuf[p++] = 63;\n\tbuf[p++] = 0;\n\treturn p;\n}\n\nstatic int gen_mjpeghdr_to_package(struct go7007 *go, __le16 *code, int space)\n{\n\tu8 *buf;\n\tu16 mem = 0x3e00;\n\tunsigned int addr = 0x19;\n\tint size = 0, i, off = 0, chunk;\n\n\tbuf = kzalloc(4096, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 1; i < 32; ++i) {\n\t\tmjpeg_frame_header(go, buf + size, i);\n\t\tsize += 80;\n\t}\n\tchunk = mjpeg_frame_header(go, buf + size, 1);\n\tmemmove(buf + size, buf + size + 80, chunk - 80);\n\tsize += chunk - 80;\n\n\tfor (i = 0; i < size; i += chunk * 2) {\n\t\tif (space - off < 32) {\n\t\t\toff = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tcode[off + 1] = __cpu_to_le16(0x8000 | mem);\n\n\t\tchunk = 28;\n\t\tif (mem + chunk > 0x4000)\n\t\t\tchunk = 0x4000 - mem;\n\t\tif (i + 2 * chunk > size)\n\t\t\tchunk = (size - i) / 2;\n\n\t\tif (chunk < 28) {\n\t\t\tcode[off] = __cpu_to_le16(0x4000 | chunk);\n\t\t\tcode[off + 31] = __cpu_to_le16(addr++);\n\t\t\tmem = 0x3e00;\n\t\t} else {\n\t\t\tcode[off] = __cpu_to_le16(0x1000 | 28);\n\t\t\tcode[off + 31] = 0;\n\t\t\tmem += 28;\n\t\t}\n\n\t\tmemcpy(&code[off + 2], buf + i, chunk * 2);\n\t\toff += 32;\n\t}\ndone:\n\tkfree(buf);\n\treturn off;\n}\n\nstatic int mpeg1_frame_header(struct go7007 *go, unsigned char *buf,\n\t\tint modulo, int pict_struct, enum mpeg_frame_type frame)\n{\n\tint i, j, mb_code, mb_len;\n\tint rows = go->interlace_coding ? go->height / 32 : go->height / 16;\n\tCODE_GEN(c, buf + 6);\n\n\tswitch (frame) {\n\tcase PFRAME:\n\t\tmb_code = 0x1;\n\t\tmb_len = 3;\n\t\tbreak;\n\tcase BFRAME_PRE:\n\t\tmb_code = 0x2;\n\t\tmb_len = 4;\n\t\tbreak;\n\tcase BFRAME_POST:\n\t\tmb_code = 0x2;\n\t\tmb_len = 3;\n\t\tbreak;\n\tcase BFRAME_BIDIR:\n\t\tmb_code = 0x2;\n\t\tmb_len = 2;\n\t\tbreak;\n\tdefault:  \n\t\tmb_code = mb_len = 0;\n\t\tbreak;\n\t}\n\n\tCODE_ADD(c, frame == PFRAME ? 0x2 : 0x3, 13);\n\tCODE_ADD(c, 0xffff, 16);\n\tCODE_ADD(c, go->format == V4L2_PIX_FMT_MPEG2 ? 0x7 : 0x4, 4);\n\tif (frame != PFRAME)\n\t\tCODE_ADD(c, go->format == V4L2_PIX_FMT_MPEG2 ? 0x7 : 0x4, 4);\n\telse\n\t\tCODE_ADD(c, 0, 4);  \n\tCODE_ADD(c, 0, 3);  \n\t \n\tj = 8 - (CODE_LENGTH(c) % 8);\n\tif (j != 8)\n\t\tCODE_ADD(c, 0, j);\n\n\tif (go->format == V4L2_PIX_FMT_MPEG2) {\n\t\tCODE_ADD(c, 0x1, 24);\n\t\tCODE_ADD(c, 0xb5, 8);\n\t\tCODE_ADD(c, 0x844, 12);\n\t\tCODE_ADD(c, frame == PFRAME ? 0xff : 0x44, 8);\n\t\tif (go->interlace_coding) {\n\t\t\tCODE_ADD(c, pict_struct, 4);\n\t\t\tif (go->dvd_mode)\n\t\t\t\tCODE_ADD(c, 0x000, 11);\n\t\t\telse\n\t\t\t\tCODE_ADD(c, 0x200, 11);\n\t\t} else {\n\t\t\tCODE_ADD(c, 0x3, 4);\n\t\t\tCODE_ADD(c, 0x20c, 11);\n\t\t}\n\t\t \n\t\tj = 8 - (CODE_LENGTH(c) % 8);\n\t\tif (j != 8)\n\t\t\tCODE_ADD(c, 0, j);\n\t}\n\n\tfor (i = 0; i < rows; ++i) {\n\t\tCODE_ADD(c, 1, 24);\n\t\tCODE_ADD(c, i + 1, 8);\n\t\tCODE_ADD(c, 0x2, 6);\n\t\tCODE_ADD(c, 0x1, 1);\n\t\tCODE_ADD(c, mb_code, mb_len);\n\t\tif (go->interlace_coding) {\n\t\t\tCODE_ADD(c, 0x1, 2);\n\t\t\tCODE_ADD(c, pict_struct == 1 ? 0x0 : 0x1, 1);\n\t\t}\n\t\tif (frame == BFRAME_BIDIR) {\n\t\t\tCODE_ADD(c, 0x3, 2);\n\t\t\tif (go->interlace_coding)\n\t\t\t\tCODE_ADD(c, pict_struct == 1 ? 0x0 : 0x1, 1);\n\t\t}\n\t\tCODE_ADD(c, 0x3, 2);\n\t\tfor (j = (go->width >> 4) - 2; j >= 33; j -= 33)\n\t\t\tCODE_ADD(c, 0x8, 11);\n\t\tCODE_ADD(c, addrinctab[j][0], addrinctab[j][1]);\n\t\tCODE_ADD(c, mb_code, mb_len);\n\t\tif (go->interlace_coding) {\n\t\t\tCODE_ADD(c, 0x1, 2);\n\t\t\tCODE_ADD(c, pict_struct == 1 ? 0x0 : 0x1, 1);\n\t\t}\n\t\tif (frame == BFRAME_BIDIR) {\n\t\t\tCODE_ADD(c, 0x3, 2);\n\t\t\tif (go->interlace_coding)\n\t\t\t\tCODE_ADD(c, pict_struct == 1 ? 0x0 : 0x1, 1);\n\t\t}\n\t\tCODE_ADD(c, 0x3, 2);\n\n\t\t \n\t\tj = 8 - (CODE_LENGTH(c) % 8);\n\t\tif (j != 8)\n\t\t\tCODE_ADD(c, 0, j);\n\t}\n\n\ti = CODE_LENGTH(c) + 4 * 8;\n\tbuf[2] = 0x00;\n\tbuf[3] = 0x00;\n\tbuf[4] = 0x01;\n\tbuf[5] = 0x00;\n\treturn i;\n}\n\nstatic int mpeg1_sequence_header(struct go7007 *go, unsigned char *buf, int ext)\n{\n\tint i, aspect_ratio, picture_rate;\n\tCODE_GEN(c, buf + 6);\n\n\tif (go->format == V4L2_PIX_FMT_MPEG1) {\n\t\tswitch (go->aspect_ratio) {\n\t\tcase GO7007_RATIO_4_3:\n\t\t\taspect_ratio = go->standard == GO7007_STD_NTSC ? 3 : 2;\n\t\t\tbreak;\n\t\tcase GO7007_RATIO_16_9:\n\t\t\taspect_ratio = go->standard == GO7007_STD_NTSC ? 5 : 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\taspect_ratio = 1;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (go->aspect_ratio) {\n\t\tcase GO7007_RATIO_4_3:\n\t\t\taspect_ratio = 2;\n\t\t\tbreak;\n\t\tcase GO7007_RATIO_16_9:\n\t\t\taspect_ratio = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\taspect_ratio = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tswitch (go->sensor_framerate) {\n\tcase 24000:\n\t\tpicture_rate = 1;\n\t\tbreak;\n\tcase 24024:\n\t\tpicture_rate = 2;\n\t\tbreak;\n\tcase 25025:\n\t\tpicture_rate = go->interlace_coding ? 6 : 3;\n\t\tbreak;\n\tcase 30000:\n\t\tpicture_rate = go->interlace_coding ? 7 : 4;\n\t\tbreak;\n\tcase 30030:\n\t\tpicture_rate = go->interlace_coding ? 8 : 5;\n\t\tbreak;\n\tdefault:\n\t\tpicture_rate = 5;  \n\t\tbreak;\n\t}\n\n\tCODE_ADD(c, go->width, 12);\n\tCODE_ADD(c, go->height, 12);\n\tCODE_ADD(c, aspect_ratio, 4);\n\tCODE_ADD(c, picture_rate, 4);\n\tCODE_ADD(c, go->format == V4L2_PIX_FMT_MPEG2 ? 20000 : 0x3ffff, 18);\n\tCODE_ADD(c, 1, 1);\n\tCODE_ADD(c, go->format == V4L2_PIX_FMT_MPEG2 ? 112 : 20, 10);\n\tCODE_ADD(c, 0, 3);\n\n\t \n\ti = 8 - (CODE_LENGTH(c) % 8);\n\tif (i != 8)\n\t\tCODE_ADD(c, 0, i);\n\n\tif (go->format == V4L2_PIX_FMT_MPEG2) {\n\t\tCODE_ADD(c, 0x1, 24);\n\t\tCODE_ADD(c, 0xb5, 8);\n\t\tCODE_ADD(c, 0x148, 12);\n\t\tif (go->interlace_coding)\n\t\t\tCODE_ADD(c, 0x20001, 20);\n\t\telse\n\t\t\tCODE_ADD(c, 0xa0001, 20);\n\t\tCODE_ADD(c, 0, 16);\n\n\t\t \n\t\ti = 8 - (CODE_LENGTH(c) % 8);\n\t\tif (i != 8)\n\t\t\tCODE_ADD(c, 0, i);\n\n\t\tif (ext) {\n\t\t\tCODE_ADD(c, 0x1, 24);\n\t\t\tCODE_ADD(c, 0xb52, 12);\n\t\t\tCODE_ADD(c, go->standard == GO7007_STD_NTSC ? 2 : 1, 3);\n\t\t\tCODE_ADD(c, 0x105, 9);\n\t\t\tCODE_ADD(c, 0x505, 16);\n\t\t\tCODE_ADD(c, go->width, 14);\n\t\t\tCODE_ADD(c, 1, 1);\n\t\t\tCODE_ADD(c, go->height, 14);\n\n\t\t\t \n\t\t\ti = 8 - (CODE_LENGTH(c) % 8);\n\t\t\tif (i != 8)\n\t\t\t\tCODE_ADD(c, 0, i);\n\t\t}\n\t}\n\n\ti = CODE_LENGTH(c) + 4 * 8;\n\tbuf[0] = i & 0xff;\n\tbuf[1] = i >> 8;\n\tbuf[2] = 0x00;\n\tbuf[3] = 0x00;\n\tbuf[4] = 0x01;\n\tbuf[5] = 0xb3;\n\treturn i;\n}\n\nstatic int gen_mpeg1hdr_to_package(struct go7007 *go,\n\t\t\t\t\t__le16 *code, int space, int *framelen)\n{\n\tu8 *buf;\n\tu16 mem = 0x3e00;\n\tunsigned int addr = 0x19;\n\tint i, off = 0, chunk;\n\n\tbuf = kzalloc(5120, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tframelen[0] = mpeg1_frame_header(go, buf, 0, 1, PFRAME);\n\tif (go->interlace_coding)\n\t\tframelen[0] += mpeg1_frame_header(go, buf + framelen[0] / 8,\n\t\t\t\t\t\t\t0, 2, PFRAME);\n\tbuf[0] = framelen[0] & 0xff;\n\tbuf[1] = framelen[0] >> 8;\n\ti = 368;\n\tframelen[1] = mpeg1_frame_header(go, buf + i, 0, 1, BFRAME_PRE);\n\tif (go->interlace_coding)\n\t\tframelen[1] += mpeg1_frame_header(go, buf + i + framelen[1] / 8,\n\t\t\t\t\t\t\t0, 2, BFRAME_PRE);\n\tbuf[i] = framelen[1] & 0xff;\n\tbuf[i + 1] = framelen[1] >> 8;\n\ti += 1632;\n\tframelen[2] = mpeg1_frame_header(go, buf + i, 0, 1, BFRAME_POST);\n\tif (go->interlace_coding)\n\t\tframelen[2] += mpeg1_frame_header(go, buf + i + framelen[2] / 8,\n\t\t\t\t\t\t\t0, 2, BFRAME_POST);\n\tbuf[i] = framelen[2] & 0xff;\n\tbuf[i + 1] = framelen[2] >> 8;\n\ti += 1432;\n\tframelen[3] = mpeg1_frame_header(go, buf + i, 0, 1, BFRAME_BIDIR);\n\tif (go->interlace_coding)\n\t\tframelen[3] += mpeg1_frame_header(go, buf + i + framelen[3] / 8,\n\t\t\t\t\t\t\t0, 2, BFRAME_BIDIR);\n\tbuf[i] = framelen[3] & 0xff;\n\tbuf[i + 1] = framelen[3] >> 8;\n\ti += 1632 + 16;\n\tmpeg1_sequence_header(go, buf + i, 0);\n\ti += 40;\n\tfor (i = 0; i < 5120; i += chunk * 2) {\n\t\tif (space - off < 32) {\n\t\t\toff = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tcode[off + 1] = __cpu_to_le16(0x8000 | mem);\n\n\t\tchunk = 28;\n\t\tif (mem + chunk > 0x4000)\n\t\t\tchunk = 0x4000 - mem;\n\t\tif (i + 2 * chunk > 5120)\n\t\t\tchunk = (5120 - i) / 2;\n\n\t\tif (chunk < 28) {\n\t\t\tcode[off] = __cpu_to_le16(0x4000 | chunk);\n\t\t\tcode[off + 31] = __cpu_to_le16(addr);\n\t\t\tif (mem + chunk == 0x4000) {\n\t\t\t\tmem = 0x3e00;\n\t\t\t\t++addr;\n\t\t\t}\n\t\t} else {\n\t\t\tcode[off] = __cpu_to_le16(0x1000 | 28);\n\t\t\tcode[off + 31] = 0;\n\t\t\tmem += 28;\n\t\t}\n\n\t\tmemcpy(&code[off + 2], buf + i, chunk * 2);\n\t\toff += 32;\n\t}\ndone:\n\tkfree(buf);\n\treturn off;\n}\n\nstatic int vti_bitlen(struct go7007 *go)\n{\n\tunsigned int i, max_time_incr = go->sensor_framerate / go->fps_scale;\n\n\tfor (i = 31; (max_time_incr & ((1 << i) - 1)) == max_time_incr; --i)\n\t\t;\n\treturn i + 1;\n}\n\nstatic int mpeg4_frame_header(struct go7007 *go, unsigned char *buf,\n\t\tint modulo, enum mpeg_frame_type frame)\n{\n\tint i;\n\tCODE_GEN(c, buf + 6);\n\tint mb_count = (go->width >> 4) * (go->height >> 4);\n\n\tCODE_ADD(c, frame == PFRAME ? 0x1 : 0x2, 2);\n\tif (modulo)\n\t\tCODE_ADD(c, 0x1, 1);\n\tCODE_ADD(c, 0x1, 2);\n\tCODE_ADD(c, 0, vti_bitlen(go));\n\tCODE_ADD(c, 0x3, 2);\n\tif (frame == PFRAME)\n\t\tCODE_ADD(c, 0, 1);\n\tCODE_ADD(c, 0xc, 11);\n\tif (frame != PFRAME)\n\t\tCODE_ADD(c, 0x4, 3);\n\tif (frame != BFRAME_EMPTY) {\n\t\tfor (i = 0; i < mb_count; ++i) {\n\t\t\tswitch (frame) {\n\t\t\tcase PFRAME:\n\t\t\t\tCODE_ADD(c, 0x1, 1);\n\t\t\t\tbreak;\n\t\t\tcase BFRAME_PRE:\n\t\t\t\tCODE_ADD(c, 0x47, 8);\n\t\t\t\tbreak;\n\t\t\tcase BFRAME_POST:\n\t\t\t\tCODE_ADD(c, 0x27, 7);\n\t\t\t\tbreak;\n\t\t\tcase BFRAME_BIDIR:\n\t\t\t\tCODE_ADD(c, 0x5f, 8);\n\t\t\t\tbreak;\n\t\t\tcase BFRAME_EMPTY:  \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\ti = 8 - (CODE_LENGTH(c) % 8);\n\tCODE_ADD(c, 0, 1);\n\tCODE_ADD(c, (1 << (i - 1)) - 1, i - 1);\n\n\ti = CODE_LENGTH(c) + 4 * 8;\n\tbuf[0] = i & 0xff;\n\tbuf[1] = i >> 8;\n\tbuf[2] = 0x00;\n\tbuf[3] = 0x00;\n\tbuf[4] = 0x01;\n\tbuf[5] = 0xb6;\n\treturn i;\n}\n\nstatic int mpeg4_sequence_header(struct go7007 *go, unsigned char *buf, int ext)\n{\n\tconst unsigned char head[] = { 0x00, 0x00, 0x01, 0xb0, go->pali,\n\t\t0x00, 0x00, 0x01, 0xb5, 0x09,\n\t\t0x00, 0x00, 0x01, 0x00,\n\t\t0x00, 0x00, 0x01, 0x20, };\n\tint i, aspect_ratio;\n\tint fps = go->sensor_framerate / go->fps_scale;\n\tCODE_GEN(c, buf + 2 + sizeof(head));\n\n\tswitch (go->aspect_ratio) {\n\tcase GO7007_RATIO_4_3:\n\t\taspect_ratio = go->standard == GO7007_STD_NTSC ? 3 : 2;\n\t\tbreak;\n\tcase GO7007_RATIO_16_9:\n\t\taspect_ratio = go->standard == GO7007_STD_NTSC ? 5 : 4;\n\t\tbreak;\n\tdefault:\n\t\taspect_ratio = 1;\n\t\tbreak;\n\t}\n\n\tmemcpy(buf + 2, head, sizeof(head));\n\tCODE_ADD(c, 0x191, 17);\n\tCODE_ADD(c, aspect_ratio, 4);\n\tCODE_ADD(c, 0x1, 4);\n\tCODE_ADD(c, fps, 16);\n\tCODE_ADD(c, 0x3, 2);\n\tCODE_ADD(c, 1001, vti_bitlen(go));\n\tCODE_ADD(c, 1, 1);\n\tCODE_ADD(c, go->width, 13);\n\tCODE_ADD(c, 1, 1);\n\tCODE_ADD(c, go->height, 13);\n\tCODE_ADD(c, 0x2830, 14);\n\n\t \n\ti = 8 - (CODE_LENGTH(c) % 8);\n\tCODE_ADD(c, 0, 1);\n\tCODE_ADD(c, (1 << (i - 1)) - 1, i - 1);\n\n\ti = CODE_LENGTH(c) + sizeof(head) * 8;\n\tbuf[0] = i & 0xff;\n\tbuf[1] = i >> 8;\n\treturn i;\n}\n\nstatic int gen_mpeg4hdr_to_package(struct go7007 *go,\n\t\t\t\t\t__le16 *code, int space, int *framelen)\n{\n\tu8 *buf;\n\tu16 mem = 0x3e00;\n\tunsigned int addr = 0x19;\n\tint i, off = 0, chunk;\n\n\tbuf = kzalloc(5120, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tframelen[0] = mpeg4_frame_header(go, buf, 0, PFRAME);\n\ti = 368;\n\tframelen[1] = mpeg4_frame_header(go, buf + i, 0, BFRAME_PRE);\n\ti += 1632;\n\tframelen[2] = mpeg4_frame_header(go, buf + i, 0, BFRAME_POST);\n\ti += 1432;\n\tframelen[3] = mpeg4_frame_header(go, buf + i, 0, BFRAME_BIDIR);\n\ti += 1632;\n\tmpeg4_frame_header(go, buf + i, 0, BFRAME_EMPTY);\n\ti += 16;\n\tmpeg4_sequence_header(go, buf + i, 0);\n\ti += 40;\n\tfor (i = 0; i < 5120; i += chunk * 2) {\n\t\tif (space - off < 32) {\n\t\t\toff = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tcode[off + 1] = __cpu_to_le16(0x8000 | mem);\n\n\t\tchunk = 28;\n\t\tif (mem + chunk > 0x4000)\n\t\t\tchunk = 0x4000 - mem;\n\t\tif (i + 2 * chunk > 5120)\n\t\t\tchunk = (5120 - i) / 2;\n\n\t\tif (chunk < 28) {\n\t\t\tcode[off] = __cpu_to_le16(0x4000 | chunk);\n\t\t\tcode[off + 31] = __cpu_to_le16(addr);\n\t\t\tif (mem + chunk == 0x4000) {\n\t\t\t\tmem = 0x3e00;\n\t\t\t\t++addr;\n\t\t\t}\n\t\t} else {\n\t\t\tcode[off] = __cpu_to_le16(0x1000 | 28);\n\t\t\tcode[off + 31] = 0;\n\t\t\tmem += 28;\n\t\t}\n\n\t\tmemcpy(&code[off + 2], buf + i, chunk * 2);\n\t\toff += 32;\n\t}\n\tmem = 0x3e00;\n\taddr = go->ipb ? 0x14f9 : 0x0af9;\n\tmemset(buf, 0, 5120);\n\tframelen[4] = mpeg4_frame_header(go, buf, 1, PFRAME);\n\ti = 368;\n\tframelen[5] = mpeg4_frame_header(go, buf + i, 1, BFRAME_PRE);\n\ti += 1632;\n\tframelen[6] = mpeg4_frame_header(go, buf + i, 1, BFRAME_POST);\n\ti += 1432;\n\tframelen[7] = mpeg4_frame_header(go, buf + i, 1, BFRAME_BIDIR);\n\ti += 1632;\n\tmpeg4_frame_header(go, buf + i, 1, BFRAME_EMPTY);\n\ti += 16;\n\tfor (i = 0; i < 5120; i += chunk * 2) {\n\t\tif (space - off < 32) {\n\t\t\toff = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tcode[off + 1] = __cpu_to_le16(0x8000 | mem);\n\n\t\tchunk = 28;\n\t\tif (mem + chunk > 0x4000)\n\t\t\tchunk = 0x4000 - mem;\n\t\tif (i + 2 * chunk > 5120)\n\t\t\tchunk = (5120 - i) / 2;\n\n\t\tif (chunk < 28) {\n\t\t\tcode[off] = __cpu_to_le16(0x4000 | chunk);\n\t\t\tcode[off + 31] = __cpu_to_le16(addr);\n\t\t\tif (mem + chunk == 0x4000) {\n\t\t\t\tmem = 0x3e00;\n\t\t\t\t++addr;\n\t\t\t}\n\t\t} else {\n\t\t\tcode[off] = __cpu_to_le16(0x1000 | 28);\n\t\t\tcode[off + 31] = 0;\n\t\t\tmem += 28;\n\t\t}\n\n\t\tmemcpy(&code[off + 2], buf + i, chunk * 2);\n\t\toff += 32;\n\t}\ndone:\n\tkfree(buf);\n\treturn off;\n}\n\nstatic int brctrl_to_package(struct go7007 *go,\n\t\t\t\t\t__le16 *code, int space, int *framelen)\n{\n\tint converge_speed = 0;\n\tint lambda = (go->format == V4L2_PIX_FMT_MJPEG || go->dvd_mode) ?\n\t\t\t\t100 : 0;\n\tint peak_rate = 6 * go->bitrate / 5;\n\tint vbv_buffer = go->format == V4L2_PIX_FMT_MJPEG ?\n\t\t\t\tgo->bitrate :\n\t\t\t\t(go->dvd_mode ? 900000 : peak_rate);\n\tint fps = go->sensor_framerate / go->fps_scale;\n\tint q = 0;\n\t \n\tu32 sgop_expt_addr = go->bitrate / 32 * (go->ipb ? 3 : 1) * 1001 / fps;\n\tu32 sgop_peak_addr = peak_rate / 32 * 1001 / fps;\n\tu32 total_expt_addr = go->bitrate / 32 * 1000 / fps * (fps / 1000);\n\tu32 vbv_alert_addr = vbv_buffer * 3 / (4 * 32);\n\tu32 cplx[] = {\n\t\tq > 0 ? sgop_expt_addr * q :\n\t\t\t2 * go->width * go->height * (go->ipb ? 6 : 4) / 32,\n\t\tq > 0 ? sgop_expt_addr * q :\n\t\t\t2 * go->width * go->height * (go->ipb ? 6 : 4) / 32,\n\t\tq > 0 ? sgop_expt_addr * q :\n\t\t\t2 * go->width * go->height * (go->ipb ? 6 : 4) / 32,\n\t\tq > 0 ? sgop_expt_addr * q :\n\t\t\t2 * go->width * go->height * (go->ipb ? 6 : 4) / 32,\n\t};\n\tu32 calc_q = q > 0 ? q : cplx[0] / sgop_expt_addr;\n\tu16 pack[] = {\n\t\t0x200e,\t\t0x0000,\n\t\t0xBF20,\t\tgo->ipb ? converge_speed_ipb[converge_speed]\n\t\t\t\t\t: converge_speed_ip[converge_speed],\n\t\t0xBF21,\t\tgo->ipb ? 2 : 0,\n\t\t0xBF22,\t\tgo->ipb ? LAMBDA_table[0][lambda / 2 + 50]\n\t\t\t\t\t: 32767,\n\t\t0xBF23,\t\tgo->ipb ? LAMBDA_table[1][lambda] : 32767,\n\t\t0xBF24,\t\t32767,\n\t\t0xBF25,\t\tlambda > 99 ? 32767 : LAMBDA_table[3][lambda],\n\t\t0xBF26,\t\tsgop_expt_addr & 0x0000FFFF,\n\t\t0xBF27,\t\tsgop_expt_addr >> 16,\n\t\t0xBF28,\t\tsgop_peak_addr & 0x0000FFFF,\n\t\t0xBF29,\t\tsgop_peak_addr >> 16,\n\t\t0xBF2A,\t\tvbv_alert_addr & 0x0000FFFF,\n\t\t0xBF2B,\t\tvbv_alert_addr >> 16,\n\t\t0xBF2C,\t\t0,\n\t\t0xBF2D,\t\t0,\n\t\t0,\t\t0,\n\n\t\t0x200e,\t\t0x0000,\n\t\t0xBF2E,\t\tvbv_alert_addr & 0x0000FFFF,\n\t\t0xBF2F,\t\tvbv_alert_addr >> 16,\n\t\t0xBF30,\t\tcplx[0] & 0x0000FFFF,\n\t\t0xBF31,\t\tcplx[0] >> 16,\n\t\t0xBF32,\t\tcplx[1] & 0x0000FFFF,\n\t\t0xBF33,\t\tcplx[1] >> 16,\n\t\t0xBF34,\t\tcplx[2] & 0x0000FFFF,\n\t\t0xBF35,\t\tcplx[2] >> 16,\n\t\t0xBF36,\t\tcplx[3] & 0x0000FFFF,\n\t\t0xBF37,\t\tcplx[3] >> 16,\n\t\t0xBF38,\t\t0,\n\t\t0xBF39,\t\t0,\n\t\t0xBF3A,\t\ttotal_expt_addr & 0x0000FFFF,\n\t\t0xBF3B,\t\ttotal_expt_addr >> 16,\n\t\t0,\t\t0,\n\n\t\t0x200e,\t\t0x0000,\n\t\t0xBF3C,\t\ttotal_expt_addr & 0x0000FFFF,\n\t\t0xBF3D,\t\ttotal_expt_addr >> 16,\n\t\t0xBF3E,\t\t0,\n\t\t0xBF3F,\t\t0,\n\t\t0xBF48,\t\t0,\n\t\t0xBF49,\t\t0,\n\t\t0xBF4A,\t\tcalc_q < 4 ? 4 : (calc_q > 124 ? 124 : calc_q),\n\t\t0xBF4B,\t\t4,\n\t\t0xBF4C,\t\t0,\n\t\t0xBF4D,\t\t0,\n\t\t0xBF4E,\t\t0,\n\t\t0xBF4F,\t\t0,\n\t\t0xBF50,\t\t0,\n\t\t0xBF51,\t\t0,\n\t\t0,\t\t0,\n\n\t\t0x200e,\t\t0x0000,\n\t\t0xBF40,\t\tsgop_expt_addr & 0x0000FFFF,\n\t\t0xBF41,\t\tsgop_expt_addr >> 16,\n\t\t0xBF42,\t\t0,\n\t\t0xBF43,\t\t0,\n\t\t0xBF44,\t\t0,\n\t\t0xBF45,\t\t0,\n\t\t0xBF46,\t\t(go->width >> 4) * (go->height >> 4),\n\t\t0xBF47,\t\t0,\n\t\t0xBF64,\t\t0,\n\t\t0xBF65,\t\t0,\n\t\t0xBF18,\t\tframelen[4],\n\t\t0xBF19,\t\tframelen[5],\n\t\t0xBF1A,\t\tframelen[6],\n\t\t0xBF1B,\t\tframelen[7],\n\t\t0,\t\t0,\n\n#if 0\n\t\t \n\t\t0x200e,\t\t0x0000,\n\t\t0xBF56,\t\t4,\n\t\t0xBF57,\t\t0,\n\t\t0xBF58,\t\t5,\n\t\t0xBF59,\t\t0,\n\t\t0xBF5A,\t\t6,\n\t\t0xBF5B,\t\t0,\n\t\t0xBF5C,\t\t8,\n\t\t0xBF5D,\t\t0,\n\t\t0xBF5E,\t\t1,\n\t\t0xBF5F,\t\t0,\n\t\t0xBF60,\t\t1,\n\t\t0xBF61,\t\t0,\n\t\t0xBF62,\t\t0,\n\t\t0xBF63,\t\t0,\n\t\t0,\t\t0,\n#else\n\t\t0x2008,\t\t0x0000,\n\t\t0xBF56,\t\t4,\n\t\t0xBF57,\t\t0,\n\t\t0xBF58,\t\t5,\n\t\t0xBF59,\t\t0,\n\t\t0xBF5A,\t\t6,\n\t\t0xBF5B,\t\t0,\n\t\t0xBF5C,\t\t8,\n\t\t0xBF5D,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n#endif\n\n\t\t0x200e,\t\t0x0000,\n\t\t0xBF10,\t\t0,\n\t\t0xBF11,\t\t0,\n\t\t0xBF12,\t\t0,\n\t\t0xBF13,\t\t0,\n\t\t0xBF14,\t\t0,\n\t\t0xBF15,\t\t0,\n\t\t0xBF16,\t\t0,\n\t\t0xBF17,\t\t0,\n\t\t0xBF7E,\t\t0,\n\t\t0xBF7F,\t\t1,\n\t\t0xBF52,\t\tframelen[0],\n\t\t0xBF53,\t\tframelen[1],\n\t\t0xBF54,\t\tframelen[2],\n\t\t0xBF55,\t\tframelen[3],\n\t\t0,\t\t0,\n\t};\n\n\treturn copy_packages(code, pack, 6, space);\n}\n\nstatic int config_package(struct go7007 *go, __le16 *code, int space)\n{\n\tint fps = go->sensor_framerate / go->fps_scale / 1000;\n\tint rows = go->interlace_coding ? go->height / 32 : go->height / 16;\n\tint brc_window_size = fps;\n\tint q_min = 2, q_max = 31;\n\tint THACCoeffSet0 = 0;\n\tu16 pack[] = {\n\t\t0x200e,\t\t0x0000,\n\t\t0xc002,\t\t0x14b4,\n\t\t0xc003,\t\t0x28b4,\n\t\t0xc004,\t\t0x3c5a,\n\t\t0xdc05,\t\t0x2a77,\n\t\t0xc6c3,\t\tgo->format == V4L2_PIX_FMT_MPEG4 ? 0 :\n\t\t\t\t(go->format == V4L2_PIX_FMT_H263 ? 0 : 1),\n\t\t0xc680,\t\tgo->format == V4L2_PIX_FMT_MPEG4 ? 0xf1 :\n\t\t\t\t(go->format == V4L2_PIX_FMT_H263 ? 0x61 :\n\t\t\t\t\t\t\t\t\t0xd3),\n\t\t0xc780,\t\t0x0140,\n\t\t0xe009,\t\t0x0001,\n\t\t0xc60f,\t\t0x0008,\n\t\t0xd4ff,\t\t0x0002,\n\t\t0xe403,\t\t2340,\n\t\t0xe406,\t\t75,\n\t\t0xd411,\t\t0x0001,\n\t\t0xd410,\t\t0xa1d6,\n\t\t0x0001,\t\t0x2801,\n\n\t\t0x200d,\t\t0x0000,\n\t\t0xe402,\t\t0x018b,\n\t\t0xe401,\t\t0x8b01,\n\t\t0xd472,\t\t(go->board_info->sensor_flags &\n\t\t\t\t\t\t\tGO7007_SENSOR_TV) &&\n\t\t\t\t\t\t(!go->interlace_coding) ?\n\t\t\t\t\t0x01b0 : 0x0170,\n\t\t0xd475,\t\t(go->board_info->sensor_flags &\n\t\t\t\t\t\t\tGO7007_SENSOR_TV) &&\n\t\t\t\t\t\t(!go->interlace_coding) ?\n\t\t\t\t\t0x0008 : 0x0009,\n\t\t0xc404,\t\tgo->interlace_coding ? 0x44 :\n\t\t\t\t(go->format == V4L2_PIX_FMT_MPEG4 ? 0x11 :\n\t\t\t\t(go->format == V4L2_PIX_FMT_MPEG1 ? 0x02 :\n\t\t\t\t(go->format == V4L2_PIX_FMT_MPEG2 ? 0x04 :\n\t\t\t\t(go->format == V4L2_PIX_FMT_H263  ? 0x08 :\n\t\t\t\t\t\t\t\t     0x20)))),\n\t\t0xbf0a,\t\t(go->format == V4L2_PIX_FMT_MPEG4 ? 8 :\n\t\t\t\t(go->format == V4L2_PIX_FMT_MPEG1 ? 1 :\n\t\t\t\t(go->format == V4L2_PIX_FMT_MPEG2 ? 2 :\n\t\t\t\t(go->format == V4L2_PIX_FMT_H263 ? 4 : 16)))) |\n\t\t\t\t((go->repeat_seqhead ? 1 : 0) << 6) |\n\t\t\t\t((go->dvd_mode ? 1 : 0) << 9) |\n\t\t\t\t((go->gop_header_enable ? 1 : 0) << 10),\n\t\t0xbf0b,\t\t0,\n\t\t0xdd5a,\t\tgo->ipb ? 0x14 : 0x0a,\n\t\t0xbf0c,\t\t0,\n\t\t0xbf0d,\t\t0,\n\t\t0xc683,\t\tTHACCoeffSet0,\n\t\t0xc40a,\t\t(go->width << 4) | rows,\n\t\t0xe01a,\t\tgo->board_info->hpi_buffer_cap,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\n\t\t0x2008,\t\t0,\n\t\t0xe402,\t\t0x88,\n\t\t0xe401,\t\t0x8f01,\n\t\t0xbf6a,\t\t0,\n\t\t0xbf6b,\t\t0,\n\t\t0xbf6c,\t\t0,\n\t\t0xbf6d,\t\t0,\n\t\t0xbf6e,\t\t0,\n\t\t0xbf6f,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\n\t\t0x200e,\t\t0,\n\t\t0xbf66,\t\tbrc_window_size,\n\t\t0xbf67,\t\t0,\n\t\t0xbf68,\t\tq_min,\n\t\t0xbf69,\t\tq_max,\n\t\t0xbfe0,\t\t0,\n\t\t0xbfe1,\t\t0,\n\t\t0xbfe2,\t\t0,\n\t\t0xbfe3,\t\tgo->ipb ? 3 : 1,\n\t\t0xc031,\t\tgo->board_info->sensor_flags &\n\t\t\t\t\tGO7007_SENSOR_VBI ? 1 : 0,\n\t\t0xc01c,\t\t0x1f,\n\t\t0xdd8c,\t\t0x15,\n\t\t0xdd94,\t\t0x15,\n\t\t0xdd88,\t\tgo->ipb ? 0x1401 : 0x0a01,\n\t\t0xdd90,\t\tgo->ipb ? 0x1401 : 0x0a01,\n\t\t0,\t\t0,\n\n\t\t0x200e,\t\t0,\n\t\t0xbfe4,\t\t0,\n\t\t0xbfe5,\t\t0,\n\t\t0xbfe6,\t\t0,\n\t\t0xbfe7,\t\tfps << 8,\n\t\t0xbfe8,\t\t0x3a00,\n\t\t0xbfe9,\t\t0,\n\t\t0xbfea,\t\t0,\n\t\t0xbfeb,\t\t0,\n\t\t0xbfec,\t\t(go->interlace_coding ? 1 << 15 : 0) |\n\t\t\t\t\t(go->modet_enable ? 0xa : 0) |\n\t\t\t\t\t(go->board_info->sensor_flags &\n\t\t\t\t\t\tGO7007_SENSOR_VBI ? 1 : 0),\n\t\t0xbfed,\t\t0,\n\t\t0xbfee,\t\t0,\n\t\t0xbfef,\t\t0,\n\t\t0xbff0,\t\tgo->board_info->sensor_flags &\n\t\t\t\t\tGO7007_SENSOR_TV ? 0xf060 : 0xb060,\n\t\t0xbff1,\t\t0,\n\t\t0,\t\t0,\n\t};\n\n\treturn copy_packages(code, pack, 5, space);\n}\n\nstatic int seqhead_to_package(struct go7007 *go, __le16 *code, int space,\n\tint (*sequence_header_func)(struct go7007 *go,\n\t\tunsigned char *buf, int ext))\n{\n\tint vop_time_increment_bitlength = vti_bitlen(go);\n\tint fps = go->sensor_framerate / go->fps_scale *\n\t\t\t\t\t(go->interlace_coding ? 2 : 1);\n\tunsigned char buf[40] = { };\n\tint len = sequence_header_func(go, buf, 1);\n\tu16 pack[] = {\n\t\t0x2006,\t\t0,\n\t\t0xbf08,\t\tfps,\n\t\t0xbf09,\t\t0,\n\t\t0xbff2,\t\tvop_time_increment_bitlength,\n\t\t0xbff3,\t\t(1 << vop_time_increment_bitlength) - 1,\n\t\t0xbfe6,\t\t0,\n\t\t0xbfe7,\t\t(fps / 1000) << 8,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\n\t\t0x2007,\t\t0,\n\t\t0xc800,\t\tbuf[2] << 8 | buf[3],\n\t\t0xc801,\t\tbuf[4] << 8 | buf[5],\n\t\t0xc802,\t\tbuf[6] << 8 | buf[7],\n\t\t0xc803,\t\tbuf[8] << 8 | buf[9],\n\t\t0xc406,\t\t64,\n\t\t0xc407,\t\tlen - 64,\n\t\t0xc61b,\t\t1,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\n\t\t0x200e,\t\t0,\n\t\t0xc808,\t\tbuf[10] << 8 | buf[11],\n\t\t0xc809,\t\tbuf[12] << 8 | buf[13],\n\t\t0xc80a,\t\tbuf[14] << 8 | buf[15],\n\t\t0xc80b,\t\tbuf[16] << 8 | buf[17],\n\t\t0xc80c,\t\tbuf[18] << 8 | buf[19],\n\t\t0xc80d,\t\tbuf[20] << 8 | buf[21],\n\t\t0xc80e,\t\tbuf[22] << 8 | buf[23],\n\t\t0xc80f,\t\tbuf[24] << 8 | buf[25],\n\t\t0xc810,\t\tbuf[26] << 8 | buf[27],\n\t\t0xc811,\t\tbuf[28] << 8 | buf[29],\n\t\t0xc812,\t\tbuf[30] << 8 | buf[31],\n\t\t0xc813,\t\tbuf[32] << 8 | buf[33],\n\t\t0xc814,\t\tbuf[34] << 8 | buf[35],\n\t\t0xc815,\t\tbuf[36] << 8 | buf[37],\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t};\n\n\treturn copy_packages(code, pack, 3, space);\n}\n\nstatic int relative_prime(int big, int little)\n{\n\tint remainder;\n\n\twhile (little != 0) {\n\t\tremainder = big % little;\n\t\tbig = little;\n\t\tlittle = remainder;\n\t}\n\treturn big;\n}\n\nstatic int avsync_to_package(struct go7007 *go, __le16 *code, int space)\n{\n\tint arate = go->board_info->audio_rate * 1001 * go->fps_scale;\n\tint ratio = arate / go->sensor_framerate;\n\tint adjratio = ratio * 215 / 100;\n\tint rprime = relative_prime(go->sensor_framerate,\n\t\t\t\t\tarate % go->sensor_framerate);\n\tint f1 = (arate % go->sensor_framerate) / rprime;\n\tint f2 = (go->sensor_framerate - arate % go->sensor_framerate) / rprime;\n\tu16 pack[] = {\n\t\t0x200e,\t\t0,\n\t\t0xbf98,\t\t(u16)((-adjratio) & 0xffff),\n\t\t0xbf99,\t\t(u16)((-adjratio) >> 16),\n\t\t0xbf92,\t\t0,\n\t\t0xbf93,\t\t0,\n\t\t0xbff4,\t\tf1 > f2 ? f1 : f2,\n\t\t0xbff5,\t\tf1 < f2 ? f1 : f2,\n\t\t0xbff6,\t\tf1 < f2 ? ratio : ratio + 1,\n\t\t0xbff7,\t\tf1 > f2 ? ratio : ratio + 1,\n\t\t0xbff8,\t\t0,\n\t\t0xbff9,\t\t0,\n\t\t0xbffa,\t\tadjratio & 0xffff,\n\t\t0xbffb,\t\tadjratio >> 16,\n\t\t0xbf94,\t\t0,\n\t\t0xbf95,\t\t0,\n\t\t0,\t\t0,\n\t};\n\n\treturn copy_packages(code, pack, 1, space);\n}\n\nstatic int final_package(struct go7007 *go, __le16 *code, int space)\n{\n\tint rows = go->interlace_coding ? go->height / 32 : go->height / 16;\n\tu16 pack[] = {\n\t\t0x8000,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t2,\n\t\t((go->board_info->sensor_flags & GO7007_SENSOR_TV) &&\n\t\t\t\t\t\t(!go->interlace_coding) ?\n\t\t\t\t\t(1 << 14) | (1 << 9) : 0) |\n\t\t\t((go->encoder_subsample ? 1 : 0) << 8) |\n\t\t\t(go->board_info->sensor_flags &\n\t\t\t\tGO7007_SENSOR_CONFIG_MASK),\n\t\t((go->encoder_v_halve ? 1 : 0) << 14) |\n\t\t\t(go->encoder_v_halve ? rows << 9 : rows << 8) |\n\t\t\t(go->encoder_h_halve ? 1 << 6 : 0) |\n\t\t\t(go->encoder_h_halve ? go->width >> 3 : go->width >> 4),\n\t\t(1 << 15) | (go->encoder_v_offset << 6) |\n\t\t\t(1 << 7) | (go->encoder_h_offset >> 2),\n\t\t(1 << 6),\n\t\t0,\n\t\t0,\n\t\t((go->fps_scale - 1) << 8) |\n\t\t\t(go->board_info->sensor_flags & GO7007_SENSOR_TV ?\n\t\t\t\t\t\t(1 << 7) : 0) |\n\t\t\t0x41,\n\t\tgo->ipb ? 0xd4c : 0x36b,\n\t\t(rows << 8) | (go->width >> 4),\n\t\tgo->format == V4L2_PIX_FMT_MPEG4 ? 0x0404 : 0,\n\t\t(1 << 15) | ((go->interlace_coding ? 1 : 0) << 13) |\n\t\t\t((go->closed_gop ? 1 : 0) << 12) |\n\t\t\t((go->format == V4L2_PIX_FMT_MPEG4 ? 1 : 0) << 11) |\n\t\t \n\t\t\t((go->ipb ? 3 : 0) << 7) |\n\t\t\t((go->modet_enable ? 1 : 0) << 2) |\n\t\t\t((go->dvd_mode ? 1 : 0) << 1) | 1,\n\t\t(go->format == V4L2_PIX_FMT_MPEG1 ? 0x89a0 :\n\t\t\t(go->format == V4L2_PIX_FMT_MPEG2 ? 0x89a0 :\n\t\t\t(go->format == V4L2_PIX_FMT_MJPEG ? 0x89a0 :\n\t\t\t(go->format == V4L2_PIX_FMT_MPEG4 ? 0x8920 :\n\t\t\t(go->format == V4L2_PIX_FMT_H263 ? 0x8920 : 0))))),\n\t\tgo->ipb ? 0x1f15 : 0x1f0b,\n\t\tgo->ipb ? 0x0015 : 0x000b,\n\t\tgo->ipb ? 0xa800 : 0x5800,\n\t\t0xffff,\n\t\t0x0020 + 0x034b * 0,\n\t\t0x0020 + 0x034b * 1,\n\t\t0x0020 + 0x034b * 2,\n\t\t0x0020 + 0x034b * 3,\n\t\t0x0020 + 0x034b * 4,\n\t\t0x0020 + 0x034b * 5,\n\t\tgo->ipb ? (go->gop_size / 3) : go->gop_size,\n\t\t(go->height >> 4) * (go->width >> 4) * 110 / 100,\n\t};\n\n\treturn copy_packages(code, pack, 1, space);\n}\n\nstatic int audio_to_package(struct go7007 *go, __le16 *code, int space)\n{\n\tint clock_config = ((go->board_info->audio_flags &\n\t\t\t\tGO7007_AUDIO_I2S_MASTER ? 1 : 0) << 11) |\n\t\t\t((go->board_info->audio_flags &\n\t\t\t\tGO7007_AUDIO_OKI_MODE ? 1 : 0) << 8) |\n\t\t\t(((go->board_info->audio_bclk_div / 4) - 1) << 4) |\n\t\t\t(go->board_info->audio_main_div - 1);\n\tu16 pack[] = {\n\t\t0x200d,\t\t0,\n\t\t0x9002,\t\t0,\n\t\t0x9002,\t\t0,\n\t\t0x9031,\t\t0,\n\t\t0x9032,\t\t0,\n\t\t0x9033,\t\t0,\n\t\t0x9034,\t\t0,\n\t\t0x9035,\t\t0,\n\t\t0x9036,\t\t0,\n\t\t0x9037,\t\t0,\n\t\t0x9040,\t\t0,\n\t\t0x9000,\t\tclock_config,\n\t\t0x9001,\t\t(go->board_info->audio_flags & 0xffff) |\n\t\t\t\t\t(1 << 9),\n\t\t0x9000,\t\t((go->board_info->audio_flags &\n\t\t\t\t\t\tGO7007_AUDIO_I2S_MASTER ?\n\t\t\t\t\t\t1 : 0) << 10) |\n\t\t\t\t\tclock_config,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0x2005,\t\t0,\n\t\t0x9041,\t\t0,\n\t\t0x9042,\t\t256,\n\t\t0x9043,\t\t0,\n\t\t0x9044,\t\t16,\n\t\t0x9045,\t\t16,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t\t0,\t\t0,\n\t};\n\n\treturn copy_packages(code, pack, 2, space);\n}\n\nstatic int modet_to_package(struct go7007 *go, __le16 *code, int space)\n{\n\tbool has_modet0 = go->modet[0].enable;\n\tbool has_modet1 = go->modet[1].enable;\n\tbool has_modet2 = go->modet[2].enable;\n\tbool has_modet3 = go->modet[3].enable;\n\tint ret, mb, i, addr, cnt = 0;\n\tu16 pack[32];\n\tu16 thresholds[] = {\n\t\t0x200e,\t\t0,\n\t\t0xbf82,\t\thas_modet0 ? go->modet[0].pixel_threshold : 32767,\n\t\t0xbf83,\t\thas_modet1 ? go->modet[1].pixel_threshold : 32767,\n\t\t0xbf84,\t\thas_modet2 ? go->modet[2].pixel_threshold : 32767,\n\t\t0xbf85,\t\thas_modet3 ? go->modet[3].pixel_threshold : 32767,\n\t\t0xbf86,\t\thas_modet0 ? go->modet[0].motion_threshold : 32767,\n\t\t0xbf87,\t\thas_modet1 ? go->modet[1].motion_threshold : 32767,\n\t\t0xbf88,\t\thas_modet2 ? go->modet[2].motion_threshold : 32767,\n\t\t0xbf89,\t\thas_modet3 ? go->modet[3].motion_threshold : 32767,\n\t\t0xbf8a,\t\thas_modet0 ? go->modet[0].mb_threshold : 32767,\n\t\t0xbf8b,\t\thas_modet1 ? go->modet[1].mb_threshold : 32767,\n\t\t0xbf8c,\t\thas_modet2 ? go->modet[2].mb_threshold : 32767,\n\t\t0xbf8d,\t\thas_modet3 ? go->modet[3].mb_threshold : 32767,\n\t\t0xbf8e,\t\t0,\n\t\t0xbf8f,\t\t0,\n\t\t0,\t\t0,\n\t};\n\n\tret = copy_packages(code, thresholds, 1, space);\n\tif (ret < 0)\n\t\treturn -1;\n\tcnt += ret;\n\n\taddr = 0xbac0;\n\tmemset(pack, 0, 64);\n\ti = 0;\n\tfor (mb = 0; mb < 1624; ++mb) {\n\t\tpack[i * 2 + 3] <<= 2;\n\t\tpack[i * 2 + 3] |= go->modet_map[mb];\n\t\tif (mb % 8 != 7)\n\t\t\tcontinue;\n\t\tpack[i * 2 + 2] = addr++;\n\t\t++i;\n\t\tif (i == 10 || mb == 1623) {\n\t\t\tpack[0] = 0x2000 | i;\n\t\t\tret = copy_packages(code + cnt, pack, 1, space - cnt);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -1;\n\t\t\tcnt += ret;\n\t\t\ti = 0;\n\t\t\tmemset(pack, 0, 64);\n\t\t}\n\t\tpack[i * 2 + 3] = 0;\n\t}\n\n\tmemset(pack, 0, 64);\n\ti = 0;\n\tfor (addr = 0xbb90; addr < 0xbbfa; ++addr) {\n\t\tpack[i * 2 + 2] = addr;\n\t\tpack[i * 2 + 3] = 0;\n\t\t++i;\n\t\tif (i == 10 || addr == 0xbbf9) {\n\t\t\tpack[0] = 0x2000 | i;\n\t\t\tret = copy_packages(code + cnt, pack, 1, space - cnt);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -1;\n\t\t\tcnt += ret;\n\t\t\ti = 0;\n\t\t\tmemset(pack, 0, 64);\n\t\t}\n\t}\n\treturn cnt;\n}\n\nstatic noinline_for_stack int do_special(struct go7007 *go, u16 type,\n\t\t\t\t\t __le16 *code, int space, int *framelen)\n{\n\tswitch (type) {\n\tcase SPECIAL_FRM_HEAD:\n\t\tswitch (go->format) {\n\t\tcase V4L2_PIX_FMT_MJPEG:\n\t\t\treturn gen_mjpeghdr_to_package(go, code, space);\n\t\tcase V4L2_PIX_FMT_MPEG1:\n\t\tcase V4L2_PIX_FMT_MPEG2:\n\t\t\treturn gen_mpeg1hdr_to_package(go, code, space,\n\t\t\t\t\t\t\t\tframelen);\n\t\tcase V4L2_PIX_FMT_MPEG4:\n\t\t\treturn gen_mpeg4hdr_to_package(go, code, space,\n\t\t\t\t\t\t\t\tframelen);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SPECIAL_BRC_CTRL:\n\t\treturn brctrl_to_package(go, code, space, framelen);\n\tcase SPECIAL_CONFIG:\n\t\treturn config_package(go, code, space);\n\tcase SPECIAL_SEQHEAD:\n\t\tswitch (go->format) {\n\t\tcase V4L2_PIX_FMT_MPEG1:\n\t\tcase V4L2_PIX_FMT_MPEG2:\n\t\t\treturn seqhead_to_package(go, code, space,\n\t\t\t\t\tmpeg1_sequence_header);\n\t\tcase V4L2_PIX_FMT_MPEG4:\n\t\t\treturn seqhead_to_package(go, code, space,\n\t\t\t\t\tmpeg4_sequence_header);\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase SPECIAL_AV_SYNC:\n\t\treturn avsync_to_package(go, code, space);\n\tcase SPECIAL_FINAL:\n\t\treturn final_package(go, code, space);\n\tcase SPECIAL_AUDIO:\n\t\treturn audio_to_package(go, code, space);\n\tcase SPECIAL_MODET:\n\t\treturn modet_to_package(go, code, space);\n\t}\n\tdev_err(go->dev,\n\t\t\"firmware file contains unsupported feature %04x\\n\", type);\n\treturn -1;\n}\n\nint go7007_construct_fw_image(struct go7007 *go, u8 **fw, int *fwlen)\n{\n\tconst struct firmware *fw_entry;\n\t__le16 *code, *src;\n\tint framelen[8] = { };  \n\tint codespace = 64 * 1024, i = 0, srclen, chunk_len, chunk_flags;\n\tint mode_flag;\n\tint ret;\n\n\tswitch (go->format) {\n\tcase V4L2_PIX_FMT_MJPEG:\n\t\tmode_flag = FLAG_MODE_MJPEG;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_MPEG1:\n\t\tmode_flag = FLAG_MODE_MPEG1;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_MPEG2:\n\t\tmode_flag = FLAG_MODE_MPEG2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_MPEG4:\n\t\tmode_flag = FLAG_MODE_MPEG4;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\tif (request_firmware(&fw_entry, GO7007_FW_NAME, go->dev)) {\n\t\tdev_err(go->dev,\n\t\t\t\"unable to load firmware from file \\\"%s\\\"\\n\",\n\t\t\tGO7007_FW_NAME);\n\t\treturn -1;\n\t}\n\tcode = kcalloc(codespace, 2, GFP_KERNEL);\n\tif (code == NULL)\n\t\tgoto fw_failed;\n\n\tsrc = (__le16 *)fw_entry->data;\n\tsrclen = fw_entry->size / 2;\n\twhile (srclen >= 2) {\n\t\tchunk_flags = __le16_to_cpu(src[0]);\n\t\tchunk_len = __le16_to_cpu(src[1]);\n\t\tif (chunk_len + 2 > srclen) {\n\t\t\tdev_err(go->dev,\n\t\t\t\t\"firmware file \\\"%s\\\" appears to be corrupted\\n\",\n\t\t\t\tGO7007_FW_NAME);\n\t\t\tgoto fw_failed;\n\t\t}\n\t\tif (chunk_flags & mode_flag) {\n\t\t\tif (chunk_flags & FLAG_SPECIAL) {\n\t\t\t\tret = do_special(go, __le16_to_cpu(src[2]),\n\t\t\t\t\t&code[i], codespace - i, framelen);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_err(go->dev,\n\t\t\t\t\t\t\"insufficient memory for firmware construction\\n\");\n\t\t\t\t\tgoto fw_failed;\n\t\t\t\t}\n\t\t\t\ti += ret;\n\t\t\t} else {\n\t\t\t\tif (codespace - i < chunk_len) {\n\t\t\t\t\tdev_err(go->dev,\n\t\t\t\t\t\t\"insufficient memory for firmware construction\\n\");\n\t\t\t\t\tgoto fw_failed;\n\t\t\t\t}\n\t\t\t\tmemcpy(&code[i], &src[2], chunk_len * 2);\n\t\t\t\ti += chunk_len;\n\t\t\t}\n\t\t}\n\t\tsrclen -= chunk_len + 2;\n\t\tsrc += chunk_len + 2;\n\t}\n\trelease_firmware(fw_entry);\n\t*fw = (u8 *)code;\n\t*fwlen = i * 2;\n\treturn 0;\n\nfw_failed:\n\tkfree(code);\n\trelease_firmware(fw_entry);\n\treturn -1;\n}\n\nMODULE_FIRMWARE(GO7007_FW_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}