{
  "module_name": "go7007-v4l2.c",
  "hash_id": "39458bbf33f480948ed93f81fc8319e38564adf575e455f93000b27a87897e71",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/go7007/go7007-v4l2.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/unistd.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-subdev.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-vmalloc.h>\n#include <media/i2c/saa7115.h>\n\n#include \"go7007-priv.h\"\n\n#define call_all(dev, o, f, args...) \\\n\tv4l2_device_call_until_err(dev, 0, o, f, ##args)\n\nstatic bool valid_pixelformat(u32 pixelformat)\n{\n\tswitch (pixelformat) {\n\tcase V4L2_PIX_FMT_MJPEG:\n\tcase V4L2_PIX_FMT_MPEG1:\n\tcase V4L2_PIX_FMT_MPEG2:\n\tcase V4L2_PIX_FMT_MPEG4:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic u32 get_frame_type_flag(struct go7007_buffer *vb, int format)\n{\n\tu8 *ptr = vb2_plane_vaddr(&vb->vb.vb2_buf, 0);\n\n\tswitch (format) {\n\tcase V4L2_PIX_FMT_MJPEG:\n\t\treturn V4L2_BUF_FLAG_KEYFRAME;\n\tcase V4L2_PIX_FMT_MPEG4:\n\t\tswitch ((ptr[vb->frame_offset + 4] >> 6) & 0x3) {\n\t\tcase 0:\n\t\t\treturn V4L2_BUF_FLAG_KEYFRAME;\n\t\tcase 1:\n\t\t\treturn V4L2_BUF_FLAG_PFRAME;\n\t\tcase 2:\n\t\t\treturn V4L2_BUF_FLAG_BFRAME;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase V4L2_PIX_FMT_MPEG1:\n\tcase V4L2_PIX_FMT_MPEG2:\n\t\tswitch ((ptr[vb->frame_offset + 5] >> 3) & 0x7) {\n\t\tcase 1:\n\t\t\treturn V4L2_BUF_FLAG_KEYFRAME;\n\t\tcase 2:\n\t\t\treturn V4L2_BUF_FLAG_PFRAME;\n\t\tcase 3:\n\t\t\treturn V4L2_BUF_FLAG_BFRAME;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void get_resolution(struct go7007 *go, int *width, int *height)\n{\n\tswitch (go->standard) {\n\tcase GO7007_STD_NTSC:\n\t\t*width = 720;\n\t\t*height = 480;\n\t\tbreak;\n\tcase GO7007_STD_PAL:\n\t\t*width = 720;\n\t\t*height = 576;\n\t\tbreak;\n\tcase GO7007_STD_OTHER:\n\tdefault:\n\t\t*width = go->board_info->sensor_width;\n\t\t*height = go->board_info->sensor_height;\n\t\tbreak;\n\t}\n}\n\nstatic void set_formatting(struct go7007 *go)\n{\n\tif (go->format == V4L2_PIX_FMT_MJPEG) {\n\t\tgo->pali = 0;\n\t\tgo->aspect_ratio = GO7007_RATIO_1_1;\n\t\tgo->gop_size = 0;\n\t\tgo->ipb = 0;\n\t\tgo->closed_gop = 0;\n\t\tgo->repeat_seqhead = 0;\n\t\tgo->seq_header_enable = 0;\n\t\tgo->gop_header_enable = 0;\n\t\tgo->dvd_mode = 0;\n\t\treturn;\n\t}\n\n\tswitch (go->format) {\n\tcase V4L2_PIX_FMT_MPEG1:\n\t\tgo->pali = 0;\n\t\tbreak;\n\tdefault:\n\tcase V4L2_PIX_FMT_MPEG2:\n\t\tgo->pali = 0x48;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_MPEG4:\n\t\t \n\t\tgo->pali = 0xf5;\n\t\tbreak;\n\t}\n\tgo->gop_size = v4l2_ctrl_g_ctrl(go->mpeg_video_gop_size);\n\tgo->closed_gop = v4l2_ctrl_g_ctrl(go->mpeg_video_gop_closure);\n\tgo->ipb = v4l2_ctrl_g_ctrl(go->mpeg_video_b_frames) != 0;\n\tgo->bitrate = v4l2_ctrl_g_ctrl(go->mpeg_video_bitrate);\n\tgo->repeat_seqhead = v4l2_ctrl_g_ctrl(go->mpeg_video_rep_seqheader);\n\tgo->gop_header_enable = 1;\n\tgo->dvd_mode = 0;\n\tif (go->format == V4L2_PIX_FMT_MPEG2)\n\t\tgo->dvd_mode =\n\t\t\tgo->bitrate == 9800000 &&\n\t\t\tgo->gop_size == 15 &&\n\t\t\tgo->ipb == 0 &&\n\t\t\tgo->repeat_seqhead == 1 &&\n\t\t\tgo->closed_gop;\n\n\tswitch (v4l2_ctrl_g_ctrl(go->mpeg_video_aspect_ratio)) {\n\tdefault:\n\tcase V4L2_MPEG_VIDEO_ASPECT_1x1:\n\t\tgo->aspect_ratio = GO7007_RATIO_1_1;\n\t\tbreak;\n\tcase V4L2_MPEG_VIDEO_ASPECT_4x3:\n\t\tgo->aspect_ratio = GO7007_RATIO_4_3;\n\t\tbreak;\n\tcase V4L2_MPEG_VIDEO_ASPECT_16x9:\n\t\tgo->aspect_ratio = GO7007_RATIO_16_9;\n\t\tbreak;\n\t}\n}\n\nstatic int set_capture_size(struct go7007 *go, struct v4l2_format *fmt, int try)\n{\n\tint sensor_height = 0, sensor_width = 0;\n\tint width, height;\n\n\tif (fmt != NULL && !valid_pixelformat(fmt->fmt.pix.pixelformat))\n\t\treturn -EINVAL;\n\n\tget_resolution(go, &sensor_width, &sensor_height);\n\n\tif (fmt == NULL) {\n\t\twidth = sensor_width;\n\t\theight = sensor_height;\n\t} else if (go->board_info->sensor_flags & GO7007_SENSOR_SCALING) {\n\t\tif (fmt->fmt.pix.width > sensor_width)\n\t\t\twidth = sensor_width;\n\t\telse if (fmt->fmt.pix.width < 144)\n\t\t\twidth = 144;\n\t\telse\n\t\t\twidth = fmt->fmt.pix.width & ~0x0f;\n\n\t\tif (fmt->fmt.pix.height > sensor_height)\n\t\t\theight = sensor_height;\n\t\telse if (fmt->fmt.pix.height < 96)\n\t\t\theight = 96;\n\t\telse\n\t\t\theight = fmt->fmt.pix.height & ~0x0f;\n\t} else {\n\t\twidth = fmt->fmt.pix.width;\n\n\t\tif (width <= sensor_width / 4) {\n\t\t\twidth = sensor_width / 4;\n\t\t\theight = sensor_height / 4;\n\t\t} else if (width <= sensor_width / 2) {\n\t\t\twidth = sensor_width / 2;\n\t\t\theight = sensor_height / 2;\n\t\t} else {\n\t\t\twidth = sensor_width;\n\t\t\theight = sensor_height;\n\t\t}\n\t\twidth &= ~0xf;\n\t\theight &= ~0xf;\n\t}\n\n\tif (fmt != NULL) {\n\t\tu32 pixelformat = fmt->fmt.pix.pixelformat;\n\n\t\tmemset(fmt, 0, sizeof(*fmt));\n\t\tfmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tfmt->fmt.pix.width = width;\n\t\tfmt->fmt.pix.height = height;\n\t\tfmt->fmt.pix.pixelformat = pixelformat;\n\t\tfmt->fmt.pix.field = V4L2_FIELD_NONE;\n\t\tfmt->fmt.pix.bytesperline = 0;\n\t\tfmt->fmt.pix.sizeimage = GO7007_BUF_SIZE;\n\t\tfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\t}\n\n\tif (try)\n\t\treturn 0;\n\n\tif (fmt)\n\t\tgo->format = fmt->fmt.pix.pixelformat;\n\tgo->width = width;\n\tgo->height = height;\n\tgo->encoder_h_offset = go->board_info->sensor_h_offset;\n\tgo->encoder_v_offset = go->board_info->sensor_v_offset;\n\n\tif (go->board_info->sensor_flags & GO7007_SENSOR_SCALING) {\n\t\tstruct v4l2_subdev_format format = {\n\t\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t};\n\n\t\tformat.format.code = MEDIA_BUS_FMT_FIXED;\n\t\tformat.format.width = fmt ? fmt->fmt.pix.width : width;\n\t\tformat.format.height = height;\n\t\tgo->encoder_h_halve = 0;\n\t\tgo->encoder_v_halve = 0;\n\t\tgo->encoder_subsample = 0;\n\t\tcall_all(&go->v4l2_dev, pad, set_fmt, NULL, &format);\n\t} else {\n\t\tif (width <= sensor_width / 4) {\n\t\t\tgo->encoder_h_halve = 1;\n\t\t\tgo->encoder_v_halve = 1;\n\t\t\tgo->encoder_subsample = 1;\n\t\t} else if (width <= sensor_width / 2) {\n\t\t\tgo->encoder_h_halve = 1;\n\t\t\tgo->encoder_v_halve = 1;\n\t\t\tgo->encoder_subsample = 0;\n\t\t} else {\n\t\t\tgo->encoder_h_halve = 0;\n\t\t\tgo->encoder_v_halve = 0;\n\t\t\tgo->encoder_subsample = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_querycap(struct file *file, void  *priv,\n\t\t\t\t\tstruct v4l2_capability *cap)\n{\n\tstruct go7007 *go = video_drvdata(file);\n\n\tstrscpy(cap->driver, \"go7007\", sizeof(cap->driver));\n\tstrscpy(cap->card, go->name, sizeof(cap->card));\n\tstrscpy(cap->bus_info, go->bus_info, sizeof(cap->bus_info));\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,\n\t\t\t\t\tstruct v4l2_fmtdesc *fmt)\n{\n\tswitch (fmt->index) {\n\tcase 0:\n\t\tfmt->pixelformat = V4L2_PIX_FMT_MJPEG;\n\t\tbreak;\n\tcase 1:\n\t\tfmt->pixelformat = V4L2_PIX_FMT_MPEG1;\n\t\tbreak;\n\tcase 2:\n\t\tfmt->pixelformat = V4L2_PIX_FMT_MPEG2;\n\t\tbreak;\n\tcase 3:\n\t\tfmt->pixelformat = V4L2_PIX_FMT_MPEG4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_format *fmt)\n{\n\tstruct go7007 *go = video_drvdata(file);\n\n\tfmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tfmt->fmt.pix.width = go->width;\n\tfmt->fmt.pix.height = go->height;\n\tfmt->fmt.pix.pixelformat = go->format;\n\tfmt->fmt.pix.field = V4L2_FIELD_NONE;\n\tfmt->fmt.pix.bytesperline = 0;\n\tfmt->fmt.pix.sizeimage = GO7007_BUF_SIZE;\n\tfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\tstruct v4l2_format *fmt)\n{\n\tstruct go7007 *go = video_drvdata(file);\n\n\treturn set_capture_size(go, fmt, 1);\n}\n\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\tstruct v4l2_format *fmt)\n{\n\tstruct go7007 *go = video_drvdata(file);\n\n\tif (vb2_is_busy(&go->vidq))\n\t\treturn -EBUSY;\n\n\treturn set_capture_size(go, fmt, 0);\n}\n\nstatic int go7007_queue_setup(struct vb2_queue *q,\n\t\tunsigned int *num_buffers, unsigned int *num_planes,\n\t\tunsigned int sizes[], struct device *alloc_devs[])\n{\n\tsizes[0] = GO7007_BUF_SIZE;\n\t*num_planes = 1;\n\n\tif (*num_buffers < 2)\n\t\t*num_buffers = 2;\n\n\treturn 0;\n}\n\nstatic void go7007_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct go7007 *go = vb2_get_drv_priv(vq);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct go7007_buffer *go7007_vb =\n\t\tcontainer_of(vbuf, struct go7007_buffer, vb);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&go->spinlock, flags);\n\tlist_add_tail(&go7007_vb->list, &go->vidq_active);\n\tspin_unlock_irqrestore(&go->spinlock, flags);\n}\n\nstatic int go7007_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct go7007_buffer *go7007_vb =\n\t\tcontainer_of(vbuf, struct go7007_buffer, vb);\n\n\tgo7007_vb->modet_active = 0;\n\tgo7007_vb->frame_offset = 0;\n\tvb->planes[0].bytesused = 0;\n\treturn 0;\n}\n\nstatic void go7007_buf_finish(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct go7007 *go = vb2_get_drv_priv(vq);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct go7007_buffer *go7007_vb =\n\t\tcontainer_of(vbuf, struct go7007_buffer, vb);\n\tu32 frame_type_flag = get_frame_type_flag(go7007_vb, go->format);\n\n\tvbuf->flags &= ~(V4L2_BUF_FLAG_KEYFRAME | V4L2_BUF_FLAG_BFRAME |\n\t\t\tV4L2_BUF_FLAG_PFRAME);\n\tvbuf->flags |= frame_type_flag;\n\tvbuf->field = V4L2_FIELD_NONE;\n}\n\nstatic int go7007_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct go7007 *go = vb2_get_drv_priv(q);\n\tint ret;\n\n\tset_formatting(go);\n\tmutex_lock(&go->hw_lock);\n\tgo->next_seq = 0;\n\tgo->active_buf = NULL;\n\tgo->modet_event_status = 0;\n\tif (go7007_start_encoder(go) < 0)\n\t\tret = -EIO;\n\telse\n\t\tret = 0;\n\tmutex_unlock(&go->hw_lock);\n\tif (ret)\n\t\treturn ret;\n\tcall_all(&go->v4l2_dev, video, s_stream, 1);\n\tv4l2_ctrl_grab(go->mpeg_video_gop_size, true);\n\tv4l2_ctrl_grab(go->mpeg_video_gop_closure, true);\n\tv4l2_ctrl_grab(go->mpeg_video_bitrate, true);\n\tv4l2_ctrl_grab(go->mpeg_video_aspect_ratio, true);\n\t \n\tif (go->board_id == GO7007_BOARDID_ADS_USBAV_709)\n\t\tgo7007_write_addr(go, 0x3c82, 0x0005);\n\treturn ret;\n}\n\nstatic void go7007_stop_streaming(struct vb2_queue *q)\n{\n\tstruct go7007 *go = vb2_get_drv_priv(q);\n\tunsigned long flags;\n\n\tgo7007_stream_stop(go);\n\tmutex_lock(&go->hw_lock);\n\tgo7007_reset_encoder(go);\n\tmutex_unlock(&go->hw_lock);\n\tcall_all(&go->v4l2_dev, video, s_stream, 0);\n\n\tspin_lock_irqsave(&go->spinlock, flags);\n\tINIT_LIST_HEAD(&go->vidq_active);\n\tspin_unlock_irqrestore(&go->spinlock, flags);\n\tv4l2_ctrl_grab(go->mpeg_video_gop_size, false);\n\tv4l2_ctrl_grab(go->mpeg_video_gop_closure, false);\n\tv4l2_ctrl_grab(go->mpeg_video_bitrate, false);\n\tv4l2_ctrl_grab(go->mpeg_video_aspect_ratio, false);\n\t \n\tif (go->board_id == GO7007_BOARDID_ADS_USBAV_709)\n\t\tgo7007_write_addr(go, 0x3c82, 0x000d);\n}\n\nstatic const struct vb2_ops go7007_video_qops = {\n\t.queue_setup    = go7007_queue_setup,\n\t.buf_queue      = go7007_buf_queue,\n\t.buf_prepare    = go7007_buf_prepare,\n\t.buf_finish     = go7007_buf_finish,\n\t.start_streaming = go7007_start_streaming,\n\t.stop_streaming = go7007_stop_streaming,\n\t.wait_prepare   = vb2_ops_wait_prepare,\n\t.wait_finish    = vb2_ops_wait_finish,\n};\n\nstatic int vidioc_g_parm(struct file *filp, void *priv,\n\t\tstruct v4l2_streamparm *parm)\n{\n\tstruct go7007 *go = video_drvdata(filp);\n\tstruct v4l2_fract timeperframe = {\n\t\t.numerator = 1001 *  go->fps_scale,\n\t\t.denominator = go->sensor_framerate,\n\t};\n\n\tif (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tparm->parm.capture.readbuffers = 2;\n\tparm->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\n\tparm->parm.capture.timeperframe = timeperframe;\n\n\treturn 0;\n}\n\nstatic int vidioc_s_parm(struct file *filp, void *priv,\n\t\tstruct v4l2_streamparm *parm)\n{\n\tstruct go7007 *go = video_drvdata(filp);\n\tunsigned int n, d;\n\n\tif (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tn = go->sensor_framerate *\n\t\tparm->parm.capture.timeperframe.numerator;\n\td = 1001 * parm->parm.capture.timeperframe.denominator;\n\tif (n != 0 && d != 0 && n > d)\n\t\tgo->fps_scale = (n + d/2) / d;\n\telse\n\t\tgo->fps_scale = 1;\n\n\treturn vidioc_g_parm(filp, priv, parm);\n}\n\n \nstatic int vidioc_enum_framesizes(struct file *filp, void *priv,\n\t\t\t\t  struct v4l2_frmsizeenum *fsize)\n{\n\tstruct go7007 *go = video_drvdata(filp);\n\tint width, height;\n\n\tif (fsize->index > 2)\n\t\treturn -EINVAL;\n\n\tif (!valid_pixelformat(fsize->pixel_format))\n\t\treturn -EINVAL;\n\n\tget_resolution(go, &width, &height);\n\tfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\tfsize->discrete.width = (width >> fsize->index) & ~0xf;\n\tfsize->discrete.height = (height >> fsize->index) & ~0xf;\n\treturn 0;\n}\n\nstatic int vidioc_enum_frameintervals(struct file *filp, void *priv,\n\t\t\t\t      struct v4l2_frmivalenum *fival)\n{\n\tstruct go7007 *go = video_drvdata(filp);\n\tint width, height;\n\tint i;\n\n\tif (fival->index > 4)\n\t\treturn -EINVAL;\n\n\tif (!valid_pixelformat(fival->pixel_format))\n\t\treturn -EINVAL;\n\n\tif (!(go->board_info->sensor_flags & GO7007_SENSOR_SCALING)) {\n\t\tget_resolution(go, &width, &height);\n\t\tfor (i = 0; i <= 2; i++)\n\t\t\tif (fival->width == ((width >> i) & ~0xf) &&\n\t\t\t    fival->height == ((height >> i) & ~0xf))\n\t\t\t\tbreak;\n\t\tif (i > 2)\n\t\t\treturn -EINVAL;\n\t}\n\tfival->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\tfival->discrete.numerator = 1001 * (fival->index + 1);\n\tfival->discrete.denominator = go->sensor_framerate;\n\treturn 0;\n}\n\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *std)\n{\n\tstruct go7007 *go = video_drvdata(file);\n\n\t*std = go->std;\n\treturn 0;\n}\n\nstatic int go7007_s_std(struct go7007 *go)\n{\n\tif (go->std & V4L2_STD_625_50) {\n\t\tgo->standard = GO7007_STD_PAL;\n\t\tgo->sensor_framerate = 25025;\n\t} else {\n\t\tgo->standard = GO7007_STD_NTSC;\n\t\tgo->sensor_framerate = 30000;\n\t}\n\n\tcall_all(&go->v4l2_dev, video, s_std, go->std);\n\tset_capture_size(go, NULL, 0);\n\treturn 0;\n}\n\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id std)\n{\n\tstruct go7007 *go = video_drvdata(file);\n\n\tif (vb2_is_busy(&go->vidq))\n\t\treturn -EBUSY;\n\n\tgo->std = std;\n\n\treturn go7007_s_std(go);\n}\n\nstatic int vidioc_querystd(struct file *file, void *priv, v4l2_std_id *std)\n{\n\tstruct go7007 *go = video_drvdata(file);\n\n\treturn call_all(&go->v4l2_dev, video, querystd, std);\n}\n\nstatic int vidioc_enum_input(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_input *inp)\n{\n\tstruct go7007 *go = video_drvdata(file);\n\n\tif (inp->index >= go->board_info->num_inputs)\n\t\treturn -EINVAL;\n\n\tstrscpy(inp->name, go->board_info->inputs[inp->index].name,\n\t\tsizeof(inp->name));\n\n\t \n\tif ((go->board_info->flags & GO7007_BOARD_HAS_TUNER) &&\n\t\t\tinp->index == 0)\n\t\tinp->type = V4L2_INPUT_TYPE_TUNER;\n\telse\n\t\tinp->type = V4L2_INPUT_TYPE_CAMERA;\n\n\tif (go->board_info->num_aud_inputs)\n\t\tinp->audioset = (1 << go->board_info->num_aud_inputs) - 1;\n\telse\n\t\tinp->audioset = 0;\n\tinp->tuner = 0;\n\tif (go->board_info->sensor_flags & GO7007_SENSOR_TV)\n\t\tinp->std = video_devdata(file)->tvnorms;\n\telse\n\t\tinp->std = 0;\n\n\treturn 0;\n}\n\n\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *input)\n{\n\tstruct go7007 *go = video_drvdata(file);\n\n\t*input = go->input;\n\n\treturn 0;\n}\n\nstatic int vidioc_enumaudio(struct file *file, void *fh, struct v4l2_audio *a)\n{\n\tstruct go7007 *go = video_drvdata(file);\n\n\tif (a->index >= go->board_info->num_aud_inputs)\n\t\treturn -EINVAL;\n\tstrscpy(a->name, go->board_info->aud_inputs[a->index].name,\n\t\tsizeof(a->name));\n\ta->capability = V4L2_AUDCAP_STEREO;\n\treturn 0;\n}\n\nstatic int vidioc_g_audio(struct file *file, void *fh, struct v4l2_audio *a)\n{\n\tstruct go7007 *go = video_drvdata(file);\n\n\ta->index = go->aud_input;\n\tstrscpy(a->name, go->board_info->aud_inputs[go->aud_input].name,\n\t\tsizeof(a->name));\n\ta->capability = V4L2_AUDCAP_STEREO;\n\treturn 0;\n}\n\nstatic int vidioc_s_audio(struct file *file, void *fh,\n\tconst struct v4l2_audio *a)\n{\n\tstruct go7007 *go = video_drvdata(file);\n\n\tif (a->index >= go->board_info->num_aud_inputs)\n\t\treturn -EINVAL;\n\tgo->aud_input = a->index;\n\tv4l2_subdev_call(go->sd_audio, audio, s_routing,\n\t\tgo->board_info->aud_inputs[go->aud_input].audio_input, 0, 0);\n\treturn 0;\n}\n\nstatic void go7007_s_input(struct go7007 *go)\n{\n\tunsigned int input = go->input;\n\n\tv4l2_subdev_call(go->sd_video, video, s_routing,\n\t\t\tgo->board_info->inputs[input].video_input, 0,\n\t\t\tgo->board_info->video_config);\n\tif (go->board_info->num_aud_inputs) {\n\t\tint aud_input = go->board_info->inputs[input].audio_index;\n\n\t\tv4l2_subdev_call(go->sd_audio, audio, s_routing,\n\t\t\tgo->board_info->aud_inputs[aud_input].audio_input, 0, 0);\n\t\tgo->aud_input = aud_input;\n\t}\n}\n\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int input)\n{\n\tstruct go7007 *go = video_drvdata(file);\n\n\tif (input >= go->board_info->num_inputs)\n\t\treturn -EINVAL;\n\tif (vb2_is_busy(&go->vidq))\n\t\treturn -EBUSY;\n\n\tgo->input = input;\n\tgo7007_s_input(go);\n\n\treturn 0;\n}\n\nstatic int vidioc_g_tuner(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_tuner *t)\n{\n\tstruct go7007 *go = video_drvdata(file);\n\n\tif (t->index != 0)\n\t\treturn -EINVAL;\n\n\tstrscpy(t->name, \"Tuner\", sizeof(t->name));\n\treturn call_all(&go->v4l2_dev, tuner, g_tuner, t);\n}\n\nstatic int vidioc_s_tuner(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_tuner *t)\n{\n\tstruct go7007 *go = video_drvdata(file);\n\n\tif (t->index != 0)\n\t\treturn -EINVAL;\n\n\treturn call_all(&go->v4l2_dev, tuner, s_tuner, t);\n}\n\nstatic int vidioc_g_frequency(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_frequency *f)\n{\n\tstruct go7007 *go = video_drvdata(file);\n\n\tif (f->tuner)\n\t\treturn -EINVAL;\n\n\treturn call_all(&go->v4l2_dev, tuner, g_frequency, f);\n}\n\nstatic int vidioc_s_frequency(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_frequency *f)\n{\n\tstruct go7007 *go = video_drvdata(file);\n\n\tif (f->tuner)\n\t\treturn -EINVAL;\n\n\treturn call_all(&go->v4l2_dev, tuner, s_frequency, f);\n}\n\nstatic int vidioc_log_status(struct file *file, void *priv)\n{\n\tstruct go7007 *go = video_drvdata(file);\n\n\tv4l2_ctrl_log_status(file, priv);\n\treturn call_all(&go->v4l2_dev, core, log_status);\n}\n\nstatic int vidioc_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\tconst struct v4l2_event_subscription *sub)\n{\n\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_MOTION_DET:\n\t\t \n\t\treturn v4l2_event_subscribe(fh, sub, 30, NULL);\n\tdefault:\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\t}\n}\n\n\nstatic int go7007_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct go7007 *go =\n\t\tcontainer_of(ctrl->handler, struct go7007, hdl);\n\tunsigned y;\n\tu8 *mt;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_PIXEL_THRESHOLD0:\n\t\tgo->modet[0].pixel_threshold = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MOTION_THRESHOLD0:\n\t\tgo->modet[0].motion_threshold = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MB_THRESHOLD0:\n\t\tgo->modet[0].mb_threshold = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_PIXEL_THRESHOLD1:\n\t\tgo->modet[1].pixel_threshold = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MOTION_THRESHOLD1:\n\t\tgo->modet[1].motion_threshold = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MB_THRESHOLD1:\n\t\tgo->modet[1].mb_threshold = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_PIXEL_THRESHOLD2:\n\t\tgo->modet[2].pixel_threshold = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MOTION_THRESHOLD2:\n\t\tgo->modet[2].motion_threshold = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MB_THRESHOLD2:\n\t\tgo->modet[2].mb_threshold = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_PIXEL_THRESHOLD3:\n\t\tgo->modet[3].pixel_threshold = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MOTION_THRESHOLD3:\n\t\tgo->modet[3].motion_threshold = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MB_THRESHOLD3:\n\t\tgo->modet[3].mb_threshold = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_DETECT_MD_REGION_GRID:\n\t\tmt = go->modet_map;\n\t\tfor (y = 0; y < go->height / 16; y++, mt += go->width / 16)\n\t\t\tmemcpy(mt, ctrl->p_new.p_u8 + y * (720 / 16), go->width / 16);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations go7007_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= v4l2_fh_open,\n\t.release\t= vb2_fop_release,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.read\t\t= vb2_fop_read,\n\t.mmap\t\t= vb2_fop_mmap,\n\t.poll\t\t= vb2_fop_poll,\n};\n\nstatic const struct v4l2_ioctl_ops video_ioctl_ops = {\n\t.vidioc_querycap          = vidioc_querycap,\n\t.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,\n\t.vidioc_reqbufs           = vb2_ioctl_reqbufs,\n\t.vidioc_querybuf          = vb2_ioctl_querybuf,\n\t.vidioc_qbuf              = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf             = vb2_ioctl_dqbuf,\n\t.vidioc_g_std             = vidioc_g_std,\n\t.vidioc_s_std             = vidioc_s_std,\n\t.vidioc_querystd          = vidioc_querystd,\n\t.vidioc_enum_input        = vidioc_enum_input,\n\t.vidioc_g_input           = vidioc_g_input,\n\t.vidioc_s_input           = vidioc_s_input,\n\t.vidioc_enumaudio         = vidioc_enumaudio,\n\t.vidioc_g_audio           = vidioc_g_audio,\n\t.vidioc_s_audio           = vidioc_s_audio,\n\t.vidioc_streamon          = vb2_ioctl_streamon,\n\t.vidioc_streamoff         = vb2_ioctl_streamoff,\n\t.vidioc_g_tuner           = vidioc_g_tuner,\n\t.vidioc_s_tuner           = vidioc_s_tuner,\n\t.vidioc_g_frequency       = vidioc_g_frequency,\n\t.vidioc_s_frequency       = vidioc_s_frequency,\n\t.vidioc_g_parm            = vidioc_g_parm,\n\t.vidioc_s_parm            = vidioc_s_parm,\n\t.vidioc_enum_framesizes   = vidioc_enum_framesizes,\n\t.vidioc_enum_frameintervals = vidioc_enum_frameintervals,\n\t.vidioc_log_status        = vidioc_log_status,\n\t.vidioc_subscribe_event   = vidioc_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic const struct video_device go7007_template = {\n\t.name\t\t= \"go7007\",\n\t.fops\t\t= &go7007_fops,\n\t.release\t= video_device_release_empty,\n\t.ioctl_ops\t= &video_ioctl_ops,\n\t.tvnorms\t= V4L2_STD_ALL,\n};\n\nstatic const struct v4l2_ctrl_ops go7007_ctrl_ops = {\n\t.s_ctrl = go7007_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config go7007_pixel_threshold0_ctrl = {\n\t.ops = &go7007_ctrl_ops,\n\t.id = V4L2_CID_PIXEL_THRESHOLD0,\n\t.name = \"Pixel Threshold Region 0\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.def = 20,\n\t.max = 32767,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config go7007_motion_threshold0_ctrl = {\n\t.ops = &go7007_ctrl_ops,\n\t.id = V4L2_CID_MOTION_THRESHOLD0,\n\t.name = \"Motion Threshold Region 0\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.def = 80,\n\t.max = 32767,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config go7007_mb_threshold0_ctrl = {\n\t.ops = &go7007_ctrl_ops,\n\t.id = V4L2_CID_MB_THRESHOLD0,\n\t.name = \"MB Threshold Region 0\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.def = 200,\n\t.max = 32767,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config go7007_pixel_threshold1_ctrl = {\n\t.ops = &go7007_ctrl_ops,\n\t.id = V4L2_CID_PIXEL_THRESHOLD1,\n\t.name = \"Pixel Threshold Region 1\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.def = 20,\n\t.max = 32767,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config go7007_motion_threshold1_ctrl = {\n\t.ops = &go7007_ctrl_ops,\n\t.id = V4L2_CID_MOTION_THRESHOLD1,\n\t.name = \"Motion Threshold Region 1\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.def = 80,\n\t.max = 32767,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config go7007_mb_threshold1_ctrl = {\n\t.ops = &go7007_ctrl_ops,\n\t.id = V4L2_CID_MB_THRESHOLD1,\n\t.name = \"MB Threshold Region 1\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.def = 200,\n\t.max = 32767,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config go7007_pixel_threshold2_ctrl = {\n\t.ops = &go7007_ctrl_ops,\n\t.id = V4L2_CID_PIXEL_THRESHOLD2,\n\t.name = \"Pixel Threshold Region 2\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.def = 20,\n\t.max = 32767,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config go7007_motion_threshold2_ctrl = {\n\t.ops = &go7007_ctrl_ops,\n\t.id = V4L2_CID_MOTION_THRESHOLD2,\n\t.name = \"Motion Threshold Region 2\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.def = 80,\n\t.max = 32767,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config go7007_mb_threshold2_ctrl = {\n\t.ops = &go7007_ctrl_ops,\n\t.id = V4L2_CID_MB_THRESHOLD2,\n\t.name = \"MB Threshold Region 2\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.def = 200,\n\t.max = 32767,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config go7007_pixel_threshold3_ctrl = {\n\t.ops = &go7007_ctrl_ops,\n\t.id = V4L2_CID_PIXEL_THRESHOLD3,\n\t.name = \"Pixel Threshold Region 3\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.def = 20,\n\t.max = 32767,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config go7007_motion_threshold3_ctrl = {\n\t.ops = &go7007_ctrl_ops,\n\t.id = V4L2_CID_MOTION_THRESHOLD3,\n\t.name = \"Motion Threshold Region 3\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.def = 80,\n\t.max = 32767,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config go7007_mb_threshold3_ctrl = {\n\t.ops = &go7007_ctrl_ops,\n\t.id = V4L2_CID_MB_THRESHOLD3,\n\t.name = \"MB Threshold Region 3\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.def = 200,\n\t.max = 32767,\n\t.step = 1,\n};\n\nstatic const struct v4l2_ctrl_config go7007_mb_regions_ctrl = {\n\t.ops = &go7007_ctrl_ops,\n\t.id = V4L2_CID_DETECT_MD_REGION_GRID,\n\t.dims = { 576 / 16, 720 / 16 },\n\t.max = 3,\n\t.step = 1,\n};\n\nint go7007_v4l2_ctrl_init(struct go7007 *go)\n{\n\tstruct v4l2_ctrl_handler *hdl = &go->hdl;\n\tstruct v4l2_ctrl *ctrl;\n\n\tv4l2_ctrl_handler_init(hdl, 22);\n\tgo->mpeg_video_gop_size = v4l2_ctrl_new_std(hdl, NULL,\n\t\t\tV4L2_CID_MPEG_VIDEO_GOP_SIZE, 0, 34, 1, 15);\n\tgo->mpeg_video_gop_closure = v4l2_ctrl_new_std(hdl, NULL,\n\t\t\tV4L2_CID_MPEG_VIDEO_GOP_CLOSURE, 0, 1, 1, 1);\n\tgo->mpeg_video_bitrate = v4l2_ctrl_new_std(hdl, NULL,\n\t\t\tV4L2_CID_MPEG_VIDEO_BITRATE,\n\t\t\t64000, 10000000, 1, 9800000);\n\tgo->mpeg_video_b_frames = v4l2_ctrl_new_std(hdl, NULL,\n\t\t\tV4L2_CID_MPEG_VIDEO_B_FRAMES, 0, 2, 2, 0);\n\tgo->mpeg_video_rep_seqheader = v4l2_ctrl_new_std(hdl, NULL,\n\t\t\tV4L2_CID_MPEG_VIDEO_REPEAT_SEQ_HEADER, 0, 1, 1, 1);\n\n\tgo->mpeg_video_aspect_ratio = v4l2_ctrl_new_std_menu(hdl, NULL,\n\t\t\tV4L2_CID_MPEG_VIDEO_ASPECT,\n\t\t\tV4L2_MPEG_VIDEO_ASPECT_16x9, 0,\n\t\t\tV4L2_MPEG_VIDEO_ASPECT_1x1);\n\tctrl = v4l2_ctrl_new_std(hdl, NULL,\n\t\t\tV4L2_CID_JPEG_ACTIVE_MARKER, 0,\n\t\t\tV4L2_JPEG_ACTIVE_MARKER_DQT |\n\t\t\tV4L2_JPEG_ACTIVE_MARKER_DHT, 0,\n\t\t\tV4L2_JPEG_ACTIVE_MARKER_DQT |\n\t\t\tV4L2_JPEG_ACTIVE_MARKER_DHT);\n\tif (ctrl)\n\t\tctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\tv4l2_ctrl_new_custom(hdl, &go7007_pixel_threshold0_ctrl, NULL);\n\tv4l2_ctrl_new_custom(hdl, &go7007_motion_threshold0_ctrl, NULL);\n\tv4l2_ctrl_new_custom(hdl, &go7007_mb_threshold0_ctrl, NULL);\n\tv4l2_ctrl_new_custom(hdl, &go7007_pixel_threshold1_ctrl, NULL);\n\tv4l2_ctrl_new_custom(hdl, &go7007_motion_threshold1_ctrl, NULL);\n\tv4l2_ctrl_new_custom(hdl, &go7007_mb_threshold1_ctrl, NULL);\n\tv4l2_ctrl_new_custom(hdl, &go7007_pixel_threshold2_ctrl, NULL);\n\tv4l2_ctrl_new_custom(hdl, &go7007_motion_threshold2_ctrl, NULL);\n\tv4l2_ctrl_new_custom(hdl, &go7007_mb_threshold2_ctrl, NULL);\n\tv4l2_ctrl_new_custom(hdl, &go7007_pixel_threshold3_ctrl, NULL);\n\tv4l2_ctrl_new_custom(hdl, &go7007_motion_threshold3_ctrl, NULL);\n\tv4l2_ctrl_new_custom(hdl, &go7007_mb_threshold3_ctrl, NULL);\n\tv4l2_ctrl_new_custom(hdl, &go7007_mb_regions_ctrl, NULL);\n\tgo->modet_mode = v4l2_ctrl_new_std_menu(hdl, NULL,\n\t\t\tV4L2_CID_DETECT_MD_MODE,\n\t\t\tV4L2_DETECT_MD_MODE_REGION_GRID,\n\t\t\t1 << V4L2_DETECT_MD_MODE_THRESHOLD_GRID,\n\t\t\tV4L2_DETECT_MD_MODE_DISABLED);\n\tif (hdl->error) {\n\t\tint rv = hdl->error;\n\n\t\tv4l2_err(&go->v4l2_dev, \"Could not register controls\\n\");\n\t\treturn rv;\n\t}\n\tgo->v4l2_dev.ctrl_handler = hdl;\n\treturn 0;\n}\n\nint go7007_v4l2_init(struct go7007 *go)\n{\n\tstruct video_device *vdev = &go->vdev;\n\tint rv;\n\n\tmutex_init(&go->serialize_lock);\n\tmutex_init(&go->queue_lock);\n\n\tINIT_LIST_HEAD(&go->vidq_active);\n\tgo->vidq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tgo->vidq.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\n\tgo->vidq.ops = &go7007_video_qops;\n\tgo->vidq.mem_ops = &vb2_vmalloc_memops;\n\tgo->vidq.drv_priv = go;\n\tgo->vidq.buf_struct_size = sizeof(struct go7007_buffer);\n\tgo->vidq.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tgo->vidq.lock = &go->queue_lock;\n\trv = vb2_queue_init(&go->vidq);\n\tif (rv)\n\t\treturn rv;\n\t*vdev = go7007_template;\n\tvdev->lock = &go->serialize_lock;\n\tvdev->queue = &go->vidq;\n\tvdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\n\t\t\t    V4L2_CAP_STREAMING;\n\tif (go->board_info->num_aud_inputs)\n\t\tvdev->device_caps |= V4L2_CAP_AUDIO;\n\tif (go->board_info->flags & GO7007_BOARD_HAS_TUNER)\n\t\tvdev->device_caps |= V4L2_CAP_TUNER;\n\tvideo_set_drvdata(vdev, go);\n\tvdev->v4l2_dev = &go->v4l2_dev;\n\tif (!v4l2_device_has_op(&go->v4l2_dev, 0, video, querystd))\n\t\tv4l2_disable_ioctl(vdev, VIDIOC_QUERYSTD);\n\tif (!(go->board_info->flags & GO7007_BOARD_HAS_TUNER)) {\n\t\tv4l2_disable_ioctl(vdev, VIDIOC_S_FREQUENCY);\n\t\tv4l2_disable_ioctl(vdev, VIDIOC_G_FREQUENCY);\n\t\tv4l2_disable_ioctl(vdev, VIDIOC_S_TUNER);\n\t\tv4l2_disable_ioctl(vdev, VIDIOC_G_TUNER);\n\t} else {\n\t\tstruct v4l2_frequency f = {\n\t\t\t.type = V4L2_TUNER_ANALOG_TV,\n\t\t\t.frequency = 980,\n\t\t};\n\n\t\tcall_all(&go->v4l2_dev, tuner, s_frequency, &f);\n\t}\n\tif (!(go->board_info->sensor_flags & GO7007_SENSOR_TV)) {\n\t\tv4l2_disable_ioctl(vdev, VIDIOC_G_STD);\n\t\tv4l2_disable_ioctl(vdev, VIDIOC_S_STD);\n\t\tvdev->tvnorms = 0;\n\t}\n\tif (go->board_info->sensor_flags & GO7007_SENSOR_SCALING)\n\t\tv4l2_disable_ioctl(vdev, VIDIOC_ENUM_FRAMESIZES);\n\tif (go->board_info->num_aud_inputs == 0) {\n\t\tv4l2_disable_ioctl(vdev, VIDIOC_G_AUDIO);\n\t\tv4l2_disable_ioctl(vdev, VIDIOC_S_AUDIO);\n\t\tv4l2_disable_ioctl(vdev, VIDIOC_ENUMAUDIO);\n\t}\n\t \n\tif (go->board_info->sensor_flags & GO7007_SENSOR_SAA7115)\n\t\tv4l2_subdev_call(go->sd_video, video, s_crystal_freq,\n\t\t\t\tSAA7115_FREQ_24_576_MHZ,\n\t\t\t\tSAA7115_FREQ_FL_APLL | SAA7115_FREQ_FL_UCGC |\n\t\t\t\tSAA7115_FREQ_FL_DOUBLE_ASCLK);\n\tgo7007_s_input(go);\n\tif (go->board_info->sensor_flags & GO7007_SENSOR_TV)\n\t\tgo7007_s_std(go);\n\trv = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\tif (rv < 0)\n\t\treturn rv;\n\tdev_info(go->dev, \"registered device %s [v4l2]\\n\",\n\t\t video_device_node_name(vdev));\n\n\treturn 0;\n}\n\nvoid go7007_v4l2_remove(struct go7007 *go)\n{\n\tv4l2_ctrl_handler_free(&go->hdl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}