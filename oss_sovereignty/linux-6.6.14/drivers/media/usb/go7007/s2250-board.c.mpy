{
  "module_name": "s2250-board.c",
  "hash_id": "7bd71a58ba56b0384f2cd05bcd0c8d8cc2736df7d11f111ff8d80483171f8eb3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/go7007/s2250-board.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/i2c.h>\n#include <linux/videodev2.h>\n#include <linux/slab.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-subdev.h>\n#include \"go7007-priv.h\"\n\nMODULE_DESCRIPTION(\"Sensoray 2250/2251 i2c v4l2 subdev driver\");\nMODULE_LICENSE(\"GPL v2\");\n\n \n\n#define TLV320_ADDRESS      0x34\n#define VPX322_ADDR_ANALOGCONTROL1\t0x02\n#define VPX322_ADDR_BRIGHTNESS0\t\t0x0127\n#define VPX322_ADDR_BRIGHTNESS1\t\t0x0131\n#define VPX322_ADDR_CONTRAST0\t\t0x0128\n#define VPX322_ADDR_CONTRAST1\t\t0x0132\n#define VPX322_ADDR_HUE\t\t\t0x00dc\n#define VPX322_ADDR_SAT\t\t\t0x0030\n\nstruct go7007_usb_board {\n\tunsigned int flags;\n\tstruct go7007_board_info main_info;\n};\n\nstruct go7007_usb {\n\tstruct go7007_usb_board *board;\n\tstruct mutex i2c_lock;\n\tstruct usb_device *usbdev;\n\tstruct urb *video_urbs[8];\n\tstruct urb *audio_urbs[8];\n\tstruct urb *intr_urb;\n};\n\nstatic unsigned char aud_regs[] = {\n\t0x1e, 0x00,\n\t0x00, 0x17,\n\t0x02, 0x17,\n\t0x04, 0xf9,\n\t0x06, 0xf9,\n\t0x08, 0x02,\n\t0x0a, 0x00,\n\t0x0c, 0x00,\n\t0x0a, 0x00,\n\t0x0c, 0x00,\n\t0x0e, 0x02,\n\t0x10, 0x00,\n\t0x12, 0x01,\n\t0x00, 0x00,\n};\n\n\nstatic unsigned char vid_regs[] = {\n\t0xF2, 0x0f,\n\t0xAA, 0x00,\n\t0xF8, 0xff,\n\t0x00, 0x00,\n};\n\nstatic u16 vid_regs_fp[] = {\n\t0x028, 0x067,\n\t0x120, 0x016,\n\t0x121, 0xcF2,\n\t0x122, 0x0F2,\n\t0x123, 0x00c,\n\t0x124, 0x2d0,\n\t0x125, 0x2e0,\n\t0x126, 0x004,\n\t0x128, 0x1E0,\n\t0x12A, 0x016,\n\t0x12B, 0x0F2,\n\t0x12C, 0x0F2,\n\t0x12D, 0x00c,\n\t0x12E, 0x2d0,\n\t0x12F, 0x2e0,\n\t0x130, 0x004,\n\t0x132, 0x1E0,\n\t0x140, 0x060,\n\t0x153, 0x00C,\n\t0x154, 0x200,\n\t0x150, 0x801,\n\t0x000, 0x000\n};\n\n \nstatic u16 vid_regs_fp_pal[] = {\n\t0x120, 0x017,\n\t0x121, 0xd22,\n\t0x122, 0x122,\n\t0x12A, 0x017,\n\t0x12B, 0x122,\n\t0x12C, 0x122,\n\t0x140, 0x060,\n\t0x000, 0x000,\n};\n\nstruct s2250 {\n\tstruct v4l2_subdev sd;\n\tstruct v4l2_ctrl_handler hdl;\n\tv4l2_std_id std;\n\tint input;\n\tint brightness;\n\tint contrast;\n\tint saturation;\n\tint hue;\n\tint reg12b_val;\n\tint audio_input;\n\tstruct i2c_client *audio;\n};\n\nstatic inline struct s2250 *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct s2250, sd);\n}\n\n \nstatic int go7007_usb_vendor_request(struct go7007 *go, u16 request,\n\tu16 value, u16 index, void *transfer_buffer, int length, int in)\n{\n\tstruct go7007_usb *usb = go->hpi_context;\n\tint timeout = 5000;\n\n\tif (in) {\n\t\treturn usb_control_msg(usb->usbdev,\n\t\t\t\tusb_rcvctrlpipe(usb->usbdev, 0), request,\n\t\t\t\tUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\n\t\t\t\tvalue, index, transfer_buffer, length, timeout);\n\t} else {\n\t\treturn usb_control_msg(usb->usbdev,\n\t\t\t\tusb_sndctrlpipe(usb->usbdev, 0), request,\n\t\t\t\tUSB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\tvalue, index, transfer_buffer, length, timeout);\n\t}\n}\n \n\nstatic int write_reg(struct i2c_client *client, u8 reg, u8 value)\n{\n\tstruct go7007 *go = i2c_get_adapdata(client->adapter);\n\tstruct go7007_usb *usb;\n\tint rc;\n\tint dev_addr = client->addr << 1;   \n\tu8 *buf;\n\n\tif (go == NULL)\n\t\treturn -ENODEV;\n\n\tif (go->status == STATUS_SHUTDOWN)\n\t\treturn -EBUSY;\n\n\tbuf = kzalloc(16, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tusb = go->hpi_context;\n\tif (mutex_lock_interruptible(&usb->i2c_lock) != 0) {\n\t\tdev_info(&client->dev, \"i2c lock failed\\n\");\n\t\tkfree(buf);\n\t\treturn -EINTR;\n\t}\n\trc = go7007_usb_vendor_request(go, 0x55, dev_addr,\n\t\t\t\t       (reg<<8 | value),\n\t\t\t\t       buf,\n\t\t\t\t       16, 1);\n\n\tmutex_unlock(&usb->i2c_lock);\n\tkfree(buf);\n\treturn rc;\n}\n\nstatic int write_reg_fp(struct i2c_client *client, u16 addr, u16 val)\n{\n\tstruct go7007 *go = i2c_get_adapdata(client->adapter);\n\tstruct go7007_usb *usb;\n\tint rc;\n\tu8 *buf;\n\tstruct s2250 *dec = i2c_get_clientdata(client);\n\n\tif (go == NULL)\n\t\treturn -ENODEV;\n\n\tif (go->status == STATUS_SHUTDOWN)\n\t\treturn -EBUSY;\n\n\tbuf = kzalloc(16, GFP_KERNEL);\n\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\n\n\tmemset(buf, 0xcd, 6);\n\n\tusb = go->hpi_context;\n\tif (mutex_lock_interruptible(&usb->i2c_lock) != 0) {\n\t\tdev_info(&client->dev, \"i2c lock failed\\n\");\n\t\tkfree(buf);\n\t\treturn -EINTR;\n\t}\n\trc = go7007_usb_vendor_request(go, 0x57, addr, val, buf, 16, 1);\n\tmutex_unlock(&usb->i2c_lock);\n\tif (rc < 0) {\n\t\tkfree(buf);\n\t\treturn rc;\n\t}\n\n\tif (buf[0] == 0) {\n\t\tunsigned int subaddr, val_read;\n\n\t\tsubaddr = (buf[4] << 8) + buf[5];\n\t\tval_read = (buf[2] << 8) + buf[3];\n\t\tkfree(buf);\n\t\tif (val_read != val) {\n\t\t\tdev_info(&client->dev, \"invalid fp write %x %x\\n\",\n\t\t\t\t val_read, val);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (subaddr != addr) {\n\t\t\tdev_info(&client->dev, \"invalid fp write addr %x %x\\n\",\n\t\t\t\t subaddr, addr);\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else {\n\t\tkfree(buf);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tif (addr == 0x12b)\n\t\tdec->reg12b_val = val;\n\n\treturn 0;\n}\n\nstatic int read_reg_fp(struct i2c_client *client, u16 addr, u16 *val)\n{\n\tstruct go7007 *go = i2c_get_adapdata(client->adapter);\n\tstruct go7007_usb *usb;\n\tint rc;\n\tu8 *buf;\n\n\tif (go == NULL)\n\t\treturn -ENODEV;\n\n\tif (go->status == STATUS_SHUTDOWN)\n\t\treturn -EBUSY;\n\n\tbuf = kzalloc(16, GFP_KERNEL);\n\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\n\n\tmemset(buf, 0xcd, 6);\n\tusb = go->hpi_context;\n\tif (mutex_lock_interruptible(&usb->i2c_lock) != 0) {\n\t\tdev_info(&client->dev, \"i2c lock failed\\n\");\n\t\tkfree(buf);\n\t\treturn -EINTR;\n\t}\n\trc = go7007_usb_vendor_request(go, 0x58, addr, 0, buf, 16, 1);\n\tmutex_unlock(&usb->i2c_lock);\n\tif (rc < 0) {\n\t\tkfree(buf);\n\t\treturn rc;\n\t}\n\n\t*val = (buf[0] << 8) | buf[1];\n\tkfree(buf);\n\n\treturn 0;\n}\n\n\nstatic int write_regs(struct i2c_client *client, u8 *regs)\n{\n\tint i;\n\n\tfor (i = 0; !((regs[i] == 0x00) && (regs[i+1] == 0x00)); i += 2) {\n\t\tif (write_reg(client, regs[i], regs[i+1]) < 0) {\n\t\t\tdev_info(&client->dev, \"failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int write_regs_fp(struct i2c_client *client, u16 *regs)\n{\n\tint i;\n\n\tfor (i = 0; !((regs[i] == 0x00) && (regs[i+1] == 0x00)); i += 2) {\n\t\tif (write_reg_fp(client, regs[i], regs[i+1]) < 0) {\n\t\t\tdev_info(&client->dev, \"failed fp\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n \n\nstatic int s2250_s_video_routing(struct v4l2_subdev *sd, u32 input, u32 output,\n\t\t\t\t u32 config)\n{\n\tstruct s2250 *state = to_state(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tint vidsys;\n\n\tvidsys = (state->std == V4L2_STD_NTSC) ? 0x01 : 0x00;\n\tif (input == 0) {\n\t\t \n\t\twrite_reg_fp(client, 0x20, 0x020 | vidsys);\n\t\twrite_reg_fp(client, 0x21, 0x662);\n\t\twrite_reg_fp(client, 0x140, 0x060);\n\t} else if (input == 1) {\n\t\t \n\t\twrite_reg_fp(client, 0x20, 0x040 | vidsys);\n\t\twrite_reg_fp(client, 0x21, 0x666);\n\t\twrite_reg_fp(client, 0x140, 0x060);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tstate->input = input;\n\treturn 0;\n}\n\nstatic int s2250_s_std(struct v4l2_subdev *sd, v4l2_std_id norm)\n{\n\tstruct s2250 *state = to_state(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\tu16 vidsource;\n\n\tvidsource = (state->input == 1) ? 0x040 : 0x020;\n\tif (norm & V4L2_STD_625_50) {\n\t\twrite_regs_fp(client, vid_regs_fp);\n\t\twrite_regs_fp(client, vid_regs_fp_pal);\n\t\twrite_reg_fp(client, 0x20, vidsource);\n\t} else {\n\t\twrite_regs_fp(client, vid_regs_fp);\n\t\twrite_reg_fp(client, 0x20, vidsource | 1);\n\t}\n\tstate->std = norm;\n\treturn 0;\n}\n\nstatic int s2250_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct s2250 *state = container_of(ctrl->handler, struct s2250, hdl);\n\tstruct i2c_client *client = v4l2_get_subdevdata(&state->sd);\n\tu16 oldvalue;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tread_reg_fp(client, VPX322_ADDR_BRIGHTNESS0, &oldvalue);\n\t\twrite_reg_fp(client, VPX322_ADDR_BRIGHTNESS0,\n\t\t\t     ctrl->val | (oldvalue & ~0xff));\n\t\tread_reg_fp(client, VPX322_ADDR_BRIGHTNESS1, &oldvalue);\n\t\twrite_reg_fp(client, VPX322_ADDR_BRIGHTNESS1,\n\t\t\t     ctrl->val | (oldvalue & ~0xff));\n\t\twrite_reg_fp(client, 0x140, 0x60);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tread_reg_fp(client, VPX322_ADDR_CONTRAST0, &oldvalue);\n\t\twrite_reg_fp(client, VPX322_ADDR_CONTRAST0,\n\t\t\t     ctrl->val | (oldvalue & ~0x3f));\n\t\tread_reg_fp(client, VPX322_ADDR_CONTRAST1, &oldvalue);\n\t\twrite_reg_fp(client, VPX322_ADDR_CONTRAST1,\n\t\t\t     ctrl->val | (oldvalue & ~0x3f));\n\t\twrite_reg_fp(client, 0x140, 0x60);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\twrite_reg_fp(client, VPX322_ADDR_SAT, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\twrite_reg_fp(client, VPX322_ADDR_HUE, ctrl->val);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int s2250_set_fmt(struct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct v4l2_mbus_framefmt *fmt = &format->format;\n\tstruct s2250 *state = to_state(sd);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tif (format->pad)\n\t\treturn -EINVAL;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn 0;\n\n\tif (fmt->height < 640) {\n\t\twrite_reg_fp(client, 0x12b, state->reg12b_val | 0x400);\n\t\twrite_reg_fp(client, 0x140, 0x060);\n\t} else {\n\t\twrite_reg_fp(client, 0x12b, state->reg12b_val & ~0x400);\n\t\twrite_reg_fp(client, 0x140, 0x060);\n\t}\n\treturn 0;\n}\n\nstatic int s2250_s_audio_routing(struct v4l2_subdev *sd, u32 input, u32 output,\n\t\t\t\t u32 config)\n{\n\tstruct s2250 *state = to_state(sd);\n\n\tswitch (input) {\n\tcase 0:\n\t\twrite_reg(state->audio, 0x08, 0x02);  \n\t\tbreak;\n\tcase 1:\n\t\twrite_reg(state->audio, 0x08, 0x04);  \n\t\tbreak;\n\tcase 2:\n\t\twrite_reg(state->audio, 0x08, 0x05);  \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tstate->audio_input = input;\n\treturn 0;\n}\n\n\nstatic int s2250_log_status(struct v4l2_subdev *sd)\n{\n\tstruct s2250 *state = to_state(sd);\n\n\tv4l2_info(sd, \"Standard: %s\\n\", state->std == V4L2_STD_NTSC ? \"NTSC\" :\n\t\t\t\t\tstate->std == V4L2_STD_PAL ? \"PAL\" :\n\t\t\t\t\tstate->std == V4L2_STD_SECAM ? \"SECAM\" :\n\t\t\t\t\t\"unknown\");\n\tv4l2_info(sd, \"Input: %s\\n\", state->input == 0 ? \"Composite\" :\n\t\t\t\t\tstate->input == 1 ? \"S-video\" :\n\t\t\t\t\t\"error\");\n\tv4l2_info(sd, \"Audio input: %s\\n\", state->audio_input == 0 ? \"Line In\" :\n\t\t\t\t\tstate->audio_input == 1 ? \"Mic\" :\n\t\t\t\t\tstate->audio_input == 2 ? \"Mic Boost\" :\n\t\t\t\t\t\"error\");\n\treturn v4l2_ctrl_subdev_log_status(sd);\n}\n\n \n\nstatic const struct v4l2_ctrl_ops s2250_ctrl_ops = {\n\t.s_ctrl = s2250_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops s2250_core_ops = {\n\t.log_status = s2250_log_status,\n};\n\nstatic const struct v4l2_subdev_audio_ops s2250_audio_ops = {\n\t.s_routing = s2250_s_audio_routing,\n};\n\nstatic const struct v4l2_subdev_video_ops s2250_video_ops = {\n\t.s_std = s2250_s_std,\n\t.s_routing = s2250_s_video_routing,\n};\n\nstatic const struct v4l2_subdev_pad_ops s2250_pad_ops = {\n\t.set_fmt = s2250_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops s2250_ops = {\n\t.core = &s2250_core_ops,\n\t.audio = &s2250_audio_ops,\n\t.video = &s2250_video_ops,\n\t.pad = &s2250_pad_ops,\n};\n\n \n\nstatic int s2250_probe(struct i2c_client *client)\n{\n\tstruct i2c_client *audio;\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct s2250 *state;\n\tstruct v4l2_subdev *sd;\n\tu8 *data;\n\tstruct go7007 *go = i2c_get_adapdata(adapter);\n\tstruct go7007_usb *usb = go->hpi_context;\n\tint err = -EIO;\n\n\taudio = i2c_new_dummy_device(adapter, TLV320_ADDRESS >> 1);\n\tif (IS_ERR(audio))\n\t\treturn PTR_ERR(audio);\n\n\tstate = kzalloc(sizeof(struct s2250), GFP_KERNEL);\n\tif (state == NULL) {\n\t\ti2c_unregister_device(audio);\n\t\treturn -ENOMEM;\n\t}\n\n\tsd = &state->sd;\n\tv4l2_i2c_subdev_init(sd, client, &s2250_ops);\n\n\tv4l2_info(sd, \"initializing %s at address 0x%x on %s\\n\",\n\t       \"Sensoray 2250/2251\", client->addr, client->adapter->name);\n\n\tv4l2_ctrl_handler_init(&state->hdl, 4);\n\tv4l2_ctrl_new_std(&state->hdl, &s2250_ctrl_ops,\n\t\tV4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\n\tv4l2_ctrl_new_std(&state->hdl, &s2250_ctrl_ops,\n\t\tV4L2_CID_CONTRAST, 0, 0x3f, 1, 0x32);\n\tv4l2_ctrl_new_std(&state->hdl, &s2250_ctrl_ops,\n\t\tV4L2_CID_SATURATION, 0, 4094, 1, 2070);\n\tv4l2_ctrl_new_std(&state->hdl, &s2250_ctrl_ops,\n\t\tV4L2_CID_HUE, -512, 511, 1, 0);\n\tsd->ctrl_handler = &state->hdl;\n\tif (state->hdl.error) {\n\t\terr = state->hdl.error;\n\t\tgoto fail;\n\t}\n\n\tstate->std = V4L2_STD_NTSC;\n\tstate->brightness = 50;\n\tstate->contrast = 50;\n\tstate->saturation = 50;\n\tstate->hue = 0;\n\tstate->audio = audio;\n\n\t \n\tif (write_regs(audio, aud_regs) < 0) {\n\t\tdev_err(&client->dev, \"error initializing audio\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (write_regs(client, vid_regs) < 0) {\n\t\tdev_err(&client->dev, \"error initializing decoder\\n\");\n\t\tgoto fail;\n\t}\n\tif (write_regs_fp(client, vid_regs_fp) < 0) {\n\t\tdev_err(&client->dev, \"error initializing decoder\\n\");\n\t\tgoto fail;\n\t}\n\t \n\t \n\twrite_reg_fp(client, 0x20, 0x020 | 1);\n\twrite_reg_fp(client, 0x21, 0x662);\n\twrite_reg_fp(client, 0x140, 0x060);\n\n\t \n\tstate->audio_input = 0;\n\twrite_reg(client, 0x08, 0x02);  \n\n\tif (mutex_lock_interruptible(&usb->i2c_lock) == 0) {\n\t\tdata = kzalloc(16, GFP_KERNEL);\n\t\tif (data != NULL) {\n\t\t\tint rc = go7007_usb_vendor_request(go, 0x41, 0, 0,\n\t\t\t\t\t\t       data, 16, 1);\n\n\t\t\tif (rc > 0) {\n\t\t\t\tu8 mask;\n\n\t\t\t\tdata[0] = 0;\n\t\t\t\tmask = 1<<5;\n\t\t\t\tdata[0] &= ~mask;\n\t\t\t\tdata[1] |= mask;\n\t\t\t\tgo7007_usb_vendor_request(go, 0x40, 0,\n\t\t\t\t\t\t\t  (data[1]<<8)\n\t\t\t\t\t\t\t  + data[1],\n\t\t\t\t\t\t\t  data, 16, 0);\n\t\t\t}\n\t\t\tkfree(data);\n\t\t}\n\t\tmutex_unlock(&usb->i2c_lock);\n\t}\n\n\tv4l2_info(sd, \"initialized successfully\\n\");\n\treturn 0;\n\nfail:\n\ti2c_unregister_device(audio);\n\tv4l2_ctrl_handler_free(&state->hdl);\n\tkfree(state);\n\treturn err;\n}\n\nstatic void s2250_remove(struct i2c_client *client)\n{\n\tstruct s2250 *state = to_state(i2c_get_clientdata(client));\n\n\ti2c_unregister_device(state->audio);\n\tv4l2_device_unregister_subdev(&state->sd);\n\tv4l2_ctrl_handler_free(&state->hdl);\n\tkfree(state);\n}\n\nstatic const struct i2c_device_id s2250_id[] = {\n\t{ \"s2250\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, s2250_id);\n\nstatic struct i2c_driver s2250_driver = {\n\t.driver = {\n\t\t.name\t= \"s2250\",\n\t},\n\t.probe\t\t= s2250_probe,\n\t.remove\t\t= s2250_remove,\n\t.id_table\t= s2250_id,\n};\n\nmodule_i2c_driver(s2250_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}