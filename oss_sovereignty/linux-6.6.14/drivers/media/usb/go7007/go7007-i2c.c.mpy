{
  "module_name": "go7007-i2c.c",
  "hash_id": "046ef9c22ab5e577c9dfcac020879b52b79ae62c786619c6ecfe597f17fb201e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/go7007/go7007-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/unistd.h>\n#include <linux/time.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n\n#include \"go7007-priv.h\"\n\n \n\n \n\n#define SPI_I2C_ADDR_BASE\t\t0x1400\n#define STATUS_REG_ADDR\t\t\t(SPI_I2C_ADDR_BASE + 0x2)\n#define I2C_CTRL_REG_ADDR\t\t(SPI_I2C_ADDR_BASE + 0x6)\n#define I2C_DEV_UP_ADDR_REG_ADDR\t(SPI_I2C_ADDR_BASE + 0x7)\n#define I2C_LO_ADDR_REG_ADDR\t\t(SPI_I2C_ADDR_BASE + 0x8)\n#define I2C_DATA_REG_ADDR\t\t(SPI_I2C_ADDR_BASE + 0x9)\n#define I2C_CLKFREQ_REG_ADDR\t\t(SPI_I2C_ADDR_BASE + 0xa)\n\n#define I2C_STATE_MASK\t\t\t0x0007\n#define I2C_READ_READY_MASK\t\t0x0008\n\n \nstatic DEFINE_MUTEX(adlink_mpg24_i2c_lock);\n\nstatic int go7007_i2c_xfer(struct go7007 *go, u16 addr, int read,\n\t\tu16 command, int flags, u8 *data)\n{\n\tint i, ret = -EIO;\n\tu16 val;\n\n\tif (go->status == STATUS_SHUTDOWN)\n\t\treturn -ENODEV;\n\n#ifdef GO7007_I2C_DEBUG\n\tif (read)\n\t\tdev_dbg(go->dev, \"go7007-i2c: reading 0x%02x on 0x%02x\\n\",\n\t\t\tcommand, addr);\n\telse\n\t\tdev_dbg(go->dev,\n\t\t\t\"go7007-i2c: writing 0x%02x to 0x%02x on 0x%02x\\n\",\n\t\t\t*data, command, addr);\n#endif\n\n\tmutex_lock(&go->hw_lock);\n\n\tif (go->board_id == GO7007_BOARDID_ADLINK_MPG24) {\n\t\t \n\t\tmutex_lock(&adlink_mpg24_i2c_lock);\n\t\tgo7007_write_addr(go, 0x3c82, 0x0020);\n\t}\n\n\t \n\tfor (i = 0; i < 10; ++i) {\n\t\tif (go7007_read_addr(go, STATUS_REG_ADDR, &val) < 0)\n\t\t\tgoto i2c_done;\n\t\tif (!(val & I2C_STATE_MASK))\n\t\t\tbreak;\n\t\tmsleep(100);\n\t}\n\tif (i == 10) {\n\t\tdev_err(go->dev, \"go7007-i2c: I2C adapter is hung\\n\");\n\t\tgoto i2c_done;\n\t}\n\n\t \n\tgo7007_write_addr(go, I2C_CTRL_REG_ADDR, flags);\n\tgo7007_write_addr(go, I2C_LO_ADDR_REG_ADDR, command);\n\n\t \n\tif (!read) {\n\t\tgo7007_write_addr(go, I2C_DATA_REG_ADDR, *data);\n\t\tgo7007_write_addr(go, I2C_DEV_UP_ADDR_REG_ADDR,\n\t\t\t\t\t(addr << 9) | (command >> 8));\n\t\tret = 0;\n\t\tgoto i2c_done;\n\t}\n\n\t \n\tif (go7007_read_addr(go, I2C_DATA_REG_ADDR, &val) < 0)\n\t\tgoto i2c_done;\n\n\t \n\tgo7007_write_addr(go, I2C_DEV_UP_ADDR_REG_ADDR,\n\t\t\t(addr << 9) | 0x0100 | (command >> 8));\n\n\t \n\tfor (i = 0; i < 10; ++i) {\n\t\tif (go7007_read_addr(go, STATUS_REG_ADDR, &val) < 0)\n\t\t\tgoto i2c_done;\n\t\tif (val & I2C_READ_READY_MASK)\n\t\t\tbreak;\n\t\tmsleep(100);\n\t}\n\tif (i == 10) {\n\t\tdev_err(go->dev, \"go7007-i2c: I2C adapter is hung\\n\");\n\t\tgoto i2c_done;\n\t}\n\n\t \n\tif (go7007_read_addr(go, I2C_DATA_REG_ADDR, &val) < 0)\n\t\tgoto i2c_done;\n\t*data = val;\n\tret = 0;\n\ni2c_done:\n\tif (go->board_id == GO7007_BOARDID_ADLINK_MPG24) {\n\t\t \n\t\tgo7007_write_addr(go, 0x3c82, 0x0000);\n\t\tmutex_unlock(&adlink_mpg24_i2c_lock);\n\t}\n\tmutex_unlock(&go->hw_lock);\n\treturn ret;\n}\n\nstatic int go7007_smbus_xfer(struct i2c_adapter *adapter, u16 addr,\n\t\tunsigned short flags, char read_write,\n\t\tu8 command, int size, union i2c_smbus_data *data)\n{\n\tstruct go7007 *go = i2c_get_adapdata(adapter);\n\n\tif (size != I2C_SMBUS_BYTE_DATA)\n\t\treturn -EIO;\n\treturn go7007_i2c_xfer(go, addr, read_write == I2C_SMBUS_READ, command,\n\t\t\tflags & I2C_CLIENT_SCCB ? 0x10 : 0x00, &data->byte);\n}\n\n \n\nstatic int go7007_i2c_master_xfer(struct i2c_adapter *adapter,\n\t\t\t\t\tstruct i2c_msg msgs[], int num)\n{\n\tstruct go7007 *go = i2c_get_adapdata(adapter);\n\tint i;\n\n\tfor (i = 0; i < num; ++i) {\n\t\t \n\t\tif (msgs[i].len == 2) {\n\t\t\tif (i + 1 == num || msgs[i].addr != msgs[i + 1].addr ||\n\t\t\t\t\t(msgs[i].flags & I2C_M_RD) ||\n\t\t\t\t\t!(msgs[i + 1].flags & I2C_M_RD) ||\n\t\t\t\t\tmsgs[i + 1].len != 1)\n\t\t\t\treturn -EIO;\n\t\t\tif (go7007_i2c_xfer(go, msgs[i].addr, 1,\n\t\t\t\t\t(msgs[i].buf[0] << 8) | msgs[i].buf[1],\n\t\t\t\t\t0x01, &msgs[i + 1].buf[0]) < 0)\n\t\t\t\treturn -EIO;\n\t\t\t++i;\n\t\t} else if (msgs[i].len == 3) {\n\t\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\t\treturn -EIO;\n\t\t\tif (go7007_i2c_xfer(go, msgs[i].addr, 0,\n\t\t\t\t\t(msgs[i].buf[0] << 8) | msgs[i].buf[1],\n\t\t\t\t\t0x01, &msgs[i].buf[2]) < 0)\n\t\t\t\treturn -EIO;\n\t\t} else\n\t\t\treturn -EIO;\n\t}\n\n\treturn num;\n}\n\nstatic u32 go7007_functionality(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_SMBUS_BYTE_DATA;\n}\n\nstatic const struct i2c_algorithm go7007_algo = {\n\t.smbus_xfer\t= go7007_smbus_xfer,\n\t.master_xfer\t= go7007_i2c_master_xfer,\n\t.functionality\t= go7007_functionality,\n};\n\nstatic struct i2c_adapter go7007_adap_templ = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"WIS GO7007SB\",\n\t.algo\t\t\t= &go7007_algo,\n};\n\nint go7007_i2c_init(struct go7007 *go)\n{\n\tmemcpy(&go->i2c_adapter, &go7007_adap_templ,\n\t\t\tsizeof(go7007_adap_templ));\n\tgo->i2c_adapter.dev.parent = go->dev;\n\ti2c_set_adapdata(&go->i2c_adapter, go);\n\tif (i2c_add_adapter(&go->i2c_adapter) < 0) {\n\t\tdev_err(go->dev,\n\t\t\t\"go7007-i2c: error: i2c_add_adapter failed\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}