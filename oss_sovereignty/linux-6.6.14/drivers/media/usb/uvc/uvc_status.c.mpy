{
  "module_name": "uvc_status.c",
  "hash_id": "6e842ed660d47dc6ca6a521e805d39b82cdb0612ac8db09b8df963eaf4f332ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/uvc/uvc_status.c",
  "human_readable_source": "\n \n\n#include <asm/barrier.h>\n#include <linux/kernel.h>\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/input.h>\n\n#include \"uvcvideo.h\"\n\n \n#ifdef CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV\n\nstatic bool uvc_input_has_button(struct uvc_device *dev)\n{\n\tstruct uvc_streaming *stream;\n\n\t \n\tlist_for_each_entry(stream, &dev->streams, list) {\n\t\tif (stream->header.bTriggerSupport == 1 &&\n\t\t    stream->header.bTriggerUsage == 1)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int uvc_input_init(struct uvc_device *dev)\n{\n\tstruct input_dev *input;\n\tint ret;\n\n\tif (!uvc_input_has_button(dev))\n\t\treturn 0;\n\n\tinput = input_allocate_device();\n\tif (input == NULL)\n\t\treturn -ENOMEM;\n\n\tusb_make_path(dev->udev, dev->input_phys, sizeof(dev->input_phys));\n\tstrlcat(dev->input_phys, \"/button\", sizeof(dev->input_phys));\n\n\tinput->name = dev->name;\n\tinput->phys = dev->input_phys;\n\tusb_to_input_id(dev->udev, &input->id);\n\tinput->dev.parent = &dev->intf->dev;\n\n\t__set_bit(EV_KEY, input->evbit);\n\t__set_bit(KEY_CAMERA, input->keybit);\n\n\tif ((ret = input_register_device(input)) < 0)\n\t\tgoto error;\n\n\tdev->input = input;\n\treturn 0;\n\nerror:\n\tinput_free_device(input);\n\treturn ret;\n}\n\nstatic void uvc_input_unregister(struct uvc_device *dev)\n{\n\tif (dev->input)\n\t\tinput_unregister_device(dev->input);\n}\n\nstatic void uvc_input_report_key(struct uvc_device *dev, unsigned int code,\n\tint value)\n{\n\tif (dev->input) {\n\t\tinput_report_key(dev->input, code, value);\n\t\tinput_sync(dev->input);\n\t}\n}\n\n#else\n#define uvc_input_init(dev)\n#define uvc_input_unregister(dev)\n#define uvc_input_report_key(dev, code, value)\n#endif  \n\n \nstatic void uvc_event_streaming(struct uvc_device *dev,\n\t\t\t\tstruct uvc_status *status, int len)\n{\n\tif (len <= offsetof(struct uvc_status, bEvent)) {\n\t\tuvc_dbg(dev, STATUS,\n\t\t\t\"Invalid streaming status event received\\n\");\n\t\treturn;\n\t}\n\n\tif (status->bEvent == 0) {\n\t\tif (len <= offsetof(struct uvc_status, streaming))\n\t\t\treturn;\n\n\t\tuvc_dbg(dev, STATUS, \"Button (intf %u) %s len %d\\n\",\n\t\t\tstatus->bOriginator,\n\t\t\tstatus->streaming.button ? \"pressed\" : \"released\", len);\n\t\tuvc_input_report_key(dev, KEY_CAMERA, status->streaming.button);\n\t} else {\n\t\tuvc_dbg(dev, STATUS, \"Stream %u error event %02x len %d\\n\",\n\t\t\tstatus->bOriginator, status->bEvent, len);\n\t}\n}\n\n#define UVC_CTRL_VALUE_CHANGE\t0\n#define UVC_CTRL_INFO_CHANGE\t1\n#define UVC_CTRL_FAILURE_CHANGE\t2\n#define UVC_CTRL_MIN_CHANGE\t3\n#define UVC_CTRL_MAX_CHANGE\t4\n\nstatic struct uvc_control *uvc_event_entity_find_ctrl(struct uvc_entity *entity,\n\t\t\t\t\t\t      u8 selector)\n{\n\tstruct uvc_control *ctrl;\n\tunsigned int i;\n\n\tfor (i = 0, ctrl = entity->controls; i < entity->ncontrols; i++, ctrl++)\n\t\tif (ctrl->info.selector == selector)\n\t\t\treturn ctrl;\n\n\treturn NULL;\n}\n\nstatic struct uvc_control *uvc_event_find_ctrl(struct uvc_device *dev,\n\t\t\t\t\tconst struct uvc_status *status,\n\t\t\t\t\tstruct uvc_video_chain **chain)\n{\n\tlist_for_each_entry((*chain), &dev->chains, list) {\n\t\tstruct uvc_entity *entity;\n\t\tstruct uvc_control *ctrl;\n\n\t\tlist_for_each_entry(entity, &(*chain)->entities, chain) {\n\t\t\tif (entity->id != status->bOriginator)\n\t\t\t\tcontinue;\n\n\t\t\tctrl = uvc_event_entity_find_ctrl(entity,\n\t\t\t\t\t\t     status->control.bSelector);\n\t\t\tif (ctrl)\n\t\t\t\treturn ctrl;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic bool uvc_event_control(struct urb *urb,\n\t\t\t      const struct uvc_status *status, int len)\n{\n\tstatic const char *attrs[] = { \"value\", \"info\", \"failure\", \"min\", \"max\" };\n\tstruct uvc_device *dev = urb->context;\n\tstruct uvc_video_chain *chain;\n\tstruct uvc_control *ctrl;\n\n\tif (len < 6 || status->bEvent != 0 ||\n\t    status->control.bAttribute >= ARRAY_SIZE(attrs)) {\n\t\tuvc_dbg(dev, STATUS, \"Invalid control status event received\\n\");\n\t\treturn false;\n\t}\n\n\tuvc_dbg(dev, STATUS, \"Control %u/%u %s change len %d\\n\",\n\t\tstatus->bOriginator, status->control.bSelector,\n\t\tattrs[status->control.bAttribute], len);\n\n\t \n\tctrl = uvc_event_find_ctrl(dev, status, &chain);\n\tif (!ctrl)\n\t\treturn false;\n\n\tswitch (status->control.bAttribute) {\n\tcase UVC_CTRL_VALUE_CHANGE:\n\t\treturn uvc_ctrl_status_event_async(urb, chain, ctrl,\n\t\t\t\t\t\t   status->control.bValue);\n\n\tcase UVC_CTRL_INFO_CHANGE:\n\tcase UVC_CTRL_FAILURE_CHANGE:\n\tcase UVC_CTRL_MIN_CHANGE:\n\tcase UVC_CTRL_MAX_CHANGE:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic void uvc_status_complete(struct urb *urb)\n{\n\tstruct uvc_device *dev = urb->context;\n\tint len, ret;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\n\tcase -ENOENT:\t\t \n\tcase -ECONNRESET:\t \n\tcase -ESHUTDOWN:\t \n\tcase -EPROTO:\t\t \n\t\treturn;\n\n\tdefault:\n\t\tdev_warn(&dev->udev->dev,\n\t\t\t \"Non-zero status (%d) in status completion handler.\\n\",\n\t\t\t urb->status);\n\t\treturn;\n\t}\n\n\tlen = urb->actual_length;\n\tif (len > 0) {\n\t\tswitch (dev->status->bStatusType & 0x0f) {\n\t\tcase UVC_STATUS_TYPE_CONTROL: {\n\t\t\tif (uvc_event_control(urb, dev->status, len))\n\t\t\t\t \n\t\t\t\treturn;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase UVC_STATUS_TYPE_STREAMING: {\n\t\t\tuvc_event_streaming(dev, dev->status, len);\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tuvc_dbg(dev, STATUS, \"Unknown status event type %u\\n\",\n\t\t\t\tdev->status->bStatusType);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\turb->interval = dev->int_ep->desc.bInterval;\n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"Failed to resubmit status URB (%d).\\n\", ret);\n}\n\nint uvc_status_init(struct uvc_device *dev)\n{\n\tstruct usb_host_endpoint *ep = dev->int_ep;\n\tunsigned int pipe;\n\tint interval;\n\n\tif (ep == NULL)\n\t\treturn 0;\n\n\tuvc_input_init(dev);\n\n\tdev->status = kzalloc(sizeof(*dev->status), GFP_KERNEL);\n\tif (!dev->status)\n\t\treturn -ENOMEM;\n\n\tdev->int_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->int_urb) {\n\t\tkfree(dev->status);\n\t\treturn -ENOMEM;\n\t}\n\n\tpipe = usb_rcvintpipe(dev->udev, ep->desc.bEndpointAddress);\n\n\t \n\tinterval = ep->desc.bInterval;\n\tif (interval > 16 && dev->udev->speed == USB_SPEED_HIGH &&\n\t    (dev->quirks & UVC_QUIRK_STATUS_INTERVAL))\n\t\tinterval = fls(interval) - 1;\n\n\tusb_fill_int_urb(dev->int_urb, dev->udev, pipe,\n\t\tdev->status, sizeof(*dev->status), uvc_status_complete,\n\t\tdev, interval);\n\n\treturn 0;\n}\n\nvoid uvc_status_unregister(struct uvc_device *dev)\n{\n\tusb_kill_urb(dev->int_urb);\n\tuvc_input_unregister(dev);\n}\n\nvoid uvc_status_cleanup(struct uvc_device *dev)\n{\n\tusb_free_urb(dev->int_urb);\n\tkfree(dev->status);\n}\n\nint uvc_status_start(struct uvc_device *dev, gfp_t flags)\n{\n\tif (dev->int_urb == NULL)\n\t\treturn 0;\n\n\treturn usb_submit_urb(dev->int_urb, flags);\n}\n\nvoid uvc_status_stop(struct uvc_device *dev)\n{\n\tstruct uvc_ctrl_work *w = &dev->async_ctrl;\n\n\t \n\tsmp_store_release(&dev->flush_status, true);\n\n\t \n\tif (cancel_work_sync(&w->work))\n\t\tuvc_ctrl_status_event(w->chain, w->ctrl, w->data);\n\n\t \n\tusb_kill_urb(dev->int_urb);\n\n\t \n\tif (cancel_work_sync(&w->work))\n\t\tuvc_ctrl_status_event(w->chain, w->ctrl, w->data);\n\n\t \n\tsmp_store_release(&dev->flush_status, false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}