{
  "module_name": "uvc_isight.c",
  "hash_id": "bb91b97b39d416d254c4725db022fc559291c5ca9a65e4b27c2243cefca95d4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/uvc/uvc_isight.c",
  "human_readable_source": "\n \n\n#include <linux/usb.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n\n#include \"uvcvideo.h\"\n\n \n\nstatic int isight_decode(struct uvc_video_queue *queue, struct uvc_buffer *buf,\n\t\tconst u8 *data, unsigned int len)\n{\n\tstatic const u8 hdr[] = {\n\t\t0x11, 0x22, 0x33, 0x44,\n\t\t0xde, 0xad, 0xbe, 0xef,\n\t\t0xde, 0xad, 0xfa, 0xce\n\t};\n\n\tstruct uvc_streaming *stream = uvc_queue_to_stream(queue);\n\tunsigned int maxlen, nbytes;\n\tu8 *mem;\n\tint is_header = 0;\n\n\tif (buf == NULL)\n\t\treturn 0;\n\n\tif ((len >= 14 && memcmp(&data[2], hdr, 12) == 0) ||\n\t    (len >= 15 && memcmp(&data[3], hdr, 12) == 0)) {\n\t\tuvc_dbg(stream->dev, FRAME, \"iSight header found\\n\");\n\t\tis_header = 1;\n\t}\n\n\t \n\tif (buf->state != UVC_BUF_STATE_ACTIVE) {\n\t\tif (!is_header) {\n\t\t\tuvc_dbg(stream->dev, FRAME,\n\t\t\t\t\"Dropping packet (out of sync)\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tbuf->state = UVC_BUF_STATE_ACTIVE;\n\t}\n\n\t \n\tif (is_header && buf->bytesused != 0) {\n\t\tbuf->state = UVC_BUF_STATE_DONE;\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tif (!is_header) {\n\t\tmaxlen = buf->length - buf->bytesused;\n\t\tmem = buf->mem + buf->bytesused;\n\t\tnbytes = min(len, maxlen);\n\t\tmemcpy(mem, data, nbytes);\n\t\tbuf->bytesused += nbytes;\n\n\t\tif (len > maxlen || buf->bytesused == buf->length) {\n\t\t\tuvc_dbg(stream->dev, FRAME,\n\t\t\t\t\"Frame complete (overflow)\\n\");\n\t\t\tbuf->state = UVC_BUF_STATE_DONE;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid uvc_video_decode_isight(struct uvc_urb *uvc_urb, struct uvc_buffer *buf,\n\t\t\tstruct uvc_buffer *meta_buf)\n{\n\tstruct urb *urb = uvc_urb->urb;\n\tstruct uvc_streaming *stream = uvc_urb->stream;\n\tint ret, i;\n\n\tfor (i = 0; i < urb->number_of_packets; ++i) {\n\t\tif (urb->iso_frame_desc[i].status < 0) {\n\t\t\tuvc_dbg(stream->dev, FRAME,\n\t\t\t\t\"USB isochronous frame lost (%d)\\n\",\n\t\t\t\turb->iso_frame_desc[i].status);\n\t\t}\n\n\t\t \n\t\tdo {\n\t\t\tret = isight_decode(&stream->queue, buf,\n\t\t\t\t\turb->transfer_buffer +\n\t\t\t\t\turb->iso_frame_desc[i].offset,\n\t\t\t\t\turb->iso_frame_desc[i].actual_length);\n\n\t\t\tif (buf == NULL)\n\t\t\t\tbreak;\n\n\t\t\tif (buf->state == UVC_BUF_STATE_DONE ||\n\t\t\t    buf->state == UVC_BUF_STATE_ERROR)\n\t\t\t\tbuf = uvc_queue_next_buffer(&stream->queue,\n\t\t\t\t\t\t\tbuf);\n\t\t} while (ret == -EAGAIN);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}