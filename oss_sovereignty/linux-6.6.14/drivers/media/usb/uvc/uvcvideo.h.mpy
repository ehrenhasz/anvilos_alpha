{
  "module_name": "uvcvideo.h",
  "hash_id": "c8cee2df017a74f2e9f524e03322a84361c47ce88cad0a564997837ce04b9158",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/uvc/uvcvideo.h",
  "human_readable_source": " \n#ifndef _USB_VIDEO_H_\n#define _USB_VIDEO_H_\n\n#ifndef __KERNEL__\n#error \"The uvcvideo.h header is deprecated, use linux/uvcvideo.h instead.\"\n#endif  \n\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n#include <linux/poll.h>\n#include <linux/usb.h>\n#include <linux/usb/video.h>\n#include <linux/uvcvideo.h>\n#include <linux/videodev2.h>\n#include <linux/workqueue.h>\n#include <media/media-device.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fh.h>\n#include <media/videobuf2-v4l2.h>\n\n \n\n#define UVC_TERM_INPUT\t\t\t0x0000\n#define UVC_TERM_OUTPUT\t\t\t0x8000\n#define UVC_TERM_DIRECTION(term)\t((term)->type & 0x8000)\n\n#define UVC_ENTITY_TYPE(entity)\t\t((entity)->type & 0x7fff)\n#define UVC_ENTITY_IS_UNIT(entity)\t(((entity)->type & 0xff00) == 0)\n#define UVC_ENTITY_IS_TERM(entity)\t(((entity)->type & 0xff00) != 0)\n#define UVC_ENTITY_IS_ITERM(entity) \\\n\t(UVC_ENTITY_IS_TERM(entity) && \\\n\t((entity)->type & 0x8000) == UVC_TERM_INPUT)\n#define UVC_ENTITY_IS_OTERM(entity) \\\n\t(UVC_ENTITY_IS_TERM(entity) && \\\n\t((entity)->type & 0x8000) == UVC_TERM_OUTPUT)\n\n#define UVC_EXT_GPIO_UNIT\t\t0x7ffe\n#define UVC_EXT_GPIO_UNIT_ID\t\t0x100\n\n \n\n#define DRIVER_VERSION\t\t\"1.1.1\"\n\n \n#define UVC_URBS\t\t5\n \n#define UVC_MAX_PACKETS\t\t32\n\n#define UVC_CTRL_CONTROL_TIMEOUT\t5000\n#define UVC_CTRL_STREAMING_TIMEOUT\t5000\n\n \n#define UVC_MAX_CONTROL_MAPPINGS\t1024\n#define UVC_MAX_CONTROL_MENU_ENTRIES\t32\n\n \n#define UVC_QUIRK_STATUS_INTERVAL\t0x00000001\n#define UVC_QUIRK_PROBE_MINMAX\t\t0x00000002\n#define UVC_QUIRK_PROBE_EXTRAFIELDS\t0x00000004\n#define UVC_QUIRK_BUILTIN_ISIGHT\t0x00000008\n#define UVC_QUIRK_STREAM_NO_FID\t\t0x00000010\n#define UVC_QUIRK_IGNORE_SELECTOR_UNIT\t0x00000020\n#define UVC_QUIRK_FIX_BANDWIDTH\t\t0x00000080\n#define UVC_QUIRK_PROBE_DEF\t\t0x00000100\n#define UVC_QUIRK_RESTRICT_FRAME_RATE\t0x00000200\n#define UVC_QUIRK_RESTORE_CTRLS_ON_INIT\t0x00000400\n#define UVC_QUIRK_FORCE_Y8\t\t0x00000800\n#define UVC_QUIRK_FORCE_BPP\t\t0x00001000\n#define UVC_QUIRK_WAKE_AUTOSUSPEND\t0x00002000\n\n \n#define UVC_FMT_FLAG_COMPRESSED\t\t0x00000001\n#define UVC_FMT_FLAG_STREAM\t\t0x00000002\n\n \n\nstruct gpio_desc;\nstruct sg_table;\nstruct uvc_device;\n\n \nstruct uvc_control_info {\n\tstruct list_head mappings;\n\n\tu8 entity[16];\n\tu8 index;\t \n\tu8 selector;\n\n\tu16 size;\n\tu32 flags;\n};\n\nstruct uvc_control_mapping {\n\tstruct list_head list;\n\tstruct list_head ev_subs;\n\n\tu32 id;\n\tchar *name;\n\tu8 entity[16];\n\tu8 selector;\n\n\tu8 size;\n\tu8 offset;\n\tenum v4l2_ctrl_type v4l2_type;\n\tu32 data_type;\n\n\tconst u32 *menu_mapping;\n\tconst char (*menu_names)[UVC_MENU_NAME_LEN];\n\tunsigned long menu_mask;\n\n\tu32 master_id;\n\ts32 master_manual;\n\tu32 slave_ids[2];\n\n\ts32 (*get)(struct uvc_control_mapping *mapping, u8 query,\n\t\t   const u8 *data);\n\tvoid (*set)(struct uvc_control_mapping *mapping, s32 value,\n\t\t    u8 *data);\n};\n\nstruct uvc_control {\n\tstruct uvc_entity *entity;\n\tstruct uvc_control_info info;\n\n\tu8 index;\t \n\tu8 dirty:1,\n\t   loaded:1,\n\t   modified:1,\n\t   cached:1,\n\t   initialized:1;\n\n\tu8 *uvc_data;\n\n\tstruct uvc_fh *handle;\t \n};\n\n \n\n#define UVC_ENTITY_FLAG_DEFAULT\t\t(1 << 0)\n\nstruct uvc_entity {\n\tstruct list_head list;\t\t \n\tstruct list_head chain;\t\t \n\tunsigned int flags;\n\n\t \n\tu16 id;\n\tu16 type;\n\tchar name[64];\n\tu8 guid[16];\n\n\t \n\tstruct video_device *vdev;\n\tstruct v4l2_subdev subdev;\n\tunsigned int num_pads;\n\tunsigned int num_links;\n\tstruct media_pad *pads;\n\n\tunion {\n\t\tstruct {\n\t\t\tu16 wObjectiveFocalLengthMin;\n\t\t\tu16 wObjectiveFocalLengthMax;\n\t\t\tu16 wOcularFocalLength;\n\t\t\tu8  bControlSize;\n\t\t\tu8  *bmControls;\n\t\t} camera;\n\n\t\tstruct {\n\t\t\tu8  bControlSize;\n\t\t\tu8  *bmControls;\n\t\t\tu8  bTransportModeSize;\n\t\t\tu8  *bmTransportModes;\n\t\t} media;\n\n\t\tstruct {\n\t\t} output;\n\n\t\tstruct {\n\t\t\tu16 wMaxMultiplier;\n\t\t\tu8  bControlSize;\n\t\t\tu8  *bmControls;\n\t\t\tu8  bmVideoStandards;\n\t\t} processing;\n\n\t\tstruct {\n\t\t} selector;\n\n\t\tstruct {\n\t\t\tu8  bNumControls;\n\t\t\tu8  bControlSize;\n\t\t\tu8  *bmControls;\n\t\t\tu8  *bmControlsType;\n\t\t} extension;\n\n\t\tstruct {\n\t\t\tu8  bControlSize;\n\t\t\tu8  *bmControls;\n\t\t\tstruct gpio_desc *gpio_privacy;\n\t\t\tint irq;\n\t\t} gpio;\n\t};\n\n\tu8 bNrInPins;\n\tu8 *baSourceID;\n\n\tint (*get_info)(struct uvc_device *dev, struct uvc_entity *entity,\n\t\t\tu8 cs, u8 *caps);\n\tint (*get_cur)(struct uvc_device *dev, struct uvc_entity *entity,\n\t\t       u8 cs, void *data, u16 size);\n\n\tunsigned int ncontrols;\n\tstruct uvc_control *controls;\n};\n\nstruct uvc_frame {\n\tu8  bFrameIndex;\n\tu8  bmCapabilities;\n\tu16 wWidth;\n\tu16 wHeight;\n\tu32 dwMinBitRate;\n\tu32 dwMaxBitRate;\n\tu32 dwMaxVideoFrameBufferSize;\n\tu8  bFrameIntervalType;\n\tu32 dwDefaultFrameInterval;\n\tconst u32 *dwFrameInterval;\n};\n\nstruct uvc_format {\n\tu8 type;\n\tu8 index;\n\tu8 bpp;\n\tenum v4l2_colorspace colorspace;\n\tenum v4l2_xfer_func xfer_func;\n\tenum v4l2_ycbcr_encoding ycbcr_enc;\n\tu32 fcc;\n\tu32 flags;\n\n\tunsigned int nframes;\n\tconst struct uvc_frame *frames;\n};\n\nstruct uvc_streaming_header {\n\tu8 bNumFormats;\n\tu8 bEndpointAddress;\n\tu8 bTerminalLink;\n\tu8 bControlSize;\n\tu8 *bmaControls;\n\t \n\tu8 bmInfo;\n\tu8 bStillCaptureMethod;\n\tu8 bTriggerSupport;\n\tu8 bTriggerUsage;\n};\n\nenum uvc_buffer_state {\n\tUVC_BUF_STATE_IDLE\t= 0,\n\tUVC_BUF_STATE_QUEUED\t= 1,\n\tUVC_BUF_STATE_ACTIVE\t= 2,\n\tUVC_BUF_STATE_READY\t= 3,\n\tUVC_BUF_STATE_DONE\t= 4,\n\tUVC_BUF_STATE_ERROR\t= 5,\n};\n\nstruct uvc_buffer {\n\tstruct vb2_v4l2_buffer buf;\n\tstruct list_head queue;\n\n\tenum uvc_buffer_state state;\n\tunsigned int error;\n\n\tvoid *mem;\n\tunsigned int length;\n\tunsigned int bytesused;\n\n\tu32 pts;\n\n\t \n\tstruct kref ref;\n};\n\n#define UVC_QUEUE_DISCONNECTED\t\t(1 << 0)\n#define UVC_QUEUE_DROP_CORRUPTED\t(1 << 1)\n\nstruct uvc_video_queue {\n\tstruct vb2_queue queue;\n\tstruct mutex mutex;\t\t\t \n\n\tunsigned int flags;\n\tunsigned int buf_used;\n\n\tspinlock_t irqlock;\t\t\t \n\tstruct list_head irqqueue;\n};\n\nstruct uvc_video_chain {\n\tstruct uvc_device *dev;\n\tstruct list_head list;\n\n\tstruct list_head entities;\t\t \n\tstruct uvc_entity *processing;\t\t \n\tstruct uvc_entity *selector;\t\t \n\n\tstruct mutex ctrl_mutex;\t\t \n\n\tstruct v4l2_prio_state prio;\t\t \n\tu32 caps;\t\t\t\t \n\tu8 ctrl_class_bitmap;\t\t\t \n};\n\nstruct uvc_stats_frame {\n\tunsigned int size;\t\t \n\tunsigned int first_data;\t \n\n\tunsigned int nb_packets;\t \n\tunsigned int nb_empty;\t\t \n\tunsigned int nb_invalid;\t \n\tunsigned int nb_errors;\t\t \n\n\tunsigned int nb_pts;\t\t \n\tunsigned int nb_pts_diffs;\t \n\tunsigned int last_pts_diff;\t \n\tbool has_initial_pts;\t\t \n\tbool has_early_pts;\t\t \n\tu32 pts;\t\t\t \n\n\tunsigned int nb_scr;\t\t \n\tunsigned int nb_scr_diffs;\t \n\tu16 scr_sof;\t\t\t \n\tu32 scr_stc;\t\t\t \n};\n\nstruct uvc_stats_stream {\n\tktime_t start_ts;\t\t \n\tktime_t stop_ts;\t\t \n\n\tunsigned int nb_frames;\t\t \n\n\tunsigned int nb_packets;\t \n\tunsigned int nb_empty;\t\t \n\tunsigned int nb_invalid;\t \n\tunsigned int nb_errors;\t\t \n\n\tunsigned int nb_pts_constant;\t \n\tunsigned int nb_pts_early;\t \n\tunsigned int nb_pts_initial;\t \n\n\tunsigned int nb_scr_count_ok;\t \n\tunsigned int nb_scr_diffs_ok;\t \n\tunsigned int scr_sof_count;\t \n\tunsigned int scr_sof;\t\t \n\tunsigned int min_sof;\t\t \n\tunsigned int max_sof;\t\t \n};\n\n#define UVC_METADATA_BUF_SIZE 10240\n\n \nstruct uvc_copy_op {\n\tstruct uvc_buffer *buf;\n\tvoid *dst;\n\tconst __u8 *src;\n\tsize_t len;\n};\n\n \nstruct uvc_urb {\n\tstruct urb *urb;\n\tstruct uvc_streaming *stream;\n\n\tchar *buffer;\n\tdma_addr_t dma;\n\tstruct sg_table *sgt;\n\n\tunsigned int async_operations;\n\tstruct uvc_copy_op copy_operations[UVC_MAX_PACKETS];\n\tstruct work_struct work;\n};\n\nstruct uvc_streaming {\n\tstruct list_head list;\n\tstruct uvc_device *dev;\n\tstruct video_device vdev;\n\tstruct uvc_video_chain *chain;\n\tatomic_t active;\n\n\tstruct usb_interface *intf;\n\tint intfnum;\n\tu16 maxpsize;\n\n\tstruct uvc_streaming_header header;\n\tenum v4l2_buf_type type;\n\n\tunsigned int nformats;\n\tconst struct uvc_format *formats;\n\n\tstruct uvc_streaming_control ctrl;\n\tconst struct uvc_format *def_format;\n\tconst struct uvc_format *cur_format;\n\tconst struct uvc_frame *cur_frame;\n\n\t \n\tstruct mutex mutex;\n\n\t \n\tunsigned int frozen : 1;\n\tstruct uvc_video_queue queue;\n\tstruct workqueue_struct *async_wq;\n\tvoid (*decode)(struct uvc_urb *uvc_urb, struct uvc_buffer *buf,\n\t\t       struct uvc_buffer *meta_buf);\n\n\tstruct {\n\t\tstruct video_device vdev;\n\t\tstruct uvc_video_queue queue;\n\t\tu32 format;\n\t} meta;\n\n\t \n\tstruct {\n\t\tu8 header[256];\n\t\tunsigned int header_size;\n\t\tint skip_payload;\n\t\tu32 payload_size;\n\t\tu32 max_payload_size;\n\t} bulk;\n\n\tstruct uvc_urb uvc_urb[UVC_URBS];\n\tunsigned int urb_size;\n\n\tu32 sequence;\n\tu8 last_fid;\n\n\t \n\tstruct dentry *debugfs_dir;\n\tstruct {\n\t\tstruct uvc_stats_frame frame;\n\t\tstruct uvc_stats_stream stream;\n\t} stats;\n\n\t \n\tstruct uvc_clock {\n\t\tstruct uvc_clock_sample {\n\t\t\tu32 dev_stc;\n\t\t\tu16 dev_sof;\n\t\t\tu16 host_sof;\n\t\t\tktime_t host_time;\n\t\t} *samples;\n\n\t\tunsigned int head;\n\t\tunsigned int count;\n\t\tunsigned int size;\n\n\t\tu16 last_sof;\n\t\tu16 sof_offset;\n\n\t\tu8 last_scr[6];\n\n\t\tspinlock_t lock;\n\t} clock;\n};\n\n#define for_each_uvc_urb(uvc_urb, uvc_streaming) \\\n\tfor ((uvc_urb) = &(uvc_streaming)->uvc_urb[0]; \\\n\t     (uvc_urb) < &(uvc_streaming)->uvc_urb[UVC_URBS]; \\\n\t     ++(uvc_urb))\n\nstatic inline u32 uvc_urb_index(const struct uvc_urb *uvc_urb)\n{\n\treturn uvc_urb - &uvc_urb->stream->uvc_urb[0];\n}\n\nstruct uvc_device_info {\n\tu32\tquirks;\n\tu32\tmeta_format;\n\tu16\tuvc_version;\n\tconst struct uvc_control_mapping **mappings;\n};\n\nstruct uvc_status_streaming {\n\tu8\tbutton;\n} __packed;\n\nstruct uvc_status_control {\n\tu8\tbSelector;\n\tu8\tbAttribute;\n\tu8\tbValue[11];\n} __packed;\n\nstruct uvc_status {\n\tu8\tbStatusType;\n\tu8\tbOriginator;\n\tu8\tbEvent;\n\tunion {\n\t\tstruct uvc_status_control control;\n\t\tstruct uvc_status_streaming streaming;\n\t};\n} __packed;\n\nstruct uvc_device {\n\tstruct usb_device *udev;\n\tstruct usb_interface *intf;\n\tunsigned long warnings;\n\tu32 quirks;\n\tint intfnum;\n\tchar name[32];\n\n\tconst struct uvc_device_info *info;\n\n\tstruct mutex lock;\t\t \n\tunsigned int users;\n\tatomic_t nmappings;\n\n\t \n#ifdef CONFIG_MEDIA_CONTROLLER\n\tstruct media_device mdev;\n#endif\n\tstruct v4l2_device vdev;\n\tu16 uvc_version;\n\tu32 clock_frequency;\n\n\tstruct list_head entities;\n\tstruct list_head chains;\n\n\t \n\tstruct list_head streams;\n\tstruct kref ref;\n\n\t \n\tstruct usb_host_endpoint *int_ep;\n\tstruct urb *int_urb;\n\tstruct uvc_status *status;\n\tbool flush_status;\n\n\tstruct input_dev *input;\n\tchar input_phys[64];\n\n\tstruct uvc_ctrl_work {\n\t\tstruct work_struct work;\n\t\tstruct urb *urb;\n\t\tstruct uvc_video_chain *chain;\n\t\tstruct uvc_control *ctrl;\n\t\tconst void *data;\n\t} async_ctrl;\n\n\tstruct uvc_entity *gpio_unit;\n};\n\nenum uvc_handle_state {\n\tUVC_HANDLE_PASSIVE\t= 0,\n\tUVC_HANDLE_ACTIVE\t= 1,\n};\n\nstruct uvc_fh {\n\tstruct v4l2_fh vfh;\n\tstruct uvc_video_chain *chain;\n\tstruct uvc_streaming *stream;\n\tenum uvc_handle_state state;\n};\n\nstruct uvc_driver {\n\tstruct usb_driver driver;\n};\n\n \n\n#define UVC_DBG_PROBE\t\t(1 << 0)\n#define UVC_DBG_DESCR\t\t(1 << 1)\n#define UVC_DBG_CONTROL\t\t(1 << 2)\n#define UVC_DBG_FORMAT\t\t(1 << 3)\n#define UVC_DBG_CAPTURE\t\t(1 << 4)\n#define UVC_DBG_CALLS\t\t(1 << 5)\n#define UVC_DBG_FRAME\t\t(1 << 7)\n#define UVC_DBG_SUSPEND\t\t(1 << 8)\n#define UVC_DBG_STATUS\t\t(1 << 9)\n#define UVC_DBG_VIDEO\t\t(1 << 10)\n#define UVC_DBG_STATS\t\t(1 << 11)\n#define UVC_DBG_CLOCK\t\t(1 << 12)\n\n#define UVC_WARN_MINMAX\t\t0\n#define UVC_WARN_PROBE_DEF\t1\n#define UVC_WARN_XU_GET_RES\t2\n\nextern unsigned int uvc_clock_param;\nextern unsigned int uvc_no_drop_param;\nextern unsigned int uvc_dbg_param;\nextern unsigned int uvc_timeout_param;\nextern unsigned int uvc_hw_timestamps_param;\n\n#define uvc_dbg(_dev, flag, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (uvc_dbg_param & UVC_DBG_##flag)\t\t\t\t\\\n\t\tdev_printk(KERN_DEBUG, &(_dev)->udev->dev, fmt,\t\t\\\n\t\t\t   ##__VA_ARGS__);\t\t\t\t\\\n} while (0)\n\n#define uvc_dbg_cont(flag, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (uvc_dbg_param & UVC_DBG_##flag)\t\t\t\t\\\n\t\tpr_cont(fmt, ##__VA_ARGS__);\t\t\t\t\\\n} while (0)\n\n#define uvc_warn_once(_dev, warn, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (!test_and_set_bit(warn, &(_dev)->warnings))\t\t\t\\\n\t\tdev_info(&(_dev)->udev->dev, fmt, ##__VA_ARGS__);\t\\\n} while (0)\n\n \n\n \nextern struct uvc_driver uvc_driver;\n\nstruct uvc_entity *uvc_entity_by_id(struct uvc_device *dev, int id);\n\n \nint uvc_queue_init(struct uvc_video_queue *queue, enum v4l2_buf_type type,\n\t\t   int drop_corrupted);\nvoid uvc_queue_release(struct uvc_video_queue *queue);\nint uvc_request_buffers(struct uvc_video_queue *queue,\n\t\t\tstruct v4l2_requestbuffers *rb);\nint uvc_query_buffer(struct uvc_video_queue *queue,\n\t\t     struct v4l2_buffer *v4l2_buf);\nint uvc_create_buffers(struct uvc_video_queue *queue,\n\t\t       struct v4l2_create_buffers *v4l2_cb);\nint uvc_queue_buffer(struct uvc_video_queue *queue,\n\t\t     struct media_device *mdev,\n\t\t     struct v4l2_buffer *v4l2_buf);\nint uvc_export_buffer(struct uvc_video_queue *queue,\n\t\t      struct v4l2_exportbuffer *exp);\nint uvc_dequeue_buffer(struct uvc_video_queue *queue,\n\t\t       struct v4l2_buffer *v4l2_buf, int nonblocking);\nint uvc_queue_streamon(struct uvc_video_queue *queue, enum v4l2_buf_type type);\nint uvc_queue_streamoff(struct uvc_video_queue *queue, enum v4l2_buf_type type);\nvoid uvc_queue_cancel(struct uvc_video_queue *queue, int disconnect);\nstruct uvc_buffer *uvc_queue_next_buffer(struct uvc_video_queue *queue,\n\t\t\t\t\t struct uvc_buffer *buf);\nstruct uvc_buffer *uvc_queue_get_current_buffer(struct uvc_video_queue *queue);\nvoid uvc_queue_buffer_release(struct uvc_buffer *buf);\nint uvc_queue_mmap(struct uvc_video_queue *queue,\n\t\t   struct vm_area_struct *vma);\n__poll_t uvc_queue_poll(struct uvc_video_queue *queue, struct file *file,\n\t\t\tpoll_table *wait);\n#ifndef CONFIG_MMU\nunsigned long uvc_queue_get_unmapped_area(struct uvc_video_queue *queue,\n\t\t\t\t\t  unsigned long pgoff);\n#endif\nint uvc_queue_allocated(struct uvc_video_queue *queue);\nstatic inline int uvc_queue_streaming(struct uvc_video_queue *queue)\n{\n\treturn vb2_is_streaming(&queue->queue);\n}\n\nstatic inline struct uvc_streaming *\nuvc_queue_to_stream(struct uvc_video_queue *queue)\n{\n\treturn container_of(queue, struct uvc_streaming, queue);\n}\n\n \nextern const struct v4l2_ioctl_ops uvc_ioctl_ops;\nextern const struct v4l2_file_operations uvc_fops;\n\n \nint uvc_mc_register_entities(struct uvc_video_chain *chain);\nvoid uvc_mc_cleanup_entity(struct uvc_entity *entity);\n\n \nint uvc_video_init(struct uvc_streaming *stream);\nint uvc_video_suspend(struct uvc_streaming *stream);\nint uvc_video_resume(struct uvc_streaming *stream, int reset);\nint uvc_video_start_streaming(struct uvc_streaming *stream);\nvoid uvc_video_stop_streaming(struct uvc_streaming *stream);\nint uvc_probe_video(struct uvc_streaming *stream,\n\t\t    struct uvc_streaming_control *probe);\nint uvc_query_ctrl(struct uvc_device *dev, u8 query, u8 unit,\n\t\t   u8 intfnum, u8 cs, void *data, u16 size);\nvoid uvc_video_clock_update(struct uvc_streaming *stream,\n\t\t\t    struct vb2_v4l2_buffer *vbuf,\n\t\t\t    struct uvc_buffer *buf);\nint uvc_meta_register(struct uvc_streaming *stream);\n\nint uvc_register_video_device(struct uvc_device *dev,\n\t\t\t      struct uvc_streaming *stream,\n\t\t\t      struct video_device *vdev,\n\t\t\t      struct uvc_video_queue *queue,\n\t\t\t      enum v4l2_buf_type type,\n\t\t\t      const struct v4l2_file_operations *fops,\n\t\t\t      const struct v4l2_ioctl_ops *ioctl_ops);\n\n \nint uvc_status_init(struct uvc_device *dev);\nvoid uvc_status_unregister(struct uvc_device *dev);\nvoid uvc_status_cleanup(struct uvc_device *dev);\nint uvc_status_start(struct uvc_device *dev, gfp_t flags);\nvoid uvc_status_stop(struct uvc_device *dev);\n\n \nextern const struct uvc_control_mapping uvc_ctrl_power_line_mapping_limited;\nextern const struct uvc_control_mapping uvc_ctrl_power_line_mapping_uvc11;\nextern const struct v4l2_subscribed_event_ops uvc_ctrl_sub_ev_ops;\n\nint uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,\n\t\t\tstruct v4l2_queryctrl *v4l2_ctrl);\nint uvc_query_v4l2_menu(struct uvc_video_chain *chain,\n\t\t\tstruct v4l2_querymenu *query_menu);\n\nint uvc_ctrl_add_mapping(struct uvc_video_chain *chain,\n\t\t\t const struct uvc_control_mapping *mapping);\nint uvc_ctrl_init_device(struct uvc_device *dev);\nvoid uvc_ctrl_cleanup_device(struct uvc_device *dev);\nint uvc_ctrl_restore_values(struct uvc_device *dev);\nbool uvc_ctrl_status_event_async(struct urb *urb, struct uvc_video_chain *chain,\n\t\t\t\t struct uvc_control *ctrl, const u8 *data);\nvoid uvc_ctrl_status_event(struct uvc_video_chain *chain,\n\t\t\t   struct uvc_control *ctrl, const u8 *data);\n\nint uvc_ctrl_begin(struct uvc_video_chain *chain);\nint __uvc_ctrl_commit(struct uvc_fh *handle, int rollback,\n\t\t      struct v4l2_ext_controls *ctrls);\nstatic inline int uvc_ctrl_commit(struct uvc_fh *handle,\n\t\t\t\t  struct v4l2_ext_controls *ctrls)\n{\n\treturn __uvc_ctrl_commit(handle, 0, ctrls);\n}\nstatic inline int uvc_ctrl_rollback(struct uvc_fh *handle)\n{\n\treturn __uvc_ctrl_commit(handle, 1, NULL);\n}\n\nint uvc_ctrl_get(struct uvc_video_chain *chain, struct v4l2_ext_control *xctrl);\nint uvc_ctrl_set(struct uvc_fh *handle, struct v4l2_ext_control *xctrl);\nint uvc_ctrl_is_accessible(struct uvc_video_chain *chain, u32 v4l2_id,\n\t\t\t   const struct v4l2_ext_controls *ctrls,\n\t\t\t   unsigned long ioctl);\n\nint uvc_xu_ctrl_query(struct uvc_video_chain *chain,\n\t\t      struct uvc_xu_control_query *xqry);\n\n \nstruct usb_host_endpoint *uvc_find_endpoint(struct usb_host_interface *alts,\n\t\t\t\t\t    u8 epaddr);\nu16 uvc_endpoint_max_bpi(struct usb_device *dev, struct usb_host_endpoint *ep);\n\n \nvoid uvc_video_decode_isight(struct uvc_urb *uvc_urb,\n\t\t\t     struct uvc_buffer *buf,\n\t\t\t     struct uvc_buffer *meta_buf);\n\n \nvoid uvc_debugfs_init(void);\nvoid uvc_debugfs_cleanup(void);\nvoid uvc_debugfs_init_stream(struct uvc_streaming *stream);\nvoid uvc_debugfs_cleanup_stream(struct uvc_streaming *stream);\n\nsize_t uvc_video_stats_dump(struct uvc_streaming *stream, char *buf,\n\t\t\t    size_t size);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}