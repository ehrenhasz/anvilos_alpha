{
  "module_name": "uvc_metadata.c",
  "hash_id": "4f3bede231a0b31610a86de936d28025e6373ddc9640452fe31d23a6b360a9e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/uvc/uvc_metadata.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-vmalloc.h>\n\n#include \"uvcvideo.h\"\n\n \n\nstatic int uvc_meta_v4l2_querycap(struct file *file, void *fh,\n\t\t\t\t  struct v4l2_capability *cap)\n{\n\tstruct v4l2_fh *vfh = file->private_data;\n\tstruct uvc_streaming *stream = video_get_drvdata(vfh->vdev);\n\tstruct uvc_video_chain *chain = stream->chain;\n\n\tstrscpy(cap->driver, \"uvcvideo\", sizeof(cap->driver));\n\tstrscpy(cap->card, stream->dev->name, sizeof(cap->card));\n\tusb_make_path(stream->dev->udev, cap->bus_info, sizeof(cap->bus_info));\n\tcap->capabilities = V4L2_CAP_DEVICE_CAPS | V4L2_CAP_STREAMING\n\t\t\t  | chain->caps;\n\n\treturn 0;\n}\n\nstatic int uvc_meta_v4l2_get_format(struct file *file, void *fh,\n\t\t\t\t    struct v4l2_format *format)\n{\n\tstruct v4l2_fh *vfh = file->private_data;\n\tstruct uvc_streaming *stream = video_get_drvdata(vfh->vdev);\n\tstruct v4l2_meta_format *fmt = &format->fmt.meta;\n\n\tif (format->type != vfh->vdev->queue->type)\n\t\treturn -EINVAL;\n\n\tmemset(fmt, 0, sizeof(*fmt));\n\n\tfmt->dataformat = stream->meta.format;\n\tfmt->buffersize = UVC_METADATA_BUF_SIZE;\n\n\treturn 0;\n}\n\nstatic int uvc_meta_v4l2_try_format(struct file *file, void *fh,\n\t\t\t\t    struct v4l2_format *format)\n{\n\tstruct v4l2_fh *vfh = file->private_data;\n\tstruct uvc_streaming *stream = video_get_drvdata(vfh->vdev);\n\tstruct uvc_device *dev = stream->dev;\n\tstruct v4l2_meta_format *fmt = &format->fmt.meta;\n\tu32 fmeta = fmt->dataformat;\n\n\tif (format->type != vfh->vdev->queue->type)\n\t\treturn -EINVAL;\n\n\tmemset(fmt, 0, sizeof(*fmt));\n\n\tfmt->dataformat = fmeta == dev->info->meta_format\n\t\t\t? fmeta : V4L2_META_FMT_UVC;\n\tfmt->buffersize = UVC_METADATA_BUF_SIZE;\n\n\treturn 0;\n}\n\nstatic int uvc_meta_v4l2_set_format(struct file *file, void *fh,\n\t\t\t\t    struct v4l2_format *format)\n{\n\tstruct v4l2_fh *vfh = file->private_data;\n\tstruct uvc_streaming *stream = video_get_drvdata(vfh->vdev);\n\tstruct v4l2_meta_format *fmt = &format->fmt.meta;\n\tint ret;\n\n\tret = uvc_meta_v4l2_try_format(file, fh, format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmutex_lock(&stream->mutex);\n\n\tif (uvc_queue_allocated(&stream->queue))\n\t\tret = -EBUSY;\n\telse\n\t\tstream->meta.format = fmt->dataformat;\n\n\tmutex_unlock(&stream->mutex);\n\n\treturn ret;\n}\n\nstatic int uvc_meta_v4l2_enum_formats(struct file *file, void *fh,\n\t\t\t\t      struct v4l2_fmtdesc *fdesc)\n{\n\tstruct v4l2_fh *vfh = file->private_data;\n\tstruct uvc_streaming *stream = video_get_drvdata(vfh->vdev);\n\tstruct uvc_device *dev = stream->dev;\n\tu32 index = fdesc->index;\n\n\tif (fdesc->type != vfh->vdev->queue->type ||\n\t    index > 1U || (index && !dev->info->meta_format))\n\t\treturn -EINVAL;\n\n\tmemset(fdesc, 0, sizeof(*fdesc));\n\n\tfdesc->type = vfh->vdev->queue->type;\n\tfdesc->index = index;\n\tfdesc->pixelformat = index ? dev->info->meta_format : V4L2_META_FMT_UVC;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops uvc_meta_ioctl_ops = {\n\t.vidioc_querycap\t\t= uvc_meta_v4l2_querycap,\n\t.vidioc_g_fmt_meta_cap\t\t= uvc_meta_v4l2_get_format,\n\t.vidioc_s_fmt_meta_cap\t\t= uvc_meta_v4l2_set_format,\n\t.vidioc_try_fmt_meta_cap\t= uvc_meta_v4l2_try_format,\n\t.vidioc_enum_fmt_meta_cap\t= uvc_meta_v4l2_enum_formats,\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n};\n\n \n\nstatic const struct v4l2_file_operations uvc_meta_fops = {\n\t.owner = THIS_MODULE,\n\t.unlocked_ioctl = video_ioctl2,\n\t.open = v4l2_fh_open,\n\t.release = vb2_fop_release,\n\t.poll = vb2_fop_poll,\n\t.mmap = vb2_fop_mmap,\n};\n\nint uvc_meta_register(struct uvc_streaming *stream)\n{\n\tstruct uvc_device *dev = stream->dev;\n\tstruct video_device *vdev = &stream->meta.vdev;\n\tstruct uvc_video_queue *queue = &stream->meta.queue;\n\n\tstream->meta.format = V4L2_META_FMT_UVC;\n\n\t \n\tvdev->queue = &queue->queue;\n\n\treturn uvc_register_video_device(dev, stream, vdev, queue,\n\t\t\t\t\t V4L2_BUF_TYPE_META_CAPTURE,\n\t\t\t\t\t &uvc_meta_fops, &uvc_meta_ioctl_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}