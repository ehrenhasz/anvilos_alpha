{
  "module_name": "uvc_v4l2.c",
  "hash_id": "aace2de839358b2f65223d19777d2ed6a52e2eea8c082e428de3133ec07db074",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/uvc/uvc_v4l2.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/compat.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/videodev2.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/wait.h>\n#include <linux/atomic.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n\n#include \"uvcvideo.h\"\n\nstatic int uvc_control_add_xu_mapping(struct uvc_video_chain *chain,\n\t\t\t\t      struct uvc_control_mapping *map,\n\t\t\t\t      const struct uvc_xu_control_mapping *xmap)\n{\n\tunsigned int i;\n\tsize_t size;\n\tint ret;\n\n\t \n\tif (xmap->menu_count == 0 ||\n\t    xmap->menu_count > UVC_MAX_CONTROL_MENU_ENTRIES)\n\t\treturn -EINVAL;\n\n\tmap->menu_names = NULL;\n\tmap->menu_mapping = NULL;\n\n\tmap->menu_mask = GENMASK(xmap->menu_count - 1, 0);\n\n\tsize = xmap->menu_count * sizeof(*map->menu_mapping);\n\tmap->menu_mapping = kzalloc(size, GFP_KERNEL);\n\tif (!map->menu_mapping) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < xmap->menu_count ; i++) {\n\t\tif (copy_from_user((u32 *)&map->menu_mapping[i],\n\t\t\t\t   &xmap->menu_info[i].value,\n\t\t\t\t   sizeof(map->menu_mapping[i]))) {\n\t\t\tret = -EACCES;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tif (!v4l2_ctrl_get_menu(map->id)) {\n\t\tsize = xmap->menu_count * sizeof(map->menu_names[0]);\n\t\tmap->menu_names = kzalloc(size, GFP_KERNEL);\n\t\tif (!map->menu_names) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\n\t\tfor (i = 0; i < xmap->menu_count ; i++) {\n\t\t\t \n\t\t\tif (copy_from_user((char *)map->menu_names[i],\n\t\t\t\t\t   xmap->menu_info[i].name,\n\t\t\t\t\t   sizeof(map->menu_names[i]) - 1)) {\n\t\t\t\tret = -EACCES;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = uvc_ctrl_add_mapping(chain, map);\n\ndone:\n\tkfree(map->menu_names);\n\tmap->menu_names = NULL;\n\tkfree(map->menu_mapping);\n\tmap->menu_mapping = NULL;\n\n\treturn ret;\n}\n\n \nstatic int uvc_ioctl_xu_ctrl_map(struct uvc_video_chain *chain,\n\t\t\t\t struct uvc_xu_control_mapping *xmap)\n{\n\tstruct uvc_control_mapping *map;\n\tint ret;\n\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (map == NULL)\n\t\treturn -ENOMEM;\n\n\tmap->id = xmap->id;\n\t \n\tif (v4l2_ctrl_get_name(map->id) == NULL) {\n\t\tif (xmap->name[0] == '\\0') {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_map;\n\t\t}\n\t\txmap->name[sizeof(xmap->name) - 1] = '\\0';\n\t\tmap->name = xmap->name;\n\t}\n\tmemcpy(map->entity, xmap->entity, sizeof(map->entity));\n\tmap->selector = xmap->selector;\n\tmap->size = xmap->size;\n\tmap->offset = xmap->offset;\n\tmap->v4l2_type = xmap->v4l2_type;\n\tmap->data_type = xmap->data_type;\n\n\tswitch (xmap->v4l2_type) {\n\tcase V4L2_CTRL_TYPE_INTEGER:\n\tcase V4L2_CTRL_TYPE_BOOLEAN:\n\tcase V4L2_CTRL_TYPE_BUTTON:\n\t\tret = uvc_ctrl_add_mapping(chain, map);\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_MENU:\n\t\tret = uvc_control_add_xu_mapping(chain, map, xmap);\n\t\tbreak;\n\n\tdefault:\n\t\tuvc_dbg(chain->dev, CONTROL,\n\t\t\t\"Unsupported V4L2 control type %u\\n\", xmap->v4l2_type);\n\t\tret = -ENOTTY;\n\t\tbreak;\n\t}\n\nfree_map:\n\tkfree(map);\n\n\treturn ret;\n}\n\n \n\n \nstatic u32 uvc_try_frame_interval(const struct uvc_frame *frame, u32 interval)\n{\n\tunsigned int i;\n\n\tif (frame->bFrameIntervalType) {\n\t\tu32 best = -1, dist;\n\n\t\tfor (i = 0; i < frame->bFrameIntervalType; ++i) {\n\t\t\tdist = interval > frame->dwFrameInterval[i]\n\t\t\t     ? interval - frame->dwFrameInterval[i]\n\t\t\t     : frame->dwFrameInterval[i] - interval;\n\n\t\t\tif (dist > best)\n\t\t\t\tbreak;\n\n\t\t\tbest = dist;\n\t\t}\n\n\t\tinterval = frame->dwFrameInterval[i-1];\n\t} else {\n\t\tconst u32 min = frame->dwFrameInterval[0];\n\t\tconst u32 max = frame->dwFrameInterval[1];\n\t\tconst u32 step = frame->dwFrameInterval[2];\n\n\t\tinterval = min + (interval - min + step/2) / step * step;\n\t\tif (interval > max)\n\t\t\tinterval = max;\n\t}\n\n\treturn interval;\n}\n\nstatic u32 uvc_v4l2_get_bytesperline(const struct uvc_format *format,\n\tconst struct uvc_frame *frame)\n{\n\tswitch (format->fcc) {\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_YVU420:\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_M420:\n\t\treturn frame->wWidth;\n\n\tdefault:\n\t\treturn format->bpp * frame->wWidth / 8;\n\t}\n}\n\nstatic int uvc_v4l2_try_format(struct uvc_streaming *stream,\n\tstruct v4l2_format *fmt, struct uvc_streaming_control *probe,\n\tconst struct uvc_format **uvc_format,\n\tconst struct uvc_frame **uvc_frame)\n{\n\tconst struct uvc_format *format = NULL;\n\tconst struct uvc_frame *frame = NULL;\n\tu16 rw, rh;\n\tunsigned int d, maxd;\n\tunsigned int i;\n\tu32 interval;\n\tint ret = 0;\n\tu8 *fcc;\n\n\tif (fmt->type != stream->type)\n\t\treturn -EINVAL;\n\n\tfcc = (u8 *)&fmt->fmt.pix.pixelformat;\n\tuvc_dbg(stream->dev, FORMAT, \"Trying format 0x%08x (%c%c%c%c): %ux%u\\n\",\n\t\tfmt->fmt.pix.pixelformat,\n\t\tfcc[0], fcc[1], fcc[2], fcc[3],\n\t\tfmt->fmt.pix.width, fmt->fmt.pix.height);\n\n\t \n\tfor (i = 0; i < stream->nformats; ++i) {\n\t\tformat = &stream->formats[i];\n\t\tif (format->fcc == fmt->fmt.pix.pixelformat)\n\t\t\tbreak;\n\t}\n\n\tif (i == stream->nformats) {\n\t\tformat = stream->def_format;\n\t\tfmt->fmt.pix.pixelformat = format->fcc;\n\t}\n\n\t \n\trw = fmt->fmt.pix.width;\n\trh = fmt->fmt.pix.height;\n\tmaxd = (unsigned int)-1;\n\n\tfor (i = 0; i < format->nframes; ++i) {\n\t\tu16 w = format->frames[i].wWidth;\n\t\tu16 h = format->frames[i].wHeight;\n\n\t\td = min(w, rw) * min(h, rh);\n\t\td = w*h + rw*rh - 2*d;\n\t\tif (d < maxd) {\n\t\t\tmaxd = d;\n\t\t\tframe = &format->frames[i];\n\t\t}\n\n\t\tif (maxd == 0)\n\t\t\tbreak;\n\t}\n\n\tif (frame == NULL) {\n\t\tuvc_dbg(stream->dev, FORMAT, \"Unsupported size %ux%u\\n\",\n\t\t\tfmt->fmt.pix.width, fmt->fmt.pix.height);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tinterval = frame->dwDefaultFrameInterval;\n\tuvc_dbg(stream->dev, FORMAT,\n\t\t\"Using default frame interval %u.%u us (%u.%u fps)\\n\",\n\t\tinterval / 10, interval % 10, 10000000 / interval,\n\t\t(100000000 / interval) % 10);\n\n\t \n\tmemset(probe, 0, sizeof(*probe));\n\tprobe->bmHint = 1;\t \n\tprobe->bFormatIndex = format->index;\n\tprobe->bFrameIndex = frame->bFrameIndex;\n\tprobe->dwFrameInterval = uvc_try_frame_interval(frame, interval);\n\t \n\tmutex_lock(&stream->mutex);\n\tif (stream->dev->quirks & UVC_QUIRK_PROBE_EXTRAFIELDS)\n\t\tprobe->dwMaxVideoFrameSize =\n\t\t\tstream->ctrl.dwMaxVideoFrameSize;\n\n\t \n\tret = uvc_probe_video(stream, probe);\n\tmutex_unlock(&stream->mutex);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < stream->nformats; ++i) {\n\t\tif (probe->bFormatIndex == stream->formats[i].index) {\n\t\t\tformat = &stream->formats[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == stream->nformats)\n\t\tuvc_dbg(stream->dev, FORMAT,\n\t\t\t\"Unknown bFormatIndex %u, using default\\n\",\n\t\t\tprobe->bFormatIndex);\n\n\tfor (i = 0; i < format->nframes; ++i) {\n\t\tif (probe->bFrameIndex == format->frames[i].bFrameIndex) {\n\t\t\tframe = &format->frames[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == format->nframes)\n\t\tuvc_dbg(stream->dev, FORMAT,\n\t\t\t\"Unknown bFrameIndex %u, using default\\n\",\n\t\t\tprobe->bFrameIndex);\n\n\tfmt->fmt.pix.width = frame->wWidth;\n\tfmt->fmt.pix.height = frame->wHeight;\n\tfmt->fmt.pix.field = V4L2_FIELD_NONE;\n\tfmt->fmt.pix.bytesperline = uvc_v4l2_get_bytesperline(format, frame);\n\tfmt->fmt.pix.sizeimage = probe->dwMaxVideoFrameSize;\n\tfmt->fmt.pix.pixelformat = format->fcc;\n\tfmt->fmt.pix.colorspace = format->colorspace;\n\tfmt->fmt.pix.xfer_func = format->xfer_func;\n\tfmt->fmt.pix.ycbcr_enc = format->ycbcr_enc;\n\n\tif (uvc_format != NULL)\n\t\t*uvc_format = format;\n\tif (uvc_frame != NULL)\n\t\t*uvc_frame = frame;\n\n\treturn ret;\n}\n\nstatic int uvc_v4l2_get_format(struct uvc_streaming *stream,\n\tstruct v4l2_format *fmt)\n{\n\tconst struct uvc_format *format;\n\tconst struct uvc_frame *frame;\n\tint ret = 0;\n\n\tif (fmt->type != stream->type)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&stream->mutex);\n\tformat = stream->cur_format;\n\tframe = stream->cur_frame;\n\n\tif (format == NULL || frame == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tfmt->fmt.pix.pixelformat = format->fcc;\n\tfmt->fmt.pix.width = frame->wWidth;\n\tfmt->fmt.pix.height = frame->wHeight;\n\tfmt->fmt.pix.field = V4L2_FIELD_NONE;\n\tfmt->fmt.pix.bytesperline = uvc_v4l2_get_bytesperline(format, frame);\n\tfmt->fmt.pix.sizeimage = stream->ctrl.dwMaxVideoFrameSize;\n\tfmt->fmt.pix.colorspace = format->colorspace;\n\tfmt->fmt.pix.xfer_func = format->xfer_func;\n\tfmt->fmt.pix.ycbcr_enc = format->ycbcr_enc;\n\ndone:\n\tmutex_unlock(&stream->mutex);\n\treturn ret;\n}\n\nstatic int uvc_v4l2_set_format(struct uvc_streaming *stream,\n\tstruct v4l2_format *fmt)\n{\n\tstruct uvc_streaming_control probe;\n\tconst struct uvc_format *format;\n\tconst struct uvc_frame *frame;\n\tint ret;\n\n\tif (fmt->type != stream->type)\n\t\treturn -EINVAL;\n\n\tret = uvc_v4l2_try_format(stream, fmt, &probe, &format, &frame);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&stream->mutex);\n\n\tif (uvc_queue_allocated(&stream->queue)) {\n\t\tret = -EBUSY;\n\t\tgoto done;\n\t}\n\n\tstream->ctrl = probe;\n\tstream->cur_format = format;\n\tstream->cur_frame = frame;\n\ndone:\n\tmutex_unlock(&stream->mutex);\n\treturn ret;\n}\n\nstatic int uvc_v4l2_get_streamparm(struct uvc_streaming *stream,\n\t\tstruct v4l2_streamparm *parm)\n{\n\tu32 numerator, denominator;\n\n\tif (parm->type != stream->type)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&stream->mutex);\n\tnumerator = stream->ctrl.dwFrameInterval;\n\tmutex_unlock(&stream->mutex);\n\n\tdenominator = 10000000;\n\tv4l2_simplify_fraction(&numerator, &denominator, 8, 333);\n\n\tmemset(parm, 0, sizeof(*parm));\n\tparm->type = stream->type;\n\n\tif (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tparm->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\n\t\tparm->parm.capture.capturemode = 0;\n\t\tparm->parm.capture.timeperframe.numerator = numerator;\n\t\tparm->parm.capture.timeperframe.denominator = denominator;\n\t\tparm->parm.capture.extendedmode = 0;\n\t\tparm->parm.capture.readbuffers = 0;\n\t} else {\n\t\tparm->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\n\t\tparm->parm.output.outputmode = 0;\n\t\tparm->parm.output.timeperframe.numerator = numerator;\n\t\tparm->parm.output.timeperframe.denominator = denominator;\n\t}\n\n\treturn 0;\n}\n\nstatic int uvc_v4l2_set_streamparm(struct uvc_streaming *stream,\n\t\tstruct v4l2_streamparm *parm)\n{\n\tstruct uvc_streaming_control probe;\n\tstruct v4l2_fract timeperframe;\n\tconst struct uvc_format *format;\n\tconst struct uvc_frame *frame;\n\tu32 interval, maxd;\n\tunsigned int i;\n\tint ret;\n\n\tif (parm->type != stream->type)\n\t\treturn -EINVAL;\n\n\tif (parm->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\ttimeperframe = parm->parm.capture.timeperframe;\n\telse\n\t\ttimeperframe = parm->parm.output.timeperframe;\n\n\tinterval = v4l2_fraction_to_interval(timeperframe.numerator,\n\t\ttimeperframe.denominator);\n\tuvc_dbg(stream->dev, FORMAT, \"Setting frame interval to %u/%u (%u)\\n\",\n\t\ttimeperframe.numerator, timeperframe.denominator, interval);\n\n\tmutex_lock(&stream->mutex);\n\n\tif (uvc_queue_streaming(&stream->queue)) {\n\t\tmutex_unlock(&stream->mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tformat = stream->cur_format;\n\tframe = stream->cur_frame;\n\tprobe = stream->ctrl;\n\tprobe.dwFrameInterval = uvc_try_frame_interval(frame, interval);\n\tmaxd = abs((s32)probe.dwFrameInterval - interval);\n\n\t \n\tfor (i = 0; i < format->nframes && maxd != 0; i++) {\n\t\tu32 d, ival;\n\n\t\tif (&format->frames[i] == stream->cur_frame)\n\t\t\tcontinue;\n\n\t\tif (format->frames[i].wWidth != stream->cur_frame->wWidth ||\n\t\t    format->frames[i].wHeight != stream->cur_frame->wHeight)\n\t\t\tcontinue;\n\n\t\tival = uvc_try_frame_interval(&format->frames[i], interval);\n\t\td = abs((s32)ival - interval);\n\t\tif (d >= maxd)\n\t\t\tcontinue;\n\n\t\tframe = &format->frames[i];\n\t\tprobe.bFrameIndex = frame->bFrameIndex;\n\t\tprobe.dwFrameInterval = ival;\n\t\tmaxd = d;\n\t}\n\n\t \n\tret = uvc_probe_video(stream, &probe);\n\tif (ret < 0) {\n\t\tmutex_unlock(&stream->mutex);\n\t\treturn ret;\n\t}\n\n\tstream->ctrl = probe;\n\tstream->cur_frame = frame;\n\tmutex_unlock(&stream->mutex);\n\n\t \n\ttimeperframe.numerator = probe.dwFrameInterval;\n\ttimeperframe.denominator = 10000000;\n\tv4l2_simplify_fraction(&timeperframe.numerator,\n\t\t&timeperframe.denominator, 8, 333);\n\n\tif (parm->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tparm->parm.capture.timeperframe = timeperframe;\n\t\tparm->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\n\t} else {\n\t\tparm->parm.output.timeperframe = timeperframe;\n\t\tparm->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic int uvc_acquire_privileges(struct uvc_fh *handle)\n{\n\t \n\tif (handle->state == UVC_HANDLE_ACTIVE)\n\t\treturn 0;\n\n\t \n\tif (atomic_inc_return(&handle->stream->active) != 1) {\n\t\tatomic_dec(&handle->stream->active);\n\t\treturn -EBUSY;\n\t}\n\n\thandle->state = UVC_HANDLE_ACTIVE;\n\treturn 0;\n}\n\nstatic void uvc_dismiss_privileges(struct uvc_fh *handle)\n{\n\tif (handle->state == UVC_HANDLE_ACTIVE)\n\t\tatomic_dec(&handle->stream->active);\n\n\thandle->state = UVC_HANDLE_PASSIVE;\n}\n\nstatic int uvc_has_privileges(struct uvc_fh *handle)\n{\n\treturn handle->state == UVC_HANDLE_ACTIVE;\n}\n\n \n\nstatic int uvc_v4l2_open(struct file *file)\n{\n\tstruct uvc_streaming *stream;\n\tstruct uvc_fh *handle;\n\tint ret = 0;\n\n\tstream = video_drvdata(file);\n\tuvc_dbg(stream->dev, CALLS, \"%s\\n\", __func__);\n\n\tret = usb_autopm_get_interface(stream->dev->intf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\thandle = kzalloc(sizeof(*handle), GFP_KERNEL);\n\tif (handle == NULL) {\n\t\tusb_autopm_put_interface(stream->dev->intf);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&stream->dev->lock);\n\tif (stream->dev->users == 0) {\n\t\tret = uvc_status_start(stream->dev, GFP_KERNEL);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&stream->dev->lock);\n\t\t\tusb_autopm_put_interface(stream->dev->intf);\n\t\t\tkfree(handle);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tstream->dev->users++;\n\tmutex_unlock(&stream->dev->lock);\n\n\tv4l2_fh_init(&handle->vfh, &stream->vdev);\n\tv4l2_fh_add(&handle->vfh);\n\thandle->chain = stream->chain;\n\thandle->stream = stream;\n\thandle->state = UVC_HANDLE_PASSIVE;\n\tfile->private_data = handle;\n\n\treturn 0;\n}\n\nstatic int uvc_v4l2_release(struct file *file)\n{\n\tstruct uvc_fh *handle = file->private_data;\n\tstruct uvc_streaming *stream = handle->stream;\n\n\tuvc_dbg(stream->dev, CALLS, \"%s\\n\", __func__);\n\n\t \n\tif (uvc_has_privileges(handle))\n\t\tuvc_queue_release(&stream->queue);\n\n\t \n\tuvc_dismiss_privileges(handle);\n\tv4l2_fh_del(&handle->vfh);\n\tv4l2_fh_exit(&handle->vfh);\n\tkfree(handle);\n\tfile->private_data = NULL;\n\n\tmutex_lock(&stream->dev->lock);\n\tif (--stream->dev->users == 0)\n\t\tuvc_status_stop(stream->dev);\n\tmutex_unlock(&stream->dev->lock);\n\n\tusb_autopm_put_interface(stream->dev->intf);\n\treturn 0;\n}\n\nstatic int uvc_ioctl_querycap(struct file *file, void *fh,\n\t\t\t      struct v4l2_capability *cap)\n{\n\tstruct uvc_fh *handle = file->private_data;\n\tstruct uvc_video_chain *chain = handle->chain;\n\tstruct uvc_streaming *stream = handle->stream;\n\n\tstrscpy(cap->driver, \"uvcvideo\", sizeof(cap->driver));\n\tstrscpy(cap->card, handle->stream->dev->name, sizeof(cap->card));\n\tusb_make_path(stream->dev->udev, cap->bus_info, sizeof(cap->bus_info));\n\tcap->capabilities = V4L2_CAP_DEVICE_CAPS | V4L2_CAP_STREAMING\n\t\t\t  | chain->caps;\n\n\treturn 0;\n}\n\nstatic int uvc_ioctl_enum_fmt(struct uvc_streaming *stream,\n\t\t\t      struct v4l2_fmtdesc *fmt)\n{\n\tconst struct uvc_format *format;\n\tenum v4l2_buf_type type = fmt->type;\n\tu32 index = fmt->index;\n\n\tif (fmt->type != stream->type || fmt->index >= stream->nformats)\n\t\treturn -EINVAL;\n\n\tmemset(fmt, 0, sizeof(*fmt));\n\tfmt->index = index;\n\tfmt->type = type;\n\n\tformat = &stream->formats[fmt->index];\n\tfmt->flags = 0;\n\tif (format->flags & UVC_FMT_FLAG_COMPRESSED)\n\t\tfmt->flags |= V4L2_FMT_FLAG_COMPRESSED;\n\tfmt->pixelformat = format->fcc;\n\treturn 0;\n}\n\nstatic int uvc_ioctl_enum_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t      struct v4l2_fmtdesc *fmt)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\n\treturn uvc_ioctl_enum_fmt(stream, fmt);\n}\n\nstatic int uvc_ioctl_enum_fmt_vid_out(struct file *file, void *fh,\n\t\t\t\t      struct v4l2_fmtdesc *fmt)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\n\treturn uvc_ioctl_enum_fmt(stream, fmt);\n}\n\nstatic int uvc_ioctl_g_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_format *fmt)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\n\treturn uvc_v4l2_get_format(stream, fmt);\n}\n\nstatic int uvc_ioctl_g_fmt_vid_out(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_format *fmt)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\n\treturn uvc_v4l2_get_format(stream, fmt);\n}\n\nstatic int uvc_ioctl_s_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_format *fmt)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\tint ret;\n\n\tret = uvc_acquire_privileges(handle);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn uvc_v4l2_set_format(stream, fmt);\n}\n\nstatic int uvc_ioctl_s_fmt_vid_out(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_format *fmt)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\tint ret;\n\n\tret = uvc_acquire_privileges(handle);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn uvc_v4l2_set_format(stream, fmt);\n}\n\nstatic int uvc_ioctl_try_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t     struct v4l2_format *fmt)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\tstruct uvc_streaming_control probe;\n\n\treturn uvc_v4l2_try_format(stream, fmt, &probe, NULL, NULL);\n}\n\nstatic int uvc_ioctl_try_fmt_vid_out(struct file *file, void *fh,\n\t\t\t\t     struct v4l2_format *fmt)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\tstruct uvc_streaming_control probe;\n\n\treturn uvc_v4l2_try_format(stream, fmt, &probe, NULL, NULL);\n}\n\nstatic int uvc_ioctl_reqbufs(struct file *file, void *fh,\n\t\t\t     struct v4l2_requestbuffers *rb)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\tint ret;\n\n\tret = uvc_acquire_privileges(handle);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&stream->mutex);\n\tret = uvc_request_buffers(&stream->queue, rb);\n\tmutex_unlock(&stream->mutex);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0)\n\t\tuvc_dismiss_privileges(handle);\n\n\treturn 0;\n}\n\nstatic int uvc_ioctl_querybuf(struct file *file, void *fh,\n\t\t\t      struct v4l2_buffer *buf)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\n\tif (!uvc_has_privileges(handle))\n\t\treturn -EBUSY;\n\n\treturn uvc_query_buffer(&stream->queue, buf);\n}\n\nstatic int uvc_ioctl_qbuf(struct file *file, void *fh, struct v4l2_buffer *buf)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\n\tif (!uvc_has_privileges(handle))\n\t\treturn -EBUSY;\n\n\treturn uvc_queue_buffer(&stream->queue,\n\t\t\t\tstream->vdev.v4l2_dev->mdev, buf);\n}\n\nstatic int uvc_ioctl_expbuf(struct file *file, void *fh,\n\t\t\t    struct v4l2_exportbuffer *exp)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\n\tif (!uvc_has_privileges(handle))\n\t\treturn -EBUSY;\n\n\treturn uvc_export_buffer(&stream->queue, exp);\n}\n\nstatic int uvc_ioctl_dqbuf(struct file *file, void *fh, struct v4l2_buffer *buf)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\n\tif (!uvc_has_privileges(handle))\n\t\treturn -EBUSY;\n\n\treturn uvc_dequeue_buffer(&stream->queue, buf,\n\t\t\t\t  file->f_flags & O_NONBLOCK);\n}\n\nstatic int uvc_ioctl_create_bufs(struct file *file, void *fh,\n\t\t\t\t  struct v4l2_create_buffers *cb)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\tint ret;\n\n\tret = uvc_acquire_privileges(handle);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn uvc_create_buffers(&stream->queue, cb);\n}\n\nstatic int uvc_ioctl_streamon(struct file *file, void *fh,\n\t\t\t      enum v4l2_buf_type type)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\tint ret;\n\n\tif (!uvc_has_privileges(handle))\n\t\treturn -EBUSY;\n\n\tmutex_lock(&stream->mutex);\n\tret = uvc_queue_streamon(&stream->queue, type);\n\tmutex_unlock(&stream->mutex);\n\n\treturn ret;\n}\n\nstatic int uvc_ioctl_streamoff(struct file *file, void *fh,\n\t\t\t       enum v4l2_buf_type type)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\n\tif (!uvc_has_privileges(handle))\n\t\treturn -EBUSY;\n\n\tmutex_lock(&stream->mutex);\n\tuvc_queue_streamoff(&stream->queue, type);\n\tmutex_unlock(&stream->mutex);\n\n\treturn 0;\n}\n\nstatic int uvc_ioctl_enum_input(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_input *input)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_video_chain *chain = handle->chain;\n\tconst struct uvc_entity *selector = chain->selector;\n\tstruct uvc_entity *iterm = NULL;\n\tstruct uvc_entity *it;\n\tu32 index = input->index;\n\n\tif (selector == NULL ||\n\t    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {\n\t\tif (index != 0)\n\t\t\treturn -EINVAL;\n\t\tlist_for_each_entry(it, &chain->entities, chain) {\n\t\t\tif (UVC_ENTITY_IS_ITERM(it)) {\n\t\t\t\titerm = it;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (index < selector->bNrInPins) {\n\t\tlist_for_each_entry(it, &chain->entities, chain) {\n\t\t\tif (!UVC_ENTITY_IS_ITERM(it))\n\t\t\t\tcontinue;\n\t\t\tif (it->id == selector->baSourceID[index]) {\n\t\t\t\titerm = it;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (iterm == NULL)\n\t\treturn -EINVAL;\n\n\tmemset(input, 0, sizeof(*input));\n\tinput->index = index;\n\tstrscpy(input->name, iterm->name, sizeof(input->name));\n\tif (UVC_ENTITY_TYPE(iterm) == UVC_ITT_CAMERA)\n\t\tinput->type = V4L2_INPUT_TYPE_CAMERA;\n\n\treturn 0;\n}\n\nstatic int uvc_ioctl_g_input(struct file *file, void *fh, unsigned int *input)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_video_chain *chain = handle->chain;\n\tu8 *buf;\n\tint ret;\n\n\tif (chain->selector == NULL ||\n\t    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {\n\t\t*input = 0;\n\t\treturn 0;\n\t}\n\n\tbuf = kmalloc(1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = uvc_query_ctrl(chain->dev, UVC_GET_CUR, chain->selector->id,\n\t\t\t     chain->dev->intfnum,  UVC_SU_INPUT_SELECT_CONTROL,\n\t\t\t     buf, 1);\n\tif (!ret)\n\t\t*input = *buf - 1;\n\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int uvc_ioctl_s_input(struct file *file, void *fh, unsigned int input)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_video_chain *chain = handle->chain;\n\tu8 *buf;\n\tint ret;\n\n\tret = uvc_acquire_privileges(handle);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (chain->selector == NULL ||\n\t    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {\n\t\tif (input)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\tif (input >= chain->selector->bNrInPins)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t*buf = input + 1;\n\tret = uvc_query_ctrl(chain->dev, UVC_SET_CUR, chain->selector->id,\n\t\t\t     chain->dev->intfnum, UVC_SU_INPUT_SELECT_CONTROL,\n\t\t\t     buf, 1);\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int uvc_ioctl_queryctrl(struct file *file, void *fh,\n\t\t\t       struct v4l2_queryctrl *qc)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_video_chain *chain = handle->chain;\n\n\treturn uvc_query_v4l2_ctrl(chain, qc);\n}\n\nstatic int uvc_ioctl_query_ext_ctrl(struct file *file, void *fh,\n\t\t\t\t    struct v4l2_query_ext_ctrl *qec)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_video_chain *chain = handle->chain;\n\tstruct v4l2_queryctrl qc = { qec->id };\n\tint ret;\n\n\tret = uvc_query_v4l2_ctrl(chain, &qc);\n\tif (ret)\n\t\treturn ret;\n\n\tqec->id = qc.id;\n\tqec->type = qc.type;\n\tstrscpy(qec->name, qc.name, sizeof(qec->name));\n\tqec->minimum = qc.minimum;\n\tqec->maximum = qc.maximum;\n\tqec->step = qc.step;\n\tqec->default_value = qc.default_value;\n\tqec->flags = qc.flags;\n\tqec->elem_size = 4;\n\tqec->elems = 1;\n\tqec->nr_of_dims = 0;\n\tmemset(qec->dims, 0, sizeof(qec->dims));\n\tmemset(qec->reserved, 0, sizeof(qec->reserved));\n\n\treturn 0;\n}\n\nstatic int uvc_ctrl_check_access(struct uvc_video_chain *chain,\n\t\t\t\t struct v4l2_ext_controls *ctrls,\n\t\t\t\t unsigned long ioctl)\n{\n\tstruct v4l2_ext_control *ctrl = ctrls->controls;\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < ctrls->count; ++ctrl, ++i) {\n\t\tret = uvc_ctrl_is_accessible(chain, ctrl->id, ctrls, ioctl);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tctrls->error_idx = ioctl == VIDIOC_TRY_EXT_CTRLS ? i : ctrls->count;\n\n\treturn ret;\n}\n\nstatic int uvc_ioctl_g_ext_ctrls(struct file *file, void *fh,\n\t\t\t\t struct v4l2_ext_controls *ctrls)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_video_chain *chain = handle->chain;\n\tstruct v4l2_ext_control *ctrl = ctrls->controls;\n\tunsigned int i;\n\tint ret;\n\n\tret = uvc_ctrl_check_access(chain, ctrls, VIDIOC_G_EXT_CTRLS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ctrls->which == V4L2_CTRL_WHICH_DEF_VAL) {\n\t\tfor (i = 0; i < ctrls->count; ++ctrl, ++i) {\n\t\t\tstruct v4l2_queryctrl qc = { .id = ctrl->id };\n\n\t\t\tret = uvc_query_v4l2_ctrl(chain, &qc);\n\t\t\tif (ret < 0) {\n\t\t\t\tctrls->error_idx = i;\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tctrl->value = qc.default_value;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tret = uvc_ctrl_begin(chain);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ctrls->count; ++ctrl, ++i) {\n\t\tret = uvc_ctrl_get(chain, ctrl);\n\t\tif (ret < 0) {\n\t\t\tuvc_ctrl_rollback(handle);\n\t\t\tctrls->error_idx = i;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tctrls->error_idx = 0;\n\n\treturn uvc_ctrl_rollback(handle);\n}\n\nstatic int uvc_ioctl_s_try_ext_ctrls(struct uvc_fh *handle,\n\t\t\t\t     struct v4l2_ext_controls *ctrls,\n\t\t\t\t     unsigned long ioctl)\n{\n\tstruct v4l2_ext_control *ctrl = ctrls->controls;\n\tstruct uvc_video_chain *chain = handle->chain;\n\tunsigned int i;\n\tint ret;\n\n\tret = uvc_ctrl_check_access(chain, ctrls, ioctl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = uvc_ctrl_begin(chain);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ctrls->count; ++ctrl, ++i) {\n\t\tret = uvc_ctrl_set(handle, ctrl);\n\t\tif (ret < 0) {\n\t\t\tuvc_ctrl_rollback(handle);\n\t\t\tctrls->error_idx = ioctl == VIDIOC_S_EXT_CTRLS ?\n\t\t\t\t\t\t    ctrls->count : i;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tctrls->error_idx = 0;\n\n\tif (ioctl == VIDIOC_S_EXT_CTRLS)\n\t\treturn uvc_ctrl_commit(handle, ctrls);\n\telse\n\t\treturn uvc_ctrl_rollback(handle);\n}\n\nstatic int uvc_ioctl_s_ext_ctrls(struct file *file, void *fh,\n\t\t\t\t struct v4l2_ext_controls *ctrls)\n{\n\tstruct uvc_fh *handle = fh;\n\n\treturn uvc_ioctl_s_try_ext_ctrls(handle, ctrls, VIDIOC_S_EXT_CTRLS);\n}\n\nstatic int uvc_ioctl_try_ext_ctrls(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_ext_controls *ctrls)\n{\n\tstruct uvc_fh *handle = fh;\n\n\treturn uvc_ioctl_s_try_ext_ctrls(handle, ctrls, VIDIOC_TRY_EXT_CTRLS);\n}\n\nstatic int uvc_ioctl_querymenu(struct file *file, void *fh,\n\t\t\t       struct v4l2_querymenu *qm)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_video_chain *chain = handle->chain;\n\n\treturn uvc_query_v4l2_menu(chain, qm);\n}\n\nstatic int uvc_ioctl_g_selection(struct file *file, void *fh,\n\t\t\t\t struct v4l2_selection *sel)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\n\tif (sel->type != stream->type)\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tif (stream->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\tif (stream->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsel->r.left = 0;\n\tsel->r.top = 0;\n\tmutex_lock(&stream->mutex);\n\tsel->r.width = stream->cur_frame->wWidth;\n\tsel->r.height = stream->cur_frame->wHeight;\n\tmutex_unlock(&stream->mutex);\n\n\treturn 0;\n}\n\nstatic int uvc_ioctl_g_parm(struct file *file, void *fh,\n\t\t\t    struct v4l2_streamparm *parm)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\n\treturn uvc_v4l2_get_streamparm(stream, parm);\n}\n\nstatic int uvc_ioctl_s_parm(struct file *file, void *fh,\n\t\t\t    struct v4l2_streamparm *parm)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\tint ret;\n\n\tret = uvc_acquire_privileges(handle);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn uvc_v4l2_set_streamparm(stream, parm);\n}\n\nstatic int uvc_ioctl_enum_framesizes(struct file *file, void *fh,\n\t\t\t\t     struct v4l2_frmsizeenum *fsize)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\tconst struct uvc_format *format = NULL;\n\tconst struct uvc_frame *frame = NULL;\n\tunsigned int index;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < stream->nformats; i++) {\n\t\tif (stream->formats[i].fcc == fsize->pixel_format) {\n\t\t\tformat = &stream->formats[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (format == NULL)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0, index = 0; i < format->nframes; i++) {\n\t\tif (frame && frame->wWidth == format->frames[i].wWidth &&\n\t\t    frame->wHeight == format->frames[i].wHeight)\n\t\t\tcontinue;\n\t\tframe = &format->frames[i];\n\t\tif (index == fsize->index)\n\t\t\tbreak;\n\t\tindex++;\n\t}\n\n\tif (i == format->nframes)\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\tfsize->discrete.width = frame->wWidth;\n\tfsize->discrete.height = frame->wHeight;\n\treturn 0;\n}\n\nstatic int uvc_ioctl_enum_frameintervals(struct file *file, void *fh,\n\t\t\t\t\t struct v4l2_frmivalenum *fival)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_streaming *stream = handle->stream;\n\tconst struct uvc_format *format = NULL;\n\tconst struct uvc_frame *frame = NULL;\n\tunsigned int nintervals;\n\tunsigned int index;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < stream->nformats; i++) {\n\t\tif (stream->formats[i].fcc == fival->pixel_format) {\n\t\t\tformat = &stream->formats[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (format == NULL)\n\t\treturn -EINVAL;\n\n\tindex = fival->index;\n\tfor (i = 0; i < format->nframes; i++) {\n\t\tif (format->frames[i].wWidth == fival->width &&\n\t\t    format->frames[i].wHeight == fival->height) {\n\t\t\tframe = &format->frames[i];\n\t\t\tnintervals = frame->bFrameIntervalType ?: 1;\n\t\t\tif (index < nintervals)\n\t\t\t\tbreak;\n\t\t\tindex -= nintervals;\n\t\t}\n\t}\n\tif (i == format->nframes)\n\t\treturn -EINVAL;\n\n\tif (frame->bFrameIntervalType) {\n\t\tfival->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\t\tfival->discrete.numerator =\n\t\t\tframe->dwFrameInterval[index];\n\t\tfival->discrete.denominator = 10000000;\n\t\tv4l2_simplify_fraction(&fival->discrete.numerator,\n\t\t\t&fival->discrete.denominator, 8, 333);\n\t} else {\n\t\tfival->type = V4L2_FRMIVAL_TYPE_STEPWISE;\n\t\tfival->stepwise.min.numerator = frame->dwFrameInterval[0];\n\t\tfival->stepwise.min.denominator = 10000000;\n\t\tfival->stepwise.max.numerator = frame->dwFrameInterval[1];\n\t\tfival->stepwise.max.denominator = 10000000;\n\t\tfival->stepwise.step.numerator = frame->dwFrameInterval[2];\n\t\tfival->stepwise.step.denominator = 10000000;\n\t\tv4l2_simplify_fraction(&fival->stepwise.min.numerator,\n\t\t\t&fival->stepwise.min.denominator, 8, 333);\n\t\tv4l2_simplify_fraction(&fival->stepwise.max.numerator,\n\t\t\t&fival->stepwise.max.denominator, 8, 333);\n\t\tv4l2_simplify_fraction(&fival->stepwise.step.numerator,\n\t\t\t&fival->stepwise.step.denominator, 8, 333);\n\t}\n\n\treturn 0;\n}\n\nstatic int uvc_ioctl_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\t     const struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_CTRL:\n\t\treturn v4l2_event_subscribe(fh, sub, 0, &uvc_ctrl_sub_ev_ops);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic long uvc_ioctl_default(struct file *file, void *fh, bool valid_prio,\n\t\t\t      unsigned int cmd, void *arg)\n{\n\tstruct uvc_fh *handle = fh;\n\tstruct uvc_video_chain *chain = handle->chain;\n\n\tswitch (cmd) {\n\t \n\tcase UVCIOC_CTRL_MAP:\n\t\treturn uvc_ioctl_xu_ctrl_map(chain, arg);\n\n\tcase UVCIOC_CTRL_QUERY:\n\t\treturn uvc_xu_ctrl_query(chain, arg);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nstruct uvc_xu_control_mapping32 {\n\tu32 id;\n\tu8 name[32];\n\tu8 entity[16];\n\tu8 selector;\n\n\tu8 size;\n\tu8 offset;\n\tu32 v4l2_type;\n\tu32 data_type;\n\n\tcompat_caddr_t menu_info;\n\tu32 menu_count;\n\n\tu32 reserved[4];\n};\n\nstatic int uvc_v4l2_get_xu_mapping(struct uvc_xu_control_mapping *kp,\n\t\t\tconst struct uvc_xu_control_mapping32 __user *up)\n{\n\tstruct uvc_xu_control_mapping32 *p = (void *)kp;\n\tcompat_caddr_t info;\n\tu32 count;\n\n\tif (copy_from_user(p, up, sizeof(*p)))\n\t\treturn -EFAULT;\n\n\tcount = p->menu_count;\n\tinfo = p->menu_info;\n\n\tmemset(kp->reserved, 0, sizeof(kp->reserved));\n\tkp->menu_info = count ? compat_ptr(info) : NULL;\n\tkp->menu_count = count;\n\treturn 0;\n}\n\nstatic int uvc_v4l2_put_xu_mapping(const struct uvc_xu_control_mapping *kp,\n\t\t\tstruct uvc_xu_control_mapping32 __user *up)\n{\n\tif (copy_to_user(up, kp, offsetof(typeof(*up), menu_info)) ||\n\t    put_user(kp->menu_count, &up->menu_count))\n\t\treturn -EFAULT;\n\n\tif (clear_user(up->reserved, sizeof(up->reserved)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstruct uvc_xu_control_query32 {\n\tu8 unit;\n\tu8 selector;\n\tu8 query;\n\tu16 size;\n\tcompat_caddr_t data;\n};\n\nstatic int uvc_v4l2_get_xu_query(struct uvc_xu_control_query *kp,\n\t\t\tconst struct uvc_xu_control_query32 __user *up)\n{\n\tstruct uvc_xu_control_query32 v;\n\n\tif (copy_from_user(&v, up, sizeof(v)))\n\t\treturn -EFAULT;\n\n\t*kp = (struct uvc_xu_control_query){\n\t\t.unit = v.unit,\n\t\t.selector = v.selector,\n\t\t.query = v.query,\n\t\t.size = v.size,\n\t\t.data = v.size ? compat_ptr(v.data) : NULL\n\t};\n\treturn 0;\n}\n\nstatic int uvc_v4l2_put_xu_query(const struct uvc_xu_control_query *kp,\n\t\t\tstruct uvc_xu_control_query32 __user *up)\n{\n\tif (copy_to_user(up, kp, offsetof(typeof(*up), data)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n#define UVCIOC_CTRL_MAP32\t_IOWR('u', 0x20, struct uvc_xu_control_mapping32)\n#define UVCIOC_CTRL_QUERY32\t_IOWR('u', 0x21, struct uvc_xu_control_query32)\n\nstatic long uvc_v4l2_compat_ioctl32(struct file *file,\n\t\t     unsigned int cmd, unsigned long arg)\n{\n\tstruct uvc_fh *handle = file->private_data;\n\tunion {\n\t\tstruct uvc_xu_control_mapping xmap;\n\t\tstruct uvc_xu_control_query xqry;\n\t} karg;\n\tvoid __user *up = compat_ptr(arg);\n\tlong ret;\n\n\tswitch (cmd) {\n\tcase UVCIOC_CTRL_MAP32:\n\t\tret = uvc_v4l2_get_xu_mapping(&karg.xmap, up);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = uvc_ioctl_xu_ctrl_map(handle->chain, &karg.xmap);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = uvc_v4l2_put_xu_mapping(&karg.xmap, up);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbreak;\n\n\tcase UVCIOC_CTRL_QUERY32:\n\t\tret = uvc_v4l2_get_xu_query(&karg.xqry, up);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = uvc_xu_ctrl_query(handle->chain, &karg.xqry);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = uvc_v4l2_put_xu_query(&karg.xqry, up);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn ret;\n}\n#endif\n\nstatic ssize_t uvc_v4l2_read(struct file *file, char __user *data,\n\t\t    size_t count, loff_t *ppos)\n{\n\tstruct uvc_fh *handle = file->private_data;\n\tstruct uvc_streaming *stream = handle->stream;\n\n\tuvc_dbg(stream->dev, CALLS, \"%s: not implemented\\n\", __func__);\n\treturn -EINVAL;\n}\n\nstatic int uvc_v4l2_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct uvc_fh *handle = file->private_data;\n\tstruct uvc_streaming *stream = handle->stream;\n\n\tuvc_dbg(stream->dev, CALLS, \"%s\\n\", __func__);\n\n\treturn uvc_queue_mmap(&stream->queue, vma);\n}\n\nstatic __poll_t uvc_v4l2_poll(struct file *file, poll_table *wait)\n{\n\tstruct uvc_fh *handle = file->private_data;\n\tstruct uvc_streaming *stream = handle->stream;\n\n\tuvc_dbg(stream->dev, CALLS, \"%s\\n\", __func__);\n\n\treturn uvc_queue_poll(&stream->queue, file, wait);\n}\n\n#ifndef CONFIG_MMU\nstatic unsigned long uvc_v4l2_get_unmapped_area(struct file *file,\n\t\tunsigned long addr, unsigned long len, unsigned long pgoff,\n\t\tunsigned long flags)\n{\n\tstruct uvc_fh *handle = file->private_data;\n\tstruct uvc_streaming *stream = handle->stream;\n\n\tuvc_dbg(stream->dev, CALLS, \"%s\\n\", __func__);\n\n\treturn uvc_queue_get_unmapped_area(&stream->queue, pgoff);\n}\n#endif\n\nconst struct v4l2_ioctl_ops uvc_ioctl_ops = {\n\t.vidioc_querycap = uvc_ioctl_querycap,\n\t.vidioc_enum_fmt_vid_cap = uvc_ioctl_enum_fmt_vid_cap,\n\t.vidioc_enum_fmt_vid_out = uvc_ioctl_enum_fmt_vid_out,\n\t.vidioc_g_fmt_vid_cap = uvc_ioctl_g_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_out = uvc_ioctl_g_fmt_vid_out,\n\t.vidioc_s_fmt_vid_cap = uvc_ioctl_s_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_out = uvc_ioctl_s_fmt_vid_out,\n\t.vidioc_try_fmt_vid_cap = uvc_ioctl_try_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_out = uvc_ioctl_try_fmt_vid_out,\n\t.vidioc_reqbufs = uvc_ioctl_reqbufs,\n\t.vidioc_querybuf = uvc_ioctl_querybuf,\n\t.vidioc_qbuf = uvc_ioctl_qbuf,\n\t.vidioc_expbuf = uvc_ioctl_expbuf,\n\t.vidioc_dqbuf = uvc_ioctl_dqbuf,\n\t.vidioc_create_bufs = uvc_ioctl_create_bufs,\n\t.vidioc_streamon = uvc_ioctl_streamon,\n\t.vidioc_streamoff = uvc_ioctl_streamoff,\n\t.vidioc_enum_input = uvc_ioctl_enum_input,\n\t.vidioc_g_input = uvc_ioctl_g_input,\n\t.vidioc_s_input = uvc_ioctl_s_input,\n\t.vidioc_queryctrl = uvc_ioctl_queryctrl,\n\t.vidioc_query_ext_ctrl = uvc_ioctl_query_ext_ctrl,\n\t.vidioc_g_ext_ctrls = uvc_ioctl_g_ext_ctrls,\n\t.vidioc_s_ext_ctrls = uvc_ioctl_s_ext_ctrls,\n\t.vidioc_try_ext_ctrls = uvc_ioctl_try_ext_ctrls,\n\t.vidioc_querymenu = uvc_ioctl_querymenu,\n\t.vidioc_g_selection = uvc_ioctl_g_selection,\n\t.vidioc_g_parm = uvc_ioctl_g_parm,\n\t.vidioc_s_parm = uvc_ioctl_s_parm,\n\t.vidioc_enum_framesizes = uvc_ioctl_enum_framesizes,\n\t.vidioc_enum_frameintervals = uvc_ioctl_enum_frameintervals,\n\t.vidioc_subscribe_event = uvc_ioctl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\t.vidioc_default = uvc_ioctl_default,\n};\n\nconst struct v4l2_file_operations uvc_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= uvc_v4l2_open,\n\t.release\t= uvc_v4l2_release,\n\t.unlocked_ioctl\t= video_ioctl2,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl32\t= uvc_v4l2_compat_ioctl32,\n#endif\n\t.read\t\t= uvc_v4l2_read,\n\t.mmap\t\t= uvc_v4l2_mmap,\n\t.poll\t\t= uvc_v4l2_poll,\n#ifndef CONFIG_MMU\n\t.get_unmapped_area = uvc_v4l2_get_unmapped_area,\n#endif\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}