{
  "module_name": "uvc_video.c",
  "hash_id": "9e655bbaaca2306aa239fded082757411ca3e5a9d69c4e4f6dcadaeef2169079",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/uvc/uvc_video.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/videodev2.h>\n#include <linux/vmalloc.h>\n#include <linux/wait.h>\n#include <linux/atomic.h>\n#include <asm/unaligned.h>\n\n#include <media/v4l2-common.h>\n\n#include \"uvcvideo.h\"\n\n \n\nstatic int __uvc_query_ctrl(struct uvc_device *dev, u8 query, u8 unit,\n\t\t\tu8 intfnum, u8 cs, void *data, u16 size,\n\t\t\tint timeout)\n{\n\tu8 type = USB_TYPE_CLASS | USB_RECIP_INTERFACE;\n\tunsigned int pipe;\n\n\tpipe = (query & 0x80) ? usb_rcvctrlpipe(dev->udev, 0)\n\t\t\t      : usb_sndctrlpipe(dev->udev, 0);\n\ttype |= (query & 0x80) ? USB_DIR_IN : USB_DIR_OUT;\n\n\treturn usb_control_msg(dev->udev, pipe, query, type, cs << 8,\n\t\t\tunit << 8 | intfnum, data, size, timeout);\n}\n\nstatic const char *uvc_query_name(u8 query)\n{\n\tswitch (query) {\n\tcase UVC_SET_CUR:\n\t\treturn \"SET_CUR\";\n\tcase UVC_GET_CUR:\n\t\treturn \"GET_CUR\";\n\tcase UVC_GET_MIN:\n\t\treturn \"GET_MIN\";\n\tcase UVC_GET_MAX:\n\t\treturn \"GET_MAX\";\n\tcase UVC_GET_RES:\n\t\treturn \"GET_RES\";\n\tcase UVC_GET_LEN:\n\t\treturn \"GET_LEN\";\n\tcase UVC_GET_INFO:\n\t\treturn \"GET_INFO\";\n\tcase UVC_GET_DEF:\n\t\treturn \"GET_DEF\";\n\tdefault:\n\t\treturn \"<invalid>\";\n\t}\n}\n\nint uvc_query_ctrl(struct uvc_device *dev, u8 query, u8 unit,\n\t\t\tu8 intfnum, u8 cs, void *data, u16 size)\n{\n\tint ret;\n\tu8 error;\n\tu8 tmp;\n\n\tret = __uvc_query_ctrl(dev, query, unit, intfnum, cs, data, size,\n\t\t\t\tUVC_CTRL_CONTROL_TIMEOUT);\n\tif (likely(ret == size))\n\t\treturn 0;\n\n\tif (ret != -EPIPE) {\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"Failed to query (%s) UVC control %u on unit %u: %d (exp. %u).\\n\",\n\t\t\tuvc_query_name(query), cs, unit, ret, size);\n\t\treturn ret < 0 ? ret : -EPIPE;\n\t}\n\n\t \n\ttmp = *(u8 *)data;\n\n\tret = __uvc_query_ctrl(dev, UVC_GET_CUR, 0, intfnum,\n\t\t\t       UVC_VC_REQUEST_ERROR_CODE_CONTROL, data, 1,\n\t\t\t       UVC_CTRL_CONTROL_TIMEOUT);\n\n\terror = *(u8 *)data;\n\t*(u8 *)data = tmp;\n\n\tif (ret != 1)\n\t\treturn ret < 0 ? ret : -EPIPE;\n\n\tuvc_dbg(dev, CONTROL, \"Control error %u\\n\", error);\n\n\tswitch (error) {\n\tcase 0:\n\t\t \n\t\treturn -EPIPE;\n\tcase 1:  \n\t\treturn -EBUSY;\n\tcase 2:  \n\t\treturn -EACCES;\n\tcase 3:  \n\t\treturn -EREMOTE;\n\tcase 4:  \n\t\treturn -ERANGE;\n\tcase 5:  \n\tcase 6:  \n\tcase 7:  \n\t\t \n\t\treturn -EIO;\n\tcase 8:  \n\t\treturn -EINVAL;\n\tdefault:  \n\t\tbreak;\n\t}\n\n\treturn -EPIPE;\n}\n\nstatic const struct usb_device_id elgato_cam_link_4k = {\n\tUSB_DEVICE(0x0fd9, 0x0066)\n};\n\nstatic void uvc_fixup_video_ctrl(struct uvc_streaming *stream,\n\tstruct uvc_streaming_control *ctrl)\n{\n\tconst struct uvc_format *format = NULL;\n\tconst struct uvc_frame *frame = NULL;\n\tunsigned int i;\n\n\t \n\tif (usb_match_one_id(stream->dev->intf, &elgato_cam_link_4k) &&\n\t    ctrl->bmHint > 255) {\n\t\tu8 corrected_format_index = ctrl->bmHint >> 8;\n\n\t\tuvc_dbg(stream->dev, VIDEO,\n\t\t\t\"Correct USB video probe response from {bmHint: 0x%04x, bFormatIndex: %u} to {bmHint: 0x%04x, bFormatIndex: %u}\\n\",\n\t\t\tctrl->bmHint, ctrl->bFormatIndex,\n\t\t\t1, corrected_format_index);\n\t\tctrl->bmHint = 1;\n\t\tctrl->bFormatIndex = corrected_format_index;\n\t}\n\n\tfor (i = 0; i < stream->nformats; ++i) {\n\t\tif (stream->formats[i].index == ctrl->bFormatIndex) {\n\t\t\tformat = &stream->formats[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (format == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < format->nframes; ++i) {\n\t\tif (format->frames[i].bFrameIndex == ctrl->bFrameIndex) {\n\t\t\tframe = &format->frames[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (frame == NULL)\n\t\treturn;\n\n\tif (!(format->flags & UVC_FMT_FLAG_COMPRESSED) ||\n\t     (ctrl->dwMaxVideoFrameSize == 0 &&\n\t      stream->dev->uvc_version < 0x0110))\n\t\tctrl->dwMaxVideoFrameSize =\n\t\t\tframe->dwMaxVideoFrameBufferSize;\n\n\t \n\tif ((ctrl->dwMaxPayloadTransferSize & 0xffff0000) == 0xffff0000)\n\t\tctrl->dwMaxPayloadTransferSize &= ~0xffff0000;\n\n\tif (!(format->flags & UVC_FMT_FLAG_COMPRESSED) &&\n\t    stream->dev->quirks & UVC_QUIRK_FIX_BANDWIDTH &&\n\t    stream->intf->num_altsetting > 1) {\n\t\tu32 interval;\n\t\tu32 bandwidth;\n\n\t\tinterval = (ctrl->dwFrameInterval > 100000)\n\t\t\t ? ctrl->dwFrameInterval\n\t\t\t : frame->dwFrameInterval[0];\n\n\t\t \n\t\tbandwidth = frame->wWidth * frame->wHeight / 8 * format->bpp;\n\t\tbandwidth *= 10000000 / interval + 1;\n\t\tbandwidth /= 1000;\n\t\tif (stream->dev->udev->speed == USB_SPEED_HIGH)\n\t\t\tbandwidth /= 8;\n\t\tbandwidth += 12;\n\n\t\t \n\t\tbandwidth = max_t(u32, bandwidth, 1024);\n\n\t\tctrl->dwMaxPayloadTransferSize = bandwidth;\n\t}\n}\n\nstatic size_t uvc_video_ctrl_size(struct uvc_streaming *stream)\n{\n\t \n\tif (stream->dev->uvc_version < 0x0110)\n\t\treturn 26;\n\telse if (stream->dev->uvc_version < 0x0150)\n\t\treturn 34;\n\telse\n\t\treturn 48;\n}\n\nstatic int uvc_get_video_ctrl(struct uvc_streaming *stream,\n\tstruct uvc_streaming_control *ctrl, int probe, u8 query)\n{\n\tu16 size = uvc_video_ctrl_size(stream);\n\tu8 *data;\n\tint ret;\n\n\tif ((stream->dev->quirks & UVC_QUIRK_PROBE_DEF) &&\n\t\t\tquery == UVC_GET_DEF)\n\t\treturn -EIO;\n\n\tdata = kmalloc(size, GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\tret = __uvc_query_ctrl(stream->dev, query, 0, stream->intfnum,\n\t\tprobe ? UVC_VS_PROBE_CONTROL : UVC_VS_COMMIT_CONTROL, data,\n\t\tsize, uvc_timeout_param);\n\n\tif ((query == UVC_GET_MIN || query == UVC_GET_MAX) && ret == 2) {\n\t\t \n\t\tuvc_warn_once(stream->dev, UVC_WARN_MINMAX, \"UVC non \"\n\t\t\t\"compliance - GET_MIN/MAX(PROBE) incorrectly \"\n\t\t\t\"supported. Enabling workaround.\\n\");\n\t\tmemset(ctrl, 0, sizeof(*ctrl));\n\t\tctrl->wCompQuality = le16_to_cpup((__le16 *)data);\n\t\tret = 0;\n\t\tgoto out;\n\t} else if (query == UVC_GET_DEF && probe == 1 && ret != size) {\n\t\t \n\t\tuvc_warn_once(stream->dev, UVC_WARN_PROBE_DEF, \"UVC non \"\n\t\t\t\"compliance - GET_DEF(PROBE) not supported. \"\n\t\t\t\"Enabling workaround.\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t} else if (ret != size) {\n\t\tdev_err(&stream->intf->dev,\n\t\t\t\"Failed to query (%u) UVC %s control : %d (exp. %u).\\n\",\n\t\t\tquery, probe ? \"probe\" : \"commit\", ret, size);\n\t\tret = (ret == -EPROTO) ? -EPROTO : -EIO;\n\t\tgoto out;\n\t}\n\n\tctrl->bmHint = le16_to_cpup((__le16 *)&data[0]);\n\tctrl->bFormatIndex = data[2];\n\tctrl->bFrameIndex = data[3];\n\tctrl->dwFrameInterval = le32_to_cpup((__le32 *)&data[4]);\n\tctrl->wKeyFrameRate = le16_to_cpup((__le16 *)&data[8]);\n\tctrl->wPFrameRate = le16_to_cpup((__le16 *)&data[10]);\n\tctrl->wCompQuality = le16_to_cpup((__le16 *)&data[12]);\n\tctrl->wCompWindowSize = le16_to_cpup((__le16 *)&data[14]);\n\tctrl->wDelay = le16_to_cpup((__le16 *)&data[16]);\n\tctrl->dwMaxVideoFrameSize = get_unaligned_le32(&data[18]);\n\tctrl->dwMaxPayloadTransferSize = get_unaligned_le32(&data[22]);\n\n\tif (size >= 34) {\n\t\tctrl->dwClockFrequency = get_unaligned_le32(&data[26]);\n\t\tctrl->bmFramingInfo = data[30];\n\t\tctrl->bPreferedVersion = data[31];\n\t\tctrl->bMinVersion = data[32];\n\t\tctrl->bMaxVersion = data[33];\n\t} else {\n\t\tctrl->dwClockFrequency = stream->dev->clock_frequency;\n\t\tctrl->bmFramingInfo = 0;\n\t\tctrl->bPreferedVersion = 0;\n\t\tctrl->bMinVersion = 0;\n\t\tctrl->bMaxVersion = 0;\n\t}\n\n\t \n\tuvc_fixup_video_ctrl(stream, ctrl);\n\tret = 0;\n\nout:\n\tkfree(data);\n\treturn ret;\n}\n\nstatic int uvc_set_video_ctrl(struct uvc_streaming *stream,\n\tstruct uvc_streaming_control *ctrl, int probe)\n{\n\tu16 size = uvc_video_ctrl_size(stream);\n\tu8 *data;\n\tint ret;\n\n\tdata = kzalloc(size, GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\t*(__le16 *)&data[0] = cpu_to_le16(ctrl->bmHint);\n\tdata[2] = ctrl->bFormatIndex;\n\tdata[3] = ctrl->bFrameIndex;\n\t*(__le32 *)&data[4] = cpu_to_le32(ctrl->dwFrameInterval);\n\t*(__le16 *)&data[8] = cpu_to_le16(ctrl->wKeyFrameRate);\n\t*(__le16 *)&data[10] = cpu_to_le16(ctrl->wPFrameRate);\n\t*(__le16 *)&data[12] = cpu_to_le16(ctrl->wCompQuality);\n\t*(__le16 *)&data[14] = cpu_to_le16(ctrl->wCompWindowSize);\n\t*(__le16 *)&data[16] = cpu_to_le16(ctrl->wDelay);\n\tput_unaligned_le32(ctrl->dwMaxVideoFrameSize, &data[18]);\n\tput_unaligned_le32(ctrl->dwMaxPayloadTransferSize, &data[22]);\n\n\tif (size >= 34) {\n\t\tput_unaligned_le32(ctrl->dwClockFrequency, &data[26]);\n\t\tdata[30] = ctrl->bmFramingInfo;\n\t\tdata[31] = ctrl->bPreferedVersion;\n\t\tdata[32] = ctrl->bMinVersion;\n\t\tdata[33] = ctrl->bMaxVersion;\n\t}\n\n\tret = __uvc_query_ctrl(stream->dev, UVC_SET_CUR, 0, stream->intfnum,\n\t\tprobe ? UVC_VS_PROBE_CONTROL : UVC_VS_COMMIT_CONTROL, data,\n\t\tsize, uvc_timeout_param);\n\tif (ret != size) {\n\t\tdev_err(&stream->intf->dev,\n\t\t\t\"Failed to set UVC %s control : %d (exp. %u).\\n\",\n\t\t\tprobe ? \"probe\" : \"commit\", ret, size);\n\t\tret = -EIO;\n\t}\n\n\tkfree(data);\n\treturn ret;\n}\n\nint uvc_probe_video(struct uvc_streaming *stream,\n\tstruct uvc_streaming_control *probe)\n{\n\tstruct uvc_streaming_control probe_min, probe_max;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tret = uvc_set_video_ctrl(stream, probe, 1);\n\tif (ret < 0)\n\t\tgoto done;\n\n\t \n\tif (!(stream->dev->quirks & UVC_QUIRK_PROBE_MINMAX)) {\n\t\tret = uvc_get_video_ctrl(stream, &probe_min, 1, UVC_GET_MIN);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tret = uvc_get_video_ctrl(stream, &probe_max, 1, UVC_GET_MAX);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tprobe->wCompQuality = probe_max.wCompQuality;\n\t}\n\n\tfor (i = 0; i < 2; ++i) {\n\t\tret = uvc_set_video_ctrl(stream, probe, 1);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tret = uvc_get_video_ctrl(stream, probe, 1, UVC_GET_CUR);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tif (stream->intf->num_altsetting == 1)\n\t\t\tbreak;\n\n\t\tif (probe->dwMaxPayloadTransferSize <= stream->maxpsize)\n\t\t\tbreak;\n\n\t\tif (stream->dev->quirks & UVC_QUIRK_PROBE_MINMAX) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tprobe->wKeyFrameRate = probe_min.wKeyFrameRate;\n\t\tprobe->wPFrameRate = probe_min.wPFrameRate;\n\t\tprobe->wCompQuality = probe_max.wCompQuality;\n\t\tprobe->wCompWindowSize = probe_min.wCompWindowSize;\n\t}\n\ndone:\n\treturn ret;\n}\n\nstatic int uvc_commit_video(struct uvc_streaming *stream,\n\t\t\t    struct uvc_streaming_control *probe)\n{\n\treturn uvc_set_video_ctrl(stream, probe, 0);\n}\n\n \n\nstatic inline ktime_t uvc_video_get_time(void)\n{\n\tif (uvc_clock_param == CLOCK_MONOTONIC)\n\t\treturn ktime_get();\n\telse\n\t\treturn ktime_get_real();\n}\n\nstatic void\nuvc_video_clock_decode(struct uvc_streaming *stream, struct uvc_buffer *buf,\n\t\t       const u8 *data, int len)\n{\n\tstruct uvc_clock_sample *sample;\n\tunsigned int header_size;\n\tbool has_pts = false;\n\tbool has_scr = false;\n\tunsigned long flags;\n\tktime_t time;\n\tu16 host_sof;\n\tu16 dev_sof;\n\n\tswitch (data[1] & (UVC_STREAM_PTS | UVC_STREAM_SCR)) {\n\tcase UVC_STREAM_PTS | UVC_STREAM_SCR:\n\t\theader_size = 12;\n\t\thas_pts = true;\n\t\thas_scr = true;\n\t\tbreak;\n\tcase UVC_STREAM_PTS:\n\t\theader_size = 6;\n\t\thas_pts = true;\n\t\tbreak;\n\tcase UVC_STREAM_SCR:\n\t\theader_size = 8;\n\t\thas_scr = true;\n\t\tbreak;\n\tdefault:\n\t\theader_size = 2;\n\t\tbreak;\n\t}\n\n\t \n\tif (len < header_size)\n\t\treturn;\n\n\t \n\tif (has_pts && buf != NULL)\n\t\tbuf->pts = get_unaligned_le32(&data[2]);\n\n\tif (!has_scr)\n\t\treturn;\n\n\t \n\tdev_sof = get_unaligned_le16(&data[header_size - 2]);\n\tif (dev_sof == stream->clock.last_sof)\n\t\treturn;\n\n\tstream->clock.last_sof = dev_sof;\n\n\thost_sof = usb_get_current_frame_number(stream->dev->udev);\n\ttime = uvc_video_get_time();\n\n\t \n\tif (stream->clock.sof_offset == (u16)-1) {\n\t\tu16 delta_sof = (host_sof - dev_sof) & 255;\n\t\tif (delta_sof >= 10)\n\t\t\tstream->clock.sof_offset = delta_sof;\n\t\telse\n\t\t\tstream->clock.sof_offset = 0;\n\t}\n\n\tdev_sof = (dev_sof + stream->clock.sof_offset) & 2047;\n\n\tspin_lock_irqsave(&stream->clock.lock, flags);\n\n\tsample = &stream->clock.samples[stream->clock.head];\n\tsample->dev_stc = get_unaligned_le32(&data[header_size - 6]);\n\tsample->dev_sof = dev_sof;\n\tsample->host_sof = host_sof;\n\tsample->host_time = time;\n\n\t \n\tstream->clock.head = (stream->clock.head + 1) % stream->clock.size;\n\n\tif (stream->clock.count < stream->clock.size)\n\t\tstream->clock.count++;\n\n\tspin_unlock_irqrestore(&stream->clock.lock, flags);\n}\n\nstatic void uvc_video_clock_reset(struct uvc_streaming *stream)\n{\n\tstruct uvc_clock *clock = &stream->clock;\n\n\tclock->head = 0;\n\tclock->count = 0;\n\tclock->last_sof = -1;\n\tclock->sof_offset = -1;\n}\n\nstatic int uvc_video_clock_init(struct uvc_streaming *stream)\n{\n\tstruct uvc_clock *clock = &stream->clock;\n\n\tspin_lock_init(&clock->lock);\n\tclock->size = 32;\n\n\tclock->samples = kmalloc_array(clock->size, sizeof(*clock->samples),\n\t\t\t\t       GFP_KERNEL);\n\tif (clock->samples == NULL)\n\t\treturn -ENOMEM;\n\n\tuvc_video_clock_reset(stream);\n\n\treturn 0;\n}\n\nstatic void uvc_video_clock_cleanup(struct uvc_streaming *stream)\n{\n\tkfree(stream->clock.samples);\n\tstream->clock.samples = NULL;\n}\n\n \nstatic u16 uvc_video_clock_host_sof(const struct uvc_clock_sample *sample)\n{\n\t \n\ts8 delta_sof;\n\n\tdelta_sof = (sample->host_sof - sample->dev_sof) & 255;\n\n\treturn (sample->dev_sof + delta_sof) & 2047;\n}\n\n \nvoid uvc_video_clock_update(struct uvc_streaming *stream,\n\t\t\t    struct vb2_v4l2_buffer *vbuf,\n\t\t\t    struct uvc_buffer *buf)\n{\n\tstruct uvc_clock *clock = &stream->clock;\n\tstruct uvc_clock_sample *first;\n\tstruct uvc_clock_sample *last;\n\tunsigned long flags;\n\tu64 timestamp;\n\tu32 delta_stc;\n\tu32 y1, y2;\n\tu32 x1, x2;\n\tu32 mean;\n\tu32 sof;\n\tu64 y;\n\n\tif (!uvc_hw_timestamps_param)\n\t\treturn;\n\n\t \n\tif (!clock->samples)\n\t\treturn;\n\n\tspin_lock_irqsave(&clock->lock, flags);\n\n\tif (clock->count < clock->size)\n\t\tgoto done;\n\n\tfirst = &clock->samples[clock->head];\n\tlast = &clock->samples[(clock->head - 1) % clock->size];\n\n\t \n\tdelta_stc = buf->pts - (1UL << 31);\n\tx1 = first->dev_stc - delta_stc;\n\tx2 = last->dev_stc - delta_stc;\n\tif (x1 == x2)\n\t\tgoto done;\n\n\ty1 = (first->dev_sof + 2048) << 16;\n\ty2 = (last->dev_sof + 2048) << 16;\n\tif (y2 < y1)\n\t\ty2 += 2048 << 16;\n\n\ty = (u64)(y2 - y1) * (1ULL << 31) + (u64)y1 * (u64)x2\n\t  - (u64)y2 * (u64)x1;\n\ty = div_u64(y, x2 - x1);\n\n\tsof = y;\n\n\tuvc_dbg(stream->dev, CLOCK,\n\t\t\"%s: PTS %u y %llu.%06llu SOF %u.%06llu (x1 %u x2 %u y1 %u y2 %u SOF offset %u)\\n\",\n\t\tstream->dev->name, buf->pts,\n\t\ty >> 16, div_u64((y & 0xffff) * 1000000, 65536),\n\t\tsof >> 16, div_u64(((u64)sof & 0xffff) * 1000000LLU, 65536),\n\t\tx1, x2, y1, y2, clock->sof_offset);\n\n\t \n\tx1 = (uvc_video_clock_host_sof(first) + 2048) << 16;\n\tx2 = (uvc_video_clock_host_sof(last) + 2048) << 16;\n\tif (x2 < x1)\n\t\tx2 += 2048 << 16;\n\tif (x1 == x2)\n\t\tgoto done;\n\n\ty1 = NSEC_PER_SEC;\n\ty2 = (u32)ktime_to_ns(ktime_sub(last->host_time, first->host_time)) + y1;\n\n\t \n\tmean = (x1 + x2) / 2;\n\tif (mean - (1024 << 16) > sof)\n\t\tsof += 2048 << 16;\n\telse if (sof > mean + (1024 << 16))\n\t\tsof -= 2048 << 16;\n\n\ty = (u64)(y2 - y1) * (u64)sof + (u64)y1 * (u64)x2\n\t  - (u64)y2 * (u64)x1;\n\ty = div_u64(y, x2 - x1);\n\n\ttimestamp = ktime_to_ns(first->host_time) + y - y1;\n\n\tuvc_dbg(stream->dev, CLOCK,\n\t\t\"%s: SOF %u.%06llu y %llu ts %llu buf ts %llu (x1 %u/%u/%u x2 %u/%u/%u y1 %u y2 %u)\\n\",\n\t\tstream->dev->name,\n\t\tsof >> 16, div_u64(((u64)sof & 0xffff) * 1000000LLU, 65536),\n\t\ty, timestamp, vbuf->vb2_buf.timestamp,\n\t\tx1, first->host_sof, first->dev_sof,\n\t\tx2, last->host_sof, last->dev_sof, y1, y2);\n\n\t \n\tvbuf->vb2_buf.timestamp = timestamp;\n\ndone:\n\tspin_unlock_irqrestore(&clock->lock, flags);\n}\n\n \n\nstatic void uvc_video_stats_decode(struct uvc_streaming *stream,\n\t\tconst u8 *data, int len)\n{\n\tunsigned int header_size;\n\tbool has_pts = false;\n\tbool has_scr = false;\n\tu16 scr_sof;\n\tu32 scr_stc;\n\tu32 pts;\n\n\tif (stream->stats.stream.nb_frames == 0 &&\n\t    stream->stats.frame.nb_packets == 0)\n\t\tstream->stats.stream.start_ts = ktime_get();\n\n\tswitch (data[1] & (UVC_STREAM_PTS | UVC_STREAM_SCR)) {\n\tcase UVC_STREAM_PTS | UVC_STREAM_SCR:\n\t\theader_size = 12;\n\t\thas_pts = true;\n\t\thas_scr = true;\n\t\tbreak;\n\tcase UVC_STREAM_PTS:\n\t\theader_size = 6;\n\t\thas_pts = true;\n\t\tbreak;\n\tcase UVC_STREAM_SCR:\n\t\theader_size = 8;\n\t\thas_scr = true;\n\t\tbreak;\n\tdefault:\n\t\theader_size = 2;\n\t\tbreak;\n\t}\n\n\t \n\tif (len < header_size || data[0] < header_size) {\n\t\tstream->stats.frame.nb_invalid++;\n\t\treturn;\n\t}\n\n\t \n\tif (has_pts)\n\t\tpts = get_unaligned_le32(&data[2]);\n\n\tif (has_scr) {\n\t\tscr_stc = get_unaligned_le32(&data[header_size - 6]);\n\t\tscr_sof = get_unaligned_le16(&data[header_size - 2]);\n\t}\n\n\t \n\tif (has_pts && stream->stats.frame.nb_pts) {\n\t\tif (stream->stats.frame.pts != pts) {\n\t\t\tstream->stats.frame.nb_pts_diffs++;\n\t\t\tstream->stats.frame.last_pts_diff =\n\t\t\t\tstream->stats.frame.nb_packets;\n\t\t}\n\t}\n\n\tif (has_pts) {\n\t\tstream->stats.frame.nb_pts++;\n\t\tstream->stats.frame.pts = pts;\n\t}\n\n\t \n\tif (stream->stats.frame.size == 0) {\n\t\tif (len > header_size)\n\t\t\tstream->stats.frame.has_initial_pts = has_pts;\n\t\tif (len == header_size && has_pts)\n\t\t\tstream->stats.frame.has_early_pts = true;\n\t}\n\n\t \n\tif (has_scr && stream->stats.frame.nb_scr) {\n\t\tif (stream->stats.frame.scr_stc != scr_stc)\n\t\t\tstream->stats.frame.nb_scr_diffs++;\n\t}\n\n\tif (has_scr) {\n\t\t \n\t\tif (stream->stats.stream.nb_frames > 0 ||\n\t\t    stream->stats.frame.nb_scr > 0)\n\t\t\tstream->stats.stream.scr_sof_count +=\n\t\t\t\t(scr_sof - stream->stats.stream.scr_sof) % 2048;\n\t\tstream->stats.stream.scr_sof = scr_sof;\n\n\t\tstream->stats.frame.nb_scr++;\n\t\tstream->stats.frame.scr_stc = scr_stc;\n\t\tstream->stats.frame.scr_sof = scr_sof;\n\n\t\tif (scr_sof < stream->stats.stream.min_sof)\n\t\t\tstream->stats.stream.min_sof = scr_sof;\n\t\tif (scr_sof > stream->stats.stream.max_sof)\n\t\t\tstream->stats.stream.max_sof = scr_sof;\n\t}\n\n\t \n\tif (stream->stats.frame.size == 0 && len > header_size)\n\t\tstream->stats.frame.first_data = stream->stats.frame.nb_packets;\n\n\t \n\tstream->stats.frame.size += len - header_size;\n\n\t \n\tstream->stats.frame.nb_packets++;\n\tif (len <= header_size)\n\t\tstream->stats.frame.nb_empty++;\n\n\tif (data[1] & UVC_STREAM_ERR)\n\t\tstream->stats.frame.nb_errors++;\n}\n\nstatic void uvc_video_stats_update(struct uvc_streaming *stream)\n{\n\tstruct uvc_stats_frame *frame = &stream->stats.frame;\n\n\tuvc_dbg(stream->dev, STATS,\n\t\t\"frame %u stats: %u/%u/%u packets, %u/%u/%u pts (%searly %sinitial), %u/%u scr, last pts/stc/sof %u/%u/%u\\n\",\n\t\tstream->sequence, frame->first_data,\n\t\tframe->nb_packets - frame->nb_empty, frame->nb_packets,\n\t\tframe->nb_pts_diffs, frame->last_pts_diff, frame->nb_pts,\n\t\tframe->has_early_pts ? \"\" : \"!\",\n\t\tframe->has_initial_pts ? \"\" : \"!\",\n\t\tframe->nb_scr_diffs, frame->nb_scr,\n\t\tframe->pts, frame->scr_stc, frame->scr_sof);\n\n\tstream->stats.stream.nb_frames++;\n\tstream->stats.stream.nb_packets += stream->stats.frame.nb_packets;\n\tstream->stats.stream.nb_empty += stream->stats.frame.nb_empty;\n\tstream->stats.stream.nb_errors += stream->stats.frame.nb_errors;\n\tstream->stats.stream.nb_invalid += stream->stats.frame.nb_invalid;\n\n\tif (frame->has_early_pts)\n\t\tstream->stats.stream.nb_pts_early++;\n\tif (frame->has_initial_pts)\n\t\tstream->stats.stream.nb_pts_initial++;\n\tif (frame->last_pts_diff <= frame->first_data)\n\t\tstream->stats.stream.nb_pts_constant++;\n\tif (frame->nb_scr >= frame->nb_packets - frame->nb_empty)\n\t\tstream->stats.stream.nb_scr_count_ok++;\n\tif (frame->nb_scr_diffs + 1 == frame->nb_scr)\n\t\tstream->stats.stream.nb_scr_diffs_ok++;\n\n\tmemset(&stream->stats.frame, 0, sizeof(stream->stats.frame));\n}\n\nsize_t uvc_video_stats_dump(struct uvc_streaming *stream, char *buf,\n\t\t\t    size_t size)\n{\n\tunsigned int scr_sof_freq;\n\tunsigned int duration;\n\tsize_t count = 0;\n\n\t \n\tduration = ktime_ms_delta(stream->stats.stream.stop_ts,\n\t\t\t\t  stream->stats.stream.start_ts);\n\tif (duration != 0)\n\t\tscr_sof_freq = stream->stats.stream.scr_sof_count * 1000\n\t\t\t     / duration;\n\telse\n\t\tscr_sof_freq = 0;\n\n\tcount += scnprintf(buf + count, size - count,\n\t\t\t   \"frames:  %u\\npackets: %u\\nempty:   %u\\n\"\n\t\t\t   \"errors:  %u\\ninvalid: %u\\n\",\n\t\t\t   stream->stats.stream.nb_frames,\n\t\t\t   stream->stats.stream.nb_packets,\n\t\t\t   stream->stats.stream.nb_empty,\n\t\t\t   stream->stats.stream.nb_errors,\n\t\t\t   stream->stats.stream.nb_invalid);\n\tcount += scnprintf(buf + count, size - count,\n\t\t\t   \"pts: %u early, %u initial, %u ok\\n\",\n\t\t\t   stream->stats.stream.nb_pts_early,\n\t\t\t   stream->stats.stream.nb_pts_initial,\n\t\t\t   stream->stats.stream.nb_pts_constant);\n\tcount += scnprintf(buf + count, size - count,\n\t\t\t   \"scr: %u count ok, %u diff ok\\n\",\n\t\t\t   stream->stats.stream.nb_scr_count_ok,\n\t\t\t   stream->stats.stream.nb_scr_diffs_ok);\n\tcount += scnprintf(buf + count, size - count,\n\t\t\t   \"sof: %u <= sof <= %u, freq %u.%03u kHz\\n\",\n\t\t\t   stream->stats.stream.min_sof,\n\t\t\t   stream->stats.stream.max_sof,\n\t\t\t   scr_sof_freq / 1000, scr_sof_freq % 1000);\n\n\treturn count;\n}\n\nstatic void uvc_video_stats_start(struct uvc_streaming *stream)\n{\n\tmemset(&stream->stats, 0, sizeof(stream->stats));\n\tstream->stats.stream.min_sof = 2048;\n}\n\nstatic void uvc_video_stats_stop(struct uvc_streaming *stream)\n{\n\tstream->stats.stream.stop_ts = ktime_get();\n}\n\n \n\n \nstatic int uvc_video_decode_start(struct uvc_streaming *stream,\n\t\tstruct uvc_buffer *buf, const u8 *data, int len)\n{\n\tu8 fid;\n\n\t \n\tif (len < 2 || data[0] < 2 || data[0] > len) {\n\t\tstream->stats.frame.nb_invalid++;\n\t\treturn -EINVAL;\n\t}\n\n\tfid = data[1] & UVC_STREAM_FID;\n\n\t \n\tif (stream->last_fid != fid) {\n\t\tstream->sequence++;\n\t\tif (stream->sequence)\n\t\t\tuvc_video_stats_update(stream);\n\t}\n\n\tuvc_video_clock_decode(stream, buf, data, len);\n\tuvc_video_stats_decode(stream, data, len);\n\n\t \n\tif (buf == NULL) {\n\t\tstream->last_fid = fid;\n\t\treturn -ENODATA;\n\t}\n\n\t \n\tif (data[1] & UVC_STREAM_ERR) {\n\t\tuvc_dbg(stream->dev, FRAME,\n\t\t\t\"Marking buffer as bad (error bit set)\\n\");\n\t\tbuf->error = 1;\n\t}\n\n\t \n\tif (buf->state != UVC_BUF_STATE_ACTIVE) {\n\t\tif (fid == stream->last_fid) {\n\t\t\tuvc_dbg(stream->dev, FRAME,\n\t\t\t\t\"Dropping payload (out of sync)\\n\");\n\t\t\tif ((stream->dev->quirks & UVC_QUIRK_STREAM_NO_FID) &&\n\t\t\t    (data[1] & UVC_STREAM_EOF))\n\t\t\t\tstream->last_fid ^= UVC_STREAM_FID;\n\t\t\treturn -ENODATA;\n\t\t}\n\n\t\tbuf->buf.field = V4L2_FIELD_NONE;\n\t\tbuf->buf.sequence = stream->sequence;\n\t\tbuf->buf.vb2_buf.timestamp = ktime_to_ns(uvc_video_get_time());\n\n\t\t \n\t\tbuf->state = UVC_BUF_STATE_ACTIVE;\n\t}\n\n\t \n\tif (fid != stream->last_fid && buf->bytesused != 0) {\n\t\tuvc_dbg(stream->dev, FRAME,\n\t\t\t\"Frame complete (FID bit toggled)\\n\");\n\t\tbuf->state = UVC_BUF_STATE_READY;\n\t\treturn -EAGAIN;\n\t}\n\n\tstream->last_fid = fid;\n\n\treturn data[0];\n}\n\nstatic inline enum dma_data_direction uvc_stream_dir(\n\t\t\t\tstruct uvc_streaming *stream)\n{\n\tif (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn DMA_FROM_DEVICE;\n\telse\n\t\treturn DMA_TO_DEVICE;\n}\n\nstatic inline struct device *uvc_stream_to_dmadev(struct uvc_streaming *stream)\n{\n\treturn bus_to_hcd(stream->dev->udev->bus)->self.sysdev;\n}\n\nstatic int uvc_submit_urb(struct uvc_urb *uvc_urb, gfp_t mem_flags)\n{\n\t \n\tdma_sync_sgtable_for_device(uvc_stream_to_dmadev(uvc_urb->stream),\n\t\t\t\t    uvc_urb->sgt,\n\t\t\t\t    uvc_stream_dir(uvc_urb->stream));\n\treturn usb_submit_urb(uvc_urb->urb, mem_flags);\n}\n\n \nstatic void uvc_video_copy_data_work(struct work_struct *work)\n{\n\tstruct uvc_urb *uvc_urb = container_of(work, struct uvc_urb, work);\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < uvc_urb->async_operations; i++) {\n\t\tstruct uvc_copy_op *op = &uvc_urb->copy_operations[i];\n\n\t\tmemcpy(op->dst, op->src, op->len);\n\n\t\t \n\t\tuvc_queue_buffer_release(op->buf);\n\t}\n\n\tret = uvc_submit_urb(uvc_urb, GFP_KERNEL);\n\tif (ret < 0)\n\t\tdev_err(&uvc_urb->stream->intf->dev,\n\t\t\t\"Failed to resubmit video URB (%d).\\n\", ret);\n}\n\nstatic void uvc_video_decode_data(struct uvc_urb *uvc_urb,\n\t\tstruct uvc_buffer *buf, const u8 *data, int len)\n{\n\tunsigned int active_op = uvc_urb->async_operations;\n\tstruct uvc_copy_op *op = &uvc_urb->copy_operations[active_op];\n\tunsigned int maxlen;\n\n\tif (len <= 0)\n\t\treturn;\n\n\tmaxlen = buf->length - buf->bytesused;\n\n\t \n\tkref_get(&buf->ref);\n\n\top->buf = buf;\n\top->src = data;\n\top->dst = buf->mem + buf->bytesused;\n\top->len = min_t(unsigned int, len, maxlen);\n\n\tbuf->bytesused += op->len;\n\n\t \n\tif (len > maxlen) {\n\t\tuvc_dbg(uvc_urb->stream->dev, FRAME,\n\t\t\t\"Frame complete (overflow)\\n\");\n\t\tbuf->error = 1;\n\t\tbuf->state = UVC_BUF_STATE_READY;\n\t}\n\n\tuvc_urb->async_operations++;\n}\n\nstatic void uvc_video_decode_end(struct uvc_streaming *stream,\n\t\tstruct uvc_buffer *buf, const u8 *data, int len)\n{\n\t \n\tif (data[1] & UVC_STREAM_EOF && buf->bytesused != 0) {\n\t\tuvc_dbg(stream->dev, FRAME, \"Frame complete (EOF found)\\n\");\n\t\tif (data[0] == len)\n\t\t\tuvc_dbg(stream->dev, FRAME, \"EOF in empty payload\\n\");\n\t\tbuf->state = UVC_BUF_STATE_READY;\n\t\tif (stream->dev->quirks & UVC_QUIRK_STREAM_NO_FID)\n\t\t\tstream->last_fid ^= UVC_STREAM_FID;\n\t}\n}\n\n \nstatic int uvc_video_encode_header(struct uvc_streaming *stream,\n\t\tstruct uvc_buffer *buf, u8 *data, int len)\n{\n\tdata[0] = 2;\t \n\tdata[1] = UVC_STREAM_EOH | UVC_STREAM_EOF\n\t\t| (stream->last_fid & UVC_STREAM_FID);\n\treturn 2;\n}\n\nstatic int uvc_video_encode_data(struct uvc_streaming *stream,\n\t\tstruct uvc_buffer *buf, u8 *data, int len)\n{\n\tstruct uvc_video_queue *queue = &stream->queue;\n\tunsigned int nbytes;\n\tvoid *mem;\n\n\t \n\tmem = buf->mem + queue->buf_used;\n\tnbytes = min((unsigned int)len, buf->bytesused - queue->buf_used);\n\tnbytes = min(stream->bulk.max_payload_size - stream->bulk.payload_size,\n\t\t\tnbytes);\n\tmemcpy(data, mem, nbytes);\n\n\tqueue->buf_used += nbytes;\n\n\treturn nbytes;\n}\n\n \n\n \nstatic void uvc_video_decode_meta(struct uvc_streaming *stream,\n\t\t\t\t  struct uvc_buffer *meta_buf,\n\t\t\t\t  const u8 *mem, unsigned int length)\n{\n\tstruct uvc_meta_buf *meta;\n\tsize_t len_std = 2;\n\tbool has_pts, has_scr;\n\tunsigned long flags;\n\tunsigned int sof;\n\tktime_t time;\n\tconst u8 *scr;\n\n\tif (!meta_buf || length == 2)\n\t\treturn;\n\n\tif (meta_buf->length - meta_buf->bytesused <\n\t    length + sizeof(meta->ns) + sizeof(meta->sof)) {\n\t\tmeta_buf->error = 1;\n\t\treturn;\n\t}\n\n\thas_pts = mem[1] & UVC_STREAM_PTS;\n\thas_scr = mem[1] & UVC_STREAM_SCR;\n\n\tif (has_pts) {\n\t\tlen_std += 4;\n\t\tscr = mem + 6;\n\t} else {\n\t\tscr = mem + 2;\n\t}\n\n\tif (has_scr)\n\t\tlen_std += 6;\n\n\tif (stream->meta.format == V4L2_META_FMT_UVC)\n\t\tlength = len_std;\n\n\tif (length == len_std && (!has_scr ||\n\t\t\t\t  !memcmp(scr, stream->clock.last_scr, 6)))\n\t\treturn;\n\n\tmeta = (struct uvc_meta_buf *)((u8 *)meta_buf->mem + meta_buf->bytesused);\n\tlocal_irq_save(flags);\n\ttime = uvc_video_get_time();\n\tsof = usb_get_current_frame_number(stream->dev->udev);\n\tlocal_irq_restore(flags);\n\tput_unaligned(ktime_to_ns(time), &meta->ns);\n\tput_unaligned(sof, &meta->sof);\n\n\tif (has_scr)\n\t\tmemcpy(stream->clock.last_scr, scr, 6);\n\n\tmeta->length = mem[0];\n\tmeta->flags  = mem[1];\n\tmemcpy(meta->buf, &mem[2], length - 2);\n\tmeta_buf->bytesused += length + sizeof(meta->ns) + sizeof(meta->sof);\n\n\tuvc_dbg(stream->dev, FRAME,\n\t\t\"%s(): t-sys %lluns, SOF %u, len %u, flags 0x%x, PTS %u, STC %u frame SOF %u\\n\",\n\t\t__func__, ktime_to_ns(time), meta->sof, meta->length,\n\t\tmeta->flags,\n\t\thas_pts ? *(u32 *)meta->buf : 0,\n\t\thas_scr ? *(u32 *)scr : 0,\n\t\thas_scr ? *(u32 *)(scr + 4) & 0x7ff : 0);\n}\n\n \n\n \nstatic void uvc_video_validate_buffer(const struct uvc_streaming *stream,\n\t\t\t\t      struct uvc_buffer *buf)\n{\n\tif (stream->ctrl.dwMaxVideoFrameSize != buf->bytesused &&\n\t    !(stream->cur_format->flags & UVC_FMT_FLAG_COMPRESSED))\n\t\tbuf->error = 1;\n}\n\n \n\nstatic void uvc_video_next_buffers(struct uvc_streaming *stream,\n\t\tstruct uvc_buffer **video_buf, struct uvc_buffer **meta_buf)\n{\n\tuvc_video_validate_buffer(stream, *video_buf);\n\n\tif (*meta_buf) {\n\t\tstruct vb2_v4l2_buffer *vb2_meta = &(*meta_buf)->buf;\n\t\tconst struct vb2_v4l2_buffer *vb2_video = &(*video_buf)->buf;\n\n\t\tvb2_meta->sequence = vb2_video->sequence;\n\t\tvb2_meta->field = vb2_video->field;\n\t\tvb2_meta->vb2_buf.timestamp = vb2_video->vb2_buf.timestamp;\n\n\t\t(*meta_buf)->state = UVC_BUF_STATE_READY;\n\t\tif (!(*meta_buf)->error)\n\t\t\t(*meta_buf)->error = (*video_buf)->error;\n\t\t*meta_buf = uvc_queue_next_buffer(&stream->meta.queue,\n\t\t\t\t\t\t  *meta_buf);\n\t}\n\t*video_buf = uvc_queue_next_buffer(&stream->queue, *video_buf);\n}\n\nstatic void uvc_video_decode_isoc(struct uvc_urb *uvc_urb,\n\t\t\tstruct uvc_buffer *buf, struct uvc_buffer *meta_buf)\n{\n\tstruct urb *urb = uvc_urb->urb;\n\tstruct uvc_streaming *stream = uvc_urb->stream;\n\tu8 *mem;\n\tint ret, i;\n\n\tfor (i = 0; i < urb->number_of_packets; ++i) {\n\t\tif (urb->iso_frame_desc[i].status < 0) {\n\t\t\tuvc_dbg(stream->dev, FRAME,\n\t\t\t\t\"USB isochronous frame lost (%d)\\n\",\n\t\t\t\turb->iso_frame_desc[i].status);\n\t\t\t \n\t\t\tif (buf != NULL)\n\t\t\t\tbuf->error = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmem = urb->transfer_buffer + urb->iso_frame_desc[i].offset;\n\t\tdo {\n\t\t\tret = uvc_video_decode_start(stream, buf, mem,\n\t\t\t\turb->iso_frame_desc[i].actual_length);\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tuvc_video_next_buffers(stream, &buf, &meta_buf);\n\t\t} while (ret == -EAGAIN);\n\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tuvc_video_decode_meta(stream, meta_buf, mem, ret);\n\n\t\t \n\t\tuvc_video_decode_data(uvc_urb, buf, mem + ret,\n\t\t\turb->iso_frame_desc[i].actual_length - ret);\n\n\t\t \n\t\tuvc_video_decode_end(stream, buf, mem,\n\t\t\turb->iso_frame_desc[i].actual_length);\n\n\t\tif (buf->state == UVC_BUF_STATE_READY)\n\t\t\tuvc_video_next_buffers(stream, &buf, &meta_buf);\n\t}\n}\n\nstatic void uvc_video_decode_bulk(struct uvc_urb *uvc_urb,\n\t\t\tstruct uvc_buffer *buf, struct uvc_buffer *meta_buf)\n{\n\tstruct urb *urb = uvc_urb->urb;\n\tstruct uvc_streaming *stream = uvc_urb->stream;\n\tu8 *mem;\n\tint len, ret;\n\n\t \n\tif (urb->actual_length == 0 && stream->bulk.header_size == 0)\n\t\treturn;\n\n\tmem = urb->transfer_buffer;\n\tlen = urb->actual_length;\n\tstream->bulk.payload_size += len;\n\n\t \n\tif (stream->bulk.header_size == 0 && !stream->bulk.skip_payload) {\n\t\tdo {\n\t\t\tret = uvc_video_decode_start(stream, buf, mem, len);\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tuvc_video_next_buffers(stream, &buf, &meta_buf);\n\t\t} while (ret == -EAGAIN);\n\n\t\t \n\t\tif (ret < 0 || buf == NULL) {\n\t\t\tstream->bulk.skip_payload = 1;\n\t\t} else {\n\t\t\tmemcpy(stream->bulk.header, mem, ret);\n\t\t\tstream->bulk.header_size = ret;\n\n\t\t\tuvc_video_decode_meta(stream, meta_buf, mem, ret);\n\n\t\t\tmem += ret;\n\t\t\tlen -= ret;\n\t\t}\n\t}\n\n\t \n\n\t \n\tif (!stream->bulk.skip_payload && buf != NULL)\n\t\tuvc_video_decode_data(uvc_urb, buf, mem, len);\n\n\t \n\tif (urb->actual_length < urb->transfer_buffer_length ||\n\t    stream->bulk.payload_size >= stream->bulk.max_payload_size) {\n\t\tif (!stream->bulk.skip_payload && buf != NULL) {\n\t\t\tuvc_video_decode_end(stream, buf, stream->bulk.header,\n\t\t\t\tstream->bulk.payload_size);\n\t\t\tif (buf->state == UVC_BUF_STATE_READY)\n\t\t\t\tuvc_video_next_buffers(stream, &buf, &meta_buf);\n\t\t}\n\n\t\tstream->bulk.header_size = 0;\n\t\tstream->bulk.skip_payload = 0;\n\t\tstream->bulk.payload_size = 0;\n\t}\n}\n\nstatic void uvc_video_encode_bulk(struct uvc_urb *uvc_urb,\n\tstruct uvc_buffer *buf, struct uvc_buffer *meta_buf)\n{\n\tstruct urb *urb = uvc_urb->urb;\n\tstruct uvc_streaming *stream = uvc_urb->stream;\n\n\tu8 *mem = urb->transfer_buffer;\n\tint len = stream->urb_size, ret;\n\n\tif (buf == NULL) {\n\t\turb->transfer_buffer_length = 0;\n\t\treturn;\n\t}\n\n\t \n\tif (stream->bulk.header_size == 0) {\n\t\tret = uvc_video_encode_header(stream, buf, mem, len);\n\t\tstream->bulk.header_size = ret;\n\t\tstream->bulk.payload_size += ret;\n\t\tmem += ret;\n\t\tlen -= ret;\n\t}\n\n\t \n\tret = uvc_video_encode_data(stream, buf, mem, len);\n\n\tstream->bulk.payload_size += ret;\n\tlen -= ret;\n\n\tif (buf->bytesused == stream->queue.buf_used ||\n\t    stream->bulk.payload_size == stream->bulk.max_payload_size) {\n\t\tif (buf->bytesused == stream->queue.buf_used) {\n\t\t\tstream->queue.buf_used = 0;\n\t\t\tbuf->state = UVC_BUF_STATE_READY;\n\t\t\tbuf->buf.sequence = ++stream->sequence;\n\t\t\tuvc_queue_next_buffer(&stream->queue, buf);\n\t\t\tstream->last_fid ^= UVC_STREAM_FID;\n\t\t}\n\n\t\tstream->bulk.header_size = 0;\n\t\tstream->bulk.payload_size = 0;\n\t}\n\n\turb->transfer_buffer_length = stream->urb_size - len;\n}\n\nstatic void uvc_video_complete(struct urb *urb)\n{\n\tstruct uvc_urb *uvc_urb = urb->context;\n\tstruct uvc_streaming *stream = uvc_urb->stream;\n\tstruct uvc_video_queue *queue = &stream->queue;\n\tstruct uvc_video_queue *qmeta = &stream->meta.queue;\n\tstruct vb2_queue *vb2_qmeta = stream->meta.vdev.queue;\n\tstruct uvc_buffer *buf = NULL;\n\tstruct uvc_buffer *buf_meta = NULL;\n\tunsigned long flags;\n\tint ret;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&stream->intf->dev,\n\t\t\t \"Non-zero status (%d) in video completion handler.\\n\",\n\t\t\t urb->status);\n\t\tfallthrough;\n\tcase -ENOENT:\t\t \n\t\tif (stream->frozen)\n\t\t\treturn;\n\t\tfallthrough;\n\tcase -ECONNRESET:\t \n\tcase -ESHUTDOWN:\t \n\t\tuvc_queue_cancel(queue, urb->status == -ESHUTDOWN);\n\t\tif (vb2_qmeta)\n\t\t\tuvc_queue_cancel(qmeta, urb->status == -ESHUTDOWN);\n\t\treturn;\n\t}\n\n\tbuf = uvc_queue_get_current_buffer(queue);\n\n\tif (vb2_qmeta) {\n\t\tspin_lock_irqsave(&qmeta->irqlock, flags);\n\t\tif (!list_empty(&qmeta->irqqueue))\n\t\t\tbuf_meta = list_first_entry(&qmeta->irqqueue,\n\t\t\t\t\t\t    struct uvc_buffer, queue);\n\t\tspin_unlock_irqrestore(&qmeta->irqlock, flags);\n\t}\n\n\t \n\tuvc_urb->async_operations = 0;\n\n\t \n\tdma_sync_sgtable_for_cpu(uvc_stream_to_dmadev(uvc_urb->stream),\n\t\t\t\t uvc_urb->sgt, uvc_stream_dir(stream));\n\tinvalidate_kernel_vmap_range(uvc_urb->buffer,\n\t\t\t\t     uvc_urb->stream->urb_size);\n\n\t \n\tstream->decode(uvc_urb, buf, buf_meta);\n\n\t \n\tif (!uvc_urb->async_operations) {\n\t\tret = uvc_submit_urb(uvc_urb, GFP_ATOMIC);\n\t\tif (ret < 0)\n\t\t\tdev_err(&stream->intf->dev,\n\t\t\t\t\"Failed to resubmit video URB (%d).\\n\", ret);\n\t\treturn;\n\t}\n\n\tqueue_work(stream->async_wq, &uvc_urb->work);\n}\n\n \nstatic void uvc_free_urb_buffers(struct uvc_streaming *stream)\n{\n\tstruct device *dma_dev = uvc_stream_to_dmadev(stream);\n\tstruct uvc_urb *uvc_urb;\n\n\tfor_each_uvc_urb(uvc_urb, stream) {\n\t\tif (!uvc_urb->buffer)\n\t\t\tcontinue;\n\n\t\tdma_vunmap_noncontiguous(dma_dev, uvc_urb->buffer);\n\t\tdma_free_noncontiguous(dma_dev, stream->urb_size, uvc_urb->sgt,\n\t\t\t\t       uvc_stream_dir(stream));\n\n\t\tuvc_urb->buffer = NULL;\n\t\tuvc_urb->sgt = NULL;\n\t}\n\n\tstream->urb_size = 0;\n}\n\nstatic bool uvc_alloc_urb_buffer(struct uvc_streaming *stream,\n\t\t\t\t struct uvc_urb *uvc_urb, gfp_t gfp_flags)\n{\n\tstruct device *dma_dev = uvc_stream_to_dmadev(stream);\n\n\tuvc_urb->sgt = dma_alloc_noncontiguous(dma_dev, stream->urb_size,\n\t\t\t\t\t       uvc_stream_dir(stream),\n\t\t\t\t\t       gfp_flags, 0);\n\tif (!uvc_urb->sgt)\n\t\treturn false;\n\tuvc_urb->dma = uvc_urb->sgt->sgl->dma_address;\n\n\tuvc_urb->buffer = dma_vmap_noncontiguous(dma_dev, stream->urb_size,\n\t\t\t\t\t\t uvc_urb->sgt);\n\tif (!uvc_urb->buffer) {\n\t\tdma_free_noncontiguous(dma_dev, stream->urb_size,\n\t\t\t\t       uvc_urb->sgt,\n\t\t\t\t       uvc_stream_dir(stream));\n\t\tuvc_urb->sgt = NULL;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic int uvc_alloc_urb_buffers(struct uvc_streaming *stream,\n\tunsigned int size, unsigned int psize, gfp_t gfp_flags)\n{\n\tunsigned int npackets;\n\tunsigned int i;\n\n\t \n\tif (stream->urb_size)\n\t\treturn stream->urb_size / psize;\n\n\t \n\tnpackets = DIV_ROUND_UP(size, psize);\n\tif (npackets > UVC_MAX_PACKETS)\n\t\tnpackets = UVC_MAX_PACKETS;\n\n\t \n\tfor (; npackets > 1; npackets /= 2) {\n\t\tstream->urb_size = psize * npackets;\n\n\t\tfor (i = 0; i < UVC_URBS; ++i) {\n\t\t\tstruct uvc_urb *uvc_urb = &stream->uvc_urb[i];\n\n\t\t\tif (!uvc_alloc_urb_buffer(stream, uvc_urb, gfp_flags)) {\n\t\t\t\tuvc_free_urb_buffers(stream);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tuvc_urb->stream = stream;\n\t\t}\n\n\t\tif (i == UVC_URBS) {\n\t\t\tuvc_dbg(stream->dev, VIDEO,\n\t\t\t\t\"Allocated %u URB buffers of %ux%u bytes each\\n\",\n\t\t\t\tUVC_URBS, npackets, psize);\n\t\t\treturn npackets;\n\t\t}\n\t}\n\n\tuvc_dbg(stream->dev, VIDEO,\n\t\t\"Failed to allocate URB buffers (%u bytes per packet)\\n\",\n\t\tpsize);\n\treturn 0;\n}\n\n \nstatic void uvc_video_stop_transfer(struct uvc_streaming *stream,\n\t\t\t\t    int free_buffers)\n{\n\tstruct uvc_urb *uvc_urb;\n\n\tuvc_video_stats_stop(stream);\n\n\t \n\tfor_each_uvc_urb(uvc_urb, stream)\n\t\tusb_poison_urb(uvc_urb->urb);\n\n\tflush_workqueue(stream->async_wq);\n\n\tfor_each_uvc_urb(uvc_urb, stream) {\n\t\tusb_free_urb(uvc_urb->urb);\n\t\tuvc_urb->urb = NULL;\n\t}\n\n\tif (free_buffers)\n\t\tuvc_free_urb_buffers(stream);\n}\n\n \nu16 uvc_endpoint_max_bpi(struct usb_device *dev, struct usb_host_endpoint *ep)\n{\n\tu16 psize;\n\n\tswitch (dev->speed) {\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_SUPER_PLUS:\n\t\treturn le16_to_cpu(ep->ss_ep_comp.wBytesPerInterval);\n\tdefault:\n\t\tpsize = usb_endpoint_maxp(&ep->desc);\n\t\tpsize *= usb_endpoint_maxp_mult(&ep->desc);\n\t\treturn psize;\n\t}\n}\n\n \nstatic int uvc_init_video_isoc(struct uvc_streaming *stream,\n\tstruct usb_host_endpoint *ep, gfp_t gfp_flags)\n{\n\tstruct urb *urb;\n\tstruct uvc_urb *uvc_urb;\n\tunsigned int npackets, i;\n\tu16 psize;\n\tu32 size;\n\n\tpsize = uvc_endpoint_max_bpi(stream->dev->udev, ep);\n\tsize = stream->ctrl.dwMaxVideoFrameSize;\n\n\tnpackets = uvc_alloc_urb_buffers(stream, size, psize, gfp_flags);\n\tif (npackets == 0)\n\t\treturn -ENOMEM;\n\n\tsize = npackets * psize;\n\n\tfor_each_uvc_urb(uvc_urb, stream) {\n\t\turb = usb_alloc_urb(npackets, gfp_flags);\n\t\tif (urb == NULL) {\n\t\t\tuvc_video_stop_transfer(stream, 1);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\turb->dev = stream->dev->udev;\n\t\turb->context = uvc_urb;\n\t\turb->pipe = usb_rcvisocpipe(stream->dev->udev,\n\t\t\t\tep->desc.bEndpointAddress);\n\t\turb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\n\t\turb->transfer_dma = uvc_urb->dma;\n\t\turb->interval = ep->desc.bInterval;\n\t\turb->transfer_buffer = uvc_urb->buffer;\n\t\turb->complete = uvc_video_complete;\n\t\turb->number_of_packets = npackets;\n\t\turb->transfer_buffer_length = size;\n\n\t\tfor (i = 0; i < npackets; ++i) {\n\t\t\turb->iso_frame_desc[i].offset = i * psize;\n\t\t\turb->iso_frame_desc[i].length = psize;\n\t\t}\n\n\t\tuvc_urb->urb = urb;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int uvc_init_video_bulk(struct uvc_streaming *stream,\n\tstruct usb_host_endpoint *ep, gfp_t gfp_flags)\n{\n\tstruct urb *urb;\n\tstruct uvc_urb *uvc_urb;\n\tunsigned int npackets, pipe;\n\tu16 psize;\n\tu32 size;\n\n\tpsize = usb_endpoint_maxp(&ep->desc);\n\tsize = stream->ctrl.dwMaxPayloadTransferSize;\n\tstream->bulk.max_payload_size = size;\n\n\tnpackets = uvc_alloc_urb_buffers(stream, size, psize, gfp_flags);\n\tif (npackets == 0)\n\t\treturn -ENOMEM;\n\n\tsize = npackets * psize;\n\n\tif (usb_endpoint_dir_in(&ep->desc))\n\t\tpipe = usb_rcvbulkpipe(stream->dev->udev,\n\t\t\t\t       ep->desc.bEndpointAddress);\n\telse\n\t\tpipe = usb_sndbulkpipe(stream->dev->udev,\n\t\t\t\t       ep->desc.bEndpointAddress);\n\n\tif (stream->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\tsize = 0;\n\n\tfor_each_uvc_urb(uvc_urb, stream) {\n\t\turb = usb_alloc_urb(0, gfp_flags);\n\t\tif (urb == NULL) {\n\t\t\tuvc_video_stop_transfer(stream, 1);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tusb_fill_bulk_urb(urb, stream->dev->udev, pipe,\tuvc_urb->buffer,\n\t\t\t\t  size, uvc_video_complete, uvc_urb);\n\t\turb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\t\turb->transfer_dma = uvc_urb->dma;\n\n\t\tuvc_urb->urb = urb;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int uvc_video_start_transfer(struct uvc_streaming *stream,\n\t\t\t\t    gfp_t gfp_flags)\n{\n\tstruct usb_interface *intf = stream->intf;\n\tstruct usb_host_endpoint *ep;\n\tstruct uvc_urb *uvc_urb;\n\tunsigned int i;\n\tint ret;\n\n\tstream->sequence = -1;\n\tstream->last_fid = -1;\n\tstream->bulk.header_size = 0;\n\tstream->bulk.skip_payload = 0;\n\tstream->bulk.payload_size = 0;\n\n\tuvc_video_stats_start(stream);\n\n\tif (intf->num_altsetting > 1) {\n\t\tstruct usb_host_endpoint *best_ep = NULL;\n\t\tunsigned int best_psize = UINT_MAX;\n\t\tunsigned int bandwidth;\n\t\tunsigned int altsetting;\n\t\tint intfnum = stream->intfnum;\n\n\t\t \n\t\tbandwidth = stream->ctrl.dwMaxPayloadTransferSize;\n\n\t\tif (bandwidth == 0) {\n\t\t\tuvc_dbg(stream->dev, VIDEO,\n\t\t\t\t\"Device requested null bandwidth, defaulting to lowest\\n\");\n\t\t\tbandwidth = 1;\n\t\t} else {\n\t\t\tuvc_dbg(stream->dev, VIDEO,\n\t\t\t\t\"Device requested %u B/frame bandwidth\\n\",\n\t\t\t\tbandwidth);\n\t\t}\n\n\t\tfor (i = 0; i < intf->num_altsetting; ++i) {\n\t\t\tstruct usb_host_interface *alts;\n\t\t\tunsigned int psize;\n\n\t\t\talts = &intf->altsetting[i];\n\t\t\tep = uvc_find_endpoint(alts,\n\t\t\t\tstream->header.bEndpointAddress);\n\t\t\tif (ep == NULL)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tpsize = uvc_endpoint_max_bpi(stream->dev->udev, ep);\n\t\t\tif (psize >= bandwidth && psize <= best_psize) {\n\t\t\t\taltsetting = alts->desc.bAlternateSetting;\n\t\t\t\tbest_psize = psize;\n\t\t\t\tbest_ep = ep;\n\t\t\t}\n\t\t}\n\n\t\tif (best_ep == NULL) {\n\t\t\tuvc_dbg(stream->dev, VIDEO,\n\t\t\t\t\"No fast enough alt setting for requested bandwidth\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tuvc_dbg(stream->dev, VIDEO,\n\t\t\t\"Selecting alternate setting %u (%u B/frame bandwidth)\\n\",\n\t\t\taltsetting, best_psize);\n\n\t\t \n\t\tif (stream->dev->quirks & UVC_QUIRK_WAKE_AUTOSUSPEND) {\n\t\t\tusb_set_interface(stream->dev->udev, intfnum,\n\t\t\t\t\t  altsetting);\n\t\t\tusb_set_interface(stream->dev->udev, intfnum, 0);\n\t\t}\n\n\t\tret = usb_set_interface(stream->dev->udev, intfnum, altsetting);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = uvc_init_video_isoc(stream, best_ep, gfp_flags);\n\t} else {\n\t\t \n\t\tep = uvc_find_endpoint(&intf->altsetting[0],\n\t\t\t\tstream->header.bEndpointAddress);\n\t\tif (ep == NULL)\n\t\t\treturn -EIO;\n\n\t\t \n\t\tif (usb_endpoint_maxp(&ep->desc) == 0)\n\t\t\treturn -EIO;\n\n\t\tret = uvc_init_video_bulk(stream, ep, gfp_flags);\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfor_each_uvc_urb(uvc_urb, stream) {\n\t\tret = uvc_submit_urb(uvc_urb, gfp_flags);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&stream->intf->dev,\n\t\t\t\t\"Failed to submit URB %u (%d).\\n\",\n\t\t\t\tuvc_urb_index(uvc_urb), ret);\n\t\t\tuvc_video_stop_transfer(stream, 1);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (stream->dev->quirks & UVC_QUIRK_RESTORE_CTRLS_ON_INIT)\n\t\tuvc_ctrl_restore_values(stream->dev);\n\n\treturn 0;\n}\n\n \n\n \nint uvc_video_suspend(struct uvc_streaming *stream)\n{\n\tif (!uvc_queue_streaming(&stream->queue))\n\t\treturn 0;\n\n\tstream->frozen = 1;\n\tuvc_video_stop_transfer(stream, 0);\n\tusb_set_interface(stream->dev->udev, stream->intfnum, 0);\n\treturn 0;\n}\n\n \nint uvc_video_resume(struct uvc_streaming *stream, int reset)\n{\n\tint ret;\n\n\t \n\tif (reset)\n\t\tusb_set_interface(stream->dev->udev, stream->intfnum, 0);\n\n\tstream->frozen = 0;\n\n\tuvc_video_clock_reset(stream);\n\n\tif (!uvc_queue_streaming(&stream->queue))\n\t\treturn 0;\n\n\tret = uvc_commit_video(stream, &stream->ctrl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn uvc_video_start_transfer(stream, GFP_NOIO);\n}\n\n \n\n \nint uvc_video_init(struct uvc_streaming *stream)\n{\n\tstruct uvc_streaming_control *probe = &stream->ctrl;\n\tconst struct uvc_format *format = NULL;\n\tconst struct uvc_frame *frame = NULL;\n\tstruct uvc_urb *uvc_urb;\n\tunsigned int i;\n\tint ret;\n\n\tif (stream->nformats == 0) {\n\t\tdev_info(&stream->intf->dev,\n\t\t\t \"No supported video formats found.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tatomic_set(&stream->active, 0);\n\n\t \n\tusb_set_interface(stream->dev->udev, stream->intfnum, 0);\n\n\t \n\tif (uvc_get_video_ctrl(stream, probe, 1, UVC_GET_DEF) == 0)\n\t\tuvc_set_video_ctrl(stream, probe, 1);\n\n\t \n\tret = uvc_get_video_ctrl(stream, probe, 1, UVC_GET_CUR);\n\n\t \n\tif (ret == -EPROTO &&\n\t    usb_match_one_id(stream->dev->intf, &elgato_cam_link_4k)) {\n\t\tdev_err(&stream->intf->dev, \"Elgato Cam Link 4K firmware crash detected\\n\");\n\t\tdev_err(&stream->intf->dev, \"Resetting the device, unplug and replug to recover\\n\");\n\t\tusb_reset_device(stream->dev->udev);\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfor (i = stream->nformats; i > 0; --i) {\n\t\tformat = &stream->formats[i-1];\n\t\tif (format->index == probe->bFormatIndex)\n\t\t\tbreak;\n\t}\n\n\tif (format->nframes == 0) {\n\t\tdev_info(&stream->intf->dev,\n\t\t\t \"No frame descriptor found for the default format.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = format->nframes; i > 0; --i) {\n\t\tframe = &format->frames[i-1];\n\t\tif (frame->bFrameIndex == probe->bFrameIndex)\n\t\t\tbreak;\n\t}\n\n\tprobe->bFormatIndex = format->index;\n\tprobe->bFrameIndex = frame->bFrameIndex;\n\n\tstream->def_format = format;\n\tstream->cur_format = format;\n\tstream->cur_frame = frame;\n\n\t \n\tif (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tif (stream->dev->quirks & UVC_QUIRK_BUILTIN_ISIGHT)\n\t\t\tstream->decode = uvc_video_decode_isight;\n\t\telse if (stream->intf->num_altsetting > 1)\n\t\t\tstream->decode = uvc_video_decode_isoc;\n\t\telse\n\t\t\tstream->decode = uvc_video_decode_bulk;\n\t} else {\n\t\tif (stream->intf->num_altsetting == 1)\n\t\t\tstream->decode = uvc_video_encode_bulk;\n\t\telse {\n\t\t\tdev_info(&stream->intf->dev,\n\t\t\t\t \"Isochronous endpoints are not supported for video output devices.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tfor_each_uvc_urb(uvc_urb, stream)\n\t\tINIT_WORK(&uvc_urb->work, uvc_video_copy_data_work);\n\n\treturn 0;\n}\n\nint uvc_video_start_streaming(struct uvc_streaming *stream)\n{\n\tint ret;\n\n\tret = uvc_video_clock_init(stream);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = uvc_commit_video(stream, &stream->ctrl);\n\tif (ret < 0)\n\t\tgoto error_commit;\n\n\tret = uvc_video_start_transfer(stream, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto error_video;\n\n\treturn 0;\n\nerror_video:\n\tusb_set_interface(stream->dev->udev, stream->intfnum, 0);\nerror_commit:\n\tuvc_video_clock_cleanup(stream);\n\n\treturn ret;\n}\n\nvoid uvc_video_stop_streaming(struct uvc_streaming *stream)\n{\n\tuvc_video_stop_transfer(stream, 1);\n\n\tif (stream->intf->num_altsetting > 1) {\n\t\tusb_set_interface(stream->dev->udev, stream->intfnum, 0);\n\t} else {\n\t\t \n\t\tunsigned int epnum = stream->header.bEndpointAddress\n\t\t\t\t   & USB_ENDPOINT_NUMBER_MASK;\n\t\tunsigned int dir = stream->header.bEndpointAddress\n\t\t\t\t & USB_ENDPOINT_DIR_MASK;\n\t\tunsigned int pipe;\n\n\t\tpipe = usb_sndbulkpipe(stream->dev->udev, epnum) | dir;\n\t\tusb_clear_halt(stream->dev->udev, pipe);\n\t}\n\n\tuvc_video_clock_cleanup(stream);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}