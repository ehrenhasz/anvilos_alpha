{
  "module_name": "uvc_queue.c",
  "hash_id": "2cffb00e9fc0d3dae5ec49a556002ff7dee9f28b34798c765eed32efcb3f5450",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/uvc/uvc_queue.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/videodev2.h>\n#include <linux/vmalloc.h>\n#include <linux/wait.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-vmalloc.h>\n\n#include \"uvcvideo.h\"\n\n \n\nstatic inline struct uvc_buffer *uvc_vbuf_to_buffer(struct vb2_v4l2_buffer *buf)\n{\n\treturn container_of(buf, struct uvc_buffer, buf);\n}\n\n \nstatic void uvc_queue_return_buffers(struct uvc_video_queue *queue,\n\t\t\t       enum uvc_buffer_state state)\n{\n\tenum vb2_buffer_state vb2_state = state == UVC_BUF_STATE_ERROR\n\t\t\t\t\t? VB2_BUF_STATE_ERROR\n\t\t\t\t\t: VB2_BUF_STATE_QUEUED;\n\n\twhile (!list_empty(&queue->irqqueue)) {\n\t\tstruct uvc_buffer *buf = list_first_entry(&queue->irqqueue,\n\t\t\t\t\t\t\t  struct uvc_buffer,\n\t\t\t\t\t\t\t  queue);\n\t\tlist_del(&buf->queue);\n\t\tbuf->state = state;\n\t\tvb2_buffer_done(&buf->buf.vb2_buf, vb2_state);\n\t}\n}\n\n \n\nstatic int uvc_queue_setup(struct vb2_queue *vq,\n\t\t\t   unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t   unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct uvc_video_queue *queue = vb2_get_drv_priv(vq);\n\tstruct uvc_streaming *stream;\n\tunsigned int size;\n\n\tswitch (vq->type) {\n\tcase V4L2_BUF_TYPE_META_CAPTURE:\n\t\tsize = UVC_METADATA_BUF_SIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tstream = uvc_queue_to_stream(queue);\n\t\tsize = stream->ctrl.dwMaxVideoFrameSize;\n\t\tbreak;\n\t}\n\n\t \n\tif (*nplanes)\n\t\treturn *nplanes != 1 || sizes[0] < size ? -EINVAL : 0;\n\n\t*nplanes = 1;\n\tsizes[0] = size;\n\treturn 0;\n}\n\nstatic int uvc_buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct uvc_video_queue *queue = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct uvc_buffer *buf = uvc_vbuf_to_buffer(vbuf);\n\n\tif (vb->type == V4L2_BUF_TYPE_VIDEO_OUTPUT &&\n\t    vb2_get_plane_payload(vb, 0) > vb2_plane_size(vb, 0)) {\n\t\tuvc_dbg(uvc_queue_to_stream(queue)->dev, CAPTURE,\n\t\t\t\"[E] Bytes used out of bounds\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(queue->flags & UVC_QUEUE_DISCONNECTED))\n\t\treturn -ENODEV;\n\n\tbuf->state = UVC_BUF_STATE_QUEUED;\n\tbuf->error = 0;\n\tbuf->mem = vb2_plane_vaddr(vb, 0);\n\tbuf->length = vb2_plane_size(vb, 0);\n\tif (vb->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\tbuf->bytesused = 0;\n\telse\n\t\tbuf->bytesused = vb2_get_plane_payload(vb, 0);\n\n\treturn 0;\n}\n\nstatic void uvc_buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct uvc_video_queue *queue = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct uvc_buffer *buf = uvc_vbuf_to_buffer(vbuf);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&queue->irqlock, flags);\n\tif (likely(!(queue->flags & UVC_QUEUE_DISCONNECTED))) {\n\t\tkref_init(&buf->ref);\n\t\tlist_add_tail(&buf->queue, &queue->irqqueue);\n\t} else {\n\t\t \n\t\tbuf->state = UVC_BUF_STATE_ERROR;\n\t\tvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\n\t}\n\n\tspin_unlock_irqrestore(&queue->irqlock, flags);\n}\n\nstatic void uvc_buffer_finish(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct uvc_video_queue *queue = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct uvc_streaming *stream = uvc_queue_to_stream(queue);\n\tstruct uvc_buffer *buf = uvc_vbuf_to_buffer(vbuf);\n\n\tif (vb->state == VB2_BUF_STATE_DONE)\n\t\tuvc_video_clock_update(stream, vbuf, buf);\n}\n\nstatic int uvc_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct uvc_video_queue *queue = vb2_get_drv_priv(vq);\n\tstruct uvc_streaming *stream = uvc_queue_to_stream(queue);\n\tint ret;\n\n\tlockdep_assert_irqs_enabled();\n\n\tqueue->buf_used = 0;\n\n\tret = uvc_video_start_streaming(stream);\n\tif (ret == 0)\n\t\treturn 0;\n\n\tspin_lock_irq(&queue->irqlock);\n\tuvc_queue_return_buffers(queue, UVC_BUF_STATE_QUEUED);\n\tspin_unlock_irq(&queue->irqlock);\n\n\treturn ret;\n}\n\nstatic void uvc_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct uvc_video_queue *queue = vb2_get_drv_priv(vq);\n\n\tlockdep_assert_irqs_enabled();\n\n\tif (vq->type != V4L2_BUF_TYPE_META_CAPTURE)\n\t\tuvc_video_stop_streaming(uvc_queue_to_stream(queue));\n\n\tspin_lock_irq(&queue->irqlock);\n\tuvc_queue_return_buffers(queue, UVC_BUF_STATE_ERROR);\n\tspin_unlock_irq(&queue->irqlock);\n}\n\nstatic const struct vb2_ops uvc_queue_qops = {\n\t.queue_setup = uvc_queue_setup,\n\t.buf_prepare = uvc_buffer_prepare,\n\t.buf_queue = uvc_buffer_queue,\n\t.buf_finish = uvc_buffer_finish,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n\t.start_streaming = uvc_start_streaming,\n\t.stop_streaming = uvc_stop_streaming,\n};\n\nstatic const struct vb2_ops uvc_meta_queue_qops = {\n\t.queue_setup = uvc_queue_setup,\n\t.buf_prepare = uvc_buffer_prepare,\n\t.buf_queue = uvc_buffer_queue,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n\t.stop_streaming = uvc_stop_streaming,\n};\n\nint uvc_queue_init(struct uvc_video_queue *queue, enum v4l2_buf_type type,\n\t\t    int drop_corrupted)\n{\n\tint ret;\n\n\tqueue->queue.type = type;\n\tqueue->queue.io_modes = VB2_MMAP | VB2_USERPTR;\n\tqueue->queue.drv_priv = queue;\n\tqueue->queue.buf_struct_size = sizeof(struct uvc_buffer);\n\tqueue->queue.mem_ops = &vb2_vmalloc_memops;\n\tqueue->queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC\n\t\t| V4L2_BUF_FLAG_TSTAMP_SRC_SOE;\n\tqueue->queue.lock = &queue->mutex;\n\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_META_CAPTURE:\n\t\tqueue->queue.ops = &uvc_meta_queue_qops;\n\t\tbreak;\n\tdefault:\n\t\tqueue->queue.io_modes |= VB2_DMABUF;\n\t\tqueue->queue.ops = &uvc_queue_qops;\n\t\tbreak;\n\t}\n\n\tret = vb2_queue_init(&queue->queue);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&queue->mutex);\n\tspin_lock_init(&queue->irqlock);\n\tINIT_LIST_HEAD(&queue->irqqueue);\n\tqueue->flags = drop_corrupted ? UVC_QUEUE_DROP_CORRUPTED : 0;\n\n\treturn 0;\n}\n\nvoid uvc_queue_release(struct uvc_video_queue *queue)\n{\n\tmutex_lock(&queue->mutex);\n\tvb2_queue_release(&queue->queue);\n\tmutex_unlock(&queue->mutex);\n}\n\n \n\nint uvc_request_buffers(struct uvc_video_queue *queue,\n\t\t\tstruct v4l2_requestbuffers *rb)\n{\n\tint ret;\n\n\tmutex_lock(&queue->mutex);\n\tret = vb2_reqbufs(&queue->queue, rb);\n\tmutex_unlock(&queue->mutex);\n\n\treturn ret ? ret : rb->count;\n}\n\nint uvc_query_buffer(struct uvc_video_queue *queue, struct v4l2_buffer *buf)\n{\n\tint ret;\n\n\tmutex_lock(&queue->mutex);\n\tret = vb2_querybuf(&queue->queue, buf);\n\tmutex_unlock(&queue->mutex);\n\n\treturn ret;\n}\n\nint uvc_create_buffers(struct uvc_video_queue *queue,\n\t\t       struct v4l2_create_buffers *cb)\n{\n\tint ret;\n\n\tmutex_lock(&queue->mutex);\n\tret = vb2_create_bufs(&queue->queue, cb);\n\tmutex_unlock(&queue->mutex);\n\n\treturn ret;\n}\n\nint uvc_queue_buffer(struct uvc_video_queue *queue,\n\t\t     struct media_device *mdev, struct v4l2_buffer *buf)\n{\n\tint ret;\n\n\tmutex_lock(&queue->mutex);\n\tret = vb2_qbuf(&queue->queue, mdev, buf);\n\tmutex_unlock(&queue->mutex);\n\n\treturn ret;\n}\n\nint uvc_export_buffer(struct uvc_video_queue *queue,\n\t\t      struct v4l2_exportbuffer *exp)\n{\n\tint ret;\n\n\tmutex_lock(&queue->mutex);\n\tret = vb2_expbuf(&queue->queue, exp);\n\tmutex_unlock(&queue->mutex);\n\n\treturn ret;\n}\n\nint uvc_dequeue_buffer(struct uvc_video_queue *queue, struct v4l2_buffer *buf,\n\t\t       int nonblocking)\n{\n\tint ret;\n\n\tmutex_lock(&queue->mutex);\n\tret = vb2_dqbuf(&queue->queue, buf, nonblocking);\n\tmutex_unlock(&queue->mutex);\n\n\treturn ret;\n}\n\nint uvc_queue_streamon(struct uvc_video_queue *queue, enum v4l2_buf_type type)\n{\n\tint ret;\n\n\tmutex_lock(&queue->mutex);\n\tret = vb2_streamon(&queue->queue, type);\n\tmutex_unlock(&queue->mutex);\n\n\treturn ret;\n}\n\nint uvc_queue_streamoff(struct uvc_video_queue *queue, enum v4l2_buf_type type)\n{\n\tint ret;\n\n\tmutex_lock(&queue->mutex);\n\tret = vb2_streamoff(&queue->queue, type);\n\tmutex_unlock(&queue->mutex);\n\n\treturn ret;\n}\n\nint uvc_queue_mmap(struct uvc_video_queue *queue, struct vm_area_struct *vma)\n{\n\treturn vb2_mmap(&queue->queue, vma);\n}\n\n#ifndef CONFIG_MMU\nunsigned long uvc_queue_get_unmapped_area(struct uvc_video_queue *queue,\n\t\tunsigned long pgoff)\n{\n\treturn vb2_get_unmapped_area(&queue->queue, 0, 0, pgoff, 0);\n}\n#endif\n\n__poll_t uvc_queue_poll(struct uvc_video_queue *queue, struct file *file,\n\t\t\t    poll_table *wait)\n{\n\t__poll_t ret;\n\n\tmutex_lock(&queue->mutex);\n\tret = vb2_poll(&queue->queue, file, wait);\n\tmutex_unlock(&queue->mutex);\n\n\treturn ret;\n}\n\n \n\n \nint uvc_queue_allocated(struct uvc_video_queue *queue)\n{\n\tint allocated;\n\n\tmutex_lock(&queue->mutex);\n\tallocated = vb2_is_busy(&queue->queue);\n\tmutex_unlock(&queue->mutex);\n\n\treturn allocated;\n}\n\n \nvoid uvc_queue_cancel(struct uvc_video_queue *queue, int disconnect)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&queue->irqlock, flags);\n\tuvc_queue_return_buffers(queue, UVC_BUF_STATE_ERROR);\n\t \n\tif (disconnect)\n\t\tqueue->flags |= UVC_QUEUE_DISCONNECTED;\n\tspin_unlock_irqrestore(&queue->irqlock, flags);\n}\n\n \nstatic struct uvc_buffer *\n__uvc_queue_get_current_buffer(struct uvc_video_queue *queue)\n{\n\tif (list_empty(&queue->irqqueue))\n\t\treturn NULL;\n\n\treturn list_first_entry(&queue->irqqueue, struct uvc_buffer, queue);\n}\n\nstruct uvc_buffer *uvc_queue_get_current_buffer(struct uvc_video_queue *queue)\n{\n\tstruct uvc_buffer *nextbuf;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&queue->irqlock, flags);\n\tnextbuf = __uvc_queue_get_current_buffer(queue);\n\tspin_unlock_irqrestore(&queue->irqlock, flags);\n\n\treturn nextbuf;\n}\n\n \nstatic void uvc_queue_buffer_requeue(struct uvc_video_queue *queue,\n\t\tstruct uvc_buffer *buf)\n{\n\tbuf->error = 0;\n\tbuf->state = UVC_BUF_STATE_QUEUED;\n\tbuf->bytesused = 0;\n\tvb2_set_plane_payload(&buf->buf.vb2_buf, 0, 0);\n\n\tuvc_buffer_queue(&buf->buf.vb2_buf);\n}\n\nstatic void uvc_queue_buffer_complete(struct kref *ref)\n{\n\tstruct uvc_buffer *buf = container_of(ref, struct uvc_buffer, ref);\n\tstruct vb2_buffer *vb = &buf->buf.vb2_buf;\n\tstruct uvc_video_queue *queue = vb2_get_drv_priv(vb->vb2_queue);\n\n\tif ((queue->flags & UVC_QUEUE_DROP_CORRUPTED) && buf->error) {\n\t\tuvc_queue_buffer_requeue(queue, buf);\n\t\treturn;\n\t}\n\n\tbuf->state = buf->error ? UVC_BUF_STATE_ERROR : UVC_BUF_STATE_DONE;\n\tvb2_set_plane_payload(&buf->buf.vb2_buf, 0, buf->bytesused);\n\tvb2_buffer_done(&buf->buf.vb2_buf, VB2_BUF_STATE_DONE);\n}\n\n \nvoid uvc_queue_buffer_release(struct uvc_buffer *buf)\n{\n\tkref_put(&buf->ref, uvc_queue_buffer_complete);\n}\n\n \nstruct uvc_buffer *uvc_queue_next_buffer(struct uvc_video_queue *queue,\n\t\tstruct uvc_buffer *buf)\n{\n\tstruct uvc_buffer *nextbuf;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&queue->irqlock, flags);\n\tlist_del(&buf->queue);\n\tnextbuf = __uvc_queue_get_current_buffer(queue);\n\tspin_unlock_irqrestore(&queue->irqlock, flags);\n\n\tuvc_queue_buffer_release(buf);\n\n\treturn nextbuf;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}