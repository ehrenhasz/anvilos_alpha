{
  "module_name": "uvc_driver.c",
  "hash_id": "4edb1095a68a352742f1992820cf358cea5771404ece87e57acfa7ac5a42f83b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/uvc/uvc_driver.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/bits.h>\n#include <linux/gpio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/uvc.h>\n#include <linux/videodev2.h>\n#include <linux/vmalloc.h>\n#include <linux/wait.h>\n#include <asm/unaligned.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n\n#include \"uvcvideo.h\"\n\n#define DRIVER_AUTHOR\t\t\"Laurent Pinchart \" \\\n\t\t\t\t\"<laurent.pinchart@ideasonboard.com>\"\n#define DRIVER_DESC\t\t\"USB Video Class driver\"\n\nunsigned int uvc_clock_param = CLOCK_MONOTONIC;\nunsigned int uvc_hw_timestamps_param;\nunsigned int uvc_no_drop_param;\nstatic unsigned int uvc_quirks_param = -1;\nunsigned int uvc_dbg_param;\nunsigned int uvc_timeout_param = UVC_CTRL_STREAMING_TIMEOUT;\n\n \n\nstruct usb_host_endpoint *uvc_find_endpoint(struct usb_host_interface *alts,\n\t\tu8 epaddr)\n{\n\tstruct usb_host_endpoint *ep;\n\tunsigned int i;\n\n\tfor (i = 0; i < alts->desc.bNumEndpoints; ++i) {\n\t\tep = &alts->endpoint[i];\n\t\tif (ep->desc.bEndpointAddress == epaddr)\n\t\t\treturn ep;\n\t}\n\n\treturn NULL;\n}\n\nstatic enum v4l2_colorspace uvc_colorspace(const u8 primaries)\n{\n\tstatic const enum v4l2_colorspace colorprimaries[] = {\n\t\tV4L2_COLORSPACE_SRGB,   \n\t\tV4L2_COLORSPACE_SRGB,\n\t\tV4L2_COLORSPACE_470_SYSTEM_M,\n\t\tV4L2_COLORSPACE_470_SYSTEM_BG,\n\t\tV4L2_COLORSPACE_SMPTE170M,\n\t\tV4L2_COLORSPACE_SMPTE240M,\n\t};\n\n\tif (primaries < ARRAY_SIZE(colorprimaries))\n\t\treturn colorprimaries[primaries];\n\n\treturn V4L2_COLORSPACE_SRGB;   \n}\n\nstatic enum v4l2_xfer_func uvc_xfer_func(const u8 transfer_characteristics)\n{\n\t \n\tstatic const enum v4l2_xfer_func xfer_funcs[] = {\n\t\tV4L2_XFER_FUNC_DEFAULT,     \n\t\tV4L2_XFER_FUNC_709,\n\t\tV4L2_XFER_FUNC_709,         \n\t\tV4L2_XFER_FUNC_709,         \n\t\tV4L2_XFER_FUNC_709,         \n\t\tV4L2_XFER_FUNC_SMPTE240M,\n\t\tV4L2_XFER_FUNC_NONE,\n\t\tV4L2_XFER_FUNC_SRGB,\n\t};\n\n\tif (transfer_characteristics < ARRAY_SIZE(xfer_funcs))\n\t\treturn xfer_funcs[transfer_characteristics];\n\n\treturn V4L2_XFER_FUNC_DEFAULT;   \n}\n\nstatic enum v4l2_ycbcr_encoding uvc_ycbcr_enc(const u8 matrix_coefficients)\n{\n\t \n\tstatic const enum v4l2_ycbcr_encoding ycbcr_encs[] = {\n\t\tV4L2_YCBCR_ENC_DEFAULT,   \n\t\tV4L2_YCBCR_ENC_709,\n\t\tV4L2_YCBCR_ENC_601,       \n\t\tV4L2_YCBCR_ENC_601,       \n\t\tV4L2_YCBCR_ENC_601,\n\t\tV4L2_YCBCR_ENC_SMPTE240M,\n\t};\n\n\tif (matrix_coefficients < ARRAY_SIZE(ycbcr_encs))\n\t\treturn ycbcr_encs[matrix_coefficients];\n\n\treturn V4L2_YCBCR_ENC_DEFAULT;   \n}\n\n \n\nstruct uvc_entity *uvc_entity_by_id(struct uvc_device *dev, int id)\n{\n\tstruct uvc_entity *entity;\n\n\tlist_for_each_entry(entity, &dev->entities, list) {\n\t\tif (entity->id == id)\n\t\t\treturn entity;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct uvc_entity *uvc_entity_by_reference(struct uvc_device *dev,\n\tint id, struct uvc_entity *entity)\n{\n\tunsigned int i;\n\n\tif (entity == NULL)\n\t\tentity = list_entry(&dev->entities, struct uvc_entity, list);\n\n\tlist_for_each_entry_continue(entity, &dev->entities, list) {\n\t\tfor (i = 0; i < entity->bNrInPins; ++i)\n\t\t\tif (entity->baSourceID[i] == id)\n\t\t\t\treturn entity;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct uvc_streaming *uvc_stream_by_id(struct uvc_device *dev, int id)\n{\n\tstruct uvc_streaming *stream;\n\n\tlist_for_each_entry(stream, &dev->streams, list) {\n\t\tif (stream->header.bTerminalLink == id)\n\t\t\treturn stream;\n\t}\n\n\treturn NULL;\n}\n\n \n\nstatic void uvc_stream_delete(struct uvc_streaming *stream)\n{\n\tif (stream->async_wq)\n\t\tdestroy_workqueue(stream->async_wq);\n\n\tmutex_destroy(&stream->mutex);\n\n\tusb_put_intf(stream->intf);\n\n\tkfree(stream->formats);\n\tkfree(stream->header.bmaControls);\n\tkfree(stream);\n}\n\nstatic struct uvc_streaming *uvc_stream_new(struct uvc_device *dev,\n\t\t\t\t\t    struct usb_interface *intf)\n{\n\tstruct uvc_streaming *stream;\n\n\tstream = kzalloc(sizeof(*stream), GFP_KERNEL);\n\tif (stream == NULL)\n\t\treturn NULL;\n\n\tmutex_init(&stream->mutex);\n\n\tstream->dev = dev;\n\tstream->intf = usb_get_intf(intf);\n\tstream->intfnum = intf->cur_altsetting->desc.bInterfaceNumber;\n\n\t \n\tstream->async_wq = alloc_workqueue(\"uvcvideo\", WQ_UNBOUND | WQ_HIGHPRI,\n\t\t\t\t\t   0);\n\tif (!stream->async_wq) {\n\t\tuvc_stream_delete(stream);\n\t\treturn NULL;\n\t}\n\n\treturn stream;\n}\n\n \n\nstatic int uvc_parse_format(struct uvc_device *dev,\n\tstruct uvc_streaming *streaming, struct uvc_format *format,\n\tstruct uvc_frame *frames, u32 **intervals, const unsigned char *buffer,\n\tint buflen)\n{\n\tstruct usb_interface *intf = streaming->intf;\n\tstruct usb_host_interface *alts = intf->cur_altsetting;\n\tconst struct uvc_format_desc *fmtdesc;\n\tstruct uvc_frame *frame;\n\tconst unsigned char *start = buffer;\n\tunsigned int width_multiplier = 1;\n\tunsigned int interval;\n\tunsigned int i, n;\n\tu8 ftype;\n\n\tformat->type = buffer[2];\n\tformat->index = buffer[3];\n\tformat->frames = frames;\n\n\tswitch (buffer[2]) {\n\tcase UVC_VS_FORMAT_UNCOMPRESSED:\n\tcase UVC_VS_FORMAT_FRAME_BASED:\n\t\tn = buffer[2] == UVC_VS_FORMAT_UNCOMPRESSED ? 27 : 28;\n\t\tif (buflen < n) {\n\t\t\tuvc_dbg(dev, DESCR,\n\t\t\t\t\"device %d videostreaming interface %d FORMAT error\\n\",\n\t\t\t\tdev->udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tfmtdesc = uvc_format_by_guid(&buffer[5]);\n\n\t\tif (!fmtdesc) {\n\t\t\t \n\t\t\tdev_info(&streaming->intf->dev,\n\t\t\t\t \"Unknown video format %pUl\\n\", &buffer[5]);\n\t\t\treturn 0;\n\t\t}\n\n\t\tformat->fcc = fmtdesc->fcc;\n\t\tformat->bpp = buffer[21];\n\n\t\t \n\t\tif (dev->quirks & UVC_QUIRK_FORCE_Y8) {\n\t\t\tif (format->fcc == V4L2_PIX_FMT_YUYV) {\n\t\t\t\tformat->fcc = V4L2_PIX_FMT_GREY;\n\t\t\t\tformat->bpp = 8;\n\t\t\t\twidth_multiplier = 2;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (dev->quirks & UVC_QUIRK_FORCE_BPP) {\n\t\t\tconst struct v4l2_format_info *info =\n\t\t\t\tv4l2_format_info(format->fcc);\n\n\t\t\tif (info) {\n\t\t\t\tunsigned int div = info->hdiv * info->vdiv;\n\n\t\t\t\tn = info->bpp[0] * div;\n\t\t\t\tfor (i = 1; i < info->comp_planes; i++)\n\t\t\t\t\tn += info->bpp[i];\n\n\t\t\t\tformat->bpp = DIV_ROUND_UP(8 * n, div);\n\t\t\t}\n\t\t}\n\n\t\tif (buffer[2] == UVC_VS_FORMAT_UNCOMPRESSED) {\n\t\t\tftype = UVC_VS_FRAME_UNCOMPRESSED;\n\t\t} else {\n\t\t\tftype = UVC_VS_FRAME_FRAME_BASED;\n\t\t\tif (buffer[27])\n\t\t\t\tformat->flags = UVC_FMT_FLAG_COMPRESSED;\n\t\t}\n\t\tbreak;\n\n\tcase UVC_VS_FORMAT_MJPEG:\n\t\tif (buflen < 11) {\n\t\t\tuvc_dbg(dev, DESCR,\n\t\t\t\t\"device %d videostreaming interface %d FORMAT error\\n\",\n\t\t\t\tdev->udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tformat->fcc = V4L2_PIX_FMT_MJPEG;\n\t\tformat->flags = UVC_FMT_FLAG_COMPRESSED;\n\t\tformat->bpp = 0;\n\t\tftype = UVC_VS_FRAME_MJPEG;\n\t\tbreak;\n\n\tcase UVC_VS_FORMAT_DV:\n\t\tif (buflen < 9) {\n\t\t\tuvc_dbg(dev, DESCR,\n\t\t\t\t\"device %d videostreaming interface %d FORMAT error\\n\",\n\t\t\t\tdev->udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((buffer[8] & 0x7f) > 2) {\n\t\t\tuvc_dbg(dev, DESCR,\n\t\t\t\t\"device %d videostreaming interface %d: unknown DV format %u\\n\",\n\t\t\t\tdev->udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber, buffer[8]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tformat->fcc = V4L2_PIX_FMT_DV;\n\t\tformat->flags = UVC_FMT_FLAG_COMPRESSED | UVC_FMT_FLAG_STREAM;\n\t\tformat->bpp = 0;\n\t\tftype = 0;\n\n\t\t \n\t\tframe = &frames[0];\n\t\tmemset(frame, 0, sizeof(*frame));\n\t\tframe->bFrameIntervalType = 1;\n\t\tframe->dwDefaultFrameInterval = 1;\n\t\tframe->dwFrameInterval = *intervals;\n\t\t*(*intervals)++ = 1;\n\t\tformat->nframes = 1;\n\t\tbreak;\n\n\tcase UVC_VS_FORMAT_MPEG2TS:\n\tcase UVC_VS_FORMAT_STREAM_BASED:\n\t\t \n\tdefault:\n\t\tuvc_dbg(dev, DESCR,\n\t\t\t\"device %d videostreaming interface %d unsupported format %u\\n\",\n\t\t\tdev->udev->devnum, alts->desc.bInterfaceNumber,\n\t\t\tbuffer[2]);\n\t\treturn -EINVAL;\n\t}\n\n\tuvc_dbg(dev, DESCR, \"Found format %p4cc\", &format->fcc);\n\n\tbuflen -= buffer[0];\n\tbuffer += buffer[0];\n\n\t \n\twhile (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE &&\n\t       buffer[2] == ftype) {\n\t\tunsigned int maxIntervalIndex;\n\n\t\tframe = &frames[format->nframes];\n\t\tif (ftype != UVC_VS_FRAME_FRAME_BASED)\n\t\t\tn = buflen > 25 ? buffer[25] : 0;\n\t\telse\n\t\t\tn = buflen > 21 ? buffer[21] : 0;\n\n\t\tn = n ? n : 3;\n\n\t\tif (buflen < 26 + 4*n) {\n\t\t\tuvc_dbg(dev, DESCR,\n\t\t\t\t\"device %d videostreaming interface %d FRAME error\\n\",\n\t\t\t\tdev->udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tframe->bFrameIndex = buffer[3];\n\t\tframe->bmCapabilities = buffer[4];\n\t\tframe->wWidth = get_unaligned_le16(&buffer[5])\n\t\t\t      * width_multiplier;\n\t\tframe->wHeight = get_unaligned_le16(&buffer[7]);\n\t\tframe->dwMinBitRate = get_unaligned_le32(&buffer[9]);\n\t\tframe->dwMaxBitRate = get_unaligned_le32(&buffer[13]);\n\t\tif (ftype != UVC_VS_FRAME_FRAME_BASED) {\n\t\t\tframe->dwMaxVideoFrameBufferSize =\n\t\t\t\tget_unaligned_le32(&buffer[17]);\n\t\t\tframe->dwDefaultFrameInterval =\n\t\t\t\tget_unaligned_le32(&buffer[21]);\n\t\t\tframe->bFrameIntervalType = buffer[25];\n\t\t} else {\n\t\t\tframe->dwMaxVideoFrameBufferSize = 0;\n\t\t\tframe->dwDefaultFrameInterval =\n\t\t\t\tget_unaligned_le32(&buffer[17]);\n\t\t\tframe->bFrameIntervalType = buffer[21];\n\t\t}\n\n\t\t \n\t\tframe->dwFrameInterval = *intervals;\n\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tinterval = get_unaligned_le32(&buffer[26+4*i]);\n\t\t\t(*intervals)[i] = interval ? interval : 1;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tif (!(format->flags & UVC_FMT_FLAG_COMPRESSED))\n\t\t\tframe->dwMaxVideoFrameBufferSize = format->bpp\n\t\t\t\t* frame->wWidth * frame->wHeight / 8;\n\n\t\t \n\t\tmaxIntervalIndex = frame->bFrameIntervalType ? n - 1 : 1;\n\t\tframe->dwDefaultFrameInterval =\n\t\t\tclamp(frame->dwDefaultFrameInterval,\n\t\t\t      frame->dwFrameInterval[0],\n\t\t\t      frame->dwFrameInterval[maxIntervalIndex]);\n\n\t\t \n\t\tif (dev->quirks & UVC_QUIRK_RESTRICT_FRAME_RATE) {\n\t\t\tframe->bFrameIntervalType = 1;\n\t\t\t(*intervals)[0] = frame->dwDefaultFrameInterval;\n\t\t}\n\n\t\tuvc_dbg(dev, DESCR, \"- %ux%u (%u.%u fps)\\n\",\n\t\t\tframe->wWidth, frame->wHeight,\n\t\t\t10000000 / frame->dwDefaultFrameInterval,\n\t\t\t(100000000 / frame->dwDefaultFrameInterval) % 10);\n\n\t\tformat->nframes++;\n\t\t*intervals += n;\n\n\t\tbuflen -= buffer[0];\n\t\tbuffer += buffer[0];\n\t}\n\n\tif (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE &&\n\t    buffer[2] == UVC_VS_STILL_IMAGE_FRAME) {\n\t\tbuflen -= buffer[0];\n\t\tbuffer += buffer[0];\n\t}\n\n\tif (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE &&\n\t    buffer[2] == UVC_VS_COLORFORMAT) {\n\t\tif (buflen < 6) {\n\t\t\tuvc_dbg(dev, DESCR,\n\t\t\t\t\"device %d videostreaming interface %d COLORFORMAT error\\n\",\n\t\t\t\tdev->udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tformat->colorspace = uvc_colorspace(buffer[3]);\n\t\tformat->xfer_func = uvc_xfer_func(buffer[4]);\n\t\tformat->ycbcr_enc = uvc_ycbcr_enc(buffer[5]);\n\n\t\tbuflen -= buffer[0];\n\t\tbuffer += buffer[0];\n\t} else {\n\t\tformat->colorspace = V4L2_COLORSPACE_SRGB;\n\t}\n\n\treturn buffer - start;\n}\n\nstatic int uvc_parse_streaming(struct uvc_device *dev,\n\tstruct usb_interface *intf)\n{\n\tstruct uvc_streaming *streaming = NULL;\n\tstruct uvc_format *format;\n\tstruct uvc_frame *frame;\n\tstruct usb_host_interface *alts = &intf->altsetting[0];\n\tconst unsigned char *_buffer, *buffer = alts->extra;\n\tint _buflen, buflen = alts->extralen;\n\tunsigned int nformats = 0, nframes = 0, nintervals = 0;\n\tunsigned int size, i, n, p;\n\tu32 *interval;\n\tu16 psize;\n\tint ret = -EINVAL;\n\n\tif (intf->cur_altsetting->desc.bInterfaceSubClass\n\t\t!= UVC_SC_VIDEOSTREAMING) {\n\t\tuvc_dbg(dev, DESCR,\n\t\t\t\"device %d interface %d isn't a video streaming interface\\n\",\n\t\t\tdev->udev->devnum,\n\t\t\tintf->altsetting[0].desc.bInterfaceNumber);\n\t\treturn -EINVAL;\n\t}\n\n\tif (usb_driver_claim_interface(&uvc_driver.driver, intf, dev)) {\n\t\tuvc_dbg(dev, DESCR,\n\t\t\t\"device %d interface %d is already claimed\\n\",\n\t\t\tdev->udev->devnum,\n\t\t\tintf->altsetting[0].desc.bInterfaceNumber);\n\t\treturn -EINVAL;\n\t}\n\n\tstreaming = uvc_stream_new(dev, intf);\n\tif (streaming == NULL) {\n\t\tusb_driver_release_interface(&uvc_driver.driver, intf);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (buflen == 0) {\n\t\tfor (i = 0; i < alts->desc.bNumEndpoints; ++i) {\n\t\t\tstruct usb_host_endpoint *ep = &alts->endpoint[i];\n\n\t\t\tif (ep->extralen == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (ep->extralen > 2 &&\n\t\t\t    ep->extra[1] == USB_DT_CS_INTERFACE) {\n\t\t\t\tuvc_dbg(dev, DESCR,\n\t\t\t\t\t\"trying extra data from endpoint %u\\n\",\n\t\t\t\t\ti);\n\t\t\t\tbuffer = alts->endpoint[i].extra;\n\t\t\t\tbuflen = alts->endpoint[i].extralen;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\twhile (buflen > 2 && buffer[1] != USB_DT_CS_INTERFACE) {\n\t\tbuflen -= buffer[0];\n\t\tbuffer += buffer[0];\n\t}\n\n\tif (buflen <= 2) {\n\t\tuvc_dbg(dev, DESCR,\n\t\t\t\"no class-specific streaming interface descriptors found\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tswitch (buffer[2]) {\n\tcase UVC_VS_OUTPUT_HEADER:\n\t\tstreaming->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\t\tsize = 9;\n\t\tbreak;\n\n\tcase UVC_VS_INPUT_HEADER:\n\t\tstreaming->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tsize = 13;\n\t\tbreak;\n\n\tdefault:\n\t\tuvc_dbg(dev, DESCR,\n\t\t\t\"device %d videostreaming interface %d HEADER descriptor not found\\n\",\n\t\t\tdev->udev->devnum, alts->desc.bInterfaceNumber);\n\t\tgoto error;\n\t}\n\n\tp = buflen >= 4 ? buffer[3] : 0;\n\tn = buflen >= size ? buffer[size-1] : 0;\n\n\tif (buflen < size + p*n) {\n\t\tuvc_dbg(dev, DESCR,\n\t\t\t\"device %d videostreaming interface %d HEADER descriptor is invalid\\n\",\n\t\t\tdev->udev->devnum, alts->desc.bInterfaceNumber);\n\t\tgoto error;\n\t}\n\n\tstreaming->header.bNumFormats = p;\n\tstreaming->header.bEndpointAddress = buffer[6];\n\tif (buffer[2] == UVC_VS_INPUT_HEADER) {\n\t\tstreaming->header.bmInfo = buffer[7];\n\t\tstreaming->header.bTerminalLink = buffer[8];\n\t\tstreaming->header.bStillCaptureMethod = buffer[9];\n\t\tstreaming->header.bTriggerSupport = buffer[10];\n\t\tstreaming->header.bTriggerUsage = buffer[11];\n\t} else {\n\t\tstreaming->header.bTerminalLink = buffer[7];\n\t}\n\tstreaming->header.bControlSize = n;\n\n\tstreaming->header.bmaControls = kmemdup(&buffer[size], p * n,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (streaming->header.bmaControls == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tbuflen -= buffer[0];\n\tbuffer += buffer[0];\n\n\t_buffer = buffer;\n\t_buflen = buflen;\n\n\t \n\twhile (_buflen > 2 && _buffer[1] == USB_DT_CS_INTERFACE) {\n\t\tswitch (_buffer[2]) {\n\t\tcase UVC_VS_FORMAT_UNCOMPRESSED:\n\t\tcase UVC_VS_FORMAT_MJPEG:\n\t\tcase UVC_VS_FORMAT_FRAME_BASED:\n\t\t\tnformats++;\n\t\t\tbreak;\n\n\t\tcase UVC_VS_FORMAT_DV:\n\t\t\t \n\t\t\tnformats++;\n\t\t\tnframes++;\n\t\t\tnintervals++;\n\t\t\tbreak;\n\n\t\tcase UVC_VS_FORMAT_MPEG2TS:\n\t\tcase UVC_VS_FORMAT_STREAM_BASED:\n\t\t\tuvc_dbg(dev, DESCR,\n\t\t\t\t\"device %d videostreaming interface %d FORMAT %u is not supported\\n\",\n\t\t\t\tdev->udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber, _buffer[2]);\n\t\t\tbreak;\n\n\t\tcase UVC_VS_FRAME_UNCOMPRESSED:\n\t\tcase UVC_VS_FRAME_MJPEG:\n\t\t\tnframes++;\n\t\t\tif (_buflen > 25)\n\t\t\t\tnintervals += _buffer[25] ? _buffer[25] : 3;\n\t\t\tbreak;\n\n\t\tcase UVC_VS_FRAME_FRAME_BASED:\n\t\t\tnframes++;\n\t\t\tif (_buflen > 21)\n\t\t\t\tnintervals += _buffer[21] ? _buffer[21] : 3;\n\t\t\tbreak;\n\t\t}\n\n\t\t_buflen -= _buffer[0];\n\t\t_buffer += _buffer[0];\n\t}\n\n\tif (nformats == 0) {\n\t\tuvc_dbg(dev, DESCR,\n\t\t\t\"device %d videostreaming interface %d has no supported formats defined\\n\",\n\t\t\tdev->udev->devnum, alts->desc.bInterfaceNumber);\n\t\tgoto error;\n\t}\n\n\tsize = nformats * sizeof(*format) + nframes * sizeof(*frame)\n\t     + nintervals * sizeof(*interval);\n\tformat = kzalloc(size, GFP_KERNEL);\n\tif (format == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tframe = (struct uvc_frame *)&format[nformats];\n\tinterval = (u32 *)&frame[nframes];\n\n\tstreaming->formats = format;\n\tstreaming->nformats = 0;\n\n\t \n\twhile (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE) {\n\t\tswitch (buffer[2]) {\n\t\tcase UVC_VS_FORMAT_UNCOMPRESSED:\n\t\tcase UVC_VS_FORMAT_MJPEG:\n\t\tcase UVC_VS_FORMAT_DV:\n\t\tcase UVC_VS_FORMAT_FRAME_BASED:\n\t\t\tret = uvc_parse_format(dev, streaming, format, frame,\n\t\t\t\t&interval, buffer, buflen);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (!ret)\n\t\t\t\tbreak;\n\n\t\t\tstreaming->nformats++;\n\t\t\tframe += format->nframes;\n\t\t\tformat++;\n\n\t\t\tbuflen -= ret;\n\t\t\tbuffer += ret;\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbuflen -= buffer[0];\n\t\tbuffer += buffer[0];\n\t}\n\n\tif (buflen)\n\t\tuvc_dbg(dev, DESCR,\n\t\t\t\"device %d videostreaming interface %d has %u bytes of trailing descriptor garbage\\n\",\n\t\t\tdev->udev->devnum, alts->desc.bInterfaceNumber, buflen);\n\n\t \n\tfor (i = 0; i < intf->num_altsetting; ++i) {\n\t\tstruct usb_host_endpoint *ep;\n\n\t\talts = &intf->altsetting[i];\n\t\tep = uvc_find_endpoint(alts,\n\t\t\t\tstreaming->header.bEndpointAddress);\n\t\tif (ep == NULL)\n\t\t\tcontinue;\n\t\tpsize = uvc_endpoint_max_bpi(dev->udev, ep);\n\t\tif (psize > streaming->maxpsize)\n\t\t\tstreaming->maxpsize = psize;\n\t}\n\n\tlist_add_tail(&streaming->list, &dev->streams);\n\treturn 0;\n\nerror:\n\tusb_driver_release_interface(&uvc_driver.driver, intf);\n\tuvc_stream_delete(streaming);\n\treturn ret;\n}\n\nstatic const u8 uvc_camera_guid[16] = UVC_GUID_UVC_CAMERA;\nstatic const u8 uvc_gpio_guid[16] = UVC_GUID_EXT_GPIO_CONTROLLER;\nstatic const u8 uvc_media_transport_input_guid[16] =\n\tUVC_GUID_UVC_MEDIA_TRANSPORT_INPUT;\nstatic const u8 uvc_processing_guid[16] = UVC_GUID_UVC_PROCESSING;\n\nstatic struct uvc_entity *uvc_alloc_entity(u16 type, u16 id,\n\t\tunsigned int num_pads, unsigned int extra_size)\n{\n\tstruct uvc_entity *entity;\n\tunsigned int num_inputs;\n\tunsigned int size;\n\tunsigned int i;\n\n\textra_size = roundup(extra_size, sizeof(*entity->pads));\n\tif (num_pads)\n\t\tnum_inputs = type & UVC_TERM_OUTPUT ? num_pads : num_pads - 1;\n\telse\n\t\tnum_inputs = 0;\n\tsize = sizeof(*entity) + extra_size + sizeof(*entity->pads) * num_pads\n\t     + num_inputs;\n\tentity = kzalloc(size, GFP_KERNEL);\n\tif (entity == NULL)\n\t\treturn NULL;\n\n\tentity->id = id;\n\tentity->type = type;\n\n\t \n\tswitch (type) {\n\tcase UVC_EXT_GPIO_UNIT:\n\t\tmemcpy(entity->guid, uvc_gpio_guid, 16);\n\t\tbreak;\n\tcase UVC_ITT_CAMERA:\n\t\tmemcpy(entity->guid, uvc_camera_guid, 16);\n\t\tbreak;\n\tcase UVC_ITT_MEDIA_TRANSPORT_INPUT:\n\t\tmemcpy(entity->guid, uvc_media_transport_input_guid, 16);\n\t\tbreak;\n\tcase UVC_VC_PROCESSING_UNIT:\n\t\tmemcpy(entity->guid, uvc_processing_guid, 16);\n\t\tbreak;\n\t}\n\n\tentity->num_links = 0;\n\tentity->num_pads = num_pads;\n\tentity->pads = ((void *)(entity + 1)) + extra_size;\n\n\tfor (i = 0; i < num_inputs; ++i)\n\t\tentity->pads[i].flags = MEDIA_PAD_FL_SINK;\n\tif (!UVC_ENTITY_IS_OTERM(entity) && num_pads)\n\t\tentity->pads[num_pads-1].flags = MEDIA_PAD_FL_SOURCE;\n\n\tentity->bNrInPins = num_inputs;\n\tentity->baSourceID = (u8 *)(&entity->pads[num_pads]);\n\n\treturn entity;\n}\n\nstatic void uvc_entity_set_name(struct uvc_device *dev, struct uvc_entity *entity,\n\t\t\t\tconst char *type_name, u8 string_id)\n{\n\tint ret;\n\n\t \n\tif (string_id) {\n\t\tret = usb_string(dev->udev, string_id, entity->name,\n\t\t\t\t sizeof(entity->name));\n\t\tif (!ret)\n\t\t\treturn;\n\t}\n\n\tsprintf(entity->name, \"%s %u\", type_name, entity->id);\n}\n\n \nstatic int uvc_parse_vendor_control(struct uvc_device *dev,\n\tconst unsigned char *buffer, int buflen)\n{\n\tstruct usb_device *udev = dev->udev;\n\tstruct usb_host_interface *alts = dev->intf->cur_altsetting;\n\tstruct uvc_entity *unit;\n\tunsigned int n, p;\n\tint handled = 0;\n\n\tswitch (le16_to_cpu(dev->udev->descriptor.idVendor)) {\n\tcase 0x046d:\t\t \n\t\tif (buffer[1] != 0x41 || buffer[2] != 0x01)\n\t\t\tbreak;\n\n\t\t \n\t\tp = buflen >= 22 ? buffer[21] : 0;\n\t\tn = buflen >= 25 + p ? buffer[22+p] : 0;\n\n\t\tif (buflen < 25 + p + 2*n) {\n\t\t\tuvc_dbg(dev, DESCR,\n\t\t\t\t\"device %d videocontrol interface %d EXTENSION_UNIT error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\tbreak;\n\t\t}\n\n\t\tunit = uvc_alloc_entity(UVC_VC_EXTENSION_UNIT, buffer[3],\n\t\t\t\t\tp + 1, 2*n);\n\t\tif (unit == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(unit->guid, &buffer[4], 16);\n\t\tunit->extension.bNumControls = buffer[20];\n\t\tmemcpy(unit->baSourceID, &buffer[22], p);\n\t\tunit->extension.bControlSize = buffer[22+p];\n\t\tunit->extension.bmControls = (u8 *)unit + sizeof(*unit);\n\t\tunit->extension.bmControlsType = (u8 *)unit + sizeof(*unit)\n\t\t\t\t\t       + n;\n\t\tmemcpy(unit->extension.bmControls, &buffer[23+p], 2*n);\n\n\t\tuvc_entity_set_name(dev, unit, \"Extension\", buffer[24+p+2*n]);\n\n\t\tlist_add_tail(&unit->list, &dev->entities);\n\t\thandled = 1;\n\t\tbreak;\n\t}\n\n\treturn handled;\n}\n\nstatic int uvc_parse_standard_control(struct uvc_device *dev,\n\tconst unsigned char *buffer, int buflen)\n{\n\tstruct usb_device *udev = dev->udev;\n\tstruct uvc_entity *unit, *term;\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *alts = dev->intf->cur_altsetting;\n\tunsigned int i, n, p, len;\n\tconst char *type_name;\n\tu16 type;\n\n\tswitch (buffer[2]) {\n\tcase UVC_VC_HEADER:\n\t\tn = buflen >= 12 ? buffer[11] : 0;\n\n\t\tif (buflen < 12 + n) {\n\t\t\tuvc_dbg(dev, DESCR,\n\t\t\t\t\"device %d videocontrol interface %d HEADER error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev->uvc_version = get_unaligned_le16(&buffer[3]);\n\t\tdev->clock_frequency = get_unaligned_le32(&buffer[7]);\n\n\t\t \n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tintf = usb_ifnum_to_if(udev, buffer[12+i]);\n\t\t\tif (intf == NULL) {\n\t\t\t\tuvc_dbg(dev, DESCR,\n\t\t\t\t\t\"device %d interface %d doesn't exists\\n\",\n\t\t\t\t\tudev->devnum, i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tuvc_parse_streaming(dev, intf);\n\t\t}\n\t\tbreak;\n\n\tcase UVC_VC_INPUT_TERMINAL:\n\t\tif (buflen < 8) {\n\t\t\tuvc_dbg(dev, DESCR,\n\t\t\t\t\"device %d videocontrol interface %d INPUT_TERMINAL error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\ttype = get_unaligned_le16(&buffer[4]);\n\t\tif ((type & 0x7f00) == 0 || (type & 0x8000) != 0) {\n\t\t\tuvc_dbg(dev, DESCR,\n\t\t\t\t\"device %d videocontrol interface %d INPUT_TERMINAL %d has invalid type 0x%04x, skipping\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber,\n\t\t\t\tbuffer[3], type);\n\t\t\treturn 0;\n\t\t}\n\n\t\tn = 0;\n\t\tp = 0;\n\t\tlen = 8;\n\n\t\tif (type == UVC_ITT_CAMERA) {\n\t\t\tn = buflen >= 15 ? buffer[14] : 0;\n\t\t\tlen = 15;\n\n\t\t} else if (type == UVC_ITT_MEDIA_TRANSPORT_INPUT) {\n\t\t\tn = buflen >= 9 ? buffer[8] : 0;\n\t\t\tp = buflen >= 10 + n ? buffer[9+n] : 0;\n\t\t\tlen = 10;\n\t\t}\n\n\t\tif (buflen < len + n + p) {\n\t\t\tuvc_dbg(dev, DESCR,\n\t\t\t\t\"device %d videocontrol interface %d INPUT_TERMINAL error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tterm = uvc_alloc_entity(type | UVC_TERM_INPUT, buffer[3],\n\t\t\t\t\t1, n + p);\n\t\tif (term == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tif (UVC_ENTITY_TYPE(term) == UVC_ITT_CAMERA) {\n\t\t\tterm->camera.bControlSize = n;\n\t\t\tterm->camera.bmControls = (u8 *)term + sizeof(*term);\n\t\t\tterm->camera.wObjectiveFocalLengthMin =\n\t\t\t\tget_unaligned_le16(&buffer[8]);\n\t\t\tterm->camera.wObjectiveFocalLengthMax =\n\t\t\t\tget_unaligned_le16(&buffer[10]);\n\t\t\tterm->camera.wOcularFocalLength =\n\t\t\t\tget_unaligned_le16(&buffer[12]);\n\t\t\tmemcpy(term->camera.bmControls, &buffer[15], n);\n\t\t} else if (UVC_ENTITY_TYPE(term) ==\n\t\t\t   UVC_ITT_MEDIA_TRANSPORT_INPUT) {\n\t\t\tterm->media.bControlSize = n;\n\t\t\tterm->media.bmControls = (u8 *)term + sizeof(*term);\n\t\t\tterm->media.bTransportModeSize = p;\n\t\t\tterm->media.bmTransportModes = (u8 *)term\n\t\t\t\t\t\t     + sizeof(*term) + n;\n\t\t\tmemcpy(term->media.bmControls, &buffer[9], n);\n\t\t\tmemcpy(term->media.bmTransportModes, &buffer[10+n], p);\n\t\t}\n\n\t\tif (UVC_ENTITY_TYPE(term) == UVC_ITT_CAMERA)\n\t\t\ttype_name = \"Camera\";\n\t\telse if (UVC_ENTITY_TYPE(term) == UVC_ITT_MEDIA_TRANSPORT_INPUT)\n\t\t\ttype_name = \"Media\";\n\t\telse\n\t\t\ttype_name = \"Input\";\n\n\t\tuvc_entity_set_name(dev, term, type_name, buffer[7]);\n\n\t\tlist_add_tail(&term->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_OUTPUT_TERMINAL:\n\t\tif (buflen < 9) {\n\t\t\tuvc_dbg(dev, DESCR,\n\t\t\t\t\"device %d videocontrol interface %d OUTPUT_TERMINAL error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\ttype = get_unaligned_le16(&buffer[4]);\n\t\tif ((type & 0xff00) == 0) {\n\t\t\tuvc_dbg(dev, DESCR,\n\t\t\t\t\"device %d videocontrol interface %d OUTPUT_TERMINAL %d has invalid type 0x%04x, skipping\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber,\n\t\t\t\tbuffer[3], type);\n\t\t\treturn 0;\n\t\t}\n\n\t\tterm = uvc_alloc_entity(type | UVC_TERM_OUTPUT, buffer[3],\n\t\t\t\t\t1, 0);\n\t\tif (term == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(term->baSourceID, &buffer[7], 1);\n\n\t\tuvc_entity_set_name(dev, term, \"Output\", buffer[8]);\n\n\t\tlist_add_tail(&term->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_SELECTOR_UNIT:\n\t\tp = buflen >= 5 ? buffer[4] : 0;\n\n\t\tif (buflen < 5 || buflen < 6 + p) {\n\t\t\tuvc_dbg(dev, DESCR,\n\t\t\t\t\"device %d videocontrol interface %d SELECTOR_UNIT error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tunit = uvc_alloc_entity(buffer[2], buffer[3], p + 1, 0);\n\t\tif (unit == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(unit->baSourceID, &buffer[5], p);\n\n\t\tuvc_entity_set_name(dev, unit, \"Selector\", buffer[5+p]);\n\n\t\tlist_add_tail(&unit->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_PROCESSING_UNIT:\n\t\tn = buflen >= 8 ? buffer[7] : 0;\n\t\tp = dev->uvc_version >= 0x0110 ? 10 : 9;\n\n\t\tif (buflen < p + n) {\n\t\t\tuvc_dbg(dev, DESCR,\n\t\t\t\t\"device %d videocontrol interface %d PROCESSING_UNIT error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tunit = uvc_alloc_entity(buffer[2], buffer[3], 2, n);\n\t\tif (unit == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(unit->baSourceID, &buffer[4], 1);\n\t\tunit->processing.wMaxMultiplier =\n\t\t\tget_unaligned_le16(&buffer[5]);\n\t\tunit->processing.bControlSize = buffer[7];\n\t\tunit->processing.bmControls = (u8 *)unit + sizeof(*unit);\n\t\tmemcpy(unit->processing.bmControls, &buffer[8], n);\n\t\tif (dev->uvc_version >= 0x0110)\n\t\t\tunit->processing.bmVideoStandards = buffer[9+n];\n\n\t\tuvc_entity_set_name(dev, unit, \"Processing\", buffer[8+n]);\n\n\t\tlist_add_tail(&unit->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_EXTENSION_UNIT:\n\t\tp = buflen >= 22 ? buffer[21] : 0;\n\t\tn = buflen >= 24 + p ? buffer[22+p] : 0;\n\n\t\tif (buflen < 24 + p + n) {\n\t\t\tuvc_dbg(dev, DESCR,\n\t\t\t\t\"device %d videocontrol interface %d EXTENSION_UNIT error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tunit = uvc_alloc_entity(buffer[2], buffer[3], p + 1, n);\n\t\tif (unit == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(unit->guid, &buffer[4], 16);\n\t\tunit->extension.bNumControls = buffer[20];\n\t\tmemcpy(unit->baSourceID, &buffer[22], p);\n\t\tunit->extension.bControlSize = buffer[22+p];\n\t\tunit->extension.bmControls = (u8 *)unit + sizeof(*unit);\n\t\tmemcpy(unit->extension.bmControls, &buffer[23+p], n);\n\n\t\tuvc_entity_set_name(dev, unit, \"Extension\", buffer[23+p+n]);\n\n\t\tlist_add_tail(&unit->list, &dev->entities);\n\t\tbreak;\n\n\tdefault:\n\t\tuvc_dbg(dev, DESCR,\n\t\t\t\"Found an unknown CS_INTERFACE descriptor (%u)\\n\",\n\t\t\tbuffer[2]);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int uvc_parse_control(struct uvc_device *dev)\n{\n\tstruct usb_host_interface *alts = dev->intf->cur_altsetting;\n\tconst unsigned char *buffer = alts->extra;\n\tint buflen = alts->extralen;\n\tint ret;\n\n\t \n\n\twhile (buflen > 2) {\n\t\tif (uvc_parse_vendor_control(dev, buffer, buflen) ||\n\t\t    buffer[1] != USB_DT_CS_INTERFACE)\n\t\t\tgoto next_descriptor;\n\n\t\tret = uvc_parse_standard_control(dev, buffer, buflen);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\nnext_descriptor:\n\t\tbuflen -= buffer[0];\n\t\tbuffer += buffer[0];\n\t}\n\n\t \n\tif (alts->desc.bNumEndpoints == 1 &&\n\t    !(dev->quirks & UVC_QUIRK_BUILTIN_ISIGHT)) {\n\t\tstruct usb_host_endpoint *ep = &alts->endpoint[0];\n\t\tstruct usb_endpoint_descriptor *desc = &ep->desc;\n\n\t\tif (usb_endpoint_is_int_in(desc) &&\n\t\t    le16_to_cpu(desc->wMaxPacketSize) >= 8 &&\n\t\t    desc->bInterval != 0) {\n\t\t\tuvc_dbg(dev, DESCR,\n\t\t\t\t\"Found a Status endpoint (addr %02x)\\n\",\n\t\t\t\tdesc->bEndpointAddress);\n\t\t\tdev->int_ep = ep;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void uvc_gpio_event(struct uvc_device *dev)\n{\n\tstruct uvc_entity *unit = dev->gpio_unit;\n\tstruct uvc_video_chain *chain;\n\tu8 new_val;\n\n\tif (!unit)\n\t\treturn;\n\n\tnew_val = gpiod_get_value_cansleep(unit->gpio.gpio_privacy);\n\n\t \n\tchain = list_first_entry(&dev->chains, struct uvc_video_chain, list);\n\tuvc_ctrl_status_event(chain, unit->controls, &new_val);\n}\n\nstatic int uvc_gpio_get_cur(struct uvc_device *dev, struct uvc_entity *entity,\n\t\t\t    u8 cs, void *data, u16 size)\n{\n\tif (cs != UVC_CT_PRIVACY_CONTROL || size < 1)\n\t\treturn -EINVAL;\n\n\t*(u8 *)data = gpiod_get_value_cansleep(entity->gpio.gpio_privacy);\n\n\treturn 0;\n}\n\nstatic int uvc_gpio_get_info(struct uvc_device *dev, struct uvc_entity *entity,\n\t\t\t     u8 cs, u8 *caps)\n{\n\tif (cs != UVC_CT_PRIVACY_CONTROL)\n\t\treturn -EINVAL;\n\n\t*caps = UVC_CONTROL_CAP_GET | UVC_CONTROL_CAP_AUTOUPDATE;\n\treturn 0;\n}\n\nstatic irqreturn_t uvc_gpio_irq(int irq, void *data)\n{\n\tstruct uvc_device *dev = data;\n\n\tuvc_gpio_event(dev);\n\treturn IRQ_HANDLED;\n}\n\nstatic int uvc_gpio_parse(struct uvc_device *dev)\n{\n\tstruct uvc_entity *unit;\n\tstruct gpio_desc *gpio_privacy;\n\tint irq;\n\n\tgpio_privacy = devm_gpiod_get_optional(&dev->udev->dev, \"privacy\",\n\t\t\t\t\t       GPIOD_IN);\n\tif (IS_ERR_OR_NULL(gpio_privacy))\n\t\treturn PTR_ERR_OR_ZERO(gpio_privacy);\n\n\tirq = gpiod_to_irq(gpio_privacy);\n\tif (irq < 0)\n\t\treturn dev_err_probe(&dev->udev->dev, irq,\n\t\t\t\t     \"No IRQ for privacy GPIO\\n\");\n\n\tunit = uvc_alloc_entity(UVC_EXT_GPIO_UNIT, UVC_EXT_GPIO_UNIT_ID, 0, 1);\n\tif (!unit)\n\t\treturn -ENOMEM;\n\n\tunit->gpio.gpio_privacy = gpio_privacy;\n\tunit->gpio.irq = irq;\n\tunit->gpio.bControlSize = 1;\n\tunit->gpio.bmControls = (u8 *)unit + sizeof(*unit);\n\tunit->gpio.bmControls[0] = 1;\n\tunit->get_cur = uvc_gpio_get_cur;\n\tunit->get_info = uvc_gpio_get_info;\n\tstrscpy(unit->name, \"GPIO\", sizeof(unit->name));\n\n\tlist_add_tail(&unit->list, &dev->entities);\n\n\tdev->gpio_unit = unit;\n\n\treturn 0;\n}\n\nstatic int uvc_gpio_init_irq(struct uvc_device *dev)\n{\n\tstruct uvc_entity *unit = dev->gpio_unit;\n\n\tif (!unit || unit->gpio.irq < 0)\n\t\treturn 0;\n\n\treturn devm_request_threaded_irq(&dev->udev->dev, unit->gpio.irq, NULL,\n\t\t\t\t\t uvc_gpio_irq,\n\t\t\t\t\t IRQF_ONESHOT | IRQF_TRIGGER_FALLING |\n\t\t\t\t\t IRQF_TRIGGER_RISING,\n\t\t\t\t\t \"uvc_privacy_gpio\", dev);\n}\n\n \n\n \nstatic int uvc_scan_chain_entity(struct uvc_video_chain *chain,\n\tstruct uvc_entity *entity)\n{\n\tswitch (UVC_ENTITY_TYPE(entity)) {\n\tcase UVC_VC_EXTENSION_UNIT:\n\t\tuvc_dbg_cont(PROBE, \" <- XU %d\", entity->id);\n\n\t\tif (entity->bNrInPins != 1) {\n\t\t\tuvc_dbg(chain->dev, DESCR,\n\t\t\t\t\"Extension unit %d has more than 1 input pin\\n\",\n\t\t\t\tentity->id);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbreak;\n\n\tcase UVC_VC_PROCESSING_UNIT:\n\t\tuvc_dbg_cont(PROBE, \" <- PU %d\", entity->id);\n\n\t\tif (chain->processing != NULL) {\n\t\t\tuvc_dbg(chain->dev, DESCR,\n\t\t\t\t\"Found multiple Processing Units in chain\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tchain->processing = entity;\n\t\tbreak;\n\n\tcase UVC_VC_SELECTOR_UNIT:\n\t\tuvc_dbg_cont(PROBE, \" <- SU %d\", entity->id);\n\n\t\t \n\t\tif (entity->bNrInPins == 1)\n\t\t\tbreak;\n\n\t\tif (chain->selector != NULL) {\n\t\t\tuvc_dbg(chain->dev, DESCR,\n\t\t\t\t\"Found multiple Selector Units in chain\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tchain->selector = entity;\n\t\tbreak;\n\n\tcase UVC_ITT_VENDOR_SPECIFIC:\n\tcase UVC_ITT_CAMERA:\n\tcase UVC_ITT_MEDIA_TRANSPORT_INPUT:\n\t\tuvc_dbg_cont(PROBE, \" <- IT %d\\n\", entity->id);\n\n\t\tbreak;\n\n\tcase UVC_OTT_VENDOR_SPECIFIC:\n\tcase UVC_OTT_DISPLAY:\n\tcase UVC_OTT_MEDIA_TRANSPORT_OUTPUT:\n\t\tuvc_dbg_cont(PROBE, \" OT %d\", entity->id);\n\n\t\tbreak;\n\n\tcase UVC_TT_STREAMING:\n\t\tif (UVC_ENTITY_IS_ITERM(entity))\n\t\t\tuvc_dbg_cont(PROBE, \" <- IT %d\\n\", entity->id);\n\t\telse\n\t\t\tuvc_dbg_cont(PROBE, \" OT %d\", entity->id);\n\n\t\tbreak;\n\n\tdefault:\n\t\tuvc_dbg(chain->dev, DESCR,\n\t\t\t\"Unsupported entity type 0x%04x found in chain\\n\",\n\t\t\tUVC_ENTITY_TYPE(entity));\n\t\treturn -1;\n\t}\n\n\tlist_add_tail(&entity->chain, &chain->entities);\n\treturn 0;\n}\n\nstatic int uvc_scan_chain_forward(struct uvc_video_chain *chain,\n\tstruct uvc_entity *entity, struct uvc_entity *prev)\n{\n\tstruct uvc_entity *forward;\n\tint found;\n\n\t \n\tforward = NULL;\n\tfound = 0;\n\n\twhile (1) {\n\t\tforward = uvc_entity_by_reference(chain->dev, entity->id,\n\t\t\tforward);\n\t\tif (forward == NULL)\n\t\t\tbreak;\n\t\tif (forward == prev)\n\t\t\tcontinue;\n\t\tif (forward->chain.next || forward->chain.prev) {\n\t\t\tuvc_dbg(chain->dev, DESCR,\n\t\t\t\t\"Found reference to entity %d already in chain\\n\",\n\t\t\t\tforward->id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (UVC_ENTITY_TYPE(forward)) {\n\t\tcase UVC_VC_EXTENSION_UNIT:\n\t\t\tif (forward->bNrInPins != 1) {\n\t\t\t\tuvc_dbg(chain->dev, DESCR,\n\t\t\t\t\t\"Extension unit %d has more than 1 input pin\\n\",\n\t\t\t\t\tforward->id);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (UVC_ENTITY_IS_OTERM(entity)) {\n\t\t\t\tstruct uvc_entity *source;\n\n\t\t\t\tsource = uvc_entity_by_id(chain->dev,\n\t\t\t\t\t\t\t  entity->baSourceID[0]);\n\t\t\t\tif (!source) {\n\t\t\t\t\tuvc_dbg(chain->dev, DESCR,\n\t\t\t\t\t\t\"Can't connect extension unit %u in chain\\n\",\n\t\t\t\t\t\tforward->id);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tforward->baSourceID[0] = source->id;\n\t\t\t}\n\n\t\t\tlist_add_tail(&forward->chain, &chain->entities);\n\t\t\tif (!found)\n\t\t\t\tuvc_dbg_cont(PROBE, \" (->\");\n\n\t\t\tuvc_dbg_cont(PROBE, \" XU %d\", forward->id);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\n\t\tcase UVC_OTT_VENDOR_SPECIFIC:\n\t\tcase UVC_OTT_DISPLAY:\n\t\tcase UVC_OTT_MEDIA_TRANSPORT_OUTPUT:\n\t\tcase UVC_TT_STREAMING:\n\t\t\tif (UVC_ENTITY_IS_ITERM(forward)) {\n\t\t\t\tuvc_dbg(chain->dev, DESCR,\n\t\t\t\t\t\"Unsupported input terminal %u\\n\",\n\t\t\t\t\tforward->id);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (UVC_ENTITY_IS_OTERM(entity)) {\n\t\t\t\tuvc_dbg(chain->dev, DESCR,\n\t\t\t\t\t\"Unsupported connection between output terminals %u and %u\\n\",\n\t\t\t\t\tentity->id, forward->id);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlist_add_tail(&forward->chain, &chain->entities);\n\t\t\tif (!found)\n\t\t\t\tuvc_dbg_cont(PROBE, \" (->\");\n\n\t\t\tuvc_dbg_cont(PROBE, \" OT %d\", forward->id);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found)\n\t\tuvc_dbg_cont(PROBE, \")\");\n\n\treturn 0;\n}\n\nstatic int uvc_scan_chain_backward(struct uvc_video_chain *chain,\n\tstruct uvc_entity **_entity)\n{\n\tstruct uvc_entity *entity = *_entity;\n\tstruct uvc_entity *term;\n\tint id = -EINVAL, i;\n\n\tswitch (UVC_ENTITY_TYPE(entity)) {\n\tcase UVC_VC_EXTENSION_UNIT:\n\tcase UVC_VC_PROCESSING_UNIT:\n\t\tid = entity->baSourceID[0];\n\t\tbreak;\n\n\tcase UVC_VC_SELECTOR_UNIT:\n\t\t \n\t\tif (entity->bNrInPins == 1) {\n\t\t\tid = entity->baSourceID[0];\n\t\t\tbreak;\n\t\t}\n\n\t\tuvc_dbg_cont(PROBE, \" <- IT\");\n\n\t\tchain->selector = entity;\n\t\tfor (i = 0; i < entity->bNrInPins; ++i) {\n\t\t\tid = entity->baSourceID[i];\n\t\t\tterm = uvc_entity_by_id(chain->dev, id);\n\t\t\tif (term == NULL || !UVC_ENTITY_IS_ITERM(term)) {\n\t\t\t\tuvc_dbg(chain->dev, DESCR,\n\t\t\t\t\t\"Selector unit %d input %d isn't connected to an input terminal\\n\",\n\t\t\t\t\tentity->id, i);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (term->chain.next || term->chain.prev) {\n\t\t\t\tuvc_dbg(chain->dev, DESCR,\n\t\t\t\t\t\"Found reference to entity %d already in chain\\n\",\n\t\t\t\t\tterm->id);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tuvc_dbg_cont(PROBE, \" %d\", term->id);\n\n\t\t\tlist_add_tail(&term->chain, &chain->entities);\n\t\t\tuvc_scan_chain_forward(chain, term, entity);\n\t\t}\n\n\t\tuvc_dbg_cont(PROBE, \"\\n\");\n\n\t\tid = 0;\n\t\tbreak;\n\n\tcase UVC_ITT_VENDOR_SPECIFIC:\n\tcase UVC_ITT_CAMERA:\n\tcase UVC_ITT_MEDIA_TRANSPORT_INPUT:\n\tcase UVC_OTT_VENDOR_SPECIFIC:\n\tcase UVC_OTT_DISPLAY:\n\tcase UVC_OTT_MEDIA_TRANSPORT_OUTPUT:\n\tcase UVC_TT_STREAMING:\n\t\tid = UVC_ENTITY_IS_OTERM(entity) ? entity->baSourceID[0] : 0;\n\t\tbreak;\n\t}\n\n\tif (id <= 0) {\n\t\t*_entity = NULL;\n\t\treturn id;\n\t}\n\n\tentity = uvc_entity_by_id(chain->dev, id);\n\tif (entity == NULL) {\n\t\tuvc_dbg(chain->dev, DESCR,\n\t\t\t\"Found reference to unknown entity %d\\n\", id);\n\t\treturn -EINVAL;\n\t}\n\n\t*_entity = entity;\n\treturn 0;\n}\n\nstatic int uvc_scan_chain(struct uvc_video_chain *chain,\n\t\t\t  struct uvc_entity *term)\n{\n\tstruct uvc_entity *entity, *prev;\n\n\tuvc_dbg(chain->dev, PROBE, \"Scanning UVC chain:\");\n\n\tentity = term;\n\tprev = NULL;\n\n\twhile (entity != NULL) {\n\t\t \n\t\tif (entity->chain.next || entity->chain.prev) {\n\t\t\tuvc_dbg(chain->dev, DESCR,\n\t\t\t\t\"Found reference to entity %d already in chain\\n\",\n\t\t\t\tentity->id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (uvc_scan_chain_entity(chain, entity) < 0)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (uvc_scan_chain_forward(chain, entity, prev) < 0)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tprev = entity;\n\t\tif (uvc_scan_chain_backward(chain, &entity) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int uvc_print_terms(struct list_head *terms, u16 dir,\n\t\tchar *buffer)\n{\n\tstruct uvc_entity *term;\n\tunsigned int nterms = 0;\n\tchar *p = buffer;\n\n\tlist_for_each_entry(term, terms, chain) {\n\t\tif (!UVC_ENTITY_IS_TERM(term) ||\n\t\t    UVC_TERM_DIRECTION(term) != dir)\n\t\t\tcontinue;\n\n\t\tif (nterms)\n\t\t\tp += sprintf(p, \",\");\n\t\tif (++nterms >= 4) {\n\t\t\tp += sprintf(p, \"...\");\n\t\t\tbreak;\n\t\t}\n\t\tp += sprintf(p, \"%u\", term->id);\n\t}\n\n\treturn p - buffer;\n}\n\nstatic const char *uvc_print_chain(struct uvc_video_chain *chain)\n{\n\tstatic char buffer[43];\n\tchar *p = buffer;\n\n\tp += uvc_print_terms(&chain->entities, UVC_TERM_INPUT, p);\n\tp += sprintf(p, \" -> \");\n\tuvc_print_terms(&chain->entities, UVC_TERM_OUTPUT, p);\n\n\treturn buffer;\n}\n\nstatic struct uvc_video_chain *uvc_alloc_chain(struct uvc_device *dev)\n{\n\tstruct uvc_video_chain *chain;\n\n\tchain = kzalloc(sizeof(*chain), GFP_KERNEL);\n\tif (chain == NULL)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chain->entities);\n\tmutex_init(&chain->ctrl_mutex);\n\tchain->dev = dev;\n\tv4l2_prio_init(&chain->prio);\n\n\treturn chain;\n}\n\n \nstatic int uvc_scan_fallback(struct uvc_device *dev)\n{\n\tstruct uvc_video_chain *chain;\n\tstruct uvc_entity *iterm = NULL;\n\tstruct uvc_entity *oterm = NULL;\n\tstruct uvc_entity *entity;\n\tstruct uvc_entity *prev;\n\n\t \n\tlist_for_each_entry(entity, &dev->entities, list) {\n\t\tif (UVC_ENTITY_IS_ITERM(entity)) {\n\t\t\tif (iterm)\n\t\t\t\treturn -EINVAL;\n\t\t\titerm = entity;\n\t\t}\n\n\t\tif (UVC_ENTITY_IS_OTERM(entity)) {\n\t\t\tif (oterm)\n\t\t\t\treturn -EINVAL;\n\t\t\toterm = entity;\n\t\t}\n\t}\n\n\tif (iterm == NULL || oterm == NULL)\n\t\treturn -EINVAL;\n\n\t \n\tchain = uvc_alloc_chain(dev);\n\tif (chain == NULL)\n\t\treturn -ENOMEM;\n\n\tif (uvc_scan_chain_entity(chain, oterm) < 0)\n\t\tgoto error;\n\n\tprev = oterm;\n\n\t \n\tlist_for_each_entry_reverse(entity, &dev->entities, list) {\n\t\tif (entity->type != UVC_VC_PROCESSING_UNIT &&\n\t\t    entity->type != UVC_VC_EXTENSION_UNIT)\n\t\t\tcontinue;\n\n\t\tif (entity->num_pads != 2)\n\t\t\tcontinue;\n\n\t\tif (uvc_scan_chain_entity(chain, entity) < 0)\n\t\t\tgoto error;\n\n\t\tprev->baSourceID[0] = entity->id;\n\t\tprev = entity;\n\t}\n\n\tif (uvc_scan_chain_entity(chain, iterm) < 0)\n\t\tgoto error;\n\n\tprev->baSourceID[0] = iterm->id;\n\n\tlist_add_tail(&chain->list, &dev->chains);\n\n\tuvc_dbg(dev, PROBE, \"Found a video chain by fallback heuristic (%s)\\n\",\n\t\tuvc_print_chain(chain));\n\n\treturn 0;\n\nerror:\n\tkfree(chain);\n\treturn -EINVAL;\n}\n\n \nstatic int uvc_scan_device(struct uvc_device *dev)\n{\n\tstruct uvc_video_chain *chain;\n\tstruct uvc_entity *term;\n\n\tlist_for_each_entry(term, &dev->entities, list) {\n\t\tif (!UVC_ENTITY_IS_OTERM(term))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (term->chain.next || term->chain.prev)\n\t\t\tcontinue;\n\n\t\tchain = uvc_alloc_chain(dev);\n\t\tif (chain == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tterm->flags |= UVC_ENTITY_FLAG_DEFAULT;\n\n\t\tif (uvc_scan_chain(chain, term) < 0) {\n\t\t\tkfree(chain);\n\t\t\tcontinue;\n\t\t}\n\n\t\tuvc_dbg(dev, PROBE, \"Found a valid video chain (%s)\\n\",\n\t\t\tuvc_print_chain(chain));\n\n\t\tlist_add_tail(&chain->list, &dev->chains);\n\t}\n\n\tif (list_empty(&dev->chains))\n\t\tuvc_scan_fallback(dev);\n\n\tif (list_empty(&dev->chains)) {\n\t\tdev_info(&dev->udev->dev, \"No valid video chain found.\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (dev->gpio_unit) {\n\t\tchain = list_first_entry(&dev->chains,\n\t\t\t\t\t struct uvc_video_chain, list);\n\t\tlist_add_tail(&dev->gpio_unit->chain, &chain->entities);\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic void uvc_delete(struct kref *kref)\n{\n\tstruct uvc_device *dev = container_of(kref, struct uvc_device, ref);\n\tstruct list_head *p, *n;\n\n\tuvc_status_cleanup(dev);\n\tuvc_ctrl_cleanup_device(dev);\n\n\tusb_put_intf(dev->intf);\n\tusb_put_dev(dev->udev);\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tmedia_device_cleanup(&dev->mdev);\n#endif\n\n\tlist_for_each_safe(p, n, &dev->chains) {\n\t\tstruct uvc_video_chain *chain;\n\n\t\tchain = list_entry(p, struct uvc_video_chain, list);\n\t\tkfree(chain);\n\t}\n\n\tlist_for_each_safe(p, n, &dev->entities) {\n\t\tstruct uvc_entity *entity;\n\n\t\tentity = list_entry(p, struct uvc_entity, list);\n#ifdef CONFIG_MEDIA_CONTROLLER\n\t\tuvc_mc_cleanup_entity(entity);\n#endif\n\t\tkfree(entity);\n\t}\n\n\tlist_for_each_safe(p, n, &dev->streams) {\n\t\tstruct uvc_streaming *streaming;\n\n\t\tstreaming = list_entry(p, struct uvc_streaming, list);\n\t\tusb_driver_release_interface(&uvc_driver.driver,\n\t\t\tstreaming->intf);\n\t\tuvc_stream_delete(streaming);\n\t}\n\n\tkfree(dev);\n}\n\nstatic void uvc_release(struct video_device *vdev)\n{\n\tstruct uvc_streaming *stream = video_get_drvdata(vdev);\n\tstruct uvc_device *dev = stream->dev;\n\n\tkref_put(&dev->ref, uvc_delete);\n}\n\n \nstatic void uvc_unregister_video(struct uvc_device *dev)\n{\n\tstruct uvc_streaming *stream;\n\n\tlist_for_each_entry(stream, &dev->streams, list) {\n\t\tif (!video_is_registered(&stream->vdev))\n\t\t\tcontinue;\n\n\t\tvideo_unregister_device(&stream->vdev);\n\t\tvideo_unregister_device(&stream->meta.vdev);\n\n\t\tuvc_debugfs_cleanup_stream(stream);\n\t}\n\n\tuvc_status_unregister(dev);\n\n\tif (dev->vdev.dev)\n\t\tv4l2_device_unregister(&dev->vdev);\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tif (media_devnode_is_registered(dev->mdev.devnode))\n\t\tmedia_device_unregister(&dev->mdev);\n#endif\n}\n\nint uvc_register_video_device(struct uvc_device *dev,\n\t\t\t      struct uvc_streaming *stream,\n\t\t\t      struct video_device *vdev,\n\t\t\t      struct uvc_video_queue *queue,\n\t\t\t      enum v4l2_buf_type type,\n\t\t\t      const struct v4l2_file_operations *fops,\n\t\t\t      const struct v4l2_ioctl_ops *ioctl_ops)\n{\n\tint ret;\n\n\t \n\tret = uvc_queue_init(queue, type, !uvc_no_drop_param);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\t \n\tvdev->v4l2_dev = &dev->vdev;\n\tvdev->fops = fops;\n\tvdev->ioctl_ops = ioctl_ops;\n\tvdev->release = uvc_release;\n\tvdev->prio = &stream->chain->prio;\n\tif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\tvdev->vfl_dir = VFL_DIR_TX;\n\telse\n\t\tvdev->vfl_dir = VFL_DIR_RX;\n\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\tdefault:\n\t\tvdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tvdev->device_caps = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_META_CAPTURE:\n\t\tvdev->device_caps = V4L2_CAP_META_CAPTURE | V4L2_CAP_STREAMING;\n\t\tbreak;\n\t}\n\n\tstrscpy(vdev->name, dev->name, sizeof(vdev->name));\n\n\t \n\tvideo_set_drvdata(vdev, stream);\n\n\tret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret < 0) {\n\t\tdev_err(&stream->intf->dev,\n\t\t\t\"Failed to register %s device (%d).\\n\",\n\t\t\tv4l2_type_names[type], ret);\n\t\treturn ret;\n\t}\n\n\tkref_get(&dev->ref);\n\treturn 0;\n}\n\nstatic int uvc_register_video(struct uvc_device *dev,\n\t\tstruct uvc_streaming *stream)\n{\n\tint ret;\n\n\t \n\tret = uvc_video_init(stream);\n\tif (ret < 0) {\n\t\tdev_err(&stream->intf->dev,\n\t\t\t\"Failed to initialize the device (%d).\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\tstream->chain->caps |= V4L2_CAP_VIDEO_CAPTURE\n\t\t\t| V4L2_CAP_META_CAPTURE;\n\telse\n\t\tstream->chain->caps |= V4L2_CAP_VIDEO_OUTPUT;\n\n\tuvc_debugfs_init_stream(stream);\n\n\t \n\treturn uvc_register_video_device(dev, stream, &stream->vdev,\n\t\t\t\t\t &stream->queue, stream->type,\n\t\t\t\t\t &uvc_fops, &uvc_ioctl_ops);\n}\n\n \nstatic int uvc_register_terms(struct uvc_device *dev,\n\tstruct uvc_video_chain *chain)\n{\n\tstruct uvc_streaming *stream;\n\tstruct uvc_entity *term;\n\tint ret;\n\n\tlist_for_each_entry(term, &chain->entities, chain) {\n\t\tif (UVC_ENTITY_TYPE(term) != UVC_TT_STREAMING)\n\t\t\tcontinue;\n\n\t\tstream = uvc_stream_by_id(dev, term->id);\n\t\tif (stream == NULL) {\n\t\t\tdev_info(&dev->udev->dev,\n\t\t\t\t \"No streaming interface found for terminal %u.\",\n\t\t\t\t term->id);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstream->chain = chain;\n\t\tret = uvc_register_video(dev, stream);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tuvc_meta_register(stream);\n\n\t\tterm->vdev = &stream->vdev;\n\t}\n\n\treturn 0;\n}\n\nstatic int uvc_register_chains(struct uvc_device *dev)\n{\n\tstruct uvc_video_chain *chain;\n\tint ret;\n\n\tlist_for_each_entry(chain, &dev->chains, list) {\n\t\tret = uvc_register_terms(dev, chain);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\t\tret = uvc_mc_register_entities(chain);\n\t\tif (ret < 0)\n\t\t\tdev_info(&dev->udev->dev,\n\t\t\t\t \"Failed to register entities (%d).\\n\", ret);\n#endif\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic const struct uvc_device_info uvc_quirk_none = { 0 };\n\nstatic int uvc_probe(struct usb_interface *intf,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct uvc_device *dev;\n\tconst struct uvc_device_info *info =\n\t\t(const struct uvc_device_info *)id->driver_info;\n\tint function;\n\tint ret;\n\n\t \n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&dev->entities);\n\tINIT_LIST_HEAD(&dev->chains);\n\tINIT_LIST_HEAD(&dev->streams);\n\tkref_init(&dev->ref);\n\tatomic_set(&dev->nmappings, 0);\n\tmutex_init(&dev->lock);\n\n\tdev->udev = usb_get_dev(udev);\n\tdev->intf = usb_get_intf(intf);\n\tdev->intfnum = intf->cur_altsetting->desc.bInterfaceNumber;\n\tdev->info = info ? info : &uvc_quirk_none;\n\tdev->quirks = uvc_quirks_param == -1\n\t\t    ? dev->info->quirks : uvc_quirks_param;\n\n\tif (id->idVendor && id->idProduct)\n\t\tuvc_dbg(dev, PROBE, \"Probing known UVC device %s (%04x:%04x)\\n\",\n\t\t\tudev->devpath, id->idVendor, id->idProduct);\n\telse\n\t\tuvc_dbg(dev, PROBE, \"Probing generic UVC device %s\\n\",\n\t\t\tudev->devpath);\n\n\tif (udev->product != NULL)\n\t\tstrscpy(dev->name, udev->product, sizeof(dev->name));\n\telse\n\t\tsnprintf(dev->name, sizeof(dev->name),\n\t\t\t \"UVC Camera (%04x:%04x)\",\n\t\t\t le16_to_cpu(udev->descriptor.idVendor),\n\t\t\t le16_to_cpu(udev->descriptor.idProduct));\n\n\t \n\tif (intf->intf_assoc && intf->intf_assoc->iFunction != 0)\n\t\tfunction = intf->intf_assoc->iFunction;\n\telse\n\t\tfunction = intf->cur_altsetting->desc.iInterface;\n\tif (function != 0) {\n\t\tsize_t len;\n\n\t\tstrlcat(dev->name, \": \", sizeof(dev->name));\n\t\tlen = strlen(dev->name);\n\t\tusb_string(udev, function, dev->name + len,\n\t\t\t   sizeof(dev->name) - len);\n\t}\n\n\t \n#ifdef CONFIG_MEDIA_CONTROLLER\n\tdev->mdev.dev = &intf->dev;\n\tstrscpy(dev->mdev.model, dev->name, sizeof(dev->mdev.model));\n\tif (udev->serial)\n\t\tstrscpy(dev->mdev.serial, udev->serial,\n\t\t\tsizeof(dev->mdev.serial));\n\tusb_make_path(udev, dev->mdev.bus_info, sizeof(dev->mdev.bus_info));\n\tdev->mdev.hw_revision = le16_to_cpu(udev->descriptor.bcdDevice);\n\tmedia_device_init(&dev->mdev);\n\n\tdev->vdev.mdev = &dev->mdev;\n#endif\n\n\t \n\tif (uvc_parse_control(dev) < 0) {\n\t\tuvc_dbg(dev, PROBE, \"Unable to parse UVC descriptors\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tif (uvc_gpio_parse(dev) < 0) {\n\t\tuvc_dbg(dev, PROBE, \"Unable to parse UVC GPIOs\\n\");\n\t\tgoto error;\n\t}\n\n\tdev_info(&dev->udev->dev, \"Found UVC %u.%02x device %s (%04x:%04x)\\n\",\n\t\t dev->uvc_version >> 8, dev->uvc_version & 0xff,\n\t\t udev->product ? udev->product : \"<unnamed>\",\n\t\t le16_to_cpu(udev->descriptor.idVendor),\n\t\t le16_to_cpu(udev->descriptor.idProduct));\n\n\tif (dev->quirks != dev->info->quirks) {\n\t\tdev_info(&dev->udev->dev,\n\t\t\t \"Forcing device quirks to 0x%x by module parameter for testing purpose.\\n\",\n\t\t\t dev->quirks);\n\t\tdev_info(&dev->udev->dev,\n\t\t\t \"Please report required quirks to the linux-media mailing list.\\n\");\n\t}\n\n\tif (dev->info->uvc_version) {\n\t\tdev->uvc_version = dev->info->uvc_version;\n\t\tdev_info(&dev->udev->dev, \"Forcing UVC version to %u.%02x\\n\",\n\t\t\t dev->uvc_version >> 8, dev->uvc_version & 0xff);\n\t}\n\n\t \n\tif (v4l2_device_register(&intf->dev, &dev->vdev) < 0)\n\t\tgoto error;\n\n\t \n\tif (uvc_scan_device(dev) < 0)\n\t\tgoto error;\n\n\t \n\tif (uvc_ctrl_init_device(dev) < 0)\n\t\tgoto error;\n\n\t \n\tif (uvc_register_chains(dev) < 0)\n\t\tgoto error;\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\t \n\tif (media_device_register(&dev->mdev) < 0)\n\t\tgoto error;\n#endif\n\t \n\tusb_set_intfdata(intf, dev);\n\n\t \n\tret = uvc_status_init(dev);\n\tif (ret < 0) {\n\t\tdev_info(&dev->udev->dev,\n\t\t\t \"Unable to initialize the status endpoint (%d), status interrupt will not be supported.\\n\",\n\t\t\t ret);\n\t}\n\n\tret = uvc_gpio_init_irq(dev);\n\tif (ret < 0) {\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"Unable to request privacy GPIO IRQ (%d)\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tuvc_dbg(dev, PROBE, \"UVC device initialized\\n\");\n\tusb_enable_autosuspend(udev);\n\treturn 0;\n\nerror:\n\tuvc_unregister_video(dev);\n\tkref_put(&dev->ref, uvc_delete);\n\treturn -ENODEV;\n}\n\nstatic void uvc_disconnect(struct usb_interface *intf)\n{\n\tstruct uvc_device *dev = usb_get_intfdata(intf);\n\n\t \n\tusb_set_intfdata(intf, NULL);\n\n\tif (intf->cur_altsetting->desc.bInterfaceSubClass ==\n\t    UVC_SC_VIDEOSTREAMING)\n\t\treturn;\n\n\tuvc_unregister_video(dev);\n\tkref_put(&dev->ref, uvc_delete);\n}\n\nstatic int uvc_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct uvc_device *dev = usb_get_intfdata(intf);\n\tstruct uvc_streaming *stream;\n\n\tuvc_dbg(dev, SUSPEND, \"Suspending interface %u\\n\",\n\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\n\t \n\tif (intf->cur_altsetting->desc.bInterfaceSubClass ==\n\t    UVC_SC_VIDEOCONTROL) {\n\t\tmutex_lock(&dev->lock);\n\t\tif (dev->users)\n\t\t\tuvc_status_stop(dev);\n\t\tmutex_unlock(&dev->lock);\n\t\treturn 0;\n\t}\n\n\tlist_for_each_entry(stream, &dev->streams, list) {\n\t\tif (stream->intf == intf)\n\t\t\treturn uvc_video_suspend(stream);\n\t}\n\n\tuvc_dbg(dev, SUSPEND,\n\t\t\"Suspend: video streaming USB interface mismatch\\n\");\n\treturn -EINVAL;\n}\n\nstatic int __uvc_resume(struct usb_interface *intf, int reset)\n{\n\tstruct uvc_device *dev = usb_get_intfdata(intf);\n\tstruct uvc_streaming *stream;\n\tint ret = 0;\n\n\tuvc_dbg(dev, SUSPEND, \"Resuming interface %u\\n\",\n\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\n\tif (intf->cur_altsetting->desc.bInterfaceSubClass ==\n\t    UVC_SC_VIDEOCONTROL) {\n\t\tif (reset) {\n\t\t\tret = uvc_ctrl_restore_values(dev);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tmutex_lock(&dev->lock);\n\t\tif (dev->users)\n\t\t\tret = uvc_status_start(dev, GFP_NOIO);\n\t\tmutex_unlock(&dev->lock);\n\n\t\treturn ret;\n\t}\n\n\tlist_for_each_entry(stream, &dev->streams, list) {\n\t\tif (stream->intf == intf) {\n\t\t\tret = uvc_video_resume(stream, reset);\n\t\t\tif (ret < 0)\n\t\t\t\tuvc_queue_streamoff(&stream->queue,\n\t\t\t\t\t\t    stream->queue.queue.type);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tuvc_dbg(dev, SUSPEND,\n\t\t\"Resume: video streaming USB interface mismatch\\n\");\n\treturn -EINVAL;\n}\n\nstatic int uvc_resume(struct usb_interface *intf)\n{\n\treturn __uvc_resume(intf, 0);\n}\n\nstatic int uvc_reset_resume(struct usb_interface *intf)\n{\n\treturn __uvc_resume(intf, 1);\n}\n\n \n\nstatic int uvc_clock_param_get(char *buffer, const struct kernel_param *kp)\n{\n\tif (uvc_clock_param == CLOCK_MONOTONIC)\n\t\treturn sprintf(buffer, \"CLOCK_MONOTONIC\");\n\telse\n\t\treturn sprintf(buffer, \"CLOCK_REALTIME\");\n}\n\nstatic int uvc_clock_param_set(const char *val, const struct kernel_param *kp)\n{\n\tif (strncasecmp(val, \"clock_\", strlen(\"clock_\")) == 0)\n\t\tval += strlen(\"clock_\");\n\n\tif (strcasecmp(val, \"monotonic\") == 0)\n\t\tuvc_clock_param = CLOCK_MONOTONIC;\n\telse if (strcasecmp(val, \"realtime\") == 0)\n\t\tuvc_clock_param = CLOCK_REALTIME;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nmodule_param_call(clock, uvc_clock_param_set, uvc_clock_param_get,\n\t\t  &uvc_clock_param, 0644);\nMODULE_PARM_DESC(clock, \"Video buffers timestamp clock\");\nmodule_param_named(hwtimestamps, uvc_hw_timestamps_param, uint, 0644);\nMODULE_PARM_DESC(hwtimestamps, \"Use hardware timestamps\");\nmodule_param_named(nodrop, uvc_no_drop_param, uint, 0644);\nMODULE_PARM_DESC(nodrop, \"Don't drop incomplete frames\");\nmodule_param_named(quirks, uvc_quirks_param, uint, 0644);\nMODULE_PARM_DESC(quirks, \"Forced device quirks\");\nmodule_param_named(trace, uvc_dbg_param, uint, 0644);\nMODULE_PARM_DESC(trace, \"Trace level bitmask\");\nmodule_param_named(timeout, uvc_timeout_param, uint, 0644);\nMODULE_PARM_DESC(timeout, \"Streaming control requests timeout\");\n\n \n\nstatic const struct uvc_device_info uvc_ctrl_power_line_limited = {\n\t.mappings = (const struct uvc_control_mapping *[]) {\n\t\t&uvc_ctrl_power_line_mapping_limited,\n\t\tNULL,  \n\t},\n};\n\nstatic const struct uvc_device_info uvc_ctrl_power_line_uvc11 = {\n\t.mappings = (const struct uvc_control_mapping *[]) {\n\t\t&uvc_ctrl_power_line_mapping_uvc11,\n\t\tNULL,  \n\t},\n};\n\nstatic const struct uvc_device_info uvc_quirk_probe_minmax = {\n\t.quirks = UVC_QUIRK_PROBE_MINMAX,\n};\n\nstatic const struct uvc_device_info uvc_quirk_fix_bandwidth = {\n\t.quirks = UVC_QUIRK_FIX_BANDWIDTH,\n};\n\nstatic const struct uvc_device_info uvc_quirk_probe_def = {\n\t.quirks = UVC_QUIRK_PROBE_DEF,\n};\n\nstatic const struct uvc_device_info uvc_quirk_stream_no_fid = {\n\t.quirks = UVC_QUIRK_STREAM_NO_FID,\n};\n\nstatic const struct uvc_device_info uvc_quirk_force_y8 = {\n\t.quirks = UVC_QUIRK_FORCE_Y8,\n};\n\n#define UVC_INFO_QUIRK(q) (kernel_ulong_t)&(struct uvc_device_info){.quirks = q}\n#define UVC_INFO_META(m) (kernel_ulong_t)&(struct uvc_device_info) \\\n\t{.meta_format = m}\n\n \nstatic const struct usb_device_id uvc_ids[] = {\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x0408,\n\t  .idProduct\t\t= 0x3090,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_ctrl_power_line_limited },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x0408,\n\t  .idProduct\t\t= 0x4030,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_ctrl_power_line_limited },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x0408,\n\t  .idProduct\t\t= 0x4034,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= UVC_PC_PROTOCOL_15,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_ctrl_power_line_limited },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x0416,\n\t  .idProduct\t\t= 0xa91a,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_probe_minmax },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x0458,\n\t  .idProduct\t\t= 0x706e,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_probe_minmax },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x045e,\n\t  .idProduct\t\t= 0x00f8,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_probe_minmax },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x045e,\n\t  .idProduct\t\t= 0x0721,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_probe_def },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x045e,\n\t  .idProduct\t\t= 0x0723,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_probe_minmax },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x046d,\n\t  .idProduct\t\t= 0x0821,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= UVC_INFO_QUIRK(UVC_QUIRK_WAKE_AUTOSUSPEND)},\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x046d,\n\t  .idProduct\t\t= 0x0823,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= UVC_INFO_QUIRK(UVC_QUIRK_WAKE_AUTOSUSPEND)},\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x046d,\n\t  .idProduct\t\t= 0x08c1,\n\t  .bInterfaceClass\t= USB_CLASS_VENDOR_SPEC,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0 },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x046d,\n\t  .idProduct\t\t= 0x08c2,\n\t  .bInterfaceClass\t= USB_CLASS_VENDOR_SPEC,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0 },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x046d,\n\t  .idProduct\t\t= 0x08c3,\n\t  .bInterfaceClass\t= USB_CLASS_VENDOR_SPEC,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0 },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x046d,\n\t  .idProduct\t\t= 0x08c5,\n\t  .bInterfaceClass\t= USB_CLASS_VENDOR_SPEC,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0 },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x046d,\n\t  .idProduct\t\t= 0x08c6,\n\t  .bInterfaceClass\t= USB_CLASS_VENDOR_SPEC,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0 },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x046d,\n\t  .idProduct\t\t= 0x08c7,\n\t  .bInterfaceClass\t= USB_CLASS_VENDOR_SPEC,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0 },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x046d,\n\t  .idProduct\t\t= 0x082d,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= UVC_INFO_QUIRK(UVC_QUIRK_RESTORE_CTRLS_ON_INIT) },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x04f2,\n\t  .idProduct\t\t= 0xb071,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= UVC_INFO_QUIRK(UVC_QUIRK_RESTRICT_FRAME_RATE) },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x04f2,\n\t  .idProduct\t\t= 0xb5eb,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_ctrl_power_line_limited },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x04f2,\n\t  .idProduct\t\t= 0xb6ba,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_ctrl_power_line_limited },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x04f2,\n\t  .idProduct\t\t= 0xb746,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_ctrl_power_line_limited },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x058f,\n\t  .idProduct\t\t= 0x3820,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_probe_minmax },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x05a9,\n\t  .idProduct\t\t= 0x2640,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_probe_def },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x05a9,\n\t  .idProduct\t\t= 0x2641,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_probe_def },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x05a9,\n\t  .idProduct\t\t= 0x2643,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_probe_def },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x05a9,\n\t  .idProduct\t\t= 0x264a,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_probe_def },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x05a9,\n\t  .idProduct\t\t= 0x7670,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_probe_def },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x05ac,\n\t  .idProduct\t\t= 0x8501,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= UVC_INFO_QUIRK(UVC_QUIRK_PROBE_MINMAX\n\t\t\t\t\t| UVC_QUIRK_BUILTIN_ISIGHT) },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x05ac,\n\t  .idProduct\t\t= 0x8514,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_probe_def },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x05ac,\n\t  .idProduct\t\t= 0x8600,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_probe_def },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x05c8,\n\t  .idProduct\t\t= 0x0403,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_fix_bandwidth },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x05e3,\n\t  .idProduct\t\t= 0x0505,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_stream_no_fid },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x06f8,\n\t  .idProduct\t\t= 0x300c,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_fix_bandwidth },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x0ac8,\n\t  .idProduct\t\t= 0x332d,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_fix_bandwidth },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x0ac8,\n\t  .idProduct\t\t= 0x3410,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_fix_bandwidth },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x0ac8,\n\t  .idProduct\t\t= 0x3420,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_fix_bandwidth },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x0bd3,\n\t  .idProduct\t\t= 0x0555,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_probe_minmax },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x0e8d,\n\t  .idProduct\t\t= 0x0004,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= UVC_INFO_QUIRK(UVC_QUIRK_PROBE_MINMAX\n\t\t\t\t\t| UVC_QUIRK_PROBE_DEF) },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x13d3,\n\t  .idProduct\t\t= 0x5103,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_stream_no_fid },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x152d,\n\t  .idProduct\t\t= 0x0310,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_probe_minmax },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x174f,\n\t  .idProduct\t\t= 0x5212,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_stream_no_fid },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x174f,\n\t  .idProduct\t\t= 0x5931,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_stream_no_fid },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x174f,\n\t  .idProduct\t\t= 0x8a12,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_stream_no_fid },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x174f,\n\t  .idProduct\t\t= 0x8a31,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_stream_no_fid },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x174f,\n\t  .idProduct\t\t= 0x8a33,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_stream_no_fid },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x174f,\n\t  .idProduct\t\t= 0x8a34,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_stream_no_fid },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x17dc,\n\t  .idProduct\t\t= 0x0202,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_stream_no_fid },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x17ef,\n\t  .idProduct\t\t= 0x480b,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_stream_no_fid },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x1871,\n\t  .idProduct\t\t= 0x0306,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= UVC_INFO_QUIRK(UVC_QUIRK_PROBE_MINMAX\n\t\t\t\t\t| UVC_QUIRK_PROBE_EXTRAFIELDS) },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x1871,\n\t  .idProduct\t\t= 0x0516,\n\t  .bInterfaceClass\t= USB_CLASS_VENDOR_SPEC,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0 },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x18cd,\n\t  .idProduct\t\t= 0xcafe,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= UVC_INFO_QUIRK(UVC_QUIRK_PROBE_EXTRAFIELDS) },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x18ec,\n\t  .idProduct\t\t= 0x3188,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_probe_minmax },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x18ec,\n\t  .idProduct\t\t= 0x3288,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_probe_minmax },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x18ec,\n\t  .idProduct\t\t= 0x3290,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_probe_def },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x199e,\n\t  .idProduct\t\t= 0x8102,\n\t  .bInterfaceClass\t= USB_CLASS_VENDOR_SPEC,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0 },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_DEV_HI\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x19ab,\n\t  .idProduct\t\t= 0x1000,\n\t  .bcdDevice_hi\t\t= 0x0126,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= UVC_INFO_QUIRK(UVC_QUIRK_STATUS_INTERVAL) },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x1b3b,\n\t  .idProduct\t\t= 0x2951,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_probe_minmax },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x1b3f,\n\t  .idProduct\t\t= 0x2002,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_probe_minmax },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x1bcf,\n\t  .idProduct\t\t= 0x0b40,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&(const struct uvc_device_info){\n\t\t.uvc_version = 0x010a,\n\t  } },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x1c4f,\n\t  .idProduct\t\t= 0x3000,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= UVC_INFO_QUIRK(UVC_QUIRK_PROBE_MINMAX\n\t\t\t\t\t| UVC_QUIRK_IGNORE_SELECTOR_UNIT) },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x2833,\n\t  .idProduct\t\t= 0x0201,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_force_y8 },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x2833,\n\t  .idProduct\t\t= 0x0211,\n\t  .bInterfaceClass\t= USB_CLASS_VENDOR_SPEC,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_quirk_force_y8 },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x29fe,\n\t  .idProduct\t\t= 0x4d53,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= UVC_INFO_QUIRK(UVC_QUIRK_FORCE_BPP) },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x30c9,\n\t  .idProduct\t\t= 0x0093,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= UVC_PC_PROTOCOL_15,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_ctrl_power_line_uvc11 },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x3277,\n\t  .idProduct\t\t= 0x0072,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_ctrl_power_line_limited },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x5986,\n\t  .idProduct\t\t= 0x1172,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_ctrl_power_line_limited },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x5986,\n\t  .idProduct\t\t= 0x1180,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= (kernel_ulong_t)&uvc_ctrl_power_line_limited },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x8086,\n\t  .idProduct\t\t= 0x0ad2,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= UVC_INFO_META(V4L2_META_FMT_D4XX) },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x8086,\n\t  .idProduct\t\t= 0x0ad3,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= UVC_INFO_META(V4L2_META_FMT_D4XX) },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x8086,\n\t  .idProduct\t\t= 0x0ad4,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= UVC_INFO_META(V4L2_META_FMT_D4XX) },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x8086,\n\t  .idProduct\t\t= 0x0b03,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= UVC_INFO_META(V4L2_META_FMT_D4XX) },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x8086,\n\t  .idProduct\t\t= 0x0b07,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= UVC_INFO_META(V4L2_META_FMT_D4XX) },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x8086,\n\t  .idProduct\t\t= 0x0b3a,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= UVC_INFO_META(V4L2_META_FMT_D4XX) },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x8086,\n\t  .idProduct\t\t= 0x0b5b,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= UVC_INFO_META(V4L2_META_FMT_D4XX) },\n\t \n\t{ .match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE\n\t\t\t\t| USB_DEVICE_ID_MATCH_INT_INFO,\n\t  .idVendor\t\t= 0x8086,\n\t  .idProduct\t\t= 0x0b5c,\n\t  .bInterfaceClass\t= USB_CLASS_VIDEO,\n\t  .bInterfaceSubClass\t= 1,\n\t  .bInterfaceProtocol\t= 0,\n\t  .driver_info\t\t= UVC_INFO_META(V4L2_META_FMT_D4XX) },\n\t \n\t{ USB_INTERFACE_INFO(USB_CLASS_VIDEO, 1, UVC_PC_PROTOCOL_UNDEFINED) },\n\t{ USB_INTERFACE_INFO(USB_CLASS_VIDEO, 1, UVC_PC_PROTOCOL_15) },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, uvc_ids);\n\nstruct uvc_driver uvc_driver = {\n\t.driver = {\n\t\t.name\t\t= \"uvcvideo\",\n\t\t.probe\t\t= uvc_probe,\n\t\t.disconnect\t= uvc_disconnect,\n\t\t.suspend\t= uvc_suspend,\n\t\t.resume\t\t= uvc_resume,\n\t\t.reset_resume\t= uvc_reset_resume,\n\t\t.id_table\t= uvc_ids,\n\t\t.supports_autosuspend = 1,\n\t},\n};\n\nstatic int __init uvc_init(void)\n{\n\tint ret;\n\n\tuvc_debugfs_init();\n\n\tret = usb_register(&uvc_driver.driver);\n\tif (ret < 0) {\n\t\tuvc_debugfs_cleanup();\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit uvc_cleanup(void)\n{\n\tusb_deregister(&uvc_driver.driver);\n\tuvc_debugfs_cleanup();\n}\n\nmodule_init(uvc_init);\nmodule_exit(uvc_cleanup);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRIVER_VERSION);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}