{
  "module_name": "uvc_ctrl.c",
  "hash_id": "ce37ff38372ee561f2965894a7ee4134e351b0ce229333f3f03565296cd02faf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/uvc/uvc_ctrl.c",
  "human_readable_source": "\n \n\n#include <asm/barrier.h>\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/uvc.h>\n#include <linux/videodev2.h>\n#include <linux/vmalloc.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n#include <linux/atomic.h>\n#include <media/v4l2-ctrls.h>\n\n#include \"uvcvideo.h\"\n\n#define UVC_CTRL_DATA_CURRENT\t0\n#define UVC_CTRL_DATA_BACKUP\t1\n#define UVC_CTRL_DATA_MIN\t2\n#define UVC_CTRL_DATA_MAX\t3\n#define UVC_CTRL_DATA_RES\t4\n#define UVC_CTRL_DATA_DEF\t5\n#define UVC_CTRL_DATA_LAST\t6\n\n \n\nstatic const struct uvc_control_info uvc_ctrls[] = {\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_BRIGHTNESS_CONTROL,\n\t\t.index\t\t= 0,\n\t\t.size\t\t= 2,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_RANGE\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_CONTRAST_CONTROL,\n\t\t.index\t\t= 1,\n\t\t.size\t\t= 2,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_RANGE\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_HUE_CONTROL,\n\t\t.index\t\t= 2,\n\t\t.size\t\t= 2,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_RANGE\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE\n\t\t\t\t| UVC_CTRL_FLAG_AUTO_UPDATE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_SATURATION_CONTROL,\n\t\t.index\t\t= 3,\n\t\t.size\t\t= 2,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_RANGE\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_SHARPNESS_CONTROL,\n\t\t.index\t\t= 4,\n\t\t.size\t\t= 2,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_RANGE\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_GAMMA_CONTROL,\n\t\t.index\t\t= 5,\n\t\t.size\t\t= 2,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_RANGE\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL,\n\t\t.index\t\t= 6,\n\t\t.size\t\t= 2,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_RANGE\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE\n\t\t\t\t| UVC_CTRL_FLAG_AUTO_UPDATE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL,\n\t\t.index\t\t= 7,\n\t\t.size\t\t= 4,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_RANGE\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE\n\t\t\t\t| UVC_CTRL_FLAG_AUTO_UPDATE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_BACKLIGHT_COMPENSATION_CONTROL,\n\t\t.index\t\t= 8,\n\t\t.size\t\t= 2,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_RANGE\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_GAIN_CONTROL,\n\t\t.index\t\t= 9,\n\t\t.size\t\t= 2,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_RANGE\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_POWER_LINE_FREQUENCY_CONTROL,\n\t\t.index\t\t= 10,\n\t\t.size\t\t= 1,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR | UVC_CTRL_FLAG_GET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_DEF | UVC_CTRL_FLAG_RESTORE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_HUE_AUTO_CONTROL,\n\t\t.index\t\t= 11,\n\t\t.size\t\t= 1,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR | UVC_CTRL_FLAG_GET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_DEF | UVC_CTRL_FLAG_RESTORE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL,\n\t\t.index\t\t= 12,\n\t\t.size\t\t= 1,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR | UVC_CTRL_FLAG_GET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_DEF | UVC_CTRL_FLAG_RESTORE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL,\n\t\t.index\t\t= 13,\n\t\t.size\t\t= 1,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR | UVC_CTRL_FLAG_GET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_DEF | UVC_CTRL_FLAG_RESTORE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_DIGITAL_MULTIPLIER_CONTROL,\n\t\t.index\t\t= 14,\n\t\t.size\t\t= 2,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_RANGE\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL,\n\t\t.index\t\t= 15,\n\t\t.size\t\t= 2,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_RANGE\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_ANALOG_VIDEO_STANDARD_CONTROL,\n\t\t.index\t\t= 16,\n\t\t.size\t\t= 1,\n\t\t.flags\t\t= UVC_CTRL_FLAG_GET_CUR,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_ANALOG_LOCK_STATUS_CONTROL,\n\t\t.index\t\t= 17,\n\t\t.size\t\t= 1,\n\t\t.flags\t\t= UVC_CTRL_FLAG_GET_CUR,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_SCANNING_MODE_CONTROL,\n\t\t.index\t\t= 0,\n\t\t.size\t\t= 1,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR | UVC_CTRL_FLAG_GET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_AE_MODE_CONTROL,\n\t\t.index\t\t= 1,\n\t\t.size\t\t= 1,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR | UVC_CTRL_FLAG_GET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_DEF | UVC_CTRL_FLAG_GET_RES\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_AE_PRIORITY_CONTROL,\n\t\t.index\t\t= 2,\n\t\t.size\t\t= 1,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR | UVC_CTRL_FLAG_GET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL,\n\t\t.index\t\t= 3,\n\t\t.size\t\t= 4,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_RANGE\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE\n\t\t\t\t| UVC_CTRL_FLAG_AUTO_UPDATE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL,\n\t\t.index\t\t= 4,\n\t\t.size\t\t= 1,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR | UVC_CTRL_FLAG_RESTORE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_FOCUS_ABSOLUTE_CONTROL,\n\t\t.index\t\t= 5,\n\t\t.size\t\t= 2,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_RANGE\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE\n\t\t\t\t| UVC_CTRL_FLAG_AUTO_UPDATE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_FOCUS_RELATIVE_CONTROL,\n\t\t.index\t\t= 6,\n\t\t.size\t\t= 2,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR | UVC_CTRL_FLAG_GET_MIN\n\t\t\t\t| UVC_CTRL_FLAG_GET_MAX | UVC_CTRL_FLAG_GET_RES\n\t\t\t\t| UVC_CTRL_FLAG_GET_DEF\n\t\t\t\t| UVC_CTRL_FLAG_AUTO_UPDATE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_IRIS_ABSOLUTE_CONTROL,\n\t\t.index\t\t= 7,\n\t\t.size\t\t= 2,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_RANGE\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE\n\t\t\t\t| UVC_CTRL_FLAG_AUTO_UPDATE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_IRIS_RELATIVE_CONTROL,\n\t\t.index\t\t= 8,\n\t\t.size\t\t= 1,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_AUTO_UPDATE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_ZOOM_ABSOLUTE_CONTROL,\n\t\t.index\t\t= 9,\n\t\t.size\t\t= 2,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_RANGE\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE\n\t\t\t\t| UVC_CTRL_FLAG_AUTO_UPDATE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_ZOOM_RELATIVE_CONTROL,\n\t\t.index\t\t= 10,\n\t\t.size\t\t= 3,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR | UVC_CTRL_FLAG_GET_MIN\n\t\t\t\t| UVC_CTRL_FLAG_GET_MAX | UVC_CTRL_FLAG_GET_RES\n\t\t\t\t| UVC_CTRL_FLAG_GET_DEF\n\t\t\t\t| UVC_CTRL_FLAG_AUTO_UPDATE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_PANTILT_ABSOLUTE_CONTROL,\n\t\t.index\t\t= 11,\n\t\t.size\t\t= 8,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_RANGE\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE\n\t\t\t\t| UVC_CTRL_FLAG_AUTO_UPDATE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_PANTILT_RELATIVE_CONTROL,\n\t\t.index\t\t= 12,\n\t\t.size\t\t= 4,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_RANGE\n\t\t\t\t| UVC_CTRL_FLAG_AUTO_UPDATE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_ROLL_ABSOLUTE_CONTROL,\n\t\t.index\t\t= 13,\n\t\t.size\t\t= 2,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_RANGE\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE\n\t\t\t\t| UVC_CTRL_FLAG_AUTO_UPDATE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_ROLL_RELATIVE_CONTROL,\n\t\t.index\t\t= 14,\n\t\t.size\t\t= 2,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR | UVC_CTRL_FLAG_GET_MIN\n\t\t\t\t| UVC_CTRL_FLAG_GET_MAX | UVC_CTRL_FLAG_GET_RES\n\t\t\t\t| UVC_CTRL_FLAG_GET_DEF\n\t\t\t\t| UVC_CTRL_FLAG_AUTO_UPDATE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_FOCUS_AUTO_CONTROL,\n\t\t.index\t\t= 17,\n\t\t.size\t\t= 1,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR | UVC_CTRL_FLAG_GET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_GET_DEF | UVC_CTRL_FLAG_RESTORE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_PRIVACY_CONTROL,\n\t\t.index\t\t= 18,\n\t\t.size\t\t= 1,\n\t\t.flags\t\t= UVC_CTRL_FLAG_SET_CUR | UVC_CTRL_FLAG_GET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_RESTORE\n\t\t\t\t| UVC_CTRL_FLAG_AUTO_UPDATE,\n\t},\n\t{\n\t\t.entity\t\t= UVC_GUID_EXT_GPIO_CONTROLLER,\n\t\t.selector\t= UVC_CT_PRIVACY_CONTROL,\n\t\t.index\t\t= 0,\n\t\t.size\t\t= 1,\n\t\t.flags\t\t= UVC_CTRL_FLAG_GET_CUR\n\t\t\t\t| UVC_CTRL_FLAG_AUTO_UPDATE,\n\t},\n};\n\nstatic const u32 uvc_control_classes[] = {\n\tV4L2_CID_CAMERA_CLASS,\n\tV4L2_CID_USER_CLASS,\n};\n\nstatic const int exposure_auto_mapping[] = { 2, 1, 4, 8 };\n\n \nstatic int uvc_mapping_get_menu_value(const struct uvc_control_mapping *mapping,\n\t\t\t\t      u32 idx)\n{\n\tif (!test_bit(idx, &mapping->menu_mask))\n\t\treturn -EINVAL;\n\n\tif (mapping->menu_mapping)\n\t\treturn mapping->menu_mapping[idx];\n\n\treturn idx;\n}\n\nstatic const char *\nuvc_mapping_get_menu_name(const struct uvc_control_mapping *mapping, u32 idx)\n{\n\tif (!test_bit(idx, &mapping->menu_mask))\n\t\treturn NULL;\n\n\tif (mapping->menu_names)\n\t\treturn mapping->menu_names[idx];\n\n\treturn v4l2_ctrl_get_menu(mapping->id)[idx];\n}\n\nstatic s32 uvc_ctrl_get_zoom(struct uvc_control_mapping *mapping,\n\tu8 query, const u8 *data)\n{\n\ts8 zoom = (s8)data[0];\n\n\tswitch (query) {\n\tcase UVC_GET_CUR:\n\t\treturn (zoom == 0) ? 0 : (zoom > 0 ? data[2] : -data[2]);\n\n\tcase UVC_GET_MIN:\n\tcase UVC_GET_MAX:\n\tcase UVC_GET_RES:\n\tcase UVC_GET_DEF:\n\tdefault:\n\t\treturn data[2];\n\t}\n}\n\nstatic void uvc_ctrl_set_zoom(struct uvc_control_mapping *mapping,\n\ts32 value, u8 *data)\n{\n\tdata[0] = value == 0 ? 0 : (value > 0) ? 1 : 0xff;\n\tdata[2] = min((int)abs(value), 0xff);\n}\n\nstatic s32 uvc_ctrl_get_rel_speed(struct uvc_control_mapping *mapping,\n\tu8 query, const u8 *data)\n{\n\tunsigned int first = mapping->offset / 8;\n\ts8 rel = (s8)data[first];\n\n\tswitch (query) {\n\tcase UVC_GET_CUR:\n\t\treturn (rel == 0) ? 0 : (rel > 0 ? data[first+1]\n\t\t\t\t\t\t : -data[first+1]);\n\tcase UVC_GET_MIN:\n\t\treturn -data[first+1];\n\tcase UVC_GET_MAX:\n\tcase UVC_GET_RES:\n\tcase UVC_GET_DEF:\n\tdefault:\n\t\treturn data[first+1];\n\t}\n}\n\nstatic void uvc_ctrl_set_rel_speed(struct uvc_control_mapping *mapping,\n\ts32 value, u8 *data)\n{\n\tunsigned int first = mapping->offset / 8;\n\n\tdata[first] = value == 0 ? 0 : (value > 0) ? 1 : 0xff;\n\tdata[first+1] = min_t(int, abs(value), 0xff);\n}\n\nstatic const struct uvc_control_mapping uvc_ctrl_mappings[] = {\n\t{\n\t\t.id\t\t= V4L2_CID_BRIGHTNESS,\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_BRIGHTNESS_CONTROL,\n\t\t.size\t\t= 16,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_SIGNED,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_CONTRAST,\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_CONTRAST_CONTROL,\n\t\t.size\t\t= 16,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_UNSIGNED,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_HUE,\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_HUE_CONTROL,\n\t\t.size\t\t= 16,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_SIGNED,\n\t\t.master_id\t= V4L2_CID_HUE_AUTO,\n\t\t.master_manual\t= 0,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_SATURATION,\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_SATURATION_CONTROL,\n\t\t.size\t\t= 16,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_UNSIGNED,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_SHARPNESS,\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_SHARPNESS_CONTROL,\n\t\t.size\t\t= 16,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_UNSIGNED,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_GAMMA,\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_GAMMA_CONTROL,\n\t\t.size\t\t= 16,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_UNSIGNED,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_BACKLIGHT_COMPENSATION,\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_BACKLIGHT_COMPENSATION_CONTROL,\n\t\t.size\t\t= 16,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_UNSIGNED,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_GAIN,\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_GAIN_CONTROL,\n\t\t.size\t\t= 16,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_UNSIGNED,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_HUE_AUTO,\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_HUE_AUTO_CONTROL,\n\t\t.size\t\t= 1,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_BOOLEAN,\n\t\t.slave_ids\t= { V4L2_CID_HUE, },\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_EXPOSURE_AUTO,\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_AE_MODE_CONTROL,\n\t\t.size\t\t= 4,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_MENU,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_BITMASK,\n\t\t.menu_mapping\t= exposure_auto_mapping,\n\t\t.menu_mask\t= GENMASK(V4L2_EXPOSURE_APERTURE_PRIORITY,\n\t\t\t\t\t  V4L2_EXPOSURE_AUTO),\n\t\t.slave_ids\t= { V4L2_CID_EXPOSURE_ABSOLUTE, },\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_EXPOSURE_AUTO_PRIORITY,\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_AE_PRIORITY_CONTROL,\n\t\t.size\t\t= 1,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_BOOLEAN,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_EXPOSURE_ABSOLUTE,\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL,\n\t\t.size\t\t= 32,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_UNSIGNED,\n\t\t.master_id\t= V4L2_CID_EXPOSURE_AUTO,\n\t\t.master_manual\t= V4L2_EXPOSURE_MANUAL,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_AUTO_WHITE_BALANCE,\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL,\n\t\t.size\t\t= 1,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_BOOLEAN,\n\t\t.slave_ids\t= { V4L2_CID_WHITE_BALANCE_TEMPERATURE, },\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_WHITE_BALANCE_TEMPERATURE,\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL,\n\t\t.size\t\t= 16,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_UNSIGNED,\n\t\t.master_id\t= V4L2_CID_AUTO_WHITE_BALANCE,\n\t\t.master_manual\t= 0,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_AUTO_WHITE_BALANCE,\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL,\n\t\t.size\t\t= 1,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_BOOLEAN,\n\t\t.slave_ids\t= { V4L2_CID_BLUE_BALANCE,\n\t\t\t\t    V4L2_CID_RED_BALANCE },\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_BLUE_BALANCE,\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL,\n\t\t.size\t\t= 16,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_SIGNED,\n\t\t.master_id\t= V4L2_CID_AUTO_WHITE_BALANCE,\n\t\t.master_manual\t= 0,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_RED_BALANCE,\n\t\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t\t.selector\t= UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL,\n\t\t.size\t\t= 16,\n\t\t.offset\t\t= 16,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_SIGNED,\n\t\t.master_id\t= V4L2_CID_AUTO_WHITE_BALANCE,\n\t\t.master_manual\t= 0,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_FOCUS_ABSOLUTE,\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_FOCUS_ABSOLUTE_CONTROL,\n\t\t.size\t\t= 16,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_UNSIGNED,\n\t\t.master_id\t= V4L2_CID_FOCUS_AUTO,\n\t\t.master_manual\t= 0,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_FOCUS_AUTO,\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_FOCUS_AUTO_CONTROL,\n\t\t.size\t\t= 1,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_BOOLEAN,\n\t\t.slave_ids\t= { V4L2_CID_FOCUS_ABSOLUTE, },\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_IRIS_ABSOLUTE,\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_IRIS_ABSOLUTE_CONTROL,\n\t\t.size\t\t= 16,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_UNSIGNED,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_IRIS_RELATIVE,\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_IRIS_RELATIVE_CONTROL,\n\t\t.size\t\t= 8,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_SIGNED,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_ZOOM_ABSOLUTE,\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_ZOOM_ABSOLUTE_CONTROL,\n\t\t.size\t\t= 16,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_UNSIGNED,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_ZOOM_CONTINUOUS,\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_ZOOM_RELATIVE_CONTROL,\n\t\t.size\t\t= 0,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_SIGNED,\n\t\t.get\t\t= uvc_ctrl_get_zoom,\n\t\t.set\t\t= uvc_ctrl_set_zoom,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_PAN_ABSOLUTE,\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_PANTILT_ABSOLUTE_CONTROL,\n\t\t.size\t\t= 32,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_SIGNED,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_TILT_ABSOLUTE,\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_PANTILT_ABSOLUTE_CONTROL,\n\t\t.size\t\t= 32,\n\t\t.offset\t\t= 32,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_SIGNED,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_PAN_SPEED,\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_PANTILT_RELATIVE_CONTROL,\n\t\t.size\t\t= 16,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_SIGNED,\n\t\t.get\t\t= uvc_ctrl_get_rel_speed,\n\t\t.set\t\t= uvc_ctrl_set_rel_speed,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_TILT_SPEED,\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_PANTILT_RELATIVE_CONTROL,\n\t\t.size\t\t= 16,\n\t\t.offset\t\t= 16,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_SIGNED,\n\t\t.get\t\t= uvc_ctrl_get_rel_speed,\n\t\t.set\t\t= uvc_ctrl_set_rel_speed,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_PRIVACY,\n\t\t.entity\t\t= UVC_GUID_UVC_CAMERA,\n\t\t.selector\t= UVC_CT_PRIVACY_CONTROL,\n\t\t.size\t\t= 1,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_BOOLEAN,\n\t},\n\t{\n\t\t.id\t\t= V4L2_CID_PRIVACY,\n\t\t.entity\t\t= UVC_GUID_EXT_GPIO_CONTROLLER,\n\t\t.selector\t= UVC_CT_PRIVACY_CONTROL,\n\t\t.size\t\t= 1,\n\t\t.offset\t\t= 0,\n\t\t.v4l2_type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.data_type\t= UVC_CTRL_DATA_TYPE_BOOLEAN,\n\t},\n};\n\nconst struct uvc_control_mapping uvc_ctrl_power_line_mapping_limited = {\n\t.id\t\t= V4L2_CID_POWER_LINE_FREQUENCY,\n\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t.selector\t= UVC_PU_POWER_LINE_FREQUENCY_CONTROL,\n\t.size\t\t= 2,\n\t.offset\t\t= 0,\n\t.v4l2_type\t= V4L2_CTRL_TYPE_MENU,\n\t.data_type\t= UVC_CTRL_DATA_TYPE_ENUM,\n\t.menu_mask\t= GENMASK(V4L2_CID_POWER_LINE_FREQUENCY_60HZ,\n\t\t\t\t  V4L2_CID_POWER_LINE_FREQUENCY_50HZ),\n};\n\nconst struct uvc_control_mapping uvc_ctrl_power_line_mapping_uvc11 = {\n\t.id\t\t= V4L2_CID_POWER_LINE_FREQUENCY,\n\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t.selector\t= UVC_PU_POWER_LINE_FREQUENCY_CONTROL,\n\t.size\t\t= 2,\n\t.offset\t\t= 0,\n\t.v4l2_type\t= V4L2_CTRL_TYPE_MENU,\n\t.data_type\t= UVC_CTRL_DATA_TYPE_ENUM,\n\t.menu_mask\t= GENMASK(V4L2_CID_POWER_LINE_FREQUENCY_60HZ,\n\t\t\t\t  V4L2_CID_POWER_LINE_FREQUENCY_DISABLED),\n};\n\nstatic const struct uvc_control_mapping *uvc_ctrl_mappings_uvc11[] = {\n\t&uvc_ctrl_power_line_mapping_uvc11,\n\tNULL,  \n};\n\nstatic const struct uvc_control_mapping uvc_ctrl_power_line_mapping_uvc15 = {\n\t.id\t\t= V4L2_CID_POWER_LINE_FREQUENCY,\n\t.entity\t\t= UVC_GUID_UVC_PROCESSING,\n\t.selector\t= UVC_PU_POWER_LINE_FREQUENCY_CONTROL,\n\t.size\t\t= 2,\n\t.offset\t\t= 0,\n\t.v4l2_type\t= V4L2_CTRL_TYPE_MENU,\n\t.data_type\t= UVC_CTRL_DATA_TYPE_ENUM,\n\t.menu_mask\t= GENMASK(V4L2_CID_POWER_LINE_FREQUENCY_AUTO,\n\t\t\t\t  V4L2_CID_POWER_LINE_FREQUENCY_DISABLED),\n};\n\nstatic const struct uvc_control_mapping *uvc_ctrl_mappings_uvc15[] = {\n\t&uvc_ctrl_power_line_mapping_uvc15,\n\tNULL,  \n};\n\n \n\nstatic inline u8 *uvc_ctrl_data(struct uvc_control *ctrl, int id)\n{\n\treturn ctrl->uvc_data + id * ctrl->info.size;\n}\n\nstatic inline int uvc_test_bit(const u8 *data, int bit)\n{\n\treturn (data[bit >> 3] >> (bit & 7)) & 1;\n}\n\nstatic inline void uvc_clear_bit(u8 *data, int bit)\n{\n\tdata[bit >> 3] &= ~(1 << (bit & 7));\n}\n\n \nstatic s32 uvc_get_le_value(struct uvc_control_mapping *mapping,\n\tu8 query, const u8 *data)\n{\n\tint bits = mapping->size;\n\tint offset = mapping->offset;\n\ts32 value = 0;\n\tu8 mask;\n\n\tdata += offset / 8;\n\toffset &= 7;\n\tmask = ((1LL << bits) - 1) << offset;\n\n\twhile (1) {\n\t\tu8 byte = *data & mask;\n\t\tvalue |= offset > 0 ? (byte >> offset) : (byte << (-offset));\n\t\tbits -= 8 - (offset > 0 ? offset : 0);\n\t\tif (bits <= 0)\n\t\t\tbreak;\n\n\t\toffset -= 8;\n\t\tmask = (1 << bits) - 1;\n\t\tdata++;\n\t}\n\n\t \n\tif (mapping->data_type == UVC_CTRL_DATA_TYPE_SIGNED)\n\t\tvalue |= -(value & (1 << (mapping->size - 1)));\n\n\treturn value;\n}\n\n \nstatic void uvc_set_le_value(struct uvc_control_mapping *mapping,\n\ts32 value, u8 *data)\n{\n\tint bits = mapping->size;\n\tint offset = mapping->offset;\n\tu8 mask;\n\n\t \n\tif (mapping->v4l2_type == V4L2_CTRL_TYPE_BUTTON)\n\t\tvalue = -1;\n\n\tdata += offset / 8;\n\toffset &= 7;\n\n\tfor (; bits > 0; data++) {\n\t\tmask = ((1LL << bits) - 1) << offset;\n\t\t*data = (*data & ~mask) | ((value << offset) & mask);\n\t\tvalue >>= offset ? offset : 8;\n\t\tbits -= 8 - offset;\n\t\toffset = 0;\n\t}\n}\n\n \n\nstatic int uvc_entity_match_guid(const struct uvc_entity *entity,\n\t\t\t\t const u8 guid[16])\n{\n\treturn memcmp(entity->guid, guid, sizeof(entity->guid)) == 0;\n}\n\n \n\nstatic void __uvc_find_control(struct uvc_entity *entity, u32 v4l2_id,\n\tstruct uvc_control_mapping **mapping, struct uvc_control **control,\n\tint next)\n{\n\tstruct uvc_control *ctrl;\n\tstruct uvc_control_mapping *map;\n\tunsigned int i;\n\n\tif (entity == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < entity->ncontrols; ++i) {\n\t\tctrl = &entity->controls[i];\n\t\tif (!ctrl->initialized)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(map, &ctrl->info.mappings, list) {\n\t\t\tif ((map->id == v4l2_id) && !next) {\n\t\t\t\t*control = ctrl;\n\t\t\t\t*mapping = map;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ((*mapping == NULL || (*mapping)->id > map->id) &&\n\t\t\t    (map->id > v4l2_id) && next) {\n\t\t\t\t*control = ctrl;\n\t\t\t\t*mapping = map;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic struct uvc_control *uvc_find_control(struct uvc_video_chain *chain,\n\tu32 v4l2_id, struct uvc_control_mapping **mapping)\n{\n\tstruct uvc_control *ctrl = NULL;\n\tstruct uvc_entity *entity;\n\tint next = v4l2_id & V4L2_CTRL_FLAG_NEXT_CTRL;\n\n\t*mapping = NULL;\n\n\t \n\tv4l2_id &= V4L2_CTRL_ID_MASK;\n\n\t \n\tlist_for_each_entry(entity, &chain->entities, chain) {\n\t\t__uvc_find_control(entity, v4l2_id, mapping, &ctrl, next);\n\t\tif (ctrl && !next)\n\t\t\treturn ctrl;\n\t}\n\n\tif (ctrl == NULL && !next)\n\t\tuvc_dbg(chain->dev, CONTROL, \"Control 0x%08x not found\\n\",\n\t\t\tv4l2_id);\n\n\treturn ctrl;\n}\n\nstatic int uvc_ctrl_populate_cache(struct uvc_video_chain *chain,\n\tstruct uvc_control *ctrl)\n{\n\tint ret;\n\n\tif (ctrl->info.flags & UVC_CTRL_FLAG_GET_DEF) {\n\t\tret = uvc_query_ctrl(chain->dev, UVC_GET_DEF, ctrl->entity->id,\n\t\t\t\t     chain->dev->intfnum, ctrl->info.selector,\n\t\t\t\t     uvc_ctrl_data(ctrl, UVC_CTRL_DATA_DEF),\n\t\t\t\t     ctrl->info.size);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (ctrl->info.flags & UVC_CTRL_FLAG_GET_MIN) {\n\t\tret = uvc_query_ctrl(chain->dev, UVC_GET_MIN, ctrl->entity->id,\n\t\t\t\t     chain->dev->intfnum, ctrl->info.selector,\n\t\t\t\t     uvc_ctrl_data(ctrl, UVC_CTRL_DATA_MIN),\n\t\t\t\t     ctrl->info.size);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tif (ctrl->info.flags & UVC_CTRL_FLAG_GET_MAX) {\n\t\tret = uvc_query_ctrl(chain->dev, UVC_GET_MAX, ctrl->entity->id,\n\t\t\t\t     chain->dev->intfnum, ctrl->info.selector,\n\t\t\t\t     uvc_ctrl_data(ctrl, UVC_CTRL_DATA_MAX),\n\t\t\t\t     ctrl->info.size);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tif (ctrl->info.flags & UVC_CTRL_FLAG_GET_RES) {\n\t\tret = uvc_query_ctrl(chain->dev, UVC_GET_RES, ctrl->entity->id,\n\t\t\t\t     chain->dev->intfnum, ctrl->info.selector,\n\t\t\t\t     uvc_ctrl_data(ctrl, UVC_CTRL_DATA_RES),\n\t\t\t\t     ctrl->info.size);\n\t\tif (ret < 0) {\n\t\t\tif (UVC_ENTITY_TYPE(ctrl->entity) !=\n\t\t\t    UVC_VC_EXTENSION_UNIT)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tuvc_warn_once(chain->dev, UVC_WARN_XU_GET_RES,\n\t\t\t\t      \"UVC non compliance - GET_RES failed on \"\n\t\t\t\t      \"an XU control. Enabling workaround.\\n\");\n\t\t\tmemset(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_RES), 0,\n\t\t\t       ctrl->info.size);\n\t\t}\n\t}\n\n\tctrl->cached = 1;\n\treturn 0;\n}\n\nstatic s32 __uvc_ctrl_get_value(struct uvc_control_mapping *mapping,\n\t\t\t\tconst u8 *data)\n{\n\ts32 value = mapping->get(mapping, UVC_GET_CUR, data);\n\n\tif (mapping->v4l2_type == V4L2_CTRL_TYPE_MENU) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; BIT(i) <= mapping->menu_mask; ++i) {\n\t\t\tu32 menu_value;\n\n\t\t\tif (!test_bit(i, &mapping->menu_mask))\n\t\t\t\tcontinue;\n\n\t\t\tmenu_value = uvc_mapping_get_menu_value(mapping, i);\n\n\t\t\tif (menu_value == value) {\n\t\t\t\tvalue = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn value;\n}\n\nstatic int __uvc_ctrl_load_cur(struct uvc_video_chain *chain,\n\t\t\t       struct uvc_control *ctrl)\n{\n\tu8 *data;\n\tint ret;\n\n\tif (ctrl->loaded)\n\t\treturn 0;\n\n\tdata = uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT);\n\n\tif ((ctrl->info.flags & UVC_CTRL_FLAG_GET_CUR) == 0) {\n\t\tmemset(data, 0, ctrl->info.size);\n\t\tctrl->loaded = 1;\n\n\t\treturn 0;\n\t}\n\n\tif (ctrl->entity->get_cur)\n\t\tret = ctrl->entity->get_cur(chain->dev, ctrl->entity,\n\t\t\t\t\t    ctrl->info.selector, data,\n\t\t\t\t\t    ctrl->info.size);\n\telse\n\t\tret = uvc_query_ctrl(chain->dev, UVC_GET_CUR,\n\t\t\t\t     ctrl->entity->id, chain->dev->intfnum,\n\t\t\t\t     ctrl->info.selector, data,\n\t\t\t\t     ctrl->info.size);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tctrl->loaded = 1;\n\n\treturn ret;\n}\n\nstatic int __uvc_ctrl_get(struct uvc_video_chain *chain,\n\t\t\t  struct uvc_control *ctrl,\n\t\t\t  struct uvc_control_mapping *mapping,\n\t\t\t  s32 *value)\n{\n\tint ret;\n\n\tif ((ctrl->info.flags & UVC_CTRL_FLAG_GET_CUR) == 0)\n\t\treturn -EACCES;\n\n\tret = __uvc_ctrl_load_cur(chain, ctrl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*value = __uvc_ctrl_get_value(mapping,\n\t\t\t\tuvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT));\n\n\treturn 0;\n}\n\nstatic int __uvc_query_v4l2_class(struct uvc_video_chain *chain, u32 req_id,\n\t\t\t\t  u32 found_id)\n{\n\tbool find_next = req_id & V4L2_CTRL_FLAG_NEXT_CTRL;\n\tunsigned int i;\n\n\treq_id &= V4L2_CTRL_ID_MASK;\n\n\tfor (i = 0; i < ARRAY_SIZE(uvc_control_classes); i++) {\n\t\tif (!(chain->ctrl_class_bitmap & BIT(i)))\n\t\t\tcontinue;\n\t\tif (!find_next) {\n\t\t\tif (uvc_control_classes[i] == req_id)\n\t\t\t\treturn i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (uvc_control_classes[i] > req_id &&\n\t\t    uvc_control_classes[i] < found_id)\n\t\t\treturn i;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int uvc_query_v4l2_class(struct uvc_video_chain *chain, u32 req_id,\n\t\t\t\tu32 found_id, struct v4l2_queryctrl *v4l2_ctrl)\n{\n\tint idx;\n\n\tidx = __uvc_query_v4l2_class(chain, req_id, found_id);\n\tif (idx < 0)\n\t\treturn -ENODEV;\n\n\tmemset(v4l2_ctrl, 0, sizeof(*v4l2_ctrl));\n\tv4l2_ctrl->id = uvc_control_classes[idx];\n\tstrscpy(v4l2_ctrl->name, v4l2_ctrl_get_name(v4l2_ctrl->id),\n\t\tsizeof(v4l2_ctrl->name));\n\tv4l2_ctrl->type = V4L2_CTRL_TYPE_CTRL_CLASS;\n\tv4l2_ctrl->flags = V4L2_CTRL_FLAG_WRITE_ONLY\n\t\t\t | V4L2_CTRL_FLAG_READ_ONLY;\n\treturn 0;\n}\n\n \nint uvc_ctrl_is_accessible(struct uvc_video_chain *chain, u32 v4l2_id,\n\t\t\t   const struct v4l2_ext_controls *ctrls,\n\t\t\t   unsigned long ioctl)\n{\n\tstruct uvc_control_mapping *master_map = NULL;\n\tstruct uvc_control *master_ctrl = NULL;\n\tstruct uvc_control_mapping *mapping;\n\tstruct uvc_control *ctrl;\n\tbool read = ioctl == VIDIOC_G_EXT_CTRLS;\n\ts32 val;\n\tint ret;\n\tint i;\n\n\tif (__uvc_query_v4l2_class(chain, v4l2_id, 0) >= 0)\n\t\treturn -EACCES;\n\n\tctrl = uvc_find_control(chain, v4l2_id, &mapping);\n\tif (!ctrl)\n\t\treturn -EINVAL;\n\n\tif (!(ctrl->info.flags & UVC_CTRL_FLAG_GET_CUR) && read)\n\t\treturn -EACCES;\n\n\tif (!(ctrl->info.flags & UVC_CTRL_FLAG_SET_CUR) && !read)\n\t\treturn -EACCES;\n\n\tif (ioctl != VIDIOC_S_EXT_CTRLS || !mapping->master_id)\n\t\treturn 0;\n\n\t \n\tfor (i = ctrls->count - 1; i >= 0; i--) {\n\t\tif (ctrls->controls[i].id == mapping->master_id)\n\t\t\treturn ctrls->controls[i].value ==\n\t\t\t\t\tmapping->master_manual ? 0 : -EACCES;\n\t}\n\n\t__uvc_find_control(ctrl->entity, mapping->master_id, &master_map,\n\t\t\t   &master_ctrl, 0);\n\n\tif (!master_ctrl || !(master_ctrl->info.flags & UVC_CTRL_FLAG_GET_CUR))\n\t\treturn 0;\n\n\tret = __uvc_ctrl_get(chain, master_ctrl, master_map, &val);\n\tif (ret >= 0 && val != mapping->master_manual)\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\nstatic const char *uvc_map_get_name(const struct uvc_control_mapping *map)\n{\n\tconst char *name;\n\n\tif (map->name)\n\t\treturn map->name;\n\n\tname = v4l2_ctrl_get_name(map->id);\n\tif (name)\n\t\treturn name;\n\n\treturn \"Unknown Control\";\n}\n\nstatic u32 uvc_get_ctrl_bitmap(struct uvc_control *ctrl,\n\t\t\t       struct uvc_control_mapping *mapping)\n{\n\t \n\tif (ctrl->info.flags & UVC_CTRL_FLAG_GET_RES)\n\t\treturn mapping->get(mapping, UVC_GET_RES,\n\t\t\t\t    uvc_ctrl_data(ctrl, UVC_CTRL_DATA_RES));\n\n\tif (ctrl->info.flags & UVC_CTRL_FLAG_GET_MAX)\n\t\treturn mapping->get(mapping, UVC_GET_MAX,\n\t\t\t\t    uvc_ctrl_data(ctrl, UVC_CTRL_DATA_MAX));\n\n\treturn ~0;\n}\n\nstatic int __uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,\n\tstruct uvc_control *ctrl,\n\tstruct uvc_control_mapping *mapping,\n\tstruct v4l2_queryctrl *v4l2_ctrl)\n{\n\tstruct uvc_control_mapping *master_map = NULL;\n\tstruct uvc_control *master_ctrl = NULL;\n\tunsigned int i;\n\n\tmemset(v4l2_ctrl, 0, sizeof(*v4l2_ctrl));\n\tv4l2_ctrl->id = mapping->id;\n\tv4l2_ctrl->type = mapping->v4l2_type;\n\tstrscpy(v4l2_ctrl->name, uvc_map_get_name(mapping),\n\t\tsizeof(v4l2_ctrl->name));\n\tv4l2_ctrl->flags = 0;\n\n\tif (!(ctrl->info.flags & UVC_CTRL_FLAG_GET_CUR))\n\t\tv4l2_ctrl->flags |= V4L2_CTRL_FLAG_WRITE_ONLY;\n\tif (!(ctrl->info.flags & UVC_CTRL_FLAG_SET_CUR))\n\t\tv4l2_ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tif (mapping->master_id)\n\t\t__uvc_find_control(ctrl->entity, mapping->master_id,\n\t\t\t\t   &master_map, &master_ctrl, 0);\n\tif (master_ctrl && (master_ctrl->info.flags & UVC_CTRL_FLAG_GET_CUR)) {\n\t\ts32 val;\n\t\tint ret = __uvc_ctrl_get(chain, master_ctrl, master_map, &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (val != mapping->master_manual)\n\t\t\t\tv4l2_ctrl->flags |= V4L2_CTRL_FLAG_INACTIVE;\n\t}\n\n\tif (!ctrl->cached) {\n\t\tint ret = uvc_ctrl_populate_cache(chain, ctrl);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (ctrl->info.flags & UVC_CTRL_FLAG_GET_DEF) {\n\t\tv4l2_ctrl->default_value = mapping->get(mapping, UVC_GET_DEF,\n\t\t\t\tuvc_ctrl_data(ctrl, UVC_CTRL_DATA_DEF));\n\t}\n\n\tswitch (mapping->v4l2_type) {\n\tcase V4L2_CTRL_TYPE_MENU:\n\t\tv4l2_ctrl->minimum = ffs(mapping->menu_mask) - 1;\n\t\tv4l2_ctrl->maximum = fls(mapping->menu_mask) - 1;\n\t\tv4l2_ctrl->step = 1;\n\n\t\tfor (i = 0; BIT(i) <= mapping->menu_mask; ++i) {\n\t\t\tu32 menu_value;\n\n\t\t\tif (!test_bit(i, &mapping->menu_mask))\n\t\t\t\tcontinue;\n\n\t\t\tmenu_value = uvc_mapping_get_menu_value(mapping, i);\n\n\t\t\tif (menu_value == v4l2_ctrl->default_value) {\n\t\t\t\tv4l2_ctrl->default_value = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\n\tcase V4L2_CTRL_TYPE_BOOLEAN:\n\t\tv4l2_ctrl->minimum = 0;\n\t\tv4l2_ctrl->maximum = 1;\n\t\tv4l2_ctrl->step = 1;\n\t\treturn 0;\n\n\tcase V4L2_CTRL_TYPE_BUTTON:\n\t\tv4l2_ctrl->minimum = 0;\n\t\tv4l2_ctrl->maximum = 0;\n\t\tv4l2_ctrl->step = 0;\n\t\treturn 0;\n\n\tcase V4L2_CTRL_TYPE_BITMASK:\n\t\tv4l2_ctrl->minimum = 0;\n\t\tv4l2_ctrl->maximum = uvc_get_ctrl_bitmap(ctrl, mapping);\n\t\tv4l2_ctrl->step = 0;\n\t\treturn 0;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ctrl->info.flags & UVC_CTRL_FLAG_GET_MIN)\n\t\tv4l2_ctrl->minimum = mapping->get(mapping, UVC_GET_MIN,\n\t\t\t\t     uvc_ctrl_data(ctrl, UVC_CTRL_DATA_MIN));\n\n\tif (ctrl->info.flags & UVC_CTRL_FLAG_GET_MAX)\n\t\tv4l2_ctrl->maximum = mapping->get(mapping, UVC_GET_MAX,\n\t\t\t\t     uvc_ctrl_data(ctrl, UVC_CTRL_DATA_MAX));\n\n\tif (ctrl->info.flags & UVC_CTRL_FLAG_GET_RES)\n\t\tv4l2_ctrl->step = mapping->get(mapping, UVC_GET_RES,\n\t\t\t\t  uvc_ctrl_data(ctrl, UVC_CTRL_DATA_RES));\n\n\treturn 0;\n}\n\nint uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,\n\tstruct v4l2_queryctrl *v4l2_ctrl)\n{\n\tstruct uvc_control *ctrl;\n\tstruct uvc_control_mapping *mapping;\n\tint ret;\n\n\tret = mutex_lock_interruptible(&chain->ctrl_mutex);\n\tif (ret < 0)\n\t\treturn -ERESTARTSYS;\n\n\t \n\tif (!(v4l2_ctrl->id & V4L2_CTRL_FLAG_NEXT_CTRL)) {\n\t\tret = uvc_query_v4l2_class(chain, v4l2_ctrl->id, 0, v4l2_ctrl);\n\t\tif (!ret)\n\t\t\tgoto done;\n\t}\n\n\tctrl = uvc_find_control(chain, v4l2_ctrl->id, &mapping);\n\tif (ctrl == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t \n\tif (v4l2_ctrl->id & V4L2_CTRL_FLAG_NEXT_CTRL) {\n\t\tret = uvc_query_v4l2_class(chain, v4l2_ctrl->id, mapping->id,\n\t\t\t\t\t   v4l2_ctrl);\n\t\tif (!ret)\n\t\t\tgoto done;\n\t}\n\n\tret = __uvc_query_v4l2_ctrl(chain, ctrl, mapping, v4l2_ctrl);\ndone:\n\tmutex_unlock(&chain->ctrl_mutex);\n\treturn ret;\n}\n\n \nint uvc_query_v4l2_menu(struct uvc_video_chain *chain,\n\tstruct v4l2_querymenu *query_menu)\n{\n\tstruct uvc_control_mapping *mapping;\n\tstruct uvc_control *ctrl;\n\tu32 index = query_menu->index;\n\tu32 id = query_menu->id;\n\tconst char *name;\n\tint ret;\n\n\tmemset(query_menu, 0, sizeof(*query_menu));\n\tquery_menu->id = id;\n\tquery_menu->index = index;\n\n\tif (index >= BITS_PER_TYPE(mapping->menu_mask))\n\t\treturn -EINVAL;\n\n\tret = mutex_lock_interruptible(&chain->ctrl_mutex);\n\tif (ret < 0)\n\t\treturn -ERESTARTSYS;\n\n\tctrl = uvc_find_control(chain, query_menu->id, &mapping);\n\tif (ctrl == NULL || mapping->v4l2_type != V4L2_CTRL_TYPE_MENU) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (!test_bit(query_menu->index, &mapping->menu_mask)) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (mapping->data_type == UVC_CTRL_DATA_TYPE_BITMASK) {\n\t\tint mask;\n\n\t\tif (!ctrl->cached) {\n\t\t\tret = uvc_ctrl_populate_cache(chain, ctrl);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tmask = uvc_mapping_get_menu_value(mapping, query_menu->index);\n\t\tif (mask < 0) {\n\t\t\tret = mask;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!(uvc_get_ctrl_bitmap(ctrl, mapping) & mask)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tname = uvc_mapping_get_menu_name(mapping, query_menu->index);\n\tif (!name) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tstrscpy(query_menu->name, name, sizeof(query_menu->name));\n\ndone:\n\tmutex_unlock(&chain->ctrl_mutex);\n\treturn ret;\n}\n\n \n\nstatic void uvc_ctrl_fill_event(struct uvc_video_chain *chain,\n\tstruct v4l2_event *ev,\n\tstruct uvc_control *ctrl,\n\tstruct uvc_control_mapping *mapping,\n\ts32 value, u32 changes)\n{\n\tstruct v4l2_queryctrl v4l2_ctrl;\n\n\t__uvc_query_v4l2_ctrl(chain, ctrl, mapping, &v4l2_ctrl);\n\n\tmemset(ev, 0, sizeof(*ev));\n\tev->type = V4L2_EVENT_CTRL;\n\tev->id = v4l2_ctrl.id;\n\tev->u.ctrl.value = value;\n\tev->u.ctrl.changes = changes;\n\tev->u.ctrl.type = v4l2_ctrl.type;\n\tev->u.ctrl.flags = v4l2_ctrl.flags;\n\tev->u.ctrl.minimum = v4l2_ctrl.minimum;\n\tev->u.ctrl.maximum = v4l2_ctrl.maximum;\n\tev->u.ctrl.step = v4l2_ctrl.step;\n\tev->u.ctrl.default_value = v4l2_ctrl.default_value;\n}\n\n \nstatic void uvc_ctrl_send_event(struct uvc_video_chain *chain,\n\tstruct uvc_fh *handle, struct uvc_control *ctrl,\n\tstruct uvc_control_mapping *mapping, s32 value, u32 changes)\n{\n\tstruct v4l2_fh *originator = handle ? &handle->vfh : NULL;\n\tstruct v4l2_subscribed_event *sev;\n\tstruct v4l2_event ev;\n\n\tif (list_empty(&mapping->ev_subs))\n\t\treturn;\n\n\tuvc_ctrl_fill_event(chain, &ev, ctrl, mapping, value, changes);\n\n\tlist_for_each_entry(sev, &mapping->ev_subs, node) {\n\t\tif (sev->fh != originator ||\n\t\t    (sev->flags & V4L2_EVENT_SUB_FL_ALLOW_FEEDBACK) ||\n\t\t    (changes & V4L2_EVENT_CTRL_CH_FLAGS))\n\t\t\tv4l2_event_queue_fh(sev->fh, &ev);\n\t}\n}\n\n \nstatic void uvc_ctrl_send_slave_event(struct uvc_video_chain *chain,\n\tstruct uvc_fh *handle, struct uvc_control *master, u32 slave_id)\n{\n\tstruct uvc_control_mapping *mapping = NULL;\n\tstruct uvc_control *ctrl = NULL;\n\tu32 changes = V4L2_EVENT_CTRL_CH_FLAGS;\n\ts32 val = 0;\n\n\t__uvc_find_control(master->entity, slave_id, &mapping, &ctrl, 0);\n\tif (ctrl == NULL)\n\t\treturn;\n\n\tif (__uvc_ctrl_get(chain, ctrl, mapping, &val) == 0)\n\t\tchanges |= V4L2_EVENT_CTRL_CH_VALUE;\n\n\tuvc_ctrl_send_event(chain, handle, ctrl, mapping, val, changes);\n}\n\nvoid uvc_ctrl_status_event(struct uvc_video_chain *chain,\n\t\t\t   struct uvc_control *ctrl, const u8 *data)\n{\n\tstruct uvc_control_mapping *mapping;\n\tstruct uvc_fh *handle;\n\tunsigned int i;\n\n\tmutex_lock(&chain->ctrl_mutex);\n\n\thandle = ctrl->handle;\n\tctrl->handle = NULL;\n\n\tlist_for_each_entry(mapping, &ctrl->info.mappings, list) {\n\t\ts32 value = __uvc_ctrl_get_value(mapping, data);\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(mapping->slave_ids); ++i) {\n\t\t\tif (!mapping->slave_ids[i])\n\t\t\t\tbreak;\n\n\t\t\tuvc_ctrl_send_slave_event(chain, handle, ctrl,\n\t\t\t\t\t\t  mapping->slave_ids[i]);\n\t\t}\n\n\t\tuvc_ctrl_send_event(chain, handle, ctrl, mapping, value,\n\t\t\t\t    V4L2_EVENT_CTRL_CH_VALUE);\n\t}\n\n\tmutex_unlock(&chain->ctrl_mutex);\n}\n\nstatic void uvc_ctrl_status_event_work(struct work_struct *work)\n{\n\tstruct uvc_device *dev = container_of(work, struct uvc_device,\n\t\t\t\t\t      async_ctrl.work);\n\tstruct uvc_ctrl_work *w = &dev->async_ctrl;\n\tint ret;\n\n\tuvc_ctrl_status_event(w->chain, w->ctrl, w->data);\n\n\t \n\tif (smp_load_acquire(&dev->flush_status))\n\t\treturn;\n\n\t \n\tw->urb->interval = dev->int_ep->desc.bInterval;\n\tret = usb_submit_urb(w->urb, GFP_KERNEL);\n\tif (ret < 0)\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"Failed to resubmit status URB (%d).\\n\", ret);\n}\n\nbool uvc_ctrl_status_event_async(struct urb *urb, struct uvc_video_chain *chain,\n\t\t\t\t struct uvc_control *ctrl, const u8 *data)\n{\n\tstruct uvc_device *dev = chain->dev;\n\tstruct uvc_ctrl_work *w = &dev->async_ctrl;\n\n\tif (list_empty(&ctrl->info.mappings)) {\n\t\tctrl->handle = NULL;\n\t\treturn false;\n\t}\n\n\tw->data = data;\n\tw->urb = urb;\n\tw->chain = chain;\n\tw->ctrl = ctrl;\n\n\tschedule_work(&w->work);\n\n\treturn true;\n}\n\nstatic bool uvc_ctrl_xctrls_has_control(const struct v4l2_ext_control *xctrls,\n\t\t\t\t\tunsigned int xctrls_count, u32 id)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < xctrls_count; ++i) {\n\t\tif (xctrls[i].id == id)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void uvc_ctrl_send_events(struct uvc_fh *handle,\n\tconst struct v4l2_ext_control *xctrls, unsigned int xctrls_count)\n{\n\tstruct uvc_control_mapping *mapping;\n\tstruct uvc_control *ctrl;\n\tu32 changes = V4L2_EVENT_CTRL_CH_VALUE;\n\tunsigned int i;\n\tunsigned int j;\n\n\tfor (i = 0; i < xctrls_count; ++i) {\n\t\tctrl = uvc_find_control(handle->chain, xctrls[i].id, &mapping);\n\n\t\tif (ctrl->info.flags & UVC_CTRL_FLAG_ASYNCHRONOUS)\n\t\t\t \n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(mapping->slave_ids); ++j) {\n\t\t\tu32 slave_id = mapping->slave_ids[j];\n\n\t\t\tif (!slave_id)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (uvc_ctrl_xctrls_has_control(xctrls, xctrls_count,\n\t\t\t\t\t\t\tslave_id))\n\t\t\t\tcontinue;\n\n\t\t\tuvc_ctrl_send_slave_event(handle->chain, handle, ctrl,\n\t\t\t\t\t\t  slave_id);\n\t\t}\n\n\t\t \n\t\tif (mapping->master_id &&\n\t\t    uvc_ctrl_xctrls_has_control(xctrls, xctrls_count,\n\t\t\t\t\t\tmapping->master_id))\n\t\t\tchanges |= V4L2_EVENT_CTRL_CH_FLAGS;\n\n\t\tuvc_ctrl_send_event(handle->chain, handle, ctrl, mapping,\n\t\t\t\t    xctrls[i].value, changes);\n\t}\n}\n\nstatic int uvc_ctrl_add_event(struct v4l2_subscribed_event *sev, unsigned elems)\n{\n\tstruct uvc_fh *handle = container_of(sev->fh, struct uvc_fh, vfh);\n\tstruct uvc_control_mapping *mapping;\n\tstruct uvc_control *ctrl;\n\tint ret;\n\n\tret = mutex_lock_interruptible(&handle->chain->ctrl_mutex);\n\tif (ret < 0)\n\t\treturn -ERESTARTSYS;\n\n\tif (__uvc_query_v4l2_class(handle->chain, sev->id, 0) >= 0) {\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\tctrl = uvc_find_control(handle->chain, sev->id, &mapping);\n\tif (ctrl == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tlist_add_tail(&sev->node, &mapping->ev_subs);\n\tif (sev->flags & V4L2_EVENT_SUB_FL_SEND_INITIAL) {\n\t\tstruct v4l2_event ev;\n\t\tu32 changes = V4L2_EVENT_CTRL_CH_FLAGS;\n\t\ts32 val = 0;\n\n\t\tif (__uvc_ctrl_get(handle->chain, ctrl, mapping, &val) == 0)\n\t\t\tchanges |= V4L2_EVENT_CTRL_CH_VALUE;\n\n\t\tuvc_ctrl_fill_event(handle->chain, &ev, ctrl, mapping, val,\n\t\t\t\t    changes);\n\t\t \n\t\tsev->elems = elems;\n\t\tv4l2_event_queue_fh(sev->fh, &ev);\n\t}\n\ndone:\n\tmutex_unlock(&handle->chain->ctrl_mutex);\n\treturn ret;\n}\n\nstatic void uvc_ctrl_del_event(struct v4l2_subscribed_event *sev)\n{\n\tstruct uvc_fh *handle = container_of(sev->fh, struct uvc_fh, vfh);\n\n\tmutex_lock(&handle->chain->ctrl_mutex);\n\tif (__uvc_query_v4l2_class(handle->chain, sev->id, 0) >= 0)\n\t\tgoto done;\n\tlist_del(&sev->node);\ndone:\n\tmutex_unlock(&handle->chain->ctrl_mutex);\n}\n\nconst struct v4l2_subscribed_event_ops uvc_ctrl_sub_ev_ops = {\n\t.add = uvc_ctrl_add_event,\n\t.del = uvc_ctrl_del_event,\n\t.replace = v4l2_ctrl_replace,\n\t.merge = v4l2_ctrl_merge,\n};\n\n \nint uvc_ctrl_begin(struct uvc_video_chain *chain)\n{\n\treturn mutex_lock_interruptible(&chain->ctrl_mutex) ? -ERESTARTSYS : 0;\n}\n\nstatic int uvc_ctrl_commit_entity(struct uvc_device *dev,\n\tstruct uvc_entity *entity, int rollback, struct uvc_control **err_ctrl)\n{\n\tstruct uvc_control *ctrl;\n\tunsigned int i;\n\tint ret;\n\n\tif (entity == NULL)\n\t\treturn 0;\n\n\tfor (i = 0; i < entity->ncontrols; ++i) {\n\t\tctrl = &entity->controls[i];\n\t\tif (!ctrl->initialized)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ctrl->info.flags & UVC_CTRL_FLAG_AUTO_UPDATE ||\n\t\t    !(ctrl->info.flags & UVC_CTRL_FLAG_GET_CUR))\n\t\t\tctrl->loaded = 0;\n\n\t\tif (!ctrl->dirty)\n\t\t\tcontinue;\n\n\t\tif (!rollback)\n\t\t\tret = uvc_query_ctrl(dev, UVC_SET_CUR, ctrl->entity->id,\n\t\t\t\tdev->intfnum, ctrl->info.selector,\n\t\t\t\tuvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),\n\t\t\t\tctrl->info.size);\n\t\telse\n\t\t\tret = 0;\n\n\t\tif (rollback || ret < 0)\n\t\t\tmemcpy(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),\n\t\t\t       uvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP),\n\t\t\t       ctrl->info.size);\n\n\t\tctrl->dirty = 0;\n\n\t\tif (ret < 0) {\n\t\t\tif (err_ctrl)\n\t\t\t\t*err_ctrl = ctrl;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int uvc_ctrl_find_ctrl_idx(struct uvc_entity *entity,\n\t\t\t\t  struct v4l2_ext_controls *ctrls,\n\t\t\t\t  struct uvc_control *uvc_control)\n{\n\tstruct uvc_control_mapping *mapping = NULL;\n\tstruct uvc_control *ctrl_found = NULL;\n\tunsigned int i;\n\n\tif (!entity)\n\t\treturn ctrls->count;\n\n\tfor (i = 0; i < ctrls->count; i++) {\n\t\t__uvc_find_control(entity, ctrls->controls[i].id, &mapping,\n\t\t\t\t   &ctrl_found, 0);\n\t\tif (uvc_control == ctrl_found)\n\t\t\treturn i;\n\t}\n\n\treturn ctrls->count;\n}\n\nint __uvc_ctrl_commit(struct uvc_fh *handle, int rollback,\n\t\t      struct v4l2_ext_controls *ctrls)\n{\n\tstruct uvc_video_chain *chain = handle->chain;\n\tstruct uvc_control *err_ctrl;\n\tstruct uvc_entity *entity;\n\tint ret = 0;\n\n\t \n\tlist_for_each_entry(entity, &chain->entities, chain) {\n\t\tret = uvc_ctrl_commit_entity(chain->dev, entity, rollback,\n\t\t\t\t\t     &err_ctrl);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (!rollback)\n\t\tuvc_ctrl_send_events(handle, ctrls->controls, ctrls->count);\ndone:\n\tif (ret < 0 && ctrls)\n\t\tctrls->error_idx = uvc_ctrl_find_ctrl_idx(entity, ctrls,\n\t\t\t\t\t\t\t  err_ctrl);\n\tmutex_unlock(&chain->ctrl_mutex);\n\treturn ret;\n}\n\nint uvc_ctrl_get(struct uvc_video_chain *chain,\n\tstruct v4l2_ext_control *xctrl)\n{\n\tstruct uvc_control *ctrl;\n\tstruct uvc_control_mapping *mapping;\n\n\tif (__uvc_query_v4l2_class(chain, xctrl->id, 0) >= 0)\n\t\treturn -EACCES;\n\n\tctrl = uvc_find_control(chain, xctrl->id, &mapping);\n\tif (ctrl == NULL)\n\t\treturn -EINVAL;\n\n\treturn __uvc_ctrl_get(chain, ctrl, mapping, &xctrl->value);\n}\n\nint uvc_ctrl_set(struct uvc_fh *handle,\n\tstruct v4l2_ext_control *xctrl)\n{\n\tstruct uvc_video_chain *chain = handle->chain;\n\tstruct uvc_control *ctrl;\n\tstruct uvc_control_mapping *mapping;\n\ts32 value;\n\tu32 step;\n\ts32 min;\n\ts32 max;\n\tint ret;\n\n\tif (__uvc_query_v4l2_class(chain, xctrl->id, 0) >= 0)\n\t\treturn -EACCES;\n\n\tctrl = uvc_find_control(chain, xctrl->id, &mapping);\n\tif (ctrl == NULL)\n\t\treturn -EINVAL;\n\tif (!(ctrl->info.flags & UVC_CTRL_FLAG_SET_CUR))\n\t\treturn -EACCES;\n\n\t \n\tswitch (mapping->v4l2_type) {\n\tcase V4L2_CTRL_TYPE_INTEGER:\n\t\tif (!ctrl->cached) {\n\t\t\tret = uvc_ctrl_populate_cache(chain, ctrl);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tmin = mapping->get(mapping, UVC_GET_MIN,\n\t\t\t\t   uvc_ctrl_data(ctrl, UVC_CTRL_DATA_MIN));\n\t\tmax = mapping->get(mapping, UVC_GET_MAX,\n\t\t\t\t   uvc_ctrl_data(ctrl, UVC_CTRL_DATA_MAX));\n\t\tstep = mapping->get(mapping, UVC_GET_RES,\n\t\t\t\t    uvc_ctrl_data(ctrl, UVC_CTRL_DATA_RES));\n\t\tif (step == 0)\n\t\t\tstep = 1;\n\n\t\txctrl->value = min + DIV_ROUND_CLOSEST((u32)(xctrl->value - min),\n\t\t\t\t\t\t\tstep) * step;\n\t\tif (mapping->data_type == UVC_CTRL_DATA_TYPE_SIGNED)\n\t\t\txctrl->value = clamp(xctrl->value, min, max);\n\t\telse\n\t\t\txctrl->value = clamp_t(u32, xctrl->value, min, max);\n\t\tvalue = xctrl->value;\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_BITMASK:\n\t\tif (!ctrl->cached) {\n\t\t\tret = uvc_ctrl_populate_cache(chain, ctrl);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\txctrl->value &= uvc_get_ctrl_bitmap(ctrl, mapping);\n\t\tvalue = xctrl->value;\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_BOOLEAN:\n\t\txctrl->value = clamp(xctrl->value, 0, 1);\n\t\tvalue = xctrl->value;\n\t\tbreak;\n\n\tcase V4L2_CTRL_TYPE_MENU:\n\t\tif (xctrl->value < (ffs(mapping->menu_mask) - 1) ||\n\t\t    xctrl->value > (fls(mapping->menu_mask) - 1))\n\t\t\treturn -ERANGE;\n\n\t\tif (!test_bit(xctrl->value, &mapping->menu_mask))\n\t\t\treturn -EINVAL;\n\n\t\tvalue = uvc_mapping_get_menu_value(mapping, xctrl->value);\n\n\t\t \n\t\tif (mapping->data_type == UVC_CTRL_DATA_TYPE_BITMASK) {\n\t\t\tif (!ctrl->cached) {\n\t\t\t\tret = uvc_ctrl_populate_cache(chain, ctrl);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tif (!(uvc_get_ctrl_bitmap(ctrl, mapping) & value))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\tvalue = xctrl->value;\n\t\tbreak;\n\t}\n\n\t \n\tif ((ctrl->info.size * 8) != mapping->size) {\n\t\tret = __uvc_ctrl_load_cur(chain, ctrl);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (!ctrl->dirty) {\n\t\tmemcpy(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP),\n\t\t       uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),\n\t\t       ctrl->info.size);\n\t}\n\n\tmapping->set(mapping, value,\n\t\tuvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT));\n\n\tif (ctrl->info.flags & UVC_CTRL_FLAG_ASYNCHRONOUS)\n\t\tctrl->handle = handle;\n\n\tctrl->dirty = 1;\n\tctrl->modified = 1;\n\treturn 0;\n}\n\n \n\n \nstatic int uvc_ctrl_get_flags(struct uvc_device *dev,\n\t\t\t      const struct uvc_control *ctrl,\n\t\t\t      struct uvc_control_info *info)\n{\n\tu8 *data;\n\tint ret;\n\n\tdata = kmalloc(1, GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\tif (ctrl->entity->get_info)\n\t\tret = ctrl->entity->get_info(dev, ctrl->entity,\n\t\t\t\t\t     ctrl->info.selector, data);\n\telse\n\t\tret = uvc_query_ctrl(dev, UVC_GET_INFO, ctrl->entity->id,\n\t\t\t\t     dev->intfnum, info->selector, data, 1);\n\tif (!ret)\n\t\tinfo->flags |= (data[0] & UVC_CONTROL_CAP_GET ?\n\t\t\t\tUVC_CTRL_FLAG_GET_CUR : 0)\n\t\t\t    |  (data[0] & UVC_CONTROL_CAP_SET ?\n\t\t\t\tUVC_CTRL_FLAG_SET_CUR : 0)\n\t\t\t    |  (data[0] & UVC_CONTROL_CAP_AUTOUPDATE ?\n\t\t\t\tUVC_CTRL_FLAG_AUTO_UPDATE : 0)\n\t\t\t    |  (data[0] & UVC_CONTROL_CAP_ASYNCHRONOUS ?\n\t\t\t\tUVC_CTRL_FLAG_ASYNCHRONOUS : 0);\n\n\tkfree(data);\n\treturn ret;\n}\n\nstatic void uvc_ctrl_fixup_xu_info(struct uvc_device *dev,\n\tconst struct uvc_control *ctrl, struct uvc_control_info *info)\n{\n\tstruct uvc_ctrl_fixup {\n\t\tstruct usb_device_id id;\n\t\tu8 entity;\n\t\tu8 selector;\n\t\tu8 flags;\n\t};\n\n\tstatic const struct uvc_ctrl_fixup fixups[] = {\n\t\t{ { USB_DEVICE(0x046d, 0x08c2) }, 9, 1,\n\t\t\tUVC_CTRL_FLAG_GET_MIN | UVC_CTRL_FLAG_GET_MAX |\n\t\t\tUVC_CTRL_FLAG_GET_DEF | UVC_CTRL_FLAG_SET_CUR |\n\t\t\tUVC_CTRL_FLAG_AUTO_UPDATE },\n\t\t{ { USB_DEVICE(0x046d, 0x08cc) }, 9, 1,\n\t\t\tUVC_CTRL_FLAG_GET_MIN | UVC_CTRL_FLAG_GET_MAX |\n\t\t\tUVC_CTRL_FLAG_GET_DEF | UVC_CTRL_FLAG_SET_CUR |\n\t\t\tUVC_CTRL_FLAG_AUTO_UPDATE },\n\t\t{ { USB_DEVICE(0x046d, 0x0994) }, 9, 1,\n\t\t\tUVC_CTRL_FLAG_GET_MIN | UVC_CTRL_FLAG_GET_MAX |\n\t\t\tUVC_CTRL_FLAG_GET_DEF | UVC_CTRL_FLAG_SET_CUR |\n\t\t\tUVC_CTRL_FLAG_AUTO_UPDATE },\n\t};\n\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fixups); ++i) {\n\t\tif (!usb_match_one_id(dev->intf, &fixups[i].id))\n\t\t\tcontinue;\n\n\t\tif (fixups[i].entity == ctrl->entity->id &&\n\t\t    fixups[i].selector == info->selector) {\n\t\t\tinfo->flags = fixups[i].flags;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nstatic int uvc_ctrl_fill_xu_info(struct uvc_device *dev,\n\tconst struct uvc_control *ctrl, struct uvc_control_info *info)\n{\n\tu8 *data;\n\tint ret;\n\n\tdata = kmalloc(2, GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\tmemcpy(info->entity, ctrl->entity->guid, sizeof(info->entity));\n\tinfo->index = ctrl->index;\n\tinfo->selector = ctrl->index + 1;\n\n\t \n\tret = uvc_query_ctrl(dev, UVC_GET_LEN, ctrl->entity->id, dev->intfnum,\n\t\t\t     info->selector, data, 2);\n\tif (ret < 0) {\n\t\tuvc_dbg(dev, CONTROL,\n\t\t\t\"GET_LEN failed on control %pUl/%u (%d)\\n\",\n\t\t\tinfo->entity, info->selector, ret);\n\t\tgoto done;\n\t}\n\n\tinfo->size = le16_to_cpup((__le16 *)data);\n\n\tinfo->flags = UVC_CTRL_FLAG_GET_MIN | UVC_CTRL_FLAG_GET_MAX\n\t\t    | UVC_CTRL_FLAG_GET_RES | UVC_CTRL_FLAG_GET_DEF;\n\n\tret = uvc_ctrl_get_flags(dev, ctrl, info);\n\tif (ret < 0) {\n\t\tuvc_dbg(dev, CONTROL,\n\t\t\t\"Failed to get flags for control %pUl/%u (%d)\\n\",\n\t\t\tinfo->entity, info->selector, ret);\n\t\tgoto done;\n\t}\n\n\tuvc_ctrl_fixup_xu_info(dev, ctrl, info);\n\n\tuvc_dbg(dev, CONTROL,\n\t\t\"XU control %pUl/%u queried: len %u, flags { get %u set %u auto %u }\\n\",\n\t\tinfo->entity, info->selector, info->size,\n\t\t(info->flags & UVC_CTRL_FLAG_GET_CUR) ? 1 : 0,\n\t\t(info->flags & UVC_CTRL_FLAG_SET_CUR) ? 1 : 0,\n\t\t(info->flags & UVC_CTRL_FLAG_AUTO_UPDATE) ? 1 : 0);\n\ndone:\n\tkfree(data);\n\treturn ret;\n}\n\nstatic int uvc_ctrl_add_info(struct uvc_device *dev, struct uvc_control *ctrl,\n\tconst struct uvc_control_info *info);\n\nstatic int uvc_ctrl_init_xu_ctrl(struct uvc_device *dev,\n\tstruct uvc_control *ctrl)\n{\n\tstruct uvc_control_info info;\n\tint ret;\n\n\tif (ctrl->initialized)\n\t\treturn 0;\n\n\tret = uvc_ctrl_fill_xu_info(dev, ctrl, &info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = uvc_ctrl_add_info(dev, ctrl, &info);\n\tif (ret < 0)\n\t\tuvc_dbg(dev, CONTROL,\n\t\t\t\"Failed to initialize control %pUl/%u on device %s entity %u\\n\",\n\t\t\tinfo.entity, info.selector, dev->udev->devpath,\n\t\t\tctrl->entity->id);\n\n\treturn ret;\n}\n\nint uvc_xu_ctrl_query(struct uvc_video_chain *chain,\n\tstruct uvc_xu_control_query *xqry)\n{\n\tstruct uvc_entity *entity;\n\tstruct uvc_control *ctrl;\n\tunsigned int i;\n\tbool found;\n\tu32 reqflags;\n\tu16 size;\n\tu8 *data = NULL;\n\tint ret;\n\n\t \n\tfound = false;\n\tlist_for_each_entry(entity, &chain->entities, chain) {\n\t\tif (UVC_ENTITY_TYPE(entity) == UVC_VC_EXTENSION_UNIT &&\n\t\t    entity->id == xqry->unit) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tuvc_dbg(chain->dev, CONTROL, \"Extension unit %u not found\\n\",\n\t\t\txqry->unit);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tfound = false;\n\tfor (i = 0; i < entity->ncontrols; ++i) {\n\t\tctrl = &entity->controls[i];\n\t\tif (ctrl->index == xqry->selector - 1) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tuvc_dbg(chain->dev, CONTROL, \"Control %pUl/%u not found\\n\",\n\t\t\tentity->guid, xqry->selector);\n\t\treturn -ENOENT;\n\t}\n\n\tif (mutex_lock_interruptible(&chain->ctrl_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tret = uvc_ctrl_init_xu_ctrl(chain->dev, ctrl);\n\tif (ret < 0) {\n\t\tret = -ENOENT;\n\t\tgoto done;\n\t}\n\n\t \n\treqflags = 0;\n\tsize = ctrl->info.size;\n\n\tswitch (xqry->query) {\n\tcase UVC_GET_CUR:\n\t\treqflags = UVC_CTRL_FLAG_GET_CUR;\n\t\tbreak;\n\tcase UVC_GET_MIN:\n\t\treqflags = UVC_CTRL_FLAG_GET_MIN;\n\t\tbreak;\n\tcase UVC_GET_MAX:\n\t\treqflags = UVC_CTRL_FLAG_GET_MAX;\n\t\tbreak;\n\tcase UVC_GET_DEF:\n\t\treqflags = UVC_CTRL_FLAG_GET_DEF;\n\t\tbreak;\n\tcase UVC_GET_RES:\n\t\treqflags = UVC_CTRL_FLAG_GET_RES;\n\t\tbreak;\n\tcase UVC_SET_CUR:\n\t\treqflags = UVC_CTRL_FLAG_SET_CUR;\n\t\tbreak;\n\tcase UVC_GET_LEN:\n\t\tsize = 2;\n\t\tbreak;\n\tcase UVC_GET_INFO:\n\t\tsize = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (size != xqry->size) {\n\t\tret = -ENOBUFS;\n\t\tgoto done;\n\t}\n\n\tif (reqflags && !(ctrl->info.flags & reqflags)) {\n\t\tret = -EBADRQC;\n\t\tgoto done;\n\t}\n\n\tdata = kmalloc(size, GFP_KERNEL);\n\tif (data == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tif (xqry->query == UVC_SET_CUR &&\n\t    copy_from_user(data, xqry->data, size)) {\n\t\tret = -EFAULT;\n\t\tgoto done;\n\t}\n\n\tret = uvc_query_ctrl(chain->dev, xqry->query, xqry->unit,\n\t\t\t     chain->dev->intfnum, xqry->selector, data, size);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tif (xqry->query != UVC_SET_CUR &&\n\t    copy_to_user(xqry->data, data, size))\n\t\tret = -EFAULT;\ndone:\n\tkfree(data);\n\tmutex_unlock(&chain->ctrl_mutex);\n\treturn ret;\n}\n\n \n\n \nint uvc_ctrl_restore_values(struct uvc_device *dev)\n{\n\tstruct uvc_control *ctrl;\n\tstruct uvc_entity *entity;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tlist_for_each_entry(entity, &dev->entities, list) {\n\n\t\tfor (i = 0; i < entity->ncontrols; ++i) {\n\t\t\tctrl = &entity->controls[i];\n\n\t\t\tif (!ctrl->initialized || !ctrl->modified ||\n\t\t\t    (ctrl->info.flags & UVC_CTRL_FLAG_RESTORE) == 0)\n\t\t\t\tcontinue;\n\t\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\t\"restoring control %pUl/%u/%u\\n\",\n\t\t\t\tctrl->info.entity, ctrl->info.index,\n\t\t\t\tctrl->info.selector);\n\t\t\tctrl->dirty = 1;\n\t\t}\n\n\t\tret = uvc_ctrl_commit_entity(dev, entity, 0, NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic int uvc_ctrl_add_info(struct uvc_device *dev, struct uvc_control *ctrl,\n\tconst struct uvc_control_info *info)\n{\n\tctrl->info = *info;\n\tINIT_LIST_HEAD(&ctrl->info.mappings);\n\n\t \n\tctrl->uvc_data = kzalloc(ctrl->info.size * UVC_CTRL_DATA_LAST + 1,\n\t\t\t\t GFP_KERNEL);\n\tif (!ctrl->uvc_data)\n\t\treturn -ENOMEM;\n\n\tctrl->initialized = 1;\n\n\tuvc_dbg(dev, CONTROL, \"Added control %pUl/%u to device %s entity %u\\n\",\n\t\tctrl->info.entity, ctrl->info.selector, dev->udev->devpath,\n\t\tctrl->entity->id);\n\n\treturn 0;\n}\n\n \nstatic int __uvc_ctrl_add_mapping(struct uvc_video_chain *chain,\n\tstruct uvc_control *ctrl, const struct uvc_control_mapping *mapping)\n{\n\tstruct uvc_control_mapping *map;\n\tunsigned int size;\n\tunsigned int i;\n\n\t \n\tmap = kmemdup(mapping, sizeof(*mapping), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tmap->name = NULL;\n\tmap->menu_names = NULL;\n\tmap->menu_mapping = NULL;\n\n\t \n\tif (mapping->name) {\n\t\tmap->name = kstrdup(mapping->name, GFP_KERNEL);\n\t\tif (!map->name)\n\t\t\tgoto err_nomem;\n\t}\n\n\tINIT_LIST_HEAD(&map->ev_subs);\n\n\tif (mapping->menu_mapping && mapping->menu_mask) {\n\t\tsize = sizeof(mapping->menu_mapping[0])\n\t\t       * fls(mapping->menu_mask);\n\t\tmap->menu_mapping = kmemdup(mapping->menu_mapping, size,\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!map->menu_mapping)\n\t\t\tgoto err_nomem;\n\t}\n\tif (mapping->menu_names && mapping->menu_mask) {\n\t\tsize = sizeof(mapping->menu_names[0])\n\t\t       * fls(mapping->menu_mask);\n\t\tmap->menu_names = kmemdup(mapping->menu_names, size,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!map->menu_names)\n\t\t\tgoto err_nomem;\n\t}\n\n\tif (map->get == NULL)\n\t\tmap->get = uvc_get_le_value;\n\tif (map->set == NULL)\n\t\tmap->set = uvc_set_le_value;\n\n\tfor (i = 0; i < ARRAY_SIZE(uvc_control_classes); i++) {\n\t\tif (V4L2_CTRL_ID2WHICH(uvc_control_classes[i]) ==\n\t\t\t\t\t\tV4L2_CTRL_ID2WHICH(map->id)) {\n\t\t\tchain->ctrl_class_bitmap |= BIT(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_add_tail(&map->list, &ctrl->info.mappings);\n\tuvc_dbg(chain->dev, CONTROL, \"Adding mapping '%s' to control %pUl/%u\\n\",\n\t\tuvc_map_get_name(map), ctrl->info.entity,\n\t\tctrl->info.selector);\n\n\treturn 0;\n\nerr_nomem:\n\tkfree(map->menu_names);\n\tkfree(map->menu_mapping);\n\tkfree(map->name);\n\tkfree(map);\n\treturn -ENOMEM;\n}\n\nint uvc_ctrl_add_mapping(struct uvc_video_chain *chain,\n\tconst struct uvc_control_mapping *mapping)\n{\n\tstruct uvc_device *dev = chain->dev;\n\tstruct uvc_control_mapping *map;\n\tstruct uvc_entity *entity;\n\tstruct uvc_control *ctrl;\n\tint found = 0;\n\tint ret;\n\n\tif (mapping->id & ~V4L2_CTRL_ID_MASK) {\n\t\tuvc_dbg(dev, CONTROL,\n\t\t\t\"Can't add mapping '%s', control id 0x%08x is invalid\\n\",\n\t\t\tuvc_map_get_name(mapping), mapping->id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlist_for_each_entry(entity, &chain->entities, chain) {\n\t\tunsigned int i;\n\n\t\tif (UVC_ENTITY_TYPE(entity) != UVC_VC_EXTENSION_UNIT ||\n\t\t    !uvc_entity_match_guid(entity, mapping->entity))\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < entity->ncontrols; ++i) {\n\t\t\tctrl = &entity->controls[i];\n\t\t\tif (ctrl->index == mapping->selector - 1) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\tif (!found)\n\t\treturn -ENOENT;\n\n\tif (mutex_lock_interruptible(&chain->ctrl_mutex))\n\t\treturn -ERESTARTSYS;\n\n\t \n\tret = uvc_ctrl_init_xu_ctrl(dev, ctrl);\n\tif (ret < 0) {\n\t\tret = -ENOENT;\n\t\tgoto done;\n\t}\n\n\t \n\tif (mapping->size > 32 ||\n\t    mapping->offset + mapping->size > ctrl->info.size * 8) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tlist_for_each_entry(map, &ctrl->info.mappings, list) {\n\t\tif (mapping->id == map->id) {\n\t\t\tuvc_dbg(dev, CONTROL,\n\t\t\t\t\"Can't add mapping '%s', control id 0x%08x already exists\\n\",\n\t\t\t\tuvc_map_get_name(mapping), mapping->id);\n\t\t\tret = -EEXIST;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tif (atomic_inc_return(&dev->nmappings) > UVC_MAX_CONTROL_MAPPINGS) {\n\t\tatomic_dec(&dev->nmappings);\n\t\tuvc_dbg(dev, CONTROL,\n\t\t\t\"Can't add mapping '%s', maximum mappings count (%u) exceeded\\n\",\n\t\t\tuvc_map_get_name(mapping), UVC_MAX_CONTROL_MAPPINGS);\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tret = __uvc_ctrl_add_mapping(chain, ctrl, mapping);\n\tif (ret < 0)\n\t\tatomic_dec(&dev->nmappings);\n\ndone:\n\tmutex_unlock(&chain->ctrl_mutex);\n\treturn ret;\n}\n\n \nstatic void uvc_ctrl_prune_entity(struct uvc_device *dev,\n\tstruct uvc_entity *entity)\n{\n\tstruct uvc_ctrl_blacklist {\n\t\tstruct usb_device_id id;\n\t\tu8 index;\n\t};\n\n\tstatic const struct uvc_ctrl_blacklist processing_blacklist[] = {\n\t\t{ { USB_DEVICE(0x13d3, 0x509b) }, 9 },  \n\t\t{ { USB_DEVICE(0x1c4f, 0x3000) }, 6 },  \n\t\t{ { USB_DEVICE(0x5986, 0x0241) }, 2 },  \n\t};\n\tstatic const struct uvc_ctrl_blacklist camera_blacklist[] = {\n\t\t{ { USB_DEVICE(0x06f8, 0x3005) }, 9 },  \n\t};\n\n\tconst struct uvc_ctrl_blacklist *blacklist;\n\tunsigned int size;\n\tunsigned int count;\n\tunsigned int i;\n\tu8 *controls;\n\n\tswitch (UVC_ENTITY_TYPE(entity)) {\n\tcase UVC_VC_PROCESSING_UNIT:\n\t\tblacklist = processing_blacklist;\n\t\tcount = ARRAY_SIZE(processing_blacklist);\n\t\tcontrols = entity->processing.bmControls;\n\t\tsize = entity->processing.bControlSize;\n\t\tbreak;\n\n\tcase UVC_ITT_CAMERA:\n\t\tblacklist = camera_blacklist;\n\t\tcount = ARRAY_SIZE(camera_blacklist);\n\t\tcontrols = entity->camera.bmControls;\n\t\tsize = entity->camera.bControlSize;\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < count; ++i) {\n\t\tif (!usb_match_one_id(dev->intf, &blacklist[i].id))\n\t\t\tcontinue;\n\n\t\tif (blacklist[i].index >= 8 * size ||\n\t\t    !uvc_test_bit(controls, blacklist[i].index))\n\t\t\tcontinue;\n\n\t\tuvc_dbg(dev, CONTROL,\n\t\t\t\"%u/%u control is black listed, removing it\\n\",\n\t\t\tentity->id, blacklist[i].index);\n\n\t\tuvc_clear_bit(controls, blacklist[i].index);\n\t}\n}\n\n \nstatic void uvc_ctrl_init_ctrl(struct uvc_video_chain *chain,\n\t\t\t       struct uvc_control *ctrl)\n{\n\tconst struct uvc_control_mapping **mappings;\n\tunsigned int i;\n\n\t \n\tif (UVC_ENTITY_TYPE(ctrl->entity) == UVC_VC_EXTENSION_UNIT)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(uvc_ctrls); ++i) {\n\t\tconst struct uvc_control_info *info = &uvc_ctrls[i];\n\n\t\tif (uvc_entity_match_guid(ctrl->entity, info->entity) &&\n\t\t    ctrl->index == info->index) {\n\t\t\tuvc_ctrl_add_info(chain->dev, ctrl, info);\n\t\t\t \n\t\t\tuvc_ctrl_get_flags(chain->dev, ctrl, &ctrl->info);\n\t\t\tbreak;\n\t\t }\n\t}\n\n\tif (!ctrl->initialized)\n\t\treturn;\n\n\t \n\tif (chain->dev->info->mappings) {\n\t\tbool custom = false;\n\n\t\tfor (i = 0; chain->dev->info->mappings[i]; ++i) {\n\t\t\tconst struct uvc_control_mapping *mapping =\n\t\t\t\tchain->dev->info->mappings[i];\n\n\t\t\tif (uvc_entity_match_guid(ctrl->entity, mapping->entity) &&\n\t\t\t    ctrl->info.selector == mapping->selector) {\n\t\t\t\t__uvc_ctrl_add_mapping(chain, ctrl, mapping);\n\t\t\t\tcustom = true;\n\t\t\t}\n\t\t}\n\n\t\tif (custom)\n\t\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(uvc_ctrl_mappings); ++i) {\n\t\tconst struct uvc_control_mapping *mapping = &uvc_ctrl_mappings[i];\n\n\t\tif (uvc_entity_match_guid(ctrl->entity, mapping->entity) &&\n\t\t    ctrl->info.selector == mapping->selector)\n\t\t\t__uvc_ctrl_add_mapping(chain, ctrl, mapping);\n\t}\n\n\t \n\tmappings = chain->dev->uvc_version < 0x0150\n\t\t ? uvc_ctrl_mappings_uvc11 : uvc_ctrl_mappings_uvc15;\n\n\tfor (i = 0; mappings[i]; ++i) {\n\t\tconst struct uvc_control_mapping *mapping = mappings[i];\n\n\t\tif (uvc_entity_match_guid(ctrl->entity, mapping->entity) &&\n\t\t    ctrl->info.selector == mapping->selector)\n\t\t\t__uvc_ctrl_add_mapping(chain, ctrl, mapping);\n\t}\n}\n\n \nstatic int uvc_ctrl_init_chain(struct uvc_video_chain *chain)\n{\n\tstruct uvc_entity *entity;\n\tunsigned int i;\n\n\t \n\tlist_for_each_entry(entity, &chain->entities, chain) {\n\t\tstruct uvc_control *ctrl;\n\t\tunsigned int bControlSize = 0, ncontrols;\n\t\tu8 *bmControls = NULL;\n\n\t\tif (UVC_ENTITY_TYPE(entity) == UVC_VC_EXTENSION_UNIT) {\n\t\t\tbmControls = entity->extension.bmControls;\n\t\t\tbControlSize = entity->extension.bControlSize;\n\t\t} else if (UVC_ENTITY_TYPE(entity) == UVC_VC_PROCESSING_UNIT) {\n\t\t\tbmControls = entity->processing.bmControls;\n\t\t\tbControlSize = entity->processing.bControlSize;\n\t\t} else if (UVC_ENTITY_TYPE(entity) == UVC_ITT_CAMERA) {\n\t\t\tbmControls = entity->camera.bmControls;\n\t\t\tbControlSize = entity->camera.bControlSize;\n\t\t} else if (UVC_ENTITY_TYPE(entity) == UVC_EXT_GPIO_UNIT) {\n\t\t\tbmControls = entity->gpio.bmControls;\n\t\t\tbControlSize = entity->gpio.bControlSize;\n\t\t}\n\n\t\t \n\t\tuvc_ctrl_prune_entity(chain->dev, entity);\n\n\t\t \n\t\tncontrols = memweight(bmControls, bControlSize);\n\t\tif (ncontrols == 0)\n\t\t\tcontinue;\n\n\t\tentity->controls = kcalloc(ncontrols, sizeof(*ctrl),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (entity->controls == NULL)\n\t\t\treturn -ENOMEM;\n\t\tentity->ncontrols = ncontrols;\n\n\t\t \n\t\tctrl = entity->controls;\n\t\tfor (i = 0; i < bControlSize * 8; ++i) {\n\t\t\tif (uvc_test_bit(bmControls, i) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tctrl->entity = entity;\n\t\t\tctrl->index = i;\n\n\t\t\tuvc_ctrl_init_ctrl(chain, ctrl);\n\t\t\tctrl++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint uvc_ctrl_init_device(struct uvc_device *dev)\n{\n\tstruct uvc_video_chain *chain;\n\tint ret;\n\n\tINIT_WORK(&dev->async_ctrl.work, uvc_ctrl_status_event_work);\n\n\tlist_for_each_entry(chain, &dev->chains, list) {\n\t\tret = uvc_ctrl_init_chain(chain);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void uvc_ctrl_cleanup_mappings(struct uvc_device *dev,\n\tstruct uvc_control *ctrl)\n{\n\tstruct uvc_control_mapping *mapping, *nm;\n\n\tlist_for_each_entry_safe(mapping, nm, &ctrl->info.mappings, list) {\n\t\tlist_del(&mapping->list);\n\t\tkfree(mapping->menu_names);\n\t\tkfree(mapping->menu_mapping);\n\t\tkfree(mapping->name);\n\t\tkfree(mapping);\n\t}\n}\n\nvoid uvc_ctrl_cleanup_device(struct uvc_device *dev)\n{\n\tstruct uvc_entity *entity;\n\tunsigned int i;\n\n\t \n\tif (dev->async_ctrl.work.func)\n\t\tcancel_work_sync(&dev->async_ctrl.work);\n\n\t \n\tlist_for_each_entry(entity, &dev->entities, list) {\n\t\tfor (i = 0; i < entity->ncontrols; ++i) {\n\t\t\tstruct uvc_control *ctrl = &entity->controls[i];\n\n\t\t\tif (!ctrl->initialized)\n\t\t\t\tcontinue;\n\n\t\t\tuvc_ctrl_cleanup_mappings(dev, ctrl);\n\t\t\tkfree(ctrl->uvc_data);\n\t\t}\n\n\t\tkfree(entity->controls);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}