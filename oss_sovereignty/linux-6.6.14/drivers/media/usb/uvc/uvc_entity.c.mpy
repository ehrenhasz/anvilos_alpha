{
  "module_name": "uvc_entity.c",
  "hash_id": "8786778fe8a108f6d196270aa2463d1e12b13f5d3f997f1bf7f1d106b59e9697",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/uvc/uvc_entity.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-common.h>\n\n#include \"uvcvideo.h\"\n\nstatic int uvc_mc_create_links(struct uvc_video_chain *chain,\n\t\t\t\t    struct uvc_entity *entity)\n{\n\tconst u32 flags = MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE;\n\tstruct media_entity *sink;\n\tunsigned int i;\n\tint ret;\n\n\tsink = (UVC_ENTITY_TYPE(entity) == UVC_TT_STREAMING)\n\t     ? (entity->vdev ? &entity->vdev->entity : NULL)\n\t     : &entity->subdev.entity;\n\tif (sink == NULL)\n\t\treturn 0;\n\n\tfor (i = 0; i < entity->num_pads; ++i) {\n\t\tstruct media_entity *source;\n\t\tstruct uvc_entity *remote;\n\t\tu8 remote_pad;\n\n\t\tif (!(entity->pads[i].flags & MEDIA_PAD_FL_SINK))\n\t\t\tcontinue;\n\n\t\tremote = uvc_entity_by_id(chain->dev, entity->baSourceID[i]);\n\t\tif (remote == NULL || remote->num_pads == 0)\n\t\t\treturn -EINVAL;\n\n\t\tsource = (UVC_ENTITY_TYPE(remote) == UVC_TT_STREAMING)\n\t\t       ? (remote->vdev ? &remote->vdev->entity : NULL)\n\t\t       : &remote->subdev.entity;\n\t\tif (source == NULL)\n\t\t\tcontinue;\n\n\t\tremote_pad = remote->num_pads - 1;\n\t\tret = media_create_pad_link(source, remote_pad,\n\t\t\t\t\t       sink, i, flags);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_ops uvc_subdev_ops = {\n};\n\nvoid uvc_mc_cleanup_entity(struct uvc_entity *entity)\n{\n\tif (UVC_ENTITY_TYPE(entity) != UVC_TT_STREAMING)\n\t\tmedia_entity_cleanup(&entity->subdev.entity);\n\telse if (entity->vdev != NULL)\n\t\tmedia_entity_cleanup(&entity->vdev->entity);\n}\n\nstatic int uvc_mc_init_entity(struct uvc_video_chain *chain,\n\t\t\t      struct uvc_entity *entity)\n{\n\tint ret;\n\n\tif (UVC_ENTITY_TYPE(entity) != UVC_TT_STREAMING) {\n\t\tu32 function;\n\n\t\tv4l2_subdev_init(&entity->subdev, &uvc_subdev_ops);\n\t\tstrscpy(entity->subdev.name, entity->name,\n\t\t\tsizeof(entity->subdev.name));\n\n\t\tswitch (UVC_ENTITY_TYPE(entity)) {\n\t\tcase UVC_VC_SELECTOR_UNIT:\n\t\t\tfunction = MEDIA_ENT_F_VID_MUX;\n\t\t\tbreak;\n\t\tcase UVC_VC_PROCESSING_UNIT:\n\t\tcase UVC_VC_EXTENSION_UNIT:\n\t\t\t \n\t\t\tfunction = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;\n\t\t\tbreak;\n\t\tcase UVC_COMPOSITE_CONNECTOR:\n\t\tcase UVC_COMPONENT_CONNECTOR:\n\t\t\tfunction = MEDIA_ENT_F_CONN_COMPOSITE;\n\t\t\tbreak;\n\t\tcase UVC_SVIDEO_CONNECTOR:\n\t\t\tfunction = MEDIA_ENT_F_CONN_SVIDEO;\n\t\t\tbreak;\n\t\tcase UVC_ITT_CAMERA:\n\t\t\tfunction = MEDIA_ENT_F_CAM_SENSOR;\n\t\t\tbreak;\n\t\tcase UVC_TT_VENDOR_SPECIFIC:\n\t\tcase UVC_ITT_VENDOR_SPECIFIC:\n\t\tcase UVC_ITT_MEDIA_TRANSPORT_INPUT:\n\t\tcase UVC_OTT_VENDOR_SPECIFIC:\n\t\tcase UVC_OTT_DISPLAY:\n\t\tcase UVC_OTT_MEDIA_TRANSPORT_OUTPUT:\n\t\tcase UVC_EXTERNAL_VENDOR_SPECIFIC:\n\t\tcase UVC_EXT_GPIO_UNIT:\n\t\tdefault:\n\t\t\tfunction = MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\n\t\tentity->subdev.entity.function = function;\n\n\t\tret = media_entity_pads_init(&entity->subdev.entity,\n\t\t\t\t\tentity->num_pads, entity->pads);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = v4l2_device_register_subdev(&chain->dev->vdev,\n\t\t\t\t\t\t  &entity->subdev);\n\t} else if (entity->vdev != NULL) {\n\t\tret = media_entity_pads_init(&entity->vdev->entity,\n\t\t\t\t\tentity->num_pads, entity->pads);\n\t\tif (entity->flags & UVC_ENTITY_FLAG_DEFAULT)\n\t\t\tentity->vdev->entity.flags |= MEDIA_ENT_FL_DEFAULT;\n\t} else\n\t\tret = 0;\n\n\treturn ret;\n}\n\nint uvc_mc_register_entities(struct uvc_video_chain *chain)\n{\n\tstruct uvc_entity *entity;\n\tint ret;\n\n\tlist_for_each_entry(entity, &chain->entities, chain) {\n\t\tret = uvc_mc_init_entity(chain, entity);\n\t\tif (ret < 0) {\n\t\t\tdev_info(&chain->dev->udev->dev,\n\t\t\t\t \"Failed to initialize entity for entity %u\\n\",\n\t\t\t\t entity->id);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tlist_for_each_entry(entity, &chain->entities, chain) {\n\t\tret = uvc_mc_create_links(chain, entity);\n\t\tif (ret < 0) {\n\t\t\tdev_info(&chain->dev->udev->dev,\n\t\t\t\t \"Failed to create links for entity %u\\n\",\n\t\t\t\t entity->id);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}