{
  "module_name": "dvb-ttusb-budget.c",
  "hash_id": "8359cd90cc37b750683b38ca469b9546338f3884d795bfd1adb8263b677efe8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/ttusb-budget/dvb-ttusb-budget.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/delay.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/jiffies.h>\n#include <linux/mutex.h>\n#include <linux/firmware.h>\n\n#include <media/dvb_frontend.h>\n#include <media/dmxdev.h>\n#include <media/dvb_demux.h>\n#include <media/dvb_net.h>\n#include \"ves1820.h\"\n#include \"cx22700.h\"\n#include \"tda1004x.h\"\n#include \"stv0299.h\"\n#include \"tda8083.h\"\n#include \"stv0297.h\"\n#include \"lnbp21.h\"\n\n#include <linux/dvb/frontend.h>\n#include <linux/dvb/dmx.h>\n#include <linux/pci.h>\n\n \n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off debugging (default:off).\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n#define dprintk(fmt, arg...) do {\t\t\t\t\t\\\n\tif (debug)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt),\t\t\t\\\n\t\t       __func__, ##arg);\t\t\t\t\\\n} while (0)\n\n\n#define ISO_BUF_COUNT      4\n#define FRAMES_PER_ISO_BUF 4\n#define ISO_FRAME_SIZE     912\n#define TTUSB_MAXCHANNEL   32\n#ifdef TTUSB_HWSECTIONS\n#define TTUSB_MAXFILTER    16\t \n#endif\n\n#define TTUSB_REV_2_2\t0x22\n#define TTUSB_BUDGET_NAME \"ttusb_stc_fw\"\n\n#define MAX_SEND\t0x28\n#define MAX_RCV\t\t0x20\n\n \nstruct ttusb {\n\tstruct dvb_demux dvb_demux;\n\tstruct dmxdev dmxdev;\n\tstruct dvb_net dvbnet;\n\n\t \n\tstruct mutex semi2c;\n\tstruct mutex semusb;\n\n\tstruct dvb_adapter adapter;\n\tstruct usb_device *dev;\n\n\tstruct i2c_adapter i2c_adap;\n\n\tint disconnecting;\n\tint iso_streaming;\n\n\tunsigned int bulk_out_pipe;\n\tunsigned int bulk_in_pipe;\n\tunsigned int isoc_in_pipe;\n\n\tvoid *iso_buffer;\n\n\tstruct urb *iso_urb[ISO_BUF_COUNT];\n\n\tint running_feed_count;\n\tint last_channel;\n\tint last_filter;\n\n\tu8 c;\t\t\t \n\tenum fe_sec_tone_mode tone;\n\tenum fe_sec_voltage voltage;\n\n\tint mux_state;\t\t \n\tu8 mux_npacks;\n\tu8 muxpack[256 + 8];\n\tint muxpack_ptr, muxpack_len;\n\n\tint insync;\n\n\tint cc;\t\t\t \n\t \n\n\tu8 send_buf[MAX_SEND];\n\tu8 last_result[MAX_RCV];\n\n\tint revision;\n\n\tstruct dvb_frontend* fe;\n};\n\nstatic int ttusb_cmd(struct ttusb *ttusb, u8 *data, int len, int len_result)\n{\n\tint actual_len;\n\tint err;\n\n\tif (mutex_lock_interruptible(&ttusb->semusb) < 0)\n\t\treturn -EAGAIN;\n\n\tif (debug >= 3)\n\t\tdprintk(\"> %*ph\\n\", len, data);\n\n\tmemcpy(data, ttusb->send_buf, len);\n\n\terr = usb_bulk_msg(ttusb->dev, ttusb->bulk_out_pipe,\n\t\t\t   ttusb->send_buf, len, &actual_len, 1000);\n\tif (err != 0) {\n\t\tdprintk(\"usb_bulk_msg(send) failed, err == %i!\\n\", err);\n\t\tgoto err;\n\t}\n\tif (actual_len != len) {\n\t\terr = -EIO;\n\t\tdprintk(\"only wrote %d of %d bytes\\n\",\n\t\t\tactual_len, len);\n\t\tgoto err;\n\t}\n\n\terr = usb_bulk_msg(ttusb->dev, ttusb->bulk_in_pipe,\n\t\t\t   ttusb->last_result, MAX_RCV, &actual_len, 1000);\n\n\tif (err != 0) {\n\t\tpr_err(\"cmd xter failed, receive error %d\\n\", err);\n\t\tgoto err;\n\t}\n\n\tif (debug >= 3) {\n\t\tactual_len = ttusb->last_result[3] + 4;\n\t\tdprintk(\"< %*ph\\n\", actual_len, ttusb->last_result);\n\t}\n\n\tif (len_result)\n\t\tmemcpy(ttusb->send_buf, ttusb->last_result, len_result);\n\nerr:\n\tmutex_unlock(&ttusb->semusb);\n\treturn err;\n}\n\nstatic int ttusb_i2c_msg(struct ttusb *ttusb,\n\t\t  u8 addr, u8 * snd_buf, u8 snd_len, u8 * rcv_buf,\n\t\t  u8 rcv_len)\n{\n\tu8 b[MAX_SEND];\n\tu8 id = ++ttusb->c;\n\tint i, err;\n\n\tif (snd_len > MAX_SEND - 7 || rcv_len > MAX_RCV - 7)\n\t\treturn -EINVAL;\n\n\tb[0] = 0xaa;\n\tb[1] = id;\n\tb[2] = 0x31;\n\tb[3] = snd_len + 3;\n\tb[4] = addr << 1;\n\tb[5] = snd_len;\n\tb[6] = rcv_len;\n\n\tfor (i = 0; i < snd_len; i++)\n\t\tb[7 + i] = snd_buf[i];\n\n\terr = ttusb_cmd(ttusb, b, snd_len + 7, MAX_RCV);\n\n\tif (err)\n\t\treturn -EREMOTEIO;\n\n\t \n\tif ((snd_len != b[5]) || (rcv_len != b[6])) return -EREMOTEIO;\n\n\tif (rcv_len > 0) {\n\n\t\tif (err || b[0] != 0x55 || b[1] != id) {\n\t\t\tdprintk(\"usb_bulk_msg(recv) failed, err == %i, id == %02x, b == \",\n\t\t\t\terr, id);\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\n\t\tfor (i = 0; i < rcv_len; i++)\n\t\t\trcv_buf[i] = b[7 + i];\n\t}\n\n\treturn rcv_len;\n}\n\nstatic int master_xfer(struct i2c_adapter* adapter, struct i2c_msg *msg, int num)\n{\n\tstruct ttusb *ttusb = i2c_get_adapdata(adapter);\n\tint i = 0;\n\tint inc;\n\n\tif (mutex_lock_interruptible(&ttusb->semi2c) < 0)\n\t\treturn -EAGAIN;\n\n\twhile (i < num) {\n\t\tu8 addr, snd_len, rcv_len, *snd_buf, *rcv_buf;\n\t\tint err;\n\n\t\tif (num > i + 1 && (msg[i + 1].flags & I2C_M_RD)) {\n\t\t\taddr = msg[i].addr;\n\t\t\tsnd_buf = msg[i].buf;\n\t\t\tsnd_len = msg[i].len;\n\t\t\trcv_buf = msg[i + 1].buf;\n\t\t\trcv_len = msg[i + 1].len;\n\t\t\tinc = 2;\n\t\t} else {\n\t\t\taddr = msg[i].addr;\n\t\t\tsnd_buf = msg[i].buf;\n\t\t\tsnd_len = msg[i].len;\n\t\t\trcv_buf = NULL;\n\t\t\trcv_len = 0;\n\t\t\tinc = 1;\n\t\t}\n\n\t\terr = ttusb_i2c_msg(ttusb, addr,\n\t\t\t\t    snd_buf, snd_len, rcv_buf, rcv_len);\n\n\t\tif (err < rcv_len) {\n\t\t\tdprintk(\"i == %i\\n\", i);\n\t\t\tbreak;\n\t\t}\n\n\t\ti += inc;\n\t}\n\n\tmutex_unlock(&ttusb->semi2c);\n\treturn i;\n}\n\nstatic int ttusb_boot_dsp(struct ttusb *ttusb)\n{\n\tconst struct firmware *fw;\n\tint i, err;\n\tu8 b[40];\n\n\terr = request_firmware(&fw, \"ttusb-budget/dspbootcode.bin\",\n\t\t\t       &ttusb->dev->dev);\n\tif (err) {\n\t\tpr_err(\"failed to request firmware\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tb[0] = 0xaa;\n\tb[2] = 0x13;\n\tb[3] = 28;\n\n\t \n\t \n\tfor (i = 0; i < fw->size; i += 28) {\n\t\tmemcpy(&b[4], &fw->data[i], 28);\n\n\t\tb[1] = ++ttusb->c;\n\n\t\terr = ttusb_cmd(ttusb, b, 32, 0);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\t \n\tb[1] = ++ttusb->c;\n\tb[2] = 0x13;\n\tb[3] = 0;\n\n\terr = ttusb_cmd(ttusb, b, 4, 0);\n\tif (err)\n\t\tgoto done;\n\n\t \n\tb[1] = ++ttusb->c;\n\tb[2] = 0x14;\n\tb[3] = 0;\n\n\terr = ttusb_cmd(ttusb, b, 4, 0);\n\n      done:\n\trelease_firmware(fw);\n\tif (err) {\n\t\tdprintk(\"usb_bulk_msg() failed, return value %i!\\n\", err);\n\t}\n\n\treturn err;\n}\n\nstatic int ttusb_set_channel(struct ttusb *ttusb, int chan_id, int filter_type,\n\t\t      int pid)\n{\n\tint err;\n\t \n\tu8 b[] = { 0xaa, ++ttusb->c, 0x22, 4, chan_id, filter_type,\n\t\t(pid >> 8) & 0xff, pid & 0xff\n\t};\n\n\terr = ttusb_cmd(ttusb, b, sizeof(b), 0);\n\treturn err;\n}\n\nstatic int ttusb_del_channel(struct ttusb *ttusb, int channel_id)\n{\n\tint err;\n\t \n\tu8 b[] = { 0xaa, ++ttusb->c, 0x23, 1, channel_id };\n\n\terr = ttusb_cmd(ttusb, b, sizeof(b), 0);\n\treturn err;\n}\n\n#ifdef TTUSB_HWSECTIONS\nstatic int ttusb_set_filter(struct ttusb *ttusb, int filter_id,\n\t\t     int associated_chan, u8 filter[8], u8 mask[8])\n{\n\tint err;\n\t \n\tu8 b[] = { 0xaa, 0, 0x24, 0x1a, filter_id, associated_chan,\n\t\tfilter[0], filter[1], filter[2], filter[3],\n\t\tfilter[4], filter[5], filter[6], filter[7],\n\t\tfilter[8], filter[9], filter[10], filter[11],\n\t\tmask[0], mask[1], mask[2], mask[3],\n\t\tmask[4], mask[5], mask[6], mask[7],\n\t\tmask[8], mask[9], mask[10], mask[11]\n\t};\n\n\terr = ttusb_cmd(ttusb, b, sizeof(b), 0);\n\treturn err;\n}\n\nstatic int ttusb_del_filter(struct ttusb *ttusb, int filter_id)\n{\n\tint err;\n\t \n\tu8 b[] = { 0xaa, ++ttusb->c, 0x25, 1, filter_id };\n\n\terr = ttusb_cmd(ttusb, b, sizeof(b), 0);\n\treturn err;\n}\n#endif\n\nstatic int ttusb_init_controller(struct ttusb *ttusb)\n{\n\tu8 b0[] = { 0xaa, ++ttusb->c, 0x15, 1, 0 };\n\tu8 b1[] = { 0xaa, ++ttusb->c, 0x15, 1, 1 };\n\tu8 b2[] = { 0xaa, ++ttusb->c, 0x32, 1, 0 };\n\t \n\tu8 b3[] =\n\t    { 0xaa, ++ttusb->c, 0x31, 5, 0x10, 0x02, 0x01, 0x00, 0x1e };\n\n\tu8 get_version[] = { 0xaa, ++ttusb->c, 0x17, 5, 0, 0, 0, 0, 0 };\n\tu8 get_dsp_version[0x20] =\n\t    { 0xaa, ++ttusb->c, 0x26, 28, 0, 0, 0, 0, 0 };\n\tint err;\n\n\t \n\tif ((err = ttusb_cmd(ttusb, b0, sizeof(b0), 0)))\n\t\treturn err;\n\n\t \n\tif ((err = ttusb_cmd(ttusb, b1, sizeof(b1), 0)))\n\t\treturn err;\n\n\tttusb_boot_dsp(ttusb);\n\n\t \n\tif ((err = ttusb_cmd(ttusb, b2, sizeof(b2), 0)))\n\t\treturn err;\n\n\tif ((err = ttusb_cmd(ttusb, b3, sizeof(b3), 0)))\n\t\treturn err;\n\n\tif ((err = ttusb_cmd(ttusb, get_version,\n\t\t\t     sizeof(get_version), sizeof(get_version))))\n\t\treturn err;\n\n\tdprintk(\"stc-version: %c%c%c%c%c\\n\", get_version[4], get_version[5],\n\t\tget_version[6], get_version[7], get_version[8]);\n\n\tif (memcmp(get_version + 4, \"V 0.0\", 5) &&\n\t    memcmp(get_version + 4, \"V 1.1\", 5) &&\n\t    memcmp(get_version + 4, \"V 2.1\", 5) &&\n\t    memcmp(get_version + 4, \"V 2.2\", 5)) {\n\t\tpr_err(\"unknown STC version %c%c%c%c%c, please report!\\n\",\n\t\t       get_version[4], get_version[5],\n\t\t       get_version[6], get_version[7], get_version[8]);\n\t}\n\n\tttusb->revision = ((get_version[6] - '0') << 4) |\n\t\t\t   (get_version[8] - '0');\n\n\terr =\n\t    ttusb_cmd(ttusb, get_dsp_version,\n\t\t      sizeof(get_dsp_version), sizeof(get_dsp_version));\n\tif (err)\n\t\treturn err;\n\n\tpr_info(\"dsp-version: %c%c%c\\n\",\n\t       get_dsp_version[4], get_dsp_version[5], get_dsp_version[6]);\n\treturn 0;\n}\n\n#ifdef TTUSB_DISEQC\nstatic int ttusb_send_diseqc(struct dvb_frontend* fe,\n\t\t\t     const struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct ttusb* ttusb = (struct ttusb*) fe->dvb->priv;\n\tu8 b[12] = { 0xaa, ++ttusb->c, 0x18 };\n\n\tint err;\n\n\tb[3] = 4 + 2 + cmd->msg_len;\n\tb[4] = 0xFF;\t\t \n\tb[5] = cmd->msg_len;\n\n\tmemcpy(b + 5, cmd->msg, cmd->msg_len);\n\n\t \n\tif ((err = ttusb_cmd(ttusb, b, 4 + b[3], 0))) {\n\t\tdprintk(\"usb_bulk_msg() failed, return value %i!\\n\", err);\n\t}\n\n\treturn err;\n}\n#endif\n\nstatic int ttusb_update_lnb(struct ttusb *ttusb)\n{\n\tu8 b[] = { 0xaa, ++ttusb->c, 0x16, 5,   1,\n\t\tttusb->voltage == SEC_VOLTAGE_18 ? 0 : 1,\n\t\tttusb->tone == SEC_TONE_ON ? 1 : 0, 1, 1\n\t};\n\tint err;\n\n\t \n\tif ((err = ttusb_cmd(ttusb, b, sizeof(b), 0))) {\n\t\tdprintk(\"usb_bulk_msg() failed, return value %i!\\n\", err);\n\t}\n\n\treturn err;\n}\n\nstatic int ttusb_set_voltage(struct dvb_frontend *fe,\n\t\t\t     enum fe_sec_voltage voltage)\n{\n\tstruct ttusb* ttusb = (struct ttusb*) fe->dvb->priv;\n\n\tttusb->voltage = voltage;\n\treturn ttusb_update_lnb(ttusb);\n}\n\n#ifdef TTUSB_TONE\nstatic int ttusb_set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)\n{\n\tstruct ttusb* ttusb = (struct ttusb*) fe->dvb->priv;\n\n\tttusb->tone = tone;\n\treturn ttusb_update_lnb(ttusb);\n}\n#endif\n\n\n#if 0\nstatic void ttusb_set_led_freq(struct ttusb *ttusb, u8 freq)\n{\n\tu8 b[] = { 0xaa, ++ttusb->c, 0x19, 1, freq };\n\tint err, actual_len;\n\n\terr = ttusb_cmd(ttusb, b, sizeof(b), 0);\n\tif (err) {\n\t\tdprintk(\"usb_bulk_msg() failed, return value %i!\\n\", err);\n\t}\n}\n#endif\n\n \n\n#ifdef TTUSB_HWSECTIONS\nstatic void ttusb_handle_ts_data(struct ttusb_channel *channel,\n\t\t\t\t const u8 * data, int len);\nstatic void ttusb_handle_sec_data(struct ttusb_channel *channel,\n\t\t\t\t  const u8 * data, int len);\n#endif\n\nstatic int numpkt, numts, numstuff, numsec, numinvalid;\nstatic unsigned long lastj;\n\nstatic void ttusb_process_muxpack(struct ttusb *ttusb, const u8 * muxpack,\n\t\t\t   int len)\n{\n\tu16 csum = 0, cc;\n\tint i;\n\n\tif (len < 4 || len & 0x1) {\n\t\tpr_warn(\"muxpack has invalid len %d\\n\", len);\n\t\tnuminvalid++;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < len; i += 2)\n\t\tcsum ^= le16_to_cpup((__le16 *) (muxpack + i));\n\tif (csum) {\n\t\tpr_warn(\"muxpack with incorrect checksum, ignoring\\n\");\n\t\tnuminvalid++;\n\t\treturn;\n\t}\n\n\tcc = (muxpack[len - 4] << 8) | muxpack[len - 3];\n\tcc &= 0x7FFF;\n\tif ((cc != ttusb->cc) && (ttusb->cc != -1))\n\t\tpr_warn(\"cc discontinuity (%d frames missing)\\n\",\n\t\t\t(cc - ttusb->cc) & 0x7FFF);\n\tttusb->cc = (cc + 1) & 0x7FFF;\n\tif (muxpack[0] & 0x80) {\n#ifdef TTUSB_HWSECTIONS\n\t\t \n\t\tint pusi = muxpack[0] & 0x40;\n\t\tint channel = muxpack[0] & 0x1F;\n\t\tint payload = muxpack[1];\n\t\tconst u8 *data = muxpack + 2;\n\t\t \n\t\tif (muxpack[0] & 0x20)\n\t\t\tdata++;\n\n\t\tttusb_handle_sec_data(ttusb->channel + channel, data,\n\t\t\t\t      payload);\n\t\tdata += payload;\n\n\t\tif ((!!(ttusb->muxpack[0] & 0x20)) ^\n\t\t    !!(ttusb->muxpack[1] & 1))\n\t\t\tdata++;\n#warning TODO: pusi\n\t\tdprintk(\"cc: %04x\\n\", (data[0] << 8) | data[1]);\n#endif\n\t\tnumsec++;\n\t} else if (muxpack[0] == 0x47) {\n#ifdef TTUSB_HWSECTIONS\n\t\t \n\t\tint pid = ((muxpack[1] & 0x0F) << 8) | muxpack[2];\n\t\tint channel;\n\t\tfor (channel = 0; channel < TTUSB_MAXCHANNEL; ++channel)\n\t\t\tif (ttusb->channel[channel].active\n\t\t\t    && (pid == ttusb->channel[channel].pid))\n\t\t\t\tttusb_handle_ts_data(ttusb->channel +\n\t\t\t\t\t\t     channel, muxpack,\n\t\t\t\t\t\t     188);\n#endif\n\t\tnumts++;\n\t\tdvb_dmx_swfilter_packets(&ttusb->dvb_demux, muxpack, 1);\n\t} else if (muxpack[0] != 0) {\n\t\tnuminvalid++;\n\t\tpr_err(\"illegal muxpack type %02x\\n\", muxpack[0]);\n\t} else\n\t\tnumstuff++;\n}\n\nstatic void ttusb_process_frame(struct ttusb *ttusb, u8 * data, int len)\n{\n\tint maxwork = 1024;\n\twhile (len) {\n\t\tif (!(maxwork--)) {\n\t\t\tpr_err(\"too much work\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (ttusb->mux_state) {\n\t\tcase 0:\n\t\tcase 1:\n\t\tcase 2:\n\t\t\tlen--;\n\t\t\tif (*data++ == 0xAA)\n\t\t\t\t++ttusb->mux_state;\n\t\t\telse {\n\t\t\t\tttusb->mux_state = 0;\n\t\t\t\tif (ttusb->insync) {\n\t\t\t\t\tpr_info(\"lost sync.\\n\");\n\t\t\t\t\tttusb->insync = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tttusb->insync = 1;\n\t\t\tlen--;\n\t\t\tttusb->mux_npacks = *data++;\n\t\t\t++ttusb->mux_state;\n\t\t\tttusb->muxpack_ptr = 0;\n\t\t\t \n\t\t\tttusb->muxpack_len = 2;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t{\n\t\t\t\tint avail;\n\t\t\t\tavail = len;\n\t\t\t\tif (avail >\n\t\t\t\t    (ttusb->muxpack_len -\n\t\t\t\t     ttusb->muxpack_ptr))\n\t\t\t\t\tavail =\n\t\t\t\t\t    ttusb->muxpack_len -\n\t\t\t\t\t    ttusb->muxpack_ptr;\n\t\t\t\tmemcpy(ttusb->muxpack + ttusb->muxpack_ptr,\n\t\t\t\t       data, avail);\n\t\t\t\tttusb->muxpack_ptr += avail;\n\t\t\t\tBUG_ON(ttusb->muxpack_ptr > 264);\n\t\t\t\tdata += avail;\n\t\t\t\tlen -= avail;\n\t\t\t\t \n\t\t\t\tif (ttusb->muxpack_ptr == 2) {\n\t\t\t\t\tif (ttusb->muxpack[0] & 0x80) {\n\t\t\t\t\t\tttusb->muxpack_len =\n\t\t\t\t\t\t    ttusb->muxpack[1] + 2;\n\t\t\t\t\t\tif (ttusb->\n\t\t\t\t\t\t    muxpack[0] & 0x20)\n\t\t\t\t\t\t\tttusb->\n\t\t\t\t\t\t\t    muxpack_len++;\n\t\t\t\t\t\tif ((!!\n\t\t\t\t\t\t     (ttusb->\n\t\t\t\t\t\t      muxpack[0] & 0x20)) ^\n\t\t\t\t\t\t    !!(ttusb->\n\t\t\t\t\t\t       muxpack[1] & 1))\n\t\t\t\t\t\t\tttusb->\n\t\t\t\t\t\t\t    muxpack_len++;\n\t\t\t\t\t\tttusb->muxpack_len += 4;\n\t\t\t\t\t} else if (ttusb->muxpack[0] ==\n\t\t\t\t\t\t   0x47)\n\t\t\t\t\t\tttusb->muxpack_len =\n\t\t\t\t\t\t    188 + 4;\n\t\t\t\t\telse if (ttusb->muxpack[0] == 0x00)\n\t\t\t\t\t\tttusb->muxpack_len =\n\t\t\t\t\t\t    ttusb->muxpack[1] + 2 +\n\t\t\t\t\t\t    4;\n\t\t\t\t\telse {\n\t\t\t\t\t\tdprintk(\"invalid state: first byte is %x\\n\",\n\t\t\t\t\t\t\tttusb->muxpack[0]);\n\t\t\t\t\t\tttusb->mux_state = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t \n\t\t\t\tif ((ttusb->muxpack_ptr >= 2) &&\n\t\t\t\t    (ttusb->muxpack_ptr ==\n\t\t\t\t     ttusb->muxpack_len)) {\n\t\t\t\t\tttusb_process_muxpack(ttusb,\n\t\t\t\t\t\t\t      ttusb->\n\t\t\t\t\t\t\t      muxpack,\n\t\t\t\t\t\t\t      ttusb->\n\t\t\t\t\t\t\t      muxpack_ptr);\n\t\t\t\t\tttusb->muxpack_ptr = 0;\n\t\t\t\t\t \n\t\t\t\t\tttusb->muxpack_len = 2;\n\n\t\t\t\t \n\t\t\t\t\tif (!ttusb->mux_npacks--) {\n\t\t\t\t\t\tttusb->mux_state = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void ttusb_iso_irq(struct urb *urb)\n{\n\tstruct ttusb *ttusb = urb->context;\n\tstruct usb_iso_packet_descriptor *d;\n\tu8 *data;\n\tint len, i;\n\n\tif (!ttusb->iso_streaming)\n\t\treturn;\n\n\tif (!urb->status) {\n\t\tfor (i = 0; i < urb->number_of_packets; ++i) {\n\t\t\tnumpkt++;\n\t\t\tif (time_after_eq(jiffies, lastj + HZ)) {\n\t\t\t\tdprintk(\"frames/s: %lu (ts: %d, stuff %d, sec: %d, invalid: %d, all: %d)\\n\",\n\t\t\t\t\tnumpkt * HZ / (jiffies - lastj),\n\t\t\t\t\tnumts, numstuff, numsec, numinvalid,\n\t\t\t\t\tnumts + numstuff + numsec + numinvalid);\n\t\t\t\tnumts = numstuff = numsec = numinvalid = 0;\n\t\t\t\tlastj = jiffies;\n\t\t\t\tnumpkt = 0;\n\t\t\t}\n\t\t\td = &urb->iso_frame_desc[i];\n\t\t\tdata = urb->transfer_buffer + d->offset;\n\t\t\tlen = d->actual_length;\n\t\t\td->actual_length = 0;\n\t\t\td->status = 0;\n\t\t\tttusb_process_frame(ttusb, data, len);\n\t\t}\n\t}\n\tusb_submit_urb(urb, GFP_ATOMIC);\n}\n\nstatic void ttusb_free_iso_urbs(struct ttusb *ttusb)\n{\n\tint i;\n\n\tfor (i = 0; i < ISO_BUF_COUNT; i++)\n\t\tusb_free_urb(ttusb->iso_urb[i]);\n\tkfree(ttusb->iso_buffer);\n}\n\nstatic int ttusb_alloc_iso_urbs(struct ttusb *ttusb)\n{\n\tint i;\n\n\tttusb->iso_buffer = kcalloc(FRAMES_PER_ISO_BUF * ISO_BUF_COUNT,\n\t\t\tISO_FRAME_SIZE, GFP_KERNEL);\n\tif (!ttusb->iso_buffer)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ISO_BUF_COUNT; i++) {\n\t\tstruct urb *urb;\n\n\t\tif (!\n\t\t    (urb =\n\t\t     usb_alloc_urb(FRAMES_PER_ISO_BUF, GFP_ATOMIC))) {\n\t\t\tttusb_free_iso_urbs(ttusb);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tttusb->iso_urb[i] = urb;\n\t}\n\n\treturn 0;\n}\n\nstatic void ttusb_stop_iso_xfer(struct ttusb *ttusb)\n{\n\tint i;\n\n\tfor (i = 0; i < ISO_BUF_COUNT; i++)\n\t\tusb_kill_urb(ttusb->iso_urb[i]);\n\n\tttusb->iso_streaming = 0;\n}\n\nstatic int ttusb_start_iso_xfer(struct ttusb *ttusb)\n{\n\tint i, j, err, buffer_offset = 0;\n\n\tif (ttusb->iso_streaming) {\n\t\tpr_err(\"iso xfer already running!\\n\");\n\t\treturn 0;\n\t}\n\n\tttusb->cc = -1;\n\tttusb->insync = 0;\n\tttusb->mux_state = 0;\n\n\tfor (i = 0; i < ISO_BUF_COUNT; i++) {\n\t\tint frame_offset = 0;\n\t\tstruct urb *urb = ttusb->iso_urb[i];\n\n\t\turb->dev = ttusb->dev;\n\t\turb->context = ttusb;\n\t\turb->complete = ttusb_iso_irq;\n\t\turb->pipe = ttusb->isoc_in_pipe;\n\t\turb->transfer_flags = URB_ISO_ASAP;\n\t\turb->interval = 1;\n\t\turb->number_of_packets = FRAMES_PER_ISO_BUF;\n\t\turb->transfer_buffer_length =\n\t\t    ISO_FRAME_SIZE * FRAMES_PER_ISO_BUF;\n\t\turb->transfer_buffer = ttusb->iso_buffer + buffer_offset;\n\t\tbuffer_offset += ISO_FRAME_SIZE * FRAMES_PER_ISO_BUF;\n\n\t\tfor (j = 0; j < FRAMES_PER_ISO_BUF; j++) {\n\t\t\turb->iso_frame_desc[j].offset = frame_offset;\n\t\t\turb->iso_frame_desc[j].length = ISO_FRAME_SIZE;\n\t\t\tframe_offset += ISO_FRAME_SIZE;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ISO_BUF_COUNT; i++) {\n\t\tif ((err = usb_submit_urb(ttusb->iso_urb[i], GFP_ATOMIC))) {\n\t\t\tttusb_stop_iso_xfer(ttusb);\n\t\t\tpr_err(\"failed urb submission (%i: err = %i)!\\n\",\n\t\t\t       i, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tttusb->iso_streaming = 1;\n\n\treturn 0;\n}\n\n#ifdef TTUSB_HWSECTIONS\nstatic void ttusb_handle_ts_data(struct dvb_demux_feed *dvbdmxfeed, const u8 * data,\n\t\t\t  int len)\n{\n\tdvbdmxfeed->cb.ts(data, len, 0, 0, &dvbdmxfeed->feed.ts, 0);\n}\n\nstatic void ttusb_handle_sec_data(struct dvb_demux_feed *dvbdmxfeed, const u8 * data,\n\t\t\t   int len)\n{\n\n#error TODO: handle ugly stuff\n\n}\n#endif\n\nstatic int ttusb_start_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct ttusb *ttusb = (struct ttusb *) dvbdmxfeed->demux;\n\tint feed_type = 1;\n\n\tdprintk(\"ttusb_start_feed\\n\");\n\n\tswitch (dvbdmxfeed->type) {\n\tcase DMX_TYPE_TS:\n\t\tbreak;\n\tcase DMX_TYPE_SEC:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (dvbdmxfeed->type == DMX_TYPE_TS) {\n\t\tswitch (dvbdmxfeed->pes_type) {\n\t\tcase DMX_PES_VIDEO:\n\t\tcase DMX_PES_AUDIO:\n\t\tcase DMX_PES_TELETEXT:\n\t\tcase DMX_PES_PCR:\n\t\tcase DMX_PES_OTHER:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n#ifdef TTUSB_HWSECTIONS\n#error TODO: allocate filters\n\tif (dvbdmxfeed->type == DMX_TYPE_TS) {\n\t\tfeed_type = 1;\n\t} else if (dvbdmxfeed->type == DMX_TYPE_SEC) {\n\t\tfeed_type = 2;\n\t}\n#endif\n\n\tttusb_set_channel(ttusb, dvbdmxfeed->index, feed_type, dvbdmxfeed->pid);\n\n\tif (0 == ttusb->running_feed_count++)\n\t\tttusb_start_iso_xfer(ttusb);\n\n\treturn 0;\n}\n\nstatic int ttusb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct ttusb *ttusb = (struct ttusb *) dvbdmxfeed->demux;\n\n\tttusb_del_channel(ttusb, dvbdmxfeed->index);\n\n\tif (--ttusb->running_feed_count == 0)\n\t\tttusb_stop_iso_xfer(ttusb);\n\n\treturn 0;\n}\n\nstatic int ttusb_setup_interfaces(struct ttusb *ttusb)\n{\n\tusb_set_interface(ttusb->dev, 1, 1);\n\n\tttusb->bulk_out_pipe = usb_sndbulkpipe(ttusb->dev, 1);\n\tttusb->bulk_in_pipe = usb_rcvbulkpipe(ttusb->dev, 1);\n\tttusb->isoc_in_pipe = usb_rcvisocpipe(ttusb->dev, 2);\n\n\treturn 0;\n}\n\n#if 0\nstatic u8 stc_firmware[8192];\n\nstatic int stc_open(struct inode *inode, struct file *file)\n{\n\tstruct ttusb *ttusb = file->private_data;\n\tint addr;\n\n\tfor (addr = 0; addr < 8192; addr += 16) {\n\t\tu8 snd_buf[2] = { addr >> 8, addr & 0xFF };\n\t\tttusb_i2c_msg(ttusb, 0x50, snd_buf, 2, stc_firmware + addr,\n\t\t\t      16);\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t stc_read(struct file *file, char *buf, size_t count,\n\t\t loff_t *offset)\n{\n\treturn simple_read_from_buffer(buf, count, offset, stc_firmware, 8192);\n}\n\nstatic int stc_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\n\nstatic const struct file_operations stc_fops = {\n\t.owner = THIS_MODULE,\n\t.read = stc_read,\n\t.open = stc_open,\n\t.release = stc_release,\n};\n#endif\n\nstatic u32 functionality(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\n\n\nstatic int alps_tdmb7_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct ttusb* ttusb = (struct ttusb*) fe->dvb->priv;\n\tu8 data[4];\n\tstruct i2c_msg msg = {.addr=0x61, .flags=0, .buf=data, .len=sizeof(data) };\n\tu32 div;\n\n\tdiv = (p->frequency + 36166667) / 166667;\n\n\tdata[0] = (div >> 8) & 0x7f;\n\tdata[1] = div & 0xff;\n\tdata[2] = ((div >> 10) & 0x60) | 0x85;\n\tdata[3] = p->frequency < 592000000 ? 0x40 : 0x80;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&ttusb->i2c_adap, &msg, 1) != 1) return -EIO;\n\treturn 0;\n}\n\nstatic struct cx22700_config alps_tdmb7_config = {\n\t.demod_address = 0x43,\n};\n\n\n\n\n\nstatic int philips_tdm1316l_tuner_init(struct dvb_frontend* fe)\n{\n\tstruct ttusb* ttusb = (struct ttusb*) fe->dvb->priv;\n\tstatic u8 td1316_init[] = { 0x0b, 0xf5, 0x85, 0xab };\n\tstatic u8 disable_mc44BC374c[] = { 0x1d, 0x74, 0xa0, 0x68 };\n\tstruct i2c_msg tuner_msg = { .addr=0x60, .flags=0, .buf=td1316_init, .len=sizeof(td1316_init) };\n\n\t\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&ttusb->i2c_adap, &tuner_msg, 1) != 1) return -EIO;\n\tmsleep(1);\n\n\t\n\ttuner_msg.addr = 0x65;\n\ttuner_msg.buf = disable_mc44BC374c;\n\ttuner_msg.len = sizeof(disable_mc44BC374c);\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&ttusb->i2c_adap, &tuner_msg, 1) != 1) {\n\t\ti2c_transfer(&ttusb->i2c_adap, &tuner_msg, 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int philips_tdm1316l_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct ttusb* ttusb = (struct ttusb*) fe->dvb->priv;\n\tu8 tuner_buf[4];\n\tstruct i2c_msg tuner_msg = {.addr=0x60, .flags=0, .buf=tuner_buf, .len=sizeof(tuner_buf) };\n\tint tuner_frequency = 0;\n\tu8 band, cp, filter;\n\n\t\n\ttuner_frequency = p->frequency + 36130000;\n\tif (tuner_frequency < 87000000) return -EINVAL;\n\telse if (tuner_frequency < 130000000) cp = 3;\n\telse if (tuner_frequency < 160000000) cp = 5;\n\telse if (tuner_frequency < 200000000) cp = 6;\n\telse if (tuner_frequency < 290000000) cp = 3;\n\telse if (tuner_frequency < 420000000) cp = 5;\n\telse if (tuner_frequency < 480000000) cp = 6;\n\telse if (tuner_frequency < 620000000) cp = 3;\n\telse if (tuner_frequency < 830000000) cp = 5;\n\telse if (tuner_frequency < 895000000) cp = 7;\n\telse return -EINVAL;\n\n\t\n\tif (p->frequency < 49000000)\n\t\treturn -EINVAL;\n\telse if (p->frequency < 159000000)\n\t\tband = 1;\n\telse if (p->frequency < 444000000)\n\t\tband = 2;\n\telse if (p->frequency < 861000000)\n\t\tband = 4;\n\telse return -EINVAL;\n\n\t\n\tswitch (p->bandwidth_hz) {\n\tcase 6000000:\n\t\ttda1004x_writereg(fe, 0x0C, 0);\n\t\tfilter = 0;\n\t\tbreak;\n\n\tcase 7000000:\n\t\ttda1004x_writereg(fe, 0x0C, 0);\n\t\tfilter = 0;\n\t\tbreak;\n\n\tcase 8000000:\n\t\ttda1004x_writereg(fe, 0x0C, 0xFF);\n\t\tfilter = 1;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t\n\t\n\ttuner_frequency = (((p->frequency / 1000) * 6) + 217280) / 1000;\n\n\t\n\ttuner_buf[0] = tuner_frequency >> 8;\n\ttuner_buf[1] = tuner_frequency & 0xff;\n\ttuner_buf[2] = 0xca;\n\ttuner_buf[3] = (cp << 5) | (filter << 3) | band;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&ttusb->i2c_adap, &tuner_msg, 1) != 1)\n\t\treturn -EIO;\n\n\tmsleep(1);\n\treturn 0;\n}\n\nstatic int philips_tdm1316l_request_firmware(struct dvb_frontend* fe, const struct firmware **fw, char* name)\n{\n\tstruct ttusb* ttusb = (struct ttusb*) fe->dvb->priv;\n\n\treturn request_firmware(fw, name, &ttusb->dev->dev);\n}\n\nstatic struct tda1004x_config philips_tdm1316l_config = {\n\n\t.demod_address = 0x8,\n\t.invert = 1,\n\t.invert_oclk = 0,\n\t.request_firmware = philips_tdm1316l_request_firmware,\n};\n\nstatic u8 alps_bsbe1_inittab[] = {\n\t0x01, 0x15,\n\t0x02, 0x30,\n\t0x03, 0x00,\n\t0x04, 0x7d,              \n\t0x05, 0x35,              \n\t0x06, 0x40,              \n\t0x07, 0x00,              \n\t0x08, 0x40,              \n\t0x09, 0x00,              \n\t0x0c, 0x51,              \n\t0x0d, 0x82,              \n\t0x0e, 0x23,              \n\t0x10, 0x3f,             \n\t0x11, 0x84,\n\t0x12, 0xb9,\n\t0x15, 0xc9,             \n\t0x16, 0x00,\n\t0x17, 0x00,\n\t0x18, 0x00,\n\t0x19, 0x00,\n\t0x1a, 0x00,\n\t0x1f, 0x50,\n\t0x20, 0x00,\n\t0x21, 0x00,\n\t0x22, 0x00,\n\t0x23, 0x00,\n\t0x28, 0x00,             \n\t0x29, 0x1e,             \n\t0x2a, 0x14,             \n\t0x2b, 0x0f,             \n\t0x2c, 0x09,             \n\t0x2d, 0x05,             \n\t0x2e, 0x01,\n\t0x31, 0x1f,             \n\t0x32, 0x19,             \n\t0x33, 0xfc,             \n\t0x34, 0x93,             \n\t0x0f, 0x92,\n\t0xff, 0xff\n};\n\nstatic u8 alps_bsru6_inittab[] = {\n\t0x01, 0x15,\n\t0x02, 0x30,\n\t0x03, 0x00,\n\t0x04, 0x7d,\t\t \n\t0x05, 0x35,\t\t \n\t0x06, 0x40,\t\t \n\t0x07, 0x00,\t\t \n\t0x08, 0x40,\t\t \n\t0x09, 0x00,\t\t \n\t0x0c, 0x51,\t\t \n\t0x0d, 0x82,\t\t \n\t0x0e, 0x23,\t\t \n\t0x10, 0x3f,\t\t\n\t0x11, 0x84,\n\t0x12, 0xb9,\n\t0x15, 0xc9,\t\t\n\t0x16, 0x00,\n\t0x17, 0x00,\n\t0x18, 0x00,\n\t0x19, 0x00,\n\t0x1a, 0x00,\n\t0x1f, 0x50,\n\t0x20, 0x00,\n\t0x21, 0x00,\n\t0x22, 0x00,\n\t0x23, 0x00,\n\t0x28, 0x00,\t\t\n\t0x29, 0x1e,\t\t\n\t0x2a, 0x14,\t\t\n\t0x2b, 0x0f,\t\t\n\t0x2c, 0x09,\t\t\n\t0x2d, 0x05,\t\t\n\t0x2e, 0x01,\n\t0x31, 0x1f,\t\t\n\t0x32, 0x19,\t\t\n\t0x33, 0xfc,\t\t\n\t0x34, 0x93,\t\t\n\t0x0f, 0x52,\n\t0xff, 0xff\n};\n\nstatic int alps_stv0299_set_symbol_rate(struct dvb_frontend *fe, u32 srate, u32 ratio)\n{\n\tu8 aclk = 0;\n\tu8 bclk = 0;\n\n\tif (srate < 1500000) {\n\t\taclk = 0xb7;\n\t\tbclk = 0x47;\n\t} else if (srate < 3000000) {\n\t\taclk = 0xb7;\n\t\tbclk = 0x4b;\n\t} else if (srate < 7000000) {\n\t\taclk = 0xb7;\n\t\tbclk = 0x4f;\n\t} else if (srate < 14000000) {\n\t\taclk = 0xb7;\n\t\tbclk = 0x53;\n\t} else if (srate < 30000000) {\n\t\taclk = 0xb6;\n\t\tbclk = 0x53;\n\t} else if (srate < 45000000) {\n\t\taclk = 0xb4;\n\t\tbclk = 0x51;\n\t}\n\n\tstv0299_writereg(fe, 0x13, aclk);\n\tstv0299_writereg(fe, 0x14, bclk);\n\tstv0299_writereg(fe, 0x1f, (ratio >> 16) & 0xff);\n\tstv0299_writereg(fe, 0x20, (ratio >> 8) & 0xff);\n\tstv0299_writereg(fe, 0x21, (ratio) & 0xf0);\n\n\treturn 0;\n}\n\nstatic int philips_tsa5059_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct ttusb* ttusb = (struct ttusb*) fe->dvb->priv;\n\tu8 buf[4];\n\tu32 div;\n\tstruct i2c_msg msg = {.addr = 0x61,.flags = 0,.buf = buf,.len = sizeof(buf) };\n\n\tif ((p->frequency < 950000) || (p->frequency > 2150000))\n\t\treturn -EINVAL;\n\n\tdiv = (p->frequency + (125 - 1)) / 125;\t \n\tbuf[0] = (div >> 8) & 0x7f;\n\tbuf[1] = div & 0xff;\n\tbuf[2] = 0x80 | ((div & 0x18000) >> 10) | 4;\n\tbuf[3] = 0xC4;\n\n\tif (p->frequency > 1530000)\n\t\tbuf[3] = 0xC0;\n\n\t \n\tif (ttusb->revision == TTUSB_REV_2_2)\n\t\tbuf[3] |= 0x20;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&ttusb->i2c_adap, &msg, 1) != 1)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic struct stv0299_config alps_stv0299_config = {\n\t.demod_address = 0x68,\n\t.inittab = alps_bsru6_inittab,\n\t.mclk = 88000000UL,\n\t.invert = 1,\n\t.skip_reinit = 0,\n\t.lock_output = STV0299_LOCKOUTPUT_1,\n\t.volt13_op0_op1 = STV0299_VOLT13_OP1,\n\t.min_delay_ms = 100,\n\t.set_symbol_rate = alps_stv0299_set_symbol_rate,\n};\n\nstatic int ttusb_novas_grundig_29504_491_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct ttusb* ttusb = (struct ttusb*) fe->dvb->priv;\n\tu8 buf[4];\n\tu32 div;\n\tstruct i2c_msg msg = {.addr = 0x61,.flags = 0,.buf = buf,.len = sizeof(buf) };\n\n\tdiv = p->frequency / 125;\n\n\tbuf[0] = (div >> 8) & 0x7f;\n\tbuf[1] = div & 0xff;\n\tbuf[2] = 0x8e;\n\tbuf[3] = 0x00;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&ttusb->i2c_adap, &msg, 1) != 1)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic struct tda8083_config ttusb_novas_grundig_29504_491_config = {\n\n\t.demod_address = 0x68,\n};\n\nstatic int alps_tdbe2_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct ttusb* ttusb = fe->dvb->priv;\n\tu32 div;\n\tu8 data[4];\n\tstruct i2c_msg msg = { .addr = 0x62, .flags = 0, .buf = data, .len = sizeof(data) };\n\n\tdiv = (p->frequency + 35937500 + 31250) / 62500;\n\n\tdata[0] = (div >> 8) & 0x7f;\n\tdata[1] = div & 0xff;\n\tdata[2] = 0x85 | ((div >> 10) & 0x60);\n\tdata[3] = (p->frequency < 174000000 ? 0x88 : p->frequency < 470000000 ? 0x84 : 0x81);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer (&ttusb->i2c_adap, &msg, 1) != 1)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n\nstatic struct ves1820_config alps_tdbe2_config = {\n\t.demod_address = 0x09,\n\t.xin = 57840000UL,\n\t.invert = 1,\n\t.selagc = VES1820_SELAGC_SIGNAMPERR,\n};\n\nstatic u8 read_pwm(struct ttusb* ttusb)\n{\n\tu8 b = 0xff;\n\tu8 pwm;\n\tstruct i2c_msg msg[] = { { .addr = 0x50,.flags = 0,.buf = &b,.len = 1 },\n\t\t\t\t{ .addr = 0x50,.flags = I2C_M_RD,.buf = &pwm,.len = 1} };\n\n\tif ((i2c_transfer(&ttusb->i2c_adap, msg, 2) != 2) || (pwm == 0xff))\n\t\tpwm = 0x48;\n\n\treturn pwm;\n}\n\n\nstatic int dvbc_philips_tdm1316l_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct ttusb *ttusb = (struct ttusb *) fe->dvb->priv;\n\tu8 tuner_buf[5];\n\tstruct i2c_msg tuner_msg = {.addr = 0x60,\n\t\t\t\t    .flags = 0,\n\t\t\t\t    .buf = tuner_buf,\n\t\t\t\t    .len = sizeof(tuner_buf) };\n\tint tuner_frequency = 0;\n\tu8 band, cp, filter;\n\n\t\n\ttuner_frequency = p->frequency;\n\tif      (tuner_frequency <  87000000) {return -EINVAL;}\n\telse if (tuner_frequency < 130000000) {cp = 3; band = 1;}\n\telse if (tuner_frequency < 160000000) {cp = 5; band = 1;}\n\telse if (tuner_frequency < 200000000) {cp = 6; band = 1;}\n\telse if (tuner_frequency < 290000000) {cp = 3; band = 2;}\n\telse if (tuner_frequency < 420000000) {cp = 5; band = 2;}\n\telse if (tuner_frequency < 480000000) {cp = 6; band = 2;}\n\telse if (tuner_frequency < 620000000) {cp = 3; band = 4;}\n\telse if (tuner_frequency < 830000000) {cp = 5; band = 4;}\n\telse if (tuner_frequency < 895000000) {cp = 7; band = 4;}\n\telse {return -EINVAL;}\n\n\t\n\tfilter = 1;\n\n\t\n\t\n\ttuner_frequency = ((p->frequency + 36125000) / 62500);\n\n\t\n\ttuner_buf[0] = tuner_frequency >> 8;\n\ttuner_buf[1] = tuner_frequency & 0xff;\n\ttuner_buf[2] = 0xc8;\n\ttuner_buf[3] = (cp << 5) | (filter << 3) | band;\n\ttuner_buf[4] = 0x80;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&ttusb->i2c_adap, &tuner_msg, 1) != 1) {\n\t\tpr_err(\"dvbc_philips_tdm1316l_pll_set Error 1\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmsleep(50);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&ttusb->i2c_adap, &tuner_msg, 1) != 1) {\n\t\tpr_err(\"dvbc_philips_tdm1316l_pll_set Error 2\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmsleep(1);\n\n\treturn 0;\n}\n\nstatic u8 dvbc_philips_tdm1316l_inittab[] = {\n\t0x80, 0x21,\n\t0x80, 0x20,\n\t0x81, 0x01,\n\t0x81, 0x00,\n\t0x00, 0x09,\n\t0x01, 0x69,\n\t0x03, 0x00,\n\t0x04, 0x00,\n\t0x07, 0x00,\n\t0x08, 0x00,\n\t0x20, 0x00,\n\t0x21, 0x40,\n\t0x22, 0x00,\n\t0x23, 0x00,\n\t0x24, 0x40,\n\t0x25, 0x88,\n\t0x30, 0xff,\n\t0x31, 0x00,\n\t0x32, 0xff,\n\t0x33, 0x00,\n\t0x34, 0x50,\n\t0x35, 0x7f,\n\t0x36, 0x00,\n\t0x37, 0x20,\n\t0x38, 0x00,\n\t0x40, 0x1c,\n\t0x41, 0xff,\n\t0x42, 0x29,\n\t0x43, 0x20,\n\t0x44, 0xff,\n\t0x45, 0x00,\n\t0x46, 0x00,\n\t0x49, 0x04,\n\t0x4a, 0xff,\n\t0x4b, 0x7f,\n\t0x52, 0x30,\n\t0x55, 0xae,\n\t0x56, 0x47,\n\t0x57, 0xe1,\n\t0x58, 0x3a,\n\t0x5a, 0x1e,\n\t0x5b, 0x34,\n\t0x60, 0x00,\n\t0x63, 0x00,\n\t0x64, 0x00,\n\t0x65, 0x00,\n\t0x66, 0x00,\n\t0x67, 0x00,\n\t0x68, 0x00,\n\t0x69, 0x00,\n\t0x6a, 0x02,\n\t0x6b, 0x00,\n\t0x70, 0xff,\n\t0x71, 0x00,\n\t0x72, 0x00,\n\t0x73, 0x00,\n\t0x74, 0x0c,\n\t0x80, 0x00,\n\t0x81, 0x00,\n\t0x82, 0x00,\n\t0x83, 0x00,\n\t0x84, 0x04,\n\t0x85, 0x80,\n\t0x86, 0x24,\n\t0x87, 0x78,\n\t0x88, 0x00,\n\t0x89, 0x00,\n\t0x90, 0x01,\n\t0x91, 0x01,\n\t0xa0, 0x00,\n\t0xa1, 0x00,\n\t0xa2, 0x00,\n\t0xb0, 0x91,\n\t0xb1, 0x0b,\n\t0xc0, 0x4b,\n\t0xc1, 0x00,\n\t0xc2, 0x00,\n\t0xd0, 0x00,\n\t0xd1, 0x00,\n\t0xd2, 0x00,\n\t0xd3, 0x00,\n\t0xd4, 0x00,\n\t0xd5, 0x00,\n\t0xde, 0x00,\n\t0xdf, 0x00,\n\t0x61, 0x38,\n\t0x62, 0x0a,\n\t0x53, 0x13,\n\t0x59, 0x08,\n\t0x55, 0x00,\n\t0x56, 0x40,\n\t0x57, 0x08,\n\t0x58, 0x3d,\n\t0x88, 0x10,\n\t0xa0, 0x00,\n\t0xa0, 0x00,\n\t0xa0, 0x00,\n\t0xa0, 0x04,\n\t0xff, 0xff,\n};\n\nstatic struct stv0297_config dvbc_philips_tdm1316l_config = {\n\t.demod_address = 0x1c,\n\t.inittab = dvbc_philips_tdm1316l_inittab,\n\t.invert = 0,\n};\n\nstatic void frontend_init(struct ttusb* ttusb)\n{\n\tswitch(le16_to_cpu(ttusb->dev->descriptor.idProduct)) {\n\tcase 0x1003: \n\t\t\n\t\tttusb->fe = dvb_attach(stv0299_attach, &alps_stv0299_config, &ttusb->i2c_adap);\n\t\tif (ttusb->fe != NULL) {\n\t\t\tttusb->fe->ops.tuner_ops.set_params = philips_tsa5059_tuner_set_params;\n\n\t\t\tif(ttusb->revision == TTUSB_REV_2_2) { \n\t\t\t\talps_stv0299_config.inittab = alps_bsbe1_inittab;\n\t\t\t\tdvb_attach(lnbp21_attach, ttusb->fe, &ttusb->i2c_adap, 0, 0);\n\t\t\t} else { \n\t\t\t\tttusb->fe->ops.set_voltage = ttusb_set_voltage;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tttusb->fe = dvb_attach(tda8083_attach, &ttusb_novas_grundig_29504_491_config, &ttusb->i2c_adap);\n\t\tif (ttusb->fe != NULL) {\n\t\t\tttusb->fe->ops.tuner_ops.set_params = ttusb_novas_grundig_29504_491_tuner_set_params;\n\t\t\tttusb->fe->ops.set_voltage = ttusb_set_voltage;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 0x1004: \n\t\tttusb->fe = dvb_attach(ves1820_attach, &alps_tdbe2_config, &ttusb->i2c_adap, read_pwm(ttusb));\n\t\tif (ttusb->fe != NULL) {\n\t\t\tttusb->fe->ops.tuner_ops.set_params = alps_tdbe2_tuner_set_params;\n\t\t\tbreak;\n\t\t}\n\n\t\tttusb->fe = dvb_attach(stv0297_attach, &dvbc_philips_tdm1316l_config, &ttusb->i2c_adap);\n\t\tif (ttusb->fe != NULL) {\n\t\t\tttusb->fe->ops.tuner_ops.set_params = dvbc_philips_tdm1316l_tuner_set_params;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 0x1005: \n\t\t\n\t\tttusb->fe = dvb_attach(cx22700_attach, &alps_tdmb7_config, &ttusb->i2c_adap);\n\t\tif (ttusb->fe != NULL) {\n\t\t\tttusb->fe->ops.tuner_ops.set_params = alps_tdmb7_tuner_set_params;\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tttusb->fe = dvb_attach(tda10046_attach, &philips_tdm1316l_config, &ttusb->i2c_adap);\n\t\tif (ttusb->fe != NULL) {\n\t\t\tttusb->fe->ops.tuner_ops.init = philips_tdm1316l_tuner_init;\n\t\t\tttusb->fe->ops.tuner_ops.set_params = philips_tdm1316l_tuner_set_params;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (ttusb->fe == NULL) {\n\t\tpr_err(\"no frontend driver found for device [%04x:%04x]\\n\",\n\t\t       le16_to_cpu(ttusb->dev->descriptor.idVendor),\n\t\t       le16_to_cpu(ttusb->dev->descriptor.idProduct));\n\t} else {\n\t\tif (dvb_register_frontend(&ttusb->adapter, ttusb->fe)) {\n\t\t\tpr_err(\"Frontend registration failed!\\n\");\n\t\t\tdvb_frontend_detach(ttusb->fe);\n\t\t\tttusb->fe = NULL;\n\t\t}\n\t}\n}\n\n\n\nstatic const struct i2c_algorithm ttusb_dec_algo = {\n\t.master_xfer\t= master_xfer,\n\t.functionality\t= functionality,\n};\n\nstatic int ttusb_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *udev;\n\tstruct ttusb *ttusb;\n\tint result;\n\n\tdprintk(\"TTUSB DVB connected\\n\");\n\n\tudev = interface_to_usbdev(intf);\n\n\tif (intf->altsetting->desc.bInterfaceNumber != 1) return -ENODEV;\n\n\tif (!(ttusb = kzalloc(sizeof(struct ttusb), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tttusb->dev = udev;\n\tttusb->c = 0;\n\tttusb->mux_state = 0;\n\tmutex_init(&ttusb->semi2c);\n\n\tmutex_lock(&ttusb->semi2c);\n\n\tmutex_init(&ttusb->semusb);\n\n\tttusb_setup_interfaces(ttusb);\n\n\tresult = ttusb_alloc_iso_urbs(ttusb);\n\tif (result < 0) {\n\t\tdprintk(\"ttusb_alloc_iso_urbs - failed\\n\");\n\t\tmutex_unlock(&ttusb->semi2c);\n\t\tkfree(ttusb);\n\t\treturn result;\n\t}\n\n\tif (ttusb_init_controller(ttusb))\n\t\tpr_err(\"ttusb_init_controller: error\\n\");\n\n\tmutex_unlock(&ttusb->semi2c);\n\n\tresult = dvb_register_adapter(&ttusb->adapter,\n\t\t\t\t      \"Technotrend/Hauppauge Nova-USB\",\n\t\t\t\t      THIS_MODULE, &udev->dev, adapter_nr);\n\tif (result < 0) {\n\t\tttusb_free_iso_urbs(ttusb);\n\t\tkfree(ttusb);\n\t\treturn result;\n\t}\n\tttusb->adapter.priv = ttusb;\n\n\t \n\tmemset(&ttusb->i2c_adap, 0, sizeof(struct i2c_adapter));\n\tstrscpy(ttusb->i2c_adap.name, \"TTUSB DEC\", sizeof(ttusb->i2c_adap.name));\n\n\ti2c_set_adapdata(&ttusb->i2c_adap, ttusb);\n\n\tttusb->i2c_adap.algo              = &ttusb_dec_algo;\n\tttusb->i2c_adap.algo_data         = NULL;\n\tttusb->i2c_adap.dev.parent\t  = &udev->dev;\n\n\tresult = i2c_add_adapter(&ttusb->i2c_adap);\n\tif (result)\n\t\tgoto err_unregister_adapter;\n\n\tmemset(&ttusb->dvb_demux, 0, sizeof(ttusb->dvb_demux));\n\n\tttusb->dvb_demux.dmx.capabilities =\n\t    DMX_TS_FILTERING | DMX_SECTION_FILTERING;\n\tttusb->dvb_demux.priv = NULL;\n#ifdef TTUSB_HWSECTIONS\n\tttusb->dvb_demux.filternum = TTUSB_MAXFILTER;\n#else\n\tttusb->dvb_demux.filternum = 32;\n#endif\n\tttusb->dvb_demux.feednum = TTUSB_MAXCHANNEL;\n\tttusb->dvb_demux.start_feed = ttusb_start_feed;\n\tttusb->dvb_demux.stop_feed = ttusb_stop_feed;\n\tttusb->dvb_demux.write_to_decoder = NULL;\n\n\tresult = dvb_dmx_init(&ttusb->dvb_demux);\n\tif (result < 0) {\n\t\tpr_err(\"dvb_dmx_init failed (errno = %d)\\n\", result);\n\t\tresult = -ENODEV;\n\t\tgoto err_i2c_del_adapter;\n\t}\n\n\tttusb->dmxdev.filternum = ttusb->dvb_demux.filternum;\n\tttusb->dmxdev.demux = &ttusb->dvb_demux.dmx;\n\tttusb->dmxdev.capabilities = 0;\n\n\tresult = dvb_dmxdev_init(&ttusb->dmxdev, &ttusb->adapter);\n\tif (result < 0) {\n\t\tpr_err(\"dvb_dmxdev_init failed (errno = %d)\\n\",\n\t\t       result);\n\t\tresult = -ENODEV;\n\t\tgoto err_release_dmx;\n\t}\n\n\tif (dvb_net_init(&ttusb->adapter, &ttusb->dvbnet, &ttusb->dvb_demux.dmx)) {\n\t\tpr_err(\"dvb_net_init failed!\\n\");\n\t\tresult = -ENODEV;\n\t\tgoto err_release_dmxdev;\n\t}\n\n\tusb_set_intfdata(intf, (void *) ttusb);\n\n\tfrontend_init(ttusb);\n\n\treturn 0;\n\nerr_release_dmxdev:\n\tdvb_dmxdev_release(&ttusb->dmxdev);\nerr_release_dmx:\n\tdvb_dmx_release(&ttusb->dvb_demux);\nerr_i2c_del_adapter:\n\ti2c_del_adapter(&ttusb->i2c_adap);\nerr_unregister_adapter:\n\tdvb_unregister_adapter (&ttusb->adapter);\n\tttusb_free_iso_urbs(ttusb);\n\tkfree(ttusb);\n\treturn result;\n}\n\nstatic void ttusb_disconnect(struct usb_interface *intf)\n{\n\tstruct ttusb *ttusb = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tttusb->disconnecting = 1;\n\n\tttusb_stop_iso_xfer(ttusb);\n\n\tttusb->dvb_demux.dmx.close(&ttusb->dvb_demux.dmx);\n\tdvb_net_release(&ttusb->dvbnet);\n\tdvb_dmxdev_release(&ttusb->dmxdev);\n\tdvb_dmx_release(&ttusb->dvb_demux);\n\tif (ttusb->fe != NULL) {\n\t\tdvb_unregister_frontend(ttusb->fe);\n\t\tdvb_frontend_detach(ttusb->fe);\n\t}\n\ti2c_del_adapter(&ttusb->i2c_adap);\n\tdvb_unregister_adapter(&ttusb->adapter);\n\n\tttusb_free_iso_urbs(ttusb);\n\n\tkfree(ttusb);\n\n\tdprintk(\"TTUSB DVB disconnected\\n\");\n}\n\nstatic const struct usb_device_id ttusb_table[] = {\n\t{USB_DEVICE(0xb48, 0x1003)},\n\t{USB_DEVICE(0xb48, 0x1004)},\n\t{USB_DEVICE(0xb48, 0x1005)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, ttusb_table);\n\nstatic struct usb_driver ttusb_driver = {\n      .name\t\t= \"ttusb\",\n      .probe\t\t= ttusb_probe,\n      .disconnect\t= ttusb_disconnect,\n      .id_table\t\t= ttusb_table,\n};\n\nmodule_usb_driver(ttusb_driver);\n\nMODULE_AUTHOR(\"Holger Waechtler <holger@convergence.de>\");\nMODULE_DESCRIPTION(\"TTUSB DVB Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"ttusb-budget/dspbootcode.bin\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}