{
  "module_name": "flexcop-usb.c",
  "hash_id": "40104fa5cecb7a423a968769af6a69c7b4888c5efc26073431b729609c898283",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/b2c2/flexcop-usb.c",
  "human_readable_source": "\n \n#define FC_LOG_PREFIX \"flexcop_usb\"\n#include \"flexcop-usb.h\"\n#include \"flexcop-common.h\"\n\n \n#define DRIVER_VERSION \"0.1\"\n#define DRIVER_NAME \"Technisat/B2C2 FlexCop II/IIb/III Digital TV USB Driver\"\n#define DRIVER_AUTHOR \"Patrick Boettcher <patrick.boettcher@posteo.de>\"\n\n \n#ifdef CONFIG_DVB_B2C2_FLEXCOP_DEBUG\n#define dprintk(level, args...) \\\n\tdo { if ((debug & (level))) printk(args); } while (0)\n\n#define debug_dump(b, l, method) do {\\\n\tint i; \\\n\tfor (i = 0; i < l; i++) \\\n\t\tmethod(\"%02x \", b[i]); \\\n\tmethod(\"\\n\"); \\\n} while (0)\n\n#define DEBSTATUS \"\"\n#else\n#define dprintk(level, args...) no_printk(args)\n#define debug_dump(b, l, method) do { } while (0)\n#define DEBSTATUS \" (debugging is not enabled)\"\n#endif\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=info,ts=2,ctrl=4,i2c=8,v8mem=16 (or-able)).\" DEBSTATUS);\n#undef DEBSTATUS\n\n#define deb_info(args...) dprintk(0x01, args)\n#define deb_ts(args...) dprintk(0x02, args)\n#define deb_ctrl(args...) dprintk(0x04, args)\n#define deb_i2c(args...) dprintk(0x08, args)\n#define deb_v8(args...) dprintk(0x10, args)\n\n \n#define B2C2_FLEX_PCIOFFSET_TO_INTERNALADDR(usPCI) (u8) \\\n\t(((usPCI >> 2) & 0x07) + ((usPCI >> 4) & 0x70))\n#define B2C2_FLEX_INTERNALADDR_TO_PCIOFFSET(ucAddr) (u16) \\\n\t(((ucAddr & 0x07) << 2) + ((ucAddr & 0x70) << 4))\n\n \nstatic int flexcop_usb_readwrite_dw(struct flexcop_device *fc, u16 wRegOffsPCI, u32 *val, u8 read)\n{\n\tstruct flexcop_usb *fc_usb = fc->bus_specific;\n\tu8 request = read ? B2C2_USB_READ_REG : B2C2_USB_WRITE_REG;\n\tu8 request_type = (read ? USB_DIR_IN : USB_DIR_OUT) | USB_TYPE_VENDOR;\n\tu8 wAddress = B2C2_FLEX_PCIOFFSET_TO_INTERNALADDR(wRegOffsPCI) |\n\t\t(read ? 0x80 : 0);\n\tint ret;\n\n\tmutex_lock(&fc_usb->data_mutex);\n\tif (!read)\n\t\tmemcpy(fc_usb->data, val, sizeof(*val));\n\n\tret = usb_control_msg(fc_usb->udev,\n\t\t\tread ? B2C2_USB_CTRL_PIPE_IN : B2C2_USB_CTRL_PIPE_OUT,\n\t\t\trequest,\n\t\t\trequest_type,  \n\t\t\twAddress,\n\t\t\t0,\n\t\t\tfc_usb->data,\n\t\t\tsizeof(u32),\n\t\t\tB2C2_WAIT_FOR_OPERATION_RDW);\n\n\tif (ret != sizeof(u32)) {\n\t\terr(\"error while %s dword from %d (%d).\", read ? \"reading\" :\n\t\t\t\t\"writing\", wAddress, wRegOffsPCI);\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\n\tif (read && ret >= 0)\n\t\tmemcpy(val, fc_usb->data, sizeof(*val));\n\tmutex_unlock(&fc_usb->data_mutex);\n\n\treturn ret;\n}\n \nstatic int flexcop_usb_v8_memory_req(struct flexcop_usb *fc_usb,\n\t\tflexcop_usb_request_t req, u8 page, u16 wAddress,\n\t\tu8 *pbBuffer, u32 buflen)\n{\n\tu8 request_type = USB_TYPE_VENDOR;\n\tu16 wIndex;\n\tint nWaitTime, pipe, ret;\n\twIndex = page << 8;\n\n\tif (buflen > sizeof(fc_usb->data)) {\n\t\terr(\"Buffer size bigger than max URB control message\\n\");\n\t\treturn -EIO;\n\t}\n\n\tswitch (req) {\n\tcase B2C2_USB_READ_V8_MEM:\n\t\tnWaitTime = B2C2_WAIT_FOR_OPERATION_V8READ;\n\t\trequest_type |= USB_DIR_IN;\n\t\tpipe = B2C2_USB_CTRL_PIPE_IN;\n\t\tbreak;\n\tcase B2C2_USB_WRITE_V8_MEM:\n\t\twIndex |= pbBuffer[0];\n\t\trequest_type |= USB_DIR_OUT;\n\t\tnWaitTime = B2C2_WAIT_FOR_OPERATION_V8WRITE;\n\t\tpipe = B2C2_USB_CTRL_PIPE_OUT;\n\t\tbreak;\n\tcase B2C2_USB_FLASH_BLOCK:\n\t\trequest_type |= USB_DIR_OUT;\n\t\tnWaitTime = B2C2_WAIT_FOR_OPERATION_V8FLASH;\n\t\tpipe = B2C2_USB_CTRL_PIPE_OUT;\n\t\tbreak;\n\tdefault:\n\t\tdeb_info(\"unsupported request for v8_mem_req %x.\\n\", req);\n\t\treturn -EINVAL;\n\t}\n\tdeb_v8(\"v8mem: %02x %02x %04x %04x, len: %d\\n\", request_type, req,\n\t\t\twAddress, wIndex, buflen);\n\n\tmutex_lock(&fc_usb->data_mutex);\n\n\tif ((request_type & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT)\n\t\tmemcpy(fc_usb->data, pbBuffer, buflen);\n\n\tret = usb_control_msg(fc_usb->udev, pipe,\n\t\t\treq,\n\t\t\trequest_type,\n\t\t\twAddress,\n\t\t\twIndex,\n\t\t\tfc_usb->data,\n\t\t\tbuflen,\n\t\t\tnWaitTime);\n\tif (ret != buflen)\n\t\tret = -EIO;\n\n\tif (ret >= 0) {\n\t\tret = 0;\n\t\tif ((request_type & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)\n\t\t\tmemcpy(pbBuffer, fc_usb->data, buflen);\n\t}\n\n\tmutex_unlock(&fc_usb->data_mutex);\n\n\tdebug_dump(pbBuffer, ret, deb_v8);\n\treturn ret;\n}\n\n#define bytes_left_to_read_on_page(paddr, buflen) \\\n\t((V8_MEMORY_PAGE_SIZE - (paddr & V8_MEMORY_PAGE_MASK)) > buflen \\\n\t ? buflen : (V8_MEMORY_PAGE_SIZE - (paddr & V8_MEMORY_PAGE_MASK)))\n\nstatic int flexcop_usb_memory_req(struct flexcop_usb *fc_usb,\n\t\tflexcop_usb_request_t req, flexcop_usb_mem_page_t page_start,\n\t\tu32 addr, int extended, u8 *buf, u32 len)\n{\n\tint i, ret = 0;\n\tu16 wMax;\n\tu32 pagechunk = 0;\n\n\tswitch (req) {\n\tcase B2C2_USB_READ_V8_MEM:\n\t\twMax = USB_MEM_READ_MAX;\n\t\tbreak;\n\tcase B2C2_USB_WRITE_V8_MEM:\n\t\twMax = USB_MEM_WRITE_MAX;\n\t\tbreak;\n\tcase B2C2_USB_FLASH_BLOCK:\n\t\twMax = USB_FLASH_MAX;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < len;) {\n\t\tpagechunk =\n\t\t\twMax < bytes_left_to_read_on_page(addr, len) ?\n\t\t\t\twMax :\n\t\t\t\tbytes_left_to_read_on_page(addr, len);\n\t\tdeb_info(\"%x\\n\",\n\t\t\t(addr & V8_MEMORY_PAGE_MASK) |\n\t\t\t\t(V8_MEMORY_EXTENDED*extended));\n\n\t\tret = flexcop_usb_v8_memory_req(fc_usb, req,\n\t\t\tpage_start + (addr / V8_MEMORY_PAGE_SIZE),\n\t\t\t(addr & V8_MEMORY_PAGE_MASK) |\n\t\t\t\t(V8_MEMORY_EXTENDED*extended),\n\t\t\t&buf[i], pagechunk);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\taddr += pagechunk;\n\t\tlen -= pagechunk;\n\t}\n\treturn 0;\n}\n\nstatic int flexcop_usb_get_mac_addr(struct flexcop_device *fc, int extended)\n{\n\treturn flexcop_usb_memory_req(fc->bus_specific, B2C2_USB_READ_V8_MEM,\n\t\tV8_MEMORY_PAGE_FLASH, 0x1f010, 1,\n\t\tfc->dvb_adapter.proposed_mac, 6);\n}\n\n \nstatic int flexcop_usb_i2c_req(struct flexcop_i2c_adapter *i2c,\n\t\tflexcop_usb_request_t req, flexcop_usb_i2c_function_t func,\n\t\tu8 chipaddr, u8 addr, u8 *buf, u8 buflen)\n{\n\tstruct flexcop_usb *fc_usb = i2c->fc->bus_specific;\n\tu16 wValue, wIndex;\n\tint nWaitTime, pipe, ret;\n\tu8 request_type = USB_TYPE_VENDOR;\n\n\tif (buflen > sizeof(fc_usb->data)) {\n\t\terr(\"Buffer size bigger than max URB control message\\n\");\n\t\treturn -EIO;\n\t}\n\n\tswitch (func) {\n\tcase USB_FUNC_I2C_WRITE:\n\tcase USB_FUNC_I2C_MULTIWRITE:\n\tcase USB_FUNC_I2C_REPEATWRITE:\n\t\t \n\tcase USB_FUNC_I2C_CHECKWRITE:\n\t\tpipe = B2C2_USB_CTRL_PIPE_OUT;\n\t\tnWaitTime = 2000;\n\t\trequest_type |= USB_DIR_OUT;\n\t\tbreak;\n\tcase USB_FUNC_I2C_READ:\n\tcase USB_FUNC_I2C_REPEATREAD:\n\t\tpipe = B2C2_USB_CTRL_PIPE_IN;\n\t\tnWaitTime = 2000;\n\t\trequest_type |= USB_DIR_IN;\n\t\tbreak;\n\tdefault:\n\t\tdeb_info(\"unsupported function for i2c_req %x\\n\", func);\n\t\treturn -EINVAL;\n\t}\n\twValue = (func << 8) | (i2c->port << 4);\n\twIndex = (chipaddr << 8 ) | addr;\n\n\tdeb_i2c(\"i2c %2d: %02x %02x %02x %02x %02x %02x\\n\",\n\t\t\tfunc, request_type, req,\n\t\t\twValue & 0xff, wValue >> 8,\n\t\t\twIndex & 0xff, wIndex >> 8);\n\n\tmutex_lock(&fc_usb->data_mutex);\n\n\tif ((request_type & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT)\n\t\tmemcpy(fc_usb->data, buf, buflen);\n\n\tret = usb_control_msg(fc_usb->udev, pipe,\n\t\t\treq,\n\t\t\trequest_type,\n\t\t\twValue,\n\t\t\twIndex,\n\t\t\tfc_usb->data,\n\t\t\tbuflen,\n\t\t\tnWaitTime);\n\n\tif (ret != buflen)\n\t\tret = -EIO;\n\n\tif (ret >= 0) {\n\t\tret = 0;\n\t\tif ((request_type & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)\n\t\t\tmemcpy(buf, fc_usb->data, buflen);\n\t}\n\n\tmutex_unlock(&fc_usb->data_mutex);\n\n\treturn ret;\n}\n\n \nstatic flexcop_ibi_value flexcop_usb_read_ibi_reg(struct flexcop_device *fc,\n\tflexcop_ibi_register reg)\n{\n\tflexcop_ibi_value val;\n\tval.raw = 0;\n\tflexcop_usb_readwrite_dw(fc, reg, &val.raw, 1);\n\treturn val;\n}\n\nstatic int flexcop_usb_write_ibi_reg(struct flexcop_device *fc,\n\t\tflexcop_ibi_register reg, flexcop_ibi_value val)\n{\n\treturn flexcop_usb_readwrite_dw(fc, reg, &val.raw, 0);\n}\n\nstatic int flexcop_usb_i2c_request(struct flexcop_i2c_adapter *i2c,\n\t\tflexcop_access_op_t op, u8 chipaddr, u8 addr, u8 *buf, u16 len)\n{\n\tif (op == FC_READ)\n\t\treturn flexcop_usb_i2c_req(i2c, B2C2_USB_I2C_REQUEST,\n\t\t\t\tUSB_FUNC_I2C_READ, chipaddr, addr, buf, len);\n\telse\n\t\treturn flexcop_usb_i2c_req(i2c, B2C2_USB_I2C_REQUEST,\n\t\t\t\tUSB_FUNC_I2C_WRITE, chipaddr, addr, buf, len);\n}\n\nstatic void flexcop_usb_process_frame(struct flexcop_usb *fc_usb,\n\tu8 *buffer, int buffer_length)\n{\n\tu8 *b;\n\tint l;\n\n\tdeb_ts(\"tmp_buffer_length=%d, buffer_length=%d\\n\",\n\t\tfc_usb->tmp_buffer_length, buffer_length);\n\n\tif (fc_usb->tmp_buffer_length > 0) {\n\t\tmemcpy(fc_usb->tmp_buffer+fc_usb->tmp_buffer_length, buffer,\n\t\t\t\tbuffer_length);\n\t\tfc_usb->tmp_buffer_length += buffer_length;\n\t\tb = fc_usb->tmp_buffer;\n\t\tl = fc_usb->tmp_buffer_length;\n\t} else {\n\t\tb = buffer;\n\t\tl = buffer_length;\n\t}\n\n\twhile (l >= 190) {\n\t\tif (*b == 0xff) {\n\t\t\tswitch (*(b+1) & 0x03) {\n\t\t\tcase 0x01:  \n\t\t\t\tif (*(b+2) == 0x47)\n\t\t\t\t\tflexcop_pass_dmx_packets(\n\t\t\t\t\t\t\tfc_usb->fc_dev, b+2, 1);\n\t\t\t\telse\n\t\t\t\t\tdeb_ts(\"not ts packet %*ph\\n\", 4, b+2);\n\t\t\t\tb += 190;\n\t\t\t\tl -= 190;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdeb_ts(\"wrong packet type\\n\");\n\t\t\t\tl = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tdeb_ts(\"wrong header\\n\");\n\t\t\tl = 0;\n\t\t}\n\t}\n\n\tif (l > 0)\n\t\tmemcpy(fc_usb->tmp_buffer, b, l);\n\tfc_usb->tmp_buffer_length = l;\n}\n\nstatic void flexcop_usb_urb_complete(struct urb *urb)\n{\n\tstruct flexcop_usb *fc_usb = urb->context;\n\tint i;\n\n\tif (urb->actual_length > 0)\n\t\tdeb_ts(\"urb completed, bufsize: %d actlen; %d\\n\",\n\t\t\turb->transfer_buffer_length, urb->actual_length);\n\n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\tif (urb->iso_frame_desc[i].status < 0) {\n\t\t\terr(\"iso frame descriptor %d has an error: %d\\n\", i,\n\t\t\t\turb->iso_frame_desc[i].status);\n\t\t} else\n\t\t\tif (urb->iso_frame_desc[i].actual_length > 0) {\n\t\t\t\tdeb_ts(\"passed %d bytes to the demux\\n\",\n\t\t\t\t\turb->iso_frame_desc[i].actual_length);\n\n\t\t\t\tflexcop_usb_process_frame(fc_usb,\n\t\t\t\t\turb->transfer_buffer +\n\t\t\t\t\t\turb->iso_frame_desc[i].offset,\n\t\t\t\t\turb->iso_frame_desc[i].actual_length);\n\t\t\t}\n\t\turb->iso_frame_desc[i].status = 0;\n\t\turb->iso_frame_desc[i].actual_length = 0;\n\t}\n\tusb_submit_urb(urb, GFP_ATOMIC);\n}\n\nstatic int flexcop_usb_stream_control(struct flexcop_device *fc, int onoff)\n{\n\t \n\treturn 0;\n}\n\nstatic void flexcop_usb_transfer_exit(struct flexcop_usb *fc_usb)\n{\n\tint i;\n\tfor (i = 0; i < B2C2_USB_NUM_ISO_URB; i++)\n\t\tif (fc_usb->iso_urb[i] != NULL) {\n\t\t\tdeb_ts(\"unlinking/killing urb no. %d\\n\", i);\n\t\t\tusb_kill_urb(fc_usb->iso_urb[i]);\n\t\t\tusb_free_urb(fc_usb->iso_urb[i]);\n\t\t}\n\n\tusb_free_coherent(fc_usb->udev, fc_usb->buffer_size,\n\t\t\t  fc_usb->iso_buffer, fc_usb->dma_addr);\n\n}\n\nstatic int flexcop_usb_transfer_init(struct flexcop_usb *fc_usb)\n{\n\tstruct usb_host_interface *alt = fc_usb->uintf->cur_altsetting;\n\tu16 frame_size;\n\tint bufsize, i, j, ret;\n\tint buffer_offset = 0;\n\n\tframe_size = usb_endpoint_maxp(&alt->endpoint[0].desc);\n\tbufsize = B2C2_USB_NUM_ISO_URB * B2C2_USB_FRAMES_PER_ISO * frame_size;\n\n\tdeb_ts(\"creating %d iso-urbs with %d frames each of %d bytes size = %d.\\n\",\n\t       B2C2_USB_NUM_ISO_URB,\n\t\t\tB2C2_USB_FRAMES_PER_ISO, frame_size, bufsize);\n\n\tfc_usb->iso_buffer = usb_alloc_coherent(fc_usb->udev,\n\t\t\tbufsize, GFP_KERNEL, &fc_usb->dma_addr);\n\tif (fc_usb->iso_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tmemset(fc_usb->iso_buffer, 0, bufsize);\n\tfc_usb->buffer_size = bufsize;\n\n\t \n\tfor (i = 0; i < B2C2_USB_NUM_ISO_URB; i++) {\n\t\tfc_usb->iso_urb[i] = usb_alloc_urb(B2C2_USB_FRAMES_PER_ISO,\n\t\t\tGFP_ATOMIC);\n\t\tif (fc_usb->iso_urb[i] == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto urb_error;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < B2C2_USB_NUM_ISO_URB; i++) {\n\t\tint frame_offset = 0;\n\t\tstruct urb *urb = fc_usb->iso_urb[i];\n\t\tdeb_ts(\"initializing and submitting urb no. %d (buf_offset: %d).\\n\",\n\t\t       i, buffer_offset);\n\n\t\turb->dev = fc_usb->udev;\n\t\turb->context = fc_usb;\n\t\turb->complete = flexcop_usb_urb_complete;\n\t\turb->pipe = B2C2_USB_DATA_PIPE;\n\t\turb->transfer_flags = URB_ISO_ASAP;\n\t\turb->interval = 1;\n\t\turb->number_of_packets = B2C2_USB_FRAMES_PER_ISO;\n\t\turb->transfer_buffer_length = frame_size * B2C2_USB_FRAMES_PER_ISO;\n\t\turb->transfer_buffer = fc_usb->iso_buffer + buffer_offset;\n\n\t\tbuffer_offset += frame_size * B2C2_USB_FRAMES_PER_ISO;\n\t\tfor (j = 0; j < B2C2_USB_FRAMES_PER_ISO; j++) {\n\t\t\tdeb_ts(\"urb no: %d, frame: %d, frame_offset: %d\\n\",\n\t\t\t\t\ti, j, frame_offset);\n\t\t\turb->iso_frame_desc[j].offset = frame_offset;\n\t\t\turb->iso_frame_desc[j].length = frame_size;\n\t\t\tframe_offset += frame_size;\n\t\t}\n\n\t\tif ((ret = usb_submit_urb(fc_usb->iso_urb[i],GFP_ATOMIC))) {\n\t\t\terr(\"submitting urb %d failed with %d.\", i, ret);\n\t\t\tgoto urb_error;\n\t\t}\n\t\tdeb_ts(\"submitted urb no. %d.\\n\", i);\n\t}\n\n\t \n\tflexcop_sram_set_dest(fc_usb->fc_dev, FC_SRAM_DEST_MEDIA |\n\t\t\tFC_SRAM_DEST_NET | FC_SRAM_DEST_CAO | FC_SRAM_DEST_CAI,\n\t\t\tFC_SRAM_DEST_TARGET_WAN_USB);\n\tflexcop_wan_set_speed(fc_usb->fc_dev, FC_WAN_SPEED_8MBITS);\n\tflexcop_sram_ctrl(fc_usb->fc_dev, 1, 1, 1);\n\treturn 0;\n\nurb_error:\n\tflexcop_usb_transfer_exit(fc_usb);\n\treturn ret;\n}\n\nstatic int flexcop_usb_init(struct flexcop_usb *fc_usb)\n{\n\tstruct usb_host_interface *alt;\n\tint ret;\n\n\t \n\tret = usb_set_interface(fc_usb->udev, 0, 1);\n\tif (ret) {\n\t\terr(\"set interface failed.\");\n\t\treturn ret;\n\t}\n\n\talt = fc_usb->uintf->cur_altsetting;\n\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\tif (!usb_endpoint_is_isoc_in(&alt->endpoint[0].desc))\n\t\treturn -ENODEV;\n\n\tswitch (fc_usb->udev->speed) {\n\tcase USB_SPEED_LOW:\n\t\terr(\"cannot handle USB speed because it is too slow.\");\n\t\treturn -ENODEV;\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tinfo(\"running at FULL speed.\");\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tinfo(\"running at HIGH speed.\");\n\t\tbreak;\n\tcase USB_SPEED_UNKNOWN:\n\tdefault:\n\t\terr(\"cannot handle USB speed because it is unknown.\");\n\t\treturn -ENODEV;\n\t}\n\tusb_set_intfdata(fc_usb->uintf, fc_usb);\n\treturn 0;\n}\n\nstatic void flexcop_usb_exit(struct flexcop_usb *fc_usb)\n{\n\tusb_set_intfdata(fc_usb->uintf, NULL);\n}\n\nstatic int flexcop_usb_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct flexcop_usb *fc_usb = NULL;\n\tstruct flexcop_device *fc = NULL;\n\tint ret;\n\n\tif ((fc = flexcop_device_kmalloc(sizeof(struct flexcop_usb))) == NULL) {\n\t\terr(\"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfc_usb = fc->bus_specific;\n\tfc_usb->fc_dev = fc;\n\tmutex_init(&fc_usb->data_mutex);\n\n\tfc->read_ibi_reg  = flexcop_usb_read_ibi_reg;\n\tfc->write_ibi_reg = flexcop_usb_write_ibi_reg;\n\tfc->i2c_request = flexcop_usb_i2c_request;\n\tfc->get_mac_addr = flexcop_usb_get_mac_addr;\n\n\tfc->stream_control = flexcop_usb_stream_control;\n\n\tfc->pid_filtering = 1;\n\tfc->bus_type = FC_USB;\n\n\tfc->dev = &udev->dev;\n\tfc->owner = THIS_MODULE;\n\n\t \n\tfc_usb->udev = udev;\n\tfc_usb->uintf = intf;\n\tif ((ret = flexcop_usb_init(fc_usb)) != 0)\n\t\tgoto err_kfree;\n\n\t \n\tif ((ret = flexcop_device_initialize(fc)) != 0)\n\t\tgoto err_usb_exit;\n\n\t \n\tif ((ret = flexcop_usb_transfer_init(fc_usb)) != 0)\n\t\tgoto err_fc_exit;\n\n\tinfo(\"%s successfully initialized and connected.\", DRIVER_NAME);\n\treturn 0;\n\nerr_fc_exit:\n\tflexcop_device_exit(fc);\nerr_usb_exit:\n\tflexcop_usb_exit(fc_usb);\nerr_kfree:\n\tflexcop_device_kfree(fc);\n\treturn ret;\n}\n\nstatic void flexcop_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct flexcop_usb *fc_usb = usb_get_intfdata(intf);\n\tflexcop_usb_transfer_exit(fc_usb);\n\tflexcop_device_exit(fc_usb->fc_dev);\n\tflexcop_usb_exit(fc_usb);\n\tflexcop_device_kfree(fc_usb->fc_dev);\n\tinfo(\"%s successfully deinitialized and disconnected.\", DRIVER_NAME);\n}\n\nstatic const struct usb_device_id flexcop_usb_table[] = {\n\t{ USB_DEVICE(0x0af7, 0x0101) },\n\t{ }\n};\nMODULE_DEVICE_TABLE (usb, flexcop_usb_table);\n\n \nstatic struct usb_driver flexcop_usb_driver = {\n\t.name\t\t= \"b2c2_flexcop_usb\",\n\t.probe\t\t= flexcop_usb_probe,\n\t.disconnect = flexcop_usb_disconnect,\n\t.id_table\t= flexcop_usb_table,\n};\n\nmodule_usb_driver(flexcop_usb_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_NAME);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}