{
  "module_name": "vp702x-fe.c",
  "hash_id": "c549b0197c4291eea66d20194e99133e742d2e253d00b9a6af9a156d88dc6d38",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/vp702x-fe.c",
  "human_readable_source": "\n \n#include \"vp702x.h\"\n\nstruct vp702x_fe_state {\n\tstruct dvb_frontend fe;\n\tstruct dvb_usb_device *d;\n\n\tstruct dvb_frontend_ops ops;\n\n\tenum fe_sec_voltage voltage;\n\tenum fe_sec_tone_mode tone_mode;\n\n\tu8 lnb_buf[8];\n\n\tu8 lock;\n\tu8 sig;\n\tu8 snr;\n\n\tunsigned long next_status_check;\n\tunsigned long status_check_interval;\n};\n\nstatic int vp702x_fe_refresh_state(struct vp702x_fe_state *st)\n{\n\tstruct vp702x_device_state *dst = st->d->priv;\n\tu8 *buf;\n\n\tif (time_after(jiffies, st->next_status_check)) {\n\t\tmutex_lock(&dst->buf_mutex);\n\t\tbuf = dst->buf;\n\n\t\tvp702x_usb_in_op(st->d, READ_STATUS, 0, 0, buf, 10);\n\t\tst->lock = buf[4];\n\n\t\tvp702x_usb_in_op(st->d, READ_TUNER_REG_REQ, 0x11, 0, buf, 1);\n\t\tst->snr = buf[0];\n\n\t\tvp702x_usb_in_op(st->d, READ_TUNER_REG_REQ, 0x15, 0, buf, 1);\n\t\tst->sig = buf[0];\n\n\t\tmutex_unlock(&dst->buf_mutex);\n\t\tst->next_status_check = jiffies + (st->status_check_interval*HZ)/1000;\n\t}\n\treturn 0;\n}\n\nstatic u8 vp702x_chksum(u8 *buf,int f, int count)\n{\n\tu8 s = 0;\n\tint i;\n\tfor (i = f; i < f+count; i++)\n\t\ts += buf[i];\n\treturn ~s+1;\n}\n\nstatic int vp702x_fe_read_status(struct dvb_frontend *fe,\n\t\t\t\t enum fe_status *status)\n{\n\tstruct vp702x_fe_state *st = fe->demodulator_priv;\n\tvp702x_fe_refresh_state(st);\n\tdeb_fe(\"%s\\n\",__func__);\n\n\tif (st->lock == 0)\n\t\t*status = FE_HAS_LOCK | FE_HAS_SYNC | FE_HAS_VITERBI | FE_HAS_SIGNAL | FE_HAS_CARRIER;\n\telse\n\t\t*status = 0;\n\n\tif (*status & FE_HAS_LOCK)\n\t\tst->status_check_interval = 1000;\n\telse\n\t\tst->status_check_interval = 250;\n\treturn 0;\n}\n\n \nstatic int vp702x_fe_read_ber(struct dvb_frontend* fe, u32 *ber)\n{\n\tstruct vp702x_fe_state *st = fe->demodulator_priv;\n\tvp702x_fe_refresh_state(st);\n\t*ber = 0;\n\treturn 0;\n}\n\n \nstatic int vp702x_fe_read_unc_blocks(struct dvb_frontend* fe, u32 *unc)\n{\n\tstruct vp702x_fe_state *st = fe->demodulator_priv;\n\tvp702x_fe_refresh_state(st);\n\t*unc = 0;\n\treturn 0;\n}\n\nstatic int vp702x_fe_read_signal_strength(struct dvb_frontend* fe, u16 *strength)\n{\n\tstruct vp702x_fe_state *st = fe->demodulator_priv;\n\tvp702x_fe_refresh_state(st);\n\n\t*strength = (st->sig << 8) | st->sig;\n\treturn 0;\n}\n\nstatic int vp702x_fe_read_snr(struct dvb_frontend* fe, u16 *snr)\n{\n\tu8 _snr;\n\tstruct vp702x_fe_state *st = fe->demodulator_priv;\n\tvp702x_fe_refresh_state(st);\n\n\t_snr = (st->snr & 0x1f) * 0xff / 0x1f;\n\t*snr = (_snr << 8) | _snr;\n\treturn 0;\n}\n\nstatic int vp702x_fe_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings *tune)\n{\n\tdeb_fe(\"%s\\n\",__func__);\n\ttune->min_delay_ms = 2000;\n\treturn 0;\n}\n\nstatic int vp702x_fe_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *fep = &fe->dtv_property_cache;\n\tstruct vp702x_fe_state *st = fe->demodulator_priv;\n\tstruct vp702x_device_state *dst = st->d->priv;\n\tu32 freq = fep->frequency/1000;\n\t \n \n\tu64 sr;\n\tu8 *cmd;\n\n\tmutex_lock(&dst->buf_mutex);\n\n\tcmd = dst->buf;\n\tmemset(cmd, 0, 10);\n\n\tcmd[0] = (freq >> 8) & 0x7f;\n\tcmd[1] =  freq       & 0xff;\n\tcmd[2] = 1;  \n\n\tsr = (u64) (fep->symbol_rate/1000) << 20;\n\tdo_div(sr,88000);\n\tcmd[3] = (sr >> 12) & 0xff;\n\tcmd[4] = (sr >> 4)  & 0xff;\n\tcmd[5] = (sr << 4)  & 0xf0;\n\n\tdeb_fe(\"setting frontend to: %u -> %u (%x) LNB-based GHz, symbolrate: %d -> %lu (%lx)\\n\",\n\t\t\tfep->frequency, freq, freq, fep->symbol_rate,\n\t\t\t(unsigned long) sr, (unsigned long) sr);\n\n \n\n\tif (st->voltage == SEC_VOLTAGE_18)\n\t\tcmd[6] |= 0x40;\n\n \n\n\tcmd[7] = vp702x_chksum(cmd,0,7);\n\n\tst->status_check_interval = 250;\n\tst->next_status_check = jiffies;\n\n\tvp702x_usb_inout_op(st->d, cmd, 8, cmd, 10, 100);\n\n\tif (cmd[2] == 0 && cmd[3] == 0)\n\t\tdeb_fe(\"tuning failed.\\n\");\n\telse\n\t\tdeb_fe(\"tuning succeeded.\\n\");\n\n\tmutex_unlock(&dst->buf_mutex);\n\n\treturn 0;\n}\n\nstatic int vp702x_fe_init(struct dvb_frontend *fe)\n{\n\tstruct vp702x_fe_state *st = fe->demodulator_priv;\n\tdeb_fe(\"%s\\n\",__func__);\n\tvp702x_usb_in_op(st->d, RESET_TUNER, 0, 0, NULL, 0);\n\treturn 0;\n}\n\nstatic int vp702x_fe_sleep(struct dvb_frontend *fe)\n{\n\tdeb_fe(\"%s\\n\",__func__);\n\treturn 0;\n}\n\nstatic int vp702x_fe_send_diseqc_msg (struct dvb_frontend* fe,\n\t\t\t\t    struct dvb_diseqc_master_cmd *m)\n{\n\tu8 *cmd;\n\tstruct vp702x_fe_state *st = fe->demodulator_priv;\n\tstruct vp702x_device_state *dst = st->d->priv;\n\n\tdeb_fe(\"%s\\n\",__func__);\n\n\tif (m->msg_len > 4)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dst->buf_mutex);\n\n\tcmd = dst->buf;\n\tcmd[1] = SET_DISEQC_CMD;\n\tcmd[2] = m->msg_len;\n\tmemcpy(&cmd[3], m->msg, m->msg_len);\n\tcmd[7] = vp702x_chksum(cmd, 0, 7);\n\n\tvp702x_usb_inout_op(st->d, cmd, 8, cmd, 10, 100);\n\n\tif (cmd[2] == 0 && cmd[3] == 0)\n\t\tdeb_fe(\"diseqc cmd failed.\\n\");\n\telse\n\t\tdeb_fe(\"diseqc cmd succeeded.\\n\");\n\n\tmutex_unlock(&dst->buf_mutex);\n\n\treturn 0;\n}\n\nstatic int vp702x_fe_send_diseqc_burst(struct dvb_frontend *fe,\n\t\t\t\t       enum fe_sec_mini_cmd burst)\n{\n\tdeb_fe(\"%s\\n\",__func__);\n\treturn 0;\n}\n\nstatic int vp702x_fe_set_tone(struct dvb_frontend *fe,\n\t\t\t      enum fe_sec_tone_mode tone)\n{\n\tstruct vp702x_fe_state *st = fe->demodulator_priv;\n\tstruct vp702x_device_state *dst = st->d->priv;\n\tu8 *buf;\n\n\tdeb_fe(\"%s\\n\",__func__);\n\n\tst->tone_mode = tone;\n\n\tif (tone == SEC_TONE_ON)\n\t\tst->lnb_buf[2] = 0x02;\n\telse\n\t\tst->lnb_buf[2] = 0x00;\n\n\tst->lnb_buf[7] = vp702x_chksum(st->lnb_buf, 0, 7);\n\n\tmutex_lock(&dst->buf_mutex);\n\n\tbuf = dst->buf;\n\tmemcpy(buf, st->lnb_buf, 8);\n\n\tvp702x_usb_inout_op(st->d, buf, 8, buf, 10, 100);\n\tif (buf[2] == 0 && buf[3] == 0)\n\t\tdeb_fe(\"set_tone cmd failed.\\n\");\n\telse\n\t\tdeb_fe(\"set_tone cmd succeeded.\\n\");\n\n\tmutex_unlock(&dst->buf_mutex);\n\n\treturn 0;\n}\n\nstatic int vp702x_fe_set_voltage(struct dvb_frontend *fe,\n\t\t\t\t enum fe_sec_voltage voltage)\n{\n\tstruct vp702x_fe_state *st = fe->demodulator_priv;\n\tstruct vp702x_device_state *dst = st->d->priv;\n\tu8 *buf;\n\tdeb_fe(\"%s\\n\",__func__);\n\n\tst->voltage = voltage;\n\n\tif (voltage != SEC_VOLTAGE_OFF)\n\t\tst->lnb_buf[4] = 0x01;\n\telse\n\t\tst->lnb_buf[4] = 0x00;\n\n\tst->lnb_buf[7] = vp702x_chksum(st->lnb_buf, 0, 7);\n\n\tmutex_lock(&dst->buf_mutex);\n\n\tbuf = dst->buf;\n\tmemcpy(buf, st->lnb_buf, 8);\n\n\tvp702x_usb_inout_op(st->d, buf, 8, buf, 10, 100);\n\tif (buf[2] == 0 && buf[3] == 0)\n\t\tdeb_fe(\"set_voltage cmd failed.\\n\");\n\telse\n\t\tdeb_fe(\"set_voltage cmd succeeded.\\n\");\n\n\tmutex_unlock(&dst->buf_mutex);\n\treturn 0;\n}\n\nstatic void vp702x_fe_release(struct dvb_frontend* fe)\n{\n\tstruct vp702x_fe_state *st = fe->demodulator_priv;\n\tkfree(st);\n}\n\nstatic const struct dvb_frontend_ops vp702x_fe_ops;\n\nstruct dvb_frontend * vp702x_fe_attach(struct dvb_usb_device *d)\n{\n\tstruct vp702x_fe_state *s = kzalloc(sizeof(struct vp702x_fe_state), GFP_KERNEL);\n\tif (s == NULL)\n\t\tgoto error;\n\n\ts->d = d;\n\n\tmemcpy(&s->fe.ops,&vp702x_fe_ops,sizeof(struct dvb_frontend_ops));\n\ts->fe.demodulator_priv = s;\n\n\ts->lnb_buf[1] = SET_LNB_POWER;\n\ts->lnb_buf[3] = 0xff;  \n\n\treturn &s->fe;\nerror:\n\treturn NULL;\n}\n\n\nstatic const struct dvb_frontend_ops vp702x_fe_ops = {\n\t.delsys = { SYS_DVBS },\n\t.info = {\n\t\t.name           = \"Twinhan DST-like frontend (VP7021/VP7020) DVB-S\",\n\t\t.frequency_min_hz       =  950 * MHz,\n\t\t.frequency_max_hz       = 2150 * MHz,\n\t\t.frequency_stepsize_hz  =    1 * MHz,\n\t\t.symbol_rate_min     = 1000000,\n\t\t.symbol_rate_max     = 45000000,\n\t\t.symbol_rate_tolerance = 500,   \n\t\t.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |\n\t\tFE_CAN_QPSK |\n\t\tFE_CAN_FEC_AUTO\n\t},\n\t.release = vp702x_fe_release,\n\n\t.init  = vp702x_fe_init,\n\t.sleep = vp702x_fe_sleep,\n\n\t.set_frontend = vp702x_fe_set_frontend,\n\t.get_tune_settings = vp702x_fe_get_tune_settings,\n\n\t.read_status = vp702x_fe_read_status,\n\t.read_ber = vp702x_fe_read_ber,\n\t.read_signal_strength = vp702x_fe_read_signal_strength,\n\t.read_snr = vp702x_fe_read_snr,\n\t.read_ucblocks = vp702x_fe_read_unc_blocks,\n\n\t.diseqc_send_master_cmd = vp702x_fe_send_diseqc_msg,\n\t.diseqc_send_burst = vp702x_fe_send_diseqc_burst,\n\t.set_tone = vp702x_fe_set_tone,\n\t.set_voltage = vp702x_fe_set_voltage,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}