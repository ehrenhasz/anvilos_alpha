{
  "module_name": "dvb-usb-dvb.c",
  "hash_id": "3ffd65fef1e9cee5441cc6eceb168b9a0fc6a42a19237a8948553dcc02492341",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/dvb-usb-dvb.c",
  "human_readable_source": "\n \n#include \"dvb-usb-common.h\"\n#include <media/media-device.h>\n\n \nstatic int dvb_usb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed, int onoff)\n{\n\tstruct dvb_usb_adapter *adap = dvbdmxfeed->demux->priv;\n\tint newfeedcount, ret;\n\n\tif (adap == NULL)\n\t\treturn -ENODEV;\n\n\tif ((adap->active_fe < 0) ||\n\t    (adap->active_fe >= adap->num_frontends_initialized)) {\n\t\treturn -EINVAL;\n\t}\n\n\tnewfeedcount = adap->feedcount + (onoff ? 1 : -1);\n\n\t \n\tif (newfeedcount == 0) {\n\t\tdeb_ts(\"stop feeding\\n\");\n\t\tusb_urb_kill(&adap->fe_adap[adap->active_fe].stream);\n\n\t\tif (adap->props.fe[adap->active_fe].streaming_ctrl != NULL) {\n\t\t\tret = adap->props.fe[adap->active_fe].streaming_ctrl(adap, 0);\n\t\t\tif (ret < 0) {\n\t\t\t\terr(\"error while stopping stream.\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tadap->feedcount = newfeedcount;\n\n\t \n\tdeb_ts(\"setting pid (%s): %5d %04x at index %d '%s'\\n\",\n\t\tadap->fe_adap[adap->active_fe].pid_filtering ?\n\t\t\"yes\" : \"no\", dvbdmxfeed->pid, dvbdmxfeed->pid,\n\t\tdvbdmxfeed->index, onoff ? \"on\" : \"off\");\n\tif (adap->props.fe[adap->active_fe].caps & DVB_USB_ADAP_HAS_PID_FILTER &&\n\t\tadap->fe_adap[adap->active_fe].pid_filtering &&\n\t\tadap->props.fe[adap->active_fe].pid_filter != NULL)\n\t\tadap->props.fe[adap->active_fe].pid_filter(adap, dvbdmxfeed->index, dvbdmxfeed->pid, onoff);\n\n\t \n\tif (adap->feedcount == onoff && adap->feedcount > 0) {\n\t\tdeb_ts(\"controlling pid parser\\n\");\n\t\tif (adap->props.fe[adap->active_fe].caps & DVB_USB_ADAP_HAS_PID_FILTER &&\n\t\t\tadap->props.fe[adap->active_fe].caps &\n\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF &&\n\t\t\tadap->props.fe[adap->active_fe].pid_filter_ctrl != NULL) {\n\t\t\tret = adap->props.fe[adap->active_fe].pid_filter_ctrl(adap,\n\t\t\t\tadap->fe_adap[adap->active_fe].pid_filtering);\n\t\t\tif (ret < 0) {\n\t\t\t\terr(\"could not handle pid_parser\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tdeb_ts(\"start feeding\\n\");\n\t\tif (adap->props.fe[adap->active_fe].streaming_ctrl != NULL) {\n\t\t\tret = adap->props.fe[adap->active_fe].streaming_ctrl(adap, 1);\n\t\t\tif (ret < 0) {\n\t\t\t\terr(\"error while enabling fifo.\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tdeb_ts(\"submitting all URBs\\n\");\n\t\tusb_urb_submit(&adap->fe_adap[adap->active_fe].stream);\n\t}\n\treturn 0;\n}\n\nstatic int dvb_usb_start_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tdeb_ts(\"start pid: 0x%04x, feedtype: %d\\n\", dvbdmxfeed->pid,\n\t       dvbdmxfeed->type);\n\treturn dvb_usb_ctrl_feed(dvbdmxfeed, 1);\n}\n\nstatic int dvb_usb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tdeb_ts(\"stop pid: 0x%04x, feedtype: %d\\n\", dvbdmxfeed->pid, dvbdmxfeed->type);\n\treturn dvb_usb_ctrl_feed(dvbdmxfeed, 0);\n}\n\nstatic int dvb_usb_media_device_init(struct dvb_usb_adapter *adap)\n{\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tstruct media_device *mdev;\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct usb_device *udev = d->udev;\n\n\tmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\tmedia_device_usb_init(mdev, udev, d->desc->name);\n\n\tdvb_register_media_controller(&adap->dvb_adap, mdev);\n\n\tdev_info(&d->udev->dev, \"media controller created\\n\");\n#endif\n\treturn 0;\n}\n\nstatic int  dvb_usb_media_device_register(struct dvb_usb_adapter *adap)\n{\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\treturn media_device_register(adap->dvb_adap.mdev);\n#else\n\treturn 0;\n#endif\n}\n\nstatic void dvb_usb_media_device_unregister(struct dvb_usb_adapter *adap)\n{\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tif (!adap->dvb_adap.mdev)\n\t\treturn;\n\n\tmutex_lock(&adap->dvb_adap.mdev_lock);\n\n\tmedia_device_unregister(adap->dvb_adap.mdev);\n\tmedia_device_cleanup(adap->dvb_adap.mdev);\n\tkfree(adap->dvb_adap.mdev);\n\tadap->dvb_adap.mdev = NULL;\n\n\tmutex_unlock(&adap->dvb_adap.mdev_lock);\n#endif\n}\n\nint dvb_usb_adapter_dvb_init(struct dvb_usb_adapter *adap, short *adapter_nums)\n{\n\tint i;\n\tint ret = dvb_register_adapter(&adap->dvb_adap, adap->dev->desc->name,\n\t\t\t\t       adap->dev->owner, &adap->dev->udev->dev,\n\t\t\t\t       adapter_nums);\n\n\tif (ret < 0) {\n\t\tdeb_info(\"dvb_register_adapter failed: error %d\", ret);\n\t\tgoto err;\n\t}\n\tadap->dvb_adap.priv = adap;\n\n\tret = dvb_usb_media_device_init(adap);\n\tif (ret < 0) {\n\t\tdeb_info(\"dvb_usb_media_device_init failed: error %d\", ret);\n\t\tgoto err_mc;\n\t}\n\n\tif (adap->dev->props.read_mac_address) {\n\t\tif (adap->dev->props.read_mac_address(adap->dev, adap->dvb_adap.proposed_mac) == 0)\n\t\t\tinfo(\"MAC address: %pM\", adap->dvb_adap.proposed_mac);\n\t\telse\n\t\t\terr(\"MAC address reading failed.\");\n\t}\n\n\n\tadap->demux.dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING;\n\tadap->demux.priv             = adap;\n\n\tadap->demux.filternum        = 0;\n\tfor (i = 0; i < adap->props.num_frontends; i++) {\n\t\tif (adap->demux.filternum < adap->fe_adap[i].max_feed_count)\n\t\t\tadap->demux.filternum = adap->fe_adap[i].max_feed_count;\n\t}\n\tadap->demux.feednum          = adap->demux.filternum;\n\tadap->demux.start_feed       = dvb_usb_start_feed;\n\tadap->demux.stop_feed        = dvb_usb_stop_feed;\n\tadap->demux.write_to_decoder = NULL;\n\tif ((ret = dvb_dmx_init(&adap->demux)) < 0) {\n\t\terr(\"dvb_dmx_init failed: error %d\", ret);\n\t\tgoto err_dmx;\n\t}\n\n\tadap->dmxdev.filternum       = adap->demux.filternum;\n\tadap->dmxdev.demux           = &adap->demux.dmx;\n\tadap->dmxdev.capabilities    = 0;\n\tif ((ret = dvb_dmxdev_init(&adap->dmxdev, &adap->dvb_adap)) < 0) {\n\t\terr(\"dvb_dmxdev_init failed: error %d\", ret);\n\t\tgoto err_dmx_dev;\n\t}\n\n\tif ((ret = dvb_net_init(&adap->dvb_adap, &adap->dvb_net,\n\t\t\t\t\t\t&adap->demux.dmx)) < 0) {\n\t\terr(\"dvb_net_init failed: error %d\", ret);\n\t\tgoto err_net_init;\n\t}\n\n\tadap->state |= DVB_USB_ADAP_STATE_DVB;\n\treturn 0;\n\nerr_net_init:\n\tdvb_dmxdev_release(&adap->dmxdev);\nerr_dmx_dev:\n\tdvb_dmx_release(&adap->demux);\nerr_dmx:\n\tdvb_usb_media_device_unregister(adap);\nerr_mc:\n\tdvb_unregister_adapter(&adap->dvb_adap);\nerr:\n\treturn ret;\n}\n\nint dvb_usb_adapter_dvb_exit(struct dvb_usb_adapter *adap)\n{\n\tif (adap->state & DVB_USB_ADAP_STATE_DVB) {\n\t\tdeb_info(\"unregistering DVB part\\n\");\n\t\tdvb_net_release(&adap->dvb_net);\n\t\tadap->demux.dmx.close(&adap->demux.dmx);\n\t\tdvb_dmxdev_release(&adap->dmxdev);\n\t\tdvb_dmx_release(&adap->demux);\n\t\tdvb_usb_media_device_unregister(adap);\n\t\tdvb_unregister_adapter(&adap->dvb_adap);\n\t\tadap->state &= ~DVB_USB_ADAP_STATE_DVB;\n\t}\n\treturn 0;\n}\n\nstatic int dvb_usb_set_active_fe(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\n\tint ret = (adap->props.frontend_ctrl) ?\n\t\tadap->props.frontend_ctrl(fe, onoff) : 0;\n\n\tif (ret < 0) {\n\t\terr(\"frontend_ctrl request failed\");\n\t\treturn ret;\n\t}\n\tif (onoff)\n\t\tadap->active_fe = fe->id;\n\n\treturn 0;\n}\n\nstatic int dvb_usb_fe_wakeup(struct dvb_frontend *fe)\n{\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\n\tdvb_usb_device_power_ctrl(adap->dev, 1);\n\n\tdvb_usb_set_active_fe(fe, 1);\n\n\tif (adap->fe_adap[fe->id].fe_init)\n\t\tadap->fe_adap[fe->id].fe_init(fe);\n\n\treturn 0;\n}\n\nstatic int dvb_usb_fe_sleep(struct dvb_frontend *fe)\n{\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\n\tif (adap->fe_adap[fe->id].fe_sleep)\n\t\tadap->fe_adap[fe->id].fe_sleep(fe);\n\n\tdvb_usb_set_active_fe(fe, 0);\n\n\treturn dvb_usb_device_power_ctrl(adap->dev, 0);\n}\n\nint dvb_usb_adapter_frontend_init(struct dvb_usb_adapter *adap)\n{\n\tint ret, i;\n\n\t \n\tfor (i = 0; i < adap->props.num_frontends; i++) {\n\n\t\tif (adap->props.fe[i].frontend_attach == NULL) {\n\t\t\terr(\"strange: '%s' #%d,%d doesn't want to attach a frontend.\",\n\t\t\t    adap->dev->desc->name, adap->id, i);\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tret = adap->props.fe[i].frontend_attach(adap);\n\t\tif (ret || adap->fe_adap[i].fe == NULL) {\n\t\t\t \n\t\t\tif (i == 0)\n\t\t\t\terr(\"no frontend was attached by '%s'\",\n\t\t\t\t\tadap->dev->desc->name);\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tadap->fe_adap[i].fe->id = i;\n\n\t\t \n\t\tadap->fe_adap[i].fe_init = adap->fe_adap[i].fe->ops.init;\n\t\tadap->fe_adap[i].fe->ops.init  = dvb_usb_fe_wakeup;\n\t\tadap->fe_adap[i].fe_sleep = adap->fe_adap[i].fe->ops.sleep;\n\t\tadap->fe_adap[i].fe->ops.sleep = dvb_usb_fe_sleep;\n\n\t\tif (dvb_register_frontend(&adap->dvb_adap, adap->fe_adap[i].fe)) {\n\t\t\terr(\"Frontend %d registration failed.\", i);\n\t\t\tdvb_frontend_detach(adap->fe_adap[i].fe);\n\t\t\tadap->fe_adap[i].fe = NULL;\n\t\t\t \n\t\t\tif (i == 0)\n\t\t\t\treturn -ENODEV;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (adap->props.fe[i].tuner_attach != NULL)\n\t\t\tadap->props.fe[i].tuner_attach(adap);\n\n\t\tadap->num_frontends_initialized++;\n\t}\n\n\tret = dvb_create_media_graph(&adap->dvb_adap, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dvb_usb_media_device_register(adap);\n\n\treturn ret;\n}\n\nint dvb_usb_adapter_frontend_exit(struct dvb_usb_adapter *adap)\n{\n\tint i = adap->num_frontends_initialized - 1;\n\n\t \n\tfor (; i >= 0; i--) {\n\t\tif (adap->fe_adap[i].fe != NULL) {\n\t\t\tdvb_unregister_frontend(adap->fe_adap[i].fe);\n\t\t\tdvb_frontend_detach(adap->fe_adap[i].fe);\n\t\t}\n\t}\n\tadap->num_frontends_initialized = 0;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}