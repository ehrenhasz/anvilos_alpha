{
  "module_name": "usb-urb.c",
  "hash_id": "bffab2ddc106571c3b0a90860168c36c14601c15e916bc3824436744f189da1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/usb-urb.c",
  "human_readable_source": "\n \n#include \"dvb-usb-common.h\"\n\n \nstatic void usb_urb_complete(struct urb *urb)\n{\n\tstruct usb_data_stream *stream = urb->context;\n\tint ptype = usb_pipetype(urb->pipe);\n\tint i;\n\tu8 *b;\n\n\tdeb_uxfer(\"'%s' urb completed. status: %d, length: %d/%d, pack_num: %d, errors: %d\\n\",\n\t\tptype == PIPE_ISOCHRONOUS ? \"isoc\" : \"bulk\",\n\t\turb->status,urb->actual_length,urb->transfer_buffer_length,\n\t\turb->number_of_packets,urb->error_count);\n\n\tswitch (urb->status) {\n\t\tcase 0:          \n\t\tcase -ETIMEDOUT:     \n\t\t\tbreak;\n\t\tcase -ECONNRESET:    \n\t\tcase -ENOENT:\n\t\tcase -ESHUTDOWN:\n\t\t\treturn;\n\t\tdefault:         \n\t\t\tdeb_ts(\"urb completion error %d.\\n\", urb->status);\n\t\t\tbreak;\n\t}\n\n\tb = (u8 *) urb->transfer_buffer;\n\tswitch (ptype) {\n\t\tcase PIPE_ISOCHRONOUS:\n\t\t\tfor (i = 0; i < urb->number_of_packets; i++) {\n\n\t\t\t\tif (urb->iso_frame_desc[i].status != 0)\n\t\t\t\t\tdeb_ts(\"iso frame descriptor has an error: %d\\n\",urb->iso_frame_desc[i].status);\n\t\t\t\telse if (urb->iso_frame_desc[i].actual_length > 0)\n\t\t\t\t\tstream->complete(stream, b + urb->iso_frame_desc[i].offset, urb->iso_frame_desc[i].actual_length);\n\n\t\t\t\turb->iso_frame_desc[i].status = 0;\n\t\t\t\turb->iso_frame_desc[i].actual_length = 0;\n\t\t\t}\n\t\t\tdebug_dump(b,20,deb_uxfer);\n\t\t\tbreak;\n\t\tcase PIPE_BULK:\n\t\t\tif (urb->actual_length > 0)\n\t\t\t\tstream->complete(stream, b, urb->actual_length);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr(\"unknown endpoint type in completion handler.\");\n\t\t\treturn;\n\t}\n\tusb_submit_urb(urb,GFP_ATOMIC);\n}\n\nint usb_urb_kill(struct usb_data_stream *stream)\n{\n\tint i;\n\tfor (i = 0; i < stream->urbs_submitted; i++) {\n\t\tdeb_ts(\"killing URB no. %d.\\n\",i);\n\n\t\t \n\t\tusb_kill_urb(stream->urb_list[i]);\n\t}\n\tstream->urbs_submitted = 0;\n\treturn 0;\n}\n\nint usb_urb_submit(struct usb_data_stream *stream)\n{\n\tint i,ret;\n\tfor (i = 0; i < stream->urbs_initialized; i++) {\n\t\tdeb_ts(\"submitting URB no. %d\\n\",i);\n\t\tif ((ret = usb_submit_urb(stream->urb_list[i],GFP_ATOMIC))) {\n\t\t\terr(\"could not submit URB no. %d - get them all back\",i);\n\t\t\tusb_urb_kill(stream);\n\t\t\treturn ret;\n\t\t}\n\t\tstream->urbs_submitted++;\n\t}\n\treturn 0;\n}\n\nstatic int usb_free_stream_buffers(struct usb_data_stream *stream)\n{\n\tif (stream->state & USB_STATE_URB_BUF) {\n\t\twhile (stream->buf_num) {\n\t\t\tstream->buf_num--;\n\t\t\tdeb_mem(\"freeing buffer %d\\n\",stream->buf_num);\n\t\t\tusb_free_coherent(stream->udev, stream->buf_size,\n\t\t\t\t\t  stream->buf_list[stream->buf_num],\n\t\t\t\t\t  stream->dma_addr[stream->buf_num]);\n\t\t}\n\t}\n\n\tstream->state &= ~USB_STATE_URB_BUF;\n\n\treturn 0;\n}\n\nstatic int usb_allocate_stream_buffers(struct usb_data_stream *stream, int num, unsigned long size)\n{\n\tstream->buf_num = 0;\n\tstream->buf_size = size;\n\n\tdeb_mem(\"all in all I will use %lu bytes for streaming\\n\",num*size);\n\n\tfor (stream->buf_num = 0; stream->buf_num < num; stream->buf_num++) {\n\t\tdeb_mem(\"allocating buffer %d\\n\",stream->buf_num);\n\t\tif (( stream->buf_list[stream->buf_num] =\n\t\t\t\t\tusb_alloc_coherent(stream->udev, size, GFP_KERNEL,\n\t\t\t\t\t&stream->dma_addr[stream->buf_num]) ) == NULL) {\n\t\t\tdeb_mem(\"not enough memory for urb-buffer allocation.\\n\");\n\t\t\tusb_free_stream_buffers(stream);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdeb_mem(\"buffer %d: %p (dma: %Lu)\\n\",\n\t\t\tstream->buf_num,\nstream->buf_list[stream->buf_num], (long long)stream->dma_addr[stream->buf_num]);\n\t\tmemset(stream->buf_list[stream->buf_num],0,size);\n\t\tstream->state |= USB_STATE_URB_BUF;\n\t}\n\tdeb_mem(\"allocation successful\\n\");\n\n\treturn 0;\n}\n\nstatic int usb_bulk_urb_init(struct usb_data_stream *stream)\n{\n\tint i, j;\n\n\tif ((i = usb_allocate_stream_buffers(stream,stream->props.count,\n\t\t\t\t\tstream->props.u.bulk.buffersize)) < 0)\n\t\treturn i;\n\n\t \n\tfor (i = 0; i < stream->props.count; i++) {\n\t\tstream->urb_list[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!stream->urb_list[i]) {\n\t\t\tdeb_mem(\"not enough memory for urb_alloc_urb!.\\n\");\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tusb_free_urb(stream->urb_list[j]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tusb_fill_bulk_urb( stream->urb_list[i], stream->udev,\n\t\t\t\tusb_rcvbulkpipe(stream->udev,stream->props.endpoint),\n\t\t\t\tstream->buf_list[i],\n\t\t\t\tstream->props.u.bulk.buffersize,\n\t\t\t\tusb_urb_complete, stream);\n\n\t\tstream->urb_list[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\t\tstream->urb_list[i]->transfer_dma = stream->dma_addr[i];\n\t\tstream->urbs_initialized++;\n\t}\n\treturn 0;\n}\n\nstatic int usb_isoc_urb_init(struct usb_data_stream *stream)\n{\n\tint i,j;\n\n\tif ((i = usb_allocate_stream_buffers(stream,stream->props.count,\n\t\t\t\t\tstream->props.u.isoc.framesize*stream->props.u.isoc.framesperurb)) < 0)\n\t\treturn i;\n\n\t \n\tfor (i = 0; i < stream->props.count; i++) {\n\t\tstruct urb *urb;\n\t\tint frame_offset = 0;\n\n\t\tstream->urb_list[i] = usb_alloc_urb(stream->props.u.isoc.framesperurb, GFP_KERNEL);\n\t\tif (!stream->urb_list[i]) {\n\t\t\tdeb_mem(\"not enough memory for urb_alloc_urb!\\n\");\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tusb_free_urb(stream->urb_list[j]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\turb = stream->urb_list[i];\n\n\t\turb->dev = stream->udev;\n\t\turb->context = stream;\n\t\turb->complete = usb_urb_complete;\n\t\turb->pipe = usb_rcvisocpipe(stream->udev,stream->props.endpoint);\n\t\turb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\n\t\turb->interval = stream->props.u.isoc.interval;\n\t\turb->number_of_packets = stream->props.u.isoc.framesperurb;\n\t\turb->transfer_buffer_length = stream->buf_size;\n\t\turb->transfer_buffer = stream->buf_list[i];\n\t\turb->transfer_dma = stream->dma_addr[i];\n\n\t\tfor (j = 0; j < stream->props.u.isoc.framesperurb; j++) {\n\t\t\turb->iso_frame_desc[j].offset = frame_offset;\n\t\t\turb->iso_frame_desc[j].length = stream->props.u.isoc.framesize;\n\t\t\tframe_offset += stream->props.u.isoc.framesize;\n\t\t}\n\n\t\tstream->urbs_initialized++;\n\t}\n\treturn 0;\n}\n\nint usb_urb_init(struct usb_data_stream *stream, struct usb_data_stream_properties *props)\n{\n\tif (stream == NULL || props == NULL)\n\t\treturn -EINVAL;\n\n\tmemcpy(&stream->props, props, sizeof(*props));\n\n\tusb_clear_halt(stream->udev,usb_rcvbulkpipe(stream->udev,stream->props.endpoint));\n\n\tif (stream->complete == NULL) {\n\t\terr(\"there is no data callback - this doesn't make sense.\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (stream->props.type) {\n\t\tcase USB_BULK:\n\t\t\treturn usb_bulk_urb_init(stream);\n\t\tcase USB_ISOC:\n\t\t\treturn usb_isoc_urb_init(stream);\n\t\tdefault:\n\t\t\terr(\"unknown URB-type for data transfer.\");\n\t\t\treturn -EINVAL;\n\t}\n}\n\nint usb_urb_exit(struct usb_data_stream *stream)\n{\n\tint i;\n\n\tusb_urb_kill(stream);\n\n\tfor (i = 0; i < stream->urbs_initialized; i++) {\n\t\tif (stream->urb_list[i] != NULL) {\n\t\t\tdeb_mem(\"freeing URB no. %d.\\n\",i);\n\t\t\t \n\t\t\tusb_free_urb(stream->urb_list[i]);\n\t\t}\n\t}\n\tstream->urbs_initialized = 0;\n\n\tusb_free_stream_buffers(stream);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}