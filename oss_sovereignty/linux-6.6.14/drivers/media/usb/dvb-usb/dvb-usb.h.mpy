{
  "module_name": "dvb-usb.h",
  "hash_id": "b21a3408c5fb9fcefe72ec6a4e6028a5516d7ead8288bf8f89083e177932a503",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/dvb-usb.h",
  "human_readable_source": " \n \n#ifndef __DVB_USB_H__\n#define __DVB_USB_H__\n\n#include <linux/input.h>\n#include <linux/usb.h>\n#include <linux/firmware.h>\n#include <linux/mutex.h>\n#include <media/rc-core.h>\n\n#include <media/dvb_frontend.h>\n#include <media/dvb_demux.h>\n#include <media/dvb_net.h>\n#include <media/dmxdev.h>\n\n#include \"dvb-pll.h\"\n\n#include <media/dvb-usb-ids.h>\n\n \n#ifdef CONFIG_DVB_USB_DEBUG\n#define dprintk(var, level, args...) \\\n\t    do { if (((var) & (level))) { printk(args); } } while (0)\n\n#define debug_dump(b, l, func) {\\\n\tint loop_; \\\n\tfor (loop_ = 0; loop_ < (l); loop_++) \\\n\t\tfunc(\"%02x \", b[loop_]); \\\n\tfunc(\"\\n\");\\\n}\n#define DVB_USB_DEBUG_STATUS\n#else\n#define dprintk(var, level, args...) no_printk(args)\n#define debug_dump(b, l, func) do { } while (0)\n\n#define DVB_USB_DEBUG_STATUS \" (debugging is not enabled)\"\n\n#endif\n\n \n#ifndef DVB_USB_LOG_PREFIX\n #define DVB_USB_LOG_PREFIX \"dvb-usb (please define a log prefix)\"\n#endif\n\n#undef err\n#define err(format, arg...)  printk(KERN_ERR     DVB_USB_LOG_PREFIX \": \" format \"\\n\" , ## arg)\n#undef info\n#define info(format, arg...) printk(KERN_INFO    DVB_USB_LOG_PREFIX \": \" format \"\\n\" , ## arg)\n#undef warn\n#define warn(format, arg...) printk(KERN_WARNING DVB_USB_LOG_PREFIX \": \" format \"\\n\" , ## arg)\n\n \nstruct dvb_usb_device_description {\n\tconst char *name;\n\n#define DVB_USB_ID_MAX_NUM 15\n\tstruct usb_device_id *cold_ids[DVB_USB_ID_MAX_NUM];\n\tstruct usb_device_id *warm_ids[DVB_USB_ID_MAX_NUM];\n};\n\nstatic inline u8 rc5_custom(struct rc_map_table *key)\n{\n\treturn (key->scancode >> 8) & 0xff;\n}\n\nstatic inline u8 rc5_data(struct rc_map_table *key)\n{\n\treturn key->scancode & 0xff;\n}\n\nstatic inline u16 rc5_scan(struct rc_map_table *key)\n{\n\treturn key->scancode & 0xffff;\n}\n\nstruct dvb_usb_device;\nstruct dvb_usb_adapter;\nstruct usb_data_stream;\n\n \nstruct usb_data_stream_properties {\n#define USB_BULK  1\n#define USB_ISOC  2\n\tint type;\n\tint count;\n\tint endpoint;\n\n\tunion {\n\t\tstruct {\n\t\t\tint buffersize;  \n\t\t} bulk;\n\t\tstruct {\n\t\t\tint framesperurb;\n\t\t\tint framesize;\n\t\t\tint interval;\n\t\t} isoc;\n\t} u;\n};\n\n \nstruct dvb_usb_adapter_fe_properties {\n#define DVB_USB_ADAP_HAS_PID_FILTER               0x01\n#define DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF 0x02\n#define DVB_USB_ADAP_NEED_PID_FILTERING           0x04\n#define DVB_USB_ADAP_RECEIVES_204_BYTE_TS         0x08\n#define DVB_USB_ADAP_RECEIVES_RAW_PAYLOAD         0x10\n\tint caps;\n\tint pid_filter_count;\n\n\tint (*streaming_ctrl)  (struct dvb_usb_adapter *, int);\n\tint (*pid_filter_ctrl) (struct dvb_usb_adapter *, int);\n\tint (*pid_filter)      (struct dvb_usb_adapter *, int, u16, int);\n\n\tint (*frontend_attach) (struct dvb_usb_adapter *);\n\tint (*tuner_attach)    (struct dvb_usb_adapter *);\n\n\tstruct usb_data_stream_properties stream;\n\n\tint size_of_priv;\n};\n\n#define MAX_NO_OF_FE_PER_ADAP 3\nstruct dvb_usb_adapter_properties {\n\tint size_of_priv;\n\n\tint (*frontend_ctrl)   (struct dvb_frontend *, int);\n\n\tint num_frontends;\n\tstruct dvb_usb_adapter_fe_properties fe[MAX_NO_OF_FE_PER_ADAP];\n};\n\n \nstruct dvb_rc_legacy {\n \n#define REMOTE_NO_KEY_PRESSED      0x00\n#define REMOTE_KEY_PRESSED         0x01\n#define REMOTE_KEY_REPEAT          0x02\n\tstruct rc_map_table  *rc_map_table;\n\tint rc_map_size;\n\tint (*rc_query) (struct dvb_usb_device *, u32 *, int *);\n\tint rc_interval;\n};\n\n \nstruct dvb_rc {\n\tchar *rc_codes;\n\tu64 protocol;\n\tu64 allowed_protos;\n\tenum rc_driver_type driver_type;\n\tint (*change_protocol)(struct rc_dev *dev, u64 *rc_proto);\n\tchar *module_name;\n\tint (*rc_query) (struct dvb_usb_device *d);\n\tint rc_interval;\n\tbool bulk_mode;\t\t\t\t \n\tu32 scancode_mask;\n};\n\n \nenum dvb_usb_mode {\n\tDVB_RC_LEGACY,\n\tDVB_RC_CORE,\n};\n\n \nstruct dvb_usb_device_properties {\n#define MAX_NO_OF_ADAPTER_PER_DEVICE 2\n#define DVB_USB_IS_AN_I2C_ADAPTER            0x01\n\tint caps;\n\n#define DEVICE_SPECIFIC 0\n#define CYPRESS_AN2135  1\n#define CYPRESS_AN2235  2\n#define CYPRESS_FX2     3\n\tint        usb_ctrl;\n\tint        (*download_firmware) (struct usb_device *, const struct firmware *);\n\tconst char *firmware;\n\tint        no_reconnect;\n\n\tint size_of_priv;\n\tint (*priv_init)(struct dvb_usb_device *);\n\tvoid (*priv_destroy)(struct dvb_usb_device *);\n\n\tint num_adapters;\n\tstruct dvb_usb_adapter_properties adapter[MAX_NO_OF_ADAPTER_PER_DEVICE];\n\n\tint (*power_ctrl)       (struct dvb_usb_device *, int);\n\tint (*read_mac_address) (struct dvb_usb_device *, u8 []);\n\tint (*identify_state)(struct usb_device *udev,\n\t\t\t      const struct dvb_usb_device_properties *props,\n\t\t\t      const struct dvb_usb_device_description **desc,\n\t\t\t      int *cold);\n\n\tstruct {\n\t\tenum dvb_usb_mode mode;\t \n\t\tstruct dvb_rc_legacy legacy;\n\t\tstruct dvb_rc core;\n\t} rc;\n\n\tstruct i2c_algorithm *i2c_algo;\n\n\tint generic_bulk_ctrl_endpoint;\n\tint generic_bulk_ctrl_endpoint_response;\n\n\tint num_device_descs;\n\tstruct dvb_usb_device_description devices[12];\n};\n\n \nstruct usb_data_stream {\n#define MAX_NO_URBS_FOR_DATA_STREAM 10\n\tstruct usb_device                 *udev;\n\tstruct usb_data_stream_properties  props;\n\n#define USB_STATE_INIT    0x00\n#define USB_STATE_URB_BUF 0x01\n\tint state;\n\n\tvoid (*complete) (struct usb_data_stream *, u8 *, size_t);\n\n\tstruct urb    *urb_list[MAX_NO_URBS_FOR_DATA_STREAM];\n\tint            buf_num;\n\tunsigned long  buf_size;\n\tu8            *buf_list[MAX_NO_URBS_FOR_DATA_STREAM];\n\tdma_addr_t     dma_addr[MAX_NO_URBS_FOR_DATA_STREAM];\n\n\tint urbs_initialized;\n\tint urbs_submitted;\n\n\tvoid *user_priv;\n};\n\n \nstruct dvb_usb_fe_adapter {\n\tstruct dvb_frontend *fe;\n\n\tint (*fe_init)  (struct dvb_frontend *);\n\tint (*fe_sleep) (struct dvb_frontend *);\n\n\tstruct usb_data_stream stream;\n\n\tint pid_filtering;\n\tint max_feed_count;\n\n\tvoid *priv;\n};\n\n \nstruct dvb_usb_adapter {\n\tstruct dvb_usb_device *dev;\n\tstruct dvb_usb_adapter_properties props;\n\n#define DVB_USB_ADAP_STATE_INIT 0x000\n#define DVB_USB_ADAP_STATE_DVB  0x001\n\tint state;\n\n\tu8  id;\n\n\tint feedcount;\n\n\t \n\tstruct dvb_adapter   dvb_adap;\n\tstruct dmxdev        dmxdev;\n\tstruct dvb_demux     demux;\n\tstruct dvb_net       dvb_net;\n\n\tstruct dvb_usb_fe_adapter fe_adap[MAX_NO_OF_FE_PER_ADAP];\n\tint active_fe;\n\tint num_frontends_initialized;\n\n\tvoid *priv;\n};\n\n \nstruct dvb_usb_device {\n\tstruct dvb_usb_device_properties props;\n\tconst struct dvb_usb_device_description *desc;\n\n\tstruct usb_device *udev;\n\n#define DVB_USB_STATE_INIT        0x000\n#define DVB_USB_STATE_I2C         0x001\n#define DVB_USB_STATE_DVB         0x002\n#define DVB_USB_STATE_REMOTE      0x004\n\tint state;\n\n\tint powered;\n\n\t \n\tstruct mutex data_mutex;\n\tstruct mutex usb_mutex;\n\n\t \n\tstruct mutex i2c_mutex;\n\tstruct i2c_adapter i2c_adap;\n\n\tint                    num_adapters_initialized;\n\tstruct dvb_usb_adapter adapter[MAX_NO_OF_ADAPTER_PER_DEVICE];\n\n\t \n\tstruct rc_dev *rc_dev;\n\tstruct input_dev *input_dev;\n\tchar rc_phys[64];\n\tstruct delayed_work rc_query_work;\n\tu32 last_event;\n\tint last_state;\n\n\tstruct module *owner;\n\n\tvoid *priv;\n};\n\nextern int dvb_usb_device_init(struct usb_interface *,\n\t\t\t       const struct dvb_usb_device_properties *,\n\t\t\t       struct module *, struct dvb_usb_device **,\n\t\t\t       short *adapter_nums);\nextern void dvb_usb_device_exit(struct usb_interface *);\n\n \nextern int __must_check\ndvb_usb_generic_rw(struct dvb_usb_device *, u8 *, u16, u8 *, u16, int);\nextern int __must_check\ndvb_usb_generic_write(struct dvb_usb_device *, u8 *, u16);\n\n \nint dvb_usb_nec_rc_key_to_event(struct dvb_usb_device *d, u8 keybuf[5],\n\t\t\t\tu32 *event, int *state);\n\n \nstruct hexline {\n\tu8 len;\n\tu32 addr;\n\tu8 type;\n\tu8 data[255];\n\tu8 chk;\n};\nextern int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type);\nextern int dvb_usb_get_hexline(const struct firmware *fw, struct hexline *hx, int *pos);\n\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}