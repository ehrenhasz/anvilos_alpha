{
  "module_name": "az6027.c",
  "hash_id": "1dfadb83df7777d069f409ea90aaf3f8d9eab84d1ee136e349b6e9765ef16679",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/az6027.c",
  "human_readable_source": "\n \n#include \"az6027.h\"\n\n#include \"stb0899_drv.h\"\n#include \"stb0899_reg.h\"\n#include \"stb0899_cfg.h\"\n\n#include \"stb6100.h\"\n#include \"stb6100_cfg.h\"\n#include <media/dvb_ca_en50221.h>\n\nint dvb_usb_az6027_debug;\nmodule_param_named(debug, dvb_usb_az6027_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=info,xfer=2,rc=4 (or-able)).\" DVB_USB_DEBUG_STATUS);\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstruct az6027_device_state {\n\tstruct dvb_ca_en50221 ca;\n\tstruct mutex ca_mutex;\n\tu8 power_state;\n};\n\nstatic const struct stb0899_s1_reg az6027_stb0899_s1_init_1[] = {\n\n\t \n\t{ STB0899_DEV_ID\t\t, 0x30 },\n\t{ STB0899_DISCNTRL1\t\t, 0x32 },\n\t{ STB0899_DISCNTRL2\t\t, 0x80 },\n\t{ STB0899_DISRX_ST0\t\t, 0x04 },\n\t{ STB0899_DISRX_ST1\t\t, 0x00 },\n\t{ STB0899_DISPARITY\t\t, 0x00 },\n\t{ STB0899_DISSTATUS\t\t, 0x20 },\n\t{ STB0899_DISF22\t\t, 0x99 },\n\t{ STB0899_DISF22RX\t\t, 0xa8 },\n\t \n\t{ STB0899_ACRPRESC\t\t, 0x11 },\n\t{ STB0899_ACRDIV1\t\t, 0x0a },\n\t{ STB0899_ACRDIV2\t\t, 0x05 },\n\t{ STB0899_DACR1\t\t\t, 0x00 },\n\t{ STB0899_DACR2\t\t\t, 0x00 },\n\t{ STB0899_OUTCFG\t\t, 0x00 },\n\t{ STB0899_MODECFG\t\t, 0x00 },\n\t{ STB0899_IRQSTATUS_3\t\t, 0xfe },\n\t{ STB0899_IRQSTATUS_2\t\t, 0x03 },\n\t{ STB0899_IRQSTATUS_1\t\t, 0x7c },\n\t{ STB0899_IRQSTATUS_0\t\t, 0xf4 },\n\t{ STB0899_IRQMSK_3\t\t, 0xf3 },\n\t{ STB0899_IRQMSK_2\t\t, 0xfc },\n\t{ STB0899_IRQMSK_1\t\t, 0xff },\n\t{ STB0899_IRQMSK_0\t\t, 0xff },\n\t{ STB0899_IRQCFG\t\t, 0x00 },\n\t{ STB0899_I2CCFG\t\t, 0x88 },\n\t{ STB0899_I2CRPT\t\t, 0x58 },\n\t{ STB0899_IOPVALUE5\t\t, 0x00 },\n\t{ STB0899_IOPVALUE4\t\t, 0x33 },\n\t{ STB0899_IOPVALUE3\t\t, 0x6d },\n\t{ STB0899_IOPVALUE2\t\t, 0x90 },\n\t{ STB0899_IOPVALUE1\t\t, 0x60 },\n\t{ STB0899_IOPVALUE0\t\t, 0x00 },\n\t{ STB0899_GPIO00CFG\t\t, 0x82 },\n\t{ STB0899_GPIO01CFG\t\t, 0x82 },\n\t{ STB0899_GPIO02CFG\t\t, 0x82 },\n\t{ STB0899_GPIO03CFG\t\t, 0x82 },\n\t{ STB0899_GPIO04CFG\t\t, 0x82 },\n\t{ STB0899_GPIO05CFG\t\t, 0x82 },\n\t{ STB0899_GPIO06CFG\t\t, 0x82 },\n\t{ STB0899_GPIO07CFG\t\t, 0x82 },\n\t{ STB0899_GPIO08CFG\t\t, 0x82 },\n\t{ STB0899_GPIO09CFG\t\t, 0x82 },\n\t{ STB0899_GPIO10CFG\t\t, 0x82 },\n\t{ STB0899_GPIO11CFG\t\t, 0x82 },\n\t{ STB0899_GPIO12CFG\t\t, 0x82 },\n\t{ STB0899_GPIO13CFG\t\t, 0x82 },\n\t{ STB0899_GPIO14CFG\t\t, 0x82 },\n\t{ STB0899_GPIO15CFG\t\t, 0x82 },\n\t{ STB0899_GPIO16CFG\t\t, 0x82 },\n\t{ STB0899_GPIO17CFG\t\t, 0x82 },\n\t{ STB0899_GPIO18CFG\t\t, 0x82 },\n\t{ STB0899_GPIO19CFG\t\t, 0x82 },\n\t{ STB0899_GPIO20CFG\t\t, 0x82 },\n\t{ STB0899_SDATCFG\t\t, 0xb8 },\n\t{ STB0899_SCLTCFG\t\t, 0xba },\n\t{ STB0899_AGCRFCFG\t\t, 0x1c },  \n\t{ STB0899_GPIO22\t\t, 0x82 },  \n\t{ STB0899_GPIO21\t\t, 0x91 },  \n\t{ STB0899_DIRCLKCFG\t\t, 0x82 },\n\t{ STB0899_CLKOUT27CFG\t\t, 0x7e },\n\t{ STB0899_STDBYCFG\t\t, 0x82 },\n\t{ STB0899_CS0CFG\t\t, 0x82 },\n\t{ STB0899_CS1CFG\t\t, 0x82 },\n\t{ STB0899_DISEQCOCFG\t\t, 0x20 },\n\t{ STB0899_GPIO32CFG\t\t, 0x82 },\n\t{ STB0899_GPIO33CFG\t\t, 0x82 },\n\t{ STB0899_GPIO34CFG\t\t, 0x82 },\n\t{ STB0899_GPIO35CFG\t\t, 0x82 },\n\t{ STB0899_GPIO36CFG\t\t, 0x82 },\n\t{ STB0899_GPIO37CFG\t\t, 0x82 },\n\t{ STB0899_GPIO38CFG\t\t, 0x82 },\n\t{ STB0899_GPIO39CFG\t\t, 0x82 },\n\t{ STB0899_NCOARSE\t\t, 0x17 },  \n\t{ STB0899_SYNTCTRL\t\t, 0x02 },  \n\t{ STB0899_FILTCTRL\t\t, 0x00 },\n\t{ STB0899_SYSCTRL\t\t, 0x01 },\n\t{ STB0899_STOPCLK1\t\t, 0x20 },\n\t{ STB0899_STOPCLK2\t\t, 0x00 },\n\t{ STB0899_INTBUFSTATUS\t\t, 0x00 },\n\t{ STB0899_INTBUFCTRL\t\t, 0x0a },\n\t{ 0xffff\t\t\t, 0xff },\n};\n\nstatic const struct stb0899_s1_reg az6027_stb0899_s1_init_3[] = {\n\t{ STB0899_DEMOD\t\t\t, 0x00 },\n\t{ STB0899_RCOMPC\t\t, 0xc9 },\n\t{ STB0899_AGC1CN\t\t, 0x01 },\n\t{ STB0899_AGC1REF\t\t, 0x10 },\n\t{ STB0899_RTC\t\t\t, 0x23 },\n\t{ STB0899_TMGCFG\t\t, 0x4e },\n\t{ STB0899_AGC2REF\t\t, 0x34 },\n\t{ STB0899_TLSR\t\t\t, 0x84 },\n\t{ STB0899_CFD\t\t\t, 0xf7 },\n\t{ STB0899_ACLC\t\t\t, 0x87 },\n\t{ STB0899_BCLC\t\t\t, 0x94 },\n\t{ STB0899_EQON\t\t\t, 0x41 },\n\t{ STB0899_LDT\t\t\t, 0xf1 },\n\t{ STB0899_LDT2\t\t\t, 0xe3 },\n\t{ STB0899_EQUALREF\t\t, 0xb4 },\n\t{ STB0899_TMGRAMP\t\t, 0x10 },\n\t{ STB0899_TMGTHD\t\t, 0x30 },\n\t{ STB0899_IDCCOMP\t\t, 0xfd },\n\t{ STB0899_QDCCOMP\t\t, 0xff },\n\t{ STB0899_POWERI\t\t, 0x0c },\n\t{ STB0899_POWERQ\t\t, 0x0f },\n\t{ STB0899_RCOMP\t\t\t, 0x6c },\n\t{ STB0899_AGCIQIN\t\t, 0x80 },\n\t{ STB0899_AGC2I1\t\t, 0x06 },\n\t{ STB0899_AGC2I2\t\t, 0x00 },\n\t{ STB0899_TLIR\t\t\t, 0x30 },\n\t{ STB0899_RTF\t\t\t, 0x7f },\n\t{ STB0899_DSTATUS\t\t, 0x00 },\n\t{ STB0899_LDI\t\t\t, 0xbc },\n\t{ STB0899_CFRM\t\t\t, 0xea },\n\t{ STB0899_CFRL\t\t\t, 0x31 },\n\t{ STB0899_NIRM\t\t\t, 0x2b },\n\t{ STB0899_NIRL\t\t\t, 0x80 },\n\t{ STB0899_ISYMB\t\t\t, 0x1d },\n\t{ STB0899_QSYMB\t\t\t, 0xa6 },\n\t{ STB0899_SFRH\t\t\t, 0x2f },\n\t{ STB0899_SFRM\t\t\t, 0x68 },\n\t{ STB0899_SFRL\t\t\t, 0x40 },\n\t{ STB0899_SFRUPH\t\t, 0x2f },\n\t{ STB0899_SFRUPM\t\t, 0x68 },\n\t{ STB0899_SFRUPL\t\t, 0x40 },\n\t{ STB0899_EQUAI1\t\t, 0x02 },\n\t{ STB0899_EQUAQ1\t\t, 0xff },\n\t{ STB0899_EQUAI2\t\t, 0x04 },\n\t{ STB0899_EQUAQ2\t\t, 0x05 },\n\t{ STB0899_EQUAI3\t\t, 0x02 },\n\t{ STB0899_EQUAQ3\t\t, 0xfd },\n\t{ STB0899_EQUAI4\t\t, 0x03 },\n\t{ STB0899_EQUAQ4\t\t, 0x07 },\n\t{ STB0899_EQUAI5\t\t, 0x08 },\n\t{ STB0899_EQUAQ5\t\t, 0xf5 },\n\t{ STB0899_DSTATUS2\t\t, 0x00 },\n\t{ STB0899_VSTATUS\t\t, 0x00 },\n\t{ STB0899_VERROR\t\t, 0x86 },\n\t{ STB0899_IQSWAP\t\t, 0x2a },\n\t{ STB0899_ECNT1M\t\t, 0x00 },\n\t{ STB0899_ECNT1L\t\t, 0x00 },\n\t{ STB0899_ECNT2M\t\t, 0x00 },\n\t{ STB0899_ECNT2L\t\t, 0x00 },\n\t{ STB0899_ECNT3M\t\t, 0x0a },\n\t{ STB0899_ECNT3L\t\t, 0xad },\n\t{ STB0899_FECAUTO1\t\t, 0x06 },\n\t{ STB0899_FECM\t\t\t, 0x01 },\n\t{ STB0899_VTH12\t\t\t, 0xb0 },\n\t{ STB0899_VTH23\t\t\t, 0x7a },\n\t{ STB0899_VTH34\t\t\t, 0x58 },\n\t{ STB0899_VTH56\t\t\t, 0x38 },\n\t{ STB0899_VTH67\t\t\t, 0x34 },\n\t{ STB0899_VTH78\t\t\t, 0x24 },\n\t{ STB0899_PRVIT\t\t\t, 0xff },\n\t{ STB0899_VITSYNC\t\t, 0x19 },\n\t{ STB0899_RSULC\t\t\t, 0xb1 },  \n\t{ STB0899_TSULC\t\t\t, 0x42 },\n\t{ STB0899_RSLLC\t\t\t, 0x41 },\n\t{ STB0899_TSLPL\t\t\t, 0x12 },\n\t{ STB0899_TSCFGH\t\t, 0x0c },\n\t{ STB0899_TSCFGM\t\t, 0x00 },\n\t{ STB0899_TSCFGL\t\t, 0x00 },\n\t{ STB0899_TSOUT\t\t\t, 0x69 },  \n\t{ STB0899_RSSYNCDEL\t\t, 0x00 },\n\t{ STB0899_TSINHDELH\t\t, 0x02 },\n\t{ STB0899_TSINHDELM\t\t, 0x00 },\n\t{ STB0899_TSINHDELL\t\t, 0x00 },\n\t{ STB0899_TSLLSTKM\t\t, 0x1b },\n\t{ STB0899_TSLLSTKL\t\t, 0xb3 },\n\t{ STB0899_TSULSTKM\t\t, 0x00 },\n\t{ STB0899_TSULSTKL\t\t, 0x00 },\n\t{ STB0899_PCKLENUL\t\t, 0xbc },\n\t{ STB0899_PCKLENLL\t\t, 0xcc },\n\t{ STB0899_RSPCKLEN\t\t, 0xbd },\n\t{ STB0899_TSSTATUS\t\t, 0x90 },\n\t{ STB0899_ERRCTRL1\t\t, 0xb6 },\n\t{ STB0899_ERRCTRL2\t\t, 0x95 },\n\t{ STB0899_ERRCTRL3\t\t, 0x8d },\n\t{ STB0899_DMONMSK1\t\t, 0x27 },\n\t{ STB0899_DMONMSK0\t\t, 0x03 },\n\t{ STB0899_DEMAPVIT\t\t, 0x5c },\n\t{ STB0899_PLPARM\t\t, 0x19 },\n\t{ STB0899_PDELCTRL\t\t, 0x48 },\n\t{ STB0899_PDELCTRL2\t\t, 0x00 },\n\t{ STB0899_BBHCTRL1\t\t, 0x00 },\n\t{ STB0899_BBHCTRL2\t\t, 0x00 },\n\t{ STB0899_HYSTTHRESH\t\t, 0x77 },\n\t{ STB0899_MATCSTM\t\t, 0x00 },\n\t{ STB0899_MATCSTL\t\t, 0x00 },\n\t{ STB0899_UPLCSTM\t\t, 0x00 },\n\t{ STB0899_UPLCSTL\t\t, 0x00 },\n\t{ STB0899_DFLCSTM\t\t, 0x00 },\n\t{ STB0899_DFLCSTL\t\t, 0x00 },\n\t{ STB0899_SYNCCST\t\t, 0x00 },\n\t{ STB0899_SYNCDCSTM\t\t, 0x00 },\n\t{ STB0899_SYNCDCSTL\t\t, 0x00 },\n\t{ STB0899_ISI_ENTRY\t\t, 0x00 },\n\t{ STB0899_ISI_BIT_EN\t\t, 0x00 },\n\t{ STB0899_MATSTRM\t\t, 0xf0 },\n\t{ STB0899_MATSTRL\t\t, 0x02 },\n\t{ STB0899_UPLSTRM\t\t, 0x45 },\n\t{ STB0899_UPLSTRL\t\t, 0x60 },\n\t{ STB0899_DFLSTRM\t\t, 0xe3 },\n\t{ STB0899_DFLSTRL\t\t, 0x00 },\n\t{ STB0899_SYNCSTR\t\t, 0x47 },\n\t{ STB0899_SYNCDSTRM\t\t, 0x05 },\n\t{ STB0899_SYNCDSTRL\t\t, 0x18 },\n\t{ STB0899_CFGPDELSTATUS1\t, 0x19 },\n\t{ STB0899_CFGPDELSTATUS2\t, 0x2b },\n\t{ STB0899_BBFERRORM\t\t, 0x00 },\n\t{ STB0899_BBFERRORL\t\t, 0x01 },\n\t{ STB0899_UPKTERRORM\t\t, 0x00 },\n\t{ STB0899_UPKTERRORL\t\t, 0x00 },\n\t{ 0xffff\t\t\t, 0xff },\n};\n\n\n\nstatic struct stb0899_config az6027_stb0899_config = {\n\t.init_dev\t\t= az6027_stb0899_s1_init_1,\n\t.init_s2_demod\t\t= stb0899_s2_init_2,\n\t.init_s1_demod\t\t= az6027_stb0899_s1_init_3,\n\t.init_s2_fec\t\t= stb0899_s2_init_4,\n\t.init_tst\t\t= stb0899_s1_init_5,\n\n\t.demod_address\t\t= 0xd0,  \n\n\t.xtal_freq\t\t= 27000000,\n\t.inversion\t\t= IQ_SWAP_ON,\n\n\t.lo_clk\t\t\t= 76500000,\n\t.hi_clk\t\t\t= 99000000,\n\n\t.esno_ave\t\t= STB0899_DVBS2_ESNO_AVE,\n\t.esno_quant\t\t= STB0899_DVBS2_ESNO_QUANT,\n\t.avframes_coarse\t= STB0899_DVBS2_AVFRAMES_COARSE,\n\t.avframes_fine\t\t= STB0899_DVBS2_AVFRAMES_FINE,\n\t.miss_threshold\t\t= STB0899_DVBS2_MISS_THRESHOLD,\n\t.uwp_threshold_acq\t= STB0899_DVBS2_UWP_THRESHOLD_ACQ,\n\t.uwp_threshold_track\t= STB0899_DVBS2_UWP_THRESHOLD_TRACK,\n\t.uwp_threshold_sof\t= STB0899_DVBS2_UWP_THRESHOLD_SOF,\n\t.sof_search_timeout\t= STB0899_DVBS2_SOF_SEARCH_TIMEOUT,\n\n\t.btr_nco_bits\t\t= STB0899_DVBS2_BTR_NCO_BITS,\n\t.btr_gain_shift_offset\t= STB0899_DVBS2_BTR_GAIN_SHIFT_OFFSET,\n\t.crl_nco_bits\t\t= STB0899_DVBS2_CRL_NCO_BITS,\n\t.ldpc_max_iter\t\t= STB0899_DVBS2_LDPC_MAX_ITER,\n\n\t.tuner_get_frequency\t= stb6100_get_frequency,\n\t.tuner_set_frequency\t= stb6100_set_frequency,\n\t.tuner_set_bandwidth\t= stb6100_set_bandwidth,\n\t.tuner_get_bandwidth\t= stb6100_get_bandwidth,\n\t.tuner_set_rfsiggain\t= NULL,\n};\n\nstatic struct stb6100_config az6027_stb6100_config = {\n\t.tuner_address\t= 0xc0,\n\t.refclock\t= 27000000,\n};\n\n\n \nstatic int az6027_usb_in_op(struct dvb_usb_device *d, u8 req,\n\t\t\t    u16 value, u16 index, u8 *b, int blen)\n{\n\tint ret = -1;\n\tif (mutex_lock_interruptible(&d->usb_mutex))\n\t\treturn -EAGAIN;\n\n\tret = usb_control_msg(d->udev,\n\t\t\t      usb_rcvctrlpipe(d->udev, 0),\n\t\t\t      req,\n\t\t\t      USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t      value,\n\t\t\t      index,\n\t\t\t      b,\n\t\t\t      blen,\n\t\t\t      2000);\n\n\tif (ret < 0) {\n\t\twarn(\"usb in operation failed. (%d)\", ret);\n\t\tret = -EIO;\n\t} else\n\t\tret = 0;\n\n\tdeb_xfer(\"in: req. %02x, val: %04x, ind: %04x, buffer: \", req, value, index);\n\tdebug_dump(b, blen, deb_xfer);\n\n\tmutex_unlock(&d->usb_mutex);\n\treturn ret;\n}\n\nstatic int az6027_usb_out_op(struct dvb_usb_device *d,\n\t\t\t     u8 req,\n\t\t\t     u16 value,\n\t\t\t     u16 index,\n\t\t\t     u8 *b,\n\t\t\t     int blen)\n{\n\tint ret;\n\n\tdeb_xfer(\"out: req. %02x, val: %04x, ind: %04x, buffer: \", req, value, index);\n\tdebug_dump(b, blen, deb_xfer);\n\n\tif (mutex_lock_interruptible(&d->usb_mutex))\n\t\treturn -EAGAIN;\n\n\tret = usb_control_msg(d->udev,\n\t\t\t      usb_sndctrlpipe(d->udev, 0),\n\t\t\t      req,\n\t\t\t      USB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t      value,\n\t\t\t      index,\n\t\t\t      b,\n\t\t\t      blen,\n\t\t\t      2000);\n\n\tif (ret != blen) {\n\t\twarn(\"usb out operation failed. (%d)\", ret);\n\t\tmutex_unlock(&d->usb_mutex);\n\t\treturn -EIO;\n\t} else{\n\t\tmutex_unlock(&d->usb_mutex);\n\t\treturn 0;\n\t}\n}\n\nstatic int az6027_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\n{\n\tint ret;\n\tu8 req;\n\tu16 value;\n\tu16 index;\n\tint blen;\n\n\tdeb_info(\"%s %d\", __func__, onoff);\n\n\treq = 0xBC;\n\tvalue = onoff;\n\tindex = 0;\n\tblen = 0;\n\n\tret = az6027_usb_out_op(adap->dev, req, value, index, NULL, blen);\n\tif (ret != 0)\n\t\twarn(\"usb out operation failed. (%d)\", ret);\n\n\treturn ret;\n}\n\n \nstatic struct rc_map_table rc_map_az6027_table[] = {\n\t{ 0x01, KEY_1 },\n\t{ 0x02, KEY_2 },\n};\n\n \nstatic int az6027_rc_query(struct dvb_usb_device *d, u32 *event, int *state)\n{\n\t*state = REMOTE_NO_KEY_PRESSED;\n\treturn 0;\n}\n\n \n\nstatic int az6027_ci_read_attribute_mem(struct dvb_ca_en50221 *ca,\n\t\t\t\t\tint slot,\n\t\t\t\t\tint address)\n{\n\tstruct dvb_usb_device *d = ca->data;\n\tstruct az6027_device_state *state = d->priv;\n\n\tint ret;\n\tu8 req;\n\tu16 value;\n\tu16 index;\n\tint blen;\n\tu8 *b;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\tb = kmalloc(12, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&state->ca_mutex);\n\n\treq = 0xC1;\n\tvalue = address;\n\tindex = 0;\n\tblen = 1;\n\n\tret = az6027_usb_in_op(d, req, value, index, b, blen);\n\tif (ret < 0) {\n\t\twarn(\"usb in operation failed. (%d)\", ret);\n\t\tret = -EINVAL;\n\t} else {\n\t\tret = b[0];\n\t}\n\n\tmutex_unlock(&state->ca_mutex);\n\tkfree(b);\n\treturn ret;\n}\n\nstatic int az6027_ci_write_attribute_mem(struct dvb_ca_en50221 *ca,\n\t\t\t\t\t int slot,\n\t\t\t\t\t int address,\n\t\t\t\t\t u8 value)\n{\n\tstruct dvb_usb_device *d = ca->data;\n\tstruct az6027_device_state *state = d->priv;\n\n\tint ret;\n\tu8 req;\n\tu16 value1;\n\tu16 index;\n\tint blen;\n\n\tdeb_info(\"%s %d\", __func__, slot);\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&state->ca_mutex);\n\treq = 0xC2;\n\tvalue1 = address;\n\tindex = value;\n\tblen = 0;\n\n\tret = az6027_usb_out_op(d, req, value1, index, NULL, blen);\n\tif (ret != 0)\n\t\twarn(\"usb out operation failed. (%d)\", ret);\n\n\tmutex_unlock(&state->ca_mutex);\n\treturn ret;\n}\n\nstatic int az6027_ci_read_cam_control(struct dvb_ca_en50221 *ca,\n\t\t\t\t      int slot,\n\t\t\t\t      u8 address)\n{\n\tstruct dvb_usb_device *d = ca->data;\n\tstruct az6027_device_state *state = d->priv;\n\n\tint ret;\n\tu8 req;\n\tu16 value;\n\tu16 index;\n\tint blen;\n\tu8 *b;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\tb = kmalloc(12, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&state->ca_mutex);\n\n\treq = 0xC3;\n\tvalue = address;\n\tindex = 0;\n\tblen = 2;\n\n\tret = az6027_usb_in_op(d, req, value, index, b, blen);\n\tif (ret < 0) {\n\t\twarn(\"usb in operation failed. (%d)\", ret);\n\t\tret = -EINVAL;\n\t} else {\n\t\tif (b[0] == 0)\n\t\t\twarn(\"Read CI IO error\");\n\n\t\tret = b[1];\n\t\tdeb_info(\"read cam data = %x from 0x%x\", b[1], value);\n\t}\n\n\tmutex_unlock(&state->ca_mutex);\n\tkfree(b);\n\treturn ret;\n}\n\nstatic int az6027_ci_write_cam_control(struct dvb_ca_en50221 *ca,\n\t\t\t\t       int slot,\n\t\t\t\t       u8 address,\n\t\t\t\t       u8 value)\n{\n\tstruct dvb_usb_device *d = ca->data;\n\tstruct az6027_device_state *state = d->priv;\n\n\tint ret;\n\tu8 req;\n\tu16 value1;\n\tu16 index;\n\tint blen;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&state->ca_mutex);\n\treq = 0xC4;\n\tvalue1 = address;\n\tindex = value;\n\tblen = 0;\n\n\tret = az6027_usb_out_op(d, req, value1, index, NULL, blen);\n\tif (ret != 0) {\n\t\twarn(\"usb out operation failed. (%d)\", ret);\n\t\tgoto failed;\n\t}\n\nfailed:\n\tmutex_unlock(&state->ca_mutex);\n\treturn ret;\n}\n\nstatic int CI_CamReady(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct dvb_usb_device *d = ca->data;\n\n\tint ret;\n\tu8 req;\n\tu16 value;\n\tu16 index;\n\tint blen;\n\tu8 *b;\n\n\tb = kmalloc(12, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\n\treq = 0xC8;\n\tvalue = 0;\n\tindex = 0;\n\tblen = 1;\n\n\tret = az6027_usb_in_op(d, req, value, index, b, blen);\n\tif (ret < 0) {\n\t\twarn(\"usb in operation failed. (%d)\", ret);\n\t\tret = -EIO;\n\t} else{\n\t\tret = b[0];\n\t}\n\tkfree(b);\n\treturn ret;\n}\n\nstatic int az6027_ci_slot_reset(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct dvb_usb_device *d = ca->data;\n\tstruct az6027_device_state *state = d->priv;\n\n\tint ret, i;\n\tu8 req;\n\tu16 value;\n\tu16 index;\n\tint blen;\n\n\tmutex_lock(&state->ca_mutex);\n\n\treq = 0xC6;\n\tvalue = 1;\n\tindex = 0;\n\tblen = 0;\n\n\tret = az6027_usb_out_op(d, req, value, index, NULL, blen);\n\tif (ret != 0) {\n\t\twarn(\"usb out operation failed. (%d)\", ret);\n\t\tgoto failed;\n\t}\n\n\tmsleep(500);\n\treq = 0xC6;\n\tvalue = 0;\n\tindex = 0;\n\tblen = 0;\n\n\tret = az6027_usb_out_op(d, req, value, index, NULL, blen);\n\tif (ret != 0) {\n\t\twarn(\"usb out operation failed. (%d)\", ret);\n\t\tgoto failed;\n\t}\n\n\tfor (i = 0; i < 15; i++) {\n\t\tmsleep(100);\n\n\t\tif (CI_CamReady(ca, slot)) {\n\t\t\tdeb_info(\"CAM Ready\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tmsleep(5000);\n\nfailed:\n\tmutex_unlock(&state->ca_mutex);\n\treturn ret;\n}\n\nstatic int az6027_ci_slot_shutdown(struct dvb_ca_en50221 *ca, int slot)\n{\n\treturn 0;\n}\n\nstatic int az6027_ci_slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct dvb_usb_device *d = ca->data;\n\tstruct az6027_device_state *state = d->priv;\n\n\tint ret;\n\tu8 req;\n\tu16 value;\n\tu16 index;\n\tint blen;\n\n\tdeb_info(\"%s\", __func__);\n\tmutex_lock(&state->ca_mutex);\n\treq = 0xC7;\n\tvalue = 1;\n\tindex = 0;\n\tblen = 0;\n\n\tret = az6027_usb_out_op(d, req, value, index, NULL, blen);\n\tif (ret != 0) {\n\t\twarn(\"usb out operation failed. (%d)\", ret);\n\t\tgoto failed;\n\t}\n\nfailed:\n\tmutex_unlock(&state->ca_mutex);\n\treturn ret;\n}\n\nstatic int az6027_ci_poll_slot_status(struct dvb_ca_en50221 *ca, int slot, int open)\n{\n\tstruct dvb_usb_device *d = ca->data;\n\tstruct az6027_device_state *state = d->priv;\n\tint ret;\n\tu8 req;\n\tu16 value;\n\tu16 index;\n\tint blen;\n\tu8 *b;\n\n\tb = kmalloc(12, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\tmutex_lock(&state->ca_mutex);\n\n\treq = 0xC5;\n\tvalue = 0;\n\tindex = 0;\n\tblen = 1;\n\n\tret = az6027_usb_in_op(d, req, value, index, b, blen);\n\tif (ret < 0) {\n\t\twarn(\"usb in operation failed. (%d)\", ret);\n\t\tret = -EIO;\n\t} else\n\t\tret = 0;\n\n\tif (!ret && b[0] == 1) {\n\t\tret = DVB_CA_EN50221_POLL_CAM_PRESENT |\n\t\t      DVB_CA_EN50221_POLL_CAM_READY;\n\t}\n\n\tmutex_unlock(&state->ca_mutex);\n\tkfree(b);\n\treturn ret;\n}\n\n\nstatic void az6027_ci_uninit(struct dvb_usb_device *d)\n{\n\tstruct az6027_device_state *state;\n\n\tdeb_info(\"%s\", __func__);\n\n\tif (NULL == d)\n\t\treturn;\n\n\tstate = d->priv;\n\tif (NULL == state)\n\t\treturn;\n\n\tif (NULL == state->ca.data)\n\t\treturn;\n\n\tdvb_ca_en50221_release(&state->ca);\n\n\tmemset(&state->ca, 0, sizeof(state->ca));\n}\n\n\nstatic int az6027_ci_init(struct dvb_usb_adapter *a)\n{\n\tstruct dvb_usb_device *d = a->dev;\n\tstruct az6027_device_state *state = d->priv;\n\tint ret;\n\n\tdeb_info(\"%s\", __func__);\n\n\tmutex_init(&state->ca_mutex);\n\n\tstate->ca.owner\t\t\t= THIS_MODULE;\n\tstate->ca.read_attribute_mem\t= az6027_ci_read_attribute_mem;\n\tstate->ca.write_attribute_mem\t= az6027_ci_write_attribute_mem;\n\tstate->ca.read_cam_control\t= az6027_ci_read_cam_control;\n\tstate->ca.write_cam_control\t= az6027_ci_write_cam_control;\n\tstate->ca.slot_reset\t\t= az6027_ci_slot_reset;\n\tstate->ca.slot_shutdown\t\t= az6027_ci_slot_shutdown;\n\tstate->ca.slot_ts_enable\t= az6027_ci_slot_ts_enable;\n\tstate->ca.poll_slot_status\t= az6027_ci_poll_slot_status;\n\tstate->ca.data\t\t\t= d;\n\n\tret = dvb_ca_en50221_init(&a->dvb_adap,\n\t\t\t\t  &state->ca,\n\t\t\t\t  0,  \n\t\t\t\t  1); \n\tif (ret != 0) {\n\t\terr(\"Cannot initialize CI: Error %d.\", ret);\n\t\tmemset(&state->ca, 0, sizeof(state->ca));\n\t\treturn ret;\n\t}\n\n\tdeb_info(\"CI initialized.\");\n\n\treturn 0;\n}\n\n \n\nstatic int az6027_set_voltage(struct dvb_frontend *fe,\n\t\t\t      enum fe_sec_voltage voltage)\n{\n\n\tu8 buf;\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\n\tstruct i2c_msg i2c_msg = {\n\t\t.addr\t= 0x99,\n\t\t.flags\t= 0,\n\t\t.buf\t= &buf,\n\t\t.len\t= 1\n\t};\n\n\t \n\tswitch (voltage) {\n\tcase SEC_VOLTAGE_13:\n\t\tbuf = 1;\n\t\ti2c_transfer(&adap->dev->i2c_adap, &i2c_msg, 1);\n\t\tbreak;\n\n\tcase SEC_VOLTAGE_18:\n\t\tbuf = 2;\n\t\ti2c_transfer(&adap->dev->i2c_adap, &i2c_msg, 1);\n\t\tbreak;\n\n\tcase SEC_VOLTAGE_OFF:\n\t\tbuf = 0;\n\t\ti2c_transfer(&adap->dev->i2c_adap, &i2c_msg, 1);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n\nstatic int az6027_frontend_poweron(struct dvb_usb_adapter *adap)\n{\n\tint ret;\n\tu8 req;\n\tu16 value;\n\tu16 index;\n\tint blen;\n\n\treq = 0xBC;\n\tvalue = 1;  \n\tindex = 3;\n\tblen = 0;\n\n\tret = az6027_usb_out_op(adap->dev, req, value, index, NULL, blen);\n\tif (ret != 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\nstatic int az6027_frontend_reset(struct dvb_usb_adapter *adap)\n{\n\tint ret;\n\tu8 req;\n\tu16 value;\n\tu16 index;\n\tint blen;\n\n\t \n\treq = 0xC0;\n\tvalue = 1;  \n\tindex = 3;\n\tblen = 0;\n\n\tret = az6027_usb_out_op(adap->dev, req, value, index, NULL, blen);\n\tif (ret != 0)\n\t\treturn -EIO;\n\n\treq = 0xC0;\n\tvalue = 0;  \n\tindex = 3;\n\tblen = 0;\n\tmsleep_interruptible(200);\n\n\tret = az6027_usb_out_op(adap->dev, req, value, index, NULL, blen);\n\tif (ret != 0)\n\t\treturn -EIO;\n\n\tmsleep_interruptible(200);\n\n\treq = 0xC0;\n\tvalue = 1;  \n\tindex = 3;\n\tblen = 0;\n\n\tret = az6027_usb_out_op(adap->dev, req, value, index, NULL, blen);\n\tif (ret != 0)\n\t\treturn -EIO;\n\n\tmsleep_interruptible(200);\n\treturn 0;\n}\n\nstatic int az6027_frontend_tsbypass(struct dvb_usb_adapter *adap, int onoff)\n{\n\tint ret;\n\tu8 req;\n\tu16 value;\n\tu16 index;\n\tint blen;\n\n\t \n\treq = 0xC7;\n\tvalue = onoff;\n\tindex = 0;\n\tblen = 0;\n\n\tret = az6027_usb_out_op(adap->dev, req, value, index, NULL, blen);\n\tif (ret != 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int az6027_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\n\taz6027_frontend_poweron(adap);\n\taz6027_frontend_reset(adap);\n\n\tdeb_info(\"adap = %p, dev = %p\\n\", adap, adap->dev);\n\tadap->fe_adap[0].fe = stb0899_attach(&az6027_stb0899_config, &adap->dev->i2c_adap);\n\n\tif (adap->fe_adap[0].fe) {\n\t\tdeb_info(\"found STB0899 DVB-S/DVB-S2 frontend @0x%02x\", az6027_stb0899_config.demod_address);\n\t\tif (stb6100_attach(adap->fe_adap[0].fe, &az6027_stb6100_config, &adap->dev->i2c_adap)) {\n\t\t\tdeb_info(\"found STB6100 DVB-S/DVB-S2 frontend @0x%02x\", az6027_stb6100_config.tuner_address);\n\t\t\tadap->fe_adap[0].fe->ops.set_voltage = az6027_set_voltage;\n\t\t\taz6027_ci_init(adap);\n\t\t} else {\n\t\t\tadap->fe_adap[0].fe = NULL;\n\t\t}\n\t} else\n\t\twarn(\"no front-end attached\\n\");\n\n\taz6027_frontend_tsbypass(adap, 0);\n\n\treturn 0;\n}\n\nstatic struct dvb_usb_device_properties az6027_properties;\n\nstatic void az6027_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\taz6027_ci_uninit(d);\n\tdvb_usb_device_exit(intf);\n}\n\n\nstatic int az6027_usb_probe(struct usb_interface *intf,\n\t\t\t    const struct usb_device_id *id)\n{\n\treturn dvb_usb_device_init(intf,\n\t\t\t\t   &az6027_properties,\n\t\t\t\t   THIS_MODULE,\n\t\t\t\t   NULL,\n\t\t\t\t   adapter_nr);\n}\n\n \nstatic int az6027_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[], int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint i = 0, j = 0, len = 0;\n\tu16 index;\n\tu16 value;\n\tint length;\n\tu8 req;\n\tu8 *data;\n\n\tdata = kmalloc(256, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0) {\n\t\tkfree(data);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (num > 2)\n\t\twarn(\"more than 2 i2c messages at a time is not handled yet. TODO.\");\n\n\tfor (i = 0; i < num; i++) {\n\n\t\tif (msg[i].addr == 0x99) {\n\t\t\treq = 0xBE;\n\t\t\tindex = 0;\n\t\t\tif (msg[i].len < 1) {\n\t\t\t\ti = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue = msg[i].buf[0] & 0x00ff;\n\t\t\tlength = 1;\n\t\t\taz6027_usb_out_op(d, req, value, index, data, length);\n\t\t}\n\n\t\tif (msg[i].addr == 0xd0) {\n\t\t\t \n\t\t\tif (i + 1 < num && (msg[i + 1].flags & I2C_M_RD)) {\n\t\t\t\treq = 0xB9;\n\t\t\t\tif (msg[i].len < 1) {\n\t\t\t\t\ti = -EOPNOTSUPP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tindex = (((msg[i].buf[0] << 8) & 0xff00) | (msg[i].buf[1] & 0x00ff));\n\t\t\t\tvalue = msg[i].addr + (msg[i].len << 8);\n\t\t\t\tlength = msg[i + 1].len + 6;\n\t\t\t\taz6027_usb_in_op(d, req, value, index, data, length);\n\t\t\t\tlen = msg[i + 1].len;\n\t\t\t\tfor (j = 0; j < len; j++)\n\t\t\t\t\tmsg[i + 1].buf[j] = data[j + 5];\n\n\t\t\t\ti++;\n\t\t\t} else {\n\n\t\t\t\t \n\t\t\t\treq = 0xBD;\n\t\t\t\tif (msg[i].len < 1) {\n\t\t\t\t\ti = -EOPNOTSUPP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tindex = (((msg[i].buf[0] << 8) & 0xff00) | (msg[i].buf[1] & 0x00ff));\n\t\t\t\tvalue = msg[i].addr + (2 << 8);\n\t\t\t\tlength = msg[i].len - 2;\n\t\t\t\tlen = msg[i].len - 2;\n\t\t\t\tfor (j = 0; j < len; j++)\n\t\t\t\t\tdata[j] = msg[i].buf[j + 2];\n\t\t\t\taz6027_usb_out_op(d, req, value, index, data, length);\n\t\t\t}\n\t\t}\n\n\t\tif (msg[i].addr == 0xc0) {\n\t\t\tif (msg[i].flags & I2C_M_RD) {\n\n\t\t\t\treq = 0xB9;\n\t\t\t\tindex = 0x0;\n\t\t\t\tvalue = msg[i].addr;\n\t\t\t\tlength = msg[i].len + 6;\n\t\t\t\taz6027_usb_in_op(d, req, value, index, data, length);\n\t\t\t\tlen = msg[i].len;\n\t\t\t\tfor (j = 0; j < len; j++)\n\t\t\t\t\tmsg[i].buf[j] = data[j + 5];\n\n\t\t\t} else {\n\n\t\t\t\treq = 0xBD;\n\t\t\t\tif (msg[i].len < 1) {\n\t\t\t\t\ti = -EOPNOTSUPP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tindex = msg[i].buf[0] & 0x00FF;\n\t\t\t\tvalue = msg[i].addr + (1 << 8);\n\t\t\t\tlength = msg[i].len - 1;\n\t\t\t\tlen = msg[i].len - 1;\n\n\t\t\t\tfor (j = 0; j < len; j++)\n\t\t\t\t\tdata[j] = msg[i].buf[j + 1];\n\n\t\t\t\taz6027_usb_out_op(d, req, value, index, data, length);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&d->i2c_mutex);\n\tkfree(data);\n\n\treturn i;\n}\n\n\nstatic u32 az6027_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm az6027_i2c_algo = {\n\t.master_xfer   = az6027_i2c_xfer,\n\t.functionality = az6027_i2c_func,\n};\n\nstatic int az6027_identify_state(struct usb_device *udev,\n\t\t\t\t const struct dvb_usb_device_properties *props,\n\t\t\t\t const struct dvb_usb_device_description **desc,\n\t\t\t\t int *cold)\n{\n\tu8 *b;\n\ts16 ret;\n\n\tb = kmalloc(16, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(udev,\n\t\t\t\t  usb_rcvctrlpipe(udev, 0),\n\t\t\t\t  0xb7,\n\t\t\t\t  USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t\t  6,\n\t\t\t\t  0,\n\t\t\t\t  b,\n\t\t\t\t  6,\n\t\t\t\t  USB_CTRL_GET_TIMEOUT);\n\n\t*cold = ret <= 0;\n\tkfree(b);\n\tdeb_info(\"cold: %d\\n\", *cold);\n\treturn 0;\n}\n\n\nenum {\n\tAZUREWAVE_AZ6027,\n\tTERRATEC_DVBS2CI_V1,\n\tTERRATEC_DVBS2CI_V2,\n\tTECHNISAT_USB2_HDCI_V1,\n\tTECHNISAT_USB2_HDCI_V2,\n\tELGATO_EYETV_SAT,\n\tELGATO_EYETV_SAT_V2,\n\tELGATO_EYETV_SAT_V3,\n};\n\nstatic struct usb_device_id az6027_usb_table[] = {\n\tDVB_USB_DEV(AZUREWAVE, AZUREWAVE_AZ6027),\n\tDVB_USB_DEV(TERRATEC, TERRATEC_DVBS2CI_V1),\n\tDVB_USB_DEV(TERRATEC, TERRATEC_DVBS2CI_V2),\n\tDVB_USB_DEV(TECHNISAT, TECHNISAT_USB2_HDCI_V1),\n\tDVB_USB_DEV(TECHNISAT, TECHNISAT_USB2_HDCI_V2),\n\tDVB_USB_DEV(ELGATO, ELGATO_EYETV_SAT),\n\tDVB_USB_DEV(ELGATO, ELGATO_EYETV_SAT_V2),\n\tDVB_USB_DEV(ELGATO, ELGATO_EYETV_SAT_V3),\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, az6027_usb_table);\n\nstatic struct dvb_usb_device_properties az6027_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\t.usb_ctrl = CYPRESS_FX2,\n\t.firmware            = \"dvb-usb-az6027-03.fw\",\n\t.no_reconnect        = 1,\n\n\t.size_of_priv     = sizeof(struct az6027_device_state),\n\t.identify_state\t\t= az6027_identify_state,\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = az6027_streaming_ctrl,\n\t\t\t.frontend_attach  = az6027_frontend_attach,\n\n\t\t\t \n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 10,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t}\n\t},\n \n\t.rc.legacy = {\n\t\t.rc_map_table     = rc_map_az6027_table,\n\t\t.rc_map_size      = ARRAY_SIZE(rc_map_az6027_table),\n\t\t.rc_interval      = 400,\n\t\t.rc_query         = az6027_rc_query,\n\t},\n\n\t.i2c_algo         = &az6027_i2c_algo,\n\n\t.num_device_descs = 8,\n\t.devices = {\n\t\t{\n\t\t\t.name = \"AZUREWAVE DVB-S/S2 USB2.0 (AZ6027)\",\n\t\t\t.cold_ids = { &az6027_usb_table[AZUREWAVE_AZ6027], NULL },\n\t\t\t.warm_ids = { NULL },\n\t\t}, {\n\t\t\t.name = \"TERRATEC S7\",\n\t\t\t.cold_ids = { &az6027_usb_table[TERRATEC_DVBS2CI_V1], NULL },\n\t\t\t.warm_ids = { NULL },\n\t\t}, {\n\t\t\t.name = \"TERRATEC S7 MKII\",\n\t\t\t.cold_ids = { &az6027_usb_table[TERRATEC_DVBS2CI_V2], NULL },\n\t\t\t.warm_ids = { NULL },\n\t\t}, {\n\t\t\t.name = \"Technisat SkyStar USB 2 HD CI\",\n\t\t\t.cold_ids = { &az6027_usb_table[TECHNISAT_USB2_HDCI_V1], NULL },\n\t\t\t.warm_ids = { NULL },\n\t\t}, {\n\t\t\t.name = \"Technisat SkyStar USB 2 HD CI\",\n\t\t\t.cold_ids = { &az6027_usb_table[TECHNISAT_USB2_HDCI_V2], NULL },\n\t\t\t.warm_ids = { NULL },\n\t\t}, {\n\t\t\t.name = \"Elgato EyeTV Sat\",\n\t\t\t.cold_ids = { &az6027_usb_table[ELGATO_EYETV_SAT], NULL },\n\t\t\t.warm_ids = { NULL },\n\t\t}, {\n\t\t\t.name = \"Elgato EyeTV Sat\",\n\t\t\t.cold_ids = { &az6027_usb_table[ELGATO_EYETV_SAT_V2], NULL },\n\t\t\t.warm_ids = { NULL },\n\t\t}, {\n\t\t\t.name = \"Elgato EyeTV Sat\",\n\t\t\t.cold_ids = { &az6027_usb_table[ELGATO_EYETV_SAT_V3], NULL },\n\t\t\t.warm_ids = { NULL },\n\t\t},\n\t\t{ NULL },\n\t}\n};\n\n \nstatic struct usb_driver az6027_usb_driver = {\n\t.name\t\t= \"dvb_usb_az6027\",\n\t.probe\t\t= az6027_usb_probe,\n\t.disconnect\t= az6027_usb_disconnect,\n\t.id_table\t= az6027_usb_table,\n};\n\nmodule_usb_driver(az6027_usb_driver);\n\nMODULE_AUTHOR(\"Adams Xu <Adams.xu@azwave.com.cn>\");\nMODULE_DESCRIPTION(\"Driver for AZUREWAVE DVB-S/S2 USB2.0 (AZ6027)\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}