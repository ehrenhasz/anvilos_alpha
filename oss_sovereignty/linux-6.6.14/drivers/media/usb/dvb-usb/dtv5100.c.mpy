{
  "module_name": "dtv5100.c",
  "hash_id": "6690d0aee5d98597580685170c3c873457f49025b5df9e6f279e443d75fc3d5f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/dtv5100.c",
  "human_readable_source": "\n \n\n#include \"dtv5100.h\"\n#include \"zl10353.h\"\n#include \"qt1010.h\"\n\n \nstatic int dvb_usb_dtv5100_debug;\nmodule_param_named(debug, dvb_usb_dtv5100_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level\" DVB_USB_DEBUG_STATUS);\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstruct dtv5100_state {\n\tunsigned char data[80];\n};\n\nstatic int dtv5100_i2c_msg(struct dvb_usb_device *d, u8 addr,\n\t\t\t   u8 *wbuf, u16 wlen, u8 *rbuf, u16 rlen)\n{\n\tstruct dtv5100_state *st = d->priv;\n\tunsigned int pipe;\n\tu8 request;\n\tu8 type;\n\tu16 value;\n\tu16 index;\n\n\tswitch (wlen) {\n\tcase 1:\n\t\t \n\t\tpipe = usb_rcvctrlpipe(d->udev, 0);\n\t\trequest = (addr == DTV5100_DEMOD_ADDR ? DTV5100_DEMOD_READ :\n\t\t\t\t\t\t\tDTV5100_TUNER_READ);\n\t\ttype = USB_TYPE_VENDOR | USB_DIR_IN;\n\t\tvalue = 0;\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tpipe = usb_sndctrlpipe(d->udev, 0);\n\t\trequest = (addr == DTV5100_DEMOD_ADDR ? DTV5100_DEMOD_WRITE :\n\t\t\t\t\t\t\tDTV5100_TUNER_WRITE);\n\t\ttype = USB_TYPE_VENDOR | USB_DIR_OUT;\n\t\tvalue = wbuf[1];\n\t\tbreak;\n\tdefault:\n\t\twarn(\"wlen = %x, aborting.\", wlen);\n\t\treturn -EINVAL;\n\t}\n\tindex = (addr << 8) + wbuf[0];\n\n\tmemcpy(st->data, rbuf, rlen);\n\tmsleep(1);  \n\treturn usb_control_msg(d->udev, pipe, request,\n\t\t\t       type, value, index, st->data, rlen,\n\t\t\t       DTV5100_USB_TIMEOUT);\n}\n\n \nstatic int dtv5100_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t    int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint i;\n\n\tif (num > 2)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tfor (i = 0; i < num; i++) {\n\t\t \n\t\tif (i+1 < num && (msg[i+1].flags & I2C_M_RD)) {\n\t\t\tif (dtv5100_i2c_msg(d, msg[i].addr, msg[i].buf,\n\t\t\t\t\t    msg[i].len, msg[i+1].buf,\n\t\t\t\t\t    msg[i+1].len) < 0)\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t} else if (dtv5100_i2c_msg(d, msg[i].addr, msg[i].buf,\n\t\t\t\t\t   msg[i].len, NULL, 0) < 0)\n\t\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&d->i2c_mutex);\n\treturn i;\n}\n\nstatic u32 dtv5100_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm dtv5100_i2c_algo = {\n\t.master_xfer   = dtv5100_i2c_xfer,\n\t.functionality = dtv5100_i2c_func,\n};\n\n \nstatic struct zl10353_config dtv5100_zl10353_config = {\n\t.demod_address = DTV5100_DEMOD_ADDR,\n\t.no_tuner = 1,\n\t.parallel_ts = 1,\n};\n\nstatic int dtv5100_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tadap->fe_adap[0].fe = dvb_attach(zl10353_attach, &dtv5100_zl10353_config,\n\t\t\t      &adap->dev->i2c_adap);\n\tif (adap->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\t \n\tadap->fe_adap[0].fe->ops.i2c_gate_ctrl = NULL;\n\n\treturn 0;\n}\n\nstatic struct qt1010_config dtv5100_qt1010_config = {\n\t.i2c_address = DTV5100_TUNER_ADDR\n};\n\nstatic int dtv5100_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\treturn dvb_attach(qt1010_attach,\n\t\t\t  adap->fe_adap[0].fe, &adap->dev->i2c_adap,\n\t\t\t  &dtv5100_qt1010_config) == NULL ? -ENODEV : 0;\n}\n\n \nstatic struct dvb_usb_device_properties dtv5100_properties;\n\nstatic int dtv5100_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tint i, ret;\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\n\t \n\tfor (i = 0; dtv5100_init[i].request; i++) {\n\t\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t      dtv5100_init[i].request,\n\t\t\t\t      USB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t\t      dtv5100_init[i].value,\n\t\t\t\t      dtv5100_init[i].index, NULL, 0,\n\t\t\t\t      DTV5100_USB_TIMEOUT);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = dvb_usb_device_init(intf, &dtv5100_properties,\n\t\t\t\t  THIS_MODULE, NULL, adapter_nr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nenum {\n\tAME_DTV5100,\n};\n\nstatic struct usb_device_id dtv5100_table[] = {\n\tDVB_USB_DEV(AME, AME_DTV5100),\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, dtv5100_table);\n\nstatic struct dvb_usb_device_properties dtv5100_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\n\t.size_of_priv = sizeof(struct dtv5100_state),\n\n\t.num_adapters = 1,\n\t.adapter = {{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t.frontend_attach = dtv5100_frontend_attach,\n\t\t.tuner_attach    = dtv5100_tuner_attach,\n\n\t\t.stream = {\n\t\t\t.type = USB_BULK,\n\t\t\t.count = 8,\n\t\t\t.endpoint = 0x82,\n\t\t\t.u = {\n\t\t\t\t.bulk = {\n\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t}},\n\t} },\n\n\t.i2c_algo = &dtv5100_i2c_algo,\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{\n\t\t\t.name = \"AME DTV-5100 USB2.0 DVB-T\",\n\t\t\t.cold_ids = { NULL },\n\t\t\t.warm_ids = { &dtv5100_table[AME_DTV5100], NULL },\n\t\t},\n\t}\n};\n\nstatic struct usb_driver dtv5100_driver = {\n\t.name\t\t= \"dvb_usb_dtv5100\",\n\t.probe\t\t= dtv5100_probe,\n\t.disconnect\t= dvb_usb_device_exit,\n\t.id_table\t= dtv5100_table,\n};\n\nmodule_usb_driver(dtv5100_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}