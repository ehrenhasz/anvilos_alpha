{
  "module_name": "dib0700_core.c",
  "hash_id": "34d77dc9a2d243464434ef23de1d31bdca92945aa88b0106ec0f114df3606e5c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/dib0700_core.c",
  "human_readable_source": "\n \n#include \"dib0700.h\"\n\n \nint dvb_usb_dib0700_debug;\nmodule_param_named(debug,dvb_usb_dib0700_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=info,2=fw,4=fwdata,8=data (or-able)).\" DVB_USB_DEBUG_STATUS);\n\nstatic int nb_packet_buffer_size = 21;\nmodule_param(nb_packet_buffer_size, int, 0644);\nMODULE_PARM_DESC(nb_packet_buffer_size,\n\t\"Set the dib0700 driver data buffer size. This parameter corresponds to the number of TS packets. The actual size of the data buffer corresponds to this parameter multiplied by 188 (default: 21)\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n\nint dib0700_get_version(struct dvb_usb_device *d, u32 *hwversion,\n\t\t\tu32 *romversion, u32 *ramversion, u32 *fwtype)\n{\n\tstruct dib0700_state *st = d->priv;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&d->usb_mutex) < 0) {\n\t\terr(\"could not acquire lock\");\n\t\treturn -EINTR;\n\t}\n\n\tret = usb_control_msg(d->udev, usb_rcvctrlpipe(d->udev, 0),\n\t\t\t\t  REQUEST_GET_VERSION,\n\t\t\t\t  USB_TYPE_VENDOR | USB_DIR_IN, 0, 0,\n\t\t\t\t  st->buf, 16, USB_CTRL_GET_TIMEOUT);\n\tif (hwversion != NULL)\n\t\t*hwversion  = (st->buf[0] << 24)  | (st->buf[1] << 16)  |\n\t\t\t(st->buf[2] << 8)  | st->buf[3];\n\tif (romversion != NULL)\n\t\t*romversion = (st->buf[4] << 24)  | (st->buf[5] << 16)  |\n\t\t\t(st->buf[6] << 8)  | st->buf[7];\n\tif (ramversion != NULL)\n\t\t*ramversion = (st->buf[8] << 24)  | (st->buf[9] << 16)  |\n\t\t\t(st->buf[10] << 8) | st->buf[11];\n\tif (fwtype != NULL)\n\t\t*fwtype     = (st->buf[12] << 24) | (st->buf[13] << 16) |\n\t\t\t(st->buf[14] << 8) | st->buf[15];\n\tmutex_unlock(&d->usb_mutex);\n\treturn ret;\n}\n\n \nstatic int dib0700_ctrl_wr(struct dvb_usb_device *d, u8 *tx, u8 txlen)\n{\n\tint status;\n\n\tdeb_data(\">>> \");\n\tdebug_dump(tx, txlen, deb_data);\n\n\tstatus = usb_control_msg(d->udev, usb_sndctrlpipe(d->udev,0),\n\t\ttx[0], USB_TYPE_VENDOR | USB_DIR_OUT, 0, 0, tx, txlen,\n\t\tUSB_CTRL_GET_TIMEOUT);\n\n\tif (status != txlen)\n\t\tdeb_data(\"ep 0 write error (status = %d, len: %d)\\n\",status,txlen);\n\n\treturn status < 0 ? status : 0;\n}\n\n \nint dib0700_ctrl_rd(struct dvb_usb_device *d, u8 *tx, u8 txlen, u8 *rx, u8 rxlen)\n{\n\tu16 index, value;\n\tint status;\n\n\tif (txlen < 2) {\n\t\terr(\"tx buffer length is smaller than 2. Makes no sense.\");\n\t\treturn -EINVAL;\n\t}\n\tif (txlen > 4) {\n\t\terr(\"tx buffer length is larger than 4. Not supported.\");\n\t\treturn -EINVAL;\n\t}\n\n\tdeb_data(\">>> \");\n\tdebug_dump(tx,txlen,deb_data);\n\n\tvalue = ((txlen - 2) << 8) | tx[1];\n\tindex = 0;\n\tif (txlen > 2)\n\t\tindex |= (tx[2] << 8);\n\tif (txlen > 3)\n\t\tindex |= tx[3];\n\n\tstatus = usb_control_msg(d->udev, usb_rcvctrlpipe(d->udev,0), tx[0],\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_IN, value, index, rx, rxlen,\n\t\t\tUSB_CTRL_GET_TIMEOUT);\n\n\tif (status < 0)\n\t\tdeb_info(\"ep 0 read error (status = %d)\\n\",status);\n\n\tdeb_data(\"<<< \");\n\tdebug_dump(rx, rxlen, deb_data);\n\n\treturn status;  \n}\n\nint dib0700_set_gpio(struct dvb_usb_device *d, enum dib07x0_gpios gpio, u8 gpio_dir, u8 gpio_val)\n{\n\tstruct dib0700_state *st = d->priv;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&d->usb_mutex) < 0) {\n\t\terr(\"could not acquire lock\");\n\t\treturn -EINTR;\n\t}\n\n\tst->buf[0] = REQUEST_SET_GPIO;\n\tst->buf[1] = gpio;\n\tst->buf[2] = ((gpio_dir & 0x01) << 7) | ((gpio_val & 0x01) << 6);\n\n\tret = dib0700_ctrl_wr(d, st->buf, 3);\n\n\tmutex_unlock(&d->usb_mutex);\n\treturn ret;\n}\n\nstatic int dib0700_set_usb_xfer_len(struct dvb_usb_device *d, u16 nb_ts_packets)\n{\n\tstruct dib0700_state *st = d->priv;\n\tint ret;\n\n\tif (st->fw_version >= 0x10201) {\n\t\tif (mutex_lock_interruptible(&d->usb_mutex) < 0) {\n\t\t\terr(\"could not acquire lock\");\n\t\t\treturn -EINTR;\n\t\t}\n\n\t\tst->buf[0] = REQUEST_SET_USB_XFER_LEN;\n\t\tst->buf[1] = (nb_ts_packets >> 8) & 0xff;\n\t\tst->buf[2] = nb_ts_packets & 0xff;\n\n\t\tdeb_info(\"set the USB xfer len to %i Ts packet\\n\", nb_ts_packets);\n\n\t\tret = dib0700_ctrl_wr(d, st->buf, 3);\n\t\tmutex_unlock(&d->usb_mutex);\n\t} else {\n\t\tdeb_info(\"this firmware does not allow to change the USB xfer len\\n\");\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int dib0700_i2c_xfer_new(struct i2c_adapter *adap, struct i2c_msg *msg,\n\t\t\t\tint num)\n{\n\t \n\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstruct dib0700_state *st = d->priv;\n\tuint8_t bus_mode = 1;   \n\tuint8_t gen_mode = 0;  \n\tuint8_t en_start = 0;\n\tuint8_t en_stop = 0;\n\tint result, i;\n\n\t \n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EINTR;\n\n\tfor (i = 0; i < num; i++) {\n\t\tif (i == 0) {\n\t\t\t \n\t\t\ten_start = 1;\n\t\t} else if (!(msg[i].flags & I2C_M_NOSTART)) {\n\t\t\t \n\t\t\ten_start = 1;\n\t\t} else {\n\t\t\t \n\t\t\ten_start = 0;\n\t\t}\n\t\tif (i == (num - 1)) {\n\t\t\t \n\t\t\ten_stop = 1;\n\t\t}\n\n\t\tif (msg[i].flags & I2C_M_RD) {\n\t\t\t \n\t\t\tu16 index, value;\n\t\t\tuint8_t i2c_dest;\n\n\t\t\ti2c_dest = (msg[i].addr << 1);\n\t\t\tvalue = ((en_start << 7) | (en_stop << 6) |\n\t\t\t\t (msg[i].len & 0x3F)) << 8 | i2c_dest;\n\t\t\t \n\t\t\tindex = ((gen_mode << 6) & 0xC0) |\n\t\t\t\t((bus_mode << 4) & 0x30);\n\n\t\t\tresult = usb_control_msg(d->udev,\n\t\t\t\t\t\t usb_rcvctrlpipe(d->udev, 0),\n\t\t\t\t\t\t REQUEST_NEW_I2C_READ,\n\t\t\t\t\t\t USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t\t\t\t value, index, st->buf,\n\t\t\t\t\t\t msg[i].len,\n\t\t\t\t\t\t USB_CTRL_GET_TIMEOUT);\n\t\t\tif (result < 0) {\n\t\t\t\tdeb_info(\"i2c read error (status = %d)\\n\", result);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tif (msg[i].len > sizeof(st->buf)) {\n\t\t\t\tdeb_info(\"buffer too small to fit %d bytes\\n\",\n\t\t\t\t\t msg[i].len);\n\t\t\t\tresult = -EIO;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tmemcpy(msg[i].buf, st->buf, msg[i].len);\n\n\t\t\tdeb_data(\"<<< \");\n\t\t\tdebug_dump(msg[i].buf, msg[i].len, deb_data);\n\n\t\t} else {\n\t\t\t \n\t\t\tif (mutex_lock_interruptible(&d->usb_mutex) < 0) {\n\t\t\t\terr(\"could not acquire lock\");\n\t\t\t\tresult = -EINTR;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tst->buf[0] = REQUEST_NEW_I2C_WRITE;\n\t\t\tst->buf[1] = msg[i].addr << 1;\n\t\t\tst->buf[2] = (en_start << 7) | (en_stop << 6) |\n\t\t\t\t(msg[i].len & 0x3F);\n\t\t\t \n\t\t\tst->buf[3] = ((gen_mode << 6) & 0xC0) |\n\t\t\t\t ((bus_mode << 4) & 0x30);\n\n\t\t\tif (msg[i].len > sizeof(st->buf) - 4) {\n\t\t\t\tdeb_info(\"i2c message to big: %d\\n\",\n\t\t\t\t\t msg[i].len);\n\t\t\t\tmutex_unlock(&d->usb_mutex);\n\t\t\t\tresult = -EIO;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\t \n\t\t\tmemcpy(&st->buf[4], msg[i].buf, msg[i].len);\n\n\t\t\tdeb_data(\">>> \");\n\t\t\tdebug_dump(st->buf, msg[i].len + 4, deb_data);\n\n\t\t\tresult = usb_control_msg(d->udev,\n\t\t\t\t\t\t usb_sndctrlpipe(d->udev, 0),\n\t\t\t\t\t\t REQUEST_NEW_I2C_WRITE,\n\t\t\t\t\t\t USB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t\t\t\t 0, 0, st->buf, msg[i].len + 4,\n\t\t\t\t\t\t USB_CTRL_GET_TIMEOUT);\n\t\t\tmutex_unlock(&d->usb_mutex);\n\t\t\tif (result < 0) {\n\t\t\t\tdeb_info(\"i2c write error (status = %d)\\n\", result);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tresult = i;\n\nunlock:\n\tmutex_unlock(&d->i2c_mutex);\n\treturn result;\n}\n\n \nstatic int dib0700_i2c_xfer_legacy(struct i2c_adapter *adap,\n\t\t\t\t   struct i2c_msg *msg, int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstruct dib0700_state *st = d->priv;\n\tint i, len, result;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EINTR;\n\tif (mutex_lock_interruptible(&d->usb_mutex) < 0) {\n\t\terr(\"could not acquire lock\");\n\t\tmutex_unlock(&d->i2c_mutex);\n\t\treturn -EINTR;\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\t \n\t\tst->buf[1] = msg[i].addr << 1;\n\t\t \n\t\tif (msg[i].len > sizeof(st->buf) - 2) {\n\t\t\tdeb_info(\"i2c xfer to big: %d\\n\",\n\t\t\t\tmsg[i].len);\n\t\t\tresult = -EIO;\n\t\t\tgoto unlock;\n\t\t}\n\t\tmemcpy(&st->buf[2], msg[i].buf, msg[i].len);\n\n\t\t \n\t\tif (i+1 < num && (msg[i+1].flags & I2C_M_RD)) {\n\t\t\tst->buf[0] = REQUEST_I2C_READ;\n\t\t\tst->buf[1] |= 1;\n\n\t\t\t \n\t\t\tlen = dib0700_ctrl_rd(d, st->buf, msg[i].len + 2,\n\t\t\t\t\t      st->buf, msg[i + 1].len);\n\t\t\tif (len <= 0) {\n\t\t\t\tdeb_info(\"I2C read failed on address 0x%02x\\n\",\n\t\t\t\t\t\tmsg[i].addr);\n\t\t\t\tresult = -EIO;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tif (msg[i + 1].len > sizeof(st->buf)) {\n\t\t\t\tdeb_info(\"i2c xfer buffer to small for %d\\n\",\n\t\t\t\t\tmsg[i].len);\n\t\t\t\tresult = -EIO;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tmemcpy(msg[i + 1].buf, st->buf, msg[i + 1].len);\n\n\t\t\tmsg[i+1].len = len;\n\n\t\t\ti++;\n\t\t} else {\n\t\t\tst->buf[0] = REQUEST_I2C_WRITE;\n\t\t\tresult = dib0700_ctrl_wr(d, st->buf, msg[i].len + 2);\n\t\t\tif (result < 0)\n\t\t\t\tgoto unlock;\n\t\t}\n\t}\n\tresult = i;\nunlock:\n\tmutex_unlock(&d->usb_mutex);\n\tmutex_unlock(&d->i2c_mutex);\n\n\treturn result;\n}\n\nstatic int dib0700_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msg,\n\t\t\t    int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstruct dib0700_state *st = d->priv;\n\n\tif (st->fw_use_new_i2c_api == 1) {\n\t\t \n\t\treturn dib0700_i2c_xfer_new(adap, msg, num);\n\t} else {\n\t\t \n\t\treturn dib0700_i2c_xfer_legacy(adap, msg, num);\n\t}\n}\n\nstatic u32 dib0700_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstruct i2c_algorithm dib0700_i2c_algo = {\n\t.master_xfer   = dib0700_i2c_xfer,\n\t.functionality = dib0700_i2c_func,\n};\n\nint dib0700_identify_state(struct usb_device *udev,\n\t\t\t   const struct dvb_usb_device_properties *props,\n\t\t\t   const struct dvb_usb_device_description **desc,\n\t\t\t   int *cold)\n{\n\ts16 ret;\n\tu8 *b;\n\n\tb = kmalloc(16, GFP_KERNEL);\n\tif (!b)\n\t\treturn\t-ENOMEM;\n\n\n\tret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\tREQUEST_GET_VERSION, USB_TYPE_VENDOR | USB_DIR_IN, 0, 0, b, 16, USB_CTRL_GET_TIMEOUT);\n\n\tdeb_info(\"FW GET_VERSION length: %d\\n\",ret);\n\n\t*cold = ret <= 0;\n\tdeb_info(\"cold: %d\\n\", *cold);\n\n\tkfree(b);\n\treturn 0;\n}\n\nstatic int dib0700_set_clock(struct dvb_usb_device *d, u8 en_pll,\n\tu8 pll_src, u8 pll_range, u8 clock_gpio3, u16 pll_prediv,\n\tu16 pll_loopdiv, u16 free_div, u16 dsuScaler)\n{\n\tstruct dib0700_state *st = d->priv;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&d->usb_mutex) < 0) {\n\t\terr(\"could not acquire lock\");\n\t\treturn -EINTR;\n\t}\n\n\tst->buf[0] = REQUEST_SET_CLOCK;\n\tst->buf[1] = (en_pll << 7) | (pll_src << 6) |\n\t\t(pll_range << 5) | (clock_gpio3 << 4);\n\tst->buf[2] = (pll_prediv >> 8)  & 0xff;  \n\tst->buf[3] =  pll_prediv        & 0xff;  \n\tst->buf[4] = (pll_loopdiv >> 8) & 0xff;  \n\tst->buf[5] =  pll_loopdiv       & 0xff;  \n\tst->buf[6] = (free_div >> 8)    & 0xff;  \n\tst->buf[7] =  free_div          & 0xff;  \n\tst->buf[8] = (dsuScaler >> 8)   & 0xff;  \n\tst->buf[9] =  dsuScaler         & 0xff;  \n\n\tret = dib0700_ctrl_wr(d, st->buf, 10);\n\tmutex_unlock(&d->usb_mutex);\n\n\treturn ret;\n}\n\nint dib0700_set_i2c_speed(struct dvb_usb_device *d, u16 scl_kHz)\n{\n\tstruct dib0700_state *st = d->priv;\n\tu16 divider;\n\tint ret;\n\n\tif (scl_kHz == 0)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&d->usb_mutex) < 0) {\n\t\terr(\"could not acquire lock\");\n\t\treturn -EINTR;\n\t}\n\n\tst->buf[0] = REQUEST_SET_I2C_PARAM;\n\tdivider = (u16) (30000 / scl_kHz);\n\tst->buf[1] = 0;\n\tst->buf[2] = (u8) (divider >> 8);\n\tst->buf[3] = (u8) (divider & 0xff);\n\tdivider = (u16) (72000 / scl_kHz);\n\tst->buf[4] = (u8) (divider >> 8);\n\tst->buf[5] = (u8) (divider & 0xff);\n\tdivider = (u16) (72000 / scl_kHz);  \n\tst->buf[6] = (u8) (divider >> 8);\n\tst->buf[7] = (u8) (divider & 0xff);\n\n\tdeb_info(\"setting I2C speed: %04x %04x %04x (%d kHz).\",\n\t\t(st->buf[2] << 8) | (st->buf[3]), (st->buf[4] << 8) |\n\t\tst->buf[5], (st->buf[6] << 8) | st->buf[7], scl_kHz);\n\n\tret = dib0700_ctrl_wr(d, st->buf, 8);\n\tmutex_unlock(&d->usb_mutex);\n\n\treturn ret;\n}\n\n\nint dib0700_ctrl_clock(struct dvb_usb_device *d, u32 clk_MHz, u8 clock_out_gp3)\n{\n\tswitch (clk_MHz) {\n\t\tcase 72: dib0700_set_clock(d, 1, 0, 1, clock_out_gp3, 2, 24, 0, 0x4c); break;\n\t\tdefault: return -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int dib0700_jumpram(struct usb_device *udev, u32 address)\n{\n\tint ret = 0, actlen;\n\tu8 *buf;\n\n\tbuf = kmalloc(8, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tbuf[0] = REQUEST_JUMPRAM;\n\tbuf[1] = 0;\n\tbuf[2] = 0;\n\tbuf[3] = 0;\n\tbuf[4] = (address >> 24) & 0xff;\n\tbuf[5] = (address >> 16) & 0xff;\n\tbuf[6] = (address >> 8)  & 0xff;\n\tbuf[7] =  address        & 0xff;\n\n\tif ((ret = usb_bulk_msg(udev, usb_sndbulkpipe(udev, 0x01),buf,8,&actlen,1000)) < 0) {\n\t\tdeb_fw(\"jumpram to 0x%x failed\\n\",address);\n\t\tgoto out;\n\t}\n\tif (actlen != 8) {\n\t\tdeb_fw(\"jumpram to 0x%x failed\\n\",address);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\nint dib0700_download_firmware(struct usb_device *udev, const struct firmware *fw)\n{\n\tstruct hexline hx;\n\tint pos = 0, ret, act_len, i, adap_num;\n\tu8 *buf;\n\tu32 fw_version;\n\n\tbuf = kmalloc(260, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\twhile ((ret = dvb_usb_get_hexline(fw, &hx, &pos)) > 0) {\n\t\tdeb_fwdata(\"writing to address 0x%08x (buffer: 0x%02x %02x)\\n\",\n\t\t\t\thx.addr, hx.len, hx.chk);\n\n\t\tbuf[0] = hx.len;\n\t\tbuf[1] = (hx.addr >> 8) & 0xff;\n\t\tbuf[2] =  hx.addr       & 0xff;\n\t\tbuf[3] = hx.type;\n\t\tmemcpy(&buf[4],hx.data,hx.len);\n\t\tbuf[4+hx.len] = hx.chk;\n\n\t\tret = usb_bulk_msg(udev,\n\t\t\tusb_sndbulkpipe(udev, 0x01),\n\t\t\tbuf,\n\t\t\thx.len + 5,\n\t\t\t&act_len,\n\t\t\t1000);\n\n\t\tif (ret < 0) {\n\t\t\terr(\"firmware download failed at %d with %d\",pos,ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ret == 0) {\n\t\t \n\t\tif ((ret = dib0700_jumpram(udev, 0x70000000)) == 0) {\n\t\t\tinfo(\"firmware started successfully.\");\n\t\t\tmsleep(500);\n\t\t}\n\t} else\n\t\tret = -EIO;\n\n\t \n\tif (nb_packet_buffer_size < 1)\n\t\tnb_packet_buffer_size = 1;\n\n\t \n\tusb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t\t  REQUEST_GET_VERSION,\n\t\t\t\t  USB_TYPE_VENDOR | USB_DIR_IN, 0, 0,\n\t\t\t\t  buf, 16, USB_CTRL_GET_TIMEOUT);\n\tfw_version = (buf[8] << 24) | (buf[9] << 16) | (buf[10] << 8) | buf[11];\n\n\t \n\tfor (i = 0; i < dib0700_device_count; i++) {\n\t\tfor (adap_num = 0; adap_num < dib0700_devices[i].num_adapters;\n\t\t\t\tadap_num++) {\n\t\t\tif (fw_version >= 0x10201) {\n\t\t\t\tdib0700_devices[i].adapter[adap_num].fe[0].stream.u.bulk.buffersize = 188*nb_packet_buffer_size;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdib0700_devices[i].adapter[adap_num].fe[0].stream.u.bulk.buffersize = ((188*nb_packet_buffer_size+188/2)/512)*512;\n\t\t\t\tif (dib0700_devices[i].adapter[adap_num].fe[0].stream.u.bulk.buffersize < 512)\n\t\t\t\t\tdib0700_devices[i].adapter[adap_num].fe[0].stream.u.bulk.buffersize = 512;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\nint dib0700_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\n{\n\tstruct dib0700_state *st = adap->dev->priv;\n\tint ret, adapt_nr;\n\n\tif ((onoff != 0) && (st->fw_version >= 0x10201)) {\n\t\t \n\t\tret = dib0700_set_usb_xfer_len(adap->dev,\n\t\t\tst->nb_packet_buffer_size);\n\t\tif (ret < 0) {\n\t\t\tdeb_info(\"can not set the USB xfer len\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmutex_lock(&adap->dev->usb_mutex);\n\n\tst->buf[0] = REQUEST_ENABLE_VIDEO;\n\t \n\tst->buf[1] = (onoff << 4) | 0x00;\n\n\tif (st->disable_streaming_master_mode == 1)\n\t\tst->buf[2] = 0x00;\n\telse\n\t\tst->buf[2] = 0x01 << 4;  \n\n\tst->buf[3] = 0x00;\n\n\tif ((adap->fe_adap[0].stream.props.endpoint != 2)\n\t    && (adap->fe_adap[0].stream.props.endpoint != 3)) {\n\t\tdeb_info(\"the endpoint number (%i) is not correct, use the adapter id instead\\n\",\n\t\t\t adap->fe_adap[0].stream.props.endpoint);\n\t\tadapt_nr = adap->id;\n\t} else {\n\t\tadapt_nr = adap->fe_adap[0].stream.props.endpoint - 2;\n\t}\n\n\tif (onoff)\n\t\tst->channel_state |= 1 << adapt_nr;\n\telse\n\t\tst->channel_state &= ~(1 << adapt_nr);\n\n\tst->buf[2] |= st->channel_state;\n\n\tdeb_info(\"adapter %d, streaming %s: %*ph\\n\",\n\t\tadapt_nr, onoff ? \"ON\" : \"OFF\", 3, st->buf);\n\n\tret = dib0700_ctrl_wr(adap->dev, st->buf, 4);\n\tmutex_unlock(&adap->dev->usb_mutex);\n\n\treturn ret;\n}\n\nint dib0700_change_protocol(struct rc_dev *rc, u64 *rc_proto)\n{\n\tstruct dvb_usb_device *d = rc->priv;\n\tstruct dib0700_state *st = d->priv;\n\tint new_proto, ret;\n\n\tif (mutex_lock_interruptible(&d->usb_mutex) < 0) {\n\t\terr(\"could not acquire lock\");\n\t\treturn -EINTR;\n\t}\n\n\tst->buf[0] = REQUEST_SET_RC;\n\tst->buf[1] = 0;\n\tst->buf[2] = 0;\n\n\t \n\tif (*rc_proto & RC_PROTO_BIT_RC5) {\n\t\tnew_proto = 1;\n\t\t*rc_proto = RC_PROTO_BIT_RC5;\n\t} else if (*rc_proto & RC_PROTO_BIT_NEC) {\n\t\tnew_proto = 0;\n\t\t*rc_proto = RC_PROTO_BIT_NEC;\n\t} else if (*rc_proto & RC_PROTO_BIT_RC6_MCE) {\n\t\tif (st->fw_version < 0x10200) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tnew_proto = 2;\n\t\t*rc_proto = RC_PROTO_BIT_RC6_MCE;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tst->buf[1] = new_proto;\n\n\tret = dib0700_ctrl_wr(d, st->buf, 3);\n\tif (ret < 0) {\n\t\terr(\"ir protocol setup failed\");\n\t\tgoto out;\n\t}\n\n\td->props.rc.core.protocol = *rc_proto;\n\nout:\n\tmutex_unlock(&d->usb_mutex);\n\treturn ret;\n}\n\n \nstruct dib0700_rc_response {\n\tu8 report_id;\n\tu8 data_state;\n\tunion {\n\t\tstruct {\n\t\t\tu8 system;\n\t\t\tu8 not_system;\n\t\t\tu8 data;\n\t\t\tu8 not_data;\n\t\t} nec;\n\t\tstruct {\n\t\t\tu8 not_used;\n\t\t\tu8 system;\n\t\t\tu8 data;\n\t\t\tu8 not_data;\n\t\t} rc5;\n\t};\n};\n#define RC_MSG_SIZE_V1_20 6\n\nstatic void dib0700_rc_urb_completion(struct urb *purb)\n{\n\tstruct dvb_usb_device *d = purb->context;\n\tstruct dib0700_rc_response *poll_reply;\n\tenum rc_proto protocol;\n\tu32 keycode;\n\tu8 toggle;\n\n\tdeb_info(\"%s()\\n\", __func__);\n\tif (d->rc_dev == NULL) {\n\t\t \n\t\tkfree(purb->transfer_buffer);\n\t\tusb_free_urb(purb);\n\t\treturn;\n\t}\n\n\tpoll_reply = purb->transfer_buffer;\n\n\tif (purb->status < 0) {\n\t\tdeb_info(\"discontinuing polling\\n\");\n\t\tkfree(purb->transfer_buffer);\n\t\tusb_free_urb(purb);\n\t\treturn;\n\t}\n\n\tif (purb->actual_length != RC_MSG_SIZE_V1_20) {\n\t\tdeb_info(\"malformed rc msg size=%d\\n\", purb->actual_length);\n\t\tgoto resubmit;\n\t}\n\n\tdeb_data(\"IR ID = %02X state = %02X System = %02X %02X Cmd = %02X %02X (len %d)\\n\",\n\t\t poll_reply->report_id, poll_reply->data_state,\n\t\t poll_reply->nec.system, poll_reply->nec.not_system,\n\t\t poll_reply->nec.data, poll_reply->nec.not_data,\n\t\t purb->actual_length);\n\n\tswitch (d->props.rc.core.protocol) {\n\tcase RC_PROTO_BIT_NEC:\n\t\ttoggle = 0;\n\n\t\t \n\t\tif (poll_reply->nec.system     == 0x00 &&\n\t\t    poll_reply->nec.not_system == 0x00 &&\n\t\t    poll_reply->nec.data       == 0x00 &&\n\t\t    poll_reply->nec.not_data   == 0xff) {\n\t\t\tpoll_reply->data_state = 2;\n\t\t\trc_repeat(d->rc_dev);\n\t\t\tgoto resubmit;\n\t\t}\n\n\t\tif ((poll_reply->nec.data ^ poll_reply->nec.not_data) != 0xff) {\n\t\t\tdeb_data(\"NEC32 protocol\\n\");\n\t\t\tkeycode = RC_SCANCODE_NEC32(poll_reply->nec.system     << 24 |\n\t\t\t\t\t\t     poll_reply->nec.not_system << 16 |\n\t\t\t\t\t\t     poll_reply->nec.data       << 8  |\n\t\t\t\t\t\t     poll_reply->nec.not_data);\n\t\t\tprotocol = RC_PROTO_NEC32;\n\t\t} else if ((poll_reply->nec.system ^ poll_reply->nec.not_system) != 0xff) {\n\t\t\tdeb_data(\"NEC extended protocol\\n\");\n\t\t\tkeycode = RC_SCANCODE_NECX(poll_reply->nec.system << 8 |\n\t\t\t\t\t\t    poll_reply->nec.not_system,\n\t\t\t\t\t\t    poll_reply->nec.data);\n\n\t\t\tprotocol = RC_PROTO_NECX;\n\t\t} else {\n\t\t\tdeb_data(\"NEC normal protocol\\n\");\n\t\t\tkeycode = RC_SCANCODE_NEC(poll_reply->nec.system,\n\t\t\t\t\t\t   poll_reply->nec.data);\n\t\t\tprotocol = RC_PROTO_NEC;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tdeb_data(\"RC5 protocol\\n\");\n\t\tprotocol = RC_PROTO_RC5;\n\t\ttoggle = poll_reply->report_id;\n\t\tkeycode = RC_SCANCODE_RC5(poll_reply->rc5.system, poll_reply->rc5.data);\n\n\t\tif ((poll_reply->rc5.data ^ poll_reply->rc5.not_data) != 0xff) {\n\t\t\t \n\t\t\terr(\"key failed integrity check: %02x %02x %02x %02x\",\n\t\t\t    poll_reply->rc5.not_used, poll_reply->rc5.system,\n\t\t\t    poll_reply->rc5.data, poll_reply->rc5.not_data);\n\t\t\tgoto resubmit;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\trc_keydown(d->rc_dev, protocol, keycode, toggle);\n\nresubmit:\n\t \n\tmemset(purb->transfer_buffer, 0, RC_MSG_SIZE_V1_20);\n\n\t \n\tusb_submit_urb(purb, GFP_ATOMIC);\n}\n\nint dib0700_rc_setup(struct dvb_usb_device *d, struct usb_interface *intf)\n{\n\tstruct dib0700_state *st = d->priv;\n\tstruct urb *purb;\n\tconst struct usb_endpoint_descriptor *e;\n\tint ret, rc_ep = 1;\n\tunsigned int pipe = 0;\n\n\t \n\tif (st->fw_version < 0x10200 || !intf)\n\t\treturn 0;\n\n\t \n\n\tif (intf->cur_altsetting->desc.bNumEndpoints < rc_ep + 1)\n\t\treturn -ENODEV;\n\n\tpurb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (purb == NULL)\n\t\treturn -ENOMEM;\n\n\tpurb->transfer_buffer = kzalloc(RC_MSG_SIZE_V1_20, GFP_KERNEL);\n\tif (purb->transfer_buffer == NULL) {\n\t\terr(\"rc kzalloc failed\");\n\t\tusb_free_urb(purb);\n\t\treturn -ENOMEM;\n\t}\n\n\tpurb->status = -EINPROGRESS;\n\n\t \n\te = &intf->cur_altsetting->endpoint[rc_ep].desc;\n\tif (usb_endpoint_dir_in(e)) {\n\t\tif (usb_endpoint_xfer_bulk(e)) {\n\t\t\tpipe = usb_rcvbulkpipe(d->udev, rc_ep);\n\t\t\tusb_fill_bulk_urb(purb, d->udev, pipe,\n\t\t\t\t\t  purb->transfer_buffer,\n\t\t\t\t\t  RC_MSG_SIZE_V1_20,\n\t\t\t\t\t  dib0700_rc_urb_completion, d);\n\n\t\t} else if (usb_endpoint_xfer_int(e)) {\n\t\t\tpipe = usb_rcvintpipe(d->udev, rc_ep);\n\t\t\tusb_fill_int_urb(purb, d->udev, pipe,\n\t\t\t\t\t  purb->transfer_buffer,\n\t\t\t\t\t  RC_MSG_SIZE_V1_20,\n\t\t\t\t\t  dib0700_rc_urb_completion, d, 1);\n\t\t}\n\t}\n\n\tif (!pipe) {\n\t\terr(\"There's no endpoint for remote controller\");\n\t\tkfree(purb->transfer_buffer);\n\t\tusb_free_urb(purb);\n\t\treturn 0;\n\t}\n\n\tret = usb_submit_urb(purb, GFP_ATOMIC);\n\tif (ret) {\n\t\terr(\"rc submit urb failed\");\n\t\tkfree(purb->transfer_buffer);\n\t\tusb_free_urb(purb);\n\t}\n\n\treturn ret;\n}\n\nstatic int dib0700_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tint i;\n\tstruct dvb_usb_device *dev;\n\n\tfor (i = 0; i < dib0700_device_count; i++)\n\t\tif (dvb_usb_device_init(intf, &dib0700_devices[i], THIS_MODULE,\n\t\t    &dev, adapter_nr) == 0) {\n\t\t\tstruct dib0700_state *st = dev->priv;\n\t\t\tu32 hwversion, romversion, fw_version, fwtype;\n\n\t\t\tdib0700_get_version(dev, &hwversion, &romversion,\n\t\t\t\t&fw_version, &fwtype);\n\n\t\t\tdeb_info(\"Firmware version: %x, %d, 0x%x, %d\\n\",\n\t\t\t\thwversion, romversion, fw_version, fwtype);\n\n\t\t\tst->fw_version = fw_version;\n\t\t\tst->nb_packet_buffer_size = (u32)nb_packet_buffer_size;\n\n\t\t\t \n\t\t\tif (st->fw_version >= 0x10200)\n\t\t\t\tdev->props.rc.core.bulk_mode = true;\n\t\t\telse\n\t\t\t\tdev->props.rc.core.bulk_mode = false;\n\n\t\t\tdib0700_rc_setup(dev, intf);\n\n\t\t\treturn 0;\n\t\t}\n\n\treturn -ENODEV;\n}\n\nstatic void dib0700_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tstruct dib0700_state *st = d->priv;\n\tstruct i2c_client *client;\n\n\t \n\tclient = st->i2c_client_tuner;\n\tif (client) {\n\t\tmodule_put(client->dev.driver->owner);\n\t\ti2c_unregister_device(client);\n\t}\n\n\t \n\tclient = st->i2c_client_demod;\n\tif (client) {\n\t\tmodule_put(client->dev.driver->owner);\n\t\ti2c_unregister_device(client);\n\t}\n\n\tdvb_usb_device_exit(intf);\n}\n\n\nstatic struct usb_driver dib0700_driver = {\n\t.name       = \"dvb_usb_dib0700\",\n\t.probe      = dib0700_probe,\n\t.disconnect = dib0700_disconnect,\n\t.id_table   = dib0700_usb_id_table,\n};\n\nmodule_usb_driver(dib0700_driver);\n\nMODULE_FIRMWARE(\"dvb-usb-dib0700-1.20.fw\");\nMODULE_AUTHOR(\"Patrick Boettcher <patrick.boettcher@posteo.de>\");\nMODULE_DESCRIPTION(\"Driver for devices based on DiBcom DiB0700 - USB bridge\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}