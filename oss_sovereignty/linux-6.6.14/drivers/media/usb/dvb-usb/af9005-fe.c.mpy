{
  "module_name": "af9005-fe.c",
  "hash_id": "3e0b24fe954747033b9f634d90d8ed8a8b642848a669f36586867687a7bf89b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/af9005-fe.c",
  "human_readable_source": "\n \n#include \"af9005.h\"\n#include \"af9005-script.h\"\n#include \"mt2060.h\"\n#include \"qt1010.h\"\n#include <asm/div64.h>\n\nstruct af9005_fe_state {\n\tstruct dvb_usb_device *d;\n\tenum fe_status stat;\n\n\t \n\tu32 original_fcw;\n\tu16 original_rf_top;\n\tu16 original_if_top;\n\tu16 original_if_min;\n\tu16 original_aci0_if_top;\n\tu16 original_aci1_if_top;\n\tu16 original_aci0_if_min;\n\tu8 original_if_unplug_th;\n\tu8 original_rf_unplug_th;\n\tu8 original_dtop_if_unplug_th;\n\tu8 original_dtop_rf_unplug_th;\n\n\t \n\tu32 pre_vit_error_count;\n\tu32 pre_vit_bit_count;\n\tu32 ber;\n\tu32 post_vit_error_count;\n\tu32 post_vit_bit_count;\n\tu32 unc;\n\tu16 abort_count;\n\n\tint opened;\n\tint strong;\n\tunsigned long next_status_check;\n\tstruct dvb_frontend frontend;\n};\n\nstatic int af9005_write_word_agc(struct dvb_usb_device *d, u16 reghi,\n\t\t\t\t u16 reglo, u8 pos, u8 len, u16 value)\n{\n\tint ret;\n\n\tif ((ret = af9005_write_ofdm_register(d, reglo, (u8) (value & 0xff))))\n\t\treturn ret;\n\treturn af9005_write_register_bits(d, reghi, pos, len,\n\t\t\t\t\t  (u8) ((value & 0x300) >> 8));\n}\n\nstatic int af9005_read_word_agc(struct dvb_usb_device *d, u16 reghi,\n\t\t\t\tu16 reglo, u8 pos, u8 len, u16 * value)\n{\n\tint ret;\n\tu8 temp0, temp1;\n\n\tif ((ret = af9005_read_ofdm_register(d, reglo, &temp0)))\n\t\treturn ret;\n\tif ((ret = af9005_read_ofdm_register(d, reghi, &temp1)))\n\t\treturn ret;\n\tswitch (pos) {\n\tcase 0:\n\t\t*value = ((u16) (temp1 & 0x03) << 8) + (u16) temp0;\n\t\tbreak;\n\tcase 2:\n\t\t*value = ((u16) (temp1 & 0x0C) << 6) + (u16) temp0;\n\t\tbreak;\n\tcase 4:\n\t\t*value = ((u16) (temp1 & 0x30) << 4) + (u16) temp0;\n\t\tbreak;\n\tcase 6:\n\t\t*value = ((u16) (temp1 & 0xC0) << 2) + (u16) temp0;\n\t\tbreak;\n\tdefault:\n\t\terr(\"invalid pos in read word agc\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n\n}\n\nstatic int af9005_is_fecmon_available(struct dvb_frontend *fe, int *available)\n{\n\tstruct af9005_fe_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 temp;\n\n\t*available = false;\n\n\tret = af9005_read_register_bits(state->d, xd_p_fec_vtb_rsd_mon_en,\n\t\t\t\t\tfec_vtb_rsd_mon_en_pos,\n\t\t\t\t\tfec_vtb_rsd_mon_en_len, &temp);\n\tif (ret)\n\t\treturn ret;\n\tif (temp & 1) {\n\t\tret =\n\t\t    af9005_read_register_bits(state->d,\n\t\t\t\t\t      xd_p_reg_ofsm_read_rbc_en,\n\t\t\t\t\t      reg_ofsm_read_rbc_en_pos,\n\t\t\t\t\t      reg_ofsm_read_rbc_en_len, &temp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif ((temp & 1) == 0)\n\t\t\t*available = true;\n\n\t}\n\treturn 0;\n}\n\nstatic int af9005_get_post_vit_err_cw_count(struct dvb_frontend *fe,\n\t\t\t\t\t    u32 * post_err_count,\n\t\t\t\t\t    u32 * post_cw_count,\n\t\t\t\t\t    u16 * abort_count)\n{\n\tstruct af9005_fe_state *state = fe->demodulator_priv;\n\tint ret;\n\tu32 err_count;\n\tu32 cw_count;\n\tu8 temp, temp0, temp1, temp2;\n\tu16 loc_abort_count;\n\n\t*post_err_count = 0;\n\t*post_cw_count = 0;\n\n\t \n\tret =\n\t    af9005_read_register_bits(state->d, xd_r_fec_rsd_ber_rdy,\n\t\t\t\t      fec_rsd_ber_rdy_pos, fec_rsd_ber_rdy_len,\n\t\t\t\t      &temp);\n\tif (ret)\n\t\treturn ret;\n\tif (!temp) {\n\t\tdeb_info(\"rsd counter not ready\\n\");\n\t\treturn 100;\n\t}\n\t \n\tret =\n\t    af9005_read_ofdm_register(state->d,\n\t\t\t\t      xd_r_fec_rsd_abort_packet_cnt_7_0,\n\t\t\t\t      &temp0);\n\tif (ret)\n\t\treturn ret;\n\tret =\n\t    af9005_read_ofdm_register(state->d,\n\t\t\t\t      xd_r_fec_rsd_abort_packet_cnt_15_8,\n\t\t\t\t      &temp1);\n\tif (ret)\n\t\treturn ret;\n\tloc_abort_count = ((u16) temp1 << 8) + temp0;\n\n\t \n\tret =\n\t    af9005_read_ofdm_register(state->d, xd_r_fec_rsd_bit_err_cnt_7_0,\n\t\t\t\t      &temp0);\n\tif (ret)\n\t\treturn ret;\n\tret =\n\t    af9005_read_ofdm_register(state->d, xd_r_fec_rsd_bit_err_cnt_15_8,\n\t\t\t\t      &temp1);\n\tif (ret)\n\t\treturn ret;\n\tret =\n\t    af9005_read_ofdm_register(state->d, xd_r_fec_rsd_bit_err_cnt_23_16,\n\t\t\t\t      &temp2);\n\tif (ret)\n\t\treturn ret;\n\terr_count = ((u32) temp2 << 16) + ((u32) temp1 << 8) + temp0;\n\t*post_err_count = err_count - (u32) loc_abort_count *8 * 8;\n\n\t \n\tret =\n\t    af9005_read_ofdm_register(state->d, xd_p_fec_rsd_packet_unit_7_0,\n\t\t\t\t      &temp0);\n\tif (ret)\n\t\treturn ret;\n\tret =\n\t    af9005_read_ofdm_register(state->d, xd_p_fec_rsd_packet_unit_15_8,\n\t\t\t\t      &temp1);\n\tif (ret)\n\t\treturn ret;\n\tcw_count = ((u32) temp1 << 8) + temp0;\n\tif (cw_count == 0) {\n\t\terr(\"wrong RSD packet count\");\n\t\treturn -EIO;\n\t}\n\tdeb_info(\"POST abort count %d err count %d rsd packets %d\\n\",\n\t\t loc_abort_count, err_count, cw_count);\n\t*post_cw_count = cw_count - (u32) loc_abort_count;\n\t*abort_count = loc_abort_count;\n\treturn 0;\n\n}\n\nstatic int af9005_get_post_vit_ber(struct dvb_frontend *fe,\n\t\t\t\t   u32 * post_err_count, u32 * post_cw_count,\n\t\t\t\t   u16 * abort_count)\n{\n\tu32 loc_cw_count = 0, loc_err_count;\n\tu16 loc_abort_count = 0;\n\tint ret;\n\n\tret =\n\t    af9005_get_post_vit_err_cw_count(fe, &loc_err_count, &loc_cw_count,\n\t\t\t\t\t     &loc_abort_count);\n\tif (ret)\n\t\treturn ret;\n\t*post_err_count = loc_err_count;\n\t*post_cw_count = loc_cw_count * 204 * 8;\n\t*abort_count = loc_abort_count;\n\n\treturn 0;\n}\n\nstatic int af9005_get_pre_vit_err_bit_count(struct dvb_frontend *fe,\n\t\t\t\t\t    u32 * pre_err_count,\n\t\t\t\t\t    u32 * pre_bit_count)\n{\n\tstruct af9005_fe_state *state = fe->demodulator_priv;\n\tu8 temp, temp0, temp1, temp2;\n\tu32 super_frame_count, x, bits;\n\tint ret;\n\n\tret =\n\t    af9005_read_register_bits(state->d, xd_r_fec_vtb_ber_rdy,\n\t\t\t\t      fec_vtb_ber_rdy_pos, fec_vtb_ber_rdy_len,\n\t\t\t\t      &temp);\n\tif (ret)\n\t\treturn ret;\n\tif (!temp) {\n\t\tdeb_info(\"viterbi counter not ready\\n\");\n\t\treturn 101;\t \n\t}\n\tret =\n\t    af9005_read_ofdm_register(state->d, xd_r_fec_vtb_err_bit_cnt_7_0,\n\t\t\t\t      &temp0);\n\tif (ret)\n\t\treturn ret;\n\tret =\n\t    af9005_read_ofdm_register(state->d, xd_r_fec_vtb_err_bit_cnt_15_8,\n\t\t\t\t      &temp1);\n\tif (ret)\n\t\treturn ret;\n\tret =\n\t    af9005_read_ofdm_register(state->d, xd_r_fec_vtb_err_bit_cnt_23_16,\n\t\t\t\t      &temp2);\n\tif (ret)\n\t\treturn ret;\n\t*pre_err_count = ((u32) temp2 << 16) + ((u32) temp1 << 8) + temp0;\n\n\tret =\n\t    af9005_read_ofdm_register(state->d, xd_p_fec_super_frm_unit_7_0,\n\t\t\t\t      &temp0);\n\tif (ret)\n\t\treturn ret;\n\tret =\n\t    af9005_read_ofdm_register(state->d, xd_p_fec_super_frm_unit_15_8,\n\t\t\t\t      &temp1);\n\tif (ret)\n\t\treturn ret;\n\tsuper_frame_count = ((u32) temp1 << 8) + temp0;\n\tif (super_frame_count == 0) {\n\t\tdeb_info(\"super frame count 0\\n\");\n\t\treturn 102;\n\t}\n\n\t \n\tret =\n\t    af9005_read_register_bits(state->d, xd_g_reg_tpsd_txmod,\n\t\t\t\t      reg_tpsd_txmod_pos, reg_tpsd_txmod_len,\n\t\t\t\t      &temp);\n\tif (ret)\n\t\treturn ret;\n\tif (temp == 0) {\n\t\t \n\t\tx = 1512;\n\t} else if (temp == 1) {\n\t\t \n\t\tx = 6048;\n\t} else {\n\t\terr(\"Invalid fft mode\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret =\n\t    af9005_read_register_bits(state->d, xd_g_reg_tpsd_const,\n\t\t\t\t      reg_tpsd_const_pos, reg_tpsd_const_len,\n\t\t\t\t      &temp);\n\tif (ret)\n\t\treturn ret;\n\tswitch (temp) {\n\tcase 0:\t\t \n\t\tbits = 2;\n\t\tbreak;\n\tcase 1:\t\t \n\t\tbits = 4;\n\t\tbreak;\n\tcase 2:\t\t \n\t\tbits = 6;\n\t\tbreak;\n\tdefault:\n\t\terr(\"invalid modulation mode\");\n\t\treturn -EINVAL;\n\t}\n\t*pre_bit_count = super_frame_count * 68 * 4 * x * bits;\n\tdeb_info(\"PRE err count %d frame count %d bit count %d\\n\",\n\t\t *pre_err_count, super_frame_count, *pre_bit_count);\n\treturn 0;\n}\n\nstatic int af9005_reset_pre_viterbi(struct dvb_frontend *fe)\n{\n\tstruct af9005_fe_state *state = fe->demodulator_priv;\n\tint ret;\n\n\t \n\tret =\n\t    af9005_write_ofdm_register(state->d, xd_p_fec_super_frm_unit_7_0,\n\t\t\t\t       1 & 0xff);\n\tif (ret)\n\t\treturn ret;\n\tret = af9005_write_ofdm_register(state->d, xd_p_fec_super_frm_unit_15_8,\n\t\t\t\t\t 1 >> 8);\n\tif (ret)\n\t\treturn ret;\n\t \n\tret =\n\t    af9005_write_register_bits(state->d, xd_p_fec_vtb_ber_rst,\n\t\t\t\t       fec_vtb_ber_rst_pos, fec_vtb_ber_rst_len,\n\t\t\t\t       1);\n\n\treturn ret;\n}\n\nstatic int af9005_reset_post_viterbi(struct dvb_frontend *fe)\n{\n\tstruct af9005_fe_state *state = fe->demodulator_priv;\n\tint ret;\n\n\t \n\tret =\n\t    af9005_write_ofdm_register(state->d, xd_p_fec_rsd_packet_unit_7_0,\n\t\t\t\t       10000 & 0xff);\n\tif (ret)\n\t\treturn ret;\n\tret =\n\t    af9005_write_ofdm_register(state->d, xd_p_fec_rsd_packet_unit_15_8,\n\t\t\t\t       10000 >> 8);\n\tif (ret)\n\t\treturn ret;\n\t \n\tret =\n\t    af9005_write_register_bits(state->d, xd_p_fec_rsd_ber_rst,\n\t\t\t\t       fec_rsd_ber_rst_pos, fec_rsd_ber_rst_len,\n\t\t\t\t       1);\n\n\treturn ret;\n}\n\nstatic int af9005_get_statistic(struct dvb_frontend *fe)\n{\n\tstruct af9005_fe_state *state = fe->demodulator_priv;\n\tint ret, fecavailable;\n\tu64 numerator, denominator;\n\n\tdeb_info(\"GET STATISTIC\\n\");\n\tret = af9005_is_fecmon_available(fe, &fecavailable);\n\tif (ret)\n\t\treturn ret;\n\tif (!fecavailable) {\n\t\tdeb_info(\"fecmon not available\\n\");\n\t\treturn 0;\n\t}\n\n\tret = af9005_get_pre_vit_err_bit_count(fe, &state->pre_vit_error_count,\n\t\t\t\t\t       &state->pre_vit_bit_count);\n\tif (ret == 0) {\n\t\taf9005_reset_pre_viterbi(fe);\n\t\tif (state->pre_vit_bit_count > 0) {\n\t\t\t \n\t\t\tnumerator =\n\t\t\t    (u64) state->pre_vit_error_count * (u64) 1000000000;\n\t\t\tdenominator = (u64) state->pre_vit_bit_count;\n\t\t\tstate->ber = do_div(numerator, denominator);\n\t\t} else {\n\t\t\tstate->ber = 0xffffffff;\n\t\t}\n\t}\n\n\tret = af9005_get_post_vit_ber(fe, &state->post_vit_error_count,\n\t\t\t\t      &state->post_vit_bit_count,\n\t\t\t\t      &state->abort_count);\n\tif (ret == 0) {\n\t\tret = af9005_reset_post_viterbi(fe);\n\t\tstate->unc += state->abort_count;\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int af9005_fe_refresh_state(struct dvb_frontend *fe)\n{\n\tstruct af9005_fe_state *state = fe->demodulator_priv;\n\tif (time_after(jiffies, state->next_status_check)) {\n\t\tdeb_info(\"REFRESH STATE\\n\");\n\n\t\t \n\t\tif (af9005_get_statistic(fe))\n\t\t\terr(\"get_statistic_failed\");\n\t\tstate->next_status_check = jiffies + 250 * HZ / 1000;\n\t}\n\treturn 0;\n}\n\nstatic int af9005_fe_read_status(struct dvb_frontend *fe,\n\t\t\t\t enum fe_status *stat)\n{\n\tstruct af9005_fe_state *state = fe->demodulator_priv;\n\tu8 temp;\n\tint ret;\n\n\tif (fe->ops.tuner_ops.release == NULL)\n\t\treturn -ENODEV;\n\n\t*stat = 0;\n\tret = af9005_read_register_bits(state->d, xd_p_agc_lock,\n\t\t\t\t\tagc_lock_pos, agc_lock_len, &temp);\n\tif (ret)\n\t\treturn ret;\n\tif (temp)\n\t\t*stat |= FE_HAS_SIGNAL;\n\n\tret = af9005_read_register_bits(state->d, xd_p_fd_tpsd_lock,\n\t\t\t\t\tfd_tpsd_lock_pos, fd_tpsd_lock_len,\n\t\t\t\t\t&temp);\n\tif (ret)\n\t\treturn ret;\n\tif (temp)\n\t\t*stat |= FE_HAS_CARRIER;\n\n\tret = af9005_read_register_bits(state->d,\n\t\t\t\t\txd_r_mp2if_sync_byte_locked,\n\t\t\t\t\tmp2if_sync_byte_locked_pos,\n\t\t\t\t\tmp2if_sync_byte_locked_pos, &temp);\n\tif (ret)\n\t\treturn ret;\n\tif (temp)\n\t\t*stat |= FE_HAS_SYNC | FE_HAS_VITERBI | FE_HAS_LOCK;\n\tif (state->opened)\n\t\taf9005_led_control(state->d, *stat & FE_HAS_LOCK);\n\n\tret =\n\t    af9005_read_register_bits(state->d, xd_p_reg_strong_sginal_detected,\n\t\t\t\t      reg_strong_sginal_detected_pos,\n\t\t\t\t      reg_strong_sginal_detected_len, &temp);\n\tif (ret)\n\t\treturn ret;\n\tif (temp != state->strong) {\n\t\tdeb_info(\"adjust for strong signal %d\\n\", temp);\n\t\tstate->strong = temp;\n\t}\n\treturn 0;\n}\n\nstatic int af9005_fe_read_ber(struct dvb_frontend *fe, u32 * ber)\n{\n\tstruct af9005_fe_state *state = fe->demodulator_priv;\n\tif (fe->ops.tuner_ops.release  == NULL)\n\t\treturn -ENODEV;\n\taf9005_fe_refresh_state(fe);\n\t*ber = state->ber;\n\treturn 0;\n}\n\nstatic int af9005_fe_read_unc_blocks(struct dvb_frontend *fe, u32 * unc)\n{\n\tstruct af9005_fe_state *state = fe->demodulator_priv;\n\tif (fe->ops.tuner_ops.release == NULL)\n\t\treturn -ENODEV;\n\taf9005_fe_refresh_state(fe);\n\t*unc = state->unc;\n\treturn 0;\n}\n\nstatic int af9005_fe_read_signal_strength(struct dvb_frontend *fe,\n\t\t\t\t\t  u16 * strength)\n{\n\tstruct af9005_fe_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 if_gain, rf_gain;\n\n\tif (fe->ops.tuner_ops.release == NULL)\n\t\treturn -ENODEV;\n\tret =\n\t    af9005_read_ofdm_register(state->d, xd_r_reg_aagc_rf_gain,\n\t\t\t\t      &rf_gain);\n\tif (ret)\n\t\treturn ret;\n\tret =\n\t    af9005_read_ofdm_register(state->d, xd_r_reg_aagc_if_gain,\n\t\t\t\t      &if_gain);\n\tif (ret)\n\t\treturn ret;\n\t \n\t*strength = (512 - rf_gain - if_gain) << 7;\n\treturn 0;\n}\n\nstatic int af9005_fe_read_snr(struct dvb_frontend *fe, u16 * snr)\n{\n\t \n\treturn -ENOSYS;\n}\n\nstatic int af9005_fe_program_cfoe(struct dvb_usb_device *d, u32 bw)\n{\n\tu8 temp0, temp1, temp2, temp3, buf[4];\n\tint ret;\n\tu32 NS_coeff1_2048Nu;\n\tu32 NS_coeff1_8191Nu;\n\tu32 NS_coeff1_8192Nu;\n\tu32 NS_coeff1_8193Nu;\n\tu32 NS_coeff2_2k;\n\tu32 NS_coeff2_8k;\n\n\tswitch (bw) {\n\tcase 6000000:\n\t\tNS_coeff1_2048Nu = 0x2ADB6DC;\n\t\tNS_coeff1_8191Nu = 0xAB7313;\n\t\tNS_coeff1_8192Nu = 0xAB6DB7;\n\t\tNS_coeff1_8193Nu = 0xAB685C;\n\t\tNS_coeff2_2k = 0x156DB6E;\n\t\tNS_coeff2_8k = 0x55B6DC;\n\t\tbreak;\n\n\tcase 7000000:\n\t\tNS_coeff1_2048Nu = 0x3200001;\n\t\tNS_coeff1_8191Nu = 0xC80640;\n\t\tNS_coeff1_8192Nu = 0xC80000;\n\t\tNS_coeff1_8193Nu = 0xC7F9C0;\n\t\tNS_coeff2_2k = 0x1900000;\n\t\tNS_coeff2_8k = 0x640000;\n\t\tbreak;\n\n\tcase 8000000:\n\t\tNS_coeff1_2048Nu = 0x3924926;\n\t\tNS_coeff1_8191Nu = 0xE4996E;\n\t\tNS_coeff1_8192Nu = 0xE49249;\n\t\tNS_coeff1_8193Nu = 0xE48B25;\n\t\tNS_coeff2_2k = 0x1C92493;\n\t\tNS_coeff2_8k = 0x724925;\n\t\tbreak;\n\tdefault:\n\t\terr(\"Invalid bandwidth %d.\", bw);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\ttemp0 = (u8) (NS_coeff1_2048Nu & 0x000000FF);\n\ttemp1 = (u8) ((NS_coeff1_2048Nu & 0x0000FF00) >> 8);\n\ttemp2 = (u8) ((NS_coeff1_2048Nu & 0x00FF0000) >> 16);\n\ttemp3 = (u8) ((NS_coeff1_2048Nu & 0x03000000) >> 24);\n\n\t \n\tbuf[0] = temp3;\n\tbuf[1] = temp2;\n\tbuf[2] = temp1;\n\tbuf[3] = temp0;\n\n\t \n\tret = af9005_write_ofdm_register(d, 0xAE00, buf[0]);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = af9005_write_ofdm_register(d, 0xAE01, buf[1]);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = af9005_write_ofdm_register(d, 0xAE02, buf[2]);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = af9005_write_ofdm_register(d, 0xAE03, buf[3]);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\ttemp0 = (u8) ((NS_coeff2_2k & 0x0000003F));\n\ttemp1 = (u8) ((NS_coeff2_2k & 0x00003FC0) >> 6);\n\ttemp2 = (u8) ((NS_coeff2_2k & 0x003FC000) >> 14);\n\ttemp3 = (u8) ((NS_coeff2_2k & 0x01C00000) >> 22);\n\n\t \n\tbuf[0] = temp3;\n\tbuf[1] = temp2;\n\tbuf[2] = temp1;\n\tbuf[3] = temp0;\n\n\tret = af9005_write_ofdm_register(d, 0xAE04, buf[0]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = af9005_write_ofdm_register(d, 0xAE05, buf[1]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = af9005_write_ofdm_register(d, 0xAE06, buf[2]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = af9005_write_ofdm_register(d, 0xAE07, buf[3]);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\ttemp0 = (u8) ((NS_coeff1_8191Nu & 0x000000FF));\n\ttemp1 = (u8) ((NS_coeff1_8191Nu & 0x0000FF00) >> 8);\n\ttemp2 = (u8) ((NS_coeff1_8191Nu & 0x00FFC000) >> 16);\n\ttemp3 = (u8) ((NS_coeff1_8191Nu & 0x03000000) >> 24);\n\n\t \n\tbuf[0] = temp3;\n\tbuf[1] = temp2;\n\tbuf[2] = temp1;\n\tbuf[3] = temp0;\n\n\tret = af9005_write_ofdm_register(d, 0xAE08, buf[0]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = af9005_write_ofdm_register(d, 0xAE09, buf[1]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = af9005_write_ofdm_register(d, 0xAE0A, buf[2]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = af9005_write_ofdm_register(d, 0xAE0B, buf[3]);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\ttemp0 = (u8) (NS_coeff1_8192Nu & 0x000000FF);\n\ttemp1 = (u8) ((NS_coeff1_8192Nu & 0x0000FF00) >> 8);\n\ttemp2 = (u8) ((NS_coeff1_8192Nu & 0x00FFC000) >> 16);\n\ttemp3 = (u8) ((NS_coeff1_8192Nu & 0x03000000) >> 24);\n\n\t \n\tbuf[0] = temp3;\n\tbuf[1] = temp2;\n\tbuf[2] = temp1;\n\tbuf[3] = temp0;\n\n\tret = af9005_write_ofdm_register(d, 0xAE0C, buf[0]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = af9005_write_ofdm_register(d, 0xAE0D, buf[1]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = af9005_write_ofdm_register(d, 0xAE0E, buf[2]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = af9005_write_ofdm_register(d, 0xAE0F, buf[3]);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\ttemp0 = (u8) ((NS_coeff1_8193Nu & 0x000000FF));\n\ttemp1 = (u8) ((NS_coeff1_8193Nu & 0x0000FF00) >> 8);\n\ttemp2 = (u8) ((NS_coeff1_8193Nu & 0x00FFC000) >> 16);\n\ttemp3 = (u8) ((NS_coeff1_8193Nu & 0x03000000) >> 24);\n\n\t \n\tbuf[0] = temp3;\n\tbuf[1] = temp2;\n\tbuf[2] = temp1;\n\tbuf[3] = temp0;\n\n\tret = af9005_write_ofdm_register(d, 0xAE10, buf[0]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = af9005_write_ofdm_register(d, 0xAE11, buf[1]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = af9005_write_ofdm_register(d, 0xAE12, buf[2]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = af9005_write_ofdm_register(d, 0xAE13, buf[3]);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\ttemp0 = (u8) ((NS_coeff2_8k & 0x0000003F));\n\ttemp1 = (u8) ((NS_coeff2_8k & 0x00003FC0) >> 6);\n\ttemp2 = (u8) ((NS_coeff2_8k & 0x003FC000) >> 14);\n\ttemp3 = (u8) ((NS_coeff2_8k & 0x01C00000) >> 22);\n\n\t \n\tbuf[0] = temp3;\n\tbuf[1] = temp2;\n\tbuf[2] = temp1;\n\tbuf[3] = temp0;\n\n\tret = af9005_write_ofdm_register(d, 0xAE14, buf[0]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = af9005_write_ofdm_register(d, 0xAE15, buf[1]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = af9005_write_ofdm_register(d, 0xAE16, buf[2]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = af9005_write_ofdm_register(d, 0xAE17, buf[3]);\n\treturn ret;\n\n}\n\nstatic int af9005_fe_select_bw(struct dvb_usb_device *d, u32 bw)\n{\n\tu8 temp;\n\tswitch (bw) {\n\tcase 6000000:\n\t\ttemp = 0;\n\t\tbreak;\n\tcase 7000000:\n\t\ttemp = 1;\n\t\tbreak;\n\tcase 8000000:\n\t\ttemp = 2;\n\t\tbreak;\n\tdefault:\n\t\terr(\"Invalid bandwidth %d.\", bw);\n\t\treturn -EINVAL;\n\t}\n\treturn af9005_write_register_bits(d, xd_g_reg_bw, reg_bw_pos,\n\t\t\t\t\t  reg_bw_len, temp);\n}\n\nstatic int af9005_fe_power(struct dvb_frontend *fe, int on)\n{\n\tstruct af9005_fe_state *state = fe->demodulator_priv;\n\tu8 temp = on;\n\tint ret;\n\tdeb_info(\"power %s tuner\\n\", on ? \"on\" : \"off\");\n\tret = af9005_send_command(state->d, 0x03, &temp, 1, NULL, 0);\n\treturn ret;\n}\n\nstatic struct mt2060_config af9005_mt2060_config = {\n\t0xC0\n};\n\nstatic struct qt1010_config af9005_qt1010_config = {\n\t0xC4\n};\n\nstatic int af9005_fe_init(struct dvb_frontend *fe)\n{\n\tstruct af9005_fe_state *state = fe->demodulator_priv;\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tint ret, i, scriptlen;\n\tu8 temp, temp0 = 0, temp1 = 0, temp2 = 0;\n\tu8 buf[2];\n\tu16 if1;\n\n\tdeb_info(\"in af9005_fe_init\\n\");\n\n\t \n\tdeb_info(\"reset\\n\");\n\tif ((ret =\n\t     af9005_write_register_bits(state->d, xd_I2C_reg_ofdm_rst_en,\n\t\t\t\t\t4, 1, 0x01)))\n\t\treturn ret;\n\tif ((ret = af9005_write_ofdm_register(state->d, APO_REG_RESET, 0)))\n\t\treturn ret;\n\t \n\tdeb_info(\"clear ofdm reset\\n\");\n\tfor (i = 0; i < 150; i++) {\n\t\tif ((ret =\n\t\t     af9005_read_ofdm_register(state->d,\n\t\t\t\t\t       xd_I2C_reg_ofdm_rst, &temp)))\n\t\t\treturn ret;\n\t\tif (temp & (regmask[reg_ofdm_rst_len - 1] << reg_ofdm_rst_pos))\n\t\t\tbreak;\n\t\tmsleep(10);\n\t}\n\tif (i == 150)\n\t\treturn -ETIMEDOUT;\n\n\t \n\tret = af9005_write_ofdm_register(state->d, 0xb200, 0xa9);\n\tif (ret)\n\t\treturn ret;\n\tret = af9005_write_ofdm_register(state->d, xd_g_reg_ofsm_clk, 0x07);\n\tif (ret)\n\t\treturn ret;\n\ttemp = 0x01;\n\tret = af9005_send_command(state->d, 0x03, &temp, 1, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\tret = af9005_write_ofdm_register(state->d, xd_g_reg_ofsm_clk, 0x00);\n\tif (ret)\n\t\treturn ret;\n\tret = af9005_write_ofdm_register(state->d, 0xb200, 0xa1);\n\tif (ret)\n\t\treturn ret;\n\n\ttemp = regmask[reg_ofdm_rst_len - 1] << reg_ofdm_rst_pos;\n\tif ((ret =\n\t     af9005_write_register_bits(state->d, xd_I2C_reg_ofdm_rst,\n\t\t\t\t\treg_ofdm_rst_pos, reg_ofdm_rst_len, 1)))\n\t\treturn ret;\n\tret = af9005_write_register_bits(state->d, xd_I2C_reg_ofdm_rst,\n\t\t\t\t\t reg_ofdm_rst_pos, reg_ofdm_rst_len, 0);\n\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = af9005_write_ofdm_register(state->d, 0xaefc, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdeb_info(\"set stand alone chip\\n\");\n\tif ((ret =\n\t     af9005_write_register_bits(state->d, xd_p_reg_dca_stand_alone,\n\t\t\t\t\treg_dca_stand_alone_pos,\n\t\t\t\t\treg_dca_stand_alone_len, 1)))\n\t\treturn ret;\n\n\t \n\tdeb_info(\"set dca upper & lower chip\\n\");\n\tif ((ret =\n\t     af9005_write_register_bits(state->d, xd_p_reg_dca_upper_chip,\n\t\t\t\t\treg_dca_upper_chip_pos,\n\t\t\t\t\treg_dca_upper_chip_len, 0)))\n\t\treturn ret;\n\tif ((ret =\n\t     af9005_write_register_bits(state->d, xd_p_reg_dca_lower_chip,\n\t\t\t\t\treg_dca_lower_chip_pos,\n\t\t\t\t\treg_dca_lower_chip_len, 0)))\n\t\treturn ret;\n\n\t \n\tdeb_info(\"set 2wire master clock to 0x14 (for 60KHz)\\n\");\n\tif ((ret =\n\t     af9005_write_ofdm_register(state->d, xd_I2C_i2c_m_period, 0x14)))\n\t\treturn ret;\n\n\t \n\tdeb_info(\"clear dca enable chip\\n\");\n\tif ((ret =\n\t     af9005_write_register_bits(state->d, xd_p_reg_dca_en,\n\t\t\t\t\treg_dca_en_pos, reg_dca_en_len, 0)))\n\t\treturn ret;\n\t \n\tret = af9005_write_ofdm_register(state->d, 0xa16c, 1);\n\tif (ret)\n\t\treturn ret;\n\tret = af9005_write_ofdm_register(state->d, 0xa3c1, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdeb_info(\"program cfoe\\n\");\n\tret = af9005_fe_program_cfoe(state->d, 6000000);\n\tif (ret)\n\t\treturn ret;\n\t \n\tdeb_info(\"set read-update bit for modulation\\n\");\n\tif ((ret =\n\t     af9005_write_register_bits(state->d, xd_p_reg_feq_read_update,\n\t\t\t\t\treg_feq_read_update_pos,\n\t\t\t\t\treg_feq_read_update_len, 1)))\n\t\treturn ret;\n\n\t \n\n\t \n\tdeb_info(\"set read-update bit 1 for DCA modulation\\n\");\n\tif ((ret =\n\t     af9005_write_register_bits(state->d, xd_p_reg_dca_read_update,\n\t\t\t\t\treg_dca_read_update_pos,\n\t\t\t\t\treg_dca_read_update_len, 1)))\n\t\treturn ret;\n\n\t \n\tdeb_info(\"enable fec monitor\\n\");\n\tif ((ret =\n\t     af9005_write_register_bits(state->d, xd_p_fec_vtb_rsd_mon_en,\n\t\t\t\t\tfec_vtb_rsd_mon_en_pos,\n\t\t\t\t\tfec_vtb_rsd_mon_en_len, 1)))\n\t\treturn ret;\n\n\t \n\tret = af9005_write_ofdm_register(state->d, 0xa601, 0);\n\n\t \n\tdeb_info(\"set api_retrain_never_freeze\\n\");\n\tif ((ret = af9005_write_ofdm_register(state->d, 0xaefb, 0x01)))\n\t\treturn ret;\n\n\t \n\tdeb_info(\"load init script\\n\");\n\tscriptlen = sizeof(script) / sizeof(RegDesc);\n\tfor (i = 0; i < scriptlen; i++) {\n\t\tif ((ret =\n\t\t     af9005_write_register_bits(state->d, script[i].reg,\n\t\t\t\t\t\tscript[i].pos,\n\t\t\t\t\t\tscript[i].len, script[i].val)))\n\t\t\treturn ret;\n\t\t \n\t\tif (script[i].reg == 0xae18)\n\t\t\ttemp2 = script[i].val;\n\t\tif (script[i].reg == 0xae19)\n\t\t\ttemp1 = script[i].val;\n\t\tif (script[i].reg == 0xae1a)\n\t\t\ttemp0 = script[i].val;\n\n\t\t \n\t\tif (script[i].reg == xd_p_reg_unplug_th)\n\t\t\tstate->original_if_unplug_th = script[i].val;\n\t\tif (script[i].reg == xd_p_reg_unplug_rf_gain_th)\n\t\t\tstate->original_rf_unplug_th = script[i].val;\n\t\tif (script[i].reg == xd_p_reg_unplug_dtop_if_gain_th)\n\t\t\tstate->original_dtop_if_unplug_th = script[i].val;\n\t\tif (script[i].reg == xd_p_reg_unplug_dtop_rf_gain_th)\n\t\t\tstate->original_dtop_rf_unplug_th = script[i].val;\n\n\t}\n\tstate->original_fcw =\n\t    ((u32) temp2 << 16) + ((u32) temp1 << 8) + (u32) temp0;\n\n\n\t \n\tdeb_info(\"save original TOPs\\n\");\n\n\t \n\tret =\n\t    af9005_read_word_agc(state->d,\n\t\t\t\t xd_p_reg_aagc_rf_top_numerator_9_8,\n\t\t\t\t xd_p_reg_aagc_rf_top_numerator_7_0, 0, 2,\n\t\t\t\t &state->original_rf_top);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret =\n\t    af9005_read_word_agc(state->d,\n\t\t\t\t xd_p_reg_aagc_if_top_numerator_9_8,\n\t\t\t\t xd_p_reg_aagc_if_top_numerator_7_0, 0, 2,\n\t\t\t\t &state->original_if_top);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret =\n\t    af9005_read_word_agc(state->d, 0xA60E, 0xA60A, 4, 2,\n\t\t\t\t &state->original_aci0_if_top);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret =\n\t    af9005_read_word_agc(state->d, 0xA60E, 0xA60B, 6, 2,\n\t\t\t\t &state->original_aci1_if_top);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (fe->ops.tuner_ops.release == NULL) {\n\t\t \n\t\tret = af9005_read_eeprom(adap->dev, 0xc6, buf, 2);\n\t\tif (ret) {\n\t\t\terr(\"Impossible to read EEPROM\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tdeb_info(\"Tuner id %d, board id %d\\n\", buf[0], buf[1]);\n\t\tswitch (buf[0]) {\n\t\tcase 2:\t \n\t\t\t \n\t\t\tret = af9005_read_eeprom(adap->dev, 0xc8, buf, 2);\n\t\t\tif (ret) {\n\t\t\t\terr(\"Impossible to read EEPROM\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tif1 = (u16) (buf[0] << 8) + buf[1];\n\t\t\tif (dvb_attach(mt2060_attach, fe, &adap->dev->i2c_adap,\n\t\t\t\t\t &af9005_mt2060_config, if1) == NULL) {\n\t\t\t\tdeb_info(\"MT2060 attach failed\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\t \n\t\tcase 9:\t \n\t\t\tif (dvb_attach(qt1010_attach, fe, &adap->dev->i2c_adap,\n\t\t\t\t\t&af9005_qt1010_config) ==NULL) {\n\t\t\t\tdeb_info(\"QT1010 attach failed\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr(\"Unsupported tuner type %d\", buf[0]);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tret = fe->ops.tuner_ops.init(fe);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdeb_info(\"profit!\\n\");\n\treturn 0;\n}\n\nstatic int af9005_fe_sleep(struct dvb_frontend *fe)\n{\n\treturn af9005_fe_power(fe, 0);\n}\n\nstatic int af9005_ts_bus_ctrl(struct dvb_frontend *fe, int acquire)\n{\n\tstruct af9005_fe_state *state = fe->demodulator_priv;\n\n\tif (acquire) {\n\t\tstate->opened++;\n\t} else {\n\n\t\tstate->opened--;\n\t\tif (!state->opened)\n\t\t\taf9005_led_control(state->d, 0);\n\t}\n\treturn 0;\n}\n\nstatic int af9005_fe_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *fep = &fe->dtv_property_cache;\n\tstruct af9005_fe_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 temp, temp0, temp1, temp2;\n\n\tdeb_info(\"af9005_fe_set_frontend freq %d bw %d\\n\", fep->frequency,\n\t\t fep->bandwidth_hz);\n\tif (fe->ops.tuner_ops.release == NULL) {\n\t\terr(\"Tuner not attached\");\n\t\treturn -ENODEV;\n\t}\n\n\tdeb_info(\"turn off led\\n\");\n\t \n\tret = af9005_led_control(state->d, 0);\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = af9005_write_register_bits(state->d, XD_MP2IF_MISC, 2, 1, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdeb_info(\"set FCW to default value\\n\");\n\ttemp0 = (u8) (state->original_fcw & 0x000000ff);\n\ttemp1 = (u8) ((state->original_fcw & 0x0000ff00) >> 8);\n\ttemp2 = (u8) ((state->original_fcw & 0x00ff0000) >> 16);\n\tret = af9005_write_ofdm_register(state->d, 0xae1a, temp0);\n\tif (ret)\n\t\treturn ret;\n\tret = af9005_write_ofdm_register(state->d, 0xae19, temp1);\n\tif (ret)\n\t\treturn ret;\n\tret = af9005_write_ofdm_register(state->d, 0xae18, temp2);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdeb_info(\"restore original TOPs\\n\");\n\tret =\n\t    af9005_write_word_agc(state->d,\n\t\t\t\t  xd_p_reg_aagc_rf_top_numerator_9_8,\n\t\t\t\t  xd_p_reg_aagc_rf_top_numerator_7_0, 0, 2,\n\t\t\t\t  state->original_rf_top);\n\tif (ret)\n\t\treturn ret;\n\tret =\n\t    af9005_write_word_agc(state->d,\n\t\t\t\t  xd_p_reg_aagc_if_top_numerator_9_8,\n\t\t\t\t  xd_p_reg_aagc_if_top_numerator_7_0, 0, 2,\n\t\t\t\t  state->original_if_top);\n\tif (ret)\n\t\treturn ret;\n\tret =\n\t    af9005_write_word_agc(state->d, 0xA60E, 0xA60A, 4, 2,\n\t\t\t\t  state->original_aci0_if_top);\n\tif (ret)\n\t\treturn ret;\n\tret =\n\t    af9005_write_word_agc(state->d, 0xA60E, 0xA60B, 6, 2,\n\t\t\t\t  state->original_aci1_if_top);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdeb_info(\"select bandwidth\");\n\tret = af9005_fe_select_bw(state->d, fep->bandwidth_hz);\n\tif (ret)\n\t\treturn ret;\n\tret = af9005_fe_program_cfoe(state->d, fep->bandwidth_hz);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdeb_info(\"clear easy mode flag\\n\");\n\tret = af9005_write_ofdm_register(state->d, 0xaefd, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdeb_info(\"set unplug threshold to original value\\n\");\n\tret =\n\t    af9005_write_ofdm_register(state->d, xd_p_reg_unplug_th,\n\t\t\t\t       state->original_if_unplug_th);\n\tif (ret)\n\t\treturn ret;\n\t \n\tdeb_info(\"set tuner\\n\");\n\tret = fe->ops.tuner_ops.set_params(fe);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdeb_info(\"trigger ofsm\\n\");\n\ttemp = 0;\n\tret = af9005_write_tuner_registers(state->d, 0xffff, &temp, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdeb_info(\"clear retrain and freeze flag\\n\");\n\tret =\n\t    af9005_write_register_bits(state->d,\n\t\t\t\t       xd_p_reg_api_retrain_request,\n\t\t\t\t       reg_api_retrain_request_pos, 2, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\taf9005_reset_pre_viterbi(fe);\n\taf9005_reset_post_viterbi(fe);\n\tstate->pre_vit_error_count = 0;\n\tstate->pre_vit_bit_count = 0;\n\tstate->ber = 0;\n\tstate->post_vit_error_count = 0;\n\t \n\tstate->abort_count = 0;\n\n\tstate->next_status_check = jiffies;\n\tstate->strong = -1;\n\n\treturn 0;\n}\n\nstatic int af9005_fe_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t  struct dtv_frontend_properties *fep)\n{\n\tstruct af9005_fe_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 temp;\n\n\t \n\tret =\n\t    af9005_read_register_bits(state->d, xd_g_reg_tpsd_const,\n\t\t\t\t      reg_tpsd_const_pos, reg_tpsd_const_len,\n\t\t\t\t      &temp);\n\tif (ret)\n\t\treturn ret;\n\tdeb_info(\"===== fe_get_frontend_legacy = =============\\n\");\n\tdeb_info(\"CONSTELLATION \");\n\tswitch (temp) {\n\tcase 0:\n\t\tfep->modulation = QPSK;\n\t\tdeb_info(\"QPSK\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tfep->modulation = QAM_16;\n\t\tdeb_info(\"QAM_16\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tfep->modulation = QAM_64;\n\t\tdeb_info(\"QAM_64\\n\");\n\t\tbreak;\n\t}\n\n\t \n\tret =\n\t    af9005_read_register_bits(state->d, xd_g_reg_tpsd_hier,\n\t\t\t\t      reg_tpsd_hier_pos, reg_tpsd_hier_len,\n\t\t\t\t      &temp);\n\tif (ret)\n\t\treturn ret;\n\tdeb_info(\"HIERARCHY \");\n\tswitch (temp) {\n\tcase 0:\n\t\tfep->hierarchy = HIERARCHY_NONE;\n\t\tdeb_info(\"NONE\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tfep->hierarchy = HIERARCHY_1;\n\t\tdeb_info(\"1\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tfep->hierarchy = HIERARCHY_2;\n\t\tdeb_info(\"2\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tfep->hierarchy = HIERARCHY_4;\n\t\tdeb_info(\"4\\n\");\n\t\tbreak;\n\t}\n\n\t \n\tret =\n\t    af9005_read_register_bits(state->d, xd_g_reg_dec_pri,\n\t\t\t\t      reg_dec_pri_pos, reg_dec_pri_len, &temp);\n\tif (ret)\n\t\treturn ret;\n\t \n\tdeb_info(\"PRIORITY %s\\n\", temp ? \"high\" : \"low\");\n\n\t \n\tret =\n\t    af9005_read_register_bits(state->d, xd_g_reg_tpsd_hpcr,\n\t\t\t\t      reg_tpsd_hpcr_pos, reg_tpsd_hpcr_len,\n\t\t\t\t      &temp);\n\tif (ret)\n\t\treturn ret;\n\tdeb_info(\"CODERATE HP \");\n\tswitch (temp) {\n\tcase 0:\n\t\tfep->code_rate_HP = FEC_1_2;\n\t\tdeb_info(\"FEC_1_2\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tfep->code_rate_HP = FEC_2_3;\n\t\tdeb_info(\"FEC_2_3\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tfep->code_rate_HP = FEC_3_4;\n\t\tdeb_info(\"FEC_3_4\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tfep->code_rate_HP = FEC_5_6;\n\t\tdeb_info(\"FEC_5_6\\n\");\n\t\tbreak;\n\tcase 4:\n\t\tfep->code_rate_HP = FEC_7_8;\n\t\tdeb_info(\"FEC_7_8\\n\");\n\t\tbreak;\n\t}\n\n\t \n\tret =\n\t    af9005_read_register_bits(state->d, xd_g_reg_tpsd_lpcr,\n\t\t\t\t      reg_tpsd_lpcr_pos, reg_tpsd_lpcr_len,\n\t\t\t\t      &temp);\n\tif (ret)\n\t\treturn ret;\n\tdeb_info(\"CODERATE LP \");\n\tswitch (temp) {\n\tcase 0:\n\t\tfep->code_rate_LP = FEC_1_2;\n\t\tdeb_info(\"FEC_1_2\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tfep->code_rate_LP = FEC_2_3;\n\t\tdeb_info(\"FEC_2_3\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tfep->code_rate_LP = FEC_3_4;\n\t\tdeb_info(\"FEC_3_4\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tfep->code_rate_LP = FEC_5_6;\n\t\tdeb_info(\"FEC_5_6\\n\");\n\t\tbreak;\n\tcase 4:\n\t\tfep->code_rate_LP = FEC_7_8;\n\t\tdeb_info(\"FEC_7_8\\n\");\n\t\tbreak;\n\t}\n\n\t \n\tret =\n\t    af9005_read_register_bits(state->d, xd_g_reg_tpsd_gi,\n\t\t\t\t      reg_tpsd_gi_pos, reg_tpsd_gi_len, &temp);\n\tif (ret)\n\t\treturn ret;\n\tdeb_info(\"GUARD INTERVAL \");\n\tswitch (temp) {\n\tcase 0:\n\t\tfep->guard_interval = GUARD_INTERVAL_1_32;\n\t\tdeb_info(\"1_32\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tfep->guard_interval = GUARD_INTERVAL_1_16;\n\t\tdeb_info(\"1_16\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tfep->guard_interval = GUARD_INTERVAL_1_8;\n\t\tdeb_info(\"1_8\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tfep->guard_interval = GUARD_INTERVAL_1_4;\n\t\tdeb_info(\"1_4\\n\");\n\t\tbreak;\n\t}\n\n\t \n\tret =\n\t    af9005_read_register_bits(state->d, xd_g_reg_tpsd_txmod,\n\t\t\t\t      reg_tpsd_txmod_pos, reg_tpsd_txmod_len,\n\t\t\t\t      &temp);\n\tif (ret)\n\t\treturn ret;\n\tdeb_info(\"TRANSMISSION MODE \");\n\tswitch (temp) {\n\tcase 0:\n\t\tfep->transmission_mode = TRANSMISSION_MODE_2K;\n\t\tdeb_info(\"2K\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tfep->transmission_mode = TRANSMISSION_MODE_8K;\n\t\tdeb_info(\"8K\\n\");\n\t\tbreak;\n\t}\n\n\t \n\tret =\n\t    af9005_read_register_bits(state->d, xd_g_reg_bw, reg_bw_pos,\n\t\t\t\t      reg_bw_len, &temp);\n\tdeb_info(\"BANDWIDTH \");\n\tswitch (temp) {\n\tcase 0:\n\t\tfep->bandwidth_hz = 6000000;\n\t\tdeb_info(\"6\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tfep->bandwidth_hz = 7000000;\n\t\tdeb_info(\"7\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tfep->bandwidth_hz = 8000000;\n\t\tdeb_info(\"8\\n\");\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void af9005_fe_release(struct dvb_frontend *fe)\n{\n\tstruct af9005_fe_state *state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops af9005_fe_ops;\n\nstruct dvb_frontend *af9005_fe_attach(struct dvb_usb_device *d)\n{\n\tstruct af9005_fe_state *state = NULL;\n\n\t \n\tstate = kzalloc(sizeof(struct af9005_fe_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\tdeb_info(\"attaching frontend af9005\\n\");\n\n\tstate->d = d;\n\tstate->opened = 0;\n\n\tmemcpy(&state->frontend.ops, &af9005_fe_ops,\n\t       sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\n\treturn &state->frontend;\n      error:\n\treturn NULL;\n}\n\nstatic const struct dvb_frontend_ops af9005_fe_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t .name = \"AF9005 USB DVB-T\",\n\t\t .frequency_min_hz =    44250 * kHz,\n\t\t .frequency_max_hz =   867250 * kHz,\n\t\t .frequency_stepsize_hz = 250 * kHz,\n\t\t .caps = FE_CAN_INVERSION_AUTO |\n\t\t FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |\n\t\t FE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_RECOVER |\n\t\t FE_CAN_HIERARCHY_AUTO,\n\t\t },\n\n\t.release = af9005_fe_release,\n\n\t.init = af9005_fe_init,\n\t.sleep = af9005_fe_sleep,\n\t.ts_bus_ctrl = af9005_ts_bus_ctrl,\n\n\t.set_frontend = af9005_fe_set_frontend,\n\t.get_frontend = af9005_fe_get_frontend,\n\n\t.read_status = af9005_fe_read_status,\n\t.read_ber = af9005_fe_read_ber,\n\t.read_signal_strength = af9005_fe_read_signal_strength,\n\t.read_snr = af9005_fe_read_snr,\n\t.read_ucblocks = af9005_fe_read_unc_blocks,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}