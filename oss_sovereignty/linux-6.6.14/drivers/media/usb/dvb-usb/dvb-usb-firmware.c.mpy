{
  "module_name": "dvb-usb-firmware.c",
  "hash_id": "143e99277991e2d91a5167581bb9ca506f9a292e02533dffa5c84229a9eaf075",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/dvb-usb-firmware.c",
  "human_readable_source": "\n \n#include \"dvb-usb-common.h\"\n\n#include <linux/usb.h>\n\nstruct usb_cypress_controller {\n\tint id;\n\tconst char *name;        \n\tu16 cpu_cs_register;     \n};\n\nstatic struct usb_cypress_controller cypress[] = {\n\t{ .id = DEVICE_SPECIFIC, .name = \"Device specific\", .cpu_cs_register = 0 },\n\t{ .id = CYPRESS_AN2135,  .name = \"Cypress AN2135\",  .cpu_cs_register = 0x7f92 },\n\t{ .id = CYPRESS_AN2235,  .name = \"Cypress AN2235\",  .cpu_cs_register = 0x7f92 },\n\t{ .id = CYPRESS_FX2,     .name = \"Cypress FX2\",     .cpu_cs_register = 0xe600 },\n};\n\n \nstatic int usb_cypress_writemem(struct usb_device *udev,u16 addr,u8 *data, u8 len)\n{\n\treturn usb_control_msg(udev, usb_sndctrlpipe(udev,0),\n\t\t\t0xa0, USB_TYPE_VENDOR, addr, 0x00, data, len, 5000);\n}\n\nint usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\n{\n\tstruct hexline *hx;\n\tu8 *buf;\n\tint ret, pos = 0;\n\tu16 cpu_cs_register = cypress[type].cpu_cs_register;\n\n\tbuf = kmalloc(sizeof(*hx), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\thx = (struct hexline *)buf;\n\n\t \n\tbuf[0] = 1;\n\tif (usb_cypress_writemem(udev, cpu_cs_register, buf, 1) != 1)\n\t\terr(\"could not stop the USB controller CPU.\");\n\n\twhile ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {\n\t\tdeb_fw(\"writing to address 0x%04x (buffer: 0x%02x %02x)\\n\", hx->addr, hx->len, hx->chk);\n\t\tret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\n\n\t\tif (ret != hx->len) {\n\t\t\terr(\"error while transferring firmware (transferred size: %d, block size: %d)\",\n\t\t\t\tret, hx->len);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\terr(\"firmware download failed at %d with %d\",pos,ret);\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\tif (ret == 0) {\n\t\t \n\t\tbuf[0] = 0;\n\t\tif (usb_cypress_writemem(udev, cpu_cs_register, buf, 1) != 1) {\n\t\t\terr(\"could not restart the USB controller CPU.\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else\n\t\tret = -EIO;\n\n\tkfree(buf);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(usb_cypress_load_firmware);\n\nint dvb_usb_download_firmware(struct usb_device *udev,\n\t\t\t      const struct dvb_usb_device_properties *props)\n{\n\tint ret;\n\tconst struct firmware *fw = NULL;\n\n\tif ((ret = request_firmware(&fw, props->firmware, &udev->dev)) != 0) {\n\t\terr(\"did not find the firmware file '%s' (status %d). You can use <kernel_dir>/scripts/get_dvb_firmware to get the firmware\",\n\t\t\tprops->firmware,ret);\n\t\treturn ret;\n\t}\n\n\tinfo(\"downloading firmware from file '%s'\",props->firmware);\n\n\tswitch (props->usb_ctrl) {\n\t\tcase CYPRESS_AN2135:\n\t\tcase CYPRESS_AN2235:\n\t\tcase CYPRESS_FX2:\n\t\t\tret = usb_cypress_load_firmware(udev, fw, props->usb_ctrl);\n\t\t\tbreak;\n\t\tcase DEVICE_SPECIFIC:\n\t\t\tif (props->download_firmware)\n\t\t\t\tret = props->download_firmware(udev,fw);\n\t\t\telse {\n\t\t\t\terr(\"BUG: driver didn't specified a download_firmware-callback, although it claims to have a DEVICE_SPECIFIC one.\");\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t}\n\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nint dvb_usb_get_hexline(const struct firmware *fw, struct hexline *hx,\n\t\t\t       int *pos)\n{\n\tu8 *b = (u8 *) &fw->data[*pos];\n\tint data_offs = 4;\n\tif (*pos >= fw->size)\n\t\treturn 0;\n\n\tmemset(hx,0,sizeof(struct hexline));\n\n\thx->len  = b[0];\n\n\tif ((*pos + hx->len + 4) >= fw->size)\n\t\treturn -EINVAL;\n\n\thx->addr = b[1] | (b[2] << 8);\n\thx->type = b[3];\n\n\tif (hx->type == 0x04) {\n\t\t \n\t\thx->addr |= (b[4] << 24) | (b[5] << 16);\n \n\t}\n\tmemcpy(hx->data,&b[data_offs],hx->len);\n\thx->chk = b[hx->len + data_offs];\n\n\t*pos += hx->len + 5;\n\n\treturn *pos;\n}\nEXPORT_SYMBOL(dvb_usb_get_hexline);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}