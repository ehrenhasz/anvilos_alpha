{
  "module_name": "opera1.c",
  "hash_id": "7f8af2a450f3eea0de1334ca28d62bca4301513dcfb3a9b2c70bae2229c53568",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/opera1.c",
  "human_readable_source": "\n \n\n#define DVB_USB_LOG_PREFIX \"opera\"\n\n#include \"dvb-usb.h\"\n#include \"stv0299.h\"\n\n#define OPERA_READ_MSG 0\n#define OPERA_WRITE_MSG 1\n#define OPERA_I2C_TUNER 0xd1\n\n#define READ_FX2_REG_REQ  0xba\n#define READ_MAC_ADDR 0x08\n#define OPERA_WRITE_FX2 0xbb\n#define OPERA_TUNER_REQ 0xb1\n#define REG_1F_SYMBOLRATE_BYTE0 0x1f\n#define REG_20_SYMBOLRATE_BYTE1 0x20\n#define REG_21_SYMBOLRATE_BYTE2 0x21\n\n#define ADDR_B600_VOLTAGE_13V (0x02)\n#define ADDR_B601_VOLTAGE_18V (0x03)\n#define ADDR_B1A6_STREAM_CTRL (0x04)\n#define ADDR_B880_READ_REMOTE (0x05)\n\nstruct opera1_state {\n\tu32 last_key_pressed;\n};\nstruct rc_map_opera_table {\n\tu32 keycode;\n\tu32 event;\n};\n\nstatic int dvb_usb_opera1_debug;\nmodule_param_named(debug, dvb_usb_opera1_debug, int, 0644);\nMODULE_PARM_DESC(debug,\n\t\t \"set debugging level (1=info,xfer=2,pll=4,ts=8,err=16,rc=32,fw=64 (or-able)).\"\n\t\t DVB_USB_DEBUG_STATUS);\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n\nstatic int opera1_xilinx_rw(struct usb_device *dev, u8 request, u16 value,\n\t\t\t    u8 * data, u16 len, int flags)\n{\n\tint ret;\n\tu8 tmp;\n\tu8 *buf;\n\tunsigned int pipe = (flags == OPERA_READ_MSG) ?\n\t\tusb_rcvctrlpipe(dev,0) : usb_sndctrlpipe(dev, 0);\n\tu8 request_type = (flags == OPERA_READ_MSG) ? USB_DIR_IN : USB_DIR_OUT;\n\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (flags == OPERA_WRITE_MSG)\n\t\tmemcpy(buf, data, len);\n\tret = usb_control_msg(dev, pipe, request,\n\t\t\trequest_type | USB_TYPE_VENDOR, value, 0x0,\n\t\t\tbuf, len, 2000);\n\n\tif (request == OPERA_TUNER_REQ) {\n\t\ttmp = buf[0];\n\t\tif (usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t    OPERA_TUNER_REQ, USB_DIR_IN | USB_TYPE_VENDOR,\n\t\t\t    0x01, 0x0, buf, 1, 2000) < 1 || buf[0] != 0x08) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tbuf[0] = tmp;\n\t}\n\tif (flags == OPERA_READ_MSG)\n\t\tmemcpy(data, buf, len);\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\n \n\nstatic int opera1_usb_i2c_msgxfer(struct dvb_usb_device *dev, u16 addr,\n\t\t\t\t  u8 * buf, u16 len)\n{\n\tint ret = 0;\n\tu8 request;\n\tu16 value;\n\n\tif (!dev) {\n\t\tinfo(\"no usb_device\");\n\t\treturn -EINVAL;\n\t}\n\tif (mutex_lock_interruptible(&dev->usb_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tswitch (addr>>1){\n\t\tcase ADDR_B600_VOLTAGE_13V:\n\t\t\trequest=0xb6;\n\t\t\tvalue=0x00;\n\t\t\tbreak;\n\t\tcase ADDR_B601_VOLTAGE_18V:\n\t\t\trequest=0xb6;\n\t\t\tvalue=0x01;\n\t\t\tbreak;\n\t\tcase ADDR_B1A6_STREAM_CTRL:\n\t\t\trequest=0xb1;\n\t\t\tvalue=0xa6;\n\t\t\tbreak;\n\t\tcase ADDR_B880_READ_REMOTE:\n\t\t\trequest=0xb8;\n\t\t\tvalue=0x80;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trequest=0xb1;\n\t\t\tvalue=addr;\n\t}\n\tret = opera1_xilinx_rw(dev->udev, request,\n\t\tvalue, buf, len,\n\t\taddr&0x01?OPERA_READ_MSG:OPERA_WRITE_MSG);\n\n\tmutex_unlock(&dev->usb_mutex);\n\treturn ret;\n}\n\nstatic int opera1_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t   int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint i = 0, tmp = 0;\n\n\tif (!d)\n\t\treturn -ENODEV;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tfor (i = 0; i < num; i++) {\n\t\tif ((tmp = opera1_usb_i2c_msgxfer(d,\n\t\t\t\t\t(msg[i].addr<<1)|(msg[i].flags&I2C_M_RD?0x01:0),\n\t\t\t\t\tmsg[i].buf,\n\t\t\t\t\tmsg[i].len\n\t\t\t\t\t)) != msg[i].len) {\n\t\t\tbreak;\n\t\t}\n\t\tif (dvb_usb_opera1_debug & 0x10)\n\t\t\tinfo(\"sending i2c message %d %d\", tmp, msg[i].len);\n\t}\n\tmutex_unlock(&d->i2c_mutex);\n\treturn num;\n}\n\nstatic u32 opera1_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm opera1_i2c_algo = {\n\t.master_xfer = opera1_i2c_xfer,\n\t.functionality = opera1_i2c_func,\n};\n\nstatic int opera1_set_voltage(struct dvb_frontend *fe,\n\t\t\t      enum fe_sec_voltage voltage)\n{\n\tstatic u8 command_13v[1]={0x00};\n\tstatic u8 command_18v[1]={0x01};\n\tstruct i2c_msg msg[] = {\n\t\t{.addr = ADDR_B600_VOLTAGE_13V,.flags = 0,.buf = command_13v,.len = 1},\n\t};\n\tstruct dvb_usb_adapter *udev_adap = fe->dvb->priv;\n\tif (voltage == SEC_VOLTAGE_18) {\n\t\tmsg[0].addr = ADDR_B601_VOLTAGE_18V;\n\t\tmsg[0].buf = command_18v;\n\t}\n\ti2c_transfer(&udev_adap->dev->i2c_adap, msg, 1);\n\treturn 0;\n}\n\nstatic int opera1_stv0299_set_symbol_rate(struct dvb_frontend *fe, u32 srate,\n\t\t\t\t\t  u32 ratio)\n{\n\tstv0299_writereg(fe, 0x13, 0x98);\n\tstv0299_writereg(fe, 0x14, 0x95);\n\tstv0299_writereg(fe, REG_1F_SYMBOLRATE_BYTE0, (ratio >> 16) & 0xff);\n\tstv0299_writereg(fe, REG_20_SYMBOLRATE_BYTE1, (ratio >> 8) & 0xff);\n\tstv0299_writereg(fe, REG_21_SYMBOLRATE_BYTE2, (ratio) & 0xf0);\n\treturn 0;\n\n}\nstatic u8 opera1_inittab[] = {\n\t0x00, 0xa1,\n\t0x01, 0x15,\n\t0x02, 0x30,\n\t0x03, 0x00,\n\t0x04, 0x7d,\n\t0x05, 0x05,\n\t0x06, 0x02,\n\t0x07, 0x00,\n\t0x0b, 0x00,\n\t0x0c, 0x01,\n\t0x0d, 0x81,\n\t0x0e, 0x44,\n\t0x0f, 0x19,\n\t0x10, 0x3f,\n\t0x11, 0x84,\n\t0x12, 0xda,\n\t0x13, 0x98,\n\t0x14, 0x95,\n\t0x15, 0xc9,\n\t0x16, 0xeb,\n\t0x17, 0x00,\n\t0x18, 0x19,\n\t0x19, 0x8b,\n\t0x1a, 0x00,\n\t0x1b, 0x82,\n\t0x1c, 0x7f,\n\t0x1d, 0x00,\n\t0x1e, 0x00,\n\tREG_1F_SYMBOLRATE_BYTE0, 0x06,\n\tREG_20_SYMBOLRATE_BYTE1, 0x50,\n\tREG_21_SYMBOLRATE_BYTE2, 0x10,\n\t0x22, 0x00,\n\t0x23, 0x00,\n\t0x24, 0x37,\n\t0x25, 0xbc,\n\t0x26, 0x00,\n\t0x27, 0x00,\n\t0x28, 0x00,\n\t0x29, 0x1e,\n\t0x2a, 0x14,\n\t0x2b, 0x1f,\n\t0x2c, 0x09,\n\t0x2d, 0x0a,\n\t0x2e, 0x00,\n\t0x2f, 0x00,\n\t0x30, 0x00,\n\t0x31, 0x1f,\n\t0x32, 0x19,\n\t0x33, 0xfc,\n\t0x34, 0x13,\n\t0xff, 0xff,\n};\n\nstatic struct stv0299_config opera1_stv0299_config = {\n\t.demod_address = 0xd0>>1,\n\t.min_delay_ms = 100,\n\t.mclk = 88000000UL,\n\t.invert = 1,\n\t.skip_reinit = 0,\n\t.lock_output = STV0299_LOCKOUTPUT_0,\n\t.volt13_op0_op1 = STV0299_VOLT13_OP0,\n\t.inittab = opera1_inittab,\n\t.set_symbol_rate = opera1_stv0299_set_symbol_rate,\n};\n\nstatic int opera1_frontend_attach(struct dvb_usb_adapter *d)\n{\n\td->fe_adap[0].fe = dvb_attach(stv0299_attach, &opera1_stv0299_config,\n\t\t\t\t      &d->dev->i2c_adap);\n\tif ((d->fe_adap[0].fe) != NULL) {\n\t\td->fe_adap[0].fe->ops.set_voltage = opera1_set_voltage;\n\t\treturn 0;\n\t}\n\tinfo(\"not attached stv0299\");\n\treturn -EIO;\n}\n\nstatic int opera1_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdvb_attach(\n\t\tdvb_pll_attach, adap->fe_adap[0].fe, 0xc0>>1,\n\t\t&adap->dev->i2c_adap, DVB_PLL_OPERA1\n\t);\n\treturn 0;\n}\n\nstatic int opera1_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tu8 val = onoff ? 0x01 : 0x00;\n\n\tif (dvb_usb_opera1_debug)\n\t\tinfo(\"power %s\", onoff ? \"on\" : \"off\");\n\treturn opera1_xilinx_rw(d->udev, 0xb7, val,\n\t\t\t\t&val, 1, OPERA_WRITE_MSG);\n}\n\nstatic int opera1_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\n{\n\tstatic u8 buf_start[2] = { 0xff, 0x03 };\n\tstatic u8 buf_stop[2] = { 0xff, 0x00 };\n\tstruct i2c_msg start_tuner[] = {\n\t\t{.addr = ADDR_B1A6_STREAM_CTRL,.buf = onoff ? buf_start : buf_stop,.len = 2},\n\t};\n\tif (dvb_usb_opera1_debug)\n\t\tinfo(\"streaming %s\", onoff ? \"on\" : \"off\");\n\ti2c_transfer(&adap->dev->i2c_adap, start_tuner, 1);\n\treturn 0;\n}\n\nstatic int opera1_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid,\n\t\t\t     int onoff)\n{\n\tu8 b_pid[3];\n\tstruct i2c_msg msg[] = {\n\t\t{.addr = ADDR_B1A6_STREAM_CTRL,.buf = b_pid,.len = 3},\n\t};\n\tif (dvb_usb_opera1_debug)\n\t\tinfo(\"pidfilter index: %d pid: %d %s\", index, pid,\n\t\t\tonoff ? \"on\" : \"off\");\n\tb_pid[0] = (2 * index) + 4;\n\tb_pid[1] = onoff ? (pid & 0xff) : (0x00);\n\tb_pid[2] = onoff ? ((pid >> 8) & 0xff) : (0x00);\n\ti2c_transfer(&adap->dev->i2c_adap, msg, 1);\n\treturn 0;\n}\n\nstatic int opera1_pid_filter_control(struct dvb_usb_adapter *adap, int onoff)\n{\n\tint u = 0x04;\n\tu8 b_pid[3];\n\tstruct i2c_msg msg[] = {\n\t\t{.addr = ADDR_B1A6_STREAM_CTRL,.buf = b_pid,.len = 3},\n\t};\n\tif (dvb_usb_opera1_debug)\n\t\tinfo(\"%s hw-pidfilter\", onoff ? \"enable\" : \"disable\");\n\tfor (; u < 0x7e; u += 2) {\n\t\tb_pid[0] = u;\n\t\tb_pid[1] = 0;\n\t\tb_pid[2] = 0x80;\n\t\ti2c_transfer(&adap->dev->i2c_adap, msg, 1);\n\t}\n\treturn 0;\n}\n\nstatic struct rc_map_table rc_map_opera1_table[] = {\n\t{0x5fa0, KEY_1},\n\t{0x51af, KEY_2},\n\t{0x5da2, KEY_3},\n\t{0x41be, KEY_4},\n\t{0x0bf5, KEY_5},\n\t{0x43bd, KEY_6},\n\t{0x47b8, KEY_7},\n\t{0x49b6, KEY_8},\n\t{0x05fa, KEY_9},\n\t{0x45ba, KEY_0},\n\t{0x09f6, KEY_CHANNELUP},\t \n\t{0x1be5, KEY_CHANNELDOWN},\t \n\t{0x5da3, KEY_VOLUMEDOWN},\t \n\t{0x5fa1, KEY_VOLUMEUP},\t\t \n\t{0x07f8, KEY_SPACE},\t\t \n\t{0x1fe1, KEY_OK},\t\t \n\t{0x1be4, KEY_ZOOM},\t\t \n\t{0x59a6, KEY_MUTE},\t\t \n\t{0x5ba5, KEY_RADIO},\t\t \n\t{0x19e7, KEY_RECORD},\t\t \n\t{0x01fe, KEY_STOP},\t\t \n\t{0x03fd, KEY_PAUSE},\t\t \n\t{0x03fc, KEY_SCREEN},\t\t \n\t{0x07f9, KEY_CAMERA},\t\t \n\t{0x47b9, KEY_ESC},\t\t \n\t{0x43bc, KEY_POWER2},\t\t \n};\n\nstatic int opera1_rc_query(struct dvb_usb_device *dev, u32 * event, int *state)\n{\n\tstruct opera1_state *opst = dev->priv;\n\tu8 rcbuffer[32];\n\tconst u16 startmarker1 = 0x10ed;\n\tconst u16 startmarker2 = 0x11ec;\n\tstruct i2c_msg read_remote[] = {\n\t\t{.addr = ADDR_B880_READ_REMOTE,.buf = rcbuffer,.flags = I2C_M_RD,.len = 32},\n\t};\n\tint i = 0;\n\tu32 send_key = 0;\n\n\tif (i2c_transfer(&dev->i2c_adap, read_remote, 1) == 1) {\n\t\tfor (i = 0; i < 32; i++) {\n\t\t\tif (rcbuffer[i])\n\t\t\t\tsend_key |= 1;\n\t\t\tif (i < 31)\n\t\t\t\tsend_key = send_key << 1;\n\t\t}\n\t\tif (send_key & 0x8000)\n\t\t\tsend_key = (send_key << 1) | (send_key >> 15 & 0x01);\n\n\t\tif (send_key == 0xffff && opst->last_key_pressed != 0) {\n\t\t\t*state = REMOTE_KEY_REPEAT;\n\t\t\t*event = opst->last_key_pressed;\n\t\t\treturn 0;\n\t\t}\n\t\tfor (; send_key != 0;) {\n\t\t\tif (send_key >> 16 == startmarker2) {\n\t\t\t\tbreak;\n\t\t\t} else if (send_key >> 16 == startmarker1) {\n\t\t\t\tsend_key =\n\t\t\t\t\t(send_key & 0xfffeffff) | (startmarker1 << 16);\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tsend_key >>= 1;\n\t\t}\n\n\t\tif (send_key == 0)\n\t\t\treturn 0;\n\n\t\tsend_key = (send_key & 0xffff) | 0x0100;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(rc_map_opera1_table); i++) {\n\t\t\tif (rc5_scan(&rc_map_opera1_table[i]) == (send_key & 0xffff)) {\n\t\t\t\t*state = REMOTE_KEY_PRESSED;\n\t\t\t\t*event = rc_map_opera1_table[i].keycode;\n\t\t\t\topst->last_key_pressed =\n\t\t\t\t\trc_map_opera1_table[i].keycode;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\topst->last_key_pressed = 0;\n\t\t}\n\t} else\n\t\t*state = REMOTE_NO_KEY_PRESSED;\n\treturn 0;\n}\n\nenum {\n\tCYPRESS_OPERA1_COLD,\n\tOPERA1_WARM,\n};\n\nstatic struct usb_device_id opera1_table[] = {\n\tDVB_USB_DEV(CYPRESS, CYPRESS_OPERA1_COLD),\n\tDVB_USB_DEV(OPERA1, OPERA1_WARM),\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, opera1_table);\n\nstatic int opera1_read_mac_address(struct dvb_usb_device *d, u8 mac[6])\n{\n\tint ret;\n\tu8 command[] = { READ_MAC_ADDR };\n\tret = opera1_xilinx_rw(d->udev, 0xb1, 0xa0, command, 1, OPERA_WRITE_MSG);\n\tif (ret)\n\t\treturn ret;\n\tret = opera1_xilinx_rw(d->udev, 0xb1, 0xa1, mac, 6, OPERA_READ_MSG);\n\tif (ret)\n\t\treturn ret;\n\treturn 0;\n}\nstatic int opera1_xilinx_load_firmware(struct usb_device *dev,\n\t\t\t\t       const char *filename)\n{\n\tconst struct firmware *fw = NULL;\n\tu8 *b, *p;\n\tint ret = 0, i,fpgasize=40;\n\tu8 testval;\n\tinfo(\"start downloading fpga firmware %s\",filename);\n\n\tif ((ret = request_firmware(&fw, filename, &dev->dev)) != 0) {\n\t\terr(\"did not find the firmware file '%s'. You can use <kernel_dir>/scripts/get_dvb_firmware to get the firmware\",\n\t\t\tfilename);\n\t\treturn ret;\n\t} else {\n\t\tp = kmalloc(fw->size, GFP_KERNEL);\n\t\topera1_xilinx_rw(dev, 0xbc, 0x00, &testval, 1, OPERA_READ_MSG);\n\t\tif (p != NULL && testval != 0x67) {\n\n\t\t\tu8 reset = 0, fpga_command = 0;\n\t\t\tmemcpy(p, fw->data, fw->size);\n\t\t\t \n\t\t\topera1_xilinx_rw(dev, 0xbc, 0xaa, &fpga_command, 1,\n\t\t\t\t\t OPERA_WRITE_MSG);\n\t\t\tfor (i = 0; i < fw->size;) {\n\t\t\t\tif ( (fw->size - i) <fpgasize){\n\t\t\t\t    fpgasize=fw->size-i;\n\t\t\t\t}\n\t\t\t\tb = (u8 *) p + i;\n\t\t\t\tif (opera1_xilinx_rw\n\t\t\t\t\t(dev, OPERA_WRITE_FX2, 0x0, b , fpgasize,\n\t\t\t\t\t\tOPERA_WRITE_MSG) != fpgasize\n\t\t\t\t\t) {\n\t\t\t\t\terr(\"error while transferring firmware\");\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti = i + fpgasize;\n\t\t\t}\n\t\t\t \n\t\t\tif (ret || opera1_xilinx_rw\n\t\t\t\t\t(dev, 0xa0, 0xe600, &reset, 1,\n\t\t\t\t\tOPERA_WRITE_MSG) != 1) {\n\t\t\t\terr(\"could not restart the USB controller CPU.\");\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\tkfree(p);\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nstatic struct dvb_usb_device_properties opera1_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\t.usb_ctrl = CYPRESS_FX2,\n\t.firmware = \"dvb-usb-opera-01.fw\",\n\t.size_of_priv = sizeof(struct opera1_state),\n\n\t.power_ctrl = opera1_power_ctrl,\n\t.i2c_algo = &opera1_i2c_algo,\n\n\t.rc.legacy = {\n\t\t.rc_map_table = rc_map_opera1_table,\n\t\t.rc_map_size = ARRAY_SIZE(rc_map_opera1_table),\n\t\t.rc_interval = 200,\n\t\t.rc_query = opera1_rc_query,\n\t},\n\t.read_mac_address = opera1_read_mac_address,\n\t.generic_bulk_ctrl_endpoint = 0x00,\n\t \n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.frontend_attach = opera1_frontend_attach,\n\t\t\t.streaming_ctrl = opera1_streaming_ctrl,\n\t\t\t.tuner_attach = opera1_tuner_attach,\n\t\t\t.caps =\n\t\t\t\tDVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t.pid_filter = opera1_pid_filter,\n\t\t\t.pid_filter_ctrl = opera1_pid_filter_control,\n\t\t\t.pid_filter_count = 252,\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 10,\n\t\t\t\t.endpoint = 0x82,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t}\n\t},\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{\"Opera1 DVB-S USB2.0\",\n\t\t\t{&opera1_table[CYPRESS_OPERA1_COLD], NULL},\n\t\t\t{&opera1_table[OPERA1_WARM], NULL},\n\t\t},\n\t}\n};\n\nstatic int opera1_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\n\tif (le16_to_cpu(udev->descriptor.idProduct) == USB_PID_OPERA1_WARM &&\n\t    le16_to_cpu(udev->descriptor.idVendor) == USB_VID_OPERA1 &&\n\t\topera1_xilinx_load_firmware(udev, \"dvb-usb-opera1-fpga-01.fw\") != 0\n\t    ) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (0 != dvb_usb_device_init(intf, &opera1_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic struct usb_driver opera1_driver = {\n\t.name = \"opera1\",\n\t.probe = opera1_probe,\n\t.disconnect = dvb_usb_device_exit,\n\t.id_table = opera1_table,\n};\n\nmodule_usb_driver(opera1_driver);\n\nMODULE_AUTHOR(\"Mario Hlawitschka (c) dh1pa@amsat.org\");\nMODULE_AUTHOR(\"Marco Gittler (c) g.marco@freenet.de\");\nMODULE_DESCRIPTION(\"Driver for Opera1 DVB-S device\");\nMODULE_VERSION(\"0.1\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}