{
  "module_name": "m920x.c",
  "hash_id": "d57e0c1e71010c25fc216590cfd278a39bf61efe7ba4ab3b376fedbd5dd2eb7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/m920x.c",
  "human_readable_source": "\n \n\n#include \"m920x.h\"\n\n#include \"mt352.h\"\n#include \"mt352_priv.h\"\n#include \"qt1010.h\"\n#include \"tda1004x.h\"\n#include \"tda827x.h\"\n#include \"mt2060.h\"\n\n#include <media/tuner.h>\n#include \"tuner-simple.h\"\n#include <asm/unaligned.h>\n\n \nstatic int dvb_usb_m920x_debug;\nmodule_param_named(debug,dvb_usb_m920x_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=rc (or-able)).\" DVB_USB_DEBUG_STATUS);\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic int m920x_set_filter(struct dvb_usb_device *d, int type, int idx, int pid);\n\nstatic inline int m920x_read(struct usb_device *udev, u8 request, u16 value,\n\t\t\t     u16 index, void *data, int size)\n{\n\tint ret;\n\n\tret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t      request, USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t      value, index, data, size, 2000);\n\tif (ret < 0) {\n\t\tprintk(KERN_INFO \"m920x_read = error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ret != size) {\n\t\tdeb(\"m920x_read = no data\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int m920x_write(struct usb_device *udev, u8 request,\n\t\t\t      u16 value, u16 index)\n{\n\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0), request,\n\t\t\t       USB_TYPE_VENDOR | USB_DIR_OUT, value, index,\n\t\t\t       NULL, 0, 2000);\n}\n\nstatic inline int m920x_write_seq(struct usb_device *udev, u8 request,\n\t\t\t\t  struct m920x_inits *seq)\n{\n\tint ret;\n\tdo {\n\t\tret = m920x_write(udev, request, seq->data, seq->address);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\tseq++;\n\t} while (seq->address);\n\n\treturn 0;\n}\n\nstatic int m920x_init(struct dvb_usb_device *d, struct m920x_inits *rc_seq)\n{\n\tint ret, i, epi, flags = 0;\n\tint adap_enabled[M9206_MAX_ADAPTERS] = { 0 };\n\n\t \n\tif (d->props.rc.legacy.rc_query || d->props.rc.core.rc_query) {\n\t\tdeb(\"Initialising remote control\\n\");\n\t\tret = m920x_write_seq(d->udev, M9206_CORE, rc_seq);\n\t\tif (ret != 0) {\n\t\t\tdeb(\"Initialising remote control failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdeb(\"Initialising remote control success\\n\");\n\t}\n\n\tfor (i = 0; i < d->props.num_adapters; i++)\n\t\tflags |= d->adapter[i].props.fe[0].caps;\n\n\t \n\tif (flags & DVB_USB_ADAP_HAS_PID_FILTER) {\n\t\tfor (i = 0; i < d->props.num_adapters; i++) {\n\t\t\tepi = d->adapter[i].props.fe[0].stream.endpoint - 0x81;\n\n\t\t\tif (epi < 0 || epi >= M9206_MAX_ADAPTERS) {\n\t\t\t\tprintk(KERN_INFO \"m920x: Unexpected adapter endpoint!\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tadap_enabled[epi] = 1;\n\t\t}\n\n\t\tfor (i = 0; i < M9206_MAX_ADAPTERS; i++) {\n\t\t\tif (adap_enabled[i])\n\t\t\t\tcontinue;\n\n\t\t\tif ((ret = m920x_set_filter(d, 0x81 + i, 0, 0x0)) != 0)\n\t\t\t\treturn ret;\n\n\t\t\tif ((ret = m920x_set_filter(d, 0x81 + i, 0, 0x02f5)) != 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int m920x_init_ep(struct usb_interface *intf)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_host_interface *alt;\n\n\tif ((alt = usb_altnum_to_altsetting(intf, 1)) == NULL) {\n\t\tdeb(\"No alt found!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn usb_set_interface(udev, alt->desc.bInterfaceNumber,\n\t\t\t\t alt->desc.bAlternateSetting);\n}\n\nstatic inline void m920x_parse_rc_state(struct dvb_usb_device *d, u8 rc_state,\n\t\t\t\t\tint *state)\n{\n\tstruct m920x_state *m = d->priv;\n\n\tswitch (rc_state) {\n\tcase 0x80:\n\t\t*state = REMOTE_NO_KEY_PRESSED;\n\t\tbreak;\n\n\tcase 0x88:  \n\tcase 0x99:\n\tcase 0xc0:\n\tcase 0xd8:\n\t\t*state = REMOTE_NO_KEY_PRESSED;\n\t\tm->rep_count = 0;\n\t\tbreak;\n\n\tcase 0x93:\n\tcase 0x92:\n\tcase 0x83:  \n\tcase 0x82:\n\t\tm->rep_count = 0;\n\t\t*state = REMOTE_KEY_PRESSED;\n\t\tbreak;\n\n\tcase 0x91:\n\tcase 0x81:  \n\t\t \n\t\tif (++m->rep_count > 2)\n\t\t\t*state = REMOTE_KEY_REPEAT;\n\t\telse\n\t\t\t*state = REMOTE_NO_KEY_PRESSED;\n\t\tbreak;\n\n\tdefault:\n\t\tdeb(\"Unexpected rc state %02x\\n\", rc_state);\n\t\t*state = REMOTE_NO_KEY_PRESSED;\n\t\tbreak;\n\t}\n}\n\nstatic int m920x_rc_query(struct dvb_usb_device *d, u32 *event, int *state)\n{\n\tint i, ret = 0;\n\tu8 *rc_state;\n\n\trc_state = kmalloc(2, GFP_KERNEL);\n\tif (!rc_state)\n\t\treturn -ENOMEM;\n\n\tret = m920x_read(d->udev, M9206_CORE, 0x0, M9206_RC_STATE,\n\t\t\t rc_state, 1);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tret = m920x_read(d->udev, M9206_CORE, 0x0, M9206_RC_KEY,\n\t\t\t rc_state + 1, 1);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tm920x_parse_rc_state(d, rc_state[0], state);\n\n\tfor (i = 0; i < d->props.rc.legacy.rc_map_size; i++)\n\t\tif (rc5_data(&d->props.rc.legacy.rc_map_table[i]) == rc_state[1]) {\n\t\t\t*event = d->props.rc.legacy.rc_map_table[i].keycode;\n\t\t\tgoto out;\n\t\t}\n\n\tif (rc_state[1] != 0)\n\t\tdeb(\"Unknown rc key %02x\\n\", rc_state[1]);\n\n\t*state = REMOTE_NO_KEY_PRESSED;\n\n out:\n\tkfree(rc_state);\n\treturn ret;\n}\n\nstatic int m920x_rc_core_query(struct dvb_usb_device *d)\n{\n\tint ret = 0;\n\tu8 *rc_state;\n\tint state;\n\n\trc_state = kmalloc(2, GFP_KERNEL);\n\tif (!rc_state)\n\t\treturn -ENOMEM;\n\n\tif ((ret = m920x_read(d->udev, M9206_CORE, 0x0, M9206_RC_STATE, &rc_state[0], 1)) != 0)\n\t\tgoto out;\n\n\tif ((ret = m920x_read(d->udev, M9206_CORE, 0x0, M9206_RC_KEY, &rc_state[1], 1)) != 0)\n\t\tgoto out;\n\n\tdeb(\"state=0x%02x keycode=0x%02x\\n\", rc_state[0], rc_state[1]);\n\n\tm920x_parse_rc_state(d, rc_state[0], &state);\n\n\tif (state == REMOTE_NO_KEY_PRESSED)\n\t\trc_keyup(d->rc_dev);\n\telse if (state == REMOTE_KEY_REPEAT)\n\t\trc_repeat(d->rc_dev);\n\telse\n\t\trc_keydown(d->rc_dev, RC_PROTO_UNKNOWN, rc_state[1], 0);\n\nout:\n\tkfree(rc_state);\n\treturn ret;\n}\n\n \nstatic int m920x_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[], int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint i, j;\n\tint ret = 0;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tfor (i = 0; i < num; i++) {\n\t\tif (msg[i].flags & (I2C_M_NO_RD_ACK | I2C_M_IGNORE_NAK | I2C_M_TEN) || msg[i].len == 0) {\n\t\t\t \n\t\t\tret = -ENOTSUPP;\n\t\t\tgoto unlock;\n\t\t}\n\t\t \n\t\tif (!(msg[i].flags & I2C_M_NOSTART)) {\n\t\t\tif ((ret = m920x_write(d->udev, M9206_I2C,\n\t\t\t\t\t(msg[i].addr << 1) |\n\t\t\t\t\t(msg[i].flags & I2C_M_RD ? 0x01 : 0), 0x80)) != 0)\n\t\t\t\tgoto unlock;\n\t\t\t \n\t\t}\n\t\tif (msg[i].flags & I2C_M_RD) {\n\t\t\tchar *read = kmalloc(1, GFP_KERNEL);\n\t\t\tif (!read) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < msg[i].len; j++) {\n\t\t\t\t \n\t\t\t\tint stop = (i+1 == num && j+1 == msg[i].len) ? 0x40 : 0x01;\n\n\t\t\t\tif ((ret = m920x_read(d->udev, M9206_I2C, 0x0,\n\t\t\t\t\t\t      0x20 | stop,\n\t\t\t\t\t\t      read, 1)) != 0) {\n\t\t\t\t\tkfree(read);\n\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\t\t\t\tmsg[i].buf[j] = read[0];\n\t\t\t}\n\n\t\t\tkfree(read);\n\t\t} else {\n\t\t\tfor (j = 0; j < msg[i].len; j++) {\n\t\t\t\t \n\t\t\t\tint stop = (i+1 == num && j+1 == msg[i].len) ? 0x40 : 0x00;\n\n\t\t\t\tif ((ret = m920x_write(d->udev, M9206_I2C, msg[i].buf[j], stop)) != 0)\n\t\t\t\t\tgoto unlock;\n\t\t\t\t \n\t\t\t}\n\t\t}\n\t}\n\tret = num;\n\n unlock:\n\tmutex_unlock(&d->i2c_mutex);\n\n\treturn ret;\n}\n\nstatic u32 m920x_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm m920x_i2c_algo = {\n\t.master_xfer   = m920x_i2c_xfer,\n\t.functionality = m920x_i2c_func,\n};\n\n \nstatic int m920x_set_filter(struct dvb_usb_device *d, int type, int idx, int pid)\n{\n\tint ret = 0;\n\n\tif (pid >= 0x8000)\n\t\treturn -EINVAL;\n\n\tpid |= 0x8000;\n\n\tif ((ret = m920x_write(d->udev, M9206_FILTER, pid, (type << 8) | (idx * 4) )) != 0)\n\t\treturn ret;\n\n\tif ((ret = m920x_write(d->udev, M9206_FILTER, 0, (type << 8) | (idx * 4) )) != 0)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic int m920x_update_filters(struct dvb_usb_adapter *adap)\n{\n\tstruct m920x_state *m = adap->dev->priv;\n\tint enabled = m->filtering_enabled[adap->id];\n\tint i, ret = 0, filter = 0;\n\tint ep = adap->props.fe[0].stream.endpoint;\n\n\tfor (i = 0; i < M9206_MAX_FILTERS; i++)\n\t\tif (m->filters[adap->id][i] == 8192)\n\t\t\tenabled = 0;\n\n\t \n\tif ((ret = m920x_set_filter(adap->dev, ep, 1, enabled)) != 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < M9206_MAX_FILTERS; i++)\n\t\tif ((ret = m920x_set_filter(adap->dev, ep, i + 2, 0)) != 0)\n\t\t\treturn ret;\n\n\t \n\tif (enabled) {\n\t\tfor (i = 0; i < M9206_MAX_FILTERS; i++) {\n\t\t\tif (m->filters[adap->id][i] == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif ((ret = m920x_set_filter(adap->dev, ep, filter + 2, m->filters[adap->id][i])) != 0)\n\t\t\t\treturn ret;\n\n\t\t\tfilter++;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int m920x_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)\n{\n\tstruct m920x_state *m = adap->dev->priv;\n\n\tm->filtering_enabled[adap->id] = onoff ? 1 : 0;\n\n\treturn m920x_update_filters(adap);\n}\n\nstatic int m920x_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid, int onoff)\n{\n\tstruct m920x_state *m = adap->dev->priv;\n\n\tm->filters[adap->id][index] = onoff ? pid : 0;\n\n\treturn m920x_update_filters(adap);\n}\n\nstatic int m920x_firmware_download(struct usb_device *udev, const struct firmware *fw)\n{\n\tu16 value, index, size;\n\tu8 *read, *buff;\n\tint i, pass, ret = 0;\n\n\tbuff = kmalloc(65536, GFP_KERNEL);\n\tif (buff == NULL)\n\t\treturn -ENOMEM;\n\n\tread = kmalloc(4, GFP_KERNEL);\n\tif (!read) {\n\t\tkfree(buff);\n\t\treturn -ENOMEM;\n\t}\n\n\tif ((ret = m920x_read(udev, M9206_FILTER, 0x0, 0x8000, read, 4)) != 0)\n\t\tgoto done;\n\tdeb(\"%*ph\\n\", 4, read);\n\n\tif ((ret = m920x_read(udev, M9206_FW, 0x0, 0x0, read, 1)) != 0)\n\t\tgoto done;\n\tdeb(\"%x\\n\", read[0]);\n\n\tfor (pass = 0; pass < 2; pass++) {\n\t\tfor (i = 0; i + (sizeof(u16) * 3) < fw->size;) {\n\t\t\tvalue = get_unaligned_le16(fw->data + i);\n\t\t\ti += sizeof(u16);\n\n\t\t\tindex = get_unaligned_le16(fw->data + i);\n\t\t\ti += sizeof(u16);\n\n\t\t\tsize = get_unaligned_le16(fw->data + i);\n\t\t\ti += sizeof(u16);\n\n\t\t\tif (pass == 1) {\n\t\t\t\t \n\t\t\t\tmemcpy(buff, fw->data + i, size);\n\n\t\t\t\tret = usb_control_msg(udev, usb_sndctrlpipe(udev,0),\n\t\t\t\t\t\t      M9206_FW,\n\t\t\t\t\t\t      USB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t\t\t\t      value, index, buff, size, 20);\n\t\t\t\tif (ret != size) {\n\t\t\t\t\tdeb(\"error while uploading fw!\\n\");\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tmsleep(3);\n\t\t\t}\n\t\t\ti += size;\n\t\t}\n\t\tif (i != fw->size) {\n\t\t\tdeb(\"bad firmware file!\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tmsleep(36);\n\n\t \n\t(void) m920x_write(udev, M9206_CORE, 0x01, M9206_FW_GO);\n\tdeb(\"firmware uploaded!\\n\");\n\n done:\n\tkfree(read);\n\tkfree(buff);\n\n\treturn ret;\n}\n\n \nstatic int m920x_identify_state(struct usb_device *udev,\n\t\t\t\tconst struct dvb_usb_device_properties *props,\n\t\t\t\tconst struct dvb_usb_device_description **desc,\n\t\t\t\tint *cold)\n{\n\tstruct usb_host_interface *alt;\n\n\talt = usb_altnum_to_altsetting(usb_ifnum_to_if(udev, 0), 1);\n\t*cold = (alt == NULL) ? 1 : 0;\n\n\treturn 0;\n}\n\n \nstatic int m920x_mt352_demod_init(struct dvb_frontend *fe)\n{\n\tint ret;\n\tstatic const u8 config[] = { CONFIG, 0x3d };\n\tstatic const u8 clock[] = { CLOCK_CTL, 0x30 };\n\tstatic const u8 reset[] = { RESET, 0x80 };\n\tstatic const u8 adc_ctl[] = { ADC_CTL_1, 0x40 };\n\tstatic const u8 agc[] = { AGC_TARGET, 0x1c, 0x20 };\n\tstatic const u8 sec_agc[] = { 0x69, 0x00, 0xff, 0xff, 0x40, 0xff, 0x00, 0x40, 0x40 };\n\tstatic const u8 unk1[] = { 0x93, 0x1a };\n\tstatic const u8 unk2[] = { 0xb5, 0x7a };\n\n\tdeb(\"Demod init!\\n\");\n\n\tif ((ret = mt352_write(fe, config, ARRAY_SIZE(config))) != 0)\n\t\treturn ret;\n\tif ((ret = mt352_write(fe, clock, ARRAY_SIZE(clock))) != 0)\n\t\treturn ret;\n\tif ((ret = mt352_write(fe, reset, ARRAY_SIZE(reset))) != 0)\n\t\treturn ret;\n\tif ((ret = mt352_write(fe, adc_ctl, ARRAY_SIZE(adc_ctl))) != 0)\n\t\treturn ret;\n\tif ((ret = mt352_write(fe, agc, ARRAY_SIZE(agc))) != 0)\n\t\treturn ret;\n\tif ((ret = mt352_write(fe, sec_agc, ARRAY_SIZE(sec_agc))) != 0)\n\t\treturn ret;\n\tif ((ret = mt352_write(fe, unk1, ARRAY_SIZE(unk1))) != 0)\n\t\treturn ret;\n\tif ((ret = mt352_write(fe, unk2, ARRAY_SIZE(unk2))) != 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic struct mt352_config m920x_mt352_config = {\n\t.demod_address = 0x0f,\n\t.no_tuner = 1,\n\t.demod_init = m920x_mt352_demod_init,\n};\n\nstatic struct tda1004x_config m920x_tda10046_08_config = {\n\t.demod_address = 0x08,\n\t.invert = 0,\n\t.invert_oclk = 0,\n\t.ts_mode = TDA10046_TS_SERIAL,\n\t.xtal_freq = TDA10046_XTAL_16M,\n\t.if_freq = TDA10046_FREQ_045,\n\t.agc_config = TDA10046_AGC_TDA827X,\n\t.gpio_config = TDA10046_GPTRI,\n\t.request_firmware = NULL,\n};\n\nstatic struct tda1004x_config m920x_tda10046_0b_config = {\n\t.demod_address = 0x0b,\n\t.invert = 0,\n\t.invert_oclk = 0,\n\t.ts_mode = TDA10046_TS_SERIAL,\n\t.xtal_freq = TDA10046_XTAL_16M,\n\t.if_freq = TDA10046_FREQ_045,\n\t.agc_config = TDA10046_AGC_TDA827X,\n\t.gpio_config = TDA10046_GPTRI,\n\t.request_firmware = NULL,  \n};\n\n \nstatic struct qt1010_config m920x_qt1010_config = {\n\t.i2c_address = 0x62\n};\n\nstatic struct mt2060_config m920x_mt2060_config = {\n\t.i2c_address = 0x60,  \n\t.clock_out = 0,\n};\n\n\n \nstatic int m920x_mt352_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tdeb(\"%s\\n\",__func__);\n\n\tadap->fe_adap[0].fe = dvb_attach(mt352_attach,\n\t\t\t\t\t &m920x_mt352_config,\n\t\t\t\t\t &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) == NULL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int m920x_mt352_frontend_attach_vp7049(struct dvb_usb_adapter *adap)\n{\n\tstruct m920x_inits vp7049_fe_init_seq[] = {\n\t\t \n\t\t{ 0xff28,         0x00 },\n\t\t{ 0xff23,         0x00 },\n\t\t{ 0xff28,         0x00 },\n\t\t{ 0xff23,         0x00 },\n\t\t{ 0xff21,         0x20 },\n\t\t{ 0xff21,         0x60 },\n\t\t{ 0xff28,         0x00 },\n\t\t{ 0xff22,         0x00 },\n\t\t{ 0xff20,         0x30 },\n\t\t{ 0xff20,         0x20 },\n\t\t{ 0xff20,         0x30 },\n\t\t{ }  \n\t};\n\tint ret;\n\n\tdeb(\"%s\\n\", __func__);\n\n\tret = m920x_write_seq(adap->dev->udev, M9206_CORE, vp7049_fe_init_seq);\n\tif (ret != 0) {\n\t\tdeb(\"Initialization of vp7049 frontend failed.\");\n\t\treturn ret;\n\t}\n\n\treturn m920x_mt352_frontend_attach(adap);\n}\n\nstatic int m920x_tda10046_08_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tdeb(\"%s\\n\",__func__);\n\n\tadap->fe_adap[0].fe = dvb_attach(tda10046_attach,\n\t\t\t\t\t &m920x_tda10046_08_config,\n\t\t\t\t\t &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) == NULL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int m920x_tda10046_0b_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tdeb(\"%s\\n\",__func__);\n\n\tadap->fe_adap[0].fe = dvb_attach(tda10046_attach,\n\t\t\t\t\t &m920x_tda10046_0b_config,\n\t\t\t\t\t &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) == NULL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int m920x_qt1010_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdeb(\"%s\\n\",__func__);\n\n\tif (dvb_attach(qt1010_attach, adap->fe_adap[0].fe, &adap->dev->i2c_adap, &m920x_qt1010_config) == NULL)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int m920x_tda8275_60_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdeb(\"%s\\n\",__func__);\n\n\tif (dvb_attach(tda827x_attach, adap->fe_adap[0].fe, 0x60, &adap->dev->i2c_adap, NULL) == NULL)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int m920x_tda8275_61_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdeb(\"%s\\n\",__func__);\n\n\tif (dvb_attach(tda827x_attach, adap->fe_adap[0].fe, 0x61, &adap->dev->i2c_adap, NULL) == NULL)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int m920x_fmd1216me_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdvb_attach(simple_tuner_attach, adap->fe_adap[0].fe,\n\t\t   &adap->dev->i2c_adap, 0x61,\n\t\t   TUNER_PHILIPS_FMD1216ME_MK3);\n\treturn 0;\n}\n\nstatic int m920x_mt2060_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdeb(\"%s\\n\", __func__);\n\n\tif (dvb_attach(mt2060_attach, adap->fe_adap[0].fe, &adap->dev->i2c_adap,\n\t\t       &m920x_mt2060_config, 1220) == NULL)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\n\n \nstatic struct m920x_inits megasky_rc_init [] = {\n\t{ M9206_RC_INIT2, 0xa8 },\n\t{ M9206_RC_INIT1, 0x51 },\n\t{ }  \n};\n\nstatic struct m920x_inits tvwalkertwin_rc_init [] = {\n\t{ M9206_RC_INIT2, 0x00 },\n\t{ M9206_RC_INIT1, 0xef },\n\t{ 0xff28,         0x00 },\n\t{ 0xff23,         0x00 },\n\t{ 0xff21,         0x30 },\n\t{ }  \n};\n\nstatic struct m920x_inits pinnacle310e_init[] = {\n\t \n\t{ 0xff20,         0x9b },\n\t{ 0xff22,         0x70 },\n\n\t \n\t{ 0xff50,         0x80 },\n\t{ M9206_RC_INIT1, 0x00 },\n\t{ M9206_RC_INIT2, 0xff },\n\t{ }  \n};\n\nstatic struct m920x_inits vp7049_rc_init[] = {\n\t{ 0xff28,         0x00 },\n\t{ 0xff23,         0x00 },\n\t{ 0xff21,         0x70 },\n\t{ M9206_RC_INIT2, 0x00 },\n\t{ M9206_RC_INIT1, 0xff },\n\t{ }  \n};\n\n \nstatic struct rc_map_table rc_map_megasky_table[] = {\n\t{ 0x0012, KEY_POWER },\n\t{ 0x001e, KEY_CYCLEWINDOWS },  \n\t{ 0x0002, KEY_CHANNELUP },\n\t{ 0x0005, KEY_CHANNELDOWN },\n\t{ 0x0003, KEY_VOLUMEUP },\n\t{ 0x0006, KEY_VOLUMEDOWN },\n\t{ 0x0004, KEY_MUTE },\n\t{ 0x0007, KEY_OK },  \n\t{ 0x0008, KEY_STOP },\n\t{ 0x0009, KEY_MENU },  \n\t{ 0x000a, KEY_REWIND },\n\t{ 0x001b, KEY_PAUSE },\n\t{ 0x001f, KEY_FASTFORWARD },\n\t{ 0x000c, KEY_RECORD },\n\t{ 0x000d, KEY_CAMERA },  \n\t{ 0x000e, KEY_COFFEE },  \n};\n\nstatic struct rc_map_table rc_map_tvwalkertwin_table[] = {\n\t{ 0x0001, KEY_ZOOM },  \n\t{ 0x0002, KEY_CAMERA },  \n\t{ 0x0003, KEY_MUTE },\n\t{ 0x0004, KEY_REWIND },\n\t{ 0x0005, KEY_PLAYPAUSE },  \n\t{ 0x0006, KEY_FASTFORWARD },\n\t{ 0x0007, KEY_RECORD },\n\t{ 0x0008, KEY_STOP },\n\t{ 0x0009, KEY_TIME },  \n\t{ 0x000c, KEY_COFFEE },  \n\t{ 0x000e, KEY_CHANNELUP },\n\t{ 0x0012, KEY_POWER },\n\t{ 0x0015, KEY_MENU },  \n\t{ 0x0018, KEY_CYCLEWINDOWS },  \n\t{ 0x001a, KEY_CHANNELDOWN },\n\t{ 0x001b, KEY_VOLUMEDOWN },\n\t{ 0x001e, KEY_VOLUMEUP },\n};\n\nstatic struct rc_map_table rc_map_pinnacle310e_table[] = {\n\t{ 0x16, KEY_POWER },\n\t{ 0x17, KEY_FAVORITES },\n\t{ 0x0f, KEY_TEXT },\n\t{ 0x48, KEY_PROGRAM },\t\t \n\t{ 0x1c, KEY_EPG },\n\t{ 0x04, KEY_LIST },\t\t \n\t{ 0x03, KEY_1 },\n\t{ 0x01, KEY_2 },\n\t{ 0x06, KEY_3 },\n\t{ 0x09, KEY_4 },\n\t{ 0x1d, KEY_5 },\n\t{ 0x1f, KEY_6 },\n\t{ 0x0d, KEY_7 },\n\t{ 0x19, KEY_8 },\n\t{ 0x1b, KEY_9 },\n\t{ 0x15, KEY_0 },\n\t{ 0x0c, KEY_CANCEL },\n\t{ 0x4a, KEY_CLEAR },\n\t{ 0x13, KEY_BACK },\n\t{ 0x00, KEY_TAB },\n\t{ 0x4b, KEY_UP },\n\t{ 0x4e, KEY_LEFT },\n\t{ 0x52, KEY_RIGHT },\n\t{ 0x51, KEY_DOWN },\n\t{ 0x4f, KEY_ENTER },\t\t \n\t{ 0x1e, KEY_VOLUMEUP },\n\t{ 0x0a, KEY_VOLUMEDOWN },\n\t{ 0x05, KEY_CHANNELUP },\n\t{ 0x02, KEY_CHANNELDOWN },\n\t{ 0x11, KEY_RECORD },\n\t{ 0x14, KEY_PLAY },\n\t{ 0x4c, KEY_PAUSE },\n\t{ 0x1a, KEY_STOP },\n\t{ 0x40, KEY_REWIND },\n\t{ 0x12, KEY_FASTFORWARD },\n\t{ 0x41, KEY_PREVIOUSSONG },\t \n\t{ 0x42, KEY_NEXTSONG },\t\t \n\t{ 0x54, KEY_CAMERA },\t\t \n \t\t \n\t{ 0x47, KEY_CYCLEWINDOWS },\t \n\t{ 0x4d, KEY_SCREEN },\t\t \n\t{ 0x08, KEY_SUBTITLE },\n\t{ 0x0e, KEY_MUTE },\n \t\t \n\t{ 0x07, KEY_SLEEP },\t\t \n\t{ 0x08, KEY_VIDEO },\t\t \n\t{ 0x0e, KEY_MENU },\t\t \n\t{ 0x45, KEY_ZOOMIN },\n\t{ 0x46, KEY_ZOOMOUT },\n\t{ 0x18, KEY_RED },\t\t \n\t{ 0x53, KEY_GREEN },\t\t \n\t{ 0x5e, KEY_YELLOW },\t\t \n\t{ 0x5f, KEY_BLUE },\t\t \n};\n\n \nstatic struct dvb_usb_device_properties megasky_properties;\nstatic struct dvb_usb_device_properties digivox_mini_ii_properties;\nstatic struct dvb_usb_device_properties tvwalkertwin_properties;\nstatic struct dvb_usb_device_properties dposh_properties;\nstatic struct dvb_usb_device_properties pinnacle_pctv310e_properties;\nstatic struct dvb_usb_device_properties vp7049_properties;\n\nstatic int m920x_probe(struct usb_interface *intf,\n\t\t       const struct usb_device_id *id)\n{\n\tstruct dvb_usb_device *d = NULL;\n\tint ret;\n\tstruct m920x_inits *rc_init_seq = NULL;\n\tint bInterfaceNumber = intf->cur_altsetting->desc.bInterfaceNumber;\n\n\tdeb(\"Probing for m920x device at interface %d\\n\", bInterfaceNumber);\n\n\tif (bInterfaceNumber == 0) {\n\t\t \n\n\t\tret = dvb_usb_device_init(intf, &megasky_properties,\n\t\t\t\t\t  THIS_MODULE, &d, adapter_nr);\n\t\tif (ret == 0) {\n\t\t\trc_init_seq = megasky_rc_init;\n\t\t\tgoto found;\n\t\t}\n\n\t\tret = dvb_usb_device_init(intf, &digivox_mini_ii_properties,\n\t\t\t\t\t  THIS_MODULE, &d, adapter_nr);\n\t\tif (ret == 0) {\n\t\t\t \n\t\t\tgoto found;\n\t\t}\n\n\t\t \n\t\tret = dvb_usb_device_init(intf, &tvwalkertwin_properties,\n\t\t\t\t\t  THIS_MODULE, &d, adapter_nr);\n\t\tif (ret == 0) {\n\t\t\trc_init_seq = tvwalkertwin_rc_init;\n\t\t\tgoto found;\n\t\t}\n\n\t\tret = dvb_usb_device_init(intf, &dposh_properties,\n\t\t\t\t\t  THIS_MODULE, &d, adapter_nr);\n\t\tif (ret == 0) {\n\t\t\t \n\t\t\tgoto found;\n\t\t}\n\n\t\tret = dvb_usb_device_init(intf, &pinnacle_pctv310e_properties,\n\t\t\t\t\t  THIS_MODULE, &d, adapter_nr);\n\t\tif (ret == 0) {\n\t\t\trc_init_seq = pinnacle310e_init;\n\t\t\tgoto found;\n\t\t}\n\n\t\tret = dvb_usb_device_init(intf, &vp7049_properties,\n\t\t\t\t\t  THIS_MODULE, &d, adapter_nr);\n\t\tif (ret == 0) {\n\t\t\trc_init_seq = vp7049_rc_init;\n\t\t\tgoto found;\n\t\t}\n\n\t\treturn ret;\n\t} else {\n\t\t \n\n\t\t \n\t}\n\n found:\n\tif ((ret = m920x_init_ep(intf)) < 0)\n\t\treturn ret;\n\n\tif (d && (ret = m920x_init(d, rc_init_seq)) != 0)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nenum {\n\tMSI_MEGASKY580,\n\tANUBIS_MSI_DIGI_VOX_MINI_II,\n\tANUBIS_LIFEVIEW_TV_WALKER_TWIN_COLD,\n\tANUBIS_LIFEVIEW_TV_WALKER_TWIN_WARM,\n\tDPOSH_M9206_COLD,\n\tDPOSH_M9206_WARM,\n\tVISIONPLUS_PINNACLE_PCTV310E,\n\tAZUREWAVE_TWINHAN_VP7049,\n};\n\nstatic struct usb_device_id m920x_table[] = {\n\tDVB_USB_DEV(MSI, MSI_MEGASKY580),\n\tDVB_USB_DEV(ANUBIS_ELECTRONIC, ANUBIS_MSI_DIGI_VOX_MINI_II),\n\tDVB_USB_DEV(ANUBIS_ELECTRONIC, ANUBIS_LIFEVIEW_TV_WALKER_TWIN_COLD),\n\tDVB_USB_DEV(ANUBIS_ELECTRONIC, ANUBIS_LIFEVIEW_TV_WALKER_TWIN_WARM),\n\tDVB_USB_DEV(DPOSH, DPOSH_M9206_COLD),\n\tDVB_USB_DEV(DPOSH, DPOSH_M9206_WARM),\n\tDVB_USB_DEV(VISIONPLUS, VISIONPLUS_PINNACLE_PCTV310E),\n\tDVB_USB_DEV(AZUREWAVE, AZUREWAVE_TWINHAN_VP7049),\n\t{ }\n};\n\nMODULE_DEVICE_TABLE (usb, m920x_table);\n\nstatic struct dvb_usb_device_properties megasky_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.firmware = \"dvb-usb-megasky-02.fw\",\n\t.download_firmware = m920x_firmware_download,\n\n\t.rc.legacy = {\n\t\t.rc_interval      = 100,\n\t\t.rc_map_table     = rc_map_megasky_table,\n\t\t.rc_map_size      = ARRAY_SIZE(rc_map_megasky_table),\n\t\t.rc_query         = m920x_rc_query,\n\t},\n\n\t.size_of_priv     = sizeof(struct m920x_state),\n\n\t.identify_state   = m920x_identify_state,\n\t.num_adapters = 1,\n\t.adapter = {{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\n\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\n\t\t.pid_filter_count = 8,\n\t\t.pid_filter       = m920x_pid_filter,\n\t\t.pid_filter_ctrl  = m920x_pid_filter_ctrl,\n\n\t\t.frontend_attach  = m920x_mt352_frontend_attach,\n\t\t.tuner_attach     = m920x_qt1010_tuner_attach,\n\n\t\t.stream = {\n\t\t\t.type = USB_BULK,\n\t\t\t.count = 8,\n\t\t\t.endpoint = 0x81,\n\t\t\t.u = {\n\t\t\t\t.bulk = {\n\t\t\t\t\t.buffersize = 512,\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t}},\n\t}},\n\t.i2c_algo         = &m920x_i2c_algo,\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"MSI Mega Sky 580 DVB-T USB2.0\",\n\t\t\t{ &m920x_table[MSI_MEGASKY580], NULL },\n\t\t\t{ NULL },\n\t\t}\n\t}\n};\n\nstatic struct dvb_usb_device_properties digivox_mini_ii_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.firmware = \"dvb-usb-digivox-02.fw\",\n\t.download_firmware = m920x_firmware_download,\n\n\t.size_of_priv     = sizeof(struct m920x_state),\n\n\t.identify_state   = m920x_identify_state,\n\t.num_adapters = 1,\n\t.adapter = {{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\n\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\n\t\t.pid_filter_count = 8,\n\t\t.pid_filter       = m920x_pid_filter,\n\t\t.pid_filter_ctrl  = m920x_pid_filter_ctrl,\n\n\t\t.frontend_attach  = m920x_tda10046_08_frontend_attach,\n\t\t.tuner_attach     = m920x_tda8275_60_tuner_attach,\n\n\t\t.stream = {\n\t\t\t.type = USB_BULK,\n\t\t\t.count = 8,\n\t\t\t.endpoint = 0x81,\n\t\t\t.u = {\n\t\t\t\t.bulk = {\n\t\t\t\t\t.buffersize = 0x4000,\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t}},\n\t}},\n\t.i2c_algo         = &m920x_i2c_algo,\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"MSI DIGI VOX mini II DVB-T USB2.0\",\n\t\t\t{ &m920x_table[ANUBIS_MSI_DIGI_VOX_MINI_II], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t}\n};\n\n \nstatic struct dvb_usb_device_properties tvwalkertwin_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.firmware = \"dvb-usb-tvwalkert.fw\",\n\t.download_firmware = m920x_firmware_download,\n\n\t.rc.legacy = {\n\t\t.rc_interval      = 100,\n\t\t.rc_map_table     = rc_map_tvwalkertwin_table,\n\t\t.rc_map_size      = ARRAY_SIZE(rc_map_tvwalkertwin_table),\n\t\t.rc_query         = m920x_rc_query,\n\t},\n\n\t.size_of_priv     = sizeof(struct m920x_state),\n\n\t.identify_state   = m920x_identify_state,\n\t.num_adapters = 2,\n\t.adapter = {{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\n\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\n\t\t.pid_filter_count = 8,\n\t\t.pid_filter       = m920x_pid_filter,\n\t\t.pid_filter_ctrl  = m920x_pid_filter_ctrl,\n\n\t\t.frontend_attach  = m920x_tda10046_08_frontend_attach,\n\t\t.tuner_attach     = m920x_tda8275_60_tuner_attach,\n\n\t\t.stream = {\n\t\t\t.type = USB_BULK,\n\t\t\t.count = 8,\n\t\t\t.endpoint = 0x81,\n\t\t\t.u = {\n\t\t\t\t .bulk = {\n\t\t\t\t\t .buffersize = 512,\n\t\t\t\t }\n\t\t\t}\n\t\t}},\n\t\t}},{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\n\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\n\t\t.pid_filter_count = 8,\n\t\t.pid_filter       = m920x_pid_filter,\n\t\t.pid_filter_ctrl  = m920x_pid_filter_ctrl,\n\n\t\t.frontend_attach  = m920x_tda10046_0b_frontend_attach,\n\t\t.tuner_attach     = m920x_tda8275_61_tuner_attach,\n\n\t\t.stream = {\n\t\t\t.type = USB_BULK,\n\t\t\t.count = 8,\n\t\t\t.endpoint = 0x82,\n\t\t\t.u = {\n\t\t\t\t .bulk = {\n\t\t\t\t\t .buffersize = 512,\n\t\t\t\t }\n\t\t\t}\n\t\t}},\n\t\t},\n\t}},\n\t.i2c_algo         = &m920x_i2c_algo,\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   .name = \"LifeView TV Walker Twin DVB-T USB2.0\",\n\t\t    .cold_ids = { &m920x_table[ANUBIS_LIFEVIEW_TV_WALKER_TWIN_COLD], NULL },\n\t\t    .warm_ids = { &m920x_table[ANUBIS_LIFEVIEW_TV_WALKER_TWIN_WARM], NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties dposh_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.firmware = \"dvb-usb-dposh-01.fw\",\n\t.download_firmware = m920x_firmware_download,\n\n\t.size_of_priv     = sizeof(struct m920x_state),\n\n\t.identify_state   = m920x_identify_state,\n\t.num_adapters = 1,\n\t.adapter = {{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t \n\n\t\t.frontend_attach  = m920x_mt352_frontend_attach,\n\t\t.tuner_attach     = m920x_qt1010_tuner_attach,\n\n\t\t.stream = {\n\t\t\t.type = USB_BULK,\n\t\t\t.count = 8,\n\t\t\t.endpoint = 0x81,\n\t\t\t.u = {\n\t\t\t\t .bulk = {\n\t\t\t\t\t .buffersize = 512,\n\t\t\t\t }\n\t\t\t}\n\t\t},\n\t\t}},\n\t}},\n\t.i2c_algo         = &m920x_i2c_algo,\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t {   .name = \"Dposh DVB-T USB2.0\",\n\t\t     .cold_ids = { &m920x_table[DPOSH_M9206_COLD], NULL },\n\t\t     .warm_ids = { &m920x_table[DPOSH_M9206_WARM], NULL },\n\t\t },\n\t }\n};\n\nstatic struct dvb_usb_device_properties pinnacle_pctv310e_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.download_firmware = NULL,\n\n\t.rc.legacy = {\n\t\t.rc_interval      = 100,\n\t\t.rc_map_table     = rc_map_pinnacle310e_table,\n\t\t.rc_map_size      = ARRAY_SIZE(rc_map_pinnacle310e_table),\n\t\t.rc_query         = m920x_rc_query,\n\t},\n\n\t.size_of_priv     = sizeof(struct m920x_state),\n\n\t.identify_state   = m920x_identify_state,\n\t.num_adapters = 1,\n\t.adapter = {{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\n\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\n\t\t.pid_filter_count = 8,\n\t\t.pid_filter       = m920x_pid_filter,\n\t\t.pid_filter_ctrl  = m920x_pid_filter_ctrl,\n\n\t\t.frontend_attach  = m920x_mt352_frontend_attach,\n\t\t.tuner_attach     = m920x_fmd1216me_tuner_attach,\n\n\t\t.stream = {\n\t\t\t.type = USB_ISOC,\n\t\t\t.count = 5,\n\t\t\t.endpoint = 0x84,\n\t\t\t.u = {\n\t\t\t\t.isoc = {\n\t\t\t\t\t.framesperurb = 128,\n\t\t\t\t\t.framesize = 564,\n\t\t\t\t\t.interval = 1,\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t}},\n\t} },\n\t.i2c_algo         = &m920x_i2c_algo,\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"Pinnacle PCTV 310e\",\n\t\t\t{ &m920x_table[VISIONPLUS_PINNACLE_PCTV310E], NULL },\n\t\t\t{ NULL },\n\t\t}\n\t}\n};\n\nstatic struct dvb_usb_device_properties vp7049_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.firmware = \"dvb-usb-vp7049-0.95.fw\",\n\t.download_firmware = m920x_firmware_download,\n\n\t.rc.core = {\n\t\t.rc_interval    = 150,\n\t\t.rc_codes       = RC_MAP_TWINHAN_VP1027_DVBS,\n\t\t.rc_query       = m920x_rc_core_query,\n\t\t.allowed_protos = RC_PROTO_BIT_UNKNOWN,\n\t},\n\n\t.size_of_priv     = sizeof(struct m920x_state),\n\n\t.identify_state   = m920x_identify_state,\n\t.num_adapters = 1,\n\t.adapter = {{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\n\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\n\t\t.pid_filter_count = 8,\n\t\t.pid_filter       = m920x_pid_filter,\n\t\t.pid_filter_ctrl  = m920x_pid_filter_ctrl,\n\n\t\t.frontend_attach  = m920x_mt352_frontend_attach_vp7049,\n\t\t.tuner_attach     = m920x_mt2060_tuner_attach,\n\n\t\t.stream = {\n\t\t\t.type = USB_BULK,\n\t\t\t.count = 8,\n\t\t\t.endpoint = 0x81,\n\t\t\t.u = {\n\t\t\t\t .bulk = {\n\t\t\t\t\t .buffersize = 512,\n\t\t\t\t }\n\t\t\t}\n\t\t},\n\t\t} },\n\t} },\n\t.i2c_algo         = &m920x_i2c_algo,\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"DTV-DVB UDTT7049\",\n\t\t\t{ &m920x_table[AZUREWAVE_TWINHAN_VP7049], NULL },\n\t\t\t{ NULL },\n\t\t}\n\t }\n};\n\nstatic struct usb_driver m920x_driver = {\n\t.name\t\t= \"dvb_usb_m920x\",\n\t.probe\t\t= m920x_probe,\n\t.disconnect\t= dvb_usb_device_exit,\n\t.id_table\t= m920x_table,\n};\n\nmodule_usb_driver(m920x_driver);\n\nMODULE_AUTHOR(\"Aapo Tahkola <aet@rasterburn.org>\");\nMODULE_DESCRIPTION(\"DVB Driver for ULI M920x\");\nMODULE_VERSION(\"0.1\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}