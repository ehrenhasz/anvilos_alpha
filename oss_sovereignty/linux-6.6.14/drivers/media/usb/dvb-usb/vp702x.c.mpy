{
  "module_name": "vp702x.c",
  "hash_id": "5963e79e9cee1964bf6df218b55c4e2ac08846f6273fefbfbe11158ccba26799",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/vp702x.c",
  "human_readable_source": "\n \n#include \"vp702x.h\"\n#include <linux/mutex.h>\n\n \nint dvb_usb_vp702x_debug;\nmodule_param_named(debug,dvb_usb_vp702x_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=info,xfer=2,rc=4 (or-able)).\" DVB_USB_DEBUG_STATUS);\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstruct vp702x_adapter_state {\n\tint pid_filter_count;\n\tint pid_filter_can_bypass;\n\tu8  pid_filter_state;\n};\n\nstatic int vp702x_usb_in_op_unlocked(struct dvb_usb_device *d, u8 req,\n\t\t\t\t     u16 value, u16 index, u8 *b, int blen)\n{\n\tint ret;\n\n\tret = usb_control_msg(d->udev,\n\t\tusb_rcvctrlpipe(d->udev, 0),\n\t\treq,\n\t\tUSB_TYPE_VENDOR | USB_DIR_IN,\n\t\tvalue, index, b, blen,\n\t\t2000);\n\n\tif (ret < 0) {\n\t\twarn(\"usb in operation failed. (%d)\", ret);\n\t\tret = -EIO;\n\t} else\n\t\tret = 0;\n\n\n\tdeb_xfer(\"in: req. %02x, val: %04x, ind: %04x, buffer: \",req,value,index);\n\tdebug_dump(b,blen,deb_xfer);\n\n\treturn ret;\n}\n\nint vp702x_usb_in_op(struct dvb_usb_device *d, u8 req, u16 value,\n\t\t     u16 index, u8 *b, int blen)\n{\n\tint ret;\n\n\tmutex_lock(&d->usb_mutex);\n\tret = vp702x_usb_in_op_unlocked(d, req, value, index, b, blen);\n\tmutex_unlock(&d->usb_mutex);\n\n\treturn ret;\n}\n\nstatic int vp702x_usb_out_op_unlocked(struct dvb_usb_device *d, u8 req,\n\t\t\t\t      u16 value, u16 index, u8 *b, int blen)\n{\n\tint ret;\n\tdeb_xfer(\"out: req. %02x, val: %04x, ind: %04x, buffer: \",req,value,index);\n\tdebug_dump(b,blen,deb_xfer);\n\n\tif ((ret = usb_control_msg(d->udev,\n\t\t\tusb_sndctrlpipe(d->udev,0),\n\t\t\treq,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\tvalue,index,b,blen,\n\t\t\t2000)) != blen) {\n\t\twarn(\"usb out operation failed. (%d)\",ret);\n\t\treturn -EIO;\n\t} else\n\t\treturn 0;\n}\n\nstatic int vp702x_usb_out_op(struct dvb_usb_device *d, u8 req, u16 value,\n\t\t\t     u16 index, u8 *b, int blen)\n{\n\tint ret;\n\n\tmutex_lock(&d->usb_mutex);\n\tret = vp702x_usb_out_op_unlocked(d, req, value, index, b, blen);\n\tmutex_unlock(&d->usb_mutex);\n\n\treturn ret;\n}\n\nint vp702x_usb_inout_op(struct dvb_usb_device *d, u8 *o, int olen, u8 *i, int ilen, int msec)\n{\n\tint ret;\n\n\tif ((ret = mutex_lock_interruptible(&d->usb_mutex)))\n\t\treturn ret;\n\n\tret = vp702x_usb_out_op_unlocked(d, REQUEST_OUT, 0, 0, o, olen);\n\tmsleep(msec);\n\tret = vp702x_usb_in_op_unlocked(d, REQUEST_IN, 0, 0, i, ilen);\n\n\tmutex_unlock(&d->usb_mutex);\n\treturn ret;\n}\n\nstatic int vp702x_usb_inout_cmd(struct dvb_usb_device *d, u8 cmd, u8 *o,\n\t\t\t\tint olen, u8 *i, int ilen, int msec)\n{\n\tstruct vp702x_device_state *st = d->priv;\n\tint ret = 0;\n\tu8 *buf;\n\tint buflen = max(olen + 2, ilen + 1);\n\n\tret = mutex_lock_interruptible(&st->buf_mutex);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (buflen > st->buf_len) {\n\t\tbuf = kmalloc(buflen, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tmutex_unlock(&st->buf_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tinfo(\"successfully reallocated a bigger buffer\");\n\t\tkfree(st->buf);\n\t\tst->buf = buf;\n\t\tst->buf_len = buflen;\n\t} else {\n\t\tbuf = st->buf;\n\t}\n\n\tbuf[0] = 0x00;\n\tbuf[1] = cmd;\n\tmemcpy(&buf[2], o, olen);\n\n\tret = vp702x_usb_inout_op(d, buf, olen+2, buf, ilen+1, msec);\n\n\tif (ret == 0)\n\t\tmemcpy(i, &buf[1], ilen);\n\tmutex_unlock(&st->buf_mutex);\n\n\treturn ret;\n}\n\nstatic int vp702x_set_pld_mode(struct dvb_usb_adapter *adap, u8 bypass)\n{\n\tint ret;\n\tstruct vp702x_device_state *st = adap->dev->priv;\n\tu8 *buf;\n\n\tmutex_lock(&st->buf_mutex);\n\n\tbuf = st->buf;\n\tmemset(buf, 0, 16);\n\n\tret = vp702x_usb_in_op(adap->dev, 0xe0, (bypass << 8) | 0x0e,\n\t\t\t0, buf, 16);\n\tmutex_unlock(&st->buf_mutex);\n\treturn ret;\n}\n\nstatic int vp702x_set_pld_state(struct dvb_usb_adapter *adap, u8 state)\n{\n\tint ret;\n\tstruct vp702x_device_state *st = adap->dev->priv;\n\tu8 *buf;\n\n\tmutex_lock(&st->buf_mutex);\n\n\tbuf = st->buf;\n\tmemset(buf, 0, 16);\n\tret = vp702x_usb_in_op(adap->dev, 0xe0, (state << 8) | 0x0f,\n\t\t\t0, buf, 16);\n\n\tmutex_unlock(&st->buf_mutex);\n\n\treturn ret;\n}\n\nstatic int vp702x_set_pid(struct dvb_usb_adapter *adap, u16 pid, u8 id, int onoff)\n{\n\tstruct vp702x_adapter_state *st = adap->priv;\n\tstruct vp702x_device_state *dst = adap->dev->priv;\n\tu8 *buf;\n\n\tif (onoff)\n\t\tst->pid_filter_state |=  (1 << id);\n\telse {\n\t\tst->pid_filter_state &= ~(1 << id);\n\t\tpid = 0xffff;\n\t}\n\n\tid = 0x10 + id*2;\n\n\tvp702x_set_pld_state(adap, st->pid_filter_state);\n\n\tmutex_lock(&dst->buf_mutex);\n\n\tbuf = dst->buf;\n\tmemset(buf, 0, 16);\n\tvp702x_usb_in_op(adap->dev, 0xe0, (((pid >> 8) & 0xff) << 8) | (id), 0, buf, 16);\n\tvp702x_usb_in_op(adap->dev, 0xe0, (((pid     ) & 0xff) << 8) | (id+1), 0, buf, 16);\n\n\tmutex_unlock(&dst->buf_mutex);\n\n\treturn 0;\n}\n\n\nstatic int vp702x_init_pid_filter(struct dvb_usb_adapter *adap)\n{\n\tstruct vp702x_adapter_state *st = adap->priv;\n\tstruct vp702x_device_state *dst = adap->dev->priv;\n\tint i;\n\tu8 *b;\n\n\tst->pid_filter_count = 8;\n\tst->pid_filter_can_bypass = 1;\n\tst->pid_filter_state = 0x00;\n\n\tvp702x_set_pld_mode(adap, 1);  \n\n\tfor (i = 0; i < st->pid_filter_count; i++)\n\t\tvp702x_set_pid(adap, 0xffff, i, 1);\n\n\tmutex_lock(&dst->buf_mutex);\n\tb = dst->buf;\n\tmemset(b, 0, 10);\n\tvp702x_usb_in_op(adap->dev, 0xb5, 3, 0, b, 10);\n\tvp702x_usb_in_op(adap->dev, 0xb5, 0, 0, b, 10);\n\tvp702x_usb_in_op(adap->dev, 0xb5, 1, 0, b, 10);\n\tmutex_unlock(&dst->buf_mutex);\n\t \nstatic struct rc_map_table rc_map_vp702x_table[] = {\n\t{ 0x0001, KEY_1 },\n\t{ 0x0002, KEY_2 },\n};\n\n \nstatic int vp702x_rc_query(struct dvb_usb_device *d, u32 *event, int *state)\n{\n \n#if 0\n\tu8 *key;\n\tint i;\n\n\tkey = kmalloc(10, GFP_KERNEL);\n\tif (!key)\n\t\treturn -ENOMEM;\n\n\tvp702x_usb_in_op(d,READ_REMOTE_REQ,0,0,key,10);\n\n\tdeb_rc(\"remote query key: %x %d\\n\",key[1],key[1]);\n\n\tif (key[1] == 0x44) {\n\t\t*state = REMOTE_NO_KEY_PRESSED;\n\t\tkfree(key);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(rc_map_vp702x_table); i++)\n\t\tif (rc5_custom(&rc_map_vp702x_table[i]) == key[1]) {\n\t\t\t*state = REMOTE_KEY_PRESSED;\n\t\t\t*event = rc_map_vp702x_table[i].keycode;\n\t\t\tbreak;\n\t\t}\n\tkfree(key);\n#endif\n\n\treturn 0;\n}\n\n\nstatic int vp702x_read_mac_addr(struct dvb_usb_device *d,u8 mac[6])\n{\n\tu8 i, *buf;\n\tint ret;\n\tstruct vp702x_device_state *st = d->priv;\n\n\tmutex_lock(&st->buf_mutex);\n\tbuf = st->buf;\n\tfor (i = 6; i < 12; i++) {\n\t\tret = vp702x_usb_in_op(d, READ_EEPROM_REQ, i, 1,\n\t\t\t\t       &buf[i - 6], 1);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tmemcpy(mac, buf, 6);\nerr:\n\tmutex_unlock(&st->buf_mutex);\n\treturn ret;\n}\n\nstatic int vp702x_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tu8 buf[10] = { 0 };\n\n\tvp702x_usb_out_op(adap->dev, SET_TUNER_POWER_REQ, 0, 7, NULL, 0);\n\n\tif (vp702x_usb_inout_cmd(adap->dev, GET_SYSTEM_STRING, NULL, 0,\n\t\t\t\t   buf, 10, 10))\n\t\treturn -EIO;\n\n\tbuf[9] = '\\0';\n\tinfo(\"system string: %s\",&buf[1]);\n\n\tvp702x_init_pid_filter(adap);\n\n\tadap->fe_adap[0].fe = vp702x_fe_attach(adap->dev);\n\tvp702x_usb_out_op(adap->dev, SET_TUNER_POWER_REQ, 1, 7, NULL, 0);\n\n\treturn 0;\n}\n\nstatic struct dvb_usb_device_properties vp702x_properties;\n\nstatic int vp702x_usb_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct dvb_usb_device *d;\n\tstruct vp702x_device_state *st;\n\tint ret;\n\n\tret = dvb_usb_device_init(intf, &vp702x_properties,\n\t\t\t\t   THIS_MODULE, &d, adapter_nr);\n\tif (ret)\n\t\tgoto out;\n\n\tst = d->priv;\n\tst->buf_len = 16;\n\tst->buf = kmalloc(st->buf_len, GFP_KERNEL);\n\tif (!st->buf) {\n\t\tret = -ENOMEM;\n\t\tdvb_usb_device_exit(intf);\n\t\tgoto out;\n\t}\n\tmutex_init(&st->buf_mutex);\n\nout:\n\treturn ret;\n\n}\n\nstatic void vp702x_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tstruct vp702x_device_state *st = d->priv;\n\tmutex_lock(&st->buf_mutex);\n\tkfree(st->buf);\n\tmutex_unlock(&st->buf_mutex);\n\tdvb_usb_device_exit(intf);\n}\n\nenum {\n\tVISIONPLUS_VP7021_COLD,\n\tVISIONPLUS_VP7020_COLD,\n\tVISIONPLUS_VP7020_WARM,\n};\n\nstatic struct usb_device_id vp702x_usb_table[] = {\n\tDVB_USB_DEV(VISIONPLUS, VISIONPLUS_VP7021_COLD),\n\n\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, vp702x_usb_table);\n\nstatic struct dvb_usb_device_properties vp702x_properties = {\n\t.usb_ctrl = CYPRESS_FX2,\n\t.firmware            = \"dvb-usb-vp702x-02.fw\",\n\t.no_reconnect        = 1,\n\n\t.size_of_priv     = sizeof(struct vp702x_device_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.caps             = DVB_USB_ADAP_RECEIVES_204_BYTE_TS,\n\n\t\t\t.streaming_ctrl   = vp702x_streaming_ctrl,\n\t\t\t.frontend_attach  = vp702x_frontend_attach,\n\n\t\t\t \n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 10,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t\t.size_of_priv     = sizeof(struct vp702x_adapter_state),\n\t\t}\n\t},\n\t.read_mac_address = vp702x_read_mac_addr,\n\n\t.rc.legacy = {\n\t\t.rc_map_table       = rc_map_vp702x_table,\n\t\t.rc_map_size  = ARRAY_SIZE(rc_map_vp702x_table),\n\t\t.rc_interval      = 400,\n\t\t.rc_query         = vp702x_rc_query,\n\t},\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{ .name = \"TwinhanDTV StarBox DVB-S USB2.0 (VP7021)\",\n\t\t  .cold_ids = { &vp702x_usb_table[VISIONPLUS_VP7021_COLD], NULL },\n\t\t  .warm_ids = { NULL },\n\t\t},\n \t\t{ NULL },\n\t}\n};\n\n \nstatic struct usb_driver vp702x_usb_driver = {\n\t.name\t\t= \"dvb_usb_vp702x\",\n\t.probe\t\t= vp702x_usb_probe,\n\t.disconnect\t= vp702x_usb_disconnect,\n\t.id_table\t= vp702x_usb_table,\n};\n\nmodule_usb_driver(vp702x_usb_driver);\n\nMODULE_AUTHOR(\"Patrick Boettcher <patrick.boettcher@posteo.de>\");\nMODULE_DESCRIPTION(\"Driver for Twinhan StarBox DVB-S USB2.0 and clones\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}