{
  "module_name": "gp8psk.c",
  "hash_id": "9ceb176650505aabd4220db6c26dcd7b8796bcd6a93ae8f3a74f0318d3616e7a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/gp8psk.c",
  "human_readable_source": "\n \n#include \"gp8psk.h\"\n#include \"gp8psk-fe.h\"\n\n \nstatic char bcm4500_firmware[] = \"dvb-usb-gp8psk-02.fw\";\nint dvb_usb_gp8psk_debug;\nmodule_param_named(debug,dvb_usb_gp8psk_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=info,xfer=2,rc=4 (or-able)).\" DVB_USB_DEBUG_STATUS);\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstruct gp8psk_state {\n\tunsigned char data[80];\n};\n\nstatic int gp8psk_usb_in_op(struct dvb_usb_device *d, u8 req, u16 value,\n\t\t\t    u16 index, u8 *b, int blen)\n{\n\tstruct gp8psk_state *st = d->priv;\n\tint ret = 0,try = 0;\n\n\tif (blen > sizeof(st->data))\n\t\treturn -EIO;\n\n\tif ((ret = mutex_lock_interruptible(&d->usb_mutex)))\n\t\treturn ret;\n\n\twhile (ret >= 0 && ret != blen && try < 3) {\n\t\tret = usb_control_msg(d->udev,\n\t\t\tusb_rcvctrlpipe(d->udev,0),\n\t\t\treq,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\tvalue, index, st->data, blen,\n\t\t\t2000);\n\t\tdeb_info(\"reading number %d (ret: %d)\\n\",try,ret);\n\t\ttry++;\n\t}\n\n\tif (ret < 0 || ret != blen) {\n\t\twarn(\"usb in %d operation failed.\", req);\n\t\tret = -EIO;\n\t} else {\n\t\tret = 0;\n\t\tmemcpy(b, st->data, blen);\n\t}\n\n\tdeb_xfer(\"in: req. %x, val: %x, ind: %x, buffer: \",req,value,index);\n\tdebug_dump(b,blen,deb_xfer);\n\n\tmutex_unlock(&d->usb_mutex);\n\n\treturn ret;\n}\n\nstatic int gp8psk_usb_out_op(struct dvb_usb_device *d, u8 req, u16 value,\n\t\t\t     u16 index, u8 *b, int blen)\n{\n\tstruct gp8psk_state *st = d->priv;\n\tint ret;\n\n\tdeb_xfer(\"out: req. %x, val: %x, ind: %x, buffer: \",req,value,index);\n\tdebug_dump(b,blen,deb_xfer);\n\n\tif (blen > sizeof(st->data))\n\t\treturn -EIO;\n\n\tif ((ret = mutex_lock_interruptible(&d->usb_mutex)))\n\t\treturn ret;\n\n\tmemcpy(st->data, b, blen);\n\tif (usb_control_msg(d->udev,\n\t\t\tusb_sndctrlpipe(d->udev,0),\n\t\t\treq,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\tvalue, index, st->data, blen,\n\t\t\t2000) != blen) {\n\t\twarn(\"usb out operation failed.\");\n\t\tret = -EIO;\n\t} else\n\t\tret = 0;\n\tmutex_unlock(&d->usb_mutex);\n\n\treturn ret;\n}\n\n\nstatic int gp8psk_get_fw_version(struct dvb_usb_device *d, u8 *fw_vers)\n{\n\treturn gp8psk_usb_in_op(d, GET_FW_VERS, 0, 0, fw_vers, 6);\n}\n\nstatic int gp8psk_get_fpga_version(struct dvb_usb_device *d, u8 *fpga_vers)\n{\n\treturn gp8psk_usb_in_op(d, GET_FPGA_VERS, 0, 0, fpga_vers, 1);\n}\n\nstatic void gp8psk_info(struct dvb_usb_device *d)\n{\n\tu8 fpga_vers, fw_vers[6];\n\n\tif (!gp8psk_get_fw_version(d, fw_vers))\n\t\tinfo(\"FW Version = %i.%02i.%i (0x%x)  Build %4i/%02i/%02i\",\n\t\tfw_vers[2], fw_vers[1], fw_vers[0], GP8PSK_FW_VERS(fw_vers),\n\t\t2000 + fw_vers[5], fw_vers[4], fw_vers[3]);\n\telse\n\t\tinfo(\"failed to get FW version\");\n\n\tif (!gp8psk_get_fpga_version(d, &fpga_vers))\n\t\tinfo(\"FPGA Version = %i\", fpga_vers);\n\telse\n\t\tinfo(\"failed to get FPGA version\");\n}\n\nstatic int gp8psk_load_bcm4500fw(struct dvb_usb_device *d)\n{\n\tint ret;\n\tconst struct firmware *fw = NULL;\n\tconst u8 *ptr;\n\tu8 *buf;\n\tif ((ret = request_firmware(&fw, bcm4500_firmware,\n\t\t\t\t\t&d->udev->dev)) != 0) {\n\t\terr(\"did not find the bcm4500 firmware file '%s' (status %d). You can use <kernel_dir>/scripts/get_dvb_firmware to get the firmware\",\n\t\t\tbcm4500_firmware,ret);\n\t\treturn ret;\n\t}\n\n\tret = -EINVAL;\n\n\tif (gp8psk_usb_out_op(d, LOAD_BCM4500,1,0,NULL, 0))\n\t\tgoto out_rel_fw;\n\n\tinfo(\"downloading bcm4500 firmware from file '%s'\",bcm4500_firmware);\n\n\tptr = fw->data;\n\tbuf = kmalloc(64, GFP_KERNEL);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out_rel_fw;\n\t}\n\n\twhile (ptr[0] != 0xff) {\n\t\tu16 buflen = ptr[0] + 4;\n\t\tif (ptr + buflen >= fw->data + fw->size) {\n\t\t\terr(\"failed to load bcm4500 firmware.\");\n\t\t\tgoto out_free;\n\t\t}\n\t\tif (buflen > 64) {\n\t\t\terr(\"firmware chunk size bigger than 64 bytes.\");\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tmemcpy(buf, ptr, buflen);\n\t\tif (dvb_usb_generic_write(d, buf, buflen)) {\n\t\t\terr(\"failed to load bcm4500 firmware.\");\n\t\t\tgoto out_free;\n\t\t}\n\t\tptr += buflen;\n\t}\n\n\tret = 0;\n\nout_free:\n\tkfree(buf);\nout_rel_fw:\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic int gp8psk_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tu8 status = 0, buf;\n\tint gp_product_id = le16_to_cpu(d->udev->descriptor.idProduct);\n\n\tif (onoff) {\n\t\tgp8psk_usb_in_op(d, GET_8PSK_CONFIG,0,0,&status,1);\n\t\tif (! (status & bm8pskStarted)) {   \n\t\t\tif(gp_product_id == USB_PID_GENPIX_SKYWALKER_CW3K)\n\t\t\t\tgp8psk_usb_out_op(d, CW3K_INIT, 1, 0, NULL, 0);\n\t\t\tif (gp8psk_usb_in_op(d, BOOT_8PSK, 1, 0, &buf, 1))\n\t\t\t\treturn -EINVAL;\n\t\t\tgp8psk_info(d);\n\t\t}\n\n\t\tif (gp_product_id == USB_PID_GENPIX_8PSK_REV_1_WARM)\n\t\t\tif (! (status & bm8pskFW_Loaded))  \n\t\t\t\tif(gp8psk_load_bcm4500fw(d))\n\t\t\t\t\treturn -EINVAL;\n\n\t\tif (! (status & bmIntersilOn))  \n\t\t\tif (gp8psk_usb_in_op(d, START_INTERSIL, 1, 0,\n\t\t\t\t\t&buf, 1))\n\t\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (gp_product_id == USB_PID_GENPIX_8PSK_REV_1_WARM)\n\t\t\tif (gp8psk_usb_out_op(d, SET_DVB_MODE, 1, 0, NULL, 0))\n\t\t\t\treturn -EINVAL;\n\t\t \n\t\tif (gp8psk_usb_out_op(d, ARM_TRANSFER, 0, 0, NULL, 0))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tif (gp8psk_usb_in_op(d, START_INTERSIL, 0, 0, &buf, 1))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (gp8psk_usb_in_op(d, BOOT_8PSK, 0, 0, &buf, 1))\n\t\t\treturn -EINVAL;\n\t\tif(gp_product_id == USB_PID_GENPIX_SKYWALKER_CW3K)\n\t\t\tgp8psk_usb_out_op(d, CW3K_INIT, 0, 0, NULL, 0);\n\t}\n\treturn 0;\n}\n\nstatic int gp8psk_bcm4500_reload(struct dvb_usb_device *d)\n{\n\tu8 buf;\n\tint gp_product_id = le16_to_cpu(d->udev->descriptor.idProduct);\n\n\tdeb_xfer(\"reloading firmware\\n\");\n\n\t \n\tif (gp8psk_usb_in_op(d, BOOT_8PSK, 0, 0, &buf, 1))\n\t\treturn -EINVAL;\n\t \n\tif (gp8psk_usb_in_op(d, BOOT_8PSK, 1, 0, &buf, 1))\n\t\treturn -EINVAL;\n\t \n\tif (gp_product_id == USB_PID_GENPIX_8PSK_REV_1_WARM)\n\t\tif (gp8psk_load_bcm4500fw(d))\n\t\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int gp8psk_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\n{\n\treturn gp8psk_usb_out_op(adap->dev, ARM_TRANSFER, onoff, 0 , NULL, 0);\n}\n\n \n\nstatic int gp8psk_fe_in(void *priv, u8 req, u16 value,\n\t\t\t    u16 index, u8 *b, int blen)\n{\n\tstruct dvb_usb_device *d = priv;\n\n\treturn gp8psk_usb_in_op(d, req, value, index, b, blen);\n}\n\nstatic int gp8psk_fe_out(void *priv, u8 req, u16 value,\n\t\t\t    u16 index, u8 *b, int blen)\n{\n\tstruct dvb_usb_device *d = priv;\n\n\treturn gp8psk_usb_out_op(d, req, value, index, b, blen);\n}\n\nstatic int gp8psk_fe_reload(void *priv)\n{\n\tstruct dvb_usb_device *d = priv;\n\n\treturn gp8psk_bcm4500_reload(d);\n}\n\nstatic const struct gp8psk_fe_ops gp8psk_fe_ops = {\n\t.in = gp8psk_fe_in,\n\t.out = gp8psk_fe_out,\n\t.reload = gp8psk_fe_reload,\n};\n\nstatic int gp8psk_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tint id = le16_to_cpu(d->udev->descriptor.idProduct);\n\tint is_rev1;\n\n\tis_rev1 = (id == USB_PID_GENPIX_8PSK_REV_1_WARM) ? true : false;\n\n\tadap->fe_adap[0].fe = dvb_attach(gp8psk_fe_attach,\n\t\t\t\t\t &gp8psk_fe_ops, d, is_rev1);\n\treturn 0;\n}\n\nstatic struct dvb_usb_device_properties gp8psk_properties;\n\nstatic int gp8psk_usb_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tint ret;\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tret = dvb_usb_device_init(intf, &gp8psk_properties,\n\t\t\t\t  THIS_MODULE, NULL, adapter_nr);\n\tif (ret == 0) {\n\t\tinfo(\"found Genpix USB device pID = %x (hex)\",\n\t\t\tle16_to_cpu(udev->descriptor.idProduct));\n\t}\n\treturn ret;\n}\n\nenum {\n\tGENPIX_8PSK_REV_1_COLD,\n\tGENPIX_8PSK_REV_1_WARM,\n\tGENPIX_8PSK_REV_2,\n\tGENPIX_SKYWALKER_1,\n\tGENPIX_SKYWALKER_2,\n\tGENPIX_SKYWALKER_CW3K,\n};\n\nstatic struct usb_device_id gp8psk_usb_table[] = {\n\tDVB_USB_DEV(GENPIX, GENPIX_8PSK_REV_1_COLD),\n\tDVB_USB_DEV(GENPIX, GENPIX_8PSK_REV_1_WARM),\n\tDVB_USB_DEV(GENPIX, GENPIX_8PSK_REV_2),\n\tDVB_USB_DEV(GENPIX, GENPIX_SKYWALKER_1),\n\tDVB_USB_DEV(GENPIX, GENPIX_SKYWALKER_2),\n\tDVB_USB_DEV(GENPIX, GENPIX_SKYWALKER_CW3K),\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, gp8psk_usb_table);\n\nstatic struct dvb_usb_device_properties gp8psk_properties = {\n\t.usb_ctrl = CYPRESS_FX2,\n\t.firmware = \"dvb-usb-gp8psk-01.fw\",\n\n\t.size_of_priv = sizeof(struct gp8psk_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = gp8psk_streaming_ctrl,\n\t\t\t.frontend_attach  = gp8psk_frontend_attach,\n\t\t\t \n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 7,\n\t\t\t\t.endpoint = 0x82,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 8192,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t}\n\t},\n\t.power_ctrl       = gp8psk_power_ctrl,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.num_device_descs = 4,\n\t.devices = {\n\t\t{ .name = \"Genpix 8PSK-to-USB2 Rev.1 DVB-S receiver\",\n\t\t  .cold_ids = { &gp8psk_usb_table[GENPIX_8PSK_REV_1_COLD], NULL },\n\t\t  .warm_ids = { &gp8psk_usb_table[GENPIX_8PSK_REV_1_WARM], NULL },\n\t\t},\n\t\t{ .name = \"Genpix 8PSK-to-USB2 Rev.2 DVB-S receiver\",\n\t\t  .cold_ids = { NULL },\n\t\t  .warm_ids = { &gp8psk_usb_table[GENPIX_8PSK_REV_2], NULL },\n\t\t},\n\t\t{ .name = \"Genpix SkyWalker-1 DVB-S receiver\",\n\t\t  .cold_ids = { NULL },\n\t\t  .warm_ids = { &gp8psk_usb_table[GENPIX_SKYWALKER_1], NULL },\n\t\t},\n\t\t{ .name = \"Genpix SkyWalker-2 DVB-S receiver\",\n\t\t  .cold_ids = { NULL },\n\t\t  .warm_ids = { &gp8psk_usb_table[GENPIX_SKYWALKER_2], NULL },\n\t\t},\n\t\t{ NULL },\n\t}\n};\n\n \nstatic struct usb_driver gp8psk_usb_driver = {\n\t.name\t\t= \"dvb_usb_gp8psk\",\n\t.probe\t\t= gp8psk_usb_probe,\n\t.disconnect = dvb_usb_device_exit,\n\t.id_table\t= gp8psk_usb_table,\n};\n\nmodule_usb_driver(gp8psk_usb_driver);\n\nMODULE_AUTHOR(\"Alan Nisota <alannisota@gamil.com>\");\nMODULE_DESCRIPTION(\"Driver for Genpix DVB-S\");\nMODULE_VERSION(\"1.1\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}