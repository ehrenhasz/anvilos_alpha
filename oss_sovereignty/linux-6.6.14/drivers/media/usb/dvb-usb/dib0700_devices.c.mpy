{
  "module_name": "dib0700_devices.c",
  "hash_id": "41f29b83dc8f0eb2f6303d993dd885e645d4e713fce3105a75ed727591b1a65e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/dib0700_devices.c",
  "human_readable_source": "\n \n#include \"dib0700.h\"\n\n#include \"dib3000mc.h\"\n#include \"dib7000m.h\"\n#include \"dib7000p.h\"\n#include \"dib8000.h\"\n#include \"dib9000.h\"\n#include \"mt2060.h\"\n#include \"mt2266.h\"\n#include \"xc2028.h\"\n#include \"xc5000.h\"\n#include \"xc4000.h\"\n#include \"s5h1411.h\"\n#include \"dib0070.h\"\n#include \"dib0090.h\"\n#include \"lgdt3305.h\"\n#include \"mxl5007t.h\"\n#include \"mn88472.h\"\n#include \"tda18250.h\"\n\n\nstatic int force_lna_activation;\nmodule_param(force_lna_activation, int, 0644);\nMODULE_PARM_DESC(force_lna_activation, \"force the activation of Low-Noise-Amplifier(s) (LNA), if applicable for the device (default: 0=automatic/off).\");\n\nstruct dib0700_adapter_state {\n\tint (*set_param_save) (struct dvb_frontend *);\n\tconst struct firmware *frontend_firmware;\n\tstruct dib7000p_ops dib7000p_ops;\n\tstruct dib8000_ops dib8000_ops;\n};\n\n \nstatic struct mt2060_config bristol_mt2060_config[2] = {\n\t{\n\t\t.i2c_address = 0x60,\n\t\t.clock_out   = 3,\n\t}, {\n\t\t.i2c_address = 0x61,\n\t}\n};\n\n\nstatic struct dibx000_agc_config bristol_dib3000p_mt2060_agc_config = {\n\t.band_caps = BAND_VHF | BAND_UHF,\n\t.setup     = (1 << 8) | (5 << 5) | (0 << 4) | (0 << 3) | (0 << 2) | (2 << 0),\n\n\t.agc1_max = 42598,\n\t.agc1_min = 17694,\n\t.agc2_max = 45875,\n\t.agc2_min = 0,\n\n\t.agc1_pt1 = 0,\n\t.agc1_pt2 = 59,\n\n\t.agc1_slope1 = 0,\n\t.agc1_slope2 = 69,\n\n\t.agc2_pt1 = 0,\n\t.agc2_pt2 = 59,\n\n\t.agc2_slope1 = 111,\n\t.agc2_slope2 = 28,\n};\n\nstatic struct dib3000mc_config bristol_dib3000mc_config[2] = {\n\t{\t.agc          = &bristol_dib3000p_mt2060_agc_config,\n\t\t.max_time     = 0x196,\n\t\t.ln_adc_level = 0x1cc7,\n\t\t.output_mpeg2_in_188_bytes = 1,\n\t},\n\t{\t.agc          = &bristol_dib3000p_mt2060_agc_config,\n\t\t.max_time     = 0x196,\n\t\t.ln_adc_level = 0x1cc7,\n\t\t.output_mpeg2_in_188_bytes = 1,\n\t}\n};\n\nstatic int bristol_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_state *st = adap->dev->priv;\n\tif (adap->id == 0) {\n\t\tdib0700_set_gpio(adap->dev, GPIO6,  GPIO_OUT, 0); msleep(10);\n\t\tdib0700_set_gpio(adap->dev, GPIO6,  GPIO_OUT, 1); msleep(10);\n\t\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0); msleep(10);\n\t\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1); msleep(10);\n\n\t\tif (force_lna_activation)\n\t\t\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\t\telse\n\t\t\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 0);\n\n\t\tif (dib3000mc_i2c_enumeration(&adap->dev->i2c_adap, 2, DEFAULT_DIB3000P_I2C_ADDRESS, bristol_dib3000mc_config) != 0) {\n\t\t\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0); msleep(10);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tst->mt2060_if1[adap->id] = 1220;\n\treturn (adap->fe_adap[0].fe = dvb_attach(dib3000mc_attach, &adap->dev->i2c_adap,\n\t\t(10 + adap->id) << 1, &bristol_dib3000mc_config[adap->id])) == NULL ? -ENODEV : 0;\n}\n\nstatic int eeprom_read(struct i2c_adapter *adap,u8 adrs,u8 *pval)\n{\n\tstruct i2c_msg msg[2] = {\n\t\t{ .addr = 0x50, .flags = 0,        .buf = &adrs, .len = 1 },\n\t\t{ .addr = 0x50, .flags = I2C_M_RD, .buf = pval,  .len = 1 },\n\t};\n\tif (i2c_transfer(adap, msg, 2) != 2) return -EREMOTEIO;\n\treturn 0;\n}\n\nstatic int bristol_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct i2c_adapter *prim_i2c = &adap->dev->i2c_adap;\n\tstruct i2c_adapter *tun_i2c = dib3000mc_get_tuner_i2c_master(adap->fe_adap[0].fe, 1);\n\ts8 a;\n\tint if1=1220;\n\tif (adap->dev->udev->descriptor.idVendor  == cpu_to_le16(USB_VID_HAUPPAUGE) &&\n\t\tadap->dev->udev->descriptor.idProduct == cpu_to_le16(USB_PID_HAUPPAUGE_NOVA_T_500_2)) {\n\t\tif (!eeprom_read(prim_i2c,0x59 + adap->id,&a)) if1=1220+a;\n\t}\n\treturn dvb_attach(mt2060_attach, adap->fe_adap[0].fe, tun_i2c,\n\t\t\t  &bristol_mt2060_config[adap->id], if1) == NULL ?\n\t\t\t  -ENODEV : 0;\n}\n\n \n\n \nstatic struct dibx000_agc_config stk7700d_7000p_mt2266_agc_config[2] = {\n\t{\n\t\tBAND_UHF,\n\n\t\t \n\t\t(0 << 15) | (0 << 14) | (1 << 11) | (1 << 10) | (1 << 9) | (0 << 8)\n\t    | (3 << 5) | (0 << 4) | (5 << 1) | (0 << 0),\n\n\t\t1130,\n\t\t21,\n\n\t\t0,\n\t\t118,\n\n\t\t0,\n\t\t3530,\n\t\t1,\n\t\t0,\n\n\t\t65535,\n\t\t33770,\n\t\t65535,\n\t\t23592,\n\n\t\t0,\n\t\t62,\n\t\t255,\n\t\t64,\n\t\t64,\n\t\t132,\n\t\t192,\n\t\t80,\n\t\t80,\n\n\t\t17,\n\t\t27,\n\t\t23,\n\t\t51,\n\n\t\t1,\n\t}, {\n\t\tBAND_VHF | BAND_LBAND,\n\n\t\t \n\t\t(0 << 15) | (0 << 14) | (1 << 11) | (1 << 10) | (1 << 9) | (0 << 8)\n\t    | (3 << 5) | (0 << 4) | (2 << 1) | (0 << 0),\n\n\t\t2372,\n\t\t21,\n\n\t\t0,\n\t\t118,\n\n\t\t0,\n\t\t3530,\n\t\t1,\n\t\t0,\n\n\t\t65535,\n\t\t0,\n\t\t65535,\n\t\t23592,\n\n\t\t0,\n\t\t128,\n\t\t128,\n\t\t128,\n\t\t0,\n\t\t128,\n\t\t253,\n\t\t81,\n\t\t0,\n\n\t\t17,\n\t\t27,\n\t\t23,\n\t\t51,\n\n\t\t1,\n\t}\n};\n\nstatic struct dibx000_bandwidth_config stk7700d_mt2266_pll_config = {\n\t.internal = 60000,\n\t.sampling = 30000,\n\t.pll_prediv = 1,\n\t.pll_ratio = 8,\n\t.pll_range = 3,\n\t.pll_reset = 1,\n\t.pll_bypass = 0,\n\t.enable_refdiv = 0,\n\t.bypclk_div = 0,\n\t.IO_CLK_en_core = 1,\n\t.ADClkSrc = 1,\n\t.modulo = 2,\n\t.sad_cfg = (3 << 14) | (1 << 12) | (524 << 0),\n\t.ifreq = 0,\n\t.timf = 20452225,\n};\n\nstatic struct dib7000p_config stk7700d_dib7000p_mt2266_config[] = {\n\t{\t.output_mpeg2_in_188_bytes = 1,\n\t\t.hostbus_diversity = 1,\n\t\t.tuner_is_baseband = 1,\n\n\t\t.agc_config_count = 2,\n\t\t.agc = stk7700d_7000p_mt2266_agc_config,\n\t\t.bw  = &stk7700d_mt2266_pll_config,\n\n\t\t.gpio_dir = DIB7000P_GPIO_DEFAULT_DIRECTIONS,\n\t\t.gpio_val = DIB7000P_GPIO_DEFAULT_VALUES,\n\t\t.gpio_pwm_pos = DIB7000P_GPIO_DEFAULT_PWM_POS,\n\t},\n\t{\t.output_mpeg2_in_188_bytes = 1,\n\t\t.hostbus_diversity = 1,\n\t\t.tuner_is_baseband = 1,\n\n\t\t.agc_config_count = 2,\n\t\t.agc = stk7700d_7000p_mt2266_agc_config,\n\t\t.bw  = &stk7700d_mt2266_pll_config,\n\n\t\t.gpio_dir = DIB7000P_GPIO_DEFAULT_DIRECTIONS,\n\t\t.gpio_val = DIB7000P_GPIO_DEFAULT_VALUES,\n\t\t.gpio_pwm_pos = DIB7000P_GPIO_DEFAULT_PWM_POS,\n\t}\n};\n\nstatic struct mt2266_config stk7700d_mt2266_config[2] = {\n\t{\t.i2c_address = 0x60\n\t},\n\t{\t.i2c_address = 0x60\n\t}\n};\n\nstatic int stk7700P2_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\tif (adap->id == 0) {\n\t\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\t\tmsleep(10);\n\t\tdib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\n\t\tdib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\n\t\tdib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\n\t\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\t\tmsleep(10);\n\t\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\t\tmsleep(10);\n\t\tif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 18,\n\t\t\t\t\t     stk7700d_dib7000p_mt2266_config)\n\t\t    != 0) {\n\t\t\terr(\"%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\\n\", __func__);\n\t\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap,\n\t\t\t   0x80 + (adap->id << 1),\n\t\t\t   &stk7700d_dib7000p_mt2266_config[adap->id]);\n\n\treturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\n}\n\nstatic int stk7700d_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\tif (adap->id == 0) {\n\t\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\t\tmsleep(10);\n\t\tdib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\n\t\tdib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\n\t\tdib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\n\t\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\t\tmsleep(10);\n\t\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\t\tmsleep(10);\n\t\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\t\tif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 2, 18,\n\t\t\t\t\t     stk7700d_dib7000p_mt2266_config)\n\t\t    != 0) {\n\t\t\terr(\"%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\\n\", __func__);\n\t\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap,\n\t\t\t   0x80 + (adap->id << 1),\n\t\t\t   &stk7700d_dib7000p_mt2266_config[adap->id]);\n\n\treturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\n}\n\nstatic int stk7700d_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct i2c_adapter *tun_i2c;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\ttun_i2c = state->dib7000p_ops.get_i2c_master(adap->fe_adap[0].fe,\n\t\t\t\t\t    DIBX000_I2C_INTERFACE_TUNER, 1);\n\treturn dvb_attach(mt2266_attach, adap->fe_adap[0].fe, tun_i2c,\n\t\t&stk7700d_mt2266_config[adap->id]) == NULL ? -ENODEV : 0;\n}\n\n \nstatic struct dibx000_agc_config xc3028_agc_config = {\n\t.band_caps = BAND_VHF | BAND_UHF,\n\t \n\t.setup = (0 << 15) | (0 << 14) | (0 << 11) | (0 << 10) | (0 << 9) | (0 << 8) | (3 << 5) | (0 << 4) | (2 << 1) | (0 << 0),\n\t.inv_gain = 712,\n\t.time_stabiliz = 21,\n\t.alpha_level = 0,\n\t.thlock = 118,\n\t.wbd_inv = 0,\n\t.wbd_ref = 2867,\n\t.wbd_sel = 0,\n\t.wbd_alpha = 2,\n\t.agc1_max = 0,\n\t.agc1_min = 0,\n\t.agc2_max = 39718,\n\t.agc2_min = 9930,\n\t.agc1_pt1 = 0,\n\t.agc1_pt2 = 0,\n\t.agc1_pt3 = 0,\n\t.agc1_slope1 = 0,\n\t.agc1_slope2 = 0,\n\t.agc2_pt1 = 0,\n\t.agc2_pt2 = 128,\n\t.agc2_slope1 = 29,\n\t.agc2_slope2 = 29,\n\t.alpha_mant = 17,\n\t.alpha_exp = 27,\n\t.beta_mant = 23,\n\t.beta_exp = 51,\n\t.perform_agc_softsplit = 1,\n};\n\n \nstatic struct dibx000_bandwidth_config xc3028_bw_config = {\n\t.internal = 60000,\n\t.sampling = 30000,\n\t.pll_prediv = 1,\n\t.pll_ratio = 8,\n\t.pll_range = 3,\n\t.pll_reset = 1,\n\t.pll_bypass = 0,\n\t.enable_refdiv = 0,\n\t.bypclk_div = 0,\n\t.IO_CLK_en_core = 1,\n\t.ADClkSrc = 1,\n\t.modulo = 0,\n\t.sad_cfg = (3 << 14) | (1 << 12) | (524 << 0),  \n\t.ifreq = (1 << 25) | 5816102,   \n\t.timf = 20452225,\n\t.xtal_hz = 30000000,\n};\n\nstatic struct dib7000p_config stk7700ph_dib7700_xc3028_config = {\n\t.output_mpeg2_in_188_bytes = 1,\n\t.tuner_is_baseband = 1,\n\n\t.agc_config_count = 1,\n\t.agc = &xc3028_agc_config,\n\t.bw  = &xc3028_bw_config,\n\n\t.gpio_dir = DIB7000P_GPIO_DEFAULT_DIRECTIONS,\n\t.gpio_val = DIB7000P_GPIO_DEFAULT_VALUES,\n\t.gpio_pwm_pos = DIB7000P_GPIO_DEFAULT_PWM_POS,\n};\n\nstatic int stk7700ph_xc3028_callback(void *ptr, int component,\n\t\t\t\t     int command, int arg)\n{\n\tstruct dvb_usb_adapter *adap = ptr;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tswitch (command) {\n\tcase XC2028_TUNER_RESET:\n\t\t \n\t\tstate->dib7000p_ops.set_gpio(adap->fe_adap[0].fe, 8, 0, 0);\n\t\tmsleep(10);\n\t\tstate->dib7000p_ops.set_gpio(adap->fe_adap[0].fe, 8, 0, 1);\n\t\tbreak;\n\tcase XC2028_RESET_CLK:\n\tcase XC2028_I2C_FLUSH:\n\t\tbreak;\n\tdefault:\n\t\terr(\"%s: unknown command %d, arg %d\\n\", __func__,\n\t\t\tcommand, arg);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic struct xc2028_ctrl stk7700ph_xc3028_ctrl = {\n\t.fname = XC2028_DEFAULT_FIRMWARE,\n\t.max_len = 64,\n\t.demod = XC3028_FE_DIBCOM52,\n};\n\nstatic struct xc2028_config stk7700ph_xc3028_config = {\n\t.i2c_addr = 0x61,\n\t.ctrl = &stk7700ph_xc3028_ctrl,\n};\n\nstatic int stk7700ph_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct usb_device_descriptor *desc = &adap->dev->udev->descriptor;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\tif (desc->idVendor  == cpu_to_le16(USB_VID_PINNACLE) &&\n\t    desc->idProduct == cpu_to_le16(USB_PID_PINNACLE_EXPRESSCARD_320CX))\n\t\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0);\n\telse\n\t\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\tmsleep(10);\n\n\tif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 18,\n\t\t\t\t     &stk7700ph_dib7700_xc3028_config) != 0) {\n\t\terr(\"%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\\n\",\n\t\t    __func__);\n\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);\n\t\treturn -ENODEV;\n\t}\n\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x80,\n\t\t&stk7700ph_dib7700_xc3028_config);\n\n\treturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\n}\n\nstatic int stk7700ph_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct i2c_adapter *tun_i2c;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\ttun_i2c = state->dib7000p_ops.get_i2c_master(adap->fe_adap[0].fe,\n\t\tDIBX000_I2C_INTERFACE_TUNER, 1);\n\n\tstk7700ph_xc3028_config.i2c_adap = tun_i2c;\n\n\t \n\tadap->fe_adap[0].fe->callback = stk7700ph_xc3028_callback;\n\n\treturn dvb_attach(xc2028_attach, adap->fe_adap[0].fe, &stk7700ph_xc3028_config)\n\t\t== NULL ? -ENODEV : 0;\n}\n\n#define DEFAULT_RC_INTERVAL 50\n\n \nstatic int dib0700_rc_query_old_firmware(struct dvb_usb_device *d)\n{\n\tenum rc_proto protocol;\n\tu32 scancode;\n\tu8 toggle;\n\tint i;\n\tstruct dib0700_state *st = d->priv;\n\n\tif (st->fw_version >= 0x10200) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tst->buf[0] = REQUEST_POLL_RC;\n\tst->buf[1] = 0;\n\n\ti = dib0700_ctrl_rd(d, st->buf, 2, st->buf, 4);\n\tif (i <= 0) {\n\t\terr(\"RC Query Failed\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (st->buf[0] == 0 && st->buf[1] == 0\n\t    && st->buf[2] == 0 && st->buf[3] == 0)\n\t\treturn 0;\n\n\t \n\n\tdib0700_rc_setup(d, NULL);  \n\n\tswitch (d->props.rc.core.protocol) {\n\tcase RC_PROTO_BIT_NEC:\n\t\t \n\t\tif ((st->buf[3 - 2] == 0x00) && (st->buf[3 - 3] == 0x00) &&\n\t\t    (st->buf[3] == 0xff)) {\n\t\t\trc_repeat(d->rc_dev);\n\t\t\treturn 0;\n\t\t}\n\n\t\tprotocol = RC_PROTO_NEC;\n\t\tscancode = RC_SCANCODE_NEC(st->buf[3 - 2], st->buf[3 - 3]);\n\t\ttoggle = 0;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tprotocol = RC_PROTO_RC5;\n\t\tscancode = RC_SCANCODE_RC5(st->buf[3 - 2], st->buf[3 - 3]);\n\t\ttoggle = st->buf[3 - 1];\n\t\tbreak;\n\t}\n\n\trc_keydown(d->rc_dev, protocol, scancode, toggle);\n\treturn 0;\n}\n\n \nstatic struct dibx000_agc_config stk7700p_7000m_mt2060_agc_config = {\n\tBAND_UHF | BAND_VHF,\n\n\t \n\t(0 << 15) | (0 << 14) | (5 << 11) | (0 << 10) | (0 << 9) | (0 << 8)\n\t| (3 << 5) | (0 << 4) | (2 << 1) | (0 << 0),\n\n\t712,\n\t41,\n\n\t0,\n\t118,\n\n\t0,\n\t4095,\n\t0,\n\t0,\n\n\t42598,\n\t17694,\n\t45875,\n\t2621,\n\t0,\n\t76,\n\t139,\n\t52,\n\t59,\n\t107,\n\t172,\n\t57,\n\t70,\n\n\t21,\n\t25,\n\t28,\n\t48,\n\n\t1,\n\t{  0,\n\t   107,\n\t   51800,\n\t   24700\n\t},\n};\n\nstatic struct dibx000_agc_config stk7700p_7000p_mt2060_agc_config = {\n\t.band_caps = BAND_UHF | BAND_VHF,\n\t \n\t.setup = (0 << 15) | (0 << 14) | (5 << 11) | (0 << 10) | (0 << 9) | (0 << 8) | (3 << 5) | (0 << 4) | (2 << 1) | (0 << 0),\n\t.inv_gain = 712,\n\t.time_stabiliz = 41,\n\t.alpha_level = 0,\n\t.thlock = 118,\n\t.wbd_inv = 0,\n\t.wbd_ref = 4095,\n\t.wbd_sel = 0,\n\t.wbd_alpha = 0,\n\t.agc1_max = 42598,\n\t.agc1_min = 16384,\n\t.agc2_max = 42598,\n\t.agc2_min = 0,\n\t.agc1_pt1 = 0,\n\t.agc1_pt2 = 137,\n\t.agc1_pt3 = 255,\n\t.agc1_slope1 = 0,\n\t.agc1_slope2 = 255,\n\t.agc2_pt1 = 0,\n\t.agc2_pt2 = 0,\n\t.agc2_slope1 = 0,\n\t.agc2_slope2 = 41,\n\t.alpha_mant = 15,\n\t.alpha_exp = 25,\n\t.beta_mant = 28,\n\t.beta_exp = 48,\n\t.perform_agc_softsplit = 0,\n};\n\nstatic struct dibx000_bandwidth_config stk7700p_pll_config = {\n\t.internal = 60000,\n\t.sampling = 30000,\n\t.pll_prediv = 1,\n\t.pll_ratio = 8,\n\t.pll_range = 3,\n\t.pll_reset = 1,\n\t.pll_bypass = 0,\n\t.enable_refdiv = 0,\n\t.bypclk_div = 0,\n\t.IO_CLK_en_core = 1,\n\t.ADClkSrc = 1,\n\t.modulo = 0,\n\t.sad_cfg = (3 << 14) | (1 << 12) | (524 << 0),\n\t.ifreq = 60258167,\n\t.timf = 20452225,\n\t.xtal_hz = 30000000,\n};\n\nstatic struct dib7000m_config stk7700p_dib7000m_config = {\n\t.dvbt_mode = 1,\n\t.output_mpeg2_in_188_bytes = 1,\n\t.quartz_direct = 1,\n\n\t.agc_config_count = 1,\n\t.agc = &stk7700p_7000m_mt2060_agc_config,\n\t.bw  = &stk7700p_pll_config,\n\n\t.gpio_dir = DIB7000M_GPIO_DEFAULT_DIRECTIONS,\n\t.gpio_val = DIB7000M_GPIO_DEFAULT_VALUES,\n\t.gpio_pwm_pos = DIB7000M_GPIO_DEFAULT_PWM_POS,\n};\n\nstatic struct dib7000p_config stk7700p_dib7000p_config = {\n\t.output_mpeg2_in_188_bytes = 1,\n\n\t.agc_config_count = 1,\n\t.agc = &stk7700p_7000p_mt2060_agc_config,\n\t.bw  = &stk7700p_pll_config,\n\n\t.gpio_dir = DIB7000M_GPIO_DEFAULT_DIRECTIONS,\n\t.gpio_val = DIB7000M_GPIO_DEFAULT_VALUES,\n\t.gpio_pwm_pos = DIB7000M_GPIO_DEFAULT_PWM_POS,\n};\n\nstatic int stk7700p_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_state *st = adap->dev->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\t \n\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\tdib0700_set_gpio(adap->dev, GPIO6,  GPIO_OUT, 0); msleep(50);\n\n\tdib0700_set_gpio(adap->dev, GPIO6,  GPIO_OUT, 1); msleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO9,  GPIO_OUT, 1);\n\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0); msleep(10);\n\tdib0700_ctrl_clock(adap->dev, 72, 1);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1); msleep(100);\n\n\tdib0700_set_gpio(adap->dev,  GPIO0, GPIO_OUT, 1);\n\n\tst->mt2060_if1[0] = 1220;\n\n\tif (state->dib7000p_ops.dib7000pc_detection(&adap->dev->i2c_adap)) {\n\t\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 18, &stk7700p_dib7000p_config);\n\t\tst->is_dib7000pc = 1;\n\t} else {\n\t\tmemset(&state->dib7000p_ops, 0, sizeof(state->dib7000p_ops));\n\t\tadap->fe_adap[0].fe = dvb_attach(dib7000m_attach, &adap->dev->i2c_adap, 18, &stk7700p_dib7000m_config);\n\t}\n\n\treturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\n}\n\nstatic struct mt2060_config stk7700p_mt2060_config = {\n\t0x60\n};\n\nstatic int stk7700p_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct i2c_adapter *prim_i2c = &adap->dev->i2c_adap;\n\tstruct dib0700_state *st = adap->dev->priv;\n\tstruct i2c_adapter *tun_i2c;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\ts8 a;\n\tint if1=1220;\n\n\tif (adap->dev->udev->descriptor.idVendor  == cpu_to_le16(USB_VID_HAUPPAUGE) &&\n\t\tadap->dev->udev->descriptor.idProduct == cpu_to_le16(USB_PID_HAUPPAUGE_NOVA_T_STICK)) {\n\t\tif (!eeprom_read(prim_i2c,0x58,&a)) if1=1220+a;\n\t}\n\tif (st->is_dib7000pc)\n\t\ttun_i2c = state->dib7000p_ops.get_i2c_master(adap->fe_adap[0].fe, DIBX000_I2C_INTERFACE_TUNER, 1);\n\telse\n\t\ttun_i2c = dib7000m_get_i2c_master(adap->fe_adap[0].fe, DIBX000_I2C_INTERFACE_TUNER, 1);\n\n\treturn dvb_attach(mt2060_attach, adap->fe_adap[0].fe, tun_i2c, &stk7700p_mt2060_config,\n\t\tif1) == NULL ? -ENODEV : 0;\n}\n\n \nstatic struct dibx000_agc_config dib7070_agc_config = {\n\t.band_caps = BAND_UHF | BAND_VHF | BAND_LBAND | BAND_SBAND,\n\t \n\t.setup = (0 << 15) | (0 << 14) | (5 << 11) | (0 << 10) | (0 << 9) | (0 << 8) | (3 << 5) | (0 << 4) | (5 << 1) | (0 << 0),\n\t.inv_gain = 600,\n\t.time_stabiliz = 10,\n\t.alpha_level = 0,\n\t.thlock = 118,\n\t.wbd_inv = 0,\n\t.wbd_ref = 3530,\n\t.wbd_sel = 1,\n\t.wbd_alpha = 5,\n\t.agc1_max = 65535,\n\t.agc1_min = 0,\n\t.agc2_max = 65535,\n\t.agc2_min = 0,\n\t.agc1_pt1 = 0,\n\t.agc1_pt2 = 40,\n\t.agc1_pt3 = 183,\n\t.agc1_slope1 = 206,\n\t.agc1_slope2 = 255,\n\t.agc2_pt1 = 72,\n\t.agc2_pt2 = 152,\n\t.agc2_slope1 = 88,\n\t.agc2_slope2 = 90,\n\t.alpha_mant = 17,\n\t.alpha_exp = 27,\n\t.beta_mant = 23,\n\t.beta_exp = 51,\n\t.perform_agc_softsplit = 0,\n};\n\nstatic int dib7070_tuner_reset(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tdeb_info(\"reset: %d\", onoff);\n\treturn state->dib7000p_ops.set_gpio(fe, 8, 0, !onoff);\n}\n\nstatic int dib7070_tuner_sleep(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tdeb_info(\"sleep: %d\", onoff);\n\treturn state->dib7000p_ops.set_gpio(fe, 9, 0, onoff);\n}\n\nstatic struct dib0070_config dib7070p_dib0070_config[2] = {\n\t{\n\t\t.i2c_address = DEFAULT_DIB0070_I2C_ADDRESS,\n\t\t.reset = dib7070_tuner_reset,\n\t\t.sleep = dib7070_tuner_sleep,\n\t\t.clock_khz = 12000,\n\t\t.clock_pad_drive = 4,\n\t\t.charge_pump = 2,\n\t}, {\n\t\t.i2c_address = DEFAULT_DIB0070_I2C_ADDRESS,\n\t\t.reset = dib7070_tuner_reset,\n\t\t.sleep = dib7070_tuner_sleep,\n\t\t.clock_khz = 12000,\n\t\t.charge_pump = 2,\n\t}\n};\n\nstatic struct dib0070_config dib7770p_dib0070_config = {\n\t .i2c_address = DEFAULT_DIB0070_I2C_ADDRESS,\n\t .reset = dib7070_tuner_reset,\n\t .sleep = dib7070_tuner_sleep,\n\t .clock_khz = 12000,\n\t .clock_pad_drive = 0,\n\t .flip_chip = 1,\n\t .charge_pump = 2,\n};\n\nstatic int dib7070_set_param_override(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tu16 offset;\n\tu8 band = BAND_OF_FREQUENCY(p->frequency/1000);\n\tswitch (band) {\n\t\tcase BAND_VHF: offset = 950; break;\n\t\tcase BAND_UHF:\n\t\tdefault: offset = 550; break;\n\t}\n\tdeb_info(\"WBD for DiB7000P: %d\\n\", offset + dib0070_wbd_offset(fe));\n\tstate->dib7000p_ops.set_wbd_ref(fe, offset + dib0070_wbd_offset(fe));\n\treturn state->set_param_save(fe);\n}\n\nstatic int dib7770_set_param_override(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tu16 offset;\n\tu8 band = BAND_OF_FREQUENCY(p->frequency/1000);\n\tswitch (band) {\n\tcase BAND_VHF:\n\t\tstate->dib7000p_ops.set_gpio(fe, 0, 0, 1);\n\t\toffset = 850;\n\t\tbreak;\n\tcase BAND_UHF:\n\tdefault:\n\t\tstate->dib7000p_ops.set_gpio(fe, 0, 0, 0);\n\t\toffset = 250;\n\t\tbreak;\n\t}\n\tdeb_info(\"WBD for DiB7000P: %d\\n\", offset + dib0070_wbd_offset(fe));\n\tstate->dib7000p_ops.set_wbd_ref(fe, offset + dib0070_wbd_offset(fe));\n\treturn state->set_param_save(fe);\n}\n\nstatic int dib7770p_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *st = adap->priv;\n\tstruct i2c_adapter *tun_i2c = st->dib7000p_ops.get_i2c_master(adap->fe_adap[0].fe,\n\t\t\t DIBX000_I2C_INTERFACE_TUNER, 1);\n\n\tif (dvb_attach(dib0070_attach, adap->fe_adap[0].fe, tun_i2c,\n\t\t       &dib7770p_dib0070_config) == NULL)\n\t\treturn -ENODEV;\n\n\tst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\n\tadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib7770_set_param_override;\n\treturn 0;\n}\n\nstatic int dib7070p_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *st = adap->priv;\n\tstruct i2c_adapter *tun_i2c = st->dib7000p_ops.get_i2c_master(adap->fe_adap[0].fe, DIBX000_I2C_INTERFACE_TUNER, 1);\n\n\tif (adap->id == 0) {\n\t\tif (dvb_attach(dib0070_attach, adap->fe_adap[0].fe, tun_i2c, &dib7070p_dib0070_config[0]) == NULL)\n\t\t\treturn -ENODEV;\n\t} else {\n\t\tif (dvb_attach(dib0070_attach, adap->fe_adap[0].fe, tun_i2c, &dib7070p_dib0070_config[1]) == NULL)\n\t\t\treturn -ENODEV;\n\t}\n\n\tst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\n\tadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib7070_set_param_override;\n\treturn 0;\n}\n\nstatic int stk7700p_pid_filter(struct dvb_usb_adapter *adapter, int index,\n\t\tu16 pid, int onoff)\n{\n\tstruct dib0700_adapter_state *state = adapter->priv;\n\tstruct dib0700_state *st = adapter->dev->priv;\n\n\tif (st->is_dib7000pc)\n\t\treturn state->dib7000p_ops.pid_filter(adapter->fe_adap[0].fe, index, pid, onoff);\n\treturn dib7000m_pid_filter(adapter->fe_adap[0].fe, index, pid, onoff);\n}\n\nstatic int stk7700p_pid_filter_ctrl(struct dvb_usb_adapter *adapter, int onoff)\n{\n\tstruct dib0700_state *st = adapter->dev->priv;\n\tstruct dib0700_adapter_state *state = adapter->priv;\n\tif (st->is_dib7000pc)\n\t\treturn state->dib7000p_ops.pid_filter_ctrl(adapter->fe_adap[0].fe, onoff);\n\treturn dib7000m_pid_filter_ctrl(adapter->fe_adap[0].fe, onoff);\n}\n\nstatic int stk70x0p_pid_filter(struct dvb_usb_adapter *adapter, int index, u16 pid, int onoff)\n{\n\tstruct dib0700_adapter_state *state = adapter->priv;\n\treturn state->dib7000p_ops.pid_filter(adapter->fe_adap[0].fe, index, pid, onoff);\n}\n\nstatic int stk70x0p_pid_filter_ctrl(struct dvb_usb_adapter *adapter, int onoff)\n{\n\tstruct dib0700_adapter_state *state = adapter->priv;\n\treturn state->dib7000p_ops.pid_filter_ctrl(adapter->fe_adap[0].fe, onoff);\n}\n\nstatic struct dibx000_bandwidth_config dib7070_bw_config_12_mhz = {\n\t.internal = 60000,\n\t.sampling = 15000,\n\t.pll_prediv = 1,\n\t.pll_ratio = 20,\n\t.pll_range = 3,\n\t.pll_reset = 1,\n\t.pll_bypass = 0,\n\t.enable_refdiv = 0,\n\t.bypclk_div = 0,\n\t.IO_CLK_en_core = 1,\n\t.ADClkSrc = 1,\n\t.modulo = 2,\n\t.sad_cfg = (3 << 14) | (1 << 12) | (524 << 0),\n\t.ifreq = (0 << 25) | 0,\n\t.timf = 20452225,\n\t.xtal_hz = 12000000,\n};\n\nstatic struct dib7000p_config dib7070p_dib7000p_config = {\n\t.output_mpeg2_in_188_bytes = 1,\n\n\t.agc_config_count = 1,\n\t.agc = &dib7070_agc_config,\n\t.bw  = &dib7070_bw_config_12_mhz,\n\t.tuner_is_baseband = 1,\n\t.spur_protect = 1,\n\n\t.gpio_dir = DIB7000P_GPIO_DEFAULT_DIRECTIONS,\n\t.gpio_val = DIB7000P_GPIO_DEFAULT_VALUES,\n\t.gpio_pwm_pos = DIB7000P_GPIO_DEFAULT_PWM_POS,\n\n\t.hostbus_diversity = 1,\n};\n\n \nstatic int stk7070p_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct usb_device_descriptor *p = &adap->dev->udev->descriptor;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\tif (p->idVendor  == cpu_to_le16(USB_VID_PINNACLE) &&\n\t    p->idProduct == cpu_to_le16(USB_PID_PINNACLE_PCTV72E))\n\t\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0);\n\telse\n\t\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\n\tdib0700_ctrl_clock(adap->dev, 72, 1);\n\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\n\tif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 18,\n\t\t\t\t     &dib7070p_dib7000p_config) != 0) {\n\t\terr(\"%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\\n\",\n\t\t    __func__);\n\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);\n\t\treturn -ENODEV;\n\t}\n\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x80,\n\t\t&dib7070p_dib7000p_config);\n\treturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\n}\n\n \nstatic struct dib7000p_config dib7770p_dib7000p_config = {\n\t.output_mpeg2_in_188_bytes = 1,\n\n\t.agc_config_count = 1,\n\t.agc = &dib7070_agc_config,\n\t.bw  = &dib7070_bw_config_12_mhz,\n\t.tuner_is_baseband = 1,\n\t.spur_protect = 1,\n\n\t.gpio_dir = DIB7000P_GPIO_DEFAULT_DIRECTIONS,\n\t.gpio_val = DIB7000P_GPIO_DEFAULT_VALUES,\n\t.gpio_pwm_pos = DIB7000P_GPIO_DEFAULT_PWM_POS,\n\n\t.hostbus_diversity = 1,\n\t.enable_current_mirror = 1,\n\t.disable_sample_and_hold = 0,\n};\n\nstatic int stk7770p_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct usb_device_descriptor *p = &adap->dev->udev->descriptor;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\tif (p->idVendor  == cpu_to_le16(USB_VID_PINNACLE) &&\n\t    p->idProduct == cpu_to_le16(USB_PID_PINNACLE_PCTV72E))\n\t\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0);\n\telse\n\t\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\n\tdib0700_ctrl_clock(adap->dev, 72, 1);\n\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\n\tif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 18,\n\t\t\t\t     &dib7770p_dib7000p_config) != 0) {\n\t\terr(\"%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\\n\",\n\t\t    __func__);\n\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);\n\t\treturn -ENODEV;\n\t}\n\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x80,\n\t\t&dib7770p_dib7000p_config);\n\treturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\n}\n\n \nstatic struct dibx000_agc_config dib807x_agc_config[2] = {\n\t{\n\t\tBAND_VHF,\n\t\t \n\t\t(0 << 15) | (0 << 14) | (7 << 11) | (0 << 10) | (0 << 9) |\n\t\t\t(0 << 8) | (3 << 5) | (0 << 4) | (5 << 1) |\n\t\t\t(0 << 0),  \n\n\t\t600,  \n\t\t10,   \n\n\t\t0,   \n\t\t118,   \n\n\t\t0,      \n\t\t3530,   \n\t\t1,      \n\t\t5,      \n\n\t\t65535,   \n\t\t0,   \n\n\t\t65535,   \n\t\t0,       \n\n\t\t0,       \n\t\t40,      \n\t\t183,     \n\t\t206,     \n\t\t255,     \n\t\t72,      \n\t\t152,     \n\t\t88,      \n\t\t90,      \n\n\t\t17,   \n\t\t27,   \n\t\t23,   \n\t\t51,   \n\n\t\t0,   \n\t}, {\n\t\tBAND_UHF,\n\t\t \n\t\t(0 << 15) | (0 << 14) | (1 << 11) | (0 << 10) | (0 << 9) |\n\t\t\t(0 << 8) | (3 << 5) | (0 << 4) | (5 << 1) |\n\t\t\t(0 << 0),  \n\n\t\t600,  \n\t\t10,   \n\n\t\t0,   \n\t\t118,   \n\n\t\t0,      \n\t\t3530,   \n\t\t1,      \n\t\t5,      \n\n\t\t65535,   \n\t\t0,   \n\n\t\t65535,   \n\t\t0,       \n\n\t\t0,       \n\t\t40,      \n\t\t183,     \n\t\t206,     \n\t\t255,     \n\t\t72,      \n\t\t152,     \n\t\t88,      \n\t\t90,      \n\n\t\t17,   \n\t\t27,   \n\t\t23,   \n\t\t51,   \n\n\t\t0,   \n\t}\n};\n\nstatic struct dibx000_bandwidth_config dib807x_bw_config_12_mhz = {\n\t.internal = 60000,\n\t.sampling = 15000,\n\t.pll_prediv = 1,\n\t.pll_ratio = 20,\n\t.pll_range = 3,\n\t.pll_reset = 1,\n\t.pll_bypass = 0,\n\t.enable_refdiv = 0,\n\t.bypclk_div = 0,\n\t.IO_CLK_en_core = 1,\n\t.ADClkSrc = 1,\n\t.modulo = 2,\n\t.sad_cfg = (3 << 14) | (1 << 12) | (599 << 0),\t \n\t.ifreq = (0 << 25) | 0,\t\t\t\t \n\t.timf = 18179755,\n\t.xtal_hz = 12000000,\n};\n\nstatic struct dib8000_config dib807x_dib8000_config[2] = {\n\t{\n\t\t.output_mpeg2_in_188_bytes = 1,\n\n\t\t.agc_config_count = 2,\n\t\t.agc = dib807x_agc_config,\n\t\t.pll = &dib807x_bw_config_12_mhz,\n\t\t.tuner_is_baseband = 1,\n\n\t\t.gpio_dir = DIB8000_GPIO_DEFAULT_DIRECTIONS,\n\t\t.gpio_val = DIB8000_GPIO_DEFAULT_VALUES,\n\t\t.gpio_pwm_pos = DIB8000_GPIO_DEFAULT_PWM_POS,\n\n\t\t.hostbus_diversity = 1,\n\t\t.div_cfg = 1,\n\t\t.agc_control = &dib0070_ctrl_agc_filter,\n\t\t.output_mode = OUTMODE_MPEG2_FIFO,\n\t\t.drives = 0x2d98,\n\t}, {\n\t\t.output_mpeg2_in_188_bytes = 1,\n\n\t\t.agc_config_count = 2,\n\t\t.agc = dib807x_agc_config,\n\t\t.pll = &dib807x_bw_config_12_mhz,\n\t\t.tuner_is_baseband = 1,\n\n\t\t.gpio_dir = DIB8000_GPIO_DEFAULT_DIRECTIONS,\n\t\t.gpio_val = DIB8000_GPIO_DEFAULT_VALUES,\n\t\t.gpio_pwm_pos = DIB8000_GPIO_DEFAULT_PWM_POS,\n\n\t\t.hostbus_diversity = 1,\n\t\t.agc_control = &dib0070_ctrl_agc_filter,\n\t\t.output_mode = OUTMODE_MPEG2_FIFO,\n\t\t.drives = 0x2d98,\n\t}\n};\n\nstatic int dib80xx_tuner_reset(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\treturn state->dib8000_ops.set_gpio(fe, 5, 0, !onoff);\n}\n\nstatic int dib80xx_tuner_sleep(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\treturn state->dib8000_ops.set_gpio(fe, 0, 0, onoff);\n}\n\nstatic const struct dib0070_wbd_gain_cfg dib8070_wbd_gain_cfg[] = {\n    { 240,      7},\n    { 0xffff,   6},\n};\n\nstatic struct dib0070_config dib807x_dib0070_config[2] = {\n\t{\n\t\t.i2c_address = DEFAULT_DIB0070_I2C_ADDRESS,\n\t\t.reset = dib80xx_tuner_reset,\n\t\t.sleep = dib80xx_tuner_sleep,\n\t\t.clock_khz = 12000,\n\t\t.clock_pad_drive = 4,\n\t\t.vga_filter = 1,\n\t\t.force_crystal_mode = 1,\n\t\t.enable_third_order_filter = 1,\n\t\t.charge_pump = 0,\n\t\t.wbd_gain = dib8070_wbd_gain_cfg,\n\t\t.osc_buffer_state = 0,\n\t\t.freq_offset_khz_uhf = -100,\n\t\t.freq_offset_khz_vhf = -100,\n\t}, {\n\t\t.i2c_address = DEFAULT_DIB0070_I2C_ADDRESS,\n\t\t.reset = dib80xx_tuner_reset,\n\t\t.sleep = dib80xx_tuner_sleep,\n\t\t.clock_khz = 12000,\n\t\t.clock_pad_drive = 2,\n\t\t.vga_filter = 1,\n\t\t.force_crystal_mode = 1,\n\t\t.enable_third_order_filter = 1,\n\t\t.charge_pump = 0,\n\t\t.wbd_gain = dib8070_wbd_gain_cfg,\n\t\t.osc_buffer_state = 0,\n\t\t.freq_offset_khz_uhf = -25,\n\t\t.freq_offset_khz_vhf = -25,\n\t}\n};\n\nstatic int dib807x_set_param_override(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tu16 offset = dib0070_wbd_offset(fe);\n\tu8 band = BAND_OF_FREQUENCY(p->frequency/1000);\n\tswitch (band) {\n\tcase BAND_VHF:\n\t\toffset += 750;\n\t\tbreak;\n\tcase BAND_UHF:   \n\tdefault:\n\t\toffset += 250; break;\n\t}\n\tdeb_info(\"WBD for DiB8000: %d\\n\", offset);\n\tstate->dib8000_ops.set_wbd_ref(fe, offset);\n\n\treturn state->set_param_save(fe);\n}\n\nstatic int dib807x_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *st = adap->priv;\n\tstruct i2c_adapter *tun_i2c = st->dib8000_ops.get_i2c_master(adap->fe_adap[0].fe,\n\t\t\tDIBX000_I2C_INTERFACE_TUNER, 1);\n\n\tif (adap->id == 0) {\n\t\tif (dvb_attach(dib0070_attach, adap->fe_adap[0].fe, tun_i2c,\n\t\t\t\t&dib807x_dib0070_config[0]) == NULL)\n\t\t\treturn -ENODEV;\n\t} else {\n\t\tif (dvb_attach(dib0070_attach, adap->fe_adap[0].fe, tun_i2c,\n\t\t\t\t&dib807x_dib0070_config[1]) == NULL)\n\t\t\treturn -ENODEV;\n\t}\n\n\tst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\n\tadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib807x_set_param_override;\n\treturn 0;\n}\n\nstatic int stk80xx_pid_filter(struct dvb_usb_adapter *adapter, int index,\n\tu16 pid, int onoff)\n{\n\tstruct dib0700_adapter_state *state = adapter->priv;\n\n\treturn state->dib8000_ops.pid_filter(adapter->fe_adap[0].fe, index, pid, onoff);\n}\n\nstatic int stk80xx_pid_filter_ctrl(struct dvb_usb_adapter *adapter,\n\t\tint onoff)\n{\n\tstruct dib0700_adapter_state *state = adapter->priv;\n\n\treturn state->dib8000_ops.pid_filter_ctrl(adapter->fe_adap[0].fe, onoff);\n}\n\n \nstatic int stk807x_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib8000_attach, &state->dib8000_ops))\n\t\treturn -ENODEV;\n\n\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\n\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\n\tdib0700_ctrl_clock(adap->dev, 72, 1);\n\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\n\tstate->dib8000_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 18,\n\t\t\t\t0x80, 0);\n\n\tadap->fe_adap[0].fe = state->dib8000_ops.init(&adap->dev->i2c_adap, 0x80,\n\t\t\t      &dib807x_dib8000_config[0]);\n\n\treturn adap->fe_adap[0].fe == NULL ?  -ENODEV : 0;\n}\n\n \nstatic int stk807xpvr_frontend_attach0(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib8000_attach, &state->dib8000_ops))\n\t\treturn -ENODEV;\n\n\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0);\n\tmsleep(30);\n\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(500);\n\tdib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\n\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\n\tdib0700_ctrl_clock(adap->dev, 72, 1);\n\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\n\t \n\tstate->dib8000_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 0x22, 0x80, 0);\n\n\tadap->fe_adap[0].fe = state->dib8000_ops.init(&adap->dev->i2c_adap, 0x80,\n\t\t\t      &dib807x_dib8000_config[0]);\n\n\treturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\n}\n\nstatic int stk807xpvr_frontend_attach1(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib8000_attach, &state->dib8000_ops))\n\t\treturn -ENODEV;\n\n\t \n\tstate->dib8000_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 0x12, 0x82, 0);\n\n\tadap->fe_adap[0].fe = state->dib8000_ops.init(&adap->dev->i2c_adap, 0x82,\n\t\t\t      &dib807x_dib8000_config[1]);\n\n\treturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\n}\n\n \nstatic struct dibx000_agc_config dib8090_agc_config[2] = {\n\t{\n\t.band_caps = BAND_UHF | BAND_VHF | BAND_LBAND | BAND_SBAND,\n\t \n\t.setup = (0 << 15) | (0 << 14) | (5 << 11) | (0 << 10) | (0 << 9) | (0 << 8)\n\t| (3 << 5) | (0 << 4) | (5 << 1) | (0 << 0),\n\n\t.inv_gain = 787,\n\t.time_stabiliz = 10,\n\n\t.alpha_level = 0,\n\t.thlock = 118,\n\n\t.wbd_inv = 0,\n\t.wbd_ref = 3530,\n\t.wbd_sel = 1,\n\t.wbd_alpha = 5,\n\n\t.agc1_max = 65535,\n\t.agc1_min = 0,\n\n\t.agc2_max = 65535,\n\t.agc2_min = 0,\n\n\t.agc1_pt1 = 0,\n\t.agc1_pt2 = 32,\n\t.agc1_pt3 = 114,\n\t.agc1_slope1 = 143,\n\t.agc1_slope2 = 144,\n\t.agc2_pt1 = 114,\n\t.agc2_pt2 = 227,\n\t.agc2_slope1 = 116,\n\t.agc2_slope2 = 117,\n\n\t.alpha_mant = 28,\n\t.alpha_exp = 26,\n\t.beta_mant = 31,\n\t.beta_exp = 51,\n\n\t.perform_agc_softsplit = 0,\n\t},\n\t{\n\t.band_caps = BAND_CBAND,\n\t \n\t.setup = (0 << 15) | (0 << 14) | (5 << 11) | (0 << 10) | (0 << 9) | (0 << 8)\n\t| (3 << 5) | (0 << 4) | (5 << 1) | (0 << 0),\n\n\t.inv_gain = 787,\n\t.time_stabiliz = 10,\n\n\t.alpha_level = 0,\n\t.thlock = 118,\n\n\t.wbd_inv = 0,\n\t.wbd_ref = 3530,\n\t.wbd_sel = 1,\n\t.wbd_alpha = 5,\n\n\t.agc1_max = 0,\n\t.agc1_min = 0,\n\n\t.agc2_max = 65535,\n\t.agc2_min = 0,\n\n\t.agc1_pt1 = 0,\n\t.agc1_pt2 = 32,\n\t.agc1_pt3 = 114,\n\t.agc1_slope1 = 143,\n\t.agc1_slope2 = 144,\n\t.agc2_pt1 = 114,\n\t.agc2_pt2 = 227,\n\t.agc2_slope1 = 116,\n\t.agc2_slope2 = 117,\n\n\t.alpha_mant = 28,\n\t.alpha_exp = 26,\n\t.beta_mant = 31,\n\t.beta_exp = 51,\n\n\t.perform_agc_softsplit = 0,\n\t}\n};\n\nstatic struct dibx000_bandwidth_config dib8090_pll_config_12mhz = {\n\t.internal = 54000,\n\t.sampling = 13500,\n\n\t.pll_prediv = 1,\n\t.pll_ratio = 18,\n\t.pll_range = 3,\n\t.pll_reset = 1,\n\t.pll_bypass = 0,\n\n\t.enable_refdiv = 0,\n\t.bypclk_div = 0,\n\t.IO_CLK_en_core = 1,\n\t.ADClkSrc = 1,\n\t.modulo = 2,\n\n\t.sad_cfg = (3 << 14) | (1 << 12) | (599 << 0),\n\n\t.ifreq = (0 << 25) | 0,\n\t.timf = 20199727,\n\n\t.xtal_hz = 12000000,\n};\n\nstatic int dib8090_get_adc_power(struct dvb_frontend *fe)\n{\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\treturn state->dib8000_ops.get_adc_power(fe, 1);\n}\n\nstatic void dib8090_agc_control(struct dvb_frontend *fe, u8 restart)\n{\n\tdeb_info(\"AGC control callback: %i\\n\", restart);\n\tdib0090_dcc_freq(fe, restart);\n\n\tif (restart == 0)  \n\t\tdib0090_set_dc_servo(fe, 1);\n}\n\nstatic struct dib8000_config dib809x_dib8000_config[2] = {\n\t{\n\t.output_mpeg2_in_188_bytes = 1,\n\n\t.agc_config_count = 2,\n\t.agc = dib8090_agc_config,\n\t.agc_control = dib8090_agc_control,\n\t.pll = &dib8090_pll_config_12mhz,\n\t.tuner_is_baseband = 1,\n\n\t.gpio_dir = DIB8000_GPIO_DEFAULT_DIRECTIONS,\n\t.gpio_val = DIB8000_GPIO_DEFAULT_VALUES,\n\t.gpio_pwm_pos = DIB8000_GPIO_DEFAULT_PWM_POS,\n\n\t.hostbus_diversity = 1,\n\t.div_cfg = 0x31,\n\t.output_mode = OUTMODE_MPEG2_FIFO,\n\t.drives = 0x2d98,\n\t.diversity_delay = 48,\n\t.refclksel = 3,\n\t}, {\n\t.output_mpeg2_in_188_bytes = 1,\n\n\t.agc_config_count = 2,\n\t.agc = dib8090_agc_config,\n\t.agc_control = dib8090_agc_control,\n\t.pll = &dib8090_pll_config_12mhz,\n\t.tuner_is_baseband = 1,\n\n\t.gpio_dir = DIB8000_GPIO_DEFAULT_DIRECTIONS,\n\t.gpio_val = DIB8000_GPIO_DEFAULT_VALUES,\n\t.gpio_pwm_pos = DIB8000_GPIO_DEFAULT_PWM_POS,\n\n\t.hostbus_diversity = 1,\n\t.div_cfg = 0x31,\n\t.output_mode = OUTMODE_DIVERSITY,\n\t.drives = 0x2d08,\n\t.diversity_delay = 1,\n\t.refclksel = 3,\n\t}\n};\n\nstatic struct dib0090_wbd_slope dib8090_wbd_table[] = {\n\t \n\t{ 120,     0, 500,  0,   500, 4 },  \n\t{ 170,     0, 450,  0,   450, 4 },  \n\t{ 380,    48, 373, 28,   259, 6 },  \n\t{ 860,    34, 700, 36,   616, 6 },  \n\t{ 0xFFFF, 34, 700, 36,   616, 6 },  \n};\n\nstatic struct dib0090_config dib809x_dib0090_config = {\n\t.io.pll_bypass = 1,\n\t.io.pll_range = 1,\n\t.io.pll_prediv = 1,\n\t.io.pll_loopdiv = 20,\n\t.io.adc_clock_ratio = 8,\n\t.io.pll_int_loop_filt = 0,\n\t.io.clock_khz = 12000,\n\t.reset = dib80xx_tuner_reset,\n\t.sleep = dib80xx_tuner_sleep,\n\t.clkouttobamse = 1,\n\t.analog_output = 1,\n\t.i2c_address = DEFAULT_DIB0090_I2C_ADDRESS,\n\t.use_pwm_agc = 1,\n\t.clkoutdrive = 1,\n\t.get_adc_power = dib8090_get_adc_power,\n\t.freq_offset_khz_uhf = -63,\n\t.freq_offset_khz_vhf = -143,\n\t.wbd = dib8090_wbd_table,\n\t.fref_clock_ratio = 6,\n};\n\nstatic u8 dib8090_compute_pll_parameters(struct dvb_frontend *fe)\n{\n\tu8 optimal_pll_ratio = 20;\n\tu32 freq_adc, ratio, rest, max = 0;\n\tu8 pll_ratio;\n\n\tfor (pll_ratio = 17; pll_ratio <= 20; pll_ratio++) {\n\t\tfreq_adc = 12 * pll_ratio * (1 << 8) / 16;\n\t\tratio = ((fe->dtv_property_cache.frequency / 1000) * (1 << 8) / 1000) / freq_adc;\n\t\trest = ((fe->dtv_property_cache.frequency / 1000) * (1 << 8) / 1000) - ratio * freq_adc;\n\n\t\tif (rest > freq_adc / 2)\n\t\t\trest = freq_adc - rest;\n\t\tdeb_info(\"PLL ratio=%i rest=%i\\n\", pll_ratio, rest);\n\t\tif ((rest > max) && (rest > 717)) {\n\t\t\toptimal_pll_ratio = pll_ratio;\n\t\t\tmax = rest;\n\t\t}\n\t}\n\tdeb_info(\"optimal PLL ratio=%i\\n\", optimal_pll_ratio);\n\n\treturn optimal_pll_ratio;\n}\n\nstatic int dib8096_set_param_override(struct dvb_frontend *fe)\n{\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\tu8 pll_ratio, band = BAND_OF_FREQUENCY(fe->dtv_property_cache.frequency / 1000);\n\tu16 target, ltgain, rf_gain_limit;\n\tu32 timf;\n\tint ret = 0;\n\tenum frontend_tune_state tune_state = CT_SHUTDOWN;\n\n\tswitch (band) {\n\tdefault:\n\t\tdeb_info(\"Warning : Rf frequency  (%iHz) is not in the supported range, using VHF switch \", fe->dtv_property_cache.frequency);\n\t\tfallthrough;\n\tcase BAND_VHF:\n\t\tstate->dib8000_ops.set_gpio(fe, 3, 0, 1);\n\t\tbreak;\n\tcase BAND_UHF:\n\t\tstate->dib8000_ops.set_gpio(fe, 3, 0, 0);\n\t\tbreak;\n\t}\n\n\tret = state->set_param_save(fe);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (fe->dtv_property_cache.bandwidth_hz != 6000000) {\n\t\tdeb_info(\"only 6MHz bandwidth is supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tstate->dib8000_ops.update_pll(fe, &dib8090_pll_config_12mhz, fe->dtv_property_cache.bandwidth_hz / 1000, 0);\n\n\t \n\tpll_ratio = dib8090_compute_pll_parameters(fe);\n\tif (pll_ratio == 17)\n\t\ttimf = 21387946;\n\telse if (pll_ratio == 18)\n\t\ttimf = 20199727;\n\telse if (pll_ratio == 19)\n\t\ttimf = 19136583;\n\telse\n\t\ttimf = 18179756;\n\n\t \n\tstate->dib8000_ops.update_pll(fe, &dib8090_pll_config_12mhz, fe->dtv_property_cache.bandwidth_hz / 1000, pll_ratio);\n\n\tstate->dib8000_ops.ctrl_timf(fe, DEMOD_TIMF_SET, timf);\n\n\tif (band != BAND_CBAND) {\n\t\t \n\t\ttarget = (dib0090_get_wbd_target(fe) * 8 * 18 / 33 + 1) / 2;\n\t\tstate->dib8000_ops.set_wbd_ref(fe, target);\n\t}\n\n\tif (band == BAND_CBAND) {\n\t\tdeb_info(\"tuning in CBAND - soft-AGC startup\\n\");\n\t\tdib0090_set_tune_state(fe, CT_AGC_START);\n\n\t\tdo {\n\t\t\tret = dib0090_gain_control(fe);\n\t\t\tmsleep(ret);\n\t\t\ttune_state = dib0090_get_tune_state(fe);\n\t\t\tif (tune_state == CT_AGC_STEP_0)\n\t\t\t\tstate->dib8000_ops.set_gpio(fe, 6, 0, 1);\n\t\t\telse if (tune_state == CT_AGC_STEP_1) {\n\t\t\t\tdib0090_get_current_gain(fe, NULL, NULL, &rf_gain_limit, &ltgain);\n\t\t\t\tif (rf_gain_limit < 2000)  \n\t\t\t\t\tstate->dib8000_ops.set_gpio(fe, 6, 0, 0);\n\t\t\t}\n\t\t} while (tune_state < CT_AGC_STOP);\n\n\t\tdeb_info(\"switching to PWM AGC\\n\");\n\t\tdib0090_pwm_gain_reset(fe);\n\t\tstate->dib8000_ops.pwm_agc_reset(fe);\n\t\tstate->dib8000_ops.set_tune_state(fe, CT_DEMOD_START);\n\t} else {\n\t\t \n\t\tdeb_info(\"not tuning in CBAND - standard AGC startup\\n\");\n\t\tdib0090_pwm_gain_reset(fe);\n\t}\n\n\treturn 0;\n}\n\nstatic int dib809x_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *st = adap->priv;\n\tstruct i2c_adapter *tun_i2c = st->dib8000_ops.get_i2c_master(adap->fe_adap[0].fe, DIBX000_I2C_INTERFACE_TUNER, 1);\n\n\t \n\tif (!dvb_attach(dib0090_register, adap->fe_adap[0].fe, tun_i2c, &dib809x_dib0090_config))\n\t\treturn -ENODEV;\n\n\tst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\n\tadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib8096_set_param_override;\n\treturn 0;\n}\n\nstatic int stk809x_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib8000_attach, &state->dib8000_ops))\n\t\treturn -ENODEV;\n\n\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\n\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\n\tdib0700_ctrl_clock(adap->dev, 72, 1);\n\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\n\tstate->dib8000_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 18, 0x80, 0);\n\n\tadap->fe_adap[0].fe = state->dib8000_ops.init(&adap->dev->i2c_adap, 0x80, &dib809x_dib8000_config[0]);\n\n\treturn adap->fe_adap[0].fe == NULL ?  -ENODEV : 0;\n}\n\nstatic int stk809x_frontend1_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib8000_attach, &state->dib8000_ops))\n\t\treturn -ENODEV;\n\n\tstate->dib8000_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 0x10, 0x82, 0);\n\n\tadap->fe_adap[0].fe = state->dib8000_ops.init(&adap->dev->i2c_adap, 0x82, &dib809x_dib8000_config[1]);\n\n\treturn adap->fe_adap[0].fe == NULL ?  -ENODEV : 0;\n}\n\nstatic int nim8096md_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *st = adap->priv;\n\tstruct i2c_adapter *tun_i2c;\n\tstruct dvb_frontend *fe_slave  = st->dib8000_ops.get_slave_frontend(adap->fe_adap[0].fe, 1);\n\n\tif (fe_slave) {\n\t\ttun_i2c = st->dib8000_ops.get_i2c_master(fe_slave, DIBX000_I2C_INTERFACE_TUNER, 1);\n\t\tif (dvb_attach(dib0090_register, fe_slave, tun_i2c, &dib809x_dib0090_config) == NULL)\n\t\t\treturn -ENODEV;\n\t\tfe_slave->dvb = adap->fe_adap[0].fe->dvb;\n\t\tfe_slave->ops.tuner_ops.set_params = dib8096_set_param_override;\n\t}\n\ttun_i2c = st->dib8000_ops.get_i2c_master(adap->fe_adap[0].fe, DIBX000_I2C_INTERFACE_TUNER, 1);\n\tif (dvb_attach(dib0090_register, adap->fe_adap[0].fe, tun_i2c, &dib809x_dib0090_config) == NULL)\n\t\treturn -ENODEV;\n\n\tst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\n\tadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib8096_set_param_override;\n\n\treturn 0;\n}\n\nstatic int nim8096md_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_frontend *fe_slave;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib8000_attach, &state->dib8000_ops))\n\t\treturn -ENODEV;\n\n\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0);\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(1000);\n\tdib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\n\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\n\tdib0700_ctrl_clock(adap->dev, 72, 1);\n\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\n\tstate->dib8000_ops.i2c_enumeration(&adap->dev->i2c_adap, 2, 18, 0x80, 0);\n\n\tadap->fe_adap[0].fe = state->dib8000_ops.init(&adap->dev->i2c_adap, 0x80, &dib809x_dib8000_config[0]);\n\tif (adap->fe_adap[0].fe == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tif (!dvb_attach(dib8000_attach, &state->dib8000_ops))\n\t\treturn -ENODEV;\n\n\tfe_slave = state->dib8000_ops.init(&adap->dev->i2c_adap, 0x82, &dib809x_dib8000_config[1]);\n\tstate->dib8000_ops.set_slave_frontend(adap->fe_adap[0].fe, fe_slave);\n\n\treturn fe_slave == NULL ?  -ENODEV : 0;\n}\n\n \nstatic struct dibx000_agc_config dib8096p_agc_config[2] = {\n\t{\n\t\t.band_caps\t\t= BAND_UHF,\n\t\t \n\t\t.setup\t\t\t= (0 << 15) | (0 << 14) | (5 << 11)\n\t\t\t| (0 << 10) | (0 << 9) | (0 << 8) | (3 << 5)\n\t\t\t| (0 << 4) | (5 << 1) | (0 << 0),\n\n\t\t.inv_gain\t\t= 684,\n\t\t.time_stabiliz\t= 10,\n\n\t\t.alpha_level\t= 0,\n\t\t.thlock\t\t\t= 118,\n\n\t\t.wbd_inv\t\t= 0,\n\t\t.wbd_ref\t\t= 1200,\n\t\t.wbd_sel\t\t= 3,\n\t\t.wbd_alpha\t\t= 5,\n\n\t\t.agc1_max\t\t= 65535,\n\t\t.agc1_min\t\t= 0,\n\n\t\t.agc2_max\t\t= 32767,\n\t\t.agc2_min\t\t= 0,\n\n\t\t.agc1_pt1\t\t= 0,\n\t\t.agc1_pt2\t\t= 0,\n\t\t.agc1_pt3\t\t= 105,\n\t\t.agc1_slope1\t= 0,\n\t\t.agc1_slope2\t= 156,\n\t\t.agc2_pt1\t\t= 105,\n\t\t.agc2_pt2\t\t= 255,\n\t\t.agc2_slope1\t= 54,\n\t\t.agc2_slope2\t= 0,\n\n\t\t.alpha_mant\t\t= 28,\n\t\t.alpha_exp\t\t= 26,\n\t\t.beta_mant\t\t= 31,\n\t\t.beta_exp\t\t= 51,\n\n\t\t.perform_agc_softsplit = 0,\n\t} , {\n\t\t.band_caps\t\t= BAND_FM | BAND_VHF | BAND_CBAND,\n\t\t \n\t\t.setup\t\t\t= (0 << 15) | (0 << 14) | (5 << 11)\n\t\t\t| (0 << 10) | (0 << 9) | (0 << 8) | (3 << 5)\n\t\t\t| (0 << 4) | (5 << 1) | (0 << 0),\n\n\t\t.inv_gain\t\t= 732,\n\t\t.time_stabiliz  = 10,\n\n\t\t.alpha_level\t= 0,\n\t\t.thlock\t\t\t= 118,\n\n\t\t.wbd_inv\t\t= 0,\n\t\t.wbd_ref\t\t= 1200,\n\t\t.wbd_sel\t\t= 3,\n\t\t.wbd_alpha\t\t= 5,\n\n\t\t.agc1_max\t\t= 65535,\n\t\t.agc1_min\t\t= 0,\n\n\t\t.agc2_max\t\t= 32767,\n\t\t.agc2_min\t\t= 0,\n\n\t\t.agc1_pt1\t\t= 0,\n\t\t.agc1_pt2\t\t= 0,\n\t\t.agc1_pt3\t\t= 98,\n\t\t.agc1_slope1\t= 0,\n\t\t.agc1_slope2\t= 167,\n\t\t.agc2_pt1\t\t= 98,\n\t\t.agc2_pt2\t\t= 255,\n\t\t.agc2_slope1\t= 52,\n\t\t.agc2_slope2\t= 0,\n\n\t\t.alpha_mant\t\t= 28,\n\t\t.alpha_exp\t\t= 26,\n\t\t.beta_mant\t\t= 31,\n\t\t.beta_exp\t\t= 51,\n\n\t\t.perform_agc_softsplit = 0,\n\t}\n};\n\nstatic struct dibx000_bandwidth_config dib8096p_clock_config_12_mhz = {\n\t.internal = 108000,\n\t.sampling = 13500,\n\t.pll_prediv = 1,\n\t.pll_ratio = 9,\n\t.pll_range = 1,\n\t.pll_reset = 0,\n\t.pll_bypass = 0,\n\t.enable_refdiv = 0,\n\t.bypclk_div = 0,\n\t.IO_CLK_en_core = 0,\n\t.ADClkSrc = 0,\n\t.modulo = 2,\n\t.sad_cfg = (3 << 14) | (1 << 12) | (524 << 0),\n\t.ifreq = (0 << 25) | 0,\n\t.timf = 20199729,\n\t.xtal_hz = 12000000,\n};\n\nstatic struct dib8000_config tfe8096p_dib8000_config = {\n\t.output_mpeg2_in_188_bytes\t= 1,\n\t.hostbus_diversity\t\t\t= 1,\n\t.update_lna\t\t\t\t\t= NULL,\n\n\t.agc_config_count\t\t\t= 2,\n\t.agc\t\t\t\t\t\t= dib8096p_agc_config,\n\t.pll\t\t\t\t\t\t= &dib8096p_clock_config_12_mhz,\n\n\t.gpio_dir\t\t\t\t\t= DIB8000_GPIO_DEFAULT_DIRECTIONS,\n\t.gpio_val\t\t\t\t\t= DIB8000_GPIO_DEFAULT_VALUES,\n\t.gpio_pwm_pos\t\t\t\t= DIB8000_GPIO_DEFAULT_PWM_POS,\n\n\t.agc_control\t\t\t\t= NULL,\n\t.diversity_delay\t\t\t= 48,\n\t.output_mode\t\t\t\t= OUTMODE_MPEG2_FIFO,\n\t.enMpegOutput\t\t\t\t= 1,\n};\n\nstatic struct dib0090_wbd_slope dib8096p_wbd_table[] = {\n\t{ 380, 81, 850, 64, 540, 4},\n\t{ 860, 51, 866, 21, 375, 4},\n\t{1700, 0, 250, 0, 100, 6},\n\t{2600, 0, 250, 0, 100, 6},\n\t{ 0xFFFF, 0, 0, 0, 0, 0},\n};\n\nstatic struct dib0090_config tfe8096p_dib0090_config = {\n\t.io.clock_khz\t\t\t= 12000,\n\t.io.pll_bypass\t\t\t= 0,\n\t.io.pll_range\t\t\t= 0,\n\t.io.pll_prediv\t\t\t= 3,\n\t.io.pll_loopdiv\t\t\t= 6,\n\t.io.adc_clock_ratio\t\t= 0,\n\t.io.pll_int_loop_filt\t= 0,\n\n\t.freq_offset_khz_uhf\t= -143,\n\t.freq_offset_khz_vhf\t= -143,\n\n\t.get_adc_power\t\t\t= dib8090_get_adc_power,\n\n\t.clkouttobamse\t\t\t= 1,\n\t.analog_output\t\t\t= 0,\n\n\t.wbd_vhf_offset\t\t\t= 0,\n\t.wbd_cband_offset\t\t= 0,\n\t.use_pwm_agc\t\t\t= 1,\n\t.clkoutdrive\t\t\t= 0,\n\n\t.fref_clock_ratio\t\t= 1,\n\n\t.ls_cfg_pad_drv\t\t\t= 0,\n\t.data_tx_drv\t\t\t= 0,\n\t.low_if\t\t\t\t\t= NULL,\n\t.in_soc\t\t\t\t\t= 1,\n\t.force_cband_input\t\t= 0,\n};\n\nstruct dibx090p_best_adc {\n\tu32 timf;\n\tu32 pll_loopdiv;\n\tu32 pll_prediv;\n};\n\nstatic int dib8096p_get_best_sampling(struct dvb_frontend *fe, struct dibx090p_best_adc *adc)\n{\n\tu8 spur = 0, prediv = 0, loopdiv = 0, min_prediv = 1, max_prediv = 1;\n\tu16 xtal = 12000;\n\tu16 fcp_min = 1900;   \n\tu16 fcp_max = 20000;  \n\tu32 fmem_max = 140000;  \n\tu32 fdem_min = 66000;\n\tu32 fcp = 0, fs = 0, fdem = 0, fmem = 0;\n\tu32 harmonic_id = 0;\n\n\tadc->timf = 0;\n\tadc->pll_loopdiv = loopdiv;\n\tadc->pll_prediv = prediv;\n\n\tdeb_info(\"bandwidth = %d\", fe->dtv_property_cache.bandwidth_hz);\n\n\t \n\twhile ((xtal / max_prediv) >= fcp_min)\n\t\tmax_prediv++;\n\n\tmax_prediv--;\n\tmin_prediv = max_prediv;\n\twhile ((xtal / min_prediv) <= fcp_max) {\n\t\tmin_prediv--;\n\t\tif (min_prediv == 1)\n\t\t\tbreak;\n\t}\n\tdeb_info(\"MIN prediv = %d : MAX prediv = %d\", min_prediv, max_prediv);\n\n\tmin_prediv = 1;\n\n\tfor (prediv = min_prediv; prediv < max_prediv; prediv++) {\n\t\tfcp = xtal / prediv;\n\t\tif (fcp > fcp_min && fcp < fcp_max) {\n\t\t\tfor (loopdiv = 1; loopdiv < 64; loopdiv++) {\n\t\t\t\tfmem = ((xtal/prediv) * loopdiv);\n\t\t\t\tfdem = fmem / 2;\n\t\t\t\tfs   = fdem / 4;\n\n\t\t\t\t \n\t\t\t\tif ((fdem >= fdem_min) && (fmem <= fmem_max) && (fs >= fe->dtv_property_cache.bandwidth_hz / 1000)) {\n\t\t\t\t\tspur = 0;\n\t\t\t\t\t \n\t\t\t\t\tfor (harmonic_id = (fe->dtv_property_cache.frequency / (1000 * fs));  harmonic_id <= ((fe->dtv_property_cache.frequency / (1000 * fs)) + 1); harmonic_id++) {\n\t\t\t\t\t\tif (((fs * harmonic_id) >= (fe->dtv_property_cache.frequency / 1000 - (fe->dtv_property_cache.bandwidth_hz / 2000))) &&  ((fs * harmonic_id) <= (fe->dtv_property_cache.frequency / 1000 + (fe->dtv_property_cache.bandwidth_hz / 2000)))) {\n\t\t\t\t\t\t\tspur = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!spur) {\n\t\t\t\t\t\tadc->pll_loopdiv = loopdiv;\n\t\t\t\t\t\tadc->pll_prediv = prediv;\n\t\t\t\t\t\tadc->timf = (4260880253U / fdem) * (1 << 8);\n\t\t\t\t\t\tadc->timf += ((4260880253U % fdem) << 8) / fdem;\n\n\t\t\t\t\t\tdeb_info(\"RF %6d; BW %6d; Xtal %6d; Fmem %6d; Fdem %6d; Fs %6d; Prediv %2d; Loopdiv %2d; Timf %8d;\", fe->dtv_property_cache.frequency, fe->dtv_property_cache.bandwidth_hz, xtal, fmem, fdem, fs, prediv, loopdiv, adc->timf);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!spur)\n\t\t\tbreak;\n\t}\n\n\tif (adc->pll_loopdiv == 0 && adc->pll_prediv == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int dib8096p_agc_startup(struct dvb_frontend *fe)\n{\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\tstruct dibx000_bandwidth_config pll;\n\tstruct dibx090p_best_adc adc;\n\tu16 target;\n\tint ret;\n\n\tret = state->set_param_save(fe);\n\tif (ret < 0)\n\t\treturn ret;\n\tmemset(&pll, 0, sizeof(struct dibx000_bandwidth_config));\n\n\tdib0090_pwm_gain_reset(fe);\n\t \n\ttarget = (dib0090_get_wbd_target(fe) * 8  + 1) / 2;\n\tstate->dib8000_ops.set_wbd_ref(fe, target);\n\n\tif (dib8096p_get_best_sampling(fe, &adc) == 0) {\n\t\tpll.pll_ratio  = adc.pll_loopdiv;\n\t\tpll.pll_prediv = adc.pll_prediv;\n\n\t\tdib0700_set_i2c_speed(adap->dev, 200);\n\t\tstate->dib8000_ops.update_pll(fe, &pll, fe->dtv_property_cache.bandwidth_hz / 1000, 0);\n\t\tstate->dib8000_ops.ctrl_timf(fe, DEMOD_TIMF_SET, adc.timf);\n\t\tdib0700_set_i2c_speed(adap->dev, 1000);\n\t}\n\treturn 0;\n}\n\nstatic int tfe8096p_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_state *st = adap->dev->priv;\n\tu32 fw_version;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib8000_attach, &state->dib8000_ops))\n\t\treturn -ENODEV;\n\n\tdib0700_get_version(adap->dev, NULL, NULL, &fw_version, NULL);\n\tif (fw_version >= 0x10200)\n\t\tst->fw_use_new_i2c_api = 1;\n\n\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\n\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\n\tdib0700_ctrl_clock(adap->dev, 72, 1);\n\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\n\tstate->dib8000_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 0x10, 0x80, 1);\n\n\tadap->fe_adap[0].fe = state->dib8000_ops.init(&adap->dev->i2c_adap,\n\t\t\t\t\t     0x80, &tfe8096p_dib8000_config);\n\n\treturn adap->fe_adap[0].fe == NULL ?  -ENODEV : 0;\n}\n\nstatic int tfe8096p_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *st = adap->priv;\n\tstruct i2c_adapter *tun_i2c = st->dib8000_ops.get_i2c_tuner(adap->fe_adap[0].fe);\n\n\ttfe8096p_dib0090_config.reset = st->dib8000_ops.tuner_sleep;\n\ttfe8096p_dib0090_config.sleep = st->dib8000_ops.tuner_sleep;\n\ttfe8096p_dib0090_config.wbd = dib8096p_wbd_table;\n\n\tif (dvb_attach(dib0090_register, adap->fe_adap[0].fe, tun_i2c,\n\t\t\t\t&tfe8096p_dib0090_config) == NULL)\n\t\treturn -ENODEV;\n\n\tst->dib8000_ops.set_gpio(adap->fe_adap[0].fe, 8, 0, 1);\n\n\tst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\n\tadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib8096p_agc_startup;\n\treturn 0;\n}\n\n \nstatic int dib90x0_pid_filter(struct dvb_usb_adapter *adapter, int index, u16 pid, int onoff)\n{\n\treturn dib9000_fw_pid_filter(adapter->fe_adap[0].fe, index, pid, onoff);\n}\n\nstatic int dib90x0_pid_filter_ctrl(struct dvb_usb_adapter *adapter, int onoff)\n{\n\treturn dib9000_fw_pid_filter_ctrl(adapter->fe_adap[0].fe, onoff);\n}\n\nstatic int dib90x0_tuner_reset(struct dvb_frontend *fe, int onoff)\n{\n\treturn dib9000_set_gpio(fe, 5, 0, !onoff);\n}\n\nstatic int dib90x0_tuner_sleep(struct dvb_frontend *fe, int onoff)\n{\n\treturn dib9000_set_gpio(fe, 0, 0, onoff);\n}\n\nstatic int dib01x0_pmu_update(struct i2c_adapter *i2c, u16 *data, u8 len)\n{\n\tu8 wb[4] = { 0xc >> 8, 0xc & 0xff, 0, 0 };\n\tu8 rb[2];\n\tstruct i2c_msg msg[2] = {\n\t\t{.addr = 0x1e >> 1, .flags = 0, .buf = wb, .len = 2},\n\t\t{.addr = 0x1e >> 1, .flags = I2C_M_RD, .buf = rb, .len = 2},\n\t};\n\tu8 index_data;\n\n\tdibx000_i2c_set_speed(i2c, 250);\n\n\tif (i2c_transfer(i2c, msg, 2) != 2)\n\t\treturn -EIO;\n\n\tswitch (rb[0] << 8 | rb[1]) {\n\tcase 0:\n\t\t\tdeb_info(\"Found DiB0170 rev1: This version of DiB0170 is not supported any longer.\\n\");\n\t\t\treturn -EIO;\n\tcase 1:\n\t\t\tdeb_info(\"Found DiB0170 rev2\");\n\t\t\tbreak;\n\tcase 2:\n\t\t\tdeb_info(\"Found DiB0190 rev2\");\n\t\t\tbreak;\n\tdefault:\n\t\t\tdeb_info(\"DiB01x0 not found\");\n\t\t\treturn -EIO;\n\t}\n\n\tfor (index_data = 0; index_data < len; index_data += 2) {\n\t\twb[2] = (data[index_data + 1] >> 8) & 0xff;\n\t\twb[3] = (data[index_data + 1]) & 0xff;\n\n\t\tif (data[index_data] == 0) {\n\t\t\twb[0] = (data[index_data] >> 8) & 0xff;\n\t\t\twb[1] = (data[index_data]) & 0xff;\n\t\t\tmsg[0].len = 2;\n\t\t\tif (i2c_transfer(i2c, msg, 2) != 2)\n\t\t\t\treturn -EIO;\n\t\t\twb[2] |= rb[0];\n\t\t\twb[3] |= rb[1] & ~(3 << 4);\n\t\t}\n\n\t\twb[0] = (data[index_data] >> 8)&0xff;\n\t\twb[1] = (data[index_data])&0xff;\n\t\tmsg[0].len = 4;\n\t\tif (i2c_transfer(i2c, &msg[0], 1) != 1)\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic struct dib9000_config stk9090m_config = {\n\t.output_mpeg2_in_188_bytes = 1,\n\t.output_mode = OUTMODE_MPEG2_FIFO,\n\t.vcxo_timer = 279620,\n\t.timing_frequency = 20452225,\n\t.demod_clock_khz = 60000,\n\t.xtal_clock_khz = 30000,\n\t.if_drives = (0 << 15) | (1 << 13) | (0 << 12) | (3 << 10) | (0 << 9) | (1 << 7) | (0 << 6) | (0 << 4) | (1 << 3) | (1 << 1) | (0),\n\t.subband = {\n\t\t2,\n\t\t{\n\t\t\t{ 240, { BOARD_GPIO_COMPONENT_DEMOD, BOARD_GPIO_FUNCTION_SUBBAND_GPIO, 0x0008, 0x0000, 0x0008 } },  \n\t\t\t{ 890, { BOARD_GPIO_COMPONENT_DEMOD, BOARD_GPIO_FUNCTION_SUBBAND_GPIO, 0x0008, 0x0000, 0x0000 } },  \n\t\t\t{ 0 },\n\t\t},\n\t},\n\t.gpio_function = {\n\t\t{ .component = BOARD_GPIO_COMPONENT_DEMOD, .function = BOARD_GPIO_FUNCTION_COMPONENT_ON, .mask = 0x10 | 0x21, .direction = 0 & ~0x21, .value = (0x10 & ~0x1) | 0x20 },\n\t\t{ .component = BOARD_GPIO_COMPONENT_DEMOD, .function = BOARD_GPIO_FUNCTION_COMPONENT_OFF, .mask = 0x10 | 0x21, .direction = 0 & ~0x21, .value = 0 | 0x21 },\n\t},\n};\n\nstatic struct dib9000_config nim9090md_config[2] = {\n\t{\n\t\t.output_mpeg2_in_188_bytes = 1,\n\t\t.output_mode = OUTMODE_MPEG2_FIFO,\n\t\t.vcxo_timer = 279620,\n\t\t.timing_frequency = 20452225,\n\t\t.demod_clock_khz = 60000,\n\t\t.xtal_clock_khz = 30000,\n\t\t.if_drives = (0 << 15) | (1 << 13) | (0 << 12) | (3 << 10) | (0 << 9) | (1 << 7) | (0 << 6) | (0 << 4) | (1 << 3) | (1 << 1) | (0),\n\t}, {\n\t\t.output_mpeg2_in_188_bytes = 1,\n\t\t.output_mode = OUTMODE_DIVERSITY,\n\t\t.vcxo_timer = 279620,\n\t\t.timing_frequency = 20452225,\n\t\t.demod_clock_khz = 60000,\n\t\t.xtal_clock_khz = 30000,\n\t\t.if_drives = (0 << 15) | (1 << 13) | (0 << 12) | (3 << 10) | (0 << 9) | (1 << 7) | (0 << 6) | (0 << 4) | (1 << 3) | (1 << 1) | (0),\n\t\t.subband = {\n\t\t\t2,\n\t\t\t{\n\t\t\t\t{ 240, { BOARD_GPIO_COMPONENT_DEMOD, BOARD_GPIO_FUNCTION_SUBBAND_GPIO, 0x0006, 0x0000, 0x0006 } },  \n\t\t\t\t{ 890, { BOARD_GPIO_COMPONENT_DEMOD, BOARD_GPIO_FUNCTION_SUBBAND_GPIO, 0x0006, 0x0000, 0x0000 } },  \n\t\t\t\t{ 0 },\n\t\t\t},\n\t\t},\n\t\t.gpio_function = {\n\t\t\t{ .component = BOARD_GPIO_COMPONENT_DEMOD, .function = BOARD_GPIO_FUNCTION_COMPONENT_ON, .mask = 0x10 | 0x21, .direction = 0 & ~0x21, .value = (0x10 & ~0x1) | 0x20 },\n\t\t\t{ .component = BOARD_GPIO_COMPONENT_DEMOD, .function = BOARD_GPIO_FUNCTION_COMPONENT_OFF, .mask = 0x10 | 0x21, .direction = 0 & ~0x21, .value = 0 | 0x21 },\n\t\t},\n\t}\n};\n\nstatic struct dib0090_config dib9090_dib0090_config = {\n\t.io.pll_bypass = 0,\n\t.io.pll_range = 1,\n\t.io.pll_prediv = 1,\n\t.io.pll_loopdiv = 8,\n\t.io.adc_clock_ratio = 8,\n\t.io.pll_int_loop_filt = 0,\n\t.io.clock_khz = 30000,\n\t.reset = dib90x0_tuner_reset,\n\t.sleep = dib90x0_tuner_sleep,\n\t.clkouttobamse = 0,\n\t.analog_output = 0,\n\t.use_pwm_agc = 0,\n\t.clkoutdrive = 0,\n\t.freq_offset_khz_uhf = 0,\n\t.freq_offset_khz_vhf = 0,\n};\n\nstatic struct dib0090_config nim9090md_dib0090_config[2] = {\n\t{\n\t\t.io.pll_bypass = 0,\n\t\t.io.pll_range = 1,\n\t\t.io.pll_prediv = 1,\n\t\t.io.pll_loopdiv = 8,\n\t\t.io.adc_clock_ratio = 8,\n\t\t.io.pll_int_loop_filt = 0,\n\t\t.io.clock_khz = 30000,\n\t\t.reset = dib90x0_tuner_reset,\n\t\t.sleep = dib90x0_tuner_sleep,\n\t\t.clkouttobamse = 1,\n\t\t.analog_output = 0,\n\t\t.use_pwm_agc = 0,\n\t\t.clkoutdrive = 0,\n\t\t.freq_offset_khz_uhf = 0,\n\t\t.freq_offset_khz_vhf = 0,\n\t}, {\n\t\t.io.pll_bypass = 0,\n\t\t.io.pll_range = 1,\n\t\t.io.pll_prediv = 1,\n\t\t.io.pll_loopdiv = 8,\n\t\t.io.adc_clock_ratio = 8,\n\t\t.io.pll_int_loop_filt = 0,\n\t\t.io.clock_khz = 30000,\n\t\t.reset = dib90x0_tuner_reset,\n\t\t.sleep = dib90x0_tuner_sleep,\n\t\t.clkouttobamse = 0,\n\t\t.analog_output = 0,\n\t\t.use_pwm_agc = 0,\n\t\t.clkoutdrive = 0,\n\t\t.freq_offset_khz_uhf = 0,\n\t\t.freq_offset_khz_vhf = 0,\n\t}\n};\n\n\nstatic int stk9090m_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *state = adap->priv;\n\tstruct dib0700_state *st = adap->dev->priv;\n\tu32 fw_version;\n\n\t \n\tdib0700_get_version(adap->dev, NULL, NULL, &fw_version, NULL);\n\tif (fw_version >= 0x10200)\n\t\tst->fw_use_new_i2c_api = 1;\n\tdib0700_set_i2c_speed(adap->dev, 340);\n\n\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\n\tdib0700_ctrl_clock(adap->dev, 72, 1);\n\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\n\tdib9000_i2c_enumeration(&adap->dev->i2c_adap, 1, 0x10, 0x80);\n\n\tif (request_firmware(&state->frontend_firmware, \"dib9090.fw\", &adap->dev->udev->dev)) {\n\t\tdeb_info(\"%s: Upload failed. (file not found?)\\n\", __func__);\n\t\treturn -ENODEV;\n\t} else {\n\t\tdeb_info(\"%s: firmware read %zu bytes.\\n\", __func__, state->frontend_firmware->size);\n\t}\n\tstk9090m_config.microcode_B_fe_size = state->frontend_firmware->size;\n\tstk9090m_config.microcode_B_fe_buffer = state->frontend_firmware->data;\n\n\tadap->fe_adap[0].fe = dvb_attach(dib9000_attach, &adap->dev->i2c_adap, 0x80, &stk9090m_config);\n\n\treturn adap->fe_adap[0].fe == NULL ?  -ENODEV : 0;\n}\n\nstatic int dib9090_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *state = adap->priv;\n\tstruct i2c_adapter *i2c = dib9000_get_tuner_interface(adap->fe_adap[0].fe);\n\tu16 data_dib190[10] = {\n\t\t1, 0x1374,\n\t\t2, 0x01a2,\n\t\t7, 0x0020,\n\t\t0, 0x00ef,\n\t\t8, 0x0486,\n\t};\n\n\tif (!IS_ENABLED(CONFIG_DVB_DIB9000))\n\t\treturn -ENODEV;\n\tif (dvb_attach(dib0090_fw_register, adap->fe_adap[0].fe, i2c, &dib9090_dib0090_config) == NULL)\n\t\treturn -ENODEV;\n\ti2c = dib9000_get_i2c_master(adap->fe_adap[0].fe, DIBX000_I2C_INTERFACE_GPIO_1_2, 0);\n\tif (!i2c)\n\t\treturn -ENODEV;\n\tif (dib01x0_pmu_update(i2c, data_dib190, 10) != 0)\n\t\treturn -ENODEV;\n\tdib0700_set_i2c_speed(adap->dev, 1500);\n\tif (dib9000_firmware_post_pll_init(adap->fe_adap[0].fe) < 0)\n\t\treturn -ENODEV;\n\trelease_firmware(state->frontend_firmware);\n\treturn 0;\n}\n\nstatic int nim9090md_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *state = adap->priv;\n\tstruct dib0700_state *st = adap->dev->priv;\n\tstruct i2c_adapter *i2c;\n\tstruct dvb_frontend *fe_slave;\n\tu32 fw_version;\n\n\t \n\tdib0700_get_version(adap->dev, NULL, NULL, &fw_version, NULL);\n\tif (fw_version >= 0x10200)\n\t\tst->fw_use_new_i2c_api = 1;\n\tdib0700_set_i2c_speed(adap->dev, 340);\n\n\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\n\tdib0700_ctrl_clock(adap->dev, 72, 1);\n\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\n\tif (request_firmware(&state->frontend_firmware, \"dib9090.fw\", &adap->dev->udev->dev)) {\n\t\tdeb_info(\"%s: Upload failed. (file not found?)\\n\", __func__);\n\t\treturn -EIO;\n\t} else {\n\t\tdeb_info(\"%s: firmware read %zu bytes.\\n\", __func__, state->frontend_firmware->size);\n\t}\n\tnim9090md_config[0].microcode_B_fe_size = state->frontend_firmware->size;\n\tnim9090md_config[0].microcode_B_fe_buffer = state->frontend_firmware->data;\n\tnim9090md_config[1].microcode_B_fe_size = state->frontend_firmware->size;\n\tnim9090md_config[1].microcode_B_fe_buffer = state->frontend_firmware->data;\n\n\tdib9000_i2c_enumeration(&adap->dev->i2c_adap, 1, 0x20, 0x80);\n\tadap->fe_adap[0].fe = dvb_attach(dib9000_attach, &adap->dev->i2c_adap, 0x80, &nim9090md_config[0]);\n\n\tif (adap->fe_adap[0].fe == NULL)\n\t\treturn -ENODEV;\n\n\ti2c = dib9000_get_i2c_master(adap->fe_adap[0].fe, DIBX000_I2C_INTERFACE_GPIO_3_4, 0);\n\tdib9000_i2c_enumeration(i2c, 1, 0x12, 0x82);\n\n\tfe_slave = dvb_attach(dib9000_attach, i2c, 0x82, &nim9090md_config[1]);\n\tdib9000_set_slave_frontend(adap->fe_adap[0].fe, fe_slave);\n\n\treturn fe_slave == NULL ?  -ENODEV : 0;\n}\n\nstatic int nim9090md_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *state = adap->priv;\n\tstruct i2c_adapter *i2c;\n\tstruct dvb_frontend *fe_slave;\n\tu16 data_dib190[10] = {\n\t\t1, 0x5374,\n\t\t2, 0x01ae,\n\t\t7, 0x0020,\n\t\t0, 0x00ef,\n\t\t8, 0x0406,\n\t};\n\tif (!IS_ENABLED(CONFIG_DVB_DIB9000))\n\t\treturn -ENODEV;\n\ti2c = dib9000_get_tuner_interface(adap->fe_adap[0].fe);\n\tif (dvb_attach(dib0090_fw_register, adap->fe_adap[0].fe, i2c, &nim9090md_dib0090_config[0]) == NULL)\n\t\treturn -ENODEV;\n\ti2c = dib9000_get_i2c_master(adap->fe_adap[0].fe, DIBX000_I2C_INTERFACE_GPIO_1_2, 0);\n\tif (!i2c)\n\t\treturn -ENODEV;\n\tif (dib01x0_pmu_update(i2c, data_dib190, 10) < 0)\n\t\treturn -ENODEV;\n\n\tdib0700_set_i2c_speed(adap->dev, 1500);\n\tif (dib9000_firmware_post_pll_init(adap->fe_adap[0].fe) < 0)\n\t\treturn -ENODEV;\n\n\tfe_slave = dib9000_get_slave_frontend(adap->fe_adap[0].fe, 1);\n\tif (fe_slave != NULL) {\n\t\ti2c = dib9000_get_component_bus_interface(adap->fe_adap[0].fe);\n\t\tdib9000_set_i2c_adapter(fe_slave, i2c);\n\n\t\ti2c = dib9000_get_tuner_interface(fe_slave);\n\t\tif (dvb_attach(dib0090_fw_register, fe_slave, i2c, &nim9090md_dib0090_config[1]) == NULL)\n\t\t\treturn -ENODEV;\n\t\tfe_slave->dvb = adap->fe_adap[0].fe->dvb;\n\t\tdib9000_fw_set_component_bus_speed(adap->fe_adap[0].fe, 1500);\n\t\tif (dib9000_firmware_post_pll_init(fe_slave) < 0)\n\t\t\treturn -ENODEV;\n\t}\n\trelease_firmware(state->frontend_firmware);\n\n\treturn 0;\n}\n\n \nstatic int dib7090p_get_best_sampling(struct dvb_frontend *fe , struct dibx090p_best_adc *adc)\n{\n\tu8 spur = 0, prediv = 0, loopdiv = 0, min_prediv = 1, max_prediv = 1;\n\n\tu16 xtal = 12000;\n\tu32 fcp_min = 1900;   \n\tu32 fcp_max = 20000;  \n\tu32 fdem_max = 76000;\n\tu32 fdem_min = 69500;\n\tu32 fcp = 0, fs = 0, fdem = 0;\n\tu32 harmonic_id = 0;\n\n\tadc->pll_loopdiv = loopdiv;\n\tadc->pll_prediv = prediv;\n\tadc->timf = 0;\n\n\tdeb_info(\"bandwidth = %d fdem_min =%d\", fe->dtv_property_cache.bandwidth_hz, fdem_min);\n\n\t \n\twhile ((xtal/max_prediv) >= fcp_min)\n\t\tmax_prediv++;\n\n\tmax_prediv--;\n\tmin_prediv = max_prediv;\n\twhile ((xtal/min_prediv) <= fcp_max) {\n\t\tmin_prediv--;\n\t\tif (min_prediv == 1)\n\t\t\tbreak;\n\t}\n\tdeb_info(\"MIN prediv = %d : MAX prediv = %d\", min_prediv, max_prediv);\n\n\tmin_prediv = 2;\n\n\tfor (prediv = min_prediv ; prediv < max_prediv; prediv++) {\n\t\tfcp = xtal / prediv;\n\t\tif (fcp > fcp_min && fcp < fcp_max) {\n\t\t\tfor (loopdiv = 1 ; loopdiv < 64 ; loopdiv++) {\n\t\t\t\tfdem = ((xtal/prediv) * loopdiv);\n\t\t\t\tfs   = fdem / 4;\n\t\t\t\t \n\n\t\t\t\tif ((fdem >= fdem_min) && (fdem <= fdem_max) && (fs >= fe->dtv_property_cache.bandwidth_hz/1000)) {\n\t\t\t\t\tspur = 0;\n\t\t\t\t\t \n\t\t\t\t\tfor (harmonic_id = (fe->dtv_property_cache.frequency / (1000*fs)) ;  harmonic_id <= ((fe->dtv_property_cache.frequency / (1000*fs))+1) ; harmonic_id++) {\n\t\t\t\t\t\tif (((fs*harmonic_id) >= ((fe->dtv_property_cache.frequency/1000) - (fe->dtv_property_cache.bandwidth_hz/2000))) &&  ((fs*harmonic_id) <= ((fe->dtv_property_cache.frequency/1000) + (fe->dtv_property_cache.bandwidth_hz/2000)))) {\n\t\t\t\t\t\t\tspur = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!spur) {\n\t\t\t\t\t\tadc->pll_loopdiv = loopdiv;\n\t\t\t\t\t\tadc->pll_prediv = prediv;\n\t\t\t\t\t\tadc->timf = 2396745143UL/fdem*(1 << 9);\n\t\t\t\t\t\tadc->timf += ((2396745143UL%fdem) << 9)/fdem;\n\t\t\t\t\t\tdeb_info(\"loopdiv=%i prediv=%i timf=%i\", loopdiv, prediv, adc->timf);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!spur)\n\t\t\tbreak;\n\t}\n\n\n\tif (adc->pll_loopdiv == 0 && adc->pll_prediv == 0)\n\t\treturn -EINVAL;\n\telse\n\t\treturn 0;\n}\n\nstatic int dib7090_agc_startup(struct dvb_frontend *fe)\n{\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\tstruct dibx000_bandwidth_config pll;\n\tu16 target;\n\tstruct dibx090p_best_adc adc;\n\tint ret;\n\n\tret = state->set_param_save(fe);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmemset(&pll, 0, sizeof(struct dibx000_bandwidth_config));\n\tdib0090_pwm_gain_reset(fe);\n\ttarget = (dib0090_get_wbd_target(fe) * 8 + 1) / 2;\n\tstate->dib7000p_ops.set_wbd_ref(fe, target);\n\n\tif (dib7090p_get_best_sampling(fe, &adc) == 0) {\n\t\tpll.pll_ratio  = adc.pll_loopdiv;\n\t\tpll.pll_prediv = adc.pll_prediv;\n\n\t\tstate->dib7000p_ops.update_pll(fe, &pll);\n\t\tstate->dib7000p_ops.ctrl_timf(fe, DEMOD_TIMF_SET, adc.timf);\n\t}\n\treturn 0;\n}\n\nstatic int dib7090_agc_restart(struct dvb_frontend *fe, u8 restart)\n{\n\tdeb_info(\"AGC restart callback: %d\", restart);\n\tif (restart == 0)  \n\t\tdib0090_set_dc_servo(fe, 1);\n\treturn 0;\n}\n\nstatic int tfe7790p_update_lna(struct dvb_frontend *fe, u16 agc_global)\n{\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tdeb_info(\"update LNA: agc global=%i\", agc_global);\n\n\tif (agc_global < 25000) {\n\t\tstate->dib7000p_ops.set_gpio(fe, 8, 0, 0);\n\t\tstate->dib7000p_ops.set_agc1_min(fe, 0);\n\t} else {\n\t\tstate->dib7000p_ops.set_gpio(fe, 8, 0, 1);\n\t\tstate->dib7000p_ops.set_agc1_min(fe, 32768);\n\t}\n\n\treturn 0;\n}\n\nstatic struct dib0090_wbd_slope dib7090_wbd_table[] = {\n\t{ 380,   81, 850, 64, 540,  4},\n\t{ 860,   51, 866, 21,  375, 4},\n\t{1700,    0, 250, 0,   100, 6},\n\t{2600,    0, 250, 0,   100, 6},\n\t{ 0xFFFF, 0,   0, 0,   0,   0},\n};\n\nstatic struct dibx000_agc_config dib7090_agc_config[2] = {\n\t{\n\t\t.band_caps      = BAND_UHF,\n\t\t \n\t\t.setup          = (0 << 15) | (0 << 14) | (5 << 11) | (0 << 10) | (0 << 9) | (0 << 8) | (3 << 5) | (0 << 4) | (5 << 1) | (0 << 0),\n\n\t\t.inv_gain       = 687,\n\t\t.time_stabiliz  = 10,\n\n\t\t.alpha_level    = 0,\n\t\t.thlock         = 118,\n\n\t\t.wbd_inv        = 0,\n\t\t.wbd_ref        = 1200,\n\t\t.wbd_sel        = 3,\n\t\t.wbd_alpha      = 5,\n\n\t\t.agc1_max       = 65535,\n\t\t.agc1_min       = 32768,\n\n\t\t.agc2_max       = 65535,\n\t\t.agc2_min       = 0,\n\n\t\t.agc1_pt1       = 0,\n\t\t.agc1_pt2       = 32,\n\t\t.agc1_pt3       = 114,\n\t\t.agc1_slope1    = 143,\n\t\t.agc1_slope2    = 144,\n\t\t.agc2_pt1       = 114,\n\t\t.agc2_pt2       = 227,\n\t\t.agc2_slope1    = 116,\n\t\t.agc2_slope2    = 117,\n\n\t\t.alpha_mant     = 18,\n\t\t.alpha_exp      = 0,\n\t\t.beta_mant      = 20,\n\t\t.beta_exp       = 59,\n\n\t\t.perform_agc_softsplit = 0,\n\t} , {\n\t\t.band_caps      = BAND_FM | BAND_VHF | BAND_CBAND,\n\t\t \n\t\t.setup          = (0 << 15) | (0 << 14) | (5 << 11) | (0 << 10) | (0 << 9) | (0 << 8) | (3 << 5) | (0 << 4) | (5 << 1) | (0 << 0),\n\n\t\t.inv_gain       = 732,\n\t\t.time_stabiliz  = 10,\n\n\t\t.alpha_level    = 0,\n\t\t.thlock         = 118,\n\n\t\t.wbd_inv        = 0,\n\t\t.wbd_ref        = 1200,\n\t\t.wbd_sel        = 3,\n\t\t.wbd_alpha      = 5,\n\n\t\t.agc1_max       = 65535,\n\t\t.agc1_min       = 0,\n\n\t\t.agc2_max       = 65535,\n\t\t.agc2_min       = 0,\n\n\t\t.agc1_pt1       = 0,\n\t\t.agc1_pt2       = 0,\n\t\t.agc1_pt3       = 98,\n\t\t.agc1_slope1    = 0,\n\t\t.agc1_slope2    = 167,\n\t\t.agc2_pt1       = 98,\n\t\t.agc2_pt2       = 255,\n\t\t.agc2_slope1    = 104,\n\t\t.agc2_slope2    = 0,\n\n\t\t.alpha_mant     = 18,\n\t\t.alpha_exp      = 0,\n\t\t.beta_mant      = 20,\n\t\t.beta_exp       = 59,\n\n\t\t.perform_agc_softsplit = 0,\n\t}\n};\n\nstatic struct dibx000_bandwidth_config dib7090_clock_config_12_mhz = {\n\t.internal = 60000,\n\t.sampling = 15000,\n\t.pll_prediv = 1,\n\t.pll_ratio = 5,\n\t.pll_range = 0,\n\t.pll_reset = 0,\n\t.pll_bypass = 0,\n\t.enable_refdiv = 0,\n\t.bypclk_div = 0,\n\t.IO_CLK_en_core = 1,\n\t.ADClkSrc = 1,\n\t.modulo = 2,\n\t.sad_cfg = (3 << 14) | (1 << 12) | (524 << 0),\n\t.ifreq = (0 << 25) | 0,\n\t.timf = 20452225,\n\t.xtal_hz = 15000000,\n};\n\nstatic struct dib7000p_config nim7090_dib7000p_config = {\n\t.output_mpeg2_in_188_bytes  = 1,\n\t.hostbus_diversity\t\t\t= 1,\n\t.tuner_is_baseband\t\t\t= 1,\n\t.update_lna\t\t\t\t\t= tfe7790p_update_lna,  \n\n\t.agc_config_count\t\t\t= 2,\n\t.agc\t\t\t\t\t\t= dib7090_agc_config,\n\n\t.bw\t\t\t\t\t\t\t= &dib7090_clock_config_12_mhz,\n\n\t.gpio_dir\t\t\t\t\t= DIB7000P_GPIO_DEFAULT_DIRECTIONS,\n\t.gpio_val\t\t\t\t\t= DIB7000P_GPIO_DEFAULT_VALUES,\n\t.gpio_pwm_pos\t\t\t\t= DIB7000P_GPIO_DEFAULT_PWM_POS,\n\n\t.pwm_freq_div\t\t\t\t= 0,\n\n\t.agc_control\t\t\t\t= dib7090_agc_restart,\n\n\t.spur_protect\t\t\t\t= 0,\n\t.disable_sample_and_hold\t= 0,\n\t.enable_current_mirror\t\t= 0,\n\t.diversity_delay\t\t\t= 0,\n\n\t.output_mode\t\t\t\t= OUTMODE_MPEG2_FIFO,\n\t.enMpegOutput\t\t\t\t= 1,\n};\n\nstatic int tfe7090p_pvr_update_lna(struct dvb_frontend *fe, u16 agc_global)\n{\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tdeb_info(\"TFE7090P-PVR update LNA: agc global=%i\", agc_global);\n\tif (agc_global < 25000) {\n\t\tstate->dib7000p_ops.set_gpio(fe, 5, 0, 0);\n\t\tstate->dib7000p_ops.set_agc1_min(fe, 0);\n\t} else {\n\t\tstate->dib7000p_ops.set_gpio(fe, 5, 0, 1);\n\t\tstate->dib7000p_ops.set_agc1_min(fe, 32768);\n\t}\n\n\treturn 0;\n}\n\nstatic struct dib7000p_config tfe7090pvr_dib7000p_config[2] = {\n\t{\n\t\t.output_mpeg2_in_188_bytes  = 1,\n\t\t.hostbus_diversity\t\t\t= 1,\n\t\t.tuner_is_baseband\t\t\t= 1,\n\t\t.update_lna\t\t\t\t\t= tfe7090p_pvr_update_lna,\n\n\t\t.agc_config_count\t\t\t= 2,\n\t\t.agc\t\t\t\t\t\t= dib7090_agc_config,\n\n\t\t.bw\t\t\t\t\t\t\t= &dib7090_clock_config_12_mhz,\n\n\t\t.gpio_dir\t\t\t\t\t= DIB7000P_GPIO_DEFAULT_DIRECTIONS,\n\t\t.gpio_val\t\t\t\t\t= DIB7000P_GPIO_DEFAULT_VALUES,\n\t\t.gpio_pwm_pos\t\t\t\t= DIB7000P_GPIO_DEFAULT_PWM_POS,\n\n\t\t.pwm_freq_div\t\t\t\t= 0,\n\n\t\t.agc_control\t\t\t\t= dib7090_agc_restart,\n\n\t\t.spur_protect\t\t\t\t= 0,\n\t\t.disable_sample_and_hold\t= 0,\n\t\t.enable_current_mirror\t\t= 0,\n\t\t.diversity_delay\t\t\t= 0,\n\n\t\t.output_mode\t\t\t\t= OUTMODE_MPEG2_PAR_GATED_CLK,\n\t\t.default_i2c_addr\t\t\t= 0x90,\n\t\t.enMpegOutput\t\t\t\t= 1,\n\t}, {\n\t\t.output_mpeg2_in_188_bytes  = 1,\n\t\t.hostbus_diversity\t\t\t= 1,\n\t\t.tuner_is_baseband\t\t\t= 1,\n\t\t.update_lna\t\t\t\t\t= tfe7090p_pvr_update_lna,\n\n\t\t.agc_config_count\t\t\t= 2,\n\t\t.agc\t\t\t\t\t\t= dib7090_agc_config,\n\n\t\t.bw\t\t\t\t\t\t\t= &dib7090_clock_config_12_mhz,\n\n\t\t.gpio_dir\t\t\t\t\t= DIB7000P_GPIO_DEFAULT_DIRECTIONS,\n\t\t.gpio_val\t\t\t\t\t= DIB7000P_GPIO_DEFAULT_VALUES,\n\t\t.gpio_pwm_pos\t\t\t\t= DIB7000P_GPIO_DEFAULT_PWM_POS,\n\n\t\t.pwm_freq_div\t\t\t\t= 0,\n\n\t\t.agc_control\t\t\t\t= dib7090_agc_restart,\n\n\t\t.spur_protect\t\t\t\t= 0,\n\t\t.disable_sample_and_hold\t= 0,\n\t\t.enable_current_mirror\t\t= 0,\n\t\t.diversity_delay\t\t\t= 0,\n\n\t\t.output_mode\t\t\t\t= OUTMODE_MPEG2_PAR_GATED_CLK,\n\t\t.default_i2c_addr\t\t\t= 0x92,\n\t\t.enMpegOutput\t\t\t\t= 0,\n\t}\n};\n\nstatic struct dib0090_config nim7090_dib0090_config = {\n\t.io.clock_khz = 12000,\n\t.io.pll_bypass = 0,\n\t.io.pll_range = 0,\n\t.io.pll_prediv = 3,\n\t.io.pll_loopdiv = 6,\n\t.io.adc_clock_ratio = 0,\n\t.io.pll_int_loop_filt = 0,\n\n\t.freq_offset_khz_uhf = 0,\n\t.freq_offset_khz_vhf = 0,\n\n\t.clkouttobamse = 1,\n\t.analog_output = 0,\n\n\t.wbd_vhf_offset = 0,\n\t.wbd_cband_offset = 0,\n\t.use_pwm_agc = 1,\n\t.clkoutdrive = 0,\n\n\t.fref_clock_ratio = 0,\n\n\t.wbd = dib7090_wbd_table,\n\n\t.ls_cfg_pad_drv = 0,\n\t.data_tx_drv = 0,\n\t.low_if = NULL,\n\t.in_soc = 1,\n};\n\nstatic struct dib7000p_config tfe7790p_dib7000p_config = {\n\t.output_mpeg2_in_188_bytes  = 1,\n\t.hostbus_diversity\t\t\t= 1,\n\t.tuner_is_baseband\t\t\t= 1,\n\t.update_lna\t\t\t\t\t= tfe7790p_update_lna,\n\n\t.agc_config_count\t\t\t= 2,\n\t.agc\t\t\t\t\t\t= dib7090_agc_config,\n\n\t.bw\t\t\t\t\t\t\t= &dib7090_clock_config_12_mhz,\n\n\t.gpio_dir\t\t\t\t\t= DIB7000P_GPIO_DEFAULT_DIRECTIONS,\n\t.gpio_val\t\t\t\t\t= DIB7000P_GPIO_DEFAULT_VALUES,\n\t.gpio_pwm_pos\t\t\t\t= DIB7000P_GPIO_DEFAULT_PWM_POS,\n\n\t.pwm_freq_div\t\t\t\t= 0,\n\n\t.agc_control\t\t\t\t= dib7090_agc_restart,\n\n\t.spur_protect\t\t\t\t= 0,\n\t.disable_sample_and_hold\t= 0,\n\t.enable_current_mirror\t\t= 0,\n\t.diversity_delay\t\t\t= 0,\n\n\t.output_mode\t\t\t\t= OUTMODE_MPEG2_PAR_GATED_CLK,\n\t.enMpegOutput\t\t\t\t= 1,\n};\n\nstatic struct dib0090_config tfe7790p_dib0090_config = {\n\t.io.clock_khz = 12000,\n\t.io.pll_bypass = 0,\n\t.io.pll_range = 0,\n\t.io.pll_prediv = 3,\n\t.io.pll_loopdiv = 6,\n\t.io.adc_clock_ratio = 0,\n\t.io.pll_int_loop_filt = 0,\n\n\t.freq_offset_khz_uhf = 0,\n\t.freq_offset_khz_vhf = 0,\n\n\t.clkouttobamse = 1,\n\t.analog_output = 0,\n\n\t.wbd_vhf_offset = 0,\n\t.wbd_cband_offset = 0,\n\t.use_pwm_agc = 1,\n\t.clkoutdrive = 0,\n\n\t.fref_clock_ratio = 0,\n\n\t.wbd = dib7090_wbd_table,\n\n\t.ls_cfg_pad_drv = 0,\n\t.data_tx_drv = 0,\n\t.low_if = NULL,\n\t.in_soc = 1,\n\t.force_cband_input = 0,\n\t.is_dib7090e = 0,\n\t.force_crystal_mode = 1,\n};\n\nstatic struct dib0090_config tfe7090pvr_dib0090_config[2] = {\n\t{\n\t\t.io.clock_khz = 12000,\n\t\t.io.pll_bypass = 0,\n\t\t.io.pll_range = 0,\n\t\t.io.pll_prediv = 3,\n\t\t.io.pll_loopdiv = 6,\n\t\t.io.adc_clock_ratio = 0,\n\t\t.io.pll_int_loop_filt = 0,\n\n\t\t.freq_offset_khz_uhf = 50,\n\t\t.freq_offset_khz_vhf = 70,\n\n\t\t.clkouttobamse = 1,\n\t\t.analog_output = 0,\n\n\t\t.wbd_vhf_offset = 0,\n\t\t.wbd_cband_offset = 0,\n\t\t.use_pwm_agc = 1,\n\t\t.clkoutdrive = 0,\n\n\t\t.fref_clock_ratio = 0,\n\n\t\t.wbd = dib7090_wbd_table,\n\n\t\t.ls_cfg_pad_drv = 0,\n\t\t.data_tx_drv = 0,\n\t\t.low_if = NULL,\n\t\t.in_soc = 1,\n\t}, {\n\t\t.io.clock_khz = 12000,\n\t\t.io.pll_bypass = 0,\n\t\t.io.pll_range = 0,\n\t\t.io.pll_prediv = 3,\n\t\t.io.pll_loopdiv = 6,\n\t\t.io.adc_clock_ratio = 0,\n\t\t.io.pll_int_loop_filt = 0,\n\n\t\t.freq_offset_khz_uhf = -50,\n\t\t.freq_offset_khz_vhf = -70,\n\n\t\t.clkouttobamse = 1,\n\t\t.analog_output = 0,\n\n\t\t.wbd_vhf_offset = 0,\n\t\t.wbd_cband_offset = 0,\n\t\t.use_pwm_agc = 1,\n\t\t.clkoutdrive = 0,\n\n\t\t.fref_clock_ratio = 0,\n\n\t\t.wbd = dib7090_wbd_table,\n\n\t\t.ls_cfg_pad_drv = 0,\n\t\t.data_tx_drv = 0,\n\t\t.low_if = NULL,\n\t\t.in_soc = 1,\n\t}\n};\n\nstatic int nim7090_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\n\tif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 0x10, &nim7090_dib7000p_config) != 0) {\n\t\terr(\"%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\\n\", __func__);\n\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);\n\t\treturn -ENODEV;\n\t}\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x80, &nim7090_dib7000p_config);\n\n\treturn adap->fe_adap[0].fe == NULL ?  -ENODEV : 0;\n}\n\nstatic int nim7090_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *st = adap->priv;\n\tstruct i2c_adapter *tun_i2c = st->dib7000p_ops.get_i2c_tuner(adap->fe_adap[0].fe);\n\n\tnim7090_dib0090_config.reset = st->dib7000p_ops.tuner_sleep;\n\tnim7090_dib0090_config.sleep = st->dib7000p_ops.tuner_sleep;\n\tnim7090_dib0090_config.get_adc_power = st->dib7000p_ops.get_adc_power;\n\n\tif (dvb_attach(dib0090_register, adap->fe_adap[0].fe, tun_i2c, &nim7090_dib0090_config) == NULL)\n\t\treturn -ENODEV;\n\n\tst->dib7000p_ops.set_gpio(adap->fe_adap[0].fe, 8, 0, 1);\n\n\tst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\n\tadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib7090_agc_startup;\n\treturn 0;\n}\n\nstatic int tfe7090pvr_frontend0_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_state *st = adap->dev->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\t \n\tst->disable_streaming_master_mode = 1;\n\n\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\n\t \n\tif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 1, 0x20, &tfe7090pvr_dib7000p_config[0]) != 0) {\n\t\terr(\"%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\\n\", __func__);\n\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);\n\t\treturn -ENODEV;\n\t}\n\n\tdib0700_set_i2c_speed(adap->dev, 340);\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x90, &tfe7090pvr_dib7000p_config[0]);\n\tif (adap->fe_adap[0].fe == NULL)\n\t\treturn -ENODEV;\n\n\tstate->dib7000p_ops.slave_reset(adap->fe_adap[0].fe);\n\n\treturn 0;\n}\n\nstatic int tfe7090pvr_frontend1_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct i2c_adapter *i2c;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (adap->dev->adapter[0].fe_adap[0].fe == NULL) {\n\t\terr(\"the master dib7090 has to be initialized first\");\n\t\treturn -ENODEV;  \n\t}\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\ti2c = state->dib7000p_ops.get_i2c_master(adap->dev->adapter[0].fe_adap[0].fe, DIBX000_I2C_INTERFACE_GPIO_6_7, 1);\n\tif (state->dib7000p_ops.i2c_enumeration(i2c, 1, 0x10, &tfe7090pvr_dib7000p_config[1]) != 0) {\n\t\terr(\"%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\\n\", __func__);\n\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);\n\t\treturn -ENODEV;\n\t}\n\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(i2c, 0x92, &tfe7090pvr_dib7000p_config[1]);\n\tdib0700_set_i2c_speed(adap->dev, 200);\n\n\treturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\n}\n\nstatic int tfe7090pvr_tuner0_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *st = adap->priv;\n\tstruct i2c_adapter *tun_i2c = st->dib7000p_ops.get_i2c_tuner(adap->fe_adap[0].fe);\n\n\ttfe7090pvr_dib0090_config[0].reset = st->dib7000p_ops.tuner_sleep;\n\ttfe7090pvr_dib0090_config[0].sleep = st->dib7000p_ops.tuner_sleep;\n\ttfe7090pvr_dib0090_config[0].get_adc_power = st->dib7000p_ops.get_adc_power;\n\n\tif (dvb_attach(dib0090_register, adap->fe_adap[0].fe, tun_i2c, &tfe7090pvr_dib0090_config[0]) == NULL)\n\t\treturn -ENODEV;\n\n\tst->dib7000p_ops.set_gpio(adap->fe_adap[0].fe, 8, 0, 1);\n\n\tst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\n\tadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib7090_agc_startup;\n\treturn 0;\n}\n\nstatic int tfe7090pvr_tuner1_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *st = adap->priv;\n\tstruct i2c_adapter *tun_i2c = st->dib7000p_ops.get_i2c_tuner(adap->fe_adap[0].fe);\n\n\ttfe7090pvr_dib0090_config[1].reset = st->dib7000p_ops.tuner_sleep;\n\ttfe7090pvr_dib0090_config[1].sleep = st->dib7000p_ops.tuner_sleep;\n\ttfe7090pvr_dib0090_config[1].get_adc_power = st->dib7000p_ops.get_adc_power;\n\n\tif (dvb_attach(dib0090_register, adap->fe_adap[0].fe, tun_i2c, &tfe7090pvr_dib0090_config[1]) == NULL)\n\t\treturn -ENODEV;\n\n\tst->dib7000p_ops.set_gpio(adap->fe_adap[0].fe, 8, 0, 1);\n\n\tst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\n\tadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib7090_agc_startup;\n\treturn 0;\n}\n\nstatic int tfe7790p_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_state *st = adap->dev->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\t \n\tst->disable_streaming_master_mode = 1;\n\n\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\tmsleep(20);\n\tdib0700_ctrl_clock(adap->dev, 72, 1);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(20);\n\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\n\tif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap,\n\t\t\t\t1, 0x10, &tfe7790p_dib7000p_config) != 0) {\n\t\terr(\"%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\\n\",\n\t\t\t\t__func__);\n\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);\n\t\treturn -ENODEV;\n\t}\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap,\n\t\t\t0x80, &tfe7790p_dib7000p_config);\n\n\treturn adap->fe_adap[0].fe == NULL ?  -ENODEV : 0;\n}\n\nstatic int tfe7790p_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *st = adap->priv;\n\tstruct i2c_adapter *tun_i2c =\n\t\tst->dib7000p_ops.get_i2c_tuner(adap->fe_adap[0].fe);\n\n\n\ttfe7790p_dib0090_config.reset = st->dib7000p_ops.tuner_sleep;\n\ttfe7790p_dib0090_config.sleep = st->dib7000p_ops.tuner_sleep;\n\ttfe7790p_dib0090_config.get_adc_power = st->dib7000p_ops.get_adc_power;\n\n\tif (dvb_attach(dib0090_register, adap->fe_adap[0].fe, tun_i2c,\n\t\t\t\t&tfe7790p_dib0090_config) == NULL)\n\t\treturn -ENODEV;\n\n\tst->dib7000p_ops.set_gpio(adap->fe_adap[0].fe, 8, 0, 1);\n\n\tst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\n\tadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib7090_agc_startup;\n\treturn 0;\n}\n\n \nstatic struct dib7000p_config stk7070pd_dib7000p_config[2] = {\n\t{\n\t\t.output_mpeg2_in_188_bytes = 1,\n\n\t\t.agc_config_count = 1,\n\t\t.agc = &dib7070_agc_config,\n\t\t.bw  = &dib7070_bw_config_12_mhz,\n\t\t.tuner_is_baseband = 1,\n\t\t.spur_protect = 1,\n\n\t\t.gpio_dir = DIB7000P_GPIO_DEFAULT_DIRECTIONS,\n\t\t.gpio_val = DIB7000P_GPIO_DEFAULT_VALUES,\n\t\t.gpio_pwm_pos = DIB7000P_GPIO_DEFAULT_PWM_POS,\n\n\t\t.hostbus_diversity = 1,\n\t}, {\n\t\t.output_mpeg2_in_188_bytes = 1,\n\n\t\t.agc_config_count = 1,\n\t\t.agc = &dib7070_agc_config,\n\t\t.bw  = &dib7070_bw_config_12_mhz,\n\t\t.tuner_is_baseband = 1,\n\t\t.spur_protect = 1,\n\n\t\t.gpio_dir = DIB7000P_GPIO_DEFAULT_DIRECTIONS,\n\t\t.gpio_val = DIB7000P_GPIO_DEFAULT_VALUES,\n\t\t.gpio_pwm_pos = DIB7000P_GPIO_DEFAULT_PWM_POS,\n\n\t\t.hostbus_diversity = 1,\n\t}\n};\n\nstatic void stk7070pd_init(struct dvb_usb_device *dev)\n{\n\tdib0700_set_gpio(dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(10);\n\tdib0700_set_gpio(dev, GPIO9, GPIO_OUT, 1);\n\tdib0700_set_gpio(dev, GPIO4, GPIO_OUT, 1);\n\tdib0700_set_gpio(dev, GPIO7, GPIO_OUT, 1);\n\tdib0700_set_gpio(dev, GPIO10, GPIO_OUT, 0);\n\n\tdib0700_ctrl_clock(dev, 72, 1);\n\n\tmsleep(10);\n\tdib0700_set_gpio(dev, GPIO10, GPIO_OUT, 1);\n}\n\nstatic int stk7070pd_frontend_attach0(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\tstk7070pd_init(adap->dev);\n\n\tmsleep(10);\n\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\n\tif (state->dib7000p_ops.i2c_enumeration(&adap->dev->i2c_adap, 2, 18,\n\t\t\t\t     stk7070pd_dib7000p_config) != 0) {\n\t\terr(\"%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\\n\",\n\t\t    __func__);\n\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);\n\t\treturn -ENODEV;\n\t}\n\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x80, &stk7070pd_dib7000p_config[0]);\n\treturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\n}\n\nstatic int stk7070pd_frontend_attach1(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x82, &stk7070pd_dib7000p_config[1]);\n\treturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\n}\n\nstatic int novatd_read_status_override(struct dvb_frontend *fe,\n\t\t\t\t       enum fe_status *stat)\n{\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dvb_usb_device *dev = adap->dev;\n\tstruct dib0700_state *state = dev->priv;\n\tint ret;\n\n\tret = state->read_status(fe, stat);\n\n\tif (!ret)\n\t\tdib0700_set_gpio(dev, adap->id == 0 ? GPIO1 : GPIO0, GPIO_OUT,\n\t\t\t\t!!(*stat & FE_HAS_LOCK));\n\n\treturn ret;\n}\n\nstatic int novatd_sleep_override(struct dvb_frontend* fe)\n{\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tstruct dvb_usb_device *dev = adap->dev;\n\tstruct dib0700_state *state = dev->priv;\n\n\t \n\tdib0700_set_gpio(dev, adap->id == 0 ? GPIO1 : GPIO0, GPIO_OUT, 0);\n\n\treturn state->sleep(fe);\n}\n\n \nstatic int novatd_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *dev = adap->dev;\n\tstruct dib0700_state *st = dev->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\tif (adap->id == 0) {\n\t\tstk7070pd_init(dev);\n\n\t\t \n\t\tdib0700_set_gpio(dev, GPIO0, GPIO_OUT, 0);\n\t\tdib0700_set_gpio(dev, GPIO1, GPIO_OUT, 0);\n\t\tdib0700_set_gpio(dev, GPIO2, GPIO_OUT, 1);\n\n\t\tif (state->dib7000p_ops.i2c_enumeration(&dev->i2c_adap, 2, 18,\n\t\t\t\t\t     stk7070pd_dib7000p_config) != 0) {\n\t\t\terr(\"%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\\n\",\n\t\t\t    __func__);\n\t\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&dev->i2c_adap,\n\t\t\tadap->id == 0 ? 0x80 : 0x82,\n\t\t\t&stk7070pd_dib7000p_config[adap->id]);\n\n\tif (adap->fe_adap[0].fe == NULL)\n\t\treturn -ENODEV;\n\n\tst->read_status = adap->fe_adap[0].fe->ops.read_status;\n\tadap->fe_adap[0].fe->ops.read_status = novatd_read_status_override;\n\tst->sleep = adap->fe_adap[0].fe->ops.sleep;\n\tadap->fe_adap[0].fe->ops.sleep = novatd_sleep_override;\n\n\treturn 0;\n}\n\n \nstatic struct s5h1411_config pinnacle_801e_config = {\n\t.output_mode   = S5H1411_PARALLEL_OUTPUT,\n\t.gpio          = S5H1411_GPIO_OFF,\n\t.mpeg_timing   = S5H1411_MPEGTIMING_NONCONTINUOUS_NONINVERTING_CLOCK,\n\t.qam_if        = S5H1411_IF_44000,\n\t.vsb_if        = S5H1411_IF_44000,\n\t.inversion     = S5H1411_INVERSION_OFF,\n\t.status_mode   = S5H1411_DEMODLOCKING\n};\n\n \nstatic int s5h1411_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_state *st = adap->dev->priv;\n\n\t \n\tst->fw_use_new_i2c_api = 1;\n\n\t \n\tst->disable_streaming_master_mode = 1;\n\n\t \n\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 0);\n\tdib0700_set_gpio(adap->dev, GPIO3, GPIO_OUT, 0);\n\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(400);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\tmsleep(60);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(30);\n\tdib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);\n\tdib0700_set_gpio(adap->dev, GPIO2, GPIO_OUT, 0);\n\tmsleep(30);\n\n\t \n\tdib0700_set_gpio(adap->dev, GPIO2, GPIO_OUT, 1);\n\n\t \n\tadap->fe_adap[0].fe = dvb_attach(s5h1411_attach, &pinnacle_801e_config,\n\t\t\t      &adap->dev->i2c_adap);\n\treturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\n}\n\nstatic int dib0700_xc5000_tuner_callback(void *priv, int component,\n\t\t\t\t\t int command, int arg)\n{\n\tstruct dvb_usb_adapter *adap = priv;\n\n\tif (command == XC5000_TUNER_RESET) {\n\t\t \n\t\tdib0700_set_gpio(adap->dev, GPIO1, GPIO_OUT, 0);\n\t\tmsleep(10);\n\t\tdib0700_set_gpio(adap->dev, GPIO1, GPIO_OUT, 1);\n\t\tmsleep(10);\n\t} else {\n\t\terr(\"xc5000: unknown tuner callback command: %d\\n\", command);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct xc5000_config s5h1411_xc5000_tunerconfig = {\n\t.i2c_address      = 0x64,\n\t.if_khz           = 5380,\n};\n\nstatic int xc5000_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\t \n\tadap->fe_adap[0].fe->callback = dib0700_xc5000_tuner_callback;\n\n\treturn dvb_attach(xc5000_attach, adap->fe_adap[0].fe, &adap->dev->i2c_adap,\n\t\t\t  &s5h1411_xc5000_tunerconfig)\n\t\t== NULL ? -ENODEV : 0;\n}\n\nstatic int dib0700_xc4000_tuner_callback(void *priv, int component,\n\t\t\t\t\t int command, int arg)\n{\n\tstruct dvb_usb_adapter *adap = priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (command == XC4000_TUNER_RESET) {\n\t\t \n\t\tstate->dib7000p_ops.set_gpio(adap->fe_adap[0].fe, 8, 0, 0);\n\t\tmsleep(10);\n\t\tstate->dib7000p_ops.set_gpio(adap->fe_adap[0].fe, 8, 0, 1);\n\t} else {\n\t\terr(\"xc4000: unknown tuner callback command: %d\\n\", command);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct dibx000_agc_config stk7700p_7000p_xc4000_agc_config = {\n\t.band_caps = BAND_UHF | BAND_VHF,\n\t.setup = 0x64,\n\t.inv_gain = 0x02c8,\n\t.time_stabiliz = 0x15,\n\t.alpha_level = 0x00,\n\t.thlock = 0x76,\n\t.wbd_inv = 0x01,\n\t.wbd_ref = 0x0b33,\n\t.wbd_sel = 0x00,\n\t.wbd_alpha = 0x02,\n\t.agc1_max = 0x00,\n\t.agc1_min = 0x00,\n\t.agc2_max = 0x9b26,\n\t.agc2_min = 0x26ca,\n\t.agc1_pt1 = 0x00,\n\t.agc1_pt2 = 0x00,\n\t.agc1_pt3 = 0x00,\n\t.agc1_slope1 = 0x00,\n\t.agc1_slope2 = 0x00,\n\t.agc2_pt1 = 0x00,\n\t.agc2_pt2 = 0x80,\n\t.agc2_slope1 = 0x1d,\n\t.agc2_slope2 = 0x1d,\n\t.alpha_mant = 0x11,\n\t.alpha_exp = 0x1b,\n\t.beta_mant = 0x17,\n\t.beta_exp = 0x33,\n\t.perform_agc_softsplit = 0x00,\n};\n\nstatic struct dibx000_bandwidth_config stk7700p_xc4000_pll_config = {\n\t.internal = 60000,\n\t.sampling = 30000,\n\t.pll_prediv = 1,\n\t.pll_ratio = 8,\n\t.pll_range = 3,\n\t.pll_reset = 1,\n\t.pll_bypass = 0,\n\t.enable_refdiv = 0,\n\t.bypclk_div = 0,\n\t.IO_CLK_en_core = 1,\n\t.ADClkSrc = 1,\n\t.modulo = 0,\n\t.sad_cfg = (3 << 14) | (1 << 12) | 524,  \n\t.ifreq = 39370534,\n\t.timf = 20452225,\n\t.xtal_hz = 30000000\n};\n\n \nstatic struct dib7000p_config pctv_340e_config = {\n\t.output_mpeg2_in_188_bytes = 1,\n\n\t.agc_config_count = 1,\n\t.agc = &stk7700p_7000p_xc4000_agc_config,\n\t.bw  = &stk7700p_xc4000_pll_config,\n\n\t.gpio_dir = DIB7000M_GPIO_DEFAULT_DIRECTIONS,\n\t.gpio_val = DIB7000M_GPIO_DEFAULT_VALUES,\n\t.gpio_pwm_pos = DIB7000M_GPIO_DEFAULT_PWM_POS,\n};\n\n \nstatic int pctv340e_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_state *st = adap->dev->priv;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\tif (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))\n\t\treturn -ENODEV;\n\n\t \n\tdib0700_set_gpio(adap->dev, GPIO6,  GPIO_OUT, 0);\n\tmsleep(50);\n\tdib0700_set_gpio(adap->dev, GPIO6,  GPIO_OUT, 1);\n\tmsleep(100);  \n\n\t \n\tdib0700_set_gpio(adap->dev, GPIO10,  GPIO_OUT, 0);\n\tmsleep(1);  \n\tdib0700_set_gpio(adap->dev, GPIO10,  GPIO_OUT, 1);\n\n\t \n\tdib0700_set_gpio(adap->dev, GPIO8,  GPIO_OUT, 1);\n\n\t \n\tdib0700_set_gpio(adap->dev, GPIO2, GPIO_OUT, 1);\n\n\t \n\tdib0700_ctrl_clock(adap->dev, 72, 1);\n\n\tmsleep(500);\n\n\tif (state->dib7000p_ops.dib7000pc_detection(&adap->dev->i2c_adap) == 0) {\n\t\t \n\t\tdvb_detach(state->dib7000p_ops.set_wbd_ref);\n\t\treturn -ENODEV;\n\t}\n\n\tadap->fe_adap[0].fe = state->dib7000p_ops.init(&adap->dev->i2c_adap, 0x12,\n\t\t\t      &pctv_340e_config);\n\tst->is_dib7000pc = 1;\n\n\treturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\n}\n\nstatic struct xc4000_config dib7000p_xc4000_tunerconfig = {\n\t.i2c_address\t  = 0x61,\n\t.default_pm\t  = 1,\n\t.dvb_amplitude\t  = 0,\n\t.set_smoothedcvbs = 0,\n\t.if_khz\t\t  = 5400\n};\n\nstatic int xc4000_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct i2c_adapter *tun_i2c;\n\tstruct dib0700_adapter_state *state = adap->priv;\n\n\t \n\ttun_i2c = state->dib7000p_ops.get_i2c_master(adap->fe_adap[0].fe,\n\t\t\t\t\t  DIBX000_I2C_INTERFACE_TUNER, 1);\n\tif (tun_i2c == NULL) {\n\t\tprintk(KERN_ERR \"Could not reach tuner i2c bus\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tadap->fe_adap[0].fe->callback = dib0700_xc4000_tuner_callback;\n\n\treturn dvb_attach(xc4000_attach, adap->fe_adap[0].fe, tun_i2c,\n\t\t\t  &dib7000p_xc4000_tunerconfig)\n\t\t== NULL ? -ENODEV : 0;\n}\n\nstatic struct lgdt3305_config hcw_lgdt3305_config = {\n\t.i2c_addr           = 0x0e,\n\t.mpeg_mode          = LGDT3305_MPEG_PARALLEL,\n\t.tpclk_edge         = LGDT3305_TPCLK_FALLING_EDGE,\n\t.tpvalid_polarity   = LGDT3305_TP_VALID_LOW,\n\t.deny_i2c_rptr      = 0,\n\t.spectral_inversion = 1,\n\t.qam_if_khz         = 6000,\n\t.vsb_if_khz         = 6000,\n\t.usref_8vsb         = 0x0500,\n};\n\nstatic struct mxl5007t_config hcw_mxl5007t_config = {\n\t.xtal_freq_hz = MxL_XTAL_25_MHZ,\n\t.if_freq_hz = MxL_IF_6_MHZ,\n\t.invert_if = 1,\n};\n\n \nstatic int lgdt3305_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_state *st = adap->dev->priv;\n\n\t \n\tst->fw_use_new_i2c_api = 1;\n\n\tst->disable_streaming_master_mode = 1;\n\n\t \n\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0);\n\tmsleep(30);\n\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(30);\n\n\t \n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(30);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\tmsleep(30);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(30);\n\n\tadap->fe_adap[0].fe = dvb_attach(lgdt3305_attach,\n\t\t\t      &hcw_lgdt3305_config,\n\t\t\t      &adap->dev->i2c_adap);\n\n\treturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\n}\n\nstatic int mxl5007t_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\treturn dvb_attach(mxl5007t_attach, adap->fe_adap[0].fe,\n\t\t\t  &adap->dev->i2c_adap, 0x60,\n\t\t\t  &hcw_mxl5007t_config) == NULL ? -ENODEV : 0;\n}\n\nstatic int xbox_one_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_state *st = adap->dev->priv;\n\tstruct i2c_client *client_demod, *client_tuner;\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct mn88472_config mn88472_config = { };\n\tstruct tda18250_config tda18250_config;\n\tstruct i2c_board_info info;\n\n\tst->fw_use_new_i2c_api = 1;\n\tst->disable_streaming_master_mode = 1;\n\n\t \n\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0);\n\tmsleep(30);\n\tdib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);\n\tmsleep(30);\n\n\t \n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(30);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);\n\tmsleep(30);\n\tdib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);\n\tmsleep(30);\n\n\t \n\tmn88472_config.fe = &adap->fe_adap[0].fe;\n\tmn88472_config.i2c_wr_max = 22;\n\tmn88472_config.xtal = 20500000;\n\tmn88472_config.ts_mode = PARALLEL_TS_MODE;\n\tmn88472_config.ts_clock = FIXED_TS_CLOCK;\n\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\tstrscpy(info.type, \"mn88472\", I2C_NAME_SIZE);\n\tinfo.addr = 0x18;\n\tinfo.platform_data = &mn88472_config;\n\trequest_module(info.type);\n\tclient_demod = i2c_new_client_device(&d->i2c_adap, &info);\n\tif (!i2c_client_has_driver(client_demod))\n\t\tgoto fail_demod_device;\n\tif (!try_module_get(client_demod->dev.driver->owner))\n\t\tgoto fail_demod_module;\n\n\tst->i2c_client_demod = client_demod;\n\n\tadap->fe_adap[0].fe = mn88472_config.get_dvb_frontend(client_demod);\n\n\t \n\tmemset(&tda18250_config, 0, sizeof(tda18250_config));\n\ttda18250_config.if_dvbt_6 = 3950;\n\ttda18250_config.if_dvbt_7 = 4450;\n\ttda18250_config.if_dvbt_8 = 4950;\n\ttda18250_config.if_dvbc_6 = 4950;\n\ttda18250_config.if_dvbc_8 = 4950;\n\ttda18250_config.if_atsc = 4079;\n\ttda18250_config.loopthrough = true;\n\ttda18250_config.xtal_freq = TDA18250_XTAL_FREQ_27MHZ;\n\ttda18250_config.fe = adap->fe_adap[0].fe;\n\n\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\tstrscpy(info.type, \"tda18250\", I2C_NAME_SIZE);\n\tinfo.addr = 0x60;\n\tinfo.platform_data = &tda18250_config;\n\n\trequest_module(info.type);\n\tclient_tuner = i2c_new_client_device(&adap->dev->i2c_adap, &info);\n\tif (!i2c_client_has_driver(client_tuner))\n\t\tgoto fail_tuner_device;\n\tif (!try_module_get(client_tuner->dev.driver->owner))\n\t\tgoto fail_tuner_module;\n\n\tst->i2c_client_tuner = client_tuner;\n\treturn 0;\n\nfail_tuner_module:\n\ti2c_unregister_device(client_tuner);\nfail_tuner_device:\n\tmodule_put(client_demod->dev.driver->owner);\nfail_demod_module:\n\ti2c_unregister_device(client_demod);\nfail_demod_device:\n\treturn -ENODEV;\n}\n\n\n \nenum {\n\tDIBCOM_STK7700P,\n\tDIBCOM_STK7700P_PC,\n\tHAUPPAUGE_NOVA_T_500,\n\tHAUPPAUGE_NOVA_T_500_2,\n\tHAUPPAUGE_NOVA_T_STICK,\n\tAVERMEDIA_VOLAR,\n\tCOMPRO_VIDEOMATE_U500,\n\tUNIWILL_STK7700P,\n\tLEADTEK_WINFAST_DTV_DONGLE_STK7700P,\n\tHAUPPAUGE_NOVA_T_STICK_2,\n\tAVERMEDIA_VOLAR_2,\n\tPINNACLE_PCTV2000E,\n\tTERRATEC_CINERGY_DT_XS_DIVERSITY,\n\tHAUPPAUGE_NOVA_TD_STICK,\n\tDIBCOM_STK7700D,\n\tDIBCOM_STK7070P,\n\tPINNACLE_PCTV_DVB_T_FLASH,\n\tDIBCOM_STK7070PD,\n\tPINNACLE_PCTV_DUAL_DIVERSITY_DVB_T,\n\tCOMPRO_VIDEOMATE_U500_PC,\n\tAVERMEDIA_EXPRESS,\n\tGIGABYTE_U7000,\n\tULTIMA_ARTEC_T14BR,\n\tASUS_U3000,\n\tASUS_U3100,\n\tHAUPPAUGE_NOVA_T_STICK_3,\n\tHAUPPAUGE_MYTV_T,\n\tTERRATEC_CINERGY_HT_USB_XE,\n\tPINNACLE_EXPRESSCARD_320CX,\n\tPINNACLE_PCTV72E,\n\tPINNACLE_PCTV73E,\n\tYUAN_EC372S,\n\tTERRATEC_CINERGY_HT_EXPRESS,\n\tTERRATEC_CINERGY_T_XXS,\n\tLEADTEK_WINFAST_DTV_DONGLE_STK7700P_2,\n\tHAUPPAUGE_NOVA_TD_STICK_52009,\n\tHAUPPAUGE_NOVA_T_500_3,\n\tGIGABYTE_U8000,\n\tYUAN_STK7700PH,\n\tASUS_U3000H,\n\tPINNACLE_PCTV801E,\n\tPINNACLE_PCTV801E_SE,\n\tTERRATEC_CINERGY_T_EXPRESS,\n\tTERRATEC_CINERGY_DT_XS_DIVERSITY_2,\n\tSONY_PLAYTV,\n\tYUAN_PD378S,\n\tHAUPPAUGE_TIGER_ATSC,\n\tHAUPPAUGE_TIGER_ATSC_B210,\n\tYUAN_MC770,\n\tELGATO_EYETV_DTT,\n\tELGATO_EYETV_DTT_Dlx,\n\tLEADTEK_WINFAST_DTV_DONGLE_H,\n\tTERRATEC_T3,\n\tTERRATEC_T5,\n\tYUAN_STK7700D,\n\tYUAN_STK7700D_2,\n\tPINNACLE_PCTV73A,\n\tPCTV_PINNACLE_PCTV73ESE,\n\tPCTV_PINNACLE_PCTV282E,\n\tDIBCOM_STK7770P,\n\tTERRATEC_CINERGY_T_XXS_2,\n\tDIBCOM_STK807XPVR,\n\tDIBCOM_STK807XP,\n\tPIXELVIEW_SBTVD,\n\tEVOLUTEPC_TVWAY_PLUS,\n\tPINNACLE_PCTV73ESE,\n\tPINNACLE_PCTV282E,\n\tDIBCOM_STK8096GP,\n\tELGATO_EYETV_DIVERSITY,\n\tDIBCOM_NIM9090M,\n\tDIBCOM_NIM8096MD,\n\tDIBCOM_NIM9090MD,\n\tDIBCOM_NIM7090,\n\tDIBCOM_TFE7090PVR,\n\tTECHNISAT_AIRSTAR_TELESTICK_2,\n\tMEDION_CREATIX_CTX1921,\n\tPINNACLE_PCTV340E,\n\tPINNACLE_PCTV340E_SE,\n\tDIBCOM_TFE7790P,\n\tDIBCOM_TFE8096P,\n\tELGATO_EYETV_DTT_2,\n\tPCTV_2002E,\n\tPCTV_2002E_SE,\n\tPCTV_DIBCOM_STK8096PVR,\n\tDIBCOM_STK8096PVR,\n\tHAMA_DVBT_HYBRID,\n\tMICROSOFT_XBOX_ONE_TUNER,\n};\n\nstruct usb_device_id dib0700_usb_id_table[] = {\n\tDVB_USB_DEV(DIBCOM, DIBCOM_STK7700P),\n\tDVB_USB_DEV(DIBCOM, DIBCOM_STK7700P_PC),\n\tDVB_USB_DEV(HAUPPAUGE, HAUPPAUGE_NOVA_T_500),\n\tDVB_USB_DEV(HAUPPAUGE, HAUPPAUGE_NOVA_T_500_2),\n\tDVB_USB_DEV(HAUPPAUGE, HAUPPAUGE_NOVA_T_STICK),\n\tDVB_USB_DEV(AVERMEDIA, AVERMEDIA_VOLAR),\n\tDVB_USB_DEV(COMPRO, COMPRO_VIDEOMATE_U500),\n\tDVB_USB_DEV(UNIWILL, UNIWILL_STK7700P),\n\tDVB_USB_DEV(LEADTEK, LEADTEK_WINFAST_DTV_DONGLE_STK7700P),\n\tDVB_USB_DEV(HAUPPAUGE, HAUPPAUGE_NOVA_T_STICK_2),\n\tDVB_USB_DEV(AVERMEDIA, AVERMEDIA_VOLAR_2),\n\tDVB_USB_DEV(PINNACLE, PINNACLE_PCTV2000E),\n\tDVB_USB_DEV(TERRATEC, TERRATEC_CINERGY_DT_XS_DIVERSITY),\n\tDVB_USB_DEV(HAUPPAUGE, HAUPPAUGE_NOVA_TD_STICK),\n\tDVB_USB_DEV(DIBCOM, DIBCOM_STK7700D),\n\tDVB_USB_DEV(DIBCOM, DIBCOM_STK7070P),\n\tDVB_USB_DEV(PINNACLE, PINNACLE_PCTV_DVB_T_FLASH),\n\tDVB_USB_DEV(DIBCOM, DIBCOM_STK7070PD),\n\tDVB_USB_DEV(PINNACLE, PINNACLE_PCTV_DUAL_DIVERSITY_DVB_T),\n\tDVB_USB_DEV(COMPRO, COMPRO_VIDEOMATE_U500_PC),\n\tDVB_USB_DEV(AVERMEDIA, AVERMEDIA_EXPRESS),\n\tDVB_USB_DEV(GIGABYTE, GIGABYTE_U7000),\n\tDVB_USB_DEV(ULTIMA_ELECTRONIC, ULTIMA_ARTEC_T14BR),\n\tDVB_USB_DEV(ASUS, ASUS_U3000),\n\tDVB_USB_DEV(ASUS, ASUS_U3100),\n\tDVB_USB_DEV(HAUPPAUGE, HAUPPAUGE_NOVA_T_STICK_3),\n\tDVB_USB_DEV(HAUPPAUGE, HAUPPAUGE_MYTV_T),\n\tDVB_USB_DEV(TERRATEC, TERRATEC_CINERGY_HT_USB_XE),\n\tDVB_USB_DEV(PINNACLE, PINNACLE_EXPRESSCARD_320CX),\n\tDVB_USB_DEV(PINNACLE, PINNACLE_PCTV72E),\n\tDVB_USB_DEV(PINNACLE, PINNACLE_PCTV73E),\n\tDVB_USB_DEV(YUAN, YUAN_EC372S),\n\tDVB_USB_DEV(TERRATEC, TERRATEC_CINERGY_HT_EXPRESS),\n\tDVB_USB_DEV(TERRATEC, TERRATEC_CINERGY_T_XXS),\n\tDVB_USB_DEV(LEADTEK, LEADTEK_WINFAST_DTV_DONGLE_STK7700P_2),\n\tDVB_USB_DEV(HAUPPAUGE, HAUPPAUGE_NOVA_TD_STICK_52009),\n\tDVB_USB_DEV(HAUPPAUGE, HAUPPAUGE_NOVA_T_500_3),\n\tDVB_USB_DEV(GIGABYTE, GIGABYTE_U8000),\n\tDVB_USB_DEV(YUAN, YUAN_STK7700PH),\n\tDVB_USB_DEV(ASUS, ASUS_U3000H),\n\tDVB_USB_DEV(PINNACLE, PINNACLE_PCTV801E),\n\tDVB_USB_DEV(PINNACLE, PINNACLE_PCTV801E_SE),\n\tDVB_USB_DEV(TERRATEC, TERRATEC_CINERGY_T_EXPRESS),\n\tDVB_USB_DEV(TERRATEC, TERRATEC_CINERGY_DT_XS_DIVERSITY_2),\n\tDVB_USB_DEV(SONY, SONY_PLAYTV),\n\tDVB_USB_DEV(YUAN, YUAN_PD378S),\n\tDVB_USB_DEV(HAUPPAUGE, HAUPPAUGE_TIGER_ATSC),\n\tDVB_USB_DEV(HAUPPAUGE, HAUPPAUGE_TIGER_ATSC_B210),\n\tDVB_USB_DEV(YUAN, YUAN_MC770),\n\tDVB_USB_DEV(ELGATO, ELGATO_EYETV_DTT),\n\tDVB_USB_DEV(ELGATO, ELGATO_EYETV_DTT_Dlx),\n\tDVB_USB_DEV(LEADTEK, LEADTEK_WINFAST_DTV_DONGLE_H),\n\tDVB_USB_DEV(TERRATEC, TERRATEC_T3),\n\tDVB_USB_DEV(TERRATEC, TERRATEC_T5),\n\tDVB_USB_DEV(YUAN, YUAN_STK7700D),\n\tDVB_USB_DEV(YUAN, YUAN_STK7700D_2),\n\tDVB_USB_DEV(PINNACLE, PINNACLE_PCTV73A),\n\tDVB_USB_DEV(PCTV, PCTV_PINNACLE_PCTV73ESE),\n\tDVB_USB_DEV(PCTV, PCTV_PINNACLE_PCTV282E),\n\tDVB_USB_DEV(DIBCOM, DIBCOM_STK7770P),\n\tDVB_USB_DEV(TERRATEC, TERRATEC_CINERGY_T_XXS_2),\n\tDVB_USB_DEV(DIBCOM, DIBCOM_STK807XPVR),\n\tDVB_USB_DEV(DIBCOM, DIBCOM_STK807XP),\n\tDVB_USB_DEV_VER(PIXELVIEW, PIXELVIEW_SBTVD, 0x000, 0x3f00),\n\tDVB_USB_DEV(EVOLUTEPC, EVOLUTEPC_TVWAY_PLUS),\n\tDVB_USB_DEV(PINNACLE, PINNACLE_PCTV73ESE),\n\tDVB_USB_DEV(PINNACLE, PINNACLE_PCTV282E),\n\tDVB_USB_DEV(DIBCOM, DIBCOM_STK8096GP),\n\tDVB_USB_DEV(ELGATO, ELGATO_EYETV_DIVERSITY),\n\tDVB_USB_DEV(DIBCOM, DIBCOM_NIM9090M),\n\tDVB_USB_DEV(DIBCOM, DIBCOM_NIM8096MD),\n\tDVB_USB_DEV(DIBCOM, DIBCOM_NIM9090MD),\n\tDVB_USB_DEV(DIBCOM, DIBCOM_NIM7090),\n\tDVB_USB_DEV(DIBCOM, DIBCOM_TFE7090PVR),\n\tDVB_USB_DEV(TECHNISAT, TECHNISAT_AIRSTAR_TELESTICK_2),\n\tDVB_USB_DEV(MEDION, MEDION_CREATIX_CTX1921),\n\tDVB_USB_DEV(PINNACLE, PINNACLE_PCTV340E),\n\tDVB_USB_DEV(PINNACLE, PINNACLE_PCTV340E_SE),\n\tDVB_USB_DEV(DIBCOM, DIBCOM_TFE7790P),\n\tDVB_USB_DEV(DIBCOM, DIBCOM_TFE8096P),\n\tDVB_USB_DEV(ELGATO, ELGATO_EYETV_DTT_2),\n\tDVB_USB_DEV(PCTV, PCTV_2002E),\n\tDVB_USB_DEV(PCTV, PCTV_2002E_SE),\n\tDVB_USB_DEV(PCTV, PCTV_DIBCOM_STK8096PVR),\n\tDVB_USB_DEV(DIBCOM, DIBCOM_STK8096PVR),\n\tDVB_USB_DEV(HAMA, HAMA_DVBT_HYBRID),\n\tDVB_USB_DEV(MICROSOFT, MICROSOFT_XBOX_ONE_TUNER),\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, dib0700_usb_id_table);\n\n#define DIB0700_DEFAULT_DEVICE_PROPERTIES \\\n\t.caps              = DVB_USB_IS_AN_I2C_ADAPTER, \\\n\t.usb_ctrl          = DEVICE_SPECIFIC, \\\n\t.firmware          = \"dvb-usb-dib0700-1.20.fw\", \\\n\t.download_firmware = dib0700_download_firmware, \\\n\t.no_reconnect      = 1, \\\n\t.size_of_priv      = sizeof(struct dib0700_state), \\\n\t.i2c_algo          = &dib0700_i2c_algo, \\\n\t.identify_state    = dib0700_identify_state\n\n#define DIB0700_DEFAULT_STREAMING_CONFIG(ep) \\\n\t.streaming_ctrl   = dib0700_streaming_ctrl, \\\n\t.stream = { \\\n\t\t.type = USB_BULK, \\\n\t\t.count = 4, \\\n\t\t.endpoint = ep, \\\n\t\t.u = { \\\n\t\t\t.bulk = { \\\n\t\t\t\t.buffersize = 39480, \\\n\t\t\t} \\\n\t\t} \\\n\t}\n\n#define DIB0700_NUM_FRONTENDS(n) \\\n\t.num_frontends = n, \\\n\t.size_of_priv     = sizeof(struct dib0700_adapter_state)\n\nstruct dvb_usb_device_properties dib0700_devices[] = {\n\t{\n\t\tDIB0700_DEFAULT_DEVICE_PROPERTIES,\n\n\t\t.num_adapters = 1,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER | DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter       = stk7700p_pid_filter,\n\t\t\t\t.pid_filter_ctrl  = stk7700p_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = stk7700p_frontend_attach,\n\t\t\t\t.tuner_attach     = stk7700p_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t},\n\t\t},\n\n\t\t.num_device_descs = 8,\n\t\t.devices = {\n\t\t\t{   \"DiBcom STK7700P reference design\",\n\t\t\t\t{ &dib0700_usb_id_table[DIBCOM_STK7700P], &dib0700_usb_id_table[DIBCOM_STK7700P_PC] },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Hauppauge Nova-T Stick\",\n\t\t\t\t{ &dib0700_usb_id_table[HAUPPAUGE_NOVA_T_STICK], &dib0700_usb_id_table[HAUPPAUGE_NOVA_T_STICK_2], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"AVerMedia AVerTV DVB-T Volar\",\n\t\t\t\t{ &dib0700_usb_id_table[AVERMEDIA_VOLAR], &dib0700_usb_id_table[AVERMEDIA_VOLAR_2] },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Compro Videomate U500\",\n\t\t\t\t{ &dib0700_usb_id_table[COMPRO_VIDEOMATE_U500], &dib0700_usb_id_table[COMPRO_VIDEOMATE_U500_PC] },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Uniwill STK7700P based (Hama and others)\",\n\t\t\t\t{ &dib0700_usb_id_table[UNIWILL_STK7700P], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Leadtek Winfast DTV Dongle (STK7700P based)\",\n\t\t\t\t{ &dib0700_usb_id_table[LEADTEK_WINFAST_DTV_DONGLE_STK7700P], &dib0700_usb_id_table[LEADTEK_WINFAST_DTV_DONGLE_STK7700P_2] },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"AVerMedia AVerTV DVB-T Express\",\n\t\t\t\t{ &dib0700_usb_id_table[AVERMEDIA_EXPRESS] },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Gigabyte U7000\",\n\t\t\t\t{ &dib0700_usb_id_table[GIGABYTE_U7000], NULL },\n\t\t\t\t{ NULL },\n\t\t\t}\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol  = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\n\t\t.num_adapters = 2,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.frontend_attach  = bristol_frontend_attach,\n\t\t\t\t.tuner_attach     = bristol_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t}, {\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.frontend_attach  = bristol_frontend_attach,\n\t\t\t\t.tuner_attach     = bristol_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x03),\n\t\t\t}},\n\t\t\t}\n\t\t},\n\n\t\t.num_device_descs = 1,\n\t\t.devices = {\n\t\t\t{   \"Hauppauge Nova-T 500 Dual DVB-T\",\n\t\t\t\t{ &dib0700_usb_id_table[HAUPPAUGE_NOVA_T_500], &dib0700_usb_id_table[HAUPPAUGE_NOVA_T_500_2], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\n\t\t.num_adapters = 2,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER | DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter       = stk70x0p_pid_filter,\n\t\t\t\t.pid_filter_ctrl  = stk70x0p_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = stk7700d_frontend_attach,\n\t\t\t\t.tuner_attach     = stk7700d_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t}, {\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER | DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter       = stk70x0p_pid_filter,\n\t\t\t\t.pid_filter_ctrl  = stk70x0p_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = stk7700d_frontend_attach,\n\t\t\t\t.tuner_attach     = stk7700d_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x03),\n\t\t\t}},\n\t\t\t}\n\t\t},\n\n\t\t.num_device_descs = 5,\n\t\t.devices = {\n\t\t\t{   \"Pinnacle PCTV 2000e\",\n\t\t\t\t{ &dib0700_usb_id_table[PINNACLE_PCTV2000E], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Terratec Cinergy DT XS Diversity\",\n\t\t\t\t{ &dib0700_usb_id_table[TERRATEC_CINERGY_DT_XS_DIVERSITY], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Hauppauge Nova-TD Stick/Elgato Eye-TV Diversity\",\n\t\t\t\t{ &dib0700_usb_id_table[HAUPPAUGE_NOVA_TD_STICK], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"DiBcom STK7700D reference design\",\n\t\t\t\t{ &dib0700_usb_id_table[DIBCOM_STK7700D], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"YUAN High-Tech DiBcom STK7700D\",\n\t\t\t\t{ &dib0700_usb_id_table[YUAN_STK7700D_2], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\n\t\t.num_adapters = 1,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER | DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter       = stk70x0p_pid_filter,\n\t\t\t\t.pid_filter_ctrl  = stk70x0p_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = stk7700P2_frontend_attach,\n\t\t\t\t.tuner_attach     = stk7700d_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t},\n\t\t},\n\n\t\t.num_device_descs = 3,\n\t\t.devices = {\n\t\t\t{   \"ASUS My Cinema U3000 Mini DVBT Tuner\",\n\t\t\t\t{ &dib0700_usb_id_table[ASUS_U3000], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Yuan EC372S\",\n\t\t\t\t{ &dib0700_usb_id_table[YUAN_EC372S], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Terratec Cinergy T Express\",\n\t\t\t\t{ &dib0700_usb_id_table[TERRATEC_CINERGY_T_EXPRESS], NULL },\n\t\t\t\t{ NULL },\n\t\t\t}\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.module_name\t  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\n\t\t.num_adapters = 1,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER | DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter       = stk70x0p_pid_filter,\n\t\t\t\t.pid_filter_ctrl  = stk70x0p_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = stk7070p_frontend_attach,\n\t\t\t\t.tuner_attach     = dib7070p_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t},\n\t\t},\n\n\t\t.num_device_descs = 12,\n\t\t.devices = {\n\t\t\t{   \"DiBcom STK7070P reference design\",\n\t\t\t\t{ &dib0700_usb_id_table[DIBCOM_STK7070P], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Pinnacle PCTV DVB-T Flash Stick\",\n\t\t\t\t{ &dib0700_usb_id_table[PINNACLE_PCTV_DVB_T_FLASH], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Artec T14BR DVB-T\",\n\t\t\t\t{ &dib0700_usb_id_table[ULTIMA_ARTEC_T14BR], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"ASUS My Cinema U3100 Mini DVBT Tuner\",\n\t\t\t\t{ &dib0700_usb_id_table[ASUS_U3100], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Hauppauge Nova-T Stick\",\n\t\t\t\t{ &dib0700_usb_id_table[HAUPPAUGE_NOVA_T_STICK_3], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Hauppauge Nova-T MyTV.t\",\n\t\t\t\t{ &dib0700_usb_id_table[HAUPPAUGE_MYTV_T], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Pinnacle PCTV 72e\",\n\t\t\t\t{ &dib0700_usb_id_table[PINNACLE_PCTV72E], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Pinnacle PCTV 73e\",\n\t\t\t\t{ &dib0700_usb_id_table[PINNACLE_PCTV73E], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Elgato EyeTV DTT\",\n\t\t\t\t{ &dib0700_usb_id_table[ELGATO_EYETV_DTT], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Yuan PD378S\",\n\t\t\t\t{ &dib0700_usb_id_table[YUAN_PD378S], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Elgato EyeTV Dtt Dlx PD378S\",\n\t\t\t\t{ &dib0700_usb_id_table[ELGATO_EYETV_DTT_Dlx], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Elgato EyeTV DTT rev. 2\",\n\t\t\t\t{ &dib0700_usb_id_table[ELGATO_EYETV_DTT_2], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.module_name\t  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol  = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\n\t\t.num_adapters = 1,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER | DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter       = stk70x0p_pid_filter,\n\t\t\t\t.pid_filter_ctrl  = stk70x0p_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = stk7070p_frontend_attach,\n\t\t\t\t.tuner_attach     = dib7070p_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t},\n\t\t},\n\n\t\t.num_device_descs = 3,\n\t\t.devices = {\n\t\t\t{   \"Pinnacle PCTV 73A\",\n\t\t\t\t{ &dib0700_usb_id_table[PINNACLE_PCTV73A], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Pinnacle PCTV 73e SE\",\n\t\t\t\t{ &dib0700_usb_id_table[PCTV_PINNACLE_PCTV73ESE], &dib0700_usb_id_table[PINNACLE_PCTV73ESE], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Pinnacle PCTV 282e\",\n\t\t\t\t{ &dib0700_usb_id_table[PCTV_PINNACLE_PCTV282E], &dib0700_usb_id_table[PINNACLE_PCTV282E], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.module_name\t  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol  = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\n\t\t.num_adapters = 2,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER | DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter       = stk70x0p_pid_filter,\n\t\t\t\t.pid_filter_ctrl  = stk70x0p_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = novatd_frontend_attach,\n\t\t\t\t.tuner_attach     = dib7070p_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t}, {\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER | DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter       = stk70x0p_pid_filter,\n\t\t\t\t.pid_filter_ctrl  = stk70x0p_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = novatd_frontend_attach,\n\t\t\t\t.tuner_attach     = dib7070p_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x03),\n\t\t\t}},\n\t\t\t}\n\t\t},\n\n\t\t.num_device_descs = 3,\n\t\t.devices = {\n\t\t\t{   \"Hauppauge Nova-TD Stick (52009)\",\n\t\t\t\t{ &dib0700_usb_id_table[HAUPPAUGE_NOVA_TD_STICK_52009], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"PCTV 2002e\",\n\t\t\t\t{ &dib0700_usb_id_table[PCTV_2002E], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"PCTV 2002e SE\",\n\t\t\t\t{ &dib0700_usb_id_table[PCTV_2002E_SE], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.module_name\t  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\n\t\t.num_adapters = 2,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER | DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter       = stk70x0p_pid_filter,\n\t\t\t\t.pid_filter_ctrl  = stk70x0p_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = stk7070pd_frontend_attach0,\n\t\t\t\t.tuner_attach     = dib7070p_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t}, {\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER | DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter       = stk70x0p_pid_filter,\n\t\t\t\t.pid_filter_ctrl  = stk70x0p_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = stk7070pd_frontend_attach1,\n\t\t\t\t.tuner_attach     = dib7070p_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x03),\n\t\t\t}},\n\t\t\t}\n\t\t},\n\n\t\t.num_device_descs = 5,\n\t\t.devices = {\n\t\t\t{   \"DiBcom STK7070PD reference design\",\n\t\t\t\t{ &dib0700_usb_id_table[DIBCOM_STK7070PD], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Pinnacle PCTV Dual DVB-T Diversity Stick\",\n\t\t\t\t{ &dib0700_usb_id_table[PINNACLE_PCTV_DUAL_DIVERSITY_DVB_T], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Hauppauge Nova-TD-500 (84xxx)\",\n\t\t\t\t{ &dib0700_usb_id_table[HAUPPAUGE_NOVA_T_500_3], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{  \"Terratec Cinergy DT USB XS Diversity/ T5\",\n\t\t\t\t{ &dib0700_usb_id_table[TERRATEC_CINERGY_DT_XS_DIVERSITY_2],\n\t\t\t\t\t&dib0700_usb_id_table[TERRATEC_T5], NULL},\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{  \"Sony PlayTV\",\n\t\t\t\t{ &dib0700_usb_id_table[SONY_PLAYTV], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.module_name\t  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\n\t\t.num_adapters = 2,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER | DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter       = stk70x0p_pid_filter,\n\t\t\t\t.pid_filter_ctrl  = stk70x0p_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = stk7070pd_frontend_attach0,\n\t\t\t\t.tuner_attach     = dib7070p_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t}, {\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER | DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter       = stk70x0p_pid_filter,\n\t\t\t\t.pid_filter_ctrl  = stk70x0p_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = stk7070pd_frontend_attach1,\n\t\t\t\t.tuner_attach     = dib7070p_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x03),\n\t\t\t}},\n\t\t\t}\n\t\t},\n\n\t\t.num_device_descs = 1,\n\t\t.devices = {\n\t\t\t{   \"Elgato EyeTV Diversity\",\n\t\t\t\t{ &dib0700_usb_id_table[ELGATO_EYETV_DIVERSITY], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_NEC_TABLE,\n\t\t\t.module_name\t  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol  = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\n\t\t.num_adapters = 1,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER | DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter       = stk70x0p_pid_filter,\n\t\t\t\t.pid_filter_ctrl  = stk70x0p_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = stk7700ph_frontend_attach,\n\t\t\t\t.tuner_attach     = stk7700ph_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t},\n\t\t},\n\n\t\t.num_device_descs = 10,\n\t\t.devices = {\n\t\t\t{   \"Terratec Cinergy HT USB XE\",\n\t\t\t\t{ &dib0700_usb_id_table[TERRATEC_CINERGY_HT_USB_XE], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Pinnacle Expresscard 320cx\",\n\t\t\t\t{ &dib0700_usb_id_table[PINNACLE_EXPRESSCARD_320CX], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Terratec Cinergy HT Express\",\n\t\t\t\t{ &dib0700_usb_id_table[TERRATEC_CINERGY_HT_EXPRESS], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Gigabyte U8000-RH\",\n\t\t\t\t{ &dib0700_usb_id_table[GIGABYTE_U8000], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"YUAN High-Tech STK7700PH\",\n\t\t\t\t{ &dib0700_usb_id_table[YUAN_STK7700PH], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Asus My Cinema-U3000Hybrid\",\n\t\t\t\t{ &dib0700_usb_id_table[ASUS_U3000H], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"YUAN High-Tech MC770\",\n\t\t\t\t{ &dib0700_usb_id_table[YUAN_MC770], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Leadtek WinFast DTV Dongle H\",\n\t\t\t\t{ &dib0700_usb_id_table[LEADTEK_WINFAST_DTV_DONGLE_H], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"YUAN High-Tech STK7700D\",\n\t\t\t\t{ &dib0700_usb_id_table[YUAN_STK7700D], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Hama DVB=T Hybrid USB Stick\",\n\t\t\t\t{ &dib0700_usb_id_table[HAMA_DVBT_HYBRID], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.module_name\t  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol  = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\t\t.num_adapters = 1,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.frontend_attach  = s5h1411_frontend_attach,\n\t\t\t\t.tuner_attach     = xc5000_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t},\n\t\t},\n\n\t\t.num_device_descs = 2,\n\t\t.devices = {\n\t\t\t{   \"Pinnacle PCTV HD Pro USB Stick\",\n\t\t\t\t{ &dib0700_usb_id_table[PINNACLE_PCTV801E], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Pinnacle PCTV HD USB Stick\",\n\t\t\t\t{ &dib0700_usb_id_table[PINNACLE_PCTV801E_SE], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.module_name\t  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol  = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\t\t.num_adapters = 1,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.frontend_attach  = lgdt3305_frontend_attach,\n\t\t\t\t.tuner_attach     = mxl5007t_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t},\n\t\t},\n\n\t\t.num_device_descs = 2,\n\t\t.devices = {\n\t\t\t{   \"Hauppauge ATSC MiniCard (B200)\",\n\t\t\t\t{ &dib0700_usb_id_table[HAUPPAUGE_TIGER_ATSC], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Hauppauge ATSC MiniCard (B210)\",\n\t\t\t\t{ &dib0700_usb_id_table[HAUPPAUGE_TIGER_ATSC_B210], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\n\t\t.num_adapters = 1,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER | DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter       = stk70x0p_pid_filter,\n\t\t\t\t.pid_filter_ctrl  = stk70x0p_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = stk7770p_frontend_attach,\n\t\t\t\t.tuner_attach     = dib7770p_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t},\n\t\t},\n\n\t\t.num_device_descs = 4,\n\t\t.devices = {\n\t\t\t{   \"DiBcom STK7770P reference design\",\n\t\t\t\t{ &dib0700_usb_id_table[DIBCOM_STK7770P], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Terratec Cinergy T USB XXS (HD)/ T3\",\n\t\t\t\t{ &dib0700_usb_id_table[TERRATEC_CINERGY_T_XXS],\n\t\t\t\t\t&dib0700_usb_id_table[TERRATEC_T3],\n\t\t\t\t\t&dib0700_usb_id_table[TERRATEC_CINERGY_T_XXS_2], NULL},\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"TechniSat AirStar TeleStick 2\",\n\t\t\t\t{ &dib0700_usb_id_table[TECHNISAT_AIRSTAR_TELESTICK_2], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Medion CTX1921 DVB-T USB\",\n\t\t\t\t{ &dib0700_usb_id_table[MEDION_CREATIX_CTX1921], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.module_name\t  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol  = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\t\t.num_adapters = 1,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps  = DVB_USB_ADAP_HAS_PID_FILTER | DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter = stk80xx_pid_filter,\n\t\t\t\t.pid_filter_ctrl = stk80xx_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = stk807x_frontend_attach,\n\t\t\t\t.tuner_attach     = dib807x_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t},\n\t\t},\n\n\t\t.num_device_descs = 3,\n\t\t.devices = {\n\t\t\t{   \"DiBcom STK807xP reference design\",\n\t\t\t\t{ &dib0700_usb_id_table[DIBCOM_STK807XP], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Prolink Pixelview SBTVD\",\n\t\t\t\t{ &dib0700_usb_id_table[PIXELVIEW_SBTVD], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"EvolutePC TVWay+\",\n\t\t\t\t{ &dib0700_usb_id_table[EVOLUTEPC_TVWAY_PLUS], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_NEC_TABLE,\n\t\t\t.module_name\t  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol  = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\t\t.num_adapters = 2,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps  = DVB_USB_ADAP_HAS_PID_FILTER | DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter = stk80xx_pid_filter,\n\t\t\t\t.pid_filter_ctrl = stk80xx_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = stk807xpvr_frontend_attach0,\n\t\t\t\t.tuner_attach     = dib807x_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t},\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps  = DVB_USB_ADAP_HAS_PID_FILTER | DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter = stk80xx_pid_filter,\n\t\t\t\t.pid_filter_ctrl = stk80xx_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = stk807xpvr_frontend_attach1,\n\t\t\t\t.tuner_attach     = dib807x_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x03),\n\t\t\t}},\n\t\t\t},\n\t\t},\n\n\t\t.num_device_descs = 1,\n\t\t.devices = {\n\t\t\t{   \"DiBcom STK807xPVR reference design\",\n\t\t\t\t{ &dib0700_usb_id_table[DIBCOM_STK807XPVR], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.module_name\t  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol  = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\t\t.num_adapters = 1,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps  = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter = stk80xx_pid_filter,\n\t\t\t\t.pid_filter_ctrl = stk80xx_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = stk809x_frontend_attach,\n\t\t\t\t.tuner_attach     = dib809x_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t},\n\t\t},\n\n\t\t.num_device_descs = 1,\n\t\t.devices = {\n\t\t\t{   \"DiBcom STK8096GP reference design\",\n\t\t\t\t{ &dib0700_usb_id_table[DIBCOM_STK8096GP], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.module_name\t  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol  = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\t\t.num_adapters = 1,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps  = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter = dib90x0_pid_filter,\n\t\t\t\t.pid_filter_ctrl = dib90x0_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = stk9090m_frontend_attach,\n\t\t\t\t.tuner_attach     = dib9090_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t},\n\t\t},\n\n\t\t.num_device_descs = 1,\n\t\t.devices = {\n\t\t\t{   \"DiBcom STK9090M reference design\",\n\t\t\t\t{ &dib0700_usb_id_table[DIBCOM_NIM9090M], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.module_name\t  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol  = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\t\t.num_adapters = 1,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps  = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter = stk80xx_pid_filter,\n\t\t\t\t.pid_filter_ctrl = stk80xx_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = nim8096md_frontend_attach,\n\t\t\t\t.tuner_attach     = nim8096md_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t},\n\t\t},\n\n\t\t.num_device_descs = 1,\n\t\t.devices = {\n\t\t\t{   \"DiBcom NIM8096MD reference design\",\n\t\t\t\t{ &dib0700_usb_id_table[DIBCOM_NIM8096MD], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.module_name\t  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol  = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\t\t.num_adapters = 1,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps  = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter = dib90x0_pid_filter,\n\t\t\t\t.pid_filter_ctrl = dib90x0_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = nim9090md_frontend_attach,\n\t\t\t\t.tuner_attach     = nim9090md_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t},\n\t\t},\n\n\t\t.num_device_descs = 1,\n\t\t.devices = {\n\t\t\t{   \"DiBcom NIM9090MD reference design\",\n\t\t\t\t{ &dib0700_usb_id_table[DIBCOM_NIM9090MD], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.module_name\t  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol  = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\t\t.num_adapters = 1,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps  = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter = stk70x0p_pid_filter,\n\t\t\t\t.pid_filter_ctrl = stk70x0p_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = nim7090_frontend_attach,\n\t\t\t\t.tuner_attach     = nim7090_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t},\n\t\t},\n\n\t\t.num_device_descs = 1,\n\t\t.devices = {\n\t\t\t{   \"DiBcom NIM7090 reference design\",\n\t\t\t\t{ &dib0700_usb_id_table[DIBCOM_NIM7090], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.module_name\t  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol  = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\t\t.num_adapters = 2,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps  = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter = stk70x0p_pid_filter,\n\t\t\t\t.pid_filter_ctrl = stk70x0p_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = tfe7090pvr_frontend0_attach,\n\t\t\t\t.tuner_attach     = tfe7090pvr_tuner0_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x03),\n\t\t\t}},\n\t\t\t},\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.caps  = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t.pid_filter = stk70x0p_pid_filter,\n\t\t\t\t.pid_filter_ctrl = stk70x0p_pid_filter_ctrl,\n\t\t\t\t.frontend_attach  = tfe7090pvr_frontend1_attach,\n\t\t\t\t.tuner_attach     = tfe7090pvr_tuner1_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t},\n\t\t},\n\n\t\t.num_device_descs = 1,\n\t\t.devices = {\n\t\t\t{   \"DiBcom TFE7090PVR reference design\",\n\t\t\t\t{ &dib0700_usb_id_table[DIBCOM_TFE7090PVR], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.module_name\t  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol  = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\t\t.num_adapters = 1,\n\t\t.adapter = {\n\t\t\t{\n\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t.fe = {{\n\t\t\t\t.frontend_attach  = pctv340e_frontend_attach,\n\t\t\t\t.tuner_attach     = xc4000_tuner_attach,\n\n\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t}},\n\t\t\t},\n\t\t},\n\n\t\t.num_device_descs = 2,\n\t\t.devices = {\n\t\t\t{   \"Pinnacle PCTV 340e HD Pro USB Stick\",\n\t\t\t\t{ &dib0700_usb_id_table[PINNACLE_PCTV340E], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t\t{   \"Pinnacle PCTV Hybrid Stick Solo\",\n\t\t\t\t{ &dib0700_usb_id_table[PINNACLE_PCTV340E_SE], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.module_name\t  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol  = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\t\t.num_adapters = 1,\n\t\t.adapter = {\n\t\t\t{\n\t\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t\t.fe = {{\n\t\t\t\t\t.caps  = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\t\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t\t.pid_filter = stk70x0p_pid_filter,\n\t\t\t\t\t.pid_filter_ctrl = stk70x0p_pid_filter_ctrl,\n\t\t\t\t\t.frontend_attach  = tfe7790p_frontend_attach,\n\t\t\t\t\t.tuner_attach     = tfe7790p_tuner_attach,\n\n\t\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x03),\n\t\t\t\t} },\n\t\t\t},\n\t\t},\n\n\t\t.num_device_descs = 1,\n\t\t.devices = {\n\t\t\t{   \"DiBcom TFE7790P reference design\",\n\t\t\t\t{ &dib0700_usb_id_table[DIBCOM_TFE7790P], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.module_name\t  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol  = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\t\t.num_adapters = 1,\n\t\t.adapter = {\n\t\t\t{\n\t\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t\t.fe = {{\n\t\t\t\t\t.caps  = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\t\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t\t.pid_filter = stk80xx_pid_filter,\n\t\t\t\t\t.pid_filter_ctrl = stk80xx_pid_filter_ctrl,\n\t\t\t\t\t.frontend_attach  = tfe8096p_frontend_attach,\n\t\t\t\t\t.tuner_attach     = tfe8096p_tuner_attach,\n\n\t\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\n\t\t\t\t} },\n\t\t\t},\n\t\t},\n\n\t\t.num_device_descs = 1,\n\t\t.devices = {\n\t\t\t{   \"DiBcom TFE8096P reference design\",\n\t\t\t\t{ &dib0700_usb_id_table[DIBCOM_TFE8096P], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.module_name\t  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t    RC_PROTO_BIT_RC6_MCE |\n\t\t\t\t\t    RC_PROTO_BIT_NEC,\n\t\t\t.change_protocol  = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\t\t.num_adapters = 2,\n\t\t.adapter = {\n\t\t\t{\n\t\t\t\t.num_frontends = 1,\n\t\t\t\t.fe = {{\n\t\t\t\t\t.caps  = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\t\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t\t.pid_filter = stk80xx_pid_filter,\n\t\t\t\t\t.pid_filter_ctrl = stk80xx_pid_filter_ctrl,\n\t\t\t\t\t.frontend_attach  = stk809x_frontend_attach,\n\t\t\t\t\t.tuner_attach     = dib809x_tuner_attach,\n\n\t\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x02),\n\t\t\t\t} },\n\t\t\t\t.size_of_priv =\n\t\t\t\t\tsizeof(struct dib0700_adapter_state),\n\t\t\t}, {\n\t\t\t\t.num_frontends = 1,\n\t\t\t\t.fe = { {\n\t\t\t\t\t.caps  = DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t\t\t\t\tDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t\t\t.pid_filter_count = 32,\n\t\t\t\t\t.pid_filter = stk80xx_pid_filter,\n\t\t\t\t\t.pid_filter_ctrl = stk80xx_pid_filter_ctrl,\n\t\t\t\t\t.frontend_attach  = stk809x_frontend1_attach,\n\t\t\t\t\t.tuner_attach     = dib809x_tuner_attach,\n\n\t\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x03),\n\t\t\t\t} },\n\t\t\t\t.size_of_priv =\n\t\t\t\t\tsizeof(struct dib0700_adapter_state),\n\t\t\t},\n\t\t},\n\t\t.num_device_descs = 1,\n\t\t.devices = {\n\t\t\t{   \"DiBcom STK8096-PVR reference design\",\n\t\t\t\t{ &dib0700_usb_id_table[PCTV_DIBCOM_STK8096PVR],\n\t\t\t\t\t&dib0700_usb_id_table[DIBCOM_STK8096PVR], NULL},\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\n\t\t.rc.core = {\n\t\t\t.rc_interval      = DEFAULT_RC_INTERVAL,\n\t\t\t.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,\n\t\t\t.module_name  = \"dib0700\",\n\t\t\t.rc_query         = dib0700_rc_query_old_firmware,\n\t\t\t.allowed_protos   = RC_PROTO_BIT_RC5 |\n\t\t\t\tRC_PROTO_BIT_RC6_MCE |\n\t\t\t\tRC_PROTO_BIT_NEC,\n\t\t\t.change_protocol  = dib0700_change_protocol,\n\t\t},\n\t}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,\n\t\t.num_adapters = 1,\n\t\t.adapter = {\n\t\t\t{\n\t\t\t\tDIB0700_NUM_FRONTENDS(1),\n\t\t\t\t.fe = {{\n\t\t\t\t\t.frontend_attach = xbox_one_attach,\n\n\t\t\t\t\tDIB0700_DEFAULT_STREAMING_CONFIG(0x82),\n\t\t\t\t} },\n\t\t\t},\n\t\t},\n\t\t.num_device_descs = 1,\n\t\t.devices = {\n\t\t\t{ \"Microsoft Xbox One Digital TV Tuner\",\n\t\t\t\t{ &dib0700_usb_id_table[MICROSOFT_XBOX_ONE_TUNER], NULL },\n\t\t\t\t{ NULL },\n\t\t\t},\n\t\t},\n\t},\n};\n\nint dib0700_device_count = ARRAY_SIZE(dib0700_devices);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}