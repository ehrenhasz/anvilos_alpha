{
  "module_name": "cinergyT2-core.c",
  "hash_id": "135628dbe9542ef90301dce1f544ff7c7a0a7211b489a2f50a692c9836f09923",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/cinergyT2-core.c",
  "human_readable_source": "\n \n\n#include \"cinergyT2.h\"\n\n\n \nint dvb_usb_cinergyt2_debug;\n\nmodule_param_named(debug, dvb_usb_cinergyt2_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=info, xfer=2, rc=4 (or-able)).\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstruct cinergyt2_state {\n\tu8 rc_counter;\n\tunsigned char data[64];\n};\n\n \nstatic const struct dvb_usb_device_properties cinergyt2_properties;\n\nstatic int cinergyt2_streaming_ctrl(struct dvb_usb_adapter *adap, int enable)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct cinergyt2_state *st = d->priv;\n\tint ret;\n\n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = CINERGYT2_EP1_CONTROL_STREAM_TRANSFER;\n\tst->data[1] = enable ? 1 : 0;\n\n\tret = dvb_usb_generic_rw(d, st->data, 2, st->data, 64, 0);\n\tmutex_unlock(&d->data_mutex);\n\n\treturn ret;\n}\n\nstatic int cinergyt2_power_ctrl(struct dvb_usb_device *d, int enable)\n{\n\tstruct cinergyt2_state *st = d->priv;\n\tint ret;\n\n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = CINERGYT2_EP1_SLEEP_MODE;\n\tst->data[1] = enable ? 0 : 1;\n\n\tret = dvb_usb_generic_rw(d, st->data, 2, st->data, 3, 0);\n\tmutex_unlock(&d->data_mutex);\n\n\treturn ret;\n}\n\nstatic int cinergyt2_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct cinergyt2_state *st = d->priv;\n\tint ret;\n\n\tadap->fe_adap[0].fe = cinergyt2_fe_attach(adap->dev);\n\n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = CINERGYT2_EP1_GET_FIRMWARE_VERSION;\n\n\tret = dvb_usb_generic_rw(d, st->data, 1, st->data, 3, 0);\n\tif (ret < 0) {\n\t\tif (adap->fe_adap[0].fe)\n\t\t\tadap->fe_adap[0].fe->ops.release(adap->fe_adap[0].fe);\n\t\tdeb_rc(\"cinergyt2_power_ctrl() Failed to retrieve sleep state info\\n\");\n\t}\n\tmutex_unlock(&d->data_mutex);\n\n\treturn ret;\n}\n\nstatic struct rc_map_table rc_map_cinergyt2_table[] = {\n\t{ 0x0401, KEY_POWER },\n\t{ 0x0402, KEY_1 },\n\t{ 0x0403, KEY_2 },\n\t{ 0x0404, KEY_3 },\n\t{ 0x0405, KEY_4 },\n\t{ 0x0406, KEY_5 },\n\t{ 0x0407, KEY_6 },\n\t{ 0x0408, KEY_7 },\n\t{ 0x0409, KEY_8 },\n\t{ 0x040a, KEY_9 },\n\t{ 0x040c, KEY_0 },\n\t{ 0x040b, KEY_VIDEO },\n\t{ 0x040d, KEY_REFRESH },\n\t{ 0x040e, KEY_SELECT },\n\t{ 0x040f, KEY_EPG },\n\t{ 0x0410, KEY_UP },\n\t{ 0x0414, KEY_DOWN },\n\t{ 0x0411, KEY_LEFT },\n\t{ 0x0413, KEY_RIGHT },\n\t{ 0x0412, KEY_OK },\n\t{ 0x0415, KEY_TEXT },\n\t{ 0x0416, KEY_INFO },\n\t{ 0x0417, KEY_RED },\n\t{ 0x0418, KEY_GREEN },\n\t{ 0x0419, KEY_YELLOW },\n\t{ 0x041a, KEY_BLUE },\n\t{ 0x041c, KEY_VOLUMEUP },\n\t{ 0x041e, KEY_VOLUMEDOWN },\n\t{ 0x041d, KEY_MUTE },\n\t{ 0x041b, KEY_CHANNELUP },\n\t{ 0x041f, KEY_CHANNELDOWN },\n\t{ 0x0440, KEY_PAUSE },\n\t{ 0x044c, KEY_PLAY },\n\t{ 0x0458, KEY_RECORD },\n\t{ 0x0454, KEY_PREVIOUS },\n\t{ 0x0448, KEY_STOP },\n\t{ 0x045c, KEY_NEXT }\n};\n\n \n#define RC_REPEAT_DELAY 3\n\nstatic int repeatable_keys[] = {\n\tKEY_UP,\n\tKEY_DOWN,\n\tKEY_LEFT,\n\tKEY_RIGHT,\n\tKEY_VOLUMEUP,\n\tKEY_VOLUMEDOWN,\n\tKEY_CHANNELUP,\n\tKEY_CHANNELDOWN\n};\n\nstatic int cinergyt2_rc_query(struct dvb_usb_device *d, u32 *event, int *state)\n{\n\tstruct cinergyt2_state *st = d->priv;\n\tint i, ret;\n\n\t*state = REMOTE_NO_KEY_PRESSED;\n\n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = CINERGYT2_EP1_GET_RC_EVENTS;\n\n\tret = dvb_usb_generic_rw(d, st->data, 1, st->data, 5, 0);\n\tif (ret < 0)\n\t\tgoto ret;\n\n\tif (st->data[4] == 0xff) {\n\t\t \n\t\tst->rc_counter++;\n\t\tif (st->rc_counter > RC_REPEAT_DELAY) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(repeatable_keys); i++) {\n\t\t\t\tif (d->last_event == repeatable_keys[i]) {\n\t\t\t\t\t*state = REMOTE_KEY_REPEAT;\n\t\t\t\t\t*event = d->last_event;\n\t\t\t\t\tdeb_rc(\"repeat key, event %x\\n\",\n\t\t\t\t\t\t   *event);\n\t\t\t\t\tgoto ret;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeb_rc(\"repeated key (non repeatable)\\n\");\n\t\t}\n\t\tgoto ret;\n\t}\n\n\t \n\tst->data[2] = ~st->data[1];\n\tdvb_usb_nec_rc_key_to_event(d, st->data, event, state);\n\tif (st->data[0] != 0) {\n\t\tif (*event != d->last_event)\n\t\t\tst->rc_counter = 0;\n\n\t\tdeb_rc(\"key: %*ph\\n\", 5, st->data);\n\t}\n\nret:\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n}\n\nstatic int cinergyt2_usb_probe(struct usb_interface *intf,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\treturn dvb_usb_device_init(intf, &cinergyt2_properties,\n\t\t\t\t   THIS_MODULE, NULL, adapter_nr);\n}\n\nenum {\n\tTERRATEC_CINERGY_T2,\n};\n\nstatic struct usb_device_id cinergyt2_usb_table[] = {\n\tDVB_USB_DEV(TERRATEC, TERRATEC_CINERGY_T2),\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, cinergyt2_usb_table);\n\nstatic const struct dvb_usb_device_properties cinergyt2_properties = {\n\t.size_of_priv = sizeof(struct cinergyt2_state),\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = cinergyt2_streaming_ctrl,\n\t\t\t.frontend_attach  = cinergyt2_frontend_attach,\n\n\t\t\t \n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 512,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t}\n\t},\n\n\t.power_ctrl       = cinergyt2_power_ctrl,\n\n\t.rc.legacy = {\n\t\t.rc_interval      = 50,\n\t\t.rc_map_table     = rc_map_cinergyt2_table,\n\t\t.rc_map_size      = ARRAY_SIZE(rc_map_cinergyt2_table),\n\t\t.rc_query         = cinergyt2_rc_query,\n\t},\n\n\t.generic_bulk_ctrl_endpoint = 1,\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{ .name = \"TerraTec/qanu USB2.0 Highspeed DVB-T Receiver\",\n\t\t  .cold_ids = {NULL},\n\t\t  .warm_ids = { &cinergyt2_usb_table[TERRATEC_CINERGY_T2], NULL },\n\t\t},\n\t\t{ NULL },\n\t}\n};\n\n\nstatic struct usb_driver cinergyt2_driver = {\n\t.name\t\t= \"cinergyT2\",\n\t.probe\t\t= cinergyt2_usb_probe,\n\t.disconnect\t= dvb_usb_device_exit,\n\t.id_table\t= cinergyt2_usb_table\n};\n\nmodule_usb_driver(cinergyt2_driver);\n\nMODULE_DESCRIPTION(\"Terratec Cinergy T2 DVB-T driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Tomi Orava\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}