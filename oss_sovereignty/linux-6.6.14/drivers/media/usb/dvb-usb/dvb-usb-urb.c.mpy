{
  "module_name": "dvb-usb-urb.c",
  "hash_id": "c9575832412d6c47c8ef033e7616a170383967f481ac3fe190b44c63b3b5e91a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/dvb-usb-urb.c",
  "human_readable_source": "\n \n#include \"dvb-usb-common.h\"\n\nint dvb_usb_generic_rw(struct dvb_usb_device *d, u8 *wbuf, u16 wlen, u8 *rbuf,\n\tu16 rlen, int delay_ms)\n{\n\tint actlen = 0, ret = -ENOMEM;\n\n\tif (!d || wbuf == NULL || wlen == 0)\n\t\treturn -EINVAL;\n\n\tif (d->props.generic_bulk_ctrl_endpoint == 0) {\n\t\terr(\"endpoint for generic control not specified.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((ret = mutex_lock_interruptible(&d->usb_mutex)))\n\t\treturn ret;\n\n\tdeb_xfer(\">>> \");\n\tdebug_dump(wbuf,wlen,deb_xfer);\n\n\tret = usb_bulk_msg(d->udev,usb_sndbulkpipe(d->udev,\n\t\t\td->props.generic_bulk_ctrl_endpoint), wbuf,wlen,&actlen,\n\t\t\t2000);\n\n\tif (ret)\n\t\terr(\"bulk message failed: %d (%d/%d)\",ret,wlen,actlen);\n\telse\n\t\tret = actlen != wlen ? -1 : 0;\n\n\t \n\tif (!ret && rbuf && rlen) {\n\t\tif (delay_ms)\n\t\t\tmsleep(delay_ms);\n\n\t\tret = usb_bulk_msg(d->udev,usb_rcvbulkpipe(d->udev,\n\t\t\t\td->props.generic_bulk_ctrl_endpoint_response ?\n\t\t\t\td->props.generic_bulk_ctrl_endpoint_response :\n\t\t\t\td->props.generic_bulk_ctrl_endpoint),rbuf,rlen,&actlen,\n\t\t\t\t2000);\n\n\t\tif (ret)\n\t\t\terr(\"recv bulk message failed: %d\",ret);\n\t\telse {\n\t\t\tdeb_xfer(\"<<< \");\n\t\t\tdebug_dump(rbuf,actlen,deb_xfer);\n\t\t}\n\t}\n\n\tmutex_unlock(&d->usb_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(dvb_usb_generic_rw);\n\nint dvb_usb_generic_write(struct dvb_usb_device *d, u8 *buf, u16 len)\n{\n\treturn dvb_usb_generic_rw(d,buf,len,NULL,0,0);\n}\nEXPORT_SYMBOL(dvb_usb_generic_write);\n\nstatic void dvb_usb_data_complete(struct usb_data_stream *stream, u8 *buffer, size_t length)\n{\n\tstruct dvb_usb_adapter *adap = stream->user_priv;\n\tif (adap->feedcount > 0 && adap->state & DVB_USB_ADAP_STATE_DVB)\n\t\tdvb_dmx_swfilter(&adap->demux, buffer, length);\n}\n\nstatic void dvb_usb_data_complete_204(struct usb_data_stream *stream, u8 *buffer, size_t length)\n{\n\tstruct dvb_usb_adapter *adap = stream->user_priv;\n\tif (adap->feedcount > 0 && adap->state & DVB_USB_ADAP_STATE_DVB)\n\t\tdvb_dmx_swfilter_204(&adap->demux, buffer, length);\n}\n\nstatic void dvb_usb_data_complete_raw(struct usb_data_stream *stream,\n\t\t\t\t      u8 *buffer, size_t length)\n{\n\tstruct dvb_usb_adapter *adap = stream->user_priv;\n\tif (adap->feedcount > 0 && adap->state & DVB_USB_ADAP_STATE_DVB)\n\t\tdvb_dmx_swfilter_raw(&adap->demux, buffer, length);\n}\n\nint dvb_usb_adapter_stream_init(struct dvb_usb_adapter *adap)\n{\n\tint i, ret = 0;\n\tfor (i = 0; i < adap->props.num_frontends; i++) {\n\n\t\tadap->fe_adap[i].stream.udev      = adap->dev->udev;\n\t\tif (adap->props.fe[i].caps & DVB_USB_ADAP_RECEIVES_204_BYTE_TS)\n\t\t\tadap->fe_adap[i].stream.complete =\n\t\t\t\tdvb_usb_data_complete_204;\n\t\telse\n\t\tif (adap->props.fe[i].caps & DVB_USB_ADAP_RECEIVES_RAW_PAYLOAD)\n\t\t\tadap->fe_adap[i].stream.complete =\n\t\t\t\tdvb_usb_data_complete_raw;\n\t\telse\n\t\tadap->fe_adap[i].stream.complete  = dvb_usb_data_complete;\n\t\tadap->fe_adap[i].stream.user_priv = adap;\n\t\tret = usb_urb_init(&adap->fe_adap[i].stream,\n\t\t\t\t   &adap->props.fe[i].stream);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nint dvb_usb_adapter_stream_exit(struct dvb_usb_adapter *adap)\n{\n\tint i;\n\tfor (i = 0; i < adap->props.num_frontends; i++)\n\t\tusb_urb_exit(&adap->fe_adap[i].stream);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}