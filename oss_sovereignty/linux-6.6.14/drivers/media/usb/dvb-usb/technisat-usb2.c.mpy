{
  "module_name": "technisat-usb2.c",
  "hash_id": "135d0301896ff3295f753b2eca25a1ce0155d7a3cad38f1bcc4a04c6c4356c6a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/technisat-usb2.c",
  "human_readable_source": " \n\n#define DVB_USB_LOG_PREFIX \"technisat-usb2\"\n#include \"dvb-usb.h\"\n\n#include \"stv6110x.h\"\n#include \"stv090x.h\"\n\n \nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug,\n\t\t\"set debugging level (bit-mask: 1=info,2=eeprom,4=i2c,8=rc).\" \\\n\t\tDVB_USB_DEBUG_STATUS);\n\n \nstatic int disable_led_control;\nmodule_param(disable_led_control, int, 0444);\nMODULE_PARM_DESC(disable_led_control,\n\t\t\"disable LED control of the device (default: 0 - LED control is active).\");\n\n \nstruct technisat_usb2_state {\n\tstruct dvb_usb_device *dev;\n\tstruct delayed_work green_led_work;\n\tu8 power_state;\n\n\tu16 last_scan_code;\n\n\tu8 buf[64];\n};\n\n \n#define deb_info(args...)    dprintk(debug, 0x01, args)\n#define deb_eeprom(args...)  dprintk(debug, 0x02, args)\n#define deb_i2c(args...)     dprintk(debug, 0x04, args)\n#define deb_rc(args...)      dprintk(debug, 0x08, args)\n\n \n#define SET_IFCLK_TO_EXTERNAL_TSCLK_VENDOR_REQUEST 0xB3\n#define SET_FRONT_END_RESET_VENDOR_REQUEST         0xB4\n#define GET_VERSION_INFO_VENDOR_REQUEST            0xB5\n#define SET_GREEN_LED_VENDOR_REQUEST               0xB6\n#define SET_RED_LED_VENDOR_REQUEST                 0xB7\n#define GET_IR_DATA_VENDOR_REQUEST                 0xB8\n#define SET_LED_TIMER_DIVIDER_VENDOR_REQUEST       0xB9\n#define SET_USB_REENUMERATION                      0xBA\n\n \n#define I2C_SPEED_100KHZ_BIT 0x40\n\n#define I2C_STATUS_NAK 7\n#define I2C_STATUS_OK 8\n\nstatic int technisat_usb2_i2c_access(struct usb_device *udev,\n\t\tu8 device_addr, u8 *tx, u8 txlen, u8 *rx, u8 rxlen)\n{\n\tu8 *b;\n\tint ret, actual_length;\n\n\tb = kmalloc(64, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\n\tdeb_i2c(\"i2c-access: %02x, tx: \", device_addr);\n\tdebug_dump(tx, txlen, deb_i2c);\n\tdeb_i2c(\" \");\n\n\tif (txlen > 62) {\n\t\terr(\"i2c TX buffer can't exceed 62 bytes (dev 0x%02x)\",\n\t\t\t\tdevice_addr);\n\t\ttxlen = 62;\n\t}\n\tif (rxlen > 62) {\n\t\terr(\"i2c RX buffer can't exceed 62 bytes (dev 0x%02x)\",\n\t\t\t\tdevice_addr);\n\t\trxlen = 62;\n\t}\n\n\tb[0] = I2C_SPEED_100KHZ_BIT;\n\tb[1] = device_addr << 1;\n\n\tif (rx != NULL) {\n\t\tb[0] |= rxlen;\n\t\tb[1] |= 1;\n\t}\n\n\tmemcpy(&b[2], tx, txlen);\n\tret = usb_bulk_msg(udev,\n\t\t\tusb_sndbulkpipe(udev, 0x01),\n\t\t\tb, 2 + txlen,\n\t\t\tNULL, 1000);\n\n\tif (ret < 0) {\n\t\terr(\"i2c-error: out failed %02x = %d\", device_addr, ret);\n\t\tgoto err;\n\t}\n\n\tret = usb_bulk_msg(udev,\n\t\t\tusb_rcvbulkpipe(udev, 0x01),\n\t\t\tb, 64, &actual_length, 1000);\n\tif (ret < 0) {\n\t\terr(\"i2c-error: in failed %02x = %d\", device_addr, ret);\n\t\tgoto err;\n\t}\n\n\tif (b[0] != I2C_STATUS_OK) {\n\t\terr(\"i2c-error: %02x = %d\", device_addr, b[0]);\n\t\t \n\t\tif (!(b[0] == I2C_STATUS_NAK &&\n\t\t\t\tdevice_addr == 0x60\n\t\t\t\t ))\n\t\t\tgoto err;\n\t}\n\n\tdeb_i2c(\"status: %d, \", b[0]);\n\n\tif (rx != NULL) {\n\t\tmemcpy(rx, &b[2], rxlen);\n\n\t\tdeb_i2c(\"rx (%d): \", rxlen);\n\t\tdebug_dump(rx, rxlen, deb_i2c);\n\t}\n\n\tdeb_i2c(\"\\n\");\n\nerr:\n\tkfree(b);\n\treturn ret;\n}\n\nstatic int technisat_usb2_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msg,\n\t\t\t\tint num)\n{\n\tint ret = 0, i;\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\n\t \n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tfor (i = 0; i < num; i++) {\n\t\tif (i+1 < num && msg[i+1].flags & I2C_M_RD) {\n\t\t\tret = technisat_usb2_i2c_access(d->udev, msg[i+1].addr,\n\t\t\t\t\t\tmsg[i].buf, msg[i].len,\n\t\t\t\t\t\tmsg[i+1].buf, msg[i+1].len);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t} else {\n\t\t\tret = technisat_usb2_i2c_access(d->udev, msg[i].addr,\n\t\t\t\t\t\tmsg[i].buf, msg[i].len,\n\t\t\t\t\t\tNULL, 0);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret == 0)\n\t\tret = i;\n\n\tmutex_unlock(&d->i2c_mutex);\n\n\treturn ret;\n}\n\nstatic u32 technisat_usb2_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm technisat_usb2_i2c_algo = {\n\t.master_xfer   = technisat_usb2_i2c_xfer,\n\t.functionality = technisat_usb2_i2c_func,\n};\n\n#if 0\nstatic void technisat_usb2_frontend_reset(struct usb_device *udev)\n{\n\tusb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tSET_FRONT_END_RESET_VENDOR_REQUEST,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t10, 0,\n\t\t\tNULL, 0, 500);\n}\n#endif\n\n \nenum technisat_usb2_led_state {\n\tTECH_LED_OFF,\n\tTECH_LED_BLINK,\n\tTECH_LED_ON,\n\tTECH_LED_UNDEFINED\n};\n\nstatic int technisat_usb2_set_led(struct dvb_usb_device *d, int red,\n\t\t\t\t  enum technisat_usb2_led_state st)\n{\n\tstruct technisat_usb2_state *state = d->priv;\n\tu8 *led = state->buf;\n\tint ret;\n\n\tled[0] = red ? SET_RED_LED_VENDOR_REQUEST : SET_GREEN_LED_VENDOR_REQUEST;\n\n\tif (disable_led_control && st != TECH_LED_OFF)\n\t\treturn 0;\n\n\tswitch (st) {\n\tcase TECH_LED_ON:\n\t\tled[1] = 0x82;\n\t\tbreak;\n\tcase TECH_LED_BLINK:\n\t\tled[1] = 0x82;\n\t\tif (red) {\n\t\t\tled[2] = 0x02;\n\t\t\tled[3] = 10;\n\t\t\tled[4] = 10;\n\t\t} else {\n\t\t\tled[2] = 0xff;\n\t\t\tled[3] = 50;\n\t\t\tled[4] = 50;\n\t\t}\n\t\tled[5] = 1;\n\t\tbreak;\n\n\tdefault:\n\tcase TECH_LED_OFF:\n\t\tled[1] = 0x80;\n\t\tbreak;\n\t}\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tret = usb_control_msg(d->udev, usb_sndctrlpipe(d->udev, 0),\n\t\tred ? SET_RED_LED_VENDOR_REQUEST : SET_GREEN_LED_VENDOR_REQUEST,\n\t\tUSB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t0, 0,\n\t\tled, 8, 500);\n\n\tmutex_unlock(&d->i2c_mutex);\n\treturn ret;\n}\n\nstatic int technisat_usb2_set_led_timer(struct dvb_usb_device *d, u8 red, u8 green)\n{\n\tstruct technisat_usb2_state *state = d->priv;\n\tu8 *b = state->buf;\n\tint ret;\n\n\tb[0] = 0;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tret = usb_control_msg(d->udev, usb_sndctrlpipe(d->udev, 0),\n\t\tSET_LED_TIMER_DIVIDER_VENDOR_REQUEST,\n\t\tUSB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t(red << 8) | green, 0,\n\t\tb, 1, 500);\n\n\tmutex_unlock(&d->i2c_mutex);\n\n\treturn ret;\n}\n\nstatic void technisat_usb2_green_led_control(struct work_struct *work)\n{\n\tstruct technisat_usb2_state *state =\n\t\tcontainer_of(work, struct technisat_usb2_state, green_led_work.work);\n\tstruct dvb_frontend *fe = state->dev->adapter[0].fe_adap[0].fe;\n\n\tif (state->power_state == 0)\n\t\tgoto schedule;\n\n\tif (fe != NULL) {\n\t\tenum fe_status status;\n\n\t\tif (fe->ops.read_status(fe, &status) != 0)\n\t\t\tgoto schedule;\n\n\t\tif (status & FE_HAS_LOCK) {\n\t\t\tu32 ber;\n\n\t\t\tif (fe->ops.read_ber(fe, &ber) != 0)\n\t\t\t\tgoto schedule;\n\n\t\t\tif (ber > 1000)\n\t\t\t\ttechnisat_usb2_set_led(state->dev, 0, TECH_LED_BLINK);\n\t\t\telse\n\t\t\t\ttechnisat_usb2_set_led(state->dev, 0, TECH_LED_ON);\n\t\t} else\n\t\t\ttechnisat_usb2_set_led(state->dev, 0, TECH_LED_OFF);\n\t}\n\nschedule:\n\tschedule_delayed_work(&state->green_led_work,\n\t\t\tmsecs_to_jiffies(500));\n}\n\n \nstatic int technisat_usb2_identify_state(struct usb_device *udev,\n\t\tconst struct dvb_usb_device_properties *props,\n\t\tconst struct dvb_usb_device_description **desc, int *cold)\n{\n\tint ret;\n\tu8 *version;\n\n\tversion = kmalloc(3, GFP_KERNEL);\n\tif (!version)\n\t\treturn -ENOMEM;\n\n\t \n\tif (usb_set_interface(udev, 0, 1) != 0)\n\t\terr(\"could not set alternate setting to 0\");\n\telse\n\t\tinfo(\"set alternate setting\");\n\n\t*cold = 0;  \n\n\tret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\tGET_VERSION_INFO_VENDOR_REQUEST,\n\t\tUSB_TYPE_VENDOR | USB_DIR_IN,\n\t\t0, 0,\n\t\tversion, 3, 500);\n\n\tif (ret < 0)\n\t\t*cold = 1;\n\telse {\n\t\tinfo(\"firmware version: %d.%d\", version[1], version[2]);\n\t\t*cold = 0;\n\t}\n\n\tkfree(version);\n\n\treturn 0;\n}\n\n \nstatic int technisat_usb2_power_ctrl(struct dvb_usb_device *d, int level)\n{\n\tstruct technisat_usb2_state *state = d->priv;\n\n\tstate->power_state = level;\n\n\tif (disable_led_control)\n\t\treturn 0;\n\n\t \n\ttechnisat_usb2_set_led(d, 0, TECH_LED_OFF);\n\t \n\ttechnisat_usb2_set_led(d, 1, TECH_LED_ON);\n\treturn 0;\n}\n\n \n#if 0\nstatic void technisat_usb2_eeprom_dump(struct dvb_usb_device *d)\n{\n\tu8 reg;\n\tu8 b[16];\n\tint i, j;\n\n\t \n\tfor (j = 0; j < 256 * 4; j += 16) {\n\t\treg = j;\n\t\tif (technisat_usb2_i2c_access(d->udev, 0x50 + j / 256, &reg, 1, b, 16) != 0)\n\t\t\tbreak;\n\n\t\tdeb_eeprom(\"EEPROM: %01x%02x: \", j / 256, reg);\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tdeb_eeprom(\"%02x \", b[i]);\n\t\tdeb_eeprom(\"\\n\");\n\t}\n}\n#endif\n\nstatic u8 technisat_usb2_calc_lrc(const u8 *b, u16 length)\n{\n\tu8 lrc = 0;\n\twhile (--length)\n\t\tlrc ^= *b++;\n\treturn lrc;\n}\n\nstatic int technisat_usb2_eeprom_lrc_read(struct dvb_usb_device *d,\n\tu16 offset, u8 *b, u16 length, u8 tries)\n{\n\tu8 bo = offset & 0xff;\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = 0x50 | ((offset >> 8) & 0x3),\n\t\t\t.buf = &bo,\n\t\t\t.len = 1\n\t\t}, {\n\t\t\t.addr = 0x50 | ((offset >> 8) & 0x3),\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.buf = b,\n\t\t\t.len = length\n\t\t}\n\t};\n\n\twhile (tries--) {\n\t\tint status;\n\n\t\tif (i2c_transfer(&d->i2c_adap, msg, 2) != 2)\n\t\t\tbreak;\n\n\t\tstatus =\n\t\t\ttechnisat_usb2_calc_lrc(b, length - 1) == b[length - 1];\n\n\t\tif (status)\n\t\t\treturn 0;\n\t}\n\n\treturn -EREMOTEIO;\n}\n\n#define EEPROM_MAC_START 0x3f8\n#define EEPROM_MAC_TOTAL 8\nstatic int technisat_usb2_read_mac_address(struct dvb_usb_device *d,\n\t\tu8 mac[])\n{\n\tu8 buf[EEPROM_MAC_TOTAL];\n\n\tif (technisat_usb2_eeprom_lrc_read(d, EEPROM_MAC_START,\n\t\t\t\tbuf, EEPROM_MAC_TOTAL, 4) != 0)\n\t\treturn -ENODEV;\n\n\tmemcpy(mac, buf, 6);\n\treturn 0;\n}\n\nstatic struct stv090x_config technisat_usb2_stv090x_config;\n\n \nstatic int technisat_usb2_set_voltage(struct dvb_frontend *fe,\n\t\t\t\t      enum fe_sec_voltage voltage)\n{\n\tint i;\n\tu8 gpio[3] = { 0 };  \n\n\tgpio[2] = 1;  \n\n\tswitch (voltage) {\n\tcase SEC_VOLTAGE_13:\n\t\tgpio[0] = 1;\n\t\tbreak;\n\tcase SEC_VOLTAGE_18:\n\t\tgpio[0] = 1;\n\t\tgpio[1] = 1;\n\t\tbreak;\n\tdefault:\n\tcase SEC_VOLTAGE_OFF:\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t\tif (technisat_usb2_stv090x_config.set_gpio(fe, i+2, 0,\n\t\t\t\t\t\t\t   gpio[i], 0) != 0)\n\t\t\treturn -EREMOTEIO;\n\treturn 0;\n}\n\nstatic struct stv090x_config technisat_usb2_stv090x_config = {\n\t.device         = STV0903,\n\t.demod_mode     = STV090x_SINGLE,\n\t.clk_mode       = STV090x_CLK_EXT,\n\n\t.xtal           = 8000000,\n\t.address        = 0x68,\n\n\t.ts1_mode       = STV090x_TSMODE_DVBCI,\n\t.ts1_clk        = 13400000,\n\t.ts1_tei        = 1,\n\n\t.repeater_level = STV090x_RPTLEVEL_64,\n\n\t.tuner_bbgain   = 6,\n};\n\nstatic struct stv6110x_config technisat_usb2_stv6110x_config = {\n\t.addr           = 0x60,\n\t.refclk         = 16000000,\n\t.clk_div        = 2,\n};\n\nstatic int technisat_usb2_frontend_attach(struct dvb_usb_adapter *a)\n{\n\tstruct usb_device *udev = a->dev->udev;\n\tint ret;\n\n\ta->fe_adap[0].fe = dvb_attach(stv090x_attach, &technisat_usb2_stv090x_config,\n\t\t\t&a->dev->i2c_adap, STV090x_DEMODULATOR_0);\n\n\tif (a->fe_adap[0].fe) {\n\t\tconst struct stv6110x_devctl *ctl;\n\n\t\tctl = dvb_attach(stv6110x_attach,\n\t\t\t\ta->fe_adap[0].fe,\n\t\t\t\t&technisat_usb2_stv6110x_config,\n\t\t\t\t&a->dev->i2c_adap);\n\n\t\tif (ctl) {\n\t\t\ttechnisat_usb2_stv090x_config.tuner_init          = ctl->tuner_init;\n\t\t\ttechnisat_usb2_stv090x_config.tuner_sleep         = ctl->tuner_sleep;\n\t\t\ttechnisat_usb2_stv090x_config.tuner_set_mode      = ctl->tuner_set_mode;\n\t\t\ttechnisat_usb2_stv090x_config.tuner_set_frequency = ctl->tuner_set_frequency;\n\t\t\ttechnisat_usb2_stv090x_config.tuner_get_frequency = ctl->tuner_get_frequency;\n\t\t\ttechnisat_usb2_stv090x_config.tuner_set_bandwidth = ctl->tuner_set_bandwidth;\n\t\t\ttechnisat_usb2_stv090x_config.tuner_get_bandwidth = ctl->tuner_get_bandwidth;\n\t\t\ttechnisat_usb2_stv090x_config.tuner_set_bbgain    = ctl->tuner_set_bbgain;\n\t\t\ttechnisat_usb2_stv090x_config.tuner_get_bbgain    = ctl->tuner_get_bbgain;\n\t\t\ttechnisat_usb2_stv090x_config.tuner_set_refclk    = ctl->tuner_set_refclk;\n\t\t\ttechnisat_usb2_stv090x_config.tuner_get_status    = ctl->tuner_get_status;\n\n\t\t\t \n\t\t\tif (a->fe_adap[0].fe->ops.init)\n\t\t\t\ta->fe_adap[0].fe->ops.init(a->fe_adap[0].fe);\n\n\t\t\tif (mutex_lock_interruptible(&a->dev->i2c_mutex) < 0)\n\t\t\t\treturn -EAGAIN;\n\n\t\t\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t\tSET_IFCLK_TO_EXTERNAL_TSCLK_VENDOR_REQUEST,\n\t\t\t\t\tUSB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t\t\t0, 0,\n\t\t\t\t\tNULL, 0, 500);\n\t\t\tmutex_unlock(&a->dev->i2c_mutex);\n\n\t\t\tif (ret != 0)\n\t\t\t\terr(\"could not set IF_CLK to external\");\n\n\t\t\ta->fe_adap[0].fe->ops.set_voltage = technisat_usb2_set_voltage;\n\n\t\t\t \n\t\t\tstrscpy(a->fe_adap[0].fe->ops.info.name,\n\t\t\t\ta->dev->desc->name,\n\t\t\t\tsizeof(a->fe_adap[0].fe->ops.info.name));\n\t\t} else {\n\t\t\tdvb_frontend_detach(a->fe_adap[0].fe);\n\t\t\ta->fe_adap[0].fe = NULL;\n\t\t}\n\t}\n\n\ttechnisat_usb2_set_led_timer(a->dev, 1, 1);\n\n\treturn a->fe_adap[0].fe == NULL ? -ENODEV : 0;\n}\n\n \n\n \n#define NOMINAL_IR_BIT_TRANSITION_TIME_US 889\n#define NOMINAL_IR_BIT_TIME_US (2 * NOMINAL_IR_BIT_TRANSITION_TIME_US)\n\n#define FIRMWARE_CLOCK_TICK 83333\n#define FIRMWARE_CLOCK_DIVISOR 256\n\n#define IR_PERCENT_TOLERANCE 15\n\n#define NOMINAL_IR_BIT_TRANSITION_TICKS ((NOMINAL_IR_BIT_TRANSITION_TIME_US * 1000 * 1000) / FIRMWARE_CLOCK_TICK)\n#define NOMINAL_IR_BIT_TRANSITION_TICK_COUNT (NOMINAL_IR_BIT_TRANSITION_TICKS / FIRMWARE_CLOCK_DIVISOR)\n\n#define NOMINAL_IR_BIT_TIME_TICKS ((NOMINAL_IR_BIT_TIME_US * 1000 * 1000) / FIRMWARE_CLOCK_TICK)\n#define NOMINAL_IR_BIT_TIME_TICK_COUNT (NOMINAL_IR_BIT_TIME_TICKS / FIRMWARE_CLOCK_DIVISOR)\n\n#define MINIMUM_IR_BIT_TRANSITION_TICK_COUNT (NOMINAL_IR_BIT_TRANSITION_TICK_COUNT - ((NOMINAL_IR_BIT_TRANSITION_TICK_COUNT * IR_PERCENT_TOLERANCE) / 100))\n#define MAXIMUM_IR_BIT_TRANSITION_TICK_COUNT (NOMINAL_IR_BIT_TRANSITION_TICK_COUNT + ((NOMINAL_IR_BIT_TRANSITION_TICK_COUNT * IR_PERCENT_TOLERANCE) / 100))\n\n#define MINIMUM_IR_BIT_TIME_TICK_COUNT (NOMINAL_IR_BIT_TIME_TICK_COUNT - ((NOMINAL_IR_BIT_TIME_TICK_COUNT * IR_PERCENT_TOLERANCE) / 100))\n#define MAXIMUM_IR_BIT_TIME_TICK_COUNT (NOMINAL_IR_BIT_TIME_TICK_COUNT + ((NOMINAL_IR_BIT_TIME_TICK_COUNT * IR_PERCENT_TOLERANCE) / 100))\n\nstatic int technisat_usb2_get_ir(struct dvb_usb_device *d)\n{\n\tstruct technisat_usb2_state *state = d->priv;\n\tstruct ir_raw_event ev;\n\tu8 *buf = state->buf;\n\tint i, ret;\n\n\tbuf[0] = GET_IR_DATA_VENDOR_REQUEST;\n\tbuf[1] = 0x08;\n\tbuf[2] = 0x8f;\n\tbuf[3] = MINIMUM_IR_BIT_TRANSITION_TICK_COUNT;\n\tbuf[4] = MAXIMUM_IR_BIT_TIME_TICK_COUNT;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\tret = usb_control_msg(d->udev, usb_sndctrlpipe(d->udev, 0),\n\t\t\tGET_IR_DATA_VENDOR_REQUEST,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t0, 0,\n\t\t\tbuf, 5, 500);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tbuf[1] = 0;\n\tbuf[2] = 0;\n\tret = usb_control_msg(d->udev, usb_rcvctrlpipe(d->udev, 0),\n\t\t\tGET_IR_DATA_VENDOR_REQUEST,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t0x8080, 0,\n\t\t\tbuf, 62, 500);\n\nunlock:\n\tmutex_unlock(&d->i2c_mutex);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 1)\n\t\treturn 0;  \n\n\t \n\n#if 0\n\tdeb_rc(\"RC: %d \", ret);\n\tdebug_dump(buf + 1, ret, deb_rc);\n#endif\n\n\tev.pulse = 0;\n\tfor (i = 1; i < ARRAY_SIZE(state->buf); i++) {\n\t\tif (buf[i] == 0xff) {\n\t\t\tev.pulse = 0;\n\t\t\tev.duration = 889 * 2;\n\t\t\tir_raw_event_store(d->rc_dev, &ev);\n\t\t\tbreak;\n\t\t}\n\n\t\tev.pulse = !ev.pulse;\n\t\tev.duration = (buf[i] * FIRMWARE_CLOCK_DIVISOR *\n\t\t\t       FIRMWARE_CLOCK_TICK) / (1000 * 1000);\n\t\tir_raw_event_store(d->rc_dev, &ev);\n\t}\n\n\tir_raw_event_handle(d->rc_dev);\n\n\treturn 1;\n}\n\nstatic int technisat_usb2_rc_query(struct dvb_usb_device *d)\n{\n\tint ret = technisat_usb2_get_ir(d);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0)\n\t\treturn 0;\n\n\tif (!disable_led_control)\n\t\ttechnisat_usb2_set_led(d, 1, TECH_LED_BLINK);\n\n\treturn 0;\n}\n\n \nenum {\n\tTECHNISAT_USB2_DVB_S2,\n};\n\nstatic struct usb_device_id technisat_usb2_id_table[] = {\n\tDVB_USB_DEV(TECHNISAT, TECHNISAT_USB2_DVB_S2),\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, technisat_usb2_id_table);\n\n \nstatic struct dvb_usb_device_properties technisat_usb2_devices = {\n\t.caps              = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl          = CYPRESS_FX2,\n\n\t.identify_state    = technisat_usb2_identify_state,\n\t.firmware          = \"dvb-usb-SkyStar_USB_HD_FW_v17_63.HEX.fw\",\n\n\t.size_of_priv      = sizeof(struct technisat_usb2_state),\n\n\t.i2c_algo          = &technisat_usb2_i2c_algo,\n\n\t.power_ctrl        = technisat_usb2_power_ctrl,\n\t.read_mac_address  = technisat_usb2_read_mac_address,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.frontend_attach  = technisat_usb2_frontend_attach,\n\n\t\t\t.stream = {\n\t\t\t\t.type = USB_ISOC,\n\t\t\t\t.count = 4,\n\t\t\t\t.endpoint = 0x2,\n\t\t\t\t.u = {\n\t\t\t\t\t.isoc = {\n\t\t\t\t\t\t.framesperurb = 32,\n\t\t\t\t\t\t.framesize = 2048,\n\t\t\t\t\t\t.interval = 1,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t\t.size_of_priv = 0,\n\t\t},\n\t},\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"Technisat SkyStar USB HD (DVB-S/S2)\",\n\t\t\t{ &technisat_usb2_id_table[TECHNISAT_USB2_DVB_S2], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t},\n\n\t.rc.core = {\n\t\t.rc_interval = 100,\n\t\t.rc_codes    = RC_MAP_TECHNISAT_USB2,\n\t\t.module_name = \"technisat-usb2\",\n\t\t.rc_query    = technisat_usb2_rc_query,\n\t\t.allowed_protos = RC_PROTO_BIT_ALL_IR_DECODER,\n\t\t.driver_type    = RC_DRIVER_IR_RAW,\n\t}\n};\n\nstatic int technisat_usb2_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct dvb_usb_device *dev;\n\n\tif (dvb_usb_device_init(intf, &technisat_usb2_devices, THIS_MODULE,\n\t\t\t\t&dev, adapter_nr) != 0)\n\t\treturn -ENODEV;\n\n\tif (dev) {\n\t\tstruct technisat_usb2_state *state = dev->priv;\n\t\tstate->dev = dev;\n\n\t\tif (!disable_led_control) {\n\t\t\tINIT_DELAYED_WORK(&state->green_led_work,\n\t\t\t\t\ttechnisat_usb2_green_led_control);\n\t\t\tschedule_delayed_work(&state->green_led_work,\n\t\t\t\t\tmsecs_to_jiffies(500));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void technisat_usb2_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *dev = usb_get_intfdata(intf);\n\n\t \n\tif (dev != NULL) {\n\t\tstruct technisat_usb2_state *state = dev->priv;\n\t\tif (state != NULL)\n\t\t\tcancel_delayed_work_sync(&state->green_led_work);\n\t}\n\n\tdvb_usb_device_exit(intf);\n}\n\nstatic struct usb_driver technisat_usb2_driver = {\n\t.name       = \"dvb_usb_technisat_usb2\",\n\t.probe      = technisat_usb2_probe,\n\t.disconnect = technisat_usb2_disconnect,\n\t.id_table   = technisat_usb2_id_table,\n};\n\nmodule_usb_driver(technisat_usb2_driver);\n\nMODULE_AUTHOR(\"Patrick Boettcher <pboettcher@kernellabs.com>\");\nMODULE_DESCRIPTION(\"Driver for Technisat DVB-S/S2 USB 2.0 device\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}