{
  "module_name": "a800.c",
  "hash_id": "9a5dd9881eae9950f40677c418fd6a50cb28a4680aee45906781edafacc5d612",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/a800.c",
  "human_readable_source": "\n \n#include \"dibusb.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (rc=1 (or-able)).\" DVB_USB_DEBUG_STATUS);\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n#define deb_rc(args...)   dprintk(debug,0x01,args)\n\nstatic int a800_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\t \n\treturn 0;\n}\n\n \nstatic int a800_identify_state(struct usb_device *udev,\n\t\t\t       const struct dvb_usb_device_properties *props,\n\t\t\t       const struct dvb_usb_device_description **desc,\n\t\t\t       int *cold)\n{\n\t*cold = udev->descriptor.iManufacturer != 1;\n\treturn 0;\n}\n\nstatic int a800_rc_query(struct dvb_usb_device *d)\n{\n\tint ret = 0;\n\tu8 *key = kmalloc(5, GFP_KERNEL);\n\tif (!key)\n\t\treturn -ENOMEM;\n\n\tif (usb_control_msg(d->udev,usb_rcvctrlpipe(d->udev,0),\n\t\t\t\t0x04, USB_TYPE_VENDOR | USB_DIR_IN, 0, 0, key, 5,\n\t\t\t\t2000) != 5) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\tif (key[0] == 1)\n\t\trc_keydown(d->rc_dev, RC_PROTO_NEC,\n\t\t\t   RC_SCANCODE_NEC(key[1], key[3]), 0);\n\telse if (key[0] == 2)\n\t\trc_repeat(d->rc_dev);\nout:\n\tkfree(key);\n\treturn ret;\n}\n\n \nstatic struct dvb_usb_device_properties a800_properties;\n\nstatic int a800_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\treturn dvb_usb_device_init(intf, &a800_properties,\n\t\t\t\t   THIS_MODULE, NULL, adapter_nr);\n}\n\n \nenum {\n\tAVERMEDIA_DVBT_USB2_COLD,\n\tAVERMEDIA_DVBT_USB2_WARM,\n};\n\nstatic struct usb_device_id a800_table[] = {\n\tDVB_USB_DEV(AVERMEDIA, AVERMEDIA_DVBT_USB2_COLD),\n\tDVB_USB_DEV(AVERMEDIA, AVERMEDIA_DVBT_USB2_WARM),\n\t{ }\n};\n\nMODULE_DEVICE_TABLE (usb, a800_table);\n\nstatic struct dvb_usb_device_properties a800_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl = CYPRESS_FX2,\n\t.firmware = \"dvb-usb-avertv-a800-02.fw\",\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.caps = DVB_USB_ADAP_HAS_PID_FILTER | DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t\t.pid_filter_count = 32,\n\t\t\t.streaming_ctrl   = dibusb2_0_streaming_ctrl,\n\t\t\t.pid_filter       = dibusb_pid_filter,\n\t\t\t.pid_filter_ctrl  = dibusb_pid_filter_ctrl,\n\n\t\t\t.frontend_attach  = dibusb_dib3000mc_frontend_attach,\n\t\t\t.tuner_attach     = dibusb_dib3000mc_tuner_attach,\n\n\t\t\t \n\t\t\t\t\t.stream = {\n\t\t\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 7,\n\t\t\t\t.endpoint = 0x06,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t\t.size_of_priv     = sizeof(struct dibusb_state),\n\t\t},\n\t},\n\n\t.power_ctrl       = a800_power_ctrl,\n\t.identify_state   = a800_identify_state,\n\n\t.rc.core = {\n\t\t.rc_interval\t= DEFAULT_RC_INTERVAL,\n\t\t.rc_codes\t= RC_MAP_AVERMEDIA_M135A,\n\t\t.module_name\t= KBUILD_MODNAME,\n\t\t.rc_query\t= a800_rc_query,\n\t\t.allowed_protos = RC_PROTO_BIT_NEC,\n\t},\n\n\t.i2c_algo         = &dibusb_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"AVerMedia AverTV DVB-T USB 2.0 (A800)\",\n\t\t\t{ &a800_table[AVERMEDIA_DVBT_USB2_COLD], NULL },\n\t\t\t{ &a800_table[AVERMEDIA_DVBT_USB2_WARM], NULL },\n\t\t},\n\t}\n};\n\nstatic struct usb_driver a800_driver = {\n\t.name\t\t= \"dvb_usb_a800\",\n\t.probe\t\t= a800_probe,\n\t.disconnect = dvb_usb_device_exit,\n\t.id_table\t= a800_table,\n};\n\nmodule_usb_driver(a800_driver);\n\nMODULE_AUTHOR(\"Patrick Boettcher <patrick.boettcher@posteo.de>\");\nMODULE_DESCRIPTION(\"AVerMedia AverTV DVB-T USB 2.0 (A800)\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}