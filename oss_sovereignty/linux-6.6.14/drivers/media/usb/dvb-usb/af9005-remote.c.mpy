{
  "module_name": "af9005-remote.c",
  "hash_id": "33a2987f5a1eaf984ffe7e07261af1392e80daf303d65a7d7b7b7b3595642214",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/af9005-remote.c",
  "human_readable_source": "\n \n#include \"af9005.h\"\n \nstatic int dvb_usb_af9005_remote_debug;\nmodule_param_named(debug, dvb_usb_af9005_remote_debug, int, 0644);\nMODULE_PARM_DESC(debug,\n\t\t \"enable (1) or disable (0) debug messages.\"\n\t\t DVB_USB_DEBUG_STATUS);\n\n#define deb_decode(args...)   dprintk(dvb_usb_af9005_remote_debug,0x01,args)\n\nstruct rc_map_table rc_map_af9005_table[] = {\n\n\t{0x01b7, KEY_POWER},\n\t{0x01a7, KEY_VOLUMEUP},\n\t{0x0187, KEY_CHANNELUP},\n\t{0x017f, KEY_MUTE},\n\t{0x01bf, KEY_VOLUMEDOWN},\n\t{0x013f, KEY_CHANNELDOWN},\n\t{0x01df, KEY_1},\n\t{0x015f, KEY_2},\n\t{0x019f, KEY_3},\n\t{0x011f, KEY_4},\n\t{0x01ef, KEY_5},\n\t{0x016f, KEY_6},\n\t{0x01af, KEY_7},\n\t{0x0127, KEY_8},\n\t{0x0107, KEY_9},\n\t{0x01cf, KEY_ZOOM},\n\t{0x014f, KEY_0},\n\t{0x018f, KEY_GOTO},\t \n\n\t{0x00bd, KEY_POWER},\n\t{0x007d, KEY_VOLUMEUP},\n\t{0x00fd, KEY_CHANNELUP},\n\t{0x009d, KEY_MUTE},\n\t{0x005d, KEY_VOLUMEDOWN},\n\t{0x00dd, KEY_CHANNELDOWN},\n\t{0x00ad, KEY_1},\n\t{0x006d, KEY_2},\n\t{0x00ed, KEY_3},\n\t{0x008d, KEY_4},\n\t{0x004d, KEY_5},\n\t{0x00cd, KEY_6},\n\t{0x00b5, KEY_7},\n\t{0x0075, KEY_8},\n\t{0x00f5, KEY_9},\n\t{0x0095, KEY_ZOOM},\n\t{0x0055, KEY_0},\n\t{0x00d5, KEY_GOTO},\t \n};\n\nint rc_map_af9005_table_size = ARRAY_SIZE(rc_map_af9005_table);\n\nstatic int repeatable_keys[] = {\n\tKEY_VOLUMEUP,\n\tKEY_VOLUMEDOWN,\n\tKEY_CHANNELUP,\n\tKEY_CHANNELDOWN\n};\n\nint af9005_rc_decode(struct dvb_usb_device *d, u8 * data, int len, u32 * event,\n\t\t     int *state)\n{\n\tu16 mark, space;\n\tu32 result;\n\tu8 cust, dat, invdat;\n\tint i;\n\n\tif (len >= 6) {\n\t\tmark = (u16) (data[0] << 8) + data[1];\n\t\tspace = (u16) (data[2] << 8) + data[3];\n\t\tif (space * 3 < mark) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(repeatable_keys); i++) {\n\t\t\t\tif (d->last_event == repeatable_keys[i]) {\n\t\t\t\t\t*state = REMOTE_KEY_REPEAT;\n\t\t\t\t\t*event = d->last_event;\n\t\t\t\t\tdeb_decode(\"repeat key, event %x\\n\",\n\t\t\t\t\t\t   *event);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeb_decode(\"repeated key ignored (non repeatable)\\n\");\n\t\t\treturn 0;\n\t\t} else if (len >= 33 * 4) {\t \n\t\t\tresult = 0;\n\t\t\tfor (i = 4; i < 4 + 32 * 4; i += 4) {\n\t\t\t\tresult <<= 1;\n\t\t\t\tmark = (u16) (data[i] << 8) + data[i + 1];\n\t\t\t\tmark >>= 1;\n\t\t\t\tspace = (u16) (data[i + 2] << 8) + data[i + 3];\n\t\t\t\tspace >>= 1;\n\t\t\t\tif (mark * 2 > space)\n\t\t\t\t\tresult += 1;\n\t\t\t}\n\t\t\tdeb_decode(\"key pressed, raw value %x\\n\", result);\n\t\t\tif ((result & 0xff000000) != 0xfe000000) {\n\t\t\t\tdeb_decode\n\t\t\t\t    (\"doesn't start with 0xfe, ignored\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcust = (result >> 16) & 0xff;\n\t\t\tdat = (result >> 8) & 0xff;\n\t\t\tinvdat = (~result) & 0xff;\n\t\t\tif (dat != invdat) {\n\t\t\t\tdeb_decode(\"code != inverted code\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (i = 0; i < rc_map_af9005_table_size; i++) {\n\t\t\t\tif (rc5_custom(&rc_map_af9005_table[i]) == cust\n\t\t\t\t    && rc5_data(&rc_map_af9005_table[i]) == dat) {\n\t\t\t\t\t*event = rc_map_af9005_table[i].keycode;\n\t\t\t\t\t*state = REMOTE_KEY_PRESSED;\n\t\t\t\t\tdeb_decode\n\t\t\t\t\t    (\"key pressed, event %x\\n\", *event);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeb_decode(\"not found in table\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n\nEXPORT_SYMBOL(rc_map_af9005_table);\nEXPORT_SYMBOL(rc_map_af9005_table_size);\nEXPORT_SYMBOL(af9005_rc_decode);\n\nMODULE_AUTHOR(\"Luca Olivetti <luca@ventoso.org>\");\nMODULE_DESCRIPTION\n    (\"Standard remote control decoder for Afatech 9005 DVB-T USB1.1 stick\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}