{
  "module_name": "cxusb-analog.c",
  "hash_id": "3fe47a29aa10420bd007589d87875ff73f7b5aabe4fc085a0b36e4fbd7dd5a1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/cxusb-analog.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/ktime.h>\n#include <linux/vmalloc.h>\n#include <media/drv-intf/cx25840.h>\n#include <media/tuner.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-subdev.h>\n#include <media/videobuf2-vmalloc.h>\n\n#include \"cxusb.h\"\n\nstatic int cxusb_medion_v_queue_setup(struct vb2_queue *q,\n\t\t\t\t      unsigned int *num_buffers,\n\t\t\t\t      unsigned int *num_planes,\n\t\t\t\t      unsigned int sizes[],\n\t\t\t\t      struct device *alloc_devs[])\n{\n\tstruct dvb_usb_device *dvbdev = vb2_get_drv_priv(q);\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\tunsigned int size = cxdev->width * cxdev->height * 2;\n\n\tif (*num_planes > 0) {\n\t\tif (*num_planes != 1)\n\t\t\treturn -EINVAL;\n\n\t\tif (sizes[0] < size)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t*num_planes = 1;\n\t\tsizes[0] = size;\n\t}\n\n\treturn 0;\n}\n\nstatic int cxusb_medion_v_buf_init(struct vb2_buffer *vb)\n{\n\tstruct dvb_usb_device *dvbdev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\n\tcxusb_vprintk(dvbdev, OPS, \"buffer init\\n\");\n\n\tif (vb2_plane_size(vb, 0) < cxdev->width * cxdev->height * 2)\n\t\treturn -ENOMEM;\n\n\tcxusb_vprintk(dvbdev, OPS, \"buffer OK\\n\");\n\n\treturn 0;\n}\n\nstatic void cxusb_auxbuf_init(struct dvb_usb_device *dvbdev,\n\t\t\t      struct cxusb_medion_auxbuf *auxbuf,\n\t\t\t      u8 *buf, unsigned int len)\n{\n\tcxusb_vprintk(dvbdev, AUXB, \"initializing auxbuf of len %u\\n\", len);\n\n\tauxbuf->buf = buf;\n\tauxbuf->len = len;\n\tauxbuf->paylen = 0;\n}\n\nstatic void cxusb_auxbuf_head_trim(struct dvb_usb_device *dvbdev,\n\t\t\t\t   struct cxusb_medion_auxbuf *auxbuf,\n\t\t\t\t   unsigned int pos)\n{\n\tif (pos == 0)\n\t\treturn;\n\n\tif (WARN_ON(pos > auxbuf->paylen))\n\t\treturn;\n\n\tcxusb_vprintk(dvbdev, AUXB,\n\t\t      \"trimming auxbuf len by %u to %u\\n\",\n\t\t      pos, auxbuf->paylen - pos);\n\n\tmemmove(auxbuf->buf, auxbuf->buf + pos, auxbuf->paylen - pos);\n\tauxbuf->paylen -= pos;\n}\n\nstatic unsigned int cxusb_auxbuf_paylen(struct cxusb_medion_auxbuf *auxbuf)\n{\n\treturn auxbuf->paylen;\n}\n\nstatic bool cxusb_auxbuf_make_space(struct dvb_usb_device *dvbdev,\n\t\t\t\t    struct cxusb_medion_auxbuf *auxbuf,\n\t\t\t\t    unsigned int howmuch)\n{\n\tunsigned int freespace;\n\n\tif (WARN_ON(howmuch >= auxbuf->len))\n\t\thowmuch = auxbuf->len - 1;\n\n\tfreespace = auxbuf->len - cxusb_auxbuf_paylen(auxbuf);\n\n\tcxusb_vprintk(dvbdev, AUXB, \"freespace is %u\\n\", freespace);\n\n\tif (freespace >= howmuch)\n\t\treturn true;\n\n\thowmuch -= freespace;\n\n\tcxusb_vprintk(dvbdev, AUXB, \"will overwrite %u bytes of buffer\\n\",\n\t\t      howmuch);\n\n\tcxusb_auxbuf_head_trim(dvbdev, auxbuf, howmuch);\n\n\treturn false;\n}\n\n \nstatic bool cxusb_auxbuf_append_urb(struct dvb_usb_device *dvbdev,\n\t\t\t\t    struct cxusb_medion_auxbuf *auxbuf,\n\t\t\t\t    struct urb *urb)\n{\n\tunsigned long len;\n\tint i;\n\tbool ret;\n\n\tfor (i = 0, len = 0; i < urb->number_of_packets; i++)\n\t\tlen += urb->iso_frame_desc[i].actual_length;\n\n\tret = cxusb_auxbuf_make_space(dvbdev, auxbuf, len);\n\n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\tunsigned int to_copy;\n\n\t\tto_copy = urb->iso_frame_desc[i].actual_length;\n\n\t\tmemcpy(auxbuf->buf + auxbuf->paylen, urb->transfer_buffer +\n\t\t       urb->iso_frame_desc[i].offset, to_copy);\n\n\t\tauxbuf->paylen += to_copy;\n\t}\n\n\treturn ret;\n}\n\nstatic bool cxusb_auxbuf_copy(struct cxusb_medion_auxbuf *auxbuf,\n\t\t\t      unsigned int pos, unsigned char *dest,\n\t\t\t      unsigned int len)\n{\n\tif (pos + len > auxbuf->paylen)\n\t\treturn false;\n\n\tmemcpy(dest, auxbuf->buf + pos, len);\n\n\treturn true;\n}\n\nstatic bool cxusb_medion_cf_refc_fld_chg(struct dvb_usb_device *dvbdev,\n\t\t\t\t\t struct cxusb_bt656_params *bt656,\n\t\t\t\t\t bool firstfield,\n\t\t\t\t\t unsigned int maxlines,\n\t\t\t\t\t unsigned int maxlinesamples,\n\t\t\t\t\t unsigned char buf[4])\n{\n\tbool firstfield_code = (buf[3] & CXUSB_BT656_FIELD_MASK) ==\n\t\tCXUSB_BT656_FIELD_1;\n\tunsigned int remlines;\n\n\tif (bt656->line == 0 || firstfield == firstfield_code)\n\t\treturn false;\n\n\tif (bt656->fmode == LINE_SAMPLES) {\n\t\tunsigned int remsamples = maxlinesamples -\n\t\t\tbt656->linesamples;\n\n\t\tcxusb_vprintk(dvbdev, BT656,\n\t\t\t      \"field %c after line %u field change\\n\",\n\t\t\t      firstfield ? '1' : '2', bt656->line);\n\n\t\tif (bt656->buf && remsamples > 0) {\n\t\t\tmemset(bt656->buf, 0, remsamples);\n\t\t\tbt656->buf += remsamples;\n\n\t\t\tcxusb_vprintk(dvbdev, BT656,\n\t\t\t\t      \"field %c line %u %u samples still remaining (of %u)\\n\",\n\t\t\t\t      firstfield ? '1' : '2',\n\t\t\t\t      bt656->line, remsamples,\n\t\t\t\t      maxlinesamples);\n\t\t}\n\n\t\tbt656->line++;\n\t}\n\n\tremlines = maxlines - bt656->line;\n\tif (bt656->buf && remlines > 0) {\n\t\tmemset(bt656->buf, 0, remlines * maxlinesamples);\n\t\tbt656->buf += remlines * maxlinesamples;\n\n\t\tcxusb_vprintk(dvbdev, BT656,\n\t\t\t      \"field %c %u lines still remaining (of %u)\\n\",\n\t\t\t      firstfield ? '1' : '2', remlines,\n\t\t\t      maxlines);\n\t}\n\n\treturn true;\n}\n\nstatic void cxusb_medion_cf_refc_start_sch(struct dvb_usb_device *dvbdev,\n\t\t\t\t\t   struct cxusb_bt656_params *bt656,\n\t\t\t\t\t   bool firstfield,\n\t\t\t\t\t   unsigned char buf[4])\n{\n\tbool firstfield_code = (buf[3] & CXUSB_BT656_FIELD_MASK) ==\n\t\tCXUSB_BT656_FIELD_1;\n\tbool sav_code = (buf[3] & CXUSB_BT656_SEAV_MASK) ==\n\t\tCXUSB_BT656_SEAV_SAV;\n\tbool vbi_code = (buf[3] & CXUSB_BT656_VBI_MASK) ==\n\t\tCXUSB_BT656_VBI_ON;\n\n\tif (!sav_code || firstfield != firstfield_code)\n\t\treturn;\n\n\tif (!vbi_code) {\n\t\tcxusb_vprintk(dvbdev, BT656, \"line start @ pos %u\\n\",\n\t\t\t      bt656->pos);\n\n\t\tbt656->linesamples = 0;\n\t\tbt656->fmode = LINE_SAMPLES;\n\t} else {\n\t\tcxusb_vprintk(dvbdev, BT656, \"VBI start @ pos %u\\n\",\n\t\t\t      bt656->pos);\n\n\t\tbt656->fmode = VBI_SAMPLES;\n\t}\n}\n\nstatic void cxusb_medion_cf_refc_line_smpl(struct dvb_usb_device *dvbdev,\n\t\t\t\t\t   struct cxusb_bt656_params *bt656,\n\t\t\t\t\t   bool firstfield,\n\t\t\t\t\t   unsigned int maxlinesamples,\n\t\t\t\t\t   unsigned char buf[4])\n{\n\tbool sav_code = (buf[3] & CXUSB_BT656_SEAV_MASK) ==\n\t\tCXUSB_BT656_SEAV_SAV;\n\tunsigned int remsamples;\n\n\tif (sav_code)\n\t\tcxusb_vprintk(dvbdev, BT656,\n\t\t\t      \"SAV in line samples @ line %u, pos %u\\n\",\n\t\t\t      bt656->line, bt656->pos);\n\n\tremsamples = maxlinesamples - bt656->linesamples;\n\tif (bt656->buf && remsamples > 0) {\n\t\tmemset(bt656->buf, 0, remsamples);\n\t\tbt656->buf += remsamples;\n\n\t\tcxusb_vprintk(dvbdev, BT656,\n\t\t\t      \"field %c line %u %u samples still remaining (of %u)\\n\",\n\t\t\t      firstfield ? '1' : '2', bt656->line, remsamples,\n\t\t\t      maxlinesamples);\n\t}\n\n\tbt656->fmode = START_SEARCH;\n\tbt656->line++;\n}\n\nstatic void cxusb_medion_cf_refc_vbi_smpl(struct dvb_usb_device *dvbdev,\n\t\t\t\t\t  struct cxusb_bt656_params *bt656,\n\t\t\t\t\t  unsigned char buf[4])\n{\n\tbool sav_code = (buf[3] & CXUSB_BT656_SEAV_MASK) ==\n\t\tCXUSB_BT656_SEAV_SAV;\n\n\tif (sav_code)\n\t\tcxusb_vprintk(dvbdev, BT656, \"SAV in VBI samples @ pos %u\\n\",\n\t\t\t      bt656->pos);\n\n\tbt656->fmode = START_SEARCH;\n}\n\n \nstatic bool cxusb_medion_cf_ref_code(struct dvb_usb_device *dvbdev,\n\t\t\t\t     struct cxusb_bt656_params *bt656,\n\t\t\t\t     bool firstfield,\n\t\t\t\t     unsigned int maxlines,\n\t\t\t\t     unsigned int maxlinesamples,\n\t\t\t\t     unsigned char buf[4])\n{\n\tif (bt656->fmode == START_SEARCH) {\n\t\tcxusb_medion_cf_refc_start_sch(dvbdev, bt656, firstfield, buf);\n\t} else if (bt656->fmode == LINE_SAMPLES) {\n\t\tcxusb_medion_cf_refc_line_smpl(dvbdev, bt656, firstfield,\n\t\t\t\t\t       maxlinesamples, buf);\n\t\treturn false;\n\t} else if (bt656->fmode == VBI_SAMPLES) {\n\t\tcxusb_medion_cf_refc_vbi_smpl(dvbdev, bt656, buf);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool cxusb_medion_cs_start_sch(struct dvb_usb_device *dvbdev,\n\t\t\t\t      struct cxusb_medion_auxbuf *auxbuf,\n\t\t\t\t      struct cxusb_bt656_params *bt656,\n\t\t\t\t      unsigned int maxlinesamples)\n{\n\tunsigned char buf[64];\n\tunsigned int idx;\n\tunsigned int tocheck = clamp_t(size_t, maxlinesamples / 4, 3,\n\t\t\t\t       sizeof(buf));\n\n\tif (!cxusb_auxbuf_copy(auxbuf, bt656->pos + 1, buf, tocheck))\n\t\treturn false;\n\n\tfor (idx = 0; idx <= tocheck - 3; idx++)\n\t\tif (memcmp(buf + idx, CXUSB_BT656_PREAMBLE, 3) == 0) {\n\t\t\tbt656->pos += (1 + idx);\n\t\t\treturn true;\n\t\t}\n\n\tcxusb_vprintk(dvbdev, BT656, \"line %u early start, pos %u\\n\",\n\t\t      bt656->line, bt656->pos);\n\n\tbt656->linesamples = 0;\n\tbt656->fmode = LINE_SAMPLES;\n\n\treturn true;\n}\n\nstatic void cxusb_medion_cs_line_smpl(struct cxusb_bt656_params *bt656,\n\t\t\t\t      unsigned int maxlinesamples,\n\t\t\t\t      unsigned char val)\n{\n\tif (bt656->buf)\n\t\t*(bt656->buf++) = val;\n\n\tbt656->linesamples++;\n\tbt656->pos++;\n\n\tif (bt656->linesamples >= maxlinesamples) {\n\t\tbt656->fmode = START_SEARCH;\n\t\tbt656->line++;\n\t}\n}\n\nstatic bool cxusb_medion_copy_samples(struct dvb_usb_device *dvbdev,\n\t\t\t\t      struct cxusb_medion_auxbuf *auxbuf,\n\t\t\t\t      struct cxusb_bt656_params *bt656,\n\t\t\t\t      unsigned int maxlinesamples,\n\t\t\t\t      unsigned char val)\n{\n\tif (bt656->fmode == START_SEARCH && bt656->line > 0)\n\t\treturn cxusb_medion_cs_start_sch(dvbdev, auxbuf, bt656,\n\t\t\t\t\t\t maxlinesamples);\n\telse if (bt656->fmode == LINE_SAMPLES)\n\t\tcxusb_medion_cs_line_smpl(bt656, maxlinesamples, val);\n\telse  \n\t\tbt656->pos++;\n\n\treturn true;\n}\n\nstatic bool cxusb_medion_copy_field(struct dvb_usb_device *dvbdev,\n\t\t\t\t    struct cxusb_medion_auxbuf *auxbuf,\n\t\t\t\t    struct cxusb_bt656_params *bt656,\n\t\t\t\t    bool firstfield,\n\t\t\t\t    unsigned int maxlines,\n\t\t\t\t    unsigned int maxlinesmpls)\n{\n\twhile (bt656->line < maxlines) {\n\t\tunsigned char val;\n\n\t\tif (!cxusb_auxbuf_copy(auxbuf, bt656->pos, &val, 1))\n\t\t\tbreak;\n\n\t\tif (val == CXUSB_BT656_PREAMBLE[0]) {\n\t\t\tunsigned char buf[4];\n\n\t\t\tbuf[0] = val;\n\t\t\tif (!cxusb_auxbuf_copy(auxbuf, bt656->pos + 1,\n\t\t\t\t\t       buf + 1, 3))\n\t\t\t\tbreak;\n\n\t\t\tif (buf[1] == CXUSB_BT656_PREAMBLE[1] &&\n\t\t\t    buf[2] == CXUSB_BT656_PREAMBLE[2]) {\n\t\t\t\t \n\t\t\t\tif (cxusb_medion_cf_refc_fld_chg(dvbdev,\n\t\t\t\t\t\t\t\t bt656,\n\t\t\t\t\t\t\t\t firstfield,\n\t\t\t\t\t\t\t\t maxlines,\n\t\t\t\t\t\t\t\t maxlinesmpls,\n\t\t\t\t\t\t\t\t buf))\n\t\t\t\t\treturn true;\n\n\t\t\t\tif (cxusb_medion_cf_ref_code(dvbdev, bt656,\n\t\t\t\t\t\t\t     firstfield,\n\t\t\t\t\t\t\t     maxlines,\n\t\t\t\t\t\t\t     maxlinesmpls,\n\t\t\t\t\t\t\t     buf))\n\t\t\t\t\tbt656->pos += 4;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!cxusb_medion_copy_samples(dvbdev, auxbuf, bt656,\n\t\t\t\t\t       maxlinesmpls, val))\n\t\t\tbreak;\n\t}\n\n\tif (bt656->line < maxlines) {\n\t\tcxusb_vprintk(dvbdev, BT656,\n\t\t\t      \"end of buffer pos = %u, line = %u\\n\",\n\t\t\t      bt656->pos, bt656->line);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool cxusb_medion_v_process_auxbuf(struct cxusb_medion_dev *cxdev,\n\t\t\t\t\t  bool reset)\n{\n\tstruct dvb_usb_device *dvbdev = cxdev->dvbdev;\n\tstruct cxusb_bt656_params *bt656 = &cxdev->bt656;\n\n\t \n\tif (bt656->mode == NEW_FRAME) {\n\t\tif (!list_empty(&cxdev->buflist)) {\n\t\t\tcxdev->vbuf =\n\t\t\t\tlist_first_entry(&cxdev->buflist,\n\t\t\t\t\t\t struct cxusb_medion_vbuffer,\n\t\t\t\t\t\t list);\n\t\t\tlist_del(&cxdev->vbuf->list);\n\t\t} else {\n\t\t\tdev_warn(&dvbdev->udev->dev, \"no free buffers\\n\");\n\t\t}\n\t}\n\n\tif (bt656->mode == NEW_FRAME || reset) {\n\t\tcxusb_vprintk(dvbdev, URB, \"will copy field 1\\n\");\n\t\tbt656->pos = 0;\n\t\tbt656->mode = FIRST_FIELD;\n\t\tbt656->fmode = START_SEARCH;\n\t\tbt656->line = 0;\n\n\t\tif (cxdev->vbuf) {\n\t\t\tcxdev->vbuf->vb2.vb2_buf.timestamp = ktime_get_ns();\n\t\t\tbt656->buf = vb2_plane_vaddr(&cxdev->vbuf->vb2.vb2_buf,\n\t\t\t\t\t\t     0);\n\t\t}\n\t}\n\n\tif (bt656->mode == FIRST_FIELD) {\n\t\tif (!cxusb_medion_copy_field(dvbdev, &cxdev->auxbuf, bt656,\n\t\t\t\t\t     true, cxdev->height / 2,\n\t\t\t\t\t     cxdev->width * 2))\n\t\t\treturn false;\n\n\t\t \n\n\t\tcxusb_vprintk(dvbdev, URB, \"will copy field 2\\n\");\n\t\tbt656->mode = SECOND_FIELD;\n\t\tbt656->fmode = START_SEARCH;\n\t\tbt656->line = 0;\n\t}\n\n\tif (bt656->mode == SECOND_FIELD) {\n\t\tif (!cxusb_medion_copy_field(dvbdev, &cxdev->auxbuf, bt656,\n\t\t\t\t\t     false, cxdev->height / 2,\n\t\t\t\t\t     cxdev->width * 2))\n\t\t\treturn false;\n\n\t\tcxusb_auxbuf_head_trim(dvbdev, &cxdev->auxbuf, bt656->pos);\n\n\t\tbt656->mode = NEW_FRAME;\n\n\t\tif (cxdev->vbuf) {\n\t\t\tvb2_set_plane_payload(&cxdev->vbuf->vb2.vb2_buf, 0,\n\t\t\t\t\t      cxdev->width * cxdev->height * 2);\n\n\t\t\tcxdev->vbuf->vb2.field = cxdev->field_order;\n\t\t\tcxdev->vbuf->vb2.sequence = cxdev->vbuf_sequence++;\n\n\t\t\tvb2_buffer_done(&cxdev->vbuf->vb2.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_DONE);\n\n\t\t\tcxdev->vbuf = NULL;\n\t\t\tcxdev->bt656.buf = NULL;\n\n\t\t\tcxusb_vprintk(dvbdev, URB, \"frame done\\n\");\n\t\t} else {\n\t\t\tcxusb_vprintk(dvbdev, URB, \"frame skipped\\n\");\n\t\t\tcxdev->vbuf_sequence++;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool cxusb_medion_v_complete_handle_urb(struct cxusb_medion_dev *cxdev,\n\t\t\t\t\t       bool *auxbuf_reset)\n{\n\tstruct dvb_usb_device *dvbdev = cxdev->dvbdev;\n\tunsigned int urbn;\n\tstruct urb *urb;\n\tint ret;\n\n\t*auxbuf_reset = false;\n\n\turbn = cxdev->nexturb;\n\tif (!test_bit(urbn, &cxdev->urbcomplete))\n\t\treturn false;\n\n\tclear_bit(urbn, &cxdev->urbcomplete);\n\n\tdo {\n\t\tcxdev->nexturb++;\n\t\tcxdev->nexturb %= CXUSB_VIDEO_URBS;\n\t\turb = cxdev->streamurbs[cxdev->nexturb];\n\t} while (!urb);\n\n\turb = cxdev->streamurbs[urbn];\n\tcxusb_vprintk(dvbdev, URB, \"URB %u status = %d\\n\", urbn, urb->status);\n\n\tif (urb->status == 0 || urb->status == -EXDEV) {\n\t\tint i;\n\t\tunsigned long len;\n\n\t\tfor (i = 0, len = 0; i < urb->number_of_packets; i++)\n\t\t\tlen += urb->iso_frame_desc[i].actual_length;\n\n\t\tcxusb_vprintk(dvbdev, URB, \"URB %u data len = %lu\\n\", urbn,\n\t\t\t      len);\n\n\t\tif (len > 0) {\n\t\t\tcxusb_vprintk(dvbdev, URB, \"appending URB\\n\");\n\n\t\t\t \n\t\t\t*auxbuf_reset =\n\t\t\t\t!cxusb_auxbuf_append_urb(dvbdev,\n\t\t\t\t\t\t\t &cxdev->auxbuf,\n\t\t\t\t\t\t\t urb);\n\t\t}\n\t}\n\n\tcxusb_vprintk(dvbdev, URB, \"URB %u resubmit\\n\", urbn);\n\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret != 0)\n\t\tdev_err(&dvbdev->udev->dev,\n\t\t\t\"unable to resubmit URB %u (%d), you'll have to restart streaming\\n\",\n\t\t\turbn, ret);\n\n\t \n\treturn test_bit(cxdev->nexturb, &cxdev->urbcomplete);\n}\n\nstatic void cxusb_medion_v_complete_work(struct work_struct *work)\n{\n\tstruct cxusb_medion_dev *cxdev = container_of(work,\n\t\t\t\t\t\t      struct cxusb_medion_dev,\n\t\t\t\t\t\t      urbwork);\n\tstruct dvb_usb_device *dvbdev = cxdev->dvbdev;\n\tbool auxbuf_reset;\n\tbool reschedule;\n\n\tmutex_lock(cxdev->videodev->lock);\n\n\tcxusb_vprintk(dvbdev, URB, \"worker called, stop_streaming = %d\\n\",\n\t\t      (int)cxdev->stop_streaming);\n\n\tif (cxdev->stop_streaming)\n\t\tgoto unlock;\n\n\treschedule = cxusb_medion_v_complete_handle_urb(cxdev, &auxbuf_reset);\n\n\tif (cxusb_medion_v_process_auxbuf(cxdev, auxbuf_reset))\n\t\t \n\t\treschedule = true;\n\n\tif (reschedule) {\n\t\tcxusb_vprintk(dvbdev, URB, \"rescheduling worker\\n\");\n\t\tschedule_work(&cxdev->urbwork);\n\t}\n\nunlock:\n\tmutex_unlock(cxdev->videodev->lock);\n}\n\nstatic void cxusb_medion_v_complete(struct urb *u)\n{\n\tstruct dvb_usb_device *dvbdev = u->context;\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\tunsigned int i;\n\n\tfor (i = 0; i < CXUSB_VIDEO_URBS; i++)\n\t\tif (cxdev->streamurbs[i] == u)\n\t\t\tbreak;\n\n\tif (i >= CXUSB_VIDEO_URBS) {\n\t\tdev_err(&dvbdev->udev->dev,\n\t\t\t\"complete on unknown URB\\n\");\n\t\treturn;\n\t}\n\n\tcxusb_vprintk(dvbdev, URB, \"URB %u complete\\n\", i);\n\n\tset_bit(i, &cxdev->urbcomplete);\n\tschedule_work(&cxdev->urbwork);\n}\n\nstatic void cxusb_medion_urbs_free(struct cxusb_medion_dev *cxdev)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < CXUSB_VIDEO_URBS; i++)\n\t\tif (cxdev->streamurbs[i]) {\n\t\t\tkfree(cxdev->streamurbs[i]->transfer_buffer);\n\t\t\tusb_free_urb(cxdev->streamurbs[i]);\n\t\t\tcxdev->streamurbs[i] = NULL;\n\t\t}\n}\n\nstatic void cxusb_medion_return_buffers(struct cxusb_medion_dev *cxdev,\n\t\t\t\t\tbool requeue)\n{\n\tstruct cxusb_medion_vbuffer *vbuf, *vbuf_tmp;\n\n\tlist_for_each_entry_safe(vbuf, vbuf_tmp, &cxdev->buflist,\n\t\t\t\t list) {\n\t\tlist_del(&vbuf->list);\n\t\tvb2_buffer_done(&vbuf->vb2.vb2_buf,\n\t\t\t\trequeue ? VB2_BUF_STATE_QUEUED :\n\t\t\t\tVB2_BUF_STATE_ERROR);\n\t}\n\n\tif (cxdev->vbuf) {\n\t\tvb2_buffer_done(&cxdev->vbuf->vb2.vb2_buf,\n\t\t\t\trequeue ? VB2_BUF_STATE_QUEUED :\n\t\t\t\tVB2_BUF_STATE_ERROR);\n\n\t\tcxdev->vbuf = NULL;\n\t\tcxdev->bt656.buf = NULL;\n\t}\n}\n\nstatic int cxusb_medion_v_ss_auxbuf_alloc(struct cxusb_medion_dev *cxdev,\n\t\t\t\t\t  int *npackets)\n{\n\tstruct dvb_usb_device *dvbdev = cxdev->dvbdev;\n\tu8 *buf;\n\tunsigned int framelen, urblen, auxbuflen;\n\n\tframelen = (cxdev->width * 2 + 4 + 4) *\n\t\t(cxdev->height + 50  );\n\n\t \n\tBUILD_BUG_ON(CXUSB_VIDEO_URB_MAX_SIZE / CXUSB_VIDEO_PKT_SIZE >\n\t\t     CXUSB_VIDEO_MAX_FRAME_PKTS);\n\t*npackets = min_t(int, (framelen + CXUSB_VIDEO_PKT_SIZE - 1) /\n\t\t\t  CXUSB_VIDEO_PKT_SIZE,\n\t\t\t  CXUSB_VIDEO_URB_MAX_SIZE / CXUSB_VIDEO_PKT_SIZE);\n\turblen = *npackets * CXUSB_VIDEO_PKT_SIZE;\n\n\tcxusb_vprintk(dvbdev, URB,\n\t\t      \"each URB will have %d packets for total of %u bytes (%u x %u @ %u)\\n\",\n\t\t      *npackets, urblen, (unsigned int)cxdev->width,\n\t\t      (unsigned int)cxdev->height, framelen);\n\n\tauxbuflen = framelen + urblen;\n\n\tbuf = vmalloc(auxbuflen);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tcxusb_auxbuf_init(dvbdev, &cxdev->auxbuf, buf, auxbuflen);\n\n\treturn 0;\n}\n\nstatic u32 cxusb_medion_norm2field_order(v4l2_std_id norm)\n{\n\tbool is625 = norm & V4L2_STD_625_50;\n\tbool is525 = norm & V4L2_STD_525_60;\n\n\tif (!is625 && !is525)\n\t\treturn V4L2_FIELD_NONE;\n\n\tif (is625 && is525)\n\t\treturn V4L2_FIELD_NONE;\n\n\tif (is625)\n\t\treturn V4L2_FIELD_SEQ_TB;\n\telse  \n\t\treturn V4L2_FIELD_SEQ_BT;\n}\n\nstatic u32 cxusb_medion_field_order(struct cxusb_medion_dev *cxdev)\n{\n\tstruct dvb_usb_device *dvbdev = cxdev->dvbdev;\n\tu32 field;\n\tint ret;\n\tv4l2_std_id norm;\n\n\t \n\tif (cxdev->input == 0)\n\t\treturn V4L2_FIELD_SEQ_TB;\n\n\tfield = cxusb_medion_norm2field_order(cxdev->norm);\n\tif (field != V4L2_FIELD_NONE)\n\t\treturn field;\n\n\tret = v4l2_subdev_call(cxdev->cx25840, video, g_std, &norm);\n\tif (ret != 0) {\n\t\tcxusb_vprintk(dvbdev, OPS,\n\t\t\t      \"cannot get current standard for input %u\\n\",\n\t\t\t      (unsigned int)cxdev->input);\n\t} else {\n\t\tfield = cxusb_medion_norm2field_order(norm);\n\t\tif (field != V4L2_FIELD_NONE)\n\t\t\treturn field;\n\t}\n\n\tdev_warn(&dvbdev->udev->dev,\n\t\t \"cannot determine field order for the current standard setup and received signal, using TB\\n\");\n\treturn V4L2_FIELD_SEQ_TB;\n}\n\nstatic int cxusb_medion_v_start_streaming(struct vb2_queue *q,\n\t\t\t\t\t  unsigned int count)\n{\n\tstruct dvb_usb_device *dvbdev = vb2_get_drv_priv(q);\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\tu8 streamon_params[2] = { 0x03, 0x00 };\n\tint npackets, i;\n\tint ret;\n\n\tcxusb_vprintk(dvbdev, OPS, \"should start streaming\\n\");\n\n\tif (cxdev->stop_streaming) {\n\t\t \n\t\tret = -EBUSY;\n\t\tgoto ret_retbufs;\n\t}\n\n\tcxdev->field_order = cxusb_medion_field_order(cxdev);\n\n\tret = v4l2_subdev_call(cxdev->cx25840, video, s_stream, 1);\n\tif (ret != 0) {\n\t\tdev_err(&dvbdev->udev->dev,\n\t\t\t\"unable to start stream (%d)\\n\", ret);\n\t\tgoto ret_retbufs;\n\t}\n\n\tret = cxusb_ctrl_msg(dvbdev, CMD_STREAMING_ON, streamon_params, 2,\n\t\t\t     NULL, 0);\n\tif (ret != 0) {\n\t\tdev_err(&dvbdev->udev->dev,\n\t\t\t\"unable to start streaming (%d)\\n\", ret);\n\t\tgoto ret_unstream_cx;\n\t}\n\n\tret = cxusb_medion_v_ss_auxbuf_alloc(cxdev, &npackets);\n\tif (ret != 0)\n\t\tgoto ret_unstream_md;\n\n\tfor (i = 0; i < CXUSB_VIDEO_URBS; i++) {\n\t\tint framen;\n\t\tu8 *streambuf;\n\t\tstruct urb *surb;\n\n\t\t \n\t\tstreambuf = kmalloc(npackets * CXUSB_VIDEO_PKT_SIZE,\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!streambuf) {\n\t\t\tif (i < 2) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto ret_freeab;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tsurb = usb_alloc_urb(npackets, GFP_KERNEL);\n\t\tif (!surb) {\n\t\t\tkfree(streambuf);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto ret_freeu;\n\t\t}\n\n\t\tcxdev->streamurbs[i] = surb;\n\t\tsurb->dev = dvbdev->udev;\n\t\tsurb->context = dvbdev;\n\t\tsurb->pipe = usb_rcvisocpipe(dvbdev->udev, 2);\n\n\t\tsurb->interval = 1;\n\t\tsurb->transfer_flags = URB_ISO_ASAP;\n\n\t\tsurb->transfer_buffer = streambuf;\n\n\t\tsurb->complete = cxusb_medion_v_complete;\n\t\tsurb->number_of_packets = npackets;\n\t\tsurb->transfer_buffer_length = npackets * CXUSB_VIDEO_PKT_SIZE;\n\n\t\tfor (framen = 0; framen < npackets; framen++) {\n\t\t\tsurb->iso_frame_desc[framen].offset =\n\t\t\t\tCXUSB_VIDEO_PKT_SIZE * framen;\n\n\t\t\tsurb->iso_frame_desc[framen].length =\n\t\t\t\tCXUSB_VIDEO_PKT_SIZE;\n\t\t}\n\t}\n\n\tcxdev->urbcomplete = 0;\n\tcxdev->nexturb = 0;\n\tcxdev->vbuf_sequence = 0;\n\n\tcxdev->vbuf = NULL;\n\tcxdev->bt656.mode = NEW_FRAME;\n\tcxdev->bt656.buf = NULL;\n\n\tfor (i = 0; i < CXUSB_VIDEO_URBS; i++)\n\t\tif (cxdev->streamurbs[i]) {\n\t\t\tret = usb_submit_urb(cxdev->streamurbs[i],\n\t\t\t\t\t     GFP_KERNEL);\n\t\t\tif (ret != 0)\n\t\t\t\tdev_err(&dvbdev->udev->dev,\n\t\t\t\t\t\"URB %d submission failed (%d)\\n\", i,\n\t\t\t\t\tret);\n\t\t}\n\n\treturn 0;\n\nret_freeu:\n\tcxusb_medion_urbs_free(cxdev);\n\nret_freeab:\n\tvfree(cxdev->auxbuf.buf);\n\nret_unstream_md:\n\tcxusb_ctrl_msg(dvbdev, CMD_STREAMING_OFF, NULL, 0, NULL, 0);\n\nret_unstream_cx:\n\tv4l2_subdev_call(cxdev->cx25840, video, s_stream, 0);\n\nret_retbufs:\n\tcxusb_medion_return_buffers(cxdev, true);\n\n\treturn ret;\n}\n\nstatic void cxusb_medion_v_stop_streaming(struct vb2_queue *q)\n{\n\tstruct dvb_usb_device *dvbdev = vb2_get_drv_priv(q);\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\tint ret;\n\tunsigned int i;\n\n\tcxusb_vprintk(dvbdev, OPS, \"should stop streaming\\n\");\n\n\tif (WARN_ON(cxdev->stop_streaming))\n\t\treturn;\n\n\tcxdev->stop_streaming = true;\n\n\tcxusb_ctrl_msg(dvbdev, CMD_STREAMING_OFF, NULL, 0, NULL, 0);\n\n\tret = v4l2_subdev_call(cxdev->cx25840, video, s_stream, 0);\n\tif (ret != 0)\n\t\tdev_err(&dvbdev->udev->dev, \"unable to stop stream (%d)\\n\",\n\t\t\tret);\n\n\t \n\tmutex_unlock(cxdev->videodev->lock);\n\n\tfor (i = 0; i < CXUSB_VIDEO_URBS; i++)\n\t\tif (cxdev->streamurbs[i])\n\t\t\tusb_kill_urb(cxdev->streamurbs[i]);\n\n\tflush_work(&cxdev->urbwork);\n\n\tmutex_lock(cxdev->videodev->lock);\n\n\t \n\tvfree(cxdev->auxbuf.buf);\n\n\tcxusb_medion_urbs_free(cxdev);\n\n\tcxusb_medion_return_buffers(cxdev, false);\n\n\tcxdev->stop_streaming = false;\n}\n\nstatic void cxusub_medion_v_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *v4l2buf = to_vb2_v4l2_buffer(vb);\n\tstruct cxusb_medion_vbuffer *vbuf =\n\t\tcontainer_of(v4l2buf, struct cxusb_medion_vbuffer, vb2);\n\tstruct dvb_usb_device *dvbdev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\n\t \n\n\tlist_add_tail(&vbuf->list, &cxdev->buflist);\n}\n\nstatic const struct vb2_ops cxdev_video_qops = {\n\t.queue_setup = cxusb_medion_v_queue_setup,\n\t.buf_init = cxusb_medion_v_buf_init,\n\t.start_streaming = cxusb_medion_v_start_streaming,\n\t.stop_streaming = cxusb_medion_v_stop_streaming,\n\t.buf_queue = cxusub_medion_v_buf_queue,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish\n};\n\nstatic const __u32 videocaps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_TUNER |\n\tV4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\nstatic const __u32 radiocaps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;\n\nstatic int cxusb_medion_v_querycap(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct dvb_usb_device *dvbdev = video_drvdata(file);\n\n\tstrscpy(cap->driver, dvbdev->udev->dev.driver->name,\n\t\tsizeof(cap->driver));\n\tstrscpy(cap->card, \"Medion 95700\", sizeof(cap->card));\n\tusb_make_path(dvbdev->udev, cap->bus_info, sizeof(cap->bus_info));\n\n\tcap->capabilities = videocaps | radiocaps | V4L2_CAP_DEVICE_CAPS;\n\n\treturn 0;\n}\n\nstatic int cxusb_medion_v_enum_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tif (f->index != 0)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = V4L2_PIX_FMT_UYVY;\n\n\treturn 0;\n}\n\nstatic int cxusb_medion_g_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t      struct v4l2_format *f)\n{\n\tstruct dvb_usb_device *dvbdev = video_drvdata(file);\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\n\tf->fmt.pix.width = cxdev->width;\n\tf->fmt.pix.height = cxdev->height;\n\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;\n\tf->fmt.pix.field = vb2_start_streaming_called(&cxdev->videoqueue) ?\n\t\tcxdev->field_order : cxusb_medion_field_order(cxdev);\n\tf->fmt.pix.bytesperline = cxdev->width * 2;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tf->fmt.pix.sizeimage = f->fmt.pix.bytesperline * f->fmt.pix.height;\n\n\treturn 0;\n}\n\nstatic int cxusb_medion_try_s_fmt_vid_cap(struct file *file,\n\t\t\t\t\t  struct v4l2_format *f,\n\t\t\t\t\t  bool isset)\n{\n\tstruct dvb_usb_device *dvbdev = video_drvdata(file);\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\tstruct v4l2_subdev_format subfmt = {\n\t\t.which = isset ? V4L2_SUBDEV_FORMAT_ACTIVE :\n\t\t\t V4L2_SUBDEV_FORMAT_TRY,\n\t};\n\tu32 field;\n\tint ret;\n\n\tif (isset && vb2_is_busy(&cxdev->videoqueue))\n\t\treturn -EBUSY;\n\n\tfield = vb2_start_streaming_called(&cxdev->videoqueue) ?\n\t\tcxdev->field_order : cxusb_medion_field_order(cxdev);\n\n\tsubfmt.format.width = f->fmt.pix.width & ~1;\n\tsubfmt.format.height = f->fmt.pix.height & ~1;\n\tsubfmt.format.code = MEDIA_BUS_FMT_FIXED;\n\tsubfmt.format.field = field;\n\tsubfmt.format.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\tret = v4l2_subdev_call(cxdev->cx25840, pad, set_fmt, NULL, &subfmt);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tf->fmt.pix.width = subfmt.format.width;\n\tf->fmt.pix.height = subfmt.format.height;\n\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;\n\tf->fmt.pix.field = field;\n\tf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\n\tf->fmt.pix.sizeimage = f->fmt.pix.bytesperline * f->fmt.pix.height;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\tif (isset) {\n\t\tcxdev->width = f->fmt.pix.width;\n\t\tcxdev->height = f->fmt.pix.height;\n\t}\n\n\treturn 0;\n}\n\nstatic int cxusb_medion_try_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\treturn cxusb_medion_try_s_fmt_vid_cap(file, f, false);\n}\n\nstatic int cxusb_medion_s_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t      struct v4l2_format *f)\n{\n\treturn cxusb_medion_try_s_fmt_vid_cap(file, f, true);\n}\n\nstatic const struct {\n\tstruct v4l2_input input;\n\tu32 inputcfg;\n} cxusb_medion_inputs[] = {\n\t{ .input = { .name = \"TV tuner\", .type = V4L2_INPUT_TYPE_TUNER,\n\t\t     .tuner = 0, .std = V4L2_STD_PAL },\n\t  .inputcfg = CX25840_COMPOSITE2, },\n\n\t{  .input = { .name = \"Composite\", .type = V4L2_INPUT_TYPE_CAMERA,\n\t\t     .std = V4L2_STD_ALL },\n\t   .inputcfg = CX25840_COMPOSITE1, },\n\n\t{  .input = { .name = \"S-Video\", .type = V4L2_INPUT_TYPE_CAMERA,\n\t\t      .std = V4L2_STD_ALL },\n\t   .inputcfg = CX25840_SVIDEO_LUMA3 | CX25840_SVIDEO_CHROMA4 }\n};\n\n#define CXUSB_INPUT_CNT ARRAY_SIZE(cxusb_medion_inputs)\n\nstatic int cxusb_medion_enum_input(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_input *inp)\n{\n\tstruct dvb_usb_device *dvbdev = video_drvdata(file);\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\tu32 index = inp->index;\n\n\tif (index >= CXUSB_INPUT_CNT)\n\t\treturn -EINVAL;\n\n\t*inp = cxusb_medion_inputs[index].input;\n\tinp->index = index;\n\tinp->capabilities |= V4L2_IN_CAP_STD;\n\n\tif (index == cxdev->input) {\n\t\tint ret;\n\t\tu32 status = 0;\n\n\t\tret = v4l2_subdev_call(cxdev->cx25840, video, g_input_status,\n\t\t\t\t       &status);\n\t\tif (ret != 0)\n\t\t\tdev_warn(&dvbdev->udev->dev,\n\t\t\t\t \"cx25840 input status query failed (%d)\\n\",\n\t\t\t\t ret);\n\t\telse\n\t\t\tinp->status = status;\n\t}\n\n\treturn 0;\n}\n\nstatic int cxusb_medion_g_input(struct file *file, void *fh,\n\t\t\t\tunsigned int *i)\n{\n\tstruct dvb_usb_device *dvbdev = video_drvdata(file);\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\n\t*i = cxdev->input;\n\n\treturn 0;\n}\n\nstatic int cxusb_medion_set_norm(struct cxusb_medion_dev *cxdev,\n\t\t\t\t v4l2_std_id norm)\n{\n\tstruct dvb_usb_device *dvbdev = cxdev->dvbdev;\n\tint ret;\n\n\tcxusb_vprintk(dvbdev, OPS,\n\t\t      \"trying to set standard for input %u to %lx\\n\",\n\t\t      (unsigned int)cxdev->input,\n\t\t      (unsigned long)norm);\n\n\t \n\tif (norm == V4L2_STD_UNKNOWN)\n\t\treturn -EINVAL;\n\n\t \n\tif (cxdev->input != 0) {\n\t\tret = v4l2_subdev_call(cxdev->cx25840, video, s_std, norm);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tgoto ret_savenorm;\n\t}\n\n\t \n\tif ((norm & ~V4L2_STD_PAL) != 0)\n\t\treturn -EINVAL;\n\n\tret = v4l2_subdev_call(cxdev->tda9887, video, s_std, norm);\n\tif (ret != 0) {\n\t\tdev_err(&dvbdev->udev->dev,\n\t\t\t\"tda9887 norm setup failed (%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = v4l2_subdev_call(cxdev->tuner, video, s_std, norm);\n\tif (ret != 0) {\n\t\tdev_err(&dvbdev->udev->dev,\n\t\t\t\"tuner norm setup failed (%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = v4l2_subdev_call(cxdev->cx25840, video, s_std, norm);\n\tif (ret != 0) {\n\t\tdev_err(&dvbdev->udev->dev,\n\t\t\t\"cx25840 norm setup failed (%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\nret_savenorm:\n\tcxdev->norm = norm;\n\n\treturn 0;\n}\n\nstatic int cxusb_medion_s_input(struct file *file, void *fh,\n\t\t\t\tunsigned int i)\n{\n\tstruct dvb_usb_device *dvbdev = video_drvdata(file);\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\tint ret;\n\tv4l2_std_id norm;\n\n\tif (i >= CXUSB_INPUT_CNT)\n\t\treturn -EINVAL;\n\n\tret = v4l2_subdev_call(cxdev->cx25840, video, s_routing,\n\t\t\t       cxusb_medion_inputs[i].inputcfg, 0, 0);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tcxdev->input = i;\n\tcxdev->videodev->tvnorms = cxusb_medion_inputs[i].input.std;\n\n\tnorm = cxdev->norm & cxusb_medion_inputs[i].input.std;\n\tif (norm == 0)\n\t\tnorm = cxusb_medion_inputs[i].input.std;\n\n\tcxusb_medion_set_norm(cxdev, norm);\n\n\treturn 0;\n}\n\nstatic int cxusb_medion_g_tuner(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_tuner *tuner)\n{\n\tstruct dvb_usb_device *dvbdev = video_drvdata(file);\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\tstruct video_device *vdev = video_devdata(file);\n\tint ret;\n\n\tif (tuner->index != 0)\n\t\treturn -EINVAL;\n\n\tif (vdev->vfl_type == VFL_TYPE_VIDEO)\n\t\ttuner->type = V4L2_TUNER_ANALOG_TV;\n\telse\n\t\ttuner->type = V4L2_TUNER_RADIO;\n\n\ttuner->capability = 0;\n\ttuner->afc = 0;\n\n\t \n\tret = v4l2_subdev_call(cxdev->tda9887, tuner, g_tuner, tuner);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tret = v4l2_subdev_call(cxdev->tuner, tuner, g_tuner, tuner);\n\tif (ret != 0)\n\t\treturn ret;\n\n\ttuner->signal = 0;\n\n\t \n\tret = v4l2_subdev_call(cxdev->cx25840, tuner, g_tuner, tuner);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (vdev->vfl_type == VFL_TYPE_VIDEO)\n\t\tstrscpy(tuner->name, \"TV tuner\", sizeof(tuner->name));\n\telse\n\t\tstrscpy(tuner->name, \"Radio tuner\", sizeof(tuner->name));\n\n\tmemset(tuner->reserved, 0, sizeof(tuner->reserved));\n\n\treturn 0;\n}\n\nstatic int cxusb_medion_s_tuner(struct file *file, void *fh,\n\t\t\t\tconst struct v4l2_tuner *tuner)\n{\n\tstruct dvb_usb_device *dvbdev = video_drvdata(file);\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\tstruct video_device *vdev = video_devdata(file);\n\tint ret;\n\n\tif (tuner->index != 0)\n\t\treturn -EINVAL;\n\n\tret = v4l2_subdev_call(cxdev->tda9887, tuner, s_tuner, tuner);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = v4l2_subdev_call(cxdev->tuner, tuner, s_tuner, tuner);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tif (vdev->vfl_type == VFL_TYPE_VIDEO)\n\t\tv4l2_subdev_call(cxdev->cx25840, video, s_std, cxdev->norm);\n\telse\n\t\tv4l2_subdev_call(cxdev->cx25840, tuner, s_radio);\n\n\treturn v4l2_subdev_call(cxdev->cx25840, tuner, s_tuner, tuner);\n}\n\nstatic int cxusb_medion_g_frequency(struct file *file, void *fh,\n\t\t\t\t    struct v4l2_frequency *freq)\n{\n\tstruct dvb_usb_device *dvbdev = video_drvdata(file);\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\n\tif (freq->tuner != 0)\n\t\treturn -EINVAL;\n\n\treturn v4l2_subdev_call(cxdev->tuner, tuner, g_frequency, freq);\n}\n\nstatic int cxusb_medion_s_frequency(struct file *file, void *fh,\n\t\t\t\t    const struct v4l2_frequency *freq)\n{\n\tstruct dvb_usb_device *dvbdev = video_drvdata(file);\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\tstruct video_device *vdev = video_devdata(file);\n\tint ret;\n\n\tif (freq->tuner != 0)\n\t\treturn -EINVAL;\n\n\tret = v4l2_subdev_call(cxdev->tda9887, tuner, s_frequency, freq);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = v4l2_subdev_call(cxdev->tuner, tuner, s_frequency, freq);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tif (vdev->vfl_type == VFL_TYPE_VIDEO)\n\t\tv4l2_subdev_call(cxdev->cx25840, video, s_std, cxdev->norm);\n\telse\n\t\tv4l2_subdev_call(cxdev->cx25840, tuner, s_radio);\n\n\treturn v4l2_subdev_call(cxdev->cx25840, tuner, s_frequency, freq);\n}\n\nstatic int cxusb_medion_g_std(struct file *file, void *fh,\n\t\t\t      v4l2_std_id *norm)\n{\n\tstruct dvb_usb_device *dvbdev = video_drvdata(file);\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\n\t*norm = cxdev->norm;\n\n\tif (*norm == V4L2_STD_UNKNOWN)\n\t\treturn -ENODATA;\n\n\treturn 0;\n}\n\nstatic int cxusb_medion_s_std(struct file *file, void *fh,\n\t\t\t      v4l2_std_id norm)\n{\n\tstruct dvb_usb_device *dvbdev = video_drvdata(file);\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\n\treturn cxusb_medion_set_norm(cxdev, norm);\n}\n\nstatic int cxusb_medion_querystd(struct file *file, void *fh,\n\t\t\t\t v4l2_std_id *norm)\n{\n\tstruct dvb_usb_device *dvbdev = video_drvdata(file);\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\tv4l2_std_id norm_mask;\n\tint ret;\n\n\t \n\tif (cxdev->input == 0)\n\t\tnorm_mask = V4L2_STD_PAL;\n\telse\n\t\tnorm_mask = V4L2_STD_ALL;\n\n\tret = v4l2_subdev_call(cxdev->cx25840, video, querystd, norm);\n\tif (ret != 0) {\n\t\tcxusb_vprintk(dvbdev, OPS,\n\t\t\t      \"cannot get detected standard for input %u\\n\",\n\t\t\t      (unsigned int)cxdev->input);\n\t\treturn ret;\n\t}\n\n\tcxusb_vprintk(dvbdev, OPS, \"input %u detected standard is %lx\\n\",\n\t\t      (unsigned int)cxdev->input, (unsigned long)*norm);\n\t*norm &= norm_mask;\n\n\treturn 0;\n}\n\nstatic int cxusb_medion_log_status(struct file *file, void *fh)\n{\n\tstruct dvb_usb_device *dvbdev = video_drvdata(file);\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\n\tv4l2_device_call_all(&cxdev->v4l2dev, 0, core, log_status);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops cxusb_video_ioctl = {\n\t.vidioc_querycap = cxusb_medion_v_querycap,\n\t.vidioc_enum_fmt_vid_cap = cxusb_medion_v_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap = cxusb_medion_g_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap = cxusb_medion_s_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap = cxusb_medion_try_fmt_vid_cap,\n\t.vidioc_enum_input = cxusb_medion_enum_input,\n\t.vidioc_g_input = cxusb_medion_g_input,\n\t.vidioc_s_input = cxusb_medion_s_input,\n\t.vidioc_g_tuner = cxusb_medion_g_tuner,\n\t.vidioc_s_tuner = cxusb_medion_s_tuner,\n\t.vidioc_g_frequency = cxusb_medion_g_frequency,\n\t.vidioc_s_frequency = cxusb_medion_s_frequency,\n\t.vidioc_g_std = cxusb_medion_g_std,\n\t.vidioc_s_std = cxusb_medion_s_std,\n\t.vidioc_querystd = cxusb_medion_querystd,\n\t.vidioc_log_status = cxusb_medion_log_status,\n\t.vidioc_reqbufs = vb2_ioctl_reqbufs,\n\t.vidioc_querybuf = vb2_ioctl_querybuf,\n\t.vidioc_qbuf = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf = vb2_ioctl_dqbuf,\n\t.vidioc_create_bufs = vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf = vb2_ioctl_prepare_buf,\n\t.vidioc_streamon = vb2_ioctl_streamon,\n\t.vidioc_streamoff = vb2_ioctl_streamoff\n};\n\nstatic const struct v4l2_ioctl_ops cxusb_radio_ioctl = {\n\t.vidioc_querycap = cxusb_medion_v_querycap,\n\t.vidioc_g_tuner = cxusb_medion_g_tuner,\n\t.vidioc_s_tuner = cxusb_medion_s_tuner,\n\t.vidioc_g_frequency = cxusb_medion_g_frequency,\n\t.vidioc_s_frequency = cxusb_medion_s_frequency,\n\t.vidioc_log_status = cxusb_medion_log_status\n};\n\n \nstatic struct v4l2_subdev_io_pin_config cxusub_medion_pin_config[] = {\n\t{ .pin = CX25840_PIN_DVALID_PRGM0, .function = CX25840_PAD_DEFAULT,\n\t  .strength = CX25840_PIN_DRIVE_MEDIUM },\n\t{ .pin = CX25840_PIN_PLL_CLK_PRGM7, .function = CX25840_PAD_AUX_PLL },\n\t{ .pin = CX25840_PIN_HRESET_PRGM2, .function = CX25840_PAD_ACTIVE,\n\t  .strength = CX25840_PIN_DRIVE_MEDIUM }\n};\n\nint cxusb_medion_analog_init(struct dvb_usb_device *dvbdev)\n{\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\tu8 tuner_analog_msg_data[] = { 0x9c, 0x60, 0x85, 0x54 };\n\tstruct i2c_msg tuner_analog_msg = { .addr = 0x61, .flags = 0,\n\t\t\t\t\t    .buf = tuner_analog_msg_data,\n\t\t\t\t\t    .len =\n\t\t\t\t\t    sizeof(tuner_analog_msg_data) };\n\tstruct v4l2_subdev_format subfmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret;\n\n\t \n\tret = i2c_transfer(&dvbdev->i2c_adap, &tuner_analog_msg, 1);\n\tif (ret != 1)\n\t\tdev_warn(&dvbdev->udev->dev,\n\t\t\t \"tuner analog switch failed (%d)\\n\", ret);\n\n\t \n\tret = v4l2_subdev_call(cxdev->cx25840, core, reset, 0);\n\tif (ret != 0)\n\t\tdev_warn(&dvbdev->udev->dev,\n\t\t\t \"cx25840 reset failed (%d)\\n\", ret);\n\n\tret = v4l2_subdev_call(cxdev->cx25840, video, s_routing,\n\t\t\t       CX25840_COMPOSITE1, 0, 0);\n\tif (ret != 0)\n\t\tdev_warn(&dvbdev->udev->dev,\n\t\t\t \"cx25840 initial input setting failed (%d)\\n\", ret);\n\n\t \n\tcxdev->input = 1;\n\tcxdev->videodev->tvnorms = V4L2_STD_ALL;\n\tcxdev->norm = V4L2_STD_PAL;\n\n\t \n\n\tret = v4l2_subdev_call(cxdev->cx25840, core, s_io_pin_config,\n\t\t\t       ARRAY_SIZE(cxusub_medion_pin_config),\n\t\t\t       cxusub_medion_pin_config);\n\tif (ret != 0)\n\t\tdev_warn(&dvbdev->udev->dev,\n\t\t\t \"cx25840 pin config failed (%d)\\n\", ret);\n\n\t \n\tv4l2_subdev_call(cxdev->tda9887, video, s_std, cxdev->norm);\n\tv4l2_subdev_call(cxdev->tuner, video, s_std, cxdev->norm);\n\tv4l2_subdev_call(cxdev->cx25840, video, s_std, cxdev->norm);\n\n\tsubfmt.format.width = cxdev->width;\n\tsubfmt.format.height = cxdev->height;\n\tsubfmt.format.code = MEDIA_BUS_FMT_FIXED;\n\tsubfmt.format.field = V4L2_FIELD_SEQ_TB;\n\tsubfmt.format.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\tret = v4l2_subdev_call(cxdev->cx25840, pad, set_fmt, NULL, &subfmt);\n\tif (ret != 0)\n\t\tdev_warn(&dvbdev->udev->dev,\n\t\t\t \"cx25840 format set failed (%d)\\n\", ret);\n\n\tif (ret == 0) {\n\t\tcxdev->width = subfmt.format.width;\n\t\tcxdev->height = subfmt.format.height;\n\t}\n\n\treturn 0;\n}\n\nstatic int cxusb_videoradio_open(struct file *f)\n{\n\tstruct dvb_usb_device *dvbdev = video_drvdata(f);\n\tint ret;\n\n\t \n\tret = cxusb_medion_get(dvbdev, CXUSB_OPEN_ANALOG);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = v4l2_fh_open(f);\n\tif (ret != 0)\n\t\tgoto ret_release;\n\n\tcxusb_vprintk(dvbdev, OPS, \"got open\\n\");\n\n\treturn 0;\n\nret_release:\n\tcxusb_medion_put(dvbdev);\n\n\treturn ret;\n}\n\nstatic int cxusb_videoradio_release(struct file *f)\n{\n\tstruct video_device *vdev = video_devdata(f);\n\tstruct dvb_usb_device *dvbdev = video_drvdata(f);\n\tint ret;\n\n\tcxusb_vprintk(dvbdev, OPS, \"got release\\n\");\n\n\tif (vdev->vfl_type == VFL_TYPE_VIDEO)\n\t\tret = vb2_fop_release(f);\n\telse\n\t\tret = v4l2_fh_release(f);\n\n\tcxusb_medion_put(dvbdev);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_file_operations cxusb_video_fops = {\n\t.owner = THIS_MODULE,\n\t.read = vb2_fop_read,\n\t.poll = vb2_fop_poll,\n\t.unlocked_ioctl = video_ioctl2,\n\t.mmap = vb2_fop_mmap,\n\t.open = cxusb_videoradio_open,\n\t.release = cxusb_videoradio_release\n};\n\nstatic const struct v4l2_file_operations cxusb_radio_fops = {\n\t.owner = THIS_MODULE,\n\t.unlocked_ioctl = video_ioctl2,\n\t.open = cxusb_videoradio_open,\n\t.release = cxusb_videoradio_release\n};\n\nstatic void cxusb_medion_v4l2_release(struct v4l2_device *v4l2_dev)\n{\n\tstruct cxusb_medion_dev *cxdev =\n\t\tcontainer_of(v4l2_dev, struct cxusb_medion_dev, v4l2dev);\n\tstruct dvb_usb_device *dvbdev = cxdev->dvbdev;\n\n\tcxusb_vprintk(dvbdev, OPS, \"v4l2 device release\\n\");\n\n\tv4l2_device_unregister(&cxdev->v4l2dev);\n\n\tmutex_destroy(&cxdev->dev_lock);\n\n\twhile (completion_done(&cxdev->v4l2_release))\n\t\tschedule();\n\n\tcomplete(&cxdev->v4l2_release);\n}\n\nstatic void cxusb_medion_videodev_release(struct video_device *vdev)\n{\n\tstruct dvb_usb_device *dvbdev = video_get_drvdata(vdev);\n\n\tcxusb_vprintk(dvbdev, OPS, \"video device release\\n\");\n\n\tvideo_device_release(vdev);\n}\n\nstatic int cxusb_medion_register_analog_video(struct dvb_usb_device *dvbdev)\n{\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\tint ret;\n\n\tcxdev->videoqueue.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tcxdev->videoqueue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ |\n\t\tVB2_DMABUF;\n\tcxdev->videoqueue.ops = &cxdev_video_qops;\n\tcxdev->videoqueue.mem_ops = &vb2_vmalloc_memops;\n\tcxdev->videoqueue.drv_priv = dvbdev;\n\tcxdev->videoqueue.buf_struct_size =\n\t\tsizeof(struct cxusb_medion_vbuffer);\n\tcxdev->videoqueue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tcxdev->videoqueue.min_buffers_needed = 6;\n\tcxdev->videoqueue.lock = &cxdev->dev_lock;\n\n\tret = vb2_queue_init(&cxdev->videoqueue);\n\tif (ret) {\n\t\tdev_err(&dvbdev->udev->dev,\n\t\t\t\"video queue init failed, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcxdev->videodev = video_device_alloc();\n\tif (!cxdev->videodev) {\n\t\tdev_err(&dvbdev->udev->dev, \"video device alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcxdev->videodev->device_caps = videocaps;\n\tcxdev->videodev->fops = &cxusb_video_fops;\n\tcxdev->videodev->v4l2_dev = &cxdev->v4l2dev;\n\tcxdev->videodev->queue = &cxdev->videoqueue;\n\tstrscpy(cxdev->videodev->name, \"cxusb\", sizeof(cxdev->videodev->name));\n\tcxdev->videodev->vfl_dir = VFL_DIR_RX;\n\tcxdev->videodev->ioctl_ops = &cxusb_video_ioctl;\n\tcxdev->videodev->tvnorms = V4L2_STD_ALL;\n\tcxdev->videodev->release = cxusb_medion_videodev_release;\n\tcxdev->videodev->lock = &cxdev->dev_lock;\n\tvideo_set_drvdata(cxdev->videodev, dvbdev);\n\n\tret = video_register_device(cxdev->videodev, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tdev_err(&dvbdev->udev->dev,\n\t\t\t\"video device register failed, ret = %d\\n\", ret);\n\t\tgoto ret_vrelease;\n\t}\n\n\treturn 0;\n\nret_vrelease:\n\tvideo_device_release(cxdev->videodev);\n\treturn ret;\n}\n\nstatic int cxusb_medion_register_analog_radio(struct dvb_usb_device *dvbdev)\n{\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\tint ret;\n\n\tcxdev->radiodev = video_device_alloc();\n\tif (!cxdev->radiodev) {\n\t\tdev_err(&dvbdev->udev->dev, \"radio device alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcxdev->radiodev->device_caps = radiocaps;\n\tcxdev->radiodev->fops = &cxusb_radio_fops;\n\tcxdev->radiodev->v4l2_dev = &cxdev->v4l2dev;\n\tstrscpy(cxdev->radiodev->name, \"cxusb\", sizeof(cxdev->radiodev->name));\n\tcxdev->radiodev->vfl_dir = VFL_DIR_RX;\n\tcxdev->radiodev->ioctl_ops = &cxusb_radio_ioctl;\n\tcxdev->radiodev->release = video_device_release;\n\tcxdev->radiodev->lock = &cxdev->dev_lock;\n\tvideo_set_drvdata(cxdev->radiodev, dvbdev);\n\n\tret = video_register_device(cxdev->radiodev, VFL_TYPE_RADIO, -1);\n\tif (ret) {\n\t\tdev_err(&dvbdev->udev->dev,\n\t\t\t\"radio device register failed, ret = %d\\n\", ret);\n\t\tvideo_device_release(cxdev->radiodev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cxusb_medion_register_analog_subdevs(struct dvb_usb_device *dvbdev)\n{\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\tint ret;\n\tstruct tuner_setup tun_setup;\n\n\t \n\tcxdev->cx25840 = v4l2_i2c_new_subdev(&cxdev->v4l2dev,\n\t\t\t\t\t     &dvbdev->i2c_adap,\n\t\t\t\t\t     \"cx25840\", 0x44, NULL);\n\tif (!cxdev->cx25840) {\n\t\tdev_err(&dvbdev->udev->dev, \"cx25840 not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = v4l2_subdev_call(cxdev->cx25840, core, init,\n\t\t\t       CX25840_VCONFIG_FMT_BT656 |\n\t\t\t       CX25840_VCONFIG_RES_8BIT |\n\t\t\t       CX25840_VCONFIG_VBIRAW_DISABLED |\n\t\t\t       CX25840_VCONFIG_ANCDATA_DISABLED |\n\t\t\t       CX25840_VCONFIG_ACTIVE_COMPOSITE |\n\t\t\t       CX25840_VCONFIG_VALID_ANDACTIVE |\n\t\t\t       CX25840_VCONFIG_HRESETW_NORMAL |\n\t\t\t       CX25840_VCONFIG_CLKGATE_NONE |\n\t\t\t       CX25840_VCONFIG_DCMODE_DWORDS);\n\tif (ret != 0) {\n\t\tdev_err(&dvbdev->udev->dev,\n\t\t\t\"cx25840 init failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tcxdev->tuner = v4l2_i2c_new_subdev(&cxdev->v4l2dev,\n\t\t\t\t\t   &dvbdev->i2c_adap,\n\t\t\t\t\t   \"tuner\", 0x61, NULL);\n\tif (!cxdev->tuner) {\n\t\tdev_err(&dvbdev->udev->dev, \"tuner not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tmemset(&tun_setup, 0, sizeof(tun_setup));\n\ttun_setup.addr = 0x61;\n\ttun_setup.type = TUNER_PHILIPS_FMD1216ME_MK3;\n\ttun_setup.mode_mask = T_RADIO | T_ANALOG_TV;\n\tv4l2_subdev_call(cxdev->tuner, tuner, s_type_addr, &tun_setup);\n\n\t \n\tcxdev->tda9887 = v4l2_i2c_new_subdev(&cxdev->v4l2dev,\n\t\t\t\t\t     &dvbdev->i2c_adap,\n\t\t\t\t\t     \"tuner\", 0x43, NULL);\n\tif (!cxdev->tda9887) {\n\t\tdev_err(&dvbdev->udev->dev, \"tda9887 not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nint cxusb_medion_register_analog(struct dvb_usb_device *dvbdev)\n{\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\tint ret;\n\n\tmutex_init(&cxdev->dev_lock);\n\n\tinit_completion(&cxdev->v4l2_release);\n\n\tcxdev->v4l2dev.release = cxusb_medion_v4l2_release;\n\n\tret = v4l2_device_register(&dvbdev->udev->dev, &cxdev->v4l2dev);\n\tif (ret != 0) {\n\t\tdev_err(&dvbdev->udev->dev,\n\t\t\t\"V4L2 device registration failed, ret = %d\\n\", ret);\n\t\tmutex_destroy(&cxdev->dev_lock);\n\t\treturn ret;\n\t}\n\n\tret = cxusb_medion_register_analog_subdevs(dvbdev);\n\tif (ret)\n\t\tgoto ret_unregister;\n\n\tINIT_WORK(&cxdev->urbwork, cxusb_medion_v_complete_work);\n\tINIT_LIST_HEAD(&cxdev->buflist);\n\n\tcxdev->width = 320;\n\tcxdev->height = 240;\n\n\tret = cxusb_medion_register_analog_video(dvbdev);\n\tif (ret)\n\t\tgoto ret_unregister;\n\n\tret = cxusb_medion_register_analog_radio(dvbdev);\n\tif (ret)\n\t\tgoto ret_vunreg;\n\n\treturn 0;\n\nret_vunreg:\n\tvb2_video_unregister_device(cxdev->videodev);\n\nret_unregister:\n\tv4l2_device_put(&cxdev->v4l2dev);\n\twait_for_completion(&cxdev->v4l2_release);\n\n\treturn ret;\n}\n\nvoid cxusb_medion_unregister_analog(struct dvb_usb_device *dvbdev)\n{\n\tstruct cxusb_medion_dev *cxdev = dvbdev->priv;\n\n\tcxusb_vprintk(dvbdev, OPS, \"unregistering analog\\n\");\n\n\tvideo_unregister_device(cxdev->radiodev);\n\tvb2_video_unregister_device(cxdev->videodev);\n\n\tv4l2_device_put(&cxdev->v4l2dev);\n\twait_for_completion(&cxdev->v4l2_release);\n\n\tcxusb_vprintk(dvbdev, OPS, \"analog unregistered\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}