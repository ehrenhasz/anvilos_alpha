{
  "module_name": "vp7045.c",
  "hash_id": "2db7d4bb72bebfd29ca1602e8311df39a3726f82d697202a1a27b6e88cb29ae7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/vp7045.c",
  "human_readable_source": "\n \n#include \"vp7045.h\"\n\n \nstatic int dvb_usb_vp7045_debug;\nmodule_param_named(debug,dvb_usb_vp7045_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=info,xfer=2,rc=4 (or-able)).\" DVB_USB_DEBUG_STATUS);\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n#define deb_info(args...) dprintk(dvb_usb_vp7045_debug,0x01,args)\n#define deb_xfer(args...) dprintk(dvb_usb_vp7045_debug,0x02,args)\n#define deb_rc(args...)   dprintk(dvb_usb_vp7045_debug,0x04,args)\n\nint vp7045_usb_op(struct dvb_usb_device *d, u8 cmd, u8 *out, int outlen, u8 *in, int inlen, int msec)\n{\n\tint ret = 0;\n\tu8 *buf = d->priv;\n\n\tbuf[0] = cmd;\n\n\tif (outlen > 19)\n\t\toutlen = 19;\n\n\tif (inlen > 11)\n\t\tinlen = 11;\n\n\tret = mutex_lock_interruptible(&d->usb_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tif (out != NULL && outlen > 0)\n\t\tmemcpy(&buf[1], out, outlen);\n\n\tdeb_xfer(\"out buffer: \");\n\tdebug_dump(buf, outlen+1, deb_xfer);\n\n\n\tif (usb_control_msg(d->udev,\n\t\t\tusb_sndctrlpipe(d->udev,0),\n\t\t\tTH_COMMAND_OUT, USB_TYPE_VENDOR | USB_DIR_OUT, 0, 0,\n\t\t\tbuf, 20, 2000) != 20) {\n\t\terr(\"USB control message 'out' went wrong.\");\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\n\tmsleep(msec);\n\n\tif (usb_control_msg(d->udev,\n\t\t\tusb_rcvctrlpipe(d->udev,0),\n\t\t\tTH_COMMAND_IN, USB_TYPE_VENDOR | USB_DIR_IN, 0, 0,\n\t\t\tbuf, 12, 2000) != 12) {\n\t\terr(\"USB control message 'in' went wrong.\");\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\n\tdeb_xfer(\"in buffer: \");\n\tdebug_dump(buf, 12, deb_xfer);\n\n\tif (in != NULL && inlen > 0)\n\t\tmemcpy(in, &buf[1], inlen);\n\nunlock:\n\tmutex_unlock(&d->usb_mutex);\n\n\treturn ret;\n}\n\nu8 vp7045_read_reg(struct dvb_usb_device *d, u8 reg)\n{\n\tu8 obuf[2] = { 0 },v;\n\tobuf[1] = reg;\n\n\tvp7045_usb_op(d,TUNER_REG_READ,obuf,2,&v,1,30);\n\n\treturn v;\n}\n\nstatic int vp7045_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tu8 v = onoff;\n\treturn vp7045_usb_op(d,SET_TUNER_POWER,&v,1,NULL,0,150);\n}\n\nstatic int vp7045_rc_query(struct dvb_usb_device *d)\n{\n\tint ret;\n\tu8 key;\n\n\tret = vp7045_usb_op(d, RC_VAL_READ, NULL, 0, &key, 1, 20);\n\tif (ret)\n\t\treturn ret;\n\n\tdeb_rc(\"remote query key: %x\\n\", key);\n\n\tif (key != 0x44) {\n\t\t \n\t\trc_keydown(d->rc_dev, RC_PROTO_NEC, RC_SCANCODE_NEC(0, key), 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int vp7045_read_eeprom(struct dvb_usb_device *d,u8 *buf, int len, int offset)\n{\n\tint i, ret;\n\tu8 v, br[2];\n\tfor (i=0; i < len; i++) {\n\t\tv = offset + i;\n\t\tret = vp7045_usb_op(d, GET_EE_VALUE, &v, 1, br, 2, 5);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbuf[i] = br[1];\n\t}\n\tdeb_info(\"VP7045 EEPROM read (offs: %d, len: %d) : \", offset, i);\n\tdebug_dump(buf, i, deb_info);\n\treturn 0;\n}\n\nstatic int vp7045_read_mac_addr(struct dvb_usb_device *d,u8 mac[6])\n{\n\treturn vp7045_read_eeprom(d,mac, 6, MAC_0_ADDR);\n}\n\nstatic int vp7045_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tu8 buf[255] = { 0 };\n\n\tvp7045_usb_op(adap->dev,VENDOR_STRING_READ,NULL,0,buf,20,0);\n\tbuf[10] = '\\0';\n\tdeb_info(\"firmware says: %s \",buf);\n\n\tvp7045_usb_op(adap->dev,PRODUCT_STRING_READ,NULL,0,buf,20,0);\n\tbuf[10] = '\\0';\n\tdeb_info(\"%s \",buf);\n\n\tvp7045_usb_op(adap->dev,FW_VERSION_READ,NULL,0,buf,20,0);\n\tbuf[10] = '\\0';\n\tdeb_info(\"v%s\\n\",buf);\n\n \n \n\n\tadap->fe_adap[0].fe = vp7045_fe_attach(adap->dev);\n\n\treturn 0;\n}\n\nstatic struct dvb_usb_device_properties vp7045_properties;\n\nstatic int vp7045_usb_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\treturn dvb_usb_device_init(intf, &vp7045_properties,\n\t\t\t\t   THIS_MODULE, NULL, adapter_nr);\n}\n\nenum {\n\tVISIONPLUS_VP7045_COLD,\n\tVISIONPLUS_VP7045_WARM,\n\tVISIONPLUS_TINYUSB2_COLD,\n\tVISIONPLUS_TINYUSB2_WARM,\n};\n\nstatic struct usb_device_id vp7045_usb_table[] = {\n\tDVB_USB_DEV(VISIONPLUS, VISIONPLUS_VP7045_COLD),\n\tDVB_USB_DEV(VISIONPLUS, VISIONPLUS_VP7045_WARM),\n\tDVB_USB_DEV(VISIONPLUS, VISIONPLUS_TINYUSB2_COLD),\n\tDVB_USB_DEV(VISIONPLUS, VISIONPLUS_TINYUSB2_WARM),\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, vp7045_usb_table);\n\nstatic struct dvb_usb_device_properties vp7045_properties = {\n\t.usb_ctrl = CYPRESS_FX2,\n\t.firmware = \"dvb-usb-vp7045-01.fw\",\n\t.size_of_priv = 20,\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.frontend_attach  = vp7045_frontend_attach,\n\t\t\t \n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 7,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t}\n\t},\n\t.power_ctrl       = vp7045_power_ctrl,\n\t.read_mac_address = vp7045_read_mac_addr,\n\n\t.rc.core = {\n\t\t.rc_interval\t= 400,\n\t\t.rc_codes\t= RC_MAP_TWINHAN_VP1027_DVBS,\n\t\t.module_name    = KBUILD_MODNAME,\n\t\t.rc_query\t= vp7045_rc_query,\n\t\t.allowed_protos = RC_PROTO_BIT_NEC,\n\t\t.scancode_mask\t= 0xff,\n\t},\n\n\t.num_device_descs = 2,\n\t.devices = {\n\t\t{ .name = \"Twinhan USB2.0 DVB-T receiver (TwinhanDTV Alpha/MagicBox II)\",\n\t\t  .cold_ids = { &vp7045_usb_table[VISIONPLUS_VP7045_COLD], NULL },\n\t\t  .warm_ids = { &vp7045_usb_table[VISIONPLUS_VP7045_WARM], NULL },\n\t\t},\n\t\t{ .name = \"DigitalNow TinyUSB 2 DVB-t Receiver\",\n\t\t  .cold_ids = { &vp7045_usb_table[VISIONPLUS_TINYUSB2_COLD], NULL },\n\t\t  .warm_ids = { &vp7045_usb_table[VISIONPLUS_TINYUSB2_WARM], NULL },\n\t\t},\n\t\t{ NULL },\n\t}\n};\n\n \nstatic struct usb_driver vp7045_usb_driver = {\n\t.name\t\t= \"dvb_usb_vp7045\",\n\t.probe\t\t= vp7045_usb_probe,\n\t.disconnect\t= dvb_usb_device_exit,\n\t.id_table\t= vp7045_usb_table,\n};\n\nmodule_usb_driver(vp7045_usb_driver);\n\nMODULE_AUTHOR(\"Patrick Boettcher <patrick.boettcher@posteo.de>\");\nMODULE_DESCRIPTION(\"Driver for Twinhan MagicBox/Alpha and DNTV tinyUSB2 DVB-T USB2.0\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}