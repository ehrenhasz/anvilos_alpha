{
  "module_name": "dvb-usb-init.c",
  "hash_id": "74ad19b74bc41b3a34717994846684abf89b264b39e50beacfc7e62b841db987",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/dvb-usb-init.c",
  "human_readable_source": "\n \n#include \"dvb-usb-common.h\"\n\n \nint dvb_usb_debug;\nmodule_param_named(debug, dvb_usb_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=info,xfer=2,pll=4,ts=8,err=16,rc=32,fw=64,mem=128,uxfer=256  (or-able)).\" DVB_USB_DEBUG_STATUS);\n\nint dvb_usb_disable_rc_polling;\nmodule_param_named(disable_rc_polling, dvb_usb_disable_rc_polling, int, 0644);\nMODULE_PARM_DESC(disable_rc_polling, \"disable remote control polling (default: 0).\");\n\nstatic int dvb_usb_force_pid_filter_usage;\nmodule_param_named(force_pid_filter_usage, dvb_usb_force_pid_filter_usage, int, 0444);\nMODULE_PARM_DESC(force_pid_filter_usage, \"force all dvb-usb-devices to use a PID filter, if any (default: 0).\");\n\nstatic int dvb_usb_adapter_init(struct dvb_usb_device *d, short *adapter_nrs)\n{\n\tstruct dvb_usb_adapter *adap;\n\tint ret, n, o;\n\n\tfor (n = 0; n < d->props.num_adapters; n++) {\n\t\tadap = &d->adapter[n];\n\t\tadap->dev = d;\n\t\tadap->id  = n;\n\n\t\tmemcpy(&adap->props, &d->props.adapter[n], sizeof(struct dvb_usb_adapter_properties));\n\n\t\tfor (o = 0; o < adap->props.num_frontends; o++) {\n\t\t\tstruct dvb_usb_adapter_fe_properties *props = &adap->props.fe[o];\n\t\t\t \n\t\t\tif (d->udev->speed == USB_SPEED_FULL && !(props->caps & DVB_USB_ADAP_HAS_PID_FILTER)) {\n\t\t\t\terr(\"This USB2.0 device cannot be run on a USB1.1 port. (it lacks a hardware PID filter)\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\n\t\t\tif ((d->udev->speed == USB_SPEED_FULL && props->caps & DVB_USB_ADAP_HAS_PID_FILTER) ||\n\t\t\t\t(props->caps & DVB_USB_ADAP_NEED_PID_FILTERING)) {\n\t\t\t\tinfo(\"will use the device's hardware PID filter (table count: %d).\", props->pid_filter_count);\n\t\t\t\tadap->fe_adap[o].pid_filtering  = 1;\n\t\t\t\tadap->fe_adap[o].max_feed_count = props->pid_filter_count;\n\t\t\t} else {\n\t\t\t\tinfo(\"will pass the complete MPEG2 transport stream to the software demuxer.\");\n\t\t\t\tadap->fe_adap[o].pid_filtering  = 0;\n\t\t\t\tadap->fe_adap[o].max_feed_count = 255;\n\t\t\t}\n\n\t\t\tif (!adap->fe_adap[o].pid_filtering &&\n\t\t\t\tdvb_usb_force_pid_filter_usage &&\n\t\t\t\tprops->caps & DVB_USB_ADAP_HAS_PID_FILTER) {\n\t\t\t\tinfo(\"pid filter enabled by module option.\");\n\t\t\t\tadap->fe_adap[o].pid_filtering  = 1;\n\t\t\t\tadap->fe_adap[o].max_feed_count = props->pid_filter_count;\n\t\t\t}\n\n\t\t\tif (props->size_of_priv > 0) {\n\t\t\t\tadap->fe_adap[o].priv = kzalloc(props->size_of_priv, GFP_KERNEL);\n\t\t\t\tif (adap->fe_adap[o].priv == NULL) {\n\t\t\t\t\terr(\"no memory for priv for adapter %d fe %d.\", n, o);\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (adap->props.size_of_priv > 0) {\n\t\t\tadap->priv = kzalloc(adap->props.size_of_priv, GFP_KERNEL);\n\t\t\tif (adap->priv == NULL) {\n\t\t\t\terr(\"no memory for priv for adapter %d.\", n);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tret = dvb_usb_adapter_stream_init(adap);\n\t\tif (ret)\n\t\t\tgoto stream_init_err;\n\n\t\tret = dvb_usb_adapter_dvb_init(adap, adapter_nrs);\n\t\tif (ret)\n\t\t\tgoto dvb_init_err;\n\n\t\tret = dvb_usb_adapter_frontend_init(adap);\n\t\tif (ret)\n\t\t\tgoto frontend_init_err;\n\n\t\t \n\t\tif (adap->fe_adap[1].fe && adap->dvb_adap.mfe_shared < 1)\n\t\t\tadap->dvb_adap.mfe_shared = 1;\n\n\t\td->num_adapters_initialized++;\n\t\td->state |= DVB_USB_STATE_DVB;\n\t}\n\n\t \n\tif (d->props.generic_bulk_ctrl_endpoint != 0) {\n\t\tusb_clear_halt(d->udev, usb_sndbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\n\t\tusb_clear_halt(d->udev, usb_rcvbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\n\t}\n\n\treturn 0;\n\nfrontend_init_err:\n\tdvb_usb_adapter_dvb_exit(adap);\ndvb_init_err:\n\tdvb_usb_adapter_stream_exit(adap);\nstream_init_err:\n\tkfree(adap->priv);\n\treturn ret;\n}\n\nstatic int dvb_usb_adapter_exit(struct dvb_usb_device *d)\n{\n\tint n;\n\n\tfor (n = 0; n < d->num_adapters_initialized; n++) {\n\t\tdvb_usb_adapter_frontend_exit(&d->adapter[n]);\n\t\tdvb_usb_adapter_dvb_exit(&d->adapter[n]);\n\t\tdvb_usb_adapter_stream_exit(&d->adapter[n]);\n\t\tkfree(d->adapter[n].priv);\n\t}\n\td->num_adapters_initialized = 0;\n\td->state &= ~DVB_USB_STATE_DVB;\n\treturn 0;\n}\n\n\n \nstatic int dvb_usb_exit(struct dvb_usb_device *d)\n{\n\tdeb_info(\"state before exiting everything: %x\\n\", d->state);\n\tdvb_usb_remote_exit(d);\n\tdvb_usb_adapter_exit(d);\n\tdvb_usb_i2c_exit(d);\n\tdeb_info(\"state should be zero now: %x\\n\", d->state);\n\td->state = DVB_USB_STATE_INIT;\n\n\tif (d->priv != NULL && d->props.priv_destroy != NULL)\n\t\td->props.priv_destroy(d);\n\n\tkfree(d->priv);\n\tkfree(d);\n\treturn 0;\n}\n\nstatic int dvb_usb_init(struct dvb_usb_device *d, short *adapter_nums)\n{\n\tint ret = 0;\n\n\tmutex_init(&d->data_mutex);\n\tmutex_init(&d->usb_mutex);\n\tmutex_init(&d->i2c_mutex);\n\n\td->state = DVB_USB_STATE_INIT;\n\n\tif (d->props.size_of_priv > 0) {\n\t\td->priv = kzalloc(d->props.size_of_priv, GFP_KERNEL);\n\t\tif (d->priv == NULL) {\n\t\t\terr(\"no memory for priv in 'struct dvb_usb_device'\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (d->props.priv_init != NULL) {\n\t\t\tret = d->props.priv_init(d);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto err_priv_init;\n\t\t}\n\t}\n\n\t \n\tdvb_usb_device_power_ctrl(d, 1);\n\n\tret = dvb_usb_i2c_init(d);\n\tif (ret)\n\t\tgoto err_i2c_init;\n\tret = dvb_usb_adapter_init(d, adapter_nums);\n\tif (ret)\n\t\tgoto err_adapter_init;\n\n\tif ((ret = dvb_usb_remote_init(d)))\n\t\terr(\"could not initialize remote control.\");\n\n\tdvb_usb_device_power_ctrl(d, 0);\n\n\treturn 0;\n\nerr_adapter_init:\n\tdvb_usb_adapter_exit(d);\n\tdvb_usb_i2c_exit(d);\nerr_i2c_init:\n\tif (d->priv && d->props.priv_destroy)\n\t\td->props.priv_destroy(d);\nerr_priv_init:\n\tkfree(d->priv);\n\td->priv = NULL;\n\treturn ret;\n}\n\n \nstatic const struct dvb_usb_device_description *dvb_usb_find_device(struct usb_device *udev, const struct dvb_usb_device_properties *props, int *cold)\n{\n\tint i, j;\n\tconst struct dvb_usb_device_description *desc = NULL;\n\n\t*cold = -1;\n\n\tfor (i = 0; i < props->num_device_descs; i++) {\n\n\t\tfor (j = 0; j < DVB_USB_ID_MAX_NUM && props->devices[i].cold_ids[j] != NULL; j++) {\n\t\t\tdeb_info(\"check for cold %x %x\\n\", props->devices[i].cold_ids[j]->idVendor, props->devices[i].cold_ids[j]->idProduct);\n\t\t\tif (props->devices[i].cold_ids[j]->idVendor  == le16_to_cpu(udev->descriptor.idVendor) &&\n\t\t\t\tprops->devices[i].cold_ids[j]->idProduct == le16_to_cpu(udev->descriptor.idProduct)) {\n\t\t\t\t*cold = 1;\n\t\t\t\tdesc = &props->devices[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (desc != NULL)\n\t\t\tbreak;\n\n\t\tfor (j = 0; j < DVB_USB_ID_MAX_NUM && props->devices[i].warm_ids[j] != NULL; j++) {\n\t\t\tdeb_info(\"check for warm %x %x\\n\", props->devices[i].warm_ids[j]->idVendor, props->devices[i].warm_ids[j]->idProduct);\n\t\t\tif (props->devices[i].warm_ids[j]->idVendor == le16_to_cpu(udev->descriptor.idVendor) &&\n\t\t\t\tprops->devices[i].warm_ids[j]->idProduct == le16_to_cpu(udev->descriptor.idProduct)) {\n\t\t\t\t*cold = 0;\n\t\t\t\tdesc = &props->devices[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (desc != NULL && props->identify_state != NULL)\n\t\tprops->identify_state(udev, props, &desc, cold);\n\n\treturn desc;\n}\n\nint dvb_usb_device_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tif (onoff)\n\t\td->powered++;\n\telse\n\t\td->powered--;\n\n\tif (d->powered == 0 || (onoff && d->powered == 1)) {  \n\t\tdeb_info(\"power control: %d\\n\", onoff);\n\t\tif (d->props.power_ctrl)\n\t\t\treturn d->props.power_ctrl(d, onoff);\n\t}\n\treturn 0;\n}\n\n \nint dvb_usb_device_init(struct usb_interface *intf,\n\t\t\tconst struct dvb_usb_device_properties *props,\n\t\t\tstruct module *owner, struct dvb_usb_device **du,\n\t\t\tshort *adapter_nums)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct dvb_usb_device *d = NULL;\n\tconst struct dvb_usb_device_description *desc = NULL;\n\n\tint ret = -ENOMEM, cold = 0;\n\n\tif (du != NULL)\n\t\t*du = NULL;\n\n\td = kzalloc(sizeof(*d), GFP_KERNEL);\n\tif (!d) {\n\t\terr(\"no memory for 'struct dvb_usb_device'\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(&d->props, props, sizeof(struct dvb_usb_device_properties));\n\n\tdesc = dvb_usb_find_device(udev, &d->props, &cold);\n\tif (!desc) {\n\t\tdeb_err(\"something went very wrong, device was not found in current device list - let's see what comes next.\\n\");\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (cold) {\n\t\tinfo(\"found a '%s' in cold state, will try to load a firmware\", desc->name);\n\t\tret = dvb_usb_download_firmware(udev, props);\n\t\tif (!props->no_reconnect || ret != 0)\n\t\t\tgoto error;\n\t}\n\n\tinfo(\"found a '%s' in warm state.\", desc->name);\n\td->udev = udev;\n\td->desc = desc;\n\td->owner = owner;\n\n\tusb_set_intfdata(intf, d);\n\n\tret = dvb_usb_init(d, adapter_nums);\n\tif (ret) {\n\t\tinfo(\"%s error while loading driver (%d)\", desc->name, ret);\n\t\tgoto error;\n\t}\n\n\tif (du)\n\t\t*du = d;\n\n\tinfo(\"%s successfully initialized and connected.\", desc->name);\n\treturn 0;\n\n error:\n\tusb_set_intfdata(intf, NULL);\n\tkfree(d);\n\treturn ret;\n}\nEXPORT_SYMBOL(dvb_usb_device_init);\n\nvoid dvb_usb_device_exit(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *default_name = \"generic DVB-USB module\";\n\tchar name[40];\n\n\tusb_set_intfdata(intf, NULL);\n\tif (d != NULL && d->desc != NULL) {\n\t\tstrscpy(name, d->desc->name, sizeof(name));\n\t\tdvb_usb_exit(d);\n\t} else {\n\t\tstrscpy(name, default_name, sizeof(name));\n\t}\n\tinfo(\"%s successfully deinitialized and disconnected.\", name);\n\n}\nEXPORT_SYMBOL(dvb_usb_device_exit);\n\nMODULE_VERSION(\"1.0\");\nMODULE_AUTHOR(\"Patrick Boettcher <patrick.boettcher@posteo.de>\");\nMODULE_DESCRIPTION(\"A library module containing commonly used USB and DVB function USB DVB devices\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}