{
  "module_name": "dvb-usb-remote.c",
  "hash_id": "cb48391fcbf66d774c0dcfe76466e8b44c25683df67b70cacfe74d40d3284b2e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/dvb-usb-remote.c",
  "human_readable_source": "\n \n#include \"dvb-usb-common.h\"\n#include <linux/usb/input.h>\n\nstatic unsigned int\nlegacy_dvb_usb_get_keymap_index(const struct input_keymap_entry *ke,\n\t\t\t\tstruct rc_map_table *keymap,\n\t\t\t\tunsigned int keymap_size)\n{\n\tunsigned int index;\n\tunsigned int scancode;\n\n\tif (ke->flags & INPUT_KEYMAP_BY_INDEX) {\n\t\tindex = ke->index;\n\t} else {\n\t\tif (input_scancode_to_scalar(ke, &scancode))\n\t\t\treturn keymap_size;\n\n\t\t \n\t\tfor (index = 0; index < keymap_size; index++)\n\t\t\tif (keymap[index].scancode == scancode)\n\t\t\t\tbreak;\n\n\t\t \n\t\tif (index >= keymap_size) {\n\t\t\tfor (index = 0; index < keymap_size; index++) {\n\t\t\t\tif (keymap[index].keycode == KEY_RESERVED ||\n\t\t\t\t    keymap[index].keycode == KEY_UNKNOWN) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn index;\n}\n\nstatic int legacy_dvb_usb_getkeycode(struct input_dev *dev,\n\t\t\t\t     struct input_keymap_entry *ke)\n{\n\tstruct dvb_usb_device *d = input_get_drvdata(dev);\n\tstruct rc_map_table *keymap = d->props.rc.legacy.rc_map_table;\n\tunsigned int keymap_size = d->props.rc.legacy.rc_map_size;\n\tunsigned int index;\n\n\tindex = legacy_dvb_usb_get_keymap_index(ke, keymap, keymap_size);\n\tif (index >= keymap_size)\n\t\treturn -EINVAL;\n\n\tke->keycode = keymap[index].keycode;\n\tif (ke->keycode == KEY_UNKNOWN)\n\t\tke->keycode = KEY_RESERVED;\n\tke->len = sizeof(keymap[index].scancode);\n\tmemcpy(&ke->scancode, &keymap[index].scancode, ke->len);\n\tke->index = index;\n\n\treturn 0;\n}\n\nstatic int legacy_dvb_usb_setkeycode(struct input_dev *dev,\n\t\t\t\t     const struct input_keymap_entry *ke,\n\t\t\t\t     unsigned int *old_keycode)\n{\n\tstruct dvb_usb_device *d = input_get_drvdata(dev);\n\tstruct rc_map_table *keymap = d->props.rc.legacy.rc_map_table;\n\tunsigned int keymap_size = d->props.rc.legacy.rc_map_size;\n\tunsigned int index;\n\n\tindex = legacy_dvb_usb_get_keymap_index(ke, keymap, keymap_size);\n\t \n\tif (index >= keymap_size)\n\t\treturn -EINVAL;\n\n\t*old_keycode = keymap[index].keycode;\n\tkeymap->keycode = ke->keycode;\n\t__set_bit(ke->keycode, dev->keybit);\n\n\tif (*old_keycode != KEY_RESERVED) {\n\t\t__clear_bit(*old_keycode, dev->keybit);\n\t\tfor (index = 0; index < keymap_size; index++) {\n\t\t\tif (keymap[index].keycode == *old_keycode) {\n\t\t\t\t__set_bit(*old_keycode, dev->keybit);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void legacy_dvb_usb_read_remote_control(struct work_struct *work)\n{\n\tstruct dvb_usb_device *d =\n\t\tcontainer_of(work, struct dvb_usb_device, rc_query_work.work);\n\tu32 event;\n\tint state;\n\n\t \n\n\t \n\tif (dvb_usb_disable_rc_polling)\n\t\treturn;\n\n\tif (d->props.rc.legacy.rc_query(d,&event,&state)) {\n\t\terr(\"error while querying for an remote control event.\");\n\t\tgoto schedule;\n\t}\n\n\n\tswitch (state) {\n\t\tcase REMOTE_NO_KEY_PRESSED:\n\t\t\tbreak;\n\t\tcase REMOTE_KEY_PRESSED:\n\t\t\tdeb_rc(\"key pressed\\n\");\n\t\t\td->last_event = event;\n\t\t\tinput_event(d->input_dev, EV_KEY, event, 1);\n\t\t\tinput_sync(d->input_dev);\n\t\t\tinput_event(d->input_dev, EV_KEY, d->last_event, 0);\n\t\t\tinput_sync(d->input_dev);\n\t\t\tbreak;\n\t\tcase REMOTE_KEY_REPEAT:\n\t\t\tdeb_rc(\"key repeated\\n\");\n\t\t\tinput_event(d->input_dev, EV_KEY, event, 1);\n\t\t\tinput_sync(d->input_dev);\n\t\t\tinput_event(d->input_dev, EV_KEY, d->last_event, 0);\n\t\t\tinput_sync(d->input_dev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n \n\nschedule:\n\tschedule_delayed_work(&d->rc_query_work,msecs_to_jiffies(d->props.rc.legacy.rc_interval));\n}\n\nstatic int legacy_dvb_usb_remote_init(struct dvb_usb_device *d)\n{\n\tint i, err, rc_interval;\n\tstruct input_dev *input_dev;\n\n\tinput_dev = input_allocate_device();\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY);\n\tinput_dev->name = \"IR-receiver inside an USB DVB receiver\";\n\tinput_dev->phys = d->rc_phys;\n\tusb_to_input_id(d->udev, &input_dev->id);\n\tinput_dev->dev.parent = &d->udev->dev;\n\td->input_dev = input_dev;\n\td->rc_dev = NULL;\n\n\tinput_dev->getkeycode = legacy_dvb_usb_getkeycode;\n\tinput_dev->setkeycode = legacy_dvb_usb_setkeycode;\n\n\t \n\tdeb_rc(\"key map size: %d\\n\", d->props.rc.legacy.rc_map_size);\n\tfor (i = 0; i < d->props.rc.legacy.rc_map_size; i++) {\n\t\tdeb_rc(\"setting bit for event %d item %d\\n\",\n\t\t\td->props.rc.legacy.rc_map_table[i].keycode, i);\n\t\tset_bit(d->props.rc.legacy.rc_map_table[i].keycode, input_dev->keybit);\n\t}\n\n\t \n\tinput_dev->rep[REP_PERIOD] = d->props.rc.legacy.rc_interval;\n\tinput_dev->rep[REP_DELAY]  = d->props.rc.legacy.rc_interval + 150;\n\n\tinput_set_drvdata(input_dev, d);\n\n\terr = input_register_device(input_dev);\n\tif (err)\n\t\tinput_free_device(input_dev);\n\n\trc_interval = d->props.rc.legacy.rc_interval;\n\n\tINIT_DELAYED_WORK(&d->rc_query_work, legacy_dvb_usb_read_remote_control);\n\n\tinfo(\"schedule remote query interval to %d msecs.\", rc_interval);\n\tschedule_delayed_work(&d->rc_query_work,\n\t\t\t      msecs_to_jiffies(rc_interval));\n\n\td->state |= DVB_USB_STATE_REMOTE;\n\n\treturn err;\n}\n\n \nstatic void dvb_usb_read_remote_control(struct work_struct *work)\n{\n\tstruct dvb_usb_device *d =\n\t\tcontainer_of(work, struct dvb_usb_device, rc_query_work.work);\n\tint err;\n\n\t \n\n\t \n\tif (dvb_usb_disable_rc_polling || d->props.rc.core.bulk_mode)\n\t\treturn;\n\n\terr = d->props.rc.core.rc_query(d);\n\tif (err)\n\t\terr(\"error %d while querying for an remote control event.\", err);\n\n\tschedule_delayed_work(&d->rc_query_work,\n\t\t\t      msecs_to_jiffies(d->props.rc.core.rc_interval));\n}\n\nstatic int rc_core_dvb_usb_remote_init(struct dvb_usb_device *d)\n{\n\tint err, rc_interval;\n\tstruct rc_dev *dev;\n\n\tdev = rc_allocate_device(d->props.rc.core.driver_type);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->driver_name = d->props.rc.core.module_name;\n\tdev->map_name = d->props.rc.core.rc_codes;\n\tdev->change_protocol = d->props.rc.core.change_protocol;\n\tdev->allowed_protocols = d->props.rc.core.allowed_protos;\n\tusb_to_input_id(d->udev, &dev->input_id);\n\tdev->device_name = d->desc->name;\n\tdev->input_phys = d->rc_phys;\n\tdev->dev.parent = &d->udev->dev;\n\tdev->priv = d;\n\tdev->scancode_mask = d->props.rc.core.scancode_mask;\n\n\terr = rc_register_device(dev);\n\tif (err < 0) {\n\t\trc_free_device(dev);\n\t\treturn err;\n\t}\n\n\td->input_dev = NULL;\n\td->rc_dev = dev;\n\n\tif (!d->props.rc.core.rc_query || d->props.rc.core.bulk_mode)\n\t\treturn 0;\n\n\t \n\tINIT_DELAYED_WORK(&d->rc_query_work, dvb_usb_read_remote_control);\n\n\trc_interval = d->props.rc.core.rc_interval;\n\n\tinfo(\"schedule remote query interval to %d msecs.\", rc_interval);\n\tschedule_delayed_work(&d->rc_query_work,\n\t\t\t      msecs_to_jiffies(rc_interval));\n\n\treturn 0;\n}\n\nint dvb_usb_remote_init(struct dvb_usb_device *d)\n{\n\tint err;\n\n\tif (dvb_usb_disable_rc_polling)\n\t\treturn 0;\n\n\tif (d->props.rc.legacy.rc_map_table && d->props.rc.legacy.rc_query)\n\t\td->props.rc.mode = DVB_RC_LEGACY;\n\telse if (d->props.rc.core.rc_codes)\n\t\td->props.rc.mode = DVB_RC_CORE;\n\telse\n\t\treturn 0;\n\n\tusb_make_path(d->udev, d->rc_phys, sizeof(d->rc_phys));\n\tstrlcat(d->rc_phys, \"/ir0\", sizeof(d->rc_phys));\n\n\t \n\tif (d->props.rc.legacy.rc_interval < 40)\n\t\td->props.rc.legacy.rc_interval = 100;  \n\n\tif (d->props.rc.mode == DVB_RC_LEGACY)\n\t\terr = legacy_dvb_usb_remote_init(d);\n\telse\n\t\terr = rc_core_dvb_usb_remote_init(d);\n\tif (err)\n\t\treturn err;\n\n\td->state |= DVB_USB_STATE_REMOTE;\n\n\treturn 0;\n}\n\nint dvb_usb_remote_exit(struct dvb_usb_device *d)\n{\n\tif (d->state & DVB_USB_STATE_REMOTE) {\n\t\tcancel_delayed_work_sync(&d->rc_query_work);\n\t\tif (d->props.rc.mode == DVB_RC_LEGACY)\n\t\t\tinput_unregister_device(d->input_dev);\n\t\telse\n\t\t\trc_unregister_device(d->rc_dev);\n\t}\n\td->state &= ~DVB_USB_STATE_REMOTE;\n\treturn 0;\n}\n\n#define DVB_USB_RC_NEC_EMPTY           0x00\n#define DVB_USB_RC_NEC_KEY_PRESSED     0x01\n#define DVB_USB_RC_NEC_KEY_REPEATED    0x02\nint dvb_usb_nec_rc_key_to_event(struct dvb_usb_device *d,\n\t\tu8 keybuf[5], u32 *event, int *state)\n{\n\tint i;\n\tstruct rc_map_table *keymap = d->props.rc.legacy.rc_map_table;\n\t*event = 0;\n\t*state = REMOTE_NO_KEY_PRESSED;\n\tswitch (keybuf[0]) {\n\t\tcase DVB_USB_RC_NEC_EMPTY:\n\t\t\tbreak;\n\t\tcase DVB_USB_RC_NEC_KEY_PRESSED:\n\t\t\tif ((u8) ~keybuf[1] != keybuf[2] ||\n\t\t\t\t(u8) ~keybuf[3] != keybuf[4]) {\n\t\t\t\tdeb_err(\"remote control checksum failed.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tfor (i = 0; i < d->props.rc.legacy.rc_map_size; i++)\n\t\t\t\tif (rc5_custom(&keymap[i]) == keybuf[1] &&\n\t\t\t\t\trc5_data(&keymap[i]) == keybuf[3]) {\n\t\t\t\t\t*event = keymap[i].keycode;\n\t\t\t\t\t*state = REMOTE_KEY_PRESSED;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tdeb_err(\"key mapping failed - no appropriate key found in keymapping\\n\");\n\t\t\tbreak;\n\t\tcase DVB_USB_RC_NEC_KEY_REPEATED:\n\t\t\t*state = REMOTE_KEY_REPEAT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdeb_err(\"unknown type of remote status: %d\\n\",keybuf[0]);\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(dvb_usb_nec_rc_key_to_event);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}