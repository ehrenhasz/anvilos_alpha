{
  "module_name": "ttusb2.c",
  "hash_id": "6bdeb2b0c39d9f4f413bd32eed38aa7b0a00d147ce99d9e6a075cf34e2d6dcfb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/ttusb2.c",
  "human_readable_source": "\n \n#define DVB_USB_LOG_PREFIX \"ttusb2\"\n#include \"dvb-usb.h\"\n\n#include \"ttusb2.h\"\n\n#include \"tda826x.h\"\n#include \"tda10086.h\"\n#include \"tda1002x.h\"\n#include \"tda10048.h\"\n#include \"tda827x.h\"\n#include \"lnbp21.h\"\n \n#include <media/dvb_ca_en50221.h>\n\n \nstatic int dvb_usb_ttusb2_debug;\n#define deb_info(args...)   dprintk(dvb_usb_ttusb2_debug,0x01,args)\nmodule_param_named(debug,dvb_usb_ttusb2_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=info (or-able)).\" DVB_USB_DEBUG_STATUS);\nstatic int dvb_usb_ttusb2_debug_ci;\nmodule_param_named(debug_ci,dvb_usb_ttusb2_debug_ci, int, 0644);\nMODULE_PARM_DESC(debug_ci, \"set debugging ci.\" DVB_USB_DEBUG_STATUS);\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n#define ci_dbg(format, arg...)                \\\ndo {                                          \\\n\tif (dvb_usb_ttusb2_debug_ci)                                    \\\n\t\tprintk(KERN_DEBUG DVB_USB_LOG_PREFIX \\\n\t\t\t\": %s \" format \"\\n\" , __func__, ## arg);       \\\n} while (0)\n\nenum {\n\tTT3650_CMD_CI_TEST = 0x40,\n\tTT3650_CMD_CI_RD_CTRL,\n\tTT3650_CMD_CI_WR_CTRL,\n\tTT3650_CMD_CI_RD_ATTR,\n\tTT3650_CMD_CI_WR_ATTR,\n\tTT3650_CMD_CI_RESET,\n\tTT3650_CMD_CI_SET_VIDEO_PORT\n};\n\nstruct ttusb2_state {\n\tstruct dvb_ca_en50221 ca;\n\tstruct mutex ca_mutex;\n\tu8 id;\n\tu16 last_rc_key;\n};\n\nstatic int ttusb2_msg(struct dvb_usb_device *d, u8 cmd,\n\t\tu8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct ttusb2_state *st = d->priv;\n\tu8 *s, *r = NULL;\n\tint ret = 0;\n\n\tif (4 + rlen > 64)\n\t\treturn -EIO;\n\n\ts = kzalloc(wlen+4, GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tr = kzalloc(64, GFP_KERNEL);\n\tif (!r) {\n\t\tkfree(s);\n\t\treturn -ENOMEM;\n\t}\n\n\ts[0] = 0xaa;\n\ts[1] = ++st->id;\n\ts[2] = cmd;\n\ts[3] = wlen;\n\tmemcpy(&s[4],wbuf,wlen);\n\n\tret = dvb_usb_generic_rw(d, s, wlen+4, r, 64, 0);\n\n\tif (ret  != 0 ||\n\t\tr[0] != 0x55 ||\n\t\tr[1] != s[1] ||\n\t\tr[2] != cmd ||\n\t\t(rlen > 0 && r[3] != rlen)) {\n\t\twarn(\"there might have been an error during control message transfer. (rlen = %d, was %d)\",rlen,r[3]);\n\t\tkfree(s);\n\t\tkfree(r);\n\t\treturn -EIO;\n\t}\n\n\tif (rlen > 0)\n\t\tmemcpy(rbuf, &r[4], rlen);\n\n\tkfree(s);\n\tkfree(r);\n\n\treturn 0;\n}\n\n \nstatic int tt3650_ci_msg(struct dvb_usb_device *d, u8 cmd, u8 *data, unsigned int write_len, unsigned int read_len)\n{\n\tint ret;\n\tu8 rx[60]; \n\tret = ttusb2_msg(d, cmd, data, write_len, rx, read_len);\n\tif (!ret)\n\t\tmemcpy(data, rx, read_len);\n\treturn ret;\n}\n\nstatic int tt3650_ci_msg_locked(struct dvb_ca_en50221 *ca, u8 cmd, u8 *data, unsigned int write_len, unsigned int read_len)\n{\n\tstruct dvb_usb_device *d = ca->data;\n\tstruct ttusb2_state *state = d->priv;\n\tint ret;\n\n\tmutex_lock(&state->ca_mutex);\n\tret = tt3650_ci_msg(d, cmd, data, write_len, read_len);\n\tmutex_unlock(&state->ca_mutex);\n\n\treturn ret;\n}\n\nstatic int tt3650_ci_read_attribute_mem(struct dvb_ca_en50221 *ca, int slot, int address)\n{\n\tu8 buf[3];\n\tint ret = 0;\n\n\tif (slot)\n\t\treturn -EINVAL;\n\n\tbuf[0] = (address >> 8) & 0x0F;\n\tbuf[1] = address;\n\n\n\tret = tt3650_ci_msg_locked(ca, TT3650_CMD_CI_RD_ATTR, buf, 2, 3);\n\n\tci_dbg(\"%04x -> %d 0x%02x\", address, ret, buf[2]);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn buf[2];\n}\n\nstatic int tt3650_ci_write_attribute_mem(struct dvb_ca_en50221 *ca, int slot, int address, u8 value)\n{\n\tu8 buf[3];\n\n\tci_dbg(\"%d 0x%04x 0x%02x\", slot, address, value);\n\n\tif (slot)\n\t\treturn -EINVAL;\n\n\tbuf[0] = (address >> 8) & 0x0F;\n\tbuf[1] = address;\n\tbuf[2] = value;\n\n\treturn tt3650_ci_msg_locked(ca, TT3650_CMD_CI_WR_ATTR, buf, 3, 3);\n}\n\nstatic int tt3650_ci_read_cam_control(struct dvb_ca_en50221 *ca, int slot, u8 address)\n{\n\tu8 buf[2];\n\tint ret;\n\n\tif (slot)\n\t\treturn -EINVAL;\n\n\tbuf[0] = address & 3;\n\n\tret = tt3650_ci_msg_locked(ca, TT3650_CMD_CI_RD_CTRL, buf, 1, 2);\n\n\tci_dbg(\"0x%02x -> %d 0x%02x\", address, ret, buf[1]);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn buf[1];\n}\n\nstatic int tt3650_ci_write_cam_control(struct dvb_ca_en50221 *ca, int slot, u8 address, u8 value)\n{\n\tu8 buf[2];\n\n\tci_dbg(\"%d 0x%02x 0x%02x\", slot, address, value);\n\n\tif (slot)\n\t\treturn -EINVAL;\n\n\tbuf[0] = address;\n\tbuf[1] = value;\n\n\treturn tt3650_ci_msg_locked(ca, TT3650_CMD_CI_WR_CTRL, buf, 2, 2);\n}\n\nstatic int tt3650_ci_set_video_port(struct dvb_ca_en50221 *ca, int slot, int enable)\n{\n\tu8 buf[1];\n\tint ret;\n\n\tci_dbg(\"%d %d\", slot, enable);\n\n\tif (slot)\n\t\treturn -EINVAL;\n\n\tbuf[0] = enable;\n\n\tret = tt3650_ci_msg_locked(ca, TT3650_CMD_CI_SET_VIDEO_PORT, buf, 1, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (enable != buf[0]) {\n\t\terr(\"CI not %sabled.\", enable ? \"en\" : \"dis\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int tt3650_ci_slot_shutdown(struct dvb_ca_en50221 *ca, int slot)\n{\n\treturn tt3650_ci_set_video_port(ca, slot, 0);\n}\n\nstatic int tt3650_ci_slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)\n{\n\treturn tt3650_ci_set_video_port(ca, slot, 1);\n}\n\nstatic int tt3650_ci_slot_reset(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct dvb_usb_device *d = ca->data;\n\tstruct ttusb2_state *state = d->priv;\n\tu8 buf[1];\n\tint ret;\n\n\tci_dbg(\"%d\", slot);\n\n\tif (slot)\n\t\treturn -EINVAL;\n\n\tbuf[0] = 0;\n\n\tmutex_lock(&state->ca_mutex);\n\n\tret = tt3650_ci_msg(d, TT3650_CMD_CI_RESET, buf, 1, 1);\n\tif (ret)\n\t\tgoto failed;\n\n\tmsleep(500);\n\n\tbuf[0] = 1;\n\n\tret = tt3650_ci_msg(d, TT3650_CMD_CI_RESET, buf, 1, 1);\n\tif (ret)\n\t\tgoto failed;\n\n\tmsleep(500);\n\n\tbuf[0] = 0;  \n\n\tret = tt3650_ci_msg(d, TT3650_CMD_CI_SET_VIDEO_PORT, buf, 1, 1);\n\n\tmsleep(1100);\n\n failed:\n\tmutex_unlock(&state->ca_mutex);\n\n\treturn ret;\n}\n\nstatic int tt3650_ci_poll_slot_status(struct dvb_ca_en50221 *ca, int slot, int open)\n{\n\tu8 buf[1];\n\tint ret;\n\n\tif (slot)\n\t\treturn -EINVAL;\n\n\tret = tt3650_ci_msg_locked(ca, TT3650_CMD_CI_TEST, buf, 0, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (1 == buf[0]) {\n\t\treturn DVB_CA_EN50221_POLL_CAM_PRESENT |\n\t\t\tDVB_CA_EN50221_POLL_CAM_READY;\n\t}\n\treturn 0;\n}\n\nstatic void tt3650_ci_uninit(struct dvb_usb_device *d)\n{\n\tstruct ttusb2_state *state;\n\n\tci_dbg(\"\");\n\n\tif (NULL == d)\n\t\treturn;\n\n\tstate = d->priv;\n\tif (NULL == state)\n\t\treturn;\n\n\tif (NULL == state->ca.data)\n\t\treturn;\n\n\tdvb_ca_en50221_release(&state->ca);\n\n\tmemset(&state->ca, 0, sizeof(state->ca));\n}\n\nstatic int tt3650_ci_init(struct dvb_usb_adapter *a)\n{\n\tstruct dvb_usb_device *d = a->dev;\n\tstruct ttusb2_state *state = d->priv;\n\tint ret;\n\n\tci_dbg(\"\");\n\n\tmutex_init(&state->ca_mutex);\n\n\tstate->ca.owner = THIS_MODULE;\n\tstate->ca.read_attribute_mem = tt3650_ci_read_attribute_mem;\n\tstate->ca.write_attribute_mem = tt3650_ci_write_attribute_mem;\n\tstate->ca.read_cam_control = tt3650_ci_read_cam_control;\n\tstate->ca.write_cam_control = tt3650_ci_write_cam_control;\n\tstate->ca.slot_reset = tt3650_ci_slot_reset;\n\tstate->ca.slot_shutdown = tt3650_ci_slot_shutdown;\n\tstate->ca.slot_ts_enable = tt3650_ci_slot_ts_enable;\n\tstate->ca.poll_slot_status = tt3650_ci_poll_slot_status;\n\tstate->ca.data = d;\n\n\tret = dvb_ca_en50221_init(&a->dvb_adap,\n\t\t\t\t  &state->ca,\n\t\t\t\t    0,\n\t\t\t\t    1);\n\tif (ret) {\n\t\terr(\"Cannot initialize CI: Error %d.\", ret);\n\t\tmemset(&state->ca, 0, sizeof(state->ca));\n\t\treturn ret;\n\t}\n\n\tinfo(\"CI initialized.\");\n\n\treturn 0;\n}\n\nstatic int ttusb2_i2c_xfer(struct i2c_adapter *adap,struct i2c_msg msg[],int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstatic u8 obuf[60], ibuf[60];\n\tint i, write_read, read;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tif (num > 2)\n\t\twarn(\"more than 2 i2c messages at a time is not handled yet. TODO.\");\n\n\tfor (i = 0; i < num; i++) {\n\t\twrite_read = i+1 < num && (msg[i+1].flags & I2C_M_RD);\n\t\tread = msg[i].flags & I2C_M_RD;\n\n\t\tif (3 + msg[i].len > sizeof(obuf)) {\n\t\t\terr(\"i2c wr len=%d too high\", msg[i].len);\n\t\t\tbreak;\n\t\t}\n\t\tif (write_read) {\n\t\t\tif (3 + msg[i+1].len > sizeof(ibuf)) {\n\t\t\t\terr(\"i2c rd len=%d too high\", msg[i+1].len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (read) {\n\t\t\tif (3 + msg[i].len > sizeof(ibuf)) {\n\t\t\t\terr(\"i2c rd len=%d too high\", msg[i].len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tobuf[0] = (msg[i].addr << 1) | (write_read | read);\n\t\tif (read)\n\t\t\tobuf[1] = 0;\n\t\telse\n\t\t\tobuf[1] = msg[i].len;\n\n\t\t \n\t\tif (write_read)\n\t\t\tobuf[2] = msg[i+1].len;\n\t\telse if (read)\n\t\t\tobuf[2] = msg[i].len;\n\t\telse\n\t\t\tobuf[2] = 0;\n\n\t\tmemcpy(&obuf[3], msg[i].buf, msg[i].len);\n\n\t\tif (ttusb2_msg(d, CMD_I2C_XFER, obuf, obuf[1]+3, ibuf, obuf[2] + 3) < 0) {\n\t\t\terr(\"i2c transfer failed.\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write_read) {\n\t\t\tmemcpy(msg[i+1].buf, &ibuf[3], msg[i+1].len);\n\t\t\ti++;\n\t\t} else if (read)\n\t\t\tmemcpy(msg[i].buf, &ibuf[3], msg[i].len);\n\t}\n\n\tmutex_unlock(&d->i2c_mutex);\n\treturn i;\n}\n\nstatic u32 ttusb2_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm ttusb2_i2c_algo = {\n\t.master_xfer   = ttusb2_i2c_xfer,\n\t.functionality = ttusb2_i2c_func,\n};\n\n \n#define CMD_GET_IR_CODE     0x1b\n\n \nstatic int tt3650_rc_query(struct dvb_usb_device *d)\n{\n\tint ret;\n\tu8 rx[9];  \n\tstruct ttusb2_state *st = d->priv;\n\tret = ttusb2_msg(d, CMD_GET_IR_CODE, NULL, 0, rx, sizeof(rx));\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (rx[8] & 0x01) {\n\t\t \n\t\tst->last_rc_key = RC_SCANCODE_RC5(rx[3], rx[2]);\n\t\tdeb_info(\"%s: cmd=0x%02x sys=0x%02x\\n\", __func__, rx[2], rx[3]);\n\t\trc_keydown(d->rc_dev, RC_PROTO_RC5, st->last_rc_key, rx[1]);\n\t} else if (st->last_rc_key) {\n\t\trc_keyup(d->rc_dev);\n\t\tst->last_rc_key = 0;\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic int ttusb2_identify_state(struct usb_device *udev,\n\t\t\t\t const struct dvb_usb_device_properties *props,\n\t\t\t\t const struct dvb_usb_device_description **desc,\n\t\t\t\t int *cold)\n{\n\t*cold = udev->descriptor.iManufacturer == 0 && udev->descriptor.iProduct == 0;\n\treturn 0;\n}\n\nstatic int ttusb2_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tu8 b = onoff;\n\tttusb2_msg(d, CMD_POWER, &b, 0, NULL, 0);\n\treturn ttusb2_msg(d, CMD_POWER, &b, 1, NULL, 0);\n}\n\n\nstatic struct tda10086_config tda10086_config = {\n\t.demod_address = 0x0e,\n\t.invert = 0,\n\t.diseqc_tone = 1,\n\t.xtal_freq = TDA10086_XTAL_16M,\n};\n\nstatic struct tda10023_config tda10023_config = {\n\t.demod_address = 0x0c,\n\t.invert = 0,\n\t.xtal = 16000000,\n\t.pll_m = 11,\n\t.pll_p = 3,\n\t.pll_n = 1,\n\t.deltaf = 0xa511,\n};\n\nstatic struct tda10048_config tda10048_config = {\n\t.demod_address    = 0x10 >> 1,\n\t.output_mode      = TDA10048_PARALLEL_OUTPUT,\n\t.inversion        = TDA10048_INVERSION_ON,\n\t.dtv6_if_freq_khz = TDA10048_IF_4000,\n\t.dtv7_if_freq_khz = TDA10048_IF_4500,\n\t.dtv8_if_freq_khz = TDA10048_IF_5000,\n\t.clk_freq_khz     = TDA10048_CLK_16000,\n\t.no_firmware      = 1,\n\t.set_pll          = true ,\n\t.pll_m            = 5,\n\t.pll_n            = 3,\n\t.pll_p            = 0,\n};\n\nstatic struct tda827x_config tda827x_config = {\n\t.config = 0,\n};\n\nstatic int ttusb2_frontend_tda10086_attach(struct dvb_usb_adapter *adap)\n{\n\tif (usb_set_interface(adap->dev->udev,0,3) < 0)\n\t\terr(\"set interface to alts=3 failed\");\n\n\tif ((adap->fe_adap[0].fe = dvb_attach(tda10086_attach, &tda10086_config, &adap->dev->i2c_adap)) == NULL) {\n\t\tdeb_info(\"TDA10086 attach failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int ttusb2_ct3650_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\n\treturn adap->fe_adap[0].fe->ops.i2c_gate_ctrl(adap->fe_adap[0].fe, enable);\n}\n\nstatic int ttusb2_frontend_tda10023_attach(struct dvb_usb_adapter *adap)\n{\n\tif (usb_set_interface(adap->dev->udev, 0, 3) < 0)\n\t\terr(\"set interface to alts=3 failed\");\n\n\tif (adap->fe_adap[0].fe == NULL) {\n\t\t \n\t\tadap->fe_adap[0].fe = dvb_attach(tda10023_attach,\n\t\t\t&tda10023_config, &adap->dev->i2c_adap, 0x48);\n\n\t\tif (adap->fe_adap[0].fe == NULL) {\n\t\t\tdeb_info(\"TDA10023 attach failed\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\ttt3650_ci_init(adap);\n\t} else {\n\t\tadap->fe_adap[1].fe = dvb_attach(tda10048_attach,\n\t\t\t&tda10048_config, &adap->dev->i2c_adap);\n\n\t\tif (adap->fe_adap[1].fe == NULL) {\n\t\t\tdeb_info(\"TDA10048 attach failed\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\tadap->fe_adap[1].fe->ops.i2c_gate_ctrl = ttusb2_ct3650_i2c_gate_ctrl;\n\n\t}\n\n\treturn 0;\n}\n\nstatic int ttusb2_tuner_tda827x_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_frontend *fe;\n\n\t \n\tif (adap->fe_adap[1].fe == NULL)\n\t\tfe = adap->fe_adap[0].fe;\n\telse\n\t\tfe = adap->fe_adap[1].fe;\n\n\t \n\tif (dvb_attach(tda827x_attach, fe, 0x61, &adap->dev->i2c_adap, &tda827x_config) == NULL) {\n\t\tprintk(KERN_ERR \"%s: No tda827x found!\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int ttusb2_tuner_tda826x_attach(struct dvb_usb_adapter *adap)\n{\n\tif (dvb_attach(tda826x_attach, adap->fe_adap[0].fe, 0x60, &adap->dev->i2c_adap, 0) == NULL) {\n\t\tdeb_info(\"TDA8263 attach failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (dvb_attach(lnbp21_attach, adap->fe_adap[0].fe, &adap->dev->i2c_adap, 0, 0) == NULL) {\n\t\tdeb_info(\"LNBP21 attach failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\n \nstatic struct dvb_usb_device_properties ttusb2_properties;\nstatic struct dvb_usb_device_properties ttusb2_properties_s2400;\nstatic struct dvb_usb_device_properties ttusb2_properties_ct3650;\n\nstatic void ttusb2_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\n\ttt3650_ci_uninit(d);\n\tdvb_usb_device_exit(intf);\n}\n\nstatic int ttusb2_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tif (0 == dvb_usb_device_init(intf, &ttusb2_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &ttusb2_properties_s2400,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &ttusb2_properties_ct3650,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr))\n\t\treturn 0;\n\treturn -ENODEV;\n}\n\nenum {\n\tPINNACLE_PCTV_400E,\n\tPINNACLE_PCTV_450E,\n\tTECHNOTREND_CONNECT_S2400,\n\tTECHNOTREND_CONNECT_CT3650,\n\tTECHNOTREND_CONNECT_S2400_8KEEPROM,\n};\n\nstatic struct usb_device_id ttusb2_table[] = {\n\tDVB_USB_DEV(PINNACLE, PINNACLE_PCTV_400E),\n\tDVB_USB_DEV(PINNACLE, PINNACLE_PCTV_450E),\n\tDVB_USB_DEV(TECHNOTREND, TECHNOTREND_CONNECT_S2400),\n\tDVB_USB_DEV(TECHNOTREND, TECHNOTREND_CONNECT_CT3650),\n\tDVB_USB_DEV(TECHNOTREND, TECHNOTREND_CONNECT_S2400_8KEEPROM),\n\t{ }\n};\n\nMODULE_DEVICE_TABLE (usb, ttusb2_table);\n\nstatic struct dvb_usb_device_properties ttusb2_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl = CYPRESS_FX2,\n\t.firmware = \"dvb-usb-pctv-400e-01.fw\",\n\n\t.size_of_priv = sizeof(struct ttusb2_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = NULL, \n\n\t\t\t.frontend_attach  = ttusb2_frontend_tda10086_attach,\n\t\t\t.tuner_attach     = ttusb2_tuner_tda826x_attach,\n\n\t\t\t \n\t\t\t.stream = {\n\t\t\t\t.type = USB_ISOC,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.isoc = {\n\t\t\t\t\t\t.framesperurb = 4,\n\t\t\t\t\t\t.framesize = 940,\n\t\t\t\t\t\t.interval = 1,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}},\n\t\t}\n\t},\n\n\t.power_ctrl       = ttusb2_power_ctrl,\n\t.identify_state   = ttusb2_identify_state,\n\n\t.i2c_algo         = &ttusb2_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.num_device_descs = 2,\n\t.devices = {\n\t\t{   \"Pinnacle 400e DVB-S USB2.0\",\n\t\t\t{ &ttusb2_table[PINNACLE_PCTV_400E], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{   \"Pinnacle 450e DVB-S USB2.0\",\n\t\t\t{ &ttusb2_table[PINNACLE_PCTV_450E], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties ttusb2_properties_s2400 = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl = CYPRESS_FX2,\n\t.firmware = \"dvb-usb-tt-s2400-01.fw\",\n\n\t.size_of_priv = sizeof(struct ttusb2_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = NULL,\n\n\t\t\t.frontend_attach  = ttusb2_frontend_tda10086_attach,\n\t\t\t.tuner_attach     = ttusb2_tuner_tda826x_attach,\n\n\t\t\t \n\t\t\t.stream = {\n\t\t\t\t.type = USB_ISOC,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.isoc = {\n\t\t\t\t\t\t.framesperurb = 4,\n\t\t\t\t\t\t.framesize = 940,\n\t\t\t\t\t\t.interval = 1,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}},\n\t\t}\n\t},\n\n\t.power_ctrl       = ttusb2_power_ctrl,\n\t.identify_state   = ttusb2_identify_state,\n\n\t.i2c_algo         = &ttusb2_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.num_device_descs = 2,\n\t.devices = {\n\t\t{   \"Technotrend TT-connect S-2400\",\n\t\t\t{ &ttusb2_table[TECHNOTREND_CONNECT_S2400], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{   \"Technotrend TT-connect S-2400 (8kB EEPROM)\",\n\t\t\t{ &ttusb2_table[TECHNOTREND_CONNECT_S2400_8KEEPROM], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties ttusb2_properties_ct3650 = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl = CYPRESS_FX2,\n\n\t.size_of_priv = sizeof(struct ttusb2_state),\n\n\t.rc.core = {\n\t\t.rc_interval      = 150,  \n\t\t.rc_codes         = RC_MAP_TT_1500,\n\t\t.rc_query         = tt3650_rc_query,\n\t\t.allowed_protos   = RC_PROTO_BIT_RC5,\n\t},\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 2,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = NULL,\n\n\t\t\t.frontend_attach  = ttusb2_frontend_tda10023_attach,\n\t\t\t.tuner_attach = ttusb2_tuner_tda827x_attach,\n\n\t\t\t \n\t\t\t.stream = {\n\t\t\t\t.type = USB_ISOC,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.isoc = {\n\t\t\t\t\t\t.framesperurb = 4,\n\t\t\t\t\t\t.framesize = 940,\n\t\t\t\t\t\t.interval = 1,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\t.streaming_ctrl   = NULL,\n\n\t\t\t.frontend_attach  = ttusb2_frontend_tda10023_attach,\n\t\t\t.tuner_attach = ttusb2_tuner_tda827x_attach,\n\n\t\t\t \n\t\t\t.stream = {\n\t\t\t\t.type = USB_ISOC,\n\t\t\t\t.count = 5,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.isoc = {\n\t\t\t\t\t\t.framesperurb = 4,\n\t\t\t\t\t\t.framesize = 940,\n\t\t\t\t\t\t.interval = 1,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}},\n\t\t},\n\t},\n\n\t.power_ctrl       = ttusb2_power_ctrl,\n\t.identify_state   = ttusb2_identify_state,\n\n\t.i2c_algo         = &ttusb2_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"Technotrend TT-connect CT-3650\",\n\t\t\t.warm_ids = { &ttusb2_table[TECHNOTREND_CONNECT_CT3650], NULL },\n\t\t},\n\t}\n};\n\nstatic struct usb_driver ttusb2_driver = {\n\t.name\t\t= \"dvb_usb_ttusb2\",\n\t.probe\t\t= ttusb2_probe,\n\t.disconnect\t= ttusb2_usb_disconnect,\n\t.id_table\t= ttusb2_table,\n};\n\nmodule_usb_driver(ttusb2_driver);\n\nMODULE_AUTHOR(\"Patrick Boettcher <patrick.boettcher@posteo.de>\");\nMODULE_DESCRIPTION(\"Driver for Pinnacle PCTV 400e DVB-S USB2.0\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}