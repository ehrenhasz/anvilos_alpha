{
  "module_name": "pctv452e.c",
  "hash_id": "47d3273afacb87457a4170480f4c5126d8eb511464d77633162a31e64747b2ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/pctv452e.c",
  "human_readable_source": "\n \n\n \n#define DVB_USB_LOG_PREFIX \"pctv452e\"\n#include \"dvb-usb.h\"\n\n \n#include \"stb0899_drv.h\"\n#include \"stb0899_reg.h\"\n#include \"stb0899_cfg.h\"\n \n#include \"stb6100.h\"\n#include \"stb6100_cfg.h\"\n \n#include \"isl6423.h\"\n#include \"lnbp22.h\"\n\n#include <media/dvb_ca_en50221.h>\n#include \"ttpci-eeprom.h\"\n\n#include <linux/etherdevice.h>\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off debugging (default:off).\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n#define ISOC_INTERFACE_ALTERNATIVE 3\n\n#define SYNC_BYTE_OUT 0xaa\n#define SYNC_BYTE_IN  0x55\n\n \n#define PCTV_CMD_RESET 0x15\n \n#define PCTV_CMD_IR    0x1b\n \n#define PCTV_CMD_I2C   0x31\n\n#define I2C_ADDR_STB0899 (0xd0 >> 1)\n#define I2C_ADDR_STB6100 (0xc0 >> 1)\n#define I2C_ADDR_LNBP22  (0x10 >> 1)\n#define I2C_ADDR_24C16   (0xa0 >> 1)\n#define I2C_ADDR_24C64   (0xa2 >> 1)\n\n\n \n#define PCTV_ANSWER_LEN 64\n \n#define PCTV_TIMEOUT 1000\n\n\n#define PCTV_LED_GPIO   STB0899_GPIO01\n#define PCTV_LED_GREEN  0x82\n#define PCTV_LED_ORANGE 0x02\n\n#define ci_dbg(format, arg...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG DVB_USB_LOG_PREFIX\t\\\n\t\t\t\": \" format \"\\n\" , ## arg);\t\\\n} while (0)\n\nenum {\n\tTT3650_CMD_CI_TEST = 0x40,\n\tTT3650_CMD_CI_RD_CTRL,\n\tTT3650_CMD_CI_WR_CTRL,\n\tTT3650_CMD_CI_RD_ATTR,\n\tTT3650_CMD_CI_WR_ATTR,\n\tTT3650_CMD_CI_RESET,\n\tTT3650_CMD_CI_SET_VIDEO_PORT\n};\n\n\nstatic struct stb0899_postproc pctv45e_postproc[] = {\n\t{ PCTV_LED_GPIO, STB0899_GPIOPULLUP },\n\t{ 0, 0 }\n};\n\nstatic struct isl6423_config pctv452e_isl6423_config = {\n\t.current_max\t\t= SEC_CURRENT_515m,\n\t.curlim\t\t\t= SEC_CURRENT_LIM_ON,\n\t.mod_extern\t\t= 1,\n\t.addr\t\t\t= 0x08,\n};\n\n \nstruct pctv452e_state {\n\tstruct dvb_ca_en50221 ca;\n\tstruct mutex ca_mutex;\n\n\tu8 c;\t    \n\tu8 initialized;  \n\tu16 last_rc_key;\n};\n\nstatic int tt3650_ci_msg(struct dvb_usb_device *d, u8 cmd, u8 *data,\n\t\t\t unsigned int write_len, unsigned int read_len)\n{\n\tstruct pctv452e_state *state = d->priv;\n\tu8 *buf;\n\tu8 id;\n\tunsigned int rlen;\n\tint ret;\n\n\tif (!data || (write_len > 64 - 4) || (read_len > 64 - 4)) {\n\t\terr(\"%s: transfer data invalid\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tbuf = kmalloc(64, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tid = state->c++;\n\n\tbuf[0] = SYNC_BYTE_OUT;\n\tbuf[1] = id;\n\tbuf[2] = cmd;\n\tbuf[3] = write_len;\n\n\tmemcpy(buf + 4, data, write_len);\n\n\trlen = (read_len > 0) ? 64 : 0;\n\tret = dvb_usb_generic_rw(d, buf, 4 + write_len,\n\t\t\t\t  buf, rlen,   0);\n\tif (0 != ret)\n\t\tgoto failed;\n\n\tret = -EIO;\n\tif (SYNC_BYTE_IN != buf[0] || id != buf[1])\n\t\tgoto failed;\n\n\tmemcpy(data, buf + 4, read_len);\n\n\tkfree(buf);\n\treturn 0;\n\nfailed:\n\terr(\"CI error %d; %02X %02X %02X -> %*ph.\",\n\t     ret, SYNC_BYTE_OUT, id, cmd, 3, buf);\n\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int tt3650_ci_msg_locked(struct dvb_ca_en50221 *ca,\n\t\t\t\tu8 cmd, u8 *data, unsigned int write_len,\n\t\t\t\tunsigned int read_len)\n{\n\tstruct dvb_usb_device *d = ca->data;\n\tstruct pctv452e_state *state = d->priv;\n\tint ret;\n\n\tmutex_lock(&state->ca_mutex);\n\tret = tt3650_ci_msg(d, cmd, data, write_len, read_len);\n\tmutex_unlock(&state->ca_mutex);\n\n\treturn ret;\n}\n\nstatic int tt3650_ci_read_attribute_mem(struct dvb_ca_en50221 *ca,\n\t\t\t\t int slot, int address)\n{\n\tu8 buf[3];\n\tint ret;\n\n\tif (0 != slot)\n\t\treturn -EINVAL;\n\n\tbuf[0] = (address >> 8) & 0x0F;\n\tbuf[1] = address;\n\n\tret = tt3650_ci_msg_locked(ca, TT3650_CMD_CI_RD_ATTR, buf, 2, 3);\n\n\tci_dbg(\"%s %04x -> %d 0x%02x\",\n\t\t__func__, address, ret, buf[2]);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn buf[2];\n}\n\nstatic int tt3650_ci_write_attribute_mem(struct dvb_ca_en50221 *ca,\n\t\t\t\t int slot, int address, u8 value)\n{\n\tu8 buf[3];\n\n\tci_dbg(\"%s %d 0x%04x 0x%02x\",\n\t\t__func__, slot, address, value);\n\n\tif (0 != slot)\n\t\treturn -EINVAL;\n\n\tbuf[0] = (address >> 8) & 0x0F;\n\tbuf[1] = address;\n\tbuf[2] = value;\n\n\treturn tt3650_ci_msg_locked(ca, TT3650_CMD_CI_WR_ATTR, buf, 3, 3);\n}\n\nstatic int tt3650_ci_read_cam_control(struct dvb_ca_en50221 *ca,\n\t\t\t\t int\t\t\tslot,\n\t\t\t\t u8\t\t\taddress)\n{\n\tu8 buf[2];\n\tint ret;\n\n\tif (0 != slot)\n\t\treturn -EINVAL;\n\n\tbuf[0] = address & 3;\n\n\tret = tt3650_ci_msg_locked(ca, TT3650_CMD_CI_RD_CTRL, buf, 1, 2);\n\n\tci_dbg(\"%s 0x%02x -> %d 0x%02x\",\n\t\t__func__, address, ret, buf[1]);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn buf[1];\n}\n\nstatic int tt3650_ci_write_cam_control(struct dvb_ca_en50221 *ca,\n\t\t\t\t int\t\t\tslot,\n\t\t\t\t u8\t\t\taddress,\n\t\t\t\t u8\t\t\tvalue)\n{\n\tu8 buf[2];\n\n\tci_dbg(\"%s %d 0x%02x 0x%02x\",\n\t\t__func__, slot, address, value);\n\n\tif (0 != slot)\n\t\treturn -EINVAL;\n\n\tbuf[0] = address;\n\tbuf[1] = value;\n\n\treturn tt3650_ci_msg_locked(ca, TT3650_CMD_CI_WR_CTRL, buf, 2, 2);\n}\n\nstatic int tt3650_ci_set_video_port(struct dvb_ca_en50221 *ca,\n\t\t\t\t int\t\t\tslot,\n\t\t\t\t int\t\t\tenable)\n{\n\tu8 buf[1];\n\tint ret;\n\n\tci_dbg(\"%s %d %d\", __func__, slot, enable);\n\n\tif (0 != slot)\n\t\treturn -EINVAL;\n\n\tenable = !!enable;\n\tbuf[0] = enable;\n\n\tret = tt3650_ci_msg_locked(ca, TT3650_CMD_CI_SET_VIDEO_PORT, buf, 1, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (enable != buf[0]) {\n\t\terr(\"CI not %sabled.\", enable ? \"en\" : \"dis\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int tt3650_ci_slot_shutdown(struct dvb_ca_en50221 *ca, int slot)\n{\n\treturn tt3650_ci_set_video_port(ca, slot,   0);\n}\n\nstatic int tt3650_ci_slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)\n{\n\treturn tt3650_ci_set_video_port(ca, slot,   1);\n}\n\nstatic int tt3650_ci_slot_reset(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct dvb_usb_device *d = ca->data;\n\tstruct pctv452e_state *state = d->priv;\n\tu8 buf[1];\n\tint ret;\n\n\tci_dbg(\"%s %d\", __func__, slot);\n\n\tif (0 != slot)\n\t\treturn -EINVAL;\n\n\tbuf[0] = 0;\n\n\tmutex_lock(&state->ca_mutex);\n\n\tret = tt3650_ci_msg(d, TT3650_CMD_CI_RESET, buf, 1, 1);\n\tif (0 != ret)\n\t\tgoto failed;\n\n\tmsleep(500);\n\n\tbuf[0] = 1;\n\n\tret = tt3650_ci_msg(d, TT3650_CMD_CI_RESET, buf, 1, 1);\n\tif (0 != ret)\n\t\tgoto failed;\n\n\tmsleep(500);\n\n\tbuf[0] = 0;  \n\n\tret = tt3650_ci_msg(d, TT3650_CMD_CI_SET_VIDEO_PORT, buf, 1, 1);\n\n failed:\n\tmutex_unlock(&state->ca_mutex);\n\n\treturn ret;\n}\n\nstatic int tt3650_ci_poll_slot_status(struct dvb_ca_en50221 *ca,\n\t\t\t\t int\t\t\tslot,\n\t\t\t\t int\t\t\topen)\n{\n\tu8 buf[1];\n\tint ret;\n\n\tif (0 != slot)\n\t\treturn -EINVAL;\n\n\tret = tt3650_ci_msg_locked(ca, TT3650_CMD_CI_TEST, buf, 0, 1);\n\tif (0 != ret)\n\t\treturn ret;\n\n\tif (1 == buf[0])\n\t\treturn DVB_CA_EN50221_POLL_CAM_PRESENT |\n\t\t\tDVB_CA_EN50221_POLL_CAM_READY;\n\n\treturn 0;\n\n}\n\nstatic void tt3650_ci_uninit(struct dvb_usb_device *d)\n{\n\tstruct pctv452e_state *state;\n\n\tci_dbg(\"%s\", __func__);\n\n\tif (NULL == d)\n\t\treturn;\n\n\tstate = d->priv;\n\tif (NULL == state)\n\t\treturn;\n\n\tif (NULL == state->ca.data)\n\t\treturn;\n\n\t \n\ttt3650_ci_set_video_port(&state->ca,   0,   0);\n\n\tdvb_ca_en50221_release(&state->ca);\n\n\tmemset(&state->ca, 0, sizeof(state->ca));\n}\n\nstatic int tt3650_ci_init(struct dvb_usb_adapter *a)\n{\n\tstruct dvb_usb_device *d = a->dev;\n\tstruct pctv452e_state *state = d->priv;\n\tint ret;\n\n\tci_dbg(\"%s\", __func__);\n\n\tmutex_init(&state->ca_mutex);\n\n\tstate->ca.owner = THIS_MODULE;\n\tstate->ca.read_attribute_mem = tt3650_ci_read_attribute_mem;\n\tstate->ca.write_attribute_mem = tt3650_ci_write_attribute_mem;\n\tstate->ca.read_cam_control = tt3650_ci_read_cam_control;\n\tstate->ca.write_cam_control = tt3650_ci_write_cam_control;\n\tstate->ca.slot_reset = tt3650_ci_slot_reset;\n\tstate->ca.slot_shutdown = tt3650_ci_slot_shutdown;\n\tstate->ca.slot_ts_enable = tt3650_ci_slot_ts_enable;\n\tstate->ca.poll_slot_status = tt3650_ci_poll_slot_status;\n\tstate->ca.data = d;\n\n\tret = dvb_ca_en50221_init(&a->dvb_adap,\n\t\t\t\t   &state->ca,\n\t\t\t\t     0,\n\t\t\t\t     1);\n\tif (0 != ret) {\n\t\terr(\"Cannot initialize CI: Error %d.\", ret);\n\t\tmemset(&state->ca, 0, sizeof(state->ca));\n\t\treturn ret;\n\t}\n\n\tinfo(\"CI initialized.\");\n\n\treturn 0;\n}\n\n#define CMD_BUFFER_SIZE 0x28\nstatic int pctv452e_i2c_msg(struct dvb_usb_device *d, u8 addr,\n\t\t\t\tconst u8 *snd_buf, u8 snd_len,\n\t\t\t\tu8 *rcv_buf, u8 rcv_len)\n{\n\tstruct pctv452e_state *state = d->priv;\n\tu8 *buf;\n\tu8 id;\n\tint ret;\n\n\tbuf = kmalloc(64, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tid = state->c++;\n\n\tret = -EINVAL;\n\tif (snd_len > 64 - 7 || rcv_len > 64 - 7)\n\t\tgoto failed;\n\n\tbuf[0] = SYNC_BYTE_OUT;\n\tbuf[1] = id;\n\tbuf[2] = PCTV_CMD_I2C;\n\tbuf[3] = snd_len + 3;\n\tbuf[4] = addr << 1;\n\tbuf[5] = snd_len;\n\tbuf[6] = rcv_len;\n\n\tmemcpy(buf + 7, snd_buf, snd_len);\n\n\tret = dvb_usb_generic_rw(d, buf, 7 + snd_len,\n\t\t\t\t  buf,   64,\n\t\t\t\t    0);\n\tif (ret < 0)\n\t\tgoto failed;\n\n\t \n\tret = -EIO;\n\tif (SYNC_BYTE_IN != buf[0] || id != buf[1])\n\t\tgoto failed;\n\n\t \n\tret = -EREMOTEIO;\n\tif (buf[5] < snd_len || buf[6] < rcv_len)\n\t\tgoto failed;\n\n\tmemcpy(rcv_buf, buf + 7, rcv_len);\n\n\tkfree(buf);\n\treturn rcv_len;\n\nfailed:\n\terr(\"I2C error %d; %02X %02X  %02X %02X %02X -> %*ph\",\n\t     ret, SYNC_BYTE_OUT, id, addr << 1, snd_len, rcv_len,\n\t     7, buf);\n\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int pctv452e_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msg,\n\t\t\t\tint num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adapter);\n\tint i;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tfor (i = 0; i < num; i++) {\n\t\tu8 addr, snd_len, rcv_len, *snd_buf, *rcv_buf;\n\t\tint ret;\n\n\t\tif (msg[i].flags & I2C_M_RD) {\n\t\t\taddr = msg[i].addr;\n\t\t\tsnd_buf = NULL;\n\t\t\tsnd_len = 0;\n\t\t\trcv_buf = msg[i].buf;\n\t\t\trcv_len = msg[i].len;\n\t\t} else {\n\t\t\taddr = msg[i].addr;\n\t\t\tsnd_buf = msg[i].buf;\n\t\t\tsnd_len = msg[i].len;\n\t\t\trcv_buf = NULL;\n\t\t\trcv_len = 0;\n\t\t}\n\n\t\tret = pctv452e_i2c_msg(d, addr, snd_buf, snd_len, rcv_buf,\n\t\t\t\t\trcv_len);\n\t\tif (ret < rcv_len)\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&d->i2c_mutex);\n\treturn i;\n}\n\nstatic u32 pctv452e_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic int pctv452e_power_ctrl(struct dvb_usb_device *d, int i)\n{\n\tstruct pctv452e_state *state = d->priv;\n\tu8 *b0, *rx;\n\tint ret;\n\n\tinfo(\"%s: %d\\n\", __func__, i);\n\n\tif (!i)\n\t\treturn 0;\n\n\tif (state->initialized)\n\t\treturn 0;\n\n\tb0 = kmalloc(5 + PCTV_ANSWER_LEN, GFP_KERNEL);\n\tif (!b0)\n\t\treturn -ENOMEM;\n\n\trx = b0 + 5;\n\n\t \n\tret = usb_set_interface(d->udev, 0, ISOC_INTERFACE_ALTERNATIVE);\n\tif (ret != 0)\n\t\tinfo(\"%s: Warning set interface returned: %d\\n\",\n\t\t\t__func__, ret);\n\n\t \n\tb0[0] = 0xaa;\n\tb0[1] = state->c++;\n\tb0[2] = PCTV_CMD_RESET;\n\tb0[3] = 1;\n\tb0[4] = 0;\n\t \n\tret = dvb_usb_generic_rw(d, b0, 5, rx, PCTV_ANSWER_LEN, 0);\n\tif (ret)\n\t\tgoto ret;\n\n\tb0[1] = state->c++;\n\tb0[4] = 1;\n\t \n\tret = dvb_usb_generic_rw(d, b0, 5, rx, PCTV_ANSWER_LEN, 0);\n\tif (ret)\n\t\tgoto ret;\n\n\tstate->initialized = 1;\n\nret:\n\tkfree(b0);\n\treturn ret;\n}\n\nstatic int pctv452e_rc_query(struct dvb_usb_device *d)\n{\n\tstruct pctv452e_state *state = d->priv;\n\tu8 *b, *rx;\n\tint ret, i;\n\tu8 id;\n\n\tb = kmalloc(CMD_BUFFER_SIZE + PCTV_ANSWER_LEN, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\n\trx = b + CMD_BUFFER_SIZE;\n\n\tid = state->c++;\n\n\t \n\tb[0] = SYNC_BYTE_OUT;\n\tb[1] = id;\n\tb[2] = PCTV_CMD_IR;\n\tb[3] = 0;\n\n\t \n\tret = dvb_usb_generic_rw(d, b, 4, rx, PCTV_ANSWER_LEN, 0);\n\tif (ret != 0)\n\t\tgoto ret;\n\n\tif (debug > 3) {\n\t\tinfo(\"%s: read: %2d: %*ph: \", __func__, ret, 3, rx);\n\t\tfor (i = 0; (i < rx[3]) && ((i+3) < PCTV_ANSWER_LEN); i++)\n\t\t\tinfo(\" %02x\", rx[i+3]);\n\n\t\tinfo(\"\\n\");\n\t}\n\n\tif ((rx[3] == 9) &&  (rx[12] & 0x01)) {\n\t\t \n\t\tstate->last_rc_key = RC_SCANCODE_RC5(rx[7], rx[6]);\n\t\tif (debug > 2)\n\t\t\tinfo(\"%s: cmd=0x%02x sys=0x%02x\\n\",\n\t\t\t\t__func__, rx[6], rx[7]);\n\n\t\trc_keydown(d->rc_dev, RC_PROTO_RC5, state->last_rc_key, 0);\n\t} else if (state->last_rc_key) {\n\t\trc_keyup(d->rc_dev);\n\t\tstate->last_rc_key = 0;\n\t}\nret:\n\tkfree(b);\n\treturn ret;\n}\n\nstatic int pctv452e_read_mac_address(struct dvb_usb_device *d, u8 mac[6])\n{\n\tconst u8 mem_addr[] = { 0x1f, 0xcc };\n\tu8 encoded_mac[20];\n\tint ret;\n\n\tret = -EAGAIN;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\tgoto failed;\n\n\tret = pctv452e_i2c_msg(d, I2C_ADDR_24C16,\n\t\t\t\tmem_addr + 1,   1,\n\t\t\t\tencoded_mac,   20);\n\tif (-EREMOTEIO == ret)\n\t\t \n\t\tret = pctv452e_i2c_msg(d, I2C_ADDR_24C64,\n\t\t\t\t\tmem_addr, 2,\n\t\t\t\t\tencoded_mac, 20);\n\n\tmutex_unlock(&d->i2c_mutex);\n\n\tif (20 != ret)\n\t\tgoto failed;\n\n\tret = ttpci_eeprom_decode_mac(mac, encoded_mac);\n\tif (0 != ret)\n\t\tgoto failed;\n\n\treturn 0;\n\nfailed:\n\teth_zero_addr(mac);\n\n\treturn ret;\n}\n\nstatic const struct stb0899_s1_reg pctv452e_init_dev[] = {\n\t{ STB0899_DISCNTRL1,\t0x26 },\n\t{ STB0899_DISCNTRL2,\t0x80 },\n\t{ STB0899_DISRX_ST0,\t0x04 },\n\t{ STB0899_DISRX_ST1,\t0x20 },\n\t{ STB0899_DISPARITY,\t0x00 },\n\t{ STB0899_DISFIFO,\t0x00 },\n\t{ STB0899_DISF22,\t0x99 },\n\t{ STB0899_DISF22RX,\t0x85 },  \n\t{ STB0899_ACRPRESC,\t0x11 },\n\t{ STB0899_ACRDIV1,\t0x0a },\n\t{ STB0899_ACRDIV2,\t0x05 },\n\t{ STB0899_DACR1\t,\t0x00 },\n\t{ STB0899_DACR2\t,\t0x00 },\n\t{ STB0899_OUTCFG,\t0x00 },\n\t{ STB0899_MODECFG,\t0x00 },  \n\t{ STB0899_IRQMSK_3,\t0xf3 },\n\t{ STB0899_IRQMSK_2,\t0xfc },\n\t{ STB0899_IRQMSK_1,\t0xff },\n\t{ STB0899_IRQMSK_0,\t0xff },\n\t{ STB0899_I2CCFG,\t0x88 },\n\t{ STB0899_I2CRPT,\t0x58 },\n\t{ STB0899_GPIO00CFG,\t0x82 },\n\t{ STB0899_GPIO01CFG,\t0x82 },  \n\t{ STB0899_GPIO02CFG,\t0x82 },\n\t{ STB0899_GPIO03CFG,\t0x82 },\n\t{ STB0899_GPIO04CFG,\t0x82 },\n\t{ STB0899_GPIO05CFG,\t0x82 },\n\t{ STB0899_GPIO06CFG,\t0x82 },\n\t{ STB0899_GPIO07CFG,\t0x82 },\n\t{ STB0899_GPIO08CFG,\t0x82 },\n\t{ STB0899_GPIO09CFG,\t0x82 },\n\t{ STB0899_GPIO10CFG,\t0x82 },\n\t{ STB0899_GPIO11CFG,\t0x82 },\n\t{ STB0899_GPIO12CFG,\t0x82 },\n\t{ STB0899_GPIO13CFG,\t0x82 },\n\t{ STB0899_GPIO14CFG,\t0x82 },\n\t{ STB0899_GPIO15CFG,\t0x82 },\n\t{ STB0899_GPIO16CFG,\t0x82 },\n\t{ STB0899_GPIO17CFG,\t0x82 },\n\t{ STB0899_GPIO18CFG,\t0x82 },\n\t{ STB0899_GPIO19CFG,\t0x82 },\n\t{ STB0899_GPIO20CFG,\t0x82 },\n\t{ STB0899_SDATCFG,\t0xb8 },\n\t{ STB0899_SCLTCFG,\t0xba },\n\t{ STB0899_AGCRFCFG,\t0x1c },  \n\t{ STB0899_GPIO22,\t0x82 },\n\t{ STB0899_GPIO21,\t0x91 },\n\t{ STB0899_DIRCLKCFG,\t0x82 },\n\t{ STB0899_CLKOUT27CFG,\t0x7e },\n\t{ STB0899_STDBYCFG,\t0x82 },\n\t{ STB0899_CS0CFG,\t0x82 },\n\t{ STB0899_CS1CFG,\t0x82 },\n\t{ STB0899_DISEQCOCFG,\t0x20 },\n\t{ STB0899_NCOARSE,\t0x15 },  \n\t{ STB0899_SYNTCTRL,\t0x00 },  \n\t{ STB0899_FILTCTRL,\t0x00 },\n\t{ STB0899_SYSCTRL,\t0x00 },\n\t{ STB0899_STOPCLK1,\t0x20 },  \n\t{ STB0899_STOPCLK2,\t0x00 },\n\t{ STB0899_INTBUFCTRL,\t0x0a },\n\t{ STB0899_AGC2I1,\t0x00 },\n\t{ STB0899_AGC2I2,\t0x00 },\n\t{ STB0899_AGCIQIN,\t0x00 },\n\t{ STB0899_TSTRES,\t0x40 },  \n\t{ 0xffff,\t\t0xff },\n};\n\nstatic const struct stb0899_s1_reg pctv452e_init_s1_demod[] = {\n\t{ STB0899_DEMOD,\t0x00 },\n\t{ STB0899_RCOMPC,\t0xc9 },\n\t{ STB0899_AGC1CN,\t0x01 },\n\t{ STB0899_AGC1REF,\t0x10 },\n\t{ STB0899_RTC,\t\t0x23 },\n\t{ STB0899_TMGCFG,\t0x4e },\n\t{ STB0899_AGC2REF,\t0x34 },\n\t{ STB0899_TLSR,\t\t0x84 },\n\t{ STB0899_CFD,\t\t0xf7 },\n\t{ STB0899_ACLC,\t\t0x87 },\n\t{ STB0899_BCLC,\t\t0x94 },\n\t{ STB0899_EQON,\t\t0x41 },\n\t{ STB0899_LDT,\t\t0xf1 },\n\t{ STB0899_LDT2,\t\t0xe3 },\n\t{ STB0899_EQUALREF,\t0xb4 },\n\t{ STB0899_TMGRAMP,\t0x10 },\n\t{ STB0899_TMGTHD,\t0x30 },\n\t{ STB0899_IDCCOMP,\t0xfd },\n\t{ STB0899_QDCCOMP,\t0xff },\n\t{ STB0899_POWERI,\t0x0c },\n\t{ STB0899_POWERQ,\t0x0f },\n\t{ STB0899_RCOMP,\t0x6c },\n\t{ STB0899_AGCIQIN,\t0x80 },\n\t{ STB0899_AGC2I1,\t0x06 },\n\t{ STB0899_AGC2I2,\t0x00 },\n\t{ STB0899_TLIR,\t\t0x30 },\n\t{ STB0899_RTF,\t\t0x7f },\n\t{ STB0899_DSTATUS,\t0x00 },\n\t{ STB0899_LDI,\t\t0xbc },\n\t{ STB0899_CFRM,\t\t0xea },\n\t{ STB0899_CFRL,\t\t0x31 },\n\t{ STB0899_NIRM,\t\t0x2b },\n\t{ STB0899_NIRL,\t\t0x80 },\n\t{ STB0899_ISYMB,\t0x1d },\n\t{ STB0899_QSYMB,\t0xa6 },\n\t{ STB0899_SFRH,\t\t0x2f },\n\t{ STB0899_SFRM,\t\t0x68 },\n\t{ STB0899_SFRL,\t\t0x40 },\n\t{ STB0899_SFRUPH,\t0x2f },\n\t{ STB0899_SFRUPM,\t0x68 },\n\t{ STB0899_SFRUPL,\t0x40 },\n\t{ STB0899_EQUAI1,\t0x02 },\n\t{ STB0899_EQUAQ1,\t0xff },\n\t{ STB0899_EQUAI2,\t0x04 },\n\t{ STB0899_EQUAQ2,\t0x05 },\n\t{ STB0899_EQUAI3,\t0x02 },\n\t{ STB0899_EQUAQ3,\t0xfd },\n\t{ STB0899_EQUAI4,\t0x03 },\n\t{ STB0899_EQUAQ4,\t0x07 },\n\t{ STB0899_EQUAI5,\t0x08 },\n\t{ STB0899_EQUAQ5,\t0xf5 },\n\t{ STB0899_DSTATUS2,\t0x00 },\n\t{ STB0899_VSTATUS,\t0x00 },\n\t{ STB0899_VERROR,\t0x86 },\n\t{ STB0899_IQSWAP,\t0x2a },\n\t{ STB0899_ECNT1M,\t0x00 },\n\t{ STB0899_ECNT1L,\t0x00 },\n\t{ STB0899_ECNT2M,\t0x00 },\n\t{ STB0899_ECNT2L,\t0x00 },\n\t{ STB0899_ECNT3M,\t0x0a },\n\t{ STB0899_ECNT3L,\t0xad },\n\t{ STB0899_FECAUTO1,\t0x06 },\n\t{ STB0899_FECM,\t\t0x01 },\n\t{ STB0899_VTH12,\t0xb0 },\n\t{ STB0899_VTH23,\t0x7a },\n\t{ STB0899_VTH34,\t0x58 },\n\t{ STB0899_VTH56,\t0x38 },\n\t{ STB0899_VTH67,\t0x34 },\n\t{ STB0899_VTH78,\t0x24 },\n\t{ STB0899_PRVIT,\t0xff },\n\t{ STB0899_VITSYNC,\t0x19 },\n\t{ STB0899_RSULC,\t0xb1 },  \n\t{ STB0899_TSULC,\t0x42 },\n\t{ STB0899_RSLLC,\t0x41 },\n\t{ STB0899_TSLPL,\t0x12 },\n\t{ STB0899_TSCFGH,\t0x0c },\n\t{ STB0899_TSCFGM,\t0x00 },\n\t{ STB0899_TSCFGL,\t0x00 },\n\t{ STB0899_TSOUT,\t0x69 },  \n\t{ STB0899_RSSYNCDEL,\t0x00 },\n\t{ STB0899_TSINHDELH,\t0x02 },\n\t{ STB0899_TSINHDELM,\t0x00 },\n\t{ STB0899_TSINHDELL,\t0x00 },\n\t{ STB0899_TSLLSTKM,\t0x1b },\n\t{ STB0899_TSLLSTKL,\t0xb3 },\n\t{ STB0899_TSULSTKM,\t0x00 },\n\t{ STB0899_TSULSTKL,\t0x00 },\n\t{ STB0899_PCKLENUL,\t0xbc },\n\t{ STB0899_PCKLENLL,\t0xcc },\n\t{ STB0899_RSPCKLEN,\t0xbd },\n\t{ STB0899_TSSTATUS,\t0x90 },\n\t{ STB0899_ERRCTRL1,\t0xb6 },\n\t{ STB0899_ERRCTRL2,\t0x95 },\n\t{ STB0899_ERRCTRL3,\t0x8d },\n\t{ STB0899_DMONMSK1,\t0x27 },\n\t{ STB0899_DMONMSK0,\t0x03 },\n\t{ STB0899_DEMAPVIT,\t0x5c },\n\t{ STB0899_PLPARM,\t0x19 },\n\t{ STB0899_PDELCTRL,\t0x48 },\n\t{ STB0899_PDELCTRL2,\t0x00 },\n\t{ STB0899_BBHCTRL1,\t0x00 },\n\t{ STB0899_BBHCTRL2,\t0x00 },\n\t{ STB0899_HYSTTHRESH,\t0x77 },\n\t{ STB0899_MATCSTM,\t0x00 },\n\t{ STB0899_MATCSTL,\t0x00 },\n\t{ STB0899_UPLCSTM,\t0x00 },\n\t{ STB0899_UPLCSTL,\t0x00 },\n\t{ STB0899_DFLCSTM,\t0x00 },\n\t{ STB0899_DFLCSTL,\t0x00 },\n\t{ STB0899_SYNCCST,\t0x00 },\n\t{ STB0899_SYNCDCSTM,\t0x00 },\n\t{ STB0899_SYNCDCSTL,\t0x00 },\n\t{ STB0899_ISI_ENTRY,\t0x00 },\n\t{ STB0899_ISI_BIT_EN,\t0x00 },\n\t{ STB0899_MATSTRM,\t0xf0 },\n\t{ STB0899_MATSTRL,\t0x02 },\n\t{ STB0899_UPLSTRM,\t0x45 },\n\t{ STB0899_UPLSTRL,\t0x60 },\n\t{ STB0899_DFLSTRM,\t0xe3 },\n\t{ STB0899_DFLSTRL,\t0x00 },\n\t{ STB0899_SYNCSTR,\t0x47 },\n\t{ STB0899_SYNCDSTRM,\t0x05 },\n\t{ STB0899_SYNCDSTRL,\t0x18 },\n\t{ STB0899_CFGPDELSTATUS1, 0x19 },\n\t{ STB0899_CFGPDELSTATUS2, 0x2b },\n\t{ STB0899_BBFERRORM,\t0x00 },\n\t{ STB0899_BBFERRORL,\t0x01 },\n\t{ STB0899_UPKTERRORM,\t0x00 },\n\t{ STB0899_UPKTERRORL,\t0x00 },\n\t{ 0xffff,\t\t0xff },\n};\n\nstatic struct stb0899_config stb0899_config = {\n\t.init_dev\t= pctv452e_init_dev,\n\t.init_s2_demod\t= stb0899_s2_init_2,\n\t.init_s1_demod\t= pctv452e_init_s1_demod,\n\t.init_s2_fec\t= stb0899_s2_init_4,\n\t.init_tst\t= stb0899_s1_init_5,\n\n\t.demod_address   = I2C_ADDR_STB0899,  \n\t.block_sync_mode = STB0899_SYNC_FORCED,  \n\n\t.xtal_freq       = 27000000,\t  \n\t.inversion       = IQ_SWAP_ON,\n\n\t.lo_clk\t  = 76500000,\n\t.hi_clk\t  = 99000000,\n\n\t.ts_output_mode  = 0,\t \n\t.clock_polarity  = 0,\n\t.data_clk_parity = 0,\n\t.fec_mode\t= 0,\n\n\t.esno_ave\t    = STB0899_DVBS2_ESNO_AVE,\n\t.esno_quant\t  = STB0899_DVBS2_ESNO_QUANT,\n\t.avframes_coarse     = STB0899_DVBS2_AVFRAMES_COARSE,\n\t.avframes_fine       = STB0899_DVBS2_AVFRAMES_FINE,\n\t.miss_threshold      = STB0899_DVBS2_MISS_THRESHOLD,\n\t.uwp_threshold_acq   = STB0899_DVBS2_UWP_THRESHOLD_ACQ,\n\t.uwp_threshold_track = STB0899_DVBS2_UWP_THRESHOLD_TRACK,\n\t.uwp_threshold_sof   = STB0899_DVBS2_UWP_THRESHOLD_SOF,\n\t.sof_search_timeout  = STB0899_DVBS2_SOF_SEARCH_TIMEOUT,\n\n\t.btr_nco_bits\t  = STB0899_DVBS2_BTR_NCO_BITS,\n\t.btr_gain_shift_offset = STB0899_DVBS2_BTR_GAIN_SHIFT_OFFSET,\n\t.crl_nco_bits\t  = STB0899_DVBS2_CRL_NCO_BITS,\n\t.ldpc_max_iter\t = STB0899_DVBS2_LDPC_MAX_ITER,\n\n\t.tuner_get_frequency\t= stb6100_get_frequency,\n\t.tuner_set_frequency\t= stb6100_set_frequency,\n\t.tuner_set_bandwidth\t= stb6100_set_bandwidth,\n\t.tuner_get_bandwidth\t= stb6100_get_bandwidth,\n\t.tuner_set_rfsiggain\t= NULL,\n\n\t \n\t.postproc = pctv45e_postproc\n};\n\nstatic struct stb6100_config stb6100_config = {\n\t.tuner_address = I2C_ADDR_STB6100,\n\t.refclock      = 27000000\n};\n\n\nstatic struct i2c_algorithm pctv452e_i2c_algo = {\n\t.master_xfer   = pctv452e_i2c_xfer,\n\t.functionality = pctv452e_i2c_func\n};\n\nstatic int pctv452e_frontend_attach(struct dvb_usb_adapter *a)\n{\n\tstruct usb_device_id *id;\n\n\ta->fe_adap[0].fe = dvb_attach(stb0899_attach, &stb0899_config,\n\t\t\t\t\t\t&a->dev->i2c_adap);\n\tif (!a->fe_adap[0].fe)\n\t\treturn -ENODEV;\n\n\tid = a->dev->desc->warm_ids[0];\n\tif (id->idVendor == USB_VID_TECHNOTREND &&\n\t    id->idProduct == USB_PID_TECHNOTREND_CONNECT_S2_3650_CI) {\n\t\tif (dvb_attach(lnbp22_attach,\n\t\t\t       a->fe_adap[0].fe,\n\t\t\t       &a->dev->i2c_adap) == NULL) {\n\t\t\terr(\"Cannot attach lnbp22\\n\");\n\t\t}\n\t\t \n\t\ttt3650_ci_init(a);\n\t} else if (dvb_attach(isl6423_attach,\n\t\t\t      a->fe_adap[0].fe,\n\t\t\t      &a->dev->i2c_adap,\n\t\t\t      &pctv452e_isl6423_config) == NULL) {\n\t\terr(\"Cannot attach isl6423\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int pctv452e_tuner_attach(struct dvb_usb_adapter *a)\n{\n\tif (!a->fe_adap[0].fe)\n\t\treturn -ENODEV;\n\tif (dvb_attach(stb6100_attach, a->fe_adap[0].fe, &stb6100_config,\n\t\t\t\t\t&a->dev->i2c_adap) == NULL) {\n\t\terr(\"%s failed\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nenum {\n\tPINNACLE_PCTV_452E,\n\tTECHNOTREND_CONNECT_S2_3600,\n\tTECHNOTREND_CONNECT_S2_3650_CI,\n};\n\nstatic struct usb_device_id pctv452e_usb_table[] = {\n\tDVB_USB_DEV(PINNACLE, PINNACLE_PCTV_452E),\n\tDVB_USB_DEV(TECHNOTREND, TECHNOTREND_CONNECT_S2_3600),\n\tDVB_USB_DEV(TECHNOTREND, TECHNOTREND_CONNECT_S2_3650_CI),\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, pctv452e_usb_table);\n\nstatic struct dvb_usb_device_properties pctv452e_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,  \n\t.usb_ctrl = DEVICE_SPECIFIC,\n\n\t.size_of_priv     = sizeof(struct pctv452e_state),\n\n\t.power_ctrl       = pctv452e_power_ctrl,\n\n\t.rc.core = {\n\t\t.rc_codes\t= RC_MAP_DIB0700_RC5_TABLE,\n\t\t.allowed_protos\t= RC_PROTO_BIT_RC5,\n\t\t.rc_query\t= pctv452e_rc_query,\n\t\t.rc_interval\t= 100,\n\t},\n\n\t.num_adapters     = 1,\n\t.adapter = {{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.frontend_attach  = pctv452e_frontend_attach,\n\t\t\t.tuner_attach     = pctv452e_tuner_attach,\n\n\t\t\t \n\t\t\t.stream = {\n\t\t\t\t.type     = USB_ISOC,\n\t\t\t\t.count    = 4,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.isoc = {\n\t\t\t\t\t\t.framesperurb = 4,\n\t\t\t\t\t\t.framesize    = 940,\n\t\t\t\t\t\t.interval     = 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t} },\n\t} },\n\n\t.i2c_algo = &pctv452e_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 1,  \n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{ .name = \"PCTV HDTV USB\",\n\t\t  .cold_ids = { NULL, NULL },  \n\t\t  .warm_ids = { &pctv452e_usb_table[PINNACLE_PCTV_452E], NULL }\n\t\t},\n\t\t{ NULL },\n\t}\n};\n\nstatic struct dvb_usb_device_properties tt_connect_s2_3600_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,  \n\t.usb_ctrl = DEVICE_SPECIFIC,\n\n\t.size_of_priv\t\t= sizeof(struct pctv452e_state),\n\n\t.power_ctrl\t\t= pctv452e_power_ctrl,\n\t.read_mac_address\t= pctv452e_read_mac_address,\n\n\t.rc.core = {\n\t\t.rc_codes\t= RC_MAP_TT_1500,\n\t\t.allowed_protos\t= RC_PROTO_BIT_RC5,\n\t\t.rc_query\t= pctv452e_rc_query,\n\t\t.rc_interval\t= 100,\n\t},\n\n\t.num_adapters\t\t= 1,\n\t.adapter = {{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.frontend_attach = pctv452e_frontend_attach,\n\t\t\t.tuner_attach = pctv452e_tuner_attach,\n\n\t\t\t \n\t\t\t.stream = {\n\t\t\t\t.type = USB_ISOC,\n\t\t\t\t.count = 4,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.isoc = {\n\t\t\t\t\t\t.framesperurb = 64,\n\t\t\t\t\t\t.framesize = 940,\n\t\t\t\t\t\t.interval = 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t} },\n\t} },\n\n\t.i2c_algo = &pctv452e_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 1,  \n\n\t.num_device_descs = 2,\n\t.devices = {\n\t\t{ .name = \"Technotrend TT Connect S2-3600\",\n\t\t  .cold_ids = { NULL, NULL },  \n\t\t  .warm_ids = { &pctv452e_usb_table[TECHNOTREND_CONNECT_S2_3600], NULL }\n\t\t},\n\t\t{ .name = \"Technotrend TT Connect S2-3650-CI\",\n\t\t  .cold_ids = { NULL, NULL },\n\t\t  .warm_ids = { &pctv452e_usb_table[TECHNOTREND_CONNECT_S2_3650_CI], NULL }\n\t\t},\n\t\t{ NULL },\n\t}\n};\n\nstatic void pctv452e_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\n\ttt3650_ci_uninit(d);\n\tdvb_usb_device_exit(intf);\n}\n\nstatic int pctv452e_usb_probe(struct usb_interface *intf,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\tif (0 == dvb_usb_device_init(intf, &pctv452e_properties,\n\t\t\t\t\tTHIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &tt_connect_s2_3600_properties,\n\t\t\t\t\tTHIS_MODULE, NULL, adapter_nr))\n\t\treturn 0;\n\n\treturn -ENODEV;\n}\n\nstatic struct usb_driver pctv452e_usb_driver = {\n\t.name       = \"pctv452e\",\n\t.probe      = pctv452e_usb_probe,\n\t.disconnect = pctv452e_usb_disconnect,\n\t.id_table   = pctv452e_usb_table,\n};\n\nmodule_usb_driver(pctv452e_usb_driver);\n\nMODULE_AUTHOR(\"Dominik Kuhlen <dkuhlen@gmx.net>\");\nMODULE_AUTHOR(\"Andre Weidemann <Andre.Weidemann@web.de>\");\nMODULE_AUTHOR(\"Michael H. Schimek <mschimek@gmx.at>\");\nMODULE_DESCRIPTION(\"Pinnacle PCTV HDTV USB DVB / TT connect S2-3600 Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}