{
  "module_name": "dibusb-common.c",
  "hash_id": "c0d54ae0da551ac6ec9cc4c7ab367532fe041a2228e1e681d2365ff701d1d41b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/dibusb-common.c",
  "human_readable_source": "\n \n\n#include \"dibusb.h\"\n\n \n#define MAX_XFER_SIZE  64\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=info (|-able)).\" DVB_USB_DEBUG_STATUS);\nMODULE_LICENSE(\"GPL\");\n\n#define deb_info(args...) dprintk(debug,0x01,args)\n\n \nint dibusb_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\n{\n\tif (adap->priv != NULL) {\n\t\tstruct dibusb_state *st = adap->priv;\n\t\tif (st->ops.fifo_ctrl != NULL)\n\t\t\tif (st->ops.fifo_ctrl(adap->fe_adap[0].fe, onoff)) {\n\t\t\t\terr(\"error while controlling the fifo of the demod.\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(dibusb_streaming_ctrl);\n\nint dibusb_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid, int onoff)\n{\n\tif (adap->priv != NULL) {\n\t\tstruct dibusb_state *st = adap->priv;\n\t\tif (st->ops.pid_ctrl != NULL)\n\t\t\tst->ops.pid_ctrl(adap->fe_adap[0].fe,\n\t\t\t\t\t index, pid, onoff);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(dibusb_pid_filter);\n\nint dibusb_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)\n{\n\tif (adap->priv != NULL) {\n\t\tstruct dibusb_state *st = adap->priv;\n\t\tif (st->ops.pid_parse != NULL)\n\t\t\tif (st->ops.pid_parse(adap->fe_adap[0].fe, onoff) < 0)\n\t\t\t\terr(\"could not handle pid_parser\");\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(dibusb_pid_filter_ctrl);\n\nint dibusb_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tu8 *b;\n\tint ret;\n\n\tb = kmalloc(3, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\n\tb[0] = DIBUSB_REQ_SET_IOCTL;\n\tb[1] = DIBUSB_IOCTL_CMD_POWER_MODE;\n\tb[2] = onoff ? DIBUSB_IOCTL_POWER_WAKEUP : DIBUSB_IOCTL_POWER_SLEEP;\n\n\tret = dvb_usb_generic_write(d, b, 3);\n\n\tkfree(b);\n\n\tmsleep(10);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dibusb_power_ctrl);\n\nint dibusb2_0_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\n{\n\tint ret;\n\tu8 *b;\n\n\tb = kmalloc(3, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\n\tif ((ret = dibusb_streaming_ctrl(adap,onoff)) < 0)\n\t\tgoto ret;\n\n\tif (onoff) {\n\t\tb[0] = DIBUSB_REQ_SET_STREAMING_MODE;\n\t\tb[1] = 0x00;\n\t\tret = dvb_usb_generic_write(adap->dev, b, 2);\n\t\tif (ret  < 0)\n\t\t\tgoto ret;\n\t}\n\n\tb[0] = DIBUSB_REQ_SET_IOCTL;\n\tb[1] = onoff ? DIBUSB_IOCTL_CMD_ENABLE_STREAM : DIBUSB_IOCTL_CMD_DISABLE_STREAM;\n\tret = dvb_usb_generic_write(adap->dev, b, 3);\n\nret:\n\tkfree(b);\n\treturn ret;\n}\nEXPORT_SYMBOL(dibusb2_0_streaming_ctrl);\n\nint dibusb2_0_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\tu8 *b;\n\tint ret;\n\n\tif (!onoff)\n\t\treturn 0;\n\n\tb = kmalloc(3, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\n\tb[0] = DIBUSB_REQ_SET_IOCTL;\n\tb[1] = DIBUSB_IOCTL_CMD_POWER_MODE;\n\tb[2] = DIBUSB_IOCTL_POWER_WAKEUP;\n\n\tret = dvb_usb_generic_write(d, b, 3);\n\n\tkfree(b);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dibusb2_0_power_ctrl);\n\nstatic int dibusb_i2c_msg(struct dvb_usb_device *d, u8 addr,\n\t\t\t  u8 *wbuf, u16 wlen, u8 *rbuf, u16 rlen)\n{\n\tu8 *sndbuf;\n\tint ret, wo, len;\n\n\t \n\two = (rbuf == NULL || rlen == 0);\n\n\tlen = 2 + wlen + (wo ? 0 : 2);\n\n\tsndbuf = kmalloc(MAX_XFER_SIZE, GFP_KERNEL);\n\tif (!sndbuf)\n\t\treturn -ENOMEM;\n\n\tif (4 + wlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c wr: len=%d is too big!\\n\", wlen);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto ret;\n\t}\n\n\tsndbuf[0] = wo ? DIBUSB_REQ_I2C_WRITE : DIBUSB_REQ_I2C_READ;\n\tsndbuf[1] = (addr << 1) | (wo ? 0 : 1);\n\n\tmemcpy(&sndbuf[2], wbuf, wlen);\n\n\tif (!wo) {\n\t\tsndbuf[wlen + 2] = (rlen >> 8) & 0xff;\n\t\tsndbuf[wlen + 3] = rlen & 0xff;\n\t}\n\n\tret = dvb_usb_generic_rw(d, sndbuf, len, rbuf, rlen, 0);\n\nret:\n\tkfree(sndbuf);\n\treturn ret;\n}\n\n \nstatic int dibusb_i2c_xfer(struct i2c_adapter *adap,struct i2c_msg msg[],int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint i;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tfor (i = 0; i < num; i++) {\n\t\t \n\t\tif (i+1 < num && (msg[i].flags & I2C_M_RD) == 0\n\t\t\t\t\t  && (msg[i+1].flags & I2C_M_RD)) {\n\t\t\tif (dibusb_i2c_msg(d, msg[i].addr, msg[i].buf,msg[i].len,\n\t\t\t\t\t\tmsg[i+1].buf,msg[i+1].len) < 0)\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t} else if ((msg[i].flags & I2C_M_RD) == 0) {\n\t\t\tif (dibusb_i2c_msg(d, msg[i].addr, msg[i].buf,msg[i].len,NULL,0) < 0)\n\t\t\t\tbreak;\n\t\t} else if (msg[i].addr != 0x50) {\n\t\t\t \n\t\t\tif (dibusb_i2c_msg(d, msg[i].addr, NULL, 0, msg[i].buf, msg[i].len) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&d->i2c_mutex);\n\treturn i;\n}\n\nstatic u32 dibusb_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstruct i2c_algorithm dibusb_i2c_algo = {\n\t.master_xfer   = dibusb_i2c_xfer,\n\t.functionality = dibusb_i2c_func,\n};\nEXPORT_SYMBOL(dibusb_i2c_algo);\n\nint dibusb_read_eeprom_byte(struct dvb_usb_device *d, u8 offs, u8 *val)\n{\n\tu8 *buf;\n\tint rc;\n\n\tbuf = kzalloc(2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = offs;\n\n\trc = dibusb_i2c_msg(d, 0x50, &buf[0], 1, &buf[1], 1);\n\t*val = buf[1];\n\tkfree(buf);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(dibusb_read_eeprom_byte);\n\n \nstruct rc_map_table rc_map_dibusb_table[] = {\n\t \n\t{ 0x0016, KEY_POWER },\n\t{ 0x0010, KEY_MUTE },\n\t{ 0x0003, KEY_1 },\n\t{ 0x0001, KEY_2 },\n\t{ 0x0006, KEY_3 },\n\t{ 0x0009, KEY_4 },\n\t{ 0x001d, KEY_5 },\n\t{ 0x001f, KEY_6 },\n\t{ 0x000d, KEY_7 },\n\t{ 0x0019, KEY_8 },\n\t{ 0x001b, KEY_9 },\n\t{ 0x0015, KEY_0 },\n\t{ 0x0005, KEY_CHANNELUP },\n\t{ 0x0002, KEY_CHANNELDOWN },\n\t{ 0x001e, KEY_VOLUMEUP },\n\t{ 0x000a, KEY_VOLUMEDOWN },\n\t{ 0x0011, KEY_RECORD },\n\t{ 0x0017, KEY_FAVORITES },  \n\t{ 0x0014, KEY_PLAY },\n\t{ 0x001a, KEY_STOP },\n\t{ 0x0040, KEY_REWIND },\n\t{ 0x0012, KEY_FASTFORWARD },\n\t{ 0x000e, KEY_PREVIOUS },  \n\t{ 0x004c, KEY_PAUSE },\n\t{ 0x004d, KEY_SCREEN },  \n\t{ 0x0054, KEY_AUDIO },  \n\t \n\t{ 0x000c, KEY_CANCEL },  \n\t{ 0x001c, KEY_EPG },  \n\t{ 0x0000, KEY_TAB },  \n\t{ 0x0048, KEY_INFO },  \n\t{ 0x0004, KEY_LIST },  \n\t{ 0x000f, KEY_TEXT },  \n\t \n\t{ 0x8612, KEY_POWER },\n\t{ 0x860f, KEY_SELECT },  \n\t{ 0x860c, KEY_UNKNOWN },  \n\t{ 0x860b, KEY_EPG },\n\t{ 0x8610, KEY_MUTE },\n\t{ 0x8601, KEY_1 },\n\t{ 0x8602, KEY_2 },\n\t{ 0x8603, KEY_3 },\n\t{ 0x8604, KEY_4 },\n\t{ 0x8605, KEY_5 },\n\t{ 0x8606, KEY_6 },\n\t{ 0x8607, KEY_7 },\n\t{ 0x8608, KEY_8 },\n\t{ 0x8609, KEY_9 },\n\t{ 0x860a, KEY_0 },\n\t{ 0x8618, KEY_ZOOM },\n\t{ 0x861c, KEY_UNKNOWN },  \n\t{ 0x8613, KEY_UNKNOWN },  \n\t{ 0x8600, KEY_UNDO },\n\t{ 0x861d, KEY_RECORD },\n\t{ 0x860d, KEY_STOP },\n\t{ 0x860e, KEY_PAUSE },\n\t{ 0x8616, KEY_PLAY },\n\t{ 0x8611, KEY_BACK },\n\t{ 0x8619, KEY_FORWARD },\n\t{ 0x8614, KEY_UNKNOWN },  \n\t{ 0x8615, KEY_ESC },\n\t{ 0x861a, KEY_UP },\n\t{ 0x861e, KEY_DOWN },\n\t{ 0x861f, KEY_LEFT },\n\t{ 0x861b, KEY_RIGHT },\n\n\t \n\t{ 0x8000, KEY_MUTE },\n\t{ 0x8001, KEY_TEXT },\n\t{ 0x8002, KEY_HOME },\n\t{ 0x8003, KEY_POWER },\n\n\t{ 0x8004, KEY_RED },\n\t{ 0x8005, KEY_GREEN },\n\t{ 0x8006, KEY_YELLOW },\n\t{ 0x8007, KEY_BLUE },\n\n\t{ 0x8008, KEY_DVD },\n\t{ 0x8009, KEY_AUDIO },\n\t{ 0x800a, KEY_IMAGES },       \n\t{ 0x800b, KEY_VIDEO },\n\n\t{ 0x800c, KEY_BACK },\n\t{ 0x800d, KEY_UP },\n\t{ 0x800e, KEY_RADIO },\n\t{ 0x800f, KEY_EPG },\n\n\t{ 0x8010, KEY_LEFT },\n\t{ 0x8011, KEY_OK },\n\t{ 0x8012, KEY_RIGHT },\n\t{ 0x8013, KEY_UNKNOWN },     \n\n\t{ 0x8014, KEY_TV },\n\t{ 0x8015, KEY_DOWN },\n\t{ 0x8016, KEY_MENU },        \n\t{ 0x8017, KEY_LAST },\n\n\t{ 0x8018, KEY_RECORD },\n\t{ 0x8019, KEY_STOP },\n\t{ 0x801a, KEY_PAUSE },\n\t{ 0x801b, KEY_PLAY },\n\n\t{ 0x801c, KEY_PREVIOUS },\n\t{ 0x801d, KEY_REWIND },\n\t{ 0x801e, KEY_FASTFORWARD },\n\t{ 0x801f, KEY_NEXT},\n\n\t{ 0x8040, KEY_1 },\n\t{ 0x8041, KEY_2 },\n\t{ 0x8042, KEY_3 },\n\t{ 0x8043, KEY_CHANNELUP },\n\n\t{ 0x8044, KEY_4 },\n\t{ 0x8045, KEY_5 },\n\t{ 0x8046, KEY_6 },\n\t{ 0x8047, KEY_CHANNELDOWN },\n\n\t{ 0x8048, KEY_7 },\n\t{ 0x8049, KEY_8 },\n\t{ 0x804a, KEY_9 },\n\t{ 0x804b, KEY_VOLUMEUP },\n\n\t{ 0x804c, KEY_CLEAR },\n\t{ 0x804d, KEY_0 },\n\t{ 0x804e, KEY_ENTER },\n\t{ 0x804f, KEY_VOLUMEDOWN },\n};\nEXPORT_SYMBOL(rc_map_dibusb_table);\n\nint dibusb_rc_query(struct dvb_usb_device *d, u32 *event, int *state)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmalloc(5, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = DIBUSB_REQ_POLL_REMOTE;\n\n\tret = dvb_usb_generic_rw(d, buf, 1, buf, 5, 0);\n\tif (ret < 0)\n\t\tgoto ret;\n\n\tdvb_usb_nec_rc_key_to_event(d, buf, event, state);\n\n\tif (buf[0] != 0)\n\t\tdeb_info(\"key: %*ph\\n\", 5, buf);\n\nret:\n\tkfree(buf);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dibusb_rc_query);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}