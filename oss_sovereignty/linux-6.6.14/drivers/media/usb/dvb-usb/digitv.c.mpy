{
  "module_name": "digitv.c",
  "hash_id": "49caa7956bc1cad3954653c5c9b739d30330d5041dbad56dd884eef2057843e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/dvb-usb/digitv.c",
  "human_readable_source": "\n \n#include \"digitv.h\"\n\n#include \"mt352.h\"\n#include \"nxt6000.h\"\n\n \nstatic int dvb_usb_digitv_debug;\nmodule_param_named(debug,dvb_usb_digitv_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=rc (or-able)).\" DVB_USB_DEBUG_STATUS);\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n#define deb_rc(args...)   dprintk(dvb_usb_digitv_debug,0x01,args)\n\nstatic int digitv_ctrl_msg(struct dvb_usb_device *d,\n\t\tu8 cmd, u8 vv, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct digitv_state *st = d->priv;\n\tint ret, wo;\n\n\two = (rbuf == NULL || rlen == 0);  \n\n\tif (wlen > 4 || rlen > 4)\n\t\treturn -EIO;\n\n\tmemset(st->sndbuf, 0, 7);\n\tmemset(st->rcvbuf, 0, 7);\n\n\tst->sndbuf[0] = cmd;\n\tst->sndbuf[1] = vv;\n\tst->sndbuf[2] = wo ? wlen : rlen;\n\n\tif (wo) {\n\t\tmemcpy(&st->sndbuf[3], wbuf, wlen);\n\t\tret = dvb_usb_generic_write(d, st->sndbuf, 7);\n\t} else {\n\t\tret = dvb_usb_generic_rw(d, st->sndbuf, 7, st->rcvbuf, 7, 10);\n\t\tmemcpy(rbuf, &st->rcvbuf[3], rlen);\n\t}\n\treturn ret;\n}\n\n \nstatic int digitv_i2c_xfer(struct i2c_adapter *adap,struct i2c_msg msg[],int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint i;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tif (num > 2)\n\t\twarn(\"more than 2 i2c messages at a time is not handled yet. TODO.\");\n\n\tfor (i = 0; i < num; i++) {\n\t\tif (msg[i].len < 1) {\n\t\t\ti = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (i+1 < num && (msg[i+1].flags & I2C_M_RD)) {\n\t\t\tif (digitv_ctrl_msg(d, USB_READ_COFDM, msg[i].buf[0], NULL, 0,\n\t\t\t\t\t\tmsg[i+1].buf,msg[i+1].len) < 0)\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t} else\n\t\t\tif (digitv_ctrl_msg(d,USB_WRITE_COFDM, msg[i].buf[0],\n\t\t\t\t\t\t&msg[i].buf[1],msg[i].len-1,NULL,0) < 0)\n\t\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&d->i2c_mutex);\n\treturn i;\n}\n\nstatic u32 digitv_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm digitv_i2c_algo = {\n\t.master_xfer   = digitv_i2c_xfer,\n\t.functionality = digitv_i2c_func,\n};\n\n \nstatic int digitv_identify_state(struct usb_device *udev,\n\t\t\t\t const struct dvb_usb_device_properties *props,\n\t\t\t\t const struct dvb_usb_device_description **desc,\n\t\t\t\t int *cold)\n{\n\t*cold = udev->descriptor.iManufacturer == 0 && udev->descriptor.iProduct == 0;\n\treturn 0;\n}\n\nstatic int digitv_mt352_demod_init(struct dvb_frontend *fe)\n{\n\tstatic u8 reset_buf[] = { 0x89, 0x38,  0x8a, 0x2d, 0x50, 0x80 };\n\tstatic u8 init_buf[] = { 0x68, 0xa0,  0x8e, 0x40,  0x53, 0x50,\n\t\t\t0x67, 0x20,  0x7d, 0x01,  0x7c, 0x00,  0x7a, 0x00,\n\t\t\t0x79, 0x20,  0x57, 0x05,  0x56, 0x31,  0x88, 0x0f,\n\t\t\t0x75, 0x32 };\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reset_buf); i += 2)\n\t\tmt352_write(fe, &reset_buf[i], 2);\n\n\tmsleep(1);\n\n\tfor (i = 0; i < ARRAY_SIZE(init_buf); i += 2)\n\t\tmt352_write(fe, &init_buf[i], 2);\n\n\treturn 0;\n}\n\nstatic struct mt352_config digitv_mt352_config = {\n\t.demod_init = digitv_mt352_demod_init,\n};\n\nstatic int digitv_nxt6000_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dvb_usb_adapter *adap = fe->dvb->priv;\n\tu8 b[5];\n\n\tfe->ops.tuner_ops.calc_regs(fe, b, sizeof(b));\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\treturn digitv_ctrl_msg(adap->dev, USB_WRITE_TUNER, 0, &b[1], 4, NULL, 0);\n}\n\nstatic struct nxt6000_config digitv_nxt6000_config = {\n\t.clock_inversion = 1,\n};\n\nstatic int digitv_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct digitv_state *st = adap->dev->priv;\n\n\tadap->fe_adap[0].fe = dvb_attach(mt352_attach, &digitv_mt352_config,\n\t\t\t\t\t &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) != NULL) {\n\t\tst->is_nxt6000 = 0;\n\t\treturn 0;\n\t}\n\tadap->fe_adap[0].fe = dvb_attach(nxt6000_attach,\n\t\t\t\t\t &digitv_nxt6000_config,\n\t\t\t\t\t &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) != NULL) {\n\t\tst->is_nxt6000 = 1;\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}\n\nstatic int digitv_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct digitv_state *st = adap->dev->priv;\n\n\tif (!dvb_attach(dvb_pll_attach, adap->fe_adap[0].fe, 0x60, NULL, DVB_PLL_TDED4))\n\t\treturn -ENODEV;\n\n\tif (st->is_nxt6000)\n\t\tadap->fe_adap[0].fe->ops.tuner_ops.set_params = digitv_nxt6000_tuner_set_params;\n\n\treturn 0;\n}\n\nstatic struct rc_map_table rc_map_digitv_table[] = {\n\t{ 0x5f55, KEY_0 },\n\t{ 0x6f55, KEY_1 },\n\t{ 0x9f55, KEY_2 },\n\t{ 0xaf55, KEY_3 },\n\t{ 0x5f56, KEY_4 },\n\t{ 0x6f56, KEY_5 },\n\t{ 0x9f56, KEY_6 },\n\t{ 0xaf56, KEY_7 },\n\t{ 0x5f59, KEY_8 },\n\t{ 0x6f59, KEY_9 },\n\t{ 0x9f59, KEY_TV },\n\t{ 0xaf59, KEY_AUX },\n\t{ 0x5f5a, KEY_DVD },\n\t{ 0x6f5a, KEY_POWER },\n\t{ 0x9f5a, KEY_CAMERA },      \n\t{ 0xaf5a, KEY_AUDIO },\n\t{ 0x5f65, KEY_INFO },\n\t{ 0x6f65, KEY_F13 },      \n\t{ 0x9f65, KEY_F14 },      \n\t{ 0xaf65, KEY_EPG },\n\t{ 0x5f66, KEY_EXIT },\n\t{ 0x6f66, KEY_MENU },\n\t{ 0x9f66, KEY_UP },\n\t{ 0xaf66, KEY_DOWN },\n\t{ 0x5f69, KEY_LEFT },\n\t{ 0x6f69, KEY_RIGHT },\n\t{ 0x9f69, KEY_ENTER },\n\t{ 0xaf69, KEY_CHANNELUP },\n\t{ 0x5f6a, KEY_CHANNELDOWN },\n\t{ 0x6f6a, KEY_VOLUMEUP },\n\t{ 0x9f6a, KEY_VOLUMEDOWN },\n\t{ 0xaf6a, KEY_RED },\n\t{ 0x5f95, KEY_GREEN },\n\t{ 0x6f95, KEY_YELLOW },\n\t{ 0x9f95, KEY_BLUE },\n\t{ 0xaf95, KEY_SUBTITLE },\n\t{ 0x5f96, KEY_F15 },      \n\t{ 0x6f96, KEY_TEXT },\n\t{ 0x9f96, KEY_MUTE },\n\t{ 0xaf96, KEY_REWIND },\n\t{ 0x5f99, KEY_STOP },\n\t{ 0x6f99, KEY_PLAY },\n\t{ 0x9f99, KEY_FASTFORWARD },\n\t{ 0xaf99, KEY_F16 },      \n\t{ 0x5f9a, KEY_PAUSE },\n\t{ 0x6f9a, KEY_PLAY },\n\t{ 0x9f9a, KEY_RECORD },\n\t{ 0xaf9a, KEY_F17 },      \n\t{ 0x5fa5, KEY_KPPLUS },   \n\t{ 0x6fa5, KEY_KPMINUS },  \n\t{ 0x9fa5, KEY_F18 },      \n\t{ 0xafa5, KEY_F19 },      \n\t{ 0x5fa6, KEY_EMAIL },\n\t{ 0x6fa6, KEY_PHONE },\n\t{ 0x9fa6, KEY_PC },\n};\n\nstatic int digitv_rc_query(struct dvb_usb_device *d, u32 *event, int *state)\n{\n\tstruct rc_map_table *entry;\n\tint ret, i;\n\tu8 key[4];\n\tu8 b[4] = { 0 };\n\n\t*event = 0;\n\t*state = REMOTE_NO_KEY_PRESSED;\n\n\tret = digitv_ctrl_msg(d, USB_READ_REMOTE, 0, NULL, 0, key, 4);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = digitv_ctrl_msg(d, USB_WRITE_REMOTE, 0, b, 4, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (key[0] != 0) {\n\t\tfor (i = 0; i < d->props.rc.legacy.rc_map_size; i++) {\n\t\t\tentry = &d->props.rc.legacy.rc_map_table[i];\n\n\t\t\tif (rc5_custom(entry) == key[0] &&\n\t\t\t    rc5_data(entry) == key[1]) {\n\t\t\t\t*event = entry->keycode;\n\t\t\t\t*state = REMOTE_KEY_PRESSED;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tdeb_rc(\"key: %*ph\\n\", 4, key);\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct dvb_usb_device_properties digitv_properties;\n\nstatic int digitv_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct dvb_usb_device *d;\n\tint ret = dvb_usb_device_init(intf, &digitv_properties, THIS_MODULE, &d,\n\t\t\t\t      adapter_nr);\n\tif (ret == 0) {\n\t\tu8 b[4] = { 0 };\n\n\t\tif (d != NULL) {  \n\t\t\tb[0] = 1;\n\t\t\tdigitv_ctrl_msg(d,USB_WRITE_REMOTE_TYPE,0,b,4,NULL,0);\n\n\t\t\tb[0] = 0;\n\t\t\tdigitv_ctrl_msg(d,USB_WRITE_REMOTE,0,b,4,NULL,0);\n\t\t}\n\t}\n\treturn ret;\n}\n\nenum {\n\tANCHOR_NEBULA_DIGITV,\n};\n\nstatic struct usb_device_id digitv_table[] = {\n\tDVB_USB_DEV(ANCHOR, ANCHOR_NEBULA_DIGITV),\n\t{ }\n};\n\nMODULE_DEVICE_TABLE (usb, digitv_table);\n\nstatic struct dvb_usb_device_properties digitv_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl = CYPRESS_FX2,\n\t.firmware = \"dvb-usb-digitv-02.fw\",\n\n\t.size_of_priv = sizeof(struct digitv_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.frontend_attach  = digitv_frontend_attach,\n\t\t\t.tuner_attach     = digitv_tuner_attach,\n\n\t\t\t \n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 7,\n\t\t\t\t.endpoint = 0x02,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t}\n\t},\n\t.identify_state   = digitv_identify_state,\n\n\t.rc.legacy = {\n\t\t.rc_interval      = 1000,\n\t\t.rc_map_table     = rc_map_digitv_table,\n\t\t.rc_map_size      = ARRAY_SIZE(rc_map_digitv_table),\n\t\t.rc_query         = digitv_rc_query,\n\t},\n\n\t.i2c_algo         = &digitv_i2c_algo,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{   \"Nebula Electronics uDigiTV DVB-T USB2.0)\",\n\t\t\t{ &digitv_table[ANCHOR_NEBULA_DIGITV], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{ NULL },\n\t}\n};\n\nstatic struct usb_driver digitv_driver = {\n\t.name\t\t= \"dvb_usb_digitv\",\n\t.probe\t\t= digitv_probe,\n\t.disconnect = dvb_usb_device_exit,\n\t.id_table\t= digitv_table,\n};\n\nmodule_usb_driver(digitv_driver);\n\nMODULE_AUTHOR(\"Patrick Boettcher <patrick.boettcher@posteo.de>\");\nMODULE_DESCRIPTION(\"Driver for Nebula Electronics uDigiTV DVB-T USB2.0\");\nMODULE_VERSION(\"1.0-alpha\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}