{
  "module_name": "em28xx-core.c",
  "hash_id": "a7e8548b3c9e9bafa6163e4812c8ec9e180d7f688947b43461a0da3758988f14",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/em28xx/em28xx-core.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include \"em28xx.h\"\n\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/vmalloc.h>\n#include <sound/ac97_codec.h>\n#include <media/v4l2-common.h>\n\n#define DRIVER_AUTHOR \"Ludovico Cavedon <cavedon@sssup.it>, \" \\\n\t\t      \"Markus Rechberger <mrechberger@gmail.com>, \" \\\n\t\t      \"Mauro Carvalho Chehab <mchehab@kernel.org>, \" \\\n\t\t      \"Sascha Sommer <saschasommer@freenet.de>\"\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(EM28XX_VERSION);\n\n \n\nstatic unsigned int core_debug;\nmodule_param(core_debug, int, 0644);\nMODULE_PARM_DESC(core_debug, \"enable debug messages [core and isoc]\");\n\n#define em28xx_coredbg(fmt, arg...) do {\t\t\t\t\\\n\tif (core_debug)\t\t\t\t\t\t\t\\\n\t\tdev_printk(KERN_DEBUG, &dev->intf->dev,\t\t\t\\\n\t\t\t   \"core: %s: \" fmt, __func__, ## arg);\t\t\\\n} while (0)\n\nstatic unsigned int reg_debug;\nmodule_param(reg_debug, int, 0644);\nMODULE_PARM_DESC(reg_debug, \"enable debug messages [URB reg]\");\n\n#define em28xx_regdbg(fmt, arg...) do {\t\t\t\t\\\n\tif (reg_debug)\t\t\t\t\t\t\t\\\n\t\tdev_printk(KERN_DEBUG, &dev->intf->dev,\t\t\t\\\n\t\t\t   \"reg: %s: \" fmt, __func__, ## arg);\t\t\\\n} while (0)\n\n \n#define em28xx_isocdbg(fmt, arg...) do {\t\t\t\t\\\n\tif (core_debug)\t\t\t\t\t\t\t\\\n\t\tdev_printk(KERN_DEBUG, &dev->intf->dev,\t\t\t\\\n\t\t\t   \"core: %s: \" fmt, __func__, ## arg);\t\t\\\n} while (0)\n\n \nint em28xx_read_reg_req_len(struct em28xx *dev, u8 req, u16 reg,\n\t\t\t    char *buf, int len)\n{\n\tint ret;\n\tstruct usb_device *udev = interface_to_usbdev(dev->intf);\n\tint pipe = usb_rcvctrlpipe(udev, 0);\n\n\tif (dev->disconnected)\n\t\treturn -ENODEV;\n\n\tif (len > URB_MAX_CTRL_SIZE)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->ctrl_urb_lock);\n\tret = usb_control_msg(udev, pipe, req,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      0x0000, reg, dev->urb_buf, len, 1000);\n\tif (ret < 0) {\n\t\tem28xx_regdbg(\"(pipe 0x%08x): IN:  %02x %02x %02x %02x %02x %02x %02x %02x  failed with error %i\\n\",\n\t\t\t      pipe,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      req, 0, 0,\n\t\t\t      reg & 0xff, reg >> 8,\n\t\t\t      len & 0xff, len >> 8, ret);\n\t\tmutex_unlock(&dev->ctrl_urb_lock);\n\t\treturn usb_translate_errors(ret);\n\t}\n\n\tif (len)\n\t\tmemcpy(buf, dev->urb_buf, len);\n\n\tmutex_unlock(&dev->ctrl_urb_lock);\n\n\tem28xx_regdbg(\"(pipe 0x%08x): IN:  %02x %02x %02x %02x %02x %02x %02x %02x <<< %*ph\\n\",\n\t\t      pipe, USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t      req, 0, 0,\n\t\t      reg & 0xff, reg >> 8,\n\t\t      len & 0xff, len >> 8, len, buf);\n\n\treturn ret;\n}\n\n \nint em28xx_read_reg_req(struct em28xx *dev, u8 req, u16 reg)\n{\n\tint ret;\n\tu8 val;\n\n\tret = em28xx_read_reg_req_len(dev, req, reg, &val, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn val;\n}\n\nint em28xx_read_reg(struct em28xx *dev, u16 reg)\n{\n\treturn em28xx_read_reg_req(dev, USB_REQ_GET_STATUS, reg);\n}\nEXPORT_SYMBOL_GPL(em28xx_read_reg);\n\n \nint em28xx_write_regs_req(struct em28xx *dev, u8 req, u16 reg, char *buf,\n\t\t\t  int len)\n{\n\tint ret;\n\tstruct usb_device *udev = interface_to_usbdev(dev->intf);\n\tint pipe = usb_sndctrlpipe(udev, 0);\n\n\tif (dev->disconnected)\n\t\treturn -ENODEV;\n\n\tif (len < 1 || len > URB_MAX_CTRL_SIZE)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->ctrl_urb_lock);\n\tmemcpy(dev->urb_buf, buf, len);\n\tret = usb_control_msg(udev, pipe, req,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      0x0000, reg, dev->urb_buf, len, 1000);\n\tmutex_unlock(&dev->ctrl_urb_lock);\n\n\tif (ret < 0) {\n\t\tem28xx_regdbg(\"(pipe 0x%08x): OUT:  %02x %02x %02x %02x %02x %02x %02x %02x >>> %*ph  failed with error %i\\n\",\n\t\t\t      pipe,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      req, 0, 0,\n\t\t\t      reg & 0xff, reg >> 8,\n\t\t\t      len & 0xff, len >> 8, len, buf, ret);\n\t\treturn usb_translate_errors(ret);\n\t}\n\n\tem28xx_regdbg(\"(pipe 0x%08x): OUT:  %02x %02x %02x %02x %02x %02x %02x %02x >>> %*ph\\n\",\n\t\t      pipe,\n\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t      req, 0, 0,\n\t\t      reg & 0xff, reg >> 8,\n\t\t      len & 0xff, len >> 8, len, buf);\n\n\tif (dev->wait_after_write)\n\t\tmsleep(dev->wait_after_write);\n\n\treturn ret;\n}\n\nint em28xx_write_regs(struct em28xx *dev, u16 reg, char *buf, int len)\n{\n\treturn em28xx_write_regs_req(dev, USB_REQ_GET_STATUS, reg, buf, len);\n}\nEXPORT_SYMBOL_GPL(em28xx_write_regs);\n\n \nint em28xx_write_reg(struct em28xx *dev, u16 reg, u8 val)\n{\n\treturn em28xx_write_regs(dev, reg, &val, 1);\n}\nEXPORT_SYMBOL_GPL(em28xx_write_reg);\n\n \nint em28xx_write_reg_bits(struct em28xx *dev, u16 reg, u8 val,\n\t\t\t  u8 bitmask)\n{\n\tint oldval;\n\tu8 newval;\n\n\toldval = em28xx_read_reg(dev, reg);\n\tif (oldval < 0)\n\t\treturn oldval;\n\n\tnewval = (((u8)oldval) & ~bitmask) | (val & bitmask);\n\n\treturn em28xx_write_regs(dev, reg, &newval, 1);\n}\nEXPORT_SYMBOL_GPL(em28xx_write_reg_bits);\n\n \nint em28xx_toggle_reg_bits(struct em28xx *dev, u16 reg, u8 bitmask)\n{\n\tint oldval;\n\tu8 newval;\n\n\toldval = em28xx_read_reg(dev, reg);\n\tif (oldval < 0)\n\t\treturn oldval;\n\n\tnewval = (~oldval & bitmask) | (oldval & ~bitmask);\n\n\treturn em28xx_write_reg(dev, reg, newval);\n}\nEXPORT_SYMBOL_GPL(em28xx_toggle_reg_bits);\n\n \nstatic int em28xx_is_ac97_ready(struct em28xx *dev)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(EM28XX_AC97_XFER_TIMEOUT);\n\tint ret;\n\n\t \n\twhile (time_is_after_jiffies(timeout)) {\n\t\tret = em28xx_read_reg(dev, EM28XX_R43_AC97BUSY);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!(ret & 0x01))\n\t\t\treturn 0;\n\t\tmsleep(5);\n\t}\n\n\tdev_warn(&dev->intf->dev,\n\t\t \"AC97 command still being executed: not handled properly!\\n\");\n\treturn -EBUSY;\n}\n\n \nint em28xx_read_ac97(struct em28xx *dev, u8 reg)\n{\n\tint ret;\n\tu8 addr = (reg & 0x7f) | 0x80;\n\t__le16 val;\n\n\tret = em28xx_is_ac97_ready(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = em28xx_write_regs(dev, EM28XX_R42_AC97ADDR, &addr, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = dev->em28xx_read_reg_req_len(dev, 0, EM28XX_R40_AC97LSB,\n\t\t\t\t\t   (u8 *)&val, sizeof(val));\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn le16_to_cpu(val);\n}\nEXPORT_SYMBOL_GPL(em28xx_read_ac97);\n\n \nint em28xx_write_ac97(struct em28xx *dev, u8 reg, u16 val)\n{\n\tint ret;\n\tu8 addr = reg & 0x7f;\n\t__le16 value;\n\n\tvalue = cpu_to_le16(val);\n\n\tret = em28xx_is_ac97_ready(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = em28xx_write_regs(dev, EM28XX_R40_AC97LSB, (u8 *)&value, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = em28xx_write_regs(dev, EM28XX_R42_AC97ADDR, &addr, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(em28xx_write_ac97);\n\nstruct em28xx_vol_itable {\n\tenum em28xx_amux mux;\n\tu8\t\t reg;\n};\n\nstatic struct em28xx_vol_itable inputs[] = {\n\t{ EM28XX_AMUX_VIDEO,\tAC97_VIDEO\t},\n\t{ EM28XX_AMUX_LINE_IN,\tAC97_LINE\t},\n\t{ EM28XX_AMUX_PHONE,\tAC97_PHONE\t},\n\t{ EM28XX_AMUX_MIC,\tAC97_MIC\t},\n\t{ EM28XX_AMUX_CD,\tAC97_CD\t\t},\n\t{ EM28XX_AMUX_AUX,\tAC97_AUX\t},\n\t{ EM28XX_AMUX_PCM_OUT,\tAC97_PCM\t},\n};\n\nstatic int set_ac97_input(struct em28xx *dev)\n{\n\tint ret, i;\n\tenum em28xx_amux amux = dev->ctl_ainput;\n\n\t \n\tif (amux == EM28XX_AMUX_VIDEO2)\n\t\tamux = EM28XX_AMUX_VIDEO;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(inputs); i++) {\n\t\tif (amux == inputs[i].mux)\n\t\t\tret = em28xx_write_ac97(dev, inputs[i].reg, 0x0808);\n\t\telse\n\t\t\tret = em28xx_write_ac97(dev, inputs[i].reg, 0x8000);\n\n\t\tif (ret < 0)\n\t\t\tdev_warn(&dev->intf->dev,\n\t\t\t\t \"couldn't setup AC97 register %d\\n\",\n\t\t\t\t inputs[i].reg);\n\t}\n\treturn 0;\n}\n\nstatic int em28xx_set_audio_source(struct em28xx *dev)\n{\n\tint ret;\n\tu8 input;\n\n\tif (dev->board.is_em2800) {\n\t\tif (dev->ctl_ainput == EM28XX_AMUX_VIDEO)\n\t\t\tinput = EM2800_AUDIO_SRC_TUNER;\n\t\telse\n\t\t\tinput = EM2800_AUDIO_SRC_LINE;\n\n\t\tret = em28xx_write_regs(dev, EM2800_R08_AUDIOSRC, &input, 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (dev->has_msp34xx) {\n\t\tinput = EM28XX_AUDIO_SRC_TUNER;\n\t} else {\n\t\tswitch (dev->ctl_ainput) {\n\t\tcase EM28XX_AMUX_VIDEO:\n\t\t\tinput = EM28XX_AUDIO_SRC_TUNER;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinput = EM28XX_AUDIO_SRC_LINE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (dev->board.mute_gpio && dev->mute)\n\t\tem28xx_gpio_set(dev, dev->board.mute_gpio);\n\telse\n\t\tem28xx_gpio_set(dev, INPUT(dev->ctl_input)->gpio);\n\n\tret = em28xx_write_reg_bits(dev, EM28XX_R0E_AUDIOSRC, input, 0xc0);\n\tif (ret < 0)\n\t\treturn ret;\n\tusleep_range(10000, 11000);\n\n\tswitch (dev->audio_mode.ac97) {\n\tcase EM28XX_NO_AC97:\n\t\tbreak;\n\tdefault:\n\t\tret = set_ac97_input(dev);\n\t}\n\n\treturn ret;\n}\n\nstruct em28xx_vol_otable {\n\tenum em28xx_aout mux;\n\tu8\t\t reg;\n};\n\nstatic const struct em28xx_vol_otable outputs[] = {\n\t{ EM28XX_AOUT_MASTER, AC97_MASTER\t\t},\n\t{ EM28XX_AOUT_LINE,   AC97_HEADPHONE\t\t},\n\t{ EM28XX_AOUT_MONO,   AC97_MASTER_MONO\t\t},\n\t{ EM28XX_AOUT_LFE,    AC97_CENTER_LFE_MASTER\t},\n\t{ EM28XX_AOUT_SURR,   AC97_SURROUND_MASTER\t},\n};\n\nint em28xx_audio_analog_set(struct em28xx *dev)\n{\n\tint ret, i;\n\tu8 xclk;\n\n\tif (dev->int_audio_type == EM28XX_INT_AUDIO_NONE)\n\t\treturn 0;\n\n\t \n\tif (dev->audio_mode.ac97 != EM28XX_NO_AC97) {\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(outputs); i++) {\n\t\t\tret = em28xx_write_ac97(dev, outputs[i].reg, 0x8000);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_warn(&dev->intf->dev,\n\t\t\t\t\t \"couldn't setup AC97 register %d\\n\",\n\t\t\t\t\t outputs[i].reg);\n\t\t}\n\t}\n\n\txclk = dev->board.xclk & 0x7f;\n\tif (!dev->mute)\n\t\txclk |= EM28XX_XCLK_AUDIO_UNMUTE;\n\n\tret = em28xx_write_reg(dev, EM28XX_R0F_XCLK, xclk);\n\tif (ret < 0)\n\t\treturn ret;\n\tusleep_range(10000, 11000);\n\n\t \n\tret = em28xx_set_audio_source(dev);\n\n\t \n\tif (dev->audio_mode.ac97 != EM28XX_NO_AC97) {\n\t\tint vol;\n\n\t\tem28xx_write_ac97(dev, AC97_POWERDOWN, 0x4200);\n\t\tem28xx_write_ac97(dev, AC97_EXTENDED_STATUS, 0x0031);\n\t\tem28xx_write_ac97(dev, AC97_PCM_LR_ADC_RATE, 0xbb80);\n\n\t\t \n\t\tvol = (0x1f - dev->volume) | ((0x1f - dev->volume) << 8);\n\n\t\t \n\t\tif (dev->mute)\n\t\t\tvol |= 0x8000;\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(outputs); i++) {\n\t\t\tif (dev->ctl_aoutput & outputs[i].mux)\n\t\t\t\tret = em28xx_write_ac97(dev, outputs[i].reg,\n\t\t\t\t\t\t\tvol);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_warn(&dev->intf->dev,\n\t\t\t\t\t \"couldn't setup AC97 register %d\\n\",\n\t\t\t\t\t outputs[i].reg);\n\t\t}\n\n\t\tif (dev->ctl_aoutput & EM28XX_AOUT_PCM_IN) {\n\t\t\tint sel = ac97_return_record_select(dev->ctl_aoutput);\n\n\t\t\t \n\t\t\tsel |= (sel << 8);\n\n\t\t\tem28xx_write_ac97(dev, AC97_REC_SEL, sel);\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(em28xx_audio_analog_set);\n\nint em28xx_audio_setup(struct em28xx *dev)\n{\n\tint vid1, vid2, feat, cfg;\n\tu32 vid = 0;\n\tu8 i2s_samplerates;\n\n\tif (dev->chip_id == CHIP_ID_EM2870 ||\n\t    dev->chip_id == CHIP_ID_EM2874 ||\n\t    dev->chip_id == CHIP_ID_EM28174 ||\n\t    dev->chip_id == CHIP_ID_EM28178) {\n\t\t \n\t\tdev->int_audio_type = EM28XX_INT_AUDIO_NONE;\n\t\tdev->usb_audio_type = EM28XX_USB_AUDIO_NONE;\n\t\treturn 0;\n\t}\n\n\t \n\tcfg = em28xx_read_reg(dev, EM28XX_R00_CHIPCFG);\n\tdev_info(&dev->intf->dev, \"Config register raw data: 0x%02x\\n\", cfg);\n\tif (cfg < 0) {  \n\t\t \n\t\tdev->int_audio_type = EM28XX_INT_AUDIO_AC97;\n\t} else if ((cfg & EM28XX_CHIPCFG_AUDIOMASK) == 0x00) {\n\t\t \n\t\tdev->int_audio_type = EM28XX_INT_AUDIO_NONE;\n\t\tdev->usb_audio_type = EM28XX_USB_AUDIO_NONE;\n\t\treturn 0;\n\t} else if ((cfg & EM28XX_CHIPCFG_AUDIOMASK) != EM28XX_CHIPCFG_AC97) {\n\t\tdev->int_audio_type = EM28XX_INT_AUDIO_I2S;\n\t\tif (dev->chip_id < CHIP_ID_EM2860 &&\n\t\t    (cfg & EM28XX_CHIPCFG_AUDIOMASK) ==\n\t\t    EM2820_CHIPCFG_I2S_1_SAMPRATE)\n\t\t\ti2s_samplerates = 1;\n\t\telse if (dev->chip_id >= CHIP_ID_EM2860 &&\n\t\t\t (cfg & EM28XX_CHIPCFG_AUDIOMASK) ==\n\t\t\t EM2860_CHIPCFG_I2S_5_SAMPRATES)\n\t\t\ti2s_samplerates = 5;\n\t\telse\n\t\t\ti2s_samplerates = 3;\n\t\tdev_info(&dev->intf->dev, \"I2S Audio (%d sample rate(s))\\n\",\n\t\t\t i2s_samplerates);\n\t\t \n\t\tdev->audio_mode.ac97 = EM28XX_NO_AC97;\n\t\tgoto init_audio;\n\t} else {\n\t\tdev->int_audio_type = EM28XX_INT_AUDIO_AC97;\n\t}\n\n\tdev->audio_mode.ac97 = EM28XX_AC97_OTHER;\n\n\tvid1 = em28xx_read_ac97(dev, AC97_VENDOR_ID1);\n\tif (vid1 < 0) {\n\t\t \n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"AC97 chip type couldn't be determined\\n\");\n\t\tdev->audio_mode.ac97 = EM28XX_NO_AC97;\n\t\tif (dev->usb_audio_type == EM28XX_USB_AUDIO_VENDOR)\n\t\t\tdev->usb_audio_type = EM28XX_USB_AUDIO_NONE;\n\t\tdev->int_audio_type = EM28XX_INT_AUDIO_NONE;\n\t\tgoto init_audio;\n\t}\n\n\tvid2 = em28xx_read_ac97(dev, AC97_VENDOR_ID2);\n\tif (vid2 < 0)\n\t\tgoto init_audio;\n\n\tvid = vid1 << 16 | vid2;\n\tdev_warn(&dev->intf->dev, \"AC97 vendor ID = 0x%08x\\n\", vid);\n\n\tfeat = em28xx_read_ac97(dev, AC97_RESET);\n\tif (feat < 0)\n\t\tgoto init_audio;\n\n\tdev_warn(&dev->intf->dev, \"AC97 features = 0x%04x\\n\", feat);\n\n\t \n\tif ((vid == 0xffffffff || vid == 0x83847650) && feat == 0x6a90)\n\t\tdev->audio_mode.ac97 = EM28XX_AC97_EM202;\n\telse if ((vid >> 8) == 0x838476)\n\t\tdev->audio_mode.ac97 = EM28XX_AC97_SIGMATEL;\n\ninit_audio:\n\t \n\tswitch (dev->audio_mode.ac97) {\n\tcase EM28XX_NO_AC97:\n\t\tdev_info(&dev->intf->dev, \"No AC97 audio processor\\n\");\n\t\tbreak;\n\tcase EM28XX_AC97_EM202:\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"Empia 202 AC97 audio processor detected\\n\");\n\t\tbreak;\n\tcase EM28XX_AC97_SIGMATEL:\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"Sigmatel audio processor detected (stac 97%02x)\\n\",\n\t\t\t vid & 0xff);\n\t\tbreak;\n\tcase EM28XX_AC97_OTHER:\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"Unknown AC97 audio processor detected!\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn em28xx_audio_analog_set(dev);\n}\nEXPORT_SYMBOL_GPL(em28xx_audio_setup);\n\nconst struct em28xx_led *em28xx_find_led(struct em28xx *dev,\n\t\t\t\t\t enum em28xx_led_role role)\n{\n\tif (dev->board.leds) {\n\t\tu8 k = 0;\n\n\t\twhile (dev->board.leds[k].role >= 0 &&\n\t\t       dev->board.leds[k].role < EM28XX_NUM_LED_ROLES) {\n\t\t\tif (dev->board.leds[k].role == role)\n\t\t\t\treturn &dev->board.leds[k];\n\t\t\tk++;\n\t\t}\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(em28xx_find_led);\n\nint em28xx_capture_start(struct em28xx *dev, int start)\n{\n\tint rc;\n\tconst struct em28xx_led *led = NULL;\n\n\tif (dev->chip_id == CHIP_ID_EM2874 ||\n\t    dev->chip_id == CHIP_ID_EM2884 ||\n\t    dev->chip_id == CHIP_ID_EM28174 ||\n\t    dev->chip_id == CHIP_ID_EM28178) {\n\t\t \n\t\tif (dev->dvb_xfer_bulk) {\n\t\t\t \n\t\t\tem28xx_write_reg(dev, (dev->ts == PRIMARY_TS) ?\n\t\t\t\t\t EM2874_R5D_TS1_PKT_SIZE :\n\t\t\t\t\t EM2874_R5E_TS2_PKT_SIZE,\n\t\t\t\t\t 0xff);\n\t\t} else {\n\t\t\t \n\t\t\tem28xx_write_reg(dev, (dev->ts == PRIMARY_TS) ?\n\t\t\t\t\t EM2874_R5D_TS1_PKT_SIZE :\n\t\t\t\t\t EM2874_R5E_TS2_PKT_SIZE,\n\t\t\t\t\t dev->dvb_max_pkt_size_isoc / 188);\n\t\t}\n\t\tif (dev->ts == PRIMARY_TS)\n\t\t\trc = em28xx_write_reg_bits(dev,\n\t\t\t\t\t\t   EM2874_R5F_TS_ENABLE,\n\t\t\t\t\t\t   start ? EM2874_TS1_CAPTURE_ENABLE : 0x00,\n\t\t\t\t\t\t   EM2874_TS1_CAPTURE_ENABLE | EM2874_TS1_FILTER_ENABLE | EM2874_TS1_NULL_DISCARD);\n\t\telse\n\t\t\trc = em28xx_write_reg_bits(dev,\n\t\t\t\t\t\t   EM2874_R5F_TS_ENABLE,\n\t\t\t\t\t\t   start ? EM2874_TS2_CAPTURE_ENABLE : 0x00,\n\t\t\t\t\t\t   EM2874_TS2_CAPTURE_ENABLE | EM2874_TS2_FILTER_ENABLE | EM2874_TS2_NULL_DISCARD);\n\t} else {\n\t\t \n\t\t \n\t\trc = em28xx_write_reg_bits(dev, EM28XX_R0C_USBSUSP,\n\t\t\t\t\t   start ? 0x10 : 0x00, 0x10);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif (start) {\n\t\t\tif (dev->is_webcam)\n\t\t\t\trc = em28xx_write_reg(dev, 0x13, 0x0c);\n\n\t\t\t \n\t\t\trc = em28xx_write_reg(dev, 0x48, 0x00);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\tif (dev->mode == EM28XX_ANALOG_MODE)\n\t\t\t\trc = em28xx_write_reg(dev,\n\t\t\t\t\t\t      EM28XX_R12_VINENABLE,\n\t\t\t\t\t\t      0x67);\n\t\t\telse\n\t\t\t\trc = em28xx_write_reg(dev,\n\t\t\t\t\t\t      EM28XX_R12_VINENABLE,\n\t\t\t\t\t\t      0x37);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\tusleep_range(10000, 11000);\n\t\t} else {\n\t\t\t \n\t\t\trc = em28xx_write_reg(dev, EM28XX_R12_VINENABLE, 0x27);\n\t\t}\n\t}\n\n\tif (dev->mode == EM28XX_ANALOG_MODE)\n\t\tled = em28xx_find_led(dev, EM28XX_LED_ANALOG_CAPTURING);\n\telse if (dev->ts == PRIMARY_TS)\n\t\tled = em28xx_find_led(dev, EM28XX_LED_DIGITAL_CAPTURING);\n\telse\n\t\tled = em28xx_find_led(dev, EM28XX_LED_DIGITAL_CAPTURING_TS2);\n\n\tif (led)\n\t\tem28xx_write_reg_bits(dev, led->gpio_reg,\n\t\t\t\t      (!start ^ led->inverted) ?\n\t\t\t\t      ~led->gpio_mask : led->gpio_mask,\n\t\t\t\t      led->gpio_mask);\n\n\treturn rc;\n}\n\nint em28xx_gpio_set(struct em28xx *dev, const struct em28xx_reg_seq *gpio)\n{\n\tint rc = 0;\n\n\tif (!gpio)\n\t\treturn rc;\n\n\tif (dev->mode != EM28XX_SUSPEND) {\n\t\tem28xx_write_reg(dev, 0x48, 0x00);\n\t\tif (dev->mode == EM28XX_ANALOG_MODE)\n\t\t\tem28xx_write_reg(dev, EM28XX_R12_VINENABLE, 0x67);\n\t\telse\n\t\t\tem28xx_write_reg(dev, EM28XX_R12_VINENABLE, 0x37);\n\t\tusleep_range(10000, 11000);\n\t}\n\n\t \n\twhile (gpio->sleep >= 0) {\n\t\tif (gpio->reg >= 0) {\n\t\t\trc = em28xx_write_reg_bits(dev,\n\t\t\t\t\t\t   gpio->reg,\n\t\t\t\t\t\t   gpio->val,\n\t\t\t\t\t\t   gpio->mask);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t}\n\t\tif (gpio->sleep > 0)\n\t\t\tmsleep(gpio->sleep);\n\n\t\tgpio++;\n\t}\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(em28xx_gpio_set);\n\nint em28xx_set_mode(struct em28xx *dev, enum em28xx_mode set_mode)\n{\n\tif (dev->mode == set_mode)\n\t\treturn 0;\n\n\tif (set_mode == EM28XX_SUSPEND) {\n\t\tdev->mode = set_mode;\n\n\t\t \n\n\t\treturn em28xx_gpio_set(dev, dev->board.suspend_gpio);\n\t}\n\n\tdev->mode = set_mode;\n\n\tif (dev->mode == EM28XX_DIGITAL_MODE)\n\t\treturn em28xx_gpio_set(dev, dev->board.dvb_gpio);\n\telse\n\t\treturn em28xx_gpio_set(dev, INPUT(dev->ctl_input)->gpio);\n}\nEXPORT_SYMBOL_GPL(em28xx_set_mode);\n\n \n\n \nstatic void em28xx_irq_callback(struct urb *urb)\n{\n\tstruct em28xx *dev = urb->context;\n\tunsigned long flags;\n\tint i;\n\n\tswitch (urb->status) {\n\tcase 0:              \n\tcase -ETIMEDOUT:     \n\t\tbreak;\n\tcase -ECONNRESET:    \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:             \n\t\tem28xx_isocdbg(\"urb completion error %d.\\n\", urb->status);\n\t\tbreak;\n\t}\n\n\t \n\tspin_lock_irqsave(&dev->slock, flags);\n\tdev->usb_ctl.urb_data_copy(dev, urb);\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\n\t \n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\t \n\t\turb->iso_frame_desc[i].status = 0;\n\t\turb->iso_frame_desc[i].actual_length = 0;\n\t}\n\turb->status = 0;\n\n\turb->status = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (urb->status) {\n\t\tem28xx_isocdbg(\"urb resubmit failed (error=%i)\\n\",\n\t\t\t       urb->status);\n\t}\n}\n\n \nvoid em28xx_uninit_usb_xfer(struct em28xx *dev, enum em28xx_mode mode)\n{\n\tstruct urb *urb;\n\tstruct em28xx_usb_bufs *usb_bufs;\n\tint i;\n\n\tem28xx_isocdbg(\"called %s in mode %d\\n\", __func__, mode);\n\n\tif (mode == EM28XX_DIGITAL_MODE)\n\t\tusb_bufs = &dev->usb_ctl.digital_bufs;\n\telse\n\t\tusb_bufs = &dev->usb_ctl.analog_bufs;\n\n\tfor (i = 0; i < usb_bufs->num_bufs; i++) {\n\t\turb = usb_bufs->urb[i];\n\t\tif (urb) {\n\t\t\tif (!irqs_disabled())\n\t\t\t\tusb_kill_urb(urb);\n\t\t\telse\n\t\t\t\tusb_unlink_urb(urb);\n\n\t\t\tusb_free_urb(urb);\n\t\t\tusb_bufs->urb[i] = NULL;\n\t\t}\n\t}\n\n\tkfree(usb_bufs->urb);\n\tkfree(usb_bufs->buf);\n\n\tusb_bufs->urb = NULL;\n\tusb_bufs->buf = NULL;\n\tusb_bufs->num_bufs = 0;\n\n\tem28xx_capture_start(dev, 0);\n}\nEXPORT_SYMBOL_GPL(em28xx_uninit_usb_xfer);\n\n \nvoid em28xx_stop_urbs(struct em28xx *dev)\n{\n\tint i;\n\tstruct urb *urb;\n\tstruct em28xx_usb_bufs *isoc_bufs = &dev->usb_ctl.digital_bufs;\n\n\tem28xx_isocdbg(\"called %s\\n\", __func__);\n\n\tfor (i = 0; i < isoc_bufs->num_bufs; i++) {\n\t\turb = isoc_bufs->urb[i];\n\t\tif (urb) {\n\t\t\tif (!irqs_disabled())\n\t\t\t\tusb_kill_urb(urb);\n\t\t\telse\n\t\t\t\tusb_unlink_urb(urb);\n\t\t}\n\t}\n\n\tem28xx_capture_start(dev, 0);\n}\nEXPORT_SYMBOL_GPL(em28xx_stop_urbs);\n\n \nint em28xx_alloc_urbs(struct em28xx *dev, enum em28xx_mode mode, int xfer_bulk,\n\t\t      int num_bufs, int max_pkt_size, int packet_multiplier)\n{\n\tstruct em28xx_usb_bufs *usb_bufs;\n\tstruct urb *urb;\n\tstruct usb_device *udev = interface_to_usbdev(dev->intf);\n\tint i;\n\tint sb_size, pipe;\n\tint j, k;\n\n\tem28xx_isocdbg(\"em28xx: called %s in mode %d\\n\", __func__, mode);\n\n\t \n\tif (mode == EM28XX_DIGITAL_MODE) {\n\t\tif ((xfer_bulk && !dev->dvb_ep_bulk) ||\n\t\t    (!xfer_bulk && !dev->dvb_ep_isoc)) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"no endpoint for DVB mode and transfer type %d\\n\",\n\t\t\t\txfer_bulk > 0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tusb_bufs = &dev->usb_ctl.digital_bufs;\n\t} else if (mode == EM28XX_ANALOG_MODE) {\n\t\tif ((xfer_bulk && !dev->analog_ep_bulk) ||\n\t\t    (!xfer_bulk && !dev->analog_ep_isoc)) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"no endpoint for analog mode and transfer type %d\\n\",\n\t\t\t\txfer_bulk > 0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tusb_bufs = &dev->usb_ctl.analog_bufs;\n\t} else {\n\t\tdev_err(&dev->intf->dev, \"invalid mode selected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tem28xx_uninit_usb_xfer(dev, mode);\n\n\tusb_bufs->num_bufs = num_bufs;\n\n\tusb_bufs->urb = kcalloc(num_bufs, sizeof(void *), GFP_KERNEL);\n\tif (!usb_bufs->urb)\n\t\treturn -ENOMEM;\n\n\tusb_bufs->buf = kcalloc(num_bufs, sizeof(void *), GFP_KERNEL);\n\tif (!usb_bufs->buf) {\n\t\tkfree(usb_bufs->urb);\n\t\treturn -ENOMEM;\n\t}\n\n\tusb_bufs->max_pkt_size = max_pkt_size;\n\tif (xfer_bulk)\n\t\tusb_bufs->num_packets = 0;\n\telse\n\t\tusb_bufs->num_packets = packet_multiplier;\n\tdev->usb_ctl.vid_buf = NULL;\n\tdev->usb_ctl.vbi_buf = NULL;\n\n\tsb_size = packet_multiplier * usb_bufs->max_pkt_size;\n\n\t \n\tfor (i = 0; i < usb_bufs->num_bufs; i++) {\n\t\turb = usb_alloc_urb(usb_bufs->num_packets, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\tem28xx_uninit_usb_xfer(dev, mode);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tusb_bufs->urb[i] = urb;\n\n\t\tusb_bufs->buf[i] = kzalloc(sb_size, GFP_KERNEL);\n\t\tif (!usb_bufs->buf[i]) {\n\t\t\tfor (i--; i >= 0; i--)\n\t\t\t\tkfree(usb_bufs->buf[i]);\n\n\t\t\tem28xx_uninit_usb_xfer(dev, mode);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\turb->transfer_flags = URB_FREE_BUFFER;\n\n\t\tif (xfer_bulk) {  \n\t\t\tpipe = usb_rcvbulkpipe(udev,\n\t\t\t\t\t       mode == EM28XX_ANALOG_MODE ?\n\t\t\t\t\t       dev->analog_ep_bulk :\n\t\t\t\t\t       dev->dvb_ep_bulk);\n\t\t\tusb_fill_bulk_urb(urb, udev, pipe, usb_bufs->buf[i],\n\t\t\t\t\t  sb_size, em28xx_irq_callback, dev);\n\t\t} else {  \n\t\t\tpipe = usb_rcvisocpipe(udev,\n\t\t\t\t\t       mode == EM28XX_ANALOG_MODE ?\n\t\t\t\t\t       dev->analog_ep_isoc :\n\t\t\t\t\t       dev->dvb_ep_isoc);\n\t\t\tusb_fill_int_urb(urb, udev, pipe, usb_bufs->buf[i],\n\t\t\t\t\t sb_size, em28xx_irq_callback, dev, 1);\n\t\t\turb->transfer_flags |= URB_ISO_ASAP;\n\t\t\tk = 0;\n\t\t\tfor (j = 0; j < usb_bufs->num_packets; j++) {\n\t\t\t\turb->iso_frame_desc[j].offset = k;\n\t\t\t\turb->iso_frame_desc[j].length =\n\t\t\t\t\t\t\tusb_bufs->max_pkt_size;\n\t\t\t\tk += usb_bufs->max_pkt_size;\n\t\t\t}\n\t\t}\n\n\t\turb->number_of_packets = usb_bufs->num_packets;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(em28xx_alloc_urbs);\n\n \nint em28xx_init_usb_xfer(struct em28xx *dev, enum em28xx_mode mode,\n\t\t\t int xfer_bulk, int num_bufs, int max_pkt_size,\n\t\t    int packet_multiplier,\n\t\t    int (*urb_data_copy)(struct em28xx *dev, struct urb *urb))\n{\n\tstruct em28xx_dmaqueue *dma_q = &dev->vidq;\n\tstruct em28xx_dmaqueue *vbi_dma_q = &dev->vbiq;\n\tstruct em28xx_usb_bufs *usb_bufs;\n\tstruct usb_device *udev = interface_to_usbdev(dev->intf);\n\tint i;\n\tint rc;\n\tint alloc;\n\n\tem28xx_isocdbg(\"em28xx: called %s in mode %d\\n\", __func__, mode);\n\n\tdev->usb_ctl.urb_data_copy = urb_data_copy;\n\n\tif (mode == EM28XX_DIGITAL_MODE) {\n\t\tusb_bufs = &dev->usb_ctl.digital_bufs;\n\t\t \n\t\talloc = 0;\n\t} else {\n\t\tusb_bufs = &dev->usb_ctl.analog_bufs;\n\t\talloc = 1;\n\t}\n\n\tif (alloc) {\n\t\trc = em28xx_alloc_urbs(dev, mode, xfer_bulk, num_bufs,\n\t\t\t\t       max_pkt_size, packet_multiplier);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (xfer_bulk) {\n\t\trc = usb_clear_halt(udev, usb_bufs->urb[0]->pipe);\n\t\tif (rc < 0) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"failed to clear USB bulk endpoint stall/halt condition (error=%i)\\n\",\n\t\t\t       rc);\n\t\t\tem28xx_uninit_usb_xfer(dev, mode);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tinit_waitqueue_head(&dma_q->wq);\n\tinit_waitqueue_head(&vbi_dma_q->wq);\n\n\tem28xx_capture_start(dev, 1);\n\n\t \n\tfor (i = 0; i < usb_bufs->num_bufs; i++) {\n\t\trc = usb_submit_urb(usb_bufs->urb[i], GFP_KERNEL);\n\t\tif (rc) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"submit of urb %i failed (error=%i)\\n\", i, rc);\n\t\t\tem28xx_uninit_usb_xfer(dev, mode);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(em28xx_init_usb_xfer);\n\n \n\nstatic LIST_HEAD(em28xx_devlist);\nstatic DEFINE_MUTEX(em28xx_devlist_mutex);\n\n \n\nstatic LIST_HEAD(em28xx_extension_devlist);\n\nint em28xx_register_extension(struct em28xx_ops *ops)\n{\n\tstruct em28xx *dev = NULL;\n\n\tmutex_lock(&em28xx_devlist_mutex);\n\tlist_add_tail(&ops->next, &em28xx_extension_devlist);\n\tlist_for_each_entry(dev, &em28xx_devlist, devlist) {\n\t\tif (ops->init) {\n\t\t\tops->init(dev);\n\t\t\tif (dev->dev_next)\n\t\t\t\tops->init(dev->dev_next);\n\t\t}\n\t}\n\tmutex_unlock(&em28xx_devlist_mutex);\n\tpr_info(\"em28xx: Registered (%s) extension\\n\", ops->name);\n\treturn 0;\n}\nEXPORT_SYMBOL(em28xx_register_extension);\n\nvoid em28xx_unregister_extension(struct em28xx_ops *ops)\n{\n\tstruct em28xx *dev = NULL;\n\n\tmutex_lock(&em28xx_devlist_mutex);\n\tlist_for_each_entry(dev, &em28xx_devlist, devlist) {\n\t\tif (ops->fini) {\n\t\t\tif (dev->dev_next)\n\t\t\t\tops->fini(dev->dev_next);\n\t\t\tops->fini(dev);\n\t\t}\n\t}\n\tlist_del(&ops->next);\n\tmutex_unlock(&em28xx_devlist_mutex);\n\tpr_info(\"em28xx: Removed (%s) extension\\n\", ops->name);\n}\nEXPORT_SYMBOL(em28xx_unregister_extension);\n\nvoid em28xx_init_extension(struct em28xx *dev)\n{\n\tconst struct em28xx_ops *ops = NULL;\n\n\tmutex_lock(&em28xx_devlist_mutex);\n\tlist_add_tail(&dev->devlist, &em28xx_devlist);\n\tlist_for_each_entry(ops, &em28xx_extension_devlist, next) {\n\t\tif (ops->init) {\n\t\t\tops->init(dev);\n\t\t\tif (dev->dev_next)\n\t\t\t\tops->init(dev->dev_next);\n\t\t}\n\t}\n\tmutex_unlock(&em28xx_devlist_mutex);\n}\n\nvoid em28xx_close_extension(struct em28xx *dev)\n{\n\tconst struct em28xx_ops *ops = NULL;\n\n\tmutex_lock(&em28xx_devlist_mutex);\n\tlist_for_each_entry(ops, &em28xx_extension_devlist, next) {\n\t\tif (ops->fini) {\n\t\t\tif (dev->dev_next)\n\t\t\t\tops->fini(dev->dev_next);\n\t\t\tops->fini(dev);\n\t\t}\n\t}\n\tlist_del(&dev->devlist);\n\tmutex_unlock(&em28xx_devlist_mutex);\n}\n\nint em28xx_suspend_extension(struct em28xx *dev)\n{\n\tconst struct em28xx_ops *ops = NULL;\n\n\tdev_info(&dev->intf->dev, \"Suspending extensions\\n\");\n\tmutex_lock(&em28xx_devlist_mutex);\n\tlist_for_each_entry(ops, &em28xx_extension_devlist, next) {\n\t\tif (!ops->suspend)\n\t\t\tcontinue;\n\t\tops->suspend(dev);\n\t\tif (dev->dev_next)\n\t\t\tops->suspend(dev->dev_next);\n\t}\n\tmutex_unlock(&em28xx_devlist_mutex);\n\treturn 0;\n}\n\nint em28xx_resume_extension(struct em28xx *dev)\n{\n\tconst struct em28xx_ops *ops = NULL;\n\n\tdev_info(&dev->intf->dev, \"Resuming extensions\\n\");\n\tmutex_lock(&em28xx_devlist_mutex);\n\tlist_for_each_entry(ops, &em28xx_extension_devlist, next) {\n\t\tif (!ops->resume)\n\t\t\tcontinue;\n\t\tops->resume(dev);\n\t\tif (dev->dev_next)\n\t\t\tops->resume(dev->dev_next);\n\t}\n\tmutex_unlock(&em28xx_devlist_mutex);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}