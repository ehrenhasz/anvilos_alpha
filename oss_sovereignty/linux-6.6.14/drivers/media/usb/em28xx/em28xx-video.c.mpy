{
  "module_name": "em28xx-video.c",
  "hash_id": "e5d423f33389bec98db63a20aa57de2759d46f0895dd8297aa8e49fab3971e6b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/em28xx/em28xx-video.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"em28xx.h\"\n\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/bitmap.h>\n#include <linux/usb.h>\n#include <linux/i2c.h>\n#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n\n#include \"em28xx-v4l.h\"\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include <media/drv-intf/msp3400.h>\n#include <media/tuner.h>\n\n#define DRIVER_AUTHOR \"Ludovico Cavedon <cavedon@sssup.it>, \" \\\n\t\t      \"Markus Rechberger <mrechberger@gmail.com>, \" \\\n\t\t      \"Mauro Carvalho Chehab <mchehab@kernel.org>, \" \\\n\t\t      \"Sascha Sommer <saschasommer@freenet.de>\"\n\nstatic unsigned int isoc_debug;\nmodule_param(isoc_debug, int, 0644);\nMODULE_PARM_DESC(isoc_debug, \"enable debug messages [isoc transfers]\");\n\nstatic unsigned int disable_vbi;\nmodule_param(disable_vbi, int, 0644);\nMODULE_PARM_DESC(disable_vbi, \"disable vbi support\");\n\nstatic int alt;\nmodule_param(alt, int, 0644);\nMODULE_PARM_DESC(alt, \"alternate setting to use for video endpoint\");\n\n#define em28xx_videodbg(fmt, arg...) do {\t\t\t\t\\\n\tif (video_debug)\t\t\t\t\t\t\\\n\t\tdev_printk(KERN_DEBUG, &dev->intf->dev,\t\t\t\\\n\t\t\t   \"video: %s: \" fmt, __func__, ## arg);\t\\\n} while (0)\n\n#define em28xx_isocdbg(fmt, arg...) do {\\\n\tif (isoc_debug) \\\n\t\tdev_printk(KERN_DEBUG, &dev->intf->dev,\t\t\t\\\n\t\t\t   \"isoc: %s: \" fmt, __func__, ## arg);\t\t\\\n} while (0)\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC \" - v4l2 interface\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(EM28XX_VERSION);\n\n#define EM25XX_FRMDATAHDR_BYTE1\t\t\t0x02\n#define EM25XX_FRMDATAHDR_BYTE2_STILL_IMAGE\t0x20\n#define EM25XX_FRMDATAHDR_BYTE2_FRAME_END\t0x02\n#define EM25XX_FRMDATAHDR_BYTE2_FRAME_ID\t0x01\n#define EM25XX_FRMDATAHDR_BYTE2_MASK\t(EM25XX_FRMDATAHDR_BYTE2_STILL_IMAGE | \\\n\t\t\t\t\t EM25XX_FRMDATAHDR_BYTE2_FRAME_END |   \\\n\t\t\t\t\t EM25XX_FRMDATAHDR_BYTE2_FRAME_ID)\n\nstatic unsigned int video_nr[] = {[0 ... (EM28XX_MAXBOARDS - 1)] = -1U };\nstatic unsigned int vbi_nr[]   = {[0 ... (EM28XX_MAXBOARDS - 1)] = -1U };\nstatic unsigned int radio_nr[] = {[0 ... (EM28XX_MAXBOARDS - 1)] = -1U };\n\nmodule_param_array(video_nr, int, NULL, 0444);\nmodule_param_array(vbi_nr, int, NULL, 0444);\nmodule_param_array(radio_nr, int, NULL, 0444);\nMODULE_PARM_DESC(video_nr, \"video device numbers\");\nMODULE_PARM_DESC(vbi_nr,   \"vbi device numbers\");\nMODULE_PARM_DESC(radio_nr, \"radio device numbers\");\n\nstatic unsigned int video_debug;\nmodule_param(video_debug, int, 0644);\nMODULE_PARM_DESC(video_debug, \"enable debug messages [video]\");\n\n \nstatic struct em28xx_fmt format[] = {\n\t{\n\t\t.fourcc   = V4L2_PIX_FMT_YUYV,\n\t\t.depth    = 16,\n\t\t.reg\t  = EM28XX_OUTFMT_YUV422_Y0UY1V,\n\t}, {\n\t\t.fourcc   = V4L2_PIX_FMT_RGB565,\n\t\t.depth    = 16,\n\t\t.reg      = EM28XX_OUTFMT_RGB_16_656,\n\t}, {\n\t\t.fourcc   = V4L2_PIX_FMT_SRGGB8,\n\t\t.depth    = 8,\n\t\t.reg      = EM28XX_OUTFMT_RGB_8_RGRG,\n\t}, {\n\t\t.fourcc   = V4L2_PIX_FMT_SBGGR8,\n\t\t.depth    = 8,\n\t\t.reg      = EM28XX_OUTFMT_RGB_8_BGBG,\n\t}, {\n\t\t.fourcc   = V4L2_PIX_FMT_SGRBG8,\n\t\t.depth    = 8,\n\t\t.reg      = EM28XX_OUTFMT_RGB_8_GRGR,\n\t}, {\n\t\t.fourcc   = V4L2_PIX_FMT_SGBRG8,\n\t\t.depth    = 8,\n\t\t.reg      = EM28XX_OUTFMT_RGB_8_GBGB,\n\t}, {\n\t\t.fourcc   = V4L2_PIX_FMT_YUV411P,\n\t\t.depth    = 12,\n\t\t.reg      = EM28XX_OUTFMT_YUV411,\n\t},\n};\n\n \nstatic inline unsigned int norm_maxw(struct em28xx *dev)\n{\n\tstruct em28xx_v4l2 *v4l2 = dev->v4l2;\n\n\tif (dev->is_webcam)\n\t\treturn v4l2->sensor_xres;\n\n\tif (dev->board.max_range_640_480)\n\t\treturn 640;\n\n\treturn 720;\n}\n\nstatic inline unsigned int norm_maxh(struct em28xx *dev)\n{\n\tstruct em28xx_v4l2 *v4l2 = dev->v4l2;\n\n\tif (dev->is_webcam)\n\t\treturn v4l2->sensor_yres;\n\n\tif (dev->board.max_range_640_480)\n\t\treturn 480;\n\n\treturn (v4l2->norm & V4L2_STD_625_50) ? 576 : 480;\n}\n\nstatic int em28xx_vbi_supported(struct em28xx *dev)\n{\n\t \n\tif (disable_vbi == 1)\n\t\treturn 0;\n\n\tif (dev->is_webcam)\n\t\treturn 0;\n\n\t \n\n\tif (dev->chip_id == CHIP_ID_EM2860 ||\n\t    dev->chip_id == CHIP_ID_EM2883)\n\t\treturn 1;\n\n\t \n\treturn 0;\n}\n\n \nstatic void em28xx_wake_i2c(struct em28xx *dev)\n{\n\tstruct v4l2_device *v4l2_dev = &dev->v4l2->v4l2_dev;\n\n\tv4l2_device_call_all(v4l2_dev, 0, core,  reset, 0);\n\tv4l2_device_call_all(v4l2_dev, 0, video, s_routing,\n\t\t\t     INPUT(dev->ctl_input)->vmux, 0, 0);\n}\n\nstatic int em28xx_colorlevels_set_default(struct em28xx *dev)\n{\n\tem28xx_write_reg(dev, EM28XX_R20_YGAIN, CONTRAST_DEFAULT);\n\tem28xx_write_reg(dev, EM28XX_R21_YOFFSET, BRIGHTNESS_DEFAULT);\n\tem28xx_write_reg(dev, EM28XX_R22_UVGAIN, SATURATION_DEFAULT);\n\tem28xx_write_reg(dev, EM28XX_R23_UOFFSET, BLUE_BALANCE_DEFAULT);\n\tem28xx_write_reg(dev, EM28XX_R24_VOFFSET, RED_BALANCE_DEFAULT);\n\tem28xx_write_reg(dev, EM28XX_R25_SHARPNESS, SHARPNESS_DEFAULT);\n\n\tem28xx_write_reg(dev, EM28XX_R14_GAMMA, 0x20);\n\tem28xx_write_reg(dev, EM28XX_R15_RGAIN, 0x20);\n\tem28xx_write_reg(dev, EM28XX_R16_GGAIN, 0x20);\n\tem28xx_write_reg(dev, EM28XX_R17_BGAIN, 0x20);\n\tem28xx_write_reg(dev, EM28XX_R18_ROFFSET, 0x00);\n\tem28xx_write_reg(dev, EM28XX_R19_GOFFSET, 0x00);\n\treturn em28xx_write_reg(dev, EM28XX_R1A_BOFFSET, 0x00);\n}\n\nstatic int em28xx_set_outfmt(struct em28xx *dev)\n{\n\tint ret;\n\tu8 fmt, vinctrl;\n\tstruct em28xx_v4l2 *v4l2 = dev->v4l2;\n\n\tfmt = v4l2->format->reg;\n\tif (!dev->is_em25xx)\n\t\tfmt |= 0x20;\n\t \n\tret = em28xx_write_reg(dev, EM28XX_R27_OUTFMT, fmt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = em28xx_write_reg(dev, EM28XX_R10_VINMODE, v4l2->vinmode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvinctrl = v4l2->vinctl;\n\tif (em28xx_vbi_supported(dev) == 1) {\n\t\tvinctrl |= EM28XX_VINCTRL_VBI_RAW;\n\t\tem28xx_write_reg(dev, EM28XX_R34_VBI_START_H, 0x00);\n\t\tem28xx_write_reg(dev, EM28XX_R36_VBI_WIDTH,\n\t\t\t\t v4l2->vbi_width / 4);\n\t\tem28xx_write_reg(dev, EM28XX_R37_VBI_HEIGHT, v4l2->vbi_height);\n\t\tif (v4l2->norm & V4L2_STD_525_60) {\n\t\t\t \n\t\t\tem28xx_write_reg(dev, EM28XX_R35_VBI_START_V, 0x09);\n\t\t} else if (v4l2->norm & V4L2_STD_625_50) {\n\t\t\t \n\t\t\tem28xx_write_reg(dev, EM28XX_R35_VBI_START_V, 0x07);\n\t\t}\n\t}\n\n\treturn em28xx_write_reg(dev, EM28XX_R11_VINCTRL, vinctrl);\n}\n\nstatic int em28xx_accumulator_set(struct em28xx *dev, u8 xmin, u8 xmax,\n\t\t\t\t  u8 ymin, u8 ymax)\n{\n\tem28xx_videodbg(\"em28xx Scale: (%d,%d)-(%d,%d)\\n\",\n\t\t\txmin, ymin, xmax, ymax);\n\n\tem28xx_write_regs(dev, EM28XX_R28_XMIN, &xmin, 1);\n\tem28xx_write_regs(dev, EM28XX_R29_XMAX, &xmax, 1);\n\tem28xx_write_regs(dev, EM28XX_R2A_YMIN, &ymin, 1);\n\treturn em28xx_write_regs(dev, EM28XX_R2B_YMAX, &ymax, 1);\n}\n\nstatic void em28xx_capture_area_set(struct em28xx *dev, u8 hstart, u8 vstart,\n\t\t\t\t    u16 width, u16 height)\n{\n\tu8 cwidth = width >> 2;\n\tu8 cheight = height >> 2;\n\tu8 overflow = (height >> 9 & 0x02) | (width >> 10 & 0x01);\n\t \n\n\tem28xx_videodbg(\"capture area set to (%d,%d): %dx%d\\n\",\n\t\t\thstart, vstart,\n\t\t       ((overflow & 2) << 9 | cwidth << 2),\n\t\t       ((overflow & 1) << 10 | cheight << 2));\n\n\tem28xx_write_regs(dev, EM28XX_R1C_HSTART, &hstart, 1);\n\tem28xx_write_regs(dev, EM28XX_R1D_VSTART, &vstart, 1);\n\tem28xx_write_regs(dev, EM28XX_R1E_CWIDTH, &cwidth, 1);\n\tem28xx_write_regs(dev, EM28XX_R1F_CHEIGHT, &cheight, 1);\n\tem28xx_write_regs(dev, EM28XX_R1B_OFLOW, &overflow, 1);\n\n\t \n\t \n\tif (dev->is_em25xx) {\n\t\tem28xx_write_reg(dev, 0x34, width >> 4);\n\t\tem28xx_write_reg(dev, 0x35, height >> 4);\n\t}\n}\n\nstatic int em28xx_scaler_set(struct em28xx *dev, u16 h, u16 v)\n{\n\tu8 mode = 0x00;\n\t \n\n\tif (dev->board.is_em2800) {\n\t\tmode = (v ? 0x20 : 0x00) | (h ? 0x10 : 0x00);\n\t} else {\n\t\tu8 buf[2];\n\n\t\tbuf[0] = h;\n\t\tbuf[1] = h >> 8;\n\t\tem28xx_write_regs(dev, EM28XX_R30_HSCALELOW, (char *)buf, 2);\n\n\t\tbuf[0] = v;\n\t\tbuf[1] = v >> 8;\n\t\tem28xx_write_regs(dev, EM28XX_R32_VSCALELOW, (char *)buf, 2);\n\t\t \n\t\tmode = (h || v) ? 0x30 : 0x00;\n\t}\n\treturn em28xx_write_reg(dev, EM28XX_R26_COMPR, mode);\n}\n\n \nstatic int em28xx_resolution_set(struct em28xx *dev)\n{\n\tstruct em28xx_v4l2 *v4l2 = dev->v4l2;\n\tint width = norm_maxw(dev);\n\tint height = norm_maxh(dev);\n\n\t \n\tv4l2->vbi_width = 720;\n\tif (v4l2->norm & V4L2_STD_525_60)\n\t\tv4l2->vbi_height = 12;\n\telse\n\t\tv4l2->vbi_height = 18;\n\n\tem28xx_set_outfmt(dev);\n\n\tem28xx_accumulator_set(dev, 1, (width - 4) >> 2, 1, (height - 4) >> 2);\n\n\t \n\tif (em28xx_vbi_supported(dev) == 1)\n\t\tem28xx_capture_area_set(dev, 0, 2, width, height);\n\telse\n\t\tem28xx_capture_area_set(dev, 0, 0, width, height);\n\n\treturn em28xx_scaler_set(dev, v4l2->hscale, v4l2->vscale);\n}\n\n \nstatic int em28xx_set_alternate(struct em28xx *dev)\n{\n\tstruct em28xx_v4l2 *v4l2 = dev->v4l2;\n\tstruct usb_device *udev = interface_to_usbdev(dev->intf);\n\tint err;\n\tint i;\n\tunsigned int min_pkt_size = v4l2->width * 2 + 4;\n\n\t \n\tdev->alt = 0;\n\tif (alt > 0 && alt < dev->num_alt) {\n\t\tem28xx_videodbg(\"alternate forced to %d\\n\", dev->alt);\n\t\tdev->alt = alt;\n\t\tgoto set_alt;\n\t}\n\tif (dev->analog_xfer_bulk)\n\t\tgoto set_alt;\n\n\t \n\tif (v4l2->width * 2 * v4l2->height > 720 * 240 * 2)\n\t\tmin_pkt_size *= 2;\n\n\tfor (i = 0; i < dev->num_alt; i++) {\n\t\t \n\t\tif (dev->alt_max_pkt_size_isoc[i] >= min_pkt_size) {\n\t\t\tdev->alt = i;\n\t\t\tbreak;\n\t\t \n\t\t} else if (dev->alt_max_pkt_size_isoc[i] >\n\t\t\t   dev->alt_max_pkt_size_isoc[dev->alt])\n\t\t\tdev->alt = i;\n\t}\n\nset_alt:\n\t \n\tif (dev->analog_xfer_bulk) {\n\t\tdev->max_pkt_size = 512;  \n\t\tdev->packet_multiplier = EM28XX_BULK_PACKET_MULTIPLIER;\n\t} else {  \n\t\tem28xx_videodbg(\"minimum isoc packet size: %u (alt=%d)\\n\",\n\t\t\t\tmin_pkt_size, dev->alt);\n\t\tdev->max_pkt_size =\n\t\t\t\t  dev->alt_max_pkt_size_isoc[dev->alt];\n\t\tdev->packet_multiplier = EM28XX_NUM_ISOC_PACKETS;\n\t}\n\tem28xx_videodbg(\"setting alternate %d with wMaxPacketSize=%u\\n\",\n\t\t\tdev->alt, dev->max_pkt_size);\n\terr = usb_set_interface(udev, dev->ifnum, dev->alt);\n\tif (err < 0) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"cannot change alternate number to %d (error=%i)\\n\",\n\t\t\tdev->alt, err);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \n\n \nstatic inline void finish_buffer(struct em28xx *dev,\n\t\t\t\t struct em28xx_buffer *buf)\n{\n\tem28xx_isocdbg(\"[%p/%d] wakeup\\n\", buf, buf->top_field);\n\n\tbuf->vb.sequence = dev->v4l2->field_count++;\n\tif (dev->v4l2->progressive)\n\t\tbuf->vb.field = V4L2_FIELD_NONE;\n\telse\n\t\tbuf->vb.field = V4L2_FIELD_INTERLACED;\n\tbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\n\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n}\n\n \nstatic void em28xx_copy_video(struct em28xx *dev,\n\t\t\t      struct em28xx_buffer *buf,\n\t\t\t      unsigned char *usb_buf,\n\t\t\t      unsigned long len)\n{\n\tstruct em28xx_v4l2 *v4l2 = dev->v4l2;\n\tvoid *fieldstart, *startwrite, *startread;\n\tint  linesdone, currlinedone, offset, lencopy, remain;\n\tint bytesperline = v4l2->width << 1;\n\n\tif (buf->pos + len > buf->length)\n\t\tlen = buf->length - buf->pos;\n\n\tstartread = usb_buf;\n\tremain = len;\n\n\tif (v4l2->progressive || buf->top_field)\n\t\tfieldstart = buf->vb_buf;\n\telse  \n\t\tfieldstart = buf->vb_buf + bytesperline;\n\n\tlinesdone = buf->pos / bytesperline;\n\tcurrlinedone = buf->pos % bytesperline;\n\n\tif (v4l2->progressive)\n\t\toffset = linesdone * bytesperline + currlinedone;\n\telse\n\t\toffset = linesdone * bytesperline * 2 + currlinedone;\n\n\tstartwrite = fieldstart + offset;\n\tlencopy = bytesperline - currlinedone;\n\tlencopy = lencopy > remain ? remain : lencopy;\n\n\tif ((char *)startwrite + lencopy > (char *)buf->vb_buf + buf->length) {\n\t\tem28xx_isocdbg(\"Overflow of %zu bytes past buffer end (1)\\n\",\n\t\t\t       ((char *)startwrite + lencopy) -\n\t\t\t      ((char *)buf->vb_buf + buf->length));\n\t\tremain = (char *)buf->vb_buf + buf->length -\n\t\t\t (char *)startwrite;\n\t\tlencopy = remain;\n\t}\n\tif (lencopy <= 0)\n\t\treturn;\n\tmemcpy(startwrite, startread, lencopy);\n\n\tremain -= lencopy;\n\n\twhile (remain > 0) {\n\t\tif (v4l2->progressive)\n\t\t\tstartwrite += lencopy;\n\t\telse\n\t\t\tstartwrite += lencopy + bytesperline;\n\t\tstartread += lencopy;\n\t\tif (bytesperline > remain)\n\t\t\tlencopy = remain;\n\t\telse\n\t\t\tlencopy = bytesperline;\n\n\t\tif ((char *)startwrite + lencopy > (char *)buf->vb_buf +\n\t\t    buf->length) {\n\t\t\tem28xx_isocdbg(\"Overflow of %zu bytes past buffer end(2)\\n\",\n\t\t\t\t       ((char *)startwrite + lencopy) -\n\t\t\t\t       ((char *)buf->vb_buf + buf->length));\n\t\t\tremain = (char *)buf->vb_buf + buf->length -\n\t\t\t\t (char *)startwrite;\n\t\t\tlencopy = remain;\n\t\t}\n\t\tif (lencopy <= 0)\n\t\t\tbreak;\n\n\t\tmemcpy(startwrite, startread, lencopy);\n\n\t\tremain -= lencopy;\n\t}\n\n\tbuf->pos += len;\n}\n\n \nstatic void em28xx_copy_vbi(struct em28xx *dev,\n\t\t\t    struct em28xx_buffer *buf,\n\t\t\t    unsigned char *usb_buf,\n\t\t\t    unsigned long len)\n{\n\tunsigned int offset;\n\n\tif (buf->pos + len > buf->length)\n\t\tlen = buf->length - buf->pos;\n\n\toffset = buf->pos;\n\t \n\tif (buf->top_field == 0)\n\t\toffset += dev->v4l2->vbi_width * dev->v4l2->vbi_height;\n\n\tmemcpy(buf->vb_buf + offset, usb_buf, len);\n\tbuf->pos += len;\n}\n\nstatic inline void print_err_status(struct em28xx *dev,\n\t\t\t\t    int packet, int status)\n{\n\tchar *errmsg = \"Unknown\";\n\n\tswitch (status) {\n\tcase -ENOENT:\n\t\terrmsg = \"unlinked synchronously\";\n\t\tbreak;\n\tcase -ECONNRESET:\n\t\terrmsg = \"unlinked asynchronously\";\n\t\tbreak;\n\tcase -ENOSR:\n\t\terrmsg = \"Buffer error (overrun)\";\n\t\tbreak;\n\tcase -EPIPE:\n\t\terrmsg = \"Stalled (device not responding)\";\n\t\tbreak;\n\tcase -EOVERFLOW:\n\t\terrmsg = \"Babble (bad cable?)\";\n\t\tbreak;\n\tcase -EPROTO:\n\t\terrmsg = \"Bit-stuff error (bad cable?)\";\n\t\tbreak;\n\tcase -EILSEQ:\n\t\terrmsg = \"CRC/Timeout (could be anything)\";\n\t\tbreak;\n\tcase -ETIME:\n\t\terrmsg = \"Device does not respond\";\n\t\tbreak;\n\t}\n\tif (packet < 0) {\n\t\tem28xx_isocdbg(\"URB status %d [%s].\\n\",\tstatus, errmsg);\n\t} else {\n\t\tem28xx_isocdbg(\"URB packet %d, status %d [%s].\\n\",\n\t\t\t       packet, status, errmsg);\n\t}\n}\n\n \nstatic inline struct em28xx_buffer *get_next_buf(struct em28xx *dev,\n\t\t\t\t\t\t struct em28xx_dmaqueue *dma_q)\n{\n\tstruct em28xx_buffer *buf;\n\n\tif (list_empty(&dma_q->active)) {\n\t\tem28xx_isocdbg(\"No active queue to serve\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tbuf = list_entry(dma_q->active.next, struct em28xx_buffer, list);\n\t \n\tlist_del(&buf->list);\n\tbuf->pos = 0;\n\tbuf->vb_buf = buf->mem;\n\n\treturn buf;\n}\n\n \nstatic struct em28xx_buffer *\nfinish_field_prepare_next(struct em28xx *dev,\n\t\t\t  struct em28xx_buffer *buf,\n\t\t\t  struct em28xx_dmaqueue *dma_q)\n{\n\tstruct em28xx_v4l2 *v4l2 = dev->v4l2;\n\n\tif (v4l2->progressive || v4l2->top_field) {  \n\t\tif (buf)\n\t\t\tfinish_buffer(dev, buf);\n\t\tbuf = get_next_buf(dev, dma_q);\n\t}\n\tif (buf) {\n\t\tbuf->top_field = v4l2->top_field;\n\t\tbuf->pos = 0;\n\t}\n\n\treturn buf;\n}\n\n \nstatic inline void process_frame_data_em28xx(struct em28xx *dev,\n\t\t\t\t\t     unsigned char *data_pkt,\n\t\t\t\t\t     unsigned int  data_len)\n{\n\tstruct em28xx_v4l2      *v4l2 = dev->v4l2;\n\tstruct em28xx_buffer    *buf = dev->usb_ctl.vid_buf;\n\tstruct em28xx_buffer    *vbi_buf = dev->usb_ctl.vbi_buf;\n\tstruct em28xx_dmaqueue  *dma_q = &dev->vidq;\n\tstruct em28xx_dmaqueue  *vbi_dma_q = &dev->vbiq;\n\n\t \n\tif (data_len >= 4) {\n\t\t \n\t\tif (data_pkt[0] == 0x88 && data_pkt[1] == 0x88 &&\n\t\t    data_pkt[2] == 0x88 && data_pkt[3] == 0x88) {\n\t\t\t \n\t\t\tdata_pkt += 4;\n\t\t\tdata_len -= 4;\n\t\t} else if (data_pkt[0] == 0x33 && data_pkt[1] == 0x95) {\n\t\t\t \n\t\t\tv4l2->capture_type = 0;\n\t\t\tv4l2->vbi_read = 0;\n\t\t\tem28xx_isocdbg(\"VBI START HEADER !!!\\n\");\n\t\t\tv4l2->top_field = !(data_pkt[2] & 1);\n\t\t\tdata_pkt += 4;\n\t\t\tdata_len -= 4;\n\t\t} else if (data_pkt[0] == 0x22 && data_pkt[1] == 0x5a) {\n\t\t\t \n\t\t\tv4l2->capture_type = 2;\n\t\t\tem28xx_isocdbg(\"VIDEO START HEADER !!!\\n\");\n\t\t\tv4l2->top_field = !(data_pkt[2] & 1);\n\t\t\tdata_pkt += 4;\n\t\t\tdata_len -= 4;\n\t\t}\n\t}\n\t \n\n\tif (v4l2->capture_type == 0) {\n\t\tvbi_buf = finish_field_prepare_next(dev, vbi_buf, vbi_dma_q);\n\t\tdev->usb_ctl.vbi_buf = vbi_buf;\n\t\tv4l2->capture_type = 1;\n\t}\n\n\tif (v4l2->capture_type == 1) {\n\t\tint vbi_size = v4l2->vbi_width * v4l2->vbi_height;\n\t\tint vbi_data_len = ((v4l2->vbi_read + data_len) > vbi_size) ?\n\t\t\t\t   (vbi_size - v4l2->vbi_read) : data_len;\n\n\t\t \n\t\tif (vbi_buf)\n\t\t\tem28xx_copy_vbi(dev, vbi_buf, data_pkt, vbi_data_len);\n\t\tv4l2->vbi_read += vbi_data_len;\n\n\t\tif (vbi_data_len < data_len) {\n\t\t\t \n\t\t\tv4l2->capture_type = 2;\n\t\t\tdata_pkt += vbi_data_len;\n\t\t\tdata_len -= vbi_data_len;\n\t\t}\n\t}\n\n\tif (v4l2->capture_type == 2) {\n\t\tbuf = finish_field_prepare_next(dev, buf, dma_q);\n\t\tdev->usb_ctl.vid_buf = buf;\n\t\tv4l2->capture_type = 3;\n\t}\n\n\tif (v4l2->capture_type == 3 && buf && data_len > 0)\n\t\tem28xx_copy_video(dev, buf, data_pkt, data_len);\n}\n\n \nstatic inline void process_frame_data_em25xx(struct em28xx *dev,\n\t\t\t\t\t     unsigned char *data_pkt,\n\t\t\t\t\t     unsigned int  data_len)\n{\n\tstruct em28xx_buffer    *buf = dev->usb_ctl.vid_buf;\n\tstruct em28xx_dmaqueue  *dmaq = &dev->vidq;\n\tstruct em28xx_v4l2      *v4l2 = dev->v4l2;\n\tbool frame_end = false;\n\n\t \n\t \n\tif (data_len >= 2) {\t \n\t\tif ((data_pkt[0] == EM25XX_FRMDATAHDR_BYTE1) &&\n\t\t    ((data_pkt[1] & ~EM25XX_FRMDATAHDR_BYTE2_MASK) == 0x00)) {\n\t\t\tv4l2->top_field = !(data_pkt[1] &\n\t\t\t\t\t   EM25XX_FRMDATAHDR_BYTE2_FRAME_ID);\n\t\t\tframe_end = data_pkt[1] &\n\t\t\t\t    EM25XX_FRMDATAHDR_BYTE2_FRAME_END;\n\t\t\tdata_pkt += 2;\n\t\t\tdata_len -= 2;\n\t\t}\n\n\t\t \n\t\tif (dev->analog_xfer_bulk && frame_end) {\n\t\t\tbuf = finish_field_prepare_next(dev, buf, dmaq);\n\t\t\tdev->usb_ctl.vid_buf = buf;\n\t\t}\n\t\t \n\t}\n\n\t \n\tif (buf && data_len > 0)\n\t\tem28xx_copy_video(dev, buf, data_pkt, data_len);\n\n\t \n\tif (!dev->analog_xfer_bulk && frame_end) {\n\t\tbuf = finish_field_prepare_next(dev, buf, dmaq);\n\t\tdev->usb_ctl.vid_buf = buf;\n\t}\n\n\t \n}\n\n \nstatic inline int em28xx_urb_data_copy(struct em28xx *dev, struct urb *urb)\n{\n\tint xfer_bulk, num_packets, i;\n\tunsigned char *usb_data_pkt;\n\tunsigned int usb_data_len;\n\n\tif (!dev)\n\t\treturn 0;\n\n\tif (dev->disconnected)\n\t\treturn 0;\n\n\tif (urb->status < 0)\n\t\tprint_err_status(dev, -1, urb->status);\n\n\txfer_bulk = usb_pipebulk(urb->pipe);\n\n\tif (xfer_bulk)  \n\t\tnum_packets = 1;\n\telse  \n\t\tnum_packets = urb->number_of_packets;\n\n\tfor (i = 0; i < num_packets; i++) {\n\t\tif (xfer_bulk) {  \n\t\t\tusb_data_len = urb->actual_length;\n\n\t\t\tusb_data_pkt = urb->transfer_buffer;\n\t\t} else {  \n\t\t\tif (urb->iso_frame_desc[i].status < 0) {\n\t\t\t\tprint_err_status(dev, i,\n\t\t\t\t\t\t urb->iso_frame_desc[i].status);\n\t\t\t\tif (urb->iso_frame_desc[i].status != -EPROTO)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tusb_data_len = urb->iso_frame_desc[i].actual_length;\n\t\t\tif (usb_data_len > dev->max_pkt_size) {\n\t\t\t\tem28xx_isocdbg(\"packet bigger than packet size\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tusb_data_pkt = urb->transfer_buffer +\n\t\t\t\t       urb->iso_frame_desc[i].offset;\n\t\t}\n\n\t\tif (usb_data_len == 0) {\n\t\t\t \n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev->is_em25xx)\n\t\t\tprocess_frame_data_em25xx(dev,\n\t\t\t\t\t\t  usb_data_pkt, usb_data_len);\n\t\telse\n\t\t\tprocess_frame_data_em28xx(dev,\n\t\t\t\t\t\t  usb_data_pkt, usb_data_len);\n\t}\n\treturn 1;\n}\n\nstatic int get_resource(enum v4l2_buf_type f_type)\n{\n\tswitch (f_type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\treturn EM28XX_RESOURCE_VIDEO;\n\tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n\t\treturn EM28XX_RESOURCE_VBI;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -1;  \n\t}\n}\n\n \nstatic int res_get(struct em28xx *dev, enum v4l2_buf_type f_type)\n{\n\tint res_type = get_resource(f_type);\n\n\t \n\tif (dev->resources & res_type) {\n\t\t \n\t\treturn -EBUSY;\n\t}\n\n\t \n\tdev->resources |= res_type;\n\tem28xx_videodbg(\"res: get %d\\n\", res_type);\n\treturn 0;\n}\n\nstatic void res_free(struct em28xx *dev, enum v4l2_buf_type f_type)\n{\n\tint res_type = get_resource(f_type);\n\n\tdev->resources &= ~res_type;\n\tem28xx_videodbg(\"res: put %d\\n\", res_type);\n}\n\nstatic void em28xx_v4l2_media_release(struct em28xx *dev)\n{\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tint i;\n\n\tfor (i = 0; i < MAX_EM28XX_INPUT; i++) {\n\t\tif (!INPUT(i)->type)\n\t\t\treturn;\n\t\tmedia_device_unregister_entity(&dev->input_ent[i]);\n\t}\n#endif\n}\n\n \n\nstatic int em28xx_enable_analog_tuner(struct em28xx *dev)\n{\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tstruct media_device *mdev = dev->media_dev;\n\tstruct em28xx_v4l2 *v4l2 = dev->v4l2;\n\tstruct media_entity *source;\n\tstruct media_link *link, *found_link = NULL;\n\tint ret, active_links = 0;\n\n\tif (!mdev || !v4l2->decoder)\n\t\treturn 0;\n\n\t \n\tlist_for_each_entry(link, &v4l2->decoder->links, list) {\n\t\tif (link->sink->entity == v4l2->decoder) {\n\t\t\tfound_link = link;\n\t\t\tif (link->flags & MEDIA_LNK_FL_ENABLED)\n\t\t\t\tactive_links++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (active_links == 1 || !found_link)\n\t\treturn 0;\n\n\tsource = found_link->source->entity;\n\tlist_for_each_entry(link, &source->links, list) {\n\t\tstruct media_entity *sink;\n\t\tint flags = 0;\n\n\t\tsink = link->sink->entity;\n\n\t\tif (sink == v4l2->decoder)\n\t\t\tflags = MEDIA_LNK_FL_ENABLED;\n\n\t\tret = media_entity_setup_link(link, flags);\n\t\tif (ret) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"Couldn't change link %s->%s to %s. Error %d\\n\",\n\t\t\t\tsource->name, sink->name,\n\t\t\t\tflags ? \"enabled\" : \"disabled\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tem28xx_videodbg(\"link %s->%s was %s\\n\",\n\t\t\t\tsource->name, sink->name,\n\t\t\t\tflags ? \"ENABLED\" : \"disabled\");\n\t}\n#endif\n\treturn 0;\n}\n\nstatic const char * const iname[] = {\n\t[EM28XX_VMUX_COMPOSITE]  = \"Composite\",\n\t[EM28XX_VMUX_SVIDEO]     = \"S-Video\",\n\t[EM28XX_VMUX_TELEVISION] = \"Television\",\n\t[EM28XX_RADIO]           = \"Radio\",\n};\n\nstatic void em28xx_v4l2_create_entities(struct em28xx *dev)\n{\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tstruct em28xx_v4l2 *v4l2 = dev->v4l2;\n\tint ret, i;\n\n\t \n\tv4l2->video_pad.flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&v4l2->vdev.entity, 1, &v4l2->video_pad);\n\tif (ret < 0)\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"failed to initialize video media entity!\\n\");\n\n\tif (em28xx_vbi_supported(dev)) {\n\t\tv4l2->vbi_pad.flags = MEDIA_PAD_FL_SINK;\n\t\tret = media_entity_pads_init(&v4l2->vbi_dev.entity, 1,\n\t\t\t\t\t     &v4l2->vbi_pad);\n\t\tif (ret < 0)\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"failed to initialize vbi media entity!\\n\");\n\t}\n\n\t \n\tif (dev->is_webcam)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < MAX_EM28XX_INPUT; i++) {\n\t\tstruct media_entity *ent = &dev->input_ent[i];\n\n\t\tif (!INPUT(i)->type)\n\t\t\tbreak;\n\n\t\tent->name = iname[INPUT(i)->type];\n\t\tent->flags = MEDIA_ENT_FL_CONNECTOR;\n\t\tdev->input_pad[i].flags = MEDIA_PAD_FL_SOURCE;\n\n\t\tswitch (INPUT(i)->type) {\n\t\tcase EM28XX_VMUX_COMPOSITE:\n\t\t\tent->function = MEDIA_ENT_F_CONN_COMPOSITE;\n\t\t\tbreak;\n\t\tcase EM28XX_VMUX_SVIDEO:\n\t\t\tent->function = MEDIA_ENT_F_CONN_SVIDEO;\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tif (dev->tuner_type != TUNER_ABSENT)\n\t\t\t\tent->function = MEDIA_ENT_F_CONN_RF;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = media_entity_pads_init(ent, 1, &dev->input_pad[i]);\n\t\tif (ret < 0)\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"failed to initialize input pad[%d]!\\n\", i);\n\n\t\tret = media_device_register_entity(dev->media_dev, ent);\n\t\tif (ret < 0)\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"failed to register input entity %d!\\n\", i);\n\t}\n#endif\n}\n\n \n\nstatic int queue_setup(struct vb2_queue *vq,\n\t\t       unsigned int *nbuffers, unsigned int *nplanes,\n\t\t       unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct em28xx *dev = vb2_get_drv_priv(vq);\n\tstruct em28xx_v4l2 *v4l2 = dev->v4l2;\n\tunsigned long size =\n\t\t    (v4l2->width * v4l2->height * v4l2->format->depth + 7) >> 3;\n\n\tif (*nplanes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\t*nplanes = 1;\n\tsizes[0] = size;\n\n\tem28xx_enable_analog_tuner(dev);\n\n\treturn 0;\n}\n\nstatic int\nbuffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct em28xx        *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct em28xx_v4l2   *v4l2 = dev->v4l2;\n\tunsigned long size;\n\n\tem28xx_videodbg(\"%s, field=%d\\n\", __func__, vbuf->field);\n\n\tsize = (v4l2->width * v4l2->height * v4l2->format->depth + 7) >> 3;\n\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tem28xx_videodbg(\"%s data will not fit into plane (%lu < %lu)\\n\",\n\t\t\t\t__func__, vb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\tvb2_set_plane_payload(vb, 0, size);\n\n\treturn 0;\n}\n\nint em28xx_start_analog_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct em28xx *dev = vb2_get_drv_priv(vq);\n\tstruct em28xx_v4l2 *v4l2 = dev->v4l2;\n\tstruct v4l2_frequency f;\n\tstruct v4l2_fh *owner;\n\tint rc = 0;\n\n\tem28xx_videodbg(\"%s\\n\", __func__);\n\n\tdev->v4l2->field_count = 0;\n\n\t \n\trc = res_get(dev, vq->type);\n\tif (rc)\n\t\treturn rc;\n\n\tif (v4l2->streaming_users == 0) {\n\t\t \n\n\t\t \n\t\tem28xx_set_alternate(dev);\n\n\t\t \n\t\tem28xx_wake_i2c(dev);\n\n\t\tv4l2->capture_type = -1;\n\t\trc = em28xx_init_usb_xfer(dev, EM28XX_ANALOG_MODE,\n\t\t\t\t\t  dev->analog_xfer_bulk,\n\t\t\t\t\t  EM28XX_NUM_BUFS,\n\t\t\t\t\t  dev->max_pkt_size,\n\t\t\t\t\t  dev->packet_multiplier,\n\t\t\t\t\t  em28xx_urb_data_copy);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\n\t\t \n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frequency = v4l2->frequency;\n\t\towner = (struct v4l2_fh *)vq->owner;\n\t\tif (owner && owner->vdev->vfl_type == VFL_TYPE_RADIO)\n\t\t\tf.type = V4L2_TUNER_RADIO;\n\t\telse\n\t\t\tf.type = V4L2_TUNER_ANALOG_TV;\n\t\tv4l2_device_call_all(&v4l2->v4l2_dev,\n\t\t\t\t     0, tuner, s_frequency, &f);\n\n\t\t \n\t\tv4l2_device_call_all(&v4l2->v4l2_dev, 0, video, s_stream, 1);\n\t}\n\n\tv4l2->streaming_users++;\n\n\treturn rc;\n}\n\nstatic void em28xx_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct em28xx *dev = vb2_get_drv_priv(vq);\n\tstruct em28xx_v4l2 *v4l2 = dev->v4l2;\n\tstruct em28xx_dmaqueue *vidq = &dev->vidq;\n\tunsigned long flags = 0;\n\n\tem28xx_videodbg(\"%s\\n\", __func__);\n\n\tres_free(dev, vq->type);\n\n\tif (v4l2->streaming_users-- == 1) {\n\t\t \n\t\tv4l2_device_call_all(&v4l2->v4l2_dev, 0, video, s_stream, 0);\n\n\t\t \n\t\tem28xx_uninit_usb_xfer(dev, EM28XX_ANALOG_MODE);\n\t}\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\tif (dev->usb_ctl.vid_buf) {\n\t\tvb2_buffer_done(&dev->usb_ctl.vid_buf->vb.vb2_buf,\n\t\t\t\tVB2_BUF_STATE_ERROR);\n\t\tdev->usb_ctl.vid_buf = NULL;\n\t}\n\twhile (!list_empty(&vidq->active)) {\n\t\tstruct em28xx_buffer *buf;\n\n\t\tbuf = list_entry(vidq->active.next, struct em28xx_buffer, list);\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nvoid em28xx_stop_vbi_streaming(struct vb2_queue *vq)\n{\n\tstruct em28xx *dev = vb2_get_drv_priv(vq);\n\tstruct em28xx_v4l2 *v4l2 = dev->v4l2;\n\tstruct em28xx_dmaqueue *vbiq = &dev->vbiq;\n\tunsigned long flags = 0;\n\n\tem28xx_videodbg(\"%s\\n\", __func__);\n\n\tres_free(dev, vq->type);\n\n\tif (v4l2->streaming_users-- == 1) {\n\t\t \n\t\tv4l2_device_call_all(&v4l2->v4l2_dev, 0, video, s_stream, 0);\n\n\t\t \n\t\tem28xx_uninit_usb_xfer(dev, EM28XX_ANALOG_MODE);\n\t}\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\tif (dev->usb_ctl.vbi_buf) {\n\t\tvb2_buffer_done(&dev->usb_ctl.vbi_buf->vb.vb2_buf,\n\t\t\t\tVB2_BUF_STATE_ERROR);\n\t\tdev->usb_ctl.vbi_buf = NULL;\n\t}\n\twhile (!list_empty(&vbiq->active)) {\n\t\tstruct em28xx_buffer *buf;\n\n\t\tbuf = list_entry(vbiq->active.next, struct em28xx_buffer, list);\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nstatic void\nbuffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct em28xx *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct em28xx_buffer *buf =\n\t\tcontainer_of(vbuf, struct em28xx_buffer, vb);\n\tstruct em28xx_dmaqueue *vidq = &dev->vidq;\n\tunsigned long flags = 0;\n\n\tem28xx_videodbg(\"%s\\n\", __func__);\n\tbuf->mem = vb2_plane_vaddr(vb, 0);\n\tbuf->length = vb2_plane_size(vb, 0);\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\tlist_add_tail(&buf->list, &vidq->active);\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nstatic const struct vb2_ops em28xx_video_qops = {\n\t.queue_setup    = queue_setup,\n\t.buf_prepare    = buffer_prepare,\n\t.buf_queue      = buffer_queue,\n\t.start_streaming = em28xx_start_analog_streaming,\n\t.stop_streaming = em28xx_stop_streaming,\n\t.wait_prepare   = vb2_ops_wait_prepare,\n\t.wait_finish    = vb2_ops_wait_finish,\n};\n\nstatic int em28xx_vb2_setup(struct em28xx *dev)\n{\n\tint rc;\n\tstruct vb2_queue *q;\n\tstruct em28xx_v4l2 *v4l2 = dev->v4l2;\n\n\t \n\tq = &v4l2->vb_vidq;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_READ | VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->drv_priv = dev;\n\tq->buf_struct_size = sizeof(struct em28xx_buffer);\n\tq->ops = &em28xx_video_qops;\n\tq->mem_ops = &vb2_vmalloc_memops;\n\n\trc = vb2_queue_init(q);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tq = &v4l2->vb_vbiq;\n\tq->type = V4L2_BUF_TYPE_VBI_CAPTURE;\n\tq->io_modes = VB2_READ | VB2_MMAP | VB2_USERPTR;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->drv_priv = dev;\n\tq->buf_struct_size = sizeof(struct em28xx_buffer);\n\tq->ops = &em28xx_vbi_qops;\n\tq->mem_ops = &vb2_vmalloc_memops;\n\n\trc = vb2_queue_init(q);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\n \n\nstatic void video_mux(struct em28xx *dev, int index)\n{\n\tstruct v4l2_device *v4l2_dev = &dev->v4l2->v4l2_dev;\n\n\tdev->ctl_input = index;\n\tdev->ctl_ainput = INPUT(index)->amux;\n\tdev->ctl_aoutput = INPUT(index)->aout;\n\n\tif (!dev->ctl_aoutput)\n\t\tdev->ctl_aoutput = EM28XX_AOUT_MASTER;\n\n\tv4l2_device_call_all(v4l2_dev, 0, video, s_routing,\n\t\t\t     INPUT(index)->vmux, 0, 0);\n\n\tif (dev->has_msp34xx) {\n\t\tif (dev->i2s_speed) {\n\t\t\tv4l2_device_call_all(v4l2_dev, 0, audio,\n\t\t\t\t\t     s_i2s_clock_freq, dev->i2s_speed);\n\t\t}\n\t\t \n\t\tv4l2_device_call_all(v4l2_dev, 0, audio, s_routing,\n\t\t\t\t     dev->ctl_ainput,\n\t\t\t\t     MSP_OUTPUT(MSP_SC_IN_DSP_SCART1), 0);\n\t}\n\n\tif (dev->board.adecoder != EM28XX_NOADECODER) {\n\t\tv4l2_device_call_all(v4l2_dev, 0, audio, s_routing,\n\t\t\t\t     dev->ctl_ainput, dev->ctl_aoutput, 0);\n\t}\n\n\tem28xx_audio_analog_set(dev);\n}\n\nstatic void em28xx_ctrl_notify(struct v4l2_ctrl *ctrl, void *priv)\n{\n\tstruct em28xx *dev = priv;\n\n\t \n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\tdev->mute = ctrl->val;\n\t\tem28xx_audio_analog_set(dev);\n\t\tbreak;\n\tcase V4L2_CID_AUDIO_VOLUME:\n\t\tdev->volume = ctrl->val;\n\t\tem28xx_audio_analog_set(dev);\n\t\tbreak;\n\t}\n}\n\nstatic int em28xx_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct em28xx_v4l2 *v4l2 =\n\t\t  container_of(ctrl->handler, struct em28xx_v4l2, ctrl_handler);\n\tstruct em28xx *dev = v4l2->dev;\n\tint ret = -EINVAL;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\tdev->mute = ctrl->val;\n\t\tret = em28xx_audio_analog_set(dev);\n\t\tbreak;\n\tcase V4L2_CID_AUDIO_VOLUME:\n\t\tdev->volume = ctrl->val;\n\t\tret = em28xx_audio_analog_set(dev);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tret = em28xx_write_reg(dev, EM28XX_R20_YGAIN, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tret = em28xx_write_reg(dev, EM28XX_R21_YOFFSET, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tret = em28xx_write_reg(dev, EM28XX_R22_UVGAIN, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_BLUE_BALANCE:\n\t\tret = em28xx_write_reg(dev, EM28XX_R23_UOFFSET, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_RED_BALANCE:\n\t\tret = em28xx_write_reg(dev, EM28XX_R24_VOFFSET, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SHARPNESS:\n\t\tret = em28xx_write_reg(dev, EM28XX_R25_SHARPNESS, ctrl->val);\n\t\tbreak;\n\t}\n\n\treturn (ret < 0) ? ret : 0;\n}\n\nstatic const struct v4l2_ctrl_ops em28xx_ctrl_ops = {\n\t.s_ctrl = em28xx_s_ctrl,\n};\n\nstatic void size_to_scale(struct em28xx *dev,\n\t\t\t  unsigned int width, unsigned int height,\n\t\t\tunsigned int *hscale, unsigned int *vscale)\n{\n\tunsigned int          maxw = norm_maxw(dev);\n\tunsigned int          maxh = norm_maxh(dev);\n\n\t*hscale = (((unsigned long)maxw) << 12) / width - 4096L;\n\tif (*hscale > EM28XX_HVSCALE_MAX)\n\t\t*hscale = EM28XX_HVSCALE_MAX;\n\n\t*vscale = (((unsigned long)maxh) << 12) / height - 4096L;\n\tif (*vscale > EM28XX_HVSCALE_MAX)\n\t\t*vscale = EM28XX_HVSCALE_MAX;\n}\n\nstatic void scale_to_size(struct em28xx *dev,\n\t\t\t  unsigned int hscale, unsigned int vscale,\n\t\t\t  unsigned int *width, unsigned int *height)\n{\n\tunsigned int          maxw = norm_maxw(dev);\n\tunsigned int          maxh = norm_maxh(dev);\n\n\t*width = (((unsigned long)maxw) << 12) / (hscale + 4096L);\n\t*height = (((unsigned long)maxh) << 12) / (vscale + 4096L);\n\n\t \n\tif (*width < 1)\n\t\t*width = 1;\n\tif (*height < 1)\n\t\t*height = 1;\n}\n\n \n\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct em28xx         *dev = video_drvdata(file);\n\tstruct em28xx_v4l2    *v4l2 = dev->v4l2;\n\n\tf->fmt.pix.width = v4l2->width;\n\tf->fmt.pix.height = v4l2->height;\n\tf->fmt.pix.pixelformat = v4l2->format->fourcc;\n\tf->fmt.pix.bytesperline = (v4l2->width * v4l2->format->depth + 7) >> 3;\n\tf->fmt.pix.sizeimage = f->fmt.pix.bytesperline * v4l2->height;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\t \n\tif (v4l2->progressive)\n\t\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\telse\n\t\tf->fmt.pix.field = v4l2->interlaced_fieldmode ?\n\t\t\t   V4L2_FIELD_INTERLACED : V4L2_FIELD_TOP;\n\treturn 0;\n}\n\nstatic struct em28xx_fmt *format_by_fourcc(unsigned int fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(format); i++)\n\t\tif (format[i].fourcc == fourcc)\n\t\t\treturn &format[i];\n\n\treturn NULL;\n}\n\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct em28xx         *dev   = video_drvdata(file);\n\tstruct em28xx_v4l2    *v4l2  = dev->v4l2;\n\tunsigned int          width  = f->fmt.pix.width;\n\tunsigned int          height = f->fmt.pix.height;\n\tunsigned int          maxw   = norm_maxw(dev);\n\tunsigned int          maxh   = norm_maxh(dev);\n\tunsigned int          hscale, vscale;\n\tstruct em28xx_fmt     *fmt;\n\n\tfmt = format_by_fourcc(f->fmt.pix.pixelformat);\n\tif (!fmt) {\n\t\tfmt = &format[0];\n\t\tem28xx_videodbg(\"Fourcc format (%08x) invalid. Using default (%08x).\\n\",\n\t\t\t\tf->fmt.pix.pixelformat, fmt->fourcc);\n\t}\n\n\tif (dev->board.is_em2800) {\n\t\t \n\t\theight = height > (3 * maxh / 4) ? maxh : maxh / 2;\n\t\twidth = width > (3 * maxw / 4) ? maxw : maxw / 2;\n\t\t \n\t\tif (width == maxw && height == maxh)\n\t\t\twidth /= 2;\n\t} else {\n\t\t \n\t\tv4l_bound_align_image(&width, 48, maxw, 1, &height, 32, maxh,\n\t\t\t\t      1, 0);\n\t}\n\t \n\tif (width < 1)\n\t\twidth = 1;\n\tif (height < 1)\n\t\theight = 1;\n\n\tsize_to_scale(dev, width, height, &hscale, &vscale);\n\tscale_to_size(dev, hscale, vscale, &width, &height);\n\n\tf->fmt.pix.width = width;\n\tf->fmt.pix.height = height;\n\tf->fmt.pix.pixelformat = fmt->fourcc;\n\tf->fmt.pix.bytesperline = (width * fmt->depth + 7) >> 3;\n\tf->fmt.pix.sizeimage = f->fmt.pix.bytesperline * height;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tif (v4l2->progressive)\n\t\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\telse\n\t\tf->fmt.pix.field = v4l2->interlaced_fieldmode ?\n\t\t\t   V4L2_FIELD_INTERLACED : V4L2_FIELD_TOP;\n\n\treturn 0;\n}\n\nstatic int em28xx_set_video_format(struct em28xx *dev, unsigned int fourcc,\n\t\t\t\t   unsigned int width, unsigned int height)\n{\n\tstruct em28xx_fmt     *fmt;\n\tstruct em28xx_v4l2    *v4l2 = dev->v4l2;\n\n\tfmt = format_by_fourcc(fourcc);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tv4l2->format = fmt;\n\tv4l2->width  = width;\n\tv4l2->height = height;\n\n\t \n\tsize_to_scale(dev, v4l2->width, v4l2->height,\n\t\t      &v4l2->hscale, &v4l2->vscale);\n\n\tem28xx_resolution_set(dev);\n\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct em28xx *dev = video_drvdata(file);\n\tstruct em28xx_v4l2 *v4l2 = dev->v4l2;\n\n\tif (vb2_is_busy(&v4l2->vb_vidq))\n\t\treturn -EBUSY;\n\n\tvidioc_try_fmt_vid_cap(file, priv, f);\n\n\treturn em28xx_set_video_format(dev, f->fmt.pix.pixelformat,\n\t\t\t\tf->fmt.pix.width, f->fmt.pix.height);\n}\n\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *norm)\n{\n\tstruct em28xx *dev = video_drvdata(file);\n\n\t*norm = dev->v4l2->norm;\n\n\treturn 0;\n}\n\nstatic int vidioc_querystd(struct file *file, void *priv, v4l2_std_id *norm)\n{\n\tstruct em28xx *dev = video_drvdata(file);\n\n\tv4l2_device_call_all(&dev->v4l2->v4l2_dev, 0, video, querystd, norm);\n\n\treturn 0;\n}\n\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id norm)\n{\n\tstruct em28xx      *dev  = video_drvdata(file);\n\tstruct em28xx_v4l2 *v4l2 = dev->v4l2;\n\tstruct v4l2_format f;\n\n\tif (norm == v4l2->norm)\n\t\treturn 0;\n\n\tif (v4l2->streaming_users > 0)\n\t\treturn -EBUSY;\n\n\tv4l2->norm = norm;\n\n\t \n\tf.fmt.pix.width = 720;\n\tf.fmt.pix.height = (norm & V4L2_STD_525_60) ? 480 : 576;\n\tvidioc_try_fmt_vid_cap(file, priv, &f);\n\n\t \n\tv4l2->width = f.fmt.pix.width;\n\tv4l2->height = f.fmt.pix.height;\n\tsize_to_scale(dev, v4l2->width, v4l2->height,\n\t\t      &v4l2->hscale, &v4l2->vscale);\n\n\tem28xx_resolution_set(dev);\n\tv4l2_device_call_all(&v4l2->v4l2_dev, 0, video, s_std, v4l2->norm);\n\n\treturn 0;\n}\n\nstatic int vidioc_g_parm(struct file *file, void *priv,\n\t\t\t struct v4l2_streamparm *p)\n{\n\tstruct v4l2_subdev_frame_interval ival = { 0 };\n\tstruct em28xx      *dev  = video_drvdata(file);\n\tstruct em28xx_v4l2 *v4l2 = dev->v4l2;\n\tint rc = 0;\n\n\tif (p->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\n\t    p->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\treturn -EINVAL;\n\n\tp->parm.capture.readbuffers = EM28XX_MIN_BUF;\n\tp->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\n\tif (dev->is_webcam) {\n\t\trc = v4l2_device_call_until_err(&v4l2->v4l2_dev, 0,\n\t\t\t\t\t\tvideo, g_frame_interval, &ival);\n\t\tif (!rc)\n\t\t\tp->parm.capture.timeperframe = ival.interval;\n\t} else {\n\t\tv4l2_video_std_frame_period(v4l2->norm,\n\t\t\t\t\t    &p->parm.capture.timeperframe);\n\t}\n\n\treturn rc;\n}\n\nstatic int vidioc_s_parm(struct file *file, void *priv,\n\t\t\t struct v4l2_streamparm *p)\n{\n\tstruct em28xx *dev = video_drvdata(file);\n\tstruct v4l2_subdev_frame_interval ival = {\n\t\t0,\n\t\tp->parm.capture.timeperframe\n\t};\n\tint rc = 0;\n\n\tif (!dev->is_webcam)\n\t\treturn -ENOTTY;\n\n\tif (p->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\n\t    p->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\treturn -EINVAL;\n\n\tmemset(&p->parm, 0, sizeof(p->parm));\n\tp->parm.capture.readbuffers = EM28XX_MIN_BUF;\n\tp->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\n\trc = v4l2_device_call_until_err(&dev->v4l2->v4l2_dev, 0,\n\t\t\t\t\tvideo, s_frame_interval, &ival);\n\tif (!rc)\n\t\tp->parm.capture.timeperframe = ival.interval;\n\treturn rc;\n}\n\nstatic int vidioc_enum_input(struct file *file, void *priv,\n\t\t\t     struct v4l2_input *i)\n{\n\tstruct em28xx *dev = video_drvdata(file);\n\tunsigned int       n;\n\tint j;\n\n\tn = i->index;\n\tif (n >= MAX_EM28XX_INPUT)\n\t\treturn -EINVAL;\n\tif (!INPUT(n)->type)\n\t\treturn -EINVAL;\n\n\ti->type = V4L2_INPUT_TYPE_CAMERA;\n\n\tstrscpy(i->name, iname[INPUT(n)->type], sizeof(i->name));\n\n\tif (INPUT(n)->type == EM28XX_VMUX_TELEVISION)\n\t\ti->type = V4L2_INPUT_TYPE_TUNER;\n\n\ti->std = dev->v4l2->vdev.tvnorms;\n\t \n\tif (dev->is_webcam)\n\t\ti->capabilities = 0;\n\n\t \n\ti->audioset = 0;\n\tfor (j = 0; j < MAX_EM28XX_INPUT; j++)\n\t\tif (dev->amux_map[j] != EM28XX_AMUX_UNUSED)\n\t\t\ti->audioset |= 1 << j;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct em28xx *dev = video_drvdata(file);\n\n\t*i = dev->ctl_input;\n\n\treturn 0;\n}\n\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tstruct em28xx *dev = video_drvdata(file);\n\n\tif (i >= MAX_EM28XX_INPUT)\n\t\treturn -EINVAL;\n\tif (!INPUT(i)->type)\n\t\treturn -EINVAL;\n\n\tvideo_mux(dev, i);\n\treturn 0;\n}\n\nstatic int em28xx_fill_audio_input(struct em28xx *dev,\n\t\t\t\t   const char *s,\n\t\t\t\t   struct v4l2_audio *a,\n\t\t\t\t   unsigned int index)\n{\n\tunsigned int idx = dev->amux_map[index];\n\n\t \n\tif (dev->has_msp34xx && idx != EM28XX_AMUX_UNUSED)\n\t\tidx = EM28XX_AMUX_LINE_IN;\n\n\tswitch (idx) {\n\tcase EM28XX_AMUX_VIDEO:\n\t\tstrscpy(a->name, \"Television\", sizeof(a->name));\n\t\tbreak;\n\tcase EM28XX_AMUX_LINE_IN:\n\t\tstrscpy(a->name, \"Line In\", sizeof(a->name));\n\t\tbreak;\n\tcase EM28XX_AMUX_VIDEO2:\n\t\tstrscpy(a->name, \"Television alt\", sizeof(a->name));\n\t\tbreak;\n\tcase EM28XX_AMUX_PHONE:\n\t\tstrscpy(a->name, \"Phone\", sizeof(a->name));\n\t\tbreak;\n\tcase EM28XX_AMUX_MIC:\n\t\tstrscpy(a->name, \"Mic\", sizeof(a->name));\n\t\tbreak;\n\tcase EM28XX_AMUX_CD:\n\t\tstrscpy(a->name, \"CD\", sizeof(a->name));\n\t\tbreak;\n\tcase EM28XX_AMUX_AUX:\n\t\tstrscpy(a->name, \"Aux\", sizeof(a->name));\n\t\tbreak;\n\tcase EM28XX_AMUX_PCM_OUT:\n\t\tstrscpy(a->name, \"PCM\", sizeof(a->name));\n\t\tbreak;\n\tcase EM28XX_AMUX_UNUSED:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\ta->index = index;\n\ta->capability = V4L2_AUDCAP_STEREO;\n\n\tem28xx_videodbg(\"%s: audio input index %d is '%s'\\n\",\n\t\t\ts, a->index, a->name);\n\n\treturn 0;\n}\n\nstatic int vidioc_enumaudio(struct file *file, void *fh, struct v4l2_audio *a)\n{\n\tstruct em28xx *dev = video_drvdata(file);\n\n\tif (a->index >= MAX_EM28XX_INPUT)\n\t\treturn -EINVAL;\n\n\treturn em28xx_fill_audio_input(dev, __func__, a, a->index);\n}\n\nstatic int vidioc_g_audio(struct file *file, void *priv, struct v4l2_audio *a)\n{\n\tstruct em28xx *dev = video_drvdata(file);\n\tint i;\n\n\tfor (i = 0; i < MAX_EM28XX_INPUT; i++)\n\t\tif (dev->ctl_ainput == dev->amux_map[i])\n\t\t\treturn em28xx_fill_audio_input(dev, __func__, a, i);\n\n\t \n\treturn -EINVAL;\n}\n\nstatic int vidioc_s_audio(struct file *file, void *priv,\n\t\t\t  const struct v4l2_audio *a)\n{\n\tstruct em28xx *dev = video_drvdata(file);\n\tint idx, i;\n\n\tif (a->index >= MAX_EM28XX_INPUT)\n\t\treturn -EINVAL;\n\n\tidx = dev->amux_map[a->index];\n\n\tif (idx == EM28XX_AMUX_UNUSED)\n\t\treturn -EINVAL;\n\n\tdev->ctl_ainput = idx;\n\n\t \n\tfor (i = 0; i < MAX_EM28XX_INPUT; i++)\n\t\tif (idx == dev->amux_map[i])\n\t\t\tbreak;\n\tif (i == MAX_EM28XX_INPUT)\n\t\treturn -EINVAL;\n\n\tdev->ctl_aoutput = INPUT(i)->aout;\n\n\tif (!dev->ctl_aoutput)\n\t\tdev->ctl_aoutput = EM28XX_AOUT_MASTER;\n\n\tem28xx_videodbg(\"%s: set audio input to %d\\n\", __func__,\n\t\t\tdev->ctl_ainput);\n\n\treturn 0;\n}\n\nstatic int vidioc_g_tuner(struct file *file, void *priv,\n\t\t\t  struct v4l2_tuner *t)\n{\n\tstruct em28xx *dev = video_drvdata(file);\n\n\tif (t->index != 0)\n\t\treturn -EINVAL;\n\n\tstrscpy(t->name, \"Tuner\", sizeof(t->name));\n\n\tv4l2_device_call_all(&dev->v4l2->v4l2_dev, 0, tuner, g_tuner, t);\n\treturn 0;\n}\n\nstatic int vidioc_s_tuner(struct file *file, void *priv,\n\t\t\t  const struct v4l2_tuner *t)\n{\n\tstruct em28xx *dev = video_drvdata(file);\n\n\tif (t->index != 0)\n\t\treturn -EINVAL;\n\n\tv4l2_device_call_all(&dev->v4l2->v4l2_dev, 0, tuner, s_tuner, t);\n\treturn 0;\n}\n\nstatic int vidioc_g_frequency(struct file *file, void *priv,\n\t\t\t      struct v4l2_frequency *f)\n{\n\tstruct em28xx         *dev = video_drvdata(file);\n\tstruct em28xx_v4l2    *v4l2 = dev->v4l2;\n\n\tif (f->tuner != 0)\n\t\treturn -EINVAL;\n\n\tf->frequency = v4l2->frequency;\n\treturn 0;\n}\n\nstatic int vidioc_s_frequency(struct file *file, void *priv,\n\t\t\t      const struct v4l2_frequency *f)\n{\n\tstruct v4l2_frequency  new_freq = *f;\n\tstruct em28xx             *dev  = video_drvdata(file);\n\tstruct em28xx_v4l2        *v4l2 = dev->v4l2;\n\n\tif (f->tuner != 0)\n\t\treturn -EINVAL;\n\n\tv4l2_device_call_all(&v4l2->v4l2_dev, 0, tuner, s_frequency, f);\n\tv4l2_device_call_all(&v4l2->v4l2_dev, 0, tuner, g_frequency, &new_freq);\n\tv4l2->frequency = new_freq.frequency;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int vidioc_g_chip_info(struct file *file, void *priv,\n\t\t\t      struct v4l2_dbg_chip_info *chip)\n{\n\tstruct em28xx *dev = video_drvdata(file);\n\n\tif (chip->match.addr > 1)\n\t\treturn -EINVAL;\n\tif (chip->match.addr == 1)\n\t\tstrscpy(chip->name, \"ac97\", sizeof(chip->name));\n\telse\n\t\tstrscpy(chip->name,\n\t\t\tdev->v4l2->v4l2_dev.name, sizeof(chip->name));\n\treturn 0;\n}\n\nstatic int em28xx_reg_len(int reg)\n{\n\tswitch (reg) {\n\tcase EM28XX_R40_AC97LSB:\n\tcase EM28XX_R30_HSCALELOW:\n\tcase EM28XX_R32_VSCALELOW:\n\t\treturn 2;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic int vidioc_g_register(struct file *file, void *priv,\n\t\t\t     struct v4l2_dbg_register *reg)\n{\n\tstruct em28xx *dev = video_drvdata(file);\n\tint ret;\n\n\tif (reg->match.addr > 1)\n\t\treturn -EINVAL;\n\tif (reg->match.addr) {\n\t\tret = em28xx_read_ac97(dev, reg->reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treg->val = ret;\n\t\treg->size = 1;\n\t\treturn 0;\n\t}\n\n\t \n\treg->size = em28xx_reg_len(reg->reg);\n\tif (reg->size == 1) {\n\t\tret = em28xx_read_reg(dev, reg->reg);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treg->val = ret;\n\t} else {\n\t\t__le16 val = 0;\n\n\t\tret = dev->em28xx_read_reg_req_len(dev, USB_REQ_GET_STATUS,\n\t\t\t\t\t\t   reg->reg, (char *)&val, 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treg->val = le16_to_cpu(val);\n\t}\n\n\treturn 0;\n}\n\nstatic int vidioc_s_register(struct file *file, void *priv,\n\t\t\t     const struct v4l2_dbg_register *reg)\n{\n\tstruct em28xx *dev = video_drvdata(file);\n\t__le16 buf;\n\n\tif (reg->match.addr > 1)\n\t\treturn -EINVAL;\n\tif (reg->match.addr)\n\t\treturn em28xx_write_ac97(dev, reg->reg, reg->val);\n\n\t \n\tbuf = cpu_to_le16(reg->val);\n\n\treturn em28xx_write_regs(dev, reg->reg, (char *)&buf,\n\t\t\t       em28xx_reg_len(reg->reg));\n}\n#endif\n\nstatic int vidioc_querycap(struct file *file, void  *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct em28xx         *dev  = video_drvdata(file);\n\tstruct em28xx_v4l2    *v4l2 = dev->v4l2;\n\tstruct usb_device *udev = interface_to_usbdev(dev->intf);\n\n\tstrscpy(cap->driver, \"em28xx\", sizeof(cap->driver));\n\tstrscpy(cap->card, em28xx_boards[dev->model].name, sizeof(cap->card));\n\tusb_make_path(udev, cap->bus_info, sizeof(cap->bus_info));\n\n\tcap->capabilities = V4L2_CAP_DEVICE_CAPS | V4L2_CAP_READWRITE |\n\t\t\t    V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\n\tif (dev->int_audio_type != EM28XX_INT_AUDIO_NONE)\n\t\tcap->capabilities |= V4L2_CAP_AUDIO;\n\tif (dev->tuner_type != TUNER_ABSENT)\n\t\tcap->capabilities |= V4L2_CAP_TUNER;\n\tif (video_is_registered(&v4l2->vbi_dev))\n\t\tcap->capabilities |= V4L2_CAP_VBI_CAPTURE;\n\tif (video_is_registered(&v4l2->radio_dev))\n\t\tcap->capabilities |= V4L2_CAP_RADIO;\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tif (unlikely(f->index >= ARRAY_SIZE(format)))\n\t\treturn -EINVAL;\n\n\tf->pixelformat = format[f->index].fourcc;\n\n\treturn 0;\n}\n\nstatic int vidioc_enum_framesizes(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_frmsizeenum *fsize)\n{\n\tstruct em28xx         *dev = video_drvdata(file);\n\tstruct em28xx_fmt     *fmt;\n\tunsigned int\t      maxw = norm_maxw(dev);\n\tunsigned int\t      maxh = norm_maxh(dev);\n\n\tfmt = format_by_fourcc(fsize->pixel_format);\n\tif (!fmt) {\n\t\tem28xx_videodbg(\"Fourcc format (%08x) invalid.\\n\",\n\t\t\t\tfsize->pixel_format);\n\t\treturn -EINVAL;\n\t}\n\n\tif (dev->board.is_em2800) {\n\t\tif (fsize->index > 1)\n\t\t\treturn -EINVAL;\n\t\tfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\t\tfsize->discrete.width = maxw / (1 + fsize->index);\n\t\tfsize->discrete.height = maxh / (1 + fsize->index);\n\t\treturn 0;\n\t}\n\n\tif (fsize->index != 0)\n\t\treturn -EINVAL;\n\n\t \n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\tscale_to_size(dev, EM28XX_HVSCALE_MAX, EM28XX_HVSCALE_MAX,\n\t\t      &fsize->stepwise.min_width, &fsize->stepwise.min_height);\n\tif (fsize->stepwise.min_width < 48)\n\t\tfsize->stepwise.min_width = 48;\n\tif (fsize->stepwise.min_height < 38)\n\t\tfsize->stepwise.min_height = 38;\n\tfsize->stepwise.max_width = maxw;\n\tfsize->stepwise.max_height = maxh;\n\tfsize->stepwise.step_width = 1;\n\tfsize->stepwise.step_height = 1;\n\treturn 0;\n}\n\n \n\nstatic int vidioc_g_fmt_vbi_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *format)\n{\n\tstruct em28xx         *dev  = video_drvdata(file);\n\tstruct em28xx_v4l2    *v4l2 = dev->v4l2;\n\n\tformat->fmt.vbi.samples_per_line = v4l2->vbi_width;\n\tformat->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;\n\tformat->fmt.vbi.offset = 0;\n\tformat->fmt.vbi.flags = 0;\n\tformat->fmt.vbi.sampling_rate = 6750000 * 4 / 2;\n\tformat->fmt.vbi.count[0] = v4l2->vbi_height;\n\tformat->fmt.vbi.count[1] = v4l2->vbi_height;\n\tmemset(format->fmt.vbi.reserved, 0, sizeof(format->fmt.vbi.reserved));\n\n\t \n\tif (v4l2->norm & V4L2_STD_525_60) {\n\t\t \n\t\tformat->fmt.vbi.start[0] = 10;\n\t\tformat->fmt.vbi.start[1] = 273;\n\t} else if (v4l2->norm & V4L2_STD_625_50) {\n\t\t \n\t\tformat->fmt.vbi.start[0] = 6;\n\t\tformat->fmt.vbi.start[1] = 318;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int radio_g_tuner(struct file *file, void *priv,\n\t\t\t struct v4l2_tuner *t)\n{\n\tstruct em28xx *dev = video_drvdata(file);\n\n\tif (unlikely(t->index > 0))\n\t\treturn -EINVAL;\n\n\tstrscpy(t->name, \"Radio\", sizeof(t->name));\n\n\tv4l2_device_call_all(&dev->v4l2->v4l2_dev, 0, tuner, g_tuner, t);\n\n\treturn 0;\n}\n\nstatic int radio_s_tuner(struct file *file, void *priv,\n\t\t\t const struct v4l2_tuner *t)\n{\n\tstruct em28xx *dev = video_drvdata(file);\n\n\tif (t->index != 0)\n\t\treturn -EINVAL;\n\n\tv4l2_device_call_all(&dev->v4l2->v4l2_dev, 0, tuner, s_tuner, t);\n\n\treturn 0;\n}\n\n \nstatic void em28xx_free_v4l2(struct kref *ref)\n{\n\tstruct em28xx_v4l2 *v4l2 = container_of(ref, struct em28xx_v4l2, ref);\n\n\tv4l2->dev->v4l2 = NULL;\n\tkfree(v4l2);\n}\n\n \nstatic int em28xx_v4l2_open(struct file *filp)\n{\n\tstruct video_device *vdev = video_devdata(filp);\n\tstruct em28xx *dev = video_drvdata(filp);\n\tstruct em28xx_v4l2 *v4l2 = dev->v4l2;\n\tenum v4l2_buf_type fh_type = 0;\n\tint ret;\n\n\tswitch (vdev->vfl_type) {\n\tcase VFL_TYPE_VIDEO:\n\t\tfh_type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tbreak;\n\tcase VFL_TYPE_VBI:\n\t\tfh_type = V4L2_BUF_TYPE_VBI_CAPTURE;\n\t\tbreak;\n\tcase VFL_TYPE_RADIO:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tem28xx_videodbg(\"open dev=%s type=%s users=%d\\n\",\n\t\t\tvideo_device_node_name(vdev), v4l2_type_names[fh_type],\n\t\t\tv4l2->users);\n\n\tif (mutex_lock_interruptible(&dev->lock))\n\t\treturn -ERESTARTSYS;\n\n\tret = v4l2_fh_open(filp);\n\tif (ret) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"%s: v4l2_fh_open() returned error %d\\n\",\n\t\t       __func__, ret);\n\t\tmutex_unlock(&dev->lock);\n\t\treturn ret;\n\t}\n\n\tif (v4l2->users == 0) {\n\t\tem28xx_set_mode(dev, EM28XX_ANALOG_MODE);\n\n\t\tif (vdev->vfl_type != VFL_TYPE_RADIO)\n\t\t\tem28xx_resolution_set(dev);\n\n\t\t \n\t\tem28xx_wake_i2c(dev);\n\t}\n\n\tif (vdev->vfl_type == VFL_TYPE_RADIO) {\n\t\tem28xx_videodbg(\"video_open: setting radio device\\n\");\n\t\tv4l2_device_call_all(&v4l2->v4l2_dev, 0, tuner, s_radio);\n\t}\n\n\tkref_get(&dev->ref);\n\tkref_get(&v4l2->ref);\n\tv4l2->users++;\n\n\tmutex_unlock(&dev->lock);\n\n\treturn 0;\n}\n\n \nstatic int em28xx_v4l2_fini(struct em28xx *dev)\n{\n\tstruct em28xx_v4l2 *v4l2 = dev->v4l2;\n\n\tif (dev->is_audio_only) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (!dev->has_video) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (!v4l2)\n\t\treturn 0;\n\n\tdev_info(&dev->intf->dev, \"Closing video extension\\n\");\n\n\tmutex_lock(&dev->lock);\n\n\tv4l2_device_disconnect(&v4l2->v4l2_dev);\n\n\tem28xx_uninit_usb_xfer(dev, EM28XX_ANALOG_MODE);\n\n\tem28xx_v4l2_media_release(dev);\n\n\tif (video_is_registered(&v4l2->radio_dev)) {\n\t\tdev_info(&dev->intf->dev, \"V4L2 device %s deregistered\\n\",\n\t\t\t video_device_node_name(&v4l2->radio_dev));\n\t\tvideo_unregister_device(&v4l2->radio_dev);\n\t}\n\tif (video_is_registered(&v4l2->vbi_dev)) {\n\t\tdev_info(&dev->intf->dev, \"V4L2 device %s deregistered\\n\",\n\t\t\t video_device_node_name(&v4l2->vbi_dev));\n\t\tvideo_unregister_device(&v4l2->vbi_dev);\n\t}\n\tif (video_is_registered(&v4l2->vdev)) {\n\t\tdev_info(&dev->intf->dev, \"V4L2 device %s deregistered\\n\",\n\t\t\t video_device_node_name(&v4l2->vdev));\n\t\tvideo_unregister_device(&v4l2->vdev);\n\t}\n\n\tv4l2_ctrl_handler_free(&v4l2->ctrl_handler);\n\tv4l2_device_unregister(&v4l2->v4l2_dev);\n\n\tkref_put(&v4l2->ref, em28xx_free_v4l2);\n\n\tmutex_unlock(&dev->lock);\n\n\tkref_put(&dev->ref, em28xx_free_device);\n\n\treturn 0;\n}\n\nstatic int em28xx_v4l2_suspend(struct em28xx *dev)\n{\n\tif (dev->is_audio_only)\n\t\treturn 0;\n\n\tif (!dev->has_video)\n\t\treturn 0;\n\n\tdev_info(&dev->intf->dev, \"Suspending video extension\\n\");\n\tem28xx_stop_urbs(dev);\n\treturn 0;\n}\n\nstatic int em28xx_v4l2_resume(struct em28xx *dev)\n{\n\tif (dev->is_audio_only)\n\t\treturn 0;\n\n\tif (!dev->has_video)\n\t\treturn 0;\n\n\tdev_info(&dev->intf->dev, \"Resuming video extension\\n\");\n\t \n\treturn 0;\n}\n\n \nstatic int em28xx_v4l2_close(struct file *filp)\n{\n\tstruct em28xx         *dev  = video_drvdata(filp);\n\tstruct em28xx_v4l2    *v4l2 = dev->v4l2;\n\tstruct usb_device *udev = interface_to_usbdev(dev->intf);\n\tint              err;\n\n\tem28xx_videodbg(\"users=%d\\n\", v4l2->users);\n\n\tvb2_fop_release(filp);\n\tmutex_lock(&dev->lock);\n\n\tif (v4l2->users == 1) {\n\t\t \n\t\tif (dev->disconnected)\n\t\t\tgoto exit;\n\n\t\t \n\t\tv4l2_device_call_all(&v4l2->v4l2_dev, 0, tuner, standby);\n\n\t\t \n\t\tem28xx_set_mode(dev, EM28XX_SUSPEND);\n\n\t\t \n\t\tdev->alt = 0;\n\t\tem28xx_videodbg(\"setting alternate 0\\n\");\n\t\terr = usb_set_interface(udev, 0, 0);\n\t\tif (err < 0) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"cannot change alternate number to 0 (error=%i)\\n\",\n\t\t\t\terr);\n\t\t}\n\t}\n\nexit:\n\tv4l2->users--;\n\tkref_put(&v4l2->ref, em28xx_free_v4l2);\n\tmutex_unlock(&dev->lock);\n\tkref_put(&dev->ref, em28xx_free_device);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations em28xx_v4l_fops = {\n\t.owner         = THIS_MODULE,\n\t.open          = em28xx_v4l2_open,\n\t.release       = em28xx_v4l2_close,\n\t.read          = vb2_fop_read,\n\t.poll          = vb2_fop_poll,\n\t.mmap          = vb2_fop_mmap,\n\t.unlocked_ioctl = video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops video_ioctl_ops = {\n\t.vidioc_querycap            = vidioc_querycap,\n\t.vidioc_enum_fmt_vid_cap    = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap       = vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap     = vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap       = vidioc_s_fmt_vid_cap,\n\t.vidioc_g_fmt_vbi_cap       = vidioc_g_fmt_vbi_cap,\n\t.vidioc_try_fmt_vbi_cap     = vidioc_g_fmt_vbi_cap,\n\t.vidioc_s_fmt_vbi_cap       = vidioc_g_fmt_vbi_cap,\n\t.vidioc_enum_framesizes     = vidioc_enum_framesizes,\n\t.vidioc_enumaudio           = vidioc_enumaudio,\n\t.vidioc_g_audio             = vidioc_g_audio,\n\t.vidioc_s_audio             = vidioc_s_audio,\n\n\t.vidioc_reqbufs             = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs         = vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf         = vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf            = vb2_ioctl_querybuf,\n\t.vidioc_qbuf                = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf               = vb2_ioctl_dqbuf,\n\n\t.vidioc_g_std               = vidioc_g_std,\n\t.vidioc_querystd            = vidioc_querystd,\n\t.vidioc_s_std               = vidioc_s_std,\n\t.vidioc_g_parm\t\t    = vidioc_g_parm,\n\t.vidioc_s_parm\t\t    = vidioc_s_parm,\n\t.vidioc_enum_input          = vidioc_enum_input,\n\t.vidioc_g_input             = vidioc_g_input,\n\t.vidioc_s_input             = vidioc_s_input,\n\t.vidioc_streamon            = vb2_ioctl_streamon,\n\t.vidioc_streamoff           = vb2_ioctl_streamoff,\n\t.vidioc_g_tuner             = vidioc_g_tuner,\n\t.vidioc_s_tuner             = vidioc_s_tuner,\n\t.vidioc_g_frequency         = vidioc_g_frequency,\n\t.vidioc_s_frequency         = vidioc_s_frequency,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_chip_info         = vidioc_g_chip_info,\n\t.vidioc_g_register          = vidioc_g_register,\n\t.vidioc_s_register          = vidioc_s_register,\n#endif\n};\n\nstatic const struct video_device em28xx_video_template = {\n\t.fops\t\t= &em28xx_v4l_fops,\n\t.ioctl_ops\t= &video_ioctl_ops,\n\t.release\t= video_device_release_empty,\n\t.tvnorms\t= V4L2_STD_ALL,\n};\n\nstatic const struct v4l2_file_operations radio_fops = {\n\t.owner         = THIS_MODULE,\n\t.open          = em28xx_v4l2_open,\n\t.release       = em28xx_v4l2_close,\n\t.unlocked_ioctl = video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops radio_ioctl_ops = {\n\t.vidioc_querycap      = vidioc_querycap,\n\t.vidioc_g_tuner       = radio_g_tuner,\n\t.vidioc_s_tuner       = radio_s_tuner,\n\t.vidioc_g_frequency   = vidioc_g_frequency,\n\t.vidioc_s_frequency   = vidioc_s_frequency,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_chip_info   = vidioc_g_chip_info,\n\t.vidioc_g_register    = vidioc_g_register,\n\t.vidioc_s_register    = vidioc_s_register,\n#endif\n};\n\nstatic struct video_device em28xx_radio_template = {\n\t.fops\t\t= &radio_fops,\n\t.ioctl_ops\t= &radio_ioctl_ops,\n\t.release\t= video_device_release_empty,\n};\n\n \nstatic unsigned short saa711x_addrs[] = {\n\t0x4a >> 1, 0x48 >> 1,    \n\t0x42 >> 1, 0x40 >> 1,    \n\tI2C_CLIENT_END };\n\nstatic unsigned short tvp5150_addrs[] = {\n\t0xb8 >> 1,\n\t0xba >> 1,\n\tI2C_CLIENT_END\n};\n\nstatic unsigned short msp3400_addrs[] = {\n\t0x80 >> 1,\n\t0x88 >> 1,\n\tI2C_CLIENT_END\n};\n\n \n\nstatic void em28xx_vdev_init(struct em28xx *dev,\n\t\t\t     struct video_device *vfd,\n\t\t\t     const struct video_device *template,\n\t\t\t     const char *type_name)\n{\n\t*vfd\t\t= *template;\n\tvfd->v4l2_dev\t= &dev->v4l2->v4l2_dev;\n\tvfd->lock\t= &dev->lock;\n\tif (dev->is_webcam)\n\t\tvfd->tvnorms = 0;\n\n\tsnprintf(vfd->name, sizeof(vfd->name), \"%s %s\",\n\t\t dev_name(&dev->intf->dev), type_name);\n\n\tvideo_set_drvdata(vfd, dev);\n}\n\nstatic void em28xx_tuner_setup(struct em28xx *dev, unsigned short tuner_addr)\n{\n\tstruct em28xx_v4l2      *v4l2 = dev->v4l2;\n\tstruct v4l2_device      *v4l2_dev = &v4l2->v4l2_dev;\n\tstruct tuner_setup      tun_setup;\n\tstruct v4l2_frequency   f;\n\n\tmemset(&tun_setup, 0, sizeof(tun_setup));\n\n\ttun_setup.mode_mask = T_ANALOG_TV | T_RADIO;\n\ttun_setup.tuner_callback = em28xx_tuner_callback;\n\n\tif (dev->board.radio.type) {\n\t\ttun_setup.type = dev->board.radio.type;\n\t\ttun_setup.addr = dev->board.radio_addr;\n\n\t\tv4l2_device_call_all(v4l2_dev,\n\t\t\t\t     0, tuner, s_type_addr, &tun_setup);\n\t}\n\n\tif (dev->tuner_type != TUNER_ABSENT && dev->tuner_type) {\n\t\ttun_setup.type   = dev->tuner_type;\n\t\ttun_setup.addr   = tuner_addr;\n\n\t\tv4l2_device_call_all(v4l2_dev,\n\t\t\t\t     0, tuner, s_type_addr, &tun_setup);\n\t}\n\n\tif (dev->board.tda9887_conf) {\n\t\tstruct v4l2_priv_tun_config tda9887_cfg;\n\n\t\ttda9887_cfg.tuner = TUNER_TDA9887;\n\t\ttda9887_cfg.priv = &dev->board.tda9887_conf;\n\n\t\tv4l2_device_call_all(v4l2_dev,\n\t\t\t\t     0, tuner, s_config, &tda9887_cfg);\n\t}\n\n\tif (dev->tuner_type == TUNER_XC2028) {\n\t\tstruct v4l2_priv_tun_config  xc2028_cfg;\n\t\tstruct xc2028_ctrl           ctl;\n\n\t\tmemset(&xc2028_cfg, 0, sizeof(xc2028_cfg));\n\t\tmemset(&ctl, 0, sizeof(ctl));\n\n\t\tem28xx_setup_xc3028(dev, &ctl);\n\n\t\txc2028_cfg.tuner = TUNER_XC2028;\n\t\txc2028_cfg.priv  = &ctl;\n\n\t\tv4l2_device_call_all(v4l2_dev, 0, tuner, s_config, &xc2028_cfg);\n\t}\n\n\t \n\tf.tuner = 0;\n\tf.type = V4L2_TUNER_ANALOG_TV;\n\tf.frequency = 9076;      \n\tv4l2->frequency = f.frequency;\n\tv4l2_device_call_all(v4l2_dev, 0, tuner, s_frequency, &f);\n}\n\nstatic int em28xx_v4l2_init(struct em28xx *dev)\n{\n\tu8 val;\n\tint ret;\n\tunsigned int maxw;\n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct em28xx_v4l2 *v4l2;\n\n\tif (dev->is_audio_only) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (!dev->has_video) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tdev_info(&dev->intf->dev, \"Registering V4L2 extension\\n\");\n\n\tmutex_lock(&dev->lock);\n\n\tv4l2 = kzalloc(sizeof(*v4l2), GFP_KERNEL);\n\tif (!v4l2) {\n\t\tmutex_unlock(&dev->lock);\n\t\treturn -ENOMEM;\n\t}\n\tkref_init(&v4l2->ref);\n\tv4l2->dev = dev;\n\tdev->v4l2 = v4l2;\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tv4l2->v4l2_dev.mdev = dev->media_dev;\n#endif\n\tret = v4l2_device_register(&dev->intf->dev, &v4l2->v4l2_dev);\n\tif (ret < 0) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Call to v4l2_device_register() failed!\\n\");\n\t\tgoto err;\n\t}\n\n\thdl = &v4l2->ctrl_handler;\n\tv4l2_ctrl_handler_init(hdl, 8);\n\tv4l2->v4l2_dev.ctrl_handler = hdl;\n\n\tif (dev->is_webcam)\n\t\tv4l2->progressive = true;\n\n\t \n\tv4l2->vinmode = EM28XX_VINMODE_YUV422_CbYCrY;\n\tv4l2->vinctl  = EM28XX_VINCTRL_INTERLACED |\n\t\t\tEM28XX_VINCTRL_CCIR656_ENABLE;\n\n\t \n\n\tif (dev->has_msp34xx)\n\t\tv4l2_i2c_new_subdev(&v4l2->v4l2_dev,\n\t\t\t\t    &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t    \"msp3400\", 0, msp3400_addrs);\n\n\tif (dev->board.decoder == EM28XX_SAA711X)\n\t\tv4l2_i2c_new_subdev(&v4l2->v4l2_dev,\n\t\t\t\t    &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t    \"saa7115_auto\", 0, saa711x_addrs);\n\n\tif (dev->board.decoder == EM28XX_TVP5150)\n\t\tv4l2_i2c_new_subdev(&v4l2->v4l2_dev,\n\t\t\t\t    &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t    \"tvp5150\", 0, tvp5150_addrs);\n\n\tif (dev->board.adecoder == EM28XX_TVAUDIO)\n\t\tv4l2_i2c_new_subdev(&v4l2->v4l2_dev,\n\t\t\t\t    &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t    \"tvaudio\", dev->board.tvaudio_addr, NULL);\n\n\t \n\n\tif (dev->board.tuner_type != TUNER_ABSENT) {\n\t\tunsigned short tuner_addr = dev->board.tuner_addr;\n\t\tint has_demod = (dev->board.tda9887_conf & TDA9887_PRESENT);\n\n\t\tif (dev->board.radio.type)\n\t\t\tv4l2_i2c_new_subdev(&v4l2->v4l2_dev,\n\t\t\t\t\t    &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t    \"tuner\", dev->board.radio_addr,\n\t\t\t\t\t    NULL);\n\n\t\tif (has_demod)\n\t\t\tv4l2_i2c_new_subdev(&v4l2->v4l2_dev,\n\t\t\t\t\t    &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t    \"tuner\", 0,\n\t\t\t\t\t    v4l2_i2c_tuner_addrs(ADDRS_DEMOD));\n\t\tif (tuner_addr == 0) {\n\t\t\tenum v4l2_i2c_tuner_type type =\n\t\t\t\thas_demod ? ADDRS_TV_WITH_DEMOD : ADDRS_TV;\n\t\t\tstruct v4l2_subdev *sd;\n\n\t\t\tsd = v4l2_i2c_new_subdev(&v4l2->v4l2_dev,\n\t\t\t\t\t\t &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t\t \"tuner\", 0,\n\t\t\t\t\t\t v4l2_i2c_tuner_addrs(type));\n\n\t\t\tif (sd)\n\t\t\t\ttuner_addr = v4l2_i2c_subdev_addr(sd);\n\t\t} else {\n\t\t\tv4l2_i2c_new_subdev(&v4l2->v4l2_dev,\n\t\t\t\t\t    &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t    \"tuner\", tuner_addr, NULL);\n\t\t}\n\n\t\tem28xx_tuner_setup(dev, tuner_addr);\n\t}\n\n\tif (dev->em28xx_sensor != EM28XX_NOSENSOR)\n\t\tem28xx_init_camera(dev);\n\n\t \n\tret = em28xx_audio_setup(dev);\n\tif (ret < 0) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"%s: Error while setting audio - error [%d]!\\n\",\n\t\t\t__func__, ret);\n\t\tgoto unregister_dev;\n\t}\n\tif (dev->audio_mode.ac97 != EM28XX_NO_AC97) {\n\t\tv4l2_ctrl_new_std(hdl, &em28xx_ctrl_ops,\n\t\t\t\t  V4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\n\t\tv4l2_ctrl_new_std(hdl, &em28xx_ctrl_ops,\n\t\t\t\t  V4L2_CID_AUDIO_VOLUME, 0, 0x1f, 1, 0x1f);\n\t} else {\n\t\t \n\t\tv4l2_ctrl_notify(v4l2_ctrl_find(hdl, V4L2_CID_AUDIO_MUTE),\n\t\t\t\t em28xx_ctrl_notify, dev);\n\t\tv4l2_ctrl_notify(v4l2_ctrl_find(hdl, V4L2_CID_AUDIO_VOLUME),\n\t\t\t\t em28xx_ctrl_notify, dev);\n\t}\n\n\t \n\tem28xx_wake_i2c(dev);\n\n\t \n\tINIT_LIST_HEAD(&dev->vidq.active);\n\tINIT_LIST_HEAD(&dev->vbiq.active);\n\n\tif (dev->has_msp34xx) {\n\t\t \n\t\tret = em28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xf7);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"%s: em28xx_write_reg - msp34xx(1) failed! error [%d]\\n\",\n\t\t\t\t__func__, ret);\n\t\t\tgoto unregister_dev;\n\t\t}\n\t\tusleep_range(10000, 11000);\n\n\t\tret = em28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xff);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"%s: em28xx_write_reg - msp34xx(2) failed! error [%d]\\n\",\n\t\t\t\t__func__, ret);\n\t\t\tgoto unregister_dev;\n\t\t}\n\t\tusleep_range(10000, 11000);\n\t}\n\n\t \n\tv4l2->norm = V4L2_STD_PAL;\n\tv4l2_device_call_all(&v4l2->v4l2_dev, 0, video, s_std, v4l2->norm);\n\tv4l2->interlaced_fieldmode = EM28XX_INTERLACED_DEFAULT;\n\n\t \n\tv4l2->format = &format[0];\n\n\tmaxw = norm_maxw(dev);\n\t \n\tif (dev->board.is_em2800)\n\t\tmaxw /= 2;\n\n\tem28xx_set_video_format(dev, format[0].fourcc,\n\t\t\t\tmaxw, norm_maxh(dev));\n\n\tvideo_mux(dev, 0);\n\n\t \n\tdev->mute = 1;\n\tdev->volume = 0x1f;\n\n \n\tval = (u8)em28xx_read_reg(dev, EM28XX_R0F_XCLK);\n\tem28xx_write_reg(dev, EM28XX_R0F_XCLK,\n\t\t\t (EM28XX_XCLK_AUDIO_UNMUTE | val));\n\n\tem28xx_set_outfmt(dev);\n\n\t \n\n\t \n\tif (!v4l2_ctrl_find(hdl, V4L2_CID_CONTRAST))\n\t\tv4l2_ctrl_new_std(hdl, &em28xx_ctrl_ops,\n\t\t\t\t  V4L2_CID_CONTRAST,\n\t\t\t\t  0, 0x1f, 1, CONTRAST_DEFAULT);\n\tif (!v4l2_ctrl_find(hdl, V4L2_CID_BRIGHTNESS))\n\t\tv4l2_ctrl_new_std(hdl, &em28xx_ctrl_ops,\n\t\t\t\t  V4L2_CID_BRIGHTNESS,\n\t\t\t\t  -0x80, 0x7f, 1, BRIGHTNESS_DEFAULT);\n\tif (!v4l2_ctrl_find(hdl, V4L2_CID_SATURATION))\n\t\tv4l2_ctrl_new_std(hdl, &em28xx_ctrl_ops,\n\t\t\t\t  V4L2_CID_SATURATION,\n\t\t\t\t  0, 0x1f, 1, SATURATION_DEFAULT);\n\tif (!v4l2_ctrl_find(hdl, V4L2_CID_BLUE_BALANCE))\n\t\tv4l2_ctrl_new_std(hdl, &em28xx_ctrl_ops,\n\t\t\t\t  V4L2_CID_BLUE_BALANCE,\n\t\t\t\t  -0x30, 0x30, 1, BLUE_BALANCE_DEFAULT);\n\tif (!v4l2_ctrl_find(hdl, V4L2_CID_RED_BALANCE))\n\t\tv4l2_ctrl_new_std(hdl, &em28xx_ctrl_ops,\n\t\t\t\t  V4L2_CID_RED_BALANCE,\n\t\t\t\t  -0x30, 0x30, 1, RED_BALANCE_DEFAULT);\n\tif (!v4l2_ctrl_find(hdl, V4L2_CID_SHARPNESS))\n\t\tv4l2_ctrl_new_std(hdl, &em28xx_ctrl_ops,\n\t\t\t\t  V4L2_CID_SHARPNESS,\n\t\t\t\t  0, 0x0f, 1, SHARPNESS_DEFAULT);\n\n\t \n\tem28xx_colorlevels_set_default(dev);\n\tv4l2_ctrl_handler_setup(hdl);\n\tret = hdl->error;\n\tif (ret)\n\t\tgoto unregister_dev;\n\n\t \n\tem28xx_vdev_init(dev, &v4l2->vdev, &em28xx_video_template, \"video\");\n\tmutex_init(&v4l2->vb_queue_lock);\n\tmutex_init(&v4l2->vb_vbi_queue_lock);\n\tv4l2->vdev.queue = &v4l2->vb_vidq;\n\tv4l2->vdev.queue->lock = &v4l2->vb_queue_lock;\n\tv4l2->vdev.device_caps = V4L2_CAP_READWRITE | V4L2_CAP_VIDEO_CAPTURE |\n\t\t\t\t V4L2_CAP_STREAMING;\n\tif (dev->int_audio_type != EM28XX_INT_AUDIO_NONE)\n\t\tv4l2->vdev.device_caps |= V4L2_CAP_AUDIO;\n\tif (dev->tuner_type != TUNER_ABSENT)\n\t\tv4l2->vdev.device_caps |= V4L2_CAP_TUNER;\n\n\n\t \n\tif (dev->is_webcam) {\n\t\tv4l2_disable_ioctl(&v4l2->vdev, VIDIOC_QUERYSTD);\n\t\tv4l2_disable_ioctl(&v4l2->vdev, VIDIOC_G_STD);\n\t\tv4l2_disable_ioctl(&v4l2->vdev, VIDIOC_S_STD);\n\t} else {\n\t\tv4l2_disable_ioctl(&v4l2->vdev, VIDIOC_S_PARM);\n\t}\n\tif (dev->tuner_type == TUNER_ABSENT) {\n\t\tv4l2_disable_ioctl(&v4l2->vdev, VIDIOC_G_TUNER);\n\t\tv4l2_disable_ioctl(&v4l2->vdev, VIDIOC_S_TUNER);\n\t\tv4l2_disable_ioctl(&v4l2->vdev, VIDIOC_G_FREQUENCY);\n\t\tv4l2_disable_ioctl(&v4l2->vdev, VIDIOC_S_FREQUENCY);\n\t}\n\tif (dev->int_audio_type == EM28XX_INT_AUDIO_NONE) {\n\t\tv4l2_disable_ioctl(&v4l2->vdev, VIDIOC_G_AUDIO);\n\t\tv4l2_disable_ioctl(&v4l2->vdev, VIDIOC_S_AUDIO);\n\t}\n\n\t \n\tret = video_register_device(&v4l2->vdev, VFL_TYPE_VIDEO,\n\t\t\t\t    video_nr[dev->devno]);\n\tif (ret) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"unable to register video device (error=%i).\\n\", ret);\n\t\tgoto unregister_dev;\n\t}\n\n\t \n\tif (em28xx_vbi_supported(dev) == 1) {\n\t\tem28xx_vdev_init(dev, &v4l2->vbi_dev, &em28xx_video_template,\n\t\t\t\t \"vbi\");\n\n\t\tv4l2->vbi_dev.queue = &v4l2->vb_vbiq;\n\t\tv4l2->vbi_dev.queue->lock = &v4l2->vb_vbi_queue_lock;\n\t\tv4l2->vbi_dev.device_caps = V4L2_CAP_STREAMING |\n\t\t\tV4L2_CAP_READWRITE | V4L2_CAP_VBI_CAPTURE;\n\t\tif (dev->tuner_type != TUNER_ABSENT)\n\t\t\tv4l2->vbi_dev.device_caps |= V4L2_CAP_TUNER;\n\n\t\t \n\t\tv4l2_disable_ioctl(&v4l2->vbi_dev, VIDIOC_S_PARM);\n\t\tif (dev->tuner_type == TUNER_ABSENT) {\n\t\t\tv4l2_disable_ioctl(&v4l2->vbi_dev, VIDIOC_G_TUNER);\n\t\t\tv4l2_disable_ioctl(&v4l2->vbi_dev, VIDIOC_S_TUNER);\n\t\t\tv4l2_disable_ioctl(&v4l2->vbi_dev, VIDIOC_G_FREQUENCY);\n\t\t\tv4l2_disable_ioctl(&v4l2->vbi_dev, VIDIOC_S_FREQUENCY);\n\t\t}\n\t\tif (dev->int_audio_type == EM28XX_INT_AUDIO_NONE) {\n\t\t\tv4l2_disable_ioctl(&v4l2->vbi_dev, VIDIOC_G_AUDIO);\n\t\t\tv4l2_disable_ioctl(&v4l2->vbi_dev, VIDIOC_S_AUDIO);\n\t\t}\n\n\t\t \n\t\tret = video_register_device(&v4l2->vbi_dev, VFL_TYPE_VBI,\n\t\t\t\t\t    vbi_nr[dev->devno]);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"unable to register vbi device\\n\");\n\t\t\tgoto unregister_dev;\n\t\t}\n\t}\n\n\tif (em28xx_boards[dev->model].radio.type == EM28XX_RADIO) {\n\t\tem28xx_vdev_init(dev, &v4l2->radio_dev, &em28xx_radio_template,\n\t\t\t\t \"radio\");\n\t\tv4l2->radio_dev.device_caps = V4L2_CAP_RADIO | V4L2_CAP_TUNER;\n\t\tret = video_register_device(&v4l2->radio_dev, VFL_TYPE_RADIO,\n\t\t\t\t\t    radio_nr[dev->devno]);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"can't register radio device\\n\");\n\t\t\tgoto unregister_dev;\n\t\t}\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"Registered radio device as %s\\n\",\n\t\t\t video_device_node_name(&v4l2->radio_dev));\n\t}\n\n\t \n\tem28xx_v4l2_create_entities(dev);\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tret = v4l2_mc_create_media_graph(dev->media_dev);\n\tif (ret) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"failed to create media graph\\n\");\n\t\tem28xx_v4l2_media_release(dev);\n\t\tgoto unregister_dev;\n\t}\n#endif\n\n\tdev_info(&dev->intf->dev,\n\t\t \"V4L2 video device registered as %s\\n\",\n\t\t video_device_node_name(&v4l2->vdev));\n\n\tif (video_is_registered(&v4l2->vbi_dev))\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"V4L2 VBI device registered as %s\\n\",\n\t\t\t video_device_node_name(&v4l2->vbi_dev));\n\n\t \n\tv4l2_device_call_all(&v4l2->v4l2_dev, 0, tuner, standby);\n\n\t \n\tem28xx_vb2_setup(dev);\n\n\tdev_info(&dev->intf->dev,\n\t\t \"V4L2 extension successfully initialized\\n\");\n\n\tkref_get(&dev->ref);\n\n\tmutex_unlock(&dev->lock);\n\treturn 0;\n\nunregister_dev:\n\tif (video_is_registered(&v4l2->radio_dev)) {\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"V4L2 device %s deregistered\\n\",\n\t\t\t video_device_node_name(&v4l2->radio_dev));\n\t\tvideo_unregister_device(&v4l2->radio_dev);\n\t}\n\tif (video_is_registered(&v4l2->vbi_dev)) {\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"V4L2 device %s deregistered\\n\",\n\t\t\t video_device_node_name(&v4l2->vbi_dev));\n\t\tvideo_unregister_device(&v4l2->vbi_dev);\n\t}\n\tif (video_is_registered(&v4l2->vdev)) {\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"V4L2 device %s deregistered\\n\",\n\t\t\t video_device_node_name(&v4l2->vdev));\n\t\tvideo_unregister_device(&v4l2->vdev);\n\t}\n\n\tv4l2_ctrl_handler_free(&v4l2->ctrl_handler);\n\tv4l2_device_unregister(&v4l2->v4l2_dev);\nerr:\n\tdev->v4l2 = NULL;\n\tkref_put(&v4l2->ref, em28xx_free_v4l2);\n\tmutex_unlock(&dev->lock);\n\treturn ret;\n}\n\nstatic struct em28xx_ops v4l2_ops = {\n\t.id   = EM28XX_V4L2,\n\t.name = \"Em28xx v4l2 Extension\",\n\t.init = em28xx_v4l2_init,\n\t.fini = em28xx_v4l2_fini,\n\t.suspend = em28xx_v4l2_suspend,\n\t.resume = em28xx_v4l2_resume,\n};\n\nstatic int __init em28xx_video_register(void)\n{\n\treturn em28xx_register_extension(&v4l2_ops);\n}\n\nstatic void __exit em28xx_video_unregister(void)\n{\n\tem28xx_unregister_extension(&v4l2_ops);\n}\n\nmodule_init(em28xx_video_register);\nmodule_exit(em28xx_video_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}