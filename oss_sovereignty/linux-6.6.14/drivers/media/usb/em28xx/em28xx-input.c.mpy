{
  "module_name": "em28xx-input.c",
  "hash_id": "dea5dae30fd6bc075641481c3633f25cbeafb2a928a184da09748caffdafcbb9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/em28xx/em28xx-input.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include \"em28xx.h\"\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/usb.h>\n#include <linux/usb/input.h>\n#include <linux/slab.h>\n#include <linux/bitrev.h>\n\n#define EM28XX_SNAPSHOT_KEY\t\t\t\tKEY_CAMERA\n#define EM28XX_BUTTONS_DEBOUNCED_QUERY_INTERVAL\t\t500  \n#define EM28XX_BUTTONS_VOLATILE_QUERY_INTERVAL\t\t100  \n\nstatic unsigned int ir_debug;\nmodule_param(ir_debug, int, 0644);\nMODULE_PARM_DESC(ir_debug, \"enable debug messages [IR]\");\n\n#define MODULE_NAME \"em28xx\"\n\n#define dprintk(fmt, arg...) do {\t\t\t\t\t\\\n\tif (ir_debug)\t\t\t\t\t\t\t\\\n\t\tdev_printk(KERN_DEBUG, &ir->dev->intf->dev,\t\t\\\n\t\t\t   \"input: %s: \" fmt, __func__, ## arg);\t\\\n} while (0)\n\n \n\nstruct em28xx_ir_poll_result {\n\tunsigned int toggle_bit:1;\n\tunsigned int read_count:7;\n\n\tenum rc_proto protocol;\n\tu32 scancode;\n};\n\nstruct em28xx_IR {\n\tstruct em28xx *dev;\n\tstruct rc_dev *rc;\n\tchar phys[32];\n\n\t \n\tint polling;\n\tstruct delayed_work work;\n\tunsigned int full_code:1;\n\tunsigned int last_readcount;\n\tu64 rc_proto;\n\n\tstruct i2c_client *i2c_client;\n\n\tint  (*get_key_i2c)(struct i2c_client *ir, enum rc_proto *protocol,\n\t\t\t    u32 *scancode);\n\tint  (*get_key)(struct em28xx_IR *ir, struct em28xx_ir_poll_result *r);\n};\n\n \n\nstatic int em28xx_get_key_terratec(struct i2c_client *i2c_dev,\n\t\t\t\t   enum rc_proto *protocol, u32 *scancode)\n{\n\tint rc;\n\tunsigned char b;\n\n\t \n\trc = i2c_master_recv(i2c_dev, &b, 1);\n\tif (rc != 1) {\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treturn -EIO;\n\t}\n\n\t \n\n\tif (b == 0xff)\n\t\treturn 0;\n\n\tif (b == 0xfe)\n\t\t \n\t\treturn 1;\n\n\t*protocol = RC_PROTO_UNKNOWN;\n\t*scancode = b;\n\treturn 1;\n}\n\nstatic int em28xx_get_key_em_haup(struct i2c_client *i2c_dev,\n\t\t\t\t  enum rc_proto *protocol, u32 *scancode)\n{\n\tunsigned char buf[2];\n\tint size;\n\n\t \n\tsize = i2c_master_recv(i2c_dev, buf, sizeof(buf));\n\n\tif (size != 2)\n\t\treturn -EIO;\n\n\t \n\tif (buf[1] == 0xff)\n\t\treturn 0;\n\n\t \n\t*protocol = RC_PROTO_RC5;\n\t*scancode = (bitrev8(buf[1]) & 0x1f) << 8 | bitrev8(buf[0]) >> 2;\n\treturn 1;\n}\n\nstatic int em28xx_get_key_pinnacle_usb_grey(struct i2c_client *i2c_dev,\n\t\t\t\t\t    enum rc_proto *protocol,\n\t\t\t\t\t    u32 *scancode)\n{\n\tunsigned char buf[3];\n\n\t \n\n\tif (i2c_master_recv(i2c_dev, buf, 3) != 3)\n\t\treturn -EIO;\n\n\tif (buf[0] != 0x00)\n\t\treturn 0;\n\n\t*protocol = RC_PROTO_UNKNOWN;\n\t*scancode = buf[2] & 0x3f;\n\treturn 1;\n}\n\nstatic int em28xx_get_key_winfast_usbii_deluxe(struct i2c_client *i2c_dev,\n\t\t\t\t\t       enum rc_proto *protocol,\n\t\t\t\t\t       u32 *scancode)\n{\n\tunsigned char subaddr, keydetect, key;\n\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = i2c_dev->addr,\n\t\t\t.flags = 0,\n\t\t\t.buf = &subaddr, .len = 1\n\t\t}, {\n\t\t\t.addr = i2c_dev->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = &keydetect,\n\t\t\t.len = 1\n\t\t}\n\t};\n\n\tsubaddr = 0x10;\n\tif (i2c_transfer(i2c_dev->adapter, msg, 2) != 2)\n\t\treturn -EIO;\n\tif (keydetect == 0x00)\n\t\treturn 0;\n\n\tsubaddr = 0x00;\n\tmsg[1].buf = &key;\n\tif (i2c_transfer(i2c_dev->adapter, msg, 2) != 2)\n\t\treturn -EIO;\n\tif (key == 0x00)\n\t\treturn 0;\n\n\t*protocol = RC_PROTO_UNKNOWN;\n\t*scancode = key;\n\treturn 1;\n}\n\n \n\n \nstatic int default_polling_getkey(struct em28xx_IR *ir,\n\t\t\t\t  struct em28xx_ir_poll_result *poll_result)\n{\n\tstruct em28xx *dev = ir->dev;\n\tint rc;\n\tu8 msg[3] = { 0, 0, 0 };\n\n\t \n\trc = dev->em28xx_read_reg_req_len(dev, 0, EM28XX_R45_IR,\n\t\t\t\t\t  msg, sizeof(msg));\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tpoll_result->toggle_bit = (msg[0] >> 7);\n\n\t \n\tpoll_result->read_count = (msg[0] & 0x7f);\n\n\t \n\tswitch (ir->rc_proto) {\n\tcase RC_PROTO_BIT_RC5:\n\t\tpoll_result->protocol = RC_PROTO_RC5;\n\t\tpoll_result->scancode = RC_SCANCODE_RC5(msg[1], msg[2]);\n\t\tbreak;\n\n\tcase RC_PROTO_BIT_NEC:\n\t\tpoll_result->protocol = RC_PROTO_NEC;\n\t\tpoll_result->scancode = RC_SCANCODE_NEC(msg[1], msg[2]);\n\t\tbreak;\n\n\tdefault:\n\t\tpoll_result->protocol = RC_PROTO_UNKNOWN;\n\t\tpoll_result->scancode = msg[1] << 8 | msg[2];\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int em2874_polling_getkey(struct em28xx_IR *ir,\n\t\t\t\t struct em28xx_ir_poll_result *poll_result)\n{\n\tstruct em28xx *dev = ir->dev;\n\tint rc;\n\tu8 msg[5] = { 0, 0, 0, 0, 0 };\n\n\t \n\trc = dev->em28xx_read_reg_req_len(dev, 0, EM2874_R51_IR,\n\t\t\t\t\t  msg, sizeof(msg));\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tpoll_result->toggle_bit = (msg[0] >> 7);\n\n\t \n\tpoll_result->read_count = (msg[0] & 0x7f);\n\n\t \n\tswitch (ir->rc_proto) {\n\tcase RC_PROTO_BIT_RC5:\n\t\tpoll_result->protocol = RC_PROTO_RC5;\n\t\tpoll_result->scancode = RC_SCANCODE_RC5(msg[1], msg[2]);\n\t\tbreak;\n\n\tcase RC_PROTO_BIT_NEC:\n\t\tpoll_result->scancode = ir_nec_bytes_to_scancode(msg[1], msg[2], msg[3], msg[4],\n\t\t\t\t\t\t\t\t &poll_result->protocol);\n\t\tbreak;\n\n\tcase RC_PROTO_BIT_RC6_0:\n\t\tpoll_result->protocol = RC_PROTO_RC6_0;\n\t\tpoll_result->scancode = RC_SCANCODE_RC6_0(msg[1], msg[2]);\n\t\tbreak;\n\n\tdefault:\n\t\tpoll_result->protocol = RC_PROTO_UNKNOWN;\n\t\tpoll_result->scancode = (msg[1] << 24) | (msg[2] << 16) |\n\t\t\t\t\t(msg[3] << 8)  | msg[4];\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int em28xx_i2c_ir_handle_key(struct em28xx_IR *ir)\n{\n\tstatic u32 scancode;\n\tenum rc_proto protocol;\n\tint rc;\n\n\trc = ir->get_key_i2c(ir->i2c_client, &protocol, &scancode);\n\tif (rc < 0) {\n\t\tdprintk(\"ir->get_key_i2c() failed: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (rc) {\n\t\tdprintk(\"%s: proto = 0x%04x, scancode = 0x%04x\\n\",\n\t\t\t__func__, protocol, scancode);\n\t\trc_keydown(ir->rc, protocol, scancode, 0);\n\t}\n\treturn 0;\n}\n\nstatic void em28xx_ir_handle_key(struct em28xx_IR *ir)\n{\n\tint result;\n\tstruct em28xx_ir_poll_result poll_result;\n\n\t \n\tresult = ir->get_key(ir, &poll_result);\n\tif (unlikely(result < 0)) {\n\t\tdprintk(\"ir->get_key() failed: %d\\n\", result);\n\t\treturn;\n\t}\n\n\tif (unlikely(poll_result.read_count != ir->last_readcount)) {\n\t\tdprintk(\"%s: toggle: %d, count: %d, key 0x%04x\\n\", __func__,\n\t\t\tpoll_result.toggle_bit, poll_result.read_count,\n\t\t\tpoll_result.scancode);\n\t\tif (ir->full_code)\n\t\t\trc_keydown(ir->rc,\n\t\t\t\t   poll_result.protocol,\n\t\t\t\t   poll_result.scancode,\n\t\t\t\t   poll_result.toggle_bit);\n\t\telse\n\t\t\trc_keydown(ir->rc,\n\t\t\t\t   RC_PROTO_UNKNOWN,\n\t\t\t\t   poll_result.scancode & 0xff,\n\t\t\t\t   poll_result.toggle_bit);\n\n\t\tif (ir->dev->chip_id == CHIP_ID_EM2874 ||\n\t\t    ir->dev->chip_id == CHIP_ID_EM2884)\n\t\t\t \n\t\t\tir->last_readcount = 0;\n\t\telse\n\t\t\tir->last_readcount = poll_result.read_count;\n\t}\n}\n\nstatic void em28xx_ir_work(struct work_struct *work)\n{\n\tstruct em28xx_IR *ir = container_of(work, struct em28xx_IR, work.work);\n\n\tif (ir->i2c_client)  \n\t\tem28xx_i2c_ir_handle_key(ir);\n\telse  \n\t\tem28xx_ir_handle_key(ir);\n\tschedule_delayed_work(&ir->work, msecs_to_jiffies(ir->polling));\n}\n\nstatic int em28xx_ir_start(struct rc_dev *rc)\n{\n\tstruct em28xx_IR *ir = rc->priv;\n\n\tINIT_DELAYED_WORK(&ir->work, em28xx_ir_work);\n\tschedule_delayed_work(&ir->work, 0);\n\n\treturn 0;\n}\n\nstatic void em28xx_ir_stop(struct rc_dev *rc)\n{\n\tstruct em28xx_IR *ir = rc->priv;\n\n\tcancel_delayed_work_sync(&ir->work);\n}\n\nstatic int em2860_ir_change_protocol(struct rc_dev *rc_dev, u64 *rc_proto)\n{\n\tstruct em28xx_IR *ir = rc_dev->priv;\n\tstruct em28xx *dev = ir->dev;\n\n\t \n\tif (*rc_proto & RC_PROTO_BIT_RC5) {\n\t\tdev->board.xclk |= EM28XX_XCLK_IR_RC5_MODE;\n\t\tir->full_code = 1;\n\t\t*rc_proto = RC_PROTO_BIT_RC5;\n\t} else if (*rc_proto & RC_PROTO_BIT_NEC) {\n\t\tdev->board.xclk &= ~EM28XX_XCLK_IR_RC5_MODE;\n\t\tir->full_code = 1;\n\t\t*rc_proto = RC_PROTO_BIT_NEC;\n\t} else if (*rc_proto & RC_PROTO_BIT_UNKNOWN) {\n\t\t*rc_proto = RC_PROTO_BIT_UNKNOWN;\n\t} else {\n\t\t*rc_proto = ir->rc_proto;\n\t\treturn -EINVAL;\n\t}\n\tem28xx_write_reg_bits(dev, EM28XX_R0F_XCLK, dev->board.xclk,\n\t\t\t      EM28XX_XCLK_IR_RC5_MODE);\n\n\tir->rc_proto = *rc_proto;\n\n\treturn 0;\n}\n\nstatic int em2874_ir_change_protocol(struct rc_dev *rc_dev, u64 *rc_proto)\n{\n\tstruct em28xx_IR *ir = rc_dev->priv;\n\tstruct em28xx *dev = ir->dev;\n\tu8 ir_config = EM2874_IR_RC5;\n\n\t \n\tif (*rc_proto & RC_PROTO_BIT_RC5) {\n\t\tdev->board.xclk |= EM28XX_XCLK_IR_RC5_MODE;\n\t\tir->full_code = 1;\n\t\t*rc_proto = RC_PROTO_BIT_RC5;\n\t} else if (*rc_proto & RC_PROTO_BIT_NEC) {\n\t\tdev->board.xclk &= ~EM28XX_XCLK_IR_RC5_MODE;\n\t\tir_config = EM2874_IR_NEC | EM2874_IR_NEC_NO_PARITY;\n\t\tir->full_code = 1;\n\t\t*rc_proto = RC_PROTO_BIT_NEC;\n\t} else if (*rc_proto & RC_PROTO_BIT_RC6_0) {\n\t\tdev->board.xclk |= EM28XX_XCLK_IR_RC5_MODE;\n\t\tir_config = EM2874_IR_RC6_MODE_0;\n\t\tir->full_code = 1;\n\t\t*rc_proto = RC_PROTO_BIT_RC6_0;\n\t} else if (*rc_proto & RC_PROTO_BIT_UNKNOWN) {\n\t\t*rc_proto = RC_PROTO_BIT_UNKNOWN;\n\t} else {\n\t\t*rc_proto = ir->rc_proto;\n\t\treturn -EINVAL;\n\t}\n\tem28xx_write_regs(dev, EM2874_R50_IR_CONFIG, &ir_config, 1);\n\tem28xx_write_reg_bits(dev, EM28XX_R0F_XCLK, dev->board.xclk,\n\t\t\t      EM28XX_XCLK_IR_RC5_MODE);\n\n\tir->rc_proto = *rc_proto;\n\n\treturn 0;\n}\n\nstatic int em28xx_ir_change_protocol(struct rc_dev *rc_dev, u64 *rc_proto)\n{\n\tstruct em28xx_IR *ir = rc_dev->priv;\n\tstruct em28xx *dev = ir->dev;\n\n\t \n\tswitch (dev->chip_id) {\n\tcase CHIP_ID_EM2860:\n\tcase CHIP_ID_EM2883:\n\t\treturn em2860_ir_change_protocol(rc_dev, rc_proto);\n\tcase CHIP_ID_EM2884:\n\tcase CHIP_ID_EM2874:\n\tcase CHIP_ID_EM28174:\n\tcase CHIP_ID_EM28178:\n\t\treturn em2874_ir_change_protocol(rc_dev, rc_proto);\n\tdefault:\n\t\tdev_err(&ir->dev->intf->dev,\n\t\t\t\"Unrecognized em28xx chip id 0x%02x: IR not supported\\n\",\n\t\t\tdev->chip_id);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int em28xx_probe_i2c_ir(struct em28xx *dev)\n{\n\tint i = 0;\n\t \n\tstatic const unsigned short addr_list[] = {\n\t\t 0x1f, 0x30, 0x47, I2C_CLIENT_END\n\t};\n\n\twhile (addr_list[i] != I2C_CLIENT_END) {\n\t\tif (i2c_probe_func_quick_read(&dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t      addr_list[i]) == 1)\n\t\t\treturn addr_list[i];\n\t\ti++;\n\t}\n\n\treturn -ENODEV;\n}\n\n \n\nstatic void em28xx_query_buttons(struct work_struct *work)\n{\n\tstruct em28xx *dev =\n\t\tcontainer_of(work, struct em28xx, buttons_query_work.work);\n\tu8 i, j;\n\tint regval;\n\tbool is_pressed, was_pressed;\n\tconst struct em28xx_led *led;\n\n\t \n\tfor (i = 0; i < dev->num_button_polling_addresses; i++) {\n\t\t \n\t\tregval = em28xx_read_reg(dev, dev->button_polling_addresses[i]);\n\t\tif (regval < 0)\n\t\t\tcontinue;\n\t\t \n\t\tj = 0;\n\t\twhile (dev->board.buttons[j].role >= 0 &&\n\t\t       dev->board.buttons[j].role < EM28XX_NUM_BUTTON_ROLES) {\n\t\t\tconst struct em28xx_button *button;\n\n\t\t\tbutton = &dev->board.buttons[j];\n\n\t\t\t \n\t\t\tif (button->reg_r != dev->button_polling_addresses[i]) {\n\t\t\t\tj++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tis_pressed = regval & button->mask;\n\t\t\twas_pressed = dev->button_polling_last_values[i]\n\t\t\t\t       & button->mask;\n\t\t\tif (button->inverted) {\n\t\t\t\tis_pressed = !is_pressed;\n\t\t\t\twas_pressed = !was_pressed;\n\t\t\t}\n\t\t\t \n\t\t\tif (is_pressed && button->reg_clearing)\n\t\t\t\tem28xx_write_reg(dev, button->reg_clearing,\n\t\t\t\t\t\t (~regval & button->mask)\n\t\t\t\t\t\t    | (regval & ~button->mask));\n\t\t\t \n\t\t\tif (!is_pressed || was_pressed) {\n\t\t\t\tj++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (button->role) {\n\t\t\tcase EM28XX_BUTTON_SNAPSHOT:\n\t\t\t\t \n\t\t\t\tinput_report_key(dev->sbutton_input_dev,\n\t\t\t\t\t\t EM28XX_SNAPSHOT_KEY, 1);\n\t\t\t\t \n\t\t\t\tinput_report_key(dev->sbutton_input_dev,\n\t\t\t\t\t\t EM28XX_SNAPSHOT_KEY, 0);\n\t\t\t\tbreak;\n\t\t\tcase EM28XX_BUTTON_ILLUMINATION:\n\t\t\t\tled = em28xx_find_led(dev,\n\t\t\t\t\t\t      EM28XX_LED_ILLUMINATION);\n\t\t\t\t \n\t\t\t\tif (led)\n\t\t\t\t\tem28xx_toggle_reg_bits(dev,\n\t\t\t\t\t\t\t       led->gpio_reg,\n\t\t\t\t\t\t\t       led->gpio_mask);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ONCE(1, \"BUG: unhandled button role.\");\n\t\t\t}\n\t\t\t \n\t\t\tj++;\n\t\t}\n\t\t \n\t\tdev->button_polling_last_values[i] = regval;\n\t}\n\t \n\tschedule_delayed_work(&dev->buttons_query_work,\n\t\t\t      msecs_to_jiffies(dev->button_polling_interval));\n}\n\nstatic int em28xx_register_snapshot_button(struct em28xx *dev)\n{\n\tstruct usb_device *udev = interface_to_usbdev(dev->intf);\n\tstruct input_dev *input_dev;\n\tint err;\n\n\tdev_info(&dev->intf->dev, \"Registering snapshot button...\\n\");\n\tinput_dev = input_allocate_device();\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tusb_make_path(udev, dev->snapshot_button_path,\n\t\t      sizeof(dev->snapshot_button_path));\n\tstrlcat(dev->snapshot_button_path, \"/sbutton\",\n\t\tsizeof(dev->snapshot_button_path));\n\n\tinput_dev->name = \"em28xx snapshot button\";\n\tinput_dev->phys = dev->snapshot_button_path;\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);\n\tset_bit(EM28XX_SNAPSHOT_KEY, input_dev->keybit);\n\tinput_dev->keycodesize = 0;\n\tinput_dev->keycodemax = 0;\n\tusb_to_input_id(udev, &input_dev->id);\n\tinput_dev->dev.parent = &dev->intf->dev;\n\n\terr = input_register_device(input_dev);\n\tif (err) {\n\t\tdev_err(&dev->intf->dev, \"input_register_device failed\\n\");\n\t\tinput_free_device(input_dev);\n\t\treturn err;\n\t}\n\n\tdev->sbutton_input_dev = input_dev;\n\treturn 0;\n}\n\nstatic void em28xx_init_buttons(struct em28xx *dev)\n{\n\tu8  i = 0, j = 0;\n\tbool addr_new = false;\n\n\tdev->button_polling_interval = EM28XX_BUTTONS_DEBOUNCED_QUERY_INTERVAL;\n\twhile (dev->board.buttons[i].role >= 0 &&\n\t       dev->board.buttons[i].role < EM28XX_NUM_BUTTON_ROLES) {\n\t\tconst struct em28xx_button *button = &dev->board.buttons[i];\n\n\t\t \n\t\taddr_new = true;\n\t\tfor (j = 0; j < dev->num_button_polling_addresses; j++) {\n\t\t\tif (button->reg_r == dev->button_polling_addresses[j]) {\n\t\t\t\taddr_new = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (addr_new && dev->num_button_polling_addresses\n\t\t\t\t\t   >= EM28XX_NUM_BUTTON_ADDRESSES_MAX) {\n\t\t\tWARN_ONCE(1, \"BUG: maximum number of button polling addresses exceeded.\");\n\t\t\tgoto next_button;\n\t\t}\n\t\t \n\t\tif (button->role == EM28XX_BUTTON_SNAPSHOT) {\n\t\t\t \n\t\t\tif (em28xx_register_snapshot_button(dev) < 0)\n\t\t\t\tgoto next_button;\n\t\t} else if (button->role == EM28XX_BUTTON_ILLUMINATION) {\n\t\t\t \n\t\t\tif (!em28xx_find_led(dev, EM28XX_LED_ILLUMINATION)) {\n\t\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\t\"BUG: illumination button defined, but no illumination LED.\\n\");\n\t\t\t\tgoto next_button;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (addr_new) {\n\t\t\tunsigned int index = dev->num_button_polling_addresses;\n\n\t\t\tdev->button_polling_addresses[index] = button->reg_r;\n\t\t\tdev->num_button_polling_addresses++;\n\t\t}\n\t\t \n\t\tif (!button->reg_clearing)\n\t\t\tdev->button_polling_interval =\n\t\t\t\t\t EM28XX_BUTTONS_VOLATILE_QUERY_INTERVAL;\nnext_button:\n\t\t \n\t\ti++;\n\t}\n\n\t \n\tif (dev->num_button_polling_addresses) {\n\t\tmemset(dev->button_polling_last_values, 0,\n\t\t       EM28XX_NUM_BUTTON_ADDRESSES_MAX);\n\t\tschedule_delayed_work(&dev->buttons_query_work,\n\t\t\t\t      msecs_to_jiffies(dev->button_polling_interval));\n\t}\n}\n\nstatic void em28xx_shutdown_buttons(struct em28xx *dev)\n{\n\t \n\tcancel_delayed_work_sync(&dev->buttons_query_work);\n\t \n\tdev->num_button_polling_addresses = 0;\n\t \n\tif (dev->sbutton_input_dev) {\n\t\tdev_info(&dev->intf->dev, \"Deregistering snapshot button\\n\");\n\t\tinput_unregister_device(dev->sbutton_input_dev);\n\t\tdev->sbutton_input_dev = NULL;\n\t}\n}\n\nstatic int em28xx_ir_init(struct em28xx *dev)\n{\n\tstruct usb_device *udev = interface_to_usbdev(dev->intf);\n\tstruct em28xx_IR *ir;\n\tstruct rc_dev *rc;\n\tint err = -ENOMEM;\n\tu64 rc_proto;\n\tu16 i2c_rc_dev_addr = 0;\n\n\tif (dev->is_audio_only) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tkref_get(&dev->ref);\n\tINIT_DELAYED_WORK(&dev->buttons_query_work, em28xx_query_buttons);\n\n\tif (dev->board.buttons)\n\t\tem28xx_init_buttons(dev);\n\n\tif (dev->board.has_ir_i2c) {\n\t\ti2c_rc_dev_addr = em28xx_probe_i2c_ir(dev);\n\t\tif (!i2c_rc_dev_addr) {\n\t\t\tdev->board.has_ir_i2c = 0;\n\t\t\tdev_warn(&dev->intf->dev,\n\t\t\t\t \"No i2c IR remote control device found.\\n\");\n\t\t\terr = -ENODEV;\n\t\t\tgoto ref_put;\n\t\t}\n\t}\n\n\tif (!dev->board.ir_codes && !dev->board.has_ir_i2c) {\n\t\t \n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"Remote control support is not available for this card.\\n\");\n\t\treturn 0;\n\t}\n\n\tdev_info(&dev->intf->dev, \"Registering input extension\\n\");\n\n\tir = kzalloc(sizeof(*ir), GFP_KERNEL);\n\tif (!ir)\n\t\tgoto ref_put;\n\trc = rc_allocate_device(RC_DRIVER_SCANCODE);\n\tif (!rc)\n\t\tgoto error;\n\n\t \n\tir->dev = dev;\n\tdev->ir = ir;\n\tir->rc = rc;\n\n\trc->priv = ir;\n\trc->open = em28xx_ir_start;\n\trc->close = em28xx_ir_stop;\n\n\tif (dev->board.has_ir_i2c) {\t \n\t\tswitch (dev->model) {\n\t\tcase EM2800_BOARD_TERRATEC_CINERGY_200:\n\t\tcase EM2820_BOARD_TERRATEC_CINERGY_250:\n\t\t\trc->map_name = RC_MAP_EM_TERRATEC;\n\t\t\tir->get_key_i2c = em28xx_get_key_terratec;\n\t\t\tbreak;\n\t\tcase EM2820_BOARD_PINNACLE_USB_2:\n\t\t\trc->map_name = RC_MAP_PINNACLE_GREY;\n\t\t\tir->get_key_i2c = em28xx_get_key_pinnacle_usb_grey;\n\t\t\tbreak;\n\t\tcase EM2820_BOARD_HAUPPAUGE_WINTV_USB_2:\n\t\t\trc->map_name = RC_MAP_HAUPPAUGE;\n\t\t\tir->get_key_i2c = em28xx_get_key_em_haup;\n\t\t\trc->allowed_protocols = RC_PROTO_BIT_RC5;\n\t\t\tbreak;\n\t\tcase EM2820_BOARD_LEADTEK_WINFAST_USBII_DELUXE:\n\t\t\trc->map_name = RC_MAP_WINFAST_USBII_DELUXE;\n\t\t\tir->get_key_i2c = em28xx_get_key_winfast_usbii_deluxe;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -ENODEV;\n\t\t\tgoto error;\n\t\t}\n\n\t\tir->i2c_client = kzalloc(sizeof(*ir->i2c_client), GFP_KERNEL);\n\t\tif (!ir->i2c_client)\n\t\t\tgoto error;\n\t\tir->i2c_client->adapter = &ir->dev->i2c_adap[dev->def_i2c_bus];\n\t\tir->i2c_client->addr = i2c_rc_dev_addr;\n\t\tir->i2c_client->flags = 0;\n\t\t \n\t} else {\t \n\t\tswitch (dev->chip_id) {\n\t\tcase CHIP_ID_EM2860:\n\t\tcase CHIP_ID_EM2883:\n\t\t\trc->allowed_protocols = RC_PROTO_BIT_RC5 |\n\t\t\t\t\t\tRC_PROTO_BIT_NEC;\n\t\t\tir->get_key = default_polling_getkey;\n\t\t\tbreak;\n\t\tcase CHIP_ID_EM2884:\n\t\tcase CHIP_ID_EM2874:\n\t\tcase CHIP_ID_EM28174:\n\t\tcase CHIP_ID_EM28178:\n\t\t\tir->get_key = em2874_polling_getkey;\n\t\t\trc->allowed_protocols = RC_PROTO_BIT_RC5 |\n\t\t\t\tRC_PROTO_BIT_NEC | RC_PROTO_BIT_NECX |\n\t\t\t\tRC_PROTO_BIT_NEC32 | RC_PROTO_BIT_RC6_0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -ENODEV;\n\t\t\tgoto error;\n\t\t}\n\n\t\trc->change_protocol = em28xx_ir_change_protocol;\n\t\trc->map_name = dev->board.ir_codes;\n\n\t\t \n\t\trc_proto = RC_PROTO_BIT_UNKNOWN;\n\t\terr = em28xx_ir_change_protocol(rc, &rc_proto);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\n\t \n\tir->polling = 100;  \n\n\tusb_make_path(udev, ir->phys, sizeof(ir->phys));\n\tstrlcat(ir->phys, \"/input0\", sizeof(ir->phys));\n\n\trc->device_name = em28xx_boards[dev->model].name;\n\trc->input_phys = ir->phys;\n\tusb_to_input_id(udev, &rc->input_id);\n\trc->dev.parent = &dev->intf->dev;\n\trc->driver_name = MODULE_NAME;\n\n\t \n\terr = rc_register_device(rc);\n\tif (err)\n\t\tgoto error;\n\n\tdev_info(&dev->intf->dev, \"Input extension successfully initialized\\n\");\n\n\treturn 0;\n\nerror:\n\tkfree(ir->i2c_client);\n\tdev->ir = NULL;\n\trc_free_device(rc);\n\tkfree(ir);\nref_put:\n\tem28xx_shutdown_buttons(dev);\n\treturn err;\n}\n\nstatic int em28xx_ir_fini(struct em28xx *dev)\n{\n\tstruct em28xx_IR *ir = dev->ir;\n\n\tif (dev->is_audio_only) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tdev_info(&dev->intf->dev, \"Closing input extension\\n\");\n\n\tem28xx_shutdown_buttons(dev);\n\n\t \n\tif (!ir)\n\t\tgoto ref_put;\n\n\trc_unregister_device(ir->rc);\n\n\tkfree(ir->i2c_client);\n\n\t \n\tkfree(ir);\n\tdev->ir = NULL;\n\nref_put:\n\tkref_put(&dev->ref, em28xx_free_device);\n\n\treturn 0;\n}\n\nstatic int em28xx_ir_suspend(struct em28xx *dev)\n{\n\tstruct em28xx_IR *ir = dev->ir;\n\n\tif (dev->is_audio_only)\n\t\treturn 0;\n\n\tdev_info(&dev->intf->dev, \"Suspending input extension\\n\");\n\tif (ir)\n\t\tcancel_delayed_work_sync(&ir->work);\n\tcancel_delayed_work_sync(&dev->buttons_query_work);\n\t \n\treturn 0;\n}\n\nstatic int em28xx_ir_resume(struct em28xx *dev)\n{\n\tstruct em28xx_IR *ir = dev->ir;\n\n\tif (dev->is_audio_only)\n\t\treturn 0;\n\n\tdev_info(&dev->intf->dev, \"Resuming input extension\\n\");\n\t \n\tif (ir)\n\t\tschedule_delayed_work(&ir->work, msecs_to_jiffies(ir->polling));\n\tif (dev->num_button_polling_addresses)\n\t\tschedule_delayed_work(&dev->buttons_query_work,\n\t\t\t\t      msecs_to_jiffies(dev->button_polling_interval));\n\treturn 0;\n}\n\nstatic struct em28xx_ops rc_ops = {\n\t.id   = EM28XX_RC,\n\t.name = \"Em28xx Input Extension\",\n\t.init = em28xx_ir_init,\n\t.fini = em28xx_ir_fini,\n\t.suspend = em28xx_ir_suspend,\n\t.resume = em28xx_ir_resume,\n};\n\nstatic int __init em28xx_rc_register(void)\n{\n\treturn em28xx_register_extension(&rc_ops);\n}\n\nstatic void __exit em28xx_rc_unregister(void)\n{\n\tem28xx_unregister_extension(&rc_ops);\n}\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab\");\nMODULE_DESCRIPTION(DRIVER_DESC \" - input interface\");\nMODULE_VERSION(EM28XX_VERSION);\n\nmodule_init(em28xx_rc_register);\nmodule_exit(em28xx_rc_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}