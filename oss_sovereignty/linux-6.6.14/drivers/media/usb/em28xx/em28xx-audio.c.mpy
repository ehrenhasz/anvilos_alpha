{
  "module_name": "em28xx-audio.c",
  "hash_id": "d1517b29e0bb5b1d1b1623cbd9c48268728eebd3c35826fc85797c26297f66d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/em28xx/em28xx-audio.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"em28xx.h\"\n\n#include <linux/kernel.h>\n#include <linux/usb.h>\n#include <linux/init.h>\n#include <linux/sound.h>\n#include <linux/spinlock.h>\n#include <linux/soundcard.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/info.h>\n#include <sound/initval.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n#include <sound/ac97_codec.h>\n#include <media/v4l2-common.h>\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"activates debug info\");\n\n#define EM28XX_MAX_AUDIO_BUFS\t\t5\n#define EM28XX_MIN_AUDIO_PACKETS\t64\n\n#define dprintk(fmt, arg...) do {\t\t\t\t\t\\\n\tif (debug)\t\t\t\t\t\t\\\n\t\tdev_printk(KERN_DEBUG, &dev->intf->dev,\t\t\t\\\n\t\t\t   \"video: %s: \" fmt, __func__, ## arg);\t\\\n} while (0)\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\n\nstatic int em28xx_deinit_isoc_audio(struct em28xx *dev)\n{\n\tint i;\n\n\tdprintk(\"Stopping isoc\\n\");\n\tfor (i = 0; i < dev->adev.num_urb; i++) {\n\t\tstruct urb *urb = dev->adev.urb[i];\n\n\t\tif (!irqs_disabled())\n\t\t\tusb_kill_urb(urb);\n\t\telse\n\t\t\tusb_unlink_urb(urb);\n\t}\n\n\treturn 0;\n}\n\nstatic void em28xx_audio_isocirq(struct urb *urb)\n{\n\tstruct em28xx            *dev = urb->context;\n\tint                      i;\n\tunsigned int             oldptr;\n\tint                      period_elapsed = 0;\n\tint                      status;\n\tunsigned char            *cp;\n\tunsigned int             stride;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime   *runtime;\n\n\tif (dev->disconnected) {\n\t\tdprintk(\"device disconnected while streaming. URB status=%d.\\n\",\n\t\t\turb->status);\n\t\tatomic_set(&dev->adev.stream_started, 0);\n\t\treturn;\n\t}\n\n\tswitch (urb->status) {\n\tcase 0:              \n\tcase -ETIMEDOUT:     \n\t\tbreak;\n\tcase -ECONNRESET:    \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:             \n\t\tdprintk(\"urb completion error %d.\\n\", urb->status);\n\t\tbreak;\n\t}\n\n\tif (atomic_read(&dev->adev.stream_started) == 0)\n\t\treturn;\n\n\tif (dev->adev.capture_pcm_substream) {\n\t\tsubstream = dev->adev.capture_pcm_substream;\n\t\truntime = substream->runtime;\n\t\tstride = runtime->frame_bits >> 3;\n\n\t\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\t\tunsigned long flags;\n\t\t\tint length =\n\t\t\t    urb->iso_frame_desc[i].actual_length / stride;\n\t\t\tcp = (unsigned char *)urb->transfer_buffer +\n\t\t\t    urb->iso_frame_desc[i].offset;\n\n\t\t\tif (!length)\n\t\t\t\tcontinue;\n\n\t\t\toldptr = dev->adev.hwptr_done_capture;\n\t\t\tif (oldptr + length >= runtime->buffer_size) {\n\t\t\t\tunsigned int cnt =\n\t\t\t\t    runtime->buffer_size - oldptr;\n\t\t\t\tmemcpy(runtime->dma_area + oldptr * stride, cp,\n\t\t\t\t       cnt * stride);\n\t\t\t\tmemcpy(runtime->dma_area, cp + cnt * stride,\n\t\t\t\t       length * stride - cnt * stride);\n\t\t\t} else {\n\t\t\t\tmemcpy(runtime->dma_area + oldptr * stride, cp,\n\t\t\t\t       length * stride);\n\t\t\t}\n\n\t\t\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\n\t\t\tdev->adev.hwptr_done_capture += length;\n\t\t\tif (dev->adev.hwptr_done_capture >=\n\t\t\t    runtime->buffer_size)\n\t\t\t\tdev->adev.hwptr_done_capture -=\n\t\t\t\t    runtime->buffer_size;\n\n\t\t\tdev->adev.capture_transfer_done += length;\n\t\t\tif (dev->adev.capture_transfer_done >=\n\t\t\t    runtime->period_size) {\n\t\t\t\tdev->adev.capture_transfer_done -=\n\t\t\t\t    runtime->period_size;\n\t\t\t\tperiod_elapsed = 1;\n\t\t\t}\n\n\t\t\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\t\t}\n\t\tif (period_elapsed)\n\t\t\tsnd_pcm_period_elapsed(substream);\n\t}\n\turb->status = 0;\n\n\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (status < 0)\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"resubmit of audio urb failed (error=%i)\\n\",\n\t\t\tstatus);\n}\n\nstatic int em28xx_init_audio_isoc(struct em28xx *dev)\n{\n\tint       i, err;\n\n\tdprintk(\"Starting isoc transfers\\n\");\n\n\t \n\tfor (i = 0; i < dev->adev.num_urb; i++) {\n\t\tmemset(dev->adev.transfer_buffer[i], 0x80,\n\t\t       dev->adev.urb[i]->transfer_buffer_length);\n\n\t\terr = usb_submit_urb(dev->adev.urb[i], GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"submit of audio urb failed (error=%i)\\n\",\n\t\t\t\terr);\n\t\t\tem28xx_deinit_isoc_audio(dev);\n\t\t\tatomic_set(&dev->adev.stream_started, 0);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_pcm_hardware snd_em28xx_hw_capture = {\n\t.info = SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_MMAP           |\n\t\tSNDRV_PCM_INFO_INTERLEAVED    |\n\t\tSNDRV_PCM_INFO_BATCH\t      |\n\t\tSNDRV_PCM_INFO_MMAP_VALID,\n\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\n\t.rates = SNDRV_PCM_RATE_48000,\n\n\t.rate_min = 48000,\n\t.rate_max = 48000,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.buffer_bytes_max = 62720 * 8,\t \n\n\t \n\t.period_bytes_min = 11059,\n\t.period_bytes_max = 13516,\n\n\t.periods_min = 2,\n\t.periods_max = 98,\t\t \n};\n\nstatic int snd_em28xx_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct em28xx *dev = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint nonblock, ret = 0;\n\n\tif (!dev) {\n\t\tpr_err(\"em28xx-audio: BUG: em28xx can't find device struct. Can't proceed with open\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (dev->disconnected)\n\t\treturn -ENODEV;\n\n\tdprintk(\"opening device and trying to acquire exclusive lock\\n\");\n\n\tnonblock = !!(substream->f_flags & O_NONBLOCK);\n\tif (nonblock) {\n\t\tif (!mutex_trylock(&dev->lock))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tmutex_lock(&dev->lock);\n\t}\n\n\truntime->hw = snd_em28xx_hw_capture;\n\n\tif (dev->adev.users == 0) {\n\t\tif (!dev->alt || dev->is_audio_only) {\n\t\t\tstruct usb_device *udev;\n\n\t\t\tudev = interface_to_usbdev(dev->intf);\n\n\t\t\tif (dev->is_audio_only)\n\t\t\t\t \n\t\t\t\tdev->alt = 1;\n\t\t\telse\n\t\t\t\t \n\t\t\t\tdev->alt = 7;\n\t\t\t\t \n\t\t\tdprintk(\"changing alternate number on interface %d to %d\\n\",\n\t\t\t\tdev->ifnum, dev->alt);\n\t\t\tusb_set_interface(udev, dev->ifnum, dev->alt);\n\t\t}\n\n\t\t \n\t\tdev->mute = 0;\n\t\tret = em28xx_audio_analog_set(dev);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tkref_get(&dev->ref);\n\tdev->adev.users++;\n\tmutex_unlock(&dev->lock);\n\n\t \n\tsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\n\t\t\t\t     dev->adev.period * 95 / 100,\n\t\t\t\t     dev->adev.period * 105 / 100);\n\n\tdev->adev.capture_pcm_substream = substream;\n\n\treturn 0;\nerr:\n\tmutex_unlock(&dev->lock);\n\n\tdev_err(&dev->intf->dev,\n\t\t\"Error while configuring em28xx mixer\\n\");\n\treturn ret;\n}\n\nstatic int snd_em28xx_pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct em28xx *dev = snd_pcm_substream_chip(substream);\n\n\tdprintk(\"closing device\\n\");\n\n\tdev->mute = 1;\n\tmutex_lock(&dev->lock);\n\tdev->adev.users--;\n\tif (atomic_read(&dev->adev.stream_started) > 0) {\n\t\tatomic_set(&dev->adev.stream_started, 0);\n\t\tschedule_work(&dev->adev.wq_trigger);\n\t}\n\n\tem28xx_audio_analog_set(dev);\n\tmutex_unlock(&dev->lock);\n\tkref_put(&dev->ref, em28xx_free_device);\n\n\treturn 0;\n}\n\nstatic int snd_em28xx_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct em28xx *dev = snd_pcm_substream_chip(substream);\n\n\tif (dev->disconnected)\n\t\treturn -ENODEV;\n\n\tdev->adev.hwptr_done_capture = 0;\n\tdev->adev.capture_transfer_done = 0;\n\n\treturn 0;\n}\n\nstatic void audio_trigger(struct work_struct *work)\n{\n\tstruct em28xx_audio *adev =\n\t\t\t    container_of(work, struct em28xx_audio, wq_trigger);\n\tstruct em28xx *dev = container_of(adev, struct em28xx, adev);\n\n\tif (atomic_read(&adev->stream_started)) {\n\t\tdprintk(\"starting capture\");\n\t\tem28xx_init_audio_isoc(dev);\n\t} else {\n\t\tdprintk(\"stopping capture\");\n\t\tem28xx_deinit_isoc_audio(dev);\n\t}\n}\n\nstatic int snd_em28xx_capture_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t      int cmd)\n{\n\tstruct em28xx *dev = snd_pcm_substream_chip(substream);\n\tint retval = 0;\n\n\tif (dev->disconnected)\n\t\treturn -ENODEV;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tatomic_set(&dev->adev.stream_started, 1);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tatomic_set(&dev->adev.stream_started, 0);\n\t\tbreak;\n\tdefault:\n\t\tretval = -EINVAL;\n\t}\n\tschedule_work(&dev->adev.wq_trigger);\n\treturn retval;\n}\n\nstatic snd_pcm_uframes_t snd_em28xx_capture_pointer(struct snd_pcm_substream\n\t\t\t\t\t\t    *substream)\n{\n\tunsigned long flags;\n\tstruct em28xx *dev;\n\tsnd_pcm_uframes_t hwptr_done;\n\n\tdev = snd_pcm_substream_chip(substream);\n\tif (dev->disconnected)\n\t\treturn SNDRV_PCM_POS_XRUN;\n\n\tspin_lock_irqsave(&dev->adev.slock, flags);\n\thwptr_done = dev->adev.hwptr_done_capture;\n\tspin_unlock_irqrestore(&dev->adev.slock, flags);\n\n\treturn hwptr_done;\n}\n\n \nstatic int em28xx_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_info *info)\n{\n\tstruct em28xx *dev = snd_kcontrol_chip(kcontrol);\n\n\tif (dev->disconnected)\n\t\treturn -ENODEV;\n\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tinfo->count = 2;\n\tinfo->value.integer.min = 0;\n\tinfo->value.integer.max = 0x1f;\n\n\treturn 0;\n}\n\nstatic int em28xx_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *value)\n{\n\tstruct em28xx *dev = snd_kcontrol_chip(kcontrol);\n\tstruct snd_pcm_substream *substream = dev->adev.capture_pcm_substream;\n\tu16 val = (0x1f - (value->value.integer.value[0] & 0x1f)) |\n\t\t  (0x1f - (value->value.integer.value[1] & 0x1f)) << 8;\n\tint nonblock = 0;\n\tint rc;\n\n\tif (dev->disconnected)\n\t\treturn -ENODEV;\n\n\tif (substream)\n\t\tnonblock = !!(substream->f_flags & O_NONBLOCK);\n\tif (nonblock) {\n\t\tif (!mutex_trylock(&dev->lock))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tmutex_lock(&dev->lock);\n\t}\n\trc = em28xx_read_ac97(dev, kcontrol->private_value);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tval |= rc & 0x8000;\t \n\n\trc = em28xx_write_ac97(dev, kcontrol->private_value, val);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tdprintk(\"%sleft vol %d, right vol %d (0x%04x) to ac97 volume control 0x%04x\\n\",\n\t\t(val & 0x8000) ? \"muted \" : \"\",\n\t\t0x1f - ((val >> 8) & 0x1f), 0x1f - (val & 0x1f),\n\t\tval, (int)kcontrol->private_value);\n\nerr:\n\tmutex_unlock(&dev->lock);\n\treturn rc;\n}\n\nstatic int em28xx_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *value)\n{\n\tstruct em28xx *dev = snd_kcontrol_chip(kcontrol);\n\tstruct snd_pcm_substream *substream = dev->adev.capture_pcm_substream;\n\tint nonblock = 0;\n\tint val;\n\n\tif (dev->disconnected)\n\t\treturn -ENODEV;\n\n\tif (substream)\n\t\tnonblock = !!(substream->f_flags & O_NONBLOCK);\n\tif (nonblock) {\n\t\tif (!mutex_trylock(&dev->lock))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tmutex_lock(&dev->lock);\n\t}\n\tval = em28xx_read_ac97(dev, kcontrol->private_value);\n\tmutex_unlock(&dev->lock);\n\tif (val < 0)\n\t\treturn val;\n\n\tdprintk(\"%sleft vol %d, right vol %d (0x%04x) from ac97 volume control 0x%04x\\n\",\n\t\t(val & 0x8000) ? \"muted \" : \"\",\n\t\t0x1f - ((val >> 8) & 0x1f), 0x1f - (val & 0x1f),\n\t\tval, (int)kcontrol->private_value);\n\n\tvalue->value.integer.value[0] = 0x1f - (val & 0x1f);\n\tvalue->value.integer.value[1] = 0x1f - ((val >> 8) & 0x1f);\n\n\treturn 0;\n}\n\nstatic int em28xx_vol_put_mute(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct em28xx *dev = snd_kcontrol_chip(kcontrol);\n\tu16 val = value->value.integer.value[0];\n\tstruct snd_pcm_substream *substream = dev->adev.capture_pcm_substream;\n\tint nonblock = 0;\n\tint rc;\n\n\tif (dev->disconnected)\n\t\treturn -ENODEV;\n\n\tif (substream)\n\t\tnonblock = !!(substream->f_flags & O_NONBLOCK);\n\tif (nonblock) {\n\t\tif (!mutex_trylock(&dev->lock))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tmutex_lock(&dev->lock);\n\t}\n\trc = em28xx_read_ac97(dev, kcontrol->private_value);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tif (val)\n\t\trc &= 0x1f1f;\n\telse\n\t\trc |= 0x8000;\n\n\trc = em28xx_write_ac97(dev, kcontrol->private_value, rc);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tdprintk(\"%sleft vol %d, right vol %d (0x%04x) to ac97 volume control 0x%04x\\n\",\n\t\t(val & 0x8000) ? \"muted \" : \"\",\n\t\t0x1f - ((val >> 8) & 0x1f), 0x1f - (val & 0x1f),\n\t\tval, (int)kcontrol->private_value);\n\nerr:\n\tmutex_unlock(&dev->lock);\n\treturn rc;\n}\n\nstatic int em28xx_vol_get_mute(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct em28xx *dev = snd_kcontrol_chip(kcontrol);\n\tstruct snd_pcm_substream *substream = dev->adev.capture_pcm_substream;\n\tint nonblock = 0;\n\tint val;\n\n\tif (dev->disconnected)\n\t\treturn -ENODEV;\n\n\tif (substream)\n\t\tnonblock = !!(substream->f_flags & O_NONBLOCK);\n\tif (nonblock) {\n\t\tif (!mutex_trylock(&dev->lock))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tmutex_lock(&dev->lock);\n\t}\n\tval = em28xx_read_ac97(dev, kcontrol->private_value);\n\tmutex_unlock(&dev->lock);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (val & 0x8000)\n\t\tvalue->value.integer.value[0] = 0;\n\telse\n\t\tvalue->value.integer.value[0] = 1;\n\n\tdprintk(\"%sleft vol %d, right vol %d (0x%04x) from ac97 volume control 0x%04x\\n\",\n\t\t(val & 0x8000) ? \"muted \" : \"\",\n\t\t0x1f - ((val >> 8) & 0x1f), 0x1f - (val & 0x1f),\n\t\tval, (int)kcontrol->private_value);\n\n\treturn 0;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(em28xx_db_scale, -3450, 150, 0);\n\nstatic int em28xx_cvol_new(struct snd_card *card, struct em28xx *dev,\n\t\t\t   char *name, int id)\n{\n\tint err;\n\tchar ctl_name[44];\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_new tmp;\n\n\tmemset(&tmp, 0, sizeof(tmp));\n\ttmp.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\ttmp.private_value = id;\n\ttmp.name  = ctl_name;\n\n\t \n\tsprintf(ctl_name, \"%s Switch\", name);\n\ttmp.get  = em28xx_vol_get_mute;\n\ttmp.put  = em28xx_vol_put_mute;\n\ttmp.info = snd_ctl_boolean_mono_info;\n\tkctl = snd_ctl_new1(&tmp, dev);\n\terr = snd_ctl_add(card, kctl);\n\tif (err < 0)\n\t\treturn err;\n\tdprintk(\"Added control %s for ac97 volume control 0x%04x\\n\",\n\t\tctl_name, id);\n\n\tmemset(&tmp, 0, sizeof(tmp));\n\ttmp.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\ttmp.private_value = id;\n\ttmp.name  = ctl_name;\n\n\t \n\tsprintf(ctl_name, \"%s Volume\", name);\n\ttmp.get   = em28xx_vol_get;\n\ttmp.put   = em28xx_vol_put;\n\ttmp.info  = em28xx_vol_info;\n\ttmp.tlv.p = em28xx_db_scale;\n\tkctl = snd_ctl_new1(&tmp, dev);\n\terr = snd_ctl_add(card, kctl);\n\tif (err < 0)\n\t\treturn err;\n\tdprintk(\"Added control %s for ac97 volume control 0x%04x\\n\",\n\t\tctl_name, id);\n\n\treturn 0;\n}\n\n \nstatic const struct snd_pcm_ops snd_em28xx_pcm_capture = {\n\t.open      = snd_em28xx_capture_open,\n\t.close     = snd_em28xx_pcm_close,\n\t.prepare   = snd_em28xx_prepare,\n\t.trigger   = snd_em28xx_capture_trigger,\n\t.pointer   = snd_em28xx_capture_pointer,\n};\n\nstatic void em28xx_audio_free_urb(struct em28xx *dev)\n{\n\tstruct usb_device *udev = interface_to_usbdev(dev->intf);\n\tint i;\n\n\tfor (i = 0; i < dev->adev.num_urb; i++) {\n\t\tstruct urb *urb = dev->adev.urb[i];\n\n\t\tif (!urb)\n\t\t\tcontinue;\n\n\t\tusb_free_coherent(udev, urb->transfer_buffer_length,\n\t\t\t\t  dev->adev.transfer_buffer[i],\n\t\t\t\t  urb->transfer_dma);\n\n\t\tusb_free_urb(urb);\n\t}\n\tkfree(dev->adev.urb);\n\tkfree(dev->adev.transfer_buffer);\n\tdev->adev.num_urb = 0;\n}\n\n \nstatic int em28xx_audio_ep_packet_size(struct usb_device *udev,\n\t\t\t\t       struct usb_endpoint_descriptor *e)\n{\n\tint size = le16_to_cpu(e->wMaxPacketSize);\n\n\tif (udev->speed == USB_SPEED_HIGH)\n\t\treturn (size & 0x7ff) *  (1 + (((size) >> 11) & 0x03));\n\n\treturn size & 0x7ff;\n}\n\nstatic int em28xx_audio_urb_init(struct em28xx *dev)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_endpoint_descriptor *e, *ep = NULL;\n\tstruct usb_device *udev = interface_to_usbdev(dev->intf);\n\tint                 i, ep_size, interval, num_urb, npackets;\n\tint\t\t    urb_size, bytes_per_transfer;\n\tu8 alt;\n\n\tif (dev->ifnum)\n\t\talt = 1;\n\telse\n\t\talt = 7;\n\n\tintf = usb_ifnum_to_if(udev, dev->ifnum);\n\n\tif (intf->num_altsetting <= alt) {\n\t\tdev_err(&dev->intf->dev, \"alt %d doesn't exist on interface %d\\n\",\n\t\t\tdev->ifnum, alt);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < intf->altsetting[alt].desc.bNumEndpoints; i++) {\n\t\te = &intf->altsetting[alt].endpoint[i].desc;\n\t\tif (!usb_endpoint_dir_in(e))\n\t\t\tcontinue;\n\t\tif (e->bEndpointAddress == EM28XX_EP_AUDIO) {\n\t\t\tep = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ep) {\n\t\tdev_err(&dev->intf->dev, \"Couldn't find an audio endpoint\");\n\t\treturn -ENODEV;\n\t}\n\n\tep_size = em28xx_audio_ep_packet_size(udev, ep);\n\tinterval = 1 << (ep->bInterval - 1);\n\n\tdev_info(&dev->intf->dev,\n\t\t \"Endpoint 0x%02x %s on intf %d alt %d interval = %d, size %d\\n\",\n\t\t EM28XX_EP_AUDIO, usb_speed_string(udev->speed),\n\t\t dev->ifnum, alt, interval, ep_size);\n\n\t \n\n\t \n\tbytes_per_transfer = DIV_ROUND_UP(48000 * 2 * 2, 125 * interval);\n\n\t \n\tnum_urb = DIV_ROUND_UP(bytes_per_transfer, ep_size);\n\tif (num_urb > EM28XX_MAX_AUDIO_BUFS)\n\t\tnum_urb = EM28XX_MAX_AUDIO_BUFS;\n\n\t \n\turb_size = bytes_per_transfer / num_urb;\n\n\t \n\tnpackets = EM28XX_MIN_AUDIO_PACKETS;\n\tif (urb_size > ep_size * npackets)\n\t\tnpackets = DIV_ROUND_UP(urb_size, ep_size);\n\n\tdev_info(&dev->intf->dev,\n\t\t \"Number of URBs: %d, with %d packets and %d size\\n\",\n\t\t num_urb, npackets, urb_size);\n\n\t \n\tdev->adev.period = urb_size * npackets;\n\n\t \n\n\tdev->adev.transfer_buffer = kcalloc(num_urb,\n\t\t\t\t\t    sizeof(*dev->adev.transfer_buffer),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!dev->adev.transfer_buffer)\n\t\treturn -ENOMEM;\n\n\tdev->adev.urb = kcalloc(num_urb, sizeof(*dev->adev.urb), GFP_KERNEL);\n\tif (!dev->adev.urb) {\n\t\tkfree(dev->adev.transfer_buffer);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tdev->adev.num_urb = num_urb;\n\tfor (i = 0; i < num_urb; i++) {\n\t\tstruct urb *urb;\n\t\tint j, k;\n\t\tvoid *buf;\n\n\t\turb = usb_alloc_urb(npackets, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\tem28xx_audio_free_urb(dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdev->adev.urb[i] = urb;\n\n\t\tbuf = usb_alloc_coherent(udev, npackets * ep_size, GFP_KERNEL,\n\t\t\t\t\t &urb->transfer_dma);\n\t\tif (!buf) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"usb_alloc_coherent failed!\\n\");\n\t\t\tem28xx_audio_free_urb(dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdev->adev.transfer_buffer[i] = buf;\n\n\t\turb->dev = udev;\n\t\turb->context = dev;\n\t\turb->pipe = usb_rcvisocpipe(udev, EM28XX_EP_AUDIO);\n\t\turb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\n\t\turb->transfer_buffer = buf;\n\t\turb->interval = interval;\n\t\turb->complete = em28xx_audio_isocirq;\n\t\turb->number_of_packets = npackets;\n\t\turb->transfer_buffer_length = ep_size * npackets;\n\n\t\tfor (j = k = 0; j < npackets; j++, k += ep_size) {\n\t\t\turb->iso_frame_desc[j].offset = k;\n\t\t\turb->iso_frame_desc[j].length = ep_size;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int em28xx_audio_init(struct em28xx *dev)\n{\n\tstruct em28xx_audio *adev = &dev->adev;\n\tstruct usb_device *udev = interface_to_usbdev(dev->intf);\n\tstruct snd_pcm      *pcm;\n\tstruct snd_card     *card;\n\tstatic int          devnr;\n\tint\t\t    err;\n\n\tif (dev->usb_audio_type != EM28XX_USB_AUDIO_VENDOR) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tdev_info(&dev->intf->dev, \"Binding audio extension\\n\");\n\n\tkref_get(&dev->ref);\n\n\tdev_info(&dev->intf->dev,\n\t\t \"em28xx-audio.c: Copyright (C) 2006 Markus Rechberger\\n\");\n\tdev_info(&dev->intf->dev,\n\t\t \"em28xx-audio.c: Copyright (C) 2007-2016 Mauro Carvalho Chehab\\n\");\n\n\terr = snd_card_new(&dev->intf->dev, index[devnr], \"Em28xx Audio\",\n\t\t\t   THIS_MODULE, 0, &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tspin_lock_init(&adev->slock);\n\tadev->sndcard = card;\n\tadev->udev = udev;\n\n\terr = snd_pcm_new(card, \"Em28xx Audio\", 0, 0, 1, &pcm);\n\tif (err < 0)\n\t\tgoto card_free;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_em28xx_pcm_capture);\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC, NULL, 0, 0);\n\tpcm->info_flags = 0;\n\tpcm->private_data = dev;\n\tstrscpy(pcm->name, \"Empia 28xx Capture\", sizeof(pcm->name));\n\n\tstrscpy(card->driver, \"Em28xx-Audio\", sizeof(card->driver));\n\tstrscpy(card->shortname, \"Em28xx Audio\", sizeof(card->shortname));\n\tstrscpy(card->longname, \"Empia Em28xx Audio\", sizeof(card->longname));\n\n\tINIT_WORK(&adev->wq_trigger, audio_trigger);\n\n\tif (dev->audio_mode.ac97 != EM28XX_NO_AC97) {\n\t\tem28xx_cvol_new(card, dev, \"Video\", AC97_VIDEO);\n\t\tem28xx_cvol_new(card, dev, \"Line In\", AC97_LINE);\n\t\tem28xx_cvol_new(card, dev, \"Phone\", AC97_PHONE);\n\t\tem28xx_cvol_new(card, dev, \"Microphone\", AC97_MIC);\n\t\tem28xx_cvol_new(card, dev, \"CD\", AC97_CD);\n\t\tem28xx_cvol_new(card, dev, \"AUX\", AC97_AUX);\n\t\tem28xx_cvol_new(card, dev, \"PCM\", AC97_PCM);\n\n\t\tem28xx_cvol_new(card, dev, \"Master\", AC97_MASTER);\n\t\tem28xx_cvol_new(card, dev, \"Line\", AC97_HEADPHONE);\n\t\tem28xx_cvol_new(card, dev, \"Mono\", AC97_MASTER_MONO);\n\t\tem28xx_cvol_new(card, dev, \"LFE\", AC97_CENTER_LFE_MASTER);\n\t\tem28xx_cvol_new(card, dev, \"Surround\", AC97_SURROUND_MASTER);\n\t}\n\n\terr = em28xx_audio_urb_init(dev);\n\tif (err)\n\t\tgoto card_free;\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto urb_free;\n\n\tdev_info(&dev->intf->dev, \"Audio extension successfully initialized\\n\");\n\treturn 0;\n\nurb_free:\n\tem28xx_audio_free_urb(dev);\n\ncard_free:\n\tsnd_card_free(card);\n\tadev->sndcard = NULL;\n\n\treturn err;\n}\n\nstatic int em28xx_audio_fini(struct em28xx *dev)\n{\n\tif (!dev)\n\t\treturn 0;\n\n\tif (dev->usb_audio_type != EM28XX_USB_AUDIO_VENDOR) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tdev_info(&dev->intf->dev, \"Closing audio extension\\n\");\n\n\tif (dev->adev.sndcard) {\n\t\tsnd_card_disconnect(dev->adev.sndcard);\n\t\tflush_work(&dev->adev.wq_trigger);\n\n\t\tem28xx_audio_free_urb(dev);\n\n\t\tsnd_card_free(dev->adev.sndcard);\n\t\tdev->adev.sndcard = NULL;\n\t}\n\n\tkref_put(&dev->ref, em28xx_free_device);\n\treturn 0;\n}\n\nstatic int em28xx_audio_suspend(struct em28xx *dev)\n{\n\tif (!dev)\n\t\treturn 0;\n\n\tif (dev->usb_audio_type != EM28XX_USB_AUDIO_VENDOR)\n\t\treturn 0;\n\n\tdev_info(&dev->intf->dev, \"Suspending audio extension\\n\");\n\tem28xx_deinit_isoc_audio(dev);\n\tatomic_set(&dev->adev.stream_started, 0);\n\treturn 0;\n}\n\nstatic int em28xx_audio_resume(struct em28xx *dev)\n{\n\tif (!dev)\n\t\treturn 0;\n\n\tif (dev->usb_audio_type != EM28XX_USB_AUDIO_VENDOR)\n\t\treturn 0;\n\n\tdev_info(&dev->intf->dev, \"Resuming audio extension\\n\");\n\t \n\tschedule_work(&dev->adev.wq_trigger);\n\treturn 0;\n}\n\nstatic struct em28xx_ops audio_ops = {\n\t.id   = EM28XX_AUDIO,\n\t.name = \"Em28xx Audio Extension\",\n\t.init = em28xx_audio_init,\n\t.fini = em28xx_audio_fini,\n\t.suspend = em28xx_audio_suspend,\n\t.resume = em28xx_audio_resume,\n};\n\nstatic int __init em28xx_alsa_register(void)\n{\n\treturn em28xx_register_extension(&audio_ops);\n}\n\nstatic void __exit em28xx_alsa_unregister(void)\n{\n\tem28xx_unregister_extension(&audio_ops);\n}\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Markus Rechberger <mrechberger@gmail.com>\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab\");\nMODULE_DESCRIPTION(DRIVER_DESC \" - audio interface\");\nMODULE_VERSION(EM28XX_VERSION);\n\nmodule_init(em28xx_alsa_register);\nmodule_exit(em28xx_alsa_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}