{
  "module_name": "em28xx-camera.c",
  "hash_id": "7bf3f2274ee170067655fe181c3636e1e967d1d71a487232697dd23468f9da35",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/em28xx/em28xx-camera.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include \"em28xx.h\"\n\n#include <linux/i2c.h>\n#include <linux/usb.h>\n#include <media/i2c/mt9v011.h>\n#include <media/v4l2-common.h>\n\n \nstatic unsigned short micron_sensor_addrs[] = {\n\t0xb8 >> 1,    \n\t0xba >> 1,    \n\t0x90 >> 1,    \n\tI2C_CLIENT_END\n};\n\n \nstatic unsigned short omnivision_sensor_addrs[] = {\n\t0x42 >> 1,    \n\t0x60 >> 1,    \n\tI2C_CLIENT_END\n};\n\n \nstatic int em28xx_initialize_mt9m111(struct em28xx *dev)\n{\n\tint i;\n\tunsigned char regs[][3] = {\n\t\t{ 0x0d, 0x00, 0x01, },   \n\t\t{ 0x0d, 0x00, 0x00, },\n\t\t{ 0x0a, 0x00, 0x21, },\n\t\t{ 0x21, 0x04, 0x00, },   \n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(regs); i++)\n\t\ti2c_master_send(&dev->i2c_client[dev->def_i2c_bus],\n\t\t\t\t&regs[i][0], 3);\n\n\t \n\n\treturn 0;\n}\n\n \nstatic int em28xx_initialize_mt9m001(struct em28xx *dev)\n{\n\tint i;\n\tunsigned char regs[][3] = {\n\t\t{ 0x0d, 0x00, 0x01, },\n\t\t{ 0x0d, 0x00, 0x00, },\n\t\t{ 0x04, 0x05, 0x00, },\t \n\t\t{ 0x03, 0x04, 0x00, },   \n\t\t{ 0x20, 0x11, 0x00, },\n\t\t{ 0x06, 0x00, 0x10, },\n\t\t{ 0x2b, 0x00, 0x24, },\n\t\t{ 0x2e, 0x00, 0x24, },\n\t\t{ 0x35, 0x00, 0x24, },\n\t\t{ 0x2d, 0x00, 0x20, },\n\t\t{ 0x2c, 0x00, 0x20, },\n\t\t{ 0x09, 0x0a, 0xd4, },\n\t\t{ 0x35, 0x00, 0x57, },\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(regs); i++)\n\t\ti2c_master_send(&dev->i2c_client[dev->def_i2c_bus],\n\t\t\t\t&regs[i][0], 3);\n\n\t \n\n\treturn 0;\n}\n\n \nstatic int em28xx_probe_sensor_micron(struct em28xx *dev)\n{\n\tint ret, i;\n\tchar *name;\n\tu16 id;\n\n\tstruct i2c_client *client = &dev->i2c_client[dev->def_i2c_bus];\n\n\tdev->em28xx_sensor = EM28XX_NOSENSOR;\n\tfor (i = 0; micron_sensor_addrs[i] != I2C_CLIENT_END; i++) {\n\t\tclient->addr = micron_sensor_addrs[i];\n\t\t \n\t\tret = i2c_smbus_read_word_data(client, 0x00);  \n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENXIO)\n\t\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\t\"couldn't read from i2c device 0x%02x: error %i\\n\",\n\t\t\t\t       client->addr << 1, ret);\n\t\t\tcontinue;\n\t\t}\n\t\tid = swab16(ret);  \n\t\t \n\t\tret = i2c_smbus_read_word_data(client, 0xff);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"couldn't read from i2c device 0x%02x: error %i\\n\",\n\t\t\t\tclient->addr << 1, ret);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (id != swab16(ret))\n\t\t\tcontinue;\n\t\t \n\t\tswitch (id) {\n\t\tcase 0x1222:\n\t\t\tname = \"MT9V012\";    \n\t\t\tbreak;\n\t\tcase 0x1229:\n\t\t\tname = \"MT9V112\";  \n\t\t\tbreak;\n\t\tcase 0x1433:\n\t\t\tname = \"MT9M011\";  \n\t\t\tbreak;\n\t\tcase 0x143a:     \n\t\t\tname = \"MT9M111\";    \n\t\t\tdev->em28xx_sensor = EM28XX_MT9M111;\n\t\t\tbreak;\n\t\tcase 0x148c:\n\t\t\tname = \"MT9M112\";    \n\t\t\tbreak;\n\t\tcase 0x1511:\n\t\t\tname = \"MT9D011\";    \n\t\t\tbreak;\n\t\tcase 0x8232:\n\t\tcase 0x8243:\t \n\t\t\tname = \"MT9V011\";    \n\t\t\tdev->em28xx_sensor = EM28XX_MT9V011;\n\t\t\tbreak;\n\t\tcase 0x8431:\n\t\t\tname = \"MT9M001\";  \n\t\t\tdev->em28xx_sensor = EM28XX_MT9M001;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(&dev->intf->dev,\n\t\t\t\t \"unknown Micron sensor detected: 0x%04x\\n\",\n\t\t\t\t id);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (dev->em28xx_sensor == EM28XX_NOSENSOR)\n\t\t\tdev_info(&dev->intf->dev,\n\t\t\t\t \"unsupported sensor detected: %s\\n\", name);\n\t\telse\n\t\t\tdev_info(&dev->intf->dev,\n\t\t\t\t \"sensor %s detected\\n\", name);\n\n\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\n \nstatic int em28xx_probe_sensor_omnivision(struct em28xx *dev)\n{\n\tint ret, i;\n\tchar *name;\n\tu8 reg;\n\tu16 id;\n\tstruct i2c_client *client = &dev->i2c_client[dev->def_i2c_bus];\n\n\tdev->em28xx_sensor = EM28XX_NOSENSOR;\n\t \n\tfor (i = 0; omnivision_sensor_addrs[i] != I2C_CLIENT_END; i++) {\n\t\tclient->addr = omnivision_sensor_addrs[i];\n\t\t \n\t\treg = 0x1c;\n\t\tret = i2c_smbus_read_byte_data(client, reg);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENXIO)\n\t\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\t\"couldn't read from i2c device 0x%02x: error %i\\n\",\n\t\t\t\t\tclient->addr << 1, ret);\n\t\t\tcontinue;\n\t\t}\n\t\tid = ret << 8;\n\t\treg = 0x1d;\n\t\tret = i2c_smbus_read_byte_data(client, reg);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"couldn't read from i2c device 0x%02x: error %i\\n\",\n\t\t\t\tclient->addr << 1, ret);\n\t\t\tcontinue;\n\t\t}\n\t\tid += ret;\n\t\t \n\t\tif (id != 0x7fa2)\n\t\t\tcontinue;\n\t\t \n\t\treg = 0x0a;\n\t\tret = i2c_smbus_read_byte_data(client, reg);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"couldn't read from i2c device 0x%02x: error %i\\n\",\n\t\t\t\tclient->addr << 1, ret);\n\t\t\tcontinue;\n\t\t}\n\t\tid = ret << 8;\n\t\treg = 0x0b;\n\t\tret = i2c_smbus_read_byte_data(client, reg);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"couldn't read from i2c device 0x%02x: error %i\\n\",\n\t\t\t\tclient->addr << 1, ret);\n\t\t\tcontinue;\n\t\t}\n\t\tid += ret;\n\t\t \n\t\tswitch (id) {\n\t\tcase 0x2642:\n\t\t\tname = \"OV2640\";\n\t\t\tdev->em28xx_sensor = EM28XX_OV2640;\n\t\t\tbreak;\n\t\tcase 0x7648:\n\t\t\tname = \"OV7648\";\n\t\t\tbreak;\n\t\tcase 0x7660:\n\t\t\tname = \"OV7660\";\n\t\t\tbreak;\n\t\tcase 0x7673:\n\t\t\tname = \"OV7670\";\n\t\t\tbreak;\n\t\tcase 0x7720:\n\t\t\tname = \"OV7720\";\n\t\t\tbreak;\n\t\tcase 0x7721:\n\t\t\tname = \"OV7725\";\n\t\t\tbreak;\n\t\tcase 0x9648:  \n\t\tcase 0x9649:  \n\t\t\tname = \"OV9640\";\n\t\t\tbreak;\n\t\tcase 0x9650:\n\t\tcase 0x9652:  \n\t\t\tname = \"OV9650\";\n\t\t\tbreak;\n\t\tcase 0x9656:  \n\t\tcase 0x9657:  \n\t\t\tname = \"OV9655\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(&dev->intf->dev,\n\t\t\t\t \"unknown OmniVision sensor detected: 0x%04x\\n\",\n\t\t\t\tid);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (dev->em28xx_sensor == EM28XX_NOSENSOR)\n\t\t\tdev_info(&dev->intf->dev,\n\t\t\t\t \"unsupported sensor detected: %s\\n\", name);\n\t\telse\n\t\t\tdev_info(&dev->intf->dev,\n\t\t\t\t \"sensor %s detected\\n\", name);\n\n\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\nint em28xx_detect_sensor(struct em28xx *dev)\n{\n\tint ret;\n\n\tret = em28xx_probe_sensor_micron(dev);\n\n\tif (dev->em28xx_sensor == EM28XX_NOSENSOR && ret < 0)\n\t\tret = em28xx_probe_sensor_omnivision(dev);\n\n\t \n\n\tif (dev->em28xx_sensor == EM28XX_NOSENSOR && ret < 0) {\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"No sensor detected\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nint em28xx_init_camera(struct em28xx *dev)\n{\n\tstruct i2c_client *client = &dev->i2c_client[dev->def_i2c_bus];\n\tstruct i2c_adapter *adap = &dev->i2c_adap[dev->def_i2c_bus];\n\tstruct em28xx_v4l2 *v4l2 = dev->v4l2;\n\n\tswitch (dev->em28xx_sensor) {\n\tcase EM28XX_MT9V011:\n\t{\n\t\tstruct mt9v011_platform_data pdata;\n\t\tstruct i2c_board_info mt9v011_info = {\n\t\t\t.type = \"mt9v011\",\n\t\t\t.addr = client->addr,\n\t\t\t.platform_data = &pdata,\n\t\t};\n\n\t\tv4l2->sensor_xres = 640;\n\t\tv4l2->sensor_yres = 480;\n\n\t\t \n\t\tdev->board.xclk = EM28XX_XCLK_FREQUENCY_4_3MHZ;\n\t\tem28xx_write_reg(dev, EM28XX_R0F_XCLK, dev->board.xclk);\n\t\tv4l2->sensor_xtal = 4300000;\n\t\tpdata.xtal = v4l2->sensor_xtal;\n\t\tif (NULL ==\n\t\t    v4l2_i2c_new_subdev_board(&v4l2->v4l2_dev, adap,\n\t\t\t\t\t      &mt9v011_info, NULL))\n\t\t\treturn -ENODEV;\n\t\tv4l2->vinmode = EM28XX_VINMODE_RGB8_GRBG;\n\t\tv4l2->vinctl = 0x00;\n\n\t\tbreak;\n\t}\n\tcase EM28XX_MT9M001:\n\t\tv4l2->sensor_xres = 1280;\n\t\tv4l2->sensor_yres = 1024;\n\n\t\tem28xx_initialize_mt9m001(dev);\n\n\t\tv4l2->vinmode = EM28XX_VINMODE_RGB8_BGGR;\n\t\tv4l2->vinctl = 0x00;\n\n\t\tbreak;\n\tcase EM28XX_MT9M111:\n\t\tv4l2->sensor_xres = 640;\n\t\tv4l2->sensor_yres = 512;\n\n\t\tdev->board.xclk = EM28XX_XCLK_FREQUENCY_48MHZ;\n\t\tem28xx_write_reg(dev, EM28XX_R0F_XCLK, dev->board.xclk);\n\t\tem28xx_initialize_mt9m111(dev);\n\n\t\tv4l2->vinmode = EM28XX_VINMODE_YUV422_UYVY;\n\t\tv4l2->vinctl = 0x00;\n\n\t\tbreak;\n\tcase EM28XX_OV2640:\n\t{\n\t\tstruct v4l2_subdev *subdev;\n\t\tstruct i2c_board_info ov2640_info = {\n\t\t\t.type = \"ov2640\",\n\t\t\t.flags = I2C_CLIENT_SCCB,\n\t\t\t.addr = client->addr,\n\t\t};\n\t\tstruct v4l2_subdev_format format = {\n\t\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t};\n\n\t\t \n\t\tv4l2->sensor_xres = 640;\n\t\tv4l2->sensor_yres = 480;\n\n\t\tsubdev =\n\t\t     v4l2_i2c_new_subdev_board(&v4l2->v4l2_dev, adap,\n\t\t\t\t\t       &ov2640_info, NULL);\n\t\tif (!subdev)\n\t\t\treturn -ENODEV;\n\n\t\tformat.format.code = MEDIA_BUS_FMT_YUYV8_2X8;\n\t\tformat.format.width = 640;\n\t\tformat.format.height = 480;\n\t\tv4l2_subdev_call(subdev, pad, set_fmt, NULL, &format);\n\n\t\t \n\t\tdev->board.xclk = EM28XX_XCLK_FREQUENCY_24MHZ;\n\t\tem28xx_write_reg(dev, EM28XX_R0F_XCLK, dev->board.xclk);\n\t\tv4l2->vinmode = EM28XX_VINMODE_YUV422_YUYV;\n\t\tv4l2->vinctl = 0x00;\n\n\t\tbreak;\n\t}\n\tcase EM28XX_NOSENSOR:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(em28xx_init_camera);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}