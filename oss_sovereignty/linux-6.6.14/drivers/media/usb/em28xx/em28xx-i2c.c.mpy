{
  "module_name": "em28xx-i2c.c",
  "hash_id": "fd473dc9c18d5c2d74e3e0589eee211c5eede5646d747ba30ee66d062978f09b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/em28xx/em28xx-i2c.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include \"em28xx.h\"\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/usb.h>\n#include <linux/i2c.h>\n#include <linux/jiffies.h>\n\n#include \"xc2028.h\"\n#include <media/v4l2-common.h>\n#include <media/tuner.h>\n\n \n\nstatic unsigned int i2c_scan;\nmodule_param(i2c_scan, int, 0444);\nMODULE_PARM_DESC(i2c_scan, \"scan i2c bus at insmod time\");\n\nstatic unsigned int i2c_debug;\nmodule_param(i2c_debug, int, 0644);\nMODULE_PARM_DESC(i2c_debug, \"i2c debug message level (1: normal debug, 2: show I2C transfers)\");\n\n#define dprintk(level, fmt, arg...) do {\t\t\t\t\\\n\tif (i2c_debug > level)\t\t\t\t\t\t\\\n\t\tdev_printk(KERN_DEBUG, &dev->intf->dev,\t\t\t\\\n\t\t\t   \"i2c: %s: \" fmt, __func__, ## arg);\t\t\\\n} while (0)\n\n \n#define EM28XX_I2C_XFER_TIMEOUT         35  \n\nstatic int em28xx_i2c_timeout(struct em28xx *dev)\n{\n\tint time = EM28XX_I2C_XFER_TIMEOUT;\n\n\tswitch (dev->i2c_speed & 0x03) {\n\tcase EM28XX_I2C_FREQ_25_KHZ:\n\t\ttime += 4;\t\t \n\t\tbreak;\n\tcase EM28XX_I2C_FREQ_100_KHZ:\n\tcase EM28XX_I2C_FREQ_400_KHZ:\n\t\ttime += 1;\t\t \n\t\tbreak;\n\tdefault:  \n\t\tbreak;\n\t}\n\n\treturn msecs_to_jiffies(time);\n}\n\n \nstatic int em2800_i2c_send_bytes(struct em28xx *dev, u8 addr, u8 *buf, u16 len)\n{\n\tunsigned long timeout = jiffies + em28xx_i2c_timeout(dev);\n\tint ret;\n\tu8 b2[6];\n\n\tif (len < 1 || len > 4)\n\t\treturn -EOPNOTSUPP;\n\n\tb2[5] = 0x80 + len - 1;\n\tb2[4] = addr;\n\tb2[3] = buf[0];\n\tif (len > 1)\n\t\tb2[2] = buf[1];\n\tif (len > 2)\n\t\tb2[1] = buf[2];\n\tif (len > 3)\n\t\tb2[0] = buf[3];\n\n\t \n\tret = dev->em28xx_write_regs(dev, 4 - len, &b2[4 - len], 2 + len);\n\tif (ret != 2 + len) {\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"failed to trigger write to i2c address 0x%x (error=%i)\\n\",\n\t\t\t    addr, ret);\n\t\treturn (ret < 0) ? ret : -EIO;\n\t}\n\t \n\twhile (time_is_after_jiffies(timeout)) {\n\t\tret = dev->em28xx_read_reg(dev, 0x05);\n\t\tif (ret == 0x80 + len - 1)\n\t\t\treturn len;\n\t\tif (ret == 0x94 + len - 1) {\n\t\t\tdprintk(1, \"R05 returned 0x%02x: I2C ACK error\\n\", ret);\n\t\t\treturn -ENXIO;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_warn(&dev->intf->dev,\n\t\t\t\t \"failed to get i2c transfer status from bridge register (error=%i)\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t\tusleep_range(5000, 6000);\n\t}\n\tdprintk(0, \"write to i2c device at 0x%x timed out\\n\", addr);\n\treturn -ETIMEDOUT;\n}\n\n \nstatic int em2800_i2c_recv_bytes(struct em28xx *dev, u8 addr, u8 *buf, u16 len)\n{\n\tunsigned long timeout = jiffies + em28xx_i2c_timeout(dev);\n\tu8 buf2[4];\n\tint ret;\n\tint i;\n\n\tif (len < 1 || len > 4)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tbuf2[1] = 0x84 + len - 1;\n\tbuf2[0] = addr;\n\tret = dev->em28xx_write_regs(dev, 0x04, buf2, 2);\n\tif (ret != 2) {\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"failed to trigger read from i2c address 0x%x (error=%i)\\n\",\n\t\t\t addr, ret);\n\t\treturn (ret < 0) ? ret : -EIO;\n\t}\n\n\t \n\twhile (time_is_after_jiffies(timeout)) {\n\t\tret = dev->em28xx_read_reg(dev, 0x05);\n\t\tif (ret == 0x84 + len - 1)\n\t\t\tbreak;\n\t\tif (ret == 0x94 + len - 1) {\n\t\t\tdprintk(1, \"R05 returned 0x%02x: I2C ACK error\\n\",\n\t\t\t\tret);\n\t\t\treturn -ENXIO;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_warn(&dev->intf->dev,\n\t\t\t\t \"failed to get i2c transfer status from bridge register (error=%i)\\n\",\n\t\t\t\t ret);\n\t\t\treturn ret;\n\t\t}\n\t\tusleep_range(5000, 6000);\n\t}\n\tif (ret != 0x84 + len - 1)\n\t\tdprintk(0, \"read from i2c device at 0x%x timed out\\n\", addr);\n\n\t \n\tret = dev->em28xx_read_reg_req_len(dev, 0x00, 4 - len, buf2, len);\n\tif (ret != len) {\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"reading from i2c device at 0x%x failed: couldn't get the received message from the bridge (error=%i)\\n\",\n\t\t\t addr, ret);\n\t\treturn (ret < 0) ? ret : -EIO;\n\t}\n\tfor (i = 0; i < len; i++)\n\t\tbuf[i] = buf2[len - 1 - i];\n\n\treturn ret;\n}\n\n \nstatic int em2800_i2c_check_for_device(struct em28xx *dev, u8 addr)\n{\n\tu8 buf;\n\tint ret;\n\n\tret = em2800_i2c_recv_bytes(dev, addr, &buf, 1);\n\tif (ret == 1)\n\t\treturn 0;\n\treturn (ret < 0) ? ret : -EIO;\n}\n\n \nstatic int em28xx_i2c_send_bytes(struct em28xx *dev, u16 addr, u8 *buf,\n\t\t\t\t u16 len, int stop)\n{\n\tunsigned long timeout = jiffies + em28xx_i2c_timeout(dev);\n\tint ret;\n\n\tif (len < 1 || len > 64)\n\t\treturn -EOPNOTSUPP;\n\t \n\n\t \n\tret = dev->em28xx_write_regs_req(dev, stop ? 2 : 3, addr, buf, len);\n\tif (ret != len) {\n\t\tif (ret < 0) {\n\t\t\tdev_warn(&dev->intf->dev,\n\t\t\t\t \"writing to i2c device at 0x%x failed (error=%i)\\n\",\n\t\t\t\t addr, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"%i bytes write to i2c device at 0x%x requested, but %i bytes written\\n\",\n\t\t\t\tlen, addr, ret);\n\t\treturn -EIO;\n\t}\n\n\t \n\twhile (time_is_after_jiffies(timeout)) {\n\t\tret = dev->em28xx_read_reg(dev, 0x05);\n\t\tif (ret == 0)  \n\t\t\treturn len;\n\t\tif (ret == 0x10) {\n\t\t\tdprintk(1, \"I2C ACK error on writing to addr 0x%02x\\n\",\n\t\t\t\taddr);\n\t\t\treturn -ENXIO;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_warn(&dev->intf->dev,\n\t\t\t\t \"failed to get i2c transfer status from bridge register (error=%i)\\n\",\n\t\t\t\t ret);\n\t\t\treturn ret;\n\t\t}\n\t\tusleep_range(5000, 6000);\n\t\t \n\t}\n\n\tif (ret == 0x02 || ret == 0x04) {\n\t\t \n\t\tdprintk(0,\n\t\t\t\"write to i2c device at 0x%x timed out (status=%i)\\n\",\n\t\t\taddr, ret);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tdev_warn(&dev->intf->dev,\n\t\t \"write to i2c device at 0x%x failed with unknown error (status=%i)\\n\",\n\t\t addr, ret);\n\treturn -EIO;\n}\n\n \nstatic int em28xx_i2c_recv_bytes(struct em28xx *dev, u16 addr, u8 *buf, u16 len)\n{\n\tint ret;\n\n\tif (len < 1 || len > 64)\n\t\treturn -EOPNOTSUPP;\n\t \n\n\t \n\tret = dev->em28xx_read_reg_req_len(dev, 2, addr, buf, len);\n\tif (ret < 0) {\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"reading from i2c device at 0x%x failed (error=%i)\\n\",\n\t\t\t addr, ret);\n\t\treturn ret;\n\t} else if (ret != len) {\n\t\tdev_dbg(&dev->intf->dev,\n\t\t\t\"%i bytes read from i2c device at 0x%x requested, but %i bytes written\\n\",\n\t\t\t\tret, addr, len);\n\t}\n\t \n\n\t \n\tret = dev->em28xx_read_reg(dev, 0x05);\n\tif (ret == 0)  \n\t\treturn len;\n\tif (ret < 0) {\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"failed to get i2c transfer status from bridge register (error=%i)\\n\",\n\t\t\t ret);\n\t\treturn ret;\n\t}\n\tif (ret == 0x10) {\n\t\tdprintk(1, \"I2C ACK error on writing to addr 0x%02x\\n\",\n\t\t\taddr);\n\t\treturn -ENXIO;\n\t}\n\n\tif (ret == 0x02 || ret == 0x04) {\n\t\t \n\t\tdprintk(0,\n\t\t\t\"write to i2c device at 0x%x timed out (status=%i)\\n\",\n\t\t\taddr, ret);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tdev_warn(&dev->intf->dev,\n\t\t \"read from i2c device at 0x%x failed with unknown error (status=%i)\\n\",\n\t\t addr, ret);\n\treturn -EIO;\n}\n\n \nstatic int em28xx_i2c_check_for_device(struct em28xx *dev, u16 addr)\n{\n\tint ret;\n\tu8 buf;\n\n\tret = em28xx_i2c_recv_bytes(dev, addr, &buf, 1);\n\tif (ret == 1)\n\t\treturn 0;\n\treturn (ret < 0) ? ret : -EIO;\n}\n\n \nstatic int em25xx_bus_B_send_bytes(struct em28xx *dev, u16 addr, u8 *buf,\n\t\t\t\t   u16 len)\n{\n\tint ret;\n\n\tif (len < 1 || len > 64)\n\t\treturn -EOPNOTSUPP;\n\t \n\n\t \n\tret = dev->em28xx_write_regs_req(dev, 0x06, addr, buf, len);\n\tif (ret != len) {\n\t\tif (ret < 0) {\n\t\t\tdev_warn(&dev->intf->dev,\n\t\t\t\t \"writing to i2c device at 0x%x failed (error=%i)\\n\",\n\t\t\t\t addr, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"%i bytes write to i2c device at 0x%x requested, but %i bytes written\\n\",\n\t\t\t len, addr, ret);\n\t\treturn -EIO;\n\t}\n\t \n\tret = dev->em28xx_read_reg_req(dev, 0x08, 0x0000);\n\t \n\tif (!ret)\n\t\treturn len;\n\n\tif (ret > 0) {\n\t\tdprintk(1, \"Bus B R08 returned 0x%02x: I2C ACK error\\n\", ret);\n\t\treturn -ENXIO;\n\t}\n\n\treturn ret;\n\t \n}\n\n \nstatic int em25xx_bus_B_recv_bytes(struct em28xx *dev, u16 addr, u8 *buf,\n\t\t\t\t   u16 len)\n{\n\tint ret;\n\n\tif (len < 1 || len > 64)\n\t\treturn -EOPNOTSUPP;\n\t \n\n\t \n\tret = dev->em28xx_read_reg_req_len(dev, 0x06, addr, buf, len);\n\tif (ret < 0) {\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"reading from i2c device at 0x%x failed (error=%i)\\n\",\n\t\t\t addr, ret);\n\t\treturn ret;\n\t}\n\t \n\n\t \n\tret = dev->em28xx_read_reg_req(dev, 0x08, 0x0000);\n\t \n\tif (!ret)\n\t\treturn len;\n\n\tif (ret > 0) {\n\t\tdprintk(1, \"Bus B R08 returned 0x%02x: I2C ACK error\\n\", ret);\n\t\treturn -ENXIO;\n\t}\n\n\treturn ret;\n\t \n}\n\n \nstatic int em25xx_bus_B_check_for_device(struct em28xx *dev, u16 addr)\n{\n\tu8 buf;\n\tint ret;\n\n\tret = em25xx_bus_B_recv_bytes(dev, addr, &buf, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n\t \n}\n\nstatic inline int i2c_check_for_device(struct em28xx_i2c_bus *i2c_bus, u16 addr)\n{\n\tstruct em28xx *dev = i2c_bus->dev;\n\tint rc = -EOPNOTSUPP;\n\n\tif (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM28XX)\n\t\trc = em28xx_i2c_check_for_device(dev, addr);\n\telse if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM2800)\n\t\trc = em2800_i2c_check_for_device(dev, addr);\n\telse if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM25XX_BUS_B)\n\t\trc = em25xx_bus_B_check_for_device(dev, addr);\n\treturn rc;\n}\n\nstatic inline int i2c_recv_bytes(struct em28xx_i2c_bus *i2c_bus,\n\t\t\t\t struct i2c_msg msg)\n{\n\tstruct em28xx *dev = i2c_bus->dev;\n\tu16 addr = msg.addr << 1;\n\tint rc = -EOPNOTSUPP;\n\n\tif (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM28XX)\n\t\trc = em28xx_i2c_recv_bytes(dev, addr, msg.buf, msg.len);\n\telse if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM2800)\n\t\trc = em2800_i2c_recv_bytes(dev, addr, msg.buf, msg.len);\n\telse if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM25XX_BUS_B)\n\t\trc = em25xx_bus_B_recv_bytes(dev, addr, msg.buf, msg.len);\n\treturn rc;\n}\n\nstatic inline int i2c_send_bytes(struct em28xx_i2c_bus *i2c_bus,\n\t\t\t\t struct i2c_msg msg, int stop)\n{\n\tstruct em28xx *dev = i2c_bus->dev;\n\tu16 addr = msg.addr << 1;\n\tint rc = -EOPNOTSUPP;\n\n\tif (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM28XX)\n\t\trc = em28xx_i2c_send_bytes(dev, addr, msg.buf, msg.len, stop);\n\telse if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM2800)\n\t\trc = em2800_i2c_send_bytes(dev, addr, msg.buf, msg.len);\n\telse if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM25XX_BUS_B)\n\t\trc = em25xx_bus_B_send_bytes(dev, addr, msg.buf, msg.len);\n\treturn rc;\n}\n\n \nstatic int em28xx_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t   struct i2c_msg msgs[], int num)\n{\n\tstruct em28xx_i2c_bus *i2c_bus = i2c_adap->algo_data;\n\tstruct em28xx *dev = i2c_bus->dev;\n\tunsigned int bus = i2c_bus->bus;\n\tint addr, rc, i;\n\tu8 reg;\n\n\t \n\tif (dev->disconnected)\n\t\treturn -ENODEV;\n\n\tif (!rt_mutex_trylock(&dev->i2c_bus_lock))\n\t\treturn -EAGAIN;\n\n\t \n\tif (bus != dev->cur_i2c_bus &&\n\t    i2c_bus->algo_type == EM28XX_I2C_ALGO_EM28XX) {\n\t\tif (bus == 1)\n\t\t\treg = EM2874_I2C_SECONDARY_BUS_SELECT;\n\t\telse\n\t\t\treg = 0;\n\t\tem28xx_write_reg_bits(dev, EM28XX_R06_I2C_CLK, reg,\n\t\t\t\t      EM2874_I2C_SECONDARY_BUS_SELECT);\n\t\tdev->cur_i2c_bus = bus;\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\taddr = msgs[i].addr << 1;\n\t\tif (!msgs[i].len) {\n\t\t\t \n\t\t\trc = i2c_check_for_device(i2c_bus, addr);\n\n\t\t\tif (rc == -ENXIO)\n\t\t\t\trc = -ENODEV;\n\t\t} else if (msgs[i].flags & I2C_M_RD) {\n\t\t\t \n\t\t\trc = i2c_recv_bytes(i2c_bus, msgs[i]);\n\t\t} else {\n\t\t\t \n\t\t\trc = i2c_send_bytes(i2c_bus, msgs[i], i == num - 1);\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\tgoto error;\n\n\t\tdprintk(2, \"%s %s addr=%02x len=%d: %*ph\\n\",\n\t\t\t(msgs[i].flags & I2C_M_RD) ? \"read\" : \"write\",\n\t\t\ti == num - 1 ? \"stop\" : \"nonstop\",\n\t\t\taddr, msgs[i].len,\n\t\t\tmsgs[i].len, msgs[i].buf);\n\t}\n\n\trt_mutex_unlock(&dev->i2c_bus_lock);\n\treturn num;\n\nerror:\n\tdprintk(2, \"%s %s addr=%02x len=%d: %sERROR: %i\\n\",\n\t\t(msgs[i].flags & I2C_M_RD) ? \"read\" : \"write\",\n\t\ti == num - 1 ? \"stop\" : \"nonstop\",\n\t\taddr, msgs[i].len,\n\t\t(rc == -ENODEV) ? \"no device \" : \"\",\n\t\trc);\n\n\trt_mutex_unlock(&dev->i2c_bus_lock);\n\treturn rc;\n}\n\n \nstatic inline unsigned long em28xx_hash_mem(char *buf, int length, int bits)\n{\n\tunsigned long hash = 0;\n\tunsigned long l = 0;\n\tint len = 0;\n\tunsigned char c;\n\n\tdo {\n\t\tif (len == length) {\n\t\t\tc = (char)len;\n\t\t\tlen = -1;\n\t\t} else {\n\t\t\tc = *buf++;\n\t\t}\n\t\tl = (l << 8) | c;\n\t\tlen++;\n\t\tif ((len & (32 / 8 - 1)) == 0)\n\t\t\thash = ((hash ^ l) * 0x9e370001UL);\n\t} while (len);\n\n\treturn (hash >> (32 - bits)) & 0xffffffffUL;\n}\n\n \nstatic int em28xx_i2c_read_block(struct em28xx *dev, unsigned int bus, u16 addr,\n\t\t\t\t bool addr_w16, u16 len, u8 *data)\n{\n\tint remain = len, rsize, rsize_max, ret;\n\tu8 buf[2];\n\n\t \n\tif (addr + remain > (addr_w16 * 0xff00 + 0xff + 1))\n\t\treturn -EINVAL;\n\t \n\tbuf[0] = addr >> 8;\n\tbuf[1] = addr & 0xff;\n\tret = i2c_master_send(&dev->i2c_client[bus],\n\t\t\t      buf + !addr_w16, 1 + addr_w16);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tif (dev->board.is_em2800)\n\t\trsize_max = 4;\n\telse\n\t\trsize_max = 64;\n\twhile (remain > 0) {\n\t\tif (remain > rsize_max)\n\t\t\trsize = rsize_max;\n\t\telse\n\t\t\trsize = remain;\n\n\t\tret = i2c_master_recv(&dev->i2c_client[bus], data, rsize);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tremain -= rsize;\n\t\tdata += rsize;\n\t}\n\n\treturn len;\n}\n\nstatic int em28xx_i2c_eeprom(struct em28xx *dev, unsigned int bus,\n\t\t\t     u8 **eedata, u16 *eedata_len)\n{\n\tconst u16 len = 256;\n\t \n\tint err;\n\tstruct em28xx_eeprom *dev_config;\n\tu8 buf, *data;\n\n\t*eedata = NULL;\n\t*eedata_len = 0;\n\n\t \n\n\tdev->i2c_client[bus].addr = 0xa0 >> 1;\n\n\t \n\terr = i2c_master_recv(&dev->i2c_client[bus], &buf, 0);\n\tif (err < 0) {\n\t\tdev_info(&dev->intf->dev, \"board has no eeprom\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdata = kzalloc(len, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t \n\terr = em28xx_i2c_read_block(dev, bus, 0x0000,\n\t\t\t\t    dev->eeprom_addrwidth_16bit,\n\t\t\t\t    len, data);\n\tif (err != len) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"failed to read eeprom (err=%d)\\n\", err);\n\t\tgoto error;\n\t}\n\n\tif (i2c_debug) {\n\t\t \n\t\tprint_hex_dump(KERN_DEBUG, \"em28xx eeprom \", DUMP_PREFIX_OFFSET,\n\t\t\t       16, 1, data, len, true);\n\n\t\tif (dev->eeprom_addrwidth_16bit)\n\t\t\tdev_info(&dev->intf->dev,\n\t\t\t\t \"eeprom %06x: ... (skipped)\\n\", 256);\n\t}\n\n\tif (dev->eeprom_addrwidth_16bit &&\n\t    data[0] == 0x26 && data[3] == 0x00) {\n\t\t \n\t\tu16 mc_start;\n\t\tu16 hwconf_offset;\n\n\t\tdev->hash = em28xx_hash_mem(data, len, 32);\n\t\tmc_start = (data[1] << 8) + 4;\t \n\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"EEPROM ID = %4ph, EEPROM hash = 0x%08lx\\n\",\n\t\t\t data, dev->hash);\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"EEPROM info:\\n\");\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"\\tmicrocode start address = 0x%04x, boot configuration = 0x%02x\\n\",\n\t\t\t mc_start, data[2]);\n\t\t \n\n\t\t \n\t\terr = em28xx_i2c_read_block(dev, bus, mc_start + 46, 1, 2,\n\t\t\t\t\t    data);\n\t\tif (err != 2) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"failed to read hardware configuration data from eeprom (err=%d)\\n\",\n\t\t\t\terr);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\thwconf_offset = mc_start + data[0] + (data[1] << 8);\n\n\t\t \n\t\t \n\t\terr = em28xx_i2c_read_block(dev, bus, hwconf_offset, 1, len,\n\t\t\t\t\t    data);\n\t\tif (err != len) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"failed to read hardware configuration data from eeprom (err=%d)\\n\",\n\t\t\t\terr);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\t \n\t\tif (data[0] != 0x1a || data[1] != 0xeb ||\n\t\t    data[2] != 0x67 || data[3] != 0x95) {\n\t\t\tdev_info(&dev->intf->dev,\n\t\t\t\t \"\\tno hardware configuration dataset found in eeprom\\n\");\n\t\t\tkfree(data);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\n\t} else if (!dev->eeprom_addrwidth_16bit &&\n\t\t   data[0] == 0x1a && data[1] == 0xeb &&\n\t\t   data[2] == 0x67 && data[3] == 0x95) {\n\t\tdev->hash = em28xx_hash_mem(data, len, 32);\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"EEPROM ID = %4ph, EEPROM hash = 0x%08lx\\n\",\n\t\t\t data, dev->hash);\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"EEPROM info:\\n\");\n\t} else {\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"unknown eeprom format or eeprom corrupted !\\n\");\n\t\terr = -ENODEV;\n\t\tgoto error;\n\t}\n\n\t*eedata = data;\n\t*eedata_len = len;\n\tdev_config = (void *)*eedata;\n\n\tswitch (le16_to_cpu(dev_config->chip_conf) >> 4 & 0x3) {\n\tcase 0:\n\t\tdev_info(&dev->intf->dev, \"\\tNo audio on board.\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tdev_info(&dev->intf->dev, \"\\tAC97 audio (5 sample rates)\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tif (dev->chip_id < CHIP_ID_EM2860)\n\t\t\tdev_info(&dev->intf->dev,\n\t\t\t\t \"\\tI2S audio, sample rate=32k\\n\");\n\t\telse\n\t\t\tdev_info(&dev->intf->dev,\n\t\t\t\t \"\\tI2S audio, 3 sample rates\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tif (dev->chip_id < CHIP_ID_EM2860)\n\t\t\tdev_info(&dev->intf->dev,\n\t\t\t\t \"\\tI2S audio, 3 sample rates\\n\");\n\t\telse\n\t\t\tdev_info(&dev->intf->dev,\n\t\t\t\t \"\\tI2S audio, 5 sample rates\\n\");\n\t\tbreak;\n\t}\n\n\tif (le16_to_cpu(dev_config->chip_conf) & 1 << 3)\n\t\tdev_info(&dev->intf->dev, \"\\tUSB Remote wakeup capable\\n\");\n\n\tif (le16_to_cpu(dev_config->chip_conf) & 1 << 2)\n\t\tdev_info(&dev->intf->dev, \"\\tUSB Self power capable\\n\");\n\n\tswitch (le16_to_cpu(dev_config->chip_conf) & 0x3) {\n\tcase 0:\n\t\tdev_info(&dev->intf->dev, \"\\t500mA max power\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tdev_info(&dev->intf->dev, \"\\t400mA max power\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tdev_info(&dev->intf->dev, \"\\t300mA max power\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tdev_info(&dev->intf->dev, \"\\t200mA max power\\n\");\n\t\tbreak;\n\t}\n\tdev_info(&dev->intf->dev,\n\t\t \"\\tTable at offset 0x%02x, strings=0x%04x, 0x%04x, 0x%04x\\n\",\n\t\t dev_config->string_idx_table,\n\t\t le16_to_cpu(dev_config->string1),\n\t\t le16_to_cpu(dev_config->string2),\n\t\t le16_to_cpu(dev_config->string3));\n\n\treturn 0;\n\nerror:\n\tkfree(data);\n\treturn err;\n}\n\n \n\n \nstatic u32 functionality(struct i2c_adapter *i2c_adap)\n{\n\tstruct em28xx_i2c_bus *i2c_bus = i2c_adap->algo_data;\n\n\tif (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM28XX ||\n\t    i2c_bus->algo_type == EM28XX_I2C_ALGO_EM25XX_BUS_B) {\n\t\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n\t} else if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM2800)  {\n\t\treturn (I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL) &\n\t\t\t~I2C_FUNC_SMBUS_WRITE_BLOCK_DATA;\n\t}\n\n\tWARN(1, \"Unknown i2c bus algorithm.\\n\");\n\treturn 0;\n}\n\nstatic const struct i2c_algorithm em28xx_algo = {\n\t.master_xfer   = em28xx_i2c_xfer,\n\t.functionality = functionality,\n};\n\nstatic const struct i2c_adapter em28xx_adap_template = {\n\t.owner = THIS_MODULE,\n\t.name = \"em28xx\",\n\t.algo = &em28xx_algo,\n};\n\nstatic const struct i2c_client em28xx_client_template = {\n\t.name = \"em28xx internal\",\n};\n\n \n\n \nstatic char *i2c_devs[128] = {\n\t[0x1c >> 1] = \"lgdt330x\",\n\t[0x3e >> 1] = \"remote IR sensor\",\n\t[0x4a >> 1] = \"saa7113h\",\n\t[0x52 >> 1] = \"drxk\",\n\t[0x60 >> 1] = \"remote IR sensor\",\n\t[0x8e >> 1] = \"remote IR sensor\",\n\t[0x86 >> 1] = \"tda9887\",\n\t[0x80 >> 1] = \"msp34xx\",\n\t[0x88 >> 1] = \"msp34xx\",\n\t[0xa0 >> 1] = \"eeprom\",\n\t[0xb0 >> 1] = \"tda9874\",\n\t[0xb8 >> 1] = \"tvp5150a\",\n\t[0xba >> 1] = \"webcam sensor or tvp5150a\",\n\t[0xc0 >> 1] = \"tuner (analog)\",\n\t[0xc2 >> 1] = \"tuner (analog)\",\n\t[0xc4 >> 1] = \"tuner (analog)\",\n\t[0xc6 >> 1] = \"tuner (analog)\",\n};\n\n \nvoid em28xx_do_i2c_scan(struct em28xx *dev, unsigned int bus)\n{\n\tu8 i2c_devicelist[128];\n\tunsigned char buf;\n\tint i, rc;\n\n\tmemset(i2c_devicelist, 0, sizeof(i2c_devicelist));\n\n\tfor (i = 0; i < ARRAY_SIZE(i2c_devs); i++) {\n\t\tdev->i2c_client[bus].addr = i;\n\t\trc = i2c_master_recv(&dev->i2c_client[bus], &buf, 0);\n\t\tif (rc < 0)\n\t\t\tcontinue;\n\t\ti2c_devicelist[i] = i;\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"found i2c device @ 0x%x on bus %d [%s]\\n\",\n\t\t\t i << 1, bus, i2c_devs[i] ? i2c_devs[i] : \"???\");\n\t}\n\n\tif (bus == dev->def_i2c_bus)\n\t\tdev->i2c_hash = em28xx_hash_mem(i2c_devicelist,\n\t\t\t\t\t\tsizeof(i2c_devicelist), 32);\n}\n\n \nint em28xx_i2c_register(struct em28xx *dev, unsigned int bus,\n\t\t\tenum em28xx_i2c_algo_type algo_type)\n{\n\tint retval;\n\n\tif (WARN_ON(!dev->em28xx_write_regs || !dev->em28xx_read_reg ||\n\t\t    !dev->em28xx_write_regs_req || !dev->em28xx_read_reg_req))\n\t\treturn -ENODEV;\n\n\tif (bus >= NUM_I2C_BUSES)\n\t\treturn -ENODEV;\n\n\tdev->i2c_adap[bus] = em28xx_adap_template;\n\tdev->i2c_adap[bus].dev.parent = &dev->intf->dev;\n\tstrscpy(dev->i2c_adap[bus].name, dev_name(&dev->intf->dev),\n\t\tsizeof(dev->i2c_adap[bus].name));\n\n\tdev->i2c_bus[bus].bus = bus;\n\tdev->i2c_bus[bus].algo_type = algo_type;\n\tdev->i2c_bus[bus].dev = dev;\n\tdev->i2c_adap[bus].algo_data = &dev->i2c_bus[bus];\n\n\tretval = i2c_add_adapter(&dev->i2c_adap[bus]);\n\tif (retval < 0) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"%s: i2c_add_adapter failed! retval [%d]\\n\",\n\t\t\t__func__, retval);\n\t\treturn retval;\n\t}\n\n\tdev->i2c_client[bus] = em28xx_client_template;\n\tdev->i2c_client[bus].adapter = &dev->i2c_adap[bus];\n\n\t \n\tif (!bus) {\n\t\tretval = em28xx_i2c_eeprom(dev, bus,\n\t\t\t\t\t   &dev->eedata, &dev->eedata_len);\n\t\tif (retval < 0 && retval != -ENODEV) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"%s: em28xx_i2_eeprom failed! retval [%d]\\n\",\n\t\t\t\t__func__, retval);\n\t\t}\n\t}\n\n\tif (i2c_scan)\n\t\tem28xx_do_i2c_scan(dev, bus);\n\n\treturn 0;\n}\n\n \nint em28xx_i2c_unregister(struct em28xx *dev, unsigned int bus)\n{\n\tif (bus >= NUM_I2C_BUSES)\n\t\treturn -ENODEV;\n\n\ti2c_del_adapter(&dev->i2c_adap[bus]);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}