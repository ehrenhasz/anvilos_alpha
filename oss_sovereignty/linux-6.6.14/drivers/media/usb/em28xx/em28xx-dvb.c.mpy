{
  "module_name": "em28xx-dvb.c",
  "hash_id": "59935eee8c93bdbf7bf7bc754a2d98414a1ac1bccc4e84b0161283f13744b034",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/em28xx/em28xx-dvb.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"em28xx.h\"\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n#include <media/v4l2-common.h>\n#include <media/dvb_demux.h>\n#include <media/dvb_net.h>\n#include <media/dmxdev.h>\n#include <media/tuner.h>\n#include \"tuner-simple.h\"\n#include <linux/gpio.h>\n\n#include \"lgdt330x.h\"\n#include \"lgdt3305.h\"\n#include \"lgdt3306a.h\"\n#include \"zl10353.h\"\n#include \"s5h1409.h\"\n#include \"mt2060.h\"\n#include \"mt352.h\"\n#include \"mt352_priv.h\"  \n#include \"tda1002x.h\"\n#include \"drx39xyj/drx39xxj.h\"\n#include \"tda18271.h\"\n#include \"s921.h\"\n#include \"drxd.h\"\n#include \"cxd2820r.h\"\n#include \"tda18271c2dd.h\"\n#include \"drxk.h\"\n#include \"tda10071.h\"\n#include \"tda18212.h\"\n#include \"a8293.h\"\n#include \"qt1010.h\"\n#include \"mb86a20s.h\"\n#include \"m88ds3103.h\"\n#include \"ts2020.h\"\n#include \"si2168.h\"\n#include \"si2157.h\"\n#include \"tc90522.h\"\n#include \"qm1d1c0042.h\"\n#include \"mxl692.h\"\n\nMODULE_AUTHOR(\"Mauro Carvalho Chehab <mchehab@kernel.org>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(DRIVER_DESC \" - digital TV interface\");\nMODULE_VERSION(EM28XX_VERSION);\n\nstatic unsigned int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable debug messages [dvb]\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n#define dprintk(level, fmt, arg...) do {\t\t\t\t\\\n\tif (debug >= level)\t\t\t\t\t\t\\\n\t\tdev_printk(KERN_DEBUG, &dev->intf->dev,\t\t\t\\\n\t\t\t   \"dvb: \" fmt, ## arg);\t\t\t\\\n} while (0)\n\nstruct em28xx_dvb {\n\tstruct dvb_frontend        *fe[2];\n\n\t \n\tstruct mutex               lock;\n\tint                        nfeeds;\n\n\t \n\tstruct dvb_adapter         adapter;\n\tstruct dvb_demux           demux;\n\tstruct dmxdev              dmxdev;\n\tstruct dmx_frontend        fe_hw;\n\tstruct dmx_frontend        fe_mem;\n\tstruct dvb_net             net;\n\n\t \n\tint (*gate_ctrl)(struct dvb_frontend *fe, int gate);\n\tstruct semaphore      pll_mutex;\n\tbool\t\t\tdont_attach_fe1;\n\tint\t\t\tlna_gpio;\n\tstruct i2c_client\t*i2c_client_demod;\n\tstruct i2c_client\t*i2c_client_tuner;\n\tstruct i2c_client\t*i2c_client_sec;\n};\n\nstatic inline void print_err_status(struct em28xx *dev,\n\t\t\t\t    int packet, int status)\n{\n\tchar *errmsg = \"Unknown\";\n\n\tswitch (status) {\n\tcase -ENOENT:\n\t\terrmsg = \"unlinked synchronously\";\n\t\tbreak;\n\tcase -ECONNRESET:\n\t\terrmsg = \"unlinked asynchronously\";\n\t\tbreak;\n\tcase -ENOSR:\n\t\terrmsg = \"Buffer error (overrun)\";\n\t\tbreak;\n\tcase -EPIPE:\n\t\terrmsg = \"Stalled (device not responding)\";\n\t\tbreak;\n\tcase -EOVERFLOW:\n\t\terrmsg = \"Babble (bad cable?)\";\n\t\tbreak;\n\tcase -EPROTO:\n\t\terrmsg = \"Bit-stuff error (bad cable?)\";\n\t\tbreak;\n\tcase -EILSEQ:\n\t\terrmsg = \"CRC/Timeout (could be anything)\";\n\t\tbreak;\n\tcase -ETIME:\n\t\terrmsg = \"Device does not respond\";\n\t\tbreak;\n\t}\n\tif (packet < 0) {\n\t\tdprintk(1, \"URB status %d [%s].\\n\", status, errmsg);\n\t} else {\n\t\tdprintk(1, \"URB packet %d, status %d [%s].\\n\",\n\t\t\tpacket, status, errmsg);\n\t}\n}\n\nstatic inline int em28xx_dvb_urb_data_copy(struct em28xx *dev, struct urb *urb)\n{\n\tint xfer_bulk, num_packets, i;\n\n\tif (!dev)\n\t\treturn 0;\n\n\tif (dev->disconnected)\n\t\treturn 0;\n\n\tif (urb->status < 0)\n\t\tprint_err_status(dev, -1, urb->status);\n\n\txfer_bulk = usb_pipebulk(urb->pipe);\n\n\tif (xfer_bulk)  \n\t\tnum_packets = 1;\n\telse  \n\t\tnum_packets = urb->number_of_packets;\n\n\tfor (i = 0; i < num_packets; i++) {\n\t\tif (xfer_bulk) {\n\t\t\tif (urb->status < 0) {\n\t\t\t\tprint_err_status(dev, i, urb->status);\n\t\t\t\tif (urb->status != -EPROTO)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!urb->actual_length)\n\t\t\t\tcontinue;\n\t\t\tdvb_dmx_swfilter(&dev->dvb->demux, urb->transfer_buffer,\n\t\t\t\t\t urb->actual_length);\n\t\t} else {\n\t\t\tif (urb->iso_frame_desc[i].status < 0) {\n\t\t\t\tprint_err_status(dev, i,\n\t\t\t\t\t\t urb->iso_frame_desc[i].status);\n\t\t\t\tif (urb->iso_frame_desc[i].status != -EPROTO)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!urb->iso_frame_desc[i].actual_length)\n\t\t\t\tcontinue;\n\t\t\tdvb_dmx_swfilter(&dev->dvb->demux,\n\t\t\t\t\t urb->transfer_buffer +\n\t\t\t\t\t urb->iso_frame_desc[i].offset,\n\t\t\t\t\t urb->iso_frame_desc[i].actual_length);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int em28xx_start_streaming(struct em28xx_dvb *dvb)\n{\n\tint rc;\n\tstruct em28xx_i2c_bus *i2c_bus = dvb->adapter.priv;\n\tstruct em28xx *dev = i2c_bus->dev;\n\tstruct usb_device *udev = interface_to_usbdev(dev->intf);\n\tint dvb_max_packet_size, packet_multiplier, dvb_alt;\n\n\tif (dev->dvb_xfer_bulk) {\n\t\tif (!dev->dvb_ep_bulk)\n\t\t\treturn -ENODEV;\n\t\tdvb_max_packet_size = 512;  \n\t\tpacket_multiplier = EM28XX_DVB_BULK_PACKET_MULTIPLIER;\n\t\tdvb_alt = 0;\n\t} else {  \n\t\tif (!dev->dvb_ep_isoc)\n\t\t\treturn -ENODEV;\n\t\tdvb_max_packet_size = dev->dvb_max_pkt_size_isoc;\n\t\tif (dvb_max_packet_size < 0)\n\t\t\treturn dvb_max_packet_size;\n\t\tpacket_multiplier = EM28XX_DVB_NUM_ISOC_PACKETS;\n\t\tdvb_alt = dev->dvb_alt_isoc;\n\t}\n\n\tif (!dev->board.has_dual_ts)\n\t\tusb_set_interface(udev, dev->ifnum, dvb_alt);\n\n\trc = em28xx_set_mode(dev, EM28XX_DIGITAL_MODE);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tdprintk(1, \"Using %d buffers each with %d x %d bytes, alternate %d\\n\",\n\t\tEM28XX_DVB_NUM_BUFS,\n\t\tpacket_multiplier,\n\t\tdvb_max_packet_size, dvb_alt);\n\n\treturn em28xx_init_usb_xfer(dev, EM28XX_DIGITAL_MODE,\n\t\t\t\t    dev->dvb_xfer_bulk,\n\t\t\t\t    EM28XX_DVB_NUM_BUFS,\n\t\t\t\t    dvb_max_packet_size,\n\t\t\t\t    packet_multiplier,\n\t\t\t\t    em28xx_dvb_urb_data_copy);\n}\n\nstatic int em28xx_stop_streaming(struct em28xx_dvb *dvb)\n{\n\tstruct em28xx_i2c_bus *i2c_bus = dvb->adapter.priv;\n\tstruct em28xx *dev = i2c_bus->dev;\n\n\tem28xx_stop_urbs(dev);\n\n\treturn 0;\n}\n\nstatic int em28xx_start_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux  = feed->demux;\n\tstruct em28xx_dvb *dvb = demux->priv;\n\tint rc, ret;\n\n\tif (!demux->dmx.frontend)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dvb->lock);\n\tdvb->nfeeds++;\n\trc = dvb->nfeeds;\n\n\tif (dvb->nfeeds == 1) {\n\t\tret = em28xx_start_streaming(dvb);\n\t\tif (ret < 0)\n\t\t\trc = ret;\n\t}\n\n\tmutex_unlock(&dvb->lock);\n\treturn rc;\n}\n\nstatic int em28xx_stop_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux  = feed->demux;\n\tstruct em28xx_dvb *dvb = demux->priv;\n\tint err = 0;\n\n\tmutex_lock(&dvb->lock);\n\tdvb->nfeeds--;\n\n\tif (!dvb->nfeeds)\n\t\terr = em28xx_stop_streaming(dvb);\n\n\tmutex_unlock(&dvb->lock);\n\treturn err;\n}\n\n \nstatic int em28xx_dvb_bus_ctrl(struct dvb_frontend *fe, int acquire)\n{\n\tstruct em28xx_i2c_bus *i2c_bus = fe->dvb->priv;\n\tstruct em28xx *dev = i2c_bus->dev;\n\n\tif (acquire)\n\t\treturn em28xx_set_mode(dev, EM28XX_DIGITAL_MODE);\n\telse\n\t\treturn em28xx_set_mode(dev, EM28XX_SUSPEND);\n}\n\n \n\nstatic struct lgdt330x_config em2880_lgdt3303_dev = {\n\t.demod_chip = LGDT3303,\n};\n\nstatic struct lgdt3305_config em2870_lgdt3304_dev = {\n\t.i2c_addr           = 0x0e,\n\t.demod_chip         = LGDT3304,\n\t.spectral_inversion = 1,\n\t.deny_i2c_rptr      = 1,\n\t.mpeg_mode          = LGDT3305_MPEG_PARALLEL,\n\t.tpclk_edge         = LGDT3305_TPCLK_FALLING_EDGE,\n\t.tpvalid_polarity   = LGDT3305_TP_VALID_HIGH,\n\t.vsb_if_khz         = 3250,\n\t.qam_if_khz         = 4000,\n};\n\nstatic struct lgdt3305_config em2874_lgdt3305_dev = {\n\t.i2c_addr           = 0x0e,\n\t.demod_chip         = LGDT3305,\n\t.spectral_inversion = 1,\n\t.deny_i2c_rptr      = 0,\n\t.mpeg_mode          = LGDT3305_MPEG_SERIAL,\n\t.tpclk_edge         = LGDT3305_TPCLK_FALLING_EDGE,\n\t.tpvalid_polarity   = LGDT3305_TP_VALID_HIGH,\n\t.vsb_if_khz         = 3250,\n\t.qam_if_khz         = 4000,\n};\n\nstatic struct lgdt3305_config em2874_lgdt3305_nogate_dev = {\n\t.i2c_addr           = 0x0e,\n\t.demod_chip         = LGDT3305,\n\t.spectral_inversion = 1,\n\t.deny_i2c_rptr      = 1,\n\t.mpeg_mode          = LGDT3305_MPEG_SERIAL,\n\t.tpclk_edge         = LGDT3305_TPCLK_FALLING_EDGE,\n\t.tpvalid_polarity   = LGDT3305_TP_VALID_HIGH,\n\t.vsb_if_khz         = 3600,\n\t.qam_if_khz         = 3600,\n};\n\nstatic struct s921_config sharp_isdbt = {\n\t.demod_address = 0x30 >> 1\n};\n\nstatic struct zl10353_config em28xx_zl10353_with_xc3028 = {\n\t.demod_address = (0x1e >> 1),\n\t.no_tuner = 1,\n\t.parallel_ts = 1,\n\t.if2 = 45600,\n};\n\nstatic struct s5h1409_config em28xx_s5h1409_with_xc3028 = {\n\t.demod_address = 0x32 >> 1,\n\t.output_mode   = S5H1409_PARALLEL_OUTPUT,\n\t.gpio          = S5H1409_GPIO_OFF,\n\t.inversion     = S5H1409_INVERSION_OFF,\n\t.status_mode   = S5H1409_DEMODLOCKING,\n\t.mpeg_timing   = S5H1409_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK\n};\n\nstatic struct tda18271_std_map kworld_a340_std_map = {\n\t.atsc_6   = { .if_freq = 3250, .agc_mode = 3, .std = 0,\n\t\t      .if_lvl = 1, .rfagc_top = 0x37, },\n\t.qam_6    = { .if_freq = 4000, .agc_mode = 3, .std = 1,\n\t\t      .if_lvl = 1, .rfagc_top = 0x37, },\n};\n\nstatic struct tda18271_config kworld_a340_config = {\n\t.std_map           = &kworld_a340_std_map,\n};\n\nstatic struct tda18271_config kworld_ub435q_v2_config = {\n\t.std_map\t= &kworld_a340_std_map,\n\t.gate\t\t= TDA18271_GATE_DIGITAL,\n};\n\nstatic struct tda18212_config kworld_ub435q_v3_config = {\n\t.if_atsc_vsb\t= 3600,\n\t.if_atsc_qam\t= 3600,\n};\n\nstatic struct zl10353_config em28xx_zl10353_xc3028_no_i2c_gate = {\n\t.demod_address = (0x1e >> 1),\n\t.no_tuner = 1,\n\t.disable_i2c_gate_ctrl = 1,\n\t.parallel_ts = 1,\n\t.if2 = 45600,\n};\n\nstatic struct drxd_config em28xx_drxd = {\n\t.demod_address = 0x70,\n\t.demod_revision = 0xa2,\n\t.pll_type = DRXD_PLL_NONE,\n\t.clock = 12000,\n\t.insert_rs_byte = 1,\n\t.IF = 42800000,\n\t.disable_i2c_gate_ctrl = 1,\n};\n\nstatic struct drxk_config terratec_h5_drxk = {\n\t.adr = 0x29,\n\t.single_master = 1,\n\t.no_i2c_bridge = 1,\n\t.microcode_name = \"dvb-usb-terratec-h5-drxk.fw\",\n\t.qam_demod_parameter_count = 2,\n};\n\nstatic struct drxk_config hauppauge_930c_drxk = {\n\t.adr = 0x29,\n\t.single_master = 1,\n\t.no_i2c_bridge = 1,\n\t.microcode_name = \"dvb-usb-hauppauge-hvr930c-drxk.fw\",\n\t.chunk_size = 56,\n\t.qam_demod_parameter_count = 2,\n};\n\nstatic struct drxk_config terratec_htc_stick_drxk = {\n\t.adr = 0x29,\n\t.single_master = 1,\n\t.no_i2c_bridge = 1,\n\t.microcode_name = \"dvb-usb-terratec-htc-stick-drxk.fw\",\n\t.chunk_size = 54,\n\t.qam_demod_parameter_count = 2,\n\t \n\t.antenna_dvbt = true,\n\t \n\t.antenna_gpio = 0x6,\n};\n\nstatic struct drxk_config maxmedia_ub425_tc_drxk = {\n\t.adr = 0x29,\n\t.single_master = 1,\n\t.no_i2c_bridge = 1,\n\t.microcode_name = \"dvb-demod-drxk-01.fw\",\n\t.chunk_size = 62,\n\t.qam_demod_parameter_count = 2,\n};\n\nstatic struct drxk_config pctv_520e_drxk = {\n\t.adr = 0x29,\n\t.single_master = 1,\n\t.microcode_name = \"dvb-demod-drxk-pctv.fw\",\n\t.qam_demod_parameter_count = 2,\n\t.chunk_size = 58,\n\t.antenna_dvbt = true,  \n\t.antenna_gpio = (1 << 2),  \n};\n\nstatic int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct em28xx_dvb *dvb = fe->sec_priv;\n\tint status;\n\n\tif (!dvb)\n\t\treturn -EINVAL;\n\n\tif (enable) {\n\t\tdown(&dvb->pll_mutex);\n\t\tstatus = dvb->gate_ctrl(fe, 1);\n\t} else {\n\t\tstatus = dvb->gate_ctrl(fe, 0);\n\t\tup(&dvb->pll_mutex);\n\t}\n\treturn status;\n}\n\nstatic void hauppauge_hvr930c_init(struct em28xx *dev)\n{\n\tint i;\n\n\tstatic const struct em28xx_reg_seq hauppauge_hvr930c_init[] = {\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xff,\t0xff,\t0x65},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xfb,\t0xff,\t0x32},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xff,\t0xff,\t0xb8},\n\t\t{\t-1,\t\t\t-1,\t-1,\t-1},\n\t};\n\tstatic const struct em28xx_reg_seq hauppauge_hvr930c_end[] = {\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xef,\t0xff,\t0x01},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xaf,\t0xff,\t0x65},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xef,\t0xff,\t0x76},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xef,\t0xff,\t0x01},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xcf,\t0xff,\t0x0b},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xef,\t0xff,\t0x40},\n\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xcf,\t0xff,\t0x65},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xef,\t0xff,\t0x65},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xcf,\t0xff,\t0x0b},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xef,\t0xff,\t0x65},\n\n\t\t{\t-1,\t\t\t-1,\t-1,\t-1},\n\t};\n\n\tstatic const struct {\n\t\tunsigned char r[4];\n\t\tint len;\n\t} regs[] = {\n\t\t{{ 0x06, 0x02, 0x00, 0x31 }, 4},\n\t\t{{ 0x01, 0x02 }, 2},\n\t\t{{ 0x01, 0x02, 0x00, 0xc6 }, 4},\n\t\t{{ 0x01, 0x00 }, 2},\n\t\t{{ 0x01, 0x00, 0xff, 0xaf }, 4},\n\t\t{{ 0x01, 0x00, 0x03, 0xa0 }, 4},\n\t\t{{ 0x01, 0x00 }, 2},\n\t\t{{ 0x01, 0x00, 0x73, 0xaf }, 4},\n\t\t{{ 0x04, 0x00 }, 2},\n\t\t{{ 0x00, 0x04 }, 2},\n\t\t{{ 0x00, 0x04, 0x00, 0x0a }, 4},\n\t\t{{ 0x04, 0x14 }, 2},\n\t\t{{ 0x04, 0x14, 0x00, 0x00 }, 4},\n\t};\n\n\tem28xx_gpio_set(dev, hauppauge_hvr930c_init);\n\tem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x40);\n\tusleep_range(10000, 11000);\n\tem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x44);\n\tusleep_range(10000, 11000);\n\n\tdev->i2c_client[dev->def_i2c_bus].addr = 0x82 >> 1;\n\n\tfor (i = 0; i < ARRAY_SIZE(regs); i++)\n\t\ti2c_master_send(&dev->i2c_client[dev->def_i2c_bus],\n\t\t\t\tregs[i].r, regs[i].len);\n\tem28xx_gpio_set(dev, hauppauge_hvr930c_end);\n\n\tmsleep(100);\n\n\tem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x44);\n\tmsleep(30);\n\n\tem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x45);\n\tusleep_range(10000, 11000);\n}\n\nstatic void terratec_h5_init(struct em28xx *dev)\n{\n\tint i;\n\tstatic const struct em28xx_reg_seq terratec_h5_init[] = {\n\t\t{EM2820_R08_GPIO_CTRL,\t\t0xff,\t0xff,\t10},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xf6,\t0xff,\t100},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xf2,\t0xff,\t50},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xf6,\t0xff,\t100},\n\t\t{\t-1,\t\t\t-1,\t-1,\t-1},\n\t};\n\tstatic const struct em28xx_reg_seq terratec_h5_end[] = {\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xe6,\t0xff,\t100},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xa6,\t0xff,\t50},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xe6,\t0xff,\t100},\n\t\t{\t-1,\t\t\t-1,\t-1,\t-1},\n\t};\n\tstatic const struct {\n\t\tunsigned char r[4];\n\t\tint len;\n\t} regs[] = {\n\t\t{{ 0x06, 0x02, 0x00, 0x31 }, 4},\n\t\t{{ 0x01, 0x02 }, 2},\n\t\t{{ 0x01, 0x02, 0x00, 0xc6 }, 4},\n\t\t{{ 0x01, 0x00 }, 2},\n\t\t{{ 0x01, 0x00, 0xff, 0xaf }, 4},\n\t\t{{ 0x01, 0x00, 0x03, 0xa0 }, 4},\n\t\t{{ 0x01, 0x00 }, 2},\n\t\t{{ 0x01, 0x00, 0x73, 0xaf }, 4},\n\t\t{{ 0x04, 0x00 }, 2},\n\t\t{{ 0x00, 0x04 }, 2},\n\t\t{{ 0x00, 0x04, 0x00, 0x0a }, 4},\n\t\t{{ 0x04, 0x14 }, 2},\n\t\t{{ 0x04, 0x14, 0x00, 0x00 }, 4},\n\t};\n\n\tem28xx_gpio_set(dev, terratec_h5_init);\n\tem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x40);\n\tusleep_range(10000, 11000);\n\tem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x45);\n\tusleep_range(10000, 11000);\n\n\tdev->i2c_client[dev->def_i2c_bus].addr = 0x82 >> 1;\n\n\tfor (i = 0; i < ARRAY_SIZE(regs); i++)\n\t\ti2c_master_send(&dev->i2c_client[dev->def_i2c_bus],\n\t\t\t\tregs[i].r, regs[i].len);\n\tem28xx_gpio_set(dev, terratec_h5_end);\n};\n\nstatic void terratec_htc_stick_init(struct em28xx *dev)\n{\n\tint i;\n\n\t \n\tstatic const struct em28xx_reg_seq terratec_htc_stick_init[] = {\n\t\t{EM2820_R08_GPIO_CTRL,\t\t0xff,\t0xff,\t10},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xf6,\t0xff,\t100},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xe6,\t0xff,\t50},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xf6,\t0xff,\t100},\n\t\t{\t-1,\t\t\t-1,\t-1,\t-1},\n\t};\n\tstatic const struct em28xx_reg_seq terratec_htc_stick_end[] = {\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xb6,\t0xff,\t100},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xf6,\t0xff,\t50},\n\t\t{\t-1,\t\t\t-1,\t-1,\t-1},\n\t};\n\n\t \n\tstatic const struct {\n\t\tunsigned char r[4];\n\t\tint len;\n\t} regs[] = {\n\t\t{{ 0x06, 0x02, 0x00, 0x31 }, 4},\n\t\t{{ 0x01, 0x02 }, 2},\n\t\t{{ 0x01, 0x02, 0x00, 0xc6 }, 4},\n\t\t{{ 0x01, 0x00 }, 2},\n\t\t{{ 0x01, 0x00, 0xff, 0xaf }, 4},\n\t};\n\n\tem28xx_gpio_set(dev, terratec_htc_stick_init);\n\n\tem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x40);\n\tusleep_range(10000, 11000);\n\tem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x44);\n\tusleep_range(10000, 11000);\n\n\tdev->i2c_client[dev->def_i2c_bus].addr = 0x82 >> 1;\n\n\tfor (i = 0; i < ARRAY_SIZE(regs); i++)\n\t\ti2c_master_send(&dev->i2c_client[dev->def_i2c_bus],\n\t\t\t\tregs[i].r, regs[i].len);\n\n\tem28xx_gpio_set(dev, terratec_htc_stick_end);\n};\n\nstatic void terratec_htc_usb_xs_init(struct em28xx *dev)\n{\n\tint i;\n\n\tstatic const struct em28xx_reg_seq terratec_htc_usb_xs_init[] = {\n\t\t{EM2820_R08_GPIO_CTRL,\t\t0xff,\t0xff,\t10},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xb2,\t0xff,\t100},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xb2,\t0xff,\t50},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xb6,\t0xff,\t100},\n\t\t{\t-1,\t\t\t-1,\t-1,\t-1},\n\t};\n\tstatic const struct em28xx_reg_seq terratec_htc_usb_xs_end[] = {\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xa6,\t0xff,\t100},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xa6,\t0xff,\t50},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xe6,\t0xff,\t100},\n\t\t{\t-1,\t\t\t-1,\t-1,\t-1},\n\t};\n\n\t \n\tstatic const struct {\n\t\tunsigned char r[4];\n\t\tint len;\n\t} regs[] = {\n\t\t{{ 0x06, 0x02, 0x00, 0x31 }, 4},\n\t\t{{ 0x01, 0x02 }, 2},\n\t\t{{ 0x01, 0x02, 0x00, 0xc6 }, 4},\n\t\t{{ 0x01, 0x00 }, 2},\n\t\t{{ 0x01, 0x00, 0xff, 0xaf }, 4},\n\t\t{{ 0x01, 0x00, 0x03, 0xa0 }, 4},\n\t\t{{ 0x01, 0x00 }, 2},\n\t\t{{ 0x01, 0x00, 0x73, 0xaf }, 4},\n\t\t{{ 0x04, 0x00 }, 2},\n\t\t{{ 0x00, 0x04 }, 2},\n\t\t{{ 0x00, 0x04, 0x00, 0x0a }, 4},\n\t\t{{ 0x04, 0x14 }, 2},\n\t\t{{ 0x04, 0x14, 0x00, 0x00 }, 4},\n\t};\n\n\tem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x40);\n\n\tem28xx_gpio_set(dev, terratec_htc_usb_xs_init);\n\n\tem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x40);\n\tusleep_range(10000, 11000);\n\tem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x44);\n\tusleep_range(10000, 11000);\n\n\tdev->i2c_client[dev->def_i2c_bus].addr = 0x82 >> 1;\n\n\tfor (i = 0; i < ARRAY_SIZE(regs); i++)\n\t\ti2c_master_send(&dev->i2c_client[dev->def_i2c_bus],\n\t\t\t\tregs[i].r, regs[i].len);\n\n\tem28xx_gpio_set(dev, terratec_htc_usb_xs_end);\n};\n\nstatic void pctv_520e_init(struct em28xx *dev)\n{\n\t \n\tint i;\n\tstatic const struct {\n\t\tunsigned char r[4];\n\t\tint len;\n\t} regs[] = {\n\t\t{{ 0x06, 0x02, 0x00, 0x31 }, 4},\n\t\t{{ 0x01, 0x02 }, 2},\n\t\t{{ 0x01, 0x02, 0x00, 0xc6 }, 4},\n\t\t{{ 0x01, 0x00 }, 2},\n\t\t{{ 0x01, 0x00, 0xff, 0xaf }, 4},\n\t\t{{ 0x01, 0x00, 0x03, 0xa0 }, 4},\n\t\t{{ 0x01, 0x00 }, 2},\n\t\t{{ 0x01, 0x00, 0x73, 0xaf }, 4},\n\t};\n\n\tdev->i2c_client[dev->def_i2c_bus].addr = 0x82 >> 1;  \n\n\tfor (i = 0; i < ARRAY_SIZE(regs); i++)\n\t\ti2c_master_send(&dev->i2c_client[dev->def_i2c_bus],\n\t\t\t\tregs[i].r, regs[i].len);\n};\n\nstatic int em28xx_pctv_290e_set_lna(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct em28xx_i2c_bus *i2c_bus = fe->dvb->priv;\n\tstruct em28xx *dev = i2c_bus->dev;\n#ifdef CONFIG_GPIOLIB\n\tstruct em28xx_dvb *dvb = dev->dvb;\n\tint ret;\n\tunsigned long flags;\n\n\tif (c->lna == 1)\n\t\tflags = GPIOF_OUT_INIT_HIGH;  \n\telse\n\t\tflags = GPIOF_OUT_INIT_LOW;  \n\n\tret = gpio_request_one(dvb->lna_gpio, flags, NULL);\n\tif (ret)\n\t\tdev_err(&dev->intf->dev, \"gpio request failed %d\\n\", ret);\n\telse\n\t\tgpio_free(dvb->lna_gpio);\n\n\treturn ret;\n#else\n\tdev_warn(&dev->intf->dev, \"%s: LNA control is disabled (lna=%u)\\n\",\n\t\t KBUILD_MODNAME, c->lna);\n\treturn 0;\n#endif\n}\n\nstatic int em28xx_pctv_292e_set_lna(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct em28xx_i2c_bus *i2c_bus = fe->dvb->priv;\n\tstruct em28xx *dev = i2c_bus->dev;\n\tu8 lna;\n\n\tif (c->lna == 1)\n\t\tlna = 0x01;\n\telse\n\t\tlna = 0x00;\n\n\treturn em28xx_write_reg_bits(dev, EM2874_R80_GPIO_P0_CTRL, lna, 0x01);\n}\n\nstatic int em28xx_mt352_terratec_xs_init(struct dvb_frontend *fe)\n{\n\t \n\tstatic u8 clock_config[]   = { CLOCK_CTL,  0x38, 0x2c };\n\tstatic u8 reset[]          = { RESET,      0x80 };\n\tstatic u8 adc_ctl_1_cfg[]  = { ADC_CTL_1,  0x40 };\n\tstatic u8 agc_cfg[]        = { AGC_TARGET, 0x28, 0xa0 };\n\tstatic u8 input_freq_cfg[] = { INPUT_FREQ_1, 0x31, 0xb8 };\n\tstatic u8 rs_err_cfg[]     = { RS_ERR_PER_1, 0x00, 0x4d };\n\tstatic u8 capt_range_cfg[] = { CAPT_RANGE, 0x32 };\n\tstatic u8 trl_nom_cfg[]    = { TRL_NOMINAL_RATE_1, 0x64, 0x00 };\n\tstatic u8 tps_given_cfg[]  = { TPS_GIVEN_1, 0x40, 0x80, 0x50 };\n\tstatic u8 tuner_go[]       = { TUNER_GO, 0x01};\n\n\tmt352_write(fe, clock_config,   sizeof(clock_config));\n\tusleep_range(200, 250);\n\tmt352_write(fe, reset,          sizeof(reset));\n\tmt352_write(fe, adc_ctl_1_cfg,  sizeof(adc_ctl_1_cfg));\n\tmt352_write(fe, agc_cfg,        sizeof(agc_cfg));\n\tmt352_write(fe, input_freq_cfg, sizeof(input_freq_cfg));\n\tmt352_write(fe, rs_err_cfg,     sizeof(rs_err_cfg));\n\tmt352_write(fe, capt_range_cfg, sizeof(capt_range_cfg));\n\tmt352_write(fe, trl_nom_cfg,    sizeof(trl_nom_cfg));\n\tmt352_write(fe, tps_given_cfg,  sizeof(tps_given_cfg));\n\tmt352_write(fe, tuner_go,       sizeof(tuner_go));\n\treturn 0;\n}\n\nstatic void px_bcud_init(struct em28xx *dev)\n{\n\tint i;\n\tstatic const struct {\n\t\tunsigned char r[4];\n\t\tint len;\n\t} regs1[] = {\n\t\t{{ 0x0e, 0x77 }, 2},\n\t\t{{ 0x0f, 0x77 }, 2},\n\t\t{{ 0x03, 0x90 }, 2},\n\t}, regs2[] = {\n\t\t{{ 0x07, 0x01 }, 2},\n\t\t{{ 0x08, 0x10 }, 2},\n\t\t{{ 0x13, 0x00 }, 2},\n\t\t{{ 0x17, 0x00 }, 2},\n\t\t{{ 0x03, 0x01 }, 2},\n\t\t{{ 0x10, 0xb1 }, 2},\n\t\t{{ 0x11, 0x40 }, 2},\n\t\t{{ 0x85, 0x7a }, 2},\n\t\t{{ 0x87, 0x04 }, 2},\n\t};\n\tstatic const struct em28xx_reg_seq gpio[] = {\n\t\t{EM28XX_R06_I2C_CLK,\t\t0x40,\t0xff,\t300},\n\t\t{EM2874_R80_GPIO_P0_CTRL,\t0xfd,\t0xff,\t60},\n\t\t{EM28XX_R15_RGAIN,\t\t0x20,\t0xff,\t0},\n\t\t{EM28XX_R16_GGAIN,\t\t0x20,\t0xff,\t0},\n\t\t{EM28XX_R17_BGAIN,\t\t0x20,\t0xff,\t0},\n\t\t{EM28XX_R18_ROFFSET,\t\t0x00,\t0xff,\t0},\n\t\t{EM28XX_R19_GOFFSET,\t\t0x00,\t0xff,\t0},\n\t\t{EM28XX_R1A_BOFFSET,\t\t0x00,\t0xff,\t0},\n\t\t{EM28XX_R23_UOFFSET,\t\t0x00,\t0xff,\t0},\n\t\t{EM28XX_R24_VOFFSET,\t\t0x00,\t0xff,\t0},\n\t\t{EM28XX_R26_COMPR,\t\t0x00,\t0xff,\t0},\n\t\t{0x13,\t\t\t\t0x08,\t0xff,\t0},\n\t\t{EM28XX_R12_VINENABLE,\t\t0x27,\t0xff,\t0},\n\t\t{EM28XX_R0C_USBSUSP,\t\t0x10,\t0xff,\t0},\n\t\t{EM28XX_R27_OUTFMT,\t\t0x00,\t0xff,\t0},\n\t\t{EM28XX_R10_VINMODE,\t\t0x00,\t0xff,\t0},\n\t\t{EM28XX_R11_VINCTRL,\t\t0x11,\t0xff,\t0},\n\t\t{EM2874_R50_IR_CONFIG,\t\t0x01,\t0xff,\t0},\n\t\t{EM2874_R5F_TS_ENABLE,\t\t0x80,\t0xff,\t0},\n\t\t{EM28XX_R06_I2C_CLK,\t\t0x46,\t0xff,\t0},\n\t};\n\tem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x46);\n\t \n\tdev->dvb->i2c_client_demod->addr = 0x14;\n\tfor (i = 0; i < ARRAY_SIZE(regs1); i++)\n\t\ti2c_master_send(dev->dvb->i2c_client_demod,\n\t\t\t\tregs1[i].r, regs1[i].len);\n\t \n\tdev->dvb->i2c_client_demod->addr = 0x15;\n\tfor (i = 0; i < ARRAY_SIZE(regs2); i++)\n\t\ti2c_master_send(dev->dvb->i2c_client_demod, regs2[i].r,\n\t\t\t\tregs2[i].len);\n\tfor (i = 0; i < ARRAY_SIZE(gpio); i++) {\n\t\tem28xx_write_reg_bits(dev, gpio[i].reg, gpio[i].val,\n\t\t\t\t      gpio[i].mask);\n\t\tif (gpio[i].sleep > 0)\n\t\t\tmsleep(gpio[i].sleep);\n\t}\n};\n\nstatic struct mt352_config terratec_xs_mt352_cfg = {\n\t.demod_address = (0x1e >> 1),\n\t.no_tuner = 1,\n\t.if2 = 45600,\n\t.demod_init = em28xx_mt352_terratec_xs_init,\n};\n\nstatic struct tda10023_config em28xx_tda10023_config = {\n\t.demod_address = 0x0c,\n\t.invert = 1,\n};\n\nstatic struct cxd2820r_config em28xx_cxd2820r_config = {\n\t.i2c_address = (0xd8 >> 1),\n\t.ts_mode = CXD2820R_TS_SERIAL,\n};\n\nstatic struct tda18271_config em28xx_cxd2820r_tda18271_config = {\n\t.output_opt = TDA18271_OUTPUT_LT_OFF,\n\t.gate = TDA18271_GATE_DIGITAL,\n};\n\nstatic struct zl10353_config em28xx_zl10353_no_i2c_gate_dev = {\n\t.demod_address = (0x1e >> 1),\n\t.disable_i2c_gate_ctrl = 1,\n\t.no_tuner = 1,\n\t.parallel_ts = 1,\n};\n\nstatic struct mt2060_config em28xx_mt2060_config = {\n\t.i2c_address = 0x60,\n};\n\nstatic struct qt1010_config em28xx_qt1010_config = {\n\t.i2c_address = 0x62\n};\n\nstatic const struct mb86a20s_config c3tech_duo_mb86a20s_config = {\n\t.demod_address = 0x10,\n\t.is_serial = true,\n};\n\nstatic struct tda18271_std_map mb86a20s_tda18271_config = {\n\t.dvbt_6   = { .if_freq = 4000, .agc_mode = 3, .std = 4,\n\t\t      .if_lvl = 1, .rfagc_top = 0x37, },\n};\n\nstatic struct tda18271_config c3tech_duo_tda18271_config = {\n\t.std_map = &mb86a20s_tda18271_config,\n\t.gate    = TDA18271_GATE_DIGITAL,\n\t.small_i2c = TDA18271_03_BYTE_CHUNK_INIT,\n};\n\nstatic struct tda18271_std_map drx_j_std_map = {\n\t.atsc_6   = { .if_freq = 5000, .agc_mode = 3, .std = 0, .if_lvl = 1,\n\t\t      .rfagc_top = 0x37, },\n\t.qam_6    = { .if_freq = 5380, .agc_mode = 3, .std = 3, .if_lvl = 1,\n\t\t      .rfagc_top = 0x37, },\n};\n\nstatic struct tda18271_config pinnacle_80e_dvb_config = {\n\t.std_map = &drx_j_std_map,\n\t.gate    = TDA18271_GATE_DIGITAL,\n\t.role    = TDA18271_MASTER,\n};\n\nstatic struct lgdt3306a_config hauppauge_01595_lgdt3306a_config = {\n\t.qam_if_khz         = 4000,\n\t.vsb_if_khz         = 3250,\n\t.spectral_inversion = 0,\n\t.deny_i2c_rptr      = 0,\n\t.mpeg_mode          = LGDT3306A_MPEG_SERIAL,\n\t.tpclk_edge         = LGDT3306A_TPCLK_RISING_EDGE,\n\t.tpvalid_polarity   = LGDT3306A_TP_VALID_HIGH,\n\t.xtalMHz            = 25,\n};\n\n \n\nstatic noinline_for_stack int em28xx_attach_xc3028(u8 addr, struct em28xx *dev)\n{\n\tstruct dvb_frontend *fe;\n\tstruct xc2028_config cfg;\n\tstruct xc2028_ctrl ctl;\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\tcfg.i2c_adap  = &dev->i2c_adap[dev->def_i2c_bus];\n\tcfg.i2c_addr  = addr;\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tem28xx_setup_xc3028(dev, &ctl);\n\tcfg.ctrl  = &ctl;\n\n\tif (!dev->dvb->fe[0]) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"dvb frontend not attached. Can't attach xc3028\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfe = dvb_attach(xc2028_attach, dev->dvb->fe[0], &cfg);\n\tif (!fe) {\n\t\tdev_err(&dev->intf->dev, \"xc3028 attach failed\\n\");\n\t\tdvb_frontend_detach(dev->dvb->fe[0]);\n\t\tdev->dvb->fe[0] = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(&dev->intf->dev, \"xc3028 attached\\n\");\n\n\treturn 0;\n}\n\n \n\nstatic int em28xx_register_dvb(struct em28xx_dvb *dvb, struct module *module,\n\t\t\t       struct em28xx *dev, struct device *device)\n{\n\tint result;\n\tbool create_rf_connector = false;\n\n\tmutex_init(&dvb->lock);\n\n\t \n\tresult = dvb_register_adapter(&dvb->adapter,\n\t\t\t\t      dev_name(&dev->intf->dev), module,\n\t\t\t\t      device, adapter_nr);\n\tif (result < 0) {\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"dvb_register_adapter failed (errno = %d)\\n\",\n\t\t\t result);\n\t\tgoto fail_adapter;\n\t}\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tdvb->adapter.mdev = dev->media_dev;\n#endif\n\n\t \n\tdvb->fe[0]->ops.ts_bus_ctrl = em28xx_dvb_bus_ctrl;\n\tif (dvb->fe[1])\n\t\tdvb->fe[1]->ops.ts_bus_ctrl = em28xx_dvb_bus_ctrl;\n\n\tdvb->adapter.priv = &dev->i2c_bus[dev->def_i2c_bus];\n\n\t \n\tresult = dvb_register_frontend(&dvb->adapter, dvb->fe[0]);\n\tif (result < 0) {\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"dvb_register_frontend failed (errno = %d)\\n\",\n\t\t\t result);\n\t\tgoto fail_frontend0;\n\t}\n\n\t \n\tif (dvb->fe[1]) {\n\t\tresult = dvb_register_frontend(&dvb->adapter, dvb->fe[1]);\n\t\tif (result < 0) {\n\t\t\tdev_warn(&dev->intf->dev,\n\t\t\t\t \"2nd dvb_register_frontend failed (errno = %d)\\n\",\n\t\t\t\t result);\n\t\t\tgoto fail_frontend1;\n\t\t}\n\t}\n\n\t \n\tdvb->demux.dmx.capabilities =\n\t\tDMX_TS_FILTERING | DMX_SECTION_FILTERING |\n\t\tDMX_MEMORY_BASED_FILTERING;\n\tdvb->demux.priv       = dvb;\n\tdvb->demux.filternum  = 256;\n\tdvb->demux.feednum    = 256;\n\tdvb->demux.start_feed = em28xx_start_feed;\n\tdvb->demux.stop_feed  = em28xx_stop_feed;\n\n\tresult = dvb_dmx_init(&dvb->demux);\n\tif (result < 0) {\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"dvb_dmx_init failed (errno = %d)\\n\",\n\t\t\t result);\n\t\tgoto fail_dmx;\n\t}\n\n\tdvb->dmxdev.filternum    = 256;\n\tdvb->dmxdev.demux        = &dvb->demux.dmx;\n\tdvb->dmxdev.capabilities = 0;\n\tresult = dvb_dmxdev_init(&dvb->dmxdev, &dvb->adapter);\n\tif (result < 0) {\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"dvb_dmxdev_init failed (errno = %d)\\n\",\n\t\t\t result);\n\t\tgoto fail_dmxdev;\n\t}\n\n\tdvb->fe_hw.source = DMX_FRONTEND_0;\n\tresult = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_hw);\n\tif (result < 0) {\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"add_frontend failed (DMX_FRONTEND_0, errno = %d)\\n\",\n\t\t\t result);\n\t\tgoto fail_fe_hw;\n\t}\n\n\tdvb->fe_mem.source = DMX_MEMORY_FE;\n\tresult = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_mem);\n\tif (result < 0) {\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"add_frontend failed (DMX_MEMORY_FE, errno = %d)\\n\",\n\t\t\t result);\n\t\tgoto fail_fe_mem;\n\t}\n\n\tresult = dvb->demux.dmx.connect_frontend(&dvb->demux.dmx, &dvb->fe_hw);\n\tif (result < 0) {\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"connect_frontend failed (errno = %d)\\n\",\n\t\t\t result);\n\t\tgoto fail_fe_conn;\n\t}\n\n\t \n\tdvb_net_init(&dvb->adapter, &dvb->net, &dvb->demux.dmx);\n\n\t \n\tif (!dev->has_video || dev->tuner_type == TUNER_ABSENT)\n\t\tcreate_rf_connector = true;\n\n\tresult = dvb_create_media_graph(&dvb->adapter, create_rf_connector);\n\tif (result < 0)\n\t\tgoto fail_create_graph;\n\n\treturn 0;\n\nfail_create_graph:\n\tdvb_net_release(&dvb->net);\nfail_fe_conn:\n\tdvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_mem);\nfail_fe_mem:\n\tdvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_hw);\nfail_fe_hw:\n\tdvb_dmxdev_release(&dvb->dmxdev);\nfail_dmxdev:\n\tdvb_dmx_release(&dvb->demux);\nfail_dmx:\n\tif (dvb->fe[1])\n\t\tdvb_unregister_frontend(dvb->fe[1]);\n\tdvb_unregister_frontend(dvb->fe[0]);\nfail_frontend1:\n\tif (dvb->fe[1])\n\t\tdvb_frontend_detach(dvb->fe[1]);\nfail_frontend0:\n\tdvb_frontend_detach(dvb->fe[0]);\n\tdvb_unregister_adapter(&dvb->adapter);\nfail_adapter:\n\treturn result;\n}\n\nstatic void em28xx_unregister_dvb(struct em28xx_dvb *dvb)\n{\n\tdvb_net_release(&dvb->net);\n\tdvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_mem);\n\tdvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_hw);\n\tdvb_dmxdev_release(&dvb->dmxdev);\n\tdvb_dmx_release(&dvb->demux);\n\tif (dvb->fe[1])\n\t\tdvb_unregister_frontend(dvb->fe[1]);\n\tdvb_unregister_frontend(dvb->fe[0]);\n\tif (dvb->fe[1] && !dvb->dont_attach_fe1)\n\t\tdvb_frontend_detach(dvb->fe[1]);\n\tdvb_frontend_detach(dvb->fe[0]);\n\tdvb_unregister_adapter(&dvb->adapter);\n}\n\nstatic int em28174_dvb_init_pctv_460e(struct em28xx *dev)\n{\n\tstruct em28xx_dvb *dvb = dev->dvb;\n\tstruct tda10071_platform_data tda10071_pdata = {};\n\tstruct a8293_platform_data a8293_pdata = {};\n\n\t \n\ttda10071_pdata.clk = 40444000;  \n\ttda10071_pdata.i2c_wr_max = 64;\n\ttda10071_pdata.ts_mode = TDA10071_TS_SERIAL;\n\ttda10071_pdata.pll_multiplier = 20;\n\ttda10071_pdata.tuner_i2c_addr = 0x14;\n\n\tdvb->i2c_client_demod = dvb_module_probe(\"tda10071\", \"tda10071_cx24118\",\n\t\t\t\t\t\t &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t\t 0x55, &tda10071_pdata);\n\tif (!dvb->i2c_client_demod)\n\t\treturn -ENODEV;\n\n\tdvb->fe[0] = tda10071_pdata.get_dvb_frontend(dvb->i2c_client_demod);\n\n\t \n\ta8293_pdata.dvb_frontend = dvb->fe[0];\n\n\tdvb->i2c_client_sec = dvb_module_probe(\"a8293\", NULL,\n\t\t\t\t\t       &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t       0x08, &a8293_pdata);\n\tif (!dvb->i2c_client_sec) {\n\t\tdvb_module_release(dvb->i2c_client_demod);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int em28178_dvb_init_pctv_461e(struct em28xx *dev)\n{\n\tstruct em28xx_dvb *dvb = dev->dvb;\n\tstruct i2c_adapter *i2c_adapter;\n\tstruct m88ds3103_platform_data m88ds3103_pdata = {};\n\tstruct ts2020_config ts2020_config = {};\n\tstruct a8293_platform_data a8293_pdata = {};\n\n\t \n\tm88ds3103_pdata.clk = 27000000;\n\tm88ds3103_pdata.i2c_wr_max = 33;\n\tm88ds3103_pdata.ts_mode = M88DS3103_TS_PARALLEL;\n\tm88ds3103_pdata.ts_clk = 16000;\n\tm88ds3103_pdata.ts_clk_pol = 1;\n\tm88ds3103_pdata.agc = 0x99;\n\n\tdvb->i2c_client_demod = dvb_module_probe(\"m88ds3103\", NULL,\n\t\t\t\t\t\t &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t\t 0x68, &m88ds3103_pdata);\n\tif (!dvb->i2c_client_demod)\n\t\treturn -ENODEV;\n\n\tdvb->fe[0] = m88ds3103_pdata.get_dvb_frontend(dvb->i2c_client_demod);\n\ti2c_adapter = m88ds3103_pdata.get_i2c_adapter(dvb->i2c_client_demod);\n\n\t \n\tts2020_config.fe = dvb->fe[0];\n\n\tdvb->i2c_client_tuner = dvb_module_probe(\"ts2020\", \"ts2022\",\n\t\t\t\t\t\t i2c_adapter,\n\t\t\t\t\t\t 0x60, &ts2020_config);\n\tif (!dvb->i2c_client_tuner) {\n\t\tdvb_module_release(dvb->i2c_client_demod);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tdvb->fe[0]->ops.read_signal_strength =\n\t\t\tdvb->fe[0]->ops.tuner_ops.get_rf_strength;\n\n\t \n\ta8293_pdata.dvb_frontend = dvb->fe[0];\n\t \n\ta8293_pdata.volt_slew_nanos_per_mv = 20;\n\n\tdvb->i2c_client_sec = dvb_module_probe(\"a8293\", NULL,\n\t\t\t\t\t       &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t       0x08, &a8293_pdata);\n\tif (!dvb->i2c_client_sec) {\n\t\tdvb_module_release(dvb->i2c_client_tuner);\n\t\tdvb_module_release(dvb->i2c_client_demod);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int em28178_dvb_init_pctv_461e_v2(struct em28xx *dev)\n{\n\tstruct em28xx_dvb *dvb = dev->dvb;\n\tstruct i2c_adapter *i2c_adapter;\n\tstruct m88ds3103_platform_data m88ds3103_pdata = {};\n\tstruct ts2020_config ts2020_config = {};\n\tstruct a8293_platform_data a8293_pdata = {};\n\n\t \n\tm88ds3103_pdata.clk = 27000000;\n\tm88ds3103_pdata.i2c_wr_max = 33;\n\tm88ds3103_pdata.ts_mode = M88DS3103_TS_PARALLEL;\n\tm88ds3103_pdata.ts_clk = 16000;\n\tm88ds3103_pdata.ts_clk_pol = 0;\n\tm88ds3103_pdata.agc = 0x99;\n\tm88ds3103_pdata.agc_inv = 0;\n\tm88ds3103_pdata.spec_inv = 0;\n\tdvb->i2c_client_demod = dvb_module_probe(\"m88ds3103\", \"m88ds3103b\",\n\t\t\t\t\t\t &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t\t 0x6a, &m88ds3103_pdata);\n\n\tif (!dvb->i2c_client_demod)\n\t\treturn -ENODEV;\n\n\tdvb->fe[0] = m88ds3103_pdata.get_dvb_frontend(dvb->i2c_client_demod);\n\ti2c_adapter = m88ds3103_pdata.get_i2c_adapter(dvb->i2c_client_demod);\n\n\t \n\tts2020_config.fe = dvb->fe[0];\n\tdvb->i2c_client_tuner = dvb_module_probe(\"ts2020\", \"ts2022\",\n\t\t\t\t\t\t i2c_adapter,\n\t\t\t\t\t\t 0x60, &ts2020_config);\n\tif (!dvb->i2c_client_tuner) {\n\t\tdvb_module_release(dvb->i2c_client_demod);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tdvb->fe[0]->ops.read_signal_strength =\n\t\t\tdvb->fe[0]->ops.tuner_ops.get_rf_strength;\n\n\t \n\ta8293_pdata.dvb_frontend = dvb->fe[0];\n\tdvb->i2c_client_sec = dvb_module_probe(\"a8293\", NULL,\n\t\t\t\t\t       &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t       0x08, &a8293_pdata);\n\tif (!dvb->i2c_client_sec) {\n\t\tdvb_module_release(dvb->i2c_client_tuner);\n\t\tdvb_module_release(dvb->i2c_client_demod);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int em28178_dvb_init_pctv_292e(struct em28xx *dev)\n{\n\tstruct em28xx_dvb *dvb = dev->dvb;\n\tstruct i2c_adapter *adapter;\n\tstruct si2168_config si2168_config = {};\n\tstruct si2157_config si2157_config = {};\n\n\t \n\tsi2168_config.i2c_adapter = &adapter;\n\tsi2168_config.fe = &dvb->fe[0];\n\tsi2168_config.ts_mode = SI2168_TS_PARALLEL;\n\tsi2168_config.spectral_inversion = true;\n\n\tdvb->i2c_client_demod = dvb_module_probe(\"si2168\", NULL,\n\t\t\t\t\t\t &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t\t 0x64, &si2168_config);\n\tif (!dvb->i2c_client_demod)\n\t\treturn -ENODEV;\n\n\t \n\tsi2157_config.fe = dvb->fe[0];\n\tsi2157_config.if_port = 1;\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tsi2157_config.mdev = dev->media_dev;\n#endif\n\tdvb->i2c_client_tuner = dvb_module_probe(\"si2157\", NULL,\n\t\t\t\t\t\t adapter,\n\t\t\t\t\t\t 0x60, &si2157_config);\n\tif (!dvb->i2c_client_tuner) {\n\t\tdvb_module_release(dvb->i2c_client_demod);\n\t\treturn -ENODEV;\n\t}\n\tdvb->fe[0]->ops.set_lna = em28xx_pctv_292e_set_lna;\n\n\treturn 0;\n}\n\nstatic int em28178_dvb_init_terratec_t2_stick_hd(struct em28xx *dev)\n{\n\tstruct em28xx_dvb *dvb = dev->dvb;\n\tstruct i2c_adapter *adapter;\n\tstruct si2168_config si2168_config = {};\n\tstruct si2157_config si2157_config = {};\n\n\t \n\tsi2168_config.i2c_adapter = &adapter;\n\tsi2168_config.fe = &dvb->fe[0];\n\tsi2168_config.ts_mode = SI2168_TS_PARALLEL;\n\n\tdvb->i2c_client_demod = dvb_module_probe(\"si2168\", NULL,\n\t\t\t\t\t\t &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t\t 0x64, &si2168_config);\n\tif (!dvb->i2c_client_demod)\n\t\treturn -ENODEV;\n\n\t \n\tmemset(&si2157_config, 0, sizeof(si2157_config));\n\tsi2157_config.fe = dvb->fe[0];\n\tsi2157_config.if_port = 0;\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tsi2157_config.mdev = dev->media_dev;\n#endif\n\tdvb->i2c_client_tuner = dvb_module_probe(\"si2157\", \"si2146\",\n\t\t\t\t\t\t adapter,\n\t\t\t\t\t\t 0x60, &si2157_config);\n\tif (!dvb->i2c_client_tuner) {\n\t\tdvb_module_release(dvb->i2c_client_demod);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int em28178_dvb_init_plex_px_bcud(struct em28xx *dev)\n{\n\tstruct em28xx_dvb *dvb = dev->dvb;\n\tstruct tc90522_config tc90522_config = {};\n\tstruct qm1d1c0042_config qm1d1c0042_config = {};\n\n\t \n\tdvb->i2c_client_demod = dvb_module_probe(\"tc90522\", \"tc90522sat\",\n\t\t\t\t\t\t &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t\t 0x15, &tc90522_config);\n\tif (!dvb->i2c_client_demod)\n\t\treturn -ENODEV;\n\n\t \n\tqm1d1c0042_config.fe = tc90522_config.fe;\n\tqm1d1c0042_config.lpf = 1;\n\n\tdvb->i2c_client_tuner = dvb_module_probe(\"qm1d1c0042\", NULL,\n\t\t\t\t\t\t tc90522_config.tuner_i2c,\n\t\t\t\t\t\t 0x61, &qm1d1c0042_config);\n\tif (!dvb->i2c_client_tuner) {\n\t\tdvb_module_release(dvb->i2c_client_demod);\n\t\treturn -ENODEV;\n\t}\n\n\tdvb->fe[0] = tc90522_config.fe;\n\tpx_bcud_init(dev);\n\n\treturn 0;\n}\n\nstatic int em28174_dvb_init_hauppauge_wintv_dualhd_dvb(struct em28xx *dev)\n{\n\tstruct em28xx_dvb *dvb = dev->dvb;\n\tstruct i2c_adapter *adapter;\n\tstruct si2168_config si2168_config = {};\n\tstruct si2157_config si2157_config = {};\n\tunsigned char addr;\n\n\t \n\tsi2168_config.i2c_adapter = &adapter;\n\tsi2168_config.fe = &dvb->fe[0];\n\tsi2168_config.ts_mode = SI2168_TS_SERIAL;\n\tsi2168_config.spectral_inversion = true;\n\taddr = (dev->ts == PRIMARY_TS) ? 0x64 : 0x67;\n\n\tdvb->i2c_client_demod = dvb_module_probe(\"si2168\", NULL,\n\t\t\t\t\t\t &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t\t addr, &si2168_config);\n\tif (!dvb->i2c_client_demod)\n\t\treturn -ENODEV;\n\n\t \n\tmemset(&si2157_config, 0, sizeof(si2157_config));\n\tsi2157_config.fe = dvb->fe[0];\n\tsi2157_config.if_port = 1;\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tsi2157_config.mdev = dev->media_dev;\n#endif\n\taddr = (dev->ts == PRIMARY_TS) ? 0x60 : 0x63;\n\n\tdvb->i2c_client_tuner = dvb_module_probe(\"si2157\", NULL,\n\t\t\t\t\t\t adapter,\n\t\t\t\t\t\t addr, &si2157_config);\n\tif (!dvb->i2c_client_tuner) {\n\t\tdvb_module_release(dvb->i2c_client_demod);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int em28174_dvb_init_hauppauge_wintv_dualhd_01595(struct em28xx *dev)\n{\n\tstruct em28xx_dvb *dvb = dev->dvb;\n\tstruct i2c_adapter *adapter;\n\tstruct lgdt3306a_config lgdt3306a_config =  {};\n\tstruct si2157_config si2157_config = {};\n\tunsigned char addr;\n\n\t \n\tlgdt3306a_config = hauppauge_01595_lgdt3306a_config;\n\tlgdt3306a_config.fe = &dvb->fe[0];\n\tlgdt3306a_config.i2c_adapter = &adapter;\n\taddr = (dev->ts == PRIMARY_TS) ? 0x59 : 0x0e;\n\n\tdvb->i2c_client_demod = dvb_module_probe(\"lgdt3306a\", NULL,\n\t\t\t\t\t\t &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t\t addr, &lgdt3306a_config);\n\tif (!dvb->i2c_client_demod)\n\t\treturn -ENODEV;\n\n\t \n\tsi2157_config.fe = dvb->fe[0];\n\tsi2157_config.if_port = 1;\n\tsi2157_config.inversion = 1;\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tsi2157_config.mdev = dev->media_dev;\n#endif\n\taddr = (dev->ts == PRIMARY_TS) ? 0x60 : 0x62;\n\n\tdvb->i2c_client_tuner = dvb_module_probe(\"si2157\", NULL,\n\t\t\t\t\t\t adapter,\n\t\t\t\t\t\t addr, &si2157_config);\n\tif (!dvb->i2c_client_tuner) {\n\t\tdvb_module_release(dvb->i2c_client_demod);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int em2874_dvb_init_hauppauge_usb_quadhd(struct em28xx *dev)\n{\n\tstruct em28xx_dvb *dvb = dev->dvb;\n\tstruct mxl692_config mxl692_config = {};\n\tunsigned char addr;\n\n\t \n\tmxl692_config.id = (dev->ts == PRIMARY_TS) ? 0 : 1;\n\tmxl692_config.fe = &dvb->fe[0];\n\taddr = (dev->ts == PRIMARY_TS) ? 0x60 : 0x63;\n\n\tdvb->i2c_client_demod = dvb_module_probe(\"mxl692\", NULL,\n\t\t\t\t\t\t &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t\t addr, &mxl692_config);\n\tif (!dvb->i2c_client_demod)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int em28xx_dvb_init(struct em28xx *dev)\n{\n\tint result = 0, dvb_alt = 0;\n\tstruct em28xx_dvb *dvb;\n\tstruct usb_device *udev;\n\n\tif (dev->is_audio_only) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (!dev->board.has_dvb) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tdev_info(&dev->intf->dev, \"Binding DVB extension\\n\");\n\n\tdvb = kzalloc(sizeof(*dvb), GFP_KERNEL);\n\tif (!dvb)\n\t\treturn -ENOMEM;\n\n\tdev->dvb = dvb;\n\tdvb->fe[0] = NULL;\n\tdvb->fe[1] = NULL;\n\n\t \n\tif (dev->dvb_xfer_bulk) {\n\t\tresult = em28xx_alloc_urbs(dev, EM28XX_DIGITAL_MODE,\n\t\t\t\t\t   dev->dvb_xfer_bulk,\n\t\t\t\t\t   EM28XX_DVB_NUM_BUFS,\n\t\t\t\t\t   512,\n\t\t\t\t\t   EM28XX_DVB_BULK_PACKET_MULTIPLIER);\n\t} else {\n\t\tresult = em28xx_alloc_urbs(dev, EM28XX_DIGITAL_MODE,\n\t\t\t\t\t   dev->dvb_xfer_bulk,\n\t\t\t\t\t   EM28XX_DVB_NUM_BUFS,\n\t\t\t\t\t   dev->dvb_max_pkt_size_isoc,\n\t\t\t\t\t   EM28XX_DVB_NUM_ISOC_PACKETS);\n\t}\n\tif (result) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"failed to pre-allocate USB transfer buffers for DVB.\\n\");\n\t\tkfree(dvb);\n\t\tdev->dvb = NULL;\n\t\treturn result;\n\t}\n\n\tmutex_lock(&dev->lock);\n\tem28xx_set_mode(dev, EM28XX_DIGITAL_MODE);\n\t \n\tswitch (dev->model) {\n\tcase EM2874_BOARD_LEADERSHIP_ISDBT:\n\t\tdvb->fe[0] = dvb_attach(s921_attach,\n\t\t\t\t\t&sharp_isdbt,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\n\t\tif (!dvb->fe[0]) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tbreak;\n\tcase EM2883_BOARD_HAUPPAUGE_WINTV_HVR_850:\n\tcase EM2883_BOARD_HAUPPAUGE_WINTV_HVR_950:\n\tcase EM2880_BOARD_PINNACLE_PCTV_HD_PRO:\n\tcase EM2880_BOARD_AMD_ATI_TV_WONDER_HD_600:\n\t\tdvb->fe[0] = dvb_attach(lgdt330x_attach,\n\t\t\t\t\t&em2880_lgdt3303_dev,\n\t\t\t\t\t0x0e,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\t\tif (em28xx_attach_xc3028(0x61, dev) < 0) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbreak;\n\tcase EM2880_BOARD_KWORLD_DVB_310U:\n\t\tdvb->fe[0] = dvb_attach(zl10353_attach,\n\t\t\t\t\t&em28xx_zl10353_with_xc3028,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\t\tif (em28xx_attach_xc3028(0x61, dev) < 0) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbreak;\n\tcase EM2880_BOARD_HAUPPAUGE_WINTV_HVR_900:\n\tcase EM2882_BOARD_TERRATEC_HYBRID_XS:\n\tcase EM2880_BOARD_EMPIRE_DUAL_TV:\n\tcase EM2882_BOARD_ZOLID_HYBRID_TV_STICK:\n\t\tdvb->fe[0] = dvb_attach(zl10353_attach,\n\t\t\t\t\t&em28xx_zl10353_xc3028_no_i2c_gate,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\t\tif (em28xx_attach_xc3028(0x61, dev) < 0) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbreak;\n\tcase EM2880_BOARD_TERRATEC_HYBRID_XS:\n\tcase EM2880_BOARD_TERRATEC_HYBRID_XS_FR:\n\tcase EM2881_BOARD_PINNACLE_HYBRID_PRO:\n\tcase EM2882_BOARD_DIKOM_DK300:\n\tcase EM2882_BOARD_KWORLD_VS_DVBT:\n\t\t \n\t\tdvb->fe[0] = dvb_attach(zl10353_attach,\n\t\t\t\t\t&em28xx_zl10353_xc3028_no_i2c_gate,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\t\tif (!dvb->fe[0])\n\t\t\tdvb->fe[0] = dvb_attach(mt352_attach,\n\t\t\t\t\t\t&terratec_xs_mt352_cfg,\n\t\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\n\t\tif (em28xx_attach_xc3028(0x61, dev) < 0) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbreak;\n\tcase EM2870_BOARD_TERRATEC_XS_MT2060:\n\t\tdvb->fe[0] = dvb_attach(zl10353_attach,\n\t\t\t\t\t&em28xx_zl10353_no_i2c_gate_dev,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\t\tif (dvb->fe[0]) {\n\t\t\tdvb_attach(mt2060_attach, dvb->fe[0],\n\t\t\t\t   &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t   &em28xx_mt2060_config, 1220);\n\t\t}\n\t\tbreak;\n\tcase EM2870_BOARD_KWORLD_355U:\n\t\tdvb->fe[0] = dvb_attach(zl10353_attach,\n\t\t\t\t\t&em28xx_zl10353_no_i2c_gate_dev,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\t\tif (dvb->fe[0])\n\t\t\tdvb_attach(qt1010_attach, dvb->fe[0],\n\t\t\t\t   &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t   &em28xx_qt1010_config);\n\t\tbreak;\n\tcase EM2883_BOARD_KWORLD_HYBRID_330U:\n\tcase EM2882_BOARD_EVGA_INDTUBE:\n\t\tdvb->fe[0] = dvb_attach(s5h1409_attach,\n\t\t\t\t\t&em28xx_s5h1409_with_xc3028,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\t\tif (em28xx_attach_xc3028(0x61, dev) < 0) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbreak;\n\tcase EM2882_BOARD_KWORLD_ATSC_315U:\n\t\tdvb->fe[0] = dvb_attach(lgdt330x_attach,\n\t\t\t\t\t&em2880_lgdt3303_dev,\n\t\t\t\t\t0x0e,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\t\tif (dvb->fe[0]) {\n\t\t\tif (!dvb_attach(simple_tuner_attach, dvb->fe[0],\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t0x61, TUNER_THOMSON_DTT761X)) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase EM2880_BOARD_HAUPPAUGE_WINTV_HVR_900_R2:\n\tcase EM2882_BOARD_PINNACLE_HYBRID_PRO_330E:\n\t\tdvb->fe[0] = dvb_attach(drxd_attach, &em28xx_drxd, NULL,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t&dev->intf->dev);\n\t\tif (em28xx_attach_xc3028(0x61, dev) < 0) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbreak;\n\tcase EM2870_BOARD_REDDO_DVB_C_USB_BOX:\n\t\t \n\t\tdvb->fe[0] = dvb_attach(tda10023_attach,\n\t\t\t\t\t&em28xx_tda10023_config,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t0x48);\n\t\tif (dvb->fe[0]) {\n\t\t\tif (!dvb_attach(simple_tuner_attach, dvb->fe[0],\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t0x60, TUNER_PHILIPS_CU1216L)) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase EM2870_BOARD_KWORLD_A340:\n\t\tdvb->fe[0] = dvb_attach(lgdt3305_attach,\n\t\t\t\t\t&em2870_lgdt3304_dev,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\t\tif (!dvb->fe[0]) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tif (!dvb_attach(tda18271_attach, dvb->fe[0], 0x60,\n\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t&kworld_a340_config)) {\n\t\t\tdvb_frontend_detach(dvb->fe[0]);\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbreak;\n\tcase EM28174_BOARD_PCTV_290E:\n\t\t \n\t\tdvb->lna_gpio = CXD2820R_GPIO_E | CXD2820R_GPIO_O |\n\t\t\t\tCXD2820R_GPIO_L;\n\t\tdvb->fe[0] = dvb_attach(cxd2820r_attach,\n\t\t\t\t\t&em28xx_cxd2820r_config,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t&dvb->lna_gpio);\n\t\tif (dvb->fe[0]) {\n\t\t\t \n\t\t\tif (!dvb_attach(tda18271_attach,\n\t\t\t\t\tdvb->fe[0],\n\t\t\t\t\t0x60,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t&em28xx_cxd2820r_tda18271_config)) {\n\t\t\t\tdvb_frontend_detach(dvb->fe[0]);\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n#ifdef CONFIG_GPIOLIB\n\t\t\t \n\t\t\tresult = gpio_request_one(dvb->lna_gpio,\n\t\t\t\t\t\t  GPIOF_OUT_INIT_LOW, NULL);\n\t\t\tif (result)\n\t\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\t\"gpio request failed %d\\n\",\n\t\t\t\t\tresult);\n\t\t\telse\n\t\t\t\tgpio_free(dvb->lna_gpio);\n\n\t\t\tresult = 0;  \n#endif\n\t\t\tdvb->fe[0]->ops.set_lna = em28xx_pctv_290e_set_lna;\n\t\t}\n\n\t\tbreak;\n\tcase EM2884_BOARD_HAUPPAUGE_WINTV_HVR_930C:\n\t{\n\t\tstruct xc5000_config cfg = {};\n\n\t\thauppauge_hvr930c_init(dev);\n\n\t\tdvb->fe[0] = dvb_attach(drxk_attach,\n\t\t\t\t\t&hauppauge_930c_drxk,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\t\tif (!dvb->fe[0]) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\t \n\t\tdvb->fe[0]->sec_priv = dvb;\n\t\tsema_init(&dvb->pll_mutex, 1);\n\t\tdvb->gate_ctrl = dvb->fe[0]->ops.i2c_gate_ctrl;\n\t\tdvb->fe[0]->ops.i2c_gate_ctrl = drxk_gate_ctrl;\n\n\t\t \n\t\tcfg.i2c_address  = 0x61;\n\t\tcfg.if_khz = 4000;\n\n\t\tif (dvb->fe[0]->ops.i2c_gate_ctrl)\n\t\t\tdvb->fe[0]->ops.i2c_gate_ctrl(dvb->fe[0], 1);\n\t\tif (!dvb_attach(xc5000_attach, dvb->fe[0],\n\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus], &cfg)) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tif (dvb->fe[0]->ops.i2c_gate_ctrl)\n\t\t\tdvb->fe[0]->ops.i2c_gate_ctrl(dvb->fe[0], 0);\n\n\t\tbreak;\n\t}\n\tcase EM2884_BOARD_TERRATEC_H5:\n\t\tterratec_h5_init(dev);\n\n\t\tdvb->fe[0] = dvb_attach(drxk_attach, &terratec_h5_drxk,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\t\tif (!dvb->fe[0]) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\t \n\t\tdvb->fe[0]->sec_priv = dvb;\n\t\tsema_init(&dvb->pll_mutex, 1);\n\t\tdvb->gate_ctrl = dvb->fe[0]->ops.i2c_gate_ctrl;\n\t\tdvb->fe[0]->ops.i2c_gate_ctrl = drxk_gate_ctrl;\n\n\t\t \n\t\tif (dvb->fe[0]->ops.i2c_gate_ctrl)\n\t\t\tdvb->fe[0]->ops.i2c_gate_ctrl(dvb->fe[0], 1);\n\t\tif (!dvb_attach(tda18271c2dd_attach, dvb->fe[0],\n\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus], 0x60)) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tif (dvb->fe[0]->ops.i2c_gate_ctrl)\n\t\t\tdvb->fe[0]->ops.i2c_gate_ctrl(dvb->fe[0], 0);\n\n\t\tbreak;\n\tcase EM2884_BOARD_C3TECH_DIGITAL_DUO:\n\t\tdvb->fe[0] = dvb_attach(mb86a20s_attach,\n\t\t\t\t\t&c3tech_duo_mb86a20s_config,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\t\tif (dvb->fe[0])\n\t\t\tdvb_attach(tda18271_attach, dvb->fe[0], 0x60,\n\t\t\t\t   &dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t   &c3tech_duo_tda18271_config);\n\t\tbreak;\n\tcase EM28174_BOARD_PCTV_460E:\n\t\tresult = em28174_dvb_init_pctv_460e(dev);\n\t\tif (result)\n\t\t\tgoto out_free;\n\t\tbreak;\n\tcase EM2874_BOARD_DELOCK_61959:\n\tcase EM2874_BOARD_MAXMEDIA_UB425_TC:\n\t\t \n\t\tdvb->fe[0] = dvb_attach(drxk_attach, &maxmedia_ub425_tc_drxk,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\n\t\tif (dvb->fe[0]) {\n\t\t\t \n\t\t\tdvb->fe[0]->ops.i2c_gate_ctrl = NULL;\n\n\t\t\t \n\t\t\tif (!dvb_attach(tda18271_attach, dvb->fe[0], 0x60,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t&em28xx_cxd2820r_tda18271_config)) {\n\t\t\t\tdvb_frontend_detach(dvb->fe[0]);\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase EM2884_BOARD_PCTV_510E:\n\tcase EM2884_BOARD_PCTV_520E:\n\t\tpctv_520e_init(dev);\n\n\t\t \n\t\tdvb->fe[0] = dvb_attach(drxk_attach, &pctv_520e_drxk,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\n\t\tif (dvb->fe[0]) {\n\t\t\t \n\t\t\tif (!dvb_attach(tda18271_attach, dvb->fe[0], 0x60,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t&em28xx_cxd2820r_tda18271_config)) {\n\t\t\t\tdvb_frontend_detach(dvb->fe[0]);\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase EM2884_BOARD_ELGATO_EYETV_HYBRID_2008:\n\tcase EM2884_BOARD_CINERGY_HTC_STICK:\n\tcase EM2884_BOARD_TERRATEC_H6:\n\t\tterratec_htc_stick_init(dev);\n\n\t\t \n\t\tdvb->fe[0] = dvb_attach(drxk_attach, &terratec_htc_stick_drxk,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\t\tif (!dvb->fe[0]) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t \n\t\tif (!dvb_attach(tda18271_attach, dvb->fe[0], 0x60,\n\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t&em28xx_cxd2820r_tda18271_config)) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbreak;\n\tcase EM2884_BOARD_TERRATEC_HTC_USB_XS:\n\t\tterratec_htc_usb_xs_init(dev);\n\n\t\t \n\t\tdvb->fe[0] = dvb_attach(drxk_attach, &terratec_htc_stick_drxk,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\t\tif (!dvb->fe[0]) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t \n\t\tif (!dvb_attach(tda18271_attach, dvb->fe[0], 0x60,\n\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t&em28xx_cxd2820r_tda18271_config)) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbreak;\n\tcase EM2874_BOARD_KWORLD_UB435Q_V2:\n\t\tdvb->fe[0] = dvb_attach(lgdt3305_attach,\n\t\t\t\t\t&em2874_lgdt3305_dev,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\t\tif (!dvb->fe[0]) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t \n\t\tif (!dvb_attach(tda18271_attach, dvb->fe[0], 0x60,\n\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t&kworld_ub435q_v2_config)) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbreak;\n\tcase EM2874_BOARD_KWORLD_UB435Q_V3:\n\t{\n\t\tstruct i2c_adapter *adapter = &dev->i2c_adap[dev->def_i2c_bus];\n\n\t\tdvb->fe[0] = dvb_attach(lgdt3305_attach,\n\t\t\t\t\t&em2874_lgdt3305_nogate_dev,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\t\tif (!dvb->fe[0]) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t \n\t\tkworld_ub435q_v3_config.fe = dvb->fe[0];\n\n\t\tdvb->i2c_client_tuner = dvb_module_probe(\"tda18212\", NULL,\n\t\t\t\t\t\t\t adapter, 0x60,\n\t\t\t\t\t\t\t &kworld_ub435q_v3_config);\n\t\tif (!dvb->i2c_client_tuner) {\n\t\t\tdvb_frontend_detach(dvb->fe[0]);\n\t\t\tresult = -ENODEV;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbreak;\n\t}\n\tcase EM2874_BOARD_PCTV_HD_MINI_80E:\n\t\tdvb->fe[0] = dvb_attach(drx39xxj_attach,\n\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus]);\n\t\tif (dvb->fe[0]) {\n\t\t\tdvb->fe[0] = dvb_attach(tda18271_attach, dvb->fe[0],\n\t\t\t\t\t\t0x60,\n\t\t\t\t\t\t&dev->i2c_adap[dev->def_i2c_bus],\n\t\t\t\t\t\t&pinnacle_80e_dvb_config);\n\t\t\tif (!dvb->fe[0]) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase EM28178_BOARD_PCTV_461E:\n\t\tresult = em28178_dvb_init_pctv_461e(dev);\n\t\tif (result)\n\t\t\tgoto out_free;\n\t\tbreak;\n\tcase EM28178_BOARD_PCTV_461E_V2:\n\t\tresult = em28178_dvb_init_pctv_461e_v2(dev);\n\t\tif (result)\n\t\t\tgoto out_free;\n\t\tbreak;\n\tcase EM28178_BOARD_PCTV_292E:\n\t\tresult = em28178_dvb_init_pctv_292e(dev);\n\t\tif (result)\n\t\t\tgoto out_free;\n\t\tbreak;\n\tcase EM28178_BOARD_TERRATEC_T2_STICK_HD:\n\t\tresult = em28178_dvb_init_terratec_t2_stick_hd(dev);\n\t\tif (result)\n\t\t\tgoto out_free;\n\t\tbreak;\n\tcase EM28178_BOARD_PLEX_PX_BCUD:\n\t\tresult = em28178_dvb_init_plex_px_bcud(dev);\n\t\tif (result)\n\t\t\tgoto out_free;\n\t\tbreak;\n\tcase EM28174_BOARD_HAUPPAUGE_WINTV_DUALHD_DVB:\n\t\tresult = em28174_dvb_init_hauppauge_wintv_dualhd_dvb(dev);\n\t\tif (result)\n\t\t\tgoto out_free;\n\t\tbreak;\n\tcase EM28174_BOARD_HAUPPAUGE_WINTV_DUALHD_01595:\n\t\tresult = em28174_dvb_init_hauppauge_wintv_dualhd_01595(dev);\n\t\tif (result)\n\t\t\tgoto out_free;\n\t\tbreak;\n\tcase EM2874_BOARD_HAUPPAUGE_USB_QUADHD:\n\t\tresult = em2874_dvb_init_hauppauge_usb_quadhd(dev);\n\t\tif (result)\n\t\t\tgoto out_free;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"The frontend of your DVB/ATSC card isn't supported yet\\n\");\n\t\tbreak;\n\t}\n\tif (!dvb->fe[0]) {\n\t\tdev_err(&dev->intf->dev, \"frontend initialization failed\\n\");\n\t\tresult = -EINVAL;\n\t\tgoto out_free;\n\t}\n\t \n\tdvb->fe[0]->callback = em28xx_tuner_callback;\n\tif (dvb->fe[1])\n\t\tdvb->fe[1]->callback = em28xx_tuner_callback;\n\n\t \n\tresult = em28xx_register_dvb(dvb, THIS_MODULE, dev, &dev->intf->dev);\n\n\tif (result < 0)\n\t\tgoto out_free;\n\n\tif (dev->dvb_xfer_bulk) {\n\t\tdvb_alt = 0;\n\t} else {  \n\t\tdvb_alt = dev->dvb_alt_isoc;\n\t}\n\n\tudev = interface_to_usbdev(dev->intf);\n\tusb_set_interface(udev, dev->ifnum, dvb_alt);\n\tdev_info(&dev->intf->dev, \"DVB extension successfully initialized\\n\");\n\n\tkref_get(&dev->ref);\n\nret:\n\tem28xx_set_mode(dev, EM28XX_SUSPEND);\n\tmutex_unlock(&dev->lock);\n\treturn result;\n\nout_free:\n\tem28xx_uninit_usb_xfer(dev, EM28XX_DIGITAL_MODE);\n\tkfree(dvb);\n\tdev->dvb = NULL;\n\tgoto ret;\n}\n\nstatic inline void prevent_sleep(struct dvb_frontend_ops *ops)\n{\n\tops->set_voltage = NULL;\n\tops->sleep = NULL;\n\tops->tuner_ops.sleep = NULL;\n}\n\nstatic int em28xx_dvb_fini(struct em28xx *dev)\n{\n\tstruct em28xx_dvb *dvb;\n\n\tif (dev->is_audio_only) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (!dev->board.has_dvb) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (!dev->dvb)\n\t\treturn 0;\n\n\tdev_info(&dev->intf->dev, \"Closing DVB extension\\n\");\n\n\tdvb = dev->dvb;\n\n\tem28xx_uninit_usb_xfer(dev, EM28XX_DIGITAL_MODE);\n\n\tif (dev->disconnected) {\n\t\t \n\t\tif (dvb->fe[0]) {\n\t\t\tprevent_sleep(&dvb->fe[0]->ops);\n\t\t\tdvb->fe[0]->exit = DVB_FE_DEVICE_REMOVED;\n\t\t}\n\t\tif (dvb->fe[1]) {\n\t\t\tprevent_sleep(&dvb->fe[1]->ops);\n\t\t\tdvb->fe[1]->exit = DVB_FE_DEVICE_REMOVED;\n\t\t}\n\t}\n\n\tem28xx_unregister_dvb(dvb);\n\n\t \n\tdvb_module_release(dvb->i2c_client_sec);\n\tdvb_module_release(dvb->i2c_client_tuner);\n\tdvb_module_release(dvb->i2c_client_demod);\n\n\tkfree(dvb);\n\tdev->dvb = NULL;\n\tkref_put(&dev->ref, em28xx_free_device);\n\n\treturn 0;\n}\n\nstatic int em28xx_dvb_suspend(struct em28xx *dev)\n{\n\tint ret = 0;\n\n\tif (dev->is_audio_only)\n\t\treturn 0;\n\n\tif (!dev->board.has_dvb)\n\t\treturn 0;\n\n\tdev_info(&dev->intf->dev, \"Suspending DVB extension\\n\");\n\tif (dev->dvb) {\n\t\tstruct em28xx_dvb *dvb = dev->dvb;\n\n\t\tif (dvb->fe[0]) {\n\t\t\tret = dvb_frontend_suspend(dvb->fe[0]);\n\t\t\tdev_info(&dev->intf->dev, \"fe0 suspend %d\\n\", ret);\n\t\t}\n\t\tif (dvb->fe[1]) {\n\t\t\tdvb_frontend_suspend(dvb->fe[1]);\n\t\t\tdev_info(&dev->intf->dev, \"fe1 suspend %d\\n\", ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int em28xx_dvb_resume(struct em28xx *dev)\n{\n\tint ret = 0;\n\n\tif (dev->is_audio_only)\n\t\treturn 0;\n\n\tif (!dev->board.has_dvb)\n\t\treturn 0;\n\n\tdev_info(&dev->intf->dev, \"Resuming DVB extension\\n\");\n\tif (dev->dvb) {\n\t\tstruct em28xx_dvb *dvb = dev->dvb;\n\n\t\tif (dvb->fe[0]) {\n\t\t\tret = dvb_frontend_resume(dvb->fe[0]);\n\t\t\tdev_info(&dev->intf->dev, \"fe0 resume %d\\n\", ret);\n\t\t}\n\n\t\tif (dvb->fe[1]) {\n\t\t\tret = dvb_frontend_resume(dvb->fe[1]);\n\t\t\tdev_info(&dev->intf->dev, \"fe1 resume %d\\n\", ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct em28xx_ops dvb_ops = {\n\t.id   = EM28XX_DVB,\n\t.name = \"Em28xx dvb Extension\",\n\t.init = em28xx_dvb_init,\n\t.fini = em28xx_dvb_fini,\n\t.suspend = em28xx_dvb_suspend,\n\t.resume = em28xx_dvb_resume,\n};\n\nstatic int __init em28xx_dvb_register(void)\n{\n\treturn em28xx_register_extension(&dvb_ops);\n}\n\nstatic void __exit em28xx_dvb_unregister(void)\n{\n\tem28xx_unregister_extension(&dvb_ops);\n}\n\nmodule_init(em28xx_dvb_register);\nmodule_exit(em28xx_dvb_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}