{
  "module_name": "msi2500.c",
  "hash_id": "4925cedcceafbe1b65101ebac432f21a85f6f6a2439e9abe9570212a569b5d9f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/msi2500/msi2500.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <asm/div64.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <linux/usb.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-vmalloc.h>\n#include <linux/spi/spi.h>\n\nstatic bool msi2500_emulated_fmt;\nmodule_param_named(emulated_formats, msi2500_emulated_fmt, bool, 0644);\nMODULE_PARM_DESC(emulated_formats, \"enable emulated formats (disappears in future)\");\n\n \n#define MAX_ISO_BUFS            (8)\n#define ISO_FRAMES_PER_DESC     (8)\n#define ISO_MAX_FRAME_SIZE      (3 * 1024)\n#define ISO_BUFFER_SIZE         (ISO_FRAMES_PER_DESC * ISO_MAX_FRAME_SIZE)\n#define MAX_ISOC_ERRORS         20\n\n \n  \n#define MSI2500_PIX_FMT_SDR_S12         v4l2_fourcc('D', 'S', '1', '2')\n \n#define MSI2500_PIX_FMT_SDR_MSI2500_384 v4l2_fourcc('M', '3', '8', '4')\n\nstatic const struct v4l2_frequency_band bands[] = {\n\t{\n\t\t.tuner = 0,\n\t\t.type = V4L2_TUNER_ADC,\n\t\t.index = 0,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   =  1200000,\n\t\t.rangehigh  = 15000000,\n\t},\n};\n\n \nstruct msi2500_format {\n\tu32\tpixelformat;\n\tu32\tbuffersize;\n};\n\n \nstatic struct msi2500_format formats[] = {\n\t{\n\t\t.pixelformat\t= V4L2_SDR_FMT_CS8,\n\t\t.buffersize\t= 3 * 1008,\n#if 0\n\t}, {\n\t\t.pixelformat\t= MSI2500_PIX_FMT_SDR_MSI2500_384,\n\t}, {\n\t\t.pixelformat\t= MSI2500_PIX_FMT_SDR_S12,\n#endif\n\t}, {\n\t\t.pixelformat\t= V4L2_SDR_FMT_CS14LE,\n\t\t.buffersize\t= 3 * 1008,\n\t}, {\n\t\t.pixelformat\t= V4L2_SDR_FMT_CU8,\n\t\t.buffersize\t= 3 * 1008,\n\t}, {\n\t\t.pixelformat\t=  V4L2_SDR_FMT_CU16LE,\n\t\t.buffersize\t= 3 * 1008,\n\t},\n};\n\nstatic const unsigned int NUM_FORMATS = ARRAY_SIZE(formats);\n\n \nstruct msi2500_frame_buf {\n\t \n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head list;\n};\n\nstruct msi2500_dev {\n\tstruct device *dev;\n\tstruct video_device vdev;\n\tstruct v4l2_device v4l2_dev;\n\tstruct v4l2_subdev *v4l2_subdev;\n\tstruct spi_master *master;\n\n\t \n\tstruct vb2_queue vb_queue;\n\tstruct list_head queued_bufs;\n\tspinlock_t queued_bufs_lock;  \n\n\t \n\tstruct mutex v4l2_lock;       \n\tstruct mutex vb_queue_lock;   \n\n\t \n\tstruct usb_device *udev;  \n\n\tunsigned int f_adc;\n\tu32 pixelformat;\n\tu32 buffersize;\n\tunsigned int num_formats;\n\n\tunsigned int isoc_errors;  \n\tunsigned int vb_full;  \n\n\tstruct urb *urbs[MAX_ISO_BUFS];\n\n\t \n\tstruct v4l2_ctrl_handler hdl;\n\n\tu32 next_sample;  \n\tu32 sample;  \n\tunsigned long jiffies_next;\n};\n\n \nstatic struct msi2500_frame_buf *msi2500_get_next_fill_buf(\n\t\t\t\t\t\t\tstruct msi2500_dev *dev)\n{\n\tunsigned long flags;\n\tstruct msi2500_frame_buf *buf = NULL;\n\n\tspin_lock_irqsave(&dev->queued_bufs_lock, flags);\n\tif (list_empty(&dev->queued_bufs))\n\t\tgoto leave;\n\n\tbuf = list_entry(dev->queued_bufs.next, struct msi2500_frame_buf, list);\n\tlist_del(&buf->list);\nleave:\n\tspin_unlock_irqrestore(&dev->queued_bufs_lock, flags);\n\treturn buf;\n}\n\n \n\nstatic int msi2500_convert_stream(struct msi2500_dev *dev, u8 *dst, u8 *src,\n\t\t\t\t  unsigned int src_len)\n{\n\tunsigned int i, j, transactions, dst_len = 0;\n\tu32 sample[3];\n\n\t \n\ttransactions = src_len / 1024;\n\n\tfor (i = 0; i < transactions; i++) {\n\t\tsample[i] = src[3] << 24 | src[2] << 16 | src[1] << 8 |\n\t\t\t\tsrc[0] << 0;\n\t\tif (i == 0 && dev->next_sample != sample[0]) {\n\t\t\tdev_dbg_ratelimited(dev->dev,\n\t\t\t\t\t    \"%d samples lost, %d %08x:%08x\\n\",\n\t\t\t\t\t    sample[0] - dev->next_sample,\n\t\t\t\t\t    src_len, dev->next_sample,\n\t\t\t\t\t    sample[0]);\n\t\t}\n\n\t\t \n\t\tdev_dbg_ratelimited(dev->dev, \"%*ph\\n\", 12, &src[4]);\n\n\t\tsrc += 16;  \n\n\t\tswitch (dev->pixelformat) {\n\t\tcase V4L2_SDR_FMT_CU8:  \n\t\t{\n\t\t\ts8 *s8src = (s8 *)src;\n\t\t\tu8 *u8dst = (u8 *)dst;\n\n\t\t\tfor (j = 0; j < 1008; j++)\n\t\t\t\t*u8dst++ = *s8src++ + 128;\n\n\t\t\tsrc += 1008;\n\t\t\tdst += 1008;\n\t\t\tdst_len += 1008;\n\t\t\tdev->next_sample = sample[i] + 504;\n\t\t\tbreak;\n\t\t}\n\t\tcase  V4L2_SDR_FMT_CU16LE:  \n\t\t{\n\t\t\ts16 *s16src = (s16 *)src;\n\t\t\tu16 *u16dst = (u16 *)dst;\n\t\t\tstruct {signed int x:14; } se;  \n\t\t\tunsigned int utmp;\n\n\t\t\tfor (j = 0; j < 1008; j += 2) {\n\t\t\t\t \n\t\t\t\tse.x = *s16src++;\n\t\t\t\t \n\t\t\t\tutmp = se.x + 8192;\n\t\t\t\t \n\t\t\t\t*u16dst++ = utmp << 2 | utmp >> 12;\n\t\t\t}\n\n\t\t\tsrc += 1008;\n\t\t\tdst += 1008;\n\t\t\tdst_len += 1008;\n\t\t\tdev->next_sample = sample[i] + 252;\n\t\t\tbreak;\n\t\t}\n\t\tcase MSI2500_PIX_FMT_SDR_MSI2500_384:  \n\t\t\t \n\t\t\tdev_dbg_ratelimited(dev->dev, \"%*ph\\n\", 24, &src[1000]);\n\t\t\tmemcpy(dst, src, 984);\n\t\t\tsrc += 984 + 24;\n\t\t\tdst += 984;\n\t\t\tdst_len += 984;\n\t\t\tdev->next_sample = sample[i] + 384;\n\t\t\tbreak;\n\t\tcase V4L2_SDR_FMT_CS8:          \n\t\t\tmemcpy(dst, src, 1008);\n\t\t\tsrc += 1008;\n\t\t\tdst += 1008;\n\t\t\tdst_len += 1008;\n\t\t\tdev->next_sample = sample[i] + 504;\n\t\t\tbreak;\n\t\tcase MSI2500_PIX_FMT_SDR_S12:   \n\t\t\tmemcpy(dst, src, 1008);\n\t\t\tsrc += 1008;\n\t\t\tdst += 1008;\n\t\t\tdst_len += 1008;\n\t\t\tdev->next_sample = sample[i] + 336;\n\t\t\tbreak;\n\t\tcase V4L2_SDR_FMT_CS14LE:       \n\t\t\tmemcpy(dst, src, 1008);\n\t\t\tsrc += 1008;\n\t\t\tdst += 1008;\n\t\t\tdst_len += 1008;\n\t\t\tdev->next_sample = sample[i] + 252;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (unlikely(time_is_before_jiffies(dev->jiffies_next))) {\n\t\t#define MSECS 10000UL\n\t\tunsigned int msecs = jiffies_to_msecs(jiffies -\n\t\t\t\tdev->jiffies_next + msecs_to_jiffies(MSECS));\n\t\tunsigned int samples = dev->next_sample - dev->sample;\n\n\t\tdev->jiffies_next = jiffies + msecs_to_jiffies(MSECS);\n\t\tdev->sample = dev->next_sample;\n\t\tdev_dbg(dev->dev, \"size=%u samples=%u msecs=%u sample rate=%lu\\n\",\n\t\t\tsrc_len, samples, msecs,\n\t\t\tsamples * 1000UL / msecs);\n\t}\n\n\treturn dst_len;\n}\n\n \nstatic void msi2500_isoc_handler(struct urb *urb)\n{\n\tstruct msi2500_dev *dev = (struct msi2500_dev *)urb->context;\n\tint i, flen, fstatus;\n\tunsigned char *iso_buf = NULL;\n\tstruct msi2500_frame_buf *fbuf;\n\n\tif (unlikely(urb->status == -ENOENT ||\n\t\t     urb->status == -ECONNRESET ||\n\t\t     urb->status == -ESHUTDOWN)) {\n\t\tdev_dbg(dev->dev, \"URB (%p) unlinked %ssynchronously\\n\",\n\t\t\turb, urb->status == -ENOENT ? \"\" : \"a\");\n\t\treturn;\n\t}\n\n\tif (unlikely(urb->status != 0)) {\n\t\tdev_dbg(dev->dev, \"called with status %d\\n\", urb->status);\n\t\t \n\t\tif (++dev->isoc_errors > MAX_ISOC_ERRORS)\n\t\t\tdev_dbg(dev->dev, \"Too many ISOC errors, bailing out\\n\");\n\t\tgoto handler_end;\n\t} else {\n\t\t \n\t\tdev->isoc_errors = 0;\n\t}\n\n\t \n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\tvoid *ptr;\n\n\t\t \n\t\tfstatus = urb->iso_frame_desc[i].status;\n\t\tif (unlikely(fstatus)) {\n\t\t\tdev_dbg_ratelimited(dev->dev,\n\t\t\t\t\t    \"frame=%d/%d has error %d skipping\\n\",\n\t\t\t\t\t    i, urb->number_of_packets, fstatus);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tflen = urb->iso_frame_desc[i].actual_length;\n\t\tif (unlikely(flen == 0))\n\t\t\tcontinue;\n\n\t\tiso_buf = urb->transfer_buffer + urb->iso_frame_desc[i].offset;\n\n\t\t \n\t\tfbuf = msi2500_get_next_fill_buf(dev);\n\t\tif (unlikely(fbuf == NULL)) {\n\t\t\tdev->vb_full++;\n\t\t\tdev_dbg_ratelimited(dev->dev,\n\t\t\t\t\t    \"video buffer is full, %d packets dropped\\n\",\n\t\t\t\t\t    dev->vb_full);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tptr = vb2_plane_vaddr(&fbuf->vb.vb2_buf, 0);\n\t\tflen = msi2500_convert_stream(dev, ptr, iso_buf, flen);\n\t\tvb2_set_plane_payload(&fbuf->vb.vb2_buf, 0, flen);\n\t\tvb2_buffer_done(&fbuf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\t}\n\nhandler_end:\n\ti = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(i != 0))\n\t\tdev_dbg(dev->dev, \"Error (%d) re-submitting urb\\n\", i);\n}\n\nstatic void msi2500_iso_stop(struct msi2500_dev *dev)\n{\n\tint i;\n\n\tdev_dbg(dev->dev, \"\\n\");\n\n\t \n\tfor (i = 0; i < MAX_ISO_BUFS; i++) {\n\t\tif (dev->urbs[i]) {\n\t\t\tdev_dbg(dev->dev, \"Unlinking URB %p\\n\", dev->urbs[i]);\n\t\t\tusb_kill_urb(dev->urbs[i]);\n\t\t}\n\t}\n}\n\nstatic void msi2500_iso_free(struct msi2500_dev *dev)\n{\n\tint i;\n\n\tdev_dbg(dev->dev, \"\\n\");\n\n\t \n\tfor (i = 0; i < MAX_ISO_BUFS; i++) {\n\t\tif (dev->urbs[i]) {\n\t\t\tdev_dbg(dev->dev, \"Freeing URB\\n\");\n\t\t\tif (dev->urbs[i]->transfer_buffer) {\n\t\t\t\tusb_free_coherent(dev->udev,\n\t\t\t\t\tdev->urbs[i]->transfer_buffer_length,\n\t\t\t\t\tdev->urbs[i]->transfer_buffer,\n\t\t\t\t\tdev->urbs[i]->transfer_dma);\n\t\t\t}\n\t\t\tusb_free_urb(dev->urbs[i]);\n\t\t\tdev->urbs[i] = NULL;\n\t\t}\n\t}\n}\n\n \nstatic void msi2500_isoc_cleanup(struct msi2500_dev *dev)\n{\n\tdev_dbg(dev->dev, \"\\n\");\n\n\tmsi2500_iso_stop(dev);\n\tmsi2500_iso_free(dev);\n}\n\n \nstatic int msi2500_isoc_init(struct msi2500_dev *dev)\n{\n\tstruct urb *urb;\n\tint i, j, ret;\n\n\tdev_dbg(dev->dev, \"\\n\");\n\n\tdev->isoc_errors = 0;\n\n\tret = usb_set_interface(dev->udev, 0, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < MAX_ISO_BUFS; i++) {\n\t\turb = usb_alloc_urb(ISO_FRAMES_PER_DESC, GFP_KERNEL);\n\t\tif (urb == NULL) {\n\t\t\tmsi2500_isoc_cleanup(dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdev->urbs[i] = urb;\n\t\tdev_dbg(dev->dev, \"Allocated URB at 0x%p\\n\", urb);\n\n\t\turb->interval = 1;\n\t\turb->dev = dev->udev;\n\t\turb->pipe = usb_rcvisocpipe(dev->udev, 0x81);\n\t\turb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\n\t\turb->transfer_buffer = usb_alloc_coherent(dev->udev,\n\t\t\t\tISO_BUFFER_SIZE,\n\t\t\t\tGFP_KERNEL, &urb->transfer_dma);\n\t\tif (urb->transfer_buffer == NULL) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"Failed to allocate urb buffer %d\\n\", i);\n\t\t\tmsi2500_isoc_cleanup(dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\turb->transfer_buffer_length = ISO_BUFFER_SIZE;\n\t\turb->complete = msi2500_isoc_handler;\n\t\turb->context = dev;\n\t\turb->start_frame = 0;\n\t\turb->number_of_packets = ISO_FRAMES_PER_DESC;\n\t\tfor (j = 0; j < ISO_FRAMES_PER_DESC; j++) {\n\t\t\turb->iso_frame_desc[j].offset = j * ISO_MAX_FRAME_SIZE;\n\t\t\turb->iso_frame_desc[j].length = ISO_MAX_FRAME_SIZE;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < MAX_ISO_BUFS; i++) {\n\t\tret = usb_submit_urb(dev->urbs[i], GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"usb_submit_urb %d failed with error %d\\n\",\n\t\t\t\ti, ret);\n\t\t\tmsi2500_isoc_cleanup(dev);\n\t\t\treturn ret;\n\t\t}\n\t\tdev_dbg(dev->dev, \"URB 0x%p submitted.\\n\", dev->urbs[i]);\n\t}\n\n\t \n\treturn 0;\n}\n\n \nstatic void msi2500_cleanup_queued_bufs(struct msi2500_dev *dev)\n{\n\tunsigned long flags;\n\n\tdev_dbg(dev->dev, \"\\n\");\n\n\tspin_lock_irqsave(&dev->queued_bufs_lock, flags);\n\twhile (!list_empty(&dev->queued_bufs)) {\n\t\tstruct msi2500_frame_buf *buf;\n\n\t\tbuf = list_entry(dev->queued_bufs.next,\n\t\t\t\t struct msi2500_frame_buf, list);\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&dev->queued_bufs_lock, flags);\n}\n\n \nstatic void msi2500_disconnect(struct usb_interface *intf)\n{\n\tstruct v4l2_device *v = usb_get_intfdata(intf);\n\tstruct msi2500_dev *dev =\n\t\t\tcontainer_of(v, struct msi2500_dev, v4l2_dev);\n\n\tdev_dbg(dev->dev, \"\\n\");\n\n\tmutex_lock(&dev->vb_queue_lock);\n\tmutex_lock(&dev->v4l2_lock);\n\t \n\tdev->udev = NULL;\n\tv4l2_device_disconnect(&dev->v4l2_dev);\n\tvideo_unregister_device(&dev->vdev);\n\tspi_unregister_master(dev->master);\n\tmutex_unlock(&dev->v4l2_lock);\n\tmutex_unlock(&dev->vb_queue_lock);\n\n\tv4l2_device_put(&dev->v4l2_dev);\n}\n\nstatic int msi2500_querycap(struct file *file, void *fh,\n\t\t\t    struct v4l2_capability *cap)\n{\n\tstruct msi2500_dev *dev = video_drvdata(file);\n\n\tdev_dbg(dev->dev, \"\\n\");\n\n\tstrscpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\n\tstrscpy(cap->card, dev->vdev.name, sizeof(cap->card));\n\tusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\n\treturn 0;\n}\n\n \nstatic int msi2500_queue_setup(struct vb2_queue *vq,\n\t\t\t       unsigned int *nbuffers,\n\t\t\t       unsigned int *nplanes, unsigned int sizes[],\n\t\t\t       struct device *alloc_devs[])\n{\n\tstruct msi2500_dev *dev = vb2_get_drv_priv(vq);\n\n\tdev_dbg(dev->dev, \"nbuffers=%d\\n\", *nbuffers);\n\n\t \n\t*nbuffers = clamp_t(unsigned int, *nbuffers, 8, 32);\n\t*nplanes = 1;\n\tsizes[0] = PAGE_ALIGN(dev->buffersize);\n\tdev_dbg(dev->dev, \"nbuffers=%d sizes[0]=%d\\n\", *nbuffers, sizes[0]);\n\treturn 0;\n}\n\nstatic void msi2500_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct msi2500_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct msi2500_frame_buf *buf = container_of(vbuf,\n\t\t\t\t\t\t     struct msi2500_frame_buf,\n\t\t\t\t\t\t     vb);\n\tunsigned long flags;\n\n\t \n\tif (unlikely(!dev->udev)) {\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&dev->queued_bufs_lock, flags);\n\tlist_add_tail(&buf->list, &dev->queued_bufs);\n\tspin_unlock_irqrestore(&dev->queued_bufs_lock, flags);\n}\n\n#define CMD_WREG               0x41\n#define CMD_START_STREAMING    0x43\n#define CMD_STOP_STREAMING     0x45\n#define CMD_READ_UNKNOWN       0x48\n\n#define msi2500_dbg_usb_control_msg(_dev, _r, _t, _v, _i, _b, _l) { \\\n\tchar *_direction; \\\n\tif (_t & USB_DIR_IN) \\\n\t\t_direction = \"<<<\"; \\\n\telse \\\n\t\t_direction = \">>>\"; \\\n\tdev_dbg(_dev, \"%02x %02x %02x %02x %02x %02x %02x %02x %s %*ph\\n\", \\\n\t\t\t_t, _r, _v & 0xff, _v >> 8, _i & 0xff, _i >> 8, \\\n\t\t\t_l & 0xff, _l >> 8, _direction, _l, _b); \\\n}\n\nstatic int msi2500_ctrl_msg(struct msi2500_dev *dev, u8 cmd, u32 data)\n{\n\tint ret;\n\tu8 request = cmd;\n\tu8 requesttype = USB_DIR_OUT | USB_TYPE_VENDOR;\n\tu16 value = (data >> 0) & 0xffff;\n\tu16 index = (data >> 16) & 0xffff;\n\n\tmsi2500_dbg_usb_control_msg(dev->dev, request, requesttype,\n\t\t\t\t    value, index, NULL, 0);\n\tret = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0), request,\n\t\t\t      requesttype, value, index, NULL, 0, 2000);\n\tif (ret)\n\t\tdev_err(dev->dev, \"failed %d, cmd %02x, data %04x\\n\",\n\t\t\tret, cmd, data);\n\n\treturn ret;\n}\n\nstatic int msi2500_set_usb_adc(struct msi2500_dev *dev)\n{\n\tint ret;\n\tunsigned int f_vco, f_sr, div_n, k, k_cw, div_out;\n\tu32 reg3, reg4, reg7;\n\tstruct v4l2_ctrl *bandwidth_auto;\n\tstruct v4l2_ctrl *bandwidth;\n\n\tf_sr = dev->f_adc;\n\n\t \n\tbandwidth_auto = v4l2_ctrl_find(&dev->hdl,\n\t\t\tV4L2_CID_RF_TUNER_BANDWIDTH_AUTO);\n\tif (v4l2_ctrl_g_ctrl(bandwidth_auto)) {\n\t\tbandwidth = v4l2_ctrl_find(&dev->hdl,\n\t\t\t\tV4L2_CID_RF_TUNER_BANDWIDTH);\n\t\tv4l2_ctrl_s_ctrl(bandwidth, dev->f_adc);\n\t}\n\n\t \n\tswitch (dev->pixelformat) {\n\tcase V4L2_SDR_FMT_CU8:\n\t\treg7 = 0x000c9407;  \n\t\tbreak;\n\tcase  V4L2_SDR_FMT_CU16LE:\n\t\treg7 = 0x00009407;  \n\t\tbreak;\n\tcase V4L2_SDR_FMT_CS8:\n\t\treg7 = 0x000c9407;  \n\t\tbreak;\n\tcase MSI2500_PIX_FMT_SDR_MSI2500_384:\n\t\treg7 = 0x0000a507;  \n\t\tbreak;\n\tcase MSI2500_PIX_FMT_SDR_S12:\n\t\treg7 = 0x00008507;  \n\t\tbreak;\n\tcase V4L2_SDR_FMT_CS14LE:\n\t\treg7 = 0x00009407;  \n\t\tbreak;\n\tdefault:\n\t\treg7 = 0x000c9407;  \n\t\tbreak;\n\t}\n\n\t \n\t \n\n\t#define F_REF 24000000\n\t#define DIV_PRE_N 2\n\t#define DIV_LO_OUT 12\n\treg3 = 0x01000303;\n\treg4 = 0x00000004;\n\n\t \n\tif (f_sr < 6000000)\n\t\treg3 |= 0x1 << 20;\n\telse if (f_sr < 7000000)\n\t\treg3 |= 0x5 << 20;\n\telse if (f_sr < 8500000)\n\t\treg3 |= 0x9 << 20;\n\telse\n\t\treg3 |= 0xd << 20;\n\n\tfor (div_out = 4; div_out < 16; div_out += 2) {\n\t\tf_vco = f_sr * div_out * DIV_LO_OUT;\n\t\tdev_dbg(dev->dev, \"div_out=%u f_vco=%u\\n\", div_out, f_vco);\n\t\tif (f_vco >= 202000000)\n\t\t\tbreak;\n\t}\n\n\t \n\tdiv_n = div_u64_rem(f_vco, DIV_PRE_N * F_REF, &k);\n\tk_cw = div_u64((u64) k * 0x200000, DIV_PRE_N * F_REF);\n\n\treg3 |= div_n << 16;\n\treg3 |= (div_out / 2 - 1) << 10;\n\treg3 |= ((k_cw >> 20) & 0x000001) << 15;  \n\treg4 |= ((k_cw >>  0) & 0x0fffff) <<  8;  \n\n\tdev_dbg(dev->dev,\n\t\t\"f_sr=%u f_vco=%u div_n=%u k=%u div_out=%u reg3=%08x reg4=%08x\\n\",\n\t\tf_sr, f_vco, div_n, k, div_out, reg3, reg4);\n\n\tret = msi2500_ctrl_msg(dev, CMD_WREG, 0x00608008);\n\tif (ret)\n\t\tgoto err;\n\n\tret = msi2500_ctrl_msg(dev, CMD_WREG, 0x00000c05);\n\tif (ret)\n\t\tgoto err;\n\n\tret = msi2500_ctrl_msg(dev, CMD_WREG, 0x00020000);\n\tif (ret)\n\t\tgoto err;\n\n\tret = msi2500_ctrl_msg(dev, CMD_WREG, 0x00480102);\n\tif (ret)\n\t\tgoto err;\n\n\tret = msi2500_ctrl_msg(dev, CMD_WREG, 0x00f38008);\n\tif (ret)\n\t\tgoto err;\n\n\tret = msi2500_ctrl_msg(dev, CMD_WREG, reg7);\n\tif (ret)\n\t\tgoto err;\n\n\tret = msi2500_ctrl_msg(dev, CMD_WREG, reg4);\n\tif (ret)\n\t\tgoto err;\n\n\tret = msi2500_ctrl_msg(dev, CMD_WREG, reg3);\nerr:\n\treturn ret;\n}\n\nstatic int msi2500_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct msi2500_dev *dev = vb2_get_drv_priv(vq);\n\tint ret;\n\n\tdev_dbg(dev->dev, \"\\n\");\n\n\tif (!dev->udev)\n\t\treturn -ENODEV;\n\n\tif (mutex_lock_interruptible(&dev->v4l2_lock))\n\t\treturn -ERESTARTSYS;\n\n\t \n\tv4l2_subdev_call(dev->v4l2_subdev, core, s_power, 1);\n\n\tret = msi2500_set_usb_adc(dev);\n\n\tret = msi2500_isoc_init(dev);\n\tif (ret)\n\t\tmsi2500_cleanup_queued_bufs(dev);\n\n\tret = msi2500_ctrl_msg(dev, CMD_START_STREAMING, 0);\n\n\tmutex_unlock(&dev->v4l2_lock);\n\n\treturn ret;\n}\n\nstatic void msi2500_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct msi2500_dev *dev = vb2_get_drv_priv(vq);\n\n\tdev_dbg(dev->dev, \"\\n\");\n\n\tmutex_lock(&dev->v4l2_lock);\n\n\tif (dev->udev)\n\t\tmsi2500_isoc_cleanup(dev);\n\n\tmsi2500_cleanup_queued_bufs(dev);\n\n\t \n\tmsleep(20);\n\tif (dev->udev && !msi2500_ctrl_msg(dev, CMD_STOP_STREAMING, 0)) {\n\t\t \n\t\tmsi2500_ctrl_msg(dev, CMD_WREG, 0x01000003);\n\t}\n\n\t \n\tv4l2_subdev_call(dev->v4l2_subdev, core, s_power, 0);\n\n\tmutex_unlock(&dev->v4l2_lock);\n}\n\nstatic const struct vb2_ops msi2500_vb2_ops = {\n\t.queue_setup            = msi2500_queue_setup,\n\t.buf_queue              = msi2500_buf_queue,\n\t.start_streaming        = msi2500_start_streaming,\n\t.stop_streaming         = msi2500_stop_streaming,\n\t.wait_prepare           = vb2_ops_wait_prepare,\n\t.wait_finish            = vb2_ops_wait_finish,\n};\n\nstatic int msi2500_enum_fmt_sdr_cap(struct file *file, void *priv,\n\t\t\t\t    struct v4l2_fmtdesc *f)\n{\n\tstruct msi2500_dev *dev = video_drvdata(file);\n\n\tdev_dbg(dev->dev, \"index=%d\\n\", f->index);\n\n\tif (f->index >= dev->num_formats)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = formats[f->index].pixelformat;\n\n\treturn 0;\n}\n\nstatic int msi2500_g_fmt_sdr_cap(struct file *file, void *priv,\n\t\t\t\t struct v4l2_format *f)\n{\n\tstruct msi2500_dev *dev = video_drvdata(file);\n\n\tdev_dbg(dev->dev, \"pixelformat fourcc %4.4s\\n\",\n\t\t(char *)&dev->pixelformat);\n\n\tf->fmt.sdr.pixelformat = dev->pixelformat;\n\tf->fmt.sdr.buffersize = dev->buffersize;\n\n\treturn 0;\n}\n\nstatic int msi2500_s_fmt_sdr_cap(struct file *file, void *priv,\n\t\t\t\t struct v4l2_format *f)\n{\n\tstruct msi2500_dev *dev = video_drvdata(file);\n\tstruct vb2_queue *q = &dev->vb_queue;\n\tint i;\n\n\tdev_dbg(dev->dev, \"pixelformat fourcc %4.4s\\n\",\n\t\t(char *)&f->fmt.sdr.pixelformat);\n\n\tif (vb2_is_busy(q))\n\t\treturn -EBUSY;\n\n\tfor (i = 0; i < dev->num_formats; i++) {\n\t\tif (formats[i].pixelformat == f->fmt.sdr.pixelformat) {\n\t\t\tdev->pixelformat = formats[i].pixelformat;\n\t\t\tdev->buffersize = formats[i].buffersize;\n\t\t\tf->fmt.sdr.buffersize = formats[i].buffersize;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev->pixelformat = formats[0].pixelformat;\n\tdev->buffersize = formats[0].buffersize;\n\tf->fmt.sdr.pixelformat = formats[0].pixelformat;\n\tf->fmt.sdr.buffersize = formats[0].buffersize;\n\n\treturn 0;\n}\n\nstatic int msi2500_try_fmt_sdr_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_format *f)\n{\n\tstruct msi2500_dev *dev = video_drvdata(file);\n\tint i;\n\n\tdev_dbg(dev->dev, \"pixelformat fourcc %4.4s\\n\",\n\t\t(char *)&f->fmt.sdr.pixelformat);\n\n\tfor (i = 0; i < dev->num_formats; i++) {\n\t\tif (formats[i].pixelformat == f->fmt.sdr.pixelformat) {\n\t\t\tf->fmt.sdr.buffersize = formats[i].buffersize;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tf->fmt.sdr.pixelformat = formats[0].pixelformat;\n\tf->fmt.sdr.buffersize = formats[0].buffersize;\n\n\treturn 0;\n}\n\nstatic int msi2500_s_tuner(struct file *file, void *priv,\n\t\t\t   const struct v4l2_tuner *v)\n{\n\tstruct msi2500_dev *dev = video_drvdata(file);\n\tint ret;\n\n\tdev_dbg(dev->dev, \"index=%d\\n\", v->index);\n\n\tif (v->index == 0)\n\t\tret = 0;\n\telse if (v->index == 1)\n\t\tret = v4l2_subdev_call(dev->v4l2_subdev, tuner, s_tuner, v);\n\telse\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nstatic int msi2500_g_tuner(struct file *file, void *priv, struct v4l2_tuner *v)\n{\n\tstruct msi2500_dev *dev = video_drvdata(file);\n\tint ret;\n\n\tdev_dbg(dev->dev, \"index=%d\\n\", v->index);\n\n\tif (v->index == 0) {\n\t\tstrscpy(v->name, \"Mirics MSi2500\", sizeof(v->name));\n\t\tv->type = V4L2_TUNER_ADC;\n\t\tv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\n\t\tv->rangelow =   1200000;\n\t\tv->rangehigh = 15000000;\n\t\tret = 0;\n\t} else if (v->index == 1) {\n\t\tret = v4l2_subdev_call(dev->v4l2_subdev, tuner, g_tuner, v);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int msi2500_g_frequency(struct file *file, void *priv,\n\t\t\t       struct v4l2_frequency *f)\n{\n\tstruct msi2500_dev *dev = video_drvdata(file);\n\tint ret  = 0;\n\n\tdev_dbg(dev->dev, \"tuner=%d type=%d\\n\", f->tuner, f->type);\n\n\tif (f->tuner == 0) {\n\t\tf->frequency = dev->f_adc;\n\t\tret = 0;\n\t} else if (f->tuner == 1) {\n\t\tf->type = V4L2_TUNER_RF;\n\t\tret = v4l2_subdev_call(dev->v4l2_subdev, tuner, g_frequency, f);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int msi2500_s_frequency(struct file *file, void *priv,\n\t\t\t       const struct v4l2_frequency *f)\n{\n\tstruct msi2500_dev *dev = video_drvdata(file);\n\tint ret;\n\n\tdev_dbg(dev->dev, \"tuner=%d type=%d frequency=%u\\n\",\n\t\tf->tuner, f->type, f->frequency);\n\n\tif (f->tuner == 0) {\n\t\tdev->f_adc = clamp_t(unsigned int, f->frequency,\n\t\t\t\t     bands[0].rangelow,\n\t\t\t\t     bands[0].rangehigh);\n\t\tdev_dbg(dev->dev, \"ADC frequency=%u Hz\\n\", dev->f_adc);\n\t\tret = msi2500_set_usb_adc(dev);\n\t} else if (f->tuner == 1) {\n\t\tret = v4l2_subdev_call(dev->v4l2_subdev, tuner, s_frequency, f);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int msi2500_enum_freq_bands(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_frequency_band *band)\n{\n\tstruct msi2500_dev *dev = video_drvdata(file);\n\tint ret;\n\n\tdev_dbg(dev->dev, \"tuner=%d type=%d index=%d\\n\",\n\t\tband->tuner, band->type, band->index);\n\n\tif (band->tuner == 0) {\n\t\tif (band->index >= ARRAY_SIZE(bands)) {\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\t*band = bands[band->index];\n\t\t\tret = 0;\n\t\t}\n\t} else if (band->tuner == 1) {\n\t\tret = v4l2_subdev_call(dev->v4l2_subdev, tuner,\n\t\t\t\t       enum_freq_bands, band);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ioctl_ops msi2500_ioctl_ops = {\n\t.vidioc_querycap          = msi2500_querycap,\n\n\t.vidioc_enum_fmt_sdr_cap  = msi2500_enum_fmt_sdr_cap,\n\t.vidioc_g_fmt_sdr_cap     = msi2500_g_fmt_sdr_cap,\n\t.vidioc_s_fmt_sdr_cap     = msi2500_s_fmt_sdr_cap,\n\t.vidioc_try_fmt_sdr_cap   = msi2500_try_fmt_sdr_cap,\n\n\t.vidioc_reqbufs           = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs       = vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf       = vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf          = vb2_ioctl_querybuf,\n\t.vidioc_qbuf              = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf             = vb2_ioctl_dqbuf,\n\n\t.vidioc_streamon          = vb2_ioctl_streamon,\n\t.vidioc_streamoff         = vb2_ioctl_streamoff,\n\n\t.vidioc_g_tuner           = msi2500_g_tuner,\n\t.vidioc_s_tuner           = msi2500_s_tuner,\n\n\t.vidioc_g_frequency       = msi2500_g_frequency,\n\t.vidioc_s_frequency       = msi2500_s_frequency,\n\t.vidioc_enum_freq_bands   = msi2500_enum_freq_bands,\n\n\t.vidioc_subscribe_event   = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\t.vidioc_log_status        = v4l2_ctrl_log_status,\n};\n\nstatic const struct v4l2_file_operations msi2500_fops = {\n\t.owner                    = THIS_MODULE,\n\t.open                     = v4l2_fh_open,\n\t.release                  = vb2_fop_release,\n\t.read                     = vb2_fop_read,\n\t.poll                     = vb2_fop_poll,\n\t.mmap                     = vb2_fop_mmap,\n\t.unlocked_ioctl           = video_ioctl2,\n};\n\nstatic const struct video_device msi2500_template = {\n\t.name                     = \"Mirics MSi3101 SDR Dongle\",\n\t.release                  = video_device_release_empty,\n\t.fops                     = &msi2500_fops,\n\t.ioctl_ops                = &msi2500_ioctl_ops,\n};\n\nstatic void msi2500_video_release(struct v4l2_device *v)\n{\n\tstruct msi2500_dev *dev = container_of(v, struct msi2500_dev, v4l2_dev);\n\n\tv4l2_ctrl_handler_free(&dev->hdl);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tkfree(dev);\n}\n\nstatic int msi2500_transfer_one_message(struct spi_master *master,\n\t\t\t\t\tstruct spi_message *m)\n{\n\tstruct msi2500_dev *dev = spi_master_get_devdata(master);\n\tstruct spi_transfer *t;\n\tint ret = 0;\n\tu32 data;\n\n\tlist_for_each_entry(t, &m->transfers, transfer_list) {\n\t\tdev_dbg(dev->dev, \"msg=%*ph\\n\", t->len, t->tx_buf);\n\t\tdata = 0x09;  \n\t\tdata |= ((u8 *)t->tx_buf)[0] << 8;\n\t\tdata |= ((u8 *)t->tx_buf)[1] << 16;\n\t\tdata |= ((u8 *)t->tx_buf)[2] << 24;\n\t\tret = msi2500_ctrl_msg(dev, CMD_WREG, data);\n\t}\n\n\tm->status = ret;\n\tspi_finalize_current_message(master);\n\treturn ret;\n}\n\nstatic int msi2500_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct msi2500_dev *dev;\n\tstruct v4l2_subdev *sd;\n\tstruct spi_master *master;\n\tint ret;\n\tstatic struct spi_board_info board_info = {\n\t\t.modalias\t\t= \"msi001\",\n\t\t.bus_num\t\t= 0,\n\t\t.chip_select\t\t= 0,\n\t\t.max_speed_hz\t\t= 12000000,\n\t};\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tmutex_init(&dev->v4l2_lock);\n\tmutex_init(&dev->vb_queue_lock);\n\tspin_lock_init(&dev->queued_bufs_lock);\n\tINIT_LIST_HEAD(&dev->queued_bufs);\n\tdev->dev = &intf->dev;\n\tdev->udev = interface_to_usbdev(intf);\n\tdev->f_adc = bands[0].rangelow;\n\tdev->pixelformat = formats[0].pixelformat;\n\tdev->buffersize = formats[0].buffersize;\n\tdev->num_formats = NUM_FORMATS;\n\tif (!msi2500_emulated_fmt)\n\t\tdev->num_formats -= 2;\n\n\t \n\tdev->vb_queue.type = V4L2_BUF_TYPE_SDR_CAPTURE;\n\tdev->vb_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\n\tdev->vb_queue.drv_priv = dev;\n\tdev->vb_queue.buf_struct_size = sizeof(struct msi2500_frame_buf);\n\tdev->vb_queue.ops = &msi2500_vb2_ops;\n\tdev->vb_queue.mem_ops = &vb2_vmalloc_memops;\n\tdev->vb_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tret = vb2_queue_init(&dev->vb_queue);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Could not initialize vb2 queue\\n\");\n\t\tgoto err_free_mem;\n\t}\n\n\t \n\tdev->vdev = msi2500_template;\n\tdev->vdev.queue = &dev->vb_queue;\n\tdev->vdev.queue->lock = &dev->vb_queue_lock;\n\tvideo_set_drvdata(&dev->vdev, dev);\n\n\t \n\tdev->v4l2_dev.release = msi2500_video_release;\n\tret = v4l2_device_register(&intf->dev, &dev->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to register v4l2-device (%d)\\n\", ret);\n\t\tgoto err_free_mem;\n\t}\n\n\t \n\tmaster = spi_alloc_master(dev->dev, 0);\n\tif (master == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unregister_v4l2_dev;\n\t}\n\n\tdev->master = master;\n\tmaster->bus_num = -1;\n\tmaster->num_chipselect = 1;\n\tmaster->transfer_one_message = msi2500_transfer_one_message;\n\tspi_master_set_devdata(master, dev);\n\tret = spi_register_master(master);\n\tif (ret) {\n\t\tspi_master_put(master);\n\t\tgoto err_unregister_v4l2_dev;\n\t}\n\n\t \n\tsd = v4l2_spi_new_subdev(&dev->v4l2_dev, master, &board_info);\n\tdev->v4l2_subdev = sd;\n\tif (sd == NULL) {\n\t\tdev_err(dev->dev, \"cannot get v4l2 subdevice\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_unregister_master;\n\t}\n\n\t \n\tv4l2_ctrl_handler_init(&dev->hdl, 0);\n\tif (dev->hdl.error) {\n\t\tret = dev->hdl.error;\n\t\tdev_err(dev->dev, \"Could not initialize controls\\n\");\n\t\tgoto err_free_controls;\n\t}\n\n\t \n\tv4l2_ctrl_add_handler(&dev->hdl, sd->ctrl_handler, NULL, true);\n\n\tdev->v4l2_dev.ctrl_handler = &dev->hdl;\n\tdev->vdev.v4l2_dev = &dev->v4l2_dev;\n\tdev->vdev.lock = &dev->v4l2_lock;\n\tdev->vdev.device_caps = V4L2_CAP_SDR_CAPTURE | V4L2_CAP_STREAMING |\n\t\t\t\tV4L2_CAP_READWRITE | V4L2_CAP_TUNER;\n\n\tret = video_register_device(&dev->vdev, VFL_TYPE_SDR, -1);\n\tif (ret) {\n\t\tdev_err(dev->dev,\n\t\t\t\"Failed to register as video device (%d)\\n\", ret);\n\t\tgoto err_unregister_v4l2_dev;\n\t}\n\tdev_info(dev->dev, \"Registered as %s\\n\",\n\t\t video_device_node_name(&dev->vdev));\n\tdev_notice(dev->dev,\n\t\t   \"SDR API is still slightly experimental and functionality changes may follow\\n\");\n\treturn 0;\nerr_free_controls:\n\tv4l2_ctrl_handler_free(&dev->hdl);\nerr_unregister_master:\n\tspi_unregister_master(dev->master);\nerr_unregister_v4l2_dev:\n\tv4l2_device_unregister(&dev->v4l2_dev);\nerr_free_mem:\n\tkfree(dev);\nerr:\n\treturn ret;\n}\n\n \nstatic const struct usb_device_id msi2500_id_table[] = {\n\t{USB_DEVICE(0x1df7, 0x2500)},  \n\t{USB_DEVICE(0x2040, 0xd300)},  \n\t{}\n};\nMODULE_DEVICE_TABLE(usb, msi2500_id_table);\n\n \nstatic struct usb_driver msi2500_driver = {\n\t.name                     = KBUILD_MODNAME,\n\t.probe                    = msi2500_probe,\n\t.disconnect               = msi2500_disconnect,\n\t.id_table                 = msi2500_id_table,\n};\n\nmodule_usb_driver(msi2500_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"Mirics MSi3101 SDR Dongle\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}