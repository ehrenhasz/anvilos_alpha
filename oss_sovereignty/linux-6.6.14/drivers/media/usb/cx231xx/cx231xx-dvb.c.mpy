{
  "module_name": "cx231xx-dvb.c",
  "hash_id": "a639efc4aedfc30a24c485daa190d246381cd6a2e3ceef12141851a1ab975ba4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/cx231xx/cx231xx-dvb.c",
  "human_readable_source": "\n \n\n#include \"cx231xx.h\"\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\n#include <media/dvbdev.h>\n#include <media/dmxdev.h>\n#include <media/dvb_demux.h>\n#include <media/dvb_net.h>\n#include <media/dvb_frontend.h>\n#include <media/v4l2-common.h>\n#include <media/tuner.h>\n\n#include \"xc5000.h\"\n#include \"s5h1432.h\"\n#include \"tda18271.h\"\n#include \"s5h1411.h\"\n#include \"lgdt3305.h\"\n#include \"si2165.h\"\n#include \"si2168.h\"\n#include \"mb86a20s.h\"\n#include \"si2157.h\"\n#include \"lgdt3306a.h\"\n#include \"r820t.h\"\n#include \"mn88473.h\"\n\nMODULE_DESCRIPTION(\"driver for cx231xx based DVB cards\");\nMODULE_AUTHOR(\"Srinivasa Deevi <srinivasa.deevi@conexant.com>\");\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable debug messages [dvb]\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n#define CX231XX_DVB_NUM_BUFS 5\n#define CX231XX_DVB_MAX_PACKETSIZE 564\n#define CX231XX_DVB_MAX_PACKETS 64\n#define CX231XX_DVB_MAX_FRONTENDS 2\n\nstruct cx231xx_dvb {\n\tstruct dvb_frontend *frontend[CX231XX_DVB_MAX_FRONTENDS];\n\n\t \n\tstruct mutex lock;\n\tint nfeeds;\n\n\t \n\tstruct dvb_adapter adapter;\n\tstruct dvb_demux demux;\n\tstruct dmxdev dmxdev;\n\tstruct dmx_frontend fe_hw;\n\tstruct dmx_frontend fe_mem;\n\tstruct dvb_net net;\n\tstruct i2c_client *i2c_client_demod[2];\n\tstruct i2c_client *i2c_client_tuner;\n};\n\nstatic struct s5h1432_config dvico_s5h1432_config = {\n\t.output_mode   = S5H1432_SERIAL_OUTPUT,\n\t.gpio          = S5H1432_GPIO_ON,\n\t.qam_if        = S5H1432_IF_4000,\n\t.vsb_if        = S5H1432_IF_4000,\n\t.inversion     = S5H1432_INVERSION_OFF,\n\t.status_mode   = S5H1432_DEMODLOCKING,\n\t.mpeg_timing   = S5H1432_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,\n};\n\nstatic struct tda18271_std_map cnxt_rde253s_tda18271_std_map = {\n\t.dvbt_6   = { .if_freq = 4000, .agc_mode = 3, .std = 4,\n\t\t      .if_lvl = 1, .rfagc_top = 0x37, },\n\t.dvbt_7   = { .if_freq = 4000, .agc_mode = 3, .std = 5,\n\t\t      .if_lvl = 1, .rfagc_top = 0x37, },\n\t.dvbt_8   = { .if_freq = 4000, .agc_mode = 3, .std = 6,\n\t\t      .if_lvl = 1, .rfagc_top = 0x37, },\n};\n\nstatic struct tda18271_std_map mb86a20s_tda18271_config = {\n\t.dvbt_6   = { .if_freq = 4000, .agc_mode = 3, .std = 4,\n\t\t      .if_lvl = 0, .rfagc_top = 0x37, },\n};\n\nstatic struct tda18271_config cnxt_rde253s_tunerconfig = {\n\t.std_map = &cnxt_rde253s_tda18271_std_map,\n\t.gate    = TDA18271_GATE_ANALOG,\n};\n\nstatic struct s5h1411_config tda18271_s5h1411_config = {\n\t.output_mode   = S5H1411_SERIAL_OUTPUT,\n\t.gpio          = S5H1411_GPIO_OFF,\n\t.vsb_if        = S5H1411_IF_3250,\n\t.qam_if        = S5H1411_IF_4000,\n\t.inversion     = S5H1411_INVERSION_ON,\n\t.status_mode   = S5H1411_DEMODLOCKING,\n\t.mpeg_timing   = S5H1411_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,\n};\nstatic struct s5h1411_config xc5000_s5h1411_config = {\n\t.output_mode   = S5H1411_SERIAL_OUTPUT,\n\t.gpio          = S5H1411_GPIO_OFF,\n\t.vsb_if        = S5H1411_IF_3250,\n\t.qam_if        = S5H1411_IF_3250,\n\t.inversion     = S5H1411_INVERSION_OFF,\n\t.status_mode   = S5H1411_DEMODLOCKING,\n\t.mpeg_timing   = S5H1411_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,\n};\n\nstatic struct lgdt3305_config hcw_lgdt3305_config = {\n\t.i2c_addr           = 0x0e,\n\t.mpeg_mode          = LGDT3305_MPEG_SERIAL,\n\t.tpclk_edge         = LGDT3305_TPCLK_FALLING_EDGE,\n\t.tpvalid_polarity   = LGDT3305_TP_VALID_HIGH,\n\t.deny_i2c_rptr      = 1,\n\t.spectral_inversion = 1,\n\t.qam_if_khz         = 4000,\n\t.vsb_if_khz         = 3250,\n};\n\nstatic struct tda18271_std_map hauppauge_tda18271_std_map = {\n\t.atsc_6   = { .if_freq = 3250, .agc_mode = 3, .std = 4,\n\t\t      .if_lvl = 1, .rfagc_top = 0x58, },\n\t.qam_6    = { .if_freq = 4000, .agc_mode = 3, .std = 5,\n\t\t      .if_lvl = 1, .rfagc_top = 0x58, },\n};\n\nstatic struct tda18271_config hcw_tda18271_config = {\n\t.std_map = &hauppauge_tda18271_std_map,\n\t.gate    = TDA18271_GATE_DIGITAL,\n};\n\nstatic const struct mb86a20s_config pv_mb86a20s_config = {\n\t.demod_address = 0x10,\n\t.is_serial = true,\n};\n\nstatic struct tda18271_config pv_tda18271_config = {\n\t.std_map = &mb86a20s_tda18271_config,\n\t.gate    = TDA18271_GATE_DIGITAL,\n\t.small_i2c = TDA18271_03_BYTE_CHUNK_INIT,\n};\n\nstatic const struct lgdt3306a_config hauppauge_955q_lgdt3306a_config = {\n\t.qam_if_khz         = 4000,\n\t.vsb_if_khz         = 3250,\n\t.spectral_inversion = 1,\n\t.mpeg_mode          = LGDT3306A_MPEG_SERIAL,\n\t.tpclk_edge         = LGDT3306A_TPCLK_RISING_EDGE,\n\t.tpvalid_polarity   = LGDT3306A_TP_VALID_HIGH,\n\t.xtalMHz            = 25,\n};\n\nstatic struct r820t_config astrometa_t2hybrid_r820t_config = {\n\t.i2c_addr\t\t= 0x3a,  \n\t.xtal\t\t\t= 16000000,\n\t.rafael_chip\t\t= CHIP_R828D,\n\t.max_i2c_msg_len\t= 2,\n};\n\nstatic inline void print_err_status(struct cx231xx *dev, int packet, int status)\n{\n\tchar *errmsg = \"Unknown\";\n\n\tswitch (status) {\n\tcase -ENOENT:\n\t\terrmsg = \"unlinked synchronously\";\n\t\tbreak;\n\tcase -ECONNRESET:\n\t\terrmsg = \"unlinked asynchronously\";\n\t\tbreak;\n\tcase -ENOSR:\n\t\terrmsg = \"Buffer error (overrun)\";\n\t\tbreak;\n\tcase -EPIPE:\n\t\terrmsg = \"Stalled (device not responding)\";\n\t\tbreak;\n\tcase -EOVERFLOW:\n\t\terrmsg = \"Babble (bad cable?)\";\n\t\tbreak;\n\tcase -EPROTO:\n\t\terrmsg = \"Bit-stuff error (bad cable?)\";\n\t\tbreak;\n\tcase -EILSEQ:\n\t\terrmsg = \"CRC/Timeout (could be anything)\";\n\t\tbreak;\n\tcase -ETIME:\n\t\terrmsg = \"Device does not respond\";\n\t\tbreak;\n\t}\n\tif (packet < 0) {\n\t\tdev_dbg(dev->dev,\n\t\t\t\"URB status %d [%s].\\n\", status, errmsg);\n\t} else {\n\t\tdev_dbg(dev->dev,\n\t\t\t\"URB packet %d, status %d [%s].\\n\",\n\t\t\tpacket, status, errmsg);\n\t}\n}\n\nstatic inline int dvb_isoc_copy(struct cx231xx *dev, struct urb *urb)\n{\n\tint i;\n\n\tif (!dev)\n\t\treturn 0;\n\n\tif (dev->state & DEV_DISCONNECTED)\n\t\treturn 0;\n\n\tif (urb->status < 0) {\n\t\tprint_err_status(dev, -1, urb->status);\n\t\tif (urb->status == -ENOENT)\n\t\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\tint status = urb->iso_frame_desc[i].status;\n\n\t\tif (status < 0) {\n\t\t\tprint_err_status(dev, i, status);\n\t\t\tif (urb->iso_frame_desc[i].status != -EPROTO)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tdvb_dmx_swfilter(&dev->dvb->demux,\n\t\t\t\t urb->transfer_buffer +\n\t\t\t\turb->iso_frame_desc[i].offset,\n\t\t\t\turb->iso_frame_desc[i].actual_length);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int dvb_bulk_copy(struct cx231xx *dev, struct urb *urb)\n{\n\tif (!dev)\n\t\treturn 0;\n\n\tif (dev->state & DEV_DISCONNECTED)\n\t\treturn 0;\n\n\tif (urb->status < 0) {\n\t\tprint_err_status(dev, -1, urb->status);\n\t\tif (urb->status == -ENOENT)\n\t\t\treturn 0;\n\t}\n\n\t \n\tdvb_dmx_swfilter(&dev->dvb->demux,\n\t\turb->transfer_buffer, urb->actual_length);\n\n\treturn 0;\n}\n\nstatic int start_streaming(struct cx231xx_dvb *dvb)\n{\n\tint rc;\n\tstruct cx231xx *dev = dvb->adapter.priv;\n\n\tif (dev->USE_ISO) {\n\t\tdev_dbg(dev->dev, \"DVB transfer mode is ISO.\\n\");\n\t\tcx231xx_set_alt_setting(dev, INDEX_TS1, 5);\n\t\trc = cx231xx_set_mode(dev, CX231XX_DIGITAL_MODE);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tdev->mode_tv = 1;\n\t\treturn cx231xx_init_isoc(dev, CX231XX_DVB_MAX_PACKETS,\n\t\t\t\t\tCX231XX_DVB_NUM_BUFS,\n\t\t\t\t\tdev->ts1_mode.max_pkt_size,\n\t\t\t\t\tdvb_isoc_copy);\n\t} else {\n\t\tdev_dbg(dev->dev, \"DVB transfer mode is BULK.\\n\");\n\t\tcx231xx_set_alt_setting(dev, INDEX_TS1, 0);\n\t\trc = cx231xx_set_mode(dev, CX231XX_DIGITAL_MODE);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tdev->mode_tv = 1;\n\t\treturn cx231xx_init_bulk(dev, CX231XX_DVB_MAX_PACKETS,\n\t\t\t\t\tCX231XX_DVB_NUM_BUFS,\n\t\t\t\t\tdev->ts1_mode.max_pkt_size,\n\t\t\t\t\tdvb_bulk_copy);\n\t}\n\n}\n\nstatic int stop_streaming(struct cx231xx_dvb *dvb)\n{\n\tstruct cx231xx *dev = dvb->adapter.priv;\n\n\tif (dev->USE_ISO)\n\t\tcx231xx_uninit_isoc(dev);\n\telse\n\t\tcx231xx_uninit_bulk(dev);\n\n\tcx231xx_set_mode(dev, CX231XX_SUSPEND);\n\n\treturn 0;\n}\n\nstatic int start_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct cx231xx_dvb *dvb = demux->priv;\n\tint rc, ret;\n\n\tif (!demux->dmx.frontend)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dvb->lock);\n\tdvb->nfeeds++;\n\trc = dvb->nfeeds;\n\n\tif (dvb->nfeeds == 1) {\n\t\tret = start_streaming(dvb);\n\t\tif (ret < 0)\n\t\t\trc = ret;\n\t}\n\n\tmutex_unlock(&dvb->lock);\n\treturn rc;\n}\n\nstatic int stop_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct cx231xx_dvb *dvb = demux->priv;\n\tint err = 0;\n\n\tmutex_lock(&dvb->lock);\n\tdvb->nfeeds--;\n\n\tif (0 == dvb->nfeeds)\n\t\terr = stop_streaming(dvb);\n\n\tmutex_unlock(&dvb->lock);\n\treturn err;\n}\n\n \nstatic int cx231xx_dvb_bus_ctrl(struct dvb_frontend *fe, int acquire)\n{\n\tstruct cx231xx *dev = fe->dvb->priv;\n\n\tif (acquire)\n\t\treturn cx231xx_set_mode(dev, CX231XX_DIGITAL_MODE);\n\telse\n\t\treturn cx231xx_set_mode(dev, CX231XX_SUSPEND);\n}\n\n \n\nstatic struct xc5000_config cnxt_rde250_tunerconfig = {\n\t.i2c_address = 0x61,\n\t.if_khz = 4000,\n};\nstatic struct xc5000_config cnxt_rdu250_tunerconfig = {\n\t.i2c_address = 0x61,\n\t.if_khz = 3250,\n};\n\n \n#if 0\nstatic int attach_xc5000(u8 addr, struct cx231xx *dev)\n{\n\n\tstruct dvb_frontend *fe;\n\tstruct xc5000_config cfg;\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\tcfg.i2c_adap = cx231xx_get_i2c_adap(dev, dev->board.tuner_i2c_master);\n\tcfg.i2c_addr = addr;\n\n\tif (!dev->dvb->frontend[0]) {\n\t\tdev_err(dev->dev, \"%s/2: dvb frontend not attached. Can't attach xc5000\\n\",\n\t\t\tdev->name);\n\t\treturn -EINVAL;\n\t}\n\n\tfe = dvb_attach(xc5000_attach, dev->dvb->frontend[0], &cfg);\n\tif (!fe) {\n\t\tdev_err(dev->dev, \"%s/2: xc5000 attach failed\\n\", dev->name);\n\t\tdvb_frontend_detach(dev->dvb->frontend[0]);\n\t\tdev->dvb->frontend[0] = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(dev->dev, \"%s/2: xc5000 attached\\n\", dev->name);\n\n\treturn 0;\n}\n#endif\n\nint cx231xx_set_analog_freq(struct cx231xx *dev, u32 freq)\n{\n\tif (dev->dvb && dev->dvb->frontend[0]) {\n\n\t\tstruct dvb_tuner_ops *dops = &dev->dvb->frontend[0]->ops.tuner_ops;\n\n\t\tif (dops->set_analog_params != NULL) {\n\t\t\tstruct analog_parameters params;\n\n\t\t\tparams.frequency = freq;\n\t\t\tparams.std = dev->norm;\n\t\t\tparams.mode = 0;\t \n\t\t\t \n\n\t\t\t \n\t\t\tdops->set_analog_params(dev->dvb->frontend[0], &params);\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nint cx231xx_reset_analog_tuner(struct cx231xx *dev)\n{\n\tint status = 0;\n\n\tif (dev->dvb && dev->dvb->frontend[0]) {\n\n\t\tstruct dvb_tuner_ops *dops = &dev->dvb->frontend[0]->ops.tuner_ops;\n\n\t\tif (dops->init != NULL && !dev->xc_fw_load_done) {\n\n\t\t\tdev_dbg(dev->dev,\n\t\t\t\t\"Reloading firmware for XC5000\\n\");\n\t\t\tstatus = dops->init(dev->dvb->frontend[0]);\n\t\t\tif (status == 0) {\n\t\t\t\tdev->xc_fw_load_done = 1;\n\t\t\t\tdev_dbg(dev->dev,\n\t\t\t\t\t\"XC5000 firmware download completed\\n\");\n\t\t\t} else {\n\t\t\t\tdev->xc_fw_load_done = 0;\n\t\t\t\tdev_dbg(dev->dev,\n\t\t\t\t\t\"XC5000 firmware download failed !!!\\n\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn status;\n}\n\n \n\nstatic int register_dvb(struct cx231xx_dvb *dvb,\n\t\t\tstruct module *module,\n\t\t\tstruct cx231xx *dev, struct device *device)\n{\n\tint result;\n\n\tmutex_init(&dvb->lock);\n\n\n\t \n\tresult = dvb_register_adapter(&dvb->adapter, dev->name, module, device,\n\t\t\t\t      adapter_nr);\n\tif (result < 0) {\n\t\tdev_warn(dev->dev,\n\t\t       \"%s: dvb_register_adapter failed (errno = %d)\\n\",\n\t\t       dev->name, result);\n\t\tgoto fail_adapter;\n\t}\n\tdvb_register_media_controller(&dvb->adapter, dev->media_dev);\n\n\t \n\tdvb->frontend[0]->ops.ts_bus_ctrl = cx231xx_dvb_bus_ctrl;\n\tif (dvb->frontend[1])\n\t\tdvb->frontend[1]->ops.ts_bus_ctrl = cx231xx_dvb_bus_ctrl;\n\n\tdvb->adapter.priv = dev;\n\n\t \n\tresult = dvb_register_frontend(&dvb->adapter, dvb->frontend[0]);\n\tif (result < 0) {\n\t\tdev_warn(dev->dev,\n\t\t       \"%s: dvb_register_frontend failed (errno = %d)\\n\",\n\t\t       dev->name, result);\n\t\tgoto fail_frontend0;\n\t}\n\n\tif (dvb->frontend[1]) {\n\t\tresult = dvb_register_frontend(&dvb->adapter, dvb->frontend[1]);\n\t\tif (result < 0) {\n\t\t\tdev_warn(dev->dev,\n\t\t\t\t \"%s: 2nd dvb_register_frontend failed (errno = %d)\\n\",\n\t\t\t\tdev->name, result);\n\t\t\tgoto fail_frontend1;\n\t\t}\n\n\t\t \n\t\tdvb->adapter.mfe_shared = 1;\n\t}\n\n\t \n\tdvb->demux.dmx.capabilities =\n\t    DMX_TS_FILTERING | DMX_SECTION_FILTERING |\n\t    DMX_MEMORY_BASED_FILTERING;\n\tdvb->demux.priv = dvb;\n\tdvb->demux.filternum = 256;\n\tdvb->demux.feednum = 256;\n\tdvb->demux.start_feed = start_feed;\n\tdvb->demux.stop_feed = stop_feed;\n\n\tresult = dvb_dmx_init(&dvb->demux);\n\tif (result < 0) {\n\t\tdev_warn(dev->dev,\n\t\t\t \"%s: dvb_dmx_init failed (errno = %d)\\n\",\n\t\t       dev->name, result);\n\t\tgoto fail_dmx;\n\t}\n\n\tdvb->dmxdev.filternum = 256;\n\tdvb->dmxdev.demux = &dvb->demux.dmx;\n\tdvb->dmxdev.capabilities = 0;\n\tresult = dvb_dmxdev_init(&dvb->dmxdev, &dvb->adapter);\n\tif (result < 0) {\n\t\tdev_warn(dev->dev,\n\t\t\t \"%s: dvb_dmxdev_init failed (errno = %d)\\n\",\n\t\t\t dev->name, result);\n\t\tgoto fail_dmxdev;\n\t}\n\n\tdvb->fe_hw.source = DMX_FRONTEND_0;\n\tresult = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_hw);\n\tif (result < 0) {\n\t\tdev_warn(dev->dev,\n\t\t       \"%s: add_frontend failed (DMX_FRONTEND_0, errno = %d)\\n\",\n\t\t       dev->name, result);\n\t\tgoto fail_fe_hw;\n\t}\n\n\tdvb->fe_mem.source = DMX_MEMORY_FE;\n\tresult = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_mem);\n\tif (result < 0) {\n\t\tdev_warn(dev->dev,\n\t\t\t \"%s: add_frontend failed (DMX_MEMORY_FE, errno = %d)\\n\",\n\t\t\t dev->name, result);\n\t\tgoto fail_fe_mem;\n\t}\n\n\tresult = dvb->demux.dmx.connect_frontend(&dvb->demux.dmx, &dvb->fe_hw);\n\tif (result < 0) {\n\t\tdev_warn(dev->dev,\n\t\t\t \"%s: connect_frontend failed (errno = %d)\\n\",\n\t\t\t dev->name, result);\n\t\tgoto fail_fe_conn;\n\t}\n\n\t \n\tdvb_net_init(&dvb->adapter, &dvb->net, &dvb->demux.dmx);\n\tresult = dvb_create_media_graph(&dvb->adapter,\n\t\t\t\t\tdev->tuner_type == TUNER_ABSENT);\n\tif (result < 0)\n\t\tgoto fail_create_graph;\n\n\treturn 0;\n\nfail_create_graph:\n\tdvb_net_release(&dvb->net);\nfail_fe_conn:\n\tdvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_mem);\nfail_fe_mem:\n\tdvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_hw);\nfail_fe_hw:\n\tdvb_dmxdev_release(&dvb->dmxdev);\nfail_dmxdev:\n\tdvb_dmx_release(&dvb->demux);\nfail_dmx:\n\tif (dvb->frontend[1])\n\t\tdvb_unregister_frontend(dvb->frontend[1]);\n\tdvb_unregister_frontend(dvb->frontend[0]);\nfail_frontend1:\n\tif (dvb->frontend[1])\n\t\tdvb_frontend_detach(dvb->frontend[1]);\nfail_frontend0:\n\tdvb_frontend_detach(dvb->frontend[0]);\n\tdvb_unregister_adapter(&dvb->adapter);\nfail_adapter:\n\treturn result;\n}\n\nstatic void unregister_dvb(struct cx231xx_dvb *dvb)\n{\n\tdvb_net_release(&dvb->net);\n\tdvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_mem);\n\tdvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_hw);\n\tdvb_dmxdev_release(&dvb->dmxdev);\n\tdvb_dmx_release(&dvb->demux);\n\tif (dvb->frontend[1])\n\t\tdvb_unregister_frontend(dvb->frontend[1]);\n\tdvb_unregister_frontend(dvb->frontend[0]);\n\tif (dvb->frontend[1])\n\t\tdvb_frontend_detach(dvb->frontend[1]);\n\tdvb_frontend_detach(dvb->frontend[0]);\n\tdvb_unregister_adapter(&dvb->adapter);\n\n\t \n\tdvb_module_release(dvb->i2c_client_tuner);\n\tdvb->i2c_client_tuner = NULL;\n\t \n\tdvb_module_release(dvb->i2c_client_demod[1]);\n\tdvb->i2c_client_demod[1] = NULL;\n\tdvb_module_release(dvb->i2c_client_demod[0]);\n\tdvb->i2c_client_demod[0] = NULL;\n}\n\nstatic int dvb_init(struct cx231xx *dev)\n{\n\tint result;\n\tstruct cx231xx_dvb *dvb;\n\tstruct i2c_adapter *tuner_i2c;\n\tstruct i2c_adapter *demod_i2c;\n\tstruct i2c_client *client;\n\tstruct i2c_adapter *adapter;\n\n\tif (!dev->board.has_dvb) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tdvb = kzalloc(sizeof(struct cx231xx_dvb), GFP_KERNEL);\n\n\tif (dvb == NULL) {\n\t\tdev_info(dev->dev,\n\t\t\t \"cx231xx_dvb: memory allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdev->dvb = dvb;\n\tdev->cx231xx_set_analog_freq = cx231xx_set_analog_freq;\n\tdev->cx231xx_reset_analog_tuner = cx231xx_reset_analog_tuner;\n\n\ttuner_i2c = cx231xx_get_i2c_adap(dev, dev->board.tuner_i2c_master);\n\tdemod_i2c = cx231xx_get_i2c_adap(dev, dev->board.demod_i2c_master);\n\tmutex_lock(&dev->lock);\n\tcx231xx_set_mode(dev, CX231XX_DIGITAL_MODE);\n\tcx231xx_demod_reset(dev);\n\t \n\tswitch (dev->model) {\n\tcase CX231XX_BOARD_CNXT_CARRAERA:\n\tcase CX231XX_BOARD_CNXT_RDE_250:\n\n\t\tdev->dvb->frontend[0] = dvb_attach(s5h1432_attach,\n\t\t\t\t\t&dvico_s5h1432_config,\n\t\t\t\t\tdemod_i2c);\n\n\t\tif (!dev->dvb->frontend[0]) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"Failed to attach s5h1432 front end\\n\");\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t \n\t\tdvb->frontend[0]->callback = cx231xx_tuner_callback;\n\n\t\tif (!dvb_attach(xc5000_attach, dev->dvb->frontend[0],\n\t\t\t       tuner_i2c,\n\t\t\t       &cnxt_rde250_tunerconfig)) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tbreak;\n\tcase CX231XX_BOARD_CNXT_SHELBY:\n\tcase CX231XX_BOARD_CNXT_RDU_250:\n\n\t\tdev->dvb->frontend[0] = dvb_attach(s5h1411_attach,\n\t\t\t\t\t       &xc5000_s5h1411_config,\n\t\t\t\t\t       demod_i2c);\n\n\t\tif (!dev->dvb->frontend[0]) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"Failed to attach s5h1411 front end\\n\");\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t \n\t\tdvb->frontend[0]->callback = cx231xx_tuner_callback;\n\n\t\tif (!dvb_attach(xc5000_attach, dev->dvb->frontend[0],\n\t\t\t       tuner_i2c,\n\t\t\t       &cnxt_rdu250_tunerconfig)) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbreak;\n\tcase CX231XX_BOARD_CNXT_RDE_253S:\n\n\t\tdev->dvb->frontend[0] = dvb_attach(s5h1432_attach,\n\t\t\t\t\t&dvico_s5h1432_config,\n\t\t\t\t\tdemod_i2c);\n\n\t\tif (!dev->dvb->frontend[0]) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"Failed to attach s5h1432 front end\\n\");\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t \n\t\tdvb->frontend[0]->callback = cx231xx_tuner_callback;\n\n\t\tif (!dvb_attach(tda18271_attach, dev->dvb->frontend[0],\n\t\t\t       dev->board.tuner_addr, tuner_i2c,\n\t\t\t       &cnxt_rde253s_tunerconfig)) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbreak;\n\tcase CX231XX_BOARD_CNXT_RDU_253S:\n\tcase CX231XX_BOARD_KWORLD_UB445_USB_HYBRID:\n\n\t\tdev->dvb->frontend[0] = dvb_attach(s5h1411_attach,\n\t\t\t\t\t       &tda18271_s5h1411_config,\n\t\t\t\t\t       demod_i2c);\n\n\t\tif (!dev->dvb->frontend[0]) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"Failed to attach s5h1411 front end\\n\");\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t \n\t\tdvb->frontend[0]->callback = cx231xx_tuner_callback;\n\n\t\tif (!dvb_attach(tda18271_attach, dev->dvb->frontend[0],\n\t\t\t       dev->board.tuner_addr, tuner_i2c,\n\t\t\t       &cnxt_rde253s_tunerconfig)) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbreak;\n\tcase CX231XX_BOARD_HAUPPAUGE_EXETER:\n\n\t\tdev_info(dev->dev,\n\t\t\t \"%s: looking for tuner / demod on i2c bus: %d\\n\",\n\t\t       __func__, i2c_adapter_id(tuner_i2c));\n\n\t\tdev->dvb->frontend[0] = dvb_attach(lgdt3305_attach,\n\t\t\t\t\t\t&hcw_lgdt3305_config,\n\t\t\t\t\t\tdemod_i2c);\n\n\t\tif (!dev->dvb->frontend[0]) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"Failed to attach LG3305 front end\\n\");\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t \n\t\tdvb->frontend[0]->callback = cx231xx_tuner_callback;\n\n\t\tdvb_attach(tda18271_attach, dev->dvb->frontend[0],\n\t\t\t   dev->board.tuner_addr, tuner_i2c,\n\t\t\t   &hcw_tda18271_config);\n\t\tbreak;\n\n\tcase CX231XX_BOARD_HAUPPAUGE_930C_HD_1113xx:\n\t{\n\t\tstruct si2165_platform_data si2165_pdata = {};\n\n\t\t \n\t\tsi2165_pdata.fe = &dev->dvb->frontend[0];\n\t\tsi2165_pdata.chip_mode = SI2165_MODE_PLL_XTAL;\n\t\tsi2165_pdata.ref_freq_hz = 16000000;\n\n\t\t \n\t\tclient = dvb_module_probe(\"si2165\", NULL, demod_i2c,\n\t\t\t\t\t\tdev->board.demod_addr,\n\t\t\t\t\t\t&si2165_pdata);\n\t\tif (!client) {\n\t\t\tresult = -ENODEV;\n\t\t\tgoto out_free;\n\t\t}\n\t\tdvb->i2c_client_demod[0] = client;\n\n\t\tdev->dvb->frontend[0]->ops.i2c_gate_ctrl = NULL;\n\n\t\t \n\t\tdvb->frontend[0]->callback = cx231xx_tuner_callback;\n\n\t\tdvb_attach(tda18271_attach, dev->dvb->frontend[0],\n\t\t\tdev->board.tuner_addr, tuner_i2c,\n\t\t\t&hcw_tda18271_config);\n\n\t\tdev->cx231xx_reset_analog_tuner = NULL;\n\t\tbreak;\n\t}\n\tcase CX231XX_BOARD_HAUPPAUGE_930C_HD_1114xx:\n\t{\n\t\tstruct si2165_platform_data si2165_pdata = {};\n\t\tstruct si2157_config si2157_config = {};\n\n\t\t \n\t\tsi2165_pdata.fe = &dev->dvb->frontend[0];\n\t\tsi2165_pdata.chip_mode = SI2165_MODE_PLL_EXT;\n\t\tsi2165_pdata.ref_freq_hz = 24000000;\n\n\t\t \n\t\tclient = dvb_module_probe(\"si2165\", NULL, demod_i2c,\n\t\t\t\t\t\tdev->board.demod_addr,\n\t\t\t\t\t\t&si2165_pdata);\n\t\tif (!client) {\n\t\t\tresult = -ENODEV;\n\t\t\tgoto out_free;\n\t\t}\n\t\tdvb->i2c_client_demod[0] = client;\n\n\t\tdev->dvb->frontend[0]->ops.i2c_gate_ctrl = NULL;\n\n\t\t \n\t\tdvb->frontend[0]->callback = cx231xx_tuner_callback;\n\n\t\t \n\t\tsi2157_config.fe = dev->dvb->frontend[0];\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\t\tsi2157_config.mdev = dev->media_dev;\n#endif\n\t\tsi2157_config.if_port = 1;\n\t\tsi2157_config.inversion = true;\n\n\t\t \n\t\tclient = dvb_module_probe(\"si2157\", NULL, tuner_i2c,\n\t\t\t\t\t\tdev->board.tuner_addr,\n\t\t\t\t\t\t&si2157_config);\n\t\tif (!client) {\n\t\t\tresult = -ENODEV;\n\t\t\tgoto out_free;\n\t\t}\n\t\tdev->cx231xx_reset_analog_tuner = NULL;\n\n\t\tdev->dvb->i2c_client_tuner = client;\n\t\tbreak;\n\t}\n\tcase CX231XX_BOARD_HAUPPAUGE_955Q:\n\t{\n\t\tstruct si2157_config si2157_config = {};\n\t\tstruct lgdt3306a_config lgdt3306a_config = {};\n\n\t\tlgdt3306a_config = hauppauge_955q_lgdt3306a_config;\n\t\tlgdt3306a_config.fe = &dev->dvb->frontend[0];\n\t\tlgdt3306a_config.i2c_adapter = &adapter;\n\n\t\t \n\t\tclient = dvb_module_probe(\"lgdt3306a\", NULL, demod_i2c,\n\t\t\t\t\t\tdev->board.demod_addr,\n\t\t\t\t\t\t&lgdt3306a_config);\n\t\tif (!client) {\n\t\t\tresult = -ENODEV;\n\t\t\tgoto out_free;\n\t\t}\n\t\tdvb->i2c_client_demod[0] = client;\n\n\t\tdev->dvb->frontend[0]->ops.i2c_gate_ctrl = NULL;\n\n\t\t \n\t\tdvb->frontend[0]->callback = cx231xx_tuner_callback;\n\n\t\t \n\t\tsi2157_config.fe = dev->dvb->frontend[0];\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\t\tsi2157_config.mdev = dev->media_dev;\n#endif\n\t\tsi2157_config.if_port = 1;\n\t\tsi2157_config.inversion = true;\n\n\t\t \n\t\tclient = dvb_module_probe(\"si2157\", NULL, tuner_i2c,\n\t\t\t\t\t\tdev->board.tuner_addr,\n\t\t\t\t\t\t&si2157_config);\n\t\tif (!client) {\n\t\t\tresult = -ENODEV;\n\t\t\tgoto out_free;\n\t\t}\n\t\tdev->cx231xx_reset_analog_tuner = NULL;\n\n\t\tdev->dvb->i2c_client_tuner = client;\n\t\tbreak;\n\t}\n\tcase CX231XX_BOARD_PV_PLAYTV_USB_HYBRID:\n\tcase CX231XX_BOARD_KWORLD_UB430_USB_HYBRID:\n\n\t\tdev_info(dev->dev,\n\t\t\t \"%s: looking for demod on i2c bus: %d\\n\",\n\t\t\t __func__, i2c_adapter_id(tuner_i2c));\n\n\t\tdev->dvb->frontend[0] = dvb_attach(mb86a20s_attach,\n\t\t\t\t\t\t&pv_mb86a20s_config,\n\t\t\t\t\t\tdemod_i2c);\n\n\t\tif (!dev->dvb->frontend[0]) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"Failed to attach mb86a20s demod\\n\");\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t \n\t\tdvb->frontend[0]->callback = cx231xx_tuner_callback;\n\n\t\tdvb_attach(tda18271_attach, dev->dvb->frontend[0],\n\t\t\t   dev->board.tuner_addr, tuner_i2c,\n\t\t\t   &pv_tda18271_config);\n\t\tbreak;\n\n\tcase CX231XX_BOARD_EVROMEDIA_FULL_HYBRID_FULLHD:\n\t{\n\t\tstruct si2157_config si2157_config = {};\n\t\tstruct si2168_config si2168_config = {};\n\n\t\t \n\t\tsi2168_config.ts_mode = SI2168_TS_SERIAL;  \n\t\tsi2168_config.fe = &dev->dvb->frontend[0];\n\t\tsi2168_config.i2c_adapter = &adapter;\n\t\tsi2168_config.ts_clock_inv = true;\n\n\t\t \n\t\tclient = dvb_module_probe(\"si2168\", NULL, demod_i2c,\n\t\t\t\t\t\tdev->board.demod_addr,\n\t\t\t\t\t\t&si2168_config);\n\t\tif (!client) {\n\t\t\tresult = -ENODEV;\n\t\t\tgoto out_free;\n\t\t}\n\t\tdvb->i2c_client_demod[0] = client;\n\n\t\t \n\t\tsi2157_config.fe = dev->dvb->frontend[0];\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\t\tsi2157_config.mdev = dev->media_dev;\n#endif\n\t\tsi2157_config.if_port = 1;\n\t\tsi2157_config.inversion = false;\n\n\t\t \n\t\tclient = dvb_module_probe(\"si2157\", NULL, tuner_i2c,\n\t\t\t\t\t\tdev->board.tuner_addr,\n\t\t\t\t\t\t&si2157_config);\n\t\tif (!client) {\n\t\t\tresult = -ENODEV;\n\t\t\tgoto out_free;\n\t\t}\n\t\tdev->cx231xx_reset_analog_tuner = NULL;\n\t\tdev->dvb->i2c_client_tuner = client;\n\t\tbreak;\n\t}\n\tcase CX231XX_BOARD_ASTROMETA_T2HYBRID:\n\t{\n\t\tstruct mn88473_config mn88473_config = {};\n\n\t\t \n\t\tmn88473_config.i2c_wr_max = 16;\n\t\tmn88473_config.xtal = 25000000;\n\t\tmn88473_config.fe = &dev->dvb->frontend[0];\n\n\t\t \n\t\tclient = dvb_module_probe(\"mn88473\", NULL, demod_i2c,\n\t\t\t\t\t\tdev->board.demod_addr,\n\t\t\t\t\t\t&mn88473_config);\n\t\tif (!client) {\n\t\t\tresult = -ENODEV;\n\t\t\tgoto out_free;\n\t\t}\n\t\tdvb->i2c_client_demod[0] = client;\n\n\t\t \n\t\tdvb->frontend[0]->callback = cx231xx_tuner_callback;\n\n\t\t \n\t\tdvb_attach(r820t_attach, dev->dvb->frontend[0],\n\t\t\t   tuner_i2c,\n\t\t\t   &astrometa_t2hybrid_r820t_config);\n\t\tbreak;\n\t}\n\tcase CX231XX_BOARD_HAUPPAUGE_935C:\n\t{\n\t\tstruct si2157_config si2157_config = {};\n\t\tstruct si2168_config si2168_config = {};\n\n\t\t \n\t\tsi2168_config.ts_mode = SI2168_TS_SERIAL;\n\t\tsi2168_config.fe = &dev->dvb->frontend[0];\n\t\tsi2168_config.i2c_adapter = &adapter;\n\t\tsi2168_config.ts_clock_inv = true;\n\n\t\t \n\t\tclient = dvb_module_probe(\"si2168\", NULL, demod_i2c,\n\t\t\t\t\t\tdev->board.demod_addr,\n\t\t\t\t\t\t&si2168_config);\n\t\tif (!client) {\n\t\t\tresult = -ENODEV;\n\t\t\tgoto out_free;\n\t\t}\n\t\tdvb->i2c_client_demod[0] = client;\n\t\tdev->dvb->frontend[0]->ops.i2c_gate_ctrl = NULL;\n\n\t\t \n\t\tdvb->frontend[0]->callback = cx231xx_tuner_callback;\n\n\t\t \n\t\tsi2157_config.fe = dev->dvb->frontend[0];\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\t\tsi2157_config.mdev = dev->media_dev;\n#endif\n\t\tsi2157_config.if_port = 1;\n\t\tsi2157_config.inversion = true;\n\n\t\t \n\t\tclient = dvb_module_probe(\"si2157\", NULL, tuner_i2c,\n\t\t\t\t\t\tdev->board.tuner_addr,\n\t\t\t\t\t\t&si2157_config);\n\t\tif (!client) {\n\t\t\tresult = -ENODEV;\n\t\t\tgoto out_free;\n\t\t}\n\t\tdev->cx231xx_reset_analog_tuner = NULL;\n\t\tdev->dvb->i2c_client_tuner = client;\n\t\tbreak;\n\t}\n\tcase CX231XX_BOARD_HAUPPAUGE_975:\n\t{\n\t\tstruct i2c_adapter *adapter2;\n\t\tstruct si2157_config si2157_config = {};\n\t\tstruct lgdt3306a_config lgdt3306a_config = {};\n\t\tstruct si2168_config si2168_config = {};\n\n\t\t \n\t\tlgdt3306a_config = hauppauge_955q_lgdt3306a_config;\n\t\tlgdt3306a_config.fe = &dev->dvb->frontend[0];\n\t\tlgdt3306a_config.i2c_adapter = &adapter;\n\n\t\t \n\t\tclient = dvb_module_probe(\"lgdt3306a\", NULL, demod_i2c,\n\t\t\t\t\t\tdev->board.demod_addr,\n\t\t\t\t\t\t&lgdt3306a_config);\n\t\tif (!client) {\n\t\t\tresult = -ENODEV;\n\t\t\tgoto out_free;\n\t\t}\n\t\tdvb->i2c_client_demod[0] = client;\n\n\t\t \n\t\tsi2168_config.ts_mode = SI2168_TS_SERIAL;\n\t\tsi2168_config.fe = &dev->dvb->frontend[1];\n\t\tsi2168_config.i2c_adapter = &adapter2;\n\t\tsi2168_config.ts_clock_inv = true;\n\n\t\t \n\t\tclient = dvb_module_probe(\"si2168\", NULL, adapter,\n\t\t\t\t\t\tdev->board.demod_addr2,\n\t\t\t\t\t\t&si2168_config);\n\t\tif (!client) {\n\t\t\tresult = -ENODEV;\n\t\t\tgoto out_free;\n\t\t}\n\t\tdvb->i2c_client_demod[1] = client;\n\t\tdvb->frontend[1]->id = 1;\n\n\t\t \n\t\tdvb->frontend[0]->callback = cx231xx_tuner_callback;\n\t\tdvb->frontend[1]->callback = cx231xx_tuner_callback;\n\n\t\t \n\t\tsi2157_config.fe = dev->dvb->frontend[0];\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\t\tsi2157_config.mdev = dev->media_dev;\n#endif\n\t\tsi2157_config.if_port = 1;\n\t\tsi2157_config.inversion = true;\n\n\t\t \n\t\tclient = dvb_module_probe(\"si2157\", NULL, adapter,\n\t\t\t\t\t\tdev->board.tuner_addr,\n\t\t\t\t\t\t&si2157_config);\n\t\tif (!client) {\n\t\t\tresult = -ENODEV;\n\t\t\tgoto out_free;\n\t\t}\n\t\tdev->cx231xx_reset_analog_tuner = NULL;\n\t\tdvb->i2c_client_tuner = client;\n\n\t\tdvb->frontend[1]->tuner_priv = dvb->frontend[0]->tuner_priv;\n\n\t\tmemcpy(&dvb->frontend[1]->ops.tuner_ops,\n\t\t\t&dvb->frontend[0]->ops.tuner_ops,\n\t\t\tsizeof(struct dvb_tuner_ops));\n\t\tbreak;\n\t}\n\tdefault:\n\t\tdev_err(dev->dev,\n\t\t\t\"%s/2: The frontend of your DVB/ATSC card isn't supported yet\\n\",\n\t\t\tdev->name);\n\t\tbreak;\n\t}\n\tif (!dvb->frontend[0]) {\n\t\tdev_err(dev->dev,\n\t\t       \"%s/2: frontend initialization failed\\n\", dev->name);\n\t\tresult = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\t \n\tresult = register_dvb(dvb, THIS_MODULE, dev, dev->dev);\n\n\tif (result < 0)\n\t\tgoto out_free;\n\n\n\tdev_info(dev->dev, \"Successfully loaded cx231xx-dvb\\n\");\n\nret:\n\tcx231xx_set_mode(dev, CX231XX_SUSPEND);\n\tmutex_unlock(&dev->lock);\n\treturn result;\n\nout_free:\n\t \n\tdvb_module_release(dvb->i2c_client_tuner);\n\tdvb->i2c_client_tuner = NULL;\n\t \n\tdvb_module_release(dvb->i2c_client_demod[1]);\n\tdvb->i2c_client_demod[1] = NULL;\n\tdvb_module_release(dvb->i2c_client_demod[0]);\n\tdvb->i2c_client_demod[0] = NULL;\n\tkfree(dvb);\n\tdev->dvb = NULL;\n\tgoto ret;\n}\n\nstatic int dvb_fini(struct cx231xx *dev)\n{\n\tif (!dev->board.has_dvb) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (dev->dvb) {\n\t\tunregister_dvb(dev->dvb);\n\t\tkfree(dev->dvb);\n\t\tdev->dvb = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct cx231xx_ops dvb_ops = {\n\t.id = CX231XX_DVB,\n\t.name = \"Cx231xx dvb Extension\",\n\t.init = dvb_init,\n\t.fini = dvb_fini,\n};\n\nstatic int __init cx231xx_dvb_register(void)\n{\n\treturn cx231xx_register_extension(&dvb_ops);\n}\n\nstatic void __exit cx231xx_dvb_unregister(void)\n{\n\tcx231xx_unregister_extension(&dvb_ops);\n}\n\nmodule_init(cx231xx_dvb_register);\nmodule_exit(cx231xx_dvb_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}