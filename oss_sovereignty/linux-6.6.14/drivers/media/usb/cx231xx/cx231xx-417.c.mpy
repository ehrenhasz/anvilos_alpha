{
  "module_name": "cx231xx-417.c",
  "hash_id": "9ec92046a74d81b03d7442192441fe09f30eb3e26a414d91f2e17a56c420abd7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/cx231xx/cx231xx-417.c",
  "human_readable_source": "\n \n\n#include \"cx231xx.h\"\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include <media/drv-intf/cx2341x.h>\n#include <media/tuner.h>\n\n#define CX231xx_FIRM_IMAGE_SIZE 376836\n#define CX231xx_FIRM_IMAGE_NAME \"v4l-cx23885-enc.fw\"\n\n \n#define ITVC_WRITE_DIR          0x03FDFC00\n#define ITVC_READ_DIR            0x0001FC00\n\n#define  MCI_MEMORY_DATA_BYTE0          0x00\n#define  MCI_MEMORY_DATA_BYTE1          0x08\n#define  MCI_MEMORY_DATA_BYTE2          0x10\n#define  MCI_MEMORY_DATA_BYTE3          0x18\n\n#define  MCI_MEMORY_ADDRESS_BYTE2       0x20\n#define  MCI_MEMORY_ADDRESS_BYTE1       0x28\n#define  MCI_MEMORY_ADDRESS_BYTE0       0x30\n\n#define  MCI_REGISTER_DATA_BYTE0        0x40\n#define  MCI_REGISTER_DATA_BYTE1        0x48\n#define  MCI_REGISTER_DATA_BYTE2        0x50\n#define  MCI_REGISTER_DATA_BYTE3        0x58\n\n#define  MCI_REGISTER_ADDRESS_BYTE0     0x60\n#define  MCI_REGISTER_ADDRESS_BYTE1     0x68\n\n#define  MCI_REGISTER_MODE              0x70\n\n \n#define  MCI_MODE_REGISTER_READ         0x000\n#define  MCI_MODE_REGISTER_WRITE        0x100\n#define  MCI_MODE_MEMORY_READ           0x000\n#define  MCI_MODE_MEMORY_WRITE          0x4000\n\nstatic unsigned int mpeglines = 128;\nmodule_param(mpeglines, int, 0644);\nMODULE_PARM_DESC(mpeglines, \"number of lines in an MPEG buffer, range 2-32\");\n\nstatic unsigned int mpeglinesize = 512;\nmodule_param(mpeglinesize, int, 0644);\nMODULE_PARM_DESC(mpeglinesize,\n\t\"number of bytes in each line of an MPEG buffer, range 512-1024\");\n\nstatic unsigned int v4l_debug = 1;\nmodule_param(v4l_debug, int, 0644);\nMODULE_PARM_DESC(v4l_debug, \"enable V4L debug messages\");\n\n#define dprintk(level, fmt, arg...)\t\\\n\tdo {\t\t\t\t\\\n\t\tif (v4l_debug >= level) \\\n\t\t\tprintk(KERN_DEBUG pr_fmt(fmt), ## arg); \\\n\t} while (0)\n\nstatic struct cx231xx_tvnorm cx231xx_tvnorms[] = {\n\t{\n\t\t.name      = \"NTSC-M\",\n\t\t.id        = V4L2_STD_NTSC_M,\n\t}, {\n\t\t.name      = \"NTSC-JP\",\n\t\t.id        = V4L2_STD_NTSC_M_JP,\n\t}, {\n\t\t.name      = \"PAL-BG\",\n\t\t.id        = V4L2_STD_PAL_BG,\n\t}, {\n\t\t.name      = \"PAL-DK\",\n\t\t.id        = V4L2_STD_PAL_DK,\n\t}, {\n\t\t.name      = \"PAL-I\",\n\t\t.id        = V4L2_STD_PAL_I,\n\t}, {\n\t\t.name      = \"PAL-M\",\n\t\t.id        = V4L2_STD_PAL_M,\n\t}, {\n\t\t.name      = \"PAL-N\",\n\t\t.id        = V4L2_STD_PAL_N,\n\t}, {\n\t\t.name      = \"PAL-Nc\",\n\t\t.id        = V4L2_STD_PAL_Nc,\n\t}, {\n\t\t.name      = \"PAL-60\",\n\t\t.id        = V4L2_STD_PAL_60,\n\t}, {\n\t\t.name      = \"SECAM-L\",\n\t\t.id        = V4L2_STD_SECAM_L,\n\t}, {\n\t\t.name      = \"SECAM-DK\",\n\t\t.id        = V4L2_STD_SECAM_DK,\n\t}\n};\n\n \n\nenum cx231xx_capture_type {\n\tCX231xx_MPEG_CAPTURE,\n\tCX231xx_RAW_CAPTURE,\n\tCX231xx_RAW_PASSTHRU_CAPTURE\n};\n\nenum cx231xx_capture_bits {\n\tCX231xx_RAW_BITS_NONE             = 0x00,\n\tCX231xx_RAW_BITS_YUV_CAPTURE      = 0x01,\n\tCX231xx_RAW_BITS_PCM_CAPTURE      = 0x02,\n\tCX231xx_RAW_BITS_VBI_CAPTURE      = 0x04,\n\tCX231xx_RAW_BITS_PASSTHRU_CAPTURE = 0x08,\n\tCX231xx_RAW_BITS_TO_HOST_CAPTURE  = 0x10\n};\n\nenum cx231xx_capture_end {\n\tCX231xx_END_AT_GOP,  \n\tCX231xx_END_NOW,  \n};\n\nenum cx231xx_framerate {\n\tCX231xx_FRAMERATE_NTSC_30,  \n\tCX231xx_FRAMERATE_PAL_25    \n};\n\nenum cx231xx_stream_port {\n\tCX231xx_OUTPUT_PORT_MEMORY,\n\tCX231xx_OUTPUT_PORT_STREAMING,\n\tCX231xx_OUTPUT_PORT_SERIAL\n};\n\nenum cx231xx_data_xfer_status {\n\tCX231xx_MORE_BUFFERS_FOLLOW,\n\tCX231xx_LAST_BUFFER,\n};\n\nenum cx231xx_picture_mask {\n\tCX231xx_PICTURE_MASK_NONE,\n\tCX231xx_PICTURE_MASK_I_FRAMES,\n\tCX231xx_PICTURE_MASK_I_P_FRAMES = 0x3,\n\tCX231xx_PICTURE_MASK_ALL_FRAMES = 0x7,\n};\n\nenum cx231xx_vbi_mode_bits {\n\tCX231xx_VBI_BITS_SLICED,\n\tCX231xx_VBI_BITS_RAW,\n};\n\nenum cx231xx_vbi_insertion_bits {\n\tCX231xx_VBI_BITS_INSERT_IN_XTENSION_USR_DATA,\n\tCX231xx_VBI_BITS_INSERT_IN_PRIVATE_PACKETS = 0x1 << 1,\n\tCX231xx_VBI_BITS_SEPARATE_STREAM = 0x2 << 1,\n\tCX231xx_VBI_BITS_SEPARATE_STREAM_USR_DATA = 0x4 << 1,\n\tCX231xx_VBI_BITS_SEPARATE_STREAM_PRV_DATA = 0x5 << 1,\n};\n\nenum cx231xx_dma_unit {\n\tCX231xx_DMA_BYTES,\n\tCX231xx_DMA_FRAMES,\n};\n\nenum cx231xx_dma_transfer_status_bits {\n\tCX231xx_DMA_TRANSFER_BITS_DONE = 0x01,\n\tCX231xx_DMA_TRANSFER_BITS_ERROR = 0x04,\n\tCX231xx_DMA_TRANSFER_BITS_LL_ERROR = 0x10,\n};\n\nenum cx231xx_pause {\n\tCX231xx_PAUSE_ENCODING,\n\tCX231xx_RESUME_ENCODING,\n};\n\nenum cx231xx_copyright {\n\tCX231xx_COPYRIGHT_OFF,\n\tCX231xx_COPYRIGHT_ON,\n};\n\nenum cx231xx_notification_type {\n\tCX231xx_NOTIFICATION_REFRESH,\n};\n\nenum cx231xx_notification_status {\n\tCX231xx_NOTIFICATION_OFF,\n\tCX231xx_NOTIFICATION_ON,\n};\n\nenum cx231xx_notification_mailbox {\n\tCX231xx_NOTIFICATION_NO_MAILBOX = -1,\n};\n\nenum cx231xx_field1_lines {\n\tCX231xx_FIELD1_SAA7114 = 0x00EF,  \n\tCX231xx_FIELD1_SAA7115 = 0x00F0,  \n\tCX231xx_FIELD1_MICRONAS = 0x0105,  \n};\n\nenum cx231xx_field2_lines {\n\tCX231xx_FIELD2_SAA7114 = 0x00EF,  \n\tCX231xx_FIELD2_SAA7115 = 0x00F0,  \n\tCX231xx_FIELD2_MICRONAS = 0x0106,  \n};\n\nenum cx231xx_custom_data_type {\n\tCX231xx_CUSTOM_EXTENSION_USR_DATA,\n\tCX231xx_CUSTOM_PRIVATE_PACKET,\n};\n\nenum cx231xx_mute {\n\tCX231xx_UNMUTE,\n\tCX231xx_MUTE,\n};\n\nenum cx231xx_mute_video_mask {\n\tCX231xx_MUTE_VIDEO_V_MASK = 0x0000FF00,\n\tCX231xx_MUTE_VIDEO_U_MASK = 0x00FF0000,\n\tCX231xx_MUTE_VIDEO_Y_MASK = 0xFF000000,\n};\n\nenum cx231xx_mute_video_shift {\n\tCX231xx_MUTE_VIDEO_V_SHIFT = 8,\n\tCX231xx_MUTE_VIDEO_U_SHIFT = 16,\n\tCX231xx_MUTE_VIDEO_Y_SHIFT = 24,\n};\n\n \n#define IVTV_CMD_HW_BLOCKS_RST 0xFFFFFFFF\n\n \n#define IVTV_API_STD_TIMEOUT 500\n\n \n \n#define IVTV_REG_ENC_SDRAM_REFRESH (0x07F8)\n#define IVTV_REG_ENC_SDRAM_PRECHARGE (0x07FC)\n#define IVTV_REG_SPU (0x9050)\n#define IVTV_REG_HW_BLOCKS (0x9054)\n#define IVTV_REG_VPU (0x9058)\n#define IVTV_REG_APU (0xA064)\n\n \n#define MC417_MIWR\t0x8000\n#define MC417_MIRD\t0x4000\n#define MC417_MICS\t0x2000\n#define MC417_MIRDY\t0x1000\n#define MC417_MIADDR\t0x0F00\n#define MC417_MIDATA\t0x00FF\n\n\n \n#define MC417_SPD_CTL(x)\t(((x) << 4) & 0x00000030)\n#define MC417_GPIO_SEL(x)\t(((x) << 1) & 0x00000006)\n#define MC417_UART_GPIO_EN\t0x00000001\n\n \n#define MC417_SPD_CTL_SLOW\t0x1\n#define MC417_SPD_CTL_MEDIUM\t0x0\n#define MC417_SPD_CTL_FAST\t0x3      \n\n \n#define MC417_GPIO_SEL_GPIO3\t0x3\n#define MC417_GPIO_SEL_GPIO2\t0x2\n#define MC417_GPIO_SEL_GPIO1\t0x1\n#define MC417_GPIO_SEL_GPIO0\t0x0\n\n\n#define CX23417_GPIO_MASK 0xFC0003FF\n\nstatic int set_itvc_reg(struct cx231xx *dev, u32 gpio_direction, u32 value)\n{\n\tint status = 0;\n\tu32 _gpio_direction = 0;\n\n\t_gpio_direction = _gpio_direction & CX23417_GPIO_MASK;\n\t_gpio_direction = _gpio_direction | gpio_direction;\n\tstatus = cx231xx_send_gpio_cmd(dev, _gpio_direction,\n\t\t\t (u8 *)&value, 4, 0, 0);\n\treturn status;\n}\n\nstatic int get_itvc_reg(struct cx231xx *dev, u32 gpio_direction, u32 *val_ptr)\n{\n\tint status = 0;\n\tu32 _gpio_direction = 0;\n\n\t_gpio_direction = _gpio_direction & CX23417_GPIO_MASK;\n\t_gpio_direction = _gpio_direction | gpio_direction;\n\n\tstatus = cx231xx_send_gpio_cmd(dev, _gpio_direction,\n\t\t (u8 *)val_ptr, 4, 0, 1);\n\treturn status;\n}\n\nstatic int wait_for_mci_complete(struct cx231xx *dev)\n{\n\tu32 gpio;\n\tu32 gpio_direction = 0;\n\tu8 count = 0;\n\tget_itvc_reg(dev, gpio_direction, &gpio);\n\n\twhile (!(gpio&0x020000)) {\n\t\tmsleep(10);\n\n\t\tget_itvc_reg(dev, gpio_direction, &gpio);\n\n\t\tif (count++ > 100) {\n\t\t\tdprintk(3, \"ERROR: Timeout - gpio=%x\\n\", gpio);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int mc417_register_write(struct cx231xx *dev, u16 address, u32 value)\n{\n\tu32 temp;\n\tint status = 0;\n\n\ttemp = 0x82 | MCI_REGISTER_DATA_BYTE0 | ((value & 0x000000FF) << 8);\n\ttemp = temp << 10;\n\tstatus = set_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\tif (status < 0)\n\t\treturn status;\n\ttemp = temp | (0x05 << 10);\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\n\t \n\ttemp = 0x82 | MCI_REGISTER_DATA_BYTE1 | (value & 0x0000FF00);\n\ttemp = temp << 10;\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\ttemp = temp | (0x05 << 10);\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\n\t \n\ttemp = 0x82 | MCI_REGISTER_DATA_BYTE2 | ((value & 0x00FF0000) >> 8);\n\ttemp = temp << 10;\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\ttemp = temp | (0x05 << 10);\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\n\t \n\ttemp = 0x82 | MCI_REGISTER_DATA_BYTE3 | ((value & 0xFF000000) >> 16);\n\ttemp = temp << 10;\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\ttemp = temp | (0x05 << 10);\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\n\t \n\ttemp = 0x82 | MCI_REGISTER_ADDRESS_BYTE0 | ((address & 0x000000FF) << 8);\n\ttemp = temp << 10;\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\ttemp = temp | (0x05 << 10);\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\n\t \n\ttemp = 0x82 | MCI_REGISTER_ADDRESS_BYTE1 | (address & 0x0000FF00);\n\ttemp = temp << 10;\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\ttemp = temp | (0x05 << 10);\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\n\t \n\ttemp = 0x82 | MCI_REGISTER_MODE | MCI_MODE_REGISTER_WRITE;\n\ttemp = temp << 10;\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\ttemp = temp | (0x05 << 10);\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\n\treturn wait_for_mci_complete(dev);\n}\n\nstatic int mc417_register_read(struct cx231xx *dev, u16 address, u32 *value)\n{\n\t \n\tu32 temp;\n\tu32 return_value = 0;\n\tint ret = 0;\n\n\ttemp = 0x82 | MCI_REGISTER_ADDRESS_BYTE0 | ((address & 0x00FF) << 8);\n\ttemp = temp << 10;\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\ttemp = temp | ((0x05) << 10);\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\n\t \n\ttemp = 0x82 | MCI_REGISTER_ADDRESS_BYTE1 | (address & 0xFF00);\n\ttemp = temp << 10;\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\ttemp = temp | ((0x05) << 10);\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\n\t \n\ttemp = 0x82 | MCI_REGISTER_MODE | MCI_MODE_REGISTER_READ;\n\ttemp = temp << 10;\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\ttemp = temp | ((0x05) << 10);\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\n\t \n\tret = wait_for_mci_complete(dev);\n\n\t \n\n\t \n\ttemp = (0x82 | MCI_REGISTER_DATA_BYTE0) << 10;\n\tset_itvc_reg(dev, ITVC_READ_DIR, temp);\n\ttemp = ((0x81 | MCI_REGISTER_DATA_BYTE0) << 10);\n\tset_itvc_reg(dev, ITVC_READ_DIR, temp);\n\tget_itvc_reg(dev, ITVC_READ_DIR, &temp);\n\treturn_value |= ((temp & 0x03FC0000) >> 18);\n\tset_itvc_reg(dev, ITVC_READ_DIR, (0x87 << 10));\n\n\t \n\ttemp = (0x82 | MCI_REGISTER_DATA_BYTE1) << 10;\n\tset_itvc_reg(dev, ITVC_READ_DIR, temp);\n\ttemp = ((0x81 | MCI_REGISTER_DATA_BYTE1) << 10);\n\tset_itvc_reg(dev, ITVC_READ_DIR, temp);\n\tget_itvc_reg(dev, ITVC_READ_DIR, &temp);\n\n\treturn_value |= ((temp & 0x03FC0000) >> 10);\n\tset_itvc_reg(dev, ITVC_READ_DIR, (0x87 << 10));\n\n\t \n\ttemp = (0x82 | MCI_REGISTER_DATA_BYTE2) << 10;\n\tset_itvc_reg(dev, ITVC_READ_DIR, temp);\n\ttemp = ((0x81 | MCI_REGISTER_DATA_BYTE2) << 10);\n\tset_itvc_reg(dev, ITVC_READ_DIR, temp);\n\tget_itvc_reg(dev, ITVC_READ_DIR, &temp);\n\treturn_value |= ((temp & 0x03FC0000) >> 2);\n\tset_itvc_reg(dev, ITVC_READ_DIR, (0x87 << 10));\n\n\t \n\ttemp = (0x82 | MCI_REGISTER_DATA_BYTE3) << 10;\n\tset_itvc_reg(dev, ITVC_READ_DIR, temp);\n\ttemp = ((0x81 | MCI_REGISTER_DATA_BYTE3) << 10);\n\tset_itvc_reg(dev, ITVC_READ_DIR, temp);\n\tget_itvc_reg(dev, ITVC_READ_DIR, &temp);\n\treturn_value |= ((temp & 0x03FC0000) << 6);\n\tset_itvc_reg(dev, ITVC_READ_DIR, (0x87 << 10));\n\n\t*value  = return_value;\n\treturn ret;\n}\n\nstatic int mc417_memory_write(struct cx231xx *dev, u32 address, u32 value)\n{\n\t \n\n\tu32 temp;\n\tint ret = 0;\n\n\ttemp = 0x82 | MCI_MEMORY_DATA_BYTE0 | ((value & 0x000000FF) << 8);\n\ttemp = temp << 10;\n\tret = set_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\tif (ret < 0)\n\t\treturn ret;\n\ttemp = temp | (0x05 << 10);\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\n\t \n\ttemp = 0x82 | MCI_MEMORY_DATA_BYTE1 | (value & 0x0000FF00);\n\ttemp = temp << 10;\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\ttemp = temp | (0x05 << 10);\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\n\t \n\ttemp = 0x82 | MCI_MEMORY_DATA_BYTE2 | ((value & 0x00FF0000) >> 8);\n\ttemp = temp << 10;\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\ttemp = temp | (0x05 << 10);\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\n\t \n\ttemp = 0x82 | MCI_MEMORY_DATA_BYTE3 | ((value & 0xFF000000) >> 16);\n\ttemp = temp << 10;\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\ttemp = temp | (0x05 << 10);\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\n\t \n\ttemp = 0x82 | MCI_MEMORY_ADDRESS_BYTE2 | MCI_MODE_MEMORY_WRITE |\n\t\t((address & 0x003F0000) >> 8);\n\ttemp = temp << 10;\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\ttemp = temp | (0x05 << 10);\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\n\t \n\ttemp = 0x82 | MCI_MEMORY_ADDRESS_BYTE1 | (address & 0xFF00);\n\ttemp = temp << 10;\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\ttemp = temp | (0x05 << 10);\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\n\t \n\ttemp = 0x82 | MCI_MEMORY_ADDRESS_BYTE0 | ((address & 0x00FF) << 8);\n\ttemp = temp << 10;\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\ttemp = temp | (0x05 << 10);\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\n\t \n\twait_for_mci_complete(dev);\n\n\treturn 0;\n}\n\nstatic int mc417_memory_read(struct cx231xx *dev, u32 address, u32 *value)\n{\n\tu32 temp = 0;\n\tu32 return_value = 0;\n\tint ret = 0;\n\n\t \n\ttemp = 0x82 | MCI_MEMORY_ADDRESS_BYTE2 | MCI_MODE_MEMORY_READ |\n\t\t((address & 0x003F0000) >> 8);\n\ttemp = temp << 10;\n\tret = set_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\tif (ret < 0)\n\t\treturn ret;\n\ttemp = temp | (0x05 << 10);\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\n\t \n\ttemp = 0x82 | MCI_MEMORY_ADDRESS_BYTE1 | (address & 0xFF00);\n\ttemp = temp << 10;\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\ttemp = temp | (0x05 << 10);\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\n\t \n\ttemp = 0x82 | MCI_MEMORY_ADDRESS_BYTE0 | ((address & 0x00FF) << 8);\n\ttemp = temp << 10;\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\ttemp = temp | (0x05 << 10);\n\tset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\n\n\t \n\tret = wait_for_mci_complete(dev);\n\n\n\t \n\ttemp = (0x82 | MCI_MEMORY_DATA_BYTE3) << 10;\n\tset_itvc_reg(dev, ITVC_READ_DIR, temp);\n\ttemp = ((0x81 | MCI_MEMORY_DATA_BYTE3) << 10);\n\tset_itvc_reg(dev, ITVC_READ_DIR, temp);\n\tget_itvc_reg(dev, ITVC_READ_DIR, &temp);\n\treturn_value |= ((temp & 0x03FC0000) << 6);\n\tset_itvc_reg(dev, ITVC_READ_DIR, (0x87 << 10));\n\n\t \n\ttemp = (0x82 | MCI_MEMORY_DATA_BYTE2) << 10;\n\tset_itvc_reg(dev, ITVC_READ_DIR, temp);\n\ttemp = ((0x81 | MCI_MEMORY_DATA_BYTE2) << 10);\n\tset_itvc_reg(dev, ITVC_READ_DIR, temp);\n\tget_itvc_reg(dev, ITVC_READ_DIR, &temp);\n\treturn_value |= ((temp & 0x03FC0000) >> 2);\n\tset_itvc_reg(dev, ITVC_READ_DIR, (0x87 << 10));\n\n\t \n\ttemp = (0x82 | MCI_MEMORY_DATA_BYTE1) << 10;\n\tset_itvc_reg(dev, ITVC_READ_DIR, temp);\n\ttemp = ((0x81 | MCI_MEMORY_DATA_BYTE1) << 10);\n\tset_itvc_reg(dev, ITVC_READ_DIR, temp);\n\tget_itvc_reg(dev, ITVC_READ_DIR, &temp);\n\treturn_value |= ((temp & 0x03FC0000) >> 10);\n\tset_itvc_reg(dev, ITVC_READ_DIR, (0x87 << 10));\n\n\t \n\ttemp = (0x82 | MCI_MEMORY_DATA_BYTE0) << 10;\n\tset_itvc_reg(dev, ITVC_READ_DIR, temp);\n\ttemp = ((0x81 | MCI_MEMORY_DATA_BYTE0) << 10);\n\tset_itvc_reg(dev, ITVC_READ_DIR, temp);\n\tget_itvc_reg(dev, ITVC_READ_DIR, &temp);\n\treturn_value |= ((temp & 0x03FC0000) >> 18);\n\tset_itvc_reg(dev, ITVC_READ_DIR, (0x87 << 10));\n\n\t*value  = return_value;\n\treturn ret;\n}\n\n \n\n \nstatic char *cmd_to_str(int cmd)\n{\n\tswitch (cmd) {\n\tcase CX2341X_ENC_PING_FW:\n\t\treturn \"PING_FW\";\n\tcase CX2341X_ENC_START_CAPTURE:\n\t\treturn \"START_CAPTURE\";\n\tcase CX2341X_ENC_STOP_CAPTURE:\n\t\treturn \"STOP_CAPTURE\";\n\tcase CX2341X_ENC_SET_AUDIO_ID:\n\t\treturn \"SET_AUDIO_ID\";\n\tcase CX2341X_ENC_SET_VIDEO_ID:\n\t\treturn \"SET_VIDEO_ID\";\n\tcase CX2341X_ENC_SET_PCR_ID:\n\t\treturn \"SET_PCR_PID\";\n\tcase CX2341X_ENC_SET_FRAME_RATE:\n\t\treturn \"SET_FRAME_RATE\";\n\tcase CX2341X_ENC_SET_FRAME_SIZE:\n\t\treturn \"SET_FRAME_SIZE\";\n\tcase CX2341X_ENC_SET_BIT_RATE:\n\t\treturn \"SET_BIT_RATE\";\n\tcase CX2341X_ENC_SET_GOP_PROPERTIES:\n\t\treturn \"SET_GOP_PROPERTIES\";\n\tcase CX2341X_ENC_SET_ASPECT_RATIO:\n\t\treturn \"SET_ASPECT_RATIO\";\n\tcase CX2341X_ENC_SET_DNR_FILTER_MODE:\n\t\treturn \"SET_DNR_FILTER_PROPS\";\n\tcase CX2341X_ENC_SET_DNR_FILTER_PROPS:\n\t\treturn \"SET_DNR_FILTER_PROPS\";\n\tcase CX2341X_ENC_SET_CORING_LEVELS:\n\t\treturn \"SET_CORING_LEVELS\";\n\tcase CX2341X_ENC_SET_SPATIAL_FILTER_TYPE:\n\t\treturn \"SET_SPATIAL_FILTER_TYPE\";\n\tcase CX2341X_ENC_SET_VBI_LINE:\n\t\treturn \"SET_VBI_LINE\";\n\tcase CX2341X_ENC_SET_STREAM_TYPE:\n\t\treturn \"SET_STREAM_TYPE\";\n\tcase CX2341X_ENC_SET_OUTPUT_PORT:\n\t\treturn \"SET_OUTPUT_PORT\";\n\tcase CX2341X_ENC_SET_AUDIO_PROPERTIES:\n\t\treturn \"SET_AUDIO_PROPERTIES\";\n\tcase CX2341X_ENC_HALT_FW:\n\t\treturn \"HALT_FW\";\n\tcase CX2341X_ENC_GET_VERSION:\n\t\treturn \"GET_VERSION\";\n\tcase CX2341X_ENC_SET_GOP_CLOSURE:\n\t\treturn \"SET_GOP_CLOSURE\";\n\tcase CX2341X_ENC_GET_SEQ_END:\n\t\treturn \"GET_SEQ_END\";\n\tcase CX2341X_ENC_SET_PGM_INDEX_INFO:\n\t\treturn \"SET_PGM_INDEX_INFO\";\n\tcase CX2341X_ENC_SET_VBI_CONFIG:\n\t\treturn \"SET_VBI_CONFIG\";\n\tcase CX2341X_ENC_SET_DMA_BLOCK_SIZE:\n\t\treturn \"SET_DMA_BLOCK_SIZE\";\n\tcase CX2341X_ENC_GET_PREV_DMA_INFO_MB_10:\n\t\treturn \"GET_PREV_DMA_INFO_MB_10\";\n\tcase CX2341X_ENC_GET_PREV_DMA_INFO_MB_9:\n\t\treturn \"GET_PREV_DMA_INFO_MB_9\";\n\tcase CX2341X_ENC_SCHED_DMA_TO_HOST:\n\t\treturn \"SCHED_DMA_TO_HOST\";\n\tcase CX2341X_ENC_INITIALIZE_INPUT:\n\t\treturn \"INITIALIZE_INPUT\";\n\tcase CX2341X_ENC_SET_FRAME_DROP_RATE:\n\t\treturn \"SET_FRAME_DROP_RATE\";\n\tcase CX2341X_ENC_PAUSE_ENCODER:\n\t\treturn \"PAUSE_ENCODER\";\n\tcase CX2341X_ENC_REFRESH_INPUT:\n\t\treturn \"REFRESH_INPUT\";\n\tcase CX2341X_ENC_SET_COPYRIGHT:\n\t\treturn \"SET_COPYRIGHT\";\n\tcase CX2341X_ENC_SET_EVENT_NOTIFICATION:\n\t\treturn \"SET_EVENT_NOTIFICATION\";\n\tcase CX2341X_ENC_SET_NUM_VSYNC_LINES:\n\t\treturn \"SET_NUM_VSYNC_LINES\";\n\tcase CX2341X_ENC_SET_PLACEHOLDER:\n\t\treturn \"SET_PLACEHOLDER\";\n\tcase CX2341X_ENC_MUTE_VIDEO:\n\t\treturn \"MUTE_VIDEO\";\n\tcase CX2341X_ENC_MUTE_AUDIO:\n\t\treturn \"MUTE_AUDIO\";\n\tcase CX2341X_ENC_MISC:\n\t\treturn \"MISC\";\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n\nstatic int cx231xx_mbox_func(void *priv, u32 command, int in, int out,\n\t\t\t     u32 data[CX2341X_MBOX_MAX_DATA])\n{\n\tstruct cx231xx *dev = priv;\n\tunsigned long timeout;\n\tu32 value, flag, retval = 0;\n\tint i;\n\n\tdprintk(3, \"%s: command(0x%X) = %s\\n\", __func__, command,\n\t\tcmd_to_str(command));\n\n\t \n\tmc417_memory_read(dev, dev->cx23417_mailbox - 4, &value);\n\tif (value != 0x12345678) {\n\t\tdprintk(3, \"Firmware and/or mailbox pointer not initialized or corrupted, signature = 0x%x, cmd = %s\\n\",\n\t\t\tvalue, cmd_to_str(command));\n\t\treturn -EIO;\n\t}\n\n\t \n\tmc417_memory_read(dev, dev->cx23417_mailbox, &flag);\n\tif (flag) {\n\t\tdprintk(3, \"ERROR: Mailbox appears to be in use (%x), cmd = %s\\n\",\n\t\t\t\tflag, cmd_to_str(command));\n\t\treturn -EBUSY;\n\t}\n\n\tflag |= 1;  \n\tmc417_memory_write(dev, dev->cx23417_mailbox, flag);\n\n\t \n\t \n\tmc417_memory_write(dev, dev->cx23417_mailbox + 1, command);\n\tmc417_memory_write(dev, dev->cx23417_mailbox + 3,\n\t\tIVTV_API_STD_TIMEOUT);  \n\tfor (i = 0; i < in; i++) {\n\t\tmc417_memory_write(dev, dev->cx23417_mailbox + 4 + i, data[i]);\n\t\tdprintk(3, \"API Input %d = %d\\n\", i, data[i]);\n\t}\n\tfor (; i < CX2341X_MBOX_MAX_DATA; i++)\n\t\tmc417_memory_write(dev, dev->cx23417_mailbox + 4 + i, 0);\n\n\tflag |= 3;  \n\tmc417_memory_write(dev, dev->cx23417_mailbox, flag);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(10);\n\tfor (;;) {\n\t\tmc417_memory_read(dev, dev->cx23417_mailbox, &flag);\n\t\tif (0 != (flag & 4))\n\t\t\tbreak;\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdprintk(3, \"ERROR: API Mailbox timeout\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tudelay(10);\n\t}\n\n\t \n\tfor (i = 0; i < out; i++) {\n\t\tmc417_memory_read(dev, dev->cx23417_mailbox + 4 + i, data + i);\n\t\tdprintk(3, \"API Output %d = %d\\n\", i, data[i]);\n\t}\n\n\tmc417_memory_read(dev, dev->cx23417_mailbox + 2, &retval);\n\tdprintk(3, \"API result = %d\\n\", retval);\n\n\tflag = 0;\n\tmc417_memory_write(dev, dev->cx23417_mailbox, flag);\n\n\treturn 0;\n}\n\n \nstatic int cx231xx_api_cmd(struct cx231xx *dev, u32 command,\n\t\tu32 inputcnt, u32 outputcnt, ...)\n{\n\tu32 data[CX2341X_MBOX_MAX_DATA];\n\tva_list vargs;\n\tint i, err;\n\n\tdprintk(3, \"%s() cmds = 0x%08x\\n\", __func__, command);\n\n\tva_start(vargs, outputcnt);\n\tfor (i = 0; i < inputcnt; i++)\n\t\tdata[i] = va_arg(vargs, int);\n\n\terr = cx231xx_mbox_func(dev, command, inputcnt, outputcnt, data);\n\tfor (i = 0; i < outputcnt; i++) {\n\t\tint *vptr = va_arg(vargs, int *);\n\t\t*vptr = data[i];\n\t}\n\tva_end(vargs);\n\n\treturn err;\n}\n\n\nstatic int cx231xx_find_mailbox(struct cx231xx *dev)\n{\n\tu32 signature[4] = {\n\t\t0x12345678, 0x34567812, 0x56781234, 0x78123456\n\t};\n\tint signaturecnt = 0;\n\tu32 value;\n\tint i;\n\tint ret = 0;\n\n\tdprintk(2, \"%s()\\n\", __func__);\n\n\tfor (i = 0; i < 0x100; i++) { \n\t\tret = mc417_memory_read(dev, i, &value);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (value == signature[signaturecnt])\n\t\t\tsignaturecnt++;\n\t\telse\n\t\t\tsignaturecnt = 0;\n\t\tif (4 == signaturecnt) {\n\t\t\tdprintk(1, \"Mailbox signature found at 0x%x\\n\", i + 1);\n\t\t\treturn i + 1;\n\t\t}\n\t}\n\tdprintk(3, \"Mailbox signature values not found!\\n\");\n\treturn -EIO;\n}\n\nstatic void mci_write_memory_to_gpio(struct cx231xx *dev, u32 address, u32 value,\n\t\tu32 *p_fw_image)\n{\n\tu32 temp = 0;\n\tint i = 0;\n\n\ttemp = 0x82 | MCI_MEMORY_DATA_BYTE0 | ((value & 0x000000FF) << 8);\n\ttemp = temp << 10;\n\t*p_fw_image = temp;\n\tp_fw_image++;\n\ttemp = temp | (0x05 << 10);\n\t*p_fw_image = temp;\n\tp_fw_image++;\n\n\t \n\ttemp = 0x82 | MCI_MEMORY_DATA_BYTE1 | (value & 0x0000FF00);\n\ttemp = temp << 10;\n\t*p_fw_image = temp;\n\tp_fw_image++;\n\ttemp = temp | (0x05 << 10);\n\t*p_fw_image = temp;\n\tp_fw_image++;\n\n\t \n\ttemp = 0x82 | MCI_MEMORY_DATA_BYTE2 | ((value & 0x00FF0000) >> 8);\n\ttemp = temp << 10;\n\t*p_fw_image = temp;\n\tp_fw_image++;\n\ttemp = temp | (0x05 << 10);\n\t*p_fw_image = temp;\n\tp_fw_image++;\n\n\t \n\ttemp = 0x82 | MCI_MEMORY_DATA_BYTE3 | ((value & 0xFF000000) >> 16);\n\ttemp = temp << 10;\n\t*p_fw_image = temp;\n\tp_fw_image++;\n\ttemp = temp | (0x05 << 10);\n\t*p_fw_image = temp;\n\tp_fw_image++;\n\n\t \n\ttemp = 0x82 | MCI_MEMORY_ADDRESS_BYTE2 | MCI_MODE_MEMORY_WRITE |\n\t\t((address & 0x003F0000) >> 8);\n\ttemp = temp << 10;\n\t*p_fw_image = temp;\n\tp_fw_image++;\n\ttemp = temp | (0x05 << 10);\n\t*p_fw_image = temp;\n\tp_fw_image++;\n\n\t \n\ttemp = 0x82 | MCI_MEMORY_ADDRESS_BYTE1 | (address & 0xFF00);\n\ttemp = temp << 10;\n\t*p_fw_image = temp;\n\tp_fw_image++;\n\ttemp = temp | (0x05 << 10);\n\t*p_fw_image = temp;\n\tp_fw_image++;\n\n\t \n\ttemp = 0x82 | MCI_MEMORY_ADDRESS_BYTE0 | ((address & 0x00FF) << 8);\n\ttemp = temp << 10;\n\t*p_fw_image = temp;\n\tp_fw_image++;\n\ttemp = temp | (0x05 << 10);\n\t*p_fw_image = temp;\n\tp_fw_image++;\n\n\tfor (i = 0; i < 6; i++) {\n\t\t*p_fw_image = 0xFFFFFFFF;\n\t\tp_fw_image++;\n\t}\n}\n\n\nstatic int cx231xx_load_firmware(struct cx231xx *dev)\n{\n\tstatic const unsigned char magic[8] = {\n\t\t0xa7, 0x0d, 0x00, 0x00, 0x66, 0xbb, 0x55, 0xaa\n\t};\n\tconst struct firmware *firmware;\n\tint i, retval = 0;\n\tu32 value = 0;\n\tu32 gpio_output = 0;\n\t \n\t \n\tu32 transfer_size = 0;\n\tu32 fw_data = 0;\n\tu32 address = 0;\n\t \n\tu32 *p_current_fw, *p_fw;\n\tu32 *p_fw_data;\n\tint frame = 0;\n\tu16 _buffer_size = 4096;\n\tu8 *p_buffer;\n\n\tp_current_fw = vmalloc(1884180 * 4);\n\tp_fw = p_current_fw;\n\tif (p_current_fw == NULL) {\n\t\tdprintk(2, \"FAIL!!!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tp_buffer = vmalloc(4096);\n\tif (p_buffer == NULL) {\n\t\tdprintk(2, \"FAIL!!!\\n\");\n\t\tvfree(p_current_fw);\n\t\treturn -ENOMEM;\n\t}\n\n\tdprintk(2, \"%s()\\n\", __func__);\n\n\t \n\tretval |= mc417_memory_read(dev, 0x9020, &gpio_output);\n\tretval |= mc417_memory_read(dev, 0x900C, &value);\n\n\tretval  = mc417_register_write(dev,\n\t\tIVTV_REG_VPU, 0xFFFFFFED);\n\tretval |= mc417_register_write(dev,\n\t\tIVTV_REG_HW_BLOCKS, IVTV_CMD_HW_BLOCKS_RST);\n\tretval |= mc417_register_write(dev,\n\t\tIVTV_REG_ENC_SDRAM_REFRESH, 0x80000800);\n\tretval |= mc417_register_write(dev,\n\t\tIVTV_REG_ENC_SDRAM_PRECHARGE, 0x1A);\n\tretval |= mc417_register_write(dev,\n\t\tIVTV_REG_APU, 0);\n\n\tif (retval != 0) {\n\t\tdev_err(dev->dev,\n\t\t\t\"%s: Error with mc417_register_write\\n\", __func__);\n\t\tvfree(p_current_fw);\n\t\tvfree(p_buffer);\n\t\treturn retval;\n\t}\n\n\tretval = request_firmware(&firmware, CX231xx_FIRM_IMAGE_NAME,\n\t\t\t\t  dev->dev);\n\n\tif (retval != 0) {\n\t\tdev_err(dev->dev,\n\t\t\t\"ERROR: Hotplug firmware request failed (%s).\\n\",\n\t\t\tCX231xx_FIRM_IMAGE_NAME);\n\t\tdev_err(dev->dev,\n\t\t\t\"Please fix your hotplug setup, the board will not work without firmware loaded!\\n\");\n\t\tvfree(p_current_fw);\n\t\tvfree(p_buffer);\n\t\treturn retval;\n\t}\n\n\tif (firmware->size != CX231xx_FIRM_IMAGE_SIZE) {\n\t\tdev_err(dev->dev,\n\t\t\t\"ERROR: Firmware size mismatch (have %zd, expected %d)\\n\",\n\t\t\tfirmware->size, CX231xx_FIRM_IMAGE_SIZE);\n\t\trelease_firmware(firmware);\n\t\tvfree(p_current_fw);\n\t\tvfree(p_buffer);\n\t\treturn -EINVAL;\n\t}\n\n\tif (0 != memcmp(firmware->data, magic, 8)) {\n\t\tdev_err(dev->dev,\n\t\t\t\"ERROR: Firmware magic mismatch, wrong file?\\n\");\n\t\trelease_firmware(firmware);\n\t\tvfree(p_current_fw);\n\t\tvfree(p_buffer);\n\t\treturn -EINVAL;\n\t}\n\n\tinitGPIO(dev);\n\n\t \n\tdprintk(2, \"Loading firmware to GPIO...\\n\");\n\tp_fw_data = (u32 *)firmware->data;\n\tdprintk(2, \"firmware->size=%zd\\n\", firmware->size);\n\tfor (transfer_size = 0; transfer_size < firmware->size;\n\t\t transfer_size += 4) {\n\t\tfw_data = *p_fw_data;\n\n\t\tmci_write_memory_to_gpio(dev, address, fw_data, p_current_fw);\n\t\taddress = address + 1;\n\t\tp_current_fw += 20;\n\t\tp_fw_data += 1;\n\t}\n\n\t \n\n\tfor (frame = 0; frame < (int)(CX231xx_FIRM_IMAGE_SIZE*20/_buffer_size);\n\t     frame++) {\n\t\tfor (i = 0; i < _buffer_size; i++) {\n\t\t\t*(p_buffer + i) = (u8)(*(p_fw + (frame * 128 * 8 + (i / 4))) & 0x000000FF);\n\t\t\ti++;\n\t\t\t*(p_buffer + i) = (u8)((*(p_fw + (frame * 128 * 8 + (i / 4))) & 0x0000FF00) >> 8);\n\t\t\ti++;\n\t\t\t*(p_buffer + i) = (u8)((*(p_fw + (frame * 128 * 8 + (i / 4))) & 0x00FF0000) >> 16);\n\t\t\ti++;\n\t\t\t*(p_buffer + i) = (u8)((*(p_fw + (frame * 128 * 8 + (i / 4))) & 0xFF000000) >> 24);\n\t\t}\n\t\tcx231xx_ep5_bulkout(dev, p_buffer, _buffer_size);\n\t}\n\n\tp_current_fw = p_fw;\n\tvfree(p_current_fw);\n\tp_current_fw = NULL;\n\tvfree(p_buffer);\n\tuninitGPIO(dev);\n\trelease_firmware(firmware);\n\tdprintk(1, \"Firmware upload successful.\\n\");\n\n\tretval |= mc417_register_write(dev, IVTV_REG_HW_BLOCKS,\n\t\tIVTV_CMD_HW_BLOCKS_RST);\n\tif (retval < 0) {\n\t\tdev_err(dev->dev,\n\t\t\t\"%s: Error with mc417_register_write\\n\",\n\t\t\t__func__);\n\t\treturn retval;\n\t}\n\t \n\tretval |= mc417_register_write(dev, 0x9020, gpio_output);\n\tretval |= mc417_register_write(dev, 0x900C, value);\n\n\tretval |= mc417_register_read(dev, IVTV_REG_VPU, &value);\n\tretval |= mc417_register_write(dev, IVTV_REG_VPU, value & 0xFFFFFFE8);\n\n\tif (retval < 0) {\n\t\tdev_err(dev->dev,\n\t\t\t\"%s: Error with mc417_register_write\\n\",\n\t\t\t__func__);\n\t\treturn retval;\n\t}\n\treturn 0;\n}\n\nstatic void cx231xx_codec_settings(struct cx231xx *dev)\n{\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t \n\tcx231xx_api_cmd(dev, CX2341X_ENC_SET_FRAME_SIZE, 2, 0,\n\t\t\t\tdev->ts1.height, dev->ts1.width);\n\n\tdev->mpeg_ctrl_handler.width = dev->ts1.width;\n\tdev->mpeg_ctrl_handler.height = dev->ts1.height;\n\n\tcx2341x_handler_setup(&dev->mpeg_ctrl_handler);\n\n\tcx231xx_api_cmd(dev, CX2341X_ENC_MISC, 2, 0, 3, 1);\n\tcx231xx_api_cmd(dev, CX2341X_ENC_MISC, 2, 0, 4, 1);\n}\n\nstatic int cx231xx_initialize_codec(struct cx231xx *dev)\n{\n\tint version;\n\tint retval;\n\tu32 i;\n\tu32 val = 0;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\tcx231xx_disable656(dev);\n\tretval = cx231xx_api_cmd(dev, CX2341X_ENC_PING_FW, 0, 0);  \n\tif (retval < 0) {\n\t\tdprintk(2, \"%s: PING OK\\n\", __func__);\n\t\tretval = cx231xx_load_firmware(dev);\n\t\tif (retval < 0) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"%s: f/w load failed\\n\", __func__);\n\t\t\treturn retval;\n\t\t}\n\t\tretval = cx231xx_find_mailbox(dev);\n\t\tif (retval < 0) {\n\t\t\tdev_err(dev->dev, \"%s: mailbox < 0, error\\n\",\n\t\t\t\t__func__);\n\t\t\treturn retval;\n\t\t}\n\t\tdev->cx23417_mailbox = retval;\n\t\tretval = cx231xx_api_cmd(dev, CX2341X_ENC_PING_FW, 0, 0);\n\t\tif (retval < 0) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"ERROR: cx23417 firmware ping failed!\\n\");\n\t\t\treturn retval;\n\t\t}\n\t\tretval = cx231xx_api_cmd(dev, CX2341X_ENC_GET_VERSION, 0, 1,\n\t\t\t&version);\n\t\tif (retval < 0) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"ERROR: cx23417 firmware get encoder: version failed!\\n\");\n\t\t\treturn retval;\n\t\t}\n\t\tdprintk(1, \"cx23417 firmware version is 0x%08x\\n\", version);\n\t\tmsleep(200);\n\t}\n\n\tfor (i = 0; i < 1; i++) {\n\t\tretval = mc417_register_read(dev, 0x20f8, &val);\n\t\tdprintk(3, \"***before enable656() VIM Capture Lines = %d ***\\n\",\n\t\t\t\t val);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\tcx231xx_enable656(dev);\n\n\t \n\tcx231xx_api_cmd(dev, CX2341X_ENC_STOP_CAPTURE, 3, 0, 1, 3, 4);\n\n\tcx231xx_codec_settings(dev);\n\tmsleep(60);\n\n \n\n#if 0\n\t \n\tu32 data[7];\n\n\t \n\tdata[0] = 0x0001BD00;\n\tdata[1] = 1;           \n\tdata[2] = 4;           \n\tdata[3] = 0x91559155;  \n\tdata[4] = 0x206080C0;  \n\tdata[5] = 6;           \n\tdata[6] = 64;          \n\n\tcx231xx_api_cmd(dev, CX2341X_ENC_SET_VBI_CONFIG, 7, 0, data[0], data[1],\n\t\tdata[2], data[3], data[4], data[5], data[6]);\n\n\tfor (i = 2; i <= 24; i++) {\n\t\tint valid;\n\n\t\tvalid = ((i >= 19) && (i <= 21));\n\t\tcx231xx_api_cmd(dev, CX2341X_ENC_SET_VBI_LINE, 5, 0, i,\n\t\t\t\tvalid, 0 , 0, 0);\n\t\tcx231xx_api_cmd(dev, CX2341X_ENC_SET_VBI_LINE, 5, 0,\n\t\t\t\ti | 0x80000000, valid, 0, 0, 0);\n\t}\n#endif\n \n\t \n\tretval = cx231xx_api_cmd(dev, CX2341X_ENC_INITIALIZE_INPUT, 0, 0);\n\tif (retval < 0)\n\t\treturn retval;\n\tmsleep(60);\n\n\t \n\tmc417_memory_write(dev, 2120, 0x00000080);\n\n\t \n\tretval = cx231xx_api_cmd(dev, CX2341X_ENC_START_CAPTURE, 2, 0,\n\t\tCX231xx_MPEG_CAPTURE, CX231xx_RAW_BITS_NONE);\n\tif (retval < 0)\n\t\treturn retval;\n\tmsleep(10);\n\n\tfor (i = 0; i < 1; i++) {\n\t\tmc417_register_read(dev, 0x20f8, &val);\n\t\tdprintk(3, \"***VIM Capture Lines =%d ***\\n\", val);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int queue_setup(struct vb2_queue *vq,\n\t\t       unsigned int *nbuffers, unsigned int *nplanes,\n\t\t       unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct cx231xx *dev = vb2_get_drv_priv(vq);\n\tunsigned int size = mpeglinesize * mpeglines;\n\n\tdev->ts1.ts_packet_size  = mpeglinesize;\n\tdev->ts1.ts_packet_count = mpeglines;\n\n\tif (vq->num_buffers + *nbuffers < CX231XX_MIN_BUF)\n\t\t*nbuffers = CX231XX_MIN_BUF - vq->num_buffers;\n\n\tif (*nplanes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\t*nplanes = 1;\n\tsizes[0] = mpeglinesize * mpeglines;\n\n\treturn 0;\n}\n\nstatic void buffer_copy(struct cx231xx *dev, char *data, int len, struct urb *urb,\n\t\tstruct cx231xx_dmaqueue *dma_q)\n{\n\tvoid *vbuf;\n\tstruct cx231xx_buffer *buf;\n\tu32 tail_data = 0;\n\tchar *p_data;\n\n\tif (dma_q->mpeg_buffer_done == 0) {\n\t\tif (list_empty(&dma_q->active))\n\t\t\treturn;\n\n\t\tbuf = list_entry(dma_q->active.next,\n\t\t\t\tstruct cx231xx_buffer, list);\n\t\tdev->video_mode.isoc_ctl.buf = buf;\n\t\tdma_q->mpeg_buffer_done = 1;\n\t}\n\t \n\tbuf = dev->video_mode.isoc_ctl.buf;\n\tvbuf = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\n\n\tif ((dma_q->mpeg_buffer_completed+len) <\n\t\t\tmpeglines*mpeglinesize) {\n\t\tif (dma_q->add_ps_package_head ==\n\t\t\t\tCX231XX_NEED_ADD_PS_PACKAGE_HEAD) {\n\t\t\tmemcpy(vbuf+dma_q->mpeg_buffer_completed,\n\t\t\t\t\tdma_q->ps_head, 3);\n\t\t\tdma_q->mpeg_buffer_completed =\n\t\t\t\tdma_q->mpeg_buffer_completed + 3;\n\t\t\tdma_q->add_ps_package_head =\n\t\t\t\tCX231XX_NONEED_PS_PACKAGE_HEAD;\n\t\t}\n\t\tmemcpy(vbuf+dma_q->mpeg_buffer_completed, data, len);\n\t\tdma_q->mpeg_buffer_completed =\n\t\t\tdma_q->mpeg_buffer_completed + len;\n\t} else {\n\t\tdma_q->mpeg_buffer_done = 0;\n\n\t\ttail_data =\n\t\t\tmpeglines*mpeglinesize - dma_q->mpeg_buffer_completed;\n\t\tmemcpy(vbuf+dma_q->mpeg_buffer_completed,\n\t\t\t\tdata, tail_data);\n\n\t\tbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\tbuf->vb.sequence = dma_q->sequence++;\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\t\tdma_q->mpeg_buffer_completed = 0;\n\n\t\tif (len - tail_data > 0) {\n\t\t\tp_data = data + tail_data;\n\t\t\tdma_q->left_data_count = len - tail_data;\n\t\t\tmemcpy(dma_q->p_left_data,\n\t\t\t\t\tp_data, len - tail_data);\n\t\t}\n\t}\n}\n\nstatic void buffer_filled(char *data, int len, struct urb *urb,\n\t\tstruct cx231xx_dmaqueue *dma_q)\n{\n\tvoid *vbuf;\n\tstruct cx231xx_buffer *buf;\n\n\tif (list_empty(&dma_q->active))\n\t\treturn;\n\n\tbuf = list_entry(dma_q->active.next, struct cx231xx_buffer, list);\n\n\t \n\tvbuf = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\n\tmemcpy(vbuf, data, len);\n\tbuf->vb.sequence = dma_q->sequence++;\n\tbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\tlist_del(&buf->list);\n\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n}\n\nstatic int cx231xx_isoc_copy(struct cx231xx *dev, struct urb *urb)\n{\n\tstruct cx231xx_dmaqueue *dma_q = urb->context;\n\tunsigned char *p_buffer;\n\tu32 buffer_size = 0;\n\tu32 i = 0;\n\n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\tif (dma_q->left_data_count > 0) {\n\t\t\tbuffer_copy(dev, dma_q->p_left_data,\n\t\t\t\t    dma_q->left_data_count, urb, dma_q);\n\t\t\tdma_q->mpeg_buffer_completed = dma_q->left_data_count;\n\t\t\tdma_q->left_data_count = 0;\n\t\t}\n\n\t\tp_buffer = urb->transfer_buffer +\n\t\t\t\turb->iso_frame_desc[i].offset;\n\t\tbuffer_size = urb->iso_frame_desc[i].actual_length;\n\n\t\tif (buffer_size > 0)\n\t\t\tbuffer_copy(dev, p_buffer, buffer_size, urb, dma_q);\n\t}\n\n\treturn 0;\n}\n\nstatic int cx231xx_bulk_copy(struct cx231xx *dev, struct urb *urb)\n{\n\tstruct cx231xx_dmaqueue *dma_q = urb->context;\n\tunsigned char *p_buffer, *buffer;\n\tu32 buffer_size = 0;\n\n\tp_buffer = urb->transfer_buffer;\n\tbuffer_size = urb->actual_length;\n\n\tbuffer = kmalloc(buffer_size, GFP_ATOMIC);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tmemcpy(buffer, dma_q->ps_head, 3);\n\tmemcpy(buffer+3, p_buffer, buffer_size-3);\n\tmemcpy(dma_q->ps_head, p_buffer+buffer_size-3, 3);\n\n\tp_buffer = buffer;\n\tbuffer_filled(p_buffer, buffer_size, urb, dma_q);\n\n\tkfree(buffer);\n\treturn 0;\n}\n\nstatic void buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct cx231xx_buffer *buf =\n\t    container_of(vb, struct cx231xx_buffer, vb.vb2_buf);\n\tstruct cx231xx *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct cx231xx_dmaqueue *vidq = &dev->video_mode.vidq;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->video_mode.slock, flags);\n\tlist_add_tail(&buf->list, &vidq->active);\n\tspin_unlock_irqrestore(&dev->video_mode.slock, flags);\n}\n\nstatic void return_all_buffers(struct cx231xx *dev,\n\t\t\t       enum vb2_buffer_state state)\n{\n\tstruct cx231xx_dmaqueue *vidq = &dev->video_mode.vidq;\n\tstruct cx231xx_buffer *buf, *node;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->video_mode.slock, flags);\n\tlist_for_each_entry_safe(buf, node, &vidq->active, list) {\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t\tlist_del(&buf->list);\n\t}\n\tspin_unlock_irqrestore(&dev->video_mode.slock, flags);\n}\n\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct cx231xx *dev = vb2_get_drv_priv(vq);\n\tstruct cx231xx_dmaqueue *vidq = &dev->video_mode.vidq;\n\tint ret = 0;\n\n\tvidq->sequence = 0;\n\tdev->mode_tv = 1;\n\n\tcx231xx_set_alt_setting(dev, INDEX_VANC, 1);\n\tcx231xx_set_gpio_value(dev, 2, 0);\n\n\tcx231xx_initialize_codec(dev);\n\n\tcx231xx_start_TS1(dev);\n\n\tcx231xx_set_alt_setting(dev, INDEX_TS1, 0);\n\tcx231xx_set_mode(dev, CX231XX_DIGITAL_MODE);\n\tif (dev->USE_ISO)\n\t\tret = cx231xx_init_isoc(dev, CX231XX_NUM_PACKETS,\n\t\t\t\t\tCX231XX_NUM_BUFS,\n\t\t\t\t\tdev->ts1_mode.max_pkt_size,\n\t\t\t\t\tcx231xx_isoc_copy);\n\telse\n\t\tret = cx231xx_init_bulk(dev, 320, 5,\n\t\t\t\t\tdev->ts1_mode.max_pkt_size,\n\t\t\t\t\tcx231xx_bulk_copy);\n\tif (ret)\n\t\treturn_all_buffers(dev, VB2_BUF_STATE_QUEUED);\n\n\tcall_all(dev, video, s_stream, 1);\n\treturn ret;\n}\n\nstatic void stop_streaming(struct vb2_queue *vq)\n{\n\tstruct cx231xx *dev = vb2_get_drv_priv(vq);\n\tunsigned long flags;\n\n\tcall_all(dev, video, s_stream, 0);\n\n\tcx231xx_stop_TS1(dev);\n\n\t \n\tif (dev->USE_ISO)\n\t\tcx231xx_uninit_isoc(dev);\n\telse\n\t\tcx231xx_uninit_bulk(dev);\n\tcx231xx_set_mode(dev, CX231XX_SUSPEND);\n\n\tcx231xx_api_cmd(dev, CX2341X_ENC_STOP_CAPTURE, 3, 0,\n\t\t\tCX231xx_END_NOW, CX231xx_MPEG_CAPTURE,\n\t\t\tCX231xx_RAW_BITS_NONE);\n\n\tspin_lock_irqsave(&dev->video_mode.slock, flags);\n\tif (dev->USE_ISO)\n\t\tdev->video_mode.isoc_ctl.buf = NULL;\n\telse\n\t\tdev->video_mode.bulk_ctl.buf = NULL;\n\tspin_unlock_irqrestore(&dev->video_mode.slock, flags);\n\treturn_all_buffers(dev, VB2_BUF_STATE_ERROR);\n}\n\nstatic struct vb2_ops cx231xx_video_qops = {\n\t.queue_setup\t\t= queue_setup,\n\t.buf_queue\t\t= buffer_queue,\n\t.start_streaming\t= start_streaming,\n\t.stop_streaming\t\t= stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\n \n\nstatic int vidioc_g_pixelaspect(struct file *file, void *priv,\n\t\t\t\tint type, struct v4l2_fract *f)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\tbool is_50hz = dev->encodernorm.id & V4L2_STD_625_50;\n\n\tif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tf->numerator = is_50hz ? 54 : 11;\n\tf->denominator = is_50hz ? 59 : 10;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_selection(struct file *file, void *priv,\n\t\t\t      struct v4l2_selection *s)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = dev->ts1.width;\n\t\ts->r.height = dev->ts1.height;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_g_std(struct file *file, void *fh0, v4l2_std_id *norm)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\n\t*norm = dev->encodernorm.id;\n\treturn 0;\n}\n\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id id)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cx231xx_tvnorms); i++)\n\t\tif (id & cx231xx_tvnorms[i].id)\n\t\t\tbreak;\n\tif (i == ARRAY_SIZE(cx231xx_tvnorms))\n\t\treturn -EINVAL;\n\tdev->encodernorm = cx231xx_tvnorms[i];\n\n\tif (dev->encodernorm.id & 0xb000) {\n\t\tdprintk(3, \"encodernorm set to NTSC\\n\");\n\t\tdev->norm = V4L2_STD_NTSC;\n\t\tdev->ts1.height = 480;\n\t\tcx2341x_handler_set_50hz(&dev->mpeg_ctrl_handler, false);\n\t} else {\n\t\tdprintk(3, \"encodernorm set to PAL\\n\");\n\t\tdev->norm = V4L2_STD_PAL_B;\n\t\tdev->ts1.height = 576;\n\t\tcx2341x_handler_set_50hz(&dev->mpeg_ctrl_handler, true);\n\t}\n\tcall_all(dev, video, s_std, dev->norm);\n\t \n\tcx231xx_do_mode_ctrl_overrides(dev);\n\n\tdprintk(3, \"exit vidioc_s_std() i=0x%x\\n\", i);\n\treturn 0;\n}\n\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_control *ctl)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\tstruct v4l2_subdev *sd;\n\n\tdprintk(3, \"enter vidioc_s_ctrl()\\n\");\n\t \n\tv4l2_device_for_each_subdev(sd, &dev->v4l2_dev)\n\t\tv4l2_s_ctrl(NULL, sd->ctrl_handler, ctl);\n\tdprintk(3, \"exit vidioc_s_ctrl()\\n\");\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,\n\t\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\tif (f->index != 0)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = V4L2_PIX_FMT_MPEG;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\n\tdprintk(3, \"enter vidioc_g_fmt_vid_cap()\\n\");\n\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\n\tf->fmt.pix.bytesperline = 0;\n\tf->fmt.pix.sizeimage = mpeglines * mpeglinesize;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tf->fmt.pix.width = dev->ts1.width;\n\tf->fmt.pix.height = dev->ts1.height;\n\tf->fmt.pix.field = V4L2_FIELD_INTERLACED;\n\tdprintk(1, \"VIDIOC_G_FMT: w: %d, h: %d\\n\",\n\t\tdev->ts1.width, dev->ts1.height);\n\tdprintk(3, \"exit vidioc_g_fmt_vid_cap()\\n\");\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\n\tdprintk(3, \"enter vidioc_try_fmt_vid_cap()\\n\");\n\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\n\tf->fmt.pix.bytesperline = 0;\n\tf->fmt.pix.sizeimage = mpeglines * mpeglinesize;\n\tf->fmt.pix.field = V4L2_FIELD_INTERLACED;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tdprintk(1, \"VIDIOC_TRY_FMT: w: %d, h: %d\\n\",\n\t\tdev->ts1.width, dev->ts1.height);\n\tdprintk(3, \"exit vidioc_try_fmt_vid_cap()\\n\");\n\treturn 0;\n}\n\nstatic int vidioc_log_status(struct file *file, void *priv)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\n\tcall_all(dev, core, log_status);\n\treturn v4l2_ctrl_log_status(file, priv);\n}\n\nstatic const struct v4l2_file_operations mpeg_fops = {\n\t.owner\t       = THIS_MODULE,\n\t.open\t       = v4l2_fh_open,\n\t.release       = vb2_fop_release,\n\t.read\t       = vb2_fop_read,\n\t.poll          = vb2_fop_poll,\n\t.mmap\t       = vb2_fop_mmap,\n\t.unlocked_ioctl = video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops mpeg_ioctl_ops = {\n\t.vidioc_s_std\t\t = vidioc_s_std,\n\t.vidioc_g_std\t\t = vidioc_g_std,\n\t.vidioc_g_tuner          = cx231xx_g_tuner,\n\t.vidioc_s_tuner          = cx231xx_s_tuner,\n\t.vidioc_g_frequency      = cx231xx_g_frequency,\n\t.vidioc_s_frequency      = cx231xx_s_frequency,\n\t.vidioc_enum_input\t = cx231xx_enum_input,\n\t.vidioc_g_input\t\t = cx231xx_g_input,\n\t.vidioc_s_input\t\t = cx231xx_s_input,\n\t.vidioc_s_ctrl\t\t = vidioc_s_ctrl,\n\t.vidioc_g_pixelaspect\t = vidioc_g_pixelaspect,\n\t.vidioc_g_selection\t = vidioc_g_selection,\n\t.vidioc_querycap\t = cx231xx_querycap,\n\t.vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t = vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t = vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t = vidioc_try_fmt_vid_cap,\n\t.vidioc_reqbufs\t\t = vb2_ioctl_reqbufs,\n\t.vidioc_querybuf\t = vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t = vb2_ioctl_dqbuf,\n\t.vidioc_streamon\t = vb2_ioctl_streamon,\n\t.vidioc_streamoff\t = vb2_ioctl_streamoff,\n\t.vidioc_log_status\t = vidioc_log_status,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_register\t = cx231xx_g_register,\n\t.vidioc_s_register\t = cx231xx_s_register,\n#endif\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic struct video_device cx231xx_mpeg_template = {\n\t.name          = \"cx231xx\",\n\t.fops          = &mpeg_fops,\n\t.ioctl_ops     = &mpeg_ioctl_ops,\n\t.minor         = -1,\n\t.tvnorms       = V4L2_STD_ALL,\n};\n\nvoid cx231xx_417_unregister(struct cx231xx *dev)\n{\n\tdprintk(1, \"%s()\\n\", __func__);\n\tdprintk(3, \"%s()\\n\", __func__);\n\n\tif (video_is_registered(&dev->v4l_device)) {\n\t\tvideo_unregister_device(&dev->v4l_device);\n\t\tv4l2_ctrl_handler_free(&dev->mpeg_ctrl_handler.hdl);\n\t}\n}\n\nstatic int cx231xx_s_video_encoding(struct cx2341x_handler *cxhdl, u32 val)\n{\n\tstruct cx231xx *dev = container_of(cxhdl, struct cx231xx, mpeg_ctrl_handler);\n\tint is_mpeg1 = val == V4L2_MPEG_VIDEO_ENCODING_MPEG_1;\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\n\t \n\tformat.format.width = cxhdl->width / (is_mpeg1 ? 2 : 1);\n\tformat.format.height = cxhdl->height;\n\tformat.format.code = MEDIA_BUS_FMT_FIXED;\n\tv4l2_subdev_call(dev->sd_cx25840, pad, set_fmt, NULL, &format);\n\treturn 0;\n}\n\nstatic int cx231xx_s_audio_sampling_freq(struct cx2341x_handler *cxhdl, u32 idx)\n{\n\tstatic const u32 freqs[3] = { 44100, 48000, 32000 };\n\tstruct cx231xx *dev = container_of(cxhdl, struct cx231xx, mpeg_ctrl_handler);\n\n\t \n\tif (idx < ARRAY_SIZE(freqs))\n\t\tcall_all(dev, audio, s_clock_freq, freqs[idx]);\n\treturn 0;\n}\n\nstatic const struct cx2341x_handler_ops cx231xx_ops = {\n\t \n\t.s_audio_sampling_freq = cx231xx_s_audio_sampling_freq,\n\t \n\t.s_video_encoding = cx231xx_s_video_encoding,\n};\n\nstatic void cx231xx_video_dev_init(\n\tstruct cx231xx *dev,\n\tstruct usb_device *usbdev,\n\tstruct video_device *vfd,\n\tconst struct video_device *template,\n\tconst char *type)\n{\n\tdprintk(1, \"%s()\\n\", __func__);\n\t*vfd = *template;\n\tsnprintf(vfd->name, sizeof(vfd->name), \"%s %s (%s)\", dev->name,\n\t\ttype, cx231xx_boards[dev->model].name);\n\n\tvfd->v4l2_dev = &dev->v4l2_dev;\n\tvfd->lock = &dev->lock;\n\tvfd->release = video_device_release_empty;\n\tvfd->ctrl_handler = &dev->mpeg_ctrl_handler.hdl;\n\tvideo_set_drvdata(vfd, dev);\n\tif (dev->tuner_type == TUNER_ABSENT) {\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_G_FREQUENCY);\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_S_FREQUENCY);\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_G_TUNER);\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_S_TUNER);\n\t}\n}\n\nint cx231xx_417_register(struct cx231xx *dev)\n{\n\t \n\tint err;\n\tstruct cx231xx_tsport *tsport = &dev->ts1;\n\tstruct vb2_queue *q;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t \n\tdev->encodernorm = cx231xx_tvnorms[0];\n\n\tif (dev->encodernorm.id & V4L2_STD_525_60)\n\t\ttsport->height = 480;\n\telse\n\t\ttsport->height = 576;\n\n\ttsport->width = 720;\n\terr = cx2341x_handler_init(&dev->mpeg_ctrl_handler, 50);\n\tif (err) {\n\t\tdprintk(3, \"%s: can't init cx2341x controls\\n\", dev->name);\n\t\treturn err;\n\t}\n\tdev->mpeg_ctrl_handler.func = cx231xx_mbox_func;\n\tdev->mpeg_ctrl_handler.priv = dev;\n\tdev->mpeg_ctrl_handler.ops = &cx231xx_ops;\n\tif (dev->sd_cx25840)\n\t\tv4l2_ctrl_add_handler(&dev->mpeg_ctrl_handler.hdl,\n\t\t\t\tdev->sd_cx25840->ctrl_handler, NULL, false);\n\tif (dev->mpeg_ctrl_handler.hdl.error) {\n\t\terr = dev->mpeg_ctrl_handler.hdl.error;\n\t\tdprintk(3, \"%s: can't add cx25840 controls\\n\", dev->name);\n\t\tv4l2_ctrl_handler_free(&dev->mpeg_ctrl_handler.hdl);\n\t\treturn err;\n\t}\n\tdev->norm = V4L2_STD_NTSC;\n\n\tdev->mpeg_ctrl_handler.port = CX2341X_PORT_SERIAL;\n\tcx2341x_handler_set_50hz(&dev->mpeg_ctrl_handler, false);\n\n\t \n\tcx231xx_video_dev_init(dev, dev->udev,\n\t\t\t&dev->v4l_device, &cx231xx_mpeg_template, \"mpeg\");\n\tq = &dev->mpegq;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_USERPTR | VB2_MMAP | VB2_DMABUF | VB2_READ;\n\tq->drv_priv = dev;\n\tq->buf_struct_size = sizeof(struct cx231xx_buffer);\n\tq->ops = &cx231xx_video_qops;\n\tq->mem_ops = &vb2_vmalloc_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->min_buffers_needed = 1;\n\tq->lock = &dev->lock;\n\terr = vb2_queue_init(q);\n\tif (err)\n\t\treturn err;\n\tdev->v4l_device.queue = q;\n\n\terr = video_register_device(&dev->v4l_device,\n\t\tVFL_TYPE_VIDEO, -1);\n\tif (err < 0) {\n\t\tdprintk(3, \"%s: can't register mpeg device\\n\", dev->name);\n\t\tv4l2_ctrl_handler_free(&dev->mpeg_ctrl_handler.hdl);\n\t\treturn err;\n\t}\n\n\tdprintk(3, \"%s: registered device video%d [mpeg]\\n\",\n\t       dev->name, dev->v4l_device.num);\n\n\treturn 0;\n}\n\nMODULE_FIRMWARE(CX231xx_FIRM_IMAGE_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}