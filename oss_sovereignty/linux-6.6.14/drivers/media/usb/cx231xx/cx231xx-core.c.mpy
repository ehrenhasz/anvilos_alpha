{
  "module_name": "cx231xx-core.c",
  "hash_id": "9cf4199101c03c159efb63c2232d5183ef69b431ab6bbb0dd79a868fef92f523",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/cx231xx/cx231xx-core.c",
  "human_readable_source": "\n \n\n#include \"cx231xx.h\"\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <media/v4l2-common.h>\n#include <media/tuner.h>\n\n#include \"cx231xx-reg.h\"\n\n \n\nstatic unsigned int core_debug;\nmodule_param(core_debug, int, 0644);\nMODULE_PARM_DESC(core_debug, \"enable debug messages [core]\");\n\n#define cx231xx_coredbg(fmt, arg...) do {\\\n\tif (core_debug) \\\n\t\tprintk(KERN_INFO \"%s %s :\"fmt, \\\n\t\t\t dev->name, __func__ , ##arg); } while (0)\n\nstatic unsigned int reg_debug;\nmodule_param(reg_debug, int, 0644);\nMODULE_PARM_DESC(reg_debug, \"enable debug messages [URB reg]\");\n\nstatic int alt = CX231XX_PINOUT;\nmodule_param(alt, int, 0644);\nMODULE_PARM_DESC(alt, \"alternate setting to use for video endpoint\");\n\n#define cx231xx_isocdbg(fmt, arg...) do {\\\n\tif (core_debug) \\\n\t\tprintk(KERN_INFO \"%s %s :\"fmt, \\\n\t\t\t dev->name, __func__ , ##arg); } while (0)\n\n \n\nLIST_HEAD(cx231xx_devlist);\nstatic DEFINE_MUTEX(cx231xx_devlist_mutex);\n\n \nvoid cx231xx_remove_from_devlist(struct cx231xx *dev)\n{\n\tif (dev == NULL)\n\t\treturn;\n\tif (dev->udev == NULL)\n\t\treturn;\n\n\tif (atomic_read(&dev->devlist_count) > 0) {\n\t\tmutex_lock(&cx231xx_devlist_mutex);\n\t\tlist_del(&dev->devlist);\n\t\tatomic_dec(&dev->devlist_count);\n\t\tmutex_unlock(&cx231xx_devlist_mutex);\n\t}\n};\n\nvoid cx231xx_add_into_devlist(struct cx231xx *dev)\n{\n\tmutex_lock(&cx231xx_devlist_mutex);\n\tlist_add_tail(&dev->devlist, &cx231xx_devlist);\n\tatomic_inc(&dev->devlist_count);\n\tmutex_unlock(&cx231xx_devlist_mutex);\n};\n\nstatic LIST_HEAD(cx231xx_extension_devlist);\n\nint cx231xx_register_extension(struct cx231xx_ops *ops)\n{\n\tstruct cx231xx *dev = NULL;\n\n\tmutex_lock(&cx231xx_devlist_mutex);\n\tlist_add_tail(&ops->next, &cx231xx_extension_devlist);\n\tlist_for_each_entry(dev, &cx231xx_devlist, devlist) {\n\t\tops->init(dev);\n\t\tdev_info(dev->dev, \"%s initialized\\n\", ops->name);\n\t}\n\tmutex_unlock(&cx231xx_devlist_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(cx231xx_register_extension);\n\nvoid cx231xx_unregister_extension(struct cx231xx_ops *ops)\n{\n\tstruct cx231xx *dev = NULL;\n\n\tmutex_lock(&cx231xx_devlist_mutex);\n\tlist_for_each_entry(dev, &cx231xx_devlist, devlist) {\n\t\tops->fini(dev);\n\t\tdev_info(dev->dev, \"%s removed\\n\", ops->name);\n\t}\n\n\tlist_del(&ops->next);\n\tmutex_unlock(&cx231xx_devlist_mutex);\n}\nEXPORT_SYMBOL(cx231xx_unregister_extension);\n\nvoid cx231xx_init_extension(struct cx231xx *dev)\n{\n\tstruct cx231xx_ops *ops = NULL;\n\n\tmutex_lock(&cx231xx_devlist_mutex);\n\tlist_for_each_entry(ops, &cx231xx_extension_devlist, next) {\n\t\tif (ops->init)\n\t\t\tops->init(dev);\n\t}\n\tmutex_unlock(&cx231xx_devlist_mutex);\n}\n\nvoid cx231xx_close_extension(struct cx231xx *dev)\n{\n\tstruct cx231xx_ops *ops = NULL;\n\n\tmutex_lock(&cx231xx_devlist_mutex);\n\tlist_for_each_entry(ops, &cx231xx_extension_devlist, next) {\n\t\tif (ops->fini)\n\t\t\tops->fini(dev);\n\t}\n\tmutex_unlock(&cx231xx_devlist_mutex);\n}\n\n \nint cx231xx_send_usb_command(struct cx231xx_i2c *i2c_bus,\n\t\t\t     struct cx231xx_i2c_xfer_data *req_data)\n{\n\tint status = 0;\n\tstruct cx231xx *dev = i2c_bus->dev;\n\tstruct VENDOR_REQUEST_IN ven_req;\n\n\tu8 saddr_len = 0;\n\tu8 _i2c_period = 0;\n\tu8 _i2c_nostop = 0;\n\tu8 _i2c_reserve = 0;\n\n\tif (dev->state & DEV_DISCONNECTED)\n\t\treturn -ENODEV;\n\n\t \n\t_i2c_period = i2c_bus->i2c_period;\n\t_i2c_nostop = i2c_bus->i2c_nostop;\n\t_i2c_reserve = i2c_bus->i2c_reserve;\n\n\tsaddr_len = req_data->saddr_len;\n\n\t \n\tven_req.wValue = (req_data->dev_addr << 9 | _i2c_period << 4 |\n\t\t\t  saddr_len << 2 | _i2c_nostop << 1 | I2C_SYNC |\n\t\t\t  _i2c_reserve << 6);\n\n\t \n\tif (req_data->direction & I2C_M_RD) {\n\t\t \n\t\tven_req.bRequest = i2c_bus->nr + 4;\n\t} else\n\t\tven_req.bRequest = i2c_bus->nr;\t \n\n\t \n\tswitch (saddr_len) {\n\tcase 0:\n\t\tven_req.wIndex = 0;\t \n\t\tbreak;\n\tcase 1:\n\t\tven_req.wIndex = (req_data->saddr_dat & 0xff);\n\t\tbreak;\n\tcase 2:\n\t\tven_req.wIndex = req_data->saddr_dat;\n\t\tbreak;\n\t}\n\n\t \n\tven_req.wLength = req_data->buf_size;\n\n\t \n\tven_req.bData = 0;\n\n\t \n\tif (req_data->direction) {\n\t\tven_req.direction = USB_DIR_IN;\n\t\tmemset(req_data->p_buffer, 0x00, ven_req.wLength);\n\t} else\n\t\tven_req.direction = USB_DIR_OUT;\n\n\t \n\tven_req.pBuff = req_data->p_buffer;\n\n\n\t \n\tstatus = cx231xx_send_vendor_cmd(dev, &ven_req);\n\tif (status < 0 && !dev->i2c_scan_running) {\n\t\tdev_err(dev->dev, \"%s: failed with status -%d\\n\",\n\t\t\t__func__, status);\n\t}\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(cx231xx_send_usb_command);\n\n \nstatic int __usb_control_msg(struct cx231xx *dev, unsigned int pipe,\n\t__u8 request, __u8 requesttype, __u16 value, __u16 index,\n\tvoid *data, __u16 size, int timeout)\n{\n\tint rc, i;\n\n\tif (reg_debug) {\n\t\tprintk(KERN_DEBUG \"%s: (pipe 0x%08x): %s:  %02x %02x %02x %02x %02x %02x %02x %02x \",\n\t\t\t\tdev->name,\n\t\t\t\tpipe,\n\t\t\t\t(requesttype & USB_DIR_IN) ? \"IN\" : \"OUT\",\n\t\t\t\trequesttype,\n\t\t\t\trequest,\n\t\t\t\tvalue & 0xff, value >> 8,\n\t\t\t\tindex & 0xff, index >> 8,\n\t\t\t\tsize & 0xff, size >> 8);\n\t\tif (!(requesttype & USB_DIR_IN)) {\n\t\t\tprintk(KERN_CONT \">>>\");\n\t\t\tfor (i = 0; i < size; i++)\n\t\t\t\tprintk(KERN_CONT \" %02x\",\n\t\t\t\t       ((unsigned char *)data)[i]);\n\t\t}\n\t}\n\n\t \n\tmutex_lock(&dev->ctrl_urb_lock);\n\tif (!(requesttype & USB_DIR_IN) && size)\n\t\tmemcpy(dev->urb_buf, data, size);\n\trc = usb_control_msg(dev->udev, pipe, request, requesttype, value,\n\t\t\t     index, dev->urb_buf, size, timeout);\n\tif ((requesttype & USB_DIR_IN) && size)\n\t\tmemcpy(data, dev->urb_buf, size);\n\tmutex_unlock(&dev->ctrl_urb_lock);\n\n\tif (reg_debug) {\n\t\tif (unlikely(rc < 0)) {\n\t\t\tprintk(KERN_CONT \"FAILED!\\n\");\n\t\t\treturn rc;\n\t\t}\n\n\t\tif ((requesttype & USB_DIR_IN)) {\n\t\t\tprintk(KERN_CONT \"<<<\");\n\t\t\tfor (i = 0; i < size; i++)\n\t\t\t\tprintk(KERN_CONT \" %02x\",\n\t\t\t\t       ((unsigned char *)data)[i]);\n\t\t}\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\n\treturn rc;\n}\n\n\n \nint cx231xx_read_ctrl_reg(struct cx231xx *dev, u8 req, u16 reg,\n\t\t\t  char *buf, int len)\n{\n\tu8 val = 0;\n\tint ret;\n\tint pipe = usb_rcvctrlpipe(dev->udev, 0);\n\n\tif (dev->state & DEV_DISCONNECTED)\n\t\treturn -ENODEV;\n\n\tif (len > URB_MAX_CTRL_SIZE)\n\t\treturn -EINVAL;\n\n\tswitch (len) {\n\tcase 1:\n\t\tval = ENABLE_ONE_BYTE;\n\t\tbreak;\n\tcase 2:\n\t\tval = ENABLE_TWE_BYTE;\n\t\tbreak;\n\tcase 3:\n\t\tval = ENABLE_THREE_BYTE;\n\t\tbreak;\n\tcase 4:\n\t\tval = ENABLE_FOUR_BYTE;\n\t\tbreak;\n\tdefault:\n\t\tval = 0xFF;\t \n\t}\n\n\tif (val == 0xFF)\n\t\treturn -EINVAL;\n\n\tret = __usb_control_msg(dev, pipe, req,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      val, reg, buf, len, HZ);\n\treturn ret;\n}\n\nint cx231xx_send_vendor_cmd(struct cx231xx *dev,\n\t\t\t\tstruct VENDOR_REQUEST_IN *ven_req)\n{\n\tint ret;\n\tint pipe = 0;\n\tint unsend_size = 0;\n\tu8 *pdata;\n\n\tif (dev->state & DEV_DISCONNECTED)\n\t\treturn -ENODEV;\n\n\tif ((ven_req->wLength > URB_MAX_CTRL_SIZE))\n\t\treturn -EINVAL;\n\n\tif (ven_req->direction)\n\t\tpipe = usb_rcvctrlpipe(dev->udev, 0);\n\telse\n\t\tpipe = usb_sndctrlpipe(dev->udev, 0);\n\n\t \n\tif ((ven_req->wLength > 4) && ((ven_req->bRequest == 0x4) ||\n\t\t\t\t\t(ven_req->bRequest == 0x5) ||\n\t\t\t\t\t(ven_req->bRequest == 0x6) ||\n\n\t\t\t\t\t \n\t\t\t\t\t(ven_req->bRequest == 0x2))) {\n\t\tunsend_size = 0;\n\t\tpdata = ven_req->pBuff;\n\n\n\t\tunsend_size = ven_req->wLength;\n\n\t\t \n\t\tven_req->wValue = ven_req->wValue & 0xFFFB;\n\t\tven_req->wValue = (ven_req->wValue & 0xFFBD) | 0x2;\n\t\tret = __usb_control_msg(dev, pipe, ven_req->bRequest,\n\t\t\tven_req->direction | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tven_req->wValue, ven_req->wIndex, pdata,\n\t\t\t0x0004, HZ);\n\t\tunsend_size = unsend_size - 4;\n\n\t\t \n\t\tven_req->wValue = (ven_req->wValue & 0xFFBD) | 0x42;\n\t\twhile (unsend_size - 4 > 0) {\n\t\t\tpdata = pdata + 4;\n\t\t\tret = __usb_control_msg(dev, pipe,\n\t\t\t\tven_req->bRequest,\n\t\t\t\tven_req->direction | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\tven_req->wValue, ven_req->wIndex, pdata,\n\t\t\t\t0x0004, HZ);\n\t\t\tunsend_size = unsend_size - 4;\n\t\t}\n\n\t\t \n\t\tven_req->wValue = (ven_req->wValue & 0xFFBD) | 0x40;\n\t\tpdata = pdata + 4;\n\t\tret = __usb_control_msg(dev, pipe, ven_req->bRequest,\n\t\t\tven_req->direction | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\tven_req->wValue, ven_req->wIndex, pdata,\n\t\t\tunsend_size, HZ);\n\t} else {\n\t\tret = __usb_control_msg(dev, pipe, ven_req->bRequest,\n\t\t\t\tven_req->direction | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\tven_req->wValue, ven_req->wIndex,\n\t\t\t\tven_req->pBuff, ven_req->wLength, HZ);\n\t}\n\n\treturn ret;\n}\n\n \nint cx231xx_write_ctrl_reg(struct cx231xx *dev, u8 req, u16 reg, char *buf,\n\t\t\t   int len)\n{\n\tu8 val = 0;\n\tint ret;\n\tint pipe = usb_sndctrlpipe(dev->udev, 0);\n\n\tif (dev->state & DEV_DISCONNECTED)\n\t\treturn -ENODEV;\n\n\tif ((len < 1) || (len > URB_MAX_CTRL_SIZE))\n\t\treturn -EINVAL;\n\n\tswitch (len) {\n\tcase 1:\n\t\tval = ENABLE_ONE_BYTE;\n\t\tbreak;\n\tcase 2:\n\t\tval = ENABLE_TWE_BYTE;\n\t\tbreak;\n\tcase 3:\n\t\tval = ENABLE_THREE_BYTE;\n\t\tbreak;\n\tcase 4:\n\t\tval = ENABLE_FOUR_BYTE;\n\t\tbreak;\n\tdefault:\n\t\tval = 0xFF;\t \n\t}\n\n\tif (val == 0xFF)\n\t\treturn -EINVAL;\n\n\tif (reg_debug) {\n\t\tint byte;\n\n\t\tcx231xx_isocdbg(\"(pipe 0x%08x): OUT: %02x %02x %02x %02x %02x %02x %02x %02x >>>\",\n\t\t\tpipe,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\treq, 0, val, reg & 0xff,\n\t\t\treg >> 8, len & 0xff, len >> 8);\n\n\t\tfor (byte = 0; byte < len; byte++)\n\t\t\tcx231xx_isocdbg(\" %02x\", (unsigned char)buf[byte]);\n\t\tcx231xx_isocdbg(\"\\n\");\n\t}\n\n\tret = __usb_control_msg(dev, pipe, req,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      val, reg, buf, len, HZ);\n\n\treturn ret;\n}\n\n \n\nint cx231xx_set_video_alternate(struct cx231xx *dev)\n{\n\tint errCode, prev_alt = dev->video_mode.alt;\n\tunsigned int min_pkt_size = dev->width * 2 + 4;\n\tu32 usb_interface_index = 0;\n\n\t \n\tif (dev->width * 2 * dev->height > 720 * 240 * 2)\n\t\tmin_pkt_size *= 2;\n\n\tif (dev->width > 360) {\n\t\t \n\t\tdev->video_mode.alt = 3;\n\t} else if (dev->width > 180) {\n\t\t \n\t\tdev->video_mode.alt = 2;\n\t} else if (dev->width > 0) {\n\t\t \n\t\tdev->video_mode.alt = 1;\n\t} else {\n\t\t \n\t\tdev->video_mode.alt = 0;\n\t}\n\n\tif (dev->USE_ISO == 0)\n\t\tdev->video_mode.alt = 0;\n\n\tcx231xx_coredbg(\"dev->video_mode.alt= %d\\n\", dev->video_mode.alt);\n\n\t \n\tusb_interface_index =\n\t    dev->current_pcb_config.hs_config_info[0].interface_info.\n\t    video_index + 1;\n\n\tif (dev->video_mode.alt != prev_alt) {\n\t\tcx231xx_coredbg(\"minimum isoc packet size: %u (alt=%d)\\n\",\n\t\t\t\tmin_pkt_size, dev->video_mode.alt);\n\n\t\tif (dev->video_mode.alt_max_pkt_size != NULL)\n\t\t\tdev->video_mode.max_pkt_size =\n\t\t\tdev->video_mode.alt_max_pkt_size[dev->video_mode.alt];\n\t\tcx231xx_coredbg(\"setting alternate %d with wMaxPacketSize=%u\\n\",\n\t\t\t\tdev->video_mode.alt,\n\t\t\t\tdev->video_mode.max_pkt_size);\n\t\terrCode =\n\t\t    usb_set_interface(dev->udev, usb_interface_index,\n\t\t\t\t      dev->video_mode.alt);\n\t\tif (errCode < 0) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"cannot change alt number to %d (error=%i)\\n\",\n\t\t\t\tdev->video_mode.alt, errCode);\n\t\t\treturn errCode;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint cx231xx_set_alt_setting(struct cx231xx *dev, u8 index, u8 alt)\n{\n\tint status = 0;\n\tu32 usb_interface_index = 0;\n\tu32 max_pkt_size = 0;\n\n\tswitch (index) {\n\tcase INDEX_TS1:\n\t\tusb_interface_index =\n\t\t    dev->current_pcb_config.hs_config_info[0].interface_info.\n\t\t    ts1_index + 1;\n\t\tdev->ts1_mode.alt = alt;\n\t\tif (dev->ts1_mode.alt_max_pkt_size != NULL)\n\t\t\tmax_pkt_size = dev->ts1_mode.max_pkt_size =\n\t\t\t    dev->ts1_mode.alt_max_pkt_size[dev->ts1_mode.alt];\n\t\tbreak;\n\tcase INDEX_TS2:\n\t\tusb_interface_index =\n\t\t    dev->current_pcb_config.hs_config_info[0].interface_info.\n\t\t    ts2_index + 1;\n\t\tbreak;\n\tcase INDEX_AUDIO:\n\t\tusb_interface_index =\n\t\t    dev->current_pcb_config.hs_config_info[0].interface_info.\n\t\t    audio_index + 1;\n\t\tdev->adev.alt = alt;\n\t\tif (dev->adev.alt_max_pkt_size != NULL)\n\t\t\tmax_pkt_size = dev->adev.max_pkt_size =\n\t\t\t    dev->adev.alt_max_pkt_size[dev->adev.alt];\n\t\tbreak;\n\tcase INDEX_VIDEO:\n\t\tusb_interface_index =\n\t\t    dev->current_pcb_config.hs_config_info[0].interface_info.\n\t\t    video_index + 1;\n\t\tdev->video_mode.alt = alt;\n\t\tif (dev->video_mode.alt_max_pkt_size != NULL)\n\t\t\tmax_pkt_size = dev->video_mode.max_pkt_size =\n\t\t\t    dev->video_mode.alt_max_pkt_size[dev->video_mode.\n\t\t\t\t\t\t\t     alt];\n\t\tbreak;\n\tcase INDEX_VANC:\n\t\tif (dev->board.no_alt_vanc)\n\t\t\treturn 0;\n\t\tusb_interface_index =\n\t\t    dev->current_pcb_config.hs_config_info[0].interface_info.\n\t\t    vanc_index + 1;\n\t\tdev->vbi_mode.alt = alt;\n\t\tif (dev->vbi_mode.alt_max_pkt_size != NULL)\n\t\t\tmax_pkt_size = dev->vbi_mode.max_pkt_size =\n\t\t\t    dev->vbi_mode.alt_max_pkt_size[dev->vbi_mode.alt];\n\t\tbreak;\n\tcase INDEX_HANC:\n\t\tusb_interface_index =\n\t\t    dev->current_pcb_config.hs_config_info[0].interface_info.\n\t\t    hanc_index + 1;\n\t\tdev->sliced_cc_mode.alt = alt;\n\t\tif (dev->sliced_cc_mode.alt_max_pkt_size != NULL)\n\t\t\tmax_pkt_size = dev->sliced_cc_mode.max_pkt_size =\n\t\t\t    dev->sliced_cc_mode.alt_max_pkt_size[dev->\n\t\t\t\t\t\t\t\t sliced_cc_mode.\n\t\t\t\t\t\t\t\t alt];\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (alt > 0 && max_pkt_size == 0) {\n\t\tdev_err(dev->dev,\n\t\t\t\"can't change interface %d alt no. to %d: Max. Pkt size = 0\\n\",\n\t\t\tusb_interface_index, alt);\n\t\t \n\t\tif (dev->board.no_alt_vanc)\n\t\t\treturn -1;\n\t}\n\n\tcx231xx_coredbg(\"setting alternate %d with wMaxPacketSize=%u,Interface = %d\\n\",\n\t\t\talt, max_pkt_size,\n\t\t\tusb_interface_index);\n\n\tif (usb_interface_index > 0) {\n\t\tstatus = usb_set_interface(dev->udev, usb_interface_index, alt);\n\t\tif (status < 0) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"can't change interface %d alt no. to %d (err=%i)\\n\",\n\t\t\t\tusb_interface_index, alt, status);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(cx231xx_set_alt_setting);\n\nint cx231xx_gpio_set(struct cx231xx *dev, struct cx231xx_reg_seq *gpio)\n{\n\tint rc = 0;\n\n\tif (!gpio)\n\t\treturn rc;\n\n\t \n\twhile (gpio->sleep >= 0) {\n\t\trc = cx231xx_set_gpio_value(dev, gpio->bit, gpio->val);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif (gpio->sleep > 0)\n\t\t\tmsleep(gpio->sleep);\n\n\t\tgpio++;\n\t}\n\treturn rc;\n}\n\nint cx231xx_demod_reset(struct cx231xx *dev)\n{\n\n\tu8 status = 0;\n\tu8 value[4] = { 0, 0, 0, 0 };\n\n\tstatus = cx231xx_read_ctrl_reg(dev, VRT_GET_REGISTER, PWR_CTL_EN,\n\t\t\t\t value, 4);\n\n\tcx231xx_coredbg(\"reg0x%x=0x%x 0x%x 0x%x 0x%x\\n\", PWR_CTL_EN,\n\t\t\tvalue[0], value[1], value[2], value[3]);\n\n\tcx231xx_coredbg(\"Enter cx231xx_demod_reset()\\n\");\n\n\tvalue[1] = (u8) 0x3;\n\tstatus = cx231xx_write_ctrl_reg(dev, VRT_SET_REGISTER,\n\t\t\t\t\tPWR_CTL_EN, value, 4);\n\tmsleep(10);\n\n\tvalue[1] = (u8) 0x0;\n\tstatus = cx231xx_write_ctrl_reg(dev, VRT_SET_REGISTER,\n\t\t\t\t\tPWR_CTL_EN, value, 4);\n\tmsleep(10);\n\n\tvalue[1] = (u8) 0x3;\n\tstatus = cx231xx_write_ctrl_reg(dev, VRT_SET_REGISTER,\n\t\t\t\t\tPWR_CTL_EN, value, 4);\n\tmsleep(10);\n\n\tstatus = cx231xx_read_ctrl_reg(dev, VRT_GET_REGISTER, PWR_CTL_EN,\n\t\t\t\t value, 4);\n\n\tcx231xx_coredbg(\"reg0x%x=0x%x 0x%x 0x%x 0x%x\\n\", PWR_CTL_EN,\n\t\t\tvalue[0], value[1], value[2], value[3]);\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(cx231xx_demod_reset);\nint is_fw_load(struct cx231xx *dev)\n{\n\treturn cx231xx_check_fw(dev);\n}\nEXPORT_SYMBOL_GPL(is_fw_load);\n\nint cx231xx_set_mode(struct cx231xx *dev, enum cx231xx_mode set_mode)\n{\n\tint errCode = 0;\n\n\tif (dev->mode == set_mode)\n\t\treturn 0;\n\n\tif (set_mode == CX231XX_SUSPEND) {\n\t\t \n\t\tdev->mode = set_mode;\n\t}\n\n\t \n\tif (dev->mode != CX231XX_SUSPEND)\n\t\treturn -EINVAL;\n\n\tdev->mode = set_mode;\n\n\tif (dev->mode == CX231XX_DIGITAL_MODE)  {\n\t \n\t\tswitch (dev->model) {\n\t\tcase CX231XX_BOARD_CNXT_CARRAERA:\n\t\tcase CX231XX_BOARD_CNXT_RDE_250:\n\t\tcase CX231XX_BOARD_CNXT_SHELBY:\n\t\tcase CX231XX_BOARD_CNXT_RDU_250:\n\t\terrCode = cx231xx_set_agc_analog_digital_mux_select(dev, 0);\n\t\t\tbreak;\n\t\tcase CX231XX_BOARD_CNXT_RDE_253S:\n\t\tcase CX231XX_BOARD_CNXT_RDU_253S:\n\t\tcase CX231XX_BOARD_PV_PLAYTV_USB_HYBRID:\n\t\t\terrCode = cx231xx_set_agc_analog_digital_mux_select(dev, 1);\n\t\t\tbreak;\n\t\tcase CX231XX_BOARD_HAUPPAUGE_EXETER:\n\t\tcase CX231XX_BOARD_HAUPPAUGE_930C_HD_1113xx:\n\t\t\terrCode = cx231xx_set_power_mode(dev,\n\t\t\t\t\t\tPOLARIS_AVMODE_DIGITAL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else  {\n\t \n\t\tswitch (dev->model) {\n\t\tcase CX231XX_BOARD_CNXT_CARRAERA:\n\t\tcase CX231XX_BOARD_CNXT_RDE_250:\n\t\tcase CX231XX_BOARD_CNXT_SHELBY:\n\t\tcase CX231XX_BOARD_CNXT_RDU_250:\n\t\terrCode = cx231xx_set_agc_analog_digital_mux_select(dev, 1);\n\t\t\tbreak;\n\t\tcase CX231XX_BOARD_CNXT_RDE_253S:\n\t\tcase CX231XX_BOARD_CNXT_RDU_253S:\n\t\tcase CX231XX_BOARD_HAUPPAUGE_EXETER:\n\t\tcase CX231XX_BOARD_HAUPPAUGE_930C_HD_1113xx:\n\t\tcase CX231XX_BOARD_PV_PLAYTV_USB_HYBRID:\n\t\tcase CX231XX_BOARD_HAUPPAUGE_USB2_FM_PAL:\n\t\tcase CX231XX_BOARD_HAUPPAUGE_USB2_FM_NTSC:\n\t\t\terrCode = cx231xx_set_agc_analog_digital_mux_select(dev, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (errCode < 0) {\n\t\tdev_err(dev->dev, \"Failed to set devmode to %s: error: %i\",\n\t\t\tdev->mode == CX231XX_DIGITAL_MODE ? \"digital\" : \"analog\",\n\t\t\terrCode);\n\t\treturn errCode;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cx231xx_set_mode);\n\nint cx231xx_ep5_bulkout(struct cx231xx *dev, u8 *firmware, u16 size)\n{\n\tint errCode = 0;\n\tint actlen = -1;\n\tint ret = -ENOMEM;\n\tu32 *buffer;\n\n\tbuffer = kzalloc(4096, GFP_KERNEL);\n\tif (buffer == NULL)\n\t\treturn -ENOMEM;\n\tmemcpy(&buffer[0], firmware, 4096);\n\n\tret = usb_bulk_msg(dev->udev, usb_sndbulkpipe(dev->udev, 5),\n\t\t\tbuffer, 4096, &actlen, 2000);\n\n\tif (ret)\n\t\tdev_err(dev->dev,\n\t\t\t\"bulk message failed: %d (%d/%d)\", ret,\n\t\t\tsize, actlen);\n\telse {\n\t\terrCode = actlen != size ? -1 : 0;\n\t}\n\tkfree(buffer);\n\treturn errCode;\n}\n\n \n\n \nstatic void cx231xx_isoc_irq_callback(struct urb *urb)\n{\n\tstruct cx231xx_dmaqueue *dma_q = urb->context;\n\tstruct cx231xx_video_mode *vmode =\n\t    container_of(dma_q, struct cx231xx_video_mode, vidq);\n\tstruct cx231xx *dev = container_of(vmode, struct cx231xx, video_mode);\n\tunsigned long flags;\n\tint i;\n\n\tswitch (urb->status) {\n\tcase 0:\t\t \n\tcase -ETIMEDOUT:\t \n\t\tbreak;\n\tcase -ECONNRESET:\t \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:\t\t \n\t\tcx231xx_isocdbg(\"urb completion error %d.\\n\", urb->status);\n\t\tbreak;\n\t}\n\n\t \n\tspin_lock_irqsave(&dev->video_mode.slock, flags);\n\tdev->video_mode.isoc_ctl.isoc_copy(dev, urb);\n\tspin_unlock_irqrestore(&dev->video_mode.slock, flags);\n\n\t \n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\turb->iso_frame_desc[i].status = 0;\n\t\turb->iso_frame_desc[i].actual_length = 0;\n\t}\n\n\turb->status = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (urb->status) {\n\t\tcx231xx_isocdbg(\"urb resubmit failed (error=%i)\\n\",\n\t\t\t\turb->status);\n\t}\n}\n \n\n \nstatic void cx231xx_bulk_irq_callback(struct urb *urb)\n{\n\tstruct cx231xx_dmaqueue *dma_q = urb->context;\n\tstruct cx231xx_video_mode *vmode =\n\t    container_of(dma_q, struct cx231xx_video_mode, vidq);\n\tstruct cx231xx *dev = container_of(vmode, struct cx231xx, video_mode);\n\tunsigned long flags;\n\n\tswitch (urb->status) {\n\tcase 0:\t\t \n\tcase -ETIMEDOUT:\t \n\t\tbreak;\n\tcase -ECONNRESET:\t \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tcase -EPIPE:\t\t \n\t\tcx231xx_isocdbg(\"urb completion error - device is stalled.\\n\");\n\t\treturn;\n\tdefault:\t\t \n\t\tcx231xx_isocdbg(\"urb completion error %d.\\n\", urb->status);\n\t\tbreak;\n\t}\n\n\t \n\tspin_lock_irqsave(&dev->video_mode.slock, flags);\n\tdev->video_mode.bulk_ctl.bulk_copy(dev, urb);\n\tspin_unlock_irqrestore(&dev->video_mode.slock, flags);\n\n\t \n\turb->status = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (urb->status) {\n\t\tcx231xx_isocdbg(\"urb resubmit failed (error=%i)\\n\",\n\t\t\t\turb->status);\n\t}\n}\n \nvoid cx231xx_uninit_isoc(struct cx231xx *dev)\n{\n\tstruct cx231xx_dmaqueue *dma_q = &dev->video_mode.vidq;\n\tstruct urb *urb;\n\tint i;\n\tbool broken_pipe = false;\n\n\tcx231xx_isocdbg(\"cx231xx: called cx231xx_uninit_isoc\\n\");\n\n\tdev->video_mode.isoc_ctl.nfields = -1;\n\tfor (i = 0; i < dev->video_mode.isoc_ctl.num_bufs; i++) {\n\t\turb = dev->video_mode.isoc_ctl.urb[i];\n\t\tif (urb) {\n\t\t\tif (!irqs_disabled())\n\t\t\t\tusb_kill_urb(urb);\n\t\t\telse\n\t\t\t\tusb_unlink_urb(urb);\n\n\t\t\tif (dev->video_mode.isoc_ctl.transfer_buffer[i]) {\n\t\t\t\tusb_free_coherent(dev->udev,\n\t\t\t\t\t\t  urb->transfer_buffer_length,\n\t\t\t\t\t\t  dev->video_mode.isoc_ctl.\n\t\t\t\t\t\t  transfer_buffer[i],\n\t\t\t\t\t\t  urb->transfer_dma);\n\t\t\t}\n\t\t\tif (urb->status == -EPIPE) {\n\t\t\t\tbroken_pipe = true;\n\t\t\t}\n\t\t\tusb_free_urb(urb);\n\t\t\tdev->video_mode.isoc_ctl.urb[i] = NULL;\n\t\t}\n\t\tdev->video_mode.isoc_ctl.transfer_buffer[i] = NULL;\n\t}\n\n\tif (broken_pipe) {\n\t\tcx231xx_isocdbg(\"Reset endpoint to recover broken pipe.\");\n\t\tusb_reset_endpoint(dev->udev, dev->video_mode.end_point_addr);\n\t}\n\tkfree(dev->video_mode.isoc_ctl.urb);\n\tkfree(dev->video_mode.isoc_ctl.transfer_buffer);\n\tkfree(dma_q->p_left_data);\n\n\tdev->video_mode.isoc_ctl.urb = NULL;\n\tdev->video_mode.isoc_ctl.transfer_buffer = NULL;\n\tdev->video_mode.isoc_ctl.num_bufs = 0;\n\tdma_q->p_left_data = NULL;\n\n\tif (dev->mode_tv == 0)\n\t\tcx231xx_capture_start(dev, 0, Raw_Video);\n\telse\n\t\tcx231xx_capture_start(dev, 0, TS1_serial_mode);\n\n\n}\nEXPORT_SYMBOL_GPL(cx231xx_uninit_isoc);\n\n \nvoid cx231xx_uninit_bulk(struct cx231xx *dev)\n{\n\tstruct cx231xx_dmaqueue *dma_q = &dev->video_mode.vidq;\n\tstruct urb *urb;\n\tint i;\n\tbool broken_pipe = false;\n\n\tcx231xx_isocdbg(\"cx231xx: called cx231xx_uninit_bulk\\n\");\n\n\tdev->video_mode.bulk_ctl.nfields = -1;\n\tfor (i = 0; i < dev->video_mode.bulk_ctl.num_bufs; i++) {\n\t\turb = dev->video_mode.bulk_ctl.urb[i];\n\t\tif (urb) {\n\t\t\tif (!irqs_disabled())\n\t\t\t\tusb_kill_urb(urb);\n\t\t\telse\n\t\t\t\tusb_unlink_urb(urb);\n\n\t\t\tif (dev->video_mode.bulk_ctl.transfer_buffer[i]) {\n\t\t\t\tusb_free_coherent(dev->udev,\n\t\t\t\t\t\turb->transfer_buffer_length,\n\t\t\t\t\t\tdev->video_mode.bulk_ctl.\n\t\t\t\t\t\ttransfer_buffer[i],\n\t\t\t\t\t\turb->transfer_dma);\n\t\t\t}\n\t\t\tif (urb->status == -EPIPE) {\n\t\t\t\tbroken_pipe = true;\n\t\t\t}\n\t\t\tusb_free_urb(urb);\n\t\t\tdev->video_mode.bulk_ctl.urb[i] = NULL;\n\t\t}\n\t\tdev->video_mode.bulk_ctl.transfer_buffer[i] = NULL;\n\t}\n\n\tif (broken_pipe) {\n\t\tcx231xx_isocdbg(\"Reset endpoint to recover broken pipe.\");\n\t\tusb_reset_endpoint(dev->udev, dev->video_mode.end_point_addr);\n\t}\n\tkfree(dev->video_mode.bulk_ctl.urb);\n\tkfree(dev->video_mode.bulk_ctl.transfer_buffer);\n\tkfree(dma_q->p_left_data);\n\n\tdev->video_mode.bulk_ctl.urb = NULL;\n\tdev->video_mode.bulk_ctl.transfer_buffer = NULL;\n\tdev->video_mode.bulk_ctl.num_bufs = 0;\n\tdma_q->p_left_data = NULL;\n\n\tif (dev->mode_tv == 0)\n\t\tcx231xx_capture_start(dev, 0, Raw_Video);\n\telse\n\t\tcx231xx_capture_start(dev, 0, TS1_serial_mode);\n\n\n}\nEXPORT_SYMBOL_GPL(cx231xx_uninit_bulk);\n\n \nint cx231xx_init_isoc(struct cx231xx *dev, int max_packets,\n\t\t      int num_bufs, int max_pkt_size,\n\t\t      int (*isoc_copy) (struct cx231xx *dev, struct urb *urb))\n{\n\tstruct cx231xx_dmaqueue *dma_q = &dev->video_mode.vidq;\n\tint i;\n\tint sb_size, pipe;\n\tstruct urb *urb;\n\tint j, k;\n\tint rc;\n\n\t \n\tcx231xx_uninit_isoc(dev);\n\n\tdma_q->p_left_data = kzalloc(4096, GFP_KERNEL);\n\tif (dma_q->p_left_data == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->video_mode.isoc_ctl.isoc_copy = isoc_copy;\n\tdev->video_mode.isoc_ctl.num_bufs = num_bufs;\n\tdma_q->pos = 0;\n\tdma_q->is_partial_line = 0;\n\tdma_q->last_sav = 0;\n\tdma_q->current_field = -1;\n\tdma_q->field1_done = 0;\n\tdma_q->lines_per_field = dev->height / 2;\n\tdma_q->bytes_left_in_line = dev->width << 1;\n\tdma_q->lines_completed = 0;\n\tdma_q->mpeg_buffer_done = 0;\n\tdma_q->left_data_count = 0;\n\tdma_q->mpeg_buffer_completed = 0;\n\tdma_q->add_ps_package_head = CX231XX_NEED_ADD_PS_PACKAGE_HEAD;\n\tdma_q->ps_head[0] = 0x00;\n\tdma_q->ps_head[1] = 0x00;\n\tdma_q->ps_head[2] = 0x01;\n\tdma_q->ps_head[3] = 0xBA;\n\tfor (i = 0; i < 8; i++)\n\t\tdma_q->partial_buf[i] = 0;\n\n\tdev->video_mode.isoc_ctl.urb =\n\t    kcalloc(num_bufs, sizeof(void *), GFP_KERNEL);\n\tif (!dev->video_mode.isoc_ctl.urb) {\n\t\tdev_err(dev->dev,\n\t\t\t\"cannot alloc memory for usb buffers\\n\");\n\t\tkfree(dma_q->p_left_data);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev->video_mode.isoc_ctl.transfer_buffer =\n\t    kcalloc(num_bufs, sizeof(void *), GFP_KERNEL);\n\tif (!dev->video_mode.isoc_ctl.transfer_buffer) {\n\t\tdev_err(dev->dev,\n\t\t\t\"cannot allocate memory for usbtransfer\\n\");\n\t\tkfree(dev->video_mode.isoc_ctl.urb);\n\t\tkfree(dma_q->p_left_data);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev->video_mode.isoc_ctl.max_pkt_size = max_pkt_size;\n\tdev->video_mode.isoc_ctl.buf = NULL;\n\n\tsb_size = max_packets * dev->video_mode.isoc_ctl.max_pkt_size;\n\n\tif (dev->mode_tv == 1)\n\t\tdev->video_mode.end_point_addr = 0x81;\n\telse\n\t\tdev->video_mode.end_point_addr = 0x84;\n\n\n\t \n\tfor (i = 0; i < dev->video_mode.isoc_ctl.num_bufs; i++) {\n\t\turb = usb_alloc_urb(max_packets, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\tcx231xx_uninit_isoc(dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdev->video_mode.isoc_ctl.urb[i] = urb;\n\n\t\tdev->video_mode.isoc_ctl.transfer_buffer[i] =\n\t\t    usb_alloc_coherent(dev->udev, sb_size, GFP_KERNEL,\n\t\t\t\t       &urb->transfer_dma);\n\t\tif (!dev->video_mode.isoc_ctl.transfer_buffer[i]) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"unable to allocate %i bytes for transfer buffer %i\\n\",\n\t\t\t\tsb_size, i);\n\t\t\tcx231xx_uninit_isoc(dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(dev->video_mode.isoc_ctl.transfer_buffer[i], 0, sb_size);\n\n\t\tpipe =\n\t\t    usb_rcvisocpipe(dev->udev, dev->video_mode.end_point_addr);\n\n\t\tusb_fill_int_urb(urb, dev->udev, pipe,\n\t\t\t\t dev->video_mode.isoc_ctl.transfer_buffer[i],\n\t\t\t\t sb_size, cx231xx_isoc_irq_callback, dma_q, 1);\n\n\t\turb->number_of_packets = max_packets;\n\t\turb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\n\n\t\tk = 0;\n\t\tfor (j = 0; j < max_packets; j++) {\n\t\t\turb->iso_frame_desc[j].offset = k;\n\t\t\turb->iso_frame_desc[j].length =\n\t\t\t    dev->video_mode.isoc_ctl.max_pkt_size;\n\t\t\tk += dev->video_mode.isoc_ctl.max_pkt_size;\n\t\t}\n\t}\n\n\tinit_waitqueue_head(&dma_q->wq);\n\n\t \n\tfor (i = 0; i < dev->video_mode.isoc_ctl.num_bufs; i++) {\n\t\trc = usb_submit_urb(dev->video_mode.isoc_ctl.urb[i],\n\t\t\t\t    GFP_ATOMIC);\n\t\tif (rc) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"submit of urb %i failed (error=%i)\\n\", i,\n\t\t\t\trc);\n\t\t\tcx231xx_uninit_isoc(dev);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (dev->mode_tv == 0)\n\t\tcx231xx_capture_start(dev, 1, Raw_Video);\n\telse\n\t\tcx231xx_capture_start(dev, 1, TS1_serial_mode);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cx231xx_init_isoc);\n\n \nint cx231xx_init_bulk(struct cx231xx *dev, int max_packets,\n\t\t      int num_bufs, int max_pkt_size,\n\t\t      int (*bulk_copy) (struct cx231xx *dev, struct urb *urb))\n{\n\tstruct cx231xx_dmaqueue *dma_q = &dev->video_mode.vidq;\n\tint i;\n\tint sb_size, pipe;\n\tstruct urb *urb;\n\tint rc;\n\n\tdev->video_input = dev->video_input > 2 ? 2 : dev->video_input;\n\n\tcx231xx_coredbg(\"Setting Video mux to %d\\n\", dev->video_input);\n\n\tvideo_mux(dev, dev->video_input);\n\n\t \n\tcx231xx_uninit_bulk(dev);\n\n\tdev->video_mode.bulk_ctl.bulk_copy = bulk_copy;\n\tdev->video_mode.bulk_ctl.num_bufs = num_bufs;\n\tdma_q->pos = 0;\n\tdma_q->is_partial_line = 0;\n\tdma_q->last_sav = 0;\n\tdma_q->current_field = -1;\n\tdma_q->field1_done = 0;\n\tdma_q->lines_per_field = dev->height / 2;\n\tdma_q->bytes_left_in_line = dev->width << 1;\n\tdma_q->lines_completed = 0;\n\tdma_q->mpeg_buffer_done = 0;\n\tdma_q->left_data_count = 0;\n\tdma_q->mpeg_buffer_completed = 0;\n\tdma_q->ps_head[0] = 0x00;\n\tdma_q->ps_head[1] = 0x00;\n\tdma_q->ps_head[2] = 0x01;\n\tdma_q->ps_head[3] = 0xBA;\n\tfor (i = 0; i < 8; i++)\n\t\tdma_q->partial_buf[i] = 0;\n\n\tdev->video_mode.bulk_ctl.urb =\n\t    kcalloc(num_bufs, sizeof(void *), GFP_KERNEL);\n\tif (!dev->video_mode.bulk_ctl.urb) {\n\t\tdev_err(dev->dev,\n\t\t\t\"cannot alloc memory for usb buffers\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdev->video_mode.bulk_ctl.transfer_buffer =\n\t    kcalloc(num_bufs, sizeof(void *), GFP_KERNEL);\n\tif (!dev->video_mode.bulk_ctl.transfer_buffer) {\n\t\tdev_err(dev->dev,\n\t\t\t\"cannot allocate memory for usbtransfer\\n\");\n\t\tkfree(dev->video_mode.bulk_ctl.urb);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev->video_mode.bulk_ctl.max_pkt_size = max_pkt_size;\n\tdev->video_mode.bulk_ctl.buf = NULL;\n\n\tsb_size = max_packets * dev->video_mode.bulk_ctl.max_pkt_size;\n\n\tif (dev->mode_tv == 1)\n\t\tdev->video_mode.end_point_addr = 0x81;\n\telse\n\t\tdev->video_mode.end_point_addr = 0x84;\n\n\n\t \n\tfor (i = 0; i < dev->video_mode.bulk_ctl.num_bufs; i++) {\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\tcx231xx_uninit_bulk(dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdev->video_mode.bulk_ctl.urb[i] = urb;\n\t\turb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\n\t\tdev->video_mode.bulk_ctl.transfer_buffer[i] =\n\t\t    usb_alloc_coherent(dev->udev, sb_size, GFP_KERNEL,\n\t\t\t\t     &urb->transfer_dma);\n\t\tif (!dev->video_mode.bulk_ctl.transfer_buffer[i]) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"unable to allocate %i bytes for transfer buffer %i\\n\",\n\t\t\t\tsb_size, i);\n\t\t\tcx231xx_uninit_bulk(dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(dev->video_mode.bulk_ctl.transfer_buffer[i], 0, sb_size);\n\n\t\tpipe = usb_rcvbulkpipe(dev->udev,\n\t\t\t\t dev->video_mode.end_point_addr);\n\t\tusb_fill_bulk_urb(urb, dev->udev, pipe,\n\t\t\t\t  dev->video_mode.bulk_ctl.transfer_buffer[i],\n\t\t\t\t  sb_size, cx231xx_bulk_irq_callback, dma_q);\n\t}\n\n\t \n\trc = usb_clear_halt(dev->udev, dev->video_mode.bulk_ctl.urb[0]->pipe);\n\tif (rc < 0) {\n\t\tdev_err(dev->dev,\n\t\t\t\"failed to clear USB bulk endpoint stall/halt condition (error=%i)\\n\",\n\t\t\trc);\n\t\tcx231xx_uninit_bulk(dev);\n\t\treturn rc;\n\t}\n\n\tinit_waitqueue_head(&dma_q->wq);\n\n\t \n\tfor (i = 0; i < dev->video_mode.bulk_ctl.num_bufs; i++) {\n\t\trc = usb_submit_urb(dev->video_mode.bulk_ctl.urb[i],\n\t\t\t\t    GFP_ATOMIC);\n\t\tif (rc) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"submit of urb %i failed (error=%i)\\n\", i, rc);\n\t\t\tcx231xx_uninit_bulk(dev);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (dev->mode_tv == 0)\n\t\tcx231xx_capture_start(dev, 1, Raw_Video);\n\telse\n\t\tcx231xx_capture_start(dev, 1, TS1_serial_mode);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cx231xx_init_bulk);\nvoid cx231xx_stop_TS1(struct cx231xx *dev)\n{\n\tu8 val[4] = { 0, 0, 0, 0 };\n\n\tval[0] = 0x00;\n\tval[1] = 0x03;\n\tval[2] = 0x00;\n\tval[3] = 0x00;\n\tcx231xx_write_ctrl_reg(dev, VRT_SET_REGISTER,\n\t\t\tTS_MODE_REG, val, 4);\n\n\tval[0] = 0x00;\n\tval[1] = 0x70;\n\tval[2] = 0x04;\n\tval[3] = 0x00;\n\tcx231xx_write_ctrl_reg(dev, VRT_SET_REGISTER,\n\t\t\tTS1_CFG_REG, val, 4);\n}\n \nvoid cx231xx_start_TS1(struct cx231xx *dev)\n{\n\tu8 val[4] = { 0, 0, 0, 0 };\n\n\tval[0] = 0x03;\n\tval[1] = 0x03;\n\tval[2] = 0x00;\n\tval[3] = 0x00;\n\tcx231xx_write_ctrl_reg(dev, VRT_SET_REGISTER,\n\t\t\tTS_MODE_REG, val, 4);\n\n\tval[0] = 0x04;\n\tval[1] = 0xA3;\n\tval[2] = 0x3B;\n\tval[3] = 0x00;\n\tcx231xx_write_ctrl_reg(dev, VRT_SET_REGISTER,\n\t\t\tTS1_CFG_REG, val, 4);\n}\n \n \nint cx231xx_dev_init(struct cx231xx *dev)\n{\n\tint errCode = 0;\n\n\t \n\n\t \n\tdev->i2c_bus[0].nr = 0;\n\tdev->i2c_bus[0].dev = dev;\n\tdev->i2c_bus[0].i2c_period = I2C_SPEED_100K;\t \n\tdev->i2c_bus[0].i2c_nostop = 0;\n\tdev->i2c_bus[0].i2c_reserve = 0;\n\tdev->i2c_bus[0].i2c_rc = -ENODEV;\n\n\t \n\tdev->i2c_bus[1].nr = 1;\n\tdev->i2c_bus[1].dev = dev;\n\tdev->i2c_bus[1].i2c_period = I2C_SPEED_100K;\t \n\tdev->i2c_bus[1].i2c_nostop = 0;\n\tdev->i2c_bus[1].i2c_reserve = 0;\n\tdev->i2c_bus[1].i2c_rc = -ENODEV;\n\n\t \n\tdev->i2c_bus[2].nr = 2;\n\tdev->i2c_bus[2].dev = dev;\n\tdev->i2c_bus[2].i2c_period = I2C_SPEED_100K;\t \n\tdev->i2c_bus[2].i2c_nostop = 0;\n\tdev->i2c_bus[2].i2c_reserve = 0;\n\tdev->i2c_bus[2].i2c_rc = -ENODEV;\n\n\t \n\terrCode = cx231xx_i2c_register(&dev->i2c_bus[0]);\n\tif (errCode < 0)\n\t\treturn errCode;\n\terrCode = cx231xx_i2c_register(&dev->i2c_bus[1]);\n\tif (errCode < 0)\n\t\treturn errCode;\n\terrCode = cx231xx_i2c_register(&dev->i2c_bus[2]);\n\tif (errCode < 0)\n\t\treturn errCode;\n\n\terrCode = cx231xx_i2c_mux_create(dev);\n\tif (errCode < 0) {\n\t\tdev_err(dev->dev,\n\t\t\t\"%s: Failed to create I2C mux\\n\", __func__);\n\t\treturn errCode;\n\t}\n\terrCode = cx231xx_i2c_mux_register(dev, 0);\n\tif (errCode < 0)\n\t\treturn errCode;\n\n\terrCode = cx231xx_i2c_mux_register(dev, 1);\n\tif (errCode < 0)\n\t\treturn errCode;\n\n\t \n\tcx231xx_do_i2c_scan(dev, I2C_0);\n\tcx231xx_do_i2c_scan(dev, I2C_1_MUX_1);\n\tcx231xx_do_i2c_scan(dev, I2C_2);\n\tcx231xx_do_i2c_scan(dev, I2C_1_MUX_3);\n\n\t \n\t \n\tif (dev->board.external_av) {\n\t\terrCode = cx231xx_set_power_mode(dev,\n\t\t\t\t POLARIS_AVMODE_ENXTERNAL_AV);\n\t\tif (errCode < 0) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"%s: Failed to set Power - errCode [%d]!\\n\",\n\t\t\t\t__func__, errCode);\n\t\t\treturn errCode;\n\t\t}\n\t} else {\n\t\terrCode = cx231xx_set_power_mode(dev,\n\t\t\t\t POLARIS_AVMODE_ANALOGT_TV);\n\t\tif (errCode < 0) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"%s: Failed to set Power - errCode [%d]!\\n\",\n\t\t\t\t__func__, errCode);\n\t\t\treturn errCode;\n\t\t}\n\t}\n\n\t \n\tif ((dev->board.tuner_type == TUNER_XC5000) ||\n\t    (dev->board.tuner_type == TUNER_XC2028))\n\t\t\tcx231xx_gpio_set(dev, dev->board.tuner_gpio);\n\n\t \n\terrCode = cx231xx_afe_init_super_block(dev, 0x23c);\n\tif (errCode < 0) {\n\t\tdev_err(dev->dev,\n\t\t\t\"%s: cx231xx_afe init super block - errCode [%d]!\\n\",\n\t\t\t__func__, errCode);\n\t\treturn errCode;\n\t}\n\terrCode = cx231xx_afe_init_channels(dev);\n\tif (errCode < 0) {\n\t\tdev_err(dev->dev,\n\t\t\t\"%s: cx231xx_afe init channels - errCode [%d]!\\n\",\n\t\t\t__func__, errCode);\n\t\treturn errCode;\n\t}\n\n\t \n\terrCode = cx231xx_dif_set_standard(dev, DIF_USE_BASEBAND);\n\tif (errCode < 0) {\n\t\tdev_err(dev->dev,\n\t\t\t\"%s: cx231xx_dif set to By pass mode - errCode [%d]!\\n\",\n\t\t\t__func__, errCode);\n\t\treturn errCode;\n\t}\n\n\t \n\terrCode = cx231xx_i2s_blk_initialize(dev);\n\tif (errCode < 0) {\n\t\tdev_err(dev->dev,\n\t\t\t\"%s: cx231xx_i2s block initialize - errCode [%d]!\\n\",\n\t\t\t__func__, errCode);\n\t\treturn errCode;\n\t}\n\n\t \n\terrCode = cx231xx_init_ctrl_pin_status(dev);\n\tif (errCode < 0) {\n\t\tdev_err(dev->dev,\n\t\t\t\"%s: cx231xx_init ctrl pins - errCode [%d]!\\n\",\n\t\t\t__func__, errCode);\n\t\treturn errCode;\n\t}\n\n\t \n\tswitch (dev->model) {\n\tcase CX231XX_BOARD_CNXT_CARRAERA:\n\tcase CX231XX_BOARD_CNXT_RDE_250:\n\tcase CX231XX_BOARD_CNXT_SHELBY:\n\tcase CX231XX_BOARD_CNXT_RDU_250:\n\terrCode = cx231xx_set_agc_analog_digital_mux_select(dev, 1);\n\t\tbreak;\n\tcase CX231XX_BOARD_CNXT_RDE_253S:\n\tcase CX231XX_BOARD_CNXT_RDU_253S:\n\tcase CX231XX_BOARD_HAUPPAUGE_EXETER:\n\tcase CX231XX_BOARD_HAUPPAUGE_930C_HD_1113xx:\n\tcase CX231XX_BOARD_PV_PLAYTV_USB_HYBRID:\n\tcase CX231XX_BOARD_HAUPPAUGE_USB2_FM_PAL:\n\tcase CX231XX_BOARD_HAUPPAUGE_USB2_FM_NTSC:\n\terrCode = cx231xx_set_agc_analog_digital_mux_select(dev, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (errCode < 0) {\n\t\tdev_err(dev->dev,\n\t\t\t\"%s: cx231xx_AGC mode to Analog - errCode [%d]!\\n\",\n\t\t\t__func__, errCode);\n\t\treturn errCode;\n\t}\n\n\t \n\tcx231xx_set_alt_setting(dev, INDEX_VIDEO, 0);\n\tcx231xx_set_alt_setting(dev, INDEX_VANC, 0);\n\tcx231xx_set_alt_setting(dev, INDEX_HANC, 0);\n\tif (dev->board.has_dvb)\n\t\tcx231xx_set_alt_setting(dev, INDEX_TS1, 0);\n\n\terrCode = 0;\n\treturn errCode;\n}\nEXPORT_SYMBOL_GPL(cx231xx_dev_init);\n\nvoid cx231xx_dev_uninit(struct cx231xx *dev)\n{\n\t \n\tcx231xx_i2c_mux_unregister(dev);\n\tcx231xx_i2c_unregister(&dev->i2c_bus[2]);\n\tcx231xx_i2c_unregister(&dev->i2c_bus[1]);\n\tcx231xx_i2c_unregister(&dev->i2c_bus[0]);\n}\nEXPORT_SYMBOL_GPL(cx231xx_dev_uninit);\n\n \nint cx231xx_send_gpio_cmd(struct cx231xx *dev, u32 gpio_bit, u8 *gpio_val,\n\t\t\t  u8 len, u8 request, u8 direction)\n{\n\tint status = 0;\n\tstruct VENDOR_REQUEST_IN ven_req;\n\n\t \n\tven_req.wValue = (u16) (gpio_bit >> 16 & 0xffff);\n\n\t \n\tif (!request) {\n\t\tif (direction)\n\t\t\tven_req.bRequest = VRT_GET_GPIO;\t \n\t\telse\n\t\t\tven_req.bRequest = VRT_SET_GPIO;\t \n\t} else {\n\t\tif (direction)\n\t\t\tven_req.bRequest = VRT_GET_GPIE;\t \n\t\telse\n\t\t\tven_req.bRequest = VRT_SET_GPIE;\t \n\t}\n\n\t \n\tven_req.wIndex = (u16) (gpio_bit & 0xffff);\n\n\t \n\tven_req.wLength = len;\n\n\t \n\tven_req.bData = 0;\n\n\t \n\tven_req.pBuff = gpio_val;\n\n\t \n\tif (direction) {\n\t\tven_req.direction = USB_DIR_IN;\n\t\tmemset(ven_req.pBuff, 0x00, ven_req.wLength);\n\t} else\n\t\tven_req.direction = USB_DIR_OUT;\n\n\n\t \n\tstatus = cx231xx_send_vendor_cmd(dev, &ven_req);\n\tif (status < 0) {\n\t\tdev_err(dev->dev, \"%s: failed with status -%d\\n\",\n\t\t\t__func__, status);\n\t}\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(cx231xx_send_gpio_cmd);\n\n \nint cx231xx_mode_register(struct cx231xx *dev, u16 address, u32 mode)\n{\n\tu8 value[4] = { 0x0, 0x0, 0x0, 0x0 };\n\tu32 tmp = 0;\n\tint status = 0;\n\n\tstatus =\n\t    cx231xx_read_ctrl_reg(dev, VRT_GET_REGISTER, address, value, 4);\n\tif (status < 0)\n\t\treturn status;\n\n\ttmp = le32_to_cpu(*((__le32 *) value));\n\ttmp |= mode;\n\n\tvalue[0] = (u8) tmp;\n\tvalue[1] = (u8) (tmp >> 8);\n\tvalue[2] = (u8) (tmp >> 16);\n\tvalue[3] = (u8) (tmp >> 24);\n\n\tstatus =\n\t    cx231xx_write_ctrl_reg(dev, VRT_SET_REGISTER, address, value, 4);\n\n\treturn status;\n}\n\n \nint cx231xx_read_i2c_master(struct cx231xx *dev, u8 dev_addr, u16 saddr,\n\t\t\t  u8 saddr_len, u32 *data, u8 data_len, int master)\n{\n\tint status = 0;\n\tstruct cx231xx_i2c_xfer_data req_data;\n\tu8 value[64] = \"0\";\n\n\tif (saddr_len == 0)\n\t\tsaddr = 0;\n\telse if (saddr_len == 1)\n\t\tsaddr &= 0xff;\n\n\t \n\treq_data.dev_addr = dev_addr >> 1;\n\treq_data.direction = I2C_M_RD;\n\treq_data.saddr_len = saddr_len;\n\treq_data.saddr_dat = saddr;\n\treq_data.buf_size = data_len;\n\treq_data.p_buffer = (u8 *) value;\n\n\t \n\tif (master == 0)\n\t\tstatus = dev->cx231xx_send_usb_command(&dev->i2c_bus[0],\n\t\t\t\t\t &req_data);\n\telse if (master == 1)\n\t\tstatus = dev->cx231xx_send_usb_command(&dev->i2c_bus[1],\n\t\t\t\t\t &req_data);\n\telse if (master == 2)\n\t\tstatus = dev->cx231xx_send_usb_command(&dev->i2c_bus[2],\n\t\t\t\t\t &req_data);\n\n\tif (status >= 0) {\n\t\t \n\t\tif (data_len == 1)\n\t\t\t*data = value[0];\n\t\telse if (data_len == 4)\n\t\t\t*data =\n\t\t\t    value[0] | value[1] << 8 | value[2] << 16 | value[3]\n\t\t\t    << 24;\n\t\telse if (data_len > 4)\n\t\t\t*data = value[saddr];\n\t}\n\n\treturn status;\n}\n\nint cx231xx_write_i2c_master(struct cx231xx *dev, u8 dev_addr, u16 saddr,\n\t\t\t   u8 saddr_len, u32 data, u8 data_len, int master)\n{\n\tint status = 0;\n\tu8 value[4] = { 0, 0, 0, 0 };\n\tstruct cx231xx_i2c_xfer_data req_data;\n\n\tvalue[0] = (u8) data;\n\tvalue[1] = (u8) (data >> 8);\n\tvalue[2] = (u8) (data >> 16);\n\tvalue[3] = (u8) (data >> 24);\n\n\tif (saddr_len == 0)\n\t\tsaddr = 0;\n\telse if (saddr_len == 1)\n\t\tsaddr &= 0xff;\n\n\t \n\treq_data.dev_addr = dev_addr >> 1;\n\treq_data.direction = 0;\n\treq_data.saddr_len = saddr_len;\n\treq_data.saddr_dat = saddr;\n\treq_data.buf_size = data_len;\n\treq_data.p_buffer = value;\n\n\t \n\tif (master == 0)\n\t\tstatus = dev->cx231xx_send_usb_command(&dev->i2c_bus[0],\n\t\t\t\t &req_data);\n\telse if (master == 1)\n\t\tstatus = dev->cx231xx_send_usb_command(&dev->i2c_bus[1],\n\t\t\t\t &req_data);\n\telse if (master == 2)\n\t\tstatus = dev->cx231xx_send_usb_command(&dev->i2c_bus[2],\n\t\t\t\t &req_data);\n\n\treturn status;\n}\n\nint cx231xx_read_i2c_data(struct cx231xx *dev, u8 dev_addr, u16 saddr,\n\t\t\t  u8 saddr_len, u32 *data, u8 data_len)\n{\n\tint status = 0;\n\tstruct cx231xx_i2c_xfer_data req_data;\n\tu8 value[4] = { 0, 0, 0, 0 };\n\n\tif (saddr_len == 0)\n\t\tsaddr = 0;\n\telse if (saddr_len == 1)\n\t\tsaddr &= 0xff;\n\n\t \n\treq_data.dev_addr = dev_addr >> 1;\n\treq_data.direction = I2C_M_RD;\n\treq_data.saddr_len = saddr_len;\n\treq_data.saddr_dat = saddr;\n\treq_data.buf_size = data_len;\n\treq_data.p_buffer = (u8 *) value;\n\n\t \n\tstatus = dev->cx231xx_send_usb_command(&dev->i2c_bus[0], &req_data);\n\n\tif (status >= 0) {\n\t\t \n\t\tif (data_len == 1)\n\t\t\t*data = value[0];\n\t\telse\n\t\t\t*data =\n\t\t\t    value[0] | value[1] << 8 | value[2] << 16 | value[3]\n\t\t\t    << 24;\n\t}\n\n\treturn status;\n}\n\nint cx231xx_write_i2c_data(struct cx231xx *dev, u8 dev_addr, u16 saddr,\n\t\t\t   u8 saddr_len, u32 data, u8 data_len)\n{\n\tint status = 0;\n\tu8 value[4] = { 0, 0, 0, 0 };\n\tstruct cx231xx_i2c_xfer_data req_data;\n\n\tvalue[0] = (u8) data;\n\tvalue[1] = (u8) (data >> 8);\n\tvalue[2] = (u8) (data >> 16);\n\tvalue[3] = (u8) (data >> 24);\n\n\tif (saddr_len == 0)\n\t\tsaddr = 0;\n\telse if (saddr_len == 1)\n\t\tsaddr &= 0xff;\n\n\t \n\treq_data.dev_addr = dev_addr >> 1;\n\treq_data.direction = 0;\n\treq_data.saddr_len = saddr_len;\n\treq_data.saddr_dat = saddr;\n\treq_data.buf_size = data_len;\n\treq_data.p_buffer = value;\n\n\t \n\tstatus = dev->cx231xx_send_usb_command(&dev->i2c_bus[0], &req_data);\n\n\treturn status;\n}\n\nint cx231xx_reg_mask_write(struct cx231xx *dev, u8 dev_addr, u8 size,\n\t\t\t   u16 register_address, u8 bit_start, u8 bit_end,\n\t\t\t   u32 value)\n{\n\tint status = 0;\n\tu32 tmp;\n\tu32 mask = 0;\n\tint i;\n\n\tif (bit_start > (size - 1) || bit_end > (size - 1))\n\t\treturn -1;\n\n\tif (size == 8) {\n\t\tstatus =\n\t\t    cx231xx_read_i2c_data(dev, dev_addr, register_address, 2,\n\t\t\t\t\t  &tmp, 1);\n\t} else {\n\t\tstatus =\n\t\t    cx231xx_read_i2c_data(dev, dev_addr, register_address, 2,\n\t\t\t\t\t  &tmp, 4);\n\t}\n\n\tif (status < 0)\n\t\treturn status;\n\n\tmask = 1 << bit_end;\n\tfor (i = bit_end; i > bit_start && i > 0; i--)\n\t\tmask = mask + (1 << (i - 1));\n\n\tvalue <<= bit_start;\n\n\tif (size == 8) {\n\t\ttmp &= ~mask;\n\t\ttmp |= value;\n\t\ttmp &= 0xff;\n\t\tstatus =\n\t\t    cx231xx_write_i2c_data(dev, dev_addr, register_address, 2,\n\t\t\t\t\t   tmp, 1);\n\t} else {\n\t\ttmp &= ~mask;\n\t\ttmp |= value;\n\t\tstatus =\n\t\t    cx231xx_write_i2c_data(dev, dev_addr, register_address, 2,\n\t\t\t\t\t   tmp, 4);\n\t}\n\n\treturn status;\n}\n\nint cx231xx_read_modify_write_i2c_dword(struct cx231xx *dev, u8 dev_addr,\n\t\t\t\t\tu16 saddr, u32 mask, u32 value)\n{\n\tu32 temp;\n\tint status = 0;\n\n\tstatus = cx231xx_read_i2c_data(dev, dev_addr, saddr, 2, &temp, 4);\n\n\tif (status < 0)\n\t\treturn status;\n\n\ttemp &= ~mask;\n\ttemp |= value;\n\n\tstatus = cx231xx_write_i2c_data(dev, dev_addr, saddr, 2, temp, 4);\n\n\treturn status;\n}\n\nu32 cx231xx_set_field(u32 field_mask, u32 data)\n{\n\tu32 temp;\n\n\tfor (temp = field_mask; (temp & 1) == 0; temp >>= 1)\n\t\tdata <<= 1;\n\n\treturn data;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}