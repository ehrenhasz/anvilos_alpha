{
  "module_name": "cx231xx-video.c",
  "hash_id": "bd61a956f794f7e1db1c29f28a27cfbd8e2bec1fc86a32b42d3a90f92be1849d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/cx231xx/cx231xx-video.c",
  "human_readable_source": "\n \n\n#include \"cx231xx.h\"\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/bitmap.h>\n#include <linux/i2c.h>\n#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include <media/drv-intf/msp3400.h>\n#include <media/tuner.h>\n\n#include <media/dvb_frontend.h>\n\n#include \"cx231xx-vbi.h\"\n\n#define CX231XX_VERSION \"0.0.3\"\n\n#define DRIVER_AUTHOR   \"Srinivasa Deevi <srinivasa.deevi@conexant.com>\"\n#define DRIVER_DESC     \"Conexant cx231xx based USB video device driver\"\n\n#define cx231xx_videodbg(fmt, arg...) do {\\\n\tif (video_debug) \\\n\t\tprintk(KERN_INFO \"%s %s :\"fmt, \\\n\t\t\t dev->name, __func__ , ##arg); } while (0)\n\nstatic unsigned int isoc_debug;\nmodule_param(isoc_debug, int, 0644);\nMODULE_PARM_DESC(isoc_debug, \"enable debug messages [isoc transfers]\");\n\n#define cx231xx_isocdbg(fmt, arg...) \\\ndo {\\\n\tif (isoc_debug) { \\\n\t\tprintk(KERN_INFO \"%s %s :\"fmt, \\\n\t\t\t dev->name, __func__ , ##arg); \\\n\t} \\\n  } while (0)\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(CX231XX_VERSION);\n\nstatic unsigned int card[]     = {[0 ... (CX231XX_MAXBOARDS - 1)] = -1U };\nstatic unsigned int video_nr[] = {[0 ... (CX231XX_MAXBOARDS - 1)] = -1U };\nstatic unsigned int vbi_nr[]   = {[0 ... (CX231XX_MAXBOARDS - 1)] = -1U };\nstatic unsigned int radio_nr[] = {[0 ... (CX231XX_MAXBOARDS - 1)] = -1U };\n\nmodule_param_array(card, int, NULL, 0444);\nmodule_param_array(video_nr, int, NULL, 0444);\nmodule_param_array(vbi_nr, int, NULL, 0444);\nmodule_param_array(radio_nr, int, NULL, 0444);\n\nMODULE_PARM_DESC(card, \"card type\");\nMODULE_PARM_DESC(video_nr, \"video device numbers\");\nMODULE_PARM_DESC(vbi_nr, \"vbi device numbers\");\nMODULE_PARM_DESC(radio_nr, \"radio device numbers\");\n\nstatic unsigned int video_debug;\nmodule_param(video_debug, int, 0644);\nMODULE_PARM_DESC(video_debug, \"enable debug messages [video]\");\n\n \nstatic struct cx231xx_fmt format[] = {\n\t{\n\t .fourcc = V4L2_PIX_FMT_YUYV,\n\t .depth = 16,\n\t .reg = 0,\n\t },\n};\n\n\nstatic int cx231xx_enable_analog_tuner(struct cx231xx *dev)\n{\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tstruct media_device *mdev = dev->media_dev;\n\tstruct media_entity  *entity, *decoder = NULL, *source;\n\tstruct media_link *link, *found_link = NULL;\n\tint ret, active_links = 0;\n\n\tif (!mdev)\n\t\treturn 0;\n\n\t \n\tmedia_device_for_each_entity(entity, mdev) {\n\t\tif (entity->function == MEDIA_ENT_F_ATV_DECODER) {\n\t\t\tdecoder = entity;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!decoder)\n\t\treturn 0;\n\n\tlist_for_each_entry(link, &decoder->links, list) {\n\t\tif (link->sink->entity == decoder) {\n\t\t\tfound_link = link;\n\t\t\tif (link->flags & MEDIA_LNK_FL_ENABLED)\n\t\t\t\tactive_links++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (active_links == 1 || !found_link)\n\t\treturn 0;\n\n\tsource = found_link->source->entity;\n\tlist_for_each_entry(link, &source->links, list) {\n\t\tstruct media_entity *sink;\n\t\tint flags = 0;\n\n\t\tsink = link->sink->entity;\n\n\t\tif (sink == entity)\n\t\t\tflags = MEDIA_LNK_FL_ENABLED;\n\n\t\tret = media_entity_setup_link(link, flags);\n\t\tif (ret) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"Couldn't change link %s->%s to %s. Error %d\\n\",\n\t\t\t\tsource->name, sink->name,\n\t\t\t\tflags ? \"enabled\" : \"disabled\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t} else\n\t\t\tdev_dbg(dev->dev,\n\t\t\t\t\"link %s->%s was %s\\n\",\n\t\t\t\tsource->name, sink->name,\n\t\t\t\tflags ? \"ENABLED\" : \"disabled\");\n\t}\n#endif\n\treturn 0;\n}\n\n \n\n \nstatic inline void buffer_filled(struct cx231xx *dev,\n\t\t\t\t struct cx231xx_dmaqueue *dma_q,\n\t\t\t\t struct cx231xx_buffer *buf)\n{\n\t \n\tcx231xx_isocdbg(\"[%p/%d] wakeup\\n\", buf, buf->vb.vb2_buf.index);\n\tbuf->vb.sequence = dma_q->sequence++;\n\tbuf->vb.field = V4L2_FIELD_INTERLACED;\n\tbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\tvb2_set_plane_payload(&buf->vb.vb2_buf, 0, dev->size);\n\n\tif (dev->USE_ISO)\n\t\tdev->video_mode.isoc_ctl.buf = NULL;\n\telse\n\t\tdev->video_mode.bulk_ctl.buf = NULL;\n\n\tlist_del(&buf->list);\n\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n}\n\nstatic inline void print_err_status(struct cx231xx *dev, int packet, int status)\n{\n\tchar *errmsg = \"Unknown\";\n\n\tswitch (status) {\n\tcase -ENOENT:\n\t\terrmsg = \"unlinked synchronously\";\n\t\tbreak;\n\tcase -ECONNRESET:\n\t\terrmsg = \"unlinked asynchronously\";\n\t\tbreak;\n\tcase -ENOSR:\n\t\terrmsg = \"Buffer error (overrun)\";\n\t\tbreak;\n\tcase -EPIPE:\n\t\terrmsg = \"Stalled (device not responding)\";\n\t\tbreak;\n\tcase -EOVERFLOW:\n\t\terrmsg = \"Babble (bad cable?)\";\n\t\tbreak;\n\tcase -EPROTO:\n\t\terrmsg = \"Bit-stuff error (bad cable?)\";\n\t\tbreak;\n\tcase -EILSEQ:\n\t\terrmsg = \"CRC/Timeout (could be anything)\";\n\t\tbreak;\n\tcase -ETIME:\n\t\terrmsg = \"Device does not respond\";\n\t\tbreak;\n\t}\n\tif (packet < 0) {\n\t\tcx231xx_isocdbg(\"URB status %d [%s].\\n\", status, errmsg);\n\t} else {\n\t\tcx231xx_isocdbg(\"URB packet %d, status %d [%s].\\n\",\n\t\t\t\tpacket, status, errmsg);\n\t}\n}\n\n \nstatic inline void get_next_buf(struct cx231xx_dmaqueue *dma_q,\n\t\t\t\tstruct cx231xx_buffer **buf)\n{\n\tstruct cx231xx_video_mode *vmode =\n\t    container_of(dma_q, struct cx231xx_video_mode, vidq);\n\tstruct cx231xx *dev = container_of(vmode, struct cx231xx, video_mode);\n\n\tchar *outp;\n\n\tif (list_empty(&dma_q->active)) {\n\t\tcx231xx_isocdbg(\"No active queue to serve\\n\");\n\t\tif (dev->USE_ISO)\n\t\t\tdev->video_mode.isoc_ctl.buf = NULL;\n\t\telse\n\t\t\tdev->video_mode.bulk_ctl.buf = NULL;\n\t\t*buf = NULL;\n\t\treturn;\n\t}\n\n\t \n\t*buf = list_entry(dma_q->active.next, struct cx231xx_buffer, list);\n\n\t \n\toutp = vb2_plane_vaddr(&(*buf)->vb.vb2_buf, 0);\n\tmemset(outp, 0, dev->size);\n\n\tif (dev->USE_ISO)\n\t\tdev->video_mode.isoc_ctl.buf = *buf;\n\telse\n\t\tdev->video_mode.bulk_ctl.buf = *buf;\n\n\treturn;\n}\n\n \nstatic inline int cx231xx_isoc_copy(struct cx231xx *dev, struct urb *urb)\n{\n\tstruct cx231xx_dmaqueue *dma_q = urb->context;\n\tint i;\n\tunsigned char *p_buffer;\n\tu32 bytes_parsed = 0, buffer_size = 0;\n\tu8 sav_eav = 0;\n\n\tif (!dev)\n\t\treturn 0;\n\n\tif (dev->state & DEV_DISCONNECTED)\n\t\treturn 0;\n\n\tif (urb->status < 0) {\n\t\tprint_err_status(dev, -1, urb->status);\n\t\tif (urb->status == -ENOENT)\n\t\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\tint status = urb->iso_frame_desc[i].status;\n\n\t\tif (status < 0) {\n\t\t\tprint_err_status(dev, i, status);\n\t\t\tif (urb->iso_frame_desc[i].status != -EPROTO)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (urb->iso_frame_desc[i].actual_length <= 0) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tif (urb->iso_frame_desc[i].actual_length >\n\t\t    dev->video_mode.max_pkt_size) {\n\t\t\tcx231xx_isocdbg(\"packet bigger than packet size\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tp_buffer = urb->transfer_buffer + urb->iso_frame_desc[i].offset;\n\t\tbuffer_size = urb->iso_frame_desc[i].actual_length;\n\t\tbytes_parsed = 0;\n\n\t\tif (dma_q->is_partial_line) {\n\t\t\t \n\t\t\tsav_eav = dma_q->last_sav;\n\t\t} else {\n\t\t\t \n\t\t\tsav_eav =\n\t\t\t    cx231xx_find_boundary_SAV_EAV(p_buffer,\n\t\t\t\t\t\t\t  dma_q->partial_buf,\n\t\t\t\t\t\t\t  &bytes_parsed);\n\t\t}\n\n\t\tsav_eav &= 0xF0;\n\t\t \n\t\tif (sav_eav) {\n\t\t\tbytes_parsed += cx231xx_get_video_line(dev, dma_q,\n\t\t\t\tsav_eav,\t \n\t\t\t\tp_buffer + bytes_parsed,\t \n\t\t\t\tbuffer_size - bytes_parsed); \n\t\t}\n\n\t\t \n\t\t \n\n\t\twhile (bytes_parsed < buffer_size) {\n\t\t\tu32 bytes_used = 0;\n\n\t\t\tsav_eav = cx231xx_find_next_SAV_EAV(\n\t\t\t\tp_buffer + bytes_parsed,\t \n\t\t\t\tbuffer_size - bytes_parsed,\t \n\t\t\t\t&bytes_used); \n\n\t\t\tbytes_parsed += bytes_used;\n\n\t\t\tsav_eav &= 0xF0;\n\t\t\tif (sav_eav && (bytes_parsed < buffer_size)) {\n\t\t\t\tbytes_parsed += cx231xx_get_video_line(dev,\n\t\t\t\t\tdma_q, sav_eav,\t \n\t\t\t\t\tp_buffer + bytes_parsed, \n\t\t\t\t\tbuffer_size - bytes_parsed); \n\t\t\t}\n\t\t}\n\n\t\t \n\t\tmemcpy(dma_q->partial_buf, p_buffer + buffer_size - 4, 4);\n\t\tbytes_parsed = 0;\n\n\t}\n\treturn 1;\n}\n\nstatic inline int cx231xx_bulk_copy(struct cx231xx *dev, struct urb *urb)\n{\n\tstruct cx231xx_dmaqueue *dma_q = urb->context;\n\tunsigned char *p_buffer;\n\tu32 bytes_parsed = 0, buffer_size = 0;\n\tu8 sav_eav = 0;\n\n\tif (!dev)\n\t\treturn 0;\n\n\tif (dev->state & DEV_DISCONNECTED)\n\t\treturn 0;\n\n\tif (urb->status < 0) {\n\t\tprint_err_status(dev, -1, urb->status);\n\t\tif (urb->status == -ENOENT)\n\t\t\treturn 0;\n\t}\n\n\tif (1) {\n\n\t\t \n\t\tp_buffer = urb->transfer_buffer;\n\t\tbuffer_size = urb->actual_length;\n\t\tbytes_parsed = 0;\n\n\t\tif (dma_q->is_partial_line) {\n\t\t\t \n\t\t\tsav_eav = dma_q->last_sav;\n\t\t} else {\n\t\t\t \n\t\t\tsav_eav =\n\t\t\t    cx231xx_find_boundary_SAV_EAV(p_buffer,\n\t\t\t\t\t\t\t  dma_q->partial_buf,\n\t\t\t\t\t\t\t  &bytes_parsed);\n\t\t}\n\n\t\tsav_eav &= 0xF0;\n\t\t \n\t\tif (sav_eav) {\n\t\t\tbytes_parsed += cx231xx_get_video_line(dev, dma_q,\n\t\t\t\tsav_eav,\t \n\t\t\t\tp_buffer + bytes_parsed,\t \n\t\t\t\tbuffer_size - bytes_parsed); \n\t\t}\n\n\t\t \n\t\t \n\n\t\twhile (bytes_parsed < buffer_size) {\n\t\t\tu32 bytes_used = 0;\n\n\t\t\tsav_eav = cx231xx_find_next_SAV_EAV(\n\t\t\t\tp_buffer + bytes_parsed,\t \n\t\t\t\tbuffer_size - bytes_parsed,\t \n\t\t\t\t&bytes_used); \n\n\t\t\tbytes_parsed += bytes_used;\n\n\t\t\tsav_eav &= 0xF0;\n\t\t\tif (sav_eav && (bytes_parsed < buffer_size)) {\n\t\t\t\tbytes_parsed += cx231xx_get_video_line(dev,\n\t\t\t\t\tdma_q, sav_eav,\t \n\t\t\t\t\tp_buffer + bytes_parsed, \n\t\t\t\t\tbuffer_size - bytes_parsed); \n\t\t\t}\n\t\t}\n\n\t\t \n\t\tmemcpy(dma_q->partial_buf, p_buffer + buffer_size - 4, 4);\n\t\tbytes_parsed = 0;\n\n\t}\n\treturn 1;\n}\n\n\nu8 cx231xx_find_boundary_SAV_EAV(u8 *p_buffer, u8 *partial_buf,\n\t\t\t\t u32 *p_bytes_used)\n{\n\tu32 bytes_used;\n\tu8 boundary_bytes[8];\n\tu8 sav_eav = 0;\n\n\t*p_bytes_used = 0;\n\n\t \n\n\tmemcpy(boundary_bytes, partial_buf, 4);\n\tmemcpy(boundary_bytes + 4, p_buffer, 4);\n\n\t \n\tsav_eav = cx231xx_find_next_SAV_EAV((u8 *)&boundary_bytes, 8,\n\t\t\t\t\t    &bytes_used);\n\n\tif (sav_eav) {\n\t\t \n\t\t*p_bytes_used = bytes_used - 4;\n\t}\n\n\treturn sav_eav;\n}\n\nu8 cx231xx_find_next_SAV_EAV(u8 *p_buffer, u32 buffer_size, u32 *p_bytes_used)\n{\n\tu32 i;\n\tu8 sav_eav = 0;\n\n\t \n\tif (buffer_size < 4) {\n\t\t*p_bytes_used = buffer_size;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < (buffer_size - 3); i++) {\n\n\t\tif ((p_buffer[i] == 0xFF) &&\n\t\t    (p_buffer[i + 1] == 0x00) && (p_buffer[i + 2] == 0x00)) {\n\n\t\t\t*p_bytes_used = i + 4;\n\t\t\tsav_eav = p_buffer[i + 3];\n\t\t\treturn sav_eav;\n\t\t}\n\t}\n\n\t*p_bytes_used = buffer_size;\n\treturn 0;\n}\n\nu32 cx231xx_get_video_line(struct cx231xx *dev,\n\t\t\t   struct cx231xx_dmaqueue *dma_q, u8 sav_eav,\n\t\t\t   u8 *p_buffer, u32 buffer_size)\n{\n\tu32 bytes_copied = 0;\n\tint current_field = -1;\n\n\tswitch (sav_eav) {\n\tcase SAV_ACTIVE_VIDEO_FIELD1:\n\t\t \n\t\tif ((buffer_size > 3) && (p_buffer[0] == 0xFF) &&\n\t\t    (p_buffer[1] == 0x00) && (p_buffer[2] == 0x00) &&\n\t\t    ((p_buffer[3] == EAV_ACTIVE_VIDEO_FIELD1) ||\n\t\t     (p_buffer[3] == EAV_ACTIVE_VIDEO_FIELD2) ||\n\t\t     (p_buffer[3] == EAV_VBLANK_FIELD1) ||\n\t\t     (p_buffer[3] == EAV_VBLANK_FIELD2)))\n\t\t\treturn bytes_copied;\n\t\tcurrent_field = 1;\n\t\tbreak;\n\n\tcase SAV_ACTIVE_VIDEO_FIELD2:\n\t\t \n\t\tif ((buffer_size > 3) && (p_buffer[0] == 0xFF) &&\n\t\t    (p_buffer[1] == 0x00) && (p_buffer[2] == 0x00) &&\n\t\t    ((p_buffer[3] == EAV_ACTIVE_VIDEO_FIELD1) ||\n\t\t     (p_buffer[3] == EAV_ACTIVE_VIDEO_FIELD2) ||\n\t\t     (p_buffer[3] == EAV_VBLANK_FIELD1)       ||\n\t\t     (p_buffer[3] == EAV_VBLANK_FIELD2)))\n\t\t\treturn bytes_copied;\n\t\tcurrent_field = 2;\n\t\tbreak;\n\t}\n\n\tdma_q->last_sav = sav_eav;\n\n\tbytes_copied = cx231xx_copy_video_line(dev, dma_q, p_buffer,\n\t\t\t\t\t       buffer_size, current_field);\n\n\treturn bytes_copied;\n}\n\nu32 cx231xx_copy_video_line(struct cx231xx *dev,\n\t\t\t    struct cx231xx_dmaqueue *dma_q, u8 *p_line,\n\t\t\t    u32 length, int field_number)\n{\n\tu32 bytes_to_copy;\n\tstruct cx231xx_buffer *buf;\n\tu32 _line_size = dev->width * 2;\n\n\tif (dma_q->current_field != field_number)\n\t\tcx231xx_reset_video_buffer(dev, dma_q);\n\n\t \n\tif (dev->USE_ISO)\n\t\tbuf = dev->video_mode.isoc_ctl.buf;\n\telse\n\t\tbuf = dev->video_mode.bulk_ctl.buf;\n\n\t \n\tdma_q->current_field = field_number;\n\n\tbytes_to_copy = dma_q->bytes_left_in_line;\n\tif (bytes_to_copy > length)\n\t\tbytes_to_copy = length;\n\n\tif (dma_q->lines_completed >= dma_q->lines_per_field) {\n\t\tdma_q->bytes_left_in_line -= bytes_to_copy;\n\t\tdma_q->is_partial_line = (dma_q->bytes_left_in_line == 0) ?\n\t\t\t\t\t  0 : 1;\n\t\treturn 0;\n\t}\n\n\tdma_q->is_partial_line = 1;\n\n\t \n\tif (!buf) {\n\t\tdma_q->bytes_left_in_line -= bytes_to_copy;\n\t\tdma_q->is_partial_line = (dma_q->bytes_left_in_line == 0)\n\t\t\t\t\t ? 0 : 1;\n\t\treturn bytes_to_copy;\n\t}\n\n\t \n\tcx231xx_do_copy(dev, dma_q, p_line, bytes_to_copy);\n\n\tdma_q->pos += bytes_to_copy;\n\tdma_q->bytes_left_in_line -= bytes_to_copy;\n\n\tif (dma_q->bytes_left_in_line == 0) {\n\t\tdma_q->bytes_left_in_line = _line_size;\n\t\tdma_q->lines_completed++;\n\t\tdma_q->is_partial_line = 0;\n\n\t\tif (cx231xx_is_buffer_done(dev, dma_q) && buf) {\n\t\t\tbuffer_filled(dev, dma_q, buf);\n\n\t\t\tdma_q->pos = 0;\n\t\t\tbuf = NULL;\n\t\t\tdma_q->lines_completed = 0;\n\t\t}\n\t}\n\n\treturn bytes_to_copy;\n}\n\nvoid cx231xx_reset_video_buffer(struct cx231xx *dev,\n\t\t\t\tstruct cx231xx_dmaqueue *dma_q)\n{\n\tstruct cx231xx_buffer *buf;\n\n\t \n\tif (dma_q->current_field == 1) {\n\t\tif (dma_q->lines_completed >= dma_q->lines_per_field)\n\t\t\tdma_q->field1_done = 1;\n\t\telse\n\t\t\tdma_q->field1_done = 0;\n\t}\n\n\tif (dev->USE_ISO)\n\t\tbuf = dev->video_mode.isoc_ctl.buf;\n\telse\n\t\tbuf = dev->video_mode.bulk_ctl.buf;\n\n\tif (buf == NULL) {\n\t\t \n\t\tget_next_buf(dma_q, &buf);\n\n\t\tdma_q->pos = 0;\n\t\tdma_q->field1_done = 0;\n\t\tdma_q->current_field = -1;\n\t}\n\n\t \n\tdma_q->bytes_left_in_line = dev->width << 1;\n\tdma_q->lines_completed = 0;\n}\n\nint cx231xx_do_copy(struct cx231xx *dev, struct cx231xx_dmaqueue *dma_q,\n\t\t    u8 *p_buffer, u32 bytes_to_copy)\n{\n\tu8 *p_out_buffer = NULL;\n\tu32 current_line_bytes_copied = 0;\n\tstruct cx231xx_buffer *buf;\n\tu32 _line_size = dev->width << 1;\n\tvoid *startwrite;\n\tint offset, lencopy;\n\n\tif (dev->USE_ISO)\n\t\tbuf = dev->video_mode.isoc_ctl.buf;\n\telse\n\t\tbuf = dev->video_mode.bulk_ctl.buf;\n\n\tif (buf == NULL)\n\t\treturn -1;\n\n\tp_out_buffer = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\n\n\tcurrent_line_bytes_copied = _line_size - dma_q->bytes_left_in_line;\n\n\t \n\toffset = (dma_q->current_field == 1) ? 0 : _line_size;\n\n\t \n\tstartwrite = p_out_buffer + offset;\n\n\t \n\tstartwrite += (dma_q->lines_completed * _line_size * 2);\n\n\t \n\tstartwrite += current_line_bytes_copied;\n\n\tlencopy = dma_q->bytes_left_in_line > bytes_to_copy ?\n\t\t  bytes_to_copy : dma_q->bytes_left_in_line;\n\n\tif ((u8 *)(startwrite + lencopy) > (u8 *)(p_out_buffer + dev->size))\n\t\treturn 0;\n\n\t \n\tcx231xx_swab((u16 *) p_buffer, (u16 *) startwrite, (u16) lencopy);\n\n\treturn 0;\n}\n\nvoid cx231xx_swab(u16 *from, u16 *to, u16 len)\n{\n\tu16 i;\n\n\tif (len <= 0)\n\t\treturn;\n\n\tfor (i = 0; i < len / 2; i++)\n\t\tto[i] = (from[i] << 8) | (from[i] >> 8);\n}\n\nu8 cx231xx_is_buffer_done(struct cx231xx *dev, struct cx231xx_dmaqueue *dma_q)\n{\n\tu8 buffer_complete = 0;\n\n\t \n\tbuffer_complete = ((dma_q->current_field == 2) &&\n\t\t\t   (dma_q->lines_completed >= dma_q->lines_per_field) &&\n\t\t\t    dma_q->field1_done);\n\n\treturn buffer_complete;\n}\n\n \n\nstatic int queue_setup(struct vb2_queue *vq,\n\t\t       unsigned int *nbuffers, unsigned int *nplanes,\n\t\t       unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct cx231xx *dev = vb2_get_drv_priv(vq);\n\n\tdev->size = (dev->width * dev->height * dev->format->depth + 7) >> 3;\n\n\tif (vq->num_buffers + *nbuffers < CX231XX_MIN_BUF)\n\t\t*nbuffers = CX231XX_MIN_BUF - vq->num_buffers;\n\n\tif (*nplanes)\n\t\treturn sizes[0] < dev->size ? -EINVAL : 0;\n\t*nplanes = 1;\n\tsizes[0] = dev->size;\n\n\treturn 0;\n}\n\nstatic void buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct cx231xx_buffer *buf =\n\t    container_of(vb, struct cx231xx_buffer, vb.vb2_buf);\n\tstruct cx231xx *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct cx231xx_dmaqueue *vidq = &dev->video_mode.vidq;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->video_mode.slock, flags);\n\tlist_add_tail(&buf->list, &vidq->active);\n\tspin_unlock_irqrestore(&dev->video_mode.slock, flags);\n}\n\nstatic void return_all_buffers(struct cx231xx *dev,\n\t\t\t       enum vb2_buffer_state state)\n{\n\tstruct cx231xx_dmaqueue *vidq = &dev->video_mode.vidq;\n\tstruct cx231xx_buffer *buf, *node;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->video_mode.slock, flags);\n\tif (dev->USE_ISO)\n\t\tdev->video_mode.isoc_ctl.buf = NULL;\n\telse\n\t\tdev->video_mode.bulk_ctl.buf = NULL;\n\tlist_for_each_entry_safe(buf, node, &vidq->active, list) {\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t}\n\tspin_unlock_irqrestore(&dev->video_mode.slock, flags);\n}\n\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct cx231xx *dev = vb2_get_drv_priv(vq);\n\tstruct cx231xx_dmaqueue *vidq = &dev->video_mode.vidq;\n\tint ret = 0;\n\n\tvidq->sequence = 0;\n\tdev->mode_tv = 0;\n\n\tcx231xx_enable_analog_tuner(dev);\n\tif (dev->USE_ISO)\n\t\tret = cx231xx_init_isoc(dev, CX231XX_NUM_PACKETS,\n\t\t\t\t\tCX231XX_NUM_BUFS,\n\t\t\t\t\tdev->video_mode.max_pkt_size,\n\t\t\t\t\tcx231xx_isoc_copy);\n\telse\n\t\tret = cx231xx_init_bulk(dev, CX231XX_NUM_PACKETS,\n\t\t\t\t\tCX231XX_NUM_BUFS,\n\t\t\t\t\tdev->video_mode.max_pkt_size,\n\t\t\t\t\tcx231xx_bulk_copy);\n\tif (ret)\n\t\treturn_all_buffers(dev, VB2_BUF_STATE_QUEUED);\n\tcall_all(dev, video, s_stream, 1);\n\treturn ret;\n}\n\nstatic void stop_streaming(struct vb2_queue *vq)\n{\n\tstruct cx231xx *dev = vb2_get_drv_priv(vq);\n\n\tcall_all(dev, video, s_stream, 0);\n\treturn_all_buffers(dev, VB2_BUF_STATE_ERROR);\n}\n\nstatic struct vb2_ops cx231xx_video_qops = {\n\t.queue_setup\t\t= queue_setup,\n\t.buf_queue\t\t= buffer_queue,\n\t.start_streaming\t= start_streaming,\n\t.stop_streaming\t\t= stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\n \n\nvoid video_mux(struct cx231xx *dev, int index)\n{\n\tdev->video_input = index;\n\tdev->ctl_ainput = INPUT(index)->amux;\n\n\tcx231xx_set_video_input_mux(dev, index);\n\n\tcx25840_call(dev, video, s_routing, INPUT(index)->vmux, 0, 0);\n\n\tcx231xx_set_audio_input(dev, dev->ctl_ainput);\n\n\tdev_dbg(dev->dev, \"video_mux : %d\\n\", index);\n\n\t \n\tcx231xx_do_mode_ctrl_overrides(dev);\n}\n\n \n\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\n\tf->fmt.pix.width = dev->width;\n\tf->fmt.pix.height = dev->height;\n\tf->fmt.pix.pixelformat = dev->format->fourcc;\n\tf->fmt.pix.bytesperline = (dev->width * dev->format->depth + 7) >> 3;\n\tf->fmt.pix.sizeimage = f->fmt.pix.bytesperline * dev->height;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\tf->fmt.pix.field = V4L2_FIELD_INTERLACED;\n\n\treturn 0;\n}\n\nstatic struct cx231xx_fmt *format_by_fourcc(unsigned int fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(format); i++)\n\t\tif (format[i].fourcc == fourcc)\n\t\t\treturn &format[i];\n\n\treturn NULL;\n}\n\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\tunsigned int width = f->fmt.pix.width;\n\tunsigned int height = f->fmt.pix.height;\n\tunsigned int maxw = norm_maxw(dev);\n\tunsigned int maxh = norm_maxh(dev);\n\tstruct cx231xx_fmt *fmt;\n\n\tfmt = format_by_fourcc(f->fmt.pix.pixelformat);\n\tif (!fmt) {\n\t\tcx231xx_videodbg(\"Fourcc format (%08x) invalid.\\n\",\n\t\t\t\t f->fmt.pix.pixelformat);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tv4l_bound_align_image(&width, 48, maxw, 1, &height, 32, maxh, 1, 0);\n\n\tf->fmt.pix.width = width;\n\tf->fmt.pix.height = height;\n\tf->fmt.pix.pixelformat = fmt->fourcc;\n\tf->fmt.pix.bytesperline = (width * fmt->depth + 7) >> 3;\n\tf->fmt.pix.sizeimage = f->fmt.pix.bytesperline * height;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tf->fmt.pix.field = V4L2_FIELD_INTERLACED;\n\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint rc;\n\n\trc = vidioc_try_fmt_vid_cap(file, priv, f);\n\tif (rc)\n\t\treturn rc;\n\n\tif (vb2_is_busy(&dev->vidq)) {\n\t\tdev_err(dev->dev, \"%s: queue busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tdev->width = f->fmt.pix.width;\n\tdev->height = f->fmt.pix.height;\n\tdev->format = format_by_fourcc(f->fmt.pix.pixelformat);\n\n\tv4l2_fill_mbus_format(&format.format, &f->fmt.pix, MEDIA_BUS_FMT_FIXED);\n\tcall_all(dev, pad, set_fmt, NULL, &format);\n\tv4l2_fill_pix_format(&f->fmt.pix, &format.format);\n\n\treturn rc;\n}\n\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *id)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\n\t*id = dev->norm;\n\treturn 0;\n}\n\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id norm)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\n\tif (dev->norm == norm)\n\t\treturn 0;\n\n\tif (vb2_is_busy(&dev->vidq))\n\t\treturn -EBUSY;\n\n\tdev->norm = norm;\n\n\t \n\tdev->width = 720;\n\tdev->height = (dev->norm & V4L2_STD_625_50) ? 576 : 480;\n\n\tcall_all(dev, video, s_std, dev->norm);\n\n\t \n\tformat.format.code = MEDIA_BUS_FMT_FIXED;\n\tformat.format.width = dev->width;\n\tformat.format.height = dev->height;\n\tcall_all(dev, pad, set_fmt, NULL, &format);\n\n\t \n\tcx231xx_do_mode_ctrl_overrides(dev);\n\n\treturn 0;\n}\n\nstatic const char *iname[] = {\n\t[CX231XX_VMUX_COMPOSITE1] = \"Composite1\",\n\t[CX231XX_VMUX_SVIDEO]     = \"S-Video\",\n\t[CX231XX_VMUX_TELEVISION] = \"Television\",\n\t[CX231XX_VMUX_CABLE]      = \"Cable TV\",\n\t[CX231XX_VMUX_DVB]        = \"DVB\",\n};\n\nvoid cx231xx_v4l2_create_entities(struct cx231xx *dev)\n{\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tint ret, i;\n\n\t \n\tfor (i = 0; i < MAX_CX231XX_INPUT; i++) {\n\t\tstruct media_entity *ent = &dev->input_ent[i];\n\n\t\tif (!INPUT(i)->type)\n\t\t\tbreak;\n\n\t\tent->name = iname[INPUT(i)->type];\n\t\tent->flags = MEDIA_ENT_FL_CONNECTOR;\n\t\tdev->input_pad[i].flags = MEDIA_PAD_FL_SOURCE;\n\n\t\tswitch (INPUT(i)->type) {\n\t\tcase CX231XX_VMUX_COMPOSITE1:\n\t\t\tent->function = MEDIA_ENT_F_CONN_COMPOSITE;\n\t\t\tbreak;\n\t\tcase CX231XX_VMUX_SVIDEO:\n\t\t\tent->function = MEDIA_ENT_F_CONN_SVIDEO;\n\t\t\tbreak;\n\t\tcase CX231XX_VMUX_TELEVISION:\n\t\tcase CX231XX_VMUX_CABLE:\n\t\tcase CX231XX_VMUX_DVB:\n\t\t\t \n\t\t\tif (dev->tuner_type == TUNER_ABSENT)\n\t\t\t\tcontinue;\n\t\t\tfallthrough;\n\t\tdefault:  \n\t\t\tent->function = MEDIA_ENT_F_CONN_RF;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = media_entity_pads_init(ent, 1, &dev->input_pad[i]);\n\t\tif (ret < 0)\n\t\t\tpr_err(\"failed to initialize input pad[%d]!\\n\", i);\n\n\t\tret = media_device_register_entity(dev->media_dev, ent);\n\t\tif (ret < 0)\n\t\t\tpr_err(\"failed to register input entity %d!\\n\", i);\n\t}\n#endif\n}\n\nint cx231xx_enum_input(struct file *file, void *priv,\n\t\t\t     struct v4l2_input *i)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\tu32 gen_stat;\n\tunsigned int n;\n\tint ret;\n\n\tn = i->index;\n\tif (n >= MAX_CX231XX_INPUT)\n\t\treturn -EINVAL;\n\tif (0 == INPUT(n)->type)\n\t\treturn -EINVAL;\n\n\ti->index = n;\n\ti->type = V4L2_INPUT_TYPE_CAMERA;\n\n\tstrscpy(i->name, iname[INPUT(n)->type], sizeof(i->name));\n\n\tif ((CX231XX_VMUX_TELEVISION == INPUT(n)->type) ||\n\t    (CX231XX_VMUX_CABLE == INPUT(n)->type))\n\t\ti->type = V4L2_INPUT_TYPE_TUNER;\n\n\ti->std = dev->vdev.tvnorms;\n\n\t \n\tif (n == dev->video_input) {\n\t\tret = cx231xx_read_i2c_data(dev, VID_BLK_I2C_ADDRESS,\n\t\t\t\t\t    GEN_STAT, 2, &gen_stat, 4);\n\t\tif (ret > 0) {\n\t\t\tif ((gen_stat & FLD_VPRES) == 0x00)\n\t\t\t\ti->status |= V4L2_IN_ST_NO_SIGNAL;\n\t\t\tif ((gen_stat & FLD_HLOCK) == 0x00)\n\t\t\t\ti->status |= V4L2_IN_ST_NO_H_LOCK;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint cx231xx_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\n\t*i = dev->video_input;\n\n\treturn 0;\n}\n\nint cx231xx_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\n\tdev->mode_tv = 0;\n\n\tif (i >= MAX_CX231XX_INPUT)\n\t\treturn -EINVAL;\n\tif (0 == INPUT(i)->type)\n\t\treturn -EINVAL;\n\n\tvideo_mux(dev, i);\n\n\tif (INPUT(i)->type == CX231XX_VMUX_TELEVISION ||\n\t    INPUT(i)->type == CX231XX_VMUX_CABLE) {\n\t\t \n\t\tcall_all(dev, video, s_std, dev->norm);\n\t}\n\n\treturn 0;\n}\n\nint cx231xx_g_tuner(struct file *file, void *priv, struct v4l2_tuner *t)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\n\tif (0 != t->index)\n\t\treturn -EINVAL;\n\n\tstrscpy(t->name, \"Tuner\", sizeof(t->name));\n\n\tt->type = V4L2_TUNER_ANALOG_TV;\n\tt->capability = V4L2_TUNER_CAP_NORM;\n\tt->rangehigh = 0xffffffffUL;\n\tt->signal = 0xffff;\t \n\tcall_all(dev, tuner, g_tuner, t);\n\n\treturn 0;\n}\n\nint cx231xx_s_tuner(struct file *file, void *priv, const struct v4l2_tuner *t)\n{\n\tif (0 != t->index)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nint cx231xx_g_frequency(struct file *file, void *priv,\n\t\t\t      struct v4l2_frequency *f)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\n\tif (f->tuner)\n\t\treturn -EINVAL;\n\n\tf->frequency = dev->ctl_freq;\n\n\treturn 0;\n}\n\nint cx231xx_s_frequency(struct file *file, void *priv,\n\t\t\t      const struct v4l2_frequency *f)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\tstruct v4l2_frequency new_freq = *f;\n\tint rc, need_if_freq = 0;\n\tu32 if_frequency = 5400000;\n\n\tdev_dbg(dev->dev,\n\t\t\"Enter vidioc_s_frequency()f->frequency=%d;f->type=%d\\n\",\n\t\tf->frequency, f->type);\n\n\tif (0 != f->tuner)\n\t\treturn -EINVAL;\n\n\t \n\trc = cx231xx_tuner_pre_channel_change(dev);\n\n\tswitch (dev->model) {  \n\tcase CX231XX_BOARD_HAUPPAUGE_930C_HD_1114xx:\n\tcase CX231XX_BOARD_HAUPPAUGE_935C:\n\tcase CX231XX_BOARD_HAUPPAUGE_955Q:\n\tcase CX231XX_BOARD_HAUPPAUGE_975:\n\tcase CX231XX_BOARD_EVROMEDIA_FULL_HYBRID_FULLHD:\n\t\tif (dev->cx231xx_set_analog_freq)\n\t\t\tdev->cx231xx_set_analog_freq(dev, f->frequency);\n\t\tdev->ctl_freq = f->frequency;\n\t\tneed_if_freq = 1;\n\t\tbreak;\n\tdefault:\n\t\tcall_all(dev, tuner, s_frequency, f);\n\t\tcall_all(dev, tuner, g_frequency, &new_freq);\n\t\tdev->ctl_freq = new_freq.frequency;\n\t\tbreak;\n\t}\n\n\tpr_debug(\"%s() %u  :  %u\\n\", __func__, f->frequency, dev->ctl_freq);\n\n\t \n\trc = cx231xx_tuner_post_channel_change(dev);\n\n\tif (need_if_freq || dev->tuner_type == TUNER_NXP_TDA18271) {\n\t\tif (dev->norm & (V4L2_STD_MN | V4L2_STD_NTSC_443))\n\t\t\tif_frequency = 5400000;   \n\t\telse if (dev->norm & V4L2_STD_B)\n\t\t\tif_frequency = 6000000;   \n\t\telse if (dev->norm & (V4L2_STD_PAL_DK | V4L2_STD_SECAM_DK))\n\t\t\tif_frequency = 6900000;   \n\t\telse if (dev->norm & V4L2_STD_GH)\n\t\t\tif_frequency = 7100000;   \n\t\telse if (dev->norm & V4L2_STD_PAL_I)\n\t\t\tif_frequency = 7250000;   \n\t\telse if (dev->norm & V4L2_STD_SECAM_L)\n\t\t\tif_frequency = 6900000;   \n\t\telse if (dev->norm & V4L2_STD_SECAM_LC)\n\t\t\tif_frequency = 1250000;   \n\n\t\tdev_dbg(dev->dev,\n\t\t\t\"if_frequency is set to %d\\n\", if_frequency);\n\t\tcx231xx_set_Colibri_For_LowIF(dev, if_frequency, 1, 1);\n\n\t\tupdate_HH_register_after_set_DIF(dev);\n\t}\n\n\tdev_dbg(dev->dev, \"Set New FREQUENCY to %d\\n\", f->frequency);\n\n\treturn rc;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\nint cx231xx_g_chip_info(struct file *file, void *fh,\n\t\t\tstruct v4l2_dbg_chip_info *chip)\n{\n\tswitch (chip->match.addr) {\n\tcase 0:\t \n\t\treturn 0;\n\tcase 1:\t \n\t\tstrscpy(chip->name, \"AFE (byte)\", sizeof(chip->name));\n\t\treturn 0;\n\tcase 2:\t \n\t\tstrscpy(chip->name, \"Video (byte)\", sizeof(chip->name));\n\t\treturn 0;\n\tcase 3:\t \n\t\tstrscpy(chip->name, \"I2S (byte)\", sizeof(chip->name));\n\t\treturn 0;\n\tcase 4:  \n\t\tstrscpy(chip->name, \"AFE (dword)\", sizeof(chip->name));\n\t\treturn 0;\n\tcase 5:  \n\t\tstrscpy(chip->name, \"Video (dword)\", sizeof(chip->name));\n\t\treturn 0;\n\tcase 6:  \n\t\tstrscpy(chip->name, \"I2S (dword)\", sizeof(chip->name));\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nint cx231xx_g_register(struct file *file, void *priv,\n\t\t\t     struct v4l2_dbg_register *reg)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\tint ret;\n\tu8 value[4] = { 0, 0, 0, 0 };\n\tu32 data = 0;\n\n\tswitch (reg->match.addr) {\n\tcase 0:\t \n\t\tret = cx231xx_read_ctrl_reg(dev, VRT_GET_REGISTER,\n\t\t\t\t(u16)reg->reg, value, 4);\n\t\treg->val = value[0] | value[1] << 8 |\n\t\t\tvalue[2] << 16 | (u32)value[3] << 24;\n\t\treg->size = 4;\n\t\tbreak;\n\tcase 1:\t \n\t\tret = cx231xx_read_i2c_data(dev, AFE_DEVICE_ADDRESS,\n\t\t\t\t(u16)reg->reg, 2, &data, 1);\n\t\treg->val = data;\n\t\treg->size = 1;\n\t\tbreak;\n\tcase 2:\t \n\t\tret = cx231xx_read_i2c_data(dev, VID_BLK_I2C_ADDRESS,\n\t\t\t\t(u16)reg->reg, 2, &data, 1);\n\t\treg->val = data;\n\t\treg->size = 1;\n\t\tbreak;\n\tcase 3:\t \n\t\tret = cx231xx_read_i2c_data(dev, I2S_BLK_DEVICE_ADDRESS,\n\t\t\t\t(u16)reg->reg, 1, &data, 1);\n\t\treg->val = data;\n\t\treg->size = 1;\n\t\tbreak;\n\tcase 4:  \n\t\tret = cx231xx_read_i2c_data(dev, AFE_DEVICE_ADDRESS,\n\t\t\t\t(u16)reg->reg, 2, &data, 4);\n\t\treg->val = data;\n\t\treg->size = 4;\n\t\tbreak;\n\tcase 5:  \n\t\tret = cx231xx_read_i2c_data(dev, VID_BLK_I2C_ADDRESS,\n\t\t\t\t(u16)reg->reg, 2, &data, 4);\n\t\treg->val = data;\n\t\treg->size = 4;\n\t\tbreak;\n\tcase 6:  \n\t\tret = cx231xx_read_i2c_data(dev, I2S_BLK_DEVICE_ADDRESS,\n\t\t\t\t(u16)reg->reg, 1, &data, 4);\n\t\treg->val = data;\n\t\treg->size = 4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn ret < 0 ? ret : 0;\n}\n\nint cx231xx_s_register(struct file *file, void *priv,\n\t\t\t     const struct v4l2_dbg_register *reg)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\tint ret;\n\tu8 data[4] = { 0, 0, 0, 0 };\n\n\tswitch (reg->match.addr) {\n\tcase 0:\t \n\t\tdata[0] = (u8) reg->val;\n\t\tdata[1] = (u8) (reg->val >> 8);\n\t\tdata[2] = (u8) (reg->val >> 16);\n\t\tdata[3] = (u8) (reg->val >> 24);\n\t\tret = cx231xx_write_ctrl_reg(dev, VRT_SET_REGISTER,\n\t\t\t\t(u16)reg->reg, data, 4);\n\t\tbreak;\n\tcase 1:\t \n\t\tret = cx231xx_write_i2c_data(dev, AFE_DEVICE_ADDRESS,\n\t\t\t\t(u16)reg->reg, 2, reg->val, 1);\n\t\tbreak;\n\tcase 2:\t \n\t\tret = cx231xx_write_i2c_data(dev, VID_BLK_I2C_ADDRESS,\n\t\t\t\t(u16)reg->reg, 2, reg->val, 1);\n\t\tbreak;\n\tcase 3:\t \n\t\tret = cx231xx_write_i2c_data(dev, I2S_BLK_DEVICE_ADDRESS,\n\t\t\t\t(u16)reg->reg, 1, reg->val, 1);\n\t\tbreak;\n\tcase 4:  \n\t\tret = cx231xx_write_i2c_data(dev, AFE_DEVICE_ADDRESS,\n\t\t\t\t(u16)reg->reg, 2, reg->val, 4);\n\t\tbreak;\n\tcase 5:  \n\t\tret = cx231xx_write_i2c_data(dev, VID_BLK_I2C_ADDRESS,\n\t\t\t\t(u16)reg->reg, 2, reg->val, 4);\n\t\tbreak;\n\tcase 6:  \n\t\tret = cx231xx_write_i2c_data(dev, I2S_BLK_DEVICE_ADDRESS,\n\t\t\t\t(u16)reg->reg, 1, reg->val, 4);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn ret < 0 ? ret : 0;\n}\n#endif\n\nstatic int vidioc_g_pixelaspect(struct file *file, void *priv,\n\t\t\t\tint type, struct v4l2_fract *f)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\tbool is_50hz = dev->norm & V4L2_STD_625_50;\n\n\tif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tf->numerator = is_50hz ? 54 : 11;\n\tf->denominator = is_50hz ? 59 : 10;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_selection(struct file *file, void *priv,\n\t\t\t      struct v4l2_selection *s)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = dev->width;\n\t\ts->r.height = dev->height;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint cx231xx_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\n\tstrscpy(cap->driver, \"cx231xx\", sizeof(cap->driver));\n\tstrscpy(cap->card, cx231xx_boards[dev->model].name, sizeof(cap->card));\n\tusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\n\tcap->capabilities = V4L2_CAP_READWRITE |\n\t\tV4L2_CAP_VBI_CAPTURE | V4L2_CAP_VIDEO_CAPTURE |\n\t\tV4L2_CAP_STREAMING | V4L2_CAP_DEVICE_CAPS;\n\tif (video_is_registered(&dev->radio_dev))\n\t\tcap->capabilities |= V4L2_CAP_RADIO;\n\n\tswitch (dev->model) {\n\tcase CX231XX_BOARD_HAUPPAUGE_930C_HD_1114xx:\n\tcase CX231XX_BOARD_HAUPPAUGE_935C:\n\tcase CX231XX_BOARD_HAUPPAUGE_955Q:\n\tcase CX231XX_BOARD_HAUPPAUGE_975:\n\tcase CX231XX_BOARD_EVROMEDIA_FULL_HYBRID_FULLHD:\n\t\tcap->capabilities |= V4L2_CAP_TUNER;\n\t\tbreak;\n\tdefault:\n\t\tif (dev->tuner_type != TUNER_ABSENT)\n\t\t\tcap->capabilities |= V4L2_CAP_TUNER;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tif (unlikely(f->index >= ARRAY_SIZE(format)))\n\t\treturn -EINVAL;\n\n\tf->pixelformat = format[f->index].fourcc;\n\n\treturn 0;\n}\n\n \n\nstatic int vidioc_g_fmt_vbi_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\n\tf->fmt.vbi.sampling_rate = 6750000 * 4;\n\tf->fmt.vbi.samples_per_line = VBI_LINE_LENGTH;\n\tf->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;\n\tf->fmt.vbi.offset = 0;\n\tf->fmt.vbi.start[0] = (dev->norm & V4L2_STD_625_50) ?\n\t    PAL_VBI_START_LINE : NTSC_VBI_START_LINE;\n\tf->fmt.vbi.count[0] = (dev->norm & V4L2_STD_625_50) ?\n\t    PAL_VBI_LINES : NTSC_VBI_LINES;\n\tf->fmt.vbi.start[1] = (dev->norm & V4L2_STD_625_50) ?\n\t    PAL_VBI_START_LINE + 312 : NTSC_VBI_START_LINE + 263;\n\tf->fmt.vbi.count[1] = f->fmt.vbi.count[0];\n\tmemset(f->fmt.vbi.reserved, 0, sizeof(f->fmt.vbi.reserved));\n\n\treturn 0;\n\n}\n\nstatic int vidioc_try_fmt_vbi_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\n\tf->fmt.vbi.sampling_rate = 6750000 * 4;\n\tf->fmt.vbi.samples_per_line = VBI_LINE_LENGTH;\n\tf->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;\n\tf->fmt.vbi.offset = 0;\n\tf->fmt.vbi.flags = 0;\n\tf->fmt.vbi.start[0] = (dev->norm & V4L2_STD_625_50) ?\n\t    PAL_VBI_START_LINE : NTSC_VBI_START_LINE;\n\tf->fmt.vbi.count[0] = (dev->norm & V4L2_STD_625_50) ?\n\t    PAL_VBI_LINES : NTSC_VBI_LINES;\n\tf->fmt.vbi.start[1] = (dev->norm & V4L2_STD_625_50) ?\n\t    PAL_VBI_START_LINE + 312 : NTSC_VBI_START_LINE + 263;\n\tf->fmt.vbi.count[1] = f->fmt.vbi.count[0];\n\tmemset(f->fmt.vbi.reserved, 0, sizeof(f->fmt.vbi.reserved));\n\n\treturn 0;\n\n}\n\nstatic int vidioc_s_fmt_vbi_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\treturn vidioc_try_fmt_vbi_cap(file, priv, f);\n}\n\n \n \n \n\nstatic int radio_g_tuner(struct file *file, void *priv, struct v4l2_tuner *t)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\n\tif (t->index)\n\t\treturn -EINVAL;\n\n\tstrscpy(t->name, \"Radio\", sizeof(t->name));\n\n\tcall_all(dev, tuner, g_tuner, t);\n\n\treturn 0;\n}\nstatic int radio_s_tuner(struct file *file, void *priv, const struct v4l2_tuner *t)\n{\n\tstruct cx231xx *dev = video_drvdata(file);\n\n\tif (t->index)\n\t\treturn -EINVAL;\n\n\tcall_all(dev, tuner, s_tuner, t);\n\n\treturn 0;\n}\n\n \nstatic int cx231xx_v4l2_open(struct file *filp)\n{\n\tstruct video_device *vdev = video_devdata(filp);\n\tstruct cx231xx *dev = video_drvdata(filp);\n\tint ret;\n\n\tif (mutex_lock_interruptible(&dev->lock))\n\t\treturn -ERESTARTSYS;\n\n\tret = v4l2_fh_open(filp);\n\tif (ret) {\n\t\tmutex_unlock(&dev->lock);\n\t\treturn ret;\n\t}\n\n\tif (dev->users++ == 0) {\n\t\t \n\t\tif (dev->board.external_av)\n\t\t\tcx231xx_set_power_mode(dev,\n\t\t\t\t POLARIS_AVMODE_ENXTERNAL_AV);\n\t\telse\n\t\t\tcx231xx_set_power_mode(dev, POLARIS_AVMODE_ANALOGT_TV);\n\n\t\t \n\t\tcx231xx_set_video_alternate(dev);\n\n\t\t \n\t\tcx231xx_config_i2c(dev);\n\n\t\t \n\t\tdev->video_input = dev->video_input > 2 ? 2 : dev->video_input;\n\t}\n\n\tif (vdev->vfl_type == VFL_TYPE_RADIO) {\n\t\tcx231xx_videodbg(\"video_open: setting radio device\\n\");\n\n\t\t \n\n\t\tcall_all(dev, tuner, s_radio);\n\t}\n\tif (vdev->vfl_type == VFL_TYPE_VBI) {\n\t\t \n\t\tcx231xx_set_alt_setting(dev, INDEX_VANC, 0);\n\t}\n\tmutex_unlock(&dev->lock);\n\treturn 0;\n}\n\n \nvoid cx231xx_release_analog_resources(struct cx231xx *dev)\n{\n\n\t \n\n\tif (video_is_registered(&dev->radio_dev))\n\t\tvideo_unregister_device(&dev->radio_dev);\n\tif (video_is_registered(&dev->vbi_dev)) {\n\t\tdev_info(dev->dev, \"V4L2 device %s deregistered\\n\",\n\t\t\tvideo_device_node_name(&dev->vbi_dev));\n\t\tvideo_unregister_device(&dev->vbi_dev);\n\t}\n\tif (video_is_registered(&dev->vdev)) {\n\t\tdev_info(dev->dev, \"V4L2 device %s deregistered\\n\",\n\t\t\tvideo_device_node_name(&dev->vdev));\n\n\t\tif (dev->board.has_417)\n\t\t\tcx231xx_417_unregister(dev);\n\n\t\tvideo_unregister_device(&dev->vdev);\n\t}\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\n\tv4l2_ctrl_handler_free(&dev->radio_ctrl_handler);\n}\n\n \nstatic int cx231xx_close(struct file *filp)\n{\n\tstruct cx231xx *dev = video_drvdata(filp);\n\tstruct video_device *vdev = video_devdata(filp);\n\n\t_vb2_fop_release(filp, NULL);\n\n\tif (--dev->users == 0) {\n\t\t \n\t\tcall_all(dev, tuner, standby);\n\n\t\t \n\t\tif (dev->USE_ISO)\n\t\t\tcx231xx_uninit_isoc(dev);\n\t\telse\n\t\t\tcx231xx_uninit_bulk(dev);\n\t\tcx231xx_set_mode(dev, CX231XX_SUSPEND);\n\t}\n\n\t \n\tif (!dev->board.no_alt_vanc && vdev->vfl_type == VFL_TYPE_VBI) {\n\t\t \n\t\tcx231xx_uninit_vbi_isoc(dev);\n\n\t\t \n\t\tif (!dev->vbi_or_sliced_cc_mode)\n\t\t\tcx231xx_set_alt_setting(dev, INDEX_VANC, 0);\n\t\telse\n\t\t\tcx231xx_set_alt_setting(dev, INDEX_HANC, 0);\n\n\t\twake_up_interruptible_nr(&dev->open, 1);\n\t\treturn 0;\n\t}\n\n\tif (dev->users == 0) {\n\t\t \n\t\tcx231xx_set_alt_setting(dev, INDEX_VIDEO, 0);\n\t}\n\n\twake_up_interruptible(&dev->open);\n\treturn 0;\n}\n\nstatic int cx231xx_v4l2_close(struct file *filp)\n{\n\tstruct cx231xx *dev = video_drvdata(filp);\n\tint rc;\n\n\tmutex_lock(&dev->lock);\n\trc = cx231xx_close(filp);\n\tmutex_unlock(&dev->lock);\n\treturn rc;\n}\n\nstatic const struct v4l2_file_operations cx231xx_v4l_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = cx231xx_v4l2_open,\n\t.release = cx231xx_v4l2_close,\n\t.read    = vb2_fop_read,\n\t.poll    = vb2_fop_poll,\n\t.mmap    = vb2_fop_mmap,\n\t.unlocked_ioctl   = video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops video_ioctl_ops = {\n\t.vidioc_querycap               = cx231xx_querycap,\n\t.vidioc_enum_fmt_vid_cap       = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap          = vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap        = vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap          = vidioc_s_fmt_vid_cap,\n\t.vidioc_g_fmt_vbi_cap          = vidioc_g_fmt_vbi_cap,\n\t.vidioc_try_fmt_vbi_cap        = vidioc_try_fmt_vbi_cap,\n\t.vidioc_s_fmt_vbi_cap          = vidioc_s_fmt_vbi_cap,\n\t.vidioc_g_pixelaspect          = vidioc_g_pixelaspect,\n\t.vidioc_g_selection            = vidioc_g_selection,\n\t.vidioc_reqbufs                = vb2_ioctl_reqbufs,\n\t.vidioc_querybuf               = vb2_ioctl_querybuf,\n\t.vidioc_qbuf                   = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf                  = vb2_ioctl_dqbuf,\n\t.vidioc_s_std                  = vidioc_s_std,\n\t.vidioc_g_std                  = vidioc_g_std,\n\t.vidioc_enum_input             = cx231xx_enum_input,\n\t.vidioc_g_input                = cx231xx_g_input,\n\t.vidioc_s_input                = cx231xx_s_input,\n\t.vidioc_streamon               = vb2_ioctl_streamon,\n\t.vidioc_streamoff              = vb2_ioctl_streamoff,\n\t.vidioc_g_tuner                = cx231xx_g_tuner,\n\t.vidioc_s_tuner                = cx231xx_s_tuner,\n\t.vidioc_g_frequency            = cx231xx_g_frequency,\n\t.vidioc_s_frequency            = cx231xx_s_frequency,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_chip_info            = cx231xx_g_chip_info,\n\t.vidioc_g_register             = cx231xx_g_register,\n\t.vidioc_s_register             = cx231xx_s_register,\n#endif\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic struct video_device cx231xx_vbi_template;\n\nstatic const struct video_device cx231xx_video_template = {\n\t.fops         = &cx231xx_v4l_fops,\n\t.release      = video_device_release_empty,\n\t.ioctl_ops    = &video_ioctl_ops,\n\t.tvnorms      = V4L2_STD_ALL,\n};\n\nstatic const struct v4l2_file_operations radio_fops = {\n\t.owner   = THIS_MODULE,\n\t.open   = cx231xx_v4l2_open,\n\t.release = cx231xx_v4l2_close,\n\t.poll = v4l2_ctrl_poll,\n\t.unlocked_ioctl = video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops radio_ioctl_ops = {\n\t.vidioc_querycap    = cx231xx_querycap,\n\t.vidioc_g_tuner     = radio_g_tuner,\n\t.vidioc_s_tuner     = radio_s_tuner,\n\t.vidioc_g_frequency = cx231xx_g_frequency,\n\t.vidioc_s_frequency = cx231xx_s_frequency,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_chip_info = cx231xx_g_chip_info,\n\t.vidioc_g_register  = cx231xx_g_register,\n\t.vidioc_s_register  = cx231xx_s_register,\n#endif\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic struct video_device cx231xx_radio_template = {\n\t.name      = \"cx231xx-radio\",\n\t.fops      = &radio_fops,\n\t.ioctl_ops = &radio_ioctl_ops,\n};\n\n \n\nstatic void cx231xx_vdev_init(struct cx231xx *dev,\n\t\tstruct video_device *vfd,\n\t\tconst struct video_device *template,\n\t\tconst char *type_name)\n{\n\t*vfd = *template;\n\tvfd->v4l2_dev = &dev->v4l2_dev;\n\tvfd->release = video_device_release_empty;\n\tvfd->lock = &dev->lock;\n\n\tsnprintf(vfd->name, sizeof(vfd->name), \"%s %s\", dev->name, type_name);\n\n\tvideo_set_drvdata(vfd, dev);\n\tif (dev->tuner_type == TUNER_ABSENT) {\n\t\tswitch (dev->model) {\n\t\tcase CX231XX_BOARD_HAUPPAUGE_930C_HD_1114xx:\n\t\tcase CX231XX_BOARD_HAUPPAUGE_935C:\n\t\tcase CX231XX_BOARD_HAUPPAUGE_955Q:\n\t\tcase CX231XX_BOARD_HAUPPAUGE_975:\n\t\tcase CX231XX_BOARD_EVROMEDIA_FULL_HYBRID_FULLHD:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tv4l2_disable_ioctl(vfd, VIDIOC_G_FREQUENCY);\n\t\t\tv4l2_disable_ioctl(vfd, VIDIOC_S_FREQUENCY);\n\t\t\tv4l2_disable_ioctl(vfd, VIDIOC_G_TUNER);\n\t\t\tv4l2_disable_ioctl(vfd, VIDIOC_S_TUNER);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint cx231xx_register_analog_devices(struct cx231xx *dev)\n{\n\tstruct vb2_queue *q;\n\tint ret;\n\n\tdev_info(dev->dev, \"v4l2 driver version %s\\n\", CX231XX_VERSION);\n\n\t \n\tdev->norm = V4L2_STD_PAL;\n\tdev->width = norm_maxw(dev);\n\tdev->height = norm_maxh(dev);\n\tdev->interlaced = 0;\n\n\t \n\tdev->format = &format[0];\n\n\t \n\tvideo_mux(dev, dev->video_input);\n\n\tcall_all(dev, video, s_std, dev->norm);\n\n\tv4l2_ctrl_handler_init(&dev->ctrl_handler, 10);\n\tv4l2_ctrl_handler_init(&dev->radio_ctrl_handler, 5);\n\n\tif (dev->sd_cx25840) {\n\t\tv4l2_ctrl_add_handler(&dev->ctrl_handler,\n\t\t\t\tdev->sd_cx25840->ctrl_handler, NULL, true);\n\t\tv4l2_ctrl_add_handler(&dev->radio_ctrl_handler,\n\t\t\t\tdev->sd_cx25840->ctrl_handler,\n\t\t\t\tv4l2_ctrl_radio_filter, true);\n\t}\n\n\tif (dev->ctrl_handler.error)\n\t\treturn dev->ctrl_handler.error;\n\tif (dev->radio_ctrl_handler.error)\n\t\treturn dev->radio_ctrl_handler.error;\n\n\t \n\t \n\n\t \n\tcx231xx_vdev_init(dev, &dev->vdev, &cx231xx_video_template, \"video\");\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tdev->video_pad.flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&dev->vdev.entity, 1, &dev->video_pad);\n\tif (ret < 0)\n\t\tdev_err(dev->dev, \"failed to initialize video media entity!\\n\");\n#endif\n\tdev->vdev.ctrl_handler = &dev->ctrl_handler;\n\n\tq = &dev->vidq;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_USERPTR | VB2_MMAP | VB2_DMABUF | VB2_READ;\n\tq->drv_priv = dev;\n\tq->buf_struct_size = sizeof(struct cx231xx_buffer);\n\tq->ops = &cx231xx_video_qops;\n\tq->mem_ops = &vb2_vmalloc_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->min_buffers_needed = 1;\n\tq->lock = &dev->lock;\n\tret = vb2_queue_init(q);\n\tif (ret)\n\t\treturn ret;\n\tdev->vdev.queue = q;\n\tdev->vdev.device_caps = V4L2_CAP_READWRITE | V4L2_CAP_STREAMING |\n\t\t\t\tV4L2_CAP_VIDEO_CAPTURE;\n\n\tswitch (dev->model) {  \n\tcase CX231XX_BOARD_HAUPPAUGE_930C_HD_1114xx:\n\tcase CX231XX_BOARD_HAUPPAUGE_935C:\n\tcase CX231XX_BOARD_HAUPPAUGE_955Q:\n\tcase CX231XX_BOARD_HAUPPAUGE_975:\n\tcase CX231XX_BOARD_EVROMEDIA_FULL_HYBRID_FULLHD:\n\t\tdev->vdev.device_caps |= V4L2_CAP_TUNER;\n\t\tbreak;\n\tdefault:\n\t\tif (dev->tuner_type != TUNER_ABSENT)\n\t\t\tdev->vdev.device_caps |= V4L2_CAP_TUNER;\n\t\tbreak;\n\t}\n\n\t \n\tret = video_register_device(&dev->vdev, VFL_TYPE_VIDEO,\n\t\t\t\t    video_nr[dev->devno]);\n\tif (ret) {\n\t\tdev_err(dev->dev,\n\t\t\t\"unable to register video device (error=%i).\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tdev_info(dev->dev, \"Registered video device %s [v4l2]\\n\",\n\t\tvideo_device_node_name(&dev->vdev));\n\n\t \n\tcx231xx_vbi_template = cx231xx_video_template;\n\tstrscpy(cx231xx_vbi_template.name, \"cx231xx-vbi\",\n\t\tsizeof(cx231xx_vbi_template.name));\n\n\t \n\tcx231xx_vdev_init(dev, &dev->vbi_dev, &cx231xx_vbi_template, \"vbi\");\n\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\tdev->vbi_pad.flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&dev->vbi_dev.entity, 1, &dev->vbi_pad);\n\tif (ret < 0)\n\t\tdev_err(dev->dev, \"failed to initialize vbi media entity!\\n\");\n#endif\n\tdev->vbi_dev.ctrl_handler = &dev->ctrl_handler;\n\n\tq = &dev->vbiq;\n\tq->type = V4L2_BUF_TYPE_VBI_CAPTURE;\n\tq->io_modes = VB2_USERPTR | VB2_MMAP | VB2_DMABUF | VB2_READ;\n\tq->drv_priv = dev;\n\tq->buf_struct_size = sizeof(struct cx231xx_buffer);\n\tq->ops = &cx231xx_vbi_qops;\n\tq->mem_ops = &vb2_vmalloc_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->min_buffers_needed = 1;\n\tq->lock = &dev->lock;\n\tret = vb2_queue_init(q);\n\tif (ret)\n\t\treturn ret;\n\tdev->vbi_dev.queue = q;\n\tdev->vbi_dev.device_caps = V4L2_CAP_READWRITE | V4L2_CAP_STREAMING |\n\t\t\t\t   V4L2_CAP_VBI_CAPTURE;\n\tswitch (dev->model) {  \n\tcase CX231XX_BOARD_HAUPPAUGE_930C_HD_1114xx:\n\tcase CX231XX_BOARD_HAUPPAUGE_935C:\n\tcase CX231XX_BOARD_HAUPPAUGE_955Q:\n\tcase CX231XX_BOARD_HAUPPAUGE_975:\n\tcase CX231XX_BOARD_EVROMEDIA_FULL_HYBRID_FULLHD:\n\t\tdev->vbi_dev.device_caps |= V4L2_CAP_TUNER;\n\t\tbreak;\n\tdefault:\n\t\tif (dev->tuner_type != TUNER_ABSENT)\n\t\t\tdev->vbi_dev.device_caps |= V4L2_CAP_TUNER;\n\t}\n\n\t \n\tret = video_register_device(&dev->vbi_dev, VFL_TYPE_VBI,\n\t\t\t\t    vbi_nr[dev->devno]);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev, \"unable to register vbi device\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(dev->dev, \"Registered VBI device %s\\n\",\n\t\tvideo_device_node_name(&dev->vbi_dev));\n\n\tif (cx231xx_boards[dev->model].radio.type == CX231XX_RADIO) {\n\t\tcx231xx_vdev_init(dev, &dev->radio_dev,\n\t\t\t\t&cx231xx_radio_template, \"radio\");\n\t\tdev->radio_dev.ctrl_handler = &dev->radio_ctrl_handler;\n\t\tdev->radio_dev.device_caps = V4L2_CAP_RADIO | V4L2_CAP_TUNER;\n\t\tret = video_register_device(&dev->radio_dev, VFL_TYPE_RADIO,\n\t\t\t\t\t    radio_nr[dev->devno]);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"can't register radio device\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tdev_info(dev->dev, \"Registered radio device as %s\\n\",\n\t\t\tvideo_device_node_name(&dev->radio_dev));\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}