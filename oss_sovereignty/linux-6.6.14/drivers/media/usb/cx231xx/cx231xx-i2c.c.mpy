{
  "module_name": "cx231xx-i2c.c",
  "hash_id": "e57e838cfd0dc5b0088be96703c10d913eb2f5b036de7a43b4ff0deb7ba531cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/cx231xx/cx231xx-i2c.c",
  "human_readable_source": "\n \n\n#include \"cx231xx.h\"\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/i2c.h>\n#include <linux/i2c-mux.h>\n#include <media/v4l2-common.h>\n#include <media/tuner.h>\n\n\n \n\nstatic unsigned int i2c_scan;\nmodule_param(i2c_scan, int, 0444);\nMODULE_PARM_DESC(i2c_scan, \"scan i2c bus at insmod time\");\n\nstatic unsigned int i2c_debug;\nmodule_param(i2c_debug, int, 0644);\nMODULE_PARM_DESC(i2c_debug, \"enable debug messages [i2c]\");\n\n#define dprintk1(lvl, fmt, args...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (i2c_debug >= lvl) {\t\t\t\t\\\n\t\tprintk(fmt, ##args);\t\t\t\\\n\t\t}\t\t\t\t\t\\\n} while (0)\n\n#define dprintk2(lvl, fmt, args...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (i2c_debug >= lvl) {\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"%s at %s: \" fmt,\t\\\n\t\t       dev->name, __func__ , ##args);\t\\\n      }\t\t\t\t\t\t\t\\\n} while (0)\n\nstatic inline int get_real_i2c_port(struct cx231xx *dev, int bus_nr)\n{\n\tif (bus_nr == 1)\n\t\treturn dev->port_3_switch_enabled ? I2C_1_MUX_3 : I2C_1_MUX_1;\n\treturn bus_nr;\n}\n\nstatic inline bool is_tuner(struct cx231xx *dev, struct cx231xx_i2c *bus,\n\t\t\tconst struct i2c_msg *msg, int tuner_type)\n{\n\tint i2c_port = get_real_i2c_port(dev, bus->nr);\n\n\tif (i2c_port != dev->board.tuner_i2c_master)\n\t\treturn false;\n\n\tif (msg->addr != dev->board.tuner_addr)\n\t\treturn false;\n\n\tif (dev->tuner_type != tuner_type)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic int cx231xx_i2c_send_bytes(struct i2c_adapter *i2c_adap,\n\t\t\t\t  const struct i2c_msg *msg)\n{\n\tstruct cx231xx_i2c *bus = i2c_adap->algo_data;\n\tstruct cx231xx *dev = bus->dev;\n\tstruct cx231xx_i2c_xfer_data req_data;\n\tint status = 0;\n\tu16 size = 0;\n\tu8 loop = 0;\n\tu8 saddr_len = 1;\n\tu8 *buf_ptr = NULL;\n\tu16 saddr = 0;\n\tu8 need_gpio = 0;\n\n\tif (is_tuner(dev, bus, msg, TUNER_XC5000)) {\n\t\tsize = msg->len;\n\n\t\tif (size == 2) {\t \n\t\t\t \n\t\t\treturn 0;\n\t\t} else if (size == 4) {\t \n\t\t\tif (msg->len >= 2)\n\t\t\t\tsaddr = msg->buf[0] << 8 | msg->buf[1];\n\t\t\telse if (msg->len == 1)\n\t\t\t\tsaddr = msg->buf[0];\n\n\t\t\tswitch (saddr) {\n\t\t\tcase 0x0000:\t \n\t\t\t\tneed_gpio = 1;\n\t\t\t\t \n\t\t\t\tdev->xc_fw_load_done = 1;\n\t\t\t\tbreak;\n\t\t\tcase 0x000D:\t \n\t\t\tcase 0x0001:\t \n\t\t\tcase 0x0002:\t \n\t\t\tcase 0x0003:\t \n\t\t\t\tneed_gpio = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (dev->xc_fw_load_done)\n\t\t\t\t\tneed_gpio = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (need_gpio) {\n\t\t\t\tdprintk1(1,\n\t\t\t\t\"GPIO WRITE: addr 0x%x, len %d, saddr 0x%x\\n\",\n\t\t\t\tmsg->addr, msg->len, saddr);\n\n\t\t\t\treturn dev->cx231xx_gpio_i2c_write(dev,\n\t\t\t\t\t\t\t\t   msg->addr,\n\t\t\t\t\t\t\t\t   msg->buf,\n\t\t\t\t\t\t\t\t   msg->len);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tsaddr_len = 1;\n\n\t\t \n\t\tsize -= saddr_len;\n\t\tbuf_ptr = (u8 *) (msg->buf + 1);\n\n\t\tdo {\n\t\t\t \n\t\t\treq_data.dev_addr = msg->addr;\n\t\t\treq_data.direction = msg->flags;\n\t\t\treq_data.saddr_len = saddr_len;\n\t\t\treq_data.saddr_dat = msg->buf[0];\n\t\t\treq_data.buf_size = size > 16 ? 16 : size;\n\t\t\treq_data.p_buffer = (u8 *) (buf_ptr + loop * 16);\n\n\t\t\tbus->i2c_nostop = (size > 16) ? 1 : 0;\n\t\t\tbus->i2c_reserve = (loop == 0) ? 0 : 1;\n\n\t\t\t \n\t\t\tstatus = dev->cx231xx_send_usb_command(bus, &req_data);\n\t\t\tloop++;\n\n\t\t\tif (size >= 16)\n\t\t\t\tsize -= 16;\n\t\t\telse\n\t\t\t\tsize = 0;\n\n\t\t} while (size > 0);\n\n\t\tbus->i2c_nostop = 0;\n\t\tbus->i2c_reserve = 0;\n\n\t} else {\t\t \n\n\t\t \n\t\treq_data.dev_addr = msg->addr;\n\t\treq_data.direction = msg->flags;\n\t\treq_data.saddr_len = 0;\n\t\treq_data.saddr_dat = 0;\n\t\treq_data.buf_size = msg->len;\n\t\treq_data.p_buffer = msg->buf;\n\n\t\t \n\t\tstatus = dev->cx231xx_send_usb_command(bus, &req_data);\n\t}\n\n\treturn status < 0 ? status : 0;\n}\n\n \nstatic int cx231xx_i2c_recv_bytes(struct i2c_adapter *i2c_adap,\n\t\t\t\t  const struct i2c_msg *msg)\n{\n\tstruct cx231xx_i2c *bus = i2c_adap->algo_data;\n\tstruct cx231xx *dev = bus->dev;\n\tstruct cx231xx_i2c_xfer_data req_data;\n\tint status = 0;\n\tu16 saddr = 0;\n\tu8 need_gpio = 0;\n\n\tif (is_tuner(dev, bus, msg, TUNER_XC5000)) {\n\t\tif (msg->len == 2)\n\t\t\tsaddr = msg->buf[0] << 8 | msg->buf[1];\n\t\telse if (msg->len == 1)\n\t\t\tsaddr = msg->buf[0];\n\n\t\tif (dev->xc_fw_load_done) {\n\n\t\t\tswitch (saddr) {\n\t\t\tcase 0x0009:\t \n\t\t\t\tdprintk1(1,\n\t\t\t\t\"GPIO R E A D: Special case BUSY check \\n\");\n\t\t\t\t \n\t\t\t\tmsg->buf[0] = 0;\n\t\t\t\tif (msg->len == 2)\n\t\t\t\t\tmsg->buf[1] = 0;\n\t\t\t\treturn 0;\n\t\t\tcase 0x0004:\t \n\t\t\t\tneed_gpio = 1;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (need_gpio) {\n\t\t\t\t \n\n\t\t\t\tdprintk1(1,\n\t\t\t\t\"GPIO R E A D: addr 0x%x, len %d, saddr 0x%x\\n\",\n\t\t\t\tmsg->addr, msg->len,\n\t\t\t\tmsg->buf[0] << 8 | msg->buf[1]);\n\n\t\t\t\tstatus =\n\t\t\t\t    dev->cx231xx_gpio_i2c_write(dev, msg->addr,\n\t\t\t\t\t\t\t\tmsg->buf,\n\t\t\t\t\t\t\t\tmsg->len);\n\t\t\t\tstatus =\n\t\t\t\t    dev->cx231xx_gpio_i2c_read(dev, msg->addr,\n\t\t\t\t\t\t\t       msg->buf,\n\t\t\t\t\t\t\t       msg->len);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\treq_data.dev_addr = msg->addr;\n\t\treq_data.direction = msg->flags;\n\t\treq_data.saddr_len = msg->len;\n\t\treq_data.saddr_dat = msg->buf[0] << 8 | msg->buf[1];\n\t\treq_data.buf_size = msg->len;\n\t\treq_data.p_buffer = msg->buf;\n\n\t\t \n\t\tstatus = dev->cx231xx_send_usb_command(bus, &req_data);\n\n\t} else {\n\n\t\t \n\t\treq_data.dev_addr = msg->addr;\n\t\treq_data.direction = msg->flags;\n\t\treq_data.saddr_len = 0;\n\t\treq_data.saddr_dat = 0;\n\t\treq_data.buf_size = msg->len;\n\t\treq_data.p_buffer = msg->buf;\n\n\t\t \n\t\tstatus = dev->cx231xx_send_usb_command(bus, &req_data);\n\t}\n\n\treturn status < 0 ? status : 0;\n}\n\n \nstatic int cx231xx_i2c_recv_bytes_with_saddr(struct i2c_adapter *i2c_adap,\n\t\t\t\t\t     const struct i2c_msg *msg1,\n\t\t\t\t\t     const struct i2c_msg *msg2)\n{\n\tstruct cx231xx_i2c *bus = i2c_adap->algo_data;\n\tstruct cx231xx *dev = bus->dev;\n\tstruct cx231xx_i2c_xfer_data req_data;\n\tint status = 0;\n\tu16 saddr = 0;\n\tu8 need_gpio = 0;\n\n\tif (msg1->len == 2)\n\t\tsaddr = msg1->buf[0] << 8 | msg1->buf[1];\n\telse if (msg1->len == 1)\n\t\tsaddr = msg1->buf[0];\n\n\tif (is_tuner(dev, bus, msg2, TUNER_XC5000)) {\n\t\tif ((msg2->len < 16)) {\n\n\t\t\tdprintk1(1,\n\t\t\t\"i2c_read: addr 0x%x, len %d, saddr 0x%x, len %d\\n\",\n\t\t\tmsg2->addr, msg2->len, saddr, msg1->len);\n\n\t\t\tswitch (saddr) {\n\t\t\tcase 0x0008:\t \n\t\t\t\tneed_gpio = 1;\n\t\t\t\tbreak;\n\t\t\tcase 0x0004:\t \n\t\t\t\tneed_gpio = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (need_gpio) {\n\t\t\t\tstatus =\n\t\t\t\t    dev->cx231xx_gpio_i2c_write(dev, msg1->addr,\n\t\t\t\t\t\t\t\tmsg1->buf,\n\t\t\t\t\t\t\t\tmsg1->len);\n\t\t\t\tstatus =\n\t\t\t\t    dev->cx231xx_gpio_i2c_read(dev, msg2->addr,\n\t\t\t\t\t\t\t       msg2->buf,\n\t\t\t\t\t\t\t       msg2->len);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\treq_data.dev_addr = msg2->addr;\n\treq_data.direction = msg2->flags;\n\treq_data.saddr_len = msg1->len;\n\treq_data.saddr_dat = saddr;\n\treq_data.buf_size = msg2->len;\n\treq_data.p_buffer = msg2->buf;\n\n\t \n\tstatus = dev->cx231xx_send_usb_command(bus, &req_data);\n\n\treturn status < 0 ? status : 0;\n}\n\n \nstatic int cx231xx_i2c_check_for_device(struct i2c_adapter *i2c_adap,\n\t\t\t\t\tconst struct i2c_msg *msg)\n{\n\tstruct cx231xx_i2c *bus = i2c_adap->algo_data;\n\tstruct cx231xx *dev = bus->dev;\n\tstruct cx231xx_i2c_xfer_data req_data;\n\tint status = 0;\n\tu8 buf[1];\n\n\t \n\treq_data.dev_addr = msg->addr;\n\treq_data.direction = I2C_M_RD;\n\treq_data.saddr_len = 0;\n\treq_data.saddr_dat = 0;\n\treq_data.buf_size = 1;\n\treq_data.p_buffer = buf;\n\n\t \n\tstatus = dev->cx231xx_send_usb_command(bus, &req_data);\n\n\treturn status < 0 ? status : 0;\n}\n\n \nstatic int cx231xx_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t    struct i2c_msg msgs[], int num)\n{\n\tstruct cx231xx_i2c *bus = i2c_adap->algo_data;\n\tstruct cx231xx *dev = bus->dev;\n\tint addr, rc, i, byte;\n\n\tmutex_lock(&dev->i2c_lock);\n\tfor (i = 0; i < num; i++) {\n\n\t\taddr = msgs[i].addr;\n\n\t\tdprintk2(2, \"%s %s addr=0x%x len=%d:\",\n\t\t\t (msgs[i].flags & I2C_M_RD) ? \"read\" : \"write\",\n\t\t\t i == num - 1 ? \"stop\" : \"nonstop\", addr, msgs[i].len);\n\t\tif (!msgs[i].len) {\n\t\t\t \n\t\t\trc = cx231xx_i2c_check_for_device(i2c_adap, &msgs[i]);\n\t\t\tif (rc < 0) {\n\t\t\t\tdprintk2(2, \" no device\\n\");\n\t\t\t\tmutex_unlock(&dev->i2c_lock);\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t} else if (msgs[i].flags & I2C_M_RD) {\n\t\t\t \n\t\t\trc = cx231xx_i2c_recv_bytes(i2c_adap, &msgs[i]);\n\t\t\tif (i2c_debug >= 2) {\n\t\t\t\tfor (byte = 0; byte < msgs[i].len; byte++)\n\t\t\t\t\tprintk(KERN_CONT \" %02x\", msgs[i].buf[byte]);\n\t\t\t}\n\t\t} else if (i + 1 < num && (msgs[i + 1].flags & I2C_M_RD) &&\n\t\t\t   msgs[i].addr == msgs[i + 1].addr\n\t\t\t   && (msgs[i].len <= 2) && (bus->nr < 3)) {\n\t\t\t \n\t\t\tif (i2c_debug >= 2) {\n\t\t\t\tfor (byte = 0; byte < msgs[i].len; byte++)\n\t\t\t\t\tprintk(KERN_CONT \" %02x\", msgs[i].buf[byte]);\n\t\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\t}\n\t\t\t \n\t\t\tdprintk2(2, \"plus %s %s addr=0x%x len=%d:\",\n\t\t\t\t(msgs[i+1].flags & I2C_M_RD) ? \"read\" : \"write\",\n\t\t\t\ti+1 == num - 1 ? \"stop\" : \"nonstop\", addr, msgs[i+1].len);\n\t\t\trc = cx231xx_i2c_recv_bytes_with_saddr(i2c_adap,\n\t\t\t\t\t\t\t       &msgs[i],\n\t\t\t\t\t\t\t       &msgs[i + 1]);\n\t\t\tif (i2c_debug >= 2) {\n\t\t\t\tfor (byte = 0; byte < msgs[i+1].len; byte++)\n\t\t\t\t\tprintk(KERN_CONT \" %02x\", msgs[i+1].buf[byte]);\n\t\t\t}\n\t\t\ti++;\n\t\t} else {\n\t\t\t \n\t\t\tif (i2c_debug >= 2) {\n\t\t\t\tfor (byte = 0; byte < msgs[i].len; byte++)\n\t\t\t\t\tprintk(KERN_CONT \" %02x\", msgs[i].buf[byte]);\n\t\t\t}\n\t\t\trc = cx231xx_i2c_send_bytes(i2c_adap, &msgs[i]);\n\t\t}\n\t\tif (rc < 0)\n\t\t\tgoto err;\n\t\tif (i2c_debug >= 2)\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\tmutex_unlock(&dev->i2c_lock);\n\treturn num;\nerr:\n\tdprintk2(2, \" ERROR: %i\\n\", rc);\n\tmutex_unlock(&dev->i2c_lock);\n\treturn rc;\n}\n\n \n\n \nstatic u32 functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_SMBUS_EMUL | I2C_FUNC_I2C;\n}\n\nstatic const struct i2c_algorithm cx231xx_algo = {\n\t.master_xfer = cx231xx_i2c_xfer,\n\t.functionality = functionality,\n};\n\nstatic const struct i2c_adapter cx231xx_adap_template = {\n\t.owner = THIS_MODULE,\n\t.name = \"cx231xx\",\n\t.algo = &cx231xx_algo,\n};\n\n \n\n \nstatic const char *i2c_devs[128] = {\n\t[0x20 >> 1] = \"demod\",\n\t[0x60 >> 1] = \"colibri\",\n\t[0x88 >> 1] = \"hammerhead\",\n\t[0x8e >> 1] = \"CIR\",\n\t[0x32 >> 1] = \"GeminiIII\",\n\t[0x02 >> 1] = \"Aquarius\",\n\t[0xa0 >> 1] = \"eeprom\",\n\t[0xc0 >> 1] = \"tuner\",\n\t[0xc2 >> 1] = \"tuner\",\n};\n\n \nvoid cx231xx_do_i2c_scan(struct cx231xx *dev, int i2c_port)\n{\n\tunsigned char buf;\n\tint i, rc;\n\tstruct i2c_adapter *adap;\n\tstruct i2c_msg msg = {\n\t\t.flags = I2C_M_RD,\n\t\t.len = 1,\n\t\t.buf = &buf,\n\t};\n\n\tif (!i2c_scan)\n\t\treturn;\n\n\t \n\tdev->i2c_scan_running = true;\n\tadap = cx231xx_get_i2c_adap(dev, i2c_port);\n\n\tfor (i = 0; i < 128; i++) {\n\t\tmsg.addr = i;\n\t\trc = i2c_transfer(adap, &msg, 1);\n\n\t\tif (rc < 0)\n\t\t\tcontinue;\n\t\tdev_info(dev->dev,\n\t\t\t \"i2c scan: found device @ port %d addr 0x%x  [%s]\\n\",\n\t\t\t i2c_port,\n\t\t\t i << 1,\n\t\t\t i2c_devs[i] ? i2c_devs[i] : \"???\");\n\t}\n\n\tdev->i2c_scan_running = false;\n}\n\n \nint cx231xx_i2c_register(struct cx231xx_i2c *bus)\n{\n\tstruct cx231xx *dev = bus->dev;\n\n\tif (!dev->cx231xx_send_usb_command)\n\t\treturn -EINVAL;\n\n\tbus->i2c_adap = cx231xx_adap_template;\n\tbus->i2c_adap.dev.parent = dev->dev;\n\n\tsnprintf(bus->i2c_adap.name, sizeof(bus->i2c_adap.name), \"%s-%d\", bus->dev->name, bus->nr);\n\n\tbus->i2c_adap.algo_data = bus;\n\ti2c_set_adapdata(&bus->i2c_adap, &dev->v4l2_dev);\n\tbus->i2c_rc = i2c_add_adapter(&bus->i2c_adap);\n\n\tif (0 != bus->i2c_rc)\n\t\tdev_warn(dev->dev,\n\t\t\t \"i2c bus %d register FAILED\\n\", bus->nr);\n\n\treturn bus->i2c_rc;\n}\n\n \nvoid cx231xx_i2c_unregister(struct cx231xx_i2c *bus)\n{\n\tif (!bus->i2c_rc)\n\t\ti2c_del_adapter(&bus->i2c_adap);\n}\n\n \nstatic int cx231xx_i2c_mux_select(struct i2c_mux_core *muxc, u32 chan_id)\n{\n\tstruct cx231xx *dev = i2c_mux_priv(muxc);\n\n\treturn cx231xx_enable_i2c_port_3(dev, chan_id);\n}\n\nint cx231xx_i2c_mux_create(struct cx231xx *dev)\n{\n\tdev->muxc = i2c_mux_alloc(&dev->i2c_bus[1].i2c_adap, dev->dev, 2, 0, 0,\n\t\t\t\t  cx231xx_i2c_mux_select, NULL);\n\tif (!dev->muxc)\n\t\treturn -ENOMEM;\n\tdev->muxc->priv = dev;\n\treturn 0;\n}\n\nint cx231xx_i2c_mux_register(struct cx231xx *dev, int mux_no)\n{\n\treturn i2c_mux_add_adapter(dev->muxc,\n\t\t\t\t   0,\n\t\t\t\t   mux_no  ,\n\t\t\t\t   0  );\n}\n\nvoid cx231xx_i2c_mux_unregister(struct cx231xx *dev)\n{\n\ti2c_mux_del_adapters(dev->muxc);\n}\n\nstruct i2c_adapter *cx231xx_get_i2c_adap(struct cx231xx *dev, int i2c_port)\n{\n\tswitch (i2c_port) {\n\tcase I2C_0:\n\t\treturn &dev->i2c_bus[0].i2c_adap;\n\tcase I2C_1:\n\t\treturn &dev->i2c_bus[1].i2c_adap;\n\tcase I2C_2:\n\t\treturn &dev->i2c_bus[2].i2c_adap;\n\tcase I2C_1_MUX_1:\n\t\treturn dev->muxc->adapter[0];\n\tcase I2C_1_MUX_3:\n\t\treturn dev->muxc->adapter[1];\n\tdefault:\n\t\tBUG();\n\t}\n}\nEXPORT_SYMBOL_GPL(cx231xx_get_i2c_adap);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}