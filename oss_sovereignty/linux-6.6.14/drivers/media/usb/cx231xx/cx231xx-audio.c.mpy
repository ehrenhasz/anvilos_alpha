{
  "module_name": "cx231xx-audio.c",
  "hash_id": "6f99c3051dfc1bfa4fddfd9880d0742963e639aad63196a3dbe1b8867f70cf10",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/usb/cx231xx/cx231xx-audio.c",
  "human_readable_source": "\n \n\n#include \"cx231xx.h\"\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sound.h>\n#include <linux/spinlock.h>\n#include <linux/soundcard.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/info.h>\n#include <sound/initval.h>\n#include <sound/control.h>\n#include <media/v4l2-common.h>\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"activates debug info\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\n\nstatic int cx231xx_isoc_audio_deinit(struct cx231xx *dev)\n{\n\tint i;\n\n\tdev_dbg(dev->dev, \"Stopping isoc\\n\");\n\n\tfor (i = 0; i < CX231XX_AUDIO_BUFS; i++) {\n\t\tif (dev->adev.urb[i]) {\n\t\t\tif (!irqs_disabled())\n\t\t\t\tusb_kill_urb(dev->adev.urb[i]);\n\t\t\telse\n\t\t\t\tusb_unlink_urb(dev->adev.urb[i]);\n\n\t\t\tusb_free_urb(dev->adev.urb[i]);\n\t\t\tdev->adev.urb[i] = NULL;\n\n\t\t\tkfree(dev->adev.transfer_buffer[i]);\n\t\t\tdev->adev.transfer_buffer[i] = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cx231xx_bulk_audio_deinit(struct cx231xx *dev)\n{\n\tint i;\n\n\tdev_dbg(dev->dev, \"Stopping bulk\\n\");\n\n\tfor (i = 0; i < CX231XX_AUDIO_BUFS; i++) {\n\t\tif (dev->adev.urb[i]) {\n\t\t\tif (!irqs_disabled())\n\t\t\t\tusb_kill_urb(dev->adev.urb[i]);\n\t\t\telse\n\t\t\t\tusb_unlink_urb(dev->adev.urb[i]);\n\n\t\t\tusb_free_urb(dev->adev.urb[i]);\n\t\t\tdev->adev.urb[i] = NULL;\n\n\t\t\tkfree(dev->adev.transfer_buffer[i]);\n\t\t\tdev->adev.transfer_buffer[i] = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void cx231xx_audio_isocirq(struct urb *urb)\n{\n\tstruct cx231xx *dev = urb->context;\n\tint i;\n\tunsigned int oldptr;\n\tint period_elapsed = 0;\n\tint status;\n\tunsigned char *cp;\n\tunsigned int stride;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\n\tif (dev->state & DEV_DISCONNECTED)\n\t\treturn;\n\n\tswitch (urb->status) {\n\tcase 0:\t\t \n\tcase -ETIMEDOUT:\t \n\t\tbreak;\n\tcase -ECONNRESET:\t \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:\t\t \n\t\tdev_dbg(dev->dev, \"urb completion error %d.\\n\",\n\t\t\turb->status);\n\t\tbreak;\n\t}\n\n\tif (atomic_read(&dev->stream_started) == 0)\n\t\treturn;\n\n\tif (dev->adev.capture_pcm_substream) {\n\t\tsubstream = dev->adev.capture_pcm_substream;\n\t\truntime = substream->runtime;\n\t\tstride = runtime->frame_bits >> 3;\n\n\t\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\t\tunsigned long flags;\n\t\t\tint length = urb->iso_frame_desc[i].actual_length /\n\t\t\t\t     stride;\n\t\t\tcp = (unsigned char *)urb->transfer_buffer +\n\t\t\t\t\t      urb->iso_frame_desc[i].offset;\n\n\t\t\tif (!length)\n\t\t\t\tcontinue;\n\n\t\t\toldptr = dev->adev.hwptr_done_capture;\n\t\t\tif (oldptr + length >= runtime->buffer_size) {\n\t\t\t\tunsigned int cnt;\n\n\t\t\t\tcnt = runtime->buffer_size - oldptr;\n\t\t\t\tmemcpy(runtime->dma_area + oldptr * stride, cp,\n\t\t\t\t       cnt * stride);\n\t\t\t\tmemcpy(runtime->dma_area, cp + cnt * stride,\n\t\t\t\t       length * stride - cnt * stride);\n\t\t\t} else {\n\t\t\t\tmemcpy(runtime->dma_area + oldptr * stride, cp,\n\t\t\t\t       length * stride);\n\t\t\t}\n\n\t\t\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\n\t\t\tdev->adev.hwptr_done_capture += length;\n\t\t\tif (dev->adev.hwptr_done_capture >=\n\t\t\t\t\t\truntime->buffer_size)\n\t\t\t\tdev->adev.hwptr_done_capture -=\n\t\t\t\t\t\truntime->buffer_size;\n\n\t\t\tdev->adev.capture_transfer_done += length;\n\t\t\tif (dev->adev.capture_transfer_done >=\n\t\t\t\truntime->period_size) {\n\t\t\t\tdev->adev.capture_transfer_done -=\n\t\t\t\t\t\truntime->period_size;\n\t\t\t\tperiod_elapsed = 1;\n\t\t\t}\n\t\t\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\t\t}\n\t\tif (period_elapsed)\n\t\t\tsnd_pcm_period_elapsed(substream);\n\t}\n\turb->status = 0;\n\n\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (status < 0) {\n\t\tdev_err(dev->dev,\n\t\t\t\"resubmit of audio urb failed (error=%i)\\n\",\n\t\t\tstatus);\n\t}\n\treturn;\n}\n\nstatic void cx231xx_audio_bulkirq(struct urb *urb)\n{\n\tstruct cx231xx *dev = urb->context;\n\tunsigned int oldptr;\n\tint period_elapsed = 0;\n\tint status;\n\tunsigned char *cp;\n\tunsigned int stride;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\n\tif (dev->state & DEV_DISCONNECTED)\n\t\treturn;\n\n\tswitch (urb->status) {\n\tcase 0:\t\t \n\tcase -ETIMEDOUT:\t \n\t\tbreak;\n\tcase -ECONNRESET:\t \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:\t\t \n\t\tdev_dbg(dev->dev, \"urb completion error %d.\\n\",\n\t\t\turb->status);\n\t\tbreak;\n\t}\n\n\tif (atomic_read(&dev->stream_started) == 0)\n\t\treturn;\n\n\tif (dev->adev.capture_pcm_substream) {\n\t\tsubstream = dev->adev.capture_pcm_substream;\n\t\truntime = substream->runtime;\n\t\tstride = runtime->frame_bits >> 3;\n\n\t\tif (1) {\n\t\t\tunsigned long flags;\n\t\t\tint length = urb->actual_length /\n\t\t\t\t     stride;\n\t\t\tcp = (unsigned char *)urb->transfer_buffer;\n\n\t\t\toldptr = dev->adev.hwptr_done_capture;\n\t\t\tif (oldptr + length >= runtime->buffer_size) {\n\t\t\t\tunsigned int cnt;\n\n\t\t\t\tcnt = runtime->buffer_size - oldptr;\n\t\t\t\tmemcpy(runtime->dma_area + oldptr * stride, cp,\n\t\t\t\t       cnt * stride);\n\t\t\t\tmemcpy(runtime->dma_area, cp + cnt * stride,\n\t\t\t\t       length * stride - cnt * stride);\n\t\t\t} else {\n\t\t\t\tmemcpy(runtime->dma_area + oldptr * stride, cp,\n\t\t\t\t       length * stride);\n\t\t\t}\n\n\t\t\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\n\t\t\tdev->adev.hwptr_done_capture += length;\n\t\t\tif (dev->adev.hwptr_done_capture >=\n\t\t\t\t\t\truntime->buffer_size)\n\t\t\t\tdev->adev.hwptr_done_capture -=\n\t\t\t\t\t\truntime->buffer_size;\n\n\t\t\tdev->adev.capture_transfer_done += length;\n\t\t\tif (dev->adev.capture_transfer_done >=\n\t\t\t\truntime->period_size) {\n\t\t\t\tdev->adev.capture_transfer_done -=\n\t\t\t\t\t\truntime->period_size;\n\t\t\t\tperiod_elapsed = 1;\n\t\t\t}\n\t\t\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\t\t}\n\t\tif (period_elapsed)\n\t\t\tsnd_pcm_period_elapsed(substream);\n\t}\n\turb->status = 0;\n\n\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (status < 0) {\n\t\tdev_err(dev->dev,\n\t\t\t\"resubmit of audio urb failed (error=%i)\\n\",\n\t\t\tstatus);\n\t}\n\treturn;\n}\n\nstatic int cx231xx_init_audio_isoc(struct cx231xx *dev)\n{\n\tint i, errCode;\n\tint sb_size;\n\n\tdev_dbg(dev->dev,\n\t\t\"%s: Starting ISO AUDIO transfers\\n\", __func__);\n\n\tif (dev->state & DEV_DISCONNECTED)\n\t\treturn -ENODEV;\n\n\tsb_size = CX231XX_ISO_NUM_AUDIO_PACKETS * dev->adev.max_pkt_size;\n\n\tfor (i = 0; i < CX231XX_AUDIO_BUFS; i++) {\n\t\tstruct urb *urb;\n\t\tint j, k;\n\n\t\tdev->adev.transfer_buffer[i] = kmalloc(sb_size, GFP_ATOMIC);\n\t\tif (!dev->adev.transfer_buffer[i])\n\t\t\treturn -ENOMEM;\n\n\t\tmemset(dev->adev.transfer_buffer[i], 0x80, sb_size);\n\t\turb = usb_alloc_urb(CX231XX_ISO_NUM_AUDIO_PACKETS, GFP_ATOMIC);\n\t\tif (!urb) {\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tusb_free_urb(dev->adev.urb[j]);\n\t\t\t\tkfree(dev->adev.transfer_buffer[j]);\n\t\t\t}\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\turb->dev = dev->udev;\n\t\turb->context = dev;\n\t\turb->pipe = usb_rcvisocpipe(dev->udev,\n\t\t\t\t\t\tdev->adev.end_point_addr);\n\t\turb->transfer_flags = URB_ISO_ASAP;\n\t\turb->transfer_buffer = dev->adev.transfer_buffer[i];\n\t\turb->interval = 1;\n\t\turb->complete = cx231xx_audio_isocirq;\n\t\turb->number_of_packets = CX231XX_ISO_NUM_AUDIO_PACKETS;\n\t\turb->transfer_buffer_length = sb_size;\n\n\t\tfor (j = k = 0; j < CX231XX_ISO_NUM_AUDIO_PACKETS;\n\t\t\tj++, k += dev->adev.max_pkt_size) {\n\t\t\turb->iso_frame_desc[j].offset = k;\n\t\t\turb->iso_frame_desc[j].length = dev->adev.max_pkt_size;\n\t\t}\n\t\tdev->adev.urb[i] = urb;\n\t}\n\n\tfor (i = 0; i < CX231XX_AUDIO_BUFS; i++) {\n\t\terrCode = usb_submit_urb(dev->adev.urb[i], GFP_ATOMIC);\n\t\tif (errCode < 0) {\n\t\t\tcx231xx_isoc_audio_deinit(dev);\n\t\t\treturn errCode;\n\t\t}\n\t}\n\n\treturn errCode;\n}\n\nstatic int cx231xx_init_audio_bulk(struct cx231xx *dev)\n{\n\tint i, errCode;\n\tint sb_size;\n\n\tdev_dbg(dev->dev,\n\t\t\"%s: Starting BULK AUDIO transfers\\n\", __func__);\n\n\tif (dev->state & DEV_DISCONNECTED)\n\t\treturn -ENODEV;\n\n\tsb_size = CX231XX_NUM_AUDIO_PACKETS * dev->adev.max_pkt_size;\n\n\tfor (i = 0; i < CX231XX_AUDIO_BUFS; i++) {\n\t\tstruct urb *urb;\n\t\tint j;\n\n\t\tdev->adev.transfer_buffer[i] = kmalloc(sb_size, GFP_ATOMIC);\n\t\tif (!dev->adev.transfer_buffer[i])\n\t\t\treturn -ENOMEM;\n\n\t\tmemset(dev->adev.transfer_buffer[i], 0x80, sb_size);\n\t\turb = usb_alloc_urb(CX231XX_NUM_AUDIO_PACKETS, GFP_ATOMIC);\n\t\tif (!urb) {\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tusb_free_urb(dev->adev.urb[j]);\n\t\t\t\tkfree(dev->adev.transfer_buffer[j]);\n\t\t\t}\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\turb->dev = dev->udev;\n\t\turb->context = dev;\n\t\turb->pipe = usb_rcvbulkpipe(dev->udev,\n\t\t\t\t\t\tdev->adev.end_point_addr);\n\t\turb->transfer_flags = 0;\n\t\turb->transfer_buffer = dev->adev.transfer_buffer[i];\n\t\turb->complete = cx231xx_audio_bulkirq;\n\t\turb->transfer_buffer_length = sb_size;\n\n\t\tdev->adev.urb[i] = urb;\n\n\t}\n\n\tfor (i = 0; i < CX231XX_AUDIO_BUFS; i++) {\n\t\terrCode = usb_submit_urb(dev->adev.urb[i], GFP_ATOMIC);\n\t\tif (errCode < 0) {\n\t\t\tcx231xx_bulk_audio_deinit(dev);\n\t\t\treturn errCode;\n\t\t}\n\t}\n\n\treturn errCode;\n}\n\nstatic const struct snd_pcm_hardware snd_cx231xx_hw_capture = {\n\t.info = SNDRV_PCM_INFO_BLOCK_TRANSFER\t|\n\t    SNDRV_PCM_INFO_MMAP\t\t\t|\n\t    SNDRV_PCM_INFO_INTERLEAVED\t\t|\n\t    SNDRV_PCM_INFO_MMAP_VALID,\n\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\n\t.rates = SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_KNOT,\n\n\t.rate_min = 48000,\n\t.rate_max = 48000,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.buffer_bytes_max = 62720 * 8,\t \n\t.period_bytes_min = 64,\t\t \n\t.period_bytes_max = 12544,\n\t.periods_min = 2,\n\t.periods_max = 98,\t\t \n};\n\nstatic int snd_cx231xx_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct cx231xx *dev = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint ret = 0;\n\n\tdev_dbg(dev->dev,\n\t\t\"opening device and trying to acquire exclusive lock\\n\");\n\n\tif (dev->state & DEV_DISCONNECTED) {\n\t\tdev_err(dev->dev,\n\t\t\t\"Can't open. the device was removed.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\t \n\tmutex_lock(&dev->lock);\n\tif (dev->USE_ISO)\n\t\tret = cx231xx_set_alt_setting(dev, INDEX_AUDIO, 1);\n\telse\n\t\tret = cx231xx_set_alt_setting(dev, INDEX_AUDIO, 0);\n\tmutex_unlock(&dev->lock);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev,\n\t\t\t\"failed to set alternate setting !\\n\");\n\n\t\treturn ret;\n\t}\n\n\truntime->hw = snd_cx231xx_hw_capture;\n\n\tmutex_lock(&dev->lock);\n\t \n\tret = cx231xx_capture_start(dev, 1, Audio);\n\n\tdev->adev.users++;\n\tmutex_unlock(&dev->lock);\n\n\tsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tdev->adev.capture_pcm_substream = substream;\n\truntime->private_data = dev;\n\n\treturn 0;\n}\n\nstatic int snd_cx231xx_pcm_close(struct snd_pcm_substream *substream)\n{\n\tint ret;\n\tstruct cx231xx *dev = snd_pcm_substream_chip(substream);\n\n\tdev_dbg(dev->dev, \"closing device\\n\");\n\n\t \n\tmutex_lock(&dev->lock);\n\tret = cx231xx_capture_start(dev, 0, Audio);\n\n\t \n\t \n\tret = cx231xx_set_alt_setting(dev, INDEX_AUDIO, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev,\n\t\t\t\"failed to set alternate setting !\\n\");\n\n\t\tmutex_unlock(&dev->lock);\n\t\treturn ret;\n\t}\n\n\tdev->adev.users--;\n\tmutex_unlock(&dev->lock);\n\n\tif (dev->adev.users == 0 && dev->adev.shutdown == 1) {\n\t\tdev_dbg(dev->dev, \"audio users: %d\\n\", dev->adev.users);\n\t\tdev_dbg(dev->dev, \"disabling audio stream!\\n\");\n\t\tdev->adev.shutdown = 0;\n\t\tdev_dbg(dev->dev, \"released lock\\n\");\n\t\tif (atomic_read(&dev->stream_started) > 0) {\n\t\t\tatomic_set(&dev->stream_started, 0);\n\t\t\tschedule_work(&dev->wq_trigger);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int snd_cx231xx_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct cx231xx *dev = snd_pcm_substream_chip(substream);\n\n\tdev->adev.hwptr_done_capture = 0;\n\tdev->adev.capture_transfer_done = 0;\n\n\treturn 0;\n}\n\nstatic void audio_trigger(struct work_struct *work)\n{\n\tstruct cx231xx *dev = container_of(work, struct cx231xx, wq_trigger);\n\n\tif (atomic_read(&dev->stream_started)) {\n\t\tdev_dbg(dev->dev, \"starting capture\");\n\t\tif (is_fw_load(dev) == 0)\n\t\t\tcx25840_call(dev, core, load_fw);\n\t\tif (dev->USE_ISO)\n\t\t\tcx231xx_init_audio_isoc(dev);\n\t\telse\n\t\t\tcx231xx_init_audio_bulk(dev);\n\t} else {\n\t\tdev_dbg(dev->dev, \"stopping capture\");\n\t\tcx231xx_isoc_audio_deinit(dev);\n\t}\n}\n\nstatic int snd_cx231xx_capture_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t       int cmd)\n{\n\tstruct cx231xx *dev = snd_pcm_substream_chip(substream);\n\tint retval = 0;\n\n\tif (dev->state & DEV_DISCONNECTED)\n\t\treturn -ENODEV;\n\n\tspin_lock(&dev->adev.slock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tatomic_set(&dev->stream_started, 1);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tatomic_set(&dev->stream_started, 0);\n\t\tbreak;\n\tdefault:\n\t\tretval = -EINVAL;\n\t\tbreak;\n\t}\n\tspin_unlock(&dev->adev.slock);\n\n\tschedule_work(&dev->wq_trigger);\n\n\treturn retval;\n}\n\nstatic snd_pcm_uframes_t snd_cx231xx_capture_pointer(struct snd_pcm_substream\n\t\t\t\t\t\t     *substream)\n{\n\tstruct cx231xx *dev;\n\tunsigned long flags;\n\tsnd_pcm_uframes_t hwptr_done;\n\n\tdev = snd_pcm_substream_chip(substream);\n\n\tspin_lock_irqsave(&dev->adev.slock, flags);\n\thwptr_done = dev->adev.hwptr_done_capture;\n\tspin_unlock_irqrestore(&dev->adev.slock, flags);\n\n\treturn hwptr_done;\n}\n\nstatic const struct snd_pcm_ops snd_cx231xx_pcm_capture = {\n\t.open = snd_cx231xx_capture_open,\n\t.close = snd_cx231xx_pcm_close,\n\t.prepare = snd_cx231xx_prepare,\n\t.trigger = snd_cx231xx_capture_trigger,\n\t.pointer = snd_cx231xx_capture_pointer,\n};\n\nstatic int cx231xx_audio_init(struct cx231xx *dev)\n{\n\tstruct cx231xx_audio *adev = &dev->adev;\n\tstruct snd_pcm *pcm;\n\tstruct snd_card *card;\n\tstatic int devnr;\n\tint err;\n\tstruct usb_interface *uif;\n\tint i, isoc_pipe = 0;\n\n\tif (dev->has_alsa_audio != 1) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tdev_dbg(dev->dev,\n\t\t\"probing for cx231xx non standard usbaudio\\n\");\n\n\terr = snd_card_new(dev->dev, index[devnr], \"Cx231xx Audio\",\n\t\t\t   THIS_MODULE, 0, &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tspin_lock_init(&adev->slock);\n\terr = snd_pcm_new(card, \"Cx231xx Audio\", 0, 0, 1, &pcm);\n\tif (err < 0)\n\t\tgoto err_free_card;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&snd_cx231xx_pcm_capture);\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC, NULL, 0, 0);\n\tpcm->info_flags = 0;\n\tpcm->private_data = dev;\n\tstrscpy(pcm->name, \"Conexant cx231xx Capture\", sizeof(pcm->name));\n\tstrscpy(card->driver, \"Cx231xx-Audio\", sizeof(card->driver));\n\tstrscpy(card->shortname, \"Cx231xx Audio\", sizeof(card->shortname));\n\tstrscpy(card->longname, \"Conexant cx231xx Audio\", sizeof(card->longname));\n\n\tINIT_WORK(&dev->wq_trigger, audio_trigger);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto err_free_card;\n\n\tadev->sndcard = card;\n\tadev->udev = dev->udev;\n\n\t \n\tuif =\n\t    dev->udev->actconfig->interface[dev->current_pcb_config.\n\t\t\t\t\t    hs_config_info[0].interface_info.\n\t\t\t\t\t    audio_index + 1];\n\n\tif (uif->altsetting[0].desc.bNumEndpoints < isoc_pipe + 1) {\n\t\terr = -ENODEV;\n\t\tgoto err_free_card;\n\t}\n\n\tadev->end_point_addr =\n\t    uif->altsetting[0].endpoint[isoc_pipe].desc.\n\t\t\tbEndpointAddress;\n\n\tadev->num_alt = uif->num_altsetting;\n\tdev_info(dev->dev,\n\t\t\"audio EndPoint Addr 0x%x, Alternate settings: %i\\n\",\n\t\tadev->end_point_addr, adev->num_alt);\n\tadev->alt_max_pkt_size = kmalloc_array(32, adev->num_alt, GFP_KERNEL);\n\tif (!adev->alt_max_pkt_size) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_card;\n\t}\n\n\tfor (i = 0; i < adev->num_alt; i++) {\n\t\tu16 tmp;\n\n\t\tif (uif->altsetting[i].desc.bNumEndpoints < isoc_pipe + 1) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto err_free_pkt_size;\n\t\t}\n\n\t\ttmp = le16_to_cpu(uif->altsetting[i].endpoint[isoc_pipe].desc.\n\t\t\t\twMaxPacketSize);\n\t\tadev->alt_max_pkt_size[i] =\n\t\t    (tmp & 0x07ff) * (((tmp & 0x1800) >> 11) + 1);\n\t\tdev_dbg(dev->dev,\n\t\t\t\"audio alternate setting %i, max size= %i\\n\", i,\n\t\t\tadev->alt_max_pkt_size[i]);\n\t}\n\n\treturn 0;\n\nerr_free_pkt_size:\n\tkfree(adev->alt_max_pkt_size);\nerr_free_card:\n\tsnd_card_free(card);\n\n\treturn err;\n}\n\nstatic int cx231xx_audio_fini(struct cx231xx *dev)\n{\n\tif (dev == NULL)\n\t\treturn 0;\n\n\tif (dev->has_alsa_audio != 1) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (dev->adev.sndcard) {\n\t\tsnd_card_free_when_closed(dev->adev.sndcard);\n\t\tkfree(dev->adev.alt_max_pkt_size);\n\t\tdev->adev.sndcard = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct cx231xx_ops audio_ops = {\n\t.id = CX231XX_AUDIO,\n\t.name = \"Cx231xx Audio Extension\",\n\t.init = cx231xx_audio_init,\n\t.fini = cx231xx_audio_fini,\n};\n\nstatic int __init cx231xx_alsa_register(void)\n{\n\treturn cx231xx_register_extension(&audio_ops);\n}\n\nstatic void __exit cx231xx_alsa_unregister(void)\n{\n\tcx231xx_unregister_extension(&audio_ops);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Srinivasa Deevi <srinivasa.deevi@conexant.com>\");\nMODULE_DESCRIPTION(\"Cx231xx Audio driver\");\n\nmodule_init(cx231xx_alsa_register);\nmodule_exit(cx231xx_alsa_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}