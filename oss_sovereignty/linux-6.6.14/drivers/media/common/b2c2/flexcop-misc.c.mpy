{
  "module_name": "flexcop-misc.c",
  "hash_id": "033cb0933508e4d76f90562899237336c1dfda1de585285bbab80a5847176241",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/b2c2/flexcop-misc.c",
  "human_readable_source": "\n \n#include \"flexcop.h\"\n\nvoid flexcop_determine_revision(struct flexcop_device *fc)\n{\n\tflexcop_ibi_value v = fc->read_ibi_reg(fc,misc_204);\n\n\tswitch (v.misc_204.Rev_N_sig_revision_hi) {\n\tcase 0x2:\n\t\tdeb_info(\"found a FlexCopII.\\n\");\n\t\tfc->rev = FLEXCOP_II;\n\t\tbreak;\n\tcase 0x3:\n\t\tdeb_info(\"found a FlexCopIIb.\\n\");\n\t\tfc->rev = FLEXCOP_IIB;\n\t\tbreak;\n\tcase 0x0:\n\t\tdeb_info(\"found a FlexCopIII.\\n\");\n\t\tfc->rev = FLEXCOP_III;\n\t\tbreak;\n\tdefault:\n\t\terr(\"unknown FlexCop Revision: %x. Please report this to linux-dvb@linuxtv.org.\",\n\t\t\t\tv.misc_204.Rev_N_sig_revision_hi);\n\t\tbreak;\n\t}\n\n\tif ((fc->has_32_hw_pid_filter = v.misc_204.Rev_N_sig_caps))\n\t\tdeb_info(\"this FlexCop has the additional 32 hardware pid filter.\\n\");\n\telse\n\t\tdeb_info(\"this FlexCop has the 6 basic main hardware pid filter.\\n\");\n\t \n}\n\nstatic const char *flexcop_revision_names[] = {\n\t\"Unknown chip\",\n\t\"FlexCopII\",\n\t\"FlexCopIIb\",\n\t\"FlexCopIII\",\n};\n\nstatic const char *flexcop_device_names[] = {\n\t[FC_UNK]\t= \"Unknown device\",\n\t[FC_CABLE]\t= \"Cable2PC/CableStar 2 DVB-C\",\n\t[FC_AIR_DVBT]\t= \"Air2PC/AirStar 2 DVB-T\",\n\t[FC_AIR_ATSC1]\t= \"Air2PC/AirStar 2 ATSC 1st generation\",\n\t[FC_AIR_ATSC2]\t= \"Air2PC/AirStar 2 ATSC 2nd generation\",\n\t[FC_AIR_ATSC3]\t= \"Air2PC/AirStar 2 ATSC 3rd generation (HD5000)\",\n\t[FC_SKY_REV23]\t= \"Sky2PC/SkyStar 2 DVB-S rev 2.3 (old version)\",\n\t[FC_SKY_REV26]\t= \"Sky2PC/SkyStar 2 DVB-S rev 2.6\",\n\t[FC_SKY_REV27]\t= \"Sky2PC/SkyStar 2 DVB-S rev 2.7a/u\",\n\t[FC_SKY_REV28]\t= \"Sky2PC/SkyStar 2 DVB-S rev 2.8\",\n\t[FC_SKYS2_REV33] = \"Sky2PC/SkyStar S2 DVB-S/S2 rev 3.3\",\n};\n\nstatic const char *flexcop_bus_names[] = {\n\t\"USB\",\n\t\"PCI\",\n};\n\nvoid flexcop_device_name(struct flexcop_device *fc,\n\t\tconst char *prefix, const char *suffix)\n{\n\tinfo(\"%s '%s' at the '%s' bus controlled by a '%s' %s\",\n\t\t\tprefix,\tflexcop_device_names[fc->dev_type],\n\t\t\tflexcop_bus_names[fc->bus_type],\n\t\t\tflexcop_revision_names[fc->rev], suffix);\n}\n\nvoid flexcop_dump_reg(struct flexcop_device *fc,\n\t\tflexcop_ibi_register reg, int num)\n{\n\tflexcop_ibi_value v;\n\tint i;\n\tfor (i = 0; i < num; i++) {\n\t\tv = fc->read_ibi_reg(fc, reg+4*i);\n\t\tdeb_rdump(\"0x%03x: %08x, \", reg+4*i, v.raw);\n\t}\n\tdeb_rdump(\"\\n\");\n}\nEXPORT_SYMBOL(flexcop_dump_reg);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}