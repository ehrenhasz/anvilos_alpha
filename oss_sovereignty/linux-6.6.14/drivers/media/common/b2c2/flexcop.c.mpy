{
  "module_name": "flexcop.c",
  "hash_id": "45cb5099ffe35df29d2095b73c328b93994603c385772a33693e5a0c08d03ed4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/b2c2/flexcop.c",
  "human_readable_source": "\n \n\n#include \"flexcop.h\"\n\n#define DRIVER_NAME \"B2C2 FlexcopII/II(b)/III digital TV receiver chip\"\n#define DRIVER_AUTHOR \"Patrick Boettcher <patrick.boettcher@posteo.de\"\n\n#ifdef CONFIG_DVB_B2C2_FLEXCOP_DEBUG\n#define DEBSTATUS \"\"\n#else\n#define DEBSTATUS \" (debugging is not enabled)\"\n#endif\n\nint b2c2_flexcop_debug;\nEXPORT_SYMBOL_GPL(b2c2_flexcop_debug);\nmodule_param_named(debug, b2c2_flexcop_debug,  int, 0644);\nMODULE_PARM_DESC(debug,\n\t\t\"set debug level (1=info,2=tuner,4=i2c,8=ts,16=sram,32=reg,64=i2cdump (|-able)).\"\n\t\tDEBSTATUS);\n#undef DEBSTATUS\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n \nflexcop_ibi_value ibi_zero;\n\nstatic int flexcop_dvb_start_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct flexcop_device *fc = dvbdmxfeed->demux->priv;\n\treturn flexcop_pid_feed_control(fc, dvbdmxfeed, 1);\n}\n\nstatic int flexcop_dvb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct flexcop_device *fc = dvbdmxfeed->demux->priv;\n\treturn flexcop_pid_feed_control(fc, dvbdmxfeed, 0);\n}\n\nstatic int flexcop_dvb_init(struct flexcop_device *fc)\n{\n\tint ret = dvb_register_adapter(&fc->dvb_adapter,\n\t\t\t\"FlexCop Digital TV device\", fc->owner,\n\t\t\tfc->dev, adapter_nr);\n\tif (ret < 0) {\n\t\terr(\"error registering DVB adapter\");\n\t\treturn ret;\n\t}\n\tfc->dvb_adapter.priv = fc;\n\n\tfc->demux.dmx.capabilities = (DMX_TS_FILTERING | DMX_SECTION_FILTERING\n\t\t\t| DMX_MEMORY_BASED_FILTERING);\n\tfc->demux.priv = fc;\n\tfc->demux.filternum = fc->demux.feednum = FC_MAX_FEED;\n\tfc->demux.start_feed = flexcop_dvb_start_feed;\n\tfc->demux.stop_feed = flexcop_dvb_stop_feed;\n\tfc->demux.write_to_decoder = NULL;\n\n\tret = dvb_dmx_init(&fc->demux);\n\tif (ret < 0) {\n\t\terr(\"dvb_dmx failed: error %d\", ret);\n\t\tgoto err_dmx;\n\t}\n\n\tfc->hw_frontend.source = DMX_FRONTEND_0;\n\n\tfc->dmxdev.filternum = fc->demux.feednum;\n\tfc->dmxdev.demux = &fc->demux.dmx;\n\tfc->dmxdev.capabilities = 0;\n\tret = dvb_dmxdev_init(&fc->dmxdev, &fc->dvb_adapter);\n\tif (ret < 0) {\n\t\terr(\"dvb_dmxdev_init failed: error %d\", ret);\n\t\tgoto err_dmx_dev;\n\t}\n\n\tret = fc->demux.dmx.add_frontend(&fc->demux.dmx, &fc->hw_frontend);\n\tif (ret < 0) {\n\t\terr(\"adding hw_frontend to dmx failed: error %d\", ret);\n\t\tgoto err_dmx_add_hw_frontend;\n\t}\n\n\tfc->mem_frontend.source = DMX_MEMORY_FE;\n\tret = fc->demux.dmx.add_frontend(&fc->demux.dmx, &fc->mem_frontend);\n\tif (ret < 0) {\n\t\terr(\"adding mem_frontend to dmx failed: error %d\", ret);\n\t\tgoto err_dmx_add_mem_frontend;\n\t}\n\n\tret = fc->demux.dmx.connect_frontend(&fc->demux.dmx, &fc->hw_frontend);\n\tif (ret < 0) {\n\t\terr(\"connect frontend failed: error %d\", ret);\n\t\tgoto err_connect_frontend;\n\t}\n\n\tret = dvb_net_init(&fc->dvb_adapter, &fc->dvbnet, &fc->demux.dmx);\n\tif (ret < 0) {\n\t\terr(\"dvb_net_init failed: error %d\", ret);\n\t\tgoto err_net;\n\t}\n\n\tfc->init_state |= FC_STATE_DVB_INIT;\n\treturn 0;\n\nerr_net:\n\tfc->demux.dmx.disconnect_frontend(&fc->demux.dmx);\nerr_connect_frontend:\n\tfc->demux.dmx.remove_frontend(&fc->demux.dmx, &fc->mem_frontend);\nerr_dmx_add_mem_frontend:\n\tfc->demux.dmx.remove_frontend(&fc->demux.dmx, &fc->hw_frontend);\nerr_dmx_add_hw_frontend:\n\tdvb_dmxdev_release(&fc->dmxdev);\nerr_dmx_dev:\n\tdvb_dmx_release(&fc->demux);\nerr_dmx:\n\tdvb_unregister_adapter(&fc->dvb_adapter);\n\treturn ret;\n}\n\nstatic void flexcop_dvb_exit(struct flexcop_device *fc)\n{\n\tif (fc->init_state & FC_STATE_DVB_INIT) {\n\t\tdvb_net_release(&fc->dvbnet);\n\n\t\tfc->demux.dmx.close(&fc->demux.dmx);\n\t\tfc->demux.dmx.remove_frontend(&fc->demux.dmx,\n\t\t\t&fc->mem_frontend);\n\t\tfc->demux.dmx.remove_frontend(&fc->demux.dmx,\n\t\t\t&fc->hw_frontend);\n\t\tdvb_dmxdev_release(&fc->dmxdev);\n\t\tdvb_dmx_release(&fc->demux);\n\t\tdvb_unregister_adapter(&fc->dvb_adapter);\n\t\tdeb_info(\"deinitialized dvb stuff\\n\");\n\t}\n\tfc->init_state &= ~FC_STATE_DVB_INIT;\n}\n\n \nvoid flexcop_pass_dmx_data(struct flexcop_device *fc, u8 *buf, u32 len)\n{\n\tdvb_dmx_swfilter(&fc->demux, buf, len);\n}\nEXPORT_SYMBOL(flexcop_pass_dmx_data);\n\nvoid flexcop_pass_dmx_packets(struct flexcop_device *fc, u8 *buf, u32 no)\n{\n\tdvb_dmx_swfilter_packets(&fc->demux, buf, no);\n}\nEXPORT_SYMBOL(flexcop_pass_dmx_packets);\n\nstatic void flexcop_reset(struct flexcop_device *fc)\n{\n\tflexcop_ibi_value v210, v204;\n\n\t \n\tfc->write_ibi_reg(fc,ctrl_208,ibi_zero);\n\n\tv210.raw = 0;\n\tv210.sw_reset_210.reset_block_000 = 1;\n\tv210.sw_reset_210.reset_block_100 = 1;\n\tv210.sw_reset_210.reset_block_200 = 1;\n\tv210.sw_reset_210.reset_block_300 = 1;\n\tv210.sw_reset_210.reset_block_400 = 1;\n\tv210.sw_reset_210.reset_block_500 = 1;\n\tv210.sw_reset_210.reset_block_600 = 1;\n\tv210.sw_reset_210.reset_block_700 = 1;\n\tv210.sw_reset_210.Block_reset_enable = 0xb2;\n\tv210.sw_reset_210.Special_controls = 0xc259;\n\tfc->write_ibi_reg(fc,sw_reset_210,v210);\n\tmsleep(1);\n\n\t \n\n\tv204 = fc->read_ibi_reg(fc,misc_204);\n\tv204.misc_204.Per_reset_sig = 0;\n\tfc->write_ibi_reg(fc,misc_204,v204);\n\tmsleep(1);\n\tv204.misc_204.Per_reset_sig = 1;\n\tfc->write_ibi_reg(fc,misc_204,v204);\n}\n\nvoid flexcop_reset_block_300(struct flexcop_device *fc)\n{\n\tflexcop_ibi_value v208_save = fc->read_ibi_reg(fc, ctrl_208),\n\t\t\t  v210 = fc->read_ibi_reg(fc, sw_reset_210);\n\n\tdeb_rdump(\"208: %08x, 210: %08x\\n\", v208_save.raw, v210.raw);\n\tfc->write_ibi_reg(fc,ctrl_208,ibi_zero);\n\n\tv210.sw_reset_210.reset_block_300 = 1;\n\tv210.sw_reset_210.Block_reset_enable = 0xb2;\n\n\tfc->write_ibi_reg(fc,sw_reset_210,v210);\n\tfc->write_ibi_reg(fc,ctrl_208,v208_save);\n}\n\nstruct flexcop_device *flexcop_device_kmalloc(size_t bus_specific_len)\n{\n\tvoid *bus;\n\tstruct flexcop_device *fc = kzalloc(sizeof(struct flexcop_device),\n\t\t\t\tGFP_KERNEL);\n\tif (!fc) {\n\t\terr(\"no memory\");\n\t\treturn NULL;\n\t}\n\n\tbus = kzalloc(bus_specific_len, GFP_KERNEL);\n\tif (!bus) {\n\t\terr(\"no memory\");\n\t\tkfree(fc);\n\t\treturn NULL;\n\t}\n\n\tfc->bus_specific = bus;\n\n\treturn fc;\n}\nEXPORT_SYMBOL(flexcop_device_kmalloc);\n\nvoid flexcop_device_kfree(struct flexcop_device *fc)\n{\n\tkfree(fc->bus_specific);\n\tkfree(fc);\n}\nEXPORT_SYMBOL(flexcop_device_kfree);\n\nint flexcop_device_initialize(struct flexcop_device *fc)\n{\n\tint ret;\n\tibi_zero.raw = 0;\n\n\tflexcop_reset(fc);\n\tflexcop_determine_revision(fc);\n\tflexcop_sram_init(fc);\n\tflexcop_hw_filter_init(fc);\n\tflexcop_smc_ctrl(fc, 0);\n\n\tret = flexcop_dvb_init(fc);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tret = flexcop_i2c_init(fc);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tif (fc->get_mac_addr(fc, 0) == 0) {\n\t\tu8 *b = fc->dvb_adapter.proposed_mac;\n\t\tinfo(\"MAC address = %pM\", b);\n\t\tflexcop_set_mac_filter(fc,b);\n\t\tflexcop_mac_filter_ctrl(fc,1);\n\t} else\n\t\twarn(\"reading of MAC address failed.\\n\");\n\n\tret = flexcop_frontend_init(fc);\n\tif (ret)\n\t\tgoto error;\n\n\tflexcop_device_name(fc,\"initialization of\",\"complete\");\n\treturn 0;\n\nerror:\n\tflexcop_device_exit(fc);\n\treturn ret;\n}\nEXPORT_SYMBOL(flexcop_device_initialize);\n\nvoid flexcop_device_exit(struct flexcop_device *fc)\n{\n\tflexcop_frontend_exit(fc);\n\tflexcop_i2c_exit(fc);\n\tflexcop_dvb_exit(fc);\n}\nEXPORT_SYMBOL(flexcop_device_exit);\n\nstatic int flexcop_module_init(void)\n{\n\tinfo(DRIVER_NAME \" loaded successfully\");\n\treturn 0;\n}\n\nstatic void flexcop_module_cleanup(void)\n{\n\tinfo(DRIVER_NAME \" unloaded successfully\");\n}\n\nmodule_init(flexcop_module_init);\nmodule_exit(flexcop_module_cleanup);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_NAME);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}