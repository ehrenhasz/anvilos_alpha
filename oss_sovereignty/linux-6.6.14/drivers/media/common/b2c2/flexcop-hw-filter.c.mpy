{
  "module_name": "flexcop-hw-filter.c",
  "hash_id": "b77e2c2d7d5d709cf7cbd1ea24fb81d74bf2b958bbeb2f4c3c5d5c3f86ca845a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/b2c2/flexcop-hw-filter.c",
  "human_readable_source": "\n \n#include \"flexcop.h\"\n\nstatic void flexcop_rcv_data_ctrl(struct flexcop_device *fc, int onoff)\n{\n\tflexcop_set_ibi_value(ctrl_208, Rcv_Data_sig, onoff);\n\tdeb_ts(\"rcv_data is now: '%s'\\n\", onoff ? \"on\" : \"off\");\n}\n\nvoid flexcop_smc_ctrl(struct flexcop_device *fc, int onoff)\n{\n\tflexcop_set_ibi_value(ctrl_208, SMC_Enable_sig, onoff);\n}\n\nstatic void flexcop_null_filter_ctrl(struct flexcop_device *fc, int onoff)\n{\n\tflexcop_set_ibi_value(ctrl_208, Null_filter_sig, onoff);\n}\n\nvoid flexcop_set_mac_filter(struct flexcop_device *fc, u8 mac[6])\n{\n\tflexcop_ibi_value v418, v41c;\n\tv41c = fc->read_ibi_reg(fc, mac_address_41c);\n\n\tv418.mac_address_418.MAC1 = mac[0];\n\tv418.mac_address_418.MAC2 = mac[1];\n\tv418.mac_address_418.MAC3 = mac[2];\n\tv418.mac_address_418.MAC6 = mac[3];\n\tv41c.mac_address_41c.MAC7 = mac[4];\n\tv41c.mac_address_41c.MAC8 = mac[5];\n\n\tfc->write_ibi_reg(fc, mac_address_418, v418);\n\tfc->write_ibi_reg(fc, mac_address_41c, v41c);\n}\n\nvoid flexcop_mac_filter_ctrl(struct flexcop_device *fc, int onoff)\n{\n\tflexcop_set_ibi_value(ctrl_208, MAC_filter_Mode_sig, onoff);\n}\n\nstatic void flexcop_pid_group_filter(struct flexcop_device *fc,\n\t\tu16 pid, u16 mask)\n{\n\t \n\tflexcop_ibi_value v30c;\n\tv30c.pid_filter_30c_ext_ind_0_7.Group_PID = pid;\n\tv30c.pid_filter_30c_ext_ind_0_7.Group_mask = mask;\n\tfc->write_ibi_reg(fc, pid_filter_30c, v30c);\n}\n\nstatic void flexcop_pid_group_filter_ctrl(struct flexcop_device *fc, int onoff)\n{\n\tflexcop_set_ibi_value(ctrl_208, Mask_filter_sig, onoff);\n}\n\n \n\n#define pid_ctrl(vregname,field,enablefield,trans_field,transval) \\\n\tflexcop_ibi_value vpid = fc->read_ibi_reg(fc, vregname), \\\nv208 = fc->read_ibi_reg(fc, ctrl_208); \\\nvpid.vregname.field = onoff ? pid : 0x1fff; \\\nvpid.vregname.trans_field = transval; \\\nv208.ctrl_208.enablefield = onoff; \\\nfc->write_ibi_reg(fc, vregname, vpid); \\\nfc->write_ibi_reg(fc, ctrl_208, v208)\n\nstatic void flexcop_pid_Stream1_PID_ctrl(struct flexcop_device *fc,\n\t\tu16 pid, int onoff)\n{\n\tpid_ctrl(pid_filter_300, Stream1_PID, Stream1_filter_sig,\n\t\t\tStream1_trans, 0);\n}\n\nstatic void flexcop_pid_Stream2_PID_ctrl(struct flexcop_device *fc,\n\t\tu16 pid, int onoff)\n{\n\tpid_ctrl(pid_filter_300, Stream2_PID, Stream2_filter_sig,\n\t\t\tStream2_trans, 0);\n}\n\nstatic void flexcop_pid_PCR_PID_ctrl(struct flexcop_device *fc,\n\t\tu16 pid, int onoff)\n{\n\tpid_ctrl(pid_filter_304, PCR_PID, PCR_filter_sig, PCR_trans, 0);\n}\n\nstatic void flexcop_pid_PMT_PID_ctrl(struct flexcop_device *fc,\n\t\tu16 pid, int onoff)\n{\n\tpid_ctrl(pid_filter_304, PMT_PID, PMT_filter_sig, PMT_trans, 0);\n}\n\nstatic void flexcop_pid_EMM_PID_ctrl(struct flexcop_device *fc,\n\t\tu16 pid, int onoff)\n{\n\tpid_ctrl(pid_filter_308, EMM_PID, EMM_filter_sig, EMM_trans, 0);\n}\n\nstatic void flexcop_pid_ECM_PID_ctrl(struct flexcop_device *fc,\n\t\tu16 pid, int onoff)\n{\n\tpid_ctrl(pid_filter_308, ECM_PID, ECM_filter_sig, ECM_trans, 0);\n}\n\nstatic void flexcop_pid_control(struct flexcop_device *fc,\n\t\tint index, u16 pid, int onoff)\n{\n\tif (pid == 0x2000)\n\t\treturn;\n\n\tdeb_ts(\"setting pid: %5d %04x at index %d '%s'\\n\",\n\t\t\tpid, pid, index, onoff ? \"on\" : \"off\");\n\n\t \n\tif (fc->skip_6_hw_pid_filter)\n\t\tindex += 6;\n\n\t \n\tswitch (index) {\n\tcase 0:\n\t\tflexcop_pid_Stream1_PID_ctrl(fc, pid, onoff);\n\t\tbreak;\n\tcase 1:\n\t\tflexcop_pid_Stream2_PID_ctrl(fc, pid, onoff);\n\t\tbreak;\n\tcase 2:\n\t\tflexcop_pid_PCR_PID_ctrl(fc, pid, onoff);\n\t\tbreak;\n\tcase 3:\n\t\tflexcop_pid_PMT_PID_ctrl(fc, pid, onoff);\n\t\tbreak;\n\tcase 4:\n\t\tflexcop_pid_EMM_PID_ctrl(fc, pid, onoff);\n\t\tbreak;\n\tcase 5:\n\t\tflexcop_pid_ECM_PID_ctrl(fc, pid, onoff);\n\t\tbreak;\n\tdefault:\n\t\tif (fc->has_32_hw_pid_filter && index < 38) {\n\t\t\tflexcop_ibi_value vpid, vid;\n\n\t\t\t \n\t\t\tvid = fc->read_ibi_reg(fc, index_reg_310);\n\t\t\tvid.index_reg_310.index_reg = index - 6;\n\t\t\tfc->write_ibi_reg(fc, index_reg_310, vid);\n\n\t\t\tvpid = fc->read_ibi_reg(fc, pid_n_reg_314);\n\t\t\tvpid.pid_n_reg_314.PID = onoff ? pid : 0x1fff;\n\t\t\tvpid.pid_n_reg_314.PID_enable_bit = onoff;\n\t\t\tfc->write_ibi_reg(fc, pid_n_reg_314, vpid);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int flexcop_toggle_fullts_streaming(struct flexcop_device *fc, int onoff)\n{\n\tif (fc->fullts_streaming_state != onoff) {\n\t\tdeb_ts(\"%s full TS transfer\\n\",onoff ? \"enabling\" : \"disabling\");\n\t\tflexcop_pid_group_filter(fc, 0, 0x1fe0 * (!onoff));\n\t\tflexcop_pid_group_filter_ctrl(fc, onoff);\n\t\tfc->fullts_streaming_state = onoff;\n\t}\n\treturn 0;\n}\n\nint flexcop_pid_feed_control(struct flexcop_device *fc,\n\t\tstruct dvb_demux_feed *dvbdmxfeed, int onoff)\n{\n\tint max_pid_filter = 6;\n\n\tmax_pid_filter -= 6 * fc->skip_6_hw_pid_filter;\n\tmax_pid_filter += 32 * fc->has_32_hw_pid_filter;\n\n\tfc->feedcount += onoff ? 1 : -1;  \n\tif (dvbdmxfeed->index >= max_pid_filter)\n\t\tfc->extra_feedcount += onoff ? 1 : -1;\n\n\t \n\n\tif (!fc->pid_filtering && fc->feedcount == onoff)\n\t\tflexcop_toggle_fullts_streaming(fc, onoff);\n\n\tif (fc->pid_filtering) {\n\t\tflexcop_pid_control \\\n\t\t\t(fc, dvbdmxfeed->index, dvbdmxfeed->pid, onoff);\n\n\t\tif (fc->extra_feedcount > 0)\n\t\t\tflexcop_toggle_fullts_streaming(fc, 1);\n\t\telse if (dvbdmxfeed->pid == 0x2000)\n\t\t\tflexcop_toggle_fullts_streaming(fc, onoff);\n\t\telse\n\t\t\tflexcop_toggle_fullts_streaming(fc, 0);\n\t}\n\n\t \n\tif (fc->feedcount == onoff) {\n\t\tflexcop_rcv_data_ctrl(fc, onoff);\n\t\tif (fc->stream_control)  \n\t\t\tfc->stream_control(fc, onoff);\n\n\t\t \n\t\tif (onoff == 0) {\n\t\t\tflexcop_reset_block_300(fc);\n\t\t\tflexcop_hw_filter_init(fc);\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(flexcop_pid_feed_control);\n\nvoid flexcop_hw_filter_init(struct flexcop_device *fc)\n{\n\tint i;\n\tflexcop_ibi_value v;\n\tint max_pid_filter = 6;\n\n\tmax_pid_filter -= 6 * fc->skip_6_hw_pid_filter;\n\tmax_pid_filter += 32 * fc->has_32_hw_pid_filter;\n\n\tfor (i = 0; i < max_pid_filter; i++)\n\t\tflexcop_pid_control(fc, i, 0x1fff, 0);\n\n\tflexcop_pid_group_filter(fc, 0, 0x1fe0);\n\tflexcop_pid_group_filter_ctrl(fc, 0);\n\n\tv = fc->read_ibi_reg(fc, pid_filter_308);\n\tv.pid_filter_308.EMM_filter_4 = 1;\n\tv.pid_filter_308.EMM_filter_6 = 0;\n\tfc->write_ibi_reg(fc, pid_filter_308, v);\n\n\tflexcop_null_filter_ctrl(fc, 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}