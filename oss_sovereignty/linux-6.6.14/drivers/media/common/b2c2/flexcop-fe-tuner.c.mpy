{
  "module_name": "flexcop-fe-tuner.c",
  "hash_id": "cec7fa792e798e66daeceb403f2bdc9d8aac075349538f4eff1893a8019625b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/b2c2/flexcop-fe-tuner.c",
  "human_readable_source": "\n \n#include <media/tuner.h>\n#include \"flexcop.h\"\n#include \"mt312.h\"\n#include \"stv0299.h\"\n#include \"s5h1420.h\"\n#include \"itd1000.h\"\n#include \"cx24113.h\"\n#include \"cx24123.h\"\n#include \"isl6421.h\"\n#include \"cx24120.h\"\n#include \"mt352.h\"\n#include \"bcm3510.h\"\n#include \"nxt200x.h\"\n#include \"dvb-pll.h\"\n#include \"lgdt330x.h\"\n#include \"tuner-simple.h\"\n#include \"stv0297.h\"\n\n\n \n#define FE_SUPPORTED(fe) IS_REACHABLE(CONFIG_DVB_ ## fe)\n\n#if FE_SUPPORTED(BCM3510) || (FE_SUPPORTED(CX24120) && FE_SUPPORTED(ISL6421))\nstatic int flexcop_fe_request_firmware(struct dvb_frontend *fe,\n\tconst struct firmware **fw, char *name)\n{\n\tstruct flexcop_device *fc = fe->dvb->priv;\n\n\treturn request_firmware(fw, name, fc->dev);\n}\n#endif\n\n \n#if (FE_SUPPORTED(MT312) || FE_SUPPORTED(STV0299)) && FE_SUPPORTED(PLL)\nstatic int flexcop_set_voltage(struct dvb_frontend *fe,\n\t\t\t       enum fe_sec_voltage voltage)\n{\n\tstruct flexcop_device *fc = fe->dvb->priv;\n\tflexcop_ibi_value v;\n\tdeb_tuner(\"polarity/voltage = %u\\n\", voltage);\n\n\tv = fc->read_ibi_reg(fc, misc_204);\n\tswitch (voltage) {\n\tcase SEC_VOLTAGE_OFF:\n\t\tv.misc_204.ACPI1_sig = 1;\n\t\tbreak;\n\tcase SEC_VOLTAGE_13:\n\t\tv.misc_204.ACPI1_sig = 0;\n\t\tv.misc_204.LNB_L_H_sig = 0;\n\t\tbreak;\n\tcase SEC_VOLTAGE_18:\n\t\tv.misc_204.ACPI1_sig = 0;\n\t\tv.misc_204.LNB_L_H_sig = 1;\n\t\tbreak;\n\tdefault:\n\t\terr(\"unknown SEC_VOLTAGE value\");\n\t\treturn -EINVAL;\n\t}\n\treturn fc->write_ibi_reg(fc, misc_204, v);\n}\n#endif\n\n#if FE_SUPPORTED(S5H1420) || FE_SUPPORTED(STV0299) || FE_SUPPORTED(MT312)\nstatic int __maybe_unused flexcop_sleep(struct dvb_frontend* fe)\n{\n\tstruct flexcop_device *fc = fe->dvb->priv;\n\tif (fc->fe_sleep)\n\t\treturn fc->fe_sleep(fe);\n\treturn 0;\n}\n#endif\n\n \n#if FE_SUPPORTED(MT312) && FE_SUPPORTED(PLL)\nstatic int flexcop_set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)\n{\n \n\tstruct flexcop_device *fc = fe->dvb->priv;\n\tflexcop_ibi_value v;\n\tu16 ax;\n\tv.raw = 0;\n\tdeb_tuner(\"tone = %u\\n\",tone);\n\n\tswitch (tone) {\n\tcase SEC_TONE_ON:\n\t\tax = 0x01ff;\n\t\tbreak;\n\tcase SEC_TONE_OFF:\n\t\tax = 0;\n\t\tbreak;\n\tdefault:\n\t\terr(\"unknown SEC_TONE value\");\n\t\treturn -EINVAL;\n\t}\n\n\tv.lnb_switch_freq_200.LNB_CTLPrescaler_sig = 1;  \n\tv.lnb_switch_freq_200.LNB_CTLHighCount_sig = ax;\n\tv.lnb_switch_freq_200.LNB_CTLLowCount_sig  = ax == 0 ? 0x1ff : ax;\n\treturn fc->write_ibi_reg(fc,lnb_switch_freq_200,v);\n}\n\nstatic void flexcop_diseqc_send_bit(struct dvb_frontend* fe, int data)\n{\n\tflexcop_set_tone(fe, SEC_TONE_ON);\n\tudelay(data ? 500 : 1000);\n\tflexcop_set_tone(fe, SEC_TONE_OFF);\n\tudelay(data ? 1000 : 500);\n}\n\nstatic void flexcop_diseqc_send_byte(struct dvb_frontend* fe, int data)\n{\n\tint i, par = 1, d;\n\tfor (i = 7; i >= 0; i--) {\n\t\td = (data >> i) & 1;\n\t\tpar ^= d;\n\t\tflexcop_diseqc_send_bit(fe, d);\n\t}\n\tflexcop_diseqc_send_bit(fe, par);\n}\n\nstatic int flexcop_send_diseqc_msg(struct dvb_frontend *fe,\n\tint len, u8 *msg, unsigned long burst)\n{\n\tint i;\n\n\tflexcop_set_tone(fe, SEC_TONE_OFF);\n\tmdelay(16);\n\n\tfor (i = 0; i < len; i++)\n\t\tflexcop_diseqc_send_byte(fe,msg[i]);\n\tmdelay(16);\n\n\tif (burst != -1) {\n\t\tif (burst)\n\t\t\tflexcop_diseqc_send_byte(fe, 0xff);\n\t\telse {\n\t\t\tflexcop_set_tone(fe, SEC_TONE_ON);\n\t\t\tmdelay(12);\n\t\t\tudelay(500);\n\t\t\tflexcop_set_tone(fe, SEC_TONE_OFF);\n\t\t}\n\t\tmsleep(20);\n\t}\n\treturn 0;\n}\n\nstatic int flexcop_diseqc_send_master_cmd(struct dvb_frontend *fe,\n\tstruct dvb_diseqc_master_cmd *cmd)\n{\n\treturn flexcop_send_diseqc_msg(fe, cmd->msg_len, cmd->msg, 0);\n}\n\nstatic int flexcop_diseqc_send_burst(struct dvb_frontend *fe,\n\t\t\t\t     enum fe_sec_mini_cmd minicmd)\n{\n\treturn flexcop_send_diseqc_msg(fe, 0, NULL, minicmd);\n}\n\nstatic struct mt312_config skystar23_samsung_tbdu18132_config = {\n\t.demod_address = 0x0e,\n};\n\nstatic int skystar2_rev23_attach(struct flexcop_device *fc,\n\tstruct i2c_adapter *i2c)\n{\n\tstruct dvb_frontend_ops *ops;\n\n\tfc->fe = dvb_attach(mt312_attach, &skystar23_samsung_tbdu18132_config, i2c);\n\tif (!fc->fe)\n\t\treturn 0;\n\n\tif (!dvb_attach(dvb_pll_attach, fc->fe, 0x61, i2c,\n\t\t\tDVB_PLL_SAMSUNG_TBDU18132))\n\t\treturn 0;\n\n\tops = &fc->fe->ops;\n\tops->diseqc_send_master_cmd = flexcop_diseqc_send_master_cmd;\n\tops->diseqc_send_burst      = flexcop_diseqc_send_burst;\n\tops->set_tone               = flexcop_set_tone;\n\tops->set_voltage            = flexcop_set_voltage;\n\tfc->fe_sleep                = ops->sleep;\n\tops->sleep                  = flexcop_sleep;\n\treturn 1;\n}\n#else\n#define skystar2_rev23_attach NULL\n#endif\n\n \n#if FE_SUPPORTED(STV0299) && FE_SUPPORTED(PLL)\nstatic int samsung_tbmu24112_set_symbol_rate(struct dvb_frontend *fe,\n\tu32 srate, u32 ratio)\n{\n\tu8 aclk = 0;\n\tu8 bclk = 0;\n\n\tif (srate < 1500000) {\n\t\taclk = 0xb7; bclk = 0x47;\n\t} else if (srate < 3000000) {\n\t\taclk = 0xb7; bclk = 0x4b;\n\t} else if (srate < 7000000) {\n\t\taclk = 0xb7; bclk = 0x4f;\n\t} else if (srate < 14000000) {\n\t\taclk = 0xb7; bclk = 0x53;\n\t} else if (srate < 30000000) {\n\t\taclk = 0xb6; bclk = 0x53;\n\t} else if (srate < 45000000) {\n\t\taclk = 0xb4; bclk = 0x51;\n\t}\n\n\tstv0299_writereg(fe, 0x13, aclk);\n\tstv0299_writereg(fe, 0x14, bclk);\n\tstv0299_writereg(fe, 0x1f, (ratio >> 16) & 0xff);\n\tstv0299_writereg(fe, 0x20, (ratio >>  8) & 0xff);\n\tstv0299_writereg(fe, 0x21,  ratio        & 0xf0);\n\treturn 0;\n}\n\nstatic u8 samsung_tbmu24112_inittab[] = {\n\t0x01, 0x15,\n\t0x02, 0x30,\n\t0x03, 0x00,\n\t0x04, 0x7D,\n\t0x05, 0x35,\n\t0x06, 0x02,\n\t0x07, 0x00,\n\t0x08, 0xC3,\n\t0x0C, 0x00,\n\t0x0D, 0x81,\n\t0x0E, 0x23,\n\t0x0F, 0x12,\n\t0x10, 0x7E,\n\t0x11, 0x84,\n\t0x12, 0xB9,\n\t0x13, 0x88,\n\t0x14, 0x89,\n\t0x15, 0xC9,\n\t0x16, 0x00,\n\t0x17, 0x5C,\n\t0x18, 0x00,\n\t0x19, 0x00,\n\t0x1A, 0x00,\n\t0x1C, 0x00,\n\t0x1D, 0x00,\n\t0x1E, 0x00,\n\t0x1F, 0x3A,\n\t0x20, 0x2E,\n\t0x21, 0x80,\n\t0x22, 0xFF,\n\t0x23, 0xC1,\n\t0x28, 0x00,\n\t0x29, 0x1E,\n\t0x2A, 0x14,\n\t0x2B, 0x0F,\n\t0x2C, 0x09,\n\t0x2D, 0x05,\n\t0x31, 0x1F,\n\t0x32, 0x19,\n\t0x33, 0xFE,\n\t0x34, 0x93,\n\t0xff, 0xff,\n};\n\nstatic struct stv0299_config samsung_tbmu24112_config = {\n\t.demod_address = 0x68,\n\t.inittab = samsung_tbmu24112_inittab,\n\t.mclk = 88000000UL,\n\t.invert = 0,\n\t.skip_reinit = 0,\n\t.lock_output = STV0299_LOCKOUTPUT_LK,\n\t.volt13_op0_op1 = STV0299_VOLT13_OP1,\n\t.min_delay_ms = 100,\n\t.set_symbol_rate = samsung_tbmu24112_set_symbol_rate,\n};\n\nstatic int skystar2_rev26_attach(struct flexcop_device *fc,\n\tstruct i2c_adapter *i2c)\n{\n\tfc->fe = dvb_attach(stv0299_attach, &samsung_tbmu24112_config, i2c);\n\tif (!fc->fe)\n\t\treturn 0;\n\n\tif (!dvb_attach(dvb_pll_attach, fc->fe, 0x61, i2c,\n\t\t\tDVB_PLL_SAMSUNG_TBMU24112))\n\t\treturn 0;\n\n\tfc->fe->ops.set_voltage = flexcop_set_voltage;\n\tfc->fe_sleep = fc->fe->ops.sleep;\n\tfc->fe->ops.sleep = flexcop_sleep;\n\treturn 1;\n\n}\n#else\n#define skystar2_rev26_attach NULL\n#endif\n\n \n#if FE_SUPPORTED(S5H1420) && FE_SUPPORTED(ISL6421) && FE_SUPPORTED(TUNER_ITD1000)\nstatic struct s5h1420_config skystar2_rev2_7_s5h1420_config = {\n\t.demod_address = 0x53,\n\t.invert = 1,\n\t.repeated_start_workaround = 1,\n\t.serial_mpeg = 1,\n};\n\nstatic struct itd1000_config skystar2_rev2_7_itd1000_config = {\n\t.i2c_address = 0x61,\n};\n\nstatic int skystar2_rev27_attach(struct flexcop_device *fc,\n\tstruct i2c_adapter *i2c)\n{\n\tflexcop_ibi_value r108;\n\tstruct i2c_adapter *i2c_tuner;\n\n\t \n\tfc->fc_i2c_adap[0].no_base_addr = 1;\n\tfc->fe = dvb_attach(s5h1420_attach, &skystar2_rev2_7_s5h1420_config,\n\t\t\t    i2c);\n\tif (!fc->fe)\n\t\tgoto fail;\n\n\ti2c_tuner = s5h1420_get_tuner_i2c_adapter(fc->fe);\n\tif (!i2c_tuner)\n\t\tgoto fail;\n\n\tfc->fe_sleep = fc->fe->ops.sleep;\n\tfc->fe->ops.sleep = flexcop_sleep;\n\n\t \n\tfc->fc_i2c_adap[2].no_base_addr = 1;\n\tif (!dvb_attach(isl6421_attach, fc->fe, &fc->fc_i2c_adap[2].i2c_adap,\n\t\t\t0x08, 1, 1, false)) {\n\t\terr(\"ISL6421 could NOT be attached\");\n\t\tgoto fail_isl;\n\t}\n\tinfo(\"ISL6421 successfully attached\");\n\n\t \n\tr108.raw = 0x00000506;\n\tfc->write_ibi_reg(fc, tw_sm_c_108, r108);\n\tif (!dvb_attach(itd1000_attach, fc->fe, i2c_tuner,\n\t\t\t&skystar2_rev2_7_itd1000_config)) {\n\t\terr(\"ITD1000 could NOT be attached\");\n\t\t \n\t\tgoto fail_isl;\n\t}\n\tinfo(\"ITD1000 successfully attached\");\n\n\treturn 1;\n\nfail_isl:\n\tfc->fc_i2c_adap[2].no_base_addr = 0;\nfail:\n\t \n\tfc->fc_i2c_adap[0].no_base_addr = 0;\n\treturn 0;\n}\n#else\n#define skystar2_rev27_attach NULL\n#endif\n\n \n#if FE_SUPPORTED(CX24123) && FE_SUPPORTED(ISL6421) && FE_SUPPORTED(TUNER_CX24113)\nstatic struct cx24123_config skystar2_rev2_8_cx24123_config = {\n\t.demod_address = 0x55,\n\t.dont_use_pll = 1,\n\t.agc_callback = cx24113_agc_callback,\n};\n\nstatic const struct cx24113_config skystar2_rev2_8_cx24113_config = {\n\t.i2c_addr = 0x54,\n\t.xtal_khz = 10111,\n};\n\nstatic int skystar2_rev28_attach(struct flexcop_device *fc,\n\tstruct i2c_adapter *i2c)\n{\n\tstruct i2c_adapter *i2c_tuner;\n\n\tfc->fe = dvb_attach(cx24123_attach, &skystar2_rev2_8_cx24123_config,\n\t\t\t    i2c);\n\tif (!fc->fe)\n\t\treturn 0;\n\n\ti2c_tuner = cx24123_get_tuner_i2c_adapter(fc->fe);\n\tif (!i2c_tuner)\n\t\treturn 0;\n\n\tif (!dvb_attach(cx24113_attach, fc->fe, &skystar2_rev2_8_cx24113_config,\n\t\t\ti2c_tuner)) {\n\t\terr(\"CX24113 could NOT be attached\");\n\t\treturn 0;\n\t}\n\tinfo(\"CX24113 successfully attached\");\n\n\tfc->fc_i2c_adap[2].no_base_addr = 1;\n\tif (!dvb_attach(isl6421_attach, fc->fe, &fc->fc_i2c_adap[2].i2c_adap,\n\t\t\t0x08, 0, 0, false)) {\n\t\terr(\"ISL6421 could NOT be attached\");\n\t\tfc->fc_i2c_adap[2].no_base_addr = 0;\n\t\treturn 0;\n\t}\n\tinfo(\"ISL6421 successfully attached\");\n\t \n\treturn 1;\n}\n#else\n#define skystar2_rev28_attach NULL\n#endif\n\n \n#if FE_SUPPORTED(MT352) && FE_SUPPORTED(PLL)\nstatic int samsung_tdtc9251dh0_demod_init(struct dvb_frontend *fe)\n{\n\tstatic u8 mt352_clock_config[] = { 0x89, 0x18, 0x2d };\n\tstatic u8 mt352_reset[] = { 0x50, 0x80 };\n\tstatic u8 mt352_adc_ctl_1_cfg[] = { 0x8E, 0x40 };\n\tstatic u8 mt352_agc_cfg[] = { 0x67, 0x28, 0xa1 };\n\tstatic u8 mt352_capt_range_cfg[] = { 0x75, 0x32 };\n\n\tmt352_write(fe, mt352_clock_config, sizeof(mt352_clock_config));\n\tudelay(2000);\n\tmt352_write(fe, mt352_reset, sizeof(mt352_reset));\n\tmt352_write(fe, mt352_adc_ctl_1_cfg, sizeof(mt352_adc_ctl_1_cfg));\n\tmt352_write(fe, mt352_agc_cfg, sizeof(mt352_agc_cfg));\n\tmt352_write(fe, mt352_capt_range_cfg, sizeof(mt352_capt_range_cfg));\n\treturn 0;\n}\n\nstatic struct mt352_config samsung_tdtc9251dh0_config = {\n\t.demod_address = 0x0f,\n\t.demod_init    = samsung_tdtc9251dh0_demod_init,\n};\n\nstatic int airstar_dvbt_attach(struct flexcop_device *fc,\n\tstruct i2c_adapter *i2c)\n{\n\tfc->fe = dvb_attach(mt352_attach, &samsung_tdtc9251dh0_config, i2c);\n\tif (!fc->fe)\n\t\treturn 0;\n\n\treturn !!dvb_attach(dvb_pll_attach, fc->fe, 0x61, NULL,\n\t\t\t    DVB_PLL_SAMSUNG_TDTC9251DH0);\n}\n#else\n#define airstar_dvbt_attach NULL\n#endif\n\n \n#if FE_SUPPORTED(BCM3510)\nstatic struct bcm3510_config air2pc_atsc_first_gen_config = {\n\t.demod_address    = 0x0f,\n\t.request_firmware = flexcop_fe_request_firmware,\n};\n\nstatic int airstar_atsc1_attach(struct flexcop_device *fc,\n\tstruct i2c_adapter *i2c)\n{\n\tfc->fe = dvb_attach(bcm3510_attach, &air2pc_atsc_first_gen_config, i2c);\n\treturn fc->fe != NULL;\n}\n#else\n#define airstar_atsc1_attach NULL\n#endif\n\n \n#if FE_SUPPORTED(NXT200X) && FE_SUPPORTED(PLL)\nstatic const struct nxt200x_config samsung_tbmv_config = {\n\t.demod_address = 0x0a,\n};\n\nstatic int airstar_atsc2_attach(struct flexcop_device *fc,\n\tstruct i2c_adapter *i2c)\n{\n\tfc->fe = dvb_attach(nxt200x_attach, &samsung_tbmv_config, i2c);\n\tif (!fc->fe)\n\t\treturn 0;\n\n\treturn !!dvb_attach(dvb_pll_attach, fc->fe, 0x61, NULL,\n\t\t\t    DVB_PLL_SAMSUNG_TBMV);\n}\n#else\n#define airstar_atsc2_attach NULL\n#endif\n\n \n#if FE_SUPPORTED(LGDT330X)\nstatic struct lgdt330x_config air2pc_atsc_hd5000_config = {\n\t.demod_chip          = LGDT3303,\n\t.serial_mpeg         = 0x04,\n\t.clock_polarity_flip = 1,\n};\n\nstatic int airstar_atsc3_attach(struct flexcop_device *fc,\n\tstruct i2c_adapter *i2c)\n{\n\tfc->fe = dvb_attach(lgdt330x_attach, &air2pc_atsc_hd5000_config,\n\t\t\t    0x59, i2c);\n\tif (!fc->fe)\n\t\treturn 0;\n\n\treturn !!dvb_attach(simple_tuner_attach, fc->fe, i2c, 0x61,\n\t\t\t    TUNER_LG_TDVS_H06XF);\n}\n#else\n#define airstar_atsc3_attach NULL\n#endif\n\n \n#if FE_SUPPORTED(STV0297) && FE_SUPPORTED(PLL)\nstatic u8 alps_tdee4_stv0297_inittab[] = {\n\t0x80, 0x01,\n\t0x80, 0x00,\n\t0x81, 0x01,\n\t0x81, 0x00,\n\t0x00, 0x48,\n\t0x01, 0x58,\n\t0x03, 0x00,\n\t0x04, 0x00,\n\t0x07, 0x00,\n\t0x08, 0x00,\n\t0x30, 0xff,\n\t0x31, 0x9d,\n\t0x32, 0xff,\n\t0x33, 0x00,\n\t0x34, 0x29,\n\t0x35, 0x55,\n\t0x36, 0x80,\n\t0x37, 0x6e,\n\t0x38, 0x9c,\n\t0x40, 0x1a,\n\t0x41, 0xfe,\n\t0x42, 0x33,\n\t0x43, 0x00,\n\t0x44, 0xff,\n\t0x45, 0x00,\n\t0x46, 0x00,\n\t0x49, 0x04,\n\t0x4a, 0x51,\n\t0x4b, 0xf8,\n\t0x52, 0x30,\n\t0x53, 0x06,\n\t0x59, 0x06,\n\t0x5a, 0x5e,\n\t0x5b, 0x04,\n\t0x61, 0x49,\n\t0x62, 0x0a,\n\t0x70, 0xff,\n\t0x71, 0x04,\n\t0x72, 0x00,\n\t0x73, 0x00,\n\t0x74, 0x0c,\n\t0x80, 0x20,\n\t0x81, 0x00,\n\t0x82, 0x30,\n\t0x83, 0x00,\n\t0x84, 0x04,\n\t0x85, 0x22,\n\t0x86, 0x08,\n\t0x87, 0x1b,\n\t0x88, 0x00,\n\t0x89, 0x00,\n\t0x90, 0x00,\n\t0x91, 0x04,\n\t0xa0, 0x86,\n\t0xa1, 0x00,\n\t0xa2, 0x00,\n\t0xb0, 0x91,\n\t0xb1, 0x0b,\n\t0xc0, 0x5b,\n\t0xc1, 0x10,\n\t0xc2, 0x12,\n\t0xd0, 0x02,\n\t0xd1, 0x00,\n\t0xd2, 0x00,\n\t0xd3, 0x00,\n\t0xd4, 0x02,\n\t0xd5, 0x00,\n\t0xde, 0x00,\n\t0xdf, 0x01,\n\t0xff, 0xff,\n};\n\nstatic struct stv0297_config alps_tdee4_stv0297_config = {\n\t.demod_address = 0x1c,\n\t.inittab = alps_tdee4_stv0297_inittab,\n};\n\nstatic int cablestar2_attach(struct flexcop_device *fc,\n\tstruct i2c_adapter *i2c)\n{\n\tfc->fc_i2c_adap[0].no_base_addr = 1;\n\tfc->fe = dvb_attach(stv0297_attach, &alps_tdee4_stv0297_config, i2c);\n\tif (!fc->fe)\n\t\tgoto fail;\n\n\t \n\tif (fc->fe->ops.i2c_gate_ctrl)\n\t\tfc->fe->ops.i2c_gate_ctrl(fc->fe, 0);\n\tfc->fe->ops.i2c_gate_ctrl = NULL;\n\n\tif (!dvb_attach(dvb_pll_attach, fc->fe, 0x61,\n\t\t\t&fc->fc_i2c_adap[2].i2c_adap, DVB_PLL_TDEE4))\n\t\tgoto fail;\n\n\treturn 1;\n\nfail:\n\t \n\tfc->fc_i2c_adap[0].no_base_addr = 0;\n\treturn 0;\n}\n#else\n#define cablestar2_attach NULL\n#endif\n\n \n#if FE_SUPPORTED(CX24120) && FE_SUPPORTED(ISL6421)\nstatic const struct cx24120_config skystar2_rev3_3_cx24120_config = {\n\t.i2c_addr = 0x55,\n\t.xtal_khz = 10111,\n\t.initial_mpeg_config = { 0xa1, 0x76, 0x07 },\n\t.request_firmware = flexcop_fe_request_firmware,\n\t.i2c_wr_max = 4,\n};\n\nstatic int skystarS2_rev33_attach(struct flexcop_device *fc,\n\tstruct i2c_adapter *i2c)\n{\n\tfc->fe = dvb_attach(cx24120_attach,\n\t\t\t    &skystar2_rev3_3_cx24120_config, i2c);\n\tif (!fc->fe)\n\t\treturn 0;\n\n\tfc->dev_type = FC_SKYS2_REV33;\n\tfc->fc_i2c_adap[2].no_base_addr = 1;\n\tif (!dvb_attach(isl6421_attach, fc->fe, &fc->fc_i2c_adap[2].i2c_adap,\n\t\t\t0x08, 0, 0, false)) {\n\t\terr(\"ISL6421 could NOT be attached!\");\n\t\tfc->fc_i2c_adap[2].no_base_addr = 0;\n\t\treturn 0;\n\t}\n\tinfo(\"ISL6421 successfully attached.\");\n\n\tif (fc->has_32_hw_pid_filter)\n\t\tfc->skip_6_hw_pid_filter = 1;\n\n\treturn 1;\n}\n#else\n#define skystarS2_rev33_attach NULL\n#endif\n\nstatic struct {\n\tflexcop_device_type_t type;\n\tint (*attach)(struct flexcop_device *, struct i2c_adapter *);\n} flexcop_frontends[] = {\n\t{ FC_SKY_REV27, skystar2_rev27_attach },\n\t{ FC_SKY_REV28, skystar2_rev28_attach },\n\t{ FC_SKY_REV26, skystar2_rev26_attach },\n\t{ FC_AIR_DVBT, airstar_dvbt_attach },\n\t{ FC_AIR_ATSC2, airstar_atsc2_attach },\n\t{ FC_AIR_ATSC3, airstar_atsc3_attach },\n\t{ FC_AIR_ATSC1, airstar_atsc1_attach },\n\t{ FC_CABLE, cablestar2_attach },\n\t{ FC_SKY_REV23, skystar2_rev23_attach },\n\t{ FC_SKYS2_REV33, skystarS2_rev33_attach },\n};\n\n \nint flexcop_frontend_init(struct flexcop_device *fc)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(flexcop_frontends); i++) {\n\t\tif (!flexcop_frontends[i].attach)\n\t\t\tcontinue;\n\t\t \n\t\tfc->dev_type = flexcop_frontends[i].type;\n\t\tif (flexcop_frontends[i].attach(fc, &fc->fc_i2c_adap[0].i2c_adap))\n\t\t\tgoto fe_found;\n\t\t \n\t\tif (fc->fe) {\n\t\t\tdvb_frontend_detach(fc->fe);\n\t\t\tfc->fe = NULL;\n\t\t}\n\t}\n\tfc->dev_type = FC_UNK;\n\terr(\"no frontend driver found for this B2C2/FlexCop adapter\");\n\treturn -ENODEV;\n\nfe_found:\n\tinfo(\"found '%s' .\", fc->fe->ops.info.name);\n\tif (dvb_register_frontend(&fc->dvb_adapter, fc->fe)) {\n\t\terr(\"frontend registration failed!\");\n\t\tdvb_frontend_detach(fc->fe);\n\t\tfc->fe = NULL;\n\t\treturn -EINVAL;\n\t}\n\tfc->init_state |= FC_STATE_FE_INIT;\n\treturn 0;\n}\n\nvoid flexcop_frontend_exit(struct flexcop_device *fc)\n{\n\tif (fc->init_state & FC_STATE_FE_INIT) {\n\t\tdvb_unregister_frontend(fc->fe);\n\t\tdvb_frontend_detach(fc->fe);\n\t}\n\tfc->init_state &= ~FC_STATE_FE_INIT;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}