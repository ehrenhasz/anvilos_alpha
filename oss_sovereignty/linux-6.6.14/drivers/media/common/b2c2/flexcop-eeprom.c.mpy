{
  "module_name": "flexcop-eeprom.c",
  "hash_id": "e35f23d271f4871658090e7e97640e669f7df3708e2fd0fa79890d55e0de1d8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/b2c2/flexcop-eeprom.c",
  "human_readable_source": "\n \n#include \"flexcop.h\"\n\n#if 0\n \nstatic int eeprom_write(struct adapter *adapter, u16 addr, u8 *buf, u16 len)\n{\n\treturn flex_i2c_write(adapter, 0x20000000, 0x50, addr, buf, len);\n}\n\nstatic int eeprom_lrc_write(struct adapter *adapter, u32 addr,\n\t\tu32 len, u8 *wbuf, u8 *rbuf, int retries)\n{\nint i;\n\nfor (i = 0; i < retries; i++) {\n\tif (eeprom_write(adapter, addr, wbuf, len) == len) {\n\t\tif (eeprom_lrc_read(adapter, addr, len, rbuf, retries) == 1)\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\nstatic int eeprom_writeKey(struct adapter *adapter, u8 *key, u32 len)\n{\n\tu8 rbuf[20];\n\tu8 wbuf[20];\n\n\tif (len != 16)\n\t\treturn 0;\n\n\tmemcpy(wbuf, key, len);\n\twbuf[16] = 0;\n\twbuf[17] = 0;\n\twbuf[18] = 0;\n\twbuf[19] = calc_lrc(wbuf, 19);\n\treturn eeprom_lrc_write(adapter, 0x3e4, 20, wbuf, rbuf, 4);\n}\n\nstatic int eeprom_readKey(struct adapter *adapter, u8 *key, u32 len)\n{\n\tu8 buf[20];\n\n\tif (len != 16)\n\t\treturn 0;\n\n\tif (eeprom_lrc_read(adapter, 0x3e4, 20, buf, 4) == 0)\n\t\treturn 0;\n\n\tmemcpy(key, buf, len);\n\treturn 1;\n}\n\nstatic char eeprom_set_mac_addr(struct adapter *adapter, char type, u8 *mac)\n{\n\tu8 tmp[8];\n\n\tif (type != 0) {\n\t\ttmp[0] = mac[0];\n\t\ttmp[1] = mac[1];\n\t\ttmp[2] = mac[2];\n\t\ttmp[3] = mac[5];\n\t\ttmp[4] = mac[6];\n\t\ttmp[5] = mac[7];\n\t} else {\n\t\ttmp[0] = mac[0];\n\t\ttmp[1] = mac[1];\n\t\ttmp[2] = mac[2];\n\t\ttmp[3] = mac[3];\n\t\ttmp[4] = mac[4];\n\t\ttmp[5] = mac[5];\n\t}\n\n\ttmp[6] = 0;\n\ttmp[7] = calc_lrc(tmp, 7);\n\n\tif (eeprom_write(adapter, 0x3f8, tmp, 8) == 8)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int flexcop_eeprom_read(struct flexcop_device *fc,\n\t\tu16 addr, u8 *buf, u16 len)\n{\n\treturn fc->i2c_request(fc,FC_READ,FC_I2C_PORT_EEPROM,0x50,addr,buf,len);\n}\n\n#endif\n\nstatic u8 calc_lrc(u8 *buf, int len)\n{\n\tint i;\n\tu8 sum = 0;\n\tfor (i = 0; i < len; i++)\n\t\tsum = sum ^ buf[i];\n\treturn sum;\n}\n\nstatic int flexcop_eeprom_request(struct flexcop_device *fc,\n\tflexcop_access_op_t op, u16 addr, u8 *buf, u16 len, int retries)\n{\n\tint i,ret = 0;\n\tu8 chipaddr =  0x50 | ((addr >> 8) & 3);\n\tfor (i = 0; i < retries; i++) {\n\t\tret = fc->i2c_request(&fc->fc_i2c_adap[1], op, chipaddr,\n\t\t\taddr & 0xff, buf, len);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int flexcop_eeprom_lrc_read(struct flexcop_device *fc, u16 addr,\n\t\tu8 *buf, u16 len, int retries)\n{\n\tint ret = flexcop_eeprom_request(fc, FC_READ, addr, buf, len, retries);\n\tif (ret == 0)\n\t\tif (calc_lrc(buf, len - 1) != buf[len - 1])\n\t\t\tret = -EINVAL;\n\treturn ret;\n}\n\n \nint flexcop_eeprom_check_mac_addr(struct flexcop_device *fc, int extended)\n{\n\tu8 buf[8];\n\tint ret = 0;\n\n\tif ((ret = flexcop_eeprom_lrc_read(fc,0x3f8,buf,8,4)) == 0) {\n\t\tif (extended != 0) {\n\t\t\terr(\"TODO: extended (EUI64) MAC addresses aren't completely supported yet\");\n\t\t\tret = -EINVAL;\n\t\t} else\n\t\t\tmemcpy(fc->dvb_adapter.proposed_mac,buf,6);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(flexcop_eeprom_check_mac_addr);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}