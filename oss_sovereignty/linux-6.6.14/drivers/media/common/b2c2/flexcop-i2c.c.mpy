{
  "module_name": "flexcop-i2c.c",
  "hash_id": "4675ad2cd3cd4f18938a1bf1bf38bd3884e9e426ced2cd585f36bb50139a0cb7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/b2c2/flexcop-i2c.c",
  "human_readable_source": "\n \n#include \"flexcop.h\"\n\n#define FC_MAX_I2C_RETRIES 100000\n\nstatic int flexcop_i2c_operation(struct flexcop_device *fc,\n\t\tflexcop_ibi_value *r100)\n{\n\tint i;\n\tflexcop_ibi_value r;\n\n\tr100->tw_sm_c_100.working_start = 1;\n\tdeb_i2c(\"r100 before: %08x\\n\",r100->raw);\n\n\tfc->write_ibi_reg(fc, tw_sm_c_100, ibi_zero);\n\tfc->write_ibi_reg(fc, tw_sm_c_100, *r100);  \n\n\tfor (i = 0; i < FC_MAX_I2C_RETRIES; i++) {\n\t\tr = fc->read_ibi_reg(fc, tw_sm_c_100);\n\n\t\tif (!r.tw_sm_c_100.no_base_addr_ack_error) {\n\t\t\tif (r.tw_sm_c_100.st_done) {\n\t\t\t\t*r100 = r;\n\t\t\t\tdeb_i2c(\"i2c success\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tdeb_i2c(\"suffering from an i2c ack_error\\n\");\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t}\n\tdeb_i2c(\"tried %d times i2c operation, never finished or too many ack errors.\\n\",\n\t\ti);\n\treturn -EREMOTEIO;\n}\n\nstatic int flexcop_i2c_read4(struct flexcop_i2c_adapter *i2c,\n\t\tflexcop_ibi_value r100, u8 *buf)\n{\n\tflexcop_ibi_value r104;\n\tint len = r100.tw_sm_c_100.total_bytes,\n\t\t \n\t\tret;\n\n\t \n\tif (i2c->fc->dev_type == FC_SKY_REV27)\n\t\tr100.tw_sm_c_100.no_base_addr_ack_error = i2c->no_base_addr;\n\n\tret = flexcop_i2c_operation(i2c->fc, &r100);\n\tif (ret != 0) {\n\t\tdeb_i2c(\"Retrying operation\\n\");\n\t\tr100.tw_sm_c_100.no_base_addr_ack_error = i2c->no_base_addr;\n\t\tret = flexcop_i2c_operation(i2c->fc, &r100);\n\t}\n\tif (ret != 0) {\n\t\tdeb_i2c(\"read failed. %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tbuf[0] = r100.tw_sm_c_100.data1_reg;\n\n\tif (len > 0) {\n\t\tr104 = i2c->fc->read_ibi_reg(i2c->fc, tw_sm_c_104);\n\t\tdeb_i2c(\"read: r100: %08x, r104: %08x\\n\", r100.raw, r104.raw);\n\n\t\t \n\t\tbuf[1] = r104.tw_sm_c_104.data2_reg;\n\t\tif (len > 1) buf[2] = r104.tw_sm_c_104.data3_reg;\n\t\tif (len > 2) buf[3] = r104.tw_sm_c_104.data4_reg;\n\t}\n\treturn 0;\n}\n\nstatic int flexcop_i2c_write4(struct flexcop_device *fc,\n\t\tflexcop_ibi_value r100, u8 *buf)\n{\n\tflexcop_ibi_value r104;\n\tint len = r100.tw_sm_c_100.total_bytes;  \n\tr104.raw = 0;\n\n\t \n\tr100.tw_sm_c_100.data1_reg = buf[0];\n\tr104.tw_sm_c_104.data2_reg = len > 0 ? buf[1] : 0;\n\tr104.tw_sm_c_104.data3_reg = len > 1 ? buf[2] : 0;\n\tr104.tw_sm_c_104.data4_reg = len > 2 ? buf[3] : 0;\n\n\tdeb_i2c(\"write: r100: %08x, r104: %08x\\n\", r100.raw, r104.raw);\n\n\t \n\tfc->write_ibi_reg(fc, tw_sm_c_104, r104);\n\treturn flexcop_i2c_operation(fc, &r100);\n}\n\nint flexcop_i2c_request(struct flexcop_i2c_adapter *i2c,\n\t\t\tflexcop_access_op_t op, u8 chipaddr,\n\t\t\tu8 start_addr, u8 *buf, u16 size)\n{\n\tint ret;\n\tint len = size;\n\tu8 *p;\n\tu8 addr = start_addr;\n\n\tu16 bytes_to_transfer;\n\tflexcop_ibi_value r100;\n\n\tdeb_i2c(\"port %d %s(%02x): register %02x, size: %d\\n\",\n\t\ti2c->port,\n\t\top == FC_READ ? \"rd\" : \"wr\",\n\t\tchipaddr, start_addr, size);\n\tr100.raw = 0;\n\tr100.tw_sm_c_100.chipaddr = chipaddr;\n\tr100.tw_sm_c_100.twoWS_rw = op;\n\tr100.tw_sm_c_100.twoWS_port_reg = i2c->port;\n\n\t \n\tif (i2c->no_base_addr && len == 0 && op == FC_WRITE) {\n\t\tbuf = &start_addr;\n\t\tlen = 1;\n\t}\n\n\tp = buf;\n\n\twhile (len != 0) {\n\t\tbytes_to_transfer = len > 4 ? 4 : len;\n\n\t\tr100.tw_sm_c_100.total_bytes = bytes_to_transfer - 1;\n\t\tr100.tw_sm_c_100.baseaddr = addr;\n\n\t\tif (op == FC_READ)\n\t\t\tret = flexcop_i2c_read4(i2c, r100, p);\n\t\telse\n\t\t\tret = flexcop_i2c_write4(i2c->fc, r100, p);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tp  += bytes_to_transfer;\n\t\taddr += bytes_to_transfer;\n\t\tlen  -= bytes_to_transfer;\n\t}\n\tdeb_i2c_dump(\"port %d %s(%02x): register %02x: %*ph\\n\",\n\t\ti2c->port,\n\t\top == FC_READ ? \"rd\" : \"wr\",\n\t\tchipaddr, start_addr, size, buf);\n\n\treturn 0;\n}\n \nEXPORT_SYMBOL(flexcop_i2c_request);\n\n \nstatic int flexcop_master_xfer(struct i2c_adapter *i2c_adap,\n\t\tstruct i2c_msg msgs[], int num)\n{\n\tstruct flexcop_i2c_adapter *i2c = i2c_get_adapdata(i2c_adap);\n\tint i, ret = 0;\n\n\t \n\tif (num == 1 && msgs[0].flags == I2C_M_RD && msgs[0].len <= 1)\n\t\treturn 1;\n\n\tif (mutex_lock_interruptible(&i2c->fc->i2c_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tfor (i = 0; i < num; i++) {\n\t\t \n\t\tif (i+1 < num && (msgs[i+1].flags == I2C_M_RD)) {\n\t\t\tret = i2c->fc->i2c_request(i2c, FC_READ, msgs[i].addr,\n\t\t\t\t\tmsgs[i].buf[0], msgs[i+1].buf,\n\t\t\t\t\tmsgs[i+1].len);\n\t\t\ti++;  \n\t\t} else  \n\t\t\tret = i2c->fc->i2c_request(i2c, FC_WRITE, msgs[i].addr,\n\t\t\t\t\tmsgs[i].buf[0], &msgs[i].buf[1],\n\t\t\t\t\tmsgs[i].len - 1);\n\t\tif (ret < 0) {\n\t\t\tdeb_i2c(\"i2c master_xfer failed\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&i2c->fc->i2c_mutex);\n\n\tif (ret == 0)\n\t\tret = num;\n\treturn ret;\n}\n\nstatic u32 flexcop_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm flexcop_algo = {\n\t.master_xfer\t= flexcop_master_xfer,\n\t.functionality\t= flexcop_i2c_func,\n};\n\nint flexcop_i2c_init(struct flexcop_device *fc)\n{\n\tint ret;\n\tmutex_init(&fc->i2c_mutex);\n\n\tfc->fc_i2c_adap[0].fc = fc;\n\tfc->fc_i2c_adap[1].fc = fc;\n\tfc->fc_i2c_adap[2].fc = fc;\n\tfc->fc_i2c_adap[0].port = FC_I2C_PORT_DEMOD;\n\tfc->fc_i2c_adap[1].port = FC_I2C_PORT_EEPROM;\n\tfc->fc_i2c_adap[2].port = FC_I2C_PORT_TUNER;\n\n\tstrscpy(fc->fc_i2c_adap[0].i2c_adap.name, \"B2C2 FlexCop I2C to demod\",\n\t\tsizeof(fc->fc_i2c_adap[0].i2c_adap.name));\n\tstrscpy(fc->fc_i2c_adap[1].i2c_adap.name, \"B2C2 FlexCop I2C to eeprom\",\n\t\tsizeof(fc->fc_i2c_adap[1].i2c_adap.name));\n\tstrscpy(fc->fc_i2c_adap[2].i2c_adap.name, \"B2C2 FlexCop I2C to tuner\",\n\t\tsizeof(fc->fc_i2c_adap[2].i2c_adap.name));\n\n\ti2c_set_adapdata(&fc->fc_i2c_adap[0].i2c_adap, &fc->fc_i2c_adap[0]);\n\ti2c_set_adapdata(&fc->fc_i2c_adap[1].i2c_adap, &fc->fc_i2c_adap[1]);\n\ti2c_set_adapdata(&fc->fc_i2c_adap[2].i2c_adap, &fc->fc_i2c_adap[2]);\n\n\tfc->fc_i2c_adap[0].i2c_adap.algo =\n\t\tfc->fc_i2c_adap[1].i2c_adap.algo =\n\t\tfc->fc_i2c_adap[2].i2c_adap.algo = &flexcop_algo;\n\tfc->fc_i2c_adap[0].i2c_adap.algo_data =\n\t\tfc->fc_i2c_adap[1].i2c_adap.algo_data =\n\t\tfc->fc_i2c_adap[2].i2c_adap.algo_data = NULL;\n\tfc->fc_i2c_adap[0].i2c_adap.dev.parent =\n\t\tfc->fc_i2c_adap[1].i2c_adap.dev.parent =\n\t\tfc->fc_i2c_adap[2].i2c_adap.dev.parent = fc->dev;\n\n\tret = i2c_add_adapter(&fc->fc_i2c_adap[0].i2c_adap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_add_adapter(&fc->fc_i2c_adap[1].i2c_adap);\n\tif (ret < 0)\n\t\tgoto adap_1_failed;\n\n\tret = i2c_add_adapter(&fc->fc_i2c_adap[2].i2c_adap);\n\tif (ret < 0)\n\t\tgoto adap_2_failed;\n\n\tfc->init_state |= FC_STATE_I2C_INIT;\n\treturn 0;\n\nadap_2_failed:\n\ti2c_del_adapter(&fc->fc_i2c_adap[1].i2c_adap);\nadap_1_failed:\n\ti2c_del_adapter(&fc->fc_i2c_adap[0].i2c_adap);\n\treturn ret;\n}\n\nvoid flexcop_i2c_exit(struct flexcop_device *fc)\n{\n\tif (fc->init_state & FC_STATE_I2C_INIT) {\n\t\ti2c_del_adapter(&fc->fc_i2c_adap[2].i2c_adap);\n\t\ti2c_del_adapter(&fc->fc_i2c_adap[1].i2c_adap);\n\t\ti2c_del_adapter(&fc->fc_i2c_adap[0].i2c_adap);\n\t}\n\tfc->init_state &= ~FC_STATE_I2C_INIT;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}