{
  "module_name": "videobuf2-v4l2.c",
  "hash_id": "081f4775a563f241568c7fbb03a05572885b5fce620aa7ba6216da5419b3fc7f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/videobuf2/videobuf2-v4l2.c",
  "human_readable_source": " \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/freezer.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fh.h>\n\n#include <media/videobuf2-v4l2.h>\n\nstatic int debug;\nmodule_param(debug, int, 0644);\n\n#define dprintk(q, level, fmt, arg...)\t\t\t\t\t      \\\n\tdo {\t\t\t\t\t\t\t\t      \\\n\t\tif (debug >= level)\t\t\t\t\t      \\\n\t\t\tpr_info(\"vb2-v4l2: [%p] %s: \" fmt,\t\t      \\\n\t\t\t\t(q)->name, __func__, ## arg);\t\t      \\\n\t} while (0)\n\n \n#define V4L2_BUFFER_MASK_FLAGS\t(V4L2_BUF_FLAG_MAPPED | V4L2_BUF_FLAG_QUEUED | \\\n\t\t\t\t V4L2_BUF_FLAG_DONE | V4L2_BUF_FLAG_ERROR | \\\n\t\t\t\t V4L2_BUF_FLAG_PREPARED | \\\n\t\t\t\t V4L2_BUF_FLAG_IN_REQUEST | \\\n\t\t\t\t V4L2_BUF_FLAG_REQUEST_FD | \\\n\t\t\t\t V4L2_BUF_FLAG_TIMESTAMP_MASK)\n \n#define V4L2_BUFFER_OUT_FLAGS\t(V4L2_BUF_FLAG_PFRAME | \\\n\t\t\t\t V4L2_BUF_FLAG_BFRAME | \\\n\t\t\t\t V4L2_BUF_FLAG_KEYFRAME | \\\n\t\t\t\t V4L2_BUF_FLAG_TIMECODE | \\\n\t\t\t\t V4L2_BUF_FLAG_M2M_HOLD_CAPTURE_BUF)\n\n \nstatic int __verify_planes_array(struct vb2_buffer *vb, const struct v4l2_buffer *b)\n{\n\tif (!V4L2_TYPE_IS_MULTIPLANAR(b->type))\n\t\treturn 0;\n\n\t \n\tif (b->m.planes == NULL) {\n\t\tdprintk(vb->vb2_queue, 1,\n\t\t\t\"multi-planar buffer passed but planes array not provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (b->length < vb->num_planes || b->length > VB2_MAX_PLANES) {\n\t\tdprintk(vb->vb2_queue, 1,\n\t\t\t\"incorrect planes array length, expected %d, got %d\\n\",\n\t\t\tvb->num_planes, b->length);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __verify_planes_array_core(struct vb2_buffer *vb, const void *pb)\n{\n\treturn __verify_planes_array(vb, pb);\n}\n\n \nstatic int __verify_length(struct vb2_buffer *vb, const struct v4l2_buffer *b)\n{\n\tunsigned int length;\n\tunsigned int bytesused;\n\tunsigned int plane;\n\n\tif (V4L2_TYPE_IS_CAPTURE(b->type))\n\t\treturn 0;\n\n\tif (V4L2_TYPE_IS_MULTIPLANAR(b->type)) {\n\t\tfor (plane = 0; plane < vb->num_planes; ++plane) {\n\t\t\tlength = (b->memory == VB2_MEMORY_USERPTR ||\n\t\t\t\t  b->memory == VB2_MEMORY_DMABUF)\n\t\t\t       ? b->m.planes[plane].length\n\t\t\t\t: vb->planes[plane].length;\n\t\t\tbytesused = b->m.planes[plane].bytesused\n\t\t\t\t  ? b->m.planes[plane].bytesused : length;\n\n\t\t\tif (b->m.planes[plane].bytesused > length)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (b->m.planes[plane].data_offset > 0 &&\n\t\t\t    b->m.planes[plane].data_offset >= bytesused)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tlength = (b->memory == VB2_MEMORY_USERPTR)\n\t\t\t? b->length : vb->planes[0].length;\n\n\t\tif (b->bytesused > length)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void __init_vb2_v4l2_buffer(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tvbuf->request_fd = -1;\n}\n\nstatic void __copy_timestamp(struct vb2_buffer *vb, const void *pb)\n{\n\tconst struct v4l2_buffer *b = pb;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_queue *q = vb->vb2_queue;\n\n\tif (q->is_output) {\n\t\t \n\t\tif (q->copy_timestamp)\n\t\t\tvb->timestamp = v4l2_buffer_get_timestamp(b);\n\t\tvbuf->flags |= b->flags & V4L2_BUF_FLAG_TIMECODE;\n\t\tif (b->flags & V4L2_BUF_FLAG_TIMECODE)\n\t\t\tvbuf->timecode = b->timecode;\n\t}\n};\n\nstatic void vb2_warn_zero_bytesused(struct vb2_buffer *vb)\n{\n\tstatic bool check_once;\n\n\tif (check_once)\n\t\treturn;\n\n\tcheck_once = true;\n\n\tpr_warn(\"use of bytesused == 0 is deprecated and will be removed in the future,\\n\");\n\tif (vb->vb2_queue->allow_zero_bytesused)\n\t\tpr_warn(\"use VIDIOC_DECODER_CMD(V4L2_DEC_CMD_STOP) instead.\\n\");\n\telse\n\t\tpr_warn(\"use the actual size instead.\\n\");\n}\n\nstatic int vb2_fill_vb2_v4l2_buffer(struct vb2_buffer *vb, struct v4l2_buffer *b)\n{\n\tstruct vb2_queue *q = vb->vb2_queue;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_plane *planes = vbuf->planes;\n\tunsigned int plane;\n\tint ret;\n\n\tret = __verify_length(vb, b);\n\tif (ret < 0) {\n\t\tdprintk(q, 1, \"plane parameters verification failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (b->field == V4L2_FIELD_ALTERNATE && q->is_output) {\n\t\t \n\t\tdprintk(q, 1, \"the field is incorrectly set to ALTERNATE for an output buffer\\n\");\n\t\treturn -EINVAL;\n\t}\n\tvbuf->sequence = 0;\n\tvbuf->request_fd = -1;\n\tvbuf->is_held = false;\n\n\tif (V4L2_TYPE_IS_MULTIPLANAR(b->type)) {\n\t\tswitch (b->memory) {\n\t\tcase VB2_MEMORY_USERPTR:\n\t\t\tfor (plane = 0; plane < vb->num_planes; ++plane) {\n\t\t\t\tplanes[plane].m.userptr =\n\t\t\t\t\tb->m.planes[plane].m.userptr;\n\t\t\t\tplanes[plane].length =\n\t\t\t\t\tb->m.planes[plane].length;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VB2_MEMORY_DMABUF:\n\t\t\tfor (plane = 0; plane < vb->num_planes; ++plane) {\n\t\t\t\tplanes[plane].m.fd =\n\t\t\t\t\tb->m.planes[plane].m.fd;\n\t\t\t\tplanes[plane].length =\n\t\t\t\t\tb->m.planes[plane].length;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfor (plane = 0; plane < vb->num_planes; ++plane) {\n\t\t\t\tplanes[plane].m.offset =\n\t\t\t\t\tvb->planes[plane].m.offset;\n\t\t\t\tplanes[plane].length =\n\t\t\t\t\tvb->planes[plane].length;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (V4L2_TYPE_IS_OUTPUT(b->type)) {\n\t\t\t \n\t\t\tfor (plane = 0; plane < vb->num_planes; ++plane) {\n\t\t\t\tstruct vb2_plane *pdst = &planes[plane];\n\t\t\t\tstruct v4l2_plane *psrc = &b->m.planes[plane];\n\n\t\t\t\tif (psrc->bytesused == 0)\n\t\t\t\t\tvb2_warn_zero_bytesused(vb);\n\n\t\t\t\tif (vb->vb2_queue->allow_zero_bytesused)\n\t\t\t\t\tpdst->bytesused = psrc->bytesused;\n\t\t\t\telse\n\t\t\t\t\tpdst->bytesused = psrc->bytesused ?\n\t\t\t\t\t\tpsrc->bytesused : pdst->length;\n\t\t\t\tpdst->data_offset = psrc->data_offset;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tswitch (b->memory) {\n\t\tcase VB2_MEMORY_USERPTR:\n\t\t\tplanes[0].m.userptr = b->m.userptr;\n\t\t\tplanes[0].length = b->length;\n\t\t\tbreak;\n\t\tcase VB2_MEMORY_DMABUF:\n\t\t\tplanes[0].m.fd = b->m.fd;\n\t\t\tplanes[0].length = b->length;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tplanes[0].m.offset = vb->planes[0].m.offset;\n\t\t\tplanes[0].length = vb->planes[0].length;\n\t\t\tbreak;\n\t\t}\n\n\t\tplanes[0].data_offset = 0;\n\t\tif (V4L2_TYPE_IS_OUTPUT(b->type)) {\n\t\t\tif (b->bytesused == 0)\n\t\t\t\tvb2_warn_zero_bytesused(vb);\n\n\t\t\tif (vb->vb2_queue->allow_zero_bytesused)\n\t\t\t\tplanes[0].bytesused = b->bytesused;\n\t\t\telse\n\t\t\t\tplanes[0].bytesused = b->bytesused ?\n\t\t\t\t\tb->bytesused : planes[0].length;\n\t\t} else\n\t\t\tplanes[0].bytesused = 0;\n\n\t}\n\n\t \n\tvbuf->flags = b->flags & ~V4L2_BUFFER_MASK_FLAGS;\n\tif (!vb->vb2_queue->copy_timestamp || V4L2_TYPE_IS_CAPTURE(b->type)) {\n\t\t \n\t\tvbuf->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\t}\n\n\tif (V4L2_TYPE_IS_OUTPUT(b->type)) {\n\t\t \n\t\tvbuf->flags &= ~V4L2_BUF_FLAG_TIMECODE;\n\t\tvbuf->field = b->field;\n\t\tif (!(q->subsystem_flags & VB2_V4L2_FL_SUPPORTS_M2M_HOLD_CAPTURE_BUF))\n\t\t\tvbuf->flags &= ~V4L2_BUF_FLAG_M2M_HOLD_CAPTURE_BUF;\n\t} else {\n\t\t \n\t\tvbuf->flags &= ~V4L2_BUFFER_OUT_FLAGS;\n\t\t \n\t\tvbuf->flags &= ~V4L2_BUF_FLAG_LAST;\n\t}\n\n\treturn 0;\n}\n\nstatic void set_buffer_cache_hints(struct vb2_queue *q,\n\t\t\t\t   struct vb2_buffer *vb,\n\t\t\t\t   struct v4l2_buffer *b)\n{\n\tif (!vb2_queue_allows_cache_hints(q)) {\n\t\t \n\t\tb->flags &= ~V4L2_BUF_FLAG_NO_CACHE_INVALIDATE;\n\t\tb->flags &= ~V4L2_BUF_FLAG_NO_CACHE_CLEAN;\n\t\treturn;\n\t}\n\n\tif (b->flags & V4L2_BUF_FLAG_NO_CACHE_INVALIDATE)\n\t\tvb->skip_cache_sync_on_finish = 1;\n\n\tif (b->flags & V4L2_BUF_FLAG_NO_CACHE_CLEAN)\n\t\tvb->skip_cache_sync_on_prepare = 1;\n}\n\nstatic int vb2_queue_or_prepare_buf(struct vb2_queue *q, struct media_device *mdev,\n\t\t\t\t    struct v4l2_buffer *b, bool is_prepare,\n\t\t\t\t    struct media_request **p_req)\n{\n\tconst char *opname = is_prepare ? \"prepare_buf\" : \"qbuf\";\n\tstruct media_request *req;\n\tstruct vb2_v4l2_buffer *vbuf;\n\tstruct vb2_buffer *vb;\n\tint ret;\n\n\tif (b->type != q->type) {\n\t\tdprintk(q, 1, \"%s: invalid buffer type\\n\", opname);\n\t\treturn -EINVAL;\n\t}\n\n\tif (b->index >= q->num_buffers) {\n\t\tdprintk(q, 1, \"%s: buffer index out of range\\n\", opname);\n\t\treturn -EINVAL;\n\t}\n\n\tif (q->bufs[b->index] == NULL) {\n\t\t \n\t\tdprintk(q, 1, \"%s: buffer is NULL\\n\", opname);\n\t\treturn -EINVAL;\n\t}\n\n\tif (b->memory != q->memory) {\n\t\tdprintk(q, 1, \"%s: invalid memory type\\n\", opname);\n\t\treturn -EINVAL;\n\t}\n\n\tvb = q->bufs[b->index];\n\tvbuf = to_vb2_v4l2_buffer(vb);\n\tret = __verify_planes_array(vb, b);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!is_prepare && (b->flags & V4L2_BUF_FLAG_REQUEST_FD) &&\n\t    vb->state != VB2_BUF_STATE_DEQUEUED) {\n\t\tdprintk(q, 1, \"%s: buffer is not in dequeued state\\n\", opname);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!vb->prepared) {\n\t\tset_buffer_cache_hints(q, vb, b);\n\t\t \n\t\tmemset(vbuf->planes, 0,\n\t\t       sizeof(vbuf->planes[0]) * vb->num_planes);\n\t\tret = vb2_fill_vb2_v4l2_buffer(vb, b);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (is_prepare)\n\t\treturn 0;\n\n\tif (!(b->flags & V4L2_BUF_FLAG_REQUEST_FD)) {\n\t\tif (q->requires_requests) {\n\t\t\tdprintk(q, 1, \"%s: queue requires requests\\n\", opname);\n\t\t\treturn -EBADR;\n\t\t}\n\t\tif (q->uses_requests) {\n\t\t\tdprintk(q, 1, \"%s: queue uses requests\\n\", opname);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\treturn 0;\n\t} else if (!q->supports_requests) {\n\t\tdprintk(q, 1, \"%s: queue does not support requests\\n\", opname);\n\t\treturn -EBADR;\n\t} else if (q->uses_qbuf) {\n\t\tdprintk(q, 1, \"%s: queue does not use requests\\n\", opname);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (WARN_ON(!q->lock || !p_req))\n\t\treturn -EINVAL;\n\n\t \n\tif (WARN_ON(!q->ops->buf_request_complete))\n\t\treturn -EINVAL;\n\t \n\tif (WARN_ON((q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT ||\n\t\t     q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) &&\n\t\t    !q->ops->buf_out_validate))\n\t\treturn -EINVAL;\n\n\treq = media_request_get_by_fd(mdev, b->request_fd);\n\tif (IS_ERR(req)) {\n\t\tdprintk(q, 1, \"%s: invalid request_fd\\n\", opname);\n\t\treturn PTR_ERR(req);\n\t}\n\n\t \n\tif (req->state != MEDIA_REQUEST_STATE_IDLE &&\n\t    req->state != MEDIA_REQUEST_STATE_UPDATING) {\n\t\tdprintk(q, 1, \"%s: request is not idle\\n\", opname);\n\t\tmedia_request_put(req);\n\t\treturn -EBUSY;\n\t}\n\n\t*p_req = req;\n\tvbuf->request_fd = b->request_fd;\n\n\treturn 0;\n}\n\n \nstatic void __fill_v4l2_buffer(struct vb2_buffer *vb, void *pb)\n{\n\tstruct v4l2_buffer *b = pb;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_queue *q = vb->vb2_queue;\n\tunsigned int plane;\n\n\t \n\tb->index = vb->index;\n\tb->type = vb->type;\n\tb->memory = vb->memory;\n\tb->bytesused = 0;\n\n\tb->flags = vbuf->flags;\n\tb->field = vbuf->field;\n\tv4l2_buffer_set_timestamp(b, vb->timestamp);\n\tb->timecode = vbuf->timecode;\n\tb->sequence = vbuf->sequence;\n\tb->reserved2 = 0;\n\tb->request_fd = 0;\n\n\tif (q->is_multiplanar) {\n\t\t \n\t\tb->length = vb->num_planes;\n\t\tfor (plane = 0; plane < vb->num_planes; ++plane) {\n\t\t\tstruct v4l2_plane *pdst = &b->m.planes[plane];\n\t\t\tstruct vb2_plane *psrc = &vb->planes[plane];\n\n\t\t\tpdst->bytesused = psrc->bytesused;\n\t\t\tpdst->length = psrc->length;\n\t\t\tif (q->memory == VB2_MEMORY_MMAP)\n\t\t\t\tpdst->m.mem_offset = psrc->m.offset;\n\t\t\telse if (q->memory == VB2_MEMORY_USERPTR)\n\t\t\t\tpdst->m.userptr = psrc->m.userptr;\n\t\t\telse if (q->memory == VB2_MEMORY_DMABUF)\n\t\t\t\tpdst->m.fd = psrc->m.fd;\n\t\t\tpdst->data_offset = psrc->data_offset;\n\t\t\tmemset(pdst->reserved, 0, sizeof(pdst->reserved));\n\t\t}\n\t} else {\n\t\t \n\t\tb->length = vb->planes[0].length;\n\t\tb->bytesused = vb->planes[0].bytesused;\n\t\tif (q->memory == VB2_MEMORY_MMAP)\n\t\t\tb->m.offset = vb->planes[0].m.offset;\n\t\telse if (q->memory == VB2_MEMORY_USERPTR)\n\t\t\tb->m.userptr = vb->planes[0].m.userptr;\n\t\telse if (q->memory == VB2_MEMORY_DMABUF)\n\t\t\tb->m.fd = vb->planes[0].m.fd;\n\t}\n\n\t \n\tb->flags &= ~V4L2_BUFFER_MASK_FLAGS;\n\tb->flags |= q->timestamp_flags & V4L2_BUF_FLAG_TIMESTAMP_MASK;\n\tif (!q->copy_timestamp) {\n\t\t \n\t\tb->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\t\tb->flags |= q->timestamp_flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\t}\n\n\tswitch (vb->state) {\n\tcase VB2_BUF_STATE_QUEUED:\n\tcase VB2_BUF_STATE_ACTIVE:\n\t\tb->flags |= V4L2_BUF_FLAG_QUEUED;\n\t\tbreak;\n\tcase VB2_BUF_STATE_IN_REQUEST:\n\t\tb->flags |= V4L2_BUF_FLAG_IN_REQUEST;\n\t\tbreak;\n\tcase VB2_BUF_STATE_ERROR:\n\t\tb->flags |= V4L2_BUF_FLAG_ERROR;\n\t\tfallthrough;\n\tcase VB2_BUF_STATE_DONE:\n\t\tb->flags |= V4L2_BUF_FLAG_DONE;\n\t\tbreak;\n\tcase VB2_BUF_STATE_PREPARING:\n\tcase VB2_BUF_STATE_DEQUEUED:\n\t\t \n\t\tbreak;\n\t}\n\n\tif ((vb->state == VB2_BUF_STATE_DEQUEUED ||\n\t     vb->state == VB2_BUF_STATE_IN_REQUEST) &&\n\t    vb->synced && vb->prepared)\n\t\tb->flags |= V4L2_BUF_FLAG_PREPARED;\n\n\tif (vb2_buffer_in_use(q, vb))\n\t\tb->flags |= V4L2_BUF_FLAG_MAPPED;\n\tif (vbuf->request_fd >= 0) {\n\t\tb->flags |= V4L2_BUF_FLAG_REQUEST_FD;\n\t\tb->request_fd = vbuf->request_fd;\n\t}\n}\n\n \nstatic int __fill_vb2_buffer(struct vb2_buffer *vb, struct vb2_plane *planes)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tunsigned int plane;\n\n\tif (!vb->vb2_queue->copy_timestamp)\n\t\tvb->timestamp = 0;\n\n\tfor (plane = 0; plane < vb->num_planes; ++plane) {\n\t\tif (vb->vb2_queue->memory != VB2_MEMORY_MMAP) {\n\t\t\tplanes[plane].m = vbuf->planes[plane].m;\n\t\t\tplanes[plane].length = vbuf->planes[plane].length;\n\t\t}\n\t\tplanes[plane].bytesused = vbuf->planes[plane].bytesused;\n\t\tplanes[plane].data_offset = vbuf->planes[plane].data_offset;\n\t}\n\treturn 0;\n}\n\nstatic const struct vb2_buf_ops v4l2_buf_ops = {\n\t.verify_planes_array\t= __verify_planes_array_core,\n\t.init_buffer\t\t= __init_vb2_v4l2_buffer,\n\t.fill_user_buffer\t= __fill_v4l2_buffer,\n\t.fill_vb2_buffer\t= __fill_vb2_buffer,\n\t.copy_timestamp\t\t= __copy_timestamp,\n};\n\nstruct vb2_buffer *vb2_find_buffer(struct vb2_queue *q, u64 timestamp)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < q->num_buffers; i++)\n\t\tif (q->bufs[i]->copied_timestamp &&\n\t\t    q->bufs[i]->timestamp == timestamp)\n\t\t\treturn vb2_get_buffer(q, i);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(vb2_find_buffer);\n\n \nint vb2_querybuf(struct vb2_queue *q, struct v4l2_buffer *b)\n{\n\tstruct vb2_buffer *vb;\n\tint ret;\n\n\tif (b->type != q->type) {\n\t\tdprintk(q, 1, \"wrong buffer type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (b->index >= q->num_buffers) {\n\t\tdprintk(q, 1, \"buffer index out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\tvb = q->bufs[b->index];\n\tret = __verify_planes_array(vb, b);\n\tif (!ret)\n\t\tvb2_core_querybuf(q, b->index, b);\n\treturn ret;\n}\nEXPORT_SYMBOL(vb2_querybuf);\n\nstatic void fill_buf_caps(struct vb2_queue *q, u32 *caps)\n{\n\t*caps = V4L2_BUF_CAP_SUPPORTS_ORPHANED_BUFS;\n\tif (q->io_modes & VB2_MMAP)\n\t\t*caps |= V4L2_BUF_CAP_SUPPORTS_MMAP;\n\tif (q->io_modes & VB2_USERPTR)\n\t\t*caps |= V4L2_BUF_CAP_SUPPORTS_USERPTR;\n\tif (q->io_modes & VB2_DMABUF)\n\t\t*caps |= V4L2_BUF_CAP_SUPPORTS_DMABUF;\n\tif (q->subsystem_flags & VB2_V4L2_FL_SUPPORTS_M2M_HOLD_CAPTURE_BUF)\n\t\t*caps |= V4L2_BUF_CAP_SUPPORTS_M2M_HOLD_CAPTURE_BUF;\n\tif (q->allow_cache_hints && q->io_modes & VB2_MMAP)\n\t\t*caps |= V4L2_BUF_CAP_SUPPORTS_MMAP_CACHE_HINTS;\n#ifdef CONFIG_MEDIA_CONTROLLER_REQUEST_API\n\tif (q->supports_requests)\n\t\t*caps |= V4L2_BUF_CAP_SUPPORTS_REQUESTS;\n#endif\n}\n\nstatic void validate_memory_flags(struct vb2_queue *q,\n\t\t\t\t  int memory,\n\t\t\t\t  u32 *flags)\n{\n\tif (!q->allow_cache_hints || memory != V4L2_MEMORY_MMAP) {\n\t\t \n\t\t*flags = 0;\n\t} else {\n\t\t \n\t\t*flags &= V4L2_MEMORY_FLAG_NON_COHERENT;\n\t}\n}\n\nint vb2_reqbufs(struct vb2_queue *q, struct v4l2_requestbuffers *req)\n{\n\tint ret = vb2_verify_memory_type(q, req->memory, req->type);\n\tu32 flags = req->flags;\n\n\tfill_buf_caps(q, &req->capabilities);\n\tvalidate_memory_flags(q, req->memory, &flags);\n\treq->flags = flags;\n\treturn ret ? ret : vb2_core_reqbufs(q, req->memory,\n\t\t\t\t\t    req->flags, &req->count);\n}\nEXPORT_SYMBOL_GPL(vb2_reqbufs);\n\nint vb2_prepare_buf(struct vb2_queue *q, struct media_device *mdev,\n\t\t    struct v4l2_buffer *b)\n{\n\tint ret;\n\n\tif (vb2_fileio_is_active(q)) {\n\t\tdprintk(q, 1, \"file io in progress\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (b->flags & V4L2_BUF_FLAG_REQUEST_FD)\n\t\treturn -EINVAL;\n\n\tret = vb2_queue_or_prepare_buf(q, mdev, b, true, NULL);\n\n\treturn ret ? ret : vb2_core_prepare_buf(q, b->index, b);\n}\nEXPORT_SYMBOL_GPL(vb2_prepare_buf);\n\nint vb2_create_bufs(struct vb2_queue *q, struct v4l2_create_buffers *create)\n{\n\tunsigned requested_planes = 1;\n\tunsigned requested_sizes[VIDEO_MAX_PLANES];\n\tstruct v4l2_format *f = &create->format;\n\tint ret = vb2_verify_memory_type(q, create->memory, f->type);\n\tunsigned i;\n\n\tfill_buf_caps(q, &create->capabilities);\n\tvalidate_memory_flags(q, create->memory, &create->flags);\n\tcreate->index = q->num_buffers;\n\tif (create->count == 0)\n\t\treturn ret != -EBUSY ? ret : 0;\n\n\tswitch (f->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\trequested_planes = f->fmt.pix_mp.num_planes;\n\t\tif (requested_planes == 0 ||\n\t\t    requested_planes > VIDEO_MAX_PLANES)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < requested_planes; i++)\n\t\t\trequested_sizes[i] =\n\t\t\t\tf->fmt.pix_mp.plane_fmt[i].sizeimage;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\trequested_sizes[0] = f->fmt.pix.sizeimage;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n\tcase V4L2_BUF_TYPE_VBI_OUTPUT:\n\t\trequested_sizes[0] = f->fmt.vbi.samples_per_line *\n\t\t\t(f->fmt.vbi.count[0] + f->fmt.vbi.count[1]);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\n\tcase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\n\t\trequested_sizes[0] = f->fmt.sliced.io_size;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_SDR_CAPTURE:\n\tcase V4L2_BUF_TYPE_SDR_OUTPUT:\n\t\trequested_sizes[0] = f->fmt.sdr.buffersize;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_META_CAPTURE:\n\tcase V4L2_BUF_TYPE_META_OUTPUT:\n\t\trequested_sizes[0] = f->fmt.meta.buffersize;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < requested_planes; i++)\n\t\tif (requested_sizes[i] == 0)\n\t\t\treturn -EINVAL;\n\treturn ret ? ret : vb2_core_create_bufs(q, create->memory,\n\t\t\t\t\t\tcreate->flags,\n\t\t\t\t\t\t&create->count,\n\t\t\t\t\t\trequested_planes,\n\t\t\t\t\t\trequested_sizes);\n}\nEXPORT_SYMBOL_GPL(vb2_create_bufs);\n\nint vb2_qbuf(struct vb2_queue *q, struct media_device *mdev,\n\t     struct v4l2_buffer *b)\n{\n\tstruct media_request *req = NULL;\n\tint ret;\n\n\tif (vb2_fileio_is_active(q)) {\n\t\tdprintk(q, 1, \"file io in progress\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tret = vb2_queue_or_prepare_buf(q, mdev, b, false, &req);\n\tif (ret)\n\t\treturn ret;\n\tret = vb2_core_qbuf(q, b->index, b, req);\n\tif (req)\n\t\tmedia_request_put(req);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vb2_qbuf);\n\nint vb2_dqbuf(struct vb2_queue *q, struct v4l2_buffer *b, bool nonblocking)\n{\n\tint ret;\n\n\tif (vb2_fileio_is_active(q)) {\n\t\tdprintk(q, 1, \"file io in progress\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (b->type != q->type) {\n\t\tdprintk(q, 1, \"invalid buffer type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = vb2_core_dqbuf(q, NULL, b, nonblocking);\n\n\tif (!q->is_output &&\n\t    b->flags & V4L2_BUF_FLAG_DONE &&\n\t    b->flags & V4L2_BUF_FLAG_LAST)\n\t\tq->last_buffer_dequeued = true;\n\n\t \n\tb->flags &= ~V4L2_BUF_FLAG_DONE;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vb2_dqbuf);\n\nint vb2_streamon(struct vb2_queue *q, enum v4l2_buf_type type)\n{\n\tif (vb2_fileio_is_active(q)) {\n\t\tdprintk(q, 1, \"file io in progress\\n\");\n\t\treturn -EBUSY;\n\t}\n\treturn vb2_core_streamon(q, type);\n}\nEXPORT_SYMBOL_GPL(vb2_streamon);\n\nint vb2_streamoff(struct vb2_queue *q, enum v4l2_buf_type type)\n{\n\tif (vb2_fileio_is_active(q)) {\n\t\tdprintk(q, 1, \"file io in progress\\n\");\n\t\treturn -EBUSY;\n\t}\n\treturn vb2_core_streamoff(q, type);\n}\nEXPORT_SYMBOL_GPL(vb2_streamoff);\n\nint vb2_expbuf(struct vb2_queue *q, struct v4l2_exportbuffer *eb)\n{\n\treturn vb2_core_expbuf(q, &eb->fd, eb->type, eb->index,\n\t\t\t\teb->plane, eb->flags);\n}\nEXPORT_SYMBOL_GPL(vb2_expbuf);\n\nint vb2_queue_init_name(struct vb2_queue *q, const char *name)\n{\n\t \n\tif (WARN_ON(!q)\t\t\t  ||\n\t    WARN_ON(q->timestamp_flags &\n\t\t    ~(V4L2_BUF_FLAG_TIMESTAMP_MASK |\n\t\t      V4L2_BUF_FLAG_TSTAMP_SRC_MASK)))\n\t\treturn -EINVAL;\n\n\t \n\tWARN_ON((q->timestamp_flags & V4L2_BUF_FLAG_TIMESTAMP_MASK) ==\n\t\tV4L2_BUF_FLAG_TIMESTAMP_UNKNOWN);\n\n\t \n\tif (WARN_ON(VB2_MEMORY_MMAP != (int)V4L2_MEMORY_MMAP)\n\t\t|| WARN_ON(VB2_MEMORY_USERPTR != (int)V4L2_MEMORY_USERPTR)\n\t\t|| WARN_ON(VB2_MEMORY_DMABUF != (int)V4L2_MEMORY_DMABUF))\n\t\treturn -EINVAL;\n\n\tif (q->buf_struct_size == 0)\n\t\tq->buf_struct_size = sizeof(struct vb2_v4l2_buffer);\n\n\tq->buf_ops = &v4l2_buf_ops;\n\tq->is_multiplanar = V4L2_TYPE_IS_MULTIPLANAR(q->type);\n\tq->is_output = V4L2_TYPE_IS_OUTPUT(q->type);\n\tq->copy_timestamp = (q->timestamp_flags & V4L2_BUF_FLAG_TIMESTAMP_MASK)\n\t\t\t== V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\t \n\tq->quirk_poll_must_check_waiting_for_buffers = true;\n\n\tif (name)\n\t\tstrscpy(q->name, name, sizeof(q->name));\n\telse\n\t\tq->name[0] = '\\0';\n\n\treturn vb2_core_queue_init(q);\n}\nEXPORT_SYMBOL_GPL(vb2_queue_init_name);\n\nint vb2_queue_init(struct vb2_queue *q)\n{\n\treturn vb2_queue_init_name(q, NULL);\n}\nEXPORT_SYMBOL_GPL(vb2_queue_init);\n\nvoid vb2_queue_release(struct vb2_queue *q)\n{\n\tvb2_core_queue_release(q);\n}\nEXPORT_SYMBOL_GPL(vb2_queue_release);\n\nint vb2_queue_change_type(struct vb2_queue *q, unsigned int type)\n{\n\tif (type == q->type)\n\t\treturn 0;\n\n\tif (vb2_is_busy(q))\n\t\treturn -EBUSY;\n\n\tq->type = type;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vb2_queue_change_type);\n\n__poll_t vb2_poll(struct vb2_queue *q, struct file *file, poll_table *wait)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\t__poll_t res;\n\n\tres = vb2_core_poll(q, file, wait);\n\n\tif (test_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags)) {\n\t\tstruct v4l2_fh *fh = file->private_data;\n\n\t\tpoll_wait(file, &fh->wait, wait);\n\t\tif (v4l2_event_pending(fh))\n\t\t\tres |= EPOLLPRI;\n\t}\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(vb2_poll);\n\n \n\n \n\nint vb2_ioctl_reqbufs(struct file *file, void *priv,\n\t\t\t  struct v4l2_requestbuffers *p)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tint res = vb2_verify_memory_type(vdev->queue, p->memory, p->type);\n\tu32 flags = p->flags;\n\n\tfill_buf_caps(vdev->queue, &p->capabilities);\n\tvalidate_memory_flags(vdev->queue, p->memory, &flags);\n\tp->flags = flags;\n\tif (res)\n\t\treturn res;\n\tif (vb2_queue_is_busy(vdev->queue, file))\n\t\treturn -EBUSY;\n\tres = vb2_core_reqbufs(vdev->queue, p->memory, p->flags, &p->count);\n\t \n\tif (res == 0)\n\t\tvdev->queue->owner = p->count ? file->private_data : NULL;\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(vb2_ioctl_reqbufs);\n\nint vb2_ioctl_create_bufs(struct file *file, void *priv,\n\t\t\t  struct v4l2_create_buffers *p)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tint res = vb2_verify_memory_type(vdev->queue, p->memory,\n\t\t\tp->format.type);\n\n\tp->index = vdev->queue->num_buffers;\n\tfill_buf_caps(vdev->queue, &p->capabilities);\n\tvalidate_memory_flags(vdev->queue, p->memory, &p->flags);\n\t \n\tif (p->count == 0)\n\t\treturn res != -EBUSY ? res : 0;\n\tif (res)\n\t\treturn res;\n\tif (vb2_queue_is_busy(vdev->queue, file))\n\t\treturn -EBUSY;\n\n\tres = vb2_create_bufs(vdev->queue, p);\n\tif (res == 0)\n\t\tvdev->queue->owner = file->private_data;\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(vb2_ioctl_create_bufs);\n\nint vb2_ioctl_prepare_buf(struct file *file, void *priv,\n\t\t\t  struct v4l2_buffer *p)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vb2_queue_is_busy(vdev->queue, file))\n\t\treturn -EBUSY;\n\treturn vb2_prepare_buf(vdev->queue, vdev->v4l2_dev->mdev, p);\n}\nEXPORT_SYMBOL_GPL(vb2_ioctl_prepare_buf);\n\nint vb2_ioctl_querybuf(struct file *file, void *priv, struct v4l2_buffer *p)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\t \n\treturn vb2_querybuf(vdev->queue, p);\n}\nEXPORT_SYMBOL_GPL(vb2_ioctl_querybuf);\n\nint vb2_ioctl_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vb2_queue_is_busy(vdev->queue, file))\n\t\treturn -EBUSY;\n\treturn vb2_qbuf(vdev->queue, vdev->v4l2_dev->mdev, p);\n}\nEXPORT_SYMBOL_GPL(vb2_ioctl_qbuf);\n\nint vb2_ioctl_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vb2_queue_is_busy(vdev->queue, file))\n\t\treturn -EBUSY;\n\treturn vb2_dqbuf(vdev->queue, p, file->f_flags & O_NONBLOCK);\n}\nEXPORT_SYMBOL_GPL(vb2_ioctl_dqbuf);\n\nint vb2_ioctl_streamon(struct file *file, void *priv, enum v4l2_buf_type i)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vb2_queue_is_busy(vdev->queue, file))\n\t\treturn -EBUSY;\n\treturn vb2_streamon(vdev->queue, i);\n}\nEXPORT_SYMBOL_GPL(vb2_ioctl_streamon);\n\nint vb2_ioctl_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vb2_queue_is_busy(vdev->queue, file))\n\t\treturn -EBUSY;\n\treturn vb2_streamoff(vdev->queue, i);\n}\nEXPORT_SYMBOL_GPL(vb2_ioctl_streamoff);\n\nint vb2_ioctl_expbuf(struct file *file, void *priv, struct v4l2_exportbuffer *p)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vb2_queue_is_busy(vdev->queue, file))\n\t\treturn -EBUSY;\n\treturn vb2_expbuf(vdev->queue, p);\n}\nEXPORT_SYMBOL_GPL(vb2_ioctl_expbuf);\n\n \n\nint vb2_fop_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\treturn vb2_mmap(vdev->queue, vma);\n}\nEXPORT_SYMBOL_GPL(vb2_fop_mmap);\n\nint _vb2_fop_release(struct file *file, struct mutex *lock)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (lock)\n\t\tmutex_lock(lock);\n\tif (file->private_data == vdev->queue->owner) {\n\t\tvb2_queue_release(vdev->queue);\n\t\tvdev->queue->owner = NULL;\n\t}\n\tif (lock)\n\t\tmutex_unlock(lock);\n\treturn v4l2_fh_release(file);\n}\nEXPORT_SYMBOL_GPL(_vb2_fop_release);\n\nint vb2_fop_release(struct file *file)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct mutex *lock = vdev->queue->lock ? vdev->queue->lock : vdev->lock;\n\n\treturn _vb2_fop_release(file, lock);\n}\nEXPORT_SYMBOL_GPL(vb2_fop_release);\n\nssize_t vb2_fop_write(struct file *file, const char __user *buf,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct mutex *lock = vdev->queue->lock ? vdev->queue->lock : vdev->lock;\n\tint err = -EBUSY;\n\n\tif (!(vdev->queue->io_modes & VB2_WRITE))\n\t\treturn -EINVAL;\n\tif (lock && mutex_lock_interruptible(lock))\n\t\treturn -ERESTARTSYS;\n\tif (vb2_queue_is_busy(vdev->queue, file))\n\t\tgoto exit;\n\terr = vb2_write(vdev->queue, buf, count, ppos,\n\t\t       file->f_flags & O_NONBLOCK);\n\tif (vdev->queue->fileio)\n\t\tvdev->queue->owner = file->private_data;\nexit:\n\tif (lock)\n\t\tmutex_unlock(lock);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vb2_fop_write);\n\nssize_t vb2_fop_read(struct file *file, char __user *buf,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct mutex *lock = vdev->queue->lock ? vdev->queue->lock : vdev->lock;\n\tint err = -EBUSY;\n\n\tif (!(vdev->queue->io_modes & VB2_READ))\n\t\treturn -EINVAL;\n\tif (lock && mutex_lock_interruptible(lock))\n\t\treturn -ERESTARTSYS;\n\tif (vb2_queue_is_busy(vdev->queue, file))\n\t\tgoto exit;\n\tvdev->queue->owner = file->private_data;\n\terr = vb2_read(vdev->queue, buf, count, ppos,\n\t\t       file->f_flags & O_NONBLOCK);\n\tif (!vdev->queue->fileio)\n\t\tvdev->queue->owner = NULL;\nexit:\n\tif (lock)\n\t\tmutex_unlock(lock);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vb2_fop_read);\n\n__poll_t vb2_fop_poll(struct file *file, poll_table *wait)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct vb2_queue *q = vdev->queue;\n\tstruct mutex *lock = q->lock ? q->lock : vdev->lock;\n\t__poll_t res;\n\tvoid *fileio;\n\n\t \n\tWARN_ON(!lock);\n\n\tif (lock && mutex_lock_interruptible(lock))\n\t\treturn EPOLLERR;\n\n\tfileio = q->fileio;\n\n\tres = vb2_poll(vdev->queue, file, wait);\n\n\t \n\tif (!fileio && q->fileio)\n\t\tq->owner = file->private_data;\n\tif (lock)\n\t\tmutex_unlock(lock);\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(vb2_fop_poll);\n\n#ifndef CONFIG_MMU\nunsigned long vb2_fop_get_unmapped_area(struct file *file, unsigned long addr,\n\t\tunsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\treturn vb2_get_unmapped_area(vdev->queue, addr, len, pgoff, flags);\n}\nEXPORT_SYMBOL_GPL(vb2_fop_get_unmapped_area);\n#endif\n\nvoid vb2_video_unregister_device(struct video_device *vdev)\n{\n\t \n\tif (!vdev || !video_is_registered(vdev))\n\t\treturn;\n\n\t \n\tWARN_ON(!vdev->queue);\n\n\t \n\tget_device(&vdev->dev);\n\tvideo_unregister_device(vdev);\n\tif (vdev->queue && vdev->queue->owner) {\n\t\tstruct mutex *lock = vdev->queue->lock ?\n\t\t\tvdev->queue->lock : vdev->lock;\n\n\t\tif (lock)\n\t\t\tmutex_lock(lock);\n\t\tvb2_queue_release(vdev->queue);\n\t\tvdev->queue->owner = NULL;\n\t\tif (lock)\n\t\t\tmutex_unlock(lock);\n\t}\n\t \n\tput_device(&vdev->dev);\n}\nEXPORT_SYMBOL_GPL(vb2_video_unregister_device);\n\n \n\nvoid vb2_ops_wait_prepare(struct vb2_queue *vq)\n{\n\tmutex_unlock(vq->lock);\n}\nEXPORT_SYMBOL_GPL(vb2_ops_wait_prepare);\n\nvoid vb2_ops_wait_finish(struct vb2_queue *vq)\n{\n\tmutex_lock(vq->lock);\n}\nEXPORT_SYMBOL_GPL(vb2_ops_wait_finish);\n\n \nint vb2_request_validate(struct media_request *req)\n{\n\tstruct media_request_object *obj;\n\tint ret = 0;\n\n\tif (!vb2_request_buffer_cnt(req))\n\t\treturn -ENOENT;\n\n\tlist_for_each_entry(obj, &req->objects, list) {\n\t\tif (!obj->ops->prepare)\n\t\t\tcontinue;\n\n\t\tret = obj->ops->prepare(obj);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (ret) {\n\t\tlist_for_each_entry_continue_reverse(obj, &req->objects, list)\n\t\t\tif (obj->ops->unprepare)\n\t\t\t\tobj->ops->unprepare(obj);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vb2_request_validate);\n\nvoid vb2_request_queue(struct media_request *req)\n{\n\tstruct media_request_object *obj, *obj_safe;\n\n\t \n\tlist_for_each_entry_safe(obj, obj_safe, &req->objects, list)\n\t\tif (obj->ops->queue)\n\t\t\tobj->ops->queue(obj);\n}\nEXPORT_SYMBOL_GPL(vb2_request_queue);\n\nMODULE_DESCRIPTION(\"Driver helper framework for Video for Linux 2\");\nMODULE_AUTHOR(\"Pawel Osciak <pawel@osciak.com>, Marek Szyprowski\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}