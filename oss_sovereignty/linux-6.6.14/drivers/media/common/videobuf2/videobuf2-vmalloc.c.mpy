{
  "module_name": "videobuf2-vmalloc.c",
  "hash_id": "85185d0684f389bd59ce781cee5d927fbb007c27ce7cbfe43ae937cc3060ddab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/videobuf2/videobuf2-vmalloc.c",
  "human_readable_source": " \n\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/refcount.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-vmalloc.h>\n#include <media/videobuf2-memops.h>\n\nstruct vb2_vmalloc_buf {\n\tvoid\t\t\t\t*vaddr;\n\tstruct frame_vector\t\t*vec;\n\tenum dma_data_direction\t\tdma_dir;\n\tunsigned long\t\t\tsize;\n\trefcount_t\t\t\trefcount;\n\tstruct vb2_vmarea_handler\thandler;\n\tstruct dma_buf\t\t\t*dbuf;\n};\n\nstatic void vb2_vmalloc_put(void *buf_priv);\n\nstatic void *vb2_vmalloc_alloc(struct vb2_buffer *vb, struct device *dev,\n\t\t\t       unsigned long size)\n{\n\tstruct vb2_vmalloc_buf *buf;\n\n\tbuf = kzalloc(sizeof(*buf), GFP_KERNEL | vb->vb2_queue->gfp_flags);\n\tif (!buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbuf->size = size;\n\tbuf->vaddr = vmalloc_user(buf->size);\n\tif (!buf->vaddr) {\n\t\tpr_debug(\"vmalloc of size %ld failed\\n\", buf->size);\n\t\tkfree(buf);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tbuf->dma_dir = vb->vb2_queue->dma_dir;\n\tbuf->handler.refcount = &buf->refcount;\n\tbuf->handler.put = vb2_vmalloc_put;\n\tbuf->handler.arg = buf;\n\n\trefcount_set(&buf->refcount, 1);\n\treturn buf;\n}\n\nstatic void vb2_vmalloc_put(void *buf_priv)\n{\n\tstruct vb2_vmalloc_buf *buf = buf_priv;\n\n\tif (refcount_dec_and_test(&buf->refcount)) {\n\t\tvfree(buf->vaddr);\n\t\tkfree(buf);\n\t}\n}\n\nstatic void *vb2_vmalloc_get_userptr(struct vb2_buffer *vb, struct device *dev,\n\t\t\t\t     unsigned long vaddr, unsigned long size)\n{\n\tstruct vb2_vmalloc_buf *buf;\n\tstruct frame_vector *vec;\n\tint n_pages, offset, i;\n\tint ret = -ENOMEM;\n\n\tbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\n\tif (!buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbuf->dma_dir = vb->vb2_queue->dma_dir;\n\toffset = vaddr & ~PAGE_MASK;\n\tbuf->size = size;\n\tvec = vb2_create_framevec(vaddr, size,\n\t\t\t\t  buf->dma_dir == DMA_FROM_DEVICE ||\n\t\t\t\t  buf->dma_dir == DMA_BIDIRECTIONAL);\n\tif (IS_ERR(vec)) {\n\t\tret = PTR_ERR(vec);\n\t\tgoto fail_pfnvec_create;\n\t}\n\tbuf->vec = vec;\n\tn_pages = frame_vector_count(vec);\n\tif (frame_vector_to_pages(vec) < 0) {\n\t\tunsigned long *nums = frame_vector_pfns(vec);\n\n\t\t \n\t\tfor (i = 1; i < n_pages; i++)\n\t\t\tif (nums[i-1] + 1 != nums[i])\n\t\t\t\tgoto fail_map;\n\t\tbuf->vaddr = (__force void *)\n\t\t\tioremap(__pfn_to_phys(nums[0]), size + offset);\n\t} else {\n\t\tbuf->vaddr = vm_map_ram(frame_vector_pages(vec), n_pages, -1);\n\t}\n\n\tif (!buf->vaddr)\n\t\tgoto fail_map;\n\tbuf->vaddr += offset;\n\treturn buf;\n\nfail_map:\n\tvb2_destroy_framevec(vec);\nfail_pfnvec_create:\n\tkfree(buf);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic void vb2_vmalloc_put_userptr(void *buf_priv)\n{\n\tstruct vb2_vmalloc_buf *buf = buf_priv;\n\tunsigned long vaddr = (unsigned long)buf->vaddr & PAGE_MASK;\n\tunsigned int i;\n\tstruct page **pages;\n\tunsigned int n_pages;\n\n\tif (!buf->vec->is_pfns) {\n\t\tn_pages = frame_vector_count(buf->vec);\n\t\tpages = frame_vector_pages(buf->vec);\n\t\tif (vaddr)\n\t\t\tvm_unmap_ram((void *)vaddr, n_pages);\n\t\tif (buf->dma_dir == DMA_FROM_DEVICE ||\n\t\t    buf->dma_dir == DMA_BIDIRECTIONAL)\n\t\t\tfor (i = 0; i < n_pages; i++)\n\t\t\t\tset_page_dirty_lock(pages[i]);\n\t} else {\n\t\tiounmap((__force void __iomem *)buf->vaddr);\n\t}\n\tvb2_destroy_framevec(buf->vec);\n\tkfree(buf);\n}\n\nstatic void *vb2_vmalloc_vaddr(struct vb2_buffer *vb, void *buf_priv)\n{\n\tstruct vb2_vmalloc_buf *buf = buf_priv;\n\n\tif (!buf->vaddr) {\n\t\tpr_err(\"Address of an unallocated plane requested or cannot map user pointer\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn buf->vaddr;\n}\n\nstatic unsigned int vb2_vmalloc_num_users(void *buf_priv)\n{\n\tstruct vb2_vmalloc_buf *buf = buf_priv;\n\treturn refcount_read(&buf->refcount);\n}\n\nstatic int vb2_vmalloc_mmap(void *buf_priv, struct vm_area_struct *vma)\n{\n\tstruct vb2_vmalloc_buf *buf = buf_priv;\n\tint ret;\n\n\tif (!buf) {\n\t\tpr_err(\"No memory to map\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = remap_vmalloc_range(vma, buf->vaddr, 0);\n\tif (ret) {\n\t\tpr_err(\"Remapping vmalloc memory, error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tvm_flags_set(vma, VM_DONTEXPAND);\n\n\t \n\tvma->vm_private_data\t= &buf->handler;\n\tvma->vm_ops\t\t= &vb2_common_vm_ops;\n\n\tvma->vm_ops->open(vma);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_HAS_DMA\n \n \n \n\nstruct vb2_vmalloc_attachment {\n\tstruct sg_table sgt;\n\tenum dma_data_direction dma_dir;\n};\n\nstatic int vb2_vmalloc_dmabuf_ops_attach(struct dma_buf *dbuf,\n\tstruct dma_buf_attachment *dbuf_attach)\n{\n\tstruct vb2_vmalloc_attachment *attach;\n\tstruct vb2_vmalloc_buf *buf = dbuf->priv;\n\tint num_pages = PAGE_ALIGN(buf->size) / PAGE_SIZE;\n\tstruct sg_table *sgt;\n\tstruct scatterlist *sg;\n\tvoid *vaddr = buf->vaddr;\n\tint ret;\n\tint i;\n\n\tattach = kzalloc(sizeof(*attach), GFP_KERNEL);\n\tif (!attach)\n\t\treturn -ENOMEM;\n\n\tsgt = &attach->sgt;\n\tret = sg_alloc_table(sgt, num_pages, GFP_KERNEL);\n\tif (ret) {\n\t\tkfree(attach);\n\t\treturn ret;\n\t}\n\tfor_each_sgtable_sg(sgt, sg, i) {\n\t\tstruct page *page = vmalloc_to_page(vaddr);\n\n\t\tif (!page) {\n\t\t\tsg_free_table(sgt);\n\t\t\tkfree(attach);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsg_set_page(sg, page, PAGE_SIZE, 0);\n\t\tvaddr += PAGE_SIZE;\n\t}\n\n\tattach->dma_dir = DMA_NONE;\n\tdbuf_attach->priv = attach;\n\treturn 0;\n}\n\nstatic void vb2_vmalloc_dmabuf_ops_detach(struct dma_buf *dbuf,\n\tstruct dma_buf_attachment *db_attach)\n{\n\tstruct vb2_vmalloc_attachment *attach = db_attach->priv;\n\tstruct sg_table *sgt;\n\n\tif (!attach)\n\t\treturn;\n\n\tsgt = &attach->sgt;\n\n\t \n\tif (attach->dma_dir != DMA_NONE)\n\t\tdma_unmap_sgtable(db_attach->dev, sgt, attach->dma_dir, 0);\n\tsg_free_table(sgt);\n\tkfree(attach);\n\tdb_attach->priv = NULL;\n}\n\nstatic struct sg_table *vb2_vmalloc_dmabuf_ops_map(\n\tstruct dma_buf_attachment *db_attach, enum dma_data_direction dma_dir)\n{\n\tstruct vb2_vmalloc_attachment *attach = db_attach->priv;\n\tstruct sg_table *sgt;\n\n\tsgt = &attach->sgt;\n\t \n\tif (attach->dma_dir == dma_dir)\n\t\treturn sgt;\n\n\t \n\tif (attach->dma_dir != DMA_NONE) {\n\t\tdma_unmap_sgtable(db_attach->dev, sgt, attach->dma_dir, 0);\n\t\tattach->dma_dir = DMA_NONE;\n\t}\n\n\t \n\tif (dma_map_sgtable(db_attach->dev, sgt, dma_dir, 0)) {\n\t\tpr_err(\"failed to map scatterlist\\n\");\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tattach->dma_dir = dma_dir;\n\n\treturn sgt;\n}\n\nstatic void vb2_vmalloc_dmabuf_ops_unmap(struct dma_buf_attachment *db_attach,\n\tstruct sg_table *sgt, enum dma_data_direction dma_dir)\n{\n\t \n}\n\nstatic void vb2_vmalloc_dmabuf_ops_release(struct dma_buf *dbuf)\n{\n\t \n\tvb2_vmalloc_put(dbuf->priv);\n}\n\nstatic int vb2_vmalloc_dmabuf_ops_vmap(struct dma_buf *dbuf,\n\t\t\t\t       struct iosys_map *map)\n{\n\tstruct vb2_vmalloc_buf *buf = dbuf->priv;\n\n\tiosys_map_set_vaddr(map, buf->vaddr);\n\n\treturn 0;\n}\n\nstatic int vb2_vmalloc_dmabuf_ops_mmap(struct dma_buf *dbuf,\n\tstruct vm_area_struct *vma)\n{\n\treturn vb2_vmalloc_mmap(dbuf->priv, vma);\n}\n\nstatic const struct dma_buf_ops vb2_vmalloc_dmabuf_ops = {\n\t.attach = vb2_vmalloc_dmabuf_ops_attach,\n\t.detach = vb2_vmalloc_dmabuf_ops_detach,\n\t.map_dma_buf = vb2_vmalloc_dmabuf_ops_map,\n\t.unmap_dma_buf = vb2_vmalloc_dmabuf_ops_unmap,\n\t.vmap = vb2_vmalloc_dmabuf_ops_vmap,\n\t.mmap = vb2_vmalloc_dmabuf_ops_mmap,\n\t.release = vb2_vmalloc_dmabuf_ops_release,\n};\n\nstatic struct dma_buf *vb2_vmalloc_get_dmabuf(struct vb2_buffer *vb,\n\t\t\t\t\t      void *buf_priv,\n\t\t\t\t\t      unsigned long flags)\n{\n\tstruct vb2_vmalloc_buf *buf = buf_priv;\n\tstruct dma_buf *dbuf;\n\tDEFINE_DMA_BUF_EXPORT_INFO(exp_info);\n\n\texp_info.ops = &vb2_vmalloc_dmabuf_ops;\n\texp_info.size = buf->size;\n\texp_info.flags = flags;\n\texp_info.priv = buf;\n\n\tif (WARN_ON(!buf->vaddr))\n\t\treturn NULL;\n\n\tdbuf = dma_buf_export(&exp_info);\n\tif (IS_ERR(dbuf))\n\t\treturn NULL;\n\n\t \n\trefcount_inc(&buf->refcount);\n\n\treturn dbuf;\n}\n#endif  \n\n\n \n \n \n\nstatic int vb2_vmalloc_map_dmabuf(void *mem_priv)\n{\n\tstruct vb2_vmalloc_buf *buf = mem_priv;\n\tstruct iosys_map map;\n\tint ret;\n\n\tret = dma_buf_vmap_unlocked(buf->dbuf, &map);\n\tif (ret)\n\t\treturn -EFAULT;\n\tbuf->vaddr = map.vaddr;\n\n\treturn 0;\n}\n\nstatic void vb2_vmalloc_unmap_dmabuf(void *mem_priv)\n{\n\tstruct vb2_vmalloc_buf *buf = mem_priv;\n\tstruct iosys_map map = IOSYS_MAP_INIT_VADDR(buf->vaddr);\n\n\tdma_buf_vunmap_unlocked(buf->dbuf, &map);\n\tbuf->vaddr = NULL;\n}\n\nstatic void vb2_vmalloc_detach_dmabuf(void *mem_priv)\n{\n\tstruct vb2_vmalloc_buf *buf = mem_priv;\n\tstruct iosys_map map = IOSYS_MAP_INIT_VADDR(buf->vaddr);\n\n\tif (buf->vaddr)\n\t\tdma_buf_vunmap_unlocked(buf->dbuf, &map);\n\n\tkfree(buf);\n}\n\nstatic void *vb2_vmalloc_attach_dmabuf(struct vb2_buffer *vb,\n\t\t\t\t       struct device *dev,\n\t\t\t\t       struct dma_buf *dbuf,\n\t\t\t\t       unsigned long size)\n{\n\tstruct vb2_vmalloc_buf *buf;\n\n\tif (dbuf->size < size)\n\t\treturn ERR_PTR(-EFAULT);\n\n\tbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\n\tif (!buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbuf->dbuf = dbuf;\n\tbuf->dma_dir = vb->vb2_queue->dma_dir;\n\tbuf->size = size;\n\n\treturn buf;\n}\n\n\nconst struct vb2_mem_ops vb2_vmalloc_memops = {\n\t.alloc\t\t= vb2_vmalloc_alloc,\n\t.put\t\t= vb2_vmalloc_put,\n\t.get_userptr\t= vb2_vmalloc_get_userptr,\n\t.put_userptr\t= vb2_vmalloc_put_userptr,\n#ifdef CONFIG_HAS_DMA\n\t.get_dmabuf\t= vb2_vmalloc_get_dmabuf,\n#endif\n\t.map_dmabuf\t= vb2_vmalloc_map_dmabuf,\n\t.unmap_dmabuf\t= vb2_vmalloc_unmap_dmabuf,\n\t.attach_dmabuf\t= vb2_vmalloc_attach_dmabuf,\n\t.detach_dmabuf\t= vb2_vmalloc_detach_dmabuf,\n\t.vaddr\t\t= vb2_vmalloc_vaddr,\n\t.mmap\t\t= vb2_vmalloc_mmap,\n\t.num_users\t= vb2_vmalloc_num_users,\n};\nEXPORT_SYMBOL_GPL(vb2_vmalloc_memops);\n\nMODULE_DESCRIPTION(\"vmalloc memory handling routines for videobuf2\");\nMODULE_AUTHOR(\"Pawel Osciak <pawel@osciak.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(DMA_BUF);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}