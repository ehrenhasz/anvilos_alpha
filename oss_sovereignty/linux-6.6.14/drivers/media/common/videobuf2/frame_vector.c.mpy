{
  "module_name": "frame_vector.c",
  "hash_id": "c7cf23432e44d60b174c9790f0483f6bf686fbcf845f9281c9b6e3d635926b44",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/videobuf2/frame_vector.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#include <media/frame_vector.h>\n\n \nint get_vaddr_frames(unsigned long start, unsigned int nr_frames, bool write,\n\t\t     struct frame_vector *vec)\n{\n\tint ret;\n\tunsigned int gup_flags = FOLL_LONGTERM;\n\n\tif (nr_frames == 0)\n\t\treturn 0;\n\n\tif (WARN_ON_ONCE(nr_frames > vec->nr_allocated))\n\t\tnr_frames = vec->nr_allocated;\n\n\tstart = untagged_addr(start);\n\n\tif (write)\n\t\tgup_flags |= FOLL_WRITE;\n\n\tret = pin_user_pages_fast(start, nr_frames, gup_flags,\n\t\t\t\t  (struct page **)(vec->ptrs));\n\tvec->got_ref = true;\n\tvec->is_pfns = false;\n\tvec->nr_frames = ret;\n\n\tif (likely(ret > 0))\n\t\treturn ret;\n\n\tvec->nr_frames = 0;\n\treturn ret ? ret : -EFAULT;\n}\nEXPORT_SYMBOL(get_vaddr_frames);\n\n \nvoid put_vaddr_frames(struct frame_vector *vec)\n{\n\tstruct page **pages;\n\n\tif (!vec->got_ref)\n\t\tgoto out;\n\tpages = frame_vector_pages(vec);\n\t \n\tif (WARN_ON(IS_ERR(pages)))\n\t\tgoto out;\n\n\tunpin_user_pages(pages, vec->nr_frames);\n\tvec->got_ref = false;\nout:\n\tvec->nr_frames = 0;\n}\nEXPORT_SYMBOL(put_vaddr_frames);\n\n \nint frame_vector_to_pages(struct frame_vector *vec)\n{\n\tint i;\n\tunsigned long *nums;\n\tstruct page **pages;\n\n\tif (!vec->is_pfns)\n\t\treturn 0;\n\tnums = frame_vector_pfns(vec);\n\tfor (i = 0; i < vec->nr_frames; i++)\n\t\tif (!pfn_valid(nums[i]))\n\t\t\treturn -EINVAL;\n\tpages = (struct page **)nums;\n\tfor (i = 0; i < vec->nr_frames; i++)\n\t\tpages[i] = pfn_to_page(nums[i]);\n\tvec->is_pfns = false;\n\treturn 0;\n}\nEXPORT_SYMBOL(frame_vector_to_pages);\n\n \nvoid frame_vector_to_pfns(struct frame_vector *vec)\n{\n\tint i;\n\tunsigned long *nums;\n\tstruct page **pages;\n\n\tif (vec->is_pfns)\n\t\treturn;\n\tpages = (struct page **)(vec->ptrs);\n\tnums = (unsigned long *)pages;\n\tfor (i = 0; i < vec->nr_frames; i++)\n\t\tnums[i] = page_to_pfn(pages[i]);\n\tvec->is_pfns = true;\n}\nEXPORT_SYMBOL(frame_vector_to_pfns);\n\n \nstruct frame_vector *frame_vector_create(unsigned int nr_frames)\n{\n\tstruct frame_vector *vec;\n\tint size = sizeof(struct frame_vector) + sizeof(void *) * nr_frames;\n\n\tif (WARN_ON_ONCE(nr_frames == 0))\n\t\treturn NULL;\n\t \n\tif (WARN_ON_ONCE(nr_frames > INT_MAX / sizeof(void *) / 2))\n\t\treturn NULL;\n\t \n\tvec = kvmalloc(size, GFP_KERNEL);\n\tif (!vec)\n\t\treturn NULL;\n\tvec->nr_allocated = nr_frames;\n\tvec->nr_frames = 0;\n\treturn vec;\n}\nEXPORT_SYMBOL(frame_vector_create);\n\n \nvoid frame_vector_destroy(struct frame_vector *vec)\n{\n\t \n\tVM_BUG_ON(vec->nr_frames > 0);\n\tkvfree(vec);\n}\nEXPORT_SYMBOL(frame_vector_destroy);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}