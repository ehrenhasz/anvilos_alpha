{
  "module_name": "videobuf2-dvb.c",
  "hash_id": "ee4dcd8d5b2bfe640b05b149a69af56f748d61157ec6b74492ebc76661635735",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/videobuf2/videobuf2-dvb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n\n#include <media/videobuf2-dvb.h>\n\n \n\nMODULE_AUTHOR(\"Gerd Knorr <kraxel@bytesex.org> [SuSE Labs]\");\nMODULE_LICENSE(\"GPL\");\n\n \n\nstatic int dvb_fnc(struct vb2_buffer *vb, void *priv)\n{\n\tstruct vb2_dvb *dvb = priv;\n\n\tdvb_dmx_swfilter(&dvb->demux, vb2_plane_vaddr(vb, 0),\n\t\t\t\t      vb2_get_plane_payload(vb, 0));\n\treturn 0;\n}\n\nstatic int vb2_dvb_start_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct vb2_dvb *dvb = demux->priv;\n\tint rc = 0;\n\n\tif (!demux->dmx.frontend)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dvb->lock);\n\tdvb->nfeeds++;\n\n\tif (!dvb->dvbq.threadio) {\n\t\trc = vb2_thread_start(&dvb->dvbq, dvb_fnc, dvb, dvb->name);\n\t\tif (rc)\n\t\t\tdvb->nfeeds--;\n\t}\n\tif (!rc)\n\t\trc = dvb->nfeeds;\n\tmutex_unlock(&dvb->lock);\n\treturn rc;\n}\n\nstatic int vb2_dvb_stop_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct vb2_dvb *dvb = demux->priv;\n\tint err = 0;\n\n\tmutex_lock(&dvb->lock);\n\tdvb->nfeeds--;\n\tif (0 == dvb->nfeeds)\n\t\terr = vb2_thread_stop(&dvb->dvbq);\n\tmutex_unlock(&dvb->lock);\n\treturn err;\n}\n\nstatic int vb2_dvb_register_adapter(struct vb2_dvb_frontends *fe,\n\t\t\t  struct module *module,\n\t\t\t  void *adapter_priv,\n\t\t\t  struct device *device,\n\t\t\t  struct media_device *mdev,\n\t\t\t  char *adapter_name,\n\t\t\t  short *adapter_nr,\n\t\t\t  int mfe_shared)\n{\n\tint result;\n\n\tmutex_init(&fe->lock);\n\n\t \n\tresult = dvb_register_adapter(&fe->adapter, adapter_name, module,\n\t\tdevice, adapter_nr);\n\tif (result < 0) {\n\t\tpr_warn(\"%s: dvb_register_adapter failed (errno = %d)\\n\",\n\t\t       adapter_name, result);\n\t}\n\tfe->adapter.priv = adapter_priv;\n\tfe->adapter.mfe_shared = mfe_shared;\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tif (mdev)\n\t\tfe->adapter.mdev = mdev;\n#endif\n\treturn result;\n}\n\nstatic int vb2_dvb_register_frontend(struct dvb_adapter *adapter,\n\tstruct vb2_dvb *dvb)\n{\n\tint result;\n\n\t \n\tresult = dvb_register_frontend(adapter, dvb->frontend);\n\tif (result < 0) {\n\t\tpr_warn(\"%s: dvb_register_frontend failed (errno = %d)\\n\",\n\t\t       dvb->name, result);\n\t\tgoto fail_frontend;\n\t}\n\n\t \n\tdvb->demux.dmx.capabilities =\n\t\tDMX_TS_FILTERING | DMX_SECTION_FILTERING |\n\t\tDMX_MEMORY_BASED_FILTERING;\n\tdvb->demux.priv       = dvb;\n\tdvb->demux.filternum  = 256;\n\tdvb->demux.feednum    = 256;\n\tdvb->demux.start_feed = vb2_dvb_start_feed;\n\tdvb->demux.stop_feed  = vb2_dvb_stop_feed;\n\tresult = dvb_dmx_init(&dvb->demux);\n\tif (result < 0) {\n\t\tpr_warn(\"%s: dvb_dmx_init failed (errno = %d)\\n\",\n\t\t       dvb->name, result);\n\t\tgoto fail_dmx;\n\t}\n\n\tdvb->dmxdev.filternum    = 256;\n\tdvb->dmxdev.demux        = &dvb->demux.dmx;\n\tdvb->dmxdev.capabilities = 0;\n\tresult = dvb_dmxdev_init(&dvb->dmxdev, adapter);\n\n\tif (result < 0) {\n\t\tpr_warn(\"%s: dvb_dmxdev_init failed (errno = %d)\\n\",\n\t\t       dvb->name, result);\n\t\tgoto fail_dmxdev;\n\t}\n\n\tdvb->fe_hw.source = DMX_FRONTEND_0;\n\tresult = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_hw);\n\tif (result < 0) {\n\t\tpr_warn(\"%s: add_frontend failed (DMX_FRONTEND_0, errno = %d)\\n\",\n\t\t       dvb->name, result);\n\t\tgoto fail_fe_hw;\n\t}\n\n\tdvb->fe_mem.source = DMX_MEMORY_FE;\n\tresult = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_mem);\n\tif (result < 0) {\n\t\tpr_warn(\"%s: add_frontend failed (DMX_MEMORY_FE, errno = %d)\\n\",\n\t\t       dvb->name, result);\n\t\tgoto fail_fe_mem;\n\t}\n\n\tresult = dvb->demux.dmx.connect_frontend(&dvb->demux.dmx, &dvb->fe_hw);\n\tif (result < 0) {\n\t\tpr_warn(\"%s: connect_frontend failed (errno = %d)\\n\",\n\t\t       dvb->name, result);\n\t\tgoto fail_fe_conn;\n\t}\n\n\t \n\tresult = dvb_net_init(adapter, &dvb->net, &dvb->demux.dmx);\n\tif (result < 0) {\n\t\tpr_warn(\"%s: dvb_net_init failed (errno = %d)\\n\",\n\t\t       dvb->name, result);\n\t\tgoto fail_fe_conn;\n\t}\n\treturn 0;\n\nfail_fe_conn:\n\tdvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_mem);\nfail_fe_mem:\n\tdvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_hw);\nfail_fe_hw:\n\tdvb_dmxdev_release(&dvb->dmxdev);\nfail_dmxdev:\n\tdvb_dmx_release(&dvb->demux);\nfail_dmx:\n\tdvb_unregister_frontend(dvb->frontend);\nfail_frontend:\n\tdvb_frontend_detach(dvb->frontend);\n\tdvb->frontend = NULL;\n\n\treturn result;\n}\n\n \n \nint vb2_dvb_register_bus(struct vb2_dvb_frontends *f,\n\t\t\t struct module *module,\n\t\t\t void *adapter_priv,\n\t\t\t struct device *device,\n\t\t\t struct media_device *mdev,\n\t\t\t short *adapter_nr,\n\t\t\t int mfe_shared)\n{\n\tstruct list_head *list, *q;\n\tstruct vb2_dvb_frontend *fe;\n\tint res;\n\n\tfe = vb2_dvb_get_frontend(f, 1);\n\tif (!fe) {\n\t\tpr_warn(\"Unable to register the adapter which has no frontends\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tres = vb2_dvb_register_adapter(f, module, adapter_priv, device, mdev,\n\t\tfe->dvb.name, adapter_nr, mfe_shared);\n\tif (res < 0) {\n\t\tpr_warn(\"vb2_dvb_register_adapter failed (errno = %d)\\n\", res);\n\t\treturn res;\n\t}\n\n\t \n\tmutex_lock(&f->lock);\n\tlist_for_each_safe(list, q, &f->felist) {\n\t\tfe = list_entry(list, struct vb2_dvb_frontend, felist);\n\t\tres = vb2_dvb_register_frontend(&f->adapter, &fe->dvb);\n\t\tif (res < 0) {\n\t\t\tpr_warn(\"%s: vb2_dvb_register_frontend failed (errno = %d)\\n\",\n\t\t\t\tfe->dvb.name, res);\n\t\t\tgoto err;\n\t\t}\n\t\tres = dvb_create_media_graph(&f->adapter, false);\n\t\tif (res < 0)\n\t\t\tgoto err;\n\t}\n\n\tmutex_unlock(&f->lock);\n\treturn 0;\n\nerr:\n\tmutex_unlock(&f->lock);\n\tvb2_dvb_unregister_bus(f);\n\treturn res;\n}\nEXPORT_SYMBOL(vb2_dvb_register_bus);\n\nvoid vb2_dvb_unregister_bus(struct vb2_dvb_frontends *f)\n{\n\tvb2_dvb_dealloc_frontends(f);\n\n\tdvb_unregister_adapter(&f->adapter);\n}\nEXPORT_SYMBOL(vb2_dvb_unregister_bus);\n\nstruct vb2_dvb_frontend *vb2_dvb_get_frontend(\n\tstruct vb2_dvb_frontends *f, int id)\n{\n\tstruct list_head *list, *q;\n\tstruct vb2_dvb_frontend *fe, *ret = NULL;\n\n\tmutex_lock(&f->lock);\n\n\tlist_for_each_safe(list, q, &f->felist) {\n\t\tfe = list_entry(list, struct vb2_dvb_frontend, felist);\n\t\tif (fe->id == id) {\n\t\t\tret = fe;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&f->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(vb2_dvb_get_frontend);\n\nint vb2_dvb_find_frontend(struct vb2_dvb_frontends *f,\n\tstruct dvb_frontend *p)\n{\n\tstruct list_head *list, *q;\n\tstruct vb2_dvb_frontend *fe = NULL;\n\tint ret = 0;\n\n\tmutex_lock(&f->lock);\n\n\tlist_for_each_safe(list, q, &f->felist) {\n\t\tfe = list_entry(list, struct vb2_dvb_frontend, felist);\n\t\tif (fe->dvb.frontend == p) {\n\t\t\tret = fe->id;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&f->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(vb2_dvb_find_frontend);\n\nstruct vb2_dvb_frontend *vb2_dvb_alloc_frontend(\n\tstruct vb2_dvb_frontends *f, int id)\n{\n\tstruct vb2_dvb_frontend *fe;\n\n\tfe = kzalloc(sizeof(struct vb2_dvb_frontend), GFP_KERNEL);\n\tif (fe == NULL)\n\t\treturn NULL;\n\n\tfe->id = id;\n\tmutex_init(&fe->dvb.lock);\n\n\tmutex_lock(&f->lock);\n\tlist_add_tail(&fe->felist, &f->felist);\n\tmutex_unlock(&f->lock);\n\treturn fe;\n}\nEXPORT_SYMBOL(vb2_dvb_alloc_frontend);\n\nvoid vb2_dvb_dealloc_frontends(struct vb2_dvb_frontends *f)\n{\n\tstruct list_head *list, *q;\n\tstruct vb2_dvb_frontend *fe;\n\n\tmutex_lock(&f->lock);\n\tlist_for_each_safe(list, q, &f->felist) {\n\t\tfe = list_entry(list, struct vb2_dvb_frontend, felist);\n\t\tif (fe->dvb.net.dvbdev) {\n\t\t\tdvb_net_release(&fe->dvb.net);\n\t\t\tfe->dvb.demux.dmx.remove_frontend(&fe->dvb.demux.dmx,\n\t\t\t\t&fe->dvb.fe_mem);\n\t\t\tfe->dvb.demux.dmx.remove_frontend(&fe->dvb.demux.dmx,\n\t\t\t\t&fe->dvb.fe_hw);\n\t\t\tdvb_dmxdev_release(&fe->dvb.dmxdev);\n\t\t\tdvb_dmx_release(&fe->dvb.demux);\n\t\t\tdvb_unregister_frontend(fe->dvb.frontend);\n\t\t}\n\t\tif (fe->dvb.frontend)\n\t\t\t \n\t\t\tdvb_frontend_detach(fe->dvb.frontend);\n\t\tlist_del(list);  \n\t\tkfree(fe);\t \n\t}\n\tmutex_unlock(&f->lock);\n}\nEXPORT_SYMBOL(vb2_dvb_dealloc_frontends);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}