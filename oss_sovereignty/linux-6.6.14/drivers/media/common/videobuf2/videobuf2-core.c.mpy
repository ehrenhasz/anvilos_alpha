{
  "module_name": "videobuf2-core.c",
  "hash_id": "6efcbf8b62552915366871dc0822d6258cbb51658db3ec7e9c26482cba3346c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/videobuf2/videobuf2-core.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n\n#include <media/videobuf2-core.h>\n#include <media/v4l2-mc.h>\n\n#include <trace/events/vb2.h>\n\nstatic int debug;\nmodule_param(debug, int, 0644);\n\n#define dprintk(q, level, fmt, arg...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (debug >= level)\t\t\t\t\t\\\n\t\t\tpr_info(\"[%s] %s: \" fmt, (q)->name, __func__,\t\\\n\t\t\t\t## arg);\t\t\t\t\\\n\t} while (0)\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\n \n\n#define log_memop(vb, op)\t\t\t\t\t\t\\\n\tdprintk((vb)->vb2_queue, 2, \"call_memop(%d, %s)%s\\n\",\t\t\\\n\t\t(vb)->index, #op,\t\t\t\t\t\\\n\t\t(vb)->vb2_queue->mem_ops->op ? \"\" : \" (nop)\")\n\n#define call_memop(vb, op, args...)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct vb2_queue *_q = (vb)->vb2_queue;\t\t\t\t\\\n\tint err;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tlog_memop(vb, op);\t\t\t\t\t\t\\\n\terr = _q->mem_ops->op ? _q->mem_ops->op(args) : 0;\t\t\\\n\tif (!err)\t\t\t\t\t\t\t\\\n\t\t(vb)->cnt_mem_ ## op++;\t\t\t\t\t\\\n\terr;\t\t\t\t\t\t\t\t\\\n})\n\n#define call_ptr_memop(op, vb, args...)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct vb2_queue *_q = (vb)->vb2_queue;\t\t\t\t\\\n\tvoid *ptr;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tlog_memop(vb, op);\t\t\t\t\t\t\\\n\tptr = _q->mem_ops->op ? _q->mem_ops->op(vb, args) : NULL;\t\\\n\tif (!IS_ERR_OR_NULL(ptr))\t\t\t\t\t\\\n\t\t(vb)->cnt_mem_ ## op++;\t\t\t\t\t\\\n\tptr;\t\t\t\t\t\t\t\t\\\n})\n\n#define call_void_memop(vb, op, args...)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct vb2_queue *_q = (vb)->vb2_queue;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tlog_memop(vb, op);\t\t\t\t\t\t\\\n\tif (_q->mem_ops->op)\t\t\t\t\t\t\\\n\t\t_q->mem_ops->op(args);\t\t\t\t\t\\\n\t(vb)->cnt_mem_ ## op++;\t\t\t\t\t\t\\\n})\n\n#define log_qop(q, op)\t\t\t\t\t\t\t\\\n\tdprintk(q, 2, \"call_qop(%s)%s\\n\", #op,\t\t\t\t\\\n\t\t(q)->ops->op ? \"\" : \" (nop)\")\n\n#define call_qop(q, op, args...)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint err;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tlog_qop(q, op);\t\t\t\t\t\t\t\\\n\terr = (q)->ops->op ? (q)->ops->op(args) : 0;\t\t\t\\\n\tif (!err)\t\t\t\t\t\t\t\\\n\t\t(q)->cnt_ ## op++;\t\t\t\t\t\\\n\terr;\t\t\t\t\t\t\t\t\\\n})\n\n#define call_void_qop(q, op, args...)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tlog_qop(q, op);\t\t\t\t\t\t\t\\\n\tif ((q)->ops->op)\t\t\t\t\t\t\\\n\t\t(q)->ops->op(args);\t\t\t\t\t\\\n\t(q)->cnt_ ## op++;\t\t\t\t\t\t\\\n})\n\n#define log_vb_qop(vb, op, args...)\t\t\t\t\t\\\n\tdprintk((vb)->vb2_queue, 2, \"call_vb_qop(%d, %s)%s\\n\",\t\t\\\n\t\t(vb)->index, #op,\t\t\t\t\t\\\n\t\t(vb)->vb2_queue->ops->op ? \"\" : \" (nop)\")\n\n#define call_vb_qop(vb, op, args...)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint err;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tlog_vb_qop(vb, op);\t\t\t\t\t\t\\\n\terr = (vb)->vb2_queue->ops->op ?\t\t\t\t\\\n\t\t(vb)->vb2_queue->ops->op(args) : 0;\t\t\t\\\n\tif (!err)\t\t\t\t\t\t\t\\\n\t\t(vb)->cnt_ ## op++;\t\t\t\t\t\\\n\terr;\t\t\t\t\t\t\t\t\\\n})\n\n#define call_void_vb_qop(vb, op, args...)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tlog_vb_qop(vb, op);\t\t\t\t\t\t\\\n\tif ((vb)->vb2_queue->ops->op)\t\t\t\t\t\\\n\t\t(vb)->vb2_queue->ops->op(args);\t\t\t\t\\\n\t(vb)->cnt_ ## op++;\t\t\t\t\t\t\\\n})\n\n#else\n\n#define call_memop(vb, op, args...)\t\t\t\t\t\\\n\t((vb)->vb2_queue->mem_ops->op ?\t\t\t\t\t\\\n\t\t(vb)->vb2_queue->mem_ops->op(args) : 0)\n\n#define call_ptr_memop(op, vb, args...)\t\t\t\t\t\\\n\t((vb)->vb2_queue->mem_ops->op ?\t\t\t\t\t\\\n\t\t(vb)->vb2_queue->mem_ops->op(vb, args) : NULL)\n\n#define call_void_memop(vb, op, args...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif ((vb)->vb2_queue->mem_ops->op)\t\t\t\\\n\t\t\t(vb)->vb2_queue->mem_ops->op(args);\t\t\\\n\t} while (0)\n\n#define call_qop(q, op, args...)\t\t\t\t\t\\\n\t((q)->ops->op ? (q)->ops->op(args) : 0)\n\n#define call_void_qop(q, op, args...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif ((q)->ops->op)\t\t\t\t\t\\\n\t\t\t(q)->ops->op(args);\t\t\t\t\\\n\t} while (0)\n\n#define call_vb_qop(vb, op, args...)\t\t\t\t\t\\\n\t((vb)->vb2_queue->ops->op ? (vb)->vb2_queue->ops->op(args) : 0)\n\n#define call_void_vb_qop(vb, op, args...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif ((vb)->vb2_queue->ops->op)\t\t\t\t\\\n\t\t\t(vb)->vb2_queue->ops->op(args);\t\t\t\\\n\t} while (0)\n\n#endif\n\n#define call_bufop(q, op, args...)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint ret = 0;\t\t\t\t\t\t\t\\\n\tif (q && q->buf_ops && q->buf_ops->op)\t\t\t\t\\\n\t\tret = q->buf_ops->op(args);\t\t\t\t\\\n\tret;\t\t\t\t\t\t\t\t\\\n})\n\n#define call_void_bufop(q, op, args...)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tif (q && q->buf_ops && q->buf_ops->op)\t\t\t\t\\\n\t\tq->buf_ops->op(args);\t\t\t\t\t\\\n})\n\nstatic void __vb2_queue_cancel(struct vb2_queue *q);\nstatic void __enqueue_in_driver(struct vb2_buffer *vb);\n\nstatic const char *vb2_state_name(enum vb2_buffer_state s)\n{\n\tstatic const char * const state_names[] = {\n\t\t[VB2_BUF_STATE_DEQUEUED] = \"dequeued\",\n\t\t[VB2_BUF_STATE_IN_REQUEST] = \"in request\",\n\t\t[VB2_BUF_STATE_PREPARING] = \"preparing\",\n\t\t[VB2_BUF_STATE_QUEUED] = \"queued\",\n\t\t[VB2_BUF_STATE_ACTIVE] = \"active\",\n\t\t[VB2_BUF_STATE_DONE] = \"done\",\n\t\t[VB2_BUF_STATE_ERROR] = \"error\",\n\t};\n\n\tif ((unsigned int)(s) < ARRAY_SIZE(state_names))\n\t\treturn state_names[s];\n\treturn \"unknown\";\n}\n\n \nstatic int __vb2_buf_mem_alloc(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *q = vb->vb2_queue;\n\tvoid *mem_priv;\n\tint plane;\n\tint ret = -ENOMEM;\n\n\t \n\tfor (plane = 0; plane < vb->num_planes; ++plane) {\n\t\t \n\t\tunsigned long size = PAGE_ALIGN(vb->planes[plane].length);\n\n\t\t \n\t\tif (size < vb->planes[plane].length)\n\t\t\tgoto free;\n\n\t\tmem_priv = call_ptr_memop(alloc,\n\t\t\t\t\t  vb,\n\t\t\t\t\t  q->alloc_devs[plane] ? : q->dev,\n\t\t\t\t\t  size);\n\t\tif (IS_ERR_OR_NULL(mem_priv)) {\n\t\t\tif (mem_priv)\n\t\t\t\tret = PTR_ERR(mem_priv);\n\t\t\tgoto free;\n\t\t}\n\n\t\t \n\t\tvb->planes[plane].mem_priv = mem_priv;\n\t}\n\n\treturn 0;\nfree:\n\t \n\tfor (; plane > 0; --plane) {\n\t\tcall_void_memop(vb, put, vb->planes[plane - 1].mem_priv);\n\t\tvb->planes[plane - 1].mem_priv = NULL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void __vb2_buf_mem_free(struct vb2_buffer *vb)\n{\n\tunsigned int plane;\n\n\tfor (plane = 0; plane < vb->num_planes; ++plane) {\n\t\tcall_void_memop(vb, put, vb->planes[plane].mem_priv);\n\t\tvb->planes[plane].mem_priv = NULL;\n\t\tdprintk(vb->vb2_queue, 3, \"freed plane %d of buffer %d\\n\",\n\t\t\tplane, vb->index);\n\t}\n}\n\n \nstatic void __vb2_buf_userptr_put(struct vb2_buffer *vb)\n{\n\tunsigned int plane;\n\n\tfor (plane = 0; plane < vb->num_planes; ++plane) {\n\t\tif (vb->planes[plane].mem_priv)\n\t\t\tcall_void_memop(vb, put_userptr, vb->planes[plane].mem_priv);\n\t\tvb->planes[plane].mem_priv = NULL;\n\t}\n}\n\n \nstatic void __vb2_plane_dmabuf_put(struct vb2_buffer *vb, struct vb2_plane *p)\n{\n\tif (!p->mem_priv)\n\t\treturn;\n\n\tif (p->dbuf_mapped)\n\t\tcall_void_memop(vb, unmap_dmabuf, p->mem_priv);\n\n\tcall_void_memop(vb, detach_dmabuf, p->mem_priv);\n\tdma_buf_put(p->dbuf);\n\tp->mem_priv = NULL;\n\tp->dbuf = NULL;\n\tp->dbuf_mapped = 0;\n}\n\n \nstatic void __vb2_buf_dmabuf_put(struct vb2_buffer *vb)\n{\n\tunsigned int plane;\n\n\tfor (plane = 0; plane < vb->num_planes; ++plane)\n\t\t__vb2_plane_dmabuf_put(vb, &vb->planes[plane]);\n}\n\n \nstatic void __vb2_buf_mem_prepare(struct vb2_buffer *vb)\n{\n\tunsigned int plane;\n\n\tif (vb->synced)\n\t\treturn;\n\n\tvb->synced = 1;\n\tfor (plane = 0; plane < vb->num_planes; ++plane)\n\t\tcall_void_memop(vb, prepare, vb->planes[plane].mem_priv);\n}\n\n \nstatic void __vb2_buf_mem_finish(struct vb2_buffer *vb)\n{\n\tunsigned int plane;\n\n\tif (!vb->synced)\n\t\treturn;\n\n\tvb->synced = 0;\n\tfor (plane = 0; plane < vb->num_planes; ++plane)\n\t\tcall_void_memop(vb, finish, vb->planes[plane].mem_priv);\n}\n\n \nstatic void __setup_offsets(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *q = vb->vb2_queue;\n\tunsigned int plane;\n\tunsigned long off = 0;\n\n\tif (vb->index) {\n\t\tstruct vb2_buffer *prev = q->bufs[vb->index - 1];\n\t\tstruct vb2_plane *p = &prev->planes[prev->num_planes - 1];\n\n\t\toff = PAGE_ALIGN(p->m.offset + p->length);\n\t}\n\n\tfor (plane = 0; plane < vb->num_planes; ++plane) {\n\t\tvb->planes[plane].m.offset = off;\n\n\t\tdprintk(q, 3, \"buffer %d, plane %d offset 0x%08lx\\n\",\n\t\t\t\tvb->index, plane, off);\n\n\t\toff += vb->planes[plane].length;\n\t\toff = PAGE_ALIGN(off);\n\t}\n}\n\nstatic void init_buffer_cache_hints(struct vb2_queue *q, struct vb2_buffer *vb)\n{\n\t \n\tif (q->memory == VB2_MEMORY_DMABUF) {\n\t\tvb->skip_cache_sync_on_finish = 1;\n\t\tvb->skip_cache_sync_on_prepare = 1;\n\t\treturn;\n\t}\n\n\t \n\tif (q->dma_dir == DMA_TO_DEVICE)\n\t\tvb->skip_cache_sync_on_finish = 1;\n}\n\n \nstatic int __vb2_queue_alloc(struct vb2_queue *q, enum vb2_memory memory,\n\t\t\t     unsigned int num_buffers, unsigned int num_planes,\n\t\t\t     const unsigned plane_sizes[VB2_MAX_PLANES])\n{\n\tunsigned int buffer, plane;\n\tstruct vb2_buffer *vb;\n\tint ret;\n\n\t \n\tnum_buffers = min_t(unsigned int, num_buffers,\n\t\t\t    VB2_MAX_FRAME - q->num_buffers);\n\n\tfor (buffer = 0; buffer < num_buffers; ++buffer) {\n\t\t \n\t\tvb = kzalloc(q->buf_struct_size, GFP_KERNEL);\n\t\tif (!vb) {\n\t\t\tdprintk(q, 1, \"memory alloc for buffer struct failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tvb->state = VB2_BUF_STATE_DEQUEUED;\n\t\tvb->vb2_queue = q;\n\t\tvb->num_planes = num_planes;\n\t\tvb->index = q->num_buffers + buffer;\n\t\tvb->type = q->type;\n\t\tvb->memory = memory;\n\t\tinit_buffer_cache_hints(q, vb);\n\t\tfor (plane = 0; plane < num_planes; ++plane) {\n\t\t\tvb->planes[plane].length = plane_sizes[plane];\n\t\t\tvb->planes[plane].min_length = plane_sizes[plane];\n\t\t}\n\t\tcall_void_bufop(q, init_buffer, vb);\n\n\t\tq->bufs[vb->index] = vb;\n\n\t\t \n\t\tif (memory == VB2_MEMORY_MMAP) {\n\t\t\tret = __vb2_buf_mem_alloc(vb);\n\t\t\tif (ret) {\n\t\t\t\tdprintk(q, 1, \"failed allocating memory for buffer %d\\n\",\n\t\t\t\t\tbuffer);\n\t\t\t\tq->bufs[vb->index] = NULL;\n\t\t\t\tkfree(vb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t__setup_offsets(vb);\n\t\t\t \n\t\t\tret = call_vb_qop(vb, buf_init, vb);\n\t\t\tif (ret) {\n\t\t\t\tdprintk(q, 1, \"buffer %d %p initialization failed\\n\",\n\t\t\t\t\tbuffer, vb);\n\t\t\t\t__vb2_buf_mem_free(vb);\n\t\t\t\tq->bufs[vb->index] = NULL;\n\t\t\t\tkfree(vb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tdprintk(q, 3, \"allocated %d buffers, %d plane(s) each\\n\",\n\t\tbuffer, num_planes);\n\n\treturn buffer;\n}\n\n \nstatic void __vb2_free_mem(struct vb2_queue *q, unsigned int buffers)\n{\n\tunsigned int buffer;\n\tstruct vb2_buffer *vb;\n\n\tfor (buffer = q->num_buffers - buffers; buffer < q->num_buffers;\n\t     ++buffer) {\n\t\tvb = q->bufs[buffer];\n\t\tif (!vb)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (q->memory == VB2_MEMORY_MMAP)\n\t\t\t__vb2_buf_mem_free(vb);\n\t\telse if (q->memory == VB2_MEMORY_DMABUF)\n\t\t\t__vb2_buf_dmabuf_put(vb);\n\t\telse\n\t\t\t__vb2_buf_userptr_put(vb);\n\t}\n}\n\n \nstatic void __vb2_queue_free(struct vb2_queue *q, unsigned int buffers)\n{\n\tunsigned int buffer;\n\n\tlockdep_assert_held(&q->mmap_lock);\n\n\t \n\tfor (buffer = q->num_buffers - buffers; buffer < q->num_buffers;\n\t     ++buffer) {\n\t\tstruct vb2_buffer *vb = q->bufs[buffer];\n\n\t\tif (vb && vb->planes[0].mem_priv)\n\t\t\tcall_void_vb_qop(vb, buf_cleanup, vb);\n\t}\n\n\t \n\t__vb2_free_mem(q, buffers);\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t \n\tif (q->num_buffers) {\n\t\tbool unbalanced = q->cnt_start_streaming != q->cnt_stop_streaming ||\n\t\t\t\t  q->cnt_prepare_streaming != q->cnt_unprepare_streaming ||\n\t\t\t\t  q->cnt_wait_prepare != q->cnt_wait_finish;\n\n\t\tif (unbalanced || debug) {\n\t\t\tpr_info(\"counters for queue %p:%s\\n\", q,\n\t\t\t\tunbalanced ? \" UNBALANCED!\" : \"\");\n\t\t\tpr_info(\"     setup: %u start_streaming: %u stop_streaming: %u\\n\",\n\t\t\t\tq->cnt_queue_setup, q->cnt_start_streaming,\n\t\t\t\tq->cnt_stop_streaming);\n\t\t\tpr_info(\"     prepare_streaming: %u unprepare_streaming: %u\\n\",\n\t\t\t\tq->cnt_prepare_streaming, q->cnt_unprepare_streaming);\n\t\t\tpr_info(\"     wait_prepare: %u wait_finish: %u\\n\",\n\t\t\t\tq->cnt_wait_prepare, q->cnt_wait_finish);\n\t\t}\n\t\tq->cnt_queue_setup = 0;\n\t\tq->cnt_wait_prepare = 0;\n\t\tq->cnt_wait_finish = 0;\n\t\tq->cnt_prepare_streaming = 0;\n\t\tq->cnt_start_streaming = 0;\n\t\tq->cnt_stop_streaming = 0;\n\t\tq->cnt_unprepare_streaming = 0;\n\t}\n\tfor (buffer = 0; buffer < q->num_buffers; ++buffer) {\n\t\tstruct vb2_buffer *vb = q->bufs[buffer];\n\t\tbool unbalanced = vb->cnt_mem_alloc != vb->cnt_mem_put ||\n\t\t\t\t  vb->cnt_mem_prepare != vb->cnt_mem_finish ||\n\t\t\t\t  vb->cnt_mem_get_userptr != vb->cnt_mem_put_userptr ||\n\t\t\t\t  vb->cnt_mem_attach_dmabuf != vb->cnt_mem_detach_dmabuf ||\n\t\t\t\t  vb->cnt_mem_map_dmabuf != vb->cnt_mem_unmap_dmabuf ||\n\t\t\t\t  vb->cnt_buf_queue != vb->cnt_buf_done ||\n\t\t\t\t  vb->cnt_buf_prepare != vb->cnt_buf_finish ||\n\t\t\t\t  vb->cnt_buf_init != vb->cnt_buf_cleanup;\n\n\t\tif (unbalanced || debug) {\n\t\t\tpr_info(\"   counters for queue %p, buffer %d:%s\\n\",\n\t\t\t\tq, buffer, unbalanced ? \" UNBALANCED!\" : \"\");\n\t\t\tpr_info(\"     buf_init: %u buf_cleanup: %u buf_prepare: %u buf_finish: %u\\n\",\n\t\t\t\tvb->cnt_buf_init, vb->cnt_buf_cleanup,\n\t\t\t\tvb->cnt_buf_prepare, vb->cnt_buf_finish);\n\t\t\tpr_info(\"     buf_out_validate: %u buf_queue: %u buf_done: %u buf_request_complete: %u\\n\",\n\t\t\t\tvb->cnt_buf_out_validate, vb->cnt_buf_queue,\n\t\t\t\tvb->cnt_buf_done, vb->cnt_buf_request_complete);\n\t\t\tpr_info(\"     alloc: %u put: %u prepare: %u finish: %u mmap: %u\\n\",\n\t\t\t\tvb->cnt_mem_alloc, vb->cnt_mem_put,\n\t\t\t\tvb->cnt_mem_prepare, vb->cnt_mem_finish,\n\t\t\t\tvb->cnt_mem_mmap);\n\t\t\tpr_info(\"     get_userptr: %u put_userptr: %u\\n\",\n\t\t\t\tvb->cnt_mem_get_userptr, vb->cnt_mem_put_userptr);\n\t\t\tpr_info(\"     attach_dmabuf: %u detach_dmabuf: %u map_dmabuf: %u unmap_dmabuf: %u\\n\",\n\t\t\t\tvb->cnt_mem_attach_dmabuf, vb->cnt_mem_detach_dmabuf,\n\t\t\t\tvb->cnt_mem_map_dmabuf, vb->cnt_mem_unmap_dmabuf);\n\t\t\tpr_info(\"     get_dmabuf: %u num_users: %u vaddr: %u cookie: %u\\n\",\n\t\t\t\tvb->cnt_mem_get_dmabuf,\n\t\t\t\tvb->cnt_mem_num_users,\n\t\t\t\tvb->cnt_mem_vaddr,\n\t\t\t\tvb->cnt_mem_cookie);\n\t\t}\n\t}\n#endif\n\n\t \n\tfor (buffer = q->num_buffers - buffers; buffer < q->num_buffers;\n\t     ++buffer) {\n\t\tkfree(q->bufs[buffer]);\n\t\tq->bufs[buffer] = NULL;\n\t}\n\n\tq->num_buffers -= buffers;\n\tif (!q->num_buffers) {\n\t\tq->memory = VB2_MEMORY_UNKNOWN;\n\t\tINIT_LIST_HEAD(&q->queued_list);\n\t}\n}\n\nbool vb2_buffer_in_use(struct vb2_queue *q, struct vb2_buffer *vb)\n{\n\tunsigned int plane;\n\tfor (plane = 0; plane < vb->num_planes; ++plane) {\n\t\tvoid *mem_priv = vb->planes[plane].mem_priv;\n\t\t \n\t\tif (mem_priv && call_memop(vb, num_users, mem_priv) > 1)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL(vb2_buffer_in_use);\n\n \nstatic bool __buffers_in_use(struct vb2_queue *q)\n{\n\tunsigned int buffer;\n\tfor (buffer = 0; buffer < q->num_buffers; ++buffer) {\n\t\tif (vb2_buffer_in_use(q, q->bufs[buffer]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid vb2_core_querybuf(struct vb2_queue *q, unsigned int index, void *pb)\n{\n\tcall_void_bufop(q, fill_user_buffer, q->bufs[index], pb);\n}\nEXPORT_SYMBOL_GPL(vb2_core_querybuf);\n\n \nstatic int __verify_userptr_ops(struct vb2_queue *q)\n{\n\tif (!(q->io_modes & VB2_USERPTR) || !q->mem_ops->get_userptr ||\n\t    !q->mem_ops->put_userptr)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int __verify_mmap_ops(struct vb2_queue *q)\n{\n\tif (!(q->io_modes & VB2_MMAP) || !q->mem_ops->alloc ||\n\t    !q->mem_ops->put || !q->mem_ops->mmap)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int __verify_dmabuf_ops(struct vb2_queue *q)\n{\n\tif (!(q->io_modes & VB2_DMABUF) || !q->mem_ops->attach_dmabuf ||\n\t    !q->mem_ops->detach_dmabuf  || !q->mem_ops->map_dmabuf ||\n\t    !q->mem_ops->unmap_dmabuf)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint vb2_verify_memory_type(struct vb2_queue *q,\n\t\tenum vb2_memory memory, unsigned int type)\n{\n\tif (memory != VB2_MEMORY_MMAP && memory != VB2_MEMORY_USERPTR &&\n\t    memory != VB2_MEMORY_DMABUF) {\n\t\tdprintk(q, 1, \"unsupported memory type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (type != q->type) {\n\t\tdprintk(q, 1, \"requested type is incorrect\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (memory == VB2_MEMORY_MMAP && __verify_mmap_ops(q)) {\n\t\tdprintk(q, 1, \"MMAP for current setup unsupported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (memory == VB2_MEMORY_USERPTR && __verify_userptr_ops(q)) {\n\t\tdprintk(q, 1, \"USERPTR for current setup unsupported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (memory == VB2_MEMORY_DMABUF && __verify_dmabuf_ops(q)) {\n\t\tdprintk(q, 1, \"DMABUF for current setup unsupported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (vb2_fileio_is_active(q)) {\n\t\tdprintk(q, 1, \"file io in progress\\n\");\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(vb2_verify_memory_type);\n\nstatic void set_queue_coherency(struct vb2_queue *q, bool non_coherent_mem)\n{\n\tq->non_coherent_mem = 0;\n\n\tif (!vb2_queue_allows_cache_hints(q))\n\t\treturn;\n\tq->non_coherent_mem = non_coherent_mem;\n}\n\nstatic bool verify_coherency_flags(struct vb2_queue *q, bool non_coherent_mem)\n{\n\tif (non_coherent_mem != q->non_coherent_mem) {\n\t\tdprintk(q, 1, \"memory coherency model mismatch\\n\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint vb2_core_reqbufs(struct vb2_queue *q, enum vb2_memory memory,\n\t\t     unsigned int flags, unsigned int *count)\n{\n\tunsigned int num_buffers, allocated_buffers, num_planes = 0;\n\tunsigned plane_sizes[VB2_MAX_PLANES] = { };\n\tbool non_coherent_mem = flags & V4L2_MEMORY_FLAG_NON_COHERENT;\n\tunsigned int i;\n\tint ret;\n\n\tif (q->streaming) {\n\t\tdprintk(q, 1, \"streaming active\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (q->waiting_in_dqbuf && *count) {\n\t\tdprintk(q, 1, \"another dup()ped fd is waiting for a buffer\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (*count == 0 || q->num_buffers != 0 ||\n\t    (q->memory != VB2_MEMORY_UNKNOWN && q->memory != memory) ||\n\t    !verify_coherency_flags(q, non_coherent_mem)) {\n\t\t \n\t\tmutex_lock(&q->mmap_lock);\n\t\tif (debug && q->memory == VB2_MEMORY_MMAP &&\n\t\t    __buffers_in_use(q))\n\t\t\tdprintk(q, 1, \"memory in use, orphaning buffers\\n\");\n\n\t\t \n\t\t__vb2_queue_cancel(q);\n\t\t__vb2_queue_free(q, q->num_buffers);\n\t\tmutex_unlock(&q->mmap_lock);\n\n\t\t \n\t\tif (*count == 0)\n\t\t\treturn 0;\n\t}\n\n\t \n\tWARN_ON(q->min_buffers_needed > VB2_MAX_FRAME);\n\tnum_buffers = max_t(unsigned int, *count, q->min_buffers_needed);\n\tnum_buffers = min_t(unsigned int, num_buffers, VB2_MAX_FRAME);\n\tmemset(q->alloc_devs, 0, sizeof(q->alloc_devs));\n\t \n\tmutex_lock(&q->mmap_lock);\n\tq->memory = memory;\n\tmutex_unlock(&q->mmap_lock);\n\tset_queue_coherency(q, non_coherent_mem);\n\n\t \n\tret = call_qop(q, queue_setup, q, &num_buffers, &num_planes,\n\t\t       plane_sizes, q->alloc_devs);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tif (WARN_ON(!num_planes)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tfor (i = 0; i < num_planes; i++)\n\t\tif (WARN_ON(!plane_sizes[i])) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t \n\tallocated_buffers =\n\t\t__vb2_queue_alloc(q, memory, num_buffers, num_planes, plane_sizes);\n\tif (allocated_buffers == 0) {\n\t\tdprintk(q, 1, \"memory allocation failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t \n\tif (allocated_buffers < q->min_buffers_needed)\n\t\tret = -ENOMEM;\n\n\t \n\tif (!ret && allocated_buffers < num_buffers) {\n\t\tnum_buffers = allocated_buffers;\n\t\t \n\t\tnum_planes = 0;\n\n\t\tret = call_qop(q, queue_setup, q, &num_buffers,\n\t\t\t       &num_planes, plane_sizes, q->alloc_devs);\n\n\t\tif (!ret && allocated_buffers < num_buffers)\n\t\t\tret = -ENOMEM;\n\n\t\t \n\t}\n\n\tmutex_lock(&q->mmap_lock);\n\tq->num_buffers = allocated_buffers;\n\n\tif (ret < 0) {\n\t\t \n\t\t__vb2_queue_free(q, allocated_buffers);\n\t\tmutex_unlock(&q->mmap_lock);\n\t\treturn ret;\n\t}\n\tmutex_unlock(&q->mmap_lock);\n\n\t \n\t*count = allocated_buffers;\n\tq->waiting_for_buffers = !q->is_output;\n\n\treturn 0;\n\nerror:\n\tmutex_lock(&q->mmap_lock);\n\tq->memory = VB2_MEMORY_UNKNOWN;\n\tmutex_unlock(&q->mmap_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vb2_core_reqbufs);\n\nint vb2_core_create_bufs(struct vb2_queue *q, enum vb2_memory memory,\n\t\t\t unsigned int flags, unsigned int *count,\n\t\t\t unsigned int requested_planes,\n\t\t\t const unsigned int requested_sizes[])\n{\n\tunsigned int num_planes = 0, num_buffers, allocated_buffers;\n\tunsigned plane_sizes[VB2_MAX_PLANES] = { };\n\tbool non_coherent_mem = flags & V4L2_MEMORY_FLAG_NON_COHERENT;\n\tbool no_previous_buffers = !q->num_buffers;\n\tint ret;\n\n\tif (q->num_buffers == VB2_MAX_FRAME) {\n\t\tdprintk(q, 1, \"maximum number of buffers already allocated\\n\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (no_previous_buffers) {\n\t\tif (q->waiting_in_dqbuf && *count) {\n\t\t\tdprintk(q, 1, \"another dup()ped fd is waiting for a buffer\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tmemset(q->alloc_devs, 0, sizeof(q->alloc_devs));\n\t\t \n\t\tmutex_lock(&q->mmap_lock);\n\t\tq->memory = memory;\n\t\tmutex_unlock(&q->mmap_lock);\n\t\tq->waiting_for_buffers = !q->is_output;\n\t\tset_queue_coherency(q, non_coherent_mem);\n\t} else {\n\t\tif (q->memory != memory) {\n\t\t\tdprintk(q, 1, \"memory model mismatch\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!verify_coherency_flags(q, non_coherent_mem))\n\t\t\treturn -EINVAL;\n\t}\n\n\tnum_buffers = min(*count, VB2_MAX_FRAME - q->num_buffers);\n\n\tif (requested_planes && requested_sizes) {\n\t\tnum_planes = requested_planes;\n\t\tmemcpy(plane_sizes, requested_sizes, sizeof(plane_sizes));\n\t}\n\n\t \n\tret = call_qop(q, queue_setup, q, &num_buffers,\n\t\t       &num_planes, plane_sizes, q->alloc_devs);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tallocated_buffers = __vb2_queue_alloc(q, memory, num_buffers,\n\t\t\t\tnum_planes, plane_sizes);\n\tif (allocated_buffers == 0) {\n\t\tdprintk(q, 1, \"memory allocation failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t \n\tif (allocated_buffers < num_buffers) {\n\t\tnum_buffers = allocated_buffers;\n\n\t\t \n\t\tret = call_qop(q, queue_setup, q, &num_buffers,\n\t\t\t       &num_planes, plane_sizes, q->alloc_devs);\n\n\t\tif (!ret && allocated_buffers < num_buffers)\n\t\t\tret = -ENOMEM;\n\n\t\t \n\t}\n\n\tmutex_lock(&q->mmap_lock);\n\tq->num_buffers += allocated_buffers;\n\n\tif (ret < 0) {\n\t\t \n\t\t__vb2_queue_free(q, allocated_buffers);\n\t\tmutex_unlock(&q->mmap_lock);\n\t\treturn -ENOMEM;\n\t}\n\tmutex_unlock(&q->mmap_lock);\n\n\t \n\t*count = allocated_buffers;\n\n\treturn 0;\n\nerror:\n\tif (no_previous_buffers) {\n\t\tmutex_lock(&q->mmap_lock);\n\t\tq->memory = VB2_MEMORY_UNKNOWN;\n\t\tmutex_unlock(&q->mmap_lock);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vb2_core_create_bufs);\n\nvoid *vb2_plane_vaddr(struct vb2_buffer *vb, unsigned int plane_no)\n{\n\tif (plane_no >= vb->num_planes || !vb->planes[plane_no].mem_priv)\n\t\treturn NULL;\n\n\treturn call_ptr_memop(vaddr, vb, vb->planes[plane_no].mem_priv);\n\n}\nEXPORT_SYMBOL_GPL(vb2_plane_vaddr);\n\nvoid *vb2_plane_cookie(struct vb2_buffer *vb, unsigned int plane_no)\n{\n\tif (plane_no >= vb->num_planes || !vb->planes[plane_no].mem_priv)\n\t\treturn NULL;\n\n\treturn call_ptr_memop(cookie, vb, vb->planes[plane_no].mem_priv);\n}\nEXPORT_SYMBOL_GPL(vb2_plane_cookie);\n\nvoid vb2_buffer_done(struct vb2_buffer *vb, enum vb2_buffer_state state)\n{\n\tstruct vb2_queue *q = vb->vb2_queue;\n\tunsigned long flags;\n\n\tif (WARN_ON(vb->state != VB2_BUF_STATE_ACTIVE))\n\t\treturn;\n\n\tif (WARN_ON(state != VB2_BUF_STATE_DONE &&\n\t\t    state != VB2_BUF_STATE_ERROR &&\n\t\t    state != VB2_BUF_STATE_QUEUED))\n\t\tstate = VB2_BUF_STATE_ERROR;\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t \n\tvb->cnt_buf_done++;\n#endif\n\tdprintk(q, 4, \"done processing on buffer %d, state: %s\\n\",\n\t\tvb->index, vb2_state_name(state));\n\n\tif (state != VB2_BUF_STATE_QUEUED)\n\t\t__vb2_buf_mem_finish(vb);\n\n\tspin_lock_irqsave(&q->done_lock, flags);\n\tif (state == VB2_BUF_STATE_QUEUED) {\n\t\tvb->state = VB2_BUF_STATE_QUEUED;\n\t} else {\n\t\t \n\t\tlist_add_tail(&vb->done_entry, &q->done_list);\n\t\tvb->state = state;\n\t}\n\tatomic_dec(&q->owned_by_drv_count);\n\n\tif (state != VB2_BUF_STATE_QUEUED && vb->req_obj.req) {\n\t\tmedia_request_object_unbind(&vb->req_obj);\n\t\tmedia_request_object_put(&vb->req_obj);\n\t}\n\n\tspin_unlock_irqrestore(&q->done_lock, flags);\n\n\ttrace_vb2_buf_done(q, vb);\n\n\tswitch (state) {\n\tcase VB2_BUF_STATE_QUEUED:\n\t\treturn;\n\tdefault:\n\t\t \n\t\twake_up(&q->done_wq);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(vb2_buffer_done);\n\nvoid vb2_discard_done(struct vb2_queue *q)\n{\n\tstruct vb2_buffer *vb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&q->done_lock, flags);\n\tlist_for_each_entry(vb, &q->done_list, done_entry)\n\t\tvb->state = VB2_BUF_STATE_ERROR;\n\tspin_unlock_irqrestore(&q->done_lock, flags);\n}\nEXPORT_SYMBOL_GPL(vb2_discard_done);\n\n \nstatic int __prepare_mmap(struct vb2_buffer *vb)\n{\n\tint ret = 0;\n\n\tret = call_bufop(vb->vb2_queue, fill_vb2_buffer,\n\t\t\t vb, vb->planes);\n\treturn ret ? ret : call_vb_qop(vb, buf_prepare, vb);\n}\n\n \nstatic int __prepare_userptr(struct vb2_buffer *vb)\n{\n\tstruct vb2_plane planes[VB2_MAX_PLANES];\n\tstruct vb2_queue *q = vb->vb2_queue;\n\tvoid *mem_priv;\n\tunsigned int plane;\n\tint ret = 0;\n\tbool reacquired = vb->planes[0].mem_priv == NULL;\n\n\tmemset(planes, 0, sizeof(planes[0]) * vb->num_planes);\n\t \n\tret = call_bufop(vb->vb2_queue, fill_vb2_buffer,\n\t\t\t vb, planes);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (plane = 0; plane < vb->num_planes; ++plane) {\n\t\t \n\t\tif (vb->planes[plane].m.userptr &&\n\t\t\tvb->planes[plane].m.userptr == planes[plane].m.userptr\n\t\t\t&& vb->planes[plane].length == planes[plane].length)\n\t\t\tcontinue;\n\n\t\tdprintk(q, 3, \"userspace address for plane %d changed, reacquiring memory\\n\",\n\t\t\tplane);\n\n\t\t \n\t\tif (planes[plane].length < vb->planes[plane].min_length) {\n\t\t\tdprintk(q, 1, \"provided buffer size %u is less than setup size %u for plane %d\\n\",\n\t\t\t\t\t\tplanes[plane].length,\n\t\t\t\t\t\tvb->planes[plane].min_length,\n\t\t\t\t\t\tplane);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\tif (vb->planes[plane].mem_priv) {\n\t\t\tif (!reacquired) {\n\t\t\t\treacquired = true;\n\t\t\t\tvb->copied_timestamp = 0;\n\t\t\t\tcall_void_vb_qop(vb, buf_cleanup, vb);\n\t\t\t}\n\t\t\tcall_void_memop(vb, put_userptr, vb->planes[plane].mem_priv);\n\t\t}\n\n\t\tvb->planes[plane].mem_priv = NULL;\n\t\tvb->planes[plane].bytesused = 0;\n\t\tvb->planes[plane].length = 0;\n\t\tvb->planes[plane].m.userptr = 0;\n\t\tvb->planes[plane].data_offset = 0;\n\n\t\t \n\t\tmem_priv = call_ptr_memop(get_userptr,\n\t\t\t\t\t  vb,\n\t\t\t\t\t  q->alloc_devs[plane] ? : q->dev,\n\t\t\t\t\t  planes[plane].m.userptr,\n\t\t\t\t\t  planes[plane].length);\n\t\tif (IS_ERR(mem_priv)) {\n\t\t\tdprintk(q, 1, \"failed acquiring userspace memory for plane %d\\n\",\n\t\t\t\tplane);\n\t\t\tret = PTR_ERR(mem_priv);\n\t\t\tgoto err;\n\t\t}\n\t\tvb->planes[plane].mem_priv = mem_priv;\n\t}\n\n\t \n\tfor (plane = 0; plane < vb->num_planes; ++plane) {\n\t\tvb->planes[plane].bytesused = planes[plane].bytesused;\n\t\tvb->planes[plane].length = planes[plane].length;\n\t\tvb->planes[plane].m.userptr = planes[plane].m.userptr;\n\t\tvb->planes[plane].data_offset = planes[plane].data_offset;\n\t}\n\n\tif (reacquired) {\n\t\t \n\t\tret = call_vb_qop(vb, buf_init, vb);\n\t\tif (ret) {\n\t\t\tdprintk(q, 1, \"buffer initialization failed\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tret = call_vb_qop(vb, buf_prepare, vb);\n\tif (ret) {\n\t\tdprintk(q, 1, \"buffer preparation failed\\n\");\n\t\tcall_void_vb_qop(vb, buf_cleanup, vb);\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\t \n\tfor (plane = 0; plane < vb->num_planes; ++plane) {\n\t\tif (vb->planes[plane].mem_priv)\n\t\t\tcall_void_memop(vb, put_userptr,\n\t\t\t\tvb->planes[plane].mem_priv);\n\t\tvb->planes[plane].mem_priv = NULL;\n\t\tvb->planes[plane].m.userptr = 0;\n\t\tvb->planes[plane].length = 0;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int __prepare_dmabuf(struct vb2_buffer *vb)\n{\n\tstruct vb2_plane planes[VB2_MAX_PLANES];\n\tstruct vb2_queue *q = vb->vb2_queue;\n\tvoid *mem_priv;\n\tunsigned int plane;\n\tint ret = 0;\n\tbool reacquired = vb->planes[0].mem_priv == NULL;\n\n\tmemset(planes, 0, sizeof(planes[0]) * vb->num_planes);\n\t \n\tret = call_bufop(vb->vb2_queue, fill_vb2_buffer,\n\t\t\t vb, planes);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (plane = 0; plane < vb->num_planes; ++plane) {\n\t\tstruct dma_buf *dbuf = dma_buf_get(planes[plane].m.fd);\n\n\t\tif (IS_ERR_OR_NULL(dbuf)) {\n\t\t\tdprintk(q, 1, \"invalid dmabuf fd for plane %d\\n\",\n\t\t\t\tplane);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\tif (planes[plane].length == 0)\n\t\t\tplanes[plane].length = dbuf->size;\n\n\t\tif (planes[plane].length < vb->planes[plane].min_length) {\n\t\t\tdprintk(q, 1, \"invalid dmabuf length %u for plane %d, minimum length %u\\n\",\n\t\t\t\tplanes[plane].length, plane,\n\t\t\t\tvb->planes[plane].min_length);\n\t\t\tdma_buf_put(dbuf);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\tif (dbuf == vb->planes[plane].dbuf &&\n\t\t\tvb->planes[plane].length == planes[plane].length) {\n\t\t\tdma_buf_put(dbuf);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdprintk(q, 3, \"buffer for plane %d changed\\n\", plane);\n\n\t\tif (!reacquired) {\n\t\t\treacquired = true;\n\t\t\tvb->copied_timestamp = 0;\n\t\t\tcall_void_vb_qop(vb, buf_cleanup, vb);\n\t\t}\n\n\t\t \n\t\t__vb2_plane_dmabuf_put(vb, &vb->planes[plane]);\n\t\tvb->planes[plane].bytesused = 0;\n\t\tvb->planes[plane].length = 0;\n\t\tvb->planes[plane].m.fd = 0;\n\t\tvb->planes[plane].data_offset = 0;\n\n\t\t \n\t\tmem_priv = call_ptr_memop(attach_dmabuf,\n\t\t\t\t\t  vb,\n\t\t\t\t\t  q->alloc_devs[plane] ? : q->dev,\n\t\t\t\t\t  dbuf,\n\t\t\t\t\t  planes[plane].length);\n\t\tif (IS_ERR(mem_priv)) {\n\t\t\tdprintk(q, 1, \"failed to attach dmabuf\\n\");\n\t\t\tret = PTR_ERR(mem_priv);\n\t\t\tdma_buf_put(dbuf);\n\t\t\tgoto err;\n\t\t}\n\n\t\tvb->planes[plane].dbuf = dbuf;\n\t\tvb->planes[plane].mem_priv = mem_priv;\n\t}\n\n\t \n\tfor (plane = 0; plane < vb->num_planes; ++plane) {\n\t\tif (vb->planes[plane].dbuf_mapped)\n\t\t\tcontinue;\n\n\t\tret = call_memop(vb, map_dmabuf, vb->planes[plane].mem_priv);\n\t\tif (ret) {\n\t\t\tdprintk(q, 1, \"failed to map dmabuf for plane %d\\n\",\n\t\t\t\tplane);\n\t\t\tgoto err;\n\t\t}\n\t\tvb->planes[plane].dbuf_mapped = 1;\n\t}\n\n\t \n\tfor (plane = 0; plane < vb->num_planes; ++plane) {\n\t\tvb->planes[plane].bytesused = planes[plane].bytesused;\n\t\tvb->planes[plane].length = planes[plane].length;\n\t\tvb->planes[plane].m.fd = planes[plane].m.fd;\n\t\tvb->planes[plane].data_offset = planes[plane].data_offset;\n\t}\n\n\tif (reacquired) {\n\t\t \n\t\tret = call_vb_qop(vb, buf_init, vb);\n\t\tif (ret) {\n\t\t\tdprintk(q, 1, \"buffer initialization failed\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tret = call_vb_qop(vb, buf_prepare, vb);\n\tif (ret) {\n\t\tdprintk(q, 1, \"buffer preparation failed\\n\");\n\t\tcall_void_vb_qop(vb, buf_cleanup, vb);\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\t \n\t__vb2_buf_dmabuf_put(vb);\n\n\treturn ret;\n}\n\n \nstatic void __enqueue_in_driver(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *q = vb->vb2_queue;\n\n\tvb->state = VB2_BUF_STATE_ACTIVE;\n\tatomic_inc(&q->owned_by_drv_count);\n\n\ttrace_vb2_buf_queue(q, vb);\n\n\tcall_void_vb_qop(vb, buf_queue, vb);\n}\n\nstatic int __buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *q = vb->vb2_queue;\n\tenum vb2_buffer_state orig_state = vb->state;\n\tint ret;\n\n\tif (q->error) {\n\t\tdprintk(q, 1, \"fatal error occurred on queue\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (vb->prepared)\n\t\treturn 0;\n\tWARN_ON(vb->synced);\n\n\tif (q->is_output) {\n\t\tret = call_vb_qop(vb, buf_out_validate, vb);\n\t\tif (ret) {\n\t\t\tdprintk(q, 1, \"buffer validation failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tvb->state = VB2_BUF_STATE_PREPARING;\n\n\tswitch (q->memory) {\n\tcase VB2_MEMORY_MMAP:\n\t\tret = __prepare_mmap(vb);\n\t\tbreak;\n\tcase VB2_MEMORY_USERPTR:\n\t\tret = __prepare_userptr(vb);\n\t\tbreak;\n\tcase VB2_MEMORY_DMABUF:\n\t\tret = __prepare_dmabuf(vb);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Invalid queue type\\n\");\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret) {\n\t\tdprintk(q, 1, \"buffer preparation failed: %d\\n\", ret);\n\t\tvb->state = orig_state;\n\t\treturn ret;\n\t}\n\n\t__vb2_buf_mem_prepare(vb);\n\tvb->prepared = 1;\n\tvb->state = orig_state;\n\n\treturn 0;\n}\n\nstatic int vb2_req_prepare(struct media_request_object *obj)\n{\n\tstruct vb2_buffer *vb = container_of(obj, struct vb2_buffer, req_obj);\n\tint ret;\n\n\tif (WARN_ON(vb->state != VB2_BUF_STATE_IN_REQUEST))\n\t\treturn -EINVAL;\n\n\tmutex_lock(vb->vb2_queue->lock);\n\tret = __buf_prepare(vb);\n\tmutex_unlock(vb->vb2_queue->lock);\n\treturn ret;\n}\n\nstatic void __vb2_dqbuf(struct vb2_buffer *vb);\n\nstatic void vb2_req_unprepare(struct media_request_object *obj)\n{\n\tstruct vb2_buffer *vb = container_of(obj, struct vb2_buffer, req_obj);\n\n\tmutex_lock(vb->vb2_queue->lock);\n\t__vb2_dqbuf(vb);\n\tvb->state = VB2_BUF_STATE_IN_REQUEST;\n\tmutex_unlock(vb->vb2_queue->lock);\n\tWARN_ON(!vb->req_obj.req);\n}\n\nint vb2_core_qbuf(struct vb2_queue *q, unsigned int index, void *pb,\n\t\t  struct media_request *req);\n\nstatic void vb2_req_queue(struct media_request_object *obj)\n{\n\tstruct vb2_buffer *vb = container_of(obj, struct vb2_buffer, req_obj);\n\tint err;\n\n\tmutex_lock(vb->vb2_queue->lock);\n\t \n\terr = vb2_core_qbuf(vb->vb2_queue, vb->index, NULL, NULL);\n\tWARN_ON_ONCE(err && err != -EIO);\n\tmutex_unlock(vb->vb2_queue->lock);\n}\n\nstatic void vb2_req_unbind(struct media_request_object *obj)\n{\n\tstruct vb2_buffer *vb = container_of(obj, struct vb2_buffer, req_obj);\n\n\tif (vb->state == VB2_BUF_STATE_IN_REQUEST)\n\t\tcall_void_bufop(vb->vb2_queue, init_buffer, vb);\n}\n\nstatic void vb2_req_release(struct media_request_object *obj)\n{\n\tstruct vb2_buffer *vb = container_of(obj, struct vb2_buffer, req_obj);\n\n\tif (vb->state == VB2_BUF_STATE_IN_REQUEST) {\n\t\tvb->state = VB2_BUF_STATE_DEQUEUED;\n\t\tif (vb->request)\n\t\t\tmedia_request_put(vb->request);\n\t\tvb->request = NULL;\n\t}\n}\n\nstatic const struct media_request_object_ops vb2_core_req_ops = {\n\t.prepare = vb2_req_prepare,\n\t.unprepare = vb2_req_unprepare,\n\t.queue = vb2_req_queue,\n\t.unbind = vb2_req_unbind,\n\t.release = vb2_req_release,\n};\n\nbool vb2_request_object_is_buffer(struct media_request_object *obj)\n{\n\treturn obj->ops == &vb2_core_req_ops;\n}\nEXPORT_SYMBOL_GPL(vb2_request_object_is_buffer);\n\nunsigned int vb2_request_buffer_cnt(struct media_request *req)\n{\n\tstruct media_request_object *obj;\n\tunsigned long flags;\n\tunsigned int buffer_cnt = 0;\n\n\tspin_lock_irqsave(&req->lock, flags);\n\tlist_for_each_entry(obj, &req->objects, list)\n\t\tif (vb2_request_object_is_buffer(obj))\n\t\t\tbuffer_cnt++;\n\tspin_unlock_irqrestore(&req->lock, flags);\n\n\treturn buffer_cnt;\n}\nEXPORT_SYMBOL_GPL(vb2_request_buffer_cnt);\n\nint vb2_core_prepare_buf(struct vb2_queue *q, unsigned int index, void *pb)\n{\n\tstruct vb2_buffer *vb;\n\tint ret;\n\n\tvb = q->bufs[index];\n\tif (vb->state != VB2_BUF_STATE_DEQUEUED) {\n\t\tdprintk(q, 1, \"invalid buffer state %s\\n\",\n\t\t\tvb2_state_name(vb->state));\n\t\treturn -EINVAL;\n\t}\n\tif (vb->prepared) {\n\t\tdprintk(q, 1, \"buffer already prepared\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = __buf_prepare(vb);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcall_void_bufop(q, fill_user_buffer, vb, pb);\n\n\tdprintk(q, 2, \"prepare of buffer %d succeeded\\n\", vb->index);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vb2_core_prepare_buf);\n\n \nstatic int vb2_start_streaming(struct vb2_queue *q)\n{\n\tstruct vb2_buffer *vb;\n\tint ret;\n\n\t \n\tlist_for_each_entry(vb, &q->queued_list, queued_entry)\n\t\t__enqueue_in_driver(vb);\n\n\t \n\tq->start_streaming_called = 1;\n\tret = call_qop(q, start_streaming, q,\n\t\t       atomic_read(&q->owned_by_drv_count));\n\tif (!ret)\n\t\treturn 0;\n\n\tq->start_streaming_called = 0;\n\n\tdprintk(q, 1, \"driver refused to start streaming\\n\");\n\t \n\tif (WARN_ON(atomic_read(&q->owned_by_drv_count))) {\n\t\tunsigned i;\n\n\t\t \n\t\tfor (i = 0; i < q->num_buffers; ++i) {\n\t\t\tvb = q->bufs[i];\n\t\t\tif (vb->state == VB2_BUF_STATE_ACTIVE)\n\t\t\t\tvb2_buffer_done(vb, VB2_BUF_STATE_QUEUED);\n\t\t}\n\t\t \n\t\tWARN_ON(atomic_read(&q->owned_by_drv_count));\n\t}\n\t \n\tWARN_ON(!list_empty(&q->done_list));\n\treturn ret;\n}\n\nint vb2_core_qbuf(struct vb2_queue *q, unsigned int index, void *pb,\n\t\t  struct media_request *req)\n{\n\tstruct vb2_buffer *vb;\n\tenum vb2_buffer_state orig_state;\n\tint ret;\n\n\tif (q->error) {\n\t\tdprintk(q, 1, \"fatal error occurred on queue\\n\");\n\t\treturn -EIO;\n\t}\n\n\tvb = q->bufs[index];\n\n\tif (!req && vb->state != VB2_BUF_STATE_IN_REQUEST &&\n\t    q->requires_requests) {\n\t\tdprintk(q, 1, \"qbuf requires a request\\n\");\n\t\treturn -EBADR;\n\t}\n\n\tif ((req && q->uses_qbuf) ||\n\t    (!req && vb->state != VB2_BUF_STATE_IN_REQUEST &&\n\t     q->uses_requests)) {\n\t\tdprintk(q, 1, \"queue in wrong mode (qbuf vs requests)\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (req) {\n\t\tint ret;\n\n\t\tq->uses_requests = 1;\n\t\tif (vb->state != VB2_BUF_STATE_DEQUEUED) {\n\t\t\tdprintk(q, 1, \"buffer %d not in dequeued state\\n\",\n\t\t\t\tvb->index);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (q->is_output && !vb->prepared) {\n\t\t\tret = call_vb_qop(vb, buf_out_validate, vb);\n\t\t\tif (ret) {\n\t\t\t\tdprintk(q, 1, \"buffer validation failed\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tmedia_request_object_init(&vb->req_obj);\n\n\t\t \n\t\tret = media_request_lock_for_update(req);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = media_request_object_bind(req, &vb2_core_req_ops,\n\t\t\t\t\t\tq, true, &vb->req_obj);\n\t\tmedia_request_unlock_for_update(req);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tvb->state = VB2_BUF_STATE_IN_REQUEST;\n\n\t\t \n\t\tmedia_request_get(req);\n\t\tvb->request = req;\n\n\t\t \n\t\tif (pb) {\n\t\t\tcall_void_bufop(q, copy_timestamp, vb, pb);\n\t\t\tcall_void_bufop(q, fill_user_buffer, vb, pb);\n\t\t}\n\n\t\tdprintk(q, 2, \"qbuf of buffer %d succeeded\\n\", vb->index);\n\t\treturn 0;\n\t}\n\n\tif (vb->state != VB2_BUF_STATE_IN_REQUEST)\n\t\tq->uses_qbuf = 1;\n\n\tswitch (vb->state) {\n\tcase VB2_BUF_STATE_DEQUEUED:\n\tcase VB2_BUF_STATE_IN_REQUEST:\n\t\tif (!vb->prepared) {\n\t\t\tret = __buf_prepare(vb);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase VB2_BUF_STATE_PREPARING:\n\t\tdprintk(q, 1, \"buffer still being prepared\\n\");\n\t\treturn -EINVAL;\n\tdefault:\n\t\tdprintk(q, 1, \"invalid buffer state %s\\n\",\n\t\t\tvb2_state_name(vb->state));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\torig_state = vb->state;\n\tlist_add_tail(&vb->queued_entry, &q->queued_list);\n\tq->queued_count++;\n\tq->waiting_for_buffers = false;\n\tvb->state = VB2_BUF_STATE_QUEUED;\n\n\tif (pb)\n\t\tcall_void_bufop(q, copy_timestamp, vb, pb);\n\n\ttrace_vb2_qbuf(q, vb);\n\n\t \n\tif (q->start_streaming_called)\n\t\t__enqueue_in_driver(vb);\n\n\t \n\tif (pb)\n\t\tcall_void_bufop(q, fill_user_buffer, vb, pb);\n\n\t \n\tif (q->streaming && !q->start_streaming_called &&\n\t    q->queued_count >= q->min_buffers_needed) {\n\t\tret = vb2_start_streaming(q);\n\t\tif (ret) {\n\t\t\t \n\t\t\tlist_del(&vb->queued_entry);\n\t\t\tq->queued_count--;\n\t\t\tvb->state = orig_state;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdprintk(q, 2, \"qbuf of buffer %d succeeded\\n\", vb->index);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vb2_core_qbuf);\n\n \nstatic int __vb2_wait_for_done_vb(struct vb2_queue *q, int nonblocking)\n{\n\t \n\n\tfor (;;) {\n\t\tint ret;\n\n\t\tif (q->waiting_in_dqbuf) {\n\t\t\tdprintk(q, 1, \"another dup()ped fd is waiting for a buffer\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tif (!q->streaming) {\n\t\t\tdprintk(q, 1, \"streaming off, will not wait for buffers\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (q->error) {\n\t\t\tdprintk(q, 1, \"Queue in error state, will not wait for buffers\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (q->last_buffer_dequeued) {\n\t\t\tdprintk(q, 3, \"last buffer dequeued already, will not wait for buffers\\n\");\n\t\t\treturn -EPIPE;\n\t\t}\n\n\t\tif (!list_empty(&q->done_list)) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tif (nonblocking) {\n\t\t\tdprintk(q, 3, \"nonblocking and no buffers to dequeue, will not wait\\n\");\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tq->waiting_in_dqbuf = 1;\n\t\t \n\t\tcall_void_qop(q, wait_prepare, q);\n\n\t\t \n\t\tdprintk(q, 3, \"will sleep waiting for buffers\\n\");\n\t\tret = wait_event_interruptible(q->done_wq,\n\t\t\t\t!list_empty(&q->done_list) || !q->streaming ||\n\t\t\t\tq->error);\n\n\t\t \n\t\tcall_void_qop(q, wait_finish, q);\n\t\tq->waiting_in_dqbuf = 0;\n\t\tif (ret) {\n\t\t\tdprintk(q, 1, \"sleep was interrupted\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int __vb2_get_done_vb(struct vb2_queue *q, struct vb2_buffer **vb,\n\t\t\t     void *pb, int nonblocking)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\t \n\tret = __vb2_wait_for_done_vb(q, nonblocking);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tspin_lock_irqsave(&q->done_lock, flags);\n\t*vb = list_first_entry(&q->done_list, struct vb2_buffer, done_entry);\n\t \n\tif (pb)\n\t\tret = call_bufop(q, verify_planes_array, *vb, pb);\n\tif (!ret)\n\t\tlist_del(&(*vb)->done_entry);\n\tspin_unlock_irqrestore(&q->done_lock, flags);\n\n\treturn ret;\n}\n\nint vb2_wait_for_all_buffers(struct vb2_queue *q)\n{\n\tif (!q->streaming) {\n\t\tdprintk(q, 1, \"streaming off, will not wait for buffers\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (q->start_streaming_called)\n\t\twait_event(q->done_wq, !atomic_read(&q->owned_by_drv_count));\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vb2_wait_for_all_buffers);\n\n \nstatic void __vb2_dqbuf(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *q = vb->vb2_queue;\n\n\t \n\tif (vb->state == VB2_BUF_STATE_DEQUEUED)\n\t\treturn;\n\n\tvb->state = VB2_BUF_STATE_DEQUEUED;\n\n\tcall_void_bufop(q, init_buffer, vb);\n}\n\nint vb2_core_dqbuf(struct vb2_queue *q, unsigned int *pindex, void *pb,\n\t\t   bool nonblocking)\n{\n\tstruct vb2_buffer *vb = NULL;\n\tint ret;\n\n\tret = __vb2_get_done_vb(q, &vb, pb, nonblocking);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (vb->state) {\n\tcase VB2_BUF_STATE_DONE:\n\t\tdprintk(q, 3, \"returning done buffer\\n\");\n\t\tbreak;\n\tcase VB2_BUF_STATE_ERROR:\n\t\tdprintk(q, 3, \"returning done buffer with errors\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdprintk(q, 1, \"invalid buffer state %s\\n\",\n\t\t\tvb2_state_name(vb->state));\n\t\treturn -EINVAL;\n\t}\n\n\tcall_void_vb_qop(vb, buf_finish, vb);\n\tvb->prepared = 0;\n\n\tif (pindex)\n\t\t*pindex = vb->index;\n\n\t \n\tif (pb)\n\t\tcall_void_bufop(q, fill_user_buffer, vb, pb);\n\n\t \n\tlist_del(&vb->queued_entry);\n\tq->queued_count--;\n\n\ttrace_vb2_dqbuf(q, vb);\n\n\t \n\t__vb2_dqbuf(vb);\n\n\tif (WARN_ON(vb->req_obj.req)) {\n\t\tmedia_request_object_unbind(&vb->req_obj);\n\t\tmedia_request_object_put(&vb->req_obj);\n\t}\n\tif (vb->request)\n\t\tmedia_request_put(vb->request);\n\tvb->request = NULL;\n\n\tdprintk(q, 2, \"dqbuf of buffer %d, state: %s\\n\",\n\t\tvb->index, vb2_state_name(vb->state));\n\n\treturn 0;\n\n}\nEXPORT_SYMBOL_GPL(vb2_core_dqbuf);\n\n \nstatic void __vb2_queue_cancel(struct vb2_queue *q)\n{\n\tunsigned int i;\n\n\t \n\tif (q->start_streaming_called)\n\t\tcall_void_qop(q, stop_streaming, q);\n\n\tif (q->streaming)\n\t\tcall_void_qop(q, unprepare_streaming, q);\n\n\t \n\tif (WARN_ON(atomic_read(&q->owned_by_drv_count))) {\n\t\tfor (i = 0; i < q->num_buffers; ++i)\n\t\t\tif (q->bufs[i]->state == VB2_BUF_STATE_ACTIVE) {\n\t\t\t\tpr_warn(\"driver bug: stop_streaming operation is leaving buf %p in active state\\n\",\n\t\t\t\t\tq->bufs[i]);\n\t\t\t\tvb2_buffer_done(q->bufs[i], VB2_BUF_STATE_ERROR);\n\t\t\t}\n\t\t \n\t\tWARN_ON(atomic_read(&q->owned_by_drv_count));\n\t}\n\n\tq->streaming = 0;\n\tq->start_streaming_called = 0;\n\tq->queued_count = 0;\n\tq->error = 0;\n\tq->uses_requests = 0;\n\tq->uses_qbuf = 0;\n\n\t \n\tINIT_LIST_HEAD(&q->queued_list);\n\t \n\tINIT_LIST_HEAD(&q->done_list);\n\tatomic_set(&q->owned_by_drv_count, 0);\n\twake_up_all(&q->done_wq);\n\n\t \n\tfor (i = 0; i < q->num_buffers; ++i) {\n\t\tstruct vb2_buffer *vb = q->bufs[i];\n\t\tstruct media_request *req = vb->req_obj.req;\n\n\t\t \n\t\tif (req) {\n\t\t\tenum media_request_state state;\n\t\t\tunsigned long flags;\n\n\t\t\tspin_lock_irqsave(&req->lock, flags);\n\t\t\tstate = req->state;\n\t\t\tspin_unlock_irqrestore(&req->lock, flags);\n\n\t\t\tif (state == MEDIA_REQUEST_STATE_QUEUED)\n\t\t\t\tcall_void_vb_qop(vb, buf_request_complete, vb);\n\t\t}\n\n\t\t__vb2_buf_mem_finish(vb);\n\n\t\tif (vb->prepared) {\n\t\t\tcall_void_vb_qop(vb, buf_finish, vb);\n\t\t\tvb->prepared = 0;\n\t\t}\n\t\t__vb2_dqbuf(vb);\n\n\t\tif (vb->req_obj.req) {\n\t\t\tmedia_request_object_unbind(&vb->req_obj);\n\t\t\tmedia_request_object_put(&vb->req_obj);\n\t\t}\n\t\tif (vb->request)\n\t\t\tmedia_request_put(vb->request);\n\t\tvb->request = NULL;\n\t\tvb->copied_timestamp = 0;\n\t}\n}\n\nint vb2_core_streamon(struct vb2_queue *q, unsigned int type)\n{\n\tint ret;\n\n\tif (type != q->type) {\n\t\tdprintk(q, 1, \"invalid stream type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (q->streaming) {\n\t\tdprintk(q, 3, \"already streaming\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!q->num_buffers) {\n\t\tdprintk(q, 1, \"no buffers have been allocated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (q->num_buffers < q->min_buffers_needed) {\n\t\tdprintk(q, 1, \"need at least %u allocated buffers\\n\",\n\t\t\t\tq->min_buffers_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tret = call_qop(q, prepare_streaming, q);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (q->queued_count >= q->min_buffers_needed) {\n\t\tret = vb2_start_streaming(q);\n\t\tif (ret)\n\t\t\tgoto unprepare;\n\t}\n\n\tq->streaming = 1;\n\n\tdprintk(q, 3, \"successful\\n\");\n\treturn 0;\n\nunprepare:\n\tcall_void_qop(q, unprepare_streaming, q);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vb2_core_streamon);\n\nvoid vb2_queue_error(struct vb2_queue *q)\n{\n\tq->error = 1;\n\n\twake_up_all(&q->done_wq);\n}\nEXPORT_SYMBOL_GPL(vb2_queue_error);\n\nint vb2_core_streamoff(struct vb2_queue *q, unsigned int type)\n{\n\tif (type != q->type) {\n\t\tdprintk(q, 1, \"invalid stream type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\t__vb2_queue_cancel(q);\n\tq->waiting_for_buffers = !q->is_output;\n\tq->last_buffer_dequeued = false;\n\n\tdprintk(q, 3, \"successful\\n\");\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vb2_core_streamoff);\n\n \nstatic int __find_plane_by_offset(struct vb2_queue *q, unsigned long off,\n\t\t\tunsigned int *_buffer, unsigned int *_plane)\n{\n\tstruct vb2_buffer *vb;\n\tunsigned int buffer, plane;\n\n\t \n\tlockdep_assert_held(&q->mmap_lock);\n\n\tif (q->memory != VB2_MEMORY_MMAP) {\n\t\tdprintk(q, 1, \"queue is not currently set up for mmap\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vb2_fileio_is_active(q)) {\n\t\tdprintk(q, 1, \"file io in progress\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tfor (buffer = 0; buffer < q->num_buffers; ++buffer) {\n\t\tvb = q->bufs[buffer];\n\n\t\tfor (plane = 0; plane < vb->num_planes; ++plane) {\n\t\t\tif (vb->planes[plane].m.offset == off) {\n\t\t\t\t*_buffer = buffer;\n\t\t\t\t*_plane = plane;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nint vb2_core_expbuf(struct vb2_queue *q, int *fd, unsigned int type,\n\t\tunsigned int index, unsigned int plane, unsigned int flags)\n{\n\tstruct vb2_buffer *vb = NULL;\n\tstruct vb2_plane *vb_plane;\n\tint ret;\n\tstruct dma_buf *dbuf;\n\n\tif (q->memory != VB2_MEMORY_MMAP) {\n\t\tdprintk(q, 1, \"queue is not currently set up for mmap\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!q->mem_ops->get_dmabuf) {\n\t\tdprintk(q, 1, \"queue does not support DMA buffer exporting\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (flags & ~(O_CLOEXEC | O_ACCMODE)) {\n\t\tdprintk(q, 1, \"queue does support only O_CLOEXEC and access mode flags\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (type != q->type) {\n\t\tdprintk(q, 1, \"invalid buffer type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (index >= q->num_buffers) {\n\t\tdprintk(q, 1, \"buffer index out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvb = q->bufs[index];\n\n\tif (plane >= vb->num_planes) {\n\t\tdprintk(q, 1, \"buffer plane out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vb2_fileio_is_active(q)) {\n\t\tdprintk(q, 1, \"expbuf: file io in progress\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tvb_plane = &vb->planes[plane];\n\n\tdbuf = call_ptr_memop(get_dmabuf,\n\t\t\t      vb,\n\t\t\t      vb_plane->mem_priv,\n\t\t\t      flags & O_ACCMODE);\n\tif (IS_ERR_OR_NULL(dbuf)) {\n\t\tdprintk(q, 1, \"failed to export buffer %d, plane %d\\n\",\n\t\t\tindex, plane);\n\t\treturn -EINVAL;\n\t}\n\n\tret = dma_buf_fd(dbuf, flags & ~O_ACCMODE);\n\tif (ret < 0) {\n\t\tdprintk(q, 3, \"buffer %d, plane %d failed to export (%d)\\n\",\n\t\t\tindex, plane, ret);\n\t\tdma_buf_put(dbuf);\n\t\treturn ret;\n\t}\n\n\tdprintk(q, 3, \"buffer %d, plane %d exported as %d descriptor\\n\",\n\t\tindex, plane, ret);\n\t*fd = ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vb2_core_expbuf);\n\nint vb2_mmap(struct vb2_queue *q, struct vm_area_struct *vma)\n{\n\tunsigned long off = vma->vm_pgoff << PAGE_SHIFT;\n\tstruct vb2_buffer *vb;\n\tunsigned int buffer = 0, plane = 0;\n\tint ret;\n\tunsigned long length;\n\n\t \n\tif (!(vma->vm_flags & VM_SHARED)) {\n\t\tdprintk(q, 1, \"invalid vma flags, VM_SHARED needed\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (q->is_output) {\n\t\tif (!(vma->vm_flags & VM_WRITE)) {\n\t\t\tdprintk(q, 1, \"invalid vma flags, VM_WRITE needed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (!(vma->vm_flags & VM_READ)) {\n\t\t\tdprintk(q, 1, \"invalid vma flags, VM_READ needed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmutex_lock(&q->mmap_lock);\n\n\t \n\tret = __find_plane_by_offset(q, off, &buffer, &plane);\n\tif (ret)\n\t\tgoto unlock;\n\n\tvb = q->bufs[buffer];\n\n\t \n\tlength = PAGE_ALIGN(vb->planes[plane].length);\n\tif (length < (vma->vm_end - vma->vm_start)) {\n\t\tdprintk(q, 1,\n\t\t\t\"MMAP invalid, as it would overflow buffer length\\n\");\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\t \n\tvma->vm_pgoff = 0;\n\n\tret = call_memop(vb, mmap, vb->planes[plane].mem_priv, vma);\n\nunlock:\n\tmutex_unlock(&q->mmap_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tdprintk(q, 3, \"buffer %d, plane %d successfully mapped\\n\", buffer, plane);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vb2_mmap);\n\n#ifndef CONFIG_MMU\nunsigned long vb2_get_unmapped_area(struct vb2_queue *q,\n\t\t\t\t    unsigned long addr,\n\t\t\t\t    unsigned long len,\n\t\t\t\t    unsigned long pgoff,\n\t\t\t\t    unsigned long flags)\n{\n\tunsigned long off = pgoff << PAGE_SHIFT;\n\tstruct vb2_buffer *vb;\n\tunsigned int buffer, plane;\n\tvoid *vaddr;\n\tint ret;\n\n\tmutex_lock(&q->mmap_lock);\n\n\t \n\tret = __find_plane_by_offset(q, off, &buffer, &plane);\n\tif (ret)\n\t\tgoto unlock;\n\n\tvb = q->bufs[buffer];\n\n\tvaddr = vb2_plane_vaddr(vb, plane);\n\tmutex_unlock(&q->mmap_lock);\n\treturn vaddr ? (unsigned long)vaddr : -EINVAL;\n\nunlock:\n\tmutex_unlock(&q->mmap_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vb2_get_unmapped_area);\n#endif\n\nint vb2_core_queue_init(struct vb2_queue *q)\n{\n\t \n\tif (WARN_ON(!q)\t\t\t  ||\n\t    WARN_ON(!q->ops)\t\t  ||\n\t    WARN_ON(!q->mem_ops)\t  ||\n\t    WARN_ON(!q->type)\t\t  ||\n\t    WARN_ON(!q->io_modes)\t  ||\n\t    WARN_ON(!q->ops->queue_setup) ||\n\t    WARN_ON(!q->ops->buf_queue))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(q->requires_requests && !q->supports_requests))\n\t\treturn -EINVAL;\n\n\t \n\tif (WARN_ON(q->supports_requests && q->min_buffers_needed))\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&q->queued_list);\n\tINIT_LIST_HEAD(&q->done_list);\n\tspin_lock_init(&q->done_lock);\n\tmutex_init(&q->mmap_lock);\n\tinit_waitqueue_head(&q->done_wq);\n\n\tq->memory = VB2_MEMORY_UNKNOWN;\n\n\tif (q->buf_struct_size == 0)\n\t\tq->buf_struct_size = sizeof(struct vb2_buffer);\n\n\tif (q->bidirectional)\n\t\tq->dma_dir = DMA_BIDIRECTIONAL;\n\telse\n\t\tq->dma_dir = q->is_output ? DMA_TO_DEVICE : DMA_FROM_DEVICE;\n\n\tif (q->name[0] == '\\0')\n\t\tsnprintf(q->name, sizeof(q->name), \"%s-%p\",\n\t\t\t q->is_output ? \"out\" : \"cap\", q);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vb2_core_queue_init);\n\nstatic int __vb2_init_fileio(struct vb2_queue *q, int read);\nstatic int __vb2_cleanup_fileio(struct vb2_queue *q);\nvoid vb2_core_queue_release(struct vb2_queue *q)\n{\n\t__vb2_cleanup_fileio(q);\n\t__vb2_queue_cancel(q);\n\tmutex_lock(&q->mmap_lock);\n\t__vb2_queue_free(q, q->num_buffers);\n\tmutex_unlock(&q->mmap_lock);\n}\nEXPORT_SYMBOL_GPL(vb2_core_queue_release);\n\n__poll_t vb2_core_poll(struct vb2_queue *q, struct file *file,\n\t\tpoll_table *wait)\n{\n\t__poll_t req_events = poll_requested_events(wait);\n\tstruct vb2_buffer *vb = NULL;\n\tunsigned long flags;\n\n\t \n\tpoll_wait(file, &q->done_wq, wait);\n\n\tif (!q->is_output && !(req_events & (EPOLLIN | EPOLLRDNORM)))\n\t\treturn 0;\n\tif (q->is_output && !(req_events & (EPOLLOUT | EPOLLWRNORM)))\n\t\treturn 0;\n\n\t \n\tif (q->num_buffers == 0 && !vb2_fileio_is_active(q)) {\n\t\tif (!q->is_output && (q->io_modes & VB2_READ) &&\n\t\t\t\t(req_events & (EPOLLIN | EPOLLRDNORM))) {\n\t\t\tif (__vb2_init_fileio(q, 1))\n\t\t\t\treturn EPOLLERR;\n\t\t}\n\t\tif (q->is_output && (q->io_modes & VB2_WRITE) &&\n\t\t\t\t(req_events & (EPOLLOUT | EPOLLWRNORM))) {\n\t\t\tif (__vb2_init_fileio(q, 0))\n\t\t\t\treturn EPOLLERR;\n\t\t\t \n\t\t\treturn EPOLLOUT | EPOLLWRNORM;\n\t\t}\n\t}\n\n\t \n\tif (!vb2_is_streaming(q) || q->error)\n\t\treturn EPOLLERR;\n\n\t \n\tif (q->quirk_poll_must_check_waiting_for_buffers &&\n\t    q->waiting_for_buffers && (req_events & (EPOLLIN | EPOLLRDNORM)))\n\t\treturn EPOLLERR;\n\n\t \n\tif (q->is_output && q->fileio && q->queued_count < q->num_buffers)\n\t\treturn EPOLLOUT | EPOLLWRNORM;\n\n\tif (list_empty(&q->done_list)) {\n\t\t \n\t\tif (q->last_buffer_dequeued)\n\t\t\treturn EPOLLIN | EPOLLRDNORM;\n\t}\n\n\t \n\tspin_lock_irqsave(&q->done_lock, flags);\n\tif (!list_empty(&q->done_list))\n\t\tvb = list_first_entry(&q->done_list, struct vb2_buffer,\n\t\t\t\t\tdone_entry);\n\tspin_unlock_irqrestore(&q->done_lock, flags);\n\n\tif (vb && (vb->state == VB2_BUF_STATE_DONE\n\t\t\t|| vb->state == VB2_BUF_STATE_ERROR)) {\n\t\treturn (q->is_output) ?\n\t\t\t\tEPOLLOUT | EPOLLWRNORM :\n\t\t\t\tEPOLLIN | EPOLLRDNORM;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vb2_core_poll);\n\n \nstruct vb2_fileio_buf {\n\tvoid *vaddr;\n\tunsigned int size;\n\tunsigned int pos;\n\tunsigned int queued:1;\n};\n\n \nstruct vb2_fileio_data {\n\tunsigned int count;\n\tunsigned int type;\n\tunsigned int memory;\n\tstruct vb2_fileio_buf bufs[VB2_MAX_FRAME];\n\tunsigned int cur_index;\n\tunsigned int initial_index;\n\tunsigned int q_count;\n\tunsigned int dq_count;\n\tunsigned read_once:1;\n\tunsigned write_immediately:1;\n};\n\n \nstatic int __vb2_init_fileio(struct vb2_queue *q, int read)\n{\n\tstruct vb2_fileio_data *fileio;\n\tint i, ret;\n\tunsigned int count = 0;\n\n\t \n\tif (WARN_ON((read && !(q->io_modes & VB2_READ)) ||\n\t\t    (!read && !(q->io_modes & VB2_WRITE))))\n\t\treturn -EINVAL;\n\n\t \n\tif (!q->mem_ops->vaddr)\n\t\treturn -EBUSY;\n\n\t \n\tif (q->streaming || q->num_buffers > 0)\n\t\treturn -EBUSY;\n\n\t \n\tcount = 1;\n\n\tdprintk(q, 3, \"setting up file io: mode %s, count %d, read_once %d, write_immediately %d\\n\",\n\t\t(read) ? \"read\" : \"write\", count, q->fileio_read_once,\n\t\tq->fileio_write_immediately);\n\n\tfileio = kzalloc(sizeof(*fileio), GFP_KERNEL);\n\tif (fileio == NULL)\n\t\treturn -ENOMEM;\n\n\tfileio->read_once = q->fileio_read_once;\n\tfileio->write_immediately = q->fileio_write_immediately;\n\n\t \n\tfileio->count = count;\n\tfileio->memory = VB2_MEMORY_MMAP;\n\tfileio->type = q->type;\n\tq->fileio = fileio;\n\tret = vb2_core_reqbufs(q, fileio->memory, 0, &fileio->count);\n\tif (ret)\n\t\tgoto err_kfree;\n\n\t \n\tif (q->bufs[0]->num_planes != 1) {\n\t\tret = -EBUSY;\n\t\tgoto err_reqbufs;\n\t}\n\n\t \n\tfor (i = 0; i < q->num_buffers; i++) {\n\t\tfileio->bufs[i].vaddr = vb2_plane_vaddr(q->bufs[i], 0);\n\t\tif (fileio->bufs[i].vaddr == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_reqbufs;\n\t\t}\n\t\tfileio->bufs[i].size = vb2_plane_size(q->bufs[i], 0);\n\t}\n\n\t \n\tif (read) {\n\t\t \n\t\tfor (i = 0; i < q->num_buffers; i++) {\n\t\t\tret = vb2_core_qbuf(q, i, NULL, NULL);\n\t\t\tif (ret)\n\t\t\t\tgoto err_reqbufs;\n\t\t\tfileio->bufs[i].queued = 1;\n\t\t}\n\t\t \n\t\tfileio->initial_index = q->num_buffers;\n\t\tfileio->cur_index = q->num_buffers;\n\t}\n\n\t \n\tret = vb2_core_streamon(q, q->type);\n\tif (ret)\n\t\tgoto err_reqbufs;\n\n\treturn ret;\n\nerr_reqbufs:\n\tfileio->count = 0;\n\tvb2_core_reqbufs(q, fileio->memory, 0, &fileio->count);\n\nerr_kfree:\n\tq->fileio = NULL;\n\tkfree(fileio);\n\treturn ret;\n}\n\n \nstatic int __vb2_cleanup_fileio(struct vb2_queue *q)\n{\n\tstruct vb2_fileio_data *fileio = q->fileio;\n\n\tif (fileio) {\n\t\tvb2_core_streamoff(q, q->type);\n\t\tq->fileio = NULL;\n\t\tfileio->count = 0;\n\t\tvb2_core_reqbufs(q, fileio->memory, 0, &fileio->count);\n\t\tkfree(fileio);\n\t\tdprintk(q, 3, \"file io emulator closed\\n\");\n\t}\n\treturn 0;\n}\n\n \nstatic size_t __vb2_perform_fileio(struct vb2_queue *q, char __user *data, size_t count,\n\t\tloff_t *ppos, int nonblock, int read)\n{\n\tstruct vb2_fileio_data *fileio;\n\tstruct vb2_fileio_buf *buf;\n\tbool is_multiplanar = q->is_multiplanar;\n\t \n\tbool copy_timestamp = !read && q->copy_timestamp;\n\tunsigned index;\n\tint ret;\n\n\tdprintk(q, 3, \"mode %s, offset %ld, count %zd, %sblocking\\n\",\n\t\tread ? \"read\" : \"write\", (long)*ppos, count,\n\t\tnonblock ? \"non\" : \"\");\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tif (q->waiting_in_dqbuf) {\n\t\tdprintk(q, 3, \"another dup()ped fd is %s\\n\",\n\t\t\tread ? \"reading\" : \"writing\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (!vb2_fileio_is_active(q)) {\n\t\tret = __vb2_init_fileio(q, read);\n\t\tdprintk(q, 3, \"vb2_init_fileio result: %d\\n\", ret);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tfileio = q->fileio;\n\n\t \n\tindex = fileio->cur_index;\n\tif (index >= q->num_buffers) {\n\t\tstruct vb2_buffer *b;\n\n\t\t \n\t\tret = vb2_core_dqbuf(q, &index, NULL, nonblock);\n\t\tdprintk(q, 5, \"vb2_dqbuf result: %d\\n\", ret);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tfileio->dq_count += 1;\n\n\t\tfileio->cur_index = index;\n\t\tbuf = &fileio->bufs[index];\n\t\tb = q->bufs[index];\n\n\t\t \n\t\tbuf->pos = 0;\n\t\tbuf->queued = 0;\n\t\tbuf->size = read ? vb2_get_plane_payload(q->bufs[index], 0)\n\t\t\t\t : vb2_plane_size(q->bufs[index], 0);\n\t\t \n\t\tif (is_multiplanar && read &&\n\t\t\t\tb->planes[0].data_offset < buf->size) {\n\t\t\tbuf->pos = b->planes[0].data_offset;\n\t\t\tbuf->size -= buf->pos;\n\t\t}\n\t} else {\n\t\tbuf = &fileio->bufs[index];\n\t}\n\n\t \n\tif (buf->pos + count > buf->size) {\n\t\tcount = buf->size - buf->pos;\n\t\tdprintk(q, 5, \"reducing read count: %zd\\n\", count);\n\t}\n\n\t \n\tdprintk(q, 3, \"copying %zd bytes - buffer %d, offset %u\\n\",\n\t\tcount, index, buf->pos);\n\tif (read)\n\t\tret = copy_to_user(data, buf->vaddr + buf->pos, count);\n\telse\n\t\tret = copy_from_user(buf->vaddr + buf->pos, data, count);\n\tif (ret) {\n\t\tdprintk(q, 3, \"error copying data\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tbuf->pos += count;\n\t*ppos += count;\n\n\t \n\tif (buf->pos == buf->size || (!read && fileio->write_immediately)) {\n\t\tstruct vb2_buffer *b = q->bufs[index];\n\n\t\t \n\t\tif (read && fileio->read_once && fileio->dq_count == 1) {\n\t\t\tdprintk(q, 3, \"read limit reached\\n\");\n\t\t\treturn __vb2_cleanup_fileio(q);\n\t\t}\n\n\t\t \n\t\tb->planes[0].bytesused = buf->pos;\n\n\t\tif (copy_timestamp)\n\t\t\tb->timestamp = ktime_get_ns();\n\t\tret = vb2_core_qbuf(q, index, NULL, NULL);\n\t\tdprintk(q, 5, \"vb2_dbuf result: %d\\n\", ret);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tbuf->pos = 0;\n\t\tbuf->queued = 1;\n\t\tbuf->size = vb2_plane_size(q->bufs[index], 0);\n\t\tfileio->q_count += 1;\n\t\t \n\t\tif (fileio->initial_index < q->num_buffers)\n\t\t\tfileio->initial_index++;\n\t\t \n\t\tfileio->cur_index = fileio->initial_index;\n\t}\n\n\t \n\tif (ret == 0)\n\t\tret = count;\n\treturn ret;\n}\n\nsize_t vb2_read(struct vb2_queue *q, char __user *data, size_t count,\n\t\tloff_t *ppos, int nonblocking)\n{\n\treturn __vb2_perform_fileio(q, data, count, ppos, nonblocking, 1);\n}\nEXPORT_SYMBOL_GPL(vb2_read);\n\nsize_t vb2_write(struct vb2_queue *q, const char __user *data, size_t count,\n\t\tloff_t *ppos, int nonblocking)\n{\n\treturn __vb2_perform_fileio(q, (char __user *) data, count,\n\t\t\t\t\t\t\tppos, nonblocking, 0);\n}\nEXPORT_SYMBOL_GPL(vb2_write);\n\nstruct vb2_threadio_data {\n\tstruct task_struct *thread;\n\tvb2_thread_fnc fnc;\n\tvoid *priv;\n\tbool stop;\n};\n\nstatic int vb2_thread(void *data)\n{\n\tstruct vb2_queue *q = data;\n\tstruct vb2_threadio_data *threadio = q->threadio;\n\tbool copy_timestamp = false;\n\tunsigned prequeue = 0;\n\tunsigned index = 0;\n\tint ret = 0;\n\n\tif (q->is_output) {\n\t\tprequeue = q->num_buffers;\n\t\tcopy_timestamp = q->copy_timestamp;\n\t}\n\n\tset_freezable();\n\n\tfor (;;) {\n\t\tstruct vb2_buffer *vb;\n\n\t\t \n\t\tif (prequeue) {\n\t\t\tvb = q->bufs[index++];\n\t\t\tprequeue--;\n\t\t} else {\n\t\t\tcall_void_qop(q, wait_finish, q);\n\t\t\tif (!threadio->stop)\n\t\t\t\tret = vb2_core_dqbuf(q, &index, NULL, 0);\n\t\t\tcall_void_qop(q, wait_prepare, q);\n\t\t\tdprintk(q, 5, \"file io: vb2_dqbuf result: %d\\n\", ret);\n\t\t\tif (!ret)\n\t\t\t\tvb = q->bufs[index];\n\t\t}\n\t\tif (ret || threadio->stop)\n\t\t\tbreak;\n\t\ttry_to_freeze();\n\n\t\tif (vb->state != VB2_BUF_STATE_ERROR)\n\t\t\tif (threadio->fnc(vb, threadio->priv))\n\t\t\t\tbreak;\n\t\tcall_void_qop(q, wait_finish, q);\n\t\tif (copy_timestamp)\n\t\t\tvb->timestamp = ktime_get_ns();\n\t\tif (!threadio->stop)\n\t\t\tret = vb2_core_qbuf(q, vb->index, NULL, NULL);\n\t\tcall_void_qop(q, wait_prepare, q);\n\t\tif (ret || threadio->stop)\n\t\t\tbreak;\n\t}\n\n\t \n\twhile (!kthread_should_stop()) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule();\n\t}\n\treturn 0;\n}\n\n \nint vb2_thread_start(struct vb2_queue *q, vb2_thread_fnc fnc, void *priv,\n\t\t     const char *thread_name)\n{\n\tstruct vb2_threadio_data *threadio;\n\tint ret = 0;\n\n\tif (q->threadio)\n\t\treturn -EBUSY;\n\tif (vb2_is_busy(q))\n\t\treturn -EBUSY;\n\tif (WARN_ON(q->fileio))\n\t\treturn -EBUSY;\n\n\tthreadio = kzalloc(sizeof(*threadio), GFP_KERNEL);\n\tif (threadio == NULL)\n\t\treturn -ENOMEM;\n\tthreadio->fnc = fnc;\n\tthreadio->priv = priv;\n\n\tret = __vb2_init_fileio(q, !q->is_output);\n\tdprintk(q, 3, \"file io: vb2_init_fileio result: %d\\n\", ret);\n\tif (ret)\n\t\tgoto nomem;\n\tq->threadio = threadio;\n\tthreadio->thread = kthread_run(vb2_thread, q, \"vb2-%s\", thread_name);\n\tif (IS_ERR(threadio->thread)) {\n\t\tret = PTR_ERR(threadio->thread);\n\t\tthreadio->thread = NULL;\n\t\tgoto nothread;\n\t}\n\treturn 0;\n\nnothread:\n\t__vb2_cleanup_fileio(q);\nnomem:\n\tkfree(threadio);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vb2_thread_start);\n\nint vb2_thread_stop(struct vb2_queue *q)\n{\n\tstruct vb2_threadio_data *threadio = q->threadio;\n\tint err;\n\n\tif (threadio == NULL)\n\t\treturn 0;\n\tthreadio->stop = true;\n\t \n\tvb2_queue_error(q);\n\terr = kthread_stop(threadio->thread);\n\t__vb2_cleanup_fileio(q);\n\tthreadio->thread = NULL;\n\tkfree(threadio);\n\tq->threadio = NULL;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vb2_thread_stop);\n\nMODULE_DESCRIPTION(\"Media buffer core framework\");\nMODULE_AUTHOR(\"Pawel Osciak <pawel@osciak.com>, Marek Szyprowski\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(DMA_BUF);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}