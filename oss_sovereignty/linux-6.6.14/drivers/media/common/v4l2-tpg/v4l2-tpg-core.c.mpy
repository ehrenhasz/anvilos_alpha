{
  "module_name": "v4l2-tpg-core.c",
  "hash_id": "b29a89129c1d5ebdd7efc394c8020bd8492768827a3161c945d30d4e44bc14c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/v4l2-tpg/v4l2-tpg-core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <media/tpg/v4l2-tpg.h>\n\n \nconst char * const tpg_pattern_strings[] = {\n\t\"75% Colorbar\",\n\t\"100% Colorbar\",\n\t\"CSC Colorbar\",\n\t\"Horizontal 100% Colorbar\",\n\t\"100% Color Squares\",\n\t\"100% Black\",\n\t\"100% White\",\n\t\"100% Red\",\n\t\"100% Green\",\n\t\"100% Blue\",\n\t\"16x16 Checkers\",\n\t\"2x2 Checkers\",\n\t\"1x1 Checkers\",\n\t\"2x2 Red/Green Checkers\",\n\t\"1x1 Red/Green Checkers\",\n\t\"Alternating Hor Lines\",\n\t\"Alternating Vert Lines\",\n\t\"One Pixel Wide Cross\",\n\t\"Two Pixels Wide Cross\",\n\t\"Ten Pixels Wide Cross\",\n\t\"Gray Ramp\",\n\t\"Noise\",\n\tNULL\n};\nEXPORT_SYMBOL_GPL(tpg_pattern_strings);\n\n \nconst char * const tpg_aspect_strings[] = {\n\t\"Source Width x Height\",\n\t\"4x3\",\n\t\"14x9\",\n\t\"16x9\",\n\t\"16x9 Anamorphic\",\n\tNULL\n};\nEXPORT_SYMBOL_GPL(tpg_aspect_strings);\n\n \nstatic const s8 sin[257] = {\n\t   0,   -4,   -7,  -11,  -13,  -18,  -20,  -22,  -26,  -29,  -33,  -35,  -37,  -41,  -43,  -48,\n\t -50,  -52,  -56,  -58,  -62,  -63,  -65,  -69,  -71,  -75,  -76,  -78,  -82,  -83,  -87,  -88,\n\t -90,  -93,  -94,  -97,  -99, -101, -103, -104, -107, -108, -110, -111, -112, -114, -115, -117,\n\t-118, -119, -120, -121, -122, -123, -123, -124, -125, -125, -126, -126, -127, -127, -127, -127,\n\t-127, -127, -127, -127, -126, -126, -125, -125, -124, -124, -123, -122, -121, -120, -119, -118,\n\t-117, -116, -114, -113, -111, -110, -109, -107, -105, -103, -101, -100,  -97,  -96,  -93,  -91,\n\t -90,  -87,  -85,  -82,  -80,  -76,  -75,  -73,  -69,  -67,  -63,  -62,  -60,  -56,  -54,  -50,\n\t -48,  -46,  -41,  -39,  -35,  -33,  -31,  -26,  -24,  -20,  -18,  -15,  -11,   -9,   -4,   -2,\n\t   0,    2,    4,    9,   11,   15,   18,   20,   24,   26,   31,   33,   35,   39,   41,   46,\n\t  48,   50,   54,   56,   60,   62,   64,   67,   69,   73,   75,   76,   80,   82,   85,   87,\n\t  90,   91,   93,   96,   97,  100,  101,  103,  105,  107,  109,  110,  111,  113,  114,  116,\n\t 117,  118,  119,  120,  121,  122,  123,  124,  124,  125,  125,  126,  126,  127,  127,  127,\n\t 127,  127,  127,  127,  127,  126,  126,  125,  125,  124,  123,  123,  122,  121,  120,  119,\n\t 118,  117,  115,  114,  112,  111,  110,  108,  107,  104,  103,  101,   99,   97,   94,   93,\n\t  90,   88,   87,   83,   82,   78,   76,   75,   71,   69,   65,   64,   62,   58,   56,   52,\n\t  50,   48,   43,   41,   37,   35,   33,   29,   26,   22,   20,   18,   13,   11,    7,    4,\n\t   0,\n};\n\n#define cos(idx) sin[((idx) + 64) % sizeof(sin)]\n\n \nstatic const u8 *font8x16;\n\nvoid tpg_set_font(const u8 *f)\n{\n\tfont8x16 = f;\n}\nEXPORT_SYMBOL_GPL(tpg_set_font);\n\nvoid tpg_init(struct tpg_data *tpg, unsigned w, unsigned h)\n{\n\tmemset(tpg, 0, sizeof(*tpg));\n\ttpg->scaled_width = tpg->src_width = w;\n\ttpg->src_height = tpg->buf_height = h;\n\ttpg->crop.width = tpg->compose.width = w;\n\ttpg->crop.height = tpg->compose.height = h;\n\ttpg->recalc_colors = true;\n\ttpg->recalc_square_border = true;\n\ttpg->brightness = 128;\n\ttpg->contrast = 128;\n\ttpg->saturation = 128;\n\ttpg->hue = 0;\n\ttpg->mv_hor_mode = TPG_MOVE_NONE;\n\ttpg->mv_vert_mode = TPG_MOVE_NONE;\n\ttpg->field = V4L2_FIELD_NONE;\n\ttpg_s_fourcc(tpg, V4L2_PIX_FMT_RGB24);\n\ttpg->colorspace = V4L2_COLORSPACE_SRGB;\n\ttpg->perc_fill = 100;\n\ttpg->hsv_enc = V4L2_HSV_ENC_180;\n}\nEXPORT_SYMBOL_GPL(tpg_init);\n\nint tpg_alloc(struct tpg_data *tpg, unsigned max_w)\n{\n\tunsigned pat;\n\tunsigned plane;\n\n\ttpg->max_line_width = max_w;\n\tfor (pat = 0; pat < TPG_MAX_PAT_LINES; pat++) {\n\t\tfor (plane = 0; plane < TPG_MAX_PLANES; plane++) {\n\t\t\tunsigned pixelsz = plane ? 2 : 4;\n\n\t\t\ttpg->lines[pat][plane] =\n\t\t\t\tvzalloc(array3_size(max_w, 2, pixelsz));\n\t\t\tif (!tpg->lines[pat][plane])\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (plane == 0)\n\t\t\t\tcontinue;\n\t\t\ttpg->downsampled_lines[pat][plane] =\n\t\t\t\tvzalloc(array3_size(max_w, 2, pixelsz));\n\t\t\tif (!tpg->downsampled_lines[pat][plane])\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tfor (plane = 0; plane < TPG_MAX_PLANES; plane++) {\n\t\tunsigned pixelsz = plane ? 2 : 4;\n\n\t\ttpg->contrast_line[plane] =\n\t\t\tvzalloc(array_size(pixelsz, max_w));\n\t\tif (!tpg->contrast_line[plane])\n\t\t\treturn -ENOMEM;\n\t\ttpg->black_line[plane] =\n\t\t\tvzalloc(array_size(pixelsz, max_w));\n\t\tif (!tpg->black_line[plane])\n\t\t\treturn -ENOMEM;\n\t\ttpg->random_line[plane] =\n\t\t\tvzalloc(array3_size(max_w, 2, pixelsz));\n\t\tif (!tpg->random_line[plane])\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tpg_alloc);\n\nvoid tpg_free(struct tpg_data *tpg)\n{\n\tunsigned pat;\n\tunsigned plane;\n\n\tfor (pat = 0; pat < TPG_MAX_PAT_LINES; pat++)\n\t\tfor (plane = 0; plane < TPG_MAX_PLANES; plane++) {\n\t\t\tvfree(tpg->lines[pat][plane]);\n\t\t\ttpg->lines[pat][plane] = NULL;\n\t\t\tif (plane == 0)\n\t\t\t\tcontinue;\n\t\t\tvfree(tpg->downsampled_lines[pat][plane]);\n\t\t\ttpg->downsampled_lines[pat][plane] = NULL;\n\t\t}\n\tfor (plane = 0; plane < TPG_MAX_PLANES; plane++) {\n\t\tvfree(tpg->contrast_line[plane]);\n\t\tvfree(tpg->black_line[plane]);\n\t\tvfree(tpg->random_line[plane]);\n\t\ttpg->contrast_line[plane] = NULL;\n\t\ttpg->black_line[plane] = NULL;\n\t\ttpg->random_line[plane] = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(tpg_free);\n\nbool tpg_s_fourcc(struct tpg_data *tpg, u32 fourcc)\n{\n\ttpg->fourcc = fourcc;\n\ttpg->planes = 1;\n\ttpg->buffers = 1;\n\ttpg->recalc_colors = true;\n\ttpg->interleaved = false;\n\ttpg->vdownsampling[0] = 1;\n\ttpg->hdownsampling[0] = 1;\n\ttpg->hmask[0] = ~0;\n\ttpg->hmask[1] = ~0;\n\ttpg->hmask[2] = ~0;\n\n\tswitch (fourcc) {\n\tcase V4L2_PIX_FMT_SBGGR8:\n\tcase V4L2_PIX_FMT_SGBRG8:\n\tcase V4L2_PIX_FMT_SGRBG8:\n\tcase V4L2_PIX_FMT_SRGGB8:\n\tcase V4L2_PIX_FMT_SBGGR10:\n\tcase V4L2_PIX_FMT_SGBRG10:\n\tcase V4L2_PIX_FMT_SGRBG10:\n\tcase V4L2_PIX_FMT_SRGGB10:\n\tcase V4L2_PIX_FMT_SBGGR12:\n\tcase V4L2_PIX_FMT_SGBRG12:\n\tcase V4L2_PIX_FMT_SGRBG12:\n\tcase V4L2_PIX_FMT_SRGGB12:\n\tcase V4L2_PIX_FMT_SBGGR16:\n\tcase V4L2_PIX_FMT_SGBRG16:\n\tcase V4L2_PIX_FMT_SGRBG16:\n\tcase V4L2_PIX_FMT_SRGGB16:\n\t\ttpg->interleaved = true;\n\t\ttpg->vdownsampling[1] = 1;\n\t\ttpg->hdownsampling[1] = 1;\n\t\ttpg->planes = 2;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_RGB332:\n\tcase V4L2_PIX_FMT_RGB565:\n\tcase V4L2_PIX_FMT_RGB565X:\n\tcase V4L2_PIX_FMT_RGB444:\n\tcase V4L2_PIX_FMT_XRGB444:\n\tcase V4L2_PIX_FMT_ARGB444:\n\tcase V4L2_PIX_FMT_RGBX444:\n\tcase V4L2_PIX_FMT_RGBA444:\n\tcase V4L2_PIX_FMT_XBGR444:\n\tcase V4L2_PIX_FMT_ABGR444:\n\tcase V4L2_PIX_FMT_BGRX444:\n\tcase V4L2_PIX_FMT_BGRA444:\n\tcase V4L2_PIX_FMT_RGB555:\n\tcase V4L2_PIX_FMT_XRGB555:\n\tcase V4L2_PIX_FMT_ARGB555:\n\tcase V4L2_PIX_FMT_RGBX555:\n\tcase V4L2_PIX_FMT_RGBA555:\n\tcase V4L2_PIX_FMT_XBGR555:\n\tcase V4L2_PIX_FMT_ABGR555:\n\tcase V4L2_PIX_FMT_BGRX555:\n\tcase V4L2_PIX_FMT_BGRA555:\n\tcase V4L2_PIX_FMT_RGB555X:\n\tcase V4L2_PIX_FMT_XRGB555X:\n\tcase V4L2_PIX_FMT_ARGB555X:\n\tcase V4L2_PIX_FMT_BGR666:\n\tcase V4L2_PIX_FMT_RGB24:\n\tcase V4L2_PIX_FMT_BGR24:\n\tcase V4L2_PIX_FMT_RGB32:\n\tcase V4L2_PIX_FMT_BGR32:\n\tcase V4L2_PIX_FMT_XRGB32:\n\tcase V4L2_PIX_FMT_XBGR32:\n\tcase V4L2_PIX_FMT_ARGB32:\n\tcase V4L2_PIX_FMT_ABGR32:\n\tcase V4L2_PIX_FMT_RGBX32:\n\tcase V4L2_PIX_FMT_BGRX32:\n\tcase V4L2_PIX_FMT_RGBA32:\n\tcase V4L2_PIX_FMT_BGRA32:\n\t\ttpg->color_enc = TGP_COLOR_ENC_RGB;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_GREY:\n\tcase V4L2_PIX_FMT_Y10:\n\tcase V4L2_PIX_FMT_Y12:\n\tcase V4L2_PIX_FMT_Y16:\n\tcase V4L2_PIX_FMT_Y16_BE:\n\tcase V4L2_PIX_FMT_Z16:\n\t\ttpg->color_enc = TGP_COLOR_ENC_LUMA;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV444:\n\tcase V4L2_PIX_FMT_YUV555:\n\tcase V4L2_PIX_FMT_YUV565:\n\tcase V4L2_PIX_FMT_YUV32:\n\tcase V4L2_PIX_FMT_AYUV32:\n\tcase V4L2_PIX_FMT_XYUV32:\n\tcase V4L2_PIX_FMT_VUYA32:\n\tcase V4L2_PIX_FMT_VUYX32:\n\tcase V4L2_PIX_FMT_YUVA32:\n\tcase V4L2_PIX_FMT_YUVX32:\n\t\ttpg->color_enc = TGP_COLOR_ENC_YCBCR;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV420M:\n\tcase V4L2_PIX_FMT_YVU420M:\n\t\ttpg->buffers = 3;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_YVU420:\n\t\ttpg->vdownsampling[1] = 2;\n\t\ttpg->vdownsampling[2] = 2;\n\t\ttpg->hdownsampling[1] = 2;\n\t\ttpg->hdownsampling[2] = 2;\n\t\ttpg->planes = 3;\n\t\ttpg->color_enc = TGP_COLOR_ENC_YCBCR;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV422M:\n\tcase V4L2_PIX_FMT_YVU422M:\n\t\ttpg->buffers = 3;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_YUV422P:\n\t\ttpg->vdownsampling[1] = 1;\n\t\ttpg->vdownsampling[2] = 1;\n\t\ttpg->hdownsampling[1] = 2;\n\t\ttpg->hdownsampling[2] = 2;\n\t\ttpg->planes = 3;\n\t\ttpg->color_enc = TGP_COLOR_ENC_YCBCR;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV16M:\n\tcase V4L2_PIX_FMT_NV61M:\n\t\ttpg->buffers = 2;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_NV16:\n\tcase V4L2_PIX_FMT_NV61:\n\t\ttpg->vdownsampling[1] = 1;\n\t\ttpg->hdownsampling[1] = 1;\n\t\ttpg->hmask[1] = ~1;\n\t\ttpg->planes = 2;\n\t\ttpg->color_enc = TGP_COLOR_ENC_YCBCR;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV12M:\n\tcase V4L2_PIX_FMT_NV21M:\n\t\ttpg->buffers = 2;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\t\ttpg->vdownsampling[1] = 2;\n\t\ttpg->hdownsampling[1] = 1;\n\t\ttpg->hmask[1] = ~1;\n\t\ttpg->planes = 2;\n\t\ttpg->color_enc = TGP_COLOR_ENC_YCBCR;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV444M:\n\tcase V4L2_PIX_FMT_YVU444M:\n\t\ttpg->buffers = 3;\n\t\ttpg->planes = 3;\n\t\ttpg->vdownsampling[1] = 1;\n\t\ttpg->vdownsampling[2] = 1;\n\t\ttpg->hdownsampling[1] = 1;\n\t\ttpg->hdownsampling[2] = 1;\n\t\ttpg->color_enc = TGP_COLOR_ENC_YCBCR;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV24:\n\tcase V4L2_PIX_FMT_NV42:\n\t\ttpg->vdownsampling[1] = 1;\n\t\ttpg->hdownsampling[1] = 1;\n\t\ttpg->planes = 2;\n\t\ttpg->color_enc = TGP_COLOR_ENC_YCBCR;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_UYVY:\n\tcase V4L2_PIX_FMT_YVYU:\n\tcase V4L2_PIX_FMT_VYUY:\n\t\ttpg->hmask[0] = ~1;\n\t\ttpg->color_enc = TGP_COLOR_ENC_YCBCR;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_HSV24:\n\tcase V4L2_PIX_FMT_HSV32:\n\t\ttpg->color_enc = TGP_COLOR_ENC_HSV;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tswitch (fourcc) {\n\tcase V4L2_PIX_FMT_GREY:\n\tcase V4L2_PIX_FMT_RGB332:\n\t\ttpg->twopixelsize[0] = 2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB565:\n\tcase V4L2_PIX_FMT_RGB565X:\n\tcase V4L2_PIX_FMT_RGB444:\n\tcase V4L2_PIX_FMT_XRGB444:\n\tcase V4L2_PIX_FMT_ARGB444:\n\tcase V4L2_PIX_FMT_RGBX444:\n\tcase V4L2_PIX_FMT_RGBA444:\n\tcase V4L2_PIX_FMT_XBGR444:\n\tcase V4L2_PIX_FMT_ABGR444:\n\tcase V4L2_PIX_FMT_BGRX444:\n\tcase V4L2_PIX_FMT_BGRA444:\n\tcase V4L2_PIX_FMT_RGB555:\n\tcase V4L2_PIX_FMT_XRGB555:\n\tcase V4L2_PIX_FMT_ARGB555:\n\tcase V4L2_PIX_FMT_RGBX555:\n\tcase V4L2_PIX_FMT_RGBA555:\n\tcase V4L2_PIX_FMT_XBGR555:\n\tcase V4L2_PIX_FMT_ABGR555:\n\tcase V4L2_PIX_FMT_BGRX555:\n\tcase V4L2_PIX_FMT_BGRA555:\n\tcase V4L2_PIX_FMT_RGB555X:\n\tcase V4L2_PIX_FMT_XRGB555X:\n\tcase V4L2_PIX_FMT_ARGB555X:\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_UYVY:\n\tcase V4L2_PIX_FMT_YVYU:\n\tcase V4L2_PIX_FMT_VYUY:\n\tcase V4L2_PIX_FMT_YUV444:\n\tcase V4L2_PIX_FMT_YUV555:\n\tcase V4L2_PIX_FMT_YUV565:\n\tcase V4L2_PIX_FMT_Y10:\n\tcase V4L2_PIX_FMT_Y12:\n\tcase V4L2_PIX_FMT_Y16:\n\tcase V4L2_PIX_FMT_Y16_BE:\n\tcase V4L2_PIX_FMT_Z16:\n\t\ttpg->twopixelsize[0] = 2 * 2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB24:\n\tcase V4L2_PIX_FMT_BGR24:\n\tcase V4L2_PIX_FMT_HSV24:\n\t\ttpg->twopixelsize[0] = 2 * 3;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR666:\n\tcase V4L2_PIX_FMT_RGB32:\n\tcase V4L2_PIX_FMT_BGR32:\n\tcase V4L2_PIX_FMT_XRGB32:\n\tcase V4L2_PIX_FMT_XBGR32:\n\tcase V4L2_PIX_FMT_ARGB32:\n\tcase V4L2_PIX_FMT_ABGR32:\n\tcase V4L2_PIX_FMT_RGBX32:\n\tcase V4L2_PIX_FMT_BGRX32:\n\tcase V4L2_PIX_FMT_RGBA32:\n\tcase V4L2_PIX_FMT_BGRA32:\n\tcase V4L2_PIX_FMT_YUV32:\n\tcase V4L2_PIX_FMT_AYUV32:\n\tcase V4L2_PIX_FMT_XYUV32:\n\tcase V4L2_PIX_FMT_VUYA32:\n\tcase V4L2_PIX_FMT_VUYX32:\n\tcase V4L2_PIX_FMT_YUVA32:\n\tcase V4L2_PIX_FMT_YUVX32:\n\tcase V4L2_PIX_FMT_HSV32:\n\t\ttpg->twopixelsize[0] = 2 * 4;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\tcase V4L2_PIX_FMT_NV12M:\n\tcase V4L2_PIX_FMT_NV21M:\n\tcase V4L2_PIX_FMT_NV16:\n\tcase V4L2_PIX_FMT_NV61:\n\tcase V4L2_PIX_FMT_NV16M:\n\tcase V4L2_PIX_FMT_NV61M:\n\tcase V4L2_PIX_FMT_SBGGR8:\n\tcase V4L2_PIX_FMT_SGBRG8:\n\tcase V4L2_PIX_FMT_SGRBG8:\n\tcase V4L2_PIX_FMT_SRGGB8:\n\t\ttpg->twopixelsize[0] = 2;\n\t\ttpg->twopixelsize[1] = 2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SRGGB10:\n\tcase V4L2_PIX_FMT_SGRBG10:\n\tcase V4L2_PIX_FMT_SGBRG10:\n\tcase V4L2_PIX_FMT_SBGGR10:\n\tcase V4L2_PIX_FMT_SRGGB12:\n\tcase V4L2_PIX_FMT_SGRBG12:\n\tcase V4L2_PIX_FMT_SGBRG12:\n\tcase V4L2_PIX_FMT_SBGGR12:\n\tcase V4L2_PIX_FMT_SRGGB16:\n\tcase V4L2_PIX_FMT_SGRBG16:\n\tcase V4L2_PIX_FMT_SGBRG16:\n\tcase V4L2_PIX_FMT_SBGGR16:\n\t\ttpg->twopixelsize[0] = 4;\n\t\ttpg->twopixelsize[1] = 4;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV444M:\n\tcase V4L2_PIX_FMT_YVU444M:\n\tcase V4L2_PIX_FMT_YUV422M:\n\tcase V4L2_PIX_FMT_YVU422M:\n\tcase V4L2_PIX_FMT_YUV422P:\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_YVU420:\n\tcase V4L2_PIX_FMT_YUV420M:\n\tcase V4L2_PIX_FMT_YVU420M:\n\t\ttpg->twopixelsize[0] = 2;\n\t\ttpg->twopixelsize[1] = 2;\n\t\ttpg->twopixelsize[2] = 2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV24:\n\tcase V4L2_PIX_FMT_NV42:\n\t\ttpg->twopixelsize[0] = 2;\n\t\ttpg->twopixelsize[1] = 4;\n\t\tbreak;\n\t}\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(tpg_s_fourcc);\n\nvoid tpg_s_crop_compose(struct tpg_data *tpg, const struct v4l2_rect *crop,\n\t\tconst struct v4l2_rect *compose)\n{\n\ttpg->crop = *crop;\n\ttpg->compose = *compose;\n\ttpg->scaled_width = (tpg->src_width * tpg->compose.width +\n\t\t\t\t tpg->crop.width - 1) / tpg->crop.width;\n\ttpg->scaled_width &= ~1;\n\tif (tpg->scaled_width > tpg->max_line_width)\n\t\ttpg->scaled_width = tpg->max_line_width;\n\tif (tpg->scaled_width < 2)\n\t\ttpg->scaled_width = 2;\n\ttpg->recalc_lines = true;\n}\nEXPORT_SYMBOL_GPL(tpg_s_crop_compose);\n\nvoid tpg_reset_source(struct tpg_data *tpg, unsigned width, unsigned height,\n\t\t       u32 field)\n{\n\tunsigned p;\n\n\ttpg->src_width = width;\n\ttpg->src_height = height;\n\ttpg->field = field;\n\ttpg->buf_height = height;\n\tif (V4L2_FIELD_HAS_T_OR_B(field))\n\t\ttpg->buf_height /= 2;\n\ttpg->scaled_width = width;\n\ttpg->crop.top = tpg->crop.left = 0;\n\ttpg->crop.width = width;\n\ttpg->crop.height = height;\n\ttpg->compose.top = tpg->compose.left = 0;\n\ttpg->compose.width = width;\n\ttpg->compose.height = tpg->buf_height;\n\tfor (p = 0; p < tpg->planes; p++)\n\t\ttpg->bytesperline[p] = (width * tpg->twopixelsize[p]) /\n\t\t\t\t       (2 * tpg->hdownsampling[p]);\n\ttpg->recalc_square_border = true;\n}\nEXPORT_SYMBOL_GPL(tpg_reset_source);\n\nstatic enum tpg_color tpg_get_textbg_color(struct tpg_data *tpg)\n{\n\tswitch (tpg->pattern) {\n\tcase TPG_PAT_BLACK:\n\t\treturn TPG_COLOR_100_WHITE;\n\tcase TPG_PAT_CSC_COLORBAR:\n\t\treturn TPG_COLOR_CSC_BLACK;\n\tdefault:\n\t\treturn TPG_COLOR_100_BLACK;\n\t}\n}\n\nstatic enum tpg_color tpg_get_textfg_color(struct tpg_data *tpg)\n{\n\tswitch (tpg->pattern) {\n\tcase TPG_PAT_75_COLORBAR:\n\tcase TPG_PAT_CSC_COLORBAR:\n\t\treturn TPG_COLOR_CSC_WHITE;\n\tcase TPG_PAT_BLACK:\n\t\treturn TPG_COLOR_100_BLACK;\n\tdefault:\n\t\treturn TPG_COLOR_100_WHITE;\n\t}\n}\n\nstatic inline int rec709_to_linear(int v)\n{\n\tv = clamp(v, 0, 0xff0);\n\treturn tpg_rec709_to_linear[v];\n}\n\nstatic inline int linear_to_rec709(int v)\n{\n\tv = clamp(v, 0, 0xff0);\n\treturn tpg_linear_to_rec709[v];\n}\n\nstatic void color_to_hsv(struct tpg_data *tpg, int r, int g, int b,\n\t\t\t   int *h, int *s, int *v)\n{\n\tint max_rgb, min_rgb, diff_rgb;\n\tint aux;\n\tint third;\n\tint third_size;\n\n\tr >>= 4;\n\tg >>= 4;\n\tb >>= 4;\n\n\t \n\tmax_rgb = max3(r, g, b);\n\t*v = max_rgb;\n\tif (!max_rgb) {\n\t\t*h = 0;\n\t\t*s = 0;\n\t\treturn;\n\t}\n\n\t \n\tmin_rgb = min3(r, g, b);\n\tdiff_rgb = max_rgb - min_rgb;\n\taux = 255 * diff_rgb;\n\taux += max_rgb / 2;\n\taux /= max_rgb;\n\t*s = aux;\n\tif (!aux) {\n\t\t*h = 0;\n\t\treturn;\n\t}\n\n\tthird_size = (tpg->real_hsv_enc == V4L2_HSV_ENC_180) ? 60 : 85;\n\n\t \n\tif (max_rgb == r) {\n\t\taux =  g - b;\n\t\tthird = 0;\n\t} else if (max_rgb == g) {\n\t\taux =  b - r;\n\t\tthird = third_size;\n\t} else {\n\t\taux =  r - g;\n\t\tthird = third_size * 2;\n\t}\n\n\taux *= third_size / 2;\n\taux += diff_rgb / 2;\n\taux /= diff_rgb;\n\taux += third;\n\n\t \n\tif (tpg->real_hsv_enc == V4L2_HSV_ENC_180) {\n\t\tif (aux < 0)\n\t\t\taux += 180;\n\t\telse if (aux > 180)\n\t\t\taux -= 180;\n\t} else {\n\t\taux = aux & 0xff;\n\t}\n\n\t*h = aux;\n}\n\nstatic void rgb2ycbcr(const int m[3][3], int r, int g, int b,\n\t\t\tint y_offset, int *y, int *cb, int *cr)\n{\n\t*y  = ((m[0][0] * r + m[0][1] * g + m[0][2] * b) >> 16) + (y_offset << 4);\n\t*cb = ((m[1][0] * r + m[1][1] * g + m[1][2] * b) >> 16) + (128 << 4);\n\t*cr = ((m[2][0] * r + m[2][1] * g + m[2][2] * b) >> 16) + (128 << 4);\n}\n\nstatic void color_to_ycbcr(struct tpg_data *tpg, int r, int g, int b,\n\t\t\t   int *y, int *cb, int *cr)\n{\n#define COEFF(v, r) ((int)(0.5 + (v) * (r) * 256.0))\n\n\tstatic const int bt601[3][3] = {\n\t\t{ COEFF(0.299, 219),   COEFF(0.587, 219),   COEFF(0.114, 219)   },\n\t\t{ COEFF(-0.1687, 224), COEFF(-0.3313, 224), COEFF(0.5, 224)     },\n\t\t{ COEFF(0.5, 224),     COEFF(-0.4187, 224), COEFF(-0.0813, 224) },\n\t};\n\tstatic const int bt601_full[3][3] = {\n\t\t{ COEFF(0.299, 255),   COEFF(0.587, 255),   COEFF(0.114, 255)   },\n\t\t{ COEFF(-0.1687, 255), COEFF(-0.3313, 255), COEFF(0.5, 255)     },\n\t\t{ COEFF(0.5, 255),     COEFF(-0.4187, 255), COEFF(-0.0813, 255) },\n\t};\n\tstatic const int rec709[3][3] = {\n\t\t{ COEFF(0.2126, 219),  COEFF(0.7152, 219),  COEFF(0.0722, 219)  },\n\t\t{ COEFF(-0.1146, 224), COEFF(-0.3854, 224), COEFF(0.5, 224)     },\n\t\t{ COEFF(0.5, 224),     COEFF(-0.4542, 224), COEFF(-0.0458, 224) },\n\t};\n\tstatic const int rec709_full[3][3] = {\n\t\t{ COEFF(0.2126, 255),  COEFF(0.7152, 255),  COEFF(0.0722, 255)  },\n\t\t{ COEFF(-0.1146, 255), COEFF(-0.3854, 255), COEFF(0.5, 255)     },\n\t\t{ COEFF(0.5, 255),     COEFF(-0.4542, 255), COEFF(-0.0458, 255) },\n\t};\n\tstatic const int smpte240m[3][3] = {\n\t\t{ COEFF(0.212, 219),  COEFF(0.701, 219),  COEFF(0.087, 219)  },\n\t\t{ COEFF(-0.116, 224), COEFF(-0.384, 224), COEFF(0.5, 224)    },\n\t\t{ COEFF(0.5, 224),    COEFF(-0.445, 224), COEFF(-0.055, 224) },\n\t};\n\tstatic const int smpte240m_full[3][3] = {\n\t\t{ COEFF(0.212, 255),  COEFF(0.701, 255),  COEFF(0.087, 255)  },\n\t\t{ COEFF(-0.116, 255), COEFF(-0.384, 255), COEFF(0.5, 255)    },\n\t\t{ COEFF(0.5, 255),    COEFF(-0.445, 255), COEFF(-0.055, 255) },\n\t};\n\tstatic const int bt2020[3][3] = {\n\t\t{ COEFF(0.2627, 219),  COEFF(0.6780, 219),  COEFF(0.0593, 219)  },\n\t\t{ COEFF(-0.1396, 224), COEFF(-0.3604, 224), COEFF(0.5, 224)     },\n\t\t{ COEFF(0.5, 224),     COEFF(-0.4598, 224), COEFF(-0.0402, 224) },\n\t};\n\tstatic const int bt2020_full[3][3] = {\n\t\t{ COEFF(0.2627, 255),  COEFF(0.6780, 255),  COEFF(0.0593, 255)  },\n\t\t{ COEFF(-0.1396, 255), COEFF(-0.3604, 255), COEFF(0.5, 255)     },\n\t\t{ COEFF(0.5, 255),     COEFF(-0.4598, 255), COEFF(-0.0402, 255) },\n\t};\n\tstatic const int bt2020c[4] = {\n\t\tCOEFF(1.0 / 1.9404, 224), COEFF(1.0 / 1.5816, 224),\n\t\tCOEFF(1.0 / 1.7184, 224), COEFF(1.0 / 0.9936, 224),\n\t};\n\tstatic const int bt2020c_full[4] = {\n\t\tCOEFF(1.0 / 1.9404, 255), COEFF(1.0 / 1.5816, 255),\n\t\tCOEFF(1.0 / 1.7184, 255), COEFF(1.0 / 0.9936, 255),\n\t};\n\n\tbool full = tpg->real_quantization == V4L2_QUANTIZATION_FULL_RANGE;\n\tunsigned y_offset = full ? 0 : 16;\n\tint lin_y, yc;\n\n\tswitch (tpg->real_ycbcr_enc) {\n\tcase V4L2_YCBCR_ENC_601:\n\t\trgb2ycbcr(full ? bt601_full : bt601, r, g, b, y_offset, y, cb, cr);\n\t\tbreak;\n\tcase V4L2_YCBCR_ENC_XV601:\n\t\t \n\t\trgb2ycbcr(bt601, r, g, b, 16, y, cb, cr);\n\t\tbreak;\n\tcase V4L2_YCBCR_ENC_XV709:\n\t\t \n\t\trgb2ycbcr(rec709, r, g, b, 16, y, cb, cr);\n\t\tbreak;\n\tcase V4L2_YCBCR_ENC_BT2020:\n\t\trgb2ycbcr(full ? bt2020_full : bt2020, r, g, b, y_offset, y, cb, cr);\n\t\tbreak;\n\tcase V4L2_YCBCR_ENC_BT2020_CONST_LUM:\n\t\tlin_y = (COEFF(0.2627, 255) * rec709_to_linear(r) +\n\t\t\t COEFF(0.6780, 255) * rec709_to_linear(g) +\n\t\t\t COEFF(0.0593, 255) * rec709_to_linear(b)) >> 16;\n\t\tyc = linear_to_rec709(lin_y);\n\t\t*y = full ? yc : (yc * 219) / 255 + (16 << 4);\n\t\tif (b <= yc)\n\t\t\t*cb = (((b - yc) * (full ? bt2020c_full[0] : bt2020c[0])) >> 16) + (128 << 4);\n\t\telse\n\t\t\t*cb = (((b - yc) * (full ? bt2020c_full[1] : bt2020c[1])) >> 16) + (128 << 4);\n\t\tif (r <= yc)\n\t\t\t*cr = (((r - yc) * (full ? bt2020c_full[2] : bt2020c[2])) >> 16) + (128 << 4);\n\t\telse\n\t\t\t*cr = (((r - yc) * (full ? bt2020c_full[3] : bt2020c[3])) >> 16) + (128 << 4);\n\t\tbreak;\n\tcase V4L2_YCBCR_ENC_SMPTE240M:\n\t\trgb2ycbcr(full ? smpte240m_full : smpte240m, r, g, b, y_offset, y, cb, cr);\n\t\tbreak;\n\tcase V4L2_YCBCR_ENC_709:\n\tdefault:\n\t\trgb2ycbcr(full ? rec709_full : rec709, r, g, b, y_offset, y, cb, cr);\n\t\tbreak;\n\t}\n}\n\nstatic void ycbcr2rgb(const int m[3][3], int y, int cb, int cr,\n\t\t\tint y_offset, int *r, int *g, int *b)\n{\n\ty -= y_offset << 4;\n\tcb -= 128 << 4;\n\tcr -= 128 << 4;\n\t*r = m[0][0] * y + m[0][1] * cb + m[0][2] * cr;\n\t*g = m[1][0] * y + m[1][1] * cb + m[1][2] * cr;\n\t*b = m[2][0] * y + m[2][1] * cb + m[2][2] * cr;\n\t*r = clamp(*r >> 12, 0, 0xff0);\n\t*g = clamp(*g >> 12, 0, 0xff0);\n\t*b = clamp(*b >> 12, 0, 0xff0);\n}\n\nstatic void ycbcr_to_color(struct tpg_data *tpg, int y, int cb, int cr,\n\t\t\t   int *r, int *g, int *b)\n{\n#undef COEFF\n#define COEFF(v, r) ((int)(0.5 + (v) * ((255.0 * 255.0 * 16.0) / (r))))\n\tstatic const int bt601[3][3] = {\n\t\t{ COEFF(1, 219), COEFF(0, 224),       COEFF(1.4020, 224)  },\n\t\t{ COEFF(1, 219), COEFF(-0.3441, 224), COEFF(-0.7141, 224) },\n\t\t{ COEFF(1, 219), COEFF(1.7720, 224),  COEFF(0, 224)       },\n\t};\n\tstatic const int bt601_full[3][3] = {\n\t\t{ COEFF(1, 255), COEFF(0, 255),       COEFF(1.4020, 255)  },\n\t\t{ COEFF(1, 255), COEFF(-0.3441, 255), COEFF(-0.7141, 255) },\n\t\t{ COEFF(1, 255), COEFF(1.7720, 255),  COEFF(0, 255)       },\n\t};\n\tstatic const int rec709[3][3] = {\n\t\t{ COEFF(1, 219), COEFF(0, 224),       COEFF(1.5748, 224)  },\n\t\t{ COEFF(1, 219), COEFF(-0.1873, 224), COEFF(-0.4681, 224) },\n\t\t{ COEFF(1, 219), COEFF(1.8556, 224),  COEFF(0, 224)       },\n\t};\n\tstatic const int rec709_full[3][3] = {\n\t\t{ COEFF(1, 255), COEFF(0, 255),       COEFF(1.5748, 255)  },\n\t\t{ COEFF(1, 255), COEFF(-0.1873, 255), COEFF(-0.4681, 255) },\n\t\t{ COEFF(1, 255), COEFF(1.8556, 255),  COEFF(0, 255)       },\n\t};\n\tstatic const int smpte240m[3][3] = {\n\t\t{ COEFF(1, 219), COEFF(0, 224),       COEFF(1.5756, 224)  },\n\t\t{ COEFF(1, 219), COEFF(-0.2253, 224), COEFF(-0.4767, 224) },\n\t\t{ COEFF(1, 219), COEFF(1.8270, 224),  COEFF(0, 224)       },\n\t};\n\tstatic const int smpte240m_full[3][3] = {\n\t\t{ COEFF(1, 255), COEFF(0, 255),       COEFF(1.5756, 255)  },\n\t\t{ COEFF(1, 255), COEFF(-0.2253, 255), COEFF(-0.4767, 255) },\n\t\t{ COEFF(1, 255), COEFF(1.8270, 255),  COEFF(0, 255)       },\n\t};\n\tstatic const int bt2020[3][3] = {\n\t\t{ COEFF(1, 219), COEFF(0, 224),       COEFF(1.4746, 224)  },\n\t\t{ COEFF(1, 219), COEFF(-0.1646, 224), COEFF(-0.5714, 224) },\n\t\t{ COEFF(1, 219), COEFF(1.8814, 224),  COEFF(0, 224)       },\n\t};\n\tstatic const int bt2020_full[3][3] = {\n\t\t{ COEFF(1, 255), COEFF(0, 255),       COEFF(1.4746, 255)  },\n\t\t{ COEFF(1, 255), COEFF(-0.1646, 255), COEFF(-0.5714, 255) },\n\t\t{ COEFF(1, 255), COEFF(1.8814, 255),  COEFF(0, 255)       },\n\t};\n\tstatic const int bt2020c[4] = {\n\t\tCOEFF(1.9404, 224), COEFF(1.5816, 224),\n\t\tCOEFF(1.7184, 224), COEFF(0.9936, 224),\n\t};\n\tstatic const int bt2020c_full[4] = {\n\t\tCOEFF(1.9404, 255), COEFF(1.5816, 255),\n\t\tCOEFF(1.7184, 255), COEFF(0.9936, 255),\n\t};\n\n\tbool full = tpg->real_quantization == V4L2_QUANTIZATION_FULL_RANGE;\n\tunsigned y_offset = full ? 0 : 16;\n\tint y_fac = full ? COEFF(1.0, 255) : COEFF(1.0, 219);\n\tint lin_r, lin_g, lin_b, lin_y;\n\n\tswitch (tpg->real_ycbcr_enc) {\n\tcase V4L2_YCBCR_ENC_601:\n\t\tycbcr2rgb(full ? bt601_full : bt601, y, cb, cr, y_offset, r, g, b);\n\t\tbreak;\n\tcase V4L2_YCBCR_ENC_XV601:\n\t\t \n\t\tycbcr2rgb(bt601, y, cb, cr, 16, r, g, b);\n\t\tbreak;\n\tcase V4L2_YCBCR_ENC_XV709:\n\t\t \n\t\tycbcr2rgb(rec709, y, cb, cr, 16, r, g, b);\n\t\tbreak;\n\tcase V4L2_YCBCR_ENC_BT2020:\n\t\tycbcr2rgb(full ? bt2020_full : bt2020, y, cb, cr, y_offset, r, g, b);\n\t\tbreak;\n\tcase V4L2_YCBCR_ENC_BT2020_CONST_LUM:\n\t\ty -= full ? 0 : 16 << 4;\n\t\tcb -= 128 << 4;\n\t\tcr -= 128 << 4;\n\n\t\tif (cb <= 0)\n\t\t\t*b = y_fac * y + (full ? bt2020c_full[0] : bt2020c[0]) * cb;\n\t\telse\n\t\t\t*b = y_fac * y + (full ? bt2020c_full[1] : bt2020c[1]) * cb;\n\t\t*b = *b >> 12;\n\t\tif (cr <= 0)\n\t\t\t*r = y_fac * y + (full ? bt2020c_full[2] : bt2020c[2]) * cr;\n\t\telse\n\t\t\t*r = y_fac * y + (full ? bt2020c_full[3] : bt2020c[3]) * cr;\n\t\t*r = *r >> 12;\n\t\tlin_r = rec709_to_linear(*r);\n\t\tlin_b = rec709_to_linear(*b);\n\t\tlin_y = rec709_to_linear((y * 255) / (full ? 255 : 219));\n\n\t\tlin_g = COEFF(1.0 / 0.6780, 255) * lin_y -\n\t\t\tCOEFF(0.2627 / 0.6780, 255) * lin_r -\n\t\t\tCOEFF(0.0593 / 0.6780, 255) * lin_b;\n\t\t*g = linear_to_rec709(lin_g >> 12);\n\t\tbreak;\n\tcase V4L2_YCBCR_ENC_SMPTE240M:\n\t\tycbcr2rgb(full ? smpte240m_full : smpte240m, y, cb, cr, y_offset, r, g, b);\n\t\tbreak;\n\tcase V4L2_YCBCR_ENC_709:\n\tdefault:\n\t\tycbcr2rgb(full ? rec709_full : rec709, y, cb, cr, y_offset, r, g, b);\n\t\tbreak;\n\t}\n}\n\n \nstatic void precalculate_color(struct tpg_data *tpg, int k)\n{\n\tint col = k;\n\tint r = tpg_colors[col].r;\n\tint g = tpg_colors[col].g;\n\tint b = tpg_colors[col].b;\n\tint y, cb, cr;\n\tbool ycbcr_valid = false;\n\n\tif (k == TPG_COLOR_TEXTBG) {\n\t\tcol = tpg_get_textbg_color(tpg);\n\n\t\tr = tpg_colors[col].r;\n\t\tg = tpg_colors[col].g;\n\t\tb = tpg_colors[col].b;\n\t} else if (k == TPG_COLOR_TEXTFG) {\n\t\tcol = tpg_get_textfg_color(tpg);\n\n\t\tr = tpg_colors[col].r;\n\t\tg = tpg_colors[col].g;\n\t\tb = tpg_colors[col].b;\n\t} else if (tpg->pattern == TPG_PAT_NOISE) {\n\t\tr = g = b = get_random_u8();\n\t} else if (k == TPG_COLOR_RANDOM) {\n\t\tr = g = b = tpg->qual_offset + get_random_u32_below(196);\n\t} else if (k >= TPG_COLOR_RAMP) {\n\t\tr = g = b = k - TPG_COLOR_RAMP;\n\t}\n\n\tif (tpg->pattern == TPG_PAT_CSC_COLORBAR && col <= TPG_COLOR_CSC_BLACK) {\n\t\tr = tpg_csc_colors[tpg->colorspace][tpg->real_xfer_func][col].r;\n\t\tg = tpg_csc_colors[tpg->colorspace][tpg->real_xfer_func][col].g;\n\t\tb = tpg_csc_colors[tpg->colorspace][tpg->real_xfer_func][col].b;\n\t} else {\n\t\tr <<= 4;\n\t\tg <<= 4;\n\t\tb <<= 4;\n\t}\n\n\tif (tpg->qual == TPG_QUAL_GRAY ||\n\t    tpg->color_enc ==  TGP_COLOR_ENC_LUMA) {\n\t\t \n\t\t \n\t\tr = g = b = (13879 * r + 46688 * g + 4713 * b) >> 16;\n\t}\n\n\t \n\tif (tpg->real_rgb_range == V4L2_DV_RGB_RANGE_LIMITED &&\n\t    tpg->rgb_range == V4L2_DV_RGB_RANGE_FULL &&\n\t    tpg->color_enc == TGP_COLOR_ENC_RGB) {\n\t\t \n\t\tr = (r * 219) / 255 + (16 << 4);\n\t\tg = (g * 219) / 255 + (16 << 4);\n\t\tb = (b * 219) / 255 + (16 << 4);\n\t} else if (tpg->real_rgb_range != V4L2_DV_RGB_RANGE_LIMITED &&\n\t\t   tpg->rgb_range == V4L2_DV_RGB_RANGE_LIMITED &&\n\t\t   tpg->color_enc == TGP_COLOR_ENC_RGB) {\n\n\t\t \n\t\tr = clamp(r, 16 << 4, 235 << 4);\n\t\tg = clamp(g, 16 << 4, 235 << 4);\n\t\tb = clamp(b, 16 << 4, 235 << 4);\n\t\tr = (r - (16 << 4)) * 255 / 219;\n\t\tg = (g - (16 << 4)) * 255 / 219;\n\t\tb = (b - (16 << 4)) * 255 / 219;\n\t}\n\n\tif ((tpg->brightness != 128 || tpg->contrast != 128 ||\n\t     tpg->saturation != 128 || tpg->hue) &&\n\t    tpg->color_enc != TGP_COLOR_ENC_LUMA) {\n\t\t \n\t\tint tmp_cb, tmp_cr;\n\n\t\t \n\n\t\tcolor_to_ycbcr(tpg, r, g, b, &y, &cb, &cr);\n\n\t\ty = (16 << 4) + ((y - (16 << 4)) * tpg->contrast) / 128;\n\t\ty += (tpg->brightness << 4) - (128 << 4);\n\n\t\tcb -= 128 << 4;\n\t\tcr -= 128 << 4;\n\t\ttmp_cb = (cb * cos(128 + tpg->hue)) / 127 + (cr * sin[128 + tpg->hue]) / 127;\n\t\ttmp_cr = (cr * cos(128 + tpg->hue)) / 127 - (cb * sin[128 + tpg->hue]) / 127;\n\n\t\tcb = (128 << 4) + (tmp_cb * tpg->contrast * tpg->saturation) / (128 * 128);\n\t\tcr = (128 << 4) + (tmp_cr * tpg->contrast * tpg->saturation) / (128 * 128);\n\t\tif (tpg->color_enc == TGP_COLOR_ENC_YCBCR)\n\t\t\tycbcr_valid = true;\n\t\telse\n\t\t\tycbcr_to_color(tpg, y, cb, cr, &r, &g, &b);\n\t} else if ((tpg->brightness != 128 || tpg->contrast != 128) &&\n\t\t   tpg->color_enc == TGP_COLOR_ENC_LUMA) {\n\t\tr = (16 << 4) + ((r - (16 << 4)) * tpg->contrast) / 128;\n\t\tr += (tpg->brightness << 4) - (128 << 4);\n\t}\n\n\tswitch (tpg->color_enc) {\n\tcase TGP_COLOR_ENC_HSV:\n\t{\n\t\tint h, s, v;\n\n\t\tcolor_to_hsv(tpg, r, g, b, &h, &s, &v);\n\t\ttpg->colors[k][0] = h;\n\t\ttpg->colors[k][1] = s;\n\t\ttpg->colors[k][2] = v;\n\t\tbreak;\n\t}\n\tcase TGP_COLOR_ENC_YCBCR:\n\t{\n\t\t \n\t\tif (!ycbcr_valid)\n\t\t\tcolor_to_ycbcr(tpg, r, g, b, &y, &cb, &cr);\n\n\t\ty >>= 4;\n\t\tcb >>= 4;\n\t\tcr >>= 4;\n\t\t \n\t\tif (tpg->real_quantization == V4L2_QUANTIZATION_LIM_RANGE &&\n\t\t    tpg->real_ycbcr_enc != V4L2_YCBCR_ENC_XV601 &&\n\t\t    tpg->real_ycbcr_enc != V4L2_YCBCR_ENC_XV709) {\n\t\t\ty = clamp(y, 16, 235);\n\t\t\tcb = clamp(cb, 16, 240);\n\t\t\tcr = clamp(cr, 16, 240);\n\t\t} else {\n\t\t\ty = clamp(y, 1, 254);\n\t\t\tcb = clamp(cb, 1, 254);\n\t\t\tcr = clamp(cr, 1, 254);\n\t\t}\n\t\tswitch (tpg->fourcc) {\n\t\tcase V4L2_PIX_FMT_YUV444:\n\t\t\ty >>= 4;\n\t\t\tcb >>= 4;\n\t\t\tcr >>= 4;\n\t\t\tbreak;\n\t\tcase V4L2_PIX_FMT_YUV555:\n\t\t\ty >>= 3;\n\t\t\tcb >>= 3;\n\t\t\tcr >>= 3;\n\t\t\tbreak;\n\t\tcase V4L2_PIX_FMT_YUV565:\n\t\t\ty >>= 3;\n\t\t\tcb >>= 2;\n\t\t\tcr >>= 3;\n\t\t\tbreak;\n\t\t}\n\t\ttpg->colors[k][0] = y;\n\t\ttpg->colors[k][1] = cb;\n\t\ttpg->colors[k][2] = cr;\n\t\tbreak;\n\t}\n\tcase TGP_COLOR_ENC_LUMA:\n\t{\n\t\ttpg->colors[k][0] = r >> 4;\n\t\tbreak;\n\t}\n\tcase TGP_COLOR_ENC_RGB:\n\t{\n\t\tif (tpg->real_quantization == V4L2_QUANTIZATION_LIM_RANGE) {\n\t\t\tr = (r * 219) / 255 + (16 << 4);\n\t\t\tg = (g * 219) / 255 + (16 << 4);\n\t\t\tb = (b * 219) / 255 + (16 << 4);\n\t\t}\n\t\tswitch (tpg->fourcc) {\n\t\tcase V4L2_PIX_FMT_RGB332:\n\t\t\tr >>= 9;\n\t\t\tg >>= 9;\n\t\t\tb >>= 10;\n\t\t\tbreak;\n\t\tcase V4L2_PIX_FMT_RGB565:\n\t\tcase V4L2_PIX_FMT_RGB565X:\n\t\t\tr >>= 7;\n\t\t\tg >>= 6;\n\t\t\tb >>= 7;\n\t\t\tbreak;\n\t\tcase V4L2_PIX_FMT_RGB444:\n\t\tcase V4L2_PIX_FMT_XRGB444:\n\t\tcase V4L2_PIX_FMT_ARGB444:\n\t\tcase V4L2_PIX_FMT_RGBX444:\n\t\tcase V4L2_PIX_FMT_RGBA444:\n\t\tcase V4L2_PIX_FMT_XBGR444:\n\t\tcase V4L2_PIX_FMT_ABGR444:\n\t\tcase V4L2_PIX_FMT_BGRX444:\n\t\tcase V4L2_PIX_FMT_BGRA444:\n\t\t\tr >>= 8;\n\t\t\tg >>= 8;\n\t\t\tb >>= 8;\n\t\t\tbreak;\n\t\tcase V4L2_PIX_FMT_RGB555:\n\t\tcase V4L2_PIX_FMT_XRGB555:\n\t\tcase V4L2_PIX_FMT_ARGB555:\n\t\tcase V4L2_PIX_FMT_RGBX555:\n\t\tcase V4L2_PIX_FMT_RGBA555:\n\t\tcase V4L2_PIX_FMT_XBGR555:\n\t\tcase V4L2_PIX_FMT_ABGR555:\n\t\tcase V4L2_PIX_FMT_BGRX555:\n\t\tcase V4L2_PIX_FMT_BGRA555:\n\t\tcase V4L2_PIX_FMT_RGB555X:\n\t\tcase V4L2_PIX_FMT_XRGB555X:\n\t\tcase V4L2_PIX_FMT_ARGB555X:\n\t\t\tr >>= 7;\n\t\t\tg >>= 7;\n\t\t\tb >>= 7;\n\t\t\tbreak;\n\t\tcase V4L2_PIX_FMT_BGR666:\n\t\t\tr >>= 6;\n\t\t\tg >>= 6;\n\t\t\tb >>= 6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr >>= 4;\n\t\t\tg >>= 4;\n\t\t\tb >>= 4;\n\t\t\tbreak;\n\t\t}\n\n\t\ttpg->colors[k][0] = r;\n\t\ttpg->colors[k][1] = g;\n\t\ttpg->colors[k][2] = b;\n\t\tbreak;\n\t}\n\t}\n}\n\nstatic void tpg_precalculate_colors(struct tpg_data *tpg)\n{\n\tint k;\n\n\tfor (k = 0; k < TPG_COLOR_MAX; k++)\n\t\tprecalculate_color(tpg, k);\n}\n\n \nstatic void gen_twopix(struct tpg_data *tpg,\n\t\tu8 buf[TPG_MAX_PLANES][8], int color, bool odd)\n{\n\tunsigned offset = odd * tpg->twopixelsize[0] / 2;\n\tu8 alpha = tpg->alpha_component;\n\tu8 r_y_h, g_u_s, b_v;\n\n\tif (tpg->alpha_red_only && color != TPG_COLOR_CSC_RED &&\n\t\t\t\t   color != TPG_COLOR_100_RED &&\n\t\t\t\t   color != TPG_COLOR_75_RED)\n\t\talpha = 0;\n\tif (color == TPG_COLOR_RANDOM)\n\t\tprecalculate_color(tpg, color);\n\tr_y_h = tpg->colors[color][0];  \n\tg_u_s = tpg->colors[color][1];  \n\tb_v = tpg->colors[color][2];  \n\n\tswitch (tpg->fourcc) {\n\tcase V4L2_PIX_FMT_GREY:\n\t\tbuf[0][offset] = r_y_h;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_Y10:\n\t\tbuf[0][offset] = (r_y_h << 2) & 0xff;\n\t\tbuf[0][offset+1] = r_y_h >> 6;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_Y12:\n\t\tbuf[0][offset] = (r_y_h << 4) & 0xff;\n\t\tbuf[0][offset+1] = r_y_h >> 4;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_Y16:\n\tcase V4L2_PIX_FMT_Z16:\n\t\t \n\t\tbuf[0][offset] = r_y_h == 0xff ? r_y_h : 0;\n\t\tbuf[0][offset+1] = r_y_h;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_Y16_BE:\n\t\t \n\t\tbuf[0][offset] = r_y_h;\n\t\tbuf[0][offset+1] = r_y_h == 0xff ? r_y_h : 0;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV422M:\n\tcase V4L2_PIX_FMT_YUV422P:\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_YUV420M:\n\t\tbuf[0][offset] = r_y_h;\n\t\tif (odd) {\n\t\t\tbuf[1][0] = (buf[1][0] + g_u_s) / 2;\n\t\t\tbuf[2][0] = (buf[2][0] + b_v) / 2;\n\t\t\tbuf[1][1] = buf[1][0];\n\t\t\tbuf[2][1] = buf[2][0];\n\t\t\tbreak;\n\t\t}\n\t\tbuf[1][0] = g_u_s;\n\t\tbuf[2][0] = b_v;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YVU422M:\n\tcase V4L2_PIX_FMT_YVU420:\n\tcase V4L2_PIX_FMT_YVU420M:\n\t\tbuf[0][offset] = r_y_h;\n\t\tif (odd) {\n\t\t\tbuf[1][0] = (buf[1][0] + b_v) / 2;\n\t\t\tbuf[2][0] = (buf[2][0] + g_u_s) / 2;\n\t\t\tbuf[1][1] = buf[1][0];\n\t\t\tbuf[2][1] = buf[2][0];\n\t\t\tbreak;\n\t\t}\n\t\tbuf[1][0] = b_v;\n\t\tbuf[2][0] = g_u_s;\n\t\tbreak;\n\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV12M:\n\tcase V4L2_PIX_FMT_NV16:\n\tcase V4L2_PIX_FMT_NV16M:\n\t\tbuf[0][offset] = r_y_h;\n\t\tif (odd) {\n\t\t\tbuf[1][0] = (buf[1][0] + g_u_s) / 2;\n\t\t\tbuf[1][1] = (buf[1][1] + b_v) / 2;\n\t\t\tbreak;\n\t\t}\n\t\tbuf[1][0] = g_u_s;\n\t\tbuf[1][1] = b_v;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV21:\n\tcase V4L2_PIX_FMT_NV21M:\n\tcase V4L2_PIX_FMT_NV61:\n\tcase V4L2_PIX_FMT_NV61M:\n\t\tbuf[0][offset] = r_y_h;\n\t\tif (odd) {\n\t\t\tbuf[1][0] = (buf[1][0] + b_v) / 2;\n\t\t\tbuf[1][1] = (buf[1][1] + g_u_s) / 2;\n\t\t\tbreak;\n\t\t}\n\t\tbuf[1][0] = b_v;\n\t\tbuf[1][1] = g_u_s;\n\t\tbreak;\n\n\tcase V4L2_PIX_FMT_YUV444M:\n\t\tbuf[0][offset] = r_y_h;\n\t\tbuf[1][offset] = g_u_s;\n\t\tbuf[2][offset] = b_v;\n\t\tbreak;\n\n\tcase V4L2_PIX_FMT_YVU444M:\n\t\tbuf[0][offset] = r_y_h;\n\t\tbuf[1][offset] = b_v;\n\t\tbuf[2][offset] = g_u_s;\n\t\tbreak;\n\n\tcase V4L2_PIX_FMT_NV24:\n\t\tbuf[0][offset] = r_y_h;\n\t\tbuf[1][2 * offset] = g_u_s;\n\t\tbuf[1][(2 * offset + 1) % 8] = b_v;\n\t\tbreak;\n\n\tcase V4L2_PIX_FMT_NV42:\n\t\tbuf[0][offset] = r_y_h;\n\t\tbuf[1][2 * offset] = b_v;\n\t\tbuf[1][(2 * offset + 1) % 8] = g_u_s;\n\t\tbreak;\n\n\tcase V4L2_PIX_FMT_YUYV:\n\t\tbuf[0][offset] = r_y_h;\n\t\tif (odd) {\n\t\t\tbuf[0][1] = (buf[0][1] + g_u_s) / 2;\n\t\t\tbuf[0][3] = (buf[0][3] + b_v) / 2;\n\t\t\tbreak;\n\t\t}\n\t\tbuf[0][1] = g_u_s;\n\t\tbuf[0][3] = b_v;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_UYVY:\n\t\tbuf[0][offset + 1] = r_y_h;\n\t\tif (odd) {\n\t\t\tbuf[0][0] = (buf[0][0] + g_u_s) / 2;\n\t\t\tbuf[0][2] = (buf[0][2] + b_v) / 2;\n\t\t\tbreak;\n\t\t}\n\t\tbuf[0][0] = g_u_s;\n\t\tbuf[0][2] = b_v;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YVYU:\n\t\tbuf[0][offset] = r_y_h;\n\t\tif (odd) {\n\t\t\tbuf[0][1] = (buf[0][1] + b_v) / 2;\n\t\t\tbuf[0][3] = (buf[0][3] + g_u_s) / 2;\n\t\t\tbreak;\n\t\t}\n\t\tbuf[0][1] = b_v;\n\t\tbuf[0][3] = g_u_s;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_VYUY:\n\t\tbuf[0][offset + 1] = r_y_h;\n\t\tif (odd) {\n\t\t\tbuf[0][0] = (buf[0][0] + b_v) / 2;\n\t\t\tbuf[0][2] = (buf[0][2] + g_u_s) / 2;\n\t\t\tbreak;\n\t\t}\n\t\tbuf[0][0] = b_v;\n\t\tbuf[0][2] = g_u_s;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB332:\n\t\tbuf[0][offset] = (r_y_h << 5) | (g_u_s << 2) | b_v;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV565:\n\tcase V4L2_PIX_FMT_RGB565:\n\t\tbuf[0][offset] = (g_u_s << 5) | b_v;\n\t\tbuf[0][offset + 1] = (r_y_h << 3) | (g_u_s >> 3);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB565X:\n\t\tbuf[0][offset] = (r_y_h << 3) | (g_u_s >> 3);\n\t\tbuf[0][offset + 1] = (g_u_s << 5) | b_v;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB444:\n\tcase V4L2_PIX_FMT_XRGB444:\n\t\talpha = 0;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_YUV444:\n\tcase V4L2_PIX_FMT_ARGB444:\n\t\tbuf[0][offset] = (g_u_s << 4) | b_v;\n\t\tbuf[0][offset + 1] = (alpha & 0xf0) | r_y_h;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGBX444:\n\t\talpha = 0;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_RGBA444:\n\t\tbuf[0][offset] = (b_v << 4) | (alpha >> 4);\n\t\tbuf[0][offset + 1] = (r_y_h << 4) | g_u_s;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_XBGR444:\n\t\talpha = 0;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_ABGR444:\n\t\tbuf[0][offset] = (g_u_s << 4) | r_y_h;\n\t\tbuf[0][offset + 1] = (alpha & 0xf0) | b_v;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGRX444:\n\t\talpha = 0;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_BGRA444:\n\t\tbuf[0][offset] = (r_y_h << 4) | (alpha >> 4);\n\t\tbuf[0][offset + 1] = (b_v << 4) | g_u_s;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB555:\n\tcase V4L2_PIX_FMT_XRGB555:\n\t\talpha = 0;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_YUV555:\n\tcase V4L2_PIX_FMT_ARGB555:\n\t\tbuf[0][offset] = (g_u_s << 5) | b_v;\n\t\tbuf[0][offset + 1] = (alpha & 0x80) | (r_y_h << 2)\n\t\t\t\t\t\t    | (g_u_s >> 3);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGBX555:\n\t\talpha = 0;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_RGBA555:\n\t\tbuf[0][offset] = (g_u_s << 6) | (b_v << 1) |\n\t\t\t\t ((alpha & 0x80) >> 7);\n\t\tbuf[0][offset + 1] = (r_y_h << 3) | (g_u_s >> 2);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_XBGR555:\n\t\talpha = 0;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_ABGR555:\n\t\tbuf[0][offset] = (g_u_s << 5) | r_y_h;\n\t\tbuf[0][offset + 1] = (alpha & 0x80) | (b_v << 2)\n\t\t\t\t\t\t    | (g_u_s >> 3);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGRX555:\n\t\talpha = 0;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_BGRA555:\n\t\tbuf[0][offset] = (g_u_s << 6) | (r_y_h << 1) |\n\t\t\t\t ((alpha & 0x80) >> 7);\n\t\tbuf[0][offset + 1] = (b_v << 3) | (g_u_s >> 2);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB555X:\n\tcase V4L2_PIX_FMT_XRGB555X:\n\t\talpha = 0;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_ARGB555X:\n\t\tbuf[0][offset] = (alpha & 0x80) | (r_y_h << 2) | (g_u_s >> 3);\n\t\tbuf[0][offset + 1] = (g_u_s << 5) | b_v;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB24:\n\tcase V4L2_PIX_FMT_HSV24:\n\t\tbuf[0][offset] = r_y_h;\n\t\tbuf[0][offset + 1] = g_u_s;\n\t\tbuf[0][offset + 2] = b_v;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR24:\n\t\tbuf[0][offset] = b_v;\n\t\tbuf[0][offset + 1] = g_u_s;\n\t\tbuf[0][offset + 2] = r_y_h;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR666:\n\t\tbuf[0][offset] = (b_v << 2) | (g_u_s >> 4);\n\t\tbuf[0][offset + 1] = (g_u_s << 4) | (r_y_h >> 2);\n\t\tbuf[0][offset + 2] = r_y_h << 6;\n\t\tbuf[0][offset + 3] = 0;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB32:\n\tcase V4L2_PIX_FMT_XRGB32:\n\tcase V4L2_PIX_FMT_HSV32:\n\tcase V4L2_PIX_FMT_XYUV32:\n\t\talpha = 0;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_YUV32:\n\tcase V4L2_PIX_FMT_ARGB32:\n\tcase V4L2_PIX_FMT_AYUV32:\n\t\tbuf[0][offset] = alpha;\n\t\tbuf[0][offset + 1] = r_y_h;\n\t\tbuf[0][offset + 2] = g_u_s;\n\t\tbuf[0][offset + 3] = b_v;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGBX32:\n\tcase V4L2_PIX_FMT_YUVX32:\n\t\talpha = 0;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_RGBA32:\n\tcase V4L2_PIX_FMT_YUVA32:\n\t\tbuf[0][offset] = r_y_h;\n\t\tbuf[0][offset + 1] = g_u_s;\n\t\tbuf[0][offset + 2] = b_v;\n\t\tbuf[0][offset + 3] = alpha;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR32:\n\tcase V4L2_PIX_FMT_XBGR32:\n\tcase V4L2_PIX_FMT_VUYX32:\n\t\talpha = 0;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_ABGR32:\n\tcase V4L2_PIX_FMT_VUYA32:\n\t\tbuf[0][offset] = b_v;\n\t\tbuf[0][offset + 1] = g_u_s;\n\t\tbuf[0][offset + 2] = r_y_h;\n\t\tbuf[0][offset + 3] = alpha;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGRX32:\n\t\talpha = 0;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_BGRA32:\n\t\tbuf[0][offset] = alpha;\n\t\tbuf[0][offset + 1] = b_v;\n\t\tbuf[0][offset + 2] = g_u_s;\n\t\tbuf[0][offset + 3] = r_y_h;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SBGGR8:\n\t\tbuf[0][offset] = odd ? g_u_s : b_v;\n\t\tbuf[1][offset] = odd ? r_y_h : g_u_s;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SGBRG8:\n\t\tbuf[0][offset] = odd ? b_v : g_u_s;\n\t\tbuf[1][offset] = odd ? g_u_s : r_y_h;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SGRBG8:\n\t\tbuf[0][offset] = odd ? r_y_h : g_u_s;\n\t\tbuf[1][offset] = odd ? g_u_s : b_v;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SRGGB8:\n\t\tbuf[0][offset] = odd ? g_u_s : r_y_h;\n\t\tbuf[1][offset] = odd ? b_v : g_u_s;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SBGGR10:\n\t\tbuf[0][offset] = odd ? g_u_s << 2 : b_v << 2;\n\t\tbuf[0][offset + 1] = odd ? g_u_s >> 6 : b_v >> 6;\n\t\tbuf[1][offset] = odd ? r_y_h << 2 : g_u_s << 2;\n\t\tbuf[1][offset + 1] = odd ? r_y_h >> 6 : g_u_s >> 6;\n\t\tbuf[0][offset] |= (buf[0][offset] >> 2) & 3;\n\t\tbuf[1][offset] |= (buf[1][offset] >> 2) & 3;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SGBRG10:\n\t\tbuf[0][offset] = odd ? b_v << 2 : g_u_s << 2;\n\t\tbuf[0][offset + 1] = odd ? b_v >> 6 : g_u_s >> 6;\n\t\tbuf[1][offset] = odd ? g_u_s << 2 : r_y_h << 2;\n\t\tbuf[1][offset + 1] = odd ? g_u_s >> 6 : r_y_h >> 6;\n\t\tbuf[0][offset] |= (buf[0][offset] >> 2) & 3;\n\t\tbuf[1][offset] |= (buf[1][offset] >> 2) & 3;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SGRBG10:\n\t\tbuf[0][offset] = odd ? r_y_h << 2 : g_u_s << 2;\n\t\tbuf[0][offset + 1] = odd ? r_y_h >> 6 : g_u_s >> 6;\n\t\tbuf[1][offset] = odd ? g_u_s << 2 : b_v << 2;\n\t\tbuf[1][offset + 1] = odd ? g_u_s >> 6 : b_v >> 6;\n\t\tbuf[0][offset] |= (buf[0][offset] >> 2) & 3;\n\t\tbuf[1][offset] |= (buf[1][offset] >> 2) & 3;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SRGGB10:\n\t\tbuf[0][offset] = odd ? g_u_s << 2 : r_y_h << 2;\n\t\tbuf[0][offset + 1] = odd ? g_u_s >> 6 : r_y_h >> 6;\n\t\tbuf[1][offset] = odd ? b_v << 2 : g_u_s << 2;\n\t\tbuf[1][offset + 1] = odd ? b_v >> 6 : g_u_s >> 6;\n\t\tbuf[0][offset] |= (buf[0][offset] >> 2) & 3;\n\t\tbuf[1][offset] |= (buf[1][offset] >> 2) & 3;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SBGGR12:\n\t\tbuf[0][offset] = odd ? g_u_s << 4 : b_v << 4;\n\t\tbuf[0][offset + 1] = odd ? g_u_s >> 4 : b_v >> 4;\n\t\tbuf[1][offset] = odd ? r_y_h << 4 : g_u_s << 4;\n\t\tbuf[1][offset + 1] = odd ? r_y_h >> 4 : g_u_s >> 4;\n\t\tbuf[0][offset] |= (buf[0][offset] >> 4) & 0xf;\n\t\tbuf[1][offset] |= (buf[1][offset] >> 4) & 0xf;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SGBRG12:\n\t\tbuf[0][offset] = odd ? b_v << 4 : g_u_s << 4;\n\t\tbuf[0][offset + 1] = odd ? b_v >> 4 : g_u_s >> 4;\n\t\tbuf[1][offset] = odd ? g_u_s << 4 : r_y_h << 4;\n\t\tbuf[1][offset + 1] = odd ? g_u_s >> 4 : r_y_h >> 4;\n\t\tbuf[0][offset] |= (buf[0][offset] >> 4) & 0xf;\n\t\tbuf[1][offset] |= (buf[1][offset] >> 4) & 0xf;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SGRBG12:\n\t\tbuf[0][offset] = odd ? r_y_h << 4 : g_u_s << 4;\n\t\tbuf[0][offset + 1] = odd ? r_y_h >> 4 : g_u_s >> 4;\n\t\tbuf[1][offset] = odd ? g_u_s << 4 : b_v << 4;\n\t\tbuf[1][offset + 1] = odd ? g_u_s >> 4 : b_v >> 4;\n\t\tbuf[0][offset] |= (buf[0][offset] >> 4) & 0xf;\n\t\tbuf[1][offset] |= (buf[1][offset] >> 4) & 0xf;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SRGGB12:\n\t\tbuf[0][offset] = odd ? g_u_s << 4 : r_y_h << 4;\n\t\tbuf[0][offset + 1] = odd ? g_u_s >> 4 : r_y_h >> 4;\n\t\tbuf[1][offset] = odd ? b_v << 4 : g_u_s << 4;\n\t\tbuf[1][offset + 1] = odd ? b_v >> 4 : g_u_s >> 4;\n\t\tbuf[0][offset] |= (buf[0][offset] >> 4) & 0xf;\n\t\tbuf[1][offset] |= (buf[1][offset] >> 4) & 0xf;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SBGGR16:\n\t\tbuf[0][offset] = buf[0][offset + 1] = odd ? g_u_s : b_v;\n\t\tbuf[1][offset] = buf[1][offset + 1] = odd ? r_y_h : g_u_s;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SGBRG16:\n\t\tbuf[0][offset] = buf[0][offset + 1] = odd ? b_v : g_u_s;\n\t\tbuf[1][offset] = buf[1][offset + 1] = odd ? g_u_s : r_y_h;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SGRBG16:\n\t\tbuf[0][offset] = buf[0][offset + 1] = odd ? r_y_h : g_u_s;\n\t\tbuf[1][offset] = buf[1][offset + 1] = odd ? g_u_s : b_v;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SRGGB16:\n\t\tbuf[0][offset] = buf[0][offset + 1] = odd ? g_u_s : r_y_h;\n\t\tbuf[1][offset] = buf[1][offset + 1] = odd ? b_v : g_u_s;\n\t\tbreak;\n\t}\n}\n\nunsigned tpg_g_interleaved_plane(const struct tpg_data *tpg, unsigned buf_line)\n{\n\tswitch (tpg->fourcc) {\n\tcase V4L2_PIX_FMT_SBGGR8:\n\tcase V4L2_PIX_FMT_SGBRG8:\n\tcase V4L2_PIX_FMT_SGRBG8:\n\tcase V4L2_PIX_FMT_SRGGB8:\n\tcase V4L2_PIX_FMT_SBGGR10:\n\tcase V4L2_PIX_FMT_SGBRG10:\n\tcase V4L2_PIX_FMT_SGRBG10:\n\tcase V4L2_PIX_FMT_SRGGB10:\n\tcase V4L2_PIX_FMT_SBGGR12:\n\tcase V4L2_PIX_FMT_SGBRG12:\n\tcase V4L2_PIX_FMT_SGRBG12:\n\tcase V4L2_PIX_FMT_SRGGB12:\n\tcase V4L2_PIX_FMT_SBGGR16:\n\tcase V4L2_PIX_FMT_SGBRG16:\n\tcase V4L2_PIX_FMT_SGRBG16:\n\tcase V4L2_PIX_FMT_SRGGB16:\n\t\treturn buf_line & 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL_GPL(tpg_g_interleaved_plane);\n\n \nstatic unsigned tpg_get_pat_lines(const struct tpg_data *tpg)\n{\n\tswitch (tpg->pattern) {\n\tcase TPG_PAT_CHECKERS_16X16:\n\tcase TPG_PAT_CHECKERS_2X2:\n\tcase TPG_PAT_CHECKERS_1X1:\n\tcase TPG_PAT_COLOR_CHECKERS_2X2:\n\tcase TPG_PAT_COLOR_CHECKERS_1X1:\n\tcase TPG_PAT_ALTERNATING_HLINES:\n\tcase TPG_PAT_CROSS_1_PIXEL:\n\tcase TPG_PAT_CROSS_2_PIXELS:\n\tcase TPG_PAT_CROSS_10_PIXELS:\n\t\treturn 2;\n\tcase TPG_PAT_100_COLORSQUARES:\n\tcase TPG_PAT_100_HCOLORBAR:\n\t\treturn 8;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\n \nstatic unsigned tpg_get_pat_line(const struct tpg_data *tpg, unsigned line)\n{\n\tswitch (tpg->pattern) {\n\tcase TPG_PAT_CHECKERS_16X16:\n\t\treturn (line >> 4) & 1;\n\tcase TPG_PAT_CHECKERS_1X1:\n\tcase TPG_PAT_COLOR_CHECKERS_1X1:\n\tcase TPG_PAT_ALTERNATING_HLINES:\n\t\treturn line & 1;\n\tcase TPG_PAT_CHECKERS_2X2:\n\tcase TPG_PAT_COLOR_CHECKERS_2X2:\n\t\treturn (line & 2) >> 1;\n\tcase TPG_PAT_100_COLORSQUARES:\n\tcase TPG_PAT_100_HCOLORBAR:\n\t\treturn (line * 8) / tpg->src_height;\n\tcase TPG_PAT_CROSS_1_PIXEL:\n\t\treturn line == tpg->src_height / 2;\n\tcase TPG_PAT_CROSS_2_PIXELS:\n\t\treturn (line + 1) / 2 == tpg->src_height / 4;\n\tcase TPG_PAT_CROSS_10_PIXELS:\n\t\treturn (line + 10) / 20 == tpg->src_height / 40;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic enum tpg_color tpg_get_color(const struct tpg_data *tpg,\n\t\t\t\t    unsigned pat_line, unsigned x)\n{\n\t \n\tstatic const enum tpg_color bars[3][8] = {\n\t\t \n\t\t{ TPG_COLOR_CSC_WHITE,   TPG_COLOR_75_YELLOW,\n\t\t  TPG_COLOR_75_CYAN,     TPG_COLOR_75_GREEN,\n\t\t  TPG_COLOR_75_MAGENTA,  TPG_COLOR_75_RED,\n\t\t  TPG_COLOR_75_BLUE,     TPG_COLOR_100_BLACK, },\n\t\t \n\t\t{ TPG_COLOR_100_WHITE,   TPG_COLOR_100_YELLOW,\n\t\t  TPG_COLOR_100_CYAN,    TPG_COLOR_100_GREEN,\n\t\t  TPG_COLOR_100_MAGENTA, TPG_COLOR_100_RED,\n\t\t  TPG_COLOR_100_BLUE,    TPG_COLOR_100_BLACK, },\n\t\t \n\t\t{ TPG_COLOR_CSC_WHITE,   TPG_COLOR_CSC_YELLOW,\n\t\t  TPG_COLOR_CSC_CYAN,    TPG_COLOR_CSC_GREEN,\n\t\t  TPG_COLOR_CSC_MAGENTA, TPG_COLOR_CSC_RED,\n\t\t  TPG_COLOR_CSC_BLUE,    TPG_COLOR_CSC_BLACK, },\n\t};\n\n\tswitch (tpg->pattern) {\n\tcase TPG_PAT_75_COLORBAR:\n\tcase TPG_PAT_100_COLORBAR:\n\tcase TPG_PAT_CSC_COLORBAR:\n\t\treturn bars[tpg->pattern][((x * 8) / tpg->src_width) % 8];\n\tcase TPG_PAT_100_COLORSQUARES:\n\t\treturn bars[1][(pat_line + (x * 8) / tpg->src_width) % 8];\n\tcase TPG_PAT_100_HCOLORBAR:\n\t\treturn bars[1][pat_line];\n\tcase TPG_PAT_BLACK:\n\t\treturn TPG_COLOR_100_BLACK;\n\tcase TPG_PAT_WHITE:\n\t\treturn TPG_COLOR_100_WHITE;\n\tcase TPG_PAT_RED:\n\t\treturn TPG_COLOR_100_RED;\n\tcase TPG_PAT_GREEN:\n\t\treturn TPG_COLOR_100_GREEN;\n\tcase TPG_PAT_BLUE:\n\t\treturn TPG_COLOR_100_BLUE;\n\tcase TPG_PAT_CHECKERS_16X16:\n\t\treturn (((x >> 4) & 1) ^ (pat_line & 1)) ?\n\t\t\tTPG_COLOR_100_BLACK : TPG_COLOR_100_WHITE;\n\tcase TPG_PAT_CHECKERS_1X1:\n\t\treturn ((x & 1) ^ (pat_line & 1)) ?\n\t\t\tTPG_COLOR_100_WHITE : TPG_COLOR_100_BLACK;\n\tcase TPG_PAT_COLOR_CHECKERS_1X1:\n\t\treturn ((x & 1) ^ (pat_line & 1)) ?\n\t\t\tTPG_COLOR_100_RED : TPG_COLOR_100_BLUE;\n\tcase TPG_PAT_CHECKERS_2X2:\n\t\treturn (((x >> 1) & 1) ^ (pat_line & 1)) ?\n\t\t\tTPG_COLOR_100_WHITE : TPG_COLOR_100_BLACK;\n\tcase TPG_PAT_COLOR_CHECKERS_2X2:\n\t\treturn (((x >> 1) & 1) ^ (pat_line & 1)) ?\n\t\t\tTPG_COLOR_100_RED : TPG_COLOR_100_BLUE;\n\tcase TPG_PAT_ALTERNATING_HLINES:\n\t\treturn pat_line ? TPG_COLOR_100_WHITE : TPG_COLOR_100_BLACK;\n\tcase TPG_PAT_ALTERNATING_VLINES:\n\t\treturn (x & 1) ? TPG_COLOR_100_WHITE : TPG_COLOR_100_BLACK;\n\tcase TPG_PAT_CROSS_1_PIXEL:\n\t\tif (pat_line || (x % tpg->src_width) == tpg->src_width / 2)\n\t\t\treturn TPG_COLOR_100_BLACK;\n\t\treturn TPG_COLOR_100_WHITE;\n\tcase TPG_PAT_CROSS_2_PIXELS:\n\t\tif (pat_line || ((x % tpg->src_width) + 1) / 2 == tpg->src_width / 4)\n\t\t\treturn TPG_COLOR_100_BLACK;\n\t\treturn TPG_COLOR_100_WHITE;\n\tcase TPG_PAT_CROSS_10_PIXELS:\n\t\tif (pat_line || ((x % tpg->src_width) + 10) / 20 == tpg->src_width / 40)\n\t\t\treturn TPG_COLOR_100_BLACK;\n\t\treturn TPG_COLOR_100_WHITE;\n\tcase TPG_PAT_GRAY_RAMP:\n\t\treturn TPG_COLOR_RAMP + ((x % tpg->src_width) * 256) / tpg->src_width;\n\tdefault:\n\t\treturn TPG_COLOR_100_RED;\n\t}\n}\n\n \nstatic void tpg_calculate_square_border(struct tpg_data *tpg)\n{\n\tunsigned w = tpg->src_width;\n\tunsigned h = tpg->src_height;\n\tunsigned sq_w, sq_h;\n\n\tsq_w = (w * 2 / 5) & ~1;\n\tif (((w - sq_w) / 2) & 1)\n\t\tsq_w += 2;\n\tsq_h = sq_w;\n\ttpg->square.width = sq_w;\n\tif (tpg->vid_aspect == TPG_VIDEO_ASPECT_16X9_ANAMORPHIC) {\n\t\tunsigned ana_sq_w = (sq_w / 4) * 3;\n\n\t\tif (((w - ana_sq_w) / 2) & 1)\n\t\t\tana_sq_w += 2;\n\t\ttpg->square.width = ana_sq_w;\n\t}\n\ttpg->square.left = (w - tpg->square.width) / 2;\n\tif (tpg->pix_aspect == TPG_PIXEL_ASPECT_NTSC)\n\t\tsq_h = sq_w * 10 / 11;\n\telse if (tpg->pix_aspect == TPG_PIXEL_ASPECT_PAL)\n\t\tsq_h = sq_w * 59 / 54;\n\ttpg->square.height = sq_h;\n\ttpg->square.top = (h - sq_h) / 2;\n\ttpg->border.left = 0;\n\ttpg->border.width = w;\n\ttpg->border.top = 0;\n\ttpg->border.height = h;\n\tswitch (tpg->vid_aspect) {\n\tcase TPG_VIDEO_ASPECT_4X3:\n\t\tif (tpg->pix_aspect)\n\t\t\treturn;\n\t\tif (3 * w >= 4 * h) {\n\t\t\ttpg->border.width = ((4 * h) / 3) & ~1;\n\t\t\tif (((w - tpg->border.width) / 2) & ~1)\n\t\t\t\ttpg->border.width -= 2;\n\t\t\ttpg->border.left = (w - tpg->border.width) / 2;\n\t\t\tbreak;\n\t\t}\n\t\ttpg->border.height = ((3 * w) / 4) & ~1;\n\t\ttpg->border.top = (h - tpg->border.height) / 2;\n\t\tbreak;\n\tcase TPG_VIDEO_ASPECT_14X9_CENTRE:\n\t\tif (tpg->pix_aspect) {\n\t\t\ttpg->border.height = tpg->pix_aspect == TPG_PIXEL_ASPECT_NTSC ? 420 : 506;\n\t\t\ttpg->border.top = (h - tpg->border.height) / 2;\n\t\t\tbreak;\n\t\t}\n\t\tif (9 * w >= 14 * h) {\n\t\t\ttpg->border.width = ((14 * h) / 9) & ~1;\n\t\t\tif (((w - tpg->border.width) / 2) & ~1)\n\t\t\t\ttpg->border.width -= 2;\n\t\t\ttpg->border.left = (w - tpg->border.width) / 2;\n\t\t\tbreak;\n\t\t}\n\t\ttpg->border.height = ((9 * w) / 14) & ~1;\n\t\ttpg->border.top = (h - tpg->border.height) / 2;\n\t\tbreak;\n\tcase TPG_VIDEO_ASPECT_16X9_CENTRE:\n\t\tif (tpg->pix_aspect) {\n\t\t\ttpg->border.height = tpg->pix_aspect == TPG_PIXEL_ASPECT_NTSC ? 368 : 442;\n\t\t\ttpg->border.top = (h - tpg->border.height) / 2;\n\t\t\tbreak;\n\t\t}\n\t\tif (9 * w >= 16 * h) {\n\t\t\ttpg->border.width = ((16 * h) / 9) & ~1;\n\t\t\tif (((w - tpg->border.width) / 2) & ~1)\n\t\t\t\ttpg->border.width -= 2;\n\t\t\ttpg->border.left = (w - tpg->border.width) / 2;\n\t\t\tbreak;\n\t\t}\n\t\ttpg->border.height = ((9 * w) / 16) & ~1;\n\t\ttpg->border.top = (h - tpg->border.height) / 2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void tpg_precalculate_line(struct tpg_data *tpg)\n{\n\tenum tpg_color contrast;\n\tu8 pix[TPG_MAX_PLANES][8];\n\tunsigned pat;\n\tunsigned p;\n\tunsigned x;\n\n\tswitch (tpg->pattern) {\n\tcase TPG_PAT_GREEN:\n\t\tcontrast = TPG_COLOR_100_RED;\n\t\tbreak;\n\tcase TPG_PAT_CSC_COLORBAR:\n\t\tcontrast = TPG_COLOR_CSC_GREEN;\n\t\tbreak;\n\tdefault:\n\t\tcontrast = TPG_COLOR_100_GREEN;\n\t\tbreak;\n\t}\n\n\tfor (pat = 0; pat < tpg_get_pat_lines(tpg); pat++) {\n\t\t \n\t\tunsigned int_part = tpg->src_width / tpg->scaled_width;\n\t\tunsigned fract_part = tpg->src_width % tpg->scaled_width;\n\t\tunsigned src_x = 0;\n\t\tunsigned error = 0;\n\n\t\tfor (x = 0; x < tpg->scaled_width * 2; x += 2) {\n\t\t\tunsigned real_x = src_x;\n\t\t\tenum tpg_color color1, color2;\n\n\t\t\treal_x = tpg->hflip ? tpg->src_width * 2 - real_x - 2 : real_x;\n\t\t\tcolor1 = tpg_get_color(tpg, pat, real_x);\n\n\t\t\tsrc_x += int_part;\n\t\t\terror += fract_part;\n\t\t\tif (error >= tpg->scaled_width) {\n\t\t\t\terror -= tpg->scaled_width;\n\t\t\t\tsrc_x++;\n\t\t\t}\n\n\t\t\treal_x = src_x;\n\t\t\treal_x = tpg->hflip ? tpg->src_width * 2 - real_x - 2 : real_x;\n\t\t\tcolor2 = tpg_get_color(tpg, pat, real_x);\n\n\t\t\tsrc_x += int_part;\n\t\t\terror += fract_part;\n\t\t\tif (error >= tpg->scaled_width) {\n\t\t\t\terror -= tpg->scaled_width;\n\t\t\t\tsrc_x++;\n\t\t\t}\n\n\t\t\tgen_twopix(tpg, pix, tpg->hflip ? color2 : color1, 0);\n\t\t\tgen_twopix(tpg, pix, tpg->hflip ? color1 : color2, 1);\n\t\t\tfor (p = 0; p < tpg->planes; p++) {\n\t\t\t\tunsigned twopixsize = tpg->twopixelsize[p];\n\t\t\t\tunsigned hdiv = tpg->hdownsampling[p];\n\t\t\t\tu8 *pos = tpg->lines[pat][p] + tpg_hdiv(tpg, p, x);\n\n\t\t\t\tmemcpy(pos, pix[p], twopixsize / hdiv);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tpg->vdownsampling[tpg->planes - 1] > 1) {\n\t\tunsigned pat_lines = tpg_get_pat_lines(tpg);\n\n\t\tfor (pat = 0; pat < pat_lines; pat++) {\n\t\t\tunsigned next_pat = (pat + 1) % pat_lines;\n\n\t\t\tfor (p = 1; p < tpg->planes; p++) {\n\t\t\t\tunsigned w = tpg_hdiv(tpg, p, tpg->scaled_width * 2);\n\t\t\t\tu8 *pos1 = tpg->lines[pat][p];\n\t\t\t\tu8 *pos2 = tpg->lines[next_pat][p];\n\t\t\t\tu8 *dest = tpg->downsampled_lines[pat][p];\n\n\t\t\t\tfor (x = 0; x < w; x++, pos1++, pos2++, dest++)\n\t\t\t\t\t*dest = ((u16)*pos1 + (u16)*pos2) / 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tgen_twopix(tpg, pix, contrast, 0);\n\tgen_twopix(tpg, pix, contrast, 1);\n\tfor (p = 0; p < tpg->planes; p++) {\n\t\tunsigned twopixsize = tpg->twopixelsize[p];\n\t\tu8 *pos = tpg->contrast_line[p];\n\n\t\tfor (x = 0; x < tpg->scaled_width; x += 2, pos += twopixsize)\n\t\t\tmemcpy(pos, pix[p], twopixsize);\n\t}\n\n\tgen_twopix(tpg, pix, TPG_COLOR_100_BLACK, 0);\n\tgen_twopix(tpg, pix, TPG_COLOR_100_BLACK, 1);\n\tfor (p = 0; p < tpg->planes; p++) {\n\t\tunsigned twopixsize = tpg->twopixelsize[p];\n\t\tu8 *pos = tpg->black_line[p];\n\n\t\tfor (x = 0; x < tpg->scaled_width; x += 2, pos += twopixsize)\n\t\t\tmemcpy(pos, pix[p], twopixsize);\n\t}\n\n\tfor (x = 0; x < tpg->scaled_width * 2; x += 2) {\n\t\tgen_twopix(tpg, pix, TPG_COLOR_RANDOM, 0);\n\t\tgen_twopix(tpg, pix, TPG_COLOR_RANDOM, 1);\n\t\tfor (p = 0; p < tpg->planes; p++) {\n\t\t\tunsigned twopixsize = tpg->twopixelsize[p];\n\t\t\tu8 *pos = tpg->random_line[p] + x * twopixsize / 2;\n\n\t\t\tmemcpy(pos, pix[p], twopixsize);\n\t\t}\n\t}\n\n\tgen_twopix(tpg, tpg->textbg, TPG_COLOR_TEXTBG, 0);\n\tgen_twopix(tpg, tpg->textbg, TPG_COLOR_TEXTBG, 1);\n\tgen_twopix(tpg, tpg->textfg, TPG_COLOR_TEXTFG, 0);\n\tgen_twopix(tpg, tpg->textfg, TPG_COLOR_TEXTFG, 1);\n}\n\n \ntypedef struct { u16 __; u8 _; } __packed x24;\n\n#define PRINTSTR(PIXTYPE) do {\t\\\n\tunsigned vdiv = tpg->vdownsampling[p]; \\\n\tunsigned hdiv = tpg->hdownsampling[p]; \\\n\tint line;\t\\\n\tPIXTYPE fg;\t\\\n\tPIXTYPE bg;\t\\\n\tmemcpy(&fg, tpg->textfg[p], sizeof(PIXTYPE));\t\\\n\tmemcpy(&bg, tpg->textbg[p], sizeof(PIXTYPE));\t\\\n\t\\\n\tfor (line = first; line < 16; line += vdiv * step) {\t\\\n\t\tint l = tpg->vflip ? 15 - line : line; \\\n\t\tPIXTYPE *pos = (PIXTYPE *)(basep[p][(line / vdiv) & 1] + \\\n\t\t\t       ((y * step + l) / (vdiv * div)) * tpg->bytesperline[p] + \\\n\t\t\t       (x / hdiv) * sizeof(PIXTYPE));\t\\\n\t\tunsigned s;\t\\\n\t\\\n\t\tfor (s = 0; s < len; s++) {\t\\\n\t\t\tu8 chr = font8x16[(u8)text[s] * 16 + line];\t\\\n\t\\\n\t\t\tif (hdiv == 2 && tpg->hflip) { \\\n\t\t\t\tpos[3] = (chr & (0x01 << 6) ? fg : bg);\t\\\n\t\t\t\tpos[2] = (chr & (0x01 << 4) ? fg : bg);\t\\\n\t\t\t\tpos[1] = (chr & (0x01 << 2) ? fg : bg);\t\\\n\t\t\t\tpos[0] = (chr & (0x01 << 0) ? fg : bg);\t\\\n\t\t\t} else if (hdiv == 2) { \\\n\t\t\t\tpos[0] = (chr & (0x01 << 7) ? fg : bg);\t\\\n\t\t\t\tpos[1] = (chr & (0x01 << 5) ? fg : bg);\t\\\n\t\t\t\tpos[2] = (chr & (0x01 << 3) ? fg : bg);\t\\\n\t\t\t\tpos[3] = (chr & (0x01 << 1) ? fg : bg);\t\\\n\t\t\t} else if (tpg->hflip) { \\\n\t\t\t\tpos[7] = (chr & (0x01 << 7) ? fg : bg);\t\\\n\t\t\t\tpos[6] = (chr & (0x01 << 6) ? fg : bg);\t\\\n\t\t\t\tpos[5] = (chr & (0x01 << 5) ? fg : bg);\t\\\n\t\t\t\tpos[4] = (chr & (0x01 << 4) ? fg : bg);\t\\\n\t\t\t\tpos[3] = (chr & (0x01 << 3) ? fg : bg);\t\\\n\t\t\t\tpos[2] = (chr & (0x01 << 2) ? fg : bg);\t\\\n\t\t\t\tpos[1] = (chr & (0x01 << 1) ? fg : bg);\t\\\n\t\t\t\tpos[0] = (chr & (0x01 << 0) ? fg : bg);\t\\\n\t\t\t} else { \\\n\t\t\t\tpos[0] = (chr & (0x01 << 7) ? fg : bg);\t\\\n\t\t\t\tpos[1] = (chr & (0x01 << 6) ? fg : bg);\t\\\n\t\t\t\tpos[2] = (chr & (0x01 << 5) ? fg : bg);\t\\\n\t\t\t\tpos[3] = (chr & (0x01 << 4) ? fg : bg);\t\\\n\t\t\t\tpos[4] = (chr & (0x01 << 3) ? fg : bg);\t\\\n\t\t\t\tpos[5] = (chr & (0x01 << 2) ? fg : bg);\t\\\n\t\t\t\tpos[6] = (chr & (0x01 << 1) ? fg : bg);\t\\\n\t\t\t\tpos[7] = (chr & (0x01 << 0) ? fg : bg);\t\\\n\t\t\t} \\\n\t\\\n\t\t\tpos += (tpg->hflip ? -8 : 8) / (int)hdiv;\t\\\n\t\t}\t\\\n\t}\t\\\n} while (0)\n\nstatic noinline void tpg_print_str_2(const struct tpg_data *tpg, u8 *basep[TPG_MAX_PLANES][2],\n\t\t\tunsigned p, unsigned first, unsigned div, unsigned step,\n\t\t\tint y, int x, const char *text, unsigned len)\n{\n\tPRINTSTR(u8);\n}\n\nstatic noinline void tpg_print_str_4(const struct tpg_data *tpg, u8 *basep[TPG_MAX_PLANES][2],\n\t\t\tunsigned p, unsigned first, unsigned div, unsigned step,\n\t\t\tint y, int x, const char *text, unsigned len)\n{\n\tPRINTSTR(u16);\n}\n\nstatic noinline void tpg_print_str_6(const struct tpg_data *tpg, u8 *basep[TPG_MAX_PLANES][2],\n\t\t\tunsigned p, unsigned first, unsigned div, unsigned step,\n\t\t\tint y, int x, const char *text, unsigned len)\n{\n\tPRINTSTR(x24);\n}\n\nstatic noinline void tpg_print_str_8(const struct tpg_data *tpg, u8 *basep[TPG_MAX_PLANES][2],\n\t\t\tunsigned p, unsigned first, unsigned div, unsigned step,\n\t\t\tint y, int x, const char *text, unsigned len)\n{\n\tPRINTSTR(u32);\n}\n\nvoid tpg_gen_text(const struct tpg_data *tpg, u8 *basep[TPG_MAX_PLANES][2],\n\t\t  int y, int x, const char *text)\n{\n\tunsigned step = V4L2_FIELD_HAS_T_OR_B(tpg->field) ? 2 : 1;\n\tunsigned div = step;\n\tunsigned first = 0;\n\tunsigned len;\n\tunsigned p;\n\n\tif (font8x16 == NULL || basep == NULL || text == NULL)\n\t\treturn;\n\n\tlen = strlen(text);\n\n\t \n\tif (y + 16 >= tpg->compose.height || x + 8 >= tpg->compose.width)\n\t\treturn;\n\n\tif (len > (tpg->compose.width - x) / 8)\n\t\tlen = (tpg->compose.width - x) / 8;\n\tif (tpg->vflip)\n\t\ty = tpg->compose.height - y - 16;\n\tif (tpg->hflip)\n\t\tx = tpg->compose.width - x - 8;\n\ty += tpg->compose.top;\n\tx += tpg->compose.left;\n\tif (tpg->field == V4L2_FIELD_BOTTOM)\n\t\tfirst = 1;\n\telse if (tpg->field == V4L2_FIELD_SEQ_TB || tpg->field == V4L2_FIELD_SEQ_BT)\n\t\tdiv = 2;\n\n\tfor (p = 0; p < tpg->planes; p++) {\n\t\t \n\t\tswitch (tpg->twopixelsize[p]) {\n\t\tcase 2:\n\t\t\ttpg_print_str_2(tpg, basep, p, first, div, step, y, x,\n\t\t\t\t\ttext, len);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ttpg_print_str_4(tpg, basep, p, first, div, step, y, x,\n\t\t\t\t\ttext, len);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\ttpg_print_str_6(tpg, basep, p, first, div, step, y, x,\n\t\t\t\t\ttext, len);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\ttpg_print_str_8(tpg, basep, p, first, div, step, y, x,\n\t\t\t\t\ttext, len);\n\t\t\tbreak;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(tpg_gen_text);\n\nconst char *tpg_g_color_order(const struct tpg_data *tpg)\n{\n\tswitch (tpg->pattern) {\n\tcase TPG_PAT_75_COLORBAR:\n\tcase TPG_PAT_100_COLORBAR:\n\tcase TPG_PAT_CSC_COLORBAR:\n\tcase TPG_PAT_100_HCOLORBAR:\n\t\treturn \"White, yellow, cyan, green, magenta, red, blue, black\";\n\tcase TPG_PAT_BLACK:\n\t\treturn \"Black\";\n\tcase TPG_PAT_WHITE:\n\t\treturn \"White\";\n\tcase TPG_PAT_RED:\n\t\treturn \"Red\";\n\tcase TPG_PAT_GREEN:\n\t\treturn \"Green\";\n\tcase TPG_PAT_BLUE:\n\t\treturn \"Blue\";\n\tdefault:\n\t\treturn NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(tpg_g_color_order);\n\nvoid tpg_update_mv_step(struct tpg_data *tpg)\n{\n\tint factor = tpg->mv_hor_mode > TPG_MOVE_NONE ? -1 : 1;\n\n\tif (tpg->hflip)\n\t\tfactor = -factor;\n\tswitch (tpg->mv_hor_mode) {\n\tcase TPG_MOVE_NEG_FAST:\n\tcase TPG_MOVE_POS_FAST:\n\t\ttpg->mv_hor_step = ((tpg->src_width + 319) / 320) * 4;\n\t\tbreak;\n\tcase TPG_MOVE_NEG:\n\tcase TPG_MOVE_POS:\n\t\ttpg->mv_hor_step = ((tpg->src_width + 639) / 640) * 4;\n\t\tbreak;\n\tcase TPG_MOVE_NEG_SLOW:\n\tcase TPG_MOVE_POS_SLOW:\n\t\ttpg->mv_hor_step = 2;\n\t\tbreak;\n\tcase TPG_MOVE_NONE:\n\t\ttpg->mv_hor_step = 0;\n\t\tbreak;\n\t}\n\tif (factor < 0)\n\t\ttpg->mv_hor_step = tpg->src_width - tpg->mv_hor_step;\n\n\tfactor = tpg->mv_vert_mode > TPG_MOVE_NONE ? -1 : 1;\n\tswitch (tpg->mv_vert_mode) {\n\tcase TPG_MOVE_NEG_FAST:\n\tcase TPG_MOVE_POS_FAST:\n\t\ttpg->mv_vert_step = ((tpg->src_width + 319) / 320) * 4;\n\t\tbreak;\n\tcase TPG_MOVE_NEG:\n\tcase TPG_MOVE_POS:\n\t\ttpg->mv_vert_step = ((tpg->src_width + 639) / 640) * 4;\n\t\tbreak;\n\tcase TPG_MOVE_NEG_SLOW:\n\tcase TPG_MOVE_POS_SLOW:\n\t\ttpg->mv_vert_step = 1;\n\t\tbreak;\n\tcase TPG_MOVE_NONE:\n\t\ttpg->mv_vert_step = 0;\n\t\tbreak;\n\t}\n\tif (factor < 0)\n\t\ttpg->mv_vert_step = tpg->src_height - tpg->mv_vert_step;\n}\nEXPORT_SYMBOL_GPL(tpg_update_mv_step);\n\n \nstatic unsigned tpg_calc_frameline(const struct tpg_data *tpg, unsigned src_y,\n\t\t\t\t    unsigned field)\n{\n\tswitch (field) {\n\tcase V4L2_FIELD_TOP:\n\t\treturn tpg->crop.top + src_y * 2;\n\tcase V4L2_FIELD_BOTTOM:\n\t\treturn tpg->crop.top + src_y * 2 + 1;\n\tdefault:\n\t\treturn src_y + tpg->crop.top;\n\t}\n}\n\n \nstatic unsigned tpg_calc_buffer_line(const struct tpg_data *tpg, unsigned y,\n\t\t\t\t    unsigned field)\n{\n\ty += tpg->compose.top;\n\tswitch (field) {\n\tcase V4L2_FIELD_SEQ_TB:\n\t\tif (y & 1)\n\t\t\treturn tpg->buf_height / 2 + y / 2;\n\t\treturn y / 2;\n\tcase V4L2_FIELD_SEQ_BT:\n\t\tif (y & 1)\n\t\t\treturn y / 2;\n\t\treturn tpg->buf_height / 2 + y / 2;\n\tdefault:\n\t\treturn y;\n\t}\n}\n\nstatic void tpg_recalc(struct tpg_data *tpg)\n{\n\tif (tpg->recalc_colors) {\n\t\ttpg->recalc_colors = false;\n\t\ttpg->recalc_lines = true;\n\t\ttpg->real_xfer_func = tpg->xfer_func;\n\t\ttpg->real_ycbcr_enc = tpg->ycbcr_enc;\n\t\ttpg->real_hsv_enc = tpg->hsv_enc;\n\t\ttpg->real_quantization = tpg->quantization;\n\n\t\tif (tpg->xfer_func == V4L2_XFER_FUNC_DEFAULT)\n\t\t\ttpg->real_xfer_func =\n\t\t\t\tV4L2_MAP_XFER_FUNC_DEFAULT(tpg->colorspace);\n\n\t\tif (tpg->ycbcr_enc == V4L2_YCBCR_ENC_DEFAULT)\n\t\t\ttpg->real_ycbcr_enc =\n\t\t\t\tV4L2_MAP_YCBCR_ENC_DEFAULT(tpg->colorspace);\n\n\t\tif (tpg->quantization == V4L2_QUANTIZATION_DEFAULT)\n\t\t\ttpg->real_quantization =\n\t\t\t\tV4L2_MAP_QUANTIZATION_DEFAULT(\n\t\t\t\t\ttpg->color_enc != TGP_COLOR_ENC_YCBCR,\n\t\t\t\t\ttpg->colorspace, tpg->real_ycbcr_enc);\n\n\t\ttpg_precalculate_colors(tpg);\n\t}\n\tif (tpg->recalc_square_border) {\n\t\ttpg->recalc_square_border = false;\n\t\ttpg_calculate_square_border(tpg);\n\t}\n\tif (tpg->recalc_lines) {\n\t\ttpg->recalc_lines = false;\n\t\ttpg_precalculate_line(tpg);\n\t}\n}\n\nvoid tpg_calc_text_basep(struct tpg_data *tpg,\n\t\tu8 *basep[TPG_MAX_PLANES][2], unsigned p, u8 *vbuf)\n{\n\tunsigned stride = tpg->bytesperline[p];\n\tunsigned h = tpg->buf_height;\n\n\ttpg_recalc(tpg);\n\n\tbasep[p][0] = vbuf;\n\tbasep[p][1] = vbuf;\n\th /= tpg->vdownsampling[p];\n\tif (tpg->field == V4L2_FIELD_SEQ_TB)\n\t\tbasep[p][1] += h * stride / 2;\n\telse if (tpg->field == V4L2_FIELD_SEQ_BT)\n\t\tbasep[p][0] += h * stride / 2;\n\tif (p == 0 && tpg->interleaved)\n\t\ttpg_calc_text_basep(tpg, basep, 1, vbuf);\n}\nEXPORT_SYMBOL_GPL(tpg_calc_text_basep);\n\nstatic int tpg_pattern_avg(const struct tpg_data *tpg,\n\t\t\t   unsigned pat1, unsigned pat2)\n{\n\tunsigned pat_lines = tpg_get_pat_lines(tpg);\n\n\tif (pat1 == (pat2 + 1) % pat_lines)\n\t\treturn pat2;\n\tif (pat2 == (pat1 + 1) % pat_lines)\n\t\treturn pat1;\n\treturn -1;\n}\n\nstatic const char *tpg_color_enc_str(enum tgp_color_enc\n\t\t\t\t\t\t color_enc)\n{\n\tswitch (color_enc) {\n\tcase TGP_COLOR_ENC_HSV:\n\t\treturn \"HSV\";\n\tcase TGP_COLOR_ENC_YCBCR:\n\t\treturn \"Y'CbCr\";\n\tcase TGP_COLOR_ENC_LUMA:\n\t\treturn \"Luma\";\n\tcase TGP_COLOR_ENC_RGB:\n\tdefault:\n\t\treturn \"R'G'B\";\n\n\t}\n}\n\nvoid tpg_log_status(struct tpg_data *tpg)\n{\n\tpr_info(\"tpg source WxH: %ux%u (%s)\\n\",\n\t\ttpg->src_width, tpg->src_height,\n\t\ttpg_color_enc_str(tpg->color_enc));\n\tpr_info(\"tpg field: %u\\n\", tpg->field);\n\tpr_info(\"tpg crop: %ux%u@%dx%d\\n\", tpg->crop.width, tpg->crop.height,\n\t\t\ttpg->crop.left, tpg->crop.top);\n\tpr_info(\"tpg compose: %ux%u@%dx%d\\n\", tpg->compose.width, tpg->compose.height,\n\t\t\ttpg->compose.left, tpg->compose.top);\n\tpr_info(\"tpg colorspace: %d\\n\", tpg->colorspace);\n\tpr_info(\"tpg transfer function: %d/%d\\n\", tpg->xfer_func, tpg->real_xfer_func);\n\tif (tpg->color_enc == TGP_COLOR_ENC_HSV)\n\t\tpr_info(\"tpg HSV encoding: %d/%d\\n\",\n\t\t\ttpg->hsv_enc, tpg->real_hsv_enc);\n\telse if (tpg->color_enc == TGP_COLOR_ENC_YCBCR)\n\t\tpr_info(\"tpg Y'CbCr encoding: %d/%d\\n\",\n\t\t\ttpg->ycbcr_enc, tpg->real_ycbcr_enc);\n\tpr_info(\"tpg quantization: %d/%d\\n\", tpg->quantization, tpg->real_quantization);\n\tpr_info(\"tpg RGB range: %d/%d\\n\", tpg->rgb_range, tpg->real_rgb_range);\n}\nEXPORT_SYMBOL_GPL(tpg_log_status);\n\n \nstruct tpg_draw_params {\n\t \n\tbool is_tv;\n\tbool is_60hz;\n\tunsigned twopixsize;\n\tunsigned img_width;\n\tunsigned stride;\n\tunsigned hmax;\n\tunsigned frame_line;\n\tunsigned frame_line_next;\n\n\t \n\tunsigned mv_hor_old;\n\tunsigned mv_hor_new;\n\tunsigned mv_vert_old;\n\tunsigned mv_vert_new;\n\n\t \n\tunsigned wss_width;\n\tunsigned wss_random_offset;\n\tunsigned sav_eav_f;\n\tunsigned left_pillar_width;\n\tunsigned right_pillar_start;\n};\n\nstatic void tpg_fill_params_pattern(const struct tpg_data *tpg, unsigned p,\n\t\t\t\t    struct tpg_draw_params *params)\n{\n\tparams->mv_hor_old =\n\t\ttpg_hscale_div(tpg, p, tpg->mv_hor_count % tpg->src_width);\n\tparams->mv_hor_new =\n\t\ttpg_hscale_div(tpg, p, (tpg->mv_hor_count + tpg->mv_hor_step) %\n\t\t\t       tpg->src_width);\n\tparams->mv_vert_old = tpg->mv_vert_count % tpg->src_height;\n\tparams->mv_vert_new =\n\t\t(tpg->mv_vert_count + tpg->mv_vert_step) % tpg->src_height;\n}\n\nstatic void tpg_fill_params_extras(const struct tpg_data *tpg,\n\t\t\t\t   unsigned p,\n\t\t\t\t   struct tpg_draw_params *params)\n{\n\tunsigned left_pillar_width = 0;\n\tunsigned right_pillar_start = params->img_width;\n\n\tparams->wss_width = tpg->crop.left < tpg->src_width / 2 ?\n\t\ttpg->src_width / 2 - tpg->crop.left : 0;\n\tif (params->wss_width > tpg->crop.width)\n\t\tparams->wss_width = tpg->crop.width;\n\tparams->wss_width = tpg_hscale_div(tpg, p, params->wss_width);\n\tparams->wss_random_offset =\n\t\tparams->twopixsize * get_random_u32_below(tpg->src_width / 2);\n\n\tif (tpg->crop.left < tpg->border.left) {\n\t\tleft_pillar_width = tpg->border.left - tpg->crop.left;\n\t\tif (left_pillar_width > tpg->crop.width)\n\t\t\tleft_pillar_width = tpg->crop.width;\n\t\tleft_pillar_width = tpg_hscale_div(tpg, p, left_pillar_width);\n\t}\n\tparams->left_pillar_width = left_pillar_width;\n\n\tif (tpg->crop.left + tpg->crop.width >\n\t    tpg->border.left + tpg->border.width) {\n\t\tright_pillar_start =\n\t\t\ttpg->border.left + tpg->border.width - tpg->crop.left;\n\t\tright_pillar_start =\n\t\t\ttpg_hscale_div(tpg, p, right_pillar_start);\n\t\tif (right_pillar_start > params->img_width)\n\t\t\tright_pillar_start = params->img_width;\n\t}\n\tparams->right_pillar_start = right_pillar_start;\n\n\tparams->sav_eav_f = tpg->field ==\n\t\t\t(params->is_60hz ? V4L2_FIELD_TOP : V4L2_FIELD_BOTTOM);\n}\n\nstatic void tpg_fill_plane_extras(const struct tpg_data *tpg,\n\t\t\t\t  const struct tpg_draw_params *params,\n\t\t\t\t  unsigned p, unsigned h, u8 *vbuf)\n{\n\tunsigned twopixsize = params->twopixsize;\n\tunsigned img_width = params->img_width;\n\tunsigned frame_line = params->frame_line;\n\tconst struct v4l2_rect *sq = &tpg->square;\n\tconst struct v4l2_rect *b = &tpg->border;\n\tconst struct v4l2_rect *c = &tpg->crop;\n\n\tif (params->is_tv && !params->is_60hz &&\n\t    frame_line == 0 && params->wss_width) {\n\t\t \n\t\tu8 *wss = tpg->random_line[p] + params->wss_random_offset;\n\n\t\tmemcpy(vbuf, wss, params->wss_width);\n\t}\n\n\tif (tpg->show_border && frame_line >= b->top &&\n\t    frame_line < b->top + b->height) {\n\t\tunsigned bottom = b->top + b->height - 1;\n\t\tunsigned left = params->left_pillar_width;\n\t\tunsigned right = params->right_pillar_start;\n\n\t\tif (frame_line == b->top || frame_line == b->top + 1 ||\n\t\t    frame_line == bottom || frame_line == bottom - 1) {\n\t\t\tmemcpy(vbuf + left, tpg->contrast_line[p],\n\t\t\t\t\tright - left);\n\t\t} else {\n\t\t\tif (b->left >= c->left &&\n\t\t\t    b->left < c->left + c->width)\n\t\t\t\tmemcpy(vbuf + left,\n\t\t\t\t\ttpg->contrast_line[p], twopixsize);\n\t\t\tif (b->left + b->width > c->left &&\n\t\t\t    b->left + b->width <= c->left + c->width)\n\t\t\t\tmemcpy(vbuf + right - twopixsize,\n\t\t\t\t\ttpg->contrast_line[p], twopixsize);\n\t\t}\n\t}\n\tif (tpg->qual != TPG_QUAL_NOISE && frame_line >= b->top &&\n\t    frame_line < b->top + b->height) {\n\t\tmemcpy(vbuf, tpg->black_line[p], params->left_pillar_width);\n\t\tmemcpy(vbuf + params->right_pillar_start, tpg->black_line[p],\n\t\t       img_width - params->right_pillar_start);\n\t}\n\tif (tpg->show_square && frame_line >= sq->top &&\n\t    frame_line < sq->top + sq->height &&\n\t    sq->left < c->left + c->width &&\n\t    sq->left + sq->width >= c->left) {\n\t\tunsigned left = sq->left;\n\t\tunsigned width = sq->width;\n\n\t\tif (c->left > left) {\n\t\t\twidth -= c->left - left;\n\t\t\tleft = c->left;\n\t\t}\n\t\tif (c->left + c->width < left + width)\n\t\t\twidth -= left + width - c->left - c->width;\n\t\tleft -= c->left;\n\t\tleft = tpg_hscale_div(tpg, p, left);\n\t\twidth = tpg_hscale_div(tpg, p, width);\n\t\tmemcpy(vbuf + left, tpg->contrast_line[p], width);\n\t}\n\tif (tpg->insert_sav) {\n\t\tunsigned offset = tpg_hdiv(tpg, p, tpg->compose.width / 3);\n\t\tu8 *p = vbuf + offset;\n\t\tunsigned vact = 0, hact = 0;\n\n\t\tp[0] = 0xff;\n\t\tp[1] = 0;\n\t\tp[2] = 0;\n\t\tp[3] = 0x80 | (params->sav_eav_f << 6) |\n\t\t\t(vact << 5) | (hact << 4) |\n\t\t\t((hact ^ vact) << 3) |\n\t\t\t((hact ^ params->sav_eav_f) << 2) |\n\t\t\t((params->sav_eav_f ^ vact) << 1) |\n\t\t\t(hact ^ vact ^ params->sav_eav_f);\n\t}\n\tif (tpg->insert_eav) {\n\t\tunsigned offset = tpg_hdiv(tpg, p, tpg->compose.width * 2 / 3);\n\t\tu8 *p = vbuf + offset;\n\t\tunsigned vact = 0, hact = 1;\n\n\t\tp[0] = 0xff;\n\t\tp[1] = 0;\n\t\tp[2] = 0;\n\t\tp[3] = 0x80 | (params->sav_eav_f << 6) |\n\t\t\t(vact << 5) | (hact << 4) |\n\t\t\t((hact ^ vact) << 3) |\n\t\t\t((hact ^ params->sav_eav_f) << 2) |\n\t\t\t((params->sav_eav_f ^ vact) << 1) |\n\t\t\t(hact ^ vact ^ params->sav_eav_f);\n\t}\n\tif (tpg->insert_hdmi_video_guard_band) {\n\t\tunsigned int i;\n\n\t\tswitch (tpg->fourcc) {\n\t\tcase V4L2_PIX_FMT_BGR24:\n\t\tcase V4L2_PIX_FMT_RGB24:\n\t\t\tfor (i = 0; i < 3 * 4; i += 3) {\n\t\t\t\tvbuf[i] = 0xab;\n\t\t\t\tvbuf[i + 1] = 0x55;\n\t\t\t\tvbuf[i + 2] = 0xab;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase V4L2_PIX_FMT_RGB32:\n\t\tcase V4L2_PIX_FMT_ARGB32:\n\t\tcase V4L2_PIX_FMT_XRGB32:\n\t\tcase V4L2_PIX_FMT_BGRX32:\n\t\tcase V4L2_PIX_FMT_BGRA32:\n\t\t\tfor (i = 0; i < 4 * 4; i += 4) {\n\t\t\t\tvbuf[i] = 0x00;\n\t\t\t\tvbuf[i + 1] = 0xab;\n\t\t\t\tvbuf[i + 2] = 0x55;\n\t\t\t\tvbuf[i + 3] = 0xab;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase V4L2_PIX_FMT_BGR32:\n\t\tcase V4L2_PIX_FMT_XBGR32:\n\t\tcase V4L2_PIX_FMT_ABGR32:\n\t\tcase V4L2_PIX_FMT_RGBX32:\n\t\tcase V4L2_PIX_FMT_RGBA32:\n\t\t\tfor (i = 0; i < 4 * 4; i += 4) {\n\t\t\t\tvbuf[i] = 0xab;\n\t\t\t\tvbuf[i + 1] = 0x55;\n\t\t\t\tvbuf[i + 2] = 0xab;\n\t\t\t\tvbuf[i + 3] = 0x00;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void tpg_fill_plane_pattern(const struct tpg_data *tpg,\n\t\t\t\t   const struct tpg_draw_params *params,\n\t\t\t\t   unsigned p, unsigned h, u8 *vbuf)\n{\n\tunsigned twopixsize = params->twopixsize;\n\tunsigned img_width = params->img_width;\n\tunsigned mv_hor_old = params->mv_hor_old;\n\tunsigned mv_hor_new = params->mv_hor_new;\n\tunsigned mv_vert_old = params->mv_vert_old;\n\tunsigned mv_vert_new = params->mv_vert_new;\n\tunsigned frame_line = params->frame_line;\n\tunsigned frame_line_next = params->frame_line_next;\n\tunsigned line_offset = tpg_hscale_div(tpg, p, tpg->crop.left);\n\tbool even;\n\tbool fill_blank = false;\n\tunsigned pat_line_old;\n\tunsigned pat_line_new;\n\tu8 *linestart_older;\n\tu8 *linestart_newer;\n\tu8 *linestart_top;\n\tu8 *linestart_bottom;\n\n\teven = !(frame_line & 1);\n\n\tif (h >= params->hmax) {\n\t\tif (params->hmax == tpg->compose.height)\n\t\t\treturn;\n\t\tif (!tpg->perc_fill_blank)\n\t\t\treturn;\n\t\tfill_blank = true;\n\t}\n\n\tif (tpg->vflip) {\n\t\tframe_line = tpg->src_height - frame_line - 1;\n\t\tframe_line_next = tpg->src_height - frame_line_next - 1;\n\t}\n\n\tif (fill_blank) {\n\t\tlinestart_older = tpg->contrast_line[p];\n\t\tlinestart_newer = tpg->contrast_line[p];\n\t} else if (tpg->qual != TPG_QUAL_NOISE &&\n\t\t   (frame_line < tpg->border.top ||\n\t\t    frame_line >= tpg->border.top + tpg->border.height)) {\n\t\tlinestart_older = tpg->black_line[p];\n\t\tlinestart_newer = tpg->black_line[p];\n\t} else if (tpg->pattern == TPG_PAT_NOISE || tpg->qual == TPG_QUAL_NOISE) {\n\t\tlinestart_older = tpg->random_line[p] +\n\t\t\t\t  twopixsize * get_random_u32_below(tpg->src_width / 2);\n\t\tlinestart_newer = tpg->random_line[p] +\n\t\t\t\t  twopixsize * get_random_u32_below(tpg->src_width / 2);\n\t} else {\n\t\tunsigned frame_line_old =\n\t\t\t(frame_line + mv_vert_old) % tpg->src_height;\n\t\tunsigned frame_line_new =\n\t\t\t(frame_line + mv_vert_new) % tpg->src_height;\n\t\tunsigned pat_line_next_old;\n\t\tunsigned pat_line_next_new;\n\n\t\tpat_line_old = tpg_get_pat_line(tpg, frame_line_old);\n\t\tpat_line_new = tpg_get_pat_line(tpg, frame_line_new);\n\t\tlinestart_older = tpg->lines[pat_line_old][p] + mv_hor_old;\n\t\tlinestart_newer = tpg->lines[pat_line_new][p] + mv_hor_new;\n\n\t\tif (tpg->vdownsampling[p] > 1 && frame_line != frame_line_next) {\n\t\t\tint avg_pat;\n\n\t\t\t \n\t\t\tpat_line_next_old = tpg_get_pat_line(tpg,\n\t\t\t\t\t(frame_line_next + mv_vert_old) % tpg->src_height);\n\t\t\tpat_line_next_new = tpg_get_pat_line(tpg,\n\t\t\t\t\t(frame_line_next + mv_vert_new) % tpg->src_height);\n\n\t\t\tswitch (tpg->field) {\n\t\t\tcase V4L2_FIELD_INTERLACED:\n\t\t\tcase V4L2_FIELD_INTERLACED_BT:\n\t\t\tcase V4L2_FIELD_INTERLACED_TB:\n\t\t\t\tavg_pat = tpg_pattern_avg(tpg, pat_line_old, pat_line_new);\n\t\t\t\tif (avg_pat < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tlinestart_older = tpg->downsampled_lines[avg_pat][p] + mv_hor_old;\n\t\t\t\tlinestart_newer = linestart_older;\n\t\t\t\tbreak;\n\t\t\tcase V4L2_FIELD_NONE:\n\t\t\tcase V4L2_FIELD_TOP:\n\t\t\tcase V4L2_FIELD_BOTTOM:\n\t\t\tcase V4L2_FIELD_SEQ_BT:\n\t\t\tcase V4L2_FIELD_SEQ_TB:\n\t\t\t\tavg_pat = tpg_pattern_avg(tpg, pat_line_old, pat_line_next_old);\n\t\t\t\tif (avg_pat >= 0)\n\t\t\t\t\tlinestart_older = tpg->downsampled_lines[avg_pat][p] +\n\t\t\t\t\t\tmv_hor_old;\n\t\t\t\tavg_pat = tpg_pattern_avg(tpg, pat_line_new, pat_line_next_new);\n\t\t\t\tif (avg_pat >= 0)\n\t\t\t\t\tlinestart_newer = tpg->downsampled_lines[avg_pat][p] +\n\t\t\t\t\t\tmv_hor_new;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlinestart_older += line_offset;\n\t\tlinestart_newer += line_offset;\n\t}\n\tif (tpg->field_alternate) {\n\t\tlinestart_top = linestart_bottom = linestart_older;\n\t} else if (params->is_60hz) {\n\t\tlinestart_top = linestart_newer;\n\t\tlinestart_bottom = linestart_older;\n\t} else {\n\t\tlinestart_top = linestart_older;\n\t\tlinestart_bottom = linestart_newer;\n\t}\n\n\tswitch (tpg->field) {\n\tcase V4L2_FIELD_INTERLACED:\n\tcase V4L2_FIELD_INTERLACED_TB:\n\tcase V4L2_FIELD_SEQ_TB:\n\tcase V4L2_FIELD_SEQ_BT:\n\t\tif (even)\n\t\t\tmemcpy(vbuf, linestart_top, img_width);\n\t\telse\n\t\t\tmemcpy(vbuf, linestart_bottom, img_width);\n\t\tbreak;\n\tcase V4L2_FIELD_INTERLACED_BT:\n\t\tif (even)\n\t\t\tmemcpy(vbuf, linestart_bottom, img_width);\n\t\telse\n\t\t\tmemcpy(vbuf, linestart_top, img_width);\n\t\tbreak;\n\tcase V4L2_FIELD_TOP:\n\t\tmemcpy(vbuf, linestart_top, img_width);\n\t\tbreak;\n\tcase V4L2_FIELD_BOTTOM:\n\t\tmemcpy(vbuf, linestart_bottom, img_width);\n\t\tbreak;\n\tcase V4L2_FIELD_NONE:\n\tdefault:\n\t\tmemcpy(vbuf, linestart_older, img_width);\n\t\tbreak;\n\t}\n}\n\nvoid tpg_fill_plane_buffer(struct tpg_data *tpg, v4l2_std_id std,\n\t\t\t   unsigned p, u8 *vbuf)\n{\n\tstruct tpg_draw_params params;\n\tunsigned factor = V4L2_FIELD_HAS_T_OR_B(tpg->field) ? 2 : 1;\n\n\t \n\tunsigned int_part = (tpg->crop.height / factor) / tpg->compose.height;\n\tunsigned fract_part = (tpg->crop.height / factor) % tpg->compose.height;\n\tunsigned src_y = 0;\n\tunsigned error = 0;\n\tunsigned h;\n\n\ttpg_recalc(tpg);\n\n\tparams.is_tv = std;\n\tparams.is_60hz = std & V4L2_STD_525_60;\n\tparams.twopixsize = tpg->twopixelsize[p];\n\tparams.img_width = tpg_hdiv(tpg, p, tpg->compose.width);\n\tparams.stride = tpg->bytesperline[p];\n\tparams.hmax = (tpg->compose.height * tpg->perc_fill) / 100;\n\n\ttpg_fill_params_pattern(tpg, p, &params);\n\ttpg_fill_params_extras(tpg, p, &params);\n\n\tvbuf += tpg_hdiv(tpg, p, tpg->compose.left);\n\n\tfor (h = 0; h < tpg->compose.height; h++) {\n\t\tunsigned buf_line;\n\n\t\tparams.frame_line = tpg_calc_frameline(tpg, src_y, tpg->field);\n\t\tparams.frame_line_next = params.frame_line;\n\t\tbuf_line = tpg_calc_buffer_line(tpg, h, tpg->field);\n\t\tsrc_y += int_part;\n\t\terror += fract_part;\n\t\tif (error >= tpg->compose.height) {\n\t\t\terror -= tpg->compose.height;\n\t\t\tsrc_y++;\n\t\t}\n\n\t\t \n\t\tif (tpg_g_interleaved(tpg))\n\t\t\tp = tpg_g_interleaved_plane(tpg, buf_line);\n\n\t\tif (tpg->vdownsampling[p] > 1) {\n\t\t\t \n\t\t\tif (tpg->field == V4L2_FIELD_SEQ_BT ||\n\t\t\t    tpg->field == V4L2_FIELD_SEQ_TB) {\n\t\t\t\tunsigned next_src_y = src_y;\n\n\t\t\t\tif ((h & 3) >= 2)\n\t\t\t\t\tcontinue;\n\t\t\t\tnext_src_y += int_part;\n\t\t\t\tif (error + fract_part >= tpg->compose.height)\n\t\t\t\t\tnext_src_y++;\n\t\t\t\tparams.frame_line_next =\n\t\t\t\t\ttpg_calc_frameline(tpg, next_src_y, tpg->field);\n\t\t\t} else {\n\t\t\t\tif (h & 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tparams.frame_line_next =\n\t\t\t\t\ttpg_calc_frameline(tpg, src_y, tpg->field);\n\t\t\t}\n\n\t\t\tbuf_line /= tpg->vdownsampling[p];\n\t\t}\n\t\ttpg_fill_plane_pattern(tpg, &params, p, h,\n\t\t\t\tvbuf + buf_line * params.stride);\n\t\ttpg_fill_plane_extras(tpg, &params, p, h,\n\t\t\t\tvbuf + buf_line * params.stride);\n\t}\n}\nEXPORT_SYMBOL_GPL(tpg_fill_plane_buffer);\n\nvoid tpg_fillbuffer(struct tpg_data *tpg, v4l2_std_id std, unsigned p, u8 *vbuf)\n{\n\tunsigned offset = 0;\n\tunsigned i;\n\n\tif (tpg->buffers > 1) {\n\t\ttpg_fill_plane_buffer(tpg, std, p, vbuf);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < tpg_g_planes(tpg); i++) {\n\t\ttpg_fill_plane_buffer(tpg, std, i, vbuf + offset);\n\t\toffset += tpg_calc_plane_size(tpg, i);\n\t}\n}\nEXPORT_SYMBOL_GPL(tpg_fillbuffer);\n\nMODULE_DESCRIPTION(\"V4L2 Test Pattern Generator\");\nMODULE_AUTHOR(\"Hans Verkuil\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}