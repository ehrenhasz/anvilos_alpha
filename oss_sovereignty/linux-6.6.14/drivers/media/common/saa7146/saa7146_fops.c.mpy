{
  "module_name": "saa7146_fops.c",
  "hash_id": "a9e12cdec15f8f54a582620e1f8d30fd1ed59a5612ec604d1c71e2975b514235",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/saa7146/saa7146_fops.c",
  "human_readable_source": "\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <media/drv-intf/saa7146_vv.h>\n#include <linux/module.h>\n\n \n \n\nint saa7146_res_get(struct saa7146_dev *dev, unsigned int bit)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\n\tif (vv->resources & bit) {\n\t\tDEB_D(\"already allocated! want: 0x%02x, cur:0x%02x\\n\",\n\t\t      bit, vv->resources);\n\t\t \n\t\treturn 1;\n\t}\n\n\t \n\tif (vv->resources & bit) {\n\t\tDEB_D(\"locked! vv->resources:0x%02x, we want:0x%02x\\n\",\n\t\t      vv->resources, bit);\n\t\t \n\t\treturn 0;\n\t}\n\t \n\tvv->resources |= bit;\n\tDEB_D(\"res: get 0x%02x, cur:0x%02x\\n\", bit, vv->resources);\n\treturn 1;\n}\n\nvoid saa7146_res_free(struct saa7146_dev *dev, unsigned int bits)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\n\tWARN_ON((vv->resources & bits) != bits);\n\n\tvv->resources &= ~bits;\n\tDEB_D(\"res: put 0x%02x, cur:0x%02x\\n\", bits, vv->resources);\n}\n\n\n \n \n\nint saa7146_buffer_queue(struct saa7146_dev *dev,\n\t\t\t struct saa7146_dmaqueue *q,\n\t\t\t struct saa7146_buf *buf)\n{\n\tassert_spin_locked(&dev->slock);\n\tDEB_EE(\"dev:%p, dmaq:%p, buf:%p\\n\", dev, q, buf);\n\n\tif (WARN_ON(!q))\n\t\treturn -EIO;\n\n\tif (NULL == q->curr) {\n\t\tq->curr = buf;\n\t\tDEB_D(\"immediately activating buffer %p\\n\", buf);\n\t\tbuf->activate(dev,buf,NULL);\n\t} else {\n\t\tlist_add_tail(&buf->list, &q->queue);\n\t\tDEB_D(\"adding buffer %p to queue. (active buffer present)\\n\",\n\t\t      buf);\n\t}\n\treturn 0;\n}\n\nvoid saa7146_buffer_finish(struct saa7146_dev *dev,\n\t\t\t   struct saa7146_dmaqueue *q,\n\t\t\t   int state)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\tstruct saa7146_buf *buf = q->curr;\n\n\tassert_spin_locked(&dev->slock);\n\tDEB_EE(\"dev:%p, dmaq:%p, state:%d\\n\", dev, q, state);\n\tDEB_EE(\"q->curr:%p\\n\", q->curr);\n\n\t \n\tif (!buf) {\n\t\tDEB_D(\"aiii. no current buffer\\n\");\n\t\treturn;\n\t}\n\n\tq->curr = NULL;\n\tbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\tif (vv->video_fmt.field == V4L2_FIELD_ALTERNATE)\n\t\tbuf->vb.field = vv->last_field;\n\telse if (vv->video_fmt.field == V4L2_FIELD_ANY)\n\t\tbuf->vb.field = (vv->video_fmt.height > vv->standard->v_max_out / 2)\n\t\t\t? V4L2_FIELD_INTERLACED\n\t\t\t: V4L2_FIELD_BOTTOM;\n\telse\n\t\tbuf->vb.field = vv->video_fmt.field;\n\tbuf->vb.sequence = vv->seqnr++;\n\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n}\n\nvoid saa7146_buffer_next(struct saa7146_dev *dev,\n\t\t\t struct saa7146_dmaqueue *q, int vbi)\n{\n\tstruct saa7146_buf *buf,*next = NULL;\n\n\tif (WARN_ON(!q))\n\t\treturn;\n\n\tDEB_INT(\"dev:%p, dmaq:%p, vbi:%d\\n\", dev, q, vbi);\n\n\tassert_spin_locked(&dev->slock);\n\tif (!list_empty(&q->queue)) {\n\t\t \n\t\tbuf = list_entry(q->queue.next, struct saa7146_buf, list);\n\t\tlist_del(&buf->list);\n\t\tif (!list_empty(&q->queue))\n\t\t\tnext = list_entry(q->queue.next, struct saa7146_buf, list);\n\t\tq->curr = buf;\n\t\tDEB_INT(\"next buffer: buf:%p, prev:%p, next:%p\\n\",\n\t\t\tbuf, q->queue.prev, q->queue.next);\n\t\tbuf->activate(dev,buf,next);\n\t} else {\n\t\tDEB_INT(\"no next buffer. stopping.\\n\");\n\t\tif( 0 != vbi ) {\n\t\t\t \n\t\t\tsaa7146_write(dev,MC1, MASK_20);\n\t\t} else {\n\t\t\t \n\n\t\t\t \n\n\t\t\tsaa7146_write(dev, PROT_ADDR1, 0);\n\t\t\tsaa7146_write(dev, MC2, (MASK_02|MASK_18));\n\n\t\t\t \n\t\t\tsaa7146_write(dev, RPS_ADDR0, dev->d_rps0.dma_handle);\n\t\t\t \n\t\t\tsaa7146_write(dev, MC1, (MASK_12 | MASK_28));\n\n \n\t\t}\n\t\tdel_timer(&q->timeout);\n\t}\n}\n\nvoid saa7146_buffer_timeout(struct timer_list *t)\n{\n\tstruct saa7146_dmaqueue *q = from_timer(q, t, timeout);\n\tstruct saa7146_dev *dev = q->dev;\n\tunsigned long flags;\n\n\tDEB_EE(\"dev:%p, dmaq:%p\\n\", dev, q);\n\n\tspin_lock_irqsave(&dev->slock,flags);\n\tif (q->curr) {\n\t\tDEB_D(\"timeout on %p\\n\", q->curr);\n\t\tsaa7146_buffer_finish(dev, q, VB2_BUF_STATE_ERROR);\n\t}\n\n\t \n\n\tsaa7146_buffer_next(dev, q, 0);\n\n\tspin_unlock_irqrestore(&dev->slock,flags);\n}\n\n \n \n\nstatic ssize_t fops_write(struct file *file, const char __user *data, size_t count, loff_t *ppos)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tint ret;\n\n\tif (vdev->vfl_type != VFL_TYPE_VBI || !dev->ext_vv_data->vbi_fops.write)\n\t\treturn -EINVAL;\n\tif (mutex_lock_interruptible(vdev->lock))\n\t\treturn -ERESTARTSYS;\n\tret = dev->ext_vv_data->vbi_fops.write(file, data, count, ppos);\n\tmutex_unlock(vdev->lock);\n\treturn ret;\n}\n\nstatic const struct v4l2_file_operations video_fops =\n{\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= v4l2_fh_open,\n\t.release\t= vb2_fop_release,\n\t.read\t\t= vb2_fop_read,\n\t.write\t\t= fops_write,\n\t.poll\t\t= vb2_fop_poll,\n\t.mmap\t\t= vb2_fop_mmap,\n\t.unlocked_ioctl\t= video_ioctl2,\n};\n\nstatic void vv_callback(struct saa7146_dev *dev, unsigned long status)\n{\n\tu32 isr = status;\n\n\tDEB_INT(\"dev:%p, isr:0x%08x\\n\", dev, (u32)status);\n\n\tif (0 != (isr & (MASK_27))) {\n\t\tDEB_INT(\"irq: RPS0 (0x%08x)\\n\", isr);\n\t\tsaa7146_video_uops.irq_done(dev,isr);\n\t}\n\n\tif (0 != (isr & (MASK_28))) {\n\t\tu32 mc2 = saa7146_read(dev, MC2);\n\t\tif( 0 != (mc2 & MASK_15)) {\n\t\t\tDEB_INT(\"irq: RPS1 vbi workaround (0x%08x)\\n\", isr);\n\t\t\twake_up(&dev->vv_data->vbi_wq);\n\t\t\tsaa7146_write(dev,MC2, MASK_31);\n\t\t\treturn;\n\t\t}\n\t\tDEB_INT(\"irq: RPS1 (0x%08x)\\n\", isr);\n\t\tsaa7146_vbi_uops.irq_done(dev,isr);\n\t}\n}\n\nstatic const struct v4l2_ctrl_ops saa7146_ctrl_ops = {\n\t.s_ctrl = saa7146_s_ctrl,\n};\n\nint saa7146_vv_init(struct saa7146_dev* dev, struct saa7146_ext_vv *ext_vv)\n{\n\tstruct v4l2_ctrl_handler *hdl = &dev->ctrl_handler;\n\tstruct v4l2_pix_format *fmt;\n\tstruct v4l2_vbi_format *vbi;\n\tstruct saa7146_vv *vv;\n\tint err;\n\n\terr = v4l2_device_register(&dev->pci->dev, &dev->v4l2_dev);\n\tif (err)\n\t\treturn err;\n\n\tv4l2_ctrl_handler_init(hdl, 6);\n\tv4l2_ctrl_new_std(hdl, &saa7146_ctrl_ops,\n\t\tV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(hdl, &saa7146_ctrl_ops,\n\t\tV4L2_CID_CONTRAST, 0, 127, 1, 64);\n\tv4l2_ctrl_new_std(hdl, &saa7146_ctrl_ops,\n\t\tV4L2_CID_SATURATION, 0, 127, 1, 64);\n\tv4l2_ctrl_new_std(hdl, &saa7146_ctrl_ops,\n\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &saa7146_ctrl_ops,\n\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\tif (hdl->error) {\n\t\terr = hdl->error;\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\tv4l2_device_unregister(&dev->v4l2_dev);\n\t\treturn err;\n\t}\n\tdev->v4l2_dev.ctrl_handler = hdl;\n\n\tvv = kzalloc(sizeof(struct saa7146_vv), GFP_KERNEL);\n\tif (vv == NULL) {\n\t\tERR(\"out of memory. aborting.\\n\");\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\tv4l2_device_unregister(&dev->v4l2_dev);\n\t\treturn -ENOMEM;\n\t}\n\text_vv->vid_ops = saa7146_video_ioctl_ops;\n\text_vv->vbi_ops = saa7146_vbi_ioctl_ops;\n\text_vv->core_ops = &saa7146_video_ioctl_ops;\n\n\tDEB_EE(\"dev:%p\\n\", dev);\n\n\t \n\tsaa7146_write(dev, BCS_CTRL, 0x80400040);\n\n\t \n\tsaa7146_write(dev, MC1, (MASK_10 | MASK_26));\n\n\t \n\tdev->ext_vv_data = ext_vv;\n\n\tsaa7146_video_uops.init(dev,vv);\n\tif (dev->ext_vv_data->capabilities & V4L2_CAP_VBI_CAPTURE)\n\t\tsaa7146_vbi_uops.init(dev,vv);\n\n\tfmt = &vv->video_fmt;\n\tfmt->width = 384;\n\tfmt->height = 288;\n\tfmt->pixelformat = V4L2_PIX_FMT_BGR24;\n\tfmt->field = V4L2_FIELD_INTERLACED;\n\tfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tfmt->bytesperline = 3 * fmt->width;\n\tfmt->sizeimage = fmt->bytesperline * fmt->height;\n\n\tvbi = &vv->vbi_fmt;\n\tvbi->sampling_rate\t= 27000000;\n\tvbi->offset\t\t= 248;  \n\tvbi->samples_per_line\t= 720 * 2;\n\tvbi->sample_format\t= V4L2_PIX_FMT_GREY;\n\n\t \n\tvbi->start[0] = 5;\n\tvbi->count[0] = 16;\n\tvbi->start[1] = 312;\n\tvbi->count[1] = 16;\n\n\ttimer_setup(&vv->vbi_read_timeout, NULL, 0);\n\n\tdev->vv_data = vv;\n\tdev->vv_callback = &vv_callback;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(saa7146_vv_init);\n\nint saa7146_vv_release(struct saa7146_dev* dev)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\n\tDEB_EE(\"dev:%p\\n\", dev);\n\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\n\tkfree(vv);\n\tdev->vv_data = NULL;\n\tdev->vv_callback = NULL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(saa7146_vv_release);\n\nint saa7146_register_device(struct video_device *vfd, struct saa7146_dev *dev,\n\t\t\t    char *name, int type)\n{\n\tstruct vb2_queue *q;\n\tint err;\n\tint i;\n\n\tDEB_EE(\"dev:%p, name:'%s', type:%d\\n\", dev, name, type);\n\n\tvfd->fops = &video_fops;\n\tif (type == VFL_TYPE_VIDEO) {\n\t\tvfd->ioctl_ops = &dev->ext_vv_data->vid_ops;\n\t\tq = &dev->vv_data->video_dmaq.q;\n\t} else {\n\t\tvfd->ioctl_ops = &dev->ext_vv_data->vbi_ops;\n\t\tq = &dev->vv_data->vbi_dmaq.q;\n\t}\n\tvfd->release = video_device_release_empty;\n\tvfd->lock = &dev->v4l2_lock;\n\tvfd->v4l2_dev = &dev->v4l2_dev;\n\tvfd->tvnorms = 0;\n\tfor (i = 0; i < dev->ext_vv_data->num_stds; i++)\n\t\tvfd->tvnorms |= dev->ext_vv_data->stds[i].id;\n\tstrscpy(vfd->name, name, sizeof(vfd->name));\n\tvfd->device_caps = V4L2_CAP_VIDEO_CAPTURE |\n\t\t\t   V4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\n\tvfd->device_caps |= dev->ext_vv_data->capabilities;\n\tif (type == VFL_TYPE_VIDEO) {\n\t\tvfd->device_caps &=\n\t\t\t~(V4L2_CAP_VBI_CAPTURE | V4L2_CAP_SLICED_VBI_OUTPUT);\n\t} else if (vfd->device_caps & V4L2_CAP_SLICED_VBI_OUTPUT) {\n\t\tvfd->vfl_dir = VFL_DIR_TX;\n\t\tvfd->device_caps &= ~(V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |\n\t\t\t\t      V4L2_CAP_AUDIO | V4L2_CAP_TUNER);\n\t} else {\n\t\tvfd->device_caps &= ~V4L2_CAP_VIDEO_CAPTURE;\n\t}\n\n\tq->type = type == VFL_TYPE_VIDEO ? V4L2_BUF_TYPE_VIDEO_CAPTURE : V4L2_BUF_TYPE_VBI_CAPTURE;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->io_modes = VB2_MMAP | VB2_READ | VB2_DMABUF;\n\tq->ops = type == VFL_TYPE_VIDEO ? &video_qops : &vbi_qops;\n\tq->mem_ops = &vb2_dma_sg_memops;\n\tq->drv_priv = dev;\n\tq->gfp_flags = __GFP_DMA32;\n\tq->buf_struct_size = sizeof(struct saa7146_buf);\n\tq->lock = &dev->v4l2_lock;\n\tq->min_buffers_needed = 2;\n\tq->dev = &dev->pci->dev;\n\terr = vb2_queue_init(q);\n\tif (err)\n\t\treturn err;\n\tvfd->queue = q;\n\n\tvideo_set_drvdata(vfd, dev);\n\n\terr = video_register_device(vfd, type, -1);\n\tif (err < 0) {\n\t\tERR(\"cannot register v4l2 device. skipping.\\n\");\n\t\treturn err;\n\t}\n\n\tpr_info(\"%s: registered device %s [v4l2]\\n\",\n\t\tdev->name, video_device_node_name(vfd));\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(saa7146_register_device);\n\nint saa7146_unregister_device(struct video_device *vfd, struct saa7146_dev *dev)\n{\n\tDEB_EE(\"dev:%p\\n\", dev);\n\n\tvideo_unregister_device(vfd);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(saa7146_unregister_device);\n\nstatic int __init saa7146_vv_init_module(void)\n{\n\treturn 0;\n}\n\n\nstatic void __exit saa7146_vv_cleanup_module(void)\n{\n}\n\nmodule_init(saa7146_vv_init_module);\nmodule_exit(saa7146_vv_cleanup_module);\n\nMODULE_AUTHOR(\"Michael Hunold <michael@mihu.de>\");\nMODULE_DESCRIPTION(\"video4linux driver for saa7146-based hardware\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}