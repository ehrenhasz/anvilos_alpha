{
  "module_name": "saa7146_i2c.c",
  "hash_id": "bbe709e9732cc76d78cb30f70a758684cf223e81e92b72ce53cdabc933eb7f35",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/saa7146/saa7146_i2c.c",
  "human_readable_source": "\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <media/drv-intf/saa7146_vv.h>\n\nstatic u32 saa7146_i2c_func(struct i2c_adapter *adapter)\n{\n\t \n\n\treturn\t  I2C_FUNC_I2C\n\t\t| I2C_FUNC_SMBUS_QUICK\n\t\t| I2C_FUNC_SMBUS_READ_BYTE\t| I2C_FUNC_SMBUS_WRITE_BYTE\n\t\t| I2C_FUNC_SMBUS_READ_BYTE_DATA | I2C_FUNC_SMBUS_WRITE_BYTE_DATA;\n}\n\n \nstatic inline u32 saa7146_i2c_status(struct saa7146_dev *dev)\n{\n\tu32 iicsta = saa7146_read(dev, I2C_STATUS);\n\t \n\treturn iicsta;\n}\n\n \nstatic int saa7146_i2c_msg_prepare(const struct i2c_msg *m, int num, __le32 *op)\n{\n\tint h1, h2;\n\tint i, j, addr;\n\tint mem = 0, op_count = 0;\n\n\t \n\tfor(i = 0; i < num; i++) {\n\t\tmem += m[i].len + 1;\n\t}\n\n\t \n\tmem = 1 + ((mem-1) / 3);\n\n\t \n\tif ((4 * mem) > SAA7146_I2C_MEM) {\n\t\t \n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmemset(op,0,sizeof(__le32)*mem);\n\n\t \n\tfor(i = 0; i < num; i++) {\n\n\t\taddr = i2c_8bit_addr_from_msg(&m[i]);\n\t\th1 = op_count/3; h2 = op_count%3;\n\t\top[h1] |= cpu_to_le32(\t    (u8)addr << ((3-h2)*8));\n\t\top[h1] |= cpu_to_le32(SAA7146_I2C_START << ((3-h2)*2));\n\t\top_count++;\n\n\t\t \n\t\tfor(j = 0; j < m[i].len; j++) {\n\t\t\t \n\t\t\th1 = op_count/3; h2 = op_count%3;\n\t\t\top[h1] |= cpu_to_le32( (u32)((u8)m[i].buf[j]) << ((3-h2)*8));\n\t\t\top[h1] |= cpu_to_le32(       SAA7146_I2C_CONT << ((3-h2)*2));\n\t\t\top_count++;\n\t\t}\n\n\t}\n\n\t \n\th1 = (op_count-1)/3; h2 = (op_count-1)%3;\n\tif ( SAA7146_I2C_CONT == (0x3 & (le32_to_cpu(op[h1]) >> ((3-h2)*2))) ) {\n\t\top[h1] &= ~cpu_to_le32(0x2 << ((3-h2)*2));\n\t\top[h1] |= cpu_to_le32(SAA7146_I2C_STOP << ((3-h2)*2));\n\t}\n\n\t \n\treturn mem;\n}\n\n \nstatic int saa7146_i2c_msg_cleanup(const struct i2c_msg *m, int num, __le32 *op)\n{\n\tint i, j;\n\tint op_count = 0;\n\n\t \n\tfor(i = 0; i < num; i++) {\n\n\t\top_count++;\n\n\t\t \n\t\tfor(j = 0; j < m[i].len; j++) {\n\t\t\t \n\t\t\tm[i].buf[j] = (le32_to_cpu(op[op_count/3]) >> ((3-(op_count%3))*8));\n\t\t\top_count++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int saa7146_i2c_reset(struct saa7146_dev *dev)\n{\n\t \n\tu32 status = saa7146_i2c_status(dev);\n\n\t \n\tsaa7146_write(dev, I2C_STATUS, dev->i2c_bitrate);\n\tsaa7146_write(dev, I2C_TRANSFER, 0);\n\n\t \n\tif ( 0 != ( status & SAA7146_I2C_BUSY) ) {\n\n\t\t \n\t\tDEB_I2C(\"busy_state detected\\n\");\n\n\t\t \n\t\tsaa7146_write(dev, I2C_STATUS, (dev->i2c_bitrate | MASK_07));\n\t\tsaa7146_write(dev, MC2, (MASK_00 | MASK_16));\n\t\tmsleep(SAA7146_I2C_DELAY);\n\n\t\t \n\t\tsaa7146_write(dev, I2C_STATUS, dev->i2c_bitrate);\n\t\tsaa7146_write(dev, MC2, (MASK_00 | MASK_16));\n\t\tmsleep(SAA7146_I2C_DELAY);\n\t}\n\n\t \n\tstatus = saa7146_i2c_status(dev);\n\n\tif ( dev->i2c_bitrate != status ) {\n\n\t\tDEB_I2C(\"error_state detected. status:0x%08x\\n\", status);\n\n\t\t \n\t\tsaa7146_write(dev, I2C_STATUS, (dev->i2c_bitrate | MASK_07));\n\t\tsaa7146_write(dev, MC2, (MASK_00 | MASK_16));\n\t\tmsleep(SAA7146_I2C_DELAY);\n\n\t\t \n\t\tsaa7146_write(dev, I2C_STATUS, dev->i2c_bitrate);\n\t\tsaa7146_write(dev, MC2, (MASK_00 | MASK_16));\n\t\tmsleep(SAA7146_I2C_DELAY);\n\n\t\t \n\t\tsaa7146_write(dev, I2C_STATUS, dev->i2c_bitrate);\n\t\tsaa7146_write(dev, MC2, (MASK_00 | MASK_16));\n\t\tmsleep(SAA7146_I2C_DELAY);\n\t}\n\n\t \n\tstatus = saa7146_i2c_status(dev);\n\tif ( dev->i2c_bitrate != status ) {\n\t\tDEB_I2C(\"fatal error. status:0x%08x\\n\", status);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int saa7146_i2c_writeout(struct saa7146_dev *dev, __le32 *dword, int short_delay)\n{\n\tu32 status = 0, mc2 = 0;\n\tint trial = 0;\n\tunsigned long timeout;\n\n\t \n\tDEB_I2C(\"before: 0x%08x (status: 0x%08x), %d\\n\",\n\t\t*dword, saa7146_read(dev, I2C_STATUS), dev->i2c_op);\n\n\tif( 0 != (SAA7146_USE_I2C_IRQ & dev->ext->flags)) {\n\n\t\tsaa7146_write(dev, I2C_STATUS,\t dev->i2c_bitrate);\n\t\tsaa7146_write(dev, I2C_TRANSFER, le32_to_cpu(*dword));\n\n\t\tdev->i2c_op = 1;\n\t\tSAA7146_ISR_CLEAR(dev, MASK_16|MASK_17);\n\t\tSAA7146_IER_ENABLE(dev, MASK_16|MASK_17);\n\t\tsaa7146_write(dev, MC2, (MASK_00 | MASK_16));\n\n\t\ttimeout = HZ/100 + 1;  \n\t\ttimeout = wait_event_interruptible_timeout(dev->i2c_wq, dev->i2c_op == 0, timeout);\n\t\tif (timeout == -ERESTARTSYS || dev->i2c_op) {\n\t\t\tSAA7146_IER_DISABLE(dev, MASK_16|MASK_17);\n\t\t\tSAA7146_ISR_CLEAR(dev, MASK_16|MASK_17);\n\t\t\tif (timeout == -ERESTARTSYS)\n\t\t\t\t \n\t\t\t\treturn -ERESTARTSYS;\n\n\t\t\tpr_warn(\"%s %s [irq]: timed out waiting for end of xfer\\n\",\n\t\t\t\tdev->name, __func__);\n\t\t\treturn -EIO;\n\t\t}\n\t\tstatus = saa7146_read(dev, I2C_STATUS);\n\t} else {\n\t\tsaa7146_write(dev, I2C_STATUS,\t dev->i2c_bitrate);\n\t\tsaa7146_write(dev, I2C_TRANSFER, le32_to_cpu(*dword));\n\t\tsaa7146_write(dev, MC2, (MASK_00 | MASK_16));\n\n\t\t \n\t\ttimeout = jiffies + HZ/100 + 1;  \n\t\twhile(1) {\n\t\t\tmc2 = (saa7146_read(dev, MC2) & 0x1);\n\t\t\tif( 0 != mc2 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (time_after(jiffies,timeout)) {\n\t\t\t\tpr_warn(\"%s %s: timed out waiting for MC2\\n\",\n\t\t\t\t\tdev->name, __func__);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\t \n\t\ttimeout = jiffies + HZ/100 + 1;  \n\t\t \n\t\tsaa7146_i2c_status(dev);\n\t\twhile(1) {\n\t\t\tstatus = saa7146_i2c_status(dev);\n\t\t\tif ((status & 0x3) != 1)\n\t\t\t\tbreak;\n\t\t\tif (time_after(jiffies,timeout)) {\n\t\t\t\t \n\t\t\t\tpr_warn(\"%s %s [poll]: timed out waiting for end of xfer\\n\",\n\t\t\t\t\tdev->name, __func__);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (++trial < 50 && short_delay)\n\t\t\t\tudelay(10);\n\t\t\telse\n\t\t\t\tmsleep(1);\n\t\t}\n\t}\n\n\t \n\tif ( 0 != (status & (SAA7146_I2C_SPERR | SAA7146_I2C_APERR |\n\t\t\t     SAA7146_I2C_DTERR | SAA7146_I2C_DRERR |\n\t\t\t     SAA7146_I2C_AL    | SAA7146_I2C_ERR   |\n\t\t\t     SAA7146_I2C_BUSY)) ) {\n\n\t\tif ( 0 == (status & SAA7146_I2C_ERR) ||\n\t\t     0 == (status & SAA7146_I2C_BUSY) ) {\n\t\t\t \n\t\t\tDEB_I2C(\"unexpected i2c status %04x\\n\", status);\n\t\t}\n\t\tif( 0 != (status & SAA7146_I2C_SPERR) ) {\n\t\t\tDEB_I2C(\"error due to invalid start/stop condition\\n\");\n\t\t}\n\t\tif( 0 != (status & SAA7146_I2C_DTERR) ) {\n\t\t\tDEB_I2C(\"error in data transmission\\n\");\n\t\t}\n\t\tif( 0 != (status & SAA7146_I2C_DRERR) ) {\n\t\t\tDEB_I2C(\"error when receiving data\\n\");\n\t\t}\n\t\tif( 0 != (status & SAA7146_I2C_AL) ) {\n\t\t\tDEB_I2C(\"error because arbitration lost\\n\");\n\t\t}\n\n\t\t \n\t\tif( 0 != (status & SAA7146_I2C_APERR) ) {\n\t\t\tDEB_I2C(\"error in address phase\\n\");\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\n\t\treturn -EIO;\n\t}\n\n\t \n\t*dword = cpu_to_le32(saa7146_read(dev, I2C_TRANSFER));\n\n\tDEB_I2C(\"after: 0x%08x\\n\", *dword);\n\treturn 0;\n}\n\nstatic int saa7146_i2c_transfer(struct saa7146_dev *dev, const struct i2c_msg *msgs, int num, int retries)\n{\n\tint i = 0, count = 0;\n\t__le32 *buffer = dev->d_i2c.cpu_addr;\n\tint err = 0;\n\tint short_delay = 0;\n\n\tif (mutex_lock_interruptible(&dev->i2c_lock))\n\t\treturn -ERESTARTSYS;\n\n\tfor(i=0;i<num;i++) {\n\t\tDEB_I2C(\"msg:%d/%d\\n\", i+1, num);\n\t}\n\n\t \n\tcount = saa7146_i2c_msg_prepare(msgs, num, buffer);\n\tif ( 0 > count ) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tif ( count > 3 || 0 != (SAA7146_I2C_SHORT_DELAY & dev->ext->flags) )\n\t\tshort_delay = 1;\n\n\tdo {\n\t\t \n\t\terr = saa7146_i2c_reset(dev);\n\t\tif ( 0 > err ) {\n\t\t\tDEB_I2C(\"could not reset i2c-device\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tfor(i = 0; i < count; i++) {\n\t\t\terr = saa7146_i2c_writeout(dev, &buffer[i], short_delay);\n\t\t\tif ( 0 != err) {\n\t\t\t\t \n\t\t\t\tif (-EREMOTEIO == err && 0 != (SAA7146_USE_I2C_IRQ & dev->ext->flags))\n\t\t\t\t\tgoto out;\n\t\t\t\tDEB_I2C(\"error while sending message(s). starting again\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( 0 == err ) {\n\t\t\terr = num;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmsleep(10);\n\n\t} while (err != num && retries--);\n\n\t \n\tif (err != num)\n\t\tgoto out;\n\n\t \n\tif ( 0 != saa7146_i2c_msg_cleanup(msgs, num, buffer)) {\n\t\tDEB_I2C(\"could not cleanup i2c-message\\n\");\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tDEB_I2C(\"transmission successful. (msg:%d)\\n\", err);\nout:\n\t \n\tif( 0 == dev->revision ) {\n\t\t__le32 zero = 0;\n\t\tsaa7146_i2c_reset(dev);\n\t\tif( 0 != saa7146_i2c_writeout(dev, &zero, short_delay)) {\n\t\t\tpr_info(\"revision 0 error. this should never happen\\n\");\n\t\t}\n\t}\n\n\tmutex_unlock(&dev->i2c_lock);\n\treturn err;\n}\n\n \nstatic int saa7146_i2c_xfer(struct i2c_adapter* adapter, struct i2c_msg *msg, int num)\n{\n\tstruct v4l2_device *v4l2_dev = i2c_get_adapdata(adapter);\n\tstruct saa7146_dev *dev = to_saa7146_dev(v4l2_dev);\n\n\t \n\treturn saa7146_i2c_transfer(dev, msg, num, adapter->retries);\n}\n\n\n \n \n\n \nstatic const struct i2c_algorithm saa7146_algo = {\n\t.master_xfer\t= saa7146_i2c_xfer,\n\t.functionality\t= saa7146_i2c_func,\n};\n\nint saa7146_i2c_adapter_prepare(struct saa7146_dev *dev, struct i2c_adapter *i2c_adapter, u32 bitrate)\n{\n\tDEB_EE(\"bitrate: 0x%08x\\n\", bitrate);\n\n\t \n\tsaa7146_write(dev, MC1, (MASK_08 | MASK_24));\n\n\tdev->i2c_bitrate = bitrate;\n\tsaa7146_i2c_reset(dev);\n\n\tif (i2c_adapter) {\n\t\ti2c_set_adapdata(i2c_adapter, &dev->v4l2_dev);\n\t\ti2c_adapter->dev.parent    = &dev->pci->dev;\n\t\ti2c_adapter->algo\t   = &saa7146_algo;\n\t\ti2c_adapter->algo_data     = NULL;\n\t\ti2c_adapter->timeout = SAA7146_I2C_TIMEOUT;\n\t\ti2c_adapter->retries = SAA7146_I2C_RETRIES;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}