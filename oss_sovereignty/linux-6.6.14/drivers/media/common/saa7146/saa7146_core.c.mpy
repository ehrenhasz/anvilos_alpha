{
  "module_name": "saa7146_core.c",
  "hash_id": "1677123e5a4bf27558051ae8b0cfd147a08e38860c651d907f5b0b4e5cf71cd0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/saa7146/saa7146_core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <media/drv-intf/saa7146.h>\n#include <linux/module.h>\n\nstatic int saa7146_num;\n\nunsigned int saa7146_debug;\n\nmodule_param(saa7146_debug, uint, 0644);\nMODULE_PARM_DESC(saa7146_debug, \"debug level (default: 0)\");\n\n#if 0\nstatic void dump_registers(struct saa7146_dev* dev)\n{\n\tint i = 0;\n\n\tpr_info(\" @ %li jiffies:\\n\", jiffies);\n\tfor (i = 0; i <= 0x148; i += 4)\n\t\tpr_info(\"0x%03x: 0x%08x\\n\", i, saa7146_read(dev, i));\n}\n#endif\n\n \n\nvoid saa7146_setgpio(struct saa7146_dev *dev, int port, u32 data)\n{\n\tu32 value = 0;\n\n\tif (WARN_ON(port > 3))\n\t\treturn;\n\n\tvalue = saa7146_read(dev, GPIO_CTRL);\n\tvalue &= ~(0xff << (8*port));\n\tvalue |= (data << (8*port));\n\tsaa7146_write(dev, GPIO_CTRL, value);\n}\n\n \nstatic inline int saa7146_wait_for_debi_done_sleep(struct saa7146_dev *dev,\n\t\t\t\tunsigned long us1, unsigned long us2)\n{\n\tunsigned long timeout;\n\tint err;\n\n\t \n\ttimeout = jiffies + usecs_to_jiffies(us1);\n\twhile (1) {\n\t\terr = time_after(jiffies, timeout);\n\t\tif (saa7146_read(dev, MC2) & 2)\n\t\t\tbreak;\n\t\tif (err) {\n\t\t\tpr_debug(\"%s: %s timed out while waiting for registers getting programmed\\n\",\n\t\t\t       dev->name, __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(1);\n\t}\n\n\t \n\ttimeout = jiffies + usecs_to_jiffies(us2);\n\twhile (1) {\n\t\terr = time_after(jiffies, timeout);\n\t\tif (!(saa7146_read(dev, PSR) & SPCI_DEBI_S))\n\t\t\tbreak;\n\t\tsaa7146_read(dev, MC2);\n\t\tif (err) {\n\t\t\tDEB_S(\"%s: %s timed out while waiting for transfer completion\\n\",\n\t\t\t      dev->name, __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(1);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int saa7146_wait_for_debi_done_busyloop(struct saa7146_dev *dev,\n\t\t\t\tunsigned long us1, unsigned long us2)\n{\n\tunsigned long loops;\n\n\t \n\tloops = us1;\n\twhile (1) {\n\t\tif (saa7146_read(dev, MC2) & 2)\n\t\t\tbreak;\n\t\tif (!loops--) {\n\t\t\tpr_err(\"%s: %s timed out while waiting for registers getting programmed\\n\",\n\t\t\t       dev->name, __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\t \n\tloops = us2 / 5;\n\twhile (1) {\n\t\tif (!(saa7146_read(dev, PSR) & SPCI_DEBI_S))\n\t\t\tbreak;\n\t\tsaa7146_read(dev, MC2);\n\t\tif (!loops--) {\n\t\t\tDEB_S(\"%s: %s timed out while waiting for transfer completion\\n\",\n\t\t\t      dev->name, __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(5);\n\t}\n\n\treturn 0;\n}\n\nint saa7146_wait_for_debi_done(struct saa7146_dev *dev, int nobusyloop)\n{\n\tif (nobusyloop)\n\t\treturn saa7146_wait_for_debi_done_sleep(dev, 50000, 250000);\n\telse\n\t\treturn saa7146_wait_for_debi_done_busyloop(dev, 50000, 250000);\n}\n\n \n\n \nstatic struct scatterlist* vmalloc_to_sg(unsigned char *virt, int nr_pages)\n{\n\tstruct scatterlist *sglist;\n\tstruct page *pg;\n\tint i;\n\n\tsglist = kmalloc_array(nr_pages, sizeof(struct scatterlist), GFP_KERNEL);\n\tif (NULL == sglist)\n\t\treturn NULL;\n\tsg_init_table(sglist, nr_pages);\n\tfor (i = 0; i < nr_pages; i++, virt += PAGE_SIZE) {\n\t\tpg = vmalloc_to_page(virt);\n\t\tif (NULL == pg)\n\t\t\tgoto err;\n\t\tif (WARN_ON(PageHighMem(pg)))\n\t\t\tgoto err;\n\t\tsg_set_page(&sglist[i], pg, PAGE_SIZE, 0);\n\t}\n\treturn sglist;\n\n err:\n\tkfree(sglist);\n\treturn NULL;\n}\n\n \n \n\nvoid *saa7146_vmalloc_build_pgtable(struct pci_dev *pci, long length, struct saa7146_pgtable *pt)\n{\n\tint pages = (length+PAGE_SIZE-1)/PAGE_SIZE;\n\tvoid *mem = vmalloc_32(length);\n\tint slen = 0;\n\n\tif (NULL == mem)\n\t\tgoto err_null;\n\n\tif (!(pt->slist = vmalloc_to_sg(mem, pages)))\n\t\tgoto err_free_mem;\n\n\tif (saa7146_pgtable_alloc(pci, pt))\n\t\tgoto err_free_slist;\n\n\tpt->nents = pages;\n\tslen = dma_map_sg(&pci->dev, pt->slist, pt->nents, DMA_FROM_DEVICE);\n\tif (0 == slen)\n\t\tgoto err_free_pgtable;\n\n\tif (0 != saa7146_pgtable_build_single(pci, pt, pt->slist, slen))\n\t\tgoto err_unmap_sg;\n\n\treturn mem;\n\nerr_unmap_sg:\n\tdma_unmap_sg(&pci->dev, pt->slist, pt->nents, DMA_FROM_DEVICE);\nerr_free_pgtable:\n\tsaa7146_pgtable_free(pci, pt);\nerr_free_slist:\n\tkfree(pt->slist);\n\tpt->slist = NULL;\nerr_free_mem:\n\tvfree(mem);\nerr_null:\n\treturn NULL;\n}\n\nvoid saa7146_vfree_destroy_pgtable(struct pci_dev *pci, void *mem, struct saa7146_pgtable *pt)\n{\n\tdma_unmap_sg(&pci->dev, pt->slist, pt->nents, DMA_FROM_DEVICE);\n\tsaa7146_pgtable_free(pci, pt);\n\tkfree(pt->slist);\n\tpt->slist = NULL;\n\tvfree(mem);\n}\n\nvoid saa7146_pgtable_free(struct pci_dev *pci, struct saa7146_pgtable *pt)\n{\n\tif (NULL == pt->cpu)\n\t\treturn;\n\tdma_free_coherent(&pci->dev, pt->size, pt->cpu, pt->dma);\n\tpt->cpu = NULL;\n}\n\nint saa7146_pgtable_alloc(struct pci_dev *pci, struct saa7146_pgtable *pt)\n{\n\t__le32       *cpu;\n\tdma_addr_t   dma_addr = 0;\n\n\tcpu = dma_alloc_coherent(&pci->dev, PAGE_SIZE, &dma_addr, GFP_KERNEL);\n\tif (NULL == cpu) {\n\t\treturn -ENOMEM;\n\t}\n\tpt->size = PAGE_SIZE;\n\tpt->cpu  = cpu;\n\tpt->dma  = dma_addr;\n\n\treturn 0;\n}\n\nint saa7146_pgtable_build_single(struct pci_dev *pci, struct saa7146_pgtable *pt,\n\t\t\t\t struct scatterlist *list, int sglen)\n{\n\tstruct sg_dma_page_iter dma_iter;\n\t__le32 *ptr, fill;\n\tint nr_pages = 0;\n\tint i;\n\n\tif (WARN_ON(!sglen) ||\n\t    WARN_ON(list->offset > PAGE_SIZE))\n\t\treturn -EIO;\n\n\t \n\tpt->offset = list->offset;\n\n\tptr = pt->cpu;\n\tfor_each_sg_dma_page(list, &dma_iter, sglen, 0) {\n\t\t*ptr++ = cpu_to_le32(sg_page_iter_dma_address(&dma_iter));\n\t\tnr_pages++;\n\t}\n\n\n\t \n\tfill = *(ptr-1);\n\tfor (i = nr_pages; i < 1024; i++)\n\t\t*ptr++ = fill;\n\treturn 0;\n}\n\n \n \nstatic irqreturn_t interrupt_hw(int irq, void *dev_id)\n{\n\tstruct saa7146_dev *dev = dev_id;\n\tu32 isr;\n\tu32 ack_isr;\n\n\t \n\tack_isr = isr = saa7146_read(dev, ISR);\n\n\t \n\tif ( 0 == isr ) {\n\t\t \n\t\treturn IRQ_NONE;\n\t}\n\n\tif (dev->ext) {\n\t\tif (dev->ext->irq_mask & isr) {\n\t\t\tif (dev->ext->irq_func)\n\t\t\t\tdev->ext->irq_func(dev, &isr);\n\t\t\tisr &= ~dev->ext->irq_mask;\n\t\t}\n\t}\n\tif (0 != (isr & (MASK_27))) {\n\t\tDEB_INT(\"irq: RPS0 (0x%08x)\\n\", isr);\n\t\tif (dev->vv_data && dev->vv_callback)\n\t\t\tdev->vv_callback(dev,isr);\n\t\tisr &= ~MASK_27;\n\t}\n\tif (0 != (isr & (MASK_28))) {\n\t\tif (dev->vv_data && dev->vv_callback)\n\t\t\tdev->vv_callback(dev,isr);\n\t\tisr &= ~MASK_28;\n\t}\n\tif (0 != (isr & (MASK_16|MASK_17))) {\n\t\tSAA7146_IER_DISABLE(dev, MASK_16|MASK_17);\n\t\t \n\t\tif (0 != dev->i2c_op) {\n\t\t\tdev->i2c_op = 0;\n\t\t\twake_up(&dev->i2c_wq);\n\t\t} else {\n\t\t\tu32 psr = saa7146_read(dev, PSR);\n\t\t\tu32 ssr = saa7146_read(dev, SSR);\n\t\t\tpr_warn(\"%s: unexpected i2c irq: isr %08x psr %08x ssr %08x\\n\",\n\t\t\t\tdev->name, isr, psr, ssr);\n\t\t}\n\t\tisr &= ~(MASK_16|MASK_17);\n\t}\n\tif( 0 != isr ) {\n\t\tERR(\"warning: interrupt enabled, but not handled properly.(0x%08x)\\n\",\n\t\t    isr);\n\t\tERR(\"disabling interrupt source(s)!\\n\");\n\t\tSAA7146_IER_DISABLE(dev,isr);\n\t}\n\tsaa7146_write(dev, ISR, ack_isr);\n\treturn IRQ_HANDLED;\n}\n\n \n \n\nstatic int saa7146_init_one(struct pci_dev *pci, const struct pci_device_id *ent)\n{\n\tstruct saa7146_pci_extension_data *pci_ext = (struct saa7146_pci_extension_data *)ent->driver_data;\n\tstruct saa7146_extension *ext = pci_ext->ext;\n\tstruct saa7146_dev *dev;\n\tint err = -ENOMEM;\n\n\t \n\tdev = kzalloc(sizeof(struct saa7146_dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tERR(\"out of memory\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tsprintf(dev->name, \"saa7146 (%d)\", saa7146_num);\n\n\tDEB_EE(\"pci:%p\\n\", pci);\n\n\terr = pci_enable_device(pci);\n\tif (err < 0) {\n\t\tERR(\"pci_enable_device() failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\t \n\tpci_set_master(pci);\n\n\tdev->pci = pci;\n\n\t \n\tdev->revision = pci->revision;\n\n\t \n\n\terr = pci_request_region(pci, 0, \"saa7146\");\n\tif (err < 0)\n\t\tgoto err_disable;\n\n\tdev->mem = ioremap(pci_resource_start(pci, 0),\n\t\t\t   pci_resource_len(pci, 0));\n\tif (!dev->mem) {\n\t\tERR(\"ioremap() failed\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_release;\n\t}\n\n\t \n \n\n\t \n\tsaa7146_write(dev, IER, 0);\n\n\t \n\tsaa7146_write(dev, MC1, 0x30ff0000);\n\n\t \n\tsaa7146_write(dev, MC2, 0xf8000000);\n\n\t \n\terr = request_irq(pci->irq, interrupt_hw, IRQF_SHARED,\n\t\t\t  dev->name, dev);\n\tif (err < 0) {\n\t\tERR(\"request_irq() failed\\n\");\n\t\tgoto err_unmap;\n\t}\n\n\terr = -ENOMEM;\n\n\t \n\tdev->d_rps0.cpu_addr = dma_alloc_coherent(&pci->dev, SAA7146_RPS_MEM,\n\t\t\t\t\t\t  &dev->d_rps0.dma_handle,\n\t\t\t\t\t\t  GFP_KERNEL);\n\tif (!dev->d_rps0.cpu_addr)\n\t\tgoto err_free_irq;\n\n\tdev->d_rps1.cpu_addr = dma_alloc_coherent(&pci->dev, SAA7146_RPS_MEM,\n\t\t\t\t\t\t  &dev->d_rps1.dma_handle,\n\t\t\t\t\t\t  GFP_KERNEL);\n\tif (!dev->d_rps1.cpu_addr)\n\t\tgoto err_free_rps0;\n\n\tdev->d_i2c.cpu_addr = dma_alloc_coherent(&pci->dev, SAA7146_RPS_MEM,\n\t\t\t\t\t\t &dev->d_i2c.dma_handle, GFP_KERNEL);\n\tif (!dev->d_i2c.cpu_addr)\n\t\tgoto err_free_rps1;\n\n\t \n\n\tpr_info(\"found saa7146 @ mem %p (revision %d, irq %d) (0x%04x,0x%04x)\\n\",\n\t\tdev->mem, dev->revision, pci->irq,\n\t\tpci->subsystem_vendor, pci->subsystem_device);\n\tdev->ext = ext;\n\n\tmutex_init(&dev->v4l2_lock);\n\tspin_lock_init(&dev->int_slock);\n\tspin_lock_init(&dev->slock);\n\n\tmutex_init(&dev->i2c_lock);\n\n\tdev->module = THIS_MODULE;\n\tinit_waitqueue_head(&dev->i2c_wq);\n\n\t \n\tsaa7146_write(dev, PCI_BT_V1, 0x1c00101f);\n\n\t \n\n\terr = -ENODEV;\n\n\tif (ext->probe && ext->probe(dev)) {\n\t\tDEB_D(\"ext->probe() failed for %p. skipping device.\\n\", dev);\n\t\tgoto err_free_i2c;\n\t}\n\n\tif (ext->attach(dev, pci_ext)) {\n\t\tDEB_D(\"ext->attach() failed for %p. skipping device.\\n\", dev);\n\t\tgoto err_free_i2c;\n\t}\n\t \n\tpci_set_drvdata(pci, &dev->v4l2_dev);\n\n\tsaa7146_num++;\n\n\terr = 0;\nout:\n\treturn err;\n\nerr_free_i2c:\n\tdma_free_coherent(&pci->dev, SAA7146_RPS_MEM, dev->d_i2c.cpu_addr,\n\t\t\t  dev->d_i2c.dma_handle);\nerr_free_rps1:\n\tdma_free_coherent(&pci->dev, SAA7146_RPS_MEM, dev->d_rps1.cpu_addr,\n\t\t\t  dev->d_rps1.dma_handle);\nerr_free_rps0:\n\tdma_free_coherent(&pci->dev, SAA7146_RPS_MEM, dev->d_rps0.cpu_addr,\n\t\t\t  dev->d_rps0.dma_handle);\nerr_free_irq:\n\tfree_irq(pci->irq, (void *)dev);\nerr_unmap:\n\tiounmap(dev->mem);\nerr_release:\n\tpci_release_region(pci, 0);\nerr_disable:\n\tpci_disable_device(pci);\nerr_free:\n\tkfree(dev);\n\tgoto out;\n}\n\nstatic void saa7146_remove_one(struct pci_dev *pdev)\n{\n\tstruct v4l2_device *v4l2_dev = pci_get_drvdata(pdev);\n\tstruct saa7146_dev *dev = to_saa7146_dev(v4l2_dev);\n\tstruct {\n\t\tvoid *addr;\n\t\tdma_addr_t dma;\n\t} dev_map[] = {\n\t\t{ dev->d_i2c.cpu_addr, dev->d_i2c.dma_handle },\n\t\t{ dev->d_rps1.cpu_addr, dev->d_rps1.dma_handle },\n\t\t{ dev->d_rps0.cpu_addr, dev->d_rps0.dma_handle },\n\t\t{ NULL, 0 }\n\t}, *p;\n\n\tDEB_EE(\"dev:%p\\n\", dev);\n\n\tdev->ext->detach(dev);\n\n\t \n\tsaa7146_write(dev, MC1, 0x00ff0000);\n\n\t \n\tsaa7146_write(dev, IER, 0);\n\n\tfree_irq(pdev->irq, dev);\n\n\tfor (p = dev_map; p->addr; p++)\n\t\tdma_free_coherent(&pdev->dev, SAA7146_RPS_MEM, p->addr,\n\t\t\t\t  p->dma);\n\n\tiounmap(dev->mem);\n\tpci_release_region(pdev, 0);\n\tpci_disable_device(pdev);\n\tkfree(dev);\n\n\tsaa7146_num--;\n}\n\n \n \n\nint saa7146_register_extension(struct saa7146_extension* ext)\n{\n\tDEB_EE(\"ext:%p\\n\", ext);\n\n\text->driver.name = ext->name;\n\text->driver.id_table = ext->pci_tbl;\n\text->driver.probe = saa7146_init_one;\n\text->driver.remove = saa7146_remove_one;\n\n\tpr_info(\"register extension '%s'\\n\", ext->name);\n\treturn pci_register_driver(&ext->driver);\n}\n\nint saa7146_unregister_extension(struct saa7146_extension* ext)\n{\n\tDEB_EE(\"ext:%p\\n\", ext);\n\tpr_info(\"unregister extension '%s'\\n\", ext->name);\n\tpci_unregister_driver(&ext->driver);\n\treturn 0;\n}\n\nEXPORT_SYMBOL_GPL(saa7146_register_extension);\nEXPORT_SYMBOL_GPL(saa7146_unregister_extension);\n\n \nEXPORT_SYMBOL_GPL(saa7146_pgtable_alloc);\nEXPORT_SYMBOL_GPL(saa7146_pgtable_free);\nEXPORT_SYMBOL_GPL(saa7146_pgtable_build_single);\nEXPORT_SYMBOL_GPL(saa7146_vmalloc_build_pgtable);\nEXPORT_SYMBOL_GPL(saa7146_vfree_destroy_pgtable);\nEXPORT_SYMBOL_GPL(saa7146_wait_for_debi_done);\n\nEXPORT_SYMBOL_GPL(saa7146_setgpio);\n\nEXPORT_SYMBOL_GPL(saa7146_i2c_adapter_prepare);\n\nEXPORT_SYMBOL_GPL(saa7146_debug);\n\nMODULE_AUTHOR(\"Michael Hunold <michael@mihu.de>\");\nMODULE_DESCRIPTION(\"driver for generic saa7146-based hardware\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}