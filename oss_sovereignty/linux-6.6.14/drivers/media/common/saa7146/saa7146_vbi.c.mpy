{
  "module_name": "saa7146_vbi.c",
  "hash_id": "76ede1780b1265238561ccef7977fc7222a77a9ee3bedd2e7a8c1fba661a6421",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/saa7146/saa7146_vbi.c",
  "human_readable_source": "\n#include <media/drv-intf/saa7146_vv.h>\n\nstatic int vbi_pixel_to_capture = 720 * 2;\n\nstatic int vbi_workaround(struct saa7146_dev *dev)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\n\tu32          *cpu;\n\tdma_addr_t   dma_addr;\n\n\tint count = 0;\n\tint i;\n\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tDEB_VBI(\"dev:%p\\n\", dev);\n\n\t \n\n\tcpu = dma_alloc_coherent(&dev->pci->dev, 4096, &dma_addr, GFP_KERNEL);\n\tif (NULL == cpu)\n\t\treturn -ENOMEM;\n\n\t \n\tsaa7146_write(dev, BASE_EVEN3,\tdma_addr);\n\tsaa7146_write(dev, BASE_ODD3,\tdma_addr+vbi_pixel_to_capture);\n\tsaa7146_write(dev, PROT_ADDR3,\tdma_addr+4096);\n\tsaa7146_write(dev, PITCH3,\tvbi_pixel_to_capture);\n\tsaa7146_write(dev, BASE_PAGE3,\t0x0);\n\tsaa7146_write(dev, NUM_LINE_BYTE3, (2<<16)|((vbi_pixel_to_capture)<<0));\n\tsaa7146_write(dev, MC2, MASK_04|MASK_20);\n\n\t \n\tWRITE_RPS1(CMD_WR_REG | (1 << 8) | (BRS_CTRL/4));\n\t \n\tWRITE_RPS1(0xc000008c);\n\t \n\tif ( 0 != (SAA7146_USE_PORT_B_FOR_VBI & dev->ext_vv_data->flags)) {\n\t\tDEB_D(\"...using port b\\n\");\n\t\tWRITE_RPS1(CMD_PAUSE | CMD_OAN | CMD_SIG1 | CMD_E_FID_B);\n\t\tWRITE_RPS1(CMD_PAUSE | CMD_OAN | CMD_SIG1 | CMD_O_FID_B);\n \n\t} else {\n\t\tDEB_D(\"...using port a\\n\");\n\t\tWRITE_RPS1(CMD_PAUSE | MASK_10);\n\t}\n\t \n\tWRITE_RPS1(CMD_UPLOAD | MASK_08);\n\t \n\tWRITE_RPS1(CMD_WR_REG | (1 << 8) | (BRS_CTRL/4));\n\t \n\tWRITE_RPS1(((1728-(vbi_pixel_to_capture)) << 7) | MASK_19);\n\t \n\tWRITE_RPS1(CMD_PAUSE | MASK_08);\n\t \n\tWRITE_RPS1(CMD_UPLOAD | MASK_08);\n\t \n\tWRITE_RPS1(CMD_WR_REG | (1 << 8) | (NUM_LINE_BYTE3/4));\n\t \n\tWRITE_RPS1((2 << 16) | (vbi_pixel_to_capture));\n\t \n\tWRITE_RPS1(CMD_WR_REG | (1 << 8) | (BRS_CTRL/4));\n\t \n\tWRITE_RPS1((540 << 7) | (5 << 19));   \n\t \n\tWRITE_RPS1(CMD_PAUSE | MASK_08);\n\t \n\tWRITE_RPS1(CMD_UPLOAD | MASK_08 | MASK_04);\n\t \n\tWRITE_RPS1(CMD_WR_REG | (1 << 8) | (MC1/4));\n\tWRITE_RPS1(MASK_20 | MASK_04);\n\t \n\tWRITE_RPS1(CMD_INTERRUPT);\n\t \n\tWRITE_RPS1(CMD_STOP);\n\n\t \n\tfor(i = 0; i < 2; i++) {\n\n\t\t \n\t\tsaa7146_write(dev, MC2, MASK_31|MASK_15);\n\n\t\tsaa7146_write(dev, NUM_LINE_BYTE3, (1<<16)|(2<<0));\n\t\tsaa7146_write(dev, MC2, MASK_04|MASK_20);\n\n\t\t \n\t\tSAA7146_IER_ENABLE(dev,MASK_28);\n\n\t\t \n\t\tadd_wait_queue(&vv->vbi_wq, &wait);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\t \n\t\tsaa7146_write(dev, RPS_ADDR1, dev->d_rps1.dma_handle);\n\t\tsaa7146_write(dev, MC1, (MASK_13 | MASK_29));\n\n\t\tschedule();\n\n\t\tDEB_VBI(\"brs bug workaround %d/1\\n\", i);\n\n\t\tremove_wait_queue(&vv->vbi_wq, &wait);\n\t\t__set_current_state(TASK_RUNNING);\n\n\t\t \n\t\tSAA7146_IER_DISABLE(dev,MASK_28);\n\n\t\t \n\t\tsaa7146_write(dev, MC1, MASK_20);\n\n\t\tif(signal_pending(current)) {\n\n\t\t\tDEB_VBI(\"aborted (rps:0x%08x)\\n\",\n\t\t\t\tsaa7146_read(dev, RPS_ADDR1));\n\n\t\t\t \n\t\t\tsaa7146_write(dev, MC1, MASK_29);\n\n\t\t\tdma_free_coherent(&dev->pci->dev, 4096, cpu, dma_addr);\n\t\t\treturn -EINTR;\n\t\t}\n\t}\n\n\tdma_free_coherent(&dev->pci->dev, 4096, cpu, dma_addr);\n\treturn 0;\n}\n\nstatic void saa7146_set_vbi_capture(struct saa7146_dev *dev, struct saa7146_buf *buf, struct saa7146_buf *next)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\n\tstruct saa7146_video_dma vdma3;\n\n\tint count = 0;\n\tunsigned long e_wait = vv->current_hps_sync == SAA7146_HPS_SYNC_PORT_A ? CMD_E_FID_A : CMD_E_FID_B;\n\tunsigned long o_wait = vv->current_hps_sync == SAA7146_HPS_SYNC_PORT_A ? CMD_O_FID_A : CMD_O_FID_B;\n\n \n\tvdma3.base_even\t= buf->pt[2].offset;\n\tvdma3.base_odd\t= buf->pt[2].offset + 16 * vbi_pixel_to_capture;\n\tvdma3.prot_addr\t= buf->pt[2].offset + 16 * 2 * vbi_pixel_to_capture;\n\tvdma3.pitch\t= vbi_pixel_to_capture;\n\tvdma3.base_page\t= buf->pt[2].dma | ME1;\n\tvdma3.num_line_byte = (16 << 16) | vbi_pixel_to_capture;\n\n\tsaa7146_write_out_dma(dev, 3, &vdma3);\n\n\t \n\tcount = 0;\n\n\t \n\n\t \n\n \n\t \n\tWRITE_RPS1(CMD_WR_REG | (1 << 8) | (MC2/4));\n\tWRITE_RPS1(MASK_28 | MASK_12);\n\n\t \n\tWRITE_RPS1(CMD_WR_REG_MASK | (MC1/4));\n\tWRITE_RPS1(MASK_04 | MASK_20);\t\t\t \n\tWRITE_RPS1(MASK_04 | MASK_20);\t\t\t \n\n\t \n\tWRITE_RPS1(CMD_PAUSE | o_wait);\n\tWRITE_RPS1(CMD_PAUSE | e_wait);\n\n\t \n\tWRITE_RPS1(CMD_INTERRUPT);\n\n\t \n\tWRITE_RPS1(CMD_STOP);\n\n\t \n\tSAA7146_IER_ENABLE(dev, MASK_28);\n\n\t \n\tsaa7146_write(dev, RPS_ADDR1, dev->d_rps1.dma_handle);\n\n\t \n\tsaa7146_write(dev, MC1, (MASK_13 | MASK_29));\n}\n\nstatic int buffer_activate(struct saa7146_dev *dev,\n\t\t\t   struct saa7146_buf *buf,\n\t\t\t   struct saa7146_buf *next)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\n\tDEB_VBI(\"dev:%p, buf:%p, next:%p\\n\", dev, buf, next);\n\tsaa7146_set_vbi_capture(dev,buf,next);\n\n\tmod_timer(&vv->vbi_dmaq.timeout, jiffies+BUFFER_TIMEOUT);\n\treturn 0;\n}\n\n \n\nstatic int queue_setup(struct vb2_queue *q,\n\t\t       unsigned int *num_buffers, unsigned int *num_planes,\n\t\t       unsigned int sizes[], struct device *alloc_devs[])\n{\n\tunsigned int size = 16 * 2 * vbi_pixel_to_capture;\n\n\tif (*num_planes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\t*num_planes = 1;\n\tsizes[0] = size;\n\n\treturn 0;\n}\n\nstatic void buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct saa7146_dev *dev = vb2_get_drv_priv(vq);\n\tstruct saa7146_buf *buf = container_of(vbuf, struct saa7146_buf, vb);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\n\tsaa7146_buffer_queue(dev, &dev->vv_data->vbi_dmaq, buf);\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nstatic int buf_init(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct saa7146_buf *buf = container_of(vbuf, struct saa7146_buf, vb);\n\tstruct sg_table *sgt = vb2_dma_sg_plane_desc(&buf->vb.vb2_buf, 0);\n\tstruct scatterlist *list = sgt->sgl;\n\tint length = sgt->nents;\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct saa7146_dev *dev = vb2_get_drv_priv(vq);\n\tint ret;\n\n\tbuf->activate = buffer_activate;\n\n\tsaa7146_pgtable_alloc(dev->pci, &buf->pt[2]);\n\n\tret = saa7146_pgtable_build_single(dev->pci, &buf->pt[2],\n\t\t\t\t\t   list, length);\n\tif (ret)\n\t\tsaa7146_pgtable_free(dev->pci, &buf->pt[2]);\n\treturn ret;\n}\n\nstatic int buf_prepare(struct vb2_buffer *vb)\n{\n\tunsigned int size = 16 * 2 * vbi_pixel_to_capture;\n\n\tif (vb2_plane_size(vb, 0) < size)\n\t\treturn -EINVAL;\n\tvb2_set_plane_payload(vb, 0, size);\n\treturn 0;\n}\n\nstatic void buf_cleanup(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct saa7146_buf *buf = container_of(vbuf, struct saa7146_buf, vb);\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct saa7146_dev *dev = vb2_get_drv_priv(vq);\n\n\tsaa7146_pgtable_free(dev->pci, &buf->pt[2]);\n}\n\nstatic void return_buffers(struct vb2_queue *q, int state)\n{\n\tstruct saa7146_dev *dev = vb2_get_drv_priv(q);\n\tstruct saa7146_dmaqueue *dq = &dev->vv_data->vbi_dmaq;\n\tstruct saa7146_buf *buf;\n\n\tif (dq->curr) {\n\t\tbuf = dq->curr;\n\t\tdq->curr = NULL;\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t}\n\twhile (!list_empty(&dq->queue)) {\n\t\tbuf = list_entry(dq->queue.next, struct saa7146_buf, list);\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t}\n}\n\nstatic void vbi_stop(struct saa7146_dev *dev)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\tunsigned long flags;\n\tDEB_VBI(\"dev:%p\\n\", dev);\n\n\tspin_lock_irqsave(&dev->slock,flags);\n\n\t \n\tsaa7146_write(dev, MC1, MASK_29);\n\n\t \n\tSAA7146_IER_DISABLE(dev, MASK_28);\n\n\t \n\tsaa7146_write(dev, MC1, MASK_20);\n\n\tdel_timer(&vv->vbi_dmaq.timeout);\n\tdel_timer(&vv->vbi_read_timeout);\n\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nstatic void vbi_read_timeout(struct timer_list *t)\n{\n\tstruct saa7146_vv *vv = from_timer(vv, t, vbi_read_timeout);\n\tstruct saa7146_dev *dev = vv->vbi_dmaq.dev;\n\n\tDEB_VBI(\"dev:%p\\n\", dev);\n\n\tvbi_stop(dev);\n}\n\nstatic int vbi_begin(struct saa7146_dev *dev)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\tu32 arbtr_ctrl\t= saa7146_read(dev, PCI_BT_V1);\n\tint ret = 0;\n\n\tDEB_VBI(\"dev:%p\\n\", dev);\n\n\tret = saa7146_res_get(dev, RESOURCE_DMA3_BRS);\n\tif (0 == ret) {\n\t\tDEB_S(\"cannot get vbi RESOURCE_DMA3_BRS resource\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tarbtr_ctrl &= ~0x1f0000;\n\tarbtr_ctrl |=  0x1d0000;\n\tsaa7146_write(dev, PCI_BT_V1, arbtr_ctrl);\n\tsaa7146_write(dev, MC2, (MASK_04|MASK_20));\n\n\tvv->vbi_read_timeout.function = vbi_read_timeout;\n\n\t \n\tif ( 0 != (SAA7146_USE_PORT_B_FOR_VBI & dev->ext_vv_data->flags)) {\n\t\tsaa7146_write(dev, BRS_CTRL, MASK_30|MASK_29 | (7 << 19));\n\t} else {\n\t\tsaa7146_write(dev, BRS_CTRL, 0x00000001);\n\n\t\tif (0 != (ret = vbi_workaround(dev))) {\n\t\t\tDEB_VBI(\"vbi workaround failed!\\n\");\n\t\t\t \n\t\t}\n\t}\n\n\t \n\tsaa7146_write(dev, MC2, (MASK_08|MASK_24));\n\treturn 0;\n}\n\nstatic int start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct saa7146_dev *dev = vb2_get_drv_priv(q);\n\tint ret;\n\n\tif (!vb2_is_streaming(&dev->vv_data->vbi_dmaq.q))\n\t\tdev->vv_data->seqnr = 0;\n\tret = vbi_begin(dev);\n\tif (ret)\n\t\treturn_buffers(q, VB2_BUF_STATE_QUEUED);\n\treturn ret;\n}\n\nstatic void stop_streaming(struct vb2_queue *q)\n{\n\tstruct saa7146_dev *dev = vb2_get_drv_priv(q);\n\n\tvbi_stop(dev);\n\treturn_buffers(q, VB2_BUF_STATE_ERROR);\n\tsaa7146_res_free(dev, RESOURCE_DMA3_BRS);\n}\n\nconst struct vb2_ops vbi_qops = {\n\t.queue_setup\t= queue_setup,\n\t.buf_queue\t= buf_queue,\n\t.buf_init\t= buf_init,\n\t.buf_prepare\t= buf_prepare,\n\t.buf_cleanup\t= buf_cleanup,\n\t.start_streaming = start_streaming,\n\t.stop_streaming = stop_streaming,\n\t.wait_prepare\t= vb2_ops_wait_prepare,\n\t.wait_finish\t= vb2_ops_wait_finish,\n};\n\n \n\nstatic void vbi_init(struct saa7146_dev *dev, struct saa7146_vv *vv)\n{\n\tDEB_VBI(\"dev:%p\\n\", dev);\n\n\tINIT_LIST_HEAD(&vv->vbi_dmaq.queue);\n\n\ttimer_setup(&vv->vbi_dmaq.timeout, saa7146_buffer_timeout, 0);\n\tvv->vbi_dmaq.dev              = dev;\n\n\tinit_waitqueue_head(&vv->vbi_wq);\n}\n\nstatic void vbi_irq_done(struct saa7146_dev *dev, unsigned long status)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\tspin_lock(&dev->slock);\n\n\tif (vv->vbi_dmaq.curr) {\n\t\tDEB_VBI(\"dev:%p, curr:%p\\n\", dev, vv->vbi_dmaq.curr);\n\t\tsaa7146_buffer_finish(dev, &vv->vbi_dmaq, VB2_BUF_STATE_DONE);\n\t} else {\n\t\tDEB_VBI(\"dev:%p\\n\", dev);\n\t}\n\tsaa7146_buffer_next(dev, &vv->vbi_dmaq, 1);\n\n\tspin_unlock(&dev->slock);\n}\n\nconst struct saa7146_use_ops saa7146_vbi_uops = {\n\t.init\t\t= vbi_init,\n\t.irq_done\t= vbi_irq_done,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}