{
  "module_name": "saa7146_hlp.c",
  "hash_id": "cd4b39a813f3069fe2ec7fdef0b944626489af1d8c2af5849459ad23e1fbd63f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/saa7146/saa7146_hlp.c",
  "human_readable_source": "\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <media/drv-intf/saa7146_vv.h>\n\nstatic void calculate_output_format_register(struct saa7146_dev* saa, u32 palette, u32* clip_format)\n{\n\t \n\t*clip_format &= 0x0000ffff;\n\t \n\t*clip_format |=  (( ((palette&0xf00)>>8) << 30) | ((palette&0x00f) << 24) | (((palette&0x0f0)>>4) << 16));\n}\n\nstatic void calculate_hps_source_and_sync(struct saa7146_dev *dev, int source, int sync, u32* hps_ctrl)\n{\n\t*hps_ctrl &= ~(MASK_30 | MASK_31 | MASK_28);\n\t*hps_ctrl |= (source << 30) | (sync << 28);\n}\n\nstatic void calculate_hxo_and_hyo(struct saa7146_vv *vv, u32* hps_h_scale, u32* hps_ctrl)\n{\n\tint hyo = 0, hxo = 0;\n\n\thyo = vv->standard->v_offset;\n\thxo = vv->standard->h_offset;\n\n\t*hps_h_scale\t&= ~(MASK_B0 | 0xf00);\n\t*hps_h_scale\t|= (hxo <<  0);\n\n\t*hps_ctrl\t&= ~(MASK_W0 | MASK_B2);\n\t*hps_ctrl\t|= (hyo << 12);\n}\n\n \n\n \nstatic struct {\n\tu16 hps_coeff;\n\tu16 weight_sum;\n} hps_h_coeff_tab [] = {\n\t{0x00,   2}, {0x02,   4}, {0x00,   4}, {0x06,   8}, {0x02,   8},\n\t{0x08,   8}, {0x00,   8}, {0x1E,  16}, {0x0E,   8}, {0x26,   8},\n\t{0x06,   8}, {0x42,   8}, {0x02,   8}, {0x80,   8}, {0x00,   8},\n\t{0xFE,  16}, {0xFE,   8}, {0x7E,   8}, {0x7E,   8}, {0x3E,   8},\n\t{0x3E,   8}, {0x1E,   8}, {0x1E,   8}, {0x0E,   8}, {0x0E,   8},\n\t{0x06,   8}, {0x06,   8}, {0x02,   8}, {0x02,   8}, {0x00,   8},\n\t{0x00,   8}, {0xFE,  16}, {0xFE,   8}, {0xFE,   8}, {0xFE,   8},\n\t{0xFE,   8}, {0xFE,   8}, {0xFE,   8}, {0xFE,   8}, {0xFE,   8},\n\t{0xFE,   8}, {0xFE,   8}, {0xFE,   8}, {0xFE,   8}, {0xFE,   8},\n\t{0xFE,   8}, {0xFE,   8}, {0xFE,   8}, {0xFE,   8}, {0x7E,   8},\n\t{0x7E,   8}, {0x3E,   8}, {0x3E,   8}, {0x1E,   8}, {0x1E,   8},\n\t{0x0E,   8}, {0x0E,   8}, {0x06,   8}, {0x06,   8}, {0x02,   8},\n\t{0x02,   8}, {0x00,   8}, {0x00,   8}, {0xFE,  16}\n};\n\n \nstatic u8 h_attenuation[] = { 1, 2, 4, 8, 2, 4, 8, 16, 0};\n\n \nstatic int calculate_h_scale_registers(struct saa7146_dev *dev,\n\tint in_x, int out_x, int flip_lr,\n\tu32* hps_ctrl, u32* hps_v_gain, u32* hps_h_prescale, u32* hps_h_scale)\n{\n\t \n\tu32 dcgx = 0, xpsc = 0, xacm = 0, cxy = 0, cxuv = 0;\n\t \n\tu32 xim = 0, xp = 0, xsci =0;\n\t \n\tu32 pfuv = 0;\n\n\t \n\tu32 h_atten = 0, i = 0;\n\n\tif ( 0 == out_x ) {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\t*hps_ctrl &= ~MASK_29;\n\n\t \n\tif (in_x > out_x) {\n\t\txpsc = in_x / out_x;\n\t}\n\telse {\n\t\t \n\t\txpsc = 1;\n\t}\n\n\t \n\tif ( 0 != flip_lr ) {\n\n\t\t \n\t\t*hps_ctrl |= MASK_29;\n\n\t\twhile (in_x / xpsc >= 384 )\n\t\t\txpsc++;\n\t}\n\t \n\telse {\n\t\twhile ( in_x / xpsc >= 768 )\n\t\t\txpsc++;\n\t}\n\n\t \n\tif ( xpsc > 64 )\n\t\txpsc = 64;\n\n\t \n\txacm = 0;\n\n\t \n\tcxy = hps_h_coeff_tab[( (xpsc - 1) < 63 ? (xpsc - 1) : 63 )].hps_coeff;\n\tcxuv = cxy;\n\n\t \n\n\t \n\tif ( (in_x == out_x) && ( 1 == xpsc ) )\n\t\txsci = 0x400;\n\telse\n\t\txsci = ( (1024 * in_x) / (out_x * xpsc) ) + xpsc;\n\n\t \n\txp = 0;\n\n\t \n\tif ( 0x400 == xsci )\n\t\txim = 1;\n\telse\n\t\txim = 0;\n\n\t \n\tif( 1 == xpsc ) {\n\t\txacm = 1;\n\t\tdcgx = 0;\n\t} else {\n\t\txacm = 0;\n\t\t \n\t\th_atten = hps_h_coeff_tab[( (xpsc - 1) < 63 ? (xpsc - 1) : 63 )].weight_sum;\n\n\t\tfor (i = 0; h_attenuation[i] != 0; i++) {\n\t\t\tif (h_attenuation[i] >= h_atten)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdcgx = i;\n\t}\n\n\t \n\tif ( xsci == 0x400)\n\t\tpfuv = 0x00;\n\telse if ( xsci < 0x600)\n\t\tpfuv = 0x01;\n\telse if ( xsci < 0x680)\n\t\tpfuv = 0x11;\n\telse if ( xsci < 0x700)\n\t\tpfuv = 0x22;\n\telse\n\t\tpfuv = 0x33;\n\n\n\t*hps_v_gain  &= MASK_W0|MASK_B2;\n\t*hps_v_gain  |= (pfuv << 24);\n\n\t*hps_h_scale\t&= ~(MASK_W1 | 0xf000);\n\t*hps_h_scale\t|= (xim << 31) | (xp << 24) | (xsci << 12);\n\n\t*hps_h_prescale\t|= (dcgx << 27) | ((xpsc-1) << 18) | (xacm << 17) | (cxy << 8) | (cxuv << 0);\n\n\treturn 0;\n}\n\nstatic struct {\n\tu16 hps_coeff;\n\tu16 weight_sum;\n} hps_v_coeff_tab [] = {\n {0x0100,   2},  {0x0102,   4},  {0x0300,   4},  {0x0106,   8},  {0x0502,   8},\n {0x0708,   8},  {0x0F00,   8},  {0x011E,  16},  {0x110E,  16},  {0x1926,  16},\n {0x3906,  16},  {0x3D42,  16},  {0x7D02,  16},  {0x7F80,  16},  {0xFF00,  16},\n {0x01FE,  32},  {0x01FE,  32},  {0x817E,  32},  {0x817E,  32},  {0xC13E,  32},\n {0xC13E,  32},  {0xE11E,  32},  {0xE11E,  32},  {0xF10E,  32},  {0xF10E,  32},\n {0xF906,  32},  {0xF906,  32},  {0xFD02,  32},  {0xFD02,  32},  {0xFF00,  32},\n {0xFF00,  32},  {0x01FE,  64},  {0x01FE,  64},  {0x01FE,  64},  {0x01FE,  64},\n {0x01FE,  64},  {0x01FE,  64},  {0x01FE,  64},  {0x01FE,  64},  {0x01FE,  64},\n {0x01FE,  64},  {0x01FE,  64},  {0x01FE,  64},  {0x01FE,  64},  {0x01FE,  64},\n {0x01FE,  64},  {0x01FE,  64},  {0x01FE,  64},  {0x01FE,  64},  {0x817E,  64},\n {0x817E,  64},  {0xC13E,  64},  {0xC13E,  64},  {0xE11E,  64},  {0xE11E,  64},\n {0xF10E,  64},  {0xF10E,  64},  {0xF906,  64},  {0xF906,  64},  {0xFD02,  64},\n {0xFD02,  64},  {0xFF00,  64},  {0xFF00,  64},  {0x01FE, 128}\n};\n\n \nstatic u16 v_attenuation[] = { 2, 4, 8, 16, 32, 64, 128, 256, 0};\n\n \nstatic int calculate_v_scale_registers(struct saa7146_dev *dev, enum v4l2_field field,\n\tint in_y, int out_y, u32* hps_v_scale, u32* hps_v_gain)\n{\n\tint lpi = 0;\n\n\t \n\tu32 yacm = 0, ysci = 0, yacl = 0, ypo = 0, ype = 0;\n\t \n\tu32 dcgy = 0, cya_cyb = 0;\n\n\t \n\tu32 v_atten = 0, i = 0;\n\n\t \n\tif ( in_y < out_y ) {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tif (V4L2_FIELD_HAS_BOTH(field)) {\n\t\tif( 2*out_y >= in_y) {\n\t\t\tlpi = 1;\n\t\t}\n\t} else if (field == V4L2_FIELD_TOP\n\t\t|| field == V4L2_FIELD_ALTERNATE\n\t\t|| field == V4L2_FIELD_BOTTOM) {\n\t\tif( 4*out_y >= in_y ) {\n\t\t\tlpi = 1;\n\t\t}\n\t\tout_y *= 2;\n\t}\n\tif( 0 != lpi ) {\n\n\t\tyacm = 0;\n\t\tyacl = 0;\n\t\tcya_cyb = 0x00ff;\n\n\t\t \n\t\tif ( in_y > out_y )\n\t\t\tysci = ((1024 * in_y) / (out_y + 1)) - 1024;\n\t\telse\n\t\t\tysci = 0;\n\n\t\tdcgy = 0;\n\n\t\t \n\t\type = ysci / 16;\n\t\typo = ype + (ysci / 64);\n\n\t} else {\n\t\tyacm = 1;\n\n\t\t \n\t\tysci = (((10 * 1024 * (in_y - out_y - 1)) / in_y) + 9) / 10;\n\n\t\t \n\t\typo = ype = ((ysci + 15) / 16);\n\n\t\t \n\t\tif ( ysci < 512) {\n\t\t\tyacl = 0;\n\t\t} else {\n\t\t\tyacl = ( ysci / (1024 - ysci) );\n\t\t}\n\n\t\t \n\t\tcya_cyb = hps_v_coeff_tab[ (yacl < 63 ? yacl : 63 ) ].hps_coeff;\n\n\t\t \n\t\tv_atten = hps_v_coeff_tab[ (yacl < 63 ? yacl : 63 ) ].weight_sum;\n\n\t\tfor (i = 0; v_attenuation[i] != 0; i++) {\n\t\t\tif (v_attenuation[i] >= v_atten)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdcgy = i;\n\t}\n\n\t \n\t*hps_v_scale\t|= (yacm << 31) | (ysci << 21) | (yacl << 15) | (ypo << 8 ) | (ype << 1);\n\n\t*hps_v_gain\t&= ~(MASK_W0|MASK_B2);\n\t*hps_v_gain\t|= (dcgy << 16) | (cya_cyb << 0);\n\n\treturn 0;\n}\n\n \nstatic void saa7146_set_window(struct saa7146_dev *dev, int width, int height, enum v4l2_field field)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\n\tint source = vv->current_hps_source;\n\tint sync = vv->current_hps_sync;\n\n\tu32 hps_v_scale = 0, hps_v_gain  = 0, hps_ctrl = 0, hps_h_prescale = 0, hps_h_scale = 0;\n\n\t \n\thps_v_scale = 0;  \n\thps_v_gain  = 0;  \n\tcalculate_v_scale_registers(dev, field, vv->standard->v_field*2, height, &hps_v_scale, &hps_v_gain);\n\n\t \n\thps_ctrl\t= 0;\n\thps_h_prescale\t= 0;  \n\thps_h_scale\t= 0;\n\tcalculate_h_scale_registers(dev, vv->standard->h_pixels, width, vv->hflip, &hps_ctrl, &hps_v_gain, &hps_h_prescale, &hps_h_scale);\n\n\t \n\tcalculate_hxo_and_hyo(vv, &hps_h_scale, &hps_ctrl);\n\tcalculate_hps_source_and_sync(dev, source, sync, &hps_ctrl);\n\n\t \n\tsaa7146_write(dev, HPS_V_SCALE,\thps_v_scale);\n\tsaa7146_write(dev, HPS_V_GAIN,\thps_v_gain);\n\tsaa7146_write(dev, HPS_CTRL,\thps_ctrl);\n\tsaa7146_write(dev, HPS_H_PRESCALE,hps_h_prescale);\n\tsaa7146_write(dev, HPS_H_SCALE,\thps_h_scale);\n\n\t \n\tsaa7146_write(dev, MC2, (MASK_05 | MASK_06 | MASK_21 | MASK_22) );\n}\n\nstatic void saa7146_set_output_format(struct saa7146_dev *dev, unsigned long palette)\n{\n\tu32 clip_format = saa7146_read(dev, CLIP_FORMAT_CTRL);\n\n\t \n\tcalculate_output_format_register(dev,palette,&clip_format);\n\n\t \n\tsaa7146_write(dev, CLIP_FORMAT_CTRL, clip_format);\n\tsaa7146_write(dev, MC2, (MASK_05 | MASK_21));\n}\n\n \nvoid saa7146_set_hps_source_and_sync(struct saa7146_dev *dev, int source, int sync)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\tu32 hps_ctrl = 0;\n\n\t \n\thps_ctrl = saa7146_read(dev, HPS_CTRL);\n\n\thps_ctrl &= ~( MASK_31 | MASK_30 | MASK_28 );\n\thps_ctrl |= (source << 30) | (sync << 28);\n\n\t \n\tsaa7146_write(dev, HPS_CTRL, hps_ctrl);\n\tsaa7146_write(dev, MC2, (MASK_05 | MASK_21));\n\n\tvv->current_hps_source = source;\n\tvv->current_hps_sync = sync;\n}\nEXPORT_SYMBOL_GPL(saa7146_set_hps_source_and_sync);\n\nvoid saa7146_write_out_dma(struct saa7146_dev* dev, int which, struct saa7146_video_dma* vdma)\n{\n\tint where = 0;\n\n\tif( which < 1 || which > 3) {\n\t\treturn;\n\t}\n\n\t \n\twhere  = (which-1)*0x18;\n\n\tsaa7146_write(dev, where,\tvdma->base_odd);\n\tsaa7146_write(dev, where+0x04,\tvdma->base_even);\n\tsaa7146_write(dev, where+0x08,\tvdma->prot_addr);\n\tsaa7146_write(dev, where+0x0c,\tvdma->pitch);\n\tsaa7146_write(dev, where+0x10,\tvdma->base_page);\n\tsaa7146_write(dev, where+0x14,\tvdma->num_line_byte);\n\n\t \n\tsaa7146_write(dev, MC2, (MASK_02<<(which-1))|(MASK_18<<(which-1)));\n \n}\n\nstatic int calculate_video_dma_grab_packed(struct saa7146_dev* dev, struct saa7146_buf *buf)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\tstruct v4l2_pix_format *pix = &vv->video_fmt;\n\tstruct saa7146_video_dma vdma1;\n\tstruct saa7146_format *sfmt = saa7146_format_by_fourcc(dev, pix->pixelformat);\n\n\tint width = pix->width;\n\tint height = pix->height;\n\tint bytesperline = pix->bytesperline;\n\tenum v4l2_field field = pix->field;\n\n\tint depth = sfmt->depth;\n\n\tDEB_CAP(\"[size=%dx%d,fields=%s]\\n\",\n\t\twidth, height, v4l2_field_names[field]);\n\n\tif( bytesperline != 0) {\n\t\tvdma1.pitch = bytesperline*2;\n\t} else {\n\t\tvdma1.pitch = (width*depth*2)/8;\n\t}\n\tvdma1.num_line_byte\t= ((vv->standard->v_field<<16) + vv->standard->h_pixels);\n\tvdma1.base_page\t\t= buf->pt[0].dma | ME1 | sfmt->swap;\n\n\tif( 0 != vv->vflip ) {\n\t\tvdma1.prot_addr\t= buf->pt[0].offset;\n\t\tvdma1.base_even\t= buf->pt[0].offset+(vdma1.pitch/2)*height;\n\t\tvdma1.base_odd\t= vdma1.base_even - (vdma1.pitch/2);\n\t} else {\n\t\tvdma1.base_even\t= buf->pt[0].offset;\n\t\tvdma1.base_odd\t= vdma1.base_even + (vdma1.pitch/2);\n\t\tvdma1.prot_addr\t= buf->pt[0].offset+(vdma1.pitch/2)*height;\n\t}\n\n\tif (V4L2_FIELD_HAS_BOTH(field)) {\n\t} else if (field == V4L2_FIELD_ALTERNATE) {\n\t\t \n\t\tif ( vv->last_field == V4L2_FIELD_TOP ) {\n\t\t\tvdma1.base_odd\t= vdma1.prot_addr;\n\t\t\tvdma1.pitch /= 2;\n\t\t} else if ( vv->last_field == V4L2_FIELD_BOTTOM ) {\n\t\t\tvdma1.base_odd\t= vdma1.base_even;\n\t\t\tvdma1.base_even = vdma1.prot_addr;\n\t\t\tvdma1.pitch /= 2;\n\t\t}\n\t} else if (field == V4L2_FIELD_TOP) {\n\t\tvdma1.base_odd\t= vdma1.prot_addr;\n\t\tvdma1.pitch /= 2;\n\t} else if (field == V4L2_FIELD_BOTTOM) {\n\t\tvdma1.base_odd\t= vdma1.base_even;\n\t\tvdma1.base_even = vdma1.prot_addr;\n\t\tvdma1.pitch /= 2;\n\t}\n\n\tif( 0 != vv->vflip ) {\n\t\tvdma1.pitch *= -1;\n\t}\n\n\tsaa7146_write_out_dma(dev, 1, &vdma1);\n\treturn 0;\n}\n\nstatic int calc_planar_422(struct saa7146_vv *vv, struct saa7146_buf *buf, struct saa7146_video_dma *vdma2, struct saa7146_video_dma *vdma3)\n{\n\tstruct v4l2_pix_format *pix = &vv->video_fmt;\n\tint height = pix->height;\n\tint width = pix->width;\n\n\tvdma2->pitch\t= width;\n\tvdma3->pitch\t= width;\n\n\t \n\n\tif( 0 != vv->vflip ) {\n\t\tvdma2->prot_addr\t= buf->pt[1].offset;\n\t\tvdma2->base_even\t= ((vdma2->pitch/2)*height)+buf->pt[1].offset;\n\t\tvdma2->base_odd\t\t= vdma2->base_even - (vdma2->pitch/2);\n\n\t\tvdma3->prot_addr\t= buf->pt[2].offset;\n\t\tvdma3->base_even\t= ((vdma3->pitch/2)*height)+buf->pt[2].offset;\n\t\tvdma3->base_odd\t\t= vdma3->base_even - (vdma3->pitch/2);\n\t} else {\n\t\tvdma3->base_even\t= buf->pt[2].offset;\n\t\tvdma3->base_odd\t\t= vdma3->base_even + (vdma3->pitch/2);\n\t\tvdma3->prot_addr\t= (vdma3->pitch/2)*height+buf->pt[2].offset;\n\n\t\tvdma2->base_even\t= buf->pt[1].offset;\n\t\tvdma2->base_odd\t\t= vdma2->base_even + (vdma2->pitch/2);\n\t\tvdma2->prot_addr\t= (vdma2->pitch/2)*height+buf->pt[1].offset;\n\t}\n\n\treturn 0;\n}\n\nstatic int calc_planar_420(struct saa7146_vv *vv, struct saa7146_buf *buf, struct saa7146_video_dma *vdma2, struct saa7146_video_dma *vdma3)\n{\n\tstruct v4l2_pix_format *pix = &vv->video_fmt;\n\tint height = pix->height;\n\tint width = pix->width;\n\n\tvdma2->pitch\t= width/2;\n\tvdma3->pitch\t= width/2;\n\n\tif( 0 != vv->vflip ) {\n\t\tvdma2->prot_addr\t= buf->pt[2].offset;\n\t\tvdma2->base_even\t= ((vdma2->pitch/2)*height)+buf->pt[2].offset;\n\t\tvdma2->base_odd\t\t= vdma2->base_even - (vdma2->pitch/2);\n\n\t\tvdma3->prot_addr\t= buf->pt[1].offset;\n\t\tvdma3->base_even\t= ((vdma3->pitch/2)*height)+buf->pt[1].offset;\n\t\tvdma3->base_odd\t\t= vdma3->base_even - (vdma3->pitch/2);\n\n\t} else {\n\t\tvdma3->base_even\t= buf->pt[2].offset;\n\t\tvdma3->base_odd\t\t= vdma3->base_even + (vdma3->pitch);\n\t\tvdma3->prot_addr\t= (vdma3->pitch/2)*height+buf->pt[2].offset;\n\n\t\tvdma2->base_even\t= buf->pt[1].offset;\n\t\tvdma2->base_odd\t\t= vdma2->base_even + (vdma2->pitch);\n\t\tvdma2->prot_addr\t= (vdma2->pitch/2)*height+buf->pt[1].offset;\n\t}\n\treturn 0;\n}\n\nstatic int calculate_video_dma_grab_planar(struct saa7146_dev* dev, struct saa7146_buf *buf)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\tstruct v4l2_pix_format *pix = &vv->video_fmt;\n\tstruct saa7146_video_dma vdma1;\n\tstruct saa7146_video_dma vdma2;\n\tstruct saa7146_video_dma vdma3;\n\tstruct saa7146_format *sfmt = saa7146_format_by_fourcc(dev, pix->pixelformat);\n\n\tint width = pix->width;\n\tint height = pix->height;\n\tenum v4l2_field field = pix->field;\n\n\tif (WARN_ON(!buf->pt[0].dma) ||\n\t    WARN_ON(!buf->pt[1].dma) ||\n\t    WARN_ON(!buf->pt[2].dma))\n\t\treturn -1;\n\n\tDEB_CAP(\"[size=%dx%d,fields=%s]\\n\",\n\t\twidth, height, v4l2_field_names[field]);\n\n\t \n\n\t \n\n\tvdma1.pitch\t\t= width*2;\n\tvdma1.num_line_byte\t= ((vv->standard->v_field<<16) + vv->standard->h_pixels);\n\tvdma1.base_page\t\t= buf->pt[0].dma | ME1;\n\n\tif( 0 != vv->vflip ) {\n\t\tvdma1.prot_addr\t= buf->pt[0].offset;\n\t\tvdma1.base_even\t= ((vdma1.pitch/2)*height)+buf->pt[0].offset;\n\t\tvdma1.base_odd\t= vdma1.base_even - (vdma1.pitch/2);\n\t} else {\n\t\tvdma1.base_even\t= buf->pt[0].offset;\n\t\tvdma1.base_odd\t= vdma1.base_even + (vdma1.pitch/2);\n\t\tvdma1.prot_addr\t= (vdma1.pitch/2)*height+buf->pt[0].offset;\n\t}\n\n\tvdma2.num_line_byte\t= 0;  \n\tvdma2.base_page\t\t= buf->pt[1].dma | ME1;\n\n\tvdma3.num_line_byte\t= 0;  \n\tvdma3.base_page\t\t= buf->pt[2].dma | ME1;\n\n\tswitch( sfmt->depth ) {\n\t\tcase 12: {\n\t\t\tcalc_planar_420(vv,buf,&vdma2,&vdma3);\n\t\t\tbreak;\n\t\t}\n\t\tcase 16: {\n\t\t\tcalc_planar_422(vv,buf,&vdma2,&vdma3);\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (V4L2_FIELD_HAS_BOTH(field)) {\n\t} else if (field == V4L2_FIELD_ALTERNATE) {\n\t\t \n\t\tvdma1.base_odd\t= vdma1.prot_addr;\n\t\tvdma1.pitch /= 2;\n\t\tvdma2.base_odd\t= vdma2.prot_addr;\n\t\tvdma2.pitch /= 2;\n\t\tvdma3.base_odd\t= vdma3.prot_addr;\n\t\tvdma3.pitch /= 2;\n\t} else if (field == V4L2_FIELD_TOP) {\n\t\tvdma1.base_odd\t= vdma1.prot_addr;\n\t\tvdma1.pitch /= 2;\n\t\tvdma2.base_odd\t= vdma2.prot_addr;\n\t\tvdma2.pitch /= 2;\n\t\tvdma3.base_odd\t= vdma3.prot_addr;\n\t\tvdma3.pitch /= 2;\n\t} else if (field == V4L2_FIELD_BOTTOM) {\n\t\tvdma1.base_odd\t= vdma1.base_even;\n\t\tvdma1.base_even = vdma1.prot_addr;\n\t\tvdma1.pitch /= 2;\n\t\tvdma2.base_odd\t= vdma2.base_even;\n\t\tvdma2.base_even = vdma2.prot_addr;\n\t\tvdma2.pitch /= 2;\n\t\tvdma3.base_odd\t= vdma3.base_even;\n\t\tvdma3.base_even = vdma3.prot_addr;\n\t\tvdma3.pitch /= 2;\n\t}\n\n\tif( 0 != vv->vflip ) {\n\t\tvdma1.pitch *= -1;\n\t\tvdma2.pitch *= -1;\n\t\tvdma3.pitch *= -1;\n\t}\n\n\tsaa7146_write_out_dma(dev, 1, &vdma1);\n\tif( (sfmt->flags & FORMAT_BYTE_SWAP) != 0 ) {\n\t\tsaa7146_write_out_dma(dev, 3, &vdma2);\n\t\tsaa7146_write_out_dma(dev, 2, &vdma3);\n\t} else {\n\t\tsaa7146_write_out_dma(dev, 2, &vdma2);\n\t\tsaa7146_write_out_dma(dev, 3, &vdma3);\n\t}\n\treturn 0;\n}\n\nstatic void program_capture_engine(struct saa7146_dev *dev, int planar)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\tint count = 0;\n\n\tunsigned long e_wait = vv->current_hps_sync == SAA7146_HPS_SYNC_PORT_A ? CMD_E_FID_A : CMD_E_FID_B;\n\tunsigned long o_wait = vv->current_hps_sync == SAA7146_HPS_SYNC_PORT_A ? CMD_O_FID_A : CMD_O_FID_B;\n\n\t \n\tWRITE_RPS0(CMD_PAUSE | CMD_OAN | CMD_SIG0 | o_wait);\n\tWRITE_RPS0(CMD_PAUSE | CMD_OAN | CMD_SIG0 | e_wait);\n\n\t \n\tWRITE_RPS0(CMD_WR_REG | (1 << 8) | (MC2/4));\n\tWRITE_RPS0(MASK_27 | MASK_11);\n\n\t \n\tWRITE_RPS0(CMD_WR_REG_MASK | (MC1/4));\n\tWRITE_RPS0(MASK_06 | MASK_22);\t\t\t \n\tWRITE_RPS0(MASK_06 | MASK_22);\t\t\t \n\tif( 0 != planar ) {\n\t\t \n\t\tWRITE_RPS0(CMD_WR_REG_MASK | (MC1/4));\n\t\tWRITE_RPS0(MASK_05 | MASK_21);\t\t\t \n\t\tWRITE_RPS0(MASK_05 | MASK_21);\t\t\t \n\n\t\t \n\t\tWRITE_RPS0(CMD_WR_REG_MASK | (MC1/4));\n\t\tWRITE_RPS0(MASK_04 | MASK_20);\t\t\t \n\t\tWRITE_RPS0(MASK_04 | MASK_20);\t\t\t \n\t}\n\n\t \n\tif ( vv->last_field == V4L2_FIELD_INTERLACED ) {\n\t\tWRITE_RPS0(CMD_PAUSE | o_wait);\n\t\tWRITE_RPS0(CMD_PAUSE | e_wait);\n\t} else if ( vv->last_field == V4L2_FIELD_TOP ) {\n\t\tWRITE_RPS0(CMD_PAUSE | (vv->current_hps_sync == SAA7146_HPS_SYNC_PORT_A ? MASK_10 : MASK_09));\n\t\tWRITE_RPS0(CMD_PAUSE | o_wait);\n\t} else if ( vv->last_field == V4L2_FIELD_BOTTOM ) {\n\t\tWRITE_RPS0(CMD_PAUSE | (vv->current_hps_sync == SAA7146_HPS_SYNC_PORT_A ? MASK_10 : MASK_09));\n\t\tWRITE_RPS0(CMD_PAUSE | e_wait);\n\t}\n\n\t \n\tWRITE_RPS0(CMD_WR_REG_MASK | (MC1/4));\n\tWRITE_RPS0(MASK_22 | MASK_06);\t\t\t \n\tWRITE_RPS0(MASK_22);\t\t\t\t \n\tif( 0 != planar ) {\n\t\t \n\t\tWRITE_RPS0(CMD_WR_REG_MASK | (MC1/4));\n\t\tWRITE_RPS0(MASK_05 | MASK_21);\t\t\t \n\t\tWRITE_RPS0(MASK_21);\t\t\t\t \n\n\t\t \n\t\tWRITE_RPS0(CMD_WR_REG_MASK | (MC1/4));\n\t\tWRITE_RPS0(MASK_04 | MASK_20);\t\t\t \n\t\tWRITE_RPS0(MASK_20);\t\t\t\t \n\t}\n\n\t \n\tWRITE_RPS0(CMD_INTERRUPT);\n\n\t \n\tWRITE_RPS0(CMD_STOP);\n}\n\n \nstatic void saa7146_disable_clipping(struct saa7146_dev *dev)\n{\n\tu32 clip_format\t= saa7146_read(dev, CLIP_FORMAT_CTRL);\n\n\t \n\tclip_format &= MASK_W1;\n\n\t \n\tsaa7146_write(dev, CLIP_FORMAT_CTRL, clip_format);\n\tsaa7146_write(dev, MC2, (MASK_05 | MASK_21));\n\n\t \n\tsaa7146_write(dev, MC1, MASK_21);\n}\n\nvoid saa7146_set_capture(struct saa7146_dev *dev, struct saa7146_buf *buf, struct saa7146_buf *next)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\tstruct v4l2_pix_format *pix = &vv->video_fmt;\n\tstruct saa7146_format *sfmt = saa7146_format_by_fourcc(dev, pix->pixelformat);\n\tu32 vdma1_prot_addr;\n\n\tDEB_CAP(\"buf:%p, next:%p\\n\", buf, next);\n\n\tvdma1_prot_addr = saa7146_read(dev, PROT_ADDR1);\n\tif( 0 == vdma1_prot_addr ) {\n\t\t \n\t\tDEB_CAP(\"forcing sync to new frame\\n\");\n\t\tsaa7146_write(dev, MC2, MASK_27 );\n\t}\n\n\tsaa7146_set_window(dev, pix->width, pix->height, pix->field);\n\tsaa7146_set_output_format(dev, sfmt->trans);\n\tsaa7146_disable_clipping(dev);\n\n\tif ( vv->last_field == V4L2_FIELD_INTERLACED ) {\n\t} else if ( vv->last_field == V4L2_FIELD_TOP ) {\n\t\tvv->last_field = V4L2_FIELD_BOTTOM;\n\t} else if ( vv->last_field == V4L2_FIELD_BOTTOM ) {\n\t\tvv->last_field = V4L2_FIELD_TOP;\n\t}\n\n\tif( 0 != IS_PLANAR(sfmt->trans)) {\n\t\tcalculate_video_dma_grab_planar(dev, buf);\n\t\tprogram_capture_engine(dev,1);\n\t} else {\n\t\tcalculate_video_dma_grab_packed(dev, buf);\n\t\tprogram_capture_engine(dev,0);\n\t}\n\n \n\n\t \n\tsaa7146_write(dev, RPS_ADDR0, dev->d_rps0.dma_handle);\n\n\t \n\tsaa7146_write(dev, MC1, (MASK_12 | MASK_28));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}