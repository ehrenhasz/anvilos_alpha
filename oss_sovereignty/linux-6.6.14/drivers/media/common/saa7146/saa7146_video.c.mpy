{
  "module_name": "saa7146_video.c",
  "hash_id": "c63eef5fe12b8a71b9fea44d320d9ad29908f4586f05aaa218f556d3866020d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/saa7146/saa7146_video.c",
  "human_readable_source": "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <media/drv-intf/saa7146_vv.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ctrls.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n \nstatic struct saa7146_format formats[] = {\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_RGB332,\n\t\t.trans\t\t= RGB08_COMPOSED,\n\t\t.depth\t\t= 8,\n\t\t.flags\t\t= 0,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_RGB565,\n\t\t.trans\t\t= RGB16_COMPOSED,\n\t\t.depth\t\t= 16,\n\t\t.flags\t\t= 0,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_BGR24,\n\t\t.trans\t\t= RGB24_COMPOSED,\n\t\t.depth\t\t= 24,\n\t\t.flags\t\t= 0,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_BGR32,\n\t\t.trans\t\t= RGB32_COMPOSED,\n\t\t.depth\t\t= 32,\n\t\t.flags\t\t= 0,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_RGB32,\n\t\t.trans\t\t= RGB32_COMPOSED,\n\t\t.depth\t\t= 32,\n\t\t.flags\t\t= 0,\n\t\t.swap\t\t= 0x2,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_GREY,\n\t\t.trans\t\t= Y8,\n\t\t.depth\t\t= 8,\n\t\t.flags\t\t= 0,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_YUV422P,\n\t\t.trans\t\t= YUV422_DECOMPOSED,\n\t\t.depth\t\t= 16,\n\t\t.flags\t\t= FORMAT_IS_PLANAR,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_YVU420,\n\t\t.trans\t\t= YUV420_DECOMPOSED,\n\t\t.depth\t\t= 12,\n\t\t.flags\t\t= FORMAT_BYTE_SWAP|FORMAT_IS_PLANAR,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_YUV420,\n\t\t.trans\t\t= YUV420_DECOMPOSED,\n\t\t.depth\t\t= 12,\n\t\t.flags\t\t= FORMAT_IS_PLANAR,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_UYVY,\n\t\t.trans\t\t= YUV422_COMPOSED,\n\t\t.depth\t\t= 16,\n\t\t.flags\t\t= 0,\n\t}\n};\n\n \n\nstruct saa7146_format* saa7146_format_by_fourcc(struct saa7146_dev *dev, int fourcc)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(formats); i++) {\n\t\tif (formats[i].pixelformat == fourcc) {\n\t\t\treturn formats+i;\n\t\t}\n\t}\n\n\tDEB_D(\"unknown pixelformat:'%4.4s'\\n\", (char *)&fourcc);\n\treturn NULL;\n}\n\n \n \n\nstatic int saa7146_pgtable_build(struct saa7146_dev *dev, struct saa7146_buf *buf)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\tstruct pci_dev *pci = dev->pci;\n\tstruct sg_table *sgt = vb2_dma_sg_plane_desc(&buf->vb.vb2_buf, 0);\n\tstruct scatterlist *list = sgt->sgl;\n\tint length = sgt->nents;\n\tstruct v4l2_pix_format *pix = &vv->video_fmt;\n\tstruct saa7146_format *sfmt = saa7146_format_by_fourcc(dev, pix->pixelformat);\n\n\tDEB_EE(\"dev:%p, buf:%p, sg_len:%d\\n\", dev, buf, length);\n\n\tif( 0 != IS_PLANAR(sfmt->trans)) {\n\t\tstruct saa7146_pgtable *pt1 = &buf->pt[0];\n\t\tstruct saa7146_pgtable *pt2 = &buf->pt[1];\n\t\tstruct saa7146_pgtable *pt3 = &buf->pt[2];\n\t\tstruct sg_dma_page_iter dma_iter;\n\t\t__le32  *ptr1, *ptr2, *ptr3;\n\t\t__le32 fill;\n\n\t\tint size = pix->width * pix->height;\n\t\tint i, m1, m2, m3, o1, o2;\n\n\t\tswitch( sfmt->depth ) {\n\t\t\tcase 12: {\n\t\t\t\t \n\t\t\t\tm1 = ((size + PAGE_SIZE) / PAGE_SIZE) - 1;\n\t\t\t\tm2 = ((size + (size / 4) + PAGE_SIZE) / PAGE_SIZE) - 1;\n\t\t\t\tm3 = ((size + (size / 2) + PAGE_SIZE) / PAGE_SIZE) - 1;\n\t\t\t\to1 = size % PAGE_SIZE;\n\t\t\t\to2 = (size + (size / 4)) % PAGE_SIZE;\n\t\t\t\tDEB_CAP(\"size:%d, m1:%d, m2:%d, m3:%d, o1:%d, o2:%d\\n\",\n\t\t\t\t\tsize, m1, m2, m3, o1, o2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 16: {\n\t\t\t\t \n\t\t\t\tm1 = ((size + PAGE_SIZE) / PAGE_SIZE) - 1;\n\t\t\t\tm2 = ((size + (size / 2) + PAGE_SIZE) / PAGE_SIZE) - 1;\n\t\t\t\tm3 = ((2 * size + PAGE_SIZE) / PAGE_SIZE) - 1;\n\t\t\t\to1 = size % PAGE_SIZE;\n\t\t\t\to2 = (size + (size / 2)) % PAGE_SIZE;\n\t\t\t\tDEB_CAP(\"size:%d, m1:%d, m2:%d, m3:%d, o1:%d, o2:%d\\n\",\n\t\t\t\t\tsize, m1, m2, m3, o1, o2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tptr1 = pt1->cpu;\n\t\tptr2 = pt2->cpu;\n\t\tptr3 = pt3->cpu;\n\n\t\tfor_each_sg_dma_page(list, &dma_iter, length, 0)\n\t\t\t*ptr1++ = cpu_to_le32(sg_page_iter_dma_address(&dma_iter) - list->offset);\n\n\t\t \n\t\tpt1->offset = sgt->sgl->offset;\n\t\tpt2->offset = pt1->offset + o1;\n\t\tpt3->offset = pt1->offset + o2;\n\n\t\t \n\t\tptr1 = pt1->cpu;\n\t\tfor (i = m1; i <= m2; i++, ptr2++)\n\t\t\t*ptr2 = ptr1[i];\n\t\tfill = *(ptr2 - 1);\n\t\tfor (; i < 1024; i++, ptr2++)\n\t\t\t*ptr2 = fill;\n\t\t \n\t\tptr1 = pt1->cpu;\n\t\tfor (i = m2; i <= m3; i++, ptr3++)\n\t\t\t*ptr3 = ptr1[i];\n\t\tfill = *(ptr3 - 1);\n\t\tfor (; i < 1024; i++, ptr3++)\n\t\t\t*ptr3 = fill;\n\t\t \n\t\tptr1 = pt1->cpu + m1;\n\t\tfill = pt1->cpu[m1];\n\t\tfor (i = m1; i < 1024; i++, ptr1++)\n\t\t\t*ptr1 = fill;\n\t} else {\n\t\tstruct saa7146_pgtable *pt = &buf->pt[0];\n\n\t\treturn saa7146_pgtable_build_single(pci, pt, list, length);\n\t}\n\n\treturn 0;\n}\n\n\n \n \n\nstatic int video_begin(struct saa7146_dev *dev)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\tstruct saa7146_format *fmt = NULL;\n\tunsigned int resource;\n\tint ret = 0;\n\n\tDEB_EE(\"dev:%p\\n\", dev);\n\n\tfmt = saa7146_format_by_fourcc(dev, vv->video_fmt.pixelformat);\n\t \n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tif (0 != (fmt->flags & FORMAT_IS_PLANAR)) {\n\t\tresource = RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP|RESOURCE_DMA3_BRS;\n\t} else {\n\t\tresource = RESOURCE_DMA1_HPS;\n\t}\n\n\tret = saa7146_res_get(dev, resource);\n\tif (0 == ret) {\n\t\tDEB_S(\"cannot get capture resource %d\\n\", resource);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tsaa7146_write(dev, MC2, MASK_27 );\n\n\t \n\tSAA7146_IER_ENABLE(dev, MASK_27);\n\n\treturn 0;\n}\n\nstatic void video_end(struct saa7146_dev *dev)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\tstruct saa7146_format *fmt = NULL;\n\tunsigned long flags;\n\tunsigned int resource;\n\tu32 dmas = 0;\n\tDEB_EE(\"dev:%p\\n\", dev);\n\n\tfmt = saa7146_format_by_fourcc(dev, vv->video_fmt.pixelformat);\n\t \n\tif (!fmt)\n\t\treturn;\n\n\tif (0 != (fmt->flags & FORMAT_IS_PLANAR)) {\n\t\tresource = RESOURCE_DMA1_HPS|RESOURCE_DMA2_CLP|RESOURCE_DMA3_BRS;\n\t\tdmas = MASK_22 | MASK_21 | MASK_20;\n\t} else {\n\t\tresource = RESOURCE_DMA1_HPS;\n\t\tdmas = MASK_22;\n\t}\n\tspin_lock_irqsave(&dev->slock,flags);\n\n\t \n\tsaa7146_write(dev, MC1, MASK_28);\n\n\t \n\tSAA7146_IER_DISABLE(dev, MASK_27);\n\n\t \n\tsaa7146_write(dev, MC1, dmas);\n\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\n\tsaa7146_res_free(dev, resource);\n}\n\nstatic int vidioc_querycap(struct file *file, void *fh, struct v4l2_capability *cap)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\n\tstrscpy((char *)cap->driver, \"saa7146 v4l2\", sizeof(cap->driver));\n\tstrscpy((char *)cap->card, dev->ext->name, sizeof(cap->card));\n\tcap->capabilities = V4L2_CAP_VIDEO_CAPTURE |\n\t\t\t    V4L2_CAP_READWRITE | V4L2_CAP_STREAMING |\n\t\t\t    V4L2_CAP_DEVICE_CAPS;\n\tcap->capabilities |= dev->ext_vv_data->capabilities;\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *fh, struct v4l2_fmtdesc *f)\n{\n\tif (f->index >= ARRAY_SIZE(formats))\n\t\treturn -EINVAL;\n\tf->pixelformat = formats[f->index].pixelformat;\n\treturn 0;\n}\n\nint saa7146_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct saa7146_dev *dev = container_of(ctrl->handler,\n\t\t\t\tstruct saa7146_dev, ctrl_handler);\n\tstruct saa7146_vv *vv = dev->vv_data;\n\tu32 val;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tval = saa7146_read(dev, BCS_CTRL);\n\t\tval &= 0x00ffffff;\n\t\tval |= (ctrl->val << 24);\n\t\tsaa7146_write(dev, BCS_CTRL, val);\n\t\tsaa7146_write(dev, MC2, MASK_22 | MASK_06);\n\t\tbreak;\n\n\tcase V4L2_CID_CONTRAST:\n\t\tval = saa7146_read(dev, BCS_CTRL);\n\t\tval &= 0xff00ffff;\n\t\tval |= (ctrl->val << 16);\n\t\tsaa7146_write(dev, BCS_CTRL, val);\n\t\tsaa7146_write(dev, MC2, MASK_22 | MASK_06);\n\t\tbreak;\n\n\tcase V4L2_CID_SATURATION:\n\t\tval = saa7146_read(dev, BCS_CTRL);\n\t\tval &= 0xffffff00;\n\t\tval |= (ctrl->val << 0);\n\t\tsaa7146_write(dev, BCS_CTRL, val);\n\t\tsaa7146_write(dev, MC2, MASK_22 | MASK_06);\n\t\tbreak;\n\n\tcase V4L2_CID_HFLIP:\n\t\t \n\t\tif (vb2_is_busy(&vv->video_dmaq.q))\n\t\t\treturn -EBUSY;\n\t\tvv->hflip = ctrl->val;\n\t\tbreak;\n\n\tcase V4L2_CID_VFLIP:\n\t\tif (vb2_is_busy(&vv->video_dmaq.q))\n\t\t\treturn -EBUSY;\n\t\tvv->vflip = ctrl->val;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_g_parm(struct file *file, void *fh,\n\t\tstruct v4l2_streamparm *parm)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct saa7146_vv *vv = dev->vv_data;\n\n\tif (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\tparm->parm.capture.readbuffers = 1;\n\tv4l2_video_std_frame_period(vv->standard->id,\n\t\t\t\t    &parm->parm.capture.timeperframe);\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct saa7146_vv *vv = dev->vv_data;\n\n\tf->fmt.pix = vv->video_fmt;\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_vbi_cap(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct saa7146_vv *vv = dev->vv_data;\n\n\tf->fmt.vbi = vv->vbi_fmt;\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct saa7146_vv *vv = dev->vv_data;\n\tstruct saa7146_format *fmt;\n\tenum v4l2_field field;\n\tint maxw, maxh;\n\tint calc_bpl;\n\n\tDEB_EE(\"V4L2_BUF_TYPE_VIDEO_CAPTURE: dev:%p, fh:%p\\n\", dev, fh);\n\n\tfmt = saa7146_format_by_fourcc(dev, f->fmt.pix.pixelformat);\n\tif (NULL == fmt)\n\t\treturn -EINVAL;\n\n\tfield = f->fmt.pix.field;\n\tmaxw  = vv->standard->h_max_out;\n\tmaxh  = vv->standard->v_max_out;\n\n\tif (V4L2_FIELD_ANY == field) {\n\t\tfield = (f->fmt.pix.height > maxh / 2)\n\t\t\t? V4L2_FIELD_INTERLACED\n\t\t\t: V4L2_FIELD_BOTTOM;\n\t}\n\tswitch (field) {\n\tcase V4L2_FIELD_ALTERNATE:\n\tcase V4L2_FIELD_TOP:\n\tcase V4L2_FIELD_BOTTOM:\n\t\tmaxh = maxh / 2;\n\t\tbreak;\n\tdefault:\n\t\tfield = V4L2_FIELD_INTERLACED;\n\t\tbreak;\n\t}\n\n\tf->fmt.pix.field = field;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tif (f->fmt.pix.width < 48)\n\t\tf->fmt.pix.width = 48;\n\tif (f->fmt.pix.height < 32)\n\t\tf->fmt.pix.height = 32;\n\tif (f->fmt.pix.width > maxw)\n\t\tf->fmt.pix.width = maxw;\n\tif (f->fmt.pix.height > maxh)\n\t\tf->fmt.pix.height = maxh;\n\n\tcalc_bpl = (f->fmt.pix.width * fmt->depth) / 8;\n\n\tif (f->fmt.pix.bytesperline < calc_bpl)\n\t\tf->fmt.pix.bytesperline = calc_bpl;\n\n\tif (f->fmt.pix.bytesperline > (2 * PAGE_SIZE * fmt->depth) / 8)  \n\t\tf->fmt.pix.bytesperline = calc_bpl;\n\n\tf->fmt.pix.sizeimage = f->fmt.pix.bytesperline * f->fmt.pix.height;\n\tDEB_D(\"w:%d, h:%d, bytesperline:%d, sizeimage:%d\\n\",\n\t      f->fmt.pix.width, f->fmt.pix.height,\n\t      f->fmt.pix.bytesperline, f->fmt.pix.sizeimage);\n\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct saa7146_vv *vv = dev->vv_data;\n\tint err;\n\n\tDEB_EE(\"V4L2_BUF_TYPE_VIDEO_CAPTURE: dev:%p\\n\", dev);\n\tif (vb2_is_busy(&vv->video_dmaq.q)) {\n\t\tDEB_EE(\"streaming capture is active\\n\");\n\t\treturn -EBUSY;\n\t}\n\terr = vidioc_try_fmt_vid_cap(file, fh, f);\n\tif (0 != err)\n\t\treturn err;\n\tswitch (f->fmt.pix.field) {\n\tcase V4L2_FIELD_ALTERNATE:\n\t\tvv->last_field = V4L2_FIELD_TOP;\n\t\tbreak;\n\tdefault:\n\t\tvv->last_field = V4L2_FIELD_INTERLACED;\n\t\tbreak;\n\t}\n\tvv->video_fmt = f->fmt.pix;\n\tDEB_EE(\"set to pixelformat '%4.4s'\\n\",\n\t       (char *)&vv->video_fmt.pixelformat);\n\treturn 0;\n}\n\nstatic int vidioc_g_std(struct file *file, void *fh, v4l2_std_id *norm)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct saa7146_vv *vv = dev->vv_data;\n\n\t*norm = vv->standard->id;\n\treturn 0;\n}\n\nstatic int vidioc_s_std(struct file *file, void *fh, v4l2_std_id id)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct saa7146_vv *vv = dev->vv_data;\n\tint found = 0;\n\tint i;\n\n\tDEB_EE(\"VIDIOC_S_STD\\n\");\n\n\tfor (i = 0; i < dev->ext_vv_data->num_stds; i++)\n\t\tif (id & dev->ext_vv_data->stds[i].id)\n\t\t\tbreak;\n\n\tif (i != dev->ext_vv_data->num_stds &&\n\t    vv->standard == &dev->ext_vv_data->stds[i])\n\t\treturn 0;\n\n\tif (vb2_is_busy(&vv->video_dmaq.q) || vb2_is_busy(&vv->vbi_dmaq.q)) {\n\t\tDEB_D(\"cannot change video standard while streaming capture is active\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (i != dev->ext_vv_data->num_stds) {\n\t\tvv->standard = &dev->ext_vv_data->stds[i];\n\t\tif (NULL != dev->ext_vv_data->std_callback)\n\t\t\tdev->ext_vv_data->std_callback(dev, vv->standard);\n\t\tfound = 1;\n\t}\n\n\tif (!found) {\n\t\tDEB_EE(\"VIDIOC_S_STD: standard not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tDEB_EE(\"VIDIOC_S_STD: set to standard to '%s'\\n\", vv->standard->name);\n\treturn 0;\n}\n\nconst struct v4l2_ioctl_ops saa7146_video_ioctl_ops = {\n\t.vidioc_querycap             = vidioc_querycap,\n\t.vidioc_enum_fmt_vid_cap     = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap        = vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap      = vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap        = vidioc_s_fmt_vid_cap,\n\t.vidioc_g_std                = vidioc_g_std,\n\t.vidioc_s_std                = vidioc_s_std,\n\t.vidioc_g_parm\t\t     = vidioc_g_parm,\n\t.vidioc_reqbufs\t\t     = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t     = vb2_ioctl_create_bufs,\n\t.vidioc_querybuf\t     = vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t     = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t     = vb2_ioctl_dqbuf,\n\t.vidioc_streamon\t     = vb2_ioctl_streamon,\n\t.vidioc_streamoff\t     = vb2_ioctl_streamoff,\n\t.vidioc_subscribe_event      = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event    = v4l2_event_unsubscribe,\n};\n\nconst struct v4l2_ioctl_ops saa7146_vbi_ioctl_ops = {\n\t.vidioc_querycap             = vidioc_querycap,\n\t.vidioc_g_fmt_vbi_cap        = vidioc_g_fmt_vbi_cap,\n\t.vidioc_try_fmt_vbi_cap      = vidioc_g_fmt_vbi_cap,\n\t.vidioc_s_fmt_vbi_cap        = vidioc_g_fmt_vbi_cap,\n\t.vidioc_g_std                = vidioc_g_std,\n\t.vidioc_s_std                = vidioc_s_std,\n\t.vidioc_g_parm\t\t     = vidioc_g_parm,\n\t.vidioc_reqbufs\t\t     = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t     = vb2_ioctl_create_bufs,\n\t.vidioc_querybuf\t     = vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t     = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t     = vb2_ioctl_dqbuf,\n\t.vidioc_streamon\t     = vb2_ioctl_streamon,\n\t.vidioc_streamoff\t     = vb2_ioctl_streamoff,\n\t.vidioc_subscribe_event      = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event    = v4l2_event_unsubscribe,\n};\n\n \n \n\nstatic int buffer_activate (struct saa7146_dev *dev,\n\t\t     struct saa7146_buf *buf,\n\t\t     struct saa7146_buf *next)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\n\tsaa7146_set_capture(dev,buf,next);\n\n\tmod_timer(&vv->video_dmaq.timeout, jiffies+BUFFER_TIMEOUT);\n\treturn 0;\n}\n\nstatic void release_all_pagetables(struct saa7146_dev *dev, struct saa7146_buf *buf)\n{\n\tsaa7146_pgtable_free(dev->pci, &buf->pt[0]);\n\tsaa7146_pgtable_free(dev->pci, &buf->pt[1]);\n\tsaa7146_pgtable_free(dev->pci, &buf->pt[2]);\n}\n\nstatic int queue_setup(struct vb2_queue *q,\n\t\t       unsigned int *num_buffers, unsigned int *num_planes,\n\t\t       unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct saa7146_dev *dev = vb2_get_drv_priv(q);\n\tunsigned int size = dev->vv_data->video_fmt.sizeimage;\n\n\tif (*num_planes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\t*num_planes = 1;\n\tsizes[0] = size;\n\n\treturn 0;\n}\n\nstatic void buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct saa7146_dev *dev = vb2_get_drv_priv(vq);\n\tstruct saa7146_buf *buf = container_of(vbuf, struct saa7146_buf, vb);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\n\tsaa7146_buffer_queue(dev, &dev->vv_data->video_dmaq, buf);\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nstatic int buf_init(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct saa7146_buf *buf = container_of(vbuf, struct saa7146_buf, vb);\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct saa7146_dev *dev = vb2_get_drv_priv(vq);\n\tstruct saa7146_vv *vv = dev->vv_data;\n\tstruct saa7146_format *sfmt;\n\tint ret;\n\n\tbuf->activate = buffer_activate;\n\tsfmt = saa7146_format_by_fourcc(dev, vv->video_fmt.pixelformat);\n\n\tif (IS_PLANAR(sfmt->trans)) {\n\t\tsaa7146_pgtable_alloc(dev->pci, &buf->pt[0]);\n\t\tsaa7146_pgtable_alloc(dev->pci, &buf->pt[1]);\n\t\tsaa7146_pgtable_alloc(dev->pci, &buf->pt[2]);\n\t} else {\n\t\tsaa7146_pgtable_alloc(dev->pci, &buf->pt[0]);\n\t}\n\n\tret = saa7146_pgtable_build(dev, buf);\n\tif (ret)\n\t\trelease_all_pagetables(dev, buf);\n\treturn ret;\n}\n\nstatic int buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct saa7146_dev *dev = vb2_get_drv_priv(vq);\n\tstruct saa7146_vv *vv = dev->vv_data;\n\tunsigned int size = vv->video_fmt.sizeimage;\n\n\tif (vb2_plane_size(vb, 0) < size)\n\t\treturn -EINVAL;\n\tvb2_set_plane_payload(vb, 0, size);\n\treturn 0;\n}\n\nstatic void buf_cleanup(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct saa7146_buf *buf = container_of(vbuf, struct saa7146_buf, vb);\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct saa7146_dev *dev = vb2_get_drv_priv(vq);\n\n\trelease_all_pagetables(dev, buf);\n}\n\nstatic void return_buffers(struct vb2_queue *q, int state)\n{\n\tstruct saa7146_dev *dev = vb2_get_drv_priv(q);\n\tstruct saa7146_dmaqueue *dq = &dev->vv_data->video_dmaq;\n\tstruct saa7146_buf *buf;\n\n\tif (dq->curr) {\n\t\tbuf = dq->curr;\n\t\tdq->curr = NULL;\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t}\n\twhile (!list_empty(&dq->queue)) {\n\t\tbuf = list_entry(dq->queue.next, struct saa7146_buf, list);\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t}\n}\n\nstatic int start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct saa7146_dev *dev = vb2_get_drv_priv(q);\n\tint ret;\n\n\tif (!vb2_is_streaming(&dev->vv_data->video_dmaq.q))\n\t\tdev->vv_data->seqnr = 0;\n\tret = video_begin(dev);\n\tif (ret)\n\t\treturn_buffers(q, VB2_BUF_STATE_QUEUED);\n\treturn ret;\n}\n\nstatic void stop_streaming(struct vb2_queue *q)\n{\n\tstruct saa7146_dev *dev = vb2_get_drv_priv(q);\n\tstruct saa7146_dmaqueue *dq = &dev->vv_data->video_dmaq;\n\n\tdel_timer(&dq->timeout);\n\tvideo_end(dev);\n\treturn_buffers(q, VB2_BUF_STATE_ERROR);\n}\n\nconst struct vb2_ops video_qops = {\n\t.queue_setup\t= queue_setup,\n\t.buf_queue\t= buf_queue,\n\t.buf_init\t= buf_init,\n\t.buf_prepare\t= buf_prepare,\n\t.buf_cleanup\t= buf_cleanup,\n\t.start_streaming = start_streaming,\n\t.stop_streaming = stop_streaming,\n\t.wait_prepare\t= vb2_ops_wait_prepare,\n\t.wait_finish\t= vb2_ops_wait_finish,\n};\n\n \n \n\nstatic void video_init(struct saa7146_dev *dev, struct saa7146_vv *vv)\n{\n\tINIT_LIST_HEAD(&vv->video_dmaq.queue);\n\n\ttimer_setup(&vv->video_dmaq.timeout, saa7146_buffer_timeout, 0);\n\tvv->video_dmaq.dev              = dev;\n\n\t \n\tvv->standard = &dev->ext_vv_data->stds[0];\n\n\t \n\tvv->current_hps_source = SAA7146_HPS_SOURCE_PORT_A;\n\tvv->current_hps_sync = SAA7146_HPS_SYNC_PORT_A;\n}\n\nstatic void video_irq_done(struct saa7146_dev *dev, unsigned long st)\n{\n\tstruct saa7146_vv *vv = dev->vv_data;\n\tstruct saa7146_dmaqueue *q = &vv->video_dmaq;\n\n\tspin_lock(&dev->slock);\n\tDEB_CAP(\"called\\n\");\n\n\t \n\tif (q->curr)\n\t\tsaa7146_buffer_finish(dev, q, VB2_BUF_STATE_DONE);\n\tsaa7146_buffer_next(dev,q,0);\n\n\tspin_unlock(&dev->slock);\n}\n\nconst struct saa7146_use_ops saa7146_video_uops = {\n\t.init = video_init,\n\t.irq_done = video_irq_done,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}