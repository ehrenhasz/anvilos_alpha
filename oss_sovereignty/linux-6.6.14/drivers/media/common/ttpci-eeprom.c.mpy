{
  "module_name": "ttpci-eeprom.c",
  "hash_id": "699e5e10512b438ec3ee0935b5f8bebf9964e2fed9f8a92e1b9f11a7fe3a7bce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/ttpci-eeprom.c",
  "human_readable_source": "\n \n\n#include <asm/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/i2c.h>\n#include <linux/etherdevice.h>\n\n#include \"ttpci-eeprom.h\"\n\n#if 1\n#define dprintk(x...) do { printk(x); } while (0)\n#else\n#define dprintk(x...) do { } while (0)\n#endif\n\n\nstatic int check_mac_tt(u8 *buf)\n{\n\tint i;\n\tu16 tmp = 0xffff;\n\n\tfor (i = 0; i < 8; i++) {\n\t\ttmp  = (tmp << 8) | ((tmp >> 8) ^ buf[i]);\n\t\ttmp ^= (tmp >> 4) & 0x0f;\n\t\ttmp ^= (tmp << 12) ^ ((tmp & 0xff) << 5);\n\t}\n\ttmp ^= 0xffff;\n\treturn (((tmp >> 8) ^ buf[8]) | ((tmp & 0xff) ^ buf[9]));\n}\n\nstatic int getmac_tt(u8 * decodedMAC, u8 * encodedMAC)\n{\n\tu8 xor[20] = { 0x72, 0x23, 0x68, 0x19, 0x5c, 0xa8, 0x71, 0x2c,\n\t\t       0x54, 0xd3, 0x7b, 0xf1, 0x9E, 0x23, 0x16, 0xf6,\n\t\t       0x1d, 0x36, 0x64, 0x78};\n\tu8 data[20];\n\tint i;\n\n\t \n\tmemcpy(data, encodedMAC, 20);\n\n\tfor (i = 0; i < 20; i++)\n\t\tdata[i] ^= xor[i];\n\tfor (i = 0; i < 10; i++)\n\t\tdata[i] = ((data[2 * i + 1] << 8) | data[2 * i])\n\t\t\t>> ((data[2 * i + 1] >> 6) & 3);\n\n\tif (check_mac_tt(data))\n\t\treturn -ENODEV;\n\n\tdecodedMAC[0] = data[2]; decodedMAC[1] = data[1]; decodedMAC[2] = data[0];\n\tdecodedMAC[3] = data[6]; decodedMAC[4] = data[5]; decodedMAC[5] = data[4];\n\treturn 0;\n}\n\nint ttpci_eeprom_decode_mac(u8 *decodedMAC, u8 *encodedMAC)\n{\n\tu8 xor[20] = { 0x72, 0x23, 0x68, 0x19, 0x5c, 0xa8, 0x71, 0x2c,\n\t\t       0x54, 0xd3, 0x7b, 0xf1, 0x9E, 0x23, 0x16, 0xf6,\n\t\t       0x1d, 0x36, 0x64, 0x78};\n\tu8 data[20];\n\tint i;\n\n\tmemcpy(data, encodedMAC, 20);\n\n\tfor (i = 0; i < 20; i++)\n\t\tdata[i] ^= xor[i];\n\tfor (i = 0; i < 10; i++)\n\t\tdata[i] = ((data[2 * i + 1] << 8) | data[2 * i])\n\t\t\t>> ((data[2 * i + 1] >> 6) & 3);\n\n\tif (check_mac_tt(data))\n\t\treturn -ENODEV;\n\n\tdecodedMAC[0] = data[2];\n\tdecodedMAC[1] = data[1];\n\tdecodedMAC[2] = data[0];\n\tdecodedMAC[3] = data[6];\n\tdecodedMAC[4] = data[5];\n\tdecodedMAC[5] = data[4];\n\treturn 0;\n}\nEXPORT_SYMBOL(ttpci_eeprom_decode_mac);\n\nstatic int ttpci_eeprom_read_encodedMAC(struct i2c_adapter *adapter, u8 * encodedMAC)\n{\n\tint ret;\n\tu8 b0[] = { 0xcc };\n\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = 0x50, .flags = 0, .buf = b0, .len = 1 },\n\t\t{ .addr = 0x50, .flags = I2C_M_RD, .buf = encodedMAC, .len = 20 }\n\t};\n\n\t \n\n\tret = i2c_transfer(adapter, msg, 2);\n\n\tif (ret != 2)\t\t \n\t\treturn (-ENODEV);\n\n\treturn 0;\n}\n\n\nint ttpci_eeprom_parse_mac(struct i2c_adapter *adapter, u8 *proposed_mac)\n{\n\tint ret;\n\tu8 encodedMAC[20];\n\tu8 decodedMAC[6];\n\n\tret = ttpci_eeprom_read_encodedMAC(adapter, encodedMAC);\n\n\tif (ret != 0) {\t\t \n\t\tdprintk(\"Couldn't read from EEPROM: not there?\\n\");\n\t\teth_zero_addr(proposed_mac);\n\t\treturn ret;\n\t}\n\n\tret = getmac_tt(decodedMAC, encodedMAC);\n\tif( ret != 0 ) {\n\t\tdprintk(\"adapter failed MAC signature check\\n\");\n\t\tdprintk(\"encoded MAC from EEPROM was %*phC\",\n\t\t\t(int)sizeof(encodedMAC), &encodedMAC);\n\t\teth_zero_addr(proposed_mac);\n\t\treturn ret;\n\t}\n\n\tmemcpy(proposed_mac, decodedMAC, 6);\n\tdprintk(\"adapter has MAC addr = %pM\\n\", decodedMAC);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(ttpci_eeprom_parse_mac);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ralph Metzler, Marcus Metzler, others\");\nMODULE_DESCRIPTION(\"Decode dvb_net MAC address from EEPROM of PCI DVB cards made by Siemens, Technotrend, Hauppauge\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}