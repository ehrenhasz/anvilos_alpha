{
  "module_name": "smsdvb-debugfs.c",
  "hash_id": "5a9e5f92bc6ac5b38c0b28fab9e52c651658902a3d9823f2911739c77b5cb0f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/siano/smsdvb-debugfs.c",
  "human_readable_source": "\n\n\n\n#include \"smscoreapi.h\"\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/usb.h>\n\n#include <media/dmxdev.h>\n#include <media/dvbdev.h>\n#include <media/dvb_demux.h>\n#include <media/dvb_frontend.h>\n\n#include \"smsdvb.h\"\n\nstatic struct dentry *smsdvb_debugfs_usb_root;\n\nstruct smsdvb_debugfs {\n\tstruct kref\t\trefcount;\n\tspinlock_t\t\tlock;\n\n\tchar\t\t\tstats_data[PAGE_SIZE];\n\tunsigned\t\tstats_count;\n\tbool\t\t\tstats_was_read;\n\n\twait_queue_head_t\tstats_queue;\n};\n\nstatic void smsdvb_print_dvb_stats(struct smsdvb_debugfs *debug_data,\n\t\t\t    struct sms_stats *p)\n{\n\tint n = 0;\n\tchar *buf;\n\n\tspin_lock(&debug_data->lock);\n\tif (debug_data->stats_count) {\n\t\tspin_unlock(&debug_data->lock);\n\t\treturn;\n\t}\n\n\tbuf = debug_data->stats_data;\n\n\tn += sysfs_emit_at(buf, n, \"is_rf_locked = %d\\n\", p->is_rf_locked);\n\tn += sysfs_emit_at(buf, n, \"is_demod_locked = %d\\n\", p->is_demod_locked);\n\tn += sysfs_emit_at(buf, n, \"is_external_lna_on = %d\\n\", p->is_external_lna_on);\n\tn += sysfs_emit_at(buf, n, \"SNR = %d\\n\", p->SNR);\n\tn += sysfs_emit_at(buf, n, \"ber = %d\\n\", p->ber);\n\tn += sysfs_emit_at(buf, n, \"FIB_CRC = %d\\n\", p->FIB_CRC);\n\tn += sysfs_emit_at(buf, n, \"ts_per = %d\\n\", p->ts_per);\n\tn += sysfs_emit_at(buf, n, \"MFER = %d\\n\", p->MFER);\n\tn += sysfs_emit_at(buf, n, \"RSSI = %d\\n\", p->RSSI);\n\tn += sysfs_emit_at(buf, n, \"in_band_pwr = %d\\n\", p->in_band_pwr);\n\tn += sysfs_emit_at(buf, n, \"carrier_offset = %d\\n\", p->carrier_offset);\n\tn += sysfs_emit_at(buf, n, \"modem_state = %d\\n\", p->modem_state);\n\tn += sysfs_emit_at(buf, n, \"frequency = %d\\n\", p->frequency);\n\tn += sysfs_emit_at(buf, n, \"bandwidth = %d\\n\", p->bandwidth);\n\tn += sysfs_emit_at(buf, n, \"transmission_mode = %d\\n\", p->transmission_mode);\n\tn += sysfs_emit_at(buf, n, \"modem_state = %d\\n\", p->modem_state);\n\tn += sysfs_emit_at(buf, n, \"guard_interval = %d\\n\", p->guard_interval);\n\tn += sysfs_emit_at(buf, n, \"code_rate = %d\\n\", p->code_rate);\n\tn += sysfs_emit_at(buf, n, \"lp_code_rate = %d\\n\", p->lp_code_rate);\n\tn += sysfs_emit_at(buf, n, \"hierarchy = %d\\n\", p->hierarchy);\n\tn += sysfs_emit_at(buf, n, \"constellation = %d\\n\", p->constellation);\n\tn += sysfs_emit_at(buf, n, \"burst_size = %d\\n\", p->burst_size);\n\tn += sysfs_emit_at(buf, n, \"burst_duration = %d\\n\", p->burst_duration);\n\tn += sysfs_emit_at(buf, n, \"burst_cycle_time = %d\\n\", p->burst_cycle_time);\n\tn += sysfs_emit_at(buf, n, \"calc_burst_cycle_time = %d\\n\", p->calc_burst_cycle_time);\n\tn += sysfs_emit_at(buf, n, \"num_of_rows = %d\\n\", p->num_of_rows);\n\tn += sysfs_emit_at(buf, n, \"num_of_padd_cols = %d\\n\", p->num_of_padd_cols);\n\tn += sysfs_emit_at(buf, n, \"num_of_punct_cols = %d\\n\", p->num_of_punct_cols);\n\tn += sysfs_emit_at(buf, n, \"error_ts_packets = %d\\n\", p->error_ts_packets);\n\tn += sysfs_emit_at(buf, n, \"total_ts_packets = %d\\n\", p->total_ts_packets);\n\tn += sysfs_emit_at(buf, n, \"num_of_valid_mpe_tlbs = %d\\n\", p->num_of_valid_mpe_tlbs);\n\tn += sysfs_emit_at(buf, n, \"num_of_invalid_mpe_tlbs = %d\\n\", p->num_of_invalid_mpe_tlbs);\n\tn += sysfs_emit_at(buf, n, \"num_of_corrected_mpe_tlbs = %d\\n\",\n\t\t\t   p->num_of_corrected_mpe_tlbs);\n\tn += sysfs_emit_at(buf, n, \"ber_error_count = %d\\n\", p->ber_error_count);\n\tn += sysfs_emit_at(buf, n, \"ber_bit_count = %d\\n\", p->ber_bit_count);\n\tn += sysfs_emit_at(buf, n, \"sms_to_host_tx_errors = %d\\n\", p->sms_to_host_tx_errors);\n\tn += sysfs_emit_at(buf, n, \"pre_ber = %d\\n\", p->pre_ber);\n\tn += sysfs_emit_at(buf, n, \"cell_id = %d\\n\", p->cell_id);\n\tn += sysfs_emit_at(buf, n, \"dvbh_srv_ind_hp = %d\\n\", p->dvbh_srv_ind_hp);\n\tn += sysfs_emit_at(buf, n, \"dvbh_srv_ind_lp = %d\\n\", p->dvbh_srv_ind_lp);\n\tn += sysfs_emit_at(buf, n, \"num_mpe_received = %d\\n\", p->num_mpe_received);\n\n\tdebug_data->stats_count = n;\n\tspin_unlock(&debug_data->lock);\n\twake_up(&debug_data->stats_queue);\n}\n\nstatic void smsdvb_print_isdb_stats(struct smsdvb_debugfs *debug_data,\n\t\t\t     struct sms_isdbt_stats *p)\n{\n\tint i, n = 0;\n\tchar *buf;\n\n\tspin_lock(&debug_data->lock);\n\tif (debug_data->stats_count) {\n\t\tspin_unlock(&debug_data->lock);\n\t\treturn;\n\t}\n\n\tbuf = debug_data->stats_data;\n\n\tn += sysfs_emit_at(buf, n, \"statistics_type = %d\\t\", p->statistics_type);\n\tn += sysfs_emit_at(buf, n, \"full_size = %d\\n\", p->full_size);\n\n\tn += sysfs_emit_at(buf, n, \"is_rf_locked = %d\\t\\t\", p->is_rf_locked);\n\tn += sysfs_emit_at(buf, n, \"is_demod_locked = %d\\t\", p->is_demod_locked);\n\tn += sysfs_emit_at(buf, n, \"is_external_lna_on = %d\\n\", p->is_external_lna_on);\n\tn += sysfs_emit_at(buf, n, \"SNR = %d dB\\t\\t\", p->SNR);\n\tn += sysfs_emit_at(buf, n, \"RSSI = %d dBm\\t\\t\", p->RSSI);\n\tn += sysfs_emit_at(buf, n, \"in_band_pwr = %d dBm\\n\", p->in_band_pwr);\n\tn += sysfs_emit_at(buf, n, \"carrier_offset = %d\\t\", p->carrier_offset);\n\tn += sysfs_emit_at(buf, n, \"bandwidth = %d\\t\\t\", p->bandwidth);\n\tn += sysfs_emit_at(buf, n, \"frequency = %d Hz\\n\", p->frequency);\n\tn += sysfs_emit_at(buf, n, \"transmission_mode = %d\\t\", p->transmission_mode);\n\tn += sysfs_emit_at(buf, n, \"modem_state = %d\\t\\t\", p->modem_state);\n\tn += sysfs_emit_at(buf, n, \"guard_interval = %d\\n\", p->guard_interval);\n\tn += sysfs_emit_at(buf, n, \"system_type = %d\\t\\t\", p->system_type);\n\tn += sysfs_emit_at(buf, n, \"partial_reception = %d\\t\", p->partial_reception);\n\tn += sysfs_emit_at(buf, n, \"num_of_layers = %d\\n\", p->num_of_layers);\n\tn += sysfs_emit_at(buf, n, \"sms_to_host_tx_errors = %d\\n\", p->sms_to_host_tx_errors);\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (p->layer_info[i].number_of_segments < 1 ||\n\t\t    p->layer_info[i].number_of_segments > 13)\n\t\t\tcontinue;\n\n\t\tn += sysfs_emit_at(buf, n, \"\\nLayer %d\\n\", i);\n\t\tn += sysfs_emit_at(buf, n, \"\\tcode_rate = %d\\t\", p->layer_info[i].code_rate);\n\t\tn += sysfs_emit_at(buf, n, \"constellation = %d\\n\", p->layer_info[i].constellation);\n\t\tn += sysfs_emit_at(buf, n, \"\\tber = %-5d\\t\", p->layer_info[i].ber);\n\t\tn += sysfs_emit_at(buf, n, \"\\tber_error_count = %-5d\\t\",\n\t\t\t\t   p->layer_info[i].ber_error_count);\n\t\tn += sysfs_emit_at(buf, n, \"ber_bit_count = %-5d\\n\",\n\t\t\t\t   p->layer_info[i].ber_bit_count);\n\t\tn += sysfs_emit_at(buf, n, \"\\tpre_ber = %-5d\\t\", p->layer_info[i].pre_ber);\n\t\tn += sysfs_emit_at(buf, n, \"\\tts_per = %-5d\\n\", p->layer_info[i].ts_per);\n\t\tn += sysfs_emit_at(buf, n, \"\\terror_ts_packets = %-5d\\t\",\n\t\t\t\t   p->layer_info[i].error_ts_packets);\n\t\tn += sysfs_emit_at(buf, n, \"total_ts_packets = %-5d\\t\",\n\t\t\t\t   p->layer_info[i].total_ts_packets);\n\t\tn += sysfs_emit_at(buf, n, \"ti_ldepth_i = %d\\n\", p->layer_info[i].ti_ldepth_i);\n\t\tn += sysfs_emit_at(buf, n, \"\\tnumber_of_segments = %d\\t\",\n\t\t\t\t   p->layer_info[i].number_of_segments);\n\t\tn += sysfs_emit_at(buf, n, \"tmcc_errors = %d\\n\", p->layer_info[i].tmcc_errors);\n\t}\n\n\tdebug_data->stats_count = n;\n\tspin_unlock(&debug_data->lock);\n\twake_up(&debug_data->stats_queue);\n}\n\nstatic void smsdvb_print_isdb_stats_ex(struct smsdvb_debugfs *debug_data,\n\t\t\t\tstruct sms_isdbt_stats_ex *p)\n{\n\tint i, n = 0;\n\tchar *buf;\n\n\tspin_lock(&debug_data->lock);\n\tif (debug_data->stats_count) {\n\t\tspin_unlock(&debug_data->lock);\n\t\treturn;\n\t}\n\n\tbuf = debug_data->stats_data;\n\n\tn += sysfs_emit_at(buf, n, \"statistics_type = %d\\t\", p->statistics_type);\n\tn += sysfs_emit_at(buf, n, \"full_size = %d\\n\", p->full_size);\n\n\tn += sysfs_emit_at(buf, n, \"is_rf_locked = %d\\t\\t\", p->is_rf_locked);\n\tn += sysfs_emit_at(buf, n, \"is_demod_locked = %d\\t\", p->is_demod_locked);\n\tn += sysfs_emit_at(buf, n, \"is_external_lna_on = %d\\n\", p->is_external_lna_on);\n\tn += sysfs_emit_at(buf, n, \"SNR = %d dB\\t\\t\", p->SNR);\n\tn += sysfs_emit_at(buf, n, \"RSSI = %d dBm\\t\\t\", p->RSSI);\n\tn += sysfs_emit_at(buf, n, \"in_band_pwr = %d dBm\\n\", p->in_band_pwr);\n\tn += sysfs_emit_at(buf, n, \"carrier_offset = %d\\t\", p->carrier_offset);\n\tn += sysfs_emit_at(buf, n, \"bandwidth = %d\\t\\t\", p->bandwidth);\n\tn += sysfs_emit_at(buf, n, \"frequency = %d Hz\\n\", p->frequency);\n\tn += sysfs_emit_at(buf, n, \"transmission_mode = %d\\t\", p->transmission_mode);\n\tn += sysfs_emit_at(buf, n, \"modem_state = %d\\t\\t\", p->modem_state);\n\tn += sysfs_emit_at(buf, n, \"guard_interval = %d\\n\", p->guard_interval);\n\tn += sysfs_emit_at(buf, n, \"system_type = %d\\t\\t\", p->system_type);\n\tn += sysfs_emit_at(buf, n, \"partial_reception = %d\\t\", p->partial_reception);\n\tn += sysfs_emit_at(buf, n, \"num_of_layers = %d\\n\", p->num_of_layers);\n\tn += sysfs_emit_at(buf, n, \"segment_number = %d\\t\", p->segment_number);\n\tn += sysfs_emit_at(buf, n, \"tune_bw = %d\\n\", p->tune_bw);\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (p->layer_info[i].number_of_segments < 1 ||\n\t\t    p->layer_info[i].number_of_segments > 13)\n\t\t\tcontinue;\n\n\t\tn += sysfs_emit_at(buf, n, \"\\nLayer %d\\n\", i);\n\t\tn += sysfs_emit_at(buf, n, \"\\tcode_rate = %d\\t\", p->layer_info[i].code_rate);\n\t\tn += sysfs_emit_at(buf, n, \"constellation = %d\\n\", p->layer_info[i].constellation);\n\t\tn += sysfs_emit_at(buf, n, \"\\tber = %-5d\\t\", p->layer_info[i].ber);\n\t\tn += sysfs_emit_at(buf, n, \"\\tber_error_count = %-5d\\t\",\n\t\t\t\t   p->layer_info[i].ber_error_count);\n\t\tn += sysfs_emit_at(buf, n, \"ber_bit_count = %-5d\\n\",\n\t\t\t\t   p->layer_info[i].ber_bit_count);\n\t\tn += sysfs_emit_at(buf, n, \"\\tpre_ber = %-5d\\t\", p->layer_info[i].pre_ber);\n\t\tn += sysfs_emit_at(buf, n, \"\\tts_per = %-5d\\n\", p->layer_info[i].ts_per);\n\t\tn += sysfs_emit_at(buf, n, \"\\terror_ts_packets = %-5d\\t\",\n\t\t\t\t   p->layer_info[i].error_ts_packets);\n\t\tn += sysfs_emit_at(buf, n, \"total_ts_packets = %-5d\\t\",\n\t\t\t\t   p->layer_info[i].total_ts_packets);\n\t\tn += sysfs_emit_at(buf, n, \"ti_ldepth_i = %d\\n\", p->layer_info[i].ti_ldepth_i);\n\t\tn += sysfs_emit_at(buf, n, \"\\tnumber_of_segments = %d\\t\",\n\t\t\t\t   p->layer_info[i].number_of_segments);\n\t\tn += sysfs_emit_at(buf, n, \"tmcc_errors = %d\\n\", p->layer_info[i].tmcc_errors);\n\t}\n\n\n\tdebug_data->stats_count = n;\n\tspin_unlock(&debug_data->lock);\n\n\twake_up(&debug_data->stats_queue);\n}\n\nstatic int smsdvb_stats_open(struct inode *inode, struct file *file)\n{\n\tstruct smsdvb_client_t *client = inode->i_private;\n\tstruct smsdvb_debugfs *debug_data = client->debug_data;\n\n\tkref_get(&debug_data->refcount);\n\n\tspin_lock(&debug_data->lock);\n\tdebug_data->stats_count = 0;\n\tdebug_data->stats_was_read = false;\n\tspin_unlock(&debug_data->lock);\n\n\tfile->private_data = debug_data;\n\n\treturn 0;\n}\n\nstatic void smsdvb_debugfs_data_release(struct kref *ref)\n{\n\tstruct smsdvb_debugfs *debug_data;\n\n\tdebug_data = container_of(ref, struct smsdvb_debugfs, refcount);\n\tkfree(debug_data);\n}\n\nstatic int smsdvb_stats_wait_read(struct smsdvb_debugfs *debug_data)\n{\n\tint rc = 1;\n\n\tspin_lock(&debug_data->lock);\n\n\tif (debug_data->stats_was_read)\n\t\tgoto exit;\n\n\trc = debug_data->stats_count;\n\nexit:\n\tspin_unlock(&debug_data->lock);\n\treturn rc;\n}\n\nstatic __poll_t smsdvb_stats_poll(struct file *file, poll_table *wait)\n{\n\tstruct smsdvb_debugfs *debug_data = file->private_data;\n\tint rc;\n\n\tkref_get(&debug_data->refcount);\n\n\tpoll_wait(file, &debug_data->stats_queue, wait);\n\n\trc = smsdvb_stats_wait_read(debug_data);\n\tkref_put(&debug_data->refcount, smsdvb_debugfs_data_release);\n\n\treturn rc > 0 ? EPOLLIN | EPOLLRDNORM : 0;\n}\n\nstatic ssize_t smsdvb_stats_read(struct file *file, char __user *user_buf,\n\t\t\t\t      size_t nbytes, loff_t *ppos)\n{\n\tint rc = 0, len;\n\tstruct smsdvb_debugfs *debug_data = file->private_data;\n\n\tkref_get(&debug_data->refcount);\n\n\tif (file->f_flags & O_NONBLOCK) {\n\t\trc = smsdvb_stats_wait_read(debug_data);\n\t\tif (!rc) {\n\t\t\trc = -EWOULDBLOCK;\n\t\t\tgoto ret;\n\t\t}\n\t} else {\n\t\trc = wait_event_interruptible(debug_data->stats_queue,\n\t\t\t\t      smsdvb_stats_wait_read(debug_data));\n\t\tif (rc < 0)\n\t\t\tgoto ret;\n\t}\n\n\tif (debug_data->stats_was_read) {\n\t\trc = 0;\t \n\t\tgoto ret;\n\t}\n\n\tlen = debug_data->stats_count - *ppos;\n\tif (len >= 0)\n\t\trc = simple_read_from_buffer(user_buf, nbytes, ppos,\n\t\t\t\t\t     debug_data->stats_data, len);\n\telse\n\t\trc = 0;\n\n\tif (*ppos >= debug_data->stats_count) {\n\t\tspin_lock(&debug_data->lock);\n\t\tdebug_data->stats_was_read = true;\n\t\tspin_unlock(&debug_data->lock);\n\t}\nret:\n\tkref_put(&debug_data->refcount, smsdvb_debugfs_data_release);\n\treturn rc;\n}\n\nstatic int smsdvb_stats_release(struct inode *inode, struct file *file)\n{\n\tstruct smsdvb_debugfs *debug_data = file->private_data;\n\n\tspin_lock(&debug_data->lock);\n\tdebug_data->stats_was_read = true;\t \n\tspin_unlock(&debug_data->lock);\n\twake_up_interruptible_sync(&debug_data->stats_queue);\n\n\tkref_put(&debug_data->refcount, smsdvb_debugfs_data_release);\n\tfile->private_data = NULL;\n\n\treturn 0;\n}\n\nstatic const struct file_operations debugfs_stats_ops = {\n\t.open = smsdvb_stats_open,\n\t.poll = smsdvb_stats_poll,\n\t.read = smsdvb_stats_read,\n\t.release = smsdvb_stats_release,\n\t.llseek = generic_file_llseek,\n};\n\n \n\nint smsdvb_debugfs_create(struct smsdvb_client_t *client)\n{\n\tstruct smscore_device_t *coredev = client->coredev;\n\tstruct dentry *d;\n\tstruct smsdvb_debugfs *debug_data;\n\n\tif (!smsdvb_debugfs_usb_root || !coredev->is_usb_device)\n\t\treturn -ENODEV;\n\n\tclient->debugfs = debugfs_create_dir(coredev->devpath,\n\t\t\t\t\t     smsdvb_debugfs_usb_root);\n\tif (IS_ERR_OR_NULL(client->debugfs)) {\n\t\tpr_info(\"Unable to create debugfs %s directory.\\n\",\n\t\t\tcoredev->devpath);\n\t\treturn -ENODEV;\n\t}\n\n\td = debugfs_create_file(\"stats\", S_IRUGO | S_IWUSR, client->debugfs,\n\t\t\t\tclient, &debugfs_stats_ops);\n\tif (!d) {\n\t\tdebugfs_remove(client->debugfs);\n\t\treturn -ENOMEM;\n\t}\n\n\tdebug_data = kzalloc(sizeof(*client->debug_data), GFP_KERNEL);\n\tif (!debug_data)\n\t\treturn -ENOMEM;\n\n\tclient->debug_data        = debug_data;\n\tclient->prt_dvb_stats     = smsdvb_print_dvb_stats;\n\tclient->prt_isdb_stats    = smsdvb_print_isdb_stats;\n\tclient->prt_isdb_stats_ex = smsdvb_print_isdb_stats_ex;\n\n\tinit_waitqueue_head(&debug_data->stats_queue);\n\tspin_lock_init(&debug_data->lock);\n\tkref_init(&debug_data->refcount);\n\n\treturn 0;\n}\n\nvoid smsdvb_debugfs_release(struct smsdvb_client_t *client)\n{\n\tif (!client->debugfs)\n\t\treturn;\n\n\tclient->prt_dvb_stats     = NULL;\n\tclient->prt_isdb_stats    = NULL;\n\tclient->prt_isdb_stats_ex = NULL;\n\n\tdebugfs_remove_recursive(client->debugfs);\n\tkref_put(&client->debug_data->refcount, smsdvb_debugfs_data_release);\n\n\tclient->debug_data = NULL;\n\tclient->debugfs = NULL;\n}\n\nvoid smsdvb_debugfs_register(void)\n{\n\tstruct dentry *d;\n\n\t \n\td = debugfs_create_dir(\"smsdvb\", usb_debug_root);\n\tif (IS_ERR_OR_NULL(d)) {\n\t\tpr_err(\"Couldn't create sysfs node for smsdvb\\n\");\n\t\treturn;\n\t}\n\tsmsdvb_debugfs_usb_root = d;\n}\n\nvoid smsdvb_debugfs_unregister(void)\n{\n\tif (!smsdvb_debugfs_usb_root)\n\t\treturn;\n\tdebugfs_remove_recursive(smsdvb_debugfs_usb_root);\n\tsmsdvb_debugfs_usb_root = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}