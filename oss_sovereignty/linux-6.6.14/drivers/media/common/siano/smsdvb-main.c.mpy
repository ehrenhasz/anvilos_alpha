{
  "module_name": "smsdvb-main.c",
  "hash_id": "97aa3fdeddfae85dc27fc79b6d5175e5c4d85b1da989002a653dcb67a47951a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/common/siano/smsdvb-main.c",
  "human_readable_source": "\n \n\n#include \"smscoreapi.h\"\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <asm/div64.h>\n\n#include <media/dmxdev.h>\n#include <media/dvbdev.h>\n#include <media/dvb_demux.h>\n#include <media/dvb_frontend.h>\n\n#include \"sms-cards.h\"\n\n#include \"smsdvb.h\"\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic LIST_HEAD(g_smsdvb_clients);\nstatic DEFINE_MUTEX(g_smsdvb_clientslock);\n\nstatic u32 sms_to_guard_interval_table[] = {\n\t[0] = GUARD_INTERVAL_1_32,\n\t[1] = GUARD_INTERVAL_1_16,\n\t[2] = GUARD_INTERVAL_1_8,\n\t[3] = GUARD_INTERVAL_1_4,\n};\n\nstatic u32 sms_to_code_rate_table[] = {\n\t[0] = FEC_1_2,\n\t[1] = FEC_2_3,\n\t[2] = FEC_3_4,\n\t[3] = FEC_5_6,\n\t[4] = FEC_7_8,\n};\n\n\nstatic u32 sms_to_hierarchy_table[] = {\n\t[0] = HIERARCHY_NONE,\n\t[1] = HIERARCHY_1,\n\t[2] = HIERARCHY_2,\n\t[3] = HIERARCHY_4,\n};\n\nstatic u32 sms_to_modulation_table[] = {\n\t[0] = QPSK,\n\t[1] = QAM_16,\n\t[2] = QAM_64,\n\t[3] = DQPSK,\n};\n\n\n \nstatic void sms_board_dvb3_event(struct smsdvb_client_t *client,\n\t\tenum SMS_DVB3_EVENTS event) {\n\n\tstruct smscore_device_t *coredev = client->coredev;\n\tswitch (event) {\n\tcase DVB3_EVENT_INIT:\n\t\tpr_debug(\"DVB3_EVENT_INIT\\n\");\n\t\tsms_board_event(coredev, BOARD_EVENT_BIND);\n\t\tbreak;\n\tcase DVB3_EVENT_SLEEP:\n\t\tpr_debug(\"DVB3_EVENT_SLEEP\\n\");\n\t\tsms_board_event(coredev, BOARD_EVENT_POWER_SUSPEND);\n\t\tbreak;\n\tcase DVB3_EVENT_HOTPLUG:\n\t\tpr_debug(\"DVB3_EVENT_HOTPLUG\\n\");\n\t\tsms_board_event(coredev, BOARD_EVENT_POWER_INIT);\n\t\tbreak;\n\tcase DVB3_EVENT_FE_LOCK:\n\t\tif (client->event_fe_state != DVB3_EVENT_FE_LOCK) {\n\t\t\tclient->event_fe_state = DVB3_EVENT_FE_LOCK;\n\t\t\tpr_debug(\"DVB3_EVENT_FE_LOCK\\n\");\n\t\t\tsms_board_event(coredev, BOARD_EVENT_FE_LOCK);\n\t\t}\n\t\tbreak;\n\tcase DVB3_EVENT_FE_UNLOCK:\n\t\tif (client->event_fe_state != DVB3_EVENT_FE_UNLOCK) {\n\t\t\tclient->event_fe_state = DVB3_EVENT_FE_UNLOCK;\n\t\t\tpr_debug(\"DVB3_EVENT_FE_UNLOCK\\n\");\n\t\t\tsms_board_event(coredev, BOARD_EVENT_FE_UNLOCK);\n\t\t}\n\t\tbreak;\n\tcase DVB3_EVENT_UNC_OK:\n\t\tif (client->event_unc_state != DVB3_EVENT_UNC_OK) {\n\t\t\tclient->event_unc_state = DVB3_EVENT_UNC_OK;\n\t\t\tpr_debug(\"DVB3_EVENT_UNC_OK\\n\");\n\t\t\tsms_board_event(coredev, BOARD_EVENT_MULTIPLEX_OK);\n\t\t}\n\t\tbreak;\n\tcase DVB3_EVENT_UNC_ERR:\n\t\tif (client->event_unc_state != DVB3_EVENT_UNC_ERR) {\n\t\t\tclient->event_unc_state = DVB3_EVENT_UNC_ERR;\n\t\t\tpr_debug(\"DVB3_EVENT_UNC_ERR\\n\");\n\t\t\tsms_board_event(coredev, BOARD_EVENT_MULTIPLEX_ERRORS);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"Unknown dvb3 api event\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void smsdvb_stats_not_ready(struct dvb_frontend *fe)\n{\n\tstruct smsdvb_client_t *client =\n\t\tcontainer_of(fe, struct smsdvb_client_t, frontend);\n\tstruct smscore_device_t *coredev = client->coredev;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint i, n_layers;\n\n\tswitch (smscore_get_device_mode(coredev)) {\n\tcase DEVICE_MODE_ISDBT:\n\tcase DEVICE_MODE_ISDBT_BDA:\n\t\tn_layers = 4;\n\t\tbreak;\n\tdefault:\n\t\tn_layers = 1;\n\t}\n\n\t \n\tc->strength.len = 1;\n\tc->cnr.len = 1;\n\tc->strength.stat[0].scale = FE_SCALE_DECIBEL;\n\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\n\t \n\tc->post_bit_error.len = n_layers;\n\tc->post_bit_count.len = n_layers;\n\tc->block_error.len = n_layers;\n\tc->block_count.len = n_layers;\n\n\t \n\tfor (i = 0; i < n_layers; i++) {\n\t\tc->post_bit_error.stat[i].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_count.stat[i].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->block_error.stat[i].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->block_count.stat[i].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n}\n\nstatic inline int sms_to_mode(u32 mode)\n{\n\tswitch (mode) {\n\tcase 2:\n\t\treturn TRANSMISSION_MODE_2K;\n\tcase 4:\n\t\treturn TRANSMISSION_MODE_4K;\n\tcase 8:\n\t\treturn TRANSMISSION_MODE_8K;\n\t}\n\treturn TRANSMISSION_MODE_AUTO;\n}\n\nstatic inline int sms_to_isdbt_mode(u32 mode)\n{\n\tswitch (mode) {\n\tcase 1:\n\t\treturn TRANSMISSION_MODE_2K;\n\tcase 2:\n\t\treturn TRANSMISSION_MODE_4K;\n\tcase 3:\n\t\treturn TRANSMISSION_MODE_8K;\n\t}\n\treturn TRANSMISSION_MODE_AUTO;\n}\n\nstatic inline int sms_to_isdbt_guard_interval(u32 interval)\n{\n\tswitch (interval) {\n\tcase 4:\n\t\treturn GUARD_INTERVAL_1_4;\n\tcase 8:\n\t\treturn GUARD_INTERVAL_1_8;\n\tcase 16:\n\t\treturn GUARD_INTERVAL_1_16;\n\tcase 32:\n\t\treturn GUARD_INTERVAL_1_32;\n\t}\n\treturn GUARD_INTERVAL_AUTO;\n}\n\nstatic inline int sms_to_status(u32 is_demod_locked, u32 is_rf_locked)\n{\n\tif (is_demod_locked)\n\t\treturn FE_HAS_SIGNAL  | FE_HAS_CARRIER | FE_HAS_VITERBI |\n\t\t       FE_HAS_SYNC    | FE_HAS_LOCK;\n\n\tif (is_rf_locked)\n\t\treturn FE_HAS_SIGNAL | FE_HAS_CARRIER;\n\n\treturn 0;\n}\n\nstatic inline u32 sms_to_bw(u32 value)\n{\n\treturn value * 1000000;\n}\n\n#define convert_from_table(value, table, defval) ({\t\t\t\\\n\tu32 __ret;\t\t\t\t\t\t\t\\\n\tif (value < ARRAY_SIZE(table))\t\t\t\t\t\\\n\t\t__ret = table[value];\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t__ret = defval;\t\t\t\t\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\\\n})\n\n#define sms_to_guard_interval(value)\t\t\t\t\t\\\n\tconvert_from_table(value, sms_to_guard_interval_table,\t\t\\\n\t\t\t   GUARD_INTERVAL_AUTO);\n\n#define sms_to_code_rate(value)\t\t\t\t\t\t\\\n\tconvert_from_table(value, sms_to_code_rate_table,\t\t\\\n\t\t\t   FEC_NONE);\n\n#define sms_to_hierarchy(value)\t\t\t\t\t\t\\\n\tconvert_from_table(value, sms_to_hierarchy_table,\t\t\\\n\t\t\t   FEC_NONE);\n\n#define sms_to_modulation(value)\t\t\t\t\t\\\n\tconvert_from_table(value, sms_to_modulation_table,\t\t\\\n\t\t\t   FEC_NONE);\n\nstatic void smsdvb_update_tx_params(struct smsdvb_client_t *client,\n\t\t\t\t    struct sms_tx_stats *p)\n{\n\tstruct dvb_frontend *fe = &client->frontend;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tc->frequency = p->frequency;\n\tclient->fe_status = sms_to_status(p->is_demod_locked, 0);\n\tc->bandwidth_hz = sms_to_bw(p->bandwidth);\n\tc->transmission_mode = sms_to_mode(p->transmission_mode);\n\tc->guard_interval = sms_to_guard_interval(p->guard_interval);\n\tc->code_rate_HP = sms_to_code_rate(p->code_rate);\n\tc->code_rate_LP = sms_to_code_rate(p->lp_code_rate);\n\tc->hierarchy = sms_to_hierarchy(p->hierarchy);\n\tc->modulation = sms_to_modulation(p->constellation);\n}\n\nstatic void smsdvb_update_per_slices(struct smsdvb_client_t *client,\n\t\t\t\t     struct RECEPTION_STATISTICS_PER_SLICES_S *p)\n{\n\tstruct dvb_frontend *fe = &client->frontend;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu64 tmp;\n\n\tclient->fe_status = sms_to_status(p->is_demod_locked, p->is_rf_locked);\n\tc->modulation = sms_to_modulation(p->constellation);\n\n\t \n\tc->strength.stat[0].uvalue = p->in_band_power * 1000;\n\n\t \n\tc->cnr.stat[0].svalue = p->snr * 1000;\n\n\t \n\tif (!p->is_demod_locked)\n\t\treturn;\n\n\t \n\tclient->last_per = c->block_error.stat[0].uvalue;\n\tc->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\tc->block_count.stat[0].scale = FE_SCALE_COUNTER;\n\tc->block_error.stat[0].uvalue += p->ets_packets;\n\tc->block_count.stat[0].uvalue += p->ets_packets + p->ts_packets;\n\n\t \n\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\tc->post_bit_error.stat[0].uvalue += p->ber_error_count;\n\tc->post_bit_count.stat[0].uvalue += p->ber_bit_count;\n\n\t \n\ttmp = p->ets_packets * 65535ULL;\n\tif (p->ts_packets + p->ets_packets)\n\t\tdo_div(tmp, p->ts_packets + p->ets_packets);\n\tclient->legacy_per = tmp;\n}\n\nstatic void smsdvb_update_dvb_stats(struct smsdvb_client_t *client,\n\t\t\t\t    struct sms_stats *p)\n{\n\tstruct dvb_frontend *fe = &client->frontend;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tif (client->prt_dvb_stats)\n\t\tclient->prt_dvb_stats(client->debug_data, p);\n\n\tclient->fe_status = sms_to_status(p->is_demod_locked, p->is_rf_locked);\n\n\t \n\tc->frequency = p->frequency;\n\tclient->fe_status = sms_to_status(p->is_demod_locked, 0);\n\tc->bandwidth_hz = sms_to_bw(p->bandwidth);\n\tc->transmission_mode = sms_to_mode(p->transmission_mode);\n\tc->guard_interval = sms_to_guard_interval(p->guard_interval);\n\tc->code_rate_HP = sms_to_code_rate(p->code_rate);\n\tc->code_rate_LP = sms_to_code_rate(p->lp_code_rate);\n\tc->hierarchy = sms_to_hierarchy(p->hierarchy);\n\tc->modulation = sms_to_modulation(p->constellation);\n\n\t \n\tc->lna = p->is_external_lna_on ? 1 : 0;\n\n\t \n\tc->cnr.stat[0].svalue = p->SNR * 1000;\n\n\t \n\tc->strength.stat[0].uvalue = p->in_band_pwr * 1000;\n\n\t \n\tif (!p->is_demod_locked)\n\t\treturn;\n\n\t \n\tclient->last_per = c->block_error.stat[0].uvalue;\n\tc->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\tc->block_count.stat[0].scale = FE_SCALE_COUNTER;\n\tc->block_error.stat[0].uvalue += p->error_ts_packets;\n\tc->block_count.stat[0].uvalue += p->total_ts_packets;\n\n\t \n\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\tc->post_bit_error.stat[0].uvalue += p->ber_error_count;\n\tc->post_bit_count.stat[0].uvalue += p->ber_bit_count;\n\n\t \n\tclient->legacy_ber = p->ber;\n};\n\nstatic void smsdvb_update_isdbt_stats(struct smsdvb_client_t *client,\n\t\t\t\t      struct sms_isdbt_stats *p)\n{\n\tstruct dvb_frontend *fe = &client->frontend;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct sms_isdbt_layer_stats *lr;\n\tint i, n_layers;\n\n\tif (client->prt_isdb_stats)\n\t\tclient->prt_isdb_stats(client->debug_data, p);\n\n\tclient->fe_status = sms_to_status(p->is_demod_locked, p->is_rf_locked);\n\n\t \n\tif (p->statistics_type == 0) {\n\t\tc->strength.stat[0].uvalue = ((s32)p->transmission_mode) * 1000;\n\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\treturn;\n\t}\n\n\t \n\tc->frequency = p->frequency;\n\tc->bandwidth_hz = sms_to_bw(p->bandwidth);\n\tc->transmission_mode = sms_to_isdbt_mode(p->transmission_mode);\n\tc->guard_interval = sms_to_isdbt_guard_interval(p->guard_interval);\n\tc->isdbt_partial_reception = p->partial_reception ? 1 : 0;\n\tn_layers = p->num_of_layers;\n\tif (n_layers < 1)\n\t\tn_layers = 1;\n\tif (n_layers > 3)\n\t\tn_layers = 3;\n\tc->isdbt_layer_enabled = 0;\n\n\t \n\tc->lna = p->is_external_lna_on ? 1 : 0;\n\n\t \n\tc->cnr.stat[0].svalue = p->SNR * 1000;\n\n\t \n\tc->strength.stat[0].uvalue = p->in_band_pwr * 1000;\n\n\t \n\tif (!p->is_demod_locked)\n\t\treturn;\n\n\tclient->last_per = c->block_error.stat[0].uvalue;\n\n\t \n\tc->block_error.stat[0].uvalue = 0;\n\tc->block_count.stat[0].uvalue = 0;\n\tc->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\tc->block_count.stat[0].scale = FE_SCALE_COUNTER;\n\tc->post_bit_error.stat[0].uvalue = 0;\n\tc->post_bit_count.stat[0].uvalue = 0;\n\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\n\tfor (i = 0; i < n_layers; i++) {\n\t\tlr = &p->layer_info[i];\n\n\t\t \n\t\tif (lr->number_of_segments > 0 && lr->number_of_segments < 13) {\n\t\t\tc->isdbt_layer_enabled |= 1 << i;\n\t\t\tc->layer[i].segment_count = lr->number_of_segments;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tc->layer[i].modulation = sms_to_modulation(lr->constellation);\n\t\tc->layer[i].fec = sms_to_code_rate(lr->code_rate);\n\n\t\t \n\t\tc->layer[i].interleaving = (u8)lr->ti_ldepth_i;\n\n\t\t \n\t\tc->block_error.stat[i + 1].scale = FE_SCALE_COUNTER;\n\t\tc->block_count.stat[i + 1].scale = FE_SCALE_COUNTER;\n\t\tc->block_error.stat[i + 1].uvalue += lr->error_ts_packets;\n\t\tc->block_count.stat[i + 1].uvalue += lr->total_ts_packets;\n\n\t\t \n\t\tc->block_error.stat[0].uvalue += lr->error_ts_packets;\n\t\tc->block_count.stat[0].uvalue += lr->total_ts_packets;\n\n\t\t \n\t\tc->post_bit_error.stat[i + 1].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_count.stat[i + 1].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_error.stat[i + 1].uvalue += lr->ber_error_count;\n\t\tc->post_bit_count.stat[i + 1].uvalue += lr->ber_bit_count;\n\n\t\t \n\t\tc->post_bit_error.stat[0].uvalue += lr->ber_error_count;\n\t\tc->post_bit_count.stat[0].uvalue += lr->ber_bit_count;\n\t}\n}\n\nstatic void smsdvb_update_isdbt_stats_ex(struct smsdvb_client_t *client,\n\t\t\t\t\t struct sms_isdbt_stats_ex *p)\n{\n\tstruct dvb_frontend *fe = &client->frontend;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct sms_isdbt_layer_stats *lr;\n\tint i, n_layers;\n\n\tif (client->prt_isdb_stats_ex)\n\t\tclient->prt_isdb_stats_ex(client->debug_data, p);\n\n\t \n\tc->frequency = p->frequency;\n\tclient->fe_status = sms_to_status(p->is_demod_locked, 0);\n\tc->bandwidth_hz = sms_to_bw(p->bandwidth);\n\tc->transmission_mode = sms_to_isdbt_mode(p->transmission_mode);\n\tc->guard_interval = sms_to_isdbt_guard_interval(p->guard_interval);\n\tc->isdbt_partial_reception = p->partial_reception ? 1 : 0;\n\tn_layers = p->num_of_layers;\n\tif (n_layers < 1)\n\t\tn_layers = 1;\n\tif (n_layers > 3)\n\t\tn_layers = 3;\n\tc->isdbt_layer_enabled = 0;\n\n\t \n\tc->lna = p->is_external_lna_on ? 1 : 0;\n\n\t \n\tc->cnr.stat[0].svalue = p->SNR * 1000;\n\n\t \n\tc->strength.stat[0].uvalue = p->in_band_pwr * 1000;\n\n\t \n\tif (!p->is_demod_locked)\n\t\treturn;\n\n\tclient->last_per = c->block_error.stat[0].uvalue;\n\n\t \n\tc->block_error.stat[0].uvalue = 0;\n\tc->block_count.stat[0].uvalue = 0;\n\tc->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\tc->block_count.stat[0].scale = FE_SCALE_COUNTER;\n\tc->post_bit_error.stat[0].uvalue = 0;\n\tc->post_bit_count.stat[0].uvalue = 0;\n\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\n\tc->post_bit_error.len = n_layers + 1;\n\tc->post_bit_count.len = n_layers + 1;\n\tc->block_error.len = n_layers + 1;\n\tc->block_count.len = n_layers + 1;\n\tfor (i = 0; i < n_layers; i++) {\n\t\tlr = &p->layer_info[i];\n\n\t\t \n\t\tif (lr->number_of_segments > 0 && lr->number_of_segments < 13) {\n\t\t\tc->isdbt_layer_enabled |= 1 << i;\n\t\t\tc->layer[i].segment_count = lr->number_of_segments;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tc->layer[i].modulation = sms_to_modulation(lr->constellation);\n\t\tc->layer[i].fec = sms_to_code_rate(lr->code_rate);\n\n\t\t \n\t\tc->layer[i].interleaving = (u8)lr->ti_ldepth_i;\n\n\t\t \n\t\tc->block_error.stat[i + 1].scale = FE_SCALE_COUNTER;\n\t\tc->block_count.stat[i + 1].scale = FE_SCALE_COUNTER;\n\t\tc->block_error.stat[i + 1].uvalue += lr->error_ts_packets;\n\t\tc->block_count.stat[i + 1].uvalue += lr->total_ts_packets;\n\n\t\t \n\t\tc->block_error.stat[0].uvalue += lr->error_ts_packets;\n\t\tc->block_count.stat[0].uvalue += lr->total_ts_packets;\n\n\t\t \n\t\tc->post_bit_error.stat[i + 1].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_count.stat[i + 1].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_error.stat[i + 1].uvalue += lr->ber_error_count;\n\t\tc->post_bit_count.stat[i + 1].uvalue += lr->ber_bit_count;\n\n\t\t \n\t\tc->post_bit_error.stat[0].uvalue += lr->ber_error_count;\n\t\tc->post_bit_count.stat[0].uvalue += lr->ber_bit_count;\n\t}\n}\n\nstatic int smsdvb_onresponse(void *context, struct smscore_buffer_t *cb)\n{\n\tstruct smsdvb_client_t *client = (struct smsdvb_client_t *) context;\n\tstruct sms_msg_hdr *phdr = (struct sms_msg_hdr *) (((u8 *) cb->p)\n\t\t\t+ cb->offset);\n\tvoid *p = phdr + 1;\n\tstruct dvb_frontend *fe = &client->frontend;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tbool is_status_update = false;\n\n\tswitch (phdr->msg_type) {\n\tcase MSG_SMS_DVBT_BDA_DATA:\n\t\t \n\t\tif (client->feed_users && client->has_tuned)\n\t\t\tdvb_dmx_swfilter(&client->demux, p,\n\t\t\t\t\t cb->size - sizeof(struct sms_msg_hdr));\n\t\tbreak;\n\n\tcase MSG_SMS_RF_TUNE_RES:\n\tcase MSG_SMS_ISDBT_TUNE_RES:\n\t\tcomplete(&client->tune_done);\n\t\tbreak;\n\n\tcase MSG_SMS_SIGNAL_DETECTED_IND:\n\t\tclient->fe_status = FE_HAS_SIGNAL  | FE_HAS_CARRIER |\n\t\t\t\t    FE_HAS_VITERBI | FE_HAS_SYNC    |\n\t\t\t\t    FE_HAS_LOCK;\n\n\t\tis_status_update = true;\n\t\tbreak;\n\n\tcase MSG_SMS_NO_SIGNAL_IND:\n\t\tclient->fe_status = 0;\n\n\t\tis_status_update = true;\n\t\tbreak;\n\n\tcase MSG_SMS_TRANSMISSION_IND:\n\t\tsmsdvb_update_tx_params(client, p);\n\n\t\tis_status_update = true;\n\t\tbreak;\n\n\tcase MSG_SMS_HO_PER_SLICES_IND:\n\t\tsmsdvb_update_per_slices(client, p);\n\n\t\tis_status_update = true;\n\t\tbreak;\n\n\tcase MSG_SMS_GET_STATISTICS_RES:\n\t\tswitch (smscore_get_device_mode(client->coredev)) {\n\t\tcase DEVICE_MODE_ISDBT:\n\t\tcase DEVICE_MODE_ISDBT_BDA:\n\t\t\tsmsdvb_update_isdbt_stats(client, p);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tsmsdvb_update_dvb_stats(client, p + sizeof(u32));\n\t\t}\n\n\t\tis_status_update = true;\n\t\tbreak;\n\n\t \n\tcase MSG_SMS_GET_STATISTICS_EX_RES:\n\t\t \n\t\tsmsdvb_update_isdbt_stats_ex(client, p + sizeof(u32));\n\t\tis_status_update = true;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"message not handled\\n\");\n\t}\n\tsmscore_putbuffer(client->coredev, cb);\n\n\tif (is_status_update) {\n\t\tif (client->fe_status & FE_HAS_LOCK) {\n\t\t\tsms_board_dvb3_event(client, DVB3_EVENT_FE_LOCK);\n\t\t\tif (client->last_per == c->block_error.stat[0].uvalue)\n\t\t\t\tsms_board_dvb3_event(client, DVB3_EVENT_UNC_OK);\n\t\t\telse\n\t\t\t\tsms_board_dvb3_event(client, DVB3_EVENT_UNC_ERR);\n\t\t\tclient->has_tuned = true;\n\t\t} else {\n\t\t\tsmsdvb_stats_not_ready(fe);\n\t\t\tclient->has_tuned = false;\n\t\t\tsms_board_dvb3_event(client, DVB3_EVENT_FE_UNLOCK);\n\t\t}\n\t\tcomplete(&client->stats_done);\n\t}\n\n\treturn 0;\n}\n\nstatic void smsdvb_media_device_unregister(struct smsdvb_client_t *client)\n{\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\tstruct smscore_device_t *coredev = client->coredev;\n\n\tif (!coredev->media_dev)\n\t\treturn;\n\tmedia_device_unregister(coredev->media_dev);\n\tmedia_device_cleanup(coredev->media_dev);\n\tkfree(coredev->media_dev);\n\tcoredev->media_dev = NULL;\n#endif\n}\n\nstatic void smsdvb_unregister_client(struct smsdvb_client_t *client)\n{\n\t \n\n\tlist_del(&client->entry);\n\n\tsmsdvb_debugfs_release(client);\n\tsmscore_unregister_client(client->smsclient);\n\tdvb_unregister_frontend(&client->frontend);\n\tdvb_dmxdev_release(&client->dmxdev);\n\tdvb_dmx_release(&client->demux);\n\tsmsdvb_media_device_unregister(client);\n\tdvb_unregister_adapter(&client->adapter);\n\tkfree(client);\n}\n\nstatic void smsdvb_onremove(void *context)\n{\n\tmutex_lock(&g_smsdvb_clientslock);\n\n\tsmsdvb_unregister_client((struct smsdvb_client_t *) context);\n\n\tmutex_unlock(&g_smsdvb_clientslock);\n}\n\nstatic int smsdvb_start_feed(struct dvb_demux_feed *feed)\n{\n\tstruct smsdvb_client_t *client =\n\t\tcontainer_of(feed->demux, struct smsdvb_client_t, demux);\n\tstruct sms_msg_data pid_msg;\n\n\tpr_debug(\"add pid %d(%x)\\n\",\n\t\t  feed->pid, feed->pid);\n\n\tclient->feed_users++;\n\n\tpid_msg.x_msg_header.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;\n\tpid_msg.x_msg_header.msg_dst_id = HIF_TASK;\n\tpid_msg.x_msg_header.msg_flags = 0;\n\tpid_msg.x_msg_header.msg_type  = MSG_SMS_ADD_PID_FILTER_REQ;\n\tpid_msg.x_msg_header.msg_length = sizeof(pid_msg);\n\tpid_msg.msg_data[0] = feed->pid;\n\n\treturn smsclient_sendrequest(client->smsclient,\n\t\t\t\t     &pid_msg, sizeof(pid_msg));\n}\n\nstatic int smsdvb_stop_feed(struct dvb_demux_feed *feed)\n{\n\tstruct smsdvb_client_t *client =\n\t\tcontainer_of(feed->demux, struct smsdvb_client_t, demux);\n\tstruct sms_msg_data pid_msg;\n\n\tpr_debug(\"remove pid %d(%x)\\n\",\n\t\t  feed->pid, feed->pid);\n\n\tclient->feed_users--;\n\n\tpid_msg.x_msg_header.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;\n\tpid_msg.x_msg_header.msg_dst_id = HIF_TASK;\n\tpid_msg.x_msg_header.msg_flags = 0;\n\tpid_msg.x_msg_header.msg_type  = MSG_SMS_REMOVE_PID_FILTER_REQ;\n\tpid_msg.x_msg_header.msg_length = sizeof(pid_msg);\n\tpid_msg.msg_data[0] = feed->pid;\n\n\treturn smsclient_sendrequest(client->smsclient,\n\t\t\t\t     &pid_msg, sizeof(pid_msg));\n}\n\nstatic int smsdvb_sendrequest_and_wait(struct smsdvb_client_t *client,\n\t\t\t\t\tvoid *buffer, size_t size,\n\t\t\t\t\tstruct completion *completion)\n{\n\tint rc;\n\n\trc = smsclient_sendrequest(client->smsclient, buffer, size);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn wait_for_completion_timeout(completion,\n\t\t\t\t\t   msecs_to_jiffies(2000)) ?\n\t\t\t\t\t\t0 : -ETIME;\n}\n\nstatic int smsdvb_send_statistics_request(struct smsdvb_client_t *client)\n{\n\tint rc;\n\tstruct sms_msg_hdr msg;\n\n\t \n\tif (client->get_stats_jiffies &&\n\t   (!time_after(jiffies, client->get_stats_jiffies)))\n\t\treturn 0;\n\tclient->get_stats_jiffies = jiffies + msecs_to_jiffies(100);\n\n\tmsg.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;\n\tmsg.msg_dst_id = HIF_TASK;\n\tmsg.msg_flags = 0;\n\tmsg.msg_length = sizeof(msg);\n\n\tswitch (smscore_get_device_mode(client->coredev)) {\n\tcase DEVICE_MODE_ISDBT:\n\tcase DEVICE_MODE_ISDBT_BDA:\n\t\t \n\t\tif (client->coredev->fw_version >= 0x800)\n\t\t\tmsg.msg_type = MSG_SMS_GET_STATISTICS_EX_REQ;\n\t\telse\n\t\t\tmsg.msg_type = MSG_SMS_GET_STATISTICS_REQ;\n\t\tbreak;\n\tdefault:\n\t\tmsg.msg_type = MSG_SMS_GET_STATISTICS_REQ;\n\t}\n\n\trc = smsdvb_sendrequest_and_wait(client, &msg, sizeof(msg),\n\t\t\t\t\t &client->stats_done);\n\n\treturn rc;\n}\n\nstatic inline int led_feedback(struct smsdvb_client_t *client)\n{\n\tif (!(client->fe_status & FE_HAS_LOCK))\n\t\treturn sms_board_led_feedback(client->coredev, SMS_LED_OFF);\n\n\treturn sms_board_led_feedback(client->coredev,\n\t\t\t\t     (client->legacy_ber == 0) ?\n\t\t\t\t     SMS_LED_HI : SMS_LED_LO);\n}\n\nstatic int smsdvb_read_status(struct dvb_frontend *fe, enum fe_status *stat)\n{\n\tint rc;\n\tstruct smsdvb_client_t *client;\n\tclient = container_of(fe, struct smsdvb_client_t, frontend);\n\n\trc = smsdvb_send_statistics_request(client);\n\n\t*stat = client->fe_status;\n\n\tled_feedback(client);\n\n\treturn rc;\n}\n\nstatic int smsdvb_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tint rc;\n\tstruct smsdvb_client_t *client;\n\n\tclient = container_of(fe, struct smsdvb_client_t, frontend);\n\n\trc = smsdvb_send_statistics_request(client);\n\n\t*ber = client->legacy_ber;\n\n\tled_feedback(client);\n\n\treturn rc;\n}\n\nstatic int smsdvb_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint rc;\n\ts32 power = (s32) c->strength.stat[0].uvalue;\n\tstruct smsdvb_client_t *client;\n\n\tclient = container_of(fe, struct smsdvb_client_t, frontend);\n\n\trc = smsdvb_send_statistics_request(client);\n\n\tif (power < -95)\n\t\t*strength = 0;\n\t\telse if (power > -29)\n\t\t\t*strength = 65535;\n\t\telse\n\t\t\t*strength = (power + 95) * 65535 / 66;\n\n\tled_feedback(client);\n\n\treturn rc;\n}\n\nstatic int smsdvb_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint rc;\n\tstruct smsdvb_client_t *client;\n\n\tclient = container_of(fe, struct smsdvb_client_t, frontend);\n\n\trc = smsdvb_send_statistics_request(client);\n\n\t \n\t*snr = ((u32)c->cnr.stat[0].svalue) / 100;\n\n\tled_feedback(client);\n\n\treturn rc;\n}\n\nstatic int smsdvb_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tint rc;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct smsdvb_client_t *client;\n\n\tclient = container_of(fe, struct smsdvb_client_t, frontend);\n\n\trc = smsdvb_send_statistics_request(client);\n\n\t*ucblocks = c->block_error.stat[0].uvalue;\n\n\tled_feedback(client);\n\n\treturn rc;\n}\n\nstatic int smsdvb_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t    struct dvb_frontend_tune_settings *tune)\n{\n\tpr_debug(\"\\n\");\n\n\ttune->min_delay_ms = 400;\n\ttune->step_size = 250000;\n\ttune->max_drift = 0;\n\treturn 0;\n}\n\nstatic int smsdvb_dvbt_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct smsdvb_client_t *client =\n\t\tcontainer_of(fe, struct smsdvb_client_t, frontend);\n\n\tstruct {\n\t\tstruct sms_msg_hdr\tmsg;\n\t\tu32\t\tData[3];\n\t} msg;\n\n\tint ret;\n\n\tclient->fe_status = 0;\n\tclient->event_fe_state = -1;\n\tclient->event_unc_state = -1;\n\tfe->dtv_property_cache.delivery_system = SYS_DVBT;\n\n\tmsg.msg.msg_src_id = DVBT_BDA_CONTROL_MSG_ID;\n\tmsg.msg.msg_dst_id = HIF_TASK;\n\tmsg.msg.msg_flags = 0;\n\tmsg.msg.msg_type = MSG_SMS_RF_TUNE_REQ;\n\tmsg.msg.msg_length = sizeof(msg);\n\tmsg.Data[0] = c->frequency;\n\tmsg.Data[2] = 12000000;\n\n\tpr_debug(\"%s: freq %d band %d\\n\", __func__, c->frequency,\n\t\t c->bandwidth_hz);\n\n\tswitch (c->bandwidth_hz / 1000000) {\n\tcase 8:\n\t\tmsg.Data[1] = BW_8_MHZ;\n\t\tbreak;\n\tcase 7:\n\t\tmsg.Data[1] = BW_7_MHZ;\n\t\tbreak;\n\tcase 6:\n\t\tmsg.Data[1] = BW_6_MHZ;\n\t\tbreak;\n\tcase 0:\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t \n\tret = sms_board_lna_control(client->coredev, 0);\n\tif (ret == 0) {\n\t\tenum fe_status status;\n\n\t\t \n\t\tret = smsdvb_sendrequest_and_wait(client, &msg, sizeof(msg),\n\t\t\t\t\t\t  &client->tune_done);\n\n\t\tsmsdvb_read_status(fe, &status);\n\n\t\tif (status & FE_HAS_LOCK)\n\t\t\treturn ret;\n\n\t\t \n\t\tsms_board_lna_control(client->coredev, 1);\n\t}\n\n\treturn smsdvb_sendrequest_and_wait(client, &msg, sizeof(msg),\n\t\t\t\t\t   &client->tune_done);\n}\n\nstatic int smsdvb_isdbt_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct smsdvb_client_t *client =\n\t\tcontainer_of(fe, struct smsdvb_client_t, frontend);\n\tint board_id = smscore_get_board_id(client->coredev);\n\tstruct sms_board *board = sms_get_board(board_id);\n\tenum sms_device_type_st type = board->type;\n\tint ret;\n\n\tstruct {\n\t\tstruct sms_msg_hdr\tmsg;\n\t\tu32\t\tData[4];\n\t} msg;\n\n\tfe->dtv_property_cache.delivery_system = SYS_ISDBT;\n\n\tmsg.msg.msg_src_id  = DVBT_BDA_CONTROL_MSG_ID;\n\tmsg.msg.msg_dst_id  = HIF_TASK;\n\tmsg.msg.msg_flags  = 0;\n\tmsg.msg.msg_type   = MSG_SMS_ISDBT_TUNE_REQ;\n\tmsg.msg.msg_length = sizeof(msg);\n\n\tif (c->isdbt_sb_segment_idx == -1)\n\t\tc->isdbt_sb_segment_idx = 0;\n\n\tif (!c->isdbt_layer_enabled)\n\t\tc->isdbt_layer_enabled = 7;\n\n\tmsg.Data[0] = c->frequency;\n\tmsg.Data[1] = BW_ISDBT_1SEG;\n\tmsg.Data[2] = 12000000;\n\tmsg.Data[3] = c->isdbt_sb_segment_idx;\n\n\tif (c->isdbt_partial_reception) {\n\t\tif ((type == SMS_PELE || type == SMS_RIO) &&\n\t\t    c->isdbt_sb_segment_count > 3)\n\t\t\tmsg.Data[1] = BW_ISDBT_13SEG;\n\t\telse if (c->isdbt_sb_segment_count > 1)\n\t\t\tmsg.Data[1] = BW_ISDBT_3SEG;\n\t} else if (type == SMS_PELE || type == SMS_RIO)\n\t\tmsg.Data[1] = BW_ISDBT_13SEG;\n\n\tc->bandwidth_hz = 6000000;\n\n\tpr_debug(\"freq %d segwidth %d segindex %d\\n\",\n\t\t c->frequency, c->isdbt_sb_segment_count,\n\t\t c->isdbt_sb_segment_idx);\n\n\t \n\tret = sms_board_lna_control(client->coredev, 0);\n\tif (ret == 0) {\n\t\tenum fe_status status;\n\n\t\t \n\t\tret = smsdvb_sendrequest_and_wait(client, &msg, sizeof(msg),\n\t\t\t\t\t\t  &client->tune_done);\n\n\t\tsmsdvb_read_status(fe, &status);\n\n\t\tif (status & FE_HAS_LOCK)\n\t\t\treturn ret;\n\n\t\t \n\t\tsms_board_lna_control(client->coredev, 1);\n\t}\n\treturn smsdvb_sendrequest_and_wait(client, &msg, sizeof(msg),\n\t\t\t\t\t   &client->tune_done);\n}\n\nstatic int smsdvb_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct smsdvb_client_t *client =\n\t\tcontainer_of(fe, struct smsdvb_client_t, frontend);\n\tstruct smscore_device_t *coredev = client->coredev;\n\n\tsmsdvb_stats_not_ready(fe);\n\tc->strength.stat[0].uvalue = 0;\n\tc->cnr.stat[0].uvalue = 0;\n\n\tclient->has_tuned = false;\n\n\tswitch (smscore_get_device_mode(coredev)) {\n\tcase DEVICE_MODE_DVBT:\n\tcase DEVICE_MODE_DVBT_BDA:\n\t\treturn smsdvb_dvbt_set_frontend(fe);\n\tcase DEVICE_MODE_ISDBT:\n\tcase DEVICE_MODE_ISDBT_BDA:\n\t\treturn smsdvb_isdbt_set_frontend(fe);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int smsdvb_init(struct dvb_frontend *fe)\n{\n\tstruct smsdvb_client_t *client =\n\t\tcontainer_of(fe, struct smsdvb_client_t, frontend);\n\n\tsms_board_power(client->coredev, 1);\n\n\tsms_board_dvb3_event(client, DVB3_EVENT_INIT);\n\treturn 0;\n}\n\nstatic int smsdvb_sleep(struct dvb_frontend *fe)\n{\n\tstruct smsdvb_client_t *client =\n\t\tcontainer_of(fe, struct smsdvb_client_t, frontend);\n\n\tsms_board_led_feedback(client->coredev, SMS_LED_OFF);\n\tsms_board_power(client->coredev, 0);\n\n\tsms_board_dvb3_event(client, DVB3_EVENT_SLEEP);\n\n\treturn 0;\n}\n\nstatic void smsdvb_release(struct dvb_frontend *fe)\n{\n\t \n}\n\nstatic const struct dvb_frontend_ops smsdvb_fe_ops = {\n\t.info = {\n\t\t.name\t\t\t= \"Siano Mobile Digital MDTV Receiver\",\n\t\t.frequency_min_hz\t=  44250 * kHz,\n\t\t.frequency_max_hz\t= 867250 * kHz,\n\t\t.frequency_stepsize_hz\t=    250 * kHz,\n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |\n\t\t\tFE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\tFE_CAN_RECOVER |\n\t\t\tFE_CAN_HIERARCHY_AUTO,\n\t},\n\n\t.release = smsdvb_release,\n\n\t.set_frontend = smsdvb_set_frontend,\n\t.get_tune_settings = smsdvb_get_tune_settings,\n\n\t.read_status = smsdvb_read_status,\n\t.read_ber = smsdvb_read_ber,\n\t.read_signal_strength = smsdvb_read_signal_strength,\n\t.read_snr = smsdvb_read_snr,\n\t.read_ucblocks = smsdvb_read_ucblocks,\n\n\t.init = smsdvb_init,\n\t.sleep = smsdvb_sleep,\n};\n\nstatic int smsdvb_hotplug(struct smscore_device_t *coredev,\n\t\t\t  struct device *device, int arrival)\n{\n\tstruct smsclient_params_t params;\n\tstruct smsdvb_client_t *client;\n\tint rc;\n\n\t \n\tif (!arrival)\n\t\treturn 0;\n\tclient = kzalloc(sizeof(struct smsdvb_client_t), GFP_KERNEL);\n\tif (!client)\n\t\treturn -ENOMEM;\n\n\t \n\trc = dvb_register_adapter(&client->adapter,\n\t\t\t\t  sms_get_board(\n\t\t\t\t\tsmscore_get_board_id(coredev))->name,\n\t\t\t\t  THIS_MODULE, device, adapter_nr);\n\tif (rc < 0) {\n\t\tpr_err(\"dvb_register_adapter() failed %d\\n\", rc);\n\t\tgoto adapter_error;\n\t}\n\tdvb_register_media_controller(&client->adapter, coredev->media_dev);\n\n\t \n\tclient->demux.dmx.capabilities = DMX_TS_FILTERING;\n\tclient->demux.filternum = 32;  \n\tclient->demux.feednum = 32;\n\tclient->demux.start_feed = smsdvb_start_feed;\n\tclient->demux.stop_feed = smsdvb_stop_feed;\n\n\trc = dvb_dmx_init(&client->demux);\n\tif (rc < 0) {\n\t\tpr_err(\"dvb_dmx_init failed %d\\n\", rc);\n\t\tgoto dvbdmx_error;\n\t}\n\n\t \n\tclient->dmxdev.filternum = 32;\n\tclient->dmxdev.demux = &client->demux.dmx;\n\tclient->dmxdev.capabilities = 0;\n\n\trc = dvb_dmxdev_init(&client->dmxdev, &client->adapter);\n\tif (rc < 0) {\n\t\tpr_err(\"dvb_dmxdev_init failed %d\\n\", rc);\n\t\tgoto dmxdev_error;\n\t}\n\n\t \n\tmemcpy(&client->frontend.ops, &smsdvb_fe_ops,\n\t       sizeof(struct dvb_frontend_ops));\n\n\tswitch (smscore_get_device_mode(coredev)) {\n\tcase DEVICE_MODE_DVBT:\n\tcase DEVICE_MODE_DVBT_BDA:\n\t\tclient->frontend.ops.delsys[0] = SYS_DVBT;\n\t\tbreak;\n\tcase DEVICE_MODE_ISDBT:\n\tcase DEVICE_MODE_ISDBT_BDA:\n\t\tclient->frontend.ops.delsys[0] = SYS_ISDBT;\n\t\tbreak;\n\t}\n\n\trc = dvb_register_frontend(&client->adapter, &client->frontend);\n\tif (rc < 0) {\n\t\tpr_err(\"frontend registration failed %d\\n\", rc);\n\t\tgoto frontend_error;\n\t}\n\n\tparams.initial_id = 1;\n\tparams.data_type = MSG_SMS_DVBT_BDA_DATA;\n\tparams.onresponse_handler = smsdvb_onresponse;\n\tparams.onremove_handler = smsdvb_onremove;\n\tparams.context = client;\n\n\trc = smscore_register_client(coredev, &params, &client->smsclient);\n\tif (rc < 0) {\n\t\tpr_err(\"smscore_register_client() failed %d\\n\", rc);\n\t\tgoto client_error;\n\t}\n\n\tclient->coredev = coredev;\n\n\tinit_completion(&client->tune_done);\n\tinit_completion(&client->stats_done);\n\n\tmutex_lock(&g_smsdvb_clientslock);\n\n\tlist_add(&client->entry, &g_smsdvb_clients);\n\n\tmutex_unlock(&g_smsdvb_clientslock);\n\n\tclient->event_fe_state = -1;\n\tclient->event_unc_state = -1;\n\tsms_board_dvb3_event(client, DVB3_EVENT_HOTPLUG);\n\n\tsms_board_setup(coredev);\n\n\tif (smsdvb_debugfs_create(client) < 0)\n\t\tpr_info(\"failed to create debugfs node\\n\");\n\n\trc = dvb_create_media_graph(&client->adapter, true);\n\tif (rc < 0) {\n\t\tpr_err(\"dvb_create_media_graph failed %d\\n\", rc);\n\t\tgoto media_graph_error;\n\t}\n\n\tpr_info(\"DVB interface registered.\\n\");\n\treturn 0;\n\nmedia_graph_error:\n\tmutex_lock(&g_smsdvb_clientslock);\n\tlist_del(&client->entry);\n\tmutex_unlock(&g_smsdvb_clientslock);\n\n\tsmsdvb_debugfs_release(client);\n\nclient_error:\n\tdvb_unregister_frontend(&client->frontend);\n\nfrontend_error:\n\tdvb_dmxdev_release(&client->dmxdev);\n\ndmxdev_error:\n\tdvb_dmx_release(&client->demux);\n\ndvbdmx_error:\n\tsmsdvb_media_device_unregister(client);\n\tdvb_unregister_adapter(&client->adapter);\n\nadapter_error:\n\tkfree(client);\n\treturn rc;\n}\n\nstatic int __init smsdvb_module_init(void)\n{\n\tint rc;\n\n\tsmsdvb_debugfs_register();\n\n\trc = smscore_register_hotplug(smsdvb_hotplug);\n\n\tpr_debug(\"\\n\");\n\n\treturn rc;\n}\n\nstatic void __exit smsdvb_module_exit(void)\n{\n\tsmscore_unregister_hotplug(smsdvb_hotplug);\n\n\tmutex_lock(&g_smsdvb_clientslock);\n\n\twhile (!list_empty(&g_smsdvb_clients))\n\t\tsmsdvb_unregister_client((struct smsdvb_client_t *)g_smsdvb_clients.next);\n\n\tsmsdvb_debugfs_unregister();\n\n\tmutex_unlock(&g_smsdvb_clientslock);\n}\n\nmodule_init(smsdvb_module_init);\nmodule_exit(smsdvb_module_exit);\n\nMODULE_DESCRIPTION(\"SMS DVB subsystem adaptation module\");\nMODULE_AUTHOR(\"Siano Mobile Silicon, Inc. (uris@siano-ms.com)\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}