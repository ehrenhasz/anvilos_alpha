{
  "module_name": "aspeed-video.c",
  "hash_id": "cf93611e9908fc130c23cc434eb19749bfcaa9b8ab0e4fde49c52729a2c4ee25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/aspeed/aspeed-video.c",
  "human_readable_source": "\n\n\n\n#include <linux/atomic.h>\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/v4l2-controls.h>\n#include <linux/videodev2.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n#include <linux/debugfs.h>\n#include <linux/ktime.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-dv-timings.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-dma-contig.h>\n#include <uapi/linux/aspeed-video.h>\n\n#define ASPEED_VIDEO_V4L2_MIN_BUF_REQ 3\n\n#define DEVICE_NAME\t\t\t\"aspeed-video\"\n\n#define ASPEED_VIDEO_JPEG_NUM_QUALITIES\t12\n#define ASPEED_VIDEO_JPEG_HEADER_SIZE\t10\n#define ASPEED_VIDEO_JPEG_QUANT_SIZE\t116\n#define ASPEED_VIDEO_JPEG_DCT_SIZE\t34\n\n#define MAX_FRAME_RATE\t\t\t60\n#define MAX_HEIGHT\t\t\t1200\n#define MAX_WIDTH\t\t\t1920\n#define MIN_HEIGHT\t\t\t480\n#define MIN_WIDTH\t\t\t640\n\n#define NUM_POLARITY_CHECKS\t\t10\n#define INVALID_RESOLUTION_RETRIES\t2\n#define INVALID_RESOLUTION_DELAY\tmsecs_to_jiffies(250)\n#define RESOLUTION_CHANGE_DELAY\t\tmsecs_to_jiffies(500)\n#define MODE_DETECT_TIMEOUT\t\tmsecs_to_jiffies(500)\n#define STOP_TIMEOUT\t\t\tmsecs_to_jiffies(1000)\n#define DIRECT_FETCH_THRESHOLD\t\t0x0c0000  \n\n#define VE_MAX_SRC_BUFFER_SIZE\t\t0x8ca000  \n#define VE_JPEG_HEADER_SIZE\t\t0x006000  \n#define VE_BCD_BUFF_SIZE\t\t0x9000  \n\n#define VE_PROTECTION_KEY\t\t0x000\n#define  VE_PROTECTION_KEY_UNLOCK\t0x1a038aa8\n\n#define VE_SEQ_CTRL\t\t\t0x004\n#define  VE_SEQ_CTRL_TRIG_MODE_DET\tBIT(0)\n#define  VE_SEQ_CTRL_TRIG_CAPTURE\tBIT(1)\n#define  VE_SEQ_CTRL_FORCE_IDLE\t\tBIT(2)\n#define  VE_SEQ_CTRL_MULT_FRAME\t\tBIT(3)\n#define  VE_SEQ_CTRL_TRIG_COMP\t\tBIT(4)\n#define  VE_SEQ_CTRL_AUTO_COMP\t\tBIT(5)\n#define  VE_SEQ_CTRL_EN_WATCHDOG\tBIT(7)\n#define  VE_SEQ_CTRL_YUV420\t\tBIT(10)\n#define  VE_SEQ_CTRL_COMP_FMT\t\tGENMASK(11, 10)\n#define  VE_SEQ_CTRL_HALT\t\tBIT(12)\n#define  VE_SEQ_CTRL_EN_WATCHDOG_COMP\tBIT(14)\n#define  VE_SEQ_CTRL_TRIG_JPG\t\tBIT(15)\n#define  VE_SEQ_CTRL_CAP_BUSY\t\tBIT(16)\n#define  VE_SEQ_CTRL_COMP_BUSY\t\tBIT(18)\n\n#define AST2500_VE_SEQ_CTRL_JPEG_MODE\tBIT(13)\n#define AST2400_VE_SEQ_CTRL_JPEG_MODE\tBIT(8)\n\n#define VE_CTRL\t\t\t\t0x008\n#define  VE_CTRL_HSYNC_POL\t\tBIT(0)\n#define  VE_CTRL_VSYNC_POL\t\tBIT(1)\n#define  VE_CTRL_SOURCE\t\t\tBIT(2)\n#define  VE_CTRL_INT_DE\t\t\tBIT(4)\n#define  VE_CTRL_DIRECT_FETCH\t\tBIT(5)\n#define  VE_CTRL_CAPTURE_FMT\t\tGENMASK(7, 6)\n#define  VE_CTRL_AUTO_OR_CURSOR\t\tBIT(8)\n#define  VE_CTRL_CLK_INVERSE\t\tBIT(11)\n#define  VE_CTRL_CLK_DELAY\t\tGENMASK(11, 9)\n#define  VE_CTRL_INTERLACE\t\tBIT(14)\n#define  VE_CTRL_HSYNC_POL_CTRL\t\tBIT(15)\n#define  VE_CTRL_FRC\t\t\tGENMASK(23, 16)\n\n#define VE_TGS_0\t\t\t0x00c\n#define VE_TGS_1\t\t\t0x010\n#define  VE_TGS_FIRST\t\t\tGENMASK(28, 16)\n#define  VE_TGS_LAST\t\t\tGENMASK(12, 0)\n\n#define VE_SCALING_FACTOR\t\t0x014\n#define VE_SCALING_FILTER0\t\t0x018\n#define VE_SCALING_FILTER1\t\t0x01c\n#define VE_SCALING_FILTER2\t\t0x020\n#define VE_SCALING_FILTER3\t\t0x024\n\n#define VE_BCD_CTRL\t\t\t0x02C\n#define  VE_BCD_CTRL_EN_BCD\t\tBIT(0)\n#define  VE_BCD_CTRL_EN_ABCD\t\tBIT(1)\n#define  VE_BCD_CTRL_EN_CB\t\tBIT(2)\n#define  VE_BCD_CTRL_THR\t\tGENMASK(23, 16)\n#define  VE_BCD_CTRL_ABCD_THR\t\tGENMASK(31, 24)\n\n#define VE_CAP_WINDOW\t\t\t0x030\n#define VE_COMP_WINDOW\t\t\t0x034\n#define VE_COMP_PROC_OFFSET\t\t0x038\n#define VE_COMP_OFFSET\t\t\t0x03c\n#define VE_JPEG_ADDR\t\t\t0x040\n#define VE_SRC0_ADDR\t\t\t0x044\n#define VE_SRC_SCANLINE_OFFSET\t\t0x048\n#define VE_SRC1_ADDR\t\t\t0x04c\n#define VE_BCD_ADDR\t\t\t0x050\n#define VE_COMP_ADDR\t\t\t0x054\n\n#define VE_STREAM_BUF_SIZE\t\t0x058\n#define  VE_STREAM_BUF_SIZE_N_PACKETS\tGENMASK(5, 3)\n#define  VE_STREAM_BUF_SIZE_P_SIZE\tGENMASK(2, 0)\n\n#define VE_COMP_CTRL\t\t\t0x060\n#define  VE_COMP_CTRL_VQ_DCT_ONLY\tBIT(0)\n#define  VE_COMP_CTRL_VQ_4COLOR\t\tBIT(1)\n#define  VE_COMP_CTRL_QUANTIZE\t\tBIT(2)\n#define  VE_COMP_CTRL_EN_BQ\t\tBIT(4)\n#define  VE_COMP_CTRL_EN_CRYPTO\t\tBIT(5)\n#define  VE_COMP_CTRL_DCT_CHR\t\tGENMASK(10, 6)\n#define  VE_COMP_CTRL_DCT_LUM\t\tGENMASK(15, 11)\n#define  VE_COMP_CTRL_EN_HQ\t\tBIT(16)\n#define  VE_COMP_CTRL_RSVD\t\tBIT(19)\n#define  VE_COMP_CTRL_ENCODE\t\tGENMASK(21, 20)\n#define  VE_COMP_CTRL_HQ_DCT_CHR\tGENMASK(26, 22)\n#define  VE_COMP_CTRL_HQ_DCT_LUM\tGENMASK(31, 27)\n\n#define VE_CB_ADDR\t\t\t0x06C\n\n#define AST2400_VE_COMP_SIZE_READ_BACK\t0x078\n#define AST2600_VE_COMP_SIZE_READ_BACK\t0x084\n\n#define VE_SRC_LR_EDGE_DET\t\t0x090\n#define  VE_SRC_LR_EDGE_DET_LEFT\tGENMASK(11, 0)\n#define  VE_SRC_LR_EDGE_DET_NO_V\tBIT(12)\n#define  VE_SRC_LR_EDGE_DET_NO_H\tBIT(13)\n#define  VE_SRC_LR_EDGE_DET_NO_DISP\tBIT(14)\n#define  VE_SRC_LR_EDGE_DET_NO_CLK\tBIT(15)\n#define  VE_SRC_LR_EDGE_DET_RT\t\tGENMASK(27, 16)\n#define  VE_SRC_LR_EDGE_DET_INTERLACE\tBIT(31)\n\n#define VE_SRC_TB_EDGE_DET\t\t0x094\n#define  VE_SRC_TB_EDGE_DET_TOP\t\tGENMASK(12, 0)\n#define  VE_SRC_TB_EDGE_DET_BOT\t\tGENMASK(28, 16)\n\n#define VE_MODE_DETECT_STATUS\t\t0x098\n#define  VE_MODE_DETECT_H_PERIOD\tGENMASK(11, 0)\n#define  VE_MODE_DETECT_EXTSRC_ADC\tBIT(12)\n#define  VE_MODE_DETECT_H_STABLE\tBIT(13)\n#define  VE_MODE_DETECT_V_STABLE\tBIT(14)\n#define  VE_MODE_DETECT_V_LINES\t\tGENMASK(27, 16)\n#define  VE_MODE_DETECT_STATUS_VSYNC\tBIT(28)\n#define  VE_MODE_DETECT_STATUS_HSYNC\tBIT(29)\n#define  VE_MODE_DETECT_VSYNC_RDY\tBIT(30)\n#define  VE_MODE_DETECT_HSYNC_RDY\tBIT(31)\n\n#define VE_SYNC_STATUS\t\t\t0x09c\n#define  VE_SYNC_STATUS_HSYNC\t\tGENMASK(11, 0)\n#define  VE_SYNC_STATUS_VSYNC\t\tGENMASK(27, 16)\n\n#define VE_H_TOTAL_PIXELS\t\t0x0A0\n\n#define VE_INTERRUPT_CTRL\t\t0x304\n#define VE_INTERRUPT_STATUS\t\t0x308\n#define  VE_INTERRUPT_MODE_DETECT_WD\tBIT(0)\n#define  VE_INTERRUPT_CAPTURE_COMPLETE\tBIT(1)\n#define  VE_INTERRUPT_COMP_READY\tBIT(2)\n#define  VE_INTERRUPT_COMP_COMPLETE\tBIT(3)\n#define  VE_INTERRUPT_MODE_DETECT\tBIT(4)\n#define  VE_INTERRUPT_FRAME_COMPLETE\tBIT(5)\n#define  VE_INTERRUPT_DECODE_ERR\tBIT(6)\n#define  VE_INTERRUPT_HALT_READY\tBIT(8)\n#define  VE_INTERRUPT_HANG_WD\t\tBIT(9)\n#define  VE_INTERRUPT_STREAM_DESC\tBIT(10)\n#define  VE_INTERRUPT_VSYNC_DESC\tBIT(11)\n\n#define VE_MODE_DETECT\t\t\t0x30c\n#define  VE_MODE_DT_HOR_TOLER\t\tGENMASK(31, 28)\n#define  VE_MODE_DT_VER_TOLER\t\tGENMASK(27, 24)\n#define  VE_MODE_DT_HOR_STABLE\t\tGENMASK(23, 20)\n#define  VE_MODE_DT_VER_STABLE\t\tGENMASK(19, 16)\n#define  VE_MODE_DT_EDG_THROD\t\tGENMASK(15, 8)\n\n#define VE_MEM_RESTRICT_START\t\t0x310\n#define VE_MEM_RESTRICT_END\t\t0x314\n\n \nenum {\n\tVIDEO_MODE_DETECT_DONE,\n\tVIDEO_RES_CHANGE,\n\tVIDEO_RES_DETECT,\n\tVIDEO_STREAMING,\n\tVIDEO_FRAME_INPRG,\n\tVIDEO_STOPPED,\n\tVIDEO_CLOCKS_ON,\n};\n\nenum aspeed_video_format {\n\tVIDEO_FMT_STANDARD = 0,\n\tVIDEO_FMT_ASPEED,\n\tVIDEO_FMT_MAX = VIDEO_FMT_ASPEED\n};\n\n\nenum aspeed_video_capture_format {\n\tVIDEO_CAP_FMT_YUV_STUDIO_SWING = 0,\n\tVIDEO_CAP_FMT_YUV_FULL_SWING,\n\tVIDEO_CAP_FMT_RGB,\n\tVIDEO_CAP_FMT_GRAY,\n\tVIDEO_CAP_FMT_MAX\n};\n\nstruct aspeed_video_addr {\n\tunsigned int size;\n\tdma_addr_t dma;\n\tvoid *virt;\n};\n\nstruct aspeed_video_buffer {\n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head link;\n};\n\nstruct aspeed_video_perf {\n\tktime_t last_sample;\n\tu32 totaltime;\n\tu32 duration;\n\tu32 duration_min;\n\tu32 duration_max;\n};\n\n#define to_aspeed_video_buffer(x) \\\n\tcontainer_of((x), struct aspeed_video_buffer, vb)\n\n \nstruct aspeed_video {\n\tvoid __iomem *base;\n\tstruct clk *eclk;\n\tstruct clk *vclk;\n\n\tstruct device *dev;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tstruct v4l2_device v4l2_dev;\n\tstruct v4l2_pix_format pix_fmt;\n\tstruct v4l2_bt_timings active_timings;\n\tstruct v4l2_bt_timings detected_timings;\n\tu32 v4l2_input_status;\n\tstruct vb2_queue queue;\n\tstruct video_device vdev;\n\tstruct mutex video_lock;\t \n\n\tu32 jpeg_mode;\n\tu32 comp_size_read;\n\n\twait_queue_head_t wait;\n\tspinlock_t lock;\t\t \n\tstruct delayed_work res_work;\n\tstruct list_head buffers;\n\tunsigned long flags;\n\tunsigned int sequence;\n\n\tunsigned int max_compressed_size;\n\tstruct aspeed_video_addr srcs[2];\n\tstruct aspeed_video_addr jpeg;\n\tstruct aspeed_video_addr bcd;\n\n\tbool yuv420;\n\tenum aspeed_video_format format;\n\tbool hq_mode;\n\tunsigned int frame_rate;\n\tunsigned int jpeg_quality;\n\tunsigned int jpeg_hq_quality;\n\n\tunsigned int frame_bottom;\n\tunsigned int frame_left;\n\tunsigned int frame_right;\n\tunsigned int frame_top;\n\n\tstruct aspeed_video_perf perf;\n};\n\n#define to_aspeed_video(x) container_of((x), struct aspeed_video, v4l2_dev)\n\nstruct aspeed_video_config {\n\tu32 jpeg_mode;\n\tu32 comp_size_read;\n};\n\nstatic const struct aspeed_video_config ast2400_config = {\n\t.jpeg_mode = AST2400_VE_SEQ_CTRL_JPEG_MODE,\n\t.comp_size_read = AST2400_VE_COMP_SIZE_READ_BACK,\n};\n\nstatic const struct aspeed_video_config ast2500_config = {\n\t.jpeg_mode = AST2500_VE_SEQ_CTRL_JPEG_MODE,\n\t.comp_size_read = AST2400_VE_COMP_SIZE_READ_BACK,\n};\n\nstatic const struct aspeed_video_config ast2600_config = {\n\t.jpeg_mode = AST2500_VE_SEQ_CTRL_JPEG_MODE,\n\t.comp_size_read = AST2600_VE_COMP_SIZE_READ_BACK,\n};\n\nstatic const u32 aspeed_video_jpeg_header[ASPEED_VIDEO_JPEG_HEADER_SIZE] = {\n\t0xe0ffd8ff, 0x464a1000, 0x01004649, 0x60000101, 0x00006000, 0x0f00feff,\n\t0x00002d05, 0x00000000, 0x00000000, 0x00dbff00\n};\n\nstatic const u32 aspeed_video_jpeg_quant[ASPEED_VIDEO_JPEG_QUANT_SIZE] = {\n\t0x081100c0, 0x00000000, 0x00110103, 0x03011102, 0xc4ff0111, 0x00001f00,\n\t0x01010501, 0x01010101, 0x00000000, 0x00000000, 0x04030201, 0x08070605,\n\t0xff0b0a09, 0x10b500c4, 0x03010200, 0x03040203, 0x04040505, 0x7d010000,\n\t0x00030201, 0x12051104, 0x06413121, 0x07615113, 0x32147122, 0x08a19181,\n\t0xc1b14223, 0xf0d15215, 0x72623324, 0x160a0982, 0x1a191817, 0x28272625,\n\t0x35342a29, 0x39383736, 0x4544433a, 0x49484746, 0x5554534a, 0x59585756,\n\t0x6564635a, 0x69686766, 0x7574736a, 0x79787776, 0x8584837a, 0x89888786,\n\t0x9493928a, 0x98979695, 0xa3a29a99, 0xa7a6a5a4, 0xb2aaa9a8, 0xb6b5b4b3,\n\t0xbab9b8b7, 0xc5c4c3c2, 0xc9c8c7c6, 0xd4d3d2ca, 0xd8d7d6d5, 0xe2e1dad9,\n\t0xe6e5e4e3, 0xeae9e8e7, 0xf4f3f2f1, 0xf8f7f6f5, 0xc4fffaf9, 0x00011f00,\n\t0x01010103, 0x01010101, 0x00000101, 0x00000000, 0x04030201, 0x08070605,\n\t0xff0b0a09, 0x11b500c4, 0x02010200, 0x04030404, 0x04040507, 0x77020100,\n\t0x03020100, 0x21050411, 0x41120631, 0x71610751, 0x81322213, 0x91421408,\n\t0x09c1b1a1, 0xf0523323, 0xd1726215, 0x3424160a, 0x17f125e1, 0x261a1918,\n\t0x2a292827, 0x38373635, 0x44433a39, 0x48474645, 0x54534a49, 0x58575655,\n\t0x64635a59, 0x68676665, 0x74736a69, 0x78777675, 0x83827a79, 0x87868584,\n\t0x928a8988, 0x96959493, 0x9a999897, 0xa5a4a3a2, 0xa9a8a7a6, 0xb4b3b2aa,\n\t0xb8b7b6b5, 0xc3c2bab9, 0xc7c6c5c4, 0xd2cac9c8, 0xd6d5d4d3, 0xdad9d8d7,\n\t0xe5e4e3e2, 0xe9e8e7e6, 0xf4f3f2ea, 0xf8f7f6f5, 0xdafffaf9, 0x01030c00,\n\t0x03110200, 0x003f0011\n};\n\nstatic const u32 aspeed_video_jpeg_dct[ASPEED_VIDEO_JPEG_NUM_QUALITIES]\n\t\t\t\t      [ASPEED_VIDEO_JPEG_DCT_SIZE] = {\n\t{ 0x0d140043, 0x0c0f110f, 0x11101114, 0x17141516, 0x1e20321e,\n\t  0x3d1e1b1b, 0x32242e2b, 0x4b4c3f48, 0x44463f47, 0x61735a50,\n\t  0x566c5550, 0x88644644, 0x7a766c65, 0x4d808280, 0x8c978d60,\n\t  0x7e73967d, 0xdbff7b80, 0x1f014300, 0x272d2121, 0x3030582d,\n\t  0x697bb958, 0xb8b9b97b, 0xb9b8a6a6, 0xb9b9b9b9, 0xb9b9b9b9,\n\t  0xb9b9b9b9, 0xb9b9b9b9, 0xb9b9b9b9, 0xb9b9b9b9, 0xb9b9b9b9,\n\t  0xb9b9b9b9, 0xb9b9b9b9, 0xb9b9b9b9, 0xffb9b9b9 },\n\t{ 0x0c110043, 0x0a0d0f0d, 0x0f0e0f11, 0x14111213, 0x1a1c2b1a,\n\t  0x351a1818, 0x2b1f2826, 0x4142373f, 0x3c3d373e, 0x55644e46,\n\t  0x4b5f4a46, 0x77573d3c, 0x6b675f58, 0x43707170, 0x7a847b54,\n\t  0x6e64836d, 0xdbff6c70, 0x1b014300, 0x22271d1d, 0x2a2a4c27,\n\t  0x5b6ba04c, 0xa0a0a06b, 0xa0a0a0a0, 0xa0a0a0a0, 0xa0a0a0a0,\n\t  0xa0a0a0a0, 0xa0a0a0a0, 0xa0a0a0a0, 0xa0a0a0a0, 0xa0a0a0a0,\n\t  0xa0a0a0a0, 0xa0a0a0a0, 0xa0a0a0a0, 0xffa0a0a0 },\n\t{ 0x090e0043, 0x090a0c0a, 0x0c0b0c0e, 0x110e0f10, 0x15172415,\n\t  0x2c151313, 0x241a211f, 0x36372e34, 0x31322e33, 0x4653413a,\n\t  0x3e4e3d3a, 0x62483231, 0x58564e49, 0x385d5e5d, 0x656d6645,\n\t  0x5b536c5a, 0xdbff595d, 0x16014300, 0x1c201818, 0x22223f20,\n\t  0x4b58853f, 0x85858558, 0x85858585, 0x85858585, 0x85858585,\n\t  0x85858585, 0x85858585, 0x85858585, 0x85858585, 0x85858585,\n\t  0x85858585, 0x85858585, 0x85858585, 0xff858585 },\n\t{ 0x070b0043, 0x07080a08, 0x0a090a0b, 0x0d0b0c0c, 0x11121c11,\n\t  0x23110f0f, 0x1c141a19, 0x2b2b2429, 0x27282428, 0x3842332e,\n\t  0x313e302e, 0x4e392827, 0x46443e3a, 0x2c4a4a4a, 0x50565137,\n\t  0x48425647, 0xdbff474a, 0x12014300, 0x161a1313, 0x1c1c331a,\n\t  0x3d486c33, 0x6c6c6c48, 0x6c6c6c6c, 0x6c6c6c6c, 0x6c6c6c6c,\n\t  0x6c6c6c6c, 0x6c6c6c6c, 0x6c6c6c6c, 0x6c6c6c6c, 0x6c6c6c6c,\n\t  0x6c6c6c6c, 0x6c6c6c6c, 0x6c6c6c6c, 0xff6c6c6c },\n\t{ 0x06090043, 0x05060706, 0x07070709, 0x0a09090a, 0x0d0e160d,\n\t  0x1b0d0c0c, 0x16101413, 0x21221c20, 0x1e1f1c20, 0x2b332824,\n\t  0x26302624, 0x3d2d1f1e, 0x3735302d, 0x22393a39, 0x3f443f2b,\n\t  0x38334338, 0xdbff3739, 0x0d014300, 0x11130e0e, 0x15152613,\n\t  0x2d355026, 0x50505035, 0x50505050, 0x50505050, 0x50505050,\n\t  0x50505050, 0x50505050, 0x50505050, 0x50505050, 0x50505050,\n\t  0x50505050, 0x50505050, 0x50505050, 0xff505050 },\n\t{ 0x04060043, 0x03040504, 0x05040506, 0x07060606, 0x09090f09,\n\t  0x12090808, 0x0f0a0d0d, 0x16161315, 0x14151315, 0x1d221b18,\n\t  0x19201918, 0x281e1514, 0x2423201e, 0x17262726, 0x2a2d2a1c,\n\t  0x25222d25, 0xdbff2526, 0x09014300, 0x0b0d0a0a, 0x0e0e1a0d,\n\t  0x1f25371a, 0x37373725, 0x37373737, 0x37373737, 0x37373737,\n\t  0x37373737, 0x37373737, 0x37373737, 0x37373737, 0x37373737,\n\t  0x37373737, 0x37373737, 0x37373737, 0xff373737 },\n\t{ 0x02030043, 0x01020202, 0x02020203, 0x03030303, 0x04040704,\n\t  0x09040404, 0x07050606, 0x0b0b090a, 0x0a0a090a, 0x0e110d0c,\n\t  0x0c100c0c, 0x140f0a0a, 0x1211100f, 0x0b131313, 0x1516150e,\n\t  0x12111612, 0xdbff1213, 0x04014300, 0x05060505, 0x07070d06,\n\t  0x0f121b0d, 0x1b1b1b12, 0x1b1b1b1b, 0x1b1b1b1b, 0x1b1b1b1b,\n\t  0x1b1b1b1b, 0x1b1b1b1b, 0x1b1b1b1b, 0x1b1b1b1b, 0x1b1b1b1b,\n\t  0x1b1b1b1b, 0x1b1b1b1b, 0x1b1b1b1b, 0xff1b1b1b },\n\t{ 0x01020043, 0x01010101, 0x01010102, 0x02020202, 0x03030503,\n\t  0x06030202, 0x05030404, 0x07070607, 0x06070607, 0x090b0908,\n\t  0x080a0808, 0x0d0a0706, 0x0c0b0a0a, 0x070c0d0c, 0x0e0f0e09,\n\t  0x0c0b0f0c, 0xdbff0c0c, 0x03014300, 0x03040303, 0x04040804,\n\t  0x0a0c1208, 0x1212120c, 0x12121212, 0x12121212, 0x12121212,\n\t  0x12121212, 0x12121212, 0x12121212, 0x12121212, 0x12121212,\n\t  0x12121212, 0x12121212, 0x12121212, 0xff121212 },\n\t{ 0x01020043, 0x01010101, 0x01010102, 0x02020202, 0x03030503,\n\t  0x06030202, 0x05030404, 0x07070607, 0x06070607, 0x090b0908,\n\t  0x080a0808, 0x0d0a0706, 0x0c0b0a0a, 0x070c0d0c, 0x0e0f0e09,\n\t  0x0c0b0f0c, 0xdbff0c0c, 0x02014300, 0x03030202, 0x04040703,\n\t  0x080a0f07, 0x0f0f0f0a, 0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f,\n\t  0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f,\n\t  0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f, 0xff0f0f0f },\n\t{ 0x01010043, 0x01010101, 0x01010101, 0x01010101, 0x02020302,\n\t  0x04020202, 0x03020303, 0x05050405, 0x05050405, 0x07080606,\n\t  0x06080606, 0x0a070505, 0x09080807, 0x05090909, 0x0a0b0a07,\n\t  0x09080b09, 0xdbff0909, 0x02014300, 0x02030202, 0x03030503,\n\t  0x07080c05, 0x0c0c0c08, 0x0c0c0c0c, 0x0c0c0c0c, 0x0c0c0c0c,\n\t  0x0c0c0c0c, 0x0c0c0c0c, 0x0c0c0c0c, 0x0c0c0c0c, 0x0c0c0c0c,\n\t  0x0c0c0c0c, 0x0c0c0c0c, 0x0c0c0c0c, 0xff0c0c0c },\n\t{ 0x01010043, 0x01010101, 0x01010101, 0x01010101, 0x01010201,\n\t  0x03010101, 0x02010202, 0x03030303, 0x03030303, 0x04050404,\n\t  0x04050404, 0x06050303, 0x06050505, 0x03060606, 0x07070704,\n\t  0x06050706, 0xdbff0606, 0x01014300, 0x01020101, 0x02020402,\n\t  0x05060904, 0x09090906, 0x09090909, 0x09090909, 0x09090909,\n\t  0x09090909, 0x09090909, 0x09090909, 0x09090909, 0x09090909,\n\t  0x09090909, 0x09090909, 0x09090909, 0xff090909 },\n\t{ 0x01010043, 0x01010101, 0x01010101, 0x01010101, 0x01010101,\n\t  0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x02020202,\n\t  0x02020202, 0x03020101, 0x03020202, 0x01030303, 0x03030302,\n\t  0x03020303, 0xdbff0403, 0x01014300, 0x01010101, 0x01010201,\n\t  0x03040602, 0x06060604, 0x06060606, 0x06060606, 0x06060606,\n\t  0x06060606, 0x06060606, 0x06060606, 0x06060606, 0x06060606,\n\t  0x06060606, 0x06060606, 0x06060606, 0xff060606 }\n};\n\nstatic const struct v4l2_dv_timings_cap aspeed_video_timings_cap = {\n\t.type = V4L2_DV_BT_656_1120,\n\t.bt = {\n\t\t.min_width = MIN_WIDTH,\n\t\t.max_width = MAX_WIDTH,\n\t\t.min_height = MIN_HEIGHT,\n\t\t.max_height = MAX_HEIGHT,\n\t\t.min_pixelclock = 6574080,  \n\t\t.max_pixelclock = 138240000,  \n\t\t.standards = V4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_DMT |\n\t\t\tV4L2_DV_BT_STD_CVT | V4L2_DV_BT_STD_GTF,\n\t\t.capabilities = V4L2_DV_BT_CAP_PROGRESSIVE |\n\t\t\tV4L2_DV_BT_CAP_REDUCED_BLANKING |\n\t\t\tV4L2_DV_BT_CAP_CUSTOM,\n\t},\n};\n\nstatic const char * const format_str[] = {\"Standard JPEG\",\n\t\"Aspeed JPEG\"};\n\nstatic unsigned int debug;\n\nstatic bool aspeed_video_alloc_buf(struct aspeed_video *video,\n\t\t\t\t   struct aspeed_video_addr *addr,\n\t\t\t\t   unsigned int size);\n\nstatic void aspeed_video_free_buf(struct aspeed_video *video,\n\t\t\t\t  struct aspeed_video_addr *addr);\n\nstatic void aspeed_video_init_jpeg_table(u32 *table, bool yuv420)\n{\n\tint i;\n\tunsigned int base;\n\n\tfor (i = 0; i < ASPEED_VIDEO_JPEG_NUM_QUALITIES; i++) {\n\t\tbase = 256 * i;\t \n\t\tmemcpy(&table[base], aspeed_video_jpeg_header,\n\t\t       sizeof(aspeed_video_jpeg_header));\n\n\t\tbase += ASPEED_VIDEO_JPEG_HEADER_SIZE;\n\t\tmemcpy(&table[base], aspeed_video_jpeg_dct[i],\n\t\t       sizeof(aspeed_video_jpeg_dct[i]));\n\n\t\tbase += ASPEED_VIDEO_JPEG_DCT_SIZE;\n\t\tmemcpy(&table[base], aspeed_video_jpeg_quant,\n\t\t       sizeof(aspeed_video_jpeg_quant));\n\n\t\tif (yuv420)\n\t\t\ttable[base + 2] = 0x00220103;\n\t}\n}\n\n \nstatic void aspeed_video_update_jpeg_table(u32 *table, bool yuv420)\n{\n\tint i;\n\tunsigned int base;\n\n\tfor (i = 0; i < ASPEED_VIDEO_JPEG_NUM_QUALITIES; i++) {\n\t\tbase = 256 * i;\t \n\t\tbase += ASPEED_VIDEO_JPEG_HEADER_SIZE +\n\t\t\tASPEED_VIDEO_JPEG_DCT_SIZE;\n\n\t\ttable[base + 2] = (yuv420) ? 0x00220103 : 0x00110103;\n\t}\n}\n\nstatic void aspeed_video_update(struct aspeed_video *video, u32 reg, u32 clear,\n\t\t\t\tu32 bits)\n{\n\tu32 t = readl(video->base + reg);\n\tu32 before = t;\n\n\tt &= ~clear;\n\tt |= bits;\n\twritel(t, video->base + reg);\n\tv4l2_dbg(3, debug, &video->v4l2_dev, \"update %03x[%08x -> %08x]\\n\",\n\t\t reg, before, readl(video->base + reg));\n}\n\nstatic u32 aspeed_video_read(struct aspeed_video *video, u32 reg)\n{\n\tu32 t = readl(video->base + reg);\n\n\tv4l2_dbg(3, debug, &video->v4l2_dev, \"read %03x[%08x]\\n\", reg, t);\n\treturn t;\n}\n\nstatic void aspeed_video_write(struct aspeed_video *video, u32 reg, u32 val)\n{\n\twritel(val, video->base + reg);\n\tv4l2_dbg(3, debug, &video->v4l2_dev, \"write %03x[%08x]\\n\", reg,\n\t\t readl(video->base + reg));\n}\n\nstatic void update_perf(struct aspeed_video_perf *p)\n{\n\tstruct aspeed_video *v = container_of(p, struct aspeed_video,\n\t\t\t\t\t      perf);\n\n\tp->duration =\n\t\tktime_to_ms(ktime_sub(ktime_get(),  p->last_sample));\n\tp->totaltime += p->duration;\n\n\tp->duration_max = max(p->duration, p->duration_max);\n\tp->duration_min = min(p->duration, p->duration_min);\n\tv4l2_dbg(2, debug, &v->v4l2_dev, \"time consumed: %d ms\\n\",\n\t\t p->duration);\n}\n\nstatic int aspeed_video_start_frame(struct aspeed_video *video)\n{\n\tdma_addr_t addr;\n\tunsigned long flags;\n\tstruct aspeed_video_buffer *buf;\n\tu32 seq_ctrl = aspeed_video_read(video, VE_SEQ_CTRL);\n\tbool bcd_buf_need = (video->format != VIDEO_FMT_STANDARD);\n\n\tif (video->v4l2_input_status) {\n\t\tv4l2_dbg(1, debug, &video->v4l2_dev, \"No signal; don't start frame\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!(seq_ctrl & VE_SEQ_CTRL_COMP_BUSY) ||\n\t    !(seq_ctrl & VE_SEQ_CTRL_CAP_BUSY)) {\n\t\tv4l2_dbg(1, debug, &video->v4l2_dev, \"Engine busy; don't start frame\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (bcd_buf_need && !video->bcd.size) {\n\t\tif (!aspeed_video_alloc_buf(video, &video->bcd,\n\t\t\t\t\t    VE_BCD_BUFF_SIZE)) {\n\t\t\tdev_err(video->dev, \"Failed to allocate BCD buffer\\n\");\n\t\t\tdev_err(video->dev, \"don't start frame\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\taspeed_video_write(video, VE_BCD_ADDR, video->bcd.dma);\n\t\tv4l2_dbg(1, debug, &video->v4l2_dev, \"bcd addr(%pad) size(%d)\\n\",\n\t\t\t &video->bcd.dma, video->bcd.size);\n\t} else if (!bcd_buf_need && video->bcd.size) {\n\t\taspeed_video_free_buf(video, &video->bcd);\n\t}\n\n\tspin_lock_irqsave(&video->lock, flags);\n\tbuf = list_first_entry_or_null(&video->buffers,\n\t\t\t\t       struct aspeed_video_buffer, link);\n\tif (!buf) {\n\t\tspin_unlock_irqrestore(&video->lock, flags);\n\t\tv4l2_dbg(1, debug, &video->v4l2_dev, \"No buffers; don't start frame\\n\");\n\t\treturn -EPROTO;\n\t}\n\n\tset_bit(VIDEO_FRAME_INPRG, &video->flags);\n\taddr = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);\n\tspin_unlock_irqrestore(&video->lock, flags);\n\n\taspeed_video_write(video, VE_COMP_PROC_OFFSET, 0);\n\taspeed_video_write(video, VE_COMP_OFFSET, 0);\n\taspeed_video_write(video, VE_COMP_ADDR, addr);\n\n\taspeed_video_update(video, VE_INTERRUPT_CTRL, 0,\n\t\t\t    VE_INTERRUPT_COMP_COMPLETE);\n\n\tvideo->perf.last_sample = ktime_get();\n\n\taspeed_video_update(video, VE_SEQ_CTRL, 0,\n\t\t\t    VE_SEQ_CTRL_TRIG_CAPTURE | VE_SEQ_CTRL_TRIG_COMP);\n\n\treturn 0;\n}\n\nstatic void aspeed_video_enable_mode_detect(struct aspeed_video *video)\n{\n\t \n\taspeed_video_update(video, VE_INTERRUPT_CTRL, 0,\n\t\t\t    VE_INTERRUPT_MODE_DETECT);\n\n\t \n\taspeed_video_update(video, VE_SEQ_CTRL,\n\t\t\t    VE_SEQ_CTRL_TRIG_MODE_DET, 0);\n\n\t \n\taspeed_video_update(video, VE_SEQ_CTRL, 0, VE_SEQ_CTRL_TRIG_MODE_DET);\n}\n\nstatic void aspeed_video_off(struct aspeed_video *video)\n{\n\tif (!test_bit(VIDEO_CLOCKS_ON, &video->flags))\n\t\treturn;\n\n\t \n\taspeed_video_write(video, VE_INTERRUPT_CTRL, 0);\n\taspeed_video_write(video, VE_INTERRUPT_STATUS, 0xffffffff);\n\n\t \n\tclk_disable(video->eclk);\n\tclk_disable(video->vclk);\n\n\tclear_bit(VIDEO_CLOCKS_ON, &video->flags);\n}\n\nstatic void aspeed_video_on(struct aspeed_video *video)\n{\n\tif (test_bit(VIDEO_CLOCKS_ON, &video->flags))\n\t\treturn;\n\n\t \n\tclk_enable(video->vclk);\n\tclk_enable(video->eclk);\n\n\tset_bit(VIDEO_CLOCKS_ON, &video->flags);\n}\n\nstatic void aspeed_video_bufs_done(struct aspeed_video *video,\n\t\t\t\t   enum vb2_buffer_state state)\n{\n\tunsigned long flags;\n\tstruct aspeed_video_buffer *buf;\n\n\tspin_lock_irqsave(&video->lock, flags);\n\tlist_for_each_entry(buf, &video->buffers, link)\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\tINIT_LIST_HEAD(&video->buffers);\n\tspin_unlock_irqrestore(&video->lock, flags);\n}\n\nstatic void aspeed_video_irq_res_change(struct aspeed_video *video, ulong delay)\n{\n\tv4l2_dbg(1, debug, &video->v4l2_dev, \"Resolution changed; resetting\\n\");\n\n\tset_bit(VIDEO_RES_CHANGE, &video->flags);\n\tclear_bit(VIDEO_FRAME_INPRG, &video->flags);\n\n\tvideo->v4l2_input_status = V4L2_IN_ST_NO_SIGNAL;\n\n\taspeed_video_off(video);\n\taspeed_video_bufs_done(video, VB2_BUF_STATE_ERROR);\n\n\tschedule_delayed_work(&video->res_work, delay);\n}\n\nstatic void aspeed_video_swap_src_buf(struct aspeed_video *v)\n{\n\tif (v->format == VIDEO_FMT_STANDARD)\n\t\treturn;\n\n\t \n\tif (IS_ALIGNED(v->sequence, 8))\n\t\tmemset((u8 *)v->bcd.virt, 0x00, VE_BCD_BUFF_SIZE);\n\n\tif (v->sequence & 0x01) {\n\t\taspeed_video_write(v, VE_SRC0_ADDR, v->srcs[1].dma);\n\t\taspeed_video_write(v, VE_SRC1_ADDR, v->srcs[0].dma);\n\t} else {\n\t\taspeed_video_write(v, VE_SRC0_ADDR, v->srcs[0].dma);\n\t\taspeed_video_write(v, VE_SRC1_ADDR, v->srcs[1].dma);\n\t}\n}\n\nstatic irqreturn_t aspeed_video_irq(int irq, void *arg)\n{\n\tstruct aspeed_video *video = arg;\n\tu32 sts = aspeed_video_read(video, VE_INTERRUPT_STATUS);\n\n\t \n\tsts &= aspeed_video_read(video, VE_INTERRUPT_CTRL);\n\n\tv4l2_dbg(2, debug, &video->v4l2_dev, \"irq sts=%#x %s%s%s%s\\n\", sts,\n\t\t sts & VE_INTERRUPT_MODE_DETECT_WD ? \", unlock\" : \"\",\n\t\t sts & VE_INTERRUPT_MODE_DETECT ? \", lock\" : \"\",\n\t\t sts & VE_INTERRUPT_CAPTURE_COMPLETE ? \", capture-done\" : \"\",\n\t\t sts & VE_INTERRUPT_COMP_COMPLETE ? \", comp-done\" : \"\");\n\n\t \n\tif (sts & VE_INTERRUPT_MODE_DETECT_WD) {\n\t\taspeed_video_irq_res_change(video, 0);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (sts & VE_INTERRUPT_MODE_DETECT) {\n\t\tif (test_bit(VIDEO_RES_DETECT, &video->flags)) {\n\t\t\taspeed_video_update(video, VE_INTERRUPT_CTRL,\n\t\t\t\t\t    VE_INTERRUPT_MODE_DETECT, 0);\n\t\t\taspeed_video_write(video, VE_INTERRUPT_STATUS,\n\t\t\t\t\t   VE_INTERRUPT_MODE_DETECT);\n\t\t\tsts &= ~VE_INTERRUPT_MODE_DETECT;\n\t\t\tset_bit(VIDEO_MODE_DETECT_DONE, &video->flags);\n\t\t\twake_up_interruptible_all(&video->wait);\n\t\t} else {\n\t\t\t \n\t\t\taspeed_video_irq_res_change(video,\n\t\t\t\t\t\t    RESOLUTION_CHANGE_DELAY);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t}\n\n\tif (sts & VE_INTERRUPT_COMP_COMPLETE) {\n\t\tstruct aspeed_video_buffer *buf;\n\t\tbool empty = true;\n\t\tu32 frame_size = aspeed_video_read(video,\n\t\t\t\t\t\t   video->comp_size_read);\n\n\t\tupdate_perf(&video->perf);\n\n\t\tspin_lock(&video->lock);\n\t\tclear_bit(VIDEO_FRAME_INPRG, &video->flags);\n\t\tbuf = list_first_entry_or_null(&video->buffers,\n\t\t\t\t\t       struct aspeed_video_buffer,\n\t\t\t\t\t       link);\n\t\tif (buf) {\n\t\t\tvb2_set_plane_payload(&buf->vb.vb2_buf, 0, frame_size);\n\n\t\t\t \n\t\t\tif (video->format == VIDEO_FMT_STANDARD &&\n\t\t\t    list_is_last(&buf->link, &video->buffers)) {\n\t\t\t\tempty = false;\n\t\t\t\tv4l2_dbg(1, debug, &video->v4l2_dev, \"skip to keep last frame updated\\n\");\n\t\t\t} else {\n\t\t\t\tbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\t\t\tbuf->vb.sequence = video->sequence++;\n\t\t\t\tbuf->vb.field = V4L2_FIELD_NONE;\n\t\t\t\tvb2_buffer_done(&buf->vb.vb2_buf,\n\t\t\t\t\t\tVB2_BUF_STATE_DONE);\n\t\t\t\tlist_del(&buf->link);\n\t\t\t\tempty = list_empty(&video->buffers);\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&video->lock);\n\n\t\taspeed_video_update(video, VE_SEQ_CTRL,\n\t\t\t\t    VE_SEQ_CTRL_TRIG_CAPTURE |\n\t\t\t\t    VE_SEQ_CTRL_FORCE_IDLE |\n\t\t\t\t    VE_SEQ_CTRL_TRIG_COMP, 0);\n\t\taspeed_video_update(video, VE_INTERRUPT_CTRL,\n\t\t\t\t    VE_INTERRUPT_COMP_COMPLETE, 0);\n\t\taspeed_video_write(video, VE_INTERRUPT_STATUS,\n\t\t\t\t   VE_INTERRUPT_COMP_COMPLETE);\n\t\tsts &= ~VE_INTERRUPT_COMP_COMPLETE;\n\n\t\taspeed_video_swap_src_buf(video);\n\n\t\tif (test_bit(VIDEO_STREAMING, &video->flags) && !empty)\n\t\t\taspeed_video_start_frame(video);\n\t}\n\n\treturn sts ? IRQ_NONE : IRQ_HANDLED;\n}\n\nstatic void aspeed_video_check_and_set_polarity(struct aspeed_video *video)\n{\n\tint i;\n\tint hsync_counter = 0;\n\tint vsync_counter = 0;\n\tu32 sts, ctrl;\n\n\tfor (i = 0; i < NUM_POLARITY_CHECKS; ++i) {\n\t\tsts = aspeed_video_read(video, VE_MODE_DETECT_STATUS);\n\t\tif (sts & VE_MODE_DETECT_STATUS_VSYNC)\n\t\t\tvsync_counter--;\n\t\telse\n\t\t\tvsync_counter++;\n\n\t\tif (sts & VE_MODE_DETECT_STATUS_HSYNC)\n\t\t\thsync_counter--;\n\t\telse\n\t\t\thsync_counter++;\n\t}\n\n\tctrl = aspeed_video_read(video, VE_CTRL);\n\n\tif (hsync_counter < 0) {\n\t\tctrl |= VE_CTRL_HSYNC_POL;\n\t\tvideo->detected_timings.polarities &=\n\t\t\t~V4L2_DV_HSYNC_POS_POL;\n\t} else {\n\t\tctrl &= ~VE_CTRL_HSYNC_POL;\n\t\tvideo->detected_timings.polarities |=\n\t\t\tV4L2_DV_HSYNC_POS_POL;\n\t}\n\n\tif (vsync_counter < 0) {\n\t\tctrl |= VE_CTRL_VSYNC_POL;\n\t\tvideo->detected_timings.polarities &=\n\t\t\t~V4L2_DV_VSYNC_POS_POL;\n\t} else {\n\t\tctrl &= ~VE_CTRL_VSYNC_POL;\n\t\tvideo->detected_timings.polarities |=\n\t\t\tV4L2_DV_VSYNC_POS_POL;\n\t}\n\n\taspeed_video_write(video, VE_CTRL, ctrl);\n}\n\nstatic bool aspeed_video_alloc_buf(struct aspeed_video *video,\n\t\t\t\t   struct aspeed_video_addr *addr,\n\t\t\t\t   unsigned int size)\n{\n\taddr->virt = dma_alloc_coherent(video->dev, size, &addr->dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!addr->virt)\n\t\treturn false;\n\n\taddr->size = size;\n\treturn true;\n}\n\nstatic void aspeed_video_free_buf(struct aspeed_video *video,\n\t\t\t\t  struct aspeed_video_addr *addr)\n{\n\tdma_free_coherent(video->dev, addr->size, addr->virt, addr->dma);\n\taddr->size = 0;\n\taddr->dma = 0ULL;\n\taddr->virt = NULL;\n}\n\n \nstatic void aspeed_video_calc_compressed_size(struct aspeed_video *video,\n\t\t\t\t\t      unsigned int frame_size)\n{\n\tint i, j;\n\tu32 compression_buffer_size_reg = 0;\n\tunsigned int size;\n\tconst unsigned int num_compression_packets = 4;\n\tconst unsigned int compression_packet_size = 1024;\n\tconst unsigned int max_compressed_size = frame_size / 2;  \n\n\tvideo->max_compressed_size = UINT_MAX;\n\n\tfor (i = 0; i < 6; ++i) {\n\t\tfor (j = 0; j < 8; ++j) {\n\t\t\tsize = (num_compression_packets << i) *\n\t\t\t\t(compression_packet_size << j);\n\t\t\tif (size < max_compressed_size)\n\t\t\t\tcontinue;\n\n\t\t\tif (size < video->max_compressed_size) {\n\t\t\t\tcompression_buffer_size_reg = (i << 3) | j;\n\t\t\t\tvideo->max_compressed_size = size;\n\t\t\t}\n\t\t}\n\t}\n\n\taspeed_video_write(video, VE_STREAM_BUF_SIZE,\n\t\t\t   compression_buffer_size_reg);\n\n\tv4l2_dbg(1, debug, &video->v4l2_dev, \"Max compressed size: %#x\\n\",\n\t\t video->max_compressed_size);\n}\n\n \nstatic void aspeed_video_get_timings(struct aspeed_video *v,\n\t\t\t\t     struct v4l2_bt_timings *det)\n{\n\tu32 mds, sync, htotal, vtotal, vsync, hsync;\n\n\tmds = aspeed_video_read(v, VE_MODE_DETECT_STATUS);\n\tsync = aspeed_video_read(v, VE_SYNC_STATUS);\n\thtotal = aspeed_video_read(v, VE_H_TOTAL_PIXELS);\n\tvtotal = FIELD_GET(VE_MODE_DETECT_V_LINES, mds);\n\tvsync = FIELD_GET(VE_SYNC_STATUS_VSYNC, sync);\n\thsync = FIELD_GET(VE_SYNC_STATUS_HSYNC, sync);\n\n\t \n\tif (vsync > det->height)\n\t\tdet->polarities &= ~V4L2_DV_VSYNC_POS_POL;\n\telse\n\t\tdet->polarities |= V4L2_DV_VSYNC_POS_POL;\n\tif (hsync > det->width)\n\t\tdet->polarities &= ~V4L2_DV_HSYNC_POS_POL;\n\telse\n\t\tdet->polarities |= V4L2_DV_HSYNC_POS_POL;\n\n\tif (det->polarities & V4L2_DV_VSYNC_POS_POL) {\n\t\tdet->vbackporch = v->frame_top - vsync;\n\t\tdet->vfrontporch = vtotal - v->frame_bottom;\n\t\tdet->vsync = vsync;\n\t} else {\n\t\tdet->vbackporch = v->frame_top;\n\t\tdet->vfrontporch = vsync - v->frame_bottom;\n\t\tdet->vsync = vtotal - vsync;\n\t}\n\n\tif (det->polarities & V4L2_DV_HSYNC_POS_POL) {\n\t\tdet->hbackporch = v->frame_left - hsync;\n\t\tdet->hfrontporch = htotal - v->frame_right;\n\t\tdet->hsync = hsync;\n\t} else {\n\t\tdet->hbackporch = v->frame_left;\n\t\tdet->hfrontporch = hsync - v->frame_right;\n\t\tdet->hsync = htotal - hsync;\n\t}\n}\n\n#define res_check(v) test_and_clear_bit(VIDEO_MODE_DETECT_DONE, &(v)->flags)\n\nstatic void aspeed_video_get_resolution(struct aspeed_video *video)\n{\n\tbool invalid_resolution = true;\n\tint rc;\n\tint tries = 0;\n\tu32 mds;\n\tu32 src_lr_edge;\n\tu32 src_tb_edge;\n\tstruct v4l2_bt_timings *det = &video->detected_timings;\n\n\tdet->width = MIN_WIDTH;\n\tdet->height = MIN_HEIGHT;\n\tvideo->v4l2_input_status = V4L2_IN_ST_NO_SIGNAL;\n\tmemset(&video->perf, 0, sizeof(video->perf));\n\n\tdo {\n\t\tif (tries) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (schedule_timeout(INVALID_RESOLUTION_DELAY))\n\t\t\t\treturn;\n\t\t}\n\n\t\tset_bit(VIDEO_RES_DETECT, &video->flags);\n\t\taspeed_video_update(video, VE_CTRL,\n\t\t\t\t    VE_CTRL_VSYNC_POL | VE_CTRL_HSYNC_POL, 0);\n\t\taspeed_video_enable_mode_detect(video);\n\n\t\trc = wait_event_interruptible_timeout(video->wait,\n\t\t\t\t\t\t      res_check(video),\n\t\t\t\t\t\t      MODE_DETECT_TIMEOUT);\n\t\tif (!rc) {\n\t\t\tv4l2_dbg(1, debug, &video->v4l2_dev, \"Timed out; first mode detect\\n\");\n\t\t\tclear_bit(VIDEO_RES_DETECT, &video->flags);\n\t\t\treturn;\n\t\t}\n\n\t\tmds = aspeed_video_read(video, VE_MODE_DETECT_STATUS);\n\t\t\n\t\tif (!(mds & VE_MODE_DETECT_H_STABLE) ||\n\t\t    !(mds & VE_MODE_DETECT_V_STABLE) ||\n\t\t    (mds & VE_MODE_DETECT_EXTSRC_ADC))\n\t\t\tcontinue;\n\n\t\taspeed_video_check_and_set_polarity(video);\n\n\t\taspeed_video_enable_mode_detect(video);\n\n\t\trc = wait_event_interruptible_timeout(video->wait,\n\t\t\t\t\t\t      res_check(video),\n\t\t\t\t\t\t      MODE_DETECT_TIMEOUT);\n\t\tclear_bit(VIDEO_RES_DETECT, &video->flags);\n\t\tif (!rc) {\n\t\t\tv4l2_dbg(1, debug, &video->v4l2_dev, \"Timed out; second mode detect\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tsrc_lr_edge = aspeed_video_read(video, VE_SRC_LR_EDGE_DET);\n\t\tsrc_tb_edge = aspeed_video_read(video, VE_SRC_TB_EDGE_DET);\n\n\t\tvideo->frame_bottom = FIELD_GET(VE_SRC_TB_EDGE_DET_BOT, src_tb_edge);\n\t\tvideo->frame_top = FIELD_GET(VE_SRC_TB_EDGE_DET_TOP, src_tb_edge);\n\n\t\tif (video->frame_top > video->frame_bottom)\n\t\t\tcontinue;\n\n\t\tvideo->frame_right = FIELD_GET(VE_SRC_LR_EDGE_DET_RT, src_lr_edge);\n\t\tvideo->frame_left = FIELD_GET(VE_SRC_LR_EDGE_DET_LEFT, src_lr_edge);\n\n\t\tif (video->frame_left > video->frame_right)\n\t\t\tcontinue;\n\n\t\tinvalid_resolution = false;\n\t} while (invalid_resolution && (tries++ < INVALID_RESOLUTION_RETRIES));\n\n\tif (invalid_resolution) {\n\t\tv4l2_dbg(1, debug, &video->v4l2_dev, \"Invalid resolution detected\\n\");\n\t\treturn;\n\t}\n\n\tdet->height = (video->frame_bottom - video->frame_top) + 1;\n\tdet->width = (video->frame_right - video->frame_left) + 1;\n\tvideo->v4l2_input_status = 0;\n\n\taspeed_video_get_timings(video, det);\n\n\t \n\taspeed_video_update(video, VE_INTERRUPT_CTRL, 0,\n\t\t\t    VE_INTERRUPT_MODE_DETECT_WD);\n\taspeed_video_update(video, VE_SEQ_CTRL, 0,\n\t\t\t    VE_SEQ_CTRL_AUTO_COMP | VE_SEQ_CTRL_EN_WATCHDOG);\n\n\tv4l2_dbg(1, debug, &video->v4l2_dev, \"Got resolution: %dx%d\\n\",\n\t\t det->width, det->height);\n}\n\nstatic void aspeed_video_set_resolution(struct aspeed_video *video)\n{\n\tstruct v4l2_bt_timings *act = &video->active_timings;\n\tunsigned int size = act->width * ALIGN(act->height, 8);\n\n\t \n\taspeed_video_calc_compressed_size(video, size);\n\n\tif (!IS_ALIGNED(act->width, 64)) {\n\t\t \n\t\tu32 width = ALIGN(act->width, 64);\n\n\t\taspeed_video_write(video, VE_CAP_WINDOW, width << 16 | act->height);\n\t\tsize = width * ALIGN(act->height, 8);\n\t} else {\n\t\taspeed_video_write(video, VE_CAP_WINDOW,\n\t\t\t\t   act->width << 16 | act->height);\n\t}\n\taspeed_video_write(video, VE_COMP_WINDOW,\n\t\t\t   act->width << 16 | act->height);\n\taspeed_video_write(video, VE_SRC_SCANLINE_OFFSET, act->width * 4);\n\n\t \n\tif (size < DIRECT_FETCH_THRESHOLD) {\n\t\tv4l2_dbg(1, debug, &video->v4l2_dev, \"Capture: Sync Mode\\n\");\n\t\taspeed_video_write(video, VE_TGS_0,\n\t\t\t\t   FIELD_PREP(VE_TGS_FIRST,\n\t\t\t\t\t      video->frame_left - 1) |\n\t\t\t\t   FIELD_PREP(VE_TGS_LAST,\n\t\t\t\t\t      video->frame_right));\n\t\taspeed_video_write(video, VE_TGS_1,\n\t\t\t\t   FIELD_PREP(VE_TGS_FIRST, video->frame_top) |\n\t\t\t\t   FIELD_PREP(VE_TGS_LAST,\n\t\t\t\t\t      video->frame_bottom + 1));\n\t\taspeed_video_update(video, VE_CTRL,\n\t\t\t\t    VE_CTRL_INT_DE | VE_CTRL_DIRECT_FETCH,\n\t\t\t\t    VE_CTRL_INT_DE);\n\t} else {\n\t\tv4l2_dbg(1, debug, &video->v4l2_dev, \"Capture: Direct Mode\\n\");\n\t\taspeed_video_update(video, VE_CTRL,\n\t\t\t\t    VE_CTRL_INT_DE | VE_CTRL_DIRECT_FETCH,\n\t\t\t\t    VE_CTRL_DIRECT_FETCH);\n\t}\n\n\tsize *= 4;\n\n\tif (size != video->srcs[0].size) {\n\t\tif (video->srcs[0].size)\n\t\t\taspeed_video_free_buf(video, &video->srcs[0]);\n\t\tif (video->srcs[1].size)\n\t\t\taspeed_video_free_buf(video, &video->srcs[1]);\n\n\t\tif (!aspeed_video_alloc_buf(video, &video->srcs[0], size))\n\t\t\tgoto err_mem;\n\t\tif (!aspeed_video_alloc_buf(video, &video->srcs[1], size))\n\t\t\tgoto err_mem;\n\n\t\tv4l2_dbg(1, debug, &video->v4l2_dev, \"src buf0 addr(%pad) size(%d)\\n\",\n\t\t\t &video->srcs[0].dma, video->srcs[0].size);\n\t\tv4l2_dbg(1, debug, &video->v4l2_dev, \"src buf1 addr(%pad) size(%d)\\n\",\n\t\t\t &video->srcs[1].dma, video->srcs[1].size);\n\t\taspeed_video_write(video, VE_SRC0_ADDR, video->srcs[0].dma);\n\t\taspeed_video_write(video, VE_SRC1_ADDR, video->srcs[1].dma);\n\t}\n\n\treturn;\n\nerr_mem:\n\tdev_err(video->dev, \"Failed to allocate source buffers\\n\");\n\n\tif (video->srcs[0].size)\n\t\taspeed_video_free_buf(video, &video->srcs[0]);\n}\n\nstatic void aspeed_video_update_regs(struct aspeed_video *video)\n{\n\tu8 jpeg_hq_quality = clamp((int)video->jpeg_hq_quality - 1, 0,\n\t\t\t\t   ASPEED_VIDEO_JPEG_NUM_QUALITIES - 1);\n\tu32 comp_ctrl =\tFIELD_PREP(VE_COMP_CTRL_DCT_LUM, video->jpeg_quality) |\n\t\tFIELD_PREP(VE_COMP_CTRL_DCT_CHR, video->jpeg_quality | 0x10) |\n\t\tFIELD_PREP(VE_COMP_CTRL_EN_HQ, video->hq_mode) |\n\t\tFIELD_PREP(VE_COMP_CTRL_HQ_DCT_LUM, jpeg_hq_quality) |\n\t\tFIELD_PREP(VE_COMP_CTRL_HQ_DCT_CHR, jpeg_hq_quality | 0x10);\n\tu32 ctrl = 0;\n\tu32 seq_ctrl = 0;\n\n\tv4l2_dbg(1, debug, &video->v4l2_dev, \"framerate(%d)\\n\",\n\t\t video->frame_rate);\n\tv4l2_dbg(1, debug, &video->v4l2_dev, \"jpeg format(%s) subsample(%s)\\n\",\n\t\t format_str[video->format],\n\t\t video->yuv420 ? \"420\" : \"444\");\n\tv4l2_dbg(1, debug, &video->v4l2_dev, \"compression quality(%d)\\n\",\n\t\t video->jpeg_quality);\n\tv4l2_dbg(1, debug, &video->v4l2_dev, \"hq_mode(%s) hq_quality(%d)\\n\",\n\t\t video->hq_mode ? \"on\" : \"off\", video->jpeg_hq_quality);\n\n\tif (video->format == VIDEO_FMT_ASPEED)\n\t\taspeed_video_update(video, VE_BCD_CTRL, 0, VE_BCD_CTRL_EN_BCD);\n\telse\n\t\taspeed_video_update(video, VE_BCD_CTRL, VE_BCD_CTRL_EN_BCD, 0);\n\n\tif (video->frame_rate)\n\t\tctrl |= FIELD_PREP(VE_CTRL_FRC, video->frame_rate);\n\n\tif (video->format == VIDEO_FMT_STANDARD) {\n\t\tcomp_ctrl &= ~FIELD_PREP(VE_COMP_CTRL_EN_HQ, video->hq_mode);\n\t\tseq_ctrl |= video->jpeg_mode;\n\t}\n\n\tif (video->yuv420)\n\t\tseq_ctrl |= VE_SEQ_CTRL_YUV420;\n\n\tif (video->jpeg.virt)\n\t\taspeed_video_update_jpeg_table(video->jpeg.virt, video->yuv420);\n\n\t \n\taspeed_video_update(video, VE_SEQ_CTRL,\n\t\t\t    video->jpeg_mode | VE_SEQ_CTRL_YUV420,\n\t\t\t    seq_ctrl);\n\taspeed_video_update(video, VE_CTRL, VE_CTRL_FRC, ctrl);\n\taspeed_video_update(video, VE_COMP_CTRL,\n\t\t\t    VE_COMP_CTRL_DCT_LUM | VE_COMP_CTRL_DCT_CHR |\n\t\t\t    VE_COMP_CTRL_EN_HQ | VE_COMP_CTRL_HQ_DCT_LUM |\n\t\t\t    VE_COMP_CTRL_HQ_DCT_CHR | VE_COMP_CTRL_VQ_4COLOR |\n\t\t\t    VE_COMP_CTRL_VQ_DCT_ONLY,\n\t\t\t    comp_ctrl);\n}\n\nstatic void aspeed_video_init_regs(struct aspeed_video *video)\n{\n\tu32 ctrl = VE_CTRL_AUTO_OR_CURSOR |\n\t\tFIELD_PREP(VE_CTRL_CAPTURE_FMT, VIDEO_CAP_FMT_YUV_FULL_SWING);\n\n\t \n\taspeed_video_write(video, VE_PROTECTION_KEY, VE_PROTECTION_KEY_UNLOCK);\n\n\t \n\taspeed_video_write(video, VE_INTERRUPT_CTRL, 0);\n\taspeed_video_write(video, VE_INTERRUPT_STATUS, 0xffffffff);\n\n\t \n\taspeed_video_write(video, VE_COMP_PROC_OFFSET, 0);\n\taspeed_video_write(video, VE_COMP_OFFSET, 0);\n\n\taspeed_video_write(video, VE_JPEG_ADDR, video->jpeg.dma);\n\n\t \n\taspeed_video_write(video, VE_CTRL, ctrl);\n\taspeed_video_write(video, VE_COMP_CTRL, VE_COMP_CTRL_RSVD);\n\n\t \n\taspeed_video_write(video, VE_SCALING_FACTOR, 0x10001000);\n\taspeed_video_write(video, VE_SCALING_FILTER0, 0x00200000);\n\taspeed_video_write(video, VE_SCALING_FILTER1, 0x00200000);\n\taspeed_video_write(video, VE_SCALING_FILTER2, 0x00200000);\n\taspeed_video_write(video, VE_SCALING_FILTER3, 0x00200000);\n\n\t \n\taspeed_video_write(video, VE_MODE_DETECT,\n\t\t\t   FIELD_PREP(VE_MODE_DT_HOR_TOLER, 2) |\n\t\t\t   FIELD_PREP(VE_MODE_DT_VER_TOLER, 2) |\n\t\t\t   FIELD_PREP(VE_MODE_DT_HOR_STABLE, 6) |\n\t\t\t   FIELD_PREP(VE_MODE_DT_VER_STABLE, 6) |\n\t\t\t   FIELD_PREP(VE_MODE_DT_EDG_THROD, 0x65));\n\n\taspeed_video_write(video, VE_BCD_CTRL, 0);\n}\n\nstatic void aspeed_video_start(struct aspeed_video *video)\n{\n\taspeed_video_on(video);\n\n\taspeed_video_init_regs(video);\n\n\t \n\taspeed_video_get_resolution(video);\n\n\t \n\tvideo->active_timings = video->detected_timings;\n\taspeed_video_set_resolution(video);\n\n\tvideo->pix_fmt.width = video->active_timings.width;\n\tvideo->pix_fmt.height = video->active_timings.height;\n\tvideo->pix_fmt.sizeimage = video->max_compressed_size;\n}\n\nstatic void aspeed_video_stop(struct aspeed_video *video)\n{\n\tset_bit(VIDEO_STOPPED, &video->flags);\n\tcancel_delayed_work_sync(&video->res_work);\n\n\taspeed_video_off(video);\n\n\tif (video->srcs[0].size)\n\t\taspeed_video_free_buf(video, &video->srcs[0]);\n\n\tif (video->srcs[1].size)\n\t\taspeed_video_free_buf(video, &video->srcs[1]);\n\n\tif (video->bcd.size)\n\t\taspeed_video_free_buf(video, &video->bcd);\n\n\tvideo->v4l2_input_status = V4L2_IN_ST_NO_SIGNAL;\n\tvideo->flags = 0;\n}\n\nstatic int aspeed_video_querycap(struct file *file, void *fh,\n\t\t\t\t struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, DEVICE_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, \"Aspeed Video Engine\", sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info), \"platform:%s\",\n\t\t DEVICE_NAME);\n\n\treturn 0;\n}\n\nstatic int aspeed_video_enum_format(struct file *file, void *fh,\n\t\t\t\t    struct v4l2_fmtdesc *f)\n{\n\tstruct aspeed_video *video = video_drvdata(file);\n\n\tif (f->index)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = video->pix_fmt.pixelformat;\n\n\treturn 0;\n}\n\nstatic int aspeed_video_get_format(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_format *f)\n{\n\tstruct aspeed_video *video = video_drvdata(file);\n\n\tf->fmt.pix = video->pix_fmt;\n\n\treturn 0;\n}\n\nstatic int aspeed_video_set_format(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_format *f)\n{\n\tstruct aspeed_video *video = video_drvdata(file);\n\n\tif (vb2_is_busy(&video->queue))\n\t\treturn -EBUSY;\n\n\tswitch (f->fmt.pix.pixelformat) {\n\tcase V4L2_PIX_FMT_JPEG:\n\t\tvideo->format = VIDEO_FMT_STANDARD;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_AJPG:\n\t\tvideo->format = VIDEO_FMT_ASPEED;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tvideo->pix_fmt.pixelformat = f->fmt.pix.pixelformat;\n\n\treturn 0;\n}\n\nstatic int aspeed_video_enum_input(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_input *inp)\n{\n\tstruct aspeed_video *video = video_drvdata(file);\n\n\tif (inp->index)\n\t\treturn -EINVAL;\n\n\tstrscpy(inp->name, \"Host VGA capture\", sizeof(inp->name));\n\tinp->type = V4L2_INPUT_TYPE_CAMERA;\n\tinp->capabilities = V4L2_IN_CAP_DV_TIMINGS;\n\tinp->status = video->v4l2_input_status;\n\n\treturn 0;\n}\n\nstatic int aspeed_video_get_input(struct file *file, void *fh, unsigned int *i)\n{\n\t*i = 0;\n\n\treturn 0;\n}\n\nstatic int aspeed_video_set_input(struct file *file, void *fh, unsigned int i)\n{\n\tif (i)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int aspeed_video_get_parm(struct file *file, void *fh,\n\t\t\t\t struct v4l2_streamparm *a)\n{\n\tstruct aspeed_video *video = video_drvdata(file);\n\n\ta->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\n\ta->parm.capture.readbuffers = ASPEED_VIDEO_V4L2_MIN_BUF_REQ;\n\ta->parm.capture.timeperframe.numerator = 1;\n\tif (!video->frame_rate)\n\t\ta->parm.capture.timeperframe.denominator = MAX_FRAME_RATE;\n\telse\n\t\ta->parm.capture.timeperframe.denominator = video->frame_rate;\n\n\treturn 0;\n}\n\nstatic int aspeed_video_set_parm(struct file *file, void *fh,\n\t\t\t\t struct v4l2_streamparm *a)\n{\n\tunsigned int frame_rate = 0;\n\tstruct aspeed_video *video = video_drvdata(file);\n\n\ta->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\n\ta->parm.capture.readbuffers = ASPEED_VIDEO_V4L2_MIN_BUF_REQ;\n\n\tif (a->parm.capture.timeperframe.numerator)\n\t\tframe_rate = a->parm.capture.timeperframe.denominator /\n\t\t\ta->parm.capture.timeperframe.numerator;\n\n\tif (!frame_rate || frame_rate > MAX_FRAME_RATE) {\n\t\tframe_rate = 0;\n\t\ta->parm.capture.timeperframe.denominator = MAX_FRAME_RATE;\n\t\ta->parm.capture.timeperframe.numerator = 1;\n\t}\n\n\tif (video->frame_rate != frame_rate) {\n\t\tvideo->frame_rate = frame_rate;\n\t\taspeed_video_update(video, VE_CTRL, VE_CTRL_FRC,\n\t\t\t\t    FIELD_PREP(VE_CTRL_FRC, frame_rate));\n\t}\n\n\treturn 0;\n}\n\nstatic int aspeed_video_enum_framesizes(struct file *file, void *fh,\n\t\t\t\t\tstruct v4l2_frmsizeenum *fsize)\n{\n\tstruct aspeed_video *video = video_drvdata(file);\n\n\tif (fsize->index)\n\t\treturn -EINVAL;\n\n\tif (fsize->pixel_format != V4L2_PIX_FMT_JPEG)\n\t\treturn -EINVAL;\n\n\tfsize->discrete.width = video->pix_fmt.width;\n\tfsize->discrete.height = video->pix_fmt.height;\n\tfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\n\treturn 0;\n}\n\nstatic int aspeed_video_enum_frameintervals(struct file *file, void *fh,\n\t\t\t\t\t    struct v4l2_frmivalenum *fival)\n{\n\tstruct aspeed_video *video = video_drvdata(file);\n\n\tif (fival->index)\n\t\treturn -EINVAL;\n\n\tif (fival->width != video->detected_timings.width ||\n\t    fival->height != video->detected_timings.height)\n\t\treturn -EINVAL;\n\n\tif (fival->pixel_format != V4L2_PIX_FMT_JPEG)\n\t\treturn -EINVAL;\n\n\tfival->type = V4L2_FRMIVAL_TYPE_CONTINUOUS;\n\n\tfival->stepwise.min.denominator = MAX_FRAME_RATE;\n\tfival->stepwise.min.numerator = 1;\n\tfival->stepwise.max.denominator = 1;\n\tfival->stepwise.max.numerator = 1;\n\tfival->stepwise.step = fival->stepwise.max;\n\n\treturn 0;\n}\n\nstatic int aspeed_video_set_dv_timings(struct file *file, void *fh,\n\t\t\t\t       struct v4l2_dv_timings *timings)\n{\n\tstruct aspeed_video *video = video_drvdata(file);\n\n\tif (timings->bt.width == video->active_timings.width &&\n\t    timings->bt.height == video->active_timings.height)\n\t\treturn 0;\n\n\tif (vb2_is_busy(&video->queue))\n\t\treturn -EBUSY;\n\n\tvideo->active_timings = timings->bt;\n\n\taspeed_video_set_resolution(video);\n\n\tvideo->pix_fmt.width = timings->bt.width;\n\tvideo->pix_fmt.height = timings->bt.height;\n\tvideo->pix_fmt.sizeimage = video->max_compressed_size;\n\n\ttimings->type = V4L2_DV_BT_656_1120;\n\n\tv4l2_dbg(1, debug, &video->v4l2_dev, \"set new timings(%dx%d)\\n\",\n\t\t timings->bt.width, timings->bt.height);\n\n\treturn 0;\n}\n\nstatic int aspeed_video_get_dv_timings(struct file *file, void *fh,\n\t\t\t\t       struct v4l2_dv_timings *timings)\n{\n\tstruct aspeed_video *video = video_drvdata(file);\n\n\ttimings->type = V4L2_DV_BT_656_1120;\n\ttimings->bt = video->active_timings;\n\n\treturn 0;\n}\n\nstatic int aspeed_video_query_dv_timings(struct file *file, void *fh,\n\t\t\t\t\t struct v4l2_dv_timings *timings)\n{\n\tint rc;\n\tstruct aspeed_video *video = video_drvdata(file);\n\n\t \n\tif (file->f_flags & O_NONBLOCK) {\n\t\tif (test_bit(VIDEO_RES_CHANGE, &video->flags))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\trc = wait_event_interruptible(video->wait,\n\t\t\t\t\t      !test_bit(VIDEO_RES_CHANGE,\n\t\t\t\t\t\t\t&video->flags));\n\t\tif (rc)\n\t\t\treturn -EINTR;\n\t}\n\n\ttimings->type = V4L2_DV_BT_656_1120;\n\ttimings->bt = video->detected_timings;\n\n\treturn video->v4l2_input_status ? -ENOLINK : 0;\n}\n\nstatic int aspeed_video_enum_dv_timings(struct file *file, void *fh,\n\t\t\t\t\tstruct v4l2_enum_dv_timings *timings)\n{\n\treturn v4l2_enum_dv_timings_cap(timings, &aspeed_video_timings_cap,\n\t\t\t\t\tNULL, NULL);\n}\n\nstatic int aspeed_video_dv_timings_cap(struct file *file, void *fh,\n\t\t\t\t       struct v4l2_dv_timings_cap *cap)\n{\n\t*cap = aspeed_video_timings_cap;\n\n\treturn 0;\n}\n\nstatic int aspeed_video_sub_event(struct v4l2_fh *fh,\n\t\t\t\t  const struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\treturn v4l2_src_change_event_subscribe(fh, sub);\n\t}\n\n\treturn v4l2_ctrl_subscribe_event(fh, sub);\n}\n\nstatic const struct v4l2_ioctl_ops aspeed_video_ioctl_ops = {\n\t.vidioc_querycap = aspeed_video_querycap,\n\n\t.vidioc_enum_fmt_vid_cap = aspeed_video_enum_format,\n\t.vidioc_g_fmt_vid_cap = aspeed_video_get_format,\n\t.vidioc_s_fmt_vid_cap = aspeed_video_set_format,\n\t.vidioc_try_fmt_vid_cap = aspeed_video_get_format,\n\n\t.vidioc_reqbufs = vb2_ioctl_reqbufs,\n\t.vidioc_querybuf = vb2_ioctl_querybuf,\n\t.vidioc_qbuf = vb2_ioctl_qbuf,\n\t.vidioc_expbuf = vb2_ioctl_expbuf,\n\t.vidioc_dqbuf = vb2_ioctl_dqbuf,\n\t.vidioc_create_bufs = vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf = vb2_ioctl_prepare_buf,\n\t.vidioc_streamon = vb2_ioctl_streamon,\n\t.vidioc_streamoff = vb2_ioctl_streamoff,\n\n\t.vidioc_enum_input = aspeed_video_enum_input,\n\t.vidioc_g_input = aspeed_video_get_input,\n\t.vidioc_s_input = aspeed_video_set_input,\n\n\t.vidioc_g_parm = aspeed_video_get_parm,\n\t.vidioc_s_parm = aspeed_video_set_parm,\n\t.vidioc_enum_framesizes = aspeed_video_enum_framesizes,\n\t.vidioc_enum_frameintervals = aspeed_video_enum_frameintervals,\n\n\t.vidioc_s_dv_timings = aspeed_video_set_dv_timings,\n\t.vidioc_g_dv_timings = aspeed_video_get_dv_timings,\n\t.vidioc_query_dv_timings = aspeed_video_query_dv_timings,\n\t.vidioc_enum_dv_timings = aspeed_video_enum_dv_timings,\n\t.vidioc_dv_timings_cap = aspeed_video_dv_timings_cap,\n\n\t.vidioc_subscribe_event = aspeed_video_sub_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic int aspeed_video_set_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct aspeed_video *video = container_of(ctrl->handler,\n\t\t\t\t\t\t  struct aspeed_video,\n\t\t\t\t\t\t  ctrl_handler);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_JPEG_COMPRESSION_QUALITY:\n\t\tvideo->jpeg_quality = ctrl->val;\n\t\tif (test_bit(VIDEO_STREAMING, &video->flags))\n\t\t\taspeed_video_update_regs(video);\n\t\tbreak;\n\tcase V4L2_CID_JPEG_CHROMA_SUBSAMPLING:\n\t\tvideo->yuv420 = (ctrl->val == V4L2_JPEG_CHROMA_SUBSAMPLING_420);\n\t\tif (test_bit(VIDEO_STREAMING, &video->flags))\n\t\t\taspeed_video_update_regs(video);\n\t\tbreak;\n\tcase V4L2_CID_ASPEED_HQ_MODE:\n\t\tvideo->hq_mode = ctrl->val;\n\t\tif (test_bit(VIDEO_STREAMING, &video->flags))\n\t\t\taspeed_video_update_regs(video);\n\t\tbreak;\n\tcase V4L2_CID_ASPEED_HQ_JPEG_QUALITY:\n\t\tvideo->jpeg_hq_quality = ctrl->val;\n\t\tif (test_bit(VIDEO_STREAMING, &video->flags))\n\t\t\taspeed_video_update_regs(video);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops aspeed_video_ctrl_ops = {\n\t.s_ctrl = aspeed_video_set_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config aspeed_ctrl_HQ_mode = {\n\t.ops = &aspeed_video_ctrl_ops,\n\t.id = V4L2_CID_ASPEED_HQ_MODE,\n\t.name = \"Aspeed HQ Mode\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.min = false,\n\t.max = true,\n\t.step = 1,\n\t.def = false,\n};\n\nstatic const struct v4l2_ctrl_config aspeed_ctrl_HQ_jpeg_quality = {\n\t.ops = &aspeed_video_ctrl_ops,\n\t.id = V4L2_CID_ASPEED_HQ_JPEG_QUALITY,\n\t.name = \"Aspeed HQ Quality\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.min = 1,\n\t.max = ASPEED_VIDEO_JPEG_NUM_QUALITIES,\n\t.step = 1,\n\t.def = 1,\n};\n\nstatic void aspeed_video_resolution_work(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct aspeed_video *video = container_of(dwork, struct aspeed_video,\n\t\t\t\t\t\t  res_work);\n\n\taspeed_video_on(video);\n\n\t \n\tif (test_bit(VIDEO_STOPPED, &video->flags))\n\t\tgoto done;\n\n\taspeed_video_init_regs(video);\n\n\taspeed_video_update_regs(video);\n\n\taspeed_video_get_resolution(video);\n\n\tif (video->detected_timings.width != video->active_timings.width ||\n\t    video->detected_timings.height != video->active_timings.height) {\n\t\tstatic const struct v4l2_event ev = {\n\t\t\t.type = V4L2_EVENT_SOURCE_CHANGE,\n\t\t\t.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,\n\t\t};\n\n\t\tv4l2_dbg(1, debug, &video->v4l2_dev, \"fire source change event\\n\");\n\t\tv4l2_event_queue(&video->vdev, &ev);\n\t} else if (test_bit(VIDEO_STREAMING, &video->flags)) {\n\t\t \n\t\taspeed_video_start_frame(video);\n\t}\n\ndone:\n\tclear_bit(VIDEO_RES_CHANGE, &video->flags);\n\twake_up_interruptible_all(&video->wait);\n}\n\nstatic int aspeed_video_open(struct file *file)\n{\n\tint rc;\n\tstruct aspeed_video *video = video_drvdata(file);\n\n\tmutex_lock(&video->video_lock);\n\n\trc = v4l2_fh_open(file);\n\tif (rc) {\n\t\tmutex_unlock(&video->video_lock);\n\t\treturn rc;\n\t}\n\n\tif (v4l2_fh_is_singular_file(file))\n\t\taspeed_video_start(video);\n\n\tmutex_unlock(&video->video_lock);\n\n\treturn 0;\n}\n\nstatic int aspeed_video_release(struct file *file)\n{\n\tint rc;\n\tstruct aspeed_video *video = video_drvdata(file);\n\n\tmutex_lock(&video->video_lock);\n\n\tif (v4l2_fh_is_singular_file(file))\n\t\taspeed_video_stop(video);\n\n\trc = _vb2_fop_release(file, NULL);\n\n\tmutex_unlock(&video->video_lock);\n\n\treturn rc;\n}\n\nstatic const struct v4l2_file_operations aspeed_video_v4l2_fops = {\n\t.owner = THIS_MODULE,\n\t.read = vb2_fop_read,\n\t.poll = vb2_fop_poll,\n\t.unlocked_ioctl = video_ioctl2,\n\t.mmap = vb2_fop_mmap,\n\t.open = aspeed_video_open,\n\t.release = aspeed_video_release,\n};\n\nstatic int aspeed_video_queue_setup(struct vb2_queue *q,\n\t\t\t\t    unsigned int *num_buffers,\n\t\t\t\t    unsigned int *num_planes,\n\t\t\t\t    unsigned int sizes[],\n\t\t\t\t    struct device *alloc_devs[])\n{\n\tstruct aspeed_video *video = vb2_get_drv_priv(q);\n\n\tif (*num_planes) {\n\t\tif (sizes[0] < video->max_compressed_size)\n\t\t\treturn -EINVAL;\n\n\t\treturn 0;\n\t}\n\n\t*num_planes = 1;\n\tsizes[0] = video->max_compressed_size;\n\n\treturn 0;\n}\n\nstatic int aspeed_video_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct aspeed_video *video = vb2_get_drv_priv(vb->vb2_queue);\n\n\tif (vb2_plane_size(vb, 0) < video->max_compressed_size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int aspeed_video_start_streaming(struct vb2_queue *q,\n\t\t\t\t\tunsigned int count)\n{\n\tint rc;\n\tstruct aspeed_video *video = vb2_get_drv_priv(q);\n\n\tvideo->sequence = 0;\n\tvideo->perf.duration_max = 0;\n\tvideo->perf.duration_min = 0xffffffff;\n\n\taspeed_video_update_regs(video);\n\n\trc = aspeed_video_start_frame(video);\n\tif (rc) {\n\t\taspeed_video_bufs_done(video, VB2_BUF_STATE_QUEUED);\n\t\treturn rc;\n\t}\n\n\tset_bit(VIDEO_STREAMING, &video->flags);\n\treturn 0;\n}\n\nstatic void aspeed_video_stop_streaming(struct vb2_queue *q)\n{\n\tint rc;\n\tstruct aspeed_video *video = vb2_get_drv_priv(q);\n\n\tclear_bit(VIDEO_STREAMING, &video->flags);\n\n\trc = wait_event_timeout(video->wait,\n\t\t\t\t!test_bit(VIDEO_FRAME_INPRG, &video->flags),\n\t\t\t\tSTOP_TIMEOUT);\n\tif (!rc) {\n\t\tv4l2_dbg(1, debug, &video->v4l2_dev, \"Timed out when stopping streaming\\n\");\n\n\t\t \n\t\taspeed_video_off(video);\n\t\taspeed_video_on(video);\n\n\t\taspeed_video_init_regs(video);\n\n\t\taspeed_video_get_resolution(video);\n\t}\n\n\taspeed_video_bufs_done(video, VB2_BUF_STATE_ERROR);\n}\n\nstatic void aspeed_video_buf_queue(struct vb2_buffer *vb)\n{\n\tbool empty;\n\tstruct aspeed_video *video = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct aspeed_video_buffer *avb = to_aspeed_video_buffer(vbuf);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&video->lock, flags);\n\tempty = list_empty(&video->buffers);\n\tlist_add_tail(&avb->link, &video->buffers);\n\tspin_unlock_irqrestore(&video->lock, flags);\n\n\tif (test_bit(VIDEO_STREAMING, &video->flags) &&\n\t    !test_bit(VIDEO_FRAME_INPRG, &video->flags) && empty)\n\t\taspeed_video_start_frame(video);\n}\n\nstatic const struct vb2_ops aspeed_video_vb2_ops = {\n\t.queue_setup = aspeed_video_queue_setup,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n\t.buf_prepare = aspeed_video_buf_prepare,\n\t.start_streaming = aspeed_video_start_streaming,\n\t.stop_streaming = aspeed_video_stop_streaming,\n\t.buf_queue =  aspeed_video_buf_queue,\n};\n\n#ifdef CONFIG_DEBUG_FS\nstatic int aspeed_video_debugfs_show(struct seq_file *s, void *data)\n{\n\tstruct aspeed_video *v = s->private;\n\tu32 val08;\n\n\tseq_puts(s, \"\\n\");\n\n\tseq_puts(s, \"Capture:\\n\");\n\tval08 = aspeed_video_read(v, VE_CTRL);\n\tif (FIELD_GET(VE_CTRL_DIRECT_FETCH, val08)) {\n\t\tseq_printf(s, \"  %-20s:\\tDirect fetch\\n\", \"Mode\");\n\t\tseq_printf(s, \"  %-20s:\\t%s\\n\", \"VGA bpp mode\",\n\t\t\t   FIELD_GET(VE_CTRL_INT_DE, val08) ? \"16\" : \"32\");\n\t} else {\n\t\tseq_printf(s, \"  %-20s:\\tSync\\n\", \"Mode\");\n\t\tseq_printf(s, \"  %-20s:\\t%s\\n\", \"Video source\",\n\t\t\t   FIELD_GET(VE_CTRL_SOURCE, val08) ?\n\t\t\t   \"external\" : \"internal\");\n\t\tseq_printf(s, \"  %-20s:\\t%s\\n\", \"DE source\",\n\t\t\t   FIELD_GET(VE_CTRL_INT_DE, val08) ?\n\t\t\t   \"internal\" : \"external\");\n\t\tseq_printf(s, \"  %-20s:\\t%s\\n\", \"Cursor overlay\",\n\t\t\t   FIELD_GET(VE_CTRL_AUTO_OR_CURSOR, val08) ?\n\t\t\t   \"Without\" : \"With\");\n\t}\n\n\tseq_printf(s, \"  %-20s:\\t%s\\n\", \"Signal\",\n\t\t   v->v4l2_input_status ? \"Unlock\" : \"Lock\");\n\tseq_printf(s, \"  %-20s:\\t%d\\n\", \"Width\", v->pix_fmt.width);\n\tseq_printf(s, \"  %-20s:\\t%d\\n\", \"Height\", v->pix_fmt.height);\n\tseq_printf(s, \"  %-20s:\\t%d\\n\", \"FRC\", v->frame_rate);\n\n\tseq_puts(s, \"\\n\");\n\n\tseq_puts(s, \"Compression:\\n\");\n\tseq_printf(s, \"  %-20s:\\t%s\\n\", \"Format\", format_str[v->format]);\n\tseq_printf(s, \"  %-20s:\\t%s\\n\", \"Subsampling\",\n\t\t   v->yuv420 ? \"420\" : \"444\");\n\tseq_printf(s, \"  %-20s:\\t%d\\n\", \"Quality\", v->jpeg_quality);\n\tif (v->format == VIDEO_FMT_ASPEED) {\n\t\tseq_printf(s, \"  %-20s:\\t%s\\n\", \"HQ Mode\",\n\t\t\t   v->hq_mode ? \"on\" : \"off\");\n\t\tseq_printf(s, \"  %-20s:\\t%d\\n\", \"HQ Quality\",\n\t\t\t   v->hq_mode ? v->jpeg_hq_quality : 0);\n\t}\n\n\tseq_puts(s, \"\\n\");\n\n\tseq_puts(s, \"Performance:\\n\");\n\tseq_printf(s, \"  %-20s:\\t%d\\n\", \"Frame#\", v->sequence);\n\tseq_printf(s, \"  %-20s:\\n\", \"Frame Duration(ms)\");\n\tseq_printf(s, \"    %-18s:\\t%d\\n\", \"Now\", v->perf.duration);\n\tseq_printf(s, \"    %-18s:\\t%d\\n\", \"Min\", v->perf.duration_min);\n\tseq_printf(s, \"    %-18s:\\t%d\\n\", \"Max\", v->perf.duration_max);\n\tseq_printf(s, \"  %-20s:\\t%d\\n\", \"FPS\",\n\t\t   (v->perf.totaltime && v->sequence) ?\n\t\t   1000 / (v->perf.totaltime / v->sequence) : 0);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(aspeed_video_debugfs);\n\nstatic struct dentry *debugfs_entry;\n\nstatic void aspeed_video_debugfs_remove(struct aspeed_video *video)\n{\n\tdebugfs_remove_recursive(debugfs_entry);\n\tdebugfs_entry = NULL;\n}\n\nstatic int aspeed_video_debugfs_create(struct aspeed_video *video)\n{\n\tdebugfs_entry = debugfs_create_file(DEVICE_NAME, 0444, NULL,\n\t\t\t\t\t    video,\n\t\t\t\t\t    &aspeed_video_debugfs_fops);\n\tif (!debugfs_entry)\n\t\taspeed_video_debugfs_remove(video);\n\n\treturn !debugfs_entry ? -EIO : 0;\n}\n#else\nstatic void aspeed_video_debugfs_remove(struct aspeed_video *video) { }\nstatic int aspeed_video_debugfs_create(struct aspeed_video *video)\n{\n\treturn 0;\n}\n#endif  \n\nstatic int aspeed_video_setup_video(struct aspeed_video *video)\n{\n\tconst u64 mask = ~(BIT(V4L2_JPEG_CHROMA_SUBSAMPLING_444) |\n\t\t\t   BIT(V4L2_JPEG_CHROMA_SUBSAMPLING_420));\n\tstruct v4l2_device *v4l2_dev = &video->v4l2_dev;\n\tstruct vb2_queue *vbq = &video->queue;\n\tstruct video_device *vdev = &video->vdev;\n\tstruct v4l2_ctrl_handler *hdl = &video->ctrl_handler;\n\tint rc;\n\n\tvideo->pix_fmt.pixelformat = V4L2_PIX_FMT_JPEG;\n\tvideo->pix_fmt.field = V4L2_FIELD_NONE;\n\tvideo->pix_fmt.colorspace = V4L2_COLORSPACE_SRGB;\n\tvideo->pix_fmt.quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\tvideo->v4l2_input_status = V4L2_IN_ST_NO_SIGNAL;\n\n\trc = v4l2_device_register(video->dev, v4l2_dev);\n\tif (rc) {\n\t\tdev_err(video->dev, \"Failed to register v4l2 device\\n\");\n\t\treturn rc;\n\t}\n\n\tv4l2_ctrl_handler_init(hdl, 4);\n\tv4l2_ctrl_new_std(hdl, &aspeed_video_ctrl_ops,\n\t\t\t  V4L2_CID_JPEG_COMPRESSION_QUALITY, 0,\n\t\t\t  ASPEED_VIDEO_JPEG_NUM_QUALITIES - 1, 1, 0);\n\tv4l2_ctrl_new_std_menu(hdl, &aspeed_video_ctrl_ops,\n\t\t\t       V4L2_CID_JPEG_CHROMA_SUBSAMPLING,\n\t\t\t       V4L2_JPEG_CHROMA_SUBSAMPLING_420, mask,\n\t\t\t       V4L2_JPEG_CHROMA_SUBSAMPLING_444);\n\tv4l2_ctrl_new_custom(hdl, &aspeed_ctrl_HQ_mode, NULL);\n\tv4l2_ctrl_new_custom(hdl, &aspeed_ctrl_HQ_jpeg_quality, NULL);\n\n\trc = hdl->error;\n\tif (rc) {\n\t\tv4l2_ctrl_handler_free(&video->ctrl_handler);\n\t\tv4l2_device_unregister(v4l2_dev);\n\n\t\tdev_err(video->dev, \"Failed to init controls: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tv4l2_dev->ctrl_handler = hdl;\n\n\tvbq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tvbq->io_modes = VB2_MMAP | VB2_READ | VB2_DMABUF;\n\tvbq->dev = v4l2_dev->dev;\n\tvbq->lock = &video->video_lock;\n\tvbq->ops = &aspeed_video_vb2_ops;\n\tvbq->mem_ops = &vb2_dma_contig_memops;\n\tvbq->drv_priv = video;\n\tvbq->buf_struct_size = sizeof(struct aspeed_video_buffer);\n\tvbq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tvbq->min_buffers_needed = ASPEED_VIDEO_V4L2_MIN_BUF_REQ;\n\n\trc = vb2_queue_init(vbq);\n\tif (rc) {\n\t\tv4l2_ctrl_handler_free(&video->ctrl_handler);\n\t\tv4l2_device_unregister(v4l2_dev);\n\n\t\tdev_err(video->dev, \"Failed to init vb2 queue\\n\");\n\t\treturn rc;\n\t}\n\n\tvdev->queue = vbq;\n\tvdev->fops = &aspeed_video_v4l2_fops;\n\tvdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\n\t\tV4L2_CAP_STREAMING;\n\tvdev->v4l2_dev = v4l2_dev;\n\tstrscpy(vdev->name, DEVICE_NAME, sizeof(vdev->name));\n\tvdev->vfl_type = VFL_TYPE_VIDEO;\n\tvdev->vfl_dir = VFL_DIR_RX;\n\tvdev->release = video_device_release_empty;\n\tvdev->ioctl_ops = &aspeed_video_ioctl_ops;\n\tvdev->lock = &video->video_lock;\n\n\tvideo_set_drvdata(vdev, video);\n\trc = video_register_device(vdev, VFL_TYPE_VIDEO, 0);\n\tif (rc) {\n\t\tv4l2_ctrl_handler_free(&video->ctrl_handler);\n\t\tv4l2_device_unregister(v4l2_dev);\n\n\t\tdev_err(video->dev, \"Failed to register video device\\n\");\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int aspeed_video_init(struct aspeed_video *video)\n{\n\tint irq;\n\tint rc;\n\tstruct device *dev = video->dev;\n\n\tirq = irq_of_parse_and_map(dev->of_node, 0);\n\tif (!irq) {\n\t\tdev_err(dev, \"Unable to find IRQ\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trc = devm_request_threaded_irq(dev, irq, NULL, aspeed_video_irq,\n\t\t\t\t       IRQF_ONESHOT, DEVICE_NAME, video);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Unable to request IRQ %d\\n\", irq);\n\t\treturn rc;\n\t}\n\tdev_info(video->dev, \"irq %d\\n\", irq);\n\n\tvideo->eclk = devm_clk_get(dev, \"eclk\");\n\tif (IS_ERR(video->eclk)) {\n\t\tdev_err(dev, \"Unable to get ECLK\\n\");\n\t\treturn PTR_ERR(video->eclk);\n\t}\n\n\trc = clk_prepare(video->eclk);\n\tif (rc)\n\t\treturn rc;\n\n\tvideo->vclk = devm_clk_get(dev, \"vclk\");\n\tif (IS_ERR(video->vclk)) {\n\t\tdev_err(dev, \"Unable to get VCLK\\n\");\n\t\trc = PTR_ERR(video->vclk);\n\t\tgoto err_unprepare_eclk;\n\t}\n\n\trc = clk_prepare(video->vclk);\n\tif (rc)\n\t\tgoto err_unprepare_eclk;\n\n\tof_reserved_mem_device_init(dev);\n\n\trc = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\tif (rc) {\n\t\tdev_err(dev, \"Failed to set DMA mask\\n\");\n\t\tgoto err_release_reserved_mem;\n\t}\n\n\tif (!aspeed_video_alloc_buf(video, &video->jpeg,\n\t\t\t\t    VE_JPEG_HEADER_SIZE)) {\n\t\tdev_err(dev, \"Failed to allocate DMA for JPEG header\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_release_reserved_mem;\n\t}\n\tdev_info(video->dev, \"alloc mem size(%d) at %pad for jpeg header\\n\",\n\t\t VE_JPEG_HEADER_SIZE, &video->jpeg.dma);\n\n\taspeed_video_init_jpeg_table(video->jpeg.virt, video->yuv420);\n\n\treturn 0;\n\nerr_release_reserved_mem:\n\tof_reserved_mem_device_release(dev);\n\tclk_unprepare(video->vclk);\nerr_unprepare_eclk:\n\tclk_unprepare(video->eclk);\n\n\treturn rc;\n}\n\nstatic const struct of_device_id aspeed_video_of_match[] = {\n\t{ .compatible = \"aspeed,ast2400-video-engine\", .data = &ast2400_config },\n\t{ .compatible = \"aspeed,ast2500-video-engine\", .data = &ast2500_config },\n\t{ .compatible = \"aspeed,ast2600-video-engine\", .data = &ast2600_config },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, aspeed_video_of_match);\n\nstatic int aspeed_video_probe(struct platform_device *pdev)\n{\n\tconst struct aspeed_video_config *config;\n\tstruct aspeed_video *video;\n\tint rc;\n\n\tvideo = devm_kzalloc(&pdev->dev, sizeof(*video), GFP_KERNEL);\n\tif (!video)\n\t\treturn -ENOMEM;\n\n\tvideo->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(video->base))\n\t\treturn PTR_ERR(video->base);\n\n\tconfig = of_device_get_match_data(&pdev->dev);\n\tif (!config)\n\t\treturn -ENODEV;\n\n\tvideo->jpeg_mode = config->jpeg_mode;\n\tvideo->comp_size_read = config->comp_size_read;\n\n\tvideo->frame_rate = 30;\n\tvideo->jpeg_hq_quality = 1;\n\tvideo->dev = &pdev->dev;\n\tspin_lock_init(&video->lock);\n\tmutex_init(&video->video_lock);\n\tinit_waitqueue_head(&video->wait);\n\tINIT_DELAYED_WORK(&video->res_work, aspeed_video_resolution_work);\n\tINIT_LIST_HEAD(&video->buffers);\n\n\trc = aspeed_video_init(video);\n\tif (rc)\n\t\treturn rc;\n\n\trc = aspeed_video_setup_video(video);\n\tif (rc) {\n\t\taspeed_video_free_buf(video, &video->jpeg);\n\t\tclk_unprepare(video->vclk);\n\t\tclk_unprepare(video->eclk);\n\t\treturn rc;\n\t}\n\n\trc = aspeed_video_debugfs_create(video);\n\tif (rc)\n\t\tdev_err(video->dev, \"debugfs create failed\\n\");\n\n\treturn 0;\n}\n\nstatic void aspeed_video_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct v4l2_device *v4l2_dev = dev_get_drvdata(dev);\n\tstruct aspeed_video *video = to_aspeed_video(v4l2_dev);\n\n\taspeed_video_off(video);\n\n\taspeed_video_debugfs_remove(video);\n\n\tclk_unprepare(video->vclk);\n\tclk_unprepare(video->eclk);\n\n\tvb2_video_unregister_device(&video->vdev);\n\n\tv4l2_ctrl_handler_free(&video->ctrl_handler);\n\n\tv4l2_device_unregister(v4l2_dev);\n\n\taspeed_video_free_buf(video, &video->jpeg);\n\n\tof_reserved_mem_device_release(dev);\n}\n\nstatic struct platform_driver aspeed_video_driver = {\n\t.driver = {\n\t\t.name = DEVICE_NAME,\n\t\t.of_match_table = aspeed_video_of_match,\n\t},\n\t.probe = aspeed_video_probe,\n\t.remove_new = aspeed_video_remove,\n};\n\nmodule_platform_driver(aspeed_video_driver);\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Debug level (0=off,1=info,2=debug,3=reg ops)\");\n\nMODULE_DESCRIPTION(\"ASPEED Video Engine Driver\");\nMODULE_AUTHOR(\"Eddie James\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}